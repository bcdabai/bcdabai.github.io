<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Logstash——配置介绍，数据输入配置（input） - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Logstash——配置介绍，数据输入配置（input）" />
<meta property="og:description" content="之前介绍过如何使用文件系统通过Logstash将数据推送至elasticsearch来实现日志的线上分析 安装Logstash并完成一个简单的日志收集功能。而Logstash所支持的数据源远远不止这些，这里对Logstash的数据输入配置进行一个介绍。
Logstash——配置介绍，数据输入配置（input）
Logstash——Logstash从MySQL中收集数据并输出添加
Logstash——Logstash从Redis中收集数据并输出
Logstash配置内容 Logstash的配置主要分为三部分：数据输入部分、数据处理部分、数据输出部分。这三部分的定义覆盖了数据整个的生命周期。这一篇主要介绍数据输入部分
数据输入 数据输入部分的配置定义在input内容下
一个简单的示例
input { stdin {} syslog {} } 支持的数据来源 Logstash提供了一个非常长的数据来源支持列表，目前最新版的Logstash可以从下面渠道里面获得数据
输入插件支持内容azure_event_hubs从Azure事件中心接收事件beats从Elastic Beats框架接收事件cloudwatch从Amazon Web Services CloudWatch API提取事件couchdb_changes从CouchDB的_changesURI 流事件dead_letter_queue从Logstash的死信队列中读取事件elasticsearch从Elasticsearch集群读取查询结果exec将shell命令的输出捕获为事件file从文件流事件ganglia通过UDP读取Ganglia数据包gelf从Graylog2读取GELF格式的消息作为事件generator生成用于测试目的的随机日志事件github从GitHub Webhook读取事件google_cloud_storage从Google Cloud Storage存储桶中的文件中提取事件google_pubsub消费来自Google Cloud PubSub服务的事件graphite从graphite工具读取指标heartbeat生成心跳事件以进行测试http通过HTTP或HTTPS接收事件http_poller将HTTP API的输出解码为事件imap从IMAP服务器读取邮件irc从IRC服务器读取事件java_generator生成综合日志事件java_stdin从标准输入读取事件jdbc从JDBC数据创建事件jms从Jms Broker读取事件jmx通过JMX从远程Java应用程序检索指标kafka读取来自Kafka主题的事件kinesis通过AWS Kinesis流接收事件log4j从Log4j SocketAppender对象通过TCP套接字读取事件lumberjack使用Lumberjack协议接收事件meetup将命令行工具的输出捕获为事件pipe从长时间运行的命令管道流式传输事件puppet_facter接收来自Puppet服务器的事件rabbitmq从RabbitMQ交换中提取事件redis从Redis实例读取事件relp通过TCP套接字接收RELP事件rss将命令行工具的输出捕获为事件s3从S3存储桶中的文件流式传输事件s3_sns_sqs使用sqs从AWS S3存储桶读取日志salesforce根据Salesforce SOQL查询创建事件snmp使用简单网络管理协议（SNMP）轮询网络设备snmptrap根据SNMP陷阱消息创建事件sqlite根据SQLite数据库中的行创建事件sqs从Amazon Web Services简单队列服务队列中提取事件stdin从标准输入读取事件stomp创建使用STOMP协议接收的事件syslog读取系统日志消息作为事件tcp从TCP套接字读取事件twitter从Twitter Streaming API读取事件udp通过UDP读取事件unix通过UNIX套接字读取事件varnishlog从varnish缓存共享内存日志中读取websocket从网络套接字读取事件wmi根据WMI查询的结果创建事件xmpp通过XMPP / Jabber协议接收事件 常用数据来源配置 Logstash提供了足够多的数据来源，这里只介绍一些平时使用量会比较多的数据渠道
读取文件(File) 从文件中流式传输事件，通常以类似于tail -0F但可选地从头开始读取它们。Logstash 使用一个名叫 FileWatch 的 Ruby Gem 库来监听文件变化。而且会记录一个叫 .sincedb 的数据库文件来跟踪被监听的日志文件的当前读取位置。
这是一个完全的示例：
input file { # 日志文件地址 path =&gt; [&#34;/var/log/*.log&#34;, &#34;/var/log/message&#34;] # 默认一小时 close_older =&gt; 3600 # 设置新行分隔符，默认为“ \ n”。 delimiter =&gt; &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/557bd4adbaf17bca660ba1ef4b6a2dba/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-04-20T21:18:42+08:00" />
<meta property="article:modified_time" content="2020-04-20T21:18:42+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Logstash——配置介绍，数据输入配置（input）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night-eighties">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <blockquote> 
 <p>之前介绍过如何使用文件系统通过Logstash将数据推送至elasticsearch来实现日志的线上分析 <a href="https://blog.csdn.net/qq330983778/article/details/105473234">安装Logstash并完成一个简单的日志收集功能</a>。而Logstash所支持的数据源远远不止这些，这里对Logstash的数据输入配置进行一个介绍。</p> 
</blockquote> 
<p><a href="https://blog.csdn.net/qq330983778/article/details/105644835">Logstash——配置介绍，数据输入配置（input）</a><br> <a href="https://blog.csdn.net/qq330983778/article/details/105693027">Logstash——Logstash从MySQL中收集数据并输出添加</a><br> <a href="https://blog.csdn.net/qq330983778/article/details/105757604">Logstash——Logstash从Redis中收集数据并输出</a></p> 
<h2><a id="Logstash_6"></a>Logstash配置内容</h2> 
<p>Logstash的配置主要分为三部分：数据输入部分、数据处理部分、数据输出部分。这三部分的定义覆盖了数据整个的生命周期。这一篇主要介绍数据输入部分</p> 
<h3><a id="_10"></a>数据输入</h3> 
<blockquote> 
 <p>数据输入部分的配置定义在input内容下</p> 
</blockquote> 
<p>一个简单的示例</p> 
<pre><code class="prism language-json">input <span class="token punctuation">{<!-- --></span>
    stdin <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
    syslog <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="_23"></a>支持的数据来源</h3> 
<p>Logstash提供了一个非常长的数据来源支持列表，目前最新版的Logstash可以从下面渠道里面获得数据</p> 
<table><thead><tr><th>输入插件</th><th>支持内容</th></tr></thead><tbody><tr><td>azure_event_hubs</td><td>从Azure事件中心接收事件</td></tr><tr><td>beats</td><td>从Elastic Beats框架接收事件</td></tr><tr><td>cloudwatch</td><td>从Amazon Web Services CloudWatch API提取事件</td></tr><tr><td>couchdb_changes</td><td>从CouchDB的_changesURI 流事件</td></tr><tr><td>dead_letter_queue</td><td>从Logstash的死信队列中读取事件</td></tr><tr><td>elasticsearch</td><td>从Elasticsearch集群读取查询结果</td></tr><tr><td>exec</td><td>将shell命令的输出捕获为事件</td></tr><tr><td>file</td><td>从文件流事件</td></tr><tr><td>ganglia</td><td>通过UDP读取Ganglia数据包</td></tr><tr><td>gelf</td><td>从Graylog2读取GELF格式的消息作为事件</td></tr><tr><td>generator</td><td>生成用于测试目的的随机日志事件</td></tr><tr><td>github</td><td>从GitHub Webhook读取事件</td></tr><tr><td>google_cloud_storage</td><td>从Google Cloud Storage存储桶中的文件中提取事件</td></tr><tr><td>google_pubsub</td><td>消费来自Google Cloud PubSub服务的事件</td></tr><tr><td>graphite</td><td>从graphite工具读取指标</td></tr><tr><td>heartbeat</td><td>生成心跳事件以进行测试</td></tr><tr><td>http</td><td>通过HTTP或HTTPS接收事件</td></tr><tr><td>http_poller</td><td>将HTTP API的输出解码为事件</td></tr><tr><td>imap</td><td>从IMAP服务器读取邮件</td></tr><tr><td>irc</td><td>从IRC服务器读取事件</td></tr><tr><td>java_generator</td><td>生成综合日志事件</td></tr><tr><td>java_stdin</td><td>从标准输入读取事件</td></tr><tr><td>jdbc</td><td>从JDBC数据创建事件</td></tr><tr><td>jms</td><td>从Jms Broker读取事件</td></tr><tr><td>jmx</td><td>通过JMX从远程Java应用程序检索指标</td></tr><tr><td>kafka</td><td>读取来自Kafka主题的事件</td></tr><tr><td>kinesis</td><td>通过AWS Kinesis流接收事件</td></tr><tr><td>log4j</td><td>从Log4j SocketAppender对象通过TCP套接字读取事件</td></tr><tr><td>lumberjack</td><td>使用Lumberjack协议接收事件</td></tr><tr><td>meetup</td><td>将命令行工具的输出捕获为事件</td></tr><tr><td>pipe</td><td>从长时间运行的命令管道流式传输事件</td></tr><tr><td>puppet_facter</td><td>接收来自Puppet服务器的事件</td></tr><tr><td>rabbitmq</td><td>从RabbitMQ交换中提取事件</td></tr><tr><td>redis</td><td>从Redis实例读取事件</td></tr><tr><td>relp</td><td>通过TCP套接字接收RELP事件</td></tr><tr><td>rss</td><td>将命令行工具的输出捕获为事件</td></tr><tr><td>s3</td><td>从S3存储桶中的文件流式传输事件</td></tr><tr><td>s3_sns_sqs</td><td>使用sqs从AWS S3存储桶读取日志</td></tr><tr><td>salesforce</td><td>根据Salesforce SOQL查询创建事件</td></tr><tr><td>snmp</td><td>使用简单网络管理协议（SNMP）轮询网络设备</td></tr><tr><td>snmptrap</td><td>根据SNMP陷阱消息创建事件</td></tr><tr><td>sqlite</td><td>根据SQLite数据库中的行创建事件</td></tr><tr><td>sqs</td><td>从Amazon Web Services简单队列服务队列中提取事件</td></tr><tr><td>stdin</td><td>从标准输入读取事件</td></tr><tr><td>stomp</td><td>创建使用STOMP协议接收的事件</td></tr><tr><td>syslog</td><td>读取系统日志消息作为事件</td></tr><tr><td>tcp</td><td>从TCP套接字读取事件</td></tr><tr><td>twitter</td><td>从Twitter Streaming API读取事件</td></tr><tr><td>udp</td><td>通过UDP读取事件</td></tr><tr><td>unix</td><td>通过UNIX套接字读取事件</td></tr><tr><td>varnishlog</td><td>从varnish缓存共享内存日志中读取</td></tr><tr><td>websocket</td><td>从网络套接字读取事件</td></tr><tr><td>wmi</td><td>根据WMI查询的结果创建事件</td></tr><tr><td>xmpp</td><td>通过XMPP / Jabber协议接收事件</td></tr></tbody></table> 
<h3><a id="_85"></a>常用数据来源配置</h3> 
<blockquote> 
 <p>Logstash提供了足够多的数据来源，这里只介绍一些平时使用量会比较多的数据渠道</p> 
</blockquote> 
<h4><a id="File_89"></a>读取文件(File)</h4> 
<blockquote> 
 <p>从文件中流式传输事件，通常以类似于<code>tail -0F</code>但可选地从头开始读取它们。Logstash 使用一个名叫 FileWatch 的 Ruby Gem 库来监听文件变化。而且会记录一个叫 .sincedb 的数据库文件来跟踪被监听的日志文件的当前读取位置。</p> 
</blockquote> 
<p><strong>这是一个完全的示例</strong>：</p> 
<pre><code class="prism language-json">input
    file <span class="token punctuation">{<!-- --></span>
        # 日志文件地址
        path <span class="token operator">=&gt;</span> <span class="token punctuation">[</span><span class="token string">"/var/log/*.log"</span><span class="token punctuation">,</span> <span class="token string">"/var/log/message"</span><span class="token punctuation">]</span>
        # 默认一小时
        close_older <span class="token operator">=&gt;</span> <span class="token number">3600</span>
        # 设置新行分隔符，默认为“ \ n”。
        delimiter <span class="token operator">=&gt;</span> <span class="token string">"\n"</span>
        # 此参数配合stat_interval，此值用来发现新文件，最终频率为discover_interval × stat_interval。默认<span class="token number">15</span>
        discover_interval <span class="token operator">=&gt;</span> 
        # 默认为<span class="token number">1</span>秒
        stat_interval <span class="token operator">=&gt;</span> <span class="token string">"1 second"</span>
        # 忽略压缩包
        exclude <span class="token operator">=&gt;</span> exclude <span class="token operator">=&gt;</span> <span class="token string">"*.gz"</span>
        # 默认为<span class="token boolean">false</span>
        exit_after_read <span class="token operator">=&gt;</span> <span class="token boolean">false</span>
        # 默认为<span class="token number">4611686018427387903</span>，是为了保证在读取下一个文件前保证当前文件已经读取完毕
        file_chunk_count <span class="token operator">=&gt;</span> <span class="token number">4611686018427387903</span>
        # 默认为<span class="token number">32</span>kb
        file_chunk_size <span class="token operator">=&gt;</span> <span class="token number">32768</span>
        # 默认值为<span class="token keyword">delete</span>，可选值：<span class="token keyword">delete</span>，log，log_and_delete
        file_completed_action <span class="token operator">=&gt;</span> <span class="token keyword">delete</span>
        # 将完全读取的文件路径附加到哪个文件，此内容没有默认值
        file_completed_log_path <span class="token operator">=&gt;</span> <span class="token string">"/usr/local/log2/completed.log"</span>
        # 默认值last_modified，可设置内容：last_modified<span class="token punctuation">,</span> path
        file_sort_by <span class="token operator">=&gt;</span> last_modified
        # 默认值asc，可设置的值asc<span class="token punctuation">,</span> desc
        file_sort_direction <span class="token operator">=&gt;</span> 
        # 设置了忽略<span class="token number">1000</span>秒之前修改的文件，此内容没有默认值
        ignore_older <span class="token operator">=&gt;</span> <span class="token number">1000</span>
        # 设置最多打开文件量，此值没有默认值，但是存在一个内部限制<span class="token number">4095</span>
        max_open_files <span class="token operator">=&gt;</span> <span class="token number">4095</span>
        # 设置了输入模式为tail
        # tail模式下，start_position 和close_older参数将被忽略。start_position始终从头开始读取文件，close_older到达<span class="token constant">EOF</span>时文件自动关闭
        # read模式下需要设置ignore_older 、file_completed_action 、file_completed_log_path 参数
        mode <span class="token operator">=&gt;</span> tail
        # 默认值<span class="token number">2</span>周
        sincedb_clean_after <span class="token operator">=&gt;</span> <span class="token string">"2 weeks"</span>
        # 此为默认值，此值为文件路径而不是目录路径
        sincedb_path <span class="token operator">=&gt;</span> path<span class="token punctuation">.</span>data<span class="token operator">&gt;</span><span class="token operator">/</span>plugins<span class="token operator">/</span>inputs<span class="token operator">/</span>file
        # 默认值<span class="token number">15</span>秒
        sincedb_write_interval <span class="token operator">=&gt;</span> <span class="token string">"15 seconds"</span>
        # 默认值<span class="token string">"end"</span>，可选值beginning，end。如果启动logstash的时候需要读取旧数据需要设置为beginning
        start_position <span class="token operator">=&gt;</span> <span class="token string">"end"</span>
        # 下面是公共配置
        # 设置了type为system
        type <span class="token operator">=&gt;</span> <span class="token string">"system"</span> 
        # 默认line
        codec <span class="token operator">=&gt;</span> <span class="token string">"json"</span>
        # 默认值为<span class="token boolean">true</span>
        enable_metric <span class="token operator">=&gt;</span> <span class="token boolean">false</span>
        # 指定此数据输入id为input1
        id <span class="token operator">=&gt;</span> input1
        # 添加了键位key值为value的数据到时间
        add_field <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
          <span class="token string">"key"</span> <span class="token operator">=&gt;</span> <span class="token string">"value"</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>可配置的参数</strong></p> 
<table><thead><tr><th>参数</th><th>作用</th><th>参数类型</th></tr></thead><tbody><tr><td>close_older</td><td>文件输入将关闭最近一次在指定持续时间（如果指定了数字，则为秒）之前读取的所有文件</td><td>number或者string_duration</td></tr><tr><td>delimiter</td><td>设置新行分隔符，默认为“ \ n”。</td><td>string</td></tr><tr><td>discover_interval</td><td>每隔多久去检查一次被监听的 path 下是否有新文件。</td><td>number</td></tr><tr><td>exclude</td><td>排除例外文件</td><td>array</td></tr><tr><td>exit_after_read</td><td>可以在read模式下使用此选项，以在读取文件时强制关闭所有观察程序。可以用于文件内容为静态且在执行期间不会更改的情况。</td><td>boolean</td></tr><tr><td>file_chunk_count</td><td>在移至下一个活动文件之前从每个文件读取多少条数据</td><td>number</td></tr><tr><td>file_chunk_size</td><td>每条数据读取的大小</td><td>number</td></tr><tr><td>file_completed_action</td><td>在read模式下，完成文件后应执行什么操作。如果指定了删除，则文件将被删除。如果指定了日志，则文件的完整路径将记录到file_completed_log_path设置中指定的文件中 。如果log_and_delete指定，则以上两个动作都会发生。</td><td>string 可选参[“delete”, “log”, “log_and_delete”]数</td></tr><tr><td>file_completed_log_path</td><td>完全读取的文件路径应附加到哪个文件。只有当指定文件这条道路file_completed_action是日志或log_and_delete是使用</td><td>string</td></tr><tr><td>file_sort_by</td><td>应该使用“监视”文件的哪个属性对其进行排序。文件可以按修改日期或全路径字母排序。</td><td>string 可选参数[“last_modified”, “path”]</td></tr><tr><td>file_sort_direction</td><td>排序“监视”的文件时，在升序和降序之间进行选择</td><td>string 可选参数[“asc”, “desc”]</td></tr><tr><td>ignore_older</td><td>当文件输入发现在指定持续时间（如果指定了数字，则为秒）之前最后修改的文件时，将忽略该文件。</td><td>number或者string_duration</td></tr><tr><td>max_open_files</td><td>此输入一次一次消耗的file_handles的最大数量是多少。当打开的文件数量超过指定数量则会关闭一些文件</td><td>number</td></tr><tr><td>mode</td><td>您希望文件输入以哪种模式操作。</td><td>string 可选参数 [“tail”, “read”]</td></tr><tr><td>path</td><td>输入的文件的路径。</td><td>array</td></tr><tr><td>sincedb_clean_after</td><td>如果在过去N天内未在跟踪文件中检测到任何更改，则它的sincedb跟踪记录将过期，并且不会保留。</td><td>number或者string_duration</td></tr><tr><td>sincedb_path</td><td>定义 sincedb 文件的位置</td><td>string</td></tr><tr><td>sincedb_write_interval</td><td>每隔多久写一次 sincedb 文件</td><td>number或者string_duration</td></tr><tr><td>start_position</td><td>从什么位置开始读取文件数据。支持beginning或者end。end的时候从结束位置开始读取数据，而beginning则是从开头开始读取数</td><td>string 可选参数[“beginning”, “end”]</td></tr><tr><td>stat_interval</td><td>我们统计文件的频率（以秒为单位），以查看它们是否已被修改。</td><td>number或者string_duration</td></tr></tbody></table> 
<p>ps.并非所有支持配置，最后会介绍公共配置</p> 
<h4><a id="TCP_186"></a>读取网络数据(TCP)</h4> 
<blockquote> 
 <p>接收网络中的数据，此方法可以通过log发送数据到logstash，可以很方便的测试数据传输和分析效果。</p> 
</blockquote> 
<p>此方法需要对项目中log进行设置</p> 
<pre><code class="prism language-xml">
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Configuration</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Appenders</span><span class="token punctuation">&gt;</span></span>
     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Socket</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Socket<span class="token punctuation">"</span></span> <span class="token attr-name">host</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>localhost<span class="token punctuation">"</span></span> <span class="token attr-name">port</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>8081<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>JsonLayout</span> <span class="token attr-name">compact</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span> <span class="token attr-name">eventEol</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Socket</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Appenders</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Loggers</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Root</span> <span class="token attr-name">level</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>info<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>AppenderRef</span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Socket<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Root</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Loggers</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Configuration</span><span class="token punctuation">&gt;</span></span>

</code></pre> 
<p>同时需要添加一个过滤器来获取时间戳</p> 
<pre><code class="prism language-json">filter <span class="token punctuation">{<!-- --></span>
  date <span class="token punctuation">{<!-- --></span>
    match <span class="token operator">=&gt;</span> <span class="token punctuation">[</span> <span class="token string">"timeMillis"</span><span class="token punctuation">,</span> <span class="token string">"UNIX_MS"</span> <span class="token punctuation">]</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>示例</strong>：</p> 
<pre><code class="prism language-json">input <span class="token punctuation">{<!-- --></span>
  tcp <span class="token punctuation">{<!-- --></span>
        # 主机地址
        host <span class="token operator">=&gt;</span> <span class="token string">"192.168.0.2"</span>
        # 此时需要监听客户端
        mode <span class="token operator">=&gt;</span> <span class="token string">"server"</span>
        # 要监听的端口
        port <span class="token operator">=&gt;</span> <span class="token number">8081</span>
        # 默认值为<span class="token boolean">false</span>
        tcp_keep_alive <span class="token operator">=&gt;</span> <span class="token boolean">false</span>
        # 默认值为<span class="token boolean">true</span>
        dns_reverse_lookup_enabled <span class="token operator">=&gt;</span> <span class="token boolean">true</span>
        # 下面是公共配置
        # 设置了type为system
        type <span class="token operator">=&gt;</span> <span class="token string">"system"</span> 
        # 默认line
        codec <span class="token operator">=&gt;</span> <span class="token string">"json"</span>
        # 默认值为<span class="token boolean">true</span>
        enable_metric <span class="token operator">=&gt;</span> <span class="token boolean">false</span>
        # 指定此数据输入id为input1
        id <span class="token operator">=&gt;</span> input1
        # 添加了键位key值为value的数据到时间
        add_field <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
          <span class="token string">"key"</span> <span class="token operator">=&gt;</span> <span class="token string">"value"</span>
        <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>可配置的参数</strong></p> 
<table><thead><tr><th>参数</th><th>作用</th><th>参数类型</th></tr></thead><tbody><tr><td>host</td><td>监听的地址(mode=server),连接的地址(mode=client)</td><td>string</td></tr><tr><td>mode</td><td>运行模式。server指侦听客户端连接， client指连接到服务器。</td><td>string 可选参数[“server”, “client”]</td></tr><tr><td>port</td><td>当mode为时server，要监听的端口。当mode为时client，要连接的端口</td><td>number</td></tr><tr><td>proxy_protocol</td><td>代理协议</td><td>boolean</td></tr><tr><td>ssl_cert</td><td>PEM格式的证书路径。</td><td></td></tr><tr><td>ssl_certificate_authorities</td><td>根据这些权限验证客户证书或证书链。</td><td>array</td></tr><tr><td>ssl_enable</td><td>启用SSL</td><td>boolean</td></tr><tr><td>ssl_extra_chain_certs</td><td>额外的X509证书的路径数组。</td><td>array</td></tr><tr><td>ssl_key</td><td>指定证书（PEM格式）的私钥的路径。</td><td></td></tr><tr><td>ssl_key_passphrase</td><td>私钥的SSL密钥密码。</td><td>password</td></tr><tr><td>ssl_verify</td><td>根据CA验证SSL连接另一端的身份</td><td>boolean</td></tr><tr><td>tcp_keep_alive</td><td>指示套接字使用TCP保持活动。</td><td>boolean</td></tr><tr><td>dns_reverse_lookup_enabled</td><td>通过禁用此设置可以避免DNS反向查找。</td><td>boolean</td></tr></tbody></table> 
<h4><a id="_Rabbitmq___271"></a>读取 Rabbitmq 数据</h4> 
<p>从队列中读取数据的时候需要有一些额外操作，需要设置一个过滤器来解析<code>[@metadata][rabbitmq_properties][timestamp]</code>队列中的时间</p> 
<pre><code class="prism language-json">filter <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">if</span> <span class="token punctuation">[</span>@metadata<span class="token punctuation">]</span><span class="token punctuation">[</span>rabbitmq_properties<span class="token punctuation">]</span><span class="token punctuation">[</span>timestamp<span class="token punctuation">]</span> <span class="token punctuation">{<!-- --></span>
    date <span class="token punctuation">{<!-- --></span>
      match <span class="token operator">=&gt;</span> <span class="token punctuation">[</span><span class="token string">"[@metadata][rabbitmq_properties][timestamp]"</span><span class="token punctuation">,</span> <span class="token string">"UNIX"</span><span class="token punctuation">]</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>示例</strong>：</p> 
<pre><code class="prism language-json">input <span class="token punctuation">{<!-- --></span>
    rabbitmq <span class="token punctuation">{<!-- --></span>
            
            # 队列的主机
            host <span class="token operator">=&gt;</span> <span class="token string">"192.168.1.2"</span>
            # 默认为guest
            password <span class="token operator">=&gt;</span> <span class="token string">"guest"</span>
            # 消息服务器端口，默认为<span class="token number">5672</span>
            port <span class="token operator">=&gt;</span> <span class="token number">5672</span>
            # 默认为<span class="token string">""</span>
            queue <span class="token operator">=&gt;</span> <span class="token string">""</span>
            # 默认值为<span class="token boolean">true</span>
            ack <span class="token operator">=&gt;</span> <span class="token boolean">true</span>
            # 默认值为<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
            arguments <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span> <span class="token string">"x-ha-policy"</span> <span class="token operator">=&gt;</span> <span class="token string">"all"</span> <span class="token punctuation">}</span>
            # 默认值为<span class="token boolean">false</span>
            auto_delete <span class="token operator">=&gt;</span> <span class="token boolean">false</span>
            # 默认值为<span class="token boolean">true</span>
            automatic_recovery <span class="token operator">=&gt;</span> <span class="token boolean">true</span>
            # 默认值为<span class="token number">1</span>秒
            connect_retry_interval <span class="token operator">=&gt;</span> <span class="token number">1</span>
            # 没有默认值，超时时间为无限
            connection_timeout <span class="token operator">=&gt;</span> <span class="token number">1000</span>
            # 默认值为<span class="token boolean">false</span>
            durable <span class="token operator">=&gt;</span> <span class="token boolean">false</span>
            # 队列的交换器信息
            exchange <span class="token operator">=&gt;</span> <span class="token string">"log.exchange"</span>
            # 队列的交换器信息
            exchange_type <span class="token operator">=&gt;</span> <span class="token string">"direct"</span>
            # 默认值为<span class="token boolean">false</span>
            exclusive <span class="token operator">=&gt;</span> <span class="token boolean">false</span>
            # 没有默认值，但是不指定的时候未<span class="token number">60</span>秒，秒为单位
            heartbeat <span class="token operator">=&gt;</span> <span class="token number">60</span>
            # 默认值为logstash，路由键
            key <span class="token operator">=&gt;</span> logstash
            # 默认值为<span class="token boolean">false</span>，启动此功能保存元数据会影响性能
            metadata_enabled <span class="token operator">=&gt;</span> <span class="token boolean">false</span>
            # 默认值为<span class="token boolean">false</span>，当设置<span class="token boolean">true</span>的时候表明为被动队列，则在消息服务器上，此队列已经存在
            passive <span class="token operator">=&gt;</span> <span class="token boolean">false</span>
            # 默认为<span class="token number">256</span>
            prefetch_count <span class="token operator">=&gt;</span> <span class="token number">256</span>
            # 下面是公共配置
            # 设置了type为system
            type <span class="token operator">=&gt;</span> <span class="token string">"system"</span> 
            # 默认line
            codec <span class="token operator">=&gt;</span> <span class="token string">"json"</span>
            # 默认值为<span class="token boolean">true</span>
            enable_metric <span class="token operator">=&gt;</span> <span class="token boolean">false</span>
            # 指定此数据输入id为input1
            id <span class="token operator">=&gt;</span> input1
            # 添加了键位key值为value的数据到时间
            add_field <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
              <span class="token string">"key"</span> <span class="token operator">=&gt;</span> <span class="token string">"value"</span>
            <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>可配置的参数</strong></p> 
<table><thead><tr><th>参数</th><th>作用</th><th>参数类型</th></tr></thead><tbody><tr><td>ack</td><td>启用消息确认</td><td>boolean</td></tr><tr><td>arguments</td><td>可选队列参数</td><td>array</td></tr><tr><td>auto_delete</td><td>当最后一个使用者断开连接时，是否应该在代理上删除队列</td><td>boolean</td></tr><tr><td>automatic_recovery</td><td>将此设置为自动从断开的连接中恢复</td><td>boolean</td></tr><tr><td>connect_retry_interval</td><td>重试连接之前等待的时间</td><td>number</td></tr><tr><td>connection_timeout</td><td>默认连接超时（以毫秒为单位）</td><td>number</td></tr><tr><td>durable</td><td>是否持久队列</td><td>boolean</td></tr><tr><td>exchange</td><td>绑定队列的交换的名称</td><td>string</td></tr><tr><td>exchange_type</td><td>要绑定的交换类型</td><td>string</td></tr><tr><td>exclusive</td><td>队列是否排他</td><td>boolean</td></tr><tr><td>heartbeat</td><td>心跳超时（以秒为单位</td><td>number</td></tr><tr><td>host</td><td>Rabbitmq输入/输出RabbitMQ服务器地址主机的通用功能可以是单个主机，也可以是主机列表，即主机⇒“ localhost”或主机⇒[“ host01”，“ host02]</td><td>string</td></tr><tr><td>key</td><td>将队列绑定到交换机时要使用的路由密钥。</td><td>string</td></tr><tr><td>metadata_enabled</td><td>在中启用消息标头和属性的存储@metadata</td><td>boolean</td></tr><tr><td>passive</td><td>如果为true，将被动声明队列，这意味着它必须已经存在于服务器上。</td><td>boolean</td></tr><tr><td>password</td><td>RabbitMQ密码</td><td>password</td></tr><tr><td>port</td><td>RabbitMQ端口进行连接</td><td>number</td></tr><tr><td>prefetch_count</td><td>预取计数。如果使用该ack 选项启用了确认，则指定允许的未完成的未确认消息的数量。</td><td>number</td></tr><tr><td>queue</td><td>从每条消息中提取并存储在@metadata字段中的属性。</td><td>string</td></tr><tr><td>ssl</td><td>启用或禁用SSL。请注意，默认情况下，远程证书验证处于关闭状态。</td><td>boolean</td></tr><tr><td>ssl_certificate_password</td><td>ssl_certificate_path中指定的加密PKCS12（.p12）证书文件的密码</td><td>string</td></tr><tr><td>ssl_certificate_path</td><td>PKCS12（.p12）格式的SSL证书路径，用于验证远程主机</td><td></td></tr><tr><td>ssl_version</td><td>要使用的SSL协议版本。</td><td>string</td></tr><tr><td>subscription_retry_interval_seconds</td><td>订阅请求失败后，重试之前要等待的时间（秒）。</td><td>number</td></tr></tbody></table> 
<h4><a id="_Redis__376"></a>读取 Redis 数据</h4> 
<p><strong>示例</strong>：</p> 
<pre><code class="prism language-json">input <span class="token punctuation">{<!-- --></span>
  redis <span class="token punctuation">{<!-- --></span>
    # 默认值为 <span class="token number">125</span>
    batch_count <span class="token operator">=&gt;</span> <span class="token number">125</span>
    # 没有默认值，但其可选内容list，channel，pattern_channel
    data_type <span class="token operator">=&gt;</span> list
    # 默认值为 <span class="token number">0</span>
    db <span class="token operator">=&gt;</span> <span class="token number">0</span>
    # 默认值为 <span class="token string">"127.0.0.1"</span>
    host <span class="token operator">=&gt;</span> <span class="token string">"127.0.0.1"</span>
    # 指定channel，没有默认值
    key <span class="token operator">=&gt;</span> <span class="token string">"channel"</span>
    # redis的用户密码
    password <span class="token operator">=&gt;</span> <span class="token string">"password"</span>
    # redis服务器端口，默认值为 <span class="token number">6379</span>
    port <span class="token operator">=&gt;</span> <span class="token number">6379</span>
    # 默认不开启<span class="token constant">SSL</span>
    ssl <span class="token operator">=&gt;</span> <span class="token boolean">false</span>
    # 初始超时为<span class="token number">1</span>秒
    timeout <span class="token operator">=&gt;</span> <span class="token number">1</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>可配置的参数</strong></p> 
<table><thead><tr><th>参数</th><th>作用</th><th>参数类型</th></tr></thead><tbody><tr><td>batch_count</td><td>使用EVAL从Redis返回的事件数</td><td>number</td></tr><tr><td>data_type</td><td>指定列表或频道，可选内容为：list，channel，pattern_channel，如果data_type为list，将对密钥进行BLPOP锁定。如果data_type为channel，将订阅该密钥。如果data_type为pattern_channel，将订阅该密钥。</td><td>string 可选参数[“list”, “channel”, “pattern_channel”]</td></tr><tr><td>db</td><td>Redis数据库号</td><td>number</td></tr><tr><td>host</td><td>Redis服务器的主机名</td><td>string</td></tr><tr><td>path</td><td>Redis服务器的unix套接字路径</td><td>string</td></tr><tr><td>key</td><td>Redis列表或通道的名称</td><td>string</td></tr><tr><td>password</td><td>用于验证的密码。默认情况下没有身份验证</td><td>password</td></tr><tr><td>port</td><td>要连接的端口。</td><td>number</td></tr><tr><td>ssl</td><td>启用SSL支持。</td><td>boolean</td></tr><tr><td>threads</td><td>启动的线程</td><td>number</td></tr><tr><td>timeout</td><td>初始连接超时（以秒为单位）</td><td>number</td></tr><tr><td>command_map</td><td>以“旧名称”⇒“新名称”的形式配置重命名的redis命令。</td><td>hash</td></tr></tbody></table> 
<h4><a id="_JDBC__424"></a>读取 JDBC 数据</h4> 
<p><strong>示例</strong>：</p> 
<blockquote> 
 <p>这是官方的一个例子，作用就是每一分钟执行一遍<code>SELECT * from songs where artist = Beethoven</code>语句获取结果</p> 
</blockquote> 
<pre><code class="prism language-json">input <span class="token punctuation">{<!-- --></span>
  jdbc <span class="token punctuation">{<!-- --></span>
    jdbc_driver_library <span class="token operator">=&gt;</span> <span class="token string">"mysql-connector-java-5.1.36-bin.jar"</span>
    jdbc_driver_class <span class="token operator">=&gt;</span> <span class="token string">"com.mysql.jdbc.Driver"</span>
    jdbc_connection_string <span class="token operator">=&gt;</span> <span class="token string">"jdbc:mysql://localhost:3306/mydb"</span>
    jdbc_user <span class="token operator">=&gt;</span> <span class="token string">"mysql"</span>
    jdbc_password <span class="token operator">=&gt;</span> <span class="token string">"root"</span>
    parameters <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span> <span class="token string">"favorite_artist"</span> <span class="token operator">=&gt;</span> <span class="token string">"Beethoven"</span> <span class="token punctuation">}</span>
    # 设置监听间隔  各字段含义（由左至右）分、时、天、月、年，全部为<span class="token operator">*</span>默认含义为每分钟都更新
    schedule <span class="token operator">=&gt;</span> <span class="token string">"* * * * *"</span>
    statement <span class="token operator">=&gt;</span> <span class="token string">"SELECT * from songs where artist = :favorite_artist"</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre> 
<blockquote> 
 <p>这是使用了预编译来进行数据查询的例子</p> 
</blockquote> 
<pre><code class="prism language-json">input <span class="token punctuation">{<!-- --></span>
  jdbc <span class="token punctuation">{<!-- --></span>
    statement <span class="token operator">=&gt;</span> <span class="token string">"SELECT * FROM mgd.seq_sequence WHERE _sequence_key &gt; ? AND _sequence_key &lt; ? + ? ORDER BY _sequence_key ASC"</span>
    prepared_statement_bind_values <span class="token operator">=&gt;</span> <span class="token punctuation">[</span><span class="token string">":sql_last_value"</span><span class="token punctuation">,</span> <span class="token string">":sql_last_value"</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span>
    prepared_statement_name <span class="token operator">=&gt;</span> <span class="token string">"foobar"</span>
    use_prepared_statements <span class="token operator">=&gt;</span> <span class="token boolean">true</span>
    use_column_value <span class="token operator">=&gt;</span> <span class="token boolean">true</span>
    tracking_column_type <span class="token operator">=&gt;</span> <span class="token string">"numeric"</span>
    tracking_column <span class="token operator">=&gt;</span> <span class="token string">"_sequence_key"</span>
    last_run_metadata_path <span class="token operator">=&gt;</span> <span class="token string">"/elastic/tmp/testing/confs/test-jdbc-int-sql_last_value.yml"</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<blockquote> 
 <p>也可以使用编辑好的SQL文件</p> 
</blockquote> 
<pre><code class="prism language-json">input <span class="token punctuation">{<!-- --></span>
    jdbc <span class="token punctuation">{<!-- --></span>
      # mysql 数据库链接<span class="token punctuation">,</span>test为数据库名
      jdbc_connection_string <span class="token operator">=&gt;</span> <span class="token string">"jdbc:mysql://localhost:3306/mydb"</span>
      # 用户名和密码
      jdbc_user <span class="token operator">=&gt;</span> <span class="token string">"root"</span>
      jdbc_password <span class="token operator">=&gt;</span> <span class="token string">"root"</span>
      # 驱动
      jdbc_driver_library <span class="token operator">=&gt;</span> <span class="token string">"mysql-connector-java-5.1.36-bin.jar"</span>
      # 驱动类名
      jdbc_driver_class <span class="token operator">=&gt;</span> <span class="token string">"com.mysql.jdbc.Driver"</span>
      jdbc_paging_enabled <span class="token operator">=&gt;</span> <span class="token string">"true"</span>
      jdbc_page_size <span class="token operator">=&gt;</span> <span class="token string">"50000"</span>
	  # 执行的sql 文件路径<span class="token operator">+</span>名称
      statement_filepath <span class="token operator">=&gt;</span> <span class="token string">"logstash\sql\mysql\jdbc.sql"</span>
      # 设置监听间隔  各字段含义（由左至右）分、时、天、月、年，全部为<span class="token operator">*</span>默认含义为每分钟都更新
	  schedule <span class="token operator">=&gt;</span> <span class="token string">"* * * * *"</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>可配置的参数</strong></p> 
<table><thead><tr><th>参数</th><th>作用</th><th>参数类型</th></tr></thead><tbody><tr><td>clean_run</td><td>是否应保留先前的运行状态</td><td>boolean</td></tr><tr><td>columns_charset</td><td>特定列的字符编码</td><td>hash</td></tr><tr><td>connection_retry_attempts</td><td>尝试连接数据库的最大次数</td><td>number</td></tr><tr><td>connection_retry_attempts_wait_time</td><td>两次尝试之间休眠的秒数</td><td>number</td></tr><tr><td>jdbc_connection_string</td><td>JDBC连接字符串</td><td>string</td></tr><tr><td>jdbc_default_timezone</td><td>时区转换。</td><td>string</td></tr><tr><td>jdbc_driver_class</td><td>JDBC驱动程序类</td><td>string</td></tr><tr><td>jdbc_driver_library</td><td>第三方驱动程序库的JDBC驱动程序库路径。</td><td>string</td></tr><tr><td>jdbc_fetch_size</td><td>JDBC提取大小。</td><td>number</td></tr><tr><td>jdbc_page_size</td><td>JDBC页大小</td><td>number</td></tr><tr><td>jdbc_paging_enabled</td><td>JDBC启用分页</td><td>boolean</td></tr><tr><td>jdbc_password</td><td>JDBC密码</td><td>password</td></tr><tr><td>jdbc_password_filepath</td><td>JDBC密码文件名</td><td></td></tr><tr><td>jdbc_pool_timeout</td><td>PoolTimeoutError之前等待获取连接的秒数</td><td>number</td></tr><tr><td>jdbc_user</td><td>JDBC用户</td><td>string</td></tr><tr><td>jdbc_validate_connection</td><td>使用前验证连接。</td><td>boolean</td></tr><tr><td>jdbc_validation_timeout</td><td>验证连接的频率（以秒为单位）</td><td>number</td></tr><tr><td>last_run_metadata_path</td><td>上次运行时间的文件路径</td><td>string</td></tr><tr><td>lowercase_column_names</td><td>是否强制使用标识符字段的小写</td><td>boolean</td></tr><tr><td>parameters</td><td>查询参数的哈希，例如 { “target_id” =&gt; “321” }</td><td>hash</td></tr><tr><td>plugin_timezone</td><td>将时间戳偏移到UTC以外的时区，则可以将此设置设置为local，插件将使用OS时区进行偏移调整。</td><td>string 可选参数 [“local”, “utc”]</td></tr><tr><td>prepared_statement_bind_values</td><td>准备好的语句的绑定值数组。</td><td>array</td></tr><tr><td>prepared_statement_name</td><td>准备好的语句的名称</td><td>string</td></tr><tr><td>record_last_run</td><td>是否保存状态</td><td>boolean</td></tr><tr><td>schedule</td><td>定期运行语句的时间表，例如Cron格式：“ * * * * *”（每分钟，每分钟执行一次查询）</td><td>string</td></tr><tr><td>sequel_opts</td><td>连接池的最大连接数</td><td>hash</td></tr><tr><td>sql_log_level</td><td>记录SQL查询的日志级别</td><td>string 可选参数[“fatal”, “error”, “warn”, “info”, “debug”]</td></tr><tr><td>statement</td><td>执行的语句的内容</td><td>string</td></tr><tr><td>statement_filepath</td><td>执行的语句的文件的路径</td><td></td></tr><tr><td>tracking_column</td><td>要跟踪的列use_column_value</td><td>string</td></tr><tr><td>tracking_column_type</td><td>跟踪列的类型</td><td></td></tr><tr><td>use_column_value</td><td>设置为时true，将定义的 tracking_column值用作:sql_last_value。设置为时false，:sql_last_value反映上一次执行查询的时间。</td><td>string 可选参数[“numeric”, “timestamp”]</td></tr><tr><td>use_prepared_statements</td><td>设置为时true，启用prepare语句用法</td><td>boolean</td></tr></tbody></table> 
<h3><a id="Generator_530"></a>创建测试数据(Generator)</h3> 
<blockquote> 
 <p>在上线之前，可以使用此功能在实际环境中，测试 Logstash 和 Elasticsearch 的性能状况。对于极大数据情况下生产环境的评估有很重要意义</p> 
</blockquote> 
<p><strong>示例</strong>：</p> 
<pre><code class="prism language-json">input <span class="token punctuation">{<!-- --></span>
    generator <span class="token punctuation">{<!-- --></span>
        # 默认值是<span class="token number">0</span> 具体根据需要测试数据量
        count <span class="token operator">=&gt;</span> <span class="token number">100000</span>
        # 此时消息将会顺序发出，需要注意的是，此配置和message冲突
        lines <span class="token operator">=&gt;</span> <span class="token punctuation">[</span>
          <span class="token string">"line 1"</span><span class="token punctuation">,</span>
          <span class="token string">"line 2"</span><span class="token punctuation">,</span>
          <span class="token string">"line 3"</span>
        <span class="token punctuation">]</span>
        # 默认值是<span class="token string">"Hello world!"</span>
        message <span class="token operator">=&gt;</span> <span class="token string">'{"key1":"value1","key2":[1,2],"key3":{"subkey1":"subvalue1"}}'</span>
        # 下面是公共配置
        # 设置了type为system
        type <span class="token operator">=&gt;</span> <span class="token string">"system"</span> 
        # 默认line
        codec <span class="token operator">=&gt;</span> <span class="token string">"json"</span>
        # 默认值为<span class="token boolean">true</span>
        enable_metric <span class="token operator">=&gt;</span> <span class="token boolean">false</span>
        # 指定此数据输入id为input1
        id <span class="token operator">=&gt;</span> input1
        # 添加了键位key值为value的数据到时间
        add_field <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
          <span class="token string">"key"</span> <span class="token operator">=&gt;</span> <span class="token string">"value"</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>可配置的参数</strong></p> 
<table><thead><tr><th>参数</th><th>作用</th><th>参数类型</th></tr></thead><tbody><tr><td>count</td><td>生成消息数量</td><td>number</td></tr><tr><td>lines</td><td>顺序消息生成</td><td>array</td></tr><tr><td>message</td><td>生成的消息</td><td>string</td></tr><tr><td>threads</td><td>启动的线程</td><td>number</td></tr></tbody></table> 
<h4><a id="_578"></a>公共配置</h4> 
<blockquote> 
 <p>除了不同数据渠道自有的配置之外，还存在一些公共配置</p> 
</blockquote> 
<table><thead><tr><th>参数</th><th>作用</th><th>参数类型</th></tr></thead><tbody><tr><td>add_field</td><td>向事件添加字段</td><td>hash</td></tr><tr><td>codec</td><td>输入数据的编解码器</td><td>codec（解编码）</td></tr><tr><td>enable_metric</td><td>默认情况下，我们会记录我们能记录的所有度量，但是你可以禁用特定插件的度量集合</td><td>boolean</td></tr><tr><td>id</td><td>设置数据输入的ID，如果未指定ID，Logstash将生成一个。</td><td>string</td></tr><tr><td>tags</td><td>为你的数据事件设置标签，这样在数据分析的时候可以通过这个标签实现更多的分析结果</td><td>array</td></tr><tr><td>type</td><td>type向此输入处理的所有事件添加一个字段。此参数可以在数据过滤环节实现更多逻辑</td><td>string</td></tr></tbody></table> 
<h4><a id="codec_592"></a>codec（解编码）类型支持的配置</h4> 
<table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>avro</td><td>序列化的Avro记录</td></tr><tr><td>cef</td><td>读取ArcSight通用事件格式（CEF）</td></tr><tr><td>cloudfront</td><td>读取AWS CloudFront报告</td></tr><tr><td>cloudtrail</td><td>读取AWS CloudTrail日志文件</td></tr><tr><td>collectd</td><td>collectd使用UDP 从二进制协议读取事件。</td></tr><tr><td>csv</td><td>获取CSV数据，进行解析并传递。</td></tr><tr><td>dots</td><td>每个事件发送1点stdout用于性能跟踪</td></tr><tr><td>edn</td><td>读取EDN格式数据</td></tr><tr><td>edn_lines</td><td>读取以换行符分隔的EDN格式数据</td></tr><tr><td>es_bulk</td><td>将Elasticsearch批量格式与元数据一起读取为单独的事件</td></tr><tr><td>fluent</td><td>读取fluentd msgpack架构</td></tr><tr><td>graphite</td><td>读取graphite格式化的行</td></tr><tr><td>gzip_lines</td><td>读取gzip编码内容</td></tr><tr><td>jdots</td><td>将每个已处理的事件呈现为一个点</td></tr><tr><td>java_line</td><td>编码和解码面向行的文本数据</td></tr><tr><td>java_plain</td><td>处理事件之间没有定界符的文本数据</td></tr><tr><td>json</td><td>读取JSON格式的内容</td></tr><tr><td>json_lines</td><td>读取以换行符分隔的JSON</td></tr><tr><td>line</td><td>读取行文本数据</td></tr><tr><td>msgpack</td><td>读取MessagePack编码的内容</td></tr><tr><td>multiline</td><td>将多行消息合并为一个事件</td></tr><tr><td>netflow</td><td>读取Netflow v5和Netflow v9数据</td></tr><tr><td>nmap</td><td>读取XML格式的Nmap数据</td></tr><tr><td>plain</td><td>读取纯文本，事件之间没有定界</td></tr><tr><td>protobuf</td><td>读取protobuf消息并转换为Logstash事件</td></tr><tr><td>rubydebug</td><td>将Ruby Awesome Print库应用于Logstash事件</td></tr></tbody></table> 
<h4><a id="string_duration_623"></a>string_duration类似数据配置</h4> 
<ul><li>周</li></ul> 
<p>支持格式：e.g. “2 w”, “1 week”, “4 weeks”.</p> 
<ul><li>天</li></ul> 
<p>支持格式： e.g. “2 d”, “1 day”, “2.5 days”.</p> 
<ul><li>小时</li></ul> 
<p>支持格式：e.g. “4 h”, “1 hour”, “0.5 hours”.</p> 
<ul><li>分钟</li></ul> 
<p>支持格式：e.g. “45 m”, “35 min”, “1 minute”, “6 minutes”.</p> 
<ul><li>秒</li></ul> 
<p>支持格式： e.g. “45 s”, “15 sec”, “1 second”, “2.5 seconds”.</p> 
<ul><li>毫秒</li></ul> 
<p>支持格式：e.g. “500 ms”, “750 msec”, "50 msecs</p> 
<ul><li>微秒</li></ul> 
<p>支持格式：e.g. “600 us”, “800 usec”, “900 usecs”</p> 
<hr> 
<blockquote> 
 <p>个人水平有限，上面的内容可能存在没有描述清楚或者错误的地方，假如开发同学发现了，请及时告知，我会第一时间修改相关内容。假如我的这篇内容对你有任何帮助的话，麻烦给我<mark>点一个赞</mark>。你的点赞就是我前进的动力。</p> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9590e124cda8f7d8e84a4e81cbcb657f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Android之NavigationView（抽屉导航）的使用</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/28e2cfe15ce75a833639801f3477a448/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">mysql的lpad函数</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>