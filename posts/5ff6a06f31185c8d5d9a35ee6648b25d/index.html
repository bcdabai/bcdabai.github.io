<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Shell 脚本 - 自动拉取GIT代码&#43;编译3518EV200固件代码 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Shell 脚本 - 自动拉取GIT代码&#43;编译3518EV200固件代码" />
<meta property="og:description" content="一、前言 公司的固件开发人员经常用本机的代码编译打包文件，然后把编译好的固件发给硬件测试人员，经常出现开发人员不及时提交代码的问题。为了加强代码管控和规范化管理，最近搭了一个给硬件测试人员使用的服务器， 写了一个脚本文件用于自动拉取GIT上的固件代码，然后自动编译并打包。
二、以前的代码 由于是做物联网项目，公司的流量卡有分定向流量卡和普通流量卡，定向流量卡只能访问一个固定的内网地址，普通流量卡就类似我们手机中的普通上网卡，什么网站都可以访问。
以前编译打包文件时，开发人员通过修改代码中的__VPN_SIM__和FirmVer这2个参数来控制编译出的固件是什么版本号和区分流量卡的，部分代码如下：
//版本号定义 #ifdef __VPN_SIM__ #define FirmVer &#34;V005&#34; #else #define FirmVer &#34;P028&#34; #endif //服务器URL定义 #ifdef __VPN_SIM__ #define HOMEPAGE &#34;http://192.168.0.125:80&#34; #else #define HOMEPAGE &#34;http://www.xxx.cn:80&#34; //正式服务器 //#define HOMEPAGE &#34;http://test.xxx.cn:8080/&#34; //测试服务器 #endif 三、改造的过程 3.1 改造的思路 执行脚本的指令 ./buildFireware.sh P001 或者 ./buildFireware.sh V001 脚本的输入参数就1个：
参数1 -- 固件的版本号 在buildFireware.sh脚本中调用make命令执行Makefile中的编译指令时，直接传入固件版本号来代替代码中的FirmVer，同时在shell脚本中通过&lt;版本号&gt;的第一个字符是V还是P自动控制HOMEPAGE，不需要开发和测试人员更改代码就可以灵活输出不同的固件版本。
3.2 改造的C语言代码 只是加多了一个#ifndef FirmVer和#endif
//版本号定义 #ifndef FirmVer #ifdef __VPN_SIM__ #define FirmVer &#34;V005&#34; #else #define FirmVer &#34;P028&#34; #endif #endif //服务器URL定义 #ifdef __VPN_SIM__ #define HOMEPAGE &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/5ff6a06f31185c8d5d9a35ee6648b25d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-08-24T12:03:45+08:00" />
<meta property="article:modified_time" content="2020-08-24T12:03:45+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Shell 脚本 - 自动拉取GIT代码&#43;编译3518EV200固件代码</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>一、前言</h3> 
<p>公司的固件开发人员经常用本机的代码编译打包文件，然后把编译好的固件发给硬件测试人员，经常出现开发人员不及时提交代码的问题。为了加强代码管控和规范化管理，最近搭了一个给硬件测试人员使用的服务器， 写了一个脚本文件用于自动拉取GIT上的固件代码，然后自动编译并打包。</p> 
<h2>二、以前的代码</h2> 
<p>由于是做物联网项目，公司的流量卡有分定向流量卡和普通流量卡，定向流量卡只能访问一个固定的内网地址，普通流量卡就类似我们手机中的普通上网卡，什么网站都可以访问。</p> 
<p>以前编译打包文件时，开发人员通过修改代码中的__VPN_SIM__和FirmVer这2个参数来控制编译出的固件是什么版本号和区分流量卡的，部分代码如下：</p> 
<pre><code>//版本号定义
#ifdef __VPN_SIM__
	#define   FirmVer                  "V005"
#else
	#define   FirmVer                  "P028"
#endif

//服务器URL定义
#ifdef __VPN_SIM__
  #define HOMEPAGE        "http://192.168.0.125:80"
#else
  #define HOMEPAGE        "http://www.xxx.cn:80"  //正式服务器
  //#define HOMEPAGE        "http://test.xxx.cn:8080/"  //测试服务器
#endif</code></pre> 
<h2>三、改造的过程</h2> 
<h3>3.1 改造的思路</h3> 
<pre><code>执行脚本的指令

./buildFireware.sh P001

或者

./buildFireware.sh V001
</code></pre> 
<p>脚本的输入参数就1个：</p> 
<ul><li> <p>参数1 -- 固件的版本号 </p> </li></ul> 
<p>在buildFireware.sh脚本中调用make命令执行Makefile中的编译指令时，直接传入固件版本号来代替代码中的FirmVer，同时在shell脚本中通过&lt;版本号&gt;的第一个字符是V还是P自动控制HOMEPAGE，不需要开发和测试人员更改代码就可以灵活输出不同的固件版本。</p> 
<h3>3.2 改造的C语言代码</h3> 
<p>只是加多了一个#ifndef FirmVer和#endif</p> 
<pre><code>//版本号定义
#ifndef FirmVer
	#ifdef __VPN_SIM__
		#define   FirmVer                  "V005"
	#else
		#define   FirmVer                  "P028"
	#endif
#endif

//服务器URL定义
#ifdef __VPN_SIM__
  #define HOMEPAGE        "http://192.168.0.125:80"
#else
  #define HOMEPAGE        "http://www.xxx.cn:80"  //正式服务器
  //#define HOMEPAGE        "http://test.xxx.cn:8080/"  //测试服务器
#endif</code></pre> 
<h3>3.3 改造的Makefile</h3> 
<p>只是在CFLAGS中加多 $(ZYT_VER)，ZYT_VER通过shell脚本传入给该Makefile<img alt="" height="664" src="https://images2.imgbox.com/cd/ae/HZfzdfNu_o.png" width="1200"></p> 
<h3>3.4 buildFireware.sh的内容</h3> 
<pre><code>BuildVersion=$1
BuildItem=$2
BuildTime=$(date '+%Y%m%d%H%M%S')
DIR_OUTPUT=/zyt/liteos-HI3518ESV200-$BuildVersion-$BuildTime
DIR_FIREWARE_CODE=/arm/ParkerEtc/jv_code_sdk_park
DIR_FILESYSTEM=/arm/liteos_hi3518EV200_park
VersionType=${BuildVersion: 0: 1}
VersionLen=${#BuildVersion}

if [ -z "$BuildVersion" ]; then
  echo -e "\033[41;33m Please enter the version number you want to compile \033[0m"
  exit
fi
 
function CheckDir()
{
	[ -d $1 ] || mkdir -p $1
}

function gitGitFile()
{
	CodeDir="/arm"
	
	if [ -d "${CodeDir}" ]; then
		cd $CodeDir
		git pull
	else
		git clone --progress -v "http://&lt;Git用户名&gt;:&lt;Git密码&gt;@&lt;GitLib网址&gt;/Michael/Parker_ETC.git" $CodeDir
	fi
}

echo -e "\033[42;37m VersionType = [$BuildVersion,$VersionType,${#BuildVersion}] \033[0m"

if [ $VersionLen -lt 4 ]; then
  echo -e "\033[41;33m The version number must be longer than 4 bits \033[0m"
  exit
fi

if [ "P" == "$VersionType" ] ; then
	gitGitFile
	cd $DIR_FIREWARE_CODE
	CheckDir $DIR_FIREWARE_CODE/bin
	make clean
	make ZYT_VER=-DFirmVer=\\\"$BuildVersion\\\"
	echo -e "\033[42;37m fireware is finished  \033[0m"
	
	cd $DIR_FILESYSTEM
	CheckDir $DIR_FILESYSTEM/fs_park/config
	CheckDir $DIR_OUTPUT
	
	./mk-update.sh	${DIR_OUTPUT} DQPPARK $DIR_FIREWARE_CODE/dqp_main fs_park boot_emmc
	echo -e "\033[42;37m $BuildVersion is finished, files in $DIR_OUTPUT \033[0m"
elif [ "V" == "$VersionType" ] ; then
	gitGitFile
	cd $DIR_FIREWARE_CODE
	CheckDir $DIR_FIREWARE_CODE/bin
	make clean
	make ZYT_VER="-DFirmVer=\\\"$BuildVersion\\\" -D__VPN_SIM__"
	echo -e "\033[42;37m fireware is finished  \033[0m"
	
	cd $DIR_FILESYSTEM
	CheckDir $DIR_FILESYSTEM/fs_park/config
	CheckDir $DIR_OUTPUT
	./mk-update.sh	${DIR_OUTPUT} DQPPARK $DIR_FIREWARE_CODE/dqp_main fs_park boot_emmc
	echo -e "\033[42;37m $BuildVersion is finished, files in $DIR_OUTPUT \033[0m"
else
	echo -e "\033[41;33m Please enter the version number begun with P or V \033[0m"
fi</code></pre> 
<h3>3.5 设置指令的别名</h3> 
<p>在~/.bashrc中加入一条alias命令，然后就可以执行mk P001了，该命令可以将一些较长的命令进行简化 。bashrc是环境变量的配置文件，/etc/bashrc和~/.bashrc区别就在于一个是全系统的设置一个是当前用户的设置，在shell中执行alias命令会显示所有的别名。</p> 
<pre><code>alias mk='/anron/buildFireware.sh'</code></pre> 
<h2> 四、部分语法</h2> 
<h3>4.1 Makefile中</h3> 
<h4>4.1.1 引入外部文件</h4> 
<pre><code># 在Makefile中引入外部文件
include liteos_config.mk</code></pre> 
<h4>4.1.2  宏定义 -D</h4> 
<pre><code>-Dmacro=\"string\"，等同于在头文件中定义：#define macro "string"
-Dmacro，等同于在头文件中定义：#define macro 1</code></pre> 
<h3>4.2 Shell中 </h3> 
<h4>4.2.1 函数的调用</h4> 
<pre><code># 以下是test.sh文件，函数中$1的值是局部变量，与shell文件的$1不同值
function CheckDir()
{
	echo "[$1][$2]"
}


echo "[$1]"
CheckDir
CheckDir "b" "c"
CheckDir "b" $1

# 调用test.sh后的输出结果
[root@mac /]# ./test.sh a
[a]
[][]
[b][c]
[b][a]</code></pre> 
<pre><code># 给make传递参数，\是转义符
make ZYT_VER=-DFirmVer=\\\"$BuildVersion\\\"
make ZYT_VER="-DFirmVer=\\\"$BuildVersion\\\" -D__VPN_SIM__"</code></pre> 
<h4>4.2.2 字符串的截取</h4> 
<pre><code># 字符串的截取
VersionType=${BuildVersion: 0: 1}

${string: start :length}	从 string 字符串的左边第 start 个字符开始，向右截取 length 个字符。
${string: start}	从 string 字符串的左边第 start 个字符开始截取，直到最后。
${string: 0-start :length}	从 string 字符串的右边第 start 个字符开始，向右截取 length 个字符。
${string: 0-start}	从 string 字符串的右边第 start 个字符开始截取，直到最后。
${string#*chars}	从 string 字符串第一次出现 *chars 的位置开始，截取 *chars 右边的所有字符。
${string##*chars}	从 string 字符串最后一次出现 *chars 的位置开始，截取 *chars 右边的所有字符。
${string%*chars}	从 string 字符串第一次出现 *chars 的位置开始，截取 *chars 左边的所有字符。
${string%%*chars}	从 string 字符串最后一次出现 *chars 的位置开始，截取 *chars 左边的所有字符
</code></pre> 
<h4>4.2.3 字符串的长度</h4> 
<pre><code># 返回字符串的长度 ${#变量名}
varLen=${#BuildVersion}</code></pre> 
<h2>五、运行前的准备</h2> 
<p>脚本运行前要先安装交叉编译环境</p> 
<pre><code># 安装依赖库
yum install -y glibc.i686 libstdc++.so.6 zlib.i686

# 安装交叉编译工具
tar xzvf arm-hisiv500-linux.tgz
arm-hisiv500-linux/arm-hisiv500-linux.install

# 增加export
export PATH=/opt/hisi-linux/x86-arm/arm-hisiv500-linux/target/bin:$PATH 

# 测试安装结果
arm-hisiv500-linux-gcc -v</code></pre> 
<p><a href="https://blog.csdn.net/anron/article/details/105287663">Shell 脚本 - 自动拉取GIT代码+编译前后端代码+发布</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7499b0a4f4360f4018d9f255256b3b39/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">员工一言不合就离职怎么破？我有Python员工流失预警模型</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9f7a61d526a0ca26fdb3e2f5eae5ee22/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">用R语言生成均匀设计</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>