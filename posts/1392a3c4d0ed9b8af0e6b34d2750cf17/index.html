<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Prometheus_Grafana - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Prometheus_Grafana" />
<meta property="og:description" content="文章目录 1.Prometheus简介2.Prometheus优势1.易于管理2.监控服务的内部运行状态3.强大的数据模型4.强大的查询语言PromQL5.高效6.可扩展7.易于集成8.可视化9.开放性 Prometheus架构3.安装安装Prometheus安装Pushgateway安装node_exporter安装alertmanager 4.启动5.PromSQL1.瞬时时间2.时间范围3.时间位移操作4.聚合操作5.标量与字符串 6.Prometheus和grafana 1.Prometheus简介 Prometheus受启发于Google的Brogmon监控系统（相似的Kubernetes是从Google的Brog系统演变而来），从2012年开始由前Google工程师在Soundcloud以开源软件的形式进行研发，并且于2015年早期对外发布早期版本。2016年5月继Kubernetes之后成为第二个正式加入CNCF基金会的项目，同年6月正式发布1.0版本。2017年底发布了基于全新存储层的2.0版本，能更好地与容器平台、云平台配合。
2.Prometheus优势 1.易于管理 Prometheus核心部分只有一个单独的二进制文件，不存在任何的第三方依赖(数据库，缓存等等)。唯一需要的就是本地磁盘，因此不会有潜在级联故障的风险。
Prometheus基于Pull模型的架构方式，可以在任何地方（本地电脑，开发环境，测试环境）搭建我们的监控系统。对于一些复杂的情况，还可以使用Prometheus服务发现(Service Discovery)的能力动态管理监控目标。
2.监控服务的内部运行状态 Pometheus鼓励用户监控服务的内部状态，基于Prometheus丰富的Client库，用户可以轻松的在应用程序中添加对Prometheus的支持，从而让用户可以获取服务和应用内部真正的运行状态。
3.强大的数据模型 所有采集的监控数据均以指标(metric)的形式保存在内置的时间序列数据库当中(TSDB)。所有的样本除了基本的指标名称以外，还包含一组用于描述该样本特征的标签。
每一条时间序列由指标名称(Metrics Name)以及一组标签(Labels)唯一标识。每条时间序列按照时间的先后顺序存储一系列的样本值。
表示维度的标签可能来源于你的监控对象的状态，比如code=404或者content_path=/api/path。也可能来源于的你的环境定义，比如environment=produment。基于这些Labels我们可以方便地对监控数据进行聚合，过滤，裁剪。
4.强大的查询语言PromQL Prometheus内置了一个强大的数据查询语言PromQL。 通过PromQL可以实现对监控数据的查询、聚合。同时PromQL也被应用于数据可视化(如Grafana)以及告警当中。
通过PromQL可以轻松回答类似于以下问题：
在过去一段时间中95%应用延迟时间的分布范围？预测在4小时后，磁盘空间占用大致会是什么情况？CPU占用率前5位的服务有哪些？(过滤) 5.高效 对于监控系统而言，大量的监控任务必然导致有大量的数据产生。而Prometheus可以高效地处理这些数据，对于单一Prometheus Server实例而言它可以处理：
数以百万的监控指标每秒处理数十万的数据点。 6.可扩展 Prometheus是如此简单，因此你可以在每个数据中心、每个团队运行独立的Prometheus Sevrer。Prometheus对于联邦集群的支持，可以让多个Prometheus实例产生一个逻辑集群，当单实例Prometheus Server处理的任务量过大时，通过使用功能分区(sharding)&#43;联邦集群(federation)可以对其进行扩展。
7.易于集成 使用Prometheus可以快速搭建监控服务，并且可以非常方便地在应用程序中进行集成。目前支持： Java， JMX， Python， Go，Ruby， .Net， Node.js等等语言的客户端SDK，基于这些SDK可以快速让应用程序纳入到Prometheus的监控当中，或者开发自己的监控数据收集程序。同时这些客户端收集的监控数据，不仅仅支持Prometheus，还能支持Graphite这些其他的监控工具。
同时Prometheus还支持与其他的监控系统进行集成：Graphite， Statsd， Collected， Scollector， muini， Nagios等。
Prometheus社区还提供了大量第三方实现的监控数据采集支持：JMX， CloudWatch， EC2， MySQL， PostgresSQL， Haskell， Bash， SNMP， Consul， Haproxy， Mesos， Bind， CouchDB， Django， Memcached， RabbitMQ， Redis， RethinkDB， Rsyslog等等。
8.可视化 Prometheus Server中自带了一个Prometheus UI，通过这个UI可以方便地直接对数据进行查询，并且支持直接以图形化的形式展示数据。同时Prometheus还提供了一个独立的基于Ruby On Rails的Dashboard解决方案Promdash。最新的Grafana可视化工具也已经提供了完整的Prometheus支持，基于Grafana可以创建更加精美的监控图标。基于Prometheus提供的API还可以实现自己的监控可视化UI。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/1392a3c4d0ed9b8af0e6b34d2750cf17/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-12-03T16:53:51+08:00" />
<meta property="article:modified_time" content="2021-12-03T16:53:51+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Prometheus_Grafana</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-github-gist">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><ul><li><ul><li><a href="#1Prometheus_4" rel="nofollow">1.Prometheus简介</a></li><li><a href="#2Prometheus_8" rel="nofollow">2.Prometheus优势</a></li><li><ul><li><a href="#1_10" rel="nofollow">1.易于管理</a></li><li><a href="#2_16" rel="nofollow">2.监控服务的内部运行状态</a></li><li><a href="#3_23" rel="nofollow">3.强大的数据模型</a></li><li><a href="#4PromQL_31" rel="nofollow">4.强大的查询语言PromQL</a></li><li><a href="#5_42" rel="nofollow">5.高效</a></li><li><a href="#6_50" rel="nofollow">6.可扩展</a></li><li><a href="#7_53" rel="nofollow">7.易于集成</a></li><li><a href="#8_60" rel="nofollow">8.可视化</a></li><li><a href="#9_63" rel="nofollow">9.开放性</a></li></ul> 
    </li><li><a href="#Prometheus_71" rel="nofollow">Prometheus架构</a></li><li><a href="#3_94" rel="nofollow">3.安装</a></li><li><ul><li><a href="#Prometheus_97" rel="nofollow">安装Prometheus</a></li><li><a href="#Pushgateway_151" rel="nofollow">安装Pushgateway</a></li><li><a href="#node_exporter_155" rel="nofollow">安装node_exporter</a></li><li><a href="#alertmanager_160" rel="nofollow">安装alertmanager</a></li></ul> 
    </li><li><a href="#4_164" rel="nofollow">4.启动</a></li><li><a href="#5PromSQL_206" rel="nofollow">5.PromSQL</a></li><li><ul><li><a href="#1_209" rel="nofollow">1.瞬时时间</a></li><li><a href="#2_212" rel="nofollow">2.时间范围</a></li><li><a href="#3_217" rel="nofollow">3.时间位移操作</a></li><li><a href="#4_219" rel="nofollow">4.聚合操作</a></li><li><a href="#5_222" rel="nofollow">5.标量与字符串</a></li></ul> 
    </li><li><a href="#6Prometheusgrafana_225" rel="nofollow">6.Prometheus和grafana</a></li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<p><img src="https://images2.imgbox.com/de/93/Kkwmhbp1_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="1Prometheus_4"></a>1.Prometheus简介</h4> 
<p>Prometheus受启发于Google的Brogmon监控系统（相似的Kubernetes是从Google的Brog系统演变而来），从2012年开始由前Google工程师在Soundcloud以开源软件的形式进行研发，并且于2015年早期对外发布早期版本。2016年5月继Kubernetes之后成为第二个正式加入CNCF基金会的项目，同年6月正式发布1.0版本。2017年底发布了基于全新存储层的2.0版本，能更好地与容器平台、云平台配合。</p> 
<h4><a id="2Prometheus_8"></a>2.Prometheus优势</h4> 
<h5><a id="1_10"></a>1.易于管理</h5> 
<p>Prometheus核心部分只有一个单独的二进制文件，不存在任何的第三方依赖(数据库，缓存等等)。唯一需要的就是本地磁盘，因此不会有潜在级联故障的风险。</p> 
<p>Prometheus基于Pull模型的架构方式，可以在任何地方（本地电脑，开发环境，测试环境）搭建我们的监控系统。对于一些复杂的情况，还可以使用Prometheus服务发现(Service Discovery)的能力动态管理监控目标。</p> 
<h5><a id="2_16"></a>2.监控服务的内部运行状态</h5> 
<p>Pometheus鼓励用户监控服务的内部状态，基于Prometheus丰富的Client库，用户可以轻松的在应用程序中添加对Prometheus的支持，从而让用户可以获取服务和应用内部真正的运行状态。</p> 
<p><img src="https://images2.imgbox.com/56/49/aB9n4MDR_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="3_23"></a>3.强大的数据模型</h5> 
<p>所有采集的监控数据均以指标(metric)的形式保存在内置的时间序列数据库当中(TSDB)。所有的样本除了基本的指标名称以外，还包含一组用于描述该样本特征的标签。</p> 
<p>每一条时间序列由指标名称(Metrics Name)以及一组标签(Labels)唯一标识。每条时间序列按照时间的先后顺序存储一系列的样本值。</p> 
<p>表示维度的标签可能来源于你的监控对象的状态，比如code=404或者content_path=/api/path。也可能来源于的你的环境定义，比如environment=produment。基于这些Labels我们可以方便地对监控数据进行聚合，过滤，裁剪。</p> 
<h5><a id="4PromQL_31"></a>4.强大的查询语言PromQL</h5> 
<p>Prometheus内置了一个强大的数据查询语言PromQL。 通过PromQL可以实现对监控数据的查询、聚合。同时PromQL也被应用于数据可视化(如Grafana)以及告警当中。</p> 
<p>通过PromQL可以轻松回答类似于以下问题：</p> 
<ul><li>在过去一段时间中95%应用延迟时间的分布范围？</li><li>预测在4小时后，磁盘空间占用大致会是什么情况？</li><li>CPU占用率前5位的服务有哪些？(过滤)</li></ul> 
<h5><a id="5_42"></a>5.高效</h5> 
<p>对于监控系统而言，大量的监控任务必然导致有大量的数据产生。而Prometheus可以高效地处理这些数据，对于单一Prometheus Server实例而言它可以处理：</p> 
<ul><li>数以百万的监控指标</li><li>每秒处理数十万的数据点。</li></ul> 
<h5><a id="6_50"></a>6.可扩展</h5> 
<p>Prometheus是如此简单，因此你可以在每个数据中心、每个团队运行独立的Prometheus Sevrer。Prometheus对于联邦集群的支持，可以让多个Prometheus实例产生一个逻辑集群，当单实例Prometheus Server处理的任务量过大时，通过使用功能分区(sharding)+联邦集群(federation)可以对其进行扩展。</p> 
<h5><a id="7_53"></a>7.易于集成</h5> 
<p>使用Prometheus可以快速搭建监控服务，并且可以非常方便地在应用程序中进行集成。目前支持： Java， JMX， Python， Go，Ruby， .Net， Node.js等等语言的客户端SDK，基于这些SDK可以快速让应用程序纳入到Prometheus的监控当中，或者开发自己的监控数据收集程序。同时这些客户端收集的监控数据，不仅仅支持Prometheus，还能支持Graphite这些其他的监控工具。</p> 
<p>同时Prometheus还支持与其他的监控系统进行集成：Graphite， Statsd， Collected， Scollector， muini， Nagios等。</p> 
<p>Prometheus社区还提供了大量第三方实现的监控数据采集支持：JMX， CloudWatch， EC2， MySQL， PostgresSQL， Haskell， Bash， SNMP， Consul， Haproxy， Mesos， Bind， CouchDB， Django， Memcached， RabbitMQ， Redis， RethinkDB， Rsyslog等等。</p> 
<h5><a id="8_60"></a>8.可视化</h5> 
<p>Prometheus Server中自带了一个Prometheus UI，通过这个UI可以方便地直接对数据进行查询，并且支持直接以图形化的形式展示数据。同时Prometheus还提供了一个独立的基于Ruby On Rails的Dashboard解决方案Promdash。最新的Grafana可视化工具也已经提供了完整的Prometheus支持，基于Grafana可以创建更加精美的监控图标。基于Prometheus提供的API还可以实现自己的监控可视化UI。</p> 
<h5><a id="9_63"></a>9.开放性</h5> 
<p>通常来说当我们需要监控一个应用程序时，一般需要该应用程序提供对相应监控系统协议的支持。因此应用程序会与所选择的监控系统进行绑定。为了减少这种绑定所带来的限制。对于决策者而言要么你就直接在应用中集成该监控系统的支持，要么就在外部创建单独的服务来适配不同的监控系统。</p> 
<p>而对于Prometheus来说，使用Prometheus的client library的输出格式不止支持Prometheus的格式化数据，也可以输出支持其它监控系统的格式化数据，比如Graphite。</p> 
<p>因此你甚至可以在不使用Prometheus的情况下，采用Prometheus的client library来让你的应用程序支持监控数据采集。</p> 
<h4><a id="Prometheus_71"></a>Prometheus架构</h4> 
<p><img src="https://images2.imgbox.com/6a/1c/piokYo2F_o.png" alt="在这里插入图片描述"><br> 采集数据 - 存储计算 - 应用层</p> 
<p>可以理解为一个OLAP系统</p> 
<p>存储计算层:</p> 
<ul><li>Primetheus Server:里面包含了存储引擎和计算引擎</li><li>Retrieval:取数组件,会自动从Pushgateway或者Exporter拉取指标数据</li><li>Service Discovery:可以动态发现要监控的目标</li><li>TSDB:数据核心存储和查询</li><li>HTTP Server:对外提供HTTP服务</li></ul> 
<p>应用层:</p> 
<ul><li>AlterManager:对接Pagerduty,是一套付费的报警系统,</li><li>数据可视化:Web,Grafana</li></ul> 
<p>采集层:</p> 
<ul><li>exporters/job:长连接</li><li>Pushgaeway:短连接</li></ul> 
<h4><a id="3_94"></a>3.安装</h4> 
<p><img src="https://images2.imgbox.com/f4/5d/gf0eCsGx_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="Prometheus_97"></a>安装Prometheus</h5> 
<pre><code># my global config
global:
  scrape_interval: 15s # Set the scrape interval to every 15 seconds. Default is every 1 minute.
  evaluation_interval: 15s # Evaluate rules every 15 seconds. The default is every 1 minute.
  # scrape_timeout is set to the global default (10s).

# Alertmanager configuration
alerting:
  alertmanagers:
    - static_configs:
        - targets:
          # - alertmanager:9093

# Load rules once and periodically evaluate them according to the global 'evaluation_interval'.
rule_files:
  # - "first_rules.yml"
  # - "second_rules.yml"

# A scrape configuration containing exactly one endpoint to scrape:
# Here it's Prometheus itself.

scrape_configs:
  # The job name is added as a label `job=&lt;job_name&gt;` to any timeseries scraped from this config.
  - job_name: "prometheus"

    # metrics_path defaults to '/metrics'
    # scheme defaults to 'http'.

    static_configs:
      - targets: ["192.168.66.66:9090"]


  - job_name: "prometheus"
    static_configs:
      - targets: ["192.168.66.66:9090"]
        labels:
          instance: pushgateway

  - job_name: "node exporter"
    static_configs:
      - targets: ["192.168.66.66:9090"]
</code></pre> 
<p>启动</p> 
<pre><code>./prometheus
</code></pre> 
<h5><a id="Pushgateway_151"></a>安装Pushgateway</h5> 
<p>直接解压</p> 
<h5><a id="node_exporter_155"></a>安装node_exporter</h5> 
<p>直接解压</p> 
<h5><a id="alertmanager_160"></a>安装alertmanager</h5> 
<p>直接解压</p> 
<h4><a id="4_164"></a>4.启动</h4> 
<p>先启动node_exporter</p> 
<pre><code>[root@localhost mysoft]# ls
alertmanager-0.23.0  clickhouse  hadoop  jdk8  kafka  mycat  myhive  node_exporter-1.2.2  prometheus-2.29.1  pushgateway-1.4.1
[root@localhost mysoft]# cd node_exporter-1.2.2/
[root@localhost node_exporter-1.2.2]# ls
LICENSE  node_exporter  NOTICE
[root@localhost node_exporter-1.2.2]# ./node_exporter 
</code></pre> 
<p>浏览器:</p> 
<p>http://192.168.66.66:9100/metrics</p> 
<p><img src="https://images2.imgbox.com/87/89/UgoUDxVO_o.png" alt="在这里插入图片描述"><br> 再启动prometheus</p> 
<pre><code>[root@localhost node_exporter-1.2.2]# nohup ./prometheus --config.file=prometheus.yml &gt; ./prometheus.log 2&gt;&amp;1 &amp;
</code></pre> 
<p>浏览器URL:</p> 
<p>http://192.168.66.66:9090</p> 
<p><img src="https://images2.imgbox.com/f8/b0/2pCcJUz0_o.png" alt="在这里插入图片描述"></p> 
<p>启动Pushgateway</p> 
<pre><code>[root@localhost node_exporter-1.2.2]# nohup ./pushgateway --web.listen.address :9091 &gt; ./pushgateway.log 2&gt;&amp;1 &amp;
</code></pre> 
<p>本来上面的是down的后面启动后变为up</p> 
<h4><a id="5PromSQL_206"></a>5.PromSQL</h4> 
<p><img src="https://images2.imgbox.com/17/10/KzVwJClv_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="1_209"></a>1.瞬时时间</h5> 
<p><img src="https://images2.imgbox.com/69/fa/rxwzUE7D_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="2_212"></a>2.时间范围</h5> 
<p>xxx {}[5s]代表查询后5s的状态<br> <img src="https://images2.imgbox.com/0a/79/EttL2lTR_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="3_217"></a>3.时间位移操作</h5> 
<p><img src="https://images2.imgbox.com/46/0d/fGPKrc6n_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="4_219"></a>4.聚合操作</h5> 
<p><img src="https://images2.imgbox.com/af/c2/J0mC49UN_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="5_222"></a>5.标量与字符串</h5> 
<p><img src="https://images2.imgbox.com/1d/ca/qUac9ekh_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="6Prometheusgrafana_225"></a>6.Prometheus和grafana</h4> 
<p>解压grafana</p> 
<pre><code>[root@localhost bin]# pwd
/opt/mysoft/grafana-8.1.2/bin
[root@localhost bin]# nohup ./grafana-server web &gt; ../grafana.log 2&gt;&amp;1 &amp;
</code></pre> 
<p>浏览器<br> 192.168.66.66:3000</p> 
<p><img src="https://images2.imgbox.com/b8/3e/r2OCHhb4_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/55/a9/pyfp8QLj_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/7a/ec/I07fM1MR_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/fe/03/k5OPSmWA_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/11/1a/DyIRYc5W_o.png" alt="在这里插入图片描述"><br> 创建仪表盘</p> 
<p><img src="https://images2.imgbox.com/2f/49/I56EajhA_o.png" alt=" "><br> <img src="https://images2.imgbox.com/86/a5/lkoIdrIK_o.png" alt="在这里插入图片描述"><br> 就将Prometheus监控的状态同步到了Grafana</p> 
<p><img src="https://images2.imgbox.com/19/5a/iTzIKEo9_o.png" alt="在这里插入图片描述"><br> 最后需要保存,右上角apply,然后save</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0dc07e8afdecd44c5383fb5c65803b4b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【redis集群】Node xxx is not empty 解决方法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/54386d3f4a1a89b4022b90386c9ce42a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">配色基础入门</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>