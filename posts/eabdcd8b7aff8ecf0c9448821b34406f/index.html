<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java并发容器 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Java并发容器" />
<meta property="og:description" content="一、并发容器总结 1、大部分在 java.util.concurrent 包中。 ConcurrentHashMap: 线程安全的HashMap
CopyOnWriteArrayList: 线程安全的List，在读多写少的场合性能非常好，远远好于Vector.
ConcurrentLinkedQueue: 高效的并发队列，使用链表实现。可以看做一个线程安全的 LinkedList，这是一个非阻塞队列。
BlockingQueue: 这是一个接口，JDK内部通过链表、数组等方式实现了这个接口。表示阻塞队列，非常适合用于作为数据共享的通道。
ConcurrentSkipListMap: 跳表的实现。这是一个Map，使用跳表的数据结构进行快速查找。
2、 ConcurrentHashMap JDK1.7
首先将数据分为一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。
在JDK1.7中，ConcurrentHashMap采用Segment &#43; HashEntry的方式进行实现，结构如下：一个 ConcurrentHashMap 里包含一个 Segment 数组。Segment 的结构和HashMap类似，是一种数组和链表结构，一个 Segment 包含一个 HashEntry 数组，每个 HashEntry 是一个链表结构的元素，每个 Segment 守护着一个HashEntry数组里的元素，当对 HashEntry 数组的数据进行修改时，必须首先获得对应的 Segment的锁。
该类包含两个静态内部类 HashEntry 和 Segment ；前者用来封装映射表的键值对，后者用来充当
锁的角色；
Segment 是一种可重入的锁 ReentrantLock，每个 Segment 守护一个HashEntry 数组里得元
素，当对 HashEntry 数组的数据进行修改时，必须首先获得对应的 Segment 锁。
JDK1.8
在JDK1.8中，放弃了Segment臃肿的设计，取而代之的是采用Node &#43; CAS &#43; Synchronized来保
证并发安全进行实现，synchronized只锁定当前链表或红黑二叉树的首节点，这样只要hash不冲
突，就不会产生并发，效率又提升N倍。
结构如下：
插入元素过程：
如果相应位置的Node还没有初始化，则调用CAS插入相应的数据；
如果相应位置的Node不为空，且当前该节点不处于移动状态，则对该节点加synchronized锁，如果该节点的hash不小于0，则遍历链表更新节点或插入新节点；
如果该节点是TreeBin类型的节点，说明是红黑树结构，则通过putTreeVal方法往红黑树中插入节点；如果binCount不为0，说明put操作对数据产生了影响，如果当前链表的个数达到8个，则通过treeifyBin方法转化为红黑树，如果oldVal不为空，说明是一次更新操作，没有对元素个数产生影响，则直接返回旧值；
如果插入的是一个新节点，则执行addCount()方法尝试更新元素个数baseCount；" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/eabdcd8b7aff8ecf0c9448821b34406f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-01-09T20:10:14+08:00" />
<meta property="article:modified_time" content="2023-01-09T20:10:14+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java并发容器</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div class="kdocs-document"> 
 <h2 style="text-align:left;">一、并发容器总结</h2> 
 <h3 style="text-align:left;">1、大部分在 java.util.concurrent 包中。</h3> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;"><p><span class="kdocs-bold" style="font-weight:bold;">ConcurrentHashMap:</span> <span class="kdocs-fontSize" style="font-size:13pt;">线程安全的HashMap</span></p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;"><p><span class="kdocs-bold" style="font-weight:bold;">CopyOnWriteArrayList:</span> <span class="kdocs-fontSize" style="font-size:13pt;">线程安全的List，在读多写少的场合性能非常好，远远好于Vector.</span></p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;"><p><span class="kdocs-bold" style="font-weight:bold;">ConcurrentLinkedQueue:</span> <span class="kdocs-fontSize" style="font-size:13pt;">高效的并发队列，使用链表实现。可以看做一个线程安全的 LinkedList，这是一个非阻塞队列。</span></p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;"><p><span class="kdocs-bold" style="font-weight:bold;">BlockingQueue:</span> <span class="kdocs-fontSize" style="font-size:13pt;">这是一个接口，JDK内部通过链表、数组等方式实现了这个接口。表示阻塞队列，非常适合用于作为数据共享的通道。</span></p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;"><p><span class="kdocs-bold" style="font-weight:bold;">ConcurrentSkipListMap:</span> 跳表的实现。这是一个Map，使用跳表的数据结构进行快速查找。</p></li></ul> 
 <h3 style="text-align:left;">2、 ConcurrentHashMap</h3> 
 <p style=""><span class="kdocs-bold" style="font-weight:bold;">JDK1.7</span></p> 
 <p style=""><span class="kdocs-fontSize" style="font-size:13pt;">首先将数据分为一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。</span></p> 
 <p style=""><span class="kdocs-fontSize" style="font-size:13pt;">在JDK1.7中，ConcurrentHashMap采用Segment + HashEntry的方式进行实现，结构如下：一个 ConcurrentHashMap 里包含一个 Segment 数组。Segment 的结构和HashMap类似，是一种数组和链表结构，一个 Segment 包含一个 HashEntry 数组，每个 HashEntry 是一个链表结构的元素，每个 Segment 守护着一个HashEntry数组里的元素，当对 HashEntry 数组的数据进行修改时，必须首先获得对应的 Segment的锁。</span></p> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="background-color:#F5F7F9;flex-direction:column;max-width:100%;display:flex;width:843;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:53.736656%;height:0;"> 
    <img src="https://images2.imgbox.com/28/b3/9ioKSGIU_o.png" style="margin-left:;display:block;width:100.0%;margin-top:-53.736656%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <ol start="1"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p><span class="kdocs-fontSize" style="font-size:13pt;">该类包含两个静态内部类 HashEntry 和 Segment ；前者用来封装映射表的键值对，后者用来充当</span><br><span class="kdocs-fontSize" style="font-size:13pt;">锁的角色；</span></p></li></ol> 
 <ol start="2"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p><span class="kdocs-fontSize" style="font-size:13pt;">Segment 是一种可重入的锁 ReentrantLock，每个 Segment 守护一个HashEntry 数组里得元</span><br><span class="kdocs-fontSize" style="font-size:13pt;">素，当对 HashEntry 数组的数据进行修改时，必须首先获得对应的 Segment 锁。</span></p></li></ol> 
 <p style=""><span class="kdocs-bold" style="font-weight:bold;">JDK1.8</span></p> 
 <p style="text-indent:1.4em;"><span class="kdocs-fontSize" style="font-size:13pt;">在JDK1.8中，放弃了Segment臃肿的设计，取而代之的是采用Node + CAS + Synchronized来保</span></p> 
 <p style=""><span class="kdocs-fontSize" style="font-size:13pt;">证并发安全进行实现，synchronized只锁定当前链表或红黑二叉树的首节点，这样只要hash不冲</span></p> 
 <p style=""><span class="kdocs-fontSize" style="font-size:13pt;">突，就不会产生并发，效率又提升N倍。</span></p> 
 <p style=""><span class="kdocs-fontSize" style="font-size:13pt;">结构如下：</span></p> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="background-color:#F5F7F9;flex-direction:column;max-width:100%;display:flex;width:674;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:32.49258%;height:0;"> 
    <img src="https://images2.imgbox.com/85/9f/KLV4CBBd_o.png" style="margin-left:;display:block;width:100.0%;margin-top:-32.49258%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style=""><span class="kdocs-fontSize" style="font-size:13pt;">插入元素过程：</span></p> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;"><p><span class="kdocs-fontSize" style="font-size:13pt;">如果相应位置的Node还没有初始化，则调用CAS插入相应的数据；</span></p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;"><p><span class="kdocs-fontSize" style="font-size:13pt;">如果相应位置的Node不为空，且当前该节点不处于移动状态，则对该节点加synchronized锁，如果该节点的hash不小于0，则遍历链表更新节点或插入新节点；</span></p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;"><p><span class="kdocs-fontSize" style="font-size:13pt;">如果该节点是TreeBin类型的节点，说明是红黑树结构，则通过putTreeVal方法往红黑树中插入节点；如果binCount不为0，说明put操作对数据产生了影响，如果当前链表的个数达到8个，则通过treeifyBin方法转化为红黑树，如果oldVal不为空，说明是一次更新操作，没有对元素个数产生影响，则直接返回旧值；</span></p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;"><p><span class="kdocs-fontSize" style="font-size:13pt;">如果插入的是一个新节点，则执行addCount()方法尝试更新元素个数baseCount；</span></p></li></ul> 
 <h3 style="text-align:left;">3、CopyOnWriteArrayList</h3> 
 <p style=""><span class="kdocs-fontSize" style="font-size:13pt;">public class CopyOnWriteArrayList&lt;E&gt;</span></p> 
 <p style=""><span class="kdocs-fontSize" style="font-size:13pt;">extends Object</span></p> 
 <p style=""><span class="kdocs-fontSize" style="font-size:13pt;">implements List&lt;E&gt;, RandomAccess, Cloneable, Serializable</span></p> 
 <p style=""><span class="kdocs-fontSize" style="font-size:13pt;">在很多应用场景中，读操作可能会远远大于写操作。由于读操作根本不会修改原有的数据，因此对于每次读取都进行加锁其实是一种资源浪费。我们应该允许多个线程同时访问List的内部数据，毕竟读取操作是安全的。</span></p> 
 <p style=""><span class="kdocs-fontSize" style="font-size:13pt;">这和我们之前在多线程章节讲过 ReentrantReadWriteLock 读写锁的思想非常类似，也就是读读共享、写写互斥、读写互斥、写读互斥。JDK中提供了 CopyOnWriteArrayList 类比相比于在读写锁的思想又更进一步。为了将读取的性能发挥到极致，CopyOnWriteArrayList 读取是完全不用加锁的，并且更厉害的是：写入也不会阻塞读取操作。只有写入和写入之间需要进行同步等待。这样一来，读操作的性能就会大幅度提升。<span class="kdocs-bold" style="font-weight:bold;">那它是怎么做的呢？</span></span></p> 
 <h4 style="text-align:left;">3.1 CopyOnWriteArrayList 是如何做到的？</h4> 
 <p style=""><span class="kdocs-fontSize" style="font-size:13pt;">CopyOnWriteArrayList 类的所有可变操作（add，set等等）都是通过创建底层数组的新副本来实现的。当 List 需要被修改的时候，我并不修改原有内容，而是对原有数据进行一次复制，将修改的内容写入副本。写完之后，再将修改完的副本替换原来的数据，这样就可以保证写操作不会影响读操作了。</span></p> 
 <p style="text-indent:1.4em;"><span class="kdocs-fontSize" style="font-size:13pt;">从 CopyOnWriteArrayList 的名字就能看出CopyOnWriteArrayList 是满足CopyOnWrite 的ArrayList，所谓CopyOnWrite 也就是说：在计算机，如果你想要对一块内存进行修改时，我们不在原有内存块中进行写操作，而是将内存拷贝一份，在新的内存中进行写操作，写完之后呢，就将指向原来内存指针指向新的内存，原来的内存就可以被回收掉了。</span></p> 
 <h4 style="text-align:left;">3.2 CopyOnWriteArrayList 读取操作的实现</h4> 
 <p style="text-indent:1.4em;"><span class="kdocs-fontSize" style="font-size:13pt;">读取操作没有任何同步控制和锁操作，理由就是内部数组 array 不会发生修改，只会被另外一个 array 替换，因此可以保证数据安全。</span></p> 
 <p style=""><span class="kdocs-fontSize" style="font-size:13pt;"> /** The array, accessed only via getArray/setArray. */</span></p> 
 <p style=""><span class="kdocs-fontSize" style="font-size:13pt;"> private transient volatile Object[] array;</span></p> 
 <p style=""><span class="kdocs-fontSize" style="font-size:13pt;"> public E get(int index) {<!-- --></span></p> 
 <p style=""><span class="kdocs-fontSize" style="font-size:13pt;"> return get(getArray(), index);</span></p> 
 <p style=""><span class="kdocs-fontSize" style="font-size:13pt;"> }</span></p> 
 <p style=""><span class="kdocs-fontSize" style="font-size:13pt;"> @SuppressWarnings("unchecked")</span></p> 
 <p style=""><span class="kdocs-fontSize" style="font-size:13pt;"> private E get(Object[] a, int index) {<!-- --></span></p> 
 <p style=""><span class="kdocs-fontSize" style="font-size:13pt;"> return (E) a[index];</span></p> 
 <p style=""><span class="kdocs-fontSize" style="font-size:13pt;"> }</span></p> 
 <p style=""><span class="kdocs-fontSize" style="font-size:13pt;"> final Object[] getArray() {<!-- --></span></p> 
 <p style=""><span class="kdocs-fontSize" style="font-size:13pt;"> return array;</span></p> 
 <p style=""><span class="kdocs-fontSize" style="font-size:13pt;"> }</span></p> 
 <h4 style="text-align:left;">3.3 CopyOnWriteArrayList 写入操作的实现</h4> 
 <p style="text-indent:1.4em;"><span class="kdocs-fontSize" style="font-size:13pt;">CopyOnWriteArrayList 写入操作 add() 方法在添加集合的时候加了锁，保证了同步，避免了多线程写的时候会 copy 出多个副本出来。</span></p> 
 <p style=""><span class="kdocs-fontSize" style="font-size:13pt;"> /**</span></p> 
 <p style=""><span class="kdocs-fontSize" style="font-size:13pt;"> * Appends the specified element to the end of this list.</span></p> 
 <p style=""><span class="kdocs-fontSize" style="font-size:13pt;"> *</span></p> 
 <p style=""><span class="kdocs-fontSize" style="font-size:13pt;"> * @param e element to be appended to this list</span></p> 
 <p style=""><span class="kdocs-fontSize" style="font-size:13pt;"> * @return {@code true} (as specified by {@link Collection#add})</span></p> 
 <p style=""><span class="kdocs-fontSize" style="font-size:13pt;"> */</span></p> 
 <p style=""><span class="kdocs-fontSize" style="font-size:13pt;"> public boolean add(E e) {<!-- --></span></p> 
 <p style=""><span class="kdocs-fontSize" style="font-size:13pt;"> final ReentrantLock lock = this.lock;</span></p> 
 <p style=""><span class="kdocs-fontSize" style="font-size:13pt;"> lock.lock();//加锁</span></p> 
 <p style=""><span class="kdocs-fontSize" style="font-size:13pt;"> try {<!-- --></span></p> 
 <p style=""><span class="kdocs-fontSize" style="font-size:13pt;"> Object[] elements = getArray();</span></p> 
 <p style=""><span class="kdocs-fontSize" style="font-size:13pt;"> int len = elements.length;</span></p> 
 <p style=""><span class="kdocs-fontSize" style="font-size:13pt;"> Object[] newElements = Arrays.copyOf(elements, len + 1);//拷贝新数组</span></p> 
 <p style=""><span class="kdocs-fontSize" style="font-size:13pt;"> newElements[len] = e;</span></p> 
 <p style=""><span class="kdocs-fontSize" style="font-size:13pt;"> setArray(newElements);</span></p> 
 <p style=""><span class="kdocs-fontSize" style="font-size:13pt;"> return true;</span></p> 
 <p style=""><span class="kdocs-fontSize" style="font-size:13pt;"> } finally {<!-- --></span></p> 
 <p style=""><span class="kdocs-fontSize" style="font-size:13pt;"> lock.unlock();//释放锁</span></p> 
 <p style=""><span class="kdocs-fontSize" style="font-size:13pt;"> }</span></p> 
 <p style=""><span class="kdocs-fontSize" style="font-size:13pt;"> }</span></p> 
 <h3 style="text-align:left;">4、ConcurrentLinkedQueue</h3> 
 <p style=""><span class="kdocs-fontSize" style="font-size:13pt;">Java提供的线程安全的 Queue 可以分为<span class="kdocs-bold" style="font-weight:bold;">阻塞队列</span>和<span class="kdocs-bold" style="font-weight:bold;">非阻塞队列</span>，其中阻塞队列的典型例子是 BlockingQueue，非阻塞队列的典型例子是ConcurrentLinkedQueue，在实际应用中要根据实际需要选用阻塞队列或者非阻塞队列。 <span class="kdocs-bold" style="font-weight:bold;">阻塞队列可以通过加锁来实现，非阻塞队列可以通过 CAS 操作实现。</span></span></p> 
 <p style=""><span class="kdocs-fontSize" style="font-size:13pt;">从名字可以看出，ConcurrentLinkedQueue这个队列使用链表作为其数据结构．ConcurrentLinkedQueue 应该算是在高并发环境中性能最好的队列了。它之所有能有很好的性能，是因为其内部复杂的实现。</span></p> 
 <p style=""><span class="kdocs-fontSize" style="font-size:13pt;">ConcurrentLinkedQueue 内部代码我们就不分析了，大家知道ConcurrentLinkedQueue 主要使用 CAS 非阻塞算法来实现线程安全就好了。</span></p> 
 <p style=""><span class="kdocs-fontSize" style="font-size:13pt;">ConcurrentLinkedQueue 适合在对性能要求相对较高，同时对队列的读写存在多个线程同时进行的场景，即如果对队列加锁的成本较高则适合使用无锁的ConcurrentLinkedQueue来替代。</span></p> 
 <h3 style="text-align:left;">5、BlockingQueue</h3> 
 <p style=""><span class="kdocs-fontSize" style="font-size:13pt;">上面我们己经提到了 ConcurrentLinkedQueue 作为高性能的非阻塞队列。下面我们要讲到的是阻塞队列——BlockingQueue。阻塞队列（BlockingQueue）被广泛使用在“生产者-消费者”问题中，其原因是BlockingQueue提供了可阻塞的插入和移除的方法。当队列容器已满，生产者线程会被阻塞，直到队列未满；当队列容器为空时，消费者线程会被阻塞，直至队列非空时为止。</span></p> 
 <p style=""><span class="kdocs-fontSize" style="font-size:13pt;">BlockingQueue 是一个接口，继承自 Queue，所以其实现类也可以作为 Queue 的实现来使用，而 Queue 又继承自 Collection 接口。下面是 BlockingQueue 的相关实现类：</span></p> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="background-color:#F5F7F9;flex-direction:column;max-width:100%;display:flex;width:295;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:86.10169%;height:0;"> 
    <img src="https://images2.imgbox.com/4c/c1/wy0LxWx2_o.png" style="margin-left:;display:block;width:100.0%;margin-top:-86.10169%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style=""><span class="kdocs-fontSize" style="font-size:13pt;"><span class="kdocs-underline" style="text-decoration:underline;">下面主要介绍一下:ArrayBlockingQueue、LinkedBlockingQueue、PriorityBlockingQueue，这三个 BlockingQueue 的实现类。</span></span></p> 
 <h4 style="text-align:left;">5.1 ArrayBlockingQueue</h4> 
 <p style=""><span class="kdocs-fontSize" style="font-size:13pt;"><span class="kdocs-bold" style="font-weight:bold;">ArrayBlockingQueue</span> 是 BlockingQueue 接口的有界队列实现类，底层采用<span class="kdocs-bold" style="font-weight:bold;">数组</span>来实现。ArrayBlockingQueue一旦创建，容量不能改变。其并发控制采用可重入锁来控制，不管是插入操作还是读取操作，都需要获取到锁才能进行操作。当队列容量满时，尝试将元素放入队列将导致操作阻塞;尝试从一个空队列中取一个元素也会同样阻塞。</span></p> 
 <p style=""><span class="kdocs-fontSize" style="font-size:13pt;">ArrayBlockingQueue 默认情况下不能保证线程访问队列的公平性，所谓公平性是指严格按照线程等待的绝对时间顺序，即最先等待的线程能够最先访问到 ArrayBlockingQueue。而非公平性则是指访问 ArrayBlockingQueue 的顺序不是遵守严格的时间顺序，有可能存在，当 ArrayBlockingQueue 可以被访问时，长时间阻塞的线程依然无法访问到 ArrayBlockingQueue。如果保证公平性，通常会降低吞吐量。如果需要获得公平性的 ArrayBlockingQueue，可采用如下代码：</span></p> 
 <p style=""><span class="kdocs-fontSize" style="font-size:13pt;">private static ArrayBlockingQueue&lt;Integer&gt; blockingQueue = new ArrayBlockingQueue&lt;Integer&gt;(10,true);</span></p> 
 <h4 style="text-align:left;">5.2 LinkedBlockingQueue</h4> 
 <p style=""><span class="kdocs-fontSize" style="font-size:13pt;"><span class="kdocs-bold" style="font-weight:bold;">LinkedBlockingQueue</span> 底层基于<span class="kdocs-bold" style="font-weight:bold;">单向链表</span>实现的阻塞队列，可以当做无界队列也可以当做有界队列来使用，同样满足FIFO的特性，与ArrayBlockingQueue 相比起来具有更高的吞吐量，为了防止 LinkedBlockingQueue 容量迅速增，损耗大量内存。通常在创建LinkedBlockingQueue 对象时，会指定其大小，如果未指定，容量等于Integer.MAX_VALUE。</span></p> 
 <h4 style="text-align:left;">5.3 PriorityBlockingQueue</h4> 
 <p style=""><span class="kdocs-fontSize" style="font-size:13pt;"><span class="kdocs-bold" style="font-weight:bold;">PriorityBlockingQueue</span> 是一个支持优先级的无界阻塞队列。默认情况下元素采用自然顺序进行排序，也可以通过自定义类实现 compareTo() 方法来指定元素排序规则，或者初始化时通过构造器参数 Comparator 来指定排序规则。</span></p> 
 <p style=""><span class="kdocs-fontSize" style="font-size:13pt;">PriorityBlockingQueue 并发控制采用的是 <span class="kdocs-bold" style="font-weight:bold;">ReentrantLock</span>，队列为无界队列（ArrayBlockingQueue 是有界队列，LinkedBlockingQueue 也可以通过在构造函数中传入 capacity 指定队列最大的容量，但是 PriorityBlockingQueue 只能指定初始的队列大小，后面插入元素的时候，<span class="kdocs-bold" style="font-weight:bold;">如果空间不够的话会自动扩容</span>）。</span></p> 
 <p style=""><span class="kdocs-fontSize" style="font-size:13pt;">简单地说，它就是 PriorityQueue 的线程安全版本。不可以插入 null 值，同时，插入队列的对象必须是可比较大小的（comparable），否则报 ClassCastException 异常。它的插入操作 put 方法不会 block，因为它是无界队列（take 方法在队列为空的时候会阻塞）。</span></p> 
 <p style=""><span class="kdocs-fontSize" style="font-size:13pt;">推荐文章 </span><a class="kdocs-link" style="color:#0A6CFF;" href="https://javadoop.com/po" rel="nofollow noopener noreferrer" target="_blank"><span class="kdocs-fontSize" style="font-size:13pt;">https://javadoop.com/po</span></a><span class="kdocs-fontSize" style="font-size:13pt;">st/java-concurrent-queue</span></p> 
 <h3 style="text-align:left;">6、ConcurrentSkipListMap</h3> 
 <p style=""><span class="kdocs-fontSize" style="font-size:13pt;">下面这部分内容参考了极客时间专栏</span><a class="kdocs-link" style="color:#0A6CFF;" href="https://time.geekbang.org/column/intro/126?code=zl3GYeAsRI4rEJIBNu5B/km7LSZsPDlGWQEpAYw5Vu0=&amp;utm_term=SPoster" rel="nofollow noopener noreferrer" target="_blank"><span class="kdocs-fontSize" style="font-size:13pt;">《数据结构与算法之美》</span></a><span class="kdocs-fontSize" style="font-size:13pt;">以及《实战Java高并发程序设计》。</span></p> 
 <p style=""><span class="kdocs-fontSize" style="font-size:13pt;"><span class="kdocs-bold" style="font-weight:bold;">为了引出ConcurrentSkipListMap，先带着大家简单理解一下跳表。</span></span></p> 
 <p style=""><span class="kdocs-fontSize" style="font-size:13pt;">对于一个单链表，即使链表是有序的，如果我们想要在其中查找某个数据，也只能从头到尾遍历链表，这样效率自然就会很低，跳表就不一样了。跳表是一种可以用来快速查找的数据结构，有点类似于平衡树。它们都可以对元素进行快速的查找。但一个重要的区别是：对平衡树的插入和删除往往很可能导致平衡树进行一次全局的调整。而对跳表的插入和删除只需要对整个数据结构的局部进行操作即可。这样带来的好处是：在高并发的情况下，你会需要一个全局锁来保证整个平衡树的线程安全。而对于跳表，你只需要部分锁即可。这样，在高并发环境下，你就可以拥有更好的性能。而就查询的性能而言，跳表的时间复杂度也是 <span class="kdocs-bold" style="font-weight:bold;">O(logn)</span> 所以在并发数据结构中，JDK 使用跳表来实现一个 Map。</span></p> 
 <p style=""><span class="kdocs-fontSize" style="font-size:13pt;">跳表的本质是同时维护了多个链表，并且链表是分层的。</span></p> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="background-color:#F5F7F9;flex-direction:column;max-width:100%;display:flex;width:1005;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:48.955223%;height:0;"> 
    <img src="https://images2.imgbox.com/ea/2d/oYgggVaa_o.png" style="margin-left:;display:block;width:100.0%;margin-top:-48.955223%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style=""><span class="kdocs-fontSize" style="font-size:13pt;">最低层的链表维护了跳表内所有的元素，每上面一层链表都是下面一层的子集。</span></p> 
 <p style=""><span class="kdocs-fontSize" style="font-size:13pt;">跳表内的所有链表的元素都是排序的。查找时，可以从顶级链表开始找。一旦发现被查找的元素大于当前链表中的取值，就会转入下一层链表继续找。这也就是说在查找过程中，搜索是跳跃式的。如上图所示，在跳表中查找元素18。</span></p> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="background-color:#F5F7F9;flex-direction:column;max-width:100%;display:flex;width:984;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:52.23577%;height:0;"> 
    <img src="https://images2.imgbox.com/14/50/3XuoqirI_o.png" style="margin-left:;display:block;width:100.0%;margin-top:-52.23577%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style=""><span class="kdocs-fontSize" style="font-size:13pt;">查找18 的时候原来需要遍历 18 次，现在只需要 7 次即可。针对链表长度比较大的时候，构建索引查找效率的提升就会非常明显。</span></p> 
 <p style=""><span class="kdocs-fontSize" style="font-size:13pt;">从上面很容易看出，<span class="kdocs-bold" style="font-weight:bold;">跳表是一种利用空间换时间的算法。</span></span></p> 
 <p style=""><span class="kdocs-fontSize" style="font-size:13pt;">使用跳表实现Map 和使用哈希算法实现Map的另外一个不同之处是：哈希并不会保存元素的顺序，而跳表内所有的元素都是排序的。因此在对跳表进行遍历时，你会得到一个有序的结果。所以，如果你的应用需要有序性，那么跳表就是你不二的选择。JDK 中实现这一数据结构的类是ConcurrentSkipListMap。</span></p> 
 <p style=""></p> 
 <p style=""></p> 
 <p style=""> </p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/1550286fb346d8df05fece67a68071ff/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">使用windows10虚拟机搭建ftp服务，并能够使用ftp进行传输文件的操作，操作步骤配截图。</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/985beb19dd36848bbf642b22d4e126ee/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【FTP服务搭建】使用windows虚拟机搭建ftp服务，并能够使用ftp进行传输文件的操作</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>