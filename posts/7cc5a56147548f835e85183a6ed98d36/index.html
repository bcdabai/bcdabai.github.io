<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>java构造方法重载_Java 重载、重写、构造函数的实例详解 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="java构造方法重载_Java 重载、重写、构造函数的实例详解" />
<meta property="og:description" content="Java 重载、重写、构造函数的实例详解
方法重写
1、重写只能出现在继承关系之中。当一个类继承它的父类方法时，都有机会重写该父类的方法。一个特例是父类的方法被标识为final。重写的主要优点是能够定义某个子类型特有的行为。
class Animal {
public void eat(){
System.out.println (&#34;Animal is eating.&#34;);
}
}
class Horse extends Animal{
public void eat(){
System.out.println (&#34;Horse is eating.&#34;);
}
}
2、对于从父类继承来的抽象方法，要么在子类用重写的方式设计该方法，要么把子类也标识为抽象的。所以抽象方法可以说是必须要被重写的方法。
3、重写的意义。
重写方法可以实现多态，用父类的引用来操纵子类对象，但是在实际运行中对象将运行其自己特有的方法。
public class Test {
public static void main (String[] args) {
Animal h = new Horse();
h.eat();
}
}
class Animal {
public void eat(){
System.out.println (&#34;Animal is eating.&#34;);
}
}
class Horse extends Animal{
public void eat(){" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/7cc5a56147548f835e85183a6ed98d36/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-02-12T10:46:21+08:00" />
<meta property="article:modified_time" content="2021-02-12T10:46:21+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">java构造方法重载_Java 重载、重写、构造函数的实例详解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div style="font-size:16px;"> 
 <p>Java 重载、重写、构造函数的实例详解</p> 
 <p>方法重写</p> 
 <p>1、重写只能出现在继承关系之中。当一个类继承它的父类方法时，都有机会重写该父类的方法。一个特例是父类的方法被标识为final。重写的主要优点是能够定义某个子类型特有的行为。</p> 
 <p>class Animal {<!-- --></p> 
 <p>public void eat(){<!-- --></p> 
 <p>System.out.println ("Animal is eating.");</p> 
 <p>}</p> 
 <p>}</p> 
 <p>class Horse extends Animal{<!-- --></p> 
 <p>public void eat(){<!-- --></p> 
 <p>System.out.println ("Horse is eating.");</p> 
 <p>}</p> 
 <p>}</p> 
 <p>2、对于从父类继承来的抽象方法，要么在子类用重写的方式设计该方法，要么把子类也标识为抽象的。所以抽象方法可以说是必须要被重写的方法。</p> 
 <p>3、重写的意义。</p> 
 <p>重写方法可以实现多态，用父类的引用来操纵子类对象，但是在实际运行中对象将运行其自己特有的方法。</p> 
 <p>public class Test {<!-- --></p> 
 <p>public static void main (String[] args) {<!-- --></p> 
 <p>Animal h = new Horse();</p> 
 <p>h.eat();</p> 
 <p>}</p> 
 <p>}</p> 
 <p>class Animal {<!-- --></p> 
 <p>public void eat(){<!-- --></p> 
 <p>System.out.println ("Animal is eating.");</p> 
 <p>}</p> 
 <p>}</p> 
 <p>class Horse extends Animal{<!-- --></p> 
 <p>public void eat(){<!-- --></p> 
 <p>System.out.println ("Horse is eating.");</p> 
 <p>}</p> 
 <p>public void buck(){<!-- --></p> 
 <p>}</p> 
 <p>}</p> 
 <p>一个原则是：使用了什么引用，编译器就会只调用引用类所拥有的方法。如果调用子类特有的方法，如上例的h.buck(); 编译器会抱怨的(编译错误)。也就是说，编译器只看引用类型，而不是对象类型。</p> 
 <p>4、重写方法的规则。</p> 
 <p>若想实现一个合格重写方法，而不是重载，那么必须同时满足下面的要求！</p> 
 <p>A、重写规则之一：重写方法不能比被重写方法限制有更严格的访问级别。</p> 
 <p>(但是可以更广泛，比如父类方法是包访问权限，子类的重写方法是public访问权限。)</p> 
 <p>比如：Object类有个toString()方法，开始重写这个方法的时候我们总容易忘记public修饰符，编译器当然不会放过任何教训我们的机会。出错的原因就是：没有加任何访问修饰符的方法具有包访问权限，包访问权限比public当然要严格了，所以编译器会报错的。</p> 
 <p>B、重写规则之二：参数列表必须与被重写方法的相同。</p> 
 <p>重写有个孪生的弟弟叫重载，也就是后面要出场的。如果子类方法的参数与父类对应的方法不同，那么就是你认错人了，那是重载，不是重写。</p> 
 <p>C、重写规则之三：**返回类型必须与被重写方法的返回类型相同。</p> 
 <p>父类方法A：void eat(){} 子类方法B：int eat(){} 两者虽然参数相同，可是返回类型不同，所以不是重写。**</p> 
 <p>父类方法A：int eat(){} 子类方法B：long eat(){} 返回类型虽然兼容父类，但是不同就是不同，所以不是重写。</p> 
 <p>D、重写规则之四：重写方法不能抛出新的异常或者比被重写方法声明的检查异常更广的检查异常。但是可以抛出更少，更有限或者不抛出异常。</p> 
 <p>import java.io.*;</p> 
 <p>/**</p> 
 <p>* Java学习交流QQ群：589809992 我们一起学Java！</p> 
 <p>*/</p> 
 <p>public class Test {<!-- --></p> 
 <p>public static void main (String[] args) {<!-- --></p> 
 <p>Animal h = new Horse();</p> 
 <p>try {<!-- --></p> 
 <p>h.eat();</p> 
 <p>}</p> 
 <p>catch (Exception e) {<!-- --></p> 
 <p>}</p> 
 <p>}</p> 
 <p>}</p> 
 <p>class Animal {<!-- --></p> 
 <p>public void eat() throws Exception{<!-- --></p> 
 <p>System.out.println ("Animal is eating.");</p> 
 <p>throw new Exception();</p> 
 <p>}</p> 
 <p>}</p> 
 <p>class Horse extends Animal{<!-- --></p> 
 <p>public void eat() throws IOException{<!-- --></p> 
 <p>System.out.println ("Horse is eating.");</p> 
 <p>throw new IOException();</p> 
 <p>}</p> 
 <p>}</p> 
 <p>这个例子中，父类抛出了检查异常Exception，子类抛出的IOException是Exception的子类，也即是比被重写的方法抛出了更有限的异常，这是可以的。如果反过来，父类抛出IOException，子类抛出更为宽泛的Exception，那么不会通过编译的。</p> 
 <p>注意：这种限制只是针对检查异常，至于运行时异常RuntimeException及其子类不再这个限制之中。</p> 
 <p>E、重写规则之五：不能重写被标识为final的方法。</p> 
 <p>F、重写规则之六：如果一个方法不能被继承，则不能重写它。</p> 
 <p>比较典型的就是父类的private方法。下例会产生一个有趣的现象。</p> 
 <p>public class Test {<!-- --></p> 
 <p>public static void main (String[] args) {<!-- --></p> 
 <p>//Animal h = new Horse();</p> 
 <p>Horse h = new Horse();</p> 
 <p>h.eat();</p> 
 <p>}</p> 
 <p>}</p> 
 <p>class Animal {<!-- --></p> 
 <p>private void eat(){<!-- --></p> 
 <p>System.out.println ("Animal is eating.");</p> 
 <p>}</p> 
 <p>}</p> 
 <p>class Horse extends Animal{<!-- --></p> 
 <p>public void eat(){<!-- --></p> 
 <p>System.out.println ("Horse is eating.");</p> 
 <p>}</p> 
 <p>}</p> 
 <p>这段代码是能通过编译的。表面上看来违反了第六条规则，但实际上那是一点巧合。Animal类的eat()方法不能被继承，因此Horse类中的 eat()方法是一个全新的方法，不是重写也不是重载，只是一个只属于Horse类的全新的方法！这点让很多人迷惑了，但是也不是那么难以理解。</p> 
 <p>main()方法如果是这样：</p> 
 <p>Animal h = new Horse();</p> 
 <p>//Horse h = new Horse();</p> 
 <p>h.eat();</p> 
 <p>编译器会报错，为什么呢？Horse类的eat()方法是public的啊！应该可以调用啊！请牢记，多态只看父类引用的方法，而不看子类对象的方法！</p> 
 <p>方法的重载</p> 
 <p>重载是友好的，它不要求你在调用一个方法之前转换数据类型，它会自动地寻找匹配的方法。方法的重载是在编译时刻就决定调用哪个方法了，和重写不同。最最常用的地方就是构造器的重载。</p> 
 <p>1、基本数据类型参数的重载。</p> 
 <p>/**</p> 
 <p>* Java学习交流QQ群：589809992 我们一起学Java！</p> 
 <p>*/</p> 
 <p>public class Test {<!-- --></p> 
 <p>static void method(byte b){<!-- --></p> 
 <p>System.out.println ("method:byte");</p> 
 <p>}</p> 
 <p>static void method(short s){<!-- --></p> 
 <p>System.out.println ("method:short");</p> 
 <p>}</p> 
 <p>static void method(int i){<!-- --></p> 
 <p>System.out.println ("method:int");</p> 
 <p>}</p> 
 <p>static void method(float f){<!-- --></p> 
 <p>System.out.println ("method:float");</p> 
 <p>}</p> 
 <p>static void method(double d){<!-- --></p> 
 <p>System.out.println ("method:double");</p> 
 <p>}</p> 
 <p>public static void main (String[] args) {<!-- --></p> 
 <p>method((byte)1);</p> 
 <p>method('c');</p> 
 <p>method(1);</p> 
 <p>method(1L);</p> 
 <p>method(1.1);</p> 
 <p>method(1.1f);</p> 
 <p>}</p> 
 <p>}</p> 
 <p>输出结果：</p> 
 <p>method:byte</p> 
 <p>method:int</p> 
 <p>method:int</p> 
 <p>method:float</p> 
 <p>method:double</p> 
 <p>method:float</p> 
 <p>可以看出：首先要寻找的是数据类型正好匹配方法。如果找不到，那么就提升为表达能力更强的数据类型，如上例没有正好容纳long的整数类型，那么就转换为 float类型的。如果通过提升也不能找到合适的兼容类型，那么编译器就会报错。反正是不会自动转换为较小的数据类型的，必须自己强制转换，自己来承担转变后果。</p> 
 <p>char类型比较特殊，如果找不到正好匹配的类型，它会转化为int而不是short，虽然char是16位的。</p> 
 <p>2、重载方法的规则。</p> 
 <p>A、被重载的方法必须改变参数列表。</p> 
 <p>参数必须不同，这是最重要的！不同有两个方面，参数的个数，参数的类型，参数的顺序。</p> 
 <p>B、被重载的方法与返回类型无关。</p> 
 <p>也就是说，不能通过返回类型来区分重载方法。</p> 
 <p>C、被重载的方法可以改变访问修饰符。</p> 
 <p>没有重写方法那样严格的限制。</p> 
 <p>D、被重载的方法可以声明新的或者更广的检查异常。</p> 
 <p>没有重写方法那样严格的限制。</p> 
 <p>E、方法能够在一个类中或者在一个子类中被重载。</p> 
 <p>3、带对象引用参数的方法重载。</p> 
 <p>class Animal {}</p> 
 <p>class Horse extends Animal{}</p> 
 <p>public class Test {<!-- --></p> 
 <p>static void method(Animal a){<!-- --></p> 
 <p>System.out.println ("Animal is called.");</p> 
 <p>}</p> 
 <p>static void method(Horse h){<!-- --></p> 
 <p>System.out.println ("Horse is called.");</p> 
 <p>}</p> 
 <p>public static void main (String[] args) {<!-- --></p> 
 <p>Animal a = new Animal();</p> 
 <p>Horse h = new Horse();</p> 
 <p>Animal ah = new Horse();</p> 
 <p>method(a);</p> 
 <p>method(h);</p> 
 <p>method(ah);</p> 
 <p>}</p> 
 <p>}</p> 
 <p>输出结果是：</p> 
 <p>Animal is called.</p> 
 <p>Horse is called.</p> 
 <p>Animal is called.</p> 
 <p>前两个输出没有任何问题。第三个方法为什么不是输出“Horse is called.”呢？还是那句老话，要看引用类型而不是对象类型，方法重载是在编译时刻就决定的了，引用类型决定了调用哪个版本的重载方法。</p> 
 <p>4、重载和重写方法区别的小结。</p> 
 <p>如果能彻底弄明白下面的例子，说明你对重载和重写非常了解了，可以结束这节的复习了。</p> 
 <p>class Animal {<!-- --></p> 
 <p>public void eat(){<!-- --></p> 
 <p>System.out.println ("Animal is eating.");</p> 
 <p>}</p> 
 <p>}</p> 
 <p>class Horse extends Animal{<!-- --></p> 
 <p>public void eat(){<!-- --></p> 
 <p>System.out.println ("Horse is eating.");</p> 
 <p>}</p> 
 <p>public void eat(String food){<!-- --></p> 
 <p>System.out.println ("Horse is eating " + food);</p> 
 <p>}</p> 
 <p>}</p> 
 <p>public class Test {<!-- --></p> 
 <p>public static void main (String[] args) {<!-- --></p> 
 <p>Animal a = new Animal();</p> 
 <p>Horse h = new Horse();</p> 
 <p>Animal ah = new Horse();</p> 
 <p>a.eat();</p> 
 <p>h.eat();</p> 
 <p>h.eat("apple");</p> 
 <p>ah.eat();</p> 
 <p>//a.eat("apple");</p> 
 <p>//ah.eat("apple");</p> 
 <p>}</p> 
 <p>}</p> 
 <p>四个输出分别是什么？被注释的两条语句为什么不能通过编译？</p> 
 <p>第一条：a.eat(); 普通的方法调用，没有多态，没什么技术含量。调用了Animal类的eat()方法，输出：Animal is eating.</p> 
 <p>第二条：h.eat(); 普通的方法调用，也没什么技术含量。调用了Horse类的eat()方法，输出：Horse is eating.</p> 
 <p>第三条：h.eat(“apple”); 重载。Horse类的两个eat()方法重载。调用了Horse类的eat(String food)方法，输出：Horse is eating apple</p> 
 <p>第四条：ah.eat(); 多态。前面有例子了，不难理解。输出：Horse is eating.</p> 
 <p>第五条：a.eat(“apple”); 低级的错误，Animal类中没有eat(String food)方法。因此不能通过编译。</p> 
 <p>第六条：ah.eat(“apple”); 关键点就在这里。解决的方法还是那句老话，不能看对象类型，要看引用类型。Animal类中没有eat(String food)方法。因此不能通过编译。</p> 
 <p>小结一下：多态不决定调用哪个重载版本；多态只有在决定哪个重写版本时才起作用。</p> 
 <p>重载对应编译时，重写对应运行时。够简洁的了吧！</p> 
 <p>构造方法</p> 
 <p>构造方法是一种特殊的方法，没有构造方法就不能创建一个新对象。实际上，不仅要调用对象实际类型的构造方法，还要调用其父类的构造方法，向上追溯，直到 Object类。构造方法不必显式地调用，当使用new关键字时，相应的构造方法会自动被调用。</p> 
 <p>1、构造方法的规则。</p> 
 <p>A、构造方法能使用任何访问修饰符。包括private，事实上java类库有很多都是这样的，设计者不希望使用者创建该类的对象。</p> 
 <p>B、构造方法的名称必须与类名相同。这样使得构造方法与众不同，如果我们遵守sun的编码规范，似乎只有构造方法的首字母是大写的。</p> 
 <p>C、构造方法不能有返回类型。</p> 
 <p>反过来说，有返回类型的不是构造方法</p> 
 <p>public class Test {<!-- --></p> 
 <p>int Test(){<!-- --></p> 
 <p>return 1;</p> 
 <p>}</p> 
 <p>}</p> 
 <p>这个方法是什么东西？一个冒充李逵的李鬼而已，int Test()和其他任何普通方法没什么两样，就是普通的方法！只不过看起来很恶心，类似恶心的东西在考试卷子里比较多。</p> 
 <p>D、如果不在类中创建自己的构造方法，编译器会自动生成默认的不带参数的构造函数。</p> 
 <p>这点很容易验证！写一个这样简单的类，编译。</p> 
 <p>class Test {<!-- --></p> 
 <p>}</p> 
 <p>对生成的Test.class文件反编译：javap Test，可以看到：</p> 
 <p>D:"JavaCode"bin&gt;javap Test</p> 
 <p>Compiled from "Test.java"</p> 
 <p>class Test extends java.lang.Object{<!-- --></p> 
 <p>Test();</p> 
 <p>}</p> 
 <p>看到编译器自动添加的默认构造函数了吧！</p> 
 <p>E、如果只创建了带参数的构造方法，那么编译器不会自动添加无参的构造方法的！</p> 
 <p>F、在每个构造方法中，如果使用了重载构造函数this()方法，或者父类的构造方法super()方法，那么this()方法或者super()方法必须放在第一行。而且这两个方法只能选择一个，因此它们之间没有顺序问题。</p> 
 <p>G、除了编译器生成的构造方法，而且没有显式地调用super()方法，那么编译器会插入一个super()无参调用。</p> 
 <p>H、抽象类有构造方法。</p> 
 <p>静态方法的重载与重写(覆盖)</p> 
 <p>1、静态方法是不能被覆盖的。可以分两种情况讨论：</p> 
 <p>A、子类的非静态方法“覆盖”父类的静态方法。</p> 
 <p>这种情况下，是不能通过编译的。</p> 
 <p>class Father{<!-- --></p> 
 <p>static void print(){<!-- --></p> 
 <p>System.out.println ( " in father method " );</p> 
 <p>}</p> 
 <p>}</p> 
 <p>class Child extends Father{<!-- --></p> 
 <p>void print(){<!-- --></p> 
 <p>System.out.println ( " in child method " );</p> 
 <p>}</p> 
 <p>}</p> 
 <p>static方法表示该方法不关联具体的类的对象，可以通过类名直接调用，也就是编译的前期就绑定了，不存在后期动态绑定，也就是不能实现多态。子类的非静态方法是与具体的对象绑定的，两者有着不同的含义。</p> 
 <p>B、子类的静态方法“覆盖”父类静态方法。</p> 
 <p>这个覆盖依然是带引号的。事实上把上面那个例子Child类的print方法前面加上static修饰符，确实能通过编译！但是不要以为这就是多态！多态的特点是动态绑定，看下面的例子：</p> 
 <p>class Father{<!-- --></p> 
 <p>static void print(){<!-- --></p> 
 <p>System.out.println ( " in father method " );</p> 
 <p>}</p> 
 <p>}</p> 
 <p>class Child extends Father{<!-- --></p> 
 <p>static void print(){<!-- --></p> 
 <p>System.out.println ( " in child method " );</p> 
 <p>}</p> 
 <p>}</p> 
 <p>class Test{<!-- --></p> 
 <p>public static void main (String[] args) {<!-- --></p> 
 <p>Father f = new Child();</p> 
 <p>f.print();</p> 
 <p>}</p> 
 <p>}</p> 
 <p>输出结果是：in father method</p> 
 <p>从这个结果可以看出，并没有实现多态。</p> 
 <p>但是这种形式很迷惑人，貌似多态，实际编程中千万不要这样搞，会把大家搞懵的！</p> 
 <p>它不符合覆盖表现出来的特性，不应该算是覆盖！</p> 
 <p>总而言之，静态方法不能被覆盖。</p> 
 <p>2、静态方法可以和非静态方法一样被重载。</p> 
 <p>这样的例子太多了，我不想写例程了。看看java类库中很多这样的例子。</p> 
 <p>如java.util.Arrays类的一堆重载的binarySearch方法。</p> 
 <p>在这里提一下是因为查资料时看到这样的话“sun的SL275课程说，静态方法只能控制静态变量(他们本身没有)，静态方法不能被重载和覆盖……”</p> 
 <p>大家不要相信啊！可以重载的。而且静态与非静态方法可以重载。</p> 
 <p>从重载的机制很容易就理解了，重载是在编译时刻就决定的了，非静态方法都可以，静态方法怎么可能不会呢？</p> 
 <p>如有疑问请留言或者到本站社区交流讨论，感谢阅读，希望能帮助到大家，谢谢大家对本站的支持！</p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b15d5707102407b714d1efd206acd6ea/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">java级别_Java中的四种访问级别</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/39748a8803e24117caed7a46835c18d7/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">稠密集和疏朗集_康托集为啥不是疏朗集？</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>