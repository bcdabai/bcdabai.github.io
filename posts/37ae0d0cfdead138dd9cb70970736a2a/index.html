<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Openwrt框架分析 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Openwrt框架分析" />
<meta property="og:description" content="这次讲讲openwrt的结构.
1. 代码上来看有几个重要目录package, target, build_root, bin, dl....
---build_dir/host目录是建立工具链时的临时目录
---build_dir/toolchain-&lt;arch&gt;*是对应硬件的工具链的目录
---staging_dir/toolchain-&lt;arch&gt;* 则是工具链的安装位置
---target/linux/&lt;platform&gt;目录里面是各个平台(arch)的相关代码
---target/linux/&lt;platform&gt;/config-3.10文件就是配置文件了
---dl目录是&#39;download&#39;的缩写, 在编译前期，需要从网络下载的数据包都会放在这个目录下，这些软件包的一个特点就是，会自动安装在所编译的固件中，也就是我们make menuconfig的时候，为固件配置的一些软件包。如果我们需要更改这些源码包，只需要将更改好的源码包打包成相同的名字放在这个目录下，然后开始编译即可。编译时，会将软件包解压到build_dir目录下。
---而在build_dir/目录下进行解压，编译和打补丁等。
---package目录里面包含了我们在配置文件里设定的所有编译好的软件包。默认情况下，会有默认选择的软件包。在openwrt中ipk就是一切, 我们可以使用
$ ./scripts/feeds update来对软件包进行更新.
$ ./scripts/feeds search nmap 查找软件包&#39;nmap&#39;
Search results in feed ’packages’: nmap Network exploration and/or security auditing utility $ ./scripts/feeds install nmap 安装&#39;nmap&#39;这个软件
$ make package/symlinks //估计意思是更新软件源之类的
---bin目录下生成了很多bin文件，根据不同的平台来区分。另外bin/&lt;platform&gt;/package目录，里面有很多ipk后缀的文件，都是package目录下的源码在build_dir目录下编译后的生成的结果。
2. 新建自己的packages
对于自己新建的package，而这个package又不需要随固件一起安装，换句话说，就是可以当做一个可选软件包的话。我们可以利用我们的SDK环境来单独编译，编译后会生成一个ipk的文件包。然后利用 opkg install xxx.ipk 来安装这个软件。
下面具体说下，如何编译一个helloword的软件包。
（1）首先，编写helloworld程序
编写helloworld.c
/****************
* Helloworld.c
* The most simplistic C program ever written." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/37ae0d0cfdead138dd9cb70970736a2a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-08-26T13:43:31+08:00" />
<meta property="article:modified_time" content="2020-08-26T13:43:31+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Openwrt框架分析</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>这次讲讲openwrt的结构.</p> 
<p> </p> 
<p>1. 代码上来看有几个重要目录package, target, build_root, bin, dl....</p> 
<p>---build_dir/host目录是建立工具链时的临时目录</p> 
<p>---build_dir/toolchain-&lt;arch&gt;*是对应硬件的工具链的目录</p> 
<p>---staging_dir/toolchain-&lt;arch&gt;* 则是工具链的安装位置</p> 
<p>---target/linux/&lt;platform&gt;目录里面是各个平台(arch)的相关代码</p> 
<p>---target/linux/&lt;platform&gt;/config-3.10文件就是配置文件了</p> 
<p>---dl目录是'download'的缩写, 在编译前期，需要从网络下载的数据包都会放在这个目录下，这些软件包的一个特点就是，会自动安装在所编译的固件中，也就是我们make menuconfig的时候，为固件配置的一些软件包。如果我们需要更改这些源码包，只需要将更改好的源码包打包成相同的名字放在这个目录下，然后开始编译即可。编译时，会将软件包解压到build_dir目录下。</p> 
<p>---而在build_dir/目录下进行解压，编译和打补丁等。</p> 
<p>---package目录里面包含了我们在配置文件里设定的所有编译好的软件包。默认情况下，会有默认选择的软件包。在openwrt中ipk就是一切, 我们可以使用</p> 
<p>$ ./scripts/feeds update来对软件包进行更新.</p> 
<p>$ ./scripts/feeds search nmap 查找软件包'nmap'</p> 
<p> Search results in feed ’packages’: <br>  nmap       Network exploration and/or security auditing utility </p> 
<p> </p> 
<p>$ ./scripts/feeds install nmap 安装'nmap'这个软件</p> 
<p>$ make package/symlinks  //估计意思是更新软件源之类的</p> 
<p> </p> 
<p>---bin目录下生成了很多bin文件，根据不同的平台来区分。另外bin/&lt;platform&gt;/package目录，里面有很多ipk后缀的文件，都是package目录下的源码在build_dir目录下编译后的生成的结果。</p> 
<p> </p> 
<p>2. 新建自己的packages<br> 对于自己新建的package，而这个package又不需要随固件一起安装，换句话说，就是可以当做一个可选软件包的话。我们可以利用我们的SDK环境来单独编译，编译后会生成一个ipk的文件包。然后利用 opkg install xxx.ipk 来安装这个软件。</p> 
<p> </p> 
<p>下面具体说下，如何编译一个helloword的软件包。<br> （1）首先，编写helloworld程序<br> 编写helloworld.c<br> /****************<br> * Helloworld.c<br> * The most simplistic C program ever written.<br> * An epileptic monkey on crack could write this code.<br> *****************/<br> #include &lt;stdio.h&gt;<br> #include &lt;unistd.h&gt;<br> int main(void)<br> {<!-- --><br>      printf("Hell! O' world, why won't my code compile?\n\n");<br>      return 0;<br> }</p> 
<p><br> 编写Makefile文件<br> # build helloworld executable when user executes "make"<br> helloworld: helloworld.o<br>         $(CC) $(LDFLAGS) helloworld.o -o helloworld<br> helloworld.o: helloworld.c<br>         $(CC) $(CFLAGS) -c helloworld.c<br> # remove object files and executable when user executes "make clean"<br> clean:<br>         rm *.o helloworld<br>                                   <br> 在这两个文件的目录下，执行make 应该可以生成helloworld的可执行文件。执行helloworld后，能够打印出“Hell!O' world, why won't my code compile?”。 这一步，主要保证我们的源程序是可以正常编译的。</p> 
<p> </p> 
<p>下面我们将其移植到OpenWRT上。<br> （2）将OpenWrt-SDK-brcm47xx-for-Linux-x86_64-gcc-4.3.3+cs_uClibc-0.9.30.1.tar.bz2解压<br> tar –xvf OpenWrt-SDK-brcm47xx-for-Linux-x86_64-gcc-4.3.3+cs_uClibc-0.9.30.1.tar.bz2<br> （3）进入SDK<br> cd OpenWrt-SDK-brcm47xx-for-Linux-x86_64-gcc-4.3.3+cs_uClibc-0.9.30.1<br> 可以看到里面的目录结构跟我们之前source的目录结构基本相同，所需要编译的软件包，需要放置在package目录下<br> （4）在package目录下创建helloworld目录<br> cd package<br> mkdir helloworld<br> cd helloworld<br> （5）创建src目录，拷贝 helloworld文件<br> mkdir src<br> cp /home/wrt/test/helloworld.c src<br> cp /home/wrt/test/Makefile src<br> （6）在helloworld目录下创建Makefile文件<br> 这个Makefile文件是给OpenWRT读的，而之前写的那个Makefile文件是针对helloworld给编译其读的。两个Makefile不在同一层目录下。</p> 
<p><br> touch Makefile<br> vim Makefile</p> 
<p><br> Makefile文件模板内容如下：<br> ##############################################<br> # OpenWrt Makefile for helloworld program<br> #<br> #<br> # Most of the variables used here are defined in<br> # the include directives below. We just need to<br> # specify a basic description of the package,<br> # where to build our program, where to find<br> # the source files, and where to install the<br> # compiled program on the router.<br> #<br> # Be very careful of spacing in this file.<br> # Indents should be tabs, not spaces, and<br> # there should be no trailing whitespace in<br> # lines that are not commented.<br> #<br> ##############################################<br> include $(TOPDIR)/rules.mk<br> # Name and release number of this package<br> PKG_NAME:=helloworld<br> PKG_RELEASE:=1<br><br><br> # This specifies the directory where we're going to build the program. <br> # The root build directory, $(BUILD_DIR), is by default the build_mipsel<br> # directory in your OpenWrt SDK directory<br> PKG_BUILD_DIR := $(BUILD_DIR)/$(PKG_NAME)<br><br><br> include $(INCLUDE_DIR)/package.mk<br>  <br> # Specify package information for this program.<br> # The variables defined here should be self explanatory.<br> # If you are running Kamikaze, delete the DESCRIPTION<br> # variable below and uncomment the Kamikaze define<br> # directive for the description below<br> define Package/helloworld<br>         SECTION:=utils<br>         CATEGORY:=Utilities<br>         TITLE:=Helloworld -- prints a snarky message<br> endef<br><br><br> # Uncomment portion below for Kamikaze and delete DESCRIPTION variable above<br> define Package/helloworld/description<br>         If you can't figure out what this program does, you're probably<br>         brain-dead and need immediate medical attention.<br> endef<br>  <br> # Specify what needs to be done to prepare for building the package.<br> # In our case, we need to copy the source files to the build directory.<br> # This is NOT the default.  The default uses the PKG_SOURCE_URL and the<br> # PKG_SOURCE which is not defined here to download the source from the web.<br> # In order to just build a simple program that we have just written, it is<br> # much easier to do it this way.<br> define Build/Prepare<br>         mkdir -p $(PKG_BUILD_DIR)<br>         $(CP) ./src/* $(PKG_BUILD_DIR)/<br> endef<br><br><br> # We do not need to define Build/Configure or Build/Compile directives<br> # The defaults are appropriate for compiling a simple program such as this one<br><br><br> # Specify where and how to install the program. Since we only have one file,<br> # the helloworld executable, install it by copying it to the /bin directory on<br> # the router. The $(1) variable represents the root directory on the router running<br> # OpenWrt. The $(INSTALL_DIR) variable contains a command to prepare the install<br> # directory if it does not already exist.  Likewise $(INSTALL_BIN) contains the<br> # command to copy the binary file from its current location (in our case the build<br> # directory) to the install directory.<br> define Package/helloworld/install<br>         $(INSTALL_DIR) $(1)/bin<br>         $(INSTALL_BIN) $(PKG_BUILD_DIR)/helloworld $(1)/bin/<br> endef<br><br><br> # This line executes the necessary commands to compile our program.<br> # The above define directives specify all the information needed, but this<br> # line calls BuildPackage which in turn actually uses this information to<br> # build a package.<br> $(eval $(call BuildPackage,helloworld))<br><br><br> （7）返回到SDK的根目录<br> 执行make进行编译<br> 编译过程会在build_dir目录下完成<br> 编译结果会放在 bin/[yourtarget]/package目录下helloworld_1_bcm47xx.ipk<br> （8）上传helloworld_1_bcm47xx.ipk<br> 上传helloworld_1_bcm47xx.ipk至路由器<br> 执行# opkg install helloworld_1_bcm47xx.ipk<br> 然后输入hello然后按Tab键，发现openwrt中已经有helloworld可执行命令。<br> 执行 helloworld命令来查看程序的效果。<br> Hell! O' world, why won't my code compile?</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/31895a1297bad258bc112a5980bef5b8/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">(第一版) 完全免费的屏幕采集\录屏\直播推流的一体化工具</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b0a4277e73775f750a4ee4268139cdea/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">用了这么久的扫码登录，你知道它的背后到底发生了什么吗？</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>