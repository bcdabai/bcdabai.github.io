<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Qt核心特性之 —— 「信号(Signal)与槽(Slot)」机制 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Qt核心特性之 —— 「信号(Signal)与槽(Slot)」机制" />
<meta property="og:description" content="目录
1、Qt 与 Qt Creator简介：
2、关于引用头文件的一些事儿： 3、信号(Signal)与槽(Slot)机制：
3.1、一个小例子： 4、自定义信号与槽： 4.1、运行效果：
5、信号与槽的特性： 6、Qt 4 版本以前 connect 用法：
7、使用 Lambda 表达式建立连接：
1、Qt 与 Qt Creator简介： Qt：
Qt (官方发音 [kju:t]，音同 cute)是一个跨平台的 C&#43;&#43; 开发库，主要用来开发图形用户界面 (Graphical User Interface，GUI) 程序，当然也可以开发不带界面的命令行 (Command-Line Interface，CLI) 程序。
Qt 是纯 C&#43;&#43; 开发的，所以学好 C&#43;&#43; 非常有必要。当然 Qt 还存在 Python、Ruby、Perl 等脚本语言的绑定， 也就是说可以使用脚本语言开发基于 Qt 的程序。
Qt 支持的操作系统有很多，例如通用操作系统 Windows、Linux、Unix，智能手机系统 Android、iOS、WinPhone，嵌入式系统 QNX、VxWorks 等等。
（简介来自http://c.biancheng.net/view/1792.html，里面还提供了 Qt 下载安装教程）
Qt Creator：
除此以外，就像使用 Visual Studio 集成开发环境来创建Windows平台下的 Winform / WPF 应用程序一样；我们也需要一个类似的软件来创建基于 Qt 的应用程序。这个软件就是 Qt Creator。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/818df23f7baa61ef5aa4b628482a2016/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-09-06T17:38:26+08:00" />
<meta property="article:modified_time" content="2023-09-06T17:38:26+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Qt核心特性之 —— 「信号(Signal)与槽(Slot)」机制</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="1%E3%80%81Qt%20%E4%B8%8E%20Qt%20Creator%E7%AE%80%E4%BB%8B%EF%BC%9A-toc" style="margin-left:0px;"><a href="#1%E3%80%81Qt%20%E4%B8%8E%20Qt%20Creator%E7%AE%80%E4%BB%8B%EF%BC%9A" rel="nofollow">1、Qt 与 Qt Creator简介：</a></p> 
<p id="2%E3%80%81%E5%85%B3%E4%BA%8E%E5%BC%95%E7%94%A8%E5%A4%B4%E6%96%87%E4%BB%B6%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BA%8B%E5%84%BF%EF%BC%9A%C2%A0-toc" style="margin-left:0px;"><a href="#2%E3%80%81%E5%85%B3%E4%BA%8E%E5%BC%95%E7%94%A8%E5%A4%B4%E6%96%87%E4%BB%B6%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BA%8B%E5%84%BF%EF%BC%9A%C2%A0" rel="nofollow">2、关于引用头文件的一些事儿： </a></p> 
<p id="3%E3%80%81%E4%BF%A1%E5%8F%B7(Signal)%E4%B8%8E%E6%A7%BD(Slot)%E6%9C%BA%E5%88%B6%EF%BC%9A-toc" style="margin-left:0px;"><a href="#3%E3%80%81%E4%BF%A1%E5%8F%B7%28Signal%29%E4%B8%8E%E6%A7%BD%28Slot%29%E6%9C%BA%E5%88%B6%EF%BC%9A" rel="nofollow">3、信号(Signal)与槽(Slot)机制：</a></p> 
<p id="3.1%E3%80%81%E4%B8%80%E4%B8%AA%E5%B0%8F%E4%BE%8B%E5%AD%90%EF%BC%9A%C2%A0-toc" style="margin-left:40px;"><a href="#3.1%E3%80%81%E4%B8%80%E4%B8%AA%E5%B0%8F%E4%BE%8B%E5%AD%90%EF%BC%9A%C2%A0" rel="nofollow">3.1、一个小例子： </a></p> 
<p id="4%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BF%A1%E5%8F%B7%E4%B8%8E%E6%A7%BD%EF%BC%9A%C2%A0-toc" style="margin-left:0px;"><a href="#4%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BF%A1%E5%8F%B7%E4%B8%8E%E6%A7%BD%EF%BC%9A%C2%A0" rel="nofollow">4、自定义信号与槽： </a></p> 
<p id="4.1%E3%80%81%E8%BF%90%E8%A1%8C%E6%95%88%E6%9E%9C%EF%BC%9A-toc" style="margin-left:40px;"><a href="#4.1%E3%80%81%E8%BF%90%E8%A1%8C%E6%95%88%E6%9E%9C%EF%BC%9A" rel="nofollow">4.1、运行效果：</a></p> 
<p id="5%E3%80%81%E4%BF%A1%E5%8F%B7%E4%B8%8E%E6%A7%BD%E7%9A%84%E7%89%B9%E7%82%B9%EF%BC%9A%C2%A0-toc" style="margin-left:0px;"><a href="#5%E3%80%81%E4%BF%A1%E5%8F%B7%E4%B8%8E%E6%A7%BD%E7%9A%84%E7%89%B9%E7%82%B9%EF%BC%9A%C2%A0" rel="nofollow">5、信号与槽的特性： </a></p> 
<p id="6%E3%80%81Qt%204%20%E7%89%88%E6%9C%AC%E4%BB%A5%E5%89%8D%20connect%20%E7%94%A8%E6%B3%95%EF%BC%9A-toc" style="margin-left:0px;"><a href="#6%E3%80%81Qt%204%20%E7%89%88%E6%9C%AC%E4%BB%A5%E5%89%8D%20connect%20%E7%94%A8%E6%B3%95%EF%BC%9A" rel="nofollow">6、Qt 4 版本以前 connect 用法：</a></p> 
<p id="7%E3%80%81%E4%BD%BF%E7%94%A8%20Lambda%20%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%EF%BC%9A-toc" style="margin-left:0px;"><a href="#7%E3%80%81%E4%BD%BF%E7%94%A8%20Lambda%20%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%EF%BC%9A" rel="nofollow">7、使用 Lambda 表达式建立连接：</a></p> 
<p></p> 
<hr> 
<h2 id="1%E3%80%81Qt%20%E4%B8%8E%20Qt%20Creator%E7%AE%80%E4%BB%8B%EF%BC%9A"><span style="color:#9c8ec1;">1、Qt 与 Qt Creator简介：</span></h2> 
<blockquote> 
 <p><span style="color:#ffd900;"><strong><span style="background-color:#ed7976;">Qt</span></strong></span>：</p> 
 <p>        <a class="link-info" href="https://www.qt.io/zh-cn/" rel="nofollow" title="Qt">Qt</a> (官方发音 [kju:t]，音同 cute)<span style="color:#1c7331;"><strong>是一个跨平台的 C++ 开发库</strong></span>，<span style="color:#ed7976;">主要用来开发图形用户界面 (Graphical User Interface，GUI) 程序</span>，当然也可以开发不带界面的命令行 (Command-Line Interface，CLI) 程序。<br>         Qt 是纯 C++ 开发的，所以学好 C++ 非常有必要。当然 Qt 还存在 Python、Ruby、Perl 等脚本语言的绑定， 也就是说可以使用脚本语言开发基于 Qt 的程序。<br>         Qt 支持的操作系统有很多，例如通用操作系统 Windows、Linux、<a class="link-info" href="https://zhuanlan.zhihu.com/p/71934037" rel="nofollow" title="Unix">Unix</a>，智能手机系统 Android、iOS、WinPhone，嵌入式系统 <a class="link-info" href="https://blackberry.qnx.com/en" rel="nofollow" title="QNX">QNX</a>、<a class="link-info" href="http://www.windriver.com.cn/products/vxworks/" rel="nofollow" title="VxWorks">VxWorks</a> 等等。</p> 
 <p>        （简介来自<a href="http://c.biancheng.net/view/1792.html" rel="nofollow" title="http://c.biancheng.net/view/1792.html">http://c.biancheng.net/view/1792.html</a>，里面还提供了 Qt 下载安装教程）</p> 
 <p><span style="color:#ffd900;"><strong><span style="background-color:#ed7976;">Qt Creator</span></strong></span>：</p> 
 <p>        除此以外，就像使用 <a class="link-info" href="https://visualstudio.microsoft.com/zh-hans/vs/" rel="nofollow" title="Visual Studio">Visual Studio</a> <a class="link-info" href="https://baike.baidu.com/item/%E9%9B%86%E6%88%90%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/298524" rel="nofollow" title="集成开发环境">集成开发环境</a>来创建Windows平台下的 <a class="link-info" href="https://learn.microsoft.com/zh-cn/dotnet/desktop/winforms/?view=netframeworkdesktop-4.8" rel="nofollow" title="Winform">Winform</a> / <a class="link-info" href="https://learn.microsoft.com/zh-cn/dotnet/desktop/wpf/introduction-to-wpf?view=netframeworkdesktop-4.8&amp;preserve-view=true" rel="nofollow" title="WPF">WPF</a> 应用程序一样；我们也需要一个类似的软件来创建基于 Qt 的应用程序。这个软件就是 <a class="link-info" href="https://www.qt.io/zh-cn/product/development-tools" rel="nofollow" title="Qt Creator">Qt Creator</a>。</p> 
 <p>        Qt Creator是跨平台的集成开发环境（IDE），可在Windows、Linux和macOS桌面操作系统上运行，并允许开发人员在桌面、移动和嵌入式平台创建应用程序。</p> 
</blockquote> 
<h2 id="2%E3%80%81%E5%85%B3%E4%BA%8E%E5%BC%95%E7%94%A8%E5%A4%B4%E6%96%87%E4%BB%B6%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BA%8B%E5%84%BF%EF%BC%9A%C2%A0"><span style="color:#9c8ec1;">2、关于引用头文件的一些事儿：</span> </h2> 
<p>以引用 <strong>QDebug</strong> 类为例，这里我偷懒贴一段 <a class="link-info" href="https://chat.openai.com/auth/login" rel="nofollow" title="ChatGPT">ChatGPT</a> 的回答： </p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/0b/86/hkl0Q9Cw_o.png"></p> 
<h2 id="3%E3%80%81%E4%BF%A1%E5%8F%B7(Signal)%E4%B8%8E%E6%A7%BD(Slot)%E6%9C%BA%E5%88%B6%EF%BC%9A"><span style="color:#9c8ec1;">3、信号(Signal)与槽(Slot)机制：</span></h2> 
<blockquote> 
 <ul><li>信号(Signal)：用于反映某件事情发生了，比如 <a class="link-info" href="https://doc.qt.io/qt-6/qpushbutton.html" rel="nofollow" title="QPushButton">QPushButton</a> 的 <span style="color:#956fe7;">clicked</span>、<span style="color:#956fe7;">pressed</span>、<span style="color:#956fe7;">released</span>、<span style="color:#956fe7;">toggled</span> 等信号。<strong><span style="color:#1a439c;"><span style="background-color:#d4e9d5;">本质是个特殊的成员函数</span></span><span style="color:#fe2c24;"><span style="background-color:#d4e9d5;">声明</span></span></strong>； 
   <ul><li>QPushButton 就是 <span style="color:#a2e043;">Qt</span> 中的按钮控件</li></ul></li><li><a class="link-info" href="https://baike.baidu.com/item/%E6%A7%BD/13875718" rel="nofollow" title="槽">槽</a>(Slot)：信号处理槽函数，用于响应信号；</li></ul> 
</blockquote> 
<p>        信号与槽之间是一种<strong><span style="background-color:#d7d8d9;">松散耦合</span></strong>的关系，信号 发送端 和 接收端 本身是没有关联的；但我们可以通过 <strong>connect</strong> 方法绑定 <span style="color:#956fe7;">信号</span> 与对应的 <span style="color:#38d8f0;">槽函数</span> ： </p> 
<pre><code class="language-cpp">connect( 信号发送者sender，发出的信号signal，信号接收者receiver，信号处理slot（槽）)</code></pre> 
<p>        比如我们点击窗口右上角的 "<strong>×</strong>" 按钮，窗口就关闭了。在这里面："<strong>×</strong>" 按钮即信号发送者；"点击" 即那个具体的<span style="color:#956fe7;">信号</span>；"窗口" 即信号接收者；"关闭窗口" 函数即信号处理<span style="color:#38d8f0;">槽函数</span>。</p> 
<p>        下面是一个真实使用 <strong>connect</strong> 方法的 <strong>C++</strong> 代码语句，仅供参考：</p> 
<pre><code class="language-cpp">connect( myTestBtn, &amp;QPushButton::clicked, this, &amp;QWidget::close );</code></pre> 
<h3 id="3.1%E3%80%81%E4%B8%80%E4%B8%AA%E5%B0%8F%E4%BE%8B%E5%AD%90%EF%BC%9A%C2%A0"><span style="color:#9c8ec1;">3.1、一个小例子：</span> </h3> 
<blockquote> 
 <p>        下面，我将举一个生活中的例子帮助大家更好地理解 <span style="color:#956fe7;">信号</span> 与 <span style="color:#38d8f0;">槽</span>。不过，其实通过上面的叙述，我相信大部分小伙伴对信号与槽的概念已经非常清晰明朗了；而且，我自己也认为下面这个例子有些小题大做了。所以，<span style="color:#1c7331;"><strong>这一小节的内容大家酌情跳过！</strong></span></p> 
 <p><span style="color:#1c7331;"><strong>        </strong></span>在短跑比赛中，我们都知道<span style="color:#eaf4fc;"><span style="background-color:#ed7976;">鸣枪是比赛开始的信号</span></span>。下面是第一个问题：</p> 
 <p>                <strong>“谁是信号的发送者？裁判还是裁判手上的那把枪？别往下看先思考一下！”</strong> </p> 
 <p><strong>        </strong>以生活常识的角度来看，我认为发送者应该是裁判。因为显然枪是没法主导自己应该什么时候发射的，而且枪也不能自主发射信号弹，是裁判去扣动扳机发射的，信号的发出是由人来主导的。就像我经常在电视上听到那些体育竞赛的解说员说：“裁判发出了比赛结束的信号，本场比赛的胜者是谁谁谁”，可能以常识来说，大部分人会认为裁判是信号的发送者。</p> 
 <p>        然而计算机是“叛逆”且“纯粹”的。在计算机的世界里，谁能发出信号，谁就是信号的发送者，就这么简单。既然"枪响"是信号，那裁判本身能发出枪响吗？不能。只有枪才能发出枪响嘛，所以信号的发送者是枪而不是手握信号枪扣动扳机的裁判。就像我们点击窗口右上角的 "<strong>×</strong>" 按钮，窗口就关闭了，信号的发送者是 "<strong>×</strong>" 按钮而不是手握鼠标点击按钮的我们。</p> 
 <p>        这一点明了后，关于这个例子中，<span style="color:#956fe7;">信号</span> 是“鸣枪”或者说是“枪响”应该能理解就不多做解释了。接下来是第二个问题：</p> 
 <p>                <strong>“上面我们提到信号用于反映某件事情发生了，那这个例子中信号反映了什么事情发生了呢？是反映 "扣动扳机，发射信号弹" 这件事发生了还是反映 "短跑比赛开始了" 这件事发生了？还是先思考一下！</strong><strong>”</strong></p> 
 <p>        我认为，应该是反映 "扣动扳机，发射信号弹" 这件事发生了。因为 “鸣枪” 可能只是发生在在一个普通的早晨，发生在观众们还在家中休息、运动员还在场馆训练的时候，裁判只是从仓库里拿出这把信号枪来，朝天扣动扳机 “鸣枪” 以试试信号枪还好不好用，以免正式比赛出岔子。这个时候“鸣枪”显然不能说是在反映 "短跑比赛开始了" 这件事发生了。事实上，我们现在就可以把 "短跑比赛开始了" 理解为<span style="color:#38d8f0;">槽函数</span>了，因为短跑比赛一开始，运动员就起跑；而运动员起跑，就是在响应 “鸣枪” 信号；而响应处理信号的，那就是<span style="color:#38d8f0;">槽函数</span>嘛。所以，“<span style="color:#956fe7;">鸣枪</span>” 就是纯粹地反映 "开枪了" 这件事儿发生了，而 "短跑比赛开始"/"运动员起跑" 就可以称之为信号处理<span style="color:#38d8f0;">槽函数</span>，它们之间没有任何关联。这就像 Qt 中 QPushButton 按钮的 <span style="color:#956fe7;">clicked</span> 信号就是反映 "点击按钮" 这件事儿发生了，和 "关闭窗口" 没有任何关系。这就是上面提到的 —— <span style="color:#1a439c;">信号与槽之间是一种<strong><span style="background-color:#d7d8d9;">松散耦合</span></strong>的关系，信号 发送端 和 接收端 本身是没有关联的</span>。</p> 
 <p>        真正将 “鸣枪” 与 “短跑比赛开始” 建立起联系来的，就是正式比赛那天，观众们走出家门、来到场馆，运动员结束训练、站在起跑线，裁判到场就位、整装待发之时，所有人都心知肚明 —— “枪一响，比赛就开始！”，这个时候，它们就建立起联系了。而在 Qt 中，这一切可以简单地用 <strong>connect</strong> 方法实现。</p> 
 <p>        最后，我们梳理下思绪，总结下这个例子：</p> 
 <p>                若以「信号(Signal)与槽(Slot)」的机制来理解本例。那么在本例中，信号的发送者是 <span style="color:#fe2c24;"><strong>裁判手中的那把枪</strong></span> ；发出的信号是 <strong><span style="color:#956fe7;">鸣枪/枪响</span></strong> ；信号的接收者是 <span style="color:#ff9900;"><strong>运动员</strong></span> ；信号处理槽函数是 <strong><span style="color:#38d8f0;">短跑比赛开始/运动员起跑</span></strong> 。</p> 
</blockquote> 
<h2 id="4%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BF%A1%E5%8F%B7%E4%B8%8E%E6%A7%BD%EF%BC%9A%C2%A0"><span style="color:#9c8ec1;">4、自定义信号与槽：</span> </h2> 
<p>        接下来例举一个简单的自定义信号与槽的 <strong>C++</strong> 代码例，该例主要包含三大部分：自定义信号 <span style="color:#ff9900;"><strong>myprintsignal() </strong></span>(在MySignal类中声明)、自定义槽 <span style="color:#ff9900;"><strong>myprintslot()</strong></span> (在MySlot类中声明与定义)、发出信号的方法 <span style="color:#ff9900;"><strong>startprint() </strong></span>(在Widget类中声明与定义) 以及 它们相应的重载。</p> 
<blockquote> 
 <p>        这里简单提一下发出信号的方法 <span style="color:#ff9900;"><strong>startprint()</strong></span> ：我们知道对于自带的信号比如 QPushButton 的 <span style="color:#956fe7;">clicked</span> 点击信号，已经写好了当我们点击按钮时就会发送信号。而对于自定义的信号与槽，<strong>connect</strong> 仅仅只是把信号和槽连接起来了，但还没有说啥时候发信号。</p> 
 <p>        这个时候，我们一般就需要写一个发出信号的方法，调用该方法时，就可以发出信号啦~</p> 
</blockquote> 
<blockquote> 
 <p><span style="color:#edf6e8;"><strong><span style="background-color:#333333;">信号：</span></strong></span> </p> 
 <pre><code class="language-cpp">/* mysignal.h */
#ifndef MYSIGNAL_H
#define MYSIGNAL_H

#include &lt;QObject&gt;

class MySignal : public QObject
{
    Q_OBJECT
public:
    explicit MySignal(QObject *parent = nullptr);

signals:
    //自定义信号写在 signals 下
    //自定义信号无返回值，只需声明，无需在.cpp中定义
    //自定义信号可以有参数，可以重载
    //这里自定义一个我的打印信号
    void myprintsignal();

    //重载自定义信号
    void myprintsignal(QString text);
};

#endif // MYSIGNAL_H</code></pre> 
 <pre><code class="language-cpp">/* mysignal.cpp */
#include "mysignal.h"

MySignal::MySignal(QObject *parent) : QObject(parent)
{

}</code></pre> 
</blockquote> 
<blockquote> 
 <p><span style="color:#edf6e8;"><strong><span style="background-color:#333333;">槽：</span></strong></span> </p> 
 <pre><code class="language-cpp">/* myslot.h */
#ifndef MYSLOT_H
#define MYSLOT_H

#include &lt;QObject&gt;

class MySlot : public QObject
{
    Q_OBJECT
public:
    explicit MySlot(QObject *parent = nullptr);
    //高版本Qt允许自定义槽函数写在public或者全局下
    //自定义槽函数无返回值，同时需要声明和定义
    //自定义槽函数可以有参数，可以重载
    //这里自定义一个我的打印槽函数
    void myprintslot();

    //重载槽函数
    void myprintslot(QString text);
signals:

};

#endif // MYSLOT_H</code></pre> 
 <pre><code class="language-cpp">/* myslot.cpp */
#include "myslot.h"
#include &lt;QDebug&gt;

MySlot::MySlot(QObject *parent) : QObject(parent)
{

}

void MySlot::myprintslot()
{
    qDebug() &lt;&lt; "这是我自定义的打印槽函数";
}

void MySlot::myprintslot(QString text)
{
    //将 QString 类型转换为 char * 类型，打印出来的文本就没有引号了
    qDebug() &lt;&lt; text.toUtf8().data();    
}</code></pre> 
</blockquote> 
<blockquote> 
 <p><span style="color:#edf6e8;"><strong><span style="background-color:#333333;">窗口：</span></strong></span> </p> 
 <pre><code class="language-cpp">/* widget.h */
#ifndef WIDGET_H
#define WIDGET_H

#include &lt;QWidget&gt;
#include "mysignal.h"
#include "myslot.h"

QT_BEGIN_NAMESPACE
namespace Ui { class Widget; }
QT_END_NAMESPACE

class Widget : public QWidget
{
    Q_OBJECT

public:
    Widget(QWidget *parent = nullptr);
    ~Widget();

private:
    Ui::Widget *ui;

    //声明一个私有的MySignal对象
    MySignal* _mysignal;
    //声明一个私有的MySlot对象
    MySlot* _myslot;

    void startprint();

    //重载发出信号方法
    void startprint(QString text);
};
#endif // WIDGET_H</code></pre> 
 <pre><code class="language-cpp">/* widget.cpp */
#include "widget.h"
#include "ui_widget.h"

Widget::Widget(QWidget *parent)
    : QWidget(parent)
    , ui(new Ui::Widget)
{
    ui-&gt;setupUi(this);
    this-&gt;setFixedSize(300,300);

    //实例化一个MySignal对象
    _mysignal = new MySignal(this);

    //实例化一个MySlot对象
    _myslot = new MySlot(this);

    //定义函数指针(对于无参的可以在参数列表写个void，也可以空白)
    void (MySignal:: *signalpointer1)() = &amp;MySignal::myprintsignal;
    void (MySlot:: *slotpointer1)(void) = &amp;MySlot::myprintslot;
    void (MySignal:: *signalpointer2)(QString) = &amp;MySignal::myprintsignal;
    void (MySlot:: *slotpointer2)(QString) = &amp;MySlot::myprintslot;

    //建立连接
    connect(_mysignal, signalpointer1, _myslot, slotpointer1);
    connect(_mysignal, signalpointer2, _myslot, slotpointer2);

    //调用"开始打印"方法，即可发出信号，即可自动调用槽函数
    startprint();
    startprint("这是我重载的打印槽函数");
}

//开始打印方法
void Widget::startprint()
{
    //该方法用于发出信号
    emit _mysignal-&gt;myprintsignal();
}

void Widget::startprint(QString text)
{
    //发出带参数的信号
    emit _mysignal-&gt;myprintsignal(text);
}

Widget::~Widget()
{
    delete ui;
}</code></pre> 
 <p>        通过窗口类 Widget::startprint() 方法可以看到，自定义信号是通过 <strong>emit</strong> <span style="color:#ff9900;">关键字</span>发出的；而 <strong>emit</strong> <span style="color:#ff9900;">关键字</span>的存在是为了让程序员在看到 <strong>emit</strong> 语句时知道这里在做的事情是发出该信号。</p> 
 <p class="img-center"><img alt="" src="https://images2.imgbox.com/e9/fd/TQKwshnP_o.png"></p> 
</blockquote> 
<h3 id="4.1%E3%80%81%E8%BF%90%E8%A1%8C%E6%95%88%E6%9E%9C%EF%BC%9A"><span style="color:#9c8ec1;">4.1、运行效果：</span></h3> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/09/8b/BTZnnXyB_o.png"></p> 
<h2 id="5%E3%80%81%E4%BF%A1%E5%8F%B7%E4%B8%8E%E6%A7%BD%E7%9A%84%E7%89%B9%E7%82%B9%EF%BC%9A%C2%A0"><span style="color:#9c8ec1;">5、信号与槽的特性：</span> </h2> 
<ol><li>一个信号可以绑定连接到多个槽；</li><li>多个信号可以绑定连接到一个槽；</li><li>信号的参数个数可以多于槽函数的参数个数，反之不行；</li><li>信号和槽函数都有的参数，类型必须按照参数表从头一一对应。以上面自定义的信号和槽为例： <pre><code class="language-cpp">//假设信号声明成这样：
void myprintsignal(int num, QString text);


//那么，这样的槽是允许与该信号 connect 的：
void myprintslot(int num, QString text);
void myprintslot(int num);
void myprintslot();

//而这样的槽是不允许的：
void myprintslot(QString text);
void myprintslot(QString text, int num);
void myprintslot(int num, bool flag);
void myprintslot(int num, QString text, bool flag);</code></pre> </li><li>一个信号可以连接另一个信号：还是以上面自定义的信号与槽为例，假设我们在窗口内新增了一个 QPushButton 命名为 "<strong>btn</strong>"，现在我们想用按钮的"<span style="color:#956fe7;">点击</span>"信号去触发另一个不带参数的 <span style="color:#956fe7;">myprintsignal()</span> 信号。我们同样用 <span style="color:#e6b223;">connect</span> 把这两个信号绑定连接起来就可以了： <pre><code class="language-cpp">//信号连接信号
QPushButton* btn = new QPushButton("打印", this);
connect(btn, &amp;QPushButton::clicked, _mysignal, signalpointer1);

/*对于信号之间的连接，同样满足前面的4条特性：
比如在官方文档提供的信息中，QPushButton 的 clicked 信号声明形式是：
void clicked(bool checked = false);
那么 clicked 信号就不能与
void myprintsignal(QString text);
信号相绑定连接*/</code></pre> </li><li>运行效果如下图所示：<img alt="" src="https://images2.imgbox.com/b0/86/tewBLG0x_o.png"></li><li>信号是可以断开的，信号与槽的连接、信号与信号的连接都是可以断开的。调用 <span style="color:#e6b223;">disconnect</span>  方法断开信号即可： <pre><code class="language-cpp">//断开信号
disconnect(_mysignal, signalpointer1, _myslot, slotpointer1);
disconnect(btn, &amp;QPushButton::clicked, _mysignal, signalpointer1);</code></pre> </li></ol> 
<h2 id="6%E3%80%81Qt%204%20%E7%89%88%E6%9C%AC%E4%BB%A5%E5%89%8D%20connect%20%E7%94%A8%E6%B3%95%EF%BC%9A"><span style="color:#9c8ec1;">6、Qt 4 版本以前 connect 用法：</span></h2> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/54/21/fSeRv2mP_o.png"></p> 
<p>        本文使用的 Qt 版本是 <strong>5.14.2</strong>，在稍早一些的 Qt 版本比如 Qt 4 版本以前，<span style="color:#e6b223;">connect</span> 方法的使用方式会有些许不同。还是以上面自定义的信号和槽为例，现我们绑定链接无参的 <span style="color:#956fe7;">myprintsignal()</span> 信号和无参的 <span style="color:#38d8f0;">myprintslot()</span> 槽，形式应当如下：</p> 
<pre><code class="language-cpp">connect(_mysignal, SIGNAL(myprintsignal()), _myslot, SLOT(myprintslot()));</code></pre> 
<p>        这个形式在目前的 Qt 5 和 Qt 6 版本仍然是适用的。不过需要注意的是：若要使用这种形式，就必须把槽函数声明在 <span style="color:#ad720d;">public</span> <span style="color:#1a439c;">slots:</span> 下！若声明在 <span style="color:#ad720d;">public</span> 或<span style="color:#1c7331;">全局</span>下则会弹出找不到槽的提示：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/32/ac/bgHQuD6m_o.png"></p> 
<p>        这个形式优点是参数直观；缺点是类型不安全。<span style="color:#1c7331;"><strong>所以现在不推荐使用了</strong></span>。</p> 
<h2 id="7%E3%80%81%E4%BD%BF%E7%94%A8%20Lambda%20%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%EF%BC%9A"><span style="color:#9c8ec1;">7、使用 Lambda 表达式建立连接：</span></h2> 
<p>        <a class="link-info" href="http://c.biancheng.net/view/3741.html" rel="nofollow" title="Lambda 表达式">Lambda 表达式</a>（<span style="color:#cccccc;"><strong>匿名函数</strong></span>）是 C++ 11 中的新特性。对于本文<span style="color:#9c8ec1;"><strong>第 5 章</strong></span>提到的信号和槽函数的参数特性（第3条和第4条特性），我们可以使用 Lambda 表达式来解决参数限制的问题。比如现在我们来修改下第5条特性（信号连接信号）的那段代码：</p> 
<pre><code class="language-cpp">connect(btn, &amp;QPushButton::clicked, _mysignal, [=](){
    emit _mysignal-&gt;myprintsignal("这是使用 Lambda 表达式的连接");   //在匿名函数中发送带参信号
    btn-&gt;setText("test");                                          //在匿名函数中调用普通成员函数
    _myslot-&gt;myprintslot("测试下呢");                               //在匿名函数中调用槽
});</code></pre> 
<p>运行效果如下图：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/57/0f/noOCNlj8_o.png"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f67a5911d648c287781d143ef98beaff/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">使用QT的QML实时显示海康威视网络摄像头的视频数据</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0137f98b99719e7aef7556fb14ce8503/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">QT组件布局</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>