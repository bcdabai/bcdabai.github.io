<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>skynet学习笔记 源码之skynet_timer定时器 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="skynet学习笔记 源码之skynet_timer定时器" />
<meta property="og:description" content="定时器简介 skynet.timeout(ti,func)
skynet定时器非常的轻量级，仅仅提供注册函数，并且还不能传参。
定时器的实现仅仅用了300行代码。
定时器注册回调流程 通过调用capi把定时任务加入，最终以消息的方式传回本actor，用worker线程处理消息，执行注册函数。
function skynet.timeout(ti, func) local session = c.intcommand(&#34;TIMEOUT&#34;,ti) .... end static int lintcommand(lua_State *L) { result = skynet_command(context, cmd, parm); ... } cmd_timeout(struct skynet_context * context, const char * param) { ... skynet_timeout(context-&gt;handle, ti, session); ... } int skynet_timeout(uint32_t handle, int time, int session) { if (time &lt;= 0) { struct skynet_message message; message.source = 0; message.session = session; message.data = NULL; message.sz = (size_t)PTYPE_RESPONSE &lt;&lt; MESSAGE_TYPE_SHIFT; if (skynet_context_push(handle, &amp;message)) { return -1; } } else { struct timer_event event; event." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/d52cdff8719a0d6414988b746a513b63/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-04-27T20:41:10+08:00" />
<meta property="article:modified_time" content="2023-04-27T20:41:10+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">skynet学习笔记 源码之skynet_timer定时器</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>定时器简介</h2> 
<p>skynet.timeout(ti,func)</p> 
<p>skynet定时器非常的轻量级，仅仅提供注册函数，并且还不能传参。</p> 
<p>定时器的实现仅仅用了300行代码。</p> 
<h3>定时器注册回调流程</h3> 
<p>通过调用capi把定时任务加入，最终以消息的方式传回本actor，用worker线程处理消息，执行注册函数。</p> 
<pre><code>function skynet.timeout(ti, func)

    local session = c.intcommand("TIMEOUT",ti)

    ....

end

static int lintcommand(lua_State *L) {

result = skynet_command(context, cmd, parm);

...

}

cmd_timeout(struct skynet_context * context, const char * param) {

...

    skynet_timeout(context-&gt;handle, ti, session);

...

}

int

skynet_timeout(uint32_t handle, int time, int session) {

    if (time &lt;= 0) {

        struct skynet_message message;

        message.source = 0;

        message.session = session;

        message.data = NULL;

        message.sz = (size_t)PTYPE_RESPONSE &lt;&lt; MESSAGE_TYPE_SHIFT;



        if (skynet_context_push(handle, &amp;message)) {

            return -1;

        }

    } else {

        struct timer_event event;

        event.handle = handle;

        event.session = session;

        timer_add(TI, &amp;event, sizeof(event), time);

    }

    return session;

}</code></pre> 
<h3>源码原理分析</h3> 
<p>skynet的设计思想参考Linux内核动态定时器的机制，参考Linux动态内核定时器介绍<a href="http://www.cnblogs.com/leaven/archive/2010/08/19/1803382.html" rel="nofollow" title="linux 内核定时器 timer_list详解 - 海王 - 博客园">linux 内核定时器 timer_list详解 - 海王 - 博客园</a></p> 
<p>近期链表：0-255个滴答数的定时任务会加入。特征：链表里都是触发时间相同的</p> 
<p>散列链表：256 &lt;= interval &lt;= 0xffffffff 加入。   特征：链表里触发时间不一定相同</p> 
<p>滴答数： skynet的定时器精度为0.01秒，按照它算法的定义就是0.01为1个滴答数。</p> 
<p>到期时间：每一个加入的定时任务都会给它标记一个到期时间（加入时定时器当前滴答数+定时滴答数）。</p> 
<p>skynet每次update都会取当前时间减去上次update时间获取流逝的滴答数。</p> 
<p>然后把流逝的滴答数一滴答一滴答的执行。</p> 
<p>执行过程中只关心到期间隔时间为 0 到 255 滴答数的处理。暂时不关注256 &lt;= interval &lt;= 0xffffffff。</p> 
<p>滴答滴答流逝过程中，每走完一次0到255就会有一个对应的散列链表被移动（其实就是重新加入定时器，会重新给它们定位。</p> 
<h3>skynet.h</h3> 
<pre><code>int skynet_timeout(uint32_t handle, int time, int session);      //注册定时任务

void skynet_updatetime(void);                                               //更新定时任务处理

void skynet_timer_init(void);                                                  //初始化</code></pre> 
<h3>数据结构</h3> 
<pre><code>#define TIME_NEAR_SHIFT 8

#define TIME_NEAR (1 &lt;&lt; TIME_NEAR_SHIFT)

#define TIME_LEVEL_SHIFT 6

#define TIME_LEVEL (1 &lt;&lt; TIME_LEVEL_SHIFT)

#define TIME_NEAR_MASK (TIME_NEAR-1)

#define TIME_LEVEL_MASK (TIME_LEVEL-1)



struct timer_event {

    uint32_t handle;

    int session;

};



struct timer_node {

    struct timer_node *next;

    uint32_t expire;

};



struct link_list {

    struct timer_node head;

    struct timer_node *tail;

};

struct timer {

    struct link_list near[TIME_NEAR];  //近期链表长度256 记录0到255间隔触发的定时任务

    struct link_list t[4][TIME_LEVEL];   //散列链表记录256 到 0xffffffff间隔触发的定时任务

    struct spinlock lock;                        //自旋锁

    uint32_t time;                                 //定时器自增的滴答数

    uint32_t starttime;                          //程序开始时间

    uint64_t current;                             //上次记录的系统时间

    uint64_t current_point;                   //上次记录的从开机到现在的时间，不受系统时间修改影响

};</code></pre> 
<h3>定时器驱动函数</h3> 
<p>sknyet定时间隔0.00025秒调一次skynet_updatetime，</p> 
<p>skynet_updatetime会获取当前运行时间，然后减去上次记录时间，拿到一个流逝的滴答数，然后调用timer_update</p> 
<pre><code>static void *

thread_timer(void *p) {

   ....

    for (;;) {

        skynet_updatetime();

        usleep(2500);

    }

.....

}



void

skynet_updatetime(void) {

    uint64_t cp = gettime();

    if(cp &lt; TI-&gt;current_point) {

        skynet_error(NULL, "time diff error: change from %lld to %lld", cp, TI-&gt;current_point);

        TI-&gt;current_point = cp;

    } else if (cp != TI-&gt;current_point) {

        uint32_t diff = (uint32_t)(cp - TI-&gt;current_point);

        TI-&gt;current_point = cp;

      TI-&gt;current += diff;

        int i;

        for (i=0;i&lt;diff;i++) {

            timer_update(TI);

        }

    }

}

static void 

timer_update(struct timer *T) {

    SPIN_LOCK(T);



    // try to dispatch timeout 0 (rare condition)

    timer_execute(T);                                               



    // shift time first, and then dispatch timer message

    timer_shift(T);



    timer_execute(T);



    SPIN_UNLOCK(T);

}</code></pre> 
<h3>处理到期的定时任务</h3> 
<pre><code>static inline void

timer_execute(struct timer *T) {

    int idx = T-&gt;time &amp; TIME_NEAR_MASK;     取得当前处于0到255的哪个位置

    while (T-&gt;near[idx].head.next) {

        struct timer_node *current = link_clear(&amp;T-&gt;near[idx]);  //取出链表数据

        SPIN_UNLOCK(T);

        // dispatch_list don't need lock T

        dispatch_list(current);                                                     //处理到期任务

        SPIN_LOCK(T);

    }

}</code></pre> 
<h3>调整散列列表</h3> 
<pre><code>static void

timer_shift(struct timer *T) {

    int mask = TIME_NEAR;

    uint32_t ct = ++T-&gt;time;       //自增滴答数

    if (ct == 0) {                          //add_node ct为0时会加入到 散列列表3，0位置

        move_list(T, 3, 0);

    } else {

        uint32_t time = ct &gt;&gt; TIME_NEAR_SHIFT;

        int i=0;

        while ((ct &amp; (mask-1))==0) {                    前 7位都为0时满足条件，也就是每过255滴答数触发一次。

            int idx=time &amp; TIME_LEVEL_MASK;  取得散列列表的位置id

            if (idx!=0) {

                move_list(T, i, idx);                          调整

                break;              

            }

            mask &lt;&lt;= TIME_LEVEL_SHIFT;

            time &gt;&gt;= TIME_LEVEL_SHIFT;

            ++i;

        }

    }

}</code></pre> 
<p>调整函数就是把列表内容拿出来重新加入到定时器。</p> 
<pre><code>static void

move_list(struct timer *T, int level, int idx) {

    struct timer_node *current = link_clear(&amp;T-&gt;t[level][idx]);

    while (current) {

        struct timer_node *temp=current-&gt;next;

        add_node(T,current);

        current=temp;

    }

}</code></pre> 
<h3>加入定时器处理</h3> 
<pre><code>static void

add_node(struct timer *T,struct timer_node *node) {

    uint32_t time=node-&gt;expire;     //该定时任务触发滴答数

    uint32_t current_time=T-&gt;time; //定时器当前滴答数

   

    if ((time|TIME_NEAR_MASK)==(current_time|TIME_NEAR_MASK)) {  
前7位可以不一样，7位以后必须一样，也就是说间隔触发时间只有0-255之间（特殊情况，current_time为0的时候time不为0会加入到散列链表 3，0位置）

        link(&amp;T-&gt;near[time&amp;TIME_NEAR_MASK],node);

    } else {

        int i;

        uint32_t mask=TIME_NEAR &lt;&lt; TIME_LEVEL_SHIFT;

        for (i=0;i&lt;3;i++) {

            if ((time|(mask-1))==(current_time|(mask-1))) {

                break;

            }

            mask &lt;&lt;= TIME_LEVEL_SHIFT;

        }



        link(&amp;T-&gt;t[i][((time&gt;&gt;(TIME_NEAR_SHIFT + i*TIME_LEVEL_SHIFT)) &amp; TIME_LEVEL_MASK)],node);    

    }

}</code></pre> 
<h4>仅个人理解，供参考</h4>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/fa9e5fc2f74cf48f8b1024881b81586d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">利用python爬虫爬取旅游网信息</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d33131be3c786832c925a64017ff6652/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">魔兽世界服务端用户注册以及网页的搭建教程</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>