<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>pinctrl和gpio子系统 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="pinctrl和gpio子系统" />
<meta property="og:description" content="一、pinctrl子系统简介
Linux驱动讲究驱动分离与分层，pinctrl和gpio子系统就是驱动分离与分层思想下的产物，pinctrl子系统主要工作内容如下：
获取设备树中的pin信息
根据获取到的pin信息来设置pin的复用功能
根据获取到的pin信息来设置pin的电气属性，比如上下拉、速度、驱动能力等
引脚的宏定义在imx6u-pinfunc.h这个头文件
设备树中添加pinctrl节点模板
1、创建对应的节点
同一个外设的pin都放到一个节点里面，打开imx6ull-alientek-emmc.dts，在iomuxc下面添加pinctrl_gpio_leds节点，添加完成后
pinctrl_gpio_leds: gpio-leds { fsl,pins = &lt; MX6UL_PAD_GPIO1_IO03__GPIO1_IO03 0x17059 &gt;; }; 其中fsl.pins是固定属性，里面写的是设备所使用的PIN配置信息
二、gpio子系统
设置好设备树以后就可以使用gpio子系统提供的API函数来操作指定的GPIO，gpio子系统向驱动开发人员屏蔽了具体的读写寄存器过程。gpio子系统常用的API函数有下面几个：
1、gpio_request函数
gpio_request 函数用于申请一个 GPIO 管脚，在使用一个 GPIO 之前一定要使用 gpio_request
进行申请，函数原型如下：
int gpio_request(unsigned gpio, const char *label) 函数参数和返回值含义如下：
gpio：要申请的 gpio 标号，使用 of_get_named_gpio 函数从设备树获取指定 GPIO 属性信
息，此函数会返回这个 GPIO 的标号。
label：给 gpio 设置个名字。
返回值：0，申请成功；其他值，申请失败。
2、gpio_free函数
如果不使用某个 GPIO 了，那么就可以调用 gpio_free 函数进行释放。函数原型如下：
void gpio_free(unsigned gpio) 函数参数和返回值含义如下：
gpio：要释放的 gpio 标号。
返回值：无。
3、gpio_direction_input函数
此函数用于设置某个 GPIO 为输入，函数原型如下所示：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/2b8fa07d31c160830e9c1acb84c8d9fb/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-03-11T20:41:37+08:00" />
<meta property="article:modified_time" content="2023-03-11T20:41:37+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">pinctrl和gpio子系统</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div class="kdocs-document"> 
 <p style="">一、pinctrl子系统简介</p> 
 <p style="">Linux驱动讲究驱动分离与分层，pinctrl和gpio子系统就是驱动分离与分层思想下的产物，pinctrl子系统主要工作内容如下：</p> 
 <ol start="1"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>获取设备树中的pin信息</p></li></ol> 
 <ol start="2"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>根据获取到的pin信息来设置pin的复用功能</p></li></ol> 
 <ol start="3"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>根据获取到的pin信息来设置pin的电气属性，比如上下拉、速度、驱动能力等</p></li></ol> 
 <p style="">引脚的宏定义在imx6u-pinfunc.h这个头文件</p> 
 <p style="">设备树中添加pinctrl节点模板</p> 
 <p style="">1、创建对应的节点</p> 
 <p style="">同一个外设的pin都放到一个节点里面，打开imx6ull-alientek-emmc.dts，在iomuxc下面添加pinctrl_gpio_leds节点，添加完成后</p> 
 <pre class="kdocs-cpp"><code class="language-cpp">pinctrl_gpio_leds: gpio-leds {
            fsl,pins = &lt;
                MX6UL_PAD_GPIO1_IO03__GPIO1_IO03    0x17059
            &gt;;
};</code></pre> 
 <p style="">其中fsl.pins是固定属性，里面写的是设备所使用的PIN配置信息</p> 
 <p style="">二、gpio子系统</p> 
 <p style="">设置好设备树以后就可以使用gpio子系统提供的API函数来操作指定的GPIO，gpio子系统向驱动开发人员屏蔽了具体的读写寄存器过程。gpio子系统常用的API函数有下面几个：</p> 
 <p style="">1、gpio_request函数</p> 
 <p style="">gpio_request 函数用于申请一个 GPIO 管脚，在使用一个 GPIO 之前一定要使用 gpio_request</p> 
 <p style="">进行申请，函数原型如下：</p> 
 <blockquote class="kdocs-blockquote" style="">
   int gpio_request(unsigned gpio, const char *label) 
 </blockquote> 
 <p style="">函数参数和返回值含义如下：</p> 
 <p style=""><span class="kdocs-bold" style="font-weight:bold;">gpio</span>：要申请的 gpio 标号，使用 of_get_named_gpio 函数从设备树获取指定 GPIO 属性信</p> 
 <p style="">息，此函数会返回这个 GPIO 的标号。</p> 
 <p style=""><span class="kdocs-bold" style="font-weight:bold;">label</span>：给 gpio 设置个名字。</p> 
 <p style=""><span class="kdocs-bold" style="font-weight:bold;">返回值：</span>0，申请成功；其他值，申请失败。</p> 
 <p style="">2、gpio_free函数</p> 
 <p style="">如果不使用某个 GPIO 了，那么就可以调用 gpio_free 函数进行释放。函数原型如下：</p> 
 <blockquote class="kdocs-blockquote" style="">
   void gpio_free(unsigned gpio) 
 </blockquote> 
 <p style="">函数参数和返回值含义如下：</p> 
 <p style=""><span class="kdocs-bold" style="font-weight:bold;">gpio</span>：要释放的 gpio 标号。</p> 
 <p style=""><span class="kdocs-bold" style="font-weight:bold;">返回值：</span>无。</p> 
 <p style="">3、gpio_direction_input函数</p> 
 <p style="">此函数用于设置某个 GPIO 为输入，函数原型如下所示：</p> 
 <blockquote class="kdocs-blockquote" style="">
   int gpio_direction_input(unsigned gpio) 
 </blockquote> 
 <p style="">4、gpio_direction_output函数</p> 
 <p style="">此函数用于设置某个 GPIO 为输出，并且设置默认输出值，函数原型如下：</p> 
 <blockquote class="kdocs-blockquote" style="">
   int gpio_direction_output(unsigned gpio, int value) 
 </blockquote> 
 <p style="">函数参数和返回值含义如下：</p> 
 <p style=""><span class="kdocs-bold" style="font-weight:bold;">gpio</span>：要设置为输出的 GPIO 标号。</p> 
 <p style=""><span class="kdocs-bold" style="font-weight:bold;">value：</span>GPIO 默认输出值。</p> 
 <p style=""><span class="kdocs-bold" style="font-weight:bold;">返回值：</span>0，设置成功；负值，设置失败</p> 
 <p style="">5、gpio_get_value函数</p> 
 <p style="">此函数用于获取某个 GPIO 的值(0 或 1)，此函数是个宏，定义所示：</p> 
 <blockquote class="kdocs-blockquote" style="">
   #define gpio_get_value __gpio_get_value 
  <br>int __gpio_get_value(unsigned gpio) 
 </blockquote> 
 <p style="">函数参数和返回值含义如下：</p> 
 <p style=""><span class="kdocs-bold" style="font-weight:bold;">gpio</span>：要获取的 GPIO 标号。</p> 
 <p style=""><span class="kdocs-bold" style="font-weight:bold;">返回值：</span>非负值，得到的 GPIO 值；负值，获取失败。</p> 
 <p style="">6、gpio_set_value函数</p> 
 <p style="">此函数用于设置某个 GPIO 的值，此函数是个宏，定义如下</p> 
 <blockquote class="kdocs-blockquote" style="">
   #define gpio_set_value __gpio_set_value 
  <br>void __gpio_set_value(unsigned gpio, int value) 
 </blockquote> 
 <p style="">函数参数和返回值含义如下：</p> 
 <p style=""><span class="kdocs-bold" style="font-weight:bold;">gpio</span>：要设置的 GPIO 标号。</p> 
 <p style=""><span class="kdocs-bold" style="font-weight:bold;">value：</span>要设置的值。</p> 
 <p style=""></p> 
 <p style="">添加LED设备节点</p> 
 <p style="">在个别节点“/”下创建LED灯节点，节点名是leds，节点内容如下：</p> 
 <pre class="kdocs-cpp"><code class="language-cpp">leds {
        compatible = "gpio-leds";
        pinctrl-names = "default";
        pinctrl-0 = &lt;&amp;pinctrl_gpio_leds&gt;;

        led1{
            label = "sys-led";
            gpios = &lt;&amp;gpio1 3 GPIO_ACTIVE_LOW&gt;;
            linux,default-trigger = "heartbeat";
            default-state = "on";
        };
    };</code></pre> 
 <p style="">检查PIN是否被其他外设使用</p> 
 <p style="">检查PIN有没有被其他外设使用包括两个方面</p> 
 <p style="">1、检查pinctrl设置</p> 
 <p style="">2、如果这个PIN配置为GPIO的话，检查这个GPIO有没有被别的外设使用</p> 
 <p style="">在本章实验中 LED 灯使用的 PIN 为 GPIO1_IO03，因此先检查 GPIO_IO03 这个 PIN 有没有被其他的 pinctrl 节点使用，在 imx6ull-alientek-emmc.dts 中找到如下内容：</p> 
 <pre class="kdocs-cpp"><code class="language-cpp">pinctrl_tsc: tscgrp {
            fsl,pins = &lt;
                MX6UL_PAD_GPIO1_IO01__GPIO1_IO01    0xb0
                MX6UL_PAD_GPIO1_IO02__GPIO1_IO02    0xb0
                MX6UL_PAD_GPIO1_IO03__GPIO1_IO03    0xb0
                MX6UL_PAD_GPIO1_IO04__GPIO1_IO04    0xb0
            &gt;;
};</code></pre> 
 <p style="">pinctrl_tsc 节点是 TSC(电阻触摸屏接口)的 pinctrl 节点，从第 5行可以看出，默认情况下</p> 
 <p style="">GPIO1_IO03 作为了 TSC 外设的 PIN。所以我们需要将第 5 行屏蔽掉！</p> 
 <p style="">因为本章实验我们将 GPIO1_IO03 这个 PIN 配置为了 GPIO，所以还需要查找一下有没有其他的外设使用了 GPIO1_IO03，在 imx6ull-alientek-emmc.dts 中搜索“gpio1 3”，找到如下内容：</p> 
 <pre class="kdocs-cpp"><code class="language-cpp">&amp;tsc {
    pinctrl-names = "default";
    pinctrl-0 = &lt;&amp;pinctrl_tsc&gt;;
    xnur-gpio = &lt;&amp;gpio1 3 GPIO_ACTIVE_LOW&gt;;
    measure-delay-time = &lt;0xffff&gt;;
    pre-charge-time = &lt;0xfff&gt;;
    status = "disabled";
};</code></pre> 
 <p style="">tsc 是 TSC 的外设节点，从 4行可以看出，tsc 外设也使用了 GPIO1_IO03，同样我们需要将这一行屏蔽掉。然后在继续搜索“gpio1 3”，看看除了本章的 LED 灯以外还有没有其他的地方也使用了 GPIO1_IO03，找到一个屏蔽一个</p> 
 <p style="">设备树编写完成以后使用“make dtbs”命令重新编译设备树，然后使用新编译出来的imx6ull-alientek-emmc.dtb 文件启动 Linux 系统。启动成功以后进入“/proc/device-tree”目录中查看“gpioled”节点是否存在，如果存在的话就说明设备树基本修改成功</p> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:1163px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:34.909718%;height:0;"> 
    <img src="https://images2.imgbox.com/44/30/DPlnkY42_o.png" style="margin-left:;display:block;width:1163px;margin-top:-34.909718%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style="">三、LED灯驱动程序编写</p> 
 <p style="">创建工程，工作区命名为DTSLED，工程创建好以后新建dtsled.c文件，输入内容</p> 
 <pre class="kdocs-cpp"><code class="language-cpp">#include &lt;linux/module.h&gt;
#include &lt;linux/kernel.h&gt;
#include &lt;linux/init.h&gt;
#include &lt;linux/fs.h&gt;
#include &lt;linux/slab.h&gt;
#include &lt;linux/uaccess.h&gt;
#include &lt;linux/io.h&gt;
#include &lt;linux/cdev.h&gt;
#include &lt;linux/device.h&gt;
#include &lt;linux/of.h&gt;
#include &lt;linux/of_address.h&gt;
#include &lt;linux/of_irq.h&gt;

#define DTSLED_CNT 1            /* 设备号个数 */
#define DTSLED_NAME "dtsled"    /* 名字 */
#define LEDON 1
#define LEDOFF 0

static void __iomem *IMX6U_CCM_CCGR1;
static void __iomem *SW_MUX_GPIO1_IO03;
static void __iomem *SW_PAD_GPIO1_IO03;
static void __iomem *GPIO1_DR;
static void __iomem *GPIO1_GDIR;

struct dtsled_dev{
   dev_t devid;                    //设备号                  
   struct cdev cdev;                //cdev     
   struct cdev *class;              //类
   struct device *device;           //设备
   int major;
   int minor;
   struct device_node *nd;
};

struct dtsled_dev dtsled;

static void led_switch(u8 sta)
{
    u32 val = 0;
    if(sta == LEDON){
        val = readl(GPIO1_DR);
        val &amp;= ~(1 &lt;&lt; 3);
        writel(val,GPIO1_DR);
    }else if(sta == LEDOFF){
        val = readl(GPIO1_DR);
        val |= (1 &lt;&lt; 3);
        writel(val,GPIO1_DR);
    }

}

static int dtsled_open(struct inode *inode,struct file *filp)
{
    filp-&gt;private_data = &amp;dtsled;
    return 0;
}

static int dtsled_release(struct inode *inode,struct file *filp)
{
    struct dtsled_dev *dev = (struct dtsled_dev*)filp-&gt;private_data;
    return 0;
}

static ssize_t dtsled_write(struct file *filp,const char __user *buf,
             size_t count,loff_t *ppos)
{
    struct dtsled_dev *dev = (struct dtsled_dev*)filp-&gt;private_data;

    int retvalue;
    unsigned char databuf[1];
    
    retvalue = copy_from_user(databuf, buf, count);
    if(retvalue &lt; 0) {
          return -EFAULT;
    }
    led_switch(databuf[0]);

    return 0;
}

static const struct file_operations dtsled_fops = {
    .owner = THIS_MODULE,
    .write = dtsled_write,
    .open = dtsled_open,
    .release = dtsled_release,
};

static int __init dtsled_init(void)
{
    int ret = 0;
    const char *str;
    u32 regdata[10];
    u8 i = 0;
    unsigned int val = 0;

    dtsled.major = 0;
    if(dtsled.major){
        dtsled.devid = MKDEV(dtsled.major,0);
        ret = register_chrdev_region(dtsled.devid,DTSLED_CNT,DTSLED_NAME);
    }else{
        ret = alloc_chrdev_region(&amp;dtsled.devid,0,DTSLED_CNT,DTSLED_NAME);
        dtsled.major = MAJOR(dtsled.devid);
        dtsled.minor = MINOR(dtsled.devid);
    }
    
    if(ret &lt; 0){
        goto fail_devid;
    }

    dtsled.cdev.owner = THIS_MODULE;
    cdev_init(&amp;dtsled.cdev,&amp;dtsled_fops);
    ret = cdev_add(&amp;dtsled.cdev,dtsled.devid,DTSLED_CNT);
    if(ret &lt; 0){
        goto fail_cdev;
    }

    dtsled.class = class_create(THIS_MODULE,DTSLED_CNT);
    if(IS_ERR(dtsled.class)){
        ret = PTR_ERR(dtsled.class);
        goto fail_class;
    }

    dtsled.device = device_create(dtsled.class,NULL,dtsled.devid,NULL,DTSLED_NAME);
    if(IS_ERR(dtsled.device)){
        ret = PTR_ERR(dtsled.device);
        goto fail_device;
    }

    dtsled.nd = of_find_node_by_path("/alphaled");
    if(dtsled.nd == NULL){
        ret = -EINVAL;
        goto fail_findnd;
    }

    ret = of_property_read_string(dtsled.nd,"status",&amp;str);
    if(ret &lt; 0){
        goto fail_rs;
    }
    else{
        printk("status = %s\r\n",str);
    }

    ret = of_property_read_string(dtsled.nd,"compatible",&amp;str);
    if(ret &lt; 0){
        goto fail_rs;
    }
    else{
        printk("compatible = %s\r\n",str);
    }

    ret = of_property_read_u32_array(dtsled.nd,"reg",regdata,10);
    if(ret &lt; 0){
        goto fail_rs;
    }
    else{
        printk("reg data:\r\n",str);
        for(i = 0;i &lt; 10;i++){
            printk("%#X ",regdata[i]);
        }
        printk("\r\n");
    }

    IMX6U_CCM_CCGR1 = ioremap(regdata[0], regdata[1]);
    SW_MUX_GPIO1_IO03 = ioremap(regdata[2], regdata[3]);
    SW_PAD_GPIO1_IO03 = ioremap(regdata[4], regdata[5]);
    GPIO1_DR = ioremap(regdata[6], regdata[7]);
    GPIO1_GDIR = ioremap(regdata[8], regdata[9]);

    val = readl(IMX6U_CCM_CCGR1);
    val &amp;= ~(3 &lt;&lt; 26); /* 清楚以前的设置 */
    val |= (3 &lt;&lt; 26); /* 设置新值 */
    writel(val, IMX6U_CCM_CCGR1);

    writel(5, SW_MUX_GPIO1_IO03);
    writel(0x10B0, SW_PAD_GPIO1_IO03);

    val = readl(GPIO1_GDIR);
    val |= (1 &lt;&lt; 3); /* 设置为输出 */
    writel(val, GPIO1_GDIR);

    val = readl(GPIO1_DR);
    val |= (1 &lt;&lt; 3); 
    writel(val, GPIO1_DR);

    return 0;
    
fail_rs:
fail_findnd:
    device_destroy(dtsled.class,dtsled.devid);
fail_device:
    class_destroy(dtsled.class);
fail_class:
    cdev_del(&amp;dtsled.cdev);
fail_cdev:
     unregister_chrdev_region(dtsled.devid,DTSLED_CNT);
fail_devid:
    return ret;
}
static void __exit dtsled_exit(void)
{
   unsigned int val = 0;
   val = readl(GPIO1_DR);
   val |= (1 &lt;&lt; 3);
   writel(val,GPIO1_DR);

   iounmap(IMX6U_CCM_CCGR1);
   iounmap(SW_MUX_GPIO1_IO03);
   iounmap(SW_PAD_GPIO1_IO03);
   iounmap(GPIO1_DR);
   iounmap(GPIO1_GDIR);

   cdev_del(&amp;dtsled.cdev);
   unregister_chrdev_region(dtsled.devid,DTSLED_CNT); 
   device_destroy(dtsled.class,dtsled.devid);
   class_destroy(dtsled.class);
}

module_init(dtsled_init);
module_exit(dtsled_exit);
MODULE_LICENSE("GPL");
MODULE_AUTHOR("mxh");
</code></pre> 
 <p style="">编写测试ledAPP.c</p> 
 <pre class="kdocs-cpp"><code class="language-cpp">#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#define LEDOFF 0
#define LEDON 1

int main(int argc,char *argv[])
{
    int fd,retvalue;
    char *filename;
    unsigned char databuf[1];

    if(argc != 3){
        printf("Error Usage!\r\n");
        return -1;
    }
    filename = argv[1];

    fd = open(filename,O_RDWR);
    if(fd &lt; 0)
    {
        printf("file %s open failed!\r\n",filename);
        return -1;
    }
    databuf[0] = atoi(argv[2]);
    retvalue = write(fd,databuf,sizeof(databuf));
    if(retvalue &lt; 0){
        printf("LED Control Failed!\r\n");
        close(fd);
        return -1;
    }

    close(fd);
    return 0;
}</code></pre> 
 <p style="">修改Makefile</p> 
 <pre class="kdocs-cpp"><code class="language-cpp">KERNELDIR := /home/mxh/linux/IMX6ULL/linux/linux-imx-rel_imx_4.1.15_2.1.0_ga

CURRENT_PATH := $(shell pwd)

obj-m := dtsled.o

build: kernel_modules

kernel_modules:
    $(MAKE) -C $(KERNELDIR) M=$(CURRENT_PATH) modules 
clean:
    $(MAKE) -C $(KERNELDIR) M=$(CURRENT_PATH) clean
</code></pre> 
 <p style="">编译</p> 
 <blockquote class="kdocs-blockquote" style="">
   make -j4 
 </blockquote> 
 <blockquote class="kdocs-blockquote" style="">
   arm-linux-gnueabihf-gcc ledAPP.c -o ledAPP 
 </blockquote> 
 <p style="">将上面编译出来的dtsled.ko和ledAPP这两个文件拷贝到rootfs/lib/modules/4.1.15目录，进入到lib/modules/4.1.15，输入如下命令加载dtsled.ko</p> 
 <blockquote class="kdocs-blockquote" style="">
   depmod 
  <br>modprobe dtsled.ko 
 </blockquote> 
 <p style="">加载成功以后测试</p> 
 <blockquote class="kdocs-blockquote" style="">
   ./ledAPP /dev/led 1 
  <br>./ledAPP /dev/led 0 
 </blockquote> 
 <p style=""></p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/85838d097f8c037fb5f49016f28350ab/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">VMware Workstation改默认语言为中文</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/80b2f713c8eb1bc07a7aa64529271a33/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">微信文件只读模式怎么解除，一步解决新版微信接收文件为只读属性的问题，附带多开和消息防撤回功能</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>