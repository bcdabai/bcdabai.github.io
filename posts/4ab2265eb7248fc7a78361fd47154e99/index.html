<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>POJ1043  What&#39;s In a Name       逆图&#43;完美匹配 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="POJ1043  What&#39;s In a Name       逆图&#43;完美匹配" />
<meta property="og:description" content="题目链接：
poj1043
题意:
一个犯罪团伙有N个人,他们分别有一个名字和一个网名
现已知他们会先后进出一个房间发送电报
警方可以知道所有时间下:
进出房间的人的真实名字
同时通过截获该房间发出的电报,获得网名
问最后能否将所有真实名字和虚拟网名对上
解题思路:
首先根据题目条件名字和网名是一一对应的,可以大概确定是二分匹配中的完美匹配
然而根据样例很容易看出来,要想根据正确关系来建边是很复杂的
容易的做法是:每次将不可能匹配的名字和网名建边,最后根据补图进行最大匹配即可初步得出所有匹配关系.
但现在得到的最大匹配不一定是完美匹配
要确定某个名字和网名是匹配的 我们可以删除当前已匹配的边,再进行最大匹配
如果结果减小了,则一定是对应的
这样,依次枚举每一条最大匹配中的边.即可得出答案
代码:
#include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;map&gt; #define maxn 25 using namespace std; struct node { string a,b; } s[maxn]; map&lt;string,int&gt;m1,m2; string s1[maxn]; int edge[maxn][maxn]; int link[maxn],vis[maxn]; int mark[maxn]; int id,n; void init() { memset(edge,0,sizeof(edge)); memset(mark,0,sizeof(mark)); id=1; m1.clear(),m2.clear(); } int cmp(node x,node y) { return x.a&lt;y.a; } int dfs(int u) { for(int i=1;i&lt;=n;i&#43;&#43;) { if(!" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/4ab2265eb7248fc7a78361fd47154e99/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2015-08-16T16:05:40+08:00" />
<meta property="article:modified_time" content="2015-08-16T16:05:40+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">POJ1043  What&#39;s In a Name       逆图&#43;完美匹配</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>题目链接：</p> 
<p><a target="_blank" href="http://poj.org/problem?id=1043" rel="nofollow noopener noreferrer">poj1043</a></p> 
<p><br> </p> 
<p><br> </p> 
<p><br> </p> 
<p>题意:</p> 
<p>一个犯罪团伙有N个人,他们分别有一个名字和一个网名</p> 
<p>现已知他们会先后进出一个房间发送电报</p> 
<p>警方可以知道所有时间下:</p> 
<p>进出房间的人的真实名字</p> 
<p>同时通过截获该房间发出的电报,获得网名</p> 
<p>问最后能否将所有真实名字和虚拟网名对上</p> 
<p><br> </p> 
<p><br> </p> 
<p><br> </p> 
<p>解题思路:</p> 
<p>首先根据题目条件名字和网名是一一对应的,可以大概确定是二分匹配中的完美匹配<br> </p> 
<p>然而根据样例很容易看出来,要想根据正确关系来建边是很复杂的</p> 
<p>容易的做法是:每次将不可能匹配的名字和网名建边,最后根据补图进行最大匹配即可初步得出所有匹配关系.</p> 
<p>但现在得到的最大匹配不一定是完美匹配</p> 
<p>要确定某个名字和网名是匹配的 我们可以删除当前已匹配的边,再进行最大匹配</p> 
<p>如果结果减小了,则一定是对应的</p> 
<p>这样,依次枚举每一条最大匹配中的边.即可得出答案</p> 
<p><br> </p> 
<p><br> </p> 
<p><br> </p> 
<p>代码:</p> 
<p></p> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;map&gt;
#define maxn 25
using namespace std;
struct node
{
    string a,b;
} s[maxn];
map&lt;string,int&gt;m1,m2;
string s1[maxn];
int edge[maxn][maxn];
int link[maxn],vis[maxn];
int mark[maxn];
int id,n;

void init()
{
    memset(edge,0,sizeof(edge));
    memset(mark,0,sizeof(mark));
    id=1;
    m1.clear(),m2.clear();
}

int cmp(node x,node y)
{
    return x.a&lt;y.a;
}

int dfs(int u)
{
    for(int i=1;i&lt;=n;i++)
    {
        if(!vis[i]&amp;&amp;edge[u][i]==0)
        {
            vis[i]=1;
            if(link[i]==-1||dfs(link[i]))
            {
                link[i]=u;
                return 1;
            }
        }
    }
    return 0;
}

int Hungry()
{
    memset(link,-1,sizeof(link));
    int ans=0;
    for(int i=1;i&lt;=n;i++)
        {
            memset(vis,0,sizeof(vis));
            if(dfs(i))
                ans++;
        }
    return ans;
}
int main()
{
    int m,a,b,d;
    char ch;
    string str;
    while(~scanf("%d",&amp;n))
    {
        init();
        for(int i=1; i&lt;=n; i++)
        {
            cin&gt;&gt;s1[i];
            m1[s1[i]]=i;
        }
        while(cin&gt;&gt;ch)
        {
            if(ch=='Q')
                break;
            else
            {
                cin&gt;&gt;str;
                if(ch=='E')
                {
                    if(!m2[str])
                        d=m2[str]=id++;
                    else
                        d=m2[str];
                    mark[d]=1;
                    s[d].a=str;
                    s[d].b="???";
                }
                else if(ch=='L')
                {
                    d=m2[str];
                    mark[d]=0;
                }
                else if(ch=='M')
                {
                    d=m1[str];
                    for(int i=1;i&lt;=n;i++)
                        if(!mark[i])                 //建立反向边
                            edge[d][i]=1;
                }
            }
        }
        int ans=Hungry();
        int linkt[maxn];
        for(int i=1;i&lt;=n;i++)           //原最大匹配中的边
            linkt[i]=link[i];
        for(int i=1;i&lt;=n;i++)
        {
            d=linkt[i];
            edge[d][i]=1;
            if(Hungry()!=ans)           //最大匹配减少 
                s[i].b=s1[d];
            edge[d][i]=0;
        }
//        for(int i=1;i&lt;=n;i++)
//            cout&lt;&lt;s[i].a&lt;&lt;" "&lt;&lt;s1[link[i]]&lt;&lt;endl;
        sort(s+1,s+1+n,cmp);
        for(int i=1;i&lt;=n;i++)
            cout&lt;&lt;s[i].a&lt;&lt;":"&lt;&lt;s[i].b&lt;&lt;endl;
    }
    return 0;
}
</code></pre> 
<br> 
<br> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f58cb7d39b065aec5f586c07ed22b3f1/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">java与C语言的数据类型对应</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/117350938a29c86bac17084bdc3f96ee/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">多线程与并发 概论</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>