<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>移除元素【数组】 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="移除元素【数组】" />
<meta property="og:description" content="⭐前言⭐ ※※※大家好！我是同学〖森〗，一名计算机爱好者，今天让我们进入练习模式。若有错误，请多多指教。更多有趣的代码请移步Gitee
👍 点赞 ⭐ 收藏 📝留言 都是我创作的最大的动力！
题目 27. 移除元素
题目：
给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。
不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。
元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。
示例1
输入：nums = [3,2,2,3], val = 3 输出：2, nums = [2,2] 解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。 示例2
输入：nums = [0,1,2,2,3,0,4,2], val = 2 输出：5, nums = [0,1,4,0,3] 解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。 提示
0 &lt;= nums.length &lt;= 1000 &lt;= nums[i] &lt;= 500 &lt;= val &lt;= 100 思路 题目分析:" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/bb102feeacefbc9ed7a09d70315ab774/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-04-25T18:55:39+08:00" />
<meta property="article:modified_time" content="2023-04-25T18:55:39+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">移除元素【数组】</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="_0"></a>⭐前言⭐</h2> 
<blockquote> 
 <p>※※※大家好！我是同学〖森〗，一名计算机爱好者，今天让我们进入练习模式。若有错误，请多多指教。更多有趣的代码请移步<a href="https://gitee.com/never-give-in" rel="nofollow">Gitee</a><br> 👍 点赞 ⭐ 收藏 📝留言 都是我创作的最大的动力！</p> 
</blockquote> 
<h2><a id="_6"></a>题目</h2> 
<blockquote> 
 <p><a href="https://leetcode.cn/problems/remove-element/" rel="nofollow">27. 移除元素</a><br> <br> <strong>题目：</strong></p> 
 <ul><li> <p>给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。</p> </li><li> <p>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。</p> </li><li> <p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p> </li></ul> 
 <hr> 
</blockquote> 
<p><strong><code>示例1</code></strong></p> 
<pre><code class="prism language-java">输入：nums <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> val <span class="token operator">=</span> <span class="token number">3</span>
输出：<span class="token number">2</span><span class="token punctuation">,</span> nums <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span>
解释：函数应该返回新的长度 <span class="token number">2</span><span class="token punctuation">,</span> 并且 nums 中的前两个元素均为 <span class="token number">2</span>。你不需要考虑数组中超出新长度后面的元素。
</code></pre> 
<p><strong><code>示例2</code></strong></p> 
<pre><code class="prism language-java">输入：nums <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> val <span class="token operator">=</span> <span class="token number">2</span>
输出：<span class="token number">5</span><span class="token punctuation">,</span> nums <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>
解释：函数应该返回新的长度 <span class="token number">5</span><span class="token punctuation">,</span> 并且 nums 中的前五个元素为 <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">4</span>。注意这五个元素可为任意顺序。
</code></pre> 
<blockquote> 
 <p><strong>提示</strong></p> 
 <ul><li>0 &lt;= nums.length &lt;= 100</li><li>0 &lt;= nums[i] &lt;= 50</li><li>0 &lt;= val &lt;= 100</li></ul> 
</blockquote> 
<hr> 
<h2><a id="_35"></a>思路</h2> 
<blockquote> 
 <p>题目分析:</p> 
 <blockquote> 
  <ul><li>去除掉数组 nums 中 值为 val 的元素，返回新数组的长度；</li><li>不能使用额外数组空间，因为要删除元素，新数组的长度 一定小于等于 原来数组元素，我们可以在原数组上进行操作</li><li>元素的顺序可变，这个是我们进行<strong>优化</strong>的关键</li><li>由提示可知，根据相关数据的范围，本题可以直接使用int类型</li></ul> 
 </blockquote> 
 <p>由于数组的元素在内存地址中是连续的，不能单独删除数组中的某个元素，只能覆盖；<br> <br> 解法一：使用暴力破解，用两层循环，第一层循环用于 寻找数组中等于 val 的元素，第二层循环负责如果第一层循环找到等于 val 的元素，就将该元素后面的元素向前一步，覆盖掉该元素；<br> <br> 解法二： 使用快慢指针，定义 fast = slow = 0； fast 指针用来查询当前数组的元素的值 是否为 val 如果 等于 val 就 跳过该元素，如果不等就将该元素赋值给 slow ，有此可知 slow 前面的元素都是值 不为 val 的元素，返回slow 就是新数组的长度；<br> <br> 解法三： 使用相向双指针，题解二中如果数组中没有val 元素那么fast 和slow 都会遍历一遍数组，会遍历两遍数组，但由于题目说明的是元素的顺序可变，我们可以用双指针分别从前向后（left），和从后向前遍历（right） 当 right 和 left 相遇的时候说明遍历了数组，我们要做的就是将left 遍历到 值等于 val 的元素和right 遍历的不等于 val 的值进行互换，这样就不用一个一个地移动元素，但是缺点却是改变了元素的原有顺序位置；</p> 
</blockquote> 
<h2><a id="_49"></a>解法一：暴力破解</h2> 
<blockquote> 
 <p>使用双层 for 循环</p> 
 <ul><li>第一层 for 循环 遍历数组元素</li></ul> 
 <blockquote> 
  <p>i = 0; i &lt; len; i ++</p> 
 </blockquote> 
 <ul><li>第二层for循环 更新数组元素 
   <blockquote> 
    <p><code>如果 nums[i] == val </code><br> <code>for(int j = i + 1; j &lt; len ; j++) nums[j - 1] = nums[j]; </code><br> 将i后面值向前一位进行覆盖；</p> 
   </blockquote> </li></ul> 
</blockquote> 
<p>程序源码</p> 
<pre><code class="prism language-java"><span class="token comment">// 时间复杂度: O(n^2)</span>
<span class="token comment">// 空间复杂度: O(1)</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">removeElement</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 双重循环</span>
        <span class="token keyword">int</span> len <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">// 第一层循环, 查找值为 val 的元素</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> val<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>   <span class="token comment">// 找到值为 val 的元素, 将i后面的元素集体向前移动一位</span>
                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                    nums<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 注意 j的起始值 和 结束条件</span>
                <span class="token punctuation">}</span>
                i<span class="token operator">--</span><span class="token punctuation">;</span>  <span class="token comment">// 因为 i 以后的元素都集体向前移动一位, 此时位于下标 i 的元素, 其实是下标为i + 1的元素,需要重新遍历;</span>
                len<span class="token operator">--</span><span class="token punctuation">;</span>  <span class="token comment">// 覆盖一个元素, 数组的长度 - 1;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> len<span class="token punctuation">;</span> <span class="token comment">// 返回数组的长度;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre> 
<p>例：nums = [0,1,2,2,3,0,4,2], val = 2 移除 nums 中的 2</p> 
<p><strong>使用暴力破解删除过程为：</strong></p> 
<blockquote> 
 <p>初始化：i = 0</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/14/fe/Gs4Yv8Yl_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<blockquote> 
 <p>当 i = 0， 1时 nums[ i ] != 2 不执行if 语句 i = 2 时，进入if语句 j = i + 1；</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/aa/a4/HGRcpg6O_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<blockquote> 
 <p>执行 第二层循环 更新数组元素 ： 将 i 后面的所有元素集体想前移动一位<br> 此时灰色的框的元素 2 仍然存在数组中，我们需要将数组的长度由 8 改为 7 将最后一个元素 删除掉<br> 注意 for循环的结束条件 是 <code>i &lt; len</code> 而不是 <code>i &lt; nums.length</code></p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/37/a2/kcFzHbxv_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p><code> i --; len--;</code><br> 这里需要重新遍历 下标为 2 的元素 需要 i-- 向前一步，同时 新数组的长度变成了7 循环到 下标为 6的时候就结束了，<br> 注意要在循环的过程中更新结束的len值</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/87/10/fbLTzPU4_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>i++ i = 2； 重复上述过程</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/eb/15/MswSTzhC_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<p><img src="https://images2.imgbox.com/76/34/EAR0v2uy_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<p><img src="https://images2.imgbox.com/72/8a/fCkMDOJQ_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<p><img src="https://images2.imgbox.com/d8/1a/89qX4zTd_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>接下来过程和 i = 0 ，i 时一样 i 一直++到 i == 5</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/4e/d9/B2NkMRUv_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>此时 j = 6 = len 不进入第二层for循环 执行 <code>i--</code>和 <code>len--</code> 操作</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/23/f3/U7qhJKCp_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>此时 i ++ 后 i = 5 i = len 不满足进入第一层for循环条件，跳出循环 <strong>新数组长度为 5</strong> 元素分别是：0 1 3 0 4 <strong>符合预期</strong>；</p> 
</blockquote> 
<p>使用暴力破解 的时间复杂度 为：O(n^2) 时间复杂度较高，我们能不能进一步优化下；</p> 
<h2><a id="_131"></a>解法二：快慢指针(双指针）</h2> 
<blockquote> 
 <p>快慢指针： 通过一个快指针和一个慢指针在一个for循环下完成两个for循环的工作<br> 定义快慢指针:</p> 
 <blockquote> 
  <ul><li>快指针: 寻找新数组的元素，即元素的值不等于 val 的元素，</li><li>慢指针: 指向更新 新数组下标的位置，即新数组的最后一个元素的下一个的位置，和新数组的长度相等</li></ul> 
 </blockquote> 
 <p>思路： 快指针查询不等于val的元素，将这些数组赋值给慢指针所在的位置，如果查询到等于 val 的元素，快指针就跳过该元素；</p> 
</blockquote> 
<p>完整代码：</p> 
<pre><code class="prism language-java"><span class="token comment">// 时间复杂度: O(n)</span>
<span class="token comment">// 空间复杂度: O(1)</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> demo2 <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">removeElement</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 这种实现方法没有改变元素的相对位置</span>
        <span class="token keyword">int</span> slow <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> fast <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> fast <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> fast<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>fast<span class="token punctuation">]</span> <span class="token operator">!=</span> val<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                nums<span class="token punctuation">[</span>slow<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>fast<span class="token punctuation">]</span><span class="token punctuation">;</span>
                slow<span class="token operator">++</span><span class="token punctuation">;</span>
                <span class="token comment">// 这里可以化简为 nums[slow++] = nums[fast]; ++在slow的后面, 表示先用后加</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> slow<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>例：nums = [0,1,2,2,3,0,4,2], val = 2 移除 nums 中的 2</p> 
<p>图解：<br> 初始化：<br> <img src="https://images2.imgbox.com/dc/69/7KiQOPEE_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>nums[fast] != val 0 != 2 nums[slow] = nums[fast];</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/91/95/viMkpX5X_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>fast = 1; nums[1] != val</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/01/e7/rOJVoMfN_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>fast = 2 nums[2] == val</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/5c/58/BGOvlKZp_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>fast == 3 nums[3] == val</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/fc/4b/9KrZMLDb_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>fast == 4 nums[4] != 2</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/8a/cf/TQrKFwz3_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>fast = 5 nums[5] != val</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/69/47/2C938dh1_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>fast = 6 nums[6] != val</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/5f/ae/34zAQDmv_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>fast = 8 nums[7] == val</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/00/2d/iddECG14_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>fast = 8 == nums.length 跳出循环<br> 此时slow 所值的下标位置，正好等于新数组（橙色部分）的长度；<br> 将slow返回；</p> 
</blockquote> 
<p>这次解法比上一次解法时间复杂度直接从O(n^2) 降低到 O（n）但这种算法在最坏情况下（数组没有元素等于val）需要左右指针各遍历一次数组，遍历了两次数组，而且还进行了无效复制 nums[slow] = nums[fast]（fast == slow时）</p> 
<h2><a id="_199"></a>解法三：双指针优化</h2> 
<blockquote> 
 <p>相向双指针：通过左右两个指针，向中间遍历实现只遍历一次完成删除的工作</p> 
 <ul><li>前提: 元素的顺序可以改变</li><li>思路：如果要移除的元素在数组开头，我们可以直接从后面不排除的元素移动到开头这个元素的位置<br> 例：【3 4 6 2 7 8】 val 3 我们直接可以用 8 来替代 3 得到 【8 4 6 2 7】同样满足题目<br> 这个优化在序列中val 元素的数量较少时效果较明显；</li></ul> 
</blockquote> 
<blockquote> 
 <p>实现 ：</p> 
 <ul><li>使用left = 0； right = nums.length; 向中间遍历，</li><li>如果 left 指向的元素等于 val 就将 right 指向的元素 复制到left的位置，然后right–；</li><li>如果 left 指向的元素 不等于 val， 就left ++</li><li>会有一种情况是right 指向的元素也等于 val ，不过没有关系，因为上一步中 没有left++；还会检查新复制来的元素是不是为val；</li><li>当left 和 right重合的时候就遍历完数组中所有元素，结束循环</li></ul> 
</blockquote> 
<p>完整代码</p> 
<pre><code class="prism language-java"><span class="token comment">// 时间复杂度: O(n)</span>
<span class="token comment">// 空间复杂度: O(1)</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">removeElement</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment">// 指向数组第一个元素</span>
        <span class="token keyword">int</span> right <span class="token operator">=</span> nums<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">// 指向数组最后一个元素</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>left <span class="token operator">&lt;=</span> right<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">==</span> val<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token comment">// 如果 left 所指向的元素等于 val 就将 right 指向的元素复制到 left 的位置</span>
                nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>right<span class="token operator">--</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
                <span class="token comment">// 不等于 val, 就left++;</span>
                left<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> left<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>例：nums = [0,1,2,2,3,0,4,2], val = 2 移除 nums 中的 2</p> 
<blockquote> 
 <p>初始化 <code>left = 0； right = 7</code></p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/10/ed/Mm2hoFD0_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>left = 0 nums[0] != val</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/f4/0d/QuRmclmz_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>left = 1 nums[0] != val</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/15/a1/IwvAiDwn_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>left = 2 nums[0] == val<br> nums[left] = nums[right–]</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/f0/f5/F917Lakv_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>left = 2 nums[0] == val<br> nums[left] = nums[right–]</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/81/74/NMAh0tjX_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>left = 2 nums[2] == 4 != 2<br> left++</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/5c/1b/z2wHuGW9_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>left = 3<br> nums[3] = 2 == val<br> nums[left] = nums[right–]</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/c6/53/Xflwehd5_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>left = 3 nums[3] != val<br> left++;</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/4d/c0/XtC4Ziye_o.png" alt="在这里插入图片描述"><br> left = 4 nums[4] != val<br> left++;<br> <img src="https://images2.imgbox.com/a8/bd/flulXD9E_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>left &gt; right<br> 跳出循环， 返回 left ，5</p> 
</blockquote> 
<blockquote> 
 <p><strong>这种算法两个指针在最坏的情况下合起来只遍历了数组一次，避免了需要保存的元素的重复复制操作</strong></p> 
</blockquote> 
<p>但是这种算法重复第判断了好几次在同一个下标位置，对于right指向的元素 等于val 的情况还复制了过去，还存在着一定的问题，所以我们还可以进行优化</p> 
<blockquote> 
 <p>寻找left 指向的元素 等于 val 和 right 指向的元素 不等于 val，这种情况下才进行复制</p> 
</blockquote> 
<p>完整代码</p> 
<pre><code class="prism language-java"><span class="token comment">// 时间复杂度: O(n)</span>
<span class="token comment">// 空间复杂度: O(1)</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">removeElement</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment">// 指向数组第一个元素</span>
        <span class="token keyword">int</span> right <span class="token operator">=</span> nums<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">// 指向数组最后一个元素</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;=</span> right<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;=</span> right <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">!=</span> val<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span> <span class="token comment">// 寻找左边等于 val 的元素</span>
                left<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;=</span> right <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">==</span> val<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span> <span class="token comment">// 寻找右边不等于 val 的元素</span>
                right<span class="token operator">--</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">// 将右边不等于val的元素覆盖掉左边等于val的元素</span>

                nums<span class="token punctuation">[</span>left<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>right<span class="token operator">--</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> left<span class="token punctuation">;</span>  <span class="token comment">// left 制定指向最终数组末尾的下一个元素;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre> 
<p>例：nums = [0,1,2,2,3,0,4,2], val = 2 移除 nums 中的 2</p> 
<blockquote> 
 <p>图解 ： 初始化<br> left = 0; right = 7</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/ee/2d/psakqBdp_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>寻找左边等于 val 的元素 left = 2</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/6e/35/Yk59SVLM_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>寻找右边不等于 val 的元素 right = 6</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/bb/7b/S8BIkKGs_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>left &lt; right<br> nums[left++] = nums[right–]; 将右边不等于val的元素覆盖掉左边等于val的元素</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/25/be/LNagymiQ_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>left &lt;= right 进入循环<br> 寻找左边等于 val 的元素 left = 3<br> 寻找右边不等于 val 的元素 right = 5<br> left &lt; right<br> nums[left++] = nums[right–]; 将右边不等于val的元素覆盖掉左边等于val的元素</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/86/e0/LN0nKQJV_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>left == right 进入循环<br> 寻找左边等于 val 的元素 left = 5<br> left &gt; right跳出循环<br> left &gt; right 不会进入循环 并且也不会 进行交换</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/57/3f/gP8WT3Ga_o.png" alt="在这里插入图片描述"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2652be08d1dcc731afd9c550ba1200b0/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Android双屏异显</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/19767853087d46217e0fa3a412272da2/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">BatchNormalization和LayerNormalization的理解、适用范围、PyTorch代码示例</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>