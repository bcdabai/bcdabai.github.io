<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>opencv中sobel算子生成原理 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="opencv中sobel算子生成原理" />
<meta property="og:description" content=" https://blog.csdn.net/tonyshengtan/article/details/43698711
数学形式的标准Sobel为：
此模板为最早提出的Sobel模板，由于模板的对称性，我们可以将它分解一下，并根据卷积的运算性质，可以得到： 也就是说，图像对Sobel 的响应等于，对模板分解后的小模板分别卷积，而观察小模板我们可以发现，其中[1,0,-1]或其转置为差分，也就是用于寻找边缘候选点的，而另一个[1,2,1]是一个标准平滑算子，这也就是很多书上说，Sobel具有平滑和微分的功效，原因就是这里了，也就是说，算子先将图像横向或纵向平滑，然后再纵向或横向差分，得到的结果是平滑后的差分结果。 或者，也可根据以下方式得到分解到的两个模板，其中星号表示卷积： 另一种得到模板的方法是通过帕斯卡三角，得到，并且帕斯卡三角的奇数行是最有高斯模板的整数系数的逼近，也就是说，高斯模板可以通过帕斯卡三角查询到其整数系数的近似，来观察帕斯卡三角：
其中标注的就可以用来生成扩展的Sobel算子，其中较常用的有5x5和7x7的模板。
用两个小模板分别卷积的另一个好处是减少计算量，对于使用大小为nxn的模板，卷积计算量为O（n*n*width*height）而分开成小模板卷积计算量是O（2*n*width*height）也就是O（n*width*height）减少了一项，当n相对较大的时候，计算量明显减少。 帕斯卡三角的计算是通过组合公式给出，具体不在这里描述，所以Sobel算子的模板计算方法我们就有了大概的了解。 opencv文档中给出了关于sobel算子的下面信息： 和上面描述的方法类似，更直观，可以用来理解sobel的模板结构，不同的差分方向带来的问题就是边缘方向的确定，由于算子属于一阶微分，也就是梯度算子之一，所以梯度方向信息也显得很重要，比如后面要说的canny就是用到了梯度方向的信息，所以，在确定方向时要注意算子的差分方向。 对于阶梯型边缘，计算过程及结果如下，红色为模板中心： 可以看到，相比于Robert算子，Sobel得到的边界候选位置相对较宽，而且包括全部的内边界和外边界。并且差分被放大了，也就是说，用Sobel算子处理后的图片有可能超过原图像灰度级别，对于这个问题，处理方法是将平滑分算子（分解后的平滑部分，例如【1，2，1】）归一化，得到的差值仍在原始灰度级范围内。 " />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/aee9724b855996a772acdea3ffc3febd/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-03-30T21:53:10+08:00" />
<meta property="article:modified_time" content="2018-03-30T21:53:10+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">opencv中sobel算子生成原理</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><a href="https://blog.csdn.net/tonyshengtan/article/details/43698711">https://blog.csdn.net/tonyshengtan/article/details/43698711</a></p> 
<p>数学形式的标准Sobel为：</p> 
<pre><code>      此模板为最早提出的Sobel模板，由于模板的对称性，我们可以将它分解一下，并根据卷积的运算性质，可以得到：

   也就是说，图像对Sobel 的响应等于，对模板分解后的小模板分别卷积，而观察小模板我们可以发现，其中[1,0,-1]或其转置为差分，也就是用于寻找边缘候选点的，而另一个[1,2,1]是一个标准平滑算子，这也就是很多书上说，Sobel具有平滑和微分的功效，原因就是这里了，也就是说，算子先将图像横向或纵向平滑，然后再纵向或横向差分，得到的结果是平滑后的差分结果。
   或者，也可根据以下方式得到分解到的两个模板，其中星号表示卷积：
</code></pre> 
<p>另一种得到模板的方法是通过帕斯卡三角，得到，并且帕斯卡三角的奇数行是最有高斯模板的整数系数的逼近，也就是说，高斯模板可以通过帕斯卡三角查询到其整数系数的近似，来观察帕斯卡三角：</p> 
<p>其中标注的就可以用来生成扩展的Sobel算子，其中较常用的有5x5和7x7的模板。</p> 
<pre><code>   用两个小模板分别卷积的另一个好处是减少计算量，对于使用大小为nxn的模板，卷积计算量为O（n*n*width*height）而分开成小模板卷积计算量是O（2*n*width*height）也就是O（n*width*height）减少了一项，当n相对较大的时候，计算量明显减少。

     帕斯卡三角的计算是通过组合公式给出，具体不在这里描述，所以Sobel算子的模板计算方法我们就有了大概的了解。

 opencv文档中给出了关于sobel算子的下面信息：


   和上面描述的方法类似，更直观，可以用来理解sobel的模板结构，不同的差分方向带来的问题就是边缘方向的确定，由于算子属于一阶微分，也就是梯度算子之一，所以梯度方向信息也显得很重要，比如后面要说的canny就是用到了梯度方向的信息，所以，在确定方向时要注意算子的差分方向。

   对于阶梯型边缘，计算过程及结果如下，红色为模板中心：


   可以看到，相比于Robert算子，Sobel得到的边界候选位置相对较宽，而且包括全部的内边界和外边界。并且差分被放大了，也就是说，用Sobel算子处理后的图片有可能超过原图像灰度级别，对于这个问题，处理方法是将平滑分算子（分解后的平滑部分，例如【1，2，1】）归一化，得到的差值仍在原始灰度级范围内。
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d7b289f852c742fef41b8f19b17e0f4a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">#并查集#信息学奥赛一本通 1389 亲戚</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ee7a895ff6e3cba6bd4263190db76ede/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">网易云直链</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>