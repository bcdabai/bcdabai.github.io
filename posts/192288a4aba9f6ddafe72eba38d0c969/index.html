<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Container With Most Water - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Container With Most Water" />
<meta property="og:description" content="Given n non-negative integers a1, a2, ..., an, where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.
Note: You may not slant the container.
这道题给出了一个序列，要求找出两根线使其和x轴之间的存储的水最多。注意这里最终盛多少水，不需要考虑中间的最低值，只需要考虑两边的边界。
leetcode给出的提示是用two pointer来做，two pointer做了几题，基本是O(n)复杂度，使用贪心策略。
具体采用何种贪心策略，我也做了好几次选择，最终的选择如下：
1.给出l = 0, r = n-1." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/192288a4aba9f6ddafe72eba38d0c969/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-07-03T04:34:26+08:00" />
<meta property="article:modified_time" content="2019-07-03T04:34:26+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Container With Most Water</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="cnblogs_post_body" class="blogpost-body"> 
 <p>Given <em>n</em> non-negative integers <em>a1</em>, <em>a2</em>, ..., <em>an</em>, where each represents a point at coordinate (<em>i</em>, <em>ai</em>). <em>n</em> vertical lines are drawn such that the two endpoints of line <em>i</em> is at (<em>i</em>, <em>ai</em>) and (<em>i</em>, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.</p> 
 <p>Note: You may not slant the container.</p> 
 <p>这道题给出了一个序列，要求找出两根线使其和x轴之间的存储的水最多。注意这里最终盛多少水，不需要考虑中间的最低值，只需要考虑两边的边界。</p> 
 <p>leetcode给出的提示是用two  pointer来做，two pointer做了几题，基本是O(n)复杂度，使用贪心策略。</p> 
 <p>具体采用何种贪心策略，我也做了好几次选择，最终的选择如下：</p> 
 <p>1.给出l = 0, r = n-1.</p> 
 <p>2.当al &lt; ar, l++,向右移动一步，否则 r--,向左移动一步。</p> 
 <p>首先说明为何采用此种策略。思考如下,转自<a href="http://bangbingsyb.blogspot.sg/2014/11/leetcode-container-with-most-water.html#comment-form" rel="nofollow">Yangbing Shi</a>的博客:</p> 
 <p>由于ai和aj (i&lt;j) 组成的container的面积：S(i,j) = min(ai, aj) * (j-i)</p> 
 <p><br>所以对于任何S(i'&gt;=i, j'&lt;=j) &gt;= S(i,j)，由于j'-i' &lt;= j-i，必然要有min(ai',aj')&gt;=min(ai,aj)才行。同样可以采用头尾双指针向中间移动：<br><br>当a(left) &lt; a(right)时，对任何j&lt;right来说<br><br>(1) min(a(left),aj) &lt;= a(left) = min(a(left), a(right))</p> 
 <div>
   (2) j-left &lt; right-left 
 </div> 
 <div>
     
 </div> 
 <div>
   所以S(left, right) &gt; S(left, j&lt;right)。排除了所有以left为左边界的组合，因此需要右移left。同理，当a(left) &gt; a(right)时，需要左移right。而当a(left) = a(right)时，需要同时移动left和right。 
 </div> 
 <div>
     
 </div> 
 <div>
   但是以上策略在排除一侧选择时，并不能保证选择另一侧可以得到比当前最大面积更大的面积，所以我们需要保存maxArea,并不断迭代，而不是用最终的l,r结果直接算出最大面积，这也是贪心和DP的区别之一。DP的状态通常可以直接得到全局最优解。 
 </div> 
 <div>
     
 </div> 
 <div>
   所以上述解法需要通过证明来证明可以使 maxArea保存全局最优，即l,r在某一时刻同时指向使maxArea最大的l 
  <sup>*</sup>和r 
  <sup>*</sup>。 
 </div> 
 <div>
     
 </div> 
 <div>
   采用反证法来证明，即假设最终的结果并非全局最优。即存在l,r在某一时刻同时指向使maxArea更大的l 
  <sup>*</sup>和r 
  <sup>*</sup>为全局最优。再来考虑我们的算法，因为最终l和r的中止情况为l==r,所以l和r遍历了所有的下标index。左指针和右指针至少有一个曾经过全局最优的取值，即l到达l 
  <sup>*</sup>或者r到达r 
  <sup>*时</sup>，另一个不曾到达过，不然maxArea最终会记录了这个最大面积。不失一般性，假设l曾停在l 
  <sup>*</sup>。因为l停在l 
  <sup>*</sup>时，r不曾停在过r 
  <sup>*</sup>上，所以当l停在l 
  <sup>*</sup>后，后续只有l不停向右，经过了r*。 
 </div> 
 <div>
   1）此时l停在l 
  <sup>*</sup>上一段时间。r&gt;r 
  <sup>*</sup>,我们移动r,但是始终无法到达r*，移动r说明ar&lt;al,但是a[j]&gt;=a[r*](j&gt;r*),所以min(a[l*],a[j])&gt;=min(a[l*],a[r*]),显然由a[l*],a[j]组成的面积更大，与l 
  <sup>*</sup>和r 
  <sup>*</sup>为全局最优相违背。 
 </div> 
 <div>
   2）r&gt;r 
  <sup>*，</sup>l到达l 
  <sup>*后，继续向右，说明，</sup> 
 </div> 
 <div>
     
 </div> 
 <div>
   附上leetcode上的证明，我觉得Since our algorithm stops only if the two pointers meet. So, we must have visited one of them but not the other这块有问题，不是。 
 </div> 
 <div> 
  <p>Here is the proof. Proved by contradiction:</p> 
  <p>Suppose the returned result is not the optimal solution. Then there must exist an optimal solution, say a container with a<em>ol and a</em>or (left and right respectively), such that it has a greater volume than the one we got. Since our algorithm stops only if the two pointers meet. So, we must have visited one of them but not the other. WLOG, let's say we visited a<em>ol but not a</em>or. When a pointer stops at a_ol, it won't move until</p> 
  <ul><li> <p>The other pointer also points to a<em>ol. In this case, iteration ends. But the other pointer must have visited a</em>or on its way from right end to a<em>ol. Contradiction to our assumption that we didn't visit a</em>or.</p> </li><li> <p>The other pointer arrives at a value, say a<em>rr, that is greater than a</em>ol before it reaches a<em>or. In this case, we does move a</em>ol. But notice that the volume of a<em>ol and a</em>rr is already greater than a<em>ol and a</em>or (as it is wider and heigher), which means that a<em>ol and a</em>or is not the optimal solution -- Contradiction!</p> </li></ul> 
 </div> 
</div> 
<p>转载于:https://www.cnblogs.com/sherylwang/p/5539193.html</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/25764b56cb49024cb30afaac84586dc8/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Longest Substring Without Repeating Characters</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b817e7657c85c40dddeb42720584de53/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Word Ladder</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>