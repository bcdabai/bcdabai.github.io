<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>AODV协议概述 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="AODV协议概述" />
<meta property="og:description" content="AODV是由Nokia研究中心的Charles E.Perkins和加利福尼亚大学Santa Barbara的Elizabeth M.Belding-Roryer以及Cincinnati大学Samir R.Das等共同开发，已经被 IETF MANET工作组于2003年7月正式公布为自组网路由协议的RFc标准。
AODV实质上就是DSR和DSDV的综合，它借用了DSR中路由发现和路由维护的基础程序，及DSDV的逐跳(Hop-by-HoP)路由、目的节点序列号和路由维护阶段的周期更新机制，以DSDV为基础，结合DSR中的按需路由思想并加以改进。
AODV在每个中间节点隐式保存了路由请求和应答的结果，并利用扩展环搜索的办法来限制搜索发现过的目的节点的范围。AODV支持组播功能，支持Qos，而且AODV中可以使用IP地址，实现同Internet连接，但是不支持单向信道。和DSDV保存完整的路由表不同的是，AODV通过建立基于按需路由来减少路由广播的次数，这是AODV对DSDV的重要改进。和DSR相比，AODV的好处在于源路由并不需要包括在每一个数据分组中，这样会使路由协议的开销有所降低。AODV是一个纯粹的按需路由系统，那些不在路径内的节点不保存路由信息，也不参与路由表的交换。AODv协议可以实现在移动终端间动态的、自发的路由，使移动终端很快获得通向所需目的的路由，同时又不用维护当前没有使用的路由信息，并且还能很快对断链的拓扑变化做出反应。AODV的操作是无环路的，在避免了通常Bellman-ford算法的无穷计数问题的同时，还提供了很快的收敛速度。AODv的路由表中每个项都使用了目的序列号(Destination Sequence Number)。目的序列号是目的节点创建，并在发给发起节点的路由信息中使用的。使用目的序列号可以避免环路的发生。
AODV 使用 3 种消息作为控制信息 :RouteRequest(RREQ) ， RouteReply(RREP) 和 RouteError(RERR) 。这些消息都在 UDP 上使用 654 端口号。 当源节点需要和目的节点通信时，如果在路由表中已经存在了对应的路由时， AODV 不会进行任何操作。当源节点需要和新的目的通信时，它就会发起路由发现过程，通过广播 RREQ 信息来查找相应路由。当这个 RREQ 到达目的节点本身，或者是一个拥有足够新的到目的节点路由的中间节点时，路由就可以确定了。所谓 “ 足够新 ” 就是通过目的序列号来判断的。目的节点或中间节点通过原路返回一个 RREP 信息来向源节点确定路由的可用性。在维护路由表的过程中，当路由不再被使用时，节点就会从路由表中删除相应的项。同时，节点会监视一个活动路由 (activeroute ，有限跳的，可用于数据转发的路由表 ) 中，下一跳节点的状况。当发现有链路断开的情况时，节点就会使用 RERR 通知上游的节点，而上游的节点就会使用该 RERR 分组拷贝通知更上游的节点。在 RERR 消息中，指明了由于断链而导致无法达到目的节点。每个节点都保留了一个 “ 前驱列表 ”(precursor list) 来帮助完成错误报告的功能，这个列表中保存了把自己作为到当前不可达节点的下一跳的相邻节点 ( 可以通过记录 RERR 很容易地获得 ) 。在路由表中，针对每一个表项，需要记录相应的的特征内容。其中，序列号是防止路由环路的关键所在。当发生断链时，通过增加序列号 和度量值 ( 跳数 ) 来使路由表项无效。 ②AODV路由协议的运行方式 (a)AODV 路由发现 AODV 路由协议是一种典型的按需驱动路由协议，该算法可被称为纯粹的需求路由获取系统，那些不在活跃路径上的节点不会维持任何相关路由信息，也不会参与任何周期路由表的交换。此外，节点没有必要去发现和维持到另一节点的路由，除非这两个节点需要进行通信。移动节点间的局部连接性可以通过几种方法得到，其中包括使用局部广播 Hello 消息。这种算法的主要目的是 : 在需要时广播路由发现分组一般的拓扑维护 ; 区别局部连接管理 ( 邻居检测 ) 和一般的拓扑维护 ; 向需要连接信息的邻居移动节点散播拓扑变化信息。 AODV 使用广播路由发现机制，它依赖中间节点动态建立路由表来进行分组的传送。为了维持节点间的最新路由信息， AODV 借鉴了 DSDV 中的序列号的思想，利用这种机制就能有效地防止路由环的形成。当源节点想与另外一个节点通信，而它的路由表中又没有相应的路由信息时，它就会发起路由发现过程。每一个节点维持两个独立的计数器 : 节点序列号计数器和广播标识。源节点通过向自己的邻居广播 RREQ(Route Requests) 分组来发起一次路由发现过程。 (b) 反向路由的建立 在 RREQ 分组中包含了两个序列号 : 源节点序列号和源节点所知道的最新的目的序列号。源节点序列号用于维持到源的反向路由的特性，目的序列号表明了到目的地的最新路由。当 RREQ 分组从一个源节点转发到不同的目的地时，沿途所经过的节点都要自动建立到源节点的反向路由。节点通过记录收到的第一个 RREQ 分组的邻居地址来建立反向路由，这些反向路由将会维持一定时间，一该段时间足够 RREQ 分组在网内转发以及产生的 RREP 分组返回源节点。当 RREQ 分组到达了目的节点，目的节点就会产生 RREP 分组，并利用建立的反向路由来转发 RREP 。 (c) 正向路由的建立 RREQ 分组最终将到达一个节点，该节点可能就是目的节点，或者这个节点有到达目的节点的路由。如果这个中间节点有到达目的的路由项，它就会比较路由项里的目的序列号和 RREQ 分组里的目的序列号的大小来判断自己已有的路由是否是比较新的。如果 RREQ 分组里的目的序列号比路由项中的序列号大，则这个中间节点不能使用己有的路由来响应这个 RREQ 分组，只能是继续广播这个 RREQ 分组。中间节点只有在路由项中的目的序列号不小于 RREQ 中的目的序列号时，才能直接对收到的 RREQ 分组做出响应。如果节点有到目的地的最新路由，而且这个 RREQ 还没有被处理过，这个节点将会沿着建立的反向路由返回 RREP 分组。 在 RREP 转发回源节点的过程中，沿着这条路径上的每一个 ." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/353abfb49d2e19af2aa80ea42d268adf/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-07-03T05:12:19+08:00" />
<meta property="article:modified_time" content="2019-07-03T05:12:19+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">AODV协议概述</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="cnblogs_post_body" class="blogpost-body"> 
 <p>AODV是由Nokia研究中心的Charles E.Perkins和加利福尼亚大学Santa Barbara的Elizabeth M.Belding-Roryer以及Cincinnati大学Samir R.Das等共同开发，已经被 IETF MANET工作组于2003年7月正式公布为自组网路由协议的RFc标准。</p> 
 <p><strong>AODV实质上就是DSR和DSDV的综合，它借用了DSR中路由发现和路由维护的基础程序，及DSDV的逐跳(Hop-by-HoP)路由、目的节点序列号和路由维护阶段的周期更新机制，以DSDV为基础，结合DSR中的按需路由思想并加以改进。</strong></p> 
 <p><strong></strong>AODV在每个中间节点隐式保存了路由请求和应答的结果，并利用扩展环搜索的办法来限制搜索发现过的目的节点的范围。AODV支持组播功能，支持Qos，而且AODV中可以使用IP地址，实现同Internet连接，但是不支持单向信道。和DSDV保存完整的路由表不同的是，AODV通过建立基于按需路由来减少路由广播的次数，这是AODV对DSDV的重要改进。和DSR相比，AODV的好处在于源路由并不需要包括在每一个数据分组中，这样会使路由协议的开销有所降低。AODV是一个纯粹的按需路由系统，那些不在路径内的节点不保存路由信息，也不参与路由表的交换。AODv协议可以实现在移动终端间动态的、自发的路由，使移动终端很快获得通向所需目的的路由，同时又不用维护当前没有使用的路由信息，并且还能很快对断链的拓扑变化做出反应。AODV的操作是无环路的，在避免了通常Bellman-ford算法的无穷计数问题的同时，还提供了很快的收敛速度。AODv的路由表中每个项都使用了目的序列号(Destination Sequence Number)。目的序列号是目的节点创建，并在发给发起节点的路由信息中使用的。使用目的序列号可以避免环路的发生。</p> 
 <p><br></p> 
 <div> 
  AODV 
  使用 
  3 
  种消息作为控制信息 
   :RouteRequest(RREQ) 
  ， 
  RouteReply(RREP) 
  和 
   RouteError(RERR) 
  。这些消息都在 
  UDP 
  上使用 
  654 
  端口号。 
 </div> 
 <div> 
  　　当源节点需要和目的节点通信时，如果在路由表中已经存在了对应的路由时， 
  AODV 
  不会进行任何操作。当源节点需要和新的目的通信时，它就会发起路由发现过程，通过广播 
  RREQ 
  信息来查找相应路由。当这个 
  RREQ 
  到达目的节点本身，或者是一个拥有足够新的到目的节点路由的中间节点时，路由就可以确定了。所谓 
  “ 
  足够新 
  ” 
  就是通过目的序列号来判断的。目的节点或中间节点通过原路返回一个 
  RREP 
  信息来向源节点确定路由的可用性。在维护路由表的过程中，当路由不再被使用时，节点就会从路由表中删除相应的项。同时，节点会监视一个活动路由 
  (activeroute 
  ，有限跳的，可用于数据转发的路由表 
  ) 
  中，下一跳节点的状况。当发现有链路断开的情况时，节点就会使用 
  RERR 
  通知上游的节点，而上游的节点就会使用该 
  RERR 
  分组拷贝通知更上游的节点。在 
  RERR 
  消息中，指明了由于断链而导致无法达到目的节点。每个节点都保留了一个 
  “ 
  前驱列表 
  ”(precursor list) 
  来帮助完成错误报告的功能，这个列表中保存了把自己作为到当前不可达节点的下一跳的相邻节点 
  ( 
  可以通过记录 
  RERR 
  很容易地获得 
  ) 
  。在路由表中，针对每一个表项，需要记录相应的的特征内容。其中，序列号是防止路由环路的关键所在。当发生断链时，通过增加序列号 
 </div> 
 <div> 
  和度量值 
  ( 
  跳数 
  ) 
  来使路由表项无效。 
 </div> 
 <div> 
  <br> 
 </div> 
 <div> 
  <strong>②</strong><strong>AODV</strong><strong>路由协议的运行方式</strong> 
 </div> 
 <div> 
  <strong>(a)AODV</strong> 
  <strong>路由发现</strong> 
 </div> 
 <div> 
  　　 
  AODV 
  路由协议是一种典型的按需驱动路由协议，该算法可被称为纯粹的需求路由获取系统，那些不在活跃路径上的节点不会维持任何相关路由信息，也不会参与任何周期路由表的交换。此外，节点没有必要去发现和维持到另一节点的路由，除非这两个节点需要进行通信。移动节点间的局部连接性可以通过几种方法得到，其中包括使用局部广播 
  Hello 
  消息。这种算法的主要目的是 
  : 
  在需要时广播路由发现分组一般的拓扑维护 
  ; 
  区别局部连接管理 
  ( 
  邻居检测 
  ) 
  和一般的拓扑维护 
  ; 
  向需要连接信息的邻居移动节点散播拓扑变化信息。 
  AODV 
  使用广播路由发现机制，它依赖中间节点动态建立路由表来进行分组的传送。为了维持节点间的最新路由信息， 
  AODV 
  借鉴了 
  DSDV 
  中的序列号的思想，利用这种机制就能有效地防止路由环的形成。当源节点想与另外一个节点通信，而它的路由表中又没有相应的路由信息时，它就会发起路由发现过程。每一个节点维持两个独立的计数器 
  : 
  节点序列号计数器和广播标识。源节点通过向自己的邻居广播 
   RREQ(Route Requests) 
  分组来发起一次路由发现过程。 
 </div> 
 <div> 
  <strong>(b)</strong> 
  <strong>反向路由的建立</strong> 
 </div> 
 <div> 
  　　在 
  RREQ 
  分组中包含了两个序列号 
  : 
  源节点序列号和源节点所知道的最新的目的序列号。源节点序列号用于维持到源的反向路由的特性，目的序列号表明了到目的地的最新路由。当 
  RREQ 
  分组从一个源节点转发到不同的目的地时，沿途所经过的节点都要自动建立到源节点的反向路由。节点通过记录收到的第一个 
  RREQ 
  分组的邻居地址来建立反向路由，这些反向路由将会维持一定时间，一该段时间足够 
  RREQ 
  分组在网内转发以及产生的 
  RREP 
  分组返回源节点。当 
  RREQ 
  分组到达了目的节点，目的节点就会产生 
  RREP 
  分组，并利用建立的反向路由来转发 
  RREP 
  。 
 </div> 
 <div> 
  <strong>(c)</strong> 
  <strong>正向路由的建立</strong> 
 </div> 
 <div> 
  　　 
  RREQ 
  分组最终将到达一个节点，该节点可能就是目的节点，或者这个节点有到达目的节点的路由。如果这个中间节点有到达目的的路由项，它就会比较路由项里的目的序列号和 
  RREQ 
  分组里的目的序列号的大小来判断自己已有的路由是否是比较新的。如果 
  RREQ 
  分组里的目的序列号比路由项中的序列号大，则这个中间节点不能使用己有的路由来响应这个 
  RREQ 
  分组，只能是继续广播这个 
  RREQ 
  分组。中间节点只有在路由项中的目的序列号不小于 
  RREQ 
  中的目的序列号时，才能直接对收到的 
  RREQ 
  分组做出响应。如果节点有到目的地的最新路由，而且这个 
  RREQ 
  还没有被处理过，这个节点将会沿着建立的反向路由返回 
  RREP 
  分组。 
 </div> 
 <div> 
  　　在 
  RREP 
  转发回源节点的过程中，沿着这条路径上的每一个 
  . 
  节点都将建立到目的节点的同向路由，也就是记录下 
  RREP 
  是从哪一个邻居节点来的地址，然后更新有关源和目的路由的定时器信息以及记录下 
  RREP 
  中目的节点的最新序列号。对于那些建立了反向路由，但 
  RREP 
  分组并没有经过的节点，它们中建立的反向路由将会在一定时间 
  (Active-Route-Timeout) 
  后自动变为无效。收到 
  RREP 
  分组的节点将会对到某一个源节点的第一个 
  RREP 
  分组进行转发，对于其后收到的到同一个源的 
  RREP 
  分组，只有当后到的 
  RREP 
  分组中包含了更高的目的序列号或虽然有相同的目的序列号但所经过的跳数较少时，节点才一会重新更新路由信息，以及把这个 
  RREP 
  分组转发出去。这种方法有效地抑制了向源节点转发的 
  RREP 
  分组数，而且确保了最新及最快的路由信息。源节点将在收到第一个 
  RREP 
  分组后，就开始向目的节点发送数据分组。如果以后源节点了解到的更新的路由，它就会更新自己的路由信息。 
 </div> 
 <div> 
  <br> 
 </div> 
 <div> 
  <strong>③</strong><strong>AODV</strong><strong>路由表的管理</strong> 
 </div> 
 <div> 
  　　节点的路由中除了存储源和目的节点的序列号外，还存储了其他有用的信息，这些信息成为有关路由项的软状态。与反向路由相关的是路由请求定时器，这些定时器的目的是清除一定时间内没有使用的反向路由项。定时器的设置依赖于自组网的规模大小，与路由表相联系的另外一个重要的参数是路由缓存时间，即在超过这个时间之后，对应的路由表就变为无效。 
 </div> 
 <div> 
  　　此外，在每一个路由表中，还要记录本节点用于转发分组的活跃邻居。如果节点在最近一次活跃期间 
  (Active-Timeout) 
  发起或转发了到某个目的节点的分组，那么就可以称这个节点为活跃节点。这样，当到达某一个目的节点的链路有问题时，所有与这条链路有关的活跃节点都可以被通知到。一个路由表还有活跃邻居在使用，就可以认为是有效的。通过各个活跃路由项所建立的源节点到目的节点的路径，也就是一条活跃路径。路由表中的目的节点序列号，正如在 
  DSDV 
  路由协议中所使用的那样，可以在无序分组的传送和节点高度移动的极端条件下避免路由环路的产生。 
 </div> 
 <div> 
  　　移动节点为每一个相关的目的节点维护了一个路由表。每一个路由表包含以下一些信息 
  : 
  目的地址、下一跳地址、跳数、目的序列号及路由项的生存时间。路由表在每一次被用来传送一个分组时，它的生存时间都要重新开始计算，也就是用当前时间加上 
  Aetive-Route-Timeout 
  。如果一个移动节点被提供了到达某一个目的节点的新路由，那么它就会把这个新路由的目的序列号与自己路由表中己有的目的序列号做比较，并将目的序列号大的作为到达目的节点的路由表。如果目的序列号相同，则采用到目的节点所经过的节点数 
  ( 
  跳数 
  ) 
  最少的那个路由。 
 </div> 
 <div> 
  <br> 
 </div> 
 <div> 
  <strong>④</strong><strong>AODV</strong><strong>路由维护</strong> 
 </div> 
 <div> 
  　　如果节点的移动不是沿着活跃路径进行的，那么就不会影响己经建立的路由。如果一个源节点在活跃路径上移动，它就要向目的节点重新发起一次路由发现过程。如果移动的节点是中间节点或目的节点，那么一个特殊的 
  RREP 
  分组将转发到那些受移动影响的源节点。周期性发送的 
  Hello 
  分组可以用来确保链路的对称性，并检测不能用的链路。如果不用 
  Hello 
  分组，也可以采用链路层通告机制来报告链路的无效性，这样可以减少延迟。此外，节点在尝试向下一跳节点转发分组失败后，也能检测出链路的不可用性。 
 </div> 
 <div> 
  　　一旦一个节点的下一跳节点变得不可达，这时它就要向利用该损坏链路的活跃上游节点发送未被请求的 
  RREP 
  （ 
  RERR 
  ）分组，这个 
  RREP(RERR) 
  分组带有一个新的序列号 
  ( 
  即在目的序列号上加 
  1) 
  ，并将跳数值设置为二。收到这个 
  RREP(RERR) 
  分组的节点再依次将 
  RREP(RERR) 
  分组转发到它们各自的活跃邻居，这个过程持续到所有的与损坏链路有关的活跃节点都被通知到为止。源节点在收到断链的通知后，如果它还要与目的节点联系，它就需要再次发<em>起新的路由发现过程。</em>这时，它将会广播一个 
  RREQ 
  分组，这个 
  RREQ 
  分组中的目的序列号要在源节点已知的最新目的序列号之上加 
  1 
  ，以确保那些还不知道目的节点最新位置的中间节点对这个 
  RREQ 
  分组做出响应，从而能保证 
  建立一条新的、有效的路由。 
 </div> 
 <div> 
  <br> 
 </div> 
 <div> 
  <strong>⑤</strong><strong>AODV</strong><strong>协议评价</strong> 
 </div> 
 <div> 
  　　总之， 
  AODV 
  是一种距离矢量路由协议，采用的算法克服了以前提出的一些算法 
  ( 
  如 
  DSDV) 
  的缺点，具有如下优点 
  : 
 </div> 
 <div> 
  　　 
  (a) 
  基于传统的距离向量路由机制，思路简单、易懂。 
 </div> 
 <div> 
  　　 
  (b) 
  支持中间节点应答，能使源节点快速获得路由，有效减少了广播数，但存在过时路由问题。 
 </div> 
 <div> 
  　　 
  (c) 
  节点只存储需要的路由，减少了内存的需求和不必要的复制。 
 </div> 
 <div> 
  　　 
  (d) 
  快速响应活跃路径上断链。 
 </div> 
 <div> 
  　　 
  (e) 
  通过使用目的序列号来避免路由环路，解决了传统的基于距离向量路由协议存在的无限计数问题。 
 </div> 
 <div> 
  　　 
  (f) 
  具有网络的可扩充性。 
 </div> 
 <div> 
  　　 
  (g) 
  需要周期性地广播分组，需要消耗一定的电池能源和网络带宽。与 
  DSDV 
  以及其他持续存储更新路由信息的算法相比， 
  AODV 
  需要相对较长的路由建立时延，不过 
  AODV 
  采取了以下的一些措施来加以改善 
  : 
 </div> 
 <div> 
  　　 
  (a) 
  到某个目的节点的路由可以由知道路由的中间节点进行响应。 
 </div> 
 <div> 
  　　 
  (b) 
  链路失效能够被立即报告，这样路由可重新建立。 
 </div> 
 <div> 
  　　 
  (c) 
  不活跃的路由在一定时间后会被删除。 
 </div> 
</div> 
<p>转载于:https://www.cnblogs.com/zhangrui/archive/2011/12/16/2290370.html</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b817e7657c85c40dddeb42720584de53/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Word Ladder</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/7e84bfe8522ef6c1efe6eabcd3e1443e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">CRP实施方法论</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>