<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【C语言进阶】字符串处理函数的介绍 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【C语言进阶】字符串处理函数的介绍" />
<meta property="og:description" content="目录
前言：
一、字符串处理函数介绍：
1.strlen函数：
2.strcpy函数：
3.strcat函数：
4.strcmp函数：
5.strncpy函数：
6.strncat函数：
7.strncmp函数：
8.strstr函数：
9.strtok函数：
10.strerror函数：
11.memcopy函数：
12.memmove函数：
13.memcmp函数：
二、总结：
前言： 本文我们将进入对字符串处理函数的学习，重点介绍处理字符和字符串的库函数的使用和注意事项。
一、字符串处理函数介绍： C语言中对字符和字符串的处理很是频繁，但是C语言本身是没有字符串类型的，字符串通常放在常量字符串或字符数组中。其中，字符串常量是用于那些对它不修改的字符串函数。
1.strlen函数： 相信大家对strlen函数已经不陌生，在C语言初阶我们就经常使用这个函数了。
strlen函数（string length）的作用是用于返回字符串结束标志‘\0’之前出现的字符个数，因此，strlen函数处理的字符串对象必须是以结束标志‘\0’结尾的字符串。其返回值类型是size_t类型，也就是无符号类型。
下面是strlen函数的基本使用方法：
#include&lt;stdio.h&gt; #include&lt;string.h&gt; int main() { char arr1[] = &#34;hellow&#34;; char arr2[] = { &#39;h&#39;,&#39;e&#39;,&#39;l&#39;,&#39;l&#39;,&#39;o&#39;,&#39;w&#39;,&#39;\0&#39; }; char arr3[] = { &#39;h&#39;,&#39;e&#39;,&#39;l&#39;,&#39;l&#39;,&#39;o&#39;,&#39;w&#39; }; int len1 = strlen(arr1); int len2 = strlen(arr2); int len3 = strlen(arr3); printf(&#34;%d &#34;, len1); printf(&#34;%d &#34;, len2); printf(&#34;%d &#34;, len3); return 0; } 该代码输出结果如下：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/2f5f51f2a8b467e1b6082c93701a4c5b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-02-24T16:15:52+08:00" />
<meta property="article:modified_time" content="2023-02-24T16:15:52+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【C语言进阶】字符串处理函数的介绍</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><strong>目录</strong></p> 
<p style="margin-left:0px;"><a href="#%E5%89%8D%E8%A8%80%EF%BC%9A" rel="nofollow">前言：</a></p> 
<p style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0%E4%BB%8B%E7%BB%8D%EF%BC%9A" rel="nofollow">一、字符串处理函数介绍：</a></p> 
<p style="margin-left:40px;"><a href="#1.strlen%E5%87%BD%E6%95%B0%EF%BC%9A" rel="nofollow">1.strlen函数：</a></p> 
<p style="margin-left:40px;"><a href="#2.strcpy%E5%87%BD%E6%95%B0%EF%BC%9A" rel="nofollow">2.strcpy函数：</a></p> 
<p style="margin-left:40px;"><a href="#3.strcat%E5%87%BD%E6%95%B0%EF%BC%9A" rel="nofollow">3.strcat函数：</a></p> 
<p style="margin-left:40px;"><a href="#4.strcmp%E5%87%BD%E6%95%B0%EF%BC%9A" rel="nofollow">4.strcmp函数：</a></p> 
<p style="margin-left:40px;"><a href="#5.strncpy%E5%87%BD%E6%95%B0%EF%BC%9A" rel="nofollow">5.strncpy函数：</a></p> 
<p style="margin-left:40px;"><a href="#6.strncat%E5%87%BD%E6%95%B0%EF%BC%9A" rel="nofollow">6.strncat函数：</a></p> 
<p style="margin-left:40px;"><a href="#7.strncmp%E5%87%BD%E6%95%B0%EF%BC%9A" rel="nofollow">7.strncmp函数：</a></p> 
<p style="margin-left:40px;"><a href="#8.strstr%E5%87%BD%E6%95%B0%EF%BC%9A" rel="nofollow">8.strstr函数：</a></p> 
<p style="margin-left:40px;"><a href="#9.strtok%E5%87%BD%E6%95%B0%EF%BC%9A" rel="nofollow">9.strtok函数：</a></p> 
<p style="margin-left:40px;"><a href="#10.strerror%E5%87%BD%E6%95%B0%EF%BC%9A" rel="nofollow">10.strerror函数：</a></p> 
<p style="margin-left:40px;"><a href="#11.memcopy%E5%87%BD%E6%95%B0%EF%BC%9A" rel="nofollow">11.memcopy函数：</a></p> 
<p style="margin-left:40px;"><a href="#12.memmove%E5%87%BD%E6%95%B0%EF%BC%9A" rel="nofollow">12.memmove函数：</a></p> 
<p style="margin-left:40px;"><a href="#13.memcmp%E5%87%BD%E6%95%B0%EF%BC%9A" rel="nofollow">13.memcmp函数：</a></p> 
<p style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81%E6%80%BB%E7%BB%93%EF%BC%9A" rel="nofollow">二、总结：</a></p> 
<hr> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<h2>前言：</h2> 
<p>        本文我们将进入对字符串处理函数的学习，重点介绍处理字符和字符串的库函数的使用和注意事项。</p> 
<h2>一、字符串处理函数介绍：</h2> 
<p>      C语言中对字符和字符串的处理很是频繁，但是C语言本身是没有字符串类型的，字符串通常放在<strong>常量字符串</strong>或<strong>字符数组</strong>中。其中，字符串常量是用于那些<strong>对它不修改的字符串函数。</strong></p> 
<h3><strong>1.strlen函数：</strong></h3> 
<p><strong>        </strong>相信大家对strlen函数已经不陌生，在C语言初阶我们就经常使用这个函数了。</p> 
<p><img alt="4cd5f613ea7a4d4e94d520fdfb38d19d.png" src="https://images2.imgbox.com/6a/13/VLwVh4q1_o.png"></p> 
<p>         strlen函数（string length）的作用是用于返回字符串结束标志<strong>‘\0’</strong>之前出现的字符个数，因此，strlen函数处理的字符串对象必须是以结束标志<strong>‘\0’</strong>结尾的字符串。其返回值类型是size_t类型，也就是无符号类型。</p> 
<p>下面是strlen函数的基本使用方法：</p> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
#include&lt;string.h&gt;

int main()
{
    char arr1[] = "hellow";
    char arr2[] = { 'h','e','l','l','o','w','\0' };
    char arr3[] = { 'h','e','l','l','o','w' };
    
    int len1 = strlen(arr1);
    int len2 = strlen(arr2);
    int len3 = strlen(arr3);

    printf("%d ", len1);
    printf("%d ", len2);
    printf("%d ", len3);

    return 0;

}</code></pre> 
<p>该代码输出结果如下：</p> 
<p><img alt="43fcc7552e9e4f648d7cbdca0b27a8d1.png" src="https://images2.imgbox.com/1e/eb/YHXvdrwH_o.png"></p> 
<p>        我们使用字符型数组将字符串存储起来，接着使用strlen函数计算字符串‘hellow’中所有字符的数量（使用双引号初始化字符串时，编译器自动在最后面加上‘\0’），并可以可以使用一个整形变量接收strlen函数的返回值，进行打印。当没有结束标志时候，strlen会一直读下去，这也就是len3=33的原因。</p> 
<p>        并且我们还说到，strlen函数的返回类型为无符号数，因此strlen函数不可以直接用来比较两个字符串的大小；例如：</p> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
#include&lt;string.h&gt;

int main()
{
    char arr1[] = "hellow";
    char arr2[] = "hel";
   
    if (strlen(arr2) - strlen(arr1)&gt;0)
    {
        printf("arr2&gt;arr1");
    }
    else
    {
        printf("arr2&lt;arr1");
    }
    return 0;

}</code></pre> 
<p>        按照我们正常思路是3-6为-3，然后会执行else语句。但实际上：</p> 
<p><img alt="0391c1e696e94d8ba43cbd8f27b9c21c.png" src="https://images2.imgbox.com/14/34/38y38XjR_o.png"></p> 
<p>         这是因为strlen函数的返回类型是无符号类型，得出的结果也是无符号类型，于是原本第一位即符号位上的数字也将被作为数据的一部分，因而实际得出的结果是一个非常大的整数，也就是大于0，也就执行了if语句。</p> 
<p>        如果你实在要比较大小的话，这边介绍两种方式：</p> 
<p>方式一：</p> 
<pre><code class="language-cpp">//用两个变量先存起来
#include&lt;stdio.h&gt;
#include&lt;string.h&gt;

int main()
{
    char arr1[] = "hellow";
    char arr2[] = "hel";
   
    int len1 = strlen(arr1);
    int len2 = strlen(arr2);

    if (len2-len1&gt;0)
    {
        printf("arr2&gt;arr1");
    }
    else
    {
        printf("arr2&lt;arr1");
    }
    return 0;

}</code></pre> 
<p>方式二：</p> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
#include&lt;string.h&gt;

//强制类型转换
int main()
{
    char arr1[] = "hellow";
    char arr2[] = "hel";
   
    if ((int)strlen(arr2) - (int)strlen(arr1)&gt;0)
    {
        printf("arr2&gt;arr1");
    }
    else
    {
        printf("arr2&lt;arr1");
    }
    return 0;

}</code></pre> 
<h3>2.strcpy函数：</h3> 
<p>        在之前的学习中，strcpy函数也是我们经常使用的字符串处理函数之一。</p> 
<p><img alt="10802c2f08ca490fa1d9d4973f0a5c3a.png" src="https://images2.imgbox.com/17/63/yisZy2Ri_o.png"></p> 
<p>        strcpy函数（string copy）的作用是：可以将字符串从源地址复制到目的地址，通俗来讲就是用来实现字符串的复制和拷贝。并且它会将源地址内的结束标志‘\0’一并拷贝过去，因此源地址必须以‘\0’一并拷贝过去，因此源地址必须以‘\0’结尾，且目的地址也将以结束标识符结尾 。而且，因为其作用拷贝字符串，因此目标地址的空间必须足够大，必须有足够大的空间容纳下源地址内字符串，同时目的地址的空间必须是可变的，可修改的。</p> 
<p>        下面是strpy函数的基本使用方式：</p> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
#include&lt;string.h&gt;

int main()
{
    const char arr1[] = "hellow";
    const char arr2[10] = { 0 };

    printf("%s\n", arr1);
    printf("%s\n", arr2);

    //strcpy(目的地址，源地址)；
    strcpy(arr2, arr1);
    
    printf("%s\n", arr1);
    printf("%s\n", arr2);
    return 0;

}</code></pre> 
<p>        我们初始化字符数组arr中的内容，并使arr2中内容为空。首先我们将两个字符串进行打印，验证拷贝前两字符串中的存储内容。接着我们使用strcpy函数将字符数组arr1中的字符串拷贝至arr2中，并在此之前打印两数组中的内容对拷贝结果进行验证。</p> 
<p>        我们要特别注意的是strcpy函数返回的是目标空间的起始地址，该函数设置返回值类型的实现链式访问。（以后会讲到，这里仅做了解）。</p> 
<h3>3.strcat函数：</h3> 
<p>        这个字符串处理函数就比较陌生了，在我们之前的学习中没有用到过，，甚至见都没有见过。</p> 
<p><img alt="5520cc4e0d4c4e68ad379ef9a59d8242.png" src="https://images2.imgbox.com/3e/0c/lbQtcQJ5_o.png"></p> 
<p>        strcat函数（string catenate）的作用是：将源地址的字符串追加到目的地址。与字符串拷贝函数相同，它在进行补充追加时是从目的地址的结束标识符‘\0’开始追加的，追加至源地址的结束标识符停止的。且它同样要求目标地址内的空间必须足够大，要有足够的空间容纳下源地址内字符串，同时目的地址的空间必须是可变的、可修改的。</p> 
<p>        下面是strcat函数的基本使用方式：</p> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
#include&lt;string.h&gt;

int main()
{
    const char arr1[20] = "hellow ";
    const char arr2[20] = "world";

    printf("%s\n", arr1);
    printf("%s\n", arr2);

    //strcat(目的地址，源地址)；
    strcat(arr1, arr2);
    
    printf("%s\n", arr1);
    printf("%s\n", arr2);
    return 0;

}</code></pre> 
<p>        我们同样首先定义并初始化两个字符数组，接着打印他们验证他们各自内部的存储内容。然后通过是用strcat函数，我们将字符数组arr2中的内容，成功的追加补充倒了字符数组arr1中，并再次进行打印，验证追加补充的结果。</p> 
<p>        注意，strcat函数无法追加自己。原因很好理解，我们在定义是就已经固定了字符数组的储存空间了，当追加自己时，相当于将自己与自己相同大小的字符数组，即两倍自身大小的数据放入自己的储存空间，可想而知一定是不可行的。</p> 
<h3>4.strcmp函数：</h3> 
<p>        <img alt="dc3a7acff043435d8e2f6c2c2cad7e71.png" src="https://images2.imgbox.com/c0/6a/2c1uGHPL_o.png"></p> 
<p>        strcmp函数（string compare）的作用是：按照顺序依次比较两字符串对应位置字符的ASCII码值（注意不是比较两字符串的长度哦），直到结束标识符‘\0’或对应位置的字符不同。若比较到结束标识符都没有不同则字符串相等，若两字符串对应位置字符有不同，谁的ASCII码值小，那个ASCII码值小的字符比较小。</p> 
<p>同样的我们来看看strcmp的基本使用方式：</p> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
#include&lt;string.h&gt;

int main()
{
    const char arr1[20] = "abc";
    const char arr2[20] = "abz";

    int ret = strcmp(arr1, arr2);
    //如果arr1大于arr2，则返回大于0的数；
    //如果arr1等于arr2，则返回等于0的数；
    //如果arr1小于arr2，则返回小于0的数；

    if (ret &gt; 0)
    {
        printf("arr1&gt;arr2");
    }
    else if (ret == 0)
    {
        printf("arr1=arr2");
    }
    else
    {
        printf("arr1&lt;arr2");

    }
    
    return 0;

}</code></pre> 
<p>        首先我们定义并初始化两个字符数组，接着对两个数组进比较，根据strcmp函数的比较结果得到返回值，再根据返回值反馈我们想要的字符串比较结果。</p> 
<p>        这里的要点是：该函数的作用并不是比较字符串的长短，而是比较对应位置字符ASCII码值的大小。</p> 
<h3>5.strncpy函数：</h3> 
<p><img alt="c577a3f58ff343ecbbc6c6903c37a837.png" src="https://images2.imgbox.com/f1/4e/G9ejUHbn_o.png"></p> 
<p>        strncpy函数（string number copy）的作用是：将指定长度的字符串复制到字符数组中，即表示把源地址中字符串开始的前n个字符拷贝到目的地址中。与strcpy相同，它同样会将源地址内的结束标识符‘\0'一并拷贝过去，因此源地址必须以’\0‘结尾，且目的地址也将以结束标识符结尾。并且因为其作用为拷贝字符串，所以目标地址内的空间必须足够大，要有足够的空间容纳下源地址内的字符串，同时目的地址空间必须是可变，可修改的。 </p> 
<p>下面来看strncpy函数的基本使用方式：</p> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
#include&lt;string.h&gt;

int main()
{
    const char arr1[] = "hellow";
    const char arr2[10] = { 0 };

    printf("%s\n", arr1);
    printf("%s\n", arr2);

    //strcpy(目的地址，源地址,拷贝个数)；
    strncpy(arr2, arr1,3);

    printf("%s\n", arr1);
    printf("%s\n", arr2);
    return 0;

}</code></pre> 
<p>        我们看到，使用该函数，我们成功的将字符数组arr1中前3个字符拷贝到字符数组arr2中，并且通过前后两次打印的打印验证了按指定长度拷贝操作完成。</p> 
<p>ps：若源字符串的长度小于我们传递过去的参数，则拷贝完源字符串之后，将在后面加字符'\0'，直至拷贝够参数规定的个数。</p> 
<h3>6.strncat函数：</h3> 
<p><img alt="00178ae0104f43f1973eee9719041478.png" src="https://images2.imgbox.com/d9/8e/FYr695RX_o.png"></p> 
<p>        strncat函数（string number catenate）的作用：从源地址处将指定长度的字符串追加到目的地址中。与strcat类似，他在进行补充追加时，也是从目的地址的结束标识符'\0'开始追加的，不同的是追加到参数限制的字符数出停止。 但它同样要求目标地址内的空间必须足够大，要有足够的空间容纳下追加的字符串，同时目的地址的空间必须是可变的、可修改的。</p> 
<p>strncat的基本使用方式：</p> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
#include&lt;string.h&gt;

int main()
{
    const char arr1[20] = "hellow ";
    const char arr2[20] = "world";

    printf("%s\n", arr1);
    printf("%s\n", arr2);

    //strcat(目的地址，源地址,追加个数)；
    strncat(arr1, arr2,3);

    printf("%s\n", arr1);
    printf("%s\n", arr2);
    return 0;

}</code></pre> 
<p>        首先我们定义并初始化两个字符数组，接着打印追加前他们各自的内容，然后我们使用strncat函数有限制的从数组arr1向arr2追加了3个字符，最后进行打印验证。</p> 
<h3>7.strncmp函数：</h3> 
<p><img alt="65e5bc101e6a41f4a195ec5bd4fcf7c2.png" src="https://images2.imgbox.com/53/4b/PqphFAef_o.png"></p> 
<p> strncmp函数（string number compare)的作用是：有限制的按照顺序依次比较两字符串对应位置字符的ASCII码值（注意不是比较两字符串的长度哦），直到参数限制数位置上的字符都比较结束或对应位置的字符不同。若参数限制位数位置上的字符都比较结束且都没有不同则两字符串相等，若两字符串对应位置字符有不同，谁的ASCII码值小，那个ASCII码值小的字符比较小。</p> 
<p>下面是strncmp函数的基本使用方式：</p> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
#include&lt;string.h&gt;

int main()
{
    const char arr1[20] = "abcdef";
    const char arr2[20] = "abz";

    int ret = strncmp(arr1, arr2,3);
    //如果arr1大于arr2，则返回大于0的数；
    //如果arr1等于arr2，则返回等于0的数；
    //如果arr1小于arr2，则返回小于0的数；

    if (ret &gt; 0)
    {
        printf("arr1&gt;arr2");
    }
    else if (ret == 0)
    {
        printf("arr1=arr2");
    }
    else
    {
        printf("arr1&lt;arr2");

    }

    return 0;

}</code></pre> 
<p>        其作用原理与作用过程跟strcmp十分类似，唯一不同便是限制了比较的字符数，所以就不过多阐述了。</p> 
<h3>8.strstr函数：</h3> 
<p>      <img alt="8682146a00a744c8b21f2b2dd04ec5e9.png" src="https://images2.imgbox.com/19/c7/g6Tj9v9F_o.png">  </p> 
<p>strstr函数（string string）的作用是：从一个字符串中寻找其字符串，通俗来讲就是从一个字符串中寻找另外一个字符串。若找到目标字符串则返回指向目标字符串的指针，若没有找到则返回空指针 。</p> 
<p>我们来看看strstr函数的基本使用方式：</p> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
#include&lt;string.h&gt;

int main()
{
    const char arr1[20] = "abcdef";
    const char arr2[20] = "cd";

    //从arr1中找arr2；
    char* ps = strstr(arr1, arr2);

    if (ps == NULL)
    {
        printf("没找到\n");
    }
    else
    {
        printf("找到了：%s", ps);
    }

    

    return 0;

}</code></pre> 
<p>        我们定义并初始化了两个字符数组，并使用strstr函数进行字符串寻找，并使用了字符型指针接收函数的返回值，最后对接受了返回值的指针ps进行判断，若为空则为没有从数组arr1找到字符串arr2，反之则会找到了。</p> 
<h3>9.strtok函数：</h3> 
<p><img alt="46be62ef885641309f35c898fe333505.png" src="https://images2.imgbox.com/3d/89/xJZLDNGr_o.png"></p> 
<p>        strtok函数（string token）的作用是：将字符串分解为一组字符串。听起来有点懵，实际很简单。该函数有两个数组作为参数，他的实际作用便是将其中一个数组组为分割数组，在另一个数组中寻找这些“分割符”，并在分隔符处将这个数组内的字符串加上结束标识符'\0'，将其分割成一组（多个）字符串。若第一个参数不为NULL；将找到字符数组中的第一个标记并保存他在字符串中的位置；若第一个参数为NULL，将在同一个字符串中被保存的位置开始，查找下一个标记。如果字符串中不存在更多的标记，则返回 NULL 指针。</p> 
<p>下面是strtok函数的基本使用方式：</p> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
 
int main()
{
	char arr1[] = "1254594572@QQ.COM";
	char arr2[30] = { 0 };
	strcpy(arr2, arr1);
 
	const char* arr3 = "@.";
 
	printf("账号：%s\n", strtok(arr2, arr3));
	//找到第一个标记停止
	printf("服务商：%s\n", strtok(NULL, arr3));
	//从保存好的位置开始往后找
	printf("网址后缀：%s\n", strtok(NULL, arr3));
	//从保存好的位置开始往后找
 
	return 0;
}
</code></pre> 
<p>        首先我们要知道，<strong>strtok 函数是会对数组本身进行操作的</strong>，所以我们为了保护原始数据，在定义并初始化好字符数组之后，又<strong>定义了一个新的数组并将原始数据拷贝过去</strong>，作为临时拷贝供我们进行操作。接着<strong>我们定义并初始化了分割符数组</strong>，函数将根据分割符数组 arr3 对 <strong>临时拷贝 arr2 进行分割</strong>。<strong>第一次执行函数时之前没有标记</strong>，于是直接进行操作找到第一个标记并分割打印。此时就已经存在标记了，再连续两次找到前一次执行作下的标记按照分割符将数组分割完毕并打印。<br>         但是上面的代码风格较为简陋、复杂，我们可以将上面段代码优化为：</p> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
 
int main()
{
	char arr1[] = "1254594572@QQ.COM";
	char arr2[30] = { 0 };
	strcpy(arr2, arr1);
 
	const char* arr3 = "@.";
 
	char* str = NULL;
	for (str = strtok(arr2, arr3); str != NULL; str = strtok(NULL, arr3))
	{
		printf("%s\n", str);
	}
 
	return 0;
}</code></pre> 
<p>ps：若字符串中不存在更多的标记，则返回 NULL 指针。</p> 
<h3>10.strerror函数：</h3> 
<p><img alt="ffac4da78a99485581c730e832f3f151.png" src="https://images2.imgbox.com/e8/ca/qs4CJRui_o.png"></p> 
<p>         strerror函数（string error）的作用：返回错误码对应的信息。即根据接收到的错误码（错误码errno为全局变量），返回错原因的详细信息。</p> 
<p>下面是strerror函数的基本用法：</p> 
<pre><code class="language-cpp">int main()
{
    int i = 0;
    for (i = 0; i &lt;= 4; i++)
    {
        printf("错误原因：%s\n", strerror(i));
    }
    return 0;
}</code></pre> 
<h3>11.memcopy函数：</h3> 
<p><img alt="8f90992d341241bda5ba88ac9f8f8ac4.png" src="https://images2.imgbox.com/8b/7a/Ko62t35y_o.png"></p> 
<p>memcpy函数（memory copy）的作用：从源内存空间向目的内存空间拷贝限制数量（单位是字节）的数据。它与 strcpy 函数类似，作用均为拷贝数据，不同的是 strcpy 仅仅只操作字符串故会在结束标识符 ' \0 ' 处停止，而 memcpy 函数操作的是内存，内存中的数据是相邻的，故不会在结束标识符处停止。</p> 
<p>下面是memcpy函数的基本用法：</p> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
#include&lt;string.h&gt;

int main()
{
    int arr1[] = { 1,2,3,4,5,6 };
    int arr2[5] = { 0 };

    for (int i = 0; i &lt; 5; i++)
    {
        printf("%d ", arr2[i]);
    }
    printf("\n");
    //mencpy（目的地址，源地址，拷贝的大小）
    memcpy(arr2, arr1, 16);

    for (int i = 0; i &lt; 5; i++)
    {
        printf("%d ", arr2[i]);
    }
    return 0;
}</code></pre> 
<p>         我们首先<strong>创建并初始化了两个整形数组</strong>，接着<strong>打印出数组 arr2 内数据</strong>的存放情况。紧接着我们通过<strong>内存拷贝函数，将数组 arr1 内的前20个字节的数据拷贝给了 arr2数组</strong>。<strong>整型数组内每个数据元素所占的内存空间为4个字节，20个字节即将数组 arr1 中的前五个数据元素拷贝给了数组 arr2。</strong>最后再次<strong>打印数组 arr2 中的数据，验证拷贝结果。</strong></p> 
<p><strong>ps：</strong>如果源内存空间和目标内存空间有任何重叠，复制的结果都是未定义的。</p> 
<h3>12.memmove函数：</h3> 
<p><img alt="c9df8557d883487b9a228df6ae0ef1ce.png" src="https://images2.imgbox.com/63/bb/w7qGa75a_o.png"></p> 
<p>         memmove函数（memory move）的作用：弥补 memcpy 函数的不足，主要用于处理内存的重叠部分。即如果源空间和目标空间出现重叠，就得使用 memmove 函数来进行处理。</p> 
<p>下面是memmove函数的基本用法：</p> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
#include&lt;string.h&gt;

int main()
{
    int arr1[] = { 1,2,3,4,5,6,7,8,9 };
    

    for (int i = 0; i &lt; 7; i++)
    {
        printf("%d ", arr1[i]);
    }
    printf("\n");
    //mencpy（目的地址，源地址，拷贝的大小）
    memmove(arr1 + 2, arr1, 20);

    for (int i = 0; i &lt; 7; i++)
    {
        printf("%d ", arr1[i]);
    }
    return 0;
}</code></pre> 
<p>        这个函数与 memcpy 函数除处理对象不同外，语法结构和使用场景等都极其类似，这里也就不再做过多赘述。</p> 
<h3>13.memcmp函数：</h3> 
<p><img alt="275b55d55c8b436b82db79ef8330c98f.png" src="https://images2.imgbox.com/cf/57/lQadf264_o.png"></p> 
<p>         memcmp 函数（memory compare）的作用与 strcmp 函数的作用类似，不过 memcmp 函数是从内存的角度以字节为单位进行处理，故 memcmp 函数同样需要第三个参数进行限制，而不会在结束标识符 ' \0 ' 处停止比较。其它方面也就不再做过多赘述。 </p> 
<p>memcmp 函数的基本使用方式：</p> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
 
int main()
{
	int arr1[] = { 1,2,3,4,5,6,7,8,9 };
	int arr2[] = { 1,2,3,4,5,9,6,7,8 };
 
	int ret = memcmp(arr2, arr1, 24);
 
	if (ret &gt; 0)
	{
		printf("arr1 &lt; arr2\n");
	}
	else if (ret == 0)
	{
		printf("arr1 = arr2\n");
	}
	else
	{
		printf("arr1 &gt; arr2");
	}
 
	return 0;
}</code></pre> 
<h2>二、总结：</h2> 
<p>        本文到此就结束了，主要为大家整理并讲解了<strong>常用字符串操作函数</strong>，希望对大家有所帮助，同时本文仍有许多不足之处，欢迎各位小伙伴们随时批评指正！</p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4cbf9c6300933b32f8d650d29e76eca5/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">基于logback自定义一个kafka appender，以实现日志异步自动格式化为JSON字符串并推送到kafka</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/216ebeb7223004c2e10a93c18ac70bb8/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">2. Dart 开发工具环境配置</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>