<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>二十三种常见设计模式-简介 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="二十三种常见设计模式-简介" />
<meta property="og:description" content=" 设计模式分类 设计模式根据目的可分为三大类：
创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式，原型模式。
结构性模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。
行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。
设计模式的7大原则：
单一原则（SRP）：一个类（或方法）只做一件事。
开放-封闭原则（OCP）：软件实体（类、模块、函数）可以拓展，但是不可修改
依赖倒转原则（DIP）：高层模块不应该依赖底层，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。核心思想：面向接口编程，不要面向实现编程。
里氏代换原则（LSP）：子类必须能够替换其父类。子类可以扩展父类的功能，但不能改变父类原有的功能。
接口隔离原则（ISP）：尽量将臃肿庞大的接口拆分成更小的和更具体的接口，让接口中只包含客户感兴趣的方法。
迪米特法则（LoD）：如果两个类不必直接通信，那么这两个类不应当发生直接的相互作用。如果其中一个类需要调用另一个类的某一个方法的话，可通过第三者发起这个调用。
合成复用原则（CARP）：尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。
类之间的关系 UML 将事物之间的联系归纳为 6 种，并用对应的图形类表示。下面根据类与类之间的耦合度从弱到强排列。UML 中的类图有以下几种关系：依赖关系、关联关系、聚合关系、组合关系、泛化关系和实现关系。其中泛化和实现的耦合度相等，它们是最强的。
23种设计模式总览： 分类设计模式简述一句话归纳目的生活案例创建型设计模式（简单来说就是用来创建对象的）工厂模式（Factory Pattern）不同条件下创建不同实例产品标准化，生产更高效封装创建细节实体工厂单例模式（Singleton Pattern）保证一个类仅有一个实例，并且提供一个全局访问点世上只有一个我保证独一无二CEO原型模式（Prototype Pattern）通过拷贝原型创建新的对象拔一根猴毛，吹出千万个高效创建对象克隆建造者模式（Builder Pattern）用来创建复杂的复合对象高配中配和低配，想选哪配就哪配开放个性配置步骤选配结构型设计模式（关注类和对象的组合）代理模式（Proxy Pattern）为其他对象提供一种代理以控制对这个对象的访问没有资源没时间，得找别人来帮忙增强职责媒婆外观模式（Facade Pattern）对外提供一个统一的接口用来访问子系统打开一扇门，通向全世界统一访问入口前台装饰器模式（Decorator Pattern）为对象添加新功能他大舅他二舅都是他舅灵活扩展、同宗同源煎饼享元模式（Flyweight Pattern）使用对象池来减少重复对象的创建优化资源配置，减少重复浪费共享资源池全国社保联网组合模式（Composite Pattern）将整体与局部（树形结构）进行递归组合，让客户端能够以一种的方式对其进行处理人在一起叫团伙，心在一起叫团队统一整体和个体组织架构树适配器模式（Adapter Pattern）将原来不兼容的两个类融合在一起万能充电器兼容转换电源适配桥接模式（Bridge Pattern）将两个能够独立变化的部分分离开来约定优于配置不允许用继承桥行为型设计模式（关注对象之间的通信）模板模式（Template Pattern）定义一套流程模板，根据需要实现模板中的操作流程全部标准化，需要微调请覆盖逻辑复用把大象装进冰箱策略模式（Strategy Pattern）封装不同的算法，算法之间能互相替换条条大道通罗马，具体哪条你来定把选择权交给用户选择支付方式责任链模式（Chain of Responsibility Pattern）拦截的类都实现统一接口，每个接收者都包含对下一个接收者的引用。将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。各人自扫门前雪，莫管他们瓦上霜解耦处理逻辑踢皮球迭代器模式（Iterator Pattern）提供一种方法顺序访问一个聚合对象中的各个元素流水线上坐一天，每个包裹扫一遍统一对集合的访问方式逐个检票进站命令模式（Command Pattern）将请求封装成命令，并记录下来，能够撤销与重做运筹帷幄之中，决胜千里之外解耦请求和处理遥控器状态模式（State Pattern）根据不同的状态做出不同的行为状态驱动行为，行为决定状态绑定状态和行为订单状态跟踪备忘录模式（Memento Pattern）保存对象的状态，在需要时进行恢复失足不成千古恨，想重来时就重来备份、后悔机制草稿箱中介者模式（Mediator Pattern）将对象之间的通信关联关系封装到一个中介类中单独处理，从而使其耦合松散联系方式我给你，怎么搞定我不管统一管理网状资源朋友圈解释器模式（Interpreter Pattern）给定一个语言，定义它的语法表示，并定义一个解释器，这个解释器使用该标识来解释语言中的句子我想说”方言“，一切解释权都归我实现特定语法解析摩斯密码观察者模式（Observer Pattern）状态发生改变时通知观察者，一对多的关系到点就通知我解耦观察者与被观察者闹钟访问者模式（Visitor Pattern）稳定数据结构，定义新的操作行为横看成岭侧成峰，远近高低各不同解耦数据结构和数据操作KPI考核委派模式（Delegate Pattern）允许对象组合实现与继承相同的代码重用，负责任务的调用和分配这个需求很简单，怎么实现我不管只对结果负责授权委托书 " />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/f7838f3c16518b2b0f2b5d078f52294e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-11-16T10:47:14+08:00" />
<meta property="article:modified_time" content="2021-11-16T10:47:14+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">二十三种常见设计模式-简介</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="_0"></a>设计模式分类</h3> 
<p>设计模式根据目的可分为三大类：</p> 
<p>创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式，原型模式。</p> 
<p>结构性模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。</p> 
<p>行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</p> 
<p><strong>设计模式的7大原则：</strong></p> 
<p>单一原则（SRP）：一个类（或方法）只做一件事。</p> 
<p>开放-封闭原则（OCP）：软件实体（类、模块、函数）可以拓展，但是不可修改</p> 
<p>依赖倒转原则（DIP）：高层模块不应该依赖底层，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。核心思想：面向接口编程，不要面向实现编程。</p> 
<p>里氏代换原则（LSP）：子类必须能够替换其父类。子类可以扩展父类的功能，但不能改变父类原有的功能。</p> 
<p>接口隔离原则（ISP）：尽量将臃肿庞大的接口拆分成更小的和更具体的接口，让接口中只包含客户感兴趣的方法。</p> 
<p>迪米特法则（LoD）：如果两个类不必直接通信，那么这两个类不应当发生直接的相互作用。如果其中一个类需要调用另一个类的某一个方法的话，可通过第三者发起这个调用。</p> 
<p>合成复用原则（CARP）：尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。</p> 
<h3><a id="_28"></a>类之间的关系</h3> 
<p>UML 将事物之间的联系归纳为 6 种，并用对应的图形类表示。下面根据类与类之间的耦合度从弱到强排列。UML 中的类图有以下几种关系：依赖关系、关联关系、聚合关系、组合关系、泛化关系和实现关系。其中泛化和实现的耦合度相等，它们是最强的。</p> 
<h3><a id="23_32"></a>23种设计模式总览：</h3> 
<table><thead><tr><th>分类</th><th>设计模式</th><th>简述</th><th>一句话归纳</th><th>目的</th><th>生活案例</th></tr></thead><tbody><tr><td>创建型设计模式（简单来说就是用来创建对象的）</td><td>工厂模式（Factory Pattern）</td><td>不同条件下创建不同实例</td><td>产品标准化，生产更高效</td><td>封装创建细节</td><td>实体工厂</td></tr><tr><td></td><td>单例模式（Singleton Pattern）</td><td>保证一个类仅有一个实例，并且提供一个全局访问点</td><td>世上只有一个我</td><td>保证独一无二</td><td>CEO</td></tr><tr><td></td><td>原型模式（Prototype Pattern）</td><td>通过拷贝原型创建新的对象</td><td>拔一根猴毛，吹出千万个</td><td>高效创建对象</td><td>克隆</td></tr><tr><td></td><td>建造者模式（Builder Pattern）</td><td>用来创建复杂的复合对象</td><td>高配中配和低配，想选哪配就哪配</td><td>开放个性配置步骤</td><td>选配</td></tr><tr><td>结构型设计模式（关注类和对象的组合）</td><td>代理模式（Proxy Pattern）</td><td>为其他对象提供一种代理以控制对这个对象的访问</td><td>没有资源没时间，得找别人来帮忙</td><td>增强职责</td><td>媒婆</td></tr><tr><td></td><td>外观模式（Facade Pattern）</td><td>对外提供一个统一的接口用来访问子系统</td><td>打开一扇门，通向全世界</td><td>统一访问入口</td><td>前台</td></tr><tr><td></td><td>装饰器模式（Decorator Pattern）</td><td>为对象添加新功能</td><td>他大舅他二舅都是他舅</td><td>灵活扩展、同宗同源</td><td>煎饼</td></tr><tr><td></td><td>享元模式（Flyweight Pattern）</td><td>使用对象池来减少重复对象的创建</td><td>优化资源配置，减少重复浪费</td><td>共享资源池</td><td>全国社保联网</td></tr><tr><td></td><td>组合模式（Composite Pattern）</td><td>将整体与局部（树形结构）进行递归组合，让客户端能够以一种的方式对其进行处理</td><td>人在一起叫团伙，心在一起叫团队</td><td>统一整体和个体</td><td>组织架构树</td></tr><tr><td></td><td>适配器模式（Adapter Pattern）</td><td>将原来不兼容的两个类融合在一起</td><td>万能充电器</td><td>兼容转换</td><td>电源适配</td></tr><tr><td></td><td>桥接模式（Bridge Pattern）</td><td>将两个能够独立变化的部分分离开来</td><td>约定优于配置</td><td>不允许用继承</td><td>桥</td></tr><tr><td>行为型设计模式（关注对象之间的通信）</td><td>模板模式（Template Pattern）</td><td>定义一套流程模板，根据需要实现模板中的操作</td><td>流程全部标准化，需要微调请覆盖</td><td>逻辑复用</td><td>把大象装进冰箱</td></tr><tr><td></td><td>策略模式（Strategy Pattern）</td><td>封装不同的算法，算法之间能互相替换</td><td>条条大道通罗马，具体哪条你来定</td><td>把选择权交给用户</td><td>选择支付方式</td></tr><tr><td></td><td>责任链模式（Chain of Responsibility Pattern）</td><td>拦截的类都实现统一接口，每个接收者都包含对下一个接收者的引用。将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。</td><td>各人自扫门前雪，莫管他们瓦上霜</td><td>解耦处理逻辑</td><td>踢皮球</td></tr><tr><td></td><td>迭代器模式（Iterator Pattern）</td><td>提供一种方法顺序访问一个聚合对象中的各个元素</td><td>流水线上坐一天，每个包裹扫一遍</td><td>统一对集合的访问方式</td><td>逐个检票进站</td></tr><tr><td></td><td>命令模式（Command Pattern）</td><td>将请求封装成命令，并记录下来，能够撤销与重做</td><td>运筹帷幄之中，决胜千里之外</td><td>解耦请求和处理</td><td>遥控器</td></tr><tr><td></td><td>状态模式（State Pattern）</td><td>根据不同的状态做出不同的行为</td><td>状态驱动行为，行为决定状态</td><td>绑定状态和行为</td><td>订单状态跟踪</td></tr><tr><td></td><td>备忘录模式（Memento Pattern）</td><td>保存对象的状态，在需要时进行恢复</td><td>失足不成千古恨，想重来时就重来</td><td>备份、后悔机制</td><td>草稿箱</td></tr><tr><td></td><td>中介者模式（Mediator Pattern）</td><td>将对象之间的通信关联关系封装到一个中介类中单独处理，从而使其耦合松散</td><td>联系方式我给你，怎么搞定我不管</td><td>统一管理网状资源</td><td>朋友圈</td></tr><tr><td></td><td>解释器模式（Interpreter Pattern）</td><td>给定一个语言，定义它的语法表示，并定义一个解释器，这个解释器使用该标识来解释语言中的句子</td><td>我想说”方言“，一切解释权都归我</td><td>实现特定语法解析</td><td>摩斯密码</td></tr><tr><td></td><td>观察者模式（Observer Pattern）</td><td>状态发生改变时通知观察者，一对多的关系</td><td>到点就通知我</td><td>解耦观察者与被观察者</td><td>闹钟</td></tr><tr><td></td><td>访问者模式（Visitor Pattern）</td><td>稳定数据结构，定义新的操作行为</td><td>横看成岭侧成峰，远近高低各不同</td><td>解耦数据结构和数据操作</td><td>KPI考核</td></tr><tr><td></td><td>委派模式（Delegate Pattern）</td><td>允许对象组合实现与继承相同的代码重用，负责任务的调用和分配</td><td>这个需求很简单，怎么实现我不管</td><td>只对结果负责</td><td>授权委托书</td></tr></tbody></table>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9e72286da398aad1867e084f548bddd3/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">c&#43;&#43;-访问和修改类的私有变量</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8e4fe72d51c9b649351e5c34d01e8000/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">oracle sqlldr入门使用</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>