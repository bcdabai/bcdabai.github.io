<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Docker知识点整理 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Docker知识点整理" />
<meta property="og:description" content="Docker和虚拟机技术的区别： 传统的虚拟机，可以虚拟出一条硬件，运行一个完整的操作系统，在这个操作系统上安装和运行所需的软件
容器内的应用可以直接运行在宿主 主机的内核中，容器没有自己的内核，也不用虚拟硬件 （轻便）
每个容器是相互隔离的，每个容器内都有属于自己的文件系统，之间互不影响。
docker为什么比VM（虚拟机）快？ Docker有着比虚拟机更少的抽象层。docker利用的是宿主机的内核，vm需要是Guest OS。新建一个容器的时候，docker不需要像虚拟机一样重新加载一个操作系统内核，避免引导。
虚拟机是加载GuestOS，分钟级别的，而docker是利用宿主机的操作系统，省略了这个复杂的过程，秒级！ Docker优点 1. 应用于更快速的交付和部署
传统：通过大量的帮助文档，安装程序！
Docker：打包镜像发布测试，一键运行！
2. 更便捷的升级和扩缩容
通过使用Docker，部署应用 如同搭积木一样！
3. 更简单的系统运维
使用容器化之后，开发和测试环境是高度一致的
4.更高效的计算资源利用
Docker是内核级别的虚拟化，可以在一个物理机上运行很多的容器，让服务器的性能可以压榨到极致
Docker组成介绍 镜像（Image）：
docker镜像就好比一个模板，我们可以通过这个模板来创建容器服务，tomcat镜像===&gt;run==&gt;tomcat01容器（提供服务器），通过这个镜像可以创建多个容器（最终服务运行或者项目运行就是在容器中的）。
容器（container）：
docker利用容器技术，独立运行一个或者一组应用 通过镜像来创建
启动，停止，删除，基本命令！
目前就可以把这个容器理解为就是一个简易的linux系统
仓库（repository）：
仓库就是存放 镜像（image）的地方！
仓库又可以分为 公有仓库和私有仓库
Docker命令 镜像相关 docker images REPOSITORY 镜像的仓库源
TAG 镜像的标签
IMAGE ID 镜像的id
CREATED 镜像的创建时间
SIZE 镜像的大小
# 命令参数可选项
-a, --all # 显示所有镜像 (docker images -a)
-q, --quiet # 仅显示镜像id (docker images -q)
docker search（搜索镜像） 命令参数可选项 (通过搜索来过滤)" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/37a1c822fc50d0cfb404b789e8305601/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-14T23:13:42+08:00" />
<meta property="article:modified_time" content="2023-12-14T23:13:42+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Docker知识点整理</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2><strong>Docker和虚拟机技术的区别：</strong></h2> 
<p>传统的虚拟机，可以虚拟出一条硬件，运行一个完整的操作系统，在这个操作系统上安装和运行所需的软件<br> 容器内的应用可以直接运行在宿主 主机的内核中，容器没有自己的内核，也不用虚拟硬件 （轻便）<br> 每个容器是相互隔离的，每个容器内都有属于自己的文件系统，之间互不影响。</p> 
<h3>docker为什么比VM（虚拟机）快？</h3> 
<ol><li>Docker有着比虚拟机更少的抽象层。</li><li>docker利用的是宿主机的内核，vm需要是Guest OS。</li><li>新建一个容器的时候，docker不需要像虚拟机一样重新加载一个操作系统内核，避免引导。<br> 虚拟机是加载GuestOS，分钟级别的，而docker是利用宿主机的操作系统，省略了这个复杂的过程，秒级！</li></ol> 
<p><img alt="" height="368" src="https://images2.imgbox.com/0a/18/cwvlKyXN_o.png" width="607"></p> 
<p></p> 
<h2><strong>Docker优点</strong></h2> 
<p>1. 应用于更快速的交付和部署</p> 
<p>传统：通过大量的帮助文档，安装程序！<br> Docker：打包镜像发布测试，一键运行！<br> 2. 更便捷的升级和扩缩容</p> 
<p>通过使用Docker，部署应用 如同搭积木一样！<br> 3. 更简单的系统运维</p> 
<p>使用容器化之后，开发和测试环境是高度一致的<br> 4.更高效的计算资源利用</p> 
<p>Docker是内核级别的虚拟化，可以在一个物理机上运行很多的容器，让服务器的性能可以压榨到极致</p> 
<p></p> 
<h3>Docker组成介绍</h3> 
<p><img alt="" height="579" src="https://images2.imgbox.com/72/bb/fi0la25i_o.png" width="1089"></p> 
<p>镜像（Image）：</p> 
<blockquote> 
 <p>docker镜像就好比一个模板，我们可以通过这个模板来创建容器服务，tomcat镜像===&gt;run==&gt;tomcat01容器（提供服务器），通过这个镜像可以创建多个容器（最终服务运行或者项目运行就是在容器中的）。</p> 
</blockquote> 
<p>容器（container）：</p> 
<blockquote> 
 <p>docker利用容器技术，独立运行一个或者一组应用 通过镜像来创建</p> 
 <p>启动，停止，删除，基本命令！<br> 目前就可以把这个容器理解为就是一个简易的linux系统</p> 
</blockquote> 
<p>仓库（repository）：</p> 
<blockquote> 
 <p>仓库就是存放 镜像（image）的地方！</p> 
 <p>仓库又可以分为 公有仓库和私有仓库</p> 
</blockquote> 
<h2>Docker命令</h2> 
<h3>镜像相关</h3> 
<h4>docker images</h4> 
<p><img alt="" height="160" src="https://images2.imgbox.com/0a/78/PdMERBx3_o.png" width="601"></p> 
<blockquote> 
 <p>REPOSITORY 镜像的仓库源<br> TAG 镜像的标签<br> IMAGE ID 镜像的id<br> CREATED 镜像的创建时间<br> SIZE 镜像的大小<br> # 命令参数可选项<br> -a, --all # 显示所有镜像 (docker images -a)<br> -q, --quiet # 仅显示镜像id (docker images -q)</p> 
</blockquote> 
<h4>docker search（搜索镜像）</h4> 
<p><img alt="" height="103" src="https://images2.imgbox.com/f6/72/O9RgyDt7_o.png" width="671"></p> 
<blockquote> 
 <p><code>命令参数可选项 (通过搜索来过滤)</code></p> 
 <p><code>--filter=STARS=3000 # 搜索出来的镜像就是stars大于3000的</code></p> 
</blockquote> 
<h4>docker rmi（删除镜像）<img alt="" height="385" src="https://images2.imgbox.com/63/b1/fjeaofGg_o.png" width="605"></h4> 
<blockquote> 
 <p>docker rmi -f 镜像id                    # 删除指定的镜像<br> docker rmi -f 镜像id 镜像id 镜像id    # 删除多个镜像（空格分隔）<br> docker rmi -f $(docker images -aq)    # 删除全部的镜像</p> 
</blockquote> 
<h3>容器相关</h3> 
<h4>新建容器并启动</h4> 
<blockquote> 
 <p>docker run [可选参数] image<br> # 参数说明<br> --name="name"        容器名字：用来区分容器<br> -d                    后台方式运行：相当于nohup<br> -it                    使用交互式运行：进入容器查看内容<br> -p                    指定容器的端口（四种方式）小写字母p<br>     -p ip:主机端口：容器端口<br>     -p 主机端口：容器端口<br>     -p 容器端口<br>     容器端口<br> -P                     随机指定端口（大写字母P）</p> 
</blockquote> 
<h4>列出所有运行的容器</h4> 
<blockquote> 
 <p>docker ps # 列出当前正在运行的容器</p> 
 <p># 命令参数可选项</p> 
 <p>-a # 列出当前正在运行的容器+历史运行过的容器</p> 
 <p>-n=? # 显示最近创建的容器（可以指定显示几条，比如-n=1）</p> 
 <p>-q # 只显示容器的编号</p> 
</blockquote> 
<h4>退出容器</h4> 
<blockquote> 
 <p>exit # 容器直接停止，并退出</p> 
 <p>ctrl+P+Q # 容器不停止，退出</p> 
</blockquote> 
<h4>删除容器</h4> 
<blockquote> 
 <p>docker rm 容器id                    # 删除容器（不能删除正在运行的容器）如果要强制删除：docker rm -f 容器id<br> docker rm -f $(docker ps -aq)        # 删除全部容器<br> docker ps -a -q|xargs docker rm        # 删除所有容器</p> 
</blockquote> 
<h4>启动和停止容器的操作</h4> 
<blockquote> 
 <p>docker start 容器id        # 启动容器<br> docker restart 容器id    # 重启容器<br> docker stop 容器id        # 停止当前正在运行的容器<br> docker kill 容器id        # 强制停止当前容器</p> 
</blockquote> 
<h4>后台启动容器</h4> 
<blockquote> 
 <p># 命令docker run -d 镜像名</p> 
 <p></p> 
 <p>[root@JWei_0124 //]# docker run -d centos<br> 5b06d0d14b3312e589a411dd9ae15589dc9321f771e5615b7ae26e85017de080<br> # 问题：docker ps发现centos停止了<br> # 常见的坑：docker容器使用后台运行，就必须要有要一个前台进程，docker发现没有应用，就会自动停止。<br> # 比如：nginx，容器启动后，发现自己没有提供服务，就会立刻停止，就是没有程序了</p> 
</blockquote> 
<h4>查看日志</h4> 
<blockquote> 
 <p><br> docker logs -tf --tail 容器id</p> 
 <p></p> 
</blockquote> 
<h4>查看容器中进程的信息</h4> 
<blockquote> 
 <p>docker top 容器id</p> 
</blockquote> 
<h5>查看镜像的元数据</h5> 
<blockquote> 
 <p><code>命令docker inspect 容器id</code></p> 
</blockquote> 
<h5>进入当前正在运行的容器</h5> 
<blockquote> 
 <p>docker exec -it 容器id /bin/bash<br> docker attach 容器id<br><br> # docker exec        # 进入容器后开启一个新的终端，可以再里面操作（常用）<br> # docker attach        # 进入容器正在执行的终端，不会启动新的进程。</p> 
</blockquote> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/637694eee18301cf7d68448fb152a6bb/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">[PTA]计算字符串长度</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8060928fbc098e5d8b0a2a2749d76b00/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">时钟，NRZ/PAM4信号，眼图的关系</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>