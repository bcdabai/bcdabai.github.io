<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>详解SpringCloud微服务技术栈：Feign远程调用、最佳实践、错误排查 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="详解SpringCloud微服务技术栈：Feign远程调用、最佳实践、错误排查" />
<meta property="og:description" content="👨‍🎓作者简介：一位大四、研0学生，正在努力准备大四暑假的实习
🌌上期文章：详解SpringCloud微服务技术栈：Nacos配置管理
📚订阅专栏：微服务技术全家桶
希望文章对你们有所帮助
之前使用RestTemplate来实现远程调用，这种方式存在了一些问题，更优的解决方式是使用Feign来实现远程调用。
这里将会讲解如何用Feign实现远程调用，并进行最佳实践。
Feign的远程调用与最佳实践 基于Feign实现远程调用自定义配置性能优化Feign最佳实践分析实现 基于Feign实现远程调用 RestTemplate的问题：
1、代码可读性差，变成体验不统一
2、参数比较复杂的url，难以维护
Feign是一个声明式的http客户端，官方地址：Feign官网
声明式在Spring中开始提到，是利用配置文件来加事务。而声明式http客户端也是类似，我们只需要把发http请求所需要的信息声明出来即可，剩下的东西都交给Feign来实现。
使用Feign的步骤：
1、引入依赖：
&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt; &lt;/dependency&gt; 2、在order-service的启动类添加开启Feign的功能：加注解@EnableFeignClients
3、做声明（编写Feign客户端）：
@FeignClient(&#34;userservice&#34;) //声明出服务名称 public interface UserClient { @GetMapping(&#34;/user/{id}&#34;) User findById(@PathVariable(&#34;id&#34;) Long id); } 主要是基于SpringMVC的注解来声明远程调用的信息，如服务名称、 请求方式、请求路径、请求参数、返回值类型等，直接声明这些信息就行。
这样的方式会简单很多，注解开发太方便了，节约了很多学习成本，即便url的参数很复杂，我们利用注解开发写参数列表也是很方便的。
现在我们可以直接使用这个客户端了，直接修改order查询的接口：
@Resource private OrderMapper orderMapper; @Resource private UserClient userClient; public Order queryOrderById(Long orderId){ //查询订单 Order order = orderMapper.findById(orderId); //根据用户id来查询用户，用Feign实现远程调用 User user = userClient.findById(order.getUserId()); //将用户注入到order中 order.setUser(user); // 4.返回 return order; } 同时多次刷新网址，可以验证出Feign还集成了Ribbon负载均衡，是比较强大的。
总结Feign使用步骤：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/9e918deb9f71e855920ff18c3be6e31c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-17T11:00:52+08:00" />
<meta property="article:modified_time" content="2024-01-17T11:00:52+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">详解SpringCloud微服务技术栈：Feign远程调用、最佳实践、错误排查</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <blockquote> 
 <p>👨‍🎓作者简介：一位大四、研0学生，正在努力准备大四暑假的实习<br> 🌌上期文章：<a href="https://blog.csdn.net/m0_52380556/article/details/135604828?spm=1001.2014.3001.5502">详解SpringCloud微服务技术栈：Nacos配置管理</a><br> 📚订阅专栏：<a href="https://blog.csdn.net/m0_52380556/category_12554499.html?spm=1001.2014.3001.5482">微服务技术全家桶</a><br> 希望文章对你们有所帮助</p> 
</blockquote> 
<p>之前使用RestTemplate来实现远程调用，这种方式存在了一些问题，更优的解决方式是使用Feign来实现远程调用。<br> 这里将会讲解如何用Feign实现远程调用，并进行最佳实践。</p> 
<p></p> 
<div class="toc"> 
 <h4>Feign的远程调用与最佳实践</h4> 
 <ul><li><a href="#Feign_9" rel="nofollow">基于Feign实现远程调用</a></li><li><a href="#_68" rel="nofollow">自定义配置</a></li><li><a href="#_120" rel="nofollow">性能优化</a></li><li><a href="#Feign_155" rel="nofollow">Feign最佳实践</a></li><li><ul><li><a href="#_156" rel="nofollow">分析</a></li><li><a href="#_181" rel="nofollow">实现</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="Feign_9"></a>基于Feign实现远程调用</h2> 
<p>RestTemplate的问题：</p> 
<blockquote> 
 <p>1、代码可读性差，变成体验不统一<br> 2、参数比较复杂的url，难以维护</p> 
</blockquote> 
<p>Feign是一个声明式的http客户端，官方地址：<a href="https://github.com/OpenFeign/feign">Feign官网</a><br> 声明式在Spring中开始提到，是利用配置文件来加事务。而声明式http客户端也是类似，我们只需要把发http请求所需要的信息声明出来即可，剩下的东西都交给Feign来实现。</p> 
<p>使用Feign的步骤：<br> 1、引入依赖：</p> 
<pre><code class="prism language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>
	<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>
	<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-cloud-starter-openfeign<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>
</code></pre> 
<p>2、在order-service的启动类添加开启Feign的功能：加注解@EnableFeignClients<br> 3、做声明（编写Feign客户端）：</p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@FeignClient</span><span class="token punctuation">(</span><span class="token string">"userservice"</span><span class="token punctuation">)</span> <span class="token comment">//声明出服务名称</span>
<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">UserClient</span> <span class="token punctuation">{<!-- --></span>

    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/user/{id}"</span><span class="token punctuation">)</span>
    <span class="token class-name">User</span> <span class="token function">findById</span><span class="token punctuation">(</span><span class="token annotation punctuation">@PathVariable</span><span class="token punctuation">(</span><span class="token string">"id"</span><span class="token punctuation">)</span> <span class="token class-name">Long</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>主要是基于SpringMVC的注解来声明远程调用的信息，如服务名称、 请求方式、请求路径、请求参数、返回值类型等，直接声明这些信息就行。<br> 这样的方式会简单很多，注解开发太方便了，节约了很多学习成本，即便url的参数很复杂，我们利用注解开发写参数列表也是很方便的。</p> 
<p>现在我们可以直接使用这个客户端了，直接修改order查询的接口：</p> 
<pre><code class="prism language-java">    <span class="token annotation punctuation">@Resource</span>
    <span class="token keyword">private</span> <span class="token class-name">OrderMapper</span> orderMapper<span class="token punctuation">;</span>

    <span class="token annotation punctuation">@Resource</span>
    <span class="token keyword">private</span> <span class="token class-name">UserClient</span> userClient<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">Order</span> <span class="token function">queryOrderById</span><span class="token punctuation">(</span><span class="token class-name">Long</span> orderId<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token comment">//查询订单</span>
        <span class="token class-name">Order</span> order <span class="token operator">=</span> orderMapper<span class="token punctuation">.</span><span class="token function">findById</span><span class="token punctuation">(</span>orderId<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//根据用户id来查询用户，用Feign实现远程调用</span>
        <span class="token class-name">User</span> user <span class="token operator">=</span> userClient<span class="token punctuation">.</span><span class="token function">findById</span><span class="token punctuation">(</span>order<span class="token punctuation">.</span><span class="token function">getUserId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//将用户注入到order中</span>
        order<span class="token punctuation">.</span><span class="token function">setUser</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 4.返回</span>
        <span class="token keyword">return</span> order<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> 
<p>同时多次刷新网址，可以验证出Feign还集成了Ribbon负载均衡，是比较强大的。</p> 
<p>总结Feign使用步骤：</p> 
<blockquote> 
 <p>引入依赖<br> 添加@EnableFeignClients注解<br> 编写FeignClient接口<br> 使用FeignClient中定义的方法来代替RestTemplate</p> 
</blockquote> 
<h2><a id="_68"></a>自定义配置</h2> 
<p>Feign可以让我们自定义配置来覆盖默认配置，一般需要配置的是日志级别的类型feign.Logger.Level。<br> 配置Feign日志有2种方式。</p> 
<p><strong>方式一：配置文件</strong><br> 1、全局生效</p> 
<pre><code class="prism language-yaml"><span class="token key atrule">feign</span><span class="token punctuation">:</span>
  <span class="token key atrule">client</span><span class="token punctuation">:</span>
    <span class="token key atrule">config</span><span class="token punctuation">:</span>
      <span class="token key atrule">default</span><span class="token punctuation">:</span>
        <span class="token key atrule">loggerLevel</span><span class="token punctuation">:</span> FULL <span class="token comment"># 最高级别，日志中会包含发起的请求，以及远程调用等信息</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/43/2e/9piGnAZa_o.png" alt="在这里插入图片描述"></p> 
<p>2、局部生效</p> 
<pre><code class="prism language-yaml"><span class="token key atrule">feign</span><span class="token punctuation">:</span>
  <span class="token key atrule">client</span><span class="token punctuation">:</span>
    <span class="token key atrule">config</span><span class="token punctuation">:</span>
      <span class="token key atrule">userservice</span><span class="token punctuation">:</span>
        <span class="token key atrule">loggerLevel</span><span class="token punctuation">:</span> FULL
</code></pre> 
<p><strong>方式二：Java代码</strong><br> 先声明一个Bean：</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DefaultFeignConfiguration</span> <span class="token punctuation">{<!-- --></span>

    <span class="token annotation punctuation">@Bean</span>
    <span class="token keyword">public</span> <span class="token class-name">Logger<span class="token punctuation">.</span>Level</span> <span class="token class-name">LogLevel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token class-name">Logger<span class="token punctuation">.</span>Level</span><span class="token punctuation">.</span><span class="token constant">BASIC</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre> 
<p>想要这个类生效，需要配置。<br> 1、全局配置：把它放到@EnableFeignClients这个注解中：</p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@EnableFeignClients</span><span class="token punctuation">(</span>defaultConfiguration <span class="token operator">=</span> <span class="token class-name">DefaultFeignConfiguration</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>
</code></pre> 
<p>2、局部配置：把它放到@FeignClient这个注解中：</p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@FeignClient</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"userservice"</span><span class="token punctuation">,</span> configuration <span class="token operator">=</span> <span class="token class-name">DefaultFeignConfiguration</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>
</code></pre> 
<p>重启order-service，访问网址后查看控制台的日志，除了SQL语句之外，还有关于Feign的日志信息（只有请求行和相应行）</p> 
<h2><a id="_120"></a>性能优化</h2> 
<p>Feign其实性能一直很不错了，但是还是可以被优化，Feign底层的客户端实现：</p> 
<blockquote> 
 <p>URLConnection：默认实现，不支持连接池<br> Apache HttpClient：支持连接池<br> OKHttp：支持连接池</p> 
</blockquote> 
<p>Feign底层还是会用到其他的客户端，默认使用URLConnection，但是它不支持连接池，这就会使得性能不是太好。因此更推荐使用其他两种。</p> 
<p>Feign的性能优化主要包括：</p> 
<blockquote> 
 <p>使用连接池代替默认的URLConnection<br> 日志级别，最好用BASIC或NONE，日志级别太高也会造成一些性能损耗</p> 
</blockquote> 
<p>将URLConnection换成Apache HttpClient：<br> 1、引入依赖：</p> 
<pre><code class="prism language-xml">	<span class="token comment">&lt;!--引入HttpClient依赖--&gt;</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>io.github.openfeign<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>feign-httpclient<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>
</code></pre> 
<p>2、配置连接池：</p> 
<pre><code class="prism language-yaml"><span class="token key atrule">feign</span><span class="token punctuation">:</span>
  <span class="token key atrule">httpclient</span><span class="token punctuation">:</span>
    <span class="token key atrule">enabled</span><span class="token punctuation">:</span> <span class="token boolean important">true</span> <span class="token comment"># 支持HttpClient的开关</span>
    <span class="token key atrule">max-connections</span><span class="token punctuation">:</span> <span class="token number">200</span> <span class="token comment"># 最大连接数</span>
    <span class="token key atrule">max-connections-per-route</span><span class="token punctuation">:</span> <span class="token number">50</span> <span class="token comment"># 单个路径的最大连接数</span>
</code></pre> 
<p>其中，最大连接数和单个路径最大连接数并不能那么容易确定，具体的连接数需要根据业务的情况，对于不同的业务，可以用jmeter进行压力测试。</p> 
<h2><a id="Feign_155"></a>Feign最佳实践</h2> 
<h3><a id="_156"></a>分析</h3> 
<p>方式一：继承</p> 
<blockquote> 
 <p>给消费者的FeignClient和提供者的controller定义统一的父接口作为标准</p> 
</blockquote> 
<p>乍一看还是有点抽象的，但是我们可以打开一下order-service的UserClient接口与user-service的UserController：<br> <img src="https://images2.imgbox.com/c4/e9/Q8j3zX7M_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/ff/3c/LHrRTgnl_o.png" alt="在这里插入图片描述"><br> 这两个的函数其实是差不多的，因为消费者要通过Feign解析网址请求，就需要带上相应的信息（请求方式、网址、参数等），而提供者则需要提供正确的方式给消费者，因此信息上两者基本上都是差不多的。<br> 所以理论上可以定义一个统一的父接口来作为标准。</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">UserAPI</span><span class="token punctuation">{<!-- --></span>
	<span class="token annotation punctuation">@GetMapping</span>
	<span class="token class-name">User</span> <span class="token function">findById</span><span class="token punctuation">(</span><span class="token annotation punctuation">@PathVariable</span><span class="token punctuation">(</span><span class="token string">"id"</span><span class="token punctuation">)</span> <span class="token class-name">Long</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>而消费者和提供者只需要分别继承和实现这个接口就可以了。<br> 但是这种方式有一定的问题，Spring官方也不推荐让客户端和服务器端共用一个接口，因为这样的耦合度太高了。</p> 
<p>方式二：抽取</p> 
<blockquote> 
 <p>将FeignClient抽取为独立模块，并且把接口有关的pojo、默认的Feign都放到这个模块中，提供给所有消费者使用。</p> 
</blockquote> 
<p>解析一下，在之前的代码中，order-service的UserClient会去调用user-service中的UserController，但是如果还有很多模块的UserClient都要调用，可能就会有很多地方重复写了，因此可以专门定义一个feign-api，在里面声明UserClient，并且涉及到的实体类、默认配置都在feign-api中实现。而order-service要使用的时候，只需要引入feign-api的依赖就可以了。</p> 
<h3><a id="_181"></a>实现</h3> 
<p>这里将会实现方式二，步骤如下：<br> 1、新建module，命名为feign-api，然后引入feign的starter依赖</p> 
<pre><code class="prism language-xml">	<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-cloud-starter-openfeign<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>
</code></pre> 
<p>2、将order-service中编写的UserClient、User、DefaultFeignConfiguration都复制到feign-api项目中<br> <img src="https://images2.imgbox.com/78/d7/7myBpGzH_o.png" alt="在这里插入图片描述"><br> 上面拥有的部分，在order-service里面都可以直接删除了，以后需要直接去用feign-api里面的东西就可以了。</p> 
<p>3、在order-service中引入feign-api的依赖</p> 
<pre><code class="prism language-xml">	<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>
		<span class="token comment">&lt;!--groupId是你创建api的这个module时候的相关包--&gt;</span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>com.wang<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>feign-api<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>1.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>
</code></pre> 
<p>4、修改order-service中的所有与上述组件有关的import部分，改成导入feign-api的包</p> 
<p>5、重启测试</p> 
<p>运行后发现会报错，查看报错信息：<br> <img src="https://images2.imgbox.com/17/f6/o8ITG2K7_o.png" alt="在这里插入图片描述"><br> 没有找到UserClient的对象，但是编译没有报错，只是运行报错了，查看OrderService：<br> <img src="https://images2.imgbox.com/43/e0/FQwEE52U_o.png" alt="在这里插入图片描述"><br> 可以想到，Spring没有获得这个容器的对象，这种情况的发生是因为扫描包出现了问题，只是因为启动类指定的Mapper是在cn.itcast.order下面的，然而UserClient是在cn.itcast.feign下面的。<br> <img src="https://images2.imgbox.com/b4/c7/k5azCOXY_o.png" alt="在这里插入图片描述"><br> 简单粗暴的解决方式是直接把MapperScan扫描范围扩大，但是这肯定是不合适的，启动类应该默认扫描的范围就是所在的包下面的，应该想想别的办法。</p> 
<p>方式一：指定FeignClient所在包（全盘拿来）</p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@EnableFeignClients</span><span class="token punctuation">(</span>basePackages <span class="token operator">=</span> <span class="token string">"cn.itcast.feign.clients"</span><span class="token punctuation">,</span> defaultConfiguration <span class="token operator">=</span> <span class="token class-name">DefaultFeignConfiguration</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>
</code></pre> 
<p>方式二：指定FeignClient字节码（精准定位，推荐方案）</p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@EnableFeignClients</span><span class="token punctuation">(</span>clients <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token class-name">UserClient</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">}</span><span class="token punctuation">,</span> defaultConfiguration <span class="token operator">=</span> <span class="token class-name">DefaultFeignConfiguration</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8e9fa852fc18184bb302ac306414831f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">宏集干货丨探索物联网HMI的端口转发和NAT功能</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4253c2566c9ac013fd852d77f614d879/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">maven环境搭建（打包项目）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>