<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Spring 源码分析衍生篇八 ：ConfigurationClassPostProcessor 下篇 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Spring 源码分析衍生篇八 ：ConfigurationClassPostProcessor 下篇" />
<meta property="og:description" content="文章目录 一、前言1. ConfigurationClassPostProcessor 二、举例三、 代码分析1. enhanceConfigurationClasses1.1 newEnhancer(configClass, classLoader)1.2 createClass(newEnhancer(configClass, classLoader)); 2. 回调函数2.1 BeanMethodInterceptor#intercept2.1.1 enhanceFactoryBean 2.2 BeanFactoryAwareMethodInterceptor#intercept 四、总结 一、前言 本文是 Spring源码分析：Spring源码分析二：BeanFactoryPostProcessor 的处理 的衍生文章。主要是因为本人菜鸡，在分析源码的过程中还有一些其他的内容不理解，故开设衍生篇来完善内容以学习。
ConfigurationClassPostProcessor 的分析受篇幅所限，分为上下两篇
上篇 分析 postProcessBeanDefinitionRegistry 方法的调用。
下篇 分析 postProcessBeanFactory 方法的调用。
ConfigurationClassPostProcessor 是非常重要的一个 后处理器。 ConfigurationClassPostProcessor 完成了 配置类的解析和保存。将所有需要注入的bean解析成 BeanDefinition保存到 BeanFactory 中。
1. ConfigurationClassPostProcessor 首先来讲解一下 ConfigurationClassPostProcessor 的结构图如下。
可见ConfigurationClassPostProcessor 接口实现了BeanDefinitionRegistryPostProcessor(BeanFactory 的后处理器)
PriorityOrdered(设置自己的优先级为最高) 和各种 Aware 接口。
我们这里重点看的是 BeanDefinitionRegistryPostProcessor 接口的两个方法：
// 完成对 @Bean 方法的代理 void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException; // 允许在Spring容器启动后，在下一个阶段开始前，添加BeanDefinition的定义 void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) throws BeansException; 关于这两个方法的调用时机和作用，我们在之前的文章已经讲过，这里不再赘述。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/1899d73587da3ee70629915297838930/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-06-10T21:35:33+08:00" />
<meta property="article:modified_time" content="2020-06-10T21:35:33+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Spring 源码分析衍生篇八 ：ConfigurationClassPostProcessor 下篇</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#_4" rel="nofollow">一、前言</a></li><li><ul><li><a href="#1_ConfigurationClassPostProcessor_19" rel="nofollow">1. ConfigurationClassPostProcessor</a></li></ul> 
  </li><li><a href="#_46" rel="nofollow">二、举例</a></li><li><a href="#__77" rel="nofollow">三、 代码分析</a></li><li><ul><li><a href="#1_enhanceConfigurationClasses_103" rel="nofollow">1. enhanceConfigurationClasses</a></li><li><ul><li><a href="#11_newEnhancerconfigClass_classLoader_213" rel="nofollow">1.1 newEnhancer(configClass, classLoader)</a></li><li><a href="#12__createClassnewEnhancerconfigClass_classLoader_257" rel="nofollow">1.2 createClass(newEnhancer(configClass, classLoader));</a></li></ul> 
   </li><li><a href="#2__295" rel="nofollow">2. 回调函数</a></li><li><ul><li><a href="#21_BeanMethodInterceptorintercept_308" rel="nofollow">2.1 BeanMethodInterceptor#intercept</a></li><li><ul><li><a href="#211_enhanceFactoryBean_361" rel="nofollow">2.1.1 enhanceFactoryBean</a></li></ul> 
    </li><li><a href="#22_BeanFactoryAwareMethodInterceptorintercept_416" rel="nofollow">2.2 BeanFactoryAwareMethodInterceptor#intercept</a></li></ul> 
  </li></ul> 
  </li><li><a href="#_437" rel="nofollow">四、总结</a></li></ul> 
</div> 
<p></p> 
<h2><a id="_4"></a>一、前言</h2> 
<p>本文是 Spring源码分析：<a href="https://blog.csdn.net/qq_36882793/article/details/106447003">Spring源码分析二：BeanFactoryPostProcessor 的处理</a> 的衍生文章。主要是因为本人菜鸡，在分析源码的过程中还有一些其他的内容不理解，故开设衍生篇来完善内容以学习。</p> 
<hr> 
<p><strong>ConfigurationClassPostProcessor 的分析受篇幅所限，分为上下两篇<br> <a href="https://blog.csdn.net/qq_36882793/article/details/106558290">上篇</a> 分析 postProcessBeanDefinitionRegistry 方法的调用。<br> <a href="https://blog.csdn.net/qq_36882793/article/details/106652607">下篇</a> 分析 postProcessBeanFactory 方法的调用。</strong></p> 
<hr> 
<p><strong><code>ConfigurationClassPostProcessor</code> 是非常重要的一个 后处理器。 <code>ConfigurationClassPostProcessor</code> 完成了 配置类的解析和保存。将所有需要注入的bean解析成 BeanDefinition保存到 BeanFactory 中。</strong></p> 
<h3><a id="1_ConfigurationClassPostProcessor_19"></a>1. ConfigurationClassPostProcessor</h3> 
<p>首先来讲解一下 <code>ConfigurationClassPostProcessor</code> 的结构图如下。<br> <img src="https://images2.imgbox.com/db/76/1e3FSakE_o.png" alt="在这里插入图片描述"></p> 
<p>可见<code>ConfigurationClassPostProcessor</code> 接口实现了<code>BeanDefinitionRegistryPostProcessor</code>(BeanFactory 的后处理器)<br> <code>PriorityOrdered</code>(设置自己的优先级为最高) 和各种 Aware 接口。</p> 
<p>我们这里重点看的是 <code>BeanDefinitionRegistryPostProcessor</code> 接口的两个方法：</p> 
<pre><code class="prism language-java"><span class="token comment">// 完成对 @Bean 方法的代理</span>
<span class="token keyword">void</span> <span class="token function">postProcessBeanFactory</span><span class="token punctuation">(</span>ConfigurableListableBeanFactory beanFactory<span class="token punctuation">)</span> <span class="token keyword">throws</span> BeansException<span class="token punctuation">;</span>
<span class="token comment">// 允许在Spring容器启动后，在下一个阶段开始前，添加BeanDefinition的定义</span>
<span class="token keyword">void</span> <span class="token function">postProcessBeanDefinitionRegistry</span><span class="token punctuation">(</span>BeanDefinitionRegistry registry<span class="token punctuation">)</span> <span class="token keyword">throws</span> BeansException<span class="token punctuation">;</span>
</code></pre> 
<p>关于这两个方法的调用时机和作用，我们在之前的文章已经讲过，这里不再赘述。</p> 
<hr> 
<p>上篇 分析了 <code>ConfigurationClassPostProcessor#postProcessBeanDefinitionRegistry</code> 方法。得知了<code>ConfigurationClassPostProcessor</code> 解析配置类(这里的配置类不仅仅局限于<code>@Configuration</code> 注解，还包括 <code>@Import</code>、 <code>@ImportResource</code> 等注解)，将解析到的需要注入到Spring容器中的bean的BeanDefinition保存起来。在后面的bean 初始化都需要BeanDefinition。</p> 
<p>本篇需要分析 <code>ConfigurationClassPostProcessor#postProcessBeanFactory</code> 方法通过cglib代理配置类，来拦截 @Bean修饰的方法。这么做的目的是为了在配置类中多次调用 @Bean 方法返回的是同一个结果。即在下面的代码中 <code>demoController()</code> 和 <code>demoController2()</code> 方法中调用的<code>demoService()</code> 方法返回的结果是同一个值。避免了单例模式下的多例创建。我们可以通过下面一个例子来看一看</p> 
<h2><a id="_46"></a>二、举例</h2> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@Configuration</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DemoConfig</span> <span class="token punctuation">{<!-- --></span>
    <span class="token annotation punctuation">@Bean</span>
    <span class="token keyword">public</span> DemoService <span class="token function">demoService</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">DemoServiceImpl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token annotation punctuation">@Bean</span>
    <span class="token keyword">public</span> DemoController <span class="token function">demoController</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"demoController : "</span> <span class="token operator">+</span>  <span class="token function">demoService</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">DemoController</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token annotation punctuation">@Bean</span><span class="token punctuation">(</span><span class="token string">"demoController2"</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> DemoController <span class="token function">demoController2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"demoController2222 : "</span> <span class="token operator">+</span>  <span class="token function">demoService</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">DemoController</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>上面的代码输出结果是什么？<br> <img src="https://images2.imgbox.com/e0/43/oy4w4z34_o.png" alt="在这里插入图片描述"></p> 
<p>我们看到两个方法里调用 <code>demoService()</code> 方法返回的是同一个实例，但是按照我们传统的逻辑，这里调用 <code>demoService()</code> 应该是重新创建了 一个 DemoServiceImpl 实例，应该不一样的。这里就是因为<code>ConfigurationClassPostProcessor#postProcessBeanFactory</code> 方法通过代理实现了该效果，以保证正确语义。</p> 
<p>PS： <strong>如果使用 @Component 注解修饰 DemoConfig 。则两次 demoService() 方法返回的结果则不相同。，因为被 @Component 注解修饰的bean并不会调用 <code>ConfigurationClassPostProcessor#postProcessBeanFactory</code> 方法来进行方法代理。</strong></p> 
<p>具体原因，即使因为在 <code>postProcessBeanFactory</code> 方法中对 Full 类型(即被 <code>@Configuration</code> 修饰的配置类)的配置类进行了动态代理。</p> 
<h2><a id="__77"></a>三、 代码分析</h2> 
<p><code>postProcessBeanFactory</code> 方法代码如下(相较于 <code>postProcessBeanDefinitionRegistry</code> 方法真是简单太多了)：</p> 
<pre><code class="prism language-java">	<span class="token annotation punctuation">@Override</span>
	<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">postProcessBeanFactory</span><span class="token punctuation">(</span>ConfigurableListableBeanFactory beanFactory<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">int</span> factoryId <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">identityHashCode</span><span class="token punctuation">(</span>beanFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token comment">// 判断是否已经在处理</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>factoriesPostProcessed<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>factoryId<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span>
					<span class="token string">"postProcessBeanFactory already called on this post-processor against "</span> <span class="token operator">+</span> beanFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">this</span><span class="token punctuation">.</span>factoriesPostProcessed<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>factoryId<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>registriesPostProcessed<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>factoryId<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token comment">// BeanDefinitionRegistryPostProcessor hook apparently not supported...</span>
			<span class="token comment">// Simply call processConfigurationClasses lazily at this point then.</span>
			<span class="token function">processConfigBeanDefinitions</span><span class="token punctuation">(</span><span class="token punctuation">(</span>BeanDefinitionRegistry<span class="token punctuation">)</span> beanFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		<span class="token function">enhanceConfigurationClasses</span><span class="token punctuation">(</span>beanFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>
		beanFactory<span class="token punctuation">.</span><span class="token function">addBeanPostProcessor</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ImportAwareBeanPostProcessor</span><span class="token punctuation">(</span>beanFactory<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
</code></pre> 
<p>可以看到关键代码为 <code>enhanceConfigurationClasses(beanFactory);</code>。下面开始就来看看<code>enhanceConfigurationClasses</code> 方法</p> 
<h3><a id="1_enhanceConfigurationClasses_103"></a>1. enhanceConfigurationClasses</h3> 
<p><code>enhanceConfigurationClasses</code> 方法用于增强配置类。Spring会对 Full Configuration （即被 <code>@Configuration</code> 修饰的配置类）进行代理，拦截<code>@Bean</code>方法，以确保正确处理<code>@Bean</code>语义。这个增强的代理类就是在<code>enhanceConfigurationClasses(beanFactory)</code>方法中产生的。</p> 
<p>由于篇幅所限，这里等后续有机会再详细解析。这一部分的解析可以参考 ： <a href="https://segmentfault.com/a/1190000020633405?utm_source=tag-newest" rel="nofollow">https://segmentfault.com/a/1190000020633405?utm_source=tag-newest</a></p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">enhanceConfigurationClasses</span><span class="token punctuation">(</span>ConfigurableListableBeanFactory beanFactory<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		Map<span class="token generics function"><span class="token punctuation">&lt;</span>String<span class="token punctuation">,</span> AbstractBeanDefinition<span class="token punctuation">&gt;</span></span> configBeanDefs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedHashMap</span><span class="token operator">&lt;</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span>String beanName <span class="token operator">:</span> beanFactory<span class="token punctuation">.</span><span class="token function">getBeanDefinitionNames</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			BeanDefinition beanDef <span class="token operator">=</span> beanFactory<span class="token punctuation">.</span><span class="token function">getBeanDefinition</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token comment">// 获取 CONFIGURATION_CLASS_ATTRIBUTE属性，如果不为null，则是配置类，在上篇中有过交代(可能是full或者lite类型)</span>
			Object configClassAttr <span class="token operator">=</span> beanDef<span class="token punctuation">.</span><span class="token function">getAttribute</span><span class="token punctuation">(</span>ConfigurationClassUtils<span class="token punctuation">.</span>CONFIGURATION_CLASS_ATTRIBUTE<span class="token punctuation">)</span><span class="token punctuation">;</span>
			MethodMetadata methodMetadata <span class="token operator">=</span> null<span class="token punctuation">;</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>beanDef <span class="token keyword">instanceof</span> <span class="token class-name">AnnotatedBeanDefinition</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				methodMetadata <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>AnnotatedBeanDefinition<span class="token punctuation">)</span> beanDef<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getFactoryMethodMetadata</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			<span class="token comment">// 如果是配置类(configClassAttr  != null) || @Bean注解派生的方法(methodMetadata != null 不为空表示 FactoryMethod不为空，则可以说明是 @Bean 生成的 BeanDefinition)</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>configClassAttr <span class="token operator">!=</span> null <span class="token operator">||</span> methodMetadata <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> beanDef <span class="token keyword">instanceof</span> <span class="token class-name">AbstractBeanDefinition</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				<span class="token comment">// Configuration class (full or lite) or a configuration-derived @Bean method</span>
				<span class="token comment">// -&gt; resolve bean class at this point...</span>
				AbstractBeanDefinition abd <span class="token operator">=</span> <span class="token punctuation">(</span>AbstractBeanDefinition<span class="token punctuation">)</span> beanDef<span class="token punctuation">;</span>
				<span class="token comment">// 这里判断如果指定的 bean(注意并非这里的abd，而是abd所要生成的bean) 如果不是 Class类型则进入 if里面</span>
				<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>abd<span class="token punctuation">.</span><span class="token function">hasBeanClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
					<span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
						<span class="token comment">// 解析 beanClass，即获取这个 Bean 的Class 并保存到 abd中</span>
						abd<span class="token punctuation">.</span><span class="token function">resolveBeanClass</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>beanClassLoader<span class="token punctuation">)</span><span class="token punctuation">;</span>
					<span class="token punctuation">}</span>
					<span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
						<span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span>
								<span class="token string">"Cannot load configuration class: "</span> <span class="token operator">+</span> beanDef<span class="token punctuation">.</span><span class="token function">getBeanClassName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> ex<span class="token punctuation">)</span><span class="token punctuation">;</span>
					<span class="token punctuation">}</span>
				<span class="token punctuation">}</span>
			<span class="token punctuation">}</span>
			<span class="token comment">// 对 FUll的 配置类进行处理！！！</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>ConfigurationClassUtils<span class="token punctuation">.</span>CONFIGURATION_CLASS_FULL<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>configClassAttr<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				<span class="token comment">// 对非AbstractBeanDefinition子类的情况直接抛出异常</span>
				<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>beanDef <span class="token keyword">instanceof</span> <span class="token class-name">AbstractBeanDefinition</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
					<span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">BeanDefinitionStoreException</span><span class="token punctuation">(</span><span class="token string">"Cannot enhance @Configuration bean definition '"</span> <span class="token operator">+</span>
							beanName <span class="token operator">+</span> <span class="token string">"' since it is not stored in an AbstractBeanDefinition subclass"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
				<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>logger<span class="token punctuation">.</span><span class="token function">isInfoEnabled</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> beanFactory<span class="token punctuation">.</span><span class="token function">containsSingleton</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
					logger<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"Cannot enhance @Configuration bean definition '"</span> <span class="token operator">+</span> beanName <span class="token operator">+</span>
							<span class="token string">"' since its singleton instance has been created too early. The typical cause "</span> <span class="token operator">+</span>
							<span class="token string">"is a non-static @Bean method with a BeanDefinitionRegistryPostProcessor "</span> <span class="token operator">+</span>
							<span class="token string">"return type: Consider declaring such methods as 'static'."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
				<span class="token comment">// 保存下来，准备代理</span>
				configBeanDefs<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> <span class="token punctuation">(</span>AbstractBeanDefinition<span class="token punctuation">)</span> beanDef<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
		<span class="token comment">// 如果没有找到 full 配置类，则说明不需要代理增强，则直接返回。</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>configBeanDefs<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token comment">// nothing to enhance -&gt; return immediately</span>
			<span class="token keyword">return</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token comment">// 创建增强对象</span>
		ConfigurationClassEnhancer enhancer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConfigurationClassEnhancer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token comment">// 进行配置类增强。这里的增强实际上是通过cglib对配置类进行了代理。</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span>Map<span class="token punctuation">.</span>Entry<span class="token generics function"><span class="token punctuation">&lt;</span>String<span class="token punctuation">,</span> AbstractBeanDefinition<span class="token punctuation">&gt;</span></span> entry <span class="token operator">:</span> configBeanDefs<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			AbstractBeanDefinition beanDef <span class="token operator">=</span> entry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token comment">// If a @Configuration class gets proxied, always proxy the target class</span>
			<span class="token comment">// 设置 ：如果配置类被代理，则该 bean也需要一直代理</span>
			beanDef<span class="token punctuation">.</span><span class="token function">setAttribute</span><span class="token punctuation">(</span>AutoProxyUtils<span class="token punctuation">.</span>PRESERVE_TARGET_CLASS_ATTRIBUTE<span class="token punctuation">,</span> Boolean<span class="token punctuation">.</span>TRUE<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token comment">// Set enhanced subclass of the user-specified bean class</span>
			<span class="token comment">// 获取bean的 Class 类</span>
			Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">&gt;</span> configClass <span class="token operator">=</span> beanDef<span class="token punctuation">.</span><span class="token function">getBeanClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token comment">// 生成代理类</span>
			Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">&gt;</span> enhancedClass <span class="token operator">=</span> enhancer<span class="token punctuation">.</span><span class="token function">enhance</span><span class="token punctuation">(</span>configClass<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>beanClassLoader<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>configClass <span class="token operator">!=</span> enhancedClass<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				<span class="token keyword">if</span> <span class="token punctuation">(</span>logger<span class="token punctuation">.</span><span class="token function">isTraceEnabled</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
					logger<span class="token punctuation">.</span><span class="token function">trace</span><span class="token punctuation">(</span>String<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"Replacing bean definition '%s' existing class '%s' with "</span> <span class="token operator">+</span>
							<span class="token string">"enhanced class '%s'"</span><span class="token punctuation">,</span> entry<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> configClass<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> enhancedClass<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
				 <span class="token comment">//将BeanClass设置为增强后的类</span>
				beanDef<span class="token punctuation">.</span><span class="token function">setBeanClass</span><span class="token punctuation">(</span>enhancedClass<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
</code></pre> 
<p>我们可以看到关键代码在于</p> 
<pre><code class="prism language-java">Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">&gt;</span> enhancedClass <span class="token operator">=</span> enhancer<span class="token punctuation">.</span><span class="token function">enhance</span><span class="token punctuation">(</span>configClass<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>beanClassLoader<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>首先我们来看</p> 
<pre><code class="prism language-java">	<span class="token comment">// 加载指定的类并为其生成一个CGLIB子类，该子类配备了能够识别作用域和其他bean语义的容器感知回调。</span>
	<span class="token keyword">public</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">&gt;</span> <span class="token function">enhance</span><span class="token punctuation">(</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">&gt;</span> configClass<span class="token punctuation">,</span> <span class="token annotation punctuation">@Nullable</span> ClassLoader classLoader<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token comment">// 如果是 EnhancedConfiguration子类，则说明已经被增强(代理),直接返回</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>EnhancedConfiguration<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">isAssignableFrom</span><span class="token punctuation">(</span>configClass<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> 忽略日志打印
			<span class="token keyword">return</span> configClass<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token comment">// 创建代理类</span>
		Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">&gt;</span> enhancedClass <span class="token operator">=</span> <span class="token function">createClass</span><span class="token punctuation">(</span><span class="token function">newEnhancer</span><span class="token punctuation">(</span>configClass<span class="token punctuation">,</span> classLoader<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>logger<span class="token punctuation">.</span><span class="token function">isTraceEnabled</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			logger<span class="token punctuation">.</span><span class="token function">trace</span><span class="token punctuation">(</span>String<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"Successfully enhanced %s; enhanced class name is: %s"</span><span class="token punctuation">,</span>
					configClass<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> enhancedClass<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">return</span> enhancedClass<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
</code></pre> 
<p>接下来我们需要看 <code>Class&lt;?&gt; enhancedClass = createClass(newEnhancer(configClass, classLoader));</code>。我们先来看其中的 <code>newEnhancer(configClass, classLoader)</code> 方法</p> 
<h4><a id="11_newEnhancerconfigClass_classLoader_213"></a>1.1 newEnhancer(configClass, classLoader)</h4> 
<p>动态代理参考<a href="https://segmentfault.com/a/1190000020633405?utm_source=tag-newest" rel="nofollow">https://segmentfault.com/a/1190000020633405?utm_source=tag-newest</a>：<br> 回调过滤器部分： <a href="https://blog.csdn.net/iteye_13303/article/details/82640029">https://blog.csdn.net/iteye_13303/article/details/82640029</a></p> 
<hr> 
<p>这里创建了一个 Cglib 代理的实例</p> 
<pre><code class="prism language-java">
	<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> ConditionalCallbackFilter CALLBACK_FILTER <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConditionalCallbackFilter</span><span class="token punctuation">(</span>CALLBACKS<span class="token punctuation">)</span><span class="token punctuation">;</span>


<span class="token keyword">private</span> Enhancer <span class="token function">newEnhancer</span><span class="token punctuation">(</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">&gt;</span> configSuperClass<span class="token punctuation">,</span> <span class="token annotation punctuation">@Nullable</span> ClassLoader classLoader<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// Spring重新打包了CGLIB（使用Spring专用补丁;仅供内部使用）</span>
    <span class="token comment">// 这样可避免在应用程序级别或第三方库和框架上与CGLIB的依赖性发生任何潜在冲突</span>
    <span class="token comment">// https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/cglib/package-summary.html</span>
    Enhancer enhancer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Enhancer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    enhancer<span class="token punctuation">.</span><span class="token function">setSuperclass</span><span class="token punctuation">(</span>configSuperClass<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 设置需要实现的接口,也就是说,我们的配置类的cglib代理还实现的 EnhancedConfiguration 接口</span>
    enhancer<span class="token punctuation">.</span><span class="token function">setInterfaces</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Class</span><span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">&gt;</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{<!-- --></span>EnhancedConfiguration<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    enhancer<span class="token punctuation">.</span><span class="token function">setUseFactory</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 设置命名策略</span>
    enhancer<span class="token punctuation">.</span><span class="token function">setNamingPolicy</span><span class="token punctuation">(</span>SpringNamingPolicy<span class="token punctuation">.</span>INSTANCE<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 设置生成器创建字节码策略</span>
    <span class="token comment">// BeanFactoryAwareGeneratorStrategy 是 CGLIB的DefaultGeneratorStrategy的自定义扩展，主要为了引入BeanFactory字段</span>
    enhancer<span class="token punctuation">.</span><span class="token function">setStrategy</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">BeanFactoryAwareGeneratorStrategy</span><span class="token punctuation">(</span>classLoader<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 设置回调过滤器。通过其，可以设置对不同方法执行不同的回调逻辑，或者根本不执行回调。</span>
    enhancer<span class="token punctuation">.</span><span class="token function">setCallbackFilter</span><span class="token punctuation">(</span>CALLBACK_FILTER<span class="token punctuation">)</span><span class="token punctuation">;</span>
    enhancer<span class="token punctuation">.</span><span class="token function">setCallbackTypes</span><span class="token punctuation">(</span>CALLBACK_FILTER<span class="token punctuation">.</span><span class="token function">getCallbackTypes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> enhancer<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>这里的Enhancer对象是<code>org.springframework.cglib.proxy.Enhancer</code>，那它和cglib是什么关系呢？<br> 大致就是说，Spring重新打包了CGLIB（使用Spring专用补丁，仅供内部使用） ，这样可避免在应用程序级别或第三方库和框架上与CGLIB的依赖性发生任何潜在冲突。</p> 
<p>那具体做了哪些增强呢？</p> 
<ul><li>实现<code>EnhancedConfiguration</code>接口。这是一个空的标志接口，仅由Spring框架内部使用，并且由所有<code>@ConfigurationCGLIB</code>子类实现，该接口继承了BeanFactoryAware接口。</li><li>设置了命名策略</li><li>设置生成器创建字节码的策略。<code>BeanFactoryAwareGeneratorStrategy</code>继承了cglib的<code>DefaultGeneratorStrategy</code>，其主要作用是为了让子类引入BeanFactory字段和设置ClassLoader。</li><li>设置增强Callback：</li></ul> 
<h4><a id="12__createClassnewEnhancerconfigClass_classLoader_257"></a>1.2 createClass(newEnhancer(configClass, classLoader));</h4> 
<p>这里是真正创建了一个代理对象了。</p> 
<pre><code class="prism language-java">	<span class="token keyword">private</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">&gt;</span> <span class="token function">createClass</span><span class="token punctuation">(</span>Enhancer enhancer<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">&gt;</span> subclass <span class="token operator">=</span> enhancer<span class="token punctuation">.</span><span class="token function">createClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token comment">// Registering callbacks statically (as opposed to thread-local)</span>
		<span class="token comment">// is critical for usage in an OSGi environment (SPR-5932)...</span>
		<span class="token comment">// 指定代理回调 为 CALLBACKS</span>
		Enhancer<span class="token punctuation">.</span><span class="token function">registerStaticCallbacks</span><span class="token punctuation">(</span>subclass<span class="token punctuation">,</span> CALLBACKS<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> subclass<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
</code></pre> 
<p><code>Enhancer.registerStaticCallbacks(subclass, CALLBACKS);</code> 调用了 <code>setCallbacksHelper</code> 方法。</p> 
<pre><code class="prism language-java">	<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">setCallbacksHelper</span><span class="token punctuation">(</span>Class <span class="token class-name">type</span><span class="token punctuation">,</span> Callback<span class="token punctuation">[</span><span class="token punctuation">]</span> callbacks<span class="token punctuation">,</span> String methodName<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token comment">// TODO: optimize</span>
		<span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
			<span class="token comment">// 反射调用方法，并将回调函数传入。</span>
			Method setter <span class="token operator">=</span> <span class="token function">getCallbacksSetter</span><span class="token punctuation">(</span>type<span class="token punctuation">,</span> methodName<span class="token punctuation">)</span><span class="token punctuation">;</span>
			setter<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>null<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{<!-- --></span>callbacks<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">NoSuchMethodException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span>type <span class="token operator">+</span> <span class="token string">" is not an enhanced class"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IllegalAccessException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">CodeGenerationException</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InvocationTargetException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">CodeGenerationException</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
</code></pre> 
<p>这里我们可以知道，<strong>这里创建了一个 @Bean 生成的 对象 的增强代理，同时通过 <code>ConditionalCallbackFilter</code> 的回调过滤器和指定的回调函数<code>CALLBACKS</code>，完成了增强的过程。</strong></p> 
<p>但是对于我们，我们还需要看一下回调函数 <code>CALLBACKS</code>中完成了什么操作。</p> 
<h3><a id="2__295"></a>2. 回调函数</h3> 
<p><code>CALLBACKS</code> 定义如下。</p> 
<pre><code class="prism language-java">	<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Callback<span class="token punctuation">[</span><span class="token punctuation">]</span> CALLBACKS <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Callback</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{<!-- --></span>
			<span class="token comment">// 拦截@Bean方法的调用，以确保正确处理@Bean语义</span>
			<span class="token keyword">new</span> <span class="token class-name">BeanMethodInterceptor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
			<span class="token comment">// BeanFactoryAware#setBeanFactory的调用，用于获取BeanFactory对象</span>
			<span class="token keyword">new</span> <span class="token class-name">BeanFactoryAwareMethodInterceptor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
			NoOp<span class="token punctuation">.</span>INSTANCE
	<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>下面我们来看看两个拦截器的拦截方法</p> 
<h4><a id="21_BeanMethodInterceptorintercept_308"></a>2.1 BeanMethodInterceptor#intercept</h4> 
<pre><code class="prism language-java">	<span class="token keyword">public</span> Object <span class="token function">intercept</span><span class="token punctuation">(</span>Object enhancedConfigInstance<span class="token punctuation">,</span> Method beanMethod<span class="token punctuation">,</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> beanMethodArgs<span class="token punctuation">,</span>
				MethodProxy cglibMethodProxy<span class="token punctuation">)</span> <span class="token keyword">throws</span> Throwable <span class="token punctuation">{<!-- --></span>
		<span class="token comment">// 获取beanFactory</span>
		ConfigurableBeanFactory beanFactory <span class="token operator">=</span> <span class="token function">getBeanFactory</span><span class="token punctuation">(</span>enhancedConfigInstance<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token comment">// 根据从配置类中的方法获取beanName</span>
		String beanName <span class="token operator">=</span> BeanAnnotationHelper<span class="token punctuation">.</span><span class="token function">determineBeanNameFor</span><span class="token punctuation">(</span>beanMethod<span class="token punctuation">)</span><span class="token punctuation">;</span>

		<span class="token comment">// Determine whether this bean is a scoped-proxy</span>
		<span class="token comment">// 确定此bean是否为作用域代理。即判断是否包含 @Scope注解，并且其属性 proxyMode 不为  ScopedProxyMode.NO。</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>BeanAnnotationHelper<span class="token punctuation">.</span><span class="token function">isScopedProxy</span><span class="token punctuation">(</span>beanMethod<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			String scopedBeanName <span class="token operator">=</span> ScopedProxyCreator<span class="token punctuation">.</span><span class="token function">getTargetBeanName</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>beanFactory<span class="token punctuation">.</span><span class="token function">isCurrentlyInCreation</span><span class="token punctuation">(</span>scopedBeanName<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				beanName <span class="token operator">=</span> scopedBeanName<span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
		<span class="token comment">// 官方注释 ： 要处理Bean间方法引用，我们必须显式检查容器中是否已缓存实例。首先，检查所请求的bean是否为FactoryBean。</span>
		<span class="token comment">//如果是这样，则创建一个子类代理，以拦截对getObject（）的调用并返回所有缓存的Bean实例。</span>
		<span class="token comment">//这样可以确保从@Bean方法中调用FactoryBean的语义与在XML中引用FactoryBean的语义相同</span>
		
		<span class="token comment">// 判断当前BeanFactory 中是否 存在当前bean的FactoryBean实例 &amp;&amp; 包含bean实例 。说白了就是检查容器中是否已经存在该bean 的缓存实例，如果存在需要进行代理</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">factoryContainsBean</span><span class="token punctuation">(</span>beanFactory<span class="token punctuation">,</span> BeanFactory<span class="token punctuation">.</span>FACTORY_BEAN_PREFIX <span class="token operator">+</span> beanName<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
				<span class="token function">factoryContainsBean</span><span class="token punctuation">(</span>beanFactory<span class="token punctuation">,</span> beanName<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token comment">// 获取bean对应 FactoryBean 实例。对FactoryBean进行代理</span>
			Object factoryBean <span class="token operator">=</span> beanFactory<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span>BeanFactory<span class="token punctuation">.</span>FACTORY_BEAN_PREFIX <span class="token operator">+</span> beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>factoryBean <span class="token keyword">instanceof</span> <span class="token class-name">ScopedProxyFactoryBean</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				<span class="token comment">// Scoped proxy factory beans are a special case and should not be further proxied</span>
				<span class="token comment">//范围限定的代理工厂bean是一种特殊情况，不应进一步进行代理</span>
			<span class="token punctuation">}</span>
			<span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
				<span class="token comment">// It is a candidate FactoryBean - go ahead with enhancement</span>
				<span class="token comment">// 它是候选FactoryBean-继续进行增强</span>
				<span class="token keyword">return</span> <span class="token function">enhanceFactoryBean</span><span class="token punctuation">(</span>factoryBean<span class="token punctuation">,</span> beanMethod<span class="token punctuation">.</span><span class="token function">getReturnType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> beanFactory<span class="token punctuation">,</span> beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
		<span class="token comment">// 这里是我们一般的逻辑，</span>
		<span class="token comment">// isCurrentlyInvokedFactoryMethod 判断的是，是否是Spring容器自己调用@Bean 方法而并非我们自己编写代码调用。如果是Spring直接调用真正的@Bean方法，这时候多次调用返回的并非同一实例</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isCurrentlyInvokedFactoryMethod</span><span class="token punctuation">(</span>beanMethod<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token comment">// 工厂正在调用bean方法以便实例化和注册bean（即通过getBean（）调用）-&gt;调用该方法的超级实现以实际创建bean实例。</span>
			<span class="token comment">// 这里调用的就是未被增强的 @Bean 方法</span>
			<span class="token keyword">return</span> cglibMethodProxy<span class="token punctuation">.</span><span class="token function">invokeSuper</span><span class="token punctuation">(</span>enhancedConfigInstance<span class="token punctuation">,</span> beanMethodArgs<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token comment">// 返回cglib 代理后的实例。如果没有创建则创建</span>
		<span class="token keyword">return</span> <span class="token function">resolveBeanReference</span><span class="token punctuation">(</span>beanMethod<span class="token punctuation">,</span> beanMethodArgs<span class="token punctuation">,</span> beanFactory<span class="token punctuation">,</span> beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

</code></pre> 
<h5><a id="211_enhanceFactoryBean_361"></a>2.1.1 enhanceFactoryBean</h5> 
<p>该方法是对 FactoryBean 进行动态代理。</p> 
<p>这里注意：对于 <code>FactoryBean</code>的类型的处理，首先判断了类或者<code>getObject</code> 方法是否是终态(被<code>final</code> 修饰)，因为cglib 代理是通过继承代理类来实现的代理,所以这里如果是终态则无法代理。如果方法返回类型是接口，则说明是多态，可以使用实现接口的方式来进行代理。也就说在这个方法里面根据是否@Bean 方法是否是接口方法来选择使用 Cglib代理和 Jdk动态代理两种方式。</p> 
<p>关于 FactoryBean 的介绍，请移步:<a href="https://blog.csdn.net/qq_36882793/article/details/105748071">Spring 源码分析衍生篇一：FactoryBean介绍</a></p> 
<pre><code class="prism language-java">	<span class="token keyword">private</span> Object <span class="token function">enhanceFactoryBean</span><span class="token punctuation">(</span><span class="token keyword">final</span> Object factoryBean<span class="token punctuation">,</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">&gt;</span> exposedType<span class="token punctuation">,</span>
			<span class="token keyword">final</span> ConfigurableBeanFactory beanFactory<span class="token punctuation">,</span> <span class="token keyword">final</span> String beanName<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>

		<span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
			Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">&gt;</span> clazz <span class="token operator">=</span> factoryBean<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">boolean</span> finalClass <span class="token operator">=</span> Modifier<span class="token punctuation">.</span><span class="token function">isFinal</span><span class="token punctuation">(</span>clazz<span class="token punctuation">.</span><span class="token function">getModifiers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">boolean</span> finalMethod <span class="token operator">=</span> Modifier<span class="token punctuation">.</span><span class="token function">isFinal</span><span class="token punctuation">(</span>clazz<span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span><span class="token string">"getObject"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getModifiers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token comment">// 判断，如果类是 final修饰 ||  getObject 方法被final 修饰</span>
			<span class="token comment">// 因为 cglib 代理是通过创建一个类继承代理类实现，所以这里如果被final修饰就要另谋处理</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>finalClass <span class="token operator">||</span> finalMethod<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				<span class="token comment">// 如果方法的返回类型是接口，则说明使用了多态</span>
				<span class="token comment">// 则可以创建一个接口的实现类来代理FactoryBean</span>
				<span class="token keyword">if</span> <span class="token punctuation">(</span>exposedType<span class="token punctuation">.</span><span class="token function">isInterface</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
					
					<span class="token keyword">return</span> <span class="token function">createInterfaceProxyForFactoryBean</span><span class="token punctuation">(</span>factoryBean<span class="token punctuation">,</span> exposedType<span class="token punctuation">,</span> beanFactory<span class="token punctuation">,</span> beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
				<span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
					<span class="token comment">// 如果不是，则没办法进行代理，直接返回FactoryBean。</span>
					<span class="token keyword">return</span> factoryBean<span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">NoSuchMethodException</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token comment">// No getObject() method -&gt; shouldn't happen, but as long as nobody is trying to call it...</span>
		<span class="token punctuation">}</span>
		<span class="token comment">// 直接进行代理</span>
		<span class="token keyword">return</span> <span class="token function">createCglibProxyForFactoryBean</span><span class="token punctuation">(</span>factoryBean<span class="token punctuation">,</span> beanFactory<span class="token punctuation">,</span> beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
	<span class="token comment">// 创建 JDK动态代理</span>
	<span class="token keyword">private</span> Object <span class="token function">createInterfaceProxyForFactoryBean</span><span class="token punctuation">(</span><span class="token keyword">final</span> Object factoryBean<span class="token punctuation">,</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">&gt;</span> interfaceType<span class="token punctuation">,</span>
			<span class="token keyword">final</span> ConfigurableBeanFactory beanFactory<span class="token punctuation">,</span> <span class="token keyword">final</span> String beanName<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token comment">// 可以看到，实际上代理的是 FactoryBean 的 getObject 方法</span>
		<span class="token keyword">return</span> Proxy<span class="token punctuation">.</span><span class="token function">newProxyInstance</span><span class="token punctuation">(</span>
				factoryBean<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Class</span><span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">&gt;</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{<!-- --></span>interfaceType<span class="token punctuation">}</span><span class="token punctuation">,</span>
				<span class="token punctuation">(</span>proxy<span class="token punctuation">,</span> method<span class="token punctuation">,</span> args<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token punctuation">{<!-- --></span>
					<span class="token keyword">if</span> <span class="token punctuation">(</span>method<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"getObject"</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> args <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
						<span class="token keyword">return</span> beanFactory<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>
					<span class="token punctuation">}</span>
					<span class="token keyword">return</span> ReflectionUtils<span class="token punctuation">.</span><span class="token function">invokeMethod</span><span class="token punctuation">(</span>method<span class="token punctuation">,</span> factoryBean<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
</code></pre> 
<h4><a id="22_BeanFactoryAwareMethodInterceptorintercept_416"></a>2.2 BeanFactoryAwareMethodInterceptor#intercept</h4> 
<p><code>BeanFactoryAwareMethodInterceptor#intercept</code> 代码很简单，如下</p> 
<pre><code class="prism language-java">		<span class="token annotation punctuation">@Override</span>
		<span class="token annotation punctuation">@Nullable</span>
		<span class="token keyword">public</span> Object <span class="token function">intercept</span><span class="token punctuation">(</span>Object obj<span class="token punctuation">,</span> Method method<span class="token punctuation">,</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">,</span> MethodProxy proxy<span class="token punctuation">)</span> <span class="token keyword">throws</span> Throwable <span class="token punctuation">{<!-- --></span>
			<span class="token comment">// 获取 obj中的 “$$beanFactory” 属性(BEAN_FACTORY_FIELD 即为 "$$beanFactory")</span>
			Field field <span class="token operator">=</span> ReflectionUtils<span class="token punctuation">.</span><span class="token function">findField</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> BEAN_FACTORY_FIELD<span class="token punctuation">)</span><span class="token punctuation">;</span>
			Assert<span class="token punctuation">.</span><span class="token function">state</span><span class="token punctuation">(</span>field <span class="token operator">!=</span> null<span class="token punctuation">,</span> <span class="token string">"Unable to find generated BeanFactory field"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token comment">// 将参数 arg[0] 设置给 Obj 的 "$$beanFactory" 属性</span>
			field<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> args<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

			<span class="token comment">// Does the actual (non-CGLIB) superclass implement BeanFactoryAware?</span>
			<span class="token comment">// If so, call its setBeanFactory() method. If not, just exit.</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>BeanFactoryAware<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">isAssignableFrom</span><span class="token punctuation">(</span>ClassUtils<span class="token punctuation">.</span><span class="token function">getUserClass</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getSuperclass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				<span class="token keyword">return</span> proxy<span class="token punctuation">.</span><span class="token function">invokeSuper</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			<span class="token keyword">return</span> null<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
</code></pre> 
<h2><a id="_437"></a>四、总结</h2> 
<ol><li><code>@Bean</code> 在<code>@Component</code> 中 是多例的原因？<br> 因为 <code>ConfigurationClassPostProcessor</code> 方法中 只对 <code>full</code> 类型的配置类(即被 <code>@Configuration</code> 注解修饰)进行了代理，因此被 <code>@Component</code> 修饰的类并不会被代理，自然也就不会保持单例。</li><li><code>ConfigurationClassPostProcessor#postProcessBeanFactory</code> 方法完成了对 <code>full</code> 类型的配置类(即被 <code>@Configuration</code> 注解修饰)进行了代理 保证了语义的正确性。</li></ol> 
<hr> 
<p><strong>以上：内容部分参考<br> 《Spring源码深度解析》<br> <a href="https://segmentfault.com/a/1190000020633405?utm_source=tag-newest" rel="nofollow">https://segmentfault.com/a/1190000020633405?utm_source=tag-newest</a><br> 如有侵扰，联系删除。 内容仅用于自我记录学习使用。如有错误，欢迎指正</strong></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5246ebf2003c2bee2a9686f9e7a9ca8d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Spring 源码分析衍生篇七 ：ConfigurationClassPostProcessor 上篇</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/12b6bcd0bc53b99845e9e35630eb3da0/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">请将文件MP_verify_xxxxxx.txt上传至填写域名或路径指向的web服务器（或虚拟主机）的目录 已解决</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>