<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>js解leetcode(82)-中等 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="js解leetcode(82)-中等" />
<meta property="og:description" content="1.困于环中的机器人 题目：
在无限的平面上，机器人最初位于 (0, 0) 处，面朝北方。机器人可以接受下列三条指令之一：
&#34;G&#34;：直走 1 个单位&#34;L&#34;：左转 90 度&#34;R&#34;：右转 90 度 机器人按顺序执行指令 instructions，并一直重复它们。
只有在平面中存在环使得机器人永远无法离开时，返回 true。否则，返回 false。
思路：明确一点：如果执行完一轮指令之后，方向不是朝北，或者回到原点，那么都会成环。
回到原点不多说。方向不是朝北呢？其实就是，如果方向不是朝北，那么后续的路径是绕着原点中心对称的。所以肯定成环
所以执行完一轮命令之后判断方向和位置即可
时间复杂度O(n)，空间复杂度O(1)
/** * @param {string} instructions * @return {boolean} */ var isRobotBounded = function(instructions) { let dir = 0; const position = [0, 0]; const vmap = { 0: 1, 1: 1, 2: -1, 3: -1, }; const dmap = { 0: 1, 1: 0, 2: 1, 3: 0, }; for (const s of instructions) { if (s === &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/a5aa7e54145ab6c6ea8c2ed64f1c5553/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-04-09T17:32:34+08:00" />
<meta property="article:modified_time" content="2021-04-09T17:32:34+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">js解leetcode(82)-中等</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h4>1.困于环中的机器人</h4> 
<p>题目：</p> 
<p>在无限的平面上，机器人最初位于 <code>(0, 0)</code> 处，面朝北方。机器人可以接受下列三条指令之一：</p> 
<ul><li><code>"G"</code>：直走 1 个单位</li><li><code>"L"</code>：左转 90 度</li><li><code>"R"</code>：右转 90 度</li></ul> 
<p>机器人按顺序执行指令 <code>instructions</code>，并一直重复它们。</p> 
<p>只有在平面中存在环使得机器人永远无法离开时，返回 <code>true</code>。否则，返回 <code>false</code>。</p> 
<p>思路：明确一点：如果执行完一轮指令之后，方向不是朝北，或者回到原点，那么都会成环。</p> 
<p>回到原点不多说。方向不是朝北呢？其实就是，如果方向不是朝北，那么后续的路径是绕着原点中心对称的。所以肯定成环</p> 
<p>所以执行完一轮命令之后判断方向和位置即可</p> 
<p>时间复杂度O(n)，空间复杂度O(1)</p> 
<pre><code class="language-javascript">/**
 * @param {string} instructions
 * @return {boolean}
 */
var isRobotBounded = function(instructions) {
  let dir = 0;
  const position = [0, 0];
  const vmap = {
    0: 1,
    1: 1,
    2: -1,
    3: -1,
  };
  const dmap = {
    0: 1,
    1: 0,
    2: 1,
    3: 0,
  };
  for (const s of instructions) {
    if (s === "G") {
      position[dmap[dir]] += vmap[dir];
    } else if (s === "L") {
      dir = (dir - 1 + 4) % 4;
    } else {
      dir = (dir + 1) % 4;
    }
  }
  if (position[0] === 0 &amp;&amp; position[1] === 0) return true;
  if (dir === 0) return false;
  return true;
};</code></pre> 
<h4>2.分隔数组以得到最大和</h4> 
<p>题目：</p> 
<p>给你一个整数数组 arr，请你将该数组分隔为长度最多为 k 的一些（连续）子数组。分隔完成后，每个子数组的中的所有值都会变为该子数组中的最大值。</p> 
<p>返回将数组分隔变换后能够得到的元素最大和。</p> 
<p>注意，原数组和分隔后的数组对应顺序应当一致，也就是说，你只能选择分隔数组的位置而不能调整数组中的顺序。</p> 
<p>来源：力扣（LeetCode）<br> 链接：https://leetcode-cn.com/problems/partition-array-for-maximum-sum<br> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p> 
<p>思路：动态规划。假设dp[i]表示前i个数字对应的最大和。</p> 
<p>那么，将该组数字分成两部分：1-k的右半部分和左半部分，假设右半部分长度为j，那么有：</p> 
<p>dp[i] = max (dp[i], dp[i - j] + max(arr[i]-arr[i-j]) * j)</p> 
<p>即，枚举右半部分的所有可能(1-k)的长度枚举一遍，就能计算出dp[i]的最大值</p> 
<p>时间复杂度O(nk)，空间复杂度O9n0</p> 
<pre><code class="language-javascript">
/**
 * @param {number[]} arr
 * @param {number} k
 * @return {number}
 */
var maxSumAfterPartitioning = function(arr, k) {
  const l = arr.length;
  const dp = new Array(l + 1).fill(0);
  for (let i = 1; i &lt;= l; i++) {
    let max = 0;
    for (let j = i - 1; i - j &lt;= k &amp;&amp; j &gt;= 0; j--) {
      max = Math.max(max, arr[j]);
      dp[i] = Math.max(dp[i], dp[j] + (i - j) * max);
    }
  }
  return dp[l];
};</code></pre> 
<h4>3.最长字符串链</h4> 
<p>题目：</p> 
<p>给出一个单词列表，其中每个单词都由小写英文字母组成。</p> 
<p>如果我们可以在 word1 的任何地方添加一个字母使其变成 word2，那么我们认为 word1 是 word2 的前身。例如，"abc" 是 "abac" 的前身。</p> 
<p>词链是单词 [word_1, word_2, ..., word_k] 组成的序列，k &gt;= 1，其中 word_1 是 word_2 的前身，word_2 是 word_3 的前身，依此类推。</p> 
<p>从给定单词列表 words 中选择单词组成词链，返回词链的最长可能长度。</p> 
<p>思路：这个类似最长上升子序列，不过有一点区别。</p> 
<p>因为某个字符串是另一个字符串的前身的话，那么长度肯定比它小1.</p> 
<p>所以先字符串按照长度进行分组，然后从长度为1开始的字符串，依次记录每个字符串对应的下一个字符串(存在一对多，所以用数组记录)。</p> 
<p>那么从前往后开始，用一个数组记录每个字符串的最大深度，也就是词链的最大长度。</p> 
<p>时间复杂度O(n),空间复杂度O(n)</p> 
<pre><code class="language-javascript">/**
 * @param {string[]} words
 * @return {number}
 */
const isS = (s1, s2) =&gt; {
  const l = s2.length;
  for (let i = 0; i &lt; l; i++) {
    if (s2.slice(0, i) + s2.slice(i + 1) === s1) return true;
  }
  return false;
};
var longestStrChain = function (words) {
  const l = words.length;
  const deep = words.slice().fill(1);
  const nextS = words.slice();
  const dp = new Array(17).fill("").map(() =&gt; []);
  for (let i = 0; i &lt; l; i++) {
    dp[words[i].length].push(i);
  }
  for (let i = 1; i &lt; 16; i++) {
    const next = dp[i + 1];
    const current = dp[i];
    for (const cur of current) {
      const nextIndex = next.filter((item) =&gt; isS(words[cur], words[item]));
      nextS[cur] = nextIndex;
    }
  }
  for (let i = 1; i &lt; 16; i++) {
    dp[i].forEach((item) =&gt; {
      const next = nextS[item];
      next.forEach((n) =&gt; {
        deep[n] = Math.max(deep[n], deep[item] + 1);
      });
    });
  }
  return Math.max(...deep);
};</code></pre> 
<h4>4.最后一块石头的重量</h4> 
<p>题目：</p> 
<p>有一堆石头，每块石头的重量都是正整数。</p> 
<p>每一回合，从中选出<strong>任意两块石头</strong>，然后将它们一起粉碎。假设石头的重量分别为 <code>x</code> 和 <code>y</code>，且 <code>x &lt;= y</code>。那么粉碎的可能结果如下：</p> 
<ul><li>如果 <code>x == y</code>，那么两块石头都会被完全粉碎；</li><li>如果 <code>x != y</code>，那么重量为 <code>x</code> 的石头将会完全粉碎，而重量为 <code>y</code> 的石头新重量为 <code>y-x</code>。</li></ul> 
<p>最后，最多只会剩下一块石头。返回此石头<strong>最小的可能重量</strong>。如果没有石头剩下，就返回 <code>0</code>。</p> 
<p>思路：这题可以转换为背包问题。一万年两块石头粉碎后，剩余质量是它们的差。所以其实就是对石头分组，并尽可能平均分配。所以是在重量限制为最大重量的一半时，最大重量是多少，</p> 
<p>时间复杂度O(mn)，空间复杂度O(n)，m是石头的总重量</p> 
<pre><code class="language-javascript">/**
 * @param {number[]} stones
 * @return {number}
 */
var lastStoneWeightII = function(stones) {
  const l = stones.length;
  const sum = stones.reduce((a, b) =&gt; a + b, 0);
  const max = ~~(sum / 2);
  const dp = new Array(max + 1).fill(0);
  for (let i = 1; i &lt;= l; i++) {
    for (let j = max; j &gt;= 0; j--) {
      if (stones[i - 1] &gt; j) {
        continue;
      } else {
        dp[j] = Math.max(dp[j], stones[i - 1] + dp[j - stones[i - 1]]);
      }
    }
  }
  return sum - 2 * dp[max];
};</code></pre> 
<h4>5.爱生气的书店老板</h4> 
<p>题目：</p> 
<p>今天，书店老板有一家店打算试营业 customers.length 分钟。每分钟都有一些顾客（customers[i]）会进入书店，所有这些顾客都会在那一分钟结束后离开。</p> 
<p>在某些时候，书店老板会生气。 如果书店老板在第 i 分钟生气，那么 grumpy[i] = 1，否则 grumpy[i] = 0。 当书店老板生气时，那一分钟的顾客就会不满意，不生气则他们是满意的。</p> 
<p>书店老板知道一个秘密技巧，能抑制自己的情绪，可以让自己连续 X 分钟不生气，但却只能使用一次。</p> 
<p>请你返回这一天营业下来，最多有多少客户能够感到满意的数量。</p> 
<p>思路：滑动窗口。在长度为k的范围内，将老板生气时的客户数量记录下来，并计算最大值，就是最多能挽回的客户数量</p> 
<p>时间复杂度O(n)，空间复杂度O(1)</p> 
<pre><code class="language-javascript">/**
 * @param {number[]} customers
 * @param {number[]} grumpy
 * @param {number} X
 * @return {number}
 */
var maxSatisfied = function(customers, grumpy, X) {
  let c = 0;
  let l = customers.length;
  for (let i = 0; i &lt; l; i++) {
    if (!grumpy[i]) {
      c += customers[i];
    }
  }

  let cur = 0;
  for (let i = 0; i &lt; X; i++) {
    if (grumpy[i]) {
      cur += customers[i];
    }
  }
  let max = cur;
  for (let i = X; i &lt; l; i++) {
    if (grumpy[i - X]) {
      cur -= customers[i - X];
    }
    if (grumpy[i]) {
      cur += customers[i];
    }
    max = Math.max(max, cur);
  }
  return c + max;
};</code></pre> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6157bbb4c81a94e5d1a79ccd46076517/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">第3章-10 统计大写辅音字母 (15 分)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/2321f5874b4d0131bc893208863c564d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">leetcode 32. 最长有效括号</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>