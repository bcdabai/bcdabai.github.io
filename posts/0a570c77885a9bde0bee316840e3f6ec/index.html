<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>小程序笔记3 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="小程序笔记3" />
<meta property="og:description" content="1.自定义组件 1.创建组件
在项目的根目录中，鼠标右键，创建 components -&gt; test 文件夹在新建的 components -&gt; test 文件夹上，鼠标右键，点击“新建 Component”键入组件的名称之后回车，会自动生成组件对应的 4 个文件，后缀名分别为 .js，.json，.wxml 和 .wxss 2.引用组件
局部引用：组件只能在当前被引用的页面内使用
在页面的 .json 配置文件中引用组件的方式，叫做“局部引用”
“usingComponents”: {
“my-test1”: “/components/test/test”,
}
全局引用：组件可以在每个小程序页面中使用
app.json引用
“usingComponents”: {
“my-test1”: “/components/test/test”,
}
3.组件和页面的区别
从表面来看，组件和页面都是由 .js、.json、.wxml 和 .wxss 这四个文件组成的。但是，组件和页面的 .js 与 .json 文件有明显的不同：
组件的 .json 文件中需要声明 “component”: true 属性组件的 .js 文件中调用的是 Component() 函数，app.js(App()),页面Page(）组件的事件处理函数需要定义到 methods 节点中 4.自定义组件样式
组件样式隔离（组件之间或者组件和页面之间样式互不影响，只针对样式选择器）
组件样式隔离的注意点
app.wxss 中的全局样式对组件无效只有 class 选择器会有样式隔离效果，id 选择器、属性选择器、标签选择器不受样式隔离的影响 修改组件的样式隔离选项
Component({ options: { styleIsolation: &#39;shared&#39; }） 页面给组件传值" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/0a570c77885a9bde0bee316840e3f6ec/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-08-04T13:59:48+08:00" />
<meta property="article:modified_time" content="2022-08-04T13:59:48+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">小程序笔记3</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h4><a id="1_0"></a>1.自定义组件</h4> 
<p><strong>1.创建组件</strong></p> 
<ol><li>在项目的根目录中，鼠标右键，创建 components -&gt; test 文件夹</li><li>在新建的 components -&gt; test 文件夹上，鼠标右键，点击“新建 Component”</li><li>键入组件的名称之后回车，会自动生成组件对应的 4 个文件，后缀名分别为 .js，.json，.wxml 和 .wxss</li></ol> 
<p><strong>2.引用组件</strong></p> 
<ol><li> <p>局部引用：组件只能在当前被引用的页面内使用</p> <p>在页面的 .json 配置文件中引用组件的方式，叫做“局部引用”</p> <p>“usingComponents”: {<!-- --><br> “my-test1”: “/components/test/test”,<br> }</p> </li><li> <p>全局引用：组件可以在每个小程序页面中使用</p> <p>app.json引用</p> <p>“usingComponents”: {<!-- --><br> “my-test1”: “/components/test/test”,<br> }</p> </li></ol> 
<p><strong>3.组件和页面的区别</strong></p> 
<p>从表面来看，组件和页面都是由 .js、.json、.wxml 和 .wxss 这四个文件组成的。但是，组件和页面的 .js 与 .json 文件有明显的不同：</p> 
<ol><li><strong>组件的 .json 文件中需要声明 “component”: true 属性</strong></li><li><strong>组件的 .js 文件中调用的是 Component() 函数，app.js(App()),页面Page(）</strong></li><li><strong>组件的事件处理函数需要定义到 methods 节点中</strong></li></ol> 
<p><strong>4.自定义组件样式</strong></p> 
<ol><li> <p>组件样式隔离（组件之间或者组件和页面之间样式互不影响，只针对样式选择器）</p> </li><li> <p>组件样式隔离的注意点</p> 
  <ul><li><strong>app.wxss 中的全局样式对组件无效</strong></li><li><strong>只有 class 选择器会有样式隔离效果，id 选择器、属性选择器、标签选择器不受样式隔离的影响</strong></li></ul> </li><li> <p>修改组件的样式隔离选项</p> </li></ol> 
<pre><code class="prism language-cpp"><span class="token function">Component</span><span class="token punctuation">(</span><span class="token punctuation">{<!-- --></span>
     options<span class="token operator">:</span> <span class="token punctuation">{<!-- --></span>
       styleIsolation<span class="token operator">:</span> <span class="token char">'shared'</span>
     <span class="token punctuation">}</span>）
</code></pre> 
<p><img src="https://images2.imgbox.com/03/ed/0OkO3IoX_o.png" alt="在这里插入图片描述"></p> 
<p><strong>页面给组件传值</strong></p> 
<pre><code>&lt;my-test1 max="9"&gt;&lt;/my-test1&gt;
//组件
properties: {
// 第一种方式：简化的方式
// max: Number
// 第二种方式：完整的定义方式
    max: {
      type: Number,
      value: 10
    }  
},
</code></pre> 
<p><strong>5.数据监听器</strong></p> 
<p>数据监听器用于<strong>监听和响应任何属性和数据字段的变化</strong>，从而执行特定的操作。它的作用类似于 vue 中的 watch 侦听器</p> 
<p>observers: {<!-- --><br> ‘n1, n2’: function (newN1, newN2) {<!-- --><br> this.setData({<!-- --><br> sum: newN1 + newN2<br> })<br> }<br> }</p> 
<ol><li> <p>监听对象中指定属性的变化</p> <p>‘’rgb.r,rgb.b"…</p> </li><li> <p>监听对象中所有属性的变化</p> <p><strong>使用通配符 ** 来监听对象中所有属性的变化</strong></p> <p>“rgb.**”:…</p> </li></ol> 
<p><strong>6.纯数据字段</strong></p> 
<ul><li> <p>概念：纯数据字段指的是那些不用于界面渲染的 data 字段,</p> </li><li> <p>应用场景：例如有些情况下，某些 data 中的字段既不会展示在界面上，也不会传递给其他组件，仅仅在当前组件内部使用。带有这种特性的 data 字段适合被设置为纯数据字段。</p> </li><li> <p>好处：纯数据字段有助于提升页面更新的性能。</p> </li><li> <p>使用规则：在 Component 构造器的 options 节点中，指定 pureDataPattern 为一个正则表达式，字段名符合这个正则表达式的字段将成为纯数据字段（data、methods…中符合规则的）</p> </li><li> <p>例子</p> <p>options: {<!-- --><br> pureDataPattern: /^_/<br> },</p> <p>data: {<!-- --><br> _rgb: {<!-- --><br> r: 0,<br> g: 0,<br> b: 0<br> },</p> <p><strong>7.生命周期</strong></p> <p>在小程序组件中，<strong>最重要的生命周期函数</strong>有 3 个，分别是 <strong>created、attached、detached</strong>。它们各自的特点如下：</p> 
  <ul><li>组件实例刚被创建好的时候，created 生命周期函数会被触发<br> 此时还不能调用 setData<br> 通常在这个生命周期函数中，只应该用于给组件的 this 添加一些自定义的属性字段</li><li>在组件完全初始化完毕、进入页面节点树后， attached 生命周期函数会被触发<br> 此时， this.data 已被初始化完毕<br> 这个生命周期很有用，绝大多数初始化的工作可以在这个时机进行（例如发请求获取初始数据）</li><li>在组件离开页面节点树后， detached 生命周期函数会被触发<br> 退出一个页面时，会触发页面内每个自定义组件的 detached 生命周期函数<br> 此时适合做一些清理性质的工作<br> <img src="https://images2.imgbox.com/8a/fb/IBs5cTgB_o.png" alt="- [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-yoaVNabr-1659496958698)(C:\Users\syhgly\AppData\Roaming\Typora\typora-user-images\1659444077111.png)]"></li></ul> </li></ul> 
<p><strong>8.lifetimes 节点</strong></p> 
<p>在小程序组件中，生命周期函数可以直接定义在 Component 构造器的第一级参数中，可以在 lifetimes 字段内进行声明（这是推荐的方式，其优先级最高）</p> 
<p><strong>9.组件所在页面的生命周期</strong></p> 
<p>自定义组件的行为依赖于页面状态的变化，此时就需要用到组件所在页面的生命周期。<br> <img src="https://images2.imgbox.com/84/60/rNxxc6fS_o.png" alt=""></p> 
<p><strong>10.pageLifetimes 节点</strong></p> 
<p>组件所在页面的生命周期函数，需要定义在 pageLifetimes 节点中</p> 
<p><strong>11.插槽</strong></p> 
<p>在自定义组件的 wxml 结构中，可以提供一个 节点（插槽），用于承载组件使用者提供的 wxml 结构。</p> 
<ul><li> <p><strong>单个插槽</strong>–在小程序中，默认每个自定义组件中只允许使用一个 进行占位，这种个数上的限制叫做单个插槽。</p> </li><li> <p><strong>启用多个插槽</strong>–组件的 .js 文件中开启</p> </li></ul> 
<pre><code class="prism language-cpp">  <span class="token function">Component</span><span class="token punctuation">(</span><span class="token punctuation">{<!-- --></span>
    options<span class="token operator">:</span> <span class="token punctuation">{<!-- --></span>
      multipleSlots<span class="token operator">:</span> <span class="token boolean">true</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token comment">//例子  -通过具名使用</span>
  <span class="token operator">&lt;</span>slot name<span class="token operator">=</span><span class="token string">"A"</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>slot<span class="token operator">&gt;</span> 
  <span class="token operator">&lt;</span>view slot<span class="token operator">=</span><span class="token string">"before"</span><span class="token operator">&gt;</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">&lt;</span><span class="token operator">/</span>view<span class="token operator">&gt;</span>
</code></pre> 
<p>配合 -----***</p> 
<p><strong>12.父子组件之间通信</strong></p> 
<ol><li> <p><strong>属性绑定</strong>（父-&gt;子）</p> <p>父组件</p> <p>count=“{<!-- -->{count}}”</p> <p>子组件</p> <p>properties: {<!-- --><br> count: Number<br> },</p> </li><li> <p><strong>事件绑定</strong></p> <p>bind:sync=“syncCount”||bindsync=“syncCount”</p> <p>父组件(通过 e.detail 获取到子组件传递过来的数据)</p> <p>sysncCount(e)</p> <p>子组件(通过调用 this.triggerEvent(‘自定义事件名称’, { /* 参数对象 */ }) ，将数据发送到父组件)</p> <p>this.triggerEvent(‘sync’, { value: this.properties.count })</p> </li><li> <p><strong>获组件实例</strong></p> <p>可在父组件里调用 this.selectComponent(“id或class选择器”) ，获取子组件的实例对象，从而<strong>直接访问子组件的任意数据和方法</strong>。调用时需要传入一个选择器，例如 this.selectComponent(“.my-component”)。</p> </li></ol> 
<pre><code class="prism language-cpp">wxml<span class="token operator">:</span>   <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"customA"</span> id<span class="token operator">=</span><span class="token string">"cA"</span>

   父组件

   <span class="token function">getChild</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
       <span class="token keyword">const</span> child <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">selectComponent</span><span class="token punctuation">(</span><span class="token char">'#cA'</span><span class="token punctuation">)</span>
       console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>child<span class="token punctuation">)</span>
       <span class="token comment">// child.setData({<!-- --></span>
       <span class="token comment">//   count: child.properties.count + 1</span>
       <span class="token comment">// })</span>
       child<span class="token punctuation">.</span><span class="token function">addCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
     <span class="token punctuation">}</span><span class="token punctuation">,</span>
</code></pre> 
<p><strong>13.behaviors</strong></p> 
<ol><li> <p>简介</p> <p>用于实现组件间代码共享的特性，<strong>类似于 Vue.js 中的 “mixins”</strong>。</p> </li><li> <p>behaviors 的工作方式</p> <p>每个 behavior 可以<strong>包含一组属性、数据、behavior 、生命周期函数和方法</strong>。组件引用它时，它的属性、数据和方法会被合并到组件中。<br> 每个<strong>组件</strong>可以<strong>引用多个 behavior</strong>，<strong>behavior 也可以引用其它 behavior</strong>。</p> </li><li> <p>创建behavior</p> <p>调用 Behavior(Object object) 方法即可创建一个共享的 behavior 实例对象，供所有的组件使用</p> </li></ol> 
<pre><code class="prism language-cpp"> my<span class="token operator">-</span>behavior<span class="token punctuation">.</span>js
  <span class="token keyword">module</span><span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token function">Behavior</span><span class="token punctuation">(</span><span class="token punctuation">{<!-- --></span>
    data<span class="token operator">:</span> <span class="token punctuation">{<!-- --></span>
      username<span class="token operator">:</span> <span class="token char">'zs'</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    properties<span class="token operator">:</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    methods<span class="token operator">:</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> 
<pre><code class="prism language-cpp"><span class="token comment">//组件</span>
  <span class="token keyword">const</span> myBehavior <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token char">'../../behaviors/my-behavior'</span><span class="token punctuation">)</span>
  <span class="token function">Component</span><span class="token punctuation">(</span><span class="token punctuation">{<!-- --></span>
    behaviors<span class="token operator">:</span> <span class="token punctuation">[</span>myBehavior<span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span>）
</code></pre> 
<ol start="4"><li> <p>同名字段的覆盖和组合规则</p> <p>当组件触发生命周期时，上例生命周期函数执行顺序为：</p> 
  <ol><li><code>[my-behavior] created</code></li><li><code>[my-component] created</code></li><li><code>[my-behavior] attached</code></li><li><code>[my-component] attached</code></li><li><code>[my-behavior] ready</code></li><li><code>[my-component] ready</code></li></ol> <p>组件和它引用的 <code>behavior</code> 中可以包含同名的字段</p> 
  <ol><li><strong>同名的数据字段 (data)</strong> 
    <ul><li>若<strong>同名的数据字段都是对象类型</strong>，会进行对象<strong>合并</strong>；</li><li>其余情况会进行数据覆盖，覆盖规则为： **<code>引用者 behavior</code> &gt; <code>被引用的 behavior</code> 、 <code>靠后的 behavior</code> &gt; <code>靠前的 behavior**</code>。（优先级高的覆盖优先级低的，最大的为优先级最高）</li></ul> </li><li><strong>同名的属性 (properties) 或方法 (methods)</strong> 
    <ol><li>若<strong>组件本身有这个属性或方法</strong>，则组件的属性或方法会<strong>覆盖</strong> <code>behavior</code> 中的同名属性或方法；</li><li>若组件本身无这个属性或方法，则在组件的 <code>behaviors</code> 字段中定义<strong>靠后的 <code>behavior</code></strong> 的属性或方法会<strong>覆盖</strong>靠前的同名属性或方法；</li></ol> </li><li><strong>同名的生命周期函数</strong> 
    <ol><li>对于不同的生命周期函数之间，<strong>遵循组件生命周期函数的执行顺序</strong>；</li><li><strong>对于同种生命周期函数，遵循如下规则</strong>： 
      <ul><li><code>behavior</code> 优先于组件执行；</li><li><code>被引用的 behavior</code> 优先于 <code>引用者 behavior</code> 执行；</li><li><code>靠前的 behavior</code> 优先于 <code>靠后的 behavior</code> 执行；</li></ul> </li><li>如果<strong>同一个 <code>behavior</code> 被一个组件多次引用，它定义的生命周期函数只会被执行一次</strong>。</li></ol> </li></ol> </li></ol> 
<h4><a id="2npm_271"></a>2.使用那npm包</h4> 
<ol><li> <p>小程序对 npm 的支持与限制</p> <p>总结：虽然 npm 上的包有千千万，但是能供小程序使用的包却“为数不多”。</p> 
  <ul><li>不支持依赖于 Node.js 内置库的包</li><li>不支持依赖于浏览器内置对象的包</li><li>不支持依赖于 C++ 插件的包</li></ul> </li><li> <p>Vant Weapp</p> 
  <ul><li> <p>介绍：Vant Weapp 是有赞前端团队开源的一套小程序 UI 组件库，助力开发者快速搭建小程序应用。它所使用的是 MIT 开源许可协议，对商业使用比较友好。<br> <a href="https://youzan.github.io/vant-weapp" rel="nofollow">官方文档地址</a></p> </li><li> <p>安装</p> 
    <ul><li> <p>通过 npm 安装（建议指定版本为@1.3.3（不要是最新的））</p> </li><li> <p>构建 npm 包</p> </li><li> <p>修改 app.json（使用组件）</p> <p>“usingComponents”: {<!-- --><br> “van-button”: “@vant/weapp/button/index”,</p> <p>}</p> </li><li> <p>详细的操作步骤，大家可以参考 <a href="https://youzan.github.io/vant-weapp/#/quickstart#an-zhuang" rel="nofollow">Vant 官方提供的快速上手教程</a>：</p> </li></ul> </li></ul> </li><li> <p>定制全局主题样式</p> <p>Vant Weapp 使用 CSS 变量来实现定制主题。 关于 CSS 变量的基本用法，请参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Using_CSS_custom_properties" rel="nofollow">MDN 文档</a></p> </li><li> <p><strong>使用 npm 包进行API Promise优化</strong></p> 
  <ul><li>基于回调函数的异步 API 的缺点<br> <img src="https://images2.imgbox.com/17/35/8GZo84kd_o.png" alt="在这里插入图片描述"></li></ul> <p>缺点：<strong>容易造成回调地狱的问题，代码的可读性、维护性差！</strong></p> 
  <ul><li> <p>API Promise 优化-升级改造为基于 Promise 的异步 API</p> <p>在小程序中，实现 API Promise 优化主要依赖于 miniprogram-api-promise 这个第三方的 npm 包。它的安装和使用步骤如下：<br> <img src="https://images2.imgbox.com/28/bf/3wY7xpSo_o.png" alt="在这里插入图片描述"></p> </li></ul> </li></ol> 
<h4><a id="3_319"></a>3.全局数据共享</h4> 
<ol><li> <p>简介</p> <p>全局数据共享（又叫做：状态管理）是为了解决组件之间数据共享的问题。<br> 开发中常用的全局数据共享方案有：Vuex、Redux、MobX 等</p> </li><li> <p>小程序中的全局数据共享方案(Mobx)</p> <p>在小程序中，可使用 mobx-miniprogram 配合 mobx-miniprogram-bindings 实现全局数据共享。其中：</p> 
  <ul><li>mobx-miniprogram 用来创建 Store 实例对象</li><li>mobx-miniprogram-bindings 用来把 Store 中的共享数据或方法，绑定到组件或页面中使用</li></ul> </li><li> <p>使用步骤</p> 
  <ul><li> <p>安装包</p> <p>npm install --save mobx-miniprogram@4.13.2 mobx-miniprogram-bindings@1.2.1</p> <p><strong>注意</strong>：MobX 相关的包安装完毕之后，记得删除 miniprogram_npm 目录后，重新构建 npm。</p> </li><li> <p>创建Mobx的store实例</p> <p>// 在这个 JS 文件中，专门来创建 Store 的实例对象</p> </li></ul> </li></ol> 
<pre><code class="prism language-cpp"><span class="token keyword">import</span> <span class="token punctuation">{<!-- --></span> observable<span class="token punctuation">,</span> action <span class="token punctuation">}</span> from <span class="token char">'mobx-miniprogram'</span>
 <span class="token keyword">export</span> <span class="token keyword">const</span> store <span class="token operator">=</span> <span class="token function">observable</span><span class="token punctuation">(</span><span class="token punctuation">{<!-- --></span>
   <span class="token comment">// 数据字段</span>
   numA<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
   numB<span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span>
   activeTabBarIndex<span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>
   <span class="token comment">// 计算属性</span>
   get <span class="token function">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
     <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>numA <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>numB
   <span class="token punctuation">}</span><span class="token punctuation">,</span>
   <span class="token comment">// actions 函数，专门来修改 store 中数据的值</span>
   updateNum1<span class="token operator">:</span> <span class="token function">action</span><span class="token punctuation">(</span><span class="token function">function</span> <span class="token punctuation">(</span>step<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
     <span class="token keyword">this</span><span class="token punctuation">.</span>numA <span class="token operator">+=</span> step
   <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
   updateNum2<span class="token operator">:</span> <span class="token function">action</span><span class="token punctuation">(</span><span class="token function">function</span> <span class="token punctuation">(</span>step<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
     <span class="token keyword">this</span><span class="token punctuation">.</span>numB <span class="token operator">+=</span> step
   <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
   updateActiveTabBarIndex<span class="token operator">:</span> <span class="token function">action</span><span class="token punctuation">(</span><span class="token function">function</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
     <span class="token keyword">this</span><span class="token punctuation">.</span>activeTabBarIndex <span class="token operator">=</span> index
   <span class="token punctuation">}</span><span class="token punctuation">)</span>
 <span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> 
<ul><li>将 Store 中的成员绑定到页面中</li></ul> 
<pre><code class="prism language-cpp">  <span class="token comment">// pages/message/message.js</span>
     <span class="token keyword">import</span> <span class="token punctuation">{<!-- --></span> createStoreBindings <span class="token punctuation">}</span> from <span class="token char">'mobx-miniprogram-bindings'</span>
     <span class="token keyword">import</span> <span class="token punctuation">{<!-- --></span> store <span class="token punctuation">}</span> from <span class="token char">'../../store/store'</span>

     <span class="token function">Page</span><span class="token punctuation">(</span><span class="token punctuation">{<!-- --></span>
       onLoad<span class="token operator">:</span> <span class="token function">function</span> <span class="token punctuation">(</span>options<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	     <span class="token keyword">this</span><span class="token punctuation">.</span>storeBindings <span class="token operator">=</span> <span class="token function">createStoreBindings</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token punctuation">{<!-- --></span>
	       store<span class="token punctuation">,</span>
	       fields<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token char">'numA'</span><span class="token punctuation">,</span> <span class="token char">'numB'</span><span class="token punctuation">,</span> <span class="token char">'sum'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
	       actions<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token char">'updateNum1'</span><span class="token punctuation">]</span>
	     <span class="token punctuation">}</span><span class="token punctuation">)</span>
       <span class="token punctuation">}</span><span class="token punctuation">,</span>

       <span class="token function">btnHandler1</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
         <span class="token comment">// console.log(e)</span>
         <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">updateNum1</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>target<span class="token punctuation">.</span>dataset<span class="token punctuation">.</span>step<span class="token punctuation">)</span>
       <span class="token punctuation">}</span>
     <span class="token punctuation">}</span>）
</code></pre> 
<ul><li>在页面上使用 Store 中的成员</li></ul> 
<pre><code class="prism language-cpp"> <span class="token operator">&lt;</span>view<span class="token operator">&gt;</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">{<!-- --></span>numA<span class="token punctuation">}</span><span class="token punctuation">}</span> <span class="token operator">+</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">{<!-- --></span>numB<span class="token punctuation">}</span><span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">{<!-- --></span>sum<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>view<span class="token operator">&gt;</span>
 <span class="token operator">&lt;</span>van<span class="token operator">-</span>button type<span class="token operator">=</span><span class="token string">"primary"</span> bindtap<span class="token operator">=</span><span class="token string">"btnHandler1"</span> data<span class="token operator">-</span>step<span class="token operator">=</span><span class="token string">"{<!-- -->{1}}"</span><span class="token operator">&gt;</span>numA <span class="token operator">+</span> <span class="token number">1</span><span class="token operator">&lt;</span><span class="token operator">/</span>van<span class="token operator">-</span>button<span class="token operator">&gt;</span>
 <span class="token operator">&lt;</span>van<span class="token operator">-</span>button type<span class="token operator">=</span><span class="token string">"danger"</span> bindtap<span class="token operator">=</span><span class="token string">"btnHandler1"</span> data<span class="token operator">-</span>step<span class="token operator">=</span><span class="token string">"{<!-- -->{-1}}"</span><span class="token operator">&gt;</span>numA <span class="token operator">-</span> <span class="token number">1</span><span class="token operator">&lt;</span><span class="token operator">/</span>van<span class="token operator">-</span>button<span class="token operator">&gt;</span>
</code></pre> 
<ul><li>将 Store 中的成员绑定到组件中</li></ul> 
<pre><code class="prism language-cpp">  	 <span class="token keyword">import</span> <span class="token punctuation">{<!-- --></span> storeBindingsBehavior <span class="token punctuation">}</span> from <span class="token char">'mobx-miniprogram-bindings'</span>
     <span class="token keyword">import</span> <span class="token punctuation">{<!-- --></span> store <span class="token punctuation">}</span> from <span class="token char">'../../store/store'</span>
     <span class="token function">Component</span><span class="token punctuation">(</span><span class="token punctuation">{<!-- --></span>
       behaviors<span class="token operator">:</span> <span class="token punctuation">[</span>storeBindingsBehavior<span class="token punctuation">]</span><span class="token punctuation">,</span>
       storeBindings<span class="token operator">:</span> <span class="token punctuation">{<!-- --></span>
         store<span class="token punctuation">,</span>
         fields<span class="token operator">:</span> <span class="token punctuation">{<!-- --></span>
           numA<span class="token operator">:</span> <span class="token char">'numA'</span><span class="token punctuation">,</span>
           numB<span class="token operator">:</span> <span class="token char">'numB'</span><span class="token punctuation">,</span>
           sum<span class="token operator">:</span> <span class="token char">'sum'</span>
         <span class="token punctuation">}</span><span class="token punctuation">,</span>
         actions<span class="token operator">:</span> <span class="token punctuation">{<!-- --></span>
           updateNum2<span class="token operator">:</span> <span class="token char">'updateNum2'</span>
         <span class="token punctuation">}</span>
       <span class="token punctuation">}</span><span class="token punctuation">,</span>
     methods<span class="token operator">:</span> <span class="token punctuation">{<!-- --></span>
         <span class="token function">btnHandler2</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
           <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">updateNum2</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>target<span class="token punctuation">.</span>dataset<span class="token punctuation">.</span>step<span class="token punctuation">)</span>
         <span class="token punctuation">}</span>
       <span class="token punctuation">}</span>
     <span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> 
<ul><li>在组件中使用 Store 中的成员</li></ul> 
<pre><code class="prism language-cpp"> <span class="token operator">&lt;</span>view<span class="token operator">&gt;</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">{<!-- --></span>numA<span class="token punctuation">}</span><span class="token punctuation">}</span> <span class="token operator">+</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">{<!-- --></span>numB<span class="token punctuation">}</span><span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">{<!-- --></span>sum<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>view<span class="token operator">&gt;</span>
 <span class="token operator">&lt;</span>van<span class="token operator">-</span>button type<span class="token operator">=</span><span class="token string">"primary"</span> bindtap<span class="token operator">=</span><span class="token string">"btnHandler2"</span> data<span class="token operator">-</span>step<span class="token operator">=</span><span class="token string">"{<!-- -->{1}}"</span><span class="token operator">&gt;</span>numB <span class="token operator">+</span> <span class="token number">1</span><span class="token operator">&lt;</span><span class="token operator">/</span>van<span class="token operator">-</span>button<span class="token operator">&gt;</span>
 <span class="token operator">&lt;</span>van<span class="token operator">-</span>button type<span class="token operator">=</span><span class="token string">"danger"</span> bindtap<span class="token operator">=</span><span class="token string">"btnHandler2"</span> data<span class="token operator">-</span>step<span class="token operator">=</span><span class="token string">"{<!-- -->{-1}}"</span><span class="token operator">&gt;</span>numB <span class="token operator">-</span> <span class="token number">1</span><span class="token operator">&lt;</span><span class="token operator">/</span>van<span class="token operator">-</span>button<span class="token operator">&gt;</span>
</code></pre> 
<h4><a id="4_437"></a>4.分包</h4> 
<ol><li> <p>简介</p> <p>分包指的是把<strong>一个完整的小程序项目，按照需求划分为不同的子包</strong>，在构建时打包成不同的分包，用户在使用时<strong>按需进行加载</strong>。</p> </li><li> <p>分包的好处</p> 
  <ul><li>可以<strong>优化小程序首次启动的下载时间</strong></li><li>在多团队共同开发时可以更好的<strong>解耦协作</strong></li></ul> </li><li> <p>分包前项目的构成</p> <p>分包前，小程序项目中<strong>所有的页面和资源</strong>都被打包到了一起，导致<strong>整个项目体积过大</strong>，影响小程序<strong>首次启动的下载时间</strong>。</p> </li><li> <p>分包后项目的构成</p> <p>分包后，小程序项目由 <strong>1 个主包 + 多个分包组成</strong>：<br> 主包：一般只包含项目的<strong>启动页面或 TabBar 页面</strong>、以及<strong>所有分包都需要用到的一些公共资源</strong><br> 分包：<strong>只包含和当前分包有关的页面和私有资源</strong></p> </li><li> <p>分包的加载规则</p> 
  <ul><li> <p>在小程序启动时，默认会<strong>下载主包并启动主包内页面</strong></p> <p><strong>tabBar 页面需要放到主包中</strong></p> </li><li> <p>当用户<strong>进入分包内某个页面</strong>时，<strong>客户端会把对应分包下载下来</strong>，下载完成后再进行展示</p> <p>非 tabBar 页面可以按照功能的不同，划分为不同的分包之后，进行按需下载</p> </li><li> <p>分包的体积限制</p> 
    <ul><li>整个小程序所有分包大小不超过 16M（主包 + 所有分包）</li><li>单个分包/主包大小不能超过 2M</li></ul> </li></ul> </li><li> <p><strong>配置方法（使用分包）</strong></p> <p><img src="https://images2.imgbox.com/66/1c/eLaHVLsj_o.png" alt=""></p> </li><li> <p><strong>打包原则（使用分包）</strong></p> 
  <ul><li>小程序会按 subpackages 的配置进行分包，subpackages 之外的目录将被打包到主包中</li><li>主包也可以有自己的 pages（即最外层的 pages 字段）</li><li>tabBar 页面必须在主包内</li><li>分包之间不能互相嵌套</li></ul> </li><li> <p><strong>引用原则（使用分包）</strong></p> <p><strong>主包无法引用分包内的私有资源</strong><br> <strong>分包之间不能相互引用私有资源</strong><br> <strong>分包可以引用主包内的公共资源</strong></p> </li><li> <p>独立分包</p> 
  <ul><li> <p>简介</p> <p>独立分包本质上也是分包，只不过它比较特殊，<strong>可以独立于主包和其他分包而单独运行</strong>。</p> </li><li> <p>独立分包和普通分包的区别</p> <p>最主要的区别：<strong>是否依赖于主包才能运行</strong><br> <strong>普通分包必须依赖</strong>于主包才能运行<br> 独立分包可以在不下载主包的情况下，独立运行</p> </li></ul> </li><li> <p>独立分包的应用场景</p> <p>开发者可以按需，将某些具有一定功能独立性的页面配置到独立分包中。原因如下：<br> 当小程序从普通的分包页面启动时，需要首先下载主包<br> 而<strong>独立分包不依赖主包</strong>即可运行，可以很大程度上提升分包页面的启动速度<br> 注意：一个小程序中可以有多个独立分包。</p> </li><li> <p>独立分包的配置方法</p> </li></ol> 
<p><img src="https://images2.imgbox.com/d8/ad/B7ADSEAx_o.png" alt="在这里插入图片描述"></p> 
<ol start="12"><li> <p>独立分包引用原则</p> <p>独立分包和普通分包以及主包之间，是相互隔绝的，不能相互引用彼此的资源！例如：<br> 主包无法引用独立分包内的私有资源<br> 独立分包之间，不能相互引用私有资源<br> 独立分包和普通分包之间，不能相互引用私有资源<br> 特别注意：<strong>独立分包中不能引用主包内的公共资源</strong></p> </li><li> <p>分包预下载</p> <p>简介</p> <p>在进入小程序的某个页面时，<strong>由框架自动预下载可能需要的分包</strong>，从而<strong>提升</strong>进入后续<strong>分包页面时的启动速度</strong>。</p> </li><li> <p>配置分包的预下载</p> <p><strong>预下载分包的行为，会在进入指定的页面时触发</strong>。在 <strong>app.json</strong> 中，使用 <strong>preloadRule</strong> 节点定义分包的预下载规则，示例代码如下：<br> <img src="https://images2.imgbox.com/ef/29/QSEYOOgf_o.png" alt="在这里插入图片描述"></p> </li><li> <p>分包预下载的限制</p> <p>同一个分包中的页面享有共同的预下载大小限额 2M</p> </li></ol> 
<p><img src="https://images2.imgbox.com/f9/c5/oxAo7RkI_o.png" alt=""></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d681d5030e3e3ef082c5cca28ec69bc5/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">《大话通信》阅读笔记整理</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/59f9d91d37150e2c685c77322aefb0d2/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Swin-Transformer论文解析</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>