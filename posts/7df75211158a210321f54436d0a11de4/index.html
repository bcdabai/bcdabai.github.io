<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Dubbo的服务降级策略剖析 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Dubbo的服务降级策略剖析" />
<meta property="og:description" content="1 服务降级策略概述 设置Dubbo服务降级策略的主要目的，简单来说就是为了实现对指定服务的请求可以不处理或者简单处理。服务降级策略主要有以下两种：
（1）force策略。服务消费端不进行远程调用，直接执行mock方法（即服务降级方法），如返回设置的mock值、抛出异常或执行自定义mock类。
（1）mock = &#34;force:return mock值&#34; （2）mock = &#34;force:throw 抛出的异常名称&#34; （3）mock = &#34;force:自定义的Mock类名&#34; （2）fail策略。当调用远程接口失败时（非BIZ_EXCEPTION时），执行mock方法，如返回设置的mock值、抛出异常或执行自定义mock类。
（1）mock = &#34;fail:return mock值&#34; （2）mock = &#34;fail:throw 抛出的异常名称&#34; （3）mock = &#34;fail:自定义的Mock类名&#34; 服务降级主要用在以下场景：
当服务器压力剧增的情况下，根据当前业务情况及流量对一些服务有策略的降低服务级别，以释放服务器资源，保证核心任务的正常运行。当服务响应超时或连接请求超时，不用继续等下去，而采用降级措施，以防止分布式服务发生雪崩效应。在大促销之前通过降级开关关闭推荐、评价等对主流程没有影响的功能。大促销完毕后，再进行恢复。在秒杀这种流量比较集中并且流量特别大的情况下，因为突发访问量特别大可能会导致系统支撑不了。这个时候可以采用限流来限制访问量，当达到阀值时，后续的请求被降级。 总的来说，服务降级策略主要用在保障核心服务的可用性，防止分布式服务发生雪崩效应，以及在服务器压力剧增或服务响应超时等情况下保证服务的正常运行。
2 设置服务降级策略 设置服务降级策略的主要方式有以下两种：
（1）通过dubbo控制台设置指定服务的降级策略。
（2）在服务消费端设置接口级别或方法级别的服务降级策略。举例如下。
设置接口级别的降级策略：
@Reference(mock = &#34;fail:return null&#34;) private TestService testService; 或者 &lt;dubbo:reference id=&#34;testService&#34; interface=&#34;com.hn.TestService&#34; protocol=&#34;dubbo&#34; mock=&#34;fail:return null&#34;/&gt; 设置方法级别的降级策略：
&lt;!-- 对getUserList方法进行降级，其它方法正常调用 --&gt; &lt;dubbo:reference id=&#34;testService&#34; interface=&#34;com.hn.TestService&#34; protocol=&#34;dubbo&#34;&gt; &lt;dubbo:method name=&#34;getUserList&#34; mock=&#34;fail:return null&#34;/&gt; &lt;/dubbo:reference&gt; 3 服务降级策略过程剖析 在服务消费端发起远程调用的过程中，服务消费端首先调用MockClusterInvoker的invoker()方法。
（1）当没设置降级策略时，直接调用DubboInvoker的invoker()方法发起远程调用。
（2）当服务降级策略为“force策略”时，不进行远程调用，直接执行mock方法，如返回定义的mock值、抛出异常或执行自定义mock类。
（3）当服务降级策略不是“force策略”时，直接发起远程调用。当调用远程接口失败时（非BIZ_EXCEPTION时），执行mock方法，如返回设置的mock值、抛出异常或执行自定义mock类。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/7df75211158a210321f54436d0a11de4/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-13T12:20:15+08:00" />
<meta property="article:modified_time" content="2024-01-13T12:20:15+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Dubbo的服务降级策略剖析</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2 style="background-color:transparent;">1 服务降级策略概述</h2> 
<p>设置Dubbo服务降级策略的主要目的，简单来说就是为了实现对指定服务的请求可以不处理或者简单处理。服务降级策略主要有以下两种：</p> 
<p>（1）<strong>force策略</strong>。服务消费端不进行远程调用，直接执行mock方法（即服务降级方法），如返回设置的mock值、抛出异常或执行自定义mock类。</p> 
<pre><code class="language-java">（1）mock = "force:return mock值" 
（2）mock = "force:throw 抛出的异常名称" 
（3）mock = "force:自定义的Mock类名"
</code></pre> 
<p>（2）<strong>fail策略</strong>。当调用远程接口失败时（非BIZ_EXCEPTION时），执行mock方法，如返回设置的mock值、抛出异常或执行自定义mock类。</p> 
<pre><code class="language-java">（1）mock = "fail:return mock值" 
（2）mock = "fail:throw 抛出的异常名称" 
（3）mock = "fail:自定义的Mock类名"</code></pre> 
<p>服务降级主要用在以下场景：</p> 
<ul><li>当服务器压力剧增的情况下，根据当前业务情况及流量对一些服务有策略的降低服务级别，以释放服务器资源，保证核心任务的正常运行。</li><li>当服务响应超时或连接请求超时，不用继续等下去，而采用降级措施，以防止分布式服务发生雪崩效应。</li><li>在大促销之前通过降级开关关闭推荐、评价等对主流程没有影响的功能。大促销完毕后，再进行恢复。</li><li>在秒杀这种流量比较集中并且流量特别大的情况下，因为突发访问量特别大可能会导致系统支撑不了。这个时候可以采用限流来限制访问量，当达到阀值时，后续的请求被降级。</li></ul> 
<p>总的来说，服务降级策略主要用在保障核心服务的可用性，防止分布式服务发生雪崩效应，以及在服务器压力剧增或服务响应超时等情况下保证服务的正常运行。</p> 
<p></p> 
<h2 style="background-color:transparent;">2 设置服务降级策略</h2> 
<p>设置服务降级策略的主要方式有以下两种：</p> 
<p>（1）通过dubbo控制台设置指定服务的降级策略。</p> 
<p>（2）在服务消费端设置接口级别或方法级别的服务降级策略。举例如下。</p> 
<p>设置接口级别的降级策略：</p> 
<pre><code class="language-java">@Reference(mock = "fail:return null")
private TestService testService;

或者

&lt;dubbo:reference id="testService" interface="com.hn.TestService" 
protocol="dubbo"  mock="fail:return null"/&gt;</code></pre> 
<p>设置方法级别的降级策略：</p> 
<pre><code class="language-java">&lt;!-- 对getUserList方法进行降级，其它方法正常调用 --&gt;
&lt;dubbo:reference id="testService" interface="com.hn.TestService" protocol="dubbo"&gt;
    &lt;dubbo:method name="getUserList" mock="fail:return null"/&gt;
&lt;/dubbo:reference&gt;</code></pre> 
<h2></h2> 
<h2 style="background-color:transparent;">3 服务降级策略过程剖析</h2> 
<p>在服务消费端发起远程调用的过程中，服务消费端首先调用MockClusterInvoker的invoker()方法。</p> 
<p>（1）当没设置降级策略时，直接调用DubboInvoker的invoker()方法发起远程调用。</p> 
<p>（2）当服务降级策略为“force策略”时，不进行远程调用，直接执行mock方法，如返回定义的mock值、抛出异常或执行自定义mock类。</p> 
<p>（3）当服务降级策略不是“force策略”时，直接发起远程调用。当调用远程接口失败时（非BIZ_EXCEPTION时），执行mock方法，如返回设置的mock值、抛出异常或执行自定义mock类。</p> 
<p></p> 
<p>MockClusterInvoker的invoker()具体实现如下所示。</p> 
<pre><code class="language-java">public Result invoke(Invocation invocation) throws RpcException {
    Result result;

    String value = getUrl().getMethodParameter(RpcUtils.getMethodName(invocation), MOCK_KEY, Boolean.FALSE.toString()).trim();
    if (ConfigUtils.isEmpty(value)) {
        //no mock
        result = this.invoker.invoke(invocation);
    } else if (value.startsWith(FORCE_KEY)) {
        if (logger.isWarnEnabled()) {
            logger.warn(CLUSTER_FAILED_MOCK_REQUEST,"force mock","","force-mock: " + RpcUtils.getMethodName(invocation) + " force-mock enabled , url : " + getUrl());
        }
        //force:direct mock
        result = doMockInvoke(invocation, null);
    } else {
        //fail-mock
        try {
            result = this.invoker.invoke(invocation);

            //fix:#4585
            if (result.getException() != null &amp;&amp; result.getException() instanceof RpcException) {
                RpcException rpcException = (RpcException) result.getException();
                if (rpcException.isBiz()) {
                    throw rpcException;
                } else {
                    result = doMockInvoke(invocation, rpcException);
                }
            }

        } catch (RpcException e) {
            if (e.isBiz()) {
                throw e;
            }

            if (logger.isWarnEnabled()) {
                logger.warn(CLUSTER_FAILED_MOCK_REQUEST,"failed to mock invoke","","fail-mock: " + RpcUtils.getMethodName(invocation) + " fail-mock enabled , url : " + getUrl(),e);
            }
            result = doMockInvoke(invocation, e);
        }
    }
    return result;
}</code></pre> 
<p></p> 
<p>执行的mock方法为doMockInvoke()，具体实现如下所示。</p> 
<pre><code class="language-java">private Result doMockInvoke(Invocation invocation, RpcException e) {
    Result result;
    Invoker&lt;T&gt; mockInvoker;

    RpcInvocation rpcInvocation = (RpcInvocation)invocation;
    rpcInvocation.setInvokeMode(RpcUtils.getInvokeMode(getUrl(),invocation));

    List&lt;Invoker&lt;T&gt;&gt; mockInvokers = selectMockInvoker(invocation);
    if (CollectionUtils.isEmpty(mockInvokers)) {
        mockInvoker = (Invoker&lt;T&gt;) new MockInvoker(getUrl(), directory.getInterface());
    } else {
        mockInvoker = mockInvokers.get(0);
    }
    try {
        result = mockInvoker.invoke(invocation);
    } catch (RpcException mockException) {
        if (mockException.isBiz()) {
            result = AsyncRpcResult.newDefaultAsyncResult(mockException.getCause(), invocation);
        } else {
            throw new RpcException(mockException.getCode(), getMockExceptionMessage(e, mockException), mockException.getCause());
        }
    } catch (Throwable me) {
        throw new RpcException(getMockExceptionMessage(e, me), me.getCause());
    }
    if (setFutureWhenSync || rpcInvocation.getInvokeMode() != InvokeMode.SYNC) {
        // set server context
        RpcContext.getServiceContext().setFuture(new FutureAdapter&lt;&gt;(((AsyncRpcResult)result).getResponseFuture()));
    }
    return result;
}</code></pre> 
<p> 调用的核心方法为 org.apache.dubbo.rpc.support.MockInvoker#invoke 方法。具体执行分为三种情况：</p> 
<p>（1）return-&gt;返回mock值；</p> 
<p>（2）throw-&gt;抛出异常；</p> 
<p>（3）执行自定义mock类。</p> 
<pre><code class="language-java">public Result invoke(Invocation invocation) throws RpcException {
    if (invocation instanceof RpcInvocation) {
        ((RpcInvocation) invocation).setInvoker(this);
    }
    String mock = getUrl().getMethodParameter(invocation.getMethodName(), MOCK_KEY);

    if (StringUtils.isBlank(mock)) {
        throw new RpcException(new IllegalAccessException("mock can not be null. url :" + url));
    }
    mock = normalizeMock(URL.decode(mock));
    if (mock.startsWith(RETURN_PREFIX)) {
        mock = mock.substring(RETURN_PREFIX.length()).trim();
        try {
            Type[] returnTypes = RpcUtils.getReturnTypes(invocation);
            Object value = parseMockValue(mock, returnTypes);
            return AsyncRpcResult.newDefaultAsyncResult(value, invocation);
        } catch (Exception ew) {
            throw new RpcException("mock return invoke error. method :" + invocation.getMethodName()
                + ", mock:" + mock + ", url: " + url, ew);
        }
    } else if (mock.startsWith(THROW_PREFIX)) {
        mock = mock.substring(THROW_PREFIX.length()).trim();
        if (StringUtils.isBlank(mock)) {
            throw new RpcException("mocked exception for service degradation.");
        } else { // user customized class
            Throwable t = getThrowable(mock);
            throw new RpcException(RpcException.BIZ_EXCEPTION, t);
        }
    } else { //impl mock
        try {
            Invoker&lt;T&gt; invoker = getInvoker(mock);
            return invoker.invoke(invocation);
        } catch (Throwable t) {
            throw new RpcException("Failed to create mock implementation class " + mock, t);
        }
    }
}</code></pre> 
<p></p> 
<h2 style="background-color:transparent;">4 参考文献</h2> 
<p>（1）<a href="https://www.cnblogs.com/studyjobs/p/16390503.html" rel="nofollow" title="https://www.cnblogs.com/studyjobs/p/16390503.html">https://www.cnblogs.com/studyjobs/p/16390503.html</a></p> 
<p>（2）<a href="https://www.cnblogs.com/xfeiyun/p/16070538.html" rel="nofollow" title="https://www.cnblogs.com/xfeiyun/p/16070538.html">https://www.cnblogs.com/xfeiyun/p/16070538.html</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/759f16c327f197ab841f951ef56d767a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">C&#43;&#43;力扣题目700--二叉搜索树中的搜索</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/75faf0ee8006026d2b2dd24d3dea5c17/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">C&#43;&#43;力扣题目98--验证二叉搜索树</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>