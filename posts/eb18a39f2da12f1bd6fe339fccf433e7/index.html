<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>《深入理解计算机系统》第三章笔记 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="《深入理解计算机系统》第三章笔记" />
<meta property="og:description" content="深入理解计算机系统 程序的机器级表示一、程序编码机器级代码 二、数据格式三、访问信息1.操作数指示符2.数据传送指令3.数据传送实例4.压入和弹出栈数据 四、算术和逻辑操作1.加载有效地址2.一元和元操作3.移位操作4.特殊的移位操作（扩展） 五、控制1.条件码2.访问条件码3.跳转指令4.跳转指令的编码5.用条件==控制==来实现条件分支6.用条件==传送==来实现条件分支7.循环8.Switch语句 六、过程（函数）1.运行时栈2.转移控制3.数据传送4.栈上的局部存储5.寄存器中的局部存储空间 七、数组分配和访问1.基本原则2.指针运算3.嵌套的数组4.变长数组 八、异质的数据结构1.结构2.联合3.数据对齐 九、在机器级程序中将控制与数据结合起来1.理解指针2.内存越界引用和缓冲区溢出3.对抗缓冲区溢出攻击4.支持变长栈帧 十、浮点代码 本文为《深入理解计算机系统》第三章 程序的机器级表示的笔记，主要介绍x86平台下的机器代码以及人类可读的表示——汇编语言。通过阅读汇编代码，我们能理解编译器的优化能力，并分析代码中隐含的低效率。 计算器执行机器代码，用字节序列编码低级的操作（包括处理数据、管理内存、读写存储设备上的数据，以及利用网络通信）：
GCC C语言编译器以汇编代码的形式产生输出（汇编代码是机器代码的文本表示，给出程序中的每一条指令）GCC调用汇编器和链接器，根据代码生成可执行的机器代码。 程序的机器级表示 一、程序编码 代码执行流程：
1.C预处理器扩展源代码，插入所有用#include命令指定的文件，并扩展所有用#define声明指定的宏2.编译器产生两个源文件的汇编代码，后缀为s3.汇编器将汇编代码转换成二进制目标代码，后缀为o（目标代码是机器代码的一种形式，包含所有指令的二进制表示，只是还没有填入全局值的地址）4.链接器将两个目标代码与实现库函数（例如printf）的代码合并，并产生最终的可执行代码文件 机器级代码 计算机系统使用了多种不同形式的抽象，利用更简单的抽象模型来隐藏实现的细节：
由指令集体系或指令集架构（ISA）来定义机器级程序的格式和行为，它定义了处理器状态、指令的格式，以及每条指令对状态的影响。机器级程序使用的内存地址是虚拟地址，提供的内存模型看上去是一个非常大的字节数组。 x86的机器代码中，通常对C语言程序员隐藏的处理器状态都是可见的：
程序计数器（通常称为“PC”，在86中用%rip表示）给出将要执行的下一条指令在内存中的地址。整数寄存器文件 包含16个命名的位置，分别存储64位的值，可以存储地址（指针）或整数数据。有的寄存器被用来记录重要的程序状态。条件码寄存器 保存着最近执行的算术或逻辑指令的状态信息。用来实现控制或数据流中的条件语句。向量寄存器 可以存放一个或多个整数或浮点数值。 虽然C语言可以在内存中声明和分配各种数据类型的对象，但是机器代码只是简单的将内存看成一个很大的、按字节寻址的数组
程序内存包含：
程序的可执行机器代码操作系统需要的一些信息用来管理过程调用和返回的运行时栈以及用户分配的内存块。 程序内存用虚拟地址来寻址。在任意给定的时刻，只有有限的一部分虚拟地址被认为是合法的。
操作系统负责管理虚拟地址空间，将虚拟地址翻译成实际处理器内存中的物理地址。
一条机器指令只执行一个非常基本的操作（例如将存放在寄存器中的两个数字相加，在寄存器和寄存器之间传送数据，或是条件分支转移到新的指令地址），编译器必须产生这些指令的序列。
二、数据格式 汇编代码指令都有一个字符的后缀，表明操作数的大小。
例如，数据传送mov指令有四个变种：movb（传送字节）、movw（传送字）、movl（传送双字）和movq（传送四字）
三、访问信息 一个x86的中央处理单元（CPU）包含一组16个存储64位值的通用目的寄存器，用来存储整数数据和指针。这些寄存器都以%r开头（不同命名规则是由于指令集历史演化造成的）
指令可以对这16个寄存器的低位字节中存放的不同大小的数据进行操作： 字节级操作可以访问最低的字节；16位操作可以访问最低的2个字节；32位操作可以访问最低的4个字节；而64位操作可以访问整个寄存器。
对于小于8字节结果的指令，寄存器剩下的字节如何处理？
生成1字节和2字节数字的指令会保持剩下的字节不变生成4字节的数字的指令会把高位4个字节置为0 栈指针%rsp，用来指明运行时栈的结束位置。
1.操作数指示符 操作数（Operand）指示出执行一个操作中要使用的源数据值，以及放置结果的目的位置。
操作数的类型：
立即数（immediate）：用来表示常数值。格式为$整数，例如：%-577代表常数-577寄存器（register）：用来表示某个寄存器的内容，用 ra 来表示任意寄存器a，用引用 R[ ra ] 来表示它的值（将寄存器看成一个数组R，用寄存器标识符作为索引）内存引用：根据计算出来的地址访问某个内存位置。用Mb[ Addr ] 表示对存储在内存中从地址Addr开始的b个字节值的引用。 寻址模式：
有多种不同的寻址模式，允许不同形式的内存引用。
如最常用的 Imm（rb，ri，s），由四个部分组成：
一个立即数偏移Imm一个基址寄存器rb（必须是64位寄存器）一个变址寄存器ri（必须是64位寄存器）一个比例因子s（这里s必须是1、2、4或8） 有效地址被计算为：
Imm &#43; R[ rb ] &#43; R[ ri ] * s" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/eb18a39f2da12f1bd6fe339fccf433e7/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-02-19T22:51:15+08:00" />
<meta property="article:modified_time" content="2023-02-19T22:51:15+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">《深入理解计算机系统》第三章笔记</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>深入理解计算机系统</h4> 
 <ul><li><a href="#_9" rel="nofollow">程序的机器级表示</a></li><li><ul><li><a href="#_13" rel="nofollow">一、程序编码</a></li><li><ul><li><a href="#_20" rel="nofollow">机器级代码</a></li></ul> 
   </li><li><a href="#_46" rel="nofollow">二、数据格式</a></li><li><a href="#_51" rel="nofollow">三、访问信息</a></li><li><ul><li><a href="#1_63" rel="nofollow">1.操作数指示符</a></li><li><a href="#2_86" rel="nofollow">2.数据传送指令</a></li><li><a href="#3_106" rel="nofollow">3.数据传送实例</a></li><li><a href="#4_114" rel="nofollow">4.压入和弹出栈数据</a></li></ul> 
   </li><li><a href="#_132" rel="nofollow">四、算术和逻辑操作</a></li><li><ul><li><a href="#1_134" rel="nofollow">1.加载有效地址</a></li><li><a href="#2_140" rel="nofollow">2.一元和元操作</a></li><li><a href="#3_143" rel="nofollow">3.移位操作</a></li><li><a href="#4_154" rel="nofollow">4.特殊的移位操作（扩展）</a></li></ul> 
   </li><li><a href="#_171" rel="nofollow">五、控制</a></li><li><ul><li><a href="#1_179" rel="nofollow">1.条件码</a></li><li><a href="#2_200" rel="nofollow">2.访问条件码</a></li><li><a href="#3_215" rel="nofollow">3.跳转指令</a></li><li><a href="#4_225" rel="nofollow">4.跳转指令的编码</a></li><li><a href="#5_230" rel="nofollow">5.用条件==控制==来实现条件分支</a></li><li><a href="#6_240" rel="nofollow">6.用条件==传送==来实现条件分支</a></li><li><a href="#7_272" rel="nofollow">7.循环</a></li><li><a href="#8Switch_290" rel="nofollow">8.Switch语句</a></li></ul> 
   </li><li><a href="#_294" rel="nofollow">六、过程（函数）</a></li><li><ul><li><a href="#1_301" rel="nofollow">1.运行时栈</a></li><li><a href="#2_319" rel="nofollow">2.转移控制</a></li><li><a href="#3_335" rel="nofollow">3.数据传送</a></li><li><a href="#4_343" rel="nofollow">4.栈上的局部存储</a></li><li><a href="#5_353" rel="nofollow">5.寄存器中的局部存储空间</a></li></ul> 
   </li><li><a href="#_362" rel="nofollow">七、数组分配和访问</a></li><li><ul><li><a href="#1_363" rel="nofollow">1.基本原则</a></li><li><a href="#2_373" rel="nofollow">2.指针运算</a></li><li><a href="#3_384" rel="nofollow">3.嵌套的数组</a></li><li><a href="#4_392" rel="nofollow">4.变长数组</a></li></ul> 
   </li><li><a href="#_396" rel="nofollow">八、异质的数据结构</a></li><li><ul><li><a href="#1_397" rel="nofollow">1.结构</a></li><li><a href="#2_406" rel="nofollow">2.联合</a></li><li><a href="#3_411" rel="nofollow">3.数据对齐</a></li></ul> 
   </li><li><a href="#_421" rel="nofollow">九、在机器级程序中将控制与数据结合起来</a></li><li><ul><li><a href="#1_422" rel="nofollow">1.理解指针</a></li><li><a href="#2_433" rel="nofollow">2.内存越界引用和缓冲区溢出</a></li><li><a href="#3_443" rel="nofollow">3.对抗缓冲区溢出攻击</a></li><li><a href="#4_451" rel="nofollow">4.支持变长栈帧</a></li></ul> 
   </li><li><a href="#_455" rel="nofollow">十、浮点代码</a></li></ul> 
 </li></ul> 
</div> 
<br> 本文为《深入理解计算机系统》第三章 
<strong>程序的机器级表示</strong>的笔记，主要介绍x86平台下的机器代码以及人类可读的表示——汇编语言。通过阅读汇编代码，我们能理解编译器的优化能力，并分析代码中隐含的低效率。 
<p></p> 
<p>计算器执行机器代码，用<mark>字节序列</mark>编码低级的操作（包括处理数据、管理内存、读写存储设备上的数据，以及利用网络通信）：</p> 
<ul><li>GCC C语言编译器以汇编代码的形式产生输出（汇编代码是机器代码的文本表示，给出程序中的每一条指令）</li><li>GCC调用汇编器和链接器，根据代码生成可执行的机器代码。</li></ul> 
<h2><a id="_9"></a>程序的机器级表示</h2> 
<h3><a id="_13"></a>一、程序编码</h3> 
<p><strong>代码执行流程：</strong></p> 
<ul><li>1.C预处理器扩展源代码，插入所有用<code>#include</code>命令指定的文件，并扩展所有用<code>#define</code>声明指定的宏</li><li>2.编译器产生两个源文件的汇编代码，后缀为s</li><li>3.汇编器将汇编代码转换成二进制目标代码，后缀为o（目标代码是机器代码的一种形式，包含所有指令的二进制表示，只是还没有填入全局值的地址）</li><li>4.链接器将两个目标代码与实现库函数（例如printf）的代码合并，并产生最终的可执行代码文件</li></ul> 
<h4><a id="_20"></a>机器级代码</h4> 
<p><strong>计算机系统使用了多种不同形式的抽象，利用更简单的抽象模型来隐藏实现的细节：</strong></p> 
<ul><li>由指令集体系或指令集架构（ISA）来定义机器级程序的格式和行为，它定义了处理器状态、指令的格式，以及每条指令对状态的影响。</li><li>机器级程序使用的内存地址是虚拟地址，提供的内存模型看上去是一个非常大的字节数组。</li></ul> 
<p><strong>x86的机器代码中，通常对C语言程序员隐藏的处理器状态都是可见的：</strong></p> 
<ul><li><strong>程序计数器</strong>（通常称为“PC”，在86中用%rip表示）给出将要执行的下一条指令在内存中的地址。</li><li><strong>整数寄存器文件</strong> 包含16个命名的位置，分别存储64位的值，可以存储地址（指针）或整数数据。有的寄存器被用来记录重要的程序状态。</li><li><strong>条件码寄存器</strong> 保存着最近执行的算术或逻辑指令的状态信息。用来实现控制或数据流中的条件语句。</li><li><strong>向量寄存器</strong> 可以存放一个或多个整数或浮点数值。</li></ul> 
<p><strong>虽然C语言可以在内存中声明和分配各种数据类型的对象，但是<mark>机器代码只是简单的将内存看成一个很大的、按字节寻址的数组</mark></strong></p> 
<p><strong>程序内存包含</strong>：</p> 
<ul><li>程序的可执行机器代码</li><li>操作系统需要的一些信息</li><li>用来管理过程调用和返回的运行时栈</li><li>以及用户分配的内存块。</li></ul> 
<p>程序内存用虚拟地址来寻址。在任意给定的时刻，只有有限的一部分虚拟地址被认为是合法的。</p> 
<p>操作系统负责管理虚拟地址空间，将虚拟地址翻译成实际处理器内存中的物理地址。</p> 
<p>一条机器指令只执行一个非常基本的操作（例如将存放在寄存器中的两个数字相加，在寄存器和寄存器之间传送数据，或是条件分支转移到新的指令地址），编译器必须产生这些指令的序列。</p> 
<h3><a id="_46"></a>二、数据格式</h3> 
<p><strong>汇编代码指令都有一个字符的后缀，表明操作数的大小。</strong><br> 例如，数据传送mov指令有四个变种：movb（传送字节）、movw（传送字）、movl（传送双字）和movq（传送四字）<br> <img src="https://images2.imgbox.com/89/84/rJ5RIA2r_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_51"></a>三、访问信息</h3> 
<p>一个x86的中央处理单元（CPU）包含一组<strong>16个</strong>存储<strong>64位值</strong>的通用目的寄存器，用来存储整数数据和指针。这些寄存器都以%r开头（不同命名规则是由于指令集历史演化造成的）<br> <img src="https://images2.imgbox.com/60/a9/mRlljTAd_o.png" alt="在这里插入图片描述"><br> <strong>指令可以对这16个寄存器的低位字节中存放的不同大小的数据进行操作：</strong> 字节级操作可以访问最低的字节；16位操作可以访问最低的2个字节；32位操作可以访问最低的4个字节；而64位操作可以访问整个寄存器。</p> 
<p><strong>对于小于8字节结果的指令，寄存器剩下的字节如何处理？</strong></p> 
<ul><li>生成1字节和2字节数字的指令会保持剩下的字节不变</li><li>生成4字节的数字的指令会把高位4个字节置为0</li></ul> 
<p><mark>栈指针%rsp，用来指明运行时栈的结束位置。</mark></p> 
<h4><a id="1_63"></a>1.操作数指示符</h4> 
<p><strong>操作数（Operand）指示出执行一个操作中要使用的源数据值，以及放置结果的目的位置。</strong></p> 
<p><strong>操作数的类型：</strong></p> 
<ul><li><strong>立即数（immediate）</strong>：用来表示常数值。格式为<code>$整数</code>，例如：%-577代表常数-577</li><li><strong>寄存器（register）</strong>：用来表示某个寄存器的内容，用 r<sub>a</sub> 来表示任意寄存器a，用引用 R[ r<sub>a</sub> ] 来表示它的值（将寄存器看成一个数组R，用寄存器标识符作为索引）</li><li><strong>内存引用</strong>：根据计算出来的地址访问某个内存位置。用M<sub>b</sub>[ Addr ] 表示对存储在内存中<mark>从地址Addr开始</mark>的<mark>b个字节值</mark>的引用。</li></ul> 
<p><strong>寻址模式：</strong><br> 有多种不同的寻址模式，允许不同形式的内存引用。<br> 如最常用的 Imm（r<sub>b</sub>，r<sub>i</sub>，s），由四个部分组成：</p> 
<ul><li>一个立即数偏移Imm</li><li>一个基址寄存器r<sub>b</sub>（必须是64位寄存器）</li><li>一个变址寄存器r<sub>i</sub>（必须是64位寄存器）</li><li>一个比例因子s（这里s必须是1、2、4或8）</li></ul> 
<p>有效地址被计算为：</p> 
<blockquote> 
 <p>Imm + R[ r<sub>b</sub> ] + R[ r<sub>i</sub> ] * s</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/75/2e/Aen9ZcUi_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="2_86"></a>2.数据传送指令</h4> 
<p><strong>数据传送指令（Move）：把数据从源位置复制到目的位置，不做任何变化。</strong></p> 
<ul><li>源操作数是一个立即数，存储在寄存器中或内存中。</li><li>目的操作数指定一个位置，寄存器或者内存地址。</li></ul> 
<p><img src="https://images2.imgbox.com/5c/ed/dgqzzXEi_o.png" alt="在这里插入图片描述"><br> movabsq指令能够以任意64位立即数值作为源操作数，并且只能以寄存器作为目的。</p> 
<blockquote> 
 <p>x86限制：传送指令的两个操作数不能都指向内存位置。<br> 因此从内存复制到内存需要两条指令：</p> 
 <ol><li>将源值加载到寄存器</li><li>将寄存器值写入目的位置</li></ol> 
</blockquote> 
<p><strong>零扩展填充（movz）：</strong> 把目的中剩余的字节填充为0.<br> <img src="https://images2.imgbox.com/aa/96/LfL09YJH_o.png" alt="在这里插入图片描述"></p> 
<p><strong>符号扩展填充（movs）：</strong> 把源操作数的最高位复制，进行填充<br> <img src="https://images2.imgbox.com/36/a5/Qih6pBYz_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="3_106"></a>3.数据传送实例</h4> 
<p><img src="https://images2.imgbox.com/51/5f/F7F92pGE_o.png" alt="在这里插入图片描述"><br> 由这段代码可以看出：</p> 
<ul><li>“指针”其实就是地址</li><li>间接引用指针就是将该指针放在一个寄存器中，然后在内存引用中使用这个寄存器</li><li>局部变量通常保存在寄存器中，而不是内存中。访问寄存器比访问内存要快的多</li></ul> 
<h4><a id="4_114"></a>4.压入和弹出栈数据</h4> 
<p>栈操作遵循“后进先出”原则。通过push操作把数据压入栈；通过pop操作删除数据。</p> 
<ul><li>总是从一端插入和删除数据，这端被称为栈顶。</li><li>栈向下增长，栈顶元素的地址是所以栈中元素地址中最低的。</li><li>栈指针%rsp保存着栈顶元素的地址<br> <img src="https://images2.imgbox.com/f2/e3/bGgnOQmH_o.png" alt="在这里插入图片描述"></li></ul> 
<blockquote> 
 <p><strong>压入栈步骤：</strong></p> 
 <ol><li>将栈指针减8</li><li>将值写到新的栈顶地址</li></ol> 
 <p><strong>弹出栈步骤：</strong></p> 
 <ol><li>从栈顶读出数据</li><li>将栈指针加8 <img src="https://images2.imgbox.com/01/32/ch6MEM2S_o.png" alt="在这里插入图片描述"></li></ol> 
</blockquote> 
<h3><a id="_132"></a>四、算术和逻辑操作</h3> 
<p><img src="https://images2.imgbox.com/5d/37/HF7ky3uM_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="1_134"></a>1.加载有效地址</h4> 
<p><strong>加载有效地址（load effective address）</strong> 指令<code>leaq</code>用于将有效地址写入到目的位置。指令形式是从内存读数据（地址）到寄存器</p> 
<p>leaq指令能执行加法和有限形式的乘法：<br> <img src="https://images2.imgbox.com/5a/42/tpNcOhEI_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="2_140"></a>2.一元和元操作</h4> 
<p><strong>一元操作：</strong> 只有一个操作数，既是源又是目的。如自增指令： <code>incq （%rsp）</code><br> <strong>二元指令：</strong> 第二个数既是源又是目的。如减法指令：<code>subq %rax,%rdx</code></p> 
<h4><a id="3_143"></a>3.移位操作</h4> 
<p>移位：先给出移位量，第二项给出要移位的数。移位量可以是一个立即数，或者放在单字节寄存器<code>%cl</code>中。</p> 
<p><strong>左移</strong>有两个名字：SAL和SHL，效果是一样的。<br> <strong>右移：</strong></p> 
<ul><li>算术右移（SAR）：执行算术移位（填上符号位）</li><li>逻辑右移（SHR）：执行逻辑移位（填上0）</li></ul> 
<p>右移操作要求区分有符号和无符号数。这个特性使得补码运算成为实现有符号整数运算的较好方式。</p> 
<h4><a id="4_154"></a>4.特殊的移位操作（扩展）</h4> 
<p>两个64位的整数相乘需要128位来表示。<br> 128位（16字节）的数称为八字（oct word）</p> 
<p>128位乘积以及整数除法的指令：<br> <img src="https://images2.imgbox.com/49/37/nBadKDuD_o.png" alt="在这里插入图片描述"><br> 单操作数乘法指令：一个参数必须在寄存器%rax中，另一个作为指令的源操作数给出。乘积存放在寄存器<code>%rdx</code>（高64位）和<code>%rax</code>（低64位）中。</p> 
<ul><li>无符号数乘法：<code>mulq</code></li><li>补码乘法：<code>imulq</code> （汇编器能通过计算操作数的数目分辨出要用哪条指令）</li></ul> 
<p><strong>存储乘积</strong>需要两个<code>movq</code>指令：一个存储低8个字节，一个存储高8个字节。</p> 
<p><strong>除法：</strong></p> 
<p><img src="https://images2.imgbox.com/99/2a/G6Y3521m_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_171"></a>五、控制</h3> 
<p><strong>机器代码提供两种基本的低级机制来实现有条件的行为：</strong></p> 
<ol><li>测试数据值</li><li>根据测试的结果来改变控制流或数据流</li></ol> 
<p><code>jump</code>指令可以可以改变指令的执行顺序，指定控制应该被传递到程序的某个其他部分</p> 
<h4><a id="1_179"></a>1.条件码</h4> 
<p>除整数寄存器外，CPU还维护着一组<mark>单个位的</mark><code>条件码寄存器</code>，描述了最近的算术或逻辑操作的属性。可以检测这些寄存器来执行条件分支指令。</p> 
<p><strong>常用的条件码：</strong></p> 
<ol><li>CF：<mark>进位标志</mark>。最近的操作使最高位产生了进位。（可用来检查无符号操作的溢出）</li><li>ZF：<mark>零标志</mark>。最近的操作得出的结果为0。</li><li>SF：<mark>符号标志</mark>。最近的操作得到的结果为负数。</li><li>OF：<mark>溢出标志</mark>。最近的操作导致一个补码溢出（正溢出或负溢出）</li></ol> 
<blockquote> 
 <p>图3-10中的指令会设置条件码<br> 而leaq指令不改变任何条件码，因为它是用来进行地址计算的。</p> 
</blockquote> 
<blockquote> 
 <p><strong>只设置条件码而不改变任何其他寄存器的指令：</strong></p> 
 <ol><li>CMP指令根据两个操作数之差来设置条件码。与SUB指令的行为是一样的。</li><li>TEST指令的行为与AND指令一样，只是TEST只设置条件码而不改变寄存器的值。（如 <code>testq %rax,%rax</code> 用来检查%rax是负数、0，还是正数）</li></ol> 
 <p><img src="https://images2.imgbox.com/40/1a/wSXqT7aP_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<h4><a id="2_200"></a>2.访问条件码</h4> 
<p><strong>访问条件码的方法：</strong></p> 
<ul><li>根据条件码的某种组合，将一个字节设置为0或1</li><li>可以条件跳转到程序的某个其他部分</li><li>可以有条件的传送数据</li></ul> 
<p><strong>SET指令：</strong> 根据条件码的某种组合，将一个字节设置为0或1<br> <strong>不同后缀的set指令指明了所考虑的条件码组合</strong>（指令的后缀表示不同的条件而非操作数大小）。</p> 
<p><img src="https://images2.imgbox.com/72/02/pYd82iTb_o.png" alt="在这里插入图片描述"></p> 
<p>一条set指令的目的操作数是一个低位单字节寄存器，或一个字节的内存位置，指令会将这个字节设置成0或1</p> 
<h4><a id="3_215"></a>3.跳转指令</h4> 
<p><strong>跳转指令会导致执行切换到程序中一个全新的位置</strong>，跳转的目的地通常用一个标号表明。<br> <strong>jmp指令是无条件跳转，可以是直接跳转或间接跳转：</strong></p> 
<ul><li>直接跳转：跳转目标是作为指令的一部分编码的（给出一个标号作为跳转目的，如 <code>jmp .L1</code>）</li><li>间接跳转：跳转目标是从寄存器或内存位置中读出的（格式为 * 后面跟一个操作数指示符，如指令<code>jmp *rax</code> 用寄存器%rax的值作为跳转目标；而指令<code>jmp *(%rax)</code> 以%rax中的值作为读地址，从内存中读出跳转目标）</li></ul> 
<p>其他跳转指令都是有条件的，根据条件码的某种组合，或者跳转，或者继续执行代码序列中下一条指令：<br> <img src="https://images2.imgbox.com/d3/e1/6nXQSPCN_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="4_225"></a>4.跳转指令的编码</h4> 
<p>这节内容结合例子好理解些：<br> *<img src="https://images2.imgbox.com/48/ae/vHIoN3Yl_o.png" alt="加粗样式"></p> 
<h4><a id="5_230"></a>5.用条件<mark>控制</mark>来实现条件分支</h4> 
<p><strong>C语言中的if—else语句的通用形式：</strong><br> <img src="https://images2.imgbox.com/7b/46/8HWIyZoT_o.png" alt="在这里插入图片描述"><br> <strong>对应的汇编形式：</strong><br> <img src="https://images2.imgbox.com/68/c7/6f7IIW9W_o.png" alt="在这里插入图片描述"></p> 
<p>求两数之差绝对值的C程序以及对应的汇编程序（C语言里的goto语句类似于汇编的无条件跳转，所以为方便转译汇编增加了goto语句的C代码）：<br> <img src="https://images2.imgbox.com/29/fd/xvDpxuy1_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="6_240"></a>6.用条件<mark>传送</mark>来实现条件分支</h4> 
<p>使用数据的条件转移：计算一个条件操作的两种结果，再根据条件是否满足从中选取一个。</p> 
<blockquote> 
 <p><img src="https://images2.imgbox.com/f9/dd/oDlvv4B6_o.png" alt="在这里插入图片描述"><br> 该表达式用条件控制转移来编译会得到如下形式：<br> <img src="https://images2.imgbox.com/32/31/3UlebdCN_o.png" alt="在这里插入图片描述"><br> 这段代码包含两个代码序列：一个对<code>then-expr</code>求值，另一个对<code>else-expr</code>求值。条件跳转和无条件跳转结合起来使用是为了保证只有一个序列执行。<br> 基于条件传送的代码，会对<code>then-expr</code>和<code>else-expr</code>都求值，最终值的选择基于对<code>test-expr</code>的求值。可以用下面的抽象代码描述：<br> <img src="https://images2.imgbox.com/4f/2f/kesfYmrz_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<blockquote> 
 <p>为什么基于条件数据传送的代码会比基于条件控制转移的代码性能要好：<br> 处理器通过使用流水线来获得高性能，在流水线中，一条指令的处理要经过一系列的阶段，每个阶段执行所需操作的一小部分（例如，从内存取指令、确定指令类型、从内存读数据、执行算术运算、向内存写数据，以及更新程序计数器）。这种方法通过<mark>重叠连续指令</mark>的步骤来获得高性能（也就是说需要并行执行这些操作），要做到这一点，要求能事先确定要执行的指令序列，这样才能保持流水线中充满了待执行的指令。当机器遇到分支时，只有当分支条件求值完成之后，才能决定分支往哪边走。处理器采用非常精密的分支预测逻辑来猜测每条跳转指令是否会执行。<br> 同条件跳转不同，处理器无需预测测试的结果就可以执行条件传送（处理器只是读源值，检查条件码，然后要么更新目的寄存器，要么保持不变）。</p> 
</blockquote> 
<p><strong>条件传送指令：</strong></p> 
<ul><li>每条指令都有两个操作数：源寄存器或者内存地址S，和目的寄存器R。</li><li>指令的结果取决于条件码的值。</li><li>源值可以从内存或源寄存器中读取，但是只有在指定的条件满足时，才会被复制到目的寄存器中。</li><li>源和目的的值可以是16位、32位或64位，不支持单字节的条件传送。</li></ul> 
<p><img src="https://images2.imgbox.com/7d/e5/yGl8a5If_o.png" alt="在这里插入图片描述"><br> 总的来说，条件数据传送提供了一种用条件控制转移来实现条件操作的替代策略。它们只能用于非常受限制的情况，但这些情况还是相当常见的，而且与现代处理器的运行方式更契合。</p> 
<h4><a id="7_272"></a>7.循环</h4> 
<p>汇编中通过使用条件测试和跳转组合起来实现循环的效果。<br> <strong>do-while循环：</strong><br> <img src="https://images2.imgbox.com/e1/13/4omMUoLw_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/8e/73/7xEc097b_o.png" alt="在这里插入图片描述"><br> <strong>while循环：</strong><br> <img src="https://images2.imgbox.com/cf/6d/kNyewYzN_o.png" alt="在这里插入图片描述"><br> 有多种方法将while循环翻译成机器代码：</p> 
<ul><li> <p><strong>跳转到中间（jump to middle）</strong> ：它执行一个无条件跳转跳到循环结尾处的测试，以此来执行初始的测试。<img src="https://images2.imgbox.com/85/8c/d75povjM_o.png" alt="在这里插入图片描述"></p> </li><li> <p><strong>guarded-do</strong>：首先使用条件分支，如果初始条件不成立就跳过循环，把代码变换为do-while循环。<img src="https://images2.imgbox.com/77/fd/jmLbjg3F_o.png" alt="在这里插入图片描述"><br> <strong>for循环：</strong><br> <img src="https://images2.imgbox.com/d9/c6/RujmhzZD_o.png" alt="在这里插入图片描述"><br> for循环的行为与while循环的代码的行为一样：<br> <img src="https://images2.imgbox.com/f9/cf/yKYyKBCN_o.png" alt="在这里插入图片描述"></p> </li></ul> 
<h4><a id="8Switch_290"></a>8.Switch语句</h4> 
<p><strong>Switch语句根据一个整数索引值进行多重分支。通过使用跳转表（jump table）这种数据结构使得实现更高效</strong>（在于执行开关语句的时间与开关情况的数量无关）。<br> <strong>跳转表：</strong> 跳转表是一个数组，表项 i 是一个代码段的地址，这个代码段实现当开关索引值等于 i 时程序应该采取的动作。<br> 程序代码用开关索引值来执行一个跳转表内的数组引用，确定跳转指令的目标。</p> 
<h3><a id="_294"></a>六、过程（函数）</h3> 
<p><strong>过程（函数）必须拥有的机制（假设过程P调用过程Q,Q 执行后返回P）：</strong></p> 
<ul><li><strong>传递控制</strong> 在进入过程Q时，程序计数器必须被设置为Q的代码的起始地址；在返回时，要把程序计数器设置为P中调用Q后面的那条指令的地址。</li><li><strong>传递数据</strong> P必须能够向Q提供一个或多个参数，Q必须能够向P返回一个值。</li><li><strong>分配和释放内存</strong> 在开始时，Q可能需要为局部变量分配空间，而在返回前，又必须释放这些内存。</li></ul> 
<h4><a id="1_301"></a>1.运行时栈</h4> 
<p>C语言的过程调用使用了<mark>栈数据结构提供的后进先出</mark>的内存管理原则。<br> 程序用栈来管理它的过程所需要的存储空间，栈和程序计数器存放着传递控制和数据、分配内存所需要的信息。</p> 
<blockquote> 
 <p>在P调用Q的例子中，当Q在执行时，P以及所有在向上追溯到P的调用链中的过程，都是暂时被挂起的。当Q运行时，它只需要为局部变量分配新的存储空间，或者设置到另一个过程的调用。当Q返回时，任何它所分配的局部存储空间都可以被释放。<br> 当P调用Q时，控制和数据信息添加到栈尾。当P返回时，这些信息会释放掉。</p> 
</blockquote> 
<ul><li> <p>x86-64的栈向低地址方向增长，而栈指针%rsp指向栈顶元素。</p> </li><li> <p>可以用pushq和popq指令将数据存入栈中或是从栈中取出。</p> </li><li> <p>将栈指针减小一个适当的量可以为没有指定初始值的数据在栈上分配空间。可以通过增加栈指针来释放空间</p> </li><li> <p>当x86-64过程需要的存储空间超出寄存器能够存放的大小时，就会在栈上分配空间。这个部分称为过程的栈帧。<br> <img src="https://images2.imgbox.com/f5/c1/yyGBYlLd_o.png" alt="在这里插入图片描述"></p> </li><li> <p>当过程P调用Q时，会把返回地址压入栈中，指明当Q返回时，要从P程序的哪个位置继续执行。Q的代码会扩展当前栈的边界，分配它的栈帧所需的空间。在这个空间中，它可以保存寄存器的值，分配局部变量空间，为它调用的过程设置参数。</p> </li><li> <p>通过寄存器，过程P可以传递最多6个整数值（指针或者整数），如果Q需要更多参数，P可以在调用Q之前在自己的栈帧里存储好这些参数。</p> </li></ul> 
<h4><a id="2_319"></a>2.转移控制</h4> 
<p><strong>将控制从函数P转换到函数Q：把程序计数器（PC）设置为Q代码的起始位置。</strong></p> 
<p><strong>Q返回时，处理器必须记录好它需要继续执行P的代码的位置：</strong></p> 
<ul><li>x86里用指令call Q来记录该信息，首先将地址A压入栈中，并将PC设置为Q的起始地址。</li><li>压入的地址被称为起始地址，是紧跟在call指令后面那条指令的地址。对应的指令ret会从栈中弹出地址A，并把PC设置为A。</li></ul> 
<p><strong>call和ret指令的一般形式：</strong><br> <img src="https://images2.imgbox.com/58/ae/ZCsqR5ne_o.png" alt="在这里插入图片描述"></p> 
<p>call指令用来指明被调用过程起始的指令地址。有直接调用和间接调用：</p> 
<ul><li>直接调用的目标是一个标号</li><li>间接调用是 * 后面跟一个操作数指示符</li></ul> 
<h4><a id="3_335"></a>3.数据传送</h4> 
<p>过程调用还可能包括<strong>把数据作为参数传递</strong>，而从过程返回还有可能包括<strong>返回一个值。</strong><br> x86中，大部分过程间的数据传送是通过寄存器实现的。通过寄存器最多可以传递6个整型参数。<br> <strong>寄存器的使用是有特殊顺序的</strong>。寄存器使用的名字取决于要传递的数据类型的大小。<br> 如下图，会根据参数在参数列表中的顺序为它们分配寄存器。通过64位寄存器适当的部分访问小于64位的参数。（如果第一个参数是32位的，那么可以通过%edi来访问它）<br> <img src="https://images2.imgbox.com/89/44/jROFPciw_o.png" alt="在这里插入图片描述"><br> 对不止有6个参数的函数来说，超出的参数就要通过栈来传递（假设P调用Q，有n个整型整数，且n&gt;6。那P的代码分配的栈帧必须要能容纳7到n号参数的存储空间。要把参数1 ~ 6复制到对应的寄存器，把参数7 ~ n放到栈上，而参数7位于栈顶）。<br> 通过栈传递参数时，所以的数据大小都向8的倍数对齐。</p> 
<h4><a id="4_343"></a>4.栈上的局部存储</h4> 
<p><strong>局部数据必须存放在内存中（而非寄存器）的常见情况：</strong></p> 
<ul><li>寄存器不够存放所有的本地数据</li><li>对一个局部变量使用地址运算符‘&amp;’，因因此必须能够为它产生一个地址</li><li>某些局部变量是数组或结构，因此必须能够通过数组或结构引用被访问到</li></ul> 
<p>过程通过减小栈指针在栈上分配空间。分配的结果作为栈帧的一部分，标号为“局部变量”。<br> 运行时栈提供了一种简单的、在需要时分配、函数完成时释放局部存储的机制。</p> 
<h4><a id="5_353"></a>5.寄存器中的局部存储空间</h4> 
<p><strong>寄存器是唯一被所有过程共享的资源。</strong> 因此必须确保当一个过程（调用者）调用另一个过程（被调用者）时，被调用者不会<mark>覆盖</mark>调用者稍后会使用的寄存器值。<br> 为此x86采用了一组统一的<strong>寄存器使用惯例</strong>，所有的过程（包括程序库）都必须遵守：</p> 
<ul><li>寄存器%rbx、%rbp和%r12 ~ %r15被划分为<mark>被调用者保存寄存器</mark>。</li><li>所有其他的寄存器，除了栈指针%rsp，都分类为<mark>调用者保存寄存器</mark>，任何函数都能修改它们。</li></ul> 
<p><strong>递归过程：</strong> 递归调用一个函数本身与调用其他函数是一样的。<br> 栈规则提供了一种机制，每次函数调用都有它自己私有的状态信息（保存的返回位置和被调用者保存寄存器的值）存储空间。如果需要，它还可以提供局部变量的存储。栈分配和释放的规则很自然地就与函数调用----返回的顺序匹配，这种实现函数调用和返回的方法甚至对更复杂的情况也适用，包括相互递归调用。</p> 
<h3><a id="_362"></a>七、数组分配和访问</h3> 
<h4><a id="1_363"></a>1.基本原则</h4> 
<p>对于数据类型T和整型常数N的数组：<code>T A[N];</code></p> 
<ul><li>它在内存中分配了一个L*N字节的连续区域（L是数据类型T的大小，单位为字节）</li><li>它引入了标识符A，可以用A来作为执行数组开头的指针，指针的值为X<sub>a</sub><br> 可以用0 ~ N-1的整数索引来访问该数组元素。数组元素会被存放在地址为X<sub>a</sub> + L*i的地方。</li></ul> 
<p><strong>x86的内存引用指令可以用来简化数组访问：</strong> 例如对于一个int型的数组E，地址存放在寄存器%rdx中，i存放在寄存器%rcx中<br> 指令<code>movl(%rdx,%rcx,4),%eax</code> 会执行地址计算 X<sub>E</sub> +4i，读这个内存位置的值，并将结果存放到寄存器<code>%eax</code>中</p> 
<h4><a id="2_373"></a>2.指针运算</h4> 
<p><strong>对指针进行运算，计算出来的值会根据该指针引用的数据类型的大小进行伸缩：</strong> 例如，p是一个指向类型为T的数据的指针，p的值为X<sub>p</sub> ，那么表达式p+i的值为X<sub>p</sub> + L*i，这里L是数据类型T的大小。</p> 
<p><strong>单操作数操作符‘&amp;’和‘*’可以产生指针和间接引用指针：</strong></p> 
<ul><li>对于表示某个对象的表达式Expr，&amp;Expr是给出该对象地址的一个指针。</li><li>对于一个表示地址的表达式AExpr，*AExpr给出该地址处的值。</li></ul> 
<p>数组引用A[i]等同于表达式*(A+i)。它计算第i个数组元素的地址，然后访问这个内存位置。</p> 
<p>假设整型数组E的起始地址和整数索引i分别存放在寄存器%rdx和%rcx中。结果存放在寄存器%eax（如果是数据）或寄存器%rax（如果是指针）中。与E有关的表达式以及汇编代码：<img src="https://images2.imgbox.com/c5/7a/BKznse9l_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="3_384"></a>3.嵌套的数组</h4> 
<p>二维数组在内存中按照“行优先”的顺序排列<br> 访问多维数组，编译器会以数组起始为基地址，（可能需要经过伸缩的）偏移量为索引，产生计算期望的元素的偏移量，然后使用某种MOV指令。<br> 对数组：<code>T D[R][C];</code></p> 
<p>它的数组元素D [i][j]的内存地址为：&amp;D[i][j] = x<sub>D</sub>+L(C*i+j)</p> 
<h4><a id="4_392"></a>4.变长数组</h4> 
<p>变长数组：<strong>允许数组的维度是表达式，在数组被分配时才计算出来。</strong><br> 变量n必须在数组 A [n][n]之前，这样函数就可以在遇到这个数组的时候计算出数组的维度。<br> 变长数组与定长数组的不同在于：多态的版本必须用乘法指令对i伸缩n倍，而不能用一系列的移位和加法。</p> 
<h3><a id="_396"></a>八、异质的数据结构</h3> 
<h4><a id="1_397"></a>1.结构</h4> 
<p><strong>struct将可能不同类型的对象聚合到一个对象中。用名字来引用结构的各个组成部分。</strong></p> 
<ul><li>结构的所有组成部分都存放在内存中一段连续的区域内，而指向结构的指针就是结构第一个字节的地址。</li><li>编译器维护关于每个结构类型的信息，指示每个字段的字节偏移。它以这些偏移作为内存引用指令中的位移，从而产生对结构元素的引用。</li></ul> 
<p><img src="https://images2.imgbox.com/29/cf/2dZmBmnP_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/cc/b3/WLtKLEus_o.png" alt="在这里插入图片描述"><br> 结构的各个字段的选取完全是在编译时处理的。机器代码不包含关于字段声明或字段名字的信息。</p> 
<h4><a id="2_406"></a>2.联合</h4> 
<p><strong>union允许以多种数据类型来引用一个对象。一个联合的总的大小等于它最大字段的大小。</strong><br> <img src="https://images2.imgbox.com/87/99/TZr4PTar_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="3_411"></a>3.数据对齐</h4> 
<p>数据对齐：<strong>限制某种类型对象地址必须是某个值K（通常是2、4或8）的倍数。</strong> 这种对齐限制简化了处理器和内存系统之间接口的硬件设计。</p> 
<blockquote> 
 <p>如果我们能保证将所有的double类型数据的地址对齐成8的倍数，那么就可以用一个内存操作来读或者写值了。否则可能需要执行两次内存访问，因为对象可能被分放在两个8字节内存块中。</p> 
</blockquote> 
<p>对齐原则是任何K字节的基本对象的地址必须是K的倍数。<br> <img src="https://images2.imgbox.com/a9/ce/fvcw0Bgs_o.png" alt="在这里插入图片描述"></p> 
<ul><li>对于包含结构的代码，编译器可能需要在字段的分配中插入间隙，以保证每个结构元素都满足它的对齐要求。而结构本身对它的起始地址也有一些对齐要求。<br> <img src="https://images2.imgbox.com/76/5e/qIT2sSxz_o.png" alt="在这里插入图片描述"></li><li>编译器结构的末尾也可能需要一些填充，以使结构数据中的每个元素都会满足它的对齐要求。</li></ul> 
<h3><a id="_421"></a>九、在机器级程序中将控制与数据结合起来</h3> 
<h4><a id="1_422"></a>1.理解指针</h4> 
<p><strong>指针和指针映射到机器代码的关键原则：</strong></p> 
<ul><li><strong>每个指针都对应一个类型</strong>。这个类型表明该指针指向的是哪一类对象。</li><li><strong>每个指针都有一个值</strong>。这个值是某个指定类型的对象的地址。特殊的NULL（0）值表示该指针没有指向任何地方。</li><li><strong>指针用‘&amp;’运算符创建（直接获取地址）</strong>。这个运算符可以用到任何lvalue类的C表达式上，lvalue意指可以出现在赋值语句左边的表达式（如变量、结构、联合或者数组）</li><li><strong>*操作符用于间接引用指针（间接通过地址取里面的值）</strong> 。结果是一个值，类型与该指针的类型一致。间接引用是用内存引用来实现的，要么是存储到一个指定的地址，要么是从指定的地址读取。</li><li><strong>数组与指针紧密联系</strong>。一个数组的名字可以像一个指针变量一样引用（但是不能修改）。数组引用（如a[3]）与指针运算和间接引用（例如*（a+3））有一样的效果。数组引用和指针运算都需要用对象大小对偏移量进行伸缩。（如表达式p+i得到的地址计算为<code>p+L*i</code> ，L是p的数据类型的大小）</li><li><strong>将指针强转类型后只改变它的类型，而不改变它的值。</strong> 强制类型转换的一个效果是改变指针运算的伸缩。（例如char *类型的指针p，值为P，那么表达式（int *）p+7计算为P+28，而（int *）（p+7）计算为P+7。）</li><li><strong>指针也可以指向函数</strong>。这提供了一个很强大的存储和向新代码传递引用的功能，这些引用可以被程序的某个其他部分调用。函数指针的值是该函数机器代码表示中第一条指令的地址。</li></ul> 
<h4><a id="2_433"></a>2.内存越界引用和缓冲区溢出</h4> 
<p><strong>C对于数组引用不进行任何边界检查，而且局部变量和状态信息（例如保存的寄存器值和返回地址）都存放在栈中。</strong> 对越界的数组元素的写操作会破坏存储在栈中的状态信息。当程序使用这个被破坏的状态，试图重新加载寄存器或执行ret指令时，会出现很严重的错误。</p> 
<p><strong>缓冲区溢出（buffer overflow）：</strong> 通常在栈中分配某个字符数组来保存一个字符串，但是字符串的长度超出了为数组分配的空间。</p> 
<blockquote> 
 <p>缓冲区溢出的一个更加致命的使用就是让程序执行它本来不愿意执行的函数。这是一种最常见的计算机网络攻击系统安全的方法。通常，输入给程序一个字符串，这个字符串包含一些可执行代码的字节编码，称为攻击代码，另外，还有一些字节会用一个指向攻击代码的指针覆盖返回地址。那么，执行ret指令的效果就是跳转到攻击代码。<br> 在一种攻击形式中，攻击代码会使用系统调用启动一个shell程序，给攻击者提供一组操作系统函数。在另一种攻击形式中，攻击代码会执行一些未授权的任务，修复对栈的破坏，然后第二次执行ret指令，（表面上）正常返回到调用者。</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/c5/24/1fD1vBjC_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="3_443"></a>3.对抗缓冲区溢出攻击</h4> 
<p><img src="https://images2.imgbox.com/f1/54/1xhXaboj_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/ef/61/D5xFTz8d_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/24/c5/5fxiYQBQ_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/fa/2f/aKseohnk_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/b2/a9/4I6IIb5p_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="4_451"></a>4.支持变长栈帧</h4> 
<p><strong>一些函数需要的局部存储是变长的</strong>。例如当函数调用alloca时。alloca是一个标准库函数，可以在栈上分配任意字节数量的存储。当函数声明一个局部变长数组时，也会发生这种情况。<br> <img src="https://images2.imgbox.com/5f/76/eIg52Q05_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_455"></a>十、浮点代码</h3> 
<p><strong>浮点数在机器级程序中使用另外一套寄存器和指令，其余均与之前一致。</strong></p> 
<p><strong>浮点数寄存器：</strong><br> <img src="https://images2.imgbox.com/5a/30/BlVZwZUU_o.png" alt="在这里插入图片描述"></p> 
<p><strong>浮点传送和转换操作：</strong><br> <img src="https://images2.imgbox.com/6e/00/Iff0lLiy_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/8e/87/DBXmZuaG_o.png" alt="在这里插入图片描述"></p> 
<p><strong>定义和使用浮点常数：</strong><br> <img src="https://images2.imgbox.com/99/f6/UkLfcyLu_o.png" alt="在这里插入图片描述"></p> 
<p><strong>浮点运算操作：</strong><br> <img src="https://images2.imgbox.com/e1/05/KT2jAcWh_o.png" alt="在这里插入图片描述"></p> 
<p><strong>浮点代码中使用位级操作：</strong><br> <img src="https://images2.imgbox.com/3f/63/hqK2UBZ1_o.png" alt="在这里插入图片描述"></p> 
<p><strong>浮点比较操作：</strong><br> <img src="https://images2.imgbox.com/20/f6/q1TWpjgY_o.png" alt="在这里插入图片描述"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/959084d5033da0c679f50a96bc3ce025/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Java指令重排测试类</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/cc20db89d571c3926553c27338cbf226/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【论文阅读】2023-ICLR：TimesNet</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>