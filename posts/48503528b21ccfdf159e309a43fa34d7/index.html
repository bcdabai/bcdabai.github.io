<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>const关键字总结 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="const关键字总结" />
<meta property="og:description" content="在C语言中
const是C语言中总结
1.修饰的变量，使其具有常属性，使变量的值不能直接被改变。但是可以通过指针来间接的修改变量的值。
2.便于进行类型检查(在编译时进行类型检查)，使编译对处理内容有更多的了解，保护被修饰的东西，防止被意外修改，增强程序的健壮性。
3.方便的进行参数的调整和修改(类似于宏定义)
作用1说明：
修饰的变量，使其具有常属性，使变量的值不能直接被改变。但是可以通过指针来间接的修改变量的值
例如：
const int t=10;
//在以后的代码中，程序不可直接对i进行修改
//但是可通过指针来间接的修改i变量中存的值
t=2; //会报错
int *p=(int *)&amp;t;
*p=2; //在此处就将i中的值存成2了
const修饰指针变量：
int main()
{
int a = 10;
const int *p = &amp;a; //const修饰int *，即p的指向，因而p指向的内容即通过pa解引用后不能被修改，但是p中存的内容可以改变，即p的指向可以改变
int * const q=&amp;a; //const修饰*，即q变量，因而q里存的内容不能变，即q的指向不能改变，但是q指向的内容即a中的内容可以修改。
p&#43;&#43;;//正确
(*p)&#43;&#43;;//错误
q&#43;&#43;;//错误
(*q)&#43;&#43;;//正确
return 0;
}
所以看const修饰谁，要看const右面有什么
比如：
int **const* p; 则通过*p来修改对应的内容则报错
int **const** p; 则通过**p来修改内容则会报错
通过const的特性，const可以在很多地方派上用场
比如在传参时，不想通过函数来改变实参值，在传实参地址时，形参接收在前可加const修饰，这样就不会在函数里通过解引用来修改实参值了
在C语言中，const不用来修饰函数，原因看C&#43;&#43;的用法
在C&#43;&#43;中
在c&#43;&#43;中：
1.const修饰变量的用法和作用与c语言一样，但是有一点不同
#include
using namespace std;
int main()" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/48503528b21ccfdf159e309a43fa34d7/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-10-07T15:50:00+08:00" />
<meta property="article:modified_time" content="2019-10-07T15:50:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">const关键字总结</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="cnblogs_post_body" class="blogpost-body"> 
 <p>　　在C语言中</p> 
 <p>　　const是C语言中总结</p> 
 <p>　　1.修饰的变量，使其具有常属性，使变量的值不能直接被改变。但是可以通过指针来间接的修改变量的值。</p> 
 <p>　　2.便于进行类型检查(在编译时进行类型检查)，使编译对处理内容有更多的了解，保护被修饰的东西，防止被意外修改，增强程序的健壮性。</p> 
 <p>　　3.方便的进行参数的调整和修改(类似于宏定义)</p> 
 <p>　　作用1说明：</p> 
 <p>　　修饰的变量，使其具有常属性，使变量的值不能直接被改变。但是可以通过指针来间接的修改变量的值</p> 
 <p>　　例如：</p> 
 <p>　　const int t=10;</p> 
 <p>　　//在以后的代码中，程序不可直接对i进行修改</p> 
 <p>　　//但是可通过指针来间接的修改i变量中存的值</p> 
 <p>　　t=2; //会报错</p> 
 <p>　　int *p=(int *)&amp;t;</p> 
 <p>　　*p=2; //在此处就将i中的值存成2了</p> 
 <p>　　const修饰指针变量：</p> 
 <p>　　int main()</p> 
 <p>　　{<!-- --></p> 
 <p>　　int a = 10;</p> 
 <p>　　const int *p = &amp;a; //const修饰int *，即p的指向，因而p指向的内容即通过pa解引用后不能被修改，但是p中存的内容可以改变，即p的指向可以改变</p> 
 <p>　　int * const q=&amp;a; //const修饰*，即q变量，因而q里存的内容不能变，即q的指向不能改变，但是q指向的内容即a中的内容可以修改。</p> 
 <p>　　p++;//正确</p> 
 <p>　　(*p)++;//错误</p> 
 <p>　　q++;//错误</p> 
 <p>　　(*q)++;//正确</p> 
 <p>　　return 0;</p> 
 <p>　　}</p> 
 <p>　　所以看const修饰谁，要看const右面有什么</p> 
 <p>　　比如：</p> 
 <p>　　int **const* p; 则通过*p来修改对应的内容则报错</p> 
 <p>　　int **const** p; 则通过**p来修改内容则会报错</p> 
 <p>　　通过const的特性，const可以在很多地方派上用场</p> 
 <p>　　比如在传参时，不想通过函数来改变实参值，在传实参地址时，形参接收在前可加const修饰，这样就不会在函数里通过解引用来修改实参值了</p> 
 <p>　　在C语言中，const不用来修饰函数，原因看C++的用法</p> 
 <p>　　在C++中</p> 
 <p>　　在c++中：</p> 
 <p>　　1.const修饰变量的用法和作用与c语言一样，但是有一点不同</p> 
 <p>　　#include</p> 
 <p>　　using namespace std;</p> 
 <p>　　int main()</p> 
 <p>　　{<!-- --></p> 
 <p>　　const int a = 1;</p> 
 <p>　　int* p = (int *)(&amp;a);</p> 
 <p>　　*p = 2;</p> 
 <p>　　cout &lt;&lt; "value of p: " &lt;&lt; *p &lt;&lt; endl;</p> 
 <p>　　cout &lt;&lt; "value of a: " &lt;&lt; a &lt;&lt; endl;</p> 
 <p>　　cout &lt;&lt; "address of p: " &lt;&lt; p &lt;&lt; endl;</p> 
 <p>　　cout &lt;&lt; "address of a: " &lt;&lt; &amp;a &lt;&lt; endl;</p> 
 <p>　　return 0;</p> 
 <p>　　}</p> 
 <p>　　输出</p> 
 <p>　　/*value of p: 2</p> 
 <p>　　value of a: 1</p> 
 <p>　　address of p: 0x7fbffff7fc</p> 
 <p>　　address of a: 0x7fbffff7fc</p> 
 <p>　　由答案可知，a并没有像c语言中一样，被p修改为2，这是为什么呢?</p> 
 <p>　　原因: const int a其实是保存在符号表中,无内存地址,但自己对a进行&amp;a,那么编译器会为a分配一个地址,但取a的值依然是从符号表中取值,而用指针int *p=&amp;a;</p> 
 <p>　　*p=4这个值是改变a的内存所表示值,不会改变符号表中a的值。</p> 
 <p>　　#include</p> 
 <p>　　using namespace std;</p> 
 <p>　　const int a = 3; //此时a是全局变量</p> 
 <p>　　int main()</p> 
 <p>　　{<!-- --></p> 
 <p>　　//const int a = 3;</p> 
 <p>　　int* p = const_cast(&amp;a);</p> 
 <p>　　*p = 4;</p> 
 <p>　　cout &lt;&lt; "value of p: " &lt;&lt; *p &lt;&lt; endl;</p> 
 <p>　　cout &lt;&lt; "value of a: " &lt;&lt; a &lt;&lt; endl;</p> 
 <p>　　cout &lt;&lt; "address of p: " &lt;&lt; p &lt;&lt; endl;</p> 
 <p>　　cout &lt;&lt; "address of a: " &lt;&lt; &amp;a &lt;&lt; endl;</p> 
 <p>　　return 0;</p> 
 <p>　　}</p> 
 <p>　　输出结果</p> 
 <p>　　会发生如此运行时错误</p> 
 <p>　　由此可见，在c++中全局const变量和局部const变量的编译器处理的方法是不一样的。因为全局const变量是不分配内存地址的，它编译器放置在符号表中作为编译期常量，全局const变量放在只读数据段中，受到只读数据段的权限保护，当你修改一个只读数据段中的内容时，会得到一个运行时错误。而局部const变量是放在堆栈之中，因为在内存中有地址，通过修改地址中的值可以达到修改const所指内存中值的目的。</p> 
 <p>　　2.此外，在c++中，const还可用来修饰成员函数，其用法是放在形参列表之后，</p> 
 <p>　　用来修饰隐式传入构造函数中的this指针，表明在函数调用的过程中，不可对this指向的内容进行修改，即不可修改调用这个构造函数对象中的内容。</p> 
 <p>　　被const修饰的成员函数，称作为const类型的成员函数</p> 
 <p>　　例如：<span style="color:#ffffff;">无锡人流哪家好 http://www.wxbhffk.com/</span></p> 
 <p>　　class Date</p> 
 <p>　　{<!-- --></p> 
 <p>　　public:</p> 
 <p>　　Date(int year = 1900, int month = 1, int day = 1)</p> 
 <p>　　{<!-- --></p> 
 <p>　　_year = year;</p> 
 <p>　　_month = month;</p> 
 <p>　　_day = day;</p> 
 <p>　　cout &lt;&lt; "Date(int,int,int):" &lt;&lt; this &lt;&lt; endl;</p> 
 <p>　　}</p> 
 <p>　　// 在const成员函数中，不能修改类的任何成员变量</p> 
 <p>　　void PrintDate()const</p> 
 <p>　　{<!-- --></p> 
 <p>　　//_year++;</p> 
 <p>　　//即this-&gt;_year++; 会报错</p> 
 <p>　　// 在函数被修饰后，this的类型为 const Date* const (因为this指针本来就是const型的this不可修改指向，后面的const表明this指向里的内容也不可修改)</p> 
 <p>　　_day++; //√</p> 
 <p>　　cout &lt;&lt; _year &lt;&lt; "-" &lt;&lt; _month &lt;&lt; "-" &lt;&lt; _day &lt;&lt; endl;</p> 
 <p>　　}</p> 
 <p>　　private:</p> 
 <p>　　int _year;</p> 
 <p>　　int _month;</p> 
 <p>　　mutable int _day; //在成员变量名前加mutable关键字后，成员函数即使加const也可修改_day的值</p> 
 <p>　　};</p> 
 <p>　　int main()</p> 
 <p>　　{<!-- --></p> 
 <p>　　Date d1;</p> 
 <p>　　d1. PrintDate();</p> 
 <p>　　}</p> 
 <p>　　用const修饰成员函数有以下注意事项：</p> 
 <p>　　1&gt;const不可修饰其他类外函数(对有this的函数才有用)。不可调用构造函数，因为构造函数目的就是要修改成员变量。</p> 
 <p>　　2&gt;const对象不可以调用非const成员函数。因为普通成员函数是可以修改成员变量的，如果允许修改，拿不可修改的const对象就会被修改了，不安全。</p> 
 <p>　　3&gt;非const对象可以调用const成员函数。因为普通变量可读可写，const函数只允许对调用对象进行读，因此没有什么不可。</p> 
 <p>　　4&gt;const成员函数不可以调用非const成员函数。普通函数可对对象进行修改，在调用普通函数时可能会修改对象，因此const成员函数不能调用非const成员函数。</p> 
 <p>　　5&gt;非const成员函数可以调用const成员函数</p> 
 <p>　　const 变量与 define 宏定义的区别：</p> 
 <p>　　(1) 编译器处理方式不同</p> 
 <p>　　define宏是在预处理阶段展开。</p> 
 <p>　　const常量是编译运行阶段使用。</p> 
 <p>　　(2) 类型和安全检查不同</p> 
 <p>　　define宏没有类型，不做任何类型检查，仅仅是展开。</p> 
 <p>　　const常量有具体的类型，在编译阶段会执行类型检查。</p> 
 <p>　　(3) 存储方式不同</p> 
 <p>　　define宏仅仅是展开，有多少地方使用，就展开多少次，不会分配内存。</p> 
 <p>　　const常量会在内存中分配(可以是堆中也可以是栈中)</p> 
 <p>　　const修饰可以节省空间，避免不必要的内存分配(与宏定义的本质区别)</p> 
 <p>　　宏的优点：</p> 
 <p>　　1.增强代码的复用性。</p> 
 <p>　　2.提高性能。</p> 
 <p>　　缺点：</p> 
 <p>　　1.不方便调试宏。(因为预编译阶段进行了替换)</p> 
 <p>　　2.导致代码可读性差，可维护性差，容易误用。</p> 
 <p>　　3.没有类型安全的检查</p> 
</div> 
<p>转载于:https://www.cnblogs.com/djw12333/p/11630665.html</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/674ff275af4475bdcd11507150ac2cca/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">腾讯股票API获取上证指数</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e162f6071ea43f87f2e45cfb175d1b71/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Qt--多线程间的互斥</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>