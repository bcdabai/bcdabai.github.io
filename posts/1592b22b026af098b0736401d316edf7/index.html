<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>《剑指offer》——刷题日记 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="《剑指offer》——刷题日记" />
<meta property="og:description" content="本期，给大家带来的是《剑指offer》几道题目的讲解。希望对大家有所帮助！！！
本文目录
（一）JZ36 二叉搜索树与双向链表
1、题意分析
2、思路讲解
3、代码演示
4、最终结果
（二）BM6 判断链表中是否有环
1、题意分析
2、思路讲解
3、代码演示
4、最终结果
（三）JZ23 链表中环的入口结点
1、题意分析
2、思路讲解
3、代码演示
4、最终结果
（四 ）HJ43 迷宫问题
1、题意分析
2、思路讲解
3、代码演示
4、最终结果
（一）JZ36 二叉搜索树与双向链表（经典题目） 首先，我们第一题给大家讲述的是关于一道 二叉搜索树与双向链表 的问题。首先，拿到题我们还是先从题干入手，理解好题意才能更好进行解题操作。
题目如下：
输入描述：
二叉树的根节点
返回值描述：
双向链表的其中一个头节点。
示例1
输入：{10,6,14,4,8,12,16} 返回值：From left to right are:4,6,8,10,12,14,16;From right to left are:16,14,12,10,8,6,4; 说明：输入题面图中二叉树，输出的时候将双向链表的头节点返回即可。 示例2
输入：{5,4,#,3,#,2,#,1} 返回值： From left to right are:1,2,3,4,5;From right to left are:5,4,3,2,1; 说明： 5 / 4 / 3 / 2 / 1 树的形状如上图 1、题意分析 首先我们第一看到这个题目就会发现，如果我们对其进行中序遍历，则得到的结果为【4,6,8,10,12,14,16】，此时就符合我们题干的要求，再次把它转化为双向链表即可。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/1592b22b026af098b0736401d316edf7/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-04-21T11:14:10+08:00" />
<meta property="article:modified_time" content="2023-04-21T11:14:10+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">《剑指offer》——刷题日记</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p><strong>本期，给大家带来的是《剑指offer》几道题目的讲解。希望对大家有所帮助！！！</strong></p> 
</blockquote> 
<p id="main-toc"><strong>本文目录</strong></p> 
<p id="%EF%BC%88%E4%B8%80%EF%BC%89JZ36%C2%A0%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8-toc" style="margin-left:0px;"><a href="#%EF%BC%88%E4%B8%80%EF%BC%89JZ36%C2%A0%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8" rel="nofollow">（一）JZ36 二叉搜索树与双向链表</a></p> 
<p id="1%E3%80%81%E9%A2%98%E6%84%8F%E5%88%86%E6%9E%90-toc" style="margin-left:40px;"><a href="#1%E3%80%81%E9%A2%98%E6%84%8F%E5%88%86%E6%9E%90" rel="nofollow">1、题意分析</a></p> 
<p id="2%E3%80%81%E6%80%9D%E8%B7%AF%E8%AE%B2%E8%A7%A3-toc" style="margin-left:40px;"><a href="#2%E3%80%81%E6%80%9D%E8%B7%AF%E8%AE%B2%E8%A7%A3" rel="nofollow">2、思路讲解</a></p> 
<p id="3%E3%80%81%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA-toc" style="margin-left:40px;"><a href="#3%E3%80%81%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA" rel="nofollow">3、代码演示</a></p> 
<p id="4%E3%80%81%E6%9C%80%E7%BB%88%E7%BB%93%E6%9E%9C-toc" style="margin-left:40px;"><a href="#4%E3%80%81%E6%9C%80%E7%BB%88%E7%BB%93%E6%9E%9C" rel="nofollow">4、最终结果</a></p> 
<p id="%EF%BC%88%E4%BA%8C%EF%BC%89BM6%C2%A0%E5%88%A4%E6%96%AD%E9%93%BE%E8%A1%A8%E4%B8%AD%E6%98%AF%E5%90%A6%E6%9C%89%E7%8E%AF-toc" style="margin-left:0px;"><a href="#%EF%BC%88%E4%BA%8C%EF%BC%89BM6%C2%A0%E5%88%A4%E6%96%AD%E9%93%BE%E8%A1%A8%E4%B8%AD%E6%98%AF%E5%90%A6%E6%9C%89%E7%8E%AF" rel="nofollow">（二）BM6 判断链表中是否有环</a></p> 
<p id="1%E3%80%81%E9%A2%98%E6%84%8F%E5%88%86%E6%9E%90-toc" style="margin-left:40px;"><a href="#1%E3%80%81%E9%A2%98%E6%84%8F%E5%88%86%E6%9E%90" rel="nofollow">1、题意分析</a></p> 
<p id="2%E3%80%81%E6%80%9D%E8%B7%AF%E8%AE%B2%E8%A7%A3-toc" style="margin-left:40px;"><a href="#2%E3%80%81%E6%80%9D%E8%B7%AF%E8%AE%B2%E8%A7%A3" rel="nofollow">2、思路讲解</a></p> 
<p id="3%E3%80%81%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA-toc" style="margin-left:40px;"><a href="#3%E3%80%81%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA" rel="nofollow">3、代码演示</a></p> 
<p id="4%E3%80%81%E6%9C%80%E7%BB%88%E7%BB%93%E6%9E%9C-toc" style="margin-left:40px;"><a href="#4%E3%80%81%E6%9C%80%E7%BB%88%E7%BB%93%E6%9E%9C" rel="nofollow">4、最终结果</a></p> 
<p id="%EF%BC%88%E4%B8%89%EF%BC%89JZ23%C2%A0%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%8E%AF%E7%9A%84%E5%85%A5%E5%8F%A3%E7%BB%93%E7%82%B9-toc" style="margin-left:0px;"><a href="#%EF%BC%88%E4%B8%89%EF%BC%89JZ23%C2%A0%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%8E%AF%E7%9A%84%E5%85%A5%E5%8F%A3%E7%BB%93%E7%82%B9" rel="nofollow">（三）JZ23 链表中环的入口结点</a></p> 
<p id="1%E3%80%81%E9%A2%98%E6%84%8F%E5%88%86%E6%9E%90-toc" style="margin-left:40px;"><a href="#1%E3%80%81%E9%A2%98%E6%84%8F%E5%88%86%E6%9E%90" rel="nofollow">1、题意分析</a></p> 
<p id="2%E3%80%81%E6%80%9D%E8%B7%AF%E8%AE%B2%E8%A7%A3-toc" style="margin-left:40px;"><a href="#2%E3%80%81%E6%80%9D%E8%B7%AF%E8%AE%B2%E8%A7%A3" rel="nofollow">2、思路讲解</a></p> 
<p id="3%E3%80%81%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA-toc" style="margin-left:40px;"><a href="#3%E3%80%81%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA" rel="nofollow">3、代码演示</a></p> 
<p id="4%E3%80%81%E6%9C%80%E7%BB%88%E7%BB%93%E6%9E%9C-toc" style="margin-left:40px;"><a href="#4%E3%80%81%E6%9C%80%E7%BB%88%E7%BB%93%E6%9E%9C" rel="nofollow">4、最终结果</a></p> 
<p id="%EF%BC%88%E5%9B%9B%20%EF%BC%89HJ43%C2%A0%E8%BF%B7%E5%AE%AB%E9%97%AE%E9%A2%98-toc" style="margin-left:0px;"><a href="#%EF%BC%88%E5%9B%9B%20%EF%BC%89HJ43%C2%A0%E8%BF%B7%E5%AE%AB%E9%97%AE%E9%A2%98" rel="nofollow">（四 ）HJ43 迷宫问题</a></p> 
<p id="1%E3%80%81%E9%A2%98%E6%84%8F%E5%88%86%E6%9E%90-toc" style="margin-left:40px;"><a href="#1%E3%80%81%E9%A2%98%E6%84%8F%E5%88%86%E6%9E%90" rel="nofollow">1、题意分析</a></p> 
<p id="2%E3%80%81%E6%80%9D%E8%B7%AF%E8%AE%B2%E8%A7%A3-toc" style="margin-left:40px;"><a href="#2%E3%80%81%E6%80%9D%E8%B7%AF%E8%AE%B2%E8%A7%A3" rel="nofollow">2、思路讲解</a></p> 
<p id="3%E3%80%81%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA-toc" style="margin-left:40px;"><a href="#3%E3%80%81%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA" rel="nofollow">3、代码演示</a></p> 
<p id="4%E3%80%81%E6%9C%80%E7%BB%88%E7%BB%93%E6%9E%9C-toc" style="margin-left:40px;"><a href="#4%E3%80%81%E6%9C%80%E7%BB%88%E7%BB%93%E6%9E%9C" rel="nofollow">4、最终结果</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%EF%BC%88%E4%B8%80%EF%BC%89JZ36%C2%A0%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8">（一）JZ36 二叉搜索树与双向链表（经典题目）</h2> 
<p><strong>首先，我们第一题给大家讲述的是关于一道  二叉搜索树与双向链表 的问题。首先，拿到题我们还是先从题干入手，理解好题意才能更好进行解题操作。</strong></p> 
<p><strong><span style="background-color:#ffd900;">题目如下：</span></strong></p> 
<p><img alt="" height="585" src="https://images2.imgbox.com/58/f1/EnETy3zW_o.png" width="868"></p> 
<p></p> 
<p id="%E8%BE%93%E5%85%A5%E6%8F%8F%E8%BF%B0%EF%BC%9A"><strong>输入描述：</strong></p> 
<p>二叉树的根节点</p> 
<p id="%E8%BF%94%E5%9B%9E%E5%80%BC%E6%8F%8F%E8%BF%B0%EF%BC%9A"><strong>返回值描述：</strong></p> 
<p>双向链表的其中一个头节点。</p> 
<p></p> 
<p><strong>示例1</strong></p> 
<pre><code class="language-cpp">输入：{10,6,14,4,8,12,16}

返回值：From left to right are:4,6,8,10,12,14,16;From right to left are:16,14,12,10,8,6,4;

说明：输入题面图中二叉树，输出的时候将双向链表的头节点返回即可。     </code></pre> 
<p><strong>示例2</strong></p> 
<pre><code class="language-cpp">输入：{5,4,#,3,#,2,#,1}

返回值：
From left to right are:1,2,3,4,5;From right to left are:5,4,3,2,1;
说明：
                    5
                  /
                4
              /
            3
          /
        2
      /
    1
树的形状如上图   </code></pre> 
<h3></h3> 
<h3 id="1%E3%80%81%E9%A2%98%E6%84%8F%E5%88%86%E6%9E%90"><strong>1、题意分析</strong></h3> 
<p>首先我们第一看到这个题目就会发现，如果我们对其进行中序遍历，则得到的结果为【4,6,8,10,12,14,16】，此时就符合我们题干的要求，再次把它转化为双向链表即可。</p> 
<p><span style="color:#fe2c24;"><strong>注意：</strong></span></p> 
<ul><li>此时很多小伙伴就会想到我们直接对这棵树进行中序遍历，最后尾插即可。其实这样是不行的，因为题目告诉我们只能在原树中进行操作，不能创建新结点、因此这种思想是不行的。</li></ul> 
<h3 id="2%E3%80%81%E6%80%9D%E8%B7%AF%E8%AE%B2%E8%A7%A3">2、思路讲解</h3> 
<blockquote> 
 <p id="">首先，我们先将一下二叉搜索数的一些概念帮助大家做题：</p> 
</blockquote> 
<p>它要么是一棵空树，要么就具有下列性质的<a href="http://baike.baidu.com/view/88806.htm" rel="nofollow" title="二叉树">二叉树</a>： </p> 
<ul><li><strong>1. 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值； </strong></li><li><strong>2. 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值； </strong></li><li><strong>3. 它的左、右子树也分别为<a href="http://baike.baidu.com/view/647462.htm" rel="nofollow" title="二叉排序树">二叉排序树</a>。</strong></li></ul> 
<p id=""></p> 
<p><span style="color:#fe2c24;"><strong>思路一：</strong></span></p> 
<p>此时可能会有小伙伴这样去想，那我们可不可以用个容器进行操作呢？</p> 
<ul><li><strong>step1：首先我们先定义一个 vector 用来存放结点；</strong></li><li><strong>step2：紧接着进行中序遍历，将结点放进vector 中，最后再改链接关系即可。</strong></li></ul> 
<p>这其实是一个非常棒的思路，而且 牛客 应该对空间复杂度也没有进行很大的限制，最多限制其时间复杂度。因此，这种方法理论上应该是可行的（我在这里就不去实现了，大家有兴趣可以进行尝试）</p> 
<p><span style="color:#fe2c24;"><strong>思路二：</strong></span></p> 
<p></p> 
<p><strong>step1：首先我们需要确定一点，那就是这道题肯定与中序有关。是通过改变为中序这样的关系来进行实现的；</strong></p> 
<p><strong>step2：我们先中序遍历这棵树，并记录一个前驱结点（最开始前驱为空）。那我们如何记录一个前驱结点呢？ </strong></p> 
<ul><li>在 cur 往下走之前我先给 前驱结点，此时就变为前驱了，在递归往下走；</li><li>此时一个结点的左无论如何都是指向前驱的；</li></ul> 
<div class="csdn-video-box"> 
 <iframe id="J5fKruN9-1682046770109" frameborder="0" src="https://live.csdn.net/v/embed/291723" allowfullscreen="true" data-mediaembed="csdn"></iframe> 
 <p></p> 
</div> 
<p><span style="color:#fe2c24;"><strong>注意：</strong></span></p> 
<p><strong>此时又出现一个问题，我的左即前驱可以解决，但是我的 右 该如何解决呢？</strong></p> 
<ul><li>我们不能用  -&gt;next 的方法，因为我们还没遍历过去呢？怎么知道后继在哪呢？我们只知道前驱在哪。</li></ul> 
<p><strong>step3：此时我们对于可以这样去考虑：</strong></p> 
<ul><li><strong>在当前位置我可以改我的前驱，却改不了我的后继；</strong></li><li><strong>但是我可以在下一步在动手去改，即我确定上一步的下一步一定是我；</strong></li><li><strong>因此关键在于我们先把前驱弄完了，通过前驱再去修改后继即可</strong></li></ul> 
<pre><code class="language-cpp">cur-&gt;left=prev;
prev-&gt;right=cur;</code></pre> 
<p><span style="color:#fe2c24;"><strong>注意：</strong></span></p> 
<p><strong>这个题目的思想其实和二叉树的线索化非常相似。在这里简单提一句：</strong></p> 
<ul><li>二叉树的线索化就是把那些空指针利用起来，找它的前驱和后继，这样的话可以做一个迭代遍历的操作。</li></ul> 
<h3 id="3%E3%80%81%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA">3、代码演示</h3> 
<pre><code class="language-cpp">class Solution {
public:
    void InorderConvert(TreeNode* cur,TreeNode* &amp;prev)
	{
		if(cur == nullptr)
		return;

		InorderConvert(cur-&gt;left,prev);
		cur-&gt;left=prev;
		if(prev)
		prev-&gt;right=cur;

		prev=cur;
		InorderConvert(cur-&gt;right,prev);

	}
    TreeNode* Convert(TreeNode* pRootOfTree) {
       TreeNode* prev=nullptr;

	   InorderConvert(pRootOfTree,prev);
	   TreeNode* head=pRootOfTree;
	   while(head &amp;&amp; head-&gt;left)
	   {
		head=head-&gt;left;
	   }
	   return head;
    }
};</code></pre> 
<h3></h3> 
<h3 id="4%E3%80%81%E6%9C%80%E7%BB%88%E7%BB%93%E6%9E%9C"><strong>4、最终结果</strong></h3> 
<p><img alt="" height="946" src="https://images2.imgbox.com/bf/60/aVGebTQF_o.png" width="1200"></p> 
<p></p> 
<p></p> 
<blockquote> 
 <p><strong>我们提交代码，最终程序执行成功！！！ </strong></p> 
</blockquote> 
<hr> 
<h2 id="%EF%BC%88%E4%BA%8C%EF%BC%89BM6%C2%A0%E5%88%A4%E6%96%AD%E9%93%BE%E8%A1%A8%E4%B8%AD%E6%98%AF%E5%90%A6%E6%9C%89%E7%8E%AF">（二）BM6 判断链表中是否有环</h2> 
<p> <strong><span style="background-color:#ffd900;">题目如下：</span></strong></p> 
<h3></h3> 
<p><img alt="" height="603" src="https://images2.imgbox.com/dc/74/YB4UuSUd_o.png" width="860"></p> 
<ul><li><strong>示例1</strong></li></ul> 
<pre><code class="language-cpp">输入：{3,2,0,-4},1
返回值：true
说明：
第一部分{3,2,0,-4}代表一个链表，第二部分的1表示，-4到位置1（注：头结点为位置0），即-4-&gt;2存在一个链接，组成传入的head为一个带环的链表，返回true    </code></pre> 
<ul><li> <strong>示例2</strong></li></ul> 
<pre><code class="language-cpp">输入：{1},-1
返回值：false
说明：
第一部分{1}代表一个链表，-1代表无环，组成传入head为一个无环的单链表，返回false    </code></pre> 
<ul><li><strong>示例3</strong></li></ul> 
<pre><code class="language-cpp">输入：{-1,-7,7,-4,19,6,-9,-5,-2,-5},6
返回值：true</code></pre> 
<h3><strong>1、题意分析</strong></h3> 
<ul><li><strong>首先我们简单的分析一下这道题目，其实很简单，对于给出的第一个部分即表示我们要操作的链表，第二部分的数字如果为 -1 则表示此链表没有环。</strong></li><li><strong>如果为其他的数字则表示链表末尾到数字对于的下标处的结点之间形成环。</strong></li></ul> 
<p></p> 
<p><img alt="" height="1071" src="https://images2.imgbox.com/5d/f1/jgAhAa1O_o.png" width="824"></p> 
<p></p> 
<h3>2、思路讲解</h3> 
<h3></h3> 
<ul><li><strong>step1：使用快慢指针的思想，即快指针买次走两步，慢指针每次走一步；</strong></li><li><strong>step2：因为快指针会先进入环，慢指针会后进入环。一旦快指针入了环之后就会一直在环里进行循环，因此如果存在环的话，那么快慢指针经过不断的遍历之后一定会在其中的某一点处相遇。一旦相遇返回 true 即可</strong></li><li><strong>step3：相反的，如果不存在环，那么快慢指针就一定不会相遇。此时只需返回 FALSE 即可。</strong></li><li><strong>step4：最后就是对于代码的处理了，具体如下。</strong></li></ul> 
<h3></h3> 
<p></p> 
<h3>3、代码演示</h3> 
<pre><code class="language-cpp">class Solution {
public:
    bool hasCycle(ListNode *head) {
        //首先判断链表为空的情况
        if(head == nullptr || head-&gt;next == nullptr)
            return false;
        
        //接下来设置快慢指针
        ListNode* fast = head-&gt;next;
        ListNode* slow = head;

        //如果两指针没相遇就继续
        while(slow != fast)
        {
            //无环情况判断
            if(fast==nullptr || fast-&gt;next == nullptr)
            return false;

            //快指针移动两步
            fast = fast-&gt;next-&gt;next;
            //慢指针移动一步
            slow = slow-&gt;next;
        }
        return true;
    }
};</code></pre> 
<h3><strong>4、最终结果</strong></h3> 
<p><img alt="" height="941" src="https://images2.imgbox.com/b2/f7/JbxSy6J7_o.png" width="1200"></p> 
<hr> 
<p></p> 
<h2 id="%EF%BC%88%E4%B8%89%EF%BC%89JZ23%C2%A0%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%8E%AF%E7%9A%84%E5%85%A5%E5%8F%A3%E7%BB%93%E7%82%B9">（三）JZ23 链表中环的入口结点</h2> 
<h3></h3> 
<p><strong><span style="background-color:#ffd900;">题目如下：</span></strong></p> 
<p><img alt="" height="666" src="https://images2.imgbox.com/1a/80/AHoHuz0f_o.png" width="865"></p> 
<ul><li><strong> 示例1</strong></li></ul> 
<pre><code class="language-cpp">输入：{1,2},{3,4,5}
返回值：3
说明：返回环形链表入口结点，我们后台程序会打印该环形链表入口结点对应的结点值，即3</code></pre> 
<ul><li><strong> 示例2</strong></li></ul> 
<pre><code class="language-cpp">输入：{1},{}
返回值："null"
说明：没有环，返回对应编程语言的空结点，后台程序会打印"null"   </code></pre> 
<ul><li><strong> 示例3</strong></li></ul> 
<pre><code class="language-cpp">输入：{},{2}
返回值：2
说明：环的部分只有一个结点，所以返回该环形链表入口结点，后台程序打印该结点对应的结点值，即2   </code></pre> 
<h3><strong>1、题意分析</strong></h3> 
<ul><li><strong>这道题跟上述的题目有很多类似之处，因此在做这道题之前我先给大家给出了一道判断是否存在环的题目，帮助大家更好的理解这道题。</strong></li><li><strong>这道题的整体思路跟上述的其实差不多，上述我们是判断有没有环，这里我们则可以先判断是否有环，紧接着再去看链表的入环结点在哪！</strong></li></ul> 
<p></p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/9c/ba/qnlPLqPx_o.png" width="1200"></p> 
<p></p> 
<p></p> 
<h3>2、思路讲解</h3> 
<h3></h3> 
<p>本题的主要步奏其实就是两步：</p> 
<ol><li>第一步就是判断链表是否有环。</li><li>第二步如果有环，则在有环的链表中找到环的入口返回即可</li></ol> 
<p>具体步奏如下：</p> 
<p><strong>step1：首先还是使用快慢指针的思想，即快指针买次走两步，慢指针每次走一步，此时会产生两种情况：</strong></p> 
<ul><li><span style="color:#0d0016;"><strong>①无环</strong></span><span style="color:#fe2c24;"><strong>：当快指针走向链表末端的时候，此时直接返回 null即可</strong></span></li><li><span style="color:#0d0016;"><strong>②有环</strong></span><span style="color:#fe2c24;"><strong>：当有环时，此时当快指针进入环之后依旧还是在环里一直循环遍历的，此时当 fast==slow 的时候，两指针在这时首次相遇。此时，我们需要把 fast 指针指向头结点，紧接着两指针各自在走一步步的走，当走到两指针再次相遇时 ，此时所指向的结点即为我们的入环结点，返回即可。</strong></span></li></ul> 
<p><strong><span style="color:#0d0016;"><span style="background-color:#ffd900;">我以如下图示给大家分析上述:</span></span></strong></p> 
<p><img alt="" height="384" src="https://images2.imgbox.com/34/4e/54vgk4Nc_o.png" width="1200"></p> 
<p></p> 
<p><strong>step2：分析原因</strong></p> 
<ul><li><strong>①如上图所示，我们假设环外的长度为m ，此时当slow进入环之后，需要再走 n步指针才能与 fast 指针相遇。因为快指针比慢指针走得快，因此假设两指针相遇之前，fast 指针已经走了 a圈，此时 fast 指针走过的距离有  <span style="color:#fe2c24;">【m+a(n+k)+n】; </span><span style="color:#0d0016;">slow 指针走过的距离为 </span><span style="color:#fe2c24;">【m+n】</span></strong></li><li><strong>②此时，我们可以得出一个公式结论。因为 fast 一次走两步， slow 一次走一步 ，因此我们得出以下公式  <span style="color:#fe2c24;">m+a(n+k)+n=2*(m+n)</span></strong></li><li><strong>③根据上面的公式，我们可以推倒出 <span style="color:#fe2c24;">m=(a-1)*(n+k)+k</span></strong></li><li><strong>④上面的式子含义即为从链表头部到入环结点距离 <span style="background-color:#f3f3f4;">等于 </span>从相遇点到入环结点的距离+（a-1）倍的圈长</strong></li></ul> 
<p></p> 
<h3>3、代码演示</h3> 
<pre><code class="language-cpp">class Solution {
public:
    ListNode* EntryNodeOfLoop(ListNode* pHead) {
        //快慢双指针
        ListNode* fast = pHead;
        ListNode* slow = pHead;

        //如果没环快指针会先到链表尾
        while(fast != nullptr &amp;&amp; fast-&gt;next != nullptr)
        {
            //快指针移动两步
            fast = fast-&gt;next-&gt;next;
            //慢指针移动一步
            slow = slow-&gt;next;

            //相遇则有环
            if(fast == slow)
            {
                //此时从首结点开始向后遍历如果与慢指针相遇则当前结点为入环结点
                while(pHead != slow)
                {
                   slow = slow-&gt;next;
                   pHead = pHead-&gt;next;
                } 
                return slow;
            }
        }
        return nullptr;
    }
};</code></pre> 
<h3><strong>4、最终结果</strong></h3> 
<p><img alt="" height="937" src="https://images2.imgbox.com/94/83/zpouNeJ9_o.png" width="1200"></p> 
<hr> 
<p></p> 
<h2 id="%EF%BC%88%E5%9B%9B%20%EF%BC%89HJ43%C2%A0%E8%BF%B7%E5%AE%AB%E9%97%AE%E9%A2%98">（四 ）HJ43 迷宫问题</h2> 
<p></p> 
<p><strong><span style="background-color:#ffd900;">题目如下：</span></strong></p> 
<p><img alt="" height="601" src="https://images2.imgbox.com/18/5f/pxRbLweJ_o.png" width="864"></p> 
<h3></h3> 
<ul><li><strong>示例1</strong></li></ul> 
<pre><code class="language-cpp">输入：
5 5
0 1 0 0 0
0 1 1 1 0
0 0 0 0 0
0 1 1 1 0
0 0 0 1 0

输出：
(0,0)
(1,0)
(2,0)
(2,1)
(2,2)
(2,3)
(2,4)
(3,4)
(4,4)</code></pre> 
<ul><li><strong>示例2</strong></li></ul> 
<pre><code class="language-cpp">输入：
5 5
0 1 0 0 0
0 1 0 1 0
0 0 0 0 1
0 1 1 1 0
0 0 0 0 0

输出：
(0,0)
(1,0)
(2,0)
(3,0)
(4,0)
(4,1)
(4,2)
(4,3)
(4,4)</code></pre> 
<h3><strong>1、题意分析</strong></h3> 
<p>首先，开始时我们并不知道该结点可以往哪走，上下左右四个方向我们并不知道哪条是可行的。因此不难看出本题我们需要用到 “回溯法”去进行解决。</p> 
<p>其次，通过我们的分析也不难发现。对于路径的选择是不确定的。对于题意是找到最短的路径，因此我们还要对路径进行最优判断。</p> 
<h3>2、思路讲解</h3> 
<p>step1：首先我们可以从入口处开始进行递归搜索，每次进入一个点，将其加入临时路径数组中；</p> 
<p>step2：紧接着我们判断是否进入到了出口处；</p> 
<p>step3：如果没有依次搜索当前位置的上、下、左、右四个方向的点，如果搜索的这个点可以进入则路径进入，如果四个方向都没有可以走的路表示该结点走不通，此时需要恢复原场面，回溯——删去路径最后一个，重置该位为0.</p> 
<p>step4：找到横纵坐标都等于矩阵最后一位则表示找到路径，复制现有路径然后返回。</p> 
<h3></h3> 
<h3>3、代码演示</h3> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include&lt;vector&gt;
using namespace std;

int ROW, Cal;
vector&lt;vector&lt;int&gt;&gt;arry;
vector&lt;vector&lt;int&gt;&gt;Path_tmp;
vector&lt;vector&lt;int&gt;&gt;Path_way;


void Mazeway(int i, int j) {
    arry[i][j] = 1;
    Path_tmp.push_back({ i, j });
     
     //判断是否到达出口
    if (i == ROW - 1 &amp;&amp; j == Cal - 1) {
        if (Path_way.empty() || Path_way.size() &gt; Path_tmp.size())
            Path_way = Path_tmp;
    }

    //向右走
    if (j + 1 &lt; Cal &amp;&amp; arry[i][j + 1] == 0) {
        Mazeway(i, j + 1);
    }

    //向左走
    if (j - 1 &gt;= 0 &amp;&amp; arry[i][j - 1] == 0) {
        Mazeway(i, j - 1);
    }
    //向下走
    if (i - 1 &gt;= 0 &amp;&amp; arry[i - 1][j] == 0) {
        Mazeway(i - 1, j );
    }
    //向上走
    if (i + 1 &lt; ROW &amp;&amp; arry[i + 1][j] == 0) {
        Mazeway(i + 1, j);
    }

    //该结点走不通，此时需要恢复原场面
    arry[i][j] = 0;
    //从路径中删除该节点
    Path_tmp.pop_back();
}

int main() {
    while (cin &gt;&gt; ROW &gt;&gt; Cal) {
        arry = vector&lt;vector&lt;int&gt;&gt;(ROW, vector&lt;int&gt;(Cal, 0));
        Path_tmp.clear();
        Path_way.clear();
        for (int i = 0; i &lt; ROW; ++i) {
            for (int j = 0; j &lt; Cal; ++j) {
                cin &gt;&gt; arry[i][j];
            }
        }

        Mazeway(0, 0);

        for (int i = 0; i &lt; Path_way.size(); ++i) {
            cout &lt;&lt; "(" &lt;&lt; Path_way[i][0] &lt;&lt; "," &lt;&lt; Path_way[i][1] &lt;&lt; ")" &lt;&lt; endl;

        }

    }
    return 0;
}
// 64 位输出请用 printf("%lld")</code></pre> 
<h3><strong>4、最终结果</strong></h3> 
<p><img alt="" height="933" src="https://images2.imgbox.com/92/2f/4Y8xkwo8_o.png" width="1200"></p> 
<p></p> 
<p></p> 
<blockquote> 
 <p><strong>我们提交代码，最终程序执行成功！！！ </strong></p> 
</blockquote> 
<hr> 
<p><span style="color:#fe2c24;"><strong>到此，便是今天刷题的所有解答啦！希望对大家有所帮助。非常感谢您的阅读！！！</strong></span></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3e956c79fc82091dadf42741258f2396/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">c&#43;&#43; split 函数</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ea7d4b5a214ff6811788425e3b28d8c0/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Java execl导出工具</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>