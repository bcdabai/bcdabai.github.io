<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>c语言match是什么字符串,字符串匹配算法--暴力匹配(Brute-Force-Match)C语言实现 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="c语言match是什么字符串,字符串匹配算法--暴力匹配(Brute-Force-Match)C语言实现" />
<meta property="og:description" content="一、前言
暴力匹配(Brute-Force-Match)是字符串匹配算法里最基础的算法，虽然效率比较低，但胜在方便理解，在小规模数据或对时间无严格要求的情况下可以考虑。
二、代码
#include #include int bf(char *l,char *s);
int main(void)
{
char s1[201],s2[201]; //根据需要设定数组大小
printf(&#34;母串：&#34;);
scanf(&#34;%s&#34;,s1);
printf(&#34;子串：&#34;);
scanf(&#34;%s&#34;,s2);
int a=strlen(s1),b=strlen(s2),re=0;
if(a&gt;=b) //母串长度要比子串长
{
re=bf(s1,s2);
if(re==1)
printf(&#34;%s是%s的子串&#34;,s2,s1);
return 0;
}
else
printf(&#34;无法匹配&#34;);
return 0;
}
int bf(char *l,char *s)
{
if(!strcmp(l,s)) //如果两个字符串相同直接返回
return 1;
int ll=strlen(l),sl=strlen(s),di=ll-sl;
for(int i=0;i&lt;=di;i&#43;&#43;)
{
int temp=0;
for(int j=0;j
{
if(l[i&#43;j]==s[j])
continue;
else
{
temp=1;
break;
}
}
if(temp==1)
continue;
else if(temp==0)
return 1;
}" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/2c53648730ab649ddba17c70165245fa/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-05-20T18:21:46+08:00" />
<meta property="article:modified_time" content="2021-05-20T18:21:46+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">c语言match是什么字符串,字符串匹配算法--暴力匹配(Brute-Force-Match)C语言实现</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div style="font-size:16px;"> 
 <p>一、前言</p> 
 <p>暴力匹配(Brute-Force-Match)是字符串匹配算法里最基础的算法，虽然效率比较低，但胜在方便理解，在小规模数据或对时间无严格要求的情况下可以考虑。</p> 
 <p>二、代码</p> 
 <p>#include </p> 
 <p>#include </p> 
 <p>int bf(char *l,char *s);</p> 
 <p>int main(void)</p> 
 <p>{<!-- --></p> 
 <p>char s1[201],s2[201]; //根据需要设定数组大小</p> 
 <p>printf("母串：");</p> 
 <p>scanf("%s",s1);</p> 
 <p>printf("子串：");</p> 
 <p>scanf("%s",s2);</p> 
 <p>int a=strlen(s1),b=strlen(s2),re=0;</p> 
 <p>if(a&gt;=b) //母串长度要比子串长</p> 
 <p>{<!-- --></p> 
 <p>re=bf(s1,s2);</p> 
 <p>if(re==1)</p> 
 <p>printf("%s是%s的子串",s2,s1);</p> 
 <p>return 0;</p> 
 <p>}</p> 
 <p>else</p> 
 <p>printf("无法匹配");</p> 
 <p>return 0;</p> 
 <p>}</p> 
 <p>int bf(char *l,char *s)</p> 
 <p>{<!-- --></p> 
 <p>if(!strcmp(l,s)) //如果两个字符串相同直接返回</p> 
 <p>return 1;</p> 
 <p>int ll=strlen(l),sl=strlen(s),di=ll-sl;</p> 
 <p>for(int i=0;i&lt;=di;i++)</p> 
 <p>{<!-- --></p> 
 <p>int temp=0;</p> 
 <p>for(int j=0;j</p> 
 <p>{<!-- --></p> 
 <p>if(l[i+j]==s[j])</p> 
 <p>continue;</p> 
 <p>else</p> 
 <p>{<!-- --></p> 
 <p>temp=1;</p> 
 <p>break;</p> 
 <p>}</p> 
 <p>}</p> 
 <p>if(temp==1)</p> 
 <p>continue;</p> 
 <p>else if(temp==0)</p> 
 <p>return 1;</p> 
 <p>}</p> 
 <p>printf("子串不存在");</p> 
 <p>return 0;</p> 
 <p>}</p> 
 <p>三、主要思路</p> 
 <p>每次从子串与母串的第一个字符开始比较，若是匹配成功则继续下一个字符的匹配；若是匹配失败则从母串的下一个字符开始与子串的第一个字符重新匹配，循环往复直到匹配成功或者匹配失败。</p> 
 <p>四、分析时间复杂度</p> 
 <p>我们设子串长为m，母串长为n，同时m比n小的多。</p> 
 <p>在最好情况下，子串与母串的失配都是发生在第一个字符处，时间复杂度为O(m+n)。</p> 
 <p>在最坏的情况下，即子串每一次与母串失配都是在最后一个字母时，时间复杂度为O((m*n)。</p> 
 <p>标签：子串,Force,int,s2,Brute,char,母串,匹配</p> 
 <p>来源： https://www.cnblogs.com/comixH/p/12228744.html</p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e6be3fecc7b7ca702ad4d0edab405404/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">win10下IDEA连接虚拟机上的HDFS实现文件操作</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/2bc2ae27ba7c31a4aac011b517f57a03/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">电子电路基础 （11）——反馈、偏置与多级放大电路原理分析</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>