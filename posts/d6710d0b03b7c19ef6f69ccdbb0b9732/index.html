<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Redis实现优惠券秒杀业务 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Redis实现优惠券秒杀业务" />
<meta property="og:description" content="1.优惠券秒杀业务 优惠券分为两种，一种是普通优惠券，优惠力度较小，另一种是秒杀优惠券，秒杀优惠券优惠力度大，但是数量有限并且限定时间抢购。用户购买优惠券时首先会看优惠券是否有库存，如果有还会判断优惠券是否开始抢购。当用户抢购时，就会生成订单并保存到order表中，而订单表如果使用数据库自增ID就会存在一些问题：
id的规律性太明显
受单表数据量的限制
场景分析一：如果我们的id具有太明显的规则，用户或者说商业对手很容易猜测出来我们的一些敏感信息，比如商城在一天时间内，卖出了多少单，这明显不合适。
场景分析二：随着我们商城规模越来越大，mysql的单表的容量不宜超过500W，数据量过大之后，我们要进行拆库拆表，但拆分表了之后，他们从逻辑上讲他们是同一张表，所以他们的id是不能一样的， 所以我们需要保证id的唯一性解决办法是使用全局唯一Id
1.1全局唯一Id 全局ID生成器，是一种在分布式系统下用来生成全局唯一ID的工具，一般要满足下列特性：
生成Id：为了增加ID的安全性，我们可以不直接使用Redis自增的数值，而是拼接一些其它信息：
组成部分：符号位：1bit，永远为0
时间戳：31bit，以秒为单位，可以使用69年
序列号：32bit，秒内的计数器，支持每秒产生2^32个不同ID
实现： package com.example.utils; import org.springframework.data.redis.core.StringRedisTemplate; import org.springframework.stereotype.Component; import java.time.LocalDateTime; import java.time.ZoneOffset; import java.time.format.DateTimeFormatter; /** * 全局id生成器 */ @Component public class RedisIdWorker { /** * 开始时间戳 */ private static final long BEGIN_TIMESTAMP = 1640995200L; /** * 序列号的位数 */ private static final int COUNT_BITS = 32; private StringRedisTemplate stringRedisTemplate; public RedisIdWorker(StringRedisTemplate stringRedisTemplate) { this.stringRedisTemplate = stringRedisTemplate; } public long nextId(String keyPrefix) { // 1." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/d6710d0b03b7c19ef6f69ccdbb0b9732/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-05-01T00:13:34+08:00" />
<meta property="article:modified_time" content="2023-05-01T00:13:34+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Redis实现优惠券秒杀业务</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>1.优惠券秒杀业务</h2> 
<p>       优惠券分为两种，一种是普通优惠券，优惠力度较小，另一种是秒杀优惠券，秒杀优惠券优惠力度大，但是数量有限并且限定时间抢购。用户购买优惠券时首先会看优惠券是否有库存，如果有还会判断优惠券是否开始抢购。当用户抢购时，就会生成订单并保存到order表中，而订单表如果使用数据库自增ID就会存在一些问题：</p> 
<ul><li> <p>id的规律性太明显</p> </li><li> <p>受单表数据量的限制</p> </li></ul> 
<p>场景分析一：如果我们的id具有太明显的规则，用户或者说商业对手很容易猜测出来我们的一些敏感信息，比如商城在一天时间内，卖出了多少单，这明显不合适。</p> 
<p>场景分析二：随着我们商城规模越来越大，mysql的单表的容量不宜超过500W，数据量过大之后，我们要进行拆库拆表，但拆分表了之后，他们从逻辑上讲他们是同一张表，所以他们的id是不能一样的， 所以我们需要保证id的唯一性解决办法是使用全局唯一Id</p> 
<h3>1.1全局唯一Id</h3> 
<p><strong>全局ID生成器</strong>，是一种在分布式系统下用来生成全局唯一ID的工具，一般要满足下列特性：</p> 
<p></p> 
<p>生成Id：为了增加ID的安全性，我们可以不直接使用Redis自增的数值，而是拼接一些其它信息：</p> 
<p><img alt="" height="144" src="https://images2.imgbox.com/b9/38/LQH7sTZ5_o.png" width="1118"></p> 
<p>组成部分：符号位：1bit，永远为0</p> 
<p>                  时间戳：31bit，以秒为单位，可以使用69年</p> 
<p>                  序列号：32bit，秒内的计数器，支持每秒产生2^32个不同ID</p> 
<h4>实现：</h4> 
<pre><code class="language-java">package com.example.utils;

import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.stereotype.Component;

import java.time.LocalDateTime;
import java.time.ZoneOffset;
import java.time.format.DateTimeFormatter;

/**
 * 全局id生成器
 */
@Component
public class RedisIdWorker {
    /**
     * 开始时间戳
     */
    private static final long BEGIN_TIMESTAMP = 1640995200L;
    /**
     * 序列号的位数
     */
    private static final int COUNT_BITS = 32;

    private StringRedisTemplate stringRedisTemplate;

    public RedisIdWorker(StringRedisTemplate stringRedisTemplate) {
        this.stringRedisTemplate = stringRedisTemplate;
    }

    public long nextId(String keyPrefix) {
        // 1.生成时间戳
        LocalDateTime now = LocalDateTime.now();
        long nowSecond = now.toEpochSecond(ZoneOffset.UTC);
        long timestamp = nowSecond - BEGIN_TIMESTAMP;

        // 2.生成序列号
        // 2.1.获取当前日期，精确到天
        String date = now.format(DateTimeFormatter.ofPattern("yyyy:MM:dd"));
        // 2.2.自增长
        long count = stringRedisTemplate.opsForValue().increment("icr:" + keyPrefix + ":" + date);

        // 3.拼接并返回
        return timestamp &lt;&lt; COUNT_BITS | count;
        //‭10 0111 1100 0010 0000 1100 1011 0000 0000 0000 0000 0000 0000 0000 0001‬
    }


}</code></pre> 
<p>测试生成的Id</p> 
<p><img alt="" height="412" src="https://images2.imgbox.com/62/58/o4xT9ZN8_o.png" width="1200"></p> 
<h3>1.2简单实现优惠券秒杀</h3> 
<p>秒杀下单应该思考的内容：</p> 
<p>下单时需要判断两点：</p> 
<ul><li> <p>秒杀是否开始或结束，如果尚未开始或已经结束则无法下单</p> </li><li> <p>库存是否充足，不足则无法下单</p> </li></ul> 
<p>下单核心逻辑分析：</p> 
<p>当用户开始进行下单，我们应当去查询优惠卷信息，查询到优惠卷信息，判断是否满足秒杀条件</p> 
<p>比如时间是否充足，如果时间充足，则进一步判断库存是否足够，如果两者都满足，则扣减库存，创建订单，然后返回订单id，如果有一个条件不满足则直接结束。</p> 
<p><strong>流程图</strong></p> 
<p><img alt="" height="644" src="https://images2.imgbox.com/e0/35/8iHNDwaK_o.png" width="1123"></p> 
<p><strong> 实现</strong></p> 
<pre><code class="language-java">package com.example.service.impl;

import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import com.example.dto.Result;
import com.example.entity.SeckillVoucher;
import com.example.entity.VoucherOrder;
import com.example.mapper.VoucherOrderMapper;
import com.example.service.ISeckillVoucherService;
import com.example.service.IVoucherOrderService;
import com.example.utils.RedisIdWorker;
import com.example.utils.UserHolder;
import org.springframework.stereotype.Service;

import javax.annotation.Resource;
import java.time.LocalDateTime;

/**
 * &lt;p&gt;
 *  优惠券秒杀服务实现类
 * 
 * &lt;/p&gt;
 *
 */
@Service
public class VoucherOrderServiceImpl extends ServiceImpl&lt;VoucherOrderMapper, VoucherOrder&gt; implements IVoucherOrderService {
    @Resource
    private ISeckillVoucherService seckillVoucherService;
    @Resource
    private RedisIdWorker redisIdWorker;

    /**
     * 优惠券秒杀(订单)  限时抢购
     *
     * @param voucherId
     * @return
     */
    @Override
    public Result seckillVoucher(Long voucherId) {
        //首先查询秒杀优惠券
        SeckillVoucher seckillVoucher = seckillVoucherService.getById(voucherId);
        //判断是否开始秒杀
        if (seckillVoucher.getBeginTime().isAfter(LocalDateTime.now())) { //开始时间在当前时间前（未开始）
            return Result.fail("秒杀未开始");
        }
        //判断秒杀是否结束
        if (seckillVoucher.getEndTime().isBefore(LocalDateTime.now())) {  //结束时间在当前时间前
            return Result.fail("秒杀已经结束");
        }
        //判断库存是否&gt;0
        if (seckillVoucher.getStock() &lt; 1) {
            return Result.fail("库存不足");
        }
        //用户成功获取优惠券
        //优惠券数量-1
        boolean isLessSeckillVoucher = seckillVoucherService.update().setSql("stock=stock-1").eq("voucher_id", voucherId).update();
        if (!isLessSeckillVoucher) {
            return Result.fail("库存不足");
        }
        //创建订单
        VoucherOrder voucherOrder=new VoucherOrder();
        //设置订单id(全局id)
        long orderId = redisIdWorker.nextId("order");
        voucherOrder.setId(orderId);
        //设置用户id
        voucherOrder.setUserId(UserHolder.getUser().getId());
        //设置优惠券id
        voucherOrder.setVoucherId(voucherId);
        save(voucherOrder);
        return Result.ok(orderId);
    }
}</code></pre> 
<h2>2.超卖问题</h2> 
<p>        上边已经简单实现了优惠券的秒杀业务，但是仅仅支持单线程使用，当我们在判断库存时是针对单个线程的。如果有多个线程同时购买优惠券那么上述代码就会出现问题。</p> 
<p>        比如库存只有一张优惠券，线程1在购买优惠券时，判断出库存大于0，还没来得及减，线程二也购买了优惠券，此时线程2得到的库存数量也是大于0的，所以两者都会对操作优惠券的库存。导致优惠券库存数量为负(异常)。</p> 
<p><img alt="" height="626" src="https://images2.imgbox.com/02/14/2PjqAKp0_o.png" width="1200"></p> 
<p><strong> 解决方案：</strong>最简单的办法就是使用锁机制，我们有两种方案<br><img alt="" height="511" src="https://images2.imgbox.com/88/79/pAqvcZAe_o.png" width="1200"></p> 
<p></p> 
<p><strong>悲观锁：</strong></p> 
<p>悲观锁可以实现对于数据的串行化执行，比如syn，和lock都是悲观锁的代表，同时，悲观锁中又可以再细分为公平锁，非公平锁，可重入锁，等等</p> 
<p><strong>乐观锁：</strong></p> 
<p>乐观锁：会有一个版本号，每次操作数据会对版本号+1，再提交回数据时，会去校验是否比之前的版本大1 ，如果大1 ，则进行操作成功，这套机制的核心逻辑在于，如果在操作过程中，版本号只比原来大1 ，那么就意味着操作过程中没有人对他进行过修改，他的操作就是安全的，如果不大1，则数据被修改过，当然乐观锁还有一些变种的处理方式比如cas</p> 
<p>乐观锁的典型代表：就是cas，利用cas进行无锁化机制加锁，var5 是操作前读取的内存值，while中的var1+var2 是预估值，如果预估值 == 内存值，则代表中间没有被人修改过，此时就将新值去替换 内存值</p> 
<p>其中do while 是为了在操作失败时，再次进行自旋操作，即把之前的逻辑再操作一次。</p> 
<pre><code class="language-java">int var5;
do {
    var5 = this.getIntVolatile(var1, var2);
} while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));

return var5;</code></pre> 
<h4>2.1乐观锁解决超卖问题</h4> 
<p>        操作逻辑是在操作时，对版本号进行+1 操作，然后要求version 如果是1 的情况下，才能操作，那么第一个线程在操作后，数据库中的version变成了2，但是他自己满足version=1 ，所以没有问题，此时线程2执行，线程2 最后也需要加上条件version =1 ，但是现在由于线程1已经操作过了，所以线程2，操作时就不满足version=1 的条件了，所以线程2无法执行成功</p> 
<p><img alt="" height="541" src="https://images2.imgbox.com/47/88/wxuGwdtI_o.png" width="1200"></p> 
<p><strong> 实现</strong>：改成stock&gt;0即可 每个线程执行<span style="color:#fe2c24;">减库存的同时判断stock的数量(set stock=stock-1 where id = ? and stock &gt; 0)</span>。如果stock的数量&lt;0则直接返回false提示库存不足，这样就保证了每次减库存时库存的数量永远都是大于0的。</p> 
<p><img alt="" height="807" src="https://images2.imgbox.com/4f/0f/U0fzaXqW_o.png" width="1200"></p> 
<h2>3.一人一单问题</h2> 
<h3>3.1简单实现</h3> 
<p>        在实际业务中，如果限定一个用户只能拥有一张优惠券，那么我们就会对用户拥有的优惠券数量进行一个判断，</p> 
<p>流程图：</p> 
<p><img alt="" height="556" src="https://images2.imgbox.com/59/b2/Hbb7qzFv_o.png" width="1200"></p> 
<p> 实现 只需要在扣除库存之前判断当前用户Id下是否有优惠券订单信息</p> 
<pre><code class="language-java">   // 5.一人一单逻辑
    // 5.1.用户id
    Long userId = UserHolder.getUser().getId();
    int count = query().eq("user_id", userId).eq("voucher_id", voucherId).count();
    // 5.2.判断是否存在
    if (count &gt; 0) {
        // 用户已经购买过了
        return Result.fail("用户已经购买过一次！");
    }</code></pre> 
<h3>3.2并发场景下问题</h3> 
<p>   现在的问题还是和之前一样，并发过来，查询数据库，都不存在订单，所以我们还是需要加锁，但是乐观锁比较适合更新数据，而现在是插入数据，所以我们需要使用<span style="color:#fe2c24;">悲观锁</span>操作</p> 
<p>intern() 这个方法是从常量池中拿到数据，如果我们直接使用userId.toString() 他拿到的对象实际上是不同的对象，new出来的对象，我们使用锁必须保证锁必须是同一把，所以我们需要使用intern()方法</p> 
<pre><code class="language-java">@Transactional
public  Result createVoucherOrder(Long voucherId) {
	Long userId = UserHolder.getUser().getId();
	synchronized(userId.toString().intern()){
         // 5.1.查询订单
        int count = query().eq("user_id", userId).eq("voucher_id", voucherId).count();
        // 5.2.判断是否存在
        if (count &gt; 0) {
            // 用户已经购买过了
            return Result.fail("用户已经购买过一次！");
        }

        // 6.扣减库存
        boolean success = seckillVoucherService.update()
                .setSql("stock = stock - 1") // set stock = stock - 1
                .eq("voucher_id", voucherId).gt("stock", 0) // where id = ? and stock &gt; 0
                .update();
        if (!success) {
            // 扣减失败
            return Result.fail("库存不足！");
        }

        // 7.创建订单
        VoucherOrder voucherOrder = new VoucherOrder();
        // 7.1.订单id
        long orderId = redisIdWorker.nextId("order");
        voucherOrder.setId(orderId);
        // 7.2.用户id
        voucherOrder.setUserId(userId);
        // 7.3.代金券id
        voucherOrder.setVoucherId(voucherId);
        save(voucherOrder);

        // 7.返回订单id
        return Result.ok(orderId);
    }
}</code></pre> 
<p>但是以上代码还是存在问题，问题的原因在于当前方法被spring的事务控制，如果你在方法内部加锁，可能会导致当前方法事务还没有提交，但是锁已经释放也会导致问题。</p> 
<h3>3.3 分布式锁解决并发问题</h3> 
<p>通过加锁可以解决在单机情况下的一人一单安全问题，但是在集群模式下就不行了</p> 
<p><strong>有关锁失效原因分析</strong></p> 
<p>由于现在我们部署了多个tomcat，每个tomcat都有一个属于自己的jvm，那么假设在服务器A的tomcat内部，有两个线程，这两个线程由于使用的是同一份代码，那么他们的<span style="color:#ff9900;">锁对象是同一个</span>，是可以实现互斥的，但是如果现在是服务器B的tomcat内部，又有两个线程，但是他们的锁对象写的虽然和服务器A一样，但是锁对象却不是同一个，所以线程3和线程4可以实现互斥，但是却无法和线程1和线程2实现互斥，这就是 集群环境下，syn锁失效的原因，在这种情况下，我们就需要使用分布式锁来解决这个问题。</p> 
<p><img alt="" height="606" src="https://images2.imgbox.com/5c/91/QhZpinBC_o.png" width="1200"></p> 
<h4> 3.3.1基本原理和实现方式对比</h4> 
<p>分布式锁：满足分布式系统或集群模式下多进程可见并且互斥的锁。</p> 
<p>分布式锁的核心思想就是让大家都使用同一把锁，只要大家使用的是同一把锁，那么我们就能锁住线程，不让线程进行，让程序串行执行，这就是分布式锁的核心思路</p> 
<p><img alt="" height="603" src="https://images2.imgbox.com/d4/c3/TCFG9t4b_o.png" width="1200"></p> 
<h4> 3.3.2使用Redission分布式锁</h4> 
<p>        Redisson是一个在Redis的基础上实现的Java驻内存数据网格（In-Memory Data Grid）。它不仅提供了一系列的分布式的Java常用对象，还提供了许多分布式服务，其中就包含了各种分布式锁的实现。</p> 
<p><strong>快速使用</strong></p> 
<p>引入依赖：</p> 
<pre><code class="language-XML">&lt;dependency&gt;
	&lt;groupId&gt;org.redisson&lt;/groupId&gt;
	&lt;artifactId&gt;redisson&lt;/artifactId&gt;
	&lt;version&gt;3.13.6&lt;/version&gt;
&lt;/dependency&gt;</code></pre> 
<p>添加配置类</p> 
<pre><code class="language-java">package com.example.config;

import org.redisson.Redisson;
import org.redisson.api.RedissonClient;
import org.redisson.config.Config;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class RedissonConfig {

    @Bean
    public RedissonClient redissonClient(){
        // 配置
        Config config = new Config();
        config.useSingleServer().setAddress("redis://redis地址:6379")
                .setPassword("*********");
        // 创建RedissonClient对象
        return Redisson.create(config);
    }
}
</code></pre> 
<p>使用RedissonClient</p> 
<pre><code class="language-java">@Resource
private RedissionClient redissonClient;

@Test
void testRedisson() throws Exception{
    //获取锁(可重入)，指定锁的名称
    RLock lock = redissonClient.getLock("anyLock");
    //尝试获取锁，参数分别是：获取锁的最大等待时间(期间会重试)，锁自动释放时间，时间单位
    boolean isLock = lock.tryLock(1,10,TimeUnit.SECONDS);
    //判断获取锁成功
    if(isLock){
        try{



            System.out.println("执行业务");     



     
        }finally{
            //释放锁
            lock.unlock();
        }
        
    }
    
    
    
}</code></pre> 
<h4>3.3.3使用Redisson解决一人一单</h4> 
<p>简单来说就是在获取用户id时 会尝试对用户进行上锁，如果上锁成功说明用户第一次下单。其他线程访问的时候会上锁失败，只有等前一个线程执行完后才能上锁。</p> 
<pre><code class="language-java">package com.example.service.impl;

import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import com.example.dto.Result;
import com.example.entity.SeckillVoucher;
import com.example.entity.VoucherOrder;
import com.example.mapper.VoucherOrderMapper;
import com.example.service.ISeckillVoucherService;
import com.example.service.IVoucherOrderService;
import com.example.utils.RedisIdWorker;
import com.example.utils.UserHolder;
import org.redisson.api.RLock;
import org.redisson.api.RedissonClient;
import org.springframework.aop.framework.AopContext;
import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import javax.annotation.Resource;
import java.time.LocalDateTime;

/**
 * &lt;p&gt;
 * 优惠券秒杀服务实现类
 * &lt;/p&gt;
 */
@Service
public class VoucherOrderServiceImpl extends ServiceImpl&lt;VoucherOrderMapper, VoucherOrder&gt; implements IVoucherOrderService {
    @Resource
    private ISeckillVoucherService seckillVoucherService;
    @Resource
    private RedisIdWorker redisIdWorker;
    @Resource
    private StringRedisTemplate stringRedisTemplate;
    @Resource
    private RedissonClient redissonClient;

    /**
     * 优惠券秒杀(订单)  限时抢购
     *
     * @param voucherId
     * @return
     */
    @Override
    public Result seckillVoucher(Long voucherId) {
        //首先查询秒杀优惠券
        SeckillVoucher seckillVoucher = seckillVoucherService.getById(voucherId);
        //判断是否开始秒杀
        if (seckillVoucher.getBeginTime().isAfter(LocalDateTime.now())) { //开始时间在当前时间前（未开始）
            return Result.fail("秒杀未开始");
        }
        //判断秒杀是否结束
        if (seckillVoucher.getEndTime().isBefore(LocalDateTime.now())) {  //结束时间在当前时间前
            return Result.fail("秒杀已经结束");
        }
        //判断库存是否&gt;0
        if (seckillVoucher.getStock() &lt; 1) {
            return Result.fail("库存不足");
        }
        return createVoucherOrder(voucherId);
    }

    /**
     * 一人一单
     *
     * @param voucherId
     * @return
     */
    @Transactional
    public Result createVoucherOrder(Long voucherId) {
        // 一人一单逻辑
        // 用户id
        Long userId = UserHolder.getUser().getId();
        //创建锁对象 使用分布式锁(Redisson)
        RLock redisLock = redissonClient.getLock("lock:order:" + userId);//使用redisson分布式锁

        //获取锁对象
        boolean isLock = redisLock.tryLock();
        //加锁失败
        if (!isLock) {
            return Result.fail("不允许重复下单");
        }
        try {
//         查询订单
            int count = query().eq("user_id", userId).eq("voucher_id", voucherId).count();
            // 判断是否存在
            if (count &gt; 0) {
                // 用户已经购买过了
                return Result.fail("用户已经购买过一次！");
            }

            //用户成功获取优惠券
            //优惠券数量-1
            boolean isLessSeckillVoucher = seckillVoucherService.update()
                    .setSql("stock=stock-1")
                    .eq("voucher_id", voucherId).gt("stock", 0).update();  //乐观锁解决超卖
            if (!isLessSeckillVoucher) {
                return Result.fail("库存不足");
            }
            //创建订单
            VoucherOrder voucherOrder = new VoucherOrder();
            //设置订单id(全局id)
            long orderId = redisIdWorker.nextId("order");
            voucherOrder.setId(orderId);
            //设置用户id
            voucherOrder.setUserId(UserHolder.getUser().getId());
            //设置优惠券id
            voucherOrder.setVoucherId(voucherId);
            save(voucherOrder);
            return Result.ok(orderId);
        } finally {
            redisLock.unlock();
        }

    }
}
</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4c1b66ec9cc7a12ec3afc34d7f90d7f4/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">SpringBoot实现导出Excel功能</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1e6c3f5829f4b0ca5ca2db65afffc93e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">2021-06-02 Multisim 14.0 74LS160异步21进制74LS161组成61进制160与161的区别154显示193加减</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>