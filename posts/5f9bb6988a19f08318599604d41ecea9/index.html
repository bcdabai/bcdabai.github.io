<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java并发编程的艺术(5-10)学习总结 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Java并发编程的艺术(5-10)学习总结" />
<meta property="og:description" content="本文参考学习Java并发编程的艺术
第5章 Java中的锁 5.1 Lock接口 synchronized没有的特性 尝试非阻塞获取锁能够中断获取锁超时获取锁 5.2 队列同步器 队列同步器AbstractQueuedSynchronizer用来构建锁，或者其它同步组件。用一个int成员变量表示同步状态。通过内置的FIFO队列完成资源获取线程的排队工作。同步器的实现主要是继承，同步器需要提供（getState()、setState(int newState)和compareAndSetState(int expect,int update)）方法来获取同步的状态。同步器支持独占或者是共享地获取锁。 5.2.1 队列同步器的接口与示例 同步器的实现基于模板方法。继承并重写。 模板方法包括3类，独占式的获取和释放同步状态，共享式的获取和释放同步状态，查询同步队列的等待状态线程情况。 通过独占锁来说明情况
独占锁只能一个线程获取锁。其它线程只能进入到同步队列。 import java.util.concurrent.TimeUnit; import java.util.concurrent.locks.AbstractQueuedSynchronizer; import java.util.concurrent.locks.Condition; class Mutex implements Lock { // 静态内部类，自定义同步器 private static class Sync extends AbstractQueuedSynchronizer { // 是否处于占用状态 protected boolean isHeldExclusively() { return getState() == 1; } // 当状态为0的时候获取锁 public boolean tryAcquire(int acquires) { if (compareAndSetState(0, 1)) { setExclusiveOwnerThread(Thread.currentThread()); return true; } return false; } // 释放锁，将状态设置为0 protected boolean tryRelease(int releases) { if (getState() == 0) throw new IllegalMonitorStateException(); setExclusiveOwnerThread(null); setState(0); return true; } // 返回一个Condition，每个condition都包含了一个condition队列 Condition newCondition() { return new ConditionObject(); } } // 仅需要将操作代理到Sync上即可 private final Sync sync = new Sync(); public void lock() { sync." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/5f9bb6988a19f08318599604d41ecea9/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-12-05T19:49:19+08:00" />
<meta property="article:modified_time" content="2021-12-05T19:49:19+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java并发编程的艺术(5-10)学习总结</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <blockquote> 
 <p>本文参考学习Java并发编程的艺术</p> 
</blockquote> 
<h2><a id="5_Java_2"></a>第5章 Java中的锁</h2> 
<h3><a id="51_Lock_4"></a>5.1 Lock接口</h3> 
<ul><li>synchronized没有的特性 
  <ul><li>尝试非阻塞获取锁</li><li>能够中断获取锁</li><li>超时获取锁</li></ul> </li></ul> 
<p><img src="https://images2.imgbox.com/bb/19/1fDtKtcI_o.png" alt="image-20211205001858151"></p> 
<h3><a id="52__13"></a>5.2 队列同步器</h3> 
<ul><li>队列同步器AbstractQueuedSynchronizer用来构建锁，或者其它同步组件。用一个int成员变量表示同步状态。通过内置的FIFO队列完成资源获取线程的排队工作。</li><li>同步器的实现主要是继承，同步器需要提供（getState()、setState(int newState)和compareAndSetState(int expect,int update)）方法来获取同步的状态。</li><li>同步器支持独占或者是共享地获取锁。</li></ul> 
<h4><a id="521__19"></a>5.2.1 队列同步器的接口与示例</h4> 
<ul><li>同步器的实现基于模板方法。继承并重写。</li></ul> 
<p><img src="https://images2.imgbox.com/b4/2c/pzexmf9b_o.png" alt="image-20211205003008781"></p> 
<p><img src="https://images2.imgbox.com/75/46/ViqRoU6j_o.png" alt="image-20211205003024682"></p> 
<ul><li>模板方法包括3类，独占式的获取和释放同步状态，共享式的获取和释放同步状态，查询同步队列的等待状态线程情况。</li></ul> 
<blockquote> 
 <p>通过独占锁来说明情况</p> 
</blockquote> 
<ul><li>独占锁只能一个线程获取锁。其它线程只能进入到同步队列。</li></ul> 
<pre><code class="prism language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span><span class="token class-name">TimeUnit</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>locks<span class="token punctuation">.</span></span><span class="token class-name">AbstractQueuedSynchronizer</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>locks<span class="token punctuation">.</span></span><span class="token class-name">Condition</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Mutex</span> <span class="token keyword">implements</span> <span class="token class-name">Lock</span> <span class="token punctuation">{<!-- --></span>
  <span class="token comment">// 静态内部类，自定义同步器</span>
  <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Sync</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractQueuedSynchronizer</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 是否处于占用状态</span>
    <span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">isHeldExclusively</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      <span class="token keyword">return</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 当状态为0的时候获取锁</span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> acquires<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 释放锁，将状态设置为0</span>
    <span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">tryRelease</span><span class="token punctuation">(</span><span class="token keyword">int</span> releases<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span>
              <span class="token class-name">IllegalMonitorStateException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">setState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 返回一个Condition，每个condition都包含了一个condition队列</span>
    <span class="token class-name">Condition</span> <span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ConditionObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 仅需要将操作代理到Sync上即可</span>
  <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Sync</span> sync <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Sync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> sync<span class="token punctuation">.</span><span class="token function">acquire</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
  <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> sync<span class="token punctuation">.</span><span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> sync<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
  <span class="token keyword">public</span> <span class="token class-name">Condition</span> <span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> sync<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
  <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isLocked</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> sync<span class="token punctuation">.</span><span class="token function">isHeldExclusively</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
  <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">hasQueuedThreads</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> sync<span class="token punctuation">.</span><span class="token function">hasQueuedThreads</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">lockInterruptibly</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{<!-- --></span>
    sync<span class="token punctuation">.</span><span class="token function">acquireInterruptibly</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token keyword">long</span> timeout<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> sync<span class="token punctuation">.</span><span class="token function">tryAcquireNanos</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> unit<span class="token punctuation">.</span><span class="token function">toNanos</span><span class="token punctuation">(</span>timeout<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<ul><li>上面的Mutex只有在tryAcquire的CAS设置成功才能够说明获取了同步状态。</li><li>tryRelease把同步状态设置为0。</li><li>获取状态失败就会进入到阻塞队列。</li></ul> 
<h4><a id="522__87"></a>5.2.2 队列同步器的实现分析</h4> 
<h5><a id="1_89"></a>1.同步队列</h5> 
<ul><li>同步器依赖内部的同步队列完成同步状态管理。线程获取同步状态失败，同步器就会把当前的线程以及等待状态信息构成节点Node存入到同步队列。</li></ul> 
<p><img src="https://images2.imgbox.com/c3/7f/v74cZzPT_o.png" alt="image-20211205003737960"></p> 
<ul><li>节点是构成队列的基础，有首尾节点。如果线程没有获取同步状态成功就会进入到队列的尾部</li><li>加入到尾部的时候一定要是一个线程安全的状态，所以有方法compareAndSetTail(Node expect,Node update)。</li><li>每次唤醒都是先从头部开始。</li></ul> 
<p><img src="https://images2.imgbox.com/fb/15/gvrionOg_o.png" alt="image-20211205003906078"></p> 
<h5><a id="2_101"></a>2.独占式同步状态获取与释放</h5> 
<ul><li>同步器acquire(int arg)可以去获取同步状态。对中断不敏感。也就是线程不会从同步队列中移出去。</li><li>首先是调用tryAcquire(int arg)保证线程安全获取同步状态。</li><li>如果失败构造同步节点Node.EXCLUSIVE，并且通过addWaiter(Node node)加入到同步队列的尾部。</li><li>再通过acquireQueued(Node node,int arg)进入死循环获取同步状态。</li><li>只有前驱的节点头才能够获取同步状态 
  <ul><li>头结点获取同步状态的节点，释放之后会唤醒下一个节点</li><li>维护FIFO原则。</li></ul> </li></ul> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
 <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">tryAcquire</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
 <span class="token function">acquireQueued</span><span class="token punctuation">(</span><span class="token function">addWaiter</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token punctuation">.</span>EXCLUSIVE<span class="token punctuation">)</span><span class="token punctuation">,</span> arg<span class="token punctuation">)</span><span class="token punctuation">)</span>
 <span class="token function">selfInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre> 
<ul><li>compareAndSetTail(Node expect,Node update)保证了节点线程安全加入。enq通过死循环保证节点被正确添加。</li></ul> 
<pre><code class="prism language-java"> <span class="token keyword">private</span> <span class="token class-name">Node</span> <span class="token function">addWaiter</span><span class="token punctuation">(</span><span class="token class-name">Node</span> mode<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">Node</span> node <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> mode<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 快速尝试在尾部添加</span>
        <span class="token class-name">Node</span> pred <span class="token operator">=</span> tail<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>pred <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            node<span class="token punctuation">.</span>prev <span class="token operator">=</span> pred<span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetTail</span><span class="token punctuation">(</span>pred<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                pred<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">;</span>
                <span class="token keyword">return</span> node<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token function">enq</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> node<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">private</span> <span class="token class-name">Node</span> <span class="token function">enq</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token class-name">Node</span> node<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token class-name">Node</span> t <span class="token operator">=</span> tail<span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">// Must initialize</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetHead</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                    tail <span class="token operator">=</span> head<span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
                node<span class="token punctuation">.</span>prev <span class="token operator">=</span> t<span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetTail</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                    t<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">;</span>
                    <span class="token keyword">return</span> t<span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre> 
<ul><li>acquireQueued(final Node node,int arg)死循环获取同步状态。</li></ul> 
<pre><code class="prism language-java"><span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">acquireQueued</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token class-name">Node</span> node<span class="token punctuation">,</span> <span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">boolean</span> failed <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">boolean</span> interrupted <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token keyword">final</span> <span class="token class-name">Node</span> p <span class="token operator">=</span> node<span class="token punctuation">.</span><span class="token function">predecessor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> head <span class="token operator">&amp;&amp;</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                    <span class="token function">setHead</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    p<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// help GC</span>
                    failed <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
                    <span class="token keyword">return</span> interrupted<span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">shouldParkAfterFailedAcquire</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> node<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
                        <span class="token function">parkAndCheckInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                    interrupted <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>failed<span class="token punctuation">)</span>
                <span class="token function">cancelAcquire</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/a2/02/ASvvUomL_o.png" alt="image-20211205004448874"></p> 
<p><img src="https://images2.imgbox.com/3c/95/03aPQA0g_o.png" alt="image-20211205004527635"></p> 
<ul><li>接着就是release，唤醒头结点后面的一个节点</li></ul> 
<h5><a id="3_190"></a>3.共享式同步状态获取与释放</h5> 
<ul><li>共享锁可以多线程获取同步状态。</li></ul> 
<p><img src="https://images2.imgbox.com/96/6c/DWAH0Jdx_o.png" alt="image-20211205004758005"></p> 
<ul><li>acquireShared(int arg)共享式获取同步状态。</li><li>同步器调用tryAcquireShared(int arg)来获取同步状态，返回值大于等于0说明获取成功。</li></ul> 
<pre><code class="prism language-java"> <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">acquireShared</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tryAcquireShared</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
            <span class="token function">doAcquireShared</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">doAcquireShared</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">final</span> <span class="token class-name">Node</span> node <span class="token operator">=</span> <span class="token function">addWaiter</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token punctuation">.</span>SHARED<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">boolean</span> failed <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">boolean</span> interrupted <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token keyword">final</span> <span class="token class-name">Node</span> p <span class="token operator">=</span> node<span class="token punctuation">.</span><span class="token function">predecessor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> head<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                    <span class="token keyword">int</span> r <span class="token operator">=</span> <span class="token function">tryAcquireShared</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                        <span class="token function">setHeadAndPropagate</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>
                        p<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
                        <span class="token keyword">if</span> <span class="token punctuation">(</span>interrupted<span class="token punctuation">)</span>
                            <span class="token function">selfInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                        failed <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
                        <span class="token keyword">return</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                <span class="token punctuation">}</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">shouldParkAfterFailedAcquire</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> node<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
                        <span class="token function">parkAndCheckInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                    interrupted <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>failed<span class="token punctuation">)</span>
                <span class="token function">cancelAcquire</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre> 
<h5><a id="4_235"></a>4.独占式超时获取同步状态</h5> 
<ul><li>可以通过调用同步器的doAcquireNanos(int arg,long nanosTimeout)可以超时获取同步状态。</li><li>如果是调用了acquireInterruptibly(int arg)，那么只要线程被中断就会报InterruptedException。</li><li>但是doAcquireNanos(int arg,long nanosTimeout)能够中断，而且可以计算出需要睡眠的时间。nanosTimeout-=now-lastTime如果是大于0说明还没有超时。否则就是超时了。</li><li>如果 nanosTimeout小于等于spinForTimeoutThreshold（1000纳秒）的时候，线程就不会进入到超时等待了。而是进入到快速自旋。直到超时。</li></ul> 
<pre><code class="prism language-java"> <span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">doAcquireNanos</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">,</span> <span class="token keyword">long</span> nanosTimeout<span class="token punctuation">)</span>
            <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">long</span> lastTime <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">final</span> <span class="token class-name">Node</span> node <span class="token operator">=</span> <span class="token function">addWaiter</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token punctuation">.</span>EXCLUSIVE<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">boolean</span> failed <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token keyword">final</span> <span class="token class-name">Node</span> p <span class="token operator">=</span> node<span class="token punctuation">.</span><span class="token function">predecessor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> head <span class="token operator">&amp;&amp;</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                    <span class="token function">setHead</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    p<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// help GC</span>
                    failed <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
                    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>nanosTimeout <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>
                    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">shouldParkAfterFailedAcquire</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> node<span class="token punctuation">)</span>
                        <span class="token operator">&amp;&amp;</span> nanosTimeout <span class="token operator">&gt;</span> spinForTimeoutThreshold<span class="token punctuation">)</span>
                    <span class="token class-name">LockSupport</span><span class="token punctuation">.</span><span class="token function">parkNanos</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> nanosTimeout<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">long</span> now <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//计算时间，当前时间now减去睡眠之前的时间lastTime得到已经睡眠</span>
<span class="token comment">//的时间delta，然后被原有超时时间nanosTimeout减去，得到了</span>
<span class="token comment">//还应该睡眠的时间</span>
                nanosTimeout <span class="token operator">-=</span> now <span class="token operator">-</span> lastTime<span class="token punctuation">;</span>
                lastTime <span class="token operator">=</span> now<span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>failed<span class="token punctuation">)</span>
                <span class="token function">cancelAcquire</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre> 
<h3><a id="53__278"></a>5.3 重入锁</h3> 
<ul><li>支持一个线程多次获取锁。</li><li>公平锁效率未必比非公平的高。</li></ul> 
<h4><a id="1_283"></a>1.实现重进入</h4> 
<ul><li>线程再次获取锁，需要锁去识别当前获取锁的线程是不是和锁的持有线程一样。</li><li>锁的释放，要求的就是计数重复获取锁的数量减低为0。</li><li>下面的方法就增加了线程的判断。增加了同步状态的值。</li></ul> 
<pre><code class="prism language-java">    <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">nonfairTryAcquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> acquires<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">final</span> <span class="token class-name">Thread</span> current <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> acquires<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>current <span class="token operator">==</span> <span class="token function">getExclusiveOwnerThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">int</span> nextc <span class="token operator">=</span> c <span class="token operator">+</span> acquires<span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>nextc <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">"Maximum lock count exceeded"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">setState</span><span class="token punctuation">(</span>nextc<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> 
<ul><li>同样要求在释放的时候，减去状态的值。</li></ul> 
<pre><code class="prism language-java"><span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">tryRelease</span><span class="token punctuation">(</span><span class="token keyword">int</span> releases<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> releases<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token function">getExclusiveOwnerThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalMonitorStateException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">boolean</span> free <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            free <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
            <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token function">setState</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> free<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> 
<h4><a id="2_328"></a>2.公平与非公平获取锁的区别</h4> 
<ul><li>锁是公平那么一定符合FIFO请求的绝对时间顺序。</li><li>对于非公平锁来说只要CAS成功，那么就算是同步状态成功。</li><li>对于公平锁，每次获取锁的时候还需要判断队列是不是有线程等待，才能够获取。</li></ul> 
<pre><code class="prism language-java">    <span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> acquires<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">final</span> <span class="token class-name">Thread</span> current <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">hasQueuedPredecessors</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">compareAndSetState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> acquires<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>current <span class="token operator">==</span> <span class="token function">getExclusiveOwnerThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">int</span> nextc <span class="token operator">=</span> c <span class="token operator">+</span> acquires<span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>nextc <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">"Maximum lock count exceeded"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">setState</span><span class="token punctuation">(</span>nextc<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> 
<ul><li>非公平锁只要CAS状态成功就算是获取锁，所以可能会导致一个线程连续获取锁。</li><li>而且公平锁每次获取锁的线程不同每次都要切换，但是非公平锁可以连续一个线程获取锁，减少切换的成本。</li></ul> 
<h3><a id="54__357"></a>5.4 读写锁</h3> 
<ul><li>读写锁允许同一个时刻多个读线程访问。</li><li>读写锁维护了一对锁。</li><li>ReentrantReadWriteLock的特性 
  <ul><li>公平性选择：支持公平和非公平获取</li><li>可重入</li><li>锁降级</li></ul> </li></ul> 
<h4><a id="541__366"></a>5.4.1 读写锁的接口与示例</h4> 
<p><img src="https://images2.imgbox.com/f8/6e/ughsYEHz_o.png" alt="image-20211205021529068"></p> 
<h4><a id="542__372"></a>5.4.2 读写锁的实现分析</h4> 
<h5><a id="1_374"></a>1.读写状态的设计</h5> 
<ul><li>同样是依靠同步器实现同步的功能。</li><li>维护读写锁的同步状态有多个状态。所以通过按位切割使用。高16位是读，低16位是写。</li><li>当前的同步状态是读锁被同一个线程获取了写锁，重入了两次，而且还获取了两次读锁。</li></ul> 
<p><img src="https://images2.imgbox.com/32/a5/TwQQXc5x_o.png" alt="image-20211205021832670"></p> 
<h5><a id="2_384"></a>2.写锁的获取与释放</h5> 
<ul><li> <p>写锁是支持可重入的排它锁。</p> </li><li> <p>如果当前线程获取了写锁，那么就增加写状态，如果当前线程在获取写锁时，读锁已经被获取或者该线程不是已经获取写锁的线程，那么线程进入到等待状态。</p> </li><li> <p>这里除了判断可重入，还判断是否存在读锁。如果存在读锁，那么写锁就不能被获取。</p> </li><li> <p>因为读写锁需要保证写锁的操作对读锁是可见的。因为读锁被获取的状况，去获取写锁，那么当前运行的线程是没有办法感知当前写线程的操作。</p> </li></ul> 
<pre><code class="prism language-java"> <span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> acquires<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">Thread</span> current <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> w <span class="token operator">=</span> <span class="token function">exclusiveCount</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
<span class="token comment">// 存在读锁或者当前获取线程不是已经获取写锁的线程</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>w <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> current <span class="token operator">!=</span> <span class="token function">getExclusiveOwnerThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>w <span class="token operator">+</span> <span class="token function">exclusiveCount</span><span class="token punctuation">(</span>acquires<span class="token punctuation">)</span> <span class="token operator">&gt;</span> MAX_COUNT<span class="token punctuation">)</span>
                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">"Maximum lock count exceeded"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">setState</span><span class="token punctuation">(</span>c <span class="token operator">+</span> acquires<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">writerShouldBlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token operator">!</span><span class="token function">compareAndSetState</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> c <span class="token operator">+</span> acquires<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> 
<h5><a id="3_414"></a>3.读锁的获取与释放</h5> 
<ul><li>支持可重入的共享锁。</li><li>能被多个线程获取，在没有别的写线程访问的情况下，读锁会被成功获取。</li><li>如果当前线程已经获取了读锁，那么就增加读状态。</li><li>如果当前线程获取读锁的时候，发现写锁被获取，那么就会进入到等待状态。</li></ul> 
<pre><code class="prism language-java"><span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">tryAcquireShared</span><span class="token punctuation">(</span><span class="token keyword">int</span> unused<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">int</span> nextc <span class="token operator">=</span> c <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>nextc <span class="token operator">&lt;</span> c<span class="token punctuation">)</span>
                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">"Maximum lock count exceeded"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">exclusiveCount</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> owner <span class="token operator">!=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetState</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> nextc<span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre> 
<h5><a id="4_436"></a>4.锁降级</h5> 
<ul><li>锁降级指的是写锁降级成为读锁。意思是拿到写锁之后再获取读锁</li><li>锁降级的获取读锁是否有必要？如果不获取读锁，直接释放写锁的问题就是另一个线程获取写锁并且修改数据，那么当前线程无法感知线程T的数据更新。</li></ul> 
<h3><a id="55_LockSupport_443"></a>5.5 LockSupport工具</h3> 
<p><img src="https://images2.imgbox.com/cb/c0/rFXKkB9y_o.png" alt="image-20211205023437669"></p> 
<ul><li>park(Object blocker)、parkNanos(Object blocker,long nanos) 和parkUntil(Object blocker,long deadline)阻塞当前线程，blocker是标识线程等待的对象。</li></ul> 
<h3><a id="56_Condition_453"></a>5.6 Condition接口</h3> 
<h4><a id="562_Condition_455"></a>5.6.2 Condition的实现分析</h4> 
<h5><a id="1_457"></a>1.等待队列</h5> 
<ul><li>是一个FIFO队列。如果线程调用await就会进入Condition的等待队列。</li><li>由于await一定是在获取锁的情况执行，所以不需要CAS保证线程安全性。</li></ul> 
<p><img src="https://images2.imgbox.com/d5/fe/vtezm2lI_o.png" alt="image-20211205023810296"></p> 
<p><img src="https://images2.imgbox.com/f2/10/g9BN5uVB_o.png" alt="image-20211205023927029"></p> 
<h5><a id="2_468"></a>2.等待</h5> 
<ul><li>释放锁，并且线程进入到等待队列。</li></ul> 
<pre><code class="prism language-java">    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 当前线程加入等待队列</span>
        <span class="token class-name">Node</span> node <span class="token operator">=</span> <span class="token function">addConditionWaiter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 释放同步状态，也就是释放锁</span>
        <span class="token keyword">int</span> savedState <span class="token operator">=</span> <span class="token function">fullyRelease</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> interruptMode <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isOnSyncQueue</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token class-name">LockSupport</span><span class="token punctuation">.</span><span class="token function">park</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>interruptMode <span class="token operator">=</span> <span class="token function">checkInterruptWhileWaiting</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">acquireQueued</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> savedState<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> interruptMode <span class="token operator">!=</span> THROW_IE<span class="token punctuation">)</span>
            interruptMode <span class="token operator">=</span> REINTERRUPT<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>nextWaiter <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
            <span class="token function">unlinkCancelledWaiters</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>interruptMode <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>
            <span class="token function">reportInterruptAfterWait</span><span class="token punctuation">(</span>interruptMode<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> 
<h5><a id="3_495"></a>3.通知</h5> 
<ul><li>唤醒之后回到同步队列。</li></ul> 
<p><img src="https://images2.imgbox.com/9c/6c/cP0FI4mN_o.png" alt="image-20211205024106731"></p> 
<h2><a id="6_Java_505"></a>第6章 Java并发容器和框架</h2> 
<h3><a id="61_ConcurrentHashMap_509"></a>6.1 ConcurrentHashMap的实现原理与使用</h3> 
<h4><a id="611_ConcurrentHashMap_511"></a>6.1.1 为什么要使用ConcurrentHashMap</h4> 
<ul><li>并发编程的HashMap容易产生死循环，而且HashTable效率太低。</li><li>（1）线程不安全的HashMap 
  <ul><li>多线程下的put会造成死循环。</li><li>HashMap会进入到一个环形Enrty链表，next永远不是空的。</li></ul> </li></ul> 
<pre><code class="prism language-java"><span class="token keyword">final</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">Thread</span> t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                    <span class="token annotation punctuation">@Override</span>
                    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>UUID<span class="token punctuation">.</span><span class="token function">randomUUID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"ftf"</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"ftf"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
t<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
t<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<ul><li>（2）效率低下的HashTable 
  <ul><li>由于使用synchronized所以效率会比较差一些。</li></ul> </li><li>（3）ConcurrentHashMap锁分段技术有效提高了并发访问率。 
  <ul><li>多线程可以访问容器不同数据段的数据，而且线程之间不存在锁竞争。</li><li>ConcurrentHashMap把数据分段，分配多把锁。</li></ul> </li></ul> 
<h4><a id="612_ConcurrentHashMap_545"></a>6.1.2 ConcurrentHashMap的结构</h4> 
<ul><li>ConcurrentHashMap通过Segment数组结构和HashEntry数组结构组成。</li><li>Segment是可重入锁，HashEntry用于键值对存储数据。修改HashEntry数组必须先获取这段锁。</li></ul> 
<p><img src="https://images2.imgbox.com/ac/71/eem8li9U_o.png" alt="image-20211205024820830"></p> 
<h4><a id="613_ConcurrentHashMap_556"></a>6.1.3 ConcurrentHashMap的初始化</h4> 
<h5><a id="1segments_558"></a>1.初始化segments数组</h5> 
<ul><li>segments长度必须是2^N</li></ul> 
<pre><code class="prism language-java"><span class="token keyword">if</span> <span class="token punctuation">(</span>concurrencyLevel <span class="token operator">&gt;</span> MAX_SEGMENTS<span class="token punctuation">)</span>
     concurrencyLevel <span class="token operator">=</span> MAX_SEGMENTS<span class="token punctuation">;</span>
     <span class="token keyword">int</span> sshift <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
     <span class="token keyword">int</span> ssize <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
     <span class="token keyword">while</span> <span class="token punctuation">(</span>ssize <span class="token operator">&lt;</span> concurrencyLevel<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
     <span class="token operator">++</span>sshift<span class="token punctuation">;</span>
     ssize <span class="token operator">&lt;&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>
     <span class="token punctuation">}</span>
     segmentShift <span class="token operator">=</span> <span class="token number">32</span> <span class="token operator">-</span> sshift<span class="token punctuation">;</span>
     segmentMask <span class="token operator">=</span> ssize <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>segments <span class="token operator">=</span> <span class="token class-name">Segment</span><span class="token punctuation">.</span><span class="token function">newArray</span><span class="token punctuation">(</span>ssize<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h5><a id="2segmentShiftsegmentMask_576"></a>2.初始化segmentShift和segmentMask</h5> 
<ul><li>sshift等于ssize左移位数。默认concurrencyLevel=16，也就是需要移动4次。</li><li>segmentShift等于32减sshift，等于的是28。32是因为ConcurrentHashMap里的hash()方法输出最大是32.也就是算法输出的二进制数的长度是32位。</li><li>segmentMask是散列运算的掩码，等于ssize-1。</li><li>sshift的意思就是ssize的1向左移动的次数，由于ssize一定是2<sup>n，所以只有一个1存在。也就是取高位的几位。取决于Segment的大小的2</sup>n占了多少位。</li></ul> 
<h5><a id="3segment_583"></a>3.初始化每个segment</h5> 
<ul><li> <p>initialCapacity是ConcurrentHashMap的初始化容量。loadfactor是每个segment的负载因子。</p> </li><li> <p>c就是初始容量initialCapacity/ssize，也就是除以Segment数组的大小，可以发现初始的倍数就是1.</p> </li><li> <p>cap就是等于c。</p> </li><li> <p>cap是Segment里面HashEntry数组的长度。</p> </li><li> <p>可以看到一开始的扩容阈值是threshold＝（int）cap*loadFacto=0，也就是只要插入数据就会扩容。</p> </li></ul> 
<pre><code class="prism language-java">  <span class="token keyword">if</span> <span class="token punctuation">(</span>initialCapacity <span class="token operator">&gt;</span> MAXIMUM_CAPACITY<span class="token punctuation">)</span>
    initialCapacity <span class="token operator">=</span> MAXIMUM_CAPACITY<span class="token punctuation">;</span>
    <span class="token keyword">int</span> c <span class="token operator">=</span> initialCapacity <span class="token operator">/</span> ssize<span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">*</span> ssize <span class="token operator">&lt;</span> initialCapacity<span class="token punctuation">)</span>
            <span class="token operator">++</span>c<span class="token punctuation">;</span>
    <span class="token keyword">int</span> cap <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>cap <span class="token operator">&lt;</span> c<span class="token punctuation">)</span>
    cap <span class="token operator">&lt;&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>segments<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>segments<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Segment</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>cap<span class="token punctuation">,</span> loadFactor<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h4><a id="614_Segment_605"></a>6.1.4 定位Segment</h4> 
<ul><li>让元素能够均匀分配到每个Segment，所以需要再一次进行hash操作。避免散列冲突严重。主要根据元素定位Segment的位置。</li><li>默认下segmentShift为28，segmentMask为15，所以每次散列之后的值，右移28位，相当于就是高4位来进行散列运算。避免了大量的散列冲突。相当于hash算法一次，+右移segmentShift与Segment数组大小相与一次一次。</li></ul> 
<pre><code class="prism language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span><span class="token keyword">int</span> h<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    h <span class="token operator">+=</span> <span class="token punctuation">(</span>h <span class="token operator">&lt;&lt;</span> <span class="token number">15</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token number">0xffffcd7d</span><span class="token punctuation">;</span>
    h <span class="token operator">^=</span> <span class="token punctuation">(</span>h <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    h <span class="token operator">+=</span> <span class="token punctuation">(</span>h <span class="token operator">&lt;&lt;</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    h <span class="token operator">^=</span> <span class="token punctuation">(</span>h <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    h <span class="token operator">+=</span> <span class="token punctuation">(</span>h <span class="token operator">&lt;&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span>h <span class="token operator">&lt;&lt;</span> <span class="token number">14</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> h <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h4><a id="615_ConcurrentHashMap_623"></a>6.1.5 ConcurrentHashMap的操作</h4> 
<h5><a id="1get_625"></a>1.get操作</h5> 
<ul><li>首先经过一次散列，然后找到segment。然后再次通过散列找到对应的HashEntry数组的元素。</li><li>get不加锁，只有值是空的时候才会加锁重读。</li><li>get不加锁的原因是计算segment大小的count和存储值的value都是定义为volatile对象。保证了不会读到过期的值。但是只能被单线程写。</li></ul> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token class-name">V</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> hash <span class="token operator">=</span> <span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token function">segmentFor</span><span class="token punctuation">(</span>hash<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> hash<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>	
</code></pre> 
<ul><li>HashEntry是直接重新散列，并没有使用元素的hashCode防止Segment和HashEntry的散列是一样的。</li></ul> 
<pre><code class="prism language-java">hash <span class="token operator">&gt;&gt;&gt;</span> segmentShift<span class="token punctuation">)</span> <span class="token operator">&amp;</span> segmentMask <span class="token comment">// 定位Segment所使用的hash算法</span>
<span class="token keyword">int</span> index <span class="token operator">=</span> hash <span class="token operator">&amp;</span> <span class="token punctuation">(</span>tab<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 定位HashEntry所使用的hash算法</span>
</code></pre> 
<h5><a id="2put_647"></a>2.put操作</h5> 
<ul><li>put的时候必须加锁，先定位Segment。然后进行插入操作。插入的步骤 
  <ul><li>判断Segment的HashEntry是否需要扩容。</li><li>第二步就是添加元素的位置，把它放到HashEntry上面。</li></ul> </li><li>是否需要扩容。 
  <ul><li>首先判断HashEntry的大小是不是大于threshold。如果是那么就扩容。</li></ul> </li><li>如何扩容 
  <ul><li>创建两倍大的数组，然后把之前数组的元素进行再散列插入到新的数组。ConcurrentHashMap只会对部分的Segment进行扩容。</li></ul> </li></ul> 
<h5><a id="3size_657"></a>3.size操作</h5> 
<ul><li>现在是不是把所有Segment的size相加就是能够得到ConcurrentHashMap的大小？ 
  <ul><li>可能相加的时候Segment已经发生了变化。最安全的办法就是把put、remove、clean都给锁住。但是做法的效率非常低下。</li><li>ConcurrentHashMap的做法是先尝试两次统计各个Segment大小。如果count发生变化，那么才会加锁。</li><li>那么ConcurrentHashMap如果判断容器变化了。主要是看modCount也就是put和clean还有remove操作的时候这个变量都会发生变化+1。所以统计size的时候比较前后的modCount是否发生变化。就能够得知容器是否发生变化。</li></ul> </li></ul> 
<h3><a id="62_ConcurrentLinkedQueue_664"></a>6.2 ConcurrentLinkedQueue</h3> 
<ul><li>实现线程安全的队列的两种方式阻塞和非阻塞。 
  <ul><li>阻塞算法使用的是一把锁或者两个锁实现入队和出队。</li><li>非阻塞可以使用CAS解决。</li></ul> </li><li>那么非阻塞是如何做到的？</li><li>ConcurrentLinkedQueue基于链表的节点的无界线程安全队列。先进先出进行的排序。每次加入都加入到队列的尾部。</li></ul> 
<h4><a id="621_ConcurrentLinkedQueue_672"></a>6.2.1 ConcurrentLinkedQueue的结构</h4> 
<p><img src="https://images2.imgbox.com/11/13/zoYFR0fo_o.png" alt="image-20211205123741808"></p> 
<ul><li>有head和tail节点。每个节点通过next关联起来。默认head是空节点，tail指向head节点。</li></ul> 
<h4><a id="622__680"></a>6.2.2 入队列</h4> 
<h5><a id="1_682"></a>1.入队列的过程</h5> 
<ul><li>入队就是把节点加入到队列的末尾。并且把末尾指针指向最后一个节点。</li></ul> 
<p><img src="https://images2.imgbox.com/54/8c/Dh8tdnuc_o.png" alt="image-20211205124051741"></p> 
<ul><li>那么如果发生插队是如何抢占和插入节点的？ 
  <ul><li>入队之前会创建一个节点</li><li>创建一个指向末尾节点的临时节点。</li><li>然后开始先去检查p是否有下一个节点，如果没有下一个节点，那么就能够把n设置为下一个节点。</li><li>如果有那么就循环指向下一个节点。说明已经被别人抢先插入。hops++</li><li>接着如果循环发现next是空的，那么就插入n进去，这个插入是一个CAS，允许失败，也就是可能会多个线程争抢这个位置，如果成功，那么就结束循环。</li><li>如果失败，那么就p指向下一个节点再一次进入循环。</li></ul> </li><li>总结来说就是判断是不是尾节点，如果不是就循环，如果是那么就CAS插入。</li></ul> 
<pre><code class="prism language-java"> <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">offer</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 入队前，创建一个入队节点</span>
        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> n <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
        retry<span class="token operator">:</span>
<span class="token comment">// 死循环，入队不成功反复入队。</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
<span class="token comment">// 创建一个指向tail节点的引用</span>
            <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> t <span class="token operator">=</span> tail<span class="token punctuation">;</span>
<span class="token comment">// p用来表示队列的尾节点，默认情况下等于tail节点。</span>
            <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> p <span class="token operator">=</span> t<span class="token punctuation">;</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> hops <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">;</span> hops<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
<span class="token comment">// 获得p节点的下一个节点。</span>
                <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> next <span class="token operator">=</span> <span class="token function">succ</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// next节点不为空，说明p不是尾节点，需要更新p后在将它指向next节点</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>next <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
<span class="token comment">// 循环了两次及其以上，并且当前节点还是不等于尾节点</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>hops <span class="token operator">&gt;</span> HOPS <span class="token operator">&amp;&amp;</span> t <span class="token operator">!=</span> tail<span class="token punctuation">)</span>
                        <span class="token keyword">continue</span> retry<span class="token punctuation">;</span>
                    p <span class="token operator">=</span> next<span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
<span class="token comment">// 如果p是尾节点，则设置p节点的next节点为入队节点。</span>
                <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span><span class="token function">casNext</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
<span class="token comment">/*如果tail节点有大于等于1个next节点，则将入队节点设置成tail节点，
更新失败了也没关系，因为失败了表示有其他线程成功更新了tail节点*/</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>hops <span class="token operator">&gt;=</span> HOPS<span class="token punctuation">)</span>
                        <span class="token function">casTail</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 更新tail节点，允许失败</span>
                    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
<span class="token comment">// p有next节点,表示p的next节点是尾节点，则重新设置p节点</span>
                <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
                    p <span class="token operator">=</span> <span class="token function">succ</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre> 
<h5><a id="2_738"></a>2.定位尾节点</h5> 
<ul><li>通过succ方法来定位。因为可能尾节点是tail节点，也可能是next。</li></ul> 
<pre><code class="prism language-java"><span class="token keyword">final</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token function">succ</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> p<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> next <span class="token operator">=</span> p<span class="token punctuation">.</span><span class="token function">getNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> next<span class="token punctuation">)</span> head <span class="token operator">:</span> next<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h5><a id="3_749"></a>3.设置入队节点为尾节点</h5> 
<ul><li>p.casNext(null,n)，就是把入队节点设置为p.next的指向节点。</li></ul> 
<h5><a id="4HOPS_753"></a>4.HOPS的设计意图</h5> 
<ul><li>下面的意思就是循环去找到tail节点，并且设置next节点是n。并且重新设置tail节点。这样可行吗？</li><li>这样的问题其实就是CAS的次数太多，每次进来都需要CAS。那么如何减少CAS？</li><li>使用hops变量，并不是每次都把tail节点更新为尾节点，而是tail节点和尾节点大于等于常量HOPS的时候才会更新。距离越长，那么CAS更新的次数就会越少。带来一个问题就是距离越长，定位的时间也就越长。本质上就是增加volatile的读来减少volatile的写。因为写volatile消耗更大，需要增加屏障。</li><li>那么为什么会增加了volatile的读？原因就是CAS的操作是volatile读写一起的，但是纯粹的succ访问下一节点只是一个volatile读操作，前面是知道volatile写操作还需要加上一个StoreLoad屏障，但是volatile读已经不需要加任何屏障，因为X86不允许读写和读读的重排序。</li></ul> 
<pre><code class="prism language-java"> <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">offer</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> n <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> t <span class="token operator">=</span> tail<span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token function">casNext</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">casTail</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre> 
<h4><a id="623__776"></a>6.2.3 出队列</h4> 
<p><img src="https://images2.imgbox.com/56/2c/tC3DIgAu_o.png" alt="image-20211205131113733"></p> 
<ul><li>出队也是利用了hops。 
  <ul><li>首先是p指向了head节点。</li><li>然后获取p的元素。</li><li>如果元素不是空的，那么就设置p的元素是null。而且不是每次都会直接更新头节点，而是等待头结点和真正的头结点有一段距离的时候才会更新。</li></ul> </li><li>总结来说就是判断头节点的元素是不是空，如果是，那么就找到下一个头结点循环判断。如果不是空，那么就设置为空，并且等待超过HOPS的时候才能够重新设置头节点。也是通过增加volatile读的方式来减少volatile的写。</li></ul> 
<pre><code class="prism language-java"> <span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> h <span class="token operator">=</span> head<span class="token punctuation">;</span>
<span class="token comment">// p表示头节点，需要出队的节点</span>
        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> p <span class="token operator">=</span> h<span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> hops <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">;</span> hops<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
<span class="token comment">// 获取p节点的元素</span>
            <span class="token class-name">E</span> item <span class="token operator">=</span> p<span class="token punctuation">.</span><span class="token function">getItem</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 如果p节点的元素不为空，使用CAS设置p节点引用的元素为null,</span>
<span class="token comment">// 如果成功则返回p节点的元素。</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>item <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> p<span class="token punctuation">.</span><span class="token function">casItem</span><span class="token punctuation">(</span>item<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>hops <span class="token operator">&gt;=</span> HOPS<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
<span class="token comment">// 将p节点下一个节点设置成head节点</span>
                    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> q <span class="token operator">=</span> p<span class="token punctuation">.</span><span class="token function">getNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token function">updateHead</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> <span class="token punctuation">(</span>q <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> q <span class="token operator">:</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                <span class="token keyword">return</span> item<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
<span class="token comment">// 如果头节点的元素为空或头节点发生了变化，这说明头节点已经被另外</span>
<span class="token comment">// 一个线程修改了。那么获取p节点的下一个节点</span>
            <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> next <span class="token operator">=</span> <span class="token function">succ</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 如果p的下一个节点也为空，说明这个队列已经空了</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>next <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
<span class="token comment">// 更新头节点。</span>
                <span class="token function">updateHead</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
<span class="token comment">// 如果下一个元素不为空，则将头节点的下一个节点设置成头节点</span>
            p <span class="token operator">=</span> next<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> 
<h3><a id="63_Java_820"></a>6.3 Java中的阻塞队列</h3> 
<h4><a id="631__822"></a>6.3.1 什么是阻塞队列</h4> 
<ul><li>支持阻塞的插入：队列满的时候会阻塞插入元素的线程</li><li>支持阻塞的移除：队列是空的时候，队列阻塞移除的线程。等待非空。</li></ul> 
<p><img src="https://images2.imgbox.com/57/33/jAcRhVyT_o.png" alt="image-20211205131758980"></p> 
<blockquote> 
 <p>遇到队列满和队列空的处理方式。</p> 
</blockquote> 
<ul><li> <p>抛出异常：队列满的时候插入元素就会抛出异常</p> </li><li> <p>返回特殊值：当往队列插入元素的时候，成功true。移除方法取出失败返回null。</p> </li><li> <p>一直阻塞：阻塞队列满的时候，继续put的线程会被阻塞。如果是空的时候get，那么也会被阻塞，直到不空的时候</p> </li><li> <p>超时退出：阻塞队列满的时候，生产者线程往队列里面插入元素，队列就会阻塞生产者线程一段时间，如果超出一段时间生产者线程就会退出。</p> </li></ul> 
<h4><a id="632_Java_841"></a>6.3.2 Java里的阻塞队列</h4> 
<ul><li>ArrayBlockingQueue：数组有界阻塞队列</li><li>LinkedBlockingQueue链表有界阻塞队列</li><li>PriorityBlockingQueue：支持优先级的无界阻塞队列</li><li>DelayQueue：使用优先级队列的无界阻塞队列。</li><li>SynchronousQueue：不存储元素的无界阻塞队列。</li><li>LinkedTransferQueue：链表组成的无界阻塞队列</li><li>LinkedBlockingDeque：链表组成的双向阻塞队列。</li></ul> 
<ol><li>ArrayBlockingQueue</li></ol> 
<ul><li>数组实现的有界阻塞队列，遵循FIFO</li><li>默认不保证线程公平访问队列。也就是阻塞和新进来的线程都能够争夺资源。</li></ul> 
<pre><code>public ArrayBlockingQueue(int capacity, boolean fair) {
    if (capacity &lt;= 0)
    throw new IllegalArgumentException();
    this.items = new Object[capacity];
    lock = new ReentrantLock(fair);
    notEmpty = lock.newCondition();
    notFull = lock.newCondition();
}

</code></pre> 
<ol start="2"><li>LinkedBlockingQueue</li></ol> 
<ul><li>链表实现的有界阻塞队列，也是FIFO</li></ul> 
<ol start="3"><li>PriorityBlockingQueue</li></ol> 
<ul><li>支持优先级的无界阻塞队列，默认是升序。</li></ul> 
<ol start="4"><li>DelayQueue</li></ol> 
<ul><li>支持延时获取元素的无界阻塞队列。使用的是优先级队列实现的。</li><li>队列接口必须实现Delayed接口。创建元素多久才能够被获取。</li><li>应用 
  <ul><li>缓存系统设计：队列保存缓存的有效期。并且线程轮询。</li><li>定时任务调度：一旦能够获取任务，就可以执行。</li></ul> </li><li>（1）如何实现Delayed接口 
  <ul><li>初始化基本数据，time记录对象延迟什么时候可以使用。</li><li>实现getDelay方法，返回当前元素还需要延时的时间。</li><li>compareTo指定元素的顺序。把延时比较长的放到末尾。</li></ul> </li><li>（2）如何实现延时阻塞队列 
  <ul><li>获取元素的时候没有达到延时时间就会被阻塞。</li></ul> </li></ul> 
<ol start="5"><li>SynchronousQueue</li></ol> 
<ul><li>不存储元素的阻塞队列。</li><li>每个put必须等待一个take。否则不能继续添加元素。</li><li>支持公平访问队列。默认是非公平的。</li><li>传递的速度非常快</li></ul> 
<ol start="6"><li>LinkedTransferQueue</li></ol> 
<ul><li>由链表结构组成的无界阻塞TransferQueue队列</li><li>多出tryTransfer和transfer方法。</li><li>（1）transfer方法 
  <ul><li>transfer可以把元素立刻传输给消费者。如果没有消费者，那么就存放到尾部。</li><li>下面的关键代码</li><li>第一行尝试把s当前节点作为tail节点。</li><li>第二行是CPU自旋等待消费者消费元素。自旋一定次数会调用yield来切换元素。</li></ul> </li></ul> 
<pre><code class="prism language-java"><span class="token class-name">Node</span> pred <span class="token operator">=</span> <span class="token function">tryAppend</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> haveData<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">return</span> <span class="token function">awaitMatch</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> pred<span class="token punctuation">,</span> e<span class="token punctuation">,</span> <span class="token punctuation">(</span>how <span class="token operator">==</span> TIMED<span class="token punctuation">)</span><span class="token punctuation">,</span> nanos<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<ul><li>（2）tryTransfer方法 
  <ul><li>试探生产者的元素是否能够传给消费者。</li><li>可以设置时间等待。tryTransfer（E e，long timeout，TimeUnit unit）如果没有指定的消费者消费，那么就会返回false。</li></ul> </li></ul> 
<ol start="7"><li>LinkedBlockingDeque</li></ol> 
<ul><li>由链表结构组成的双向阻塞队列</li></ul> 
<h4><a id="633__926"></a>6.3.3 阻塞队列的实现原理</h4> 
<ul><li> <p>消费者和生产者如何知道队列的情况？</p> </li><li> <p>如何高效通信？</p> </li><li> <p>使用通知模式实现。生产者添加元素的时候阻塞住生产者，消费者消费了一个元素之后会通知生产者队列可用。可以看到ArrayBlockingQueue使用了Condition实现。</p> </li></ul> 
<pre><code class="prism language-java"><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Condition</span> notFull<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Condition</span> notEmpty<span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token class-name">ArrayBlockingQueue</span><span class="token punctuation">(</span><span class="token keyword">int</span> capacity<span class="token punctuation">,</span> <span class="token keyword">boolean</span> fair<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
<span class="token comment">// 省略其他代码</span>
        notEmpty <span class="token operator">=</span> lock<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        notFull <span class="token operator">=</span> lock<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{<!-- --></span>
        <span class="token function">checkNotNull</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">final</span> <span class="token class-name">ReentrantLock</span> lock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">;</span>
        lock<span class="token punctuation">.</span><span class="token function">lockInterruptibly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> items<span class="token punctuation">.</span>length<span class="token punctuation">)</span>
                notFull<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">insert</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{<!-- --></span>
            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">final</span> <span class="token class-name">ReentrantLock</span> lock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">;</span>
        lock<span class="token punctuation">.</span><span class="token function">lockInterruptibly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
                notEmpty<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token function">extract</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{<!-- --></span>
            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span><span class="token class-name">E</span> x<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        items<span class="token punctuation">[</span>putIndex<span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">;</span>
        putIndex <span class="token operator">=</span> <span class="token function">inc</span><span class="token punctuation">(</span>putIndex<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token operator">++</span>count<span class="token punctuation">;</span>
        notEmpty<span class="token punctuation">.</span><span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> 
<ul><li>而且这里的await的原理实际上就是LockSupport的阻塞。park的原理是unsafe的park来阻塞当前的线程。这是一个native的方法。</li></ul> 
<pre><code class="prism language-java"><span class="token comment">//await的原理。</span>
<span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Node</span> node <span class="token operator">=</span> <span class="token function">addConditionWaiter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> savedState <span class="token operator">=</span> <span class="token function">fullyRelease</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> interruptMode <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isOnSyncQueue</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token class-name">LockSupport</span><span class="token punctuation">.</span><span class="token function">park</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>interruptMode <span class="token operator">=</span> <span class="token function">checkInterruptWhileWaiting</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">acquireQueued</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> savedState<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> interruptMode <span class="token operator">!=</span> THROW_IE<span class="token punctuation">)</span>
            interruptMode <span class="token operator">=</span> REINTERRUPT<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>nextWaiter <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token comment">// clean up if cancelled</span>
            <span class="token function">unlinkCancelledWaiters</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>interruptMode <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>
            <span class="token function">reportInterruptAfterWait</span><span class="token punctuation">(</span>interruptMode<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token comment">//Lock.park</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">park</span><span class="token punctuation">(</span><span class="token class-name">Object</span> blocker<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token class-name">Thread</span> t <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">setBlocker</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> blocker<span class="token punctuation">)</span><span class="token punctuation">;</span>
    unsafe<span class="token punctuation">.</span><span class="token function">park</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token number">0L</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">setBlocker</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//Unsafe.park</span>
<span class="token keyword">public</span> <span class="token keyword">native</span> <span class="token keyword">void</span> <span class="token function">park</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> isAbsolute<span class="token punctuation">,</span> <span class="token keyword">long</span> time<span class="token punctuation">)</span><span class="token punctuation">;</span>


</code></pre> 
<ul><li>只有在park对应的unpark执行的时候才会返回。</li><li>或者是线程中断</li><li>或者是park超时</li><li>或者是出现了异常。</li></ul> 
<blockquote> 
 <p>JVM如何实现park。</p> 
</blockquote> 
<ul><li>Linux系统的pthread_cond_wait实现的。</li></ul> 
<h3><a id="64_ForkJoin_1019"></a>6.4 Fork/Join框架</h3> 
<h4><a id="641_ForkJoin_1021"></a>6.4.1 什么是Fork/Join框架</h4> 
<ul><li>把大任务切分成各种小任务，并且最后把结果汇总的框架。</li></ul> 
<p><img src="https://images2.imgbox.com/59/38/Cwn2oOsY_o.png" alt="image-20211205134633342"></p> 
<h4><a id="642__1029"></a>6.4.2 工作窃取算法</h4> 
<ul><li>某个线程从其它队列窃取任务执行。</li><li>为了减少竞争我们会把各个切分的子任务放到不同的队列。并且一个队列创建一个线程来执行。</li><li>但是有的线程把任务执行完之后去帮助别的线程处理。所以为了减少两个线程竞争，它会把队列弄成双端的。</li><li>优点是充分利用线程计算，减少线程间的竞争</li><li>缺点是双端队列只有一个任务的时候，仍然存在竞争。算法消耗资源，创建多个线程和队列。</li></ul> 
<p><img src="https://images2.imgbox.com/21/b5/xP3wxjfJ_o.png" alt="image-20211205134847943"></p> 
<h4><a id="643_ForkJoin_1043"></a>6.4.3 Fork/Join框架的设计</h4> 
<ol><li>分割任务</li><li>执行并合并任务。分割的任务放到双端队列，结果统一放到一个队列。</li><li>启动线程并且从队列拿出数据合并。</li></ol> 
<blockquote> 
 <p>Fork/Join使用两个类来完成以上两件事情</p> 
</blockquote> 
<ul><li>使用ForkJoinTask的子类 
  <ul><li>RecursiveAction：没有结果的任务</li><li>RecursiveTask：有返回结果的任务。</li></ul> </li><li>ForkJoinPool：ForkJoinTask需要通过ForkJoinPool来执行。</li></ul> 
<h4><a id="644_ForkJoin_1058"></a>6.4.4 使用Fork/Join框架</h4> 
<ul><li>实际上就是一个二分递归算法。</li></ul> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CountTask</span> <span class="token keyword">extends</span> <span class="token class-name">RecursiveTask</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> THRESHOLD <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">// 阈值</span>
        <span class="token keyword">private</span> <span class="token keyword">int</span> start<span class="token punctuation">;</span>
        <span class="token keyword">private</span> <span class="token keyword">int</span> end<span class="token punctuation">;</span>
        <span class="token keyword">public</span> <span class="token class-name">CountTask</span><span class="token punctuation">(</span><span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>start <span class="token operator">=</span> start<span class="token punctuation">;</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>end <span class="token operator">=</span> end<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">protected</span> <span class="token class-name">Integer</span> <span class="token function">compute</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token comment">// 如果任务足够小就计算任务</span>
            <span class="token keyword">boolean</span> canCompute <span class="token operator">=</span> <span class="token punctuation">(</span>end <span class="token operator">-</span> start<span class="token punctuation">)</span> <span class="token operator">&lt;=</span> THRESHOLD<span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>canCompute<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> start<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> end<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                    sum <span class="token operator">+=</span> i<span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
<span class="token comment">// 如果任务大于阈值，就分裂成两个子任务计算</span>
                <span class="token keyword">int</span> middle <span class="token operator">=</span> <span class="token punctuation">(</span>start <span class="token operator">+</span> end<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>
                <span class="token class-name">CountTask</span> leftTask <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountTask</span><span class="token punctuation">(</span>start<span class="token punctuation">,</span> middle<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token class-name">CountTask</span> rightTask <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountTask</span><span class="token punctuation">(</span>middle <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 执行子任务</span>
                leftTask<span class="token punctuation">.</span><span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                rightTask<span class="token punctuation">.</span><span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 等待子任务执行完，并得到其结果</span>
                <span class="token keyword">int</span> leftResult<span class="token operator">=</span>leftTask<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">int</span> rightResult<span class="token operator">=</span>rightTask<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 合并子任务</span>
                sum <span class="token operator">=</span> leftResult <span class="token operator">+</span> rightResult<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">return</span> sum<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token class-name">ForkJoinPool</span> forkJoinPool <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ForkJoinPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 生成一个计算任务，负责计算1+2+3+4</span>
            <span class="token class-name">CountTask</span> task <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountTask</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 执行一个任务</span>
            <span class="token class-name">Future</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> result <span class="token operator">=</span> forkJoinPool<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>result<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ExecutionException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre> 
<h4><a id="645_ForkJoin_1111"></a>6.4.5 Fork/Join框架的异常处理</h4> 
<ul><li>可以通过isCompletedAbnormally()检查任务是否出现异常。</li></ul> 
<h4><a id="646_ForkJoin_1117"></a>6.4.6 Fork/Join框架的实现原理</h4> 
<ul><li>ForkJoinPool由ForkJoinTask数组和ForkJoinWorkerThread数组组成。一个表示任务，一个就是线程执行任务。</li><li>（1）ForkJoinTask的fork方法实现原理 
  <ul><li>实际上就是异步执行这个任务。调用了一个thread。</li><li>pushTask把任务存放到task数组上，并且调用ForkJoinPool的signalWork方法唤醒一个线程执行。</li></ul> </li></ul> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token class-name">ForkJoinTask</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">ForkJoinWorkerThread</span><span class="token punctuation">)</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token function">pushTask</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<ul><li>（2）ForkJoinTask的join方法实现原理 
  <ul><li>阻塞当前线程并且等待结果。</li><li>调用了doJon方法。得到任务的状态。判断任务是否完成。任务的分为三个状态。已完成（NORMAL）、被取消（CANCELLED）、信号（SIGNAL）和出现异常 （EXCEPTIONAL）。</li><li>如果发现任务没有完成，那么就去拿出线程来执行</li><li>如果完成那么就返回</li><li>如果出现异常那么就抛出异常。</li></ul> </li></ul> 
<pre><code class="prism language-java"><span class="token comment">//join</span>
<span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token class-name">V</span> <span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">doJoin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> NORMAL<span class="token punctuation">)</span>
            <span class="token keyword">return</span> <span class="token function">reportResult</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span>
            <span class="token keyword">return</span> <span class="token function">getRawResult</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">private</span> <span class="token class-name">V</span> <span class="token function">reportResult</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> s<span class="token punctuation">;</span> <span class="token class-name">Throwable</span> ex<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>s <span class="token operator">=</span> status<span class="token punctuation">)</span> <span class="token operator">==</span> CANCELLED<span class="token punctuation">)</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">CancellationException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">==</span> EXCEPTIONAL <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>ex <span class="token operator">=</span> <span class="token function">getThrowableException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
            UNSAFE<span class="token punctuation">.</span><span class="token function">throwException</span><span class="token punctuation">(</span>ex<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token function">getRawResult</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token comment">//doJoin</span>
<span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">doJoin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">Thread</span> t<span class="token punctuation">;</span> <span class="token class-name">ForkJoinWorkerThread</span> w<span class="token punctuation">;</span> <span class="token keyword">int</span> s<span class="token punctuation">;</span> <span class="token keyword">boolean</span> completed<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>t <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">instanceof</span> <span class="token class-name">ForkJoinWorkerThread</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>s <span class="token operator">=</span> status<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
                <span class="token keyword">return</span> s<span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>w <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">ForkJoinWorkerThread</span><span class="token punctuation">)</span>t<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unpushTask</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
                    completed <span class="token operator">=</span> <span class="token function">exec</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> rex<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                    <span class="token keyword">return</span> <span class="token function">setExceptionalCompletion</span><span class="token punctuation">(</span>rex<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>completed<span class="token punctuation">)</span>
                    <span class="token keyword">return</span> <span class="token function">setCompletion</span><span class="token punctuation">(</span>NORMAL<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">return</span> w<span class="token punctuation">.</span><span class="token function">joinTask</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">else</span>
            <span class="token keyword">return</span> <span class="token function">externalAwaitDone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

</code></pre> 
<h2><a id="7_Java13_1183"></a>第7章 Java中的13个原子操作类</h2> 
<h3><a id="71__1185"></a>7.1 原子更新基本类型类</h3> 
<ul><li>·AtomicBoolean：原子更新布尔类型。</li><li>·AtomicInteger：原子更新整型。</li><li>·AtomicLong：原子更新长整型。</li></ul> 
<blockquote> 
 <p>提供的方法</p> 
</blockquote> 
<ul><li>int addAndGet（int delta）输入值与实例的值相加。并且返回结果</li><li>boolean compareAndSet（int expect，int update）：输入的值与预期的一样，那么就会把原来的值设置为新的值。</li><li>int getAndIncrement()：原子的方式自增。</li><li>void lazySet（int newValue）：最终会设置为新值，可能会延迟。</li><li>·int getAndSet（int newValue）：原子的方式设置新的值。并且返回旧的值。</li></ul> 
<blockquote> 
 <p>getAndIncrement如何实现原子操作</p> 
</blockquote> 
<ul><li>首先是获取原来Atomoic存储的值</li><li>然后进行加一。</li><li>compareAndSet(current, next)进行原子操作。检查当前的值是否等于current，如果没有被修改就能赋值。</li></ul> 
<pre><code class="prism language-java"> <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">getAndIncrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">int</span> current <span class="token operator">=</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">int</span> next <span class="token operator">=</span> current <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span>current<span class="token punctuation">,</span> next<span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token keyword">return</span> current<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">compareAndSet</span><span class="token punctuation">(</span><span class="token keyword">int</span> expect<span class="token punctuation">,</span> <span class="token keyword">int</span> update<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> unsafe<span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> valueOffset<span class="token punctuation">,</span> expect<span class="token punctuation">,</span> update<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> 
<ul><li>Atomic的类基本是Unsafe实现的。</li></ul> 
<pre><code class="prism language-java"> <span class="token comment">/**
     * 如果当前数值是expected，则原子的将Java变量更新成x
     * @return 如果更新成功则返回true
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">native</span> <span class="token keyword">boolean</span> <span class="token function">compareAndSwapObject</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">,</span>
                                                     <span class="token keyword">long</span> offset<span class="token punctuation">,</span>
                                                     <span class="token class-name">Object</span> expected<span class="token punctuation">,</span>
                                                     <span class="token class-name">Object</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">native</span> <span class="token keyword">boolean</span> <span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">,</span> <span class="token keyword">long</span> offset<span class="token punctuation">,</span>
                                                  <span class="token keyword">int</span> expected<span class="token punctuation">,</span>
                                                  <span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">native</span> <span class="token keyword">boolean</span> <span class="token function">compareAndSwapLong</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">,</span> <span class="token keyword">long</span> offset<span class="token punctuation">,</span>
                                                   <span class="token keyword">long</span> expected<span class="token punctuation">,</span>
                                                   <span class="token keyword">long</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h3><a id="72__1244"></a>7.2 原子更新数组</h3> 
<ul><li> <p>·AtomicIntegerArray：原子更新整型数组里的元素。</p> </li><li> <p>·AtomicLongArray：原子更新长整型数组里的元素。</p> </li><li> <p>·AtomicReferenceArray：原子更新引用类型数组里的元素。</p> </li><li> <p>·AtomicIntegerArray类主要是提供原子的方式更新数组里的整型</p> </li></ul> 
<blockquote> 
 <p>他们的方法与api</p> 
</blockquote> 
<ul><li>int addAndGet（int i，int delta）：原子方式把delta与索引是i的值相加</li><li>boolean compareAndSet（int i，int expect，int update）：是否等于预期的值，如果是才能够修改。</li></ul> 
<h3><a id="73__1261"></a>7.3 原子更新引用类型</h3> 
<ul><li>·AtomicReference：原子更新引用类型。</li><li>·AtomicReferenceFieldUpdater：原子更新引用类型里的字段。</li><li>·AtomicMarkableReference：原子更新带有标记位的引用类型。</li><li>主要是能够原子更新AtomicReference也就是它指向的引用。</li></ul> 
<h3><a id="74__1270"></a>7.4 原子更新字段类</h3> 
<ul><li> <p>·AtomicIntegerFieldUpdater：原子更新整型的字段的更新器。</p> </li><li> <p>·AtomicLongFieldUpdater：原子更新长整型字段的更新器。</p> </li><li> <p>·AtomicStampedReference：原子更新带有版本号的引用类型。</p> </li><li> <p>使用方式就是定位位置，然后调用方法即可。</p> </li></ul> 
<pre><code class="prism language-java"> <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AtomicIntegerFieldUpdaterTest</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 创建原子更新器，并设置需要更新的对象类和对象的属性</span>
        <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">AtomicIntegerFieldUpdater</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">&gt;</span></span> a <span class="token operator">=</span> <span class="token class-name">AtomicIntegerFieldUpdater</span><span class="token punctuation">.</span>
                <span class="token function">newUpdater</span><span class="token punctuation">(</span><span class="token class-name">User</span><span class="token punctuation">.</span><span class="token keyword">class</span>， <span class="token string">"old"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
<span class="token comment">// 设置柯南的年龄是10岁</span>
            <span class="token class-name">User</span> conan <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token string">"conan"</span>， <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 柯南长了一岁，但是仍然会输出旧的年龄</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">getAndIncrement</span><span class="token punctuation">(</span>conan<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 输出柯南现在的年龄</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>conan<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>
            <span class="token keyword">public</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span> old<span class="token punctuation">;</span>
            <span class="token keyword">public</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token class-name">String</span> name， <span class="token keyword">int</span> old<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
                <span class="token keyword">this</span><span class="token punctuation">.</span>old <span class="token operator">=</span> old<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token keyword">return</span> name<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getOld</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token keyword">return</span> old<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre> 
<h2><a id="9_Java_1313"></a>第9章 Java中的线程池</h2> 
<blockquote> 
 <p>线程池的好处</p> 
</blockquote> 
<ul><li>降低资源消耗。利用已经创建线程，减少线程的创建和销毁带来的性能消耗。</li><li>提高响应速度。当任务到达的时候，任务可以不需要线程创建就能够立即执行。</li><li>提高线程的可管理性。</li></ul> 
<h3><a id="91__1321"></a>9.1 线程池的实现原理</h3> 
<ul><li>线程池判断核心线程池里面的线程是否都在执行任务。如果不是那么就创建一个新的线程来执行任务。如果核心线程池线程都在执行任务，那么进入下一个流程。</li><li>线程池判断工作队列是不是满了，如果没有满，那么就把任务存储在队列。如果满了，那么进入到下一个流程</li><li>线程池判断线程池的线程是不是都处于工作状态，如果没有就创建一个执行任务，否则只能执行饱和策略来执行任务了。</li></ul> 
<p><img src="https://images2.imgbox.com/4f/a8/1kkr0pUk_o.png" alt="image-20211205155847511"></p> 
<blockquote> 
 <p>ThreadPoolExecutor执行execute方法分四种。</p> 
</blockquote> 
<ol><li>当前运行的线程数少于corePoolSize，那么创建新的线程工作。</li><li>如果当前运行线程数大于corePoolSize，那么就把任务加入到BlockingQueue。</li><li>如果无法将任务加入到BlockingQueue也就是队列满的情况，那么就要创建新的线程执行。</li><li>如果线程超出了maximumPoolSize那么执行执行饱和策略了。</li></ol> 
<p><img src="https://images2.imgbox.com/18/28/cvW1AJHN_o.png" alt="image-20211205160152922"></p> 
<blockquote> 
 <p>源码分析</p> 
</blockquote> 
<ul><li>command就是任务，判断逻辑基本上是和上面是一模一样的。</li></ul> 
<pre><code class="prism language-java">   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> command<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>command <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 如果线程数小于基本线程数，则创建线程并执行当前任务</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>poolSize <span class="token operator">&gt;=</span> corePoolSize <span class="token operator">||</span> <span class="token operator">!</span><span class="token function">addIfUnderCorePoolSize</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
<span class="token comment">// 如线程数大于等于基本线程数或线程创建失败，则将当前任务放到工作队列中。</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>runState <span class="token operator">==</span> RUNNING <span class="token operator">&amp;&amp;</span> workQueue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>runState <span class="token operator">!=</span> RUNNING <span class="token operator">||</span> poolSize <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
                    <span class="token function">ensureQueuedTaskHandled</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
<span class="token comment">// 如果线程池不处于运行中或任务无法放入队列，并且当前线程数量小于最大允许的线程数量，</span>
<span class="token comment">// 则创建一个线程执行任务。</span>
            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">addIfUnderMaximumPoolSize</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment">// 抛出RejectedExecutionException异常</span>
                <span class="token function">reject</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// is shutdown or saturated</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre> 
<blockquote> 
 <p>工作线程</p> 
</blockquote> 
<ul><li>线程会被封装为Worker。Worker执行任务之后还会循环获取工作队列里面的任务执行。</li><li>可以看看run方法。就是不断循环，并且获取任务执行。</li></ul> 
<pre><code class="prism language-java">    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
            <span class="token class-name">Runnable</span> task <span class="token operator">=</span> firstTask<span class="token punctuation">;</span>
            firstTask <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span>task <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token punctuation">(</span>task <span class="token operator">=</span> <span class="token function">getTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token function">runTask</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>
                task <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{<!-- --></span>
            <span class="token function">workerDone</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/88/be/SZqHdPQU_o.png" alt="image-20211205160839933"></p> 
<ul><li>线程池执行任务分为两种情况 
  <ul><li>execute方法创建线程，并且执行任务</li><li>线程执行任务之后，会取到BlockingQueue获取任务执行。</li></ul> </li></ul> 
<h3><a id="92__1394"></a>9.2 线程池的使用</h3> 
<h4><a id="921__1396"></a>9.2.1 线程池的创建</h4> 
<pre><code class="prism language-java"><span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span>corePoolSize<span class="token punctuation">,</span> maximumPoolSize<span class="token punctuation">,</span> keepAliveTime<span class="token punctuation">,</span>
milliseconds<span class="token punctuation">,</span>runnableTaskQueue<span class="token punctuation">,</span> handler<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<ul><li>corePoolSize：核心线程数</li><li>runnableTaskQueue：任务队列。也就是上面提到的各种阻塞队列。比如ArrayBlockingQueue。 
  <ul><li>ArrayBlockingQueue</li><li>·LinkedBlockingQueue</li><li>·SynchronousQueue</li><li>PriorityBlockingQueue</li></ul> </li><li>maximumPoolSize：线程的最大数量。</li><li>ThreadFactory：创建线程的工厂。线程工厂可以给线程赋予名字。</li><li>RejectedExecutionHandler：饱和策略。队列和线程池都已经满的情况如何处理任务。 
  <ul><li>AbortPolicy：抛出异常</li><li>CallerRunsPolicy：调用者所在的线程执行任务</li><li>DiscardOldestPolicy：丢弃队列最近的一个任务</li><li>DiscardPolicy：直接丢弃。</li></ul> </li><li>keepAliveTime：超过corePoolSize的线程空闲存活时间。</li><li>TimeUnit：上面存活时间的一个单位。</li></ul> 
<h4><a id="922__1419"></a>9.2.2 向线程池提交任务</h4> 
<ul><li>execute不需要返回值。只需要输入一个Runnable任务。</li></ul> 
<pre><code class="prism language-java">   threadsPool<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
<span class="token comment">// TODO Auto-generated method stub</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<ul><li>submit返回一个Future对象。相当于就是数据封装到了Future这里。</li></ul> 
<pre><code class="prism language-java"> <span class="token class-name">Future</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> future <span class="token operator">=</span> executor<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span>harReturnValuetask<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
            <span class="token class-name">Object</span> s <span class="token operator">=</span> future<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
<span class="token comment">// 处理中断异常</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ExecutionException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
<span class="token comment">// 处理无法执行任务异常</span>
        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{<!-- --></span>
<span class="token comment">// 关闭线程池</span>
            executor<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
</code></pre> 
<h4><a id="923__1450"></a>9.2.3 关闭线程池</h4> 
<ul><li>调用线程池的shutdown或者是shutdownNow方法关闭线程池。原理是遍历工作线程，发出中断信号。 
  <ul><li>shutdownNow设置线程状态是STOP然后尝试停止所有线程</li><li>shutdown只是设置线程状态SHUTDOWN，中断所有没有执行任务的线程。</li></ul> </li><li>所有任务关闭，那么线程池关闭成功。</li></ul> 
<h4><a id="924__1459"></a>9.2.4 合理地配置线程池</h4> 
<blockquote> 
 <p>从哪方面考量？</p> 
</blockquote> 
<ul><li>任务性质：CPU密集型还是IO密集型</li><li>任务的优先级</li><li>任务执行时间</li><li>任务的依赖性。</li></ul> 
<blockquote> 
 <p>如何选择线程池</p> 
</blockquote> 
<ul><li>CPU密集型选择线程尽可能少一点的。</li><li>对于IO密集型的选择线程多一些，因为IO密集说明不是所有线程都能工作。有的被阻塞导致CPU无法很好被使用。</li><li>优先级不同可以使用PriorityBlockingQueue来进行处理。能够让优先级更高的任务先执行。</li><li>依赖数据库连接池的任务，线程提交SQL之后会进入阻塞，所以使用更多线程会更好使用CPU。</li><li>建议使用有界队列，避免任务的积压。任务积压导致的内存撑满的问题，会导致程序直接结束。</li></ul> 
<h4><a id="925__1476"></a>9.2.5 线程池的监控</h4> 
<blockquote> 
 <p>如何监控？</p> 
</blockquote> 
<ul><li>通过各种线程池参数 
  <ul><li>taskCount：线程池需要执行的任务数量</li><li>completedTaskCount：线程池完成任务的数量</li><li>largestPoolSize：创建过的线程池最大的数量。</li><li>getPoolSize：线程池的线程数量。</li><li>getActiveCount：获取活动的线程数。</li></ul> </li></ul> 
<h2><a id="10_Executor_1497"></a>第10章 Executor框架</h2> 
<h3><a id="101_Executor_1499"></a>10.1 Executor框架简介</h3> 
<h4><a id="1011_Executor_1501"></a>10.1.1 Executor框架的两级调度模型</h4> 
<ul><li>在HotSpot VM模型里面，java线程被一对一映射为本地操作系统的线程。操作系统可以调度线程，分配给CPU。</li><li>java多线程会把应用分成多个任务，然后使用用户级的调度器。把任务映射为固定数量的线程。操作系统内核会把这些线程映射到硬件处理器上。</li><li>也就是说Executor把任务分配给线程执行，线程通过操作系统内核来映射到CPU的调度。</li></ul> 
<h4><a id="1012_Executor_1507"></a>10.1.2 Executor框架的结构与成员</h4> 
<p><img src="https://images2.imgbox.com/25/0c/OuJH50au_o.png" alt="image-20211205162907845"></p> 
<h5><a id="1Executor_1515"></a>1.Executor框架的结构</h5> 
<blockquote> 
 <p>组成部分</p> 
</blockquote> 
<ul><li>任务：实现任务的Callable和Runnable接口</li><li>任务执行：任务执行机制的核心接口Executor，以及集成Executor的ExecutorService。还有两个实现了ExecutorService接口的ThreadPoolExecutor和ScheduledThreadPoolExecutor。</li><li>异步计算的结果。也就是Future接口和实现Future接口的FutureTask类</li></ul> 
<blockquote> 
 <p>类和接口的简介</p> 
</blockquote> 
<ul><li>Executor是Executor框架的基础，把任务的提交和任务的执行分离开。</li><li>ThreadPoolExecutor：线程池的核心实现类。执行被被提交的任务。</li><li>ScheduledThreadPoolExecutor：延迟执行命令。或者定期执行命令。</li><li>Future：代表异步计算结果。</li><li>Runnable和Callable的实现类可以被ThreadPoolExecutpor和ScheduledThreadPoolExecutor。</li></ul> 
<p><img src="https://images2.imgbox.com/78/7e/7Tykv25m_o.png" alt="image-20211205164408937"></p> 
<blockquote> 
 <p>Executor框架的使用。</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/a0/f6/d1J6K0Ph_o.png" alt="image-20211205164425841"></p> 
<ul><li>首先是主线程要创建Runnable或者是Callable的实现对象，</li><li>然后把任务对象Runnable交给ExecutorService执行execute。</li><li>如果任务对象是Callable那么就是执行submit。返回一个Future异步结果。</li><li>主线程可以通过Future的get来等待任务执行结束。</li></ul> 
<h5><a id="2Executor_1544"></a>2.Executor框架的成员</h5> 
<ul><li>（1）ThreadPoolExecutor 
  <ul><li>这个通常直接通过工厂类Executors直接创建。</li><li>Executors创建3种类型的ThreadPoolExecutor：SingleThreadExecutor、FixedThreadPool和CachedThreadPool。</li><li>1）FixedThreadPool。：创建固定线程的线程池。适用负载比较重的服务器。</li><li>2）SingleThreadExecutor：顺序完成任务，所以只有一个线程在执行。</li><li>3）CachedThreadPool。：根据需要创建线程，线程数量是无限的。可以执行很多小任务。适用于负载比较轻的。</li></ul> </li><li>（2）ScheduledThreadPoolExecutor 
  <ul><li>两种类型。</li><li>ScheduledThreadPoolExecutor包含若干个线程的类型 
    <ul><li>适合多个后台的周期执行任务。</li></ul> </li><li>SingleThreadScheduledExecutor包含一个线程的类型 
    <ul><li>适合单个后台的周期执行任务。</li></ul> </li></ul> </li><li>（3）Future接口 
  <ul><li>能够表示异步计算的结果，通过FutureTask。</li></ul> </li><li>（4）Runnable接口和Callable接口 
  <ul><li>就是任务的实现接口。</li></ul> </li></ul> 
<h3><a id="102_ThreadPoolExecutor_1563"></a>10.2 ThreadPoolExecutor详解</h3> 
<ul><li>corePool：核心线程池的大小</li><li>·maximumPool：最大线程池的大小。</li><li>·BlockingQueue：用来暂时保存任务的工作队列。</li><li>·RejectedExecutionHandler：饱和策略。</li></ul> 
<h4><a id="1021_FixedThreadPool_1574"></a>10.2.1 FixedThreadPool详解</h4> 
<ul><li>corePool和maximumPool都被设置为nThreads</li><li>说明不能够有多余的线程。</li></ul> 
<pre><code class="prism language-java">    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">ExecutorService</span> <span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token keyword">int</span> nThreads<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span>nThreads<span class="token punctuation">,</span> nThreads<span class="token punctuation">,</span>
                <span class="token number">0L</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">,</span>
                <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Runnable</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/cf/04/euQcrl8U_o.png" alt="image-20211205165410522"></p> 
<ol><li>如果当前线程少于core那么就创建线程执行任务</li><li>线程池完成预热之后，把任务加入到LinkedBlockingQueue。</li><li>执行完1的任务之后，会反复去到队列获取任务。</li></ol> 
<ul><li>这个线程池不拒绝新任务</li></ul> 
<h4><a id="1022_SingleThreadExecutor_1597"></a>10.2.2 SingleThreadExecutor详解</h4> 
<ul><li>core和max线程数量都是1。</li><li>与无界队列LinkedBlockingQueue配合。</li></ul> 
<pre><code class="prism language-java">    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">ExecutorService</span> <span class="token function">newSingleThreadExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">FinalizableDelegatedExecutorService</span>
                <span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span>
                        <span class="token number">0L</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">,</span>
                        <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Runnable</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> 
<h4><a id="1023_CachedThreadPool_1611"></a>10.2.3 CachedThreadPool详解</h4> 
<ul><li>这里没有core但是max是被设置为无界的。说明可以不断创建线程。</li><li>使用的队列是SynchronousQueue。也就是来一个任务必须要快速找到线程处理</li><li>如果任务太多可能会导致内存不足。</li></ul> 
<pre><code class="prism language-java">    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">ExecutorService</span> <span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">,</span>
                <span class="token number">60L</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>SECONDS<span class="token punctuation">,</span>
                <span class="token keyword">new</span> <span class="token class-name">SynchronousQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Runnable</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

</code></pre> 
<p><img src="https://images2.imgbox.com/6e/9a/EMJLzinU_o.png" alt="image-20211205170051841"></p> 
<ol><li>首先执行的是SynchronousQueue.offer（Runnable task）如果有空闲线程，线程立刻执行SynchronousQueue.poll（keepAliveTime，TimeUnit.NANOSECONDS）。</li><li>如果maximumPool为空，说明没有空闲线程，那么就会创建一个新的线程执行任务</li><li>创建线程成功之后，线程开始执行SynchronousQueue.poll（keepAliveTime，TimeUnit.NANOSECONDS），也就是要在60s之内空闲线程要接收任务并且执行。如果60s之后，那么空闲线程就会结束。</li></ol> 
<p><img src="https://images2.imgbox.com/39/21/fNC1uKBc_o.png" alt="image-20211205170424543"></p> 
<h3><a id="103_ScheduledThreadPoolExecutor_1636"></a>10.3 ScheduledThreadPoolExecutor详解</h3> 
<ul><li>继承了ThreadPoolExecutor，定期任务和延迟任务。</li></ul> 
<h4><a id="1031_ScheduledThreadPoolExecutor_1640"></a>10.3.1 ScheduledThreadPoolExecutor的运行机制</h4> 
<ul><li>ScheduledThreadPoolExecutor使用的是DelayQueue无界队列，所以maximumPoolSize没有意义。</li><li>scheduleAtFixedRate()和scheduleAtFixedDelay（）会向DelayQueue添加一个实现了RunnableScheduledFutur的接口。</li><li>然后就是线程获取任务和执行。</li></ul> 
<p><img src="https://images2.imgbox.com/51/85/yPEJljiz_o.png" alt="image-20211205170818695"></p> 
<h4><a id="1032_ScheduledThreadPoolExecutor_1652"></a>10.3.2 ScheduledThreadPoolExecutor的实现</h4> 
<p>ScheduledFutureTask任务包含三个成员变量</p> 
<ul><li>·long型成员变量time，这个任务执行的具体时间</li><li>long型成员变量sequenceNumber，表示这个任务被添加到ScheduledThreadPoolExecutor的序号。</li><li>long型成员变量period表示任务执行的间隔周期。</li><li>DelayQueue封装了一个PriorityQueue队列。能够对里面的任务进行排序。time小的放到前面。然后对比序号。</li></ul> 
<blockquote> 
 <p>执行任务的四个步骤</p> 
</blockquote> 
<ol><li>线程从队列获取到期的任务</li><li>线程执行任务</li><li>线程修改任务的time变量为下次的执行时间。</li><li>重新把任务放回去。</li></ol> 
<p><img src="https://images2.imgbox.com/bc/42/K3pu3PKB_o.png" alt="image-20211205171207978"></p> 
<ul><li>这个就是take任务的代码 
  <ul><li>获取Lock</li><li>获取周期任务 
    <ul><li>如果PriorityQueue是空的，那么进入到Condition等待</li><li>如果PriorityQueue的time时间比当前时间大，那么就到Condition等待time时间。</li><li>获取PriorityQueue的头元素。如果不是空，那么唤醒Condition的等待线程。</li></ul> </li><li>释放Lock。</li></ul> </li></ul> 
<pre><code class="prism language-java">    <span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">final</span> <span class="token class-name">ReentrantLock</span> lock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">;</span>
        lock<span class="token punctuation">.</span><span class="token function">lockInterruptibly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1</span>
        <span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token class-name">E</span> first <span class="token operator">=</span> q<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>first <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                    available<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2.1</span>
                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
                    <span class="token keyword">long</span> delay <span class="token operator">=</span> first<span class="token punctuation">.</span><span class="token function">getDelay</span><span class="token punctuation">(</span><span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>NANOSECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>delay <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                        <span class="token keyword">long</span> tl <span class="token operator">=</span> available<span class="token punctuation">.</span><span class="token function">awaitNanos</span><span class="token punctuation">(</span>delay<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2.2</span>
                    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
                        <span class="token class-name">E</span> x <span class="token operator">=</span> q<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2.3.1</span>
                        <span class="token keyword">assert</span> x <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
                        <span class="token keyword">if</span> <span class="token punctuation">(</span>q<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>
                            available<span class="token punctuation">.</span><span class="token function">signalAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2.3.2</span>
                        <span class="token keyword">return</span> x<span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{<!-- --></span>
            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 3</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/a3/7a/RI14VFIc_o.png" alt="image-20211205171530584"></p> 
<h3><a id="104_FutureTask_1712"></a>10.4 FutureTask详解</h3> 
<h4><a id="1041_FutureTask_1714"></a>10.4.1 FutureTask简介</h4> 
<ul><li>实现了Future还实现了Runnable接口。可以交给线程池执行。</li><li>三种状态 
  <ul><li>未启动</li><li>已经启动</li><li>已经完成。</li></ul> </li></ul> 
<p><img src="https://images2.imgbox.com/b7/d9/0WgMiC4v_o.png" alt="image-20211205171916527"></p> 
<ul><li>当FutureTask是未启动或者是已经启动的时候，那么就会调用get方法导致调用线程的阻塞。</li><li>如果处于已完成，那么就会返回结果或者抛出异常。</li><li>如果FutureTask处于未启动状态的时候，可以调用cancel导致任务不会被执行。</li><li>如果是启动的时候调用cancel（true），那么就会试图中断执行这个任务。</li><li>如果是启动的时候调用cancel(false)，那么不会对正在执行的任务线程产生影响。</li><li>如果是已经完成的任务，那么就会返回false。</li></ul> 
<p><img src="https://images2.imgbox.com/e1/57/SHGRyBA9_o.png" alt="image-20211205174329434"></p> 
<h4><a id="1042_FutureTask_1737"></a>10.4.2 FutureTask的使用</h4> 
<ul><li>循环创建和执行任务。</li><li>线程会去到taskCache里面获取任务</li><li>如果发现没有，那么就创建任务，并且存入taskCache里面。</li><li>然后获取并执行任务。</li></ul> 
<pre><code class="prism language-java"><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">ConcurrentMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">,</span> <span class="token class-name">Future</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> taskCache <span class="token operator">=</span>
            <span class="token keyword">new</span> <span class="token class-name">ConcurrentHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">,</span> <span class="token class-name">Future</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> <span class="token function">executionTask</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token class-name">String</span> taskName<span class="token punctuation">)</span>
            <span class="token keyword">throws</span> <span class="token class-name">ExecutionException</span><span class="token punctuation">,</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token class-name">Future</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> future <span class="token operator">=</span> taskCache<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>taskName<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1.1,2.1</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>future <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token class-name">Callable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> task <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Callable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{<!-- --></span>
                        <span class="token keyword">return</span> taskName<span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// 1.2创建任务</span>
                <span class="token class-name">FutureTask</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> futureTask <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FutureTask</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>
                future <span class="token operator">=</span> taskCache<span class="token punctuation">.</span><span class="token function">putIfAbsent</span><span class="token punctuation">(</span>taskName<span class="token punctuation">,</span> futureTask<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1.3</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>future <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                    future <span class="token operator">=</span> futureTask<span class="token punctuation">;</span>
                    futureTask<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1.4执行任务</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
                <span class="token keyword">return</span> future<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1.5,2.2线程在此等待任务执行完成</span>
            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">CancellationException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                taskCache<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>taskName<span class="token punctuation">,</span> future<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/e8/53/OcNxiAjN_o.png" alt="image-20211205174607104"></p> 
<h4><a id="1043_FutureTask_1777"></a>10.4.3 FutureTask的实现</h4> 
<ul><li>FutureTask基于AQS</li></ul> 
<p><img src="https://images2.imgbox.com/b5/9c/DWoUuEKi_o.png" alt="image-20211205175027557"></p> 
<ul><li> <p>FutureTask的get调用AQS.acquireSharedInterruptibly（int arg）</p> 
  <ul><li>调用AQS.acquireSharedInterruptibly（int arg）也就是去争抢锁。获取成功的条件是state=RAN或者是CANCELLED</li><li>如果get成功立刻返回。否则就要等待其它线程释放release。</li><li>其它线程release。唤醒当前线程，再次去获取锁</li><li>最后返回计算结果。</li></ul> </li><li> <p>run过程</p> 
  <ul><li>执行构造函数的任务</li><li>原子方式更新同步状态。AQS.compareAndSetState（int expect，int update）设置为state=RAN如果设置成功，代表计算结果的值是Callable.call()的返回值。然后释放锁AQS.releaseShared（int arg），其实就是修改同步状态。</li><li>AQS.releaseShared（int arg）之后会调用tryReleaseShared（arg）来release。然后唤醒第一个线程。</li><li>调用FutureTask.done()。执行FutureTask.get()的时候如果task不是出于已经完成RAN或者是CANCELLED。那么线程就只能去到AQS的同步队列等待。如果某个线程执行run或者cancel，那么就会唤醒下一个线程。</li></ul> <p><img src="https://images2.imgbox.com/09/5a/k3tfbnss_o.png" alt="image-20211205180030827"></p> </li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/50aa96247b1f457e08aac0beb5062742/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">解决IDEA控制台输出中文乱码问题</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a8d77b1566a05ef4788e5e7804f909c1/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">2021黑盾杯CTF部分WP</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>