<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>node.js基础学习 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="node.js基础学习" />
<meta property="og:description" content="node.js简介 Node.js能够让javascript在服务端运行
1、node的特性 异步I/O
说到异步I/O，就不得不说一下I/O，他们分别是input和output的缩写，也就是输入、输出。它是人类用来和计算机进行通信的外部硬件。输入/输出设备能够向计算机发送数据（输出）并从计算机接收数据（输入）。
I/O分为同步和异步，其中同步又有阻塞和非阻塞之分。异步没有，异步一定是非阻塞的。
同步过程中进程,触发IO操作并等待(也就是我们说的阻塞)或者轮询的去查看IO操作(也就是我们说的非阻塞)是否完成。
异步过程中进程触发IO操作以后，直接返回，做自己的事情，IO交给内核来处理，完成后内核通知进程IO完成。
事件驱动
单线程
跨平台
2、node的应用场景 I/O密集型是否擅长CPU密集型？分布式应用 3、node和浏览器 除了HTML、WebKit还有显卡这些UI技术node没有支持以外，node和谷歌浏览器非常相似，他们都是基于事件驱动的异步架构，浏览器通过事件驱动来服务页面上的交互，node通过事件驱动来服务I/O。
node不处理UI，但是node和浏览器有相同的机制和运行原理。node打破了JS只能在浏览器运行的局面，使前后端编程环境统一，可以大大降低前后端转化所需要的交换代价
模块化 commonJS 1、模块规范 在node中一个模块就是一个文件，每一个模块都有自己的作用域
对模块的定义非常简单，分为模块引用、模块标识、模块定义。
模块引用：通过require方法，接受模块标识为参数，进行引入
模块标识：必须是小驼峰命名的字符串，或者是文件相对或者绝对路径。
模块定义：也就是导出，提供了exports对象用于导出当前模块的方法或者是变量（或者是module.exports）
使用案例：
// export.js const testVar = 1; function test() { console.log(this.testVar) }; module.exports.testVar = testVar; module.exports.fn = test; // requare.js const val = require(&#39;./export&#39;); console.log(val.testVar); // 1 val.fn(); // 2 2、模块实现 在node中，模块可以被分为两类：
一类是node提供的内置模块，称为核心模块。在源代码的编译过程中，编译进了二进制执行文件，在node启动的时候，部分的内置模块就会被直接加载进内存中，所以当我们引入这些模块的时候，文件定位和编译执行就可以直接省略掉，并且在路径分析中会优先判断，核心模块的加载速度是最快的。另一类是用户编写的模块（第三方库也是文件模块），称为文件模块，文件模块在运行的时候动态加载的，需要完整的路径分析，文件定位和编译执行过程，速度会比核心模块的速度慢。 在node引入模块，需要经历三个步骤，
路径分析文件定位编译执行。 2.1、优先缓存加载 与前段浏览器会缓存静态资源脚步一样，node也会对引入的模块进行缓存，以减少二次引入时的开销。但不同的是，浏览器仅仅缓存文件，node缓存的是编译和执行之后的对象。
不论是任何模块，require对于相同模块的二次引入都是采用缓存优先的方式。
2.2、路径分析 标识符有以下几种形式，所以对于不同的标识符，模块查找和定位在一定程度上也有不同。
核心模块，也就是node内置模块，直接通过内置模块名引入.或者…开始的相对路径文件模块/开头的绝对路径的文件模块非路径形式的文件模块，比如自定义三方库名等，直接通过第三方库名引入，但注意不要和内置模块重名。 核心模块
对于核心模块，直接通过内置模块名引入，其加载速度是最快的，但注意，要加载一个和核心模块相同标识符的自定义模块，是无法成功的，因为会优先查找核心模块。
路径形式的文件模块
在分析文件模块的时候，require会将路径转化为真实路径，并以真实路径作为索引，将编译执行后的结果放入缓存中，以便于二次加载。其加载速度仅次于核心模块。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/cfed8dcc3e81459fecd4a5f81b58a887/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-07-07T00:14:51+08:00" />
<meta property="article:modified_time" content="2022-07-07T00:14:51+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">node.js基础学习</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="nodejs_0"></a>node.js简介</h2> 
<p>Node.js能够让javascript在服务端运行</p> 
<h5><a id="1node_4"></a>1、node的特性</h5> 
<ul><li> <p>异步I/O</p> 
  <blockquote> 
   <p>说到异步I/O，就不得不说一下I/O，他们分别是input和output的缩写，也就是输入、输出。它是人类用来和计算机进行通信的外部硬件。输入/输出设备能够向计算机<code>发送数据（输出）</code>并从计算机<code>接收数据（输入）</code>。</p> 
   <p>I/O分为同步和异步，其中同步又有阻塞和非阻塞之分。异步没有，异步一定是非阻塞的。</p> 
   <p>同步过程中进程,触发IO操作并等待(也就是我们说的阻塞)或者轮询的去查看IO操作(也就是我们说的非阻塞)是否完成。</p> 
   <p>异步过程中进程触发IO操作以后，直接返回，做自己的事情，IO交给内核来处理，完成后内核通知进程IO完成。</p> 
  </blockquote> </li><li> <p>事件驱动</p> </li><li> <p>单线程</p> </li><li> <p>跨平台</p> </li></ul> 
<h5><a id="2node_21"></a>2、node的应用场景</h5> 
<ul><li>I/O密集型</li><li>是否擅长CPU密集型？</li><li>分布式应用</li></ul> 
<h5><a id="3node_27"></a>3、node和浏览器</h5> 
<p>除了HTML、WebKit还有显卡这些UI技术node没有支持以外，node和谷歌浏览器非常相似，他们都是基于事件驱动的异步架构，浏览器通过事件驱动来服务页面上的交互，node通过事件驱动来服务I/O。</p> 
<p>node不处理UI，但是node和浏览器有相同的机制和运行原理。node打破了JS只能在浏览器运行的局面，使前后端编程环境统一，可以大大降低前后端转化所需要的交换代价</p> 
<h2><a id="_commonJS_33"></a>模块化 commonJS</h2> 
<h5><a id="1_35"></a>1、模块规范</h5> 
<blockquote> 
 <p>在node中一个模块就是一个文件，每一个模块都有自己的作用域</p> 
 <p>对模块的定义非常简单，分为模块引用、模块标识、模块定义。</p> 
 <p>模块引用：通过<strong>require</strong>方法，接受<strong>模块标识</strong>为参数，进行引入</p> 
 <p>模块标识：必须是小驼峰命名的字符串，或者是文件相对或者绝对路径。</p> 
 <p>模块定义：也就是导出，提供了exports对象用于导出当前模块的方法或者是变量（或者是module.exports）</p> 
</blockquote> 
<p>使用案例：</p> 
<pre><code class="prism language-js"><span class="token comment">// export.js</span>
<span class="token keyword">const</span> testVar <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>testVar<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
module<span class="token punctuation">.</span>exports<span class="token punctuation">.</span>testVar <span class="token operator">=</span> testVar<span class="token punctuation">;</span>
module<span class="token punctuation">.</span>exports<span class="token punctuation">.</span>fn <span class="token operator">=</span> test<span class="token punctuation">;</span>

<span class="token comment">// requare.js</span>
<span class="token keyword">const</span> val <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./export'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>val<span class="token punctuation">.</span>testVar<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1</span>
val<span class="token punctuation">.</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2</span>
</code></pre> 
<h5><a id="2_64"></a>2、模块实现</h5> 
<blockquote> 
 <p>在node中，模块可以被分为两类：</p> 
 <ul><li>一类是node提供的内置模块，称为核心模块。在源代码的编译过程中，编译进了二进制执行文件，在node启动的时候，部分的内置模块就会被直接加载进内存中，所以当我们引入这些模块的时候，文件定位和编译执行就可以直接省略掉，并且在路径分析中会优先判断，核心模块的加载速度是最快的。</li><li>另一类是用户编写的模块（第三方库也是文件模块），称为文件模块，文件模块在运行的时候动态加载的，需要完整的路径分析，文件定位和编译执行过程，速度会比核心模块的速度慢。</li></ul> 
</blockquote> 
<p>在node引入模块，需要经历三个步骤，</p> 
<ul><li>路径分析</li><li>文件定位</li><li>编译执行。</li></ul> 
<h6><a id="21_77"></a>2.1、优先缓存加载</h6> 
<p>与前段浏览器会缓存静态资源脚步一样，<strong>node也会对引入的模块进行缓存，以减少二次引入时的开销</strong>。但不同的是，浏览器仅仅缓存文件，<strong>node缓存的是编译和执行之后的对象</strong>。</p> 
<p>不论是任何模块，require对于相同模块的二次引入都是采用缓存优先的方式。</p> 
<h6><a id="22_83"></a>2.2、路径分析</h6> 
<blockquote> 
 <p>标识符有以下几种形式，所以对于不同的标识符，模块查找和定位在一定程度上也有不同。</p> 
 <ul><li>核心模块，也就是node内置模块，直接通过内置模块名引入</li><li>.或者…开始的相对路径文件模块</li><li>/开头的绝对路径的文件模块</li><li>非路径形式的文件模块，比如自定义三方库名等，直接通过第三方库名引入，但注意不要和内置模块重名。</li></ul> 
</blockquote> 
<p><strong>核心模块</strong></p> 
<p>对于核心模块，直接通过内置模块名引入，其加载速度是最快的，但注意，要加载一个和核心模块相同标识符的自定义模块，是无法成功的，因为会优先查找核心模块。</p> 
<p><strong>路径形式的文件模块</strong></p> 
<p>在分析文件模块的时候，require会将路径转化为真实路径，并以真实路径作为索引，将编译执行后的结果放入缓存中，以便于二次加载。其加载速度仅次于核心模块。</p> 
<p><strong>自定义模块</strong></p> 
<p>自定义模块指的是非核心模块，也不是路径形式的标识符，是一种特殊的文件模块，可能是一个文件或者是包的形式，这类模块查找是最费时间的，会去逐级查找node_modules目录是否有，由内至外，从当前级开始。所以当前文件的路径越深，模块查找的耗时就越长。其加载速度最慢。</p> 
<h6><a id="23_104"></a>2.3、文件定位</h6> 
<p>文件定位其实我理解就是查找文件，确定文件位置。这个过程中会包括对文件扩展名的分析、目录和包的处理</p> 
<blockquote> 
 <ul><li> <p>文件扩展名分析</p> <p>require引入标识符的过程中，会出现标识符不包含文件扩展名的情况，此时node会按照.js、.json、.node的次序补足扩展名，依次尝试。</p> <p>但是在尝试的时候，需要调用同步阻塞式地判断文件是否存在。因为node是单线程的，所以这里会存在性能问题，如果是.json、.node的文件，在写入的时候带上扩展名，会加快一点寻找速度</p> </li><li> <p>目录分析和包</p> <p>有的时候require分析标识符的死活，可能没有找到对应的文件，但是这个时候得到了一个对应的目录，此时node会将其当作一个包来进行处理。</p> <p>首先，node会在当前目录下查找package.json文件，通过JSON.parse()解析出包的描述对象。从中取出main属性对应的入口文件进行定位。如果main属性指定的文件名错误，或者压根没有package.json文件，node会默认将index当作默认文件名，然后依次查找index.js,index.json,index.node.</p> </li></ul> 
</blockquote> 
<h6><a id="24_120"></a>2.4、编译执行</h6> 
<p>在node中，每一个文件模块都是一个对象，它的定义如下：</p> 
<pre><code class="prism language-js">创建一个新模块
<span class="token keyword">function</span> <span class="token function">Module</span><span class="token punctuation">(</span><span class="token parameter">id<span class="token punctuation">,</span>parent</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>id <span class="token operator">=</span> id<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>parent <span class="token operator">=</span> parent<span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>parent <span class="token operator">&amp;&amp;</span> parent<span class="token punctuation">.</span>children<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    parent<span class="token punctuation">.</span>children<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>fillname <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>loaded <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>children <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>在node中，不同的文件扩展名有不同的编译方式</p> 
<blockquote> 
 <ul><li>.js文件：通过fs同步读取文件后编译执行</li><li>.node文件：这是用C/C++编写的扩展文件，通过dlopen()方法加载最后编译生产的文件</li><li>.json文件：通过fs模块同步读取文件后，用JSON.parse()解析返回的结果</li><li>其余扩展名：都被当作js文件载入</li></ul> 
</blockquote> 
<p><strong>对JS模块的编译</strong></p> 
<p>在模块的使用过程中，我们发现每个模块文件都有require、exports、module这三个方法，但是他们在模块中并没有定义，这是因为node对获取到的js文件会进行头尾包装</p> 
<pre><code class="prism language-js"><span class="token comment">// module表示模块自身</span>
<span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">exports<span class="token punctuation">,</span> require<span class="token punctuation">,</span> module<span class="token punctuation">,</span> __filename<span class="token punctuation">,</span> __dirname</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  文件内容<span class="token operator">...</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> 
<p>这样使得每个模块时间作用域都隔离开。</p> 
<p>但这里有一个问题就是，为何exports都已经存在了，还存在module.exports，其实由于module代表的是模块本身，module.exports其实就是exports，但是这里需要注意的是，exports其实是形参传入该模块的，直接复制形参会改变形参的引用，但不能改变作用域外的值，所以不能这样写</p> 
<pre><code class="prism language-js">错误写法
<span class="token function-variable function">exports</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>

<span class="token punctuation">}</span>
正确
module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
</code></pre> 
<p><strong>node编译（C/C++编译）</strong></p> 
<p>node调用process.dlopen()方法进行加载和执行。</p> 
<p><strong>JSON文件编译</strong></p> 
<p>node利用fs同步读取json文件的内容，通过JSON.parse()得到对象，然后把他赋给模块的exports,对外调用</p> 
<p><strong>案例</strong></p> 
<p>如果有两个模块，重复引用</p> 
<pre><code class="prism language-js"><span class="token comment">// main.js</span>
<span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./moduleA'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./moduleB'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 执行输出结果 </span>
<span class="token constant">B</span> <span class="token constant">A</span>
<span class="token constant">A</span> <span class="token constant">BB</span>

<span class="token comment">// moduleA.js</span>
module<span class="token punctuation">.</span>exports<span class="token punctuation">.</span>test <span class="token operator">=</span> <span class="token string">'A'</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> moduleB <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./moduleB'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 引用的时候会执行moduleB</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'A'</span><span class="token punctuation">,</span> moduleB<span class="token punctuation">.</span>test<span class="token punctuation">)</span><span class="token punctuation">;</span>
module<span class="token punctuation">.</span>exports<span class="token punctuation">.</span>test <span class="token operator">=</span> <span class="token string">'AA'</span><span class="token punctuation">;</span>

<span class="token comment">// moduleB.js</span>
module<span class="token punctuation">.</span>exports<span class="token punctuation">.</span>test <span class="token operator">=</span> <span class="token string">'B'</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> moduleA <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./moduleA'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'B'</span><span class="token punctuation">,</span> moduleA<span class="token punctuation">.</span>test<span class="token punctuation">)</span><span class="token punctuation">;</span>
module<span class="token punctuation">.</span>exports<span class="token punctuation">.</span>test <span class="token operator">=</span> <span class="token string">'BB'</span><span class="token punctuation">;</span>
</code></pre> 
<p>不要路径引入，直接引入名字，比如系统内置模块fs</p> 
<pre><code class="prism language-js"><span class="token keyword">const</span> fs <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'fs'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
fs<span class="token punctuation">.</span><span class="token function">readFile</span><span class="token punctuation">(</span><span class="token string">'./moduleA.js'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">err<span class="token punctuation">,</span> data</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> 
<h3><a id="module__216"></a>module 模块</h3> 
<blockquote> 
 <p>Node.js 实现了一个简单的模块加载系统。在 Node.js 中，文件和模块是一一对应的关系，可以理解为一个文件就是一个模块。其模块系统的实现主要依赖于全局对象 module，其中实现了 exports(导出)、require()(加载)等机制。</p> 
</blockquote> 
<h5><a id="1__220"></a>1、 模块加载</h5> 
<p>Node.js 中一个文件就是一个模块。如，在 index.js 中加载同目录下的 circle.js：</p> 
<pre><code>// circle.js
const PI = Math.PI

exports.area = r =&gt; PI * r * r

exports.circumference = r =&gt; 2 * PI * r
// index.js
const circle = require('./circle.js')

console.log(`半径为 4 的圆面积为 ${circle.area(4)}`) // 半径为 4 的圆面积为 50.26548245743669
</code></pre> 
<p>circle.js 中通过 exports 导出了 area()和 circumference 两个方法，这两个方法可以其它模块中调用。</p> 
<p><strong>exports 与 module.exports</strong></p> 
<p>exports 是对 module.exports 的一个简单引用。如果你需要将模块导出为一个函数(如：构造函数)，或者想导出一个完整的出口对象而不是做为属性导出，这时应该使用 module.exports。</p> 
<pre><code>// square.js

module.exports = width =&gt; {
  return {
    area: () =&gt; width * width
  }
}
// index.js

const square = require('./square.js')
const mySquare = square(2)
console.log(`The area of my square is ${mySquare.area()}`) // The area of my square is 4
</code></pre> 
<h5><a id="2__258"></a>2、 访问主模块</h5> 
<p>当 Node.js 直接运行一个文件时，require.main 属性会被设置为 module 本身。这样，就可通过这个属性判断模块是否被直接运行：</p> 
<pre><code>require.main === module
</code></pre> 
<p>比如,对于上面例子的 index.js 来说, node index.js 上面值就是 true, 而通过 require(‘./index’)时, 值却是 false.</p> 
<p>module 提供了一个 filename 属性，其值通常等于__filename。 所以，当前程序的入口点可以通过 require.main.filename 来获取。</p> 
<pre><code>console.log(require.main.filename === __filename) // true
</code></pre> 
<h5><a id="3__274"></a>3、 解析模块路径</h5> 
<p>使用 require.resolve()函数,可以获取 require 加载的模块的确切文件名,此操作只返回解析后的文件名，不会加载该模块。</p> 
<pre><code>console.log(require.resolve('./square.js')) // /Users/null/meet-nodejs/module/square.js
</code></pre> 
<p>require.resolve 的工作过程：</p> 
<pre><code>require(X) from module at path Y
1. If X is a core module,
   a. return the core module
   b. STOP
2. If X begins with './' or '/' or '../'
   a. LOAD_AS_FILE(Y + X)
   b. LOAD_AS_DIRECTORY(Y + X)
3. LOAD_NODE_MODULES(X, dirname(Y))
4. THROW "not found"

LOAD_AS_FILE(X)
1. If X is a file, load X as JavaScript text.  STOP
2. If X.js is a file, load X.js as JavaScript text.  STOP
3. If X.json is a file, parse X.json to a JavaScript Object.  STOP
4. If X.node is a file, load X.node as binary addon.  STOP

LOAD_AS_DIRECTORY(X)
1. If X/package.json is a file,
   a. Parse X/package.json, and look for "main" field.
   b. let M = X + (json main field)
   c. LOAD_AS_FILE(M)
2. If X/index.js is a file, load X/index.js as JavaScript text.  STOP
3. If X/index.json is a file, parse X/index.json to a JavaScript object. STOP
4. If X/index.node is a file, load X/index.node as binary addon.  STOP

LOAD_NODE_MODULES(X, START)
1. let DIRS=NODE_MODULES_PATHS(START)
2. for each DIR in DIRS:
   a. LOAD_AS_FILE(DIR/X)
   b. LOAD_AS_DIRECTORY(DIR/X)

NODE_MODULES_PATHS(START)
1. let PARTS = path split(START)
2. let I = count of PARTS - 1
3. let DIRS = []
4. while I &gt;= 0,
   a. if PARTS[I] = "node_modules" CONTINUE
   c. DIR = path join(PARTS[0 .. I] + "node_modules")
   b. DIRS = DIRS + DIR
   c. let I = I - 1
5. return DIRS
</code></pre> 
<h5><a id="4_328"></a>4、模块缓存</h5> 
<p>模块在第一次加载后会被缓存到 require.cache 对象中, 从此对象中删除键值对将会导致下一次 require 重新加载被删除的模块。</p> 
<p>多次调用 require(‘index’)，未必会导致模块中代码的多次执行。这是一个重要的功能，借助这一功能，可以返回部分完成的对象；这样，传递依赖也能被加载，即使它们可能导致循环依赖。</p> 
<p>如果你希望一个模块多次执行，那么就应该输出一个函数，然后调用这个函数。</p> 
<p><strong>模块缓存的注意事项</strong></p> 
<p>模块的基于其解析后的文件名进行缓存。由于调用的位置不同，可能会解析到不同的文件(如，需要从 node_modules 文件夹加载的情况)。所以，当解析到其它文件时，就不能保证 require(‘index’)总是会返回确切的同一对象。</p> 
<p>另外，在不区分大小写的文件系统或系统中，不同的文件名可能解析到相同的文件，但缓存仍会将它们视为不同的模块，会多次加载文件。如：require(‘./index’)和 require(‘./INDEX’)会返回两个不同的对象，无论’./index’和’./INDEX’是否是同一个文件。</p> 
<h5><a id="5_342"></a>5、循环依赖</h5> 
<p>当 require()存在循环调用时，模块在返回时可能并不会被执行。</p> 
<pre><code>// a.js
console.log('a starting')
exports.done = false
const b = require('./b.js')
console.log('in a, b.done = %j', b.done)
exports.done = true
console.log('a done')
// b.js
console.log('b starting')
exports.done = false
const a = require('./a.js')
console.log('in b, a.done = %j', a.done)
exports.done = true
console.log('b done')
// main.js
console.log('main starting')
const a = require('./a.js')
const b = require('./b.js')
console.log('in main, a.done=%j, b.done=%j', a.done, b.done)
</code></pre> 
<p>首先 main.js 会加载 a.js，接着 a.js 又会加载 b.js。这时，b.js 又会尝试去加载 a.js。</p> 
<p>为了防止无限的循环，a.js 会返回一个 unfinished copy 给 b.js。然后 b.js 就会停止加载，并将其 exports 对象返回给 a.js 模块。</p> 
<p>这样 main.js 就完成了 a.js、b.js 两个文件的加载。输出如下:</p> 
<pre><code>$ node main.js
main starting
a starting
b starting
in b, a.done = false
b done
in a, b.done = true
a done
in main, a.done=true, b.done=true
</code></pre> 
<h5><a id="6__386"></a>6、 文件模块</h5> 
<p>当加载文件模块时，如果按文件名查找未找到。那么 Node.js 会尝试添加.js 和.json 的扩展名，并再次尝试查找。如果仍未找到，那么会添加.node 扩展名再次尝试查找。</p> 
<p>对于.js 文件，会将其解析为 JavaScript 文本文件；而.json 会解析为 JOSN 文件文件；.node 会尝试解析为编译后的插件文件，并由 dlopen 进行加载。</p> 
<p><strong>路径解析</strong></p> 
<p>当加载的文件模块使用’/‘前缀时，则表示绝对路径。如，require(’/home/null/index.js’)会加载/home/null/index.js 文件。</p> 
<p>而使用’./‘前缀时，表示相对路径。如，在 index.js 中 require(’./circle’)引用时，circle.js 必须在相同的目录下才能加载成功。</p> 
<p>当没有’/‘或’./'前缀时，所引用的模块必须是“核心模块”或是 node_modules 中的模块。</p> 
<p>如果所加载的模块不存在，require()会抛出一个 code 属性为’MODULE_NOT_FOUND’的错误。</p> 
<h5><a id="7___dirname_402"></a>7、 __dirname</h5> 
<p>当前模块的目录名。 与 __filename 的 path.dirname() 相同。</p> 
<pre><code>console.log(__dirname) // /Users/null/meet-nodejs/module

console.log(require('path').dirname(__filename)) // /Users/null/meet-nodejs/module

console.log(__dirname === require('path').dirname(__filename)) // true
</code></pre> 
<h5><a id="8_module__414"></a>8、 module 对象</h5> 
<p>module 在每个模块中表示对当前模块的引用。 而 module.exports 又可以通过全局对象 exports 来引用。module 并不是一个全局对象，而更像一个模块内部对象。</p> 
<p><strong>module.children</strong></p> 
<p>这个模块引入的所有模块对象</p> 
<p><strong>module.exports</strong></p> 
<p>module.exports 通过模块系统创建。有时它的工作方式与我们所想的并不一致，有时我们希望模块是一些类的实例。因此，要将导出对象赋值给 module.exports，但是导出所需的对象将分配绑定本地导出变量，这可能不是我们想要的结果。</p> 
<pre><code>// a.js

const EventEmitter = require('events')

module.exports = new EventEmitter()

// Do some work, and after some time emit
// the 'ready' event from the module itself.
setTimeout(() =&gt; {
  module.exports.emit('ready')
}, 1000)
const a = require('./a')
a.on('ready', () =&gt; {
  console.log('module a is ready')
})
</code></pre> 
<p>需要注意，分配给 module.exports 的导出值必须能立刻获取到，当使用回调时其不能正常执行。</p> 
<p><strong>exports 别名</strong></p> 
<p>exports 可以做为 module.exports 的一个引用。和任何变量一样，如果为它分配新值，其旧值将会失效：</p> 
<pre><code>function require(...) {
  // ...
  ((module, exports) =&gt; {
    // Your module code here
    exports = some_func;        // re-assigns exports, exports is no longer
                                // a shortcut, and nothing is exported.
    module.exports = some_func; // makes your module export 0
  })(module, module.exports);
  return module;
}
</code></pre> 
<ul><li>module.filename - 模块解析后的完整文件名</li><li>module.id - 用于区别模块的标识符，通常是完全解析后的文件名。</li><li>module.loaded - 模块是否加载完毕</li><li>module.parent - 父模块，即：引入这个模块的模块</li><li>module.require(id)</li><li>module.require 提供了类似 require()的功能，可以从最初的模块加载一个模块</li></ul> 
<h2><a id="IO_476"></a>异步I/O</h2> 
<h2><a id="_480"></a>异步编程</h2> 
<h2><a id="_484"></a>事件循环</h2> 
<h2><a id="_new_EventEmitter_488"></a>事件模块 new EventEmitter()</h2> 
<blockquote> 
 <p>所有触发的事件的对象都是EventEmitter的实例，这些对象都暴露了EventEmitter.on()函数，允许一个或者多个函数绑定到对象触发的命名事件。<br> EventEmitter 对象触发事件时，所有绑定到该特定事件的函数都会被同步的调用<br> js中的事件是通过用户点击等操作触发的，node中EventEmitter 则是通过emit去触发的。\</p> 
</blockquote> 
<pre><code class="prism language-js"><span class="token keyword">const</span> EventEmitter <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'events'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 引入事件</span>
<span class="token keyword">class</span> <span class="token class-name">MyEmitter</span> <span class="token keyword">extends</span> <span class="token class-name">EventEmitter</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span> <span class="token comment">// 继承事件触发器</span>
<span class="token keyword">const</span> myEmitter <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyEmitter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 创建实例对象</span>
myEmitter<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'event'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
 console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'creat Event'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span><span class="token punctuation">)</span>
myEmitter<span class="token punctuation">.</span><span class="token function">emit</span><span class="token punctuation">(</span><span class="token string">'event'</span><span class="token punctuation">)</span> <span class="token comment">// 触发事件</span>
</code></pre> 
<h5><a id="1this_506"></a>1、将参数和this传给监听器</h5> 
<pre><code class="prism language-js">myEmitter<span class="token punctuation">.</span><span class="token function">emit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>第二个甚至之后的参数 可以将任意一组参数传递给监听器的回调函数，
当调用普通的函数时，<span class="token keyword">this</span>会被绑定到EventEmitter 实例上，但如果是箭头函数的话，<span class="token keyword">this</span>不会绑定在实例上
myEmitter<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'testThis'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
 console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token keyword">this</span> <span class="token operator">===</span> myEmitter<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
myEmitter<span class="token punctuation">.</span><span class="token function">emit</span><span class="token punctuation">(</span><span class="token string">'testThis'</span><span class="token punctuation">,</span> <span class="token string">'aaaa'</span><span class="token punctuation">,</span> <span class="token string">'bbbbb'</span><span class="token punctuation">)</span>
打印结果
aaaa bbbbb MyEmitter <span class="token punctuation">{<!-- --></span>
 <span class="token literal-property property">_events</span><span class="token operator">:</span> <span class="token punctuation">[</span>Object<span class="token operator">:</span> <span class="token keyword">null</span> prototype<span class="token punctuation">]</span> <span class="token punctuation">{<!-- --></span> <span class="token literal-property property">testThis</span><span class="token operator">:</span> <span class="token punctuation">[</span>Function<span class="token punctuation">]</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
 <span class="token literal-property property">_eventsCount</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
 <span class="token literal-property property">_maxListeners</span><span class="token operator">:</span> <span class="token keyword">undefined</span> <span class="token punctuation">}</span> <span class="token boolean">true</span>
箭头函数测试
myEmitter<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'testThis'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
 console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token keyword">this</span> <span class="token operator">===</span> myEmitter<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
myEmitter<span class="token punctuation">.</span><span class="token function">emit</span><span class="token punctuation">(</span><span class="token string">'testThis'</span><span class="token punctuation">,</span> <span class="token string">'aaaa'</span><span class="token punctuation">,</span> <span class="token string">'bbbbb'</span><span class="token punctuation">)</span> <span class="token comment">// aaaa bbbbb {} false</span>
</code></pre> 
<h5><a id="2_527"></a>2、同步或者是异步</h5> 
<pre><code class="prism language-js"><span class="token function">EventEmitter按照注册的顺序同步的执行所有监听器，这样可以确保事件的正确顺序，有助于避免竞争条件和逻辑错误，在适当的时候，监听函数可以使用setImmediate</span><span class="token punctuation">(</span><span class="token punctuation">)</span>或者是process<span class="token punctuation">.</span><span class="token function">nextTick</span><span class="token punctuation">(</span><span class="token punctuation">)</span>切换到异步的操作模式

sync同步的意思 
myEmitter<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'noSync'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
 <span class="token function">setImmediate</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
 console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'this is setImmediate'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span><span class="token punctuation">)</span>
 console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
myEmitter<span class="token punctuation">.</span><span class="token function">emit</span><span class="token punctuation">(</span><span class="token string">'noSync'</span><span class="token punctuation">,</span> <span class="token string">'aaaaa'</span><span class="token punctuation">,</span> <span class="token string">'bbbb'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'end'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
返回如下：
aaaaa bbbb
end
<span class="token keyword">this</span> is setImmediate
</code></pre> 
<h5><a id="3_once_547"></a>3、只调用一次 once()。一旦事件被触发，则监听器就会被注销然后被调用。</h5> 
<pre><code class="prism language-js">先测试一下案例
myEmitter<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'setInterval'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">num</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
 console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token keyword">let</span> num <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
 myEmitter<span class="token punctuation">.</span><span class="token function">emit</span><span class="token punctuation">(</span><span class="token string">'setInterval'</span><span class="token punctuation">,</span> num<span class="token punctuation">)</span><span class="token punctuation">;</span>
 num <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
返回如下：
<span class="token number">0</span>
<span class="token number">1</span>
<span class="token number">2</span>
<span class="token number">3</span>
<span class="token operator">...</span>
如果只用once调用的 <span class="token punctuation">,</span>只调用一次，调用完了之后被注销。
myEmitter<span class="token punctuation">.</span><span class="token function">once</span><span class="token punctuation">(</span><span class="token string">'setInterval'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">num</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
 console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token keyword">let</span> num <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
 myEmitter<span class="token punctuation">.</span><span class="token function">emit</span><span class="token punctuation">(</span><span class="token string">'setInterval'</span><span class="token punctuation">,</span> num<span class="token punctuation">)</span><span class="token punctuation">;</span>
 num <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
返回如下：
<span class="token number">0</span>
</code></pre> 
<h5><a id="4_580"></a>4、错误事件</h5> 
<pre><code class="prism language-js">当 EventEmitter 实例中发生错误时，典型的操作是触发 <span class="token string">'error'</span> 事件。 这些在 Node<span class="token punctuation">.</span>js 中被视为特殊情况。
如果 EventEmitter 没有为 <span class="token string">'error'</span> 事件注册至少一个监听器，并且触发 <span class="token string">'error'</span> 事件，则会抛出错误，打印堆栈跟踪，然后退出 Node<span class="token punctuation">.</span>js 进程。
myEmitter<span class="token punctuation">.</span><span class="token function">emit</span><span class="token punctuation">(</span><span class="token string">'error'</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'whoops'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 没有注册直接触发会导致抛出错误</span>
应该为error添加监听器
myEmitter<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'error'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">err</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
 console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'whoops! there was an error'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token comment">// err 参数通过emit中传入一个 new Error的类</span>
myEmitter<span class="token punctuation">.</span><span class="token function">emit</span><span class="token punctuation">(</span><span class="token string">'error'</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'whoops!'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h5><a id="5removeListeneroff__593"></a>5、removeListener()/off() 从事件中移除事件监听器</h5> 
<pre><code class="prism language-js"><span class="token keyword">const</span> <span class="token function-variable function">a</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
 console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> <span class="token function-variable function">b</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
 console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'b'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
myEmitter<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'testRemoveAllListeners'</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span>
myEmitter<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'testRemoveAllListeners'</span><span class="token punctuation">,</span> b<span class="token punctuation">)</span>

myEmitter<span class="token punctuation">.</span><span class="token function">emit</span><span class="token punctuation">(</span><span class="token string">'testRemoveAllListeners'</span><span class="token punctuation">)</span> <span class="token comment">// a b</span>

myEmitter<span class="token punctuation">.</span><span class="token function">removeListener</span><span class="token punctuation">(</span><span class="token string">'testRemoveAllListeners'</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>
myEmitter<span class="token punctuation">.</span><span class="token function">emit</span><span class="token punctuation">(</span><span class="token string">'testRemoveAllListeners'</span><span class="token punctuation">)</span><span class="token comment">// b 因为a被移除了</span>
</code></pre> 
<h5><a id="6_removeAllListeners_611"></a>6、 removeAllListeners()</h5> 
<pre><code class="prism language-js"><span class="token function">removeAllListeners</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 移除事件所有的监听器 给绑定的事件名的时候 移除这个事件下所有的监听器，不给参数的时候，移除所有的
<span class="token keyword">const</span> <span class="token function-variable function">a</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
 console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> <span class="token function-variable function">b</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
 console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'b'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
myEmitter<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'testRemoveAllListeners'</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span>
myEmitter<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'testRemoveAllListeners'</span><span class="token punctuation">,</span> b<span class="token punctuation">)</span>
myEmitter<span class="token punctuation">.</span><span class="token function">emit</span><span class="token punctuation">(</span><span class="token string">'testRemoveAllListeners'</span><span class="token punctuation">)</span> <span class="token comment">// a b</span>
myEmitter<span class="token punctuation">.</span><span class="token function">removeAllListeners</span><span class="token punctuation">(</span><span class="token string">'testRemoveAllListeners'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
myEmitter<span class="token punctuation">.</span><span class="token function">emit</span><span class="token punctuation">(</span><span class="token string">'testRemoveAllListeners'</span><span class="token punctuation">)</span><span class="token comment">// 不输出 因为都被移除了</span>
</code></pre> 
<h2><a id="_628"></a>进程</h2> 
<blockquote> 
 <p>process 对象是一个全局变量， 因为是全局变量，所以无需使用 require()</p> 
 <p>提供了有关当前 Node.js进程的信息并对其进行控制，作为一个全局变量,我们都知道，进程计算机系统进行资源分配和调度的基本单位，是操作系统结构的基础，是线程的容器。当我们启动一个js文件，实际就是开启了一个服务进程，每个进程都拥有自己的独立空间地址、数据栈，像另一个进程无法访问当前进程的变量、数据结构，只有数据通信后，进程之间才可以数据共享，由于JavaScript是一个单线程语言，所以通过node xxx启动一个文件后，只有一条主线程</p> 
</blockquote> 
<h6><a id="1processenv_634"></a>1、process.env环境变量</h6> 
<blockquote> 
 <p>返回一个对象，存储当前环境相关的所有信息，一般很少直接用到。</p> 
 <p>一般我们会在 process.env 上挂载一些变量标识当前的环境。比如最常见的用 process.env.NODE_ENV 区分 development 和 production</p> 
 <p>在 vue-cli 的源码中也经常会看到 process.env.VUE_CLI_DEBUG 标识当前是不是 DEBUG 模式</p> 
</blockquote> 
<h6><a id="2processnextTick_642"></a>2、process.nextTick</h6> 
<blockquote> 
 <p>我们知道NodeJs是基于事件轮询，在这个过程中，同一时间只会处理一件事情</p> 
 <p>在这种处理模式下，process.nextTick()就是定义出一个动作，并且让这个动作在下一个事件轮询的时间点上执行</p> 
</blockquote> 
<pre><code class="prism language-js"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">'foo'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

process<span class="token punctuation">.</span><span class="token function">nextTick</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">'bar'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 输出结果为bar、foo</span>

下述方式也能实现同样效果：
<span class="token function">setTimeout</span><span class="token punctuation">(</span>foo<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'bar'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 两者区别在于：</span>
process<span class="token punctuation">.</span><span class="token function">nextTick</span><span class="token punctuation">(</span><span class="token punctuation">)</span>会在这一次event loop的call stack清空后（下一次event loop开始前）再调用callback
<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">)</span>是并不知道什么时候call stack清空的，所以何时调用callback函数是不确定的
</code></pre> 
<h6><a id="3processpid_666"></a>3、process.pid：</h6> 
<blockquote> 
 <p>属性会返回当前进程的 PID。</p> 
</blockquote> 
<pre><code>console.log('process PID: %d', process.pid)
//process PID: 10086
</code></pre> 
<h6><a id="4processppid_675"></a>4、process.ppid</h6> 
<blockquote> 
 <p>当前进程对应的父进程</p> 
</blockquote> 
<h6><a id="5processcwd_679"></a>5、process.cwd()</h6> 
<blockquote> 
 <p>获取当前进程工作目录，</p> 
</blockquote> 
<h6><a id="6processexitcode_683"></a>6、终止当前进程：process.exit([code])</h6> 
<p>process.exit()方法终止当前进程，此方法可接收一个退出状态的可选参数 code，不传入时，会返回表示成功的状态码 0。</p> 
<pre><code>process.on('exit', function(code) {
  console.log('进程退出码是:%d', code) // 进程退出码是:886
})

process.exit(886)
</code></pre> 
<h6><a id="7processargv_695"></a>7、process.argv()</h6> 
<blockquote> 
 <p>在终端通过 Node 执行命令的时候，通过 process.argv 可以获取传入的命令行参数，返回值是一个数组：0、 Node 路径（一般用不到，直接忽略）<br> 1、被执行的 JS 文件路径（一般用不到，直接忽略）<br> 2~n、 真实传入命令的参数<br> 所以，我们只要从 process.argv[2] 开始获取就好了</p> 
</blockquote> 
<pre><code class="prism language-js"><span class="token keyword">const</span> args <span class="token operator">=</span> process<span class="token punctuation">.</span>argv<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h6><a id="8processplatform_706"></a>8、process.platform</h6> 
<blockquote> 
 <p>获取当前进程运行的操作系统平台</p> 
</blockquote> 
<h6><a id="9processuptime_710"></a>9、process.uptime()</h6> 
<blockquote> 
 <p>当前进程已运行时间，例如：pm2 守护进程的 uptime 值</p> 
</blockquote> 
<h6><a id="10_714"></a>10、进程事件</h6> 
<blockquote> 
 <p>process.on(‘uncaughtException’,cb) 捕获异常信息、 process.on(‘exit’,cb）进程推出监听</p> 
</blockquote> 
<h6><a id="11_718"></a>11、三个标准流</h6> 
<blockquote> 
 <p>process.stdout 标准输出、 process.stdin 标准输入、 process.stderr 标准错误输出</p> 
</blockquote> 
<h6><a id="12processtitle_722"></a>12、process.title</h6> 
<blockquote> 
 <p>指定进程名称，有的时候需要给进程指定一个名称</p> 
</blockquote> 
<h2><a id="fs__728"></a>fs 文件</h2> 
<p>http://nodejs.cn/learn/the-nodejs-fs-module</p> 
<blockquote> 
 <p>访问文件系统并与文件系统进行交互</p> 
 <p>无需安装。 作为 Node.js 核心的组成部分，通过引用来使用它：</p> 
 <p>const fs = require(‘fs’)</p> 
 <p>方法：</p> 
 <ul><li><code>fs.access()</code>: 检查文件是否存在，以及 Node.js 是否有权限访问。</li><li><code>fs.appendFile()</code>: 追加数据到文件。如果文件不存在，则创建文件。</li><li><code>fs.chmod()</code>: 更改文件（通过传入的文件名指定）的权限。相关方法：<code>fs.lchmod()</code>、<code>fs.fchmod()</code>。</li><li><code>fs.chown()</code>: 更改文件（通过传入的文件名指定）的所有者和群组。相关方法：<code>fs.fchown()</code>、<code>fs.lchown()</code>。</li><li><code>fs.close()</code>: 关闭文件描述符。</li><li><code>fs.copyFile()</code>: 拷贝文件。</li><li><code>fs.createReadStream()</code>: 创建可读的文件流。</li><li><code>fs.createWriteStream()</code>: 创建可写的文件流。</li><li><code>fs.link()</code>: 新建指向文件的硬链接。</li><li><code>fs.mkdir()</code>: 新建文件夹。</li><li><code>fs.mkdtemp()</code>: 创建临时目录。</li><li><code>fs.open()</code>: 设置文件模式。</li><li><code>fs.readdir()</code>: 读取目录的内容。</li><li><code>fs.readFile()</code>: 读取文件的内容。相关方法：<code>fs.read()</code>。</li><li><code>fs.readlink()</code>: 读取符号链接的值。</li><li><code>fs.realpath()</code>: 将相对的文件路径指针（<code>.</code>、<code>..</code>）解析为完整的路径。</li><li><code>fs.rename()</code>: 重命名文件或文件夹。</li><li><code>fs.rmdir()</code>: 删除文件夹。</li><li><code>fs.stat()</code>: 返回文件（通过传入的文件名指定）的状态。相关方法：<code>fs.fstat()</code>、<code>fs.lstat()</code>。</li><li><code>fs.symlink()</code>: 新建文件的符号链接。</li><li><code>fs.truncate()</code>: 将传递的文件名标识的文件截断为指定的长度。相关方法：<code>fs.ftruncate()</code>。</li><li><code>fs.unlink()</code>: 删除文件或符号链接。</li><li><code>fs.unwatchFile()</code>: 停止监视文件上的更改。</li><li><code>fs.utimes()</code>: 更改文件（通过传入的文件名指定）的时间戳。相关方法：<code>fs.futimes()</code>。</li><li><code>fs.watchFile()</code>: 开始监视文件上的更改。相关方法：<code>fs.watch()</code>。</li><li><code>fs.writeFile()</code>: 将数据写入文件。相关方法：<code>fs.write()</code>。</li></ul> 
</blockquote> 
<h5><a id="1_767"></a>1、文件属性</h5> 
<h6><a id="11stat_769"></a>1.1、获取文件属性stat</h6> 
<blockquote> 
 <p>stat() 第一个参数是文件路径，第二个参数是一个回调函数（err, stats）=&gt; {};</p> 
 <p>返回的stats常用以下几点属性</p> 
 <ul><li>使用 stats.isFile() 和 stats.isDirectory() 判断文件是否目录或文件。</li><li>使用 stats.isSymbolicLink() 判断文件是否符号链接。</li><li>使用 stats.size 获取文件的大小</li></ul> 
 <p>stat是异步的，也可以同步操作 statSync(),但需要注意的是同步会阻塞进程。</p> 
</blockquote> 
<pre><code class="prism language-js">fs<span class="token punctuation">.</span><span class="token function">stat</span><span class="token punctuation">(</span><span class="token string">'./test.txt'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">err<span class="token punctuation">,</span> stats</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>stats<span class="token punctuation">)</span><span class="token punctuation">;</span>
	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>stats<span class="token punctuation">.</span><span class="token function">isFile</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>stats<span class="token punctuation">.</span><span class="token function">isDirectory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span>
	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>stats<span class="token punctuation">.</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 21 文件大小</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h5><a id="2_793"></a>2、操作文件</h5> 
<blockquote> 
 <p>文件描述符</p> 
 <ul><li>r 读取模式</li><li>r+ 读写模式 !!!</li><li>rs 同步读取</li><li>rs+ 同步读写</li><li>w 写入模式，如果文件不存在就创建</li><li>wx 类似于w，但是如果文件存在，则写入失败</li><li>w+ 打开文件用于读写，将流定位到文件的开头。如果文件不存在则创建文件 也就是写入的时候会覆盖 !!!</li><li>wx+ 类似w+ 如果文件路径存在 则写入失败</li><li>a 打开文件用于写入，将流定位到文件的末尾。如果文件不存在则创建文件 写入的时候在文件末尾追加 !!!</li><li>ax 同a 文件存在 则写入失败</li><li>a+ 打开文件用于读写，将流定位到文件的末尾。如果文件不存在则创建文件 !!!</li><li>ax+ 同a+ 文件存在 则文件读取追加失败</li></ul> 
</blockquote> 
<h6><a id="21readFile_810"></a>2.1、读取文件内容readFile</h6> 
<blockquote> 
 <p>异步的 fs.readFile() 和同步的 fs.readFileSync()</p> 
 <p><code>fs.readFile()</code></p> 
 <ul><li>第一个参数是文件路径</li></ul> 
 <ul><li>第二个参数是读取文件时用到的编码格式 一般都是’utf-8’.</li><li>参数三是一个回调函数，有返回成功的信息和失败的信息,如果返回成功则失败信息为null，如果返回失败则成功信息为undefined</li></ul> 
</blockquote> 
<pre><code class="prism language-js">fs<span class="token punctuation">.</span><span class="token function">readFile</span><span class="token punctuation">(</span><span class="token string">'./test.txt'</span><span class="token punctuation">,</span> <span class="token string">'utf-8'</span><span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">error<span class="token punctuation">,</span> successData</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">// 读取成功 则error为null.</span>
		<span class="token keyword">return</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'读取文件失败'</span><span class="token punctuation">,</span> error<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>successData<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h6><a id="22writeFile_830"></a>2.2、向文件中写入信息writeFile</h6> 
<blockquote> 
 <p><code>fs.writeFile()</code></p> 
 <p>http://nodejs.cn/api/fs.html#fswritefilefile-data-options-callback</p> 
 <ul><li> <p>第一个参数 文件路径</p> </li><li> <p>第二个参数，表示写入的内容</p> </li><li> <p>第三个参数，表示用什么样的形式写入文件内容</p> <p>{<!-- --></p> <p>​ encoding: ‘utf-8’, <strong>默认值:</strong> <code>'utf8'</code></p> <p>​ flag: ‘r+’, 文件描述符 ，默认值: <code>'w'</code></p> <p>​ signal: " ", 允许中止正在进行的写入文件</p> <p>}</p> </li><li> <p>第四个参数，回调函数 回调只有一个参数 写入是否失败。</p> </li></ul> 
</blockquote> 
<pre><code class="prism language-js">fs<span class="token punctuation">.</span><span class="token function">writeFileSync</span><span class="token punctuation">(</span><span class="token string">'./test.txt'</span><span class="token punctuation">,</span> <span class="token string">'2222'</span><span class="token punctuation">,</span><span class="token punctuation">{<!-- --></span> <span class="token literal-property property">encoding</span><span class="token operator">:</span> <span class="token string">'utf-8'</span><span class="token punctuation">,</span> <span class="token literal-property property">flag</span><span class="token operator">:</span> <span class="token string">'a+'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">error</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">// 写入成功 则error为null. 失败 则为错误对象</span>
 		<span class="token keyword">return</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'读取文件失败'</span><span class="token punctuation">,</span> error<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
fs<span class="token punctuation">.</span><span class="token function">readFile</span><span class="token punctuation">(</span><span class="token string">'./test.txt'</span><span class="token punctuation">,</span> <span class="token string">'utf-8'</span><span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">error<span class="token punctuation">,</span> successData</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">// 读取成功 则error为null.</span>
		<span class="token keyword">return</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'读取文件失败'</span><span class="token punctuation">,</span> error<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>successData<span class="token punctuation">,</span> <span class="token string">'写入之后调用'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// successData 写入之后调用</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h6><a id="23appendFile_870"></a>2.3、追加到文件appendFile</h6> 
<blockquote> 
 <p>fs.appendFile()</p> 
 <p>不需要像writeFile一样设置模式 直接追加 个人理解writeFile中包含appendFile的功能</p> 
 <ul><li>第一个参数 文件路径</li><li>第二个参数 追加内容</li><li>第三个参数 回调 结束一个参数 err 判断是否追加成功。</li></ul> 
</blockquote> 
<pre><code class="prism language-js">fs<span class="token punctuation">.</span><span class="token function">appendFile</span><span class="token punctuation">(</span><span class="token string">'./test.txt'</span><span class="token punctuation">,</span> <span class="token string">'追加'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">err</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> 
<h6><a id="24open_886"></a>2.4、打开文件open</h6> 
<blockquote> 
 <p>fs.open()</p> 
 <p>打开文件</p> 
 <ul><li>第一个参数是文件的路径</li><li>第二个参数是以什么样的形式打开文件，文件描述符</li><li>第三个参数是回调函数 接收两个参数 err和 fd 其中err是异常信息 fd是文件描述符(linux基础)</li></ul> 
</blockquote> 
<pre><code class="prism language-js">fs<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">'./test.txt'</span><span class="token punctuation">,</span> <span class="token string">'r'</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">err<span class="token punctuation">,</span> fd</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>err<span class="token punctuation">,</span> <span class="token string">'打开文件失败'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> <span class="token string">'打开文件成功'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> 
<h5><a id="3_905"></a>3、操作文件夹</h5> 
<h6><a id="31assecc_907"></a>3.1、检查文件是否存在assecc</h6> 
<blockquote> 
 <p>fs.assecc(文件路径，(err) =&gt; {文件存在或者访问正常的话err为null, 否则存在err})</p> 
 <p>fs.asseccSync() 同步</p> 
 <p>access 中文 访问、入口、使用权等</p> 
</blockquote> 
<pre><code class="prism language-js">fs<span class="token punctuation">.</span><span class="token function">access</span><span class="token punctuation">(</span><span class="token string">'./test.txt'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">err</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h6><a id="32_mkdir_921"></a>3.2、创建一个文件夹 mkdir</h6> 
<blockquote> 
 <p>创建一个文件夹 mkdir 或者同步的mkdirSync()</p> 
 <p>fs.mkdir(新的文件夹路径, (err) =&gt; {}); // 如果文件夹在改路径已存在就会报错</p> 
 <p>mkdir 中文 建立一个新的子目录</p> 
</blockquote> 
<pre><code class="prism language-js">fs<span class="token punctuation">.</span><span class="token function">mkdir</span><span class="token punctuation">(</span><span class="token string">'./mkNewDir'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">err</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h6><a id="33readdir_935"></a>3.3、读取目录的内容readdir</h6> 
<blockquote> 
 <p>读取目录的内容 会读取文件夹的内容（全部的文件和子文件夹），并返回它们的相对路径</p> 
 <p>fs.readdir()</p> 
 <p>readdirSync()</p> 
 <p>readdir 读取目录项，从目录下读取条目</p> 
</blockquote> 
<pre><code class="prism language-js">fs<span class="token punctuation">.</span><span class="token function">readdir</span><span class="token punctuation">(</span><span class="token string">'../node'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">err<span class="token punctuation">,</span> content</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>err<span class="token punctuation">,</span> content<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// content: [ 'fsLearn.js', 'mkNewDir', 'test.txt', '基础.txt' ]</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> 
<h6><a id="34rename_951"></a>3.4、重命名文件夹rename</h6> 
<blockquote> 
 <p>rename() 同步renameSync()</p> 
 <p>rename(当前路径，新的路径，(err) =&gt; {});</p> 
</blockquote> 
<pre><code class="prism language-js">fs<span class="token punctuation">.</span><span class="token function">rename</span><span class="token punctuation">(</span><span class="token string">'./mkNewDir'</span><span class="token punctuation">,</span> <span class="token string">'./testRename'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">err</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token comment">// 执行完成之后mkNewDir文件夹 就变成了testRename。</span>
</code></pre> 
<h6><a id="35_963"></a>3.5、删除文件夹</h6> 
<blockquote> 
 <p>fs.rmdir() 同步fs.rmdirSync() 删除文件夹</p> 
 <p>删除的话可以采用替代品fs-extra npm install fs-extra,使用同fs,需要引入fs</p> 
 <ul><li> <p>引入的时候使用 const fsExtra = require(‘fs-extra’);</p> </li><li> <p>fs-extra 中的remove可以替代 rmdir,remove 可以同promise、async/awite一起使用 http://nodejs.cn/learn/working-with-folders-in-nodejs</p> </li></ul> 
 <ul><li>extra 中文 额外的</li></ul> 
</blockquote> 
<pre><code class="prism language-js">fs<span class="token punctuation">.</span><span class="token function">rmdir</span><span class="token punctuation">(</span><span class="token string">'./mkNewDir'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">err</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
 console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 执行完成之后 删除调mkNewDir 文件夹 没有错误的话 err为null</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> 
<h2><a id="path__981"></a>path 路径</h2> 
<p>系统中的每个文件都有路径</p> 
<pre><code class="prism language-js"><span class="token comment">// 引入模块</span>
<span class="token keyword">const</span> path <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'path'</span><span class="token punctuation">)</span>

</code></pre> 
<p><strong>解析和规范化都不会检查路径是否存在。 其只是根据获得的信息来计算路径</strong></p> 
<h5><a id="1pathdirname_993"></a>1、path.dirname()</h5> 
<p>获取路径的目录部分。</p> 
<pre><code class="prism language-js"><span class="token keyword">const</span> path <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'path'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> pathName <span class="token operator">=</span> <span class="token string">'./learn/test/zh.txt'</span>
path<span class="token punctuation">.</span><span class="token function">dirname</span><span class="token punctuation">(</span>pathName<span class="token punctuation">)</span> <span class="token comment">// ./learn/test</span>
</code></pre> 
<h5><a id="2pathbasename_1003"></a>2、path.basename()</h5> 
<p>获取文件名部分。指定第二个参数可以获取不带扩展名的文件名，第二个参数为扩展名</p> 
<pre><code class="prism language-js"><span class="token keyword">const</span> path <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'path'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> pathName <span class="token operator">=</span> <span class="token string">'./learn/test/zh.txt'</span>

<span class="token comment">// 获取当前文件名</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">basename</span><span class="token punctuation">(</span>pathName<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// zh.txt</span>
<span class="token comment">// 获取不带扩展名的文件名</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">basename</span><span class="token punctuation">(</span>pathName<span class="token punctuation">,</span> path<span class="token punctuation">.</span><span class="token function">extname</span><span class="token punctuation">(</span>pathName<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// zh</span>
</code></pre> 
<h5><a id="3pathextname_1017"></a>3、path.extname()</h5> 
<p>获取文件的扩展名。</p> 
<pre><code class="prism language-js"><span class="token keyword">const</span> path <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'path'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> pathName <span class="token operator">=</span> <span class="token string">'./learn/test/zh.txt'</span>

<span class="token comment">// 获取当前文件扩展名</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">extname</span><span class="token punctuation">(</span>pathName<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// .txt</span>
</code></pre> 
<h5><a id="4pathjoin_1029"></a>4、path.join()</h5> 
<p>连接路径的两个或多个片段</p> 
<pre><code class="prism language-js"><span class="token keyword">const</span> path <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'path'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> name <span class="token operator">=</span> <span class="token string">'test'</span>
<span class="token keyword">const</span> test <span class="token operator">=</span> path<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">'/'</span><span class="token punctuation">,</span> <span class="token string">'users'</span><span class="token punctuation">,</span> name<span class="token punctuation">,</span> <span class="token string">'join.txt'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>test<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// /users/test/join.txt</span>
</code></pre> 
<h5><a id="5pathresolve_1040"></a>5、path.resolve()</h5> 
<p>获得相对路径的绝对路径计算</p> 
<pre><code class="prism language-js"><span class="token comment">// path.resolve()</span>
<span class="token keyword">const</span> path <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'path'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 传一个参数的时候，以当前文件所在的绝对路径，拼接testResolve</span>
path<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'testResolve.js'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// /Users/xiannv/Documents/软件学习资料/LearnExample /node/testResolve.js</span>

<span class="token comment">// 再给前面加参数的时候，就会再拼起来</span>
path<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'test'</span><span class="token punctuation">,</span> <span class="token string">'testResolve.js'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// /Users/xiannv/Documents/软件学习资料/LearnExample /node/test/testResolve.js</span>

<span class="token comment">// 但是如果第一个参数以斜杠开头，则表示它是绝对路径：</span>
path<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'/test'</span><span class="token punctuation">,</span> <span class="token string">'testResolve.js'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// /test/testResolve.js</span>
</code></pre> 
<h5><a id="6pathnormalize_1058"></a>6、path.normalize()</h5> 
<p>当包含诸如 <code>.</code>、<code>..</code> 或双斜杠之类的相对说明符时，其会尝试计算实际的路径：</p> 
<pre><code class="prism language-js"><span class="token comment">// path.normalize</span>
path<span class="token punctuation">.</span><span class="token function">normalize</span><span class="token punctuation">(</span><span class="token string">'/users/joe/..//test.txt'</span><span class="token punctuation">)</span> <span class="token comment">//'/users/test.txt'</span>
</code></pre> 
<h5><a id="7pathisAbsolute_1067"></a>7、path.isAbsolute()</h5> 
<p>如果是绝对路径，则返回 true</p> 
<pre><code class="prism language-js">path<span class="token punctuation">.</span><span class="token function">isAbsolute</span><span class="token punctuation">(</span><span class="token string">'/test/absolute'</span><span class="token punctuation">)</span> <span class="token punctuation">;</span> <span class="token comment">// true</span>
path<span class="token punctuation">.</span><span class="token function">isAbsolute</span><span class="token punctuation">(</span><span class="token string">'./test/absolute'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span>
</code></pre> 
<h5><a id="8pathparse_1076"></a>8、path.parse()</h5> 
<p>解析路径片段，并返回信息对象</p> 
<pre><code class="prism language-js"><span class="token literal-property property">root</span><span class="token operator">:</span> 根路径。
<span class="token literal-property property">dir</span><span class="token operator">:</span> 从根路径开始的文件夹路径。
<span class="token literal-property property">base</span><span class="token operator">:</span> 文件名 <span class="token operator">+</span> 扩展名
<span class="token literal-property property">name</span><span class="token operator">:</span> 文件名
<span class="token literal-property property">ext</span><span class="token operator">:</span> 文件扩展名

<span class="token comment">// 传入相对路径</span>
path<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span><span class="token string">'./test/parse.js'</span><span class="token punctuation">)</span>
<span class="token comment">// 返回如下</span>
<span class="token punctuation">{<!-- --></span>
  <span class="token literal-property property">root</span><span class="token operator">:</span> <span class="token string">''</span><span class="token punctuation">,</span>
  <span class="token literal-property property">dir</span><span class="token operator">:</span> <span class="token string">'./test'</span><span class="token punctuation">,</span>
  <span class="token literal-property property">base</span><span class="token operator">:</span> <span class="token string">'parse.js'</span><span class="token punctuation">,</span>
  <span class="token literal-property property">ext</span><span class="token operator">:</span> <span class="token string">'.js'</span><span class="token punctuation">,</span>
  <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'parse'</span>
<span class="token punctuation">}</span>

<span class="token comment">// 传入绝对路径</span>
path<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span><span class="token string">'/test/parse.js'</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
  <span class="token literal-property property">root</span><span class="token operator">:</span> <span class="token string">'/'</span><span class="token punctuation">,</span>
  <span class="token literal-property property">dir</span><span class="token operator">:</span> <span class="token string">'/test'</span><span class="token punctuation">,</span>
  <span class="token literal-property property">base</span><span class="token operator">:</span> <span class="token string">'parse.js'</span><span class="token punctuation">,</span>
  <span class="token literal-property property">ext</span><span class="token operator">:</span> <span class="token string">'.js'</span><span class="token punctuation">,</span>
  <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'parse'</span>
<span class="token punctuation">}</span>
</code></pre> 
<h5><a id="9pathrelative_1109"></a>9、path.relative()</h5> 
<p>接受两个路径作为参数， 基于当前工作目录，返回从第一个路径到第二个路径的相对路径。</p> 
<pre><code class="prism language-js"> path<span class="token punctuation">.</span><span class="token function">relative</span><span class="token punctuation">(</span><span class="token string">'/Users/joe'</span><span class="token punctuation">,</span> <span class="token string">'/Users/joe/test.txt'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// test.txt</span>
</code></pre> 
<h2><a id="buffer_1117"></a>buffer</h2> 
<blockquote> 
 <p><strong>buffer是什么？</strong></p> 
 <p>buffer 是内存区域，它表示在V8引擎之外配置的固定大小的内存块，无法调整大小。</p> 
 <p>可以将buffer看作一个整数数组，每个整数代表一个数据字节</p> 
 <p><strong>什么情况下使用？</strong></p> 
 <p>当流处理器接收数据的速度大于其消耗的速度时，此时就会将数据先放入buffer中</p> 
</blockquote> 
<h5><a id="1buffer_1129"></a>1、创建buffer</h5> 
<h6><a id="11bufferfrom_1131"></a>1.1、buffer.from()</h6> 
<blockquote> 
 <p><a href="http://nodejs.cn/api/buffer.html#buffer_class_method_buffer_from_array" rel="nofollow"><code>Buffer.from(array)</code></a></p> 
 <p>使用 0 – 255 范围内的字节 array 分配新的 Buffer。 该范围之外的数组条目将被截断以符合它<br> 如果 array 不是 Array 或其他适用于 Buffer.from() 变体的类型，则将抛出 TypeError。</p> 
</blockquote> 
<pre><code class="prism language-js"><span class="token comment">// 创建一个包含 [0x62, 0x75, 0x66, 0x66, 0x65, 0x72] 的 Buffer</span>
<span class="token keyword">const</span> buffer <span class="token operator">=</span> Buffer<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0x62</span><span class="token punctuation">,</span> <span class="token number">0x75</span><span class="token punctuation">,</span> <span class="token number">0x66</span><span class="token punctuation">,</span> <span class="token number">0x66</span><span class="token punctuation">,</span> <span class="token number">0x65</span><span class="token punctuation">,</span> <span class="token number">0x72</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<blockquote> 
 <p><a href="http://nodejs.cn/api/buffer.html#buffer_class_method_buffer_from_arraybuffer_byteoffset_length" rel="nofollow"><code>Buffer.from(arrayBuffer[, byteOffset[, length\]])</code></a></p> 
 <p>返回一个新建的与给定的 ArrayBuffer 共享同一内存的 Buffer。<br> arrayBuffer<br> byteOffset 要暴露的第一个字节的索引 默认值 0<br> length 长度 默认值: arrayBuffer.byteLength - byteOffset<br> 支持 ArrayBuffer 可以覆盖超出 TypedArray 视图边界的内存范围。 使用 TypedArray 的 buffer 属性创建的新 Buffer 可能会超出 TypedArray 的范围</p> 
</blockquote> 
<pre><code class="prism language-js"><span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Uint16Array</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">5000</span><span class="token punctuation">;</span>
arr<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">4000</span><span class="token punctuation">;</span>
和 arr共享内存
<span class="token keyword">const</span> buf <span class="token operator">=</span> Buffer<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span>buffer<span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &lt;Buffer 88 13 a0 0f&gt;</span>
更改原始的 Uint16Array 也会更改缓冲区
arr<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">6000</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &lt;Buffer 88 13 70 17&gt;</span>

使用可选的 byteOffset 和length 指定了 arrayBuffer 中将由 Buffer 共享的内存范围
<span class="token keyword">const</span> ab <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayBuffer</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> buf1 <span class="token operator">=</span> Buffer<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span>ab<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>buf1<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2</span>
</code></pre> 
<blockquote> 
 <p><a href="http://nodejs.cn/api/buffer.html#buffer_class_method_buffer_from_buffer" rel="nofollow"><code>Buffer.from(buffer)</code></a></p> 
 <p>Buffer.from(buffer)<br> 要从中复制数据的现有 Buffer 或 Uint8Array。</p> 
</blockquote> 
<pre><code class="prism language-js"><span class="token keyword">const</span> bufferA <span class="token operator">=</span> Buffer<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">'buffer'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> bufferB <span class="token operator">=</span> Buffer<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span>bufferA<span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>bufferB<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
修改bufferA
bufferA<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0x61</span><span class="token punctuation">;</span>
<span class="token constant">A</span>修改之后，不会影响bufferB
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>bufferA<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>bufferB<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<blockquote> 
 <p><a href="http://nodejs.cn/api/buffer.html#buffer_class_method_buffer_from_string_encoding" rel="nofollow"><code>Buffer.from(string[, encoding\])</code></a></p> 
 <p>buffer.from(string[,encoding]) 创建包含string的新 Buffer。 encoding 参数标识将 string 转换为字节时要使用的字符编码<br> string 要编码的字符串<br> encoding 可选 string 的编码。 默认值: ‘utf8’<br> 如果 string 不是字符串或其他适用于 Buffer.from() 变体的类型，则将抛出 TypeError</p> 
</blockquote> 
<pre><code class="prism language-js"><span class="token keyword">const</span> bufString <span class="token operator">=</span> Buffer<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">'this is a tést'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>buf1<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// this is a tést</span>
</code></pre> 
<h6><a id="12Bufferallocsize_fill_encoding_1199"></a>1.2、Buffer.alloc(size[, fill[, encoding]])</h6> 
<blockquote> 
 <p>alloc ===&gt;&gt; 中文：分配</p> 
 <p>size buffer所需要的长度 用于预填充新 Buffer 的值。 默认值: 0<br> encoding如果fill是字符串的话，则这就是它的编码， 默认为’utf-8’<br> 如果 size 大于 buffer.constants.MAX_LENGTH 或小于 0，则抛出 ERR_INVALID_ARG_VALUE。<br> Buffer.alloc()比Buffer.allocUnsafe()慢，但是可以保证buffer中不包含敏感数据</p> 
</blockquote> 
<pre><code class="prism language-js"><span class="token keyword">const</span> bufferAlloc <span class="token operator">=</span> Buffer<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>bufferAlloc<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> bufferAlloc <span class="token operator">=</span> Buffer<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token string">'a'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &lt;Buffer 61 61 61 61 61&gt;</span>
</code></pre> 
<h6><a id="13BufferallocUnsafesize_1218"></a>1.3、Buffer.allocUnsafe(size)</h6> 
<blockquote> 
 <p>size是新的Buffer所需的长度<br> 这种方式创建的Buffer实例的底层内存不会被初始化，新创建的Buffer的内容是未知的，可能包含敏感的数据，使用Buffer.alloc()用来零初始化Buffer实例<br> 如果size不是数值，则会抛出TypeError</p> 
</blockquote> 
<h5><a id="2buffer_1224"></a>2、使用buffer</h5> 
<h6><a id="21Buffer_1226"></a>2.1、Buffer可以像数组一样被访问</h6> 
<pre><code class="prism language-js"><span class="token keyword">const</span> buf <span class="token operator">=</span> Buffer<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">'buffer'</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>buf<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">// 返回结果为第一个字符 b</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>buf<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">// 返回结果为第一个字符 u</span>
</code></pre> 
<h6><a id="22toStringbuffer_1233"></a>2.2、也可以使用toString()去打印buffer的全部内容</h6> 
<pre><code class="prism language-js">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>buf<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre> 
<h6><a id="23length_buffer_1241"></a>2.3、length 可以获取buffer的长度</h6> 
<pre><code class="prism language-js"><span class="token keyword">const</span> buf <span class="token operator">=</span> Buffer<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">'hello'</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>buf<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 5</span>
</code></pre> 
<h6><a id="24buffer_for_of_1248"></a>2.4、迭代buffer for of</h6> 
<pre><code class="prism language-js"><span class="token keyword">const</span> buf <span class="token operator">=</span> Buffer<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">'hello'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> item <span class="token keyword">of</span> buf<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
 console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token number">104</span>
<span class="token number">101</span>
<span class="token number">108</span>
<span class="token number">108</span>
<span class="token number">111</span>
</code></pre> 
<h6><a id="25buffer_1262"></a>2.5、更改buffer的内容</h6> 
<pre><code class="prism language-js">write<span class="token punctuation">,</span> 写入字符串
也可以数组索引方式去修改
<span class="token keyword">const</span> buf <span class="token operator">=</span> Buffer<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">'hello'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
buf<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">'write'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>buf<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// write 直接被重置</span>
buf<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">'four'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>buf<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// foure 前四位被重重</span>
<span class="token comment">// 测试如果大于长度</span>
buf<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">'testSex'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>buf<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// testS 只有5位被写入</span>
buf<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">111</span><span class="token punctuation">;</span> <span class="token comment">// 111是o的UTF-8编码</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>buf<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// oestS</span>
</code></pre> 
<h6><a id="26buffer_1279"></a>2.6、复制buffer</h6> 
<pre><code class="prism language-js">copy
必传参数：新的buffer
三个可选参数
 新的buffer开始写入的位置
 <span class="token literal-property property">buf内开始复制的偏移量。默认值</span><span class="token operator">:</span> <span class="token number">0</span>
 buf 内停止复制的偏移量（不包括）。 默认值<span class="token operator">:</span> buf<span class="token punctuation">.</span>length<span class="token punctuation">.</span>
<span class="token keyword">const</span> buf <span class="token operator">=</span> Buffer<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">'hello'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> bufCopy <span class="token operator">=</span> Buffer<span class="token punctuation">.</span><span class="token function">alloc</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
buf<span class="token punctuation">.</span><span class="token function">copy</span><span class="token punctuation">(</span>bufCopy<span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>buf<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> bufCopy<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// hello hell bufCopy复制了buf的内容</span>
<span class="token comment">// 如果传入三个参数，则</span>
<span class="token keyword">let</span> bufCopy1 <span class="token operator">=</span> Buffer<span class="token punctuation">.</span><span class="token function">alloc</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 分配两个字节的位置</span>
buf<span class="token punctuation">.</span><span class="token function">copy</span><span class="token punctuation">(</span>bufCopy1<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>bufCopy1<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// he</span>
buf<span class="token punctuation">.</span><span class="token function">copy</span><span class="token punctuation">(</span>bufCopy1<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>bufCopy1<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// el</span>
</code></pre> 
<h6><a id="27buffer_1300"></a>2.7、buffer切片</h6> 
<pre><code class="prism language-js"><span class="token comment">// slice</span>
<span class="token comment">// 两个参数 第一个是开始位置</span>
<span class="token comment">// 第二个参数是结束位置</span>
<span class="token keyword">const</span> buf <span class="token operator">=</span> Buffer<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">'Hey!'</span><span class="token punctuation">)</span>
buf<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//Hey!</span>
<span class="token keyword">const</span> slice <span class="token operator">=</span> buf<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>slice<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//He</span>
buf<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">111</span> <span class="token comment">//o</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>slice<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//Ho</span>
</code></pre> 
<h2><a id="_1314"></a>流</h2> 
<blockquote> 
 <p><strong>流是什么</strong></p> 
 <p>http://nodejs.cn/learn/nodejs-streams<br> 流是为node.js应用提供动力的基础概念之一<br> 它们是一种以高效的方式处理 读、写文件，网络通信，或者任何类型的端到端的信息交换<br> 程序使用传统的方式读取文件的时候，会将文件从头到尾的写入内存，然后进行处理。但是使用流，可以逐个片段读取并处理，并且无需全部保存在内存中</p> 
 <p><strong>流的优点</strong><br> 内存效率：不需要加载大量的数据到内存中即可进行处理<br> 时间效率：获取到数据之后就可以立刻开始处理数据，这样需要的时间更少，不需要等到整个的数据都读入内存之后才开始使用</p> 
</blockquote> 
<pre><code class="prism language-js">使用流编写 从磁盘读取文件，并在与 <span class="token constant">HTTP</span> 服务器建立新连接时通过 <span class="token constant">HTTP</span> 提供文件
<span class="token keyword">const</span> http <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'http'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> fs <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'fs'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> server <span class="token operator">=</span> http<span class="token punctuation">.</span><span class="token function">createServer</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span> res</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
 <span class="token keyword">const</span> stream <span class="token operator">=</span> fs<span class="token punctuation">.</span><span class="token function">createReadStream</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">'/test.txt'</span><span class="token punctuation">)</span>
 stream<span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
server<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h5><a id="1streampipe_1342"></a>1、stream.pipe</h5> 
<p>是用来获取来源流，并将其通过管道传输给目标流，也可以连接使用</p> 
<pre><code class="prism language-js">stream<span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>data1<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>data2<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h5><a id="2_1350"></a>2、分类</h5> 
<pre><code class="prism language-js">流分为四种
<span class="token literal-property property">Readable</span><span class="token operator">:</span> 可以通过管道读取，但是不能通过管道写入的流（可以接收数据，但是不能发送数据的流），当推送数据到可读流中时，会对其进行缓冲，直到使用者开始读取数据为止。
<span class="token literal-property property">Writable</span><span class="token operator">:</span> 可以通过管道写入，但是不可以通过管道读取的流（可以发送数据，但是不能接收数据）
<span class="token literal-property property">Duplex</span><span class="token operator">:</span> 可以通过管道写入和读取的流
<span class="token literal-property property">Transform</span><span class="token operator">:</span> 类似于双工流，但其输出的是其输入的转换流
</code></pre> 
<h5><a id="3_1360"></a>3、创建一个可读流</h5> 
<pre><code class="prism language-js"><span class="token keyword">const</span> Stream <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'stream'</span><span class="token punctuation">)</span> <span class="token comment">// 引入流</span>
<span class="token keyword">const</span> ReadableStream <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stream<span class="token punctuation">.</span>Readable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 创建流</span>
实现一个读的方法
ReadableStream<span class="token punctuation">.</span><span class="token function-variable function">_read</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">;</span>
也可以直接在创建的时候写入read方法
<span class="token keyword">const</span> ReadableStream <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stream<span class="token punctuation">.</span>Readable</span><span class="token punctuation">(</span><span class="token punctuation">{<!-- --></span>
 <span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>；
完成初始化之后，开始发送数据
ReadableStream<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">'hi'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h5><a id="4_1375"></a>4、创建可写流</h5> 
<pre><code class="prism language-js"><span class="token keyword">const</span> Stream <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'stream'</span><span class="token punctuation">)</span> 
<span class="token keyword">const</span> writeStream <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stream<span class="token punctuation">.</span>Writable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
writeStream<span class="token punctuation">.</span><span class="token function-variable function">_write</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">chunk<span class="token punctuation">,</span> encoding<span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
 console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>chunk<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
 <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
初始化结束之后，可以通过以下方式传输可读流：
process<span class="token punctuation">.</span>stdin<span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>writableStream<span class="token punctuation">)</span>



从可读流中获取数据，
方法一：使用可写流读取
<span class="token keyword">const</span> Stream <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'stream'</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> readableStream <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stream<span class="token punctuation">.</span>Readable</span><span class="token punctuation">(</span><span class="token punctuation">{<!-- --></span>
 <span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> writeStream <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stream<span class="token punctuation">.</span>Writable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
writeStream<span class="token punctuation">.</span><span class="token function-variable function">_write</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">chunk<span class="token punctuation">,</span> encoding<span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
 console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>chunk<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
 <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
readableStream<span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>writeStream<span class="token punctuation">)</span>
readableStream<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">'hi'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// hi</span>
readableStream<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">'ho'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ho</span>


方法二：通过readable事件直接消费可读流
<span class="token keyword">const</span> Stream <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'stream'</span><span class="token punctuation">)</span> <span class="token comment">// 引入流</span>
<span class="token keyword">const</span> readableStream <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stream<span class="token punctuation">.</span>Readable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 创建流</span>
 <span class="token comment">//实现一个读的方法</span>
 readableStream<span class="token punctuation">.</span><span class="token function-variable function">_read</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">// 完成初始化之后，开始发送数据</span>
readableStream<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">'hi'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
readableStream<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'readable'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
 console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>readableStream<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// &lt;Buffer 68 69&gt;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> 
<h5><a id="5_1417"></a>5、发送数据到可写流</h5> 
<p>使用流的write() 方法</p> 
<pre><code class="prism language-js">writeStream<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">'write'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h5><a id="6__end_1424"></a>6、使用信号通知 已经结束写入 的可写流end()</h5> 
<pre><code class="prism language-js"><span class="token keyword">const</span> Stream <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'stream'</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> readableStream <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stream<span class="token punctuation">.</span>Readable</span><span class="token punctuation">(</span><span class="token punctuation">{<!-- --></span>
 <span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> writableStream <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stream<span class="token punctuation">.</span>Writable</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
writableStream<span class="token punctuation">.</span><span class="token function-variable function">_write</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">chunk<span class="token punctuation">,</span> encoding<span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
 console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>chunk<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
 <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
readableStream<span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>writableStream<span class="token punctuation">)</span>
readableStream<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">'hi!'</span><span class="token punctuation">)</span>
readableStream<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">'ho!'</span><span class="token punctuation">)</span>
writableStream<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> 
<h2><a id="os__1444"></a>os 操作系统模块</h2> 
<p>os 操作系统模块。用于从底层的操作系统和程序运行所在的计算机上检索信息并进行交互<br> const os = require(‘os’);</p> 
<p>http://nodejs.cn/api/os.html#os_signal_constants<br> http://nodejs.cn/learn/the-nodejs-os-module</p> 
<h6><a id="1arch__1452"></a>1、arch 返回标识底层架构的字符串</h6> 
<blockquote> 
 <ul><li>os.arch() 返回二进制文件的操作系统。返回标识底层架构的字符串，例如arm、x64、arm64</li><li>返回结果相当于 process.arch()</li></ul> 
</blockquote> 
<pre><code class="prism language-js">os<span class="token punctuation">.</span><span class="token function">arch</span><span class="token punctuation">(</span><span class="token punctuation">)</span>； <span class="token comment">// x64</span>
</code></pre> 
<h6><a id="2cpusCPU_1461"></a>2、cpus：返回系统可用的CPU信息</h6> 
<blockquote> 
 <ul><li>返回系统可用的CPU信息</li><li>os.cpus()</li></ul> 
</blockquote> 
<pre><code class="prism language-js">os<span class="token punctuation">.</span><span class="token function">cpus</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span> <span class="token punctuation">{<!-- --></span> <span class="token literal-property property">model</span><span class="token operator">:</span> <span class="token string">'Intel(R) Core(TM) i5-7360U CPU @ 2.30GHz'</span><span class="token punctuation">,</span> <span class="token comment">// 模型 机器</span>
	  <span class="token literal-property property">speed</span><span class="token operator">:</span> <span class="token number">2300</span><span class="token punctuation">,</span> <span class="token comment">// 速度</span>
	  <span class="token literal-property property">times</span><span class="token operator">:</span><span class="token punctuation">{<!-- --></span>
	  <span class="token literal-property property">user</span><span class="token operator">:</span> <span class="token number">14668580</span><span class="token punctuation">,</span> <span class="token comment">// CPU在用户模式下花费的毫秒数</span>
		<span class="token literal-property property">nice</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token comment">// CPU在良好模式花费的毫秒数</span>
		<span class="token literal-property property">sys</span><span class="token operator">:</span> <span class="token number">9683670</span><span class="token punctuation">,</span> <span class="token comment">// CPU在系统模式下花费的毫秒数</span>
		<span class="token literal-property property">idle</span><span class="token operator">:</span> <span class="token number">53402030</span><span class="token punctuation">,</span> <span class="token comment">// CPU在空闲模式下花费的毫秒数</span>
		<span class="token literal-property property">irq</span><span class="token operator">:</span> <span class="token number">0</span> <span class="token comment">// CPU在中断请求模式下花费的毫秒数</span>
	<span class="token punctuation">}</span><span class="token punctuation">,</span>
	<span class="token punctuation">}</span><span class="token punctuation">,</span>
 <span class="token punctuation">{<!-- --></span> <span class="token literal-property property">model</span><span class="token operator">:</span> <span class="token string">'Intel(R) Core(TM) i5-7360U CPU @ 2.30GHz'</span><span class="token punctuation">,</span>
	 <span class="token literal-property property">speed</span><span class="token operator">:</span> <span class="token number">2300</span><span class="token punctuation">,</span>
   <span class="token literal-property property">times</span><span class="token operator">:</span> <span class="token punctuation">{<!-- --></span> <span class="token literal-property property">user</span><span class="token operator">:</span> <span class="token number">4355800</span><span class="token punctuation">,</span> <span class="token literal-property property">nice</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token literal-property property">sys</span><span class="token operator">:</span> <span class="token number">3203210</span><span class="token punctuation">,</span> <span class="token literal-property property">idle</span><span class="token operator">:</span> <span class="token number">70190940</span><span class="token punctuation">,</span> <span class="token literal-property property">irq</span><span class="token operator">:</span> <span class="token number">0</span> <span class="token punctuation">}</span>
 <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">]</span>
</code></pre> 
<h6><a id="3endianness_1485"></a>3、endianness()</h6> 
<blockquote> 
 <ul><li>返回标识 为其编译node二进制文件的CPU字节序的字符串</li><li>os.endianness()</li><li>返回BE: 大端序 、 LE :小端序</li><li>endianness 英文 字节顺序</li></ul> 
</blockquote> 
<pre><code class="prism language-js">os<span class="token punctuation">.</span><span class="token function">endianness</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// LE</span>
</code></pre> 
<h6><a id="4osfreemem__1496"></a>4、os.freemem 返回空闲的系统内存量</h6> 
<blockquote> 
 <p>返回空闲的系统内存量 以字节为单位</p> 
 <p>os.freemem()；</p> 
</blockquote> 
<pre><code class="prism language-js">os<span class="token punctuation">.</span><span class="token function">freemem</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment">// 119418880</span>
</code></pre> 
<h6><a id="5homedir___1506"></a>5、homedir 当前用户的主目录的路径</h6> 
<blockquote> 
 <p>返回当前用户的主目录的路径</p> 
</blockquote> 
<pre><code class="prism language-js">os<span class="token punctuation">.</span><span class="token function">homedir</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// /Users/bianlifeng</span>
</code></pre> 
<h6><a id="6oshostname_1514"></a>6、os.hostname主机名</h6> 
<blockquote> 
 <p>os.hostname()</p> 
</blockquote> 
<pre><code class="prism language-js">os<span class="token punctuation">.</span><span class="token function">hostname</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// bogon</span>
</code></pre> 
<h6><a id="7osloadavg__1522"></a>7、os.loadavg() 平均负载的计算</h6> 
<blockquote> 
 <p>返回对平均负载的计算，返回包含1、5、15分钟平均负载的数组</p> 
 <p>负载是指：cpu的使用率</p> 
 <p>平均负载是操作系统计算的系统活动量度，并表示为小数。</p> 
 <p>平均负载是 Unix 特有的概念。 在 Windows 上，返回值始终为 [0, 0, 0]</p> 
</blockquote> 
<pre><code class="prism language-js">os<span class="token punctuation">.</span><span class="token function">loadavg</span><span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token comment">// [ 2.923828125, 2.998046875, 4.12744140625 ]</span>
</code></pre> 
<h6><a id="8networkInterfaces_1536"></a>8、networkInterfaces()；返回系统可用的网络接口的详细信息</h6> 
<blockquote> 
 <p>返回系统可用的网络接口的详细信息，返回包含已分配网络地址的网络接口对象。</p> 
 <p>返回对象的每个key都标识着一个网络接口，关联的值是每个对象描述一个分配的网络地址的对象数组os.networkInterfaces()</p> 
</blockquote> 
<pre><code class="prism language-js">os<span class="token punctuation">.</span><span class="token function">networkInterfaces</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 
<span class="token punctuation">{<!-- --></span>
	<span class="token literal-property property">lo0</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">{<!-- --></span>
		<span class="token literal-property property">address</span><span class="token operator">:</span> <span class="token string">'127.0.0.1'</span><span class="token punctuation">,</span> <span class="token comment">// 分配的IPV4和IPv6地址</span>
		<span class="token literal-property property">netmask</span><span class="token operator">:</span> <span class="token string">'255.0.0.0'</span><span class="token punctuation">,</span> <span class="token comment">// IPV4和IPv6网络掩码</span>
		<span class="token literal-property property">family</span><span class="token operator">:</span> <span class="token string">'IPv4'</span><span class="token punctuation">,</span> <span class="token comment">// 会返回4（IPv4） 或者 6（IPv6）</span>
		<span class="token literal-property property">mac</span><span class="token operator">:</span> <span class="token string">'00:00:00:00:00:00'</span><span class="token punctuation">,</span> <span class="token comment">// 网络接口的MAC地址</span>
		<span class="token literal-property property">internal</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token comment">// 如果网络接口是不能远程访问的环回或者是类似接口，就为true，否则为false</span>
		<span class="token literal-property property">cidr</span><span class="token operator">:</span> <span class="token string">'127.0.0.1/8'</span> <span class="token comment">// 使用 CIDR 表示法的路由前缀分配的 IPv4 或 IPv6 地址。 如果 netmask 无效，则此属性设置为 null</span>
	<span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
	<span class="token literal-property property">en0</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">{<!-- --></span>
 		<span class="token literal-property property">address</span><span class="token operator">:</span> <span class="token string">'fe80::5a:6abc:dc2c:aca1'</span><span class="token punctuation">,</span>
		<span class="token literal-property property">netmask</span><span class="token operator">:</span> <span class="token string">'ffff:ffff:ffff:ffff::'</span><span class="token punctuation">,</span>
		<span class="token literal-property property">family</span><span class="token operator">:</span> <span class="token string">'IPv6'</span><span class="token punctuation">,</span>
		<span class="token literal-property property">mac</span><span class="token operator">:</span> <span class="token string">'8c:85:90:06:22:5a'</span><span class="token punctuation">,</span>
		<span class="token literal-property property">scopeid</span><span class="token operator">:</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token comment">// 数字的ipv6范围id, 只有IPV6有</span>
		<span class="token literal-property property">internal</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
		<span class="token literal-property property">cidr</span><span class="token operator">:</span> <span class="token string">'fe80::5a:6abc:dc2c:aca1/64'</span>
	<span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
</code></pre> 
<h6><a id="9platform_node_1567"></a>9、platform ：node编译的平台</h6> 
<blockquote> 
 <p>返回node编译的平台, 相当于process.platform()</p> 
 <p>返回标识为其编译 Node.js 二进制文件的操作系统平台的字符串。 该值在编译时设置。 可能的值为 ‘aix’、‘darwin’、‘freebsd’、‘linux’、‘openbsd’、‘sunos’、以及 ‘win32’</p> 
 <p>如果是安卓设备，则返回值为’android’</p> 
</blockquote> 
<pre><code class="prism language-js">os<span class="token punctuation">.</span><span class="token function">platform</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment">// darwin</span>
</code></pre> 
<h6><a id="10osrelease__1579"></a>10、os.release： 标识操作系统版本号的字符串</h6> 
<blockquote> 
 <p>标识操作系统版本号的字符串</p> 
 <p>os.release()</p> 
 <p>release // 英文 释放</p> 
</blockquote> 
<pre><code class="prism language-js">os<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 20.5.0</span>
</code></pre> 
<h6><a id="11ostmpdir_1591"></a>11、os.tmpdir</h6> 
<blockquote> 
 <p>返回操作系统默认的临时文件的目录</p> 
</blockquote> 
<pre><code class="prism language-js">os<span class="token punctuation">.</span><span class="token function">tmpdir</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment">// /var/folders/zq/6v7d1c3d6z9_lx89wj9n08q40000gp/T</span>
</code></pre> 
<h6><a id="12ostotalmem_1599"></a>12、os.totalmem()</h6> 
<blockquote> 
 <p>返回系统中总内存的字节数</p> 
</blockquote> 
<pre><code class="prism language-js">os<span class="token punctuation">.</span><span class="token function">totalmem</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 8589934592</span>
</code></pre> 
<h6><a id="13_ostype_1607"></a>13、 os.type()</h6> 
<blockquote> 
 <p>标识操作系统</p> 
 <p>Linux 上返回 ‘Linux’, macOS上返回‘Darwin’,在window上面返回‘Window_NT’</p> 
</blockquote> 
<pre><code class="prism language-js">os<span class="token punctuation">.</span><span class="token function">type</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// Darwin</span>
</code></pre> 
<h6><a id="14osuptime_1619"></a>14、os.uptime()</h6> 
<blockquote> 
 <p>以秒为单位返回系统正常运行时间</p> 
</blockquote> 
<pre><code class="prism language-js">os<span class="token punctuation">.</span><span class="token function">uptime</span><span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token comment">// 189973</span>
</code></pre> 
<h6><a id="15osuserInfo_1627"></a>15、os.userInfo()</h6> 
<blockquote> 
 <p>返回包含当前 username、uid、gid、shell 和 homedir 的对象</p> 
</blockquote> 
<pre><code class="prism language-js">os<span class="token punctuation">.</span><span class="token function">userInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span> 
	<span class="token literal-property property">uid</span><span class="token operator">:</span> <span class="token number">502</span><span class="token punctuation">,</span>
	<span class="token literal-property property">gid</span><span class="token operator">:</span> <span class="token number">20</span><span class="token punctuation">,</span>
	<span class="token literal-property property">username</span><span class="token operator">:</span> <span class="token string">'bianlifeng'</span><span class="token punctuation">,</span>
	<span class="token literal-property property">homedir</span><span class="token operator">:</span> <span class="token string">'/Users/bianlifeng'</span><span class="token punctuation">,</span>
	<span class="token literal-property property">shell</span><span class="token operator">:</span> <span class="token string">'/bin/zsh'</span>
<span class="token punctuation">}</span>
</code></pre> 
<h6><a id="16osversion_1643"></a>16、os.version()</h6> 
<blockquote> 
 <p>返回标识内核版本的字符串</p> 
 <ul><li>v13.11.0, v12.17.0 新增属性</li></ul> 
</blockquote> 
<pre><code class="prism language-js">os<span class="token punctuation">.</span><span class="token function">version</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> 
<h6><a id="17osconstants_1653"></a>17、os.constants()</h6> 
<blockquote> 
 <p>返回操作系统常量</p> 
</blockquote> 
<pre><code class="prism language-js">os<span class="token punctuation">.</span><span class="token function">constants</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> 
<h2><a id="http_1663"></a>http模块</h2> 
<blockquote> 
 <p>http 模块， 提供了一些网络相关的模块<br> http://nodejs.cn/learn/the-nodejs-http-module</p> 
 <p>http 模块是 Node.js 中非常重要的一个核心模块。通过 http 模块，你可以使用其 http.createServer 方法创建一个 http 服务器，也可以使用其 http.request 方法创建一个 http 客户端。(本文先不说),Node 对 HTTP 协议及相关 API 的封装比较底层，其仅能处理流和消息，对于消息的处理，也仅解析成报文头和报文体，但是不解析实际的报文头和报文体内容。这样不仅解决了 HTTP 原本比较难用的特性，也可以支持更多的 HTTP 应用.</p> 
 <p>引入：const http = require(‘http’);</p> 
</blockquote> 
<h5><a id="1_1672"></a>1、属性</h5> 
<h5><a id="11httpMETHODS_getpost_1673"></a>1.1、http.METHODS 请求的方法：get、post等</h5> 
<blockquote> 
 <p>const http = require(‘http’);<br> console.log(http.METHODS)</p> 
</blockquote> 
<h6><a id="12_httpSTATUS_CODES_1677"></a>1.2、 http.STATUS_CODES</h6> 
<blockquote> 
 <p>返回所有的HTTP状态码及其描述<br> console.log(http.STATUS_CODES)</p> 
</blockquote> 
<h6><a id="13httpglobalAgent_1682"></a>1.3、http.globalAgent</h6> 
<blockquote> 
 <p>指向 Agent 对象的全局实例，该实例是 http.Agent 类的实例。<br> http://nodejs.cn/api/http.html#class-httpagent<br> console.log(http.globalAgent)</p> 
</blockquote> 
<h5><a id="2_1688"></a>2、方法</h5> 
<h5><a id="21__1689"></a>2.1、 创建一个实例</h5> 
<blockquote> 
 <p>http.createServer() 返回http.server类的新实例<br> http://nodejs.cn/api/http.html#httpcreateserveroptions-requestlistener<br> const server = http.createServer((req, res) =&gt; {<!-- --><br> 使用此回调处理每个单独的请求。<br> })</p> 
</blockquote> 
<h6><a id="22httprequest_1697"></a>2.2、http.request()</h6> 
<p>发送http请求到服务器，并创建http.ClientRequest()类的实例</p> 
<h6><a id="23httpget_1700"></a>2.3、http.get()</h6> 
<p>类似于http.request(),但是会自动设置Http方法为get,并自动调用req.end()</p> 
<h5><a id="3__1703"></a>3、 类</h5> 
<h6><a id="31httpIncomingMessage__1705"></a>3.1、http.IncomingMessage 对象</h6> 
<p>IncomingMessage 对象是由 http.Server 或 http.ClientRequest 创建的，并作为第一参数分别传递给 http.Server 的’request’事件和 http.ClientRequest 的’response’事件。</p> 
<p>它也可以用来访问应答的状态、头文件和数据等。 IncomingMessage 对象实现了 Readable Stream 接口，对象中还有一些事件，方法和属性。</p> 
<p>在 http.Server 或 http.ClientRequest 中略有不同。</p> 
<h6><a id="32httpcreateServerrequestListener_HTTP__1713"></a>3.2、http.createServer([requestListener])创建 HTTP 服务器</h6> 
<p>实现 HTTP 服务端功能，要通过 http.createServer 方法创建一个服务端对象 http.Server。</p> 
<p>这个方法接收一个可选传入参数 requestListener，该参数是一个函数，传入后将做为 http.Server 的 request 事件监听。不传入时，则需要通过在 http.Server 对象的 request 事件中单独添加。</p> 
<pre><code>var http = require('http')

// 创建server对象，并添加request事件监听器
var server = http.createServer(function(req, res) {
  res.writeHeader(200, { 'Content-Type': 'text/plain' })
  res.end('Hello Nodejs')
})

// 创建server对象，通过server对象的request事件添加事件事件监听器
var server = new http.Server()
server.on('request', function(req, res) {
  res.writeHeader(200, { 'Content-Type': 'text/plain' })
  res.end('Hello Nodejs')
})
</code></pre> 
<h6><a id="33httpServer__1736"></a>3.3、http.Server 服务器对象</h6> 
<p>http.Server 对象是一个事件发射器 EventEmitter，会发射：request、connection、close、checkContinue、connect、upgrade、clientError 事件。</p> 
<p>其中 request 事件监听函数为 function (request, response) { }，该方法有两个参数：request 是一个 http.IncomingMessage 实例，response 是一个 http.ServerResponse 实例。</p> 
<p>http.Server 对象中还有一些方法，调用 server.listen 后 http.Server 就可以接收客户端传入连接。</p> 
<h6><a id="34httpServerResponse_1744"></a>3.4、http.ServerResponse</h6> 
<p>http.ServerResponse 对象用于响应处理客户端请求。</p> 
<p>http.ServerResponse 是 HTTP 服务器（http.Server）内部创建的对象，作为第二个参数传递给 'request’事件的监听函数。</p> 
<p>http.ServerResponse 实现了 Writable Stream 接口，其对于客户端的响应，本质上是对这个可写流的操作。它还是一个 EventEmitter，包含：close、finish 事件。</p> 
<h6><a id="35_httpServer_1752"></a>3.5、创建一个 http.Server</h6> 
<p>创建 http.Server 使用 http.createServer()方法，为了处理客户端请求，需要在服务端监听来自客户的’request’事件。</p> 
<p>'request’事件的回调函数中，会返回一个 http.IncomingMessage 实例和一个 http.ServerResponse。</p> 
<pre><code>const http = require('http')
/**
 * @param {Object} req 是一个http.IncomingMessag实例
 * @param {Object} res 是一个http.ServerResponse实例
 */
const server = http.createServer((req, res) =&gt; {
  console.log(req.headers)
  res.end(`Hello Nodejs`)
})

server.listen(3000)
</code></pre> 
<p>http.ServerResponse 实例是一个可写流，所以可以将一个文件流转接到 res 响应流中。下面示例就是将一张图片流传送到 HTTP 响应中：</p> 
<pre><code>const http = require('http')
/**
 * @param {Object} req 是一个http.IncomingMessag实例
 * @param {Object} res 是一个http.ServerResponse实例
 */
const server = http.createServer((req, res) =&gt; {
  res.writeHead(200, { 'Content-Type': 'image/jpg' })
  const r = require('fs').createReadStream('./kobe.jpg')
  r.pipe(res)
})

server.listen(3000)
</code></pre> 
<h3><a id="zlib_1791"></a>zlib压缩</h3> 
<p>在流传输过程中，为减少传输数据加快传输速度，往往会对流进行压缩。</p> 
<p>HTTP 流就是如此，为提高网站响应速度，会在服务端进行压缩，客户端收到数据后再进行相应的解压。</p> 
<p>Node.js 中的 Zlib 模块提供了流压缩与解压缩功能，Zlib 模块提供了对 Gzip/Gunzip、Deflate/Inflate、DeflateRaw/InflateRaw 类的绑定，这些类可以实现对可读流/可写流的压缩与解压。</p> 
<h5><a id="1_gzip__deflate_1799"></a>1、关于 gzip 与 deflate</h5> 
<p>deflate(RFC1951)是一种压缩算法，使用 LZ77 和哈弗曼进行编码。gzip(RFC1952)一种压缩格式，是对 deflate 的简单封装，gzip = gzip 头(10 字节) + deflate 编码的实际内容 + gzip 尾(8 字节)。在 HTTP 传输中，gzip 是一种常用的压缩算法，使用 gzip 压缩的 HTTP 数据流，会在 HTTP 头中使用 Content-Encoding：gzip 进行标识。</p> 
<p>HTTP Request Header 中 Accept-Encoding 是浏览器发给服务器,声明浏览器支持的解压类型</p> 
<pre><code>Accept-Encoding: gzip, deflate, br
</code></pre> 
<p>HTTP Response Header 中 Content-Encoding 是服务器告诉浏览器 使用了哪种压缩类型</p> 
<pre><code>Content-Encoding: gzip
</code></pre> 
<p>对 web 性能优化有所了解的同学,相信对 gzip 都不陌生,我们就通过 gzip 来了解 zlib 模块.</p> 
<h5><a id="2__1817"></a>2、 文件压缩/解压</h5> 
<h6><a id="21_1819"></a>2.1、文件压缩</h6> 
<pre><code>const zlib = require('zlib')
const fs = require('fs')
const gzip = zlib.createGzip()
const inp = fs.createReadStream('zlib.txt')
const out = fs.createWriteStream('zlib.txt.gz')
inp.pipe(gzip).pipe(out)
</code></pre> 
<h6><a id="22_1830"></a>2.2、文件解压</h6> 
<pre><code>const zlib = require('zlib')
const fs = require('fs')
const gunzip = zlib.createGunzip()
const inp = fs.createReadStream('./un-zlib.txt.gz')
const out = fs.createWriteStream('un-zlib.txt')
inp.pipe(gunzip).pipe(out)
</code></pre> 
<h5><a id="3_gzip__1841"></a>3、服务端 gzip 压缩</h5> 
<pre><code>const fs = require('fs')
const http = require('http')
const zlib = require('zlib')
const filepath = './index.html'

const server = http.createServer((req, res) =&gt; {
  const acceptEncoding = req.headers['accept-encoding']
  if (acceptEncoding.includes('gzip')) {
    const gzip = zlib.createGzip()
    res.writeHead(200, {
      'Content-Encoding': 'gzip'
    })
    fs.createReadStream(filepath)
      .pipe(gzip)
      .pipe(res)
  } else {
    fs.createReadStream(filepath).pipe(res)
  }
})

server.listen(4396)
</code></pre> 
<h3><a id="_dns__1867"></a>域名服务器 dns 模块</h3> 
<p>DNS（Domain Name System，域名系统），DNS 协议运行在 UDP 协议之上，使用端口号 53。DNS 是因特网上作为域名和 IP 地址相互映射的一个分布式数据库，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的 IP 数串。简单的说，就是把域名（网址）解析成对应的 IP 地址。Node.js 的 dns 模块，提供了 DNS 解析功能。当使用 dns 模块中的 net.connect(80, ‘github.com/webfansplz’)方法 或 http 模块的 http.get({ host: ‘github.com/webfansplz’ })方法时，在其底层会使用 dns 模块中的 dns.lookup 方法进行域名解析。</p> 
<h5><a id="1dns__1871"></a>1、dns 模块的两种域名解析方式</h5> 
<h6><a id="11_DNS__1873"></a>1.1、使用操作系统底层的 DNS 服务解析</h6> 
<p>使用操作系统底层的 DNS 服务进行域名解析时，不需要连接到网络仅使用系统自带 DNS 解析功能。这个功能由 dns.lookup()方法实现。</p> 
<p>dns.lookup(hostname[, options], callback)：将一个域名（如：‘www.baidu.com’）解析为第一个找到的 A 记录（IPv4）或 AAAA 记录（IPv6）</p> 
<p>hostname 表示要解析的域名。</p> 
<p>options 可以是一个对象或整数。如果没有提供 options 参数，则 IP v4 和 v6 地址都可以。如果 options 是整数，则必须是 4 或 6。如果 options 是对象时，会包含以下两个可选参数：</p> 
<ul><li>family：可选，IP 版本。如果提供，必须是 4 或 6。不提供则，IP v4 和 v6 地址都可以</li><li>hints：可选。如果提供，可以是一个或者多个 getaddrinfo 标志。若不提供，则没有标志会传给 getaddrinfo。</li></ul> 
<p>callback 回调函数，参数包含(err, address, family)。出错时，参数 err 是 Error 对象。address 参数表示 IP v4 或 v6 地址。family 参数是 4 或 6，表示 address 协议版本。</p> 
<pre><code>const dns = require('dns')

dns.lookup(`www.github.com`, (err, address, family) =&gt; {
  if (err) throw err
  console.log('地址: %j 地址族: IPv%s', address, family) // 地址: "13.229.188.59" 地址族: IPv4
})
</code></pre> 
<h6><a id="12_DNS__1897"></a>1.2、连接到 DNS 服务器解析域名</h6> 
<p>在 dns 模块中，除 dns.lookup()方法外都是使用 DNS 服务器进行域名解析，解析时需要连接到网络。</p> 
<p>dns.resolve(hostname[, rrtype], callback)：将一个域名（如 ‘www.baidu.com’）解析为一个 rrtype 指定类型的数组</p> 
<p>hostname 表示要解析的域名。</p> 
<p>rrtype 有以下可用值:</p> 
<table><thead><tr><th>rrtype</th><th>records 包含</th><th>结果的类型</th><th>快捷方法</th></tr></thead><tbody><tr><td>‘A’</td><td>IPv4 地址 (默认)</td><td>string</td><td>dns.resolve4()</td></tr><tr><td>‘AAAA’</td><td>IPv6 地址</td><td>string</td><td>dns.resolve6()</td></tr><tr><td>‘ANY’</td><td>任何记录</td><td>Object</td><td>dns.resolveAny()</td></tr><tr><td>‘CNAME’</td><td>规范名称记录</td><td>string</td><td>dns.resolveCname()</td></tr><tr><td>‘MX’</td><td>邮件交换记录</td><td>Object</td><td>dns.resolveMx()</td></tr><tr><td>‘NAPTR’</td><td>名称权限指针记录</td><td>Object</td><td>dns.resolveNaptr()</td></tr><tr><td>‘NS’</td><td>名称服务器记录</td><td>string</td><td>dns.resolveNs()</td></tr><tr><td>‘PTR’</td><td>指针记录</td><td>string</td><td>dns.resolvePtr()</td></tr><tr><td>‘SOA’</td><td>开始授权记录</td><td>Object</td><td>dns.resolveSoa()</td></tr><tr><td>‘SRV’</td><td>服务记录</td><td>Object</td><td>dns.resolveSrv()</td></tr><tr><td>‘TXT’</td><td>文本记录</td><td>string[]</td><td>dns.resolveTxt()</td></tr></tbody></table> 
<p>callback 回调函数，参数包含(err, addresses)。出错时，参数 err 是 Error 对象。addresses 根据记录类型的不同返回值也不同。</p> 
<pre><code>const dns = require('dns')

dns.resolve('www.baidu.com', 'A', (err, addresses) =&gt; {
  if (err) throw err
  console.log(`IP地址 : ${JSON.stringify(addresses)}`) // IP地址 : ["163.177.151.110","163.177.151.109"]
})

// or

dns.resolve4('www.baidu.com', (err, addresses) =&gt; {
  if (err) throw err
  console.log(`IP地址 : ${JSON.stringify(addresses)}`) // IP地址 : ["163.177.151.110","163.177.151.109"]
})
</code></pre> 
<h5><a id="2_DNS__1939"></a>2、反向 DNS 查询</h5> 
<h6><a id="21_IPv4__IPv6__1941"></a>2.1、将 IPv4 或 IPv6 地址解析为主机名数组。</h6> 
<p>使用 getnameinfo 方法将传入的地址和端口解析为域名和服务</p> 
<p>dns.reverse(ip, callback)</p> 
<p>ip 表示要反向解析的 IP 地址。</p> 
<p>callback 回调函数，参数包含(err, domains)。出错时，参数 err 是 Error 对象。domains 解析后的域名数组。</p> 
<pre><code>dns.reverse('8.8.8.8', (err, domains) =&gt; {
  if (err) throw err
  console.log(domains) // [ 'dns.google' ]
})
</code></pre> 
<p>dns.lookupService(address, port, callback)</p> 
<p>address 表示要解析的 IP 地址字符串。</p> 
<p>port 表示要解析的端口号。</p> 
<p>callback 回调函数，参数包含(err, hostname, service)。出错时，参数 err 是 Error 对象。</p> 
<pre><code>dns.lookupService('127.0.0.1', 80, function(err, hostname, service) {
  if (err) throw err
  console.log('主机名：%s，服务类型：%s', hostname, service) // 主机名：localhost，服务类型：http
})
</code></pre> 
<h2><a id="NPM_1977"></a>NPM常用命令</h2> 
<h2><a id="packagejson_1987"></a>package.json指南</h2> 
<h2><a id="Node_1993"></a>Node调试</h2> 
<h3><a id="_2003"></a>实战</h3> 
<h4><a id="_2005"></a>静态资源服务器</h4> 
<h5><a id="1_2007"></a>1、项目初始化</h5> 
<h6><a id="11gitignore_2009"></a>1.1、gitignore</h6> 
<p>忽略一些文件，使它不上传到git上面</p> 
<blockquote> 
 <p>规则：</p> 
 <ul><li>前面加/：表示项目根目录</li><li>后面加/：代表的是目录</li><li>前面加！：表示取反，也就是不忽略当前文件或者文件夹</li><li>*：表示任意字符</li><li>？：表示匹配任意字符</li><li>**：表示匹配多级目录</li></ul> 
</blockquote> 
<h6><a id="12npmignore_2022"></a>1.2、npmignore：</h6> 
<blockquote> 
 <p>在包发布时用于排除某些文件或目录。</p> 
 <p>比如我下载了一个名为 <code>cli-ux</code> 的npm包，这是一组常见的 CLI UX 工具函数。该项目的<a href="https://so.csdn.net/so/search?q=%E6%A0%B9%E7%9B%AE%E5%BD%95&amp;spm=1001.2101.3001.7020">根目录</a>下有一个名为 <code>/test</code> 的文件夹，里面放的是测试脚本。为了使这个npm包更小，我们可以不要这些文件。我可以创建一个 <a href="https://docs.npmjs.com/misc/developers#keeping-files-out-of-your-package" rel="nofollow">npmignore</a> 文件里面包含 <code>/test</code>，这样在运行 <code>npm publish</code> 打包时，可以避免将该文件夹打包到项目中。</p> 
</blockquote> 
<h6><a id="13editorConfig_2028"></a>1.3、editorConfig</h6> 
<h6><a id="14ESlint_2032"></a>1.4、ESlint</h6> 
<blockquote> 
 <p>说eslint之前先说一下git hooks</p> 
 <p>Git hooks是什么？</p> 
 <ul><li>有时我们想要在git操作时候进行一些定制化操作，比如在git <a href="https://so.csdn.net/so/search?q=commit&amp;spm=1001.2101.3001.7020">commit</a>时候检查一下提交内容是否合规、git push时候检查一下资源文件大小等等，这些功能需要我们可以在git命令执行前后进行拦截，git hooks提供了这样的能力</li></ul> 
 <p>每个通过git管理的项目，在.git/hooks/这个隐藏文件夹中，会提供一些默认的git hooks文件，比如pre-commit.sample pre-push.sample等。当我们执行git命令时，git会执行相应命令的相关文件，</p> 
 <ul><li>pre-commit在我们新增一个commit前</li><li>prepare-commit-msg在我们编辑一个commit的消息前调用</li><li>commit-msg在我们编辑完一个commit的消息后调用</li><li>pre-push在我们执行一次push操作前调用</li></ul> 
 <p>由于git默认并不会提供具体的hook操作，所以这些文件都是<code>.sample</code>类型的文件，不会自动执行，所以我们需要自己定义操作。(也可以用pre-commit插件https://pre-commit.com/)，安装的时候使用–save-dev，就会安装在devdepen</p> 
</blockquote> 
<pre><code class="prism language-js"><span class="token keyword">package</span><span class="token punctuation">.</span>json 
先安装npm install eslint <span class="token operator">--</span> global，然后使用eslint <span class="token operator">--</span>init初始化eslint<span class="token punctuation">,</span>然后安装pre<span class="token operator">-</span>commit<span class="token punctuation">,</span>在scripts里面新建一个命令lint，去eslint检验，然后在pre<span class="token operator">-</span>commit里面调用lint，就可以在commit之前校验eslit<span class="token punctuation">,</span>当然也可以在其他时机使用，也可以使用pre<span class="token operator">-</span>push插件
<span class="token punctuation">{<!-- --></span>
  <span class="token string-property property">"name"</span><span class="token operator">:</span> <span class="token string">"node"</span><span class="token punctuation">,</span>
  <span class="token string-property property">"version"</span><span class="token operator">:</span> <span class="token string">"1.0.0"</span><span class="token punctuation">,</span>
  <span class="token string-property property">"description"</span><span class="token operator">:</span> <span class="token string">"common JS     node 模块规范     🇺每一个文件就是一个模块，有自己的作用域"</span><span class="token punctuation">,</span>
  <span class="token string-property property">"main"</span><span class="token operator">:</span> <span class="token string">"index.js"</span><span class="token punctuation">,</span>
  <span class="token string-property property">"scripts"</span><span class="token operator">:</span> <span class="token punctuation">{<!-- --></span>
    <span class="token string-property property">"lint"</span><span class="token operator">:</span> <span class="token string">"eslint ."</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token string-property property">"pre-commit"</span><span class="token operator">:</span> <span class="token punctuation">[</span>
    <span class="token string">"lint"</span>
  <span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token string-property property">"devDependencies"</span><span class="token operator">:</span> <span class="token punctuation">{<!-- --></span>
    <span class="token string-property property">"pre-commit"</span><span class="token operator">:</span> <span class="token string">"^1.2.2"</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token string-property property">"author"</span><span class="token operator">:</span> <span class="token string">""</span><span class="token punctuation">,</span>
  <span class="token string-property property">"license"</span><span class="token operator">:</span> <span class="token string">"ISC"</span>
<span class="token punctuation">}</span>
</code></pre> 
<h6><a id="http_2073"></a>http</h6> 
<p>静态资源服务器本质上就是http 客户端发起http请求，服务器给http进行相应。<br> Supervisor 插件 每次修改不需要重新启动node 借助Supervisor</p> 
<blockquote> 
 <p>实现静态资源服务器 运行当前进程node 获取到当前文件夹下所有目录 通过访问对应的文件，获得对应文件的内容或者是文件夹列表</p> 
</blockquote> 
<pre><code class="prism language-js"><span class="token comment">// 简易版</span>
<span class="token keyword">const</span> http <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'http'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> chalk <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'chalk'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> path <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'path'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> fs <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'fs'</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> port <span class="token operator">=</span> <span class="token number">3000</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> hostname <span class="token operator">=</span> <span class="token string">'127.0.0.1'</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> nowdir <span class="token operator">=</span> process<span class="token punctuation">.</span><span class="token function">cwd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 获取当前进程工作目录</span>

<span class="token keyword">const</span> server <span class="token operator">=</span> http<span class="token punctuation">.</span><span class="token function">createServer</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span> res</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> filePath <span class="token operator">=</span> path<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span>nowdir<span class="token punctuation">,</span> req<span class="token punctuation">.</span>url<span class="token punctuation">)</span><span class="token punctuation">;</span>
    fs<span class="token punctuation">.</span><span class="token function">stat</span><span class="token punctuation">(</span>filePath<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">err<span class="token punctuation">,</span> stats</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            res<span class="token punctuation">.</span>statusCode <span class="token operator">=</span> <span class="token number">404</span><span class="token punctuation">;</span>
            res<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">'Content-Type'</span><span class="token punctuation">,</span> <span class="token string">'text/plain'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${<!-- --></span>filePath<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> is not have</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 如果是文件的话  </span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>stats<span class="token punctuation">.</span><span class="token function">isFile</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            res<span class="token punctuation">.</span>statusCode <span class="token operator">=</span> <span class="token number">200</span><span class="token punctuation">;</span>
            res<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">'Content-Type'</span><span class="token punctuation">,</span> <span class="token string">'text/plain'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token comment">// 读取文件   通过流的形式一点点吐给客户端</span>
            fs<span class="token punctuation">.</span><span class="token function">createReadStream</span><span class="token punctuation">(</span>filePath<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 这一步读取 也可以用readfile去进行读取 但是这个是所有的读取完了之后才会传给客户端,不建议使用</span>
            <span class="token comment">// fs.readFile(filePath, (err, data) =&gt; {<!-- --></span>
            <span class="token comment">//     res.end(data);</span>
            <span class="token comment">// })</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>stats<span class="token punctuation">.</span><span class="token function">isDirectory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            fs<span class="token punctuation">.</span><span class="token function">readdir</span><span class="token punctuation">(</span>filePath<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">err<span class="token punctuation">,</span> files</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
                res<span class="token punctuation">.</span>statusCode <span class="token operator">=</span> <span class="token number">200</span><span class="token punctuation">;</span>
                res<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">'Content-Type'</span><span class="token punctuation">,</span> <span class="token string">'text/plain'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span>files<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">','</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token punctuation">}</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
server<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span>port<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">const</span> str <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">http://</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${<!-- --></span>hostname<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">:</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${<!-- --></span>port<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">/</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">服务器运行在 </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${<!-- --></span>chalk<span class="token punctuation">.</span><span class="token function">green</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> 
<pre><code class="prism language-js"><span class="token comment">// 不使用回调函数，使用异步的方式</span>
<span class="token keyword">const</span> http <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'http'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> chalk <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'chalk'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> path <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'path'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> fs <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'fs'</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> promisify <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'util'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>promisify<span class="token punctuation">;</span>
<span class="token keyword">const</span> stat <span class="token operator">=</span> <span class="token function">promisify</span><span class="token punctuation">(</span>fs<span class="token punctuation">.</span>stat<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> readdir <span class="token operator">=</span> <span class="token function">promisify</span><span class="token punctuation">(</span>fs<span class="token punctuation">.</span>readdir<span class="token punctuation">)</span>
<span class="token keyword">const</span> port <span class="token operator">=</span> <span class="token number">3000</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> hostname <span class="token operator">=</span> <span class="token string">'127.0.0.1'</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> nowdir <span class="token operator">=</span> process<span class="token punctuation">.</span><span class="token function">cwd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 获取当前进程工作目录</span>

<span class="token keyword">const</span> <span class="token function-variable function">handleRes</span> <span class="token operator">=</span> <span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span> res</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">const</span> filePath <span class="token operator">=</span> path<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span>nowdir<span class="token punctuation">,</span> req<span class="token punctuation">.</span>url<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">const</span> stats <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">stat</span><span class="token punctuation">(</span>filePath<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>stats<span class="token punctuation">.</span><span class="token function">isFile</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            res<span class="token punctuation">.</span>statusCode <span class="token operator">=</span> <span class="token number">200</span><span class="token punctuation">;</span>
            res<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">'Content-Type'</span><span class="token punctuation">,</span> <span class="token string">'text/plain'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token comment">// 读取文件   通过流的形式一点点吐给客户端</span>
            fs<span class="token punctuation">.</span><span class="token function">createReadStream</span><span class="token punctuation">(</span>filePath<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 这一步读取 也可以用readfile去进行读取 但是这个是所有的读取完了之后才会传给客户端,不建议使用</span>
            <span class="token comment">// fs.readFile(filePath, (err, data) =&gt; {<!-- --></span>
            <span class="token comment">//     res.end(data);</span>
            <span class="token comment">// })</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>stats<span class="token punctuation">.</span><span class="token function">isDirectory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">const</span> files <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">readdir</span><span class="token punctuation">(</span>filePath<span class="token punctuation">)</span><span class="token punctuation">;</span>
            res<span class="token punctuation">.</span>statusCode <span class="token operator">=</span> <span class="token number">200</span><span class="token punctuation">;</span>
            res<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">'Content-Type'</span><span class="token punctuation">,</span> <span class="token string">'text/plain'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span>files<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">'\n'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        res<span class="token punctuation">.</span>statusCode <span class="token operator">=</span> <span class="token number">404</span><span class="token punctuation">;</span>
        res<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">'Content-Type'</span><span class="token punctuation">,</span> <span class="token string">'text/plain'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${<!-- --></span>filePath<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> is not have</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> server <span class="token operator">=</span> http<span class="token punctuation">.</span><span class="token function">createServer</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span> res</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">handleRes</span><span class="token punctuation">(</span>req<span class="token punctuation">,</span> res<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

server<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span>port<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">const</span> str <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">http://</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${<!-- --></span>hostname<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">:</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${<!-- --></span>port<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">/</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">服务器运行在 </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${<!-- --></span>chalk<span class="token punctuation">.</span><span class="token function">green</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> 
<h6><a id="16node_2180"></a>1.6、node模版引擎</h6> 
<p>EJS<br> <a href="http://ejs.co/" rel="nofollow">http://ejs.co/</a><br> EJS是CanJS默认的模板语言，它提供了与Observes的实时绑定的使用。EJS非常易于使用，在模板中写入想要的HTML，以及一些表示动态行为的魔法标签即可。JES不支持block功能。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9dfa085a0366e057d87bd3b8245d11a7/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">图论—欧拉路径（只是笔记）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3df15a34f11891ff1144b2873d96930a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">C/C&#43;&#43; with return value 3221225477</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>