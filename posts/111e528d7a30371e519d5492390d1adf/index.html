<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>docker 实现JMeter分布式压测 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="docker 实现JMeter分布式压测" />
<meta property="og:description" content="前言 为什么需要分布式？ 在工作中经常需要对一些关键接口做高QPS的压测，JMeter是由Java 语言开发，没创建一个线程（虚拟用户），JVM默认会为每个线程分配1M的堆栈内存空间。受限于单台试压机的配置很难实现太高的并发。所以，通过JMeter实现分布式，可以整合多台主机的硬件资源，实现同时对被测试接口进行压力测试。
Jmeter分布式测试环境中有两个角色：Master 和 Slaves
Master节点：向参与的Slaves节点发送测试脚本，并聚合Agent节点的执行结果。
Slaves节点：接收并执行Master节点发送过来的测试脚本，并将执行结果返回给Master。
为什么要使用docker? 如果要分布式联动每台主机，就要求每台主机都要有JMeter环境（JDK &#43; JMeter），如果利用docker就可以通过docker管理 JMeter环境，简单的拉取镜像，启动容器即可。进一步讲，利用k8s、云服务可以无限的扩容JMeter试压机，理论上多少的并发用户都可以模拟。
准备工作 JDK：启动 JMeter 工具需要 $ brew install openjdk@11 JMeter: 编写JMeter脚本 https://archive.apache.org/dist/jmeter/binaries/
编写一个简单的脚本。
docker: 通过doker创建容器。 $ docker pull runcare/jmeter-master $ docker pull runcare/jmeter-slave 查看docker镜像 $ docker images REPOSITORY TAG IMAGE ID CREATED SIZE runcare/jmeter-master latest e052a8cd8680 3 years ago 326MB runcare/jmeter-slave latest 05c7ba96d97d 3 years ago 326MB 请记住 jmeter-master 的镜像ID e052a8cd8680，后面会用到。
分布式压测使用 启动 slave 节点。 假设有两台主机，可以启动两个slave。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/111e528d7a30371e519d5492390d1adf/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-17T13:08:56+08:00" />
<meta property="article:modified_time" content="2024-01-17T13:08:56+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">docker 实现JMeter分布式压测</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2><img alt="" src="https://images2.imgbox.com/25/c9/VSCYyA8S_o.png"></h2> 
<h2 style="text-align:center;"></h2> 
<h2 style="text-align:center;"></h2> 
<h2 style="text-align:center;">前言</h2> 
<h4></h4> 
<h4 id="为什么需要分布式">为什么需要分布式？</h4> 
<p>在工作中经常需要对一些关键接口做高QPS的压测，JMeter是由Java 语言开发，没创建一个线程（虚拟用户），JVM默认会为每个线程分配1M的堆栈内存空间。受限于单台试压机的配置很难实现太高的并发。所以，通过JMeter实现分布式，可以整合多台主机的硬件资源，实现同时对被测试接口进行压力测试。</p> 
<p></p> 
<p class="img-center"><img alt="" height="1200" src="https://images2.imgbox.com/7f/4c/88Q0m5Ls_o.png" width="1200"></p> 
<p>Jmeter分布式测试环境中有两个角色：Master 和 Slaves</p> 
<ul><li> <p>Master节点：向参与的Slaves节点发送测试脚本，并聚合Agent节点的执行结果。</p> </li><li> <p>Slaves节点：接收并执行Master节点发送过来的测试脚本，并将执行结果返回给Master。</p> </li></ul> 
<h4 id="为什么要使用docker">为什么要使用docker?</h4> 
<p>如果要分布式联动每台主机，就要求每台主机都要有JMeter环境（JDK + JMeter），如果利用docker就可以通过docker管理 JMeter环境，简单的拉取镜像，启动容器即可。进一步讲，利用k8s、云服务可以无限的扩容JMeter试压机，理论上多少的并发用户都可以模拟。</p> 
<h4 id="准备工作">准备工作</h4> 
<ul><li>JDK：启动 JMeter 工具需要</li></ul> 
<pre><code>$ brew install openjdk@11
</code></pre> 
<ul><li>JMeter: 编写JMeter脚本</li></ul> 
<p><a href="https://archive.apache.org/dist/jmeter/binaries/" rel="nofollow" title="https://archive.apache.org/dist/jmeter/binaries/">https://archive.apache.org/dist/jmeter/binaries/</a></p> 
<p> </p> 
<p>编写一个简单的脚本。</p> 
<p class="img-center"><img alt="" height="1200" src="https://images2.imgbox.com/4a/ac/0Ib7DuxW_o.png" width="1200"></p> 
<ul><li>docker: 通过doker创建容器。</li></ul> 
<pre><code>$ docker pull runcare/jmeter-master
$ docker pull runcare/jmeter-slave
</code></pre> 
<ul><li>查看docker镜像</li></ul> 
<pre><code>$ docker images

REPOSITORY              TAG        IMAGE ID       CREATED         SIZE
runcare/jmeter-master   latest     e052a8cd8680   3 years ago     326MB
runcare/jmeter-slave    latest     05c7ba96d97d   3 years ago     326MB
</code></pre> 
<p>请记住 jmeter-master 的镜像ID <code>e052a8cd8680</code>，后面会用到。</p> 
<h4 id="分布式压测使用">分布式压测使用</h4> 
<ul><li>启动 slave 节点。</li></ul> 
<p>假设有两台主机，可以启动两个slave。</p> 
<pre><code>$ docker run -it -d --name slave01 runcare/jmeter-slave
$ docker run -it -d --name slave02 runcare/jmeter-slave
</code></pre> 
<ul><li>查看启动的容器</li></ul> 
<pre><code>$ docker ps

CONTAINER ID   IMAGE                  COMMAND                   CREATED             STATUS             PORTS                 NAMES
b270636a7741   runcare/jmeter-slave   "/bin/sh -c 'jmeter-…"   43 seconds ago      Up 42 seconds      1099/tcp, 60001/tcp   slave01
2584c7fef5f8   runcare/jmeter-slave   "/bin/sh -c 'jmeter-…"   52 seconds ago      Up 50 seconds      1099/tcp, 60001/tcp   slave02
</code></pre> 
<ul><li>查看两个slave 的IP 地址</li></ul> 
<pre><code>$ docker inspect -f '{<!-- -->{ .Name }} =&gt; {<!-- -->{ .NetworkSettings.IPAddress }}' $(docker ps -q)

/slave01 =&gt; 172.17.0.3
/slave02 =&gt; 172.17.0.2
/k8s_nginx_nginx-deployment1-fc7586d97-jvjvk_nginx_4379ed7f-b0be-4f9f-a0a9-4a5fd7b45b38_1 =&gt; 
/k8s_nginx_nginx-deployment1-fc7586d97-bztbh_nginx_6968e6b1-6689-4f1a-a9ea-04532577841c_1 =&gt; 
</code></pre> 
<ul><li>发送压测脚本到 slave</li></ul> 
<pre><code>$ result=`date +"%Y%m%d%H%M%S"` &amp;&amp; docker run --rm -v /Users/fnngj/zhpro/script:/data e052a8cd8680 jmeter -n -t /data/baidu_script.jmx -l /data/$result.jtl -j /data/$result.log -e -o /data/$result -R 172.17.0.2,172.17.0.3
</code></pre> 
<p><strong>参数说明</strong></p> 
<p><code>result=</code>date +"%Y%m%d%H%M%S"`: 指定测试结果的名称，以当前日期时间命名。</p> 
<p><code>/Users/fnngj/zhpro/script</code> : 压测脚本的目录，测试结果也会存放到该目录下。</p> 
<p><code>baidu_script.jmx</code> : 压测脚本的名称，存放于 <code>/Users/fnngj/zhpro/script</code>目录下。</p> 
<p><code>e052a8cd8680</code> : jmeter-master 的镜像ID。</p> 
<p><code>172.17.0.2,172.17.0.3</code> ： 两台 slave 的IP 地址。</p> 
<h4 id="测试结果">测试结果</h4> 
<ul><li>执行完的目录</li></ul> 
<pre><code>$ pwd
/Users/fnngj/zhpro/script

$ ls
20230707005328     20230707005328.jtl 20230707005328.log baidu_script.jmx
</code></pre> 
<ul><li>查看报告</li></ul> 
<p>进入<code>20230707005328</code> 目录，点击 index.html 文件，可以看到压测的结果。</p> 
<p class="img-center"><img alt="" height="1200" src="https://images2.imgbox.com/5b/14/KcAlZhOq_o.png" width="1200"></p> 
<p></p> 
<p> </p> 
<p></p> 
<p style="text-align:center;"> <img alt="" src="https://images2.imgbox.com/e9/e6/YneAlSve_o.gif"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f573d8b659fea7aa3ebbe1644f06484d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">What is `HttpServletRequestWrapper` does?</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1bef6cfcb2683d109b7d836ebd9396df/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Docker 操作之数据卷挂载【云原生】</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>