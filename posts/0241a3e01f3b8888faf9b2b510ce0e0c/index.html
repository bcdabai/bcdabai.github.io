<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>MVC、MVP、MVVM之间的简介与区别 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="MVC、MVP、MVVM之间的简介与区别" />
<meta property="og:description" content="区别：MVC表示“模型-视图-控制器”，MVP表示“模型-视图-演示者”，MVVM表示“模型-视图-视图模型”；MVP、MVVM都是由MVC衍生出的。MVC中，View会直接从Model中读取数据；MVP中，View并不直接使用Model。
再次重复一下：
MVC、MVP和MVVM是三种流行的设计模式。其中，MVC表示模型-视图-控制器，MVP表示模型-视图-演示者，MVVM表示模型-视图-视图模型；MVP, MVVM都是由MVC衍生出。所有这些设计模式大体上都有助于开发松散组合、易于测试和维护的应用程序。
一、MVC（Model-View-Controller） MVC是非常直观的架构模式，最初衍生于服务器端的Web开发，后来渐渐能够胜任客户端Web开发，能够满足其复杂性和丰富性。
MVC模式将应用程序划分为三个部分： ●　Model: 模型（用于封装与应用程序的业务逻辑相关的数据以及对数据的处理方法）
●　View: 视图（渲染页面）
●　Controller: 控制器（M和V之间的连接器，用于控制应用程序的流程，及页面的业务逻辑）
MVC特点： MVC模式的特点在于实现关注点分离，即应用程序中的数据模型与业务和展示逻辑解耦。在客户端web开发中，就是将模型(M-数据、操作数据)、视图(V-显示数据的HTML元素)之间实现代码分离，松散耦合，使之成为一个更容易开发、维护和测试的客户端应用程序。
用户操作-&gt;View（负责接收用户的输入操作）-&gt;Controller（业务逻辑处理）-&gt;Model（数据持久化）-&gt;View（将结果反馈给View）：
1、View 传送指令到 Controller ；
2、Controller 完成业务逻辑后，要求 Model 改变状态 ；
3、Model 将新的数据发送到 View，用户得到反馈。
二、MVP（Model-View-Presenter） MVP是把MVC中的Controller换成了Presenter（呈现），目的就是为了完全切断View跟Model之间的联系，由Presenter充当桥梁，做到View-Model之间通信的完全隔离方向。
MVP特点： ●　M、V、P之间双向通信。
●　View 与 Model之间不通信，都通过 Presenter 传递。Presenter完全把Model和View进行了分离，主要的程序逻辑在Presenter里实现。
●　View 非常薄，不部署任何业务逻辑，称为”被动视图”（Passive View），即没有任何主动性，而 Presenter非常厚，所有逻辑都部署在那里。
●　Presenter与具体的View是没有直接关联的，而是通过定义好的接口进行交互，从而使得在变更View时候可以保持Presenter的不变，这样就可以重用。不仅如此，还可以编写测试用的View，模拟用户的各种操作，从而实现对Presenter的测试–从而不需要使用自动化的测试工具。
三、MVVM（Model-View-ViewModel） MVVM 模式将 Presenter 改名为 ViewModel，基本上与 MVP 模式完全一致。如果说MVP是对MVC的进一步改进，那么MVVM则是思想的完全变革。它是将“数据模型数据双向绑定”的思想作为核心，因此在View和Model之间没有联系，通过ViewModel进行交互，而且Model和ViewModel之间的交互是双向的，因此视图的数据的变化会同时修改数据源，而数据源数据的变化也会立即反应到View上。
区别说明： MVC中View会直接从Model中读取数据而不是通过 Controller；View和 Controller之间存在多对一关系。
MVP中View并不直接使用Model，它们之间的通信是通过Presenter (MVC中的Controller)来进行的，所有的交互都发生在Presenter内部；View和Presenter之间是一对一关系。
MVVM 模式基本上与 MVP 模式完全一致，唯一的区别是：MVVM采用双向绑定（data-binding）：View的变动，自动反映在 ViewModel，反之亦然。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/0241a3e01f3b8888faf9b2b510ce0e0c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-06-15T11:49:23+08:00" />
<meta property="article:modified_time" content="2022-06-15T11:49:23+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">MVC、MVP、MVVM之间的简介与区别</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p>区别：<span style="color:#79c6cd;"><strong>MVC</strong></span>表示“<strong>模型</strong>-<strong>视图</strong>-<strong>控制器</strong>”，<span style="color:#ed7976;"><strong>MVP</strong></span>表示“<strong>模型</strong>-<strong>视图</strong>-<strong>演示者</strong>”，<span style="color:#faa572;"><strong>MVVM</strong></span>表示“<strong>模型</strong>-<strong>视图</strong>-<strong>视图模型</strong>”；<span style="color:#ed7976;"><strong>MVP</strong></span>、<span style="color:#faa572;"><strong>MVVM</strong></span>都是由<span style="color:#1c7331;"><strong>MVC衍生</strong></span>出的。MVC中，View会直接从Model中读取数据；MVP中，View并不直接使用Model。</p> 
</blockquote> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/ea/84/lTALA3HL_o.png"></p> 
<p> 再次重复一下：</p> 
<p>MVC、MVP和MVVM是三种流行的设计模式。其中，<strong><span style="color:#1c7331;">MVC</span></strong>表示<strong>模型-视图-控制器</strong>，<strong><span style="color:#ed7976;">MVP</span></strong>表示<strong>模型-视图-演示者</strong>，<strong><span style="color:#faa572;">MVVM</span></strong>表示模型-视图-视图模型；MVP, MVVM都是由MVC衍生出。所有这些设计模式大体上都有助于开发松散组合、易于测试和维护的应用程序。</p> 
<h2><strong>一、<span style="color:#1c7331;">MVC</span>（Model-View-Controller）</strong></h2> 
<p>MVC是非常直观的架构模式，最初衍生于服务器端的Web开发，后来渐渐能够胜任客户端Web开发，能够满足其复杂性和丰富性。</p> 
<p class="img-center"><img alt="" height="284" src="https://images2.imgbox.com/4f/99/ytUFtcqp_o.png" width="535"></p> 
<h4><span style="color:#1c7331;"><span style="background-color:#f3f3f4;">MVC</span></span>模式将应用程序划分为三个部分：</h4> 
<p>　●　Model: 模型（用于封装与应用程序的业务逻辑相关的数据以及对数据的处理方法）</p> 
<p>　●　View: 视图（渲染页面）</p> 
<p>　●　Controller: 控制器（M和V之间的连接器，用于控制应用程序的流程，及页面的业务逻辑）</p> 
<h4><strong><span style="color:#1c7331;"><span style="background-color:#f3f3f4;">MVC</span></span>特点：</strong></h4> 
<p>MVC模式的特点在于实现关注点分离，即应用程序中的数据模型与业务和展示逻辑解耦。在客户端web开发中，就是将模型(M-数据、操作数据)、视图(V-显示数据的HTML元素)之间实现代码分离，松散耦合，使之成为一个更容易开发、维护和测试的客户端应用程序。</p> 
<p>用户操作-&gt;View（负责接收用户的输入操作）-&gt;Controller（业务逻辑处理）-&gt;Model（数据持久化）-&gt;View（将结果反馈给View）：</p> 
<p>　1、View 传送指令到 Controller ；</p> 
<p>　2、Controller 完成业务逻辑后，要求 Model 改变状态 ；</p> 
<p>　3、Model 将新的数据发送到 View，用户得到反馈。</p> 
<h2> <strong>二、<span style="color:#ed7976;">MVP</span>（Model-View-Presenter）</strong></h2> 
<p>MVP是把MVC中的Controller换成了Presenter（呈现），目的就是为了完全切断View跟Model之间的联系，由Presenter充当桥梁，做到View-Model之间通信的完全隔离方向。</p> 
<p class="img-center"><img alt="" height="310" src="https://images2.imgbox.com/5b/94/ItYQRgAE_o.png" width="515"></p> 
<h4><strong>MVP特点：</strong></h4> 
<p>　●　M、V、P之间双向通信。</p> 
<p>　●　View 与 Model之间不通信，都通过 Presenter 传递。Presenter完全把Model和View进行了分离，主要的程序逻辑在Presenter里实现。</p> 
<p>　●　View 非常薄，不部署任何业务逻辑，称为”被动视图”（Passive View），即没有任何主动性，而 Presenter非常厚，所有逻辑都部署在那里。</p> 
<p>　●　Presenter与具体的View是没有直接关联的，而是通过定义好的接口进行交互，从而使得在变更View时候可以保持Presenter的不变，这样就可以重用。不仅如此，还可以编写测试用的View，模拟用户的各种操作，从而实现对Presenter的测试–从而不需要使用自动化的测试工具。</p> 
<h2> <strong>三、<span style="color:#e6b223;">MVVM</span>（Model-View-ViewModel）</strong></h2> 
<p> MVVM 模式将 Presenter 改名为 ViewModel，基本上与 MVP 模式完全一致。如果说MVP是对MVC的进一步改进，那么MVVM则是思想的完全变革。它是将“数据模型数据双向绑定”的思想作为核心，因此在View和Model之间没有联系，通过ViewModel进行交互，而且Model和ViewModel之间的交互是双向的，因此视图的数据的变化会同时修改数据源，而数据源数据的变化也会立即反应到View上。</p> 
<p class="img-center"><img alt="" height="330" src="https://images2.imgbox.com/e6/0a/sMDg1oAO_o.png" width="537"></p> 
<h2><strong>区别说明：</strong></h2> 
<p><strong><span style="color:#1c7331;">MVC</span></strong>中View会直接从Model中读取数据而不是通过 Controller；View和 Controller之间存在多对一关系。</p> 
<p><span style="color:#ed7976;"><strong>MVP</strong></span>中View并不直接使用Model，它们之间的通信是通过Presenter (MVC中的Controller)来进行的，所有的交互都发生在Presenter内部；View和Presenter之间是一对一关系。</p> 
<p><strong><span style="color:#e6b223;">MVVM</span> </strong>模式基本上与 MVP 模式完全一致，唯一的区别是：MVVM采用双向绑定（data-binding）：View的变动，自动反映在 ViewModel，反之亦然。</p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3950ba24e96bc820d087aa35efcb38b5/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">java String字符串相关的方法（可总结到工具类中）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/70d6d0ade59656de07c4d8c8c36cdcac/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">PETR：Transformer不甘落后，也能端到端地估计姿态，达到SOTA性能#CVPR2022 Oral#</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>