<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【Spring源码解读】BeanFactory和FactoryBean区别及类装载源码解读 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【Spring源码解读】BeanFactory和FactoryBean区别及类装载源码解读" />
<meta property="og:description" content="最近读代码读到Bean装载过程,顺带上网搜了下BeanFactory和FactoryBean,发现好多文章都讲的不清不楚,特此自己来整理了一份BeanFactory和FactoryBean的区别及讲下bean的装载和读取过程的源码.
首先来看下BeanFactory和FactoryBean,借着例子作为入口来进行后面的源码分析.BeanFactory和FactoryBean的定义:
public interface FactoryBean&lt;T&gt; { T getObject() throws Exception; Class&lt;?&gt; getObjectType(); boolean isSingleton(); } public interface BeanFactory { String FACTORY_BEAN_PREFIX = &#34;&amp;&#34;;//此属性后面会讲到 Object getBean(String name) throws BeansException; &lt;T&gt; T getBean(String name, Class&lt;T&gt; requiredType) throws BeansException; &lt;T&gt; T getBean(Class&lt;T&gt; requiredType) throws BeansException; Object getBean(String name, Object... args) throws BeansException; &lt;T&gt; T getBean(Class&lt;T&gt; requiredType, Object... args) throws BeansException; boolean containsBean(String name); boolean isSingleton(String name) throws NoSuchBeanDefinitionException; boolean isPrototype(String name) throws NoSuchBeanDefinitionException; boolean isTypeMatch(String name, ResolvableType typeToMatch) throws NoSuchBeanDefinitionException; boolean isTypeMatch(String name, Class&lt;?" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/799503f088aced1aa13761ece1145900/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2017-03-09T20:23:46+08:00" />
<meta property="article:modified_time" content="2017-03-09T20:23:46+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【Spring源码解读】BeanFactory和FactoryBean区别及类装载源码解读</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-github-gist">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <blockquote> 
 <p>最近读代码读到Bean装载过程,顺带上网搜了下BeanFactory和FactoryBean,发现好多文章都讲的不清不楚,特此自己来整理了一份BeanFactory和FactoryBean的区别及讲下bean的装载和读取过程的源码.</p> 
</blockquote> 
<p>    首先来看下BeanFactory和FactoryBean,借着例子作为入口来进行后面的源码分析.BeanFactory和FactoryBean的定义:</p> 
<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">FactoryBean</span>&lt;<span class="hljs-title">T</span>&gt; {<!-- --></span>
    T getObject() <span class="hljs-keyword">throws</span> Exception;
    Class&lt;?&gt; getObjectType();
    <span class="hljs-keyword">boolean</span> isSingleton();
}

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">BeanFactory</span> {<!-- --></span>
    String FACTORY_BEAN_PREFIX = <span class="hljs-string">"&amp;"</span>;<span class="hljs-comment">//此属性后面会讲到</span>
    Object getBean(String name) <span class="hljs-keyword">throws</span> BeansException;
    &lt;T&gt; T getBean(String name, Class&lt;T&gt; requiredType) <span class="hljs-keyword">throws</span> BeansException;
    &lt;T&gt; T getBean(Class&lt;T&gt; requiredType) <span class="hljs-keyword">throws</span> BeansException;
    Object getBean(String name, Object... args) <span class="hljs-keyword">throws</span> BeansException;
    &lt;T&gt; T getBean(Class&lt;T&gt; requiredType, Object... args) <span class="hljs-keyword">throws</span> BeansException;
    <span class="hljs-keyword">boolean</span> containsBean(String name);
    <span class="hljs-keyword">boolean</span> isSingleton(String name) <span class="hljs-keyword">throws</span> NoSuchBeanDefinitionException;
    <span class="hljs-keyword">boolean</span> isPrototype(String name) <span class="hljs-keyword">throws</span> NoSuchBeanDefinitionException;
    <span class="hljs-keyword">boolean</span> isTypeMatch(String name, ResolvableType typeToMatch) <span class="hljs-keyword">throws</span> NoSuchBeanDefinitionException;
    <span class="hljs-keyword">boolean</span> isTypeMatch(String name, Class&lt;?&gt; typeToMatch) <span class="hljs-keyword">throws</span> NoSuchBeanDefinitionException;
    Class&lt;?&gt; getType(String name) <span class="hljs-keyword">throws</span> NoSuchBeanDefinitionException;
    String[] getAliases(String name);
}</code></pre> 
<p>    可以看到,二者的定义还比较相似,这里先直接说用法,实现<code>FactoryBean</code>的类,在初始入容器后,通过<code>BeanFactory</code>的getBean方法调用时,会调用<code>FactoryBean</code>的getObject方法返回对应的类,而不是像普通的bean一样直接返回bean实例.BeanFactory的常量&amp;的作用是在获取bean的时候直接返回FactoryBean的实例,而不是调用器的getObject方法返回对应的类,后面会有源码分析.</p> 
<p>    首先来看一个例子:</p> 
<p>    首先是具体对象:</p> 
<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ICar</span> {<!-- --></span>
    <span class="hljs-keyword">void</span> automaker();
}
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Benz</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ICar</span> {<!-- --></span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">automaker</span>() {
        System.out.println(<span class="hljs-string">"I'm Benz"</span>);
    }
}
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VOLVO</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ICar</span> {<!-- --></span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">automaker</span>() {
        System.out.println(<span class="hljs-string">"I'm VOLVO"</span>);
    }
}</code></pre> 
<p>    这里就是定义对象,不多讲,下面在applicationContext.xml中新增配置:</p> 
<pre class="prettyprint"><code class="language-java hljs ">&lt;bean id=<span class="hljs-string">"carFactoryBean"</span> class=<span class="hljs-string">"org.white.test.web.test.CarFactoryBean"</span> P:carEnum=<span class="hljs-string">"BENZ"</span>&gt;&lt;/bean&gt;</code></pre> 
<p>    下面来看测试代码:</p> 
<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CarFactoryBeanTest</span> {<!-- --></span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ApplicationContext CONTEXT = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(
        <span class="hljs-string">"/META-INF/applicationContext.xml"</span>);
    <span class="hljs-annotation">@Test</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testFactoryBean</span>() <span class="hljs-keyword">throws</span> Exception {
        ICar car = (ICar) CONTEXT.getBean(<span class="hljs-string">"carFactoryBean"</span>);
        car.automaker();
        CarFactoryBean carFactoryBean = (CarFactoryBean) CONTEXT.getBean(<span class="hljs-string">"&amp;carFactoryBean"</span>);
        carFactoryBean.getObject();
    }
}</code></pre> 
<p>    运行结果:</p> 
<pre class="prettyprint"><code class="language-java hljs ">I<span class="hljs-string">'m Benz
class org.white.test.web.test.CarFactoryBean</span></code></pre> 
<p>    通过例子可以看到结果就如上面所说.老子说,知其然并要知其所以然.下面我们就来通读源码分析下bean的装载和读取.首先来看类图:</p> 
<p><img src="https://images2.imgbox.com/3a/77/rJgFATif_o.png" alt="Spring装载Bean类图" title=""></p> 
<p>    这里只讲部分核心代码,其他过程就省略掉了,我们直接来看<code>DefaultBeanDefinitionDocumentReader</code>,此类实现自<code>BeanDefinitionDocumentReader</code>,负责从传入的Element中解析出bean.Element的加载过程此处就不过多分析了,读者可以看上面类图,<code>PathMatchingResourcePatternResolver</code>负责根据我们传入的xml路径解析为Resource,之后由<code>DefaultDocumentLoader</code>获取Document,读者可以找代码看看.</p> 
<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-comment">//根据解析到的Element解析并注册具体bean</span>
<span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">parseBeanDefinitions</span>(Element root, BeanDefinitionParserDelegate delegate) {
    <span class="hljs-keyword">if</span> (delegate.isDefaultNamespace(root)) {
        NodeList nl = root.getChildNodes();
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nl.getLength(); i++) {
            Node node = nl.item(i);
            <span class="hljs-keyword">if</span> (node <span class="hljs-keyword">instanceof</span> Element) {
                Element ele = (Element) node;
                <span class="hljs-keyword">if</span> (delegate.isDefaultNamespace(ele)) {
                    <span class="hljs-comment">//解析默认标签</span>
                    parseDefaultElement(ele, delegate);
                }
                <span class="hljs-keyword">else</span> {
                    <span class="hljs-comment">//解析自定义标签</span>
                    delegate.parseCustomElement(ele);
                }
            }
        }
    }
    <span class="hljs-keyword">else</span> {
        delegate.parseCustomElement(root);
    }
}</code></pre> 
<p>    上述代码中的parseCustomElement()方法是解析自定义标签,比如我们配置中的标签,就是spring扩展的自定义标签,会根据它的namespace即<a href="http://www.springframework.org/schema/context" rel="nofollow">http://www.springframework.org/schema/context</a>获取对应的处理器处理,这个今天就不展开了,留着下次专门写一篇自定义标签的文章详细给大家分析.</p> 
<p>    下面来看该类的另一个方法:</p> 
<pre class="prettyprint"><code class="language-java hljs ">这里根据ele的不同类型做不同处理
<span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">parseDefaultElement</span>(Element ele, BeanDefinitionParserDelegate delegate) {
    <span class="hljs-comment">//解析&lt;import /&gt;属性并加载导入的xml里的bean</span>
    <span class="hljs-keyword">if</span> (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) {
        importBeanDefinitionResource(ele);
    }
    <span class="hljs-comment">//注册bean别名</span>
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) {
        processAliasRegistration(ele);
    }
    <span class="hljs-comment">//注册具体bean</span>
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) {
        processBeanDefinition(ele, delegate);
    }
    <span class="hljs-comment">//注册beans</span>
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) {
        <span class="hljs-comment">// recurse</span>
        doRegisterBeanDefinitions(ele);
    }
}</code></pre> 
<p>    上面的方法解析出bean后要放入容器中,下面就是最核心的容器类<code>DefaultListableBeanFactory</code></p> 
<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-comment">//bean容器,xml中的bean解析后会放入这里</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, BeanDefinition&gt; beanDefinitionMap = <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;String, BeanDefinition&gt;(<span class="hljs-number">256</span>);

<span class="hljs-comment">//方法代码很多,其实很简单,就是将bean放入容器中</span>
<span class="hljs-comment">//实现自BeanDefinitionRegistry,注册具体bean,即将bean放入容器beanDefinitionMap中,后续取值从这里取</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerBeanDefinition</span>(String beanName, BeanDefinition beanDefinition)
        <span class="hljs-keyword">throws</span> BeanDefinitionStoreException {

    Assert.hasText(beanName, <span class="hljs-string">"Bean name must not be empty"</span>);
    Assert.notNull(beanDefinition, <span class="hljs-string">"BeanDefinition must not be null"</span>);

    <span class="hljs-keyword">if</span> (beanDefinition <span class="hljs-keyword">instanceof</span> AbstractBeanDefinition) {
        <span class="hljs-keyword">try</span> {
            ((AbstractBeanDefinition) beanDefinition).validate();
        }
        <span class="hljs-keyword">catch</span> (BeanDefinitionValidationException ex) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,
                    <span class="hljs-string">"Validation of bean definition failed"</span>, ex);
        }
    }

    BeanDefinition oldBeanDefinition;

    oldBeanDefinition = <span class="hljs-keyword">this</span>.beanDefinitionMap.get(beanName);
    <span class="hljs-keyword">if</span> (oldBeanDefinition != <span class="hljs-keyword">null</span>) {
        <span class="hljs-keyword">if</span> (!isAllowBeanDefinitionOverriding()) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,
                    <span class="hljs-string">"Cannot register bean definition ["</span> + beanDefinition + <span class="hljs-string">"] for bean '"</span> + beanName +
                    <span class="hljs-string">"': There is already ["</span> + oldBeanDefinition + <span class="hljs-string">"] bound."</span>);
        }
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oldBeanDefinition.getRole() &lt; beanDefinition.getRole()) {
            <span class="hljs-comment">// e.g. was ROLE_APPLICATION, now overriding with ROLE_SUPPORT or ROLE_INFRASTRUCTURE</span>
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.logger.isWarnEnabled()) {
                <span class="hljs-keyword">this</span>.logger.warn(<span class="hljs-string">"Overriding user-defined bean definition for bean '"</span> + beanName +
                        <span class="hljs-string">"' with a framework-generated bean definition: replacing ["</span> +
                        oldBeanDefinition + <span class="hljs-string">"] with ["</span> + beanDefinition + <span class="hljs-string">"]"</span>);
            }
        }
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!beanDefinition.equals(oldBeanDefinition)) {
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.logger.isInfoEnabled()) {
                <span class="hljs-keyword">this</span>.logger.info(<span class="hljs-string">"Overriding bean definition for bean '"</span> + beanName +
                        <span class="hljs-string">"' with a different definition: replacing ["</span> + oldBeanDefinition +
                        <span class="hljs-string">"] with ["</span> + beanDefinition + <span class="hljs-string">"]"</span>);
            }
        }
        <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.logger.isDebugEnabled()) {
                <span class="hljs-keyword">this</span>.logger.debug(<span class="hljs-string">"Overriding bean definition for bean '"</span> + beanName +
                        <span class="hljs-string">"' with an equivalent definition: replacing ["</span> + oldBeanDefinition +
                        <span class="hljs-string">"] with ["</span> + beanDefinition + <span class="hljs-string">"]"</span>);
            }
        }
        <span class="hljs-keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);
    }
    <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">if</span> (hasBeanCreationStarted()) {
            <span class="hljs-comment">// Cannot modify startup-time collection elements anymore (for stable iteration)</span>
            <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>.beanDefinitionMap) {
                <span class="hljs-keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);
                List&lt;String&gt; updatedDefinitions = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;(<span class="hljs-keyword">this</span>.beanDefinitionNames.size() + <span class="hljs-number">1</span>);
                updatedDefinitions.addAll(<span class="hljs-keyword">this</span>.beanDefinitionNames);
                updatedDefinitions.add(beanName);
                <span class="hljs-keyword">this</span>.beanDefinitionNames = updatedDefinitions;
                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.manualSingletonNames.contains(beanName)) {
                    Set&lt;String&gt; updatedSingletons = <span class="hljs-keyword">new</span> LinkedHashSet&lt;String&gt;(<span class="hljs-keyword">this</span>.manualSingletonNames);
                    updatedSingletons.remove(beanName);
                    <span class="hljs-keyword">this</span>.manualSingletonNames = updatedSingletons;
                }
            }
        }
        <span class="hljs-keyword">else</span> {
            <span class="hljs-comment">// Still in startup registration phase</span>
            <span class="hljs-keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);
            <span class="hljs-keyword">this</span>.beanDefinitionNames.add(beanName);
            <span class="hljs-keyword">this</span>.manualSingletonNames.remove(beanName);
        }
        <span class="hljs-keyword">this</span>.frozenBeanDefinitionNames = <span class="hljs-keyword">null</span>;
    }

    <span class="hljs-keyword">if</span> (oldBeanDefinition != <span class="hljs-keyword">null</span> || containsSingleton(beanName)) {
        resetBeanDefinition(beanName);
    }
}</code></pre> 
<p>    上面就是初始化的bean装载过程.</p> 
<p>    下面来看bean的实例化:</p> 
<p>    看<code>AbstractBeanFactory</code>类中如下代码:</p> 
<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-keyword">protected</span> Object <span class="hljs-title">getObjectForBeanInstance</span>(
        Object beanInstance, String name, String beanName, RootBeanDefinition mbd) {
    <span class="hljs-keyword">if</span> (BeanFactoryUtils.isFactoryDereference(name) &amp;&amp; !(beanInstance <span class="hljs-keyword">instanceof</span> FactoryBean)) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanIsNotAFactoryException(transformedBeanName(name), beanInstance.getClass());
    }
    <span class="hljs-comment">//注意这里,如果我们的bean满足:</span>
    <span class="hljs-comment">//1.没有实现FactoryBean 2.isFactoryDereference方法是判定是否以&amp;符号开头</span>
    <span class="hljs-comment">//满足则直接返回实例.否则则会走下面的逻辑   所以这里就是BeanFactory中常量&amp;的用法</span>
    <span class="hljs-keyword">if</span> (!(beanInstance <span class="hljs-keyword">instanceof</span> FactoryBean) || BeanFactoryUtils.isFactoryDereference(name)) {
        <span class="hljs-keyword">return</span> beanInstance;
    }

    Object object = <span class="hljs-keyword">null</span>;
    <span class="hljs-keyword">if</span> (mbd == <span class="hljs-keyword">null</span>) {
        object = getCachedObjectForFactoryBean(beanName);
    }
    <span class="hljs-keyword">if</span> (object == <span class="hljs-keyword">null</span>) {
        FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) beanInstance;
        <span class="hljs-keyword">if</span> (mbd == <span class="hljs-keyword">null</span> &amp;&amp; containsBeanDefinition(beanName)) {
            mbd = getMergedLocalBeanDefinition(beanName);
        }
        <span class="hljs-keyword">boolean</span> synthetic = (mbd != <span class="hljs-keyword">null</span> &amp;&amp; mbd.isSynthetic());
        object = getObjectFromFactoryBean(factory, beanName, !synthetic);
    }
    <span class="hljs-keyword">return</span> object;
}</code></pre> 
<p>    上面方法会继续调用到下面方法:</p> 
<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-keyword">private</span> Object <span class="hljs-title">doGetObjectFromFactoryBean</span>(<span class="hljs-keyword">final</span> FactoryBean&lt;?&gt; factory, <span class="hljs-keyword">final</span> String beanName)
        <span class="hljs-keyword">throws</span> BeanCreationException {

    Object object;
    <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">if</span> (System.getSecurityManager() != <span class="hljs-keyword">null</span>) {
            AccessControlContext acc = getAccessControlContext();
            <span class="hljs-keyword">try</span> {
                object = AccessController.doPrivileged(<span class="hljs-keyword">new</span> PrivilegedExceptionAction&lt;Object&gt;() {
                    <span class="hljs-annotation">@Override</span>
                    <span class="hljs-keyword">public</span> Object <span class="hljs-title">run</span>() <span class="hljs-keyword">throws</span> Exception {
                            <span class="hljs-comment">//调用FactoryBean的getObject方法来返回实例</span>
                            <span class="hljs-keyword">return</span> factory.getObject();
                        }
                    }, acc);
            }
            <span class="hljs-keyword">catch</span> (PrivilegedActionException pae) {
                <span class="hljs-keyword">throw</span> pae.getException();
            }
        }
        <span class="hljs-keyword">else</span> {
            <span class="hljs-comment">//调用FactoryBean的getObject方法来返回实例</span>
            object = factory.getObject();
        }
    }
    <span class="hljs-keyword">catch</span> (FactoryBeanNotInitializedException ex) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanCurrentlyInCreationException(beanName, ex.toString());
    }
    <span class="hljs-keyword">catch</span> (Throwable ex) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanCreationException(beanName, <span class="hljs-string">"FactoryBean threw exception on object creation"</span>, ex);
    }
    <span class="hljs-keyword">if</span> (object == <span class="hljs-keyword">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanCurrentlyInCreationException(
                beanName, <span class="hljs-string">"FactoryBean which is currently in creation returned null from getObject"</span>);
    }
    <span class="hljs-keyword">return</span> object;
}</code></pre> 
<p>    上面注释已经说明了,最终其实会调用FactoryBean的getObject方法来返回实例.</p> 
<p><strong>总结:</strong></p> 
<ol><li>FactoryBean其实就是一个简单工厂,实现其方法覆写getObject方法可以直接简易的实现工厂模式.</li><li>BeanFactory是Spring的核心接口,说白了其实也是采用了工厂模式,根据传入的不同bean名字,之后调用容器(如DefaultListableBeanFactory)返回具体的bean实例.我们常用的<code>ClassPathXmlApplicationContext</code>以及<code>FileSystemXmlApplicationContext</code>等都实现了此接口.</li></ol> 
<hr> 
<p>欢迎关注个人博客:blog.scarlettbai.com</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/fad35e68c0ec02208c94f455a3ab233e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">c&#43;&#43;自制锁机程序--两行代码</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3eab7d01973193877fff66fab5577b72/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">MediaPlayer详解及代码Demo</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>