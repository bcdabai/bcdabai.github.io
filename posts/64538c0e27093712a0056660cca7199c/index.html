<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Vite 5.0 正式发布 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Vite 5.0 正式发布" />
<meta property="og:description" content="11 月 16 日，Vite 5.0 正式发布，这是 Vite 道路上的又一个重要里程碑！
Vite 现在使用 Rollup 4，这已经代表了构建性能的大幅提升。此外，还有一些新的选项可以改善开发服务器性能。
Vite 4 发布于近一年前，它为生态系统奠定了坚实的基础。随着项目继续在共享基础设施上构建，每周 npm 下载量从 250 万跃升至 750 万。框架不断创新，除了 Astro、Nuxt、SvelteKit、Solid Start、Qwik City 等，还看到新的框架加入并使生态系统更加强大。RedwoodJS 和 Remix 转向 Vite 为 React 生态系统的进一步采用铺平了道路。Vitest 的增长速度甚至超过了 Vite。其团队一直在努力，很快将发布 Vitest 1.0。Vite 与 Storybook、Nx 和 Playwright 等其他工具一起使用的故事不断改进，环境也是如此，Vite 在 Deno 和 Bun 中都是可以使用的。
六个月前，Vite 4.3 版本发布。该版本显著提高了开发服务器的性能。然而，仍有很大的改进空间。在 ViteConf 上，尤雨溪公布了 Vite 的长期计划，即致力于开发 Rolldown，这是一个带有兼容 API 的 Rust 移植版的 Rollup。一旦准备就绪，打算在 Vite Core 中使用它来承担 Rollup 和 esbuild 的任务。这将意味着提高构建性能，并大大减少开发和构建之间的不一致。Rolldown 目前处于早期阶段，团队正准备在年底前开源代码库。敬请关注！
Vite 5 专注于清理 API（删除不推荐使用的功能），并简化了解决长期问题的几个功能，例如切换定义以使用正确的 AST 替换而不是 regex。团队还将继续采取措施来实现未来的 Vite（Node." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/64538c0e27093712a0056660cca7199c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-11-17T16:31:07+08:00" />
<meta property="article:modified_time" content="2023-11-17T16:31:07+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Vite 5.0 正式发布</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>11 月 16 日，<code>Vite 5.0</code> 正式发布，这是 <code>Vite</code> 道路上的又一个重要里程碑！<br> <code>Vite</code> 现在使用 <code>Rollup 4</code>，这已经代表了构建性能的大幅提升。此外，还有一些新的选项可以改善开发服务器性能。</p> 
<p><code>Vite 4</code> 发布于近一年前，它为生态系统奠定了坚实的基础。随着项目继续在共享基础设施上构建，每周 <code>npm</code> 下载量从 250 万跃升至 750 万。框架不断创新，除了 Astro、Nuxt、SvelteKit、Solid Start、Qwik City 等，还看到新的框架加入并使生态系统更加强大。RedwoodJS 和 Remix 转向 <code>Vite</code> 为 <code>React</code> 生态系统的进一步采用铺平了道路。Vitest 的增长速度甚至超过了 Vite。其团队一直在努力，很快将发布 Vitest 1.0。Vite 与 Storybook、Nx 和 Playwright 等其他工具一起使用的故事不断改进，环境也是如此，<code>Vite</code> 在 Deno 和 Bun 中都是可以使用的。</p> 
<p>六个月前，<code>Vite 4.3</code> 版本发布。该版本显著提高了开发服务器的性能。然而，仍有很大的改进空间。在 ViteConf 上，尤雨溪公布了 <code>Vite</code> 的长期计划，即致力于开发 Rolldown，这是一个带有兼容 <code>API</code> 的 <code>Rust</code> 移植版的 <code>Rollup</code>。一旦准备就绪，打算在 Vite Core 中使用它来承担 Rollup 和 esbuild 的任务。这将意味着提高构建性能，并大大减少开发和构建之间的不一致。Rolldown 目前处于早期阶段，团队正准备在年底前开源代码库。敬请关注！</p> 
<p><code>Vite 5</code> 专注于清理 API（删除不推荐使用的功能），并简化了解决长期问题的几个功能，例如切换定义以使用正确的 AST 替换而不是 regex。团队还将继续采取措施来实现未来的 Vite（<strong>Node.js 18+ 现在是必需的</strong>，CJS Node API 已被弃用）。</p> 
<h3><a id="_Vite_5_14"></a>快速开始使用 Vite 5</h3> 
<p>可以使用 <code>pnpm create vite</code> 用喜欢的框架搭建 <code>Vite</code> 项目，或者使用 <code>vite.new</code> 在线打开启动模板来使用 <code>Vite 5</code>。还可以运行 <code>pnpm create vite-extra</code> 来访问其他框架和运行时（Solid、Deno、SSR 和库启动器）的模板。当在“其他”选项下运行 <code>create vite</code> 时，也可以使用 <code>create vite-extra</code> 模板。</p> 
<p>注意，<code>Vite</code> 入门模板旨在用作使用不同框架测试 <code>Vite</code> 的平台。在构建下一个项目时，建议使用每个框架推荐的启动器。一些框架现在也将 <code>create vite</code> 重定向到它们的启动器（Vue 的 create-vue 和 Nuxt 3，以及 Svelte 的 SvelteKit）。</p> 
<h3><a id="Nodejs__22"></a>Node.js 支持</h3> 
<p>Vite 不再支持已 EOL 的 Node.js 14 / 16 / 17 / 19。现在需要 <code>Node.js 18 / 20+</code>。</p> 
<h3><a id="_26"></a>性能</h3> 
<p>除了 Rollup 4 的构建性能改进之外，还有一个新指南可帮助你识别和修复常见性能问题：https://vitejs.dev/guide/performance。</p> 
<p>Vite 5 还引入了 server.warmup，这是一项改善启动时间的新功能。它允许定义应在服务器启动后立即进行预转换的模块列表。当使用 <code>--open</code> 或 <code>server.open</code> 时，Vite 还会自动预热应用的入口点或提供的 URL 以打开。</p> 
<h3><a id="_34"></a>主要更新</h3> 
<h4><a id="Vite__Rollup_4__36"></a>Vite 现在由 Rollup 4 提供支持</h4> 
<p>Vite 现在使用 Rollup 4，它也带来了重大变化，包括：</p> 
<ul><li> <p>Import assertions 已更名为 import attributes。</p> </li><li> <p>不再支持 Acorn 插件。</p> </li><li> <p>对于 Vite 插件，this.resolve的skipSelf选项现在默认为true。</p> </li><li> <p>对于 Vite 插件，this.parse目前仅支持allowReturnOutsideFunction选项。</p> </li></ul> 
<h4><a id="CJS_Node_API__48"></a>CJS Node API 已被弃用</h4> 
<p>Vite的CJS Node API 已被弃用。当调用 <code>require('vite')</code> 时，现在会记录弃用警告。应该更新文件或框架，以导入 Vite 的ESM构建而不是CJS构建。</p> 
<p>在基本的Vite项目中，请确保：</p> 
<ul><li> <p>vite.config.js文件内容使用ESM语法。</p> </li><li> <p>最接近的package.json文件包含"type": “module”，或者使用.mjs扩展名，例如vite.config.mjs。</p> </li></ul> 
<p>对于其他项目，有一些常见的方法：</p> 
<ul><li> <p>将 ESM 配置为默认选项，根据需要选择 CJS：在项目的package.json中添加"type": “module”。所有*.js文件现在都被解释为ESM，并且需要使用 ESM 语法。可以将带有.cjs扩展名的文件重命名，以继续使用 CJS。</p> </li><li> <p>将 CJS 配置为默认选项，根据需要选择ESM：如果项目的package.json没有"type": “module”，所有*.js文件都将被解释为 CJS。可以将带有.mjs扩展名的文件重命名，以使用 ESM。</p> </li><li> <p>动态导入 Vite：如果需要继续使用 CJS，可以使用import(‘vite’)进行动态导入 Vite。这需要代码以异步上下文编写，但由于 Vite 的 API 大多是异步的，因此应该仍然可以管理。</p> </li></ul> 
<h4><a id="_define__importmetaenv__68"></a>重新制定 define 和 import.meta.env.* 的替代策略</h4> 
<p>在 Vite 4 中，<code>define</code> 和 <code>import.meta.env.*</code> 功能在开发和构建中使用不同的替换策略：</p> 
<ul><li> <p>在开发环境中，这两个功能被注入为全局变量到globalThis和import.meta中。</p> </li><li> <p>在构建环境中，这两个功能被静态地使用正则表达式替换。</p> </li></ul> 
<p>这导致在尝试访问这些变量时出现开发环境和构建环境的不一致性，有时甚至会导致构建失败。例如：</p> 
<pre><code class="prism language-js"><span class="token comment">// vite.config.js</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token function">defineConfig</span><span class="token punctuation">(</span><span class="token punctuation">{<!-- --></span>
  <span class="token literal-property property">define</span><span class="token operator">:</span> <span class="token punctuation">{<!-- --></span>
    <span class="token literal-property property">__APP_VERSION__</span><span class="token operator">:</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span><span class="token string">'1.0.0'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> 
<pre><code class="prism language-js"><span class="token keyword">const</span> data <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span> __APP_VERSION__ <span class="token punctuation">}</span>
<span class="token comment">// dev: { __APP_VERSION__: "1.0.0" } ✅</span>
<span class="token comment">// build: { "1.0.0" } ❌</span>

<span class="token keyword">const</span> docs <span class="token operator">=</span> <span class="token string">'I like import.meta.env.MODE'</span>
<span class="token comment">// dev: "I like import.meta.env.MODE" ✅</span>
<span class="token comment">// build: "I like "production"" ❌</span>
</code></pre> 
<p><code>Vite 5</code> 通过使用 <code>esbuild</code> 来处理构建中的替换，与开发行为保持一致。</p> 
<p>这个改变不应该影响大多数设置，因为已经有文档说明define的值应该遵循 esbuild 的语法：</p> 
<p>为了与 esbuild 的行为保持一致，表达式必须是一个 JSON 对象（null、boolean、number、string、array或object）或者一个单个的标识符。</p> 
<p>然而，如果你更喜欢直接保持静态替换值，可以使用 <a href="https://github.com/rollup/plugins/tree/master/packages/replace">@rollup/plugin-replace</a>。</p> 
<h4><a id="workerplugins__107"></a>worker.plugins 现在是一个函数</h4> 
<p>在 Vite 4 中，<code>worker.plugins</code> 接受一个插件数组((Plugin | Plugin[])[])。而在 Vite 5 中，它需要配置为一个返回插件数组的函数(() =&gt; (Plugin | Plugin[])[])。这个改变是为了使并行的工作器构建更加一致和可预测。</p> 
<h4><a id="___indexhtml_111"></a>允许包含 . 的路径回退到 index.html</h4> 
<p>在 Vite 4 中，在开发环境中访问包含点"."的路径时，即使将 <code>appType</code> 设置为’spa’（默认值），也不会回退到index.html。而在 Vite 5 中，它将会回退到index.html。</p> 
<p>注意，如果将图像路径指向一个不存在的文件（例如<code>&lt;img src="./file-does-not-exist.png"&gt;</code>），浏览器将不再在控制台中显示 404 错误消息。</p> 
<h4><a id="_HTML__119"></a>统一开发和预览 HTML 服务行为</h4> 
<p>在 Vite 4 中，开发服务器和预览服务器根据目录结构和末尾斜杠来不同地提供HTML服务。这会导致在测试构建后的应用时出现不一致性。Vite 5 将重构成以下类似的单一行为，假设以下文件结构：</p> 
<pre><code>├── index.html
├── file.html
└── dir
    └── index.html
</code></pre> 
<p><img src="https://images2.imgbox.com/de/fb/jTitfmTn_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="manifest__vite__132"></a>manifest 文件会在 .vite 目录中生成</h4> 
<p>默认情况下，Vite 4 中的清单文件（build.manifest和build.ssrManifest）是在构建的根目录中生成的。</p> 
<p>而从 Vite 5 开始，默认情况下它们将会生成在.build.outDir目录中的.vite目录中。这个改变有助于避免公共文件与相同的清单文件名在复制到build.outDir时发生冲突。</p> 
<h4><a id="CLI__Enter__140"></a>CLI 快捷方式需要额外的 Enter 键触发</h4> 
<p>现在，CLI的快捷方式（例如r键重启开发服务器）需要额外按下Enter键才能触发快捷方式。例如，按下r键后再按Enter键来重启开发服务器。</p> 
<p>这个改变防止 Vite 吞噬和控制特定于操作系统的快捷方式，使得将 Vite 开发服务器与其他进程结合使用时更加兼容。</p> 
<h4><a id="experimentalDecoratorsuseDefineForClassFields_TypeScript__148"></a>更新experimentalDecorators和useDefineForClassFields在 TypeScript 中的行为</h4> 
<p>Vite 5 使用 esbuild 0.19，并移除了对 esbuild 0.18 的兼容层，这改变了 experimentalDecorators 和 useDefineForClassFields 的处理方式。</p> 
<ul><li> <p>experimentalDecorators默认情况下是未启用的，需要在tsconfig.json中将compilerOptions.experimentalDecorators设置为true才能使用装饰器。</p> </li><li> <p>useDefineForClassFields的默认值取决于TypeScript的目标值，如果目标不是ESNext或ES2022或更新版本，或者没有tsconfig.json文件，则useDefineForClassFields将默认为false，这可能会导致问题，因为默认的esbuild.target值是 esnext。它可能会转译为静态初始化块，而这在浏览器中可能不被支持。</p> </li></ul> 
<p>因此，建议在配置 <code>tsconfig.json</code> 时将目标设置为 <code>ESNext</code> 或 <code>ES2022</code> 或更新版本，或者显式将useDefineForClassFields设置为true。</p> 
<pre><code class="prism language-js"><span class="token punctuation">{<!-- --></span>
  <span class="token string-property property">"compilerOptions"</span><span class="token operator">:</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 如果使用装饰器，设置为true</span>
    <span class="token string-property property">"experimentalDecorators"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    <span class="token comment">// 如果在浏览器中看到解析错误，设置为true</span>
    <span class="token string-property property">"useDefineForClassFields"</span><span class="token operator">:</span> <span class="token boolean">true</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h4><a id="httpshttps_true_171"></a>移除–https标志和https: true</h4> 
<p><code>-https</code> 标志在内部设置了server.https: true和preview.https: true。这个配置原本是用来与 Vite 3 中取消的自动 https 证书生成功能一起使用的。因此，这个配置不再有用，因为它会启动一个没有证书的 Vite HTTPS 服务器。</p> 
<p>如果使用的是@vitejs/plugin-basic-ssl或vite-plugin-mkcert，它们已经在内部设置了 https 配置，所以可以在设置中移除–https、server.https: true和preview.https: true。</p> 
<h4><a id="resolvePackageEntryresolvePackageData_API_179"></a>移除resolvePackageEntry和resolvePackageData API</h4> 
<p>resolvePackageEntry和resolvePackageData API已被移除，因为它们暴露了 Vite 的内部结构，并阻碍了过去 Vite 4.3 的潜在优化。可以使用第三方包替代这些API，例如：</p> 
<ul><li> <p>resolvePackageEntry: 使用 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/import.meta/resolve" rel="nofollow">import.meta.resolve</a> 或 <a href="https://github.com/wooorm/import-meta-resolve">import-meta-resolve</a>包。</p> </li><li> <p>resolvePackageData: 同上，并向上遍历包目录以获取根package.json。或者使用社区的 <a href="https://github.com/svitejs/vitefu">vitefu</a> 包。</p> </li></ul> 
<pre><code class="prism language-js"><span class="token keyword">import</span> <span class="token punctuation">{<!-- --></span> resolve <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'import-meta-env'</span>
<span class="token keyword">import</span> <span class="token punctuation">{<!-- --></span> findDepPkgJsonPath <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'vitefu'</span>
<span class="token keyword">import</span> fs <span class="token keyword">from</span> <span class="token string">'node:fs'</span>

<span class="token keyword">const</span> pkg <span class="token operator">=</span> <span class="token string">'my-lib'</span>
<span class="token keyword">const</span> basedir <span class="token operator">=</span> process<span class="token punctuation">.</span><span class="token function">cwd</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment">// `resolvePackageEntry`:</span>
<span class="token keyword">const</span> packageEntry <span class="token operator">=</span> <span class="token function">resolve</span><span class="token punctuation">(</span>pkg<span class="token punctuation">,</span> basedir<span class="token punctuation">)</span>

<span class="token comment">// `resolvePackageData`:</span>
<span class="token keyword">const</span> packageJsonPath <span class="token operator">=</span> <span class="token function">findDepPkgJsonPath</span><span class="token punctuation">(</span>pkg<span class="token punctuation">,</span> basedir<span class="token punctuation">)</span>
<span class="token keyword">const</span> packageJson <span class="token operator">=</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>fs<span class="token punctuation">.</span><span class="token function">readFileSync</span><span class="token punctuation">(</span>packageJsonPath<span class="token punctuation">,</span> <span class="token string">'utf-8'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre> 
<h4><a id="_API_203"></a>已移除的过时 API</h4> 
<ul><li> <p>CSS 文件的默认导出（例如 <code>import style from './foo.css'</code>）：改用?inline查询参数代替</p> </li><li> <p><code>import.meta.globEager</code>：改用 import.meta.glob(‘*’, { eager: true }) 代替 ssr.format：‘cjs’ 和 legacy.buildSsrCjsExternalHeuristics</p> </li><li> <p><code>server.middlewareMode</code>：‘ssr’ 和 server.middlewareMode：‘html’：改用 appType + server.middlewareMode: true 代替。</p> </li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0fe5194f6c5b4cdcf31abcf0d16d1416/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Python 的日志库（logging）和 pandas 库对日志数据进行分析</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/34d19e9bedaedbba67d2d93df6f603a2/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">十全十美源码</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>