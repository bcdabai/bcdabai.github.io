<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>语义分割(semantic segmentation)--DeepLabV3之ASPP(Atrous Spatial Pyramid Pooling)代码详解 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="语义分割(semantic segmentation)--DeepLabV3之ASPP(Atrous Spatial Pyramid Pooling)代码详解" />
<meta property="og:description" content="ASPP： Atrous Spatial Pyramid Pooling
deeplabv2中的aspp如上图所示，在特征顶部映射图使用了四中不同采样率的空洞卷积。这表明以不同尺度采样时有效的，在Deeolabv3中向ASPP中添加了BN层。不同采样率的空洞卷积可以有效捕获多尺度信息，但会发现随着采样率的增加，滤波器有效权重（权重有效的应用在特征区域，而不是填充0）逐渐变小。如下图
当我们以不同采样率的3*3卷积核应用在65*65的特征映射上，当采样率接近特征映射大小时，3*3滤波器不是捕获全图像上下文，而是退化为简单的1*1滤波器，只有滤波器中心起作用。
为了克服这个问题，我们考虑使用图片级特征。具体来说，我们在模型最后的特征映射上应用全局平均，将结果经过1x1的卷积，再双线性上采样得到所需的空间维度。最终我们改进的ASPP包括：
1.一个1x1卷积和三个3x3的采样率为rates={6,12,18}的空洞卷积，滤波器数量为256，包含BN层。针对output_stride=16的情况。如下图(a)部分Atrous Spatial Pyramid Pooling
2.图像级特征，即将特征做全局平均池化，经过卷积再融合。如下图(b)部分Image Pooling
也就是说当output_stride=8时，加倍了采样率。所有特征通过1x1级联到一起，生成最终的分数。代码(pytorch)为：
class ASPP(nn.Module): def __init__(self, in_channel=512, depth=256): super(ASPP,self).__init__() # global average pooling : init nn.AdaptiveAvgPool2d ;also forward torch.mean(,,keep_dim=True) self.mean = nn.AdaptiveAvgPool2d((1, 1)) self.conv = nn.Conv2d(in_channel, depth, 1, 1) # k=1 s=1 no pad self.atrous_block1 = nn.Conv2d(in_channel, depth, 1, 1) self.atrous_block6 = nn.Conv2d(in_channel, depth, 3, 1, padding=6, dilation=6) self.atrous_block12 = nn.Conv2d(in_channel, depth, 3, 1, padding=12, dilation=12) self." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/5d2372751cbbcfa095f60e6bba79c369/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-02-12T12:51:34+08:00" />
<meta property="article:modified_time" content="2019-02-12T12:51:34+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">语义分割(semantic segmentation)--DeepLabV3之ASPP(Atrous Spatial Pyramid Pooling)代码详解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>ASPP： Atrous Spatial Pyramid Pooling</p> 
<p><img alt="" class="has" height="468" src="https://images2.imgbox.com/28/0b/5y2kk2ny_o.png" width="923"></p> 
<p>deeplabv2中的aspp如上图所示，在特征顶部映射图使用了四中不同采样率的空洞卷积。这表明以不同尺度采样时有效的，在Deeolabv3中向ASPP中添加了BN层。不同采样率的空洞卷积可以有效捕获多尺度信息，但会发现随着采样率的增加，滤波器有效权重（权重有效的应用在特征区域，而不是填充0）逐渐变小。如下图</p> 
<p><img alt="" class="has" height="609" src="https://images2.imgbox.com/17/80/KDUzvDi6_o.png" width="777"></p> 
<p>当我们以不同采样率的3*3卷积核应用在65*65的特征映射上，当采样率接近特征映射大小时，3*3滤波器不是捕获全图像上下文，而是退化为简单的1*1滤波器，只有滤波器中心起作用。</p> 
<p>为了克服这个问题，我们考虑使用图片级特征。具体来说，我们在模型最后的特征映射上应用全局平均，将结果经过1x1的卷积，再双线性上采样得到所需的空间维度。最终我们改进的ASPP包括：</p> 
<ol><li> <p>1.一个1x1卷积和三个3x3的采样率为rates={6,12,18}的空洞卷积，滤波器数量为256，包含BN层。针对output_stride=16的情况。如下图(a)部分Atrous Spatial Pyramid Pooling</p> </li><li> <p>2.图像级特征，即将特征做全局平均池化，经过卷积再融合。如下图(b)部分Image Pooling</p> </li></ol> 
<p><img alt="" class="has" height="305" src="https://images2.imgbox.com/4c/f6/Q5x7AMZz_o.png" width="942"></p> 
<p>也就是说当output_stride=8时，加倍了采样率。所有特征通过1x1级联到一起，生成最终的分数。代码(pytorch)为：</p> 
<pre class="has"><code class="hljs language-python">class ASPP(nn.Module):
    def __init__(self, in_channel=512, depth=256):
        super(ASPP,self).__init__()
        # global average pooling : init nn.AdaptiveAvgPool2d ;also forward torch.mean(,,keep_dim=True)
        self.mean = nn.AdaptiveAvgPool2d((1, 1))
        self.conv = nn.Conv2d(in_channel, depth, 1, 1)
        # k=1 s=1 no pad
        self.atrous_block1 = nn.Conv2d(in_channel, depth, 1, 1)
        self.atrous_block6 = nn.Conv2d(in_channel, depth, 3, 1, padding=6, dilation=6)
        self.atrous_block12 = nn.Conv2d(in_channel, depth, 3, 1, padding=12, dilation=12)
        self.atrous_block18 = nn.Conv2d(in_channel, depth, 3, 1, padding=18, dilation=18)

        self.conv_1x1_output = nn.Conv2d(depth * 5, depth, 1, 1)

    def forward(self, x):
        size = x.shape[2:]

        image_features = self.mean(x)
        image_features = self.conv(image_features)
        image_features = F.upsample(image_features, size=size, mode='bilinear')

        atrous_block1 = self.atrous_block1(x)

        atrous_block6 = self.atrous_block6(x)

        atrous_block12 = self.atrous_block12(x)

        atrous_block18 = self.atrous_block18(x)

        net = self.conv_1x1_output(torch.cat([image_features, atrous_block1, atrous_block6,
                                              atrous_block12, atrous_block18], dim=1))
        return net</code></pre> 
<p>本文内容参考：</p> 
<p><a href="https://blog.csdn.net/u011974639/article/details/79144773">https://blog.csdn.net/u011974639/article/details/79144773</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/25f0bbc8cbcd00c9dd0603904b49d154/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">LaTeX中的BibTex报错部分解决方案</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/7c12bb9bcf9d8dd949af94c13378faff/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Linux下安装vim编辑器</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>