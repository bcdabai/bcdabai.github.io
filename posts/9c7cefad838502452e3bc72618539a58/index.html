<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据的表示之原码，补码，反码和移码 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="数据的表示之原码，补码，反码和移码" />
<meta property="og:description" content="目录
一、机器数和真值
１、机器数
２、真值
二、原码反码补码和移码的基础概念和计算方法
１．原码
２．反码
３．补码
４．移码
三、为何要使用原码反码，补码和移码
为何还会有反码和补码呢？
四、数值表示范围
五、原码反码补码再深入
一、机器数和真值 在学习原码反码，补码和移码之前需要先了解机器数和真值的概念。
１、机器数 一个数在计算机中的二进制表示形式，叫做这个数的机器数。机器数是带符号的，在计算机中用一个数的最高位存放符号正数为０负数为１。
比如，十进制中的数&#43;３，计算机字长为８位，转换成二进制就是0000 0011。如果是-３，就是1000 0011。
那么，这里的0000 0011和1000 0011就是机器数。
２、真值 因为第一位是符号位，所以机器数的形式值就不等于真正的数值。例如上面的有符号数1000 0011，其最高位１代表负，其真正数值是-３而不是形式值131（1000 0011转换成十进制等于131）。
所以，为区别起见，将带符号位的机器数对应的真正数值称为机器数的真值。例：0000 0001的真值＝&#43;000 0001＝&#43;１，1000 0001的真值＝–000 0001＝–１
二、原码反码补码和移码的基础概念和计算方法 在探求机器为何要使用补码之前让我们先了解原码反码，补码和移码的概念。对于一个数计算机要使用一定的编码方式进行存储。原码反码补码和移码是机器存储一个具体数字的编码方式。
１．原码 原码就是符号位加上真值的绝对值即用第一位表示符号其余位表示值。比如如果是８位二进制：
［＋１］原＝００００ ０００１
［－１］原＝１０００ ０００１
第一位是符号位。因为第一位是符号位所以８位二进制数的取值范围就是：
［１１１１　１１１１０１１１　１１１１］＝＝＞［－１２７１２７］
２．反码 反码的表示方法是：
正数的反码是其本身；负数的反码是在其原码的基础上符号位不变，其余各个位取反。 ［＋１］＝［０００００００１］原　＝［０００００００１］反　［－１］＝［１００００００１］原　＝［１１１１１１１０］反
３．补码 补码的表示方法是：
正数的补码就是其本身；负数的补码是在其原码的基础上符号位不变其余各位取反最后＋１（即在反码的基础上＋１）。 ［＋１］＝［０００００００１］原＝［０００００００１］反＝［０００００００１］补　［－１］＝［１００００００１］原＝［１１１１１１１０］反＝［１１１１１１１１］补
４．移码 移码是作用于阶码上的，移码的表示方法是：
正数的最高符号位用１表示；负数的最高符号位用０表示；其余原码位不变。 ［＋１］＝［０００００００１］原　＝［０００００００１］反＝［０００００００１］补＝［１００００００１］移　［－１］＝［１００００００１］原＝［１１１１１１１０］反＝［１１１１１１１１］补＝［０００００００１］移
三、为何要使用原码反码，补码和移码 图1　数据的表示
计算机可以有三种编码方式表示一个数。对于正数，因为三种编码方式的结果都相同，所以不需要过多解释。
［＋１］＝［０００００００１］原 ＝［０００００００１］反 ＝［０００００００１］补" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/9c7cefad838502452e3bc72618539a58/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-08-03T00:09:24+08:00" />
<meta property="article:modified_time" content="2020-08-03T00:09:24+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据的表示之原码，补码，反码和移码</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="-toc" style="margin-left:0px;"> </p> 
<p id="%E4%B8%80%E3%80%81%E6%9C%BA%E5%99%A8%E6%95%B0%E5%92%8C%E7%9C%9F%E5%80%BC-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%E6%9C%BA%E5%99%A8%E6%95%B0%E5%92%8C%E7%9C%9F%E5%80%BC" rel="nofollow">一、机器数和真值</a></p> 
<p id="%EF%BC%91%E3%80%81%E6%9C%BA%E5%99%A8%E6%95%B0-toc" style="margin-left:40px;"><a href="#%EF%BC%91%E3%80%81%E6%9C%BA%E5%99%A8%E6%95%B0" rel="nofollow">１、机器数</a></p> 
<p id="%EF%BC%92%E3%80%81%E7%9C%9F%E5%80%BC-toc" style="margin-left:40px;"><a href="#%EF%BC%92%E3%80%81%E7%9C%9F%E5%80%BC" rel="nofollow">２、真值</a></p> 
<p id="%E4%BA%8C%E3%80%81%E5%8E%9F%E7%A0%81%E5%8F%8D%E7%A0%81%E8%A1%A5%E7%A0%81%E5%92%8C%E7%A7%BB%E7%A0%81%E7%9A%84%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E5%92%8C%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81%E5%8E%9F%E7%A0%81%E5%8F%8D%E7%A0%81%E8%A1%A5%E7%A0%81%E5%92%8C%E7%A7%BB%E7%A0%81%E7%9A%84%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E5%92%8C%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95" rel="nofollow">二、原码反码补码和移码的基础概念和计算方法</a></p> 
<p id="%EF%BC%91%EF%BC%8E%E5%8E%9F%E7%A0%81-toc" style="margin-left:40px;"><a href="#%EF%BC%91%EF%BC%8E%E5%8E%9F%E7%A0%81" rel="nofollow">１．原码</a></p> 
<p id="%EF%BC%92%EF%BC%8E%E5%8F%8D%E7%A0%81-toc" style="margin-left:40px;"><a href="#%EF%BC%92%EF%BC%8E%E5%8F%8D%E7%A0%81" rel="nofollow">２．反码</a></p> 
<p id="%EF%BC%93%EF%BC%8E%E8%A1%A5%E7%A0%81-toc" style="margin-left:40px;"><a href="#%EF%BC%93%EF%BC%8E%E8%A1%A5%E7%A0%81" rel="nofollow">３．补码</a></p> 
<p id="%EF%BC%94%EF%BC%8E%E7%A7%BB%E7%A0%81-toc" style="margin-left:40px;"><a href="#%EF%BC%94%EF%BC%8E%E7%A7%BB%E7%A0%81" rel="nofollow">４．移码</a></p> 
<p id="%E4%B8%89%E3%80%81%E4%B8%BA%E4%BD%95%E8%A6%81%E4%BD%BF%E7%94%A8%E5%8E%9F%E7%A0%81%E5%8F%8D%E7%A0%81%EF%BC%8C%E8%A1%A5%E7%A0%81%E5%92%8C%E7%A7%BB%E7%A0%81-toc" style="margin-left:0px;"><a href="#%E4%B8%89%E3%80%81%E4%B8%BA%E4%BD%95%E8%A6%81%E4%BD%BF%E7%94%A8%E5%8E%9F%E7%A0%81%E5%8F%8D%E7%A0%81%EF%BC%8C%E8%A1%A5%E7%A0%81%E5%92%8C%E7%A7%BB%E7%A0%81" rel="nofollow">三、为何要使用原码反码，补码和移码</a></p> 
<p id="%E4%B8%BA%E4%BD%95%E8%BF%98%E4%BC%9A%E6%9C%89%E5%8F%8D%E7%A0%81%E5%92%8C%E8%A1%A5%E7%A0%81%E5%91%A2%EF%BC%9F-toc" style="margin-left:40px;"><a href="#%E4%B8%BA%E4%BD%95%E8%BF%98%E4%BC%9A%E6%9C%89%E5%8F%8D%E7%A0%81%E5%92%8C%E8%A1%A5%E7%A0%81%E5%91%A2%EF%BC%9F" rel="nofollow">为何还会有反码和补码呢？</a></p> 
<p id="%E5%9B%9B%E3%80%81%E6%95%B0%E5%80%BC%E8%A1%A8%E7%A4%BA%E8%8C%83%E5%9B%B4-toc" style="margin-left:0px;"><a href="#%E5%9B%9B%E3%80%81%E6%95%B0%E5%80%BC%E8%A1%A8%E7%A4%BA%E8%8C%83%E5%9B%B4" rel="nofollow">四、数值表示范围</a></p> 
<p id="%E4%BA%94%E3%80%81%E5%8E%9F%E7%A0%81%E5%8F%8D%E7%A0%81%E8%A1%A5%E7%A0%81%E5%86%8D%E6%B7%B1%E5%85%A5-toc" style="margin-left:0px;"><a href="#%E4%BA%94%E3%80%81%E5%8E%9F%E7%A0%81%E5%8F%8D%E7%A0%81%E8%A1%A5%E7%A0%81%E5%86%8D%E6%B7%B1%E5%85%A5" rel="nofollow">五、原码反码补码再深入</a></p> 
<hr id="hr-toc"> 
<h2 id="%E4%B8%80%E3%80%81%E6%9C%BA%E5%99%A8%E6%95%B0%E5%92%8C%E7%9C%9F%E5%80%BC" style="margin-left:0pt;">一、机器数和真值</h2> 
<p style="margin-left:0pt;">在学习原码反码，补码和移码之前需要先了解机器数和真值的概念。</p> 
<p style="margin-left:0pt;"> </p> 
<h3 id="%EF%BC%91%E3%80%81%E6%9C%BA%E5%99%A8%E6%95%B0" style="margin-left:0pt;"><strong><strong>１、机器数</strong></strong></h3> 
<p style="margin-left:0pt;">一个数在计算机中的二进制表示形式，叫做这个数的机器数。机器数是带符号的，在计算机中用一个数的最高位存放符号正数为０负数为１。</p> 
<p style="margin-left:0pt;">比如，十进制中的数+３，计算机字长为８位，转换成二进制就是0000 0011。如果是-３，就是1000 0011。</p> 
<p style="margin-left:0pt;">那么，这里的0000 0011和1000 0011就是机器数。</p> 
<p style="margin-left:0pt;"> </p> 
<h3 id="%EF%BC%92%E3%80%81%E7%9C%9F%E5%80%BC" style="margin-left:0pt;"><strong><strong>２、真值</strong></strong></h3> 
<p style="margin-left:0pt;"> </p> 
<p style="margin-left:0pt;">因为第一位是符号位，所以机器数的形式值就不等于真正的数值。例如上面的有符号数1000 0011，其最高位１代表负，其真正数值是-３而不是形式值131（1000 0011转换成十进制等于131）。</p> 
<p style="margin-left:0pt;">所以，为区别起见，将带符号位的机器数对应的真正数值称为机器数的真值。例：0000 0001的真值＝+000 0001＝+１，1000 0001的真值＝–000 0001＝–１</p> 
<p style="margin-left:0pt;"> </p> 
<h2 id="%E4%BA%8C%E3%80%81%E5%8E%9F%E7%A0%81%E5%8F%8D%E7%A0%81%E8%A1%A5%E7%A0%81%E5%92%8C%E7%A7%BB%E7%A0%81%E7%9A%84%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E5%92%8C%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95" style="margin-left:0pt;">二、原码反码补码和移码的基础概念和计算方法</h2> 
<p style="margin-left:0pt;"> </p> 
<p style="margin-left:0pt;">在探求机器为何要使用补码之前让我们先了解原码反码，补码和移码的概念。对于一个数计算机要使用一定的编码方式进行存储。原码反码补码和移码是机器存储一个具体数字的编码方式。</p> 
<p style="margin-left:0pt;"> </p> 
<h3 id="%EF%BC%91%EF%BC%8E%E5%8E%9F%E7%A0%81" style="margin-left:0pt;"><strong><strong>１．原码</strong></strong></h3> 
<p style="margin-left:0pt;"> </p> 
<p style="margin-left:0pt;">原码就是符号位加上真值的绝对值即用第一位表示符号其余位表示值。比如如果是８位二进制：</p> 
<p style="margin-left:0pt;">［＋１］原＝００００ ０００１</p> 
<p style="margin-left:0pt;">［－１］原＝１０００ ０００１</p> 
<p style="margin-left:0pt;">第一位是符号位。因为第一位是符号位所以８位二进制数的取值范围就是：</p> 
<p style="margin-left:0pt;">［１１１１　１１１１０１１１　１１１１］＝＝＞［－１２７１２７］</p> 
<p style="margin-left:0pt;"> </p> 
<h3 id="%EF%BC%92%EF%BC%8E%E5%8F%8D%E7%A0%81" style="margin-left:0pt;"><strong><strong>２．反码</strong></strong></h3> 
<p style="margin-left:0pt;"> </p> 
<p style="margin-left:0pt;">反码的表示方法是：</p> 
<ol><li>正数的反码是其本身；</li><li>负数的反码是在其原码的基础上符号位不变，其余各个位取反。</li></ol> 
<p style="margin-left:0pt;"> </p> 
<p style="margin-left:0pt;">［＋<span style="color:#800080;">１</span>］＝［<span style="color:#800080;">０００００００１</span>］原　＝［<span style="color:#800080;">０００００００１</span>］反　</p> 
<p style="margin-left:0pt;">［－<span style="color:#800080;">１</span>］＝［<strong><span style="color:#df402a;"><strong>１</strong></span></strong><strong><span style="color:#77c94b;"><strong>００００００１</strong></span></strong>］原　＝［<strong><span style="color:#df402a;"><strong>１</strong></span></strong><strong><span style="color:#77c94b;"><strong>１１１１１１０</strong></span></strong>］反</p> 
<p style="margin-left:0pt;"> </p> 
<h3 id="%EF%BC%93%EF%BC%8E%E8%A1%A5%E7%A0%81" style="margin-left:0pt;"><strong><strong>３．补码</strong></strong></h3> 
<p style="margin-left:0pt;"> </p> 
<p style="margin-left:0pt;">补码的表示方法是：</p> 
<ol><li>正数的补码就是其本身；</li><li>负数的补码是在其原码的基础上<span style="color:#c00000;">符号位不变其余各位取反最后＋１</span>（即在反码的基础上＋１）。</li></ol> 
<p style="margin-left:0pt;"> </p> 
<p style="margin-left:0pt;">［＋<span style="color:#800080;">１</span>］＝［<span style="color:#800080;">０００００００１</span>］原＝［<span style="color:#800080;">０００００００１</span>］反＝［<span style="color:#800080;">０００００００１</span>］补　</p> 
<p style="margin-left:0pt;">［－<span style="color:#800080;">１</span>］＝［<span style="color:#800080;">１００００００１</span>］原＝［<span style="color:#800080;">１１１１１１１０</span>］反＝［<span style="color:#800080;">１１１１１１１１</span>］补</p> 
<p style="margin-left:0pt;"> </p> 
<h3 id="%EF%BC%94%EF%BC%8E%E7%A7%BB%E7%A0%81" style="margin-left:0pt;"><strong><strong>４．移码</strong></strong></h3> 
<p style="margin-left:0pt;"> </p> 
<p style="margin-left:0pt;">移码是作用于<a href="https://baike.baidu.com/item/%E7%A7%BB%E7%A0%81/10165919?fr=aladdin" rel="nofollow"><u><span style="color:#003884;"><u>阶码</u></span></u></a>上的，移码的表示方法是：</p> 
<ol><li>正数的最高符号位用１表示；</li><li>负数的最高符号位用０表示；</li><li>其余原码位不变。</li></ol> 
<p style="margin-left:0pt;">［＋<span style="color:#800080;">１</span>］＝［<span style="color:#800080;">０００００００１</span>］原　＝［<span style="color:#800080;">０００００００１</span>］反＝［<span style="color:#800080;">０００００００１</span>］补＝［<span style="color:#800080;">１００００００１</span>］移　</p> 
<p style="margin-left:0pt;">［－<span style="color:#800080;">１</span>］＝［<span style="color:#800080;">１００００００１</span>］原＝［<span style="color:#800080;">１１１１１１１０</span>］反＝［<span style="color:#800080;">１１１１１１１１</span>］补＝［<span style="color:#800080;">０００００００１</span>］移</p> 
<p style="margin-left:0pt;"> </p> 
<h2 id="%E4%B8%89%E3%80%81%E4%B8%BA%E4%BD%95%E8%A6%81%E4%BD%BF%E7%94%A8%E5%8E%9F%E7%A0%81%E5%8F%8D%E7%A0%81%EF%BC%8C%E8%A1%A5%E7%A0%81%E5%92%8C%E7%A7%BB%E7%A0%81" style="margin-left:0pt;">三、为何要使用原码反码，补码和移码</h2> 
<p style="text-align:center;"><img alt="图1 数据的表示" height="322" src="https://images2.imgbox.com/a8/3b/KaEisIf9_o.png" width="531"></p> 
<p style="margin-left:0pt;"> </p> 
<p style="margin-left:0pt;">                                                                                            图1　数据的表示</p> 
<p style="margin-left:0pt;"> </p> 
<p style="margin-left:0pt;">计算机可以有三种编码方式表示一个数。对于正数，因为三种编码方式的结果都相同，所以不需要过多解释。</p> 
<p style="margin-left:0pt;"><span style="color:#333333;">［＋１］＝［０００００００１］原 ＝［０００００００１］反 ＝［０００００００１］补</span></p> 
<p style="margin-left:0pt;">但是对于负数：</p> 
<p style="margin-left:0pt;"><span style="color:#333333;">［－１］＝［１００００００１］原 ＝１１１１１１１０］反 ＝［１１１１１１１１］补</span></p> 
<p style="margin-left:0pt;">可见原码反码和补码是完全不同的。</p> 
<p style="margin-left:0pt;"> </p> 
<h3 id="%E4%B8%BA%E4%BD%95%E8%BF%98%E4%BC%9A%E6%9C%89%E5%8F%8D%E7%A0%81%E5%92%8C%E8%A1%A5%E7%A0%81%E5%91%A2%EF%BC%9F" style="margin-left:0pt;">为何还会有反码和补码呢？</h3> 
<p style="margin-left:0pt;"> </p> 
<p style="margin-left:0pt;">首先因为人脑可以知道第一位是符号位在计算的时候我们会根据符号位选择对真值区域的加减（真值的概念在本文最开头）。</p> 
<p style="margin-left:0pt;">但是对于计算机，加减乘数已经是最基础的运算要设计的尽量简单。　计算机辨别＂符号位＂显然会让计算机的基础电路设计变得十分复杂！于是人们想出了将符号位也参与运算的方法。</p> 
<p style="margin-left:0pt;">根据运算法则减去一个正数等于加上一个负数即：１－１＝１+（－１）＝０所以机器可以只有加法而没有减法这样计算机运算的设计就更简单了。</p> 
<p style="margin-left:0pt;">于是人们开始探索将符号位参与运算并且只保留加法的方法。首先来看原码：</p> 
<p style="margin-left:0pt;">计算十进制的表达式：１－１＝０</p> 
<p style="margin-left:0pt;">为了解决原码做减法的问题出现了反码：</p> 
<p style="margin-left:0pt;"><span style="color:#333333;">１-１＝１+（－１）＝［００００　０００１］原 ＋［１０００　０００１］原＝［００００　０００１］反 ＋［１１１１　１１１０］反 ＝［１１１１　１１１１］反 ＝［１０００　００００］原 ＝ -０</span></p> 
<p style="margin-left:0pt;">发现用反码计算减法结果真值的部分是正确的，而唯一的问题其实就出现在＂０＂这个特殊的数值上。虽然人们理解上＋０和－０是一样的但是０带符号是没有任何意义的。而且会有［００００　００００］原和［１０００　００００］原两个编码表示０。</p> 
<p style="margin-left:0pt;">于是补码的出现解决了０的符号以及两个编码的问题：</p> 
<p style="margin-left:0pt;"><span style="color:#333333;">１－１＝１+（－１）＝［００００　０００１］原 ＋［１０００　０００１］原 ＝［００００　０００１］补 ＋［１１１１　１１１１］补 ＝［００００　００００］补＝［００００　００００］原</span></p> 
<p style="margin-left:0pt;">这样０用［００００　００００］表示而以前出现问题的<span style="color:#df402a;">－０则不存在了</span>。而且可以用［１０００　００００］表示－１２８：</p> 
<p style="margin-left:0pt;"><span style="color:#333333;">（－１）</span><span style="color:#333333;">+</span><span style="color:#333333;">（－１２７）＝［１０００　０００１］原 ＋［１１１１　１１１１］原 ＝［１１１１　１１１１］补 ＋［１０００　０００１］补 ＝［１０００　００００］补</span></p> 
<p style="margin-left:0pt;">－１－127的结果应该是－128在用补码运算的结果中［１０００　００００］补 就是-128。但是注意因为实际上是使用以前的－０的补码来表示-128，所以-128并没有原码和反码表示（对－128的补码表示［１０００　００００］补算出来的原码是［００００　００００］原这是不正确的）。</p> 
<p style="margin-left:0pt;">使用补码不仅仅修复了０的符号以及存在两个编码的问题而且还能够多表示一个最低数。这就是为什么８位二进制使用原码或反码表示的范围为［－１２７＋１２７］而使用补码表示的范围为［－128 ，127］。</p> 
<p style="margin-left:0pt;">因为机器使用补码所以对于编程中常用到的３２位ｉｎｔ类型可以表示范围是：［－２３１２３１－１］因为第一位表示的是符号位，而使用补码表示时又可以多保存一个最小值。</p> 
<p style="margin-left:0pt;">移码是为了解决浮点数计算而来的，正数的最高符号位用０来表示，负数的最高位用１来表示就会混乱，颠倒了正常的思想观念，所以移码的最高符号位正好与原码、反码和补码的最高符号位相反，同时它进行相关操作也能得到正确的结果。</p> 
<p style="margin-left:0pt;">１０００　０００１+０１１１　１１１１＝１０００　００００［移］</p> 
<p style="margin-left:0pt;">最高符号位１代表正数，所以结果是０。</p> 
<p style="margin-left:0pt;"> </p> 
<h2 id="%E5%9B%9B%E3%80%81%E6%95%B0%E5%80%BC%E8%A1%A8%E7%A4%BA%E8%8C%83%E5%9B%B4" style="margin-left:0pt;">四、数值表示范围</h2> 
<p> </p> 
<p style="text-align:center;"><img alt="数值表示范围公式" height="406" src="https://images2.imgbox.com/ae/5a/UKKBBDKN_o.png" width="647"></p> 
<p style="margin-left:0pt;"> </p> 
<p style="margin-left:0pt;">                                                                             图2　数值表示范围公式</p> 
<p style="margin-left:0pt;">上图可知，原码和反码的取值范围都是－１２７～１２７，可是补码是－１２８～１２７。</p> 
<p style="margin-left:0pt;"> </p> 
<p style="margin-left:0pt;"><strong><strong>为什么补码的取值范围比原码、反码的多一位呢？</strong></strong></p> 
<p style="margin-left:0pt;"> </p> 
<p style="margin-left:0pt;">举例：</p> 
<p style="margin-left:0pt;">＋０＝００００　００００［原］</p> 
<p style="margin-left:0pt;">－０＝１０００　００００［原］</p> 
<p style="margin-left:0pt;">可以看出不对等。</p> 
<p style="margin-left:0pt;">＋０＝００００　００００［反］</p> 
<p style="margin-left:0pt;">－０＝１１１１　１１１１［反］</p> 
<p style="margin-left:0pt;">可以看出不对等。</p> 
<p style="margin-left:0pt;">＋０＝００００　００００［补］</p> 
<p style="margin-left:0pt;">－０＝００００　００００［补］</p> 
<p style="margin-left:0pt;">可以看出相等，所以补码少占用了一个编码。所以它的取值范围要比原码和反码多一位。</p> 
<p style="margin-left:0pt;"> </p> 
<h2 id="%E4%BA%94%E3%80%81%E5%8E%9F%E7%A0%81%E5%8F%8D%E7%A0%81%E8%A1%A5%E7%A0%81%E5%86%8D%E6%B7%B1%E5%85%A5" style="margin-left:0pt;">五、原码反码补码再深入</h2> 
<p style="margin-left:0pt;"> </p> 
<p style="margin-left:0pt;">计算机巧妙地把符号位参与运算并且将减法变成了加法背后蕴含了怎样的数学原理呢？</p> 
<p style="margin-left:0pt;">将钟表想象成是一个１位的１２进制数。如果当前时间是６点我希望将时间设置成４点需要怎么做呢？我们可以：</p> 
<p style="margin-left:0pt;">１．　往回拨２个小时：６-２＝４</p> 
<p style="margin-left:0pt;">２．　往前拨１０个小时：（６+１０）　ｍｏｄ　12＝４</p> 
<p style="margin-left:0pt;">３．　往前拨１０＋１２＝２２个小时：（６＋２２）　ｍｏｄ　12＝４</p> 
<p style="margin-left:0pt;">２、３方法中的ｍｏｄ是指取模操作１６　ｍｏｄ　12＝４，即用１６除以１２后的余数是４。</p> 
<p style="margin-left:0pt;">所以钟表往回拨（减法）的结果可以用往前拨（加法）替代！</p> 
<p style="margin-left:0pt;">现在的焦点就落在了如何用一个正数来替代一个负数。上面的例子我们能感觉出来一些端倪发现一些规律。但是数学是严谨的，不能靠感觉。</p> 
<p style="margin-left:0pt;">首先介绍一个数学中相关的概念：同余。</p> 
<p style="margin-left:0pt;"> </p> 
<p style="margin-left:0pt;"><strong><strong>同余的概念</strong></strong></p> 
<p style="margin-left:0pt;">两个整数ａ，ｂ，若它们除以整数ｍ所得的余数相等，则称ａ，ｂ对于模ｍ同余，记作ａ≡ｂ（ｍｏｄ　ｍ），读作ａ与ｂ关于模ｍ同余。</p> 
<p style="margin-left:0pt;">举例说明：</p> 
<p style="margin-left:0pt;">４　ｍｏｄ　１２　＝　４</p> 
<p style="margin-left:0pt;">１６　ｍｏｄ　１２　＝　４</p> 
<p style="margin-left:0pt;">２８　ｍｏｄ　１２　＝　４</p> 
<p style="margin-left:0pt;">所以４，16， 28关于模12同余。</p> 
<p style="margin-left:0pt;"> </p> 
<p style="margin-left:0pt;"><strong><strong>负数取模</strong></strong></p> 
<p style="margin-left:0pt;">正数进行ｍｏｄ运算是很简单的，但是负数呢？</p> 
<p style="margin-left:0pt;">下面是关于ｍｏｄ运算的数学定义：</p> 
<p style="text-align:center;"><img alt="取模运算的数学定义" height="34" src="https://images2.imgbox.com/12/b3/1Ulfisjn_o.png" width="244"></p> 
<p style="margin-left:0pt;">                                                                                           图 3 取模运算的数学定义</p> 
<p style="margin-left:0pt;">上面是截图＂取下界＂符号找不到如何输入（ｗｏｒｄ中粘贴过来后乱码）。下面是使用“Ｌ”和“Ｊ”替换上图的“取下界”符号：</p> 
<p style="margin-left:0pt;">ｘ　ｍｏｄ　ｙ＝ｘ-ｙ　Ｌ　ｘ／ｙ　Ｊ</p> 
<p style="margin-left:0pt;">上面公式的意思是：</p> 
<p style="margin-left:0pt;">ｘ　ｍｏｄ　ｙ等于ｘ减去ｙ乘上ｘ与ｙ的商的下界。</p> 
<p style="margin-left:0pt;">以-３　ｍｏｄ　2 举例：</p> 
<p style="margin-left:0pt;">－３　ｍｏｄ　２</p> 
<p style="margin-left:0pt;">＝-３-２ｘＬ -３／２　Ｊ</p> 
<p style="margin-left:0pt;">＝-３-２ｘ Ｌ－１.５ Ｊ</p> 
<p style="margin-left:0pt;">＝-３-２ｘ（－２）</p> 
<p style="margin-left:0pt;">＝-３+４＝１</p> 
<p style="margin-left:0pt;">所以：</p> 
<p style="margin-left:0pt;">（－２）　ｍｏｄ　１２＝１２－２＝１０</p> 
<p style="margin-left:0pt;">（－４）　ｍｏｄ　１２＝１２－４＝８</p> 
<p style="margin-left:0pt;">（－５）　ｍｏｄ　１２＝１２-５＝７</p> 
<p style="margin-left:0pt;"> </p> 
<p style="margin-left:0pt;"><strong><strong>开始证明</strong></strong></p> 
<p style="margin-left:0pt;">再回到时钟的问题上：</p> 
<p style="margin-left:0pt;">回拨２小时　＝　前拨１０小时</p> 
<p style="margin-left:0pt;">回拨４小时　＝　前拨８小时</p> 
<p style="margin-left:0pt;">回拨５小时＝　前拨７小时</p> 
<p style="margin-left:0pt;">注意这里发现的规律！</p> 
<p style="margin-left:0pt;">结合上面学到的同余的概念。实际上：</p> 
<p style="margin-left:0pt;">(－２)　mod　12＝10</p> 
<p style="margin-left:0pt;">10　mod　12＝10</p> 
<p style="margin-left:0pt;">－２与１０是同余的。</p> 
<p style="margin-left:0pt;">（－４）　ｍｏｄ　12＝８</p> 
<p style="margin-left:0pt;">８　ｍｏｄ　12＝８</p> 
<p style="margin-left:0pt;">－４与８是同余的。</p> 
<p style="margin-left:0pt;">距离成功越来越近了。要实现用正数替代负数只需要运用同余数的两个定理：</p> 
<p style="margin-left:0pt;">反身性：</p> 
<p style="margin-left:0pt;">ａ≡ａ　（ｍｏｄ　ｍ）</p> 
<p style="margin-left:0pt;">这个定理是很显而易见的。</p> 
<p style="margin-left:0pt;">线性运算定理：</p> 
<p style="margin-left:0pt;">如果ａ≡ｂ（ｍｏｄ　ｍ），ｃ≡ｄ（ｍｏｄ　ｍ）那么：</p> 
<p style="margin-left:0pt;">（１）ａ±ｃ≡ｂ±ｄ（ｍｏｄ　ｍ）</p> 
<p style="margin-left:0pt;">（２）ａ＊ｃ≡ｂ＊ｄ（ｍｏｄ　ｍ）</p> 
<p style="margin-left:0pt;">如果想看这个定理的证明请看：<a href="https://baike.baidu.com/item/%E5%90%8C%E4%BD%99%E5%AE%9A%E7%90%86/1212360?fromtitle=%E5%90%8C%E4%BD%99&amp;fromid=1432545" rel="nofollow">https://baike.baidu.com/item/%E5%90%8C%E4%BD%99%E5%AE%9A%E7%90%86/1212360?fromtitle=%E5%90%8C%E4%BD%99&amp;fromid=1432545</a></p> 
<p style="margin-left:0pt;">所以：</p> 
<p style="margin-left:0pt;">７≡７（ｍｏｄ　１２）</p> 
<p style="margin-left:0pt;">（－２）≡１０（ｍｏｄ　１２）</p> 
<p style="margin-left:0pt;">７-２≡７+１０（ｍｏｄ　１２）</p> 
<p style="margin-left:0pt;">现在我们为一个负数找到了它的正数同余数。但是并不是７－２＝７＋１０而是７-２≡７+１０（ｍｏｄ　１２）即计算结果的余数相等。</p> 
<p style="margin-left:0pt;">接下来回到二进制的问题上看一下：２－１＝１的问题．</p> 
<p style="margin-left:0pt;">２－１＝２＋（－１）＝［００００　００１０］原 ＋［１０００　０００１］原＝［００００　００１０］反 ＋［１１１１　１１１０］反</p> 
<p style="margin-left:0pt;">先到这一步－１的反码表示是１１１１　１１１０。如果这里将［１１１１　１１１０］认为是原码则［１１１１　１１１０］原＝-126这里将符号位除去即认为是126。</p> 
<p style="margin-left:0pt;">发现有如下规律：</p> 
<p style="margin-left:0pt;">（－１）　ｍｏｄ　127＝126</p> 
<p style="margin-left:0pt;">126　ｍｏｄ　127＝126</p> 
<p style="margin-left:0pt;">即：</p> 
<p style="margin-left:0pt;">（－１）　≡　126（ｍｏｄ　127）</p> 
<p style="margin-left:0pt;">２－１　≡　２＋126（ｍｏｄ　127）</p> 
<p style="margin-left:0pt;">２－１　与　２＋126的余数结果是相同的！而这个余数正式我们的期望的计算结果：２－１＝１</p> 
<p style="margin-left:0pt;">所以说一个数的反码实际上是这个数对于一个膜的同余数。而这个膜并不是我们的二进制而是所能表示的最大值！这就和钟表一样转了一圈后总能找到在可表示范围内的一个正确的数值！</p> 
<p style="margin-left:0pt;">而２＋126很显然相当于钟表转过了一轮而因为符号位是参与计算的正好和溢出的最高位形成正确的运算结果。</p> 
<p style="margin-left:0pt;">既然反码可以将减法变成加法那么现在计算机使用的补码呢？为什么在反码的基础上加１还能得到正确的结果？</p> 
<p style="margin-left:0pt;">２－１＝２＋（－１）＝［００００　００１０］原 ＋［１０００　０００１］原 ＝［００００　００１０］补 ＋［１１１１　１１１１］补</p> 
<p style="margin-left:0pt;">如果把［１１１１　１１１１］当成原码去除符号位， 则：</p> 
<p style="margin-left:0pt;">［０１１１　１１１１］原 ＝127</p> 
<p style="margin-left:0pt;">其实在反码的基础上＋１只是相当于增加了模的值：</p> 
<p style="margin-left:0pt;">（-1）　ｍｏｄ　128＝127</p> 
<p style="margin-left:0pt;">127　ｍｏｄ　128＝127</p> 
<p style="margin-left:0pt;">２－１≡２＋127（ｍｏｄ　128）</p> 
<p style="margin-left:0pt;">此时表盘相当于每128个刻度转一轮。所以用补码表示的运算结果最小值和最大值应该是［－128,128］。</p> 
<p style="margin-left:0pt;">但是由于０的特殊情况没有办法表示128，所以补码的取值范围是［－128 ，127］。</p> 
<p style="margin-left:0pt;"> </p> 
<p style="margin-left:0pt;"> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6be707874c4d97d22addd3fc90d5a8ea/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">深入理解PCA(主成分分析法)算法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ada0fbb68a16be8ebe1e72c72745b24b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">视觉十四讲：第八讲_光流法(特征点追踪)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>