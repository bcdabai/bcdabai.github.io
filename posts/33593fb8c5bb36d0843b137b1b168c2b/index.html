<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>流式编程基础内容解读 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="流式编程基础内容解读" />
<meta property="og:description" content="内容讲解： 介绍： Stream相当于一个数据渠道，用于操作集合、数组等多种数据源所生成的元素序列
注意：
1、Stream 自己不会存储元素。
2、Stream 不会改变源对象。相反，他们会返回一个持有结果的新Stream。
3、Stream 操作是延迟执行的。这意味着他们会等到需要结果的时候才执行。
Stream流步骤： （1）创建 Stream：一个数据源(如:集合、数组)，获取一个流；
（2）中间操作：一个中间操作链，对数据源的数据进行处理；
（3）终止操作(终端操作)：一旦执行终止操作，就执行中间操作链，并产生结果。之后，不会再被使用；
详细步骤及API解读： 步骤一：创建操作，Stream实例化
1）1）方式一：通过集合
Collection 接口被扩展，提供了两个获取流 的方法:
default Stream&lt;E&gt; stream() : 返回一个顺序流default Stream&lt;E&gt; parallelStream() : 返回一个并行流 举例：Stream&lt;Employee&gt; stream = employees.stream();
2）方式二：通过数组
Arrays 的静态方法 stream() 可以获取数组流: static &lt;T&gt; Stream&lt;T&gt; stream(T[] array): 返回一个流 举例：
IntStream stream = Arrays.stream(arr);
Stream&lt;Employee&gt; stream = Arrays.stream(arr);
3）方式三：通过Stream的of()
可以调用Stream类静态方法 of(), 通过显示值创建一个 流。它可以接收任意数量的参数。
public static&lt;T&gt; Stream&lt;T&gt; of(T... values) : 返回一个流 4）方式四：创建无限流（了解，用得少）
可以使用静态方法 Stream.iterate() 和 Stream." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/33593fb8c5bb36d0843b137b1b168c2b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-05-26T15:59:32+08:00" />
<meta property="article:modified_time" content="2022-05-26T15:59:32+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">流式编程基础内容解读</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>内容讲解：</h3> 
<h4><strong>介绍：</strong></h4> 
<p>Stream相当于一个数据渠道，用于操作集合、数组等多种数据源所生成的元素序列</p> 
<p><strong>注意：</strong></p> 
<p>1、Stream 自己不会存储元素。</p> 
<p>2、Stream 不会改变源对象。相反，他们会返回一个持有结果的新Stream。</p> 
<p>3、Stream 操作是延迟执行的。这意味着他们会等到需要结果的时候才执行。</p> 
<h4><strong>Stream流步骤：</strong></h4> 
<p>（1）创建 Stream：一个数据源(如:集合、数组)，获取一个流；</p> 
<p>（2）中间操作：一个中间操作链，对数据源的数据进行处理；</p> 
<p>（3）终止操作(终端操作)：一旦执行终止操作，就执行中间操作链，并产生结果。之后，不会再被使用；</p> 
<h4>详细步骤及API解读：</h4> 
<p><strong>步骤一：创建操作，Stream实例化</strong></p> 
<p>1）1）方式一：通过集合</p> 
<p>Collection 接口被扩展，提供了两个获取流 的方法:</p> 
<ul><li>default Stream&lt;E&gt; stream() : 返回一个顺序流</li><li>default Stream&lt;E&gt; parallelStream() : 返回一个并行流</li></ul> 
<p>举例：Stream&lt;Employee&gt; stream = employees.stream();</p> 
<p>2）方式二：通过数组</p> 
<p>Arrays 的静态方法 stream() 可以获取数组流: </p> 
<ul><li>static &lt;T&gt; Stream&lt;T&gt; stream(T[] array): 返回一个流</li></ul> 
<p>举例：</p> 
<p>        IntStream stream = Arrays.stream(arr);</p> 
<p>        Stream&lt;Employee&gt; stream = Arrays.stream(arr);</p> 
<p>3）方式三：通过Stream的of()</p> 
<p>可以调用Stream类静态方法 of(), 通过显示值创建一个 流。它可以接收任意数量的参数。</p> 
<ul><li>public static&lt;T&gt; Stream&lt;T&gt; of(T... values) : 返回一个流</li></ul> 
<p>4）方式四：创建无限流（了解，用得少）</p> 
<p>可以使用静态方法 Stream.iterate() 和 Stream.generate(), 创建无限流</p> 
<ul><li>迭代：public static&lt;T&gt; Stream&lt;T&gt; iterate(final T seed, final UnaryOperator&lt;T&gt; f) </li><li>生成：public static&lt;T&gt; Stream&lt;T&gt; generate(Supplier&lt;T&gt; s)</li></ul> 
<p><strong>步骤二：中间操作</strong></p> 
<p>1）筛选与切片</p> 
<ul><li> <p>filter(Predicate p)：接收Lambda， 从流中排除某些元素</p> </li><li> <p>distinct()：筛选，通过流所生成元素的 hashCode() 和 equals() 去除重复元素</p> </li><li> <p>limit(long maxSize)：截断流，使其元素不超过给定数量</p> </li><li> <p>skip(long n)：跳过元素，返回一个扔掉了前n个元素的流。若流中元素不足n个，则返回一个空流。与limit(n) 互补</p> </li></ul> 
<p>2）映射</p> 
<ul><li> <p>map(Function f)：接收一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素。</p> </li><li> <p>mapToDouble(ToDoubleFunction f)：接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的 DoubleStream。</p> </li><li> <p>mapToInt(ToIntFunction f)：接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的 IntStream</p> </li><li> <p>mapToLong(ToLongFunction f)：接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的 LongStream</p> </li><li> <p>flatMap(Function f)：接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流</p> </li></ul> 
<p>3）排序</p> 
<ul><li> <p>sorted()：产生一个新流，其中按自然顺序排序</p> </li><li> <p>sorted(Comparator com)：产生一个新流，其中按比较器顺序排序</p> </li></ul> 
<p><strong>步骤三：终止操作</strong></p> 
<p>注意：流终止操作后，就不能再使用了</p> 
<p>1）匹配与查找</p> 
<ul><li> <p>allMatch(Predicate p)：检查是否匹配所有元素</p> </li><li> <p>anyMatch(Predicate p)：检查是否至少匹配一个元素</p> </li><li> <p>noneMatch(Predicate p)：检查是否没有匹配所有元素</p> </li><li> <p>findFirst()：返回第一个元素</p> </li><li> <p>findAny()：返回当前流中的任意元素</p> </li><li> <p>count()：返回流中元素总数</p> </li><li> <p>max(Comparator c)：返回流中最大值</p> </li><li> <p>min(Comparator c)：返回流中最小值</p> </li><li> <p>forEach(Consumer c)：内部迭代</p> </li></ul> 
<p>2）归约</p> 
<ul><li> <p>reduce(T iden, BinaryOperator b)：从初始值iden开始，将流中元素反复结合起来，得到一个值。返回 T</p> </li><li> <p>reduce(BinaryOperator b)：可以将流中元素反复结合起来，得到一 个值。返回 Optional&lt;T&gt;</p> </li></ul> 
<p>3）收集</p> 
<ul><li> <p>collect(Collector c)：将流转换为其他形式。接收一个Collector接口的实现，用于给Stream中元素做汇总的方法</p> </li></ul> 
<h3>试验demo：</h3> 
<p>要求：编写一个流式编程的demo</p> 
<p>实际做法：找了一道流式编程的题目，使用代码进行8个问题的回答，实际代码如下：</p> 
<pre><code class="language-java">import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Optional;

public class StreamDemo {

    private static List&lt;Transaction&gt; createTransactionList(){
        Trader trader1 = new Trader("wang", "北京");
        Trader trader2 = new Trader("li", "上海");
        Trader trader3 = new Trader("qian", "北京");

        List&lt;Transaction&gt; list = Arrays.asList(
                new Transaction(trader1,2011, 300),
                new Transaction(trader1, 2012, 1000),
                new Transaction(trader2, 2011, 400),
                new Transaction(trader2, 2012, 710),
                new Transaction(trader3, 2012, 700),
                new Transaction(trader3, 2012, 950)
        );

        return list;
    }

    //1. 找出 2011 年发生的所有交易， 并按交易额排序（从低到高）
    private static void test1(){
        List&lt;Transaction&gt; list = createTransactionList();
        list.stream()
                .filter((y) -&gt; y.getYear() == 2011)
                .sorted((s1,s2) -&gt; Integer.compare(s1.getValue(), s2.getValue()))
                .forEach(System.out::println);
    }

    //2. 交易员都在哪些不同的城市工作过
    private static void test2(){
        List&lt;Transaction&gt; list = createTransactionList();
        list.stream()
                .map((r) -&gt; r.getTrader().getCity())
                .distinct()
                .forEach(System.out::println);
    }

    //3. 查找所有来自北京的交易员，并按姓名排序
    private static void test3(){
        List&lt;Transaction&gt; list = createTransactionList();
        list.stream()
                .map(Transaction::getTrader)
                .filter((n) -&gt; n.getCity().equals("北京"))
                .distinct()
                .sorted((t1, t2) -&gt; t1.getName().compareTo(t2.getName()))
                .forEach(System.out::println);
    }

    //4. 返回所有交易员的姓名字符串，按字母顺序排序
    private static void test4(){
        List&lt;Transaction&gt; list = createTransactionList();
        list.stream()
                .map((p) -&gt; p.getTrader().getName())
                .distinct()
                .sorted(String::compareTo)
                .forEach(System.out::println);
    }

    //5. 有没有交易员是在北京工作的
    private static void test5(){
        List&lt;Transaction&gt; list = createTransactionList();
        list.stream()
                .map(Transaction::getTrader)
                .filter((p) -&gt; p.getCity().equals("北京"))
                .distinct()
                .forEach(System.out::println);
    }

    //6. 打印生活在北京的交易员的所有交易额
    private static void test6(){
        List&lt;Transaction&gt; list = createTransactionList();
        Optional&lt;Integer&gt; t = list.stream()
                .filter((p) -&gt; p.getTrader().getCity().equals("北京"))
                .map(Transaction::getValue)
                .reduce(Integer::sum);
        System.out.println(t.get());
    }

    //7. 所有交易中，最高的交易额是多少
    private static void test7(){
        List&lt;Transaction&gt; list = createTransactionList();
        Optional&lt;Integer&gt; optional = list.stream()
                .map(Transaction::getValue)
                .max(Integer::compare);
        System.out.println(optional.get());
    }

    //8. 找到交易额最小的交易
    private static void test8(){
        List&lt;Transaction&gt; list = createTransactionList();
        Optional&lt;Transaction&gt; first = list.stream()
                .sorted((s1, s2) -&gt; Integer.compare(s1.getValue(), s2.getValue()))
                .findFirst();
        System.out.println(first.get());
    }

    public static void main(String[] args) {
        test8();
    }
}
</code></pre> 
<p></p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0ca4cb92c0dd58b7d8968c93057b03fd/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">批量移动指定文件至指定文件夹</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/35cf081db0c2f47d9e67a2b8a1383ff6/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">医疗器械注册文件清单 2022.5.26</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>