<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java输入输出之File类 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Java输入输出之File类" />
<meta property="og:description" content="File类表示文件或目录的抽象路径名称。Java中的抽象路径名称和路径名称两个概念是针对跨平台需求而设计的，前者是路径的抽象、操作系统无关的表示，而后者是路径的与操作系统相关的表示。
抽象路径名称包含以下两个部分：
一个可选的依赖于系统的前缀字符串，例如盘符(D:)，UNIX根目录“\”和微软Windows的UNC命名惯例下的“\\”。一个0或多个字符串型的名称组成的序列。 第一个名称可能是一个路径名，或者是一个主机名（在微软Windows的UNC定义的路径名中）。每个后续的名称表示一个路径，最后一个名称表示一个路径或者是一个文件。没有前缀且名称序列为空的路径名称为空抽象路径名称。
抽象路径名称和路径名称之间的转换是依赖于系统。当抽象路径名被转换为路径名时，名字之间都由单独一个默认分割符分割。默认的名称分割符是由系统属性file.separator定义，并且可以通过File类的静态属性separator和separatorChar访问。当一个路径名称字符串被转换为一个抽象的路径名时，它包含的名称可以由默认名称分割符分割，或者由下层系统支持的任何其他的名称分割符分割。
无论是不是抽象的，路径都分为绝对路径和相对路径两类。绝对路径是提供了定位文件的完全信息的路径名。相对路径是以某一路径名为参照下的路径名。默认情况下，java.io包往往是使用以当前的用户路径（由系统属性user.dir决定）为参考的相对路径。
通过File类的getParent()方法可以获得当前路径的父路径，即包含该路径的最底层的路径。
File类的实例是不可更改的，即由File对象表示的抽象路径是不会改变的。
File类的参数 static String pathSeparator; static char pathSeparatorChar; 依赖于当前系统的路径分割符，前一个是字符串类型，后一个是字符型。
static String separator; static char separatorChar; 依赖于当前系统的默认名称分割符，前一个是字符串类型，后一个是字符型。
/** * Test the path separator and separator static field in File class */ import java.io.File; public class FileFieldTest { public static void main(String[] args) { System.out.println(&#34;path separator: &#34;&#43; File.pathSeparator); System.out.println(&#34;path separator(char): &#34; &#43; File.pathSeparatorChar); System.out.println(&#34;separator: &#34; &#43; File.separator); System.out.println(&#34;separator(char):&#34; &#43; File.separatorChar); } } 实验所用系统为ubuntu 14.04，输出如下图：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/10f1a8da5197d8e082eac2137e00dc87/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2015-11-04T13:53:38+08:00" />
<meta property="article:modified_time" content="2015-11-04T13:53:38+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java输入输出之File类</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>File类表示文件或目录的抽象路径名称。Java中的<a href="http://blog.csdn.net/yestotofu/article/details/5914439">抽象路径名称和路径名称</a>两个概念是针对跨平台需求而设计的，前者是路径的抽象、操作系统无关的表示，而后者是路径的与操作系统相关的表示。</p> 
<p>抽象路径名称包含以下两个部分：</p> 
<ol><li>一个可选的依赖于系统的前缀字符串，例如盘符(D:)，UNIX根目录“\”和微软Windows的UNC命名惯例下的“\\”。</li><li>一个0或多个字符串型的名称组成的序列。</li></ol> 
<p>第一个名称可能是一个路径名，或者是一个主机名（在微软Windows的UNC定义的路径名中）。每个后续的名称表示一个路径，最后一个名称表示一个路径或者是一个文件。没有前缀且名称序列为空的路径名称为空抽象路径名称。</p> 
<p>抽象路径名称和路径名称之间的转换是依赖于系统。当抽象路径名被转换为路径名时，名字之间都由单独一个默认分割符分割。默认的名称分割符是由系统属性file.separator定义，并且可以通过File类的静态属性separator和separatorChar访问。当一个路径名称字符串被转换为一个抽象的路径名时，它包含的名称可以由默认名称分割符分割，或者由下层系统支持的任何其他的名称分割符分割。</p> 
<p>无论是不是抽象的，路径都分为绝对路径和相对路径两类。绝对路径是提供了定位文件的完全信息的路径名。相对路径是以某一路径名为参照下的路径名。默认情况下，java.io包往往是使用以当前的用户路径（由系统属性user.dir决定）为参考的相对路径。</p> 
<p>通过File类的getParent()方法可以获得当前路径的父路径，即包含该路径的最底层的路径。</p> 
<p>File类的实例是不可更改的，即由File对象表示的抽象路径是不会改变的。</p> 
<h4 id="file类的参数">File类的参数</h4> 
<p>static String <strong>pathSeparator</strong>; <br> static char <strong>pathSeparatorChar</strong>; <br> 依赖于当前系统的路径分割符，前一个是字符串类型，后一个是字符型。</p> 
<p>static String <strong>separator</strong>; <br> static char <strong>separatorChar</strong>; <br> 依赖于当前系统的默认名称分割符，前一个是字符串类型，后一个是字符型。</p> 
<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-javadoc">/**
 * Test the path separator and separator static field in File class
 */</span>

<span class="hljs-keyword">import</span> java.io.File;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileFieldTest</span>
{<!-- --></span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(String[] args)
    {
        System.out.println(<span class="hljs-string">"path separator: "</span>+ File.pathSeparator);
        System.out.println(<span class="hljs-string">"path separator(char): "</span> + File.pathSeparatorChar);
        System.out.println(<span class="hljs-string">"separator: "</span> + File.separator);
        System.out.println(<span class="hljs-string">"separator(char):"</span> + File.separatorChar);
    }
}</code></pre> 
<p>实验所用系统为ubuntu 14.04，输出如下图：</p> 
<h4 id="file类的构造函数">File类的构造函数</h4> 
<p>File(File parent, String child); <br> 根据父抽象路径和子路径字符串创建一个File实例 <br> File(String pathname); <br> 根据指定的路径名称创建一个File实例 <br> File(String parent, String child); <br> 根据指定的路径名和子路径字符串创建一个File实例 <br> File(URI uri); <br> 根据文件的资源定位符创建File实例。</p> 
<h4 id="函数">函数</h4> 
<h5 id="查询函数">查询函数</h5> 
<p>boolean canExecute() <br> 测试该抽象路径所指的文件是否是可执行文件 <br> boolean canRead() <br> 测试该抽象路径所指的文件是否可读 <br> boolean canWrite() <br> 测试该抽象路径所指的文件是否可写 <br> boolean exists() <br> 测试该抽象路径所指的文件是否存在 <br> boolean isAbsolute() <br> 测试该抽象路径是否为绝对路径 <br> boolean isDirectory() <br> 测试该抽象路径指向的文件是否为目录 <br> boolean isFile() <br> 测试该抽象路径指向的文件是否为标准的文件 <br> boolean isHiddien() <br> 测试该抽象路径所指的文件是否是隐藏文件</p> 
<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-keyword">import</span> java.io.File;
<span class="hljs-keyword">import</span> java.util.Scanner;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileStatusQuery</span>
{<!-- --></span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(String[] args)
    {
        Scanner sc = <span class="hljs-keyword">new</span> Scanner(System.in);
        String filePathName = sc.nextLine();

        File file = <span class="hljs-keyword">new</span> File(filePathName);

        System.out.println(<span class="hljs-string">" canExecute: "</span> + file.canExecute());
        System.out.println(<span class="hljs-string">"    canRead: "</span> + file.canRead());
        System.out.println(<span class="hljs-string">"   canWrite: "</span> + file.canWrite());
        System.out.println(<span class="hljs-string">"     exists: "</span> + file.exists());
        System.out.println(<span class="hljs-string">" isAbsolute: "</span> + file.isAbsolute());
        System.out.println(<span class="hljs-string">"isDirectory: "</span> + file.isDirectory());
        System.out.println(<span class="hljs-string">"     isFile: "</span> + file.isFile());
        System.out.println(<span class="hljs-string">"   isHidden: "</span> + file.isHidden());
    }
}</code></pre> 
<h5 id="创建函数">创建函数</h5> 
<p>boolean createNewFile() <br> 当且仅当不存在同名的文件时，创建一个该抽象路径指向的新的空文件。 <br> static File createTempFile(String prefix, String suffix) <br> 在默认的临时目录中创建一个空文件，该文件的名称由两个输入的代表前缀和后缀的字符串生成。 <br> static File createTempFile(String prefix,String suffix,File directory) <br> 在制定的目录中存在一个空文件，该文件的名称由两个输入的代表前缀和后缀的字符串生成。 <br> boolean mkdir() <br> 创建由该抽象路径指向的目录 <br> boolean mkdirs() <br> 创建该抽象路径执行的目录，同时创建包含该目录且之前不存在的父目录。 <br> boolean delete() <br> 删除该抽象路径指向的文件或目录 <br> boolean deleteOnExit() <br> 请求当虚拟机退出时删除该抽象路径指向的文件或目录</p> 
<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-keyword">import</span> java.io.File;
<span class="hljs-keyword">import</span> java.util.Scanner;
<span class="hljs-keyword">import</span> java.io.IOException;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileCreation</span>
{<!-- --></span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(String[] args)
    {
        Scanner sc = <span class="hljs-keyword">new</span> Scanner(System.in);
        String inputPath = sc.nextLine();

        <span class="hljs-keyword">try</span>
        {
            File file = <span class="hljs-keyword">new</span> File(inputPath);
            <span class="hljs-keyword">if</span> (file.createNewFile())
            {
                System.out.println(<span class="hljs-string">"File creation succeeds! "</span>);
            }
            File tempFile = File.createTempFile(<span class="hljs-string">"Log"</span>, <span class="hljs-string">".log"</span>);
            System.out.println(<span class="hljs-string">"Temp file creation: Path"</span> + tempFile.getAbsolutePath());
            file.deleteOnExit();

            File tempFile2 = File.createTempFile(<span class="hljs-string">"Log"</span>, <span class="hljs-string">".log"</span>, <span class="hljs-keyword">new</span> File(<span class="hljs-string">"Hello"</span>));
            System.out.println(<span class="hljs-string">"Temp file createion: Path"</span> + tempFile2.getAbsolutePath());
            tempFile2.delete();

        }<span class="hljs-keyword">catch</span>(IOException e)
        {
            System.out.println(e.toString());
        }


        String dirName = sc.nextLine();
        File dir = <span class="hljs-keyword">new</span> File(dirName);
        <span class="hljs-keyword">if</span> (dir.mkdir())
        {
            System.out.println(<span class="hljs-string">"Dir creation succeeds!"</span>);
        }

        String longDirName = sc.nextLine();
        File longDir = <span class="hljs-keyword">new</span> File(longDirName);
        <span class="hljs-keyword">if</span>(longDir.mkdir())
        {
            System.out.println(<span class="hljs-string">"Long dir creation succeeds!"</span>);
        }<span class="hljs-keyword">else</span>
        {
            System.out.println(<span class="hljs-string">"Long dir creation fails!"</span>);
        }

        <span class="hljs-keyword">if</span>(longDir.mkdirs())
        {
            System.out.println(<span class="hljs-string">"Long dir creation succeeds!"</span>);
        }
    }
}</code></pre> 
<h5 id="getxx函数">getXX函数</h5> 
<p>File getAbsoluteFile() <br> 返回该抽象路径的绝对形式 <br> String getAbsolutePath() <br> 返回该抽象路径的绝对路径名 <br> File getCanonicalFile() <br> 返回该抽象路径的规范形式 <br> String getCanonicalPath() <br> 返回该抽象路径的规范形式名 <br> String getName() <br> 返回由该抽象路径所指的文件或路径的名称 <br> String getParent() <br> 返回该抽象路径的父路径的抽象路径名称。如果指定的路径名称中没有父目录，则返回null。 <br> File getParentFile() <br> 返回该抽象路径的父抽象路径。如果指定的路径名称中没有父目录，则返回null。 <br> File getPath() <br> 将抽象路径名转换为路径名。 <br> long getFreeSpace() <br> 返回该抽象路径所指分区的未分配字节数 <br> long getTotalSpace() <br> 返回该抽象路径所指分区的总字节数 <br> long getUsableSpace() <br> 返回该抽象路径所指分区的已用字节数</p> 
<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-keyword">import</span> java.io.File;
<span class="hljs-keyword">import</span> java.io.IOException;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileGetters</span>
{<!-- --></span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(String[] args)
    {
        File file = <span class="hljs-keyword">new</span> File(<span class="hljs-string">"Hello/hello1.test"</span>);
        File absoluteFile = file.getAbsoluteFile();
        System.out.println(<span class="hljs-string">"AbsoulteFile: "</span> + absoluteFile.getPath());
        String absolutePath = file.getAbsolutePath();
        System.out.println(<span class="hljs-string">"AbsolutePath: "</span> + absolutePath);
        <span class="hljs-keyword">try</span>{
            File canonicalFile = file.getCanonicalFile();
            System.out.println(<span class="hljs-string">"CanonicalFile: "</span> + canonicalFile.getPath());
            String canonicalPath = file.getCanonicalPath();
            System.out.println(<span class="hljs-string">"CanonicalPath: "</span> + canonicalPath);
        }<span class="hljs-keyword">catch</span>(IOException e)
        {
            System.out.println(e.toString());
        }
        System.out.println(<span class="hljs-string">"FileName: "</span> + file.getName());
        System.out.println(<span class="hljs-string">"Parent: "</span> + file.getParent());
        File parentFile = file.getParentFile();
        <span class="hljs-keyword">if</span> (parentFile != <span class="hljs-keyword">null</span>)
            System.out.println(<span class="hljs-string">"ParentFile： "</span> + parentFile.getPath());
        System.out.println(<span class="hljs-string">"++++++++++++++++++++++++++++++++++"</span>);
        System.out.println(<span class="hljs-string">"FreeSpace: "</span> + file.getFreeSpace());
        System.out.println(<span class="hljs-string">"TotalSpace: "</span> + file.getTotalSpace());
        System.out.println(<span class="hljs-string">"UsableSpace: "</span> + file.getUsableSpace());
    }
}</code></pre> 
<h5 id="setxx函数">setXX函数</h5> 
<p>boolean setExecutable( boolean executable) <br> 为该抽象路径设置执行权限的便利方法 <br> boolean setExecutable(boolean executable, boolean ownerOnly) <br> 为该抽象路径设置其拥有者或所有人的执行权限 <br> boolean setLastModified(long time) <br> 为该抽象路径指定的文件或目录设置最后修改时间 <br> boolean setReadable(boolean readable) <br> 为该抽象路径设置用户的读权限 <br> boolean setReadable(boolean readable, boolean ownerOnly) <br> 为该抽象路径设置其拥有者或所有人的读权限 <br> boolean setReadOnly() <br> 标志该文抽象路径指向的路径只允许读操作。 <br> boolean setWritable() <br> 为该抽象路径设置用户的写权限 <br> boolean setWritable(boolean writable, boolean ownerOnly); <br> 为该抽象路径设置其拥有者或所有人的写权限</p> 
<h5 id="list函数">list函数</h5> 
<p>String[] list() <br> 返回该抽象路径所指目录中的文件或目录的名称字符串矩阵 <br> String[] list(FilenameFilter filter) <br> 返回该抽象路径所指目录中满足filter的文件或目录的名称字符串矩阵 <br> File[] listFiles() <br> 返回该抽象路径所指目录中的抽象路径矩阵 <br> File[] listFiles(FileFilter filter) <br> 返回该抽象路径所指目录中满足filter的抽象路径矩阵 <br> File[] listFiles(FilenameFilter filter) <br> 返回该抽象路径所指目录中满足filter的抽象路径矩阵 <br> static File[] listRoots() <br> 列出所有文件系统可用的根目录</p> 
<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-keyword">import</span> java.io.File;
<span class="hljs-keyword">import</span> java.io.FilenameFilter;
<span class="hljs-keyword">import</span> java.io.FileFilter;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileLists</span>
{<!-- --></span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(String[] args)
    {
        File file = <span class="hljs-keyword">new</span> File(<span class="hljs-string">"./"</span>);
        <span class="hljs-keyword">for</span> (String subfileName : file.list())
            System.out.print(subfileName + <span class="hljs-string">" "</span>);
        System.out.println(<span class="hljs-string">""</span>);
        System.out.println(<span class="hljs-string">"------------------------"</span>);

        <span class="hljs-keyword">for</span> (File subfile : file.listFiles())
            System.out.print(subfile.getPath() + <span class="hljs-string">" "</span>);
        System.out.println(<span class="hljs-string">""</span>);

        System.out.println(<span class="hljs-string">"------------------------"</span>);
        <span class="hljs-keyword">for</span> (String subfileName : file.list(<span class="hljs-keyword">new</span> FilenameFilter()
            {
                <span class="hljs-annotation">@Override</span>
                <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">accept</span>(File dir, String name)
                {
                    <span class="hljs-keyword">if</span> (name.endsWith(<span class="hljs-string">".class"</span>))
                        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
                }
            }))
         {
             System.out.print(subfileName+<span class="hljs-string">" "</span>);
         }

        System.out.println(<span class="hljs-string">""</span>);

        System.out.println(<span class="hljs-string">"------------------------"</span>);

        <span class="hljs-keyword">for</span>(File subfile : file.listFiles(<span class="hljs-keyword">new</span> FileFilter()
            {
                <span class="hljs-annotation">@Override</span>
                <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">accept</span>(File pathname)
                {
                    <span class="hljs-keyword">if</span> (pathname.getPath().endsWith(<span class="hljs-string">".java"</span>))
                        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
                }
            }))
        {
            System.out.print(subfile.getPath() + <span class="hljs-string">" "</span>);
        }

        System.out.println(<span class="hljs-string">""</span>);

        System.out.println(<span class="hljs-string">"------------------------"</span>);

        <span class="hljs-keyword">for</span>(File subfile : file.listFiles(<span class="hljs-keyword">new</span> FilenameFilter()
            {
                <span class="hljs-annotation">@Override</span>
                <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">accept</span>(File dir, String name)
                {
                    <span class="hljs-keyword">if</span> (name.endsWith(<span class="hljs-string">".java"</span>))
                        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
                }
            }))
        {
            System.out.print(subfile.getPath() + <span class="hljs-string">" "</span>);
        }

        System.out.println(<span class="hljs-string">""</span>);

        System.out.println(<span class="hljs-string">"------------------------"</span>);

        <span class="hljs-keyword">for</span>(File subfile : File.listRoots())
        {
            System.out.print(subfile.getPath() + <span class="hljs-string">" "</span>);
        }
        System.out.println(<span class="hljs-string">""</span>);
    }
}</code></pre> 
<h5 id="其他常用函数">其他常用函数</h5> 
<p>long lastModified() <br> 该抽象路径所指文件的最后修改时间 <br> long length() <br> 该抽象路径所指文件的长度（字节） <br> boolean renameTo(File dest) <br> 重命名该抽象路径所指文件</p> 
<h4 id="原文">原文</h4> 
<p><a href="http://docs.oracle.com/javase/8/docs/api/" rel="nofollow">http://docs.oracle.com/javase/8/docs/api/</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7675ce6cae66c14bed49bc3d81c736cc/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">乐曲识别（版本检测）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/785b2dfd33d0e8bba717548dda839027/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">机器学习实战(k-近邻算法)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>