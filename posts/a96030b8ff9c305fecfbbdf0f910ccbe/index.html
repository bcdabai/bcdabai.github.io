<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Linux性能优化（一）——stress压力测试工具 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Linux性能优化（一）——stress压力测试工具" />
<meta property="og:description" content="一、stress简介 1、stress简介 stress是Linux的一个压力测试工具，可以对CPU、Memory、IO、磁盘进行压力测试。
2、stress安装 安装：
sudo yum install stress 二、stress使用 1、stress命令 stress [OPTION [ARG]] -c, --cpu N：产生N个进程，每个进程都循环调用sqrt函数产生CPU压力。
-i, --io N：产生N个进程，每个进程循环调用sync将内存缓冲区内容写到磁盘上，产生IO压力。通过系统调用sync刷新内存缓冲区数据到磁盘中，以确保同步。如果缓冲区内数据较少，写到磁盘中的数据也较少，不会产生IO压力。在SSD磁盘环境中尤为明显，很可能iowait总是0，却因为大量调用系统调用sync，导致系统CPU使用率sys 升高。
-m, --vm N：产生N个进程，每个进程循环调用malloc/free函数分配和释放内存。
--vm-bytes B：指定分配内存的大小
--vm-stride B：不断的给部分内存赋值，让COW(Copy On Write)发生
--vm-hang N ：指示每个消耗内存的进程在分配到内存后转入睡眠状态N秒，然后释放内存，一直重复执行这个过程
--vm-keep：一直占用内存，区别于不断的释放和重新分配(默认是不断释放并重新分配内存)
-d, --hdd N：产生N个不断执行write和unlink函数的进程(创建文件，写入内容，删除文件)
--hdd-bytes B：指定文件大小
--hdd-noclean：不要将写入随机ASCII数据的文件Unlink
-t, --timeout N：在N秒后结束程序 --backoff N：等待N微秒后开始运行
-q, --quiet：程序在运行的过程中不输出信息
-n, --dry-run：输出程序会做什么而并不实际执行相关的操作
--version：显示版本号
-v, --verbose：显示详细的信息
2、CPU测试 stress --cpu 2 --timeout 60 开启2个CPU进程执行sqrt计算，60秒后结束
3、IO测试 stress --io 2 --timeout 60s 开启2个IO进程，执行sync系统调用，刷新内存缓冲区到磁盘
使用stress无法模拟iowait升高，但sys升高。stress -i参数表示通过系统调用sync来模拟IO问题，但sync是刷新内存缓冲区数据到磁盘中，以确保同步。如果内存缓冲区内没多少数据，读写到磁盘中的数据也就不多，没法产生IO压力。使用SSD磁盘的环境中尤为明显，iowait一直为0，但因为大量系统调用，导致系统CPU使用率sys升高。
stress --io 2 --hdd 2 --timeout 60s 开启2个IO进程，2个磁盘IO进程" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/a96030b8ff9c305fecfbbdf0f910ccbe/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-02-23T12:43:19+08:00" />
<meta property="article:modified_time" content="2022-02-23T12:43:19+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Linux性能优化（一）——stress压力测试工具</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2 style="text-align:justify;"><strong><strong><strong>一、stress简介</strong></strong></strong></h2> 
<h4> <strong><strong><strong>1、stress简介</strong></strong></strong></h4> 
<p style="margin-left:.0001pt;text-align:justify;">stress是Linux的一个压力测试工具，可以对CPU、Memory、IO、磁盘进行压力测试。</p> 
<h4 style="text-align:justify;"><strong><strong><strong>2、stress安装</strong></strong></strong></h4> 
<p style="margin-left:.0001pt;text-align:justify;">安装：</p> 
<pre><code class="language-bash">sudo yum install stress</code></pre> 
<h3 style="text-align:justify;"><strong><strong><strong>二、stress使用</strong></strong></strong></h3> 
<h4 style="text-align:justify;"><strong><strong><strong>1、stress命令</strong></strong></strong></h4> 
<pre><code class="language-bash">stress [OPTION [ARG]]</code></pre> 
<p style="margin-left:.0001pt;text-align:justify;">-c, --cpu N：产生N个进程，每个进程都循环调用sqrt函数产生CPU压力。<br> -i, --io N：产生N个进程，每个进程循环调用sync将内存缓冲区内容写到磁盘上，产生IO压力。通过系统调用sync刷新内存缓冲区数据到磁盘中，以确保同步。如果缓冲区内数据较少，写到磁盘中的数据也较少，不会产生IO压力。在SSD磁盘环境中尤为明显，很可能iowait总是0，却因为大量调用系统调用sync，导致系统CPU使用率sys 升高。<br> -m, --vm N：产生N个进程，每个进程循环调用malloc/free函数分配和释放内存。<br>     --vm-bytes B：指定分配内存的大小<br>     --vm-stride B：不断的给部分内存赋值，让COW(Copy On Write)发生<br>     --vm-hang N ：指示每个消耗内存的进程在分配到内存后转入睡眠状态N秒，然后释放内存，一直重复执行这个过程<br>     --vm-keep：一直占用内存，区别于不断的释放和重新分配(默认是不断释放并重新分配内存)<br> -d, --hdd N：产生N个不断执行write和unlink函数的进程(创建文件，写入内容，删除文件)<br>     --hdd-bytes B：指定文件大小</p> 
<p style="margin-left:.0001pt;text-align:justify;">--hdd-noclean：不要将写入随机ASCII数据的文件Unlink<br> -t, --timeout N：在N秒后结束程序        <br> --backoff N：等待N微秒后开始运行<br> -q, --quiet：程序在运行的过程中不输出信息<br> -n, --dry-run：输出程序会做什么而并不实际执行相关的操作<br> --version：显示版本号<br> -v, --verbose：显示详细的信息</p> 
<h4 style="text-align:justify;"><strong><strong><strong>2、CPU测试</strong></strong></strong></h4> 
<pre><code class="language-bash">stress --cpu 2 --timeout 60</code></pre> 
<p style="margin-left:.0001pt;text-align:justify;">开启2个CPU进程执行sqrt计算，60秒后结束</p> 
<p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="185" src="https://images2.imgbox.com/f1/3b/Jb4Sq97z_o.png" width="554"></p> 
<h4 style="margin-left:.0001pt;text-align:justify;"><strong><strong><strong>3、IO测试</strong></strong></strong></h4> 
<pre><code class="language-bash">stress --io 2 --timeout 60s</code></pre> 
<p style="margin-left:.0001pt;text-align:justify;">开启2个IO进程，执行sync系统调用，刷新内存缓冲区到磁盘</p> 
<p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="183" src="https://images2.imgbox.com/02/5d/FdOQK1yK_o.png" width="554"></p> 
<p style="margin-left:.0001pt;text-align:justify;">使用stress无法模拟iowait升高，但sys升高。stress -i参数表示通过系统调用sync来模拟IO问题，但sync是刷新内存缓冲区数据到磁盘中，以确保同步。如果内存缓冲区内没多少数据，读写到磁盘中的数据也就不多，没法产生IO压力。使用SSD磁盘的环境中尤为明显，iowait一直为0，但因为大量系统调用，导致系统CPU使用率sys升高。</p> 
<pre><code class="language-bash">stress --io 2 --hdd 2 --timeout 60s</code></pre> 
<p style="margin-left:.0001pt;text-align:justify;">开启2个IO进程，2个磁盘IO进程</p> 
<p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="184" src="https://images2.imgbox.com/7d/7c/j9qSRFRo_o.png" width="554"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong><strong>4、Memory测试</strong></strong></strong></p> 
<pre><code class="language-bash">stress --vm 2 --vm-bytes 1G --vm-hang 100 --timeout 100s</code></pre> 
<p style="margin-left:.0001pt;text-align:justify;">开启2个进程分配内存，每次分配1GB内存，保持100秒后释放，100秒后退出。</p> 
<p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="202" src="https://images2.imgbox.com/c3/5d/dZB7tKga_o.png" width="554"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong><strong>5、磁盘IO测试</strong></strong></strong></p> 
<pre><code class="language-bash">stress --hdd 2 --hdd-bytes 10G --backoff 2000000</code></pre> 
<p style="margin-left:.0001pt;text-align:justify;">开启2个磁盘IO进程，每次写10GB数据到磁盘</p> 
<p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="149" src="https://images2.imgbox.com/0c/c4/FP0AAnOb_o.png" width="554"></p> 
<h3 style="margin-left:.0001pt;text-align:justify;"><strong><strong><strong>三、stress测试场景</strong></strong></strong></h3> 
<h4 style="text-align:justify;"><strong><strong><strong>1、CPU密集型进程</strong></strong></strong></h4> 
<pre><code class="language-bash">stress --cpu 2 --timeout 600</code></pre> 
<p style="margin-left:.0001pt;text-align:justify;">模拟启动2个CPU密集型进程</p> 
<pre><code class="language-bash">uptime</code></pre> 
<p style="margin-left:.0001pt;text-align:justify;">查看系统平均负载，如下：</p> 
<p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="63" src="https://images2.imgbox.com/39/c3/eaSZ9W7F_o.png" width="554"></p> 
<pre><code class="language-bash">mpstat -P ALL 5 1</code></pre> 
<p style="margin-left:.0001pt;text-align:justify;">查看CPU使用情况，如下：</p> 
<p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="107" src="https://images2.imgbox.com/e7/aa/7XsxrtQ5_o.png" width="554"></p> 
<pre><code class="language-bash">pidstat -u 5</code></pre> 
<p style="margin-left:.0001pt;text-align:justify;">查看进程负载情况，如下：</p> 
<p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="231" src="https://images2.imgbox.com/d9/3e/ysFCap8I_o.png" width="554"></p> 
<p style="margin-left:.0001pt;text-align:justify;">（1）通过uptime可以观察系统平均负载较高。</p> 
<p style="margin-left:.0001pt;text-align:justify;">（2）通过mpstat观察到CPU0和CPU2的用户态CPU使用率很高，而iowait为0，说明进程是CPU密集型。进程使用CPU密集导致系统平均负载变高、CPU使用率变高。</p> 
<p style="margin-left:.0001pt;text-align:justify;">（3）可以通过pidstat查看是stress进程导致CPU使用率较高。</p> 
<h4 style="text-align:justify;"><strong><strong><strong>2、IO密集型进程</strong></strong></strong></h4> 
<pre><code class="language-bash">stress -i 1 --hdd 1 --timeout 600</code></pre> 
<p style="margin-left:.0001pt;text-align:justify;">模拟1个worker调用sync刷新内存缓冲区write到磁盘。</p> 
<p style="margin-left:.0001pt;text-align:justify;">uptime</p> 
<p style="margin-left:.0001pt;text-align:justify;">查看系统平均负载，如下：</p> 
<p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="77" src="https://images2.imgbox.com/72/bb/N61IaYLC_o.png" width="554"></p> 
<pre><code class="language-bash">mpstat -P ALL 5</code></pre> 
<p style="margin-left:.0001pt;text-align:justify;">查看CPU使用情况，如下：</p> 
<p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="105" src="https://images2.imgbox.com/f8/39/XCAyejDW_o.png" width="553"></p> 
<p style="margin-left:.0001pt;text-align:justify;">（1）可以通过uptime观察到，系统平均负载很高。</p> 
<p style="margin-left:.0001pt;text-align:justify;">（2）通过mpstat观察到内核态CPU使用率很低，但iowait很高，一直在等待IO处理，说明进程是IO密集型。进程频繁进行IO操作，导致系统平均负载很高而CPU使用率不高。</p> 
<h4 style="text-align:justify;"><strong><strong><strong>3、等待CPU进程</strong></strong></strong></h4> 
<p style="margin-left:.0001pt;text-align:justify;">本机4个逻辑CPU，模拟8个进程。</p> 
<pre><code class="language-bash">stress -c 8 --timeout 600</code></pre> 
<p style="margin-left:.0001pt;text-align:justify;">模拟8个CPU密集型进程</p> 
<pre><code class="language-bash">uptime</code></pre> 
<p style="margin-left:.0001pt;text-align:justify;">查看系统平均负载，如下：</p> 
<p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="63" src="https://images2.imgbox.com/30/20/zIGaZInN_o.png" width="554"></p> 
<pre><code class="language-bash">mpstat -P ALL 5</code></pre> 
<p style="margin-left:.0001pt;text-align:justify;">查看CPU使用率情况，如下：</p> 
<p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="107" src="https://images2.imgbox.com/e5/90/maMJzhjB_o.png" width="553"></p> 
<pre><code class="language-bash">pidstat -u 5</code></pre> 
<p style="margin-left:.0001pt;text-align:justify;">查看进程的CPU使用情况，如下：</p> 
<p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="324" src="https://images2.imgbox.com/b6/36/jbc9cihW_o.png" width="554"></p> 
<p style="margin-left:.0001pt;text-align:justify;">（1）通过uptime观察到系统平均负载很高</p> 
<p style="margin-left:.0001pt;text-align:justify;">（2）通过mpstat观察到用户态CPU使用率很高，iowait为0，说明进程是CPU密集型或者进程间存在CPU争用。</p> 
<p style="margin-left:.0001pt;text-align:justify;">（3）通过pidstat观察到wait指标很高，说明进程间存在CPU争用，系统中存在大量进程在等待使用CPU。</p> 
<h3 style="text-align:justify;"><strong><strong><strong>四、stress-ng简介</strong></strong></strong></h3> 
<h4 style="text-align:justify;"><strong><strong><strong>1、stress-ng简介</strong></strong></strong></h4> 
<p style="margin-left:.0001pt;text-align:justify;">stress-ng完全兼容stress, 并且在stress基础上增加数百个选项参数，支持产生各种复杂的压力。</p> 
<h4 style="text-align:justify;"><strong><strong><strong>2、stress-ng安装</strong></strong></strong></h4> 
<p style="margin-left:.0001pt;text-align:justify;">stress-ng源码下载：</p> 
<p style="margin-left:.0001pt;text-align:justify;">https://kernel.ubuntu.com/~cking/tarballs/stress-ng/</p> 
<p style="margin-left:.0001pt;text-align:justify;">编译：</p> 
<pre><code class="language-bash">make</code></pre> 
<p style="margin-left:.0001pt;text-align:justify;">安装：</p> 
<pre><code class="language-bash">sudo make install</code></pre> 
<h4 style="text-align:justify;"><strong><strong><strong>3、stress-ng命令</strong></strong></strong></h4> 
<pre><code class="language-bash">stress-ng [OPTION [ARG]]

stress-ng --cpu 2 --cpu-method pi</code></pre> 
<p style="margin-left:.0001pt;text-align:justify;">产生2个worker做圆周率算法压力</p> 
<pre><code class="language-bash">stress-ng --cpu 2 --cpu-method all</code></pre> 
<p style="margin-left:.0001pt;text-align:justify;">产生2个worker迭代使用30多种不同的压力算法，包括pi, crc16, fft等</p> 
<pre><code class="language-bash">stress-ng --sock 2</code></pre> 
<p style="margin-left:.0001pt;text-align:justify;">产生2个worker调用socket相关函数产生压力</p> 
<pre><code class="language-bash">stress-ng --tsc 2</code></pre> 
<p style="margin-left:.0001pt;text-align:justify;">产生2个worker读取tsc产生压力</p> 
<pre><code class="language-bash">stress-ng --sock 4 --taskset 0-1,3</code></pre> 
<p style="margin-left:.0001pt;text-align:justify;">strss-ng将压力指定到指定CPU上</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4f6532a920add8b3d29936174a37ce91/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">pytorch（仅供自己参考勿看）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/735a7217bf2b674760783544e6b8ca8a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Java基础--单重循环操作题（例题说明易错点）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>