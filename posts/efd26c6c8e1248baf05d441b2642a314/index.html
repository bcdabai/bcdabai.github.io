<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>NIO核心依赖多路复用小记 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="NIO核心依赖多路复用小记" />
<meta property="og:description" content="NIO允许一个线程同时处理多个连接，而不会因为一个连接的阻塞而导致其他连接被阻塞。核心是依赖操作系统的多路复用机制。
操作系统的多路复用机制 多路复用是一种操作系统的 I/O 处理机制，允许单个进程（或线程）同时监视多个输入或输出流的就绪状态。这样，一个进程就能够通过一个系统调用来等待多个事件，而不是为每个事件创建一个独立的进程或线程。
多路复用常见机制 select： select 是一个系统调用，通过它可以同时监视多个文件描述符（通常是套接字）。当其中任何一个文件描述符准备好进行读取或写入时，select 就会返回，并告诉程序哪些文件描述符处于就绪状态。
poll： poll 也是一个系统调用，它和 select 类似，但是对文件描述符的管理更加灵活，而且没有文件描述符数目的限制。
epoll： epoll 是 Linux 中引入的一种多路复用机制，相对于 select 和 poll 具有更好的性能。epoll 使用事件通知的方式，只关心那些发生了变化的文件描述符，减少了遍历全部文件描述符的开销。
网络请求的流程 当客户端请求到达服务器时，整个流程可以分为以下几个步骤，涉及用户态和内核态的协同工作：
服务器启动： 服务器程序在用户态中启动，并创建一个监听 socket。这个监听 socket 负责接收客户端的连接请求。
监听连接： 服务器使用 select 或其他多路复用的系统调用，将监听 socket 添加到文件描述符集合中，然后阻塞等待事件发生。这时用户程序告诉内核要监听哪些文件描述符，而这些文件描述符通常是由 accept 等系统调用返回的新连接。
客户端连接： 当有客户端发起连接请求时，内核接收到连接请求，然后将新的连接 socket（客户端连接的文件描述符）添加到文件描述符集合中。此时内核通知用户程序，有文件描述符就绪。
处理连接： 用户程序从 select 返回后，检查文件描述符集合，确定哪些连接处于就绪状态。然后，用户程序可以通过 accept 接受新的连接，获得新的文件描述符，并处理与客户端的通信。
下面是一个简化的伪代码示例：
// 服务器启动 int listen_fd = create_and_bind_socket(port); listen(listen_fd, SOMAXCONN); // 设置监听 socket 到文件描述符集合 fd_set master_fds; FD_ZERO(&amp;master_fds); FD_SET(listen_fd, &amp;master_fds); int max_fd = listen_fd; while (true) { fd_set read_fds = master_fds; // 使用 select 监听文件描述符 int ready = select(max_fd &#43; 1, &amp;read_fds, NULL, NULL, NULL); if (ready == -1) { // 处理错误 } else { // 检查文件描述符集合，确定哪些连接就绪 for (int i = 0; i &lt;= max_fd; &#43;&#43;i) { if (FD_ISSET(i, &amp;read_fds)) { if (i == listen_fd) { // 有新连接 int new_fd = accept(listen_fd, ." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/efd26c6c8e1248baf05d441b2642a314/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-11T10:22:33+08:00" />
<meta property="article:modified_time" content="2024-01-11T10:22:33+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">NIO核心依赖多路复用小记</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>NIO允许一个线程同时处理多个连接，而不会因为一个连接的阻塞而导致其他连接被阻塞。核心是依赖操作系统的<code>多路复用</code>机制。</p> 
<h3><a id="_2"></a>操作系统的多路复用机制</h3> 
<p>多路复用是一种操作系统的 I/O 处理机制，允许单个进程（或线程）同时监视多个输入或输出流的就绪状态。这样，一个进程就能够通过一个系统调用来等待多个事件，而不是为每个事件创建一个独立的进程或线程。</p> 
<h4><a id="_5"></a>多路复用常见机制</h4> 
<ol><li> <p><strong>select：</strong> <code>select</code> 是一个系统调用，通过它可以同时监视多个文件描述符（通常是套接字）。当其中任何一个文件描述符准备好进行读取或写入时，<code>select</code> 就会返回，并告诉程序哪些文件描述符处于就绪状态。</p> </li><li> <p><strong>poll：</strong> <code>poll</code> 也是一个系统调用，它和 <code>select</code> 类似，但是对文件描述符的管理更加灵活，而且没有文件描述符数目的限制。</p> </li><li> <p><strong>epoll：</strong> <code>epoll</code> 是 Linux 中引入的一种多路复用机制，相对于 <code>select</code> 和 <code>poll</code> 具有更好的性能。<code>epoll</code> 使用事件通知的方式，只关心那些发生了变化的文件描述符，减少了遍历全部文件描述符的开销。</p> </li></ol> 
<h4><a id="_12"></a>网络请求的流程</h4> 
<p>当客户端请求到达服务器时，整个流程可以分为以下几个步骤，涉及用户态和内核态的协同工作：</p> 
<ol><li> <p><strong>服务器启动：</strong> 服务器程序在用户态中启动，并创建一个监听 socket。这个监听 socket 负责接收客户端的连接请求。</p> </li><li> <p><strong>监听连接：</strong> 服务器使用 <code>select</code> 或其他多路复用的系统调用，将监听 socket 添加到文件描述符集合中，然后阻塞等待事件发生。这时用户程序告诉内核要监听哪些文件描述符，而这些文件描述符通常是由 <code>accept</code> 等系统调用返回的新连接。</p> </li><li> <p><strong>客户端连接：</strong> 当有客户端发起连接请求时，内核接收到连接请求，然后将新的连接 socket（客户端连接的文件描述符）添加到文件描述符集合中。此时内核通知用户程序，有文件描述符就绪。</p> </li><li> <p><strong>处理连接：</strong> 用户程序从 <code>select</code> 返回后，检查文件描述符集合，确定哪些连接处于就绪状态。然后，用户程序可以通过 <code>accept</code> 接受新的连接，获得新的文件描述符，并处理与客户端的通信。</p> </li></ol> 
<p>下面是一个简化的伪代码示例：</p> 
<pre><code class="prism language-c"><span class="token comment">// 服务器启动</span>
<span class="token keyword">int</span> listen_fd <span class="token operator">=</span> <span class="token function">create_and_bind_socket</span><span class="token punctuation">(</span>port<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">listen</span><span class="token punctuation">(</span>listen_fd<span class="token punctuation">,</span> SOMAXCONN<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 设置监听 socket 到文件描述符集合</span>
fd_set master_fds<span class="token punctuation">;</span>
<span class="token function">FD_ZERO</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>master_fds<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">FD_SET</span><span class="token punctuation">(</span>listen_fd<span class="token punctuation">,</span> <span class="token operator">&amp;</span>master_fds<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> max_fd <span class="token operator">=</span> listen_fd<span class="token punctuation">;</span>

<span class="token keyword">while</span> <span class="token punctuation">(</span>true<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    fd_set read_fds <span class="token operator">=</span> master_fds<span class="token punctuation">;</span>
    
    <span class="token comment">// 使用 select 监听文件描述符</span>
    <span class="token keyword">int</span> ready <span class="token operator">=</span> <span class="token function">select</span><span class="token punctuation">(</span>max_fd <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>read_fds<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>ready <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 处理错误</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 检查文件描述符集合，确定哪些连接就绪</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> max_fd<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">FD_ISSET</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token operator">&amp;</span>read_fds<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> listen_fd<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                    <span class="token comment">// 有新连接</span>
                    <span class="token keyword">int</span> new_fd <span class="token operator">=</span> <span class="token function">accept</span><span class="token punctuation">(</span>listen_fd<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token function">FD_SET</span><span class="token punctuation">(</span>new_fd<span class="token punctuation">,</span> <span class="token operator">&amp;</span>master_fds<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>new_fd <span class="token operator">&gt;</span> max_fd<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                        max_fd <span class="token operator">=</span> new_fd<span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
                    <span class="token comment">// 有数据可读</span>
                    <span class="token function">handle_data</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>在这个示例中，<code>listen_fd</code> 是监听 socket 的文件描述符，当有新的连接到达时，会使用 <code>accept</code> 获得新的文件描述符，然后将其添加到文件描述符集合中。<code>select</code> 会在有文件描述符就绪时返回，用户程序通过检查文件描述符集合确定哪些连接可以进行处理。</p> 
<p>这个监听 socket 并不是客户端的连接请求，而是用于接受客户端连接的准备工作。客户端连接请求是在客户端发起连接时生成的。</p> 
<h4><a id="_70"></a>文件描述符</h4> 
<h5><a id="UnixLinux_71"></a>在类Unix/Linux系统中，一切皆文件，包括网络连接。</h5> 
<blockquote> 
 <p>文件描述符（File Descriptor）是用于标识已打开文件或I/O资源的整数。对于网络连接，文件描述符是内核用于跟踪每个连接的标识符。当一个客户端连接到服务器时，内核为这个连接分配一个文件描述符，通过这个文件描述符，内核能够管理和操作与客户端之间的I/O操作。</p> 
</blockquote> 
<h5><a id="_73"></a>连接的表示</h5> 
<blockquote> 
 <p>在 Linux 系统下，客户端与服务器之间的连接通常被抽象为文件描述符。这是因为内核为每个连接分配了一个文件描述符，通过这个文件描述符可以进行对应连接的读、写等I/O操作。文件描述符是一种通用的抽象，通过它，可以使用相同的接口进行文件、网络连接等各种I/O操作。</p> 
</blockquote> 
<h5><a id="File_Descriptor_75"></a>文件描述符（File Descriptor）并不是一个真正的文件</h5> 
<blockquote> 
 <p>在 Linux 下，文件描述符（File Descriptor）并不是一个真正的文件，而是一个整数，用于标识已打开文件或 I/O 资源。每个客户端连接到服务器时，内核会为该连接分配一个文件描述符。这个文件描述符在内核中用于跟踪和管理该连接的相关信息，包括读写数据等 I/O 操作。<br> Linux 内核并不会创建一个真正的文件来存放客户端的请求内容、客户端的 IP 和端口等信息。相反，它在内核中维护了一个数据结构来表示每个连接的状态，这个数据结构包含了与连接相关的信息。这个信息通常被称为 socket（套接字），是用于在网络上进行通信的抽象。<br> 当客户端发起连接时，内核会分配一个 socket，并分配一个文件描述符用于标识这个 socket。该文件描述符被传递给用户程序，用户程序可以通过这个文件描述符进行对应连接的读写操作。客户端的 IP 地址和端口等信息通常可以通过相应的系统调用获取，而不是通过创建一个文件。<br> 总之，Linux 中的文件描述符不是一个实际的文件，而是用于标识和操作已打开的 I/O 资源，其中包括网络连接。相关的信息则在内核中以 socket 的形式存在，而不是在文件中。</p> 
</blockquote> 
<h4><a id="_81"></a>用户态和内核态</h4> 
<p>在操作系统中，用户态（User Mode）和内核态（Kernel Mode）是指操作系统与应用程序之间的两个不同的运行级别或权限级别。这两个模式之间的切换是由操作系统内核控制的，而且涉及到处理器的特权级别。</p> 
<ol><li> <p><strong>用户态（User Mode）：</strong></p> 
  <ul><li>在用户态运行的是应用程序代码。在这个级别下，应用程序只能访问自己的内存空间，不能直接访问操作系统的内核空间。</li><li>用户态的应用程序不能执行一些特权指令，例如直接访问硬件设备或执行特定的系统管理任务。</li></ul> </li><li> <p><strong>内核态（Kernel Mode）：</strong></p> 
  <ul><li>内核态是操作系统内核运行的级别。在这个级别下，操作系统具有较高的特权，可以执行所有指令，包括直接访问硬件设备、修改系统控制寄存器等。</li><li>操作系统内核负责管理系统的资源，处理中断、异常和系统调用，以及执行一些特权操作。</li></ul> </li><li> <p><strong>切换：</strong></p> 
  <ul><li>当应用程序需要执行一些特权操作（例如打开一个文件、发送网络数据等）时，就需要从用户态切换到内核态。这个切换是通过系统调用（System Call）来触发的。</li><li>当发生中断、异常或系统调用时，处理器会从用户态切换到内核态，执行相应的内核代码。完成后，再切换回用户态继续执行应用程序代码。</li></ul> </li><li> <p><strong>切换的目的：</strong></p> 
  <ul><li>切换到内核态的目的是为了执行一些需要较高权限或操作系统特权的任务，例如管理系统资源、执行设备驱动程序等。</li><li>切换回用户态后，应用程序可以继续执行。这种切换的目的是为了保护系统的安全性和稳定性，防止应用程序直接访问敏感的系统资源。</li></ul> </li></ol> 
<p>总的来说，用户态和内核态的划分是为了保障系统的安全性和稳定性，确保应用程序不能随意访问和修改系统的关键资源。用户态和内核态之间的切换是由操作系统内核控制的，它会根据需要在两者之间进行切换。</p> 
<h5><a id="_102"></a>文件描述符集合</h5> 
<p>在用户态，通过 <code>select</code> 系统调用的参数中的文件描述符集合（通常是 <code>fd_set</code>）来告诉内核要监听哪些文件描述符。<code>fd_set</code> 是一个数据结构，它使用一个位图来表示文件描述符的状态，每个位表示一个文件描述符。</p> 
<p>在调用 <code>select</code> 时，用户程序会将自己关心的文件描述符添加到 <code>fd_set</code> 中。在 <code>select</code> 返回后，用户程序可以检查 <code>fd_set</code> 来确定哪些文件描述符处于就绪状态。就绪状态通常表示有数据可读、有数据可写或者发生了错误。</p> 
<p>下面是一个简化的示例：</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/select.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    fd_set read_fds<span class="token punctuation">;</span>
    <span class="token function">FD_ZERO</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>read_fds<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">int</span> sockfd <span class="token operator">=</span> <span class="token comment">/* 创建并设置socket描述符 */</span><span class="token punctuation">;</span>
    <span class="token function">FD_SET</span><span class="token punctuation">(</span>sockfd<span class="token punctuation">,</span> <span class="token operator">&amp;</span>read_fds<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 设置超时时间为5秒</span>
    <span class="token keyword">struct</span> <span class="token class-name">timeval</span> timeout<span class="token punctuation">;</span>
    timeout<span class="token punctuation">.</span>tv_sec <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
    timeout<span class="token punctuation">.</span>tv_usec <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

    <span class="token comment">// 调用select，监听文件描述符</span>
    <span class="token keyword">int</span> ready <span class="token operator">=</span> <span class="token function">select</span><span class="token punctuation">(</span>sockfd <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>read_fds<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>timeout<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>ready <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 处理错误</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>ready <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 超时</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 检查read_fds，确定哪些文件描述符就绪</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">FD_ISSET</span><span class="token punctuation">(</span>sockfd<span class="token punctuation">,</span> <span class="token operator">&amp;</span>read_fds<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">// sockfd 就绪，可以进行读操作</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>在这个示例中，通过 <code>FD_SET</code> 将 <code>sockfd</code> 添加到 <code>read_fds</code> 中，然后调用 <code>select</code> 来监听这个文件描述符。当 <code>select</code> 返回后，通过检查 <code>FD_ISSET</code> 可以确定 <code>sockfd</code> 是否处于就绪状态，进而进行相应的操作。</p> 
<p>用户程序在调用 <code>select</code> 之前，需要设置好相应的文件描述符集合，并在 <code>select</code> 返回后，根据就绪状态进行处理。这种方式允许用户程序选择性地监听和处理多个文件描述符。</p> 
<blockquote> 
 <p>学习打卡：Java学习笔记-day04-NIO核心依赖多路复用小记</p> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7a9c4b0ef1ec8c8c931b04134b5a6c5c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">响应式编程Reactor优化Callback回调地狱</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/53fc95d820baea17363db07eb755e0d3/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">类名.this：内部类引用外部类实例</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>