<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>匿名内部类 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="匿名内部类" />
<meta property="og:description" content="目 录 匿名内部类是局部内部类的一种简化形式.本质上是一个对象,是实现了该接口或继承了该抽象类的子类对象.
语法格式： new 类名或者接口名(){ 重写方法; } ;
给匿名内部类名命: 虽然这是匿名内部类,但是仍然可以利用多态来给匿名内部类名命的哈!
匿名内部类的好处: 匿名内部类，经常作为参数，或返回值，使用比较方便。
一个类中可以嵌套一个接口:
匿名内部类是局部内部类的一种简化形式.本质上是一个对象,是实现了该接口或继承了该抽象类的子类对象. 语法格式：
new 类名或者接口名(){
重写方法;
} ; public class MyTest { public static void main(String[] args) { new Father() { //new了一个父类抽象类的子类对象.匿名的 @Override //重写了父类中的抽象方法 public void hehe() { System.out.println(&#34;呵呵呵呵呵呵&#34;); } }; //创建了父类的子类对象并且调用重写后的方法 new Father() { @Override public void hehe() { System.out.println(&#34;44444444444444&#34;); } }.hehe(); } } abstract class Father { public abstract void hehe(); } 给匿名内部类名命: 虽然这是匿名内部类,但是仍然可以利用多态来给匿名内部类名命的哈! public class MyTest { public static void main(String[] args) { //匿名内部类 new AA() { @Override public void aa() { System." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/51062481901d07708cee8685b8dd7079/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-04-20T14:35:51+08:00" />
<meta property="article:modified_time" content="2022-04-20T14:35:51+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">匿名内部类</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3 id="main-toc" style="text-align:center;"><span style="color:#faa572;"><strong>目   <img alt="" height="57" src="https://images2.imgbox.com/74/79/hMzHkyb4_o.gif" width="57">   录</strong></span></h3> 
<p id="%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E6%98%AF%E5%B1%80%E9%83%A8%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E4%B8%80%E7%A7%8D%E7%AE%80%E5%8C%96%E5%BD%A2%E5%BC%8F.%E6%9C%AC%E8%B4%A8%E4%B8%8A%E6%98%AF%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%2C%E6%98%AF%E5%AE%9E%E7%8E%B0%E4%BA%86%E8%AF%A5%E6%8E%A5%E5%8F%A3%E6%88%96%E7%BB%A7%E6%89%BF%E4%BA%86%E8%AF%A5%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%AD%90%E7%B1%BB%E5%AF%B9%E8%B1%A1.-toc" style="margin-left:80px;"><span style="color:#faa572;"><strong><img alt="" src="https://images2.imgbox.com/3e/50/aI2i1vxO_o.gif"></strong></span><a href="#%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E6%98%AF%E5%B1%80%E9%83%A8%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E4%B8%80%E7%A7%8D%E7%AE%80%E5%8C%96%E5%BD%A2%E5%BC%8F.%E6%9C%AC%E8%B4%A8%E4%B8%8A%E6%98%AF%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%2C%E6%98%AF%E5%AE%9E%E7%8E%B0%E4%BA%86%E8%AF%A5%E6%8E%A5%E5%8F%A3%E6%88%96%E7%BB%A7%E6%89%BF%E4%BA%86%E8%AF%A5%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%AD%90%E7%B1%BB%E5%AF%B9%E8%B1%A1." rel="nofollow">匿名内部类是局部内部类的一种简化形式.本质上是一个对象,是实现了该接口或继承了该抽象类的子类对象.</a></p> 
<p id="%E8%AF%AD%E6%B3%95%E6%A0%BC%E5%BC%8F%EF%BC%9A%C2%A0%C2%A0%20%C2%A0new%20%E7%B1%BB%E5%90%8D%E6%88%96%E8%80%85%E6%8E%A5%E5%8F%A3%E5%90%8D()%7B%C2%A0%C2%A0%20%C2%A0%C2%A0%C2%A0%20%C2%A0%E9%87%8D%E5%86%99%E6%96%B9%E6%B3%95%3B%C2%A0%C2%A0%20%C2%A0%7D%20%3B-toc" style="margin-left:80px;"><span style="color:#faa572;"><strong><img alt="" src="https://images2.imgbox.com/5d/4c/kncQZzaZ_o.gif"></strong></span><a href="#%E8%AF%AD%E6%B3%95%E6%A0%BC%E5%BC%8F%EF%BC%9A%C2%A0%C2%A0%20%C2%A0new%20%E7%B1%BB%E5%90%8D%E6%88%96%E8%80%85%E6%8E%A5%E5%8F%A3%E5%90%8D%28%29%7B%C2%A0%C2%A0%20%C2%A0%C2%A0%C2%A0%20%C2%A0%E9%87%8D%E5%86%99%E6%96%B9%E6%B3%95%3B%C2%A0%C2%A0%20%C2%A0%7D%20%3B" rel="nofollow">语法格式：    new 类名或者接口名(){        重写方法;    } ;</a></p> 
<p id="%E7%BB%99%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E5%90%8D%E5%91%BD%3A%20%E8%99%BD%E7%84%B6%E8%BF%99%E6%98%AF%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%2C%E4%BD%86%E6%98%AF%E4%BB%8D%E7%84%B6%E5%8F%AF%E4%BB%A5%E5%88%A9%E7%94%A8%E5%A4%9A%E6%80%81%E6%9D%A5%E7%BB%99%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E5%90%8D%E5%91%BD%E7%9A%84%E5%93%88!-toc" style="margin-left:80px;"><span style="color:#faa572;"><strong><img alt="" src="https://images2.imgbox.com/70/52/XXUHuuIw_o.gif"></strong></span><a href="#%E7%BB%99%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E5%90%8D%E5%91%BD%3A%20%E8%99%BD%E7%84%B6%E8%BF%99%E6%98%AF%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%2C%E4%BD%86%E6%98%AF%E4%BB%8D%E7%84%B6%E5%8F%AF%E4%BB%A5%E5%88%A9%E7%94%A8%E5%A4%9A%E6%80%81%E6%9D%A5%E7%BB%99%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E5%90%8D%E5%91%BD%E7%9A%84%E5%93%88!" rel="nofollow">给匿名内部类名命: 虽然这是匿名内部类,但是仍然可以利用多态来给匿名内部类名命的哈!</a></p> 
<p id="%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E5%A5%BD%E5%A4%84%3A%C2%A0%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%EF%BC%8C%E7%BB%8F%E5%B8%B8%E4%BD%9C%E4%B8%BA%E5%8F%82%E6%95%B0%EF%BC%8C%E6%88%96%E8%BF%94%E5%9B%9E%E5%80%BC%EF%BC%8C%E4%BD%BF%E7%94%A8%E6%AF%94%E8%BE%83%E6%96%B9%E4%BE%BF%E3%80%82-toc" style="margin-left:80px;"><span style="color:#faa572;"><strong><img alt="" src="https://images2.imgbox.com/7c/30/zQ1kiDR0_o.gif"></strong></span><a href="#%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E5%A5%BD%E5%A4%84%3A%C2%A0%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%EF%BC%8C%E7%BB%8F%E5%B8%B8%E4%BD%9C%E4%B8%BA%E5%8F%82%E6%95%B0%EF%BC%8C%E6%88%96%E8%BF%94%E5%9B%9E%E5%80%BC%EF%BC%8C%E4%BD%BF%E7%94%A8%E6%AF%94%E8%BE%83%E6%96%B9%E4%BE%BF%E3%80%82" rel="nofollow">匿名内部类的好处: 匿名内部类，经常作为参数，或返回值，使用比较方便。</a></p> 
<p id="%E4%B8%80%E4%B8%AA%E7%B1%BB%E4%B8%AD%E5%8F%AF%E4%BB%A5%E5%B5%8C%E5%A5%97%E4%B8%80%E4%B8%AA%E6%8E%A5%E5%8F%A3%3A-toc" style="margin-left:80px;"><span style="color:#faa572;"><strong><img alt="" src="https://images2.imgbox.com/3a/df/Zl6FWnyw_o.gif"></strong></span><a href="#%E4%B8%80%E4%B8%AA%E7%B1%BB%E4%B8%AD%E5%8F%AF%E4%BB%A5%E5%B5%8C%E5%A5%97%E4%B8%80%E4%B8%AA%E6%8E%A5%E5%8F%A3%3A" rel="nofollow">一个类中可以嵌套一个接口:</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h4 style="text-align:center;"><span style="color:#faa572;"><strong><img alt="" src="https://images2.imgbox.com/5f/ef/MSAtedRa_o.gif">匿名内部类是局部内部类的一种简化形式.本质上是一个对象,是实现了该接口或继承了该抽象类的子类对象.</strong></span></h4> 
<h4 style="text-align:center;"><span style="color:#faa572;"><strong><img alt="" src="https://images2.imgbox.com/66/f2/l6Fjv2Wr_o.gif">  语法格式：<img alt="" src="https://images2.imgbox.com/1b/6f/s3kL7mjg_o.gif"><br>     new 类名或者接口名(){<!-- --><br>         重写方法;<br>     } ;</strong></span></h4> 
<pre><code class="language-java">public class MyTest {
    public static void main(String[] args) {

        new Father() {             //new了一个父类抽象类的子类对象.匿名的
            @Override
            //重写了父类中的抽象方法
            public void hehe() {
                System.out.println("呵呵呵呵呵呵");
            }
        };

        //创建了父类的子类对象并且调用重写后的方法
        new Father() {
            @Override
            public void hehe() {
                System.out.println("44444444444444");
            }
        }.hehe();
    }
}

abstract class Father {
    public abstract void hehe();
}</code></pre> 
<h4 id="%E7%BB%99%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E5%90%8D%E5%91%BD%3A%20%E8%99%BD%E7%84%B6%E8%BF%99%E6%98%AF%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%2C%E4%BD%86%E6%98%AF%E4%BB%8D%E7%84%B6%E5%8F%AF%E4%BB%A5%E5%88%A9%E7%94%A8%E5%A4%9A%E6%80%81%E6%9D%A5%E7%BB%99%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E5%90%8D%E5%91%BD%E7%9A%84%E5%93%88!" style="text-align:center;"><span style="color:#faa572;"><strong><img alt="" src="https://images2.imgbox.com/35/84/gKOVd9Pw_o.gif">给匿名内部类名命: 虽然这是匿名内部类,但是仍然可以利用多态来给匿名内部类名命的哈!</strong></span></h4> 
<pre><code class="language-java">public class MyTest {
    public static void main(String[] args) {
        //匿名内部类
        new AA() {
            @Override
            public void aa() {
                System.out.println("aaaaaaaaaaaaaaaa");
            }

            @Override
            public void hehe() {
                System.out.println("hehehehehehhehehhe");
            }
        };
        //此时,要想用同一个对象调用多个方法时,就会很难办到.这个时候给匿名内部类名命就可以解决了!
        //利用多态进行名命
        AA aa = new AA() {
            @Override
            public void aa() {
                System.out.println("aaaaaaaaaaaaaa744444aa");
            }

            @Override
            public void hehe() {
                System.out.println("hehehehehe888877777hhehehhe");
            }
        };
        //这样就可以调用多个方法了
        aa.aa();
        aa.hehe();

    }
}

abstract class AA {
    public abstract void aa();

    public abstract void hehe();
}
</code></pre> 
<h4 id="%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E5%A5%BD%E5%A4%84%3A%C2%A0%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%EF%BC%8C%E7%BB%8F%E5%B8%B8%E4%BD%9C%E4%B8%BA%E5%8F%82%E6%95%B0%EF%BC%8C%E6%88%96%E8%BF%94%E5%9B%9E%E5%80%BC%EF%BC%8C%E4%BD%BF%E7%94%A8%E6%AF%94%E8%BE%83%E6%96%B9%E4%BE%BF%E3%80%82" style="text-align:center;"><span style="color:#faa572;"><strong><img alt="" src="https://images2.imgbox.com/d4/9f/MEAtbXRP_o.gif">匿名内部类的好处: 匿名内部类，经常作为参数，或返回值，使用比较方便。</strong></span></h4> 
<pre><code class="language-java">public class MyTest {
    public static void main(String[] args) {
        //匿名内部类，经常作为参数，或返回值，使用比较方便。
       
        test(new WW() {
            @Override
            public void hehe() {
                System.out.println("111111111");
            }
        });
    }

    //方法的形参要一个抽象类类型，传递一个该抽象类的子类对象.
    public static void test(WW ww) {
        ww.hehe();
    }
}


abstract class WW {
    public abstract void hehe();
}
</code></pre> 
<pre><code class="language-java">public class MyTest {

    public static void main(String[] args) {
        BB bb = getBB();
        bb.bb();

        //匿名内部类，作为返回值，返回方便
    }

    //方法的返回值是一个抽象类 类型，返回一个该抽象类的子类对象。
    public static BB getBB2() {
        BB b2 = new BB() {

            @Override
            public void bb() {
                System.out.println("bbbbbbbbbbbbbbbbb222222222");
            }
        };
        //匿名内部类，作为返回值，返回方便
        return b2;
    }
}

abstract class BB {
    public abstract void bb();
}
</code></pre> 
<h4 id="%E4%B8%80%E4%B8%AA%E7%B1%BB%E4%B8%AD%E5%8F%AF%E4%BB%A5%E5%B5%8C%E5%A5%97%E4%B8%80%E4%B8%AA%E6%8E%A5%E5%8F%A3%3A"><span style="color:#faa572;"><strong><img alt="" src="https://images2.imgbox.com/47/fd/uKYYvdC6_o.gif">一个类中可以嵌套一个接口:</strong></span></h4> 
<pre><code class="language-java">public class MyTest2 {
    public static void main(String[] args) {
        new Inter() {
            public void show() {
                //this 代表匿名内部类
                System.out.println(this.a);          
                System.out.println(Inter.a);         


            }
        }.show();

    }
}


interface Inter {
    public static final int a = 23;
}</code></pre> 
<p style="text-align:center;"><span style="color:#faa572;"><strong><img alt="" src="https://images2.imgbox.com/ff/a3/7VZgK7xe_o.gif">(小编也在努力学习更多哟!以后会多多分享哒!)  <img alt="" src="https://images2.imgbox.com/d6/8b/wXpqvoIT_o.gif"></strong></span></p> 
<p style="text-align:center;"><span style="color:#faa572;"><strong>希望对友友们有所帮助!!!</strong></span></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/402316d8a11ffb6e8e7e34a634ed923b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">H264编解码实战</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/30e3d5d0e5be784b9401227ebd500ce0/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">windows安装gogs实操指南</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>