<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Bi-lstm&#43;CRF实现NER（随机生成词向量） - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Bi-lstm&#43;CRF实现NER（随机生成词向量）" />
<meta property="og:description" content="尊敬的读者您好：笔者很高兴自己的文章能被阅读，但原创与编辑均不易，所以转载请必须注明本文出处并附上本文地址超链接以及博主博客地址：https://blog.csdn.net/vensmallzeng。若觉得本文对您有益处还请帮忙点个赞鼓励一下，笔者在此感谢每一位读者，如需联系笔者，请记下邮箱：zengzenghe@gmail.com，谢谢合作！
最近跟进的项目中时刻不离NER任务，笔者团队采用过多个版本bi-lstm&#43;CRF程序去实现NER的bi-lstm&#43;CRF，感觉每个版本都有每个版本的优势，所以下面就来分享第一个版本，该版本中的输入词向量是随机生成的并且所有的.py文件中有不容易读懂的地方，笔者都进行了注释，方便自己也方便大家。
1、如果需要本文源码请自行转向“https://download.csdn.net/download/vensmallzeng/11212457”。
2、该版本主要包括以下几个部分：
checkpoints文件夹用于保存训练好的模型以及参数；
data文件夹用于保存训练、验证、测试数据等；
tensorboard文件夹用于保存张量可视化的数据； 3、Data_process.py文件包含一些数据预处理的函数如read_data、build_vocab、sequence2id以及process_seq等，各函数具体功能见注释。
4、Parameters.py文件见其名知其义，应该存放一些用于模型训练、测试的参数。
5、biLstm_Crf.py文件主要是用于实现bi-Lstm&#43;CRF功能，下面将着重介绍该文件。
首先随机生成词向量（每一次训练都会重新生成，所以省去了预训练词向量的工作），生成的词向量被用于查询bi-Lstm&#43;CRF模型的输入词向量。
然后构建bi-Lstm&#43;CRF模型，该模型的输入为查询得到的词向量。
bi-Lstm层：
CRF层：
损失函数用的是最大似然函数，这里采用梯度下降算法来优化损失函数，所以需要给损失函数加负号：
优化损失函数
模型搭建好后要考虑给模型喂数据，因此需要将数据按要求进行打包处理之后方能喂给模型。
模型测试调用代码
实际应用调用代码
6、Train_Model.py文件主要是用于训练bi-Lstm&#43;CRF模型，并将训练好的模型参数保存下来，以便后期直接调用。
7、serve.py文件主要是用于实际应用，可以实现输入一句话，自动提取出人名、地点和机构。
主体代码如下：
实际效果如下：
最后想和大家谈谈几个关于Bi-lstm&#43;CRF的个人总结：
① 与传统Lstm不同，双向Lstm同时考虑了过去的特征（通过前向过程提取）和未来的特征（通过后向过程提取）。说直白点，后向过程其实相当于将原始序列逆向输入到Lstm中。因此从这个角度来看，双向Lstm相当于两个Lstm（一个正向输入序列，一个反向输入序列），最后将两者的输出结合起来作为最终的结果。
② 采用CRF层的原因：Bi-lstm考虑了输入词(字符)向量序列的上下文信息，CRF考虑了tag之间的依赖关系信息，因此二者结合无疑可以选择出最适合的预测tag序列。
如：句子的开始单词的标签类型应该是B或O，而不是I；限制一些格式，B-Person I-Person是合理的，B-Person I-Organization是不合理的
③ 需要训练的参数有：Bi-lstm中的参数与CRF中转移概率矩阵A
④ Bi-lstm&#43;CRF训练时采用监督学习方法，通过最大化预测为真实标记序列的概率（将概率取对数再取负，然后用梯度下降算法优化）来更新Bi-lstm中的参数与CRF中转移概率矩阵A。虽然刚开始训练“真实标记序列不会对应最大的概率值”，但通过样本的连续迭代优化，最终会实现“真实标记序列应该对应最大的概率值”；Bi-lstm&#43;CRF测试时，直接根据训练好的参数求出所有可能的预测序列对应的得分（这里应该会用到维特比算法），最后取对应最大得分的预测序列作为最终预测结果。
⑤ Bi-lstm&#43;CRF的输入是一组词（字符）向量，输出是一组预测tag序列。
参考文献：
【1】https://blog.csdn.net/bobobe/article/details/80489303
日积月累，与君共进，增增小结，未完待续。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/50eea88dffd0f91e282d9c9f56a14536/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-05-28T17:50:43+08:00" />
<meta property="article:modified_time" content="2019-05-28T17:50:43+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Bi-lstm&#43;CRF实现NER（随机生成词向量）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p style="margin-left:0cm;"><span style="color:#f33b45;">尊敬的读者您好：笔者很高兴自己的文章能被阅读，但原创与编辑均不易，所以</span><span style="color:#3399ea;">转载请必须注明本文出处并附上本文地址超链接以及博主博客地址：https://blog.csdn.net/vensmallzeng</span><span style="color:#f33b45;">。若觉得本文对您有益处还请帮忙点个赞鼓励一下，笔者在此感谢每一位读者，如需联系笔者，请记下邮箱：zengzenghe@gmail.com，谢谢合作！</span></p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p>        最近跟进的项目中时刻不离NER任务，笔者团队采用过多个版本bi-lstm+CRF程序去实现NER的bi-lstm+CRF，感觉每个版本都有每个版本的优势，所以下面就来分享第一个版本，<strong>该版本中的输入词向量是随机生成的</strong>并且所有的.py文件中有不容易读懂的地方，笔者都进行了注释，方便自己也方便大家。</p> 
<p>1、如果需要本文源码请自行转向“<a href="https://download.csdn.net/download/vensmallzeng/11212457">https://download.csdn.net/download/vensmallzeng/11212457</a>”。</p> 
<p>2、该版本主要包括以下几个部分：</p> 
<p><img alt="" class="has" height="260" src="https://images2.imgbox.com/42/ea/V3qWj1ZE_o.png" width="272"></p> 
<p>checkpoints文件夹用于保存训练好的模型以及参数；</p> 
<p><img alt="" class="has" height="251" src="https://images2.imgbox.com/6d/15/5u9n5vIN_o.png" width="338"></p> 
<p>data文件夹用于保存训练、验证、测试数据等；</p> 
<p><img alt="" class="has" height="130" src="https://images2.imgbox.com/00/57/1jSM7rnv_o.png" width="295"></p> 
<p>tensorboard文件夹用于保存张量可视化的数据； </p> 
<p><img alt="" class="has" height="484" src="https://images2.imgbox.com/02/82/yTdkjJU8_o.png" width="359"></p> 
<p>3、<a href="" rel="nofollow">Data_process.py</a>文件包含一些数据预处理的函数如read_data、build_vocab、sequence2id以及process_seq等，各函数具体功能见注释。</p> 
<p><img alt="" class="has" height="556" src="https://images2.imgbox.com/3d/a8/KFcqYasw_o.png" width="534"></p> 
<p> <img alt="" class="has" height="525" src="https://images2.imgbox.com/d3/f3/VELTbxXL_o.png" width="654"></p> 
<p><img alt="" class="has" height="698" src="https://images2.imgbox.com/e9/f8/hUsBlKmS_o.png" width="668"></p> 
<p><img alt="" class="has" height="461" src="https://images2.imgbox.com/77/31/lvzmWWFE_o.png" width="1057"></p> 
<p>4、Parameters.py文件见其名知其义，应该存放一些用于模型训练、测试的参数。</p> 
<p><img alt="" class="has" height="548" src="https://images2.imgbox.com/c1/cc/VjVOHdKZ_o.png" width="388"></p> 
<p>5、biLstm_Crf.py文件主要是用于实现bi-Lstm+CRF功能，下面将着重介绍该文件。</p> 
<p>首先随机生成词向量（每一次训练都会重新生成，所以省去了预训练词向量的工作），生成的词向量被用于查询bi-Lstm+CRF模型的输入词向量。</p> 
<p><img alt="" class="has" height="89" src="https://images2.imgbox.com/67/ca/LBqZSDtZ_o.png" width="1150"></p> 
<p>然后构建bi-Lstm+CRF模型，该模型的输入为查询得到的词向量。</p> 
<p>bi-Lstm层：</p> 
<p><img alt="" class="has" height="213" src="https://images2.imgbox.com/47/22/gG0PClsr_o.png" width="1130"></p> 
<p>CRF层：</p> 
<p><img alt="" class="has" height="70" src="https://images2.imgbox.com/c3/40/VpzIAtL7_o.png" width="1200"></p> 
<p>损失函数用的是最大似然函数，这里采用梯度下降算法来优化损失函数，所以需要给损失函数加负号：</p> 
<p><img alt="" class="has" height="68" src="https://images2.imgbox.com/b8/3f/UfqdlBVZ_o.png" width="782"></p> 
<p>优化损失函数</p> 
<p><img alt="" class="has" height="165" src="https://images2.imgbox.com/df/99/gGRI0LAX_o.png" width="1033"></p> 
<p>模型搭建好后要考虑给模型喂数据，因此需要将数据按要求进行打包处理之后方能喂给模型。</p> 
<p><img alt="" class="has" height="227" src="https://images2.imgbox.com/8e/b8/8aoJR9sX_o.png" width="628"></p> 
<p>模型测试调用代码</p> 
<p><img alt="" class="has" height="281" src="https://images2.imgbox.com/f1/a4/aVL77hSX_o.png" width="684"></p> 
<p>实际应用调用代码</p> 
<p><img alt="" class="has" height="409" src="https://images2.imgbox.com/be/9f/42UMiZBz_o.png" width="1200"></p> 
<p>6、Train_Model.py文件主要是用于训练bi-Lstm+CRF模型，并将训练好的模型参数保存下来，以便后期直接调用。</p> 
<p> <img alt="" class="has" height="692" src="https://images2.imgbox.com/33/8d/QNedaQnW_o.png" width="609"></p> 
<p> 7、serve.py文件主要是用于实际应用，可以实现输入一句话，自动提取出人名、地点和机构。</p> 
<p>主体代码如下：</p> 
<p><img alt="" class="has" height="741" src="https://images2.imgbox.com/ba/2a/at76atVQ_o.png" width="604"></p> 
<p> 实际效果如下：</p> 
<p><img alt="" class="has" height="137" src="https://images2.imgbox.com/2f/4b/8StQQhAl_o.png" width="334"></p> 
<p> </p> 
<p>最后想和大家谈谈几个关于Bi-lstm+CRF的个人总结：</p> 
<p>① 与传统Lstm不同，双向Lstm同时考虑了过去的特征（通过前向过程提取）和未来的特征（通过后向过程提取）。说直白点，后向过程其实相当于将原始序列逆向输入到Lstm中。因此从这个角度来看，双向Lstm相当于两个Lstm（一个正向输入序列，一个反向输入序列），最后将两者的输出结合起来作为最终的结果。</p> 
<p>② 采用CRF层的原因：Bi-lstm考虑了输入词(字符)向量序列的上下文信息，CRF考虑了tag之间的依赖关系信息，因此二者结合无疑可以选择出最适合的预测tag序列。</p> 
<p>如：句子的开始单词的标签类型应该是<code>B</code>或<code>O</code>，而不是<code>I</code>；限制一些格式，<code>B-Person I-Person</code>是合理的，<code>B-Person I-Organization</code>是不合理的</p> 
<p>③ 需要训练的参数有：Bi-lstm中的参数与CRF中转移概率矩阵A</p> 
<p>④  Bi-lstm+CRF训练时采用监督学习方法，通过最大化预测为真实标记序列的概率（将概率取对数再取负，然后用梯度下降算法优化）来更新Bi-lstm中的参数与CRF中转移概率矩阵A。虽然刚开始训练“真实标记序列不会对应最大的概率值”，但通过样本的连续迭代优化，最终会实现“真实标记序列应该对应最大的概率值”；Bi-lstm+CRF测试时，直接根据训练好的参数求出所有可能的预测序列对应的得分（这里应该会用到维特比算法），最后取对应最大得分的预测序列作为最终预测结果。</p> 
<p>⑤ Bi-lstm+CRF的输入是一组词（字符）向量，输出是一组预测tag序列。</p> 
<p>参考文献：</p> 
<p>【1】<a href="https://blog.csdn.net/bobobe/article/details/80489303">https://blog.csdn.net/bobobe/article/details/80489303</a></p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p>日积月累，与君共进，增增小结，未完待续。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/98633902b0e0db2fa0f0e149a5b66d41/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">C&#43;&#43; 简单的多线程测试</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/12f814e2b452ab5dbc4e34c83a2de247/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">关于内网使用Nginx正向代理发送极光推送</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>