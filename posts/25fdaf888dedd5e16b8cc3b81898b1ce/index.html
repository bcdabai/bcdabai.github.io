<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>常见的图像相似度比较哈希算法实现(Python&amp;amp;OpenCV) - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="常见的图像相似度比较哈希算法实现(Python&amp;amp;OpenCV)" />
<meta property="og:description" content="简述 相似图像搜索的哈希算法有三种：
均值哈希算法差值哈希算法感知哈希算法 均值哈希算法 步骤
缩放：图片缩放为8*8，保留结构，出去细节。灰度化：转换为256阶灰度图。求平均值：计算灰度图所有像素的平均值。比较：像素值大于平均值记作1，相反记作0，总共64位。生成hash：将上述步骤生成的1和0按顺序组合起来既是图片的指纹（hash）。顺序不固定。但是比较时候必须是相同的顺序。对比指纹：将两幅图的指纹对比，计算汉明距离，即两个64位的hash值有多少位是不一样的，不相同位数越少，图片越相似。 代码实现：
#均值哈希算法 def aHash(img): #缩放为8*8 img=cv2.resize(img,(8,8),interpolation=cv2.INTER_CUBIC) #转换为灰度图 gray=cv2.cvtColor(img,cv2.COLOR_BGR2GRAY) #s为像素和初值为0，hash_str为hash值初值为&#39;&#39; s=0 hash_str=&#39;&#39; #遍历累加求像素和 for i in range(8): for j in range(8): s=s&#43;gray[i,j] #求平均灰度 avg=s/64 #灰度大于平均值为1相反为0生成图片的hash值 for i in range(8): for j in range(8): if gray[i,j]&gt;avg: hash_str=hash_str&#43;&#39;1&#39; else: hash_str=hash_str&#43;&#39;0&#39; return hash_str 差值哈希算法 差值哈希算法前期和后期基本相同，只有中间比较hash有变化。
步骤 1. 缩放：图片缩放为8*9，保留结构，出去细节。 2. 灰度化：转换为256阶灰度图。 3. 求平均值：计算灰度图所有像素的平均值。 4. 比较：像素值大于后一个像素值记作1，相反记作0。本行不与下一行对比，每行9个像素，八个差值，有8行，总共64位 5. 生成hash：将上述步骤生成的1和0按顺序组合起来既是图片的指纹（hash）。顺序不固定。但是比较时候必须是相同的顺序。 6. 对比指纹：将两幅图的指纹对比，计算汉明距离，即两个64位的hash值有多少位是不一样的，不相同位数越少，图片越相似。
#差值感知算法 def dHash(img): #缩放8*8 img=cv2.resize(img,(9,8),interpolation=cv2.INTER_CUBIC) #转换灰度图 gray=cv2.cvtColor(img,cv2.COLOR_BGR2GRAY) hash_str=&#39;&#39; #每行前一个像素大于后一个像素为1，相反为0，生成哈希 for i in range(8): for j in range(8): if gray[i,j]&gt;gray[i,j&#43;1]: hash_str=hash_str&#43;&#39;1&#39; else: hash_str=hash_str&#43;&#39;0&#39; return hash_str 感知哈希算法 感知哈希算法可以参考 相似性︱python&#43;opencv实现pHash算法&#43;hamming距离（simhash）（三） 讲的很详细了。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/25fdaf888dedd5e16b8cc3b81898b1ce/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-07-20T14:28:30+08:00" />
<meta property="article:modified_time" content="2018-07-20T14:28:30+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">常见的图像相似度比较哈希算法实现(Python&amp;amp;OpenCV)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2 id="简述">简述</h2> 
<p>相似图像搜索的哈希算法有三种：</p> 
<ul><li>均值哈希算法</li><li>差值哈希算法</li><li>感知哈希算法</li></ul> 
<h2 id="均值哈希算法"><a name="t1"></a>均值哈希算法</h2> 
<p>步骤</p> 
<ol><li><strong>缩放</strong>：图片缩放为8*8，保留结构，出去细节。</li><li><strong>灰度化</strong>：转换为256阶灰度图。</li><li><strong>求平均值</strong>：计算灰度图所有像素的平均值。</li><li><strong>比较</strong>：像素值大于平均值记作1，相反记作0，总共64位。</li><li><strong>生成hash</strong>：将上述步骤生成的1和0按顺序组合起来既是图片的指纹（hash）。顺序不固定。但是比较时候必须是相同的顺序。</li><li><strong>对比指纹</strong>：将两幅图的指纹对比，计算汉明距离，即两个64位的hash值有多少位是不一样的，不相同位数越少，图片越相似。</li></ol> 
<p>代码实现：</p> 
<pre class="has"><code>#均值哈希算法
def aHash(img):
    #缩放为8*8
    img=cv2.resize(img,(8,8),interpolation=cv2.INTER_CUBIC)
    #转换为灰度图
    gray=cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)
    #s为像素和初值为0，hash_str为hash值初值为''
    s=0
    hash_str=''
    #遍历累加求像素和
    for i in range(8):
        for j in range(8):
            s=s+gray[i,j]
    #求平均灰度
    avg=s/64
    #灰度大于平均值为1相反为0生成图片的hash值
    for i in range(8):
        for j in range(8):
            if  gray[i,j]&gt;avg:
                hash_str=hash_str+'1'
            else:
                hash_str=hash_str+'0'            
    return hash_str</code></pre> 
<ul><li>差值哈希算法</li></ul> 
<p>差值哈希算法前期和后期基本相同，只有中间比较hash有变化。</p> 
<p>步骤 <br> 1. <strong>缩放</strong>：图片缩放为8*9，保留结构，出去细节。 <br> 2. <strong>灰度化</strong>：转换为256阶灰度图。 <br> 3. <strong>求平均值</strong>：计算灰度图所有像素的平均值。 <br> 4. <strong>比较</strong>：像素值大于后一个像素值记作1，相反记作0。本行不与下一行对比，每行9个像素，八个差值，有8行，总共64位 <br> 5. <strong>生成hash</strong>：将上述步骤生成的1和0按顺序组合起来既是图片的指纹（hash）。顺序不固定。但是比较时候必须是相同的顺序。 <br> 6. <strong>对比指纹</strong>：将两幅图的指纹对比，计算汉明距离，即两个64位的hash值有多少位是不一样的，不相同位数越少，图片越相似。</p> 
<pre class="has"><code>
#差值感知算法
def dHash(img):
    #缩放8*8
    img=cv2.resize(img,(9,8),interpolation=cv2.INTER_CUBIC)
    #转换灰度图
    gray=cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)
    hash_str=''
    #每行前一个像素大于后一个像素为1，相反为0，生成哈希
    for i in range(8):
        for j in range(8):
            if   gray[i,j]&gt;gray[i,j+1]:
                hash_str=hash_str+'1'
            else:
                hash_str=hash_str+'0'
    return hash_str</code></pre> 
<h2 id="感知哈希算法"><a name="t3"></a>感知哈希算法</h2> 
<p>感知哈希算法可以参考 <br><a href="http://blog.csdn.net/sinat_26917383/article/details/70287521">相似性︱python+opencv实现pHash算法+hamming距离（simhash）（三）</a> <br> 讲的很详细了。</p> 
<p><strong>pHash代码实现：</strong></p> 
<pre class="has"><code>def pHash(imgfile):
    """get image pHash value"""
    #加载并调整图片为32x32灰度图片
    img=cv2.imread(imgfile, 0)
    img=cv2.resize(img,(64,64),interpolation=cv2.INTER_CUBIC)

        #创建二维列表
    h, w = img.shape[:2]
    vis0 = np.zeros((h,w), np.float32)
    vis0[:h,:w] = img       #填充数据

    #二维Dct变换
    vis1 = cv2.dct(cv2.dct(vis0))
    #cv.SaveImage('a.jpg',cv.fromarray(vis0)) #保存图片
    vis1.resize(32,32)
    #把二维list变成一维list
    img_list = vis1.flatten()

    #计算均值
    avg = sum(img_list)*1./len(img_list)
    avg_list = ['0' if i&lt;avg else '1' for i in img_list]

    #得到哈希值
    return ''.join(['%x' % int(''.join(avg_list[x:x+4]),2) for x in range(0,32*32,4)])

'''
cv2.imread
flags&gt;0时表示以彩色方式读入图片 
flags=0时表示以灰度图方式读入图片 
flags&lt;0时表示以图片的本来的格式读入图片

interpolation - 插值方法。共有5种：
１）INTER_NEAREST - 最近邻插值法
２）INTER_LINEAR - 双线性插值法（默认）
３）INTER_AREA - 基于局部像素的重采样（resampling using pixel area relation）。对于图像抽取（image decimation）来说，这可能是一个更好的方法。但如果是放大图像时，它和最近邻法的效果类似。
４）INTER_CUBIC - 基于4x4像素邻域的3次插值法
５）INTER_LANCZOS4 - 基于8x8像素邻域的Lanczos插值
'''</code></pre> 
<p> </p> 
<h2 id="hash值对比"><a name="t4"></a>Hash值对比</h2> 
<p>由于返回值为str字符串，所以直接遍历字符串进行比对。</p> 
<pre class="has"><code>#Hash值对比
def cmpHash(hash1,hash2):
    n=0
    #hash长度不同则返回-1代表传参出错
    if len(hash1)!=len(hash2):
        return -1
    #遍历判断
    for i in range(len(hash1)):
        #不相等则n计数+1，n最终为相似度
        if hash1[i]!=hash2[i]:
            n=n+1
    return n
</code></pre> 
<h2 id="总结"><a name="t5"></a>总结</h2> 
<p>完整代码</p> 
<pre class="has"><code>import cv2
import  numpy as np

#均值哈希算法
def aHash(img):
    #缩放为8*8
    img=cv2.resize(img,(8,8),interpolation=cv2.INTER_CUBIC)
    #转换为灰度图
    gray=cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)
    #s为像素和初值为0，hash_str为hash值初值为''
    s=0
    hash_str=''
    #遍历累加求像素和
    for i in range(8):
        for j in range(8):
            s=s+gray[i,j]
    #求平均灰度
    avg=s/64
    #灰度大于平均值为1相反为0生成图片的hash值
    for i in range(8):
        for j in range(8):
            if  gray[i,j]&gt;avg:
                hash_str=hash_str+'1'
            else:
                hash_str=hash_str+'0'            
    return hash_str

#差值感知算法
def dHash(img):
    #缩放8*8
    img=cv2.resize(img,(9,8),interpolation=cv2.INTER_CUBIC)
    #转换灰度图
    gray=cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)
    hash_str=''
    #每行前一个像素大于后一个像素为1，相反为0，生成哈希
    for i in range(8):
        for j in range(8):
            if   gray[i,j]&gt;gray[i,j+1]:
                hash_str=hash_str+'1'
            else:
                hash_str=hash_str+'0'
    return hash_str

#Hash值对比
def cmpHash(hash1,hash2):
    n=0
    #hash长度不同则返回-1代表传参出错
    if len(hash1)!=len(hash2):
        return -1
    #遍历判断
    for i in range(len(hash1)):
        #不相等则n计数+1，n最终为相似度
        if hash1[i]!=hash2[i]:
            n=n+1
    return n

img1=cv2.imread('walk_m.jpg')
img2=cv2.imread('walks1.jpg')
hash1= aHash(img1)
hash2= aHash(img2)
print(hash1)
print(hash2)
n=cmpHash(hash1,hash2)
print('均值哈希算法相似度：',n)


hash1= dHash(img1)
hash2= dHash(img2)
print(hash1)
print(hash2)
n=cmpHash(hash1,hash2)
print('差值哈希算法相似度：',n)</code></pre> 
<p>测试图像两张如下</p> 
<p><img alt="这里写图片描述" class="has" src="https://images2.imgbox.com/28/04/gklVOysh_o.jpg"><img alt="这里写图片描述" class="has" src="https://images2.imgbox.com/c7/85/CuC2MCb6_o.jpg"></p> 
<p>测试结果如下：</p> 
<p><img alt="这里写图片描述" class="has" src="https://images2.imgbox.com/1d/1c/ipxVYTUq_o.jpg"></p> 
<p>根据不同的实际情况测试，选择自己合适的相似度算法才是最好的。</p> 
<p> </p> 
<p>引用：<a href="https://blog.csdn.net/haofan_/article/details/77097473">https://blog.csdn.net/haofan_/article/details/77097473</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/25a3d1916425b2578c2d7702a7e2fdde/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Oracle数据库日期格式转换函数</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3e42dee0d61e8facf14601490f0a541b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Python str转float</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>