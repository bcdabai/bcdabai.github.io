<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>AcWing 352 闇の連鎖 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="AcWing 352 闇の連鎖" />
<meta property="og:description" content="题目描述：
传说中的暗之连锁被人们称为 Dark。
Dark 是人类内心的黑暗的产物，古今中外的勇者们都试图打倒它。
经过研究，你发现 Dark 呈现无向图的结构，图中有 N 个节点和两类边，一类边被称为主要边，而另一类被称为附加边。
Dark 有 N–1 条主要边，并且 Dark 的任意两个节点之间都存在一条只由主要边构成的路径。
另外，Dark 还有 M 条附加边。
你的任务是把 Dark 斩为不连通的两部分。
一开始 Dark 的附加边都处于无敌状态，你只能选择一条主要边切断。
一旦你切断了一条主要边，Dark 就会进入防御模式，主要边会变为无敌的而附加边可以被切断。
但是你的能力只能再切断 Dark 的一条附加边。
现在你想要知道，一共有多少种方案可以击败 Dark。
注意，就算你第一步切断主要边之后就已经把 Dark 斩为两截，你也需要切断一条附加边才算击败了 Dark。
输入格式
第一行包含两个整数 N 和 M。
之后 N–1 行，每行包括两个整数 A 和 B，表示 A 和 B 之间有一条主要边。
之后 M 行以同样的格式给出附加边。
输出格式
输出一个整数表示答案。
数据范围
N≤100000,M≤200000，数据保证答案不超过2^31−1
输入样例：
4 1 1 2 2 3 1 4 3 4 输出样例：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/17242f35e3e61e6f9c018ec1d579b8af/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-05-18T11:54:39+08:00" />
<meta property="article:modified_time" content="2021-05-18T11:54:39+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">AcWing 352 闇の連鎖</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>题目描述：</p> 
<p>传说中的暗之连锁被人们称为 Dark。</p> 
<p>Dark 是人类内心的黑暗的产物，古今中外的勇者们都试图打倒它。</p> 
<p>经过研究，你发现 Dark 呈现无向图的结构，图中有 N 个节点和两类边，一类边被称为主要边，而另一类被称为附加边。</p> 
<p>Dark 有 N–1 条主要边，并且 Dark 的任意两个节点之间都存在一条只由主要边构成的路径。</p> 
<p>另外，Dark 还有 M 条附加边。</p> 
<p>你的任务是把 Dark 斩为不连通的两部分。</p> 
<p>一开始 Dark 的附加边都处于无敌状态，你只能选择一条主要边切断。</p> 
<p>一旦你切断了一条主要边，Dark 就会进入防御模式，主要边会变为无敌的而附加边可以被切断。</p> 
<p>但是你的能力只能再切断 Dark 的一条附加边。</p> 
<p>现在你想要知道，一共有多少种方案可以击败 Dark。</p> 
<p>注意，就算你第一步切断主要边之后就已经把 Dark 斩为两截，你也需要切断一条附加边才算击败了 Dark。</p> 
<p>输入格式</p> 
<p>第一行包含两个整数 N 和 M。</p> 
<p>之后 N–1 行，每行包括两个整数 A 和 B，表示 A 和 B 之间有一条主要边。</p> 
<p>之后 M 行以同样的格式给出附加边。</p> 
<p>输出格式</p> 
<p>输出一个整数表示答案。</p> 
<p>数据范围</p> 
<p>N≤100000,M≤200000，数据保证答案不超过2^31−1</p> 
<p>输入样例：</p> 
<pre><code>4 1
1 2
2 3
1 4
3 4
</code></pre> 
<p>输出样例：</p> 
<pre><code>3</code></pre> 
<p>分析：</p> 
<p>首先梳理下题意，一个无向图中，有N - 1条主要边，这么多主要边构成了原图的一棵支撑树。同时还有M条附加边，每条附加边都会增加一个回路。我们需要做的就是讲原图斩为两个不连通的部分，并且需要切断两条边，第一条边必须是主要边，第二条边必须是附加边。</p> 
<p><img alt="" height="296" src="https://images2.imgbox.com/90/1c/1XLMvT9J_o.png" width="319"></p> 
<p>如上图所示，黑色线条连接的边就是主要边，黄色线条连接的边就是附加边，要想将图切成两部分，一种可行的方案是第一次切断P和P的左孩子的连边，第二次切断连接a和b的附加边。可以观察到：a和b的连接形成从a和b的最近公共祖先P到a再到b的一个回路，如果第一刀切断该回路上的树边，则需要继续切第二刀并且只能切ab这条附加边才能将原图切为两部分。如果第一刀切断p和其父节点的连边，原图已经分为两部分了，第二刀可以任选附加边切断了。如果增加一条a到其兄弟节点的附加边，第一刀切断a和其父节点的连边，第二刀不论切掉哪条附加边都无法将原图切成两部分了，原因在于此时a到其父节点的连边处于两个不同的回路之中。进一步可以观察到，ab这条附加边的影响仅限于a、b到其LCA节点P的连边中。我们可以在连接ab这条附加边时，将a、b到它们的LCA节点P的每条连边的边权都加上1，表示他们正处于一条回路中，连接a和它的兄弟节点时，也将该回路上的主要边的边权加上1，此时a到其父节点的边权就是2了，表示有两个回路会经过这条边。</p> 
<p>经过了上面的抽象，可以得出结论，切断边权为0的主要边，原图已经被切成两部分，第二次可以任选附加边切断；切断边权为1的主要边，第二次只能切断造成该回路的那条附加边才能将原图切成两部分；切断边权不小于2的主要边，第二次不论切掉哪条附加边都无法将原图切位两部分。</p> 
<p>那么我们是否需要在添加附加边时遍历下产生的回路，将主要边的边权都加上1呢？其实是不需要的，我们可以使用<strong>树上差分</strong>来优化这一过程。</p> 
<p><img alt="" height="300" src="https://images2.imgbox.com/c9/64/GfXvSI9q_o.png" width="349"></p> 
<p>如图所示，在连接ab这条附加边时，我们只需要分别给a和b两个节点的点权加上1，然后给他们的LCA节点p的点权减去2就可以实现给回路上主要边的边权都加上1的效果。一般的差分中，我们想要给一段区间内所有数都加上c，只需要给差分数组的左端点加上c，右端点减去c就可以实现，与树上差分有异曲同工之妙。我们给a和b的点权分别+1，给p的点权-2，这样一来，以P为根的子树的点权之和是0，不会影响P的上面的节点，也不会影响P子树中回路以外的节点。回路中除了P以外的节点，它们的子树的点权之和都是1，表示有一条回路经过该点。上面说到的切断边权为1的连边，就可以等效的实现为切断点权为1的节点连向其父节点的那条连边。树上差分的好处在于不论回路多长，永远只需要对三个节点进行操作就能实现对每条边的边权都加上一个数的效果。</p> 
<p>知道了主要的步骤和算法，本题的求解思路就明朗了。在读取附加边时，将这条边的两个端点的点权都加上1，将这两点的LCA节点的点权减去2。然后遍历下主要边构成的支撑树，统计下所有可行的方案数。</p> 
<pre><code class="language-cpp">int dfs(int u) {
    int res = d[u];
    for(int i = h[u];~i;i = ne[i]) {
        int j = e[i];
        if(depth[j] &gt; depth[u]) {
            int s = dfs(j);
            if(s == 0)  ans += m;
            else if(s == 1) ans += 1;
            res += s;
        }
    }
    return res;
}</code></pre> 
<p>可以看到，在dfs的过程中，我们一边统计以节点u为根的子树的点权之和res，一边对u的孩子节点的点权和进行分类讨论统计方案数。这里要注意统计方案数需要写在循环里面而不能写在循环外面，因为在遍历以u为根的子树时，u的点权和实际上代表的是u到其父节点的边权。u为根节点时，u是没有父节点的，此时u的点权和不能增加方案数。本题总的代码如下：</p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;cstring&gt;
using namespace std;
const int N = 100005, M = 200005;
int idx,h[N],e[M],ne[M];
int q[N],depth[N],f[N][16];
int n,m,d[N];
int ans = 0;
void add(int a,int b) {
    e[idx] = b,ne[idx] = h[a],h[a] = idx++;
}
void bfs(int t) {
    memset(depth,0x3f,sizeof depth);
    int hh = 0,tt = 0;
    q[0] = t;
    depth[0] = 0,depth[t] = 1;
    while(hh &lt;= tt) {
        int u = q[hh++];
        for(int i = h[u];~i;i = ne[i]) {
            int j = e[i];
            if(depth[j] &gt; depth[u] + 1) {
                depth[j] = depth[u] + 1;
                q[++tt] = j;
                f[j][0] = u;
                for(int k = 1;k &lt;= 15;k++) {
                    f[j][k] = f[f[j][k-1]][k-1];
                }
            }
        }
    }
}
int lca(int a,int b) {
    if(depth[a] &lt; depth[b]) swap(a,b);
    for(int i = 15;i &gt;= 0;i--) {
        if(depth[f[a][i]] &gt;= depth[b])  a = f[a][i];
    }
    if(a == b)  return a;
    for(int i = 15;i &gt;= 0;i--) {
        if(f[a][i] != f[b][i]) {
            a = f[a][i];
            b = f[b][i];
        }
    }
    return f[a][0];
    
}
int dfs(int u) {
    int res = d[u];
    for(int i = h[u];~i;i = ne[i]) {
        int j = e[i];
        if(depth[j] &gt; depth[u]) {
            int s = dfs(j);
            if(s == 0)  ans += m;
            else if(s == 1) ans += 1;
            res += s;
        }
    }
    return res;
}
int main() {
    int a,b;
    scanf("%d%d",&amp;n,&amp;m);
    memset(h,-1,sizeof h);
    for(int i = 1;i &lt; n;i++) {
        scanf("%d%d",&amp;a,&amp;b);
        add(a,b),add(b,a);
    }
    bfs(1);
    for(int i = 0;i &lt; m;i++) {
        scanf("%d%d",&amp;a,&amp;b);
        d[a]++,d[b]++;
        int p = lca(a,b);
        d[p] -= 2;
    }
    dfs(1);
    printf("%d\n",ans);
    return 0;
}</code></pre> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d17e0b988da99a067bce9fc5d8524145/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">C语言程序设计答案黄保和编,C语言程序设计答案(黄保和编)第5章.pdf</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8b45ec5e46578e05708b1e3003799155/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">C语言编译灰色的点击不了,点击提交按钮后按钮变灰色不可用状态的三种方法...</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>