<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43;智能指针4——唯一指针unique_ptr详解 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C&#43;&#43;智能指针4——唯一指针unique_ptr详解" />
<meta property="og:description" content="目录
unique_ptr设计目标
使用unique_ptr
通过unique_ptr转移所有权
源和槽
unique_ptr作为类成员
处理数组
default_delete&lt;&gt;类
其他关联资源的删除器
unique_ptr详细信息
C&#43;&#43;11标准库提供的唯一指针unique_ptr有助于避免发生异常时的资源泄漏。它实现了专有所有权的概念，这意味着它可以确保一个对象及其关联资源一次只能由一个指针&#34;拥有&#39;&#39;。当此所有者被销毁或变空或开始拥有另一个对象时，先前拥有的对象也将被销毁，所有相关资源都将被释放。
唯一指针unique_ptr继承了自动指针auto_ptr（该类最初是C&#43;&#43; 98引入的，但现在已弃用）。 唯一指针unique_ptr提供了一个简单明了的接口，与自动指针auto_ptr相比，它更不容易出错。
unique_ptr设计目标 函数通常以以下步骤运行：
获取一些资源；执行一些操作；释放获得的资源。 如果获取的资源已经绑定到本地对象，则在进入时获取的资源会在函数退出时自动释放，因为函数退出时调用了这些本地对象的析构函数。但是如果资源是手动获取的，并且没有绑定到任何对象，则必须手动释放它们。使用指针时通常会手动管理资源。
以这种方式使用指针的典型示例是使用new和delete创建和销毁对象：
void f() { ClassA* ptr = new ClassA; //手动创建一个对象 ... //执行一些操作 delete ptr; //清理：手动销毁对象 } 上面代码的一个明显问题是，对象的销毁可能会被遗忘，尤其是在函数内部有return语句的情况下。 还有一种不太明显的危险就是可能发生的异常将导致函数立即退出，而不会调用末尾的delete语句，最终导致资源泄漏。
为了避免这种资源泄漏通常要求函数捕获所有异常。 例如：
void f() { ClassA* ptr = new ClassA; //手动创建一个对象 try { ... //执行一些操作 } catch (...) { //处理异常 delete ptr; //清理 throw; //重新抛出异常 } delete ptr; //正常退出时清理 } 为了在发生异常时正确处理此对象的删除，代码变得复杂和冗余。如果以这种方式处理第二个对象，或者使用了多个捕获子句，问题将变得更加严重。这不是一种好的编程风格，应避免使用，因为它很复杂且容易出错。
自动指针unique_ptr可以解决这个问题。只要自动指针本身被销毁，它就可以释放其指向的数据。此外，由于它是一个局部变量，所以退出函数时唯一指针会自动销毁，无论退出是正常的还是由于异常导致的。
unique_ptr是一个指针，作为它所引用的对象的唯一所有者。当对象的唯一指针unique_ptr被销毁时，对象将自动销毁。对意味唯一指针unique_ptr的要求是其对象只有一个所有者。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/546a203ac82ec5b5df8d5dc4e6ea887e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-02-01T19:01:22+08:00" />
<meta property="article:modified_time" content="2020-02-01T19:01:22+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43;智能指针4——唯一指针unique_ptr详解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="unique_ptr%E8%AE%BE%E8%AE%A1%E7%9B%AE%E6%A0%87-toc" style="margin-left:0px;"><a href="#unique_ptr%E8%AE%BE%E8%AE%A1%E7%9B%AE%E6%A0%87" rel="nofollow">unique_ptr设计目标</a></p> 
<p id="%E4%BD%BF%E7%94%A8unique_ptr-toc" style="margin-left:0px;"><a href="#%E4%BD%BF%E7%94%A8unique_ptr" rel="nofollow">使用unique_ptr</a></p> 
<p id="%E9%80%9A%E8%BF%87unique_ptr%E8%BD%AC%E7%A7%BB%E6%89%80%E6%9C%89%E6%9D%83-toc" style="margin-left:0px;"><a href="#%E9%80%9A%E8%BF%87unique_ptr%E8%BD%AC%E7%A7%BB%E6%89%80%E6%9C%89%E6%9D%83" rel="nofollow">通过unique_ptr转移所有权</a></p> 
<p id="%E6%BA%90%E5%92%8C%E6%A7%BD-toc" style="margin-left:0px;"><a href="#%E6%BA%90%E5%92%8C%E6%A7%BD" rel="nofollow">源和槽</a></p> 
<p id="unique_ptr%E4%BD%9C%E4%B8%BA%E7%B1%BB%E6%88%90%E5%91%98-toc" style="margin-left:0px;"><a href="#unique_ptr%E4%BD%9C%E4%B8%BA%E7%B1%BB%E6%88%90%E5%91%98" rel="nofollow">unique_ptr作为类成员</a></p> 
<p id="%E5%A4%84%E7%90%86%E6%95%B0%E7%BB%84-toc" style="margin-left:0px;"><a href="#%E5%A4%84%E7%90%86%E6%95%B0%E7%BB%84" rel="nofollow">处理数组</a></p> 
<p id="default_delete%3C%3E%E7%B1%BB-toc" style="margin-left:0px;"><a href="#default_delete%3C%3E%E7%B1%BB" rel="nofollow">default_delete&lt;&gt;类</a></p> 
<p id="%E5%85%B6%E4%BB%96%E5%85%B3%E8%81%94%E8%B5%84%E6%BA%90%E7%9A%84%E5%88%A0%E9%99%A4%E5%99%A8-toc" style="margin-left:0px;"><a href="#%E5%85%B6%E4%BB%96%E5%85%B3%E8%81%94%E8%B5%84%E6%BA%90%E7%9A%84%E5%88%A0%E9%99%A4%E5%99%A8" rel="nofollow">其他关联资源的删除器</a></p> 
<p id="unique_ptr%E8%AF%A6%E7%BB%86%E4%BF%A1%E6%81%AF-toc" style="margin-left:0px;"><a href="#unique_ptr%E8%AF%A6%E7%BB%86%E4%BF%A1%E6%81%AF" rel="nofollow">unique_ptr详细信息</a></p> 
<hr id="hr-toc"> 
<p><strong>C++11标准库提供的唯一指针unique_ptr有助于避免发生异常时的资源泄漏。</strong>它实现了专有所有权的概念，这意味着它可以确保一个对象及其关联资源一次只能由一个指针"拥有''。当此所有者被销毁或变空或开始拥有另一个对象时，先前拥有的对象也将被销毁，所有相关资源都将被释放。</p> 
<p>唯一指针unique_ptr继承了自动指针auto_ptr（该类最初是C++ 98引入的，但现在已弃用）。 唯一指针unique_ptr提供了一个简单明了的接口，与自动指针auto_ptr相比，它更不容易出错。</p> 
<h2 id="unique_ptr%E8%AE%BE%E8%AE%A1%E7%9B%AE%E6%A0%87">unique_ptr设计目标</h2> 
<p>函数通常以以下步骤运行：</p> 
<ol><li>获取一些资源；</li><li>执行一些操作；</li><li>释放获得的资源。</li></ol> 
<p>如果获取的资源已经绑定到本地对象，则在进入时获取的资源会在函数退出时自动释放，因为函数退出时调用了这些本地对象的析构函数。但是如果资源是手动获取的，并且没有绑定到任何对象，则必须手动释放它们。使用指针时通常会手动管理资源。</p> 
<p>以这种方式使用指针的典型示例是使用new和delete创建和销毁对象：</p> 
<pre class="has"><code class="language-cpp">void f()
{
    ClassA* ptr = new ClassA; //手动创建一个对象
    ... //执行一些操作
    delete ptr; //清理：手动销毁对象
}
</code></pre> 
<p>上面代码的一个明显问题是，对象的销毁可能会被遗忘，尤其是在函数内部有return语句的情况下。 还有一种不太明显的危险就是可能发生的异常将导致函数立即退出，而不会调用末尾的delete语句，最终导致资源泄漏。</p> 
<p>为了避免这种资源泄漏通常要求函数捕获所有异常。 例如：</p> 
<pre class="has"><code class="language-cpp">void f()
{
    ClassA* ptr = new ClassA; //手动创建一个对象
    try {
        ... //执行一些操作
    }
    catch (...) { //处理异常
        delete ptr; //清理
        throw; //重新抛出异常
    }
    delete ptr; //正常退出时清理
}
</code></pre> 
<p>为了在发生异常时正确处理此对象的删除，代码变得复杂和冗余。如果以这种方式处理第二个对象，或者使用了多个捕获子句，问题将变得更加严重。这不是一种好的编程风格，应避免使用，因为它很复杂且容易出错。</p> 
<p>自动指针unique_ptr可以解决这个问题。只要自动指针本身被销毁，它就可以释放其指向的数据。此外，由于它是一个局部变量，所以退出函数时唯一指针会自动销毁，无论退出是正常的还是由于异常导致的。</p> 
<p>unique_ptr是一个指针，作为它所引用的对象的唯一所有者。当对象的唯一指针unique_ptr被销毁时，对象将自动销毁。对意味唯一指针unique_ptr的要求是其对象只有一个所有者。</p> 
<p>下面是前面的示例改为使用唯一指针unique_ptr的代码：</p> 
<pre class="has"><code class="language-cpp">#include &lt;memory&gt;
void f()
{
    //创建并初始化一个unique_ptr指针
    std::unique&lt;ClassA&gt; ptr(new ClassA);
    ... //执行一些其他操作
}</code></pre> 
<p>这样修改之后就不需要删除语句和catch子句。</p> 
<h2 id="%E4%BD%BF%E7%94%A8unique_ptr">使用unique_ptr</h2> 
<p>唯一指针unique_ptr具有与普通指针几乎相同的接口；</p> 
<pre class="has"><code class="language-cpp">//创建并初始化指向字符串的unique_ptr指针
std::unique_ptr&lt;std::string&gt; up(new std::string("Tom"));
(*up)[0] = ’C’; //替换第一个字母
up-&gt;append("ming"); //追加字符串
std::cout &lt;&lt; *up &lt;&lt; std::endl; //打印整个字符串
</code></pre> 
<p>但唯一指针没有定义诸如++之类的指针算法（因为指针算法是麻烦的根源）。<br> 注意，唯一指针unique_ptr不允许使用赋值语法进行初始化，而必须使用普通指针直接初始化：</p> 
<pre class="has"><code class="language-cpp">std::unique_ptr&lt;int&gt; up = new int; //错误
std::unique_ptr&lt;int&gt; up(new int); //正确</code></pre> 
<p>唯一指针unique_ptr可以为空。例如使用默认构造函数初始化或用nullptr对唯一指针unique_ptr进行赋值或调用reset()：：</p> 
<pre class="has"><code class="language-cpp">std::unique_ptr&lt;std::string&gt; up;
up = nullptr;
up.reset();</code></pre> 
<p>另外，可以调用release()让唯一指针unique_ptr返回其拥有的对象，并放弃所有权，以便调用方对返回的对象负责：</p> 
<pre class="has"><code class="language-cpp">std::unique_ptr&lt;std::string&gt; up(new std::string("Tom"));
...
std::string* sp = up.release(); //up失去拥有权
</code></pre> 
<p>检查唯一指针unique_ptr是否拥有对象的一些方法：</p> 
<ol><li>调用操作符bool()；</li><li>与nullptr进行比较；</li><li>查询唯一指针unique_ptr中的原始指针是否为空。</li></ol> 
<pre class="has"><code class="language-cpp">if (up) { //如果up不为空
    std::cout &lt;&lt; *up &lt;&lt; std::endl;
}
if (up != nullptr) //如果up不为空
if (up.get() != nullptr) //如果up不为空</code></pre> 
<h2 id="%E9%80%9A%E8%BF%87unique_ptr%E8%BD%AC%E7%A7%BB%E6%89%80%E6%9C%89%E6%9D%83">通过唯一指针转移所有权</h2> 
<p>唯一指针unique_ptr提供排他的所有权语义，但由程序员确保同一指针不会初始化两个唯一指针unique_ptr：</p> 
<pre class="has"><code class="language-cpp">std::string* sp = new std::string("hello");
std::unique_ptr&lt;std::string&gt; up1(sp);
std::unique_ptr&lt;std::string&gt; up2(sp); //错误：up1和up2拥有相同的数据
</code></pre> 
<p>不幸的是，这是一个运行时错误无法在编译时发现，因此需要依靠程序员自己避免这种错误。</p> 
<p>使用普通的复制语义无法复制或给唯一指针unique_ptr赋值，但可以使用C++ 11提供的move语义。在这种情况下，构造函数或赋值运算符会将所有权转移到另一个唯一指针unique_ptr。</p> 
<p>例如，考虑以下拷贝构造函数的用法：</p> 
<pre class="has"><code class="language-cpp">//使用一个新对象初始化一个unique_ptr
std::unique_ptr&lt;ClassA&gt; up1(new ClassA);
//复制unique_ptr
std::unique_ptr&lt;ClassA&gt; up2(up1); //错误：编译不通过
//转移unique_ptr的所有权
std::unique_ptr&lt;ClassA&gt; up3(std::move(up1)); //正确
</code></pre> 
<p>在第一条语句之后，up1拥有使用new运算符创建的对象。 第二条语句尝试调用拷贝构造函数将导致一个编译时错误，因为up2不能成为该对象的另一个所有者。第三条语句将所有权从up1转移到up3。 因此，之后up3拥有使用new创建的对象，而up1不再拥有该对象。</p> 
<p>赋值运算符的行为类似：</p> 
<pre class="has"><code class="language-cpp">//用新对象初始化一个unique_ptr
std::unique_ptr&lt;ClassA&gt; up1(new ClassA);
std::unique_ptr&lt;ClassA&gt; up2; //创建另一个unique_ptr
up2 = up1; //错误：编译通不过
up2 = std::move(up1); //将up1的所有权转移到up2</code></pre> 
<p>移动赋值将所有权从up1转移到up2。如果up2在分配前拥有一个对象，则对该对象调用delete：</p> 
<pre class="has"><code class="language-cpp">std::unique_ptr&lt;ClassA&gt; up1(new ClassA);
std::unique_ptr&lt;ClassA&gt; up2(new ClassA);
up2 = std::move(up1); //销毁up2关联的对象，将up1关联对象的所有权转移给up2
</code></pre> 
<p>在没有获得新所有权的情况下失去对象所有权的唯一指针unique_ptr表示没有对象。</p> 
<p>要将新值赋给唯一指针unique_ptr，该新值也必须是唯一指针unique_ptr而不能是普通指针：</p> 
<pre class="has"><code class="language-cpp">std::unique_ptr&lt;ClassA&gt; ptr;
ptr = new ClassA; //错误
ptr = std::unique_ptr&lt;ClassA&gt;(new ClassA); //正确
up = nullptr; //正确，相当于调用reset()
</code></pre> 
<h2 id="%E6%BA%90%E5%92%8C%E6%A7%BD">源和槽</h2> 
<p>所有权转移意味着函数可以使用唯一指针unique_ptr将所有权转移给其他函数。 可以有两种使用方式：</p> 
<ol><li>函数可以充当数据的接收器——通过使用std::move()创建的右值引用将唯一指针unique_ptr作为参数传递给函数。 在这种情况下，被调用函数的参数将获得唯一指针unique_ptr的所有权。 <pre class="has"><code class="language-cpp">void sink(std::unique_ptr&lt;ClassA&gt; up) //形参up获得对象的所有权
{
    ...
}

std::unique_ptr&lt;ClassA&gt; up(new ClassA);
...
sink(std::move(up)); //up失去关联对象的所有权
...
</code></pre> <p> </p> </li><li>函数可以充当数据源——返回唯一指针unique_ptr时，返回值的所有权将转移到调用上下文中。 以下示例显示了此技术： <pre class="has"><code class="language-cpp">std::unique_ptr&lt;ClassA&gt; source()
{
    std::unique_ptr&lt;ClassA&gt; ptr(new ClassA);
    ...
    return ptr; //将ptr关联对象的所有权转移给调用函数
}

void g()
{
    std::unique_ptr&lt;ClassA&gt; p;
    for (int i=0; i&lt;10; ++i) {
        p = source(); //p获得返回对象的所有权
    }
}
</code></pre> <p> </p> </li></ol> 
<p>每次调用source()时，它都会使用new创建一个对象，并将该对象及其所有权返回给调用者。将返回值赋给p会将所有权转移给p。</p> 
<p>在第二遍及其他遍历循环中，对p的赋值将删除p先前拥有的对象。离开g()，从而销毁p，导致p拥有的最后一个对象的销毁。无论如何，都不会发生资源泄漏。即使抛出异常，拥有资源的任何unique_ptr也会确保删除该资源。</p> 
<p>source()的return语句中不需要std::move()的原因是，根据C++ 11的语言规则，编译器将自动尝试移动。</p> 
<h2 id="unique_ptr%E4%BD%9C%E4%B8%BA%E7%B1%BB%E6%88%90%E5%91%98">unique_ptr作为类成员</h2> 
<p>通过在类中使用唯一指针unique_ptr指针可以避免资源泄漏。</p> 
<p>如果使用唯一指针unique_ptr而不是普通的指针，则不再需要析构函数，因为对象会随着成员的删除而被删除。</p> 
<p>此外，unique_ptr有助于避免对象初始化期间引发的异常引起的资源泄漏。因为只有在完成构造后才调用析构函数，所以如果构造函数内部发生异常，则仅针对已完全构造的对象调用析构函数。如果在构造过程中第一个new执行成功而第二个new没有成功，则可能导致具有多个原始指针的类的资源泄漏。</p> 
<p>例如：</p> 
<pre class="has"><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;memory&gt;
#include &lt;sstream&gt;

using namespace std;

class ClassA {
public:
    ClassA(const string &amp; sName, const string &amp; sOwnerName, int nVal)
        : m_sName(sName), m_sOwnerName(sOwnerName)
    {
        cout &lt;&lt; "“" &lt;&lt; m_sOwnerName &lt;&lt; "”的ClassA对象“" &lt;&lt; m_sName &lt;&lt; "”开始构造" &lt;&lt; endl;
        if (0 == nVal)
        {
            runtime_error oRtEx("值不能为0\n");
            throw oRtEx;
        } else {
            m_dVal = 1.0 / nVal;
        }
        cout &lt;&lt; "“" &lt;&lt; m_sOwnerName &lt;&lt; "”的ClassA对象“" &lt;&lt; m_sName &lt;&lt; "”完成构造" &lt;&lt; endl;
    }

    ClassA(const ClassA &amp; o2BeCopy) {
        m_dVal = o2BeCopy.m_dVal;
        m_sName = o2BeCopy.m_sName;
        m_sOwnerName = o2BeCopy.m_sOwnerName;
    }

    ~ClassA() {
        cout &lt;&lt; "“" &lt;&lt; m_sOwnerName &lt;&lt; "”的ClassA对象“" &lt;&lt; m_sName &lt;&lt; "”析构" &lt;&lt; endl;
    }

    void setOwnerName(const string &amp; sOwnerName) { m_sOwnerName = sOwnerName; }

private:
    double m_dVal;
    string m_sName;
    string m_sOwnerName;
};

class ClassB {
public:
    //如果ptr2的初始化抛出异常将导致资源泄露
    ClassB (int nVal1, int nVal2, const string &amp; sName)
    {
        cout &lt;&lt; "名为“" &lt;&lt; sName &lt;&lt; "”的ClassB对象开始构造" &lt;&lt; endl;
        m_ptr1 = new ClassA("m_ptr1", sName, nVal1);
        m_ptr2 = new ClassA("m_ptr2", sName, nVal2);
        m_sName = sName;
        cout &lt;&lt; "名为“" &lt;&lt; sName &lt;&lt; "”的ClassB对象完成构造" &lt;&lt; endl;
    }

    //拷贝构造
    //如果ptr2的初始化之前抛出异常将导致资源泄露
    ClassB (const ClassB&amp; x)
    {
        cout &lt;&lt; "名为“" &lt;&lt; m_sName &lt;&lt; "”的ClassB对象开始拷贝构造" &lt;&lt; endl;
        m_ptr1 = new ClassA(*(x.m_ptr1));
        m_ptr1-&gt;setOwnerName("拷贝构造");
        ostringstream oss;
        oss &lt;&lt; "名为“" &lt;&lt; m_sName &lt;&lt; "”的ClassB对象拷贝构造出现异常\n";
        runtime_error oRtEx(oss.str());
        throw oRtEx;
        m_ptr2 = new ClassA(*(x.m_ptr2));
        m_ptr2-&gt;setOwnerName("拷贝构造");
        cout &lt;&lt; "名为“" &lt;&lt; m_sName &lt;&lt; "”的ClassB对象完成拷贝构造" &lt;&lt; endl;
    }

    //赋值运算符
    const ClassB&amp; operator= (const ClassB&amp; x) {
        *m_ptr1 = *x.m_ptr1;
        *m_ptr2 = *x.m_ptr2;
        return *this;
    }

    ~ClassB () {
        cout &lt;&lt; "名为“" &lt;&lt; m_sName &lt;&lt; "”的ClassB对象开始析构" &lt;&lt; endl;
        delete m_ptr1;
        delete m_ptr2;
        cout &lt;&lt; "名为“" &lt;&lt; m_sName &lt;&lt; "”的ClassB对象完成析构" &lt;&lt; endl;
    }

private:
        ClassA* m_ptr1; //指针成员
        ClassA* m_ptr2;
        string m_sName;
};

int main()
{
    try {
        ClassB oB(1, 0, "oB");
    } catch (const exception &amp; ex) {
        cout &lt;&lt; "ClassB oB(1, 0)执行出现异常，具体原因：" &lt;&lt; ex.what();
    }

    cout &lt;&lt; "=====================" &lt;&lt; endl;

    try {
        ClassB oB1(1, 2, "oB1");
        ClassB oB2(oB1);
    } catch (const exception &amp; ex) {
        cout &lt;&lt; "ClassB oB2(oB1)执行出现异常，具体原因：" &lt;&lt; ex.what();
    }
    return 0;
}</code></pre> 
<p>运行结果如下：</p> 
<pre class="has"><code>名为“oB”的ClassB对象开始构造
“oB”的ClassA对象“m_ptr1”开始构造
“oB”的ClassA对象“m_ptr1”完成构造
“oB”的ClassA对象“m_ptr2”开始构造
ClassB oB(1, 0)执行出现异常，具体原因：值不能为0
=====================
名为“oB1”的ClassB对象开始构造
“oB1”的ClassA对象“m_ptr1”开始构造
“oB1”的ClassA对象“m_ptr1”完成构造
“oB1”的ClassA对象“m_ptr2”开始构造
“oB1”的ClassA对象“m_ptr2”完成构造
名为“oB1”的ClassB对象完成构造
名为“”的ClassB对象开始拷贝构造
名为“oB1”的ClassB对象开始析构
“oB1”的ClassA对象“m_ptr1”析构
“oB1”的ClassA对象“m_ptr2”析构
名为“oB1”的ClassB对象完成析构
ClassB oB2(oB1)执行出现异常，具体原因：名为“”的ClassB对象拷贝构造出现异常</code></pre> 
<p>为了避免这种可能的资源泄漏，可以使用唯一指针unique_ptr指针：</p> 
<pre class="has"><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;memory&gt;
#include &lt;sstream&gt;

using namespace std;

class ClassA {
public:
    ClassA(const string &amp; sName, const string &amp; sOwnerName, int nVal)
        : m_sName(sName), m_sOwnerName(sOwnerName)
    {
        cout &lt;&lt; "“" &lt;&lt; m_sOwnerName &lt;&lt; "”的ClassA对象“" &lt;&lt; m_sName &lt;&lt; "”开始构造" &lt;&lt; endl;
        if (0 == nVal)
        {
            runtime_error oRtEx("值不能为0\n");
            throw oRtEx;
        } else {
            m_dVal = 1.0 / nVal;
        }
        cout &lt;&lt; "“" &lt;&lt; m_sOwnerName &lt;&lt; "”的ClassA对象“" &lt;&lt; m_sName &lt;&lt; "”完成构造" &lt;&lt; endl;
    }

    ClassA(const ClassA &amp; o2BeCopy) {
        m_dVal = o2BeCopy.m_dVal;
        m_sName = o2BeCopy.m_sName;
        m_sOwnerName = o2BeCopy.m_sOwnerName;
    }

    ~ClassA() {
        cout &lt;&lt; "“" &lt;&lt; m_sOwnerName &lt;&lt; "”的ClassA对象“" &lt;&lt; m_sName &lt;&lt; "”析构" &lt;&lt; endl;
    }

    void setOwnerName(const string &amp; sOwnerName) { m_sOwnerName = sOwnerName; }

private:
    double m_dVal;
    string m_sName;
    string m_sOwnerName;
};

class ClassB {
public:
    //如果ptr2的初始化抛出异常将导致资源泄露
    ClassB (int nVal1, int nVal2, const string &amp; sName)
    {
        cout &lt;&lt; "名为“" &lt;&lt; sName &lt;&lt; "”的ClassB对象开始构造" &lt;&lt; endl;
        m_ptr1 = unique_ptr&lt;ClassA&gt;(new ClassA("m_ptr1", sName, nVal1));
        m_ptr2 = unique_ptr&lt;ClassA&gt;(new ClassA("m_ptr2", sName, nVal2));
        m_sName = sName;
        cout &lt;&lt; "名为“" &lt;&lt; sName &lt;&lt; "”的ClassB对象完成构造" &lt;&lt; endl;
    }

    //拷贝构造
    //如果ptr2的初始化之前抛出异常将导致资源泄露
    ClassB (const ClassB&amp; x)
    {
        cout &lt;&lt; "名为“" &lt;&lt; m_sName &lt;&lt; "”的ClassB对象开始拷贝构造" &lt;&lt; endl;
        m_ptr1 = unique_ptr&lt;ClassA&gt;(new ClassA(*(x.m_ptr1)));
        m_ptr1-&gt;setOwnerName("拷贝构造");
        ostringstream oss;
        oss &lt;&lt; "名为“" &lt;&lt; m_sName &lt;&lt; "”的ClassB对象拷贝构造出现异常\n";
        runtime_error oRtEx(oss.str());
        throw oRtEx;
        m_ptr2 = unique_ptr&lt;ClassA&gt;(new ClassA(*(x.m_ptr2)));
        m_ptr2-&gt;setOwnerName("拷贝构造");
        cout &lt;&lt; "名为“" &lt;&lt; m_sName &lt;&lt; "”的ClassB对象完成拷贝构造" &lt;&lt; endl;
    }

    //赋值运算符
    const ClassB&amp; operator= (const ClassB&amp; x) {
        *m_ptr1 = *x.m_ptr1;
        *m_ptr2 = *x.m_ptr2;
        return *this;
    }

private:
        unique_ptr&lt;ClassA&gt; m_ptr1; //指针成员
        unique_ptr&lt;ClassA&gt; m_ptr2;
        string m_sName;
};

int main()
{
    try {
        ClassB oB(1, 0, "oB");
    } catch (const exception &amp; ex) {
        cout &lt;&lt; "ClassB oB(1, 0)执行出现异常，具体原因：" &lt;&lt; ex.what();
    }

    cout &lt;&lt; "=====================" &lt;&lt; endl;

    try {
        ClassB oB1(1, 2, "oB1");
        ClassB oB2(oB1);
    } catch (const exception &amp; ex) {
        cout &lt;&lt; "ClassB oB2(oB1)执行出现异常，具体原因：" &lt;&lt; ex.what();
    }

    return 0;
}</code></pre> 
<p>运行结果如下：</p> 
<pre class="has"><code class="language-cpp">名为“oB”的ClassB对象开始构造
“oB”的ClassA对象“m_ptr1”开始构造
“oB”的ClassA对象“m_ptr1”完成构造
“oB”的ClassA对象“m_ptr2”开始构造
“oB”的ClassA对象“m_ptr1”析构
ClassB oB(1, 0)执行出现异常，具体原因：值不能为0
=====================
名为“oB1”的ClassB对象开始构造
“oB1”的ClassA对象“m_ptr1”开始构造
“oB1”的ClassA对象“m_ptr1”完成构造
“oB1”的ClassA对象“m_ptr2”开始构造
“oB1”的ClassA对象“m_ptr2”完成构造
名为“oB1”的ClassB对象完成构造
名为“”的ClassB对象开始拷贝构造
“拷贝构造”的ClassA对象“m_ptr1”析构
“oB1”的ClassA对象“m_ptr2”析构
“oB1”的ClassA对象“m_ptr1”析构
ClassB oB2(oB1)执行出现异常，具体原因：名为“”的ClassB对象拷贝构造出现异常</code></pre> 
<p>现在可以不需要析构函数了，因为唯一指针unique_ptr会完成资源的释放。 不过使用了唯一指针unique_ptr之后就必须实现拷贝构造函数和重载赋值运算符，因为默认情况下两者都将尝试复制成员或为成员进行赋值，但由于唯一指针unique_ptr会让两者发生错误。 如果不提供它们，则ClassB也将仅提供移动语义。</p> 
<h2 id="%E5%A4%84%E7%90%86%E6%95%B0%E7%BB%84">处理数组</h2> 
<p>默认情况下，如果唯一指针失去所有权，则对其拥有的对象调用delete。 不幸的是，由于源于C的语言规则，C++无法区分指向一个对象的指针的类型和对象的数组的类型。 但是，根据数组的语言规则，必须调用运算符delete []而不是delete。 因此，以下代码可以编译通过，但会导致运行时错误：</p> 
<pre class="has"><code class="language-cpp">std::unique_ptr&lt;std::string&gt; up(new std::string[10]); //运行时错误</code></pre> 
<p>幸运的是，C++标准库为唯一指针unique_ptr针对数组提供了特殊处理，当指针失去对所引用对象的所有权时，该类将对引用对象调用delete []。</p> 
<p>因此，只需要声明：</p> 
<pre class="has"><code class="language-cpp">std::unique_ptr&lt;std::string[]&gt; up(new std::string[10]);</code></pre> 
<p>注意，唯一指针unique_ptr针对数组的接口与针对普通指针的接口略有不同——不提供运算符*和-&gt;，而是提供运算符[]来访问引用数组内的对象：</p> 
<pre class="has"><code class="language-cpp">std::unique_ptr&lt;std::string[]&gt; up(new std::string[10]);
...
std::cout &lt;&lt; *up &lt;&lt; std::endl; //错误：没有为数组定义*运算符
std::cout &lt;&lt; up[0] &lt;&lt; std::endl;</code></pre> 
<p>与普通数组的索引一样，由程序员来确保索引有效。使用无效的索引会导致未定义的行为。</p> 
<p>还要注意，唯一指针unique_ptr不允许通过派生类型的数组进行初始化。 这反映了多态不适用于普通数组的事实。</p> 
<h2 id="default_delete%3C%3E%E7%B1%BB">default_delete&lt;&gt;类</h2> 
<p>让我们看一下unique_ptr类的声明。 从概念上讲，此类声明为以下内容：</p> 
<pre class="has"><code class="language-cpp">namespace std {
    //初始模板
    template &lt;typename T, typename D = default_delete&lt;T&gt;&gt;
    class unique_ptr
    {
    public:
        ...
        T&amp; operator*() const;
        T* operator-&gt;() const noexcept;
        ...
    };

    //针对数组进行偏特化
    template&lt;typename T, typename D&gt;
    class unique_ptr&lt;T[], D&gt;
    {
        public:
        ...
        T&amp; operator[](size_t i) const;
        ...
    }
}</code></pre> 
<p>可以看到有一个特殊版本的唯一指针unique_ptr用于处理数组。 该版本提供了运算符[]而不是运算符*和-&gt;来处理数组而不是单个对象，但都使用类std :: default_delete&lt;&gt;作为删除器，它本身专门用于调用delete []而不是对数组的delete：</p> 
<pre class="has"><code class="language-cpp">namespace std {
    //初始模板
    template &lt;typename T&gt;
    class default_delete 
    {
    public:
        void operator()(T* p) const; //调用delete p

        ...
    };

    //针对数组进行偏特化
    template &lt;typename T&gt; 
    class default_delete&lt;T[]&gt; 
    {
    public:
        void operator()(T* p) const; //调用delete[] p
        ...
    };
}</code></pre> 
<p>默认模板参数也自动适用于偏特化。</p> 
<h2 id="%E5%85%B6%E4%BB%96%E5%85%B3%E8%81%94%E8%B5%84%E6%BA%90%E7%9A%84%E5%88%A0%E9%99%A4%E5%99%A8">其他关联资源的删除器</h2> 
<p>当唯一指针unique_ptr引用的对象销毁时需要进行除delete或delete []之外的其他操作时，必须自定义删除器。 unique_ptr定义删除器的方法与shared_ptr略有不同——必须将删除器的类型指定为第二个模板参数。</p> 
<p>该类型可以是对函数，函数指针或函数对象的引用。如果使用了函数对象，则应声明其“函数调用操作符”()以指向该对象的指针。</p> 
<p>例如，以下代码在删除对象之前会打印一条附加消息：</p> 
<pre class="has"><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;memory&gt;

using namespace std;

class ClassA {};

class ClassADeleter
{
public:
    void operator () (ClassA* p) {
        cout &lt;&lt; "调用ClassA对象的删除器" &lt;&lt; std::endl;
        delete p;
    }
};

int main()
{
    unique_ptr&lt;ClassA, ClassADeleter&gt; oUp(new ClassA());
    return 0;
}</code></pre> 
<p>要指定函数或lambda表达式，必须将删除程序的类型声明为void(*)(T *)或std::function &lt;void (T *)&gt;或使用decltype。 例如，要将自定义删除器用于整数数组，其代码如下所示：</p> 
<pre class="has"><code class="language-cpp">std::unique_ptr&lt;int,void(*)(int*)&gt; up(new int[10],
                                      [](int* p) {
                                          ...
                                          delete[] p;
                                      });


std::unique_ptr&lt;int,std::function&lt;void(int*)&gt;&gt; up(new int[10],
                                                  [](int* p) {
                                                      ...
                                                      delete[] p;
                                                  });

auto l = [](int* p) {
    ...
    delete[] p;
};
std::unique_ptr&lt;int,decltype(l)&gt;&gt; up(new int[10], l);</code></pre> 
<p>为避免在传递函数指针或lambda时指定删除器的类型，还可以使用别名模板，这是C++ 11提供的一种语言功能：</p> 
<pre class="has"><code class="language-cpp">template &lt;typename T&gt;
using uniquePtr = std::unique_ptr&lt;T,void(*)(T*)&gt;; //别名模板
...
uniquePtr&lt;int&gt; up(new int[10], [](int* p) {//此处使用
    ...
    delete[] p;
});</code></pre> 
<p>这样使用与shared_ptrs大致相同的接口来指定删除器。<br> 这是使用自定义删除器的完整示例：</p> 
<pre class="has"><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;memory&gt;
#include &lt;dirent.h&gt;
#include &lt;cstring&gt;
#include &lt;cerrno&gt;

using namespace std;

class DirCloser
{
public:
    void operator () (DIR* dp) {
        if (closedir(dp) != 0) {
            std::cerr &lt;&lt; "closedir()失败" &lt;&lt; std::endl;
        }
    }
};

int main()
{
    //打开当前目录
    unique_ptr&lt;DIR, DirCloser&gt; pDir(opendir("."));
    //处理目录中每个项目（文件或目录）
    struct dirent *dp;
    while ((dp = readdir(pDir.get())) != nullptr) {
        string filename(dp-&gt;d_name);
        cout &lt;&lt; "处理" &lt;&lt; filename &lt;&lt; endl;
    }
}</code></pre> 
<p>在main()内部使用opendir()，readdir()和closedir()的标准POSIX接口处理当前目录的条目。 为了确保在任何情况下都由closedir()关闭打开的目录，定义了一个unique_ptr，每当引用打开目录的句柄被销毁时，都会导致DirCloser被调用。 唯一指针的删除器可能不会抛出异常。 因此，仅打印错误消息。</p> 
<p>使用unique_ptr的另一个优点是不可复制。 请注意，readdir()并非无状态，因此最好确保在使用句柄处理目录时，句柄的副本不能修改其状态。</p> 
<p>如果您不想处理closedir()的返回值，也可以传递closedir()直接作为函数指针，指定删除器为函数指针。</p> 
<pre class="has"><code class="language-cpp">unique_ptr&lt;DIR,int(*)(DIR*)&gt; pDir(opendir("."), closedir); //可能失效
</code></pre> 
<p>注意以上代码不能保证可移植，因为closedir具有外部的“C”链接，因此在C++代码中，不能保证将其转换为int(*)(DIR *)。 对于可移植代码，需要定义下面的中间类型：</p> 
<pre class="has"><code class="language-cpp">extern "C" typedef int(*DIRDeleter)(DIR*);
unique_ptr&lt;DIR, DIRDeleter&gt; pDir(opendir("."), closedir); //正确</code></pre> 
<p>closedir()返回一个int，因此必须指定int(*)(DIR *)作为Deleter的类型。 注意，通过函数指针进行的调用是间接调用，很难进行优化。</p> 
<h2 id="unique_ptr%E8%AF%A6%E7%BB%86%E4%BF%A1%E6%81%AF">unique_ptr详细信息</h2> 
<p>unique_ptr具有专有所有权的概念——当其拥有排他控制权后，程序将无法创建多个unique_ptr拥有相同的关联对象。</p> 
<p>unique_ptr的主要目标是确保在指针生命周期结束时删除关联的对象（或清理其资源）。这尤其有助于提供异常安全性。 与共享指针shared_ptr相反，此类的重点是最小的空间和时间开销。</p> 
<p>对类unique_ptr&lt;&gt;进行模板化，以指定初始指针所指向的对象的类型及其变量：</p> 
<pre class="has"><code class="language-cpp">namespace std {
    template &lt;typename T, typename D = default_delete&lt;T&gt;&gt;
    class unique_ptr
    {
    public:
        typedef ... pointer; //可能是D::pointer
        typedef T element_type;
        typedef D deleter_type;
        ...
    };
}</code></pre> 
<p>提供了数组的偏特化（根据语言规则，它具有相同的默认变量，即default_delete &lt;T []&gt;）：</p> 
<pre class="has"><code class="language-cpp">namespace std {
    template &lt;typename T, typename D&gt;
    class unique_ptr&lt;T[], D&gt;
    {
    public:
        typedef ... pointer; //可能是D::pointer
        typedef T element_type;
        typedef D deleter_type;
        ...
    };
}
</code></pre> 
<p>元素类型T可能为void，因此unique_ptr拥有一个类型未指定的对象，就像void *。还要注意，虽然定义了pointer类型，但其不一定为T *。如果删除程序D定义了pointer类型，则将使用此类型。在这种情况下，模板参数T仅具有类型标签的作用，因为在类unique_ptr &lt;&gt;中没有成员依赖于T；一切都取决于pointer。这样做的优点是unique_ptr可以容纳其他智能指针。</p> 
<p>下表列出了为唯一指针提供的所有操作。</p> 
<table cellspacing="0"><tbody><tr><td style="vertical-align:middle;width:204px;"><span style="color:#000000;">操作</span></td><td style="vertical-align:middle;width:561px;"><span style="color:#000000;">结果</span></td></tr><tr><td style="vertical-align:middle;width:204px;"><span style="color:#000000;">unique_ptr&lt;...&gt; up</span></td><td style="vertical-align:middle;width:561px;"><span style="color:#000000;">默认构造函数；使用默认/传递的删除器类型的实例作为删除器，创建一个空的唯一指针</span></td></tr><tr><td style="vertical-align:middle;width:204px;"><span style="color:#000000;">unique_ptr&lt;T&gt; up(nullptr)</span></td><td style="vertical-align:middle;width:561px;"><span style="color:#000000;">使用默认/传递的删除器类型的实例作为删除器，创建一个空的唯一指针</span></td></tr><tr><td style="vertical-align:middle;width:204px;"><span style="color:#000000;">unique_ptr&lt;...&gt; up(ptr)</span></td><td style="vertical-align:middle;width:561px;"><span style="color:#000000;">使用默认/传递的删除器类型的实例作为删除器，创建拥有* ptr的唯一指针</span></td></tr><tr><td style="vertical-align:middle;width:204px;"><span style="color:#000000;">unique_ptr&lt;...&gt; up(ptr,del)</span></td><td style="vertical-align:middle;width:561px;"><span style="color:#000000;">使用del作为删除器创建拥有* ptr的唯一指针</span></td></tr><tr><td style="vertical-align:middle;width:204px;"><span style="color:#000000;">unique_ptr&lt;T&gt; up(move(up2))</span></td><td style="vertical-align:middle;width:561px;"><span style="color:#000000;">创建一个拥有up2先前拥有的指针的唯一指针（此后up2为空）</span></td></tr><tr><td style="vertical-align:middle;width:204px;"><span style="color:#000000;">unique_ptr&lt;T&gt; up(move(ap))</span></td><td style="vertical-align:middle;width:561px;"><span style="color:#000000;">创建一个拥有先前由auto_ptr ap拥有的指针的唯一指针（此后ap为空）</span></td></tr><tr><td style="vertical-align:middle;width:204px;"><span style="color:#000000;">up.~unique_ptr()</span></td><td style="vertical-align:middle;width:561px;"><span style="color:#000000;">析构函数；调用拥有者对象的删除器</span></td></tr><tr><td style="vertical-align:middle;width:204px;"><span style="color:#000000;">up = move(up2)</span></td><td style="vertical-align:middle;width:561px;"><span style="color:#000000;">移动赋值（up2将所有权转移到up）</span></td></tr><tr><td style="vertical-align:middle;width:204px;"><span style="color:#000000;">up = nullptr</span></td><td style="vertical-align:middle;width:561px;"><span style="color:#000000;">调用拥有者对象的删除器，并使其为空（等同于up.reset()）</span></td></tr><tr><td style="vertical-align:middle;width:204px;"><span style="color:#000000;">up1.swap(up2)</span></td><td style="vertical-align:middle;width:561px;"><span style="color:#000000;">交换up1和up2的指针和删除器</span></td></tr><tr><td style="vertical-align:middle;width:204px;"><span style="color:#000000;">swap(up1,up2)</span></td><td style="vertical-align:middle;width:561px;"><span style="color:#000000;">交换up1和up2的指针和删除器</span></td></tr><tr><td style="vertical-align:middle;width:204px;"><span style="color:#000000;">up.reset()</span></td><td style="vertical-align:middle;width:561px;"><span style="color:#000000;">调用拥有者对象的删除器，并使其为空（相当于up = nullptr）</span></td></tr><tr><td style="vertical-align:middle;width:204px;"><span style="color:#000000;">up.reset(ptr)</span></td><td style="vertical-align:middle;width:561px;"><span style="color:#000000;">调用拥有者对象的删除器，并将共享指针重新初始化为自己的* ptr</span></td></tr><tr><td style="vertical-align:middle;width:204px;"><span style="color:#000000;">up.release()</span></td><td style="vertical-align:middle;width:561px;"><span style="color:#000000;">将所有权放弃给调用者（不调用删除器就返回拥有的对象）</span></td></tr><tr><td style="vertical-align:middle;width:204px;"><span style="color:#000000;">up.get()</span></td><td style="vertical-align:middle;width:561px;"><span style="color:#000000;">返回存储的指针（拥有的对象的地址；如果没有，则返回nullptr）</span></td></tr><tr><td style="vertical-align:middle;width:204px;"><span style="color:#000000;">*up</span></td><td style="vertical-align:middle;width:561px;"><span style="color:#000000;">仅单个对象；返回拥有的对象（如果没有，则为未定义的行为）</span></td></tr><tr><td style="vertical-align:middle;width:204px;"><span style="color:#000000;">up-&gt;...</span></td><td style="vertical-align:middle;width:561px;"><span style="color:#000000;">仅单个对象；提供拥有对象的成员访问权限（如果没有，则为未定义的行为）</span></td></tr><tr><td style="vertical-align:middle;width:204px;"><span style="color:#000000;">up[idx]</span></td><td style="vertical-align:middle;width:561px;"><span style="color:#000000;">仅数组对象；返回具有存储数组的索引idx的元素（如果没有，则为未定义的行为）</span></td></tr><tr><td style="vertical-align:middle;width:204px;"><span style="color:#000000;">if (up)</span></td><td style="vertical-align:middle;width:561px;"><span style="color:#000000;">运算符bool()；返回up是否为空</span></td></tr><tr><td style="vertical-align:middle;width:204px;"><span style="color:#000000;">up1 == up2</span></td><td style="vertical-align:middle;width:561px;"><span style="color:#000000;">对存储的指针调用==（可以为nullptr）</span></td></tr><tr><td style="vertical-align:middle;width:204px;"><span style="color:#000000;">up1 != up2</span></td><td style="vertical-align:middle;width:561px;"><span style="color:#000000;">对存储的指针调用!=（可以为nullptr）</span></td></tr><tr><td style="vertical-align:middle;width:204px;"><span style="color:#000000;">up1 &lt; up2</span></td><td style="vertical-align:middle;width:561px;"><span style="color:#000000;">对存储的指针调用&lt;（可以为nullptr）</span></td></tr><tr><td style="vertical-align:middle;width:204px;"><span style="color:#000000;">up1 &lt;= up2</span></td><td style="vertical-align:middle;width:561px;"><span style="color:#000000;">对存储的指针调用&lt;=（可以为nullptr）</span></td></tr><tr><td style="vertical-align:middle;width:204px;"><span style="color:#000000;">up1 &gt; up2</span></td><td style="vertical-align:middle;width:561px;"><span style="color:#000000;">对存储的指针调用&gt;（可以为nullptr）</span></td></tr><tr><td style="vertical-align:middle;width:204px;"><span style="color:#000000;">up1 &gt;= up2</span></td><td style="vertical-align:middle;width:561px;"><span style="color:#000000;">对存储的指针调用&gt;=（可以为nullptr）</span></td></tr><tr><td style="vertical-align:middle;width:204px;"><span style="color:#000000;">up.get_deleter()</span></td><td style="vertical-align:middle;width:561px;"><span style="color:#000000;">返回删除器的引用</span></td></tr></tbody></table> 
<p>对于不同类型，以指针和删除器为参数的构造函数已重载，因此指定了以下行为：</p> 
<pre class="has"><code class="language-cpp">D d; //创建删除器对象
unique_ptr&lt;int, D&gt; p1(new int, D()); //D必须支持移动构造
unique_ptr&lt;int, D&gt; p2(new int, d); //D必须支持拷贝构造
unique_ptr&lt;int, D&amp;&gt; p3(new int, d); //p3保持一个对d的引用
unique_ptr&lt;int, const D&amp;&gt; p4(new int, D()); //错误：右值删除器对象不能具有引用删除器类型
</code></pre> 
<p>对于单个对象，移动构造函数和赋值运算符是成员模板，因此可以进行类型转换。所有比较运算符都针对不同的元素和变量类型进行了模板化。</p> 
<p>所有比较运算符都会调用unique_ptr指针内部使用的原始指针相应的比较运算符（相当于对get()返回的值调用相同的运算符）。它们都将nullptr作为参数进行重载，因此，您可以检查是否存在有效的指针，甚至可以检查原始指针是否小于或大于nullptr。</p> 
<p>与单对象接口相比，数组类型的偏特化接口具有以下差异：</p> 
<ul><li>提供了运算符[]，而不是运算符*和-&gt;。</li><li>默认删除程序调用delete []，而不是delete。</li><li>不支持不同类型之间的转换。指向派生元素类型的指针尤其不可能。</li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/828d1955377e03fc116fb7e20bf1d5de/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">undefined reference to `ceres::Solve(ceres::Solver::Options const&amp;, ceres::Problem*,</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/2e921506bbd85934f9c4984b7381cca8/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">新冠病毒破解有了巨大突破，达摩院做了什么？</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>