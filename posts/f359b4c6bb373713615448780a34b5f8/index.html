<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>翻译: Streamlit从入门到精通六 实战缓存Cache请求数据 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="翻译: Streamlit从入门到精通六 实战缓存Cache请求数据" />
<meta property="og:description" content="Streamlit从入门到精通 系列：
翻译: Streamlit从入门到精通 基础控件 一翻译: Streamlit从入门到精通 显示图表Graphs 地图Map 主题Themes 二翻译: Streamlit从入门到精通 构建一个机器学习应用程序 三翻译: Streamlit从入门到精通 部署一个机器学习应用程序 四翻译: Streamlit从入门到精通 高级用法缓存Cache和Session 五
1. 两个缓存装饰器： st.cache_data 是缓存返回数据的计算的推荐方法：从 CSV 加载 DataFrame、转换 NumPy 数组、查询 API 或任何其他返回可序列化数据对象的函数（str、int、float、DataFrame、array、list 等）。它会在每次函数调用时创建一个新的数据副本，使其免受突变和竞争条件的影响。st.cache_data的行为是您想要的——所以如果您不确定，请从st.cache_data开始，看看它是否有效！st.cache_resource 是缓存全局资源（如 ML 模型或数据库连接）的推荐方法，这些资源是您不想多次加载的不可序列化对象。使用它，您可以在应用程序的所有重新运行和会话之间共享这些资源，而无需复制或复制。请注意，对缓存返回值的任何突变都会直接改变缓存中的对象（更多详细信息见下文）。 2. 基本用法 st.cache_data 是所有返回数据的函数的首选命令，无论是 DataFrames、NumPy 数组、str、int、float 还是其他可序列化类型。对于几乎所有用例来说，这都是正确的命令！
让我们看一个使用 st.cache_data 的例子。假设您的应用将优步拼车数据集（一个 50 MB 的 CSV 文件）从互联网加载到 DataFrame 中：
import streamlit as st import time import pandas as pd def load_data(url): df = pd.read_csv(url) return df df = load_data(&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/f359b4c6bb373713615448780a34b5f8/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-18T21:15:40+08:00" />
<meta property="article:modified_time" content="2024-01-18T21:15:40+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">翻译: Streamlit从入门到精通六 实战缓存Cache请求数据</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>Streamlit从入门到精通 系列：</p> 
<ol><li><a href="https://blog.csdn.net/zgpeace/article/details/135573471">翻译: Streamlit从入门到精通 基础控件 一</a></li><li><a href="https://blog.csdn.net/zgpeace/article/details/135579400">翻译: Streamlit从入门到精通 显示图表Graphs 地图Map 主题Themes 二</a></li><li><a href="https://blog.csdn.net/zgpeace/article/details/135592692">翻译: Streamlit从入门到精通 构建一个机器学习应用程序 三</a></li><li><a href="https://blog.csdn.net/zgpeace/article/details/135611794">翻译: Streamlit从入门到精通 部署一个机器学习应用程序 四</a></li><li><a href="https://blog.csdn.net/zgpeace/article/details/135661377">翻译: Streamlit从入门到精通 高级用法缓存Cache和Session 五</a><br> <img src="https://images2.imgbox.com/68/40/cq89MW6r_o.png" alt="在这里插入图片描述"></li></ol> 
<h2><a id="1__7"></a>1. 两个缓存装饰器：</h2> 
<ul><li><code>st.cache_data</code> 是缓存返回数据的计算的推荐方法：从 <code>CSV</code> 加载 <code>DataFrame</code>、转换 <code>NumPy</code> 数组、查询 <code>API</code> 或任何其他返回可序列化数据对象的函数（str、int、float、DataFrame、array、list 等）。它会在每次函数调用时创建一个新的数据副本，使其免受突变和竞争条件的影响。<code>st.cache_data</code>的行为是您想要的——所以如果您不确定，请从<code>st.cache_data</code>开始，看看它是否有效！</li><li><code>st.cache_resource</code> 是缓存全局资源（如 ML 模型或数据库连接）的推荐方法，这些资源是您不想多次加载的不可序列化对象。使用它，您可以在应用程序的所有重新运行和会话之间共享这些资源，而无需复制或复制。请注意，对缓存返回值的任何突变都会直接改变缓存中的对象（更多详细信息见下文）。</li></ul> 
<p><img src="https://images2.imgbox.com/ce/da/ZpUEhkRG_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="2__12"></a>2. 基本用法</h2> 
<p><code>st.cache_data</code> 是所有返回数据的函数的首选命令，无论是 DataFrames、NumPy 数组、str、int、float 还是其他可序列化类型。对于几乎所有用例来说，这都是正确的命令！</p> 
<p>让我们看一个使用 <code>st.cache_data</code> 的例子。假设您的应用将优步拼车数据集（一个 50 MB 的 CSV 文件）从互联网加载到 DataFrame 中：</p> 
<pre><code class="prism language-python"><span class="token keyword">import</span> streamlit <span class="token keyword">as</span> st
<span class="token keyword">import</span> time
<span class="token keyword">import</span> pandas <span class="token keyword">as</span> pd

<span class="token keyword">def</span> <span class="token function">load_data</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">:</span>
    df <span class="token operator">=</span> pd<span class="token punctuation">.</span>read_csv<span class="token punctuation">(</span>url<span class="token punctuation">)</span>
    <span class="token keyword">return</span> df

df <span class="token operator">=</span> load_data<span class="token punctuation">(</span><span class="token string">"https://github.com/plotly/datasets/raw/master/uber-rides-data1.csv"</span><span class="token punctuation">)</span>
st<span class="token punctuation">.</span>dataframe<span class="token punctuation">(</span>df<span class="token punctuation">)</span>

st<span class="token punctuation">.</span>button<span class="token punctuation">(</span><span class="token string">"Rerun"</span><span class="token punctuation">)</span>
</code></pre> 
<p>运行 load_data 功能需要 2 到 30 秒，具体取决于您的互联网连接。（提示：如果您的连接速度较慢，请<a href="https://github.com/plotly/datasets/blob/master/26k-consumer-complaints.csv">改用此 5 MB 数据集</a>）。如果不进行缓存，则每次加载应用或进行用户交互时都会重新运行下载。点击我们添加的按钮自己试试吧！不是一次很棒的体验…😕</p> 
<p><img src="https://images2.imgbox.com/cd/26/RCnvQ5Lj_o.png" alt="在这里插入图片描述"><br> 现在让我们在load_data上添加 @st.cache_data 装饰器：</p> 
<pre><code class="prism language-python"><span class="token keyword">import</span> streamlit <span class="token keyword">as</span> st
<span class="token keyword">import</span> time
<span class="token keyword">import</span> pandas <span class="token keyword">as</span> pd

<span class="token decorator annotation punctuation">@st<span class="token punctuation">.</span>cache_data</span>  <span class="token comment"># 👈 Add the caching decorator</span>
<span class="token keyword">def</span> <span class="token function">load_data</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">:</span>
    df <span class="token operator">=</span> pd<span class="token punctuation">.</span>read_csv<span class="token punctuation">(</span>url<span class="token punctuation">)</span>
    <span class="token keyword">return</span> df

df <span class="token operator">=</span> load_data<span class="token punctuation">(</span><span class="token string">"https://github.com/plotly/datasets/raw/master/uber-rides-data1.csv"</span><span class="token punctuation">)</span>
st<span class="token punctuation">.</span>dataframe<span class="token punctuation">(</span>df<span class="token punctuation">)</span>

st<span class="token punctuation">.</span>button<span class="token punctuation">(</span><span class="token string">"Rerun"</span><span class="token punctuation">)</span>
</code></pre> 
<p>再次运行应用。您会注意到，下载速度慢只发生在第一次运行时。随后的每次重播都应该几乎是即时的！💨</p> 
<h3><a id="21__54"></a>2.1 这是如何工作的？</h3> 
<p>让我们一步一步地了解<code>st.cache_data</code>的行为：</p> 
<ul><li>在第一次运行时，Streamlit 识别出它从未使用指定的参数值（CSV 文件的 URL）调用过 load_data 函数，因此它运行该函数并下载数据。</li><li>现在我们的缓存机制变得活跃：返回的 DataFrame 通过 <a href="https://docs.python.org/3/library/pickle.html" rel="nofollow">pickle 序列化</a>（转换为字节）并存储在缓存中（与 url 参数的值一起）。</li><li>在下次运行时，Streamlit 会检查缓存中是否有具有特定 url 的 <code>load_data</code> 条目。有一个！因此，它检索缓存的对象，将其反序列化为 <code>DataFrame</code>，然后返回它，而不是重新运行函数并再次下载数据。</li></ul> 
<p>序列化和反序列化缓存对象的过程会创建原始 DataFrame 的副本。虽然这种复制行为似乎没有必要，但这是我们在缓存数据对象时想要的，因为它有效地防止了突变和并发问题。请阅读下面的“<a href="https://docs.streamlit.io/library/advanced-features/caching#mutation-and-concurrency-issues" rel="nofollow">突变和并发问题</a>”部分，以更详细地了解这一点。</p> 
<blockquote> 
 <p>Warning警告<br> <code>st.cache_data</code>隐式使用 <code>pickle</code> 模块，该模块已知不安全。缓存函数返回的任何内容都会被酸洗和存储，然后在检索时取消酸洗。确保缓存的函数返回受信任的值，因为可能会构造恶意 <code>pickle</code> 数据，这些数据将在取消<code>pickling</code> 期间执行任意代码。切勿在不安全模式下加载可能来自不受信任的来源或可能已被篡改的数据。仅加载您信任的数据。</p> 
</blockquote> 
<h3><a id="22_DataFrame__65"></a>2.2 DataFrame 转换</h3> 
<p>在上面的示例中，我们已经展示了如何缓存加载 DataFrame。缓存 DataFrame 转换（如 <code>df.filter</code> 或 <code>df.sort_values</code>）也很有用。特别是对于大型 DataFrame，这些操作可能会很慢。</p> 
<pre><code class="prism language-python">
<span class="token decorator annotation punctuation">@st<span class="token punctuation">.</span>cache_data</span>
<span class="token keyword">def</span> <span class="token function">transform</span><span class="token punctuation">(</span>df<span class="token punctuation">)</span><span class="token punctuation">:</span>
    df <span class="token operator">=</span> df<span class="token punctuation">.</span><span class="token builtin">filter</span><span class="token punctuation">(</span>items<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">'Date/Time'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment"># 示例 1：筛选特定列</span>
    <span class="token comment"># df = df.apply(np.sum, axis=0)</span>
    <span class="token keyword">return</span> df

df <span class="token operator">=</span> transform<span class="token punctuation">(</span>df<span class="token punctuation">)</span>
st<span class="token punctuation">.</span>dataframe<span class="token punctuation">(</span>df<span class="token punctuation">)</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/26/02/K2oDIJjN_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="23__API__80"></a>2.3 缓存 API 调用</h3> 
<p>这样做还可以避免速率限制。</p> 
<pre><code class="prism language-python"><span class="token decorator annotation punctuation">@st<span class="token punctuation">.</span>cache_data</span>
<span class="token keyword">def</span> <span class="token function">api_call</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    response <span class="token operator">=</span> requests<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">'https://jsonplaceholder.typicode.com/posts/1'</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> response<span class="token punctuation">.</span>json<span class="token punctuation">(</span><span class="token punctuation">)</span>
api_response <span class="token operator">=</span> api_call<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"api call"</span><span class="token punctuation">,</span> api_response<span class="token punctuation">)</span>
st<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">"api call"</span><span class="token punctuation">,</span> api_response<span class="token punctuation">)</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/82/b5/MLBpopki_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="24__ML__93"></a>2.4 运行 ML 模型（推理）</h3> 
<p>运行复杂的机器学习模型可能会占用大量时间和内存。为避免一遍又一遍地重新运行相同的计算，请使用缓存。</p> 
<pre><code class="prism language-python"><span class="token decorator annotation punctuation">@st<span class="token punctuation">.</span>cache_data</span>
<span class="token keyword">def</span> <span class="token function">run_model</span><span class="token punctuation">(</span>inputs<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">return</span> model<span class="token punctuation">(</span>inputs<span class="token punctuation">)</span>
</code></pre> 
<h2><a id="3_stcache_resource_102"></a>3. <code>st.cache_resource</code></h2> 
<p><code>st.cache_resource</code> 是缓存“资源”的正确命令，这些资源应该在所有用户、会话和重新运行中全局可用。与<code>st.cache_data</code>相比，它的用例更有限，尤其是在缓存数据库连接和 ML 模型方面。</p> 
<p>作为<code>st.cache_resource</code>示例，让我们看一个典型的机器学习应用。第一步，我们需要加载一个 ML 模型。我们使用 Hugging Face 的 transformers 库来做到这一点：</p> 
<pre><code class="prism language-python"><span class="token keyword">from</span> transformers <span class="token keyword">import</span> pipeline
model <span class="token operator">=</span> pipeline<span class="token punctuation">(</span><span class="token string">"sentiment-analysis"</span><span class="token punctuation">)</span>  <span class="token comment"># 👈 Load the model</span>
</code></pre> 
<p>如果我们将此代码直接放入 Streamlit 应用程序中，则该应用程序将在每次重新运行或用户交互时加载模型。重复加载模型会带来两个问题：</p> 
<ul><li>加载模型需要时间并减慢应用程序的速度。</li><li>每个会话都从头开始加载模型，这会占用大量内存。</li></ul> 
<p>相反，加载一次模型并在所有用户和会话中使用相同的对象会更有意义。这正是<code>st.cache_resource</code>的用例！让我们将其添加到我们的应用程序中，并处理用户输入的一些文本：</p> 
<pre><code class="prism language-python"><span class="token keyword">from</span> transformers <span class="token keyword">import</span> pipeline

<span class="token decorator annotation punctuation">@st<span class="token punctuation">.</span>cache_resource</span>  <span class="token comment"># 👈 Add the caching decorator</span>
<span class="token keyword">def</span> <span class="token function">load_model</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">return</span> pipeline<span class="token punctuation">(</span><span class="token string">"sentiment-analysis"</span><span class="token punctuation">)</span>

model <span class="token operator">=</span> load_model<span class="token punctuation">(</span><span class="token punctuation">)</span>

query <span class="token operator">=</span> st<span class="token punctuation">.</span>text_input<span class="token punctuation">(</span><span class="token string">"Your query"</span><span class="token punctuation">,</span> value<span class="token operator">=</span><span class="token string">"I love Streamlit! 🎈"</span><span class="token punctuation">)</span>
<span class="token keyword">if</span> query<span class="token punctuation">:</span>
    result <span class="token operator">=</span> model<span class="token punctuation">(</span>query<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>  <span class="token comment"># 👈 Classify the query text</span>
    st<span class="token punctuation">.</span>write<span class="token punctuation">(</span>result<span class="token punctuation">)</span>
</code></pre> 
<p>如果运行此应用，你将看到该应用仅调用一次 load_model - 就在应用启动时。后续运行将重用缓存中存储的相同模型，从而节省时间和内存！</p> 
<h3><a id="31_Behavior_134"></a>3.1 Behavior行为</h3> 
<p>使用 <code>st.cache_resource</code> 与使用 <code>st.cache_data</code> 非常相似。但是在行为上有一些重要的区别：</p> 
<ul><li>st.cache_resource 不会创建缓存返回值的副本，而是将对象本身存储在缓存中。函数返回值上的所有突变都会直接影响缓存中的对象，因此必须确保来自多个会话的突变不会导致问题。简而言之，返回值必须是线程安全的。(对非线程安全的对象使用 st.cache_resource 可能会导致崩溃或数据损坏。在下面的 <a href="https://docs.streamlit.io/library/advanced-features/caching#mutation-and-concurrency-issues" rel="nofollow">Mutation 和并发问题中了解更多信息</a>。)</li><li>不创建副本意味着缓存的返回对象只有一个全局实例，这可以节省内存，例如使用大型 ML 模型时。用计算机科学术语来说，我们创建一个单例。</li><li>函数的返回值不需要可序列化。此行为对于本质上不可序列化的类型非常有用，例如数据库连接、文件句柄或线程。无法使用 <code>st.cache_data</code> 缓存这些对象。</li></ul> 
<h3><a id="32_Database_connections_141"></a>3.2 Database connections数据库连接</h3> 
<p><code>st.cache_resource</code> 对于连接数据库很有用。通常，您要创建一个连接对象，并希望在每个查询中全局重用该对象。每次运行时创建新的连接对象效率很低，并且可能会导致连接错误。这正是 st.cache_resource 可以做的事情，例如，对于 Postgres 数据库：</p> 
<pre><code class="prism language-python"><span class="token decorator annotation punctuation">@st<span class="token punctuation">.</span>cache_resource</span>
<span class="token keyword">def</span> <span class="token function">init_connection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    host <span class="token operator">=</span> <span class="token string">"hh-pgsql-public.ebi.ac.uk"</span>
    database <span class="token operator">=</span> <span class="token string">"pfmegrnargs"</span>
    user <span class="token operator">=</span> <span class="token string">"reader"</span>
    password <span class="token operator">=</span> <span class="token string">"NWDMCE5xdipIjRrp"</span>
    <span class="token keyword">return</span> psycopg2<span class="token punctuation">.</span>connect<span class="token punctuation">(</span>host<span class="token operator">=</span>host<span class="token punctuation">,</span> database<span class="token operator">=</span>database<span class="token punctuation">,</span> user<span class="token operator">=</span>user<span class="token punctuation">,</span> password<span class="token operator">=</span>password<span class="token punctuation">)</span>

conn <span class="token operator">=</span> init_connection<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> 
<p>当然，您可以对任何其他数据库执行相同的操作。请参阅我们有关如何将 Streamlit 连接到数据库的指南以获取深入的示例。</p> 
<h3><a id="33__158"></a>3.3 决定使用哪个缓存装饰器</h3> 
<p>上面的部分展示了每个缓存装饰器的许多常见示例。但在某些边缘情况下，决定使用哪个缓存装饰器并不那么简单。最终，这一切都归结为“数据”和“资源”之间的区别：</p> 
<ul><li>数据是可序列化的对象（可以通过 pickle 转换为字节的对象），您可以轻松地将其保存到磁盘。想象一下您通常存储在数据库或文件系统中的所有类型 - 基本类型，如 str、int 和 float，还有数组、DataFrame、图像或这些类型的组合（列表、元组、字典等） ）。</li><li>资源是不可序列化的对象，您通常不会将其保存到磁盘或数据库中。它们通常是更复杂的非永久性对象，例如数据库连接、ML 模型、文件句柄、线程等。</li></ul> 
<p>从上面列出的类型中，很明显，Python 中的大多数对象都是“数据”。这也是为什么 <code>st.cache_data</code> 是几乎所有用例的正确命令。<code>st.cache_resource</code>是一个更奇特的命令，您应该只在特定情况下使用。</p> 
<h2><a id="_165"></a>代码</h2> 
<p>https://github.com/zgpeace/pets-name-langchain/tree/develop</p> 
<h2><a id="_167"></a>参考</h2> 
<p>https://docs.streamlit.io/library/advanced-features/caching#basic-usage</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a880cbf035514fc6735bb46b8dac6e9c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">K8s调试积累</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5571e6c06bda0adc2d5116b60c27253f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">如何使用Docker Compose搭建StackEdit编辑器并实现远程办公</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>