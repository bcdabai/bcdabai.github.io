<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Constructor：构造器，this 关键字,static:静态的,block 块,debug 调试工具 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Constructor：构造器，this 关键字,static:静态的,block 块,debug 调试工具" />
<meta property="og:description" content="构造器：Constructor
Constructor : 构造器| 构造方法 | 构造函数 特殊的方法 作用: 为对象初始化信息 (初始化: 第一次赋值) --&gt; 为对象的成员变量在创建对象的同时赋值 使用: 跟随new一起使用(new第二步所调用的) 定义: 修饰符 类名(参数列表){ 方法体; } 不需要返回值类型,也没有void 可以根据需要定义return关键字,作用提前结束方法 构造器的名字与类名保持一致 特点: 构造器也是特殊的方法,定义多个重载构造器,构造器的名字都与类名保持一致,参数列表不同就能构成重载构造器 如果没有显示的定义构造器,编译器会自动为类提供一个空构造 如果存在显示定义的构造器,编译器不会提供任意构造器 先创建对象后赋值 创建对象的同时赋值,为创建赋值更早,在创建对象的时候就能确定成员的值,跟简单 为了所定义的所有的javabean,必须 至少一共一个空构造 注意:
1.构造器可以实现重载,因为是特殊的方法
2.没有显示定义构造器,编译器会默认提供空构造
3.如果存在显示 定义构造器,不会提供任何构造器,包括空构造
4.至少提供一个空构造...按需提供带参,不绝对,根据需求决定
this 关键字： 指代对象--指代当前对象(new的对象)--当前调用成员方法的对象|存储所有指向的对象的地址 构造器的首行调用本类中的其他构造器 this(参数列表) 区分同名的成员与局部的问题 默认就近原则 this.调用成员 如果出现同名问题,想要指代调用成员,通过this.成员--&gt;因为this指代对象,通过对象调用成员 如果没有同名问题,可以省略this.调用成员 在构造器中使用this,默认指代当前new的对象,存储的是this的对象的地址 在的成员方法中使用this,this在成员方法中默认指代当前调用成员方法的对象 注意: 1.多个构造器之间不能相互调用,否则无法停止调用 2.在static修饰的内容中不能使用this static 静态的 成员修饰符 : 只能修饰成员位置的内容,不能修饰局部 修饰变量 : 静态变量|类变量 修饰方法 : 静态方法|类方法 修饰块 : 静态块 修饰类 : 静态内部类 静态内容的使用: 1." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/6c227327fdb6f1ea650bc01f0de132fc/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-07-08T20:02:09+08:00" />
<meta property="article:modified_time" content="2021-07-08T20:02:09+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Constructor：构造器，this 关键字,static:静态的,block 块,debug 调试工具</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><strong><span style="color:#0d0016;">构造器：Constructor</span></strong></p> 
<pre><code class="language-html hljs">Constructor : 构造器| 构造方法 | 构造函数
    特殊的方法

作用: 为对象初始化信息 (初始化: 第一次赋值) --&gt; 为对象的成员变量在创建对象的同时赋值
使用: 跟随new一起使用(new第二步所调用的)
定义:
    修饰符 类名(参数列表){
        方法体;
    }
    不需要返回值类型,也没有void
    可以根据需要定义return关键字,作用提前结束方法
    构造器的名字与类名保持一致
特点:
    构造器也是特殊的方法,定义多个重载构造器,构造器的名字都与类名保持一致,参数列表不同就能构成重载构造器
    如果没有显示的定义构造器,编译器会自动为类提供一个空构造
    如果存在显示定义的构造器,编译器不会提供任意构造器
 先创建对象后赋值
 创建对象的同时赋值,为创建赋值更早,在创建对象的时候就能确定成员的值,跟简单
 为了所定义的所有的javabean,必须 至少一共一个空构造</code></pre> 
<p><span style="color:#fe2c24;">注意:<br>         1.构造器可以实现重载,因为是特殊的方法<br>         2.没有显示定义构造器,编译器会默认提供空构造<br>         3.如果存在显示 定义构造器,不会提供任何构造器,包括空构造<br>         4.至少提供一个空构造...按需提供带参,不绝对,根据需求决定</span></p> 
<p><img alt="" height="780" src="https://images2.imgbox.com/cc/69/12HWyO8M_o.png" width="926"><img alt="" height="265" src="https://images2.imgbox.com/c8/88/VZzSYwWp_o.png" width="315"><img alt="" height="197" src="https://images2.imgbox.com/0b/59/ArvJQ4HT_o.png" width="368"></p> 
<pre><code class="language-html hljs">this 关键字：
    指代对象--指代当前对象(new的对象)--当前调用成员方法的对象|存储所有指向的对象的地址

    构造器的首行调用本类中的其他构造器    this(参数列表)

    区分同名的成员与局部的问题
    默认就近原则
     this.调用成员
        如果出现同名问题,想要指代调用成员,通过this.成员--&gt;因为this指代对象,通过对象调用成员
        如果没有同名问题,可以省略this.调用成员
        在构造器中使用this,默认指代当前new的对象,存储的是this的对象的地址
        在的成员方法中使用this,this在成员方法中默认指代当前调用成员方法的对象

    注意:
        1.多个构造器之间不能相互调用,否则无法停止调用
        2.在static修饰的内容中不能使用this</code></pre> 
<p><img alt="" height="257" src="https://images2.imgbox.com/df/67/xIQP85yy_o.png" width="319"><img alt="" height="253" src="https://images2.imgbox.com/00/f8/rfYLyVjC_o.png" width="324"></p> 
<p></p> 
<pre><code class="language-html hljs">static 静态的
    成员修饰符 : 只能修饰成员位置的内容,不能修饰局部
    修饰变量 : 静态变量|类变量
    修饰方法 : 静态方法|类方法
    修饰块 : 静态块
    修饰类 : 静态内部类

    静态内容的使用:
                1.跟随类名使用
                    类名.静态变量名
                    类名.静态方法名(参数列表);
                2.跟随对象使用
                    引用.静态变量名
                    引用.静态方法名(参数列表);

    成员是是属于对象的
    静态的是属于类的

    成员变量 :
        被static修饰的变量 --&gt; 静态变量|类变量
        不被static修饰的变量 --&gt; 实例变量
    成员方法:
        被static修饰的方法 --&gt; 静态方法|类方法
        不被static修饰的方法 --&gt; 实例方法

    注意:
        this只能使用在非静态环境中
        在非静态方法中使用this,默认指代当前调用实例方法的对象
        静态内容是独一份的,静态变量存在与静态区中,多个对象共享的资源
        成员内容跟随对象存在与对象的堆内存中,多个对象,就有多份成员
        初始加载顺序: 先静态后成员
        静态内容在类第一次加载完成之后就会进行初始化
        成员变量必须在执行到new对象的时候,才会存在对象的堆内存,在对象的堆内存中才会有成员变量</code></pre> 
<p style="text-align:center;"><img alt="" height="89" src="https://images2.imgbox.com/5a/ed/tA0fDtkn_o.png" width="316"></p> 
<p style="text-align:center;"><img alt="" height="378" src="https://images2.imgbox.com/6b/ac/mD9k39Fx_o.png" width="400"></p> 
<pre><code class="language-html hljs">1.在静态内容中,可以直接使用静态的内容,需要跟随对象使用成员
2.在成员内容中,可以直接 使用静态内容,可以直接 使用成员内容
this不能使用在静态环境中,静态的方法可以直接跟随类调用,可以能根本不存在对象,静态方法的this,无法指代某个对象</code></pre> 
<p style="text-align:center;"><img alt="" height="317" src="https://images2.imgbox.com/ff/1a/Q8idXZ4X_o.png" width="416"></p> 
<pre><code class="language-html hljs">静态变量|方法的应用场景:
 1.工具类 : Math,Arrays... 静态工厂
     可以跟随类名直接使用静态方法,使用简单
 2.定义一个类,类中的内容,所有当前类型对象共享的,唯一的可以定义为静态的 | 没有对象就可以使用的成员可以定义为静态的
     具体的需要根据业务进行分析,不绝对
</code></pre> 
<p><img alt="" height="834" src="https://images2.imgbox.com/dc/08/ylTpFjqU_o.png" width="1200"></p> 
<pre><code class="language-html hljs">block 块:
{} 块 自成作用域
             分类                                                    执行时机
局部代码块|普通语句块 : {}定义在方法中                             跟随方法的调用而执行
    1) 作用域看待
    2) 语义化
构造块 : {}定义在类中方法外                                       跟随new一起使用
    1) 成员内容的初始信息,比构造器中的代码跟早执行
    2) 对对象的某些内容进行初始
静态块 : static修饰{},定义在类中方法外                            在类第一次加载完成之后执行
    1) 会为静态内容进行初始化
    2) 信息的配置,资源的加载
同步块 : 多线程学习

构造块中的代码会先于构造器中的代码之前执行
如果存在多个构造块,会从上到下一次执行
静态块在类第一次加载完成之后执行,并且仅会执行一次
如果存在多个静态块,会从上到下一次执行

执行顺序：
静态块--&gt;main--&gt;创建对象 --&gt; 构造块 --&gt; 构造器
</code></pre> 
<p></p> 
<p style="text-align:center;"><img alt="" height="500" src="https://images2.imgbox.com/ee/bb/Wkmoo4ca_o.png" width="508"></p> 
<p></p> 
<pre><code class="language-html hljs">Debug 调试工具
   debug的作用:
      1.追踪程序的执行流程
      2.定位异常出现的位置
      3.观察程序运行期间变量变化的情况
      4.根据程序的执行流程学习第三方框架的源码

   步骤:
       1.打断点
          在行号的后面单击设置断点,单击取消断点
    2.debug运行
          step over F8 下一步跳过
          如果遇到方法的调用,不进入,直接跳过进入下一行
          step into F7 步入
          如果下一步遇到自定义方法的调用,进入方法跟随执行,如果是jdk提供的方法,不会进入
          Force step into alt+shift+F7 强制步入
          如果是jdk提供的方法,会强制进入跟随执行
          step out shift+F8 跳出
          如果执行在方法的调用中,下一步直接调出到方法调用的位置
          Run to  Cursor 运行到光标所在位置</code></pre> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3399faeb5d5e94167170063c5fb00775/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Windows下安装flink服务</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a78459abce2b8f89afe7165087fa2db9/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">NVDLA学习笔记（1）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>