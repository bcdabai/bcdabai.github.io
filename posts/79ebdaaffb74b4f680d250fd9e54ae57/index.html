<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>JUC 并发编程学习笔记（总） - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="JUC 并发编程学习笔记（总）" />
<meta property="og:description" content="文章目录 1. 什么是JUC2. 进程和线程2.1 进程2.2 线程2.3 并发2.4 并行2.5 线程的状态2.6 wait 和 sleep 的区别 3. Lock锁（重点）3.1 传统Synchronized3.2 Lock接口3.3 Synchronized 和 Lock的区别 4. 生产者和消费者问题4.1 Synchronized版的生产者和消费者问题Synchronized版4.2 JUC版的生产者和消费者问题4.3 Condition 精确的通知和唤醒线程 5. 八锁现象6. 集合类不安全6.1 List不安全6.2 Set不安全6.3 Map不安全 7. Callable(简单)8. 常用的辅助类（必会）8.1 CountDownLatch8.2 CyclicBarrier8.3 Semaphore 9. 读写锁10. 阻塞队列10.1 阻塞队列BlockingQueue10.2 BlockingQueue四组API10.3 SynchronousQueue同步队列 11. 线程池（重点）12. 四大函数式接口（必须掌握）13. Stream流式计算14. ForkJoin15. 异步回调16. JMM17. Volatile18. 单例模式19. 深入理解CAS20. 原子引用21. 各种锁的理解21.1 公平锁、非公平锁21.1 可重入锁21.3 自旋锁21.4 死锁 1. 什么是JUC JUC 指的就是 java.util.concurrent 工具包的简称，里面的工具类可以很方便的实现多线程的开发。
java.util 工具包、包、分类。
业务：普通的线程代码 Thread。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/79ebdaaffb74b4f680d250fd9e54ae57/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-11-02T08:38:54+08:00" />
<meta property="article:modified_time" content="2022-11-02T08:38:54+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">JUC 并发编程学习笔记（总）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atelier-sulphurpool-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#1_JUC_1" rel="nofollow">1. 什么是JUC</a></li><li><a href="#2__15" rel="nofollow">2. 进程和线程</a></li><li><ul><li><a href="#21__19" rel="nofollow">2.1 进程</a></li><li><a href="#22__22" rel="nofollow">2.2 线程</a></li><li><a href="#23__65" rel="nofollow">2.3 并发</a></li><li><a href="#24__71" rel="nofollow">2.4 并行</a></li><li><a href="#25__85" rel="nofollow">2.5 线程的状态</a></li><li><a href="#26_wait__sleep__110" rel="nofollow">2.6 wait 和 sleep 的区别</a></li></ul> 
  </li><li><a href="#3_Lock_127" rel="nofollow">3. Lock锁（重点）</a></li><li><ul><li><a href="#31_Synchronized_128" rel="nofollow">3.1 传统Synchronized</a></li><li><a href="#32_Lock_223" rel="nofollow">3.2 Lock接口</a></li><li><a href="#33_Synchronized__Lock_337" rel="nofollow">3.3 Synchronized 和 Lock的区别</a></li></ul> 
  </li><li><a href="#4__345" rel="nofollow">4. 生产者和消费者问题</a></li><li><ul><li><a href="#41_SynchronizedSynchronized_346" rel="nofollow">4.1 Synchronized版的生产者和消费者问题Synchronized版</a></li><li><a href="#42_JUC_710" rel="nofollow">4.2 JUC版的生产者和消费者问题</a></li><li><a href="#43_Condition__865" rel="nofollow">4.3 Condition 精确的通知和唤醒线程</a></li></ul> 
  </li><li><a href="#5__999" rel="nofollow">5. 八锁现象</a></li><li><a href="#6__1218" rel="nofollow">6. 集合类不安全</a></li><li><ul><li><a href="#61_List_1219" rel="nofollow">6.1 List不安全</a></li><li><a href="#62_Set_1252" rel="nofollow">6.2 Set不安全</a></li><li><a href="#63_Map_1285" rel="nofollow">6.3 Map不安全</a></li></ul> 
  </li><li><a href="#7_Callable_1309" rel="nofollow">7. Callable(简单)</a></li><li><a href="#8__1354" rel="nofollow">8. 常用的辅助类（必会）</a></li><li><ul><li><a href="#81_CountDownLatch_1355" rel="nofollow">8.1 CountDownLatch</a></li><li><a href="#82_CyclicBarrier_1390" rel="nofollow">8.2 CyclicBarrier</a></li><li><a href="#83_Semaphore_1427" rel="nofollow">8.3 Semaphore</a></li></ul> 
  </li><li><a href="#9__1469" rel="nofollow">9. 读写锁</a></li><li><a href="#10__1622" rel="nofollow">10. 阻塞队列</a></li><li><ul><li><a href="#101_BlockingQueue_1623" rel="nofollow">10.1 阻塞队列BlockingQueue</a></li><li><a href="#102_BlockingQueueAPI_1634" rel="nofollow">10.2 BlockingQueue四组API</a></li><li><a href="#103_SynchronousQueue_1776" rel="nofollow">10.3 SynchronousQueue同步队列</a></li></ul> 
  </li><li><a href="#11__1824" rel="nofollow">11. 线程池（重点）</a></li><li><a href="#12__2085" rel="nofollow">12. 四大函数式接口（必须掌握）</a></li><li><a href="#13_Stream_2221" rel="nofollow">13. Stream流式计算</a></li><li><a href="#14_ForkJoin_2263" rel="nofollow">14. ForkJoin</a></li><li><a href="#15__2369" rel="nofollow">15. 异步回调</a></li><li><a href="#16_JMM_2427" rel="nofollow">16. JMM</a></li><li><a href="#17_Volatile_2497" rel="nofollow">17. Volatile</a></li><li><a href="#18__2642" rel="nofollow">18. 单例模式</a></li><li><a href="#19_CAS_2799" rel="nofollow">19. 深入理解CAS</a></li><li><a href="#20__2848" rel="nofollow">20. 原子引用</a></li><li><a href="#21__2908" rel="nofollow">21. 各种锁的理解</a></li><li><ul><li><a href="#211__2909" rel="nofollow">21.1 公平锁、非公平锁</a></li><li><a href="#211__2923" rel="nofollow">21.1 可重入锁</a></li><li><a href="#213__3015" rel="nofollow">21.3 自旋锁</a></li><li><a href="#214__3092" rel="nofollow">21.4 死锁</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="1_JUC_1"></a>1. 什么是JUC</h2> 
<p><code>JUC</code> 指的就是 <code>java.util.concurrent</code> 工具包的简称，里面的工具类可以很方便的<strong>实现多线程</strong>的开发。</p> 
<p><img src="https://images2.imgbox.com/bc/00/DHNTVTNo_o.png" alt="在这里插入图片描述"><br>  <br> <code>java.util</code> 工具包、包、分类。<br> 业务：普通的线程代码 Thread。<br> <code>Runnable</code> 没有返回值、效率相比 <code>Callable</code> 相对较低！</p> 
<p><img src="https://images2.imgbox.com/08/03/3rqAcAET_o.png" alt="在这里插入图片描述"><br>  </p> 
<p><img src="https://images2.imgbox.com/ed/ba/BpVIvi3U_o.png" alt="在这里插入图片描述"><br>  </p> 
<h2><a id="2__15"></a>2. 进程和线程</h2> 
<blockquote> 
 <p>进程是操作系统中的应用程序、是资源分配的基本单位。<br> 线程是用来执行具体的任务和功能，是CPU调度和分派的最小单位。<br> 一个进程往往可以包含多个线程，至少包含一个。</p> 
</blockquote> 
<h3><a id="21__19"></a>2.1 进程</h3> 
<p>一个进程往往可以包含多个线程，至少包含一个。<br> Java默认有两个线程：一个 <code>main</code>， 一个<code>GC</code>。</p> 
<h3><a id="22__22"></a>2.2 线程</h3> 
<p>对于Java而言：<code>Thread</code>、<code>Runable</code>、<code>Callable</code> 是进行开启线程的。</p> 
<blockquote> 
 <p>Java 真的可以开启线程吗？<br> 答案：开不了。</p> 
</blockquote> 
<p>Java是没有权限去开启线程的、操作硬件的，这是一个 <code>native</code> 的一个本地方法，它调用的底层是c++代码。</p> 
<pre><code>  public synchronized void start() {
        /**
         * This method is not invoked for the main method thread or "system"
         * group threads created/set up by the VM. Any new functionality added
         * to this method in the future may have to also be added to the VM.
         *
         * A zero status value corresponds to state "NEW".
         */
        if (threadStatus != 0)
            throw new IllegalThreadStateException();
 
        /* Notify the group that this thread is about to be started
         * so that it can be added to the group's list of threads
         * and the group's unstarted count can be decremented. */
        group.add(this);
 
        boolean started = false;
        try {
            start0();
            started = true;
        } finally {
            try {
                if (!started) {
                    group.threadStartFailed(this);
                }
            } catch (Throwable ignore) {
                /* do nothing. If start0 threw a Throwable then
                  it will be passed up the call stack */
            }
        }
    }
	//这是一个C++底层，Java是没有权限操作底层硬件的
    private native void start0();
</code></pre> 
<p> </p> 
<h3><a id="23__65"></a>2.3 并发</h3> 
<p>多线程操作同一个资源。</p> 
<ul><li>CPU只有一核，模拟出来多条线程。可以使用CPU快速交替，来模拟多线程。</li><li>并发编程的本质：<strong>充分利用CPU的资源</strong>。</li></ul> 
<h3><a id="24__71"></a>2.4 并行</h3> 
<ul><li>CPU多核，多个线程可以同时执行。 我们可以使用<strong>线程池</strong>！</li></ul> 
<p>获取 CPU 的核数：</p> 
<pre><code>public class Test1 {
    public static void main(String[] args) {
        //获取cpu的核数
        System.out.println(Runtime.getRuntime().availableProcessors());
    }
}
</code></pre> 
<p><img src="https://images2.imgbox.com/43/de/2fKFo9Am_o.png" alt="在这里插入图片描述"><br>  </p> 
<h3><a id="25__85"></a>2.5 线程的状态</h3> 
<p><strong>线程的状态：</strong></p> 
<pre><code>public enum State {
        // 线程新生
        NEW,

      	//运行状态
        RUNNABLE,

        //阻塞
        BLOCKED,

        //等待，死死地等
        WAITING,

        //超时等待
        TIMED_WAITING,

        //终止
        TERMINATED;
    }
</code></pre> 
<p> </p> 
<h3><a id="26_wait__sleep__110"></a>2.6 wait 和 sleep 的区别</h3> 
<ol><li> <p>来自不同的类<br> <code>wait -&gt; Object</code><br> <code>sleep -&gt; Thread</code></p> </li><li> <p>锁的释放<br> <code>wait</code> 会释放锁。<br> <code>sleep</code> 处于睡眠状态，不会释放锁。</p> </li><li> <p>使用的范围不同<br> <code>wait</code> 必须在同步代码块中。<br> <code>sleep</code> 可以在任何地方处于睡眠。</p> </li><li> <p>是否需要捕获异常<br> <code>wait</code> 不需要捕获异常。<br> <code>sleep</code> 必须要捕获异常。<br>  </p> </li></ol> 
<h2><a id="3_Lock_127"></a>3. Lock锁（重点）</h2> 
<h3><a id="31_Synchronized_128"></a>3.1 传统Synchronized</h3> 
<pre><code>public class SaleTicketDemo1 {

    public static void main(String[] args) {
        // 并发：多线程操作同一个类，把资源丢进线程
        Ticket ticket = new Ticket();

        //@FunctionalInterface 函数式接口,jdk1.8 lambda表达式 (参数)-&gt; {代码}
        new Thread( ()-&gt; {
            for (int i = 0; i &lt; 40; i++) {
                ticket.sale();
            }
        }, "A").start();

        new Thread( ()-&gt;{
            for (int i = 0; i &lt; 40; i++) {
                ticket.sale();
            }
        }, "B").start();

        new Thread( ()-&gt; {
            ticket.sale();
        }, "C").start();
    }
}

class Ticket {
    private int number = 50;

    // synchronized: 本质就是队列、锁
    public synchronized void sale() {
        if (number  &gt; 0) {
            System.out.println(Thread.currentThread().getName() + "卖出了第" + (number --) + "票，剩余" + number);
        }
    }
}
</code></pre> 
<p> <br> 运行结果如下：</p> 
<pre><code>A窗口卖出了第50票，剩余49
A窗口卖出了第49票，剩余48
A窗口卖出了第48票，剩余47
A窗口卖出了第47票，剩余46
A窗口卖出了第46票，剩余45
B窗口卖出了第45票，剩余44
B窗口卖出了第44票，剩余43
B窗口卖出了第43票，剩余42
B窗口卖出了第42票，剩余41
B窗口卖出了第41票，剩余40
B窗口卖出了第40票，剩余39
B窗口卖出了第39票，剩余38
B窗口卖出了第38票，剩余37
B窗口卖出了第37票，剩余36
B窗口卖出了第36票，剩余35
B窗口卖出了第35票，剩余34
B窗口卖出了第34票，剩余33
B窗口卖出了第33票，剩余32
B窗口卖出了第32票，剩余31
B窗口卖出了第31票，剩余30
B窗口卖出了第30票，剩余29
B窗口卖出了第29票，剩余28
B窗口卖出了第28票，剩余27
B窗口卖出了第27票，剩余26
B窗口卖出了第26票，剩余25
B窗口卖出了第25票，剩余24
B窗口卖出了第24票，剩余23
B窗口卖出了第23票，剩余22
B窗口卖出了第22票，剩余21
B窗口卖出了第21票，剩余20
B窗口卖出了第20票，剩余19
B窗口卖出了第19票，剩余18
B窗口卖出了第18票，剩余17
B窗口卖出了第17票，剩余16
B窗口卖出了第16票，剩余15
B窗口卖出了第15票，剩余14
B窗口卖出了第14票，剩余13
B窗口卖出了第13票，剩余12
B窗口卖出了第12票，剩余11
B窗口卖出了第11票，剩余10
B窗口卖出了第10票，剩余9
B窗口卖出了第9票，剩余8
B窗口卖出了第8票，剩余7
B窗口卖出了第7票，剩余6
B窗口卖出了第6票，剩余5
A窗口卖出了第5票，剩余4
A窗口卖出了第4票，剩余3
A窗口卖出了第3票，剩余2
A窗口卖出了第2票，剩余1
A窗口卖出了第1票，剩余0

</code></pre> 
<p> </p> 
<h3><a id="32_Lock_223"></a>3.2 Lock接口</h3> 
<p><img src="https://images2.imgbox.com/ec/3e/k3rjZHtI_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/0b/d0/kj0IugYj_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/0f/33/aN4gTOyv_o.png" alt="在这里插入图片描述"><br>  <br> 代码如下：</p> 
<pre><code>public class SaleTicketDemo2 {
    public static void main(String[] args) {
        // 并发：多线程操作同一个类，把资源丢进线程
        Ticket2 ticket = new Ticket2();

        //@FunctionalInterface 函数式接口,jdk1.8 lambda表达式 (参数)-&gt; {代码}
        new Thread( ()-&gt; {
            for (int i = 0; i &lt; 40; i++) {
                ticket.sale();
            }
        }, "A").start();

        new Thread( ()-&gt;{
            for (int i = 0; i &lt; 40; i++) {
                ticket.sale();
            }
        }, "B").start();

        new Thread( ()-&gt; {
            ticket.sale();
        }, "C").start();
    }
}

/**
 * lock三部曲
 * 1. new ReentrantLock()
 * 2. lock.lock()  加锁
 * 3. finally --&gt; lock.unlock()  解锁
 */
class Ticket2 {
    private int number = 50;

    Lock lock = new ReentrantLock();

    public void sale() {
        lock.lock(); // 加锁

        try {
            // 业务代码
            if(number &gt; 0){
                System.out.println(Thread.currentThread().getName() + "卖出了" + (number--) + "票，剩余" + number);
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            lock.unlock();  // 解锁
        }
    }
}
</code></pre> 
<p>运行结果如下：</p> 
<pre><code>A卖出了50票，剩余49
A卖出了49票，剩余48
A卖出了48票，剩余47
C卖出了47票，剩余46
A卖出了46票，剩余45
A卖出了45票，剩余44
A卖出了44票，剩余43
A卖出了43票，剩余42
A卖出了42票，剩余41
A卖出了41票，剩余40
A卖出了40票，剩余39
A卖出了39票，剩余38
A卖出了38票，剩余37
A卖出了37票，剩余36
A卖出了36票，剩余35
A卖出了35票，剩余34
A卖出了34票，剩余33
A卖出了33票，剩余32
A卖出了32票，剩余31
A卖出了31票，剩余30
A卖出了30票，剩余29
A卖出了29票，剩余28
A卖出了28票，剩余27
A卖出了27票，剩余26
A卖出了26票，剩余25
A卖出了25票，剩余24
A卖出了24票，剩余23
A卖出了23票，剩余22
A卖出了22票，剩余21
A卖出了21票，剩余20
A卖出了20票，剩余19
A卖出了19票，剩余18
A卖出了18票，剩余17
A卖出了17票，剩余16
A卖出了16票，剩余15
A卖出了15票，剩余14
A卖出了14票，剩余13
A卖出了13票，剩余12
A卖出了12票，剩余11
A卖出了11票，剩余10
A卖出了10票，剩余9
B卖出了9票，剩余8
B卖出了8票，剩余7
B卖出了7票，剩余6
B卖出了6票，剩余5
B卖出了5票，剩余4
B卖出了4票，剩余3
B卖出了3票，剩余2
B卖出了2票，剩余1
B卖出了1票，剩余0
</code></pre> 
<p> </p> 
<h3><a id="33_Synchronized__Lock_337"></a>3.3 Synchronized 和 Lock的区别</h3> 
<ol><li><code>Synchronized</code> 是内置的Java关键字； <code>Lock</code> 是一个Java类。</li><li><code>Synchronized</code> 无法判断获取锁的状态； <code>Lock</code> 可以判断是否获取了锁。</li><li><code>Synchronized</code> 会自动释放锁； <code>Lock</code> 必须手动释放锁，如果不释放锁，会出现<strong>死锁</strong>。</li><li><code>Synchronized</code> 线程1（获取锁，阻塞）、线程2（一直等待）；<code>Lock</code> 锁不一定会等待下去。</li><li><code>Synchronized</code> 可重入锁，不可以中断的、非公平；<code>Lock</code> 可重入锁，可以判断锁，非公平（可以自己设置）。</li><li><code>Synchronized</code> 适合锁少量的代码同步问题；<code>Lock</code> 适合锁大量的同步代码。<br>  </li></ol> 
<h2><a id="4__345"></a>4. 生产者和消费者问题</h2> 
<h3><a id="41_SynchronizedSynchronized_346"></a>4.1 Synchronized版的生产者和消费者问题Synchronized版</h3> 
<pre><code>/**
 * 线程之间的通信问题：生产者和消费者问题  等待唤醒，通知唤醒
 * 线程交替执行 A B 操作同一个变量 num = 0
 * A num  + 1
 * B num  - 1
 */
public class A {
    public static void main(String[] args) {
        Data data = new Data();

        new Thread(()-&gt;{
            for (int i = 0; i &lt; 10; i++) {
                try {
                    data.increment();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        },"A").start();

        new Thread(()-&gt;{
            for (int i = 0; i &lt; 10; i++) {
                try {
                    data.decrement();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        },"B").start();
    }

}

//判断等待，业务，通知
class Data {

    private int number = 0;

    // + 1
    public synchronized void increment() throws InterruptedException {
        if(number != 0){
            //等待
            this.wait();
        }
        number ++;
        System.out.println(Thread.currentThread().getName() + "--&gt;" + number);
        //通知其他线程，我 +1 完毕了
        this.notifyAll();
    }

    // - 1
    public synchronized void decrement() throws InterruptedException {
        if(number == 0){
            //等待
            this.wait();
        }
        number --;
        System.out.println(Thread.currentThread().getName() + "--&gt;" + number);
        //通知其他线程，我 -1 完毕了
        this.notifyAll();
    }

}
</code></pre> 
<p> <br> 运行结果如下：</p> 
<pre><code>A--&gt;1
B--&gt;0
A--&gt;1
B--&gt;0
A--&gt;1
B--&gt;0
A--&gt;1
B--&gt;0
A--&gt;1
B--&gt;0
A--&gt;1
B--&gt;0
A--&gt;1
B--&gt;0
A--&gt;1
B--&gt;0
A--&gt;1
B--&gt;0
A--&gt;1
B--&gt;0
</code></pre> 
<p> <br> <strong>问题存在：如果是A, B, C, D 四个线程</strong><br> 常规的代码如下：</p> 
<pre><code>/**
 * 线程之间的通信问题：生产者和消费者问题  等待唤醒，通知唤醒
 * 线程交替执行 A B 操作同一个变量 num = 0
 * A num  + 1
 * B num  - 1
 */
public class A {
    public static void main(String[] args) {
        Data data = new Data();

        new Thread(()-&gt;{
            for (int i = 0; i &lt; 10; i++) {
                try {
                    data.increment();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        },"A").start();

        new Thread(()-&gt;{
            for (int i = 0; i &lt; 10; i++) {
                try {
                    data.decrement();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        },"B").start();

        new Thread(()-&gt;{
            for (int i = 0; i &lt; 10; i++) {
                try {
                    data.increment();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        },"C").start();

        new Thread(()-&gt;{
            for (int i = 0; i &lt; 10; i++) {
                try {
                    data.decrement();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        },"D").start();
    }

}

//判断等待，业务，通知
class Data {

    private int number = 0;

    // + 1
    public synchronized void increment() throws InterruptedException {
        if(number != 0){
            //等待
            this.wait();
        }
        number ++;
        System.out.println(Thread.currentThread().getName() + "--&gt;" + number);
        //通知其他线程，我 +1 完毕了
        this.notifyAll();
    }

    // - 1
    public synchronized void decrement() throws InterruptedException {
        if(number == 0){
            //等待
            this.wait();
        }
        number --;
        System.out.println(Thread.currentThread().getName() + "--&gt;" + number);
        //通知其他线程，我 -1 完毕了
        this.notifyAll();
    }

}
</code></pre> 
<p> <br> 运行结果会出现 <code>number</code> 的值为2或3的情况，这样显然是错误的。</p> 
<pre><code>A--&gt;1
B--&gt;0
A--&gt;1
B--&gt;0
A--&gt;1
B--&gt;0
A--&gt;1
B--&gt;0
A--&gt;1
B--&gt;0
A--&gt;1
B--&gt;0
A--&gt;1
B--&gt;0
A--&gt;1
B--&gt;0
A--&gt;1
B--&gt;0
C--&gt;1
A--&gt;2
C--&gt;3
B--&gt;2
C--&gt;3
D--&gt;2
D--&gt;1
D--&gt;0
C--&gt;1
D--&gt;0
C--&gt;1
D--&gt;0
C--&gt;1
D--&gt;0
C--&gt;1
D--&gt;0
C--&gt;1
D--&gt;0
C--&gt;1
D--&gt;0
C--&gt;1
D--&gt;0
</code></pre> 
<p> </p> 
<p><strong>解决方案：</strong><br> <img src="https://images2.imgbox.com/e2/01/IszTWeCP_o.png" alt="在这里插入图片描述"><br>  <br> <strong>将 if 改为 while 进行判断即可：</strong></p> 
<blockquote> 
 <p>以下是解释为什么 if 改为 while 就可以解决问题了：<br> 拿两个加法线程A、B来说，比如A先执行，执行时调用了wait方法，那它会等待，此时会释放锁，那么线程B获得锁并且也会执行wait方法，两个加线程一起等待被唤醒。此时减线程中的某一个线程执行完毕并且唤醒了这俩加线程，那么这俩加线程不会一起执行，其中A获取了锁并且加1，执行完毕之后B再执行。如果是if的话，那么A修改完num后，B不会再去判断num的值，直接会给num+1。如果是while的话，A执行完之后，B还会去判断num的值，因此就不会执行。</p> 
</blockquote> 
<pre><code>/**
 * 线程之间的通信问题：生产者和消费者问题  等待唤醒，通知唤醒
 * 线程交替执行 A B 操作同一个变量 num = 0
 * A num  + 1
 * B num  - 1
 */
public class A {
    public static void main(String[] args) {
        Data data = new Data();

        new Thread(()-&gt;{
            for (int i = 0; i &lt; 10; i++) {
                try {
                    data.increment();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        },"A").start();

        new Thread(()-&gt;{
            for (int i = 0; i &lt; 10; i++) {
                try {
                    data.decrement();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        },"B").start();

        new Thread(()-&gt;{
            for (int i = 0; i &lt; 10; i++) {
                try {
                    data.increment();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        },"C").start();

        new Thread(()-&gt;{
            for (int i = 0; i &lt; 10; i++) {
                try {
                    data.decrement();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        },"D").start();
    }

}

//判断等待，业务，通知
class Data {

    private int number = 0;

    // + 1
    public synchronized void increment() throws InterruptedException {
        while (number != 0){
            //等待
            this.wait();
        }
        number ++;
        System.out.println(Thread.currentThread().getName() + "--&gt;" + number);
        //通知其他线程，我 +1 完毕了
        this.notifyAll();
    }

    // - 1
    public synchronized void decrement() throws InterruptedException {
        while (number == 0){
            //等待
            this.wait();
        }
        number --;
        System.out.println(Thread.currentThread().getName() + "--&gt;" + number);
        //通知其他线程，我 -1 完毕了
        this.notifyAll();
    }

}
</code></pre> 
<p> <br> 运行结果如下：</p> 
<pre><code>A--&gt;1
B--&gt;0
A--&gt;1
B--&gt;0
A--&gt;1
B--&gt;0
A--&gt;1
B--&gt;0
C--&gt;1
B--&gt;0
A--&gt;1
B--&gt;0
C--&gt;1
B--&gt;0
A--&gt;1
D--&gt;0
C--&gt;1
B--&gt;0
A--&gt;1
D--&gt;0
C--&gt;1
B--&gt;0
A--&gt;1
D--&gt;0
C--&gt;1
B--&gt;0
A--&gt;1
D--&gt;0
C--&gt;1
D--&gt;0
A--&gt;1
D--&gt;0
C--&gt;1
D--&gt;0
C--&gt;1
D--&gt;0
C--&gt;1
D--&gt;0
C--&gt;1
D--&gt;0
</code></pre> 
<p> </p> 
<h3><a id="42_JUC_710"></a>4.2 JUC版的生产者和消费者问题</h3> 
<p><img src="https://images2.imgbox.com/22/67/vmFXATMT_o.png" alt="在这里插入图片描述"><br>  <br> <img src="https://images2.imgbox.com/a9/57/wL178vh3_o.png" alt="在这里插入图片描述"><br>  <br> 代码实现：</p> 
<pre><code>/**
 * 线程之间的通信问题：生产者和消费者问题  等待唤醒，通知唤醒
 * 线程交替执行 A B 操作同一个变量 num = 0
 * A num  + 1
 * B num  - 1
 */
public class B {
    public static void main(String[] args) {
        Data2 data = new Data2();

        new Thread(()-&gt;{
            for (int i = 0; i &lt; 10; i++) {
                try {
                    data.increment();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        },"A").start();

        new Thread(()-&gt;{
            for (int i = 0; i &lt; 10; i++) {
                try {
                    data.decrement();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        },"B").start();

        new Thread(()-&gt;{
            for (int i = 0; i &lt; 10; i++) {
                try {
                    data.increment();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        },"C").start();

        new Thread(()-&gt;{
            for (int i = 0; i &lt; 10; i++) {
                try {
                    data.decrement();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        },"D").start();
    }

}

//判断等待，业务，通知
class Data2 { //  数字 资源类
    private int number = 0;

    Lock lock = new ReentrantLock();
    Condition condition = lock.newCondition();

    // + 1
    public void increment() throws InterruptedException {
        lock.lock();
        try {
            //业务代码
            while (number != 0) {
                //等待
                condition.await();
            }
            number ++;
            System.out.println(Thread.currentThread().getName() + "--&gt;" + number);
            //通知其他线程，我+1完毕了
            condition.signalAll();
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }

    // - 1
    public synchronized void decrement() throws InterruptedException {
        lock.lock();
        try {
            //业务代码
            while (number == 0) {
                //等待
                condition.await();
            }
            number --;
            System.out.println(Thread.currentThread().getName() + "--&gt;" + number);
            //通知其他线程，我-1完毕了
            condition.signalAll();
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            lock.unlock(); //解锁
        }

    }
}
</code></pre> 
<p> <br> 运行结果如下：</p> 
<pre><code>A--&gt;1
B--&gt;0
C--&gt;1
B--&gt;0
A--&gt;1
B--&gt;0
A--&gt;1
B--&gt;0
A--&gt;1
B--&gt;0
A--&gt;1
B--&gt;0
A--&gt;1
B--&gt;0
A--&gt;1
B--&gt;0
A--&gt;1
B--&gt;0
A--&gt;1
B--&gt;0
A--&gt;1
D--&gt;0
C--&gt;1
D--&gt;0
C--&gt;1
D--&gt;0
C--&gt;1
D--&gt;0
C--&gt;1
D--&gt;0
C--&gt;1
D--&gt;0
C--&gt;1
D--&gt;0
C--&gt;1
D--&gt;0
C--&gt;1
D--&gt;0
C--&gt;1
D--&gt;0
</code></pre> 
<p>出现的问题：运行结果是随机的状态出现，我们想要的是有序的执行 A-&gt;B-&gt;C-&gt;D。<br>  </p> 
<h3><a id="43_Condition__865"></a>4.3 Condition 精确的通知和唤醒线程</h3> 
<p>代码如下：</p> 
<pre><code>/**
 * A执行完调用B，B执行完调用C，C执行完调用A
 */
public class C {

    public static void main(String[] args) {
        Data3  data = new Data3();

        new Thread(()-&gt; {
            for (int i = 0; i &lt; 10; i++) {
                data.printA();
            }
        }, "A").start();

        new Thread(()-&gt; {
            for (int i = 0; i &lt; 10; i++) {
                data.printB();
            }
        }, "B").start();

        new Thread(()-&gt; {
            for (int i = 0; i &lt; 10; i++) {
                data.printC();
            }
        }, "C").start();
    }
}

class Data3 {
    private Lock lock = new ReentrantLock();

    private Condition condition1 = lock.newCondition();
    private Condition condition2 = lock.newCondition();
    private Condition condition3 = lock.newCondition();

    private int number = 1;

    public void printA() {
        lock.lock();
        try {
            // 业务代码，判断 -&gt; 执行 -&gt; 通知
            while (number != 1) {
                // 等待
                condition1.await();
            }
            System.out.println(Thread.currentThread().getName() + "-&gt;执行了A");
            // 唤醒指定的人，B
            condition2.signal();
            number = 2;
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }

    public void printB() {
        lock.lock();
        try {
            // 业务代码，判断 -&gt; 执行 -&gt; 通知
            while (number != 2) {
                // 等待
                condition2.await();
            }
            System.out.println(Thread.currentThread().getName() + "-&gt;执行了B");
            // 唤醒指定的人，B
            condition3.signal();
            number = 3;
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }

    public void printC() {
        lock.lock();
        try {
            // 业务代码，判断 -&gt; 执行 -&gt; 通知
            while (number != 3) {
                // 等待
                condition3.await();
            }
            System.out.println(Thread.currentThread().getName() + "-&gt;执行了C");
            // 唤醒指定的人，B
            condition1.signal();
            number = 1;
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }

}
</code></pre> 
<p> <br> 运行结果如下：</p> 
<pre><code>A-&gt;执行了A
B-&gt;执行了B
C-&gt;执行了C
A-&gt;执行了A
B-&gt;执行了B
C-&gt;执行了C
A-&gt;执行了A
B-&gt;执行了B
C-&gt;执行了C
A-&gt;执行了A
B-&gt;执行了B
C-&gt;执行了C
A-&gt;执行了A
B-&gt;执行了B
C-&gt;执行了C
A-&gt;执行了A
B-&gt;执行了B
C-&gt;执行了C
A-&gt;执行了A
B-&gt;执行了B
C-&gt;执行了C
A-&gt;执行了A
B-&gt;执行了B
C-&gt;执行了C
A-&gt;执行了A
B-&gt;执行了B
C-&gt;执行了C
A-&gt;执行了A
B-&gt;执行了B
C-&gt;执行了C
</code></pre> 
<p> </p> 
<h2><a id="5__999"></a>5. 八锁现象</h2> 
<p>测试1代码如下：</p> 
<pre><code>/**
 * 八锁，就是关于锁的八个问题
 * 1. 标准情况下，两个线程先打印发短信还是打电话？ 发短信 -&gt; 打电话
 * 2. send 延迟4秒，两个线程先打印发短信还是打电话？ 发短信 -&gt; 打电话
 */
public class Test1 {
    public static void main(String[] args) {
        Phone phone = new Phone();

        // 锁的问题
        new Thread(()-&gt;{
            phone.send();
        }, "A").start();
        try {
            TimeUnit.SECONDS.sleep(4);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        new Thread(()-&gt;{
            phone.call();
        }, "B").start();
    }
}

class Phone {
    // synchronized 锁的对象是方法的调用者
    // 两个方法用的是同一把锁，谁先拿到谁执行！
    public synchronized void send() {
        try {
            TimeUnit.SECONDS.sleep(4);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("发短信");
    }

    public synchronized void call() {
        System.out.println("打电话");
    }
}
</code></pre> 
<p>测试1 运行结果如下：</p> 
<pre><code>发短信
打电话
</code></pre> 
<p> <br> 测试2代码如下：</p> 
<pre><code>/**
 * 3. 增加一个普通方法 先执行发短息还是hello？ 普通方法
 * 4. 两个对象都是同步方法，先发短信还是打电话？ 打电话
 */
public class Test2 {
    public static void main(String[] args) {

        // 两个对象，两个调用者，两把锁
        Phone2 phone1 = new Phone2();
        Phone2 phone2 = new Phone2();

        // 锁的问题
        new Thread(()-&gt;{
            phone1.send();
        }, "A").start();
        try {
            TimeUnit.SECONDS.sleep(4);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        new Thread(()-&gt;{
            phone2.call();
        }, "B").start();
    }
}

class Phone2 {
    // synchronized 锁的对象是方法的调用者
    public synchronized void send() {
        try {
            TimeUnit.SECONDS.sleep(4);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("发短信");
    }

    public synchronized void call() {
        System.out.println("打电话");
    }

    // 这里没有锁！不是同步方法，不受锁的影响
    public void hello() {
        System.out.println("hello");
    }
}
</code></pre> 
<p> <br> 测试2运行结果如下：</p> 
<pre><code>打电话
发短信
</code></pre> 
<p> </p> 
<p>测试3代码如下：</p> 
<pre><code>/**
 * 5.增加两个静态的同步方法,只有一个对象 先打印 发短信 还是 打电话？ 发短信
 * 6.两个对象！ 增加两个静态的同步方法,先打印 发短信 还是 打电话？ 发短信
 * */
public class Test3 {
    public static void main(String[] args) {
        //两个对象的class类模板只有一个 static 锁的是class
        Phone3 phone1 = new Phone3();
        Phone3 phone2 = new Phone3();

        //锁的问题
        new Thread(() -&gt; {
            phone1.send();
        }, "A").start();
        try {
            TimeUnit.SECONDS.sleep(1);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        new Thread(() -&gt; {
            phone2.call();
        }, "A").start();
    }
}

class Phone3 {
    //synchronized 锁的对象是方法的调用者
    //static静态方法
    //类一加载就有了！class模板
    public static synchronized void send() {
        try {
            TimeUnit.SECONDS.sleep(4);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("发短信");
    }

    //这里没有锁！不是同步方法，不受锁的影响
    public void hello() {
        System.out.println("hello");
    }

    public static synchronized void call() {
        System.out.println("打电话");
    }
}
</code></pre> 
<p> <br> 测试3运行结果如下：</p> 
<pre><code>发短信
打电话
</code></pre> 
<p> <br> 测试4代码如下：</p> 
<pre><code>/**
 * 7. 1个静态的同步方法，1个普通的同步方法，一个对象，先打印 发短信 还是 打电话？ 打电话
 * 8. 1个静态的同步方法，1个普通的同步方法，二个对象，先打印 发短信 还是 打电话？ 打电话
 */
public class Test4 {
    public static void main(String[] args) {
        //两个对象的class类模板只有一个 static 锁的是class
        Phone4 phone1 = new Phone4();
        Phone4 phone2 = new Phone4();

        //锁的问题
        new Thread(() -&gt; {
            phone1.send();
        }, "A").start();
        try {
            TimeUnit.SECONDS.sleep(1);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        new Thread(() -&gt; {
            phone2.call();
        }, "A").start();
    }
}

class Phone4 {
    //静态同步方法 锁的是class类模板
    public static synchronized void send() {
        try {
            TimeUnit.SECONDS.sleep(4);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("发短信");
    }

    //普通的同步方法 锁的调用者
    public synchronized void call() {
        System.out.println("打电话");
    }
}
</code></pre> 
<p>测试4运行结果如下：</p> 
<pre><code>打电话
发短信
</code></pre> 
<p> </p> 
<h2><a id="6__1218"></a>6. 集合类不安全</h2> 
<h3><a id="61_List_1219"></a>6.1 List不安全</h3> 
<p>代码如下：</p> 
<pre><code>//java.util.ConcurrentModificationException 并发修改异常
public class ListTest {
    public static void main(String[] args) {
        // 并发下ArrayList不安全
        /**
         * 解决方案：
         * 1. List&lt;String&gt; list = new Vector&lt;&gt;();
         * 2. List&lt;String&gt; list = Collections.synchronizedList(new ArrayList&lt;&gt;());
         * 3. List&lt;System&gt; list = new CopyOnWriteArrayList&lt;&gt;();
         */
        
        //CopyOnWrite写入时复制  COW 计算机程序设计领域的一种优化策略
        //多个线程调用的时候，list读取的时候，固定的，写入（覆盖）
        //在写入的时候避免覆盖造成数据问题
        //读写分离

        List&lt;String&gt; list = new CopyOnWriteArrayList&lt;&gt;();
        for (int i = 1; i &lt;= 10; i ++ ) {
            new Thread(()-&gt; {
                list.add(UUID.randomUUID().toString().substring(0, 5));
                System.out.println(list);
            },String.valueOf(i)).start();
        }
    }
}
</code></pre> 
<p> <br> 运行结果如下：<br> <img src="https://images2.imgbox.com/19/8e/QBKyJZQt_o.png" alt="在这里插入图片描述"><br>  </p> 
<h3><a id="62_Set_1252"></a>6.2 Set不安全</h3> 
<pre><code>public class SetTest {

    public static void main(String[] args) {

        // Set&lt;String&gt; set = new HashSet&lt;&gt;();
        // Set&lt;String&gt; set = Collections.synchronizedSet(new HashSet&lt;&gt;());
        Set&lt;String&gt; set = new CopyOnWriteArraySet&lt;&gt;();
        for (int i = 1; i &lt;= 30; i++) {
            new Thread(() -&gt; {
                set.add(UUID.randomUUID().toString().substring(0, 5));
                System.out.println(set);
            }, String.valueOf(i)).start();
        }
    }
}
</code></pre> 
<p> <br> <strong>HashSet的底层实现:</strong></p> 
<pre><code>public HashSet(){
	map = new HashMap&lt;&gt;();
}

//add Set本质就是 map Key是无法重复的
public boolean add(E e){
	return map.put(e,PRESENT) == null; 
}

private static final Object PRESENT = new Object(); //不变得值！
</code></pre> 
<p> </p> 
<h3><a id="63_Map_1285"></a>6.3 Map不安全</h3> 
<p><img src="https://images2.imgbox.com/23/8c/7lKBZ2Ph_o.png" alt="在这里插入图片描述"><br>  </p> 
<pre><code>public class MapTest {
    public static void main(String[] args) {
        //map是这样用的吗    不是，工作中不用HashMap
        // 默认等价于什么  new HashMap&lt;&gt;(16,0.75);
        //Map&lt;String, String&gt; map = new HashMap&lt;&gt;();

        Map&lt;String, String&gt; map = new ConcurrentHashMap&lt;&gt;();
        //加载因子 、初始化容量

        for (int i = 1; i &lt;= 30; i++) {
            new Thread(() -&gt; {
                map.put(Thread.currentThread().getName(), UUID.randomUUID().toString().substring(0, 5));
                System.out.println(map);
            }, String.valueOf(i)).start();
        }
    }
}
</code></pre> 
<p> </p> 
<h2><a id="7_Callable_1309"></a>7. Callable(简单)</h2> 
<p><img src="https://images2.imgbox.com/d1/d7/6rAWUflt_o.png" alt="在这里插入图片描述"></p> 
<ol><li>可以有返回值</li><li>可以抛出异常</li><li>方法不同，run() / call()<br> <img src="https://images2.imgbox.com/59/1c/5hTeUQgW_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/c8/28/Wjuan3eA_o.png" alt="在这里插入图片描述"><br>  <br> 测试代码如下：</li></ol> 
<pre><code>public class CallableTest {

    public static void main(String[] args) throws ExecutionException, InterruptedException {
        // new Thread(new Thread()).start();
        // new Thread(new FutureTask&lt;V&gt;).start();
        // new Thread().start(); // 怎么启动Callable
        MyThread thread = new MyThread();
        FutureTask futureTask = new FutureTask(thread); // 适配类
        new Thread(futureTask, "A").start();
        String o = (String) futureTask.get(); // 获取Callable 的返回结果。 这个get方法可能会产生阻塞，把它放到最后或者用异步通信来处理
        System.out.println(o);
    }

}

class MyThread implements Callable&lt;String&gt; {
    @Override
    public String call() {
        System.out.println("call()");
        return "123";
    }
}
</code></pre> 
<p> <br> 运行结果如下：</p> 
<pre><code>call()
123
</code></pre> 
<p> <br> <strong>细节：</strong></p> 
<ol><li>有缓存</li><li>结果可能需要等待会阻塞</li></ol> 
<p> </p> 
<h2><a id="8__1354"></a>8. 常用的辅助类（必会）</h2> 
<h3><a id="81_CountDownLatch_1355"></a>8.1 CountDownLatch</h3> 
<p><img src="https://images2.imgbox.com/92/e7/GizKsYmx_o.png" alt="在这里插入图片描述"><br>  <br> 测试代码如下：</p> 
<pre><code>// 计数器
public class CountDownLatchDemo {
    public static void main(String[] args) throws InterruptedException {
        // 总数是6，必须要执行任务的时候，再使用
        CountDownLatch countDownLatch = new CountDownLatch(6);
        for (int i = 1; i &lt;= 6; i ++ ) {
            new Thread(()-&gt;{
                System.out.println(Thread.currentThread().getName() + " Go out");
                countDownLatch.countDown(); // 数量-1
            }, String.valueOf(i)).start();
        }
        countDownLatch.await(); // 等待计数器归0，然后再向下执行
        System.out.println("close door");

    }
}
</code></pre> 
<p> <br> 运行结果如下：<br> <img src="https://images2.imgbox.com/9d/52/AQzP9vGn_o.png" alt="在这里插入图片描述"></p> 
<p> <br> <strong>原理：</strong><br> <code>countDownLatch.countDown();</code> // 数量 -1<br> <code>countDownLatch.await()</code> // 等待计数器归0，然后再向下执行<br> 每次有线程调用 <code>countDown()</code> 数量-1，假设计数器变为0， <code>countDownLatch.await()</code> 就会被唤醒，继续执行。<br>  </p> 
<h3><a id="82_CyclicBarrier_1390"></a>8.2 CyclicBarrier</h3> 
<p><img src="https://images2.imgbox.com/c7/e7/7rfaAXKJ_o.png" alt="在这里插入图片描述"><br>  <br> <code>CyclicBarrier</code> 即 <strong>加法计数器</strong>，测试代码如下：</p> 
<pre><code>public class CyclicBarrierDemo {

    public static void main(String[] args) {
        /**
         * 集齐7颗龙珠召唤神龙
         */
        CyclicBarrier cyclicBarrier = new CyclicBarrier(7, () -&gt; {
            System.out.println("召唤神龙成功！");
        });

        for (int i = 1; i &lt;= 7; i ++ ) {
            final int temp = i;
            // lambda 不能直接取到i，必须借助于temp
            new Thread(()-&gt; {
                System.out.println(Thread.currentThread().getName() + "收集" + temp + "个龙珠");
                try {
                    cyclicBarrier.await(); // 等待计数器变成7
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } catch (BrokenBarrierException e) {
                    e.printStackTrace();
                }
            }).start();
        }
    }
}
</code></pre> 
<p> <br> 运行结果如下：<br> <img src="https://images2.imgbox.com/f4/0f/WNVOHsxP_o.png" alt="在这里插入图片描述"><br>  </p> 
<h3><a id="83_Semaphore_1427"></a>8.3 Semaphore</h3> 
<p><code>Semaphore</code>即信号量。<br> <img src="https://images2.imgbox.com/c1/05/6Xrg2f5L_o.png" alt="在这里插入图片描述"><br>  <br> 测试代码如下：</p> 
<pre><code>public class SemaphoreDemo {

    // 6辆车、3个车位
    public static void main(String[] args) {
        // 线程数量；停车位！限流！
        Semaphore semaphore = new Semaphore(3);

        for (int i = 1; i &lt;= 6; i ++ ) {
            new Thread(()-&gt; {
                // acquire() 得到
                try {
                    semaphore.acquire();
                    System.out.println(Thread.currentThread().getName() + "抢到车位");
                    TimeUnit.SECONDS.sleep(2);
                    System.out.println(Thread.currentThread().getName() + "离开车位");
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } finally {
                    semaphore.release();
                }
                // release() 释放
            }, String.valueOf(i)).start();
        }
    }
}
</code></pre> 
<p> <br> 运行结果如下：<br> <img src="https://images2.imgbox.com/c1/5c/4Tn0m2A1_o.png" alt="在这里插入图片描述"><br>  <br> <strong>原理：</strong><br> <code>semaphore.acquire();</code> 获得，假设如果已经满了，等待被释放为止。<br> <code>semaphore.release();</code> 释放，会将当前的信号量释放+1，然后唤醒等待的线程。<br> 作用：多个共享资源互斥的使用！并发限流，控制最大的线程数。<br>  </p> 
<h2><a id="9__1469"></a>9. 读写锁</h2> 
<p><img src="https://images2.imgbox.com/88/fd/HnA7KcEW_o.png" alt="在这里插入图片描述"><br>  <br> 旧版：即自定义缓存，测试代码如下：</p> 
<pre><code>public class ReadWriteLock {

    public static void main(String[] args) {
        MyCache myCache = new MyCache();

        // 只写入
        for (int i = 1; i &lt;= 5; i ++ ) {
            final int temp = i;
            new Thread(()-&gt; {
                myCache.put(temp + "", temp + "");
            }, String.valueOf(i)).start();
        }

        // 读取
        for (int i = 1; i &lt;= 5; i ++ ) {
            final int temp = i;
            new Thread(()-&gt; {
                myCache.get(temp + "");
            }, String.valueOf(i)).start();
        }
    }
}

/**
 * 自定义缓存
 */
class MyCache {
    private volatile Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();

    // 存，写
    public void put(String key, Object value) {
        System.out.println(Thread.currentThread().getName() + "写入" + key);
        map.put(key, value);
        System.out.println(Thread.currentThread().getName() + "写入完毕");
    }

    // 取，读
    public void get(String key) {
        System.out.println(Thread.currentThread().getName() + "读取" + key);
        Object o = map.get(key);
        System.out.println(Thread.currentThread().getName() + "读取完毕");
    }
}
</code></pre> 
<p> <br> 运行结果如下：<br> <img src="https://images2.imgbox.com/c3/47/d0mSrYBu_o.png" alt="在这里插入图片描述"><br>  <br> 出现的问题：在一个线程写入的过程中会有其他线程的插入，可以用加锁的缓存来解决该问题，相关代码如下：</p> 
<pre><code>/**
 * 独占锁（写锁） 一次只能被一个线程占有
 * 共享锁（读锁） 多个线程可以同时占有
 * 读——读 可以共存
 * 读——写 不能共存
 * 写——写 不能共存
 */
public class ReadWriteLock {

    public static void main(String[] args) {
        //MyCache myCache = new MyCache();
        MyCacheLock myCache = new MyCacheLock();

        // 只写入
        for (int i = 1; i &lt;= 5; i ++ ) {
            final int temp = i;
            new Thread(()-&gt; {
                myCache.put(temp + "", temp + "");
            }, String.valueOf(i)).start();
        }

        // 读取
        for (int i = 1; i &lt;= 5; i ++ ) {
            final int temp = i;
            new Thread(()-&gt; {
                myCache.get(temp + "");
            }, String.valueOf(i)).start();
        }
    }
}

/**
 * 加锁的
 */
class MyCacheLock {
    private volatile Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();

    // 读写锁：更加细粒度的控制
    private ReentrantReadWriteLock readWriteLock = new ReentrantReadWriteLock();

    //存，写的时候，只希望同时只有一个线程写
    public void put(String key, Object value) {
        readWriteLock.writeLock().lock();

        try {
            System.out.println(Thread.currentThread().getName() + "写入" + key);
            map.put(key, value);
            System.out.println(Thread.currentThread().getName() + "写入完毕");
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            readWriteLock.writeLock().unlock();
        }
    }

    // 取，读的时候，所有人都可以读取
    public void get(String key) {
        readWriteLock.readLock().lock();

        try {
            System.out.println(Thread.currentThread().getName() + "读取" + key);
            Object o = map.get(key);
            System.out.println(Thread.currentThread().getName() + "读取完毕");
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            readWriteLock.readLock().unlock();
        }
    }

}


/**
 * 自定义缓存
 */
class MyCache {
    private volatile Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();

    // 存，写
    public void put(String key, Object value) {
        System.out.println(Thread.currentThread().getName() + "写入" + key);
        map.put(key, value);
        System.out.println(Thread.currentThread().getName() + "写入完毕");
    }

    // 取，读
    public void get(String key) {
        System.out.println(Thread.currentThread().getName() + "读取" + key);
        Object o = map.get(key);
        System.out.println(Thread.currentThread().getName() + "读取完毕");
    }
}
</code></pre> 
<p> <br> 运行结果如下：<br> <img src="https://images2.imgbox.com/eb/4c/kIWaOLEF_o.png" alt="在这里插入图片描述"><br>  </p> 
<h2><a id="10__1622"></a>10. 阻塞队列</h2> 
<h3><a id="101_BlockingQueue_1623"></a>10.1 阻塞队列BlockingQueue</h3> 
<p><img src="https://images2.imgbox.com/47/82/5ZQBNTu8_o.png" alt="在这里插入图片描述"><br>  <br> <img src="https://images2.imgbox.com/1e/42/439phEzb_o.png" alt="在这里插入图片描述"><br>  <br> <img src="https://images2.imgbox.com/57/c8/yL0tctrE_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/11/72/sJuc72Qi_o.png" alt="在这里插入图片描述"><br>  <br> 什么情况下会使用阻塞队列：多线程并发处理,线程池！<br> <strong>使用队列：</strong> 添加、移除</p> 
<h3><a id="102_BlockingQueueAPI_1634"></a>10.2 BlockingQueue四组API</h3> 
<table><thead><tr><th>方式</th><th>抛出异常</th><th>有返回值，不抛出异常</th><th>阻塞等待</th><th>超时等待</th></tr></thead><tbody><tr><td>添加</td><td>add</td><td>offer()</td><td>put()</td><td>offer(, ,)</td></tr><tr><td>删除</td><td>remove</td><td>poll()</td><td>take()</td><td>poll(,)</td></tr><tr><td>检测队首元素</td><td>element</td><td>peek()</td><td></td><td></td></tr></tbody></table> 
<p> </p> 
<ol><li><strong>抛出异常</strong>的测试代码如下：</li></ol> 
<pre><code>public class Test {

    public static void main(String[] args) {
        test1();
    }

    /**
     * 抛出异常
     */
    public static void test1() {
        // 队列的大小
        ArrayBlockingQueue blockingQueue = new ArrayBlockingQueue&lt;&gt;(3);

        System.out.println(blockingQueue.add("a"));
        System.out.println(blockingQueue.add("b"));
        System.out.println(blockingQueue.add("c"));
        System.out.println("---------------");
        //IllegalStateException: Queue full 抛出异常！
        //System.out.println(blockingQueue.add("d"));

        System.out.println(blockingQueue.remove());
        System.out.println(blockingQueue.remove());
        System.out.println(blockingQueue.remove());
        //java.util.NoSuchElementException 抛出异常！
        //System.out.println(blockingQueue.remove());
    }
}
</code></pre> 
<p> <br> 运行结果如下：<br> <img src="https://images2.imgbox.com/ce/78/xTzesRMj_o.png" alt="在这里插入图片描述"><br>  <br> 2. <strong>有返回值，没有异常</strong>的测试代码如下：</p> 
<pre><code>public class Test {

    public static void main(String[] args) {
        test2();
    }

    /**
     * 有返回值，没有异常
     */
    public static void test2() {
        // 队列的大小
        ArrayBlockingQueue blockingQueue = new ArrayBlockingQueue&lt;&gt;(3);

        System.out.println(blockingQueue.offer("a"));
        System.out.println(blockingQueue.offer("b"));
        System.out.println(blockingQueue.offer("c"));
        System.out.println(blockingQueue.offer("d")); // 不抛出异常，false
        System.out.println(blockingQueue.peek()); // 弹出队首元素
        System.out.println("--------");

        System.out.println(blockingQueue.poll());
        System.out.println(blockingQueue.poll());
        System.out.println(blockingQueue.poll());
        System.out.println(blockingQueue.poll()); // 不抛出异常，null
    }
}
</code></pre> 
<p> <br> 运行结果如下：<br> <img src="https://images2.imgbox.com/e3/45/5ZDqaXpn_o.png" alt="在这里插入图片描述"><br>  <br> 3. <strong>等待，阻塞（一直阻塞）</strong> 的测试代码如下：</p> 
<pre><code>public class Test {

    public static void main(String[] args) throws InterruptedException {
        test3();
    }

    /**
     * 等待，阻塞（一直阻塞）
     */
    public static void test3() throws InterruptedException {
        // 队列的大小
        ArrayBlockingQueue blockingQueue = new ArrayBlockingQueue&lt;&gt;(3);

        // 一直阻塞
        blockingQueue.put("a");
        blockingQueue.put("b");
        blockingQueue.put("c");
        //blockingQueue.put("d"); // 队列没有位置了，一直阻塞

        System.out.println(blockingQueue.take());
        System.out.println(blockingQueue.take());
        System.out.println(blockingQueue.take());
        //System.out.println(blockingQueue.take()); // 没有这个元素，一直阻塞
    }
}
</code></pre> 
<p> </p> 
<p>运行结果如下：<br> <img src="https://images2.imgbox.com/2b/e1/niKhFWrZ_o.png" alt="在这里插入图片描述"><br>  <br> 4. <strong>等待，阻塞（等待超时）</strong> 测试代码如下：</p> 
<pre><code>public class Test {

    public static void main(String[] args) throws InterruptedException {
        test4();
    }
   

    /**
     * 等待，阻塞（等待超时）
     */
    public static void test4() throws InterruptedException {
        // 队列的大小
        ArrayBlockingQueue blockingQueue = new ArrayBlockingQueue&lt;&gt;(3);

        blockingQueue.offer("a");
        blockingQueue.offer("b");
        blockingQueue.offer("c");
        //blockingQueue.offer("d", 2, TimeUnit.SECONDS); // 等待超过2秒就退出
        System.out.println("-------");

        System.out.println(blockingQueue.poll());
        System.out.println(blockingQueue.poll());
        System.out.println(blockingQueue.poll());
        //System.out.println(blockingQueue.poll(2, TimeUnit.SECONDS)); // 等待超过2秒就退出
    }
}
</code></pre> 
<p> <br> 运行结果如下：<br> <img src="https://images2.imgbox.com/e0/e9/W1uDyoup_o.png" alt="在这里插入图片描述"><br>  </p> 
<h3><a id="103_SynchronousQueue_1776"></a>10.3 SynchronousQueue同步队列</h3> 
<p><code>SynchronousQueue</code> 是没有容量的，进去一个元素，必须等待取出来之后，才能再往里面放入一个元素。<br> 添加操作 <code>put</code>、删除操作<code>take</code>。</p> 
<p>测试代码如下：</p> 
<pre><code>/**
 * 同步队列
 * 和其他的BlockQueue不一样，SynchronousQueue不存储元素
 * put 了一个元素，必须从里面take取出来，否则不能put进去值
 */
public class SynchronousQueueDemo {

    public static void main(String[] args) {
        BlockingQueue&lt;String&gt; blockingQueue = new SynchronousQueue&lt;&gt;(); // 同步队列

        new Thread(()-&gt;{
            try {
                System.out.println(Thread.currentThread().getName() + " put 1");
                blockingQueue.put("1");
                System.out.println(Thread.currentThread().getName() + " put 2");
                blockingQueue.put("2");
                System.out.println(Thread.currentThread().getName() + " put 3");
                blockingQueue.put("3");
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }, "T1").start();

        new Thread(()-&gt;{
            try {
                TimeUnit.SECONDS.sleep(3);
                System.out.println(Thread.currentThread().getName() + " take " + blockingQueue.take());
                TimeUnit.SECONDS.sleep(3);
                System.out.println(Thread.currentThread().getName() + " take " + blockingQueue.take());
                TimeUnit.SECONDS.sleep(3);
                System.out.println(Thread.currentThread().getName() + " take " + blockingQueue.take());
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }, "T2").start();
    }
}
</code></pre> 
<p> <br> 运行结果如下：<br> <img src="https://images2.imgbox.com/a0/24/zXE2OHS8_o.png" alt="在这里插入图片描述"><br>  </p> 
<h2><a id="11__1824"></a>11. 线程池（重点）</h2> 
<p>线程池：<strong>3大方法、7大参数、4种拒绝策略</strong>。</p> 
<p><strong>线程池的好处：</strong></p> 
<ol><li>降低资源的消耗。</li><li>提高响应的速度。</li><li>方便管理。</li></ol> 
<p><mark>线程复用、可以控制最大并发数、管理线程。</mark></p> 
<blockquote> 
 <p>线程池：三大方法</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/22/72/GiLV69PA_o.png" alt="在这里插入图片描述"><br>  </p> 
<p><strong>3大方法的测试如下：</strong></p> 
<ol><li><code>Executors.newSingleThreadExecutor()</code> 方法的测试如下：</li></ol> 
<pre><code>// Executors 工具类、3大方法
public class Demo01 {
    public static void main(String[] args) {
        ExecutorService threadPool = Executors.newSingleThreadExecutor(); // 单个线程
        //ExecutorService threadPool = Executors.newFixedThreadPool(5);   // 创建一个固定的线程池的大小
        //ExecutorService threadPool = Executors.newCachedThreadPool();   // 可伸缩的，遇强则强，遇弱则弱

        try {
            for (int i = 0; i &lt; 10; i++) {
                // 使用线程池之后，使用线程池来创建线程
                threadPool.execute(()-&gt;{
                    System.out.println(Thread.currentThread().getName() + " 创建成功");
                });
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            // 线程池用完，程序结束，关闭线程池
            threadPool.shutdown();
        }
    }
}
</code></pre> 
<p> <br> <img src="https://images2.imgbox.com/f7/bc/qSuAdz9T_o.png" alt="在这里插入图片描述"><br>  </p> 
<ol start="2"><li><code>Executors.newFixedThreadPool(5)</code> 方法的测试如下：</li></ol> 
<pre><code>// Executors 工具类、3大方法
public class Demo01 {
    public static void main(String[] args) {
        //ExecutorService threadPool = Executors.newSingleThreadExecutor(); // 单个线程
        ExecutorService threadPool = Executors.newFixedThreadPool(5);   // 创建一个固定的线程池的大小
        //ExecutorService threadPool = Executors.newCachedThreadPool();   // 可伸缩的，遇强则强，遇弱则弱

        try {
            for (int i = 0; i &lt; 10; i++) {
                // 使用线程池之后，使用线程池来创建线程
                threadPool.execute(()-&gt;{
                    System.out.println(Thread.currentThread().getName() + " 创建成功");
                });
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            // 线程池用完，程序结束，关闭线程池
            threadPool.shutdown();
        }
    }
}
</code></pre> 
<p> <br> <img src="https://images2.imgbox.com/fd/cc/WHy4EFll_o.png" alt="在这里插入图片描述"></p> 
<ol start="3"><li><code>Executors.newCachedThreadPool()</code> 方法的测试如下：</li></ol> 
<pre><code>// Executors 工具类、3大方法
public class Demo01 {
    public static void main(String[] args) {
        //ExecutorService threadPool = Executors.newSingleThreadExecutor(); // 单个线程
        //ExecutorService threadPool = Executors.newFixedThreadPool(5);   // 创建一个固定的线程池的大小
        ExecutorService threadPool = Executors.newCachedThreadPool();   // 可伸缩的，遇强则强，遇弱则弱

        try {
            for (int i = 0; i &lt; 10; i++) {
                // 使用线程池之后，使用线程池来创建线程
                threadPool.execute(()-&gt;{
                    System.out.println(Thread.currentThread().getName() + " 创建成功");
                });
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            // 线程池用完，程序结束，关闭线程池
            threadPool.shutdown();
        }
    }
}
</code></pre> 
<p> <br> <img src="https://images2.imgbox.com/96/82/gFAyUkMm_o.png" alt="在这里插入图片描述"><br>  </p> 
<blockquote> 
 <p>线程池：七大参数</p> 
</blockquote> 
<p><strong>源码分析：</strong></p> 
<pre><code>public static ExecutorService newSingleThreadExecutor() {
        return new FinalizableDelegatedExecutorService
            (new ThreadPoolExecutor(1, 1,
                                    0L, TimeUnit.MILLISECONDS,
                                    new LinkedBlockingQueue&lt;Runnable&gt;()));
}


public static ExecutorService newFixedThreadPool(int nThreads) {
        return new ThreadPoolExecutor(nThreads, nThreads,
                                      0L, TimeUnit.MILLISECONDS,
                                      new LinkedBlockingQueue&lt;Runnable&gt;());
}

public static ExecutorService newCachedThreadPool() {
        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,	//21亿 OOM
                                      60L, TimeUnit.SECONDS,
                                      new SynchronousQueue&lt;Runnable&gt;());
}


//本质： ThreadPoolExecutor（）



public ThreadPoolExecutor(int corePoolSize, //核心线程池大小
                              int maximumPoolSize, //最大核心线程池大小
                              long keepAliveTime, //超时了没有人调用就会释放
                              TimeUnit unit, //超时单位
                              BlockingQueue&lt;Runnable&gt; workQueue, //阻塞队列
                              ThreadFactory threadFactory,//线程工厂：创建线程的，一般不用动
                              RejectedExecutionHandler handler//拒绝策略) {
        if (corePoolSize &lt; 0 ||
            maximumPoolSize &lt;= 0 ||
            maximumPoolSize &lt; corePoolSize ||
            keepAliveTime &lt; 0)
            throw new IllegalArgumentException();
        if (workQueue == null || threadFactory == null || handler == null)
            throw new NullPointerException();
        this.corePoolSize = corePoolSize;
        this.maximumPoolSize = maximumPoolSize;
        this.workQueue = workQueue;
        this.keepAliveTime = unit.toNanos(keepAliveTime);
        this.threadFactory = threadFactory;
        this.handler = handler;
}
</code></pre> 
<p> <br> <img src="https://images2.imgbox.com/5c/a3/kN2PoCGG_o.png" alt="在这里插入图片描述"><br>  <br> <img src="https://images2.imgbox.com/a2/3a/Zya6uRBs_o.png" alt="在这里插入图片描述"><br>  <br> <strong>手动创建一个线程池</strong>，相关代码如下：</p> 
<pre><code>//Executors 工具类 3大方法
/**
 * 1. new ThreadPoolExecutor.AbortPolicy()); //银行满了 还有人进来，不处理这个人的，并且抛出异常
 * 2. new ThreadPoolExecutor.CallerRunsPolicy()); //哪来的去哪里！
 * 3. new ThreadPoolExecutor.DiscardPolicy()); //队列满了，丢掉任务，不会抛出异常
 * 4. new ThreadPoolExecutor.DiscardOldestPolicy()); //队列满了，尝试和最早的竞争，也不会抛出异常
 */
public class Demo02 {
    public static void main(String[] args) {
        //自定义线程池！工作ThreadPoolExecutor
        ExecutorService threadPool = new ThreadPoolExecutor(
                2,
                5,
                3,
                TimeUnit.SECONDS,
                new LinkedBlockingQueue&lt;&gt;(3),
                Executors.defaultThreadFactory(),
                new ThreadPoolExecutor.DiscardOldestPolicy()); //队列满了，尝试和最早的竞争，也不会抛出异常
        try {
            //最大承载：Deque + max
            // 超过 RejectedExecutionException
            for (int i = 1; i &lt;= 9; i++) {
                //使用了线程池之后，使用线程池来创建线程
                threadPool.execute(() -&gt; {
                    System.out.println(Thread.currentThread().getName() + " ok");
                });
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            //线程池用完，程序结束，关闭线程池
            threadPool.shutdown();
        }

    }
}
</code></pre> 
<p>运行结果如下：<br> <img src="https://images2.imgbox.com/e4/e1/IKWz2HKl_o.png" alt="在这里插入图片描述"></p> 
<p> </p> 
<blockquote> 
 <p>四种拒绝策略</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/09/8c/gIaBshTP_o.png" alt="在这里插入图片描述"><br>  </p> 
<pre><code>4种拒绝策略：
/**
 * 1. new ThreadPoolExecutor.AbortPolicy()); //银行满了 还有人进来，不处理这个人的，并且抛出异常
 * 2. new ThreadPoolExecutor.CallerRunsPolicy()); //哪来的去哪里！
 * 3. new ThreadPoolExecutor.DiscardPolicy()); //队列满了，丢掉任务，不会抛出异常
 * 4. new ThreadPoolExecutor.DiscardOldestPolicy()); //队列满了，尝试和最早的竞争，也不会抛出异常
 */
</code></pre> 
<p> </p> 
<blockquote> 
 <p>小结和扩展</p> 
</blockquote> 
<p>了解：IO密集型、CPU密集型：（调优）</p> 
<pre><code>public class Demo03 {
    public static void main(String[] args) {
        //自定义线程池！工作ThreadPoolExecutor
        //最大线程池该如何定义
        //1、CPU密集型，几核CPU就定义为几 可以保证cpu的效率最高
        //2、IO密集型 &gt; 判断你程序中十分耗IO线程
        //      程序  15个大型任务 io十分占用资源！
        //获取CPU核数
        System.out.println(Runtime.getRuntime().availableProcessors());

        ExecutorService threadPool = new ThreadPoolExecutor(
                2,
                Runtime.getRuntime().availableProcessors(),
                3,
                TimeUnit.SECONDS,
                new LinkedBlockingQueue&lt;&gt;(3),
                Executors.defaultThreadFactory(),
                new ThreadPoolExecutor.DiscardOldestPolicy()); //队列满了，尝试和最早的竞争，也不会抛出异常
        try {
            //最大承载：Deque + max
            // 超过 RejectedExecutionException
            for (int i = 1; i &lt;= 9; i++) {
                //使用了线程池之后，使用线程池来创建线程
                threadPool.execute(() -&gt; {
                    System.out.println(Thread.currentThread().getName() + " ok");
                });
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            //线程池用完，程序结束，关闭线程池
            threadPool.shutdown();
        }

    }
}
</code></pre> 
<p> </p> 
<h2><a id="12__2085"></a>12. 四大函数式接口（必须掌握）</h2> 
<p><strong>lambda表达式、链式编程、函数式接口、Stream流式计算。</strong></p> 
<blockquote> 
 <p>函数式接口：只有一个方法的接口</p> 
</blockquote> 
<pre><code>@FunctionalInterface
public interface Runnable {
    public abstract void run();
}
//超级多FunctionalInterface
//简化编程模型，在新版本的框架底层大量应用！
//foreach(消费者类型的函数式接口)
</code></pre> 
<p> <br> <img src="https://images2.imgbox.com/56/c2/5Brcr3ZL_o.png" alt="在这里插入图片描述"><br>  <br> 测试代码如下：<br> <img src="https://images2.imgbox.com/81/14/uDUEuemu_o.png" alt="在这里插入图片描述"></p> 
<pre><code>/**
 * Function 函数型接口
 * 有一个输入参数，有一个输出
 * 只要是函数式接口，就可以用lambda表达式简化
 */
public class Demo01 {

    public static void main(String[] args) {
        
        /* Function function = new Function&lt;String, String&gt;() {
            @Override
            public String apply(String str) {
                return str;
            }
        };
        */

        Function&lt;String, String&gt; function = (str) -&gt; {
            return str;
        };
        System.out.println(function.apply("abc"));
    }
}
</code></pre> 
<p> </p> 
<blockquote> 
 <p>断定型接口: 有一个输入参数，返回值只能是 <strong>布尔值</strong>。</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/c5/66/Eu3QbLVU_o.png" alt="在这里插入图片描述"><br>  <br> 测试代码如下：</p> 
<pre><code>/**
 * 断定型接口：有一个输入参数，返回值只能是布尔值！
 */
public class Demo02 {

    public static void main(String[] args) {
        // 判断字符串是否为空
        /* Predicate&lt;String&gt; predicate = new Predicate&lt;String&gt;() {
            @Override
            public boolean test(String str) {
                return str.isEmpty();
            }
        };*/
        Predicate&lt;String&gt; predicate = (str) -&gt; {
            return str.isEmpty();
        };
        
        System.out.println(predicate.test(""));
    }
}
</code></pre> 
<p> </p> 
<blockquote> 
 <p>Consumer 消费型接口: 只有输入，没有返回值</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/8f/de/bTNn49hN_o.png" alt="在这里插入图片描述"><br>  <br> 测试代码如下：</p> 
<pre><code>/**
 * Consumer 消费型接口： 只有输入，没有返回值
 */
public class Demo03 {

    public static void main(String[] args) {
        /*Consumer&lt;String&gt; consumer = new Consumer&lt;String&gt;() {
            @Override
            public void accept(String str) {
                System.out.println(str);
            }
        };*/

        Consumer&lt;String&gt; consumer = (str) -&gt; {
            System.out.println(str);
        };

        consumer.accept("abcd");
    }
}
</code></pre> 
<p> </p> 
<blockquote> 
 <p>Supplier 供给型接口: 没有参数，只有返回值</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/49/80/YjaOld2B_o.png" alt="在这里插入图片描述"><br>  <br> 测试代码如下：</p> 
<pre><code>/**
 * Supplier 供给型接口没有参数，只有返回值
 */
public class Demo04 {

    public static void main(String[] args) {

        /* Supplier supplier = new Supplier&lt;Integer&gt;() {
            @Override
            public Integer get() {
                System.out.println("get()");
                return 1024;
            }
        }; */

        Supplier supplier = () -&gt; {
            System.out.println("get()");
            return 1024;
        };

        System.out.println(supplier.get());
    }
}
</code></pre> 
<p> </p> 
<h2><a id="13_Stream_2221"></a>13. Stream流式计算</h2> 
<p>什么是Stream流式计算<br> 大数据：存储 + 计算<br> 集合、MySQL本质就是存储东西的<br> 计算都应该交给流操作</p> 
<p><img src="https://images2.imgbox.com/08/6a/esgT2Bv5_o.png" alt="在这里插入图片描述"><br>  </p> 
<pre><code>/**
 * 题目要求：一分钟内完成此题，只能用一行代码实现！
 * 现在有5个用户！筛选：
 * 1、ID必须是偶数
 * 2、年龄必须大于23岁
 * 3、用户名转为大写字母
 * 4、用户名字母倒着排序
 * 5、只输出一个用户！
 */
public class Test {
    public static void main(String[] args) {
        User u1 = new User(1, "a", 21);
        User u2 = new User(2, "b", 22);
        User u3 = new User(3, "c", 23);
        User u4 = new User(4, "d", 24);
        User u5 = new User(6, "e", 25);

        //集合就是存储
        List&lt;User&gt; list = Arrays.asList(u1, u2, u3, u4, u5);

        //计算交给stream流
        list.stream()
                .filter(u -&gt; {return u.getId() % 2 == 0;})
                .filter(u -&gt; {return u.getAge() &gt; 23;})
                .map(u -&gt; {return u.getName().toUpperCase();})
                .sorted((o1,o2)-&gt;{return o2.compareTo(o1);})
                .limit(1)
                .forEach(System.out::println);
    }
}
</code></pre> 
<p> </p> 
<h2><a id="14_ForkJoin_2263"></a>14. ForkJoin</h2> 
<blockquote> 
 <p>什么是ForkJoin？<br> 在JDK1.7中引入了一种新的Fork/Join线程池，它可以将一个大的任务拆分成多个小的任务并行执行并汇总执行结果。<br> Fork/Join采用的是分而治之的基本思想，分而治之就是将一个复杂的任务，按照规定的阈值划分成多个简单的小任务，然后将这些小任务的结果再进行汇总返回，得到最终的任务。</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/e2/4b/KqrpCAun_o.png" alt="在这里插入图片描述"><br>  </p> 
<blockquote> 
 <p>ForkJoin特点：工作窃取</p> 
</blockquote> 
<p>这个里面维护都是双端队列。<br> <img src="https://images2.imgbox.com/0b/fd/3D4khdvd_o.png" alt="在这里插入图片描述"><br>  </p> 
<blockquote> 
 <p>ForkJoin</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/6b/d3/Z03VFhpo_o.png" alt="在这里插入图片描述"><br>  <br> <img src="https://images2.imgbox.com/fe/7b/yjhEyeLP_o.png" alt="在这里插入图片描述"><br>  </p> 
<pre><code>/**
 * 求和计算的任务
 * 如何使用forkJoin
 * 1、ForkJoinPool通过它来执行
 * 2、计算任务 ForkJoinPool.execute(ForkJoinTask task)
 * 3、计算类要继承ForkJoinTask
 */
public class ForkJoinDemo extends RecursiveTask&lt;Long&gt; {

    private Long start;
    private Long end;
    //临界值
    private Long temp = 10000L;

    public ForkJoinDemo(Long start, Long end) {
        this.start = start; // 1
        this.end = end;     // 1990900000
    }

    //计算方法
    @Override
    protected Long compute() {
        if ((end - start) &lt; temp) {
            Long sum = 0L;
            for (Long i = start; i &lt; end; i++) {
                //分支合并计算
                sum += i;
            }
            return sum;
        } else {
            //forkJoin 递归
            long mid = (start + end) / 2; //中间值
            ForkJoinDemo task1 = new ForkJoinDemo(start, mid);
            task1.fork(); //拆分任务，把任务压入线程队列
            ForkJoinDemo task2 = new ForkJoinDemo(mid + 1, end);
            task2.fork(); //拆分任务，把任务压入线程队列
            return task1.join() + task2.join();
        }
    }
}
</code></pre> 
<p>测试代码如下：</p> 
<pre><code>// 同一个任务效率高几十倍
public class Test {

    public static void main(String[] args) throws ExecutionException, InterruptedException {
        //test1();
        //test2();
         test3();
    }

    // 普通 12224
    public static void test1() {
        long start = System.currentTimeMillis();
        Long sum = 0L;
        for (Long i = 1L; i &lt;= 10_000_0000; i ++ ) {
            sum += i;
        }
        long end = System.currentTimeMillis();
        System.out.println("sum = " + sum + " 时间：" + (end - start));
    }

    //会使用ForkJoin的  10038
    public static void test2() throws ExecutionException, InterruptedException {
        long start = System.currentTimeMillis();
        ForkJoinPool forkJoinPool = new ForkJoinPool();
        ForkJoinTask&lt;Long&gt; task = new ForkJoinDemo(0L, 10_0000_0000L);
        ForkJoinTask&lt;Long&gt; submit = forkJoinPool.submit(task);//提交任务
        Long sum = submit.get();

        long end = System.currentTimeMillis();
        System.out.println("sum=" + sum + "时间：" + (end - start));
    }

    //Stream并行流()  153
    public static void test3() {
        long start = System.currentTimeMillis();
        LongStream.rangeClosed(0L, 10_0000_0000L).parallel().reduce(0, Long::sum);
        long end = System.currentTimeMillis();
        System.out.println("sum = " + "时间：" + (end - start));
    }

}
</code></pre> 
<p> </p> 
<h2><a id="15__2369"></a>15. 异步回调</h2> 
<blockquote> 
 <p>Future设计的初衷：可以对将来的某个事件的结果进行建模</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/ba/f5/BlTTHenz_o.png" alt="在这里插入图片描述"><br>  </p> 
<ol><li><strong>没有返回值的runAsync异步回调</strong></li></ol> 
<p>代码如下：</p> 
<pre><code>public class Demo01 {

    public static void main(String[] args) throws ExecutionException, InterruptedException {
        //没有返回值的runAsync异步回调
        CompletableFuture&lt;Void&gt; completableFuture = CompletableFuture.runAsync(() -&gt; {
            try {
                TimeUnit.SECONDS.sleep(2);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(Thread.currentThread().getName() + "runAsync -&gt; Void");
        });
        System.out.println("111");
        completableFuture.get();  // 获取执行结果
    }
}
</code></pre> 
<p> </p> 
<ol start="2"><li><strong>有返回值的异步回调supplyAsync</strong></li></ol> 
<pre><code>public class Demo02 {

    public static void main(String[] args) throws ExecutionException, InterruptedException {
        // 有返回值的异步回调supplyAsync
        CompletableFuture&lt;Integer&gt; completableFuture = CompletableFuture.supplyAsync(() -&gt; {
            System.out.println("CompletableFuture");
            // int i = 10 / 0;
            return 1024;
        });

        System.out.println(completableFuture.whenComplete((t, u) -&gt; {
            System.out.println("t==&gt;" + t);     //正常的返回结果
            System.out.println("u==&gt;" + u);     //错误的信息，java.util.concurrent.CompletionException: java.lang.ArithmeticException: / by zero
        }).exceptionally((e) -&gt; {
            System.out.println(e.getMessage());
            return 233; //可以获取到错误的返回结果
        }).get());

    }
}
</code></pre> 
<p><strong>whenComplete:</strong> 有两个参数，一个是 t， 一个是 u。<br> <code>T</code>: 代表的是 <strong>正常返回的结果</strong>；<br> <code>U</code>: 代表的是 <strong>抛出异常的错误信息</strong>；<br> 如果发生了异常， <code>get</code> 可以获取到 <code>exceptionally</code> 返回的值。<br>  </p> 
<h2><a id="16_JMM_2427"></a>16. JMM</h2> 
<blockquote> 
 <p>对Volatile的理解</p> 
</blockquote> 
<p><code>Volatile</code> 是 <code>Java</code> 虚拟机提供 <strong>轻量级的同步机制</strong>。<br> 1、保证可见性<br> 2、不保证原子性<br> 3、禁止指令重排</p> 
<blockquote> 
 <p>什么是JMM</p> 
</blockquote> 
<p>JMM: Java 内存模型，不存在的东西、概念！约定！</p> 
<p><strong>关于 JMM 的一些同步的约定：</strong><br> 1、线程解锁前，必须把共享变量立刻刷回主存。<br> 2、线程加锁前，必须读取主存中的最新值到工作内存中。<br> 3、加锁和解锁是同一把锁。</p> 
<p><strong>8种操作：</strong></p> 
<p><img src="https://images2.imgbox.com/7a/0a/xLrM7sfG_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/28/b5/4hNIaLpa_o.png" alt="在这里插入图片描述"></p> 
<p> <br> <strong>内存交互操作有8种，虚拟机实现必须保证每一个操作都是原子的，不可在分的（对于double和long类型的变量来说，load、store、read和write操作在某些平台上允许例外）</strong></p> 
<ul><li>lock （锁定）：作用于主内存的变量，把一个变量标识为线程独占状态。</li><li>unlock （解锁）：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。</li><li>read （读取）：作用于主内存变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用。</li><li>load （载入）：作用于工作内存的变量，它把read操作从主存中变量放入工作内存中。</li><li>use （使用）：作用于工作内存中的变量，它把工作内存中的变量传输给执行引擎，每当虚拟机遇到一个需要使用到变量的值，就会使用到这个指令。</li><li>assign （赋值）：作用于工作内存中的变量，它把一个从执行引擎中接受到的值放入工作内存的变量副本中。</li><li>store （存储）：作用于主内存中的变量，它把一个从工作内存中一个变量的值传送到主内存中，以便后续的write使用。</li><li>write 　（写入）：作用于主内存中的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中。</li></ul> 
<p><strong>JMM对这八种指令的使用，制定了如下规则：</strong></p> 
<ul><li>不允许read和load、store和write操作之一单独出现。即使用了read必须load，使用了store必须write。</li><li>不允许线程丢弃他最近的assign操作，即工作变量的数据改变了之后，必须告知主存</li><li>不允许一个线程将没有assign的数据从工作内存同步回主内存。</li><li>一个新的变量必须在主内存中诞生，不允许工作内存直接使用一个未被初始化的变量。就是怼变量实施use、store操作之前，必须经过assign和load操作。</li><li>一个变量同一时间只有一个线程能对其进行lock。多次lock后，必须执行相同次数的unlock才能解锁。</li><li>如果对一个变量进行lock操作，会清空所有工作内存中此变量的值，在执行引擎使用这个变量前，必须重新load或assign操作初始化变量的值。</li><li>如果一个变量没有被lock，就不能对其进行unlock操作。也不能unlock一个被其他线程锁住的变量。</li><li>对一个变量进行unlock操作之前，必须把此变量同步回主内存。</li></ul> 
<pre><code>public class JMMDemo {

    private static int num = 0;

    public static void main(String[] args) {
        new Thread(() -&gt; {
            while (num == 0) {

            }
        }).start();
        try {
            TimeUnit.SECONDS.sleep(2);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        num = 1;
        System.out.println(num);
    }
}
</code></pre> 
<p> <br> 问题：程序不知道主内存的值已经被修改过了。<br> <img src="https://images2.imgbox.com/70/1b/SY729VBu_o.png" alt="在这里插入图片描述"><br>  </p> 
<h2><a id="17_Volatile_2497"></a>17. Volatile</h2> 
<blockquote> 
 <ol><li>保证可见性</li></ol> 
</blockquote> 
<pre><code>public class JMMDemo {

    // 不加 volatile 程序就会死循环
    // 加了 volatile 可以保证可见性
    private volatile static int num = 0;
    public static void main(String[] args) { // main 线程
        new Thread(() -&gt; { // 线程1 对主内存的变化是不知道的
            while (num == 0) {

            }
        }).start();
        try {
            TimeUnit.SECONDS.sleep(2);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        num = 1;
        System.out.println(num);
    }
}
</code></pre> 
<p> </p> 
<blockquote> 
 <ol start="2"><li>不保证原子性</li></ol> 
</blockquote> 
<p>原子性：不可分割<br> 线程A在执行任务的时候，不能被打扰的，也不能被分割。要么同时成功，要么同时失败。</p> 
<p><strong>代码如下：</strong></p> 
<pre><code>// 不保证原子性
public class VDemo {
    // volatile 不保证原子性
    private volatile static int num = 0;

    public static void add() {
        num ++; // 不是原子性操作
    }

    public static void main(String[] args) {
        // 理论上num结果为20000
        for (int i = 0; i &lt; 20; i ++ ) {
            new Thread(() -&gt; {
                for (int j = 0; j &lt; 1000; j ++ ) {
                    add();
                }
            }).start();
        }
        while (Thread.activeCount() &gt; 2) {
            Thread.yield();
        }

        System.out.println(Thread.currentThread().getName() + " " + num);
    }
}
</code></pre> 
<p> <br> <strong>如果不加lock和synchronized,怎么样保证原子性?</strong><br> <img src="https://images2.imgbox.com/0b/e5/AKoAOV2N_o.png" alt="在这里插入图片描述"><br>  </p> 
<blockquote> 
 <p>原子类为什么这么高级？</p> 
</blockquote> 
<pre><code>public class VDemo02 {
    // volatile 不保证原子性
    // 原子类的
    private volatile static AtomicInteger num = new AtomicInteger();

    public static void add() {
        //num ++; // 不是原子性操作
        num.getAndIncrement(); // Atomicnteger + 1 方法
    }

    public static void main(String[] args) {
        // 理论上num结果为20000
        for (int i = 0; i &lt; 20; i ++ ) {
            new Thread(() -&gt; {
                for (int j = 0; j &lt; 1000; j ++ ) {
                    add();
                }
            }).start();
        }
        while (Thread.activeCount() &gt; 2) {
            Thread.yield();
        }

        System.out.println(Thread.currentThread().getName() + " " + num);
    }
}
</code></pre> 
<p> <br> 这些类的底层都直接和操作系统挂钩！在内存中修改值 ！ <code>Unsafe</code> 类是一个很特殊的存在！</p> 
<blockquote> 
 <ol start="3"><li>指令重排</li></ol> 
</blockquote> 
<p>什么是指令重排： <strong>你写的程序，计算机并不会按照你写的那样去执行的。</strong><br> 源代码 -&gt; 编译器优化的重排 -&gt; 指令并行也可能会重排 -&gt; 内存系统也会重排 -&gt; 执行。<br> <strong>处理器在进行指令重排的时候会考虑一个问题，考虑：数据之间的依赖性！</strong></p> 
<pre><code>int x = 1; //1
int y = 2; //2
x = x + 5; //3
y = x * x; //4

我们所期望的：1234 但是可能执行的时候会变成 2134 1324 
可不可能是  4123！ 
</code></pre> 
<p> <br> 可能造成影响的结果: a b x y 这四个值默认都是0；</p> 
<table><thead><tr><th>线程A</th><th>线程B</th></tr></thead><tbody><tr><td>x = a</td><td>y = b</td></tr><tr><td>b = 1</td><td>a = 2</td></tr></tbody></table> 
<p>正常的结果：x = 0; y = 0.</p> 
<table><thead><tr><th>线程A</th><th>线程B</th></tr></thead><tbody><tr><td>b = 1</td><td>a = 2</td></tr><tr><td>x = a</td><td>y = b</td></tr></tbody></table> 
<p>指令重排导致的结果： x = 2; y = 1.</p> 
<p><strong><code>volatile</code> 可以避免指令重排：</strong><br> 内存屏障，CPU指令，作用：<br> 1、保证特定的操作的执行顺序。<br> 2、可以保证某些变量的内存可见性（利用这些特性volatile实现了可见性）。</p> 
<p><img src="https://images2.imgbox.com/41/8c/nchrzbRY_o.png" alt="在这里插入图片描述"><br>  <br> <strong>Volatile是可以保证可见性。不能保证原子性，由于内存屏障，可以保证避免指令重排的现象产生！</strong><br>  </p> 
<p><strong><code>volatile</code> 与 <code>synchronized</code> 的区别：</strong></p> 
<ol><li><code>volatile</code> 是轻量级的 <code>synchronized</code>，因为它不会引起上下文的切换和调亮，所以 <code>volatile</code> 性能更好。</li><li><code>volatile</code> 只能修饰变量， <code>synchronized</code> 可以修饰方法，静态方法，代码块。</li><li><code>volatile</code> 对任意单个变量的读 / 写具有原子性，但是类似于 <code>i++</code> 这种复合操作不具有原子性。而锁的互斥执行的特性可以确保整个临界区代码执行具有原子性。</li><li>多线程访问 <code>volatile</code> 不会发生阻塞，而 <code>synchronized</code> 会发生阻塞。</li><li><code>volatile</code> 是变量在多线程之间的可见性，<code>synchronized</code> 是多线程之间访问资源的同步性。</li></ol> 
<p> </p> 
<h2><a id="18__2642"></a>18. 单例模式</h2> 
<blockquote> 
 <p>饿汉式</p> 
</blockquote> 
<pre><code>//饿汉式单例
public class Hungry {

    //可能会浪费空间
    private byte[] data1 = new byte[1024 * 1024];
    private byte[] data2 = new byte[1024 * 1024];
    private byte[] data3 = new byte[1024 * 1024];
    private byte[] data4 = new byte[1024 * 1024];

    private Hungry() {

    }

    private final static Hungry HUNGRY = new Hungry();

    public static Hungry getInstance() {
        return HUNGRY;
    }
}
</code></pre> 
<p> </p> 
<blockquote> 
 <p>DCL懒汉式</p> 
</blockquote> 
<pre><code>//懒汉式单例模式
public class LazyMan {

    private static boolean sign = false;

    private LazyMan() {
        synchronized (LazyMan.class) {
            if (sign == false) {
                sign = true;
            } else {
                throw new RuntimeException("不要试图使用反射破坏异常");
            }
        }
        System.out.println(Thread.currentThread().getName() + "OK");
    }

    private static LazyMan lazyMan;

    //双重检测锁模式的懒汉式单例 简称DCL懒汉式
    public static LazyMan getInstance() {
        if (lazyMan == null) {
            synchronized (LazyMan.class) {
                if (lazyMan == null) {
                    lazyMan = new LazyMan();        //不是一个原子性操作
                }
            }
        }

        return lazyMan;
    }
}
    /**
     * 1.分配内存空间
     * 2.执行构造方法，初始化对象
     * 3.把这个对象指向这个空间
     * &lt;p&gt;
     * 期望 123
     * 执行 132 A
     * B   //此时lazyMan还没有完成构造
     */
</code></pre> 
<p> </p> 
<blockquote> 
 <p>静态内部类</p> 
</blockquote> 
<pre><code>//静态内部类
public class Holder {
    private Holder() {

    }

    public static Holder getInstance() {
        return InnerClass.HOLDER;
    }

    public static class InnerClass {
        private static final Holder HOLDER = new Holder();
    }
}
</code></pre> 
<p> </p> 
<blockquote> 
 <p>单例不安全，因为有反射<br> 枚举</p> 
</blockquote> 
<pre><code>//enum 是一个什么？本身也是一个Class类
public enum EnumSingle {
    INSTANCE;

    public EnumSingle getInstance() {
        return INSTANCE;
    }
}

class Test {
    public static void main(String[] args) throws NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException {
        EnumSingle instance1 = EnumSingle.INSTANCE;
        Constructor&lt;EnumSingle&gt; declaredConstructor = EnumSingle.class.getDeclaredConstructor(String.class, int.class);
        declaredConstructor.setAccessible(true);
        EnumSingle instance2 = declaredConstructor.newInstance();
        // NoSuchMethodException: com.kuang.single.EnumSingle.&lt;init&gt;()
        System.out.println(instance1);
        System.out.println(instance2);
    }
}
</code></pre> 
<p> <br> <img src="https://images2.imgbox.com/23/5b/wmGuN2Ny_o.png" alt="在这里插入图片描述"><br>  </p> 
<blockquote> 
 <p>枚举类型的最终反编译源：</p> 
</blockquote> 
<pre><code>public final class EnumSingle extends Enum
{

    public static EnumSingle[] values()
    {
        return (EnumSingle[])$VALUES.clone();
    }

    public static EnumSingle valueOf(String name)
    {
        return (EnumSingle)Enum.valueOf(com/kuang/single/EnumSingle, name);
    }

    private EnumSingle(String s, int i)
    {
        super(s, i);
    }

    public EnumSingle getInstance()
    {
        return INSTANCE;
    }

    public static final EnumSingle INSTANCE;
    private static final EnumSingle $VALUES[];

    static 
    {
        INSTANCE = new EnumSingle("INSTANCE", 0);
        $VALUES = (new EnumSingle[] {
            INSTANCE
        });
    }
}
</code></pre> 
<p> </p> 
<h2><a id="19_CAS_2799"></a>19. 深入理解CAS</h2> 
<blockquote> 
 <p>什么是CAS？<br> CAS的全称为 <code>Compare-And-Swap</code>，直译就是对比交换。是一条CPU的原子指令，其作用是让CPU先进行比较两个值是否相等，然后原子地更新某个位置的值，经过调查发现，其实现方式是基于硬件平台的汇编指令，就是说CAS是靠硬件实现的，JVM只是封装了汇编调用，那些AtomicInteger类便是使用了这些封装后的接口。  <br> 简单解释：CAS操作需要输入两个数值，一个旧值(期望操作前的值)和一个新值，在操作期间先比较下在旧值有没有发生变化，如果没有发生变化，才交换成新值，发生了变化则不交换。</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/f5/7c/2kK56OcV_o.png" alt="在这里插入图片描述"><br>  <br> <img src="https://images2.imgbox.com/2d/3a/cMulSwSv_o.png" alt="在这里插入图片描述"><br>  <br> <img src="https://images2.imgbox.com/a6/67/c5qzK1Nr_o.png" alt="在这里插入图片描述"><br>  <br> CAS: 比较当前工作内存中的值和主内存中的值，如果这个值是期望的，那么则执行操作！如果不是就一直循环！</p> 
<p><strong>缺点：</strong><br> 1、循环会耗时<br> 2、一次性只能保证一个共享变量的原子性<br> 3、ABA问题</p> 
<blockquote> 
 <p>CAS:ABA问题（狸猫换太子）</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/65/97/nxTZfcjN_o.png" alt="在这里插入图片描述"><br>  <br> 测试代码 如下：</p> 
<pre><code>public class CASDemo {

    // CAS  compareAndSet: 比较并交换
    public static void main(String[] args) {
        AtomicInteger atomicInteger = new AtomicInteger(2020);

        // 期望，更新
        //public final boolean compareAndSet(int expectedValue, int newValue)
        // 如果我期望的值达到了，那么就更新，否则不更新

        // ==============捣乱的线程======
        System.out.println(atomicInteger.compareAndSet(2020, 2021));
        System.out.println(atomicInteger.get());

        System.out.println(atomicInteger.compareAndSet(2021, 2020));
        System.out.println(atomicInteger.get());

        // ==============期望的线程======
        System.out.println(atomicInteger.compareAndSet(2020, 6666));
        System.out.println(atomicInteger.get());
    }
}
</code></pre> 
<p> </p> 
<h2><a id="20__2848"></a>20. 原子引用</h2> 
<blockquote> 
 <p>解决ABA问题，引入原子引用！对应的思想是乐观锁。</p> 
</blockquote> 
<p>带版本号的操作！</p> 
<p><strong>注意：</strong><br> <strong>Integer使用了对象缓存机制，默认范围是-128~-127，推荐使用静态工厂方法valueOf获取对象实例，而不是new，因为valueOf使用缓存，而new一定会创建新的对象分配新的内存空间。</strong><br> <img src="https://images2.imgbox.com/7f/dc/YPLxEKbM_o.png" alt="在这里插入图片描述"><br>  </p> 
<p>测试代码如下：</p> 
<pre><code>public class CASDemo {

    //CAS       compareAndSet:比较并交换
    public static void main(String[] args) {
        // AtomicStampedReference   注意：如果泛型是一个包装类，注意对象的引用问题
        // 正常在业务操作，这里比较的都是一个对象
        AtomicStampedReference&lt;Integer&gt; atomicStampedReference = new AtomicStampedReference&lt;&gt;(1, 1);

        new Thread(() -&gt; {
            int stamp = atomicStampedReference.getStamp();       //获得版本号
            System.out.println("a1 =&gt;" + stamp);
            try {
                TimeUnit.SECONDS.sleep(2);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(atomicStampedReference.compareAndSet(1, 2,
                    atomicStampedReference.getStamp(), atomicStampedReference.getStamp() + 1));

            System.out.println("a2 =&gt;" + atomicStampedReference.getStamp());

            System.out.println(atomicStampedReference.compareAndSet(2, 1,
                    atomicStampedReference.getStamp(), atomicStampedReference.getStamp() + 1));
            System.out.println("a3 =&gt;" + atomicStampedReference.getStamp());
        }, "a").start();

        //乐观锁的原理相同
        new Thread(() -&gt; {
            int stamp = atomicStampedReference.getStamp();       //获得版本号
            System.out.println("b1 =&gt;" + stamp);
            try {
                TimeUnit.SECONDS.sleep(2);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(atomicStampedReference.compareAndSet(1, 6, stamp,
                    stamp + 1));
            System.out.println("b2 =&gt;" + atomicStampedReference.getStamp());
        }, "b").start();


    }
}
</code></pre> 
<p>运行结果如下：<br> <img src="https://images2.imgbox.com/84/c3/THwnQYci_o.png" alt="在这里插入图片描述"><br>  </p> 
<h2><a id="21__2908"></a>21. 各种锁的理解</h2> 
<h3><a id="211__2909"></a>21.1 公平锁、非公平锁</h3> 
<p>公平锁：非常公平，不能插队，必须先来后到！<br> 非公平锁：非常不公平，可以插队（<strong>默认都是非公平的</strong>）</p> 
<pre><code>public ReentrantLock() {
        sync = new NonfairSync();
}


public ReentrantLock(boolean fair) {
        sync = fair ? new FairSync() : new NonfairSync();
    }
</code></pre> 
<p> </p> 
<h3><a id="211__2923"></a>21.1 可重入锁</h3> 
<p>可重入锁（递归锁）<br> <img src="https://images2.imgbox.com/f6/c6/5SGqNN0d_o.png" alt="在这里插入图片描述"><br>  </p> 
<blockquote> 
 <p>synchronized 版</p> 
</blockquote> 
<p>代码如下：</p> 
<pre><code>//Synchronized
public class Demo01 {
    public static void main(String[] args) {
        Phone phone = new Phone();

        new Thread(() -&gt; {
            phone.sms();
        }, "A").start();

        new Thread(() -&gt; {
            phone.sms();
        }, "B").start();
    }
}

class Phone {

    public synchronized void sms() {
        System.out.println(Thread.currentThread().getName() + " sms");
        call(); //这里也有锁
    }

    public synchronized void call() {
        System.out.println(Thread.currentThread().getName() + " Call");
    }
}
</code></pre> 
<p> <br> 运行结果如下：<br> <img src="https://images2.imgbox.com/32/3d/Qftki3sO_o.png" alt="在这里插入图片描述"><br>  </p> 
<blockquote> 
 <p>lock版</p> 
</blockquote> 
<p>代码如下：</p> 
<pre><code>// lock
public class Demo02 {
    public static void main(String[] args) {
        Phone2 phone = new Phone2();

        new Thread(() -&gt; {
            phone.sms();
        }, "A").start();

        new Thread(() -&gt; {
            phone.sms();
        }, "B").start();
    }
}

class Phone2 {
    Lock lock = new ReentrantLock();

    public void sms() {
        try {
            lock.lock();        //细节问题：lock.lock();      lock.unlock();
            // lock 锁必须配对 ，否则就会死在里面
            System.out.println(Thread.currentThread().getName() + " sms");
            call(); //这里也有锁
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }

    }
    public  void call() {
        try {
            lock.lock();
            System.out.println(Thread.currentThread().getName() + " Call");
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }
}
</code></pre> 
<p> </p> 
<p>运行结果如下：<br> <img src="https://images2.imgbox.com/8e/81/6DtvdCRo_o.png" alt="在这里插入图片描述"><br>  </p> 
<h3><a id="213__3015"></a>21.3 自旋锁</h3> 
<p><code>spinlock</code>:</p> 
<p><img src="https://images2.imgbox.com/5d/47/7Ql19oPY_o.png" alt="在这里插入图片描述"><br>  <br> 自定义一个锁测试：</p> 
<pre><code>//自旋锁
public class SpinlockDemo {
    //int 0
    //Thread null
    AtomicReference&lt;Thread&gt; atomicReference = new AtomicReference&lt;&gt;();

    //加锁
    public void myLock() {
        Thread thread = Thread.currentThread();
        System.out.println(Thread.currentThread().getName() + "=&gt; mylock");
        //自旋锁
        while (!atomicReference.compareAndSet(null, thread)) {

        }
    }

    //解锁
    public void myUnLock() {
        Thread thread = Thread.currentThread();
        System.out.println(Thread.currentThread().getName() + "=&gt; myUnlock");

        atomicReference.compareAndSet(thread, null);

    }
}
</code></pre> 
<p> <br> 测试代码如下：</p> 
<pre><code>public class TestSpinLock {
    public static void main(String[] args) throws InterruptedException {
/*        ReentrantLock reentrantLock = new ReentrantLock();
        reentrantLock.lock();
        reentrantLock.unlock();*/

        //底层使用的自旋锁CAS
        SpinlockDemo lock = new SpinlockDemo();

        new Thread(() -&gt; {
            lock.myLock();
            try {
                TimeUnit.SECONDS.sleep(5);
            } catch (Exception e) {
                e.printStackTrace();
            } finally {
                lock.myUnLock();
            }

        }, "T1").start();

        TimeUnit.SECONDS.sleep(1);

        new Thread(() -&gt; {
            lock.myLock();
            try {
                TimeUnit.SECONDS.sleep(1);
            } catch (Exception e) {
                e.printStackTrace();
            } finally {
                lock.myUnLock();
            }

        }, "T2").start();

    }
}
</code></pre> 
<p>运行结果如下：<br> <img src="https://images2.imgbox.com/70/2a/Httv4bvH_o.png" alt="在这里插入图片描述"><br>  </p> 
<h3><a id="214__3092"></a>21.4 死锁</h3> 
<blockquote> 
 <p>什么是死锁？</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/04/7f/6kp2g0ar_o.png" alt="在这里插入图片描述"><br>  <br> 死锁测试：</p> 
<pre><code>public class DeadLockDemo {
    public static void main(String[] args) {
        String lockA = "lockA";
        String lockB = "lockB";

        new Thread(new MyThread(lockA, lockB),"T1").start();
        new Thread(new MyThread(lockB, lockA),"T2").start();
    }
}

class MyThread implements Runnable {
    private String lockA;
    private String lockB;

    public MyThread(String lockA, String lockB) {
        this.lockA = lockA;
        this.lockB = lockB;
    }

    @Override
    public void run() {
        synchronized (lockA) {
            System.out.println(Thread.currentThread().getName() + "lock:" + lockA + "get " + lockB);
            try {
                TimeUnit.SECONDS.sleep(2);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            synchronized (lockB) {
                System.out.println(Thread.currentThread().getName() + "lock:" + lockB + "get " + lockA);
            }
        }
    }
}
</code></pre> 
<p><img src="https://images2.imgbox.com/3d/a3/BCulqTVu_o.png" alt="在这里插入图片描述"><br>  </p> 
<blockquote> 
 <p>解决问题</p> 
</blockquote> 
<p>1、使用 <code>jps -l</code> 定位进程号<br> <img src="https://images2.imgbox.com/30/73/z3VTJ2pz_o.png" alt="在这里插入图片描述"><br>  <br> 2、使用 <code>jstack 进程号</code> 找到死锁问题<br> <img src="https://images2.imgbox.com/e9/bf/R7F4C5RP_o.png" alt="在这里插入图片描述"><br>  <br> 排查问题：<br> 1、日志<br> 2、堆栈信息</p> 
<p> <br>  <br> <strong>创作不易，如果有帮助到你，请给题解<mark>点个赞和收藏</mark>，让更多的人看到！！！</strong><br> <strong><mark>关注博主</mark>不迷路，内容持续更新中。</strong></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8f31b9cf6b112057c501e6dc08a145e7/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">PDManer安装教程</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/02b21c7984b64868c83cfe747322f4aa/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Pyuic出现No module named ‘PyQt5.sip‘问题解决</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>