<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Android Framework 窗口子系统 （07）窗口动画之Animation &amp; Animator - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Android Framework 窗口子系统 （07）窗口动画之Animation &amp; Animator" />
<meta property="og:description" content="该系列文章总纲链接：专题分纲目录 Android Framework 窗口子系统
本章关键点总结 &amp; 说明： 导图是不断迭代的，这里主要关注➕ 左上角 Android 窗口系统中Animation &amp; Animator部分即可。主要说明Android的3种常见动画：View动画、帧动画、属性动画的基础概念以及使用方法。放大Android 窗口系统中Animation &amp; Animator部分，效果如下：
1 Animation
在Android 3.0以前，android支持两种动画模式，tween(view) animation,frame(drawable) animation，在android3.0中又引入了一个新的动画系统：property animation，这3种动画模式被称为property animation,view animation,drawable animation。 注意：可以通过{NineOldAndroids}(github上开源项目)在3.0之前的系统中使用Property Animation
1.1 View Animation / Tween Animation
@1 Animation是以XML格式定义的，定义好的XML文件存放在res/anim中。 由于Tween Animation与Frame Animation的定义、使用都有很大的差异。按照XML文档的结构{父节点|子节点|属性}来介绍Tween Animation，其由4种类型：
Alpha：渐变透明度动画效果
Scale：渐变尺寸伸缩动画效果
Translate：画面转换位置移动动画效果
Rotate：画面转换位置移动动画效果
@@1.1 在介绍以上4种类型前，先介绍Tween Animation共同的节点属性
@@1.2 alpha专有属性说明
@@1.3 scale专有属性说明
@@1.4 translate专用属性说明
@@1.5 rotate专有属性说明
@2 Tween Animation如何使用(Android SDK提供了2种方法) @@2.1 直接从XML资源中读取Animation并使用。
用XML定义的动画放在/res/anim/文件夹内，XML文件的根元素可以为&lt;alpha&gt;,&lt;scale&gt;,&lt;translate&gt;,&lt;rotate&gt;, interpolator元素 或&lt;set&gt;(表示以上几个动画的集合，set可以嵌套)。默认情况下，所有动画是同时进行的，可以通过startOffset属性设置各个动画的开始偏移（开始时间）来达到动画顺序播放的效果。
定义好动画的XML文件后，可以通过类似下面的代码对指定View应用动画。使用实例如下所示：
ImageView spaceshipImage = (ImageView)findViewById(R.id.spaceshipImage); Animation hyperspaceJumpAnimation=AnimationUtils." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/c4861d754c9e636baa7be0eaeee64708/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-07-12T10:27:40+08:00" />
<meta property="article:modified_time" content="2019-07-12T10:27:40+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Android Framework 窗口子系统 （07）窗口动画之Animation &amp; Animator</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>该系列文章总纲链接：<a href="https://blog.csdn.net/vviccc/article/details/104194986">专题分纲目录 Android Framework 窗口子系统</a></p> 
<hr> 
<h3>本章关键点总结 &amp; 说明：</h3> 
<p style="text-align:center;"><img alt="" class="has" height="338" src="https://images2.imgbox.com/05/5f/HMqEYdas_o.png" width="600"></p> 
<p>导图是不断迭代的，这里主要关注➕ 左上角 Android 窗口系统中Animation &amp; Animator部分即可。主要说明Android的3种常见动画：View动画、帧动画、属性动画的基础概念以及使用方法。放大Android 窗口系统中Animation &amp; Animator部分，效果如下：</p> 
<p style="text-align:center;"><img alt="" class="has" height="365" src="https://images2.imgbox.com/23/84/9C627sJ5_o.png" width="600"></p> 
<p><strong>1 Animation</strong><br> 在Android 3.0以前，android支持两种动画模式，tween(view) animation,frame(drawable) animation，在android3.0中又引入了一个新的动画系统：property animation，这3种动画模式被称为property animation,view animation,drawable animation。 <br><span style="color:#7c79e5;">注意：可以通过{NineOldAndroids}(github上开源项目)在3.0之前的系统中使用Property Animation</span></p> 
<p><strong>1.</strong><strong>1 View Animation / Tween Animation</strong><br>     @1 Animation是以XML格式定义的，定义好的XML文件存放在res/anim中。 由于Tween Animation与Frame Animation的定义、使用都有很大的差异。按照XML文档的结构{父节点|子节点|属性}来介绍Tween Animation，其由4种类型：<br>         Alpha：渐变透明度动画效果<br>         Scale：渐变尺寸伸缩动画效果<br>         Translate：画面转换位置移动动画效果<br>         Rotate：画面转换位置移动动画效果<br>     @@1.1 在介绍以上4种类型前，先介绍Tween Animation共同的节点属性</p> 
<p style="text-align:center;"><img alt="" class="has" src="https://images2.imgbox.com/99/73/9ewW4rKG_o.png"></p> 
<p>    @@1.2 alpha专有属性说明</p> 
<p style="text-align:center;"><img alt="" class="has" src="https://images2.imgbox.com/21/2c/vMgqsoDh_o.png"></p> 
<p>    @@1.3 scale专有属性说明</p> 
<p style="text-align:center;"><img alt="" class="has" src="https://images2.imgbox.com/7a/af/fW7MoL6S_o.png"></p> 
<p>    @@1.4  translate专用属性说明</p> 
<p style="text-align:center;"><img alt="" class="has" src="https://images2.imgbox.com/81/ad/X2bbBAbg_o.png"></p> 
<p>    @@1.5 rotate专有属性说明</p> 
<p style="text-align:center;"><img alt="" class="has" src="https://images2.imgbox.com/21/73/fsbO7YZw_o.png"></p> 
<p>@2 Tween Animation如何使用(Android SDK提供了2种方法)  <br>     @@2.1 直接从XML资源中读取Animation并使用。<br>         用XML定义的动画放在/res/anim/文件夹内，XML文件的根元素可以为&lt;alpha&gt;,&lt;scale&gt;,&lt;translate&gt;,&lt;rotate&gt;, interpolator元素 或&lt;set&gt;(表示以上几个动画的集合，set可以嵌套)。默认情况下，所有动画是同时进行的，可以通过startOffset属性设置各个动画的开始偏移（开始时间）来达到动画顺序播放的效果。<br>     定义好动画的XML文件后，可以通过类似下面的代码对指定View应用动画。使用实例如下所示：</p> 
<pre class="has"><code class="language-java">ImageView spaceshipImage = (ImageView)findViewById(R.id.spaceshipImage);
Animation hyperspaceJumpAnimation=AnimationUtils.loadAnimation(this, R.anim.hyperspace_jump);
spaceshipImage.startAnimation(hyperspaceJumpAnimation);</code></pre> 
<p>@@2.2 使用Animation子类的构造函数来初始化Animation对象。<br>         Android SDK的animation package（android.view.animation），其提供了操作Tween Animation所有的类。<br>         Android SDK提供了基类：Animation，包含大量的set/getXXXX()函数来设置、读取Animation的属性，也就是前面表一中显示的各种属性。Tween Animation由4种类型：alpha、scale、translate、roate，在Android SDK中提供了相应的类，Animation类派生出了AlphaAnimation、ScaleAnimation、 TranslateAnimation、RotateAnimation分别实现了平移、旋转、改变 Alpha 值等动画，每个子类都在父类的基础上增加了各自独有的属性。再去看下这几个类的构造函数，和在表2-&gt;5中定义的属性完全一样。<br> @3 动画的运行控制与模式<br> @@3.1 动画的运行时如何控制的？<br> interpolator定义一个动画的变化率（the rate of change）。这使得基本的动画效果(alpha, scale, translate, rotate）得以加速，减速，重复等。即动画的进度使用 Interpolator 控制。Interpolator 定义了动画的变化速度，可以实现匀速、正加速、负加速、无规则变加速等。Interpolator 是基类，封装了所有 Interpolator 的共同方法，它只有一个方法，即 getInterpolation (float input)，该方法提供了几个Interpolator 子类，实现了不同的速度曲线，如下： </p> 
<p style="text-align:center;"><img alt="" class="has" src="https://images2.imgbox.com/48/7a/Bvva4ztC_o.png"></p> 
<p>对于 LinearInterpolator ，变化率是个常数，即f(x) = x，代码实现如下：</p> 
<pre class="has"><code class="language-java">public float getInterpolation(float input) {
 return input;
}</code></pre> 
<p>Interpolator其他的几个子类，也都是按照特定的算法，实现了对变化率。还可以定义自己的 Interpolator 子类，实现抛物线、自由落体等物理效果。<br> @@3.2 动画的运行模式(2种)<br>         独占模式，即程序主线程进入一个循环，根据动画指令不断刷新屏幕，直到动画结束。<br>         中断模式，即有单独一个线程对时间计数，每隔一定的时间向主线程发通知，主线程接到通知后更新屏幕。<br> @4 动画实现原理<br> @@4.1 Transformation记录了仿射矩阵Matrix，动画每触发一次，会对原来的矩阵做一次运算， View的Bitmap与这个矩阵相乘就可实现相应的操作(旋转、平移、缩放等)。<br> @@4.2 图形变换通过仿射矩阵实现。图形变换是图形学中的基本知识，简单来讲，每种变换都是一次矩阵运算。在 Android中，Canvas 类中包含当前矩阵，当调用Canvas.drawBitmap(bmp, x, y, Paint)绘制时，Android会先把bmp做一次矩阵运算，然后将运算的结果显示在Canvas上。这样，编程人员只需不断修改Canvas的矩阵并刷新屏幕，View里的对象就会不停的做图形变换，因此就形成了动画。</p> 
<p><strong>1.2 Animation Drawable资源(Drawable Animation / Frame Animation,帧动画)</strong><br> @1 不同于animation package， Android SDK提供了另外一个类AnimationDrawable来定义、使用Frame Animation。<br> @@1.1 Frame Animation可以在XML Resource定义(还是存放到res/anim文件夹下)，也可以使用AnimationDrawable中的API定义。<br> @@1.2 由于Tween Animation与Frame Animation有着很大的不同，因此XML定义的格式也完全不一样。这里的Drawable Animation / Frame Animation是顺序播放事先做好的图像，通过一系列Drawable依次显示来模拟动画的效果。在XML中的定义方式如下：</p> 
<pre class="has"><code class="language-html">&lt;animation-list xmlns:android="http://schemas.android.com/apk/res/android"
    android:oneshot="true"&gt;
    &lt;item android:drawable="@drawable/rocket_thrust1" android:duration="200" /&gt;
    ...
&lt;/animation-list&gt;</code></pre> 
<p>@@1.3 下面对节点的元素加以说明：</p> 
<p style="text-align:center;"><img alt="" class="has" src="https://images2.imgbox.com/72/bd/5LBZnuQW_o.png"></p> 
<p>必须以&lt;animation-list&gt;为根元素，以&lt;item&gt;表示要轮换显示的图片，duration属性表示各项显示的时间。XML文件要放在/res/drawable/    <br> @2 Drawable Animation使用示例：<br> @@2.1 首先，来定义一帧一帧的动画</p> 
<pre class="has"><code class="language-html">&lt;animation-list xmlns:android=”http://schemas.android.com/apk/res/android”
android:oneshot=”true”&gt;
   &lt;item android:drawable=”@drawable/rocket_thrust1″ android:duration=”200″ /&gt;
   &lt;item android:drawable=”@drawable/rocket_thrust2″ android:duration=”200″ /&gt;
   &lt;item android:drawable=”@drawable/rocket_thrust3″ android:duration=”200″ /&gt;
&lt;/animation-list&gt;</code></pre> 
<p>其包含3帧动画，3帧动画中分别应用了drawable中的3张图片：rocket_thrust1，rocket_thrust2，rocket_thrust3，每帧动画持续200毫秒。然后我们将以上XML保存在res/anim/文件夹下，命名为rocket_thrust.xml<br> @@2.2 显示动画的代码如下：</p> 
<pre class="has"><code class="language-java">rotected void onCreate(Bundle savedInstanceState) {
        // TODO Auto-generated method stub
        super.onCreate(savedInstanceState);
        setContentView(R.layout.main);
        imageView = (ImageView) findViewById(R.id.imageView1);
        imageView.setBackgroundResource(R.drawable.drawable_anim);
        anim = (AnimationDrawable) imageView.getBackground();
    }
    public boolean onTouchEvent(MotionEvent event) {
        if (event.getAction() == MotionEvent.ACTION_DOWN) {
            anim.stop();
            anim.start();
            return true;
        }
        return super.onTouchEvent(event);
    }</code></pre> 
<p>@@2.3 这里有几点需要注意(基于SDK文档的说明)：<br>         调用Imageview的setBackgroundResource方法，如果直接在XML布局文件中设置其src属性，当触发动画时会FC。<br>         在动画start()之前要先stop()，不然在第一次动画之后会停在最后一帧，这样动画就只会触发一次。<br>         不要在onCreate中调用start，因为AnimationDrawable还没有完全跟Window相关联，如果想要界面显示时就开始动画的话，可以在onWindowFoucsChanged()中调用start()。<br> @3 阅读Android SDK中对AnimationDrawable的介绍，有个简单的了解：</p> 
<p style="text-align:center;"><img alt="" class="has" src="https://images2.imgbox.com/0d/bb/S9pMqFDO_o.png"></p> 
<p><span style="color:#7c79e5;">注：Frame Animation 的XML 文件中不定义 interpolator 属性，因为定义它没有任何意义。</span></p> 
<p> </p> 
<p><strong>2 Animator(Property Animation)<br> 2.1 Animator简介</strong><br>     Animator代表一个属性动画，但是它只是一个抽象类。<br>     通常会使用它的子类：AnimatiorSet、ValueAnimator、ObjectAnimator。<br>     XML文件应放在res/animator/中，通过以下方式应用动画<br>     @2 如何使用属性动画定义资源</p> 
<p><strong>2.2 Property Animation的工作方式</strong><br> @1 属性动画，这个是在Android 3.0中才引进的，它更改的是对象的实际属性。<br> 在View Animation（Tween Animation）中，其改变的是View的绘制效果，真正的View的属性保持不变，比如无论你在对话中如何缩放Button的大小，Button的有效点击区域还是没有应用动画时的区域，其位置与大小都不变。在Property Animation中，改变的是对象的实际属性，如Button的缩放，Button的位置与大小属性值都改变了。而且Property Animation不止可以应用于View，还可以应用于任何对象。Property Animation只是表示一个值在一段时间内的改变，当值改变时要做什么事情完全是你自己决定的。<br> @2 在Property Animation中，可以对动画应用以下属性：</p> 
<p style="text-align:center;"><img alt="" class="has" src="https://images2.imgbox.com/48/af/HSDajp75_o.png"></p> 
<p><strong>2.3 几种常见属性动画的使用实例(XML定义与使用动画)</strong><br> @1 ValueAnimator值动画XML的使用实例<br> ValueAnimator代码和xml设置中，没有setPropertyName，因为不是操作对象，只是根据value进行某种动作<br> 需要加监听器，监听值的变化做相应的处理<br> @@1.1 xml定义值动画</p> 
<pre class="has"><code class="language-html">&lt;?xml version="1.0" encoding="utf-8"?&gt;  
    &lt;animator xmlns:android="http://schemas.android.com/apk/res/android"   
        android:interpolator="@android:anim/accelerate_interpolator"  
        android:duration="10000"  
        android:startOffset="1000"  
        android:repeatCount="infinite"  
        android:repeatMode="restart"  
        android:valueFrom="1"  
        android:valueTo="100"  
        android:valueType="intType"&gt;  
    &lt;/animator&gt;  </code></pre> 
<p>@@1.2 代码加载XML动画</p> 
<pre class="has"><code class="language-java">ValueAnimator valueAnimator = (ValueAnimator) AnimatorInflater.loadAnimator(this, 
R.animator.animator);  
            valueAnimator.setTarget(tv_num);  
            valueAnimator.setEvaluator(new TypeEvaluator&lt;Integer&gt;() {  
      
                @Override   
                public Integer evaluate(float fraction, Integer startValue, Integer endValue) {  
                    System.out.println("时间比率，fraction:" + fraction);  
                    System.out.println("结果值:" + (int)((startValue + fraction * 
(endValue - startValue)) / 10 * 10));  
                    return (int)((startValue + fraction * (endValue - startValue)) / 10 * 10);  
                }  
            });  
            valueAnimator.addUpdateListener(new AnimatorUpdateListener() {  
                  
                @Override  
                public void onAnimationUpdate(ValueAnimator animation) {  
                    //在onAnimationUpdate中 该值返回第一个动画的 当前帧的evaluate 值  
                    System.out.println("animation.getAnimatedValue()==" + animation.getAnimatedValue());  
                    tv_num.setText(animation.getAnimatedValue() + "");  
                }  
            });  
    //      valueAnimator.setInterpolator(new LinearInterpolator());  
            valueAnimator.start();  </code></pre> 
<p>@2 ObjectAnimator动画XML的使用实例<br> @@2.1 动画XML的定义</p> 
<pre class="has"><code class="language-html">&lt;?xml version="1.0" encoding="utf-8"?&gt;  
&lt;objectAnimator xmlns:android="http://schemas.android.com/apk/res/android"  
    android:duration="2000"  
    android:propertyName="scaleX"  
    android:repeatCount="1"  
    android:repeatMode="reverse"  
    android:valueFrom="1.0"  
    android:valueTo="2.0" &gt;  
&lt;/objectAnimator&gt; </code></pre> 
<p>@@2.2 代码加载XML动画</p> 
<pre class="has"><code class="language-java">imageview_scale.setBackground(getResources().getDrawable(R.drawable.a11));  
            ObjectAnimator scaleAnimator = (ObjectAnimator) AnimatorInflater.loadAnimator(this, 
R.animator.scale_object_animator);  
            scaleAnimator.setTarget(imageview_scale);//设置动画作用的目标对象  
            scaleAnimator.setDuration(1000);  
            scaleAnimator.setRepeatCount(50);  
            scaleAnimator.start();  </code></pre> 
<p>@3 AnimatorSet 动画集<br>         由ObjectAnimator 和 ValueAnimator 组成，对应的xml中的写法类似为&lt;set&gt; &lt;objectAnimator /&gt; ... &lt;animator /&gt;... &lt;/set&gt;<br>         xml定义动画集一般在文件夹res/animator下，这里是res/animator/set_rotate_scale.xml<br> @@3.1 XML定义如下：</p> 
<pre class="has"><code class="language-html">&lt;?xml version="1.0" encoding="utf-8"?&gt;  
    &lt;set xmlns:android="http://schemas.android.com/apk/res/android"   
        android:ordering="together"&gt;  
      
        &lt;!-- android:ordering  together表示同时运行动画，  sequentially 表示按顺序执行以下动画 --&gt;  
        &lt;set&gt;  
            &lt;objectAnimator  
                android:propertyName="rotationX"  
                android:repeatCount="50"  
                android:repeatMode="reverse"  
                android:valueFrom="0"  
                android:valueTo="20" /&gt;  
            &lt;objectAnimator  
                android:propertyName="rotationY"  
                android:repeatCount="50"  
                android:repeatMode="reverse"  
                android:valueFrom="0"  
                android:valueTo="45"  
                android:valueType="floatType" /&gt;  
        &lt;/set&gt;  
        &lt;set&gt;  
            &lt;objectAnimator  
                android:propertyName="scaleX"  
                android:repeatCount="50"  
                android:repeatMode="reverse"  
                android:valueFrom="1.0"  
                android:valueTo="2.0" &gt;  
            &lt;/objectAnimator&gt;  
            &lt;objectAnimator  
                android:propertyName="scaleY"  
                android:repeatCount="50"  
                android:repeatMode="reverse"  
                android:valueFrom="1.0"  
                android:valueTo="2.0" &gt;  
            &lt;/objectAnimator&gt;  
        &lt;/set&gt;  
      
    &lt;/set&gt;  </code></pre> 
<p>@@3.2 代码加载XML动画集</p> 
<pre class="has"><code class="language-java">imageview_rotate.setBackground(getResources().getDrawable(R.drawable.a11));  
            AnimatorSet animatorSet = (AnimatorSet) AnimatorInflater.loadAnimator(this, R.animator.set_rotate_scale);  
            animatorSet.setTarget(imageview_rotate);  
            animatorSet.setDuration(1000);  
            animatorSet.setInterpolator(new BounceInterpolator());//设置end时的弹跳插入器  
            animatorSet.start();  </code></pre> 
<p><strong>2.4 几种常见属性动画的使用实例(代码定义与使用动画)</strong><br> @1 ValueAnimator动画(代码实现机制)<br> 整个属性动画机制当中最核心的一个类，属性动画的运行机制是通过不断地对值进行操作来实现的，而初始值和结束值之间的动画过渡就是由ValueAnimator这个类来负责计算的。它的内部使用一种时间循环的机制来计算值与值之间的动画过渡，我们只需要将初始值和结束值提供给ValueAnimator，并且告诉它动画所需运行的时长，那么ValueAnimator就会自动帮我们完成从初始值平滑地过渡到结束值这样的效果。除此之外，ValueAnimator还负责管理动画的播放次数、播放模式、以及对动画设置监听器等，是一个非常重要的类。但是ValueAnimator的用法却一点都不复杂，实例(将一个值从0平滑过渡到1，时长300毫秒，就可以这样写)如下：</p> 
<pre class="has"><code class="language-java">    ValueAnimator anim = ValueAnimator.ofFloat(0f, 1f);  
    anim.setDuration(300);  
    anim.start();  </code></pre> 
<p>@2 ObjectAnimator动画(代码实现机制)<br> 相比于ValueAnimator，ObjectAnimator可能才是我们最常接触到的类，因为ValueAnimator只不过是对值进行了一个平滑的动画过渡。而ObjectAnimator则不同，它是可以直接对任意对象的任意属性进行动画操作的，比如说View的alpha属性。<br> 不过虽说ObjectAnimator会更加常用一些，但是它其实是继承自ValueAnimator的，底层的动画实现机制也是基于ValueAnimator来完成的，因此ValueAnimator仍然是整个属性动画当中最核心的一个类。那么既然是继承关系，说明ValueAnimator中可以使用的方法在ObjectAnimator中也是可以正常使用的，它们的用法也非常类似，<br> @@2.1 实例(一个TextView在5秒中内从常规变换成全透明，再从全透明变换成常规)如下：</p> 
<pre class="has"><code class="language-java">ObjectAnimator animator = ObjectAnimator.ofFloat(textview, "alpha", 1f, 0f, 1f);  
    animator.setDuration(5000);  
    animator.start();  </code></pre> 
<p>@@2.2 实例(将TextView进行一次360度的旋转)<br> 将@@2.1中第二个参数改成"rotation"，然后将动画的初始值和结束值分别设置成0和360</p> 
<pre class="has"><code class="language-java">ObjectAnimator animator = ObjectAnimator.ofFloat(textview, "rotation", 0f, 360f);  
    animator.setDuration(5000);  
    animator.start();  </code></pre> 
<p>@@2.3 实例(将TextView先向左移出屏幕，然后再移动回来)</p> 
<pre class="has"><code class="language-java">    float curTranslationX = textview.getTranslationX();  
    ObjectAnimator animator = ObjectAnimator.ofFloat(textview, "translationX",
 curTranslationX, -500f, curTranslationX);  
    animator.setDuration(5000);  
    animator.start(); </code></pre> 
<p>先是调用了TextView的getTranslationX()方法来获取到当前TextView的translationX的位置，然后ofFloat()方法的第二个参数传入"translationX"，紧接着后面三个参数用于告诉系统TextView应该怎么移动<br> @@2.4 实例(将TextView在垂直方向上放大3倍再还原)<br> 将ofFloat()方法的第二个参数改成了"scaleY"，表示在垂直方向上进行缩放</p> 
<pre class="has"><code class="language-java">ObjectAnimator animator = ObjectAnimator.ofFloat(textview, "scaleY", 1f, 3f, 1f);  
    animator.setDuration(5000);  
    animator.start();  </code></pre> 
<p>@@2.5  特殊说明<br> @@@2.5.1 ofFloat()方法的第二个参数到底可以传哪些值？<br> 使用alpha、rotation、translationX和scaleY这几个值，分别可以完成淡入淡出、旋转、水平移动、垂直缩放这几种动画，那么还有哪些值是可以使用的呢？其实这个问题的答案非常玄乎，就是我们可以传入任意的值到ofFloat()方法的第二个参数当中。因为ObjectAnimator在设计的时候就没有针对于View来进行设计，而是针对于任意对象的，它所负责的工作就是不断地向某个对象中的某个属性进行赋值，然后对象根据属性值的改变再来决定如何展现出来。<br> @@@2.5.2 为什么textview可以实现该动画<br> 举例说明,代码如下：</p> 
<pre class="has"><code class="language-java">ObjectAnimator.ofFloat(textview, "alpha", 1f, 0f); </code></pre> 
<p>ObjectAnimator会帮我们不断地改变textview对象中alpha属性的值，从1f变化到0f。然后textview需要根据alpha属性值的改变来不断刷新界面的显示，从而让用户可以看出淡入淡出的动画效果。但textview中没有这些属性，但它是继承View的，任何继承自View的对象都可以实现该功能。<br> @3 组合动画<br> @@3.1 独立的动画能够实现的视觉效果毕竟是相当有限的，因此将多个动画组合到一起播放就显得尤为重要。实现组合动画主要借助AnimatorSet这个类，这个类提供了一个play()方法，如果我们向这个方法中传入一个Animator对象(ValueAnimator或ObjectAnimator)将会返回一个AnimatorSet.Builder的实例，AnimatorSet.Builder中包括以下四个方法：<br>             after(Animator anim)    将现有动画插入到传入的动画之后执行<br>             after(long delay)       将现有动画延迟指定毫秒后执行<br>             before(Animator anim)   将现有动画插入到传入的动画之前执行<br>             with(Animator anim)     将现有动画和传入的动画同时执行<br>         有了这四个方法，我们就可以完成组合动画的逻辑了<br> @@3.2 实例(让TextView先从屏幕外移动进屏幕，然后开始旋转360度，旋转的同时进行淡入淡出操作)</p> 
<pre class="has"><code class="language-java">ObjectAnimator moveIn = ObjectAnimator.ofFloat(textview, "translationX", -500f, 0f); 
    ObjectAnimator rotate = ObjectAnimator.ofFloat(textview, "rotation", 0f, 360f);  
    ObjectAnimator fadeInOut = ObjectAnimator.ofFloat(textview, "alpha", 1f, 0f, 1f);  
    AnimatorSet animSet = new AnimatorSet();  
    animSet.play(rotate).with(fadeInOut).after(moveIn);  
    animSet.setDuration(5000);  
    animSet.start();  </code></pre> 
<p>这里先是把三个动画的对象全部创建出来，然后new出一个AnimatorSet对象之后将这三个动画对象进行播放排序，让旋转和淡入淡出动画同时进行，并把它们插入到了平移动画的后面，最后是设置动画时长以及启动动画。</p> 
<p><strong>2.5 Animator监听器</strong></p> 
<p>在很多时候，我们希望可以监听到动画的各种事件，动画何时开始，何时结束，然后在开始或者结束的时候去执行一些逻辑处理。这个功能是完全可以实现的，Animator类当中提供了一个addListener()方法，这个方法接收一个AnimatorListener，我们只需要去实现这个AnimatorListener就可以监听动画的各种事件了。只要是继承自Animator的，addListener()这个方法算是个通用的方法，添加一个监听器的代码如下所示：</p> 
<pre class="has"><code class="language-java">anim.addListener(new AnimatorListener() {  
        @Override  
        public void onAnimationStart(Animator animation) {/*动画开始时*/}  
      
        @Override  
        public void onAnimationRepeat(Animator animation) {/*动画重复时*/}  
      
        @Override  
        public void onAnimationEnd(Animator animation) {/*动画结束时*/}  
      
        @Override  
        public void onAnimationCancel(Animator animation) {/*动画取消时*/}  
    });  </code></pre> 
<p>但是也许很多时候我们并不想要监听那么多个事件，可能我只想要监听动画结束这一个事件，那么每次都要将四个接口全部实现一遍就显得非常繁琐。没关系，为此Android提供了一个适配器类，叫作AnimatorListenerAdapter，使用这个类就可以解决掉实现接口繁琐的问题了，如下所示：</p> 
<pre class="has"><code class="language-java">anim.addListener(new AnimatorListenerAdapter() {});  </code></pre> 
<p>这里我们向addListener()方法中传入这个适配器对象，由于AnimatorListenerAdapter中已经将每个接口都实现好了，所以这里不用实现任何一个方法也不会报错。那么如果想监听动画结束这个事件，就只需要单独重写这一个方法就可以了，如下所示：</p> 
<pre class="has"><code class="language-java">anim.addListener(new AnimatorListenerAdapter() {  
        @Override  
        public void onAnimationEnd(Animator animation) {  
        }  
    });  </code></pre> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/70d5217c312b6effa588470d7bae5384/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">JS学习之onmouseover事件与onmouseout事件实现</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/040d2a32bee84d500c68bdd9f56120c5/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Android Framework 窗口子系统 （08）窗口动画之动画系统框架</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>