<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>剑指offer面试题（11）——旋转数组的最小数字 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="剑指offer面试题（11）——旋转数组的最小数字" />
<meta property="og:description" content="题目：把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如数组 {3, 4, 5, 1, 2} 为 {1, 2, 3, 4, 5} 的一个旋转，该数组的最小值为 1 。
解题思路 最直观的做法是把旋转数组从前到后遍历一遍，其时间复杂度为 O(n)。很明显，这种解法效率较低。
主要代码如下：
int FindMinElement(int* array,int length) { int minElement = array[0]; if (array == nullptr || length &lt;= 0) throw new std::exception(&#34;Invalid parameters&#34;); for (int i = 0; i &lt; length; &#43;&#43;i) { if (array[i] &lt;= minElement) minElement = array[i]; } return minElement; } 旋转后的数组实际为两个排序子数组的组合，在排序的数组中可以用二分查找的方法来查找最小数字，其时间复杂度为O(logn)。每次查找都把旋转数组平均分成两部分，通过比较当前旋转数组两端点和中间点的值，判断最小值在数组的哪一部分，从而达到缩小搜索范围的目的。具体过程如下图所示:
需要注意的是，当旋转数组的两端点的值都与中间点的值相等时，无法判断最小值在哪一部分，因此需要采用顺序查找方法，其查找过程如下图所示：
上述查找过程主要实现代码如下：
int MinInOrder(int* array,const int&amp; index1, const int&amp; index2) { int minNumber = array[index1]; for (int i = index1 &#43; 1; i &lt;= index2; &#43;&#43;i) { if (array[i] &lt; minNumber) minNumber = array[i]; } return minNumber; } int FindMinElement(int* array, const int&amp; length) { //输入合法检查 if (array == nullptr || length &lt;= 0) throw new std::exception(&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/3df743218b30f04b67d769836f2d2e76/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-07-04T09:41:06+08:00" />
<meta property="article:modified_time" content="2018-07-04T09:41:06+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">剑指offer面试题（11）——旋转数组的最小数字</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p style="text-align:left;font-family:Verdana, Arial, Helvetica, sans-serif;background-color:rgb(255,255,255);"><span style="color:rgb(0,0,0);"><span style="font-size:14px;">题目：把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如数组 {3, 4, 5, 1, 2} 为 {1, 2, 3, 4, 5} 的一个旋转，该数组的最小值为 1 。</span></span></p> 
<p style="color:rgb(0,0,0);text-align:left;font-family:Verdana, Arial, Helvetica, sans-serif;background-color:rgb(255,255,255);"><strong>解题思路</strong><span style="font-size:14px;">    </span></p> 
<p style="text-align:left;font-family:Verdana, Arial, Helvetica, sans-serif;background-color:rgb(255,255,255);"><span style="color:rgb(0,0,0);"><span style="font-size:14px;">         最直观的做法是把旋转数组从前到后遍历一遍，其时间复杂度为 O(n)。很明显，这种解法效率较低。</span></span></p> 
<p style="text-align:left;font-family:Verdana, Arial, Helvetica, sans-serif;background-color:rgb(255,255,255);"><span style="color:rgb(0,0,0);"><span style="font-size:14px;">        主要代码如下：</span></span></p> 
<pre><code class="language-cpp">int FindMinElement(int* array,int length)
{
	int minElement = array[0];
	if (array == nullptr || length &lt;= 0)
		throw new std::exception("Invalid parameters");
	for (int i = 0; i &lt; length; ++i)
	{
		if (array[i] &lt;= minElement)
			minElement = array[i];
	}
	return minElement;
}</code></pre> 
<p><span style="color:rgb(0,0,0);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);">        旋转后的数组实际为两个排序子数组的组合，在排序的数组中可以用二分查找的方法来查找最小数字，其时间复杂度为<span style="color:rgb(0,0,0);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);">O(logn)。</span>每次查找都把旋转数组平均分成两部分，通过比较当前旋转数组两端点和中间点的值，判断最小值在数组的哪一部分，从而达到缩小搜索范围的目的。具体过程如下图所示:</span></p> 
<p style="text-align:center;"><span style="color:rgb(0,0,0);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);"><img src="https://images2.imgbox.com/ae/ac/brxr6n3h_o.png" alt=""><br></span></p> 
<p style="text-align:center;"><span style="color:rgb(0,0,0);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);"><img src="https://images2.imgbox.com/c3/d1/3B7WpGnP_o.png" alt=""><br></span></p> 
<p><span style="color:rgb(0,0,0);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);">        需要注意的是，当旋转数组的两端点的值都与中间点的值相等时，无法判断最小值在哪一部分，因此需要采用顺序查找方法，其查找过程如下图所示：</span></p> 
<p><span style="color:rgb(0,0,0);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);"><img src="https://images2.imgbox.com/12/b8/Xh90TQ9m_o.png" alt=""><br></span></p> 
<p><span style="color:rgb(0,0,0);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);">        上述查找过程主要实现代码如下：</span></p> 
<pre><code class="language-cpp">int MinInOrder(int* array,const int&amp; index1, const int&amp; index2)
{
	int minNumber = array[index1];
	for (int i = index1 + 1; i &lt;= index2; ++i)
	{
		if (array[i] &lt; minNumber)
			minNumber = array[i];
	}
	return minNumber;
}
int FindMinElement(int* array, const int&amp; length)
{
	//输入合法检查
	if (array == nullptr || length &lt;= 0)
		throw new std::exception("Invalid parameters");
	int index1   = 0;
	int index2   = length-1;
	int midIndex = 0;
	//如果旋转数组前面的0个数字，则直接跳过，返回第一个元素
	while (array[index1] &gt;= array[index2])
	{
		if (index2 - index1 == 1)
		{
			midIndex = index2;
			break;
		}
		midIndex = (index1 + index2) / 2;
		//如果index1，index2，midIndex三者指向的元素大小相等，
		//则只能顺序查找最小元素
		if (array[midIndex] == array[index1] &amp;&amp; array[midIndex] &lt;= array[index2])
			return MinInOrder(array,index1, index2);
		if (array[midIndex] &gt;= array[index1])
			index1 = midIndex;
		else if(array[midIndex] &lt;= array[index2])
			index2 = midIndex;

	}
	return array[midIndex];
}</code></pre> 
<span style="color:rgb(0,0,0);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:14px;text-align:left;background-color:rgb(255,255,255);">        当题目要求在排序的数组或部分排序的数组中查找某一个数字或统计某个数字出现的次数时，都可以尝试使用二分查找方法。</span> 
<br> 
<p><span style="color:rgb(0,0,0);font-family:Verdana, Arial, Helvetica, sans-serif;background-color:rgb(255,255,255);"><strong>测试用例1</strong></span>  </p> 
<pre><code class="language-cpp">// ====================测试代码====================
void Test(int* array, int length, int expected)
{
	int result = 0;
	try
	{
		result = FindMinElement(array, length);

		for (int i = 0; i &lt; length; ++i)
			cout &lt;&lt; array[i] &lt;&lt; endl;

		if (result == expected)
			cout &lt;&lt; "\tpassed\n" &lt;&lt; endl;
		else
			cout &lt;&lt; "\tfailed\n" &lt;&lt; endl;
	}
	catch (...)
	{
		if (array == nullptr)
			cout &lt;&lt; "Test passed.\n" &lt;&lt; endl;
		else
			cout &lt;&lt; "Test failed.\n" &lt;&lt; endl;
	}
}

int main()
{
	// 典型输入，单调升序的数组的一个旋转
	int array1[] = { 3, 4, 5, 1, 2 };
	Test(array1, sizeof(array1) / sizeof(int), 1);

	// 有重复数字，并且重复的数字刚好的最小的数字
	int array2[] = { 3, 4, 5, 1, 1, 2 };
	Test(array2, sizeof(array2) / sizeof(int), 1);

	// 有重复数字，但重复的数字不是第一个数字和最后一个数字
	int array3[] = { 3, 4, 5, 1, 2, 2 };
	Test(array3, sizeof(array3) / sizeof(int), 1);

	// 有重复的数字，并且重复的数字刚好是第一个数字和最后一个数字
	int array4[] = { 1, 0, 1, 1, 1 };
	Test(array4, sizeof(array4) / sizeof(int), 0);

	// 单调升序数组，旋转0个元素，也就是单调升序数组本身
	int array5[] = { 1, 2, 3, 4, 5 };
	Test(array5, sizeof(array5) / sizeof(int), 1);

	// 数组中只有一个数字
	int array6[] = { 2 };
	Test(array6, sizeof(array6) / sizeof(int), 2);

	// 输入nullptr
	Test(nullptr, 0, 0);

	system("pause");
	return 0;
}</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4ff02c7677205f458d9a2e72fb76df1d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Java使用SFTP和FTP两种连接方式实现对服务器的上传下载</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f292f0d3fbb073ce90de551b245e572e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">小程序批量上传照片至服务器</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>