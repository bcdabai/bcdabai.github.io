<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>CGAL最小生成树、可视化 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="CGAL最小生成树、可视化" />
<meta property="og:description" content="CGAL 5.4.5 - Surface Mesh: User Manual
1、Kruskal计算最小生成树 #include &lt;CGAL/Simple_cartesian.h&gt; #include &lt;CGAL/Surface_mesh.h&gt; #include &lt;boost/graph/kruskal_min_spanning_tree.hpp&gt; #include &lt;iostream&gt; #include &lt;fstream&gt; #include &lt;list&gt; typedef CGAL::Simple_cartesian&lt;double&gt; Kernel; typedef Kernel::Point_3 Point; typedef CGAL::Surface_mesh&lt;Point&gt; Mesh; typedef boost::graph_traits&lt;Mesh&gt;::vertex_descriptor vertex_descriptor; typedef boost::graph_traits&lt;Mesh&gt;::vertex_iterator vertex_iterator; typedef boost::graph_traits&lt;Mesh&gt;::edge_descriptor edge_descriptor; /* Surface_mesh 提供了四个嵌套类，分别代表半边数据结构的基本元素： Surface_mesh::Vertex_index曲面网格::顶点索引 Surface_mesh::Halfedge_index曲面网格::半边索引 Surface_mesh::Face_index曲面网格::面索引 Surface_mesh::Edge_index曲面网格::边索引 */ void kruskal(const Mesh&amp; sm) { // 默认权重=边的平方长 存储Surace_mesh 的边信息 std::list&lt;edge_descriptor&gt; mst; //9600-&gt;3199 边 boost::kruskal_minimum_spanning_tree(sm, std::back_inserter(mst)); std::cout &lt;&lt; &#34;#VRML V2.0 utf8\n&#34; &#34;Shape {\n&#34; &#34; appearance Appearance {\n&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/7fbb88aa12c286f4971f4d7fff8af35c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-18T15:28:22+08:00" />
<meta property="article:modified_time" content="2024-01-18T15:28:22+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">CGAL最小生成树、可视化</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><a href="https://doc.cgal.org/5.4.5/Surface_mesh/index.html#title0" rel="nofollow" title="CGAL 5.4.5 - Surface Mesh: User Manual">CGAL 5.4.5 - Surface Mesh: User Manual</a></p> 
<p></p> 
<h2>1、Kruskal计算最小生成树</h2> 
<p><img alt="" height="399" src="https://images2.imgbox.com/b7/8e/qISIhFvn_o.png" width="469"></p> 
<pre><code class="language-cpp">#include &lt;CGAL/Simple_cartesian.h&gt;
#include &lt;CGAL/Surface_mesh.h&gt;
#include &lt;boost/graph/kruskal_min_spanning_tree.hpp&gt;
#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;list&gt;
typedef CGAL::Simple_cartesian&lt;double&gt;                       Kernel;
typedef Kernel::Point_3                                      Point;
typedef CGAL::Surface_mesh&lt;Point&gt;                            Mesh;
typedef boost::graph_traits&lt;Mesh&gt;::vertex_descriptor vertex_descriptor;
typedef boost::graph_traits&lt;Mesh&gt;::vertex_iterator   vertex_iterator;
typedef boost::graph_traits&lt;Mesh&gt;::edge_descriptor   edge_descriptor;
/*
Surface_mesh 提供了四个嵌套类，分别代表半边数据结构的基本元素：

Surface_mesh::Vertex_index曲面网格::顶点索引
Surface_mesh::Halfedge_index曲面网格::半边索引
Surface_mesh::Face_index曲面网格::面索引
Surface_mesh::Edge_index曲面网格::边索引

*/
void kruskal(const Mesh&amp; sm)
{
    // 默认权重=边的平方长   存储Surace_mesh 的边信息
    std::list&lt;edge_descriptor&gt; mst;
    //9600-&gt;3199 边
    boost::kruskal_minimum_spanning_tree(sm,
        std::back_inserter(mst));
    std::cout &lt;&lt; "#VRML V2.0 utf8\n"
        "Shape {\n"
        "  appearance Appearance {\n"
        "    material Material { emissiveColor 1 0 0}}\n"
        "    geometry\n"
        "    IndexedLineSet {\n"
        "      coord Coordinate {\n"
        "        point [ \n";
    
    //打印sm中所有顶点
    for (auto v : sm.vertices()) {
        std::cout &lt;&lt; "        " &lt;&lt; sm.point(v) &lt;&lt; "\n";
    }
    //vertex_iterator vb, ve;
    //for (boost::tie(vb, ve) = vertices(sm); vb != ve; ++vb) {
    //    std::cout &lt;&lt; "        " &lt;&lt; sm.point(*vb) &lt;&lt; "\n";
    //}
    std::cout &lt;&lt; "        ]\n"
        "     }\n"
        "      coordIndex [\n";

    //对于每条边，它提取并打印出该边连接的两个顶点的索引。
    for (std::list&lt;edge_descriptor&gt;::iterator it = mst.begin(); it != mst.end(); ++it)
    {
        edge_descriptor e = *it;
        vertex_descriptor s = source(e, sm);
        vertex_descriptor t = target(e, sm);
        std::cout &lt;&lt; "      " &lt;&lt; s &lt;&lt; ", " &lt;&lt; t &lt;&lt; ", -1\n";
    }
    std::cout &lt;&lt; "]\n"
        "  }#IndexedLineSet\n"
        "}# Shape\n";
}
int main(int argc, char** argv)
{
    Mesh sm;
    std::string fname = argc == 1 ? CGAL::data_file_path("meshes/knot1.off") : argv[1];
    if (!CGAL::IO::read_polygon_mesh(fname, sm))
    {
        std::cerr &lt;&lt; "Invalid input file." &lt;&lt; std::endl;
        return EXIT_FAILURE;
    }
    kruskal(sm);
    return 0;
}</code></pre> 
<h2>2、Prim的最小生成树 </h2> 
<p>还是之前的模型</p> 
<blockquote> 
 <p>好的，我将重点解释Prim算法的使用以及在代码中如何通过映射来存储Prim算法的结果。</p> 
 <h4>Prim最小生成树算法</h4> 
 <p>Prim算法是一种用于在带权无向图中找到最小生成树的算法。最小生成树是原图的一个子图，它连接了图中的所有顶点，且边的权重之和最小，且不形成任何循环。Prim算法的基本思想是：</p> 
 <ol><li>从图中的某个顶点开始。</li><li>每次迭代中，选择连接树与非树顶点且权重最小的边，并将其添加到树中。</li><li>重复此过程直到所有顶点都被包含在树中。</li></ol> 
</blockquote> 
<p></p> 
<pre><code class="language-cpp">#include &lt;CGAL/Simple_cartesian.h&gt;
#include &lt;CGAL/Surface_mesh.h&gt;
#include &lt;iostream&gt;
#include &lt;fstream&gt;
// workaround a bug in Boost-1.54
#include &lt;CGAL/boost/graph/dijkstra_shortest_paths.h&gt;
#include &lt;boost/graph/prim_minimum_spanning_tree.hpp&gt;
typedef CGAL::Simple_cartesian&lt;double&gt;                       Kernel;
typedef Kernel::Point_3                                      Point;
typedef CGAL::Surface_mesh&lt;Point&gt;                            Mesh;
typedef boost::graph_traits&lt;Mesh&gt;::vertex_descriptor vertex_descriptor;
int main(int argc, char* argv[])
{
    Mesh sm;
    std::string fname = R"(C:\chenqi\ThridParty\CGAL-5.4.3\data\meshes\knot1.off)";
    if (!CGAL::IO::read_polygon_mesh(fname, sm))
    {
        std::cerr &lt;&lt; "Invalid input file." &lt;&lt; std::endl;
        return EXIT_FAILURE;
    }
    //声明了一个名为 predecessor 的属性映射。这个映射将每个顶点（vertex_descriptor）映射到另一个顶点（也是 vertex_descriptor）。
    //这种类型的映射通常用于存储诸如搜索算法中每个顶点的前驱顶点之类的信息。
    Mesh::Property_map&lt;vertex_descriptor, vertex_descriptor&gt; predecessor;
    predecessor = sm.add_property_map&lt;vertex_descriptor, vertex_descriptor&gt;("v:predecessor").first;
    //在计算完最小生成树后，代码遍历所有顶点，并使用 predecessor 映射来输出每个顶点与其前驱顶点之间的边。
    boost::prim_minimum_spanning_tree(sm, predecessor, boost::root_vertex(*vertices(sm).first));
    std::cout &lt;&lt; "#VRML V2.0 utf8\n"
        "DirectionalLight {\n"
        "direction 0 -1 0\n"
        "}\n"
        "Shape {\n"
        "  appearance Appearance {\n"
        "    material Material { emissiveColor 1 0 0}}\n"
        "    geometry\n"
        "    IndexedLineSet {\n"
        "      coord Coordinate {\n"
        "        point [ \n";
    for (vertex_descriptor vd : vertices(sm)) {
        std::cout &lt;&lt; "        " &lt;&lt; sm.point(vd) &lt;&lt; "\n";
    }
    std::cout &lt;&lt; "        ]\n"
        "     }\n"
        "      coordIndex [\n";
    for (vertex_descriptor vd : vertices(sm)) {
        if (predecessor[vd] != vd) {
            std::cout &lt;&lt; "      " &lt;&lt; std::size_t(vd) &lt;&lt; ", " &lt;&lt; std::size_t(predecessor[vd]) &lt;&lt; ", -1\n";
        }
    }
    std::cout &lt;&lt; "]\n"
        "  }#IndexedLineSet\n"
        "}# Shape\n";
    sm.remove_property_map(predecessor);
    return 0;
}
</code></pre> 
<p></p> 
<pre><code class="language-cpp">命令行生成wrl
your_program &gt; mst.wrl</code></pre> 
<p>下载可视化软件</p> 
<p><a href="https://sourceforge.net/projects/freewrl/files/latest/download" rel="nofollow" title="Download FreeWRL VRML/X3D browser (sourceforge.net)">Download FreeWRL VRML/X3D browser (sourceforge.net)</a></p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;CGAL/Simple_cartesian.h&gt;
#include &lt;CGAL/Surface_mesh.h&gt;
typedef CGAL::Simple_cartesian&lt;double&gt; K;
typedef CGAL::Surface_mesh&lt;K::Point_3&gt; Mesh;
typedef Mesh::Vertex_index vertex_descriptor;
int main()
{
    Mesh m;
    Mesh::Vertex_index u;
    for (unsigned int i = 0; i &lt; 5; ++i) {
        Mesh::Vertex_index v = m.add_vertex(K::Point_3(0, 0, i + 1));
        if (i == 2) u = v;
    }
    m.remove_vertex(u);
    std::cout &lt;&lt; "After insertion of 5 vertices and removal of the 3. vertex\n"
        &lt;&lt; "# vertices  / # vertices + # removed vertices = "
        &lt;&lt; m.number_of_vertices()
        &lt;&lt; " / " &lt;&lt; m.number_of_vertices() + m.number_of_removed_vertices() &lt;&lt; std::endl;
    std::cout &lt;&lt; "Iterate over vertices\n";
    {
        for (vertex_descriptor vd : m.vertices()) {
            std::cout &lt;&lt; m.point(vd) &lt;&lt; std::endl;
        }
    }
    // The status of being used or removed is stored in a property map
    Mesh::Property_map&lt;Mesh::Vertex_index, bool&gt; removed
        = m.property_map&lt;Mesh::Vertex_index, bool&gt;("v:removed").first;
    std::cout &lt;&lt; "\nIterate over vertices and deleted vertices\n"
        &lt;&lt; "# vertices / # vertices + # removed vertices = "
        &lt;&lt; m.number_of_vertices()
        &lt;&lt; " / " &lt;&lt; m.number_of_vertices() + m.number_of_removed_vertices() &lt;&lt; std::endl;
    {
        unsigned int i = 0, end = m.number_of_vertices() + m.number_of_removed_vertices();
        for (; i &lt; end; ++i) {
            vertex_descriptor vh(i);
            assert(m.is_removed(vh) == removed[vh]);
            std::cout &lt;&lt; m.point(vh) &lt;&lt; ((m.is_removed(vh)) ? "  R\n" : "\n");
        }
    }
    m.collect_garbage();
    std::cout &lt;&lt; "\nAfter garbage collection\n"
        &lt;&lt; "# vertices / # vertices + # removed vertices = "
        &lt;&lt; m.number_of_vertices()
        &lt;&lt; " / " &lt;&lt; m.number_of_vertices() + m.number_of_removed_vertices() &lt;&lt; std::endl;
    {
        unsigned int i = 0, end = m.number_of_vertices() + m.number_of_removed_vertices();
        for (; i &lt; end; ++i) {
            vertex_descriptor vh(i);
            std::cout &lt;&lt; m.point(vh) &lt;&lt; ((m.is_removed(vh)) ? "  R\n" : "\n");
        }
    }
    return 0;
}</code></pre> 
<p></p> 
<h2>3、移除顶点垃圾回收</h2> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;CGAL/Simple_cartesian.h&gt;
#include &lt;CGAL/Surface_mesh.h&gt;
typedef CGAL::Simple_cartesian&lt;double&gt; K;
typedef CGAL::Surface_mesh&lt;K::Point_3&gt; Mesh;
typedef Mesh::Vertex_index vertex_descriptor;
int main()
{
    Mesh m;
    Mesh::Vertex_index u;
    for (unsigned int i = 0; i &lt; 5; ++i) {
        Mesh::Vertex_index v = m.add_vertex(K::Point_3(0, 0, i + 1));
        if (i == 2) u = v;
    }
    m.remove_vertex(u);
    std::cout &lt;&lt; "After insertion of 5 vertices and removal of the 3. vertex\n"
        &lt;&lt; "# vertices  / # vertices + # removed vertices = "
        &lt;&lt; m.number_of_vertices()
        &lt;&lt; " / " &lt;&lt; m.number_of_vertices() + m.number_of_removed_vertices() &lt;&lt; std::endl;
    std::cout &lt;&lt; "Iterate over vertices\n";
    {
        for (vertex_descriptor vd : m.vertices()) {
            std::cout &lt;&lt; m.point(vd) &lt;&lt; std::endl;
        }
    }
    // The status of being used or removed is stored in a property map
    Mesh::Property_map&lt;Mesh::Vertex_index, bool&gt; removed
        = m.property_map&lt;Mesh::Vertex_index, bool&gt;("v:removed").first;
    std::cout &lt;&lt; "\nIterate over vertices and deleted vertices\n"
        &lt;&lt; "# vertices / # vertices + # removed vertices = "
        &lt;&lt; m.number_of_vertices()
        &lt;&lt; " / " &lt;&lt; m.number_of_vertices() + m.number_of_removed_vertices() &lt;&lt; std::endl;
    {
        unsigned int i = 0, end = m.number_of_vertices() + m.number_of_removed_vertices();
        for (; i &lt; end; ++i) {
            vertex_descriptor vh(i);
            //这是一个断言语句，用于验证顶点vh的移除状态。m.is_removed(vh)返回一个布尔值，指示顶点是否被移除。
            //removed[vh]从之前创建的属性映射中获取该顶点的移除状态。断言确保这两种方式获取的信息是一致的。
            assert(m.is_removed(vh) == removed[vh]);
            //这行代码打印出顶点的坐标。如果顶点被移除（m.is_removed(vh)为true），则在坐标后面打印" R"（表示顶点被移除）。否则，只打印一个换行符。
            std::cout &lt;&lt; m.point(vh) &lt;&lt; ((m.is_removed(vh)) ? "  R\n" : "\n");
        }
    }

    //调用collect_garbage以清除被移除的顶点并优化网格内存使用。
    //再次遍历所有顶点，这次只包括未被移除的顶点。
    m.collect_garbage();
    std::cout &lt;&lt; "\nAfter garbage collection\n"
        &lt;&lt; "# vertices / # vertices + # removed vertices = "
        &lt;&lt; m.number_of_vertices()
        &lt;&lt; " / " &lt;&lt; m.number_of_vertices() + m.number_of_removed_vertices() &lt;&lt; std::endl;
    {
        unsigned int i = 0, end = m.number_of_vertices() + m.number_of_removed_vertices();
        for (; i &lt; end; ++i) {
            vertex_descriptor vh(i);
            std::cout &lt;&lt; m.point(vh) &lt;&lt; ((m.is_removed(vh)) ? "  R\n" : "\n");
        }
    }
    return 0;
}</code></pre> 
<p><img alt="" height="390" src="https://images2.imgbox.com/6e/83/6o9Z5dlY_o.png" width="563"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5b9297fc32c69c07552d5b4bc10ca4c9/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Redis三种缓存读写策略</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0761fc08294ec5d22a8b59f7d9e76b3b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">LLM之LangChain（四）| 介绍LangChain 0.1在可观察性、可组合性、流媒体、工具、RAG和代理方面的改进</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>