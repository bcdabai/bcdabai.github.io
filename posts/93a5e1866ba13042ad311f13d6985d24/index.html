<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Feign高级配置 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Feign高级配置" />
<meta property="og:description" content="1、Feign对负载均衡的支持 Feign 本身已经集成了Ribbon依赖和自动配置，因此我们不需要额外引入依赖，可以通过 ribbon.xx 来进行全局配置,也可以通过服务名.ribbon.xx 来对指定服务进行细节配置配置（参考之前，此处略）
Feign默认的请求处理超时时长1s，有时候我们的业务确实执行的需要一定时间，那么这个时候，我们就需要调整请求处理超时时长，Feign自己有超时设置，如果配置Ribbon的超时，则会以Ribbon的为准。
Ribbon设置
#针对的被调用方微服务名称,不加就是全局生效 lagou-service-resume: ribbon: #请求连接超时时间 ConnectTimeout: 2000 #请求处理超时时间 ReadTimeout: 15000 # Feign 超时时间设置 #对所有操作都进⾏重试 OkToRetryOnAllOperations: true ####根据如上配置，当访问到故障请求的时候，它会再尝试访问⼀次当前实例（次数由MaxAutoRetries配置）， ####如果不⾏，就换⼀个实例进⾏访问，如果还不⾏，再换⼀次实例访问（更换次数由MaxAutoRetriesNextServer配置）， ####如果依然不⾏，返回失败信息。 MaxAutoRetries: 0 #对当前选中实例重试次数，不包括第⼀次调⽤ MaxAutoRetriesNextServer: 0 #切换实例的重试次数 NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RoundRobinRule #负载策略调整 2、Feign对熔断器的支持 在Feign客户端工程配置文件（application.yml）中开启Feign对熔断器的支持。
# 开启Feign的熔断功能 feign: hystrix: enabled: true Feign的超时时长设置那其实就上面Ribbon的超时时长设置，Hystrix超时设置（就按照之前Hystrix设置的方式就OK了）
注意：
开启Hystrix之后，Feign中的方法都会被进行一个管理了，一旦出现问题就进入对应的回退逻辑处理针对超时这一点，当前有两个超时时间设置（Feign/hystrix），熔断的时候是根据这两个时间的最小值来进行的，即处理时长超过最短的那个超时时间了就熔断进入回退降级逻辑 hystrix: command: default: execution: isolation: thread: timeoutInMilliseconds: 15000 自定义FallBack处理类（需要实现FeignClient接口）
package com.lagou.edu.controller.service; import org.springframework.stereotype.Component; /** * 降级回退逻辑需要定义一个类，实现FeignClient接口，实现接口中的方法 * 此接口是我们进行Feign远程调用时所创建的接口 */ @Component public class ResumeFallback implements ResumeServiceFeignClient{ @Override public Integer findDefaultResumeState(Long userId) { return -6; } } 在@FeignClient注解中关联2）中自定义的处理类" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/93a5e1866ba13042ad311f13d6985d24/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-08-27T09:43:54+08:00" />
<meta property="article:modified_time" content="2022-08-27T09:43:54+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Feign高级配置</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>1、Feign对负载均衡的支持</h3> 
<p>        Feign 本身已经集成了Ribbon依赖和自动配置，因此我们不需要额外引入依赖，可以通过 ribbon.xx 来进行全局配置,也可以通过服务名.ribbon.xx 来对指定服务进行细节配置配置（参考之前，此处略）</p> 
<p>        Feign默认的请求处理超时时长1s，有时候我们的业务确实执行的需要一定时间，那么这个时候，我们就需要调整请求处理超时时长，Feign自己有超时设置，如果配置Ribbon的超时，则会以Ribbon的为准。</p> 
<p><span style="color:#956fe7;"><strong>Ribbon设置</strong></span></p> 
<pre><code class="hljs">#针对的被调用方微服务名称,不加就是全局生效
lagou-service-resume:
  ribbon:
    #请求连接超时时间
    ConnectTimeout: 2000
    #请求处理超时时间
    ReadTimeout: 15000  # Feign 超时时间设置
    #对所有操作都进⾏重试
    OkToRetryOnAllOperations: true
    ####根据如上配置，当访问到故障请求的时候，它会再尝试访问⼀次当前实例（次数由MaxAutoRetries配置），
    ####如果不⾏，就换⼀个实例进⾏访问，如果还不⾏，再换⼀次实例访问（更换次数由MaxAutoRetriesNextServer配置），
    ####如果依然不⾏，返回失败信息。
    MaxAutoRetries: 0 #对当前选中实例重试次数，不包括第⼀次调⽤
    MaxAutoRetriesNextServer: 0 #切换实例的重试次数
    NFLoadBalancerRuleClassName:  com.netflix.loadbalancer.RoundRobinRule #负载策略调整</code></pre> 
<p></p> 
<h3>2、Feign对熔断器的支持</h3> 
<p>      <span style="color:#956fe7;">在Feign客户端工程配置文件（application.yml）中开启Feign对熔断器的支持。</span></p> 
<pre><code class="hljs"># 开启Feign的熔断功能
feign:
  hystrix:
    enabled: true</code></pre> 
<p>        Feign的超时时长设置那其实就上面Ribbon的超时时长设置，Hystrix超时设置（就按照之前Hystrix设置的方式就OK了）</p> 
<p><strong>注意：</strong></p> 
<ol><li>开启Hystrix之后，Feign中的方法都会被进行一个管理了，一旦出现问题就进入对应的回退逻辑处理</li><li>针对超时这一点，当前有两个超时时间设置（Feign/hystrix），熔断的时候是根据这两个时间的最小值来进行的，即处理时长超过最短的那个超时时间了就熔断进入回退降级逻辑</li></ol> 
<pre><code class="hljs">hystrix:
  command:
    default:
      execution:
        isolation:
          thread:
            timeoutInMilliseconds: 15000</code></pre> 
<p>  <span style="color:#956fe7;">自定义FallBack处理类（需要实现FeignClient接口）</span></p> 
<pre><code class="language-java">package com.lagou.edu.controller.service;

import org.springframework.stereotype.Component;

/**
 * 降级回退逻辑需要定义一个类，实现FeignClient接口，实现接口中的方法
 * 此接口是我们进行Feign远程调用时所创建的接口
 */
@Component
public class ResumeFallback implements ResumeServiceFeignClient{
    @Override
    public Integer findDefaultResumeState(Long userId) {
        return -6;
    }
}
</code></pre> 
<p>  <span style="color:#956fe7;">在@FeignClient注解中关联2）中自定义的处理类</span></p> 
<pre><code class="language-java">package com.lagou.edu.controller.service;

import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;

// @FeignClient标明当前类是一个Feign客户端，value指定该客户端要请求的服务器名称（登记到注册中心上服务提供者的服务名称）
@FeignClient(value = "lagou-service-resume", fallback = ResumeFallback.class, path = "/resume") 
// 使⽤fallback的时候，类上的@RequestMapping的url前缀限定，改成配置在@FeignClient的path属性中
// @RequestMapping("/resume")
public interface ResumeServiceFeignClient {

    // feign要做的事情，拼装url发起请求
    // 我们调用该方法就是调用本地接口方法，那么实际上做的事远程请求
    @GetMapping("/openstate/{userId}")
    public Integer findDefaultResumeState(@PathVariable Long userId);
}
</code></pre> 
<p></p> 
<h3>3、Feign对请求压缩和响应压缩的支持</h3> 
<p>        Feign 支持对请求和响应进行GZIP压缩，以减少通信过程中的性能损耗。通过下面的参数即可开启请求与响应的压缩功能：</p> 
<pre><code class="language-java">feign:
    compression:
        request:
            enabled: true # 开启请求压缩
            mime-types: text/html,application/xml,application/json # 设置压缩的数据类型，此处也是默认值
            min-request-size: 2048 # 设置触发压缩的⼤⼩下限，此处也是默认值
        response:
            enabled: true # 开启响应压缩</code></pre> 
<p></p> 
<h3>4、Feign的日志级别配置</h3> 
<p>        Feign是http请求客户端，类似于咱们的浏览器，它在请求和接收响应的时候，可以打印出比较详细的⼀些日志信息（响应头，状态码等等）</p> 
<p>        如果我们想看到Feign请求时的日志，我们可以进行配置，默认情况下Feign的日志没有开启。</p> 
<p>  <span style="color:#be191c;">开启Feign日志功能及级别</span></p> 
<pre><code class="language-java">// Feign的⽇志级别（Feign请求过程信息）
// NONE：默认的，不显示任何⽇志----性能最好
// BASIC：仅记录请求⽅法、URL、响应状态码以及执⾏时间----⽣产问题追踪
// HEADERS：在BASIC级别的基础上，记录请求和响应的header
// FULL：记录请求和响应的header、body和元数据----适⽤于开发及测试环境定位问题

import feign.Logger;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class FeignLog {
    @Bean
    Logger.Level feignLevel() {
        return Logger.Level.FULL;
    }
}</code></pre> 
<p>  配置log日志级别为debug</p> 
<pre><code class="language-java">logging:
  level:
    # Feign⽇志只会对⽇志级别为debug的做出响应
    com.lagou.edu.controller.service.ResumeServiceFeignClient:  debug</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ebc1f7a3a7e26b7dbffb5ea99308ef5a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">对Flutter GetX的一些理解</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/764abfe4a42ba28904c68c2be324e586/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">计算机网络之公有IP和私有IP</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>