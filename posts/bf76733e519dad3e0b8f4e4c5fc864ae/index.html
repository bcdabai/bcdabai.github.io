<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>OSPF基础知识点2 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="OSPF基础知识点2" />
<meta property="og:description" content="目录
OSPF的三张表：
邻居和邻接关系：
OSPF邻居关系的建立过程：
邻接关系建立的详细过程：
指邻居：
OSPF支持的网络类型：
OSPF路由器类型：
OSPF的三张表： OSPF有三张重要的表项，OSPF邻居表、LSDB表和OSPF路由表。
对于OSPF的邻居表，需要了解：
1.OSPF在传递链路状态信息之前，需先建立OSPF邻居关系。
2.OSPF的邻居关系通过交互Hello报文建立。
3.OSPF邻居表显示了OSPF路由器之间的邻居状态，使用display ospf peer查看
对于OSPF的LSDB表，需要了解：
1.LSDB会保存自己产生的及从邻居收到的LSA信息。
2.Type标识LSA的类型，AdvRouter标识发送LSA的路由器。
3.使用命令行display ospf lsdb查看LSDB表
type有七类： 一类、二类、三类、五类、四类、七类 ，advR：是通告路由器，即谁发的 。
OSPF路由表
使用display ip routting-table 这条命令查看到的路由表叫做是实际路由的转发表，即路由器是主要依据这个表进行数据转发。
OSPF路由表中只有通过OSPF协议学到的路由信息，但不是转发表。
对于OSPF的路由表，需要了解：
1.OSPF路由表和路由器路由表是两张不同的表项。
2.OSPF路由表包含Destination、Cost和NextHop等指导转发的信息。
3.使用命令display ospf routing查看OSPF路由表。
邻居和邻接关系： 邻居关系和邻接关系：所有OSPF路由器之间的关系都是邻居关系，但只有部分路由器之间的关系是邻接关系。
邻居关系的形成：
OSPF邻居关系的建立过程： 1、运行OSPF协议的路由器在启动后会主动向外发送一个Hello报文（第1个）
Hello中包含（自己的RID，邻居的RID为空的）
2、当邻居也运行的是OSPF在收到发来的Hello后，会将自己状态从原始Down转换为Init，并向邻 居也发送第一个Hello报文
3、当运行OSPF协议的路由器在收到邻居发来的第一个Hello报文后会将自己状态从Down转换为 Init
4、先转换为Init状态的路由器发现自己的RID不在邻居发来第一个Hello报文中，这时，会发送第二 Hello报文 Hello报文中包含（自己RID，邻居的RID）
5、邻居路由器在收到后也会发送第二个Hello报文
6、当收到邻居发来的Hello报文中包含自己的RID时，会将自己的状态从Init转换为2-Way，这时两 台路由之间就形成了邻居关系。
邻接关系的形成：
邻接关系建立的详细过程： 路由器在建立完成邻居关系之后，根据路由器角色便开始进行数据库同步过程，具体如下：
第一次DD用于选主从：
1、邻居状态变为ExStart以后，发送第一个DD报文，在这个报文中，DD序列号被设置为X（任 意），并假设自己为主路由器。
2、互相发送完第一个DD报文后会比较Router ID的大小，大的为真正的主路由器Master，次大 的为Slave。
第二次真正交互DD报文
3、在主从确定后，从路由器会发送一个新的DD报文，这个新的报文中包含LSDB的摘要信 息，序列号设置为主路由器第一次使用的序列号，并将自己的状态从Exstart转换为Exchange， 主路由器在收到从路由器发来新的DD报文后将邻居状态改变为Exchange。
4、当主路由器邻居状态变为Exchange以后，主路由器会发送一个新的DD报文，该报文中包含 LSDB的描述信息，收到DD报文序列号不变（上次使用的序列号）。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/bf76733e519dad3e0b8f4e4c5fc864ae/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-12-08T10:18:05+08:00" />
<meta property="article:modified_time" content="2022-12-08T10:18:05+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">OSPF基础知识点2</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="OSPF%E7%9A%84%E4%B8%89%E5%BC%A0%E8%A1%A8%EF%BC%9A-toc" style="margin-left:40px;"><a href="#OSPF%E7%9A%84%E4%B8%89%E5%BC%A0%E8%A1%A8%EF%BC%9A" rel="nofollow">OSPF的三张表：</a></p> 
<p id="OSPF%E8%B7%AF%E7%94%B1%E5%99%A8%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB%EF%BC%9A-toc" style="margin-left:40px;"><a href="#OSPF%E8%B7%AF%E7%94%B1%E5%99%A8%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB%EF%BC%9A" rel="nofollow">邻居和邻接关系：</a></p> 
<p id="OSPF%E9%82%BB%E5%B1%85%E5%85%B3%E7%B3%BB%E7%9A%84%E5%BB%BA%E7%AB%8B%E8%BF%87%E7%A8%8B%EF%BC%9A-toc" style="margin-left:80px;"><a href="#OSPF%E9%82%BB%E5%B1%85%E5%85%B3%E7%B3%BB%E7%9A%84%E5%BB%BA%E7%AB%8B%E8%BF%87%E7%A8%8B%EF%BC%9A" rel="nofollow">OSPF邻居关系的建立过程：</a></p> 
<p id="%E9%82%BB%E6%8E%A5%E5%85%B3%E7%B3%BB%E5%BB%BA%E7%AB%8B%E7%9A%84%E8%AF%A6%E7%BB%86%E8%BF%87%E7%A8%8B%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%E9%82%BB%E6%8E%A5%E5%85%B3%E7%B3%BB%E5%BB%BA%E7%AB%8B%E7%9A%84%E8%AF%A6%E7%BB%86%E8%BF%87%E7%A8%8B%EF%BC%9A" rel="nofollow">邻接关系建立的详细过程：</a></p> 
<p id="%E6%8C%87%E9%82%BB%E5%B1%85%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%E6%8C%87%E9%82%BB%E5%B1%85%EF%BC%9A" rel="nofollow">指邻居：</a></p> 
<p id="OSPF%E6%94%AF%E6%8C%81%E7%9A%84%E7%BD%91%E7%BB%9C%E7%B1%BB%E5%9E%8B%EF%BC%9A-toc" style="margin-left:40px;"><a href="#OSPF%E6%94%AF%E6%8C%81%E7%9A%84%E7%BD%91%E7%BB%9C%E7%B1%BB%E5%9E%8B%EF%BC%9A" rel="nofollow">OSPF支持的网络类型：</a></p> 
<p id="%C2%A0OSPF%E8%B7%AF%E7%94%B1%E5%99%A8%E7%B1%BB%E5%9E%8B%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%C2%A0OSPF%E8%B7%AF%E7%94%B1%E5%99%A8%E7%B1%BB%E5%9E%8B%EF%BC%9A" rel="nofollow"> OSPF路由器类型：</a></p> 
<p></p> 
<hr> 
<h3 id="OSPF%E7%9A%84%E4%B8%89%E5%BC%A0%E8%A1%A8%EF%BC%9A">OSPF的三张表：</h3> 
<p>OSPF有三张重要的表项，OSPF邻居表、LSDB表和OSPF路由表。</p> 
<p><strong>对于OSPF的邻居表，需要了解：</strong></p> 
<p>1.OSPF在传递链路状态信息之前，需先建立OSPF邻居关系。</p> 
<p>     2.OSPF的邻居关系通过交互Hello报文建立。</p> 
<p>     3.OSPF邻居表显示了OSPF路由器之间的邻居状态，使用<span style="color:#fe2c24;">display ospf peer</span>查看</p> 
<p><strong>对于OSPF的LSDB表，需要了解：</strong></p> 
<p>1.LSDB会保存自己产生的及从邻居收到的LSA信息。</p> 
<p>    2.Type标识LSA的类型，AdvRouter标识发送LSA的路由器。</p> 
<p>    3.使用命令行<span style="color:#fe2c24;">display ospf lsdb</span>查看LSDB表</p> 
<p>type有七类： 一类、二类、三类、五类、四类、七类 ，advR：是通告路由器，即谁发的 。</p> 
<p>OSPF路由表</p> 
<p>   使用<span style="color:#fe2c24;">display ip routting-table </span>这条命令查看到的路由表叫做是实际路由的转发表，即路由器是主要依据这个表进行数据转发。</p> 
<p>OSPF路由表中只有通过OSPF协议学到的路由信息，但不是转发表。</p> 
<p><strong>对于OSPF的路由表，需要了解：</strong></p> 
<p>1.OSPF路由表和路由器路由表是两张不同的表项。</p> 
<p>   2.OSPF路由表包含Destination、Cost和NextHop等指导转发的信息。</p> 
<p>   3.使用命令<span style="color:#fe2c24;">display ospf routing</span>查看OSPF路由表。</p> 
<h3 id="OSPF%E8%B7%AF%E7%94%B1%E5%99%A8%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB%EF%BC%9A">邻居和邻接关系：</h3> 
<p>   <span style="color:#38d8f0;"> 邻居关系和邻接关系：</span>所有OSPF路由器之间的关系都是邻居关系，但只有部分路由器之间的关系是邻接关系。</p> 
<p><strong>邻居关系的形成：</strong></p> 
<p><img alt="" height="642" src="https://images2.imgbox.com/ef/c3/J0bhvTND_o.png" width="1176"></p> 
<p></p> 
<h4 id="OSPF%E9%82%BB%E5%B1%85%E5%85%B3%E7%B3%BB%E7%9A%84%E5%BB%BA%E7%AB%8B%E8%BF%87%E7%A8%8B%EF%BC%9A"><strong><span style="color:#fe2c24;">OSPF邻居关系的建立过程：</span></strong></h4> 
<p>1、运行OSPF协议的路由器在启动后会主动向外发送一个Hello报文（第1个）</p> 
<p>     Hello中包含（自己的RID，邻居的RID为空的）</p> 
<p>2、当邻居也运行的是OSPF在收到发来的Hello后，会将自己状态从原始Down转换为Init，并向邻 居也发送第一个Hello报文</p> 
<p>3、当运行OSPF协议的路由器在收到邻居发来的第一个Hello报文后会将自己状态从Down转换为 Init</p> 
<p>4、先转换为Init状态的路由器发现自己的RID不在邻居发来第一个Hello报文中，这时，会发送第二 Hello报文 Hello报文中包含（自己RID，邻居的RID）</p> 
<p>5、邻居路由器在收到后也会发送第二个Hello报文</p> 
<p>6、当收到邻居发来的Hello报文中包含自己的RID时，会将自己的状态从Init转换为2-Way，这时两 台路由之间就形成了邻居关系。</p> 
<p><strong>邻接关系的形成：</strong></p> 
<p><img alt="" height="833" src="https://images2.imgbox.com/19/07/t7AAFm6Q_o.png" width="1200"></p> 
<p></p> 
<h4 id="%E9%82%BB%E6%8E%A5%E5%85%B3%E7%B3%BB%E5%BB%BA%E7%AB%8B%E7%9A%84%E8%AF%A6%E7%BB%86%E8%BF%87%E7%A8%8B%EF%BC%9A"><strong><span style="color:#fe2c24;">邻接关系建立的详细过程：</span></strong></h4> 
<p><strong>路由器在建立完成邻居关系之后，根据路由器角色便开始进行数据库同步过程，具体如下：</strong></p> 
<p><span style="color:#4da8ee;">第一次DD用于选主从：</span></p> 
<p>1、邻居状态变为ExStart以后，发送第一个DD报文，在这个报文中，DD序列号被设置为X（任 意），并假设自己为主路由器。</p> 
<p>2、互相发送完第一个DD报文后会比较Router ID的大小，大的为真正的主路由器Master，次大 的为Slave。</p> 
<p><span style="color:#4da8ee;">第二次真正交互DD报文</span></p> 
<p>3、在主从确定后，从路由器会发送一个新的DD报文，这个新的报文中包含LSDB的摘要信 息，序列号设置为主路由器第一次使用的序列号，并将自己的状态从Exstart转换为Exchange， 主路由器在收到从路由器发来新的DD报文后将邻居状态改变为Exchange。</p> 
<p>4、当主路由器邻居状态变为Exchange以后，主路由器会发送一个新的DD报文，该报文中包含 LSDB的描述信息，收到DD报文序列号不变（上次使用的序列号）。</p> 
<p>5、当收到主路由器发送的DD报文后作为从路由器，必须要对主路由器发送的每一个DD报文 进行确认。确认DD报文是个内容为空的DD报文，序列号为再次+1。</p> 
<p>6、从路由器在全部确认收到主路由器发来的DD报文后，将邻居状态改变为Loading；主路由 器在收到最后一个DD报文之后，直接改变状态为Full。 开始传递真正的LS详细信息</p> 
<p>7、从路由器的邻居状态变为Loading之后，开始向主路由器发送LSR报文，请求那些在 Exchange状态下通过DD报文发现的，而且在本地LSDB中没有的链路状态信息。</p> 
<p>8、从路由器的邻居状态变为Loading之后，开始向主路由器发送LSR报文，请求那些在 Exchange状态下通过DD报文发现的，而且在本地LSDB中没有的链路状态信息。</p> 
<p>9、主路由器收到LSR报文之后，会向从路由器发送LSU报文，在LSU报文中，包含了那些被请 求的链路状态的详细信息。主路由器在收到LSU报文之后，会将邻居状态从Loading改变成 Full。 10、当从路由器的状态变成Full后向主路由器发送LSACK报文，用于对已接收LSA的确认。</p> 
<p>11、当全部完成后达到邻接关系。</p> 
<p><span style="color:#4da8ee;">状态切换如图所示：</span></p> 
<p><img alt="" height="303" src="https://images2.imgbox.com/99/b6/7jToVsZw_o.png" width="499"></p> 
<p> <strong>Attempt：</strong>此状态只在NBMA网络上存在，表示没有收到邻居的任何信息，但是已经周期性的向邻居发送报文，发送间隔为HelloInterval。如果RouterDeadInterval间隔内未收到邻居的 Hello报文，则转为Down状态。</p> 
<p><span style="color:#fe2c24;">注意事项：（仅在区域内） </span></p> 
<p><span style="color:#fe2c24;">1、在OSPF区域中路由器的角色有DR、BDR和 Drother</span></p> 
<p><span style="color:#fe2c24;">2、DR、BDR和其它所有路由器之间必须要建立邻接关系 </span></p> 
<p><span style="color:#fe2c24;">3、DRother之间的关系为邻居关系 </span></p> 
<p><span style="color:#fe2c24;">4、针对运行OSPF协议的任意一个区域只有一个DR、一个BDR和多个 DRother</span></p> 
<h4 id="%E6%8C%87%E9%82%BB%E5%B1%85%EF%BC%9A"><strong><span style="color:#38d8f0;">指邻居：</span></strong></h4> 
<p>因某些特殊的网络拓扑中可能不支持组播，这时无法建立邻居关系，因此只能通过单播方式建立 邻居关系，我们将这种方式称为手动邻居关系或叫指邻居</p> 
<p>拓扑图及配置命令：</p> 
<p><img alt="" height="197" src="https://images2.imgbox.com/79/fd/FXajfztK_o.png" width="374"></p> 
<h3 id="OSPF%E6%94%AF%E6%8C%81%E7%9A%84%E7%BD%91%E7%BB%9C%E7%B1%BB%E5%9E%8B%EF%BC%9A">OSPF支持的网络类型：</h3> 
<p><img alt="" height="606" src="https://images2.imgbox.com/69/a5/JZKXx1Ot_o.png" width="612"></p> 
<p><strong>OSPF域（Domain）：</strong>是在IGP网络中运行OSPF的所有路由器</p> 
<p><strong>OSPF区域：</strong>是在OSPF域中通过逻辑划分为多个小的区域，主要用于减少邻接关系</p> 
<p><span style="color:#38d8f0;"><strong>泛洪：</strong></span>OSPF路由器在同一个区域（Area）内网络中泛洪LSA。为了确保每台路由器都拥有对网络拓扑的一致认知，LSDB需要在区域内进行同步。==即互相发送链路状态通告 通过划分区域可以减小了LSA泛洪的<span style="color:#fe2c24;">范围</span>，有效的把拓扑变化的影响控制在区域内，达到网络优化的目的。 </p> 
<h4 id="%C2%A0OSPF%E8%B7%AF%E7%94%B1%E5%99%A8%E7%B1%BB%E5%9E%8B%EF%BC%9A"><span style="color:#38d8f0;"><strong> OSPF路由器类型：</strong></span></h4> 
<p>在OSPF中该路由器是什么样的路由器</p> 
<p>1.区域内路由器（Internal Router）<strong>IR </strong>该路由完全只属于某一个区域</p> 
<p>2.区域边界路由器ABR（Area Border Router）<strong> ABR</strong> 即是连接两个不同区域的路由器且其中一个区域必须是骨干区域</p> 
<p>3.骨干路由器（Backbone Router） <strong>BR</strong> 即该路由器是属于区域0的路由器也可以是ABR</p> 
<p>4.自治系统边界路由器ASBR（AS Boundary Router） <strong>AS</strong>自治系统 这个区域内只运行了某一种路由协议 <strong>AS</strong>边界路由器：连接不同AS的路由器。</p> 
<p></p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/127664f2b889d8de30b1469e4017aa23/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">如何从 JavaScript 对象中删除属性？</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1a7e047c97b6754a822c5e490e1cb354/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">获取下一个工作日/休息日的方法 本地基础搭建 Springboot 法定节假日/休息日/调休日 均可 不用调三方</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>