<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【并发编程系列8】阻塞队列之ArrayBlockingQueue,LinkedBlockingQueue,LinkedBlockingDeque原理分析 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【并发编程系列8】阻塞队列之ArrayBlockingQueue,LinkedBlockingQueue,LinkedBlockingDeque原理分析" />
<meta property="og:description" content="ArrayBlockingQueue,LinkedBlockingQueue,LinkedBlockingDeque原理分析 什么是阻塞队列队列Queue接口核心方法阻塞队列BlockigQueue接口核心方法ArrayBlockingQueue模拟实现生产者消费者初始化队列添加元素(生产者)获取元素(消费者) LinkedBlockingQueue初始化队列添加元素(生产者)获取元素(消费者) LinkedBlockingDeque初始化队列添加元素(生产者)从First添加从Last添加 获取元素(消费者)从First获取从Last获取 总结 什么是阻塞队列 阻塞队列有两个特点：
当队列中没有元素时，从队列中获取元素会被阻塞当队列满了时，添加元素会被阻塞 阻塞队列常用于生产者和消费者的场景，生产者是向队列里添加元素，消费者则从队列里取元素。
队列Queue接口核心方法 阻塞队列，本质上来说还是属于队列，也就是说阻塞队列继承了队列的功能，这里我们先来看看Queue接口中的几个核心方法：
方法功能add(e)添加一个元素，成功返回true，如果空间满了则抛出异常offer(e)添加一个元素，成功返回true，如果空间满了则返回false,处理有界队列时优于add方法remove()检索并移除队列头元素，成功则返回移除的元素，如果队列为空则抛出异常poll()检索并移除队列头元素，成功则返回移除的元素，如果队列为空则返回nullelement()检索并返回队列头元素，如果队列为空则抛出异常peek()检索并返回队列头元素，如果位列为空则返回null 这几个方法是队列接口所提供的，然而这些方法并不会阻塞，所以需要重新定义阻塞队列的接口，下面我们看看阻塞队列中的核心方法。
阻塞队列BlockigQueue接口核心方法 方法功能put(e)添加一个元素，成功返回true，如果空间满了则阻塞等待offer(e,time,unit)添加一个元素，成功返回true，如果空间满了则阻塞指定时间，到达指定时间还没空间则返回nulltake()检索并移除队列头元素，成功则返回移除的元素，如果队列为空则阻塞poll(time,unit)检索并移除队列头元素，成功则返回移除的元素，如果队列为空则阻塞指定时间，到达指定时间后队列还是空则返回nulldrainTo(Collection)一次性获取队列所有元素放到指定的集合中，并返回转移个数drainTo(c,n)一次性获取队列中指定个数的元素放到指定的集合中，并返回转移个数remainingCapacity()返回队列中理想情况下可添加元素个数 在Java中，提供了7种常用的阻塞队列。
ArrayBlockingQueue：由数组结构组成的有界阻塞队列LinkedBlockingQueue：由链表结构组成的有界阻塞队列PriorityBlockingQueue：支持优先级排序的无界阻塞队列DelayQueue：使用优先级队列实现的无界阻塞队列SynchronousQueue：不存储元素的阻塞队列LinkedTransferQueue：由链表结构组成的无界阻塞队列LinkedBlockingDeque：由链表结构组成的双向阻塞队列 ArrayBlockingQueue ArrayBlockingQueue是一个用数组实现的有界阻塞队列。此队列按照先进先出（FIFO）的原则对元素进行排序。默认情况下采用非公平锁的方式实现，可以通过构造器传参控制是采用公平锁还是非公平锁实现。先看看ArrayBlockingQueue类图关系：
可以看到有3个构造器，其实最终都是会调用上图中第二个构造器进行初始化,第三个构造器在初始化之后会再进行赋值(如果传入的Collection不为空)。
ArrayBlockingQueue nonFairQueue = new ArrayBlockingQueue(10);//默认非公平锁实现 ArrayBlockingQueue fairQueue = new ArrayBlockingQueue(10,true);//true表示公平锁 模拟实现生产者消费者 package com.zwx.concurrent.queue.block; import java.util.concurrent.ArrayBlockingQueue; public class ArrayBlockingQueueDemo { public static void main(String[] args) throws InterruptedException { ArrayBlockingQueue&lt;Integer&gt; queue = new ArrayBlockingQueue(100);//默认非公平锁实现 new Thread(new ConsumerThread(queue)).start(); Thread.sleep(2000); new Thread(new ProcuctThread(queue)).start(); } } class ProcuctThread extends Thread{ private ArrayBlockingQueue queue; public ProcuctThread(ArrayBlockingQueue queue) { this." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/43da978dc1b81b6d30bcd54bf43a09a5/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-07-05T11:24:26+08:00" />
<meta property="article:modified_time" content="2020-07-05T11:24:26+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【并发编程系列8】阻塞队列之ArrayBlockingQueue,LinkedBlockingQueue,LinkedBlockingDeque原理分析</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>ArrayBlockingQueue,LinkedBlockingQueue,LinkedBlockingDeque原理分析</h4> 
 <ul><li><a href="#_1" rel="nofollow">什么是阻塞队列</a></li><li><a href="#Queue_8" rel="nofollow">队列Queue接口核心方法</a></li><li><a href="#BlockigQueue_19" rel="nofollow">阻塞队列BlockigQueue接口核心方法</a></li><li><a href="#ArrayBlockingQueue_39" rel="nofollow">ArrayBlockingQueue</a></li><li><ul><li><a href="#_48" rel="nofollow">模拟实现生产者消费者</a></li><li><a href="#_98" rel="nofollow">初始化队列</a></li><li><a href="#_101" rel="nofollow">添加元素(生产者)</a></li><li><a href="#_106" rel="nofollow">获取元素(消费者)</a></li></ul> 
  </li><li><a href="#LinkedBlockingQueue_111" rel="nofollow">LinkedBlockingQueue</a></li><li><ul><li><a href="#_115" rel="nofollow">初始化队列</a></li><li><a href="#_122" rel="nofollow">添加元素(生产者)</a></li><li><a href="#_129" rel="nofollow">获取元素(消费者)</a></li></ul> 
  </li><li><a href="#LinkedBlockingDeque_137" rel="nofollow">LinkedBlockingDeque</a></li><li><ul><li><a href="#_144" rel="nofollow">初始化队列</a></li><li><a href="#_147" rel="nofollow">添加元素(生产者)</a></li><li><ul><li><a href="#First_148" rel="nofollow">从First添加</a></li><li><a href="#Last_152" rel="nofollow">从Last添加</a></li></ul> 
   </li><li><a href="#_156" rel="nofollow">获取元素(消费者)</a></li><li><ul><li><a href="#First_157" rel="nofollow">从First获取</a></li><li><a href="#Last_162" rel="nofollow">从Last获取</a></li></ul> 
  </li></ul> 
  </li><li><a href="#_166" rel="nofollow">总结</a></li></ul> 
</div> 
<p></p> 
<h2><a id="_1"></a>什么是阻塞队列</h2> 
<p>阻塞队列有两个特点：</p> 
<ul><li>当队列中没有元素时，从队列中获取元素会被阻塞</li><li>当队列满了时，添加元素会被阻塞</li></ul> 
<p>阻塞队列常用于生产者和消费者的场景，生产者是向队列里添加元素，消费者则从队列里取元素。</p> 
<h2><a id="Queue_8"></a>队列Queue接口核心方法</h2> 
<p>阻塞队列，本质上来说还是属于队列，也就是说阻塞队列继承了队列的功能，这里我们先来看看Queue接口中的几个核心方法：</p> 
<table><thead><tr><th>方法</th><th>功能</th></tr></thead><tbody><tr><td>add(e)</td><td>添加一个元素，成功返回true，如果空间满了则抛出异常</td></tr><tr><td>offer(e)</td><td>添加一个元素，成功返回true，如果空间满了则返回false,处理有界队列时优于add方法</td></tr><tr><td>remove()</td><td>检索并移除队列头元素，成功则返回移除的元素，如果队列为空则抛出异常</td></tr><tr><td>poll()</td><td>检索并移除队列头元素，成功则返回移除的元素，如果队列为空则返回null</td></tr><tr><td>element()</td><td>检索并返回队列头元素，如果队列为空则抛出异常</td></tr><tr><td>peek()</td><td>检索并返回队列头元素，如果位列为空则返回null</td></tr></tbody></table> 
<p>这几个方法是队列接口所提供的，然而这些方法并不会阻塞，所以需要重新定义阻塞队列的接口，下面我们看看阻塞队列中的核心方法。</p> 
<h2><a id="BlockigQueue_19"></a>阻塞队列BlockigQueue接口核心方法</h2> 
<table><thead><tr><th>方法</th><th>功能</th></tr></thead><tbody><tr><td>put(e)</td><td>添加一个元素，成功返回true，<strong>如果空间满了则阻塞等待</strong></td></tr><tr><td>offer(e,time,unit)</td><td>添加一个元素，成功返回true，<strong>如果空间满了则阻塞指定时间</strong>，到达指定时间还没空间则返回null</td></tr><tr><td>take()</td><td>检索并移除队列头元素，成功则返回移除的元素，<strong>如果队列为空则阻塞</strong></td></tr><tr><td>poll(time,unit)</td><td>检索并移除队列头元素，成功则返回移除的元素，<strong>如果队列为空则阻塞指定时间</strong>，到达指定时间后队列还是空则返回null</td></tr><tr><td>drainTo(Collection)</td><td>一次性获取队列所有元素放到指定的集合中，并返回转移个数</td></tr><tr><td>drainTo(c,n)</td><td>一次性获取队列中指定个数的元素放到指定的集合中，并返回转移个数</td></tr><tr><td>remainingCapacity()</td><td>返回队列中理想情况下可添加元素个数</td></tr></tbody></table> 
<p>在Java中，提供了7种常用的阻塞队列。</p> 
<ul><li>ArrayBlockingQueue：由数组结构组成的有界阻塞队列</li><li>LinkedBlockingQueue：由链表结构组成的有界阻塞队列</li><li>PriorityBlockingQueue：支持优先级排序的无界阻塞队列</li><li>DelayQueue：使用优先级队列实现的无界阻塞队列</li><li>SynchronousQueue：不存储元素的阻塞队列</li><li>LinkedTransferQueue：由链表结构组成的无界阻塞队列</li><li>LinkedBlockingDeque：由链表结构组成的双向阻塞队列</li></ul> 
<h2><a id="ArrayBlockingQueue_39"></a>ArrayBlockingQueue</h2> 
<p>ArrayBlockingQueue是一个用数组实现的有界阻塞队列。此队列按照先进先出（FIFO）的原则对元素进行排序。默认情况下采用非公平锁的方式实现，可以通过构造器传参控制是采用公平锁还是非公平锁实现。先看看ArrayBlockingQueue类图关系：<br> <img src="https://images2.imgbox.com/9f/a0/ch9ZNR6R_o.png" alt="在这里插入图片描述"><br> 可以看到有3个构造器，其实最终都是会调用上图中第二个构造器进行初始化,第三个构造器在初始化之后会再进行赋值(如果传入的Collection不为空)。</p> 
<pre><code class="prism language-java">ArrayBlockingQueue nonFairQueue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayBlockingQueue</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//默认非公平锁实现</span>
ArrayBlockingQueue fairQueue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayBlockingQueue</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//true表示公平锁</span>
</code></pre> 
<h3><a id="_48"></a>模拟实现生产者消费者</h3> 
<pre><code class="prism language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>zwx<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>queue<span class="token punctuation">.</span>block<span class="token punctuation">;</span>

<span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>ArrayBlockingQueue<span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ArrayBlockingQueueDemo</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{<!-- --></span>
        ArrayBlockingQueue<span class="token generics function"><span class="token punctuation">&lt;</span>Integer<span class="token punctuation">&gt;</span></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayBlockingQueue</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//默认非公平锁实现</span>
        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ConsumerThread</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ProcuctThread</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
    <span class="token keyword">class</span> <span class="token class-name">ProcuctThread</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">private</span> ArrayBlockingQueue queue<span class="token punctuation">;</span>
        <span class="token keyword">public</span> <span class="token function">ProcuctThread</span><span class="token punctuation">(</span>ArrayBlockingQueue queue<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>queue <span class="token operator">=</span> queue<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
           <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">100</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
               <span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
                   queue<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
               <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                   e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
               <span class="token punctuation">}</span>
           <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">class</span> <span class="token class-name">ConsumerThread</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">private</span> ArrayBlockingQueue queue<span class="token punctuation">;</span>
        <span class="token keyword">public</span> <span class="token function">ConsumerThread</span><span class="token punctuation">(</span>ArrayBlockingQueue queue<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>queue <span class="token operator">=</span> queue<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                <span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
                    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>queue<span class="token punctuation">.</span><span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"消费："</span> <span class="token operator">+</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre> 
<p>上面的示例中，我们先启动了消费者模式，运行之后可以发现，因为队列是空的，所以会阻塞等待生产者添加元素之后输出。</p> 
<h3><a id="_98"></a>初始化队列</h3> 
<p>首先是初始化两个Condition队列分别用于阻塞生产者和消费者线程，关于Condition队列，想详细了解的可以<a href="https://blog.csdn.net/zwx900102/article/details/106864752">点击这里</a>。<br> <img src="https://images2.imgbox.com/43/51/6xpkjLK5_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_101"></a>添加元素(生产者)</h3> 
<p>添加元素的时候，如果队列满了，就阻塞，不满则调用enque方法添加元素<br> <img src="https://images2.imgbox.com/02/2c/VF5NBN3l_o.png" alt="在这里插入图片描述"><br> 获取元素时通过内部维护的putIndex逐个往后添加元素，满了则重新从0开始<br> <img src="https://images2.imgbox.com/6d/a9/QJ70t4hQ_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_106"></a>获取元素(消费者)</h3> 
<p>首先会判断队列是不是空了，空了就阻塞，否则调用dequeue方法获取元素<br> <img src="https://images2.imgbox.com/0b/2c/Tu56Knu0_o.png" alt="在这里插入图片描述"><br> 调用dequeue方法移除元素，并唤醒添加元素线程。<br> <img src="https://images2.imgbox.com/b4/24/fVEskwgj_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="LinkedBlockingQueue_111"></a>LinkedBlockingQueue</h2> 
<p>一个由链表结构组成的有界阻塞队列,此队列按照先进先出（FIFO）的原则对元素进行排序，和ArrayBlockingQueue的区别是ArrayBlockingQueue内部维护的是一个数组，通过数组下标来维护队列，而LinkedBlockingQueue维护的是一个链表，通过Node来维护队列。还是先来看看类图关系：<br> <img src="https://images2.imgbox.com/30/d4/5e8Y8nI3_o.png" alt="在这里插入图片描述"><br> LinkedBlockingQueue依然有3个构造函数，第一个和第三个构造器最终也是会调用第二个构造器，而且默认会初始化一个Integer.MAX_VALUE大小队列，第三个构造器在初始化队列之后会进行赋值(如果传入的Collection不为空)。</p> 
<h3><a id="_115"></a>初始化队列</h3> 
<p><img src="https://images2.imgbox.com/c8/6c/0STf8Zhi_o.png" alt="在这里插入图片描述"><br> Node是LinkedBlockingQueue中的一个静态内部类：<br> <img src="https://images2.imgbox.com/a0/da/fqPFYKw3_o.png" alt="在这里插入图片描述"><br> 所以第一次初始化之后Node节点中的item是默认为null值的。初始化之后得到如下队列：<br> <img src="https://images2.imgbox.com/4d/5a/kSiCXyYi_o.png" alt="在这里插入图片描述"><br> 这个头节点也是一个哨兵，和<a href="https://blog.csdn.net/zwx900102/article/details/106864028">AQS同步队列</a>一样，设置了一个空信息的节点作为哨兵。</p> 
<h3><a id="_122"></a>添加元素(生产者)</h3> 
<p><img src="https://images2.imgbox.com/06/4a/Jdo2CXAL_o.png" alt="在这里插入图片描述"><br> 添加元素获取的是putLock，后面可以看到，获取元素获取的的takeLock，采用了读写双锁分离方式实现性能上的提升。<br> 再看下添加元素的enqueue方法：<br> <img src="https://images2.imgbox.com/44/76/D9GwOR7W_o.png" alt="在这里插入图片描述"><br> 添加元素后得到如下队列：<br> <img src="https://images2.imgbox.com/3f/08/K2MGUILC_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_129"></a>获取元素(消费者)</h3> 
<p><img src="https://images2.imgbox.com/3f/15/VLGuVlIB_o.png" alt="在这里插入图片描述"><br> 这里消费者获取的是另一把锁takeLock，这里的逻辑也应该是比较容易看懂，我们进入真正获取元素的dequeue方法：<br> <img src="https://images2.imgbox.com/19/0f/axLleXX4_o.png" alt="在这里插入图片描述"><br> 1、我们先看219行，执行之后得到如下队列：<br> <img src="https://images2.imgbox.com/35/6f/LfxU6e2W_o.png" alt="在这里插入图片描述">2、继续看221行代码，执行之后得到如下结果：<br> <img src="https://images2.imgbox.com/0d/bc/OYhlONG6_o.png" alt="在这里插入图片描述"><br> 经过这两步，其实原先的E1节点已经被移除了，那么从上图可以看到，原先旧的head节点中next还持有了当前head节点的引用，这时候根据GC的可达性算法，是无法回收的，所以需要将next的引用去掉(也就是上面218行代码的作用)，这样Node节点就没有持有其他对象的引用了，GC就可以将其当做垃圾回收掉，这个和之前在<a href="https://blog.csdn.net/zwx900102/article/details/106864028">AQS同步队列</a>以及<a href="https://blog.csdn.net/zwx900102/article/details/106864752">Condition队列</a>中做法是一个意思，都是为了取消其引用，方便GC。</p> 
<h2><a id="LinkedBlockingDeque_137"></a>LinkedBlockingDeque</h2> 
<p>LinkedBlockingDeque是和LinkedBlockingQeque一样均是由链表结构组成，也就是说内部都是通过一个Node内部类来实现聊表，而LinkedBlockingDeque是双向的阻塞队列，故而Node中肯定会比单向的多了一个prev指向前一个节点。</p> 
<p>双向队列因为多了一个操作队列的入口，所以相比较于LinkedBlockingQeque单向队列中多了addFirst、 addLast、offerFirst、offerLast、peekFirst和peekLast等方法。另外，插入方法add等同于addLast，移除方法remove等效于removeFirst，而take方法却等同于takeFirst，这些事实需要注意的，为了避免混乱，建议使用的时候还是带上First和Last关键字。<br> 首先还是来看一看类图：<br> <img src="https://images2.imgbox.com/8f/7e/NX56xw6H_o.png" alt="在这里插入图片描述"><br> 可以看出相比较于单项队列，多了一个Deque(双向)接口，构造器和单向列表一样，也是提供了3个。</p> 
<h3><a id="_144"></a>初始化队列</h3> 
<p><img src="https://images2.imgbox.com/cf/57/awYNsvge_o.png" alt="在这里插入图片描述"><br> 这里可以看到，初始化的时候没有设置任何节点，仅仅只是设置了一个容量。</p> 
<h3><a id="_147"></a>添加元素(生产者)</h3> 
<h4><a id="First_148"></a>从First添加</h4> 
<p><img src="https://images2.imgbox.com/9a/4a/YpFhpemt_o.png" alt="在这里插入图片描述"><br> 这里基本没有逻辑，主要看linkFirst(Node)方法：<br> <img src="https://images2.imgbox.com/6d/d7/cLVXR0ea_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="Last_152"></a>从Last添加</h4> 
<p><img src="https://images2.imgbox.com/d7/7a/P76NzIlC_o.png" alt="在这里插入图片描述"><br> 这个方法也是一样没有逻辑，主要看linkLast(Node)方法：<br> <img src="https://images2.imgbox.com/7d/0b/OR7ngXxk_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_156"></a>获取元素(消费者)</h3> 
<h4><a id="First_157"></a>从First获取</h4> 
<p><img src="https://images2.imgbox.com/52/60/0tEyrLVy_o.png" alt="在这里插入图片描述"><br> 继续看unlinkFirst这个方法：<br> <img src="https://images2.imgbox.com/ec/bc/QtbvP1P0_o.png" alt="在这里插入图片描述"><br> 这些逻辑和上面的单向队列是差不多的，只是多了一个prev指向</p> 
<h4><a id="Last_162"></a>从Last获取</h4> 
<p><img src="https://images2.imgbox.com/ad/3a/AtQvnIMq_o.png" alt="在这里插入图片描述"><br> 继续看unlinkLast()方法：<br> <img src="https://images2.imgbox.com/3a/32/HYzL41jA_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="_166"></a>总结</h2> 
<p>本文主要讲述了Java提供的7种队列中的其中三种队列，这三种队列实现方式比较接近，而且源码比较容易理解。<br> 想要了解PriorityBlockingQueue,DelayQueue的，请<a href="https://blog.csdn.net/zwx900102/article/details/107127982">点击这里</a>。<br> 想要了解SynchronousQueue，LinkedTransferQueue的，可以<a href="https://blog.csdn.net/zwx900102/article/details/107210498">点击这里</a>。</p> 
<p><strong><font color="red">请关注我，和孤狼一起学习进步</font></strong>。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/965f256f8aaf4d35b09a1084a2724c38/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">java为什么调用接口，就可以调用到接口的实现类的方法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a97e16ce58fbf5147b7a63f4d9daebcb/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">055 《Python极简讲义：一本书入门数据分析与机器学习》读后感</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>