<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Android 代码质量管理 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Android 代码质量管理" />
<meta property="og:description" content="前言 “任何一个傻瓜都能写出计算机可以理解的代码，唯有写出人类容易理解的代码，才是优秀的程序员。”
代码不仅仅是人类和计算机沟通的语言，它也是建立在程序员之间的桥梁，两个程序员在沟通的时候，任何富有表达力的言语都不如直接阅读对方一段代码。
代码也是公司的一笔特殊财富，因为它不可能永远被同一个程序员维护，如果代码的可读性很差的话，很可能导致这笔财富无法传承下来，前功尽弃。
具有良好可读性的代码能让功能的扩展和BUG的修复更顺利，增加新功能、修改某个BUG都需要你首先理解代码。
所以，提高代码质量是很有必要的，本文将介绍个人在实践中认为能够提高代码质量的方法，希望对大家有所帮助。
理想和现实 软件缺陷 世上本没有BUG
随着功能的增加，便有了BUG
老的BUG改了，可能引入新的BUG
事实： 我们的软件，在发布前，其实就已经百病缠身了。
烂代码的伤害 1. 不利于其他同事维护和更新2. 维护、时间成本的增加3. 无法传承下去，维护成本比重新开发成本更高。 软件发布后的情形： 0、领导：这次发布的版本BUG太多了，客户天天往我手机打电话，你们在搞什么东西？
1、项目经理：加班、加班、加班，都留下来给我加班 （把地给我扫干净！）
2、程序员：丧失工作热情 （我们一个个都是怀揣着梦想进入公司的，结果待了2年，发现并不是这么美好。
我常听到程序员说：哎，我们的代码就是一坨X。X是一种什么样的状态，你们懂的。
都说写代码是艺术，有人说，我怎么感觉像蓝领，没啥技术含量呢？）
3、结果：频繁跳槽 （其实是被动跳槽，代码不敢维护下去了，随便一个小改动都会引来新的问题……于是从一个火坑跳进了另一个更大的火坑。）
发现、修改和预防烂代码 疑问1：我们如何发现烂代码？
多看网上的大神写的代码，看多了自然就有识别的能力了。
疑问2：烂代码要不要改呢？应该怎么改？
但愿客户不要发现……不影响功能，反正用户也看不到，不要改了时间来不及了，我们下个版本再说吧 疑问3：如果烂代码不是先天性的，那是不是可以预防？
没有好的方式去预防。
制约程序员编写高质量代码的因素 1. 对需求和设计的理解不透彻
2. 对软件业务流程不熟悉
3. 没有开发经验，不知道怎样的代码是好的
4. 对开发工具或开发语言不熟悉
5. 缺少监督体系或不重视质量评估
6. 受情绪因素的影响等因素
7. 其它非代码因素也起着关键作用
- 对于一些经验丰富的编程人员，他们是知道怎么写代码是最好的，最有效率的，但是为什么他们写出的代码也很烂呢？—— 破窗效应
好代码的特性 可读性可维护性 可变更性 正确性 可读性 重视开发规范
1. 代码整洁、类、变量、方法命名规则2. 代码样式，缩进与换行3. 多写注释 可维护性 方法清晰，容易理解函数不要超过100行 类不要超过1000行不要硬编码 定义常量或配置文件修改常用属性 保持代码简洁 函数越短小越好 可变更性 代码复用，减少冗余。适当的利用23种设计模式 多人开发可以采用MVP或者其他开发模式。 设计原则 ① 单一职责，一个类或者一个方法只做一样事情。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/3444d8d16cc0cb1c340311be16fda306/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-04-25T09:49:18+08:00" />
<meta property="article:modified_time" content="2018-04-25T09:49:18+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Android 代码质量管理</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>前言</h2> 
<p>“任何一个傻瓜都能写出计算机可以理解的代码，唯有写出人类容易理解的代码，才是优秀的程序员。”</p> 
<p> </p> 
<p> 代码不仅仅是人类和计算机沟通的语言，它也是建立在程序员之间的桥梁，两个程序员在沟通的时候，任何富有表达力的言语都不如直接阅读对方一段代码。</p> 
<p>代码也是公司的一笔特殊财富，因为它不可能永远被同一个程序员维护，如果代码的可读性很差的话，很可能导致这笔财富无法传承下来，前功尽弃。</p> 
<p>具有良好可读性的代码能让功能的扩展和BUG的修复更顺利，增加新功能、修改某个BUG都需要你首先理解代码。</p> 
<p>所以，提高代码质量是很有必要的，本文将介绍个人在实践中认为能够提高代码质量的方法，希望对大家有所帮助。</p> 
<p> </p> 
<p> </p> 
<p> </p> 
<h3><strong>理想和现实</strong></h3> 
<p> </p> 
<p> <img alt="" src="https://images2.imgbox.com/98/9e/BRSKnPkc_o.png"></p> 
<p> </p> 
<h3><strong>软件缺陷</strong></h3> 
<p> </p> 
<p>         <img alt="" src="https://images2.imgbox.com/52/ad/P7OgPJon_o.png"></p> 
<p>             世上本没有BUG</p> 
<p>    随着功能的增加，便有了BUG</p> 
<p>    老的BUG改了，可能引入新的BUG</p> 
<p> </p> 
<p>    事实： 我们的软件，在发布前，其实就已经百病缠身了。</p> 
<p> </p> 
<p> </p> 
<h3><strong>烂代码的伤害</strong></h3> 
<h3> </h3> 
<ul><li>1. 不利于其他同事维护和更新</li><li>2. 维护、时间成本的增加</li><li>3. 无法传承下去，维护成本比重新开发成本更高。</li></ul> 
<p> </p> 
<h4><strong>软件发布后的情形：</strong></h4> 
<p>0、领导：这次发布的版本BUG太多了，客户天天往我手机打电话，你们在搞什么东西？</p> 
<p>1、项目经理：加班、加班、加班，都留下来给我加班 （把地给我扫干净！）</p> 
<p>2、程序员：丧失工作热情 （我们一个个都是怀揣着梦想进入公司的，结果待了2年，发现并不是这么美好。</p> 
<p>我常听到程序员说：哎，我们的代码就是一坨X。X是一种什么样的状态，你们懂的。</p> 
<p>都说写代码是艺术，有人说，我怎么感觉像蓝领，没啥技术含量呢？）</p> 
<p>3、结果：频繁跳槽 （其实是被动跳槽，代码不敢维护下去了，随便一个小改动都会引来新的问题……于是从一个火坑跳进了另一个更大的火坑。）</p> 
<p> </p> 
<p> </p> 
<p> </p> 
<h3><strong>发现、修改和预防烂代码</strong></h3> 
<p>疑问1：我们如何发现烂代码？</p> 
<p> </p> 
<p>    多看网上的大神写的代码，看多了自然就有识别的能力了。</p> 
<p>疑问2：烂代码要不要改呢？应该怎么改？</p> 
<p> </p> 
<ul><li>但愿客户不要发现……</li><li>不影响功能，反正用户也看不到，不要改了</li><li>时间来不及了，我们下个版本再说吧</li></ul> 
<p> </p> 
<p>疑问3：如果烂代码不是先天性的，那是不是可以预防？</p> 
<p>     没有好的方式去预防。</p> 
<p> </p> 
<p> </p> 
<h3><strong>制约程序员编写高质量代码的因素</strong></h3> 
<p><strong> </strong></p> 
<p>1. <strong>对需求和设计的理解不透彻</strong></p> 
<p>2. <strong>对软件业务流程不熟悉</strong></p> 
<p>3. <strong>没有开发经验，不知道怎样的代码是好的</strong></p> 
<p>4. <strong>对开发工具或开发语言不熟悉</strong></p> 
<p>5. <strong>缺少监督体系或不重视质量评估</strong></p> 
<p>6. <strong>受情绪因素的影响等因素</strong></p> 
<p>7. <strong>其它非代码因素也起着关键作用</strong></p> 
<p>    - 对于一些经验丰富的编程人员，他们是知道怎么写代码是最好的，最有效率的，但是为什么他们写出的代码也很烂呢？—— 破窗效应</p> 
<p> </p> 
<h3><strong>好代码的特性</strong></h3> 
<p> </p> 
<ul><li> 可读性</li><li>可维护性</li><li> 可变更性</li><li> 正确性</li></ul> 
<p> </p> 
<p> </p> 
<h3><strong>可读性</strong></h3> 
<p><strong>重视开发规范</strong></p> 
<p> </p> 
<ul><li>1. 代码整洁、类、变量、方法命名规则</li><li>2. 代码样式，缩进与换行</li><li>3. 多写注释</li></ul> 
<h3><strong>可维护性</strong></h3> 
<p> </p> 
<ul><li> 方法清晰，容易理解</li><li>函数不要超过100行</li><li> 类不要超过1000行</li><li>不要硬编码</li><li> 定义常量或配置文件修改常用属性</li><li> 保持代码简洁</li><li> 函数越短小越好</li></ul> 
<p> </p> 
<h3><strong>可变更性</strong></h3> 
<p> </p> 
<ul><li>代码复用，减少冗余。</li><li>适当的利用23种设计模式</li><li> 多人开发可以采用MVP或者其他开发模式。</li><li> 设计原则</li></ul> 
<p>            ① 单一职责，一个类或者一个方法只做一样事情。</p> 
<p>            ② 不要面向实现编程，要面向接口编程。</p> 
<p>            ③ 抽取封装共同代码，减少代码冗余。</p> 
<p>            ④ 代码尽量做到对修改关闭，对扩展开放。</p> 
<p> </p> 
<h3><strong>重构</strong></h3> 
<p>    所谓重构(refactoring)是这样一个过程：在不改变代码外在行为的前提下，对代码做出修改。</p> 
<p>    重构并不是重写，重构可以改进程序的内部结构，从而提高代码体的可维护性。</p> 
<p>    <strong>重构的好处：</strong></p> 
<p> </p> 
<ul><li>            改进代码美观度</li><li>             快捷寻找BUG</li><li>            提高开发速度</li><li>            改进源码可读性</li><li>            增加程序的可扩展性</li></ul> 
<p> </p> 
<p> </p> 
<p>     一般来说有以下三种场景，可以重构： </p> 
<ul><li>         添加功能时重构 </li><li>         修补错误时重构 </li><li>         复审代码时重构 </li></ul> 
<p> </p> 
<p>        项目完成后养成重构代码习惯，不仅能减少以后的维护成本，还能对这次项目的经验进行总结。</p> 
<p>    自身的编程能力也能得到相应的提高。</p> 
<p> </p> 
<p> </p> 
<h3><strong>设计模式</strong></h3> 
<p>    设计模式（Design Pattern）是一套被反复使用、多数人知晓的、经过分类的、代码设计经验的总结。使用设计模式的目的：为了代码可重用性、让代码更容易被他人理解、保证代码可靠性。 设计模式使代码编写真正工程化；设计模式是软件工程的基石脉络，如同大厦的结构一样。</p> 
<p> </p> 
<h3><strong>其他提高代码质量的方式</strong></h3> 
<p> </p> 
<ul><li>代码评审</li></ul> 
<h2>模板方法-基类封装</h2> 
<p>   Activity和Fragment应该是Android最常用的组件，对他进行简单的封装对提高代码的简洁性也有很大的帮助。</p> 
<p> </p> 
<ul><li><strong>BaseActivity ：</strong></li></ul> 
<pre class="has"><code class="language-java">public abstract class BaseActivity extends FragmentActivity {
	
	@Override
	protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		init();
		findViews();
		initData();
		setListener();
		setting();
	}
	
	/**
	 * 获得上下文
	 * @return Context
	 */
	public Context getContext(){
		return this;
	}
	
	/**
	 * 始化参数
	 */
	public abstract void init();
	/**
	 * 查找所有的控件
	 */
	public abstract void findViews();
	/**
	 * 初始化页面数据
	 */
	public abstract void initData();
	/**
	 * 设置控件的监听事件
	 */
	public abstract void setListener();
	
	/**
	 * 后续参数设置
	 */
	public abstract void setting();

}</code></pre> 
<p> </p> 
<ul><li><strong>BaseFragment :</strong></li></ul> 
<pre class="has"><code class="language-java">public abstract class BaseFragment extends Fragment {


	@Override
	public void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
	}

	@Override
	public void onStart() {
		super.onStart();
		init();
		findViews();
		initData();
		setListener();
		setting();
	}

	public Context getContext() {
		return getActivity();
	}

	public abstract void init();

	public abstract void findViews();

	public abstract void initData();

	public abstract void setListener();

	public abstract void setting();

}</code></pre> 
<p>代码比较简单，用到了<strong>模板设计模式</strong>，一个方法只做一样事情，初始化的就只做初始化操作，设置监听的就只设置监听。不管多少个Activity<strong>\</strong>Fragment都能很好的统一化编码风格，看起来更清晰不乱。</p> 
<p> </p> 
<h2>Fragment简单管理</h2> 
<p>下面先看看标准的创建和管理Fragment。</p> 
<pre class="has"><code class="language-java">	private void showFragment(){
		FragmentTransaction fragmentTransaction = getSupportFragmentManager().beginTransaction();
		hideFragment(fragmentTransaction);
		if (mFragment1== null) {
			mFragment1 = new MyFragment1(context);
			fragmentTransaction.add(R.id.content, mFragment1);
			fragmentTransaction.commit();
		} else {
			fragmentTransaction.show(mFragment1);
			fragmentTransaction.commit();
		}
	}</code></pre> 
<p>每次创建一个Fragment都要复制一边这个方法，代码冗余、不利于维护和更新。</p> 
<p>下面封装一下</p> 
<pre class="has"><code class="language-java">public class FragmentFactory {

	private FragmentActivity mContext;
	private static FragmentFactory factory = new FragmentFactory();
	//用于存储已创建的Fragment对象
	private Map&lt;String, Fragment&gt; mFragmentMap=new HashMap&lt;&gt;();
	private int mLayoutId;

	private FragmentFactory() {
	}

	public static FragmentFactory getInstance() {
		return factory;
	}

	//layoutId 传入布局文件的id
	public FragmentFactory init(FragmentActivity context,int layoutId) {
		this.mContext = context;
		this.mLayoutId=layoutId;
		return factory;
	}

	public Activity getParentActivity() {
		return mContext;
	}

	
	private &lt;T extends Fragment&gt; Fragment createFragment(Class&lt;T&gt; clazz) {
		Fragment fragment = null;
		try {
			fragment = getFragment(clazz.getName());
			FragmentTransaction fragmentTransaction = mContext.getSupportFragmentManager().beginTransaction();
			hideFragment(fragmentTransaction);
			if (fragment == null) {

				fragment = (Fragment) clazz.newInstance();
				setFragment(fragment);
				fragmentTransaction.add(mLayoutId, fragment);
				fragmentTransaction.commit();
			} else {
				fragmentTransaction.show(fragment);
				fragmentTransaction.commit();
			}
		} catch (InstantiationException e) {
			e.printStackTrace();
		} catch (IllegalAccessException e) {
			e.printStackTrace();
		}
		return fragment;
	}

	private &lt;T extends Fragment&gt; Fragment getFragment(String className) {
		Fragment fragment = mFragmentMap.get(className);
		return fragment;
	}

	private &lt;T extends Fragment&gt; void setFragment(Fragment fragment) throws InstantiationException, IllegalAccessException {
		String className = fragment.getClass().getName();
		mFragmentMap.put(className, fragment);
	}

	private void hideFragment(FragmentTransaction fragmentTransaction) {
		Set&lt;String&gt; keySet = mFragmentMap.keySet();
		for (String key : keySet) {
			Fragment fragment = mFragmentMap.get(key);
			fragmentTransaction.hide(fragment);
		}
		
	}
	
	public &lt;T extends Fragment&gt; T showFragment(Class&lt;T&gt; clazz) {
		return (T) createFragment(clazz);
	}
}
</code></pre> 
<p> </p> 
<p><strong>调用代码：</strong></p> 
<p> </p> 
<pre class="has"><code class="language-java">FragmentFactory mFragmentFactory = FragmentFactory.getInstance().init(this, R.id.fl_content);
mFragmentFactory.showFragment(MyFragment1.class);
mFragmentFactory.showFragment(MyFragment2.class);</code></pre> 
<p>上面的封装用到了泛型、工厂、单例等知识。只需要在Activity初始化一次对象就可以一行代码管理Fragment了，想显示哪个页面就传入对应的Fragment的class。</p> 
<p> </p> 
<h2>简单通用的适配器</h2> 
<p>ListView是Android最常用的一个组件，优化Litsview那就是必不可少的工作了。</p> 
<p>用Listview最痛苦的就是写BaseAdapter的getView()方法，一遍又一遍的写，大部分代码都是重复冗余，但又不得不写。下面来抽取冗余的代码封装起来。</p> 
<pre class="has"><code class="language-html">public abstract class CommonAdapter&lt;T&gt; extends BaseAdapter {
    //需要显示的数据，List中的类型为泛型，因为不知道用户的封装Bean
    private List&lt;T&gt; mDatas;
    
    private Context mContext;
    //布局文件Id
    private int mLayoutId;
    public CommonAdapter(Context context,List&lt;T&gt; data,int layoutId) {
        mDatas = data;
        mContext = context;
        mLayoutId = layoutId;
    }
    @Override
    public int getCount() {
        return mDatas.size();
    }

    @Override
    public Object getItem(int position) {
        return mDatas.get(position);
    }

    @Override
    public long getItemId(int position) {
        return position;
    }

    @Override
    public View getView(int position, View convertView, ViewGroup parent) {
        ViewHolder holder = ViewHolder.getHolder(mContext,convertView, parent, mLayoutId);
        setDatas(holder,getItem(position));
        return holder.getConvertView();
    }

    /**
     * 为各个item中的控件设置数据
     * @param holder   ViewHolder
     * @param object  从集合中所取的一个对象
     */
    public abstract void setDatas(ViewHolder holder, Object object);
}</code></pre> 
<pre class="has"><code class="language-html">public class ViewHolder {
    private View mConvertView;
    //用来存布局中的各个组件，以键值对形式
    private HashMap&lt;Integer,View&gt; mViews = new HashMap&lt;&gt;();
    //ViewHolder构造函数，只有当convertView为空的时候才创建
    public ViewHolder(Context context,View convertView, ViewGroup parent, int layouId) {
        convertView = LayoutInflater.from(context).inflate(layouId,parent,false);
        convertView.setTag(this);       //将其setTag()
        mConvertView = convertView;
    }
    //返回一个ViewHolder对象
    public static ViewHolder getHolder(Context context, View convertView, ViewGroup parent, int layoutId) {
        if (convertView == null) {
            return new ViewHolder(context,convertView,parent,layoutId);
        }else {
            return (ViewHolder) convertView.getTag();
        }
    }
    //返回一个View的子类对象，因为不确定用户布局有什么组件，相当于findViewById
    //这里返回一个泛型，也可以返回一个View或Object
    public &lt;T extends View&gt;T getView(int resId) {
        View view = mViews.get(resId);  //从集合中取出这个组件
        if (view == null) {         //如果为空，说明为第一屏
            view = mConvertView.findViewById(resId);    //从convertView中找
            mViews.put(resId,view);     
        }
        return (T) view;
    }

    public View getConvertView() {
        return mConvertView;
    }
}</code></pre> 
<p><strong>调用代码：</strong></p> 
<pre class="has"><code class="language-java">public class MyAdapter extends CommonAdapter&lt;Bean&gt; {
    public MyAdapter(Context context, List&lt;Bean&gt; data, int layoutId) {
        super(context, data, layoutId);
    }
    @Override
    public void setDatas(ViewHolder holder, Object object) {
        Bean bean = (Bean) object;
        ((TextView)holder.getView(R.id.title_Tv)).setText(bean.getTitle());
        ((TextView)holder.getView(R.id.desc_Tv)).setText(bean.getDesc());
        ((TextView)holder.getView(R.id.time_Tv)).setText(bean.getTime());
        ((TextView)holder.getView(R.id.phone_Tv)).setText(bean.getPhone());
    }
}</code></pre> 
<pre class="has"><code class="language-java">    List&lt;Bean&gt; data=new ArrayList&lt;&gt;();
    Bean bean=new Bean("标题1", "内容1", "时间1", "18300000000");
    Bean bean2=new Bean("标题2", "内容2", "时间2", "18300000000");
    data.add(bean);
    data.add(bean2);
    listView.setAdapter(new MyAdapter(context, data, R.layout.listview_item));</code></pre> 
<p>注释写的很清楚了，就不多说了。</p> 
<p> </p> 
<h2>自定义组合控，布局模块化</h2> 
<p>    正常的项目开发中肯定有很多布局冗余例如下面图红框中的设置和导航。</p> 
<p> </p> 
<p><img alt="" src="https://images2.imgbox.com/52/64/lxwo0n37_o.png" width="300"><img alt="" src="https://images2.imgbox.com/9d/0c/5p6hmiQc_o.png" width="300"></p> 
<p>                            图1                                                        图2</p> 
<p>很多人会把这些布局文件一遍又一遍的复制，只修改其中的ID、字符串等，其他部分几乎一模一样，造成布局文件代码特别多。</p> 
<p>最要命的不是这个，而且把所有的逻辑写在Activity\Fragment里，造成Activity\Fragment特别的庞大，真正实现一坨X代码。</p> 
<p>我觉得应该把公用的布局单独抽取出来到一个xml里，再用一个GroupView去处理这些逻辑和业务，减少activity\Fragment的负担。</p> 
<p>代码就不贴了，自己去源码demo里查看<strong>ParamSwitchView，</strong>这个View是图1的一个Item，封装了布局和所需要的遥控按键左右切换数据的逻辑。</p> 
<p> </p> 
<h2>面向接口编程</h2> 
<p>   </p> 
<p>    面向接口编程的意思是指在面向对象的系统中所有的类或者模块之间的交互是由接口完成的。</p> 
<p>    父类的引用指向子类对象，指向不同的子类对象，产生不同的行为：   </p> 
<p>         父 a =new 子A;</p> 
<p> </p> 
<p>有很多童靴在项目开发中经常更变业务，例如：定制化系统应用，底层的接口在不同型号的TV\手机上都有可能不一样。</p> 
<p>这时候把这些底层接口单独封装在一个类进行管理，在平台发生改变的时候只需要改变实现。</p> 
<p><strong>定义接口类统一化管理方法</strong></p> 
<pre class="has"><code class="language-java">public interface IManager {
	
	void setBackLight(int value);
	void setPictureMode(int mode);

}</code></pre> 
<p><strong>实现类 1</strong></p> 
<pre><code>public class HuaWeiManager implements IManager {
	
	@Override
	public void setBackLight(int value) {
		<strong>HuaWei</strong>.savaBackLight(value);
	}

	@Override
	public void setPictureMode(int mode) {
		<strong>HuaWei</strong>.setPictureMode(mode);
	}

}</code><strong>HuaWei</strong>.savaBackLight(value);
	}

	@Override
	public void setPictureMode(int mode) {
		<strong>HuaWei</strong>.setPictureMode(mode);
	}

}</pre> 
<pre> </pre> 
<p>假如现在业务需求是华为的定制系统，只需要调用华为的子类</p> 
<pre class="has"><code class="language-java">IManager iManager=new HuaWeiManager();
iManager.setBackLight(100);</code></pre> 
<p>如果业务需求转变成小米，那么只需要创建一个类进行实现</p> 
<p><strong>实现类 2</strong></p> 
<pre class="has"><code class="language-java">public class XiaoMiManager implements IManager {
	
	@Override
	public void setBackLight(int value) {
		XiaoMi.savaBackLight(value);
	}

	@Override
	public void setPictureMode(int mode) {
		XiaoMi.setPictureMode(mode);
	}

}</code></pre> 
<p>调用代码里只需要把HuaWeiManager改成XiaoMiManager就能适配其他机型了。</p> 
<pre class="has"><code class="language-java">	//IManager iManager=new HuaWeiManager();
	IManager iManager=new XiaoMiManager();
	iManager.setBackLight(100);</code></pre> 
<p>在这里只是灌输一个编码思维，实际开发中突发情况比较多，并不一定全部适用。</p> 
<p>在编码之前一定要花一点点时间简单构思和组织一下代码，不要想到什么写什么。</p> 
<p> </p> 
<h2>注重工具类的封装</h2> 
<p>    我们正常的开发中经常用到很多不需要在逻辑层编写的方法，我们就可以单独的把他抽取出来放在单独的类里面去单独管理。</p> 
<p>     例如：Toast 、SharePreference、获取时间、系统版本、网络、MD5等等。。。。</p> 
<p>   这些东西都可以单独的封装和管理，减少逻辑层的代码，并且也可以让其他逻辑层调用。</p> 
<p><strong>坏习惯</strong></p> 
<p>        有些人喜欢把定义个Tools这样的工具类，里面存放着所有的工具方法。</p> 
<p>       1. 网络、Toast、状态、时间等等全部都用一个类去管理，这样造成的后果就是后期不方便维护和不利于更新，代码看起来杂乱无章。</p> 
<p>        2. 把一些公共的方法直接在逻辑层构建，其他地方需要就直接复制一份过去。</p> 
<p>            或者有其他相同的比较类似的方法没有进行封装，在其他地方直接复制过去只修改其他一行的代码。</p> 
<p><strong>好习惯</strong></p> 
<p><strong>    1. </strong>把这些tools单独创建各种各样的tools去存放这些方法，Toast只存Toast相关的，网络只存网络相关的，避免交杂在一起。也符合设计原则之一的：单一原则。</p> 
<p>    2. 类似的方法独立抽取出来，用传参flag标记去区分应用场景。</p> 
<p> </p> 
<p>源码里收藏了一些常用的工具类分享给大家。</p> 
<h2> </h2> 
<p> </p> 
<p> </p> 
<h2>MVP分层架构</h2> 
<p>    去年写了一篇关于它的文章，大家可以看看。能够让代码变得异常的清晰。</p> 
<p>    https://blog.csdn.net/u012999130/article/details/70173245</p> 
<p><strong> 上面说了那么多，只是一些基本的理论，下面是分享一点平时开发中比较实在的东西。</strong></p> 
<h3><strong><a href="https://blog.csdn.net/u012999130/article/details/80061033">点击打开链接</a></strong></h3> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/781a801131165578dfbbd01d4697201a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">面试题（一）——互联网公司面试题整理</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/2ae1329a8099db16c4cbfc4cb5d1b2f9/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">java.math.BigDecimal类multiply的使用</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>