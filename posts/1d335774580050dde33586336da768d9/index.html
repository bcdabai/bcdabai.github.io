<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java 设计者模式以及与Spring关系(四) 代理模式 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Java 设计者模式以及与Spring关系(四) 代理模式" />
<meta property="og:description" content="目录
简介:
23设计者模式以及重点模式
代理模式（Proxy Pattern）
静态代理示例
spring中应用
动态代理
1.基于JDK的动态代理
target.getClass().getInterfaces()作用
内名内部类写法(更简洁，但不推荐)
2.基于CGLIB实现
spring中应用
简介: 本文是个系列一次会出两个设计者模式作用，如果有关联就三个，除此外还会讲解在spring中作用。
23设计者模式以及重点模式 我们都知道设计者模式有3类23种设计模式，标红是特别重要的设计者模式建议都会，而且熟读于心，标蓝是指其次重要建议也要明白。
（1）创建型模式：单例模式、抽象工厂模式、构建者模式、工厂模式、原型模式。
（2）结构型模式：适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式。
（3）行为型模式：访问者模式、模版方法模式、命令模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式、状态模式、策略模式、职责链模式。
代理模式（Proxy Pattern） 代理模式是一种结构型设计模式，它通过提供一个替代对象（代理）来控制对另一个对象的访问。代理对象与原始对象实现相同的接口，这使得代理可以站在原始对象的位置被客户端使用，同时代理还可以在访问原始对象前后执行额外的操作，例如访问控制、延迟初始化、日志记录、监控等。
代理模式分为两类，常说的一般是动态代理。
类型：
静态代理：手动创建代理类。 使用场景：在程序创建之前，代理类创建好的，代理目标是明确的可以使用静态代理。
动态代理：在运行时动态创建代理类，Java 中可通过 Proxy 类和 InvocationHandler 接口实现。 使用场景：让编程人员在不修改对象代码的情况下，为这个对象添加额外的功能或者限制
静态代理示例 主要就是给金士顿的U盘算完各种折扣后75给淘宝，淘宝全都加25卖给客户，业务就是这个业务。
卖U盘的接口，定义一个U盘卖多少钱
制作优盘厂商实现类
代理类，淘宝类，在内部实现类中创建目标类对象引用，引用调用目标类方法，实现静态代理
自己进行购买
spring中应用 不知道你看出来了吗，这个像不像是我们spring框架中一个实现类调用另一个实现类方法。
动态代理 如果目标类很多呢，只是静态代理，那么需要创建的代理类就很多，比如上面的卖u盘例子，本来淘宝只卖金士顿，但是来个叫李帅帅的U盘厂家，但其实你只想想给这两个厂家做一样统一逻辑操作，比如还是加25块钱卖出去，这是就需要写第二个静态代理类，但如果有100个商品呢，这时就需要使用动态代理统一加载。
动态代理有两种实现方式
1.基于JDK的动态代理 目标类
动态代理类
method.invoke(target,args) 可以看做target.method(args)
实现类调用
target.getClass().getClassLoder() 得到目标类的实现类的类加载器
target.getClass().getInterfaces()它能够获得所实现这个对象的接口。其实这个接口不一定是目标类实现的接口，你看mybatis实现源码，接口就是任意接口。但是你要保证这第二个参数是个接口。
target.getClass().getInterfaces()作用 如果不懂这块的可以看看我这块，懂就略过
内名内部类写法(更简洁，但不推荐) 方法抽取放在一个别的类中方便使用
2.基于CGLIB实现 动态代理有两种实现方式，一种是上述jdk的，核心是需要动态代理的目标类必须有接口还有一种是基于外部第三方类库的cglib,创建代理对象cglib不要求实现类也就是目标类去实现接口，cglib核心要求是继承目标类不能是finall。
cglib 经常被应用在框架中，例如 Spring，Hibernat 等。cglib的代理效率高于 Jdk。对于 cglib 一般的开发中并不使用。做了一个了解就可以。
引入Jar包
&lt;!--引入cglib依赖--&gt;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/1d335774580050dde33586336da768d9/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-22T17:42:55+08:00" />
<meta property="article:modified_time" content="2024-01-22T17:42:55+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java 设计者模式以及与Spring关系(四) 代理模式</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="-toc" style="margin-left:40px;"></p> 
<p id="%E7%AE%80%E4%BB%8B%3A-toc" style="margin-left:40px;"><a href="#%E7%AE%80%E4%BB%8B%3A" rel="nofollow">简介:</a></p> 
<p id="23%E8%AE%BE%E8%AE%A1%E8%80%85%E6%A8%A1%E5%BC%8F%E4%BB%A5%E5%8F%8A%E9%87%8D%E7%82%B9%E6%A8%A1%E5%BC%8F-toc" style="margin-left:80px;"><a href="#23%E8%AE%BE%E8%AE%A1%E8%80%85%E6%A8%A1%E5%BC%8F%E4%BB%A5%E5%8F%8A%E9%87%8D%E7%82%B9%E6%A8%A1%E5%BC%8F" rel="nofollow">23设计者模式以及重点模式</a></p> 
<p id="%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%EF%BC%88Proxy%20Pattern%EF%BC%89-toc" style="margin-left:40px;"><a href="#%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%EF%BC%88Proxy%20Pattern%EF%BC%89" rel="nofollow">代理模式（Proxy Pattern）</a></p> 
<p id="%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E7%A4%BA%E4%BE%8B-toc" style="margin-left:80px;"><a href="#%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E7%A4%BA%E4%BE%8B" rel="nofollow">静态代理示例</a></p> 
<p id="spring%E4%B8%AD%E5%BA%94%E7%94%A8-toc" style="margin-left:160px;"><a href="#spring%E4%B8%AD%E5%BA%94%E7%94%A8" rel="nofollow">spring中应用</a></p> 
<p id="%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86-toc" style="margin-left:80px;"><a href="#%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86" rel="nofollow">动态代理</a></p> 
<p id="1.%E5%9F%BA%E4%BA%8EJDK%E7%9A%84%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86-toc" style="margin-left:160px;"><a href="#1.%E5%9F%BA%E4%BA%8EJDK%E7%9A%84%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86" rel="nofollow">1.基于JDK的动态代理</a></p> 
<p id="target.getClass().getInterfaces()%E4%BD%9C%E7%94%A8-toc" style="margin-left:200px;"><a href="#target.getClass%28%29.getInterfaces%28%29%E4%BD%9C%E7%94%A8" rel="nofollow">target.getClass().getInterfaces()作用</a></p> 
<p id="%E5%86%85%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E5%86%99%E6%B3%95(%E6%9B%B4%E7%AE%80%E6%B4%81%EF%BC%8C%E4%BD%86%E4%B8%8D%E6%8E%A8%E8%8D%90)-toc" style="margin-left:200px;"><a href="#%E5%86%85%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E5%86%99%E6%B3%95%28%E6%9B%B4%E7%AE%80%E6%B4%81%EF%BC%8C%E4%BD%86%E4%B8%8D%E6%8E%A8%E8%8D%90%29" rel="nofollow">内名内部类写法(更简洁，但不推荐)</a></p> 
<p id="-toc" style="margin-left:160px;"></p> 
<p id="-toc" style="margin-left:160px;"></p> 
<p id="2.%E5%9F%BA%E4%BA%8ECGLIB%E5%AE%9E%E7%8E%B0-toc" style="margin-left:160px;"><a href="#2.%E5%9F%BA%E4%BA%8ECGLIB%E5%AE%9E%E7%8E%B0" rel="nofollow">2.基于CGLIB实现</a></p> 
<p id="spring%E4%B8%AD%E5%BA%94%E7%94%A8-toc" style="margin-left:160px;"><a href="#spring%E4%B8%AD%E5%BA%94%E7%94%A8" rel="nofollow">spring中应用</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h3 id="%E7%AE%80%E4%BB%8B%3A" style="text-align:justify;"><strong>简介:</strong></h3> 
<p style="text-align:left;"><span style="color:#333333;">本文是个系列一次会出两个设计者模式作用，如果有关联就三个，除此外还会讲解在spring中作用。</span></p> 
<h4 id="23%E8%AE%BE%E8%AE%A1%E8%80%85%E6%A8%A1%E5%BC%8F%E4%BB%A5%E5%8F%8A%E9%87%8D%E7%82%B9%E6%A8%A1%E5%BC%8F" style="text-align:justify;"><strong>23设计者模式以及重点模式</strong></h4> 
<p style="text-align:left;"><span style="color:#333333;">我们都知道</span><span style="color:#333333;">设计者模式</span><span style="color:#333333;">有</span><span style="color:#333333;">3</span><span style="color:#333333;">类</span><span style="color:#333333;">23</span><span style="color:#333333;">种设计模式，标红是特别重要的设计者模式建议都会，而且熟读于心，标蓝是指其次重要建议也要明白。</span></p> 
<p style="text-align:justify;">（1）创建型模式：<span style="color:#ff0000;">单例模式</span>、<span style="color:#ff0000;">抽象工厂模式</span>、<span style="color:#ff0000;">构建者模式</span>、<span style="color:#ff0000;">工厂模式</span>、<span style="color:#0070c0;">原型模式</span>。</p> 
<p style="text-align:justify;">（2）结构型模式：<span style="color:#ff0000;">适配器模式</span>、桥接模式、<span style="color:#ff0000;">装饰模式</span>、组合模式、外观模式、享元模式、<span style="color:#ff0000;">代理模式</span>。</p> 
<p style="text-align:justify;">（3）行为型模式：访问者模式、<span style="color:#0070c0;">模版方法模式</span>、<span style="color:#0070c0;">命令模式、迭代器模式</span>、<span style="color:#ff0000;">观察者模式</span>、中介者模式、备忘录模式、解释器模式、状态模式、<span style="color:#ff0000;">策略模式</span>、职责链模式。</p> 
<p style="text-align:justify;"><img alt="" height="259" src="https://images2.imgbox.com/0b/f0/z6wJYeVo_o.png" width="553"></p> 
<p style="text-align:justify;"></p> 
<h3 id="%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%EF%BC%88Proxy%20Pattern%EF%BC%89" style="text-align:justify;">代理模式（Proxy Pattern）</h3> 
<p>代理模式是一种结构型设计模式，它通过提供一个替代对象（代理）来控制对另一个对象的访问。代理对象与原始对象实现相同的接口，这使得代理可以站在原始对象的位置被客户端使用，同时代理还可以在访问原始对象前后执行额外的操作，例如访问控制、延迟初始化、日志记录、监控等。</p> 
<p>代理模式分为两类，常说的一般是动态代理。</p> 
<p><strong>类型：</strong></p> 
<ul><li><strong>静态代理</strong>：手动创建代理类。</li></ul> 
<p style="margin-left:0pt;text-align:justify;">使用场景：在程序创建之前，代理类创建好的，代理目标是明确的可以使用静态代理。</p> 
<ul><li><strong>动态代理</strong>：在运行时动态创建代理类，Java 中可通过 <code>Proxy</code> 类和 <code>InvocationHandler</code> 接口实现。</li></ul> 
<p style="margin-left:.0001pt;text-align:justify;">使用场景：<span style="background-color:#ffffff;"><span style="color:#404040;">让编程人员在不修改对象代码的情况下，为这个对象添加额外的功能或者限制</span></span></p> 
<h4 id="%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E7%A4%BA%E4%BE%8B" style="margin-left:.0001pt;text-align:justify;">静态代理示例</h4> 
<p>主要就是给金士顿的U盘算完各种折扣后75给淘宝，淘宝全都加25卖给客户，业务就是这个业务。</p> 
<p style="margin-left:0pt;text-align:justify;">卖U盘的接口，定义一个U盘卖多少钱</p> 
<p style="text-align:justify;"><img alt="" height="144" src="https://images2.imgbox.com/46/c0/0pFYGb6F_o.png" width="403"></p> 
<p style="margin-left:0pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">制作优盘厂商实现类</p> 
<p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="223" src="https://images2.imgbox.com/e1/64/u91uXV9O_o.png" width="554"></p> 
<p style="margin-left:.0001pt;text-align:justify;">代理类，淘宝类，在内部实现类中创建目标类对象引用，引用调用目标类方法，实现静态代理</p> 
<p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="323" src="https://images2.imgbox.com/17/34/brPBUR4S_o.png" width="554"></p> 
<p style="margin-left:0pt;text-align:justify;">自己进行购买</p> 
<p style="margin-left:0pt;text-align:justify;"><img alt="" height="218" src="https://images2.imgbox.com/07/a7/PzftETHh_o.png" width="554"></p> 
<h6 id="spring%E4%B8%AD%E5%BA%94%E7%94%A8" style="margin-left:0pt;text-align:justify;">spring中应用</h6> 
<p>不知道你看出来了吗，这个像不像是我们spring框架中一个实现类调用另一个实现类方法。</p> 
<h4 id="%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86">动态代理</h4> 
<p style="margin-left:0pt;text-align:justify;">如果目标类很多呢，只是静态代理，那么需要创建的代理类就很多，比如上面的卖u盘例子，本来淘宝只卖金士顿，但是来个叫李帅帅的U盘厂家，但其实你只想想给这两个厂家做一样统一逻辑操作，比如还是加25块钱卖出去，这是就需要写第二个静态代理类，但如果有100个商品呢，这时就需要使用动态代理统一加载。</p> 
<p style="margin-left:0pt;text-align:justify;"></p> 
<p style="margin-left:0pt;text-align:justify;">动态代理有两种实现方式</p> 
<h6 id="1.%E5%9F%BA%E4%BA%8EJDK%E7%9A%84%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86" style="margin-left:0pt;text-align:justify;">1.基于JDK的动态代理</h6> 
<p><img alt="" height="144" src="https://images2.imgbox.com/69/3c/idKzP7ev_o.png" width="403"></p> 
<p style="margin-left:0pt;text-align:justify;">目标类</p> 
<p style="text-align:justify;"><img alt="" height="240" src="https://images2.imgbox.com/10/b9/PQCnEzpH_o.png" width="645"></p> 
<p style="margin-left:0pt;text-align:justify;">动态代理类</p> 
<p style="text-align:justify;">method.invoke(target,args) 可以看做target.method(args)</p> 
<p style="text-align:justify;"><img alt="" height="438" src="https://images2.imgbox.com/48/ce/Jq61KG8Y_o.png" width="645"></p> 
<p style="margin-left:0pt;text-align:justify;">实现类调用</p> 
<p style="margin-left:0pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">t</span></span><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">arget.getClass().getClassLoder() 得到目标类的实现类的类加载器</span></span></p> 
<p style="margin-left:0pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">t</span></span><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">arget.getClass().getInterfaces()</span></span><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">它能够获得</span></span><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">所实现</span></span><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">这个对象的接口。</span></span><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">其实这个接口不一定是目标类实现的接口，你看mybatis实现源码，接口就是任意接口。但是你要保证这第二个参数是个接口。</span></span></p> 
<p><img alt="" height="378" src="https://images2.imgbox.com/5f/1e/Bl24nHi6_o.png" width="645"></p> 
<h6 id="target.getClass().getInterfaces()%E4%BD%9C%E7%94%A8" style="text-align:justify;"><strong>target.getClass().getInterfaces()作用</strong></h6> 
<p>如果不懂这块的可以看看我这块，懂就略过</p> 
<p><img alt="" height="517" src="https://images2.imgbox.com/ff/af/snTHMYna_o.png" width="645"></p> 
<p><img alt="" height="516" src="https://images2.imgbox.com/60/b8/juRNtNZH_o.png" width="645"></p> 
<p></p> 
<h6 id="%E5%86%85%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E5%86%99%E6%B3%95(%E6%9B%B4%E7%AE%80%E6%B4%81%EF%BC%8C%E4%BD%86%E4%B8%8D%E6%8E%A8%E8%8D%90)" style="margin-left:.0001pt;text-align:justify;">内名内部类写法(更简洁，但不推荐)</h6> 
<p><img alt="" height="238" src="https://images2.imgbox.com/85/e6/y12KVHT3_o.png" width="481"></p> 
<p><img alt="" height="188" src="https://images2.imgbox.com/a8/5d/iR78x2ta_o.png" width="645"></p> 
<p><img alt="" height="378" src="https://images2.imgbox.com/ec/5d/BCxtbaJ7_o.png" width="646"></p> 
<p style="margin-left:0pt;text-align:justify;">方法抽取放在一个别的类中方便使用</p> 
<p><img alt="" height="407" src="https://images2.imgbox.com/91/06/WenBcZYj_o.png" width="646"></p> 
<h6></h6> 
<h6></h6> 
<h6 id="2.%E5%9F%BA%E4%BA%8ECGLIB%E5%AE%9E%E7%8E%B0">2.基于CGLIB实现</h6> 
<p style="margin-left:0pt;text-align:justify;">        动态代理有两种实现方式，一种是上述jdk的，核心是需要动态代理的目标类必须有接口还有一种是基于外部第三方类库的cglib,创建代理对象cglib不要求实现类也就是目标类去实现接口，cglib核心要求是继承目标类不能是finall。</p> 
<p style="margin-left:0pt;text-align:justify;">        cglib 经常被应用在框架中，例如 Spring，Hibernat 等。cglib的代理效率高于 Jdk。对于 cglib 一般的开发中并不使用。做了一个了解就可以。</p> 
<p style="margin-left:0pt;text-align:justify;"></p> 
<p style="margin-left:0pt;text-align:justify;">引入Jar包</p> 
<blockquote> 
 <p style="text-align:left;"><span style="background-color:#ffffff;"><em><span style="background-color:#ffffff;"><span style="color:#8c8c8c;">&lt;!--</span></span></em><em><span style="background-color:#ffffff;"><span style="color:#8c8c8c;">引入</span></span></em><em><span style="background-color:#ffffff;"><span style="color:#8c8c8c;">cglib</span></span></em><em><span style="background-color:#ffffff;"><span style="color:#8c8c8c;">依赖</span></span></em><em><span style="background-color:#ffffff;"><span style="color:#8c8c8c;">--&gt;</span></span></em><br><span style="background-color:#ffffff;"><span style="color:#080808;">&lt;</span></span><span style="background-color:#ffffff;"><span style="color:#0033b3;">dependency</span></span><span style="background-color:#ffffff;"><span style="color:#080808;">&gt;</span></span><br><span style="background-color:#ffffff;"><span style="color:#080808;">    &lt;</span></span><span style="background-color:#ffffff;"><span style="color:#0033b3;">groupId</span></span><span style="background-color:#ffffff;"><span style="color:#080808;">&gt;cglib&lt;/</span></span><span style="background-color:#ffffff;"><span style="color:#0033b3;">groupId</span></span><span style="background-color:#ffffff;"><span style="color:#080808;">&gt;</span></span><br><span style="background-color:#ffffff;"><span style="color:#080808;">    &lt;</span></span><span style="background-color:#ffffff;"><span style="color:#0033b3;">artifactId</span></span><span style="background-color:#ffffff;"><span style="color:#080808;">&gt;cglib&lt;/</span></span><span style="background-color:#ffffff;"><span style="color:#0033b3;">artifactId</span></span><span style="background-color:#ffffff;"><span style="color:#080808;">&gt;</span></span><br><span style="background-color:#ffffff;"><span style="color:#080808;">    &lt;</span></span><span style="background-color:#ffffff;"><span style="color:#0033b3;">version</span></span><span style="background-color:#ffffff;"><span style="color:#080808;">&gt;2.1_2&lt;/</span></span><span style="background-color:#ffffff;"><span style="color:#0033b3;">version</span></span><span style="background-color:#ffffff;"><span style="color:#080808;">&gt;</span></span><br><span style="background-color:#ffffff;"><span style="color:#080808;">&lt;/</span></span><span style="background-color:#ffffff;"><span style="color:#0033b3;">dependency</span></span><span style="background-color:#ffffff;"><span style="color:#080808;">&gt;</span></span></span></p> 
</blockquote> 
<p><img alt="" height="233" src="https://images2.imgbox.com/5e/c6/MjAZyCTR_o.png" width="645"></p> 
<p></p> 
<h6>spring中应用</h6> 
<p>在 Spring 框架中，代理模式被广泛用于实现 AOP（面向切面编程），例如在事务管理和安全控制中。</p> 
<p style="margin-left:0pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">------------------------------------------与正文内容无关------------------------------------<br> 如果觉的文章写对各位读者老爷们有帮助的话，麻烦点赞加关注呗！作者在这拜谢了!</p> 
<p style="margin-left:.0001pt;text-align:justify;">混口饭吃了！如果你需要Java 、Python毕设、网页和系统设计，还有你是刚入职的新手需要度过试用期。请在关注私信我，本人看到一定马上回复！</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f2ee45653a86e0816d04859e51448764/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Python学习笔记--数值与字符串</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a642a89b2bd78180ff5ae88a77367175/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">MySQL 索引优化：深入探索自适应哈希索引的奥秘</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>