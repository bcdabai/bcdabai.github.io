<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据结构与算法 | 第五章：二叉树 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="数据结构与算法 | 第五章：二叉树" />
<meta property="og:description" content="本文参考网课为 数据结构与算法 1 第五章二叉树，主讲人 张铭 、王腾蛟 、赵海燕 、宋国杰 、邹磊 、黄群。
本文使用IDE为 Clion，开发环境 C&#43;&#43;14。
更新：2023 / 12 / 17
数据结构与算法 | 第五章：二叉树 树概念术语递归定义分类二叉树基本形态分类满二叉树（ Full Binary Tree ）完全二叉树（ Complete Binary Tree ）扩充二叉树（ Extended Binary Tree ） 二叉树性质结点数目与层次关系不同类型结点间关系结点数目与深度/高度关系 二叉树抽象数据类型二叉树结点抽象数据类型二叉树抽象数据类型 二叉树遍历深度优先遍历应用表达式二叉树 算法递归算法非递归算法前序遍历示例中序遍历示例后序遍历示例 时间、空间代价分析 广度优先遍历时间、空间代价分析 二叉树存储顺序存储链式存储寻找父节点以递归框架寻找以非递归框架寻找 空间代价分析 应用二叉搜索树概念操作检索示例时间、空间代价分析 插入示例时间、空间代价分析 删除示例时间、空间代价分析 堆与优先队列概念定义建堆筛选法理论代码实现时间代价分析 堆的相关操作插入理论代码实现时间代价分析 删除理论代码实现时间代价分析 堆的应用 Huffman树及其应用编码Huffman编码定义 Huffman解码 应用正确性证明引理定理 编码效率 参考链接 先回顾一下线性结构与非线性结构的主要区别：
线性结构
线性结构中的元素满足线性关系，每个内部元素有且仅有一个前驱结点、一个后继结点。非线性结构
至少存在一个数据元素，具有两个或两个以上的前驱或者后继。
根据前驱结点数目是否有限制，非线性结构可以进而分为树结构和图结构。 树结构
前驱唯一，后继不限 包含 n (n&gt;=0) 个结点的有穷集合E，E上定义了一个满足以下条件关系r：
有且仅有一个称为树根（root）的结点er ∈ E，在关系r下没有前驱；除结点 er 外，E中所有结点对于关系r来说都有且仅有一个前驱；除结点 er 外，对任何结点 e ∈ E，都存在一个结点序列 er，e1，…，es，使得er 就是树根，且 es = e，有序对&lt;ei-1，ei&gt; ∈ r (1 &lt;= i &lt;= s)；该结点序列称为从根到结点e的一条路径（path） 图结构" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/8227b915a3e30f5213c19ebed0e67d2c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-17T18:23:38+08:00" />
<meta property="article:modified_time" content="2023-12-17T18:23:38+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据结构与算法 | 第五章：二叉树</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-github-gist">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>本文参考网课为 <code>数据结构与算法</code> <sup class="footnote-ref"><a href="#fn1" rel="nofollow" id="fnref1">1</a></sup> 第五章二叉树，主讲人 张铭 、王腾蛟 、赵海燕 、宋国杰 、邹磊 、黄群。</p> 
<p>本文使用IDE为 <code>Clion</code>，开发环境 <code>C++14</code>。</p> 
<p>更新：2023 / 12 / 17</p> 
<hr> 
<p></p> 
<div class="toc"> 
 <h4>数据结构与算法 | 第五章：二叉树</h4> 
 <ul><li><a href="#_28" rel="nofollow">树</a></li><li><ul><li><a href="#_29" rel="nofollow">概念</a></li><li><ul><li><a href="#_30" rel="nofollow">术语</a></li><li><a href="#_70" rel="nofollow">递归定义</a></li><li><a href="#_86" rel="nofollow">分类</a></li><li><ul><li><a href="#_87" rel="nofollow">二叉树</a></li><li><ul><li><a href="#_101" rel="nofollow">基本形态</a></li><li><a href="#_108" rel="nofollow">分类</a></li><li><ul><li><a href="#_Full_Binary_Tree__109" rel="nofollow">满二叉树（ Full Binary Tree ）</a></li><li><a href="#_Complete_Binary_Tree__119" rel="nofollow">完全二叉树（ Complete Binary Tree ）</a></li><li><a href="#_Extended_Binary_Tree__136" rel="nofollow">扩充二叉树（ Extended Binary Tree ）</a></li></ul> 
     </li></ul> 
    </li></ul> 
   </li></ul> 
   </li><li><a href="#_149" rel="nofollow">二叉树性质</a></li><li><ul><li><a href="#_150" rel="nofollow">结点数目与层次关系</a></li><li><a href="#_172" rel="nofollow">不同类型结点间关系</a></li><li><a href="#_203" rel="nofollow">结点数目与深度/高度关系</a></li></ul> 
   </li><li><a href="#_214" rel="nofollow">二叉树抽象数据类型</a></li><li><ul><li><a href="#_233" rel="nofollow">二叉树结点抽象数据类型</a></li><li><a href="#_262" rel="nofollow">二叉树抽象数据类型</a></li></ul> 
   </li><li><a href="#_285" rel="nofollow">二叉树遍历</a></li><li><ul><li><a href="#_297" rel="nofollow">深度优先遍历</a></li><li><ul><li><a href="#_323" rel="nofollow">应用</a></li><li><ul><li><a href="#_324" rel="nofollow">表达式二叉树</a></li></ul> 
     </li><li><a href="#_334" rel="nofollow">算法</a></li><li><ul><li><a href="#_344" rel="nofollow">递归算法</a></li><li><a href="#_386" rel="nofollow">非递归算法</a></li><li><ul><li><a href="#_387" rel="nofollow">前序遍历</a></li><li><a href="#_394" rel="nofollow">示例</a></li><li><a href="#_453" rel="nofollow">中序遍历</a></li><li><a href="#_460" rel="nofollow">示例</a></li><li><a href="#_524" rel="nofollow">后序遍历</a></li><li><a href="#_534" rel="nofollow">示例</a></li></ul> 
     </li></ul> 
     </li><li><a href="#_608" rel="nofollow">时间、空间代价分析</a></li></ul> 
    </li><li><a href="#_624" rel="nofollow">广度优先遍历</a></li><li><ul><li><a href="#_629" rel="nofollow">时间、空间代价分析</a></li></ul> 
   </li></ul> 
   </li><li><a href="#_642" rel="nofollow">二叉树存储</a></li><li><ul><li><a href="#_658" rel="nofollow">顺序存储</a></li><li><a href="#_676" rel="nofollow">链式存储</a></li><li><ul><li><a href="#_716" rel="nofollow">寻找父节点</a></li><li><ul><li><a href="#_717" rel="nofollow">以递归框架寻找</a></li><li><a href="#_737" rel="nofollow">以非递归框架寻找</a></li></ul> 
     </li><li><a href="#_764" rel="nofollow">空间代价分析</a></li></ul> 
   </li></ul> 
   </li><li><a href="#_792" rel="nofollow">应用</a></li><li><ul><li><a href="#_795" rel="nofollow">二叉搜索树</a></li><li><ul><li><a href="#_796" rel="nofollow">概念</a></li><li><a href="#_812" rel="nofollow">操作</a></li><li><ul><li><a href="#_819" rel="nofollow">检索</a></li><li><ul><li><a href="#_829" rel="nofollow">示例</a></li><li><a href="#_843" rel="nofollow">时间、空间代价分析</a></li></ul> 
      </li><li><a href="#_848" rel="nofollow">插入</a></li><li><ul><li><a href="#_858" rel="nofollow">示例</a></li><li><a href="#_869" rel="nofollow">时间、空间代价分析</a></li></ul> 
      </li><li><a href="#_876" rel="nofollow">删除</a></li><li><ul><li><a href="#_893" rel="nofollow">示例</a></li><li><a href="#_898" rel="nofollow">时间、空间代价分析</a></li></ul> 
     </li></ul> 
    </li></ul> 
    </li><li><a href="#_909" rel="nofollow">堆与优先队列</a></li><li><ul><li><a href="#_910" rel="nofollow">概念</a></li><li><a href="#_941" rel="nofollow">定义</a></li><li><a href="#_967" rel="nofollow">建堆</a></li><li><ul><li><a href="#_968" rel="nofollow">筛选法</a></li><li><ul><li><a href="#_969" rel="nofollow">理论</a></li><li><a href="#_1019" rel="nofollow">代码实现</a></li><li><a href="#_1045" rel="nofollow">时间代价分析</a></li></ul> 
     </li></ul> 
     </li><li><a href="#_1071" rel="nofollow">堆的相关操作</a></li><li><ul><li><a href="#_1072" rel="nofollow">插入</a></li><li><ul><li><a href="#_1073" rel="nofollow">理论</a></li><li><a href="#_1091" rel="nofollow">代码实现</a></li><li><a href="#_1119" rel="nofollow">时间代价分析</a></li></ul> 
      </li><li><a href="#_1127" rel="nofollow">删除</a></li><li><ul><li><a href="#_1132" rel="nofollow">理论</a></li><li><a href="#_1170" rel="nofollow">代码实现</a></li><li><a href="#_1204" rel="nofollow">时间代价分析</a></li></ul> 
     </li></ul> 
     </li><li><a href="#_1212" rel="nofollow">堆的应用</a></li></ul> 
    </li><li><a href="#Huffman_1222" rel="nofollow">Huffman树及其应用</a></li><li><ul><li><a href="#_1223" rel="nofollow">编码</a></li><li><ul><li><a href="#Huffman_1258" rel="nofollow">Huffman编码</a></li><li><ul><li><a href="#_1280" rel="nofollow">定义</a></li></ul> 
      </li><li><a href="#Huffman_1306" rel="nofollow">Huffman解码</a></li></ul> 
     </li><li><a href="#_1323" rel="nofollow">应用</a></li><li><a href="#_1333" rel="nofollow">正确性证明</a></li><li><ul><li><a href="#_1334" rel="nofollow">引理</a></li><li><a href="#_1346" rel="nofollow">定理</a></li></ul> 
     </li><li><a href="#_1368" rel="nofollow">编码效率</a></li></ul> 
   </li></ul> 
  </li></ul> 
  </li><li><a href="#_1397" rel="nofollow">参考链接</a></li></ul> 
</div> 
<p></p> 
<hr> 
<p>先回顾一下线性结构与非线性结构的主要区别：</p> 
<ul><li>线性结构<br> 线性结构中的元素满足线性关系，每个内部元素有且仅有一个前驱结点、一个后继结点。</li><li>非线性结构<br> 至少存在一个数据元素，具有两个或两个以上的前驱或者后继。<br> 根据前驱结点数目是否有限制，非线性结构可以进而分为树结构和图结构。 
  <ul><li>树结构<br> 前驱唯一，后继不限</li></ul> </li></ul> 
<blockquote> 
 <p>包含 n (n&gt;=0) 个结点的有穷集合E，E上定义了一个满足以下条件关系r：</p> 
 <ul><li>有且仅有一个称为树根（root）的结点e<sub>r</sub> ∈ E，在关系r下没有前驱；</li><li>除结点 e<sub>r</sub> 外，E中所有结点对于关系r来说都有且仅有一个前驱；</li><li>除结点 e<sub>r</sub> 外，对任何结点 e ∈ E，都存在一个结点序列 e<sub>r</sub>，e<sub>1</sub>，…，e<sub>s</sub>，使得e<sub>r</sub> 就是树根，且 e<sub>s</sub> = e，有序对&lt;e<sub>i-1</sub>，e<sub>i</sub>&gt; ∈ r (1 &lt;= i &lt;= s)；该结点序列称为从根到结点e的一条路径（path）</li></ul> 
</blockquote> 
<ul><li>图结构<br> 前驱不限，后继不限</li></ul> 
<hr> 
<h2><a id="_28"></a>树</h2> 
<h3><a id="_29"></a>概念</h3> 
<h4><a id="_30"></a>术语</h4> 
<ul><li>结点（ <code>Node</code> ） 
  <ul><li>根结点（ <code>root</code> ）<br> 唯一没有前驱结点的结点</li><li>父结点（ <code>parent</code> ）<br> 若 &lt;e, e‘&gt; ∈ r，则称 e 是 e’ 的父结点，e’ 是 e 的子结点</li><li>子结点（ <code>children</code> ）</li></ul> </li><li>兄弟（ <code>Sibling</code> ）<br> 若 &lt;e, e’&gt;，&lt;e, e’‘&gt; ∈ r，则 e’ 和 e’’ 互称为兄弟</li><li>分支结点（ <code>branch</code> / <code>internal node</code> ）、叶结点（ <code>leaf</code> / <code>external node</code> ）<br> 根据结点是否有子结点，可以将结点区分为分支结点和叶结点。 
  <ul><li>叶结点 / 外部节点 / 终端结点：没有子树的结点</li><li>分支结点 / 内部结点 / 非终端结点</li></ul> </li><li>边（ <code>edge</code> ）<br> 两个结点组成的有序对 &lt;e，e’&gt;</li><li>路径（ <code>path</code> ）、路径长度 
  <ul><li>根结点 e<sub>r</sub> 外的 e，存在一条从根结点 e<sub>r</sub> 到e的路径</li><li>路径长度：构成路径的边的数目</li></ul> </li><li>祖先（ <code>ancestor</code> ）、后代（ <code>desendant</code> ） 
  <ul><li>存在由 e<sub>a</sub> 到 e<sub>d</sub> 的路径，则称 e<sub>a</sub> 为 e<sub>d</sub> 的祖先，e<sub>d</sub> 为 e<sub>a</sub> 的子孙</li></ul> </li><li>结点的度数（ <code>degree</code> ）、层数（ <code>levels</code> ） 
  <ul><li>结点度数：拥有子树的数目</li><li>结点层数：根节点层数为0，其他结点所在层数为其父结点层数+1</li></ul> </li><li>树的深度（ <code>depth</code> ）、高度（ <code>height</code> ） 
  <ul><li>树的深度：结点的最大层数</li><li>树的高度：深度+1</li></ul> </li></ul> 
<p>以下面的树结构示例来进一步理解这些术语的含义：<br> <img src="https://images2.imgbox.com/43/2b/SH5BABrS_o.png" alt="在这里插入图片描述" width="350"><br> A 为根结点（ <code>root node</code> ）<br> B 是 D和E的父结点（ <code>parent node</code> ），D和E是B的子结点（ <code>children node</code> ）<br> D 是E的兄弟结点（ <code>sibling node</code> ）<br> D、E、F、G 和 I 是叶结点（ <code>external node</code> 或者 <code>leaf node</code> ）<br> A、B、C、H 是分支结点（ <code>internal node</code> ）<br> C结点的度数（ <code>degree</code> ）是3<br> E结点的层数是2，I结点的层数是3<br> 树的深度是3，高度是4</p> 
<br> 
<h4><a id="_70"></a>递归定义</h4> 
<p>树是包含 <code>n</code>（ <code>n&gt;=0</code> ）个结点的有限集合 <code>T</code>。<br> 非空 <code>T</code> 满足：</p> 
<ul><li>有且仅有一个特别标出称作根的结点（e<sub>r</sub>）</li><li>e<sub>r</sub> 之外结点被分成 m 个（m&gt;=0）不相交的集合T<sub>1</sub>，T<sub>2</sub>，…，T<sub>m</sub>，其中T<sub>k</sub>（0&lt;=k&lt;=m）为树。T<sub>1</sub>，T<sub>2</sub>，…，T<sub>m</sub> 称作根（e<sub>r</sub>）的子树</li></ul> 
<p>例如，<br> <img src="https://images2.imgbox.com/1b/52/Nmurfzd8_o.png" alt="在这里插入图片描述" width="250"><br> A是根节点，BD、CEFGHI、JK分别为一颗子树。</p> 
<p>只包含1个结点的树必然仅由根结点组成。<br> 包含 n&gt;1 个结点的树借助于少于n个结点的树来定义。<br> 不包含任何结点的树称为空树。</p> 
<br> 
<h4><a id="_86"></a>分类</h4> 
<h5><a id="_87"></a>二叉树</h5> 
<p>一颗 <code>二叉树</code> 是由结点的有限集合来构成：</p> 
<ul><li>或为空的 <code>二叉树</code></li><li>或由一个根结点和 1或者2颗 不相交的分别称作这个根的左子树（ <code>left subtree</code> ）和右子树（ <code>right subtree</code> ）的 <code>二叉树</code> 组成<br> 每个结点至多两颗子树，且有左右之分，不能随意交换<br> 即使结点只有一颗子树也须明确是左子树还是右子树</li></ul> 
<p>例如，<br> <img src="https://images2.imgbox.com/28/e8/0ZPM9Ynp_o.png" alt="在这里插入图片描述" width="210"><br> 对于根结点A，BD是A的左子树，CEFGHI是A的右子树；<br> 对于根结点C，EG是C的左子树，FHI是C的右子树；</p> 
<br> 
<h6><a id="_101"></a>基本形态</h6> 
<p><code>二叉树</code> 拥有以下几种基本形态，<br> <img src="https://images2.imgbox.com/7a/89/pXFx6QzI_o.png" alt="在这里插入图片描述" width="350"><br> ( c ) 右空 和 ( d ) 左空 是两颗不同的 <code>二叉树</code>，但作为 <code>树</code> 则是相同的。<code>二叉树</code> 的概念与术语与 <code>树</code> 的基本相同。</p> 
<br> 
<h6><a id="_108"></a>分类</h6> 
<h6><a id="_Full_Binary_Tree__109"></a>满二叉树（ Full Binary Tree ）</h6> 
<p>一颗 <code>二叉树</code> 中的结点，要么为 <code>叶结点</code>，或恰有两颗非空子树，那么我们称这样的一颗 <code>二叉树</code> 为 <code>满二叉树</code>（ <code>Full Binary Tree</code> ）。</p> 
<p>例如，<br> <img src="https://images2.imgbox.com/fe/92/OjRinX5w_o.png" alt="在这里插入图片描述" width="150"><br> B、F、G、H、I均为叶结点<br> A、C、D、E都恰好有两个子结点，即满二叉树</p> 
<br> 
<h6><a id="_Complete_Binary_Tree__119"></a>完全二叉树（ Complete Binary Tree ）</h6> 
<p>一颗 <code>二叉树</code> 最多只有最下面两层的结点度数可以小于2，并且，最下面一层的结点都集中在该层最左边的若干位置上，那么我们称这样的一颗 <code>二叉树</code> 为 <code>完全二叉树</code>（ <code>Complete Binary Tree</code> ）。</p> 
<p>例如，<br> <img src="https://images2.imgbox.com/ae/5a/MHzxOjAv_o.png" alt="在这里插入图片描述" width="180"><br> ABCDEF是一颗 <code>完全二叉树</code></p> 
<p>再例如，<br> <img src="https://images2.imgbox.com/79/92/Fw1WEXD7_o.png" alt="在这里插入图片描述" width="200"><br> ABCDEFGHIJL不是一颗 <code>完全二叉树</code>，因为L没有集中到最左边的位置上。</p> 
<p><code>完全二叉树</code> 的特点如下：</p> 
<ul><li>叶结点只可能在层次最大的两层出现；</li><li>根结点到各结点的路径长度总和在具有同样数目结点的二叉树中达到了最小，即，任何一颗二叉树中根节点到各节点的最长路径一定不短于结点数目相同的完全二叉树中的路径长度；</li></ul> 
<br> 
<h6><a id="_Extended_Binary_Tree__136"></a>扩充二叉树（ Extended Binary Tree ）</h6> 
<p>给定一颗 <code>二叉树</code>，我们可以通过替换该 <code>二叉树</code> 中的 <code>空子树</code> 为 <code>空叶结点</code> 来扩充成一颗 <code>扩充二叉树</code>：</p> 
<ul><li>对于不满的分支结点<br> 增加1个 <code>空叶结点</code></li><li>对于叶结点<br> 增加2个 <code>空叶结点</code></li></ul> 
<p>例如，<br> <img src="https://images2.imgbox.com/c5/50/sgU7o3t4_o.png" alt="在这里插入图片描述" width="250"><br> 将1、4、7这3个原本度数为1的不满的分支结点在它相应的位置上扩充1个 <code>空叶结点</code>，将2、5、8、10这4个叶结点给扩充2个相应的 <code>空叶结点</code>，那么就得到了如上图所示的一个 <code>扩充二叉树</code>。</p> 
<br> 
<h3><a id="_149"></a>二叉树性质</h3> 
<h4><a id="_150"></a>结点数目与层次关系</h4> 
<p>性质1：非空二叉树的第 <code>i</code>（ <code>i&gt;=0</code> ）层至多有 2<sup>i</sup> 个结点</p> 
<p>证明：</p> 
<ol><li>归纳基础：i=0，结点数 1 = 2<sup>0</sup>；</li><li>归纳假设：假设对于所有的 j（0&lt;=j&lt;=i），命题成立，即，j 层结点数至多有 2<sup>j</sup>；</li><li>归纳结论：对于 i = j+1，结点数至多为 2 * 2<sup>j</sup> = 2<sup>j+1</sup></li></ol> 
<p>基于该性质，我们可以计算一个给定高度的 <code>二叉树</code> 中结点数目的范围，例如：<br> <img src="https://images2.imgbox.com/f9/86/6q4cWjnV_o.png" alt="在这里插入图片描述" width="350"><br> 对于如上图所示的一个深度为3、高度为4的 <code>二叉树</code>，它的结点个数的取值范围在 4 ~ 15（2<sup>0</sup>+2<sup>1</sup>+2<sup>2</sup>+2<sup>3</sup>）之间。</p> 
<hr> 
<p>性质2：深度为k的二叉树至多有 2<sup>k+1</sup>-1 个结点（ k&gt;=0 ）</p> 
<p>证明：假设第 i 层上的最大结点个数为 m<sub>i</sub>，由性质1可知，深度为k的 <code>二叉树</code> 中最大的结点个数。</p> 
<p><img src="https://images2.imgbox.com/39/86/k1cnfMoV_o.png" alt="在这里插入图片描述" width="280"></p> 
<br> 
<h4><a id="_172"></a>不同类型结点间关系</h4> 
<p>性质3：一颗 <code>二叉树</code> 中度为 <code>0</code> 的结点数目 n<sub>0</sub> 比度为2的结点数目 n<sub>2</sub>多1，即 n<sub>0</sub> = n<sub>2</sub> + 1。</p> 
<p>证明：n<sub>0</sub>，n<sub>1</sub>，n<sub>2</sub> 分别表示 n 个结点中度为0、1、2的结点数，则有 n = n0 + n1 + n2 （1）<br> 若用e表示树的边数，则有 n=e+1（除了根结点以外，其他结点都有一条与父结点之间的边存在，所以我们有树中结点数目等于树的边数+1）<br> 边均由度为1和2的结点射出，故有e=n1+2<em>n2，即，<br> n = e + 1 = n1 + 2</em>n2 + 1 （2）<br> 由（1）和（2）得，<br> n0 + n1 + n2 = n1 + 2 * n2 + 1<br> 即，n0 = n2 + 1</p> 
<hr> 
<p>性质4：满二叉树定理：非空满二叉树的叶结点数目为其分支结点数+1。</p> 
<p>证明：设 <code>二叉树</code> 结点数为n，其中叶结点数为m、分支结点数为b，则有<br> n（总结点数）= m（叶）+ b（分支） （1）<br> 因为每个分支恰有2个子结点（满），故有2*b条边；n个结点，故<br> n - 1 = 2b （2）<br> 所以，由（1）和（2）可以得到 n-1 = m+b-1 = 2b，即<br> m（叶）= b（分支）+1</p> 
<hr> 
<p>性质5：满二叉树定理推论：一个非空二叉树的空子树数目等于其结点数+1。<br> 证明：设二叉树为T，将其所有空子树替换为叶结点，所得的扩充满二叉树为T’，亦即，T的原有结点变为T’ 的分支结点。<br> 根据满二叉树定理，T’ 的叶结点数目等于T的结点个数加1；每个新添加的叶结点对应T德一个空子树<br> 所以，T中空子树数目等于T中结点数加1。</p> 
<br> 
<h4><a id="_203"></a>结点数目与深度/高度关系</h4> 
<p>性质6：具有n个结点的完全二叉树的高度和深度分别为 log<sub>2</sub>(n+1) 和 log<sub>2</sub>(n+1) - 1<br> 证明：设其深度为k，则有<br> n = 2<sup>0</sup> + 2<sup>1</sup> + 2^2 + … + 2<sup>k-1</sup> + m<sub>k</sub> = 2<sup>k</sup> - 1 + m<sub>k</sub> （1）<br> 故 2<sup>k</sup> - 1 &lt; n &lt;= 2<sup>k+1</sup> -1 （2）<br> 2<sup>k</sup> &lt; n+1 &lt;= 2<sup>k+1</sup><br> k &lt; log<sub>2</sub>(n+1) &lt;= k+1<br> 所以 k = log<sub>2</sub>(n+1) - 1</p> 
<br> 
<h3><a id="_214"></a>二叉树抽象数据类型</h3> 
<p>在明确了 <code>二叉树</code> 的逻辑结构和 <code>二叉树</code> 的性质后，我们可以来考虑 <code>二叉树</code> 上可以实施的运算的集合，以适用于不同应用的需求。</p> 
<p>一般来说，<code>二叉树</code> 的运算有：</p> 
<ul><li>针对整棵树的运算 
  <ul><li>初始化二叉树</li><li>合并两颗二叉树</li><li>遍历（周游）二叉树</li></ul> </li><li>围绕结点的运算 
  <ul><li>访问某个节点的左子结点、右子结点、父结点</li><li>访问结点存储的数据</li></ul> </li></ul> 
<p>抽象数据类型定义了二叉树基本操作的集合，在具体应用中可根据实际情况以此为基础进行适当的扩充/删减。<br> 抽象数据类型定义的操作的具体实现与二叉树的存储相关。</p> 
<br> 
<h4><a id="_233"></a>二叉树结点抽象数据类型</h4> 
<p><code>二叉树</code> 结点的抽象数据类型，包括这个结点的数据域，以及可以有适应于不同初始条件的结点的构造函数。</p> 
<pre><code class="prism language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">BinaryTreeNode</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">friend</span> <span class="token keyword">class</span> <span class="token class-name">BinaryTreeNode</span><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token punctuation">;</span>                                             <span class="token comment">// 声明二叉树类为友元类</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    T info<span class="token punctuation">;</span>                                                                     <span class="token comment">// 二叉树结点数据域</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">BinaryTreeNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                                           <span class="token comment">// 缺省构造函数</span>
    <span class="token function">BinaryTreeNode</span><span class="token punctuation">(</span><span class="token keyword">const</span> T <span class="token operator">&amp;</span>ele<span class="token punctuation">)</span><span class="token punctuation">;</span>                                               <span class="token comment">// 给定数据的构造</span>
    <span class="token function">BinaryTreeNode</span><span class="token punctuation">(</span><span class="token keyword">const</span> T <span class="token operator">&amp;</span>ele<span class="token punctuation">,</span> BinaryTreeNode<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token operator">*</span>l<span class="token punctuation">,</span> BinaryTreeNode<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token operator">*</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 子树构造结点</span>
    T <span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>                                                            <span class="token comment">// 返回当前结点数据</span>
    BinaryTreeNode<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">*</span> <span class="token function">leftchild</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>                                       <span class="token comment">// 返回左子树</span>
    BinaryTreeNode<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">*</span> <span class="token function">rightchild</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>                                      <span class="token comment">// 返回右子树</span>
    BinaryTreeNode<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">*</span> <span class="token function">Parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                                <span class="token comment">// 返回父结点</span>
    BinaryTreeNode<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">*</span> <span class="token function">LeftSibling</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                           <span class="token comment">// 返回左兄结点</span>
    BinaryTreeNode<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">*</span> <span class="token function">RightSibling</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                          <span class="token comment">// 返回右兄结点</span>
    BinaryTreeNode<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">&amp;</span> <span class="token keyword">operator</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">const</span> BinaryTreeNode<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">&amp;</span> Node<span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment">// 重载赋值操作符</span>
    <span class="token keyword">bool</span> <span class="token function">isLeaf</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>                                                        <span class="token comment">// 判断是否为叶结点</span>
    <span class="token keyword">void</span> <span class="token function">setLeftchild</span><span class="token punctuation">(</span>BinaryTreeNode<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                      <span class="token comment">// 设置左子树</span>
    <span class="token keyword">void</span> <span class="token function">setRightchild</span><span class="token punctuation">(</span>BinaryTreeNode<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                     <span class="token comment">// 设置右子树</span>
    <span class="token keyword">void</span> <span class="token function">setValue</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>                                                <span class="token comment">// 设置数据域</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<br> 
<h4><a id="_262"></a>二叉树抽象数据类型</h4> 
<pre><code class="prism language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">BinaryTree</span><span class="token punctuation">{<!-- --></span>
<span class="token keyword">private</span><span class="token operator">:</span>
    BinaryTreeNode<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">*</span> root<span class="token punctuation">;</span>                                                            <span class="token comment">// 二叉树根节点</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">BinaryTree</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>root<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>                                                           <span class="token comment">// 构造函数</span>
    <span class="token operator">~</span><span class="token function">BinaryTree</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span><span class="token function">DeleteBinaryTree</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>                                             <span class="token comment">// 析构函数</span>
    <span class="token keyword">bool</span> <span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>                                                               <span class="token comment">// 判定二叉树是否为空树</span>
    BinaryTreeNode<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">*</span> <span class="token function">Root</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span><span class="token keyword">return</span> root<span class="token punctuation">;</span><span class="token punctuation">}</span>                                             <span class="token comment">// 返回根结点</span>

    <span class="token keyword">void</span> <span class="token function">CreateTree</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> info<span class="token punctuation">,</span> BinaryTree<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">&amp;</span> leftTree<span class="token punctuation">,</span> BinaryTree<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">&amp;</span> rightTree<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 构造新树</span>
    <span class="token keyword">void</span> <span class="token function">PreOrder</span><span class="token punctuation">(</span>BinaryTreeNode<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token operator">*</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>                                             <span class="token comment">// 前序遍历二叉树或其子树</span>
    <span class="token keyword">void</span> <span class="token function">InOrder</span><span class="token punctuation">(</span>BinaryTreeNode<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token operator">*</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>                                              <span class="token comment">// 中序遍历二叉树或其子树</span>
    <span class="token keyword">void</span> <span class="token function">PostOrder</span><span class="token punctuation">(</span>BinaryTreeNode<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token operator">*</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>                                            <span class="token comment">// 后序遍历二叉树或其子树</span>
    <span class="token keyword">void</span> <span class="token function">LevelOrder</span><span class="token punctuation">(</span>BinaryTreeNode<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token operator">*</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>                                           <span class="token comment">// 按层次遍历二叉树或其子树</span>
    <span class="token keyword">void</span> <span class="token function">DeleteBinaryTree</span><span class="token punctuation">(</span>BinaryTreeNode<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token operator">*</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>                                     <span class="token comment">// 删除二叉树或其子树</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<br> 
<h3><a id="_285"></a>二叉树遍历</h3> 
<p><code>二叉树</code> 的遍历也就是将非线性结构的 <code>二叉树</code> 线性化的过程，又成周游（ <code>traversal</code> ）。这代表着系统访问数据结构中的每个结点，使得每个结点恰好被访问且仅被访问到1次。<br> 访问是指对结点进行期望的操作，具体地操作取决于应用的需求，譬如对二叉树结点数据成员进行读、写、改等操作。</p> 
<p><code>二叉树</code> 的遍历分为：</p> 
<ul><li>深度优先（ <code>depth-first search / traversal</code>，<code>DFS</code> / <code>DFT</code>）<br> 从一个结点出发，沿着分支向尽可能深的方向进行周游</li><li>广度优先（ <code>breadth-first search / traversal</code>，<code>BFT</code> / <code>BFS</code> ）<br> 按照结点的层次，从上到下，从左到右来进行周游</li></ul> 
<br> 
<h4><a id="_297"></a>深度优先遍历</h4> 
<p><img src="https://images2.imgbox.com/e0/2d/KertE6Pi_o.png" alt="在这里插入图片描述" width="100"><br> 一颗 <code>二叉树</code> 由3部分组成：</p> 
<ul><li>根结点 <code>t</code></li><li>根结点的左子树 <code>L</code>（ <code>left child</code> ）</li><li>根结点的右子树 <code>R</code>（ <code>right child</code> ）</li></ul> 
<p>通过变换根结点的遍历顺序，可以有以下3种方案：</p> 
<ul><li><code>前序遍历</code>（ <code>preorder traversal</code> ）<br> 访问根结点 -&gt; 前序遍历左子树 -&gt; 谦虚遍历右子树<br> t -&gt; L -&gt; R</li><li><code>中序遍历</code>（ <code>inorder traversal</code> ）<br> 中序遍历左子树 -&gt; 访问根节点 -&gt; 中序遍历右子树<br> L -&gt; t -&gt; R</li><li><code>后序遍历</code>（ <code>postorder traversal</code> ）<br> 后序遍历左子树 -&gt; 后序遍历右子树 -&gt; 访问根结点<br> L -&gt; R -&gt; t</li></ul> 
<p>以下面的 <code>二叉树</code> 为例，<br> <img src="https://images2.imgbox.com/86/29/AS8kjsNG_o.png" alt="在这里插入图片描述" width="180"></p> 
<ol><li>通过 <code>前序遍历</code> 得到的序列为 A、B、D、E、G、C、F、H、I</li><li>通过 <code>中序遍历</code> 得到的序列为 D、B、G、E、A、C、H、F、I</li><li>通过 <code>后序遍历</code> 得到的序列为 D、G、E、B、H、I、F、C、A</li></ol> 
<br> 
<h5><a id="_323"></a>应用</h5> 
<h6><a id="_324"></a>表达式二叉树</h6> 
<p><img src="https://images2.imgbox.com/9c/7d/qPAvPVV1_o.png" alt="在这里插入图片描述" width="180"><br> 以上面的 <code>二叉树</code> 为例，可以以3种不同的遍历方式得到表达同一表达式的不同序列：</p> 
<ol><li>通过 <code>前序遍历</code> 得到的序列为 <code>÷-ab+cd</code>，即波兰表示法</li><li>通过 <code>中序遍历</code> 得到的序列为 <code>(a-b)/(c+d)</code>，即中缀表示</li><li>通过 <code>后序遍历</code> 得到的序列为 <code>ab-cd+÷</code>，即逆波兰表示法</li></ol> 
<br> 
<h5><a id="_334"></a>算法</h5> 
<p>实现 <code>二叉树</code> 深度优先遍历的方式有:</p> 
<ol><li>递归算法<br> 算法简洁，且当前编译系统优化效率很好</li><li>非递归算法<br> 适用于某些资源受限的应用环境<br> 但需要设置一个栈来记录尚未遍历的结点/子树，以备后续访问</li></ol> 
<br> 
<h6><a id="_344"></a>递归算法</h6> 
<p>如果是 <code>前序遍历</code>，按照以下的递归算法进行遍历：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token class-name">BinaryTree</span><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span><span class="token function">DepthOrder</span><span class="token punctuation">(</span>BinaryTreeNode<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">*</span> root<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>                                      <span class="token comment">// 前序</span>
        <span class="token function">Visit</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>                                        
        <span class="token function">DepthOrder</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span><span class="token function">leftchild</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                      <span class="token comment">// 递归访问左子树</span>
        <span class="token function">DepthOrder</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span><span class="token function">rightchild</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                     <span class="token comment">// 递归访问右子树</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>如果是 <code>中序遍历</code>，按照以下的递归算法进行遍历：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token class-name">BinaryTree</span><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span><span class="token function">DepthOrder</span><span class="token punctuation">(</span>BinaryTreeNode<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">*</span> root<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>                                      <span class="token comment">// 中序</span>
        <span class="token function">DepthOrder</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span><span class="token function">leftchild</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                      <span class="token comment">// 递归访问左子树</span>
        <span class="token function">Visit</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">DepthOrder</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span><span class="token function">rightchild</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                     <span class="token comment">// 递归访问右子树</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>如果是 <code>后序遍历</code>，按照以下的递归算法进行遍历：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token class-name">BinaryTree</span><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span><span class="token function">DepthOrder</span><span class="token punctuation">(</span>BinaryTreeNode<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">*</span> root<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>                                      <span class="token comment">// 后序</span>
        <span class="token function">DepthOrder</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span><span class="token function">leftchild</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                      <span class="token comment">// 递归访问左子树</span>
        <span class="token function">DepthOrder</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span><span class="token function">rightchild</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                     <span class="token comment">// 递归访问右子树</span>
        <span class="token function">Visit</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<br> 
<br> 
<h6><a id="_386"></a>非递归算法</h6> 
<h6><a id="_387"></a>前序遍历</h6> 
<ol><li>遇到一个结点，访问该结点，同时将其非空右子树的结点压栈；</li><li>左路下降，遍历其左子树的结点；</li><li>从栈顶弹出一个结点，访问该结点，并继续遍历其右子树的结点；</li></ol> 
<br> 
<h6><a id="_394"></a>示例</h6> 
<p><img src="https://images2.imgbox.com/d1/58/KOZOKuk4_o.png" alt="在这里插入图片描述" width="200"><br> 以上面的二叉树为例，</p> 
<p>以前序遍历的方式进行周游时，</p> 
<ol><li>从根结点A开始，A的左、右子树非空，将A的右子树C压栈并继续访问A的左子树B；<br> 前序序列：A B<br> 栈内元素：C<br> 入栈序列：C</li><li>B的左子树非空、右子树为空，没有元素进栈并继续访问B的左子树D；<br> 前序序列：A B D<br> 栈内元素：C<br> 入栈序列：C</li><li>D的左、右子树均为空，没有元素进栈并从栈顶弹出C来继续访问；<br> 前序序列：A B D C<br> 栈内元素：<br> 入栈序列：C</li><li>C的左、右子树非空，将C的右子树F压栈并继续访问C的左子树E；<br> 前序序列：A B D C E<br> 栈内元素：F<br> 入栈序列：C F</li><li>E的左子树空、右子树非空，将E的右子树G压栈并从栈顶弹出G来继续访问；<br> 前序序列：A B D C E G<br> 栈内元素：F<br> 入栈序列：C F G</li><li>F的左右子树非空，将F的右子树I压栈并继续访问F的左子树H；<br> 前序序列：A B D C E G F H<br> 栈内元素：I<br> 入栈序列：C F G I</li><li>H的左右子树均为空，没有元素进栈并从栈顶弹出I；<br> 前序序列：A B D C E G F H I<br> 栈内元素：<br> 入栈序列：C F G I</li></ol> 
<p>此时栈为空，遍历结束。</p> 
<p>用代码来实现以上描述，如下所示：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token keyword">void</span> <span class="token class-name">BinaryTree</span><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span><span class="token function">PreOrderWithoutRecursion</span><span class="token punctuation">(</span>BinaryTreeNode<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token operator">*</span>root<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>stack<span class="token punctuation">;</span>                                                                       <span class="token comment">// 使用STL中的栈</span>
    stack<span class="token operator">&lt;</span>BinaryTreeNode<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">*</span> <span class="token operator">&gt;</span> aStack<span class="token punctuation">;</span>
    BinaryTreeNode<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token operator">*</span>pointer <span class="token operator">=</span> root<span class="token punctuation">;</span>                                                      <span class="token comment">// 从根结点开始访问</span>
    aStack<span class="token punctuation">.</span><span class="token function">pull</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                                                      <span class="token comment">// 放入栈底监视哨</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>pointer<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>                                                                        <span class="token comment">// 当pointer有值，或者！aStack.empty()</span>
        <span class="token function">Visit</span><span class="token punctuation">(</span>pointer <span class="token operator">-&gt;</span> <span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                                          <span class="token comment">// 访问当前结点</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>pointer <span class="token operator">-&gt;</span> <span class="token function">rightchild</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span>                                                  <span class="token comment">// 如果当前结点的右子树非空</span>
            aStack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>pointer<span class="token operator">-&gt;</span><span class="token function">rightchild</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                             <span class="token comment">// 将右子树结点压栈</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>pointer <span class="token operator">-&gt;</span> <span class="token function">leftchild</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span>                                                   <span class="token comment">// 如果左子树非空</span>
            pointer <span class="token operator">=</span> pointer <span class="token operator">-&gt;</span> <span class="token function">leftchild</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                               <span class="token comment">// 左路下降，访问左子树结点</span>
        <span class="token keyword">else</span><span class="token punctuation">{<!-- --></span>                                                                               <span class="token comment">// 如果左子树为空</span>
            pointer <span class="token operator">=</span> aStack<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            aStack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                                                   <span class="token comment">// 栈顶元素弹出、退栈</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<br> 
<h6><a id="_453"></a>中序遍历</h6> 
<ol><li>遇到一个结点，将其压栈，并遍历其左子树；</li><li>从栈顶弹出该结点，并访问之；</li><li>右路下降，遍历其右子树的结点；</li></ol> 
<br> 
<h6><a id="_460"></a>示例</h6> 
<p><img src="https://images2.imgbox.com/ce/7e/CtnQl051_o.png" alt="在这里插入图片描述" width="200"><br> 以上面的二叉树为例，</p> 
<p>以中序遍历的方式进行周游时，</p> 
<ol><li>从根结点A开始，将A压栈；<br> 中序序列：<br> 栈内元素：A<br> 入栈序列：A</li><li>A的左子树非空，左路下降、继续访问B，将B压栈；<br> 中序序列：<br> 栈内元素：A B<br> 入栈序列：A B</li><li>B的左子树非空，左路下降、继续访问D，将D压栈；<br> 中序序列：<br> 栈内元素：A B D<br> 入栈序列：A B D</li><li>D的左、右子树均为空，没有元素入栈并弹出栈顶元素D、B；<br> 中序序列：D B<br> 栈内元素：A<br> 入栈序列：A B D</li><li>B的右子树为空，弹出栈顶元素A；<br> 中序序列：D B A<br> 栈内元素：<br> 入栈序列：A B D</li><li>A的右子树非空，右路下降、继续访问C，将C压栈；<br> 中序序列：D B A<br> 栈内元素：C<br> 入栈序列：A B D C</li><li>C的左子树非空，左路下降、继续访问E，将E压栈；<br> 中序序列：D B A<br> 栈内元素：C E<br> 入栈序列：A B D C E</li><li>E的左子树为空、右子树非空，没有元素入栈并弹出栈顶元素；右路下降、继续访问G；<br> 中序序列：D B A E<br> 栈内元素：C G<br> 入栈序列：A B D C E G</li><li>G的左、右子树均为空，没有元素入栈并弹出栈顶元素G、C；<br> 中序序列：D B A E G C<br> 栈内元素：<br> 入栈序列：A B D C E G</li><li>C的右子树非空，右路下降、继续访问F，将F压栈；<br> 中序序列：D B A E G C<br> 栈内元素：F<br> 入栈序列：A B D C E G F</li><li>F的左子树非空，左路下降、继续访问H，将H压栈；<br> 中序序列：D B A E G C<br> 栈内元素：F H<br> 入栈序列：A B D C E G F H</li><li>H的左、右子树均为空，没有元素入栈并弹出栈顶元素H、F；<br> 中序序列：D B A E G C H F<br> 栈内元素：<br> 入栈序列：A B D C E G F H</li><li>F的右子树非空，右路下降、继续访问I，将I压栈；<br> 中序序列：D B A E G C H F<br> 栈内元素：I<br> 入栈序列：A B D C E G F H I</li><li>I的左、右子树均为空，没有元素入栈并连续弹出栈顶元素2次，第1次过后栈内已无元素可弹出，即结束。<br> 中序序列：D B A E G C H F I<br> 栈内元素：<br> 入栈序列：A B D C E G F H I</li></ol> 
<br> 
<h6><a id="_524"></a>后序遍历</h6> 
<ol><li>遇到一个结点，将其压栈，并遍历其左子树；</li><li>右路下降，遍历其右子树的结点；</li><li>栈中的元素增加一个特征位，以区别栈顶弹出结点时是从其左子树（仍需遍历右子树），还是从右子树返回。</li></ol> 
<ul><li>L表示进入左子树并从其返回；</li><li>R表示进入右子树并从其返回；<br> 访问栈顶元素并弹出；</li></ul> 
<br> 
<h6><a id="_534"></a>示例</h6> 
<p><img src="https://images2.imgbox.com/bc/44/6PVX9MOd_o.png" alt="在这里插入图片描述" width="200"><br> 以上面的二叉树为例，</p> 
<p>以后序遍历的方式进行周游时，</p> 
<ol><li>从根结点A开始，将A标记为（A，L）并压栈；<br> 后序序列：<br> 栈内元素：（A，L）<br> 入栈序列：（A，L）</li><li>A的左子树非空，左路下降、继续访问B，将B标记为（B，L）并压栈；<br> 后序序列：<br> 栈内元素：（A，L）（B，L）<br> 入栈序列：（A，L）（B，L）</li><li>B的左子树非空，左路下降、继续访问D，将D标记为（D，L）并压栈；<br> 后序序列：<br> 栈内元素：（A，L）（B，L）（D，L）<br> 入栈序列：（A，L）（B，L）（D，L）</li><li>D的左子树为空，弹出栈顶元素（D，L）；此时还不能访问D，右路下降、继续访问D的右子树，将（D，R）压栈；D的右子树为空，弹出栈顶元素（D，R）；访问D；<br> 后序序列：D<br> 栈内元素：（A，L）（B，L）<br> 入栈序列：（A，L）（B，L）（D，L）（D，R）</li><li>弹出栈顶元素（B，L），此时还不能访问B，右路下降、继续访问B的右子树，将（B，R）压栈；B的右子树为空，弹出栈顶元素（B，R）；访问B；<br> 后序序列：D B<br> 栈内元素：（A，L）<br> 入栈序列：（A，L）（B，L）（D，L）（D，R）（B，R）</li><li>弹出栈顶元素（A，L），此时还不能访问A，右路下降、继续访问A的右子树，将（A，R）压栈；<br> 后序序列：D B<br> 栈内元素：（A，R）<br> 入栈序列：（A，L）（B，L）（D，L）（D，R）（B，R）（A，R）</li><li>A的右子树非空，将（C，L）压栈，左路下降、继续访问C的左子树；<br> 后序序列：D B<br> 栈内元素：（A，R）（C，L)<br> 入栈序列：（A，L）（B，L）（D，L）（D，R）（B，R）（A，R）（C，L）</li><li>C的左子树非空，左路下降、继续访问E，将E标记为（E，L）并压栈；E的左子树为空，弹出栈顶元素（E，L）；此时还不能访问E，右路下降，继续访问E的右子树，将（E，R）压栈；<br> 后序序列：D B<br> 栈内元素：（A，R）（C，L) （E，R）<br> 入栈序列：（A，L）（B，L）（D，L）（D，R）（B，R）（A，R）（C，L）(E，L) （E，R）</li><li>E的右子树非空，右路下降、继续访问G，将G标记为（G，L）并压栈；G的左子树为空，弹出栈顶元素（G，L）；此时还不能访问G，右路下降，继续访问G的右子树，将（G，R）压栈；G的右子树为空，弹出栈顶元素（G，R），访问G；E的右子树遍历完毕，弹出栈顶元素（E，R），访问E；<br> 后序序列：D B G E<br> 栈内元素：（A，R）（C，L)<br> 入栈序列：（A，L）（B，L）（D，L）（D，R）（B，R）（A，R）（C，L）(E，L) （E，R）（G，L）（G，R）</li><li>弹出栈顶元素（C，L），此时不能访问C，右路下降、继续访问C的右子树，将（C，R）压栈；<br> 后序序列：D B G E<br> 栈内元素：（A，R）(C，R)<br> 入栈序列：（A，L）（B，L）（D，L）（D，R）（B，R）（A，R）（C，L）(E，L) （E，R）（G，L）（G，R）（C，R）</li><li>C的右子树非空，将（F，L）压栈，左路下降、继续访问F的左子树；<br> 后序序列：D B G E<br> 栈内元素：（A，R）(C，R)（F，L）<br> 入栈序列：（A，L）（B，L）（D，L）（D，R）（B，R）（A，R）（C，L）(E，L) （E，R）（G，L）（G，R）（C，R）（F，L）</li><li>F的左子树非空，左路下降、继续访问H，将H标记为（H，L）并压栈；H的左子树为空，弹出栈顶元素（H，L）；此时还不能访问H，右路下降，继续访问H的右子树，将（H，R）压栈；H的右子树为空，弹出栈顶元素（H，R）；访问H；<br> 后序序列：D B G E H<br> 栈内元素：（A，R）(C，R)（F，L）<br> 入栈序列：（A，L）（B，L）（D，L）（D，R）（B，R）（A，R）（C，L）(E，L) （E，R）（G，L）（G，R）（C，R）（F，L）（H，L）（H，R）</li><li>弹出栈顶元素（F，L），此时还不能访问F，右路下降、继续访问F的右子树；将（F，R）压栈；<br> 后序序列：D B G E H<br> 栈内元素：（A，R）(C，R)（F，R）<br> 入栈序列：（A，L）（B，L）（D，L）（D，R）（B，R）（A，R）（C，L）(E，L) （E，R）（G，L）（G，R）（C，R）（F，L）（H，L）（H，R）（F，R）</li><li>F的右子树非空，右路下降、继续访问I，将I标记为（I，L）并压栈；I的左子树为空，弹出栈顶元素（I，L）；此时还不能访问I，右路下降，继续访问I的右子树，将（I，R）压栈；I的右子树为空，弹出栈顶元素（I，R），访问I；I的右子树遍历完毕，弹出栈顶元素（F，R），访问F；<br> 后序序列：D B G E H F<br> 栈内元素：（A，R）(C，R)<br> 入栈序列：（A，L）（B，L）（D，L）（D，R）（B，R）（A，R）（C，L）(E，L) （E，R）（G，L）（G，R）（C，R）（F，L）（H，L）（H，R）（F，R）（I，L）（I，R)</li><li>弹出栈顶元素（C，R），访问C；<br> 后序序列：D B G E H F C<br> 栈内元素：（A，R）<br> 入栈序列：（A，L）（B，L）（D，L）（D，R）（B，R）（A，R）（C，L）(E，L) （E，R）（G，L）（G，R）（C，R）（F，L）（H，L）（H，R）（F，R）（I，L）（I，R)</li><li>弹出栈顶元素（A，R），访问A；<br> 后序序列：D B G E H F C A<br> 栈内元素：<br> 入栈序列：（A，L）（B，L）（D，L）（D，R）（B，R）（A，R）（C，L）(E，L) （E，R）（G，L）（G，R）（C，R）（F，L）（H，L）（H，R）（F，R）（I，L）（I，R)</li></ol> 
<p>此时栈为空，遍历结束。</p> 
<br> 
<h5><a id="_608"></a>时间、空间代价分析</h5> 
<ul><li> <p>时间代价<br> 遍历具有n个结点的 <code>二叉树</code> 需要 <code>O(n)</code> 时间</p> 
  <ul><li><code>前序遍历</code> 和 <code>中序遍历</code> 中，某些结点入栈 / 出栈一次，不超过 <code>O(n)</code></li><li><code>后序遍历</code> 中，每个结点分别从左、右边各入栈 / 出栈一次 <code>O(n)</code><br> 前提是，处理各节点的时间为常数</li></ul> </li><li> <p>空间代价<br> 遍历过程中栈的最大容量与树的高度成正比</p> 
  <ul><li>最坏情况<br> 高度为n，所需空间复杂度为 <code>O(n)</code></li><li>最佳情况<br> 空间复杂度为 <code>O(logn)</code></li></ul> </li></ul> 
<br> 
<h4><a id="_624"></a>广度优先遍历</h4> 
<p><code>广度优先遍历</code> 是从 <code>二叉树</code> 的第0层（根结点）开始，自上至下逐层遍历；在同一层中，按照从左到右的顺序对结点逐一访问。</p> 
<p><img src="https://images2.imgbox.com/fd/d6/EKd2YPil_o.png" alt="在这里插入图片描述" width="200"></p> 
<h5><a id="_629"></a>时间、空间代价分析</h5> 
<ul><li> <p>时间代价<br> 每个结点都被访问且只被访问一次，时间代价为 <code>O(n)</code></p> </li><li> <p>空间代价<br> 与树的最大宽度相关</p> 
  <ul><li>最坏情况<br> <code>O(n)</code></li><li>最佳情况<br> <code>O(1)</code></li></ul> </li></ul> 
<br> 
<h3><a id="_642"></a>二叉树存储</h3> 
<p><code>二叉树</code> 的存储一般分为：</p> 
<ul><li><code>顺序存储</code><br> 用 <code>数组</code> 实现 <code>完全二叉树</code></li><li><code>链式存储</code><br> 用 <code>指针</code> 实现 <code>二叉树</code></li></ul> 
<p>根据应用的需要和 <code>二叉树</code> 的结构特点，我们可以采用不同的存储方式：</p> 
<ul><li><code>顺序存储</code><br> 当要求 <code>二叉树</code> 按紧凑结构存储，且在应用过程中二叉树的大小和形状很少发生剧烈变化时，可采用 <code>顺序存储</code> 方法 
  <ul><li>所有结点按一定的次序顺序存储到一片事先申请的连续存储单元中</li><li>适当安排结点的线性序列，使结点在序列中的相互位置反映出二叉树结构的部分信息</li><li>在结点中附加一些其他的必要信息来反映整个结构</li></ul> </li></ul> 
<br> 
<h4><a id="_658"></a>顺序存储</h4> 
<p>按照广度优先遍历的方式，即按层次顺序将一颗具有n个结点的 <code>完全二叉树</code> 的结点从 0 到 n-1 编号，得到结点的一个线性序列。如下所示：</p> 
<p><img src="https://images2.imgbox.com/bb/f2/rnSZCUGJ_o.png" alt="在这里插入图片描述" width="250"><br> 从结点编号i可推知其父结点、子结点、兄弟结点的编号：</p> 
<ul><li>当2i+1&lt;n时，其左子结点编号为2i+1，否则没有左子树；</li><li>当2i+2&lt;n时，其右子结点编号为2i+2，否则没有右子树；</li><li>当0&lt;i&lt;n时 ，其父结点编号 (i-1) / 2；</li><li>当i为偶数且0&lt;i&lt;n时，其左兄结点编号为i-1，否则没有左兄；</li><li>当I为奇数且i+1&lt;n时，其右弟结点编号为i+1，否则没有右弟；</li></ul> 
<p><img src="https://images2.imgbox.com/d3/a1/PWYldIzG_o.png" alt="在这里插入图片描述" width="600"><br> <code>完全二叉树</code> 的层次结构足以反映其结构，按层次序列顺序存储，根据结点的存储位置可计算其左、右子结点、父节点、兄弟结点的存储地址。</p> 
<p><code>完全二叉树</code> 的 <code>顺序存储</code>，在存储结构上是线性的，但依然完整的反应了 <code>二叉树</code> 的逻辑结构。</p> 
<br> 
<h4><a id="_676"></a>链式存储</h4> 
<p>树结构最自然的存储方式是 <code>链式存储</code>，不同结点随机存储在内存空间中，结点间关系用指针表示。</p> 
<p>结点的形式如下所示：<br> <img src="https://images2.imgbox.com/89/82/DhCDLhuM_o.png" alt="在这里插入图片描述" width="150"><br> 每个结点除存储结点本身的数据外，设置两个指针字段 <code>left</code> 和 <code>right</code> 分别存储其左子结点和右子结点的地址。若结点的某个子节点为空，则相应的指针应为空指针。</p> 
<p>以下面的 <code>二叉树</code> 为例，</p> 
<p><img src="https://images2.imgbox.com/2c/0e/6OIc9j86_o.png" alt="在这里插入图片描述" width="200"><br> 将上面的 <code>二叉树</code> 转换为如下所示的 <code>二叉链表</code>：</p> 
<p><img src="https://images2.imgbox.com/be/f3/At3OEfpw_o.png" alt="在这里插入图片描述" width="300"><br> <code>n</code> 个结点的 <code>二叉链表</code> 有 <code>n+1</code> 个空指针。</p> 
<p><code>链式存储</code> 的优缺点如下：</p> 
<ul><li>优点<br> 运算方便，通过指针可直接访问相关结点</li><li>缺点<br> 空指针有 <code>n+1</code> 个，存储密度低、结构性开销大</li></ul> 
<p>向 BinbaryTreeNode 类中增加两个私有数据成员，如下所示：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">private</span><span class="token operator">:</span>                                    <span class="token comment">// 增加2个私有数据成员</span>
    BinaryTreeNode<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token operator">*</span>left<span class="token punctuation">;</span>                <span class="token comment">// 指向左子树的指针</span>
    BinaryTreeNode<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token operator">*</span>right<span class="token punctuation">;</span>               <span class="token comment">// 指向右子树的指针</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token keyword">class</span> <span class="token class-name">BinaryTreeNode</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">friend</span> <span class="token keyword">class</span> <span class="token class-name">BinaryTreeNode</span><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token punctuation">;</span>         <span class="token comment">// 声明二叉树类为友元类</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    T info<span class="token punctuation">;</span>                                 <span class="token comment">// 二叉树结点数据域</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">BinaryTreeNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                       <span class="token comment">// 缺省构造函数</span>
    <span class="token function">BinaryTreeNode</span><span class="token punctuation">(</span><span class="token keyword">const</span> T <span class="token operator">&amp;</span> ele<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment">// 给定数据的构造</span>
    <span class="token function">BinaryTreeNode</span><span class="token punctuation">(</span><span class="token keyword">const</span> T <span class="token operator">&amp;</span> ele<span class="token punctuation">,</span> BinaryTreeNode<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token operator">*</span>l<span class="token punctuation">,</span> BinaryTreeNode<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token operator">*</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<br> 
<h5><a id="_716"></a>寻找父节点</h5> 
<h6><a id="_717"></a>以递归框架寻找</h6> 
<pre><code class="prism language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
BinaryTreeNode<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">*</span> <span class="token class-name">BinaryTree</span><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>
<span class="token function">Parent</span><span class="token punctuation">(</span>BinaryTreeNode<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token operator">*</span>rt<span class="token punctuation">,</span> BinaryTreeNode<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token operator">*</span>current<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    BinaryTreeNode<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token operator">*</span>tmp<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>rt <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                      <span class="token comment">// 如果根结点是NULL，返回NULL</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>current <span class="token operator">==</span> rt <span class="token operator">-&gt;</span> <span class="token function">leftchild</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> current <span class="token operator">==</span> rt <span class="token operator">-&gt;</span> <span class="token function">rightchild</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment">// 如果当前结点为根结点的左/右子树，返回rt</span>
        <span class="token keyword">return</span> rt<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tmp <span class="token operator">=</span> <span class="token function">Parent</span><span class="token punctuation">(</span>rt <span class="token operator">-&gt;</span> leftchild<span class="token punctuation">,</span> current<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> tmp<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tmp <span class="token operator">=</span> <span class="token function">Parent</span><span class="token punctuation">(</span>rt <span class="token operator">-&gt;</span> rightchild<span class="token punctuation">,</span> current<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> tmp<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<br> 
<h6><a id="_737"></a>以非递归框架寻找</h6> 
<pre><code class="prism language-cpp">BinaryTreeNode<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">*</span> <span class="token class-name">BinaryTree</span><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span><span class="token function">Parent</span><span class="token punctuation">(</span>BinaryTreeNode<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token operator">*</span>current<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>stack<span class="token punctuation">;</span>                                                                 <span class="token comment">// 使用STL中的栈</span>
    stack<span class="token operator">&lt;</span>BinaryTreeNode<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">*</span> <span class="token operator">&gt;</span> aStack<span class="token punctuation">;</span>
    BinaryTreeNode<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token operator">*</span>pointer <span class="token operator">=</span> root<span class="token punctuation">;</span>
    aStack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                                                <span class="token comment">// 栈底监视哨</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>pointer<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>                                                                  <span class="token comment">// 当pointer存在，或者，!aStack.empty()时</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>current <span class="token operator">==</span> pointer <span class="token operator">-&gt;</span> <span class="token function">leftchild</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> current <span class="token operator">==</span> pointer <span class="token operator">-&gt;</span> <span class="token function">rightchild</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment">// 若current为pointer的子结点，则返回pointer</span>
            <span class="token keyword">return</span> pointer<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>pointer <span class="token operator">-&gt;</span> <span class="token function">rightchild</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>                                          <span class="token comment">// 若右子结点非空，则右子结点入栈</span>
            aStack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>pointer <span class="token operator">-&gt;</span> <span class="token function">rightchild</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>pointer <span class="token operator">-&gt;</span> <span class="token function">leftchild</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>                                           <span class="token comment">// 若左子结点非空，则左路下降</span>
            pointer <span class="token operator">=</span> pointer <span class="token operator">-&gt;</span> <span class="token function">leftchild</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span>                                                                          <span class="token comment">// 若左子结点为空，弹出栈顶元素（退栈），poniter取栈顶</span>
            pointer <span class="token operator">=</span> aStack<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>aStack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                    
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>对于经常要回溯父节点的应用，可以增加一个指向其父节点的指针域，成为如下所示的 <code>三叉链表</code>，以提供向上访问的能力：</p> 
<p><img src="https://images2.imgbox.com/c4/57/7Axvh22p_o.png" alt="在这里插入图片描述" width="500"><br> 虽然增加一个指针域，付出了空间的代价，但是可以使得经常要去找父节点的运算变得高效。</p> 
<br> 
<h5><a id="_764"></a>空间代价分析</h5> 
<p>α + γ = 1</p> 
<ul><li>存储密度 <code>α</code><br> α = <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
         
         
           数据本身存储量 
          
         
           整个结构占用的存储量 
          
         
        
       
         \frac{数据本身存储量}{整个结构占用的存储量} 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1.2173em; vertical-align: -0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.8723em;"><span class="" style="top: -2.655em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">整个结构占用的存储量</span></span></span></span><span class="" style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span class="" style="top: -3.394em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">数据本身存储量</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.345em;"><span class=""></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span><br> 表示数据结构存储的效率。当存储空间全部用于数据本身的存储结构，存储密度即为1。存储密度越大，空间利用率越高。</li><li>结构性开销 <code>γ</code><br> γ = <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
         
         
           辅助结构存储量 
          
         
           整个结构占用的存储量 
          
         
        
       
         \frac{辅助结构存储量}{整个结构占用的存储量} 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1.2173em; vertical-align: -0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.8723em;"><span class="" style="top: -2.655em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">整个结构占用的存储量</span></span></span></span><span class="" style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span class="" style="top: -3.394em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">辅助结构存储量</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.345em;"><span class=""></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span><br> 表示实现数据结构需要占用的辅助空间。并非用于存储数据，而是保存数据结构的逻辑特性或方便运算。</li></ul> 
<p>以 <code>二叉链表</code> 为例进行空间代价分析：<br> 每个结点占用两个指针、一个数据域，假定数据域大小为d、指针域大小为p，整个结构由n个结点组成，那么总体空间大小是 <code>(2p+d)n</code>，总体结构性开销是 <code>2pn</code>。<br> γ = <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
         
         
           2 
          
         
           p 
          
         
           n 
          
         
         
         
           ( 
          
         
           2 
          
         
           p 
          
         
           + 
          
         
           d 
          
         
           ) 
          
         
           n 
          
         
        
       
      
        \frac{2pn}{(2p+d)n} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1.4172em; vertical-align: -0.52em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.8972em;"><span class="" style="top: -2.655em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mtight">2</span><span class="mord mathnormal mtight">p</span><span class="mbin mtight">+</span><span class="mord mathnormal mtight">d</span><span class="mclose mtight">)</span><span class="mord mathnormal mtight">n</span></span></span></span><span class="" style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span class="" style="top: -3.4461em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mathnormal mtight">p</span><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.52em;"><span class=""></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span>，如果 p = d，γ = <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          2 
         
        
          3 
         
        
       
      
        \frac{2}{3} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1.1901em; vertical-align: -0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.8451em;"><span class="" style="top: -2.655em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span><span class="" style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span class="" style="top: -3.394em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.345em;"><span class=""></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span>。<br> 为降低结构性开销，若只有叶结点存储数据、分支结点为内部结构，则开销取决于二叉树满的程度，越满则存储效率越高。</p> 
<p>叶结点和分支结点差别较大，可区分叶结点存储和分支结点的存储。例如在叶结点存储操作数、在分支结点存储操作符：</p> 
<p><img src="https://images2.imgbox.com/77/3f/flXnPddk_o.png" alt="在这里插入图片描述"><br> 采用不同的存储实现，不仅空间开销有差异，对于运算和操作的实现也不同。<br> 具体应用中采取何种存储结构，除了二叉树的形态外，还应该考虑运算：</p> 
<ul><li>时间复杂度</li><li>空间复杂度</li><li>算法简洁性</li></ul> 
<br> 
<h3><a id="_792"></a>应用</h3> 
<p><code>二叉树</code> 的一个主要用途是提供对数据（包括索引）的快速检索，而一般二叉树对此并不具有性能优势。</p> 
<h4><a id="_795"></a>二叉搜索树</h4> 
<h5><a id="_796"></a>概念</h5> 
<p><img src="https://images2.imgbox.com/4f/26/MeTXjdUt_o.png" alt="在这里插入图片描述" width="300"><br> 和上图右侧的树类似的树，我们称其为 <code>二叉搜索树</code>（ <code>Binary Search Tree</code>，简称 <code>BST</code> ）。它在中文里还有其他常用名称，例如 <code>二叉查找树</code>、<code>二叉检索树</code>、<code>二叉排序树</code>。</p> 
<p><code>二叉搜索树</code> 具有以下性质：</p> 
<ul><li>或为一颗空树</li><li>或任何一个检索码为 <code>K</code> 的结点满足： 
  <ul><li>其左子树（若非空）任一结点的检索码均小于K</li><li>其右子树（若非空）任一结点的检索码均大于或等于K</li><li>其左、右子树分别为二叉搜索树</li></ul> </li><li>其中序序列为按检索码值从小到大的有序序列<br> <img src="https://images2.imgbox.com/7a/69/N0cff89I_o.png" alt="在这里插入图片描述" width="180"><br> 以中序序列遍历上面的 <code>二叉树</code>，可以得到一个有序序列 <code>15 17 18 22 35 51 60 88 93</code></li></ul> 
<br> 
<h5><a id="_812"></a>操作</h5> 
<p>对于 <code>二叉搜索树</code>，常用的操作有 <code>检索</code>、<code>插入</code>（ <code>生成</code> ）、<code>删除</code>。</p> 
<p>所有的操作都围绕 <code>二叉搜索树</code> 的性质，并保持相应的性质。操作的效率取决于树的高度。</p> 
<br> 
<h6><a id="_819"></a>检索</h6> 
<p>假定待检索的检索码为 <code>K</code>，</p> 
<ul><li>从根结点开始，若根结点检索码为 <code>K</code>，则检索成功并结束；否则，则继续： 
  <ul><li>若 <code>K</code> 小于根结点的值，则只检索左子树</li><li>若 <code>K</code> 大于根结点的值，则只检索右子树</li></ul> </li></ul> 
<p>如此，一直持续到 <code>K</code> 被找到，或者，遇上叶结点仍没发现 <code>K</code>，则检索失败，说明不存在满足条件的结点。</p> 
<br> 
<h6><a id="_829"></a>示例</h6> 
<p><img src="https://images2.imgbox.com/3c/9a/LEZ1tzdu_o.png" alt="在这里插入图片描述" width="200"></p> 
<ol><li>查找检索码为 <code>35</code> 的结点<br> 从根结点 <code>35</code> 开始，根结点检索码为 <code>35</code>，检索成功并结束。</li><li>查找检索码为 <code>19</code> 的结点</li></ol> 
<ul><li>从根结点 <code>35</code> 开始，根结点 <code>35</code> 和 检索码 <code>19</code> 不一致且检索码 <code>19</code> 比根结点 <code>35</code> 小，则继续检索左子树，即以 <code>16</code> 为根结点的左子树</li><li>检索码 <code>19</code> 比根结点 <code>16</code> 大，则继续检索右子树，即以 <code>19</code> 为根结点的右子树。根结点 <code>19</code> 同检索码 <code>19</code> 一致，检索成功并结束。</li></ul> 
<ol start="3"><li>查找检索码为 <code>40</code> 的结点</li></ol> 
<ul><li>从根结点 <code>35</code> 开始，根结点 <code>35</code> 和 检索码 <code>40</code> 不一致且检索码 <code>40</code> 比根结点 <code>35</code> 大，则继续检索右子树，即以 <code>60</code> 为根结点的右子树</li><li>检索码 <code>40</code> 比根结点 <code>60</code> 小，则继续检索左子树，即以 <code>51</code> 为根结点的左子树</li><li>以 <code>51</code> 为根结点的左子树为空，检索失败</li></ul> 
<br> 
<h6><a id="_843"></a>时间、空间代价分析</h6> 
<p>检索的基本操作是比较。每次比较，只需要检索2个子树之一。每比较1次，树的高度降低1。因此，检索代价是 <code>O(h)</code>，<code>h</code> 是树高。</p> 
<br> 
<h6><a id="_848"></a>插入</h6> 
<p><code>插入</code> 操作应保证结点插入后仍保持 <code>BST</code> 性质，即，<code>BST</code> 的不变量和中序有序性。</p> 
<p>假定待插入的检索码为 <code>K</code>，</p> 
<ul><li>从根结点开始，若根结点检索码为空，则将 <code>K</code> 结点作为根结点插入，操作结束 
  <ul><li>若 <code>K</code> 小于根结点的值，将其插入左子树</li><li>若 <code>K</code> 大于根结点的值，将其插入右子树</li></ul> </li></ul> 
<br> 
<h6><a id="_858"></a>示例</h6> 
<p><img src="https://images2.imgbox.com/c6/bf/Cqu1DJgc_o.png" alt="在这里插入图片描述" width="200"></p> 
<ol><li>插入检索码为 <code>17</code> 的结点</li></ol> 
<ul><li>从根结点 <code>35</code> 开始，检索码 <code>17</code> 小于根结点 <code>35</code>，只能将检索码 <code>17</code> 插入根结点为 <code>16</code> 的左子树中</li><li>检索码 <code>17</code> 比根结点 <code>16</code> 大，只能将检索码 <code>17</code> 插入根结点为 <code>19</code> 的右子树中</li><li>检索码 <code>17</code> 比根结点 <code>19</code> 小，且根结点 <code>19</code> 的左子树为空，因此插入 <code>19</code> 的左子树，如下所示：</li></ul> 
<p><img src="https://images2.imgbox.com/94/bf/xtngQDWs_o.png" alt="在这里插入图片描述" width="200"></p> 
<br> 
<h6><a id="_869"></a>时间、空间代价分析</h6> 
<p>插入操作的前提是一次失败的检索，然后将新结点作为叶结点插入，改动相关特定结点的空指针即可。</p> 
<p>其时间复杂度与根到插入位置的路径长度相关，而这个路径长度是插入结点落在先前那次失败检索时外部结点所在的层次。在最坏的情况下，这个路径长度与树的高度成正比。</p> 
<br> 
<h6><a id="_876"></a>删除</h6> 
<p><code>删除</code> 操作应保证结点删除后仍保持 <code>BST</code> 性质，且树高变化较小。</p> 
<p>首先检索到待删除结点 <code>H</code>，再根据其在树中所处位置分情况处理：</p> 
<ul><li>叶结点 
  <ul><li>直接删除 <code>H</code>，并将其父结点 <code>J</code> 的相应指针位置置空<br> <img src="https://images2.imgbox.com/7e/1f/BWaKNpZL_o.png" alt="在这里插入图片描述" width="150"></li></ul> </li><li>只有1个子结点的结点 
  <ul><li>删除 <code>H</code>，并以 <code>H</code> 的子结点代替 <code>H</code> 原有的位置</li></ul> </li></ul> 
<p><img src="https://images2.imgbox.com/cd/f5/77nEtkWm_o.png" alt="在这里插入图片描述" width="150"><br> <img src="https://images2.imgbox.com/59/1a/mXiaTLjt_o.png" alt="在这里插入图片描述" width="150"></p> 
<ul><li>有2个子结点的结点 
  <ul><li>删除 <code>H</code>，并以 <code>H</code> 的左子树中最大的结点或者右子树中最小的结点来替换 <code>H</code> 原有的位置</li></ul> </li></ul> 
<br> 
<h6><a id="_893"></a>示例</h6> 
<p><img src="https://images2.imgbox.com/5c/d5/PsoUXUrV_o.png" alt="在这里插入图片描述" width="150"><br> 假设要删除 <code>G</code>，<code>G</code> 的左右子树均不为空，即符合第3种情况。<br> <code>G</code> 的右子树中最小的结点为 <code>H</code>，<code>H</code> 符合第2种情况，将 <code>H</code> 替换到 <code>G</code> 的位置，<code>H</code> 的右子树结点 <code>I</code> 替换到 <code>H</code> 的位置。</p> 
<h6><a id="_898"></a>时间、空间代价分析</h6> 
<p>删除操作需要：</p> 
<ul><li>先检索到待删除结点的位置，比较的次数是被删结点所在的层次+1</li><li>需要根据情况需要，寻找待删除结点的后继，即查找替代结点，而查找的层次同待删除结点的子树的高度相关</li></ul> 
<p>以上两步的检索次数加起来是不会超过整个二叉搜索树的高度的。所以删除的时间代价是 <code>O(h)</code>，同树高 <code>h</code> 成正比。</p> 
<p>其时间复杂度与根到插入位置的路径长度相关，而这个路径长度是插入结点落在先前那次失败检索时外部结点所在的层次。在最坏的情况下，这个路径长度与树的高度成正比。</p> 
<br> 
<h4><a id="_909"></a>堆与优先队列</h4> 
<h5><a id="_910"></a>概念</h5> 
<p><img src="https://images2.imgbox.com/7d/4d/6mp97rmd_o.png" alt="在这里插入图片描述" width="160"><br> 满足以下几种特性的二叉树：</p> 
<ul><li>在结构上是一颗 <code>完全二叉树</code></li><li>任一结点的值小于或等于其子结点的值</li><li>根结点存储着树中所有结点的最小值</li></ul> 
<p>我们将它称为 <code>最小值堆</code>（ <code>min-heap</code> ）。如上图所示。</p> 
<p><code>堆</code> 是什么？——</p> 
<ul><li>从逻辑角度看，<code>堆</code> 是一种树型结构。 
  <ul><li>一个 <code>完全二叉树</code> 的层次序列，可采用顺序数组表示</li></ul> </li><li>堆局部有序，堆不唯一 
  <ul><li>结点的值与其子结点的值之间存在某种约束</li><li>堆中任一结点与其兄弟之间没有约束</li><li>最小堆 并非 <code>BST</code> 那样实现关键码的完全排序，而是局部有序，只有父结点的大小关系可以确定</li></ul> </li></ul> 
<p>堆是基于树的满足一定约束的重要数据结构，存在许多变体：二项式堆、斐波那契堆。<br> 二叉树所表示的二叉堆是常用的一种堆，由于完全二叉树良好的性质，常采用数组来存储堆。</p> 
<p>堆的基本操作均依赖于两个重要的函数 <code>ShiftUp</code> 和 <code>ShiftDown</code>。</p> 
<ul><li>堆的删除操作根据被删元素的位置和大小进行 <code>ShiftUp</code> 或 <code>ShiftDown</code></li><li>堆的插入操作在堆尾插入新元素并通过 <code>ShiftUp</code> 进行调整</li></ul> 
<p>构建具有N个结点的堆的时间复杂度为 <code>O(N)</code>。<br> 堆的深度为 <code>logN</code>，插入、删除元素的平均时间代价和最差时间代价都是 <code>O(logN)</code><br> 适合需要经常查找最小值、又经常增删数据的场景。但是，查找任意值的效率不高，因为往往需要遍历整棵树后才知道它在哪儿。</p> 
<br> 
<h5><a id="_941"></a>定义</h5> 
<pre><code class="prism language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>                          <span class="token comment">// 最小堆 ADT 定义</span>
<span class="token keyword">class</span> <span class="token class-name">MinHeap</span><span class="token punctuation">{<!-- --></span>
<span class="token keyword">private</span><span class="token operator">:</span>
    T<span class="token operator">*</span> heapArray<span class="token punctuation">;</span>                           <span class="token comment">// 存放堆数据的数组</span>
    <span class="token keyword">int</span> CurrentSize<span class="token punctuation">;</span>                        <span class="token comment">// 当前堆中元素数目</span>
    <span class="token keyword">int</span> MaxSize<span class="token punctuation">;</span>                            <span class="token comment">// 堆所能容纳的最大元素数目</span>
    <span class="token keyword">void</span> <span class="token function">BuildHeap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                       <span class="token comment">// 建堆函数</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">MinHeap</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>                   <span class="token comment">// 构造函数，n为最大元素数目</span>
    <span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">MinHeap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span><span class="token keyword">delete</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>heapArray<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">// 析构函数</span>
    <span class="token keyword">bool</span> <span class="token function">isLeaf</span><span class="token punctuation">(</span><span class="token keyword">int</span> pos<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>             <span class="token comment">// 若为叶结点，返回TRUE</span>
    <span class="token keyword">int</span> <span class="token function">leftchild</span><span class="token punctuation">(</span><span class="token keyword">int</span> pos<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>           <span class="token comment">// 返回左子结点位置</span>
    <span class="token keyword">int</span> <span class="token function">rightchild</span><span class="token punctuation">(</span><span class="token keyword">int</span> pos<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>          <span class="token comment">// 返回右子结点位置</span>
    <span class="token keyword">int</span> <span class="token function">parent</span><span class="token punctuation">(</span><span class="token keyword">int</span> pos<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>              <span class="token comment">// 返回父结点位置</span>
    <span class="token keyword">void</span> <span class="token function">ShiftDown</span><span class="token punctuation">(</span><span class="token keyword">int</span> left<span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token comment">// 筛选法函数，参数left表示开始处理的数组下标</span>
    <span class="token keyword">void</span> <span class="token function">ShiftUp</span><span class="token punctuation">(</span><span class="token keyword">int</span> pos<span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token comment">// 从pos开始向上调整序列为堆</span>
    <span class="token keyword">bool</span> <span class="token function">Remove</span><span class="token punctuation">(</span><span class="token keyword">int</span> pos<span class="token punctuation">,</span> T<span class="token operator">&amp;</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment">// 删除给定下标的元素node</span>
    <span class="token keyword">bool</span> <span class="token function">Insert</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> newNode<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment">// 插入新元素newNode</span>
    T<span class="token operator">&amp;</span> <span class="token function">RemoveMin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                         <span class="token comment">// 删除堆顶最小值</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<br> 
<h5><a id="_967"></a>建堆</h5> 
<h6><a id="_968"></a>筛选法</h6> 
<h6><a id="_969"></a>理论</h6> 
<p>如何建 <code>堆</code> ？——</p> 
<ol><li>筛选法<br> 将 <code>n</code> 个关键码组织到一维数组中，</li></ol> 
<ul><li>可能整体并不满足堆的特性</li><li>以叶结点为根的子树都已满足堆的特性，亦即，当 i&gt;=n/2 时，以关键码 K<sub>i</sub> 为根的子树已为堆</li><li>从最后一个分支结点 i = n/2 - 1 开始，采用 <code>shiftdown</code> 从右向左、自底向上将以各个分支结点为根的子树调整成堆，直到树根为止</li></ul> 
<p>以下面的二叉树为例，<br> <img src="https://images2.imgbox.com/71/81/8UwnU7PY_o.png" alt="在这里插入图片描述" width="300"><br> 该二叉树存在8个结点，编号从0到7。</p> 
<ol><li>编号大于 8/2-1=3，及编号大于等于4的这些结点，例如94、16、5、68，均是叶结点，都已经满足 <code>堆</code> 的性质。</li><li>编号3的结点23，同其子结点68进行比较，23&lt;68，满足 <code>堆</code> 的性质</li></ol> 
<p><img src="https://images2.imgbox.com/33/00/PJogSOjg_o.png" alt="在这里插入图片描述" width="350"></p> 
<ol start="3"><li>编号2的结点71，同其子结点16、05进行比较，71&gt;16，71&gt;5</li></ol> 
<p><img src="https://images2.imgbox.com/a9/00/QfIQLA3P_o.png" alt="在这里插入图片描述" width="350"><br> 16&gt;5，将71和5进行交换，得到下面的结构：</p> 
<p><img src="https://images2.imgbox.com/f1/87/T9Yqyo02_o.png" alt="在这里插入图片描述" width="350"><br> 以新编号2的结点5为根结点的一个二叉树结构已经被调整成 <code>堆</code></p> 
<ol start="4"><li>编号1的结点73，同其子结点23、94进行比较，73&gt;23，73&lt;94</li></ol> 
<p><img src="https://images2.imgbox.com/34/cf/3Qk97UCO_o.png" alt="在这里插入图片描述" width="350"><br> 73&gt;23，将73和23进行交换，得到下面的结构：</p> 
<p><img src="https://images2.imgbox.com/d1/ab/xUeMTAOT_o.png" alt="在这里插入图片描述" width="350"><br> 新编号3的结点73，同其子结点68进行比较，73&gt;68，将73和68进行交换，得到下面的结构：<br> <img src="https://images2.imgbox.com/b8/93/B7Cw4LUI_o.png" alt="在这里插入图片描述" width="350"><br> 以新编号1的结点23为根结点的一个二叉树结构已经被调整成 <code>堆</code></p> 
<ol start="5"><li>编号0的结点72，同其子结点23、5进行比较，72&gt;23，72&gt;5，</li></ol> 
<p><img src="https://images2.imgbox.com/90/c8/7KnXTlxW_o.png" alt="在这里插入图片描述" width="350"><br> 23&gt;5，将72和5进行交换，得到下面的结构：</p> 
<p><img src="https://images2.imgbox.com/ce/78/voTlMBbn_o.png" alt="在这里插入图片描述" width="350"><br> 新编号2的结点72，同其子结点16、71进行比较，72&gt;16，72&gt;71，16&gt;71，将72和16进行交换，得到下面的结构：</p> 
<p><img src="https://images2.imgbox.com/fb/e7/tv0YJ8AD_o.png" alt="在这里插入图片描述" width="350"><br> 以新编号2的结点16为根结点的一个二叉树结构已经被调整成 <code>堆</code></p> 
<p>至此，原始的二叉树被调整为 <code>最小堆</code> 。</p> 
<br> 
<h6><a id="_1019"></a>代码实现</h6> 
<p>如果使用代码来实现上述的 <code>shiftdown</code> 操作，</p> 
<pre><code class="prism language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span> 
<span class="token keyword">void</span> <span class="token class-name">MinHeap</span><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span><span class="token function">ShiftDown</span><span class="token punctuation">(</span><span class="token keyword">int</span> position<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> i <span class="token operator">=</span> position<span class="token punctuation">;</span>                                               <span class="token comment">// 指向父结点的指针</span>
    <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">2</span><span class="token operator">*</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>                                                <span class="token comment">// 指向关键值较小的子结点的指针</span>
    T temp <span class="token operator">=</span> heapArray<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                                          <span class="token comment">// 使用temp来保存父结点的关键值</span>

    <span class="token keyword">while</span> <span class="token punctuation">(</span>j<span class="token operator">&lt;</span>CurrentSize<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>j<span class="token operator">&lt;</span>CurrentSize<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>heapArray<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&gt;</span> heapArray<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>   <span class="token comment">// 如果编号j的结点的关键值小于编号j+1的结点的关键值</span>
            j<span class="token operator">++</span><span class="token punctuation">;</span>                                                    <span class="token comment">// j下移，j指向j+1</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>temp <span class="token operator">&gt;</span> heapArray<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>                                   <span class="token comment">// 如果父结点的关键值大于编号j的结点的关键值</span>
            heapArray<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> heapArray<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                            <span class="token comment">// 交换父结点和编号j的结点</span>
            i <span class="token operator">=</span> j<span class="token punctuation">;</span>
            j <span class="token operator">=</span> <span class="token number">2</span><span class="token operator">*</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>                                              <span class="token comment">// 向下继续</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">else</span> <span class="token keyword">break</span><span class="token punctuation">;</span>                                                 <span class="token comment">// 调整结束，退出while循环</span>
    <span class="token punctuation">}</span>
    heapArray<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<br> 
<h6><a id="_1045"></a>时间代价分析</h6> 
<p>使用 <code>shiftdown</code> 的时间代价分析如下：</p> 
<ul><li>基本操作包括比较和交换。<br> 比较需要判断子结点的大小，以及，结点是否需要筛选，即需要比较2次。<br> 交换需要1次，在最差的情况下每层都需要调整。</li><li>1个N个结点的完全二叉树，其高度是 <code>log(N+1)</code>。每循环一次就把目标结点下移一层，故循环最多为 <code>log(N+1)</code> 次。</li></ul> 
<p>所以，最差的情况下，<code>shiftdown</code> 的时间代价为 <code>O(logN)</code>。</p> 
<hr> 
<p>构建具有N个结点的堆的时间代价分析如下：<br> 以下面的完全二叉树为例，<br> <img src="https://images2.imgbox.com/c8/d8/DblQUSyv_o.png" alt="在这里插入图片描述" width="400"><br> 一个N个结点的完全二叉树，若同时为满二叉树，则筛选的层数达到最大，此时有 N = 2<sup>d</sup> - 1 =&gt; d = log(N+1)</p> 
<p>第 k 层有至多 2<sup>k</sup> 个结点，且第k层离叶结点的距离为 d-k-1层。</p> 
<p>构建具有N个结点的堆需要的比较次数为：</p> 
<p><img src="https://images2.imgbox.com/7d/49/bfaNSnUc_o.png" alt="在这里插入图片描述" width="400"><br> 最差的情况下，2次比较需要1次交换，所以最大交换次数为 <code>n-logn</code><br> 因此，构建具有N个结点的堆的时间复杂度为 <code>O(N)</code>。</p> 
<br> 
<h5><a id="_1071"></a>堆的相关操作</h5> 
<h6><a id="_1072"></a>插入</h6> 
<h6><a id="_1073"></a>理论</h6> 
<p>以向下面的二叉树插入元素12为例说明如何进行 <code>插入</code> 操作：</p> 
<p><img src="https://images2.imgbox.com/a2/9d/C8mY0ldQ_o.png" alt="在这里插入图片描述" width="200"></p> 
<ol><li>将新元素12插入最末端，尽最大程度降低对其他原有元素的影响，形成下面的结构：</li></ol> 
<p><img src="https://images2.imgbox.com/0a/62/4tCE5MNn_o.png" alt="在这里插入图片描述" width="200"></p> 
<ol start="2"><li>在插入新元素12后，它与同层的叶结点和父结点未必满足 <code>堆</code> 的性质。此时，需要同其父结点进行比较，36&gt;12，故交换36和12、将12 <code>shiftup</code> 放至根结点的位置上，形成下面的结构：</li></ol> 
<p><img src="https://images2.imgbox.com/77/f7/JFH7gnmw_o.png" alt="在这里插入图片描述" width="200"></p> 
<ol start="3"><li>以此类推，逐步 <code>shiftup</code>，最终形成下面的结构：</li></ol> 
<p><img src="https://images2.imgbox.com/7c/14/HGGB08PE_o.png" alt="" width="210"><br> <br></p> 
<h6><a id="_1091"></a>代码实现</h6> 
<p>如果使用代码来实现上述的 <code>shifup</code> 和插入操作，</p> 
<pre><code class="prism language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token class-name">MinHeap</span><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span><span class="token function">ShiftUp</span><span class="token punctuation">(</span><span class="token keyword">int</span> position<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> temppos <span class="token operator">=</span> position<span class="token punctuation">;</span>                                         <span class="token comment">// 从position向上开始调整，使序列成为堆</span>

    T temp <span class="token operator">=</span> heapArray<span class="token punctuation">[</span>temppos<span class="token punctuation">]</span><span class="token punctuation">;</span>                                    <span class="token comment">// 使用temp保存temppos结点</span>

    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>temppos <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>heapArray<span class="token punctuation">[</span><span class="token function">parent</span><span class="token punctuation">(</span>temppos<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">&gt;</span> temp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        heapArray<span class="token punctuation">[</span>temppos<span class="token punctuation">]</span> <span class="token operator">=</span> heapArray<span class="token punctuation">[</span><span class="token function">parent</span><span class="token punctuation">(</span>temppos<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token comment">// 交换temppos和其父结点</span>
        temppos <span class="token operator">=</span> <span class="token function">parent</span><span class="token punctuation">(</span>temppos<span class="token punctuation">)</span><span class="token punctuation">;</span>                                  <span class="token comment">// 交换temppos和其父结点的指针</span>
    <span class="token punctuation">}</span>
    heapArray<span class="token punctuation">[</span>temppos<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>                                      <span class="token comment">// 最终temppos结点的关键值仍为temp</span>
<span class="token punctuation">}</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">bool</span> <span class="token class-name">MinHeap</span><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span><span class="token function">Insert</span><span class="token punctuation">(</span><span class="token keyword">const</span> T <span class="token operator">&amp;</span> newNode<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>                         <span class="token comment">// 向堆中插入新元素newNode</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>CurrentSize <span class="token operator">==</span> MaxSize<span class="token punctuation">)</span>                                     <span class="token comment">// 堆空间已满</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    heapArray<span class="token punctuation">[</span>CurrentSize<span class="token punctuation">]</span> <span class="token operator">=</span> newNode<span class="token punctuation">;</span>                               <span class="token comment">// 将新元素添加到最后</span>
    <span class="token function">ShiftUp</span><span class="token punctuation">(</span>CurrentSize<span class="token punctuation">)</span><span class="token punctuation">;</span>                                           <span class="token comment">// 向上调整</span>
    CurrentSize <span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<br> 
<h6><a id="_1119"></a>时间代价分析</h6> 
<p>构建具有N个结点的堆的时间复杂度为 <code>O(N)</code>。</p> 
<p>堆的深度为 <code>logN</code><br> 插入、删除元素的平均时间代价和最差时间代价都是 <code>O(logN)</code></p> 
<br> 
<h6><a id="_1127"></a>删除</h6> 
<p>删除根结点后须维护和保持 <code>堆</code> 的特性。</p> 
<br> 
<h6><a id="_1132"></a>理论</h6> 
<p>以下面的二叉树为例，对如何删除根结点元素进行说明：</p> 
<p><img src="https://images2.imgbox.com/50/97/Uuxokfs5_o.png" alt="在这里插入图片描述" width="200"></p> 
<ol><li>删除根结点5，整个堆的规模减1，形成下面的结构：</li></ol> 
<p><img src="https://images2.imgbox.com/37/d0/mpbyVHWw_o.png" alt="在这里插入图片描述" width="200"></p> 
<p>将最后1个元素45放到根结点上作为替代，如下所示：</p> 
<p><img src="https://images2.imgbox.com/2b/f8/8frhHywY_o.png" alt="在这里插入图片描述" width="200"><br> 但是，这时候整个二叉树结构未必再满足 <code>堆</code> 的特性。</p> 
<ol start="2"><li>以新根结点45和其子结点进行比较，45&lt;63，45&gt;16，将45和16交换，16成为新的根结点，形成下面的结构：</li></ol> 
<p><img src="https://images2.imgbox.com/c6/57/RIMRRlss_o.png" alt="在这里插入图片描述" width="200"><br> 以此类推，45&gt;36，45&gt;40，36&lt;40，将45和36交换，形成下面的结构：</p> 
<p><img src="https://images2.imgbox.com/0f/bd/m9ks1hyB_o.png" alt="在这里插入图片描述" width="200"><br> 整个过程可能需要从树根一直筛到树叶，因此效率同树的高度成正比，即耗时 <code>O(logN)</code>。</p> 
<hr> 
<p>再以下面的二叉树为例，对如何删除树上的元素进行说明：</p> 
<p><img src="https://images2.imgbox.com/91/94/QuD1Qjyd_o.png" alt="在这里插入图片描述" width="200"></p> 
<ol><li>删除结点68，整个堆的规模减1；将最后1个元素45放到被删除结点上作为替代，形成下面的结构：</li></ol> 
<p><img src="https://images2.imgbox.com/8f/8d/HgBsJcHS_o.png" alt="在这里插入图片描述" width="200"></p> 
<ol start="2"><li>以新结点45和其2个子结点进行比较，45&lt;73 且 45&lt;120，满足堆的特质；继续以新结点45和其父节点进行比较，63&gt;45，将63和45交换，<code>ShiftUp</code>，63成为新结点，形成下面的结构：</li></ol> 
<p><img src="https://images2.imgbox.com/8e/11/tOGOJHfj_o.png" alt="在这里插入图片描述" width="200"><br> 此时，树上的各个节点满足 <code>最小堆</code> 的特性。至此，调整完毕。</p> 
<br> 
<h6><a id="_1170"></a>代码实现</h6> 
<p>如果使用代码来实现删除根结点的操作，</p> 
<pre><code class="prism language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span> T <span class="token class-name">MinHeap</span><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span><span class="token function">RemoveRoot</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>CurrentSize <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token comment">// 如果MinHeap的size是0，退出；</span>

    Item tmpItem <span class="token operator">=</span> heapArray<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                    <span class="token comment">// 使用tmpItem保存heapArray的第0个结点;</span>
    heapArray<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> heapArray<span class="token punctuation">[</span>CurrentSize <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token comment">// 将最后一个结点和根结点进行交换</span>
    heapArray<span class="token punctuation">[</span>CurrentSize <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> tmpItem<span class="token punctuation">;</span>

    CurrentSize <span class="token operator">--</span><span class="token punctuation">;</span>                                 <span class="token comment">// 删除新最后1个结点，即，旧根结点</span>
    <span class="token function">ShiftDown</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                   <span class="token comment">// 将根结点shift down</span>
    <span class="token keyword">return</span> tmpItem<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>如果使用代码来实现删除树上某结点的操作，</p> 
<pre><code class="prism language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">bool</span> <span class="token class-name">MinHeap</span><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span><span class="token function">Remove</span><span class="token punctuation">(</span><span class="token keyword">int</span> pos<span class="token punctuation">,</span> T<span class="token operator">&amp;</span> node<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>pos<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span>pos<span class="token operator">&gt;=</span>CurrentSize<span class="token punctuation">)</span><span class="token punctuation">)</span>              <span class="token comment">// 如果pos&lt;0或大于树中结点的个数，非法</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    T temp <span class="token operator">=</span> heapArray<span class="token punctuation">[</span>pos<span class="token punctuation">]</span><span class="token punctuation">;</span>                        <span class="token comment">// 使用temp保存树上的第pos个结点</span>
    heapArrayp<span class="token punctuation">[</span>pos<span class="token punctuation">]</span> <span class="token operator">=</span> heapArray<span class="token punctuation">[</span><span class="token operator">--</span>CurrentSize<span class="token punctuation">]</span><span class="token punctuation">;</span>     <span class="token comment">// 将树上的第pos个结点和最后一个结点进行交换</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>heapArray<span class="token punctuation">[</span><span class="token function">parent</span><span class="token punctuation">(</span>pos<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> heapArray<span class="token punctuation">[</span>pos<span class="token punctuation">]</span>    <span class="token comment">// 如果新第pos个结点的父结点比其大</span>
        <span class="token function">ShiftUp</span><span class="token punctuation">(</span>pos<span class="token punctuation">)</span><span class="token punctuation">;</span>                               <span class="token comment">// 将新第pos个结点ShiftUp</span>
    <span class="token keyword">else</span> <span class="token function">ShiftDown</span><span class="token punctuation">(</span>pos<span class="token punctuation">)</span><span class="token punctuation">;</span>                            <span class="token comment">// 否则，将新第pos个结点ShiftDown</span>
    node <span class="token operator">=</span> temp<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<br> 
<h6><a id="_1204"></a>时间代价分析</h6> 
<p>构建具有N个结点的堆的时间复杂度为 <code>O(N)</code>。</p> 
<p>堆的深度为 <code>logN</code><br> 插入、删除元素的平均时间代价和最差时间代价都是 <code>O(logN)</code></p> 
<br> 
<h5><a id="_1212"></a>堆的应用</h5> 
<ol><li>堆排序</li><li>优先队列（ <code>Priority Queue</code> ）<br> 2.1 根据需要释放具有最小 / 最大值的对象<br> 2.2 最大树、左高树（ <code>HBLT</code>、<code>WBLT</code>、<code>maxWBLT</code> ）<br> 2.3 改变已存储于优先队列中对象的优先权<br> 2.3.1 辅助数据结构帮助找到对象</li></ol> 
<br> 
<h4><a id="Huffman_1222"></a>Huffman树及其应用</h4> 
<h5><a id="_1223"></a>编码</h5> 
<p>在程序设计以及数据通信领域，常常需要给某些给定字符集进行编码。编码是建立字符集与计算机或通信的数字系统之间的对应关系。也就是说，采用一组无歧义的规则将字符集中每个字符编码为唯一可标识的代码串。</p> 
<p>一般编码有：</p> 
<ul><li>定长编码（ <code>fixed-length coding scheme</code> ） 
  <ul><li>所有字符的编码长度均相同，编码一个具有n个字符的字符集需要 log<sub>2</sub>n位。<br> 例如，ASCII码就是一种定长编码（ 8位 ）</li><li>若字符集中每个字符使用频率大致相同，定长编码的空间效率最高</li><li>具有简单、解码容易的优点</li></ul> </li><li>不等长编码（ <code>variable-length coding scheme</code> ） 
  <ul><li>根据字符出现频率编码。常出现字符的编码较短，使用频率低的字符编码较长。</li><li>不等长编码是文件压缩技术的核心。数据压缩既能节省磁盘空间，又能提高传输速度。</li><li>任何一个字符的编码都不能是另外一个字符编码的前缀。<br> 否则容易造成歧义。<br> 例如，将字符集 {Z，K，F，C，U，D，L，E} 编码为 {Z(0)，K(0)，F(1)，C(01)，U(10)，D(11)，L(000)，E(001)}，“0001110” 可解码为 “ZZZDZ”、“LDZ” 或者 “FCU”。</li></ul> </li><li>前缀编码 
  <ul><li>任何一个字符的编码都不能是另外一个字符编码的前缀。<br> 前缀特性保证了代码串被解码时，不会出现歧义。<br> 例如，将字符集 {Z，K，F，C，U，D，L，E} 编码为 {Z(111100)，K(111101)，F(11111)，C(1110)，U(100)，D(101)，L(110)，E(0)} 为一种前缀编码，“000110” 可解码为 “EEEL”。</li></ul> </li></ul> 
<blockquote> 
 <p>可以用二叉树来设计和表示前缀编码。约定叶结点代表字符，一个结点的左分支标记 ‘0’，右分支标记 ‘1’，这样的话，根结点到叶结点的路径上所有分支标记所组成的代码串作为该叶结点所代表字符的编码。<br><br> 这样的编码方式得到的一定是前缀编码。为什么呢？因为从根到一个叶结点的路径肯定不可能是根到另外一个叶结点路径的前缀，这是由二叉树的结构特性所保证的。同时，进行不等长编码的初衷是要提高空间的利用率。<br><br> 如何保证这样的编码树所得到的编码总长度最小？通过 Huffman算法。</p> 
</blockquote> 
<p>通过下面的例子来了解编码总长的概念，<br> <img src="https://images2.imgbox.com/6c/81/o9h2jzYt_o.png" alt="在这里插入图片描述" width="300"><br> 上面有三颗具有4个外部结点的二叉树，相应的权值分别为6，2，3，4。<br> （a）、（b）、（c）三种形态的编码总长为其带权外部路径长度。</p> 
<ol><li>对于（a）来说，它的4个结点的路径长度一样，都是2，编码总长 = 6x2 + 2x2 + 3x2 + 4x2 = 30。</li><li>对于（b）来说，它的4个结点不等长。编码总长 = 6x2 + 2x3 + 3x3 + 4x1 = 31。</li><li>对于（c）来说，它的4个结点不等长。编码总长 = 6x1 + 2x3 + 3x3 + 4x2 = 29。<br> 在 a）、（b）、（c）中（c）的编码总长最短。</li></ol> 
<br> 
<h6><a id="Huffman_1258"></a>Huffman编码</h6> 
<p>Huffman编码其实就是对一个待编码的字符集D={d<sub>0</sub>，…，d<sub>n-1</sub>}，D中各种字符的出现频率为W={w<sub>0</sub>，…，w<sub>n-1</sub>}，对字符集D进行二进制编码，使得通信编码总长最短，且d<sub>i</sub> 的编码不是d<sub>j</sub>编码的前缀。反之亦然。</p> 
<p>Huffman编码的基本思想是，将d<sub>i</sub>作为外部结点，w<sub>i</sub>为外部结点的权，构造具有最小带权外部路径长度的扩充二叉树。也就是说，Huffman树是一个具有n个外部结点的扩充二叉树：</p> 
<ul><li>每个外部结点d<sub>i</sub>有一个与之对应的权w<sub>i</sub></li><li>这个扩充二叉树的带权外部路径长度总和最小，也就是，权越大的叶结点离根越近。</li></ul> 
<p>构建一个Huffman树的步骤为：</p> 
<ol><li>将待编码字符集中的字符按照 “权”（例如，频率）值组成一个有序的序列</li><li>取走当前序列里 “权” 值最小的两个字符，将其标记为Huffman树的叶结点，并将这两个叶结点作为一个新生成分支结点的两个子结点，将该分支结点的权作为两个叶结点的权之和；将所得子树的 “权” 放回序列中适当位置，保持 “权” 的有序性</li><li>重复上述步骤，直至序列中只剩一个元素，那么Huffman树建立完毕</li></ol> 
<p>以下面的示例为例对如何构建Huffman树进行说明，</p> 
<p><img src="https://images2.imgbox.com/80/4f/QceElgDt_o.png" alt="在这里插入图片描述"><br> 以上是13个待编码的字符按照权值的有序排列，可构成下面的Huffman树，在这样的一棵树上，把每个结点到它的左子结点的边标记为0、到它的右子结点的边标记为1。那么将从根到叶结点的路径上的0、1标记组成该叶结点所代表字符的编码，如下所示：<br> <img src="https://images2.imgbox.com/2b/f7/DEke5T1s_o.png" alt="在这里插入图片描述" width="350"><br> <img src="https://images2.imgbox.com/32/04/75LGsEK7_o.png" alt="在这里插入图片描述" width="150"><br> 出现频率越大的字符，其编码越短。</p> 
<br> 
<h6><a id="_1280"></a>定义</h6> 
<pre><code class="prism language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token class-name">HuffmanTree</span> <span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span><span class="token function">HuffmanTree</span><span class="token punctuation">(</span>T weight<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    MinHeap<span class="token operator">&lt;</span>HuffmanTreeNode<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token function">heap</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>                                    <span class="token comment">// 最小值堆</span>
    HuffmanTreeNode<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token operator">*</span>parent<span class="token punctuation">,</span> firstchild<span class="token punctuation">,</span> secondchild<span class="token punctuation">;</span>
    HuffmanTreeNode<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token operator">*</span>NodeList <span class="token operator">=</span> <span class="token keyword">new</span> HuffmanTreeNode<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>                                                <span class="token comment">// 初始化</span>
        NodeList<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>info <span class="token operator">=</span> weight<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
        NodeList<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>parent <span class="token operator">=</span> NodeList<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>left <span class="token operator">=</span> NodeList<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
        heap<span class="token punctuation">.</span><span class="token function">Insert</span><span class="token punctuation">(</span>NodeList<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                           <span class="token comment">// 向堆中添加元素</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>                                                  <span class="token comment">// 通过n-1次合并 建立Huffman树</span>
        parent <span class="token operator">=</span> <span class="token keyword">new</span> HuffmanTreeNode<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token punctuation">;</span>                                    <span class="token comment">// 申请一个分支结点</span>
        firstchild <span class="token operator">=</span> heap<span class="token punctuation">.</span><span class="token function">RemoveMin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                      <span class="token comment">// 选择权值最小的结点</span>
        secondchild <span class="token operator">=</span> heap<span class="token punctuation">.</span><span class="token function">RemoveMin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                     <span class="token comment">// 选择权值次小的结点</span>
        <span class="token function">MergeTree</span><span class="token punctuation">(</span>firstchild<span class="token punctuation">,</span> secondchild<span class="token punctuation">,</span> parent<span class="token punctuation">)</span>                          <span class="token comment">// 将权值最小的两棵树合并到parent树</span>
        heap<span class="token punctuation">.</span><span class="token function">Insert</span><span class="token punctuation">(</span><span class="token operator">*</span>parent<span class="token punctuation">)</span><span class="token punctuation">;</span>                                               <span class="token comment">// 把parent插入到堆中去</span>
        root <span class="token operator">=</span> parent<span class="token punctuation">;</span>                                                      <span class="token comment">// Huffman树的根结点赋值</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">delete</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> NodeList<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<br> 
<h6><a id="Huffman_1306"></a>Huffman解码</h6> 
<p>采用Huffman算法构造的扩充二叉树即可编码字符集，也用来解码 / 译码二进制代码串。</p> 
<p>译码与编码过程相逆：</p> 
<ul><li>从树的根结点开始 
  <ul><li>沿0下降到左分支，沿1下降到右分支<br> 直到碰到一个叶结点，译出了一个字符</li></ul> </li><li>连续译码 
  <ul><li>回到树根</li><li>从二进制代码串中的下一位开始继续译码</li></ul> </li></ul> 
<p>以下面的示例为例对如何译码Huffman树进行说明，<br> <img src="https://images2.imgbox.com/70/66/BQglkVOx_o.png" alt="在这里插入图片描述" width="350"><br> “111 101110” 即 “d<sub>12</sub>d<sub>2</sub>”。</p> 
<br> 
<h5><a id="_1323"></a>应用</h5> 
<p>Huffman编码适合于：</p> 
<ul><li>字符频率不等、差别较大的字符集</li><li>不同的频率分布会有不同饿压缩比率</li><li>大多数商业压缩软件都是采用几种编码方式以应对各种类型的文件<br> 比如zip压缩就是LZ777与Huffman结合</li><li>组织在外排序的时候归并顺串的时候的归并树，以优化归并趟数，来减少IO的读盘次数，从而提高我们的外排效率</li></ul> 
<br> 
<h5><a id="_1333"></a>正确性证明</h5> 
<h6><a id="_1334"></a>引理</h6> 
<p>引理：<br> 一颗含有两个以上结点的Huffman树中，使用频率最小的两个字符是兄弟结点，而且其深度不比树中其他任何叶结点浅。</p> 
<p><img src="https://images2.imgbox.com/ba/a6/HssSJpkz_o.png" alt="在这里插入图片描述" width="200"><br> 证明：<br> 记使用频率最低的两个字符为 y1 和 y2，y1和y2的父结点为y<br> 假设x1和x2是最深的结点，x1和x2的父结点为x，y一定会有比x更大的 “权”，否则会选择y而不是x作为结点v的子结点。<br> 但是，由于y1和y2是频率最小的字符，所以不可能出现y的权值比x权值还小的情况。</p> 
<br> 
<h6><a id="_1346"></a>定理</h6> 
<p>定理：<br> 对于给定的一组字符，函数Huffman Tree实现了最小外部路径权重。</p> 
<p>证明：<br> 对于字符个数n，可归纳如下：</p> 
<ul><li>归纳基础<br> 令n=2，Huffman树一定有最小外部路径权重 
  <ul><li>只可能有成镜面对称的两种树</li><li>两种树的叶结点加权路径长度相等</li></ul> </li><li>归纳假设<br> 假设由函数HuffmanTree产生的具有n-1个叶结点的Huffman树有最小外部路径权重</li><li>归纳步骤 
  <ul><li>设一颗由函数HuffmanTree产生的树T有n个叶结点，n&gt;2，并假设字符的 “权”，w<sub>0</sub> &lt;= w<sub>1</sub> &lt;= … &lt;= w<sub>n-1</sub> 
    <ul><li>记V是频率为 w<sub>0</sub> 和 w<sub>1</sub> 的两个字符的父结点。据引理，它们已是树T中最深的结点</li><li>T中结点V换为一个叶结点V‘（权等于 w<sub>0</sub>+w<sub>1</sub>）得到另一棵树T‘</li></ul> </li><li>根据归纳假设，T’ 具有最小的外部路径长度，将V‘展开为V(w<sub>0</sub>+w<sub>1</sub>)，T’ 还原为 T，则T也应有最小的外部路径长度</li></ul> </li></ul> 
<p>因此，根据归纳原理，定理成立。</p> 
<br> 
<h5><a id="_1368"></a>编码效率</h5> 
<p>Huffman编码的空间效率评判指标是字符的平均编码长度。</p> 
<p>各字符的编码长度 c<sub>i</sub> 乘以其出现概率 p<sub>i</sub>，即：<br> c<sub>0</sub>p<sub>0</sub> + c<sub>1</sub>p<sub>1</sub> + … + c<sub>n-1</sub>p<sub>n-1</sub><br> 或者，<br> f<sub>i</sub> 表示第i个字符的出现频率，f<sub>T</sub>表示所有字符出现的总次数<br> （c<sub>0</sub>f<sub>0</sub> + c<sub>1</sub>f<sub>1</sub> + … + c<sub>n-1</sub>f<sub>n-1</sub>）/ f<sub>T</sub></p> 
<p>以下面的Huffman树为例说明Huffman的编码效率：</p> 
<p><img src="https://images2.imgbox.com/7e/18/RsAwdIz5_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/58/11/Ycg34VXb_o.png" alt="在这里插入图片描述" width="350"><br> 上面的Huffman树的编码的平均长度是，<br> (3*(19+23+29+31+31+47)) + 4*(11+13+17）+ 4*(11+13+17) + 5<em>7 + 6</em>5 + 7*(2+3)) / 238 = 3.38</p> 
<p>如果将这13个字符进行等长编码，则每个字符的编码平均长度为 log13 = 4位。<br> 然而将这13个字符进行Huffman编码，每个字符的编码平均长度为3.38位。<br> 比起等长编码，Huffman编码只需要等长编码 3.38 / 4 = 84% 的空间。</p> 
<p>再以下面的示例为例体会Huffman的编码效率：<br> 如果存在一个100，000个字符组成的文件，这100，000个字符有6种字符，且这6种字符的出现频率差异较大，如下所示：</p> 
<p><img src="https://images2.imgbox.com/92/16/zdGZLfZt_o.png" alt="在这里插入图片描述"><br> 224，000 / 300，000 = 74 %<br> 使用不等长编码可以节省 26% 的空间。</p> 
<hr> 
<h2><a id="_1397"></a>参考链接</h2> 
<hr class="footnotes-sep"> 
<section class="footnotes"> 
 <ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a href="https://www.icourse163.org/learn/PKU-1002534001?tid=1470937462#/learn/announce" rel="nofollow">数据结构与算法</a> <a href="#fnref1" rel="nofollow" class="footnote-backref">↩︎</a></p> </li></ol> 
</section>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/aa72afb10a6aa3caeee1db2309b42cf4/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">报错解决：RuntimeError: Error compiling objects for extension和nvcc fatal: Unsupported gpu architecture</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3e04ecfd01454493fbaac396e98b82e0/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【shell脚本实战案例】awk实现行转列数据变换</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>