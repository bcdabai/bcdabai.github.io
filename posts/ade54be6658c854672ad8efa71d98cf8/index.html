<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Promise.resolve()与new Promise(r =&gt; r(v)) - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Promise.resolve()与new Promise(r =&gt; r(v))" />
<meta property="og:description" content="Promise.resolve方法的参数分成四种情况。 参数是一个 Promise 实例 如果参数是 Promise 实例，那么Promise.resolve将不做任何修改、原封不动地返回这个实例。
这是一个特殊的情况会和另一种new Promise(r =&gt; r(v))产生不一样的效果，最后说明
参数是一个thenable对象 thenable对象指的是具有then方法的对象，比如下面这个对象
let thenable = { then: function(resolve, reject) { resolve(42); } }; Promise.resolve方法会将这个对象转为 Promise 对象，然后就立即执行thenable对象的then方法。
let thenable = { then: function(resolve, reject) { resolve(42); } }; let p1 = Promise.resolve(thenable); p1.then(function(value) { console.log(value); // 42 }); thenable对象的then方法执行后，对象p1的状态就变为resolved，从而立即执行最后那个then方法指定的回调函数，输出 42
参数不是具有then方法的对象，或根本就不是对象 如果参数是一个原始值，或者是一个不具有then方法的对象，则Promise.resolve方法返回一个新的 Promise 对象，状态为resolved。
const p = Promise.resolve(&#39;Hello&#39;); p.then(function (s){ console.log(s) }); // Hello 由于字符串Hello不属于异步操作（判断方法是字符串对象不具有 then 方法），返回 Promise 实例的状态从一生成就是resolved，所以回调函数会执行。Promise.resolve方法的参数，会同时传给回调函数" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/ade54be6658c854672ad8efa71d98cf8/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-03-13T12:15:54+08:00" />
<meta property="article:modified_time" content="2020-03-13T12:15:54+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Promise.resolve()与new Promise(r =&gt; r(v))</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3 id="item-1">Promise.resolve方法的参数分成四种情况。</h3> 
<h4 id="item-1-1"><strong>参数是一个 Promise 实例</strong></h4> 
<p>如果参数是 Promise 实例，那么Promise.resolve将不做任何修改、原封不动地返回这个实例。<br><strong>这是一个特殊的情况会和另一种new Promise(r =&gt; r(v))产生不一样的效果，最后说明</strong></p> 
<h4 id="item-1-2"><strong>参数是一个thenable对象</strong></h4> 
<p>thenable对象指的是具有then方法的对象，比如下面这个对象</p> 
<pre><code>let thenable = {
  then: function(resolve, reject) {
    resolve(42);
  }
};
</code></pre> 
<p>Promise.resolve方法会将这个对象转为 Promise 对象，然后就立即执行thenable对象的then方法。</p> 
<pre><code>let thenable = {
  then: function(resolve, reject) {
    resolve(42);
  }
};

let p1 = Promise.resolve(thenable);
p1.then(function(value) {
  console.log(value);  // 42
});
</code></pre> 
<p>thenable对象的then方法执行后，对象p1的状态就变为resolved，从而立即执行最后那个then方法指定的回调函数，输出 42</p> 
<h4 id="item-1-3"><strong>参数不是具有then方法的对象，或根本就不是对象</strong></h4> 
<p>如果参数是一个原始值，或者是一个不具有then方法的对象，则Promise.resolve方法返回一个<strong>新的 Promise 对象</strong>，状态为resolved。</p> 
<pre><code>const p = Promise.resolve('Hello');

p.then(function (s){
  console.log(s)
});
// Hello</code></pre> 
<p>由于字符串Hello不属于异步操作（判断方法是字符串对象不具有 then 方法），返回 Promise 实例的状态从一生成就是resolved，所以回调函数会执行。Promise.resolve方法的参数，会同时传给回调函数</p> 
<h4 id="item-1-4"><strong>不带有任何参数</strong></h4> 
<p>Promise.resolve方法允许调用时不带参数，直接返回一个resolved状态的 Promise 对象。</p> 
<pre><code>setTimeout(function () {
  console.log('three');
}, 0);

Promise.resolve().then(function () {
  console.log('two');
});

console.log('one');

// one
// two
// three
</code></pre> 
<p>.then()函数里不返回值或者返回的不是promise，那么 <code>then</code> 返回的 Promise 将会成为接受状态（resolve）</p> 
<pre><code>Promise.resolve().then(() =&gt; console.log(2)).then(() =&gt; console.log(3));
console.log(1); // 1, 2, 3</code></pre> 
<p>需要注意的是，<strong>立即resolve的 Promise 对象，是在本轮“事件循环”（event loop）的结束时执行执行，不是马上执行,也不是在下一轮“事件循环”的开始时执行</strong><br> 原因：传递到 <code>then()</code> 中的函数被置入了一个微任务队列，而不是立即执行，这意味着它是在 JavaScript 事件队列的所有运行时结束了，事件队列被清空之后，才开始执行</p> 
<h3 id="item-2"><code>Promise.resolve(v)</code>不等于<code>new Promise(r =&gt; r(v))</code></h3> 
<p><strong>当v是一个Promise实例的时候就会出现一些不同的地方</strong></p> 
<pre><code>    // v是一个实例化的promise，且状态为fulfilled
    let v = new Promise(resolve =&gt; {
      console.log("begin");
      resolve("then");
    });

    // 在promise里面resolve一个状态为fulfilled的promise

    // 模式一 new Promise里的resolve()
    // begin-&gt;1-&gt;2-&gt;3-&gt;then-&gt;4 可以发现then推迟了两个时序
    // 推迟原因：浏览器会创建一个 PromiseResolveThenableJob 去处理这个 Promise 实例，这是一个微任务。
    // 等到下次循环到来这个微任务会执行，也就是PromiseResolveThenableJob 执行中的时候，因为这个Promise 实例是fulfilled状态，所以又会注册一个它的.then()回调
    // 又等一次循环到这个Promise 实例它的.then()回调执行后，才会注册下面的这个.then(),于是就被推迟了两个时序
    new Promise(resolve =&gt; {
      resolve(v);
    }).then((v)=&gt;{
        console.log(v)
    });

    //  模式二 Promise.resolve(v)直接创建
    // begin-&gt;1-&gt;then-&gt;2-&gt;3-&gt;4 可以发现then的执行时间正常了，第一个执行的微任务就是下面这个.then
    // 原因：Promise.resolve()API如果参数是promise会直接返回这个promise实例，不会做任何处理
/*     Promise.resolve(v).then((v)=&gt;{
        console.log(v)
    }); */

    new Promise(resolve =&gt; {
      console.log(1);
      resolve();
    })
      .then(() =&gt; {
        console.log(2);
      })
      .then(() =&gt; {
        console.log(3);
      })
      .then(() =&gt; {
        console.log(4);
      });</code></pre> 
<h3 id="item-3">resolve()本质作用</h3> 
<ul><li>resolve()是用来表示promise的状态为fullfilled，相当于只是定义了一个有状态的Promise，但是并没有调用它；</li><li>promise调用then的前提是promise的状态为fullfilled；</li><li>只有promise调用then的时候，then里面的函数才会被推入微任务中；</li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/19aa043f2f4b81cda06dff3ea6138c29/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">AI初探——百度、阿里、腾讯开放平台OCR功能解析</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e8afd188db8cb2b9e087914767fc21ec/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">免费CDN：jsDeliver-Github-搭建过程记录</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>