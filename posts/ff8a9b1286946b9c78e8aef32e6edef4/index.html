<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>SpringBoot的统一功能处理 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="SpringBoot的统一功能处理" />
<meta property="og:description" content="目录
1.统一用户的的登录权限校验
最开始的用户登录
Spring拦截器
2.统一数据返回格式
统一数据的返回格式意义
统一数据返回格式的实现
3.统一异常处理
在上篇博客中我介绍了Spring AOP的基础知识,这篇博客则是AOP的实践练习,通过借助AOP实现三个目标
1.统一用户登录权限的校验
2.统一数据的返回格式
3.统一异常处理
接下来我们一个一个来实现
1.统一用户的的登录权限校验 最开始的用户登录 在实现统一用户登录之前先回顾一下之前如何判断用户登录的
@RestController @RequestMapping(&#34;/user&#34;) public class UserController { /** * 某⽅法 1 */ @RequestMapping(&#34;/m1&#34;) public Object method(HttpServletRequest request) { // 有 session 就获取，没有不会创建 HttpSession session = request.getSession(false); if (session != null &amp;&amp; session.getAttribute(&#34;userinfo&#34;) != null) { // 说明已经登录，业务处理 return true; } else { // 未登录 return false; } } } 可以看到为完成登录校验判断就需要在方法中单独写判断方法,封装成公共方法也需要进行调用,如果校验方法修改那么所有调用都需要修改,这将大大增加代码的维护成本,并且这些登录校验代码与所要写的业务代码并无关系但还是需要写出来,所以就需要提供AOP来解决这个问题
当想使用Spring AOP的环绕方法解决问题时我们发现无法获取到HttpSession对象并且有一些方法是不需要拦截的,此时无法准确使用切点定义拦截规则,如何接解决问题呢?可以使用Spring拦截器
Spring拦截器 Spring提供了拦截器:HandlerInterceptor,拦截器实现分为两个步骤" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/ff8a9b1286946b9c78e8aef32e6edef4/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-04-16T09:39:38+08:00" />
<meta property="article:modified_time" content="2023-04-16T09:39:38+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">SpringBoot的统一功能处理</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="1.%E7%BB%9F%E4%B8%80%E7%94%A8%E6%88%B7%E7%9A%84%E7%9A%84%E7%99%BB%E5%BD%95%E6%9D%83%E9%99%90%E6%A0%A1%E9%AA%8C-toc" style="margin-left:40px;"><a href="#1.%E7%BB%9F%E4%B8%80%E7%94%A8%E6%88%B7%E7%9A%84%E7%9A%84%E7%99%BB%E5%BD%95%E6%9D%83%E9%99%90%E6%A0%A1%E9%AA%8C" rel="nofollow">1.统一用户的的登录权限校验</a></p> 
<p id="%E6%9C%80%E5%BC%80%E5%A7%8B%E7%9A%84%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95-toc" style="margin-left:80px;"><a href="#%E6%9C%80%E5%BC%80%E5%A7%8B%E7%9A%84%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95" rel="nofollow">最开始的用户登录</a></p> 
<p id="Spring%E6%8B%A6%E6%88%AA%E5%99%A8-toc" style="margin-left:80px;"><a href="#Spring%E6%8B%A6%E6%88%AA%E5%99%A8" rel="nofollow">Spring拦截器</a></p> 
<p id="2.%E7%BB%9F%E4%B8%80%E6%95%B0%E6%8D%AE%E8%BF%94%E5%9B%9E%E6%A0%BC%E5%BC%8F-toc" style="margin-left:40px;"><a href="#2.%E7%BB%9F%E4%B8%80%E6%95%B0%E6%8D%AE%E8%BF%94%E5%9B%9E%E6%A0%BC%E5%BC%8F" rel="nofollow">2.统一数据返回格式</a></p> 
<p id="%E7%BB%9F%E4%B8%80%E6%95%B0%E6%8D%AE%E7%9A%84%E8%BF%94%E5%9B%9E%E6%A0%BC%E5%BC%8F%E6%84%8F%E4%B9%89-toc" style="margin-left:80px;"><a href="#%E7%BB%9F%E4%B8%80%E6%95%B0%E6%8D%AE%E7%9A%84%E8%BF%94%E5%9B%9E%E6%A0%BC%E5%BC%8F%E6%84%8F%E4%B9%89" rel="nofollow">统一数据的返回格式意义</a></p> 
<p id="%E7%BB%9F%E4%B8%80%E6%95%B0%E6%8D%AE%E8%BF%94%E5%9B%9E%E6%A0%BC%E5%BC%8F%E7%9A%84%E5%AE%9E%E7%8E%B0-toc" style="margin-left:80px;"><a href="#%E7%BB%9F%E4%B8%80%E6%95%B0%E6%8D%AE%E8%BF%94%E5%9B%9E%E6%A0%BC%E5%BC%8F%E7%9A%84%E5%AE%9E%E7%8E%B0" rel="nofollow">统一数据返回格式的实现</a></p> 
<p id="3.%E7%BB%9F%E4%B8%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86-toc" style="margin-left:40px;"><a href="#3.%E7%BB%9F%E4%B8%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86" rel="nofollow">3.统一异常处理</a></p> 
<hr id="hr-toc"> 
<p>在上篇博客中我介绍了Spring AOP的基础知识,这篇博客则是AOP的实践练习,通过借助AOP实现三个目标</p> 
<p>1.统一用户登录权限的校验</p> 
<p>2.统一数据的返回格式</p> 
<p>3.统一异常处理</p> 
<p>接下来我们一个一个来实现</p> 
<h3 id="1.%E7%BB%9F%E4%B8%80%E7%94%A8%E6%88%B7%E7%9A%84%E7%9A%84%E7%99%BB%E5%BD%95%E6%9D%83%E9%99%90%E6%A0%A1%E9%AA%8C">1.统一用户的的登录权限校验</h3> 
<h4 id="%E6%9C%80%E5%BC%80%E5%A7%8B%E7%9A%84%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95">最开始的用户登录</h4> 
<p>在实现统一用户登录之前先回顾一下之前如何判断用户登录的</p> 
<pre><code>@RestController
@RequestMapping("/user")
public class UserController {
    /**
     * 某⽅法 1
     */
    @RequestMapping("/m1")
    public Object method(HttpServletRequest request) {
        // 有 session 就获取，没有不会创建
        HttpSession session = request.getSession(false);
        if (session != null &amp;&amp; session.getAttribute("userinfo") != null) {
            // 说明已经登录，业务处理
            return true;
        } else {
            // 未登录
            return false;
        }
    }
}</code></pre> 
<p>可以看到为完成登录校验判断就需要在方法中单独写判断方法,封装成公共方法也需要进行调用,如果校验方法修改那么所有调用都需要修改,这将大大增加代码的维护成本,并且这些登录校验代码与所要写的业务代码并无关系但还是需要写出来,所以就需要提供AOP来解决这个问题</p> 
<p>当想使用Spring AOP的环绕方法解决问题时我们发现无法获取到HttpSession对象并且有一些方法是不需要拦截的,此时无法准确使用切点定义拦截规则,如何接解决问题呢?可以使用Spring拦截器</p> 
<h4 id="Spring%E6%8B%A6%E6%88%AA%E5%99%A8">Spring拦截器</h4> 
<p>Spring提供了拦截器:HandlerInterceptor,拦截器实现分为两个步骤</p> 
<p>1.创建自定义拦截器<strong>,实现HandlerInterceptor接口重写preHandle方法</strong>(返回boolean)</p> 
<pre><code>**
 * 登录拦截器
 */
@Component
public class LoginInterceptor implements HandlerInterceptor {
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        HttpSession session=request.getSession(false);
        if(session!=null &amp;&amp; session.getAttribute("userinfo'")!=null) {
            return true;
        }
        response.setStatus(401);
        return false;
    }
}</code></pre> 
<p>2.配置拦截规则 <strong>实现WebMvcConfigurer接口重写addInterceptors方法</strong>将自定义拦截器添加到addInterceptors中</p> 
<pre><code>@Configuration
public class MyConfig implements WebMvcConfigurer {
    @Autowired
    private LoginInterceptor loginInterceptor;
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(loginInterceptor)
                .addPathPatterns("/**")//拦截所有请求
                .excludePathPatterns("/user/login")
                .excludePathPatterns("/user/reg");//排除不拦截的url
    }
}</code></pre> 
<blockquote> 
 <p>addPathPatterns()表示拦截的URL</p> 
 <p>excludePathPatterns()表示排除的URL</p> 
</blockquote> 
<p>以上拦截规则可以拦截项目中的URL,包括静态文件(图片/JS/CSS)</p> 
<h3 id="2.%E7%BB%9F%E4%B8%80%E6%95%B0%E6%8D%AE%E8%BF%94%E5%9B%9E%E6%A0%BC%E5%BC%8F">2.统一数据返回格式</h3> 
<h4 id="%E7%BB%9F%E4%B8%80%E6%95%B0%E6%8D%AE%E7%9A%84%E8%BF%94%E5%9B%9E%E6%A0%BC%E5%BC%8F%E6%84%8F%E4%B9%89">统一数据的返回格式意义</h4> 
<p>1.方便前端程序员更好获取和解析后端数据接口返回的数据</p> 
<p>2.减低前后端程序员因为数据形式的沟通成本,按照相同格式所有的接口返回数据格式相同</p> 
<p>3.有利于代码的维护和修改</p> 
<h4 id="%E7%BB%9F%E4%B8%80%E6%95%B0%E6%8D%AE%E8%BF%94%E5%9B%9E%E6%A0%BC%E5%BC%8F%E7%9A%84%E5%AE%9E%E7%8E%B0">统一数据返回格式的实现</h4> 
<p>统一数据返回格式是通过<strong>@ControllerAdvice+ResponseBodyAdvice</strong>的方式实现</p> 
<pre><code class="hljs">/**
 * 统一功能的处理
 */
@ControllerAdvice
public class ResponseAdvice implements ResponseBodyAdvice {

    @Override
    public boolean supports(MethodParameter returnType, Class converterType) {
        return true;
    }

    @Override
    public Object beforeBodyWrite(Object body, MethodParameter returnType, MediaType selectedContentType, Class selectedConverterType, ServerHttpRequest request, ServerHttpResponse response) {
        HashMap&lt;String,Object&gt; result=new HashMap&lt;&gt;();
        result.put("code","200");
        result.put("msg","");
        result.put("data",body);
        return result;
    }
}</code></pre> 
<p>注意:实现ResponseBodyAdvice接口重写两个方法</p> 
<p>1.supports()方法返回值需要改为true,表示内容是否需要重写</p> 
<p>2.beforeBodyWrite()方法中就可以通过返回对象统一数据的返回格式了</p> 
<p><img alt="" height="61" src="https://images2.imgbox.com/6b/d5/tlt7D1sW_o.png" width="506"></p> 
<p> 可以看到我们数据的返回值不再是方法定义的String 或Boolean类型而是统一封装的返回格式</p> 
<h3 id="3.%E7%BB%9F%E4%B8%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86">3.统一异常处理</h3> 
<p>统一异常处理使用的是<strong>@ControllerAdvice+@ExceptionHandler</strong>来实现的</p> 
<pre><code>/**
 * 统一处理异常
 */
@ControllerAdvice
@ResponseBody
public class ErrorAdvice {
    @ExceptionHandler(Exception.class)
    public HashMap&lt;String,Object&gt; exAdvice(Exception e) {
        HashMap&lt;String,Object&gt;result=new HashMap&lt;&gt;();
        result.put("code","-1");
        result.put("msg",e.getMessage());
        return result;
    }
}</code></pre> 
<p><img alt="" height="435" src="https://images2.imgbox.com/ea/91/E3HmNJ4o_o.png" width="930"></p> 
<p> 通过上面的方法我们可以看到,如果出现了异常就会给前端一个HashMap对象,其中字段内容就是代码所写的</p> 
<p>当有多个异常通知时,匹配顺序为当前类及其子类向上匹配,也就是说如果封装了对应的异常则会走对应通知,反之由Exception作为最后的兜底进行通知</p> 
<p><img alt="" height="643" src="https://images2.imgbox.com/3b/c2/iob2zfe9_o.png" width="1200"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/36bcd2e6855efd5bba8cd7d26325a06f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">使用Vagrant搭建本地虚拟机开发环境</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/49b13fc01c9dffed711708ee0388170d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">2023年超实用的27个VSCode插件推荐</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>