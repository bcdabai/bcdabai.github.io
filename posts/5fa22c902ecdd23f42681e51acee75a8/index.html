<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Truetype&amp;Harfbuzz&amp;FreeType联合应用完全解析（二） - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Truetype&amp;Harfbuzz&amp;FreeType联合应用完全解析（二）" />
<meta property="og:description" content="本章主要简单介绍FreeType，以及结合TrueType来写一个代码示例
你将学习到的知识点有
什么是FreeType，它和TrueType、OpenTrue有什么联系写代码实现使用FreeType读取TrueType字体文件，生成位图数据，然后在屏幕上把位图数据显示出来。笔者使用Qt的窗口来模拟屏幕，实现真正的从字符串数据到可视的字符的效果。效果图如下：
TrueType和FreeType的简单应用 1. FreeType介绍2.TrueType&#43;FreeType生成位图数据总结 1. FreeType介绍 百度百科：FreeType库是一个完全免费（开源）的、高质量的且可移植的字体引擎，它提供统一的接口来访问多种字体格式文件，包括TrueType, OpenType, Type1, CID, CFF, Windows FON/FNT, X11 PCF等。支持单色位图、反走样位图的渲染。
直白地说，freetype就是用来生成字体的位图的一个开源函数库。它可以渲染truetype、opentype、type1等字体文件。truetype在上一篇博客已经介绍过，而opentype是truetype的一个升级版。opentype是Microsoft和Adobe之间竞争与合作的产物，它嵌入了PostScript字体，功能更加强大。
2.TrueType&#43;FreeType生成位图数据 准备材料：
truetype字体文件KhmerUI.ttf，这是高棉语的字体文件freetype字体引擎源码，这里使用的是freetype-2.10.1ubuntu16.04，我是虚拟机里面运行的安装Qt Creator 以上材料的下载链接在这里。
ubuntu16.04安装freetype：
一般在ubuntu下，解压并进入源码根目录，直接：
./configure make sudo make install 三部曲，我选择最简单的安装方式。安装过程中可能会出现依赖问题，请自行查找资料解决。
ubuntu16.04安装Qt Creator
使用Qt是为了模拟屏幕来显示渲染出来的字符位图数据，我使用的Qt版本是Qt Creator 3.4.2 (opensource)，读者可以去Qt官网上直接下载安装文件。
工作流程
回顾一下前一章的freetype加载字符到渲染出字符的点阵数据的流程
初始化freetype库使用freetype库打开truetype文件（一般是.tty后缀的文件），加载字符的全部数据设置字符的大小根据要显示的字符设置字符的编码方式，freetype默认使用的是Unicode编码。一般情况是这样的：
（1）要显示的字符使用utf8格式编码
（2）使用freetype渲染前，需要将utf8转换Unicode编码，转换算法网上可以搜索到很多渲染字符成为需要的点阵数据，然后一个个刷到屏幕上字符的显示的位置要根据字符的度量调整，才能正常显示 开始写代码：
目录结构 . ├── contrib -----第三方库头文件 │ ├── freetype2	-------freetype2库的头文件 ├── encoding_conv.c ----utf8转换成ucs2的函数接口 ├── encoding_conv.h ├── font.qrc ├── fonts │ └── KhmerUI.ttf -------高棉语truetype文件 ├── lib │ ├── freetype-2." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/5fa22c902ecdd23f42681e51acee75a8/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-06-06T15:43:09+08:00" />
<meta property="article:modified_time" content="2020-06-06T15:43:09+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Truetype&amp;Harfbuzz&amp;FreeType联合应用完全解析（二）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><strong>本章主要简单介绍FreeType，以及结合TrueType来写一个代码示例</strong><br> <strong>你将学习到的知识点有</strong></p> 
<ol><li>什么是FreeType，它和TrueType、OpenTrue有什么联系</li><li>写代码实现使用FreeType读取TrueType字体文件，生成位图数据，然后在屏幕上把位图数据显示出来。笔者使用Qt的窗口来模拟屏幕，实现真正的从字符串数据到可视的字符的效果。效果图如下：<br> <img src="https://images2.imgbox.com/c0/01/9H03rL3B_o.png" alt="在这里插入图片描述"><br> 
  <div class="toc"> 
   <h4>TrueType和FreeType的简单应用</h4> 
   <ul><li><ul><li><a href="#1_FreeType_6" rel="nofollow">1. FreeType介绍</a></li><li><a href="#2TrueTypeFreeType_11" rel="nofollow">2.TrueType+FreeType生成位图数据</a></li><li><a href="#_265" rel="nofollow">总结</a></li></ul> 
   </li></ul> 
  </div></li></ol> 
<h3><a id="1_FreeType_6"></a>1. FreeType介绍</h3> 
<p><strong>百度百科</strong>：FreeType库是一个完全免费（开源）的、高质量的且可移植的字体引擎，它提供统一的接口来访问多种字体格式文件，包括TrueType, OpenType, Type1, CID, CFF, Windows FON/FNT, X11 PCF等。支持单色位图、反走样位图的渲染。</p> 
<p>直白地说，freetype就是用来生成字体的位图的一个开源函数库。它可以渲染truetype、opentype、type1等字体文件。truetype在上一篇博客已经介绍过，而opentype是truetype的一个升级版。opentype是Microsoft和Adobe之间竞争与合作的产物，它嵌入了PostScript字体，功能更加强大。</p> 
<h3><a id="2TrueTypeFreeType_11"></a>2.TrueType+FreeType生成位图数据</h3> 
<p><strong>准备材料：</strong></p> 
<ul><li>truetype字体文件KhmerUI.ttf，这是高棉语的字体文件</li><li>freetype字体引擎源码，这里使用的是freetype-2.10.1</li><li>ubuntu16.04，我是虚拟机里面运行的</li><li>安装Qt Creator</li></ul> 
<p>以上材料的下载链接在<a href="https://download.csdn.net/download/slov8/12502843">这里</a>。</p> 
<p><strong>ubuntu16.04安装freetype：</strong><br> 一般在ubuntu下，解压并进入源码根目录，直接：</p> 
<pre><code>./configure
make 
sudo make install
</code></pre> 
<p>三部曲，我选择最简单的安装方式。安装过程中可能会出现依赖问题，请自行查找资料解决。</p> 
<p><strong>ubuntu16.04安装Qt Creator</strong><br> 使用Qt是为了模拟屏幕来显示渲染出来的字符位图数据，我使用的Qt版本是Qt Creator 3.4.2 (opensource)，读者可以去Qt<a href="http://download.qt.io/archive/qt/" rel="nofollow">官网</a>上直接下载安装文件。</p> 
<p><strong>工作流程</strong><br> 回顾一下前一章的freetype加载字符到渲染出字符的点阵数据的流程</p> 
<ol><li>初始化freetype库</li><li>使用freetype库打开truetype文件（一般是.tty后缀的文件），加载字符的全部数据</li><li>设置字符的大小</li><li>根据要显示的字符设置字符的编码方式，freetype默认使用的是Unicode编码。一般情况是这样的：<br> （1）要显示的字符使用utf8格式编码<br> （2）使用freetype渲染前，需要将utf8转换Unicode编码，转换算法网上可以搜索到很多</li><li>渲染字符成为需要的点阵数据，然后一个个刷到屏幕上</li><li>字符的显示的位置要根据字符的度量调整，才能正常显示</li></ol> 
<p><strong>开始写代码：</strong></p> 
<ul><li>目录结构</li></ul> 
<pre><code>.
├── contrib                -----第三方库头文件
│   ├── freetype2		-------freetype2库的头文件
├── encoding_conv.c    ----utf8转换成ucs2的函数接口
├── encoding_conv.h
├── font.qrc
├── fonts
│   └── KhmerUI.ttf      -------高棉语truetype文件
├── lib
│   ├── freetype-2.10.1   -------freetype2的共享库文件
├── main.cpp
├── mainwin.cpp
├── mainwin.h
├── qt_font_freetype.pro     ------Qt工程文件
└── qt_font_freetype.pro.user
</code></pre> 
<p>首先使用Qt Creator创建工程，添加代码和相应的文件</p> 
<ul><li>主要代码分析</li></ul> 
<pre><code>// mainwin.h
#ifndef MAINWIN_H
#define MAINWIN_H

#include &lt;QWidget&gt;

class MainWin : public QWidget
{
    Q_OBJECT

public:
    MainWin(QWidget *parent = 0);
    ~MainWin();
    quint32 screen_width();
    quint32 screen_height();
    quint8 screen_pixel_mode();
    bool set_simulator_screen_color(quint32 color);

    qint32 draw_text(int x, int y, char *text, unsigned int color, int font_size);

protected:
    void paintEvent(QPaintEvent *event);

private:
   unsigned int* simulator_screen;
   quint32 simulator_screen_width;
   quint32 simulator_screen_height;
   quint8 pixel_mode;
   QPixmap* screen_pixmap;
   // truetype文件的路径，需要根据自己的需要设置
   char* ttf_file = "/home/chen/gui_workspace/qt_font_freetype/fonts/KhmerUI.ttf";
};

#endif // MAINWIN_H
</code></pre> 
<pre><code>//mainwin构造函数
MainWin::MainWin(QWidget *parent)
    : QWidget(parent)
{
    simulator_screen_width = 500;
    simulator_screen_height = 300;
    //设置窗口大小
    resize(QSize(simulator_screen_width, simulator_screen_height));
    //像素模式使用argb 4个字节
    pixel_mode = 4;
    //此处分配的内存用于模拟显存
    simulator_screen = (unsigned int *)qMallocAligned(simulator_screen_width*simulator_screen_height*pixel_mode, 1);
    
    if (simulator_screen == Q_NULLPTR)
    {
       qDebug("simulator_screen malloc failed\n");
    }
    set_simulator_screen_color(WHITE_COLOR);
    //调用自己实现的draw_text把字符显示到窗口
    draw_text(40， 40， "This is a FreeType test!", RED_COLOR, 27);
}
</code></pre> 
<pre><code>//draw_text函数实现，此处是本篇最重要的代码
qint32 MainWin::draw_text(int x, int y, char *utf8_text, unsigned int color, int font_size)
{
    int i = 0;
    int j = 0;
    int a = 0;
    int b = 0;
    int k = 0;
    int error;
    int whcar_len;
    int width = 0;
    int m_font_size = font_size;
    wchar_t *ucs2_text;
    int length;
    unsigned int draw_color;
    int pen_x = x;
    int pen_y = y;

    FT_Face FTFace;
    FT_Library library;
    FT_UInt glyphIndex;

    if (utf8_text == NULL)
    {
        return 0;
    }

    if (font_size &lt; 0)
    {
        m_font_size = 18;
    }

    length = strlen(utf8_text) + 1;
    ucs2_text = (wchar_t *)malloc(length * sizeof(ucs2_text));
    if (!ucs2_text)
    {
        return 0;
    }

    utf8_to_ucs2(utf8_text, length, ucs2_text, length);
    whcar_len = wcslen(ucs2_text);

    if (FT_Init_FreeType(&amp;library) != 0)
    {
        qDebug("error func:%s line:%d \r\n",__FUNCTION__,__LINE__);
        return 0;
    }

    if (FT_New_Face(library, ttf_file, 0, &amp;FTFace) != 0)
    {
        qDebug("error func:%s line:%d \r\n",__FUNCTION__,__LINE__);
        return 0;
    }

    FT_Set_Char_Size(FTFace, 0, m_font_size * 64, 96, 96);

    for (k = 0; k &lt; whcar_len; k++)
    {
        glyphIndex = FT_Get_Char_Index(FTFace, ucs2_text[k]);
        error = FT_Load_Glyph(FTFace, glyphIndex, FT_LOAD_DEFAULT);
        if (error)
        {
            qDebug("error func:%s line:%d \r\n",__FUNCTION__,__LINE__);
            continue;
        }
        error = FT_Render_Glyph(FTFace-&gt;glyph, ft_render_mode_normal);
        if (error)
        {
            qDebug("error func:%s line:%d \r\n",__FUNCTION__,__LINE__);
            continue;
        }
        FT_GlyphSlot slot = FTFace-&gt;glyph;
        FT_Glyph_Metrics metrics = FTFace-&gt;glyph-&gt;metrics;
        FT_Bitmap bitmap = slot-&gt;bitmap;
        qDebug("slot-&gt;bitmap_left = %d, slot-&gt;bitmap_top = %d, bitmap.rows = %d, bitmap.width = %d\n", slot-&gt;bitmap_left, slot-&gt;bitmap_top, bitmap.rows, bitmap.width);
        qDebug("metrics.height&gt;&gt;6 = %d, metrics.width&gt;&gt;6 = %d, metrics.vertBearingX&gt;&gt;6 = %d, metrics.vertBearingY&gt;&gt;6 = %d\n", metrics.height&gt;&gt;6, metrics.width&gt;&gt;6, metrics.vertBearingX&gt;&gt;6, metrics.vertBearingY&gt;&gt;6);

        for (a = 0, j = pen_y; j &lt; simulator_screen_height &amp;&amp; a &lt; bitmap.rows; j++, a++)
        {
            for (b = 0, i = pen_x; i &lt; simulator_screen_width &amp;&amp; b &lt; bitmap.width; i++, b++)
            {
                draw_color = (color &amp; 0x00ffffff) | (bitmap.buffer[ a*bitmap.width + b ] &lt;&lt; 24);
                //把字符的点阵数据放到显存中
                simulator_screen[j*simulator_screen_width + i] = draw_color;
            }
        }

        width += slot-&gt;advance.x &gt;&gt; 6;
        pen_x += slot-&gt;advance.x &gt;&gt; 6; //增加水平方向上的画笔的位置
    }
    qDebug(" %s width = %d\n", __FUNCTION__, width);
    //重新刷新窗口，也就是会自动调用窗口的paintEvent函数，重载了窗口的paintEvent函数，然在里面把显存的数据刷新出来
    this-&gt;repaint();
    return width;
}
</code></pre> 
<pre><code>//重载窗口的paintEvent函数
void MainWin::paintEvent(QPaintEvent *event)
{
    QPainter painter(this);
    QImage image((uchar *)simulator_screen, screen_width(), screen_height(), screen_width()*screen_pixel_mode(), QImage::Format_ARGB32);//data数组 //355宽度 //frame_len 高度//每行字节数//格式
    QPixmap pixmap=QPixmap::fromImage(image);
    painter.drawPixmap(this-&gt;rect(), pixmap);
}
</code></pre> 
<ul><li>显示效果1<br> <img src="https://images2.imgbox.com/83/e6/ejY2BCgh_o.png" alt="在这里插入图片描述"><br> 由以上显示效果可以看出，字符串是显示出来了，但是好像有些奇怪，垂直方向的字距有问题。原因是垂直方向上没有进行字距调整，freetype渲染出来的位图大小不一定都是相同的，但是freetype有预设了全局的字符串大小，通过FTFace-&gt;size可以访问。预设全局大小意味着这是一个合适的大小值，而且全部的字符大小都不会超过它。以下是字距调整的代码：</li></ul> 
<pre><code>		//其实只需要再画每一个字符前，调整一下坐标就可以了
        pen_x += slot-&gt;bitmap_left;
        pen_y = (FTFace-&gt;size-&gt;metrics.ascender &gt;&gt; 6) - slot-&gt;bitmap_top;

        for (a = 0, j = pen_y; j &lt; simulator_screen_height &amp;&amp; a &lt; bitmap.rows; j++, a++)
        {
            for (b = 0, i = pen_x; i &lt; simulator_screen_width &amp;&amp; b &lt; bitmap.width; i++, b++)
            {
                draw_color = (color &amp; 0x00ffffff) | (bitmap.buffer[ a*bitmap.width + b ] &lt;&lt; 24);
                simulator_screen[j*simulator_screen_width + i] = draw_color;
            }
        }
</code></pre> 
<p>以下是垂直字距调整后的显示效果：</p> 
<ul><li>显示效果2<img src="https://images2.imgbox.com/f7/48/zBUBvtCt_o.png" alt="在这里插入图片描述"><br> 对于垂直字距调整的代码：</li></ul> 
<pre><code>        pen_x += slot-&gt;bitmap_left;
        pen_y = (FTFace-&gt;size-&gt;metrics.ascender &gt;&gt; 6) - slot-&gt;bitmap_top;
</code></pre> 
<p><strong>为什么这样写？以下是答案：</strong><br> 我们的屏幕坐标轴使用的是如下图所示的坐标轴，Y轴向下增长：</p> 
<p><img src="https://images2.imgbox.com/c4/7b/swV5F1As_o.png" alt="在这里插入图片描述"><br> 而freetype渲染出来的位图的坐标是和笛卡尔坐标，即x轴水平向右增长，y轴垂直向上增长。<br> 所以对应于 slot-&gt;bitmap_left，slot-&gt;bitmap_top，FTFace-&gt;size-&gt;metrics.ascender就很好理解。如下图所示：</p> 
<p><img src="https://images2.imgbox.com/ea/4a/WTN1vNtd_o.png" alt="在这里插入图片描述"><br> <strong>黑色的矩形框是预设的全局字符大小，是固定的，显示的字符一般不能超过它的大小。但是渲染出来的点阵数据的bitmap_left和bitmap_top不是固定的，所以如果不进行字距调整的话，就会显示地很奇怪。其中FTFace-&gt;size-&gt;metrics.ascender &gt;&gt; 6，&gt;&gt;6表示这个数是26.6格式数，所以要除以64</strong></p> 
<h3><a id="_265"></a>总结</h3> 
<ol><li>truetype font技术描述了字体的各种规则方式，如点和线构成了笔画（Contour），其中曲线使用二阶贝塞尔样条（Bezier-spline）来描述；Contour又组成了最小的描画单位glyph；还有虚拟框EM、坐标空间、转换规则等等。</li><li>truptype文件是truetype font技术的具体的实现载体</li><li>freetype库是truetype的字体引擎，说白了使用freetype就可以翻译truetype描述的各种规则，然后根据这些规则来获得想要的点阵数据</li><li>笔者搜索了很多网上关于freetype技术的博客，发现几乎都是给出了几行实例的代码，还有一些介绍性的文字，没有让人可以真正得看到一些实际的效果，或者实际的可操作性也不强。本文使用QT的窗口来实现字符的显示效果，能让人从抽象都具体，由浅入深地理解freetype和truetype相关的技术</li></ol> 
<p><strong>拓展</strong><br> freetype一般情况下只能按照给定字符顺序一个个地把字符渲染成点阵数据，但是在某些语言中，如果某两个字符相邻组合在一起可能需要变化成另外一个字符，如"fi"两个相邻组合到一起可能要写成：<br> <img src="https://images2.imgbox.com/b8/09/8aeLwQ7j_o.png" alt="在这里插入图片描述"><br> 可能语义也会发生改变。这些都是一些特殊的规则，可能这些规则在truetype font中属于一种自定义的规则，因为它是属于某一种语言的，它不是通用的，它是由具体的字体设计厂商规定的。能解决这种问题的一个方法是使用harfbuzz整形引擎，这将在下一篇博客介绍。</p> 
<hr> 
<p>他时若遂凌云志, 敢笑黄巢不丈夫</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a7cec91836cad498af398d996ecd79d9/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">[算法入门]分块入门之求最大值</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/59e04739b5be60f200eb11f2bb3c4413/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">PHP MD5withRSA、SHA1withRSA、SHA256withRSA算法签名</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>