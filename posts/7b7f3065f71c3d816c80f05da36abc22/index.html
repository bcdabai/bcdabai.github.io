<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Builder模式——项目中最常见的设计模式之一 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Builder模式——项目中最常见的设计模式之一" />
<meta property="og:description" content="Builder模式介绍 Builder模式是一种一步一步创建一个复杂对象的设计模式，我认为这种设计模式的精髓就主要有两点：其一，用户使用简单，并且可以在不需要知道内部构建细节的情况下，就可以构建出复杂的对象模型；其二，对于设计者来说，这是一个解耦的过程，这种设计模式可以将构建的过程和具体的表示分离开来。
Builder模式的使用场景 1.相同的方法，不同的执行顺序，产生不同的时间结果时。 2.多个部件或零件，都可以装配到一个对象中，但是产生的运行结果又不同时。 3.产品类非常复杂，或者产品类中的调用顺序不同产生了不同的作用，这个时候用建造者模式非常适合。 4.当初始化一个对象特别复杂，如参数多，切很多参数都具有默认值时。 Builder模式分析 我们为什么要把代码的构建和表示分离开来？1.增加代码的可读性；2.方便维护。举一个例子，安卓中非常常用的AlertDialog就是Builder模式，我们知道，一个Dialog可以有非常多的属性和参数，例如title，icon，message， positiveButton，negativeButton等十几个参数，如果这些参数都放在构造函数里，那么这个方法将会有很多参数，为了完成这个函数，需要一次性准备好所有的参数，很容易写着写着就乱了。同时为了适配，还需要写很多重载的构造函数，类会很乱。而如果使用builder模式，不需要一次性准备好所有的参数，完全可以一个一个准备，代码易懂，方便非常多。 举例说明 有一个Person类，有name，age，job，sex等等N多属性，这里我用s1，s2，s3...s10代替。 接下来在Person类的内部定义一个静态的Builder类，并且定义对应的s1-s10方法，方法返回类型都是Builder 最后，增加一个build()方法，将所有的属性都设置进去 这样，含有多个参数的Builder模式的Person类就完成了，接下来我们看看用法。 代码的可读性高了很多，试想一下如果new了一个Person类，构造函数里传了10个参数，看起来就非常头疼，以后想改某一个值的话，还要去找代码看相应的含义。而Builder模式的可读性就非常高，只需要去修改相应的Builder静态类中的方法即可。 总结 Builder模式与传统的模式相比，并不是完全胜出的，相比之下，Builder模式的代码量会比正常多不少，但是随之带来的好处是代码的可读性和可维护性。但是，往往一个好的设计模式或架构，就是在牺牲某一种能力从而大大增强另一种能力，例如，牺牲一定的可读性，增加项目的可扩展性等等这样的方式。因此，在参数较为复杂，构造对象相对繁琐的情况下，一定要首先考虑使用Builder模式。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/7b7f3065f71c3d816c80f05da36abc22/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2017-06-25T10:05:47+08:00" />
<meta property="article:modified_time" content="2017-06-25T10:05:47+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Builder模式——项目中最常见的设计模式之一</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3></h3> 
<h3>     Builder模式介绍</h3> 
<p>        Builder模式是一种一步一步创建一个复杂对象的设计模式，我认为这种设计模式的精髓就主要有两点：其一，用户使用简单，并且可以在不需要知道内部构建细节的情况下，就可以构建出复杂的对象模型；其二，对于设计者来说，这是一个解耦的过程，这种设计模式可以将构建的过程和具体的表示分离开来。</p> 
<h3>     Builder模式的使用场景</h3> 
<div>
          1.相同的方法，不同的执行顺序，产生不同的时间结果时。 
</div> 
<div>
          2.多个部件或零件，都可以装配到一个对象中，但是产生的运行结果又不同时。 
</div> 
<div>
          3.产品类非常复杂，或者产品类中的调用顺序不同产生了不同的作用，这个时候用建造者模式非常适合。 
</div> 
<div>
          4.当初始化一个对象特别复杂，如参数多，切很多参数都具有默认值时。 
</div> 
<h3>     Builder模式分析</h3> 
<div>
          我们为什么要把代码的构建和表示分离开来？1.增加代码的可读性；2.方便维护。举一个例子，安卓中非常常用的AlertDialog就是Builder模式，我们知道，一个Dialog可以有非常多的属性和参数，例如title，icon，message， positiveButton，negativeButton等十几个参数，如果这些参数都放在构造函数里，那么这个方法将会有很多参数，为了完成这个函数，需要一次性准备好所有的参数，很容易写着写着就乱了。同时为了适配，还需要写很多重载的构造函数，类会很乱。而如果使用builder模式，不需要一次性准备好所有的参数，完全可以一个一个准备，代码易懂，方便非常多。 
</div> 
<h3>     举例说明</h3> 
<div>
          有一个Person类，有name，age，job，sex等等N多属性，这里我用s1，s2，s3...s10代替。 
</div> 
<div> 
 <img src="https://images2.imgbox.com/2e/65/XfYKSij2_o.png" alt=""> 
 <br> 
</div> 
<div>
          接下来在Person类的内部定义一个静态的Builder类，并且定义对应的s1-s10方法，方法返回类型都是Builder 
 <img src="https://images2.imgbox.com/f3/d9/AzRr2B2U_o.png" alt=""> 
</div> 
<div> 
 <br> 
</div> 
<div>
          最后，增加一个build()方法，将所有的属性都设置进去 
</div> 
<div> 
 <img src="https://images2.imgbox.com/89/bf/cv01Weyl_o.png" alt=""> 
</div> 
<div>
          这样，含有多个参数的Builder模式的Person类就完成了，接下来我们看看用法。 
</div> 
<div> 
 <img src="https://images2.imgbox.com/7b/ec/HJzJNnqw_o.png" alt=""> 
 <br> 
</div> 
<div>
          代码的可读性高了很多，试想一下如果new了一个Person类，构造函数里传了10个参数，看起来就非常头疼，以后想改某一个值的话，还要去找代码看相应的含义。而Builder模式的可读性就非常高，只需要去修改相应的Builder静态类中的方法即可。 
</div> 
<h3>     总结</h3> 
<p>        Builder模式与传统的模式相比，并不是完全胜出的，相比之下，Builder模式的代码量会比正常多不少，但是随之带来的好处是代码的可读性和可维护性。但是，往往一个好的设计模式或架构，就是在牺牲某一种能力从而大大增强另一种能力，例如，牺牲一定的可读性，增加项目的可扩展性等等这样的方式。因此，在参数较为复杂，构造对象相对繁琐的情况下，一定要首先考虑使用Builder模式。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/46e9096a623e170799456b9114e68a11/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">http响应码</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9adc5a739d8e58bb9db5afa08441708d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Quartz任务调度(4)JobListener分版本超详细解析</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>