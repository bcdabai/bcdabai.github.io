<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>华清远见嵌入式学习笔记 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="华清远见嵌入式学习笔记" />
<meta property="og:description" content="C高级笔记 符号含义 1、hqyj@ubuntu:~$
hqyj：用户名@：分隔ubuntu：主机名‘：’：分隔~：文件路径---&gt; ~：家目录 /：根目录$:分隔 2、文件类型及标识符
d：目录文件c：字符设备b：块设备block-：普通文件p：管道文件s：套接字文件l：链接文件 3、权限及标识符
r：读权限
w：写
x：可执行
-：无该权限
4、根目录下的目录文件说明：
bin：二进制文件目录mnt：挂载文件目录root：超级用户文件目录usr：用户文件目录etc：配置文件目录dev：设备文件目录boot：启动文件目录proc：进程文件目录 5、常用指令
ls：列出指定路径下的文件
-l：列出文件的详细信息
-a：列出所有文件包含隐藏文件
cd：路径跳转 绝对路径：从根目录出发的路径 相对路径：从当前路径出发的路径
mkdir：创建目录文件
6、vi编辑器：
命令行模式
dd：剪切光标所在行
n&#43;dd：剪切光标后n行
p：粘贴 yy：复制光标所在行
n&#43;yy：复制n行
u：撤销
ZZ：保存并退出 v---&gt;进入可视模式
gg=G：全文自动缩进
插入模式
i：光标前开始插入
a：光标后开始插入
o：光标下一行开始插入
底行模式
w：保存
q：退出
wq：保存并退出
x：保存并退出
set nu：设置行号
set mouse=a：使能鼠标
vsp &#43; 文件名：横向展开另一个文件
sp &#43; 文件名：纵向展开
7、文件操作
mv：移动文件到指定目录，或者重命名
ls：列出文件信息
cp：复制文件
mkdir：创建目录文件
touch：创建文件，修改文件的时间戳
cat：在终端显示文件内容，查看文件
head：默认查看文件的前十行
head -num filename：查看文件开头num行
tail：默认查看文件后十行
rm：删除文件，删除目录文件需要添加-r选项
rmdir：删除空目录文件
wc：统计字符数
-c ：字节数" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/243078a2773bdbdd63346baf4bd2163a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-05-10T23:20:07+08:00" />
<meta property="article:modified_time" content="2022-05-10T23:20:07+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">华清远见嵌入式学习笔记</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>C高级笔记</h2> 
<hr> 
<h3 style="margin-left:.0001pt;text-align:justify;">符号含义</h3> 
<p style="margin-left:.0001pt;text-align:justify;">1、hqyj@ubuntu:~$</p> 
<blockquote> 
 <ol><li style="text-align:justify;">hqyj：用户名</li><li style="text-align:justify;">@：分隔</li><li style="text-align:justify;">ubuntu：主机名</li><li style="text-align:justify;">‘：’：分隔</li><li style="text-align:justify;">~：文件路径---&gt; ~：家目录 /：根目录</li><li style="text-align:justify;">$:分隔</li></ol> 
</blockquote> 
<p style="text-align:justify;">2、文件类型及标识符</p> 
<blockquote> 
 <ol><li style="text-align:left;">d：目录文件</li><li style="text-align:left;">c：字符设备</li><li style="text-align:left;">b：块设备block</li><li style="text-align:left;">-：普通文件</li><li style="text-align:left;">p：管道文件</li><li style="text-align:left;">s：套接字文件</li><li style="text-align:left;">l：链接文件</li></ol> 
</blockquote> 
<p style="text-align:left;">3、权限及标识符</p> 
<blockquote> 
 <p style="margin-left:.0001pt;text-align:left;">r：读权限</p> 
 <p style="margin-left:.0001pt;text-align:left;">w：写</p> 
 <p style="margin-left:.0001pt;text-align:left;">x：可执行</p> 
 <p style="margin-left:.0001pt;text-align:left;">-：无该权限</p> 
</blockquote> 
<p style="margin-left:.0001pt;text-align:left;">4、根目录下的目录文件说明：</p> 
<blockquote> 
 <ol><li style="text-align:left;">bin：二进制文件目录</li><li style="text-align:left;">mnt：挂载文件目录</li><li style="text-align:left;">root：超级用户文件目录</li><li style="text-align:left;">usr：用户文件目录</li><li style="text-align:left;">etc：配置文件目录</li><li style="text-align:left;">dev：设备文件目录</li><li style="text-align:left;">boot：启动文件目录</li><li style="text-align:left;">proc：进程文件目录</li></ol> 
</blockquote> 
<p style="text-align:left;">5、常用指令</p> 
<blockquote> 
 <p style="margin-left:.0001pt;text-align:left;">ls：列出指定路径下的文件</p> 
 <p style="margin-left:.0001pt;text-align:left;">-l：列出文件的详细信息</p> 
 <p style="margin-left:.0001pt;text-align:left;">-a：列出所有文件包含隐藏文件</p> 
 <p style="margin-left:.0001pt;text-align:left;">cd：路径跳转 绝对路径：从根目录出发的路径 相对路径：从当前路径出发的路径</p> 
 <p style="margin-left:.0001pt;text-align:left;">mkdir：创建目录文件</p> 
</blockquote> 
<p style="margin-left:.0001pt;text-align:left;">6、vi编辑器：</p> 
<p style="margin-left:.0001pt;text-align:left;">命令行模式</p> 
<blockquote> 
 <p style="margin-left:.0001pt;text-align:left;">dd：剪切光标所在行</p> 
 <p style="margin-left:.0001pt;text-align:left;">n+dd：剪切光标后n行</p> 
 <p style="margin-left:.0001pt;text-align:left;">p：粘贴 yy：复制光标所在行</p> 
 <p style="margin-left:.0001pt;text-align:left;">n+yy：复制n行</p> 
 <p style="margin-left:.0001pt;text-align:left;">u：撤销</p> 
 <p style="margin-left:.0001pt;text-align:left;">ZZ：保存并退出 v---&gt;进入可视模式</p> 
 <p style="margin-left:.0001pt;text-align:left;">gg=G：全文自动缩进</p> 
</blockquote> 
<p style="margin-left:.0001pt;text-align:left;">插入模式</p> 
<blockquote> 
 <p style="margin-left:.0001pt;text-align:left;">i：光标前开始插入</p> 
 <p style="margin-left:.0001pt;text-align:left;">a：光标后开始插入</p> 
 <p style="margin-left:.0001pt;text-align:left;">o：光标下一行开始插入</p> 
</blockquote> 
<p style="margin-left:.0001pt;text-align:left;">底行模式</p> 
<blockquote> 
 <p style="margin-left:.0001pt;text-align:left;">w：保存</p> 
 <p style="margin-left:.0001pt;text-align:left;">q：退出</p> 
 <p style="margin-left:.0001pt;text-align:left;">wq：保存并退出</p> 
 <p style="margin-left:.0001pt;text-align:left;">x：保存并退出</p> 
 <p style="margin-left:.0001pt;text-align:left;">set nu：设置行号</p> 
 <p style="margin-left:.0001pt;text-align:left;">set mouse=a：使能鼠标</p> 
 <p style="margin-left:.0001pt;text-align:left;">vsp + 文件名：横向展开另一个文件</p> 
 <p style="margin-left:.0001pt;text-align:left;">sp + 文件名：纵向展开</p> 
</blockquote> 
<p style="margin-left:.0001pt;text-align:left;">7、文件操作</p> 
<blockquote> 
 <p style="margin-left:.0001pt;text-align:left;">mv：移动文件到指定目录，或者重命名</p> 
 <p style="margin-left:.0001pt;text-align:left;">ls：列出文件信息</p> 
 <p style="margin-left:.0001pt;text-align:left;">cp：复制文件</p> 
 <p style="margin-left:.0001pt;text-align:left;">mkdir：创建目录文件</p> 
 <p style="margin-left:.0001pt;text-align:left;">touch：创建文件，修改文件的时间戳</p> 
 <p style="margin-left:.0001pt;text-align:left;">cat：在终端显示文件内容，查看文件</p> 
 <p style="margin-left:.0001pt;text-align:left;">head：默认查看文件的前十行</p> 
 <p style="margin-left:.0001pt;text-align:left;">head -num filename：查看文件开头num行</p> 
 <p style="margin-left:.0001pt;text-align:left;">tail：默认查看文件后十行</p> 
 <p style="margin-left:.0001pt;text-align:left;">rm：删除文件，删除目录文件需要添加-r选项</p> 
 <p style="margin-left:.0001pt;text-align:left;">rmdir：删除空目录文件</p> 
 <p style="margin-left:.0001pt;text-align:left;">wc：统计字符数</p> 
 <p style="margin-left:.0001pt;text-align:left;">-c ：字节数</p> 
 <p style="margin-left:.0001pt;text-align:left;">-w：单词数</p> 
 <p style="margin-left:.0001pt;text-align:left;"> -l ：行数</p> 
 <p style="margin-left:.0001pt;text-align:left;">echo：在终端上显示指定字符内容</p> 
 <p style="margin-left:.0001pt;text-align:left;">grep：在指定文件中查询指定的字符串 grep “main” -n demo.c 在demo.c文件中查询到于main字符 串相关的内容并打印对应的行号</p> 
 <p style="margin-left:.0001pt;text-align:left;">cut：剪切字符串</p> 
</blockquote> 
<p style="margin-left:.0001pt;text-align:left;">8、进程管理：</p> 
<blockquote> 
 <ol><li style="text-align:left;">ps：在终端上显示进程程序</li><li style="text-align:left;">kill：杀死指定pid的进程程序</li></ol> 
</blockquote> 
<p style="text-align:left;">9、指针</p> 
<blockquote> 
 <p style="margin-left:.0001pt;text-align:left;">地址：内存单元每个字节的编号，32位</p> 
 <p style="margin-left:.0001pt;text-align:left;">指针及地址</p> 
 <p style="margin-left:.0001pt;text-align:left;">指针变量：存放地址信息的变量</p> 
 <p style="margin-left:.0001pt;text-align:left;">指针变量的大小：64位8字节</p> 
</blockquote> 
<p style="margin-left:.0001pt;text-align:left;">10、*号的作用：</p> 
<blockquote> 
 <ol><li style="text-align:left;">乘法</li><li style="text-align:left;">在定义变量时说明该变量是一个指针变量</li><li style="text-align:left;">对地址使用操作该地址下的数据</li></ol> 
</blockquote> 
<p style="text-align:left;">11、&amp;号的作用：</p> 
<blockquote> 
 <ol><li style="text-align:left;">位与</li><li style="text-align:left;">取出变量的地址信息</li></ol> 
</blockquote> 
<p style="text-align:left;">12、指针的运算：</p> 
<blockquote> 
 <p style="margin-left:.0001pt;text-align:left;">指针和指针： 同类型指针相减，大地址减去小地址，两个地址间间隔的元素个数</p> 
 <p style="margin-left:.0001pt;text-align:left;">指针的算数运算</p> 
 <p style="margin-left:.0001pt;text-align:left;">指针+1：偏移的地址由该指针指向的数据类型决定</p> 
</blockquote> 
<p style="margin-left:.0001pt;text-align:left;">13、指针和数组：</p> 
<blockquote> 
 <p style="margin-left:.0001pt;text-align:left;">1. 指针数组 本质是一个数组，该数组内的元素全是指针</p> 
 <p style="margin-left:.0001pt;text-align:left;">2. 数组指针 本质是一个指针，该指针指向的数据是一整个数组的地址</p> 
</blockquote> 
<p style="margin-left:.0001pt;text-align:left;">14、函数</p> 
<p style="margin-left:.0001pt;text-align:left;">作用：代码封装，实现特定功能的代码模块函数声明；</p> 
<p style="margin-left:.0001pt;text-align:left;">不会在程序中开辟空间，但是会表示该函数存在函数的返回值：</p> 
<p style="margin-left:.0001pt;text-align:left;">由函数定义时决定，函数返回值类型必须和函数定义的数据类型相同</p> 
<p style="margin-left:.0001pt;text-align:left;">传参：</p> 
<blockquote> 
 <ol><li style="text-align:left;">数值传参 相当于在函数空间中对于实际参数进行了复制操作，修改形 式参数的值不会影响到实际参数</li><li style="text-align:left;">地址传参 相当于将实际参数的地址传递给函数，函数内利用指针接收 该地址，在函数空间中通过该地址可以修改到实际参数的值</li></ol> 
</blockquote> 
<p style="text-align:left;">15、全局变量：</p> 
<p style="margin-left:.0001pt;text-align:justify;">全局可见的数据</p> 
<p style="margin-left:.0001pt;text-align:justify;">16、函数调用</p> 
<p style="margin-left:.0001pt;text-align:justify;">函数名()；</p> 
<p style="margin-left:.0001pt;text-align:justify;">17、函数指针：</p> 
<p style="margin-left:.0001pt;text-align:justify;">本质是一个指针指向该函数的入口地址</p> 
<p style="margin-left:.0001pt;text-align:justify;">18、memset函数</p> 
<blockquote> 
 <p style="margin-left:.0001pt;text-align:left;">函数的功能： 将指定地址的空间的数据设置成指定数据，设置空间的大小由参数传递</p> 
 <p style="margin-left:.0001pt;text-align:left;">函数原型： void *memset(void *s, int c, size_t n);</p> 
 <p style="margin-left:.0001pt;text-align:left;">函数使用需要添加的头文件： #include 函数的参数说明： void *s：</p> 
 <p style="margin-left:.0001pt;text-align:left;">需要设置成数据的首地址 int c：</p> 
 <p style="margin-left:.0001pt;text-align:left;">想要设置成的字符的数据 size_t n：</p> 
 <p style="margin-left:.0001pt;text-align:left;">想要设置的内存空间的大小 函数的返回值 函数返回设置了数据的地址的起始地址</p> 
</blockquote> 
<p style="margin-left:.0001pt;text-align:left;">19、malloc和free函数</p> 
<p style="margin-left:.0001pt;text-align:left;">函数的功能：</p> 
<blockquote> 
 <p style="margin-left:.0001pt;text-align:left;">malloc功能是在堆空间中开辟空间，函数返回值是可以操作这片</p> 
 <p style="margin-left:.0001pt;text-align:left;">空间的大小 free功能是释放掉堆空间开辟的空间</p> 
 <p style="margin-left:.0001pt;text-align:left;">函数原型： void *malloc(size_t size);</p> 
 <p style="margin-left:.0001pt;text-align:left;">void free(void *ptr);</p> 
 <p style="margin-left:.0001pt;text-align:left;">函数使用需要添加的头文件： #include</p> 
 <p style="margin-left:.0001pt;text-align:left;">函数的参数说明：</p> 
 <p style="margin-left:.0001pt;text-align:left;">malloc： size_t size：</p> 
 <p style="margin-left:.0001pt;text-align:left;">需要在堆空间中开辟的空间大小 free：</p> 
 <p style="margin-left:.0001pt;text-align:left;">void *ptr：释放堆空间的起始地址</p> 
 <p style="margin-left:.0001pt;text-align:left;">函数的返回值说明： malloc：返回值为指针类型，是在堆空间中开辟空间的起始地址 free函数无返回值</p> 
</blockquote> 
<p style="margin-left:.0001pt;text-align:left;">20、结构体：</p> 
<p style="margin-left:.0001pt;text-align:left;">将不同类型的数据进行打包</p> 
<p style="margin-left:.0001pt;text-align:left;">声明结构体：</p> 
<p style="margin-left:.0001pt;text-align:left;">struct 结构体类型名</p> 
<blockquote> 
 <p style="margin-left:.0001pt;text-align:left;">{<!-- --></p> 
 <p style="margin-left:.0001pt;text-align:left;">成员1；</p> 
 <p style="margin-left:.0001pt;text-align:left;">成员2；</p> 
 <p style="margin-left:.0001pt;text-align:left;">}；</p> 
</blockquote> 
<p style="margin-left:.0001pt;text-align:left;">定义结构体变量 struct</p> 
<p style="margin-left:.0001pt;text-align:left;">结构体类型名 变量名;</p> 
<p style="margin-left:.0001pt;text-align:left;">初始化结构体 struct 结构体类型名 变量名 = {成员1，成员2}；</p> 
<p style="margin-left:.0001pt;text-align:left;">结构体成员的访问 结构体变量.结构体内的成员名</p> 
<p style="margin-left:.0001pt;text-align:left;">21、typedef：</p> 
<p style="margin-left:.0001pt;text-align:justify;">作用是取别名，可以将一种数据类型定义一个新的名字表示</p> 
<p style="margin-left:.0001pt;text-align:justify;">22、结构体数组：</p> 
<p style="margin-left:.0001pt;text-align:justify;">本质是数组，数组内的元素全是结构体</p> 
<p style="margin-left:.0001pt;text-align:justify;">23、结构体指针：</p> 
<p style="margin-left:.0001pt;text-align:justify;">本质是一个指针指向结构体变量</p> 
<p style="margin-left:.0001pt;text-align:justify;">24、联合体（共用体）：</p> 
<p style="margin-left:.0001pt;text-align:justify;">联合体中可以存储不同类型的数据，但是这些数据将会使用同一片空间</p> 
<p style="margin-left:.0001pt;text-align:justify;">25、Makefile：</p> 
<blockquote> 
 <p style="margin-left:.0001pt;text-align:left;">make是工程管理工具，可以通过读取makefile文件执行大量的编译效果</p> 
 <p style="margin-left:.0001pt;text-align:left;">make工程管理工具会根据文件的时间戳决定文件的更新程度，如果没有修改则可以省略没修改文件的编译步骤达到可以减少编译时间的目的</p> 
</blockquote> 
<p style="margin-left:.0001pt;text-align:left;">26、函数指针：</p> 
<p style="margin-left:.0001pt;text-align:justify;">函数指针本质是一个指针，可以通过指针指向一个存在的函数</p> 
<h2 style="margin-left:.0001pt;text-align:justify;">数据结构</h2> 
<hr> 
<h3>栈：</h3> 
<hr> 
<p style="margin-left:.0001pt;text-align:left;">是一种线性表；先进后出；只允许在一端操作。</p> 
<p style="margin-left:.0001pt;text-align:left;">定义顺序栈：</p> 
<pre><code>//大小固定

typedef int typedata;

#define MAXSIZE 100

typedef struct node{

typedata data[MAXSIZE];

int top;

}Seqstack, *Pseqstack;

//大小可由用户自定义

typedef int typedata;

typedef struct node{

int MAXSIZE;

typedata *data;

int top;

}Seqstack, *Pseqstack;</code></pre> 
<p style="margin-left:.0001pt;text-align:left;">栈的创建：</p> 
<pre><code>Pseqstack stack_create()

{

Pseqstack p = malloc(sizeof(Seqstack));

if(NULL == p)

return NULL;

p-&gt;top = -1;

return p;

}

Pseqstack stack_create(int len)

{

Pseqstack p = malloc(sizeof(Seqstack));

if(NULL == p)

return NULL;

p-&gt;top = -1;

p-&gt;MAXSIZE = len;

p-&gt;data = malloc(sizeof(typedata)*len);

if(NULL == p-&gt;data){

free(p);

return NULL;

}

return p;

}</code></pre> 
<p style="margin-left:.0001pt;text-align:left;">栈判空判满：</p> 
<p style="margin-left:.0001pt;text-align:left;">判空：top == -1;</p> 
<p style="margin-left:.0001pt;text-align:left;">判满: top == MAXSIZE-1;</p> 
<pre><code>int stack_empty(Pseqstack p)

{

if(NULL == p)

return -2;

if(-1 == p-&gt;top){

return 0;

}else{

return -1;

}

}

int stack_full(Pseqstack p)

{

if(NULL == p)

return -2;

if(p-&gt;MAXSIZE-1 == p-&gt;top){

return 0;

}else{

return -1;

}

}</code></pre> 
<p style="margin-left:.0001pt;text-align:left;">压栈:</p> 
<pre><code>int stack_push(Pseqstack p, typedata data)

{

if(!stack_full(p)){

return -1;

}

p-&gt;top++;

p-&gt;data[p-&gt;top] = data;

return 0;

}</code></pre> 
<p style="margin-left:.0001pt;text-align:left;">出栈：</p> 
<pre><code>typedata stack_pop(Pseqstack p)

{

if(!stack_empty(p)){

return -1;

}

//return p-&gt;data[p-&gt;top--];

typedata data = p-&gt;data[p-&gt;top];

p-&gt;top--;

return data;

}</code></pre> 
<p style="margin-left:.0001pt;text-align:left;">获取栈顶元素：</p> 
<pre><code>typedata stack_get_top(Pseqstack p)

{

return p-&gt;data[p-&gt;top];

}</code></pre> 
<p style="margin-left:.0001pt;text-align:left;">链式栈：</p> 
<p style="margin-left:.0001pt;text-align:left;">存储结构是链式的，理论没有上限，所以不需要判满</p> 
<h3 style="margin-left:.0001pt;text-align:left;">队列：</h3> 
<hr> 
<p style="margin-left:.0001pt;text-align:left;">仍然是线性表；只允许一端输入数据，一端输出数据；先进先出。</p> 
<p style="margin-left:.0001pt;text-align:left;">创建一个顺序队列：</p> 
<pre><code>#define MAXSIZE 10

typedef struct node{

int data[MAXSIZE];

int front, rear;

}Sequeue, *Psequeue;  

//创建

Psequeue queue_create()

{

Psequeue p = malloc(sizeof(Sequeue));

if(NULL == p)

return NULL;

p-&gt;front = p-&gt;rear = MAXSIZE - 1;

return p;

}

//判空

int queue_empty(Psequeue q)

{

if(NULL == q){

return -2;

}

if(q-&gt;front == q-&gt;rear){

return 0;

}

return -1;

}

//判满

int queue_full(Psequeue q)

{

if(NULL == q){

return -2;

}

if(q-&gt;front == (q-&gt;rear+1)%MAXSIZE){

return 0;

}

return -1;

}

//入队

int queue_in(Psequeue q, int data)

{

if(0 == queue_full(q)){

return -1;

}

q-&gt;rear = (q-&gt;rear+1) % MAXSIZE;

q-&gt;data[q-&gt;rear] = data;

return 0;

}

//出队

int queue_out(Psequeue q, int *data)

{

if(0 == queue_empty(q)){

return -1;

}

q-&gt;front = (q-&gt;front+1) % MAXSIZE;

*data = q-&gt;data[q-&gt;front];

return 0;

}</code></pre> 
<h3 style="margin-left:.0001pt;text-align:left;">链式队列：</h3> 
<hr> 
<p style="margin-left:.0001pt;text-align:left;">一端入队,一端出队；先进先出。</p> 
<pre><code>//定义队列元素的节点

typedef struct node{

int data;

struct node *next;

}Node, *Pnode;

//定义队列结构体

typedef struct queue{

Pnode pf, pr; //pf指向队头 ,pr指向队尾

}Linkqueue, *Plinkqueue;

//创建队列

bool queue_create(Plinkqueue *Q)

{

//创建一个队列的对象（管理队列）

*Q = malloc(sizeof(Linkqueue));

if(NULL == *Q){

return false;

}

//创建一个队列的具体节点，且该节点不存数据

(*Q)-&gt;pf =(*Q)-&gt;pr = malloc(sizeof(Node));

(*Q)-&gt;pf-&gt;next = NULL;

return true;

}

//判空

bool queue_empty(Plinkqueue q)

{

if(NULL == q){

return false;

}

if(q-&gt;pf-&gt;next == NULL){

return true;

}

return false;

}

//入队

bool queue_in(Plinkqueue q, int data)

{

if(NULL == q){

return false;

}

Pnode p = malloc(sizeof(Node));

if(NULL == p){

return false;

}

p-&gt;data = data;

p-&gt;next = NULL;  //p-&gt;next = q-&gt;pr-&gt;next;

q-&gt;pr-&gt;next = p;

//让pr指向新的队尾

q-&gt;pr = p;

return true;

}

//出队

bool queue_out(Plinkqueue q, int *data)

{

if(NULL == q){

return false;

}

if(true == queue_empty(q)){

return false;

}

Pnode p = q-&gt;pf-&gt;next;

//判断出队的元素是否是队列的队尾，如果是，需要

if(p == q-&gt;pr){

q-&gt;pr = q-&gt;pf;

}

q-&gt;pf-&gt;next = p-&gt;next;

*data = p-&gt;data;

free(p);

return true;

}</code></pre> 
<h3 style="margin-left:.0001pt;text-align:left;">树：</h3> 
<hr> 
<p style="margin-left:.0001pt;text-align:left;">先序：A B C D E F G H K 中序：B D C A E H G K F</p> 
<p style="margin-left:.0001pt;text-align:left;"></p> 
<p style="margin-left:.0001pt;text-align:left;">A</p> 
<p style="margin-left:.0001pt;text-align:left;">B</p> 
<p style="margin-left:.0001pt;text-align:left;">C</p> 
<p style="margin-left:.0001pt;text-align:left;">D</p> 
<p style="margin-left:.0001pt;text-align:left;">E</p> 
<p style="margin-left:.0001pt;text-align:left;">F</p> 
<p style="margin-left:.0001pt;text-align:left;">G</p> 
<p style="margin-left:.0001pt;text-align:left;">H</p> 
<p style="margin-left:.0001pt;text-align:left;">K</p> 
<p style="margin-left:.0001pt;text-align:left;">    B     D     C     A     E     H     G     K     F</p> 
<p style="margin-left:.0001pt;text-align:left;">声明二叉树的结构体：</p> 
<pre><code>typedef struct node{

char ch;

struct node *lchild, *rchild;

}Btree, *pBtree;</code></pre> 
<p style="margin-left:.0001pt;text-align:left;">创建一个二叉树：</p> 
<pre><code>pBtree btree_create()

{

pBtree pa = malloc(sizeof(Btree));

pBtree pb = malloc(sizeof(Btree));

pBtree pc = malloc(sizeof(Btree));

pBtree pd = malloc(sizeof(Btree));

pBtree pe = malloc(sizeof(Btree));

pBtree pf = malloc(sizeof(Btree));

pa-&gt;data = 'A';

pb-&gt;data = 'B';

pc-&gt;data = 'C';

pd-&gt;data = 'D';

pe-&gt;data = 'E';

pf-&gt;data = 'F';

pa-&gt;lchild = pb;

pa-&gt;rchild = pc;

pc-&gt;lchild = NULL;

pc-&gt;rchild = NULL;

pb-&gt;lchild = NULL;

pb-&gt;rchild = pd;

pd-&gt;lchild = pe;

pd-&gt;rchild = pf;

pe-&gt;lchild = NULL;

pe-&gt;rchild = NULL;

pf-&gt;lchild = NULL;

pf-&gt;rchild = NULL;

}

//先序遍历

void btree_pre_order(pBtree b)

{

if(NULL == b){

return ;

}

//先打印数据

printf("%c ", b-&gt;data);

//再遍历左孩子

btree_pre_order(b-&gt;lchild);

//再遍历右孩子

btree_pre_order(b-&gt;rchild);

}</code></pre> 
<h2 style="margin-left:.0001pt;text-align:left;">IO</h2> 
<hr> 
<h3 style="margin-left:.0001pt;text-align:justify;">进程</h3> 
<hr> 
<p style="margin-left:.0001pt;text-align:left;">1. 进程</p> 
<p style="margin-left:.0001pt;text-align:left;">进程是一个程序的一次执行的过程，每一个进程都分配一个虚拟的4G内存。</p> 
<blockquote> 
 <p style="margin-left:.0001pt;text-align:left;">0-3G  ： 用户</p> 
 <p style="margin-left:.0001pt;text-align:left;">3G-4G ： 内核</p> 
</blockquote> 
<p style="margin-left:.0001pt;text-align:left;">2. 进程和程序的区别</p> 
<p style="margin-left:.0001pt;text-align:left;">程序是静态的</p> 
<p style="margin-left:.0001pt;text-align:left;">进程是动态的</p> 
<p style="margin-left:.0001pt;text-align:left;">3. 进程的内存管理</p> 
<p style="margin-left:.0001pt;text-align:left;">正文段、用户数据段、系统数据段</p> 
<p style="margin-left:.0001pt;text-align:left;">4. 进程号PID</p> 
<p style="margin-left:.0001pt;text-align:left;">唯一的标识一个进程</p> 
<p style="margin-left:.0001pt;text-align:left;">5. 进程的类型</p> 
<blockquote> 
 <p style="margin-left:.0001pt;text-align:left;">交互进程（ctrl+z / jobs -l / bg / fg / &amp; / kill -l）</p> 
 <p style="margin-left:.0001pt;text-align:left;">ctrl + z : 使进程进入挂起状态（T）， 被挂起的进程称为作业</p> 
 <p style="margin-left:.0001pt;text-align:left;">jobs -l： 查看挂起的进程</p> 
 <p style="margin-left:.0001pt;text-align:left;">bg % 作业号 ：使作业恢复前台运行, 不能ctrl+c结束</p> 
 <p style="margin-left:.0001pt;text-align:left;">fg % 作业号 : 使作业恢复前台运行, 可以ctrl+c结束</p> 
 <p style="margin-left:.0001pt;text-align:left;">kill -l : 查看信号种类</p> 
 <p style="margin-left:.0001pt;text-align:left;">kill -9 PID ： 杀死进程</p> 
 <p style="margin-left:.0001pt;text-align:left;">ps -ajx ： 查看进程的运行状态</p> 
 <p style="margin-left:.0001pt;text-align:left;">批处理进程（运维）</p> 
 <p style="margin-left:.0001pt;text-align:left;">守护进程（ 1 init ）</p> 
</blockquote> 
<p style="margin-left:.0001pt;text-align:left;">6. 进程的运行状态</p> 
<blockquote> 
 <p style="margin-left:.0001pt;text-align:left;">ps -ajx</p> 
 <p style="margin-left:.0001pt;text-align:left;">运行态R：此时进程或者正在进行，或者准备运行</p> 
 <p style="margin-left:.0001pt;text-align:left;">内核调度程序到CPU上执行 running</p> 
 <p style="margin-left:.0001pt;text-align:left;">等待态：此时进程需要满足一些条件，如果不满足就等待</p> 
 <p style="margin-left:.0001pt;text-align:left;">可中断S：如果进程收到信号会醒来 ctrl+c</p> 
 <p style="margin-left:.0001pt;text-align:left;">不可中断D：如果进程收到信号不会醒来</p> 
 <p style="margin-left:.0001pt;text-align:left;">停止态T：此时进程被中止SIGSTOP</p> 
 <p style="margin-left:.0001pt;text-align:left;">死亡态Z：已终止的进程、僵尸进程</p> 
 <p style="margin-left:.0001pt;text-align:left;">但还在进程向量数组中占有一个task_struct结构</p> 
 <p style="margin-left:.0001pt;text-align:left;">task_struct{<!-- --></p> 
 <p style="margin-left:.0001pt;text-align:left;">pid_t pid;</p> 
 <p style="margin-left:.0001pt;text-align:left;">R;</p> 
 <p style="margin-left:.0001pt;text-align:left;">...</p> 
 <p style="margin-left:.0001pt;text-align:left;">};</p> 
 <p style="margin-left:.0001pt;text-align:left;">   &lt; 高优先级</p> 
 <p style="margin-left:.0001pt;text-align:left;">  ​ N 低优先级</p> 
 <p style="margin-left:.0001pt;text-align:left;">  ​ L 有些页被锁进内存</p> 
 <p style="margin-left:.0001pt;text-align:left;">  ​ s 会话组组长</p> 
 <p style="margin-left:.0001pt;text-align:left;">    位于前台的进程组</p> 
 <p style="margin-left:.0001pt;text-align:left;">    l 多线程，克隆线程</p> 
 <p style="margin-left:.0001pt;text-align:left;">ctrl + alt + f1 - f6 : 打开字符终端</p> 
 <p style="margin-left:.0001pt;text-align:left;">用户名：farsight</p> 
 <p style="margin-left:.0001pt;text-align:left;">密码：1</p> 
 <p style="margin-left:.0001pt;text-align:left;">为了多用户使用计算机</p> 
 <p style="margin-left:.0001pt;text-align:left;">结束字符终端： alt + f7</p> 
 <p style="margin-left:.0001pt;text-align:left;">top</p> 
 <p style="margin-left:.0001pt;text-align:left;">top -p PID  : 动态查看进程状态</p> 
 <p style="margin-left:.0001pt;text-align:left;">renice -5 PID : 改变进程的NI值（默认0）</p> 
</blockquote> 
<p style="margin-left:.0001pt;text-align:left;">7.进程相关的函数</p> 
<blockquote> 
 <p style="margin-left:.0001pt;text-align:left;">  fork/exit  </p> 
 <p style="margin-left:.0001pt;text-align:left;">创建进程、退出进程</p> 
 <p style="margin-left:.0001pt;text-align:left;">​ wait/waitpid</p> 
 <p style="margin-left:.0001pt;text-align:left;">​ 回收进程资源</p> 
 <p style="margin-left:.0001pt;text-align:left;">#include &lt;unistd.h&gt;</p> 
 <p style="margin-left:.0001pt;text-align:left;">pid_t pid; //进程号</p> 
 <p style="margin-left:.0001pt;text-align:left;">pid_t fork(void);</p> 
 <p style="margin-left:.0001pt;text-align:left;">功能：创建进程</p> 
 <p style="margin-left:.0001pt;text-align:left;">参数：无</p> 
 <p style="margin-left:.0001pt;text-align:left;">返回值：</p> 
 <p style="margin-left:.0001pt;text-align:left;">pid &lt; 0  :创建失败</p> 
 <p style="margin-left:.0001pt;text-align:left;">  pid == 0 :子进程</p> 
 <p style="margin-left:.0001pt;text-align:left;">  pid &gt; 0  :父进程</p> 
</blockquote> 
<p style="margin-left:.0001pt;text-align:left;">从fork函数往下分为两个进程开始运行。</p> 
<p style="margin-left:.0001pt;text-align:left;">父进程和子进程执行顺序是随机的。</p> 
<h3 style="margin-left:.0001pt;text-align:justify;">fork函数特性：</h3> 
<hr> 
<p style="margin-left:.0001pt;text-align:left;">1.子进程创建时，几乎拷贝了父进程全部内容，包括代码段、数据段、堆栈段、文件描述符、虚拟地址空间</p> 
<p style="margin-left:.0001pt;text-align:left;">2.同一个父进程创建的子进程都是属于同一个进程组</p> 
<p style="margin-left:.0001pt;text-align:left;">pkill -9 -g PGID</p> 
<p style="margin-left:.0001pt;text-align:left;">3.进程是管理资源的最小单位</p> 
<blockquote> 
 <p style="margin-left:.0001pt;text-align:left;">#include &lt;stdlib.h&gt;</p> 
 <p style="margin-left:.0001pt;text-align:left;">void exit(int status); //刷新缓存</p> 
 <p style="margin-left:.0001pt;text-align:left;">//系统调用函数</p> 
 <p style="margin-left:.0001pt;text-align:left;">#include &lt;unistd.h&gt;</p> 
 <p style="margin-left:.0001pt;text-align:left;">void _exit(int status); //不能刷新缓存</p> 
 <p style="margin-left:.0001pt;text-align:left;">pid_t wait(int *status);</p> 
</blockquote> 
<p style="margin-left:.0001pt;text-align:left;">功能：父进程等待子进程结束，回收它的资源</p> 
<p style="margin-left:.0001pt;text-align:left;">参数：一般设为NULL</p> 
<p style="margin-left:.0001pt;text-align:left;">WEXITSTATUS(status)  获取子进程返回值  </p> 
<p style="margin-left:.0001pt;text-align:left;">WIFEXITED(status)  判断子进程是否正常结束</p> 
<p style="margin-left:.0001pt;text-align:left;">子进程先与父进程退出---父进程未回收资源---子进程会变成僵尸进程</p> 
<p style="margin-left:.0001pt;text-align:left;">危害：占用进程号、内存空间、PCB进程控制块等</p> 
<p style="margin-left:.0001pt;text-align:left;">解决：wait / waitpid / 信号</p> 
<p style="margin-left:.0001pt;text-align:left;">注意：任何进程结束都会变成僵尸进程，只是时间有长有短</p> 
<p style="margin-left:.0001pt;text-align:left;">父进程先与子进程退出---子进程会变成孤儿进程---被init进程接管(收养)</p> 
<p style="margin-left:.0001pt;text-align:left;">init进程：系统启动后运行的第一个用户空间进程,pid=1,会定期扫描系统，收养孤儿进程。</p> 
<p style="margin-left:.0001pt;text-align:left;">注意：孤儿进程一般没什么危害</p> 
<p style="margin-left:.0001pt;text-align:left;">pid_t waitpid(pid_t pid, int *status, int options);</p> 
<p style="margin-left:.0001pt;text-align:left;">功能：父进程自动回收子进程结束后的资源</p> 
<p style="margin-left:.0001pt;text-align:left;">参数：</p> 
<blockquote> 
 <p style="margin-left:.0001pt;text-align:left;">  pid: -1   代表所有的子进程</p> 
 <p style="margin-left:.0001pt;text-align:left;">  status: NULL</p> 
 <p style="margin-left:.0001pt;text-align:left;">options:</p> 
 <p style="margin-left:.0001pt;text-align:left;">0 阻塞</p> 
 <p style="margin-left:.0001pt;text-align:left;">WNOHANG 非阻塞</p> 
 <p style="margin-left:.0001pt;text-align:justify;">waitpid(-1, NULL, 0);  == wait(NULL);</p> 
</blockquote> 
<h3 style="margin-left:.0001pt;text-align:left;">exec函数簇</h3> 
<hr> 
<p style="margin-left:.0001pt;text-align:left;">1. 概念：</p> 
<p style="margin-left:.0001pt;text-align:left;">函数族提供了一种在进程中启动另一个程序执行的方法。</p> 
<p style="margin-left:.0001pt;text-align:left;">它可以根据指定的文件名或目录名找到可执行文件，并用它来取代原调用进程的数据段、代码段和堆栈段，在执行完之后，原调用进程的内容除了进程号外，其他全部被新程序的内容替换了。另外，这里的可执行文件既可以是二进制文件，也可以是Linux下任何可执行脚本文件。</p> 
<p style="margin-left:.0001pt;text-align:left;">比如bash用到了exec函数来执行我们的可执行文件。</p> 
<p style="margin-left:.0001pt;text-align:left;">2. 在Linux中使用exec函数族主要有以下两种情况</p> 
<p style="margin-left:.0001pt;text-align:left;">当进程认为自己不能再为系统和用户做出任何贡献时，就可以调用任何exec 函数族让自己重生。</p> 
<p style="margin-left:.0001pt;text-align:left;">如果一个进程想执行另一个程序，那么它就可以调用fork函数新建一个进程，然后调用任何一个exec函数使子进程重生。</p> 
<p style="margin-left:.0001pt;text-align:left;">3. 函数</p> 
<blockquote> 
 <p style="margin-left:.0001pt;text-align:left;">  #include &lt;unistd.h&gt;</p> 
 <p style="margin-left:.0001pt;text-align:left;">     int execl(const char *path, const char *arg, ...);</p> 
 <p style="margin-left:.0001pt;text-align:left;">     int execv(const char *path, char *const argv[]);</p> 
 <p style="margin-left:.0001pt;text-align:left;">     int execlp(const char *file, const char *arg, ...);</p> 
 <p style="margin-left:.0001pt;text-align:left;">     int execvp(const char *file, char *const argv[]);</p> 
 <p style="margin-left:.0001pt;text-align:left;">     int execle(const char *path, const char *arg, ..., char *const envp[]);</p> 
 <p style="margin-left:.0001pt;text-align:left;">     int execve(const char *path, char *const argv[],   char *const envp[]);</p> 
</blockquote> 
<p style="margin-left:.0001pt;text-align:left;">  返回值:</p> 
<p style="margin-left:.0001pt;text-align:left;">   成功不返回</p> 
<p style="margin-left:.0001pt;text-align:left;">   失败返回 -1 更新 errno</p> 
<p style="margin-left:.0001pt;text-align:left;">注意：</p> 
<p style="margin-left:.0001pt;text-align:left;">​ exec函数的参数表传递方式以函数名的第五位字母来区分:</p> 
<p style="margin-left:.0001pt;text-align:left;">​ 字母为"l"(list)的表示逐个列举的方式;</p> 
<p style="margin-left:.0001pt;text-align:left;">字母为"v"(vertor)的表示将所有参数构造成指针数组传递;</p> 
<p style="margin-left:.0001pt;text-align:left;">以p结尾的函数可以只给出文件名</p> 
<p style="margin-left:.0001pt;text-align:left;">以"e"(enviromen)结尾的两个函数execle、execve就可以在</p> 
<p style="margin-left:.0001pt;text-align:left;">envp[]中设置当前进程所使用的环境变量</p> 
<p style="margin-left:.0001pt;text-align:left;">使用execle和execve可以自己向执行进程传递环境变量，但不会继承Shell进程的环境变量</p> 
<p style="margin-left:.0001pt;text-align:left;">事实上，这6个函数中真正的系统调用只有execve，其他5个都是库函数，它们最终都会调用execve这个系统调用</p> 
<h3 style="margin-left:.0001pt;text-align:justify;">守护进程daemon</h3> 
<hr> 
<p style="margin-left:.0001pt;text-align:left;">1.守护进程：</p> 
<p style="margin-left:.0001pt;text-align:left;">在linux中与用户交互的界面叫终端，从终端运行起来的程序都依附于这个终端，</p> 
<p style="margin-left:.0001pt;text-align:left;">当终端关关闭时，相应的进程都会被关闭，守护进程可以突破这个限制。</p> 
<p style="margin-left:.0001pt;text-align:left;">2.特点：</p> 
<p style="margin-left:.0001pt;text-align:left;">在后台服务的进程</p> 
<p style="margin-left:.0001pt;text-align:left;">生存期很长</p> 
<p style="margin-left:.0001pt;text-align:left;">守护进程独立于控制终端</p> 
<p style="margin-left:.0001pt;text-align:left;">比如：init进程 pid=1 开机运行 关机才结束</p> 
<p style="margin-left:.0001pt;text-align:left;">3.守护进程创建流程：</p> 
<blockquote> 
 <p style="margin-left:.0001pt;text-align:left;">1. 创建子进程，父进程退出</p> 
 <p style="margin-left:.0001pt;text-align:left;">fork(void);</p> 
 <p style="margin-left:.0001pt;text-align:left;">2. 在子进程中创建新会话</p> 
 <p style="margin-left:.0001pt;text-align:left;">setsid(void);</p> 
 <p style="margin-left:.0001pt;text-align:left;">3. 修改工作目录</p> 
 <p style="margin-left:.0001pt;text-align:left;">chdir("");</p> 
 <p style="margin-left:.0001pt;text-align:left;">4. 修改umask (增加安全性)</p> 
 <p style="margin-left:.0001pt;text-align:left;">umask();</p> 
 <p style="margin-left:.0001pt;text-align:left;">5. 关闭文件描述(回收资源)</p> 
 <p style="margin-left:.0001pt;text-align:left;">close();</p> 
</blockquote> 
<h3 style="margin-left:.0001pt;text-align:justify;">线程的概念</h3> 
<hr> 
<p style="margin-left:.0001pt;text-align:left;">1. 每个用户进程有自己的虚拟地址空间</p> 
<p style="margin-left:.0001pt;text-align:left;">2. 系统为每个用户进程创建一个</p> 
<p style="margin-left:.0001pt;text-align:left;">task_struct 来描述该进程 struct task_struct</p> 
<p style="margin-left:.0001pt;text-align:left;">3. task_struct 和地址空间映射表一起用来表示一个进程</p> 
<p style="margin-left:.0001pt;text-align:left;">4. 由于进程的虚拟地址空间是私有的，因此进程切换开销很大</p> 
<p style="margin-left:.0001pt;text-align:left;">5. 为了提高系统的性能，linux引入轻量级进程, 起名为线程</p> 
<p style="margin-left:.0001pt;text-align:left;">6. 在同一个进程中创建的线程共享该进程的地址空间</p> 
<p style="margin-left:.0001pt;text-align:left;">7. Linux里同样用task_struct来描述一个线程。</p> 
<p style="margin-left:.0001pt;text-align:left;">线程和进程都参与统一的调度</p> 
<p style="margin-left:.0001pt;text-align:left;">总结:</p> 
<p style="margin-left:.0001pt;text-align:left;">1. 通常线程指的是共享相同虚拟地址空间的多个任务</p> 
<p style="margin-left:.0001pt;text-align:left;">2. 使用多线程, 大大提高了任务切换的效率</p> 
<p style="margin-left:.0001pt;text-align:left;">线程不需要虚拟内存，为什么？</p> 
<p style="margin-left:.0001pt;text-align:left;">每个进程中至少有一个线程，就是主线程，还可以产生多个线程</p> 
<p style="margin-left:.0001pt;text-align:left;">共享4G内存空间，线程切换只需要虚拟CPU（寄存器）</p> 
<p style="margin-left:.0001pt;text-align:left;">同样用task_struct来描述一个线程，线程和进程都参于统一的调度</p> 
<p style="margin-left:.0001pt;text-align:left;">进程代表资源分配的最小单位</p> 
<p style="margin-left:.0001pt;text-align:left;">线程是最小的调度单位</p> 
<p style="margin-left:.0001pt;text-align:left;">线程概念：同一个地址空间中的多个任务</p> 
<h3 style="margin-left:.0001pt;text-align:justify;">线程相关的函数</h3> 
<hr> 
<p style="margin-left:.0001pt;text-align:left;">创建线程</p> 
<pre><code>#include &lt;pthread.h&gt;

pthread_t tid; //线程号

int pthread_create(

pthread_t *thread, const pthread_attr_t *attr,

void *(*start_routine) (void *), void *arg);</code></pre> 
<p style="margin-left:.0001pt;text-align:left;">参数：</p> 
<blockquote> 
 <p style="margin-left:.0001pt;text-align:left;">thread:  &amp;tid 线程号的地址</p> 
 <p style="margin-left:.0001pt;text-align:left;">attr: 线程函数的属性 一般设为NULL，默认属性</p> 
 <p style="margin-left:.0001pt;text-align:left;">start_routine: 线程函数的函数名</p> 
 <p style="margin-left:.0001pt;text-align:left;">arg: 给线程函数传递的参数 不传参设为NULL</p> 
 <p style="margin-left:.0001pt;text-align:left;">Compile and link with -pthread.</p> 
</blockquote> 
<p style="margin-left:.0001pt;text-align:left;">回收线程资源</p> 
<p style="margin-left:.0001pt;text-align:left;">主线程等待子线程结束，然后回收它的资源（阻塞）</p> 
<p style="margin-left:.0001pt;text-align:left;">int pthread_join(pthread_t thread, void **retval);</p> 
<p style="margin-left:.0001pt;text-align:left;">参数：</p> 
<blockquote> 
 <p style="margin-left:.0001pt;text-align:left;">thread: tid</p> 
 <p style="margin-left:.0001pt;text-align:left;">retval: 接收pthread_exit的返回值，设为NULL</p> 
</blockquote> 
<p style="margin-left:.0001pt;text-align:left;">把主线程和子线程分离开来，子线程结束，会自动回收资源</p> 
<p style="margin-left:.0001pt;text-align:left;">（非阻塞）</p> 
<p style="margin-left:.0001pt;text-align:left;">int pthread_detach(pthread_t thread);</p> 
<p style="margin-left:.0001pt;text-align:left;">参数：</p> 
<blockquote> 
 <p style="margin-left:.0001pt;text-align:left;">  thread:线程号 tid</p> 
</blockquote> 
<p style="margin-left:.0001pt;text-align:left;">结束子线程</p> 
<p style="margin-left:.0001pt;text-align:left;">void pthread_exit(void *retval);</p> 
<p style="margin-left:.0001pt;text-align:left;">线程传参</p> 
<blockquote> 
 <p style="margin-left:.0001pt;text-align:left;">{<!-- --></p> 
 <p style="margin-left:.0001pt;text-align:left;">​ 值传递</p> 
 <p style="margin-left:.0001pt;text-align:left;">​ 地址传递</p> 
 <p style="margin-left:.0001pt;text-align:left;">}</p> 
</blockquote> 
<p style="margin-left:.0001pt;text-align:left;">关闭线程</p> 
<p style="margin-left:.0001pt;text-align:left;">int pthread_cancel(pthread_t thread);</p> 
<p style="margin-left:.0001pt;text-align:left;">优点：线程间很容易进行通信</p> 
<p style="margin-left:.0001pt;text-align:left;">   通过全局变量实现数据共享和交换</p> 
<p style="margin-left:.0001pt;text-align:left;">缺点：多个线程同时访问共享对象</p> 
<p style="margin-left:.0001pt;text-align:left;">　　　　时需要引入同步和互斥机制</p> 
<p style="margin-left:.0001pt;text-align:left;">同步和互斥 ：保护共享资源，避免竟态</p> 
<p style="margin-left:.0001pt;text-align:left;">同步：多个任务按理想的顺序/步调来进行</p> 
<p style="margin-left:.0001pt;text-align:left;">互斥：不能同时访问</p> 
<p style="margin-left:.0001pt;text-align:left;">都是为了避免竟态：多个任务同时访问共享资源</p> 
<h3 style="margin-left:.0001pt;text-align:justify;">线程的同步------信号量</h3> 
<hr> 
<pre><code>#include &lt;semaphore.h&gt;

sem_t sem;

int sem_init(sem_t *sem, int pshared, unsigned int value);</code></pre> 
<p style="margin-left:.0001pt;text-align:left;">功能： 初始化信号量</p> 
<p style="margin-left:.0001pt;text-align:left;">参数:</p> 
<blockquote> 
 <p style="margin-left:.0001pt;text-align:left;">sem：  &amp;sem</p> 
 <p style="margin-left:.0001pt;text-align:left;">pshared:  0 线程     1 进程</p> 
 <p style="margin-left:.0001pt;text-align:left;">初值： 0 or 1  </p> 
 <p style="margin-left:.0001pt;text-align:left;">int sem_wait(sem_t *sem);    //-1</p> 
 <p style="margin-left:.0001pt;text-align:left;">当sem_init初值为0的时候，会阻塞</p> 
 <p style="margin-left:.0001pt;text-align:left;">int sem_post(sem_t *sem);    //+1</p> 
 <p style="margin-left:.0001pt;text-align:left;">buf: 全局变量</p> 
</blockquote> 
<p style="margin-left:.0001pt;text-align:left;">主线程：输入字符串</p> 
<p style="margin-left:.0001pt;text-align:left;">子线程：打印字符串的长度</p> 
<h3 style="margin-left:.0001pt;text-align:justify;">线程的互斥------互斥锁</h3> 
<hr> 
<p style="margin-left:.0001pt;text-align:left;">pthread_mutex_t mutex;</p> 
<p style="margin-left:.0001pt;text-align:left;">//初始化互斥锁</p> 
<p style="margin-left:.0001pt;text-align:left;">int pthread_mutex_init(pthread_mutex_t *mutex,  const</p> 
<p style="margin-left:.0001pt;text-align:left;">       pthread_mutexattr_t *mutexattr);</p> 
<p style="margin-left:.0001pt;text-align:left;">参数：</p> 
<p style="margin-left:.0001pt;text-align:left;">  &amp;mutex;</p> 
<p style="margin-left:.0001pt;text-align:left;">NULL (默认属性)</p> 
<p style="margin-left:.0001pt;text-align:left;">//加锁</p> 
<p style="margin-left:.0001pt;text-align:left;">int pthread_mutex_lock(pthread_mutex_t *mutex);</p> 
<p style="margin-left:.0001pt;text-align:left;">//解锁</p> 
<p style="margin-left:.0001pt;text-align:left;">int pthread_mutex_unlock(pthread_mutex_t *mutex);</p> 
<p style="margin-left:.0001pt;text-align:left;">同步：信号量</p> 
<blockquote> 
 <p style="margin-left:.0001pt;text-align:left;">sem_t sem;</p> 
 <p style="margin-left:.0001pt;text-align:left;">sem_init(&amp;sem, 0, 0);</p> 
 <p style="margin-left:.0001pt;text-align:left;">sem_wait(&amp;sem);  //-1</p> 
 <p style="margin-left:.0001pt;text-align:left;">sem_post(&amp;sem);  //+1</p> 
</blockquote> 
<p style="margin-left:.0001pt;text-align:left;">互斥：互斥锁</p> 
<blockquote> 
 <p style="margin-left:.0001pt;text-align:left;">pthread_mutex_t mutex;</p> 
 <p style="margin-left:.0001pt;text-align:left;">pthread_mutex_init(&amp;mutex, NULL);</p> 
 <p style="margin-left:.0001pt;text-align:left;">pthread_mutex_lock(&amp;mutex);</p> 
 <p style="margin-left:.0001pt;text-align:left;">pthread_mutex_unlock(&amp;mutex);</p> 
 <p style="margin-left:.0001pt;text-align:left;">}</p> 
</blockquote> 
<h3 style="margin-left:.0001pt;text-align:justify;">传统的进程间通信</h3> 
<hr> 
<p style="margin-left:.0001pt;text-align:left;">无名管道</p> 
<p style="margin-left:.0001pt;text-align:left;">有名管道</p> 
<p style="margin-left:.0001pt;text-align:left;">信号</p> 
<p style="margin-left:.0001pt;text-align:left;">原始的方式：用文件中转</p> 
<h4 style="margin-left:.0001pt;text-align:justify;">无名管道 （pipe）</h4> 
<hr> 
<p style="margin-left:.0001pt;text-align:left;">查看命令： man 2 pipe</p> 
<p style="margin-left:.0001pt;text-align:left;">头文件：#include &lt;unistd.h&gt;</p> 
<p style="margin-left:.0001pt;text-align:left;">函数原型： int pipe(int pipefd[2]);</p> 
<p style="margin-left:.0001pt;text-align:left;">pipefd[2] ：无名管道的两个文件描述符，int型的数组，大小为2，pipefd[0]为读端，pipefd[1]为写端</p> 
<p style="margin-left:.0001pt;text-align:left;">返回值：</p> 
<p style="margin-left:.0001pt;text-align:left;">成功：返回0</p> 
<p style="margin-left:.0001pt;text-align:left;">失败：返回-1</p> 
<p style="margin-left:.0001pt;text-align:left;">无名管道的特点：</p> 
<p style="margin-left:.0001pt;text-align:left;">a、没有名字，因此无法使用open()打开</p> 
<p style="margin-left:.0001pt;text-align:left;">b、只能用于亲缘进程间（如父子进程、兄弟进程、祖孙进程等）通信</p> 
<p style="margin-left:.0001pt;text-align:left;">c、半双工工作方式，读写端是分开的，pipefd[0]为读端，pipefd[1]为写端</p> 
<p style="margin-left:.0001pt;text-align:left;">d、是一种特殊的文件，只存在内存中，由内核进行管理</p> 
<p style="margin-left:.0001pt;text-align:left;">e、对于它的读写可以使用文件IO如read、write函数</p> 
<p style="margin-left:.0001pt;text-align:left;">f、无名管道的操作属于一次性操作，如果对无名管道进行读操作，数据会被全部读走</p> 
<p style="margin-left:.0001pt;text-align:left;">单工：固定一种方向进行通信  广播</p> 
<p style="margin-left:.0001pt;text-align:left;">半双工：同一时间只能由一端发送到另一端  对讲机</p> 
<p style="margin-left:.0001pt;text-align:left;">全双工：通信方向都可以，同时可以发送也可以接收电话</p> 
<p style="margin-left:.0001pt;text-align:left;">既然说是管道，所以可以想象成一条水管，连接两个进程，</p> 
<p style="margin-left:.0001pt;text-align:left;">一个进程负责输入数据，另一个进程负责接收数据，反过来也一样。</p> 
<p style="margin-left:.0001pt;text-align:left;">所以在无名管道中也一样，无名管道的两端，每一端都可以读和写。</p> 
<p style="margin-left:.0001pt;text-align:left;">若一端为读就要关闭他的写功能，另一端就只能为写关闭读功能。</p> 
<p style="margin-left:.0001pt;text-align:left;">注意事项：</p> 
<p style="margin-left:.0001pt;text-align:left;">1. 当管道中无数据时，执行读操作，读操作阻塞</p> 
<p style="margin-left:.0001pt;text-align:left;">2. 无名管道的大小是固定的，管道一旦满，写操作就会导致进程阻塞</p> 
<p style="margin-left:.0001pt;text-align:left;">3. 对无名管道的操作，类似一个队列，后写入的数据不会覆盖之前的数据，会在其后面存储，读取完的数据会从管道里面移除</p> 
<p style="margin-left:.0001pt;text-align:left;">4. 将读端关闭，向无名管道中写数据，管道破裂，进程收到信号（SIGPIPE）,默认这个信号会将进程杀死</p> 
<p style="margin-left:.0001pt;text-align:left;">5. 当管道中有数据，将写端关闭，读操作可以执行，之后数据读完，可以继续读取（非阻塞），直接返回0</p> 
<h4 style="margin-left:.0001pt;text-align:justify;">有名管道 (fifo)</h4> 
<hr> 
<p style="margin-left:.0001pt;text-align:left;">有名管道也叫命名管道，在文件系统目录中存在一个管道文件。</p> 
<p style="margin-left:.0001pt;text-align:left;">管道文件仅仅是文件系统中的标示，并不在磁盘上占据空间。在使用时，在内存上开辟空间，作为两个进程数据交互的通道。</p> 
<p style="margin-left:.0001pt;text-align:left;">1、查看命令：man 3 mkfifo</p> 
<p style="margin-left:.0001pt;text-align:left;">2、头文件：</p> 
<p style="margin-left:.0001pt;text-align:left;">#include &lt;sys/types.h&gt;</p> 
<p style="margin-left:.0001pt;text-align:left;">#include &lt;sys/stat.h&gt;</p> 
<p style="margin-left:.0001pt;text-align:left;">3、函数原型：</p> 
<p style="margin-left:.0001pt;text-align:left;">int mkfifo(const char *pathname, mode_t mode);</p> 
<p style="margin-left:.0001pt;text-align:left;">功能： 创建有名管道</p> 
<p style="margin-left:.0001pt;text-align:left;">参数：</p> 
<p style="margin-left:.0001pt;text-align:left;">  pathname: 文件路径名</p> 
<p style="margin-left:.0001pt;text-align:left;">  mode: 八进制 0666</p> 
<p style="margin-left:.0001pt;text-align:left;">在shell中使用mkfifo命令： mkfifo filename</p> 
<p style="margin-left:.0001pt;text-align:left;">eg:</p> 
<p style="margin-left:.0001pt;text-align:left;">mkfifo f1</p> 
<p style="margin-left:.0001pt;text-align:left;">or</p> 
<p style="margin-left:.0001pt;text-align:left;">if(mkfifo("fifo",0666) == -1)</p> 
<p style="margin-left:.0001pt;text-align:left;">{  </p> 
<p style="margin-left:.0001pt;text-align:left;">perror("mkfifo ");</p> 
<p style="margin-left:.0001pt;text-align:left;">return -1;</p> 
<p style="margin-left:.0001pt;text-align:left;">}</p> 
<p style="margin-left:.0001pt;text-align:left;">特点：</p> 
<p style="margin-left:.0001pt;text-align:left;">      1. 有名管道存在文件系统中，数据存在内存中</p> 
<p style="margin-left:.0001pt;text-align:left;">         2. 可以用于无亲缘关系的进程</p> 
<p style="margin-left:.0001pt;text-align:left;">         3. 只有读端和写端同时存在管道才能打开成功。</p> 
<p style="margin-left:.0001pt;text-align:left;">数据传输特点：</p> 
<p style="margin-left:.0001pt;text-align:left;">1、读端不存在时，写端写入数据将会阻塞</p> 
<p style="margin-left:.0001pt;text-align:left;">2、读端意外结束，写端再写数据将会管道破裂，该进程结束</p> 
<p style="margin-left:.0001pt;text-align:left;">3、有名管道的数据存储在内存中，数据交互在内核中</p> 
<h4 style="margin-left:.0001pt;text-align:left;">有名管道和无名管道的异同点</h4> 
<hr> 
<p style="margin-left:.0001pt;text-align:left;">1、相同点</p> 
<p style="margin-left:.0001pt;text-align:left;">open打开管道文件以后，在内存中开辟了一块空间，管道的内容在内存中存放，有两个指针—-头指针（指向写的位置）和尾指针（指向读的位置）指向它。读写数据都是在给内存的操作，并且都是半双工通讯。</p> 
<p style="margin-left:.0001pt;text-align:left;">2、区别</p> 
<p style="margin-left:.0001pt;text-align:left;">有名在任意进程之间使用，无名在父子进程之间使用</p> 
<h4 style="margin-left:.0001pt;text-align:justify;">信号</h4> 
<hr> 
<p style="margin-left:.0001pt;text-align:left;">简单概念：信号是在软件层次上对中断机制的一种模拟</p> 
<p style="margin-left:.0001pt;text-align:left;">kill把信号发送给进程或进程组;</p> 
<p style="margin-left:.0001pt;text-align:left;">raise把信号发送给(进程)自身.</p> 
<blockquote> 
 <p style="margin-left:.0001pt;text-align:left;">#include &lt;signal.h&gt;</p> 
 <p style="margin-left:.0001pt;text-align:left;">int kill(pid_t pid, int  signo);</p> 
 <p style="margin-left:.0001pt;text-align:left;">int raise(int  signo);</p> 
</blockquote> 
<p style="margin-left:.0001pt;text-align:left;">成功则返回0, 出错则返回-1</p> 
<blockquote> 
 <p style="margin-left:.0001pt;text-align:left;">raise(signo);   等价于  kill(getpid(), signo);</p> 
 <p style="margin-left:.0001pt;text-align:left;">alarm();//设置闹钟</p> 
 <p style="margin-left:.0001pt;text-align:left;">#include &lt;unistd.h&gt;</p> 
 <p style="margin-left:.0001pt;text-align:left;">unsigned int alarm(unsigned int seconds);</p> 
</blockquote> 
<p style="margin-left:.0001pt;text-align:left;">可以为当前进程定义闹钟，时间到了会发出SIGALRM信号。</p> 
<p style="margin-left:.0001pt;text-align:left;">每个进程只能有一个alarm，当重新定义时，会重新计时。</p> 
<p style="margin-left:.0001pt;text-align:left;">如果之前定义了一个闹钟，则这次定义返回的是上次闹钟剩余的时间，否则返回0.</p> 
<p style="margin-left:.0001pt;text-align:left;">pause();//程序暂停</p> 
<p style="margin-left:.0001pt;text-align:left;">pause函数的作用，是让当前进程暂停运行，交出CPU给其他进程去执行；</p> 
<p style="margin-left:.0001pt;text-align:left;">当前进程进入pause状态后，当前进程会表现为“卡住、阻塞住”；</p> 
<p style="margin-left:.0001pt;text-align:left;">要退出pause状态，当前进程需要被信号唤醒。</p> 
<p style="margin-left:.0001pt;text-align:left;">信号的三种处理方式：</p> 
<p style="margin-left:.0001pt;text-align:left;">1.忽略 2.默认 3.自定义信号处理函数</p> 
<p style="margin-left:.0001pt;text-align:left;">sighandler_t signal(int signum, sighandler_t handler);</p> 
<blockquote> 
 <p style="margin-left:.0001pt;text-align:left;">//捕获信号，设置信号的处理方式</p> 
 <p style="margin-left:.0001pt;text-align:left;">//handler: SIG_IGN:忽略</p> 
 <p style="margin-left:.0001pt;text-align:left;">//         SIG_DFL:默认</p> 
 <p style="margin-left:.0001pt;text-align:left;">//         自定义的信号处理函数</p> 
 <p style="margin-left:.0001pt;text-align:left;">SIGINT : ctrl + c</p> 
 <p style="margin-left:.0001pt;text-align:left;">SIGQUIT : ctrl +\</p> 
 <p style="margin-left:.0001pt;text-align:left;">SIGTSTP : ctrl + z</p> 
</blockquote> 
<h3 style="margin-left:.0001pt;text-align:justify;">进程间通信方式</h3> 
<hr> 
<p style="margin-left:.0001pt;text-align:left;">传统进程间通信方式：</p> 
<p style="margin-left:.0001pt;text-align:left;">无名管道</p> 
<p style="margin-left:.0001pt;text-align:left;">有名管道</p> 
<p style="margin-left:.0001pt;text-align:left;">信号</p> 
<p style="margin-left:.0001pt;text-align:left;">system V的IPC对象：</p> 
<p style="margin-left:.0001pt;text-align:left;">共享内存（share memory）</p> 
<p style="margin-left:.0001pt;text-align:left;">消息队列（message queue）</p> 
<p style="margin-left:.0001pt;text-align:left;">信号灯集</p> 
<p style="margin-left:.0001pt;text-align:left;">BSD: 套接字</p> 
<p style="margin-left:.0001pt;text-align:left;">ipcs</p> 
<blockquote> 
 <p style="margin-left:.0001pt;text-align:left;">ipcs -m :查询显示当前系统的共享内存</p> 
 <p style="margin-left:.0001pt;text-align:left;">ipcs -q  :查询显示当前系统的消息队列</p> 
 <p style="margin-left:.0001pt;text-align:left;">ipcs -s   :查询显示当前系统的信号灯集</p> 
 <p style="margin-left:.0001pt;text-align:left;">ipcrm -m shmid：删除某个共享内存</p> 
 <p style="margin-left:.0001pt;text-align:left;">ipcrm -q msgid：删除某个消息队列</p> 
 <p style="margin-left:.0001pt;text-align:justify;">ipcrm -s semid：删除某个信号灯集</p> 
</blockquote> 
<h3 style="margin-left:.0001pt;text-align:justify;">IPC步骤：</h3> 
<hr> 
<p style="margin-left:.0001pt;text-align:left;">  key     id</p> 
<p style="margin-left:.0001pt;text-align:left;">ftok ----&gt; shm_get/msg_get/sem_get ----&gt;</p> 
<p style="margin-left:.0001pt;text-align:left;"> shmmat/shmdt/shmctrl</p> 
<p style="margin-left:.0001pt;text-align:left;"> msgctrl/msgsend/msgrecv</p> 
<p style="margin-left:.0001pt;text-align:left;"> semctrl/semop</p> 
<p style="margin-left:.0001pt;text-align:left;">```</p> 
<p style="margin-left:.0001pt;text-align:left;">ftok函数</p> 
<p style="margin-left:.0001pt;text-align:left;">函数原型：  </p> 
<p style="margin-left:.0001pt;text-align:left;">功能：  </p> 
<p style="margin-left:.0001pt;text-align:left;">参数：  </p> 
<p style="margin-left:.0001pt;text-align:left;">返回值：</p> 
<h3 style="margin-left:.0001pt;text-align:left;">共享内存share memory</h3> 
<hr> 
<p style="margin-left:.0001pt;text-align:left;">是一种通信效率最高的进程间通信方式，</p> 
<p style="margin-left:.0001pt;text-align:left;">进程间通信时直接访问内存，不需要进行数据的拷贝。</p> 
<blockquote> 
 <p style="margin-left:.0001pt;text-align:left;">#include &lt;sys/types.h&gt;</p> 
 <p style="margin-left:.0001pt;text-align:left;">#include &lt;sys/ipc.h&gt;</p> 
 <p style="margin-left:.0001pt;text-align:left;">#include &lt;sys/shm.h&gt;</p> 
</blockquote> 
<p style="margin-left:.0001pt;text-align:left;">步骤：</p> 
<blockquote> 
 <p style="margin-left:.0001pt;text-align:left;">  1. ftok</p> 
 <p style="margin-left:.0001pt;text-align:left;">  2. shmget</p> 
 <p style="margin-left:.0001pt;text-align:left;">  3. shmat</p> 
 <p style="margin-left:.0001pt;text-align:left;">  4. 进程间通信 fork</p> 
 <p style="margin-left:.0001pt;text-align:left;">  5. shmdt</p> 
 <p style="margin-left:.0001pt;text-align:left;">  6. shmctl</p> 
</blockquote> 
<h3 style="margin-left:.0001pt;text-align:justify;">消息队列</h3> 
<hr> 
<blockquote> 
 <p style="margin-left:.0001pt;text-align:left;">#include &lt;sys/types.h&gt;</p> 
 <p style="margin-left:.0001pt;text-align:left;">#include &lt;sys/ipc.h&gt;</p> 
 <p style="margin-left:.0001pt;text-align:left;">#include &lt;sys/msg.h&gt;</p> 
</blockquote> 
<p style="margin-left:.0001pt;text-align:left;">步骤：</p> 
<blockquote> 
 <p style="margin-left:.0001pt;text-align:left;">1. ftok</p> 
 <p style="margin-left:.0001pt;text-align:left;">2. msgget</p> 
 <p style="margin-left:.0001pt;text-align:left;">3. 进程间通信</p> 
 <p style="margin-left:.0001pt;text-align:left;">4. msgsnd</p> 
 <p style="margin-left:.0001pt;text-align:left;">5. magrcv</p> 
 <p style="margin-left:.0001pt;text-align:left;">6. msgctl</p> 
</blockquote> 
<h3 style="margin-left:.0001pt;text-align:justify;">信号灯集</h3> 
<hr> 
<blockquote> 
 <p style="margin-left:.0001pt;text-align:left;">#include &lt;sys/types.h&gt;</p> 
 <p style="margin-left:.0001pt;text-align:left;">#include &lt;sys/ipc.h&gt;</p> 
 <p style="margin-left:.0001pt;text-align:left;">#include &lt;sys/sem.h&gt;</p> 
</blockquote> 
<p style="margin-left:.0001pt;text-align:left;">步骤：</p> 
<blockquote> 
 <p style="margin-left:.0001pt;text-align:left;">  1. ftok</p> 
 <p style="margin-left:.0001pt;text-align:left;">  2. shmget</p> 
 <p style="margin-left:.0001pt;text-align:left;">  3. shmat</p> 
 <p style="margin-left:.0001pt;text-align:left;">* 4. semget</p> 
 <p style="margin-left:.0001pt;text-align:left;">* 5. semctl</p> 
 <p style="margin-left:.0001pt;text-align:left;">  6. 进程间通信</p> 
 <p style="margin-left:.0001pt;text-align:left;">* 7. semop</p> 
 <p style="margin-left:.0001pt;text-align:left;">* 8. semctl</p> 
 <p style="margin-left:.0001pt;text-align:left;">   9. shmdt</p> 
 <p style="margin-left:.0001pt;text-align:left;">   10. shmctl</p> 
</blockquote> 
<h2 style="margin-left:.0001pt;text-align:left;"> 网络编程</h2> 
<hr> 
<h3 style="margin-left:.0001pt;text-align:left;">进程通信</h3> 
<hr> 
<p style="margin-left:.0001pt;text-align:left;">{<!-- --></p> 
<p style="margin-left:.0001pt;text-align:left;">1.无名管道 2有名管道 3.信号</p> 
<p style="margin-left:.0001pt;text-align:left;">1.共享内存 2.消息队列 3.信号灯集</p> 
<p style="margin-left:.0001pt;text-align:left;">套接字</p> 
<p style="margin-left:.0001pt;text-align:left;">}</p> 
<h3 style="margin-left:.0001pt;text-align:left;">网络编程</h3> 
<hr> 
<p style="margin-left:.0001pt;text-align:left;">{<!-- --></p> 
<p style="margin-left:.0001pt;text-align:left;">历史：1957年 前苏联发射两枚卫星</p> 
<p style="margin-left:.0001pt;text-align:left;">  1958年提出DARPA</p> 
<p style="margin-left:.0001pt;text-align:left;">  1968年6月DARPA提出“资源共享计算机网络”</p> 
<p style="margin-left:.0001pt;text-align:left;">  1974年12月两人正式发表第一份TCP协议详细说明，但此协议在有数据包丢失时不能有效的纠正</p> 
<p style="margin-left:.0001pt;text-align:left;">  ARRPA 网前期有两个缺点{<!-- --></p> 
<p style="margin-left:.0001pt;text-align:left;">1.只能连接ARRPA主机</p> 
<p style="margin-left:.0001pt;text-align:left;">2.数据交互不能保证传输稳定</p> 
<p style="margin-left:.0001pt;text-align:left;">  }</p> 
<h3 style="margin-left:.0001pt;text-align:left;">tcp/ip协议</h3> 
<hr> 
<p style="margin-left:.0001pt;text-align:left;">{<!-- --></p> 
<p style="margin-left:.0001pt;text-align:left;">1.tcp 解决数据传输问题</p> 
<p style="margin-left:.0001pt;text-align:left;">2.ip  解决不同网络之间的连接</p> 
<p style="margin-left:.0001pt;text-align:left;">  }</p> 
<h3 style="margin-left:.0001pt;text-align:left;">osi七层模型：</h3> 
<hr> 
<p style="margin-left:.0001pt;text-align:left;">   应用层    app</p> 
<p style="margin-left:.0001pt;text-align:left;">   表示层    数据加密解析</p> 
<p style="margin-left:.0001pt;text-align:left;">   会话层    建立逻辑名字和物理名字的联系</p> 
<p style="margin-left:.0001pt;text-align:left;">   传输层    确保数据的传输，流量控制</p> 
<p style="margin-left:.0001pt;text-align:left;">   网络层    数据分组，选择路由</p> 
<p style="margin-left:.0001pt;text-align:left;">   数据链路层  把数据组装成可以发送的帧格式</p> 
<p style="margin-left:.0001pt;text-align:left;">   物理层     把数据转化成物理信号  </p> 
<h3 style="margin-left:.0001pt;text-align:left;">tcp/ip协议模型：</h3> 
<hr> 
<p style="margin-left:.0001pt;text-align:left;">  应用层</p> 
<p style="margin-left:.0001pt;text-align:left;">  传输层 tcp/udp</p> 
<p style="margin-left:.0001pt;text-align:left;">  网络层</p> 
<p style="margin-left:.0001pt;text-align:left;">  网络接口和物理层</p> 
<p style="margin-left:.0001pt;text-align:left;">tcp/ip协议传输的数据格式组装过程</p> 
<p style="margin-left:.0001pt;text-align:left;">tcp 稳定可靠，有连接，无失序，数据流式</p> 
<p style="margin-left:.0001pt;text-align:left;">udp 不稳定，无连接，有失序，数据报式</p> 
<h3 style="margin-left:.0001pt;text-align:left;">tcp协议</h3> 
<hr> 
<p style="margin-left:.0001pt;text-align:left;">{<!-- --></p> 
<p style="margin-left:.0001pt;text-align:left;">ip地址：标识唯一主机  ipv4 4字节 点分形式：192.168.7.33</p> 
<p style="margin-left:.0001pt;text-align:left;">端口号：标识进程 2字节 0到1023系统   1024-5000应用 5001 - 65535</p> 
<p style="margin-left:.0001pt;text-align:left;">地址族：说明ip的类型</p> 
<h3 style="margin-left:.0001pt;text-align:left;">cs架构</h3> 
<hr> 
<p style="margin-left:.0001pt;text-align:left;">服务器：{<!-- --></p> 
<p style="margin-left:.0001pt;text-align:left;">1.创建套接字</p> 
<p style="margin-left:.0001pt;text-align:left;"> int socket(int domain, int type, int protocol);</p> 
<p style="margin-left:.0001pt;text-align:left;"> 返回值： 成功返回文件描述符， 失败返回-1</p> 
<p style="margin-left:.0001pt;text-align:left;"> 参数：domain：地址族 ipv4 AF_INET</p> 
<p style="margin-left:.0001pt;text-align:left;">   type: 套接字类型 tcp SOCK_STREAM</p> 
<p style="margin-left:.0001pt;text-align:left;">   protocol：协议 0默认协议</p> 
<p style="margin-left:.0001pt;text-align:left;">2.绑定套接字信息 ip地址  端口号  地址族</p> 
<blockquote> 
 <p style="margin-left:.0001pt;text-align:left;"> struct sockaddr_in {<!-- --></p> 
 <p style="margin-left:.0001pt;text-align:left;">   sa_family_t    sin_family; /* address family: AF_INET */</p> 
 <p style="margin-left:.0001pt;text-align:left;">   in_port_t      sin_port;   /* port in network byte order */</p> 
 <p style="margin-left:.0001pt;text-align:left;">   struct in_addr sin_addr;   /* internet address */</p> 
 <p style="margin-left:.0001pt;text-align:left;">   };</p> 
 <p style="margin-left:.0001pt;text-align:left;">   /* Internet address. */</p> 
 <p style="margin-left:.0001pt;text-align:left;">   struct in_addr {<!-- --></p> 
 <p style="margin-left:.0001pt;text-align:left;">   uint32_t       s_addr;     /* address in network byte order */</p> 
 <p style="margin-left:.0001pt;text-align:left;">   };</p> 
 <p style="margin-left:.0001pt;text-align:left;">int bind(int sockfd, const struct sockaddr *addr,</p> 
 <p style="margin-left:.0001pt;text-align:left;">                socklen_t addrlen);</p> 
</blockquote> 
<p style="margin-left:.0001pt;text-align:left;">返回值：成功返回0 失败-1</p> 
<p style="margin-left:.0001pt;text-align:left;">参数：sockfd：套接字文件描述符</p> 
<p style="margin-left:.0001pt;text-align:left;">  addr：存储信息的结构体地址</p> 
<p style="margin-left:.0001pt;text-align:left;">    {<!-- --></p> 
<p style="margin-left:.0001pt;text-align:left;">127.0.0.1  本机回环地址，作于测试</p> 
<p style="margin-left:.0001pt;text-align:left;">0.0.0.0    本机地址</p> 
<p style="margin-left:.0001pt;text-align:left;">}</p> 
<p style="margin-left:.0001pt;text-align:left;">  addrlen：结构体大小</p> 
<h3 style="margin-left:.0001pt;text-align:left;">大小端：</h3> 
<hr> 
<p style="margin-left:.0001pt;text-align:left;">{<!-- --></p> 
<p style="margin-left:.0001pt;text-align:left;">大端存储：低字节存在高位，高字节存低位</p> 
<p style="margin-left:.0001pt;text-align:left;">小端存储：低字节存在低位，高字节存高位</p> 
<p style="margin-left:.0001pt;text-align:left;">}</p> 
<p style="margin-left:.0001pt;text-align:left;">htons（） 把短整型转换位网络字节序</p> 
<p style="margin-left:.0001pt;text-align:left;">ntohs（） 把网络字节序转换为短整型</p> 
<p style="margin-left:.0001pt;text-align:left;">innet_addr() 把字符串转换为网络字节序</p> 
<p style="margin-left:.0001pt;text-align:left;">inet_ntoa()  把网络字节序转换为字符串</p> 
<p style="margin-left:.0001pt;text-align:left;">3.监听套接字</p> 
<p style="margin-left:.0001pt;text-align:left;"> int listen(int sockfd, int backlog);</p> 
<p style="margin-left:.0001pt;text-align:left;"> 设置监听队列</p> 
<p style="margin-left:.0001pt;text-align:left;"> 返回值：成功返回0 失败 -1</p> 
<p style="margin-left:.0001pt;text-align:left;"> 参数:  sockfd:套接字文件描述符</p> 
<p style="margin-left:.0001pt;text-align:left;">backlog：监听队列的大小一般3到4</p> 
<p style="margin-left:.0001pt;text-align:left;">4.被动等待连接 阻塞</p> 
<p style="margin-left:.0001pt;text-align:left;">accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);</p> 
<p style="margin-left:.0001pt;text-align:left;">返回值：成功返回客户端文件描述符，失败-1</p> 
<p style="margin-left:.0001pt;text-align:left;">参数： sockfd：服务器套接字</p> 
<p style="margin-left:.0001pt;text-align:left;">   addr：存客户端信息</p> 
<p style="margin-left:.0001pt;text-align:left;">   addrlen：结构体大小</p> 
<p style="margin-left:.0001pt;text-align:left;">通信：接收客户端信息</p> 
<p style="margin-left:.0001pt;text-align:left;">  处理信息</p> 
<p style="margin-left:.0001pt;text-align:left;">  返回信息</p> 
<p style="margin-left:.0001pt;text-align:left;">}</p> 
<p style="margin-left:.0001pt;text-align:left;">客户端{<!-- --></p> 
<p style="margin-left:.0001pt;text-align:left;">1.创建套接字</p> 
<p style="margin-left:.0001pt;text-align:left;">2.绑定/可选</p> 
<p style="margin-left:.0001pt;text-align:left;">3.连接connect</p> 
<p style="margin-left:.0001pt;text-align:left;">}</p> 
<p style="margin-left:.0001pt;text-align:left;">}</p> 
<h3 style="margin-left:.0001pt;text-align:left;">三次握手：</h3> 
<hr> 
<p style="margin-left:.0001pt;text-align:left;">SYN请求连接信号 0代表没确认 1代表确认</p> 
<p style="margin-left:.0001pt;text-align:left;">seq信息编号 记录发送数据的编号</p> 
<p style="margin-left:.0001pt;text-align:left;">ACK确认信号 0代表没确认 1代表确认</p> 
<p style="margin-left:.0001pt;text-align:left;">ack确认的包的编号 值应该是seq加1</p> 
<p style="margin-left:.0001pt;text-align:left;">一：客户端向服务器发送建立连接请求（SYN=1），数据包编号seq=x，客户端从CLOSED-&gt;SYN_SENT</p> 
<p style="margin-left:.0001pt;text-align:left;">二：服务器收到客户端请求：发送建立连接请求（SYN=1），数据包编号seq=y</p> 
<p style="margin-left:.0001pt;text-align:left;">    回复客户端请求（ACK=1， ack=x+1） 服务器从LISTEN-&gt;SYN_RCVD</p> 
<p style="margin-left:.0001pt;text-align:left;">三：客户端收到服务器请求：回复服务器（ACK=1， ack=y+1） 客户端从SYN_SENT-&gt;ESTABLISHED</p> 
<p style="margin-left:.0001pt;text-align:left;">服务器收到最后一条信息之后，从SYN_RCVD--&gt;ESTABLISHED</p> 
<h3 style="margin-left:.0001pt;text-align:left;">四次挥手：</h3> 
<hr> 
<p style="margin-left:.0001pt;text-align:left;">一：客户端向服务器发送断开连接请求（FIN = 1）,数据包编号u，客户端从ESTABLISHED-》FIN_WAIT_1</p> 
<p style="margin-left:.0001pt;text-align:left;">二：服务器收到客户端请求：发送（ACK = 1， ack=u+1），剩余数据 （seq = v）服务器从ESTABLISHED-》CLOSE_WAIT   客户端从FIN_WAIT_1-》FIN_WAIT_2</p> 
<p style="margin-left:.0001pt;text-align:left;">三：服务向客户端发送断开连接请求（FIN=1， seq=w， ack=u+1） 服务器从CLOSE_WAIT-》LAST_ACK</p> 
<p style="margin-left:.0001pt;text-align:left;">四：客户端收到服务器请求：（ACK=1， ack=w+1）  客户端从FIN_WAIT_2-》TIME_WAIT  等待两个最长报文时间，进入CLOSED</p> 
<p style="margin-left:.0001pt;text-align:left;">当服务器收到最后一次确认从LAST_ACK-》CLOSED</p> 
<p style="margin-left:.0001pt;text-align:left;">昨天服务器的两个问题</p> 
<p style="margin-left:.0001pt;text-align:left;">1.不能连续发送和接收（进程，线程）</p> 
<blockquote> 
 <p style="margin-left:.0001pt;text-align:left;">{<!-- --></p> 
 <p style="margin-left:.0001pt;text-align:left;">fork()</p> 
 <p style="margin-left:.0001pt;text-align:left;">while(1)</p> 
 <p style="margin-left:.0001pt;text-align:left;">{<!-- --></p> 
 <p style="margin-left:.0001pt;text-align:left;">if(pid == 0)</p> 
 <p style="margin-left:.0001pt;text-align:left;">{<!-- --></p> 
 <p style="margin-left:.0001pt;text-align:left;">while(1)</p> 
 <p style="margin-left:.0001pt;text-align:left;">{<!-- --></p> 
 <p style="margin-left:.0001pt;text-align:left;">read</p> 
 <p style="margin-left:.0001pt;text-align:left;">}</p> 
 <p style="margin-left:.0001pt;text-align:left;">}</p> 
 <p style="margin-left:.0001pt;text-align:left;">write</p> 
 <p style="margin-left:.0001pt;text-align:left;">}</p> 
 <p style="margin-left:.0001pt;text-align:left;">}</p> 
</blockquote> 
<p style="margin-left:.0001pt;text-align:left;">2.不能同时连接多个客户端</p> 
<blockquote> 
 <p style="margin-left:.0001pt;text-align:left;">while(1)</p> 
 <p style="margin-left:.0001pt;text-align:left;">{<!-- --></p> 
 <p style="margin-left:.0001pt;text-align:left;">connfd = accept()</p> 
 <p style="margin-left:.0001pt;text-align:left;">if(pid == 0)</p> 
 <p style="margin-left:.0001pt;text-align:left;">{<!-- --></p> 
 <p style="margin-left:.0001pt;text-align:left;">功能</p> 
 <p style="margin-left:.0001pt;text-align:left;">}</p> 
 <p style="margin-left:.0001pt;text-align:left;">}</p> 
</blockquote> 
<h3 style="margin-left:.0001pt;text-align:left;">并发服务器模型</h3> 
<hr> 
<p style="margin-left:.0001pt;text-align:left;">{<!-- --></p> 
<h4 style="margin-left:.0001pt;text-align:left;">多进程实现</h4> 
<hr> 
<p style="margin-left:.0001pt;text-align:left;">{<!-- --></p> 
<p style="margin-left:.0001pt;text-align:left;">优点：相互独立抗干扰</p> 
<p style="margin-left:.0001pt;text-align:left;">缺点：开辟进程的数量是有限的，占用资源，进程交互比较麻烦</p> 
<p style="margin-left:.0001pt;text-align:left;">}</p> 
<p style="margin-left:.0001pt;text-align:left;">eg：</p> 
<p style="margin-left:.0001pt;text-align:left;">int main()</p> 
<p style="margin-left:.0001pt;text-align:left;">{<!-- --></p> 
<p style="margin-left:.0001pt;text-align:left;">1.创建套接字 socket</p> 
<p style="margin-left:.0001pt;text-align:left;">2.绑定套接字 bind</p> 
<p style="margin-left:.0001pt;text-align:left;">3.监听套接字 listen</p> 
<p style="margin-left:.0001pt;text-align:left;">捕获17号信号，回收子进程资源 signal</p> 
<p style="margin-left:.0001pt;text-align:left;">while(1)</p> 
<p style="margin-left:.0001pt;text-align:left;">{<!-- --></p> 
<p style="margin-left:.0001pt;text-align:left;">4.被动等待连接 accept</p> 
<p style="margin-left:.0001pt;text-align:left;">fork()</p> 
<p style="margin-left:.0001pt;text-align:left;">if（pid == 0）</p> 
<p style="margin-left:.0001pt;text-align:left;">{<!-- --></p> 
<p style="margin-left:.0001pt;text-align:left;">处理客户端请求</p> 
<p style="margin-left:.0001pt;text-align:left;">if(0==read)</p> 
<p style="margin-left:.0001pt;text-align:left;">close(connfd);</p> 
<p style="margin-left:.0001pt;text-align:left;">exit(0);</p> 
<p style="margin-left:.0001pt;text-align:left;">}</p> 
<p style="margin-left:.0001pt;text-align:left;">}</p> 
<p style="margin-left:.0001pt;text-align:left;">close(sockfd);</p> 
<p style="margin-left:.0001pt;text-align:left;">}</p> 
<p style="margin-left:.0001pt;text-align:left;">难点：资源回收， signal（）捕获17号信号，回收子进程资源</p> 
<h4 style="margin-left:.0001pt;text-align:left;">多线程实现</h4> 
<hr> 
<p style="margin-left:.0001pt;text-align:left;">{<!-- --></p> 
<p style="margin-left:.0001pt;text-align:left;">优点：交互简单，资源占用小</p> 
<p style="margin-left:.0001pt;text-align:left;">缺点：抗干扰能力弱，需要考虑共享数据同步互斥</p> 
<p style="margin-left:.0001pt;text-align:left;">}</p> 
<p style="margin-left:.0001pt;text-align:left;">int main()</p> 
<p style="margin-left:.0001pt;text-align:left;">{<!-- --></p> 
<p style="margin-left:.0001pt;text-align:left;">1.创建套接字 socket</p> 
<p style="margin-left:.0001pt;text-align:left;">2.绑定套接字 bind</p> 
<p style="margin-left:.0001pt;text-align:left;">3.监听套接字 listen</p> 
<p style="margin-left:.0001pt;text-align:left;">while(1)</p> 
<p style="margin-left:.0001pt;text-align:left;">{<!-- --></p> 
<p style="margin-left:.0001pt;text-align:left;">4.被动等待连接 accept</p> 
<p style="margin-left:.0001pt;text-align:left;">pthread_create();</p> 
<p style="margin-left:.0001pt;text-align:left;">pthread_detach();</p> 
<p style="margin-left:.0001pt;text-align:left;">}</p> 
<p style="margin-left:.0001pt;text-align:left;">close(sockfd);</p> 
<p style="margin-left:.0001pt;text-align:left;">}</p> 
<p style="margin-left:.0001pt;text-align:left;">void*func(int *arg)</p> 
<p style="margin-left:.0001pt;text-align:left;">{<!-- --></p> 
<p style="margin-left:.0001pt;text-align:left;">while(1)</p> 
<p style="margin-left:.0001pt;text-align:left;">{<!-- --></p> 
<p style="margin-left:.0001pt;text-align:left;">处理客户端请求;</p> 
<p style="margin-left:.0001pt;text-align:left;">if(0 == read)</p> 
<p style="margin-left:.0001pt;text-align:left;">{<!-- --></p> 
<p style="margin-left:.0001pt;text-align:left;">break;</p> 
<p style="margin-left:.0001pt;text-align:left;">}</p> 
<p style="margin-left:.0001pt;text-align:left;">}</p> 
<p style="margin-left:.0001pt;text-align:left;">pthread_exit(NULL);</p> 
<p style="margin-left:.0001pt;text-align:left;">}</p> 
<p style="margin-left:.0001pt;text-align:left;">难点：资源回收，pthread_detach()  线程设置为分离属性，子线程自己回收资源</p> 
<h3 style="margin-left:.0001pt;text-align:left;">IO多路复用</h3> 
<hr> 
<p style="margin-left:.0001pt;text-align:left;">1.使用多进程，和多个客户端交流，需要读写分离，可以控制发送数据给哪个客户端</p> 
<p style="margin-left:.0001pt;text-align:left;">}</p> 
<p style="margin-left:.0001pt;text-align:left;">UDP</p> 
<p style="margin-left:.0001pt;text-align:left;">无连接，有失序，数据报式，不稳定</p> 
<p style="margin-left:.0001pt;text-align:left;">服务器{<!-- --></p> 
<p style="margin-left:.0001pt;text-align:left;">1.创建套接字 SOCK_DGRAM</p> 
<p style="margin-left:.0001pt;text-align:left;">2.绑定套接字信息</p> 
<p style="margin-left:.0001pt;text-align:left;">while（1）</p> 
<p style="margin-left:.0001pt;text-align:left;">{<!-- --></p> 
<p style="margin-left:.0001pt;text-align:left;">交互</p> 
<p style="margin-left:.0001pt;text-align:left;">}</p> 
<p style="margin-left:.0001pt;text-align:left;">ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags,struct sockaddr *src_addr, socklen_t *addrlen);</p> 
<p style="margin-left:.0001pt;text-align:left;">}</p> 
<p style="margin-left:.0001pt;text-align:left;">客户端{<!-- --></p> 
<p style="margin-left:.0001pt;text-align:left;">1.创建套接字 SOCK_DGRAM</p> 
<p style="margin-left:.0001pt;text-align:left;">2.绑定套接字信息（可省略）</p> 
<p style="margin-left:.0001pt;text-align:left;">while（1）</p> 
<p style="margin-left:.0001pt;text-align:left;">{<!-- --></p> 
<p style="margin-left:.0001pt;text-align:left;">交互</p> 
<p style="margin-left:.0001pt;text-align:left;">}</p> 
<p style="margin-left:.0001pt;text-align:left;">ssize_t sendto(int sockfd, const void *buf, size_t len, int flags,</p> 
<p style="margin-left:.0001pt;text-align:left;">                      const struct sockaddr *dest_addr, socklen_t addrlen);</p> 
<p style="margin-left:.0001pt;text-align:left;">}</p> 
<p style="margin-left:.0001pt;text-align:left;">}</p> 
<h3 style="margin-left:.0001pt;text-align:left;">IO模型</h3> 
<hr> 
<p style="margin-left:.0001pt;text-align:left;">{<!-- --></p> 
<p style="margin-left:.0001pt;text-align:left;">1.阻塞   read fgets rcv</p> 
<p style="margin-left:.0001pt;text-align:left;">缺点：阻塞之后没办法执行其他功能</p> 
<p style="margin-left:.0001pt;text-align:left;">优点：逻辑简单，资源占用不高</p> 
<p style="margin-left:.0001pt;text-align:left;">2.非阻塞 write 缓存区满（阻塞）</p> 
<p style="margin-left:.0001pt;text-align:left;">缺点：需要循环遍历，cpu占用高</p> 
<p style="margin-left:.0001pt;text-align:left;">优点：不会影响其他功能执行</p> 
<p style="margin-left:.0001pt;text-align:left;">3.信号驱动</p> 
<p style="margin-left:.0001pt;text-align:left;">4.io多路复用{<!-- --></p> 
<p style="margin-left:.0001pt;text-align:left;">select</p> 
<p style="margin-left:.0001pt;text-align:left;">poll</p> 
<p style="margin-left:.0001pt;text-align:left;">epoll</p> 
<p style="margin-left:.0001pt;text-align:left;">}</p> 
<p style="margin-left:.0001pt;text-align:left;">5.异步IO</p> 
<p style="margin-left:.0001pt;text-align:left;">在系统注册回调，如果有文件描述符准备好，直接执行回调，控制驱动</p> 
<p style="margin-left:.0001pt;text-align:left;">}</p> 
<p style="margin-left:.0001pt;text-align:left;"> int fcntl(int fd, int cmd, ... /* arg */ );</p> 
<p style="margin-left:.0001pt;text-align:left;"> 参数：fd：需要操作的文件描述符</p> 
<p style="margin-left:.0001pt;text-align:left;">   cmd：对文件操作的命令</p> 
<p style="margin-left:.0001pt;text-align:left;">   不定参数：</p> 
<p style="margin-left:.0001pt;text-align:left;">F_GETFL (void)获取文件描述符flags  </p> 
<p style="margin-left:.0001pt;text-align:left;">F_SETFL (int)设置文件描述符flags</p> 
<h3 style="margin-left:.0001pt;text-align:left;">IO多路复用</h3> 
<hr> 
<p style="margin-left:.0001pt;text-align:left;">{<!-- --></p> 
<p style="margin-left:.0001pt;text-align:left;">int select(int nfds, fd_set *readfds, fd_set *writefds,</p> 
<p style="margin-left:.0001pt;text-align:left;">                  fd_set *exceptfds, struct timeval *timeout);</p> 
<p style="margin-left:.0001pt;text-align:left;">功能：把关心的位图，传递给内核，让内核帮忙轮询，如果有准备好的事件就标记并且返回准备好的文件描述符个数</p> 
<p style="margin-left:.0001pt;text-align:left;">返回值：成功返回准备好的文件描述符个数</p> 
<p style="margin-left:.0001pt;text-align:left;">    失败-1，0代表超时；</p> 
<p style="margin-left:.0001pt;text-align:left;">参数：nfds：最大文件描述符加1</p> 
<p style="margin-left:.0001pt;text-align:left;">  readfds：读事件的位图</p> 
<p style="margin-left:.0001pt;text-align:left;">  writefds：写事件的位图</p> 
<p style="margin-left:.0001pt;text-align:left;">  exceptfds：其他事件位图</p> 
<p style="margin-left:.0001pt;text-align:left;">  timeout：struct timeval {<!-- --></p> 
<p style="margin-left:.0001pt;text-align:left;">   long    tv_sec;         /* seconds */  秒</p> 
<p style="margin-left:.0001pt;text-align:left;">   long    tv_usec;        /* microseconds */微秒</p> 
<p style="margin-left:.0001pt;text-align:left;">};</p> 
<p style="margin-left:.0001pt;text-align:left;">       void FD_CLR(int fd, fd_set *set);  删除位图中某个元素</p> 
<p style="margin-left:.0001pt;text-align:left;">       int  FD_ISSET(int fd, fd_set *set); 判断文件描述符是否准备好 准备好返回真，没准备好返回-1</p> 
<p style="margin-left:.0001pt;text-align:left;">       void FD_SET(int fd, fd_set *set); 把某个文件描述符加入到位图</p> 
<p style="margin-left:.0001pt;text-align:left;">       void FD_ZERO(fd_set *set);   把位图清空</p> 
<p style="margin-left:.0001pt;text-align:left;">  int fd1， fd2， fd3；</p> 
<p style="margin-left:.0001pt;text-align:left;">  fd1 = open（）</p> 
<p style="margin-left:.0001pt;text-align:left;">  fd2 = open（）</p> 
<p style="margin-left:.0001pt;text-align:left;">  fd3 = open（）</p> 
<p style="margin-left:.0001pt;text-align:left;">  fd_set readfd, temp;</p> 
<p style="margin-left:.0001pt;text-align:left;">  FD_ZERO(&amp;readfd);</p> 
<p style="margin-left:.0001pt;text-align:left;">  FD_SET(fd1, &amp;readfd);</p> 
<p style="margin-left:.0001pt;text-align:left;">  FD_SET(fd2, &amp;readfd);</p> 
<p style="margin-left:.0001pt;text-align:left;">  FD_SET(fd3, &amp;readfd);</p> 
<p style="margin-left:.0001pt;text-align:left;">  int nfds = fd3+1;</p> 
<p style="margin-left:.0001pt;text-align:left;">  temp = readfd;</p> 
<p style="margin-left:.0001pt;text-align:left;">  while(1)</p> 
<p style="margin-left:.0001pt;text-align:left;">  {<!-- --></p> 
<p style="margin-left:.0001pt;text-align:left;">  readfd = temp;</p> 
<p style="margin-left:.0001pt;text-align:left;">  select(nfds,&amp;readfd,NULL,NULL,NULL);</p> 
<p style="margin-left:.0001pt;text-align:left;">  for(i = 0; i &lt; nfds; i++)</p> 
<p style="margin-left:.0001pt;text-align:left;">  {<!-- --></p> 
<p style="margin-left:.0001pt;text-align:left;">  if( FD_ISSET(i, &amp;readfd))</p> 
<p style="margin-left:.0001pt;text-align:left;">  {<!-- --></p> 
<p style="margin-left:.0001pt;text-align:left;">  read()</p> 
<p style="margin-left:.0001pt;text-align:left;">  }  </p> 
<p style="margin-left:.0001pt;text-align:left;">  }</p> 
<p style="margin-left:.0001pt;text-align:left;">  }</p> 
<p style="margin-left:.0001pt;text-align:left;">}</p> 
<p style="margin-left:.0001pt;text-align:left;">select 缺点：需要轮询，需要两次拷贝， 长度有限</p> 
<p style="margin-left:.0001pt;text-align:left;">poll：解决select长度有限的问题</p> 
<p style="margin-left:.0001pt;text-align:left;">使用数组存储文件描述符，达到长度可变</p> 
<p style="margin-left:.0001pt;text-align:left;"> int poll(struct pollfd *fds, nfds_t nfds,</p> 
<p style="margin-left:.0001pt;text-align:left;">               const struct timespec *tmo_p, const sigset_t *sigmask);</p> 
<p style="margin-left:.0001pt;text-align:left;">返回值 成功个数 失败-1 超时0</p> 
<p style="margin-left:.0001pt;text-align:left;">参数：fds：存储关心文件描述符的数组首地址</p> 
<p style="margin-left:.0001pt;text-align:left;">      nfds：关系文件描述符的个数</p> 
<p style="margin-left:.0001pt;text-align:left;">  time：超时    -1 阻塞 0非阻塞  》0 时间 ms</p> 
<p style="margin-left:.0001pt;text-align:left;"> struct pollfd {<!-- --></p> 
<p style="margin-left:.0001pt;text-align:left;">               int   fd;         /* file descriptor */</p> 
<p style="margin-left:.0001pt;text-align:left;">               short events;     /* requested events */</p> 
<p style="margin-left:.0001pt;text-align:left;">               short revents;    </p> 
<p style="margin-left:.0001pt;text-align:left;">           };</p> 
<h3 style="margin-left:.0001pt;text-align:left;">epoll</h3> 
<hr> 
<p style="margin-left:.0001pt;text-align:left;">1.创建</p> 
<p style="margin-left:.0001pt;text-align:left;">int epoll_create(int size);</p> 
<p style="margin-left:.0001pt;text-align:left;">创建一个epoll句柄</p> 
<p style="margin-left:.0001pt;text-align:left;">返回值：成功返回文件描述符，失败-1</p> 
<p style="margin-left:.0001pt;text-align:left;">参数：可处理的文件的范围</p> 
<p style="margin-left:.0001pt;text-align:left;">2.插入</p> 
<p style="margin-left:.0001pt;text-align:left;">int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);</p> 
<p style="margin-left:.0001pt;text-align:left;">操作epoll</p> 
<p style="margin-left:.0001pt;text-align:left;">  EPOLL_CTL_ADD 添加</p> 
<p style="margin-left:.0001pt;text-align:left;">              Add  fd to the interest list and associate the settings specified in event with</p> 
<p style="margin-left:.0001pt;text-align:left;">              the internal file linked to fd.</p> 
<p style="margin-left:.0001pt;text-align:left;">       EPOLL_CTL_MOD 修改</p> 
<p style="margin-left:.0001pt;text-align:left;">              Change the settings associated with fd in the interest list to the new settings</p> 
<p style="margin-left:.0001pt;text-align:left;">              specified in event.</p> 
<p style="margin-left:.0001pt;text-align:left;">       EPOLL_CTL_DEL 删除</p> 
<p style="margin-left:.0001pt;text-align:left;">              Remove  (deregister) the target file descriptor fd from the interest list.  The</p> 
<p style="margin-left:.0001pt;text-align:left;">              event argument is ignored and can be NULL (but see BUGS below).</p> 
<p style="margin-left:.0001pt;text-align:left;">参数：epfd， epoll的文件描述符</p> 
<p style="margin-left:.0001pt;text-align:left;">  op ， 操作的命令</p> 
<p style="margin-left:.0001pt;text-align:left;">  fd， 操作的文件描述符</p> 
<p style="margin-left:.0001pt;text-align:left;">  epoll_event, 操作的具体内容</p> 
<p style="margin-left:.0001pt;text-align:left;">3.给内核处理</p> 
<p style="margin-left:.0001pt;text-align:left;">int epoll_wait(int epfd, struct epoll_event *events,</p> 
<p style="margin-left:.0001pt;text-align:left;">                      int maxevents, int timeout);</p> 
<p style="margin-left:.0001pt;text-align:left;">等待内核返回准备好的文件描述符</p> 
<p style="margin-left:.0001pt;text-align:left;">返回值：成功返回准备好的个数，失败-1，超时0</p> 
<p style="margin-left:.0001pt;text-align:left;">参数：epoll文件描述符</p> 
<p style="margin-left:.0001pt;text-align:left;">  events 准备好的文件描述符内容</p> 
<p style="margin-left:.0001pt;text-align:left;">  maxevents 数组大小</p> 
<p style="margin-left:.0001pt;text-align:left;">  timeout：-1 阻塞 0非阻塞 &gt;0 ms</p> 
<p style="margin-left:.0001pt;text-align:left;">4.具体操作</p> 
<p style="margin-left:.0001pt;text-align:left;">fds[i].events &amp; EPOLLIN</p> 
<p style="margin-left:.0001pt;text-align:left;">超时检测：</p> 
<p style="margin-left:.0001pt;text-align:left;">1.使用io多路复用设置超时检查</p> 
<p style="margin-left:.0001pt;text-align:left;">2.信号unsigned int alarm(unsigned int seconds);</p> 
<p style="margin-left:.0001pt;text-align:left;">3.设置套接字属性</p> 
<p style="margin-left:.0001pt;text-align:left;"> int setsockopt(int sockfd, int level, int optname,const void *optval, socklen_t optlen);</p> 
<p style="margin-left:.0001pt;text-align:left;"> 功能：设置套接字属性</p> 
<p style="margin-left:.0001pt;text-align:left;"> 返回值：成功返回0，失败-1</p> 
<p style="margin-left:.0001pt;text-align:left;"> 参数：sockfd：套接字文件描述符</p> 
<p style="margin-left:.0001pt;text-align:left;">   level：设置的协议是哪一层的</p> 
<p style="margin-left:.0001pt;text-align:left;">   optname：具体指令</p> 
<p style="margin-left:.0001pt;text-align:left;">   optval：根据不同指令传递的值</p> 
<p style="margin-left:.0001pt;text-align:left;">   optlen：结构体大小</p> 
<p style="margin-left:.0001pt;text-align:left;">设置属性表：level     </p> 
<p style="margin-left:.0001pt;text-align:left;">SOL_SOCKET</p> 
<p style="margin-left:.0001pt;text-align:left;">---------------------------------------------------</p> 
<p style="margin-left:.0001pt;text-align:left;"> 参数optname 宏的作用    对应参数optval的类型</p> 
<p style="margin-left:.0001pt;text-align:left;"></p> 
<p style="margin-left:.0001pt;text-align:left;">SO_BROADCAST      允许发送广播数据          int</p> 
<p style="margin-left:.0001pt;text-align:left;">SO_DEBUG 循序调试     int</p> 
<p style="margin-left:.0001pt;text-align:left;">SO_DONTROUTE     不查找路由 int</p> 
<p style="margin-left:.0001pt;text-align:left;">SO_ERROR 获的套接字错误 int</p> 
<p style="margin-left:.0001pt;text-align:left;">SO_KEEPALIVE 保持连接 int</p> 
<p style="margin-left:.0001pt;text-align:left;">SO_LINGER 延迟关闭连接 struct linger</p> 
<p style="margin-left:.0001pt;text-align:left;">SO_OOBINLINE 带外数据放入正常数据流  int</p> 
<p style="margin-left:.0001pt;text-align:left;">SO_RCVBUF     接收缓冲区大小 int</p> 
<p style="margin-left:.0001pt;text-align:left;">SO_SNDBUF 发送缓冲区大小 int</p> 
<p style="margin-left:.0001pt;text-align:left;">SO_RCVLOWAT 接收缓冲区下限 int</p> 
<p style="margin-left:.0001pt;text-align:left;">SO_SNDWAIT 发送缓冲区下限 int</p> 
<p style="margin-left:.0001pt;text-align:left;">SO_RCVTIMEO 接收超时 struct timeval</p> 
<p style="margin-left:.0001pt;text-align:left;">SO_SNDTIMEO 发送超时 struct timeval</p> 
<p style="margin-left:.0001pt;text-align:left;">SO_REUSEADDR 允许重用本机地址和端口 int</p> 
<p style="margin-left:.0001pt;text-align:left;">SO_TYPE 获得套接字类型 int</p> 
<p style="margin-left:.0001pt;text-align:left;">SO_BSDCOMPAT 与BSD系统兼容 int</p> 
<p style="margin-left:.0001pt;text-align:left;">===================================================</p> 
<p style="margin-left:.0001pt;text-align:left;">IPPROTO_IP</p> 
<p style="margin-left:.0001pt;text-align:left;">------------------------------------------------------</p> 
<p style="margin-left:.0001pt;text-align:left;">IP_ADD_MEMBERSHIP    加入到组播组中               struct ip_mreq</p> 
<p style="margin-left:.0001pt;text-align:left;">IP_MULTICAST_IF      允许开启组播报文的接口       struct ip_mreq</p> 
<h3 style="margin-left:.0001pt;text-align:left;">套接字分类</h3> 
<hr> 
<p style="margin-left:.0001pt;text-align:left;">{<!-- --></p> 
<p style="margin-left:.0001pt;text-align:left;">1.流式套接字</p> 
<p style="margin-left:.0001pt;text-align:left;">2.报式套接字</p> 
<p style="margin-left:.0001pt;text-align:left;">3.unix域套接字 只能进行本机通信</p> 
<p style="margin-left:.0001pt;text-align:left;">{<!-- --></p> 
<p style="margin-left:.0001pt;text-align:left;"></p> 
<p style="margin-left:.0001pt;text-align:left;">struct sockaddr_un {<!-- --></p> 
<p style="margin-left:.0001pt;text-align:left;">               sa_family_t sun_family;               /* AF_UNIX */</p> 
<p style="margin-left:.0001pt;text-align:left;">               char        sun_path[108];            /* Pathname */</p> 
<p style="margin-left:.0001pt;text-align:left;">           };</p> 
<p style="margin-left:.0001pt;text-align:left;">作用：传递文件描述符，传递凭证</p> 
<p style="margin-left:.0001pt;text-align:left;">}</p> 
<p style="margin-left:.0001pt;text-align:left;">}</p> 
<h3 style="margin-left:.0001pt;text-align:left;">ip地址分类</h3> 
<hr> 
<p style="margin-left:.0001pt;text-align:left;">{<!-- --></p> 
<p style="margin-left:.0001pt;text-align:left;">A：一个字节为网络号，3个字节为主机号</p> 
<p style="margin-left:.0001pt;text-align:left;">   学校，国企</p> 
<p style="margin-left:.0001pt;text-align:left;">   以0开始</p> 
<p style="margin-left:.0001pt;text-align:left;">   范围 0.0.0.0到127.255.255.255   0.0.0.0 本机  127.0.0.1回环  以.255结尾广播地址</p> 
<p style="margin-left:.0001pt;text-align:left;">B：两个字节为网络号，2个字节为主机号</p> 
<p style="margin-left:.0001pt;text-align:left;">私有</p> 
<p style="margin-left:.0001pt;text-align:left;">以10开始</p> 
<p style="margin-left:.0001pt;text-align:left;">范围128.0.0.0 到 191.255.255.255</p> 
<p style="margin-left:.0001pt;text-align:left;">C：三个字节为网络号，1个字节为主机地址</p> 
<p style="margin-left:.0001pt;text-align:left;">私有</p> 
<p style="margin-left:.0001pt;text-align:left;">以110开始</p> 
<p style="margin-left:.0001pt;text-align:left;">范围192.0.0.0 到 223.255.255.255</p> 
<p style="margin-left:.0001pt;text-align:left;">D：组播地址</p> 
<p style="margin-left:.0001pt;text-align:left;">以1110开始</p> 
<p style="margin-left:.0001pt;text-align:left;">范围224.0.0.0 到239.255.255.255</p> 
<p style="margin-left:.0001pt;text-align:left;">E：保留地址</p> 
<p style="margin-left:.0001pt;text-align:left;">以11110开始</p> 
<p style="margin-left:.0001pt;text-align:left;">}</p> 
<h3 style="margin-left:.0001pt;text-align:left;">广播</h3> 
<hr> 
<p style="margin-left:.0001pt;text-align:left;">{<!-- --></p> 
<p style="margin-left:.0001pt;text-align:left;">向广播地址发送消息</p> 
<p style="margin-left:.0001pt;text-align:left;">发送广播{<!-- --></p> 
<p style="margin-left:.0001pt;text-align:left;">1.设置允许发送广播选项 setsockopt（）</p> 
<p style="margin-left:.0001pt;text-align:left;">2.向广播地址发送信息 以255结尾</p> 
<p style="margin-left:.0001pt;text-align:left;">}</p> 
<p style="margin-left:.0001pt;text-align:left;">接收广播{<!-- --></p> 
<p style="margin-left:.0001pt;text-align:left;">1.我绑定的地址需要是一个广播地址或者是0地址</p> 
<p style="margin-left:.0001pt;text-align:left;">}</p> 
<p style="margin-left:.0001pt;text-align:left;">}</p> 
<h3 style="margin-left:.0001pt;text-align:left;">组播</h3> 
<hr> 
<p style="margin-left:.0001pt;text-align:left;">{<!-- --></p> 
<p style="margin-left:.0001pt;text-align:left;">加入组播地址才能收到发给组播地址的信息</p> 
<p style="margin-left:.0001pt;text-align:left;">struct ip_mreq</p> 
<p style="margin-left:.0001pt;text-align:left;">{<!-- --></p> 
<p style="margin-left:.0001pt;text-align:left;">struct in_addr imr_multiaddr; //组播地址</p> 
<p style="margin-left:.0001pt;text-align:left;">struct in_addr imr_interface; //加入到组播组中的地址</p> 
<p style="margin-left:.0001pt;text-align:left;">};</p> 
<p style="margin-left:.0001pt;text-align:left;">发送组播{<!-- --></p> 
<p style="margin-left:.0001pt;text-align:left;">1.创建套接字</p> 
<p style="margin-left:.0001pt;text-align:left;">2.允许发送组播地址</p> 
<p style="margin-left:.0001pt;text-align:left;">}</p> 
<p style="margin-left:.0001pt;text-align:left;">接收方{<!-- --></p> 
<p style="margin-left:.0001pt;text-align:left;">1.创建套接字</p> 
<p style="margin-left:.0001pt;text-align:left;">2.绑定</p> 
<p style="margin-left:.0001pt;text-align:left;">3.加入到组播组中</p> 
<p style="margin-left:.0001pt;text-align:left;">}</p> 
<p style="margin-left:.0001pt;text-align:left;">}</p> 
<p style="margin-left:.0001pt;text-align:left;">}</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/89d45658e8b0b12aea4f2214234ed5d3/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">数据压缩实验四--DPCM</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/47fde7d619d7c1c4de141baf45d30361/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">JavaScript递归详解</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>