<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C面试题--汇总 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C面试题--汇总" />
<meta property="og:description" content="目录 一、C语言基础面试题1. gcc编译器编译的完整流程，分别有什么作用？2.什么是回调函数？3.地址能否使用 printf函数中的 %u形式打印？4.结构体与共用体（联合体）的区别5. static、const、volatile关键字有什么作用？static：静止、静态const：只读volatile ：防止编译器优化 6.声明变量和定义变量的区别7.赋值与赋初值有什么不同？8.局部变量和全局变量能否重名9.如何引用一个已经定义过的外部变量10.全局变量和局部变量的存储方式有什么区别？10-附加：内存的分段11. const 与 # define 相比有何优点？12.数组与指针的区别是什么？13.为什么作为函数形参的数组和指针可以互换？14.形参和实参有什么区别？15.指针、数组和地址之间的关系是的什么？16. void指针就是空指针吗？他有什么作用？17.与内存息息相关的重要概念有哪些？18. #include&lt;&gt; 和 #include”” 有什么区别？18.0 gcc附加19. x=x&#43;1 , x&#43;=1 , x&#43;&#43; 哪个效率高？20.为无符号类型变量赋值时，数据类型应怎样转换？ 二、Linux基础1. 字符设备、块设备、管道等在Linux下有个统称叫什么？2.查看一个文件的类型常用的有几种方式引申 3.Linux下常用的安装工具？4.分别解释shell命令、shell、shell脚本5.printf与scanf操作的是否是同一个文件6. Linux常用的文件系统类型？如何查看文件系统类型？7. windows下有没有文件系统？文件系统有何作用？8.头文件和库文件一般在哪个路径下？9.系统如何区别同名的文件10.系统如何区别不同的进程。11.查看文件有哪些命令12.如修改文件的权限13.什么是符号链接？ 三、数据结构1.数据结构主要研究的是什么？2.数组和链表的区别3.快速排序的算法4. hash查找的算法5.判断单链表是否有环6.判断一个括号字符串是否匹配正确，如果括号有多种，怎么做？如（（[]））正确，[[(()错误 四. IO进程1.标准IO和文件IO区别？文件IO-系统调用标准IO-库函数 2.简述流指针？--文件指针、文件流指针3.简述系统调用？3.1 简述库函数4.简述静态库和动态库的区别？5.如何将程序执行直接运行于后台？前台后台切换 6.进程的状态7.什么是僵尸进程？7-8.孤儿进程8.简述创建子进程中的写时拷贝技术？9.多线程较多进程的优势？10.线程池的使用？----再看看11.线程池的组成部分？12.线程的同步互斥机制？13.简述互斥锁的实现原理？14.简述死锁的情景？15.简述信号量的原理？16.简述进程的通信机制？17.管道的通信原理？18.用户进程对信号的响应方式？19.共享内存通信原理？ 五. 网络编程1. ISO七层网络通信结构和TCP/IP四层网络通信结构ISO七层网络模型TCP/IP四层网络模型 2. tcp通信的优缺点2.3 TCP为什么要进行三次握手3. udp通信的优缺点4. pool与select的区别（select poll epoll的区别）select、poll、epoll机制的特点5. io模型有哪几种6. 如何实现tcp并发服务器7. 网络超时检测的本质和实现方式8. TCP 网络编程流程9. UDP网络编程流程10. UDP本地通信需要注意哪些方面11. 怎么修改文件描述符的标志位--文件状态标志位12. sqlite数据库的基本使用，包括增删改查13. 基于UDP的聊天室如何实现数据群发14. 在线词典如何实现查询单词15. TCP和UDP的区别TCP与UDP区别总结： 16. OSI七层网络模式，每层的主要作用，主要的协议17. TCP 粘包18. TCP的三次握手和四次挥手分别作用，主要做什么19. 如何实现并发服务器，并发服务器的实现方式有什么异同20.线程和进程的区别，多线程和多进程编程的特点 六.C&#43;&#43;1. new、delete、malloc、free关系2. delete与 delete []区别3." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/b009460f5d446623ee47f9595f663588/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-10-06T22:04:54+08:00" />
<meta property="article:modified_time" content="2021-10-06T22:04:54+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C面试题--汇总</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>目录</h4> 
 <ul><li><a href="#C_1" rel="nofollow">一、C语言基础面试题</a></li><li><ul><li><a href="#1_gcc_5" rel="nofollow">1. gcc编译器编译的完整流程，分别有什么作用？</a></li><li><a href="#2_31" rel="nofollow">2.什么是回调函数？</a></li><li><a href="#3_printf_u_41" rel="nofollow">3.地址能否使用 printf函数中的 %u形式打印？</a></li><li><a href="#4_48" rel="nofollow">4.结构体与共用体（联合体）的区别</a></li><li><a href="#5_staticconstvolatile_57" rel="nofollow">5. static、const、volatile关键字有什么作用？</a></li><li><ul><li><a href="#static_59" rel="nofollow">static：静止、静态</a></li><li><a href="#const_71" rel="nofollow">const：只读</a></li><li><a href="#volatile__88" rel="nofollow">volatile ：防止编译器优化</a></li></ul> 
   </li><li><a href="#6_95" rel="nofollow">6.声明变量和定义变量的区别</a></li><li><a href="#7_103" rel="nofollow">7.赋值与赋初值有什么不同？</a></li><li><a href="#8_114" rel="nofollow">8.局部变量和全局变量能否重名</a></li><li><a href="#9_122" rel="nofollow">9.如何引用一个已经定义过的外部变量</a></li><li><a href="#10_130" rel="nofollow">10.全局变量和局部变量的存储方式有什么区别？</a></li><li><a href="#10_139" rel="nofollow">10-附加：内存的分段</a></li><li><a href="#11_const___define__157" rel="nofollow">11. const 与 # define 相比有何优点？</a></li><li><a href="#12_173" rel="nofollow">12.数组与指针的区别是什么？</a></li><li><a href="#13_182" rel="nofollow">13.为什么作为函数形参的数组和指针可以互换？</a></li><li><a href="#14_188" rel="nofollow">14.形参和实参有什么区别？</a></li><li><a href="#15_197" rel="nofollow">15.指针、数组和地址之间的关系是的什么？</a></li><li><a href="#16_void_208" rel="nofollow">16. void指针就是空指针吗？他有什么作用？</a></li><li><a href="#17_220" rel="nofollow">17.与内存息息相关的重要概念有哪些？</a></li><li><a href="#18_include__include__237" rel="nofollow">18. #include&lt;&gt; 和 #include”” 有什么区别？</a></li><li><a href="#180_gcc_244" rel="nofollow">18.0 gcc附加</a></li><li><a href="#19_xx1__x1__x__253" rel="nofollow">19. x=x+1 , x+=1 , x++ 哪个效率高？</a></li><li><a href="#20_265" rel="nofollow">20.为无符号类型变量赋值时，数据类型应怎样转换？</a></li></ul> 
  </li><li><a href="#Linux_281" rel="nofollow">二、Linux基础</a></li><li><ul><li><a href="#1_Linux_283" rel="nofollow">1. 字符设备、块设备、管道等在Linux下有个统称叫什么？</a></li><li><a href="#2_289" rel="nofollow">2.查看一个文件的类型常用的有几种方式</a></li><li><ul><li><a href="#_297" rel="nofollow">引申</a></li></ul> 
   </li><li><a href="#3Linux_318" rel="nofollow">3.Linux下常用的安装工具？</a></li><li><a href="#4shellshellshell_330" rel="nofollow">4.分别解释shell命令、shell、shell脚本</a></li><li><a href="#5printfscanf_338" rel="nofollow">5.printf与scanf操作的是否是同一个文件</a></li><li><a href="#6_Linux_348" rel="nofollow">6. Linux常用的文件系统类型？如何查看文件系统类型？</a></li><li><a href="#7_windows_359" rel="nofollow">7. windows下有没有文件系统？文件系统有何作用？</a></li><li><a href="#8_371" rel="nofollow">8.头文件和库文件一般在哪个路径下？</a></li><li><a href="#9_398" rel="nofollow">9.系统如何区别同名的文件</a></li><li><a href="#10_404" rel="nofollow">10.系统如何区别不同的进程。</a></li><li><a href="#11_410" rel="nofollow">11.查看文件有哪些命令</a></li><li><a href="#12_426" rel="nofollow">12.如修改文件的权限</a></li><li><a href="#13_436" rel="nofollow">13.什么是符号链接？</a></li></ul> 
  </li><li><a href="#_450" rel="nofollow">三、数据结构</a></li><li><ul><li><a href="#1_452" rel="nofollow">1.数据结构主要研究的是什么？</a></li><li><a href="#2_461" rel="nofollow">2.数组和链表的区别</a></li><li><a href="#3_498" rel="nofollow">3.快速排序的算法</a></li><li><a href="#4_hash_507" rel="nofollow">4. hash查找的算法</a></li><li><a href="#5_522" rel="nofollow">5.判断单链表是否有环</a></li><li><a href="#6_528" rel="nofollow">6.判断一个括号字符串是否匹配正确，如果括号有多种，怎么做？如（（[]））正确，[[(()错误</a></li></ul> 
  </li><li><a href="#_IO_541" rel="nofollow">四. IO进程</a></li><li><ul><li><a href="#1IOIO_543" rel="nofollow">1.标准IO和文件IO区别？</a></li><li><ul><li><a href="#IO_545" rel="nofollow">文件IO-系统调用</a></li><li><a href="#IO_560" rel="nofollow">标准IO-库函数</a></li></ul> 
   </li><li><a href="#2_574" rel="nofollow">2.简述流指针？--文件指针、文件流指针</a></li><li><a href="#3_582" rel="nofollow">3.简述系统调用？</a></li><li><a href="#31__594" rel="nofollow">3.1 简述库函数</a></li><li><a href="#4_607" rel="nofollow">4.简述静态库和动态库的区别？</a></li><li><a href="#5_618" rel="nofollow">5.如何将程序执行直接运行于后台？</a></li><li><ul><li><a href="#_624" rel="nofollow">前台后台切换</a></li></ul> 
   </li><li><a href="#6_642" rel="nofollow">6.进程的状态</a></li><li><a href="#7_653" rel="nofollow">7.什么是僵尸进程？</a></li><li><a href="#78_665" rel="nofollow">7-8.孤儿进程</a></li><li><a href="#8_671" rel="nofollow">8.简述创建子进程中的写时拷贝技术？</a></li><li><a href="#9_680" rel="nofollow">9.多线程较多进程的优势？</a></li><li><a href="#10_687" rel="nofollow">10.线程池的使用？----再看看</a></li><li><a href="#11_697" rel="nofollow">11.线程池的组成部分？</a></li><li><a href="#12_710" rel="nofollow">12.线程的同步互斥机制？</a></li><li><a href="#13_717" rel="nofollow">13.简述互斥锁的实现原理？</a></li><li><a href="#14_735" rel="nofollow">14.简述死锁的情景？</a></li><li><a href="#15_746" rel="nofollow">15.简述信号量的原理？</a></li><li><a href="#16_756" rel="nofollow">16.简述进程的通信机制？</a></li><li><a href="#17_771" rel="nofollow">17.管道的通信原理？</a></li><li><a href="#18_798" rel="nofollow">18.用户进程对信号的响应方式？</a></li><li><a href="#19_808" rel="nofollow">19.共享内存通信原理？</a></li></ul> 
  </li><li><a href="#__827" rel="nofollow">五. 网络编程</a></li><li><ul><li><a href="#1_ISOTCPIP_829" rel="nofollow">1. ISO七层网络通信结构和TCP/IP四层网络通信结构</a></li><li><ul><li><a href="#ISO_831" rel="nofollow">ISO七层网络模型</a></li><li><a href="#TCPIP_843" rel="nofollow">TCP/IP四层网络模型</a></li></ul> 
   </li><li><a href="#2_tcp_856" rel="nofollow">2. tcp通信的优缺点</a></li><li><a href="#23_TCP_873" rel="nofollow">2.3 TCP为什么要进行三次握手</a></li><li><a href="#3_udp_891" rel="nofollow">3. udp通信的优缺点</a></li><li><a href="#4_poolselectselect_poll_epoll_905" rel="nofollow">4. pool与select的区别（select poll epoll的区别）</a></li><li><a href="#selectpollepoll_924" rel="nofollow">select、poll、epoll机制的特点</a></li><li><a href="#5_io_935" rel="nofollow">5. io模型有哪几种</a></li><li><a href="#6_tcp_944" rel="nofollow">6. 如何实现tcp并发服务器</a></li><li><a href="#7__953" rel="nofollow">7. 网络超时检测的本质和实现方式</a></li><li><a href="#8_TCP__980" rel="nofollow">8. TCP 网络编程流程</a></li><li><a href="#9_UDP_1003" rel="nofollow">9. UDP网络编程流程</a></li><li><a href="#10_UDP_1020" rel="nofollow">10. UDP本地通信需要注意哪些方面</a></li><li><a href="#11__1028" rel="nofollow">11. 怎么修改文件描述符的标志位--文件状态标志位</a></li><li><a href="#12_sqlite_1035" rel="nofollow">12. sqlite数据库的基本使用，包括增删改查</a></li><li><a href="#13_UDP_1063" rel="nofollow">13. 基于UDP的聊天室如何实现数据群发</a></li><li><a href="#14__1069" rel="nofollow">14. 在线词典如何实现查询单词</a></li><li><a href="#15_TCPUDP_1080" rel="nofollow">15. TCP和UDP的区别</a></li><li><ul><li><a href="#TCPUDP_1105" rel="nofollow">TCP与UDP区别总结：</a></li></ul> 
   </li><li><a href="#16_OSI_1128" rel="nofollow">16. OSI七层网络模式，每层的主要作用，主要的协议</a></li><li><a href="#17_TCP__1140" rel="nofollow">17. TCP 粘包</a></li><li><a href="#18_TCP_1154" rel="nofollow">18. TCP的三次握手和四次挥手分别作用，主要做什么</a></li><li><a href="#19__1177" rel="nofollow">19. 如何实现并发服务器，并发服务器的实现方式有什么异同</a></li><li><a href="#20_1183" rel="nofollow">20.线程和进程的区别，多线程和多进程编程的特点</a></li></ul> 
  </li><li><a href="#C_1224" rel="nofollow">六.C++</a></li><li><ul><li><a href="#1_newdeletemallocfree_1226" rel="nofollow">1. new、delete、malloc、free关系</a></li><li><a href="#2_delete_delete__1240" rel="nofollow">2. delete与 delete []区别</a></li><li><a href="#3_C_1256" rel="nofollow">3. C++有哪些性质（面向对象特点）</a></li><li><a href="#4__1262" rel="nofollow">4. 子类析构时要调用父类的析构函数吗？</a></li><li><a href="#5__1271" rel="nofollow">5. 多态，虚函数，纯虚函数</a></li><li><a href="#6__1305" rel="nofollow">6. 求下面函数的返回值（微软）----特么的题呢--</a></li><li><a href="#7__1360" rel="nofollow">7. 什么是“引用”？声明和使用“引用”要注意哪些问题？</a></li><li><a href="#78__1370" rel="nofollow">7-8. 引用与指针的区别</a></li><li><a href="#8____1379" rel="nofollow">8. 将“引用”作为 函数参数 有哪些特点？</a></li><li><a href="#9__1395" rel="nofollow">9. 在什么时候需要使用“常引用”？</a></li><li><a href="#10___1409" rel="nofollow">10. 将“引用”作为函数返回值类型的格式、好处和需要遵守的规则?</a></li><li><a href="#11__C_1475" rel="nofollow">11. 结构与联合有和区别？---C基础第四题</a></li><li><a href="#12___1477" rel="nofollow">12. 试写出程序结果：</a></li><li><a href="#13_overloadoverried_1498" rel="nofollow">13. 重载（overload)和重写(overried，有的书也叫做“覆盖”）的区别？</a></li><li><a href="#14_intialization_list_assignment_1516" rel="nofollow">14. 有哪几种情况只能用intialization list(初始化列表) 而不能用assignment?</a></li><li><a href="#15_C_1528" rel="nofollow">15. C++是不是类型安全的？</a></li><li><a href="#16_main__1535" rel="nofollow">16. main 函数执行以前，还会执行什么代码？</a></li><li><a href="#17__1541" rel="nofollow">17. 描述内存分配方式以及它们的区别?</a></li><li><a href="#18_BOOLintfloata__1553" rel="nofollow">18. 分别写出BOOL,int,float,指针类型的变量a 与“零”的比较语句。</a></li><li><a href="#19_constdefine_C11_1565" rel="nofollow">19. 请说出const与#define 相比，有何优点？--C基础-11题</a></li><li><a href="#20_C12_1567" rel="nofollow">20. 简述数组与指针的区别？--C基础-12题</a></li><li><a href="#21_int_s10int__1569" rel="nofollow">21. int (*s[10])(int) 表示的是什么？</a></li><li><a href="#22__1576" rel="nofollow">22. 栈内存与文字常量区</a></li><li><a href="#23__1596" rel="nofollow">23. 将程序跳转到指定内存地址</a></li><li><a href="#24_int_idsizeofunsigned_long_1611" rel="nofollow">24. int id[sizeof(unsigned long)];这个对吗？为什么？</a></li><li><a href="#27__17_1617" rel="nofollow">27. 内存的分配方式有几种?---上面 17</a></li><li><a href="#28__1619" rel="nofollow">28. 基类的析构函数不是虚函数，会带来什么问题？</a></li><li><a href="#29__1633" rel="nofollow">29. 全局变量和局部变量有什么区别？是怎么实现的？操作系统和编译器是怎么知道的？</a></li></ul> 
  </li><li><a href="#_ARM_1652" rel="nofollow">七. ARM体系结构编程</a></li><li><ul><li><a href="#1_ARM5_1654" rel="nofollow">1. 简单描述一下ARM处理器的特点，至少说出5个以上的特点。</a></li><li><a href="#2_ARMcortex_a_1666" rel="nofollow">2. ARM内核有多少种工作模式？请写出这些工作模式的英文缩写，有几种异常模式，有几种特权模式，cortex_a系列有几种特权模式，几种工作模式</a></li><li><a href="#3_ARM_1683" rel="nofollow">3. ARM内核有多少个寄存器，简述一下</a></li><li><a href="#4_ARM3_1696" rel="nofollow">4. ARM通用寄存器中，有3个寄存器有特殊功能和作用，请写出它们的名字和作用。</a></li><li><a href="#5_CPSRBit_1704" rel="nofollow">5. 请描述一下CPSR寄存器中相关Bit的情况和作用。</a></li><li><a href="#6__1759" rel="nofollow">6. 什么是立即数？立即数的本质是什么</a></li><li><a href="#7_BLLR_1766" rel="nofollow">7. 请问BL指令跳转时LR寄存器保存的是什么内容？并请简述原因</a></li><li><a href="#8__1772" rel="nofollow">8. 请描述一下什么是处理器现场，如何进行保存现场？</a></li><li><a href="#9_ATPCSARM_1782" rel="nofollow">9. ATPCS默认使用的是什么栈？--满减栈（ARM也是）</a></li><li><a href="#10__1784" rel="nofollow">10. 什么是满栈、空栈，什么是增栈、减栈？</a></li><li><a href="#11_ARM_1803" rel="nofollow">11. 请写出一条完整的ARM软件中断指令，并简要描述其作用。</a></li><li><a href="#12_ARM_1813" rel="nofollow">12. 请描述一下ARM体系中异常向量表的概念。</a></li><li><a href="#13_ARMbin_1823" rel="nofollow">13. 请写出一个ARM程序生成的bin文件映像中包含哪些内容？</a></li><li><a href="#14_ARM_1831" rel="nofollow">14. 请举例说明在ARM处理器上进行一次中断处理和中断异常处理的差异。</a></li><li><a href="#15__1840" rel="nofollow">15. 请简述异常中断处理发生时，是通过什么完成初始化步骤，这些初始化的具体步骤是什么？</a></li><li><a href="#16_uboot_1855" rel="nofollow">16. uboot的主要作用</a></li><li><a href="#17_uboot_1880" rel="nofollow">17. uboot是怎样引导启动内核的？</a></li><li><a href="#18_uboot_1893" rel="nofollow">18. uboot的启动过程的重要干了什么</a></li><li><a href="#19_bootcmdbootargsuboot_1940" rel="nofollow">19. bootcmd和bootargs两个uboot环境变量的作用</a></li><li><a href="#20_linux_1955" rel="nofollow">20. linux内核的启动过程</a></li><li><a href="#21_uImagezImagevmlinux_1973" rel="nofollow">21. uImage，zImage，vmlinux的区别</a></li><li><a href="#22_KconfigconfigMakefile_2001" rel="nofollow">22. Kconfig,.config,Makefile三个文件之间的关系</a></li></ul> 
  </li><li><a href="#__2013" rel="nofollow">八. 系统移植</a></li><li><ul><li><a href="#1_Linux_20_2015" rel="nofollow">1. Linux内核启动流程---同上 七.20</a></li><li><a href="#2_bootloaderbootloader_2084" rel="nofollow">2. 什么是bootloader？在嵌入式系统当中bootloader的作用是什么？</a></li><li><a href="#3_C_2092" rel="nofollow">3. 为什么汇编语言对硬件平台有依赖性而C语言却可以不依赖硬件平台？</a></li><li><a href="#4__2103" rel="nofollow">4. 什么叫做交叉编译？</a></li><li><a href="#5_Linux_2110" rel="nofollow">5. Linux平台下的可执行文件是什么格式？</a></li><li><a href="#6__2116" rel="nofollow">6. 什么叫做反汇编？</a></li><li><a href="#7_nfs_2124" rel="nofollow">7. 简述nfs服务的概念与作用？</a></li><li><a href="#8_linux_2132" rel="nofollow">8. 简述一个装有linux内核的开发板的启动过程？</a></li><li><a href="#9_uboot_2143" rel="nofollow">9. 简述uboot的主要功能有哪些？</a></li><li><a href="#10_uboot_2153" rel="nofollow">10. uboot如何设置环境变量？</a></li><li><a href="#11_ubootbootcmd19_2160" rel="nofollow">11. 简述uboot中bootcmd环境变量的作用？--七.19</a></li><li><a href="#12_ubootbootargs19_2167" rel="nofollow">12. 简述uboot中bootargs环境变量的作用？--七.19</a></li><li><a href="#13__2173" rel="nofollow">13. 简述什么叫平台相关代码什么叫平台无关代码？</a></li><li><a href="#14linuxuboot_2194" rel="nofollow">14.如何理解linux/uboot支持各种硬件平台？</a></li><li><a href="#15_uboot_2204" rel="nofollow">15. 如何配置uboot使其适合特定的开发板平台？</a></li><li><a href="#16_uboot_2211" rel="nofollow">16. 如何编译uboot生成二进制文件？</a></li><li><a href="#17_uboot_2217" rel="nofollow">17. 简述uboot的启动过程？</a></li><li><a href="#18__2237" rel="nofollow">18. 操作系统的作用有哪些？</a></li><li><a href="#19_linux_2248" rel="nofollow">19. 如何配置linux源码使其适合特定的处理器？</a></li><li><a href="#20_make_menuconfigYNM_2255" rel="nofollow">20. 在make menuconfig界面下有些驱动可以被选成三种状态即“Y”，“N”，“M”这三种状态分别是什么含义？</a></li><li><a href="#21_M_2263" rel="nofollow">21. 如何编译被选中为“M”选项的驱动模块？</a></li><li><a href="#22__2272" rel="nofollow">22. 简述设备树的作用？</a></li><li><a href="#23__2280" rel="nofollow">23. 编写设备树文件的主要依据是什么？</a></li><li><a href="#24__2287" rel="nofollow">24. 简述如何将一个内核源码中已有的驱动程序编译到内核中？</a></li><li><a href="#25__2296" rel="nofollow">25. 简述如何将一个自己编写的驱动程序编译到内核中？</a></li><li><a href="#26_2305" rel="nofollow">26.在内核启动过程中如果控制台已经初始化我们一般采用什么方式来调试内核？</a></li><li><a href="#27_linuxOops_2311" rel="nofollow">27. linux内核在启动过程中遇到什么情况会打印系统崩溃报告Oops？</a></li><li><a href="#28_linuxOops_2318" rel="nofollow">28. linux内核在启动过程中遇到某些问题会打印系统崩溃报告Oops，报告中主要打印哪些内容？</a></li><li><a href="#29__2324" rel="nofollow">29. 简述什么叫文件系统？什么叫根文件系统？</a></li><li><a href="#30__2333" rel="nofollow">30. 开发板中为什么一般不需要安装静态库？</a></li></ul> 
  </li><li><a href="#__2345" rel="nofollow">九. 驱动开发</a></li><li><ul><li><a href="#1__2347" rel="nofollow">1. 什么是模块？</a></li><li><a href="#2__2358" rel="nofollow">2. 驱动类型有几种</a></li><li><a href="#3__2364" rel="nofollow">3. 字符设备驱动框架编程流程？</a></li><li><a href="#4__2378" rel="nofollow">4. 什么是并发，驱动中产生竞态的原因有哪些？</a></li><li><a href="#5__2390" rel="nofollow">5. 解决竞态的途径有哪些？分别有什么特点？</a></li><li><a href="#6_IO_2402" rel="nofollow">6. 驱动中IO模型有几种？</a></li><li><a href="#7_linux_2411" rel="nofollow">7. 设计linux设备模型的主要作用？</a></li><li><a href="#8_linux_2417" rel="nofollow">8. 字符设备驱动框架与linux设备模型是否矛盾？</a></li><li><a href="#9_platform_2425" rel="nofollow">9. platform架构分别分为哪个部分？他们通过什么进行匹配</a></li><li><a href="#10_platform_2437" rel="nofollow">10. 设备树与platform架构是否有矛盾？</a></li><li><a href="#11__2444" rel="nofollow">11. 为什么要将中断分为上下半部？上下半部机制有哪些？</a></li><li><a href="#12_tasklet_2452" rel="nofollow">12. 工作队列与tasklet的区别？</a></li><li><a href="#13__2475" rel="nofollow">13. 内核中内存分配函数分别有哪些？分别有什么特点？</a></li><li><a href="#14__2492" rel="nofollow">14. 内核调试</a></li><li><ul><li><a href="#aprintkprintk_2494" rel="nofollow">a.可以使用printk打印内核信息，printk的调试级别如下</a></li><li><a href="#b_gdb__addr2line__2518" rel="nofollow">b. gdb 和 addr2line 调试内核模块</a></li><li><a href="#c_BUG_ONBUGdump_stack_2532" rel="nofollow">c. 使用函数BUG_ON()，BUG()和dump_stack()调试内核</a></li></ul> 
   </li><li><a href="#15__2542" rel="nofollow">15. 字符设备驱动的框架</a></li><li><a href="#16__2560" rel="nofollow">16. 字符设备和块设备和网络设备的区别</a></li><li><a href="#17_4_2577" rel="nofollow">17. 并发和竞态概念，那些情况会出现竟态，解决竟态的方法，以及区别，使用场景。---上面第4题</a></li><li><a href="#18__2610" rel="nofollow">18. 自旋锁和信号量的区别</a></li><li><a href="#19__2640" rel="nofollow">19. 谈谈你对中断上下文，进程上下文的理解</a></li><li><a href="#20__2662" rel="nofollow">20. 中断低半部主要做了什么</a></li><li><a href="#21_Platfprm_2686" rel="nofollow">21. Platfprm平台总线驱动模型</a></li><li><a href="#22_IIC_2716" rel="nofollow">22. IIC子系统驱动框架</a></li><li><a href="#23__2721" rel="nofollow">23. 输入子系统驱动框架</a></li><li><ul><li><a href="#_2723" rel="nofollow">子系统的组成</a></li><li><a href="#_2728" rel="nofollow">输入子系统的事件处理机制示意图</a></li><li><a href="#_2732" rel="nofollow">输入子系统剖析</a></li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="C_1"></a>一、C语言基础面试题</h2> 
<h3><a id="1_gcc_5"></a>1. gcc编译器编译的完整流程，分别有什么作用？</h3> 
<pre><code class="prism language-shell">gcc编译器编译的完整流程有四步，分别是 预处理、 编译、 汇编、 链接

预处理：处理源文件中的<span class="token comment">#ifndef、#include、#define等预处理命令，该阶段会生成一个中间文件.i</span>
	   主要进行<span class="token string">'宏定义替换'</span>，<span class="token string">'头文件展开'</span>，<span class="token string">'注释删除'</span>等，<span class="token string">'不会检查'</span>语法错误
gcc -E hello.c –o  <span class="token comment">#可以使用-E选项生成.i文件</span>
		<span class="token comment">##【注意】不 -o，只会在终端打印一下展开的代码，源文件不会发生改变</span>

编译：gcc把预处理后的<span class="token string">'结果'</span>编译成<span class="token string">'汇编语言'</span>代码，输入的是.i，编译后生成汇编语言文件.s
	 会检查语法是否有错	, 整体编译流程：（编译步骤） 语法检查--<span class="token operator">&gt;</span>词法分析--<span class="token operator">&gt;</span>语义分析--<span class="token operator">&gt;</span>统计符号--<span class="token operator">&gt;</span>汇编（再进行）
gcc -S hello.i –o hello.s		<span class="token comment">#有没有 -o 都会生成对应的 .s 文件</span>

汇编：编译器把编译出来的<span class="token string">'汇编语言'</span>汇编成具体CPU上的目标代码（<span class="token string">'机器代码'</span>）。输入汇编代码文件.s，输出目标代码文件.o或.obj	, 流程：（汇编步骤）-<span class="token operator">&gt;</span>统计符号--<span class="token operator">&gt;</span>制作符号表
	 <span class="token comment">#将汇编文件生成机器码(编译成二进制文件）  </span>
gcc –c hello.s –o hello.o
	<span class="token comment">#-c 表示不链接库,有没有 -o 都会生成对应的.o 文件</span>

链接：把<span class="token string">'多个目标代码模块'</span>链接成一个<span class="token string">'大的目标代码'</span>模块。输入目标代码文件.0（与其它的目标代码文件、库文件、引导代码），汇集成一个可执行的二进制代码文件
	 <span class="token comment">#链接库函数，生成一个可执行文件</span>
gcc hello.o –o hello	<span class="token comment">#不 -o 会生成 a.out 可执行文件</span>

<span class="token comment"># E S c 	---&gt; 	i s o</span>
</code></pre> 
<h3><a id="2_31"></a>2.什么是回调函数？</h3> 
<pre><code class="prism language-shell">回调函数就是一个通过<span class="token string">'函数指针调用'</span>的函数。所以当<span class="token string">'一个函数作为参数'</span>使用的时候,这个函数就是回调函数。
<span class="token comment">#将函数指针 最为函数的参数 的函数</span>
int <span class="token punctuation">(</span>*p<span class="token punctuation">)</span><span class="token punctuation">(</span>int,int<span class="token punctuation">)</span>		------ <span class="token operator">&gt;</span>    <span class="token comment">#  int my_sub(int a,int b)</span>

一个<span class="token string">'函数的参数'</span>是一个<span class="token string">'函数指针'</span>，在这个函数中<span class="token string">'具体调用哪个'</span>函数,<span class="token string">'取决于'</span>这个函数调用时，用<span class="token string">'哪个函数给形参'</span>的函数指针赋值
</code></pre> 
<h3><a id="3_printf_u_41"></a>3.地址能否使用 printf函数中的 %u形式打印？</h3> 
<pre><code>%u 是打印无符号的十进制的数字，地址是本身是无符号的16进制的，所以可以打印但是不推荐
还是%p是最标准的
</code></pre> 
<h3><a id="4_48"></a>4.结构体与共用体（联合体）的区别</h3> 
<pre><code class="prism language-shell">首先结构体与共用体都是<span class="token string">'构造类型'</span>，它们的<span class="token string">'成员变量'</span>都可以定义为<span class="token string">'不同类型'</span>的。
结构体可以同时存储多种变量类型，而共同体同一个时间只能存储和使用多个变量类型的一种，当另一时间，变量类型被改变后，原来的变量类型和值将被舍弃。
共用体的作用是同一个数据项可以使用多种格式，可以节省空间。<span class="token string">'所有成员共享一块内存空间'</span>,每个成员的<span class="token string">'首地址相同'</span>
<span class="token string">'结构体的大小'</span>是根据每个成员变量的大小的总量确定的，而<span class="token string">'共用体的大小'</span>是根据最大的成员变量的大小确定的
</code></pre> 
<h3><a id="5_staticconstvolatile_57"></a>5. static、const、volatile关键字有什么作用？</h3> 
<h4><a id="static_59"></a>static：静止、静态</h4> 
<pre><code class="prism language-shell"><span class="token number">1</span>.修饰全局变量：变量只在本模块内可见，<span class="token string">'限定作用域'</span>，限制<span class="token string">'变量只能在本文件'</span><span class="token punctuation">(</span>当前.c<span class="token punctuation">)</span>中使用 
	在定义不需要与其他文件共享的全局变量时，加上static关键字能够有效地降低程序模块之间的耦合，避免不同文件同名变量的冲突，且不会误使用。
	
<span class="token number">2</span>.修饰局部变量：变量在全局数据区分配内存空间，<span class="token string">'延长变量的生命周期'</span>，到整个程序结束 
	
<span class="token number">3</span>.修饰函数：函数的使用方式与全局变量类似，在函数的返回类型前加上static，就是静态函数，<span class="token string">'限定作用域'</span>，限制<span class="token string">'该函数只能在本文件'</span><span class="token punctuation">(</span>当前.c<span class="token punctuation">)</span>中使用 
	静态函数只能在声明它的文件中可见，其他文件不能引用该函数，不同的文件可以使用相同名字的静态函数，互不影响。
</code></pre> 
<h4><a id="const_71"></a>const：只读</h4> 
<pre><code class="prism language-shell">C编译器中：被const修饰的变量是<span class="token string">'只读变量'</span>，本质还是变量，
	有人称其为常变量，和普通变量的区别在于常变量不能用于左值，其余的用法和普通常量一样。
C++编译器中：被const修饰的变量，变量名和初始值会直接放到符号表中，当使用变量名的时候会直接从符号表中读取其值。相较于C编译器，在C++编译器中const修饰的变量更像是常量。
</code></pre> 
<pre><code class="prism language-c++">//const 修饰谁 谁不能变----- 修饰 *p 值不能变，但是指向 可以改变
// ----- 修饰 p p的指向不能变 但是 *p的值 可以改变
const int *p; //值不能变，但是指向 可以改变
int const *p; //值不能变，但是指向 可以改变
int * const p; //p的指向不能变 但是 *p的值 可以改变
const int * const p; //p的指向不能变 但是 *p的值 可以改变
</code></pre> 
<h4><a id="volatile__88"></a>volatile ：防止编译器优化</h4> 
<pre><code class="prism language-shell">volatile关键字声明的变量，编译器对访问该变量的代码就<span class="token string">'不再进行优化'</span>，从而可以提供对特殊地址的稳定访问。
用 volatile 声明，该关键字的作用是防止编译器直接在CPU寄存器中获取值，在内存中重新读取
</code></pre> 
<h3><a id="6_95"></a>6.声明变量和定义变量的区别</h3> 
<pre><code class="prism language-shell">声明<span class="token string">'不开辟内存空间'</span>，
定义<span class="token string">'开辟内存空间'</span>并且也有可能同时为其提供<span class="token string">'初始值'</span>。
<span class="token comment">#注意：定义引用，是开辟地址空间了的</span>
</code></pre> 
<h3><a id="7_103"></a>7.赋值与赋初值有什么不同？</h3> 
<pre><code class="prism language-c">赋初值，也就是<span class="token string">'初始化'</span>，只能在定义的时候操作，只能用<span class="token string">'='</span>，形式为
<span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
赋值，是在定义后，改变变量的值，除了<span class="token operator">=</span>还包括复合赋值语句，如<span class="token operator">+=</span>、<span class="token operator">-=</span>等，自加，自减也可以算赋值语句。形式为
a <span class="token operator">=</span> <span class="token number">200</span><span class="token punctuation">;</span>

#<span class="token operator">--</span><span class="token operator">--</span>这种<span class="token operator">*</span><span class="token operator">*</span>问题<span class="token operator">--</span>应该不会有人问吧（自动屏蔽关键字）
</code></pre> 
<h3><a id="8_114"></a>8.局部变量和全局变量能否重名</h3> 
<pre><code class="prism language-shell">可以，局部优先原则
在C++中，可以通过<span class="token string">'命名空间'</span><span class="token punctuation">(</span>匿名空间<span class="token punctuation">)</span>来访问重名的全局变量，变量前面加作用域限定符 :: 
但是在C语言里，好像是不能，访问全局的重名变量了
</code></pre> 
<h3><a id="9_122"></a>9.如何引用一个已经定义过的外部变量</h3> 
<pre><code>1.用 extern关键字方式：声明一个变量在外部定义

2.用'引用头文件'的方式，可以在不同的C文件中声明同名的全局变量，前提是其中只能有一个C文件中对此变量赋初值，此时连接不会出错。
</code></pre> 
<h3><a id="10_130"></a>10.全局变量和局部变量的存储方式有什么区别？</h3> 
<pre><code class="prism language-shell"><span class="token number">1</span>.<span class="token string">'作用域'</span>不同：全局变量的作用域为<span class="token string">'整个程序'</span>，而局部变量的作用域为<span class="token string">'当前函数或循环'</span>
<span class="token number">2</span>.<span class="token string">'内存存储方式'</span>不同：全局变量存储在<span class="token string">'全局数据区'</span>中，局部变量存储在<span class="token string">'栈区'</span>
<span class="token number">3</span>.<span class="token string">'生命期'</span>不同：全局变量的生命期和主程序一样，随<span class="token string">'程序的销毁而结束'</span>，局部变量在函数内部或循环内部，随<span class="token string">'函数的退出'</span>或<span class="token string">'循环退出'</span>就不存在了
<span class="token number">4</span>.<span class="token string">'使用方式'</span>不同：全局变量在声明后程序的<span class="token string">'各个部分都可以'</span>用到，但是局部变量只能在<span class="token string">'局部使用'</span>。<span class="token punctuation">(</span>局部优先<span class="token punctuation">)</span>
</code></pre> 
<h3><a id="10_139"></a>10-附加：内存的分段</h3> 
<pre><code class="prism language-shell">C语言经过编译之后将内存分为以下五个区域

<span class="token number">1</span>.栈：由编译器进行管理，自动分配和释放，存放函数调用过程中的各种参数，局部变量，返回值及函数返回地址。操作方式类似数据结构中的栈。
<span class="token number">2</span>.堆：用于程序动态申请分配和释放空间。C语言中的malloc和free,C++中的new和delete均是在堆中进行的。正常情况下，程序员申请的空间在使用结束后应该释放，若程序员没有释放空间，则整个程序结束时系统自动回收。

<span class="token number">3</span>.全局<span class="token punctuation">(</span>静态<span class="token punctuation">)</span>存储区：分为DATA段和BSS段。
	DATA段<span class="token punctuation">(</span>全局初始化区<span class="token punctuation">)</span>存放初始化的全局变量和静态变量；
	BSS段<span class="token punctuation">(</span>全局未初始化区<span class="token punctuation">)</span>存放未初始化的全局变量和静态变量。程序运行结束时自动释放。其中，
BSS段在程序执行之前会被系统自动清零，所以未初始化全局变量和静态变量在程序执行之前已经为0。
<span class="token number">4</span>.文字常量区：存放常量字符串。程序结束后由系统释放。
<span class="token number">5</span>.程序代码区：存放程序的二进制代码。
</code></pre> 
<h3><a id="11_const___define__157"></a>11. const 与 # define 相比有何优点？</h3> 
<pre><code class="prism language-shell">相同点：两者都可以用来定义常量。
不同点：
a.<span class="token string">'处理的时期'</span>：<span class="token comment">#define是在编译的'预处理阶段'展开，而const是在'编译'、运行的时候起作用</span>
b.<span class="token comment">#define只是'简单的字符串替换'，'没有类型检查'。</span>
	而const有对应的数据类型，是要进行判断的，可以避免一些低级的错误
c.就存储方式而言：define<span class="token string">'宏定义'</span>时<span class="token string">'不会分配内存'</span>，<span class="token comment">#define只是进行展开，有多少地方使用，就替换多少次，它定义的宏常量在内存中有若干个备份；</span>
	const常量在定义时会在内存中分配<span class="token punctuation">(</span>可以是堆中也可以是栈中<span class="token punctuation">)</span>，const定义的<span class="token string">'只读变量'</span>在程序运行过程中只有一份备份。
	
总结:const 与 <span class="token comment">#define 相比有何优点</span>
a.const常量有<span class="token string">'数据类型'</span>，而宏常量<span class="token string">'没有数据类型'</span>，编译器可以对前者进行类型安全检查，而后者只进行字符替换，没有类型安全检查，并且在字符替换可能会产生意料不到的错误。
b.有些集成化的调试工具可以对const常量进行测试，但不能对宏常量进行测试。
</code></pre> 
<h3><a id="12_173"></a>12.数组与指针的区别是什么？</h3> 
<pre><code>数组名是一个地址常量 	---&gt;	不可以被赋值,也不可以自增自减，不能偏移
指针是变量所以可以  ++ -- ,可以偏移

对于数组而言，数组名就是一个指针，指向数组的首地址，数组的首地址 和 数组首元素的地址 和 数组名 是同一个地址
</code></pre> 
<h3><a id="13_182"></a>13.为什么作为函数形参的数组和指针可以互换？</h3> 
<pre><code class="prism language-shell">C语言 形参 中<span class="token string">'数组名'</span>'实质上<span class="token string">'就是'</span>指针变量'。
</code></pre> 
<h3><a id="14_188"></a>14.形参和实参有什么区别？</h3> 
<pre><code class="prism language-shell"> 形式参数：在<span class="token string">'定义函数'</span>时，函数名后面括号中的变量名为<span class="token string">'形式参数'</span>。在函数调用之前，传递给函数的值将被复制到这些形式参数中
实际参数：在<span class="token string">'调用函数'</span>时，也就是真正使用一个函数时，函数名后面括号中的参数为<span class="token string">'实际参数'</span>，函数的调用者提供给函数的参数成为实际参数
</code></pre> 
<h3><a id="15_197"></a>15.指针、数组和地址之间的关系是的什么？</h3> 
<pre><code class="prism language-shell">数组是保存在一片<span class="token string">'连续内存单元'</span>中的，而<span class="token string">'数组名'</span>就是这片<span class="token string">'连续内存单元'</span>的<span class="token string">'首地址'</span>，
内存单元的地址就是指针，因此数组名也是一个指针 
<span class="token comment">#数组是由多个数组元素组成，元素按其数组类型的不同，所占连续内存的大小也不同。</span>
一个<span class="token string">'数组'</span>的元素的首地址就是其所占连续<span class="token string">'内存单元'</span>的<span class="token string">'首地址'</span>, <span class="token string">'指针'</span>变量<span class="token string">'既可以指向'</span>一个数组，<span class="token string">'也可以指向'</span>一个数组元素。
将<span class="token string">'数组名'</span>或<span class="token string">'数组的第一个元素'</span>的<span class="token string">'地址'</span>赋给指针，指针就指向了一个数组。
如果想使指针变量指向第i个元素，就可以把i元素首地址赋给它。
</code></pre> 
<h3><a id="16_void_208"></a>16. void指针就是空指针吗？他有什么作用？</h3> 
<pre><code class="prism language-shell">void指针是一个万能指针，不是空指针
它可以表示任意一个类型的指针（malloc的返回值就是一个 void指针）

空指针一般应用于以下三种情况：
<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> 用空指针终止对递归数组结构的间接引用
<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> 用空指针作为函数调用失败时的返回值
<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span> 用空指针作为警戒值
</code></pre> 
<h3><a id="17_220"></a>17.与内存息息相关的重要概念有哪些？</h3> 
<pre><code class="prism language-shell">（野指针、栈（stack）、堆（heap）、静态区）
野指针：定义了一个指针变量没有进行初始化，该指针指向了一个不确定的空间，这个指针称为野指针 
	造成野指针的几种情况
		a. 定义的指针变量没有被初始化
		b. 指针的操作超过可变量的作用范围（越界）
		c. 指针被释放或者删除后，没有被置为NULL，然后再次被使用
栈（stack）：栈是用来保存局部变量（系统自动申请释放），栈上的内容只在函数的范围内存在，函数运行结束这些内容也会被销毁，栈的特点就是效率高，但空间大小有限

堆（heap）：堆是由malloc（）、calloc（）、等函数或者new操作符获得的内存，由free（）函数和delete（）函数释放内存、堆的特点就是效率高，程序员手动申请释放，但空间大小有限
	<span class="token comment">#注意：当这个程序结束，在堆区申请的空间也可以被系统释放</span>

静态区：静态区用于保存自动全局变量和static变量，静态区的内容在整个程序中都存在，由编译器在编译的时候分配内存
</code></pre> 
<h3><a id="18_include__include__237"></a>18. #include&lt;&gt; 和 #include”” 有什么区别？</h3> 
<pre><code>#include&lt;&gt; 直接在 系统的库中 去寻找需要的头文件库
#include"" 现在当前目录进行查找，如果找不到，再去系统的库里进行寻找
</code></pre> 
<h3><a id="180_gcc_244"></a>18.0 gcc附加</h3> 
<pre><code class="prism language-shell">-I	-I <span class="token punctuation">..</span>/include <span class="token comment">#链接库（自己的库）//库的地址	#可以使用 -I 来指示非标准位置的头文件</span>
-i
-L
-l	链接第三方库
</code></pre> 
<h3><a id="19_xx1__x1__x__253"></a>19. x=x+1 , x+=1 , x++ 哪个效率高？</h3> 
<pre><code class="prism language-shell">x++ 读取x的地址，然后x自增1 x++的效率最高
<span class="token assign-left variable">x</span><span class="token operator">+=</span><span class="token number">1</span> 读取等号右边的x的地址，计算x+1的值，将得到的值直接传给左边的x，之前已读过，故省去传值的过程
<span class="token assign-left variable">x</span><span class="token operator">=</span>x+1 先读取等号右边的x的地址，计算x+1的值，然后读取等号左边的x地址，最后将等号右边的值传递给等号左边的值

<span class="token comment">#	++i 效率 比 i++ 更高 </span>
<span class="token number">1</span>.i++返回的是i的值，++i返回的是i+1的值；
<span class="token number">2</span>.i++不能用作左值， ++i 可以用作左值。
</code></pre> 
<h3><a id="20_265"></a>20.为无符号类型变量赋值时，数据类型应怎样转换？</h3> 
<pre><code>隐式类型转换。所有的操作数都自动转换为无符号数。
系统会将低类型会自动转换成高类型进行计算，然后将计算的结果赋值给需要的数据类型
</code></pre> 
<p><img src="https://images2.imgbox.com/7e/b0/Y9yVFYYa_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="Linux_281"></a>二、Linux基础</h2> 
<h3><a id="1_Linux_283"></a>1. 字符设备、块设备、管道等在Linux下有个统称叫什么？</h3> 
<pre><code>Linux 一切皆文件
</code></pre> 
<h3><a id="2_289"></a>2.查看一个文件的类型常用的有几种方式</h3> 
<pre><code class="prism language-shell"><span class="token function">ls</span> -l
<span class="token function">file</span> <span class="token punctuation">[</span>文件名<span class="token punctuation">]</span>
<span class="token function">stat</span> <span class="token punctuation">[</span>文件名<span class="token punctuation">]</span>
</code></pre> 
<h4><a id="_297"></a>引申</h4> 
<pre><code class="prism language-c"><span class="token comment">//普通文件类型 - </span>
Linux中最多的一种文件类型<span class="token punctuation">,</span> 包括 纯文本文件<span class="token punctuation">(</span>ASCII<span class="token punctuation">)</span>；二进制文件<span class="token punctuation">(</span>binary<span class="token punctuation">)</span>；数据格式的文件<span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>各种压缩文件<span class="token punctuation">.</span>第一个属性为 <span class="token punctuation">[</span><span class="token operator">-</span><span class="token punctuation">]</span>
<span class="token comment">//目录文件 d</span>
就是目录， 能用 # cd 命令进入的。第一个属性为 <span class="token punctuation">[</span>d<span class="token punctuation">]</span>，例如 <span class="token punctuation">[</span>drwxrwxrwx<span class="token punctuation">]</span>
<span class="token comment">//块设备文件 b</span>
块设备文件 ： 就是存储数据以供系统存取的接口设备，简单而言就是硬盘。例如一号硬盘的代码是<span class="token operator">/</span>dev<span class="token operator">/</span>hda1等文件。第一个属性为 <span class="token punctuation">[</span>b<span class="token punctuation">]</span>
<span class="token comment">//字符设备 c </span>
字符设备文件：即串行端口的接口设备，例如键盘、鼠标等等。第一个属性为 <span class="token punctuation">[</span>c<span class="token punctuation">]</span>
<span class="token comment">//套接字文件 s </span>
这类文件通常用在网络数据连接。可以启动一个程序来监听客户端的要求，客户端就可以通过套接字来进行数据通信。第一个属性为 <span class="token punctuation">[</span>s<span class="token punctuation">]</span>，最常在 <span class="token operator">/</span>var<span class="token operator">/</span>run目录中看到这种文件类型
<span class="token comment">//管道文件 p</span>
FIFO也是一种特殊的文件类型，它主要的目的是，解决多个程序同时存取一个文件所造成的错误。FIFO是first<span class="token operator">-</span>in<span class="token operator">-</span>first<span class="token operator">-</span><span class="token function">out</span><span class="token punctuation">(</span>先进先出<span class="token punctuation">)</span>的缩写。第一个属性为 <span class="token punctuation">[</span>p<span class="token punctuation">]</span>
<span class="token comment">//链接文件 l</span>
类似Windows下面的快捷方式。第一个属性为 <span class="token punctuation">[</span>l<span class="token punctuation">]</span>，例如 <span class="token punctuation">[</span>lrwxrwxrwx<span class="token punctuation">]</span> 只有软链接文件 才有l
</code></pre> 
<h3><a id="3Linux_318"></a>3.Linux下常用的安装工具？</h3> 
<pre><code>在线安装：sudo apt-get install
离线安装：sudo dpkg 
    安装软件 ： sudo dpkg -i 软件名 （install）
    查看已安装软件的版本： sudo dpkg -l 软件名
    查看软件安装的路径信息 ： sudo dpkg -L 软件名
    卸载软件 ： sudo dpkg -r 软件名 （软件的配置信息会保留）
    完全卸载 ： sudo dpkg -P 软件名 
</code></pre> 
<h3><a id="4shellshellshell_330"></a>4.分别解释shell命令、shell、shell脚本</h3> 
<pre><code>shell : 命令行解释器（包括sh,csh,ksh,bash,dash等不同版本的语法）
shell命令：是一种解释型语言的命令行语句
shell脚本：本质上是一个文件。 是以.sh 结尾的文件。 里面存放的是shell命令的集合。
</code></pre> 
<h3><a id="5printfscanf_338"></a>5.printf与scanf操作的是否是同一个文件</h3> 
<pre><code class="prism language-shell">不是
<span class="token builtin class-name">printf</span> 操作的是标准输出流文件 <span class="token comment">#--- stdout</span>
scanf 操作的是标准输入流文件 <span class="token comment">#--- stdin</span>

<span class="token comment">#还有一个 标准错误输出 --- stderr </span>
</code></pre> 
<h3><a id="6_Linux_348"></a>6. Linux常用的文件系统类型？如何查看文件系统类型？</h3> 
<pre><code class="prism language-shell">Linux常用的文件系统是 ext4，ext3<span class="token punctuation">..</span>
查看文件系统类型的命令（以下四个都行）
<span class="token function">df</span> -T  
<span class="token function">parted</span> -l 
blkid  
lsblk -f
</code></pre> 
<h3><a id="7_windows_359"></a>7. windows下有没有文件系统？文件系统有何作用？</h3> 
<pre><code>有！windows文件系统包括fat16,fat32,ntfs,ntfs5.0,winfs等

作用：负责'管理和存储'文件信息的软件机构称为文件管理系统，简称文件系统。
从系统角度来看，'文件系统'是对'文件存储器空间'进行'组织和分配'，负责文件存储并对存入的文件进行保护和检索的系统。
具体地说，它负责为用户建立文件，存入、读出、修改、转储文件，控制文件的存取，当用户不再使用时撤销文件等。
</code></pre> 
<h3><a id="8_371"></a>8.头文件和库文件一般在哪个路径下？</h3> 
<pre><code class="prism language-shell">系统标准<span class="token string">'头文件'</span>位置： /usr/include
安装库的<span class="token string">'头文件'</span>位置： /usr/local/include/
</code></pre> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;linux/can.h&gt;</span>      <span class="token comment">//对应 /usr/include/linux/can.h</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h&gt;</span>  <span class="token comment">//对应 /usr/include/stdio.h</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;libusb-1.0/libusb.h&gt;</span> <span class="token comment">//对应 /usr/local/include/libusb-1.0/libusb.h</span></span>
</code></pre> 
<pre><code class="prism language-shell">系统标准<span class="token string">'库文件'</span>位置：/lib/usr/lib
用户<span class="token string">'安装库'</span>位置： /usr/local/lib
</code></pre> 
<pre><code class="prism language-shell">默认只搜索标准c语言库，对于系统标准库中的其他库以及安装库，需要在编译时指定库名。对于非系统
标准库还需通过-L来指定库文件位置。
a. C标准库，不需要-l 以及-L，编译时自动连接/lib/x86_64-linux-gnu/libc.so.6：gcc -o <span class="token builtin class-name">test</span> test.c
b. 标准库中的其他库，如libmath.so：gcc -o <span class="token builtin class-name">test</span> test.c -lm
c.安装库：如：libusb-1.0.so，gcc -o libusb-test usbtest3.0.c -lpthread -lusb-1.0
d.非系统标准库：gcc -o usbtest usbtest.c -L/home/baoli/libusb -lusb
</code></pre> 
<h3><a id="9_398"></a>9.系统如何区别同名的文件</h3> 
<pre><code>文件描述符
</code></pre> 
<h3><a id="10_404"></a>10.系统如何区别不同的进程。</h3> 
<pre><code>pid
</code></pre> 
<h3><a id="11_410"></a>11.查看文件有哪些命令</h3> 
<pre><code class="prism language-shell"><span class="token function">cat</span> 由第一行开始显示文件内容 <span class="token comment">#-n 可以显示行号</span>
<span class="token function">tac</span> 从最后一行开始向前显示，<span class="token comment">#可以看出 tac 是 cat 的倒着写</span>

<span class="token function">more</span> 一页一页的显示文件内容
<span class="token function">less</span> 与 <span class="token function">more</span> 类似，但是比 <span class="token function">more</span> 更好的是，他可以往前翻页！

<span class="token function">head</span> 只看头几行，默认前10行
<span class="token function">tail</span> 只看尾巴几行，默认后10行

<span class="token function">ls</span> 查看目录下的文件
<span class="token function">file</span> 查看文件的类型
</code></pre> 
<h3><a id="12_426"></a>12.如修改文件的权限</h3> 
<pre><code class="prism language-shell"><span class="token function">chmod</span> <span class="token builtin class-name">:</span> 改变档案的权限, SUID, SGID, SBIT等等的特性
	<span class="token function">chmod</span> <span class="token number">754</span> filename

<span class="token comment">#chgrp : 改变档案所属群组</span>
<span class="token comment">#chown : 改变档案拥有者</span>
</code></pre> 
<h3><a id="13_436"></a>13.什么是符号链接？</h3> 
<pre><code>又叫软链接，
	#用相对路径创建软链接时：任意文件位置发生变化的时候，链接会失效(但是链接文件依旧存在)
	#用绝对路径创建的时候：链接文件可以移动到任意位置， 但是被链接文件（源文件）不能移动
</code></pre> 
<h2><a id="_450"></a>三、数据结构</h2> 
<h3><a id="1_452"></a>1.数据结构主要研究的是什么？</h3> 
<pre><code>数据的各种逻辑结构和物理结构以及它们之间的关系(数学模型)
对各种结构定义相应的运算
设计出相应的算法
分析算法的效率
</code></pre> 
<h3><a id="2_461"></a>2.数组和链表的区别</h3> 
<pre><code>（逻辑结构、内存存储、访问方式三个方面辨析）
逻辑结构：线性关系
内存存储：数组是一个连续的地址空间，链表可以是不连续的的地址空间
访问方式：数组可以通过下标直接的访问都对应的位置，链表不可以
		但是数组的删除，任意位置插入，需要内存成片的移动，效率低
		链表，的删除和插入更方便
</code></pre> 
<pre><code>顺序表：（数组）
原理：顺序表存储是将数据元素放到一块连续的内存存储空间，相邻数据元素的存放地址也相邻（逻辑
与物理统一）。
优点：
   	（1）空间利用率高。（局部性原理，连续存放，命中率高）
    （2）存取速度高效，通过下标来直接存储。
缺点：
	（1）插入和删除比较慢，比如：插入或者删除一个元素时，整个表需要遍历移动元素来重新排一次顺序。
    （2）不可以增长长度，有空间限制,当需要存取的元素个数可能多于顺序表的元素个数时,会出现"溢出"问题.当元素个数远少于预先分配的空间时,空间浪费巨大。 
时间性能 :查找 O(1) ,插入和删除O（n）
</code></pre> 
<pre><code>链表存储
原理：链表存储是在程序运行过程中动态的分配空间，只要存储器还有空间，就不会发生存储溢出问题，相邻数据元素可随意存放，但所占存储空间分两部分，一部分存放结点值(data)，另一部分存放表示结点关系间的指针(struct 结构体* next)。
优点：
    （1）插入和删除速度快，保留原有的物理顺序，比如：插入或者删除一个元素时，只需要改变指针指向即可。
    （2）没有空间限制,存储元素的个数无上限,基本只与内存空间大小有关。
缺点：
  	（1）存取某个元素速度慢。
  	（2）占用额外的空间以存储指针(浪费空间，不连续存放，malloc开辟，空间碎片多)
    （3）查找速度慢，因为查找时，需要循环链表访问，需要从开始节点一个一个节点去查找元素访问。
  时间性能 :查找 O(n) ,插入和删除O（1）。
</code></pre> 
<h3><a id="3_498"></a>3.快速排序的算法</h3> 
<pre><code>1.选择一个'基准'元素,通常选择第一个元素或者最后一个元素
2.通过一趟排序将（需要排序的数组）分割成独立的两部分，（左面的）其中一部分记录的元素值均比基准元素值小。（右面的）另一部分记录的元素值比基准值大。
3.此时'基准元素'在其排好序后的中间位置
4.然后递归操作，分别对这两部分用同样的方法继续进行排序，直到整个序列有序。
</code></pre> 
<h3><a id="4_hash_507"></a>4. hash查找的算法</h3> 
<pre><code class="prism language-shell">如果要从 <span class="token string">'NUM'</span> 个数中查找数据，
后<span class="token string">'NUM'</span>/0.75,求得最大质数<span class="token string">'N'</span>，所以创建一个有<span class="token string">'N'</span>个元素的指针数组，然后将<span class="token string">'NUM'</span>个数分别对<span class="token string">'N'</span>取
余，
将每一个数保存在余数等于数组元素下标的链表中，然后进行查找是直接找相应的数组下标即可

<span class="token comment">#实际解释</span>
如果要从100个数中查找数据
然后100/0.75,求得最大质数133，所以创建一个有133个元素的指针数组
然后将num个数分别对133取余，
将每一个数保存在余数等于数组元素下标的链表中，然后进行查找是直接找相应的数组下标即可
</code></pre> 
<h3><a id="5_522"></a>5.判断单链表是否有环</h3> 
<pre><code class="prism language-shell">使用两个指针，同时指向同一个节点，然后一个指针一次走两步，一个指针一次走一步，然后判断这两个指针有没有指向同一个节点的时候，如果指向了同一个节点 就是有环，否则就是没有
</code></pre> 
<h3><a id="6_528"></a>6.判断一个括号字符串是否匹配正确，如果括号有多种，怎么做？如（（[]））正确，[[(()错误</h3> 
<pre><code class="prism language-shell">使用的是链式栈 作为基础		
	<span class="token comment">#一个栈，根据'右括号的'种类，判断'栈顶元素'是不是匹配，</span>
	<span class="token comment">#如果不匹配 报错返回 return，匹配 出栈</span>
然后判断 ，如果是 （  就进栈，如果是 ） 就出栈
判断执行完出栈函数之后的返回值，如果返回值 等于 -1 ，则是错误的
当整个括号字符串出栈 结束后，如果出栈的返回值 <span class="token operator">=</span> <span class="token number">0</span>，表示是正确的，否则是错误的
</code></pre> 
<h2><a id="_IO_541"></a>四. IO进程</h2> 
<h3><a id="1IOIO_543"></a>1.标准IO和文件IO区别？</h3> 
<h4><a id="IO_545"></a>文件IO-系统调用</h4> 
<pre><code class="prism language-shell">文件IO又被称作 系统调用，不涉及缓冲区，是由操作系统提供的，也就是 内核 提供API（API：函数接口）
文件IO对文件操作使用文件描述符
    文件描述符：
    文件的标志，是一个小的<span class="token string">'顺序分配'</span>的非负整数。内核用以 标识一个特定进程正在访问的文件
    <span class="token string">'进程间通信'</span>方式中大多数也是<span class="token string">'通过文件描述符'</span>进行操作的
    文件描述符跟文件指针类似，也是用于标识一个文件，对文件操作需要使用文件描述符
    当一个程序运行时，操作系统会<span class="token string">'自动为当前程序创建三个文件描述符'</span>
        <span class="token number">0</span>   标准输入文件描述符<span class="token punctuation">(</span>stdin<span class="token punctuation">)</span>
        <span class="token number">1</span>   标准输出文件描述符<span class="token punctuation">(</span>stdout<span class="token punctuation">)</span>
        <span class="token number">2</span>   标准错误输出文件描述符<span class="token punctuation">(</span>stderr<span class="token punctuation">)</span>
</code></pre> 
<h4><a id="IO_560"></a>标准IO-库函数</h4> 
<pre><code class="prism language-shell">标准IO就是库函数，库函数的本质还是系统调用
标准IO是在 文件IO 的基础上，封装出来的。
库函数相比系统调用，多了一个缓冲区，在执行系统调用之前，会将数据先保存在缓冲区中，只有当缓冲区刷新的时候才会执行系统调用
标准IO对文件操作使用文件指针，<span class="token string">'fp'</span>它是一个FILE结构体中文件指针数组的下标
<span class="token comment">#特点</span>
标准IO的<span class="token string">'可移植性高'</span>
标准IO在<span class="token string">'文件IO'</span>的基础上<span class="token string">'封装了一片空间名字叫做缓冲区'</span>
FILE 结构体<span class="token punctuation">(</span>文件指针<span class="token punctuation">)</span> 是在<span class="token string">'文件描述符'</span>的基础上封装了<span class="token string">'缓冲区'</span>
文件指针：FILE * <span class="token comment">#又被称为文件流指针 ，流指针</span>
</code></pre> 
<h3><a id="2_574"></a>2.简述流指针？–文件指针、文件流指针</h3> 
<pre><code>FILE 结构体(文件指针) 是在'文件描述符'的基础上封装了'缓冲区
FILE指针：每个被使用的文件都在内存中开辟一个区域，用来存放文件的有关信息，这些信息是保存在一个结构体类型的变量中，该结构体类型是由系统定义的，取名为FILE。
标准I/O库的所有操作都是围绕流(stream)来进行的，在标准I/O中，流用FILE *来描述。
</code></pre> 
<h3><a id="3_582"></a>3.简述系统调用？</h3> 
<pre><code class="prism language-shell">系统调用主要指的就是对<span class="token string">'硬件'</span>的操作流程
用户通过<span class="token string">'应用层函数'</span>操作<span class="token string">'linux内核'</span>，linux<span class="token string">'内核'</span>再来<span class="token string">'控制'</span>硬件
linux内核里面封装了大量的系统调用，我们用户会通过<span class="token string">'应用层的系统调用函数'</span>来<span class="token string">'调用内核的系统调用'</span>
<span class="token comment">#不同的linux内核中的系统调用是不一样的，所以系统调用对应的程序移植性不高，一般对底层硬件操作都要通过系统调用</span>

从执行角度讲，就是上层API接口通过引发<span class="token string">'软中断'</span>，进入到内核空间，执行<span class="token string">'系统调用服务'</span>例程，通过系统调用编
号，找到对应的内核函数，将处理结果返回，中间涉及到处理器状态的切换（用户态、内核态）
</code></pre> 
<h3><a id="31__594"></a>3.1 简述库函数</h3> 
<pre><code class="prism language-shell">库函数是别人为了统一不同操作系统对文件操作的函数
也就意味着主要支持C语言的系统，库函数都应该是一样的
所以库函数的移植性更高
<span class="token comment">#注意：库函数的本质还是系统调用，只不过库函数相比系统调用多了 缓冲区 ，缓冲区就是用来减少系统调用次数的</span>
<span class="token comment">#只有当缓冲区被刷新之后才会执行系统调用</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/e0/bc/tlfPT6Rl_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="4_607"></a>4.简述静态库和动态库的区别？</h3> 
<pre><code class="prism language-shell"><span class="token number">1</span>.静态库是在链接阶段，将库和目标二进制文件合并到一起，形成一个整体，编译出可执行文件。会造
成可执行文件较大的现象，但是运行速度也就是调用函数的速度快。在软件更新时需要重新去编译成可执行
文件。静态库是以.a为后缀的。
<span class="token number">2</span>.动态库是在链接阶段，在目标二进制文件中创建一个库函数表单，指定链的库函数。库和可执行文件
两者相互独立所以，生成的可执行文件较小，因为需要去外部调用函数，所以速度较慢，但是更新时无需重
新编译，只需要更改库函数的实现就好了。动态库是以.so为后缀的。
</code></pre> 
<h3><a id="5_618"></a>5.如何将程序执行直接运行于后台？</h3> 
<pre><code class="prism language-shell">./**  <span class="token operator">&amp;</span>
</code></pre> 
<h4><a id="_624"></a>前台后台切换</h4> 
<pre><code class="prism language-shell">查看后台进程： <span class="token function">jobs</span> -l
ctrl + z ： 暂停进程到保存后台

将后台暂停程序在<span class="token string">'后台'</span>运行起来：
	<span class="token function">bg</span> + % 序列号（直接bg也可以）

将后台暂停进程<span class="token string">'拿到前台运行'</span>：
	<span class="token function">fg</span> + % 序列号（直接fg也可以，因为当前终端只有这一个可以变更修改的进程）
	
将程序在后台运行：./a.out + <span class="token operator">&amp;</span>
	
<span class="token function">kill</span> -19 pid 将进程号为pid的进程变为停止态
<span class="token function">kill</span> -18 pid 将进程号为pid的进程从停止态变为后台进程
</code></pre> 
<h3><a id="6_642"></a>6.进程的状态</h3> 
<pre><code>睡眠态S，运行态R，停止态T，僵尸态Z，等待态D，死亡态，
    +:    前台进程
    &lt;: 高优先级的进程
    N: 低优先级的进程
    L: 有内存分页分配并锁在内存中，多线程的
    s:    会话组组长
</code></pre> 
<h3><a id="7_653"></a>7.什么是僵尸进程？</h3> 
<pre><code class="prism language-shell">子进程结束，但是父进程没有结束，此时子进程的资源没有释放（回收），将此时的子进程称之为僵尸进程 <span class="token comment">#具有危害</span>
（孩子死了，爹不给收尸，具有危害）
<span class="token comment">#处理僵尸进程的方式</span>
    方法1：<span class="token string">'父进程结束'</span>，此时的僵尸进程就会变成孤儿进程，资源就会被init进程回收
    方法2：使用<span class="token string">'wait函数'</span>，阻塞等待子进程退出，同时可以释放僵尸进程的资源，但是wait是一个阻塞函数，父进程wait之后的代码只有当僵尸进程处理完之后才会执行
    方法3：使用<span class="token string">'waitpid函数'</span>设置为非阻塞来处理僵尸进程但是使用非阻塞必须循环的判断子进程是否退出，如果父进程没有循环执行<span class="token string">'waitpid函数'</span>，则无法回收资源
    方法4：处理僵尸进程最好的方式是结合信号
</code></pre> 
<h3><a id="78_665"></a>7-8.孤儿进程</h3> 
<pre><code>爹死了，孩子认init进程为干爹，干爹给他收尸---没有危害
</code></pre> 
<h3><a id="8_671"></a>8.简述创建子进程中的写时拷贝技术？</h3> 
<pre><code class="prism language-shell">由于fork完整地拷贝了父进程的整个地址空间，因此执行速度是比较慢的。
为了提高效率
Unix系统设计者创建了vfork。vfork也创建新进程，但不产生父进程的副本。
它通过<span class="token string">'允许父子进程可访问相同物理内存'</span>从而伪装了对进程地址空间的真实拷贝，当<span class="token string">'子进程需要改变内存中数据时'</span>'才拷贝父进程'。这就是著名的<span class="token string">"写操作时拷贝"</span><span class="token punctuation">(</span>copy-on-write<span class="token punctuation">)</span>技术
</code></pre> 
<h3><a id="9_680"></a>9.多线程较多进程的优势？</h3> 
<pre><code>线程通过不需要同进程一样的通信机制，线程通过共享进程的数据段完成通信，线程创建不需要复制进程的属性，创建更快
线程轮转的时候不需要切换4G的虚拟空间，所以线程更快
</code></pre> 
<h3><a id="10_687"></a>10.线程池的使用？----再看看</h3> 
<pre><code>多线程技术主要解决'处理器单元内'多个线程执行的问题，它可以显著减少处理器单元的闲置时间，增加处理器单元的吞吐能力 
 假设一个服务器完成一项任务所需时间为：T1 创建线程时间，T2 在线程中执行任务的时间，T3销毁线程时间
如果：T1 + T3 远大于 T2，则可以采用线程池，以提高服务器性能


</code></pre> 
<h3><a id="11_697"></a>11.线程池的组成部分？</h3> 
<pre><code>一个线程池包括以下四个基本组成部分：
 1、线程池管理器（ThreadPool）：用于创建并管理线程池，包括 创建线程池，销毁线程池，添
加新任务；
 2、工作线程（PoolWorker）：线程池中线程，在没有任务时处于等待状态，可以循环的执行任
务；
 3、任务接口（Task）：每个任务必须实现的接口，以供工作线程调度任务的执行，它主要规定了
任务的入口，任务执行完后的收尾工作，任务的执行状态等；
 4、任务队列（taskQueue）：用于存放没有处理的任务。提供一种缓冲机制。
</code></pre> 
<h3><a id="12_710"></a>12.线程的同步互斥机制？</h3> 
<pre><code class="prism language-shell">互斥：<span class="token string">'同一时间'</span>只能有一个线程执行，执行<span class="token string">'完毕后'</span>其他线程再执行   --- 互斥锁
同步：在<span class="token string">'互斥的基础上'</span>'有顺序'执行 ---  信号量 条件变量
</code></pre> 
<h3><a id="13_717"></a>13.简述互斥锁的实现原理？</h3> 
<pre><code class="prism language-shell"><span class="token string">'多个线程'</span>如果要<span class="token string">'对'</span>同<span class="token string">'一个共享资源进行操作'</span>
<span class="token string">'谁抢占到'</span>资源，就对共享资源的操作<span class="token string">'进行上锁'</span>
<span class="token string">'其他线程需要等待'</span>，当第一个线程对共享资源的<span class="token string">'操作执行完毕后就解锁'</span>，解锁之后
<span class="token string">'其他线程'</span>就可以在对这个资源进行操作，
操作之前还是得<span class="token string">'上锁'</span>
<span class="token string">'操作完毕后'</span>还是得<span class="token string">'解锁'</span>
解锁之后其他线程又可以操作，
--以此类推--
</code></pre> 
<pre><code class="prism language-shell">临界资源：多个线程<span class="token string">'共享的资源'</span>叫做临界资源，它的改变有可能影响到其他线程的使用结果。
临界区：<span class="token string">'操作'</span>临界资源的<span class="token string">'一段代码'</span>
</code></pre> 
<h3><a id="14_735"></a>14.简述死锁的情景？</h3> 
<pre><code>死锁的概念：
多线程以及多进程改善了系统资源的利用率并提高了系统的处理能力。然而，'并发执行'也带来了新的问题——--死锁。所谓死锁是指'多个线程'因'竞争资源'而造成的一种'僵局（互相等待）''，若无外力作用，这些进程都将无法向前推进

产生的原因：
1.对不可剥夺资源的竞争，才可能产生死锁（如磁带机、打印机）
2.进程推进顺序非法，请求和释放资源的顺序不当，也同样会导致死锁
</code></pre> 
<h3><a id="15_746"></a>15.简述信号量的原理？</h3> 
<pre><code>信号量主要解决同步问题
信号量的本质是PV操作（P是- V是+）
信号量本质是一个计数器，对计数器有两个操作，P操作和V操作，P操作是减操作，V操作是加操作，
当信号量的值为0时，P操作将会阻塞，V操作没有影响
默认线程中的信号量PV操作执行一次只能减1或者加1
</code></pre> 
<h3><a id="16_756"></a>16.简述进程的通信机制？</h3> 
<pre><code class="prism language-shell">早期的进程间通信方式：
    无名管道 ：只能用于<span class="token string">'亲缘关系'</span>的进程
    有名管道 ：<span class="token string">'本地生成'</span>套接字<span class="token string">'文件'</span>用于<span class="token string">'标识内核空间'</span>开辟的区域
    信号通信 ：当产生信号时，对进程有相应的处理方式---<span class="token string">'唯一的异步通信机制'</span>
SYSTEM V：IPC对象
    消息队列 ：IPC 对象，对系统所有进程可见，<span class="token string">'保存数据'</span>，可以根据类型读取数据
    共享内存 ：<span class="token string">'效率最高'</span>，<span class="token string">'实时数据'</span>一般会使用共享内存保存
    信号灯集 ：<span class="token string">'PV 操作'</span>，解决同步问题
BSD：
    套接字通信 ：实现<span class="token string">'不同主机'</span>的进程间通信
</code></pre> 
<h3><a id="17_771"></a>17.管道的通信原理？</h3> 
<pre><code class="prism language-shell">管道分为无名管道跟有名管道，其原理都是<span class="token string">'在内核中开辟一块空间'</span>，然后对这块空间进行操作，数据都存在在内存上
无名管道只能用于亲缘间进程通信，原因是在磁盘文件系统上不存在。
有名管道的出现，就是为了弥补这一缺点。有名管道在文件中属于一个特殊的文件，它确确实实存在文件系统之上，但是他的<span class="token string">'数据存放在内存上'</span>。

无名管道：
无名管道就是在<span class="token string">'内核空间开辟一块区域'</span>，然后会给<span class="token string">'进程两个文件描述符'</span>，只要多个进程可以得到这两个文件描述符，就可以对同一个管道进行操作
无名管道是一个<span class="token string">'半双工的通信方式'</span>，意味着有<span class="token string">'固定的读端和写端'</span>，但是无名管道不存在于磁盘空间。数据的操作也在内存。
既然无名管道给当前进程的是两个文件描述符，所以可以通过文件IO函数对其进行操作
无名管道<span class="token string">'只能用于具有亲缘关系的进程间通信'</span>，
	原因是因为无名管道既然给当前进程的是两个文件描述符，那么这两个文件描述符的创建只能在当前进程的用户空间，当fork之后产生的进程，会继承原本父进程的所有的空间，所以他能得到这两个文件描述符

管道的大小时64*1024，管道写满之后如果在进行写入的话，会阻塞等待写入。


有名管道：
有名管道创建好之后会在本地创建一个管道文件，对于当前系统中的进程都是可见的，
所以有名管道可以实现不相关进程间通信，由于创建了一个文件，所以对文件操作本质就是对内核开辟的区域操作，通过文件IO就可以操作


注意：打开有名管道时，必须读写权限同时存在。

在内核内存空间上创建管道，视管道为文件，对文件实现操作，但不能定位，管道的数据在内存上
</code></pre> 
<h3><a id="18_798"></a>18.用户进程对信号的响应方式？</h3> 
<pre><code class="prism language-shell">忽略:当信号产生后对当前进程<span class="token string">'没有任何影响'</span>
缺省:按照当前<span class="token string">'信号默认的方式'</span>处理
捕捉:接收到信号后改变其函数指针执行的功能函数，执行我自己的功能--为我所用

<span class="token comment">#注意：SIGKILL、SIGSTOP 这两个信号只能以缺省(默认方式)的方式处理，不能忽略也不能捕捉</span>
</code></pre> 
<h3><a id="19_808"></a>19.共享内存通信原理？</h3> 
<pre><code class="prism language-shell">在内核空间，开辟一块物理空间，分别映射给通信的进程的虚拟地址空间上，实现多进行操作同一块区域

共享内存是一种最为高效的进程间通信方式，进程可以直接读写内存，而不需要任何数据的拷贝
为了在多个进程间交换信息，内核专门留出了一块内存区，可以由需要访问的进程将其映射到自己的私有地址空间
进程就可以直接读写这一内存区而不需要进行数据的拷贝，从而大大提高的效率。
由于多个进程共享一段内存，因此也需要依靠某种同步机制，如互斥锁和信号量等
内核预留出来了一片地址空间，专门给进程做通信使用，然后将首地址以地址映射的方式交给用户空间。共享
内存是所有进程间通讯中速度最快的。是通过地址的映射的方式做到了用户层直接操作内核层的地址上的值。
</code></pre> 
<h2><a id="__827"></a>五. 网络编程</h2> 
<h3><a id="1_ISOTCPIP_829"></a>1. ISO七层网络通信结构和TCP/IP四层网络通信结构</h3> 
<h4><a id="ISO_831"></a>ISO七层网络模型</h4> 
<pre><code>应用层：面向用户的应用程序，app
表示层：数据加密、解密操作
会话层：将数据所在主机的逻辑名字和物理名字之间建立联系 (逻辑名和主机名之间的联系)
传输层：负责数据具体传输的机制(指定数据传输的方式)
网络层：如何处理如何将数据发给目的主机，路由的选择(数据分组、路由选择)
链路层：将前面所有的数据组成一个数据包，称之为一帧数据
物理层：选择数据发送的物理媒介（有线、无线）
</code></pre> 
<h4><a id="TCPIP_843"></a>TCP/IP四层网络模型</h4> 
<pre><code>TCP/IP是目前为止用的'最广泛的网络体系结构'一共4层
应用层
传输层
网络层
网络接口与物理层
</code></pre> 
<p><img src="https://images2.imgbox.com/48/64/M7xdkKMd_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="2_tcp_856"></a>2. tcp通信的优缺点</h3> 
<pre><code class="prism language-shell">TCP（即传输控制协议）概念：是一种<span class="token string">'面向连接'</span>的<span class="token string">'可靠'</span>的基于<span class="token string">'字节流'</span>的传输层协议，它能提供高<span class="token string">'可
靠'</span>性通信<span class="token punctuation">(</span>即数据无误、数据无丢失、数据无失序、数据无重复到的通信<span class="token punctuation">)</span>
优点：
    TCP具有<span class="token string">'回传机制'</span>，意味着如果数据发送出现问题，会重复发送
    TCP提供以认可的方式显式地创建和终止连接。
	TCP保证可靠的、顺序的（数据包以发送的顺序接收）以及不会重复的数据传输。
	TCP处理流控制。
	允许数据优先
	如果数据没有传送到，则TCP套接口返回一个出错状态条件。
	TCP通过保持连续并将数据块分成更小的分片来处理大数据块。—无需程序员知道
缺点：
    TCP在传输数据时必须创建（并保持）一个连接。这个连接给通信进程增加了开销，让它比UDP速度要慢
</code></pre> 
<h3><a id="23_TCP_873"></a>2.3 TCP为什么要进行三次握手</h3> 
<pre><code class="prism language-shell">第一次握手：<span class="token string">'客户端'</span>向<span class="token string">'服务器端'</span>发送<span class="token string">'连接请求'</span>，TCP包头中SYN置1，自己的随机序列号seq为x。

第二次握手：当<span class="token string">'服务器端'</span>接收到<span class="token string">'客户端'</span>的连接<span class="token string">'请求'</span>，发现SYN为1，解析获得客户端的随机序列号后。
	向<span class="token string">'客户端'</span>发送的TCP包头中SYN置1，应答序列号ACK置1，应答序列号ack为客户端的随机序列号加一（x+1），自己的随机序列号seq为y。
	
第三次握手：<span class="token string">'客户端'</span>接收到<span class="token string">'服务器端'</span>的<span class="token string">'连接请求'</span>和<span class="token string">'应答'</span>后。向<span class="token string">'服务器'</span>发送<span class="token string">'应答信号'</span>，应答标志位ACK置1，应答序列号为服务器的随机序列号加一（y+1）

为什么是三次？
	三次握手的目的是<span class="token string">'确保服务器'</span>和<span class="token string">'客户端'</span>都具有<span class="token string">'收发数据'</span>的能力，
	第一次握手成功说明<span class="token string">'客户端'</span>有<span class="token string">'发数据'</span>的能力，
	第二次握手成功说明<span class="token string">'服务器'</span>有<span class="token string">'收发数据'</span>的能力，
	第三次握手成功说明<span class="token string">'客户端'</span>有<span class="token string">'接收数据'</span>的能力，
所以三次握手的过程缺一不可，但是，如果说超过三次的握手次数，会浪费资源和时间
</code></pre> 
<h3><a id="3_udp_891"></a>3. udp通信的优缺点</h3> 
<pre><code class="prism language-shell">UDP（User Datagram Protocol）用户数据报协议，是<span class="token string">'不可靠'</span>的<span class="token string">'无连接'</span>的<span class="token string">'数据报'</span>协议。在数据发送前，因为不需要进行连接，所以可以进行高效率的数据传输。

优点：
	<span class="token number">1</span>．UDP不要求保持一个连接
	<span class="token number">2</span>．UDP没有因接收方认可收到数据包（或者当数据包没有正确抵达而自动重传）而带来的开销。（没有自动回传机制）
	<span class="token number">3</span>．设计UDP的目的是用于短应用和控制消息
	<span class="token number">4</span>．在一个数据包连接一个数据包的基础上，UDP要求的网络带宽比TDP更小。
缺点：
	不可靠
</code></pre> 
<h3><a id="4_poolselectselect_poll_epoll_905"></a>4. pool与select的区别（select poll epoll的区别）</h3> 
<pre><code class="prism language-shell">select:
    <span class="token number">1</span>.select监听的<span class="token string">'最大文件描述符的个数'</span>是 <span class="token number">1024</span> 个
    <span class="token number">2</span>.select监听的<span class="token string">'表会被清空'</span>，所以需要<span class="token string">'反复'</span>将用户空间的表<span class="token string">'拷贝'</span>到内核空间，<span class="token string">'效率'</span>比较<span class="token string">'低'</span>。
    <span class="token number">3</span>.select从<span class="token string">'休眠状态被唤醒'</span>之后，<span class="token string">'需要遍历'</span>所有的文件描述符，找到准备好的文件描述符，这个过程效率比较低。

poll:
    <span class="token number">1</span>.poll监听的文件描述符<span class="token string">'没有个数限制'</span>
    <span class="token number">2</span>.poll表<span class="token string">'没有被清空'</span>，<span class="token string">'不需要'</span>反复拷贝，<span class="token string">'效率高'</span>
    <span class="token number">3</span>.poll从<span class="token string">'休眠状态被唤醒'</span>之后，<span class="token string">'需要遍历'</span>所有的文件描述符，找到准备好的文件描述符，这个过程效率比较低。

epoll:（<span class="token comment">#本世纪最好用的IO多路复用机制）</span>
    <span class="token number">1</span>.epoll监听的文件描述符<span class="token string">'没有个数限制'</span>
    <span class="token number">2</span>.epoll<span class="token string">'表没有被清空'</span>，不需要反复拷贝，效率高
    <span class="token number">3</span>.epoll从<span class="token string">'休眠状态被唤醒'</span>之后,<span class="token string">'不需要遍历'</span>文件描述符能直接拿到准备好的文件描述符。
</code></pre> 
<h3><a id="selectpollepoll_924"></a>select、poll、epoll机制的特点</h3> 
<pre><code class="prism language-shell">select，poll，epoll都是<span class="token string">'IO多路复用'</span>的机制。
I/O多路复用就通过一种机制，可以<span class="token string">'监视'</span>多个文件描述符
一旦<span class="token string">'某个描述符就绪'</span>（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。
但select，poll，epoll本质上都是<span class="token string">'同步I/O'</span>，
因为他们都需要在<span class="token string">'读写事件就绪后'</span>自己负责进行读写，也就是说这个<span class="token string">'读写'</span>过程是<span class="token string">'阻塞'</span>的，
而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从<span class="token string">'内核'</span>拷贝到<span class="token string">'用户空间'</span>---copy to /copy from 。
</code></pre> 
<h3><a id="5_io_935"></a>5. io模型有哪几种</h3> 
<pre><code class="prism language-shell">阻塞I/O： 最常用、最简单、效率最低
非阻塞I/O： 可防止进程阻塞在I/O操作上，需要轮询
I/O 多路复用： 允许同时对多个I/O进行控制（用一个阻塞函数，阻塞所有阻塞函数）
信号驱动I/O: 一种异步通信模型<span class="token punctuation">(</span>好像也是学过的唯一的一个异步IO<span class="token punctuation">)</span>
</code></pre> 
<h3><a id="6_tcp_944"></a>6. 如何实现tcp并发服务器</h3> 
<pre><code class="prism language-shell">tcp本身不是并发服务器的原因在于有两个读阻塞函数，
    <span class="token string">'accept'</span>负责连接，产生对应的文件描述符，
    <span class="token string">'recv'</span>负责接收数据，
所以可以使用父子进程或者多线程实现tcp并发服务器，也可以使用select实现多进程、多线程、select、poll、epoll
</code></pre> 
<h3><a id="7__953"></a>7. 网络超时检测的本质和实现方式</h3> 
<pre><code class="prism language-shell"><span class="token string">'超时检测'</span>：介于 阻塞 和 非阻塞 之间，设置一定的时间，
	在时间到达<span class="token string">'之内'</span>如果没有数据则<span class="token string">'一直阻塞'</span>
	如果时间<span class="token string">'到了'</span>还<span class="token string">'没有数据'</span>，则变成<span class="token string">'非阻塞'</span>

<span class="token comment">#阻塞:  以读函数为例，如果缓冲区中有数据，则正常读取，如果没有数据，则'一直阻塞等待'</span>
<span class="token comment">#非阻塞: 以读函数为例，如果缓冲区中有数据，则正常读取，如果没有数据，则'函数立即返回'</span>

实现方式：
    方法1：使用<span class="token string">'setsockopt'</span>实现网络超时检测	<span class="token comment">#设置套接字选项</span>
    方法2：使用<span class="token string">'select'</span>实现网络超时检测		<span class="token comment">#select的最后一个参数</span>
    方法3：使用<span class="token string">'alarm闹钟'</span>实现网络超时检测		<span class="token comment">#使用闹钟</span>

<span class="token comment">#-------alarm原理---------------------------------------------------</span>
alarm函数设置时间后，代码继续运行，当设定的时间到后，会产生SIGALRM信号（闹钟信号<span class="token punctuation">)</span>这个信号默认
对当前进程的处理方式是结束进程
如果将信号的处理方式改为自定义，当执行完信号处理函数之后，代码会接着之前的继续运行，这是异步通信
机制默认的属性，我们将这个属性称之为<span class="token string">'自重启属性'</span>
<span class="token string">'为了实现超时检测，我们只需要关闭这个自重启属性即可==&gt; 执行完信号处理函数之后，代码会从头运行'</span>
关闭自重启属性之后代码运行顺序：
当使用alarm设定的时间到达后，产生SIGALRM信号，执行信号处理函数
当信号处理函数执行完毕后，不会继续执行的正在执行的函数，而是错误返回，代码继续运行
<span class="token comment">#使用sigaction函数设置信号的属性</span>
</code></pre> 
<h3><a id="8_TCP__980"></a>8. TCP 网络编程流程</h3> 
<p><img src="https://images2.imgbox.com/3d/bd/3iOcqzS1_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-c">#服务端：
    创建套接字 <span class="token function">socket</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    将服务器网络信息结构体填充 sockaddr_in <span class="token operator">==</span><span class="token operator">=</span><span class="token operator">&gt;</span>  【man <span class="token number">7</span> ip <span class="token operator">--</span><span class="token operator">-&gt;</span>  sockaddr_in
    将套接字与服务器网络信息结构体绑定 <span class="token function">bind</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    将套接字设置为被动监听状态 <span class="token function">listen</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    阻塞等待客户端的连接 <span class="token function">accept</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    进行通信 <span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 或 <span class="token function">recv</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 或 <span class="token function">recvfrom</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token function">sendto</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    关闭文件描述符 <span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

#客户端：
    创建套接字 <span class="token function">socket</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    填充服务器网络信息结构体 sockaddr_in
    客户端给服务器发送连接请求 <span class="token function">connect</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    进行通信 <span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 或 <span class="token function">recv</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 或 <span class="token function">recvfrom</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token function">sendto</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    关闭文件描述符 <span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> 
<h3><a id="9_UDP_1003"></a>9. UDP网络编程流程</h3> 
<p><img src="https://images2.imgbox.com/a1/73/quyCEUgD_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-c">服务端：
    创建套接字 <span class="token function">socket</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    填充服务器网络信息结构体 sockaddr_in
    将套接字与服务器的网络信息结构体绑定 <span class="token function">bind</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    进行通信 <span class="token function">recvfrom</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token function">sendto</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
客户端：
    创建套接字 <span class="token function">socket</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    填充服务器网络信息结构体 sockaddr_in
    进行通信 <span class="token function">recvfrom</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token function">sendto</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> 
<h3><a id="10_UDP_1020"></a>10. UDP本地通信需要注意哪些方面</h3> 
<pre><code class="prism language-shell">客户端程序：
需要bind绑定<span class="token string">'自己的本地信息结构体'</span>，也就是需要指定自己的套接字文件，
如果不这么做，服务器无法识别收到的数据来自于谁，客户端也无法接收到服务器发送的数据
</code></pre> 
<h3><a id="11__1028"></a>11. 怎么修改文件描述符的标志位–文件状态标志位</h3> 
<pre><code class="prism language-c">可以通过<span class="token string">'fcntl函数'</span>修改文件描述符的标志位，一般执行读改写三步
<span class="token keyword">int</span> <span class="token function">fcntl</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">int</span> cmd<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token comment">/* arg */</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h3><a id="12_sqlite_1035"></a>12. sqlite数据库的基本使用，包括增删改查</h3> 
<pre><code class="prism language-sqlite">创建数据库：
create table 表名(成员名 成员类型,成员名 成员类型,...);
在充当主键的成员的后面加 primary key ，在创建的时候，声明这个成员是主键，不能有重复的

增加：也就是插入
insert into 表名 values('数据');//示例如下
insert into sta values(1000,'admin','123456','12345678901');

删除：
delete from 表名 where 条件;//依据后面的条件 删除 对应这个表中符合条件的 行
示例：
delete from stu where id=1002;

修改：
update 表名 set 需要被修改的值 where 条件;
示例：
update sta set name='qxy',passwd='12345' where id=1000;

查询：
select 需要查找的成员名 from 表名 where 条件;
示例：
在sta表中 查询id为1001 的 手机号
select phone from sta where id=1001;
</code></pre> 
<h3><a id="13_UDP_1063"></a>13. 基于UDP的聊天室如何实现数据群发</h3> 
<pre><code>在客户端连接到服务器的时候，定义一个链表（因为不确定客户端的个数，所以用链表）保存客户端bind绑定的信息，，然后群发的时候，服务器遍历整个链表，向每个客户端发送消息
</code></pre> 
<h3><a id="14__1069"></a>14. 在线词典如何实现查询单词</h3> 
<pre><code class="prism language-shell">服务端会通过fopen函数，打开本地的词典
由于 每个单词跟它的释义是在同一行，中间是用空格分开的，所以用fgets来读取一行，
然后使用strtok函数，用<span class="token string">" "</span>空格当分隔符，对这一行的数据进行裁剪，现在截取出来的就是每行的单词，
然后使用strtok函数，对截取完的字符串，再次进行提取，用<span class="token string">'<span class="token entity" title="\n">\n</span>'</span>作为分隔符，得到的就是释义
使用strcmp函数，对比，客户端传过来的单词，跟截取出来的单词
如果相同，把它的释义返回给客户端
</code></pre> 
<h3><a id="15_TCPUDP_1080"></a>15. TCP和UDP的区别</h3> 
<pre><code class="prism language-shell">TCP与UDP基本区别
    <span class="token number">1</span>.TCP基于面向连接与UDP是无连接
    <span class="token number">2</span>.TCP要求系统资源较多，UDP较少；
    <span class="token number">3</span>.UDP程序结构较简单
    <span class="token number">4</span>.流模式（TCP）与数据报模式<span class="token punctuation">(</span>UDP<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token number">5</span>.TCP保证数据正确性，UDP可能丢包
    <span class="token number">6</span>.TCP保证数据顺序，UDP不保证
UDP应用场景：
    <span class="token number">1</span>.面向数据报方式
    <span class="token number">2</span>.网络数据大多为短消息
    <span class="token number">3</span>.拥有大量Client
    <span class="token number">4</span>.对数据安全性无特殊要求
    <span class="token number">5</span>.网络负担非常重，但对响应速度要求高
具体编程时的区别
    <span class="token number">1</span>.socket<span class="token punctuation">(</span><span class="token punctuation">)</span>的参数不同 ---套接字类型不同--TCP（SOCK_STREAM），UDP（SOCK_DGRAM）
    <span class="token number">2</span>.UDP Server不需要调用listen和accept ---UDP是无连接的，所以客户端也不需要connect
    <span class="token number">3</span>.UDP收发数据用sendto/recvfrom函数 ---TCP是面向连接的，直接使用send、from
    <span class="token number">4</span>.TCP：地址信息在connect/accept时确定	---三次握手也是
    <span class="token number">5</span>.UDP：在sendto/recvfrom函数中每次均 需指定地址信息
    <span class="token number">6</span>.UDP：shutdown函数无效
</code></pre> 
<h4><a id="TCPUDP_1105"></a>TCP与UDP区别总结：</h4> 
<pre><code class="prism language-shell"><span class="token number">1</span>、TCP<span class="token string">'面向连接'</span>
   UDP是<span class="token string">'无连接'</span>的，即发送数据之前不需要建立连接
   
<span class="token number">2</span>、TCP提供<span class="token string">'可靠'</span>的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达
   UDP尽最大努力交付，即<span class="token string">'不'</span>保证<span class="token string">'可靠'</span>交付
   
<span class="token number">3</span>、TCP面向<span class="token string">'字节流'</span>，实际上是TCP把数据看成一连串无结构的字节流
   UDP是面向<span class="token string">'报文'</span><span class="token punctuation">(</span>数据报<span class="token punctuation">)</span>的UDP<span class="token string">'没有拥塞控制'</span>，
   因此网络出现<span class="token string">'拥塞'</span>'不会<span class="token string">'使源主机的'</span>发送速率降低<span class="token string">'（对实时应用很有用，如IP电话，实时视频会议等）
   
4、每一条TCP连接只能是'</span>点到点<span class="token string">'的
   UDP支持'</span>一对一，一对多，多对一和多对多<span class="token string">'的交互通信
   
5、TCP首部开销20字节 	UDP的首部开销小，只有8个字节

6、TCP的逻辑通信信道是'</span>全双工<span class="token string">'的'</span>可靠<span class="token string">'信道(在不可靠的信道上建立了一个稳定的连接)，UDP则是'</span>不可靠'信道
</code></pre> 
<h3><a id="16_OSI_1128"></a>16. OSI七层网络模式，每层的主要作用，主要的协议</h3> 
<pre><code>应用层：为特定应用程序提供数据传输服务。（ TFTP，HTTP，SNMP，FTP，SMTP，DNS，Telnet）
表示层：对上层信息进行变换，保证一个主机应用层信息被另一个主机的应用程序理解，表示层的数据转换包括数据的加密、压缩、格式转换。
会话层：管理主机之间的会话进程，即负责建立、管理、终止。
传输层：提供端对端的接口。（ TCP，UDP）
网络层：为数据包选择路由。（IP，ICMP，ARP,RARP）
数据链路层：传输有地址的帧，错误检测功能（ SLIP，CSLIP，PPP，ARP，RARP，MTU）
物理层：以二进制数据形式在物理媒体上传输数据。 ISO2110，IEEE802，IEEE802.2
</code></pre> 
<h3><a id="17_TCP__1140"></a>17. TCP 粘包</h3> 
<pre><code class="prism language-shell">TCP粘包 -- TCP内部实现有一个 Nagle算法
会将 一段时间内 要发送的所有的数据报 整合在一起，作为 一个数据包 发送给对方
对方在接收数据时，recv的第三个参数表示每次接收数据的最大值
由于发送过来的数据是一个整体，所以无法区分每一个部分的数据
就会导致小于第三个参数设置值的多个数据粘连在一起接收到且无法区分
如何处理：
方法1：设置延时，保证不同类型的数据包不与之前的数据一起发送
方法2：在发送数据之前加头部信息，比如要发送数据的大小，然后将头部信息和要发送的数据保存在一个结
构体中，只要保证每次发送的数据大小一致，就不会出现这个问题
</code></pre> 
<h3><a id="18_TCP_1154"></a>18. TCP的三次握手和四次挥手分别作用，主要做什么</h3> 
<pre><code>三次握手：
目的：确定'服务器'和'客户端'两方'都有收发数据'的能力，
第一次握手说明'客户端'有'发数据'的能力
第二次握手说明'服务器端'有'收发数据'的能力
第三次握手说明'客户端'有'收数据'能力
所以三次握手这一过程缺一不可。

四次挥手
TCP协议是一种'面向连接'的、'可靠'的、基于'字节流'的传输层通信协议。
TCP是'全双工'模式，
这就意味着，
当 Client 发出FIN报文段时，只是表示 Client 已经'没有数据要发送'了，Client 告诉 Server，它的数据已经全部发送完毕了；但是，这个时候 Client 还是'可以接受'来自 Server 的数据；
当Server '返回ACK报文'段时，表示它已经知道 Client 没有数据发送了，但是 Server 还是'可以发送数据'到 Client 的；
当 Server 也发送了FIN报文段时，这个时候就表示 Server 也'没有数据要发送'了，就会告诉 Client ，我也没有数据要发送了，之后彼此就会愉快的中断这次TCP连接。

</code></pre> 
<p><img src="https://images2.imgbox.com/cc/fc/bTSoXlOA_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/34/ee/ZEF6iExN_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="19__1177"></a>19. 如何实现并发服务器，并发服务器的实现方式有什么异同</h3> 
<pre><code>实现主要分三种方式：多进程并发服务器，多线程并发服务器，I/O复用并发服务器
</code></pre> 
<h3><a id="20_1183"></a>20.线程和进程的区别，多线程和多进程编程的特点</h3> 
<pre><code class="prism language-shell">进程是<span class="token string">'资源管理'</span>的最小单位，线程是<span class="token string">'程序执行'</span>的最小单位。
每个<span class="token string">'线程'</span>'享有<span class="token string">'其所属附属'</span>进程的所有资源<span class="token string">'（打开的文件，内存页面，信号标识，动态分配的内存等）
线程更小，花费更少的CPU资源
（操作系统设计上，进程演化出线程，是为了更好的支持多处理器）
==》
当线程所属进程退出的时，他所产生的线程都会被强制退出

进程:
进程是程序的'</span>一次执行过程<span class="token string">'，是一个'</span>动态概念<span class="token string">'，是程序在执行过程中'</span>分配<span class="token string">'和'</span>管理资源<span class="token string">'的'</span>基本单位<span class="token string">'，
'</span>每一个进程<span class="token string">'都有一个'</span>自己的地址空间<span class="token string">'，
进程至少有5种基本状态，它们是：初始态，执行态，等待状态，就绪状态，终止状态。

线程：
线程是'</span>系统调度<span class="token string">'和'</span>基本单位<span class="token string">'，它可'</span>与同属<span class="token string">'一个进程的'</span>其他的线程<span class="token string">''</span>共享进程<span class="token string">'所拥有的'</span>全部资源<span class="token string">'。

联系:
'</span>线程<span class="token string">'是'</span>进程<span class="token string">'的一部分，一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程(主控线程)。

区别：
'</span>资源使用<span class="token string">'的角度出发。（所谓的资源就是计算机里的中央处理器，内存，文件，网络等等）

根本区别:'</span>进程<span class="token string">'是操作系统'</span>资源分配<span class="token string">'的'</span>基本单位<span class="token string">'，而'</span>线程<span class="token string">'是'</span>任务调度和执行<span class="token string">'的'</span>基本单位<span class="token string">'
开销方面:每个'</span>进程<span class="token string">'都有'</span>独立<span class="token string">'的代码和数据'</span>空间<span class="token string">'（程序上下文），程序之间的切换会有较大的开销；
	'</span>线程<span class="token string">'可以看做'</span>轻量级的进程<span class="token string">'，同一类'</span>线程共享<span class="token string">'代码和数据'</span>空间<span class="token string">'，
	每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。
	
所处环境：在操作系统中能'</span>同时运行多个进程<span class="token string">'（程序）；而在同一个进程（程序）中有多个线程同时执行
（通过CPU调度，在每个时间片中只有一个线程执行）(上下文切换，时间片轮转)

内存分配方面：系统在运行的时候会为每个'</span>进程<span class="token string">'分配不同的'</span>内存<span class="token string">'空间；而对线程而言，除了CPU外，系统'</span>不会为<span class="token string">'线程'</span>分配内存<span class="token string">'（线程所使用的资源来自其所属进程的资源），线程组之间只能共享资源。

包含关系：没有'</span>线程<span class="token string">'的'</span>进程<span class="token string">'可以看做是'</span>单线程<span class="token string">'的，
如果一个'</span>进程<span class="token string">'内有'</span>多个线程<span class="token string">'，则执行过程不是一条线的，而是'</span>多条线（线程）共同'完成的；
线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。
</code></pre> 
<h2><a id="C_1224"></a>六.C++</h2> 
<h3><a id="1_newdeletemallocfree_1226"></a>1. new、delete、malloc、free关系</h3> 
<pre><code class="prism language-c++">1.new分配空间的'同时可以初始化'， malloc分配空间时'不可以直接初始化'
2.new如果不初始化会'自动用0初始化'， malloc分配完就是'随机值'，需
要'memset'或者'bzero'清0
3.mallco/free 是'库函数'，new/delete 是C++的'关键字'
4.new分配空间时可以根据类型'自动计算空间大小'，而malloc需要'手动计算传参'
5.new '返回的就是'相应类型的指针，而malloc需要'强制类型转换'---返回的是
(void *)
6.new会调用'构造函数'，malloc不会
7.delete会调用'析构函数'，free不会
</code></pre> 
<h3><a id="2_delete_delete__1240"></a>2. delete与 delete []区别</h3> 
<pre><code class="prism language-c++">//方括号里 可以写空间的大小 也可以不写，不写就是 申请了多少 就被释放多少 

delete只会调用'一次''析构函数'，而delete[]会调用'每一个成员'的'析构'函数。
在More Effective C++中有更为详细的解释：“当delete操作符用于数组时，它为每个数组元素调用析构函数，然后调用operator delete来释放内存。”delete与new配套，delete []与new []配套

这就说明：对于内建简单数据类型，delete和delete[]功能是相同的。对于自定义的复杂数据类型，
delete和delete[]不能互用。delete[]删除一个数组，delete删除一个指针。
简单来说，
用new分配的内存用delete删除；
用new[]分配的内存用delete[]删除。
delete[]会调用数组元素的析构函数。内部数据类型没有析构函数，所以问题不大。如果你在用delete时没用括号，delete就会认为指向的是单个对象，否则，它就会认为指向的是一个数组。
</code></pre> 
<h3><a id="3_C_1256"></a>3. C++有哪些性质（面向对象特点）</h3> 
<pre><code class="prism language-c++">面向对象的三大特征 ： 封装 继承 多态 -----// 如果有四：加一个 抽象
</code></pre> 
<h3><a id="4__1262"></a>4. 子类析构时要调用父类的析构函数吗？</h3> 
<pre><code class="prism language-shell"><span class="token string">'析构函数'</span>调用的次序是先<span class="token string">'派生类'</span>的析构后<span class="token string">'基类的析构'</span>，
也就是说在<span class="token string">'基类'</span>的的<span class="token string">'析构调用'</span>的时候,派生类的信息已经全部销毁了。
<span class="token string">'定义'</span>一个对象时先调用<span class="token string">'基类的构造'</span>函数、然后<span class="token string">'调用派生类'</span>的<span class="token string">'构造'</span>函数；
析构的时候<span class="token string">'恰好相反'</span>：先调用<span class="token string">'派生类的析构'</span>函数、然后<span class="token string">'调用基类的析构'</span>函数。
</code></pre> 
<h3><a id="5__1271"></a>5. 多态，虚函数，纯虚函数</h3> 
<pre><code class="prism language-c++">多态：通过 父类的'指针或引用'指向 子类的对象，可以访问'子类中重写的父类中的方法'。
    实现多态的必要条件：
        1.继承 //---需要子类
        2.父类指针或引用指向子类对象 //---需要一个指针或引用
        3.虚函数 //---汇聚子类中 只有一份 公共基类的 成员
        4.函数重写 //---修改原来的函数
//-----------------------------------------------------------
虚函数：以关键字 virtual 开头的成员函数。 '声明'或'定义函数'前加上 virtual
   允许'在派生类'中对'基类的虚函数''重新定义'。

//-----------------------------------------------------------
纯虚函数：是一种在基类中只有声明，没有定义的函数
纯虚函数的作用：在'基类'中'为其'派生类'保留一个函数'的名字，以便'派生类''根据需要'对它进行'定义'。作为接口而存在 
'纯虚函数''不具备函数'的功能，一般'不能直接被调用'。

从'基类继承'来的'纯虚函数'，在'派生类'中'仍是虚函数'。
    
//---------------------------------------------------------- 
如果'一个类中'至少'有一个纯虚函数'，那么这个类被称为'抽象类'（abstract class）。

'抽象类'中不仅包括'纯虚函数'，也可包括'虚函数'。
抽象类'必须用作'派生其他类的'基类'    
包含'纯虚函数的类' 叫做 '抽象类'
抽象类'不允许'实例化对象，否则'报错'
子类中'必须重写抽象类的纯虚函数'，否则'报错'
抽象类虽然不能实例化对象，但可以通过抽象类的'指针或引用'指向子类的对象来'实现多
态'的特性
</code></pre> 
<h3><a id="6__1305"></a>6. 求下面函数的返回值（微软）----特么的题呢–</h3> 
<pre><code class="prism language-c++">int func(x)
{
    int countx = 0;
    while(x)
    {
        countx ++;
        x = x&amp;(x-1);
    }
    return countx;
}
</code></pre> 
<p>假定x = 9999。 答案：8</p> 
<pre><code class="prism language-c++">思路：将x转化为2进制，看含有的1的个数。
&amp; ： 0 与 任何数 &amp; 都等于 0				1 与 任何数 &amp; 都等于 任何数
由于每次都是 x 跟 x-1 进行 &amp; 运算，所以每次，都会弄没一个 1 ，所以只要看x的最开始的二进制有几个1 ，然后就会执行几次
9999先转换成二进制数，0010 0111 0000 1111  一共8 个，8次
</code></pre> 
<p>测试代码如下：</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">func</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> countx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
         countx <span class="token operator">++</span><span class="token punctuation">;</span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"x = %#x\n"</span><span class="token punctuation">,</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"x-1 = %#x\n"</span><span class="token punctuation">,</span>x<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
         x <span class="token operator">=</span> x<span class="token operator">&amp;</span><span class="token punctuation">(</span>x<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"后x = %#x\n"</span><span class="token punctuation">,</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"------------------------"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> countx<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">12287</span><span class="token punctuation">;</span><span class="token comment">// %#x == 2FFF, 有13个1</span>
	<span class="token keyword">int</span> o <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	o <span class="token operator">=</span> <span class="token function">func</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"OK------o = %d\n"</span><span class="token punctuation">,</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="7__1360"></a>7. 什么是“引用”？声明和使用“引用”要注意哪些问题？</h3> 
<pre><code class="prism language-c++">引用就是某个目标变量的"别名"(alias)，对应用的操作与对变量直接操作效果完全相同。
    
声明一个'引用'的时候，切记要对其进行'初始化'。
引用声明完毕后，'相当于''目标变量名'有'两个名称'，即该目标'原名称'和'引用名'，不能再把该引用名作为其他变量名的别名。
声明一个引用，'不是'新定义了一个变量，它只表示该'引用名'是目标变量名的一个'别名'，它本身不是一种数据类型，因此引用本身不占存储单元，系统也不给引用分配存储单元。不能建立数组的引用。
</code></pre> 
<h3><a id="78__1370"></a>7-8. 引用与指针的区别</h3> 
<pre><code class="prism language-c++">1. 引用必须'初始化' ,指针可以'不初始化'
2. '引用不可以改变指向' ,指针可以
3. '不存在指向NULL的引用', 指针可以指向NULL
4. '指针'在使用前需要'检查合法性' ，引用不需要
</code></pre> 
<h3><a id="8____1379"></a>8. 将“引用”作为 函数参数 有哪些特点？</h3> 
<pre><code class="prism language-c++">1.传递'引用'给函数 与 传递'指针'的'效果'是一样的。
这时，被调函数的'形参'就成为原来主调函数中的'实参变量'或'对象的'一个'别名'来使用，
所以在被调函数中对'形参变量的操作'就是对其'相应的目标对象'（在主调函数中）的操作。

2.使用'引用'传递函数的参数，在内存中并没有产生实参的副本，它是'直接对实参操作'；
  而使用'一般变量'传递函数的参数，当发生函数调用时，需要给'形参分配存储单元'，形参变量是实参变量的副本；
  如果传递的是'对象'，还将'调用拷贝构造'函数。因此，当参数传递的数据较大时，用'引用'比用一般'变量'传递参数的'效率和所占空间'都好。
  
3.使用'指针'作为函数的'参数'虽然也能达到与使用引用的效果，
但是，在被调函数中同样要给'形参分配存储单元'，且需要重复使用"*指针变量名"的形式进行运算，这很容易产生错误且程序的阅读性较差；
另一方面，在主调函数的调用点处，必须用变量的地址作为实参。而引用更容易使用，更清晰。
</code></pre> 
<h3><a id="9__1395"></a>9. 在什么时候需要使用“常引用”？</h3> 
<pre><code class="prism language-c++">如果既要利用'引用'提高程序的'效率'，又要'保护'传递给函数的'数据不'在函数中'被改变'，就'应使用'常引用。
//有些场景下，函数中 不想修改 形参的值,可以使用 常引用
常引用声明方式：const 类型标识符 &amp;引用名=目标变量名；
    int a ;
    const int &amp;ra=a;
    ra=1; //错误
    a=1; //正确
</code></pre> 
<h3><a id="10___1409"></a>10. 将“引用”作为函数返回值类型的格式、好处和需要遵守的规则?</h3> 
<pre><code class="prism language-c++">格式：类型标识符 &amp;函数名（形参列表及类型说明）
        {
            //函数体 
        }
    
好处：在'内存'中'不产生'被返回值的'副本'；
    （注意：正是因为这点原因，所以'返回一个局部变量的引用是不可取'的。因为随着该局部变量生存期的结束，相应的引用也会失效，产生runtime error!)
    
注意事项：
1. '不能返回局部变量的引用'。这条可以参照Effective C++[1]的Item 31。
    主要原因是'局部变量'会在'函数返回'后'被销毁'，因此被返回的'引用'就成为了"无所指"的引用，程序会进入未知状态。
    
2. '不能返回函数内部new分配的内存的引用'。这条可以参照Effective C++[1]的Item 31。
    虽然不存在局部变量的被动销毁问题，可对于这种情况（返回函数内部new分配内存的引用），又面临其它尴尬局面。
    例如，被函数返回的'引用'只是作为一个'临时变量'出现，而没有被赋予一个实际的变量，那么这个引用所指向的空间（由new分配）就'无法释放'，造成memory leak(内存泄漏)。
    
3. '可以返回类成员的引用'，但最好是'const'。这条原则可以参照Effective C++[1]的Item 30。
    主要原因是当'对象的属性'是与某种业务规则（business rule）相关联的时候，其赋值 常常与 某些其它属性或者对象的状态有关，因此有必要将赋值操作封装在一个业务规则当中。
    如果其它对象可以获得该属性的'非常量引用（或指针）'，那么对该属性的单纯赋值就会破坏业务规则的完整性。
    
4. '流操作符重载返回值'声明为"引用"的作用：
    
	流操作符&lt;&lt;(打印)和&gt;&gt;(提取)，这两个操作符常常希望被连续使用，
    	例如：cout &lt;&lt; "hello" &lt;&lt; endl; 
	因此这两个操作符的'返回值'应该是一个仍然支持这两个操作符的流引用。
    可选的其它方案包括：返回一个流对象和返回一个流对象指针。
    但是对于返回一个'流对象'，程序必须重新（拷贝）构造一个新的流对象，也就是说，连续的两个&lt;&lt;操作符实际上是针对不同对象的！这无法让人接受。
    对于返回一个'流指针'则不能连续使用&lt;&lt;操作符。
    
    因此，返回一个'流对象引用'是唯一选择。这个唯一选择很关键，它说明了'引用的重要性'以及'无可替代'性。---- '返回的自身的引用'
        
	赋值操作符=。这个操作符象流操作符一样，是可以连续使用的，
        例如：x = j = 10;或者(x=10)=100;
	赋值操作符的返回值必须是一个左值，以便可以被继续赋值。因此引用成了这个操作符的惟一返回值选择。
        
＃include&lt;iostream.h&gt;
int &amp;put(int n);
int vals[10];
int error=-1;
void main()
{
put(0)=10; //以put(0)函数值作为左值，等价于vals[0]=10;
put(9)=20; //以put(9)函数值作为左值，等价于vals[9]=20;
cout&lt;&lt;vals[0];
cout&lt;&lt;vals[9];
}
int &amp;put(int n)
{
if (n&gt;=0 &amp;&amp; n&lt;=9 ) return vals[n];
else { cout&lt;&lt;"subscript error"; return error; }
}

5. 在另外的一些操作符中，却千万不能返回引用：
    +-*/ 四则运算符。它们不能返回引用，Effective C++[1]的Item23详细的讨论了这个问题。
    主要原因是这四个操作符没有side effect，因此，它们必须构造一个对象作为返回值，
    可选的方案包括：返回一个对象、返回一个局部变量的引用，返回一个new分配的对象的引用、返回一个静态对象引用。
    根据前面提到的引用作为返回值的三个规则，2、3两个方案都被否决了。
    静态对象的引用又因为((a+b) == (c+d))会永远为true而导致错误。
    所以可选的只剩下返回一个对象了。
</code></pre> 
<h3><a id="11__C_1475"></a>11. 结构与联合有和区别？—C基础第四题</h3> 
<h3><a id="12___1477"></a>12. 试写出程序结果：</h3> 
<pre><code class="prism language--c++">int a=4;
int &amp;f(int x)
{
    a=a+x;
    return a;
}
int main(void)
{
    int t=5;
    cout&lt;&lt;f(t)&lt;&lt;endl;// a = 9
    f(t)=20; //a = 20
    cout&lt;&lt;f(t)&lt;&lt;endl;// t = 5,a = 20 a = 25
    t=f(t); //a = 30 t = 30
    cout&lt;&lt;f(t)&lt;&lt;endl; }// t = 60
}
//t = 60
</code></pre> 
<h3><a id="13_overloadoverried_1498"></a>13. 重载（overload)和重写(overried，有的书也叫做“覆盖”）的区别？</h3> 
<pre><code>从定义上来说：
重载：是指允许存在多个同名函数，而这些函数的参数表不同（或许参数个数不同，或许参数类型不
同，或许两者都不同）。
重写：是指子类重新定义父类虚函数的方法。
从实现原理上来说：
重载：编译器根据函数不同的参数表，对同名函数的名称做修饰，然后这些同名函数就成了不同的函数
（至少对于编译器来说是这样的）。如，有两个同名函数：function func(p:integer):integer;和
function func(p:string):integer;。那么编译器做过修饰后的函数名称可能是这样的：int_func、
str_func。对于这两个函数的调用，在编译器间就已经确定了，是静态的。也就是说，它们的地址在编
译期就绑定了（早绑定），因此，重载和多态无关！
重写：和多态真正相关。当子类重新定义了父类的虚函数后，父类指针根据赋给它的不同的子类指针，
动态的调用属于子类的该函数，这样的函数调用在编译期间是无法确定的（调用的子类的虚函数的地址
无法给出）。因此，这样的函数地址是在运行期绑定的（晚绑定）。
</code></pre> 
<h3><a id="14_intialization_list_assignment_1516"></a>14. 有哪几种情况只能用intialization list(初始化列表) 而不能用assignment?</h3> 
<pre><code class="prism language-c++">必须使用初始化表的场景
1. '成员变量名字'和'构造函数形参名字'冲突时；---也可以用this解决
2.类中包含' const '成员变量时 //因为 const 只能在初始化的时候赋值
3.类中包含' 引用' 成员变量 //引用 只能先指向 再操作
4.类中包含'成员子对象'(类中包含其他类对象时)时
//必须使用初始化表调用子对象的构造函数 完成对成员子对象的初始化  
  //构造函数 才有初始化 表
</code></pre> 
<h3><a id="15_C_1528"></a>15. C++是不是类型安全的？</h3> 
<pre><code>不是。两个不同类型的指针之间可以强制转换（用reinterpret cast)。C#是类型安全的

</code></pre> 
<h3><a id="16_main__1535"></a>16. main 函数执行以前，还会执行什么代码？</h3> 
<pre><code>全局对象的构造函数会在main 函数之前执行。
</code></pre> 
<h3><a id="17__1541"></a>17. 描述内存分配方式以及它们的区别?</h3> 
<pre><code>1） 从静态存储区域分配。内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。例如全局变量，static 变量。

2） 在栈上创建。在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集。

3） 从堆上分配，亦称动态内存分配。程序在运行的时候用malloc 或new 申请任意多少的内存，程序员自己负责在何时用free 或delete 释放内存。动态内存的生存期由程序员决定，使用非常灵活，但问题也最多。
</code></pre> 
<h3><a id="18_BOOLintfloata__1553"></a>18. 分别写出BOOL,int,float,指针类型的变量a 与“零”的比较语句。</h3> 
<pre><code>BOOL : if ( !a ) or if(a)
int : if ( a == 0)
float : const EXPRESSION EXP = 0.000001
if ( a &lt; EXP &amp;&amp; a &gt;-EXP)
pointer : if ( a != NULL) or if(a == NULL)
</code></pre> 
<h3><a id="19_constdefine_C11_1565"></a>19. 请说出const与#define 相比，有何优点？–C基础-11题</h3> 
<h3><a id="20_C12_1567"></a>20. 简述数组与指针的区别？–C基础-12题</h3> 
<h3><a id="21_int_s10int__1569"></a>21. int (*s[10])(int) 表示的是什么？</h3> 
<pre><code>函数指针数组，每个指针指向一个int func(int param)的函数
回调函数
</code></pre> 
<h3><a id="22__1576"></a>22. 栈内存与文字常量区</h3> 
<pre><code>char str1[] = "abc";
char str2[] = "abc";
const char str3[] = "abc";
const char str4[] = "abc";
const char *str5 = "abc";
const char *str6 = "abc";
char *str7 = "abc";
char *str8 = "abc";
cout &lt;&lt; ( str1 == str2 ) &lt;&lt; endl;//0 分别指向各自的栈内存
cout &lt;&lt; ( str3 == str4 ) &lt;&lt; endl;//0 分别指向各自的栈内存
cout &lt;&lt; ( str5 == str6 ) &lt;&lt; endl;//1指向文字常量区地址相同
cout &lt;&lt; ( str7 == str8 ) &lt;&lt; endl;//1指向文字常量区地址相同
结果是：0 0 1 1
解答：str1,str2,str3,str4是数组变量，它们有各自的内存空间；而str5,str6,str7,str8是指针，它们指向
相同的常量区域。
</code></pre> 
<h3><a id="23__1596"></a>23. 将程序跳转到指定内存地址</h3> 
<pre><code>要对绝对地址0x100000赋值，我们可以用(unsigned int*)0x100000 = 1234;那么要是想让程序跳转到绝对地址是0x100000去执行，应该怎么做？

((void ()( ))0x100000 ) ( );
首先要将0x100000强制转换成函数指针,
即:(void (*)())0x100000
然后再调用它:
((void ()())0x100000)();
用typedef可以看得更直观些:
typedef void(*)() voidFuncPtr;
*((voidFuncPtr)0x100000)();
</code></pre> 
<h3><a id="24_int_idsizeofunsigned_long_1611"></a>24. int id[sizeof(unsigned long)];这个对吗？为什么？</h3> 
<pre><code>正确 这个 sizeof是编译时运算，编译时就确定了 ,可以看成和机器有关的常量。
</code></pre> 
<h3><a id="27__17_1617"></a>27. 内存的分配方式有几种?—上面 17</h3> 
<h3><a id="28__1619"></a>28. 基类的析构函数不是虚函数，会带来什么问题？</h3> 
<pre><code class="prism language-c">#虚析构函数的作用：
用来指引delete关键字，正确回收空间。
  <span class="token operator">--</span><span class="token operator">-</span> 因为正常的析构函数 只能调用 父类 的析构
  <span class="token comment">//基类指针指向子类对象时，如果析构函数不是虚函数</span>
  <span class="token comment">//那么只会调用 基类的析构函数，不调用子类的，所以可能会造成内存泄露</span>
  <span class="token comment">//如果基类的 析构函数是 虚函数</span>
  <span class="token comment">//则会调用 子类的析构函数，子类的析构函数 会默认 调用基类的析构函数，不会内存泄漏</span>
</code></pre> 
<h3><a id="29__1633"></a>29. 全局变量和局部变量有什么区别？是怎么实现的？操作系统和编译器是怎么知道的？</h3> 
<pre><code class="prism language-c++">生命周期不同：
全局变量随主程序创建和创建，随主程序销毁而销毁；
局部变量在局部函数内部，甚至局部循环体等内部存在，退出就不存在；

使用方式不同：
通过声明后全局变量程序的各个部分都可以用到；局部变量只能在局部使用；分配在栈区。

操作系统和编译器通过'内存分配的位置'来知道的，
'全局变量'分配在'全局数据段'并且在程序开始运行的时候被加载。
'局部变量'则分配在'栈'里面 。
</code></pre> 
<h2><a id="_ARM_1652"></a>七. ARM体系结构编程</h2> 
<h3><a id="1_ARM5_1654"></a>1. 简单描述一下ARM处理器的特点，至少说出5个以上的特点。</h3> 
<pre><code>低功耗；
低成本，高性能，RISC结构；
体积小；
指令定长；
支持Thumb（16位）/ARM（32位）双指令集；
</code></pre> 
<h3><a id="2_ARMcortex_a_1666"></a>2. ARM内核有多少种工作模式？请写出这些工作模式的英文缩写，有几种异常模式，有几种特权模式，cortex_a系列有几种特权模式，几种工作模式</h3> 
<pre><code class="prism language-shell">	<span class="token operator">|</span>--<span class="token operator">&gt;</span> 特权模式 <span class="token operator">|</span>---<span class="token operator">&gt;</span> 异常模式  <span class="token operator">|</span> --<span class="token operator">&gt;</span> FIQ模式<span class="token punctuation">(</span>快速中断<span class="token punctuation">)</span>
	<span class="token operator">|</span> 		     <span class="token operator">|</span>			  <span class="token operator">|</span> --<span class="token operator">&gt;</span> IRQ模式<span class="token punctuation">(</span>普通中断<span class="token punctuation">)</span>
	<span class="token operator">|</span>			<span class="token operator">|</span>			  <span class="token operator">|</span> --<span class="token operator">&gt;</span> SVC模式<span class="token punctuation">(</span>特权模式<span class="token punctuation">)</span>
工作 <span class="token operator">|</span>		   <span class="token operator">|</span>			 <span class="token operator">|</span> --<span class="token operator">&gt;</span> Abort模式<span class="token punctuation">(</span>中止异常模式<span class="token punctuation">)</span>
模式 <span class="token operator">|</span>		   <span class="token operator">|</span>			 <span class="token operator">|</span> --<span class="token operator">&gt;</span> Undef模式<span class="token punctuation">(</span>未定义的异常模式<span class="token punctuation">)</span>
	<span class="token operator">|</span>			<span class="token operator">|</span>              <span class="token operator">|</span> --<span class="token operator">&gt;</span> Monitor模式<span class="token punctuation">(</span>安全监控模式<span class="token punctuation">)</span>
	<span class="token operator">|</span>			<span class="token operator">|</span>---<span class="token operator">&gt;</span> 非异常模式---<span class="token operator">&gt;</span> System模式<span class="token punctuation">(</span>User模式下的一种特权模式<span class="token punctuation">)</span>
	<span class="token operator">|</span>			
	<span class="token operator">|</span>--<span class="token operator">&gt;</span> 非特权模式  --<span class="token operator">&gt;</span> User模式
	
</code></pre> 
<h3><a id="3_ARM_1683"></a>3. ARM内核有多少个寄存器，简述一下</h3> 
<pre><code>ARM有37个寄存器，
（1）未分组寄存器：R0-R7，共8个；
（2）分组寄存器R8-R14，其中FIQ模式下有单独的一组R8-R12共5个，另外6种模式共用一组R8-R12，共5个，
（3）程序计数器PC即R15寄存器，共1个；
（4）状态寄存器CPSR，和5个备份状态寄存器SPSR，共6个
</code></pre> 
<p><img src="https://images2.imgbox.com/5e/21/OtwygZZb_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="4_ARM3_1696"></a>4. ARM通用寄存器中，有3个寄存器有特殊功能和作用，请写出它们的名字和作用。</h3> 
<pre><code class="prism language-c">R13：SP栈指针寄存器，用来保存程序<span class="token string">'执行时的栈指针位置'</span>；
R14：LR返回链接寄存器，用来保存程序执行<span class="token string">'BL指令'</span>或<span class="token string">'模式切换时'</span>的<span class="token string">'返回'</span>原程序<span class="token string">'继续执行的地址'</span>；
R15：PC程序计数器，指向<span class="token string">'正在取指的指令的地址'</span>
</code></pre> 
<h3><a id="5_CPSRBit_1704"></a>5. 请描述一下CPSR寄存器中相关Bit的情况和作用。</h3> 
<p><img src="https://images2.imgbox.com/c8/d5/VJrAueR9_o.png" alt="在这里插入图片描述"></p> 
<pre><code>条件位（指令进行算术运算后的结果是否有进位，借位等），
I位（IRQ异常允许位），
F位（FIQ异常允许位），
T位（ARM/Thumb工作状态），
模式位（处理器工作模式）
</code></pre> 
<pre><code class="prism language-c">N<span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">]</span> <span class="token operator">:</span> 指令的<span class="token string">'运算结果为负数'</span>，N位被自动<span class="token string">'置1'</span>，否则清<span class="token number">0.</span>

Z<span class="token punctuation">[</span><span class="token number">30</span><span class="token punctuation">]</span> <span class="token operator">:</span> 指令的<span class="token string">'运算结果为零'</span>，Z位被自动<span class="token string">'置1'</span>，否则清<span class="token number">0.</span>

C<span class="token punctuation">[</span><span class="token number">29</span><span class="token punctuation">]</span> <span class="token operator">:</span> 
	<span class="token string">'加法'</span>：产生<span class="token string">'进位'</span>，C位被自动<span class="token string">'置1'</span>，否则清<span class="token number">0.</span>
	<span class="token string">'减法'</span>：产生<span class="token string">'借位'</span>，C位被自动<span class="token string">'清0'</span>，否则置<span class="token number">1.</span>
	进位<span class="token operator">/</span>借位：<span class="token string">'低32位'</span>向<span class="token string">'高32位'</span> 进位或者借位。

	两个<span class="token number">64</span>位数相加，需要拆分成两个<span class="token number">32</span>位数进行加法运算，先算低<span class="token number">32</span>位，再算高<span class="token number">32</span>位，在进行高<span class="token number">32</span>位运算时需要考虑低<span class="token number">32</span>位是否有进位。

V<span class="token punctuation">[</span><span class="token number">28</span><span class="token punctuation">]</span> <span class="token operator">:</span> <span class="token string">'符号位'</span>发生变化，V位被自动<span class="token string">'置1'</span>，否则清<span class="token number">0.</span>

I<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span> <span class="token operator">:</span> IRQ屏蔽位
	I <span class="token operator">=</span> <span class="token number">0</span>   不屏蔽IRQ中断
	I <span class="token operator">=</span> <span class="token number">1</span>   屏蔽IRQ中断

F<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span> <span class="token operator">:</span> FIQ屏蔽位
	F <span class="token operator">=</span> <span class="token number">0</span>   不屏蔽FIQ中断
	F <span class="token operator">=</span> <span class="token number">1</span>   屏蔽FIQ中断

T<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">:</span> 状态位 
	T <span class="token operator">=</span> <span class="token number">0</span> ： ARM状态 <span class="token operator">--</span>》执行ARM指令集
	T <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">:</span>   Thumb状态 <span class="token operator">--</span><span class="token operator">-</span>》执行Thumb指令集ARM指令集和Thumb指令集区别
		ARM指令集： 每条指令占<span class="token number">4</span>个字节的空间
		Thumb指令集：每条指令占<span class="token number">2</span>个字节的空间
	<span class="token macro property"><span class="token directive-hash">#</span><span class="token expression">ARM指令集的功能性比Thumb指令集的功能更加完善。Thumb指令集的指令的密度要比ARM指令集高。</span></span>

M<span class="token punctuation">[</span><span class="token number">4</span><span class="token operator">:</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">:</span> 模式位
	<span class="token number">10000</span>  User mode<span class="token punctuation">;</span>    
	<span class="token number">10001</span>  FIQ mode<span class="token punctuation">;</span>         
	<span class="token number">10011</span>  SVC mode<span class="token punctuation">;</span>
	<span class="token number">10111</span>  Abort mode<span class="token punctuation">;</span>  
	<span class="token number">11011</span>  Undfined mode<span class="token punctuation">;</span>  
	<span class="token number">11111</span>  System mode<span class="token punctuation">;</span>     
	<span class="token number">10110</span>  Monitor mode<span class="token punctuation">;</span>   
	<span class="token number">10010</span>  IRQ

	#其他的保留
</code></pre> 
<h3><a id="6__1759"></a>6. 什么是立即数？立即数的本质是什么</h3> 
<pre><code>然后将这个数，循环 右移偶数 位，如果 可以得到 要判断的那个数，说明这个数 是一个立即数。
立即数的本质 包含在指令中的数
</code></pre> 
<h3><a id="7_BLLR_1766"></a>7. 请问BL指令跳转时LR寄存器保存的是什么内容？并请简述原因</h3> 
<pre><code class="prism language-c">LR中保存的是执行完<span class="token string">'BL跳转指令的下一条指令'</span>的地址。LR用来在<span class="token string">'需要返回程序'</span>时从LR中<span class="token string">'还原程序执行的位置'</span>继续执行。<span class="token punctuation">(</span>保存现场<span class="token operator">--</span>恢复现场<span class="token punctuation">)</span>
</code></pre> 
<h3><a id="8__1772"></a>8. 请描述一下什么是处理器现场，如何进行保存现场？</h3> 
<pre><code class="prism language-shell">每种工作模式下都包含R0-R15，CPSR这17个寄存器，程序的执行当前状态就保存在这些寄存器中，称为处理器现场。

当发生<span class="token string">'模式切换'</span>时，由于其中的一些寄存器是多种模式下<span class="token string">'共用的寄存器'</span>，为了<span class="token string">'防止共用'</span>处理器寄存器中的<span class="token string">'值被破坏'</span>，所以需要<span class="token string">'保存'</span>原模式下的<span class="token string">'处理器现场'</span>，
利用STM批量存储指令，把处理器现场对应的寄存器保存到栈上，待还原时再出栈恢复（模式和返回地址）。
其中保存现场的工作， 硬件完成了<span class="token string">'CPSR模式的保存'</span>和<span class="token string">'PC返回地址的保存'</span>，其他寄存器的保存工作主要依靠软件压栈完成，其中<span class="token string">'LR'</span>因为<span class="token string">'可能被异常处理程序中'</span>的BL跳转指令<span class="token string">'修改'</span>，所以一般都需要<span class="token string">'软件压栈'</span>再保存。
</code></pre> 
<h3><a id="9_ATPCSARM_1782"></a>9. ATPCS默认使用的是什么栈？–满减栈（ARM也是）</h3> 
<h3><a id="10__1784"></a>10. 什么是满栈、空栈，什么是增栈、减栈？</h3> 
<pre><code>栈的种类： (sp)
	空栈：栈指针指向的栈空间没有有效的数据，
		压栈时可以直接将数据压入栈空间中，
		需要再次将栈指针指向一个空的空间。
	满栈：栈指针指向的栈空间有有效的数据，
		压栈时需要先移动栈指针指向一个空的栈空间，
		在压入数据，此时栈指针指向的仍然是一个有有效数据的栈空间。
	增栈：压栈时栈指针向高地址方向移动，
		出栈时栈指针向低地址方向移动。
	减栈：压栈时栈指针向低地址方向移动，
		出栈时栈指针向高地址方向移动

</code></pre> 
<h3><a id="11_ARM_1803"></a>11. 请写出一条完整的ARM软件中断指令，并简要描述其作用。</h3> 
<pre><code>SWI 0x1。
SWI指令触发'软中断异常'，使程序的执行流跳转到异常向量表地址0x8，0x1是软中断的中断号，
软中断处理程序可根据不同的中断号调用对应的处理子程序。一般SWI软中断都用于操作系统的系统调用。
</code></pre> 
<h3><a id="12_ARM_1813"></a>12. 请描述一下ARM体系中异常向量表的概念。</h3> 
<pre><code>异常向量表是从0x0地址开始，一共32个字节，包含8个表项，其中有1个保留不用，其他7个表项对应7种异常发生后的跳转位置，
这7种异常发生后分别对应到5种异常模式。每个表项里面放的一般都是一条跳转指令，
用来跳转到真正的异常处理程序入口，通过BL指令，或者LDR PC，[PC, #?] 的方式都可以实现此类跳转。
</code></pre> 
<h3><a id="13_ARMbin_1823"></a>13. 请写出一个ARM程序生成的bin文件映像中包含哪些内容？</h3> 
<pre><code>ARM生成的bin文件包含：RO,RW 两个段，注意 ZI 段一般都不在 bin 文件中占用存储空间。
</code></pre> 
<h3><a id="14_ARM_1831"></a>14. 请举例说明在ARM处理器上进行一次中断处理和中断异常处理的差异。</h3> 
<pre><code>中断处理相比异常处理，主要是中断需要初始化中断源和中断控制器，中断发生后在ＩＳＲ中要清除相
应Pending位，而且要在进入中断处理程序一开始就清除。
</code></pre> 
<h3><a id="15__1840"></a>15. 请简述异常中断处理发生时，是通过什么完成初始化步骤，这些初始化的具体步骤是什么？</h3> 
<pre><code>当发生异常中断时，有ARM CORE完成一下工作，称作4大步三小步
1）拷贝CPSR到SPSR_mode
2）设置CPSR的位
        修改处理器状态进入ARM态
        修改处理器模式为相应的异常模式
        禁止相应的中断（根据需要禁止FIQ或者IRQ）
3）保存返回地址到LR_MODE
4）设置PC位相应的异常向量
</code></pre> 
<h3><a id="16_uboot_1855"></a>16. uboot的主要作用</h3> 
<pre><code class="prism language-shell">uboot 属于bootloader的一种<span class="token string">'引导程序'</span>，是用来引导启动内核的
初始化大部分的硬件，为内核运行提供基础，
给内核传递参数


uboot主要做了两个阶段的事：
第一个阶段：汇编
    构建<span class="token string">'异常向量表'</span>
    禁止<span class="token string">'mmu'</span>和<span class="token string">'cache'</span>，禁止<span class="token string">'看门狗'</span>
    硬件时钟的<span class="token string">'初始化'</span>，<span class="token string">'内存'</span>的<span class="token string">'初始化'</span>
    清除<span class="token string">'bss'</span>段	<span class="token comment">#bss段是用来存储静态变量，全局变量的</span>
    完成uboot代码的自搬移
    <span class="token string">'初始化C代码'</span>运行的<span class="token string">'栈空间'</span>
    
第二个阶段：C
    完成<span class="token string">'大部分硬件'</span>的<span class="token string">'初始化'</span>，<span class="token string">'串口'</span>的初始化，<span class="token string">'内存'</span>的进一步的初始化，<span class="token string">'电源的'</span>初始化 等等必要<span class="token string">'硬件的'</span>初始化
    根据命令是否进入<span class="token string">'交互模式'</span>还<span class="token string">'自启动模式'</span>
    获取uboot的<span class="token string">'环境变量'</span>，
    执行<span class="token string">'bootcmd中的命令'</span>，
    最终<span class="token string">'给内核传递参数'</span>（bootargs）
</code></pre> 
<h3><a id="17_uboot_1880"></a>17. uboot是怎样引导启动内核的？</h3> 
<pre><code class="prism language-c">uboot刚开始被放到flash中，
板子上电后，会自动把<span class="token string">'其中的一部分代码'</span>拷到<span class="token string">'内存'</span>中执行，
这部分代码负责把<span class="token string">'剩余的uboot代码'</span>拷到<span class="token string">'内存'</span>中，
然后<span class="token string">'uboot代码'</span>再把<span class="token string">'kernel部分代码'</span>也拷到<span class="token string">'内存'</span>中，
并且启动，内核启动后，
挂载根文件系统，执行应用程序。
</code></pre> 
<h3><a id="18_uboot_1893"></a>18. uboot的启动过程的重要干了什么</h3> 
<pre><code class="prism language-shell">uboot启动主要分为两个阶段，
主要在start.s文件中，第一阶段主要做的是硬件的初始化，
包括，设置<span class="token string">'处理器模式'</span>为<span class="token string">'SVC模式'</span>，<span class="token string">'关闭看门狗'</span>，<span class="token string">'屏蔽中断'</span>，<span class="token string">'初始化sdram'</span>，<span class="token string">'设置栈'</span>，<span class="token string">'设置时钟'</span>，从<span class="token string">'flash拷贝代码'</span>到<span class="token string">'内存'</span>，<span class="token string">'清除bss段'</span>等，bss段是用来存储静态变量，全局变量的，
然后程序跳转到start_arm_boot函数，宣告第一阶段的结束。

第二阶段比较复杂，
做的工作主要是：
<span class="token number">1</span>.从flash中读出内核。
<span class="token number">2</span>.启动内核。
start_arm_boot的主要流程为，
设置机器id，
初始化flash，
然后进入main_loop，
等待uboot命令，
uboot要启动内核，主要经过<span class="token string">'两个函数'</span>，
第一个是<span class="token string">'s=getenv("bootcmd"）'</span>，
第二个是<span class="token string">'run_command(s...)'</span>,
所以要启动内核，需要根据<span class="token string">'bootcmd环境变量'</span>的内容启动，bootcmd环境变量一般指示了从<span class="token string">'某个flash地址'</span>读取内核到启动的内存地址，然后启动，bootm。
uboot启动的内核为uImage,这种格式的内核是由<span class="token string">'两部分'</span>组成：<span class="token string">'真正的内核'</span>和<span class="token string">'内核头部'</span>组成，
<span class="token string">'头部'</span>中包括内核中的一些信息，比如<span class="token string">'内核的加载地址'</span>，<span class="token string">'入口地址'</span>。

uboot在接受到启动命令后，要做的主要是，
<span class="token number">1</span>，<span class="token string">'读取'</span>内核头部，
<span class="token number">2</span>，<span class="token string">'移动'</span>内核到合适的加载地址，
<span class="token number">3</span>，启动内核，执行do_bootm_linux
	do_bootm_linux主要做的为，
	<span class="token number">1</span>，设置启动参数，在特定的地址，保存启动参数，函数分别为
        setup_start_tag,
        setup_memory_tag,
        setup_commandline_tag,
        setup_end_tag，
	根据名字我们就知道具体的段内存储的信息，
        memory中为板子的<span class="token string">'内存大小信息'</span>，
        commandline为命令行信息，

    <span class="token number">2</span>，跳到入口地址，启动内核
    	启动的函数为
    		the_kernel<span class="token punctuation">(</span><span class="token number">0</span>,bd-<span class="token operator">&gt;</span>bi_arch_number,bd-<span class="token operator">&gt;</span>bi_boot_param<span class="token punctuation">)</span>
        		bd-<span class="token operator">&gt;</span>bi_arch_number为板子的机器码，
		        bd-<span class="token operator">&gt;</span>bi_boot_param为启动参数的地址
</code></pre> 
<h3><a id="19_bootcmdbootargsuboot_1940"></a>19. bootcmd和bootargs两个uboot环境变量的作用</h3> 
<pre><code class="prism language-c">bootcmd：<span class="token operator">&lt;</span>设置开发板的<span class="token string">'自启动的环境变量'</span><span class="token operator">&gt;</span>
	这个参数包含了一些命令，这些命令将在倒计时结束后，进入u<span class="token operator">-</span>boot自启动模式后执行
setenv bootcmd tftp c2000000 uImage \<span class="token punctuation">;</span> tftp c4000000 stm32mp157a<span class="token operator">-</span>fsmp1a<span class="token punctuation">.</span>dtb \<span class="token punctuation">;</span> bootm c2000000 <span class="token operator">-</span> c4000000

<span class="token comment">//-------------------------------------------------------------------------------</span>

bootargs：这个参数设置要<span class="token string">'传递给内核的信息'</span>，主要用来告诉<span class="token string">'内核分区信息'</span>和<span class="token string">'根文件系统'</span>所在的分区
setenv bootargs  root<span class="token operator">=</span><span class="token operator">/</span>dev<span class="token operator">/</span>nfs nfsroot<span class="token operator">=</span><span class="token number">192.168</span><span class="token number">.1</span><span class="token number">.250</span><span class="token operator">:</span><span class="token operator">/</span>home<span class="token operator">/</span>linux<span class="token operator">/</span>nfs<span class="token operator">/</span>rootfs<span class="token punctuation">,</span>tcp<span class="token punctuation">,</span>v4 rw console<span class="token operator">=</span>ttySTM0<span class="token punctuation">,</span><span class="token number">115200</span> init<span class="token operator">=</span><span class="token operator">/</span>linuxrc ip<span class="token operator">=</span><span class="token number">192.168</span><span class="token number">.1</span><span class="token number">.222</span>
</code></pre> 
<h3><a id="20_linux_1955"></a>20. linux内核的启动过程</h3> 
<pre><code class="prism language-c">内核启动过程中主要干了那些事？
    <span class="token number">1</span><span class="token operator">&gt;</span> uboot通过<span class="token string">'tftp命令'</span>将<span class="token string">'uImage下载'</span>到内存中<span class="token punctuation">(</span>下载内核<span class="token punctuation">)</span>
    <span class="token number">2</span><span class="token operator">&gt;</span> <span class="token string">'uImage'</span>需要完成<span class="token string">'自解压'</span>
    <span class="token number">3</span><span class="token operator">&gt;</span> 获取cpu的ID号，创建页表，初始化MMU，完成物理地址到虚拟地址的映射
    <span class="token number">4</span><span class="token operator">&gt;</span> <span class="token string">'清除BSS段'</span><span class="token punctuation">,</span>bss段是用来存储静态变量，全局变量的
    <span class="token number">5</span><span class="token operator">&gt;</span> 完成绝<span class="token string">'大多数硬件'</span>的<span class="token string">'初始化'</span>，进一步对硬件初始化<span class="token operator">&lt;</span> 内存，时钟，串口，EMMC，nfs客户端<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&gt;</span>
    <span class="token number">5</span><span class="token operator">&gt;</span> 从<span class="token string">'u-boot环境变量'</span>的内存分区<span class="token string">'获取bootargs参数'</span>，<span class="token string">'根据'</span>bootargs<span class="token string">'参数'</span>，决定从哪里<span class="token string">'挂载根文件系统'</span>。
    <span class="token number">6</span><span class="token operator">&gt;</span> <span class="token string">'挂载'</span>根文件系统
    <span class="token number">7</span><span class="token operator">&gt;</span> 执行根文件系统中的<span class="token string">'1号进程'</span>，<span class="token string">'linuxrc'</span>程序
    <span class="token number">8</span><span class="token operator">&gt;</span> 到此开发板的linux系统启动成功
</code></pre> 
<p><img src="https://images2.imgbox.com/69/70/IAVuBNP9_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="21_uImagezImagevmlinux_1973"></a>21. uImage，zImage，vmlinux的区别</h3> 
<pre><code class="prism language-shell">内核编译（make）之后会生成两个文件，
一个<span class="token string">'Image'</span>，一个<span class="token string">'zImage'</span>，
其中<span class="token string">'Image'</span>为<span class="token string">'内核映像'</span>文件，
而<span class="token string">'zImage'</span>为<span class="token string">'内核'</span>的一种<span class="token string">'映像压缩文件'</span>，
<span class="token string">'Image'</span>大约为4M，
而<span class="token string">'zImage'</span>不到2M。----因为压缩了

那么uImage又是什么的？----zImage 加了个头 
它是<span class="token string">'uboot专用'</span>的<span class="token string">'映像'</span>文件，它是在<span class="token string">'zImage'</span>之前<span class="token string">'加上'</span>一个长度为<span class="token string">'64字节'</span>的<span class="token string">'头'</span>，
	说明这个<span class="token string">'内核的版本'</span>、<span class="token string">'加载位置'</span>、<span class="token string">'生成时间'</span>、<span class="token string">'大小'</span>等信息；其<span class="token string">'0x40'</span>之后与<span class="token string">'zImage没区别'</span>。 

如何生成uImage文件？
首先在uboot的/tools目录下寻找<span class="token string">'mkimage'</span>文件，把其copy到系统<span class="token string">'/usr/local/bin'</span>目录下，这样就完成制作工具。
然后在内核目录下运行<span class="token string">'make uImage'</span>，
如果成功，便可以在<span class="token string">'arch/arm/boot/'</span>目录下发现<span class="token string">'uImage'</span>文件，其大小比zImage多<span class="token string">'64个字节'</span>。

其实就是一个自动跟手动的区别,
<span class="token string">'有了'</span>uImage<span class="token string">'头部的描述'</span>,u-boot就知道对应Image的信息,
如果<span class="token string">'没有头部'</span>则需要自己<span class="token string">'手动去添加那些参数'</span>。

<span class="token comment">#U-boot的U是“通用”的意思。</span>
</code></pre> 
<h3><a id="22_KconfigconfigMakefile_2001"></a>22. Kconfig,.config,Makefile三个文件之间的关系</h3> 
<pre><code class="prism language-shell">编译内核文件时，先要配置.config文件（make menuconfig 	--<span class="token operator">&gt;</span> 选择需要的驱动 ），
然后Makefile在编译时通过<span class="token string">'读取.config文件'</span>的<span class="token string">'配置信息'</span>来选择要编译的文件，选择驱动的加载方式。
.config文件的生成可通过	<span class="token function">make</span> menuconfig <span class="token assign-left variable">ARCH</span><span class="token operator">=</span>arm	或	<span class="token function">make</span> defconfig 方式生成，
这两种方式看上去虽然不同，但是两者的原理是一样的，都是通过Kconfig文件的配置来的。
</code></pre> 
<h2><a id="__2013"></a>八. 系统移植</h2> 
<h3><a id="1_Linux_20_2015"></a>1. Linux内核启动流程—同上 七.20</h3> 
<pre><code class="prism language-c"><span class="token number">1.</span> Linux内核<span class="token string">'自解压过程'</span>
uboot完成系统引导以后，执行环境变量bootm中的命令；
即，将Linux内核调入内存中并调用do_bootm函数启动内核，跳转至kernel的起始位置。如果内核没有被压缩，则直接启动；如果内核被压缩过，则需要进行解压，被压缩过的kernel头部有解压程序。

压缩过的kernel入口第一个文件源码位置在<span class="token operator">/</span>kernel<span class="token operator">/</span>arch<span class="token operator">/</span>arm<span class="token operator">/</span>boot<span class="token operator">/</span>compressed<span class="token operator">/</span>head<span class="token punctuation">.</span>S。它
将调用<span class="token function">decompress_kernel</span><span class="token punctuation">(</span><span class="token punctuation">)</span>函数进行解压，
解压完成后，打印出信息“UncompressingLinux<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>done<span class="token punctuation">,</span>booting the kernel”。
解压缩完成后，调用<span class="token function">gunzip</span><span class="token punctuation">(</span><span class="token punctuation">)</span>函数（或<span class="token function">unlz4</span><span class="token punctuation">(</span><span class="token punctuation">)</span>、或<span class="token function">bunzip2</span><span class="token punctuation">(</span><span class="token punctuation">)</span>、或<span class="token function">unlz</span><span class="token punctuation">(</span><span class="token punctuation">)</span>）将内核放于指定位置，开始启动内核。

<span class="token number">2.</span> Linux内核<span class="token string">'启动准备阶段'</span>
由内核链接脚本<span class="token operator">/</span>kernel<span class="token operator">/</span>arch<span class="token operator">/</span>arm<span class="token operator">/</span>kernel<span class="token operator">/</span>vmlinux<span class="token punctuation">.</span>lds可知，内核入口函数为stext（<span class="token operator">/</span>kernel<span class="token operator">/</span>arch<span class="token operator">/</span>arm<span class="token operator">/</span>kernel<span class="token operator">/</span>head<span class="token punctuation">.</span>S）。
内核解压完成后，解压缩代码调用stext函数启动内核。
P<span class="token punctuation">.</span>S<span class="token punctuation">.</span>：内核链接脚本vmlinux<span class="token punctuation">.</span>lds在内核配置过程中产生，由<span class="token operator">/</span>kernel<span class="token operator">/</span>arch<span class="token operator">/</span>arm<span class="token operator">/</span>kernel<span class="token operator">/</span>vmlinux<span class="token punctuation">.</span>lds<span class="token punctuation">.</span>S文件生成。
原因是，内核链接脚本为适应不同平台，有条件编译的需求，故由一个汇编文件来完成链接脚本的制作。
（<span class="token number">1</span>）关闭IRQ、FIQ中断，进入SVC模式。调用setmode宏实现；
（<span class="token number">2</span>）校验处理器ID，检验内核是否支持该处理器；若不支持，则停止启动内核。调用__lookup_processor_type函数实现；
（<span class="token number">3</span>）校验机器码，检验内核是否支持该机器；若不支持，则停止启动内核。调用__lookup_machine_type函数实现；
（<span class="token number">4</span>）检查uboot向内核传参ATAGS格式是否正确，调用__vet_atars函数实现；
（<span class="token number">5</span>）建立虚拟地址映射页表。此处建立的页表为粗页表，在内核启动前期使用。Linux对内存管理有更精细的要求，随后会重新建立更精细的页表。调用__create_page_tables函数实现。
（<span class="token number">6</span>）跳转执行__switch_data函数，其中调用__mmap_switched完成最后的准备工作。
   <span class="token number">1</span>）复制数据段、清除bss段，目的是构建C语言运行环境；
   <span class="token number">2</span>）保存处理器ID号、机器码、uboot向内核传参地址；
   <span class="token number">3</span>）b  start_kernel跳转至内核初始化阶段。

<span class="token number">3.</span> Linux内核<span class="token string">'初始化阶段'</span>
此阶段从start_kernel函数开始。start_kernel函数是所有Linux平台进入系统内核初始化的入口函数。
它的主要工作是<span class="token string">'完成剩余与硬件平台相关的初始化'</span>工作，在进行一系列与内核相关的初始化之后，
调用<span class="token string">'第一个用户进程init'</span>并等待其执行。至此，整个内核启动完成。

<span class="token number">3.1</span> start_kernel函数的主要工作
start_kernel函数主要完成<span class="token string">'内核相关的初始化'</span>工作。具体包括以下部分：
    （<span class="token number">1</span>）内核架构 、通用配置相关初始化
    （<span class="token number">2</span>）内存管理相关初始化
    （<span class="token number">3</span>）进程管理相关初始化
    （<span class="token number">4</span>）进程调度相关初始化
    （<span class="token number">5</span>）网络子系统管理
    （<span class="token number">6</span>）虚拟文件系统
    （<span class="token number">7</span>）文件系统
start_kernel函数详解。
<span class="token number">3.2</span> start_kernel函数流中的关键函数
（<span class="token number">1</span>）<span class="token function">setup_arch</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>command_line<span class="token punctuation">)</span>函数<span class="token string">'内核架构相关的初始化'</span>函数，是非常重要的一个初始化步骤。
其中，包含了处理器相关参数的初始化、内核启动参数（tagged list）的获取和前期处理、内存子系统的早期初始化。
command_line实质是<span class="token string">'uboot向内核'</span><span class="token string">'传递的命令行启动参数'</span>，即uboot中环境变量bootargs的值。
若uboot中bootargs的值为空，command_line <span class="token operator">=</span> default_command_line，即为内核中的默认命令行参数，其值在<span class="token punctuation">.</span>config文件中配置，对应CONFIG_CMDLINE配置项。

（<span class="token number">2</span>）setup_command_line、parse_early_param以及parse_args函数
这些函数都是在<span class="token string">'完成命令行参数的解析、保存'</span>。
譬如，cmdline <span class="token operator">=</span> console<span class="token operator">=</span>ttySAC2<span class="token punctuation">,</span><span class="token number">115200</span> root<span class="token operator">=</span><span class="token operator">/</span>dev<span class="token operator">/</span>mmcblk0p2 rw init<span class="token operator">=</span><span class="token operator">/</span>linuxrc rootfstype<span class="token operator">=</span>ext3；
解析为一下四个参数：
    console<span class="token operator">=</span>ttySAC2<span class="token punctuation">,</span><span class="token number">115200</span>   <span class="token comment">//指定控制台的串口设备号，及其波特率</span>
    root<span class="token operator">=</span><span class="token operator">/</span>dev<span class="token operator">/</span>mmcblk0p2 rw  <span class="token comment">//指定根文件系统rootfs的路径</span>
    init<span class="token operator">=</span><span class="token operator">/</span>linuxrc              <span class="token comment">//指定第一个用户进程init的路径</span>
    rootfstype<span class="token operator">=</span>ext3          <span class="token comment">//指定根文件系统rootfs的类型</span>
（<span class="token number">3</span>）sched_init函数初始化进程调度器，创建运行队列，设置当前任务的空线程。
（<span class="token number">4</span>）rest_init函数rest_init函数的主要工作如下：

     <span class="token number">1</span>）调用kernel_thread函数启动了<span class="token number">2</span>个内核线程，分别是：kernel_init和kthreadd。
    kernel_init线程中<span class="token string">'调用prepare_namespace函数'</span>挂载根文件系统rootfs；然后调用init_post函数，执行根文件系统rootfs下的第一个用户进程init。用户进程有<span class="token number">4</span>个备选方案，若command_line中init的路径错误，则会执行备用方案。
            第一备用：<span class="token operator">/</span>sbin<span class="token operator">/</span>init，
            第二备用：<span class="token operator">/</span>etc<span class="token operator">/</span>init，
            第三备用：<span class="token operator">/</span>bin<span class="token operator">/</span>init，
            第四备用：<span class="token operator">/</span>bin<span class="token operator">/</span>sh。
     <span class="token number">2</span>）调用schedule函数开启内核调度系统；
     <span class="token number">3</span>）调用cpu_idle函数，启动空闲进程idle，完成内核启动。
</code></pre> 
<h3><a id="2_bootloaderbootloader_2084"></a>2. 什么是bootloader？在嵌入式系统当中bootloader的作用是什么？</h3> 
<pre><code class="prism language-shell">Bootloader是<span class="token string">'引导加载程序'</span>的统称，<span class="token comment">#（Boot ：引导 Loader : 加载）</span>
是嵌入式系统上电后的第一段代码，其主要作用是将<span class="token string">'硬件初始化'</span>
到一个合适的状态并将<span class="token string">'嵌入式操作系统'</span>'加载到内存中'执行。
</code></pre> 
<h3><a id="3_C_2092"></a>3. 为什么汇编语言对硬件平台有依赖性而C语言却可以不依赖硬件平台？</h3> 
<pre><code class="prism language-shell"><span class="token string">'不同的处理器'</span>因为<span class="token string">'硬件的差异'</span>其<span class="token string">'机器码是不同'</span>的，
<span class="token string">'汇编语言'</span>是将<span class="token string">'机器码用符号'</span>表示所以<span class="token string">'不同的处理器'</span>'汇编语言也不同<span class="token string">'。---解释型语言
C语言是'</span>不能被CPU直接识别和执行<span class="token string">'的，所以C程序需要'</span>先被编译成机器码后<span class="token string">'才能执行,---编译型语言--标准C库

如果我们使用的是ARM处理器那么编译的时候我们就将'</span>C<span class="token string">'编译成ARM的机器码，如果我们使用的是X86处理器
那么编译的时候我们就将C编译成X86的机器码，所以'</span>C语言<span class="token string">'可以'</span>不区分硬件平台'。
</code></pre> 
<h3><a id="4__2103"></a>4. 什么叫做交叉编译？</h3> 
<pre><code class="prism language-c"><span class="token string">'交叉编译'</span>就是在<span class="token string">'一台主机'</span>上<span class="token string">'编辑和编译'</span>程序，而把<span class="token string">'编译好的程序'</span>放到<span class="token string">'另外一台机器'</span>上执行。
比如嵌入式开发中我们在<span class="token string">'电脑上编辑和编译程序'</span>，而编译好的程序<span class="token string">'被下载到开发板'</span>执行。
</code></pre> 
<h3><a id="5_Linux_2110"></a>5. Linux平台下的可执行文件是什么格式？</h3> 
<pre><code class="prism language-c"><span class="token string">'elf格式'</span>的文件是linux平台下常用的<span class="token string">'二进制格式'</span>
</code></pre> 
<h3><a id="6__2116"></a>6. 什么叫做反汇编？</h3> 
<pre><code class="prism language-c">因为<span class="token string">'汇编语言'</span>是用<span class="token string">'符号来表示机器码'</span>，所以<span class="token string">'汇编语言'</span>和<span class="token string">'机器码'</span>是<span class="token string">'一一对应'</span>的，
所以我们可以将<span class="token string">'汇编语言'</span>编译成<span class="token string">'机器码'</span>，同样如果有了<span class="token string">'机器码'</span>也可以<span class="token string">'反推出汇编'</span>，
我们把通过机器码来推出汇编的过程叫做反汇编
</code></pre> 
<h3><a id="7_nfs_2124"></a>7. 简述nfs服务的概念与作用？</h3> 
<pre><code class="prism language-shell">NFS（Network File System）即<span class="token string">'网络文件系统'</span>，
它允许网络中的计算机之间通过<span class="token string">'TCP/IP网络'</span>'共享资源'。
在NFS的应用中，本地NFS的客户端应用可以透明地读写位于远端NFS服务器上的文件，就像访问本地文件一样。
</code></pre> 
<h3><a id="8_linux_2132"></a>8. 简述一个装有linux内核的开发板的启动过程？</h3> 
<pre><code class="prism language-shell">一个装有linux内核的开发板上电后的
第一个程序一般是uboot，
uboot首先对<span class="token string">'软硬件资源'</span>进行<span class="token string">'初始化'</span>，
然后将<span class="token string">'固化'</span>在存储器中的<span class="token string">'内核'</span>以及<span class="token string">'相关文件'</span>引导加载到<span class="token string">'内存'</span>中，
然后<span class="token string">'内核开始运行'</span>，内核<span class="token string">'首先'</span>对<span class="token string">'软硬件资源进行初始化'</span>，内核初始化完成后内核从指定位置去<span class="token string">'挂载根文件系统'</span>
根文件系统挂载完成后就可以运行上层的应用程序即完成了系统的启动。
</code></pre> 
<h3><a id="9_uboot_2143"></a>9. 简述uboot的主要功能有哪些？</h3> 
<pre><code class="prism language-shell">uboot最主要的功能有以下几点
<span class="token number">1</span>）<span class="token string">'初始化一些硬件'</span>为后续做准备 
<span class="token number">2</span>）<span class="token string">'引导'</span>和<span class="token string">'加载'</span>内核
<span class="token number">3</span>）给<span class="token string">'内核传参'</span>
<span class="token number">4</span>）执行用户命令
</code></pre> 
<h3><a id="10_uboot_2153"></a>10. uboot如何设置环境变量？</h3> 
<pre><code class="prism language-shell">uboot中设置环境变量使用的是<span class="token string">'setenv'</span>命令，
比如我们想设置uboot的ipaddr环境变量为192.168.1.1就可以执行<span class="token string">'setenv ipaddr 192.168.1.1'</span>命令完成设置
</code></pre> 
<h3><a id="11_ubootbootcmd19_2160"></a>11. 简述uboot中bootcmd环境变量的作用？–七.19</h3> 
<pre><code>bootcmd：&lt;设置开发板的'自启动的环境变量'&gt;
	这个参数包含了一些命令，这些命令将在倒计时结束后，进入u-boot自启动模式后执行
</code></pre> 
<h3><a id="12_ubootbootargs19_2167"></a>12. 简述uboot中bootargs环境变量的作用？–七.19</h3> 
<pre><code>uboot除了可以引导和加载内核外还可以为内核传参，即给内核传递一些信息以便于内核的正确启动，我们可以先将这些信息（比如根文件系统位置、控制台信息等）写入到bootargs环境变量，然后uboot再将这些信息传递给内核使用。
</code></pre> 
<h3><a id="13__2173"></a>13. 简述什么叫平台相关代码什么叫平台无关代码？</h3> 
<pre><code class="prism language-shell">平台相关代码即和<span class="token string">'硬件平台相关'</span>的代码，当<span class="token string">'硬件平台改变'</span>后<span class="token string">'这类代码'</span>也<span class="token string">'要做对应的修改'</span>。
比如一些操作CPU、寄存器、引脚等相关代码，当硬件改变后这类代码就不再适用需要做对应的修改。
平台无关代码就是和<span class="token string">'硬件平台无关'</span>的代码，<span class="token string">'不管硬件平台是否改变'</span>'这类代码都不用修改<span class="token string">'。

平台相关： 跟硬件'</span>平台有关代码<span class="token string">'
arch
平台无关代码： 跟硬件'</span>平台无关代码'
lib 
include
drivers
toos
ipc
net
<span class="token punctuation">..</span><span class="token punctuation">..</span>


</code></pre> 
<h3><a id="14linuxuboot_2194"></a>14.如何理解linux/uboot支持各种硬件平台？</h3> 
<pre><code class="prism language-shell">一般情况下<span class="token string">'不同的处理器'</span>由于其<span class="token string">'硬件的差异'</span>其<span class="token string">'代码是不兼容'</span>的，
即便处理器相同外围的硬件设备不同代码也不兼容，
我们经常说linux/uboot支持各种硬件平台<span class="token string">'并不是'</span>其代码<span class="token string">'真正的'</span>能够<span class="token string">'适用于任何平台'</span>，
而是在linux/uboot<span class="token string">'源代码中'</span>将其<span class="token string">'所有支持的硬件平台'</span>的<span class="token string">'代码'</span>'都写了一遍<span class="token string">'，
使用的时候当前我们'</span>使用的是什么平台<span class="token string">'我们就'</span>编译对应的代码'即可。
</code></pre> 
<h3><a id="15_uboot_2204"></a>15. 如何配置uboot使其适合特定的开发板平台？</h3> 
<pre><code class="prism language-shell">在uboot源码的顶层目录下执行<span class="token string">'make &lt;开发板名&gt;_config'</span>即可将其配置成<span class="token string">'适合特定开发板平台'</span>的<span class="token string">'uboot'</span>。
比如当前开发板的名字是origen那么我们在源码的顶层目录下执行make origen_config即可完成配置。
</code></pre> 
<h3><a id="16_uboot_2211"></a>16. 如何编译uboot生成二进制文件？</h3> 
<pre><code class="prism language-shell">在配置好的uboot源码的顶层目录下直接执行<span class="token string">'make命令'</span>即可编译uboot源码生成二进制的可执行文件。
</code></pre> 
<h3><a id="17_uboot_2217"></a>17. 简述uboot的启动过程？</h3> 
<pre><code class="prism language-shell">uboot主要做了两个阶段的事：
第一个阶段：汇编
    构建<span class="token string">'异常向量表'</span>
    禁止<span class="token string">'mmu'</span>和<span class="token string">'cache'</span>，禁止<span class="token string">'看门狗'</span>
    硬件时钟的<span class="token string">'初始化'</span>，<span class="token string">'内存'</span>的<span class="token string">'初始化'</span>
    清除<span class="token string">'bss'</span>段	<span class="token comment">#bss段是用来存储静态变量，全局变量的</span>
    完成uboot代码的自搬移
    <span class="token string">'初始化C代码'</span>运行的<span class="token string">'栈空间'</span>
    
第二个阶段：C
    完成<span class="token string">'大部分硬件'</span>的<span class="token string">'初始化'</span>，<span class="token string">'串口'</span>的初始化，<span class="token string">'内存'</span>的进一步的初始化，<span class="token string">'电源的'</span>初始化 等等必要<span class="token string">'硬件的'</span>初始化
    根据命令是否进入<span class="token string">'交互模式'</span>还<span class="token string">'自启动模式'</span>
    获取uboot的<span class="token string">'环境变量'</span>，
    执行<span class="token string">'bootcmd中的命令'</span>，
    最终<span class="token string">'给内核传递参数'</span>（bootargs）
</code></pre> 
<h3><a id="18__2237"></a>18. 操作系统的作用有哪些？</h3> 
<pre><code class="prism language-shell">内存管理 
文件管理
网络管理
进程管理
设备管理 
<span class="token comment">#(这是Linux内核的功能)</span>
</code></pre> 
<h3><a id="19_linux_2248"></a>19. 如何配置linux源码使其适合特定的处理器？</h3> 
<pre><code class="prism language-shell">在linux源码中执行<span class="token string">'make &lt;处理器名&gt;_defconfig'</span>即可将其配置成<span class="token string">'适合特定的处理器'</span>的代码。
比如现在使用的处理器是exynos，那么我们在linux源码顶层目录下执行命令make exynos_defconfig即可完成配置。
</code></pre> 
<h3><a id="20_make_menuconfigYNM_2255"></a>20. 在make menuconfig界面下有些驱动可以被选成三种状态即“Y”，“N”，“M”这三种状态分别是什么含义？</h3> 
<pre><code class="prism language-shell">Y--选配<span class="token string">'到内核里'</span>，编译后的内核就包含了该驱动程序，同样内核的体积也会随之增大
N--<span class="token string">'不会被编译'</span>进内核，即编译后的内核也不支持该驱动
M--<span class="token string">'模块化编译'</span>到内核里，要将该驱动编译成模块，在编译内核的时候该驱动<span class="token string">'不会被编译'</span>，但可以单独编译成一个驱动模块使用的时候临时加载该模块。
</code></pre> 
<h3><a id="21_M_2263"></a>21. 如何编译被选中为“M”选项的驱动模块？</h3> 
<pre><code class="prism language-shell">在linux源码的顶层目录下执行<span class="token string">'make modules'</span>即可将选为“M”的驱动编译成驱动模块。
    insmod 可以安装这个驱动
    lsmod 查看驱动
    rmmod卸载驱动
</code></pre> 
<h3><a id="22__2272"></a>22. 简述设备树的作用？</h3> 
<pre><code class="prism language-shell">设备树（Device Tree）是种<span class="token string">'描述硬件的数据结构'</span>，在操作系统（OS）<span class="token string">'引导阶段'</span>进设备<span class="token string">'初始化'</span>的时候，数据结构中的<span class="token string">'硬件信息'</span>'被检测并传递<span class="token string">'给'</span>操作系统<span class="token string">'。

内核中的'</span>驱动程序<span class="token string">''</span>没有<span class="token string">'开发板'</span>硬件信息<span class="token string">'，比如'</span>管脚的信息<span class="token string">'、'</span>寄存器的地址<span class="token string">'等，所以驱动程序'</span>不能正确的驱动<span class="token string">'一个具体的硬件设备工作，设备树是'</span>专门<span class="token string">'描述开发板'</span>硬件信息<span class="token string">'的'</span>文件<span class="token string">'，所以有了'</span>设备树<span class="token string">','</span>驱动程序<span class="token string">'和开发板上'</span>具体的硬件<span class="token string">'设备就能'</span>建立起关系'使驱动正常工作。
</code></pre> 
<h3><a id="23__2280"></a>23. 编写设备树文件的主要依据是什么？</h3> 
<pre><code class="prism language-shell">设备树文件是描述开发板硬件信息的文件，
所以编写设备树的<span class="token string">'主要依据'</span>是根据开发板硬件的信息。
</code></pre> 
<h3><a id="24__2287"></a>24. 简述如何将一个内核源码中已有的驱动程序编译到内核中？</h3> 
<pre><code class="prism language-shell">首先在<span class="token string">'make menuconfig'</span>中<span class="token string">'选中'</span>我们想要的驱动，
	因为内核自带的驱动程序中<span class="token string">'没有开发板的硬件信息'</span>，
所以我们还要<span class="token string">'按照实际的硬件信息'</span>去<span class="token string">'修改设备树'</span>文件，
然后<span class="token string">'重新编译'</span>内核和设备树就可以将驱动编译到内核。
</code></pre> 
<h3><a id="25__2296"></a>25. 简述如何将一个自己编写的驱动程序编译到内核中？</h3> 
<pre><code class="prism language-c">首先我们将自己编写的<span class="token string">'驱动程序'</span>放入到<span class="token string">'内核源码'</span>中，
然后修改对应的<span class="token string">'Kconfig文件'</span>使自己写的驱动能在<span class="token string">'make menuconfig'</span>界面中显示出来，
然后还需要修改<span class="token string">'对应的Makefile'</span>使驱动能<span class="token string">'正确编译'</span>，
以上步骤完成后 编译就可以将<span class="token string">'驱动编译进内核'</span>。
</code></pre> 
<h3><a id="26_2305"></a>26.在内核启动过程中如果控制台已经初始化我们一般采用什么方式来调试内核？</h3> 
<pre><code class="prism language-shell">如果控制台已经初始化我们一般使用<span class="token string">'printk函数'</span>来打印我们自己的信息
</code></pre> 
<h3><a id="27_linuxOops_2311"></a>27. linux内核在启动过程中遇到什么情况会打印系统崩溃报告Oops？</h3> 
<pre><code class="prism language-shell">当linux内核在启动过程中出现以下几种问题的时候会打印<span class="token string">'系统崩溃报告'</span>
<span class="token number">1</span>）内存访问<span class="token string">'越界'</span> <span class="token number">2</span>）使用<span class="token string">'非法指针'</span> <span class="token number">3</span>）使用了<span class="token string">'NULL指针'</span> <span class="token number">4</span>）使用了<span class="token string">'不正确的指针'</span>
</code></pre> 
<h3><a id="28_linuxOops_2318"></a>28. linux内核在启动过程中遇到某些问题会打印系统崩溃报告Oops，报告中主要打印哪些内容？</h3> 
<pre><code class="prism language-shell">报告中可以将CPU中<span class="token string">'各个寄存器的值'</span>、<span class="token string">'页描述符表的位置'</span>以及<span class="token string">'其他信息'</span>打印出来。
</code></pre> 
<h3><a id="29__2324"></a>29. 简述什么叫文件系统？什么叫根文件系统？</h3> 
<pre><code class="prism language-shell">文件系统是一种<span class="token string">'管理和访问磁盘'</span>的<span class="token string">'软件机制'</span>，其<span class="token string">'本质'</span>是<span class="token string">'软件'</span>，不同<span class="token string">'文件系统'</span>管理和访问磁盘的<span class="token string">'机制不同'</span>。

根文件系统是<span class="token string">'存放运行系统'</span>所必须的<span class="token string">'各种工具软件'</span>、<span class="token string">'库文件'</span>、<span class="token string">'脚本'</span>、<span class="token string">'配置'</span>等文件的地方
<span class="token string">'实质'</span>就是<span class="token string">'一些文件'</span>
</code></pre> 
<h3><a id="30__2333"></a>30. 开发板中为什么一般不需要安装静态库？</h3> 
<pre><code class="prism language-shell">库可以分为<span class="token string">'静态库'</span>和<span class="token string">'动态库'</span>
<span class="token string">'静态库'</span>一般是<span class="token string">'编译程序'</span>的时候<span class="token string">'使用'</span>
而<span class="token string">'动态库'</span>一般是<span class="token string">'程序运行'</span>的时候<span class="token string">'使用'</span>

在嵌入式开发中一般我们使用<span class="token string">'交叉编译'</span>的方式，即我们编辑和编译程序是在电脑下而程序编译完成后下载到开发板执行,所以<span class="token string">'一般不会在开发板编译程序'</span>，所以开发板<span class="token string">'一般不需要安装静态库'</span>。
</code></pre> 
<h2><a id="__2345"></a>九. 驱动开发</h2> 
<h3><a id="1__2347"></a>1. 什么是模块？</h3> 
<pre><code class="prism language-shell">Linux 内核的整体结构已经非常庞大,而其包含的组件也非常多。
这会导致两个问题,
    一是生成的<span class="token string">'内核会很大'</span>,
    二是如果我们要在现有的<span class="token string">'内核中新增或删除功能'</span>,将不得不<span class="token string">'重新编译内核'</span>。

Linux 提供了这样的一种机制,这种机制被称为<span class="token string">'模块(Module)'</span>。使得编译出的内核本身并<span class="token string">'不需要包含所有功能'</span>,而在这些功能需要<span class="token string">'被使用的时候'</span>,其<span class="token string">'对应的代码'</span>被<span class="token string">'动态地加载到内核'</span>中。
</code></pre> 
<h3><a id="2__2358"></a>2. 驱动类型有几种</h3> 
<pre><code>字符设备驱动、块设备驱动、网络设备驱动
</code></pre> 
<h3><a id="3__2364"></a>3. 字符设备驱动框架编程流程？</h3> 
<pre><code>模块加载部分：
1- 生成设备号	
2- 注册设备号
3- 初始化字符设备对象，编写填充file_operations结构体集合
4- 添加注册字符设备

模块卸载部分：
1- 取消cdev注册
2- 取消设备号注册
</code></pre> 
<h3><a id="4__2378"></a>4. 什么是并发，驱动中产生竞态的原因有哪些？</h3> 
<pre><code class="prism language-shell">并发（concurrency）指的是<span class="token string">'多个执行单元'</span>'同时、并行<span class="token string">'被'</span>执行<span class="token string">'，而并发的执行单元对'</span>共享资源<span class="token string">'（硬件资源和软件上的全局变量、静态变量等）的'</span>访问<span class="token string">'则很容易导致竞态（race conditions）

产生竟态的原因：当'</span>多个进程<span class="token string">'同时访问'</span>同一个<span class="token string">'驱动的'</span>临界资源<span class="token string">'的时候竞态就产生了。	
    1.对于'</span>单核CPU<span class="token string">'来说，如果支持'</span>进程抢占<span class="token string">'，就会产生竞态。
    2.对于'</span>多核CPU<span class="token string">'来说,核与核之间'</span>本身'就会产生竞态
    <span class="token number">3</span>.中断和进程间 会产生竞态
    <span class="token comment">#（arm）中断和中断间会产生竞态  (###错误的###)</span>
</code></pre> 
<h3><a id="5__2390"></a>5. 解决竞态的途径有哪些？分别有什么特点？</h3> 
<pre><code>1.顺序执行
2.互斥执行
	中断屏蔽:都只能禁止和使能本CPU内的中断，因此，并不能解决SMP多CPU引发的竞态
	自旋锁  :又叫忙等待锁。自旋锁期间不能有睡眠的函数存在，也不能主动放弃cpu的调度权，也不能进行耗时操作。否则容易造成死锁。
	信号量  :是内核中用来保护临界资源的一种，与应用层信号量理解一致
3.互斥体  
4.原子操作
</code></pre> 
<h3><a id="6_IO_2402"></a>6. 驱动中IO模型有几种？</h3> 
<pre><code>（1）阻塞式IO	 最简单，最常用，效率最低的io操作
（2）非阻塞式IO 	需要不断的轮询。
（3）多路IO复用	 解决多路输入输出的阻塞问题
（4）信号驱动IO 	异步通信机制，类似于中断。
</code></pre> 
<h3><a id="7_linux_2411"></a>7. 设计linux设备模型的主要作用？</h3> 
<pre><code class="prism language-shell">实现<span class="token string">'硬件地址信息'</span>与<span class="token string">'软件驱动'</span>分离	----这特么是设备树吧
</code></pre> 
<h3><a id="8_linux_2417"></a>8. 字符设备驱动框架与linux设备模型是否矛盾？</h3> 
<pre><code class="prism language-shell">字符设备驱动框架，主要为了使<span class="token string">'应用程序'</span>能够经过<span class="token string">'层层调用'</span>，访问<span class="token string">'底层硬件'</span>。
linux设备模型实现<span class="token string">'硬件地址信息'</span>与<span class="token string">'软件驱动'</span>分离
所以二者并不矛盾。
</code></pre> 
<h3><a id="9_platform_2425"></a>9. platform架构分别分为哪个部分？他们通过什么进行匹配</h3> 
<pre><code class="prism language-shell">platform运用的<span class="token string">'分离'</span>的思想，将<span class="token string">'设备信息'</span>和<span class="token string">'设备驱动'</span>分离,分离后借助<span class="token string">'总线'</span>模型 <span class="token string">'devicebus driver'</span>完成匹配的过程。
匹配<span class="token string">'成功'</span>之后执行<span class="token string">'驱动中的probe函数'</span>，在probe中操作硬件即可
如果两者<span class="token string">'分离'</span>执行驱动中的<span class="token string">'remove函数'</span>。bus就完成匹配的工作（bus是内核实现的）。

设备，驱动，总线；
<span class="token number">1</span>- 按名称匹配
<span class="token number">2</span>- 按id_table表进行匹配
</code></pre> 
<h3><a id="10_platform_2437"></a>10. 设备树与platform架构是否有矛盾？</h3> 
<pre><code class="prism language-shell">没有矛盾
<span class="token string">'设备树'</span>是对<span class="token string">'设备模型'</span>中，<span class="token string">'硬件资源'</span>描述部分，进行简化升级。将以前的资源<span class="token string">'结构体'</span>，改成<span class="token string">'设备树节点'</span>的形式进行描述，降低了难度系数
</code></pre> 
<h3><a id="11__2444"></a>11. 为什么要将中断分为上下半部？上下半部机制有哪些？</h3> 
<pre><code class="prism language-shell">在中断处理函数只能做<span class="token string">'简短不耗时'</span>的操作，但是<span class="token string">'有的时候'</span>又希望在中断到来的时候<span class="token string">'做相对耗时的操作'</span>，这样就产生了矛盾，linux内核为了解决这个矛盾引入了<span class="token string">'中断底半部'</span>的概念。
将这些<span class="token string">'耗时操作'</span>放到中断底半部完成。---但是还是不能有延时函数，因为虽然是中断底半部，但也属于中断，优先级比一般进程要高--。
<span class="token comment">#例如：当网卡中断到来的时候需要去接受网络传递过来的数据，此时就是一个耗时操作应该放到中断底半部完成。中断底半部的机制 软中断 , tasklet , 工作队列</span>
</code></pre> 
<h3><a id="12_tasklet_2452"></a>12. 工作队列与tasklet的区别？</h3> 
<pre><code class="prism language-shell">tasklet:
tasklet是<span class="token string">'基于'</span>软中断实现的，本身是通过<span class="token string">'链表'</span>实现的，因此<span class="token string">'没有个数'</span>限制。
tasklet工作在<span class="token string">'中断上下文'</span>，它是中断的<span class="token string">'一个部分'</span>，<span class="token string">'不能脱离'</span>中断执行。
可以做<span class="token string">'相对耗时'</span>操作，但是<span class="token string">'不能'</span>做休眠的操作。

工作队列:
在内核启动的时候会启动一个<span class="token string">'events'</span>的线程这个线程默认处于<span class="token string">'休眠'</span>状态，在这个线程中维护一个<span class="token string">'工作队列'</span>。
如果想<span class="token string">'使用工作队列'</span>就向队列中<span class="token string">'提交队列项'</span>，然后<span class="token string">'唤醒events线程'</span>，让它去调用队列项中的<span class="token string">'底半部处理函数'</span>即可。
工作队列<span class="token string">'可以脱离'</span>中断执行，<span class="token string">'没有个数限制'</span>，工作于<span class="token string">'进程上下文'</span>。在底半部处理函数中可以做延时，耗时，<span class="token string">'甚至'</span>休眠的操作。

<span class="token comment">#-------------------------------------------------------</span>
区别：
工作队列的<span class="token string">'使用方法'</span>和tasklet非常<span class="token string">'相似'</span>
tasklet运行于<span class="token string">'中断上下文'</span>
工作队列运行于<span class="token string">'进程上下文'</span>
tasklet处理函数中<span class="token string">'不能睡眠'</span>，而工作队列处理函数中<span class="token string">'允许睡眠'</span>
</code></pre> 
<h3><a id="13__2475"></a>13. 内核中内存分配函数分别有哪些？分别有什么特点？</h3> 
<pre><code class="prism language-shell">按页<span class="token punctuation">(</span>page<span class="token punctuation">)</span>分配 		__get_free_pages <span class="token punctuation">(</span><span class="token punctuation">)</span>
调用者指定<span class="token string">'所需整页'</span>的阶数作为参数之一来请求
所申请的页将会<span class="token string">'被加入内核空间'</span>
所分配的<span class="token string">'物理RAM空间'</span>是<span class="token string">'连续'</span>的

kmalloc
除了是<span class="token string">'请求精确字节'</span>的<span class="token string">'内存'</span>外，与按页分配相同

vmalloc
除了<span class="token string">'物理内存不一定连续'</span>外，与kmalloc同
</code></pre> 
<h3><a id="14__2492"></a>14. 内核调试</h3> 
<h4><a id="aprintkprintk_2494"></a>a.可以使用printk打印内核信息，printk的调试级别如下</h4> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">KERN_EMERG</span> <span class="token string">"0"</span>   <span class="token comment">/* system is unusable */</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">KERN_ALERT</span> <span class="token string">"1"</span>   <span class="token comment">/* action must be taken immediately */</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">KERN_CRIT</span>  <span class="token string">"2"</span>   <span class="token comment">/* critical conditions */</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">KERN_ERR</span>  <span class="token string">"3"</span>   <span class="token comment">/* error conditions */</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">KERN_WARNING</span> <span class="token string">"4"</span>   <span class="token comment">/* warning conditions */</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">KERN_NOTICE</span> <span class="token string">"5"</span>   <span class="token comment">/* normal but significant condition */</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">KERN_INFO</span>  <span class="token string">"6"</span>   <span class="token comment">/* informational */</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">KERN_DEBUG</span> <span class="token string">"7"</span>   <span class="token comment">/* debug-level messages */</span></span>

<span class="token comment">//打印级别的作用是用于过滤打印信息的。</span>
<span class="token operator">&lt;</span><span class="token number">0</span><span class="token operator">&gt;</span> <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span> <span class="token operator">&lt;</span><span class="token number">7</span><span class="token operator">&gt;</span>
最大级别     最小级别
    
只有当<span class="token string">'消息的级别'</span>大于<span class="token string">'终端的级别'</span>的时候消息<span class="token string">'才会'</span>在终端上<span class="token string">'显示'</span>
可以通过<span class="token string">'/proc/sys/kernel/printk'</span> cat 这个文件来查看
cat <span class="token operator">/</span>proc<span class="token operator">/</span>sys<span class="token operator">/</span>kernel<span class="token operator">/</span>printk
<span class="token number">4</span>      <span class="token number">4</span>         <span class="token number">1</span>        <span class="token number">7</span>
终端的级别   默认消息的级别  终端的最大级别  终端的最小级别
  <span class="token comment">//注意 ： 修改级别的时候 只能使用 echo 重定向，不能使用 vim</span>
</code></pre> 
<h4><a id="b_gdb__addr2line__2518"></a>b. gdb 和 addr2line 调试内核模块</h4> 
<pre><code>大致流程如下
1.编写的makefile中的gcc加上-Wall -g选项，方便后续调试
2.加载内核模块的时候产生oops，利用dmesg 来查看 panic 内容 （例如：dmesg |tail -20）
3.查看日志内容，找到oops 发生的关键日志，（注意：出现 oops 的是从模块的基地址偏移出来的地址）
4.找到oops发生的基地址，cat /proc/modules |grep oops
5.使用 addr2line 找到 oops 位置，（addr2line -e oops.o 0x14，偏移量=偏移地址-基地址，这里的，0x14就是偏移量）
6.上面的运行结果返回的是源码某个.c文件里的行号，也就是知道了代码导致 oops 的位置是第几行
7.通过objdump 来查找oops 位置（objdump -dS --adjust-vma=0xffffffffa0358000oops.ko）
8.终端打印的结果可以看到反汇编出来的c代码，也就是知道了产生oops的内存地址对应的c代码是哪一句
</code></pre> 
<h4><a id="c_BUG_ONBUGdump_stack_2532"></a>c. 使用函数BUG_ON()，BUG()和dump_stack()调试内核</h4> 
<pre><code>使用方法：
1.编写内核驱动模块的时候，在想要查看具体信息的函数中调用BUG_ON()，BUG()或者dump_stack()
2.执行sudo insmode xxx.ko后在kernle日志下可以看到调用函数的具体信息，带绝对路径的文件名和行号等
</code></pre> 
<h3><a id="15__2542"></a>15. 字符设备驱动的框架</h3> 
<pre><code class="prism language-c">字符设备：提供连续的数据流，应用程序可以顺序读取，通常不支持随机存取，支持按字节<span class="token operator">/</span>字符来读写
数据。
块设备：应用程序可以随机访问设备数据，程序可自行确定读取数据的位置。应用程序可以寻址磁盘上
的任何位置，并由此读取数据。此外，数据的读写只能以块<span class="token punctuation">(</span>通常是<span class="token number">512</span>B<span class="token punctuation">)</span>的倍数进行。与字符设备不
同，块设备并不支持基于字符的寻址。
网络设备：网络设备是特殊设备的驱动，它负责接收和发送帧数据，可能是物理帧，也可能是ip数据
包，这些特性都有网络驱动决定。它并不存在于<span class="token operator">/</span>dev下面，所以与一般的设备不同。网络设备是一个
net_device结构，并通过register_netdev注册到系统里，最后通过ifconfig <span class="token operator">-</span>a的命令就能看到。
</code></pre> 
<p><img src="https://images2.imgbox.com/8c/b1/is6l5lAm_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="16__2560"></a>16. 字符设备和块设备和网络设备的区别</h3> 
<pre><code class="prism language-shell">字符设备：
提供连续的<span class="token string">'数据流'</span>，应用程序可以<span class="token string">'顺序读取'</span>，通常<span class="token string">'不支持随机存取'</span>，支持按<span class="token string">'字节/字符'</span>来读写数据。

块设备：
应用程序可以<span class="token string">'随机访问设备数据'</span>，程序可<span class="token string">'自行确定'</span>读取数据的<span class="token string">'位置'</span>。应用程序可以<span class="token string">'寻址'</span>磁盘上的<span class="token string">'任何位置'</span>，并由此读取数据。
此外，数据的读写<span class="token string">'只能以块(通常是512B)的倍数'</span>进行。与字符设备不同，块设备并<span class="token string">'不支持'</span>基于字符的寻址。

网络设备：
网络设备是<span class="token string">'特殊设备'</span>的驱动，它负责<span class="token string">'接收和发送'</span>帧数据，可能是<span class="token string">'物理帧'</span>，也可能是<span class="token string">'ip数据包'</span>，这些特性都有网络驱动决定。
它并不存在于/dev下面<span class="token punctuation">(</span>因为在写Linux内核之前网络协议就有了<span class="token punctuation">)</span>，所以与一般的设备不同。网络设备是一个net_device结构，并通过<span class="token string">'register_netdev'</span>注册到系统里，最后通过<span class="token string">'ifconfig -a'</span>的命令就能看到。
</code></pre> 
<h3><a id="17_4_2577"></a>17. 并发和竞态概念，那些情况会出现竟态，解决竟态的方法，以及区别，使用场景。—上面第4题</h3> 
<pre><code class="prism language-shell">并发（concurrency）是指<span class="token string">'多个执行单元'</span>'同时、并行<span class="token string">'的'</span>被执行<span class="token string">'，而并发执行单元对共享资源的访问很容导致竞态（race condition）。

并发与竞态发生的条件：
对称多处理器（SMP）的多个CPU；单CPU内进程与抢占它的进程；中断与进程之间。
当'</span>多个进程<span class="token string">'同时访问'</span>同一个<span class="token string">'驱动的'</span>临界资源<span class="token string">'的时候竞态就产生了。	
    1.对于'</span>单核CPU<span class="token string">'来说，如果支持'</span>进程抢占<span class="token string">'，就会产生竞态。
    2.对于'</span>多核CPU<span class="token string">'来说,核与核之间'</span>本身<span class="token string">'就会产生竞态
    3.中断和进程间 会产生竞态
    
    
解决并发与竞态的途径:
访问共享资源的代码区域称为'</span>临界区域<span class="token punctuation">(</span>critical section<span class="token punctuation">)</span><span class="token string">''</span>，解决竞态的根本途径就是对临界区的互斥访问，方法主要有中断屏蔽、原子操作、自旋锁、信号量、互斥体。

<span class="token number">1</span>. 中断屏蔽
单CPU避免竞态的<span class="token string">'简单办法'</span>就是<span class="token string">'中断屏蔽'</span>，保证可以防止中断与进程间竞态条件的发生（所有中断被屏蔽后进程间切换的基础时钟中断也被屏蔽掉了）。

<span class="token number">2</span>.原子操作
原子操作是指在执行过程中不会被别的代码路径所中断，可分为整形原子操作和位原子操作。

<span class="token number">3</span>.自旋锁
自旋锁主要针对SMP或单CPU且内核可抢占的情况，自旋锁可以保证临界区不受别的CPU和本CPU内的抢占进程打扰。当临界区可能受到中断和底半步影响时，应该使用自旋锁的衍生操作。
自旋锁是忙等待锁，当锁不可用时，CPU会不停地循环测试而不能做其它的工作，因此自旋锁会降低系统的性能。
如果临界区域发生阻塞，可能会导致死锁，因此在自旋锁占有期间内不能调用copy_from_user<span class="token punctuation">(</span><span class="token punctuation">)</span>,copy_to_user<span class="token punctuation">(</span><span class="token punctuation">)</span>, kmalloc<span class="token punctuation">(</span><span class="token punctuation">)</span>等函数。

<span class="token number">4</span>、信号量
信号量和自旋锁不同的地方在于当进程得不到信号量时，进程会进入休眠或其它状态。
</code></pre> 
<h3><a id="18__2610"></a>18. 自旋锁和信号量的区别</h3> 
<pre><code class="prism language-shell">自旋锁：
当一个程序获取到自旋锁后，另外一个程序也想获取这把锁，此时后一个进程处于自旋状态（忙等，原地打
转）
  <span class="token number">1</span>.针对<span class="token string">'多核处理器'</span>有效
  <span class="token number">2</span>.自旋的时候需要<span class="token string">'消耗cpu资源'</span>
  <span class="token number">3</span>.自旋锁会<span class="token string">'导致死锁'</span>。//---<span class="token operator">&gt;</span> 加锁了以后 又加一次，然后就会死锁
  <span class="token number">4</span>.自旋锁可以工作在<span class="token string">'中断处理函数'</span>中
  <span class="token number">5</span>.在自旋锁<span class="token string">'内部不能有'</span>延时，耗时，甚至休眠的操作。还<span class="token string">'不能
有'</span>copy_to_user/copy_from_user函数。
  <span class="token number">6</span>.自旋锁在<span class="token string">'上锁的时候'</span>会<span class="token string">'关闭抢占'</span>

信号量：
信号量:当一个程序获取到信号量后，另外一个程序也想获取这个信号量，此时后一个进程处于休眠状态。
  <span class="token number">1</span>.等待获取信号量的进程<span class="token string">'不占用cpu资源'</span>
  <span class="token number">2</span>.针对<span class="token string">'多核设计'</span>的
  <span class="token number">3</span>.信号量<span class="token string">'不会产生死锁'</span>
  <span class="token number">4</span>.信号量保护的<span class="token string">'临界区可以很大'</span>，里面<span class="token string">'可以有'</span>延时、耗时，甚至休眠的操作
  <span class="token number">5</span>.信号量<span class="token string">'不能用于'</span>中断处理函数中

<span class="token comment">#------------------------------------------------------------------------</span>
当临界区<span class="token string">'执行时间比较小'</span>时，采用自旋锁，否则采用信号量；
<span class="token string">'自旋锁'</span>绝对不能在临界区包含可能<span class="token string">'引起阻塞的代码'</span>，信号量可以；
如果临界区的代码在<span class="token string">'中断中'</span>执行，应该使用<span class="token string">'自旋锁'</span>或<span class="token string">'信号量的down_trylock()函数'</span>。
</code></pre> 
<h3><a id="19__2640"></a>19. 谈谈你对中断上下文，进程上下文的理解</h3> 
<pre><code class="prism language-shell">进程上下文：
进程上文：
	其是指进程由<span class="token string">'用户态'</span>切换到<span class="token string">'内核态'</span>是需要<span class="token string">'保存用户态时cpu寄存器中的值'</span>，<span class="token string">'进程状态'</span>以及<span class="token string">'堆栈上的内容'</span>，
	即保存<span class="token string">'当前进程的进程上下文'</span>，以便<span class="token string">'再次执行'</span>该进程时，能够恢复切换时的状态，继续执行。
进程下文：
	其是指<span class="token string">'切换'</span>到<span class="token string">'内核态'</span>后执行的程序，即进程运行在内核空间的部分。

<span class="token comment">#--------------------------------------------------------------------------------</span>
中断上下文：
中断上文：
	硬件通过<span class="token string">'中断'</span>触发信号，导致内核调用中断处理程序，进入<span class="token string">'内核'</span>空间。这个过程中，硬件的一些<span class="token string">'变量和参数'</span>也要传递给<span class="token string">'内核'</span>，内核通过这些参数进行中断处理。
	中断上文可以看作就是<span class="token string">'硬件传递'</span>过来的这些<span class="token string">'参数'</span>和内核需要保存的一些其他环境（主要是当前被中断的进程环境。）

中断下文：
	执行在内核空间的中断服务程序。
</code></pre> 
<h3><a id="20__2662"></a>20. 中断低半部主要做了什么</h3> 
<pre><code class="prism language-shell">为了在中断执行<span class="token string">'时间尽可能短'</span>和中断处理<span class="token string">'需完成大量工作'</span>之间找到一个平衡点，Linux将中断处理程序分解为两个半部：顶半部（top half）和底半部（bottom half）。

顶半部完成尽可能少的比较紧急的功能，它往往只是简单地读取寄存器中的中断状态并清除中断标志后就进行“登记中断”的工作。
“登记中断”意味着将底半部处理程序挂到该设备的底半部执行队列中去。这样，顶半部执行的速度就会很快，可以服务更多的中断请求。
现在，中断处理工作的重心就落在了底半部的头上，它来完成中断事件的绝大多数任务。
底半部几乎做了中断处理程序所有的事情，而且可以被新的中断打断，这也是底半部和顶半部的最大不同，因为顶半部往往被设计成不可中断。底半部则相对来说并不是非常紧急的，而且相对比较耗时，不在硬件中断服务程序中执行。

尽管顶半部、底半部的结合能够改善系统的响应能力，但是，僵化地认为Linux设备驱动中的中断处理一定要分两个半部则是不对的。如果中断要处理的工作本身很少，则完全可以直接在顶半部全部完成。

其实上面这一段大致说明一个问题，那就是：中断要尽可能耗时比较短，尽快恢复系统正常调试，所以把中断触发、中断执行分开，也就是所说的“上半部分（中断触发）、底半部（中断执行）”，其实就是我们后面说的中断上下文。下半部分一般有tasklet、工作队列实现，触摸屏中中断实现以工作队列形式实现的

中断下半部的处理对于一个中断，如何划分出上下两部分呢?哪些处理放在上半步，哪些放在下半部?
这里有一些经验可供借鉴：
如果一个任务对时间十分敏感，将其放在上半部。
如果一个任务和硬件有关，将其放在上半部。
如果一个任务要保证不被其他中断打断，将其放在上半部。
其他所有任务，考虑放在下半部。
</code></pre> 
<h3><a id="21_Platfprm_2686"></a>21. Platfprm平台总线驱动模型</h3> 
<pre><code class="prism language-c">相对于USB、PCI、I2C、SPI等物理总线来说，platform总线是一种<span class="token string">'虚拟、抽象'</span>出来的总线，实际中并不存在这样的总线。
那为什么需要platform总线呢？
    其实是Linux设备驱动模型为了保持设备驱动的统一性而虚拟出来的总线。
    因为对于usb设备、i2c设备、pci设备、spi设备等等，他们与cpu的通信都是直接挂在相应的总线下面与我们的cpu进行数据交互的，但是在我们的嵌入式系统当中，并不是所有的设备都能够归属于这些常见的总线，在嵌入式系统里面，SoC系统中集成的独立的外设控制器、挂接在SoC内存空间的外设却不依附与此类总线。
    所以Linux驱动模型为了保持完整性，将这些设备挂在一条虚拟的总线上（platform总线），而不至于使得有些设备挂在总线上，另一些设备没有挂在总线上。
    
platform总线管理
<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>两个结构体platform_device和<span class="token function">platform_driver</span>
<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>两组接口函数（driver\base\platform<span class="token punctuation">.</span>c）
<span class="token comment">// 用来注册设备驱动 </span>
<span class="token keyword">int</span> <span class="token function">platform_driver_register</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">platform_driver</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   
<span class="token comment">// 用来卸载设备驱动 </span>
<span class="token keyword">void</span> <span class="token function">platform_driver_unregister</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">platform_driver</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token comment">// 用来注册设备  </span>
<span class="token keyword">int</span> <span class="token function">platform_device_register</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">platform_device</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   
<span class="token comment">// 用来卸载设备</span>
<span class="token keyword">void</span> <span class="token function">platform_device_unregister</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">platform_device</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
不管是<span class="token string">'先注册设备'</span>还是<span class="token string">'先注册设备驱动'</span>都会进行一次<span class="token string">'设备与设备驱动'</span>的匹配过程，匹配成功之后就会调用<span class="token string">'probe函数'</span>，
    匹配的<span class="token string">'原理'</span>就是去<span class="token string">'遍历'</span>总线下的相应的<span class="token string">'链表'</span>来找到挂接在他下面的设备或者设备驱动。
    
<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span> platform总线下的匹配函数，platform_match函数platform总线下设备与设备驱动的匹配原理就是通过名字进行匹配的，先去匹配platform_driver中的id_table表中的各个名字与platform_device<span class="token operator">-&gt;</span>name名字是否相同，
    如果相同表示匹配成功直接返回，
    否则直接匹配platform_driver<span class="token operator">-&gt;</span>nameplatform_driver<span class="token operator">-&gt;</span>name是否相同，相同则匹配成功，否则失败。
</code></pre> 
<h3><a id="22_IIC_2716"></a>22. IIC子系统驱动框架</h3> 
<p><img src="https://images2.imgbox.com/7f/2f/fg5OISBe_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="23__2721"></a>23. 输入子系统驱动框架</h3> 
<h4><a id="_2723"></a>子系统的组成</h4> 
<p><img src="https://images2.imgbox.com/6d/9c/ru4d4ciG_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="_2728"></a>输入子系统的事件处理机制示意图</h4> 
<p><img src="https://images2.imgbox.com/cc/68/DNDkk6aQ_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="_2732"></a>输入子系统剖析</h4> 
<p><img src="https://images2.imgbox.com/b3/4a/HFrGHUAp_o.png" alt="在这里插入图片描述"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e46153297e9c457dfc1776312d942c9a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Grafana&amp;&amp;Zabbix</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/af5f4dbaa06bbae856fac1e7f711381e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">windows spice协议连接PVE虚拟机</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>