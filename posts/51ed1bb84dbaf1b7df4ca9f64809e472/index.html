<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>K8S的控制器Deployment,ReplicaSet,StatefulSet,CronJob,最小单位pod - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="K8S的控制器Deployment,ReplicaSet,StatefulSet,CronJob,最小单位pod" />
<meta property="og:description" content="K8S的控制器Deployment,ReplicaSet,StatefulSet,CronJob,最小单位pod K8S的控制器1、Deploymen控制器（常用pod控制器）2、ReplicaSet控制器（实现pod数量控制）3、StatefulSet控制器（有状态服务控制器）3.1 master创建pv存储池3.2 master创建configmap保存配置文件3.3 master创建secret保存redis密码3.4 master创建service3.5 master通过StatefulSet创建pod3.6 测试redis主从 4、DaemonSet控制器（主要用于每个节点创建守护pod进程）5、Job控制器（一次性任务控制器）6、CronJob控制器（定时任务控制器）7、k8s最小单位pod（单实例pod） K8S的控制器 Deployment：无状态控制器，主要可以创建无状态的服务，比如说nginx，Apache等这些不用创建主从、主主等状态的pod，还支持滚动升级，回滚等高级功能，默认创建pod的控制器。表现形式一般就是yml文件的kind: Deployment
ReplicaSet：ReplicaSet 是通过一组字段来定义的，包括一个用来识别可获得的 Pod 的集合的选择算符、一个用来标明应该维护的副本个数的数值、一个用来指定应该创建新 Pod 以满足副本个数条件时要使用的 Pod 模板等等。 每个 ReplicaSet 都通过根据需要创建和删除 Pod 以使得副本个数达到期望值， 进而实现其存在价值。当 ReplicaSet 需要创建新的 Pod 时，会使用所提供的 Pod 模板。
StatefulSet：有状态控制器，主要是为了创建有状态的服务，比如说mysql，redis等这些需要验证主从关系、复制关系等有状态的pod。表现形式一般就是yml文件的kind: StatefulSet
DeamonSet：在全部（或者某些）节点上运行一个 Pod 的副本。 当有节点加入集群时， 也会为他们新增一个 Pod 。 当有节点从集群移除时，这些 Pod 也会被回收。删除 DaemonSet 将会删除它创建的所有 Pod。主要用于收集每个节点的日志信息。
Job：Job 会创建一个或者多个 Pod，并将继续重试 Pod 的执行，直到指定数量的 Pod 成功终止。 随着 Pod 成功结束，Job 跟踪记录成功完成的 Pod 个数。 当数量达到指定的成功个数阈值时，任务（即 Job）结束。 删除 Job 的操作会清除所创建的全部 Pod。 挂起 Job 的操作会删除 Job 的所有活跃 Pod，直到 Job 被再次恢复执行。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/51ed1bb84dbaf1b7df4ca9f64809e472/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-10-31T14:56:02+08:00" />
<meta property="article:modified_time" content="2022-10-31T14:56:02+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">K8S的控制器Deployment,ReplicaSet,StatefulSet,CronJob,最小单位pod</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>K8S的控制器Deployment,ReplicaSet,StatefulSet,CronJob,最小单位pod</h4> 
 <ul><li><a href="#K8S_1" rel="nofollow">K8S的控制器</a></li><li><a href="#1Deploymenpod_24" rel="nofollow">1、Deploymen控制器（常用pod控制器）</a></li><li><a href="#2ReplicaSetpod_72" rel="nofollow">2、ReplicaSet控制器（实现pod数量控制）</a></li><li><a href="#3StatefulSet_107" rel="nofollow">3、StatefulSet控制器（有状态服务控制器）</a></li><li><ul><li><a href="#31_masterpv_140" rel="nofollow">3.1 master创建pv存储池</a></li><li><a href="#32_masterconfigmap_184" rel="nofollow">3.2 master创建configmap保存配置文件</a></li><li><a href="#33_mastersecretredis_258" rel="nofollow">3.3 master创建secret保存redis密码</a></li><li><a href="#34_masterservice_274" rel="nofollow">3.4 master创建service</a></li><li><a href="#35_masterStatefulSetpod_309" rel="nofollow">3.5 master通过StatefulSet创建pod</a></li><li><a href="#36_redis_398" rel="nofollow">3.6 测试redis主从</a></li></ul> 
  </li><li><a href="#4DaemonSetpod_429" rel="nofollow">4、DaemonSet控制器（主要用于每个节点创建守护pod进程）</a></li><li><a href="#5Job_472" rel="nofollow">5、Job控制器（一次性任务控制器）</a></li><li><a href="#6CronJob_502" rel="nofollow">6、CronJob控制器（定时任务控制器）</a></li><li><a href="#7k8spodpod_552" rel="nofollow">7、k8s最小单位pod（单实例pod）</a></li></ul> 
</div> 
<p></p> 
<h2><a id="K8S_1"></a>K8S的控制器</h2> 
<p>Deployment：无状态控制器，主要可以创建无状态的服务，比如说nginx，Apache等这些不用创建主从、主主等状态的pod，还支持滚动升级，回滚等高级功能，默认创建pod的控制器。表现形式一般就是yml文件的kind: Deployment</p> 
<p>ReplicaSet：ReplicaSet 是通过一组字段来定义的，包括一个用来识别可获得的 Pod 的集合的选择算符、一个用来标明应该维护的副本个数的数值、一个用来指定应该创建新 Pod 以满足副本个数条件时要使用的 Pod 模板等等。 每个 ReplicaSet 都通过根据需要创建和删除 Pod 以使得副本个数达到期望值， 进而实现其存在价值。当 ReplicaSet 需要创建新的 Pod 时，会使用所提供的 Pod 模板。</p> 
<p>StatefulSet：有状态控制器，主要是为了创建有状态的服务，比如说mysql，redis等这些需要验证主从关系、复制关系等有状态的pod。表现形式一般就是yml文件的kind: StatefulSet</p> 
<p>DeamonSet：在全部（或者某些）节点上运行一个 Pod 的副本。 当有节点加入集群时， 也会为他们新增一个 Pod 。 当有节点从集群移除时，这些 Pod 也会被回收。删除 DaemonSet 将会删除它创建的所有 Pod。主要用于收集每个节点的日志信息。</p> 
<p>Job：Job 会创建一个或者多个 Pod，并将继续重试 Pod 的执行，直到指定数量的 Pod 成功终止。 随着 Pod 成功结束，Job 跟踪记录成功完成的 Pod 个数。 当数量达到指定的成功个数阈值时，任务（即 Job）结束。 删除 Job 的操作会清除所创建的全部 Pod。 挂起 Job 的操作会删除 Job 的所有活跃 Pod，直到 Job 被再次恢复执行。</p> 
<p>CronJob：一个 CronJob 对象就像 crontab (cron table) 文件中的一行。 它用 Cron 格式进行编写， 并周期性地在给定的调度时间执行 Job。</p> 
<p>搭建K8S文档：<a href="https://blog.csdn.net/DLWH_HWLD/article/details/122177139">yum安装K8S</a><br> ansible搭建K8S集群：<a href="https://blog.csdn.net/DLWH_HWLD/article/details/122177164">ansible搭建K8S</a><br> 准备至少3个机器搭建好K8S集群测试调度</p> 
<table><thead><tr><th>节点名称</th><th>IP</th></tr></thead><tbody><tr><td>nfs-server</td><td>192.168.116.130</td></tr><tr><td>k8s-master</td><td>192.168.116.131</td></tr><tr><td>k8s-node1</td><td>192.168.116.132</td></tr><tr><td>k8s-node2</td><td>192.168.116.133</td></tr></tbody></table> 
<h2><a id="1Deploymenpod_24"></a>1、Deploymen控制器（常用pod控制器）</h2> 
<p>官网：<a href="https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/deployment/" rel="nofollow">deployment</a></p> 
<p>Deployment主要作用:</p> 
<ul><li>创建 Deployment 以将 ReplicaSet 上线。ReplicaSet 在后台创建 Pod。 检查 ReplicaSet<br> 的上线状态，查看其是否成功。</li><li>通过更新 Deployment 的 PodTemplateSpec，声明 Pod 的新状态 。 新的 ReplicaSet<br> 会被创建，Deployment 以受控速率将 Pod 从旧 ReplicaSet 迁移到新 ReplicaSet。 每个新的<br> ReplicaSet 都会更新 Deployment 的修订版本。</li><li>如果 Deployment 的当前状态不稳定，回滚到较早的 Deployment 版本。 每次回滚都会更新 Deployment<br> 的修订版本。</li><li>扩大 Deployment 规模以承担更多负载。</li><li>暂停 Deployment 以应用对 PodTemplateSpec 所作的多项修改， 然后恢复其执行以启动新的上线版本。</li><li>使用 Deployment 状态来判定上线过程是否出现停滞。</li><li>清理较旧的不再需要的 ReplicaSet 。</li></ul> 
<p>Deploymen创建pod</p> 
<pre><code class="prism language-bash"><span class="token function">vi</span> nginx.yml

apiVersion: apps/v1
kind: Deployment          <span class="token comment">#指定控制器的类型</span>
metadata:
  labels:
    app: nginx
  name: nginx-deployment  <span class="token comment">#指定控制器的名称</span>
  namespace: default
spec:
  replicas: <span class="token number">1</span>
  selector:
    matchLabels:
      app: nginx
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: nginx:1.23.2

kubectl apply -f Deploymen.yml  创建pod
kubectl get pod -n default   查看pod
</code></pre> 
<p><img src="https://images2.imgbox.com/e5/aa/gzQH6RaN_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="2ReplicaSetpod_72"></a>2、ReplicaSet控制器（实现pod数量控制）</h2> 
<p>官网文档：<a href="https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/replicaset/" rel="nofollow">ReplicaSet</a></p> 
<p>ReplicaSet 确保任何时间都有指定数量的 Pod 副本在运行。 然而，Deployment 是一个更高级的概念，它管理 ReplicaSet，并向 Pod 提供声明式的更新以及许多其他有用的功能。 因此，我们建议使用 Deployment 而不是直接使用 ReplicaSet， 除非你需要自定义更新业务流程或根本不需要更新。这实际上意味着，你可能永远不需要操作 ReplicaSet 对象：而是使用 Deployment，并在 spec 部分定义你的应用。</p> 
<pre><code class="prism language-bash"><span class="token function">vi</span> ReplicaSet.yml

apiVersion: apps/v1
kind: ReplicaSet     <span class="token comment">#指定控制器的类型</span>
metadata:
  name: frontend     <span class="token comment">#指定控制器的名称</span>
  labels:
    app: guestbook
    tier: frontend
spec:
  <span class="token comment">#实际作用就是下面这个控制pod的数量</span>
  replicas: <span class="token number">3</span>
  selector:
    matchLabels:
      tier: frontend
  template:
    metadata:
      labels:
        tier: frontend
    spec:
      containers:
      - name: nginx
        image: nginx:1.23.2

kubectl apply -f ReplicaSet.yml
kubectl get pod -n default 
</code></pre> 
<p><img src="https://images2.imgbox.com/e3/57/o1sbWvQM_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="3StatefulSet_107"></a>3、StatefulSet控制器（有状态服务控制器）</h2> 
<p>官网文档：<a href="https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/statefulset/" rel="nofollow">StatefulSet</a><br> StatefulSet 是用来管理有状态应用的工作负载 API 对象。<br> StatefulSet 用来管理某 Pod 集合的部署和扩缩， 并为这些 Pod 提供持久存储和持久标识符。和 Deployment 类似， StatefulSet 管理基于相同容器规约的一组 Pod。但和 Deployment 不同的是， StatefulSet 为它们的每个 Pod 维护了一个有粘性的 ID。这些 Pod 是基于相同的规约来创建的， 但是不能相互替换：无论怎么调度，每个 Pod 都有一个永久不变的 ID。</p> 
<p>StatefulSet 对于需要满足以下一个或多个需求的应用程序很有价值：</p> 
<ul><li>稳定的、唯一的网络标识符。</li><li>稳定的、持久的存储。</li><li>有序的、优雅的部署和扩缩。</li><li>有序的、自动的滚动更新。</li></ul> 
<p>在上面描述中，“稳定的”意味着 Pod 调度或重调度的整个过程是有持久性的。 如果应用程序不需要任何稳定的标识符或有序的部署、删除或扩缩， 则应该使用由一组无状态的副本控制器提供的工作负载来部署应用程序，比如 Deployment 或者 ReplicaSet 可能更适用于你的无状态应用部署需要。</p> 
<p>StatefulSet搭建redis有状态pod<br> 选一台设备当做NFS服务，创建目录挂载</p> 
<pre><code class="prism language-bash">yum <span class="token function">install</span> -y nfs-utils   安装NFS

创建2个目录
<span class="token function">mkdir</span> /data/redis0 -p
<span class="token function">mkdir</span> /data/redis1 -p

<span class="token function">vi</span> /etc/exports  配置挂载

/data/redis0 *<span class="token punctuation">(</span>rw,no_root_squash<span class="token punctuation">)</span>
/data/redis1 *<span class="token punctuation">(</span>rw,no_root_squash<span class="token punctuation">)</span>


systemctl restart nfs-server
systemctl <span class="token builtin class-name">enable</span> nfs-server

</code></pre> 
<h3><a id="31_masterpv_140"></a>3.1 master创建pv存储池</h3> 
<p>pv介绍文档：<a href="https://blog.csdn.net/DLWH_HWLD/article/details/125101691">k8s-存储池</a><br> master创建pv</p> 
<pre><code class="prism language-bash">yum <span class="token function">install</span> -y nfs-utils   安装NFS插件，master和node都要安装
showmount -e <span class="token number">192.168</span>.116.130  确保每台设备都有限制挂载目录


<span class="token function">mkdir</span> redis   创建文件夹保存yml文件
<span class="token builtin class-name">cd</span> redis
<span class="token function">vi</span> redis-pv.yml       创建pv

apiVersion: v1
kind: PersistentVolume
metadata:
  name: redis-pv-0
  namespace: default
spec:
  capacity:
    storage: 10Gi
  accessModes:
    - ReadWriteOnce
  nfs:
    server: <span class="token number">192.168</span>.116.130
    path: /data/redis0
---
apiVersion: v1
kind: PersistentVolume
metadata:
  name: redis-pv-1
  namespace: default
spec:
  capacity:
    storage: 10Gi
  accessModes:
    - ReadWriteOnce
  nfs:
    server: <span class="token number">192.168</span>.116.130
    path: /data/redis1

</code></pre> 
<p><img src="https://images2.imgbox.com/d7/9c/GN0DULwt_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="32_masterconfigmap_184"></a>3.2 master创建configmap保存配置文件</h3> 
<pre><code class="prism language-bash"><span class="token function">vi</span> redis-configmap.yml

apiVersion: v1
kind: ConfigMap
metadata:
  name: redis-configmap <span class="token comment">#定义configmap名字</span>
  namespace: default   <span class="token comment">#pod和configmap要在同一个名称空间中</span>
  labels:
    app: redis-configmap
data:
  redis.conf: <span class="token operator">|</span>
    <span class="token builtin class-name">bind</span> <span class="token number">0.0</span>.0.0
    protected-mode <span class="token function">yes</span>
    port <span class="token number">6379</span>
    tcp-backlog <span class="token number">511</span>
    <span class="token function">timeout</span> <span class="token number">0</span>
    tcp-keepalive <span class="token number">300</span>
    daemonize no
    supervised no
    pidfile /var/run/redis.pid
    loglevel notice
    logfile <span class="token string">"/data/redis.log"</span>
    databases <span class="token number">16</span>
    always-show-logo <span class="token function">yes</span>
    save <span class="token number">900</span> <span class="token number">1</span>
    save <span class="token number">300</span> <span class="token number">10</span>
    save <span class="token number">60</span> <span class="token number">10000</span>
    stop-writes-on-bgsave-error no
    rdbcompression <span class="token function">yes</span>
    rdbchecksum <span class="token function">yes</span>
    dbfilename dump.rdb
    <span class="token function">dir</span> /data
    slave-serve-stale-data <span class="token function">yes</span>
    slave-read-only <span class="token function">yes</span>
    repl-diskless-sync no
    repl-diskless-sync-delay <span class="token number">5</span>
    repl-disable-tcp-nodelay no
    slave-priority <span class="token number">100</span>
    lazyfree-lazy-eviction no
    lazyfree-lazy-expire no
    lazyfree-lazy-server-del no
    slave-lazy-flush no
    appendonly <span class="token function">yes</span>
    appendfilename <span class="token string">"appendonly.aof"</span>
    appendfsync everysec
    no-appendfsync-on-rewrite no
    auto-aof-rewrite-percentage <span class="token number">100</span>
    auto-aof-rewrite-min-size 64mb
    aof-load-truncated <span class="token function">yes</span>
    aof-use-rdb-preamble no
    lua-time-limit <span class="token number">5000</span>
    slowlog-log-slower-than <span class="token number">10000</span>
    slowlog-max-len <span class="token number">128</span>
    latency-monitor-threshold <span class="token number">0</span>
    notify-keyspace-events <span class="token string">""</span>
    hash-max-ziplist-entries <span class="token number">512</span>
    hash-max-ziplist-value <span class="token number">64</span>
    list-max-ziplist-size -2
    list-compress-depth <span class="token number">0</span>
    set-max-intset-entries <span class="token number">512</span>
    zset-max-ziplist-entries <span class="token number">128</span>
    zset-max-ziplist-value <span class="token number">64</span>
    hll-sparse-max-bytes <span class="token number">3000</span>
    activerehashing <span class="token function">yes</span>
    client-output-buffer-limit normal <span class="token number">0</span> <span class="token number">0</span> <span class="token number">0</span>
    client-output-buffer-limit slave 256mb 64mb <span class="token number">60</span>
    client-output-buffer-limit pubsub 32mb 8mb <span class="token number">60</span>
    hz <span class="token number">10</span>
    aof-rewrite-incremental-fsync <span class="token function">yes</span>

</code></pre> 
<h3><a id="33_mastersecretredis_258"></a>3.3 master创建secret保存redis密码</h3> 
<pre><code class="prism language-bash"><span class="token builtin class-name">echo</span> -n <span class="token string">"admin"</span> <span class="token operator">|</span>base64   密码转换为base64

<span class="token function">vi</span> redis-secret.yml

apiVersion: v1
kind: Secret
metadata:
  name: redis-secret
type: Opaque
data:
  pass: YWRtaW4K   <span class="token comment">#定义键值对</span>

</code></pre> 
<h3><a id="34_masterservice_274"></a>3.4 master创建service</h3> 
<pre><code class="prism language-bash"><span class="token function">vi</span> redis-service.yml

apiVersion: v1       <span class="token comment">#创建Headless Service</span>
kind: Service
metadata:
  name: redis-svc
  labels:
    app: redis-svc
spec:
  selector:
    app: redis    <span class="token comment">#绑定pod的spec.selector.matchLabels.app: redis</span>
  ports:
  - name: redis-service  <span class="token comment">#绑定pod的ports</span>
    port: <span class="token number">6379</span>
  clusterIP: None
---
apiVersion: v1   <span class="token comment">#创建对外端口</span>
kind: Service
metadata:
  name: redis-access-svc
  labels:
    app: redis-access-svc
spec:
  type: NodePort
  selector:
    app: redis
  ports:
  - name: redis-nodeport
    port: <span class="token number">6379</span>
    targetPort: <span class="token number">6379</span>
    nodePort: <span class="token number">30079</span>   <span class="token comment">#注意K8S开放的端口范围</span>

</code></pre> 
<h3><a id="35_masterStatefulSetpod_309"></a>3.5 master通过StatefulSet创建pod</h3> 
<pre><code class="prism language-bash"><span class="token function">vi</span> redis-StatefulSet.yml

apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: redis
spec:
  selector:
    matchLabels:
      app: redis
  serviceName: <span class="token string">"redis-svc"</span>  <span class="token comment">#绑定Headless Service名字</span>
  replicas: <span class="token number">2</span>               <span class="token comment">#创建2个，制作主从</span>
  template:
    metadata:
      labels:
        app: redis
    spec:
      containers:
      - name: redis
        image: redis:4.0.6
        env:
          - name: redispass  <span class="token comment">#实际镜像使用就是这个变量名字</span>
            valueFrom:
              secretKeyRef:
                name: redis-secret  <span class="token comment">#绑定上面创建的secret名字</span>
                key: pass           <span class="token comment">#绑定key</span>
        resources:
          limits:
            cpu: 500m
            memory: 1Gi
          requests:
            cpu: 500m
            memory: 1Gi
        ports:
        - containerPort: <span class="token number">6379</span>
          protocol: TCP
          name: redis-service    <span class="token comment">#对应创建的service名称</span>
        - containerPort: <span class="token number">6379</span>
          protocol: TCP
          name: redis-nodeport
        command:
        - <span class="token function">bash</span>
        - <span class="token string">"-c"</span>
        - <span class="token operator">|</span>
          <span class="token builtin class-name">set</span> -ex
          <span class="token punctuation">[</span><span class="token punctuation">[</span> <span class="token variable"><span class="token variable">`</span><span class="token function">hostname</span><span class="token variable">`</span></span> <span class="token operator">=~</span> -<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0</span>-9<span class="token punctuation">]</span>+<span class="token punctuation">)</span>$ <span class="token punctuation">]</span><span class="token punctuation">]</span>
          <span class="token assign-left variable">ordinal</span><span class="token operator">=</span><span class="token variable">${<!-- --><span class="token environment constant">BASH_REMATCH</span><span class="token punctuation">[</span>1<span class="token punctuation">]</span>}</span>
          <span class="token comment">#通过hostname制作主从文件</span>
          <span class="token keyword">if</span> <span class="token punctuation">[</span><span class="token punctuation">[</span> <span class="token variable">$ordinal</span> -eq <span class="token number">0</span> <span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
            <span class="token function">mkdir</span> /data/etc -p
            <span class="token function">cp</span> /etc/redis/redis.conf /data/etc/redis.conf
            <span class="token builtin class-name">echo</span> <span class="token string">"requirepass <span class="token variable">${redispass}</span>"</span> <span class="token operator">&gt;&gt;</span>/data/etc/redis.conf
            redis-server /data/etc/redis.conf
          <span class="token keyword">else</span>
            <span class="token function">mkdir</span> /data/etc -p
            <span class="token function">cp</span> /etc/redis/redis.conf /data/etc/redis.conf
            <span class="token builtin class-name">echo</span> <span class="token string">"masterauth <span class="token variable">${redispass}</span>"</span> <span class="token operator">&gt;&gt;</span>/data/etc/redis.conf
            <span class="token builtin class-name">echo</span> <span class="token string">"slaveof redis-0.redis-svc 6379"</span> <span class="token operator">&gt;&gt;</span>/data/etc/redis.conf
            redis-server /data/etc/redis.conf
          <span class="token keyword">fi</span>
        volumeMounts:
        - name: conf
          mountPath: <span class="token string">"/etc/redis"</span>
        - name: data
          mountPath: /data
      volumes:
      - name: conf               <span class="token comment">#对应上面的volumeMounts的conf</span>
        configMap:
          name: redis-configmap  <span class="token comment">#指定名字，绑定上面创建的configmap</span>
  volumeClaimTemplates:          <span class="token comment">#动态选择pv存储池</span>
  - metadata:
      name: data                 <span class="token comment">#对应上面volumeMounts的data</span>
    spec:
      accessModes: <span class="token punctuation">[</span><span class="token string">"ReadWriteOnce"</span><span class="token punctuation">]</span>
      resources:
        requests:
          storage: 10Gi
          
kubectl apply -f <span class="token builtin class-name">.</span>   将当前目录下的yml文件创建
kubectl get pvc -A   查看pvc和pv绑定
kubectl get svc -A   查看service
kubectl get pod -A   查看pod

</code></pre> 
<p><img src="https://images2.imgbox.com/1e/4d/lvQNmyb0_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="36_redis_398"></a>3.6 测试redis主从</h3> 
<p>连接主redis</p> 
<pre><code class="prism language-bash">kubectl <span class="token builtin class-name">exec</span> -it redis-0 /bin/bash 连接主pod

redis-cli -a admin   连接redis
<span class="token builtin class-name">set</span> a1 aa            设置键值对
info                 查看主从状态

</code></pre> 
<p><img src="https://images2.imgbox.com/fa/d0/rGmBhecm_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/bf/8a/Uya9Up4c_o.png" alt="在这里插入图片描述"><br> 连接从redis</p> 
<pre><code class="prism language-bash">kubectl <span class="token builtin class-name">exec</span> -it redis-1 /bin/bash   连接从pod
redis-cli -a admin
get a1                            可以看到a1的值可以获取到，证明主从成功
info                              查看主从状态
</code></pre> 
<p><img src="https://images2.imgbox.com/1f/a1/nSGomkPS_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/94/84/RxoWhWQt_o.png" alt="在这里插入图片描述"></p> 
<p>在NFS服务器连接redis</p> 
<pre><code class="prism language-bash">ll /data/redis0/    查看redis文件
ll /data/redis1/
</code></pre> 
<p><img src="https://images2.imgbox.com/7e/ca/WKOpcxgp_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="4DaemonSetpod_429"></a>4、DaemonSet控制器（主要用于每个节点创建守护pod进程）</h2> 
<p>官网文档：<a href="https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/daemonset/" rel="nofollow">DaemonSet</a></p> 
<p>DaemonSet 的一些典型用法：</p> 
<ul><li>在每个节点上运行集群守护进程</li><li>在每个节点上运行日志收集守护进程</li><li>在每个节点上运行监控守护进程</li></ul> 
<p>一种简单的用法是为每种类型的守护进程在所有的节点上都启动一个 DaemonSet。 一个稍微复杂的用法是为同一种守护进程部署多个 DaemonSet；每个具有不同的标志， 并且对不同硬件类型具有不同的内存、CPU 要求。</p> 
<p>通过elk搭建日志监控集群文档：<a href="https://blog.csdn.net/DLWH_HWLD/article/details/122177081">真机搭建elk</a></p> 
<p>通过DaemonSet创建pod</p> 
<pre><code class="prism language-bash"><span class="token function">vi</span> DaemonSet.yml     用DaemonSet创建pod时，k8s的每个节点都会创建一个pod

apiVersion: apps/v1
kind: DaemonSet
metadata:
  name: filebeat
  namespace: default
  labels:
    k8s-app: filebeat
spec:
  selector:
    matchLabels:
      name: filebeat
  template:
    metadata:
      labels:
        name: filebeat
    spec:
      containers:
      - name: filebeat
        image: docker.elastic.co/beats/filebeat:8.4.3

kubectl apply -f DaemonSet.yml 
kubectl get pod -n default -o wide
</code></pre> 
<p><img src="https://images2.imgbox.com/9a/8c/v1To4KWe_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="5Job_472"></a>5、Job控制器（一次性任务控制器）</h2> 
<p>官网文档：<a href="https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/job/" rel="nofollow">Job</a></p> 
<p>Job 会创建一个或者多个 Pod，并将继续重试 Pod 的执行，直到指定数量的 Pod 成功终止。 随着 Pod 成功结束，Job 跟踪记录成功完成的 Pod 个数。 当数量达到指定的成功个数阈值时，任务（即 Job）结束。 删除 Job 的操作会清除所创建的全部 Pod。 挂起 Job 的操作会删除 Job 的所有活跃 Pod，直到 Job 被再次恢复执行。</p> 
<p>用job控制器创建一个任务</p> 
<pre><code class="prism language-bash"><span class="token function">vi</span> job.yml

apiVersion: batch/v1
kind: Job
metadata:
  name: pi
spec:
  template:
    spec:
      containers:
      - name: pi
        image: perl:5.34.0
        command: <span class="token punctuation">[</span><span class="token string">"perl"</span>,  <span class="token string">"-Mbignum=bpi"</span>, <span class="token string">"-wle"</span>, <span class="token string">"print bpi(2000)"</span><span class="token punctuation">]</span>
      restartPolicy: Never
  backoffLimit: <span class="token number">4</span>

创建任务，计算 π 到小数点后 <span class="token number">2000</span> 位
kubectl apply -f job.yml 
kubectl logs -f pi-kt7fn     在日志可以看到计算完成的信息
kubectl get pod -n default   当STATUS为Completed时，证明任务完成，可以查看完结果删除
</code></pre> 
<p><img src="https://images2.imgbox.com/ac/cd/BKKBgCPY_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="6CronJob_502"></a>6、CronJob控制器（定时任务控制器）</h2> 
<p>官网文档：<a href="https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/cron-jobs/" rel="nofollow">CronJob</a></p> 
<p>CronJob 用于执行周期性的动作，例如备份、报告生成等。 这些任务中的每一个都应该配置为周期性重复的（例如：每天/每周/每月一次）； 你可以定义任务开始执行的时间间隔。</p> 
<p>注意：</p> 
<ul><li>所有 CronJob 的 schedule: 时间都是基于 kube-controller-manager. 的时区。</li><li>如果你的控制平面在 Pod 或是裸容器中运行了 kube-controller-manager， 那么为该容器所设置的时区将会决定<br> Cron Job 的控制器所使用的时区。</li><li>Kubernetes 项目官方并不支持设置如 CRON_TZ 或者 TZ 等变量。 CRON_TZ 或者 TZ 是用于解析和计算下一个<br> Job 创建时间所使用的内部库中一个实现细节。 不建议在生产集群中使用它。</li></ul> 
<p>CronJob控制器实际就是创建当任务触发时，通过job控制器生成一个pod进行操作，默认会保留最近3个pod。<br> 用CronJob控制器创建pod</p> 
<pre><code class="prism language-bash"><span class="token function">vi</span> CronJob.yml

<span class="token comment">#apiVersion: batch/v1   当k8s版本为1.21时，用这个api</span>
apiVersion: batch/v1beta1 <span class="token comment">#当k8s版本小于1.21时，用这个api</span>
kind: CronJob
metadata:
  name: hello
spec:
  schedule: <span class="token string">"* * * * *"</span>
  jobTemplate:
    spec:
      template:
        spec:
          containers:
          - name: hello
            image: busybox:1.28
            imagePullPolicy: IfNotPresent
            command:
            - /bin/sh
            - -c
            - <span class="token function">date</span><span class="token punctuation">;</span> <span class="token builtin class-name">echo</span> Hello from the Kubernetes cluster
          restartPolicy: OnFailure

kubectl apply -f CronJob.yml             创建定时任务pod
kubectl get pod -n default 
kubectl logs -f hello-1667197860-j8ntj -n default  查看第一个一次性任务的pod的日志时间

通过status为Completed状态时，可以看到job任务完成了

kubectl get pod -n default 
kubectl logs -f hello-1667197920-fjfwc         查看第二个一次性任务的pod的日志时间
</code></pre> 
<p><img src="https://images2.imgbox.com/93/67/9N6bPz2K_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="7k8spodpod_552"></a>7、k8s最小单位pod（单实例pod）</h2> 
<p>官网文档：<a href="https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/" rel="nofollow">pod</a></p> 
<p>Deployment,ReplicaSet,StatefulSet,job,CronJob这些控制器实际就是通过各种条件控制pod的各种状态、形式、结构进行变化。<br> 通常你不需要直接创建 Pod，甚至单实例 Pod。 相反，你会使用诸如 Deployment 或 Job 这类工作负载资源来创建 Pod。 如果 Pod 需要跟踪状态，可以考虑 StatefulSet 资源。</p> 
<p>Kubernetes 集群中的 Pod 主要有两种用法：</p> 
<ul><li>运行单个容器的 Pod。“每个 Pod 一个容器” 模型是最常见的 Kubernetes 用例； 在这种情况下，可以将 Pod<br> 看作单个容器的包装器，并且 Kubernetes 直接管理 Pod，而不是容器。</li><li>运行多个协同工作的容器的 Pod。 Pod 可能封装由多个紧密耦合且需要共享资源的共处容器组成的应用程序。<br> 这些位于同一位置的容器可能形成单个内聚的服务单元 —— 一个容器将文件从共享卷提供给公众， 而另一个单独的<br> “边车”（sidecar）容器则刷新或更新这些文件。 Pod 将这些容器和存储资源打包为一个可管理的实体。</li></ul> 
<p>创建单个pod</p> 
<pre><code class="prism language-bash"><span class="token function">vi</span> pod.yml

apiVersion: v1
kind: Pod
metadata:
  name: nginx
spec:
  containers:
  - name: nginx
    image: nginx:1.23.2

kubectl apply -f pod.yml
kubectl get pod -n default 
</code></pre> 
<p><img src="https://images2.imgbox.com/5e/d0/mTA4khU5_o.png" alt="在这里插入图片描述"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d121dde1f58bbd5dae39152d4defec12/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Unity官方FPS教程解析（一）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/306888b86d0358bd7d50c95fbd0b5c0d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">关于tensor的reshape操作</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>