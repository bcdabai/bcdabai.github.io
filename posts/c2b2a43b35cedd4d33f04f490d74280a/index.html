<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Python学习--QtPy系列2（信号和事件） - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Python学习--QtPy系列2（信号和事件）" />
<meta property="og:description" content="事件 所有的GUI应用都是事件驱动的。事件主要由应用的用户操作产生的。但是事件可能由其他条件触发，比如：一个网络连接，一个窗口管理器，一个定时器，这些动作都可能触发事件的产生。当我们调用应用的exec_()方法时，应用进入了主循环。主循环用于检测事件的产生并且将事件送到用于处理的对象中去。 在事件模型，有三个参与者
事件源事件对象事件目标
事件源是状态发生改变的对象。它产生了事件。事件对象(evnet)封装了事件源中的状态变化。事件目标是想要被通知的对象。事件源对象代表了处理一个事件直到事件目标做出响应的任务。 PyQt5有一个独一无二的信号和槽机制来处理事件。信号和槽用于对象之间的通信。当指定事件发生，一个事件信号会被发射。槽可以被任何Python脚本调用。当和槽连接的信号被发射时，槽会被调用。
import sys #系统模块 from PyQt5.QtCore import Qt #Qt模块 from PyQt5.QtWidgets import (QWidget, QLCDNumber, QSlider, QVBoxLayout, QApplication) #导入QWidget, QLCDNumber, QSlider,QVBoxLayout, QApplication等模块 class Example(QWidget): def __init__(self): super().__init__() #继承父类构造函数 self.initUI() #初始化UI def initUI(self): lcd = QLCDNumber(self) sld = QSlider(Qt.Horizontal, self) vbox = QVBoxLayout() vbox.addWidget(lcd) vbox.addWidget(sld) self.setLayout(vbox) sld.valueChanged.connect(lcd.display) self.setGeometry(300, 300, 250, 150) self.setWindowTitle(&#39;Signal &amp; slot&#39;) self.show() if __name__ == &#39;__main__&#39;: app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) sld." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/c2b2a43b35cedd4d33f04f490d74280a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-05-08T22:53:27+08:00" />
<meta property="article:modified_time" content="2018-05-08T22:53:27+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Python学习--QtPy系列2（信号和事件）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h4 id="事件">事件</h4> 
<p>所有的GUI应用都是事件驱动的。事件主要由应用的用户操作产生的。但是事件可能由其他条件触发，比如：一个网络连接，一个窗口管理器，一个定时器，这些动作都可能触发事件的产生。当我们调用应用的exec_()方法时，应用进入了主循环。主循环用于检测事件的产生并且将事件送到用于处理的对象中去。 <br> 在事件模型，有三个参与者</p> 
<ol><li>事件源</li><li>事件对象</li><li><p>事件目标</p> <p>事件源是状态发生改变的对象。它产生了事件。事件对象(evnet)封装了事件源中的状态变化。事件目标是想要被通知的对象。事件源对象代表了处理一个事件直到事件目标做出响应的任务。 <br> PyQt5有一个独一无二的信号和槽机制来处理事件。信号和槽用于对象之间的通信。当指定事件发生，一个事件信号会被发射。槽可以被任何Python脚本调用。当和槽连接的信号被发射时，槽会被调用。</p></li></ol> 
<pre class="prettyprint"><code class=" hljs python"><span class="hljs-keyword">import</span> sys   <span class="hljs-comment">#系统模块</span>
<span class="hljs-keyword">from</span> PyQt5.QtCore <span class="hljs-keyword">import</span> Qt  <span class="hljs-comment">#Qt模块</span>
<span class="hljs-keyword">from</span> PyQt5.QtWidgets <span class="hljs-keyword">import</span> (QWidget, QLCDNumber, QSlider,
    QVBoxLayout, QApplication)  
    <span class="hljs-comment">#导入QWidget, QLCDNumber, QSlider,QVBoxLayout, QApplication等模块</span>


<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Example</span><span class="hljs-params">(QWidget)</span>:</span>

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self)</span>:</span>
        super().__init__()  <span class="hljs-comment">#继承父类构造函数</span>
        self.initUI()       <span class="hljs-comment">#初始化UI</span>

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">initUI</span><span class="hljs-params">(self)</span>:</span> 
        lcd = QLCDNumber(self)  
        sld = QSlider(Qt.Horizontal, self) 
        vbox = QVBoxLayout()
        vbox.addWidget(lcd)
        vbox.addWidget(sld) 
        self.setLayout(vbox)
        sld.valueChanged.connect(lcd.display) 
        self.setGeometry(<span class="hljs-number">300</span>, <span class="hljs-number">300</span>, <span class="hljs-number">250</span>, <span class="hljs-number">150</span>)
        self.setWindowTitle(<span class="hljs-string">'Signal &amp; slot'</span>)
        self.show()


<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:

    app = QApplication(sys.argv)
    ex = Example()
    sys.exit(app.exec_())</code></pre> 
<p>sld.valueChanged.connect(lcd.display) <br> 将滑块条的valueChanged信号和lcd数字显示的display槽连接在一起。发送者是一个发送了信号的对象。接受者是一个接受了信号的对象。槽是对信号做出反应的方法。</p> 
<pre class="prettyprint"><code class=" hljs python"><span class="hljs-keyword">import</span> sys
<span class="hljs-keyword">from</span> PyQt5.QtCore <span class="hljs-keyword">import</span> Qt
<span class="hljs-keyword">from</span> PyQt5.QtWidgets <span class="hljs-keyword">import</span> QWidget, QApplication


<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Example</span><span class="hljs-params">(QWidget)</span>:</span> 
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self)</span>:</span>
        super().__init__() 
        self.initUI() 
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">initUI</span><span class="hljs-params">(self)</span>:</span>  
        self.setGeometry(<span class="hljs-number">300</span>, <span class="hljs-number">300</span>, <span class="hljs-number">250</span>, <span class="hljs-number">150</span>)
        self.setWindowTitle(<span class="hljs-string">'Event handler'</span>)
        self.show() 
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">keyPressEvent</span><span class="hljs-params">(self, e)</span>:</span> 
        <span class="hljs-keyword">if</span> e.key() == Qt.Key_Escape:
            self.close()


<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:

    app = QApplication(sys.argv)
    ex = Example()
    sys.exit(app.exec_())</code></pre> 
<p>重写了keyPressEvent()事件处理函数。如果我们点击了Esc按钮，应用将会被终止。</p> 
<h4 id="事件发送者">事件发送者</h4> 
<p>有时需要方便的知道哪一个组件是信号发送者。因此，PyQt5拥有了sender()方法来解决这个问题。</p> 
<pre class="prettyprint"><code class=" hljs python">
<span class="hljs-keyword">import</span> sys
<span class="hljs-keyword">from</span> PyQt5.QtWidgets <span class="hljs-keyword">import</span> QMainWindow, QPushButton, QApplication


<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Example</span><span class="hljs-params">(QMainWindow)</span>:</span>

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self)</span>:</span>
        super().__init__()

        self.initUI()


    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">initUI</span><span class="hljs-params">(self)</span>:</span>     

        btn1 = QPushButton(<span class="hljs-string">"Button 1"</span>, self)
        btn1.move(<span class="hljs-number">30</span>, <span class="hljs-number">50</span>)

        btn2 = QPushButton(<span class="hljs-string">"Button 2"</span>, self)
        btn2.move(<span class="hljs-number">150</span>, <span class="hljs-number">50</span>)

        btn1.clicked.connect(self.buttonClicked)           
        btn2.clicked.connect(self.buttonClicked)

        self.statusBar()

        self.setGeometry(<span class="hljs-number">300</span>, <span class="hljs-number">300</span>, <span class="hljs-number">290</span>, <span class="hljs-number">150</span>)
        self.setWindowTitle(<span class="hljs-string">'Event sender'</span>)
        self.show()


    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">buttonClicked</span><span class="hljs-params">(self)</span>:</span>

        sender = self.sender()
        self.statusBar().showMessage(sender.text() + <span class="hljs-string">' was pressed'</span>)


<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:

    app = QApplication(sys.argv)
    ex = Example()
    sys.exit(app.exec_())
</code></pre> 
<p>在我们的例子中，我们有两个按钮。在buttonClikced()方法中，我们调用sender()方法来判断哪一个按钮是我们按下的。 <br> btn1.clicked.connect(self.buttonClicked) <br> btn2.clicked.connect(self.buttonClicked) <br> 两个按钮都连接到了同一个槽中。</p> 
<pre class="prettyprint"><code class=" hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">buttonClicked</span><span class="hljs-params">(self)</span>:</span> 
    sender = self.sender()
    self.statusBar().showMessage(sender.text() + <span class="hljs-string">' was pressed'</span>)</code></pre> 
<p>我们调用sender()方法判断发送信号的信号源是哪一个。然后在应用的状态栏上显示被按下的按钮的标签内容。</p> 
<h4 id="发送信号">发送信号</h4> 
<p>从QObejct生成的对象可以发送信号。在下面的例子中我们将会看到怎样去发送自定义的信号。</p> 
<pre class="prettyprint"><code class=" hljs python"><span class="hljs-keyword">import</span> sys
<span class="hljs-keyword">from</span> PyQt5.QtCore <span class="hljs-keyword">import</span> pyqtSignal, QObject
<span class="hljs-keyword">from</span> PyQt5.QtWidgets <span class="hljs-keyword">import</span> QMainWindow, QApplication


<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Communicate</span><span class="hljs-params">(QObject)</span>:</span> 
    closeApp = pyqtSignal() <span class="hljs-comment">#comunicate的一个属性</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Example</span><span class="hljs-params">(QMainWindow)</span>:</span> 
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self)</span>:</span>
        super().__init__() 
        self.initUI() 

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">initUI</span><span class="hljs-params">(self)</span>:</span>   
        self.c = Communicate()  <span class="hljs-comment">#c对象</span>
        self.c.closeApp.connect(self.close)      <span class="hljs-comment">#pysignal型的信号，接收到信号就控制关闭 </span>

        self.setGeometry(<span class="hljs-number">300</span>, <span class="hljs-number">300</span>, <span class="hljs-number">290</span>, <span class="hljs-number">150</span>)
        self.setWindowTitle(<span class="hljs-string">'Emit signal'</span>)
        self.show()


    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">mousePressEvent</span><span class="hljs-params">(self, event)</span>:</span>  <span class="hljs-comment">#鼠标按下事件（信号源），发射一个信号(信号对象),信号目标是colse</span>

        self.c.closeApp.emit()   <span class="hljs-comment">#closeApp发送信号</span>


<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:

    app = QApplication(sys.argv)
    ex = Example()
    sys.exit(app.exec_())</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6c6afb9d71258896305adae7f0907035/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">树的三种遍历方式源码（递归与非递归）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/7c53fd523b1a108f7766ed02548c1ea9/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【思维导图】计算机网络第三章数据链路层</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>