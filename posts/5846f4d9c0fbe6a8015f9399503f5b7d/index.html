<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>java反射初步学习（一） - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="java反射初步学习（一）" />
<meta property="og:description" content="首先看下基本概念:
(一)在Java运行时环境中，对于任意一个类，能否知道这个类有哪些属性和方法？对于任意一个对象，能否调用它的任
意一个方法？答案是肯定的。这种动态获取类的信息以及动态调用对象的方法的功能来自于Java 语言的反射（Reflection）机制。
Java 反射机制主要提供了以下功能:
①:在运行时判断任意一个对象所属的类。
②:在运行时构造任意一个类的对象。 ③:在运行时判断任意一个类所具有的成员变量和方法。
④: 在运行时调用任意一个对象的方法
反射机制允许程序在运行时通过反射的API获取类中的描述，方法，并且允许我们在运行时改变fields内容或者去调用methods
（二）Java Reflection APIs简介:
在JDK中，主要由以下类来实现Java反射机制，这些类都
位于java.lang.reflect包中
①:Class类：代表一个类。【注:这个Class类进行继承了Object，比较特别】
②:Field 类：代表类的成员变量（成员变量也称为类的属性）。
③:Method类：代表类的方法。
④:Constructor 类：代表类的构造方法。
⑤:Array类：提供了动态创建数组，以及访问数组的元素的静态方法
简要说下是使用方法的步骤:
要想使用使用反射，我们要去获取我们需要进行去处理的类或者对象的Class对象,其中我们主要有三种方法去获取
①:使用Class的静态方法forName():例如:Class.forName(&#34;java.lang.Class&#34;);
②:使用XXX.Class语法:例如:String.Class；
③:使用具体某个对象.getClass()方法：例如String str=&#34;abc&#34;;Class&lt;?&gt; tClass=str.getClass();
先看一个例子:这个例子对于指定的类名，使用反射来获取该类中的所有声明的方法，（使用第一种获取Class对象的方法）(主要代码如下:):
package com.jiangqq.reflection;
/**
* 使用反射来获取Class中的生命的方法，包括私有的方法
*/
import java.lang.reflect.Method;
public classReflection1 {
public static void main(String[] args)throws Exception {
//使用Class去调用静态方法forName()获得java.lang.Class的Class对象
Class&lt;?&gt; tClass =Class.forName(&#34;java.lang.Class&#34;);
//获取该class中声明的所有方法
Method[] methods =tClass.getDeclaredMethods();
for (Method method :methods) {
System.out.println(method);
}
}
}
（三）查看Class的API发现Class类是Reflection API 中的核心类，它有以下几个常用的方法" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/5846f4d9c0fbe6a8015f9399503f5b7d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2016-09-13T09:26:02+08:00" />
<meta property="article:modified_time" content="2016-09-13T09:26:02+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">java反射初步学习（一）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p></p> 
<p align="left"><br> <br> </p> 
<p align="left">首先看下基本概念:</p> 
<p align="left">  (一)在Java运行时环境中，对于任意一个类，能否知道这个类有哪些属性和方法？对于任意一个对象，能否调用它的任<br> 意一个方法？答案是肯定的。这种动态获取类的信息以及动态调用对象的方法的功能来自于Java 语言的反射（Reflection）机制。</p> 
<p align="left">      Java 反射机制主要提供了以下功能:</p> 
<p align="left">      <span style="color:#339999">①</span><span style="color:#339999">:</span><span style="color:#339999">在运行时判断任意一个对象所属的类。</span><span style="color:#339999"><br>        </span><span style="color:#339999">②</span><span style="color:#339999">:</span><span style="color:#339999">在运行时构造任意一个类的对象。</span><span style="color:#339999">   <br>        </span><span style="color:#339999">③</span><span style="color:#339999">:</span><span style="color:#339999">在运行时判断任意一个类所具有的成员变量和方法。</span><span style="color:#339999"><br>        </span><span style="color:#339999">④</span><span style="color:#339999">: </span> <span style="color:#339999">在运行时调用任意一个对象的方法</span></p> 
<p align="left">     反射机制允许程序在运行时通过反射的API获取类中的描述，方法，并且允许我们在运行时改变fields内容或者去调用methods</p> 
<p align="left">（二）Java Reflection APIs简介:</p> 
<p align="left">   在JDK中，主要由以下类来实现Java反射机制，这些类都<br>     位于java.lang.reflect包中<br>      ①:Class类：代表一个类。<span style="color:#CC0000">【注</span><span style="color:#CC0000">:</span><span style="color:#CC0000">这个</span><span style="color:#CC0000">Class</span><span style="color:#CC0000">类进行继承了</span><span style="color:#CC0000">Object</span><span style="color:#CC0000">，比较特别】</span><br>      ②:Field 类：代表类的成员变量（成员变量也称为类的属性）。<br>      ③:Method类：代表类的方法。<br>      ④:Constructor 类：代表类的构造方法。<br>      ⑤:Array类：提供了动态创建数组，以及访问数组的元素的静态方法</p> 
<p align="left"> </p> 
<p align="left">简要说下是使用方法的步骤:</p> 
<p align="left">    要想使用使用反射，我们要去获取我们需要进行去处理的类或者对象的Class对象,其中我们主要有三种方法去获取</p> 
<p align="left">     <span style="color:#339999">①</span><span style="color:#339999">:</span><span style="color:#339999">使用</span><span style="color:#339999">Class</span><span style="color:#339999">的静态方法</span><span style="color:#339999">forName():</span><span style="color:#339999">例如</span><span style="color:#339999">:Class.forName("java.lang.Class");</span></p> 
<p align="left"><span style="color:#339999">     </span><span style="color:#339999">②</span><span style="color:#339999">:</span><span style="color:#339999">使用</span><span style="color:#339999">XXX.Class</span><span style="color:#339999">语法</span><span style="color:#339999">:</span><span style="color:#339999">例如</span><span style="color:#339999">:String.Class</span><span style="color:#339999">；</span></p> 
<p align="left"><span style="color:#339999">     </span><span style="color:#339999">③</span><span style="color:#339999">:</span><span style="color:#339999">使用具体某个对象</span><span style="color:#339999">.getClass()</span><span style="color:#339999">方法：例如</span><span style="color:#339999">String str="abc";Class&lt;?&gt; tClass=str.getClass();</span></p> 
<p align="left"> </p> 
<p align="left">    先看一个例子:这个例子对于指定的类名，使用反射来获取该类中的所有声明的方法，（使用第一种获取Class对象的方法）(主要代码如下:):</p> 
<p align="left" style="background:rgb(240,240,240)">package com.jiangqq.reflection;</p> 
<p align="left" style="background:rgb(240,240,240)">/**</p> 
<p align="left" style="background:rgb(240,240,240)"> * 使用反射来获取Class中的生命的方法，包括私有的方法</p> 
<p align="left" style="background:rgb(240,240,240)"> */</p> 
<p align="left" style="background:rgb(240,240,240)">import java.lang.reflect.Method;</p> 
<p align="left" style="background:rgb(240,240,240)">public classReflection1 {<!-- --></p> 
<p align="left" style="background:rgb(240,240,240)">          public static void main(String[] args)throws Exception {<!-- --></p> 
<p align="left" style="background:rgb(240,240,240)">                    //使用Class去调用静态方法forName()获得java.lang.Class的Class对象</p> 
<p align="left" style="background:rgb(240,240,240)">                    Class&lt;?&gt; tClass =Class.forName("java.lang.Class");</p> 
<p align="left" style="background:rgb(240,240,240)">                    //获取该class中声明的所有方法</p> 
<p align="left" style="background:rgb(240,240,240)">                    Method[] methods =tClass.getDeclaredMethods();</p> 
<p align="left" style="background:rgb(240,240,240)">                    for (Method method :methods) {<!-- --></p> 
<p align="left" style="background:rgb(240,240,240)">                               System.out.println(method);</p> 
<p align="left" style="background:rgb(240,240,240)">                    }</p> 
<p align="left" style="background:rgb(240,240,240)">          }</p> 
<p align="left" style="background:rgb(240,240,240)">}</p> 
<p align="left">      </p> 
<p align="left">    （三）查看Class的API发现Class类是Reflection API 中的核心类，它有以下几个常用的方法</p> 
<p align="left">           <span style="color:#339999">①</span><span style="color:#339999">: getName()</span><span style="color:#339999">：获得类的完整名字。</span><span style="color:#339999"><br>             </span><span style="color:#339999">②</span><span style="color:#339999">: getFields()</span><span style="color:#339999">：获得类的</span><span style="color:#339999">public</span><span style="color:#339999">类型的属性。</span><span style="color:#339999"><br>             </span><span style="color:#339999">③</span><span style="color:#339999">: getDeclaredFields()</span><span style="color:#339999">：获得类的所有属性。</span><span style="color:#339999"><br>             </span><span style="color:#339999">④</span><span style="color:#339999">: getMethods()</span><span style="color:#339999">：获得类的</span><span style="color:#339999">public</span><span style="color:#339999">类型的方法。</span><span style="color:#339999"><br>             </span><span style="color:#339999">⑤</span><span style="color:#339999">: getDeclaredMethods()</span><span style="color:#339999">：获得类的所有方法。</span></p> 
<p align="left"><span style="color:#339999">           </span><span style="color:#339999">⑥</span><span style="color:#339999">:getMethod(String name, Class[] parameterTypes)</span><span style="color:#339999">：获得类的特定方法，</span><span style="color:#339999">name</span><span style="color:#339999">参数指定方法的名字</span><span style="color:#339999">parameterTypes</span><span style="color:#339999">参数指定方法的参数类型。</span></p> 
<p align="left"><span style="color:#339999">           </span><span style="color:#339999">⑦</span><span style="color:#339999">:getConstructors()</span><span style="color:#339999">：获得类的</span><span style="color:#339999">public</span><span style="color:#339999">类型的构造方法。</span></p> 
<p align="left"><span style="color:#339999">           </span><span style="color:#339999">⑧</span><span style="color:#339999">:getConstructor(Class[] parameterTypes)</span><span style="color:#339999">：获得类的特定构造方法，</span><span style="color:#339999">parameterTypes</span><span style="color:#339999">参数指定构造方法的参数类型。</span></p> 
<p align="left"><span style="color:#339999">           </span><span style="color:#339999">⑨</span><span style="color:#339999">:newInstance()</span><span style="color:#339999">：通过类的不带参数的构造方法创建这个类的一个对象。</span></p> 
<p align="left"> </p> 
<p align="left">        先看上面的⑧和⑨其中都能生成对象，但是因为构造函数有无参和有参构造函数两种,所以我们分两种情况考虑</p> 
<p align="left"> </p> 
<p align="left"> 情况一:如果是无参的构造函数来生成对象:</p> 
<p align="left">     <span style="color:#CC0000">   &lt;a&gt;</span><span style="color:#CC0000">首先我们去获取</span><span style="color:#CC0000">Class</span><span style="color:#CC0000">对象，然后直接通过</span><span style="color:#CC0000">Class</span><span style="color:#CC0000">对象去调用</span><span style="color:#CC0000">newInstance()</span><span style="color:#CC0000">方法就可以</span></p> 
<p align="left" style="background:rgb(240,240,240)">         Class&lt;?&gt; tclass =Reflection2.class;</p> 
<p align="left" style="background:rgb(240,240,240)">         Object reflection2 =tclass.newInstance();</p> 
<p align="left">         &lt;b&gt;首先我们也是去获取Class对象,然后去去调用getConstructor（）得到Constructor对象，接着直接调用newInstance()即可</p> 
<p align="left" style="background:rgb(240,240,240)">         Class&lt;?&gt; classType =Reflection2.class;</p> 
<p align="left" style="background:rgb(240,240,240)">          // Object reflection2 = classType.newInstance();</p> 
<p align="left" style="background:rgb(240,240,240)">         Constructor&lt;?&gt; constructor =classType.getConstructor(new Class[] {});</p> 
<p align="left" style="background:rgb(240,240,240)">         Object reflection2 = constructor.newInstance(new Object[] {});</p> 
<p align="left">           <br> <span style="color:rgb(204,0,0)"> </span><span style="color:rgb(204,0,0)">情况二</span><span style="color:rgb(204,0,0)">:</span><span style="color:rgb(204,0,0)">现在是有参构造函数，那我们只有一种方法来通过反射生成对象</span><span style="color:rgb(204,0,0)">:       </span>   </p> 
<p align="left" style="background:rgb(240,240,240)">        Class&lt;?&gt; classType =Person.class; </p> 
<p align="left" style="background:rgb(240,240,240)">        Constructor cons =classType.getConstructor(new Class[]{String.class, int.class});  </p> 
<p align="left" style="background:rgb(240,240,240)">        Object obj = cons.newInstance(newObject[]{“zhangsan”, 19});</p> 
<p align="left">           </p> 
<p align="left">   接下来根据以上的一些常用的方法，使用反射举几个例子（使用反射来访问类中的方法）:</p> 
<p align="left" style="background:rgb(240,240,240)">package com.jiangqq.reflection;</p> 
<p align="left" style="background:rgb(240,240,240)">import java.lang.reflect.Constructor;</p> 
<p align="left" style="background:rgb(240,240,240)">import java.lang.reflect.Method;</p> 
<p align="left" style="background:rgb(240,240,240)">/**</p> 
<p align="left" style="background:rgb(240,240,240)"> * 反射练习二,使用反射访问类中的方法</p> 
<p align="left" style="background:rgb(240,240,240)"> * </p> 
<p align="left" style="background:rgb(240,240,240)"> * @author jiangqq</p> 
<p align="left" style="background:rgb(240,240,240)"> * </p> 
<p align="left" style="background:rgb(240,240,240)"> */</p> 
<p align="left" style="background:rgb(240,240,240)">public classReflection2 {<!-- --></p> 
<p align="left" style="background:rgb(240,240,240)">          public int sum(int a, int b) {<!-- --></p> 
<p align="left" style="background:rgb(240,240,240)">                    return a + b;</p> 
<p align="left" style="background:rgb(240,240,240)">          }</p> 
<p align="left" style="background:rgb(240,240,240)">          public String addStr(String str) {<!-- --></p> 
<p align="left" style="background:rgb(240,240,240)">                    return "This isthe:" + str;</p> 
<p align="left" style="background:rgb(240,240,240)">          }</p> 
<p align="left" style="background:rgb(240,240,240)">          public static void main(String[] args)throws Exception {<!-- --></p> 
<p align="left" style="background:rgb(240,240,240)">                    Class&lt;?&gt; classType =Reflection2.class;</p> 
<p align="left" style="background:rgb(240,240,240)">                    // Object reflection2 =classType.newInstance();</p> 
<p align="left" style="background:rgb(240,240,240)">                    Constructor&lt;?&gt;constructor = classType.getConstructor(new Class[] {});</p> 
<p align="left" style="background:rgb(240,240,240)">                    Object reflection2 =constructor.newInstance(new Object[] {});</p> 
<p align="left" style="background:rgb(240,240,240)">                    // 通过反射进行反射出类中的方法</p> 
<p align="left" style="background:rgb(240,240,240)">                    Method sumMethod =classType.getMethod("sum", new Class[] { int.class,  int.class});</p> 
<p align="left" style="background:rgb(240,240,240)">                    //invoke方法的值永远只是对象</p> 
<p align="left" style="background:rgb(240,240,240)">                    Object result1 = sumMethod.invoke(reflection2,new Object[] { 6, 10 });</p> 
<p align="left" style="background:rgb(240,240,240)">                    System.out.println((Integer)result1);</p> 
<p align="left" style="background:rgb(240,240,240)">                    Method addStrMethod =classType.getMethod("addStr", newClass[] { String.class });</p> 
<p align="left" style="background:rgb(240,240,240)">                    Object result2 =addStrMethod.invoke(reflection2, newObject[] { "tom" });</p> 
<p align="left" style="background:rgb(240,240,240)">                    System.out.println((String)result2);</p> 
<p align="left" style="background:rgb(240,240,240)">          }</p> 
<p align="left" style="background:rgb(240,240,240)">}</p> 
<p align="left"><br> </p> 
<p align="left">          ④:通过反射机制调用对象的私有方法,访问对象的私有变量....</p> 
<p align="left">我们大家都知道，在Java语言中，如果我们对某些变量，或者方法进行private的声明，然后我们在其他类中进行不能去调用这些方法和变量，但是通过反射机制，这些私有声明将不复存在<span style="color:rgb(204,0,0)">【提醒一点</span><span style="color:#CC0000">:</span><span style="color:#CC0000">在写程序的时候，我们最好不要故意经常去使用反射机制来打破这种私有保护</span><span style="color:#CC0000">...</span><span style="color:#CC0000">】</span></p> 
<p align="left">           要实现这种功能，<span style="color:#CC0000">我们需要用<strong>到</strong></span><strong><span style="color:#CC0000">AccessibleObject</span><span style="color:#CC0000">类中的</span><span style="color:#CC0000">public void setAccessible(boolean flag)</span><span style="color:#CC0000">方法</span><span style="color:#CC0000">:</span></strong></p> 
<p align="left"><span style="color:#CC0000"> </span><span style="color:#CC0000">使用这个方法，把参数</span><span style="color:#CC0000">flag</span><span style="color:#CC0000">设置成</span><span style="color:#CC0000">true</span><span style="color:#CC0000">，然后我们的</span><span style="color:#CC0000">field</span><span style="color:#CC0000">或者</span><span style="color:#CC0000">method</span><span style="color:#CC0000">就可以绕过</span><span style="color:#CC0000">Java</span><span style="color:#CC0000">语言的语法访问的检查</span></p> 
<p align="left">  具体使用如下:</p> 
<p align="left">  &lt;a&gt;使用反射去访问私有方法</p> 
<p align="left" style="background:rgb(240,240,240)">package com.jiangqq.reflection;</p> 
<p align="left" style="background:rgb(240,240,240)">public class Test01 {<!-- --></p> 
<p align="left" style="background:rgb(240,240,240)">          private String getName(String name) {<!-- --></p> 
<p align="left" style="background:rgb(240,240,240)">                    return "This i:" +name;</p> 
<p align="left" style="background:rgb(240,240,240)">          }</p> 
<p align="left" style="background:rgb(240,240,240)">}</p> 
<p align="left" style="background:rgb(240,240,240)"> </p> 
<p align="left" style="background:rgb(240,240,240)"> </p> 
<p align="left" style="background:rgb(240,240,240)">package com.jiangqq.reflection;</p> 
<p align="left" style="background:rgb(240,240,240)">import java.lang.reflect.Method;</p> 
<p align="left" style="background:rgb(240,240,240)">public classTestPrivate01 {<!-- --></p> 
<p align="left" style="background:rgb(240,240,240)">          public static void main(String[] args)throws Exception {<!-- --></p> 
<p align="left" style="background:rgb(240,240,240)">                    Test01 p = new Test01();</p> 
<p align="left" style="background:rgb(240,240,240)">                    Class&lt;?&gt; classType =p.getClass();</p> 
<p align="left" style="background:rgb(240,240,240)">                    Method method =classType.getDeclaredMethod("getName", newClass[] { String.class });</p> 
<p align="left" style="background:rgb(240,240,240)">                    method.setAccessible(true);</p> 
<p align="left" style="background:rgb(240,240,240)">                    Object object =method.invoke(p, new Object[] { "tom" });</p> 
<p align="left" style="background:rgb(240,240,240)">                    System.out.println((String)object);</p> 
<p align="left" style="background:rgb(240,240,240)">          }</p> 
<p align="left" style="background:rgb(240,240,240)">}</p> 
<p align="left"><br> <br> </p> 
<p align="left">&lt;b&gt;使用反射机制去访问私有变量:</p> 
<p align="left">  </p> 
<p align="left" style="background:rgb(240,240,240)">package com.jiangqq.reflection;</p> 
<p align="left" style="background:rgb(240,240,240)">public class Test02 {<!-- --></p> 
<p align="left" style="background:rgb(240,240,240)">  private String name="张三";</p> 
<p align="left" style="background:rgb(240,240,240)">  private String getName()</p> 
<p align="left" style="background:rgb(240,240,240)">  {<!-- --></p> 
<p align="left" style="background:rgb(240,240,240)">           return name;</p> 
<p align="left" style="background:rgb(240,240,240)">  }</p> 
<p align="left" style="background:rgb(240,240,240)">}</p> 
<p align="left" style="background:rgb(240,240,240)"> </p> 
<p align="left" style="background:rgb(240,240,240)"> </p> 
<p align="left" style="background:rgb(240,240,240)">package com.jiangqq.reflection;</p> 
<p align="left" style="background:rgb(240,240,240)">import java.lang.reflect.Field;</p> 
<p align="left" style="background:rgb(240,240,240)">import java.lang.reflect.Method;</p> 
<p align="left" style="background:rgb(240,240,240)">public classTestPrivate02 {<!-- --></p> 
<p align="left" style="background:rgb(240,240,240)">          public static void main(String[] args)throws Exception {<!-- --></p> 
<p align="left" style="background:rgb(240,240,240)">                    Test02 p = new Test02();</p> 
<p align="left" style="background:rgb(240,240,240)">                    Class&lt;?&gt; classType =p.getClass();</p> 
<p align="left" style="background:rgb(240,240,240)">                    Field field =classType.getDeclaredField("name");</p> 
<p align="left" style="background:rgb(240,240,240)">                    //设置true,使用可以绕过Java语言规范的检查</p> 
<p align="left" style="background:rgb(240,240,240)">                    field.setAccessible(true);</p> 
<p align="left" style="background:rgb(240,240,240)">                    //对变量进行设置值</p> 
<p align="left" style="background:rgb(240,240,240)">                    field.set(p, "李四");</p> 
<p align="left" style="background:rgb(240,240,240)">                    Method method =classType.getDeclaredMethod("getName", new Class[] {});</p> 
<p align="left" style="background:rgb(240,240,240)">                    method.setAccessible(true);</p> 
<p align="left" style="background:rgb(240,240,240)">                    Object object =method.invoke(p, new Object[] {});</p> 
<p align="left" style="background:rgb(240,240,240)">                    System.out.println((String)object);</p> 
<p align="left" style="background:rgb(240,240,240)">          }</p> 
<p align="left" style="background:rgb(240,240,240)">}</p> 
<p align="left"> </p> 
<p align="left">注：对原文的几处错误已做修改。</p> 
<p align="left">本文转载自：http://www.open-open.com/lib/view/open1331472289140.html</p> 
<p> </p> 
<p><br> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/727efe2e937024cea27ebcea29ecaef3/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">在IDEA中实战Git</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/74be113fcf728699c133ca30f626a1c6/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">利用C语言绘制操作系统图像界面</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>