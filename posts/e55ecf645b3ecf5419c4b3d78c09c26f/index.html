<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java集合如何遍历删除指定元素 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Java集合如何遍历删除指定元素" />
<meta property="og:description" content="目录
1、删除List
2、删除Set
3、删除Map
注意事项：
1、删除List public class ListDemo { public static void main(String[] args) { List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(&#34;张三&#34;); list.add(&#34;李四&#34;); list.add(&#34;王五&#34;); list.add(&#34;赵六&#34;); list.forEach(System.out::println); for(String str : list) { if (&#34;李四&#34;.equals(str)) { list.remove(str); } } list.forEach(s -&gt; { System.out.println(&#34;第1次删除后：&#34; &#43; list); }); } } 以上代码运行会发生并发修改异常ConcurrentModificationException，正确的方式是：
public class ListExample { public static void main(String[] args) { List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(&#34;张三&#34;); list.add(&#34;李四&#34;); list.add(&#34;王五&#34;); list.add(&#34;赵六&#34;); System.out.println(list); // 方法1：迭代器遍历 Iterator&lt;String&gt; iterator = list." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/e55ecf645b3ecf5419c4b3d78c09c26f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-01-05T03:42:05+08:00" />
<meta property="article:modified_time" content="2023-01-05T03:42:05+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java集合如何遍历删除指定元素</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="1%E3%80%81%E5%88%A0%E9%99%A4List-toc" style="margin-left:40px;"><a href="#1%E3%80%81%E5%88%A0%E9%99%A4List" rel="nofollow">1、删除List</a></p> 
<p id="2%E3%80%81%E5%88%A0%E9%99%A4Set-toc" style="margin-left:40px;"><a href="#2%E3%80%81%E5%88%A0%E9%99%A4Set" rel="nofollow">2、删除Set</a></p> 
<p id="3%E3%80%81%E5%88%A0%E9%99%A4Map-toc" style="margin-left:40px;"><a href="#3%E3%80%81%E5%88%A0%E9%99%A4Map" rel="nofollow">3、删除Map</a></p> 
<p id="%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%EF%BC%9A" rel="nofollow">注意事项：</a></p> 
<hr id="hr-toc"> 
<h2>1、删除List</h2> 
<pre><code class="language-java">public class ListDemo {
    public static void main(String[] args) {
        List&lt;String&gt; list = new ArrayList&lt;&gt;();

        list.add("张三");
        list.add("李四");
        list.add("王五");
        list.add("赵六");

        list.forEach(System.out::println);

        for(String str : list) {
            if ("李四".equals(str)) {
                list.remove(str);
            }
        }

        list.forEach(s -&gt; {
            System.out.println("第1次删除后：" + list);
        });
    }
}</code></pre> 
<p>以上代码运行会发生并发修改异常ConcurrentModificationException，正确的方式是：</p> 
<pre><code class="language-java">public class ListExample {
    public static void main(String[] args) {
        List&lt;String&gt; list = new ArrayList&lt;&gt;();

        list.add("张三");
        list.add("李四");
        list.add("王五");
        list.add("赵六");
        
        System.out.println(list);
        

        // 方法1：迭代器遍历
        Iterator&lt;String&gt; iterator = list.iterator();

        while(iterator.hasNext()) {
            String s = iterator.next();

            if ("李四".equals(s)) {
                iterator.remove();
            }
        }

        System.out.println("第1次删除后：" + list);

        // 方法2：使用集合的removeIf()方法
        list.removeIf(new Predicate&lt;String&gt;() {
            @Override
            public boolean test(String s) {
                return "王五".equals(s);
            }
        });

        System.out.println("第2次删除后：" + list);
    }
}</code></pre> 
<p></p> 
<h3 id="2%E3%80%81%E5%88%A0%E9%99%A4Set">2、删除Set</h3> 
<p>同样，Set也不能通过foreach删除，否则发生异常</p> 
<pre><code class="language-java">public class SetExample {
    public static void main(String[] args) {
        Set&lt;String&gt; set = new HashSet&lt;&gt;();

        set.add("张三");
        set.add("李四");
        set.add("王五");

        System.out.println(set);

        // 此处会发生并发修改异常
        for(String str : set) {
            if ("张三".equals(str)) {
                set.remove(str);
            }
        }

        System.out.println("第1次删除后：" + set);

        set.removeIf("李四"::equals);

        System.out.println("第2次删除后：" + set);
    }
}</code></pre> 
<p></p> 
<h3 id="3%E3%80%81%E5%88%A0%E9%99%A4Map">3、删除Map</h3> 
<pre><code class="language-java">public static void main(String[] args) {
    Map&lt;Integer, String&gt; map = new HashMap();

    map.put(1, "张三");
    map.put(2, "李四");
    map.put(3, "王五");
    map.put(4, "赵六");
        
    map.forEach((k, v) -&gt; System.out.println(k + "," + v));

    Iterator&lt;Map.Entry&lt;Integer, String&gt;&gt; iterator = map.entrySet().iterator();

    while(iterator.hasNext()) {
        Map.Entry&lt;Integer, String&gt; entry = iterator.next();
        Integer key = entry.getKey();

        if (key == 1) {
            iterator.remove();
        }
    }

    System.out.println(map);
}</code></pre> 
<h3 id="%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%EF%BC%9A">注意事项： </h3> 
<p>使用普通for循环删除list里面的元素会有bug，当删除一个元素时，list的长度会减1，被删除元素的后一个元素会向前移动，导致只删了一部分符合条件的元素。</p> 
<pre><code>public class ListExample {
    public static void main(String[] args) {
        List&lt;String&gt; list = new ArrayList&lt;&gt;();

        list.add("张三");
        list.add("张三");
        list.add("李四");
        list.add("王五");
        list.add("赵六");

        System.out.println("删除前：" + list);

        for (int i = 0; i &lt; list.size(); i++) {
            String s = list.get(i);

            if ("张三".equals(s)) {
                list.remove(s);
            }
        }

        System.out.println("删除后：" + list);
    }

}</code></pre> 
<p>以上代码的运行结果为：</p> 
<blockquote> 
 <p>删除前：[张三, 张三, 李四, 王五, 赵六]<br> 删除后：[张三, 李四, 王五, 赵六]</p> 
</blockquote> 
<p>原因是：</p> 
<p>第一轮循环，i = 0，会删除第一个张三，删除之后只剩四个元素[张三, 李四, 王五, 赵六]</p> 
<p>第二轮循环，i = 1，从第二个元素（也就是“李四”）开始判断</p> 
<p>以上代码可以简单的改成如下，每次都比较第一个元素</p> 
<pre><code class="language-java">public class ListExample {
    public static void main(String[] args) {
        List&lt;String&gt; list = new ArrayList&lt;&gt;();

        list.add("张三");
        list.add("张三");
        list.add("李四");
        list.add("王五");
        list.add("赵六");

        System.out.println("删除前：" + list);

        for (int i = 0; i &lt; list.size(); i++) {
            String s = list.get(0);

            if ("张三".equals(s)) {
                list.remove(s);
            }
        }

        System.out.println("删除后：" + list);
    }

}</code></pre> 
<p>事实上Collection的removeIf()方法的实现也是通过Iterator的romove()方法删除元素，源码如下：</p> 
<blockquote> 
 <pre>default boolean removeIf(Predicate&lt;? super E&gt; filter) {
    Objects.requireNonNull(filter);
    boolean removed = false;
    final Iterator&lt;E&gt; each = iterator();
    while (each.hasNext()) {
        if (filter.test(each.next())) {
            each.remove();
            removed = true;
        }
    }
    return removed;
}</pre> 
</blockquote> 
<p></p> 
<h2>答疑环节：</h2> 
<p>那有童鞋就要问了，foreach遍历删除会发生异常，为什么普通for循环就能正常运行呢？</p> 
<p>因为foreach也会被编译成迭代器遍历的方式，只不过调用的是集合的remove()方法，没有调用迭代器的remove()导致的异常。</p> 
<p>foreach编译前：</p> 
<blockquote> 
 <pre>public static void main(String[] args) {
        List&lt;String&gt; list = new ArrayList&lt;&gt;();

        list.add("张三");
        list.add("张三");
        list.add("李四");
        list.add("王五");
        list.add("赵六");

        System.out.println("删除前：" + list);

        for (String s : list) {
            if ("张三".equals(s)) {
                list.remove(s);
            }
        }
        
        System.out.println("删除后：" + list);
    }</pre> 
</blockquote> 
<p>foreach编译后：</p> 
<blockquote> 
 <pre>public static void main(String[] args) {
    List&lt;String&gt; list = new ArrayList();
    list.add("张三");
    list.add("张三");
    list.add("李四");
    list.add("王五");
    list.add("赵六");
    System.out.println("删除前：" + list);
    Iterator var2 = list.iterator();

    while(var2.hasNext()) {
        String s = (String)var2.next();
        if ("张三".equals(s)) {
            list.remove(s);
        }
    }

    System.out.println("删除后：" + list);
}</pre> 
</blockquote> 
<p>如果还想更深入了解为什么会发生异常，可以参考文章<a class="link-info" href="https://blog.csdn.net/heyl163_/article/details/126258321?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522167286125516800182726748%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=167286125516800182726748&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-1-126258321-null-null.blog_rank_default&amp;utm_term=%E5%BF%AB%E9%80%9F&amp;spm=1018.2226.3001.4450" title="Java集合的快速失败原则">Java集合的快速失败原则</a></p> 
<p></p> 
<h2>文章总结：</h2> 
<p>使用迭代器的remove()方法删除就可以了</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/1fa7faba1c2521fd6f50bc659025e09a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">IDEA 版本更新为2020.1双击打不开的解决方案</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5fcc381c45bfe8a60a6f99fa6277ef5c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">模型预测控制（MPC）算法原理</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>