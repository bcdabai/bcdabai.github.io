<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>使用iai_kinect2标定kinectV2相机 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="使用iai_kinect2标定kinectV2相机" />
<meta property="og:description" content="实验背景：因为需要制作bundlefusion需要的数据集，所以需要使用kinectV2相机获取rgbd图像，年前的时候在我的笔记本上安装了libfreenect2库和iai_kinect2，标定过一次kinecv2相机，然后使用kinectv2相机实时获取的图像实现elasticfusion稠密重建．但是由于当时时间紧迫，很多东西都没有搞明白，所以趁这次机会将一些问题整理一下，记录一下．
环境搭建：
１．　安装了ROS的kinetic版本
libfreenect2和iai_kinect2的安装参考文章：　https://www.cnblogs.com/li-yao7758258/p/7445429.html
2. 下载libfreenect2
$ cd Downloads $ git clone https://github.com/OpenKinect/libfreenect2.git 3.安装libfreenect2的依赖
sudo apt-get install build-essential cmake pkg-config libturbojpeg libjpeg-turbo8-dev mesa-common-dev freeglut3-dev libxrandr-dev libxi-dev 安装libusb sudo apt-add-repository ppa:floe/libusb sudo apt-get update sudo apt-get install libusb-1.0-0-dev 安装GLFW3 cd libfreenect2/depends sh install_ubuntu.sh sudo dpkg -i libglfw3*_3.0.4-1_*.deb 4. 继续安装libfreenect2库
$ cd libfreenect2 $ mkdir build $ cmake ../ $ make -j4 $ sudo make install 5. 使用lsusb指令测试kinectv2相机有没有链接成功．
6.　编译iai_kinect2" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/466f00acec6c8f06cefaafb2f186f1e0/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-06-11T19:13:46+08:00" />
<meta property="article:modified_time" content="2020-06-11T19:13:46+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">使用iai_kinect2标定kinectV2相机</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>实验背景：因为需要制作bundlefusion需要的数据集，所以需要使用kinectV2相机获取rgbd图像，年前的时候在我的笔记本上安装了libfreenect2库和iai_kinect2，标定过一次kinecv2相机，然后使用kinectv2相机实时获取的图像实现elasticfusion稠密重建．但是由于当时时间紧迫，很多东西都没有搞明白，所以趁这次机会将一些问题整理一下，记录一下．</p> 
<p>环境搭建：</p> 
<p>１．　安装了ROS的kinetic版本</p> 
<p>libfreenect2和iai_kinect2的安装参考文章：　<a href="https://www.cnblogs.com/li-yao7758258/p/7445429.html" rel="nofollow">https://www.cnblogs.com/li-yao7758258/p/7445429.html</a></p> 
<p>2. 下载libfreenect2</p> 
<pre><code>$ cd Downloads
$ git clone https://github.com/OpenKinect/libfreenect2.git

</code></pre> 
<p>3.安装libfreenect2的依赖</p> 
<pre><code>sudo apt-get install build-essential cmake pkg-config libturbojpeg libjpeg-turbo8-dev mesa-common-dev freeglut3-dev libxrandr-dev libxi-dev

安装libusb
sudo apt-add-repository ppa:floe/libusb
sudo apt-get update
sudo apt-get install libusb-1.0-0-dev
 
安装GLFW3
cd libfreenect2/depends 
sh install_ubuntu.sh
sudo dpkg -i libglfw3*_3.0.4-1_*.deb</code></pre> 
<p>4.  继续安装libfreenect2库</p> 
<pre><code>$ cd libfreenect2
$ mkdir build 
$ cmake ../
$ make -j4
$ sudo make install</code></pre> 
<p>5. 使用lsusb指令测试kinectv2相机有没有链接成功．</p> 
<p>6.　编译iai_kinect2</p> 
<pre><code>$ cd ~/ROS  #在/home/yunlei下创建了一个ROS文件夹，专门盛放ros的工程
$ mkdir -r ./iai_kinect2_ws/src/
$ cd ./iai_kinect2/src
$ git clone https://github.com/code-iai/iai_kinect2.git
$ cd iai_kinect2
$ rosdep install -r --from-paths .
$ cd ~/ROS/iai_kinect2
$ catkin_make -DCMAKE_BUILD_TYPE="Release"
$ rospack profile
</code></pre> 
<p>7. 测试kinectv2相机是否链接成功</p> 
<pre><code>$ cd Download
$ cd libfreenect
$ cd build/bin
$ ./Protonect</code></pre> 
<p>如果一切正常的话，相机拍摄的画面将映入眼帘． </p> 
<p><img alt="" height="819" src="https://images2.imgbox.com/a1/96/HyhPD5Qf_o.png" width="1194"></p> 
<p> ８. 测试kinectv2图像数据</p> 
<pre><code class="language-ruby">$ cd ~/ROS/iai_kinect2_ws
$ source ./devel/setup.bash
$ roslaunch kinect2_bridge kinect2_bridge.launch

# open a new terminal
$  rosrun kinect2_viewer kinect2_viewer(但是我这里执行失败) 
</code></pre> 
<p>9. 查看此时发布的与kinect相关的topics</p> 
<pre><code>/kinect2/bond
/kinect2/hd/camera_info
/kinect2/hd/image_color
/kinect2/hd/image_color/compressed
/kinect2/hd/image_color_rect
/kinect2/hd/image_color_rect/compressed
/kinect2/hd/image_depth_rect
/kinect2/hd/image_depth_rect/compressed
/kinect2/hd/image_mono
/kinect2/hd/image_mono/compressed
/kinect2/hd/image_mono_rect
/kinect2/hd/image_mono_rect/compressed
/kinect2/hd/points
/kinect2/qhd/camera_info
/kinect2/qhd/image_color
/kinect2/qhd/image_color/compressed
/kinect2/qhd/image_color_rect
/kinect2/qhd/image_color_rect/compressed
/kinect2/qhd/image_depth_rect
/kinect2/qhd/image_depth_rect/compressed
/kinect2/qhd/image_mono
/kinect2/qhd/image_mono/compressed
/kinect2/qhd/image_mono_rect
/kinect2/qhd/image_mono_rect/compressed
/kinect2/qhd/points
/kinect2/sd/camera_info
/kinect2/sd/image_color_rect
/kinect2/sd/image_color_rect/compressed
/kinect2/sd/image_depth
/kinect2/sd/image_depth/compressed
/kinect2/sd/image_depth_rect
/kinect2/sd/image_depth_rect/compressed
/kinect2/sd/image_ir
/kinect2/sd/image_ir/compressed
/kinect2/sd/image_ir_rect
/kinect2/sd/image_ir_rect/compressed
/kinect2/sd/points
</code></pre> 
<p>10. 打开/home/yunlei/ROS/iai_kinect2_ws/src/iai_kinect2/kinect2_bridge/launch/kinect2_bridge.launch查看kinect相机的分辨率</p> 
<pre><code> &lt;!-- sd point cloud (512 x 424) --&gt;
  &lt;node pkg="nodelet" type="nodelet" name="$(arg base_name)_points_xyzrgb_sd" machine="$(arg machine)"
        args="load depth_image_proc/point_cloud_xyzrgb $(arg nodelet_manager)" respawn="$(arg respawn)"&gt;
    &lt;remap from="rgb/camera_info"             to="$(arg base_name)/sd/camera_info"/&gt;
    &lt;remap from="rgb/image_rect_color"        to="$(arg base_name)/sd/image_color_rect"/&gt;
    &lt;remap from="depth_registered/image_rect" to="$(arg base_name)/sd/image_depth_rect"/&gt;
    &lt;remap from="depth_registered/points"     to="$(arg base_name)/sd/points"/&gt;
    &lt;param name="queue_size" type="int" value="$(arg queue_size)"/&gt;
  &lt;/node&gt;

  &lt;!-- qhd point cloud (960 x 540) --&gt;
  &lt;node pkg="nodelet" type="nodelet" name="$(arg base_name)_points_xyzrgb_qhd" machine="$(arg machine)"
        args="load depth_image_proc/point_cloud_xyzrgb $(arg nodelet_manager)" respawn="$(arg respawn)"&gt;
    &lt;remap from="rgb/camera_info"             to="$(arg base_name)/qhd/camera_info"/&gt;
    &lt;remap from="rgb/image_rect_color"        to="$(arg base_name)/qhd/image_color_rect"/&gt;
    &lt;remap from="depth_registered/image_rect" to="$(arg base_name)/qhd/image_depth_rect"/&gt;
    &lt;remap from="depth_registered/points"     to="$(arg base_name)/qhd/points"/&gt;
    &lt;param name="queue_size" type="int" value="$(arg queue_size)"/&gt;
  &lt;/node&gt;

  &lt;!-- hd point cloud (1920 x 1080) --&gt;
  &lt;node pkg="nodelet" type="nodelet" name="$(arg base_name)_points_xyzrgb_hd" machine="$(arg machine)"
        args="load depth_image_proc/point_cloud_xyzrgb $(arg nodelet_manager)" respawn="$(arg respawn)"&gt;
    &lt;remap from="rgb/camera_info"             to="$(arg base_name)/hd/camera_info"/&gt;
    &lt;remap from="rgb/image_rect_color"        to="$(arg base_name)/hd/image_color_rect"/&gt;
    &lt;remap from="depth_registered/image_rect" to="$(arg base_name)/hd/image_depth_rect"/&gt;
    &lt;remap from="depth_registered/points"     to="$(arg base_name)/hd/points"/&gt;
    &lt;param name="queue_size" type="int" value="$(arg queue_size)"/&gt;</code></pre> 
<p>可以发现kinecv2相机可以直接获取的图像的分辨率有三个，分别是：hd(1920x1080), qhd(960x540), sd(512x424),每一种分辨率又对应了彩色图，灰度图，深度图，以及是否是经过去畸变处理的，深度图是否和彩色图配准．</p> 
<p>11. 如果你想获取rect图像，那么你需要给定相应分辨率的相机内参数，而此时使用的是默认/iai_kinect2/kinect2_bridge/data下的相机参数，所以你需要标定你需要的分辨率的相机参数．</p> 
<p>12.关于数据获取，如果我标定了960x540的相机内参数，获取了去畸变后的而图像，我直接使用rosbag record指令，录制相应的topic就可以了．所以现在最关键的是标定相机</p> 
<p>13. iai_kinect2中也提供了标定工具，在/home/yunlei/ROS/iai_kinect2_ws/src/iai_kinect2/kinect2_calibration中，不过此时在/home/yunlei/ROS/iai_kinect2_ws/src/iai_kinect2/kinect2_calibration/src/kinect2_calibration.cpp文件中默认是标定1920x1080的图像，如果想要标定960x540的相机内参数，则需要将文件1349行中的HD改为QHD</p> 
<p>将原来的</p> 
<pre><code>std::string topicColor = "/" + ns + K2_TOPIC_HD + K2_TOPIC_IMAGE_MONO;
std::string topicIr = "/" + ns + K2_TOPIC_SD + K2_TOPIC_IMAGE_IR;
std::string topicDepth = "/" + ns + K2_TOPIC_SD + K2_TOPIC_IMAGE_DEPTH;</code></pre> 
<p>改为 </p> 
<pre><code>std::string topicColor = "/" + ns + K2_TOPIC_QHD + K2_TOPIC_IMAGE_MONO;
std::string topicIr = "/" + ns + K2_TOPIC_SD + K2_TOPIC_IMAGE_IR;
std::string topicDepth = "/" + ns + K2_TOPIC_SD + K2_TOPIC_IMAGE_DEPTH;</code></pre> 
<p>我刚开始改成了SD但是这种情况下，当你执行rosrun kinect2_calibration kinect2_calibration chess5x7x0.03 record color指令时，没有弹出图像窗口，无法保存图像，并且提示</p> 
<pre><code>[ERROR] Tried to advertise a service that is already advertised in this node [/kinect2_calib_1591865100768222736/compressed/set_parameters]
[ERROR] Tried to advertise a service that is already advertised in this node [/kinect2_calib_1591865100768222736/compressed/set_parameters]</code></pre> 
<p>我刚开始根据这个错误提示去搜索出了什么问题，但是有网友说这个不影响标定，（<a href="https://blog.csdn.net/weixin_30536513/article/details/94969881">https://blog.csdn.net/weixin_30536513/article/details/94969881</a>）但是我这里确实影响了．我折腾了好久，但是还是没有解决这个问题，当我想放弃的时候，突然想起来，我可以把上面的SD改为QHD试试．果然，当我改成了QHD后发现，虽然还是会有上面的错误的提示，但是此时弹出了图像窗口，当我拿着标定板进入相机的视野时，他可以检测到标定板子上的特征点，哇，我好开心．</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b673c96ca3ab13ed039a2c1d01a136e1/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Xilinx FPGA Partial Reconfiguration 部分重配置 详细教程</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9733f4e134d606c75ac5283fbe6ab1e1/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">C语言编程规范 学习笔记</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>