<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>FreeRTOS移植以及核心功能 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="FreeRTOS移植以及核心功能" />
<meta property="og:description" content="文章目录 freertos和ucos区别，优缺点比较移植步骤核心功能内存管理（5种内存管理策略）FreeRTOS任务调度算法有三种时间管理通信管理 栈管理 freertos和ucos区别，优缺点比较 FreeRTOS（Free Real-Time Operating System）和 uC/OS（Micro-controller Operating System）都是常见的实时操作系统（RTOS），用于嵌入式系统开发。它们有以下区别和特点：
FreeRTOS:
FreeRTOS 是由 Richard Barry 创建的免费开源的实时操作系统。FreeRTOS 非常轻量级，使用较少的内存资源，适用于资源有限的嵌入式系统。提供了任务管理、调度、时间管理、同步和通信等常见的操作系统功能。FreeRTOS 的核心是一个协程调度器，支持协作式多任务处理。支持多种处理器架构，包括 ARM、MIPS、X86 等。 uC/OS:
uC/OS 是由 Jean J. Labrosse 创建的商业实时操作系统，也有免费的开源版本（uC/OS-II）。uC/OS 具有丰富的功能，提供了任务管理、调度、同步、通信、内存管理等操作系统服务。对于实时性要求较高的应用，uC/OS 提供了可选的抢占式调度方式。支持多种处理器架构，包括 ARM、MIPS、ColdFire 等。uC/OS-III 是 uC/OS 的最新版本，相比于旧版本，具有更强大的功能和改进的性能。 两者的优缺点比较如下：
FreeRTOS 优点：
轻量级、简单易用，适合资源受限的系统。开源免费，可根据需求修改和定制。社区活跃，有大量的文档、示例和支持资源。 FreeRTOS 缺点：
功能相对较少，相比于某些商业 RTOS，可能缺乏一些高级特性和工具支持。部分功能需要额外的模块或者移植。 uC/OS 优点：
提供丰富的功能，满足大部分实时系统的需求。具有商业版和开源版可供选择。支持抢占式调度，适合对实时性要求高的应用。 uC/OS 缺点：
商业版需要购买授权，并且较为昂贵。文档和社区资源相对较少。 在选择 FreeRTOS 还是 uC/OS 时，应根据具体需求、项目要求、开发团队经验和资源等进行综合考虑。如果项目对资源和成本有限制，或需要轻量级的操作系统，那么选择 FreeRTOS 可能更合适。如果项目对实时性要求较高，或需要丰富的功能和工具支持，而且有购买授权的预算，那么 uC/OS 可能更适合。
移植步骤 在将FreeRTOS移植到STM32上之前，您需要进行以下配置：
配置硬件：确保您的STM32芯片与所选择的FreeRTOS版本兼容，并且具备足够的内存资源（ram资源）。您可以参考芯片的数据手册和FreeRTOS的系统要求来确认这些信息。
引入FreeRTOS源代码：将FreeRTOS源代码添加到您的项目中。您可以从FreeRTOS官方网站下载最新的稳定版本或者适用于STM32的移植版。
配置FreeRTOSConfig.h文件：这个文件包含了FreeRTOS的核心配置参数。您需要根据STM32的硬件特性和应用需求进行相应配置。以下是一些可能需要配置的参数：
定时器配置：根据STM32的定时器资源，配置用于FreeRTOS的系统节拍定时器。内存管理器配置：根据可用的RAM大小和需要的内存管理策略，配置内存管理器选项。任务优先级配置：定义任务优先级的范围和默认优先级。栈配置：为每个任务定义适当大小的栈空间。优化配置：根据应用需求进行合适的编译优化设置。 创建任务：在main.c（或其他文件）中创建需要运行的任务，通过调用FreeRTOS提供的API函数进行任务的创建、启动和管理。
配置中断：根据您的应用需求，配置适当的中断处理程序，并使用FreeRTOS提供的接口函数来在中断中进行任务切换。
配置时钟和系统节拍：根据STM32的时钟设置和FreeRTOS的节拍定时器配置，确保系统节拍的准确性和稳定性。
编译和烧录：将修改后的代码编译为可执行文件，并将其烧录到STM32芯片中进行测试和调试。
请注意，以上步骤仅提供了一个大致的概述，实际移植过程可能会因STM32型号、FreeRTOS版本和应用需求而有所差异。建议您参考针对您具体芯片和FreeRTOS版本的移植指南或示例代码，以获得更详细和准确的配置信息和步骤。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/47d022e3d42f4b038df0ffe6c1f61f83/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-09-20T16:32:51+08:00" />
<meta property="article:modified_time" content="2023-09-20T16:32:51+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">FreeRTOS移植以及核心功能</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#freertosucos_2" rel="nofollow">freertos和ucos区别，优缺点比较</a></li><li><a href="#_42" rel="nofollow">移植步骤</a></li><li><a href="#_69" rel="nofollow">核心功能</a></li><li><ul><li><a href="#5_71" rel="nofollow">内存管理（5种内存管理策略）</a></li><li><a href="#FreeRTOS_103" rel="nofollow">FreeRTOS任务调度算法有三种</a></li><li><a href="#_125" rel="nofollow">时间管理</a></li><li><a href="#_130" rel="nofollow">通信管理</a></li></ul> 
  </li><li><a href="#_155" rel="nofollow">栈管理</a></li></ul> 
</div> 
<p></p> 
<h2><a id="freertosucos_2"></a>freertos和ucos区别，优缺点比较</h2> 
<p>FreeRTOS（Free Real-Time Operating System）和 uC/OS（Micro-controller Operating System）都是常见的实时操作系统（RTOS），用于嵌入式系统开发。它们有以下区别和特点：</p> 
<p>FreeRTOS:</p> 
<ul><li>FreeRTOS 是由 Richard Barry 创建的免费开源的实时操作系统。</li><li>FreeRTOS 非常轻量级，使用较少的内存资源，适用于资源有限的嵌入式系统。</li><li>提供了任务管理、调度、时间管理、同步和通信等常见的操作系统功能。</li><li>FreeRTOS 的核心是一个协程调度器，支持协作式多任务处理。</li><li>支持多种处理器架构，包括 ARM、MIPS、X86 等。</li></ul> 
<p>uC/OS:</p> 
<ul><li>uC/OS 是由 Jean J. Labrosse 创建的商业实时操作系统，也有免费的开源版本（uC/OS-II）。</li><li><code>uC/OS 具有丰富的功能，提供了任务管理、调度、同步、通信、内存管理等操作系统服务。</code></li><li><code>对于实时性要求较高的应用，uC/OS 提供了可选的抢占式调度方式。</code></li><li>支持多种处理器架构，包括 ARM、MIPS、ColdFire 等。</li><li>uC/OS-III 是 uC/OS 的最新版本，相比于旧版本，具有更强大的功能和改进的性能。</li></ul> 
<p>两者的优缺点比较如下：</p> 
<p>FreeRTOS 优点：</p> 
<ul><li>轻量级、简单易用，适合资源受限的系统。</li><li>开源免费，可根据需求修改和定制。</li><li>社区活跃，有大量的文档、示例和支持资源。</li></ul> 
<p>FreeRTOS 缺点：</p> 
<ul><li>功能相对较少，相比于某些商业 RTOS，可能缺乏一些高级特性和工具支持。</li><li>部分功能需要额外的模块或者移植。</li></ul> 
<p>uC/OS 优点：</p> 
<ul><li>提供丰富的功能，满足大部分实时系统的需求。</li><li><code>具有商业版和开源版可供选择。</code></li><li><code>支持抢占式调度，适合对实时性要求高的应用。</code></li></ul> 
<p>uC/OS 缺点：</p> 
<ul><li>商业版需要购买授权，并且较为昂贵。</li><li>文档和社区资源相对较少。</li></ul> 
<p>在选择 FreeRTOS 还是 uC/OS 时，应根据具体需求、项目要求、开发团队经验和资源等进行综合考虑。如果项目对资源和成本有限制，或需要轻量级的操作系统，那么选择 FreeRTOS 可能更合适。如果项目对实时性要求较高，或需要丰富的功能和工具支持，而且有购买授权的预算，那么 uC/OS 可能更适合。</p> 
<h2><a id="_42"></a>移植步骤</h2> 
<p>在将FreeRTOS移植到STM32上之前，您需要进行以下配置：</p> 
<ol><li> <p>配置硬件：确保您的STM32芯片与所选择的FreeRTOS<code>版本兼容，并且具备足够的内存资源（ram资源）</code>。您可以参考芯片的数据手册和FreeRTOS的系统要求来确认这些信息。</p> </li><li> <p><code>引入FreeRTOS源代码</code>：将FreeRTOS源代码添加到您的项目中。您可以从FreeRTOS官方网站下载最新的稳定版本或者适用于STM32的移植版。</p> </li><li> <p>配置FreeRTOSConfig.h文件：这个文件包含了FreeRTOS的核心配置参数。您需要根据STM32的硬件特性和应用需求进行相应配置。以下是一些可能需要配置的参数：</p> 
  <ul><li>定时器配置：根据STM32的定时器资源，配置用于FreeRTOS的<code>系统节拍定时器</code>。</li><li>内存管理器配置：根据可用的RAM大小和需要的内存管理策略，<code>配置内存管理器选项</code>。</li><li>任务优先级配置：<code>定义任务优先级的范围和默认优先级</code>。</li><li>栈配置：<code>为每个任务定义适当大小的栈空间</code>。</li><li>优化配置：根据应用需求进行合适的编译优化设置。</li></ul> </li><li> <p>创建任务：在main.c（或其他文件）中创建需要运行的任务，通过调用FreeRTOS提供的API函数进行任务的创建、启动和管理。</p> </li><li> <p>配置中断：根据您的应用需求，配置适当的中断处理程序，并使用FreeRTOS提供的接口函数来在中断中进行任务切换。</p> </li><li> <p>配置时钟和系统节拍：根据STM32的时钟设置和FreeRTOS的节拍定时器配置，确保系统节拍的准确性和稳定性。</p> </li><li> <p>编译和烧录：将修改后的代码编译为可执行文件，并将其烧录到STM32芯片中进行测试和调试。</p> </li></ol> 
<p>请注意，以上步骤仅提供了一个大致的概述，实际移植过程可能会因STM32型号、FreeRTOS版本和应用需求而有所差异。建议您参考针对您具体芯片和FreeRTOS版本的移植指南或示例代码，以获得更详细和准确的配置信息和步骤。</p> 
<h2><a id="_69"></a>核心功能</h2> 
<p><img src="https://images2.imgbox.com/96/57/tHsk2aWO_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="5_71"></a>内存管理（5种内存管理策略）</h3> 
<p><a href="https://blog.csdn.net/Outside_/article/details/132805454?spm=1001.2014.3001.5502">内存管理博文</a></p> 
<p><img src="https://images2.imgbox.com/4d/0f/7tIwxjm7_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>我移植的是内存管理4</p> 
</blockquote> 
<p>Heap_1（只建不删）</p> 
<ul><li>适用场景：创建的任务、队列、信号量等不需要删除。它只实现了 pvPortMalloc，没有实现 vPortFree。如果你的程序不需要删除内核对象，那么可以使用 heap_1：</li></ul> 
<p>Heap_2（Heap1_Pro、提供删除，产生碎片）</p> 
<ul><li>适用场景：频繁的创建和删除任务，且所创建的任务堆栈都相同，此时不会出现碎片化的问题。Heap_2 之所以还保留，只是为了兼容以前的代码。新设计中不再推荐使用 Heap_2。建议使用 Heap_4 来替代 Heap_2，更加高效。</li></ul> 
<p>Heap_3（传统malloc - free）</p> 
<ul><li>Heap_3 使用标准 C 库里的 malloc、 free 函数，所以堆大小由链接器的配置决定，配置项 configTOTAL_HEAP_SIZE 不再起作用。直接用C库的 malloc - free</li></ul> 
<p>Heap_4（Heap2_Pro，解决碎片）</p> 
<ul><li>跟 Heap_1、 Heap_2 一样， Heap_4 也是使用大数组来分配内存。</li><li>Heap_4 使用首次适应算法(first fit)来分配内存。它还会把相邻的空闲内存合并为一个更大的空闲内存，这有助于较少内存的碎片问题。（heap2的升级版）</li></ul> 
<p>Heap_5（Heap4_Pro，可管理分隔内存）</p> 
<ul><li>Heap_5 分配内存、释放内存的算法跟 Heap_4 是一样的。相比于 Heap_4， Heap_5 并不局限于管理一个大数组：它可以管理多块、分隔开的内存。</li></ul> 
<p>优缺点总结：<br> <img src="https://images2.imgbox.com/ff/f0/oJuLUq2Y_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="FreeRTOS_103"></a>FreeRTOS任务调度算法有三种</h3> 
<ul><li>第一种是基于优先级的抢占式任务调度算法，</li><li>第二种是基于<code>优先级的时间片轮转调度算法，</code></li><li>第三种是合作式调度算法。【默认情况为：使用时间片抢占式任务调度】不再使用了</li></ul> 
<p><code>优先级的时间片轮转调度算法是多级反馈队列调度算法的一种变体</code>，它具有以下特点：</p> 
<ol><li> <p>多级优先级：该调度算法将进程划分为多个不同的优先级队列。<code>每个队列具有不同的优先级</code>，通常按照优先级从高到低排序。不同的进程可以被分配到不同的队列中，根据进程的优先级确定所在队列。</p> </li><li> <p>时间片轮转：<code>每个队列都采用时间片轮转的调度策略</code>。每个进程在当前队列中运行一个固定大小的时间片，当时间片用完后，进程被放入队列尾部，并等待下一次调度。</p> </li><li> <p>优先级提升：为了避免低优先级进程饥饿问题，该算法引入了优先级提升机制。当一个进程在低优先级队列中等待一段时间后，其优先级会被提升到更高的队列中，以增加其获得CPU时间片的机会。</p> </li><li> <p>公平性和响应性：<code>该算法旨在实现公平性和响应性的平衡。高优先级的进程会更频繁地获得CPU时间，以保证响应及时；而低优先级的进程也会有机会获得一定的CPU执行时间，以保证公平性</code>。</p> </li><li> <p>动态调整：根据系统负载和进程优先级的变化，该算法具有动态调整的能力。可以根据实时情况增加或减少队列的数量、调整各个队列的时间片大小，以更好地适应不同的工作负载。</p> </li></ol> 
<p>通过以上特点，优先级的时间片轮转调度算法<code>可以在满足高优先级进程响应需求的同时，确保低优先级进程也能得到一定的执行时间，从而在多任务环境中实现较好的公平性和响应性</code>。</p> 
<h3><a id="_125"></a>时间管理</h3> 
<p>这里需要程序员去<code>配置时钟和系统节拍：根据STM32的时钟设置和FreeRTOS的节拍定时器配置，确保系统节拍的准确性和稳定性。</code></p> 
<h3><a id="_130"></a>通信管理</h3> 
<p>消息队列</p> 
<ul><li> <p>队列(queue)可以用于"任务到任务"、“任务到中断”、"中断到任务"直接传输信息，可以实现任务之间的<code>通信</code></p> </li><li> <p>消息队列就是一个像容器一样的东西，我们所有的任务都可以往内部写消息，然后队列会将我们的消息按顺序存下来，所有的任务也可以按顺序将其读出来</p> </li><li> <p>队列需要明确数据的大小以及队列的长度</p> </li></ul> 
<p>信号量</p> 
<ul><li> <p>队列(queue)可以用于传输数据：在任务之间、任务和中断之间，消息队列用于传输多个数据，占用时间按也相对较长，但是有时候我们只需要传递状态，这个状态值需要用一个数值表示，一般是用作同步的效果</p> </li><li> <p>信号量这个名字，我们可以把它拆分来看，信号可以起到通知信号的作用，然后我们的量还可以用来表示资源的数量，当我们的量只有0和1的时候，它就可以被称作二值的信号量，只有两个状态，当我们的那个量没有限制的时候，它就可以被称作为计数型信号量。</p> </li><li> <p>信号量也是队列的一种【因为队列创建的时候，需要传入队列的长度以及队列的大小，而我们的信号量其实就是一种特殊的队列，只不过它的大小是0，毕竟我们的信号量是不需要传递数据，只需要传递信号，然后长度是N，当N=1的时候就是二值信号量，他就只有0和1两个状态，这里的0和1两个状态是指被填入和被拿走这两个状态，当N&gt;1时，就是我们的计数信号量，他也不传递数据，只是传递一个数量值，一般是记录我们设备的资源数量】</p> </li></ul> 
<p>互斥量</p> 
<ul><li>在项目开发中，可能会有多个任务，共用一个资源的情况，为了避免其发生冲突，二值信号量可以一定程度上避免这种事情，但是它多数还是用于同步的状况，如果任务之间出现优先级的差异，就会出现<code>优先级反转的问题</code></li></ul> 
<p>事件组</p> 
<ul><li>场景：一个任务，他执行之前需要经过多个条件进行判断，当这多个条件全部满足或者多个条件中的某一个条件满足他才会执行。使用事件组的优点就是不用多个信号量（标志位）去判断，创建太多的全局变量，而只需要一个事件组即可</li></ul> 
<p>任务通知</p> 
<ul><li>任务通知是我们整个FreeRTOS当中的最后一个通信工具，然后他是FreeRTOS第8个大版本的时候才更新出来的产物，然后我们目前是第10个版本了，相对来说还是一个比较新的概念，并且它的功能是比较强大的，它可以一定程度上的代替二值信号量，计数信号量，队列，还有我们的事件组,并且最重要的是他是我们任务中自带的一个属性，不需要我们单独去创建对应的结构体，所以他的执行效率也快很多</li></ul> 
<h2><a id="_155"></a>栈管理</h2> 
<p>https://blog.csdn.net/ba_wang_mao/article/details/127245356</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6db5e4d216503c0a32c8dee96e764898/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">基于 k8s和docker 构建一个高可用的 web 集群</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d6ba3b40acd3fb5f30da0e03506f8d01/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">MAC地址格式转换</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>