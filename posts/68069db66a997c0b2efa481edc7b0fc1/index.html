<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>（算法）通俗易懂的字符串匹配KMP算法及求next值算法 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="（算法）通俗易懂的字符串匹配KMP算法及求next值算法" />
<meta property="og:description" content="大多数据结构课本中，串涉及的内容即串的模式匹配，需要掌握的是朴素算法、KMP算法及next值的求法。在考研备考中，参考严奶奶的教材，我也是在关于求next值的算法中卡了一下午时间，感觉挺有意思的，把一些思考的结果整理出来，与大家一起探讨。
本文的逻辑顺序为
1、最基本的朴素算法
2、优化的KMP算法
3、应算法需要定义的next值
4、手动写出较短串的next值的方法
5、最难理解的、足足有5行的代码的求next值的算法
所有铺垫为了最后的第5点，我觉得以这个逻辑下来，由果索因还是相对好理解的，下面写的很通俗，略显不专业…
一、问题描述 给定一个主串S及一个模式串P，判断模式串是否为主串的子串；若是，返回匹配的第一个元素的位置（序号从1开始），否则返回0；如S=“abcd”，P=“bcd”，则返回2；S=“abcd”，P=“acb”，返回0。
二、朴素算法 最简单的方法及一次遍历S与P。以S=“abcabaaaabaaacac”,P=&#34;abaabcac&#34;为例，一张动图模拟朴素算法：
这个算法简单，不多说，附上代码
#include&lt;stdio.h&gt; int Index_1(char s[],int sLen,char p[],int pLen){//s为主串，sLen为主串元素个数，p为模式串，pLen为模式串的个数 if(sLen&lt;pLen)return 0; int i = 1,j = 1; while(i&lt;=sLen &amp;&amp; j&lt;=pLen){ if(s[i]==p[j]){i&#43;&#43;;j&#43;&#43;;} else{ i = i-j&#43;2; j = 1; } } if(j&gt;pLen) return i-pLen; return 0; } void main(){ char s[]={&#39; &#39;,&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;a&#39;,&#39;b&#39;,&#39;a&#39;,&#39;a&#39;,&#39;a&#39;,&#39;a&#39;,&#39;b&#39;,&#39;a&#39;,&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;a&#39;,&#39;c&#39;};//从序号1开始存 char p[]={&#39; &#39;,&#39;a&#39;,&#39;b&#39;,&#39;a&#39;,&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;a&#39;,&#39;c&#39;}; int sLen = sizeof(s)/sizeof(char)-1; int pLen = sizeof(p)/sizeof(char)-1; printf(&#34;%d&#34;,Index_1(s,sLen,p,pLen)); } 三、改进的算法——KMP算法 朴素算法理解简单，但两个串都有依次遍历，时间复杂度为O(n*m)，效率不高。由此有了KMP算法。
一般的，在一次匹配中，我们是不知道主串的内容的，而模式串是我们自己定义的。
朴素算法中，P的第j位失配，默认的把P串后移一位。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/68069db66a997c0b2efa481edc7b0fc1/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-10-06T00:23:54+08:00" />
<meta property="article:modified_time" content="2018-10-06T00:23:54+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">（算法）通俗易懂的字符串匹配KMP算法及求next值算法</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-github-gist">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>大多数据结构课本中，串涉及的内容即串的模式匹配，需要掌握的是朴素算法、KMP算法及next值的求法。在考研备考中，参考严奶奶的教材，我也是在关于求next值的算法中卡了一下午时间，感觉挺有意思的，把一些思考的结果整理出来，与大家一起探讨。</p> 
<p>本文的逻辑顺序为<br> 1、最基本的朴素算法<br> 2、优化的KMP算法<br> 3、应算法需要定义的next值<br> 4、手动写出较短串的next值的方法<br> 5、最难理解的、足足有5行的代码的求next值的算法<br> 所有铺垫为了最后的第5点，我觉得以这个逻辑下来，由果索因还是相对好理解的，下面写的很通俗，略显不专业…</p> 
<h4><a id="_9"></a>一、问题描述</h4> 
<p>给定一个主串S及一个模式串P，判断模式串是否为主串的子串；若是，返回匹配的第一个元素的位置（序号从1开始），否则返回0；如S=“abcd”，P=“bcd”，则返回2；S=“abcd”，P=“acb”，返回0。</p> 
<h4><a id="_11"></a>二、朴素算法</h4> 
<p>最简单的方法及一次遍历S与P。以S=“abcabaaaabaaacac”,P="abaabcac"为例，一张动图模拟朴素算法：</p> 
<p><img src="https://images2.imgbox.com/05/06/N3JuVD5Q_o.gif" alt="在这里插入图片描述"><br> 这个算法简单，不多说，附上代码</p> 
<pre><code>#include&lt;stdio.h&gt;
int Index_1(char s[],int sLen,char p[],int pLen){//s为主串，sLen为主串元素个数，p为模式串，pLen为模式串的个数
    if(sLen&lt;pLen)return 0;
    int i = 1,j = 1;
    while(i&lt;=sLen &amp;&amp; j&lt;=pLen){
        if(s[i]==p[j]){i++;j++;}
        else{
            i = i-j+2;
            j = 1;
        }
    }
    if(j&gt;pLen) return i-pLen;
    return 0;
}
void main(){
    char s[]={' ','a','b','c','a','b','a','a','a','a','b','a','a','b','c','a','c'};//从序号1开始存
    char p[]={' ','a','b','a','a','b','c','a','c'};
    int sLen = sizeof(s)/sizeof(char)-1;
    int pLen = sizeof(p)/sizeof(char)-1;
    printf("%d",Index_1(s,sLen,p,pLen));
}
</code></pre> 
<h4><a id="KMP_40"></a>三、改进的算法——KMP算法</h4> 
<p>朴素算法理解简单，但两个串都有依次遍历，时间复杂度为O(n*m)，效率不高。由此有了KMP算法。<br> 一般的，在一次匹配中，我们是不知道主串的内容的，而模式串是我们自己定义的。<br> 朴素算法中，P的第j位失配，默认的把P串<font color="red">后移一位。</font><br> 但在前一轮的比较中，我们已经知道了<font color="red">P的前(j-1)位与S中间对应的某(j-1)个元素已经匹配成功了</font>。这就意味着，在一轮的尝试匹配中，我们get到了主串的部分内容，我们能否利用这些内容，<font color="red">让P多移几位(我认为这就是KMP算法最根本的东西)</font>，减少遍历的趟数呢？答案是肯定的。再看下面改进后的动图：<br> <img src="https://images2.imgbox.com/f6/23/zCEjD0CL_o.gif" alt="在这里插入图片描述"></p> 
<p>这个模拟过程即KMP算法，若没有看明白，继续往下看相应的解释，理解需要把P多移几位，然后回头再看一遍这个图就很明了了。</p> 
<p><strong>相比朴素算法：</strong><br> <font color="red"><strong>朴素算法：</strong> 每次失配，S串的索引i定位的本次尝试匹配的第一个字符的后一个。P串的索引j定位到1；T(n)=O(n*m)<br> <strong>KMP算法：</strong> 每次失配，S串的索引i不动，<strong>P串的索引j定位到某个数</strong>。T(n)=O(n+m)，时间效率明显提高</font></p> 
<p>而这“定位到某个数”，这个数就是接下来引入的<font color="red">next值</font>。（实际上也就是P往后移多少位，换一种说法罢了：从上图中也可以看出，失配时固定i不变，令S[i]与P[某个数]对齐，实际上是P右移几位的另一种表达，只有为什么这么表达，当然是因为程序好写。）</p> 
<p><font color="red"><strong>开——始——划——重——点！（图对逻辑关系比较好理解，但i和j的关系对后面求next的算法好理解！）</strong></font></p> 
<ul><li> <p><strong>比如，P<sub>j</sub>处失配，<font color="gree">绿色的是P<sub>j</sub></font>，则我们可以确定P<sub>1</sub>…P<sub>j-1</sub>是与S<sub>i</sub>…S<sub>i+j-2</sub>相对应的位置一一相等的</strong><br> <img src="https://images2.imgbox.com/e7/06/XoJCMX8U_o.png" alt="在这里插入图片描述"></p> </li><li> <p><strong>假设P<sub>1</sub>…P<sub>j-1</sub>中，P<sub>1</sub>…P<sub>k-1</sub>与P<sub>j-k+1</sub>…P<sub>j-1</sub>是一一相等的，为了下面说的清楚，我们把这种关系叫做“首尾重合”</strong><br> <img src="https://images2.imgbox.com/51/8e/3sPBPLrZ_o.png" alt="在这里插入图片描述"></p> </li><li> <p><strong>那么可以推出，P<sub>1</sub>…P<sub>k-1</sub>与S<sub>i</sub>…S<sub>i+j-2</sub></strong><br> <img src="https://images2.imgbox.com/df/fb/OR8ooNoV_o.png" alt="在这里插入图片描述"></p> </li><li> <p><strong>显然，接下来要做的就是把模式串右移了，移到哪里就不用多说了：</strong><br> <img src="https://images2.imgbox.com/06/64/lKlRjedf_o.png" alt="在这里插入图片描述"></p> </li><li> <p>为了表示下一轮比较j定位的地方，我们<font color="blue">将其定义为next[j]，<strong><mark>next[j]就是第j个元素前j-1个元素首尾重合部分个数加一</mark></strong></font>，当然，<font color="red">为了能遍历完整，首尾重合部分的元素个数应取到最多，即next[j]应取尽量大的值</font>，原因挺好理解的，可以想个例子模拟一下，会完美跳过正确结果。在上图中就是绿色元素的next值为蓝色元素的序号。也即，对于字符串P，next[8]=4。如此，再看一下上面的动图是不是清楚了不少。</p> </li><li> <p>最后，如果我们知道了一个字符串的next值，那么KMP算法也就很好懂了。相比朴素算法，当发生失配时，i不变，j=next[j]就好啦！接下来就是怎么确定next值了。</p> </li></ul> 
<h4><a id="next_70"></a>四、手动写出一个串的next值</h4> 
<p>我们规定任何一个串，next[1]=0。(不用next[0]，与串的所有对应)，仍是一张动图搞定问题：<br> <img src="https://images2.imgbox.com/97/69/vqUrXglj_o.gif" alt="在这里插入图片描述"><br> 这个扫一眼就能依次写出，会了这个方法，应付个期末考试没问题了。</p> 
<p><strong>通过把next值“看”出来，我们再来分析next值，这就很容易得到超级有名的公式了，这个式子对后面的算法理解很重要！所以先要看懂这个式子，如果上面的内容通下来了，这个应该很容易看懂了：</strong><br> <img src="https://images2.imgbox.com/7f/88/mqEEYmV0_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="next_77"></a>五、求next的算法</h4> 
<p>终于到了最后了~短的串的next值我们可以“看”出来，但长的串就需要借助程序了，具体算法刚接触的时候确实不容易理解，但给我的体验，把上面的内容写完，现在感觉简简单单了…先附上程序再做解释，(终于到了传说中的整整5行代码让我整理了一下午)。</p> 
<pre><code class="prism language-c"><span class="token keyword">int</span> <span class="token function">GetNext</span><span class="token punctuation">(</span><span class="token keyword">char</span> ch<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> cLen<span class="token punctuation">,</span><span class="token keyword">int</span> next<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span><span class="token comment">//cLen为串ch的长度</span>
    next<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">&lt;=</span>cLen<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>j<span class="token operator">==</span><span class="token number">0</span><span class="token operator">||</span>ch<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>ch<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> next<span class="token punctuation">[</span><span class="token operator">++</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">++</span>j<span class="token punctuation">;</span>
        <span class="token keyword">else</span> j <span class="token operator">=</span> next<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<ul><li> <p>还是先由一般再推优化：<br> <strong>直接求next[j+1]</strong>（至于为什么是j+1，是为了和下面的对应）<br> 根据之前的分析，<font color="red">next[j+1]的值为p<sub>j+1</sub>的前j个元素的收尾重合的最大个数加一</font>。即需要满足两个条件，把它的值一步步“检验”出来。一是“个数最多”的，因此要从可能的最大值开始验；二是“首尾重合”，因此要一一对应验是否相等。<br> 不难理解，next[j+1]的最大值为j，所有我们<font color="red">从next[j+1]=j开始“验证”</font>。有以下优先判断顺序：<br> <em>if(P<sub>1</sub>…P<sub>j-1</sub> == P<sub>2</sub>…P<sub>j</sub>) =&gt; next[j+1]=j<br> else if(P<sub>1</sub>…P<sub>j-2</sub> == P<sub>3</sub>…P<sub>j</sub>) =&gt;next[j+1]=j-1<br> else if(P<sub>1</sub>…P<sub>j-3</sub> == P<sub>4</sub>…P<sub>j</sub>) =&gt;next[j+1]=j-2<br> …<br> …<br> …<br> else if(P<sub>1</sub>P<sub>2</sub> == P<sub>j-1</sub>P<sub>j</sub>) =&gt; next[j+1]=3<br> else if(P<sub>1</sub> == P<sub>j-1</sub>) =&gt; next[j+1]=2<br> else if(P<sub>1</sub> != P<sub>j-1</sub>) =&gt; next[j+1]=1</em><br> 每次<font color="red">前去尾<strong>1个</strong>，后掐头<strong>1个</strong></font>，直至得到next[j+1]</p> </li><li> <p>再进一步想，next值是一个“工具”，我们单独的求next[j+1]是完全没有意义的，就是说要求next就要把所有j的next求出来。所有一般的，<font color="red">我们都是已知前j个元素的next值，求next[j+1]，以此递推下去，求完整的next数组</font>。<br> 但是，上面的思考过程还是最根本的。所以问题变为两个：知道前j个元素的next的情况下，<br> ①next[j+1]的<font color="red">可能的最大值是多少（即从哪开始验证）</font><br> ②某一步验证失败后，需要<font color="red">“前去尾几个，后掐头几个？”（即本次验证失败后，再验证哪个值）</font><br> 看一下的分析：</p> </li></ul> 
<p><strong>1、next[j+1]的最大值为next[j]+1。</strong><br> 因为：<br> 假设next[j]=k1，则可以说明P<sub>1</sub>…P<sub>k1-1</sub>=P<sub>j-k1+1</sub>…P<sub>j-1</sub>，且这是前j个元素最大的首尾重合序列。<br> 如果P<sub>k1</sub>=P<sub>j</sub>，那么P<sub>1</sub>…P<sub>k1-1</sub>P<sub>K</sub>=P<sub>j-k1+1</sub>…P<sub>j-1</sub>P<sub>j</sub>，那么k+1这也是前j+1个元素的最大首尾重合序列，也即next[j+1]的值为k1+1<br> <strong>2、如果P<sub>k1</sub>≠P<sub>j</sub>，那么next[j+1]可能的次大值为next[next[j]]+1，以此类推即可高效求出next[j+1]</strong><br> 这里不好解释，直接看下面的流程分析及图解</p> 
<p><font color="red"><strong>开——始——划——重——点！</strong></font><br> 从头走一遍流程<br> ①求next[j+1]，设值为m<br> ②<font color="red">已知next[j]=k1，则有P<sub>1</sub>…P<sub>k1-1</sub> = P<sub>j-k1+1</sub>…P<sub>j-1</sub></font><br> ③<font color="blue">如果P<sub>k1</sub>=P<sub>j</sub>，则P<sub>1</sub>…P<sub>k1-1</sub>P<sub>K</sub> = P<sub>j-k1+1</sub>…P<sub>j-1</sub>P<sub>j</sub>，则next[j+1]=k1+1</font>，否则<br> ④<font color="red">已知next[k1]=k2，则有P<sub>1</sub>…P<sub>k2-1</sub> = P<sub>k1-k2+1</sub>…P<sub>k1-1</sub></font><br> ⑤第二第三步联合得到:<br> <font color="red">P<sub>1</sub>…P<sub>k2-1</sub> = P<sub>k1-k2+1</sub>…P<sub>k1-1</sub> = P<sub>j-k1+1</sub>…P<sub>k2-k1+j-1</sub> = P<sub>j-k2+1</sub>…P<sub>j-1</sub> 即四段重合</font><br> ⑥这时候，再判断<font color="blue">如果P<sub>k2</sub>=P<sub>j</sub>，则P<sub>1</sub>…P<sub>k2-1</sub>P~k2 = P<sub>j-k2+1</sub>…P<sub>j-1</sub>P<sub>j</sub>，则next[j+1]=k2+1；</font>否则再取next[k2]=k3…以此类推</p> 
<p>上面几步，耐心看下来，结合那个式子很容易看懂。最后，再加一个图的模拟帮助理解：<br> <strong>1、要求next[k+1] 其中k+1=17</strong><br> <img src="https://images2.imgbox.com/8c/58/sEXsWfja_o.png" alt="在这里插入图片描述"><br> <strong>2、已知next[16]=8，则元素有以下关系：</strong><br> <img src="https://images2.imgbox.com/71/43/HPtm0gox_o.png" alt="在这里插入图片描述"><br> <strong>3、如果P<sub>8</sub>=P<sub>16</sub>，则明显next[17]=8+1=9<br> 4、如果不相等，又若next[8]=4，则有以下关系</strong><br> <img src="https://images2.imgbox.com/fe/dd/kxGy5JVT_o.png" alt="在这里插入图片描述"><br> <strong>又加上2的条件知</strong><br> <img src="https://images2.imgbox.com/b0/67/KT2UtYYg_o.png" alt="在这里插入图片描述"><br> <strong>主要是为了证明：</strong><br> <img src="https://images2.imgbox.com/10/96/Th9nIx3p_o.png" alt="在这里插入图片描述"><br> <strong>5、现在在判断，如果P<sub>16</sub>=P<sub>4</sub>则next[17]=4+1=5，否则，在继续递推</strong><br> <strong>6、若next[4]=2，则有以下关系</strong><br> <img src="https://images2.imgbox.com/f7/cc/0ruBFQ22_o.png" alt="在这里插入图片描述"><br> <strong>7、若P<sub>16</sub>=P<sub>2</sub>，则next[17]=2+1=3;否则继续取next[2]=1、next[1]=0；遇到0时还没出结果，则递推结束，此时next[17]=1。最后，再返回看那5行算法，应该很容易明白了！</strong></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/daeefd0f53edb1c3effaec5c605613f4/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Dubbo的详细介绍、设计思路、以及4大适用场景</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4042721253d8df2aa73dca2400405658/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">C语言利用栈的操作实现判断字符串中的括号是否匹配（只考虑半角括号：( ) { } [ ]）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>