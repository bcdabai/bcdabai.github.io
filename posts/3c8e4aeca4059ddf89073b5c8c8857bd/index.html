<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>关于STM32的裸机多任务多线程心得 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="关于STM32的裸机多任务多线程心得" />
<meta property="og:description" content="多任务多线程 多任务&#34;并行处理&#34; 首先我们来理解一下并行处理，初学者写程序通常是顺序执行，当我们逐渐想成为“专业”人士的时候顺序执行 的程序已经不能满足我们了，所以就需要多任务多线程系统，市面上标准的一些操作系统比如ucos，freeRTOS这些操作系统需要的学习周期长，范围广。在网上看到了一本书&#34;单片机编程魔法师之高级裸编思想&#34;在没学会ucos的阶段学习用这种思想过度感觉非常nice！
单片机是支持多任务同时并行地运行在一个系统中，在具体介绍之前先看一看单片机的硬件结构
这个图中我们可以看出，单片机的运行是在ALU的主导下进行的；而定时器指是一个定时装置，它在定时计数期间是无需ALU干预的，完全独立运行；串口的通讯单元对数据的接收与发送也是完全独立完成的，并不需要ALU干预。很显然这三个任务是并行处理，切互不干涉，只有在定时器或串口产生中断时才会到代码中临时运行一段程序，已向单片机的主体运行过程交付一下结果，以便进行汇总处理。
微操作系统 简单一点来说就是一个while(1)但是while中我们采用多任务多线程的方式管理。首先我们要知道任务有生死，生死是一个过程所以具有寿命。
一个任务的线程：假设一个任务的执行代码有50步，通常编程只会一次执行完毕，但是我们现在需要想想，因为我们会嫌这个任务总占用着ALU的时间而影响其他任务的执行效果，所以就可以对任务进行划分，把它分为5份，每份10步，这样我们每次执行其中的一个程序片–每次正在运行的程序片我们称为线程。
这个图很完美的解释了线程的运行原理。
具体线程的实现：
typedef struct{ u8 isTask_Living; u8 Thread_Process; }myTask; void Task(void) { if(Task.isTask_Living) { Task.isTask_Living = !myThread3(&amp;Task3,&amp;Task3.Thread_Process); } } /*初始化任务变量*/ void InitTask4(myTask4 *Task) { Task-&gt;isTask_Living=1; Task-&gt;Thread_Process=0; } /*功能:任务线程 **参数:myTask:Task任务类型 **	:Process:unsigned char*类型，线程指针 **返回值:CHAR类型，线程结束，或未结束 */ static int myThread(myTask *Task,unsigned char *Process) { int ret=0; switch(*Process) { case 0: //程序片1 break; case 1: //程序片2 break; case 2: //程序编3 break; default:break; } (*Process)&#43;&#43;; if(*Process&gt;3) { ret = -1; *Process = 0; } return ret; } void TaskCommunication(void) { if(Task." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/3c8e4aeca4059ddf89073b5c8c8857bd/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-03-30T18:17:47+08:00" />
<meta property="article:modified_time" content="2019-03-30T18:17:47+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">关于STM32的裸机多任务多线程心得</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="_0"></a>多任务多线程</h2> 
<h3><a id="_2"></a>多任务"并行处理"</h3> 
<p>首先我们来理解一下并行处理，初学者写程序通常是顺序执行，当我们逐渐想成为“专业”人士的时候顺序执行 的程序已经不能满足我们了，所以就需要多任务多线程系统，市面上标准的一些操作系统比如ucos，freeRTOS这些操作系统需要的学习周期长，范围广。在网上看到了一本书"单片机编程魔法师之高级裸编思想"在没学会ucos的阶段学习用这种思想过度感觉非常nice！<br> 单片机是支持多任务同时并行地运行在一个系统中，在具体介绍之前先看一看单片机的硬件结构<br> <img src="https://images2.imgbox.com/7c/d3/y5RsHaE0_o.png" alt="在这里插入图片描述"><br> 这个图中我们可以看出，单片机的运行是在ALU的主导下进行的；而定时器指是一个定时装置，它在定时计数期间是无需ALU干预的，完全独立运行；串口的通讯单元对数据的接收与发送也是完全独立完成的，并不需要ALU干预。很显然这三个任务是并行处理，切互不干涉，只有在定时器或串口产生中断时才会到代码中临时运行一段程序，已向单片机的主体运行过程交付一下结果，以便进行汇总处理。</p> 
<h3><a id="_8"></a>微操作系统</h3> 
<p>简单一点来说就是一个while(1)但是while中我们采用多任务多线程的方式管理。首先我们要知道任务有生死，生死是一个过程所以具有寿命。<br> <strong>一个任务的线程</strong>：假设一个任务的执行代码有50步，通常编程只会一次执行完毕，但是我们现在需要想想，因为我们会嫌这个任务总占用着ALU的时间而影响其他任务的执行效果，所以就可以对任务进行划分，把它分为5份，每份10步，这样我们每次执行其中的一个程序片–每次正在运行的程序片我们称为线程。<br> <img src="https://images2.imgbox.com/42/25/3FZ5AKnC_o.png" alt="在这里插入图片描述"><br> 这个图很完美的解释了线程的运行原理。<br> 具体线程的实现：</p> 
<pre><code>typedef struct{
	u8 isTask_Living;
	u8 Thread_Process;
}myTask;
void Task(void)
{
	if(Task.isTask_Living)
	{
	Task.isTask_Living = !myThread3(&amp;Task3,&amp;Task3.Thread_Process);
	}
}
/*初始化任务变量*/
void InitTask4(myTask4 *Task)
{
	Task-&gt;isTask_Living=1;
	Task-&gt;Thread_Process=0;
}

/*功能:任务线程
**参数:myTask:Task任务类型
**	  :Process:unsigned char*类型，线程指针
**返回值:CHAR类型，线程结束，或未结束
*/
static int myThread(myTask *Task,unsigned char *Process)
{
	int ret=0;
	switch(*Process)
	{
		case 0:
		//程序片1
		break;
		case 1:
		//程序片2
		break;
		case 2:
		//程序编3
		break;
		default:break;
	}
	(*Process)++;
	if(*Process&gt;3)
	{
		ret = -1;
		*Process = 0;
	}
	return ret;
}

void TaskCommunication(void)
{
	if(Task.isTask_Living)
	{
	Task.isTask_Living = !myThread(&amp;Task4,&amp;Task4.Thread_Process);
	}
}
</code></pre> 
<p><img src="https://images2.imgbox.com/98/e0/T9rPxeBM_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/86/7c/J2jWa4FV_o.png" alt="在这里插入图片描述"><br> 真正多任务处理的过程：<br> <img src="https://images2.imgbox.com/f9/d1/rdwQnbcf_o.png" alt="在这里插入图片描述"><br> 仔细理解图上的内容对写多任务程序的结构很有好处。<br> 加油吧骚年们！</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c6143d8523999d0923bd59926ef18724/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">java小技巧之配置文件的路径获取和配置项读取</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ff8436313e9d96f81869cace234f9ce6/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">EndNoteX9 导入期刊显示%J问题解决</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>