<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Docker工具的使用 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Docker工具的使用" />
<meta property="og:description" content="初识 Docker jdk的版本问题，环境造成的问题很常见，称为代码的水土不服
把环境和代码一起传过去
软件跨环境迁移的问题就解决了
Docker 是一个开源的应用容器引擎诞生于 2013 年初，基于 Go 语言实现， dotCloud 公司出品（后改名为Docker Inc）Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上。容器是完全使用沙箱机制，相互隔离容器性能开销极低。Docker 从 17.03 版本之后分为 CE（Community Edition: 社区版） 和 EE（Enterprise Edition: 企业版） 解决环境兼容问题
https://blog.csdn.net/b9567/article/details/105027440/
• 镜像（ Image ）： Docker 镜像（ Image ），就相当于是一个 root 文件系统。比如官方镜像 ubuntu:16.04 就包含了完整的一套 Ubuntu16.04 最小系统的 root 文件系统。 • • 容器（ Container ） ：镜像（ Image ）和容器（ Container ）的关系，就像是面向对象程序设计中的类和对象一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。 • • 仓库（ Repository ） ：仓库可看成一个代码控制中心，用来保存镜像。 Docker 命令 Docker 进程相关命令 • 启动 docker 服务 • 停止 docker 服务 • 重启 docker 服务 • 查看 docker 服务状态 • 开机启动 docker 服务 Docker 镜像相关命令 • 查看镜像 • 搜索镜像 • 拉取镜像 • 删除镜像 查看镜像: 查看本地所有的镜像 tag就是版本号 镜像文件就是各种软件，可以创建" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/25fc9241b534ec6ecfa729b35d800642/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-11-25T11:35:42+08:00" />
<meta property="article:modified_time" content="2020-11-25T11:35:42+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Docker工具的使用</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2><span style="color:#595959;"><strong>初识 </strong></span><span style="color:#595959;"><strong>Docker</strong></span></h2> 
<p><span style="color:#595959;">jdk的版本问题，环境造成的问题很常见，称为代码的水土不服</span></p> 
<p><img alt="" height="424" src="https://images2.imgbox.com/c4/a7/fD0XYD0b_o.png" width="921"></p> 
<p>把环境和代码一起传过去</p> 
<p> <img alt="" height="336" src="https://images2.imgbox.com/cb/4f/inYhmufu_o.png" width="880"></p> 
<p><span style="color:#ff0000;"><strong>软件跨环境迁移的问题就解决了</strong></span></p> 
<p><img alt="" height="175" src="https://images2.imgbox.com/41/d1/PZdpo5c1_o.png" width="219"></p> 
<ul><li style="margin-left:.19in;"><span style="color:#262626;">Docker </span><span style="color:#262626;">是一个开源的应用容器引擎</span></li><li style="margin-left:.19in;"><span style="color:#262626;">诞生于 </span><span style="color:#262626;">2013 </span><span style="color:#262626;">年初，基于 </span><span style="color:#262626;">Go </span><span style="color:#262626;">语言实现，</span><span style="color:#262626;"> dotCloud </span><span style="color:#262626;">公司出品（后改名为</span><span style="color:#262626;">Docker Inc</span><span style="color:#262626;">）</span></li><li style="margin-left:.19in;"><span style="color:#262626;">Docker </span><span style="color:#262626;">可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 </span><span style="color:#262626;">Linux </span><span style="color:#262626;">机器上。</span></li><li style="margin-left:.19in;"><span style="color:#262626;">容器是完全使用沙箱机制，相互隔离</span></li><li style="margin-left:.19in;"><span style="color:#262626;">容器性能开销极低。</span></li><li style="margin-left:.19in;"><span style="color:#262626;">Docker </span><span style="color:#262626;">从 </span><span style="color:#262626;">17.03 </span><span style="color:#262626;">版本之后分为 </span><span style="color:#262626;">CE</span><span style="color:#262626;">（</span><span style="color:#262626;">Community Edition: </span><span style="color:#262626;">社区版） 和 </span><span style="color:#262626;">EE</span><span style="color:#262626;">（</span><span style="color:#262626;">Enterprise Edition: </span><span style="color:#262626;">企业版）</span></li></ul> 
<p><strong>解决环境兼容问题</strong></p> 
<p><a href="https://blog.csdn.net/b9567/article/details/105027440/">https://blog.csdn.net/b9567/article/details/105027440/</a></p> 
<p> </p> 
<p><img alt="" height="391" src="https://images2.imgbox.com/16/54/Wve9luzA_o.png" width="510"></p> 
<div style="margin-left:.19in;">
  • 
 <span style="color:#000000;"><strong>镜像（</strong></span> 
 <span style="color:#000000;"><strong>Image</strong></span> 
 <span style="color:#000000;"><strong>）：</strong></span> 
 <span style="color:#000000;">Docker </span> 
 <span style="color:#000000;">镜像（</span> 
 <span style="color:#000000;">Image</span> 
 <span style="color:#000000;">），就相当于是一个 </span> 
 <span style="color:#000000;">root </span> 
 <span style="color:#000000;">文件系统。比如官方镜像 </span> 
 <span style="color:#000000;">ubuntu:16.04 </span> 
 <span style="color:#000000;">就包含了完整的一套 </span> 
 <span style="color:#000000;">Ubuntu16.04 </span> 
 <span style="color:#000000;">最小系统的 </span> 
 <span style="color:#000000;">root </span> 
 <span style="color:#000000;">文件系统。</span> 
</div> 
<div style="margin-left:.19in;">
  • 
</div> 
<div style="margin-left:.19in;">
  • 
 <span style="color:#000000;"><strong>容器（</strong></span> 
 <span style="color:#000000;"><strong>Container</strong></span> 
 <span style="color:#000000;"><strong>）</strong></span> 
 <span style="color:#000000;">：镜像（</span> 
 <span style="color:#000000;">Image</span> 
 <span style="color:#000000;">）和容器（</span> 
 <span style="color:#000000;">Container</span> 
 <span style="color:#000000;">）的关系，就像是面向对象程序设计中的类和对象一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</span> 
</div> 
<div style="margin-left:.19in;">
  • 
</div> 
<div style="margin-left:.19in;">
  • 
 <span style="color:#000000;"><strong>仓库（</strong></span> 
 <span style="color:#000000;"><strong>Repository</strong></span> 
 <span style="color:#000000;"><strong>）</strong></span> 
 <span style="color:#000000;">：仓库可看成一个代码控制中心，用来保存镜像。</span> 
</div> 
<p> </p> 
<h2><span style="color:#595959;"><strong>Docker </strong></span><span style="color:#595959;"><strong>命令</strong></span></h2> 
<h3><span style="color:#404040;"><strong>Docker 进程</strong></span><span style="color:#404040;"><strong>相关命令</strong></span></h3> 
<div style="margin-left:.19in;">
  • 
 <span style="color:#262626;">启动</span> 
 <span style="color:#262626;">docker</span> 
 <span style="color:#262626;">服务</span> 
</div> 
<div style="margin-left:.19in;">
  • 
 <span style="color:#262626;">停止</span> 
 <span style="color:#262626;">docker</span> 
 <span style="color:#262626;">服务 </span> 
</div> 
<div style="margin-left:.19in;">
  • 
 <span style="color:#262626;">重启</span> 
 <span style="color:#262626;">docker</span> 
 <span style="color:#262626;">服务 </span> 
</div> 
<div style="margin-left:.19in;">
  • 
 <span style="color:#262626;">查看</span> 
 <span style="color:#262626;">docker</span> 
 <span style="color:#262626;">服务状态</span> 
</div> 
<div style="margin-left:.19in;">
  • 
 <span style="color:#262626;">开机启动</span> 
 <span style="color:#262626;">docker</span> 
 <span style="color:#262626;">服务</span> 
</div> 
<div style="margin-left:.19in;"> 
 <img alt="" height="385" src="https://images2.imgbox.com/a4/de/jL41fl7v_o.png" width="344"> 
</div> 
<div style="margin-left:.19in;">
    
</div> 
<div style="margin-left:.19in;">
    
</div> 
<h3 style="margin-left:.19in;"><span style="color:#404040;"><strong>Docker </strong></span><span style="color:#404040;"><strong>镜像相关命令</strong></span></h3> 
<div style="margin-left:.19in;">
  • 
 <span style="color:#262626;">查看镜像 </span> 
</div> 
<div style="margin-left:.19in;">
  • 
 <span style="color:#262626;">搜索镜像 </span> 
</div> 
<div style="margin-left:.19in;">
  • 
 <span style="color:#262626;">拉取镜像 </span> 
</div> 
<div style="margin-left:.19in;">
  • 
 <span style="color:#262626;">删除镜像</span> 
</div> 
<div style="margin-left:.19in;">
    
</div> 
<ol><li style="margin-left:.19in;"><span style="color:#262626;">查看镜像</span><span style="color:#262626;">: </span><span style="color:#262626;">查看本地所有的镜像</span></li></ol> 
<div style="margin-left:.19in;">
  tag就是版本号 
</div> 
<div style="margin-left:.19in;">
    
</div> 
<div style="margin-left:.19in;"> 
 <img alt="" height="92" src="https://images2.imgbox.com/64/86/HxRob4LH_o.png" width="791"> 
</div> 
<p> </p> 
<p>镜像文件就是各种软件，可以创建</p> 
<p>2、<span style="color:#262626;">搜索镜像</span><span style="color:#262626;">:</span><span style="color:#262626;">从网络中查找需要的镜像</span></p> 
<div style="margin-left:.19in;"> 
 <img alt="" height="307" src="https://images2.imgbox.com/fb/28/ENoYakWy_o.png" width="1181"> 
</div> 
<p> <span style="color:#262626;">3、拉取镜像:</span><span style="color:#262626;">从</span><span style="color:#262626;">Docker</span><span style="color:#262626;">仓库下载镜像到本地，镜像名称格式为 名称</span><span style="color:#262626;">:</span><span style="color:#262626;">版本号，如果版本号不指定则是最新的版本。</span></p> 
<p><span style="color:#262626;">如果不知道镜像版本，可以去docker hub 搜索对应镜像查看。</span><a href="https://hub.docker.com/" rel="nofollow">https://hub.docker.com/</a></p> 
<p> <img alt="" height="269" src="https://images2.imgbox.com/ca/43/eA4j5fjV_o.png" width="730"></p> 
<p> <img alt="" height="85" src="https://images2.imgbox.com/03/34/jmeQfQL0_o.png" width="816"></p> 
<div style="margin-left:.19in;"> 
 <p style="text-indent:0;"> </p> 
</div> 
<p>4、<span style="color:#262626;">删除镜像</span><span style="color:#262626;">: </span><span style="color:#262626;">删除本地镜像</span></p> 
<pre><code class="language-bash">docker rmi 镜像id # 删除指定本地镜像
docker rmi `docker images -q`  # 删除所有本地镜像
</code></pre> 
<p> <img alt="" height="208" src="https://images2.imgbox.com/7f/eb/ncsh5xcE_o.png" width="792"></p> 
<h3> <span style="color:#404040;"><strong>Docker </strong></span><span style="color:#404040;"><strong>容器相关命令</strong></span></h3> 
<div style="margin-left:.19in;">
  • 
 <span style="color:#262626;">查看容器</span> 
</div> 
<div style="margin-left:.19in;">
  • 
 <span style="color:#262626;">创建</span> 
 <span style="color:#262626;">容器</span> 
</div> 
<div style="margin-left:.19in;">
  • 
 <span style="color:#262626;">进入容器</span> 
</div> 
<div style="margin-left:.19in;">
  • 
 <span style="color:#262626;">启动容器</span> 
</div> 
<div style="margin-left:.19in;">
  • 
 <span style="color:#262626;">停止容器</span> 
</div> 
<div style="margin-left:.19in;">
  • 
 <span style="color:#262626;">删除容器</span> 
</div> 
<div style="margin-left:.19in;">
  • 
 <span style="color:#262626;">查看容器信息</span> 
</div> 
<div style="margin-left:.19in;">
    
</div> 
<p><img alt="" height="326" src="https://images2.imgbox.com/fb/9b/x7aodZG9_o.png" width="851"></p> 
<p><img alt="" height="81" src="https://images2.imgbox.com/bb/b1/qvZ5VY7D_o.png" width="750"></p> 
<p>已经进入了容器的内部，并由容器对应的ID，并用/bin/bash打开一个shell窗口</p> 
<p><img alt="" height="67" src="https://images2.imgbox.com/36/8e/LBN2qoVE_o.png" width="375"></p> 
<p>回到宿主机</p> 
<p><img alt="" height="149" src="https://images2.imgbox.com/7b/2d/yBz1J1ya_o.png" width="1200"></p> 
<p> 容器以-id的身份进入，需要命令才能进入</p> 
<p><img alt="" height="188" src="https://images2.imgbox.com/ae/74/5GGSntrg_o.png" width="1200"></p> 
<p><img alt="" height="53" src="https://images2.imgbox.com/1f/e1/svkf8BxV_o.png" width="657"></p> 
<p>退出的话不会关闭</p> 
<p><img alt="" height="380" src="https://images2.imgbox.com/e9/8b/8tv9me5y_o.png" width="588"></p> 
<h2><strong>Docker 容器的数据卷</strong></h2> 
<h3><span style="color:#262626;">数据卷概念及作用</span></h3> 
<p>•<span style="color:#262626;">Docker </span><span style="color:#262626;">容器删除后，在容器中产生的数据还在吗？</span></p> 
<p>•<span style="color:#262626;">Docker </span><span style="color:#262626;">容器和外部机器可以直接交换文件吗？</span></p> 
<p>•<span style="color:#262626;">容器之间想要进行数据交互？</span></p> 
<p><img alt="" height="228" src="https://images2.imgbox.com/d7/a1/iRhpJFjM_o.png" width="376"></p> 
<p><img alt="" height="227" src="https://images2.imgbox.com/fe/e3/PFapg0qJ_o.png" width="549"></p> 
<p><img alt="" height="275" src="https://images2.imgbox.com/38/ec/wz6H1qDW_o.png" width="356"></p> 
<p> </p> 
<p> </p> 
<p><span style="color:#ff0000;"><strong>数据卷</strong></span></p> 
<p><span style="color:#262626;">数据卷是宿主机中的一个目录或文件</span></p> 
<p><span style="color:#262626;">当容器目录和数据卷目录绑定后，对方的修改会立即同步</span></p> 
<p><span style="color:#262626;">一个数据卷可以被多个容器同时挂载</span></p> 
<p><span style="color:#262626;">一个容器也可以被挂载多个数据卷</span></p> 
<p><span style="color:#ff0000;"><strong>数据卷作用</strong></span></p> 
<p><span style="color:#262626;">容器数据持久化</span></p> 
<p><span style="color:#262626;">外部机器和容器间接通信</span></p> 
<p><span style="color:#262626;">容器之间数据交换</span></p> 
<p> </p> 
<h3><span style="color:#404040;"><strong>配置数据卷</strong></span></h3> 
<p><span style="color:#262626;">创建启动容器时，使用 </span><span style="color:#262626;">–v </span><span style="color:#262626;">参数 设置数据卷</span></p> 
<p><span style="color:#000080;"><strong>docker run ... </strong></span><span style="color:#ff0000;"><strong>–v </strong></span><span style="color:#ff0000;"><strong>宿主机目录</strong></span><span style="color:#ff0000;"><strong>(</strong></span><span style="color:#ff0000;"><strong>文件</strong></span><span style="color:#ff0000;"><strong>):</strong></span><span style="color:#ff0000;"><strong>容器内目录</strong></span><span style="color:#ff0000;"><strong>(</strong></span><span style="color:#ff0000;"><strong>文件</strong></span><span style="color:#ff0000;"><strong>) ... </strong></span></p> 
<p><span style="color:#262626;">注意事项：</span></p> 
<p><span style="color:#262626;">        1. </span><span style="color:#262626;">目录必须是绝对路径</span></p> 
<p><span style="color:#262626;">        2. </span><span style="color:#262626;">如果目录不存在，会自动创建</span></p> 
<p><span style="color:#262626;">        3. </span><span style="color:#262626;">可以挂载多个数据卷</span></p> 
<p><img alt="" height="227" src="https://images2.imgbox.com/28/23/EN5WwE6u_o.png" width="464"></p> 
<p>挂载后宿主机目录添加文件，容器也会相应的变化</p> 
<p><img alt="" height="114" src="https://images2.imgbox.com/9c/aa/9qrioVnv_o.png" width="467"></p> 
<p><img alt="" height="89" src="https://images2.imgbox.com/0f/cc/jDwOpdDr_o.png" width="416"></p> 
<p>并且数据可以持久化的保存在宿主机中，保证下次使用的时候也能正常使用</p> 
<p>可以挂载多个目录</p> 
<p><img alt="" height="78" src="https://images2.imgbox.com/86/62/Vlk8gUDM_o.png" width="622"></p> 
<p> </p> 
<h4><span style="color:#262626;">多容器进行数据交换</span></h4> 
<p><span style="color:#262626;">       1. </span><span style="color:#262626;">多个容器挂载同一个数据卷</span></p> 
<p><span style="color:#262626;">       2. </span><span style="color:#262626;">数据卷容器</span></p> 
<div style="margin-left:.19in;">
    
</div> 
<p><img alt="" height="260" src="https://images2.imgbox.com/28/e3/pavvAvbT_o.png" width="541"></p> 
<h4><span style="color:#404040;"><strong>配置数据卷容器</strong></span></h4> 
<p><img alt="" height="262" src="https://images2.imgbox.com/81/ea/lUzrNhNJ_o.png" width="939"></p> 
<p>会自动绑定同一个数据卷，c3删除也不会影响c1、c2</p> 
<p><img alt="" height="341" src="https://images2.imgbox.com/d9/a0/3V9rWIHz_o.png" width="823"></p> 
<h2><strong>Docker 应用部署</strong></h2> 
<h3><span style="color:#404040;"><strong>MySQL</strong></span><span style="color:#404040;"><strong>部署</strong></span></h3> 
<p>①<span style="color:#262626;">搜索</span><span style="color:#262626;">mysql</span><span style="color:#262626;">镜像</span></p> 
<p>②<span style="color:#262626;">拉取</span><span style="color:#262626;">mysql</span><span style="color:#262626;">镜像</span></p> 
<p>③<span style="color:#262626;">创建容器</span></p> 
<p>④<span style="color:#262626;">操作容器中的</span><span style="color:#262626;">mysql</span></p> 
<p> </p> 
<p><img alt="" height="226" src="https://images2.imgbox.com/96/d6/Ul0WvURs_o.png" width="541"></p> 
<p style="margin-left:.19in;">•<span style="color:#262626;">容器内的网络服务和外部机器不能直接通信</span></p> 
<p style="margin-left:.19in;">•<span style="color:#262626;">外部机器和宿主机可以直接通信</span></p> 
<p style="margin-left:.19in;">•<span style="color:#262626;">宿主机和容器可以直接通信</span></p> 
<p style="margin-left:.19in;">•<span style="color:#262626;">当容器中的网络服务需要被外部机器访问时，可以将容器中提供服务的端口映射到宿主机的端口上。外部机器访问宿主机的该端口，从而间接访问容器的服务。</span></p> 
<p style="margin-left:.19in;">•<span style="color:#262626;">这种操作称为：</span><span style="color:#ff0000;"><strong>端口映射</strong></span></p> 
<p style="margin-left:.19in;"> </p> 
<h4>一、部署MySQL</h4> 
<ol><li> <p>搜索mysql镜像</p> </li></ol> 
<pre><code class="language-html">docker search mysql</code></pre> 
<ol><li> <p>拉取mysql镜像</p> </li></ol> 
<pre><code class="language-html">docker pull mysql:5.6</code></pre> 
<ol><li> <p>创建容器，设置端口映射、目录映射</p> </li></ol> 
<pre><code class="language-html"># 在/root目录下创建mysql目录用于存储mysql数据信息
mkdir ~/mysql
cd ~/mysql</code></pre> 
<pre><code class="language-html">docker run -id \
-p 3307:3306 \
--name=c_mysql \
-v $PWD/conf:/etc/mysql/conf.d \
-v $PWD/logs:/logs \
-v $PWD/data:/var/lib/mysql \
-e MYSQL_ROOT_PASSWORD=123456 \
mysql:5.6</code></pre> 
<ul><li> <p>参数说明：</p> </li><li> <p><strong>-p 3307:3306</strong>：将容器的 3306 端口映射到宿主机的 3307 端口。</p> </li><li> <p><strong>-v $PWD/conf:/etc/mysql/conf.d</strong>：将主机当前目录下的 conf/my.cnf 挂载到容器的 /etc/mysql/my.cnf。配置目录</p> </li><li> <p><strong>-v $PWD/logs:/logs</strong>：将主机当前目录下的 logs 目录挂载到容器的 /logs。日志目录</p> </li><li> <p><strong>-v $PWD/data:/var/lib/mysql</strong> ：将主机当前目录下的data目录挂载到容器的 /var/lib/mysql 。数据目录</p> </li><li> <p><strong>-e MYSQL_ROOT_PASSWORD=123456：</strong>初始化 root 用户的密码。</p> </li></ul> 
<p>4. 进入容器，操作mysql</p> 
<pre><code class="language-bash">docker exec –it c_mysql /bin/bash</code></pre> 
<p>5. 使用外部机器连接容器中的mysql</p> 
<p>就是自己服务器的ip</p> 
<p><img alt="" height="191" src="https://images2.imgbox.com/95/8b/8yytKK0o_o.png" width="413"></p> 
<h4>二、部署Tomcat</h4> 
<p>搜索tomcat镜像</p> 
<pre><code class="language-html">docker search tomcat</code></pre> 
<p>拉取tomcat镜像</p> 
<pre><code class="language-html">docker pull tomcat</code></pre> 
<p>创建容器，设置端口映射、目录映射</p> 
<pre><code class="language-html"># 在/root目录下创建tomcat目录用于存储tomcat数据信息
mkdir ~/tomcat
cd ~/tomcat</code></pre> 
<pre><code class="language-html">docker run -id --name=c_tomcat \
-p 8080:8080 \
-v $PWD:/usr/local/tomcat/webapps \
tomcat </code></pre> 
<ul><li> <p>参数说明：</p> 
  <ul><li> <p><strong>-p 8080:8080：</strong>将容器的8080端口映射到主机的8080端口</p> <p><strong>-v $PWD:/usr/local/tomcat/webapps：</strong>将主机中当前目录挂载到容器的webapps</p> </li></ul></li></ul> 
<p>使用外部机器访问tomcat</p> 
<p><img alt="" height="94" src="https://images2.imgbox.com/4e/1a/dwMEFC9H_o.png" width="671"></p> 
<p> 写好项目直接扔到tomcat目录中</p> 
<h4>三、部署Nginx</h4> 
<p>1、搜索nginx镜像</p> 
<pre><code class="language-html">docker search nginx</code></pre> 
<p>2、拉取nginx镜像</p> 
<pre><code class="language-html">docker pull nginx</code></pre> 
<p>创建容器，设置端口映射、目录映射</p> 
<pre><code class="language-bash"># 在/root目录下创建nginx目录用于存储nginx数据信息
mkdir ~/nginx
cd ~/nginx
mkdir conf
cd conf
# 在~/nginx/conf/下创建nginx.conf文件,粘贴下面内容
vim nginx.conf</code></pre> 
<pre><code class="language-bash">user  nginx;
worker_processes  1;

error_log  /var/log/nginx/error.log warn;
pid        /var/run/nginx.pid;


events {
    worker_connections  1024;
}


http {
    include       /etc/nginx/mime.types;
    default_type  application/octet-stream;

    log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
                      '$status $body_bytes_sent "$http_referer" '
                      '"$http_user_agent" "$http_x_forwarded_for"';

    access_log  /var/log/nginx/access.log  main;

    sendfile        on;
    #tcp_nopush     on;

    keepalive_timeout  65;

    #gzip  on;

    include /etc/nginx/conf.d/*.conf;
}
</code></pre> 
<pre><code class="language-bash">docker run -id --name=c_nginx \
-p 80:80 \
-v $PWD/conf/nginx.conf:/etc/nginx/nginx.conf \
-v $PWD/logs:/var/log/nginx \
-v $PWD/html:/usr/share/nginx/html \
nginx</code></pre> 
<p>参数说明：</p> 
<ul><li> <p><strong>-p 80:80</strong>：将容器的 80端口映射到宿主机的 80 端口。</p> </li><li> <p><strong>-v $PWD/conf/nginx.conf:/etc/nginx/nginx.conf</strong>：将主机当前目录下的 /conf/nginx.conf 挂载到容器的 :/etc/nginx/nginx.conf。配置目录</p> </li><li> <p><strong>-v $PWD/logs:/var/log/nginx</strong>：将主机当前目录下的 logs 目录挂载到容器的/var/log/nginx。日志目录</p> </li></ul> 
<p>4、使用外部机器访问nginx</p> 
<p> </p> 
<h4>四、部署Redis</h4> 
<p>1、搜索redis镜像</p> 
<pre><code class="language-html">docker search redis</code></pre> 
<p>2、拉取redis镜像</p> 
<pre><code class="language-html">docker pull redis:5.0</code></pre> 
<p>3、创建容器，设置端口映射</p> 
<pre><code class="language-html">docker run -id --name=c_redis -p 6379:6379 redis:5.0</code></pre> 
<p>4、使用windows的外部机器连接redis</p> 
<pre><code class="language-html">redis-cli.exe -h 192.168.149.135 -p 6379</code></pre> 
<h2><strong>Dockerfile</strong></h2> 
<h3><span style="color:#404040;"><strong>Docker </strong></span><span style="color:#404040;"><strong>镜像原理</strong></span></h3> 
<div style="margin-left:.19in;">
  • 
 <span style="color:#262626;">Docker </span> 
 <span style="color:#262626;">镜像本质是什么？</span> 
</div> 
<div style="margin-left:.19in;">
  • 
 <span style="color:#262626;">Docker </span> 
 <span style="color:#262626;">中一个</span> 
 <span style="color:#262626;">centos</span> 
 <span style="color:#262626;">镜像为什么只有</span> 
 <span style="color:#262626;">200MB</span> 
 <span style="color:#262626;">，而一个</span> 
 <span style="color:#262626;">centos</span> 
 <span style="color:#262626;">操作系统的</span> 
 <span style="color:#262626;">iso</span> 
 <span style="color:#262626;">文件要几个个</span> 
 <span style="color:#262626;">G</span> 
 <span style="color:#262626;">？</span> 
</div> 
<div style="margin-left:.19in;">
  • 
 <span style="color:#262626;">Docker </span> 
 <span style="color:#262626;">中一个</span> 
 <span style="color:#262626;">tomcat</span> 
 <span style="color:#262626;">镜像为什么</span> 
 <span style="color:#262626;">有</span> 
 <span style="color:#262626;">500MB</span> 
 <span style="color:#262626;">，而一个</span> 
 <span style="color:#262626;">tomcat</span> 
 <span style="color:#262626;">安装包只有</span> 
 <span style="color:#262626;">70</span> 
 <span style="color:#262626;">多</span> 
 <span style="color:#262626;">MB</span> 
 <span style="color:#262626;">？</span> 
</div> 
<p> </p> 
<p><img alt="" height="343" src="https://images2.imgbox.com/98/98/vlsvhmkR_o.png" width="447"></p> 
<p> </p> 
<p><span style="color:#262626;">操作系统组成部分：</span></p> 
<p>•<span style="color:#262626;">进程调度子系统</span></p> 
<p>•<span style="color:#262626;">进程通信子系统</span></p> 
<p>•<span style="color:#262626;">内存管理子系统</span></p> 
<p>•<span style="color:#262626;">设备管理子系统</span></p> 
<p>•<span style="color:#ff0000;">文件管理子系统</span></p> 
<p>•<span style="color:#262626;">网络通信子系统</span></p> 
<p>•<span style="color:#262626;">作业控制子系统</span></p> 
<p> </p> 
<p><span style="color:#262626;">Linux</span><span style="color:#262626;">文件系统由</span><span style="color:#262626;">bootfs</span><span style="color:#262626;">和</span><span style="color:#262626;">rootfs</span><span style="color:#262626;">两部分组成</span></p> 
<div style="margin-left:.19in;">
  • 
 <span style="color:#262626;"> bootfs</span> 
 <span style="color:#262626;">：包含</span> 
 <span style="color:#262626;">bootloader</span> 
 <span style="color:#262626;">（引导加载程序）和 </span> 
 <span style="color:#262626;">kernel</span> 
 <span style="color:#262626;">（内核）</span> 
</div> 
<div style="margin-left:.19in;">
  • 
 <span style="color:#262626;"> rootfs</span> 
 <span style="color:#262626;">： </span> 
 <span style="color:#000000;">root</span> 
 <span style="color:#000000;">文件系统，</span> 
 <span style="color:#262626;">包含的就是典型 </span> 
 <span style="color:#262626;">Linux </span> 
 <span style="color:#262626;">系统中的</span> 
 <span style="color:#262626;">/dev</span> 
 <span style="color:#262626;">，</span> 
 <span style="color:#262626;">/proc</span> 
 <span style="color:#262626;">，</span> 
 <span style="color:#262626;">/bin</span> 
 <span style="color:#262626;">，</span> 
 <span style="color:#262626;">/etc</span> 
 <span style="color:#262626;">等标准目录和文件</span> 
</div> 
<div style="margin-left:.19in;">
  • 
 <span style="color:#262626;">不同的</span> 
 <span style="color:#262626;">linux</span> 
 <span style="color:#262626;">发行版，</span> 
 <span style="color:#262626;">bootfs</span> 
 <span style="color:#262626;">基本一样，而</span> 
 <span style="color:#262626;">rootfs</span> 
 <span style="color:#262626;">不同，如</span> 
 <span style="color:#262626;">ubuntu</span> 
 <span style="color:#262626;">，</span> 
 <span style="color:#262626;">centos</span> 
 <span style="color:#262626;">等</span> 
</div> 
<div style="margin-left:.19in;">
    
</div> 
<div style="margin-left:.19in;"> 
 <img alt="" height="131" src="https://images2.imgbox.com/20/3c/koeegRAw_o.png" width="355"> 
</div> 
<div style="margin-left:.19in;">
    
</div> 
<div style="margin-left:.19in;"> 
 <div style="margin-left:.19in;">
   • 
  <span style="color:#000000;">Docker</span> 
  <span style="color:#000000;">镜像是由特殊的文件系统叠加而成</span> 
 </div> 
 <div style="margin-left:.19in;">
   • 
  <span style="color:#000000;">最底端是 </span> 
  <span style="color:#000000;">bootfs</span> 
  <span style="color:#000000;">，并使用宿主机的</span> 
  <span style="color:#000000;">bootfs</span> 
 </div> 
 <div style="margin-left:.19in;">
   • 
  <span style="color:#000000;">第二层是 </span> 
  <span style="color:#000000;">root</span> 
  <span style="color:#000000;">文件系统</span> 
  <span style="color:#000000;">rootfs,</span> 
  <span style="color:#000000;">称为</span> 
  <span style="color:#000000;">base image</span> 
 </div> 
 <div style="margin-left:.19in;">
   • 
  <span style="color:#000000;">然后再往上可以叠加其他的镜像文件</span> 
 </div> 
 <div style="margin-left:.19in;">
     
 </div> 
 <div style="margin-left:.19in;">
   • 
  <span style="color:#000000;">统一文件系统（</span> 
  <span style="color:#000000;">Union File System</span> 
  <span style="color:#000000;">）技术能够将不同的层整合成一个文件系统，为这些层提供了一个统一的视角，这样就隐藏了多层的存在，在用户的角度看来，只存在一个文件系统。 </span> 
 </div> 
 <div style="margin-left:.19in;">
   • 
  <span style="color:#000000;">一个镜像可以放在另一个镜像的上面。位于下面的镜像称为父镜像，最底部的镜像成为基础镜像。</span> 
 </div> 
 <div style="margin-left:.19in;">
   • 
  <span style="color:#000000;">当从一个镜像启动容器时，</span> 
  <span style="color:#000000;">Docker</span> 
  <span style="color:#000000;">会在最顶层加载一个读写文件系统作为容器</span> 
 </div> 
</div> 
<div style="margin-left:.19in;">
    
</div> 
<div style="margin-left:.19in;">
    
</div> 
<p> <img alt="" height="415" src="https://images2.imgbox.com/86/64/Qu8OxcOY_o.png" width="503"></p> 
<p> </p> 
<div style="margin-left:.25in;">
  1. 
 <span style="color:#262626;">Docker </span> 
 <span style="color:#262626;">镜像本质是什么？</span> 
</div> 
<div style="margin-left:.69in;">
  • 
 <span style="color:#262626;">是一个分层文件系统</span> 
</div> 
<div style="margin-left:.25in;">
  2. 
 <span style="color:#262626;">Docker </span> 
 <span style="color:#262626;">中一个</span> 
 <span style="color:#262626;">centos</span> 
 <span style="color:#262626;">镜像为什么只有</span> 
 <span style="color:#262626;">200MB</span> 
 <span style="color:#262626;">，而一个</span> 
 <span style="color:#262626;">centos</span> 
 <span style="color:#262626;">操作系统的</span> 
 <span style="color:#262626;">iso</span> 
 <span style="color:#262626;">文件要几个个</span> 
 <span style="color:#262626;">G</span> 
 <span style="color:#262626;">？</span> 
</div> 
<div style="margin-left:.69in;">
  • 
 <span style="color:#262626;">Centos</span> 
 <span style="color:#262626;">的</span> 
 <span style="color:#262626;">iso</span> 
 <span style="color:#262626;">镜像文件包含</span> 
 <span style="color:#262626;">bootfs</span> 
 <span style="color:#262626;">和</span> 
 <span style="color:#262626;">rootfs</span> 
 <span style="color:#262626;">，而</span> 
 <span style="color:#262626;">docker</span> 
 <span style="color:#262626;">的</span> 
 <span style="color:#262626;">centos</span> 
 <span style="color:#262626;">镜像复用操作系统的</span> 
 <span style="color:#262626;">bootfs</span> 
 <span style="color:#262626;">，只有</span> 
 <span style="color:#262626;">rootfs</span> 
 <span style="color:#262626;">和其他镜像层</span> 
</div> 
<div style="margin-left:.25in;">
  3. 
 <span style="color:#262626;">Docker </span> 
 <span style="color:#262626;">中一个</span> 
 <span style="color:#262626;">tomcat</span> 
 <span style="color:#262626;">镜像为什么</span> 
 <span style="color:#262626;">有</span> 
 <span style="color:#262626;">500MB</span> 
 <span style="color:#262626;">，而一个</span> 
 <span style="color:#262626;">tomcat</span> 
 <span style="color:#262626;">安装包只有</span> 
 <span style="color:#262626;">70</span> 
 <span style="color:#262626;">多</span> 
 <span style="color:#262626;">MB</span> 
 <span style="color:#262626;">？</span> 
</div> 
<div style="margin-left:.69in;">
  • 
 <span style="color:#262626;">由于</span> 
 <span style="color:#262626;">docker</span> 
 <span style="color:#262626;">中镜像是分层的，</span> 
 <span style="color:#262626;">tomcat</span> 
 <span style="color:#262626;">虽然只有</span> 
 <span style="color:#262626;">70</span> 
 <span style="color:#262626;">多</span> 
 <span style="color:#262626;">MB</span> 
 <span style="color:#262626;">，但他需要依赖于父镜像和基础镜像，所有整个对外暴露的</span> 
 <span style="color:#262626;">tomcat</span> 
 <span style="color:#262626;">镜像</span> 
 <span style="color:#262626;">大小</span> 
 <span style="color:#262626;">500</span> 
 <span style="color:#262626;">多</span> 
 <span style="color:#262626;">MB</span> 
</div> 
<p> </p> 
<h4><span style="color:#404040;"><strong>镜像制作</strong></span></h4> 
<p><img alt="" height="447" src="https://images2.imgbox.com/82/71/7PVFK8Je_o.png" width="1200"></p> 
<p>目录挂载的不生效，不会放在镜像中</p> 
<p>但是根目录里的会生效，了解一下就行了</p> 
<h4><span style="color:#404040;"><strong>Dockerfile</strong></span> <span style="color:#404040;"><strong>概念</strong></span></h4> 
<p><span style="color:#262626;">Dockerfile </span><span style="color:#262626;">是一个文本文件</span></p> 
<p><span style="color:#262626;">包含了一条条的指令</span></p> 
<p><span style="color:#262626;">每一条指令构建一层，基于基础镜像，最终构建出一个新的镜像</span></p> 
<p><span style="color:#262626;">对于开发人员：可以为开发团队提供一个完全一致的开发环境</span></p> 
<p><span style="color:#262626;">对于测试人员：可以直接拿开发时所构建的镜像或者通过</span><span style="color:#262626;">Dockerfile</span><span style="color:#262626;">文件构建一个新的镜像开始工作了</span></p> 
<p><span style="color:#262626;">对于运维人员：在部署时，可以实现应用的无缝移植</span></p> 
<p><img alt="" height="374" src="https://images2.imgbox.com/c8/21/bTx9XXJm_o.png" width="333"></p> 
<table><thead><tr><th>关键字</th><th>作用</th><th>备注</th></tr></thead><tbody><tr><td>FROM</td><td>指定父镜像</td><td>指定dockerfile基于那个image构建</td></tr><tr><td>MAINTAINER</td><td>作者信息</td><td>用来标明这个dockerfile谁写的</td></tr><tr><td>LABEL</td><td>标签</td><td>用来标明dockerfile的标签 可以使用Label代替Maintainer 最终都是在docker image基本信息中可以查看</td></tr><tr><td>RUN</td><td>执行命令</td><td>执行一段命令 默认是/bin/sh 格式: RUN command 或者 RUN ["command" , "param1","param2"]</td></tr><tr><td>CMD</td><td>容器启动命令</td><td>提供启动容器时候的默认命令 和ENTRYPOINT配合使用.格式 CMD command param1 param2 或者 CMD ["command" , "param1","param2"]</td></tr><tr><td>ENTRYPOINT</td><td>入口</td><td>一般在制作一些执行就关闭的容器中会使用</td></tr><tr><td>COPY</td><td>复制文件</td><td>build的时候复制文件到image中</td></tr><tr><td>ADD</td><td>添加文件</td><td>build的时候添加文件到image中 不仅仅局限于当前build上下文 可以来源于远程服务</td></tr><tr><td>ENV</td><td>环境变量</td><td>指定build时候的环境变量 可以在启动的容器的时候 通过-e覆盖 格式ENV name=value</td></tr><tr><td>ARG</td><td>构建参数</td><td>构建参数 只在构建的时候使用的参数 如果有ENV 那么ENV的相同名字的值始终覆盖arg的参数</td></tr><tr><td>VOLUME</td><td>定义外部可以挂载的数据卷</td><td>指定build的image那些目录可以启动的时候挂载到文件系统中 启动容器的时候使用 -v 绑定 格式 VOLUME ["目录"]</td></tr><tr><td>EXPOSE</td><td>暴露端口</td><td>定义容器运行的时候监听的端口 启动容器的使用-p来绑定暴露端口 格式: EXPOSE 8080 或者 EXPOSE 8080/udp</td></tr><tr><td>WORKDIR</td><td>工作目录</td><td>指定容器内部的工作目录 如果没有创建则自动创建 如果指定/ 使用的是绝对地址 如果不是/开头那么是在上一条workdir的路径的相对路径</td></tr><tr><td>USER</td><td>指定执行用户</td><td>指定build或者启动的时候 用户 在RUN CMD ENTRYPONT执行的时候的用户</td></tr><tr><td>HEALTHCHECK</td><td>健康检查</td><td>指定监测当前容器的健康监测的命令 基本上没用 因为很多时候 应用本身有健康监测机制</td></tr><tr><td>ONBUILD</td><td>触发器</td><td>当存在ONBUILD关键字的镜像作为基础镜像的时候 当执行FROM完成之后 会执行 ONBUILD的命令 但是不影响当前镜像 用处也不怎么大</td></tr><tr><td>STOPSIGNAL</td><td>发送信号量到宿主机</td><td>该STOPSIGNAL指令设置将发送到容器的系统调用信号以退出。</td></tr><tr><td>SHELL</td><td>指定执行脚本的shell</td><td>指定RUN CMD ENTRYPOINT 执行命令的时候 使用的shell</td></tr></tbody></table> 
<p> </p> 
<h4><span style="color:#404040;"><strong>Dockerfile</strong></span> <span style="color:#404040;"><strong>案例</strong></span></h4> 
<p><span style="color:#262626;">自定义centos7</span><span style="color:#262626;">镜像。要求：</span></p> 
<p><span style="color:#262626;">1. 默认登录路径为 </span><span style="color:#262626;">/usr</span></p> 
<p><span style="color:#262626;">2. 可以使用</span><span style="color:#262626;">vim</span></p> 
<p>使用txt文件存储命令</p> 
<p>实现步骤 </p> 
<p>①<span style="color:#262626;">定义父镜像：</span><em><span style="color:#ff0000;">FROM</span><span style="color:#262626;"> centos:7</span></em></p> 
<p>②<span style="color:#262626;">定义作者信息：</span><em><span style="color:#ff0000;">MAINTAINER</span>  <span style="color:#262626;">itheima</span><span style="color:#262626;"> &lt;itheima@itcast.cn&gt;</span></em></p> 
<p>③<span style="color:#262626;">执行安装</span><span style="color:#262626;">vim</span><span style="color:#262626;">命令： </span><em><span style="color:#ff0000;">RUN</span><span style="color:#262626;"> yum </span><span style="color:#262626;">install -y </span><span style="color:#262626;">vim</span></em></p> 
<p>④<span style="color:#262626;">定义默认的工作目录：</span><em><span style="color:#ff0000;">WORKDIR</span><span style="color:#262626;"> /usr</span></em></p> 
<p>⑤<span style="color:#262626;">定义容器启动执行的命令：</span><em><span style="color:#ff0000;">CMD</span><span style="color:#262626;"> /</span><span style="color:#262626;">bin/bash</span></em></p> 
<p>⑥<span style="color:#262626;">通过</span><span style="color:#262626;">dockerfile</span><span style="color:#262626;">构建镜像：<em>docker</em></span><em> <span style="color:#262626;">bulid</span><span style="color:#262626;"> –f </span><span style="color:#262626;">dockerfile</span><span style="color:#262626;">文件路径 </span><span style="color:#262626;">–t </span><span style="color:#262626;">镜像名称</span><span style="color:#262626;">:版本</span></em></p> 
<p> </p> 
<p><span style="color:#262626;">定义dockerfile，发布</span><span style="color:#262626;">springboot</span><span style="color:#262626;">项目</span></p> 
<p>①<span style="color:#262626;">定义父镜像：</span><span style="color:#ff0000;">FROM</span> <span style="color:#262626;">java:8</span></p> 
<p>②<span style="color:#262626;">定义作者信息：</span><span style="color:#ff0000;">MAINTAINER</span>  <span style="color:#262626;">itheima</span><span style="color:#262626;"> &lt;itheima@itcast.cn</span><span style="color:#262626;">&gt;</span></p> 
<p>③<span style="color:#262626;">将</span><span style="color:#262626;">jar</span><span style="color:#262626;">包添加到容器： </span><span style="color:#ff0000;">ADD</span><span style="color:#262626;"> springboot.jar app.jar</span></p> 
<p>④<span style="color:#262626;">定义</span><span style="color:#262626;">容器启动执行的命令：</span><span style="color:#ff0000;">CMD</span> <span style="color:#262626;">java –jar app.jar</span></p> 
<p><img alt="" height="100" src="https://images2.imgbox.com/e2/eb/mDcxs0k1_o.png" width="557"></p> 
<p>⑤<span style="color:#262626;">通过</span><span style="color:#262626;">dockerfile</span><span style="color:#262626;">构建镜像：</span><span style="color:#262626;">docker</span> <span style="color:#262626;">bulid</span><span style="color:#262626;"> –f </span><span style="color:#262626;">dockerfile</span><span style="color:#262626;">文件路径 </span><span style="color:#262626;">–t </span><span style="color:#262626;">镜像名称</span><span style="color:#262626;">:</span><span style="color:#262626;">版本  .</span></p> 
<p><img alt="" height="32" src="https://images2.imgbox.com/85/8e/9ETTshgj_o.png" width="575"></p> 
<p><img alt="" height="98" src="https://images2.imgbox.com/e6/e8/6ywGvUdh_o.png" width="982">需要做个端口映射</p> 
<p> <img alt="" height="201" src="https://images2.imgbox.com/cc/cf/pL7o7bPG_o.png" width="766"></p> 
<h2><strong>Docker 服务编排</strong></h2> 
<p><span style="color:#262626;">微服务架构的应用系统中一般包含若干个微服务，每个微服务一般都会部署多个实例，如果每个微服务都要手动启停，维护的工作量会很大</span><span style="color:#262626;">。</span></p> 
<div style="margin-left:.19in;">
  • 
 <span style="color:#262626;">要从</span> 
 <span style="color:#262626;">Dockerfile</span> 
 <span style="color:#262626;"> build image </span> 
 <span style="color:#262626;">或者去</span> 
 <span style="color:#262626;">dockerhub</span> 
 <span style="color:#262626;">拉取</span> 
 <span style="color:#262626;">image</span> 
</div> 
<div style="margin-left:.19in;">
  • 
 <span style="color:#262626;">要创建多个</span> 
 <span style="color:#262626;">container</span> 
</div> 
<div style="margin-left:.19in;">
  • 
 <span style="color:#262626;">要管理这些</span> 
 <span style="color:#262626;">container</span> 
 <span style="color:#262626;">（启动停止删除</span> 
 <span style="color:#262626;">）</span> 
</div> 
<div style="margin-left:.19in;">
    
</div> 
<p><span style="color:#FF0000;"><strong>服务编排：</strong></span><span style="color:#262626;">按照一定的业务规则批量管理容器</span></p> 
<p> </p> 
<p><span style="color:#404040;"><strong>Docker Compose</strong></span></p> 
<p><span style="color:#262626;">Docker Compose</span><span style="color:#262626;">是一个编排多容器分布式部署的工具，提供命令集管理容器化应用的完整开发周期，包括服务构建，启动和停止</span><span style="color:#262626;">。使用步骤：</span></p> 
<div style="margin-left:.25in;">
  1. 
 <span style="color:#262626;">利用 </span> 
 <strong><span style="color:#262626;">Dockerfile</span></strong> 
 <span style="color:#262626;">定义</span> 
 <span style="color:#262626;">运行</span> 
 <span style="color:#262626;">环境镜像</span> 
</div> 
<div style="margin-left:.25in;">
  2. 
 <span style="color:#262626;">使用 </span> 
 <span style="color:#262626;">docker-compose.yml</span> 
 <span style="color:#262626;">定义</span> 
 <span style="color:#262626;">组成应用的各服务</span> 
</div> 
<div style="margin-left:.25in;">
  3. 
 <span style="color:#262626;">运行 </span> 
 <span style="color:#262626;">docker</span> 
 <span style="color:#262626;">-compose up </span> 
 <span style="color:#262626;">启动</span> 
 <span style="color:#262626;">应用</span> 
</div> 
<div style="margin-left:.25in;">
    
</div> 
<p><img alt="" height="179" src="https://images2.imgbox.com/32/ab/1I32gTdY_o.png" width="746"></p> 
<p> </p> 
<p>使用docker compose反向代理nginx+springboot项目</p> 
<ol><li> <p>创建docker-compose目录</p> </li></ol> 
<pre>mkdir ~/docker-compose
cd ~/docker-compose</pre> 
<p>2、编写 docker-compose.yml 文件</p> 
<pre>version: '3'
services:
  nginx:
   image: nginx
   ports:
    - 80:80
   links:
    - app
   volumes:
    - ./nginx/conf.d:/etc/nginx/conf.d
  app:
    image: app
    expose:
      - "8080"</pre> 
<p>3、创建./nginx/conf.d目录</p> 
<pre>mkdir -p ./nginx/conf.d</pre> 
<p> </p> 
<p>4、在./nginx/conf.d目录下 编写itheima.conf文件</p> 
<p>配置80端口，反向代理到app8080端口</p> 
<pre>server {
    listen 80;
    access_log off;
​
    location / {
        proxy_pass http://app:8080;
    }
   
}</pre> 
<p>5、在~/docker-compose 目录下 使用docker-compose 启动容器</p> 
<pre>docker-compose up</pre> 
<p>6、测试访问</p> 
<pre>http://192.168.149.135/hello</pre> 
<h2>Docker 私有仓库</h2> 
<h4>一、私有仓库搭建</h4> 
<pre># 1、拉取私有仓库镜像 
docker pull registry
# 2、启动私有仓库容器 
docker run -id --name=registry -p 5000:5000 registry
# 3、打开浏览器 输入地址http://私有仓库服务器ip:5000/v2/_catalog，看到{"repositories":[]} 表示私有仓库 搭建成功
# 4、修改daemon.json   
vim /etc/docker/daemon.json    
# 在上述文件中添加一个key，保存退出。此步用于让 docker 信任私有仓库地址；注意将私有仓库服务器ip修改为自己私有仓库服务器真实ip 
{"insecure-registries":["私有仓库服务器ip:5000"]} 
# 5、重启docker 服务 
systemctl restart docker
docker start registry
​</pre> 
<h4>二、将镜像上传至私有仓库</h4> 
<pre># 1、标记镜像为私有仓库的镜像     
docker tag centos:7 私有仓库服务器IP:5000/centos:7
 
# 2、上传标记的镜像     
docker push 私有仓库服务器IP:5000/centos:7
​</pre> 
<p> </p> 
<h4>三、 从私有仓库拉取镜像</h4> 
<pre>#拉取镜像 
docker pull 私有仓库服务器ip:5000/centos:7</pre> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3a2ce2ca165f058321386eaa45dc3dba/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Matlab filter2、conv2报错：不支持N维数组</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6169b4a03be747a90476a42aff0893b5/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">解决legacy、uefi系统盘boot页面无法识别问题</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>