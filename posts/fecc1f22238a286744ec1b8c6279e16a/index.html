<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Redis在SpringMVC（或xml配置）项目中使用(注意版本兼容问题) - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Redis在SpringMVC（或xml配置）项目中使用(注意版本兼容问题)" />
<meta property="og:description" content="在没有封装情况下使用 Java API的缺点，需要自己白那些规则把 java 对象 和 Redis 的字符串进行相互转换，而在 Spring 中这些问题都可以轻松处理。
在Spring中使用 Redis ,除了需要 jedis.jar 外，还需要下载 spring-data-redis.jar，打开网址 https://mvnrepository.com/artifact/org.springframework.data/spring-data-redis ， 就能够看到这样的页面：
值得注意的是， jar 包 和 Spring 版本兼容的问题。
注意 spring5以上需要配置 spring-data-redis 2.0 基于spring主版本为4.3.13.RELEASE的项目，测试以下对应版本可用。 spring-data-redis版本
jedis版本
备注
1.5.2.RELEASE
2.7.3
1.6.0.RELEASE
2.7.2 2.7.3
1.6.2.RELEASE
2.8.0
1.8.1.RELEASE
2.9.0
1.8.4.RELEASE
2.9.0
原有的SpringMVC配置不动，添加下面这个配置
redis.xml:
&lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&gt; &lt;beans xmlns=&#34;http://www.springframework.org/schema/beans&#34; xmlns:xsi=&#34;http://www.w3.org/2001/XMLSchema-instance&#34; xmlns:p=&#34;http://www.springframework.org/schema/p&#34; xmlns:context=&#34;http://www.springframework.org/schema/context&#34; xmlns:mvc=&#34;http://www.springframework.org/schema/mvc&#34; xsi:schemaLocation=&#34; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.1.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.1.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.1.xsd&#34;&gt; &lt;!-- redis数据源 --&gt; &lt;bean id=&#34;poolConfig&#34; class=&#34;redis.clients.jedis.JedisPoolConfig&#34;&gt; &lt;!-- 最大连接数 --&gt; &lt;!" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/fecc1f22238a286744ec1b8c6279e16a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-10-01T20:06:54+08:00" />
<meta property="article:modified_time" content="2022-10-01T20:06:54+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Redis在SpringMVC（或xml配置）项目中使用(注意版本兼容问题)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>在没有封装情况下使用 Java API的缺点，需要自己白那些规则把 java 对象 和 Redis 的字符串进行相互转换，而在 Spring 中这些问题都可以轻松处理。</p> 
<p><span style="color:#f33b45;"><strong>在Spring中使用 Redis ,除了需要 jedis.jar 外，还需要下载 spring-data-redis.jar，</strong></span>打开网址 <a href="https://mvnrepository.com/artifact/org.springframework.data/spring-data-redis" rel="nofollow" title="https://mvnrepository.com/artifact/org.springframework.data/spring-data-redis ， ">https://mvnrepository.com/artifact/org.springframework.data/spring-data-redis ， </a></p> 
<p>就能够看到这样的页面：</p> 
<p><span style="color:#f33b45;"><strong>值得注意的是， jar 包 和 Spring 版本兼容的问题。</strong></span></p> 
<p><img alt="" height="719" src="https://images2.imgbox.com/f7/33/3ZVON2w2_o.png" width="913"></p> 
<h4><strong><span style="color:#fe2c24;">注意 spring5以上需要配置 spring-data-redis 2.0</span></strong></h4> 
<h4><span style="color:#fe2c24;"><strong>基于spring主版本为4.3.13.RELEASE的项目，测试以下对应版本可用。</strong></span></h4> 
<table><tbody><tr><td> <p>spring-data-redis版本</p> </td><td> <p>jedis版本</p> </td><td> <p>备注</p> </td></tr><tr><td> <p>1.5.2.RELEASE</p> </td><td> <p>2.7.3</p> </td><td> <p></p> </td></tr><tr><td> <p>1.6.0.RELEASE</p> </td><td> <p>2.7.2  2.7.3</p> </td><td> <p></p> </td></tr><tr><td> <p>1.6.2.RELEASE</p> </td><td> <p>2.8.0</p> </td><td> <p></p> </td></tr><tr><td> <p>1.8.1.RELEASE</p> </td><td> <p>2.9.0</p> </td><td> <p></p> </td></tr><tr><td> <p>1.8.4.RELEASE</p> </td><td> <p>2.9.0</p> </td><td> <p></p> </td></tr></tbody></table> 
<hr> 
<p>原有的SpringMVC配置不动，添加下面这个配置</p> 
<p><img alt="" height="476" src="https://images2.imgbox.com/f4/24/tHAv92vV_o.png" width="495"></p> 
<p>redis.xml:</p> 
<pre><code class="language-html">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p"
    xmlns:context="http://www.springframework.org/schema/context"
    xmlns:mvc="http://www.springframework.org/schema/mvc"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans-3.1.xsd
        http://www.springframework.org/schema/context 
        http://www.springframework.org/schema/context/spring-context-3.1.xsd
        http://www.springframework.org/schema/mvc
        http://www.springframework.org/schema/mvc/spring-mvc-3.1.xsd"&gt;
 
 
	
     &lt;!-- redis数据源 --&gt;
    &lt;bean id="poolConfig" class="redis.clients.jedis.JedisPoolConfig"&gt;
		&lt;!-- 最大连接数 --&gt;
		&lt;!-- &lt;property name="maxTotal" value="30" /&gt;
		最大空闲连接数
		&lt;property name="maxIdle" value="10" /&gt;
		每次释放连接的最大数目
		&lt;property name="numTestsPerEvictionRun" value="1024" /&gt;
		释放连接的扫描间隔（毫秒）
		&lt;property name="timeBetweenEvictionRunsMillis" value="30000" /&gt;
		连接最小空闲时间
		&lt;property name="minEvictableIdleTimeMillis" value="1800000" /&gt;
		连接空闲多久后释放, 当空闲时间&gt;该值 且 空闲连接&gt;最大空闲连接数 时直接释放
		&lt;property name="softMinEvictableIdleTimeMillis" value="10000" /&gt;
		获取连接时的最大等待毫秒数,小于零:阻塞不确定的时间,默认-1
		&lt;property name="maxWaitMillis" value="1500" /&gt;
		在获取连接的时候检查有效性, 默认false
		&lt;property name="testOnBorrow" value="true" /&gt;
		在空闲时检查有效性, 默认false
		&lt;property name="testWhileIdle" value="true" /&gt;
		连接耗尽时是否阻塞, false报异常,ture阻塞直到超时, 默认true
		&lt;property name="blockWhenExhausted" value="false" /&gt; --&gt;
		  &lt;property name="maxIdle" value="100" /&gt;
          &lt;property name="minIdle" value="8" /&gt;
          &lt;property name="maxWaitMillis" value="-1" /&gt;
         &lt;property name="testOnBorrow" value="true" /&gt;
 
    &lt;/bean&gt;
   &lt;!-- Spring-redis连接池管理工厂 --&gt;
    &lt;bean id="connectionFactory"
        class="org.springframework.data.redis.connection.jedis.JedisConnectionFactory"&gt;
        &lt;property name="poolConfig" ref="poolConfig" /&gt;
          &lt;!-- 端口号 --&gt;
        &lt;property name="port" value="6379" /&gt;
         &lt;!-- IP地址 --&gt;
        &lt;property name="hostName" value="427.925.2214.1279" /&gt;
         &lt;!-- 密码 --&gt;
        &lt;property name="password" value="feizhou123" /&gt;
         &lt;!-- 超时时间 --&gt;
        &lt;property name="timeout" value="-1" /&gt;
    &lt;/bean&gt;
    &lt;!-- redis操作模板，面向对象的模板 --&gt;
    &lt;bean id="stringRedisSerializer" class="org.springframework.data.redis.serializer.StringRedisSerializer" /&gt;  
   &lt;bean id="jdkSerializationRedisSerializer" class="org.springframework.data.redis.serializer.JdkSerializationRedisSerializer" /&gt;
    &lt;bean id="stringRedisTemplate" class="org.springframework.data.redis.core.StringRedisTemplate"&gt;
        &lt;property name="connectionFactory" ref="connectionFactory" /&gt;
        &lt;!-- 如果不配置Serializer，那么存储的时候只能使用String，如果用对象类型存储，那么会提示错误 --&gt;
        &lt;property name="keySerializer" ref="stringRedisSerializer"&gt;&lt;/property&gt;
        &lt;property name="valueSerializer" ref="jdkSerializationRedisSerializer"&gt; &lt;/property&gt;
    &lt;/bean&gt;
    
    &lt;bean id="redisTemplate" class="org.springframework.data.redis.core.RedisTemplate"  
    p:connectionFactory-ref="connectionFactory"   
    p:keySerializer-ref="stringRedisSerializer"   
    p:hashKeySerializer-ref="stringRedisSerializer" /&gt;  
&lt;/beans&gt;</code></pre> 
<p> redis.properties:</p> 
<pre><code class="language-bash">redis.host=1936.16334.23.22
redis.port=6379
redis.pass=feizhou123
redis.timeout=-1
redis.maxIdle=100
redis.minIdle=8
redis.maxWait=-1
redis.testOnBorrow=true
</code></pre> 
<p>需要添加的jar包:</p> 
<pre><code class="language-html">&lt;!--配置redis --&gt;
&lt;dependency&gt;
	&lt;groupId&gt;org.springframework.data&lt;/groupId&gt;
	&lt;artifactId&gt;spring-data-redis&lt;/artifactId&gt;
	&lt;version&gt;1.6.0.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
 
&lt;dependency&gt;
	&lt;groupId&gt;redis.clients&lt;/groupId&gt;
		&lt;artifactId&gt;jedis&lt;/artifactId&gt;
	&lt;version&gt;2.7.3&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
        &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;
        &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt;
            &lt;version&gt;2.3&lt;/version&gt;
       &lt;/dependency&gt;
&lt;dependency&gt;
		    &lt;groupId&gt;commons-pool&lt;/groupId&gt;
		    &lt;artifactId&gt;commons-pool&lt;/artifactId&gt;
		    &lt;version&gt;1.5.5&lt;/version&gt;
		&lt;/dependency&gt;</code></pre> 
<p>工具类:</p> 
<pre><code class="language-java">package com.feizhou.commonService.redis;
 
import java.util.Map;
import java.util.Set;
import java.util.concurrent.TimeUnit;
import javax.annotation.Resource;
 
import org.apache.commons.lang3.StringUtils;
import org.springframework.data.redis.core.BoundHashOperations;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.stereotype.Component;
import org.springframework.util.CollectionUtils;
 
import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.JSONObject;
import com.feizhou.common.tools.commonTools.JsonUtil;
 
/**
 * 通用缓存工具类
 * 
 * @author lh
 * @version 3.0
 * @since 2016-6-22
 * 
 */
@Component
public class CacheUtils {
	@Resource
	private   StringRedisTemplate stringRedisTemplate;
	@Resource
	private   RedisTemplate&lt;String, Object&gt; redisTemplate;
 
	/**
	 * 删除缓存&lt;br&gt;
	 * 根据key精确匹配删除
	 * 
	 * @param key
	 */
	@SuppressWarnings("unchecked")
	public   void del(String... key) {
		if (key != null &amp;&amp; key.length &gt; 0) {
			if (key.length == 1) {
				redisTemplate.delete(key[0]);
			} else {
				redisTemplate.delete(CollectionUtils.arrayToList(key));
			}
		}
	}
	/**
	 * 
	 * @Description (根据key精确匹配删除)
	 * @author feizhou
	 * @Date 2018年5月29日下午5:39:06  
	 * @version 1.0.0
	 * @param key
	 */
	public   void deleteByKey(String  key) {
		if (key != null) {
			redisTemplate.delete(key);
		}
	}
 
	/**
	 * 批量删除&lt;br&gt;
	 * （该操作会执行模糊查询，请尽量不要使用，以免影响性能或误删）
	 * 
	 * @param pattern
	 */
	public  void batchDel(String... pattern) {
		for (String kp : pattern) {
			redisTemplate.delete(redisTemplate.keys(kp + "*"));
		}
	}
 
	/**
	 * 取得缓存（int型）
	 * 
	 * @param key
	 * @return
	 */
	public  Integer getInt(String key) {
		String value = stringRedisTemplate.boundValueOps(key).get();
		if (StringUtils.isNotEmpty(value)) {
			return Integer.valueOf(value);
		}
		return null;
	}
 
	/**
	 * 取得缓存（字符串类型）
	 * 
	 * @param key
	 * @return
	 */
	public  String getStr(String key) {
		return stringRedisTemplate.boundValueOps(key).get();
	}
 
	/**
	 * 取得缓存（字符串类型）
	 * 
	 * @param key
	 * @return
	 */
	public  String getStr(String key, boolean retain) {
		String value = stringRedisTemplate.boundValueOps(key).get();
		if (!retain) {
			redisTemplate.delete(key);
		}
		return value;
	}
 
	/**
	 * 获取缓存&lt;br&gt;
	 * 注：基本数据类型(Character除外)，请直接使用get(String key, Class&lt;T&gt; clazz)取值
	 * 
	 * @param key
	 * @return
	 */
	public  Object getObj(String key) {
		return redisTemplate.boundValueOps(key).get();
	}
 
	/**
	 * 获取缓存&lt;br&gt;
	 * 注：java 8种基本类型的数据请直接使用get(String key, Class&lt;T&gt; clazz)取值
	 * 
	 * @param key
	 * @param retain
	 *            是否保留
	 * @return
	 */
	public  Object getObj(String key, boolean retain) {
		Object obj = redisTemplate.boundValueOps(key).get();
		if (!retain) {
			redisTemplate.delete(key);
		}
		return obj;
	}
 
	/**
	 * 获取缓存&lt;br&gt;
	 * 注：该方法暂不支持Character数据类型
	 * 
	 * @param key
	 *            key
	 * @param clazz
	 *            类型
	 * @return
	 */
	@SuppressWarnings("unchecked")
	public  &lt;T&gt; T get(String key, Class&lt;T&gt; clazz) {
		return (T) redisTemplate.boundValueOps(key).get();
	}
 
	/**
	 * 获取缓存json对象&lt;br&gt;
	 * 
	 * @param key
	 *            key
	 * @param clazz
	 *            类型
	 * @return
	 * @throws Exception 
	 */
	@SuppressWarnings("unchecked")
	public  &lt;T&gt; T getJson(String key, Class&lt;T&gt; clazz) throws Exception {
		String jsonStr=null;
		jsonStr=stringRedisTemplate.boundValueOps(key).get();
		if(jsonStr==null){
			return null;
		}else{
			return (T) JsonUtil.jsonToBean(jsonStr, clazz);
		}
	}
 
	/**
	 * 将value对象写入缓存
	 * 
	 * @param key
	 * @param value
	 * @param time
	 *            失效时间(秒)
	 */
	public  void set(String key, Object value, Long time) {
		if (value.getClass().equals(String.class)) {
			stringRedisTemplate.opsForValue().set(key, value.toString());
		} else if (value.getClass().equals(Integer.class)) {
			stringRedisTemplate.opsForValue().set(key, value.toString());
		} else if (value.getClass().equals(Double.class)) {
			stringRedisTemplate.opsForValue().set(key, value.toString());
		} else if (value.getClass().equals(Float.class)) {
			stringRedisTemplate.opsForValue().set(key, value.toString());
		} else if (value.getClass().equals(Short.class)) {
			stringRedisTemplate.opsForValue().set(key, value.toString());
		} else if (value.getClass().equals(Long.class)) {
			stringRedisTemplate.opsForValue().set(key, value.toString());
		} else if (value.getClass().equals(Boolean.class)) {
			stringRedisTemplate.opsForValue().set(key, value.toString());
		} else {
			redisTemplate.opsForValue().set(key, value);
		}
		if (time != null &amp;&amp; time &gt; 0) {
            redisTemplate.expire(key, time, TimeUnit.SECONDS);
            stringRedisTemplate.expire(key, time, TimeUnit.SECONDS);
        }
	}
 
	/**
	 * 将value对象以JSON格式写入缓存
	 * 
	 * @param key
	 * @param value
	 * @param time
	 *            失效时间(秒)
	 */
	public  void setJson(String key, Object value, Long time) {
		stringRedisTemplate.opsForValue().set(key, JsonUtil.toJsonString(value));
		if (time!=null&amp;&amp;time &gt; 0) {
			stringRedisTemplate.expire(key, time, TimeUnit.SECONDS);
		}
	}
 
	/**
	 * 更新key对象field的值
	 * 
	 * @param key
	 *            缓存key
	 * @param field
	 *            缓存对象field
	 * @param value
	 *            缓存对象field值
	 */
	public  void setJsonField(String key, String field, String value) {
		JSONObject obj = JSON.parseObject(stringRedisTemplate.boundValueOps(key).get());
		obj.put(field, value);
		stringRedisTemplate.opsForValue().set(key, obj.toJSONString());
	}
 
	/**
	 * 递减操作
	 * 
	 * @param key
	 * @param by
	 * @return
	 */
	public  double decr(String key, double by) {
		return redisTemplate.opsForValue().increment(key, -by);
	}
 
	/**
	 * 递增操作
	 * 
	 * @param key
	 * @param by
	 * @return
	 */
	public  double incr(String key, double by) {
		return redisTemplate.opsForValue().increment(key, by);
	}
 
	/**
	 * 获取double类型值
	 * 
	 * @param key
	 * @return
	 */
	public  double getDouble(String key) {
		String value = stringRedisTemplate.boundValueOps(key).get();
		if (StringUtils.isNotBlank(value)) {
			return Double.valueOf(value);
		}
		return 0d;
	}
 
	/**
	 * 设置double类型值
	 * 
	 * @param key
	 * @param value
	 * @param time
	 *            失效时间(秒)
	 */
	public  void setDouble(String key, double value, Long time) {
		stringRedisTemplate.opsForValue().set(key, String.valueOf(value));
		if (time!=null&amp;&amp;time &gt; 0) {
			stringRedisTemplate.expire(key, time, TimeUnit.SECONDS);
		}
	}
 
	/**
	 * 设置double类型值
	 * 
	 * @param key
	 * @param value
	 * @param time
	 *            失效时间(秒)
	 */
	public  void setInt(String key, int value, Long time) {
		stringRedisTemplate.opsForValue().set(key, String.valueOf(value));
		if (time!=null&amp;&amp;time &gt; 0) {
			stringRedisTemplate.expire(key, time, TimeUnit.SECONDS);
		}
	}
 
	/**
	 * 将map写入缓存
	 * 
	 * @param key
	 * @param map
	 * @param time
	 *            失效时间(秒)
	 */
	public  &lt;T&gt; void setMap(String key, Map&lt;String, T&gt; map, Long time) {
		redisTemplate.opsForHash().putAll(key, map);
	}
 
	/**
	 * 将map写入缓存
	 * 
	 * @param key
	 * @param map
	 * @param time
	 *            失效时间(秒)
	 */
	@SuppressWarnings("unchecked")
	public  &lt;T&gt; void setMap(String key, T obj, Long time) {
		Map&lt;String, String&gt; map = (Map&lt;String, String&gt;)JsonUtil.parseObject(obj, Map.class);
		redisTemplate.opsForHash().putAll(key, map);
	}
 
	/**
	 * 向key对应的map中添加缓存对象
	 * 
	 * @param key
	 * @param map
	 */
	public  &lt;T&gt; void addMap(String key, Map&lt;String, T&gt; map) {
		redisTemplate.opsForHash().putAll(key, map);
	}
 
	/**
	 * 向key对应的map中添加缓存对象
	 * 
	 * @param key
	 *            cache对象key
	 * @param field
	 *            map对应的key
	 * @param value
	 *            值
	 */
	public  void addMap(String key, String field, String value) {
		redisTemplate.opsForHash().put(key, field, value);
	}
 
	/**
	 * 向key对应的map中添加缓存对象
	 * 
	 * @param key
	 *            cache对象key
	 * @param field
	 *            map对应的key
	 * @param obj
	 *            对象
	 */
	public  &lt;T&gt; void addMap(String key, String field, T obj) {
		redisTemplate.opsForHash().put(key, field, obj);
	}
 
	/**
	 * 获取map缓存
	 * 
	 * @param key
	 * @param clazz
	 * @return
	 */
	public  &lt;T&gt; Map&lt;String, T&gt; mget(String key, Class&lt;T&gt; clazz) {
		BoundHashOperations&lt;String, String, T&gt; boundHashOperations = redisTemplate.boundHashOps(key);
		return boundHashOperations.entries();
	}
 
	/**
	 * 获取map缓存中的某个对象
	 * 
	 * @param key
	 * @param field
	 * @param clazz
	 * @return
	 */
	@SuppressWarnings("unchecked")
	public  &lt;T&gt; T getMapField(String key, String field, Class&lt;T&gt; clazz) {
		return (T) redisTemplate.boundHashOps(key).get(field);
	}
 
		/**
		 * 获取map缓存
		 * 
		 * @param key
		 * @param clazz
		 * @return
		 */
		public  &lt;T&gt; T getMap(String key, Class&lt;T&gt; clazz) {
			BoundHashOperations&lt;String, String, String&gt; boundHashOperations = redisTemplate.boundHashOps(key);
			Map&lt;String, String&gt; map = boundHashOperations.entries();
			return JsonUtil.parseObject(map, clazz);
		}
	
		/**
	 * 删除map中的某个对象
	 * 
	 * @author lh
	 * @date 2016年8月10日
	 * @param key
	 *            map对应的key
	 * @param field
	 *            map中该对象的key
	 */
	public void delMapField(String key, String... field) {
		BoundHashOperations&lt;String, String, ?&gt; boundHashOperations = redisTemplate.boundHashOps(key);
		boundHashOperations.delete(field);
	}
 
	/**
	 * 指定缓存的失效时间
	 * 
	 * @author FangJun
	 * @date 2016年8月14日
	 * @param key
	 *            缓存KEY
	 * @param time
	 *            失效时间(秒)
	 */
	public  void expire(String key, Long time) {
		if (time!=null&amp;&amp;time &gt; 0) {
			redisTemplate.expire(key, time, TimeUnit.SECONDS);
		}
	}
 
	/**
	 * 添加set
	 * 
	 * @param key
	 * @param value
	 */
	public  void sadd(String key, String... value) {
		redisTemplate.boundSetOps(key).add(value);
	}
 
	/**
	 * 删除set集合中的对象
	 * 
	 * @param key
	 * @param value
	 */
	public  void srem(String key, String... value) {
		redisTemplate.boundSetOps(key).remove(value);
	}
 
	/**
	 * set重命名
	 * 
	 * @param oldkey
	 * @param newkey
	 */
	public  void srename(String oldkey, String newkey) {
		redisTemplate.boundSetOps(oldkey).rename(newkey);
	}
 
	/**
	 * 短信缓存
	 * 
	 * @author fxl
	 * @date 2016年9月11日
	 * @param key
	 * @param value
	 * @param time
	 */
	public  void setIntForPhone(String key, Object value, int time) {
		stringRedisTemplate.opsForValue().set(key, JsonUtil.toJsonString(value));
		if (time &gt; 0) {
			stringRedisTemplate.expire(key, time, TimeUnit.SECONDS);
		}
	}
 
	/**
	 * 模糊查询keys
	 * 
	 * @param pattern
	 * @return
	 */
	public  Set&lt;String&gt; keys(String pattern) {
		return redisTemplate.keys(pattern);
	}
	
	/**
	 * 
	 * @Description (检查key是否存在，返回boolean值 )
	 * @author feizhou
	 * @Date 2018年5月29日下午5:37:40  
	 * @version 1.0.0
	 * @param key
	 * @return
	 */
	public  Boolean   ishasKey(String key) {
		return stringRedisTemplate.hasKey(key);
	}
 
 
 
}</code></pre> 
<p></p> 
<p>————————————————<br> 版权声明：本文为CSDN博主「单身贵族男」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br> 原文链接：https://blog.csdn.net/zhou920786312/article/details/82496406</p> 
<p></p> 
<h4><span style="color:#fe2c24;"><strong> 注意 spring5以上需要配置 spring-data-redis 2.0</strong></span></h4> 
<p>项目中配置：</p> 
<p>jar包：</p> 
<pre><code class="language-html">  &lt;!-- spring redis配置： 注意 spring5以上需要配置 spring-data-redis 2.0 --&gt;
    &lt;!-- https://docs.spring.io/spring-data/redis/docs/2.2.12.RELEASE/reference/html/#new-features  --&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.springframework.data&lt;/groupId&gt;
      &lt;artifactId&gt;spring-data-redis&lt;/artifactId&gt;
      &lt;version&gt;2.0.0.RELEASE&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;redis.clients&lt;/groupId&gt;
      &lt;artifactId&gt;jedis&lt;/artifactId&gt;
      &lt;version&gt;2.9.0&lt;/version&gt;
    &lt;/dependency&gt;</code></pre> 
<pre><code class="language-html">applicationContext.xml：
</code></pre> 
<pre><code class="language-html">&lt;?xml version="1.0" encoding="UTF-8"?&gt;    
&lt;beans xmlns="http://www.springframework.org/schema/beans"    
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"   
    xmlns:p="http://www.springframework.org/schema/p"  
    xmlns:aop="http://www.springframework.org/schema/aop"   
    xmlns:context="http://www.springframework.org/schema/context"  
    xmlns:cache="http://www.springframework.org/schema/cache"
    xmlns:jee="http://www.springframework.org/schema/jee"  
    xmlns:tx="http://www.springframework.org/schema/tx"  
    xsi:schemaLocation="    
        http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd  
        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd  
        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd
        http://www.springframework.org/schema/cache http://www.springframework.org/schema/cache/spring-cache-4.0.xsd
        http://www.springframework.org/schema/jee http://www.springframework.org/schema/jee/spring-jee-4.0.xsd  
        http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd"&gt;    
        
    &lt;!--  配置数据源 SQLServer  --&gt;
   
    &lt;!--
    &lt;context:property-placeholder location="classpath:jdbc.properties" ignore-resource-not-found="true" &gt;&lt;/context:property-placeholder&gt;
    --&gt;

    &lt;!--
	  导入配置文件 config.properties 、redis.properties
	  注意：如果项目中有多个属性文件，要合并在一起加载同一管理。如果分散在不同的配置文件中，只能按文件顺序加载第一个配置文件中的属性文件。
	  &lt;context:property-placeholder location="classpath*:config.properties"&gt;&lt;/context:property-placeholder&gt;
	--&gt;
    &lt;context:property-placeholder location="classpath*:*.properties"&gt;&lt;/context:property-placeholder&gt;

    
    &lt;!-- 配置数据库 gzxf --&gt;
    &lt;bean id="dataSource"
		class="com.alibaba.druid.pool.DruidDataSource" init-method="init" destroy-method="close"&gt;
        &lt;property name="driverClassName" value="${jdbc.driver}" /&gt;
		&lt;property name="url" value="${jdbc.url}"/&gt;
		&lt;property name="username" value="${jdbc.username}"/&gt;
		&lt;property name="password" value="${jdbc.password}"/&gt;
        &lt;!-- 配置初始化大小、bai最小、最大 --&gt;
        &lt;property name="initialSize" value="1" /&gt;
        &lt;property name="minIdle" value="1" /&gt;
        &lt;property name="maxActive" value="20" /&gt;
        &lt;!-- 配置获取连接等待超时的时间 --&gt;
        &lt;property name="maxWait" value="60000" /&gt;
        &lt;!-- 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒 --&gt;
        &lt;property name="timeBetweenEvictionRunsMillis" value="60000" /&gt;
        &lt;!-- 配置一个连接在池中最小生存的时间，单位是毫秒 --&gt;
        &lt;property name="minEvictableIdleTimeMillis" value="300000" /&gt;
        &lt;property name="validationQuery" value="SELECT 'x'" /&gt;
        &lt;property name="testWhileIdle" value="true" /&gt;
        &lt;property name="testOnBorrow" value="false" /&gt;
        &lt;property name="testOnReturn" value="false" /&gt;
        &lt;!-- 打开PSCache，并且指定每个连接上PSCache的大小 --&gt;
        &lt;property name="poolPreparedStatements" value="true" /&gt;
        &lt;property name="maxPoolPreparedStatementPerConnectionSize" value="20" /&gt;
        &lt;!-- 配置监控统计拦截的filters，去掉后监控界面sql无法统计 --&gt;
        &lt;property name="filters" value="stat" /&gt;
	&lt;/bean&gt;
    &lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt;
		&lt;property name="dataSource" ref="dataSource" /&gt;
		&lt;property name="mapperLocations" value="classpath:/mapper/*.xml"&gt;&lt;/property&gt;
		&lt;property name="configLocation" value="classpath:mybatis-config.xml"&gt;&lt;/property&gt;
        &lt;!-- 配置分页插件 --&gt;
        &lt;property name="plugins"&gt;
            &lt;array&gt;
                &lt;bean class="com.github.pagehelper.PageInterceptor"&gt;
                    &lt;property name="properties"&gt;
                        &lt;value&gt;
                            helperDialect=sqlserver2012
                            reasonable=true
                        &lt;/value&gt;
                    &lt;/property&gt;
                &lt;/bean&gt;
            &lt;/array&gt;
        &lt;/property&gt;
	&lt;/bean&gt;
    &lt;!-- DAO接口所在包名，Spring会自动查找其下的类 --&gt;
	&lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt;
		&lt;property name="basePackage" value="com.dao"&gt;&lt;/property&gt;
		&lt;property name="sqlSessionFactoryBeanName" value="sqlSessionFactory"&gt;&lt;/property&gt;
	&lt;/bean&gt;

    &lt;!-- 开启注解: 自动扫描 --&gt;
    &lt;context:annotation-config&gt;&lt;/context:annotation-config&gt;

    &lt;!-- 配置事务（注解方式） --&gt;
    &lt;!-- 使用Annotation自动注册Bean，解决事物失效问题：在主容器中不扫描@Controller注解，在SpringMvc中只扫描@Controller注解。  --&gt;
    &lt;context:component-scan base-package="com.service"&gt;&lt;!-- base-package 如果多个，用“,”分隔 --&gt;
        &lt;context:exclude-filter type="annotation" expression="org.springframework.stereotype.Controller"/&gt;
    &lt;/context:component-scan&gt;

    &lt;!-- 定义事务 --&gt;
    &lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt;
        &lt;property name="dataSource" ref="dataSource" /&gt;
    &lt;/bean&gt;

    &lt;!-- 配置 Annotation 驱动，扫描@Transactional注解的类定义事务  --&gt;
    &lt;tx:annotation-driven transaction-manager="transactionManager" proxy-target-class="true"/&gt;
    &lt;!-- MyBatis end --&gt;

    &lt;!-- 添加redis工具类 --&gt;
    &lt;import resource="classpath:applicationContext-redis.xml" /&gt;

    &lt;!-- 添加spring工具类 --&gt;
    &lt;bean id="springUtil" class="com.fire.oms.api.utils.SpringUtil" lazy-init="false" /&gt;
	
&lt;/beans&gt;</code></pre> 
<p>applicationContext-redis.xml：</p> 
<pre><code class="language-html">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p"
	xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx"
	xmlns:context="http://www.springframework.org/schema/context" 
	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd
	http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.2.xsd
	http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.2.xsd
	http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.2.xsd"&gt;

	&lt;description&gt;Redis configuration&lt;/description&gt;

	&lt;!-- 载入redis配置参数 --&gt;
	&lt;!-- &lt;context:property-placeholder location="classpath:redis.properties" ignore-unresolvable="true" /&gt; --&gt;

	&lt;!-- redis config start --&gt;
	&lt;bean id="jedisPoolConfig" class="redis.clients.jedis.JedisPoolConfig"&gt;
		&lt;property name="maxIdle" value="${redis.pool.maxIdle}"&gt;&lt;/property&gt;
		&lt;property name="maxTotal" value="${redis.pool.maxActive}" /&gt;
		&lt;property name="maxWaitMillis" value="${redis.pool.maxWaitMillis}" /&gt;
		&lt;property name="testOnBorrow" value="${redis.pool.testOnBorrow}" /&gt;
		&lt;!--
        &lt;property name="minEvictableIdleTimeMillis" value="${redis.minEvictableIdleTimeMillis}"&gt;&lt;/property&gt;
        &lt;property name="numTestsPerEvictionRun" value="${redis.numTestsPerEvictionRun}"&gt;&lt;/property&gt;
        &lt;property name="timeBetweenEvictionRunsMillis" value="${redis.timeBetweenEvictionRunsMillis}"&gt;&lt;/property&gt;
        --&gt;
	&lt;/bean&gt;

	&lt;bean id="jedisConnectionFactory" class="org.springframework.data.redis.connection.jedis.JedisConnectionFactory" destroy-method="destroy"&gt;
		&lt;property name="poolConfig" ref="jedisPoolConfig"&gt;&lt;/property&gt;
		&lt;property name="hostName" value="${redis.host}"&gt;&lt;/property&gt;
		&lt;property name="port" value="${redis.port}"&gt;&lt;/property&gt;
		&lt;!-- 通过密码连接服务器（保证安全） --&gt;
		&lt;property name="password" value="${redis.password}"&gt;&lt;/property&gt;
		&lt;property name="timeout" value="${redis.timeout}"&gt;&lt;/property&gt;
		&lt;!--是否使用連接池 &lt;property name="usePool" value="${redis.usePool}"&gt;&lt;/property&gt; --&gt;
	&lt;/bean&gt;

	&lt;!-- redis操作模板，面向对象的模板 --&gt;
	&lt;bean id="stringRedisSerializer" class="org.springframework.data.redis.serializer.StringRedisSerializer" /&gt;
	&lt;bean id="jdkSerializationRedisSerializer" class="org.springframework.data.redis.serializer.JdkSerializationRedisSerializer" /&gt;
	&lt;bean id="stringRedisTemplate" class="org.springframework.data.redis.core.StringRedisTemplate"&gt;
		&lt;property name="connectionFactory" ref="jedisConnectionFactory" /&gt;
		&lt;!-- 如果不配置Serializer，那么存储的时候只能使用String，如果用对象类型存储，那么会提示错误 --&gt;
		&lt;!-- 注意：原来valueSerializer配置为jdkSerializationRedisSerializer ， 实际测试取值时会出现类似内容： \xac\xed\x00\x05t\x00\tb ，需要改成stringRedisSerializer    --&gt;
		&lt;property name="keySerializer" ref="stringRedisSerializer" /&gt;
		&lt;property name="valueSerializer" ref="stringRedisSerializer" /&gt;
	&lt;/bean&gt;

	&lt;bean id="redisTemplate" class="org.springframework.data.redis.core.RedisTemplate"&gt;
		&lt;property name="connectionFactory" ref="jedisConnectionFactory" /&gt;
		&lt;property name="keySerializer"&gt;
			&lt;bean class="org.springframework.data.redis.serializer.StringRedisSerializer" /&gt;
		&lt;/property&gt;
		&lt;property name="valueSerializer"&gt;
			&lt;bean class="org.springframework.data.redis.serializer.StringRedisSerializer" /&gt;
		&lt;/property&gt;
	&lt;/bean&gt;
	&lt;!-- redis config end --&gt;

	&lt;!-- Redis 发布订阅监配置 --&gt;
	&lt;!-- 1、配置监听类 --&gt;
	&lt;bean id="redisMessageListener" class="com.fire.oms.api.listener.RedisMessageListener"&gt;&lt;/bean&gt;
	&lt;!-- 2、配置监听容器 --&gt;
	&lt;bean id="topicContainer" class="org.springframework.data.redis.listener.RedisMessageListenerContainer" destroy-method="destroy"&gt;

		&lt;!-- redis连接工厂 --&gt;
		&lt;property name="connectionFactory" ref="jedisConnectionFactory"&gt;&lt;/property&gt;
		&lt;!-- 连接池，这里要线程池生存，才能继续监听 --&gt;
		&lt;property name="taskExecutor"&gt;
			&lt;bean class="org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler"&gt;
				&lt;property name="poolSize" value="3"&gt;&lt;/property&gt;
			&lt;/bean&gt;
		&lt;/property&gt;

		&lt;!-- 监听消息map --&gt;
		&lt;property name="messageListeners"&gt;
			&lt;map&gt;
				&lt;!-- 配置监听者，key-ref 和 bean id 定义一直 --&gt;
				&lt;entry key-ref="redisMessageListener"&gt;
					&lt;!-- 监听类 --&gt;
					&lt;bean class="org.springframework.data.redis.listener.ChannelTopic" &gt;
						&lt;constructor-arg value="message"&gt;&lt;/constructor-arg&gt;
					&lt;/bean&gt;
				&lt;/entry&gt;
			&lt;/map&gt;
		&lt;/property&gt;
	&lt;/bean&gt;


&lt;/beans&gt;
</code></pre> 
<p>redis.properties：</p> 
<pre><code class="language-bash">#redis pool config
redis.pool.maxActive=1000
redis.pool.maxIdle=100
redis.pool.maxWaitMillis=10000
redis.pool.testOnBorrow=true

#redis config
redis.host=127.0.0.1
redis.port=6379
redis.timeout=6000
redis.password=123456
redis.dbindex=8
redis.usePool=1
redis.default.expire=1800000</code></pre> 
<pre><code class="language-html">Redis 缓存工具类：CacheUtils</code></pre> 
<pre><code class="language-java">package com.utils;

import org.apache.commons.lang.StringUtils;
import org.springframework.data.redis.core.BoundHashOperations;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.util.CollectionUtils;

import java.util.Map;
import java.util.Set;
import java.util.concurrent.TimeUnit;

/**
 * Redis 缓存工具类
 */
public class CacheUtils {

    /** redis操作模板，面向对象的模板 */
    private static StringRedisTemplate stringRedisTemplate
            = (StringRedisTemplate) SpringUtil.getBean("stringRedisTemplate");
    private static RedisTemplate&lt;String, Object&gt; redisTemplate
            = (RedisTemplate) SpringUtil.getBean("redisTemplate");

    /**
     * 删除缓存&lt;br&gt;
     * 根据key精确匹配删除
     *
     * @param key
     */
    @SuppressWarnings("unchecked")
    public static void del(String... key) {
        if (key != null &amp;&amp; key.length &gt; 0) {
            if (key.length == 1) {
                redisTemplate.delete(key[0]);
            } else {
                redisTemplate.delete(CollectionUtils.arrayToList(key));
            }
        }
    }

    /**
     * (根据key精确匹配删除)
     * @param key
     */
    public static void deleteByKey(String  key) {
        if (key != null) {
            redisTemplate.delete(key);
        }
    }

    /**
     * 批量删除&lt;br&gt;
     * （该操作会执行模糊查询，请尽量不要使用，以免影响性能或误删）
     *
     * @param pattern
     */
    public void batchDel(String... pattern) {
        for (String kp : pattern) {
            redisTemplate.delete(redisTemplate.keys(kp + "*"));
        }
    }

    /**
     * 取得缓存（int型）
     *
     * @param key
     * @return
     */
    public  Integer getInt(String key) {
        String value = stringRedisTemplate.boundValueOps(key).get();
        if (StringUtils.isNotEmpty(value)) {
            return Integer.valueOf(value);
        }
        return null;
    }

    /**
     * 取得缓存（字符串类型）
     *
     * @param key
     * @return
     */
    public static String getStr(String key) {
        return stringRedisTemplate.boundValueOps(key).get();
    }

    /**
     * 取得缓存（字符串类型）
     *
     * @param key
     * @return
     */
    public static String getStr(String key, boolean retain) {
        String value = stringRedisTemplate.boundValueOps(key).get();
        if (!retain) {
            redisTemplate.delete(key);
        }
        return value;
    }

    /**
     * 获取缓存&lt;br&gt;
     * 注：基本数据类型(Character除外)，请直接使用get(String key, Class&lt;T&gt; clazz)取值
     *
     * @param key
     * @return
     */
    public static Object getObj(String key) {
        return redisTemplate.boundValueOps(key).get();
    }

    /**
     * 获取缓存&lt;br&gt;
     * 注：java 8种基本类型的数据请直接使用get(String key, Class&lt;T&gt; clazz)取值
     *
     * @param key
     * @param retain
     *            是否保留
     * @return
     */
    public  Object getObj(String key, boolean retain) {
        Object obj = redisTemplate.boundValueOps(key).get();
        if (!retain) {
            redisTemplate.delete(key);
        }
        return obj;
    }

    /**
     * 获取缓存&lt;br&gt;
     * 注：该方法暂不支持Character数据类型
     *
     * @param key
     *            key
     * @param clazz
     *            类型
     * @return
     */
    @SuppressWarnings("unchecked")
    public  &lt;T&gt; T get(String key, Class&lt;T&gt; clazz) {

        return (T) redisTemplate.boundValueOps(key).get();
    }

    /**
     * 获取缓存json对象&lt;br&gt;
     *
     * @param key
     *            key
     * @param clazz
     *            类型
     * @return
     * @throws Exception

    @SuppressWarnings("unchecked")
    public  &lt;T&gt; T getJson(String key, Class&lt;T&gt; clazz) throws Exception {
        String jsonStr=null;
        jsonStr=stringRedisTemplate.boundValueOps(key).get();
        if(jsonStr==null){
            return null;
        }else{
            return (T) JsonUtil.jsonToBean(jsonStr, clazz);
        }
    } */

    /**
     * 将value对象写入缓存
     *
     * @param key
     * @param value
     * @param time
     *            失效时间(秒)
     */
    public static void set(String key, Object value, Long time) {
        if (value.getClass().equals(String.class)) {
            stringRedisTemplate.opsForValue().set(key, value.toString());
        } else if (value.getClass().equals(Integer.class)) {
            stringRedisTemplate.opsForValue().set(key, value.toString());
        } else if (value.getClass().equals(Double.class)) {
            stringRedisTemplate.opsForValue().set(key, value.toString());
        } else if (value.getClass().equals(Float.class)) {
            stringRedisTemplate.opsForValue().set(key, value.toString());
        } else if (value.getClass().equals(Short.class)) {
            stringRedisTemplate.opsForValue().set(key, value.toString());
        } else if (value.getClass().equals(Long.class)) {
            stringRedisTemplate.opsForValue().set(key, value.toString());
        } else if (value.getClass().equals(Boolean.class)) {
            stringRedisTemplate.opsForValue().set(key, value.toString());
        } else {
            redisTemplate.opsForValue().set(key, value);
        }
        if (time != null &amp;&amp; time &gt; 0) {
            redisTemplate.expire(key, time, TimeUnit.SECONDS);
        }
    }

    /**
     * 将value对象以JSON格式写入缓存
     *
     * @param key
     * @param value
     * @param time
     *            失效时间(秒)

    public  void setJson(String key, Object value, Long time) {
        stringRedisTemplate.opsForValue().set(key, JsonUtil.toJsonString(value));
        if (time!=null&amp;&amp;time &gt; 0) {
            stringRedisTemplate.expire(key, time, TimeUnit.SECONDS);
        }
    }
     */

    /**
     * 更新key对象field的值
     *
     * @param key
     *            缓存key
     * @param field
     *            缓存对象field
     * @param value
     *            缓存对象field值

    public  void setJsonField(String key, String field, String value) {
        JSONObject obj = JSON.parseObject(stringRedisTemplate.boundValueOps(key).get());
        obj.put(field, value);
        stringRedisTemplate.opsForValue().set(key, obj.toJSONString());
    }
     */

    /**
     * 递减操作
     *
     * @param key
     * @param by
     * @return
     */
    public  double decr(String key, double by) {
        return redisTemplate.opsForValue().increment(key, -by);
    }

    /**
     * 递增操作
     *
     * @param key
     * @param by
     * @return
     */
    public  double incr(String key, double by) {
        return redisTemplate.opsForValue().increment(key, by);
    }

    /**
     * 获取double类型值
     *
     * @param key
     * @return
     */
    public  double getDouble(String key) {
        String value = stringRedisTemplate.boundValueOps(key).get();
        if (StringUtils.isNotBlank(value)) {
            return Double.valueOf(value);
        }
        return 0d;
    }

    /**
     * 设置double类型值
     *
     * @param key
     * @param value
     * @param time
     *            失效时间(秒)
     */
    public  void setDouble(String key, double value, Long time) {
        stringRedisTemplate.opsForValue().set(key, String.valueOf(value));
        if (time!=null&amp;&amp;time &gt; 0) {
            stringRedisTemplate.expire(key, time, TimeUnit.SECONDS);
        }
    }

    /**
     * 设置double类型值
     *
     * @param key
     * @param value
     * @param time
     *            失效时间(秒)
     */
    public  void setInt(String key, int value, Long time) {
        stringRedisTemplate.opsForValue().set(key, String.valueOf(value));
        if (time!=null&amp;&amp;time &gt; 0) {
            stringRedisTemplate.expire(key, time, TimeUnit.SECONDS);
        }
    }

    /**
     * 将map写入缓存
     *
     * @param key
     * @param map
     * @param time
     *            失效时间(秒)
     */
    public  &lt;T&gt; void setMap(String key, Map&lt;String, T&gt; map, Long time) {
        redisTemplate.opsForHash().putAll(key, map);
    }

    /**
     * 将map写入缓存
     *
     * @param key
     * @param map
     * @param time
     *            失效时间(秒)

    @SuppressWarnings("unchecked")
    public  &lt;T&gt; void setMap(String key, T obj, Long time) {
        Map&lt;String, String&gt; map = (Map&lt;String, String&gt;)JsonUtil.parseObject(obj, Map.class);
        redisTemplate.opsForHash().putAll(key, map);
    }
     */

    /**
     * 向key对应的map中添加缓存对象
     *
     * @param key
     * @param map
     */
    public  &lt;T&gt; void addMap(String key, Map&lt;String, T&gt; map) {
        redisTemplate.opsForHash().putAll(key, map);
    }

    /**
     * 向key对应的map中添加缓存对象
     *
     * @param key
     *            cache对象key
     * @param field
     *            map对应的key
     * @param value
     *            值
     */
    public  void addMap(String key, String field, String value) {
        redisTemplate.opsForHash().put(key, field, value);
    }

    /**
     * 向key对应的map中添加缓存对象
     *
     * @param key
     *            cache对象key
     * @param field
     *            map对应的key
     * @param obj
     *            对象
     */
    public  &lt;T&gt; void addMap(String key, String field, T obj) {
        redisTemplate.opsForHash().put(key, field, obj);
    }

    /**
     * 获取map缓存
     *
     * @param key
     * @param clazz
     * @return

    public  &lt;T&gt; Map&lt;String, T&gt; mget(String key, Class&lt;T&gt; clazz) {
        BoundHashOperations&lt;String, String, T&gt; boundHashOperations = redisTemplate.boundHashOps(key);
        return boundHashOperations.entries();
    }*/

    /**
     * 获取map缓存中的某个对象
     *
     * @param key
     * @param field
     * @param clazz
     * @return
     */
    @SuppressWarnings("unchecked")
    public  &lt;T&gt; T getMapField(String key, String field, Class&lt;T&gt; clazz) {
        return (T) redisTemplate.boundHashOps(key).get(field);
    }

    /**
     * 获取map缓存
     *
     * @param key
     * @param clazz
     * @return

    public  &lt;T&gt; T getMap(String key, Class&lt;T&gt; clazz) {
        BoundHashOperations&lt;String, String, String&gt; boundHashOperations = redisTemplate.boundHashOps(key);
        Map&lt;String, String&gt; map = boundHashOperations.entries();
        return JsonUtil.parseObject(map, clazz);
    } */

    /**
     * 删除map中的某个对象
     *
     * @author lh
     * @date 2016年8月10日
     * @param key
     *            map对应的key
     * @param field
     *            map中该对象的key
     */
    public void delMapField(String key, String... field) {
        BoundHashOperations&lt;String, String, ?&gt; boundHashOperations = redisTemplate.boundHashOps(key);
        boundHashOperations.delete(field);
    }

    /**
     * 指定缓存的失效时间
     *
     * @author FangJun
     * @date 2016年8月14日
     * @param key
     *            缓存KEY
     * @param time
     *            失效时间(秒)
     */
    public  void expire(String key, Long time) {
        if (time!=null&amp;&amp;time &gt; 0) {
            redisTemplate.expire(key, time, TimeUnit.SECONDS);
        }
    }

    /**
     * 添加set
     *
     * @param key
     * @param value
     */
    public  void sadd(String key, String... value) {
        redisTemplate.boundSetOps(key).add(value);
    }

    /**
     * 删除set集合中的对象
     *
     * @param key
     * @param value
     */
    public  void srem(String key, String... value) {
        redisTemplate.boundSetOps(key).remove(value);
    }

    /**
     * set重命名
     *
     * @param oldkey
     * @param newkey
     */
    public  void srename(String oldkey, String newkey) {
        redisTemplate.boundSetOps(oldkey).rename(newkey);
    }

    /**
     * 短信缓存
     *
     * @author fxl
     * @date 2016年9月11日
     * @param key
     * @param value
     * @param time

    public  void setIntForPhone(String key, Object value, int time) {
        stringRedisTemplate.opsForValue().set(key, JsonUtil.toJsonString(value));
        if (time &gt; 0) {
            stringRedisTemplate.expire(key, time, TimeUnit.SECONDS);
        }
    }
     */

    /**
     * 模糊查询keys
     *
     * @param pattern
     * @return
     */
    public static Set&lt;String&gt; keys(String pattern) {

        return redisTemplate.keys(pattern);
    }

    /**
     *
     * @Description (检查key是否存在，返回boolean值 )
     * @author feizhou
     * @Date 2018年5月29日下午5:37:40
     * @version 1.0.0
     * @param key
     * @return
     */
    public  Boolean   ishasKey(String key) {
        return stringRedisTemplate.hasKey(key);
    }

}
</code></pre> 
<p>SpringUtil类：</p> 
<pre><code class="language-java">package com.utils;

import org.springframework.beans.BeansException;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;

/**
 * 工具类 - Spring
 * @author zgp2010
 *
 */

public class SpringUtil implements ApplicationContextAware {
	
	private static ApplicationContext applicationContext;

	public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
		SpringUtil.applicationContext = applicationContext;
	}

	public static ApplicationContext getApplicationContext() {
		return applicationContext;
	}

	/**
	 * 根据Bean名称获取实例
	 * 
	 * @param name
	 *            Bean注册名称
	 * 
	 * @return bean实例
	 * 
	 * @throws BeansException
	 */
	public static Object getBean(String name) throws BeansException {
		return applicationContext.getBean(name);
	}
}
</code></pre> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/decc2a29b6e795e275930d56540f18eb/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">IO进程知识点</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8be227cce010d09e89d79e386f33f101/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">c&#43;&#43;中的异常处理</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>