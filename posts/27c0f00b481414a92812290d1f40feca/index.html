<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>HTTP协议和HTTPS加密 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="HTTP协议和HTTPS加密" />
<meta property="og:description" content="HTTP协议目录 HTTP的概论HTTP请求HTTP请求HostContent-Type和Content-lenthUser-Agent（UA）RefererCookie HTTP响应状态码 HTTPS HTTP的概论 我在网络那一篇文章中写到：我们常用的网络结构；是5层网络结构。分别是应用层，传输层，网络层，数据链路层，物理层。
应用层：关注数据怎么使用。
传输层：关注整个传输的起点和终点。
网络层：地址管理加路由选择。
数据链路层：相邻节点之间的数据转发。
物理层：基础设施构建等同于现实的高速公路。
http协议是一个使用非常广泛的应用层协议，也是TCP/IP协议栈。
应用层的协议，经常需要自定义协议。协议可定制性就非常强，所以基于HTTP我们可以进行拓展。
只要连接外网，基本上就都会使用HTTP协议。
http是一个一问一答形式的协议，及一个请求，一个响应。
而我们主要是去了解HTTP的报文格式，我们要去理解HTTP的报文格式我们就需要一个外部的工具，将HTTP协议显示出来，而这个工具呢，俗称抓包工具。
一般谷歌浏览器和IE浏览器他们会提供抓包的东西。通常按F12键就可以进入一个网页的开发者模式，我们在开发者模式中找到网络这个选项，就可以在里面找到。相应的报文。
但我们作为一个专业的程序员，我们就应该去选择一个专业的工具，这里呢，我推荐大家使用fiddler。软件有付费版和免费版啊，免费版就够用。
这个HTTP上面的所有东西都要勾选上，不然的话无法抓捕到包头。
软件，左边的是HTTP的列表。主要是相对应的HTTP的具体数据，而我们这里要用的是raw，观看HTTP的具体报头，是纯净版。
一般我们看到的请求大部分都是get请求，在登录和上传文件的时候会看见post请求。
一般我们看HTTP呢就看get和post就足矣，可看可不看。
补充一点：一般post请求不会随意出现，一旦出现必定是上传文件的时候。而在登录的时候，我们也需要去提交材料，提交登录信息，而此时你的密码在抓包工具被抓包的情况下，也就是在boss请求被抓到的情况下，会在下面显示密码。有一些网站对于这一块的保密做的不是很好，就使得有一些。非法分子对其的电脑做一些抓包处理，抓到登录账号和密码。它有一些它是经过加密的，但是经过特殊处理之后还是能被显示出来，所以你账号一定不要注册一个，尽量多注册几个高端密码。
post请求body一般不为空，而get请求body的时候一般为空。
HTTP 报文中要存在 &#34;空行，HTTP 在传输层依赖 TCP 协议, TCP 是面向字节流的. 如果没有这个空行, 就会出现 “粘包问题” 。
就是我们上传的数据计算机无法有效识别。所有的值都成为了一条字符串，无法有效的进行分割。
HTTP请求 Get的语义是从服务器里拿一个东西。
post的语义网服务器里提交一个东西。
http的这种语义通常是一种建议，在实际开发中也可以不一定遵守，对于body有没有，也不能说是绝对，get，有可能会有body，而post也可能会没有有body，只不过这种情况比较少见。
对于get和post这两种方法来说，本质上是没有区别的。也可以互相替换。但是对于操作习惯来说，他们两者是有区别的。
get习惯上用来表示获取一个数据，而post用来表示提交一个数据。
一般没有body需要携带数据，则放到URL中post没有，一般有body。
get经常会被设计成幂等，而post则无要求。什么是幂等？就是我们输入一个变量，他不是随机的。每一次输入这个变量会出现一个固定的值，这个叫幂等。
get可缓存的（提前是幂等）， Post则不能。
Get请求可以被浏览器收藏，post不能。
报文格式：
请求
首行（ 方法 URL 版本号）请求头 header.空行。正文body。 URL 协议名://IP:端口号/带层次的路径?查询字符串
响应。
首行（版本号，状态栏，状态码，描述）响应头harder。空行。正文body，通常是一个html，css，js或图片。 HTTP请求 Host Host：www.baidu.com
这个属性，除了浏览器，这个请求要访问的服务器是谁。
绝大多数情况下，Host中的值和URL中的域名是一致的。当我们通过代理来访问的时候。此时host和URL就不同了。host是作为最终目标，而URL是当前目标。
Content-Type和Content-lenth Content-Type ：描述了body的数据格式。
Content-lenth：描述了body的长度，单位字节。
Content-Type: application/json;charset=utf-8" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/27c0f00b481414a92812290d1f40feca/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-08-06T21:56:13+08:00" />
<meta property="article:modified_time" content="2023-08-06T21:56:13+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">HTTP协议和HTTPS加密</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>HTTP协议目录</h4> 
 <ul><li><a href="#HTTP_1" rel="nofollow">HTTP的概论</a></li><li><a href="#HTTP_41" rel="nofollow">HTTP请求</a></li><li><ul><li><a href="#HTTP_73" rel="nofollow">HTTP请求</a></li><li><ul><li><a href="#Host_77" rel="nofollow">Host</a></li><li><a href="#ContentTypeContentlenth_83" rel="nofollow">Content-Type和Content-lenth</a></li><li><a href="#UserAgentUA_108" rel="nofollow">User-Agent（UA）</a></li><li><a href="#Referer_121" rel="nofollow">Referer</a></li><li><a href="#Cookie_131" rel="nofollow">Cookie</a></li></ul> 
  </li></ul> 
  </li><li><a href="#HTTP_158" rel="nofollow">HTTP响应</a></li><li><ul><li><a href="#_159" rel="nofollow">状态码</a></li></ul> 
  </li><li><a href="#HTTPS_253" rel="nofollow">HTTPS</a></li></ul> 
</div> 
<p></p> 
<h2><a id="HTTP_1"></a>HTTP的概论</h2> 
<p>我在网络那一篇文章中写到：我们常用的网络结构；是5层网络结构。分别是应用层，传输层，网络层，数据链路层，物理层。</p> 
<p>应用层：关注数据怎么使用。<br> 传输层：关注整个传输的起点和终点。<br> 网络层：地址管理加路由选择。<br> 数据链路层：相邻节点之间的数据转发。<br> 物理层：基础设施构建等同于现实的高速公路。</p> 
<p>http协议是一个使用非常广泛的应用层协议，也是TCP/IP协议栈。</p> 
<p>应用层的协议，经常需要自定义协议。协议可定制性就非常强，所以基于HTTP我们可以进行拓展。</p> 
<p>只要连接外网，基本上就都会使用HTTP协议。</p> 
<p>http是一个一问一答形式的协议，及一个请求，一个响应。<br> <img src="https://images2.imgbox.com/1c/bb/Ab9nWwTZ_o.png" alt="在这里插入图片描述"><br> 而我们主要是去了解HTTP的报文格式，我们要去理解HTTP的报文格式我们就需要一个外部的工具，将HTTP协议显示出来，而这个工具呢，俗称抓包工具。</p> 
<p>一般谷歌浏览器和IE浏览器他们会提供抓包的东西。通常按F12键就可以进入一个网页的开发者模式，我们在开发者模式中找到网络这个选项，就可以在里面找到。相应的报文。<br> <img src="https://images2.imgbox.com/74/c1/aMd1KD07_o.png" alt="在这里插入图片描述"><br> 但我们作为一个专业的程序员，我们就应该去选择一个专业的工具，这里呢，我推荐大家使用fiddler。软件有付费版和免费版啊，免费版就够用。<br> <img src="https://images2.imgbox.com/b9/80/ogczwa0U_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/2b/a0/2HiA6ejU_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/0b/22/wpuwpez8_o.png" alt="在这里插入图片描述"><br> 这个HTTP上面的所有东西都要勾选上，不然的话无法抓捕到包头。</p> 
<p>软件，左边的是HTTP的列表。主要是相对应的HTTP的具体数据，而我们这里要用的是raw，观看HTTP的具体报头，是纯净版。<br> <img src="https://images2.imgbox.com/6a/82/21uRtYEl_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/cd/a5/BAM9VVVS_o.png" alt="在这里插入图片描述"><br> 一般我们看到的请求大部分都是get请求，在登录和上传文件的时候会看见post请求。<br> 一般我们看HTTP呢就看get和post就足矣，可看可不看。</p> 
<p>补充一点：一般post请求不会随意出现，一旦出现必定是上传文件的时候。而在登录的时候，我们也需要去提交材料，提交登录信息，而此时你的密码在抓包工具被抓包的情况下，也就是在boss请求被抓到的情况下，会在下面显示密码。有一些网站对于这一块的保密做的不是很好，就使得有一些。非法分子对其的电脑做一些抓包处理，抓到登录账号和密码。它有一些它是经过加密的，但是经过特殊处理之后还是能被显示出来，所以你账号一定不要注册一个，尽量多注册几个高端密码。</p> 
<p>post请求body一般不为空，而get请求body的时候一般为空。</p> 
<p>HTTP 报文中要存在 "空行，HTTP 在传输层依赖 TCP 协议, TCP 是面向字节流的. 如果没有这个空行, 就会出现 “粘包问题” 。<br> 就是我们上传的数据计算机无法有效识别。所有的值都成为了一条字符串，无法有效的进行分割。</p> 
<h2><a id="HTTP_41"></a>HTTP请求</h2> 
<p>Get的语义是从服务器里拿一个东西。<br> post的语义网服务器里提交一个东西。</p> 
<p>http的这种语义通常是一种建议，在实际开发中也可以不一定遵守，对于body有没有，也不能说是绝对，get，有可能会有body，而post也可能会没有有body，只不过这种情况比较少见。</p> 
<p>对于get和post这两种方法来说，本质上是没有区别的。也可以互相替换。但是对于操作习惯来说，他们两者是有区别的。</p> 
<ol><li> <p>get习惯上用来表示获取一个数据，而post用来表示提交一个数据。</p> </li><li> <p>一般没有body需要携带数据，则放到URL中post没有，一般有body。</p> </li><li> <p>get经常会被设计成幂等，而post则无要求。什么是幂等？就是我们输入一个变量，他不是随机的。每一次输入这个变量会出现一个固定的值，这个叫幂等。</p> </li><li> <p>get可缓存的（提前是幂等）， Post则不能。</p> </li><li> <p>Get请求可以被浏览器收藏，post不能。</p> </li></ol> 
<p>报文格式：<br> 请求</p> 
<ol><li>首行（ 方法 URL 版本号）</li><li>请求头 header.</li><li>空行。</li><li>正文body。</li></ol> 
<p>URL 协议名://IP:端口号/带层次的路径?查询字符串</p> 
<p>响应。</p> 
<ol><li>首行（版本号，状态栏，状态码，描述）</li><li>响应头harder。</li><li>空行。</li><li>正文body，通常是一个html，css，js或图片。</li></ol> 
<h3><a id="HTTP_73"></a>HTTP请求</h3> 
<p><img src="https://images2.imgbox.com/4e/e4/HaDCnKLw_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/25/b8/mhem4NLr_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="Host_77"></a>Host</h4> 
<p>Host：www.baidu.com<br> 这个属性，除了浏览器，这个请求要访问的服务器是谁。</p> 
<p>绝大多数情况下，Host中的值和URL中的域名是一致的。当我们通过代理来访问的时候。此时host和URL就不同了。host是作为最终目标，而URL是当前目标。</p> 
<h4><a id="ContentTypeContentlenth_83"></a>Content-Type和Content-lenth</h4> 
<p>Content-Type ：描述了body的数据格式。<br> Content-lenth：描述了body的长度，单位字节。</p> 
<p>Content-Type: application/json;charset=utf-8<br> （application/json）:json格式，用{}表示，诺干键值对。键值对之间用，逗号，分割，键和值使用：分割。<br> （application/x-www-form-urlencoded）:form 提交表单数据，会生成这种形式的body。</p> 
<blockquote> 
</blockquote> 
<pre><code>&lt;input type="text" name="userId"&gt;
&lt;input type="text" name="classId"&gt;
&lt;input type="submit" value="提交"&gt;
</code></pre> 
<ul><li>action: 构造的 HTTP 请求的 URL 是什么. method: 构造的 HTTP 请求的 方法 是 GET 还是 POST<br> (form 只支持 GET 和 POST). input 的重要参数: type: 表示输入框的类型. text 表示文本,<br> password 表示密码, submit 表示提交按钮. name: 表示构造出的 HTTP 请求的 query string 的<br> key. query string 的 value 就是输入框的用户 输入的内容. value: input 标签的值. 对于 type<br> 为 submit 类型来说, value 就对应了按钮上显示的文本.</li></ul> 
<p>charset=utf-8：字符的格式</p> 
<p>作为请求，Content-Type，上面这两种写法最多。<br> 作为相应，Content-Type，还有几种写法<br> <img src="https://images2.imgbox.com/3c/d0/dMPWfQQu_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="UserAgentUA_108"></a>User-Agent（UA）</h4> 
<blockquote> 
 <p>User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/115.0.0.0 Safari/537.36 Edg/115.0.1901.188</p> 
</blockquote> 
<p>Windows NT 10.0; Win64; x64：操作系统版本64位wind10系统（我的是wind11，可能内核一样）</p> 
<p>Chrome/115.0.0.0 ：浏览器版本<br> Safari/537.36：浏览器版本</p> 
<p>现在User-Agent，因为时代问题，现在的主要用途是手机/PC/平板<br> （ UC能做到这一点，但是实际上，现在还有更好的方案来解决这个问题，css3 中提供了媒体查询功能，可以根据浏览器窗口大小来设置不同样式，这种页面开发方式称之为响应式布局）</p> 
<h4><a id="Referer_121"></a>Referer</h4> 
<p><strong>描述了当前这个页面，从哪个页面跳转来的</strong></p> 
<p>通常可以用来统计点击次数，这种方式也是浏览器获利的主要方式。就是客户通过点击浏览器上的广告，浏览器的主营单位就可以赚取的相应的点击费。</p> 
<p>而为此，曾经发生了一件事，就是运营商劫持事件。所有的网络服务，都必须经过运营商的服务器，所以运营商可以修改这个数据。使得运营商的广告收入增加。</p> 
<p>为此，推出了HTTPS的加密协议。</p> 
<h4><a id="Cookie_131"></a>Cookie</h4> 
<p>cookie的值也是键值对</p> 
<blockquote> 
 <p>Cookie: BIDUPSID=8f60a93dc302578aacc49601c892ba12; PSTM=1578482103; BAIDUID=322807F4C394FA18C48A069469EEE67A:FG=1;…</p> 
</blockquote> 
<p>cookie的值也是键值对</p> 
<p>键值之间用；分割<br> 键和值之间使用=分割</p> 
<p>cookie的本质是浏览器在本地存储，用户自定义数据的一种关键机制。</p> 
<p>所以每个网站都存自己的cookie，及cookie根据域名各有不同。</p> 
<p>1.cookie从哪里来。<br> 通过服务器给浏览器返回cookie的数据，当我的浏览器访问服务器的时候，浏览器会在http响应中，通过Set-Cookie字段，把Cookie的键值对，返回给浏览器，浏览器收到数据，就会存到本地存储。</p> 
<p>2.Cookie到哪里去<br> 会在下次请求的时候，把Cookie带给服务器<br> Cookie在浏览器这边只能是，“暂时存储”，数据要发挥作用还得讲给服务器。</p> 
<p>3.有什么作用<br> 是服务器的本地存储数据的机制<br> 由于客户端很多，每个客户端提供的服务可能不一样，因此通过cookie进行区分，和识别。<br> （存储用户的身份信息（用户登录之后，身份））</p> 
<h2><a id="HTTP_158"></a>HTTP响应</h2> 
<h3><a id="_159"></a>状态码</h3> 
<ol><li> <p>200 OK：<br> 表示访问成功。</p> </li><li> <p>404 Not Found：<br> 没有找到资源。（浏览器输入一个 URL, 目的就是为了访问对方服务器上的一个资源. 如果这个 URL 标识的资源不存在, 那么就会出现 404）</p> </li><li> <p>403 Forbidden：<br> 表示访问被拒绝。<br> 有的页面通常需要用户具有一定的权限才能访问(登陆后才能访问). 如果用户没有登陆<br> 直接访问, 就容易见到 403。</p> </li><li> <p>405 Method Not Allowed<br> 但是对方的服务器不一定都支持所有的方法(或者不允许用户使用一些其他的方法)</p> </li><li> <p>500 Internal Server Error<br> 服务器出现内部错误<br> 一般是服务器的代码执行过程中遇到了一些特殊情况(服务器异常崩溃)会产生这个状态码</p> </li><li> <p>504 Gateway Timeout<br> 当服务器负载比较大的时候, 服务器处理单条请求的时候消耗的时间就会很长, 就可能会导致出现超时的情况</p> </li><li> <p>302 Move temporarily<br> 临时重定向，在登陆页面中经常会见到 302. 用于实现登陆成功后自动跳转到主页. 响应报文的 header 部分会包含一个 Location 字段, 表示要跳转到哪个页面</p> </li><li> <p>301 Moved Permanently<br> 永久重定向，当浏览器收到这种响应时, 后续的请求都会被自动改成新的地址.。301 也是通过 Location 字段来表示要重定向到的新地址。</p> </li></ol> 
<p>小结：</p> 
<table><thead><tr><th>号码头</th><th>类别</th><th>原因</th></tr></thead><tbody><tr><td>1xx</td><td>Informational（信息性状态码）</td><td>接收的请求正在处理</td></tr><tr><td>2xx</td><td>Succes（成功状态码）</td><td>请求正常处理完毕</td></tr><tr><td>3xx</td><td>Redirection（重定向状态码）</td><td>需要进行附加操作以完成请求</td></tr><tr><td>4xx</td><td>client Error（客户端错误状态码）</td><td>服务器无法处理请求</td></tr><tr><td>5xx</td><td>server Error（服务器错误状态码）</td><td>服务器处理出错</td></tr></tbody></table> 
<p>form发送post请求</p> 
<pre><code class="prism language-java"><span class="token operator">&lt;</span>form action<span class="token operator">=</span><span class="token string">"http://abcdef.com/myPath"</span> method<span class="token operator">=</span><span class="token string">"post"</span><span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>input type<span class="token operator">=</span><span class="token string">"text"</span> name<span class="token operator">=</span><span class="token string">"userId"</span><span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>input type<span class="token operator">=</span><span class="token string">"text"</span> name<span class="token operator">=</span><span class="token string">"classId"</span><span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>input type<span class="token operator">=</span><span class="token string">"submit"</span> value<span class="token operator">=</span><span class="token string">"提交"</span><span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>form<span class="token operator">&gt;</span>
</code></pre> 
<p>form 的 action 属性对应 HTTP 请求的 URL<br> form 的 method 属性对应 HTTP 请求的方法<br> input 的 name 属性对应 query string 的 key<br> input 的 内容 对应 query string 的 value</p> 
<p>form有一个属性enctype属性，可以影响content-type</p> 
<p>ajax：<br> 现在最主要的前后端的交互模式之一。（异步交互）<br> 全称：asynchronized javascript and xml</p> 
<p>A：异步，synchronized同步<br> 应用场景：</p> 
<ol><li>同步和互斥（加锁的场景）</li><li>同步和异步（io的场景）</li></ol> 
<p>同步：请求发起来处理好后，自己来取<br> 异步：请求发过来处理好，发给他。</p> 
<p>使用jQuery中的ajax</p> 
<pre><code class="prism language-java"> <span class="token generics"><span class="token punctuation">&lt;</span>body<span class="token punctuation">&gt;</span></span>
    <span class="token generics"><span class="token punctuation">&lt;</span>script<span class="token punctuation">&gt;</span></span>
        $<span class="token punctuation">.</span><span class="token function">ajax</span><span class="token punctuation">(</span><span class="token punctuation">{<!-- --></span>
            url<span class="token operator">:</span><span class="token string">"https://www.sogou.com"</span><span class="token punctuation">,</span>
            type<span class="token operator">:</span><span class="token string">"get"</span><span class="token punctuation">,</span><span class="token comment">//可以写成，post，put，delete，等等</span>
            success<span class="token operator">:</span><span class="token function">function</span><span class="token punctuation">(</span>body<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                <span class="token comment">//写处理响应的代码</span>
                console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>body<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>body<span class="token operator">&gt;</span>
</code></pre> 
<p>是一个回调函数，但是在java中其实很少有函数这个术语。但是在在C语言中经常提出。</p> 
<p>什么是回调函数。就是不是马上拿到结果，而是运行到了这里才开始。</p> 
<p>但是有一个重要的问题：ajax的跨域问题，及现在运行ajax代码的页面是123.com，但是ajax里的请求，访问的域名是456.com，此时哪怕服务器给你数据，浏览器也不能处理，要报错。</p> 
<h2><a id="HTTPS_253"></a>HTTPS</h2> 
<p>https基于HTTP，只比http多了一个加密层。<br> 明文–》密文：加密<br> 密文–》文明：解密<br> 密钥用于解锁密文。</p> 
<p>对称加密：只有一个密钥（key）<br> 明文+key=密文<br> 密文+key=明文</p> 
<p><img src="https://images2.imgbox.com/96/56/LwFBaOJu_o.png" alt="在这里插入图片描述"></p> 
<p>非对称加密：公钥（pub）私钥（pri）<br> 明文+pub=密文<br> 密文+pri=明文<br> 或者<br> 明文+pri=密文<br> 密文+pub=明文</p> 
<p>每个客户端的密钥，必然不相同。客户端生成自己的密钥后，就会把密钥传给服务器<br> <img src="https://images2.imgbox.com/82/46/FSDILcoy_o.png" alt="在这里插入图片描述"></p> 
<p>对称密钥只传一次。服务器生成公钥和私钥，上传公钥给客户端，保留私钥。而客户端生成对称密钥。客户端将自己的key用服务器的公钥加密。上传给服务器。而服务器需要私钥对照公钥对客户端上传的数据进行解密。从而拿到客户端的key。（公钥和私钥放在一起才能解密）</p> 
<p>这是基本的思路。</p> 
<p>但是实际中其实是有更多密钥。<br> 引入证书（服务器的域名，有效时间，服务器的公钥，颁布证书的机构，被加密的签名。。。）</p> 
<p><img src="https://images2.imgbox.com/84/90/UuAQ9EuD_o.png" alt="在这里插入图片描述"></p> 
<p>被加密的签名：校验和，使用证书中的其他各个属性，综合在一起通过某种算法运算出一个数字，（校验和和客户端通过同样的算法得出的数据对比）两个数据如果相同，及校验和一定相同。这签名在颁布的时候同时计算的，并使用机构自己的公钥加密了<br> （这里的话可能会有些蒙，或许不太理解机构用私钥加密后客户端如何解密，拿到校验和，其实每台客户端操作系统都有相应的公钥。所以公钥就在我们手里）</p> 
<p>而这一套是：对称加密+非对称加密+证书，不仅仅是HTTPS会涉及jdbc也会涉及。<br> 这一套也叫SSL/TLS</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/69482344f4bfa1eb222994ff91c3d290/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">树莓派是aarch64(64位ARM架构)，操作系统是32位的，在装Miniconda3遇到这个错误Miniconda3-py37_4.9.2-Linux-aarch64.sh: line 398:</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/07fc18015d9cff31740b82b8fff92df8/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">如何在宝塔页面内部署go项目</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>