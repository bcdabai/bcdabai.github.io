<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>使用C语言去掉字符串集合重复元素 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="使用C语言去掉字符串集合重复元素" />
<meta property="og:description" content="有一种最直接的方法可以去掉一个集合中重复的元素，这种方法据说就是“交给下面去做”，然而有时候，你自己动手去做一下也是不错的。如果交给下面去做，最直接的选择就是使用map，在java中，我们有HashMap，TreeMap等等实现了map接口的类可用，c&#43;&#43;中，同样有STL的同类集合可以使用，在各类高级语言中，就更不必说了，然而在c中，就没有那么幸运了，很多东西需要你来自己实现。 根据《C语言内力修炼与软件工程》，用c语言自行实现这个东西，其实对于软件工程而言没有必要，然而可以训练一下自己，增加一些内力。我不认为自己是个高手，更非大侠，然而因为我懂得少，只能自己重新来做，真恨自己没有在5年前多学习一些编程语言。 先来简单分析一下需求，就是一个字符串集合中，去掉重复的字符串，换句话说就是每一个字符串只保留一个。题目没有说是否保持原有的字符串输入顺序，作为完美主义的我，我还是将其当成了一个隐含的需求。那么下一步就是将问题进行简化和转化，如果我们能将这一堆字符串进行排序，那么最终遍历这个排过序的字符串集合，发现和前一个相同的字符串就跳过不输出，对于排序，再简单不过了，至少N中排序算法，本文不讨论各种排序算法，只使用最简单的冒泡排序来分析。那么怎么保留原有的输入序呢？这也很简单，就是在排序元素中增加一个指向原有序的指针即可，另外还有一种方法，那就是排序过程仅仅是一个删除重复元素的过程，而不影响原有的输入序列，这个动态行为可以用二叉树的插入来实现，或者其它的AVL树以及红黑树都可以，本文不会去谈这几棵树的特性，只是用最简单的排序二叉树来分析。 我们知道，在二叉树插入中，首先要进行一次查找，现在要做的是，如果没有找到相同的，则插入，如果找到了相同的，则不插入，同时为该元素置入删除标识。代码如下： // // main.c // dup-del // // Created by ya zhao on 11-12-17. // Copyright 2011年 __MyCompanyName__. All rights reserved. // #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; struct sorted_order_str_map_with_thread { char *sorted_order_str; //保存排序后的字符串 char *normal_order_str; //保存原始字符串 int tag; //指示是否要删除 struct sorted_order_str_map_with_thread *self; //指向原始的位置 }; void sort(struct sorted_order_str_map_with_thread smwt[], const int size, int (*cmp)(void *, void *), void (*swap)(void *q1, void *q2)); int cmp_node(void *, void *); //比较函数，如果相同则将其tag位设置为0，标示要删除 int cmp_node(void *q1, void *q2) { int res; struct sorted_order_str_map_with_thread *cmp1, *cmp2; cmp1 = (struct sorted_order_str_map_with_thread*)q1; cmp2 = (struct sorted_order_str_map_with_thread*)q2; res = strcmp(cmp1-&gt;sorted_order_str, cmp2-&gt;sorted_order_str); if (res == 0) { struct sorted_order_str_map_with_thread *p = cmp2-&gt;self; p-&gt;tag = 0; } return res; } //交换函数，不光要交换元素，还要交换其self指针 void swap_node(void *q1, void *q2) { struct sorted_order_str_map_with_thread *swp1, *swp2,*temp; char *strTemp; swp1 = (struct sorted_order_str_map_with_thread*)q1; swp2 = (struct sorted_order_str_map_with_thread*)q2; strTemp = swp1-&gt;sorted_order_str; temp = (swp1-&gt;self); swp1-&gt;sorted_order_str = swp2-&gt;sorted_order_str; swp1-&gt;self = swp2-&gt;self; swp2-&gt;sorted_order_str = strTemp; swp2-&gt;self = temp; } //标准冒泡排序 void sort(struct sorted_order_str_map_with_thread smwt[], const int size, int (*cmp)(void *q1, void *q2), void (*swap)(void *q1, void *q2)) { int flag = 1; for (int i = 0; i &lt; size - 1; i &#43;&#43;) { flag = 1; for (int j = 0; j &lt; size - i - 1; j &#43;&#43;) { int res = 0; if ((res = cmp(&amp;smwt[j], &amp;smwt[j&#43;1])) &gt; 0) { swap(&amp;smwt[j], &amp;smwt[j&#43;1]); flag = 0; } } if (flag == 1) break; } } int main (int argc, const char * argv[]) { int i = 0; //为了简化，下面使用了最恶心的初始化方法。方便复制粘贴 struct sorted_order_str_map_with_thread smwt[20] = {{NULL, NULL, 0 NULL}}; smwt[0]." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/cfa62173a78304012878cdc42383459a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2011-12-17T13:12:00+08:00" />
<meta property="article:modified_time" content="2011-12-17T13:12:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">使用C语言去掉字符串集合重复元素</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <br>有一种最直接的方法可以去掉一个集合中重复的元素，这种方法据说就是“交给下面去做”，然而有时候，你自己动手去做一下也是不错的。如果交给下面去做，最直接的选择就是使用map，在java中，我们有HashMap，TreeMap等等实现了map接口的类可用，c++中，同样有STL的同类集合可以使用，在各类高级语言中，就更不必说了，然而在c中，就没有那么幸运了，很多东西需要你来自己实现。 
<br> 根据《C语言内力修炼与软件工程》，用c语言自行实现这个东西，其实对于软件工程而言没有必要，然而可以训练一下自己，增加一些内力。我不认为自己是个高手，更非大侠，然而因为我懂得少，只能自己重新来做，真恨自己没有在5年前多学习一些编程语言。 
<br> 先来简单分析一下需求，就是一个字符串集合中，去掉重复的字符串，换句话说就是每一个字符串只保留一个。题目没有说是否保持原有的字符串输入顺序，作为完美主义的我，我还是将其当成了一个隐含的需求。那么下一步就是将问题进行简化和转化，如果我们能将这一堆字符串进行排序，那么最终遍历这个排过序的字符串集合，发现和前一个相同的字符串就跳过不输出，对于排序，再简单不过了，至少N中排序算法，本文不讨论各种排序算法，只使用最简单的冒泡排序来分析。那么怎么保留原有的输入序呢？这也很简单，就是在排序元素中增加一个指向原有序的指针即可，另外还有一种方法，那就是排序过程仅仅是一个删除重复元素的过程，而不影响原有的输入序列，这个动态行为可以用二叉树的插入来实现，或者其它的AVL树以及红黑树都可以，本文不会去谈这几棵树的特性，只是用最简单的排序二叉树来分析。 
<br> 我们知道，在二叉树插入中，首先要进行一次查找，现在要做的是，如果没有找到相同的，则插入，如果找到了相同的，则不插入，同时为该元素置入删除标识。代码如下： 
<br> 
<pre><code class="language-cpp">//
//  main.c
//  dup-del
//
//  Created by ya zhao on 11-12-17.
//  Copyright 2011年 __MyCompanyName__. All rights reserved.
//

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

struct sorted_order_str_map_with_thread {
    char *sorted_order_str;  //保存排序后的字符串
    char *normal_order_str;  //保存原始字符串
    int tag;                //指示是否要删除
    struct sorted_order_str_map_with_thread *self; //指向原始的位置
};

void sort(struct sorted_order_str_map_with_thread smwt[], const int size,
                    int (*cmp)(void *, void *),
                    void (*swap)(void *q1, void *q2));
int cmp_node(void *, void *);
//比较函数，如果相同则将其tag位设置为0，标示要删除
int cmp_node(void *q1, void *q2)
{
    int res;
    struct sorted_order_str_map_with_thread *cmp1, *cmp2;
    cmp1 = (struct sorted_order_str_map_with_thread*)q1;
    cmp2 = (struct sorted_order_str_map_with_thread*)q2;
    res = strcmp(cmp1-&gt;sorted_order_str, cmp2-&gt;sorted_order_str);
    if (res == 0) {
        struct sorted_order_str_map_with_thread *p = cmp2-&gt;self;
        p-&gt;tag  = 0;
    }
    return res;
}
//交换函数，不光要交换元素，还要交换其self指针
void swap_node(void *q1, void *q2)
{
    struct sorted_order_str_map_with_thread *swp1, *swp2,*temp;
    char *strTemp;
    swp1 = (struct sorted_order_str_map_with_thread*)q1;
    swp2 = (struct sorted_order_str_map_with_thread*)q2;
    strTemp = swp1-&gt;sorted_order_str;
    temp = (swp1-&gt;self);
    swp1-&gt;sorted_order_str = swp2-&gt;sorted_order_str;
    swp1-&gt;self = swp2-&gt;self;
    swp2-&gt;sorted_order_str = strTemp;
    swp2-&gt;self = temp;
}

//标准冒泡排序
void sort(struct sorted_order_str_map_with_thread smwt[], const int size,
                int (*cmp)(void *q1, void *q2),
                void (*swap)(void *q1, void *q2))
{
    int flag = 1;
    for (int i = 0; i &lt; size - 1; i ++) {
        flag = 1;
        for (int j = 0; j &lt; size - i - 1; j ++) {
            int res = 0;
            if ((res = cmp(&amp;smwt[j], &amp;smwt[j+1])) &gt; 0) {
                swap(&amp;smwt[j], &amp;smwt[j+1]);
                flag = 0;
            }
        }
        
        if (flag == 1)
            break;
    }
}

int main (int argc, const char * argv[])
{
    int i = 0;
    //为了简化，下面使用了最恶心的初始化方法。方便复制粘贴
    struct sorted_order_str_map_with_thread smwt[20] = {<!-- -->{NULL, NULL, 0 NULL}};
    smwt[0].sorted_order_str =smwt[0].normal_order_str =  "323";
    smwt[0].self = &amp;smwt[0];
    smwt[0].tag = 1;
    smwt[1].sorted_order_str = smwt[1].normal_order_str="223";
    smwt[1].self = &amp;smwt[1];
    smwt[1].tag = 2;
    smwt[2].sorted_order_str =smwt[2].normal_order_str= "723";
    smwt[2].self = &amp;smwt[2];
    smwt[2].tag = 3;
    smwt[3].sorted_order_str =smwt[3].normal_order_str= "823";
    smwt[3].self = &amp;smwt[3];
    smwt[3].tag = 4;
    smwt[4].sorted_order_str =smwt[4].normal_order_str= "123";
    smwt[4].self = &amp;smwt[4];
    smwt[4].tag = 5;
    smwt[5].sorted_order_str =smwt[5].normal_order_str= "423";
    smwt[5].self = &amp;smwt[5];
    smwt[5].tag = 6;
    smwt[6].sorted_order_str =smwt[6].normal_order_str= "123";
    smwt[6].self = &amp;smwt[6];
    smwt[6].tag = 7;
    smwt[7].sorted_order_str =smwt[7].normal_order_str= "723";
    smwt[7].self = &amp;smwt[7];
    smwt[7].tag = 8;
    smwt[8].sorted_order_str = smwt[8].normal_order_str="523";
    smwt[8].self = &amp;smwt[8];
    smwt[8].tag = 9;
    smwt[9].sorted_order_str =smwt[9].normal_order_str= "823";
    smwt[9].self = &amp;smwt[9];
    smwt[9].tag = 10;

    sort(smwt, 10, cmp_node, swap_node);
    //下面使用了最恶心的输出，经典###
    for (i = 0; i&lt; 10; i++) {
        printf("###:%s    tag:%d\n", smwt[i].normal_order_str, smwt[i].tag);
    }
    for (i = 0; i&lt; 10; i++) {
            printf("@@@:%s  tag:%d\n", smwt[i].sorted_order_str, smwt[i].tag);
    }
    for (i = 0; i&lt; 10; i++) {
        if (smwt[i].tag != 0){
        printf("@@@&amp;&amp;:%s\n", smwt[i].normal_order_str);
        }
    }
    return 0;
}</code></pre> 
<br> 
<br>下面的一种方法使用了标准的二叉树插入，注意，插入仅仅是为了删除重复元素，实际上，各种语言各种库的标准Map实现很多也是使用了树，比如java.util中的TreeMap就是使用了红黑树。下面直接给出代码，基于排序二叉树的代码： 
<br> 
<pre><code class="language-cpp">//
//  main.c
//  test-xcode
//
//  Created by ya zhao on 11-12-17.
//  Copyright 2011年 __MyCompanyName__. All rights reserved.
//

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

struct string_node {
    char  *string;
    int tag;  //标示是否被删除
};
//标准排序二叉树
struct string_tree {
    struct string_node  *strn;
    struct string_tree* left,*right;
};

struct string_tree *add_node(struct string_tree *, struct string_node *str, int (*cmp)(struct string_node *, struct string_node *));
int normalcmp(struct string_node *, struct string_node *);
//简单的字符串比较
int normalcmp(struct string_node *n1, struct string_node *n2)
{
    return  strcmp (n1-&gt;string,n2-&gt;string);
}

int main(int argc, char **argv)
{
    
    int j = 0;
    for (j = 0; j &lt; 1; j++) {
        struct string_tree *root;
        struct string_node str[9] = {<!-- -->{"123",1},{"456",1},{"234",1},{"123",1},{"347",1},{"129",1},{"888",1}, {"568",1}, {"456",1}};
        root = NULL;
        int i = 0;
        while (i&lt;9) {
            root = add_node(root, &amp;str[i], normalcmp);
            i ++;
        }
        i=0;
        while (i&lt;9){
            if (str[i].tag) {
                printf("&amp;&amp;&amp;:%s\n", str[i].string);
            }
            i++;
        }
    }
    return 0;
}

struct string_tree *add_node(struct string_tree *p, struct string_node *new, int (*cmp)(struct string_node *n1, struct string_node *n2))
{
    int cmp_ret;
    if (p == NULL) {
        p = (struct string_tree *)calloc(1, sizeof(struct string_tree));
        p-&gt;strn = (struct string_node*)calloc(1, sizeof(struct string_node));
        memcpy(p-&gt;strn, new, sizeof(struct string_node));
        p-&gt;left = p-&gt;right = NULL;
    } else if ((cmp_ret = cmp(new, p-&gt;strn)) == 0) {
        new-&gt;tag  =0;
    } else if (cmp_ret &lt; 0) {
        p-&gt;left = add_node(p-&gt;left, new, cmp);
    } else {
        p-&gt;right = add_node(p-&gt;right, new, cmp);
    }
    return p;
}</code></pre> 
<br>经过测试，自己实现的上述算法效率还可以，当然这里不该去比较效率，留下个思路即可，在没有库可用的情况下，也可以自己实现它。在现实中，特别是在软件工程中，还是使用现成的map比较好。 
<br> 
<br> 
<br>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6a5b0b9ca38e8ef23908c48dc91117a6/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">如何用JavaScript动态修改CSS样式表</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d594c392d840fafec077533d6b301a55/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">去掉linux文件中^M符号方法汇总</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>