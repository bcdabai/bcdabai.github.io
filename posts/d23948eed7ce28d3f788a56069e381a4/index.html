<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据结构——线性表（顺序实现） - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="数据结构——线性表（顺序实现）" />
<meta property="og:description" content="好好学习基础知识，出人头地就靠它了，内外兼修。(好吧，我现在内外都不行)写这篇文章的目的就是为了，巩固刚学完的线性表，个人能力有限，若有不当之处，望指出。
线性表 好了，扯完了，说正事：
1、定义
线性表是一种及其常用的并且最简单的一种数据结构。简单来说，线性表就是集合里的元素的有限排列。(在这里我把集合定义为具有相同属性的元素，会有些狭义)
在线性表中数据元素之间的关系是一对一的关系，即除了第一个和最后一个数据元素之外，其它数据元素都是首尾相接的(注意，这句话只适用大部分线性表，而不是全部。比如，循环链表逻辑层次上也是一种线性表(存储层次上属于链式存储)，但是把最后一个数据元素的尾指针指向了首位结点)[百度百科]
怎么说呢，毕竟数据结构毕竟是逻辑结构，逻辑上符合线性结构的特征即可，存储结构能实现就行。线性表的很重要！很重要！很重要！后面的栈，队列，串等都是基于线性表的基础上实现的，所以说一定要学好线性表
2、线性表的特点：
对于任意的的非空线性表或者线性结构有：
1、存在唯一一个被称为 ”第一个“的元素
2、存在唯一一个被称为 ”最后一个“的元素
3、出第一个元素之外，每一个元素都存在一个后继
4、除最后一个元素之外，每一个元素都存在一个前驱
3、基本操作
1、Create(*L)创建空表
2、InitEmpty(*L)初始化
3、getLength(*L)获取长度
4、Insert(*L)插入元素
5、Remove(*L)移除元素
6、IsEmpty(*L)空表检测
7、IsFulled(*L)表满检测(顺序表常用，链式表基本不用)
8、Delete(*L)删除表
9、getElemt(*L)获取元素
10、Traverse(*L)遍历输出所有元素
11、Clear(*L)清除所有元素
4 、实现 好了最麻烦的事情开始了，数据结构在计算机上的的映射。众所周知，线性表有两种实现方法，一种是顺序表，另一种是链式表，这两种结构实现最大的不同在于前者逻辑关系无需存储空间，而后者则需要用额外的空间(顺便记录一下，指针大小只由环境有关(严格意义上说和CPU的位数有关)本篇只实现顺序结构)。
1、顺序表：
先说一下概念：用一组地址连续的存储单元依次存储线性表的数据元素，这种存储结构的线性表称为顺序表。
很明显对于顺序表来说：逻辑上相邻的数据元素，物理次序也是相邻的。 特点：
对表中任意元素访问时间复杂度都为常数级。
尾部插入元素时间复杂度也为常量级。
下面是重点！！！
说明一下，讲解的时候实现语言为C，后续会贴上C&#43;&#43;和Python
实现：
敲~~~键盘，敲~~键盘！敲~~~键盘，敲~~键盘！
结构定义：　1 #define YWZLIST_INIT_SIZE 8 2 #define INC_SIZE 3 //空间增量的大小 3 4 typedef int ElemType; 5 typedef struct listnode 6 { 7 ElemType *base; 8 int capacity; //顺序表容量 9 int size; //表的大小 10 } YWZlist; 函数声明：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/d23948eed7ce28d3f788a56069e381a4/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-10-03T13:39:00+08:00" />
<meta property="article:modified_time" content="2019-10-03T13:39:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据结构——线性表（顺序实现）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="cnblogs_post_body" class="blogpost-body" style="font-size: 16px;"> 
 <p>　　　　好好学习基础知识，出人头地就靠它了，内外兼修。(好吧，我现在内外都不行)写这篇文章的目的就是为了，巩固刚学完的线性表，个人能力有限，若有不当之处，望指出。</p> 
 <h4><strong>线性表</strong></h4> 
 <p><strong>　　</strong>好了，扯完了，说正事：</p> 
 <p>　　<strong>1</strong>、定义</p> 
 <p>　　　　线性表是一种及其常用的并且最简单的一种数据结构。简单来说，线性表就是集合里的元素的有限排列。(在这里我把集合定义为具有相同属性的元素，会有些狭义)</p> 
 <p>　　在线性表中数据元素之间的关系是一对一的关系，即除了第一个和最后一个数据元素之外，其它数据元素都是首尾相接的(注意，这句话只适用大部分线性表，而不是全部。比如，循环链表逻辑层次上也是一种线性表(存储层次上属于链式存储)，但是把最后一个数据元素的尾指针指向了首位结点)<sup>[<a href="https://baike.baidu.com/item/%E7%BA%BF%E6%80%A7%E8%A1%A8/3228081?fr=aladdin" rel="nofollow noopener noreferrer" target="_blank">百度百科</a>]</sup></p> 
 <p>　　怎么说呢，毕竟数据结构毕竟是逻辑结构，逻辑上符合线性结构的特征即可，存储结构能实现就行。线性表的很重要！很重要！很重要！后面的栈，队列，串等都是基于线性表的基础上实现的，所以说一定要学好线性表</p> 
 <p>　　<strong>2</strong>、线性表的特点：</p> 
 <p>　　　　对于任意的的非空线性表或者线性结构有：</p> 
 <p>　　　　　　1、存在唯一一个被称为 ”第一个“的元素</p> 
 <p>　　　　　　2、存在唯一一个被称为 ”最后一个“的元素</p> 
 <p>　　　　　　3、出第一个元素之外，每一个元素都存在一个后继</p> 
 <p>　　　　　　4、除最后一个元素之外，每一个元素都存在一个前驱</p> 
 <p>　　<strong>3</strong>、基本操作</p> 
 <p>　　　　1、Create(*L)创建空表</p> 
 <p>　　　　2、InitEmpty(*L)初始化</p> 
 <p>　　　　3、getLength(*L)获取长度</p> 
 <p>　　　　4、Insert(*L)插入元素</p> 
 <p>　　　　5、Remove(*L)移除元素</p> 
 <p>　　　　6、IsEmpty(*L)空表检测</p> 
 <p>　　　　7、IsFulled(*L)表满检测(顺序表常用，链式表基本不用)</p> 
 <p>　　　　8、Delete(*L)删除表</p> 
 <p>　　　　9、getElemt(*L)获取元素</p> 
 <p>　　　 10、Traverse(*L)遍历输出所有元素</p> 
 <p>　　　 11、Clear(*L)清除所有元素</p> 
 <h5 class="configModuleBanner"> 　　<strong>4</strong> 、实现</h5> 
 <p>　　　　好了最麻烦的事情开始了，数据结构在计算机上的的映射。众所周知，线性表有两种实现方法，一种是顺序表，另一种是链式表，这两种结构实现最大的不同在于前者逻辑关系无需存储空间，而后者则需要用额外的空间(顺便记录一下，指针大小只由环境有关(严格意义上说和CPU的位数有关)本篇只实现顺序结构)。</p> 
 <p>　　　　1、顺序表：</p> 
 <p>　　　　　　先说一下概念：用一组地址连续的存储单元依次存储线性表的数据元素，这种存储结构的线性表称为顺序表。</p> 
 <p>　　　　很明显对于顺序表来说：逻辑上相邻的数据元素，物理次序也是相邻的。 </p> 
 <p>　　　　　　特点：</p> 
 <p>　　　　　　　　对表中任意元素访问时间复杂度都为常数级。</p> 
 <p>　　　　　　　　尾部插入元素时间复杂度也为常量级。</p> 
 <p><strong>　　下面是重点！！！</strong></p> 
 <p><strong>　　　　说明一下，</strong><strong>讲解的时候实现语言为C，后续会贴上C++和Python</strong></p> 
 <p><strong>　　　　　　</strong>实现：</p> 
 <p>　　　敲~~~键盘，敲~~键盘！敲~~~键盘，敲~~键盘！</p> 
 <p>　　结构定义：　　</p> 
 <div class="cnblogs_code"> 
  <pre><code class="has"> 1 #define YWZLIST_INIT_SIZE 8
 2 #define INC_SIZE 3 //空间增量的大小
 3 
 4 typedef int ElemType;
 5 typedef struct listnode
 6 {
 7     ElemType *base;
 8     int capacity; //顺序表容量
 9     int size;     //表的大小
10 } YWZlist;</code>
</pre> 
 </div> 
 <p>　　函数声明：</p> 
 <div class="cnblogs_code"> 
  <pre><code class="has"> 1 bool IsEmpty(YWZlist *list);                         //空表检测
 2 bool IsFull(YWZlist *list);                          //表满检测
 3 bool Inc(YWZlist *list);                             //增加顺序表的容量
 4 void InitSeqlist(YWZlist *list);                     //初始化顺序表
 5 void Push_back(YWZlist *list, ElemType x);           //在顺序表的末尾插入元素
 6 void Push_front(YWZlist *list, ElemType x);          //在顺序表的头部插入元素
 7 void Show_list(YWZlist *list);                       //显示顺序表中的元素
 8 void Pop_back(YWZlist *list);                        //删除顺序表最后一个元素
 9 void Pop_front(YWZlist *list);                       //删除顺序表第一个元素
10 void Insert_pos(YWZlist *list, int pos, ElemType x); //在顺序表的选定位置上插入数据
11 int Find(YWZlist *list, ElemType key);               //在顺序表中查找元素key的下标
12 int Length(YWZlist *list);                           //求顺序表的长度
13 void Delete_pos(YWZlist *list, int pos);             //删除顺序表中特定位置的数据元素
14 void Delete_val(YWZlist *list, int key);             //删除顺序表中值为key的数据元素
15 void Sort(YWZlist *list);                            //冒泡排序
16 void Reverse(YWZlist *list);                         //逆置顺序列表
17 void Clear(YWZlist *list);                           //清除顺序表中的所有元素
18 void Destroy(YWZlist *list);                         //摧毁顺序表
19 void Merge(YWZlist *lt, YWZlist *la, YWZlist *lb);   //合并两个顺序列表</code>
</pre> 
 </div> 
 <p>　　　　上面一共19个函数，空表和表满函数就不写了</p> 
 <p>　　1、初始化：</p> 
 <p>　　　　思路很明确，先开辟一个最小的数组空间，给capacity赋值</p> 
 <div class="cnblogs_code"> 
  <div id="cnblogs_code_open_29d7be95-7fb5-49ca-abc0-226ad398a206" class="cnblogs_code_hide"> 
   <pre><code class="has">void InitYWZlist(YWZlist *list) //初始化顺序表
{
    //开辟初始空间，开辟失败返回空
    list-&gt;base = (ElemType *)malloc(sizeof(ElemType) * YWZLIST_INIT_SIZE);

    if (list-&gt;base == NULL)
    {
        printf("内存不足！\n");
        return;
    }

    list-&gt;capacity = YWZLIST_INIT_SIZE - 1;
    list-&gt;size = -1;
}</code>
</pre> 
  </div> 
  <span class="cnblogs_code_collapse">初始化顺序表</span> 
 </div> 
 <p>　　2、扩容：</p> 
 <p>　　　　顺序表扩容不比链表，顺序表需要重新开劈空间需要用到realloc函数，来看一下函数原型</p> 
 <div class="cnblogs_Highlighter"> 
  <pre><code class="has">　　　　_CRTIMP void* __cdecl __MINGW_NOTHROW	realloc	(void*, size_t);　　//传进去的是要改变大小的指针
</code>
</pre> 
 </div> 
 <p>　　　　嗯，两个参数，一个指针，一个大小，由于要新开辟一块空间，所以我们不能用原指针来指向新开辟的空间，我i们需要一个新的之指针，下一步当然是计算需要多少空间，这就和malloc函数一样了，自己琢磨琢磨，记得改变capacity的值，贴代码：</p> 
 <div class="cnblogs_code"> 
  <div id="cnblogs_code_open_b991143e-e6ee-406d-9566-cd47eedfdf5b" class="cnblogs_code_hide"> 
   <pre><code class="has">bool Inc(YWZlist *list)
{
    //重新分配内存空间
    ElemType *newspace = (ElemType *)realloc(list, sizeof(ElemType) * (list-&gt;capacity + INC_SIZE));
    if (newspace == NULL)
    {
        printf("内存空间已满，无法再分配内存空间！\n");
        return false;
    }

    list-&gt;base = newspace;
    list-&gt;capacity += INC_SIZE;

    return true;
}</code>
</pre> 
  </div> 
  <span class="cnblogs_code_collapse">扩容</span> 
 </div> 
 <p>　　　3、尾部插入：</p> 
 <p>　　　　　顺序表的尾部插入无比的简单，因为物理上相邻，所以访问最后一个元素的时间复杂度为常量级。插入元素我们不仅需要考虑表是否表满，同时我们还需要检测是否可以开辟新的空间。只有当表满且内存不足才能返回异常。</p> 
 <div class="cnblogs_code"> 
  <div id="cnblogs_code_open_0bb40f03-69d8-41fd-913e-135b6c0f9550" class="cnblogs_code_hide"> 
   <pre><code class="has">void Push_back(YWZlist *list, ElemType x)
{
    //当表满且无法扩容
    if (IsFull(list) &amp;&amp; !Inc(list))
    {
        printf("顺序表容量已满，无法再在表尾继续插入新元素！\n");
        return;
    }

    list-&gt;base[list-&gt;size] = x;
    list-&gt;size++;
}</code>
</pre> 
  </div> 
  <span class="cnblogs_code_collapse">尾部插入</span> 
 </div> 
 <p>　　4、头部插入</p> 
 <p>　　　　　这个就麻烦了，因为物理相邻，所以我们得把所有元素都向后移。(这也是链式表出现的原因之一)当然啦，打印错误的条件和尾部插入相同。</p> 
 <div class="cnblogs_code"> 
  <div id="cnblogs_code_open_b919df8f-399e-4ba5-b388-9718068ab439" class="cnblogs_code_hide"> 
   <pre><code class="has">void Push_front(YWZlist *list, ElemType x)
{
  if (IsFull(list) &amp;&amp; !Inc(list))
  {
    printf("顺序表容量已满，无法再在表尾继续插入新元素！\n");
    return;
  }

  for (int i = list-&gt;size; i &gt; 0; i--)
  {
    list-&gt;base[i] = list-&gt;base[i - 1];
  }
  list-&gt;base[0] = x;
  list-&gt;size++;
}</code>
</pre> 
  </div> 
  <span class="cnblogs_code_collapse">头部插入</span> 
 </div> 
 <p>　　5、第i个索引插入</p> 
 <p>　　　　说完尾部和头部，我们来类推一下第i个元素删除的。</p> 
 <p>　　　　第一步，都不用想肯定是先找到第i个元素，</p> 
 <p>　　　　第二步，将n-i+1个元素个元素向后移动，</p> 
 <p>　　　　第三步，插入元素</p> 
 <p>　　　　第四步，size++</p> 
 <p>　　按着这个思路贴上代码</p> 
 <div class="cnblogs_code"> 
  <div id="cnblogs_code_open_d628982a-0545-475f-bf0c-fd45f430f376" class="cnblogs_code_hide"> 
   <pre><code class="has">void Insert_pos(YWZlist *list, int pos, ElemType x) 
{
  if (pos &lt; 0 || pos &gt; list-&gt;size)
  {
    printf("插入位置不合法，无法插入元素！\n");
    return;
  }
  if (list-&gt;size &gt;= list-&gt;capacity &amp;&amp; !Inc(list))
  {
    printf("顺序表容量已满，无法在插入新的元素！\n");
    return;
  }
  for (int i = list-&gt;size; i &gt; pos; i--)
  {
    list-&gt;base[i] = list-&gt;base[i - 1];
  }
  list-&gt;base[pos] = x;
  list-&gt;size++;
}</code>
</pre> 
  </div> 
  <span class="cnblogs_code_collapse">任意位置插入</span> 
 </div> 
 <p>　　6、遍历</p> 
 <p>　　　　这个直接贴代码，太简单了，不做作说明</p> 
 <div class="cnblogs_code"> 
  <div id="cnblogs_code_open_0f074559-a04c-4bca-b9f5-332eab682535" class="cnblogs_code_hide"> 
   <pre><code class="has">void Show_list(YWZlist *list)
{
  for (int i = 0; i &lt; list-&gt;size; i++)
  {
    printf("%d ", list-&gt;base[i]);
  }
  printf("\n");
}</code>
</pre> 
  </div> 
  <span class="cnblogs_code_collapse">遍历</span> 
 </div> 
 <p>　　7、尾部删除</p> 
 <p>　　　　删除其实没有想象中的那么难，就是把size--，因为你下次插入就是直接覆盖了，和原先的值没有任何关系。当然你得先判断一下表是否为空</p> 
 <div class="cnblogs_code"> 
  <div id="cnblogs_code_open_a9ae6438-7fe1-45a9-a2cd-8f2a49ee166a" class="cnblogs_code_hide"> 
   <pre><code class="has">void Pop_back(YWZlist *list) 
{
  if (list-&gt;size == 0)
  {
    printf("顺序表已空，无法再在表尾删除元素！\n");
    return;
  }
  list-&gt;size--;
}</code>
</pre> 
  </div> 
  <span class="cnblogs_code_collapse">尾部删除</span> 
 </div> 
 <p>　　8、头部删除</p> 
 <p>　　　　个人觉得无论是链表还是顺序表，只要会了插入，删除类推一下就会了。打个比方顺序表的头部插入是，一个个往后推，那么删除就是一个个往前移。当然一个是判断表满一个是判断表空</p> 
 <div class="cnblogs_code"> 
  <div id="cnblogs_code_open_04f1dca9-d4d7-4cbc-811e-5934071d609c" class="cnblogs_code_hide"> 
   <pre><code class="has">void Pop_front(YWZlist *list) 
{
  if (list-&gt;size == 0)
  {
    printf("顺序表已空，无法再在表头删除元素！\n");
    return;
  }
  for (int i = 0; i &lt; list-&gt;size - 1; i++)
  {
    list-&gt;base[i] = list-&gt;base[i + 1];
  }
  list-&gt;size--;
}</code>
</pre> 
  </div> 
  <span class="cnblogs_code_collapse">头部删除</span> 
 </div> 
 <p>　　9、指定位置删除</p> 
 <p>　　　　类推吧，</p> 
 <p>　　　　第一步，找到第i个元素</p> 
 <p>　　　　第二部，将从第i+1到第n个元素向前移动1</p> 
 <p>　　　　第三步，size--；</p> 
 <p>　　　是不是和插入很像，所以有些代码是很像的</p> 
 <div class="cnblogs_code"> 
  <div id="cnblogs_code_open_4546d8fc-323e-4bcd-99a4-225d8555bf7b" class="cnblogs_code_hide"> 
   <pre><code class="has">void Delete_pos(YWZlist *list, int pos) 
{
  if (pos &lt; 0 || pos &gt;= list-&gt;size)
  {
    printf("删除位置不合法，无法删除元素！\n");
    return;
  }
  for (int i = pos; i &lt; list-&gt;size - 1; i++)
  {
    list-&gt;base[i] = list-&gt;base[i + 1];
  }
  list-&gt;size--;
}</code>
</pre> 
  </div> 
  <span class="cnblogs_code_collapse">删除指定位置的元素</span> 
 </div> 
 <p>　　10、按元素删除</p> 
 <p>　　　　这个是我觉得，一般人找东西，都只记得叫什么名字而不是第几个，所以写了一个按元素删除的。其实思路和指定位置删除一样找到最前端的一样的元素后插入即可(有bug，当表中存在重复元素的时候，只会添加到最前面那个)</p> 
 <div class="cnblogs_code"> 
  <div id="cnblogs_code_open_2e8d8ea3-7e93-43a8-9f45-cbd46c6e3e87" class="cnblogs_code_hide"> 
   <pre><code class="has">void Delete_val(YWZlist *list, int key) //删除顺序表中值为key的数据元素
{
  int pos = Find(list, key);
  if (pos == -1)
  {
    printf("顺序表中没有这个元素！\n");
    return;
  }
  Delete_pos(list, pos);
}</code>
</pre> 
  </div> 
  <span class="cnblogs_code_collapse">按元素删除</span> 
 </div> 
 <p>　　11、元素查找</p> 
 <p>　　　　不打算说，贴代码</p> 
 <div class="cnblogs_code"> 
  <div id="cnblogs_code_open_3410873f-8488-4c8e-93af-b6d36e14266a" class="cnblogs_code_hide"> 
   <pre><code class="has">int Find(YWZlist *list, ElemType key) //在顺序表中查找元素key的下标
{
  for (int i = 0; i &lt; list-&gt;size; i++)
  {
    if (list-&gt;base[i] == key)
      return i;
  }
  return -1;
}</code>
</pre> 
  </div> 
  <span class="cnblogs_code_collapse">元素查找</span> 
 </div> 
 <p>　　12、返回长度</p> 
 <p>　　　　size中记录了表长，直接return就好了</p> 
 <div class="cnblogs_code"> 
  <div id="cnblogs_code_open_eb1d750c-c8ae-44dd-abea-ff392a09d181" class="cnblogs_code_hide"> 
   <pre><code class="has">int Length(YWZlist *list) 
{
  return list-&gt;size;
}</code>
</pre> 
  </div> 
  <span class="cnblogs_code_collapse">表长</span> 
 </div> 
 <p>　　13、排序</p> 
 <p>　　　　<a href="https://baike.baidu.com/item/%E7%BA%BF%E6%80%A7%E8%A1%A8/3228081?fr=aladdin" rel="nofollow noopener noreferrer" target="_blank">冒泡</a>，不在这里做说明，自己去看。其实可以直接调用qsort函数的写一个compare函数就行了</p> 
 <div class="cnblogs_code"> 
  <div id="cnblogs_code_open_283e1ab1-2652-49cd-8a2b-4036c61d52f0" class="cnblogs_code_hide"> 
   <pre><code class="has">void Sort(YWZlist *list) 
{
  for (int i = 0; i &lt; list-&gt;size - 1; i++)
  { //排序的趟数(例如5个数据需要比较4趟)
    for (int j = 0; j &lt; list-&gt;size - 1 - i; j++)
    { //每一趟比较中的比较次数(例如5个数据在第0趟需要比较4次)
      if (list-&gt;base[j] &gt; list-&gt;base[j + 1])
      {
        ElemType temp = list-&gt;base[j];
        list-&gt;base[j] = list-&gt;base[j + 1];
        list-&gt;base[j + 1] = temp;
      }
    }
  }
}</code>
</pre> 
  </div> 
  <span class="cnblogs_code_collapse">冒泡排序</span> 
 </div> 
 <p>　　14、顺序表逆序</p> 
 <p>　　要么写个for二分表只执行到n/2，要么写个while，大小指针(不是真正意义上的指针)小指针大于大指针的时候停止</p> 
 <div class="cnblogs_code"> 
  <div id="cnblogs_code_open_3da9754d-4b6c-4bd8-9a1d-1c4e0ed6efc5" class="cnblogs_code_hide"> 
   <pre><code class="has">void Reverse(YWZlist *list) //逆置顺序列表
{
  if (list-&gt;size == 0 || list-&gt;size == 1)
  {
    return;
  }
  int low = 0, high = list-&gt;size - 1;
  while (low &lt; high)
  {
    ElemType temp = list-&gt;base[low];
    list-&gt;base[low] = list-&gt;base[high];
    list-&gt;base[high] = temp;
    low++;
    high--;
  }
}</code>
</pre> 
  </div> 
  <span class="cnblogs_code_collapse">顺序表逆序</span> 
 </div> 
 <p>　　15、清空表</p> 
 <p>　　无比简单，就一句size = -1；</p> 
 <div class="cnblogs_code"> 
  <div id="cnblogs_code_open_16b19632-d986-4919-a0fa-8976271c249e" class="cnblogs_code_hide"> 
   <pre><code class="has">void Clear(YWZlist *list) 
{
  list-&gt;size = 0;
}</code>
</pre> 
  </div> 
  <span class="cnblogs_code_collapse">清除顺序表中的所有元素</span> 
 </div> 
 <p>　　16、删除表</p> 
 <p>　　free完毕之后，将所有成员重置</p> 
 <div class="cnblogs_code"> 
  <div id="cnblogs_code_open_ce2fbbf1-2d40-4be5-98f4-ab71782cf317" class="cnblogs_code_hide"> 
   <pre><code class="has">void Destroy(YWZlist *list) 
{
  free(list-&gt;base);
  list-&gt;base = NULL;
  list-&gt;capacity = 0;
  list-&gt;size = 0;
}</code>
</pre> 
  </div> 
  <span class="cnblogs_code_collapse">摧毁顺序表</span> 
 </div> 
 <p>　　17、合并两个顺序表</p> 
 <p>　　这个就比较麻烦了</p> 
 <p>　　第一步：开辟足够的空间</p> 
 <p>　　第二步：让La与Lb比较，谁大/小存谁，直到一个表结束</p> 
 <p>　　第三步：将余下的元素都，存入表Lc中。</p> 
 <p>　　第四步：计算表长。</p> 
 <div class="cnblogs_code"> 
  <div id="cnblogs_code_open_68a9e0de-d30f-4a93-9fb7-c71aeaf7b443" class="cnblogs_code_hide"> 
   <pre><code class="has">void Merge(YWZlist *lt, YWZlist *la, YWZlist *lb) 
{
  lt-&gt;capacity = la-&gt;size + lb-&gt;size;
  lt-&gt;base = (ElemType *)malloc(sizeof(ElemType) * lt-&gt;capacity);
  //assert(lt-&gt;base != NULL);
  int ia = 0, ib = 0, ic = 0;
  while (ia &lt; la-&gt;size &amp;&amp; ib &lt; lb-&gt;size)
  {
    if (la-&gt;base[ia] &lt; lb-&gt;base[ib])
    {
      lt-&gt;base[ic++] = la-&gt;base[ia++];
    }
    else
    {
      lt-&gt;base[ic++] = lb-&gt;base[ib++];
    }
  }
  while (ia &lt; la-&gt;size)
  {
    lt-&gt;base[ic++] = la-&gt;base[ia++];
  }
  while (ib &lt; lb-&gt;size)
  {
    lt-&gt;base[ic++] = lb-&gt;base[ib++];
  }
  lt-&gt;size = la-&gt;size + lb-&gt;size;
  Show_list(lt);
}</code>
</pre> 
  </div> 
  <span class="cnblogs_code_collapse">合并两个顺序列表</span> 
 </div> 
 <p>　　本篇只实现顺序表</p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/afd0a3221408b725078c58f45afdf461/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">[C]编译器对char数组声明的一个行为</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/430bd4dc1adf8985c17944a5eb5a6cff/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Idea2019的安装及其相关配置</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>