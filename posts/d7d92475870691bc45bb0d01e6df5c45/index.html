<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>语法：Python与C&#43;&#43;对比 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="语法：Python与C&#43;&#43;对比" />
<meta property="og:description" content="目录
一、概述
二、语句
三、函数
四、数据结构
五、类
一、概述 Python和C&#43;&#43;都是面向对象的。
Python和C&#43;&#43;的区别：
Python是脚本语言，脚本语言不需要编译，直接解释执行，由解释器来负责解释。程序代码即是脚本程序，也是可执行文件，只需要编写-运行。C&#43;&#43;是编译型编程语言，需要编译成二进制代码，以可执行文件形式运行，需要经过编写-编译-链接-运行的过程。 从语法角度来说：Python更加灵活；C&#43;&#43;逻辑更加清晰。
Python C&#43;&#43; import cmath
导入模块，每一个.py文件都可以认为是一个模块。Python中导入的模块可以是类的定义，函数的定义。
#include
引入头文件，头文件为类或函数的声明。
C&#43;&#43;支持分离式编译，对源文件分别编译成目标文件，再链接生成可执行文件。通过头文件把源文件关联起来。
在python程序中直接添加sys.path，即import时寻找模块的路径 在cmakelist中设置include_directories()，即include时寻找相应头文件的路径
在程序中添加单元测试 if __name__ == &#34;__main__&#34;:
当模块被作为脚本直接运行时，执行之后的程序块；
当模块被其他模块导入时，不执行之后的程序块。
非常方便，可以直接将单元测试脚本写在if __name__ == &#34;__main__&#34;:后，保证程序功能正常
C&#43;&#43;需要有一个 main 函数来作为程序的入口。如果需要单元测试需要单独写带有main函数的源文件。数据类型决定数据所占内存空间的大小、布局方式、该空间能存储的值的范围、以及数据能参与的运算对象 一切皆对象（数据类型、函数、类都是对象)。对象包含identity（Python中即为对象的内存地址，一旦创建不再改变）、类型信息、值、引用计数（用于记录当前有多少个变量在引用这个对象。一旦引用计数器为0，那么该对象就会被系统自动回收）、。
可参见：Python 中的对象概述 - 知乎
一块能存储数据并具有某种类型的内存空间变量 在python中就是个name，Names refer to objects. Names are introduced by name binding operations.
没有类型信息，是通用的（增加python的灵活性），引用一个对象。
(即变量是对象内存地址的引用）
可参见：python中的变量、对象和引用_ColourfulPanda的博客-CSDN博客_python 引用对象
命了名的对象，即具名的、存储数据并具有某种类型的内存空间
（即变量有一个名字，并在内存中占据一定的存储单元，在该存储单元中存放变量的值）
引用引用即别名，为已经存在的对象所起的另外一个名字，引用自身不是对象指针指针用来存放某个对象的地址，指针自身也是一个对象= name binding，名字绑定，变量存储对象的引用
对象分为可变对象和不可变对象，进行name binding时内存空间示意图可参见：Python中的变量、对象 - 汉尼拔草 - 博客园
把值赋给变量(对象） 二、基本操作 Python" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/d7d92475870691bc45bb0d01e6df5c45/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-04-12T04:37:38+08:00" />
<meta property="article:modified_time" content="2022-04-12T04:37:38+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">语法：Python与C&#43;&#43;对比</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E6%A6%82%E8%BF%B0-toc" style="margin-left:0px;"><a href="#%E6%A6%82%E8%BF%B0" rel="nofollow">一、概述</a></p> 
<p id="%E8%AF%AD%E5%8F%A5%EF%BC%9A-toc" style="margin-left:0px;"><a href="#%E8%AF%AD%E5%8F%A5%EF%BC%9A" rel="nofollow">二、语句</a></p> 
<p id="%E5%87%BD%E6%95%B0%EF%BC%9A-toc" style="margin-left:0px;"><a href="#%E5%87%BD%E6%95%B0%EF%BC%9A" rel="nofollow">三、函数</a></p> 
<p id="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-toc" style="margin-left:0px;"><a href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84" rel="nofollow">四、数据结构</a></p> 
<p id="%E7%B1%BB%EF%BC%9A-toc" style="margin-left:0px;"><a href="#%E7%B1%BB%EF%BC%9A" rel="nofollow">五、类</a></p> 
<hr id="hr-toc"> 
<h2 id="%E6%A6%82%E8%BF%B0">一、概述</h2> 
<p>Python和C++都是面向对象的。</p> 
<blockquote> 
 <p>Python和C++的区别：</p> 
 <ul><li>Python是脚本语言，脚本语言不需要编译，直接解释执行，由解释器来负责解释。程序代码即是脚本程序，也是可执行文件，只需要编写-运行。</li><li>C++是编译型编程语言，需要编译成二进制代码，以可执行文件形式运行，需要经过编写-编译-链接-运行的过程。             </li></ul> 
</blockquote> 
<p>从语法角度来说：Python更加灵活；C++逻辑更加清晰。</p> 
<table border="1" cellpadding="1" cellspacing="1"><tbody><tr><td style="width:126px;"></td><td style="width:414px;">Python </td><td style="width:324px;">C++</td></tr><tr><td style="width:126px;"></td><td style="width:414px;"> <p>import cmath</p> <p>导入模块，每一个.py文件都可以认为是一个模块。Python中导入的模块可以是类的定义，函数的定义。</p> </td><td style="width:324px;"> <p>#include</p> <p>引入头文件，头文件为类或函数的声明。</p> <p>C++支持分离式编译，对源文件分别编译成目标文件，再链接生成可执行文件。通过头文件把源文件关联起来。</p> </td></tr><tr><td style="width:126px;"></td><td style="width:414px;">在python程序中直接添加sys.path，即import时寻找模块的路径</td><td style="width:324px;"> <p>在cmakelist中设置include_directories()，即include时寻找相应头文件的路径</p> <p></p> </td></tr><tr><td style="width:126px;">在程序中添加单元测试</td><td style="width:414px;"> <p>if __name__ == "__main__":</p> <p>当模块被作为脚本直接运行时，执行之后的程序块；</p> <p>当模块被其他模块导入时，不执行之后的程序块。</p> <p>非常方便，可以直接将单元测试脚本写在if __name__ == "__main__":后，保证程序功能正常</p> </td><td style="width:324px;">C++需要有一个 main 函数来作为程序的入口。如果需要单元测试需要单独写带有main函数的源文件。</td></tr><tr><td style="width:126px;">数据类型</td><td style="width:414px;"></td><td style="width:324px;">决定数据所占内存空间的大小、布局方式、该空间能存储的值的范围、以及数据能参与的运算</td></tr><tr><td style="width:126px;">对象</td><td style="width:414px;"> <p>一切皆对象（数据类型、函数、类都是对象)。对象包含identity（Python中即为对象的内存地址，一旦创建不再改变）、类型信息、值、引用计数（用于记录当前有多少个变量在引用这个对象。一旦引用计数器为0，那么该对象就会被系统自动回收）、。</p> <p>可参见：<a href="https://zhuanlan.zhihu.com/p/21537883" rel="nofollow" title="Python 中的对象概述 - 知乎">Python 中的对象概述 - 知乎</a></p> </td><td style="width:324px;">一块能存储数据并具有某种类型的内存空间</td></tr><tr><td style="width:126px;">变量</td><td style="width:414px;"> <p>在python中就是个name，<em>Names</em> refer to objects. Names are introduced by name binding operations.</p> <p>没有类型信息，是通用的（增加python的灵活性），引用一个对象。</p> <p>(即变量是对象内存地址的引用）</p> <p>可参见：<a href="https://blog.csdn.net/qq_34730418/article/details/79412642" title="python中的变量、对象和引用_ColourfulPanda的博客-CSDN博客_python 引用对象">python中的变量、对象和引用_ColourfulPanda的博客-CSDN博客_python 引用对象</a></p> </td><td style="width:324px;"> <p>命了名的对象，即具名的、存储数据并具有某种类型的内存空间</p> <p>（即变量有一个名字，并在内存中占据一定的存储单元，在该存储单元中存放变量的值）</p> </td></tr><tr><td style="width:126px;">引用</td><td style="width:414px;"></td><td style="width:324px;">引用即别名，为已经存在的对象所起的另外一个名字，引用自身不是对象</td></tr><tr><td style="width:126px;">指针</td><td style="width:414px;"></td><td style="width:324px;">指针用来存放某个对象的地址，指针自身也是一个对象</td></tr><tr><td style="width:126px;">=</td><td style="width:414px;"> <p>name binding，名字绑定，变量存储对象的引用</p> <p>对象分为可变对象和不可变对象，进行name binding时内存空间示意图可参见：<a href="https://www.cnblogs.com/peanutk/p/10085310.html" rel="nofollow" title="Python中的变量、对象 - 汉尼拔草 - 博客园">Python中的变量、对象 - 汉尼拔草 - 博客园</a></p> </td><td style="width:324px;">把值赋给变量(对象）</td></tr></tbody></table> 
<h2>二、基本操作</h2> 
<table border="1" cellpadding="1" cellspacing="1"><tbody><tr><td style="width:188px;"></td><td style="width:238px;"> <p>Python</p> </td><td style="width:263px;"> <p>C++</p> </td></tr><tr><td style="width:188px;">int最大整型\最小整型</td><td style="width:238px;"> <p>O</p> <p>备注：sys.maxsize \ -sys.maxsize-1 (跟计算机相关，可能是32位，也可能是64位)</p> <p>sys.maxint \ -sys.maxint-1在python2中支持，在python3中不支持了</p> </td><td style="width:263px;"> <p>INT_MAX  \  (4Bytes，即32bits的最大值2^31-1)</p> <p>INT_MIN  (-2^31)</p> </td></tr><tr><td style="width:188px;">float最大值\最小值</td><td style="width:238px;"> <p>float('inf')  \</p> <p>float('-inf')</p> </td><td style="width:263px;"> <p>FLT_MAX  \</p> <p>FLT_MIN</p> </td></tr><tr><td style="width:188px;">两字符相减</td><td style="width:238px;">字符不能直接相减，必须先用ord()函数返回字符串的ASCII值，才能相见</td><td style="width:263px;">字符可以直接相减</td></tr><tr><td style="width:188px;">/</td><td style="width:238px;">两个整型做“/”运算，得到浮点型的结果</td><td style="width:263px;">两个整型做“/”运算，得到整型，相当于除完取int()，小数部分截断，<strong>即向0取整</strong></td></tr><tr><td style="width:188px;"></td><td style="width:238px;"> <p>// 地板除，即<strong>向负无穷取整</strong></p> <p>8//3 结果为2</p> <p>-8//3 结果为-3</p> </td><td style="width:263px;"></td></tr><tr><td style="width:188px;"><strong>%</strong></td><td style="width:238px;"> <p><strong>% 取模（modulus）</strong></p> <p><strong>-10%3 结果为2</strong></p> <p><strong>-90%8结果为6</strong></p> </td><td style="width:263px;"> <p><strong>% 取余</strong></p> <p><strong>-10%3 结果为-1</strong></p> <p><strong>-90%8结果为-2</strong></p> </td></tr></tbody></table> 
<blockquote> 
 <p>PS:</p> 
 <p><strong>取模（Modulus ） V.S. 取余（Remainder）</strong></p> 
 <p>对于整型数a，b来说，取模运算或者求余运算的过程都是：</p> 
 <p>1. 求 整数商： c = a/b;  （把这里的/理解成数学意义的除。求模运算和求余运算在这一步不同：<strong>取模运算在本步骤计算c的值时，向负无穷方向舍入（向下取整）；取余运算在本步骤取c的值时，向0 方向截断；</strong>）</p> 
 <p>2. 计算模或者余数： r = a - c*b （本步骤取模和取余相同）</p> 
 <p>以python实现为例，取模和取余代码区别为：</p> 
 <pre><code># 取模，Python中可直接用%，计算模，r = a % b
def mod(a, b):    
    c = a // b
    r = a - c * b
    return r

# 取余 
def rem(a, b):
    c = int(a / b)
    r = a - c * b
    return r</code></pre> 
 <p><a href="https://www.cnblogs.com/tiffanyfu/p/12673327.html" rel="nofollow" title="Python中的取模运算和取余运算 - Tiffany,fu - 博客园">Python中的取模运算和取余运算 - Tiffany,fu - 博客园</a></p> 
 <p><strong>符号%在C++和Python中意义不同</strong></p> 
 <p>对于%符号，在上面第1步中：</p> 
 <p>C++使用的a/b （是0取整），所以最终C++中%实现的是取余；</p> 
 <p>python使用的是a//b（是向负无穷大取整），所以python中%实现的是取模。</p> 
</blockquote> 
<h2 id="%E8%AF%AD%E5%8F%A5%EF%BC%9A">三、控制流</h2> 
<table border="1" cellpadding="1" cellspacing="1"><tbody><tr><td style="width:106px;"></td><td style="width:387px;">Python</td><td style="width:300px;">C++</td></tr><tr><td style="width:106px;">if</td><td style="width:387px;"> <p>if condition1:<br>     statement1<br> elif condition2:<br>     statement2<br> else:<br>     statement</p> <p>在if , elif, else中只要匹配上一个，后面的条件和代码块都不再执行，即便后面的elif条件也能匹配上。</p> </td><td style="width:300px;"> <p>if (condition1){<!-- --><br>     statement1;</p> <p>}<br> else if (condition2){<!-- --><br>     statement2;</p> <p>}<br> else (condition3){<!-- --><br>     statement3;</p> <p>}</p> </td></tr><tr><td style="width:106px;">三元运算符</td><td style="width:387px;">target = a if condition else b</td><td style="width:300px;">target= condition?a:b;</td></tr><tr><td style="width:106px;">for循环</td><td style="width:387px;"> <p>for item in iterable:<br>     statement</p> <p>iterable的可以是列表Occupationt=['teacher','student','driver','governer']、元组(1,2,3)、字典{"name":'Arnold',"Salary":10000}.items()、集合对象{100，‘ab’}、字符串 ‘abcdefg’。</p> <p>for i in range(0,10):<br>     print(i)</p> </td><td style="width:300px;"> <p>for (init-state;condition;expression){<!-- --><br>     statement;</p> <p>}</p> <p>C++范围for语句实现类似于Python的遍历序列：</p> <p>for (auto item : iterable){<!-- --><br>     statement;</p> <p>}</p> <p>iterable为一个序列，可以是数组、vector、string, 必须拥有能返回迭代器begin和end的成员。 </p> <p>for (i=0;i&lt;10;i++){<!-- --><br>     print(i);</p> <p>}</p> <p></p> </td></tr><tr><td style="width:106px;">while循环</td><td style="width:387px;">while condition:<br>     statement</td><td style="width:300px;"> <p>while (condition){<!-- --><br>     statement;</p> <p>}</p> </td></tr><tr><td style="width:106px;">switch</td><td style="width:387px;">O</td><td style="width:300px;"> <p>switch(condition){<!-- --></p> <p>        case(constant-expression1):</p> <p>                statement1;</p> <p>        case(constant-expression2):</p> <p>                statement2;</p> <p>                break;</p> <p>        case(constant-expression3):</p> <p>                statement3;</p> <p>                break;</p> <p>        default:</p> <p>                statement3;</p> <p>}</p> <p>判断满足条件的case后，后面的语句依次执行（不管后面的case是不是能匹配上），直到遇到break。在上面例子中，如果匹配了constant-expression1，则statement1和statement2都会执行。</p> </td></tr><tr><td style="width:106px;"></td><td style="width:387px;"></td><td style="width:300px;"></td></tr></tbody></table> 
<blockquote> 
 <p><strong>总结：</strong></p> 
 <p>1. Condition书写格式：</p> 
 <ul><li>在if, for，while后面的条件，Python直接写；</li><li>C++需要把条件写在括号（）内。</li></ul> 
 <p>2. 代码块：</p> 
 <ul><li>Python使用冒号：指出接下来是一个代码块，并将代码块中的每行都缩进相同的空格（悬垂的格式）；</li><li>C++ 用{}表示代码块；</li></ul> 
 <p>3. 作用域：</p> 
 <ul><li>Python中if, for, while的代码块不单独创建局部作用域，即在其中创建的变量在该代码块之外也可以使用；</li><li>C++在if, for, while后的代码块中创建局部作用域，在其中创建的变量在该代码块之外不可见</li></ul> 
</blockquote> 
<h2 id="%E5%87%BD%E6%95%B0%EF%BC%9A">四、函数</h2> 
<table border="1" cellpadding="1" cellspacing="1"><tbody><tr><td style="width:106px;"></td><td style="width:364px;">Python</td><td style="width:210px;">C++</td></tr><tr><td style="width:126px;">函数传参</td><td style="width:364px;"> <p>传对象引用（pass by object reference): 传递的是对象的内存地址的引用；</p> <p>实质与python的=意义相同。</p> </td><td style="width:210px;"> <p>传值(pass by value)：把实参的实际值赋值给函数的形参。在函数内修改形参，函数外的实参不改变。</p> <p>传引用(pass by refrence)：把实参的引用赋值给形参。在函数内修改形参，函数外的实参随之变化。</p> </td></tr><tr><td style="width:126px;"> <p>函数内定义函数</p> <p>（嵌套函数）</p> </td><td style="width:364px;"> <p>python的函数也是对象，因此可以将函数作为参数传递、可以将函数作为返回、可以将函数放入结构体中（如函数放入数组中）、可以在函数中定义函数；</p> <p>def outer():</p> <p>    x=5</p> <p>   def inner():</p> <p>         y=x+3   #内函数在自己作用域内查找局部变量失败后，会进一步向上一层作用域里查找。</p> <p>         print(y)</p> <p>    return inner  #闭包:内函数体内引用到外函数中定义的变量，return返回内函数的引用时把内函数和外部引用变量打包成整体返回， 这里inner函数和外部变量x组成闭包</p> <p></p> </td><td style="width:210px;"> <p>不能在函数中定义函数，需要使用函数对象或者匿名函数实现需求</p> <p>void foo(){<!-- --></p> <p>    //function object</p> <p>    class InnerFunction{<!-- --></p> <p>        public:</p> <p>            void operator()(){<!-- --></p> <p>                 std::cout&lt;&lt;"inner function object"&lt;</p> <p>            }</p> <p>    };</p> <p>    InnerFunction innerfunction;</p> <p>    innerfunction();</p> <p></p> <p>    //lambda expression</p> <p>    auto lambdafunc=[=]()-&gt;void{<!-- --></p> <p>        std::cout&lt;&lt;"inner lambda function"&lt;</p> <p>    }</p> <p>    lambdafunc();</p> <p>}</p> <p></p> </td></tr><tr><td style="width:126px;">装饰器</td><td style="width:364px;"> <p>用于扩展函数功能：</p> <pre><code class="language-python">def executetime(func):
   def wrapper(*args, **kwargs):
        time1=time.time()
        func(*args, **kwargs)
        time2=time.time()
        delta_t=time2-time1
        print('excecute_time is {}'.format(delta_t))
   return wrapper

@executetime
def myfunc(num):
    time.sleep(num)

#调用时：
myfunc(5)</code></pre> </td><td style="width:210px;">O</td></tr><tr><td style="width:126px;">生成器</td><td style="width:364px;"> <p>生成器是包含yield语句的函数，是使用普通函数语法定义的迭代器。</p> <p>当生成器被调用时不会执行函数体内的代码，而是返回一个迭代器。</p> <p>每次使用next()请求值时都执行生成器的代码，直到遇到yield或return，每次遇到 yield 时函数会暂停并保存当前所有的运行信息，并返回 yield 的值。在下一次执行 next() 方法时从当前位置继续运行。</p> </td><td style="width:210px;">O</td></tr><tr><td style="width:126px;"></td><td style="width:364px;"></td><td style="width:210px;"></td></tr></tbody></table> 
<h2>装饰器</h2> 
<p>想扩展类的功能可以使用继承（新增方法或者重写方法），那么想扩展函数的功能怎么办？把函数到处复制是非常丑陋的，Python的解决方案是“装饰器”。装饰器用于扩展函数功能，在没对函数本身做任何修改的情况下，如其名所示，添加了其它(辅助)功能。</p> 
<p><strong>其依赖于Python中一切皆对象的原理，可以在函数中定义函数、可以把函数作为另一个函数的argument输入、可以在函数中return函数。</strong></p> 
<p>装饰器概念的引入：</p> 
<p>假设有一个函数：</p> 
<pre><code class="language-python">def myfunc(num):
    time.sleep(num)</code></pre> 
<p>假设想给函数加上执行时间的计时，最直接的方法是直接改写函数：</p> 
<pre><code class="language-python">def myfunc(num):
    time1 = time.time()
    time.sleep(num)
    time2 = time.time()
    delta_t=time2-time1
    print('excecute_time is {}'.format(delta_t))
#调用时：
myfunc(5)</code></pre> 
<p>这里出现两个问题：1. 直接改写别人的函数在很多情况下是不允许的，而且会使得原函数引入很多冗余功能；2. 如果想要添加的这个功能也是具有通用性的，对很多函数都要添加计时，难道要把重复的代码写进每一个函数？</p> 
<p>直观的方法是重新定义一个函数，专门实现计时功能，在该函数内部调用原来的函数（这里使用了python可以把函数作为另一个函数的argument输入的原理）：</p> 
<pre><code class="language-python">def executetime(func, *args):
    time1 = time.time()
    fun(*args)
    time2 = time.time()
    delta_t=time2-time1
    print('excecute_time is {}'.format(delta_t))

def myfunc(num):
    time.sleep(num)

#调用时：
excecutetime(myfunc, 5)</code></pre> 
<p>这里独立定义了计时功能的函数，保证了计时这个功能代码的复用性，但是又出现了一个问题：代码执行的逻辑发生改变了，原来是想执行myfun(5)，现在变成了执行excecutetime(myfunc, 5) ; 为了解决这个问题，可以加一层wrapper函数封装（这里还使用了可以在函数中定义函数，以及在函数中return函数的原理）：</p> 
<pre><code class="language-python">def executetime(func):
   def wrapper(*args, **kwargs):
        time1=time.time()
        func(*args, **kwargs)
        time2=time.time()
        delta_t=time2-time1
        print('excecute_time is {}'.format(delta_t))
   return wrapper

myfunc = executetime(myfunc)

#调用：
myfunc(5)</code></pre> 
<p>装饰器其实是一个语法糖，是对myfunc = executetime(myfunc)这种写法的一种简写，即直接在定义函数是加上：</p> 
<pre><code class="language-python">@executetime
def myfunc(num):
    time.sleep(num)</code></pre> 
<p>所以，含有装饰器的完整定义如下：</p> 
<pre><code class="language-python">def executetime(func):
   def wrapper(*args, **kwargs):
        time1=time.time()
        func(*args, **kwargs)
        time2=time.time()
        delta_t=time2-time1
        print('excecute_time is {}'.format(delta_t))
   return wrapper

@executetime
def myfunc(num):
    time.sleep(num)

#调用时：
myfunc(5)</code></pre> 
<p>这样就保证了在原来调用形式不变的情况下扩展这可以计时这种共用的功能，而且这个装饰器的代码可以复用，轻松地给其他函数扩展计时的功能。</p> 
<p><strong>这里可以看到装饰器的函数定义时外面裹了两层，最外面一层def execute(func): return wrapper的目的就是把被装饰的函数送进去；里面一层def wrapper(*args, **kwargs)则是把被装饰的函数的参数送进去。</strong>那么如果装饰的函数也需要传参数怎么办呐？答案是在外面再裹一层，使用时注意在@后直接调用最外面裹的函数并传参。</p> 
<pre><code class="language-python">def executetimelogger(logfile='out.log'):
    def executetime(func):
        def wrapper(*args, **kargs):
            time1=time.time()
            func(*args, **kwargs)
            time2=time.time()
            delta_t=time2-time1
            print('excecute_time is {}'.formate(delta_t))
            with open(logfile,'a') as opened_file:
                opened_file.write(str(delta_t)+'\n')
        return wrapper
    return executetime

@executetimelogger(logfile='myout.log')
def myfunc(num):
    time.sleep(num)

#调用时：
myfunc(5)</code></pre> 
<p> 参考：<a href="https://blog.csdn.net/u013380694/article/details/90019571" title="python 闭包和装饰器详解_探索未知的自己的博客-CSDN博客_python 闭包">python 闭包和装饰器详解_探索未知的自己的博客-CSDN博客_python 闭包</a></p> 
<p>其他常用装饰器：</p> 
<ul><li>@property，即保证类的封装特性（不能访问私有成员），又使得开发者可以通过“对象.属性”的方法操作类属性；</li></ul> 
<p>参考：<a href="https://zhuanlan.zhihu.com/p/429115337" title="Python @property装饰器详解 - 知乎">Python @property装饰器详解 - 知乎</a></p> 
<ul><li>@staticmethod，在不创建类的实例的条件下调用被装饰的方法，其参数列表不需要使用self，静态方法不能引用类中的属性或方法。（很多应用场景是类对外部函数的封装）；</li><li>@classmethod，需要第一个参数传入cls，可以修改类的属性，不能对实例的属性进行操作，常用来实现工厂方法，比如实现初始化函数的动态重载功能；</li></ul> 
<p>参考：<a href="https://www.geeksforgeeks.org/classmethod-in-python/" rel="nofollow" title="classmethod() in Python - GeeksforGeeks">classmethod() in Python - GeeksforGeeks</a></p> 
<p></p> 
<h2 id="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">五、数据结构</h2> 
<p>Python和C++都有容器的概念：</p> 
<p>序列中的每个元素被分配一个序号--即元素的位置，也称为索引。</p> 
<p>通用序列操作：索引、分片、序列相加、乘法、成员资格、长度、最小值和最大值。</p> 
<p>Python包含6种内建的序列，即列表、元组、字符串、Unicode字符串、buffer对象和 xrange 对象</p> 
<ul><li>列表 []: 相当于C++中的vector容器；数据项不需要具有相同的类型</li><li>元组 (): 元组的元素不能修改；数据项不需要具有相同的类型</li></ul> 
<p>Python常用的基本内置数据类型还包括：</p> 
<ul><li>集合{ } 或 set() ： 无序不重复序列</li><li>字典 {}   </li></ul> 
<blockquote> 
 <ul><li>Python中在每一个容器的方法中定义了大量的操作，例如列表的方法直接实现查询、修改等操作，优点是方便、直观；</li><li>C++在每个容器的方法中只定义了添加、删除等很少的操作，而是以泛型算法的形式实现更多的查找元素、替换或删除特定值、排序等操作，优点是可以用于多种容器类型。泛型算法算法不直接操作容器，通过配合迭代器使用，遍历由两个迭代器指定的一个元素范围来进行操作，使得算法不依赖于容器类型。</li></ul> 
</blockquote> 
<p></p> 
<h3>1. 顺容器操作</h3> 
<table border="1" cellpadding="1" cellspacing="1" style="width:679px;"><tbody><tr><td style="width:133px;"></td><td style="width:235px;"> <p>Python </p> <p>序列（sequence ，包括列表、字符串和元组）</p> </td><td style="width:310px;"> <p>C++</p> <p>顺序容器(sequential container，包括vector, deque, list, forward_list, , string, array)</p> </td></tr><tr><td style="width:133px;">创建</td><td style="width:235px;"> <p>例如：v=['dlsdkf', 60]</p> <p>无需声明容器的类型以及容器内元素的类型：使用[]表示创建列表，()表示元组，“”或''表示字符串；</p> <p>列表中可以放任意类型的元素，甚至在同一列表中可以包含不同类型的元素。</p> </td><td style="width:310px;"> <p>C c{a,b};</p> <p>例如： std::vector v{2,3,5};</p> <p>列表初始化</p> <p>需要声明容器的类型和容器内元素的类型，容器内元素类型必须相同。</p> </td></tr><tr><td style="width:133px;">索引</td><td style="width:235px;"> <p>v[n]， n可为负数，-1表示倒数第一个</p> </td><td style="width:310px;"> <p>v[n]， n只能为正数</p> </td></tr><tr><td style="width:133px;">切片</td><td style="width:235px;"> <p>v[n:n+m]   (左闭右开）</p> <p>v[n:n+m:k] 支持带步长的切片</p> </td><td style="width:310px;">O</td></tr><tr><td style="width:133px;">序列相加</td><td style="width:235px;"> <p>v1+v2将两个序列拼接起来</p> </td><td style="width:310px;">O</td></tr><tr><td style="width:133px;"></td><td style="width:235px;"> <p>v*5，重复序列v 5次 （乘法）</p> </td><td style="width:310px;">O</td></tr><tr><td style="width:133px;">成员资格</td><td style="width:235px;"> <p>60 in v</p> </td><td style="width:310px;">O</td></tr><tr><td style="width:133px;"></td><td style="width:235px;">len(v)</td><td style="width:310px;">v.size();</td></tr><tr><td style="width:133px;"></td><td style="width:235px;">min(v)</td><td style="width:310px;">O</td></tr><tr><td style="width:133px;"></td><td style="width:235px;">max(v)</td><td style="width:310px;">O</td></tr></tbody></table> 
<p>a. 列表</p> 
<table border="1" cellpadding="1" cellspacing="1"><tbody><tr><td style="width:129px;"></td><td style="width:197px;"> <p>Python 列表的方法</p> </td><td style="width:380px;"> <p>C++</p> <p>顺序容器(sequential container，包括vector, deque, list, forward_list, array, string)</p> </td></tr><tr><td style="width:129px;">创建列表</td><td style="width:197px;"> <p>支持列表推导，通过列表及简洁语法生成新的列表。例如，创建二维列表：</p> <p>dp=[[0]*dim2 for _ in range(dim1)]</p> <p>或</p> <p>dp=[[0 for _ in range(dim2)] for _ in range(dim1)]</p> <p>三维列表：</p> <p>dp=[[[0 for _ in range(dim3)] for _ in range(dim2)] for _ in range(dim1)]</p> </td><td style="width:380px;"> <p>创建二维列表：</p> <p>vector&lt;vector&lt;int&gt;&gt; v(dim1, vector&lt;int&gt;(dim2,0);</p> <p></p> <p>创建三维列表：</p> <p>vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; v(dim1, vector&lt;vector&lt;int&gt;&gt;(dim2, vector&lt;int&gt;(dim3, 0)));</p> </td></tr><tr><td style="width:129px;">计算指定元素出现次数</td><td style="width:197px;"> <p>v.count(60)</p> </td><td style="width:380px;"></td></tr><tr><td style="width:129px;">列表中查找第一次出现的索引</td><td style="width:197px;"> <p>v.index(60)</p> </td><td style="width:380px;">O （可通过泛型算法find实现）</td></tr><tr><td style="width:129px;">复制列表</td><td style="width:197px;"> <p>v2=v1.copy()</p> </td><td style="width:380px;"></td></tr><tr><td style="width:129px;">反序排列</td><td style="width:197px;"> <p>v.reverse()</p> </td><td style="width:380px;">O</td></tr><tr><td style="width:129px;">排序</td><td style="width:197px;"> <p>v.sort()</p> </td><td style="width:380px;">O（可通过泛型算法sort实现）</td></tr><tr><td style="width:129px;">末尾添加一个对象</td><td style="width:197px;"> <p>v.append(20)</p> </td><td style="width:380px;">v.push_back()</td></tr><tr><td style="width:129px;">末尾添加多个对象</td><td style="width:197px;"> <p>v1.extend(v2)</p> </td><td style="width:380px;">v.insert()</td></tr><tr><td style="width:129px;">将一个对象插入列表</td><td style="width:197px;"> <p>v.insert(2, 69)</p> </td><td style="width:380px;">v.insert()</td></tr><tr><td style="width:129px;">删除元素</td><td style="width:197px;"> <p>del v[1]</p> </td><td style="width:380px;">v.erase()</td></tr><tr><td style="width:129px;">删除开头或末尾元素</td><td style="width:197px;"> <p>v.pop()</p> <p>v.pop(0)</p> </td><td style="width:380px;"> <p>v.pop_back()</p> <p>v.pop_front()</p> </td></tr><tr><td style="width:129px;">删除第一个为指定值的元素</td><td style="width:197px;"> <p>v.remove(60)</p> </td><td style="width:380px;">O</td></tr><tr><td style="width:129px;">清空列表</td><td style="width:197px;"> <p>v.clear()</p> </td><td style="width:380px;">v.clear()</td></tr><tr><td style="width:129px;"></td><td style="width:197px;"></td><td style="width:380px;"></td></tr></tbody></table> 
<p>备注：O表示无直接命令，需要通过其他方法才能实现。</p> 
<p>列表的深拷贝、浅拷贝及对应的内存图可参见：<a href="https://www.cnblogs.com/maplethefox/p/10836031.html" rel="nofollow" title="Python基础知识（六）—关于列表深拷贝和浅拷贝及内存图 - maplethefox - 博客园">Python基础知识（六）—关于列表深拷贝和浅拷贝及内存图 - maplethefox - 博客园</a></p> 
<p>b. 字符串</p> 
<table border="1" cellpadding="1" cellspacing="1"><tbody><tr><td style="width:129px;"></td><td style="width:197px;"> <p>Python</p> </td><td style="width:380px;"> <p>C++</p> </td></tr><tr><td style="width:129px;">子串</td><td style="width:197px;"> <p>s[2:6]</p> </td><td style="width:380px;"> <p>s.sub(2,8);</p> </td></tr><tr><td style="width:129px;">搜索子串</td><td style="width:197px;"> <p>s.find(sb) 返回子串首次出现的位置，若查找不到返回-1</p> <p>s.index(sb) 返回子串首次出现的位置，若查找不到抛出异常</p> </td><td style="width:380px;"> <p>string::size_type res=s.find(sb);</p> <p>如果找到则返回首次出现的位置，否则res==s.npos</p> </td></tr></tbody></table> 
<h2>2. 关联容器</h2> 
<p>a. 字典</p> 
<table border="1" cellpadding="1" cellspacing="1"><tbody><tr><td style="width:106px;"></td><td style="width:387px;">Python</td><td style="width:300px;">C++</td></tr><tr><td style="width:126px;">成员资格</td><td style="width:414px;"> <p>d=dict()</p> <p>if 5 in d:</p> <p>        statements</p> </td><td style="width:324px;"> <p>unordered_map&lt;int, int&gt; d;</p> <p>if(d.find(5)!=d.end()){<!-- --></p> <p>        statements;</p> <p>}</p> </td></tr></tbody></table> 
<h2 id="%E7%B1%BB%EF%BC%9A">六、类</h2> 
<table border="1" cellpadding="1" cellspacing="1"><tbody><tr><td style="width:106px;"></td><td style="width:387px;">Python</td><td style="width:300px;">C++</td></tr><tr><td style="width:126px;">类的构造函数和析构函数</td><td style="width:414px;"> <p>class Foobar:</p> <p>    def __init__(self):</p> <p>        </p> <p>    def __del__(self):</p> <p>使用魔法（特殊）方法机制，魔法方法是以__开头和__结尾的方法，在特定情况下自动被Python调用，而无需手动直接调用</p> </td><td style="width:324px;"> <p>class Foobar{<!-- --></p> <p>    Foobar(){};</p> <p>    ~Foobar(){};</p> <p>};</p> <p>和类同名的函数，无返回类型，</p> </td></tr><tr><td style="width:126px;">方法和数据成员绑定到对象</td><td style="width:414px;"> <p><strong>self</strong></p> <p>类定义中成员函数的<strong>第一个参数必须显式为self</strong>；</p> <p>对象调用成员函数时不用传入该参数，python解释器会自己把实例变量传进去。</p> </td><td style="width:324px;"> <p><strong>this </strong> 常量指针，指向对象地址</p> <p>类的成员函数通过this的<strong>隐式形参</strong>访问调用它的对象。类中定义成员函数时和对象调用成员函数时都不用显式传入this。</p> <p>在成员函数中return *this返回的正是调用该函数的对象</p> </td></tr><tr><td style="width:126px;">数据成员</td><td style="width:414px;"> <p><strong>python中称为对象的数据成员</strong></p> <p>在类的构造函数内直接定义：</p> <p>class Example:</p> <p>    def __init__（self）:</p> <p>        self.mymember=1</p> <p></p> <p><strong>也可以在对象中直接添加或删除对象的数据成员：</strong></p> <p>example=Example()</p> <p>example.mysecondmember=2.</p> <p>del example.mymember</p> <p></p> <p>这充分体现了Python的灵活性。</p> </td><td style="width:324px;"> <p>在类的方法外声明数据成员，随后对类实例化，每一个对象拥有数据成员；在对象中无法再添加或删除数据成员</p> <p>class Example{<!-- --></p> <p>    Example(int x):member(x){};</p> <p>    int mymember;</p> <p>};</p> <p>Example example;</p> <p></p> <p>C++的数据成员一目了然，非常清晰。</p> </td></tr><tr><td style="width:126px;">类的静态成员</td><td style="width:414px;"> <p>python中称为类的数据成员</p> <p>class Example:</p> <p>    classmember=4</p> <p>在类中但不在类的方法中定义的数据成员为类的数据成员，所有类的实例化对象共享类的数据成员，在类内或类外可以通过Example.classmember获取类的数据成员</p> </td><td style="width:324px;"> <p>class Example{<!-- --></p> <p>    static init mymember;</p> <p>};</p> <p>int x;</p> <p>x=Example::mymember;</p> </td></tr><tr><td style="width:126px;">类方法</td><td style="width:414px;"> <p>class Example:</p> <p>    classmember=4</p> <p>    @classmethod</p> <p>    def getclassmember(cls):</p> <p>        return cls.classmember</p> </td><td style="width:324px;"></td></tr><tr><td style="width:126px;"> <p>静态成员函数</p> <p>(类的静态成员函数不与任何对象绑定在一起，不包含this指针)</p> </td><td style="width:414px;"> <p>class Example:</p> <p>    @staticmethod</p> <p>    def  initsample():</p> <p>           pass</p> <p></p> <p>直接调用：Example.initsample()</p> <p>也可实例化后调用:</p> <p>example=Example()</p> <p>example.initsample()</p> <p></p> </td><td style="width:324px;"> <p>class Example{<!-- --></p> <p>    static double initsample();</p> <p>};</p> <p></p> <p>直接调用：</p> <p>double r;</p> <p>r=Example::initsample();</p> <p>也可实例化后调用:</p> <p>Example example;</p> <p>example.initsample();</p> </td></tr><tr><td style="width:126px;">子类的构造函数初始化父类</td><td style="width:414px;"> <p>class Fathertarget<code>:</code></p> <p>    def __init__(self, <code>Parameter1,Parameter2</code>):</p> <p>class Target（ <code>Fathertarget</code>）:</p> <p>    def __init__(self, P1, P2):</p> <p>          <strong>super().__init__(P1 =</strong><code>Parameter1,</code><strong>P2=</strong><code>Parameter2</code><strong>)</strong></p> </td><td style="width:324px;"> <p><code>class Fathertarget{ </code></p> <p><code>Fathertarget(int Parameter1, int Parameter2){};</code><code>} </code></p> <p><code>class Target:public Fathertarget{<!-- --></code></p> <p><code>Target(int P1, int P2):<strong>Fathertarget{P1,P2}</strong>{} </code></p> <p><code>}</code></p> <p>在子类的构造函数初始化列表中调用父类的构造函数初始化</p> </td></tr><tr><td style="width:126px;"> <p>抽象基类</p> <p>（作为接口）</p> </td><td style="width:414px;"> <p>class Example:</p> <p>    @abstractmethod</p> <p>    def  examplemethod(self):</p> <p>        pass</p> <p></p> </td><td style="width:324px;"> <p>class Example{<!-- --></p> <p>    void examplemethod()=0;</p> <p>};</p> </td></tr><tr><td style="width:126px;">像调用函数一样调用类实例对象</td><td style="width:414px;"> <p>class Sample:</p> <p>    def __call__(self):</p> <p>        print("!!!!!")</p> <p>sample=Sample()  #实例化</p> <p>sample()</p> </td><td style="width:324px;">使用函数对象，在类中重载（）运算符</td></tr><tr><td style="width:126px;">多态</td><td style="width:414px;"> <p>对象遵守特定的协议，协议指定需要实现哪些方法以及这些方法应做什么。不基于类的继承关系。</p> </td><td style="width:324px;">基类的指针或引用可以绑定在继承类的对象上，基于此机制实现多态。</td></tr><tr><td style="width:126px;">迭代器</td><td style="width:414px;">实现了方法__iter__的对象是可迭代的，实现了方法__next__的对象是迭代器</td><td style="width:324px;">O</td></tr><tr><td style="width:126px;"></td><td style="width:414px;"></td><td style="width:324px;"></td></tr></tbody></table> 
<p><br>  </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8523c26650506a09d87958854196fc13/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">前端页面的懒加载和预加载</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/43f3ebc204e28e4aefd393ff6f8d2387/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">vue项目 前端跨域进行配置</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>