<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>web项目功能案例总结 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="web项目功能案例总结" />
<meta property="og:description" content="Common模块 Utils org.springframework.util.StringUtils;
登录 基于口令 outh2.0 QQ、微信、github等登录微软
分布式单点登录 mall: 客户端保留用户token，通过请求发送回来，当前用户信息保存在Redis中
redis中
设置REDIS_DATABASE &#43; &#34;:&#34; &#43; REDIS_KEY_AUTH_CODE &#43; &#34;:&#34; &#43; telephone为authKey的key(验证码)
设置REDIS_DATABASE &#43; &#34;:&#34; &#43; REDIS_KEY_MEMBER &#43; &#34;:&#34; &#43; member.getId()为member对象的key
需要获取当前用户的时候，从前端传来的token转换成userDto对象，用userDto.getId()得到memberId，然后拼接成Redis中的key获取到member
管理/授权 绪论 主流的权限模型主要分为以下五种：
ACL模型：访问控制列表DAC模型：自主访问控制MAC模型：强制访问控制ABAC模型：基于属性的访问控制RBAC模型：基于角色的权限访问控制 主体：用户
客体：对象
Access Control List，ACL是最早的、最基本的一种访问控制机制，是基于客体进行控制的模型，在其他模型中也有ACL的身影。为了解决相同权限的用户挨个配置的问题，后来也采用了用户组的方式。
原理：每一个客体都有一个列表，列表中记录的是哪些主体可以对这个客体做哪些行为，非常简单。
缺点：当主体的数量较多时，配置和维护工作就会成本大、易出错。
Discretionary Access Control，DAC是ACL的一种拓展。
原理：在ACL模型的基础上，允许主体可以将自己拥有的权限自主地授予其他主体，所以权限可以任意传递。
例如：常见于文件系统，LINUX，UNIX、WindowsNT版本的操作系统都提供DAC的支持。
缺点：对权限控制比较分散，例如无法简单地将一组文件设置统一的权限开放给指定的一群用户。主体的权限太大，无意间就可能泄露信息。
Mandatory Access Control，MAC模型中主要的是双向验证机制。常见于机密机构或者其他等级观念强烈的行业，如军用和市政安全领域的软件。
原理：主体有一个权限标识，客体也有一个权限标识，而主体能否对该客体进行操作取决于双方的权限标识的关系。
例如：将军分为上将&gt;中将&gt;少将，军事文件保密等级分为绝密&gt;机密&gt;秘密，规定不同军衔仅能访问不同保密等级的文件，如少将只能访问秘密文件；当某一账号访问某一文件时，系统会验证账号的军衔，也验证文件的保密等级，当军衔和保密等级相对应时才可以访问。
缺点：控制太严格，实现工作量大，缺乏灵活性。
Attribute-Based Access Control，能很好地解决RBAC的缺点，在新增资源时容易维护。
原理：通过动态计算一个或一组属性是否满足某种机制来授权，是一种很灵活的权限模型，可以按需实现不同颗粒度的权限控制。
属性通常有四类：
主体属性，如用户年龄、性别等；客体属性，如一篇文章等；环境属性，即空间限制、时间限制、频度限制；操作属性，即行为类型，如读写、只读等。 Role-Based Access Control，核心在于用户只和角色关联，而角色代表对了权限，是一系列权限的集合。
RBAC三要素：
用户：系统中所有的账户角色：一系列权限的集合（如：管理员，开发者，审计管理员等）权限：菜单，按钮，数据的增删改查等详细权限。 在RBAC中，权限与角色相关联，用户通过成为适当角色的成员而得到这些角色的权限。
优点：便于角色划分，更灵活的授权管理；最小颗粒度授权；
RBAC模型可以分为：RBAC0、RBAC1、RBAC2、RBAC3 四个阶段，一般公司使用RBAC0的模型就可以。另外，RBAC0相当于底层逻辑，后三者都是在RBAC0模型上的拔高。
RBAC0模型 用户和角色、角色和权限多对多关系。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/8114569d5460857c5f75a8a75b55cfcf/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-22T23:34:32+08:00" />
<meta property="article:modified_time" content="2024-01-22T23:34:32+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">web项目功能案例总结</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-github-gist">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="Common_1"></a>Common模块</h2> 
<h3><a id="Utils_3"></a>Utils</h3> 
<p>org.springframework.util.StringUtils;</p> 
<h2><a id="_7"></a>登录</h2> 
<h3><a id="_9"></a>基于口令</h3> 
<h3><a id="outh20_13"></a>outh2.0</h3> 
<p>QQ、微信、github等登录微软</p> 
<h3><a id="_17"></a>分布式单点登录</h3> 
<p>mall: 客户端保留用户token，通过请求发送回来，当前用户信息保存在Redis中</p> 
<p>redis中</p> 
<ul><li> <p>设置<code>REDIS_DATABASE + ":" + REDIS_KEY_AUTH_CODE + ":" + telephone</code>为authKey的key(验证码)</p> </li><li> <p>设置<code>REDIS_DATABASE + ":" + REDIS_KEY_MEMBER + ":" + member.getId()</code>为member对象的key</p> </li></ul> 
<p>需要获取当前用户的时候，从前端传来的token转换成userDto对象，用userDto.getId()得到memberId，然后拼接成Redis中的key获取到member</p> 
<h2><a id="_31"></a>管理/授权</h2> 
<h3><a id="_33"></a>绪论</h3> 
<p>主流的权限模型主要分为以下五种：</p> 
<ul><li><strong>ACL模型</strong>：访问控制列表</li><li><strong>DAC模型</strong>：自主访问控制</li><li><strong>MAC模型</strong>：强制访问控制</li><li><strong>ABAC模型</strong>：基于属性的访问控制</li><li><strong>RBAC模型</strong>：基于角色的权限访问控制</li></ul> 
<blockquote> 
 <p>主体：用户</p> 
 <p>客体：对象</p> 
</blockquote> 
<p><strong>Access Control List</strong>，ACL是最早的、最基本的一种访问控制机制，是基于客体进行控制的模型，在其他模型中也有ACL的身影。为了解决相同权限的用户挨个配置的问题，后来也采用了用户组的方式。</p> 
<p><strong>原理</strong>：每一个客体都有一个列表，列表中记录的是哪些主体可以对这个客体做哪些行为，非常简单。</p> 
<p><strong>缺点</strong>：当主体的数量较多时，配置和维护工作就会成本大、易出错。</p> 
<p><strong>Discretionary Access Control</strong>，DAC是ACL的一种拓展。</p> 
<p><strong>原理</strong>：在ACL模型的基础上，允许主体可以将自己拥有的权限自主地授予其他主体，所以权限可以任意传递。</p> 
<p><strong>例如</strong>：常见于文件系统，LINUX，UNIX、WindowsNT版本的操作系统都提供DAC的支持。</p> 
<p><strong>缺点</strong>：对权限控制比较分散，例如无法简单地将一组文件设置统一的权限开放给指定的一群用户。主体的权限太大，无意间就可能泄露信息。</p> 
<p><strong>Mandatory Access Control</strong>，MAC模型中主要的是双向验证机制。常见于机密机构或者其他等级观念强烈的行业，如军用和市政安全领域的软件。</p> 
<p><strong>原理</strong>：主体有一个权限标识，客体也有一个权限标识，而主体能否对该客体进行操作取决于双方的权限标识的关系。</p> 
<p><strong>例如</strong>：将军分为上将&gt;中将&gt;少将，军事文件保密等级分为绝密&gt;机密&gt;秘密，规定不同军衔仅能访问不同保密等级的文件，如少将只能访问秘密文件；当某一账号访问某一文件时，系统会验证账号的军衔，也验证文件的保密等级，当军衔和保密等级相对应时才可以访问。</p> 
<p><strong>缺点</strong>：控制太严格，实现工作量大，缺乏灵活性。</p> 
<p><strong>Attribute-Based Access Control</strong>，能很好地解决RBAC的缺点，在新增资源时容易维护。</p> 
<p><strong>原理</strong>：通过动态计算一个或一组属性是否满足某种机制来授权，是一种很灵活的权限模型，可以按需实现不同颗粒度的权限控制。</p> 
<p>属性通常有四类：</p> 
<ol><li>主体属性，如用户年龄、性别等；</li><li>客体属性，如一篇文章等；</li><li>环境属性，即空间限制、时间限制、频度限制；</li><li>操作属性，即行为类型，如读写、只读等。</li></ol> 
<p><strong>Role-Based Access Control</strong>，核心在于用户只和角色关联，而角色代表对了权限，是一系列权限的集合。</p> 
<p>RBAC三要素：</p> 
<ol><li><strong>用户</strong>：系统中所有的账户</li><li><strong>角色</strong>：一系列权限的集合（如：管理员，开发者，审计管理员等）</li><li><strong>权限</strong>：菜单，按钮，数据的增删改查等详细权限。</li></ol> 
<p>在<strong>RBAC</strong>中，权限与角色相关联，用户通过成为适当角色的成员而得到这些角色的权限。</p> 
<p><strong>优点</strong>：便于角色划分，更灵活的授权管理；最小颗粒度授权；</p> 
<p><img src="https://images2.imgbox.com/d9/46/ovo7V6Ni_o.jpg" alt="图片"></p> 
<p>RBAC模型可以分为：<strong>RBAC0</strong>、<strong>RBAC1</strong>、<strong>RBAC2</strong>、<strong>RBAC3</strong> 四个阶段，一般公司使用<strong>RBAC0</strong>的模型就可以。另外，<strong>RBAC0</strong>相当于底层逻辑，后三者都是在<strong>RBAC0</strong>模型上的拔高。</p> 
<h4><a id="RBAC0_104"></a>RBAC0模型</h4> 
<p>用户和角色、角色和权限多对多关系。</p> 
<p>简单来说就是一个用户拥有多个角色，一个角色可以被多个用户拥有，这是用户和角色的多对多关系；同样的，角色和权限也是如此。</p> 
<h4><a id="RBAC1_110"></a>RBAC1模型</h4> 
<p>相对于<strong>RBAC0</strong>模型，增加了<strong>角色分级</strong>的逻辑，类似于树形结构，下一节点继承上一节点的所有权限，如<strong>role1</strong>根节点下有<strong>role1.1</strong>和<strong>role1.2</strong>两个子节点</p> 
<h4><a id="RBAC2_114"></a>RBAC2模型</h4> 
<p>基于<strong>RBAC0</strong>模型，对角色增加了更多约束条件。</p> 
<p>如<strong>角色互斥</strong>，如不能兼任。</p> 
<p>如<strong>角色数量限制</strong>，例如：一个角色专门为公司CEO创建的，最后发现公司有10个人拥有CEO角色，一个公司有10个CEO？</p> 
<ul><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled> 举点儿政治官员例子，权当学习官员</li></ul> 
<p><strong>RBAC2</strong> 模型主要是为了增加角色赋予的限制条件，这也符合权限系统的目标：权责明确，系统使用安全、保密。</p> 
<h4><a id="RBAC3_126"></a>RBAC3模型</h4> 
<p>同样是基于<strong>RBAC0</strong>模型，但是综合了<strong>RBAC1</strong>和<strong>RBAC2</strong>的所有特点</p> 
<p>蝶灭玩加减法呢你！</p> 
<h3><a id="_134"></a>动态权限</h3> 
<p>之前静态权限：<code>@PreAuthorize("hasAuthority('pms:product:create')")</code></p> 
<p>接下来我们详细介绍下如何使用Spring Security实现基于路径的动态权限。</p> 
<p>首先我们需要创建一个过滤器，用于实现动态权限控制，所有的鉴权操作都会在<code>super.beforeInvocation(fi)</code>中进行。</p> 
<pre><code class="prism language-java"><span class="token comment">/**
 * 动态权限过滤器，用于实现基于路径的动态权限过滤
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DynamicSecurityFilter</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractSecurityInterceptor</span> <span class="token keyword">implements</span> <span class="token class-name">Filter</span> <span class="token punctuation">{<!-- --></span>

    <span class="token annotation punctuation">@Autowired</span>
    <span class="token keyword">private</span> <span class="token class-name">DynamicSecurityMetadataSource</span> dynamicSecurityMetadataSource<span class="token punctuation">;</span>
    <span class="token annotation punctuation">@Autowired</span>
    <span class="token keyword">private</span> <span class="token class-name">IgnoreUrlsConfig</span> ignoreUrlsConfig<span class="token punctuation">;</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doFilter</span><span class="token punctuation">(</span><span class="token class-name">ServletRequest</span> servletRequest<span class="token punctuation">,</span> <span class="token class-name">ServletResponse</span> servletResponse<span class="token punctuation">,</span> <span class="token class-name">FilterChain</span> filterChain<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span><span class="token punctuation">,</span> <span class="token class-name">ServletException</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">HttpServletRequest</span> request <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">HttpServletRequest</span><span class="token punctuation">)</span> servletRequest<span class="token punctuation">;</span>
        <span class="token class-name">FilterInvocation</span> fi <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FilterInvocation</span><span class="token punctuation">(</span>servletRequest<span class="token punctuation">,</span> servletResponse<span class="token punctuation">,</span> filterChain<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//OPTIONS请求直接放行</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>request<span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">HttpMethod</span><span class="token punctuation">.</span><span class="token constant">OPTIONS</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            fi<span class="token punctuation">.</span><span class="token function">getChain</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">doFilter</span><span class="token punctuation">(</span>fi<span class="token punctuation">.</span><span class="token function">getRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> fi<span class="token punctuation">.</span><span class="token function">getResponse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">//白名单请求直接放行</span>
        <span class="token class-name">PathMatcher</span> pathMatcher <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AntPathMatcher</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">String</span> path <span class="token operator">:</span> ignoreUrlsConfig<span class="token punctuation">.</span><span class="token function">getUrls</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>pathMatcher<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span>request<span class="token punctuation">.</span><span class="token function">getRequestURI</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                fi<span class="token punctuation">.</span><span class="token function">getChain</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">doFilter</span><span class="token punctuation">(</span>fi<span class="token punctuation">.</span><span class="token function">getRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> fi<span class="token punctuation">.</span><span class="token function">getResponse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">return</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token comment">//此处会调用AccessDecisionManager中的decide方法进行鉴权操作</span>
        <span class="token class-name">InterceptorStatusToken</span> token <span class="token operator">=</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">beforeInvocation</span><span class="token punctuation">(</span>fi<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
            fi<span class="token punctuation">.</span><span class="token function">getChain</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">doFilter</span><span class="token punctuation">(</span>fi<span class="token punctuation">.</span><span class="token function">getRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> fi<span class="token punctuation">.</span><span class="token function">getResponse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">afterInvocation</span><span class="token punctuation">(</span>token<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>
</code></pre> 
<p>接下来我们需要自己实现SecurityMetadataSource接口的getAttributes方法，用于获取当前访问路径所需资源。</p> 
<pre><code class="prism language-java"><span class="token comment">/**
 * 动态权限数据源，用于获取动态权限规则
 * Created by macro on 2020/2/7.
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DynamicSecurityMetadataSource</span> <span class="token keyword">implements</span> <span class="token class-name">FilterInvocationSecurityMetadataSource</span> <span class="token punctuation">{<!-- --></span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">ConfigAttribute</span><span class="token punctuation">&gt;</span></span> configAttributeMap <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token annotation punctuation">@Autowired</span>
    <span class="token keyword">private</span> <span class="token class-name">DynamicSecurityService</span> dynamicSecurityService<span class="token punctuation">;</span>

    <span class="token annotation punctuation">@PostConstruct</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">loadDataSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        configAttributeMap <span class="token operator">=</span> dynamicSecurityService<span class="token punctuation">.</span><span class="token function">loadDataSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">clearDataSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        configAttributeMap<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        configAttributeMap <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ConfigAttribute</span><span class="token punctuation">&gt;</span></span> <span class="token function">getAttributes</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IllegalArgumentException</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>configAttributeMap <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">loadDataSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ConfigAttribute</span><span class="token punctuation">&gt;</span></span>  configAttributes <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//获取当前访问的路径</span>
        <span class="token class-name">String</span> url <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">FilterInvocation</span><span class="token punctuation">)</span> o<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getRequestUrl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">String</span> path <span class="token operator">=</span> <span class="token class-name">URLUtil</span><span class="token punctuation">.</span><span class="token function">getPath</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">PathMatcher</span> pathMatcher <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AntPathMatcher</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> iterator <span class="token operator">=</span> configAttributeMap<span class="token punctuation">.</span><span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//获取访问该路径所需资源</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>iterator<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token class-name">String</span> pattern <span class="token operator">=</span> iterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>pathMatcher<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>pattern<span class="token punctuation">,</span> path<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                configAttributes<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>configAttributeMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>pattern<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 未设置操作请求权限，返回空集合</span>
        <span class="token keyword">return</span> configAttributes<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>
</code></pre> 
<h2><a id="_234"></a>验证</h2> 
<p>登录后的验证，常见技术如cookie、session、jwt</p> 
<h3><a id="_238"></a>验证码</h3> 
<p>生成验证码时，将自定义的Redis键值加上手机号生成一个Redis的key,以验证码为value存入到Redis中，并设置过期时间（这里为120s）。校验验证码时根据手机号码来获取Redis里面存储的验证码，并与传入的验证码进行比对。</p> 
<h4><a id="redis_key_242"></a>自定义redis key</h4> 
<pre><code class="prism language-yaml"><span class="token key atrule">redis</span><span class="token punctuation">:</span>
  <span class="token key atrule">key</span><span class="token punctuation">:</span>
    <span class="token key atrule">prefix</span><span class="token punctuation">:</span>
      <span class="token key atrule">authCode</span><span class="token punctuation">:</span> <span class="token string">"portal:authCode:"</span>
    <span class="token key atrule">expire</span><span class="token punctuation">:</span>
      <span class="token key atrule">authCode</span><span class="token punctuation">:</span> <span class="token number">120</span> <span class="token comment"># 验证码超期时间</span>
</code></pre> 
<pre><code class="prism language-java"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">com<span class="token punctuation">.</span>macro<span class="token punctuation">.</span>mall<span class="token punctuation">.</span>tiny<span class="token punctuation">.</span>common<span class="token punctuation">.</span>api<span class="token punctuation">.</span></span><span class="token class-name">CommonResult</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>beans<span class="token punctuation">.</span>factory<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">Value</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">StringUtils</span></span><span class="token punctuation">;</span>


<span class="token annotation punctuation">@Service</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UmsMemberServiceImpl</span> <span class="token keyword">implements</span> <span class="token class-name">UmsMemberService</span> <span class="token punctuation">{<!-- --></span>
    <span class="token annotation punctuation">@Autowired</span>
    <span class="token keyword">private</span> <span class="token class-name">RedisService</span> redisService<span class="token punctuation">;</span>
    <span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span><span class="token string">"${redis.key.prefix.authCode}"</span><span class="token punctuation">)</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> <span class="token constant">REDIS_KEY_PREFIX_AUTH_CODE</span><span class="token punctuation">;</span>
    <span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span><span class="token string">"${redis.key.expire.authCode}"</span><span class="token punctuation">)</span>
    <span class="token keyword">private</span> <span class="token class-name">Long</span> <span class="token constant">AUTH_CODE_EXPIRE_SECONDS</span><span class="token punctuation">;</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">CommonResult</span> <span class="token function">generateAuthCode</span><span class="token punctuation">(</span><span class="token class-name">String</span> telephone<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">StringBuilder</span> sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Random</span> random <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">6</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>random<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">//验证码绑定手机号并存储到redis</span>
        redisService<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token constant">REDIS_KEY_PREFIX_AUTH_CODE</span> <span class="token operator">+</span> telephone<span class="token punctuation">,</span> sb<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        redisService<span class="token punctuation">.</span><span class="token function">expire</span><span class="token punctuation">(</span><span class="token constant">REDIS_KEY_PREFIX_AUTH_CODE</span> <span class="token operator">+</span> telephone<span class="token punctuation">,</span> <span class="token constant">AUTH_CODE_EXPIRE_SECONDS</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token class-name">CommonResult</span><span class="token punctuation">.</span><span class="token function">success</span><span class="token punctuation">(</span>sb<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"获取验证码成功"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>


    <span class="token comment">//对输入的验证码进行校验</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">CommonResult</span> <span class="token function">verifyAuthCode</span><span class="token punctuation">(</span><span class="token class-name">String</span> telephone<span class="token punctuation">,</span> <span class="token class-name">String</span> authCode<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">StringUtils</span><span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>authCode<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">return</span> <span class="token class-name">CommonResult</span><span class="token punctuation">.</span><span class="token function">failed</span><span class="token punctuation">(</span><span class="token string">"请输入验证码"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token class-name">String</span> realAuthCode <span class="token operator">=</span> redisService<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token constant">REDIS_KEY_PREFIX_AUTH_CODE</span> <span class="token operator">+</span> telephone<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">boolean</span> result <span class="token operator">=</span> authCode<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>realAuthCode<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>result<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">return</span> <span class="token class-name">CommonResult</span><span class="token punctuation">.</span><span class="token function">success</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token string">"验证码校验成功"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">return</span> <span class="token class-name">CommonResult</span><span class="token punctuation">.</span><span class="token function">failed</span><span class="token punctuation">(</span><span class="token string">"验证码不正确"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>
</code></pre> 
<h2><a id="_304"></a>分页查询</h2> 
<p>pageHelper</p> 
<p>limit</p> 
<p>会导致全表查询</p> 
<pre><code>https://www.db-fiddle.com/f/3JSpBxVgcqL3W2AzfRNCyq/1?ref=hackernoon.com
</code></pre> 
<p>左边的 Schema SQL 将插入 10 万行数据，右边有一个性能很差的查询和一个较好的解决方案。</p> 
<p>只需单击顶部的 Run，就可以比较它们的执行时间。第一个查询的运行时间至少是第二个查询的 30 倍。</p> 
<p>数据越多，情况就越糟。看看我对 10 万行数据进行的 PoC：</p> 
<pre><code>https://github.com/IvoPereira/Efficient-Pagination-SQL-PoC?ref=hackernoon.com
</code></pre> 
<h3><a id="_326"></a>大于号</h3> 
<p>where id &gt; 10 limit 20</p> 
<p>这是一种基于指针的分页。</p> 
<p>你要在本地保存上一次接收到的主键 (通常是一个 ID) 和 LIMIT，而不是 OFFSET 和 LIMIT，那么每一次的查询可能都与此类似。</p> 
<h4><a id="limit_336"></a>两种limit的执行过程</h4> 
<p>上面的两种查询方式。对应 <code>limit offset, size</code> 和 <code>limit size</code> 两种方式。</p> 
<p>而其实 <code>limit size</code> ，相当于 <code>limit 0, size</code>。也就是从0开始取size条数据。</p> 
<p>也就是说，两种方式的<strong>区别在于offset是否为0。</strong></p> 
<p>我们先来看下limit sql的内部执行逻辑。</p> 
<p><img src="https://images2.imgbox.com/30/76/Lr1f5uK4_o.png" alt="图片">Mysql架构</p> 
<p>mysql内部分为<strong>server层</strong>和<strong>存储引擎层</strong>。一般情况下存储引擎都用innodb。</p> 
<p>server层有很多模块，其中需要关注的是<strong>执行器</strong>是用于跟存储引擎打交道的组件。</p> 
<p>执行器可以通过调用存储引擎提供的接口，将一行行数据取出，当这些数据完全符合要求（比如满足其他where条件），则会放到<strong>结果集</strong>中，最后返回给调用mysql的<strong>客户端（go、java写的应用程序）</strong>。</p> 
<p>叶子结点里放的信息会根据当前的索引是<strong>主键还是非主键</strong>有所不同。</p> 
<ul><li>如果是<strong>主键索引</strong>，它的叶子节点会存放完整的行数据信息。</li><li>如果是<strong>非主键索引</strong>，那它的叶子节点则会存放主键，如果想获得行数据信息，则需要再跑到主键索引去拿一次数据，这叫<strong>回表</strong>。</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled> 啥意思，主键和非主键有不同的索引树？</li></ul> 
<p>limit子句中的offset会导致先查找全部结果再抛弃前面offset的。</p> 
<p>假如我们将sql语句修改成下面这样。</p> 
<pre><code class="prism language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> 表名  <span class="token keyword">where</span> id <span class="token operator">&gt;=</span><span class="token punctuation">(</span><span class="token keyword">select</span> id <span class="token keyword">from</span> 表名  <span class="token keyword">order</span> <span class="token keyword">by</span> id <span class="token keyword">limit</span> <span class="token number">6000000</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">order</span> <span class="token keyword">by</span> id <span class="token keyword">limit</span> <span class="token number">10</span><span class="token punctuation">;</span>
</code></pre> 
<p>上面这条sql语句，里面先执行子查询 <code>select id from page order by id limit 6000000, 1</code>, 这个操作，其实也是将在innodb中的<strong>主键索引</strong>中获取到<code>6000000+1</code>条数据，然后server层会抛弃前6000000条，只保留最后一条数据的id。</p> 
<p>但不同的地方在于，在返回server层的过程中，只会拷贝数据行内的id这一<strong>列</strong>，而不会拷贝所有列，当数据量较大时，这部分的耗时还是比较明显的。</p> 
<blockquote> 
 <p>3s的查询优化到了1.5s,很挫，，</p> 
</blockquote> 
<h5><a id="limit_374"></a>基于非主键索引的limit执行过程</h5> 
<p>上面提到的是主键索引的执行过程，我们再来看下基于<strong>非主键索引</strong>的limit执行过程。</p> 
<p>比如下面的sql语句</p> 
<pre><code>select * from page order by user_name  limit 0, 10;
</code></pre> 
<p>server层会调用innodb的接口，在innodb里的非主键索引中获取到第0条数据对应的主键id后，<strong>回表</strong>到主键索引中找到对应的完整行数据，然后返回给server层，server层将其放到结果集中，返回给客户端。</p> 
<p>而当offset&gt;0时，且offset的值较小时，逻辑也类似，区别在于，offset&gt;0时会丢弃前面的offset条数据。</p> 
<p>也就是说<strong>非主键索引的limit过程，比主键索引的limit过程，多了个回表的消耗。</strong></p> 
<p>但当offset变得非常大时，比如600万，此时执行explain。</p> 
<p><img src="https://images2.imgbox.com/bc/75/ygbJ3pM3_o.png" alt="图片">非主键索引offset值超大时走全表扫描</p> 
<p>可以看到type那一栏显示的是ALL，也就是<strong>全表扫描</strong>。</p> 
<p>这是因为server层的<strong>优化器</strong>，会在执行器执行sql语句前，判断下哪种执行计划的代价更小。</p> 
<p>很明显，优化器在看到非主键索引的600w次回表之后，摇了摇头，还不如全表一条条记录去判断算了，于是选择了全表扫描。</p> 
<p>因此，<strong>当limit offset过大时，非主键索引查询非常容易变成全表扫描。是真·性能杀手</strong>。</p> 
<p>这种情况也能通过一些方式去优化。比如</p> 
<pre><code class="prism language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> page t1<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">select</span> id <span class="token keyword">from</span> page <span class="token keyword">order</span> <span class="token keyword">by</span> user_name <span class="token keyword">limit</span> <span class="token number">6000000</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span> t2  <span class="token keyword">WHERE</span> t1<span class="token punctuation">.</span>id <span class="token operator">=</span> t2<span class="token punctuation">.</span>id<span class="token punctuation">;</span>
</code></pre> 
<p>通过<code>select id from page order by user_name limit 6000000, 100</code>。先走innodb层的user_name非主键索引取出id，因为只拿主键id，<strong>不需要回表</strong>，所以这块性能会稍微快点，在返回server层之后，同样抛弃前600w条数据，保留最后的100个id。然后再用这100个id去跟t1表做id匹配，此时走的是主键索引，将匹配到的100条行数据返回。这样就绕开了之前的600w条数据的回表。</p> 
<p>当然，跟上面的case一样，还是没有解决要白拿600w条数据然后抛弃的问题，这也是非常挫的优化。</p> 
<p>像这种，当offset变得超大时，比如到了百万千万的量级，问题就突然变得严肃了。</p> 
<p>这里就产生了个专门的术语，叫<strong>深度分页</strong>。</p> 
<h4><a id="_419"></a>深度分页问题</h4> 
<p>深度分页问题，是个很恶心的问题，恶心就恶心在，这个问题，它其实<strong>无解</strong>。</p> 
<p>不管你是用mysql还是es，你都只能通过一些手段去"减缓"问题的严重性。</p> 
<p>遇到这个问题，我们就该回过头来想想。</p> 
<p>为什么我们的代码会产生深度分页问题？</p> 
<p><strong>它背后的原始需求是什么</strong>，我们可以根据这个做一些规避。</p> 
<h5><a id="_431"></a>如果你是想取出全表的数据</h5> 
<p>有些需求是这样的，我们有一张数据库表，但我们希望将这个数据库表里的所有数据取出，异构到es，或者hive里，这时候如果直接执行</p> 
<pre><code>select * from page;
</code></pre> 
<p>这个sql一执行，狗看了都摇头。</p> 
<p>因为数据量较大，mysql根本没办法一次性获取到全部数据，妥妥<strong>超时报错</strong>。</p> 
<p>于是不少mysql小白会通过<code>limit offset size</code>分页的形式去分批获取，刚开始都是好的，等慢慢地，哪天数据表变得奇大无比，就有可能出现前面提到的<strong>深度分页</strong>问题。</p> 
<p>这种场景是最好解决的。</p> 
<p>我们可以将所有的数据<strong>根据id主键进行排序</strong>，然后分批次取，将当前批次的最大id作为下次筛选的条件进行查询。</p> 
<p>可以看下伪代码</p> 
<p><img src="https://images2.imgbox.com/99/92/m5bhEpLF_o.png" alt="图片">batch获取数据</p> 
<p>这个操作，可以通过主键索引，每次定位到id在哪，然后往后遍历100个数据，这样不管是多少万的数据，查询性能都很稳定。</p> 
<p><img src="https://images2.imgbox.com/76/73/dp7VS94f_o.png" alt="图片">batch分批获取user表</p> 
<h5><a id="_458"></a>如果是给用户做分页展示</h5> 
<p>如果深度分页背后的原始需求只是产品经理希望做一个展示页的功能，比如商品展示页，那么我们就应该好好跟产品经理battle一下了。</p> 
<p>什么样的翻页，需要翻到10多万以后，这明显是不合理的需求。</p> 
<p>是不是可以改一下需求，让它更接近用户的使用行为？</p> 
<p>比如，我们在使用谷歌搜索时看到的翻页功能。</p> 
<p><img src="https://images2.imgbox.com/60/ff/ZHFozuWR_o.png" alt="图片"></p> 
<p>一般来说，谷歌搜索基本上都在20页以内，作为一个用户，我就很少会翻到第10页之后。</p> 
<p>作为参考。</p> 
<p>如果我们要做搜索或筛选类的页面的话，就别用mysql了，用es，并且也需要控制展示的结果数，比如一万以内，这样不至于让分页过深。</p> 
<p>如果因为各种原因，必须使用mysql。那同样，也需要控制下返回结果数量，比如数量1k以内。</p> 
<p>这样就能勉强支持各种翻页，跳页（比如突然跳到第6页然后再跳到第106页）。</p> 
<p>但如果能从产品的形式上就做成不支持跳页会更好，比如<strong>只支持上一页或下一页</strong>。</p> 
<p><img src="https://images2.imgbox.com/15/0b/9APkOm7z_o.png" alt="图片">上下页的形式</p> 
<p>这样我们就可以使用上面提到的start_id方式，采用分批获取，每批数据以start_id为起始位置。这个解法最大的好处是不管翻到多少页，查询速度永远稳定。</p> 
<p>变成像抖音那样只能上划或下划，专业点，叫<strong>瀑布流</strong>。</p> 
<h4><a id="_493"></a>总结</h4> 
<ul><li><code>limit offset, size</code> 比 <code>limit size</code> 要慢，且offset的值越大，sql的执行速度越慢。</li><li>当offset过大，会引发<strong>深度分页</strong>问题，目前不管是mysql还是es都没有很好的方法去解决这个问题。只能通过限制查询数量或分批获取的方式进行规避。</li><li>遇到深度分页的问题，多思考其原始需求，大部分时候是不应该出现深度分页的场景的，必要时多去影响产品经理。</li><li>如果数据量很少，比如1k的量级，且长期不太可能有巨大的增长，还是用<code>limit offset, size</code> 的方案吧，整挺好，能用就行。</li></ul> 
<h5><a id="1_SQL_502"></a>方法1: 直接使用数据库提供的SQL语句</h5> 
<ul><li>语句样式: MySQL中，可用如下方法: SELECT * FROM 表名称 LIMIT M,N</li><li>适应场景：适用于数据量较少的情况(元组百/千级)</li><li>原因/缺点：全表扫描,速度会很慢 且 有的数据库结果集返回不稳定(如某次返回1,2,3,另外的一次返回2,1,3)。Limit限制的是从结果集的M位置处取出N条输出，其余抛弃。</li></ul> 
<h5><a id="2__10_508"></a>方法2: 建立主键或唯一索引, 利用索引(假设每页10条)</h5> 
<p>语句样式: MySQL中,可用如下方法: SELECT * FROM 表名称 WHERE id_pk &gt; (pageNum*10) LIMIT M</p> 
<ul><li>适应场景: 适用于数据量多的情况(元组数上万)</li><li>原因: 索引扫描,速度会很快。</li></ul> 
<p>有朋友提出: 因为数据查询出来并不是按照pk_id排序的，所以会有漏掉数据的情况，只能选择方法3。</p> 
<h5><a id="3_517"></a>方法3：基于索引再排序</h5> 
<p>语句样式: MySQL中，可用如下方法:</p> 
<pre><code class="prism language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> 表名称 
<span class="token keyword">WHERE</span> id_pk <span class="token operator">&gt;</span> <span class="token punctuation">(</span>pageNum<span class="token operator">*</span><span class="token number">10</span><span class="token punctuation">)</span> 
<span class="token keyword">ORDER</span> <span class="token keyword">BY</span> id_pk <span class="token keyword">ASC</span> <span class="token keyword">LIMIT</span> M
</code></pre> 
<ul><li>适应场景: 适用于数据量多的情况(元组数上万). 最好ORDER BY后的列对象是主键或唯一所以,使得ORDERBY操作能利用索引被消除但结果集是稳定的(稳定的含义,参见方法1)</li><li>原因: 索引扫描,速度会很快.</li></ul> 
<p>但MySQL的排序操作,只有ASC没有DESC(DESC是假的,未来会做真正的DESC,期待…)。</p> 
<h5><a id="4prepare_532"></a>方法4：基于索引使用prepare</h5> 
<p>第一个问号表示pageNum，第二个？表示每页元组数。</p> 
<ul><li>语句样式: MySQL中,可用如下方法: <code>PREPARE stmt_name FROM SELECT * FROM 表名称 WHERE id_pk &gt; (？* ？) ORDER BY id_pk ASC LIMIT M</code></li><li>适应场景: 大数据量</li><li>原因: 索引扫描,速度会很快。</li></ul> 
<p>prepare语句又比一般的查询语句快一点。</p> 
<h5><a id="5MySQLORDER_542"></a>方法5：利用MySQL支持ORDER操作可以利用索引快速定位部分元组，避免全表扫描。</h5> 
<p>比如: 读第1000到1019行数据(pk是主键/唯一键)。</p> 
<pre><code>SELECT * FROM your_table 
WHERE pk&gt;=1000 
ORDER BY pk ASC 
LIMIT 0,20
</code></pre> 
<h5><a id="6_553"></a>方法6：利用"子查询/连接+索引"快速定位元组的位置,然后再读取元组。</h5> 
<p>利用子查询示例：</p> 
<pre><code>SELECT * FROM your_table 
WHERE id &lt;= 
(SELECT id FROM your_table 
ORDER BY id desc 
LIMIT ($page-1)*$pagesize 
ORDER BY id desc 
LIMIT $pagesize
</code></pre> 
<p>利用连接示例：</p> 
<pre><code>SELECT * FROM your_table AS t1 
JOIN (
SELECT id FROM your_table 
ORDER BY id desc LIMIT ($page-1)*$pagesize 
) AS t2 
WHERE t1.id &lt;= t2.id 
ORDER BY t1.id desc LIMIT $pagesize;
</code></pre> 
<p>mysql大数据时使用limit分页，随着页码的增大，查询效率越低下。</p> 
<h5><a id="_581"></a>测试实验</h5> 
<h6><a id="1limit_start_count__583"></a>1、直接用limit start, count分页语句， 也是我程序中用的方法：</h6> 
<p>count当起始页较小时，查询没有性能问题，我们分别看下从10， 100， 1000， 10000开始分页的执行时间（每页取20条）。</p> 
<pre><code>select * from product limit start。
</code></pre> 
<p>当起始页较小时，查询没有性能问题，我们分别看下从10， 100， 1000， 10000开始分页的执行时间（每页取20条）。</p> 
<p>如下：</p> 
<pre><code>select * from product limit 10, 20;//0.016秒
select * from product limit 100, 20;//0.016秒
select * from product limit 1000, 20;//0.047秒
select * from product limit 10000, 20;//0.094秒
</code></pre> 
<p>我们已经看出随着起始记录的增加，时间也随着增大， 这说明分页语句limit跟起始页码是有很大关系的，那么我们把起始记录改为40w看下（也就是记录的一半左右）.</p> 
<pre><code>select * from product limit 400000, 20;//3.229秒
</code></pre> 
<p>再看我们取最后一页记录的时间</p> 
<pre><code>select * from product limit 866613, 20;//37.44秒
</code></pre> 
<p>像这种分页最大的页码页显然这种时间是无法忍受的。</p> 
<p>从中我们也能总结出两件事情：</p> 
<ol><li>limit语句的查询时间与起始记录的位置成正比</li><li>mysql的limit语句是很方便，但是对记录很多的表并不适合直接使用。</li></ol> 
<h6><a id="2limit_621"></a>2、对limit分页问题的性能优化方法</h6> 
<p>利用表的覆盖索引来加速分页查询</p> 
<p>我们都知道，利用了索引查询的语句中如果只包含了那个索引列（覆盖索引），那么这种情况会查询很快。</p> 
<p>因为利用索引查找有优化算法，且数据就在查询索引上面，不用再去找相关的数据地址了，这样节省了很多时间。另外Mysql中也有相关的索引缓存，在并发高的时候利用缓存就效果更好了。</p> 
<p>在我们的例子中，我们知道id字段是主键，自然就包含了默认的主键索引。现在让我们看看利用覆盖索引的查询效果如何。</p> 
<p>这次我们之间查询最后一页的数据（利用覆盖索引，只包含id列），如下：</p> 
<pre><code>select id from product limit 866613, 20;//0.2秒
</code></pre> 
<p>相对于查询了所有列的37.44秒，提升了大概100多倍的速度。</p> 
<p>那么如果我们也要查询所有列，有两种方法，一种是id&gt;=的形式，另一种就是利用join，看下实际情况：</p> 
<pre><code>SELECT * FROM product 
WHERE ID &gt; =(
select id from product limit 866613, 1) 
limit 20
</code></pre> 
<p>查询时间为0.2秒！</p> 
<p>另一种写法</p> 
<pre><code>SELECT * FROM product a JOIN 
(select id from product limit 866613, 20) b 
ON a.ID = b.id
</code></pre> 
<p>查询时间为0.3秒！</p> 
<h6><a id="3_660"></a>3、复合索引优化方法</h6> 
<p>MySql 性能到底能有多高？MySql 这个数据库绝对是适合dba级的高手去玩的，一般做一点1万篇新闻的小型系统怎么写都可以，用xx框架可以实现快速开发。可是数据量到了10万，百万至千万，他的性能还能那么高吗？一点小小的失误，可能造成整个系统的改写，甚至使系统无法正常运行！好了，不那么多废话了。</p> 
<p>用事实说话，看例子：</p> 
<p>数据表 collect ( id, title ,info ,vtype) 就这4个字段，其中 title 用定长，info 用text, id 是主键，vtype是tinyint，vtype是索引。这是一个基本的新闻系统的简单模型。现在往里面填充数据，填充10万篇新闻。最后collect 为 10万条记录，数据库表占用约1.6G。</p> 
<p>OK ,看下面这条sql语句：</p> 
<pre><code>select id,title from collect limit 1000,10;
</code></pre> 
<p>很快；基本上0.01秒就OK，再看下面的</p> 
<pre><code>select id,title from collect limit 90000,10;
</code></pre> 
<p>从9万条开始分页，结果？</p> 
<p>8-9秒完成，my god 哪出问题了？其实要优化这条数据，网上找得到答案。看下面一条语句:</p> 
<pre><code>select id from collect order by id limit 90000,10;
</code></pre> 
<p>很快，0.04秒就OK。为什么？因为用了id主键做索引当然快。网上的写法是：</p> 
<pre><code>select id,title from collect where id&gt;=
(select id from collect 
order by id limit 90000,1) 
limit 10;
</code></pre> 
<h5><a id="id_697"></a>这就是用了id做索引的结果。可是问题复杂那么一点点，就完了。看下面的语句</h5> 
<pre><code>select id from collect 
where vtype=1 
order by id limit 90000,10; //很慢，用了8-9秒！
</code></pre> 
<p>到了这里我相信很多人会和我一样，有崩溃感觉！vtype 做了索引了啊？怎么会慢呢？vtype做了索引是不错，你直接</p> 
<pre><code>select id from collect 
where vtype=1 limit 1000,10;
</code></pre> 
<p>是很快的，基本上0.05秒，可是提高90倍，从9万开始，那就是0.05*90=4.5秒的速度了。和测试结果8-9秒到了一个数量级。</p> 
<p>从这里开始有人提出了分表的思路，这个和dis #cuz 论坛是一样的思路。思路如下：</p> 
<p>建一个索引表：t (id,title,vtype) 并设置成定长，然后做分页，分页出结果再到 collect 里面去找info 。是否可行呢？实验下就知道了。</p> 
<p>10万条记录到 t(id,title,vtype) 里，数据表大小20M左右。用</p> 
<pre><code>select id from t 
where vtype=1 
order by id limit 90000,10;
</code></pre> 
<p>很快了。基本上0.1-0.2秒可以跑完。为什么会这样呢？我猜想是因为collect 数据太多，所以分页要跑很长的路。limit 完全和数据表的大小有关的。其实这样做还是全表扫描，只是因为数据量小，只有10万才快。OK， 来个疯狂的实验，加到100万条，测试性能。加了10倍的数据，马上t表就到了200多M，而且是定长。还是刚才的查询语句，时间是0.1-0.2秒完成！分表性能没问题？</p> 
<p>错！因为我们的limit还是9万，所以快。给个大的，90万开始</p> 
<pre><code>select id from t 
where vtype=1 
order by id limit 900000,10;
</code></pre> 
<p>看看结果，时间是1-2秒！why ?</p> 
<p>分表了时间还是这么长，非常之郁闷！有人说定长会提高limit的性能，开始我也以为，因为一条记录的长度是固定的，mysql 应该可以算出90万的位置才对啊？可是我们高估了mysql 的智能，他不是商务数据库，事实证明定长和非定长对limit影响不大？怪不得有人说discuz到了100万条记录就会很慢，我相信这是真的，这个和数据库设计有关！</p> 
<p>难道MySQL 无法突破100万的限制吗？？？到了100万的分页就真的到了极限？</p> 
<p>答案是：NO 为什么突破不了100万是因为不会设计mysql造成的。下面介绍非分表法，来个疯狂的测试！一张表搞定100万记录，并且10G 数据库，如何快速分页！</p> 
<p>好了，我们的测试又回到 collect表，开始测试结论是：</p> 
<p>30万数据，用分表法可行，超过30万他的速度会慢到你无法忍受！当然如果用分表+我这种方法，那是绝对完美的。但是用了我这种方法后，不用分表也可以完美解决！</p> 
<p>答案就是：复合索引！有一次设计mysql索引的时候，无意中发现索引名字可以任取，可以选择几个字段进来，这有什么用呢？</p> 
<p>开始的</p> 
<pre><code>select id from collect 
order by id limit 90000,10;
</code></pre> 
<p>这么快就是因为走了索引，可是如果加了where 就不走索引了。抱着试试看的想法加了 search(vtype,id) 这样的索引。</p> 
<p>然后测试</p> 
<pre><code>select id from collect 
where vtype=1 limit 90000,10;
</code></pre> 
<p>非常快！0.04秒完成！</p> 
<p>再测试:</p> 
<pre><code>select id ,title from collect 
where vtype=1 limit 90000,10;
</code></pre> 
<p>非常遗憾，8-9秒，没走search索引！</p> 
<p>再测试：search(id,vtype)，还是select id 这个语句，也非常遗憾，0.5秒。</p> 
<p>综上：如果对于有where 条件，又想走索引用limit的，必须设计一个索引，将where 放第一位，limit用到的主键放第2位，而且只能select 主键！</p> 
<p>完美解决了分页问题了。可以快速返回id就有希望优化limit，按这样的逻辑，百万级的limit应该在0.0x秒就可以分完。看来mysql语句的优化和索引是非常重要的！</p> 
<h2><a id="_783"></a>日志模块</h2> 
<p>分为操作日志和运行日志</p> 
<h3><a id="_787"></a>操作日志</h3> 
<p>业务日志，记录业务操作</p> 
<p>自定义注解，可以存在数据库中</p> 
<p>需要数据操作日志的可以看看这两个开源项目，可以解决从xx改为xx。</p> 
<p>https://github.com/qqxx6661/logRecord</p> 
<p>https://github.com/mouzt/mzt-biz-log</p> 
<h3><a id="_799"></a>系统日志</h3> 
<h4><a id="_803"></a>日志框架</h4> 
<h5><a id="ELK_805"></a>ELK</h5> 
<h6><a id="docker_807"></a><strong>docker系统搭建</strong></h6> 
<blockquote> 
 <p>首先我们需要搭建ELK日志收集系统，这里使用在Docker环境下安装的方式。</p> 
</blockquote> 
<ul><li>安装并运行Elasticsearch容器，使用如下命令即可；</li></ul> 
<pre><code>docker run -p 9200:9200 -p 9300:9300 --name elasticsearch \
-e "discovery.type=single-node" \
-e "cluster.name=elasticsearch" \
-e "ES_JAVA_OPTS=-Xms512m -Xmx1024m" \
-v /mydata/elasticsearch/plugins:/usr/share/elasticsearch/plugins \
-v /mydata/elasticsearch/data:/usr/share/elasticsearch/data \
-d elasticsearch:7.17.3
</code></pre> 
<ul><li>启动时会发现<code>/usr/share/elasticsearch/data</code>目录没有访问权限，只需要修改<code>/mydata/elasticsearch/data</code>目录的权限，再重新启动即可；</li></ul> 
<pre><code>chmod 777 /mydata/elasticsearch/data/
</code></pre> 
<ul><li>安装并运行Logstash容器，使用如下命令即可，<code>logstash.conf</code>文件地址：https://github.com/macrozheng/mall/blob/master/document/elk/logstash.conf</li></ul> 
<pre><code>docker run --name logstash -p 4560:4560 -p 4561:4561 -p 4562:4562 -p 4563:4563 \
--link elasticsearch:es \
-v /mydata/logstash/logstash.conf:/usr/share/logstash/pipeline/logstash.conf \
-d logstash:7.17.3
</code></pre> 
<ul><li>进入容器内部，安装<code>json_lines</code>插件；</li></ul> 
<pre><code>docker exec -it logstash /bin/bash
logstash-plugin install logstash-codec-json_lines
</code></pre> 
<ul><li>安装并运行Kibana容器，使用如下命令即可；</li></ul> 
<pre><code>docker run --name kibana -p 5601:5601 \
--link elasticsearch:es \
-e "elasticsearch.hosts=http://es:9200" \
-d kibana:7.17.3
</code></pre> 
<ul><li>ELK日志收集系统启动完成后，就可以访问Kibana的界面了，访问地址：http://192.168.3.105:5601</li></ul> 
<h4><a id="_858"></a>日志规范</h4> 
<ul><li>error：错误日志，指比较严重的错误，对正常业务有影响，需要<strong>运维配置监控的</strong>；</li><li>warn：警告日志，一般的错误，对业务影响不大，但是需要<strong>开发关注</strong>；</li><li>info：信息日志，记录排查问题的关键信息，如调用时间、出参入参等等；</li><li>debug：用于开发DEBUG的，关键逻辑里面的运行时数据；</li><li>trace：最详细的信息，一般这些信息只记录到日志文件中。</li></ul> 
<p>日志要打印出方法的入参、出参、返回值（可以设置为debug级）</p> 
<h5><a id="_868"></a>日志格式</h5> 
<p>理想的日志格式，应当包括这些最基本的信息：如当<strong>前时间戳</strong>（一般毫秒精确度）、<strong>日志级别</strong>，<strong>线程名字</strong>等等。在logback日志里可以这么配置：</p> 
<pre><code class="prism language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>appender</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>STDOUT<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>ch.qos.logback.core.ConsoleAppender<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>encoder</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>pattern</span><span class="token punctuation">&gt;</span></span>%d{HH:mm:ss.SSS} %-5level [%thread][%logger{0}] %m%n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>pattern</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>encoder</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>appender</span><span class="token punctuation">&gt;</span></span> 
</code></pre> 
<p>对于trace/debug这些比较低的日志级别，必须进行日志级别的开关判断。</p> 
<pre><code class="prism language-java"><span class="token keyword">if</span> <span class="token punctuation">(</span>log<span class="token punctuation">.</span><span class="token function">isDebugEnabled</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    log<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"userId is: {}"</span><span class="token punctuation">,</span> user<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h5><a id="Log4jLogback_APISLF4JAPI_888"></a>不能直接使用日志系统（Log4j、Logback）中的 API，而是使用日志框架SLF4J中的API。</h5> 
<p>SLF4J 是门面模式的日志框架，有利于维护和各个类的日志处理方式统一，并且可以在保证不修改代码的情况下，很方便的实现底层日志框架的更换。</p> 
<h5><a id="_892"></a>建议使用参数占位{}，而不是用+拼接。</h5> 
<p>{}是替换?字符串拼接耗时</p> 
<p>异步输出日志,以logback为例：</p> 
<pre><code class="prism language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>appender</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>FILE_ASYNC<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>ch.qos.logback.classic.AsyncAppender<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>appender-ref</span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>ASYNC<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>appender</span><span class="token punctuation">&gt;</span></span>
</code></pre> 
<p>禁止在线上环境开启debug</p> 
<p><code>e.getMessage()</code>不会记录详细的堆栈异常信息，只会记录错误基本描述信息，不利于排查问题。</p> 
<p>e.printStackTrace()打印出的堆栈日志跟业务代码日志是交错混合在一起的，通常排查异常日志不太方便。</p> 
<p>e.printStackTrace()语句产生的字符串记录的是堆栈信息，如果信息太长太多，字符串常量池所在的内存块没有空间了,即内存满了，那么，用户的请求就卡住啦</p> 
<p>打印e</p> 
<p>记录异常的不要抛异常</p> 
<p>日志文件分离，方法多样，如access.log，或者error级别error.log、按业务分、等等</p> 
<h4><a id="_918"></a><strong>日志收集原理</strong></h4> 
<p>日志收集系统的原理是这样的，首先应用集成了Logstash插件，通过TCP向Logstash传输日志。Logstash接收到日志后根据日志类型将日志存储到Elasticsearch的不同索引上去，Kibana从Elasticsearch中读取日志，然后我们就可以在Kibana中进行可视化日志分析了</p> 
<h2><a id="_926"></a>前后端通信</h2> 
<h3><a id="_928"></a>文件上传</h3> 
<h3><a id="_930"></a>防止重复提交</h3> 
<p>常见方法：自定义注解@RepeatSubmit</p> 
<p>ruoyi?配置拦截器，比较参数和时间，比较sessionID</p> 
<p>也有切面类+redis的</p> 
<pre><code class="prism language-java"><span class="token comment">//设置Redis的key</span>
<span class="token class-name">Boolean</span> absent <span class="token operator">=</span> redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setIfAbsent</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span><span class="token string">"userInfo"</span><span class="token punctuation">,</span> annotation<span class="token punctuation">.</span><span class="token function">limit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">SECONDS</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Assert</span><span class="token punctuation">.</span><span class="token function">isTrue</span><span class="token punctuation">(</span>absent<span class="token punctuation">,</span> <span class="token string">"请勿重复提交"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>https://www.cnblogs.com/goloving/p/16026003.html</p> 
<p>新版ruoyi-cloud：前端防止重复提交</p> 
<p>在axios的拦截器里</p> 
<h2><a id="_950"></a>异常处理</h2> 
<p>@RestControllerAdvice是一个组合注解，由@ControllerAdvice、@ResponseBody组成，而@ControllerAdvice继承了@Component，因此@RestControllerAdvice本质上是个Component，用于定义@ExceptionHandler，@InitBinder和@ModelAttribute方法，适用于所有使用@RequestMapping方法。<br> https://blog.csdn.net/user2025/article/details/105458842</p> 
<p>如果在类上注解了@RestControllerAdvice方法，则可以在该类的方法上添加@ExceptionHandler、@InitBinder、@ModelAttribute注解</p> 
<blockquote> 
 <ul><li>@ExceptionHandler：用于指定异常处理方法。当与@RestControllerAdvice配合使用时，用于全局处理控制器里的异常。</li><li>@InitBinder：用来设置WebDataBinder，用于自动绑定前台请求参数到Model中。</li><li>@ModelAttribute：本来作用是绑定键值对到Model中，当与@ControllerAdvice配合使用时，可以让全局的@RequestMapping都能获得在此处设置的键值对</li></ul> 
</blockquote> 
<blockquote> 
 <p>定义全局异常处理类时，是使用@RestControllerAdvice还是@ControllerAdvice，要看返回的数据是不是全是json</p> 
 <p>@ControllerAdvice还可以返回<code>ModelAndView</code>对象，如传统前后端不分离应用，错误页面（如404）在后端的情景</p> 
</blockquote> 
<h2><a id="_965"></a>支付系统</h2> 
<p>支付中心系统对内为各个业务线提供统一的支付、退款等服务，对外对接三方支付或银行服务实现资金的流转。如下图：</p> 
<p><img src="https://images2.imgbox.com/dd/fc/pHt2ycgM_o.jpg" alt="图片"></p> 
<h3><a id="_971"></a>支付流程</h3> 
<p><img src="https://images2.imgbox.com/2a/07/OwFyYXUH_o.jpg" alt="图片"></p> 
<p>上图展示了用户支付的主要流程，分为三个步骤：</p> 
<ol><li>用户在业务订单确认页，唤起收银台页面。</li><li>用户在收银台页面选择支付方式，确认支付，显示第三方支付页面，输入密码，进行真实支付行为。</li><li>系统处理用户支付结果，并通知给用户及各个相关系统。</li></ol> 
<p>下面详细说下这三个步骤：</p> 
<h4><a id="1__983"></a>1. 唤起商户收银台</h4> 
<ol><li>用户在订单确认页点击“去支付“按钮，调用收银台支付下单接口。</li><li>收银台将订单信息缓存并入库，然后将订单标识拼装到收银台URL上返回给订单系统。</li><li>订单系统接收到收银台地址跳转到收银台页面。</li></ol> 
<p><img src="https://images2.imgbox.com/65/3c/eQcOxL0H_o.png" alt="图片"></p> 
<p><img src="https://images2.imgbox.com/51/58/shMbAqp8_o.png" alt="图片"></p> 
<p>上图展示了两个业务线（景区业务线，酒店业务线）唤起的收银台页面，大概可以分为三个区域：</p> 
<p>页面上部分显示的是支付剩余时间和应付金额；</p> 
<p>中间部分是订单信息，根据收银台定义的数据格式，业务线动态传递过来的；</p> 
<p>剩余部分展示的是支付渠道，支付渠道也是业务线根据自己的需求在支付后台管理系统配置的，想要哪些支付方式以及它们的顺序都可以自定义。</p> 
<h4><a id="2__1001"></a>2. 用户确认支付</h4> 
<ol><li>用户在收银台页面选择支付方式（支付宝支付，微信支付，银行卡支付等），点击立即支付按钮，</li><li>调用支付中心创单接口，支付中心调用三方支付创单接口，同步返回支付信息，支付中心对返回参数进行处理，返回给收银台，</li><li>收银台携带支付中心返回的参数，调用三方接口，唤起三方收银台，</li><li>用户输入密码，立即支付。</li></ol> 
<p><img src="https://images2.imgbox.com/5e/19/4fDRbYxl_o.png" alt="图片"></p> 
<p><img src="https://images2.imgbox.com/f8/ec/6Ntnsxl4_o.png" alt="图片"></p> 
<h4><a id="3__1012"></a>3. 支付结果处理</h4> 
<ol><li>三方系统进行扣款处理，返回收银台结果（目前微信支付返回支付中，支付宝返回支付终态（支付成功或支付失败）），</li></ol> 
<p><strong>以下几个步骤是异步执行的，不分先后。</strong></p> 
<ol><li>收银台拿到三方返回的结果，确认用户已经支付，则分配定时任务轮询查询（注意超时时间）后台支付结果，拿到终态之后跳转到相应页面，</li><li>三方系统支付成功后会通知支付中心结果，支付中心做好自身逻辑处理，异步通知订单系统，然后返回三方系统通知结果，</li><li>如果长时间未收到三方支付结果的通知，为了防止掉单，支付中心会发起主动查询来获取支付最终结果，以保证支付结果的及时更新。</li><li>当然业务线订单系统为了防止支付系统出现异步通知问题，也可以定时轮询支付中心的支付状态，防止掉单。（图中未画）</li></ol> 
<h3><a id="_1023"></a>支付中心系统一些问题及解决方案</h3> 
<h4><a id="1__1025"></a>1. 支付订单超时关闭问题</h4> 
<p>如果用户长时间没有支付，一般都会有一个超时时间（如上图商户收银台的支付剩余时间），到达这个超时时间支付单会自动关闭。实现此需求有很多方式，比如：</p> 
<h5><a id="1__DB_1029"></a>1. 轮询 DB</h5> 
<p>定时轮询DB，取出达到超时时间且在支付中的数据，然后执行关闭逻辑。</p> 
<p>缺点：1. 存在延迟，取决于定时任务的频率。2. 影响数据库性能。</p> 
<h5><a id="2_JDK_DelayQueue_1035"></a>2. JDK 延时队列（DelayQueue）和时间轮算法</h5> 
<p>这两种的算法的实现方式自行搜索。</p> 
<p>共同的缺点是 1. 数据易丢失，由于数据存储在内存中，服务重启后数据全部消失。2. 有内存限制，如果数据量过大，会出现OOM异常。</p> 
<h5><a id="3_RocketMQ__1041"></a>3. RocketMQ 延时队列</h5> 
<p>RocketMQ 支持消息延时发送，社区版不支持任意等级的延迟，目前默认支持18个延时等级：</p> 
<pre><code>1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h 
</code></pre> 
<p>比如支付单30分钟过期，在支付单创建成功后发送延迟消息（延时等级为 16），消费者在30分钟后会拉取到该消息然后执行关闭逻辑。</p> 
<p>RocketMQ 延时队列，无论在数据安全性和及时性都有明显的优势，但是目前社区版没有支持任意级别的延迟。</p> 
<p>目前我们使用的是 RocketMQ 延时队列实现的订单关闭。</p> 
<h4><a id="2__1055"></a>2. 保证支付结果实时性</h4> 
<p>三方支付系统支付成功后99.9%的情况下都会回调通知我们，但也难免有意外，比如三方延迟回调或者三方系统宕机，为了保证支付结果的实时性，三方支付也要求我们不能完全依赖于回调接口，所以我们需要定时的调用主动查询接口来查询三方的支付结果。这里我们也是使用的 RocketMQ 延时队列实现的：</p> 
<p><img src="https://images2.imgbox.com/d1/a9/oQscdvkY_o.jpg" alt="图片"></p> 
<ol><li>调用三方支付创单成功后，发送&lt;支付主动查询&gt;延时MQ消息。</li><li>消费消息，判断支付状态是否到达终态，如果到达终态，则返回处理成功，否则调用三方支付查询接口，如果支付成功则处理成功业务，返回处理成功。</li><li>如果客户未支付则判断是否达到最大的重试次数，如果达到最大重试次数则停止&lt;支付主动查询&gt;的重试，否则解析重试规则，发送下一轮的延时消息。</li></ol> 
<p>有三个重要参数，这些参数可以放到配置中心或者配置库中，</p> 
<pre><code>// 初始延迟级别，对应RocketMQ延时等级，比如3对应的延时时间就是10s
private Integer queryInitLevel = 3;

// 重试次数
private Integer queryCount = 6;

// 重试级别，对应RocketMQ延时等级，5s,10s,30s,1m,10m,20m
private String queryDelayLevels = 2,3,4,5,14,15;
</code></pre> 
<p>支付创单成功后发送延时消息：</p> 
<pre><code>public void payQueryTask(String orderNo) {
        PayQueryMessage payQueryMessage = new PayQueryMessage();
        payQueryMessage.setOrderNo(orderNo);

        RetryMessage&lt;PayQueryMessage&gt; retryMessage = new RetryMessage&lt;&gt;();
        retryMessage.setTotalCount(queryCount);
        retryMessage.setDelayLevels(queryDelayLevels);
        retryMessage.setTopic(TopicConst.PAY_QUERY_TOPIC);
        retryMessage.setEventType(RetryEventTypeEnum.PAY_QUERY);
        retryMessage.setEventDesc(RetryEventTypeEnum.PAY_QUERY.getDesc());
        retryMessage.setData(payQueryMessage);

        log.info("{} - 发送消息, retryMessage: {}", LOG_DESC, retryMessage);
        rocketMqProducer.asyncSend(retryMessage.getTopic(), JsonUtil.toJson(retryMessage),
                CodeEnum.codeOf(RocketMQDelayLevelEnum.class, queryInitLevel).orElse(RocketMQDelayLevelEnum.FiveSeconds), LOG_DESC);
}
</code></pre> 
<p>判断的是否继续执行任务：</p> 
<pre><code>public void sendDelayRetry(RetryMessage&lt;?&gt; retryMessage) {
        int currentCount;
        retryMessage.setCurrentCount(currentCount = retryMessage.getCurrentCount() + 1);
        // 重试达到最大次数
        if (currentCount &gt; retryMessage.getTotalCount()) {
            log.warn("{} - 达到最大次数-{}, 停止重试! retryMessage: {}", retryMessage.getEventDesc(), retryMessage.getTotalCount(), JsonUtil.toJson(retryMessage));
            return;
        }
        log.info("{} - 发送重试消息-{}/{}, retryMessage: {}", retryMessage.getEventDesc(), retryMessage.getCurrentCount(), retryMessage.getTotalCount(), JsonUtil.toJson(retryMessage));
        int delayLevel = Integer.parseInt(retryMessage.getDelayLevels().split(",")[retryMessage.getCurrentCount() - 1]);
        rocketMqProducer.asyncSend(retryMessage.getTopic(), retryMessage,
                CodeEnum.codeOf(RocketMQDelayLevelEnum.class, delayLevel).orElse(RocketMQDelayLevelEnum.FiveSeconds), retryMessage.getEventDesc()+", 发送重试消息");
    }
</code></pre> 
<h4><a id="3__1117"></a>3. 支付结果通知上游容错</h4> 
<p>在回调通知上游系统支付结果时，可能会回调失败，比如网络异常或上游系统发生短时故障，如果发生这种情况我们单靠简单的重试是无法完全解决问题的。为了尽可能的通知成功，我们需要针对没有通知成功的数据，每隔一段时间通知一次，那这个需求和我们上一个问题差不多，所以可以复用我们的延时重试框架。</p> 
<p><img src="https://images2.imgbox.com/e0/cc/96u9YZb3_o.jpg" alt="图片"></p> 
<p>流程和<code>保证支付结果实时</code>的差不多，不再赘述。</p> 
<h3><a id="_1125"></a>支付中心系统中设计模式的应用</h3> 
<h4><a id="_1127"></a>模板方法</h4> 
<p>模板方法模式思想：<code>定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。</code>模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p> 
<p>简单的理解就是定义一个模版方法，然后子类实现模版方法中的抽象方法实现个性化的需求。</p> 
<p>就支付而言，无论何种支付产品，都是走的同一个支付流程，那我们就可以定义一个支付流程的模板，然后每种支付产品实现这个模板中特定步骤来实现自己的特定需求。</p> 
<p><img src="https://images2.imgbox.com/aa/63/7Ds2ZY8L_o.jpg" alt="图片"></p> 
<h4><a id="_1137"></a>策略</h4> 
<p>策略模式主要思想：<code>定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。</code></p> 
<p>在支付系统中，支付结果主动查询需要查询不同的渠道，比如支付宝，微信，银联等，每个渠道查询的方式和参数不尽相同，可以将每种渠道查询封装成不同的策略类，然后根据查询条件来调用不同的策略类。</p> 
<p>查询策略有两个策略接口，<code>callChannel</code>功能是组装查询参数和查询三方，<code>execute</code> 是处理三方返回的结果统一为支付中心状态。（因<code>callChannel</code>有其他地方共用所以分开了两个方法）。</p> 
<p>Spring 下使用策略模式，在项目启动时，将所有的策略类加载到Map中，然后使用时直接在Map中获取。</p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@Component</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PayQueryStrategyContext</span> <span class="token punctuation">{<!-- --></span>

    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">PayQueryStrategy</span><span class="token punctuation">&gt;</span></span> payQueryStrategyMap <span class="token operator">=</span> <span class="token class-name">Maps</span><span class="token punctuation">.</span><span class="token function">newConcurrentMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">PayQueryStrategyContext</span><span class="token punctuation">(</span><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">PayQueryStrategy</span><span class="token punctuation">&gt;</span></span> payQueryStrategyMap<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>payQueryStrategyMap<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        payQueryStrategyMap<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>payQueryStrategyMap<span class="token operator">::</span><span class="token function">put</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token class-name">PayQueryStrategy</span> <span class="token function">getPayQuery</span><span class="token punctuation">(</span><span class="token annotation punctuation">@NotNull</span> <span class="token class-name">String</span> channelCode<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>payQueryStrategyMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name">OperationTypeConst<span class="token punctuation">.</span>Pay_Query</span> <span class="token operator">+</span> channelCode<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h2><a id="_1165"></a>防重复</h2> 
<p><strong>为了防止掉单，这里可以这样处理：</strong></p> 
<p>1、支付订单增加一个中间状态“支付中”，当同一个订单去支付的时候，先检查有没有状态为“支付中”的支付流水，当然支付（prepay）的时候要加个锁。支付完成以后更新支付流水状态的时候再讲其改成“支付成功”状态。</p> 
<p>2、支付中心这边要自己定义一个超时时间（比如：30秒），在此时间范围内如果没有收到支付成功回调，则应调用接口主动查询支付结果，比如10s、20s、30s查一次，如果在最大查询次数内没有查到结果，应做异常处理</p> 
<p>3、支付中心收到支付结果以后，将结果同步给业务系统，可以发MQ，也可以直接调用，直接调用的话要加重试（比如：SpringBoot Retry）</p> 
<p>4、无论是支付中心，还是业务应用，在接收支付结果通知时都要考虑接口幂等性，消息只处理一次，其余的忽略</p> 
<p>5、业务应用也应做超时主动查询支付结果</p> 
<p>对于上面说的超时主动查询可以在发起支付的时候将这些支付订单放到一张表中，用定时任务去扫</p> 
<p><strong>为了防止订单重复提交，可以这样处理：</strong></p> 
<p>1、创建订单的时候，用订单信息计算一个哈希值，判断redis中是否有key，有则不允许重复提交，没有则生成一个新key，放到redis中设置个过期时间，然后创建订单。其实就是在一段时间内不可重复相同的操作</p> 
<ul><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled> 为什么不直接用订单号之类的？hash不是还有可能冲突吗</li></ul> 
<p><strong>附上微信支付最佳实践：</strong></p> 
<p><img src="https://images2.imgbox.com/ff/3a/gJ3dOHMr_o.png" alt="图片"></p> 
<h2><a id="_1191"></a>文件上传</h2> 
<p>springboot的tomcat默认10m大小</p> 
<pre><code class="prism language-java">
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">PayQueryStrategy</span><span class="token punctuation">&gt;</span></span> payQueryStrategyMap <span class="token operator">=</span> <span class="token class-name">Maps</span><span class="token punctuation">.</span><span class="token function">newConcurrentMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">PayQueryStrategyContext</span><span class="token punctuation">(</span><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">PayQueryStrategy</span><span class="token punctuation">&gt;</span></span> payQueryStrategyMap<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>payQueryStrategyMap<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        payQueryStrategyMap<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>payQueryStrategyMap<span class="token operator">::</span><span class="token function">put</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token class-name">PayQueryStrategy</span> <span class="token function">getPayQuery</span><span class="token punctuation">(</span><span class="token annotation punctuation">@NotNull</span> <span class="token class-name">String</span> channelCode<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>payQueryStrategyMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name">OperationTypeConst<span class="token punctuation">.</span>Pay_Query</span> <span class="token operator">+</span> channelCode<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h2><a id="_1209"></a>防重复</h2> 
<p><strong>为了防止掉单，这里可以这样处理：</strong></p> 
<p>1、支付订单增加一个中间状态“支付中”，当同一个订单去支付的时候，先检查有没有状态为“支付中”的支付流水，当然支付（prepay）的时候要加个锁。支付完成以后更新支付流水状态的时候再讲其改成“支付成功”状态。</p> 
<p>2、支付中心这边要自己定义一个超时时间（比如：30秒），在此时间范围内如果没有收到支付成功回调，则应调用接口主动查询支付结果，比如10s、20s、30s查一次，如果在最大查询次数内没有查到结果，应做异常处理</p> 
<p>3、支付中心收到支付结果以后，将结果同步给业务系统，可以发MQ，也可以直接调用，直接调用的话要加重试（比如：SpringBoot Retry）</p> 
<p>4、无论是支付中心，还是业务应用，在接收支付结果通知时都要考虑接口幂等性，消息只处理一次，其余的忽略</p> 
<p>5、业务应用也应做超时主动查询支付结果</p> 
<p>对于上面说的超时主动查询可以在发起支付的时候将这些支付订单放到一张表中，用定时任务去扫</p> 
<p><strong>为了防止订单重复提交，可以这样处理：</strong></p> 
<p>1、创建订单的时候，用订单信息计算一个哈希值，判断redis中是否有key，有则不允许重复提交，没有则生成一个新key，放到redis中设置个过期时间，然后创建订单。其实就是在一段时间内不可重复相同的操作</p> 
<ul><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled> 为什么不直接用订单号之类的？hash不是还有可能冲突吗</li></ul> 
<p><strong>附上微信支付最佳实践：</strong></p> 
<p><img src="https://images2.imgbox.com/f4/10/PBDiURep_o.png" alt="图片"></p> 
<h2><a id="_1235"></a>文件上传</h2> 
<p>springboot的tomcat默认10m大小</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/55d689c3ea39e77131d760b1c9a11e6b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Maven应用手册</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/dbb30bece4d0f79f22748613f46700fa/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">腾讯云香港云主机cn2网路线路说明</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>