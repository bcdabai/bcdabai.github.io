<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>CAN 总线 之七 BOSCH CAN 位时序 和 同步 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="CAN 总线 之七 BOSCH CAN 位时序 和 同步" />
<meta property="og:description" content="原文地址：https://itexp.blog.csdn.net/article/details/91129145
文章目录 位时序（BIT TIMING）标称比特率（NOMINAL BIT RATE）标称位时间（NOMINAL BIT TIME）同步跳转宽度（Synchronization Jump Width，SJW）采样点（SAMPLE POINT）信息处理时间（INFORMATION PROCESSING TIME）时间量子（TIME QUANTUM） 传播延迟（PROPAGATION DELAY） 同步同步规则硬同步重新同步e = 0e &gt; 0e &lt; 0 参考 CAN 支持 1 kBit/s 至 1000 kBit/s 的比特率。CAN 网络的每个节点都有自己的时钟发生器，通常是石英振荡器。 可以为每个 CAN 节点单独配置比特时间的定时参数（即比特率的倒数），即使 CAN 节点的振荡器周期（fosc）可能不同，也产生相同的比特率。
这些振荡器的频率不是绝对稳定的，温度或电压的变化以及元件的劣化会引起微小的变化。 只要变化保持在特定振荡器容差范围（df）内，CAN 节点就能够通过重新同步到比特流来补偿不同的比特率。
CAN 网络上的所有节点必须运行在相同的标称比特率下。但噪音、相移、振荡频率容差和振荡频率漂移导致实际的比特率可能与标称比特率不同。由于没有使用一个单独的时钟信号，因此需要一个同步节点方法。
同步在仲裁机制中十分重要，因为仲裁中的节点需要能够同时看到它们传输的数据和其他节点的传输数据。 同步在确保节点间震荡时间不同时不发生错误上十分重要。
位时序（BIT TIMING） 标称比特率（NOMINAL BIT RATE） 标称比特率是指理想发送器在没有再同步的情况下每秒传输的比特数。
标称位时间（NOMINAL BIT TIME） 标称位时间为标称比特率的倒数：NOMINAL BIT TIME = 1 / NOMINAL BIT RATE。标称位时间又被划分为 4 个独立的非重叠的时间段。这些时间段又由更小的可称为时间量子（Time Quantum，Tq） 的最小时间单位构成。CAN 规范规定，1 个比特位的标称位时间被分为 4 个段，每个段又由若干个Tq 构成，这称为位时序。示例如下（以 10 个时间量子为例）：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/6ff707514693f016b929f275c8296386/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-03-04T21:25:45+08:00" />
<meta property="article:modified_time" content="2023-03-04T21:25:45+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">CAN 总线 之七 BOSCH CAN 位时序 和 同步</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>原文地址：<a href="https://itexp.blog.csdn.net/article/details/91129145" rel="nofollow">https://itexp.blog.csdn.net/article/details/91129145</a></p> 
<hr> 
<p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#BIT_TIMING_12" rel="nofollow">位时序（BIT TIMING）</a></li><li><ul><li><a href="#NOMINAL_BIT_RATE_13" rel="nofollow">标称比特率（NOMINAL BIT RATE）</a></li><li><a href="#NOMINAL_BIT_TIME_16" rel="nofollow">标称位时间（NOMINAL BIT TIME）</a></li><li><ul><li><a href="#Synchronization_Jump_WidthSJW_22" rel="nofollow">同步跳转宽度（Synchronization Jump Width，SJW）</a></li><li><a href="#SAMPLE_POINT_26" rel="nofollow">采样点（SAMPLE POINT）</a></li><li><a href="#INFORMATION_PROCESSING_TIME_28" rel="nofollow">信息处理时间（INFORMATION PROCESSING TIME）</a></li><li><a href="#TIME_QUANTUM_30" rel="nofollow">时间量子（TIME QUANTUM）</a></li></ul> 
   </li><li><a href="#PROPAGATION_DELAY_46" rel="nofollow">传播延迟（PROPAGATION DELAY）</a></li></ul> 
  </li><li><a href="#_52" rel="nofollow">同步</a></li><li><ul><li><a href="#_61" rel="nofollow">同步规则</a></li><li><a href="#_73" rel="nofollow">硬同步</a></li><li><a href="#_79" rel="nofollow">重新同步</a></li><li><ul><li><a href="#e__0_84" rel="nofollow">e = 0</a></li><li><a href="#e__0_86" rel="nofollow">e &gt; 0</a></li><li><a href="#e__0_89" rel="nofollow">e &lt; 0</a></li></ul> 
  </li></ul> 
  </li><li><a href="#_95" rel="nofollow">参考</a></li></ul> 
</div> 
<p></p> 
<p>CAN 支持 1 kBit/s 至 1000 kBit/s 的比特率。CAN 网络的每个节点都有自己的时钟发生器，通常是石英振荡器。 可以为每个 CAN 节点单独配置比特时间的定时参数（即比特率的倒数），即使 CAN 节点的振荡器周期（fosc）可能不同，也产生相同的比特率。</p> 
<p>这些振荡器的频率不是绝对稳定的，温度或电压的变化以及元件的劣化会引起微小的变化。 只要变化保持在特定振荡器容差范围（df）内，CAN 节点就能够通过重新同步到比特流来补偿不同的比特率。</p> 
<p>CAN 网络上的所有节点必须运行在相同的标称比特率下。但噪音、相移、振荡频率容差和振荡频率漂移导致实际的比特率可能与标称比特率不同。由于没有使用一个单独的时钟信号，因此需要一个同步节点方法。</p> 
<p>同步在仲裁机制中十分重要，因为仲裁中的节点需要能够同时看到它们传输的数据和其他节点的传输数据。 同步在确保节点间震荡时间不同时不发生错误上十分重要。</p> 
<h2><a id="BIT_TIMING_12"></a>位时序（BIT TIMING）</h2> 
<h3><a id="NOMINAL_BIT_RATE_13"></a>标称比特率（NOMINAL BIT RATE）</h3> 
<p>标称比特率是指理想发送器在没有再同步的情况下每秒传输的比特数。</p> 
<h3><a id="NOMINAL_BIT_TIME_16"></a>标称位时间（NOMINAL BIT TIME）</h3> 
<p>标称位时间为标称比特率的倒数：<code>NOMINAL BIT TIME = 1 / NOMINAL BIT RATE</code>。标称位时间又被划分为 4 个独立的非重叠的时间段。这些时间段又由更小的可称为<strong>时间量子（Time Quantum，Tq）</strong> 的最小时间单位构成。CAN 规范规定，1 个比特位的标称位时间被分为 4 个段，每个段又由若干个Tq 构成，这称为<strong>位时序</strong>。示例如下（以 10 个时间量子为例）：<br> <img src="https://images2.imgbox.com/60/9b/nbrbEbNt_o.png" alt="在这里插入图片描述"></p> 
<ul><li><strong>同步段（SYNCHRONIZATION SEGMENT，SYNC_SEG）：</strong> 多个连接在总线上的单元通过此段实现时序调整，同步进行接收和发送的工作。由隐性电平到显性电平的边沿或由显性电平到隐性电平边沿最好出现在此段中。</li><li><strong>传播时间段（PROPAGATION TIME SEGMENT，PROP_SEG）：</strong> 用于吸收网络上的物理延迟的段。所谓的网络的物理延迟指发送单元的输出延迟、总线上信号的传播延迟、接收单元的输入延迟。这个段的时间为以上各延迟时间的和的两倍。长度可编程为 1 ~ 8个时间量子Tq</li><li><strong>相位缓冲段1（PHASE BUFFER SEGMENT1，PHASE_SEG1）和 相位缓冲段2（PHASE BUFFER SEGMENT2，PHASE_SEG2）：</strong> 当信号边沿不能被包含于 SS 段中时，可在这两个段中进行补偿。由于各单元以各自独立的时钟工作，细微的时钟误差会累积起来，PBS 段可用于吸收此误差。通过对相位缓冲段加减 SJW 吸收误差。SJW 加大后允许误差加大，但通信速度下降。相位缓冲段1 可以通过同步暂时延长；相位缓冲段2 可以通过同步暂时缩短。</li></ul> 
<h4><a id="Synchronization_Jump_WidthSJW_22"></a>同步跳转宽度（Synchronization Jump Width，SJW）</h4> 
<p>CAN 位时序计算的另一个重要时间段是同步跳转宽度（SJW），持续时间为tSJW。 SJW 段不是标称位时间的一部分，而是定义了在重新同步的情况下可以延长或缩短比特周期的TQ的最大数量。</p> 
<p>由于再同步，相位 SEG1 可能会延长或相位 SEG2 可能会缩短。相位缓冲器段的加长或缩短量有一个由再同步跳变宽度（SJW）给出的上限。为了调整片上总线时钟，CAN 控制器可以将位的长度缩短或延长一个整数量子数。这些位时间调整的最大值称为同步跳变宽度（SJW）。相位缓冲段（Phase_Seg1和Phase_Seg2）和同步跳转宽度（SJW）用于补偿振荡器容差。 可以通过同步跳转宽度（SJW），延长或缩短相位缓冲区段。</p> 
<h4><a id="SAMPLE_POINT_26"></a>采样点（SAMPLE POINT）</h4> 
<p>采样点是读取总线电平并将其解释为相应位的值的时间点，不是标称位时间的一部分。CAN 协议允许用户指定位样本模式(SAM)为单个样本模式或 3 个样本模式。在单采样模式下，采样在 PHASE_SEG1 的末尾进行。在 3 个采样模式下，取两个额外的采样，间隔一个TQ，最后一次采样在PHASE_SEG1 的末尾进行。</p> 
<h4><a id="INFORMATION_PROCESSING_TIME_28"></a>信息处理时间（INFORMATION PROCESSING TIME）</h4> 
<p>信息处理时间是逻辑确定采样位的位级所需的时间，不是标称位时间的一部分。从采样点开始，以 TQ 测量（例如，Microchip CAN 模块固定为2TQ）。 由于相位段2 也在采样点开始并且是位时间中的最后一个段，因此需要相位段2最小值不小于信息处理时间。</p> 
<h4><a id="TIME_QUANTUM_30"></a>时间量子（TIME QUANTUM）</h4> 
<p>TIME QUANTUM 是从振荡器周期得出的固定时间单位。存在可编程预分频器，具有范围至少为 1 到 32的整数值。从MINIMUM TIME QUANTUM 开始，TIME QUANTUM 的长度可以为 <code>TIME QUANTUM = m * MINIMUM TIME QUANTUM</code>，m 为预分频器的值。</p> 
<p>在实际的 CAN 控制器芯片中，时间量子的持续时间是 CAN 系统时钟的一个周期 tSCL，它来自振荡器参考tCLK。 用户可以通过可编程预分频器（Baud Rate Prescaler，BRP）调整 CAN 系统时钟。如下公式所示：<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          t 
         
         
         
           S 
          
         
           C 
          
         
           L 
          
         
        
       
         = 
        
       
         B 
        
       
         R 
        
       
         P 
        
       
         × 
        
       
         2 
        
        
        
          t 
         
         
         
           C 
          
         
           L 
          
         
           K 
          
         
        
       
      
        t_{SCL} = BRP × 2t_{CLK} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.7651em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3283em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0715em;">SC</span><span class="mord mathnormal mtight">L</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 0.7667em; vertical-align: -0.0833em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">BRP</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.7944em; vertical-align: -0.15em;"></span><span class="mord">2</span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3283em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0715em;">C</span><span class="mord mathnormal mtight">L</span><span class="mord mathnormal mtight" style="margin-right: 0.0715em;">K</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span> 。在大多数的 CAN 控制器芯片中，TQ 等于振荡器周期的两倍。<br> <img src="https://images2.imgbox.com/4d/c2/Ly2gDScp_o.png" alt="在这里插入图片描述"><br> 标称比特位时间中各时间段的时间量子量子个数如下：</p> 
<ul><li><strong>同步段（SYNCHRONIZATION SEGMENT，SYNC_SEG）：</strong> 长度固定的 1 个时间量子 Tq</li><li><strong>传播时间段（PROPAGATION TIME SEGMENT，PROP_SEG）：</strong> 长度可编程为 1 ~ 8 个时间量子Tq</li><li><strong>相位缓冲段1（PHASE BUFFER SEGMENT1，PHASE_SEG1）：</strong> 长度可编程为 1 ~ 8 个时间量子Tq</li><li><strong>相位缓冲段2（PHASE BUFFER SEGMENT2，PHASE_SEG2）：</strong> 长度可编程为 1 ~ 8 个时间量子Tq。PHASE_SEG2 是 PHASE_SEG1 和 信息处理时间这两者中大的那个。</li><li><strong>信息处理时间（INFORMATION PROCESSING TIME）：</strong> 小于或等于 2 个时间量子Tq。信息处理时间是从保留用于计算后续比特级别的SAMPLE POINT开始的时间段。</li><li><strong>同步跳转宽度（ Synchronization Jump Width，SJW）：</strong> 因时钟频率偏差、传送延迟等，各单元有同步误差。SJW 为补偿此误差的最大值。长度可编程为 1 ~ 4 个时间量子Tq</li></ul> 
<p><em><strong>1 个比特位时间内的 TIME QUANTA 总数必须至少可编程为 8 到 25。</strong></em></p> 
<blockquote> 
 <p>如果选择每位一个样本，则段 PHASE_SEG1 的持续时间可以在1到 8 个时间量子之间，如果选择每个位 3 个样本，则可以在 2 到 8 个时间量子之间。</p> 
</blockquote> 
<h3><a id="PROPAGATION_DELAY_46"></a>传播延迟（PROPAGATION DELAY）</h3> 
<p>传播段 PROP_SEG 的存在是由于 CAN 协议允许在竞争访问总线的节点之间进行非破坏性仲裁，以及对帧内确认的要求。 在非破坏性仲裁的情况下，在仲裁字段期间可能有多个节点正在发送。每个发送节点从总线采样数据以确定它是否已赢得仲裁，并且还在仲裁失败的情况下接收仲裁字段。 当每个节点对每个比特进行采样时，采样的值必须是总线上的每个节点发送的比特值的逻辑叠加。 在确认字段的情况下，发送节点发送隐性位但期望接收显性位，即必须在采样点处对主导值进行采样。 传播延迟段 PROP_SEG 用于延迟节点对比特的最早可能采样，直到来自所有发送节点的发送比特值已到达所有节点。</p> 
<p>当节点在位边沿上同步时，系统中过多的传播延迟会导致仲裁无效。 最终，CAN 系统中的各种延迟限制了给定比特率下的最大网络总线长度。 两个节点 A 和 B 之间的单向传播延迟定义为tProp(A,B)，如下图所示：<br> <img src="https://images2.imgbox.com/64/d5/rG9ud5IX_o.png" alt="在这里插入图片描述"><br> 上图显示了两个节点之间的传播延迟，并显示节点 A 发送的比特值在时间 tProp(A,B) 之后由节点 B 接收，并且在节点 A 的传播段结束之前，节点 B 发送的比特值在时间 tProp(B,A) 之后由节点 A 接收，从而确保节点 A 将正确地对比特值进行采样。 由于节点 A 和节点 B 之间的传播延迟，即使节点 B 的采样点超过了节点 A 的比特时间，节点 B 也将正确采样比特值。时间 tProp(A,B) 包括通过节点 A 的总线驱动器的传播延迟加上从节点 A 到节点 B 的总线传播延迟加上通过节点 B 的总线接收器的传播延迟：<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          t 
         
         
         
           P 
          
         
           r 
          
         
           o 
          
         
           p 
          
         
           ( 
          
         
           A 
          
         
           , 
          
         
           B 
          
         
           ) 
          
         
        
       
         = 
        
        
        
          t 
         
         
         
           T 
          
         
           x 
          
         
           ( 
          
         
           A 
          
         
           ) 
          
         
        
       
         + 
        
       
         t 
        
       
         B 
        
       
         u 
        
       
         s 
        
       
         ( 
        
       
         A 
        
       
         , 
        
       
         B 
        
       
         ) 
        
       
         + 
        
       
         t 
        
       
         R 
        
       
         x 
        
       
         ( 
        
       
         B 
        
       
         ) 
        
       
      
        t_{Prop(A,B)} = t_{Tx(A)} + tBus(A,B) + tRx(B) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.9703em; vertical-align: -0.3552em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3448em;"><span class="" style="top: -2.5198em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right: 0.1389em;">P</span><span class="mord mathnormal mtight">ro</span><span class="mord mathnormal mtight">p</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight">A</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right: 0.0502em;">B</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.3552em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 0.9703em; vertical-align: -0.3552em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3448em;"><span class="" style="top: -2.5198em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right: 0.1389em;">T</span><span class="mord mathnormal mtight">x</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight">A</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.3552em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0502em;">tB</span><span class="mord mathnormal">u</span><span class="mord mathnormal">s</span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord mathnormal" style="margin-right: 0.0502em;">B</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0077em;">tR</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right: 0.0502em;">B</span><span class="mclose">)</span></span></span></span></span>。</p> 
<h2><a id="_52"></a>同步</h2> 
<p>位同步是位时序的一个重要问题，因此它也会影响 CAN 总线长度。 同步保证消息被正确解码，尽管相位错误可能在节点之间累积。 相位误差的主要原因是振荡器漂移，在网络上空间分布的节点之间的传播延迟，或由噪声干扰引起的相位误差。 CAN 规范定了两种类型的同步：<strong>硬同步</strong> 和 <strong>重新同步（也称为软同步）</strong>。</p> 
<p>相位缓冲段（Phase_Seg1和Phase_Seg2）和同步跳转宽度（SJW）用于补偿振荡器容差。 可以通过同步延长或缩短相位缓冲区段。同步发生在从隐性到显性的边沿，其目的是控制边沿和采样点之间的距离。</p> 
<p>通过对每个时间量程中的实际总线电平进行采样并将其与前一个采样点的总线电平进行比较来检测边沿。 只有在前一个采样点采样隐性位并且实际时间量子总线电平占优势时，才能进行同步。如果边沿发生在Sync_Seg内部，则边沿是同步的，否则边沿与Sync_Seg的结束之间的距离是边沿相位误差，以时间量子为单位测量。 如果边沿出现在Sync_Seg之前，则相位误差为负，否则为正。</p> 
<p>当边沿相位误差的大小小于或等于SJW的程序值时，硬同步和重同步的结果是相同的。当相位误差大于SJW时，再同步不能完全补偿相位误差，仍然存在(相位误差- SJW)的误差。</p> 
<blockquote> 
 <p>CAN 系统中每个节点的位时序是从其节点的参考频率（fOSC）导出的。 这产生了由于节点之间的振荡器容差小于理想值而在节点之间发生相移和振荡器漂移的情况。CAN 规范表明，最差情况下振荡器容差为1.58%，仅适用于低比特率(125 kb/s或更低)，对于其他情况，并没有进行说明。</p> 
</blockquote> 
<h3><a id="_61"></a>同步规则</h3> 
<ol><li>一个标称比特位时间内只允许一种同步方式，要么硬同步要么重同步；</li><li>只有当在前一个采样点检测到的值(前一个读总线值)与紧接在边缘之后的总线值不同时，才会使用边缘进行同步。</li><li>只要在BUS IDLE期间存在“隐性”到“显性”边缘，就会执行硬同步。</li><li>All other ’recessive’ to ’dominant’ edges fulfilling the rules 1 and 2 will be used for RESYNCHRONIZATION with the exception that a node transmitting a dominant bit will not perform a RESYNCHRONIZATION as a result of a ’recessive’ to ’dominant’ edge with a positive PHASE ERROR, if only ’recessive’ to ’dominant’ edges are used for resynchronization.</li><li>只有在隐性电平到显性电平的边沿才会用于同步</li><li>仅当前一个采样点的值与边沿之后的总线值不同时，才会使用边沿进行同步。</li><li>硬同步发生在报文的 SOF 位，所有接收节点调整各自当前位的同步段，使其位于发送的SOF位内；</li><li>重同步发生在一个报文 SOF 位之外的其它段，当下降沿落在了同步段之外时发生重同步；</li><li>在 SOF 到仲裁场发送的时间段内，如果有多个节点同时发送报文，那么这些发送节点对跳变沿不进行重同步</li><li>A transmitting node will not resynchronize on a positive phase error (e &gt; 0). This implies that a transmitter will not resynchronize due to propagation delays of it’s own transmitted message. The receivers will synchronize normally. 发送节点不会在正相位误差（e&gt; 0）上重新同步。 这意味着发送器不会由于其自身发送的消息的传播延迟而重新同步。 接收器将正常同步。</li><li>If the absolute magnitude of the phase error is greater than the SJW, then the appropriate phase segment will be adjusted by an amount equal to the SJW. 如果相位误差的绝对幅度大于SJW，则适当的相位段将被调整等于SJW的量。</li></ol> 
<h3><a id="_73"></a>硬同步</h3> 
<p>硬同步是接收单元在总线空闲状态检测出帧起始时进行的同步调整。硬同步仅在消息帧的开头（SOF 位）执行。 在空闲时段（帧间间隔（INTERFRAME SPACING）中的总线空闲）之后，网络上的每个 CAN 控制器都会在 SYNC_SEG 的第一个接收隐性到显性边沿时初始化其当前位周期时序。 随后在每个接收到的隐性到显性边沿的整个消息的剩余部分中执行一次重新同步。</p> 
<p>硬同步调整宽度不限。经过硬同步后，无论边沿相位误差如何，位时序都会在 Sync_Seg 结束时重新启动。因此，硬同步迫使硬同步的边沿位于重新启动的位时间的同步段内。下面以节点 A 和节点 B 为例：<br> <img src="https://images2.imgbox.com/84/58/jJPIWlTN_o.png" alt="在这里插入图片描述"><br> 根据 CAN 规范，当总线空闲时总线为隐性电平。此时，节点 A 发送数据，在出现 SOF 时，总线上的其他节点（如节点 B）也会监控到该变化。但是，节点 B 会发现，自己当前位的 SS 段和发送节点 SOF 位的 SS 段不同步。此时，节点 B 将强制将自己 SOF 位的 SS 段拉到与节点 A 的 SOF 位的 SS 段同步。</p> 
<h3><a id="_79"></a>重新同步</h3> 
<p>重新同步以维持由硬同步建立的初始同步。在没有重新同步的情况下，由于节点之间的振荡器漂移等因素，接收节点可能会失去同步。该功能（Microchip’s CAN 控制器通过实现数字锁相环（DPLL）功能来实现重新同步）将总线上隐性到显性边沿的实际位置与预期边沿的位置（在 SyncSeg 内）进行比较，并根据需要调整位时间。 比特的相位误差由边沿相对于SyncSeg的位置给出，以TQ测量，并定义如下：</p> 
<ul><li>e = 0： 边沿位于 SyncSeg 内（无同步）</li><li>e &gt; 0： 边沿位于 SyncSeg 之后，采样点之前 (TQ added to PS1).</li><li>e &lt; 0： 边沿位于前一位的采样点之后. (TQ subtracted from PS2)</li></ul> 
<h4><a id="e__0_84"></a>e = 0</h4> 
<p><img src="https://images2.imgbox.com/fb/60/65GSBxLf_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="e__0_86"></a>e &gt; 0</h4> 
<p>在重新同步期间，如果在 SYNC_SEG 之后和接收器的采样点之前接收到边沿，则接收器将其解释为来自较慢发送器的后沿。 在这种情况下，接收器的 PHASE_SEG1 段被延长以匹配发送器的定时，具有更好的精度。<br> <img src="https://images2.imgbox.com/7d/6b/DJyiIBJ5_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="e__0_89"></a>e &lt; 0</h4> 
<p>如果接收器在其采样点之后和 SYNC_SEG 之前检测到边沿，即在 PHASE_SEG2 段期间，则将其解释为早期边沿，并且下一个比特周期由更快的节点发送。 在这种情况下，接收器缩短其 PHASE_SEG2 周期以匹配更快发射器的定时。<br> <img src="https://images2.imgbox.com/7e/b2/pgXy4qyd_o.png" alt="在这里插入图片描述"><br> 重新同步导致比特时间的缩短或延长（相位缓冲段仅临时加长或缩短，在下一个位时间，段返回到它们的标称值），使得采样点的位置相对于边沿移位。当引起再同步的边沿相位误差为正时，相位分段1 被延长。如果相位误差的大小小于SJW，则相位Seg1的长度为相位误差的大小，否则为SJW的长度；当引起重同步的边沿相位误差为负时，相位段2 缩短。如果相位误差的大小小于SJW，则相位段2 用相位误差的大小来缩短，否则用SJW来缩短。</p> 
<p>在预期时刻之前或之后发生的过渡会促使控制器计算时间差，并根据计算所得的时间差延长相位段1或者缩短相位段2。这有效地改变接收器到发信器的时序，将它们同步在一起。这个重新同步过程不断地在每次隐性向显性过渡时进行已确保发信器和接收器保持同步。不断地重新同步降低了噪声产生的错误，让同步至已经失去仲裁的节点的接收节点重新同步到赢得仲裁的节点。</p> 
<h2><a id="_95"></a>参考</h2> 
<ol><li><a href="https://en.wikipedia.org/wiki/CAN_bus" rel="nofollow">维基百科—— CAN BUS</a></li><li>Understanding Microchip’s CAN Module Bit Timing</li><li>AN IN-DEPTH ANALYSIS OF CAN BIT-TIMING AND DELAY SOURCES</li><li>Determination of Bit Timing Parameters for the CAN Controller SJA 1000</li><li>The Configuration of the CAN Bit Timing</li><li>瑞萨 CAN 入门书</li></ol>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a3d031962a0f76de77c14b945e0d2902/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【C语言初阶】——简易版·扫雷（9*9）【运行逻辑思维导图&#43;细节讲解&#43;源码】【初级】</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4a5e6ffae083168309a1895ead93b7f1/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Spring IoC原理及简单实现</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>