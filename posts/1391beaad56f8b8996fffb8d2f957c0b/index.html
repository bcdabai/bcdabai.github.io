<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>osgi详解 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="osgi详解" />
<meta property="og:description" content="l 什么是模块化
与面向对象一样，模块化的目的也是松耦合，高内聚。我们可以理解为模块化是将对象间的互访做了边界划分，即对一组业务相关的对象进行封装，并且提供可能的更高层次的代码访问隔离机制。
l 物理模块化 VS 逻辑模块化
物理模块化是指应用中的类文件被物理的分割放在不同的模块中，但是每个模块间的互访不受控制，各个模块可以访问模块间的内部对象，只要对象是可访问的。只是是对代码本身进行模块化管理。
例如JAVA中，应用被分为模块A和B，模块B中有一个public对象B.b，该对象可以完全被模块A访问，因为它是public的。
逻辑模块化是指在物理模块化的基础上，对模块进行控制访问；即模块间实现了访问隔离，而这才是我们所说的真正的模块化的概念。
再看回上面的例子，如果B.b没有定义是其它模块可访问的，那么默认A.a是访问不到B.b这个对象的，不管这个对象的访问级别是什么。
l OSGI的作用
在java中，OSGI是一个实现java模块化互访的平台，我们可以理解为是一个更高级的JVM。它提供了逻辑上的模块化控制。
l OSGI对模块的定义
在OSGI中，模块称之为bundle，一个bundle在物理上而言就是一个jar包。Jar包中有一个描述jar包的信息文件，位于jar内部的META-INF目录下的MANIFEST.MF文件。OSGI通过MANIFEST这个文件获取模块的定义信息，比如模块间的互访信息，模块的版本信息等。
Note：对于MANIFEST.MF文件的操作，由于这个文件有很多使用约束，比如一行不能超过72个字符，所以一般都是通过IDE工具对它进行编辑
l bundle里有什么
一个bundle中一般包含如下的东西：
部署描述文件（MANIFEST.MF，必要的），各类资源文件（如html、xml等，非必须的），还有类文件。这与一个普通的jar包没有任何的区别。但是，除此之外，bundle里还可以放入其它的jar包，用于提供给bundle内部的类引用，即bundle内部的lib库。（跟一个war很类似）。
Note：实际上bundle里可以存放任何的内容，但是在bundle内部不会有嵌套的bundle，即上面提到的存放于bundle中的jar包就只会当成是一个普通的jar包，不管这些jar包中是否含有bundle定义的信息
c9aaad9c-039c-3732-8371-7279916ec4a1.jpg
l MANIFEST.MF的定义
MANIFEST.MF位于bundle中的根目录下的META-INF目录下。
一个bundle的必要信息定义如下：
e4cfb982-b32e-398b-ac08-4c5e4837fc20.jpg
我们称这些内容为bundle的头信息，具备了这4个头信息就是一个bundle
其中，
Bundle-ManifestVersion表示OSGI的参考版本，2代表参考版本使用的是OSGI R4.0&#43;
Bundle-SymbolicName用于作为bundle的ID标识的前缀，一般用模块的顶级包名来命名
Bundle-Version表示bundle当前的版本，并作为bundle的ID标识的后缀
Bundle-Name则是一个可读的bundle的命名定义，没有太大的作用
其它还有很多的头信息的定义，这里就不一一列举了。
头信息的格式：
主要由头属性名称加冒号和各个从句组成，从句间用逗号分隔
Property-Name: clause, clause, clause …
从句的定义：
target; param1(:)=value1; param2(:)=value2 …
target表示头属性对应的值，后面可以带上很多不同的参数对，每个参数分为参数名和参数值，并且都用分号分隔
参数对的定义：
参数分为两种，属性和指令，如果是指令，需要在=号前加上冒号表示是一个指令
attr1=value1
dir1:=value1
头信息的简写形式：
如果头信息的所有target的参数对定义都是一样的，那么可以将target先定义在前面，所有的参数对定义在最后
Property-Name: target1; target2; attr1=value1; dir1:=value1 ….
l Bundle的Identifier
即bundle的ID标识，这个是用来在OSGI中对bundle进行唯一性的定义的。在Bundle被OSGI读取后，OSGI通过对Bundle-SymbolicName和Bundle-Version进行组合，成为一个唯一的ID标识。组合的方式为_。
Bundle-SymbolicName的命名方式
Bundle-SymbolicName没有任何的命名要求，可以是任意的字符组成，但是一般是用模块的顶级包名来作为它的名称
Bundle-Version的命名方式
Bundle-Version有自己的命名要求，格式为[0-9].[0-9].[0-9].{ConstraintName}" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/1391beaad56f8b8996fffb8d2f957c0b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-09-27T09:26:33+08:00" />
<meta property="article:modified_time" content="2023-09-27T09:26:33+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">osgi详解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>l 什么是模块化</p> 
<p>与面向对象一样，模块化的目的也是松耦合，高内聚。我们可以理解为模块化是将对象间的互访做了边界划分，即对一组业务相关的对象进行封装，并且提供可能的更高层次的代码访问隔离机制。</p> 
<p>l 物理模块化 VS 逻辑模块化</p> 
<p>物理模块化是指应用中的类文件被物理的分割放在不同的模块中，但是每个模块间的互访不受控制，各个模块可以访问模块间的内部对象，只要对象是可访问的。只是是对代码本身进行模块化管理。</p> 
<p>例如JAVA中，应用被分为模块A和B，模块B中有一个public对象B.b，该对象可以完全被模块A访问，因为它是public的。</p> 
<p>逻辑模块化是指在物理模块化的基础上，对模块进行控制访问；即模块间实现了访问隔离，而这才是我们所说的真正的模块化的概念。</p> 
<p>再看回上面的例子，如果B.b没有定义是其它模块可访问的，那么默认A.a是访问不到B.b这个对象的，不管这个对象的访问级别是什么。</p> 
<p>l OSGI的作用</p> 
<p>在java中，OSGI是一个实现java模块化互访的平台，我们可以理解为是一个更高级的JVM。它提供了逻辑上的模块化控制。</p> 
<p>l OSGI对模块的定义</p> 
<p>在OSGI中，模块称之为bundle，一个bundle在物理上而言就是一个jar包。Jar包中有一个描述jar包的信息文件，位于jar内部的META-INF目录下的MANIFEST.MF文件。OSGI通过MANIFEST这个文件获取模块的定义信息，比如模块间的互访信息，模块的版本信息等。</p> 
<p>Note：对于MANIFEST.MF文件的操作，由于这个文件有很多使用约束，比如一行不能超过72个字符，所以一般都是通过IDE工具对它进行编辑</p> 
<p>l bundle里有什么</p> 
<p>一个bundle中一般包含如下的东西：</p> 
<p>部署描述文件（MANIFEST.MF，必要的），各类资源文件（如html、xml等，非必须的），还有类文件。这与一个普通的jar包没有任何的区别。但是，除此之外，bundle里还可以放入其它的jar包，用于提供给bundle内部的类引用，即bundle内部的lib库。（跟一个war很类似）。</p> 
<p>Note：实际上bundle里可以存放任何的内容，但是在bundle内部不会有嵌套的bundle，即上面提到的存放于bundle中的jar包就只会当成是一个普通的jar包，不管这些jar包中是否含有bundle定义的信息</p> 
<p>c9aaad9c-039c-3732-8371-7279916ec4a1.jpg<br> l MANIFEST.MF的定义</p> 
<p>MANIFEST.MF位于bundle中的根目录下的META-INF目录下。</p> 
<p>一个bundle的必要信息定义如下：</p> 
<p>e4cfb982-b32e-398b-ac08-4c5e4837fc20.jpg</p> 
<p>我们称这些内容为bundle的头信息，具备了这4个头信息就是一个bundle</p> 
<p>其中，</p> 
<p>Bundle-ManifestVersion表示OSGI的参考版本，2代表参考版本使用的是OSGI R4.0+</p> 
<p>Bundle-SymbolicName用于作为bundle的ID标识的前缀，一般用模块的顶级包名来命名</p> 
<p>Bundle-Version表示bundle当前的版本，并作为bundle的ID标识的后缀</p> 
<p>Bundle-Name则是一个可读的bundle的命名定义，没有太大的作用</p> 
<p>其它还有很多的头信息的定义，这里就不一一列举了。</p> 
<p>头信息的格式：</p> 
<p>主要由头属性名称加冒号和各个从句组成，从句间用逗号分隔</p> 
<p>Property-Name: clause, clause, clause …</p> 
<p>从句的定义：</p> 
<p>target; param1(:)=value1; param2(:)=value2 …</p> 
<p>target表示头属性对应的值，后面可以带上很多不同的参数对，每个参数分为参数名和参数值，并且都用分号分隔</p> 
<p>参数对的定义：</p> 
<p>参数分为两种，属性和指令，如果是指令，需要在=号前加上冒号表示是一个指令</p> 
<p>attr1=value1</p> 
<p>dir1:=value1</p> 
<p>头信息的简写形式：</p> 
<p>如果头信息的所有target的参数对定义都是一样的，那么可以将target先定义在前面，所有的参数对定义在最后</p> 
<p>Property-Name: target1; target2; attr1=value1; dir1:=value1 ….</p> 
<p>l Bundle的Identifier</p> 
<p>即bundle的ID标识，这个是用来在OSGI中对bundle进行唯一性的定义的。在Bundle被OSGI读取后，OSGI通过对Bundle-SymbolicName和Bundle-Version进行组合，成为一个唯一的ID标识。组合的方式为_。</p> 
<p>Bundle-SymbolicName的命名方式</p> 
<p>Bundle-SymbolicName没有任何的命名要求，可以是任意的字符组成，但是一般是用模块的顶级包名来作为它的名称</p> 
<p>Bundle-Version的命名方式</p> 
<p>Bundle-Version有自己的命名要求，格式为[0-9].[0-9].[0-9].{ConstraintName}</p> 
<p>前面都是数字作为版本号，最后一个小数点后的名称是经过命名约束的版本名</p> 
<p>例如1.2.3.alpha，1代表大版本号，2代表中版本号，3代表小版本好，而alpha代表小版本中的某个阶段，比如alpha，beta，snapshot，qualifier等，下图展示了版本大小的排序方式</p> 
<p>点击查看原始大小图片</p> 
<p>l 代码访问机制设置</p> 
<p>JVM环境：</p> 
<p>类之间的互访是通过设置classpath来查找的</p> 
<p>OSGI环境：</p> 
<p>1）bundle内部的classpath</p> 
<p>默认是bundle的根目录，但是可以通过头信息来指定bundle内的多个目录</p> 
<p>ca376a22-ed6a-3e20-abef-fff8f3365b10.jpg</p> 
<p>如图所示，通过配置Bundle-ClassPath进行设置，. 代表bundle的根目录，是必须要有的，customPath代表/customPath目录，当然，也可以是具体到某个jar文件。将会按顺序查找</p> 
<p>2） Export-Package</p> 
<p>通过设置Export-Package的头信息进行设置，可以设置多个包，只有在这里定义的包内的类可以被其它的模块进行访问。但是只能访问该包下的，该包的子包的类是不会被曝露的。</p> 
<p>例如Export-Package: net.georgezeng.test.modelb.service; version=1.0.0, net.georgezeng.test.modelb.dao; version=1.2.0</p> 
<p>3） Import-Package</p> 
<p>当某个模块曝露了某些包，那么如果你要引用相应的那个模块下的包的类的话，就需要通知OSGI引入你设置的包到该模块，即在该模块的MANIFEST中定义Import-Package头信息。</p> 
<p>例如上面的模块曝露了两个包，分别是service和dao，我们这里假设该模块需要引入service的包来获取当中的类的访问，那么就需要如下设置</p> 
<p>Import-Package: net.georgezeng.test.modelb.service; version=1.0.0</p> 
<p>这样就能访问该service包下的类了。</p> 
<p>Note：该头信息有一个有用的指令resolution，默认值是mandatory，可以设置为optional，当设置为optional时，依赖解析将对其忽略（下面将会提到）</p> 
<p>4） DynamicImport-Package</p> 
<p>使用此头信息时，OSGI将会扫描该头信息设置的所有包</p> 
<p>它只能设置target值，可以多个，并且target值可以使用通配符，例如</p> 
<p>DynamicImport-Package: net.gerogezeng.test.*, net.georgezeng.test2 …</p> 
<p>OSGI将会扫描net.georgezeng.test下所有的子包，但不包括test包下本身的类，如果要用到test包下的类，就是第二个target所设置的值的方式</p> 
<p>Note：使用该头信息时，依赖解析也会对其忽略</p> 
<p>5） Require-Bundle</p> 
<p>使用Require-Bundle相当于是将被require的Bundle export出来的包全部import</p> 
<p>l 关于Export和Import中version属性的定义和匹配</p> 
<p>在上面的描述中我们看到了Export和Import中都有一个version的属性定义，该version采用的命名规则与Bundle-Version是一样的，这里主要是说明如何设置它的范围</p> 
<p>367b8f66-a101-321c-9eab-0ac4619e1ba2.jpg<br> 如图，你可以这样设置</p> 
<p>Import-Package: net.georgezeng.test.modelb.service; version=”[1.0.0, 2.0.0)”</p> 
<p>Export和Import间的匹配</p> 
<p>1） 版本匹配</p> 
<p>通过version属性进行设置，通过上图设置的版本的范围比较进行匹配</p> 
<p>2） 自定义属性匹配</p> 
<p>自定义属性的匹配必须是属性名和属性值都相同，即Import中的属性export中也是有的，且属性值相同</p> 
<p>Note：Import-Package的规则也适用于Require-Bundle</p> 
<p>l 依赖和解析</p> 
<p>何为依赖？</p> 
<p>如果BundleA Export了某个包，而BundleB Import了这个包，那么就说BundleB依赖于BundleA</p> 
<p>或者BundleA中设置了Require-Bundle的头信息，那么Require-Bundle中的所有相关的target Bundle都被A依赖</p> 
<p>Bundle的依赖解析</p> 
<p>当OSGI读取Bundle时，Bundle将会被解析，只有当Bundle被正确解析成功，才能被其它Bundle使用或者运行。即OSGI获取Bundle的MANIFEST里的头信息进行检查分析，而这个解析是连锁式反应的。</p> 
<p>例如BundleB依赖于BundleA，假设OSGI要使用BundleB，它需要先解析BundleB，而BundllerB因为是依赖于BundleA的，所以BundleA会先于BundleB被进行解析，如果BundleA解析成功，才会继续解析BundleB，如果BundleB也成功解析，那么OSGI就可以正常使用BundleB了，这个过程由于会引起关联的Bundle进行解析，所以是依赖解析。</p> 
<p>l DynamicImport vs optional</p> 
<p>上面提到了可以通过Import-Package添加resolution指令设为optional或通过DynamicImport-Package进行配置令使得OSGI在进行依赖解析时对其进行忽略。</p> 
<p>他们的相同之处都是在运行期间当某个Bundle用到了他们export的包时才会去解析，如果exported的Bundle之前已经解析成功，那么就直接搜索class，如果还未解析过，那么optional只会解析一次，如果失败了，就不会再尝试解析它，直到它已被重新解析过；而Dynamic的方式则是每次都尝试重新解析</p> 
<p>l 依赖匹配</p> 
<p>Bundle间的依赖需要进行匹配校验，比如bundleA需要某个包，而BundleB曝露了这个包，但是BundleC也曝露了相同的包，那么这时BundleA到底是要依赖哪个呢？这个时候就是通过上面提到的export和import间的匹配来进行校验的。默认会对比version属性，如果import中有自定义属性，那么export中也必须有相应的自定义属性且属性值相同才能匹配成功</p> 
<p>匹配的顺序：</p> 
<p>1）对version属性进行范围匹配，如果不止一个bundle匹配成功，则进入下一步</p> 
<p>2）如果有自定义属性，进行严格的自定义属性匹配，如果不止一个bundle匹配成功则进入下一步</p> 
<p>3）查找Bundle-Version更高的Bundle，以最高的版本为主</p> 
<p>l Fragment Bundle</p> 
<p>一个模块就是一个Bundle，但有时候我们会需要将Bundle在物理上分成多个块，而且让细分出来的块属于同一个模块下，那么这个时候就有了Fragment的概念。</p> 
<p>Fragment没办法独立存在于OSGI中，需要依附于某个Bundle下，即有一个Bundle作为宿主。一个Fragment只能依附于一个Bundle。</p> 
<p>Note：Fragment本身没有自己的classloader，使用的是Bundle的classloader</p> 
<p>l Class的搜索顺序</p> 
<p>在了解整个class的搜索路径前，我们需要先了解下面2个内容：</p> 
<p>1） Bundle的Classloader</p> 
<p>在OSGI环境中，一个Bundle有一个ClassLoader，用于读取bundle内部的类文件</p> 
<p>2） boot delegation</p> 
<p>在OSGI的配置文件中我们可以配置一个选项用于将需要的包委派给jvm的classloader进行搜索</p> 
<p>例如org.osgi.framework.bootdeletation=sun.<em>,com.sun.</em></p> 
<p>Bundle请求一个class的顺序如下：</p> 
<p>1）如果请求的class来自于java.*下，那么bundle的classsloader会通过父classsloader（即jvm的classloader）进行搜索，找不到则抛错，如果不是java包下的，则直接进入2）</p> 
<p>2）如果请求的class非java包下的，那么将搜索boot delegation的设置的包，同样也是通过1）的classloader进行搜索，搜索不到则进入下一步</p> 
<p>3）通过Import-Package对应的Bundle的classloader进行搜索，搜索不到则进入下一步</p> 
<p>4）通过Require-Bundle对应的Bundle的classloader进行搜索，搜索不到则进入下一步</p> 
<p>5）通过Bundle自身的classpath进行搜索，如果搜索不到则进入下一步</p> 
<p>6）通过Fragment的classpath进行搜索，如果找不到则进入下一步</p> 
<p>7）如果设置了DynamicImport-Package的头信息，将通过扫描DynamicImport-Package中设置的包，然后去相应的export的Bundle中查找，有则返回，没有则抛错，搜索完毕；如果没有设置该头信息，则直接抛错</p> 
<p>l Bundle的生命周期</p> 
<p>点击查看原始大小图片<br> 如图，椭圆表示状态，bundle在OSGI中一共可以查看到5个状态，分别是Installed，Resolved，starting，Active，stopping。Uninstalled则是一个虚的状态，即当Bundle不存在于OSGI中时的状态。</p> 
<p>OSGI里对Bundle的操作一共有6个，分别是Install，Update，Refresh，Start，Stop，Uninstall</p> 
<p>通过这些操作就可以达到不同的状态</p> 
<p>如何安装和启动Bundle？</p> 
<p>可以通过3种方式：</p> 
<p>1）OSGI的配置文件</p> 
<p>2）OSGI的shell</p> 
<p>3）OSGI的API</p> 
<p>关于Resolved</p> 
<p>上面提到解析就是从Installed到Resolved间的动作，Resolved表示解析成功，进入已解析状态，此状态下Bundle可以被其它Bundle使用或启动运行Bundle自身</p> 
<p>只有在Resolved状态时当调用start命令后才能激活starting状态，并在调用结束后自动转入Active状态，如果starting时有异常则自动返回Resolved状态</p> 
<p>Active状态</p> 
<p>只有当在Active状态时，调用stop命令才能激活stopping的状态，并在结束后（不管是否有异常）自动转入Resolved状态</p> 
<p>Starting和stopping</p> 
<p>这两个状态可以交由developer控制，比如对资源进行载入和释放，做一些bundle初始化的事情。</p> 
<p>Note：</p> 
<p>1）如果Bundle是通过配置文件启动的话，那么Bundle将会通过start level event dispatcher的线程进行starting的操作，并且bunlde间的start是按顺序的，但是由于不是在OSGI的console线程中启动，所以在starting过程中可以对shell进行操作。</p> 
<p>2）如果Bunlde是通过shell进行启动的，OSGI将使用shell的当前线程，即OSGI Console线程进行启动，在该状态中shell将无法做任何操作。如果在starting中bundle出现死锁或需要长时间的过程那么将会导致无法对shell进行操作，从而只能选择重启OSGI环境。</p> 
<p>3）由于stopping是不可能在OSGI启动时发生的，一般都是在shell下通过stop命令调用发生，这种情况与2）相同。</p> 
<p>所以要慎重的考虑starting和stopping的逻辑要如何处理。</p> 
<p>在starting和stopping的状态下调用任何相关的操作都是不合理的</p> 
<p>关于update和refresh</p> 
<p>Update会对bundle内容进行更新，refresh不会对Bundle内容进行更新</p> 
<p>1）当Bundle处于Installed状态时，调用update保持状态不变，调用refresh将会自动进行解析，如果成功则进入resolved，否则还是处于installed</p> 
<p>2）当Bundle处于Resolved时，调用update命令将会回到installed状态，而调用refresh时会再次解析，成功则自定启动bundle，直到进入active</p> 
<p>3）当Bundle处于Active状态时，调用update后如果解析成功将返回active状态，refresh一样</p> 
<p>Note：使用refresh会造成依赖解析的发生</p> 
<p>关于Activator</p> 
<p>Starting和stopping到底是在哪里进行定义呢？OSGI定义了一个Activator对starting和stopping进行操作，这个类是org.osgi.framework.BundleActivator。只要继承该类，并在MANIFEST.MF中定义Bundle-Activator头信息即可实现</p> 
<p>关于BundleContext</p> 
<p>通过BundleContext我们可以与OSGI框架进行交互，比如获取OSGI下当前的bundle列表。</p> 
<p>一个Bundle都有一个对应的BundleContext，当Bundle被start的时候创建且在stop的时候被销毁。每启动一次Bundle都将获得一个新的BundleContext</p> 
<p>如何获取BundleContext？</p> 
<p>在Activator中，OSGI将会在start和stop方法中传入这个对象</p> 
<p>关于event</p> 
<p>生命周期的控制总会有一些event可以处理，比如通过实现OSGI提供的listener接口即可，这里不详细熬述</p> 
<p>l OSGI的缓存</p> 
<p>OSGI对于Bundle的install操作是持久化的操作，即当install某一个bundle的时候，OSGI将会把该bundle进行副本保存，而不再需要当前的bundle的jar包。这是OSGI的默认行为，当OSGI停止再启动时，此Bundle将会自动载入保存的副本。</p> 
<p>在update的时候OSGI将会保存一个新的bundle副本，但是老的副本也还在（不过只在当前的OSGI环境下存在了，重启则会找到最新的副本），因为可能有其它的bundle依赖于老副本存在，此时需要使用refresh来进行同步刷新。这种会引起依赖解析再次进行。</p> 
<p>如果使用uninstall则bundle的副本不再保存</p> 
<p>Note：可以通过添加-clean的启动参数来清理缓存</p> 
<p>l Bundle的persistent storage area</p> 
<p>OSGI会为bundle开辟一块持久化数据区域，用于给bundle进行资源的存取，这块区域通过BundleContext进行访问，并在uninstall的时候销毁</p> 
<p>l OSGI Service</p> 
<p>什么是OSGI Service？</p> 
<p>我们有了export和import，已经可以很好的管理模块间的代码互访，但是，如果我们只希望曝露接口，而不是实现的话，如何让依赖的Bundle获得接口的实现呢？这个时候我们就需要一种类似服务查找的方式通过OSGI来获得实现了。</p> 
<p>所以Bundle有两种角色：生产者和消费者</p> 
<p>生产者Bundle通过注册服务将实现注入OSGI中，消费者Bundle则是通过查找服务的方式从OSGI中获得实现。</p> 
<p>OSGI目前提供了2种方式用于注册和查找服务：</p> 
<p>1）编程式</p> 
<p>通过BundleContext进行注册或查找</p> 
<p>2）声明式</p> 
<p>是OSGI R4.0中引入的新的方式，通过XML文件的配置进行服务的注册和查找</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0ce8576d1df72ae2980ccb287684bd98/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">springboot的各种配置</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/59fb86cf63b2f686f6d94b0b2187538b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">top命令找到占用CPU最高的java线程</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>