<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>c语言 -- 数组 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="c语言 -- 数组" />
<meta property="og:description" content="目录
1.一维数组的创建和初始化
2.一维数组的使用
3.一维数组在内存中的存储
4.二维数组的创建和初始化
5.二维数组的使用
6.二维数组在内存中的存储
7.数组作为函数参数
1.一维数组的创建和初始化 数组是什么？
数组是一组相同类型元素的集合。
数组的创建： type_t arr_name [const_n] type_t -- 数组的元素类型 ； arr_name -- 数组的命名 ; const_n是一个常量表达式，用来表示数组元素的大小 ，如 1&#43;1 ，3，2-1等等
//创建一个数组 -- 存放整型元素，元素个数为10 int main() { int arr_1[10] ; //要注意数组的个数表示必须得是常量表达式，变量是不能放进去的！ //如 int n = 5; int arr2[n]; //上面这个数组就是错误的，因为它的括号里放的是变量而不是常量 return 0; } 数组的初始化： 数组的初始化是指，在创建数组的同时给数组的内容设定一些合理的初始化值（初始化）
首先是非字符型的初始化，设我们规定数组中有n个元素
1.如果只给x(x&lt;=n-1)个值设定初始化值，则被称为不完全初始化，不完全初始化中没被设定值的元素被默认初始化为 0 2.int arr[x] = { } (花括号中被括起来的就是被主动设定初始化值的元素，被初始化的元素的顺序是下标从0开始数，默认初始化为0的则不显示)
另一种是字符型的初始化，这一种的初始化则较为多样
1.常规的一个字符一个字符的初始化： char arr[n]={ &#39;a&#39; , &#39;b&#39; ,&#39;c&#39; }
2.用字符串来初始化 ： char arr[n] = &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/32fd3158853d3d7290b6e73599269fe9/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-04-10T20:34:04+08:00" />
<meta property="article:modified_time" content="2022-04-10T20:34:04+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">c语言 -- 数组</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="1.%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96-toc" style="margin-left:0px;"><a href="#1.%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96" rel="nofollow">1.一维数组的创建和初始化</a></p> 
<p id="2.%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E4%BD%BF%E7%94%A8-toc" style="margin-left:0px;"><a href="#2.%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E4%BD%BF%E7%94%A8" rel="nofollow">2.一维数组的使用</a></p> 
<p id="3.%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E5%AD%98%E5%82%A8-toc" style="margin-left:0px;"><a href="#3.%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E5%AD%98%E5%82%A8" rel="nofollow">3.一维数组在内存中的存储</a></p> 
<p id="4.%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96-toc" style="margin-left:0px;"><a href="#4.%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96" rel="nofollow">4.二维数组的创建和初始化</a></p> 
<p id="5.%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E4%BD%BF%E7%94%A8-toc" style="margin-left:0px;"><a href="#5.%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E4%BD%BF%E7%94%A8" rel="nofollow">5.二维数组的使用</a></p> 
<p id="6.%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E5%AD%98%E5%82%A8-toc" style="margin-left:0px;"><a href="#6.%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E5%AD%98%E5%82%A8" rel="nofollow">6.二维数组在内存中的存储</a></p> 
<p id="7.%E6%95%B0%E7%BB%84%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0-toc" style="margin-left:0px;"><a href="#7.%E6%95%B0%E7%BB%84%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0" rel="nofollow">7.数组作为函数参数</a></p> 
<hr id="hr-toc"> 
<h2 id="1.%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96">1.一维数组的创建和初始化</h2> 
<p>数组是什么？</p> 
<p>数组是一组相<strong>同类型元素</strong>的集合。</p> 
<h4>数组的创建：</h4> 
<pre><code class="language-cpp">type_t arr_name [const_n]
</code></pre> 
<p>type_t -- 数组的元素类型  ； arr_name -- 数组的命名  ; const_n是一个常量表达式，用来表示数组元素的大小 ，如 1+1 ，3，2-1等等</p> 
<pre><code class="language-cpp">//创建一个数组 -- 存放整型元素，元素个数为10
int main()
{
    int arr_1[10] ;
    //要注意数组的个数表示必须得是常量表达式，变量是不能放进去的！
    //如 
    int n = 5;
    int arr2[n];
    //上面这个数组就是错误的，因为它的括号里放的是变量而不是常量
    return 0;
}</code></pre> 
<h4 id="2.%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E4%BD%BF%E7%94%A8"> 数组的初始化：</h4> 
<p>数组的初始化是指，在创建数组的同时给数组的内容设定一些合理的初始化值（初始化）</p> 
<h2><img alt="" height="894" src="https://images2.imgbox.com/54/44/RtNaW1fT_o.png" width="1200"></h2> 
<p> 首先是非字符型的初始化，设我们规定数组中有n个元素</p> 
<p>1.如果只给x(x&lt;=n-1)个值设定初始化值，则被称为不完全初始化，不完全初始化中没被设定值的元素被默认初始化为 0 </p> 
<p>2.int arr[x] = { } (花括号中被括起来的就是被主动设定初始化值的元素，被初始化的元素的顺序是下标从0开始数，默认初始化为0的则不显示)</p> 
<p>另一种是字符型的初始化，这一种的初始化则较为多样</p> 
<p>1.常规的一个字符一个字符的初始化： char arr[n]={ 'a' , 'b' ,'c' }</p> 
<p>2.用字符串来初始化 ： char arr[n] = "abc" 注意用字符串来初始化不要玩了字符串中的转义字符 \n 也会被放进数组中，它也是一个字符元素，是要被计数的！</p> 
<p>3.用acii码值来初始化 char arr[n] = {98 , 97 , 99} 字符数值的ascii码值会被自动转译为字符，然后再给元素初始化</p> 
<p>还有一种比较特殊的初始化，就是不单独设定数组中元素的个数，直接由我们输入的初始化元素的个数来决定数组中的元素个数。</p> 
<p>如 int arr[] = {1,2,3,4} 这个数组就有4个元素，且按照顺序分别被初始化为了1，2，3，4</p> 
<p>补充知识点 strlen 函数和 sizeof操作符 的区别</p> 
<p>strlen 函数是用来计算字符串的长度的，strlen在遇到字符串中的转义字符  \n 时会停止计算，即 \n 不计入字符串长度，<strong>它只能用来求字符串的长度。另外strlen是库函数 - 使用得引头文件 strlen函数的用法 -- strlen(字符串参数/字符数组) -- 因此strlen是无法用来计算单个字符的长度的</strong></p> 
<p>strlen 函数返回的是一个无符号整型 （unsigned int）,有符号signed</p> 
<p><strong>如：</strong></p> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;string.h&gt; 
//首先要引入 string 头文件
int main()
{
    char arr[]={'a','b','c'};
    strlen("abc"); // strlen()函数中的实参只能是字符串/字符数组(只用输入数组名即可)
    strlen(arr)；
//对于字符串而言strlen是从第一个字符开始到/n停止计数
//对于字符数组而言则是从第一个元素开始到\n元素结束
//如果字符数组中没有\n元素则strlen会在计算已有元素的长度后随机生成一个字符并继续计算，直到随机到\n为止
    printf("%zd",strlen("abc"));//strlen函数的输出类型声明是 %zd
    return 0;
}</code></pre> 
<p>sizeof是用来计算数组，变量，类型所占空间的大小的，这个大小的单位是 字节。<strong>sizeof 是操作符，不用引头文件。 sizeof操作符的使用 sizeof(要被求大小的数组，变量和类型)</strong></p> 
<p> （字符串存入数组中的时候，千万不要忘了转义字符 \n）</p> 
<p>综上</p> 
<p>字符数组的元素个数 == strlen( arr )  头文件 : string </p> 
<p>数字类型数组的元素个数 == sizeof(arr) / sizeof(arr [ 0 ] )  总数组长度除以一个数组的长度</p> 
<h2>2.一维数组的使用</h2> 
<p>在讲数组的引用之前，需要先介绍一个操作符 --&gt;[ ] ，这个操作符是下标引用操作符 ，我们的数组通过下标引用操作符来访问数组中的元素。</p> 
<p>如果要访问数组中的第i个元素，则要在下标引用操作符中输入对应元素的下标，即 i-1</p> 
<p>例子</p> 
<pre><code class="language-cpp">int main()
{
    char arr[] = "abcde" ; //注意存字符串时不要忘了那个终止字符 \n
//访问第四个元素d，下标为 4 -1 = 3
    printf("%c",arr[3]);
    return 0;
}</code></pre> 
<p>数组不能被直接打印，但数组中的元素可以通过下标引用操作符直接访问</p> 
<p>所以当我们要将数组中的元素都打印出来时，我们可以采用循环或者迭代的方法，通过元素下标的变化来实现我们想要的功能。</p> 
<h2>3.一维数组在内存中的存储</h2> 
<p><strong> 数组在内存中是连续存放的</strong><img alt="" height="833" src="https://images2.imgbox.com/aa/d3/TUnlLELC_o.png" width="1200"></p> 
<p>打印地址用的类型是 %p (p--&gt;指针) </p> 
<pre><code class="language-cpp">pritnf("%p",&amp;a);</code></pre> 
<p>地址是由十六进制数组成的，十六进制数包括 0~9 A B C D E F</p> 
<p>知道上面这些之后综合第一张图我们可以发现数组中的元素的地址都与其相邻元素的地址差k</p> 
<p>且地址排序是 第n个元素的地址就等于第n-1元素的地址＋k</p> 
<p>这个k的值则由数组的类型确定，整型 int 开辟四个字节的空间，则k=4，其他的同理，看对应类型开辟多大的空间，k就取多大</p> 
<p><img alt="" height="461" src="https://images2.imgbox.com/9c/b9/Na2e2PjH_o.png" width="1013"></p> 
<p></p> 
<h2 id="4.%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96">4.二维数组的创建和初始化</h2> 
<h3>创建</h3> 
<p><img alt="" height="215" src="https://images2.imgbox.com/55/c3/BNg6xqCB_o.png" width="399"></p> 
<p>arr[ 3 ] [ 4 ] -- 表示创建一个3行4列的数组，第一个括号是行数，第二个括号是列数</p> 
<p><img alt="" height="244" src="https://images2.imgbox.com/7f/ff/GrTuz0sb_o.png" width="891"></p> 
<h3>初始化</h3> 
<p><img alt="" height="765" src="https://images2.imgbox.com/cb/0a/M8zvqviw_o.png" width="1200"></p> 
<p>  如上面的1，2，3，4，5个元素，我们进行不完全初始化，则二维数组会将已初始化的元素按顺序从左往右塞满一行，塞满一行后自动换行，然后初始化。其中未被我们主动初始化的元素被默认初始化为0</p> 
<p>另外值得注意的一点是！<strong> 每一行元素的下标都是从0开始的，行与行之间没有继承关系</strong><img alt="" height="730" src="https://images2.imgbox.com/da/f0/YfcVwziI_o.png" width="1200"></p> 
<p> 除了直接塞元素的初始化，我们也可以选择塞入一元数组来初始化，塞入的数组个数必须 &lt;= 行的个数，数组中的元素必须&lt;=列数</p> 
<p>二元数组中塞入一元数组后，从左往右数，第一行属于第一个数组，第二行属于第二个数组，一元数组中的元素进到行后再按顺序排放，未被主动初始化的元素默认被初始化为0</p> 
<p>元素型初始化和一元数组型初始化不能出现在同一个二元数组中</p> 
<p><img alt="" height="212" src="https://images2.imgbox.com/48/f6/XinXgGaY_o.png" width="835"></p> 
<p> 一元数组和二元数组的清零都是 ={0}</p> 
<h2 id="5.%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E4%BD%BF%E7%94%A8">5.二维数组的使用</h2> 
<p>二维数组的使用依然是通过下标引用操作符来访问数组中的元素的</p> 
<p>其中二维数组的行和列依然是从第零行和第零列开始的</p> 
<p><img alt="" height="424" src="https://images2.imgbox.com/91/d2/2MdnNlLY_o.png" width="1165"></p> 
<p> 输出二维数组的所有元素的方式两层循环的嵌套</p> 
<p><img alt="" height="598" src="https://images2.imgbox.com/00/7f/8t092xEv_o.png" width="836"></p> 
<p></p> 
<h2 id="6.%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E5%AD%98%E5%82%A8">6.二维数组在内存中的存储</h2> 
<p><img alt="" height="719" src="https://images2.imgbox.com/1b/b1/9KMbxRUD_o.png" width="553"></p> 
<p>二维数组中元素的地址 ，根据地址我们可以发现二维数组中内存的存放并不是我们想象中的矩阵类型存放，而是和一元数组一样的线性存放</p> 
<p><img alt="" height="662" src="https://images2.imgbox.com/52/35/A3JwGBXw_o.png" width="1062"></p> 
<p> <img alt="" height="657" src="https://images2.imgbox.com/76/19/VcAj5Dvc_o.png" width="1087"></p> 
<p> 二维数组的第 i 行看作一维数组时的数组名是arr[ i-1 ] ，为什么可以这样看呢，因为我们在访问第一行数组中的元素时，格式是 ： arr[ 1-1= 0] [ j - 1 ] --&gt; arr[ 0] [ j-1 ] j从1开始，而我们在一维数组中访问元素时则是 arr(数组名) [ n ] ，两相对比我们就可以将 arr[i-1] 作为二维数组arr[ i ] [ j ]中的i行被看作一维数组时的数组名</p> 
<p></p> 
<p>关于二维数组的数组名以及二数组元素的引用的补充</p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/41/a3/gW1gXCtv_o.png" width="1200"></p> 
<p>在二维数组中 ，</p> 
<p>其数组名arr指向的是第0行数组的地址</p> 
<p>arr + i是第i行数组的地址</p> 
<p>*arr指向的是第0行第0列元素的地址！！！</p> 
<p>*（arr+i）是第i行第0列的地址</p> 
<p>*（arr+i）+j -- 第i行第j列元素的地址</p> 
<p><a class="link-info" href="https://blog.csdn.net/qq_43428547/article/details/88956911" title="二维数组的指针">二维数组的指针</a></p> 
<p></p> 
<h2 id="7.%E6%95%B0%E7%BB%84%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0">7.数组作为函数参数</h2> 
<p>在我们写代码的时候，会将数组作为参数（数组可以作为参数）（实参）传给函数，比如我要实现一个冒泡排序函数将一个整型数组排序的时候，就会将数组作为参数传给冒泡排序函数。</p> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
void bubble_sort(int arr[])
{
    
}
int main()
{
    int arr[]={9,8,7,6,5,4,3,2,1};
//对arr进行排序，排成升序
    bubble_sort(arr);
// bubble 冒泡 sort 排序
// 要将数组排好序，首先要把数组这个参数传过去，传过去后再创建一个与实参数组相同类型的空数组接收进行copy
    return 0;
}</code></pre> 
<p>冒泡排序：</p> 
<p>1.排升/降序时，第一趟冒泡排序必然会将最大/最小的值排到最右边，因为冒泡排序的移动逻辑是</p> 
<p>从下标为0的元素与为1的元素比较，若0元素大于1元素二者交换位置，接着下标为1的元素继续比较，后面的依次类推</p> 
<p>否则，则不交换位置，但1元素继续与二元素比较，后面的依次类推</p> 
<p><strong>元素的交换与否不影响下标的前进</strong></p> 
<p>在这样的逻辑思路下我们可以发现排升/降序时，第一趟冒泡排序必然会将最大/最小的值排到最右边，第二趟冒泡排序必然将最大/最小的值排到次右边，依次类推，冒泡排序最多进行n-1趟，最少进行0趟。</p> 
<p>n个元素最对进行n*(n-1)/2次比较 ，等差数列求和 n个元素最多比较n-1次 ， n-1 - -n-2 ，....</p> 
<p>求和 0 +1 + 2+ 3+.... + n-1，总共有n项，等差数列求和公式：Sn=n*a1+n(n-1)d/2或Sn=n(a1（首项）+an（尾项）)/2 。”，首项为0，n为项数</p> 
<p>每一趟冒泡排序都能让一个元素回到对应的位置，当有n-1个元素回到正确的位置时，第n个元素只能呆在自己正确的位置（前提：每一个元素都有自己正确位置可以坐，但它们都做乱了），所以n个元素最多n-1趟冒泡</p> 
<p><img alt="" height="744" src="https://images2.imgbox.com/33/58/QgsMha5B_o.png" width="747"></p> 
<p>一趟一趟冒泡排序下来，泡会冒的越来越快 </p> 
<p>错误的冒泡排序程序实现如下：</p> 
<p><img alt="" height="515" src="https://images2.imgbox.com/4d/c2/5iokHpIe_o.png" width="652"></p> 
<p> <img alt="" height="191" src="https://images2.imgbox.com/53/7f/8ySkToCG_o.png" width="677"></p> 
<p>这一个冒泡排序的实现从算法的角度来看是没有错的，但是从语言的角度来看则是完全错误的。</p> 
<hr> 
<p>错误的根源就是对数组名最为函数参数传参时的错误理解。</p> 
<p>首先 </p> 
<p>当我们输入这样一个语句,并让计算机执行时，会发生什么呢？</p> 
<pre><code class="language-cpp">int arr[5]={0};</code></pre> 
<p>1.这样一个语句是在告诉计算机我们在创建一个拥有五个整型元素的数组（数组的类型声明与数组的元素一致，数组中只能有一种类型的元素）；</p> 
<p>2.计算机接收到我们的指令之后，会根据我们给出的元素个数内存区开辟5个整型（4个字节）的空间来存储数组中的元素，如果我们没有初始化元素的话，则默认存0；</p> 
<p>3.开辟完一个包含5个相同的大小的内存空间的数组空间之后，计算机会返回第一个元素的地址并将其存在我们设定的数组名之中。</p> 
<p>由3我们可以得出一个结论，那就是我们设定的数组名的本质其实是指针常量，即数组名 == &amp;arr[0] </p> 
<p>4.就这样我们得到了计算机返回的用来描述数组的其中一个重要参数 ： <strong>数组中的第一个元素的地址（这个第一个元素的地址被认为是对应数组的编码，通过查找这个编码我们就能找到对应的数组）</strong>，有了这个再加上我们自己设定的元素个数和下标引用操作符，我们就能够去访问数组中的元素了。</p> 
<p>（在内存空间中，用来存放元素的内存空间按照从左到右的顺序，以地址作为编号，以对应类型的空间大小地址递增排序，而在创建数组后得到的数组空间中，这些内存空间又被赋予了第二个编号 -- 下标，这些内存空间按照上面的顺序从0开始编号递增1排列）</p> 
<p>5.有了数组名，元素个数，下标引用操作符后我们就可以直接访问数组中的元素了</p> 
<p>如arr[1] 即访问arr中下标为1的元素 ，访问的实现方式是</p> 
<p>以arr这个指针常量中存的地址找到对应的数组空间，然后再在数组空间中找到对应下标的存储空间，然后输出存储在空间中的数据</p> 
<p>第一个元素的地址：编码1 --&gt; 找到对应的内存空间 ——&gt; 给定的下标（编码2）——&gt;找到对应的元素输出。</p> 
<p>另外无论一个一元数组，它的下标都是从0开始，那从哪里结束呢？答案是到元素个数减1结束。</p> 
<p>即 一个一元数组有n个元素，那么它的下标为  0  到（n-1）</p> 
<p><strong>综上：如果我们要找到一个数组中的所有元素，我们需要知道两个参数</strong></p> 
<p><strong>一个是第一个元素的地址，该地址被存放在指针常量 数组名中 -- 编码1--找到数组空间</strong></p> 
<p><strong>一个是数组中的元素个数，通过元素个数和下标的关系得到下标范围--此时下标确定--编码2--可找到所有元素，并通过下标引用操作符输出</strong></p> 
<hr> 
<p>当我们说把数组作为参数传给函数时，本质上我们是想把数组中的元素全都传给函数，并让函数可以访问，而要实现这个目的并不需要在调用函数时重新再开辟一个数组空间，然后copy所有元素，然后再把所有元素放进数组中，然后让函数进行访问，<strong>我们需要做的只是将数组名和元素个数作为参数传给函数即可</strong></p> 
<p><strong>这样，函数就可以通过数组名得到编码1直接访问已有数组空间，然后通过元素个数得到下标--代码2直接访问想要的元素，而不要费劲的进行重新copy这样费时费空间的做法</strong></p> 
<p>格式如下</p> 
<pre><code class="language-cpp">void stt(int(与传过来的数组的类型一致) arr[元素个数]（下标引用操作符及其中的内容与数组相同）)    
//我们将装有数组第一个元素地址的地址名传过来了，我们将元素个数传过来了
//此时相当于编码1和编码2都以到位，函数可以直接通过编码1和编码2访问和操作对应的数组
{
        
}

// 二维数组在传给函数元素的个数时并并不像一维数组一样只要1个参数就可以实现
//二维数组需要的是数组的行数和列数，这两个参数一乘就可以表示数组中元素的个数了
所以有
void add(int arr[a][b])二维数组 两个参数表示元素的个数 函数的实现
add(int arr[a]) 一维数组，一个参数表示元素的个数
数组作为实参时只要数组名即可
add(arr) 函数的使用</code></pre> 
<p>就这样通过这种方式我们便可以在函数中直接访问和操作函数外对应数组中的元素</p> 
<hr> 
<p>补充知识点：</p> 
<p>1.函数元素的个数的计算要提前算好才好传参，计算方法是 sizeof(arr)/sizeof(arr[0])</p> 
<p>（sizeof是用来计算类型，变量，数组等所占空间的大小的，单位是字节，其中一个字符占一个字节）</p> 
<p>欸看完上面那些后你就会发现问题出现了</p> 
<p>如果arr是一个指针常量（这个指针常量的类型为元素的类型＋*）的话，它的大小应该是4个字节（32位）（假设为整型），而一个整型元素所占的空间是4个字节，通过上面那个sizeof来求的话我们只能得到1，应该是得不到元素个数的啊！</p> 
<p>（补充一个知识点，指针+1 时对应的是指针中的地址 + 1*对应指针类型的字节大小，如32位下的整型指针+1的话，它里面的十六位进制的地址＋4）</p> 
<p><a class="link-info" href="https://shenmingyi.blog.csdn.net/article/details/93764074?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1.pc_relevant_default&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1.pc_relevant_default&amp;utm_relevant_index=2" rel="nofollow" title="指针的大小">指针的大小</a>，<a class="link-info" href="https://www.baidu.com/s?ie=utf-8&amp;f=8&amp;rsv_bp=1&amp;tn=baidu&amp;wd=int*%20%E7%9A%84%E5%A4%A7%E5%B0%8F&amp;oq=int*&amp;rsv_pq=d828bed50000d00b&amp;rsv_t=a2c6xhuiz8kDHn9MHTPshUgMuD9qcw%2Fn2V7ornR9WUEGTynH2%2Fn884om7aE&amp;rqlang=cn&amp;rsv_dl=tb&amp;rsv_enter=1&amp;rsv_btype=t&amp;inputT=3192&amp;rsv_sug2=0&amp;rsv_sug4=4474" rel="nofollow" title="各类型的大小">各类型的大小</a></p> 
<p>关于这个问题的解释就涉及到<strong>两个特例</strong></p> 
<p><strong>1.sizeof中单独放一个数组名的时候，我们认为sizeof计算的整个数组的大小，单位是字节</strong></p> 
<p><strong>2. &amp;数组名的时候，取出的是整个数组空间的地址（编码1），但在输出时仍输出第一个元素的地址，不过意思已经完全不同了，即已经变为了数组空间的地址（编码1），此时&amp;数组名+1，表示的是直接跳过整个数组名对应的数组空间后，输出紧邻数组空间的第一个内存空间的地址。</strong></p> 
<p><strong>除了以上两种情况以外，数组名都被看作是存放第一个元素的地址的指针常量</strong></p> 
<p></p> 
<p><strong>综上我们就可以得到正确的冒泡排序实现</strong></p> 
<p><img alt="" height="1181" src="https://images2.imgbox.com/87/74/UTRAgCT3_o.png" width="1200"></p> 
<p> 注意在冒泡排序时可以设置一个判断值，排第一次后，如果发生了交换，则判断值为0，继续进行下一趟冒泡，重复判断，如果不发生交换，则判断值为1，冒泡结束，已排完，这样子可以提升冒泡效率。</p> 
<hr> 
<p>动态数组的创建</p> 
<p>以整型一维数组为例</p> 
<p><img alt="" height="234" src="https://images2.imgbox.com/51/e5/x9aubSgM_o.png" width="788"></p> 
<p>n是我们想要的元素个数</p> 
<p>int* p; 创建一个整型指针 -- 数组名 -- 这一步还没有初始化 -- 初始化由下面那一行代码实现</p> 
<p>p = (int* 指针类型)malloc( n * sizeof(int) )  从堆中动态分配一组连续空间用来建立数组，同时返回该连续内存空间中的第一个内存空间的地址并用来初始化p -- 用来组建数组空间的大小 == n*(sizeof(int)) -- sizeof(int)是我们想建立的数组中单个元素所占的空间大小 -- n为元素个数 --</p> 
<p><strong>#include&lt;malloc.h&gt; -- 不要忘了这个头文件</strong></p> 
<p>//一些零散的笔记</p> 
<p>符合运算符</p> 
<p>a += n --&gt;   a = a+n ; 减同理</p> 
<p>a %= n  --&gt; a = a%n 乘除同理</p> 
<p>if else 的简写判断式子</p> 
<p>a = (a&gt;10? a : 0)</p> 
<p> 翻译： a是否大于10，是的化输出a ，否则输出0</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/eb24b948b409d7e0ac9c54c0dfac053b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">STM32cubeIDE初始化之IO口初始化</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a7699ca18876e1e4bd1e361e4cdc7bd0/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Linux重置MySQL8.0密码</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>