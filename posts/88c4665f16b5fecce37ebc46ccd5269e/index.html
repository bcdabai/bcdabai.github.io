<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>在Vue中，如何用lib模式发布自己的库代码 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="在Vue中，如何用lib模式发布自己的库代码" />
<meta property="og:description" content="使用lib模式打包 在vue-cli官网中有指出如何使用lib模式构建代码。
当你运行 vue-cli-service build 时，你可以通过 --target 选项指定不同的构建目标。它允许你将相同的源代码根据不同的用例生成不同的构建。
lib模式默认是不含有Vue的，若原代码中有vue，则会将原代码中的vue删除。
注意对 Vue 的依赖
在库模式中，Vue 是外置的。这意味着包中不会有 Vue，即便你在代码中导入了 Vue。如果这个库会通过一个打包器使用，它将尝试通过打包器以依赖的方式加载 Vue；否则就会回退到一个全局的 Vue 变量。
要避免此行为，可以在build命令中添加--inline-vue标志。
vue-cli-service build --target lib --inline-vue 核心命令——将一个单独的入口构建为一个库：
vue-cli-service build --target lib --name myLib [entry] 这个入口可以是一个 .js 或一个 .vue 文件。如果没有指定入口，则会使用 src/App.vue。我们只需要在指定的入口文件中export我们需要的模块即可。
例如：
export {default as Button} from &#39;./button/button&#39; export {default as Cascader} from &#39;./cascader/cascader&#39; export {default as CascaderItems} from &#39;./cascader/cascader-items&#39; export {default as GridRow} from &#39;./grid/row&#39; export {default as GridCol} from &#39;." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/88c4665f16b5fecce37ebc46ccd5269e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-06-29T16:55:33+08:00" />
<meta property="article:modified_time" content="2020-06-29T16:55:33+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">在Vue中，如何用lib模式发布自己的库代码</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>使用lib模式打包</h3> 
<p>在vue-cli官网中有指出如何使用lib模式构建代码。</p> 
<p>当你运行 <code>vue-cli-service build</code> 时，你可以通过 <code>--target</code> 选项指定不同的构建目标。它允许你将相同的源代码根据不同的用例生成不同的构建。</p> 
<p>lib模式默认是不含有Vue的，若原代码中有vue，则会将原代码中的vue删除。</p> 
<blockquote> 
 <p>注意对 Vue 的依赖</p> 
 <p>在库模式中，Vue 是<em>外置的</em>。这意味着包中不会有 Vue，即便你在代码中导入了 Vue。如果这个库会通过一个打包器使用，它将尝试通过打包器以依赖的方式加载 Vue；否则就会回退到一个全局的 <code>Vue</code> 变量。</p> 
 <p>要避免此行为，可以在<code>build</code>命令中添加<code>--inline-vue</code>标志。</p> 
 <pre><code>vue-cli-service build --target lib --inline-vue</code></pre> 
 <p> </p> 
</blockquote> 
<p>核心命令——将一个单独的入口构建为一个库：</p> 
<pre><code>vue-cli-service build --target lib --name myLib [entry]</code></pre> 
<p> 这个入口可以是一个 <code>.js</code> 或一个 <code>.vue</code> 文件。如果没有指定入口，则会使用 <code>src/App.vue</code>。我们只需要在指定的入口文件中export我们需要的模块即可。</p> 
<p>例如：</p> 
<pre><code class="language-javascript">export {default as Button} from './button/button'
export {default as Cascader} from './cascader/cascader'
export {default as CascaderItems} from './cascader/cascader-items'
export {default as GridRow} from './grid/row'
export {default as GridCol} from './grid/col'
export {default as Input} from './input/input'</code></pre> 
<p>构建一个库会输出：</p> 
<ul><li><code>dist/myLib.common.js</code>：一个给打包器用的 CommonJS 包 (不幸的是，webpack 目前还并没有支持 ES modules 输出格式的包)</li><li><code>dist/myLib.umd.js</code>：一个直接给浏览器或 AMD loader 使用的 UMD 包</li><li><code>dist/myLib.umd.min.js</code>：压缩后的 UMD 构建版本</li><li><code>dist/myLib.css</code>：提取出来的 CSS 文件 (可以通过在 <code>vue.config.js</code> 中设置 <code>css: { extract: false }</code> 强制内联)</li></ul> 
<p>将打包命令写入package.json中：</p> 
<pre><code class="language-javascript">"description": "一个基于vue的ui组件库",
  "main": "dist/Tione.umd.min.js",  //打包后的包入口文件
  "scripts": {
    "serve": "vue-cli-service serve",
    "build": "vue-cli-service build --target lib --name Tione src/index.js",
  },</code></pre> 
<p>打包出来的文件：</p> 
<p> <img alt="" height="161" src="https://images2.imgbox.com/1a/78/GP6zmoP3_o.png" width="390"></p> 
<p> </p> 
<h3>JS中的模块是什么</h3> 
<h4>1、立即执行函数</h4> 
<p>在js早期的时候，是没有模块的概念的，仅仅是一个个简单的脚本。js程序员们通过立即执行函数封装成一个个独立的局部作用域，这就是模块早期的雏形。</p> 
<h4>2、CommonJS</h4> 
<p>直到node.js的诞生，js可以写后台了，后台代码量大功能多，不得不需要封装成模块以便调用。而这个JS模块化标准称之为——CommonJS。</p> 
<p>CommonJS是同步的，同步的在node.js环境服务器中使用同步加载模块是没有问题的，但在浏览器中js是在html中异步加载资源的，CommonJS在浏览器中就不太使用了。</p> 
<p>代码风格：</p> 
<pre><code class="language-javascript">module;
module.exports=new hello();
</code></pre> 
<h4>3、AMD</h4> 
<p>requirejs模块化标准，我们称之为AMD。它是异步代码，适用于在浏览器中进行加载。</p> 
<p>代码风格：</p> 
<pre><code class="language-javascript">require(['vue'],function (Vue) {  //参数vue就是vue.js对外暴露的对象
    // 内容
    new Vue()
});</code></pre> 
<h4>4、import/export</h4> 
<p>ES6的新语法import/export，ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令<code>import</code>，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。换句话说，ES6 的<code>import</code>有点像 Unix 系统的“符号连接”，原始值变了，<code>import</code>加载的值也会跟着变。因此，ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。</p> 
<p>ES6在语言规格的层面上，实现了模块功能，而且实现得相当简单，完全可以取代现有的CommonJS和AMD规范，成为浏览器和服务器通用的模块解决方案。</p> 
<h4>5、UMD</h4> 
<p>umd是AMD和CommonJS的结合，即可异步也可同步。</p> 
<p>开发人员又想出另一个更通用的模式UMD （Universal Module Definition）。希望解决跨平台的解决方案。UMD先判断是否支持Node.js的模块（exports）是否存在，存在则使用Node.js模块模式。再判断是否支持AMD（define是否存在），存在则使用AMD方式加载模块。</p> 
<p> </p> 
<h3>webpack的环境判断</h3> 
<p>我们可以点开打包后的dist文件中以umd.js结尾的文件，看看webpack是如何进行环境判断的。</p> 
<pre><code class="language-javascript">(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' &amp;&amp; typeof module === 'object') //node.js
		module.exports = factory(require("vue"));
	else if(typeof define === 'function' &amp;&amp; define.amd) //AMD webpack 浏览器环境
		define([], factory);
	else if(typeof exports === 'object') //???
		exports["Tione"] = factory(require("vue"));
	else //root =&gt; window global 等等其它环境
		root["Tione"] = factory(root["Vue"]);  
})</code></pre> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ea060d5082295eb76ec84fd0c2fef551/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">pytorch 中 contiguous()</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/460c4da952ebd8327332734c64e607af/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">UnicodeDecodeError:&amp;acutegbk&amp; codec can&amp;t decode byte 0xbf in position 2: illegal multibyte sequence</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>