<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>[Zer0pts2020]easy strcmp 分析与加法 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="[Zer0pts2020]easy strcmp 分析与加法" />
<meta property="og:description" content="无壳，放入IDA自动跳到main函数
__int64 __fastcall main(int a1, char **a2, char **a3) { if ( a1 &gt; 1 ) { if ( !strcmp(a2[1], &#34;zer0pts{********CENSORED********}&#34;) ) puts(&#34;Correct!&#34;); else puts(&#34;Wrong!&#34;); } else { printf(&#34;Usage: %s &lt;FLAG&gt;\n&#34;, *a2); } return 0LL; } 条件明确，要求我们输入的字符串和如下字符串相同
zer0pts{********CENSORED********}
提交flag发现错误，显然没有那么容易；观察函数列表：
从sub_610到sub_795的一系列函数笔记碍眼，不妨一个个看一下，能够发现sub_6EA有着明显的逻辑：
__int64 __fastcall sub_6EA(__int64 a1, __int64 a2) { int i; // [rsp&#43;18h] [rbp-8h] int v4; // [rsp&#43;18h] [rbp-8h] int j; // [rsp&#43;1Ch] [rbp-4h] for ( i = 0; *(_BYTE *)(i &#43; a1); &#43;&#43;i ) ; v4 = (i &gt;&gt; 3) &#43; 1; for ( j = 0; j &lt; v4; &#43;&#43;j ) *(_QWORD *)(8 * j &#43; a1) -= qword_201060[j]; return qword_201090(a1, a2); } 但当我试图用IDA查看该函数的交叉引用，会发现提示：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/a9e2e9222b255ec2f075581dbbff1c24/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-06-23T12:13:43+08:00" />
<meta property="article:modified_time" content="2021-06-23T12:13:43+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">[Zer0pts2020]easy strcmp 分析与加法</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>    无壳，放入IDA自动跳到main函数</p> 
<pre><code class="language-cpp">__int64 __fastcall main(int a1, char **a2, char **a3)
{
  if ( a1 &gt; 1 )
  {
    if ( !strcmp(a2[1], "zer0pts{********CENSORED********}") )
      puts("Correct!");
    else
      puts("Wrong!");
  }
  else
  {
    printf("Usage: %s &lt;FLAG&gt;\n", *a2);
  }
  return 0LL;
}</code></pre> 
<p>    条件明确，要求我们输入的字符串和如下字符串相同</p> 
<blockquote> 
 <p>zer0pts{********CENSORED********}</p> 
</blockquote> 
<p>     提交flag发现错误，显然没有那么容易；观察函数列表：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/85/8d/3CvpJyMu_o.png"></p> 
<p>     从sub_610到sub_795的一系列函数笔记碍眼，不妨一个个看一下，能够发现sub_6EA有着明显的逻辑：</p> 
<pre><code class="language-cpp">__int64 __fastcall sub_6EA(__int64 a1, __int64 a2)
{
  int i; // [rsp+18h] [rbp-8h]
  int v4; // [rsp+18h] [rbp-8h]
  int j; // [rsp+1Ch] [rbp-4h]

  for ( i = 0; *(_BYTE *)(i + a1); ++i )
    ;
  v4 = (i &gt;&gt; 3) + 1;
  for ( j = 0; j &lt; v4; ++j )
    *(_QWORD *)(8 * j + a1) -= qword_201060[j];
  return qword_201090(a1, a2);
}</code></pre> 
<p>    但当我试图用IDA查看该函数的交叉引用，会发现提示：</p> 
<blockquote> 
 <p>Couldn't find any xrefs!</p> 
</blockquote> 
<p>    那这个函数岂不是没有被用到吗？不被执行还需要分析吗？</p> 
<p>    可以从init函数中找到答案：</p> 
<pre><code class="language-cpp">void __fastcall init(unsigned int a1, __int64 a2, __int64 a3)
{
  signed __int64 v4; // rbp
  __int64 i; // rbx

  v4 = &amp;off_200DF0 - &amp;funcs_889;
  init_proc();
  if ( v4 )
  {
    for ( i = 0LL; i != v4; ++i )
      ((void (__fastcall *)(_QWORD, __int64, __int64))*(&amp;funcs_889 + i))(a1, a2, a3);
  }
}</code></pre> 
<p>    for循环中调用了一系列的函数，而函数地址从funcs_889开始，跟入便能够发现如下内容：</p> 
<pre><code class="language-cpp">.init_array:0000000000200DE0 funcs_889       dq offset sub_6E0       ; DATA XREF: LOAD:00000000000000F8↑o
.init_array:0000000000200DE0                                         ; LOAD:0000000000000210↑o ...
.init_array:0000000000200DE8                 dq offset sub_795</code></pre> 
<p>    分别调用了sub_6E0和sub_795两个函数；上一个倒不值得关注，进入下面的那个看看：</p> 
<pre><code class="language-cpp">// write access to const memory has been detected, the output may be wrong!
int (**sub_795())(const char *s1, const char *s2)
{
  int (**result)(const char *, const char *); // rax

  result = &amp;strcmp;
  qword_201090 = (__int64 (__fastcall *)(_QWORD, _QWORD))&amp;strcmp;
  off_201028 = sub_6EA;
  return result;
}</code></pre> 
<p>     可见，off_201028被置为sub_6EA函数地址了</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/c6/03/IFTBxg4P_o.png"></p> 
<p>     可以看到，off_2010288实际上是strcmp函数的地址，但现在它被替换成了sub_6EA</p> 
<p>    因此我们执行strcmp函数时实际上是执行sub_6EA函数</p> 
<pre><code class="language-cpp">__int64 __fastcall sub_6EA(__int64 a1, __int64 a2)
{
  int i; // [rsp+18h] [rbp-8h]
  int v4; // [rsp+18h] [rbp-8h]
  int j; // [rsp+1Ch] [rbp-4h]

  for ( i = 0; *(_BYTE *)(i + a1); ++i )
    ;
  v4 = (i &gt;&gt; 3) + 1;
  for ( j = 0; j &lt; v4; ++j )
    *(_QWORD *)(8 * j + a1) -= qword_201060[j];
  return qword_201090(a1, a2);
}</code></pre> 
<p>    逻辑：将字符串每8个比特位减去一个数字</p> 
<pre><code class="language-cpp">.data:0000000000201060 qword_201060    dq 0, 410A4335494A0942h, 0B0EF2F50BE619F0h, 4F0A3A064A35282Bh</code></pre> 
<p>     那么解密脚本姑且是能够写出来了</p> 
<pre><code class="language-cpp">int main()
{
	char p[] = "zer0pts{********CENSORED********}";
	uint64 k[4] = { 0, 0x410A4335494A0942, 0x0B0EF2F50BE619F0, 0x4F0A3A064A35282B };
	for (int i = 0; i &lt; 4; i++)
	{
		*(uint64*)&amp;(p[i*8]) += k[i];
	}
	cout &lt;&lt; p;
} </code></pre> 
<p>    但是，我还是好奇这样一个字符串是如何实现大数加减法的，于是单步跟了进去</p> 
<p>    以 0x410A4335494A0942 为例，其二进制表达为：</p> 
<blockquote> 
 <p>100 0001 0000 1010 0100 0011 0011 0101 0100 1001 0100 1010 0000 1001 0100 0010</p> 
</blockquote> 
<p>    因为Intel是小端序的，所以从后面往前读</p> 
<blockquote> 
 <p>0100 0010-------&gt; 66(十进制)</p> 
</blockquote> 
<p>    而我们的flag变换字符为：</p> 
<blockquote> 
 <p>'*' (42)--------&gt;'I' (108)</p> 
</blockquote> 
<p>    相差正好为66；因此结果也变得显然了：</p> 
<p>    字符串大数相加的实现为：将大数做成多个字节，将每个字节与对应的字符串字符相加(指相同字节位对齐相加，多者溢出)</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/03e7aeb7866f33635a08ba8c84c6c25b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">计算机网络传输速度单位换算,网络速度单位换算</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5028e5eec7c34e98064199320d1e99e3/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">如何增强台式计算机无线网络,台式机无线网信号差怎么解决</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>