<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>GFS分布式文件系统（详解与配置） - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="GFS分布式文件系统（详解与配置）" />
<meta property="og:description" content="目录
存储
存储类型
存储技术的发展趋势：
存储在应用中的重要性：
文件系统
弹性 HASH 算法
优点
GlusterFs简述
概念
特点
术语
架构组件
模块化堆栈式架构
GlusterFS 的工作流程
GlusterFS的卷类型
卷实例
分布式卷示例
条带卷示例
复制卷示例
分布式条带卷示例
分布式复制卷示例
条带复制卷：
分布式条带复制卷：
仲裁卷：
部署GlusterFS 群集实例
环境准备
磁盘分区并挂载
配置/etc/hosts文件
安装、启动GlusterFS
添加节点到存储信任池中
创建卷
创建分布式卷
创建条带卷
创建复制卷
创建分布式条带卷
创建分布式复制卷
查看当前所有卷的列表
部署 Gluster 客户端
安装客户端软件
创建挂载目录
配置/etc/hosts文件
挂载 Gluster 文件系统
测试 Gluster 文件系统
破坏性测试
其他维护命令
存储 存储是计算机系统中用于保留数据、程序和信息的过程和设备。它包括了数据的永久性保存，以便在需要时可以检索、读取和操作。存储可以分为多种类型，包括：
存储类型 主存储 (RAM - Random Access Memory) 用于存储正在运行的程序、操作系统和当前需要的数据。
是临时性的，失去电源时数据会丢失。
辅助存储 硬盘驱动器 (HDD)：常见的机械式存储设备，以磁盘存储数据。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/1523869b09f4d760bba41007625dff22/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-12T09:08:10+08:00" />
<meta property="article:modified_time" content="2024-01-12T09:08:10+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">GFS分布式文件系统（详解与配置）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E5%AD%98%E5%82%A8-toc" style="margin-left:0px;"><a href="#%E5%AD%98%E5%82%A8" rel="nofollow">存储</a></p> 
<p id="-1-toc" style="margin-left:40px;"><a href="#-1" rel="nofollow">存储类型</a></p> 
<p id="-2-toc" style="margin-left:40px;"><a href="#-2" rel="nofollow">存储技术的发展趋势：</a></p> 
<p id="-3-toc" style="margin-left:40px;"><a href="#-3" rel="nofollow">存储在应用中的重要性：</a></p> 
<p id="-4-toc" style="margin-left:0px;"><a href="#-4" rel="nofollow">文件系统</a></p> 
<p id="hash-toc" style="margin-left:0px;"><a href="#hash" rel="nofollow">弹性 HASH 算法</a></p> 
<p id="-5-toc" style="margin-left:40px;"><a href="#-5" rel="nofollow">优点</a></p> 
<p id="glusterfs-toc" style="margin-left:0px;"><a href="#glusterfs" rel="nofollow">GlusterFs简述</a></p> 
<p id="-6-toc" style="margin-left:40px;"><a href="#-6" rel="nofollow">概念</a></p> 
<p id="-7-toc" style="margin-left:40px;"><a href="#-7" rel="nofollow">特点</a></p> 
<p id="-8-toc" style="margin-left:40px;"><a href="#-8" rel="nofollow">术语</a></p> 
<p id="-9-toc" style="margin-left:40px;"><a href="#-9" rel="nofollow">架构组件</a></p> 
<p id="-10-toc" style="margin-left:40px;"><a href="#-10" rel="nofollow">模块化堆栈式架构</a></p> 
<p id="glusterfs-1-toc" style="margin-left:40px;"><a href="#glusterfs-1" rel="nofollow">GlusterFS 的工作流程</a></p> 
<p id="glusterfs-2-toc" style="margin-left:40px;"><a href="#glusterfs-2" rel="nofollow">GlusterFS的卷类型</a></p> 
<p id="-11-toc" style="margin-left:80px;"><a href="#-11" rel="nofollow">卷实例</a></p> 
<p id="-12-toc" style="margin-left:120px;"><a href="#-12" rel="nofollow">分布式卷示例</a></p> 
<p id="-13-toc" style="margin-left:120px;"><a href="#-13" rel="nofollow">条带卷示例</a></p> 
<p id="-14-toc" style="margin-left:120px;"><a href="#-14" rel="nofollow">复制卷示例</a></p> 
<p id="-15-toc" style="margin-left:120px;"><a href="#-15" rel="nofollow">分布式条带卷示例</a></p> 
<p id="-16-toc" style="margin-left:120px;"><a href="#-16" rel="nofollow">分布式复制卷示例</a></p> 
<p id="-17-toc" style="margin-left:120px;"><a href="#-17" rel="nofollow">条带复制卷：</a></p> 
<p id="-18-toc" style="margin-left:120px;"><a href="#-18" rel="nofollow">分布式条带复制卷：</a></p> 
<p id="-19-toc" style="margin-left:120px;"><a href="#-19" rel="nofollow">仲裁卷：</a></p> 
<p id="glusterfs-3-toc" style="margin-left:0px;"><a href="#glusterfs-3" rel="nofollow">部署GlusterFS 群集实例</a></p> 
<p id="-20-toc" style="margin-left:40px;"><a href="#-20" rel="nofollow">环境准备</a></p> 
<p id="-21-toc" style="margin-left:40px;"><a href="#-21" rel="nofollow">磁盘分区并挂载</a></p> 
<p id="etchosts-toc" style="margin-left:40px;"><a href="#etchosts" rel="nofollow">配置/etc/hosts文件</a></p> 
<p id="glusterfs-4-toc" style="margin-left:40px;"><a href="#glusterfs-4" rel="nofollow">安装、启动GlusterFS</a></p> 
<p id="-22-toc" style="margin-left:40px;"><a href="#-22" rel="nofollow">添加节点到存储信任池中</a></p> 
<p id="-23-toc" style="margin-left:80px;"><a href="#-23" rel="nofollow">创建卷</a></p> 
<p id="-24-toc" style="margin-left:120px;"><a href="#-24" rel="nofollow">创建分布式卷</a></p> 
<p id="-25-toc" style="margin-left:120px;"><a href="#-25" rel="nofollow">创建条带卷</a></p> 
<p id="-26-toc" style="margin-left:120px;"><a href="#-26" rel="nofollow">创建复制卷</a></p> 
<p id="-27-toc" style="margin-left:120px;"><a href="#-27" rel="nofollow">创建分布式条带卷</a></p> 
<p id="-28-toc" style="margin-left:120px;"><a href="#-28" rel="nofollow">创建分布式复制卷</a></p> 
<p id="-29-toc" style="margin-left:120px;"><a href="#-29" rel="nofollow">查看当前所有卷的列表</a></p> 
<p id="gluster-toc" style="margin-left:80px;"><a href="#gluster" rel="nofollow">部署 Gluster 客户端</a></p> 
<p id="-30-toc" style="margin-left:120px;"><a href="#-30" rel="nofollow">安装客户端软件</a></p> 
<p id="-31-toc" style="margin-left:120px;"><a href="#-31" rel="nofollow">创建挂载目录</a></p> 
<p id="etchosts-1-toc" style="margin-left:120px;"><a href="#etchosts-1" rel="nofollow">配置/etc/hosts文件</a></p> 
<p id="gluster-1-toc" style="margin-left:120px;"><a href="#gluster-1" rel="nofollow">挂载 Gluster 文件系统</a></p> 
<p id="gluster-2-toc" style="margin-left:80px;"><a href="#gluster-2" rel="nofollow">测试 Gluster 文件系统</a></p> 
<p id="-32-toc" style="margin-left:80px;"><a href="#-32" rel="nofollow">破坏性测试</a></p> 
<p id="-33-toc" style="margin-left:0px;"><a href="#-33" rel="nofollow">其他维护命令</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E5%AD%98%E5%82%A8">存储</h2> 
<p>存储是计算机系统中用于保留数据、程序和信息的过程和设备。它包括了数据的永久性保存，以便在需要时可以检索、读取和操作。存储可以分为多种类型，包括：</p> 
<h3 id="-1">存储类型</h3> 
<ol><li><strong>主存储 (RAM - Random Access Memory)</strong></li></ol> 
<ul><li> <p>用于存储正在运行的程序、操作系统和当前需要的数据。</p> </li><li> <p>是临时性的，失去电源时数据会丢失。</p> </li></ul> 
<ol><li><strong>辅助存储</strong></li></ol> 
<ul><li> <p><strong>硬盘驱动器 (HDD)</strong>：常见的机械式存储设备，以磁盘存储数据。</p> </li><li> <p><strong>固态驱动器 (SSD)</strong>：使用闪存技术，速度更快且更耐用，适合提高性能要求。</p> </li></ul> 
<ol><li><strong>网络存储</strong></li></ol> 
<ul><li> <p><strong>网络附加存储 (NAS)</strong>：连接到网络并提供文件访问的设备。</p> </li><li> <p><strong>存储区域网络 (SAN)</strong>：高速网络连接多个存储设备，通常用于大规模数据存储和管理。</p> </li></ul> 
<ol><li><strong>云存储</strong></li></ol> 
<ul><li>基于云服务提供商的分布式存储，允许用户通过互联网存储和访问数据。</li></ul> 
<ol><li><strong>分布式文件系统</strong></li></ol> 
<ul><li>将数据分布式地存储在多个节点上，如GFS、HDFS（Hadoop分布式文件系统）等。</li></ul> 
<ol><li><strong>数据库</strong></li></ol> 
<ul><li>用于结构化和组织数据，提供高效的数据检索和管理。</li></ul> 
<h3 id="-2">存储技术的发展趋势：</h3> 
<ul><li> <p><strong>大规模存储</strong>：云存储和分布式文件系统满足了大规模数据的存储需求。</p> </li><li> <p><strong>快速、低延迟</strong>：SSD等新型存储介质提供更快的数据读写速度。</p> </li><li> <p><strong>数据安全</strong>：加密、备份和灾难恢复方面的技术进步。</p> </li><li> <p><strong>智能化管理</strong>：利用AI和机器学习优化存储资源的利用和管理。</p> </li></ul> 
<h3 id="-3">存储在应用中的重要性：</h3> 
<ul><li> <p><strong>数据处理</strong>：存储对于数据处理和计算至关重要，影响着效率和速度。</p> </li><li> <p><strong>数据安全</strong>：良好的存储系统可以保护数据不被损坏、丢失或被非法访问。</p> </li><li> <p><strong>大数据</strong>：存储是大数据时代不可或缺的一部分，需要高效、可扩展的存储系统来管理海量数据。</p> </li></ul> 
<p>存储技术的发展和创新对于计算机系统的性能、可靠性和可扩展性都有着深远的影响，因此存储一直是计算机科学领域的一个核心关注点。</p> 
<hr> 
<h2 id="-4">文件系统</h2> 
<p><img alt="" height="741" src="https://images2.imgbox.com/29/6f/MblGUqug_o.png" width="562"></p> 
<p>文件系统是操作系统中负责管理和组织存储设备上数据的一种机制。它定义了文件和目录的结构，提供了文件的创建、读取、写入、删除等操作。文件系统使得用户和应用程序能够方便地管理和访问存储在计算机上的数据。</p> 
<p>以下是文件系统的基本概念和组成部分：</p> 
<ol><li><strong>文件和目录：</strong></li></ol> 
<ul><li> <p><strong>文件（File）：</strong> 存储在存储设备上的数据单元，可以包含文本、图像、程序等。</p> </li><li> <p><strong>目录（Directory）：</strong> 用于组织和存储文件的容器，形成了层次结构。</p> </li></ul> 
<ol><li><strong>文件系统的基本操作：</strong></li></ol> 
<ul><li> <p><strong>创建（Create）：</strong> 新建文件或目录。</p> </li><li> <p><strong>读取（Read）：</strong> 从文件中获取数据。</p> </li><li> <p><strong>写入（Write）：</strong> 向文件中写入数据。</p> </li><li> <p><strong>删除（Delete）：</strong> 删除文件或目录。</p> </li></ul> 
<ol><li><strong>文件系统层次结构：</strong></li></ol> 
<ul><li> <p><strong>文件层次结构（File Hierarchy）：</strong> 文件和目录形成了一个层次结构，使得数据的组织更有序。</p> </li><li> <p><strong>路径（Path）：</strong> 描述文件或目录在文件系统中的位置。</p> </li></ul> 
<ol><li><strong>文件系统元数据：</strong></li></ol> 
<ul><li> <p><strong>文件描述符（File Descriptor）：</strong> 记录文件的基本属性，如大小、创建时间、修改时间等。</p> </li><li> <p><strong>索引节点（Inode）：</strong> 存储文件元数据的数据结构。</p> </li></ul> 
<ol><li><strong>磁盘管理：</strong></li></ol> 
<ul><li> <p><strong>簇或块（Cluster/Block）：</strong> 存储设备被划分为固定大小的块，文件被存储在这些块中。</p> </li><li> <p><strong>文件分配表（File Allocation Table，FAT）：</strong> 记录磁盘上每个簇的使用情况。</p> </li></ul> 
<ol><li><strong>文件系统类型：</strong></li></ol> 
<ul><li> <p><strong>FAT32、NTFS（Windows）：</strong> Windows操作系统常用的文件系统。</p> </li><li> <p><strong>ext4、XFS（Linux）：</strong> Linux操作系统中常见的文件系统。</p> </li><li> <p><strong>HFS+、APFS（macOS）：</strong> macOS操作系统使用的文件系统。</p> </li></ul> 
<ol><li><strong>文件系统安全性和权限：</strong></li></ol> 
<ul><li> <p><strong>权限管理（Permissions）：</strong> 控制用户对文件和目录的访问权限。</p> </li><li> <p><strong>加密（Encryption）：</strong> 保护文件内容的安全性。</p> </li></ul> 
<ol><li><strong>日志（Journaling）：</strong></li></ol> 
<ul><li><strong>事务日志（Transaction Log）：</strong> 记录文件系统的变更，以防止因突然断电等原因导致数据损坏。</li></ul> 
<ol><li><strong>网络文件系统（Network File System，NFS）：</strong></li></ol> 
<ul><li>允许远程计算机通过网络访问文件和目录。</li></ul> 
<ol><li><strong>分布式文件系统：</strong></li></ol> 
<ul><li>如Google的GFS、Hadoop的HDFS等，用于跨多个计算机节点的大规模数据存储和访问。</li></ul> 
<p>文件系统是计算机系统中非常重要的组成部分，不仅提供了对数据的有序管理，还涉及到数据的安全性、可靠性和性能等方面。各个操作系统使用不同的文件系统来满足其特定需求和功能。</p> 
<hr> 
<h2 id="hash">弹性 HASH 算法</h2> 
<p>"弹性哈希算法" 是一种用于实现数据分布和负载均衡的哈希算法，特别适用于分布式系统中的数据存储。这种算法允许动态地增加或减少节点，同时尽量保持已有数据在节点之间的平均分布，以提高系统的可伸缩性和性能。</p> 
<p>弹性哈希算法的基本思想是将数据和节点都映射到一个相同的哈希空间中，然后通过某种方式决定数据应该存储在哪个节点上。下面是弹性哈希算法的一般步骤：</p> 
<ol><li> <p><strong>确定哈希空间范围：</strong> 将哈希空间划分为一定范围，通常使用 0 到 2^32-1 或其他适当范围的哈希值。假设逻辑卷中有 N 个存储单位 Brick，则 32 位的整数范围将被划分为 N 个连续的子空间，每个空间对应一个 Brick。 当用户或应用程序访问某一个命名空间时，通过对该命名空间计算 HASH 值，根据该 HASH 值所对应的 32 位整数空间定位数据所在的 Brick。</p> </li><li> <p><strong>节点映射：</strong> 将每个节点通过哈希算法映射到哈希空间中的一个点。这个哈希算法可以是简单的散列函数。</p> </li><li> <p><strong>数据映射：</strong> 将要存储的数据也通过哈希算法映射到哈希空间中的一个点。</p> </li><li> <p><strong>找到最近的节点：</strong> 从数据所在的点开始，沿着哈希空间的方向寻找最近的节点。这个节点将被确定为存储该数据的节点。</p> </li><li> <p><strong>数据存储：</strong> 将数据存储在确定的节点上。</p> </li></ol> 
<h3 id="-5">优点</h3> 
<ol><li> <p><strong>动态扩展和收缩：</strong> 弹性哈希算法允许系统动态地添加或移除节点，而不会显著影响已有数据的分布。这使得系统更容易扩展，同时也提供了高度的灵活性。</p> </li><li> <p><strong>负载均衡：</strong> 弹性哈希算法有助于在节点数量变化时保持负载均衡。当节点增加或减少时，只有部分数据需要重新映射，而不是整个数据集，从而减小了系统的维护开销。</p> </li><li> <p><strong>减少数据迁移：</strong> 在节点发生变化时，弹性哈希算法通过仅将部分数据进行重新映射，而不是全部数据迁移，减少了数据迁移的开销。这对于大规模分布式系统而言非常重要，因为数据迁移可能是一项昂贵的操作。</p> </li><li> <p><strong>容错性：</strong> 弹性哈希算法对节点故障有一定的容错性。当节点发生故障时，仅需重新映射该节点上的部分数据，而不是整个数据集，从而减小了系统的脆弱性。</p> </li><li> <p><strong>简化路由：</strong> 弹性哈希算法通过在节点之间分配数据块，简化了数据的路由过程。每个节点负责处理一部分数据，使得在查找特定数据时，只需查询相应的节点，而不必搜索整个系统。</p> </li></ol> 
<p>总体而言，保证数据平均分布在每一个 Brick 中。解决了对元数据服务器的依赖，进而解决了单点故障以及访问瓶颈。</p> 
<h2 id="glusterfs">GlusterFs简述</h2> 
<h3 id="-6">概念</h3> 
<ol><li><strong>分布式架构：</strong></li></ol> 
<ul><li>GlusterFS采用分布式架构，允许用户将数据存储在多个节点上，以实现横向扩展和高性能。</li></ul> 
<ol><li><strong>横向扩展性：</strong></li></ol> 
<ul><li>可以通过添加新的存储节点来扩展存储容量和性能，使系统适应不断增长的数据需求。</li></ul> 
<ol><li><strong>存储卷（Volume）：</strong></li></ol> 
<ul><li>GlusterFS通过存储卷的概念来组织和管理数据。存储卷是由多个存储节点组成的逻辑存储单元。</li></ul> 
<ol><li><strong>复制和条带化：</strong></li></ol> 
<ul><li>GlusterFS支持数据的复制和条带化，以提高数据的冗余性和读写性能。</li></ul> 
<ol><li><strong>弹性/动态伸缩：</strong></li></ol> 
<ul><li>能够动态添加或删除存储节点，系统会自动重新平衡数据以确保负载均衡。</li></ul> 
<ol><li><strong>统一命名空间：</strong></li></ol> 
<ul><li>提供一个统一的命名空间，使用户和应用程序可以方便地访问存储卷中的数据。</li></ul> 
<ol><li><strong>透明性和一致性：</strong></li></ol> 
<ul><li>对用户而言，GlusterFS提供透明的文件和目录访问，同时确保数据的一致性。</li></ul> 
<ol><li><strong>原子操作和事务：</strong></li></ol> 
<ul><li>支持原子操作和事务，确保对存储卷的修改是原子的和可靠的。</li></ul> 
<ol><li><strong>集群管理和监控：</strong></li></ol> 
<ul><li>提供管理工具和监控机制，帮助管理员轻松地管理和监视GlusterFS集群。</li></ul> 
<ol><li><strong>开源和社区支持：</strong></li></ol> 
<ul><li>作为开源项目，GlusterFS允许用户根据需要自由使用、修改和分发。同时，有活跃的社区提供支持和贡献新的功能。</li></ul> 
<ol><li><strong>应用领域：</strong></li></ol> 
<ul><li>适用于需要大规模、高性能、高可用性存储的场景，如云存储、大数据分析等。</li></ul> 
<p>GlusterFS的设计理念是通过横向扩展和分布式存储来满足现代数据存储和处理的需求，使得用户能够构建可靠、高性能的存储基础设施。</p> 
<h3 id="-7">特点</h3> 
<ol><li> <p><strong>横向扩展性：</strong> GlusterFS具有良好的横向扩展性，可以轻松地扩展到数PB的存储容量和数千个客户端。Scale-Out架构允许通过简单地增加存储节点的方式来提高存储容量和性能（磁盘、计算和I/O资源都可以独立增加），支持10GbE和 InfiniBand等高速网络互联。Gluster弹性哈希（ElasticHash）解决了GlusterFS对元数据服务器的依赖，改善了单点故障和性能瓶颈，真正实现了并行化数据访问。GlusterFS采用弹性哈希算法在存储池中可以智能地定位任意数据分片（将数据分片存储在不同节点上），不需要查看索引或者向元数据服务器查询。</p> </li><li> <p><strong>容错性和高可用性：</strong> GlusterFS通过数据复制和分布式存储的方式提供容错性和高可用性。数据可以在多个节点上复制，确保在节点故障时仍然可以访问数据。此外，它支持自动的数据自愈机制，即修复由于节点故障导致的数据损坏。</p> </li><li> <p><strong>灵活的部署选项：</strong> GlusterFS支持多种部署模式，包括分布式、条带（striping）、复制、条带复制等。这使得它可以根据特定的使用场景和性能需求进行灵活配置，满足不同应用的要求。</p> </li><li> <p><strong>统一命名空间：</strong> GlusterFS提供了一个统一的命名空间，允许用户以常规文件系统的方式访问分布式文件系统中的文件。分布式存储中，将所有节点的命名空间整合为统一命名空间，将整个系统的所有节点的存储容量组成一个大的虚拟存储池，供前端主机访问这些节点完成数据读写操作。</p> </li><li> <p><strong>协议支持：</strong> GlusterFS支持多种协议，包括NFS（Network File System）、CIFS（Common Internet File System）等，使得它能够与不同类型的客户端和应用程序无缝集成。</p> </li><li> <p><strong>弹性和动态性：</strong> GlusterFS允许在运行时动态添加或删除存储节点，从而实现弹性和动态性。通过将数据储存在逻辑卷中，逻辑卷从逻辑存储池进行独立逻辑划分而得到。 逻辑存储池可以在线进行增加和移除，不会导致业务中断。逻辑卷可以根据需求在线增长和缩减，并可以在多个节点中实现负载均衡。</p> </li><li> <p><strong>开源和社区支持：</strong> 作为开源项目，GlusterFS得到了广泛的社区支持。用户可以通过社区获得支持、参与开发，以及访问详细的文档和资源。</p> </li></ol> 
<p>总体而言，GlusterFS适用于许多不同的应用场景，特别是需要横向扩展、高可用性和容错性的大规模分布式存储需求。</p> 
<h3 id="-8">术语</h3> 
<ol><li> <p><strong>砖（Brick）：</strong> 指可信主机池中由主机提供的用于物理存储的专用分区，是GlusterFS中的基本存储单元，同时也是可信存储池中服务器上对外提供的存储目录。 存储目录的格式由服务器和目录的绝对路径构成，表示方法为 <code>SERVER:EXPORT</code>，如 <code>192.168.80.10:/data/mydir/</code>。</p> </li><li> <p><strong>卷（Volume）：</strong> 在GlusterFS中，卷是一个由多个存储服务器组成的逻辑存储单元。它表示一个完整的分布式文件系统，用户可以通过卷来进行数据访问和管理。</p> </li><li> <p><strong>存储池（Storage Pool）：</strong> 存储池是一组物理存储设备，它们被组合在一起以提供数据冗余和高可用性。砖通常存储在这些存储池中。</p> </li><li> <p><strong>复制（Replication）：</strong> 复制是一种数据冗余机制，通过在不同的节点上保存数据的多个副本来增加系统的可靠性。在GlusterFS中，复制是通过配置卷的方式实现的。</p> </li><li> <p><strong>条带（Striping）：</strong> 条带是将文件分成固定大小的块并分布在多个砖上的过程。这有助于提高文件的读写性能，因为可以并行地从多个砖上读取或写入数据。</p> </li><li> <p><strong>客户端（Client）：</strong> 客户端是连接到GlusterFS卷并访问存储的计算机或设备。它可以是一个应用程序、操作系统或其他支持GlusterFS协议的实体。</p> </li><li> <p><strong>GNFS（Gluster Native File System）：</strong> GNFS是GlusterFS的本地文件系统，它提供了类似于POSIX的文件系统接口，并允许应用程序直接通过本地文件系统访问GlusterFS。</p> </li><li> <p><strong>分布式文件系统（Distributed File System）：</strong> GlusterFS是一种分布式文件系统，它通过将数据分布在多个节点上来提供高性能和可扩展性。</p> </li><li> <p><strong>存储卷管理器（Volume Manager）：</strong> 存储卷管理器负责卷的创建、删除和管理。它是GlusterFS的组件之一，用于配置和维护卷的状态。</p> </li></ol> 
<h3 id="-9">架构组件</h3> 
<ol><li><strong>FUSE（Filesystem in Userspace）：</strong></li></ol> 
<ul><li> <p><strong>定义：</strong> FUSE是一个用户空间文件系统的框架，允许非特权用户在用户空间中实现文件系统。通过FUSE，文件系统的实现不需要修改内核，而是在用户空间中运行。</p> </li><li> <p><strong>在GlusterFS中的应用：</strong> GlusterFS可以利用FUSE来提供用户空间文件系统，使得可以在没有特殊内核模块的情况下运行GlusterFS。这种方式使得GlusterFS可以更容易地被集成到各种操作系统中。</p> </li></ul> 
<ol><li><strong>VFS（Virtual File System）：</strong></li></ol> 
<ul><li> <p><strong>定义：</strong> VFS是操作系统内核中的抽象层，用于提供对不同文件系统的统一接口。它允许应用程序使用相同的系统调用来访问不同类型的文件系统，而不必关心底层文件系统的细节。</p> </li><li> <p><strong>在GlusterFS中的应用：</strong> GlusterFS通过VFS模块与操作系统内核进行交互。这样，用户可以像使用本地文件系统一样访问分布式的GlusterFS文件系统，而VFS层会负责将这些操作转发到GlusterFS的实现。</p> </li></ul> 
<ol><li><strong>Glusterd：</strong></li></ol> 
<ul><li> <p><strong>定义：</strong> Glusterd是GlusterFS的管理守护进程，负责管理和维护GlusterFS集群的状态，以及执行一些基本的管理任务。</p> </li><li> <p><strong>在GlusterFS中的应用：</strong> Glusterd用于卷的创建、修改和删除，以及对存储池和砖的管理。它协调集群中各个节点的操作，并确保卷的一致性和可靠性。Glusterd起到了集群管理的关键作用。</p> </li></ul> 
<h3 id="-10">模块化堆栈式架构</h3> 
<p>GlusterFS 采用模块化、堆栈式的架构。 通过对模块进行各种组合，即可实现复杂的功能。例如 Replicate 模块可实现 RAID1，Stripe 模块可实现 RAID0， 通过两者的组合可实现 RAID10 和 RAID01，同时获得更高的性能及可靠性。</p> 
<ol><li> <p><strong>模块化：</strong> 意味着系统被分解成相对独立、可重用、易于维护的模块。每个模块负责一个明确定义的功能，而且模块之间的耦合度较低，这样可以提高代码的可读性和可维护性。</p> </li><li> <p><strong>堆栈式：</strong> 意味着这些模块被组织成一种层次结构，形成一个堆栈。每一层都有特定的职责和功能，而且模块在堆栈中按照一定的顺序进行组织。这有助于清晰地定义系统中不同层次的责任和交互。</p> </li></ol> 
<p>在 GlusterFS 的背景下，模块化堆栈式架构包括以下组件：</p> 
<ul><li> <p><strong>底层存储模块：</strong> 处理底层存储设备的模块，负责与硬件通信、数据读写等底层操作。</p> </li><li> <p><strong>分布式存储模块：</strong> 处理分布式存储的模块，负责数据分发、复制、一致性等任务。</p> </li><li> <p><strong>网络通信模块：</strong> 处理节点之间的通信，确保数据在集群中的传输是可靠和高效的。</p> </li><li> <p><strong>卷管理模块：</strong> 负责管理 GlusterFS 卷的模块，包括卷的创建、配置、修改和删除。</p> </li><li> <p><strong>用户接口模块：</strong> 提供用户接口，让用户可以通过不同的协议（如NFS、FUSE等）与 GlusterFS 交互。</p> </li></ul> 
<p>每个模块都有清晰的接口定义，使得它们可以相对独立地开发、测试和维护。整个系统通过这些模块协同工作，提供了一个高度可扩展和灵活的分布式存储解决方案。这种模块化和堆栈式的设计模式有助于满足不同应用场景下的需求。</p> 
<h3 id="glusterfs-1">GlusterFS 的工作流程</h3> 
<ol><li><strong>卷的创建：</strong></li></ol> 
<ul><li> <p>管理员使用 Gluster CLI（命令行界面）或其他管理工具创建一个 GlusterFS 卷。</p> </li><li> <p>卷的创建涉及选择存储池、添加砖（Brick）等配置。</p> </li></ul> 
<ol><li><strong>存储池的配置：</strong></li></ol> 
<ul><li> <p>存储池（Storage Pool）是由多个物理存储设备组成的逻辑单元。这些存储设备可以是硬盘、SSD 等。</p> </li><li> <p>管理员配置存储池，将多个存储设备添加到存储池中，为后续卷的创建提供基础。</p> </li></ul> 
<ol><li><strong>砖的配置：</strong></li></ol> 
<ul><li> <p>Brick 是 GlusterFS 存储的基本单元，通常对应一个物理存储服务器上的目录或磁盘。</p> </li><li> <p>在存储池中选择存储设备，并配置这些设备为砖，作为 GlusterFS 存储的一部分。</p> </li></ul> 
<ol><li><strong>卷的启动：</strong></li></ol> 
<ul><li>通过 Glusterd，管理员启动创建好的卷，让 GlusterFS 开始管理和分发数据。</li></ul> 
<ol><li><strong>分布式存储：</strong></li></ol> 
<ul><li>GlusterFS 使用分布式存储机制将数据分散存储在多个砖上。这增加了存储容量、提高了性能，并提供了数据冗余。</li></ul> 
<ol><li><strong>数据复制/条带化：</strong></li></ol> 
<ul><li>根据卷的配置，GlusterFS 可以使用复制机制（Replication）或条带化（Striping）来处理数据。复制提供数据冗余，而条带化则有助于提高性能。</li></ul> 
<ol><li><strong>网络通信：</strong></li></ol> 
<ul><li>GlusterFS 节点之间通过网络通信交换数据。TCP/IP 等协议用于确保数据在节点之间的可靠传输。</li></ul> 
<ol><li><strong>客户端访问：</strong></li></ol> 
<ul><li>客户端通过支持的协议（例如 NFS、FUSE）连接到 GlusterFS 卷。这可以在客户端系统中挂载 GlusterFS 文件系统。</li></ul> 
<ol><li><strong>用户访问和操作：</strong></li></ol> 
<ul><li>用户可以像访问本地文件系统一样，通过文件路径进行读写、创建和删除文件等操作。GlusterFS 的用户接口模块负责处理客户端请求。</li></ul> 
<ol><li><strong>卷的管理和监控：</strong></li></ol> 
<ul><li>管理员可以使用 Gluster CLI 或其他管理工具监控和管理卷的状态，进行调整和优化配置。</li></ul> 
<p>（1）客户端或应用程序通过 GlusterFS 的挂载点访问数据。 （2）linux系统内核通过 VFS API 收到请求并处理。 （3）VFS 将数据递交给 FUSE 内核文件系统，并向系统注册一个实际的文件系统 FUSE，而 FUSE 文件系统则是将数据通过 /dev/fuse 设备文件递交给了 GlusterFS client 端。可以将 FUSE 文件系统理解为一个代理。 （4）GlusterFS client 收到数据后，client 根据配置文件的配置对数据进行处理。 （5）经过 GlusterFS client 处理后，通过网络将数据传递至远端的 GlusterFS Server，并且将数据写入到服务器存储设备上。</p> 
<h3 id="glusterfs-2">GlusterFS的卷类型</h3> 
<p>GlusterFS支持多种卷类型，每种类型都有不同的特性，以满足不同应用场景的需求。以下是GlusterFS支持的主要卷类型：</p> 
<ol><li> <p><strong>Distribute卷（分布式卷）：</strong> 这是GlusterFS的默认卷类型。在分布式卷中，文件被平均地分布在各个存储服务器上，没有对文件进行分块处理。这种卷类型适用于需要简单的横向扩展的场景。</p> </li><li> <p><strong>Stripe卷（条带卷）：</strong> Stripe卷将文件分成固定大小的条带，并将这些条带分布在各个存储服务器上。这有助于提高文件的读/写性能，特别是对于大文件而言。</p> </li><li> <p><strong>Replica卷（复制卷）：</strong> 在Replica卷中，文件的多个副本存储在不同的存储服务器上。这提供了高可用性，因为即使某个存储服务器发生故障，数据仍然可以从其他副本中访问。</p> </li><li> <p><strong>Distribute Stripe卷（分布式条带卷）：</strong> 这是Distribute和Stripe两种卷类型的结合，文件被分成条带并分布在各个存储服务器上。</p> </li><li> <p><strong>Distribute Replica卷（分布式复制卷）：</strong> 这是Distribute和Replica两种卷类型的结合，文件被复制到多个存储服务器上，并且分布在这些服务器上。</p> </li><li> <p><strong>Distribute Stripe Replica卷（分布式条带复制卷）：</strong> 这是Distribute、Stripe和Replica三种卷类型的结合，结合了条带化和数据复制，提供了高性能和高可用性。</p> </li><li> <p><strong>Arbiter卷（仲裁卷）：</strong> 在Arbiter卷中，文件的一个副本存储在额外的仲裁节点上，而不是在数据节点上。这有助于减少数据副本的数量，节省存储空间。</p> </li></ol> 
<h4 id="-11">卷实例</h4> 
<h5 id="-12">分布式卷示例</h5> 
<ul><li> <p>文件通过 HASH 算法分布到所有 Brick Server 上，这种卷是 GlusterFS 的默认卷；以文件为单位根据 HASH 算法散列到不同的 Brick，其实只是扩大了磁盘空间，如果有一块磁盘损坏，数据也将丢失，属于文件级的 RAID0， 不具有容错能力。</p> </li><li> <p>在该模式下，并没有对文件进行分块处理，文件直接存储在某个 Server 节点上。 由于直接使用本地文件系统进行文件存储，所以存取效率并没有提高，反而会因为网络通信的原因而有所降低。</p> </li></ul> 
<pre><code>#示例原理：
File1 和 File2 存放在 Server1，而 File3 存放在 Server2，文件都是随机存储，一个文件（如 File1）要么在 Server1 上，要么在 Server2 上，不能分块同时存放在 Server1和 Server2 上。

#分布式卷具有如下特点：
文件分布在不同的服务器，不具备冗余性。
更容易和廉价地扩展卷的大小。
单点故障会造成数据丢失。
依赖底层的数据保护。

#创建一个名为dis-volume的分布式卷，文件将根据HASH分布在server1:/dir1、server2:/dir2和server3:/dir3中
gluster volume create dis-volume server1:/dir1 server2:/dir2 server3:/dir3
</code></pre> 
<h5 id="-13">条带卷示例</h5> 
<ul><li>类似 RAID0，文件被分成数据块并以轮询的方式分布到多个 Brick Server 上，文件存储以数据块为单位，支持大文件存储， 文件越大，读取效率越高，但是不具备冗余性。</li></ul> 
<pre><code>#示例原理：
File 被分割为 6 段，1、3、5 放在 Server1，2、4、6 放在 Server2。

#条带卷特点：
数据被分割成更小块分布到块服务器群中的不同条带区。
分布减少了负载且更小的文件加速了存取的速度。
没有数据冗余。

#创建了一个名为stripe-volume的条带卷，文件将被分块轮询的存储在Server1:/dir1和Server2:/dir2两个Brick中
gluster volume create stripe-volume stripe 2 transport tcp server1:/dir1 server2:/dir2
</code></pre> 
<h5 id="-14">复制卷示例</h5> 
<ul><li> <p>将文件同步到多个 Brick 上，使其具备多个文件副本，属于文件级 RAID 1，具有容错能力。因为数据分散在多个 Brick 中，所以读性能得到很大提升，但写性能下降。</p> </li><li> <p>复制卷具备冗余性，即使一个节点损坏，也不影响数据的正常使用。但因为要保存副本，所以磁盘利用率较低。</p> </li></ul> 
<pre><code>#示例原理：
File1 同时存在 Server1 和 Server2，File2 也是如此，相当于 Server2 中的文件是 Server1 中文件的副本。

#复制卷特点：
卷中所有的服务器均保存一个完整的副本。
卷的副本数量可由客户创建的时候决定，但复制数必须等于卷中 Brick 所包含的存储服务器数。
至少由两个块服务器或更多服务器。
具备冗余性。

#创建名为rep-volume的复制卷，文件将同时存储两个副本，分别在Server1:/dir1和Server2:/dir2两个Brick中
gluster volume create rep-volume replica 2 transport tcp server1:/dir1 server2:/dir2
</code></pre> 
<h5 id="-15">分布式条带卷示例</h5> 
<ul><li>Brick Server 数量是条带数（数据块分布的 Brick 数量）的倍数，兼具分布式卷和条带卷的特点。 主要用于大文件访问处理，创建一个分布式条带卷最少需要 4 台服务器。</li></ul> 
<pre><code>#示例原理：
File1 和 File2 通过分布式卷的功能分别定位到Server1和 Server2。在 Server1 中，File1 被分割成 4 段，其中 1、3 在 Server1 中的 exp1 目录中，2、4 在 Server1 中的 exp2 目录中。在 Server2 中，File2 也被分割成 4 段，其中 1、3 在 Server2 中的 exp3 目录中，2、4 在 Server2 中的 exp4 目录中。

#创建一个名为dis-stripe的分布式条带卷，配置分布式的条带卷时，卷中Brick所包含的存储服务器数必须是条带数的倍数（&gt;=2倍）。Brick 的数量是 4（Server1:/dir1、Server2:/dir2、Server3:/dir3 和 Server4:/dir4），条带数为 2（stripe 2）
gluster volume create dis-stripe stripe 2 transport tcp server1:/dir1 server2:/dir2 server3:/dir3 server4:/dir4

创建卷时，存储服务器的数量如果等于条带或复制数，那么创建的是条带卷或者复制卷；如果存储服务器的数量是条带或复制数的 2 倍甚至更多，那么将创建的是分布式条带卷或分布式复制卷。
</code></pre> 
<h5 id="-16">分布式复制卷示例</h5> 
<ul><li>Brick Server 数量是镜像数（数据副本数量）的倍数，兼具分布式卷和复制卷的特点。主要用于需要冗余的情况下。</li></ul> 
<pre><code>#示例原理：
File1 和 File2 通过分布式卷的功能分别定位到 Server1 和 Server2。在存放 File1 时，File1 根据复制卷的特性，将存在两个相同的副本，分别是 Server1 中的exp1 目录和 Server2 中的 exp2 目录。在存放 File2 时，File2 根据复制卷的特性，也将存在两个相同的副本，分别是 Server3 中的 exp3 目录和 Server4 中的 exp4 目录。

#创建一个名为dis-rep的分布式复制卷，配置分布式的复制卷时，卷中Brick所包含的存储服务器数必须是复制数的倍数（&gt;=2倍）。Brick 的数量是 4（Server1:/dir1、Server2:/dir2、Server3:/dir3 和 Server4:/dir4），复制数为 2（replica 2）
gluster volume create dis-rep replica 2 transport tcp server1:/dir1 server2:/dir2 server3:/dir3 server4:/dir4
</code></pre> 
<h5 id="-17">条带复制卷：</h5> 
<ul><li> <p>在条带复制卷中，数据被分成条带，并且每个条带都有多个副本。这提供了高性能和高可用性。</p> </li><li> <p>类似 RAID 10，同时具有条带卷和复制卷的特点。</p> </li></ul> 
<pre><code># 创建一个包含两个存储服务器的条带复制卷
$ gluster volume create stripe_replica_vol stripe 2 replica 2 transport tcp server1:/data/brick1 server2:/data/brick1

# 启动卷
$ gluster volume start stripe_replica_vol
</code></pre> 
<p>在上述示例中，<code>stripe</code>参数指定为2，表示使用条带化，<code>replica</code>参数指定为2，表示每个条带有两个副本。<code>server1</code>和<code>server2</code>是两个存储服务器的主机名，<code>/data/brick1</code>是存储卷的路径。</p> 
<h5 id="-18">分布式条带复制卷：</h5> 
<ul><li> <p>分布式条带复制卷是条带复制卷和分布式卷的结合，既具有条带的性能优势，又具有数据在多个存储服务器上的分布式特性。</p> </li><li> <p>三种基本卷的复合卷，通常用于类 Map Reduce 应用。</p> </li></ul> 
<pre><code># 创建一个包含两个存储服务器的分布式条带复制卷
$ gluster volume create distribute_stripe_replica_vol disperse 2 stripe 2 transport tcp server1:/data/brick1 server2:/data/brick1

# 启动卷
$ gluster volume start distribute_stripe_replica_vol
</code></pre> 
<p>在上述示例中，<code>disperse</code>参数指定为2，表示使用分布式，<code>stripe</code>参数指定为2，表示使用条带化。其他参数和配置与条带复制卷类似。</p> 
<h5 id="-19">仲裁卷：</h5> 
<p>仲裁卷在其中一个独立节点上存储数据的一个副本，用于提高系统的容错性。</p> 
<pre><code># 创建一个包含仲裁节点的仲裁卷
$ gluster volume create arbiter_vol replica 2 arbiter 1 transport tcp server1:/data/brick1 server2:/data/brick1 server3:/data/brick1

# 启动卷
$ gluster volume start arbiter_vol
</code></pre> 
<hr> 
<h2 id="glusterfs-3">部署GlusterFS 群集实例</h2> 
<h3 id="-20">环境准备</h3> 
<pre><code>Node1节点：node1/192.168.41.31          磁盘：/dev/sdb1          挂载点：/data/sdb1
                                            /dev/sdc1                   /data/sdc1
                                            /dev/sdd1                   /data/sdd1
                                            /dev/sde1                   /data/sde1

Node2节点：node2/192.168.41.32          磁盘：/dev/sdb1          挂载点：/data/sdb1
                                            /dev/sdc1                   /data/sdc1
                                            /dev/sdd1                   /data/sdd1
                                            /dev/sde1                   /data/sde1

Node3节点：node3/192.168.41.33          磁盘：/dev/sdb1          挂载点：/data/sdb1
                                            /dev/sdc1                   /data/sdc1
                                            /dev/sdd1                   /data/sdd1
                                            /dev/sde1                   /data/sde1

Node4节点：node4/192.168.41.34          磁盘：/dev/sdb1          挂载点：/data/sdb1
                                            /dev/sdc1                   /data/sdc1
                                            /dev/sdd1                   /data/sdd1
                                            /dev/sde1                   /data/sde1

客户端节点：192.168.10.11 
</code></pre> 
<pre><code>systemctl stop firewalld
setenforce 0
</code></pre> 
<h3 id="-21">磁盘分区并挂载</h3> 
<pre><code>vim /opt/fdisk.sh
#!/bin/bash
NEWDEV=`ls /dev/sd* | grep -o 'sd[b-z]' | uniq`
for VAR in $NEWDEV
do
   echo -e "n\np\n\n\n\nw\n" | fdisk /dev/$VAR &amp;&gt; /dev/null
   mkfs.xfs /dev/${VAR}"1" &amp;&gt; /dev/null
   mkdir -p /data/${VAR}"1" &amp;&gt; /dev/null
   echo "/dev/${VAR}"1" /data/${VAR}"1" xfs defaults 0 0" &gt;&gt; /etc/fstab
done
mount -a &amp;&gt; /dev/null

chmod +x /opt/fdisk.sh
cd /opt/
./fdisk.sh
</code></pre> 
<pre><code>vim /opt/fdisk.sh
</code></pre> 
<p>在/opt目录下创建并编辑fdisk.sh文件。</p> 
<pre><code>#!/bin/bash
</code></pre> 
<p>指定脚本解释器为bash。</p> 
<pre><code>NEWDEV=`ls /dev/sd* | grep -o 'sd[b-z]' | uniq`
</code></pre> 
<p>通过ls命令获取所有以sd开头的设备，然后使用grep筛选出sd后跟有字母b到z的设备，最后通过uniq去重。结果存储在NEWDEV变量中。</p> 
<pre><code>for VAR in $NEWDEV
do
</code></pre> 
<p>对NEWDEV中的每个设备执行以下操作。</p> 
<pre><code>   echo -e "n\np\n\n\n\nw\n" | fdisk /dev/$VAR &amp;&gt; /dev/null
</code></pre> 
<p>使用echo命令向fdisk发送一系列的命令，创建新分区。这些命令是：n（新建分区）、p（主分区）、回车（默认分区号）、回车（默认起始扇区）、回车（默认结束扇区）、w（写入并退出）。&amp;&gt; /dev/null用于将输出重定向到/dev/null，以避免显示输出。</p> 
<pre><code>   mkfs.xfs /dev/${VAR}"1" &amp;&gt; /dev/null
</code></pre> 
<p>使用mkfs.xfs命令将新创建的分区格式化为XFS文件系统。</p> 
<pre><code>   mkdir -p /data/${VAR}"1" &amp;&gt; /dev/null
</code></pre> 
<p>创建用于挂载的目录，-p选项用于递归创建目录，如果目录已存在则不会报错。</p> 
<pre><code>   echo "/dev/${VAR}"1" /data/${VAR}"1" xfs defaults 0 0" &gt;&gt; /etc/fstab
</code></pre> 
<p>将新分区的挂载信息添加到/etc/fstab文件，以便系统启动时自动挂载。这一行使用echo命令将一行文本追加到/etc/fstab文件。</p> 
<pre><code>done
</code></pre> 
<p>结束for循环。</p> 
<pre><code>mount -a &amp;&gt; /dev/null
</code></pre> 
<p>使用mount命令挂载所有在/etc/fstab中定义的分区。&amp;&gt; /dev/null用于将输出重定向到/dev/null，以避免显示输出。</p> 
<pre><code>chmod +x /opt/fdisk.sh
</code></pre> 
<p>赋予fdisk.sh脚本执行权限。</p> 
<pre><code>cd /opt/
</code></pre> 
<p>切换到/opt目录。</p> 
<pre><code>./fdisk.sh
</code></pre> 
<p>执行fdisk.sh脚本，开始磁盘分区、格式化和挂载的操作。</p> 
<h3 id="etchosts">配置/etc/hosts文件</h3> 
<pre><code>hostnamectl set-hostname node1  #修改主机名方便辨别
su

echo "192.168.41.31 node1" &gt;&gt; /etc/hosts
echo "192.168.41.32 node2" &gt;&gt; /etc/hosts
echo "192.168.41.33 node3" &gt;&gt; /etc/hosts
echo "192.168.41.34 node4" &gt;&gt; /etc/hosts
</code></pre> 
<p>通过<code>su</code>命令切换当前用户为超级用户（root），通常需要输入超级用户的密码。</p> 
<pre><code>echo "192.168.41.31 node1" &gt;&gt; /etc/hosts
</code></pre> 
<p>将"192.168.10.13 node1"这一行追加到/etc/hosts文件。这是为了将IP地址192.168.10.13与主机名node1进行关联，用于解析主机名。</p> 
<pre><code>echo "192.168.41.32 node2" &gt;&gt; /etc/hosts
echo "192.168.41.33 node3" &gt;&gt; /etc/hosts
echo "192.168.41.34 node4" &gt;&gt; /etc/hosts
</code></pre> 
<p>同样，将其他三个IP地址和相应的主机名追加到/etc/hosts文件，以便系统可以通过主机名解析到相应的IP地址。</p> 
<h3 id="glusterfs-4">安装、启动GlusterFS</h3> 
<p><strong>所有node节点都部署操作</strong></p> 
<pre><code>#将gfsrepo 软件上传到/opt目录下
cd /etc/yum.repos.d/
mkdir repo.bak
mv *.repo repo.bak

vim glfs.repo
[glfs]
name=glfs
baseurl=file:///opt/gfsrepo
gpgcheck=0
enabled=1

yum clean all &amp;&amp; yum makecache

#yum -y install centos-release-gluster            #如采用官方 YUM 源安装，可以直接指向互联网仓库
yum -y install glusterfs glusterfs-server glusterfs-fuse glusterfs-rdma

systemctl start glusterd.service 
systemctl enable glusterd.service
systemctl status glusterd.service

#如果出现版本报错，移除检测软件包
yum remove glusterfs-api.x86_64 glusterfs-cli.x86_64 glusterfs.x86_64 glusterfs-libs.x86_64 glusterfs-client-xlators.x86_64 glusterfs-fuse.x86_64 -y
</code></pre> 
<p>这段脚本主要用于将名为"gfsrepo"的软件上传到<code>/opt</code>目录，并配置一个名为<code>glfs.repo</code>的YUM仓库文件，然后安装 GlusterFS 分布式文件系统的相关软件包，并启动 GlusterFS 服务。</p> 
<p>以下是脚本的解析：</p> 
<ol><li>移动到<code>/etc/yum.repos.d/</code>目录：</li></ol> 
<pre><code>cd /etc/yum.repos.d/
</code></pre> 
<ol><li>创建名为<code>repo.bak</code>的备份目录，并将该目录下的所有<code>.repo</code>文件移动到备份目录中：</li></ol> 
<pre><code>mkdir repo.bak
mv *.repo repo.bak
</code></pre> 
<ol><li>使用<code>vim</code>编辑器创建或编辑<code>glfs.repo</code>文件，添加以下内容：</li></ol> 
<pre><code>[glfs]
name=glfs
baseurl=file:///opt/gfsrepo
gpgcheck=0
enabled=1
</code></pre> 
<p>这个配置文件指定了一个名为<code>glfs</code>的YUM仓库，其<code>baseurl</code>指向<code>file:///opt/gfsrepo</code>，表示软件包位于<code>/opt/gfsrepo</code>目录。<code>gpgcheck</code>设置为0表示不进行 GPG 签名检查，<code>enabled</code>设置为1表示启用该仓库。</p> 
<ol><li>清理YUM缓存并生成新的缓存：</li></ol> 
<pre><code>yum clean all &amp;&amp; yum makecache
</code></pre> 
<ol><li>安装 GlusterFS 相关软件包：</li></ol> 
<pre><code>yum -y install glusterfs glusterfs-server glusterfs-fuse glusterfs-rdma
</code></pre> 
<ol><li>如果使用官方 YUM 源进行安装，可以使用以下命令替代上述软件包安装：</li></ol> 
<pre><code>#yum -y install centos-release-gluster
</code></pre> 
<ol><li>启动 GlusterFS 服务：</li></ol> 
<pre><code>systemctl start glusterd.service
</code></pre> 
<ol><li>设置 GlusterFS 服务开机自启动：</li></ol> 
<pre><code>systemctl enable glusterd.service
</code></pre> 
<ol><li>查看 GlusterFS 服务状态：</li></ol> 
<pre><code>systemctl status glusterd.service
</code></pre> 
<p>这个脚本主要用于配置 GlusterFS 文件系统，确保相关软件包已安装，并启动 GlusterFS 服务。</p> 
<h3 id="-22">添加节点到存储信任池中</h3> 
<p><strong>在node1节点上配置</strong></p> 
<pre><code>#只要在一台Node节点上添加其它节点即可
gluster peer probe node1
gluster peer probe node2
gluster peer probe node3
gluster peer probe node4

#在每个Node节点上查看群集状态
gluster peer status


----- 创建卷 -----
#根据规划创建如下卷：
卷名称                 卷类型             Brick
dis-volume            分布式卷            node1(/data/sdb1)、node2(/data/sdb1)
stripe-volume        条带卷             node1(/data/sdc1)、node2(/data/sdc1)
rep-volume            复制卷             node3(/data/sdb1)、node4(/data/sdb1)
dis-stripe            分布式条带卷      node1(/data/sdd1)、node2(/data/sdd1)、node3(/data/sdd1)、node4(/data/sdd1)
dis-rep                分布式复制卷      node1(/data/sde1)、node2(/data/sde1)、node3(/data/sde1)、node4(/data/sde1)
</code></pre> 
<h4 id="-23">创建卷</h4> 
<h5 id="-24">创建分布式卷</h5> 
<pre><code>#创建分布式卷，没有指定类型，默认创建的是分布式卷
gluster volume create dis-volume node1:/data/sdb1 node2:/data/sdb1 force    

#查看卷列表
gluster volume list

#启动新建分布式卷
gluster volume start dis-volume

#查看创建分布式卷信息
gluster volume info dis-volume
</code></pre> 
<h5 id="-25">创建条带卷</h5> 
<pre><code>#指定类型为 stripe，数值为 2，且后面跟了 2 个 Brick Server，所以创建的是条带卷
gluster volume create stripe-volume stripe 2 node1:/data/sdc1 node2:/data/sdc1 force
gluster volume start stripe-volume
gluster volume info stripe-volume
</code></pre> 
<h5 id="-26">创建复制卷</h5> 
<pre><code>#指定类型为 replica，数值为 2，且后面跟了 2 个 Brick Server，所以创建的是复制卷
gluster volume create rep-volume replica 2 node3:/data/sdb1 node4:/data/sdb1 force
gluster volume start rep-volume
gluster volume info rep-volume
</code></pre> 
<h5 id="-27">创建分布式条带卷</h5> 
<pre><code>#指定类型为 stripe，数值为 2，而且后面跟了 4 个 Brick Server，是 2 的两倍，所以创建的是分布式条带卷
gluster volume create dis-stripe stripe 2 node1:/data/sdd1 node2:/data/sdd1 node3:/data/sdd1 node4:/data/sdd1 force
gluster volume start dis-stripe
gluster volume info dis-stripe
</code></pre> 
<h5 id="-28">创建分布式复制卷</h5> 
<pre><code>指定类型为 replica，数值为 2，而且后面跟了 4 个 Brick Server，是 2 的两倍，所以创建的是分布式复制卷
gluster volume create dis-rep replica 2 node1:/data/sde1 node2:/data/sde1 node3:/data/sde1 node4:/data/sde1 force
gluster volume start dis-rep
gluster volume info dis-rep
</code></pre> 
<h5 id="-29">查看当前所有卷的列表</h5> 
<pre><code>gluster volume list
</code></pre> 
<h4 id="gluster">部署 Gluster 客户端</h4> 
<h5 id="-30">安装客户端软件</h5> 
<pre><code>#将gfsrepo 软件上传到/opt目下 
cd /etc/yum.repos.d/
mkdir repo.bak
mv *.repo repo.bak

vim glfs.repo
[glfs]
name=glfs
baseurl=file:///opt/gfsrepo
gpgcheck=0
enabled=1

yum clean all &amp;&amp; yum makecache

yum -y install glusterfs glusterfs-fuse
</code></pre> 
<p>这段脚本主要用于将名为"gfsrepo"的软件上传到<code>/opt</code>目录，并配置一个名为<code>glfs.repo</code>的YUM仓库文件，然后安装 GlusterFS 分布式文件系统的相关软件包。</p> 
<p>以下是脚本的解析：</p> 
<ol><li>移动到<code>/etc/yum.repos.d/</code>目录：</li></ol> 
<pre><code>cd /etc/yum.repos.d/
</code></pre> 
<ol><li>创建名为<code>repo.bak</code>的备份目录，并将该目录下的所有<code>.repo</code>文件移动到备份目录中：</li></ol> 
<pre><code>mkdir repo.bak
mv *.repo repo.bak
</code></pre> 
<ol><li>使用<code>vim</code>编辑器创建或编辑<code>glfs.repo</code>文件，添加以下内容：</li></ol> 
<pre><code>[glfs]
name=glfs
baseurl=file:///opt/gfsrepo
gpgcheck=0
enabled=1
</code></pre> 
<p>这个配置文件指定了一个名为<code>glfs</code>的YUM仓库，其<code>baseurl</code>指向<code>file:///opt/gfsrepo</code>，表示软件包位于<code>/opt/gfsrepo</code>目录。<code>gpgcheck</code>设置为0表示不进行 GPG 签名检查，<code>enabled</code>设置为1表示启用该仓库。</p> 
<ol><li>清理YUM缓存并生成新的缓存：</li></ol> 
<pre><code>yum clean all &amp;&amp; yum makecache
</code></pre> 
<ol><li>安装 GlusterFS 相关软件包：</li></ol> 
<pre><code>yum -y install glusterfs glusterfs-fuse
</code></pre> 
<p>这个脚本主要用于配置 GlusterFS 文件系统，确保相关软件包已安装，并指定了一个本地 YUM 仓库路径为<code>/opt/gfsrepo</code>。然后通过<code>yum</code>安装了 GlusterFS 和 GlusterFS FUSE（用户空间文件系统）软件包。</p> 
<h5 id="-31">创建挂载目录</h5> 
<pre><code>mkdir -p /test/{dis,stripe,rep,dis_stripe,dis_rep}
ls /test
</code></pre> 
<p>这段命令用于创建一个名为<code>/test</code>的目录，并在该目录下创建五个子目录，分别命名为<code>dis</code>、<code>stripe</code>、<code>rep</code>、<code>dis_stripe</code>和<code>dis_rep</code>。然后，通过<code>ls /test</code>命令列出<code>/test</code>目录下的文件和子目录。</p> 
<p>解析：</p> 
<p><code>mkdir -p /test/{dis,stripe,rep,dis_stripe,dis_rep}</code>:</p> 
<ul><li> <p><code>mkdir</code>: 创建目录的命令。</p> </li><li> <p><code>-p</code>: 如果父目录不存在，则递归创建父目录。</p> </li><li> <p><code>/test/{dis,stripe,rep,dis_stripe,dis_rep}</code>: 使用大括号扩展语法，创建了五个子目录，即<code>/test/dis</code>、<code>/test/stripe</code>、<code>/test/rep</code>、<code>/test/dis_stripe</code>和<code>/test/dis_rep</code>。</p> </li></ul> 
<p><code>ls /test</code>:</p> 
<ul><li> <p><code>ls</code>: 列出目录内容的命令。</p> </li><li> <p><code>/test</code>: 指定要列出内容的目录。</p> </li></ul> 
<p>通过执行以上两个命令，你将在<code>/test</code>目录下创建了五个子目录，然后使用<code>ls</code>命令列出了<code>/test</code>目录下的文件和子目录。</p> 
<h5 id="etchosts-1">配置/etc/hosts文件</h5> 
<pre><code>echo "192.168.41.31 node1" &gt;&gt; /etc/hosts
echo "192.168.41.32 node2" &gt;&gt; /etc/hosts
echo "192.168.41.33 node3" &gt;&gt; /etc/hosts
echo "192.168.41.34 node4" &gt;&gt; /etc/hosts
</code></pre> 
<h5 id="gluster-1">挂载 Gluster 文件系统</h5> 
<pre><code>#临时挂载
mount.glusterfs node1:dis-volume /test/dis
mount.glusterfs node1:stripe-volume /test/stripe
mount.glusterfs node1:rep-volume /test/rep
mount.glusterfs node1:dis-stripe /test/dis_stripe
mount.glusterfs node1:dis-rep /test/dis_rep

df -Th

#永久挂载
vim /etc/fstab
node1:dis-volume        /test/dis               glusterfs       defaults,_netdev        0 0
node1:stripe-volume        /test/stripe            glusterfs       defaults,_netdev        0 0
node1:rep-volume        /test/rep               glusterfs       defaults,_netdev        0 0
node1:dis-stripe        /test/dis_stripe        glusterfs       defaults,_netdev        0 0
node1:dis-rep            /test/dis_rep           glusterfs       defaults,_netdev        0 0
</code></pre> 
<h4 id="gluster-2">测试 Gluster 文件系统</h4> 
<pre><code>1．卷中写入文件，客户端操作
cd /opt
dd if=/dev/zero of=/opt/demo1.log bs=1M count=40
dd if=/dev/zero of=/opt/demo2.log bs=1M count=40
dd if=/dev/zero of=/opt/demo3.log bs=1M count=40
dd if=/dev/zero of=/opt/demo4.log bs=1M count=40
dd if=/dev/zero of=/opt/demo5.log bs=1M count=40

ls -lh /opt

cp /opt/demo* /test/dis
cp /opt/demo* /test/stripe/
cp /opt/demo* /test/rep/
cp /opt/demo* /test/dis_stripe/
cp /opt/demo* /test/dis_rep/

2．查看文件分布
#查看分布式文件分布
[root@node1 ~]# ls -lh /data/sdb1                    #数据没有被分片
总用量 160M

[root@node2 ~]# ll -h /data/sdb1
总用量 40M

#查看条带卷文件分布
[root@node1 ~]# ls -lh /data/sdc1                    #数据被分片50% 没副本 没冗余
总用量 101M

[root@node2 ~]# ll -h /data/sdc1                    #数据被分片50% 没副本 没冗余
总用量 101M

#查看复制卷分布
[root@node3 ~]# ll -h /data/sdb1                    #数据没有被分片 有副本 有冗余     
总用量 201M

[root@node4 ~]# ll -h /data/sdb1                    #数据没有被分片 有副本 有冗余
总用量 201M

#查看分布式条带卷分布
[root@node1 ~]# ll -h /data/sdd1                    #数据被分片50% 没副本 没冗余
总用量 81M

[root@node2 ~]# ll -h /data/sdd1
总用量 81M

[root@node3 ~]# ll -h /data/sdd1
总用量 21M

[root@node4 ~]# ll -h /data/sdd1
总用量 21M

#查看分布式复制卷分布                                #数据没有被分片 有副本 有冗余
[root@node1 ~]# ll -h /data/sde1
总用量 161M

[root@node2 ~]# ll -h /data/sde1
总用量 161M

[root@node3 ~]# ll -h /data/sde1
总用量 41M

[root@node4 ~]# ll -h /data/sde1
总用量 41M
</code></pre> 
<h4 id="-32">破坏性测试</h4> 
<pre><code>#挂起 node2 节点或者关闭glusterd服务来模拟故障
[root@node2 ~]# systemctl stop glusterd.service

#在客户端上查看文件是否正常
#分布式卷数据查看
[root@localhost test]# ll /test/dis/        #在客户机上发现少了demo5.log文件，这个是在node2上的
总用量 163840

#条带卷
[root@localhost test]# cd /test/stripe/        #无法访问，条带卷不具备冗余性
[root@localhost stripe]# ll
总用量 0

#分布式条带卷
[root@localhost test]# ll /test/dis_stripe/        #无法访问，分布条带卷不具备冗余性
总用量 40960

#分布式复制卷
[root@localhost test]# ll /test/dis_rep/    #可以访问，分布式复制卷具备冗余性
总用量 204800

#挂起 node2 和 node4 节点，在客户端上查看文件是否正常
#测试复制卷是否正常
[root@localhost rep]# ls -l /test/rep/        #在客户机上测试正常 数据有
总用量 204800

#测试分布式条卷是否正常
[root@localhost dis_stripe]# ll /test/dis_stripe/        #在客户机上测试没有数据 
总用量 0

#测试分布式复制卷是否正常
[root@localhost dis_rep]# ll /test/dis_rep/        #在客户机上测试正常 有数据
总用量 204800
</code></pre> 
<h2 id="-33">其他维护命令</h2> 
<p><strong>上述实验测试，凡是带复制数据，相比而言，数据比较安全</strong></p> 
<p><strong>查看GlusterFS卷</strong></p> 
<pre><code>gluster volume list
</code></pre> 
<p>该命令用于列出所有GlusterFS卷的名称。</p> 
<p><strong>查看所有卷的信息</strong></p> 
<pre><code>gluster volume info
</code></pre> 
<p>用于获取所有GlusterFS卷的详细信息。</p> 
<p><strong>查看所有卷的状态</strong></p> 
<pre><code>gluster volume status
</code></pre> 
<p>该命令提供了所有GlusterFS卷的状态信息，包括节点的健康状态等。</p> 
<p><strong>停止一个卷</strong></p> 
<pre><code>gluster volume stop dis-stripe
</code></pre> 
<p>用于停止名为"dis-stripe"的GlusterFS卷。</p> 
<p><strong>删除一个卷</strong></p> 
<pre><code>gluster volume delete dis-stripe
</code></pre> 
<p>该命令用于删除名为"dis-stripe"的GlusterFS卷。在删除之前，需要确保卷已停止，且信任池中没有处于宕机状态的主机，否则删除操作将失败。</p> 
<p><strong>设置卷的访问控制</strong></p> 
<ul><li>仅拒绝特定IP地址的访问：</li><li> <pre><code>gluster volume set dis-rep auth.deny 192.168.41.100
</code></pre> <p></p> <p></p> </li><li>仅允许特定IP地址范围的访问：</li><li> <pre><code>gluster volume set dis-rep auth.allow 192.168.41.*
</code></pre> <p>该命令允许所有以192.168.41开头的IP地址范围的主机访问"dis-rep"卷（分布式复制卷）。这是一种基于IP地址的访问控制。</p> <p></p> </li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0c0afba737f07083a4da10797cd9103f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">ELK日志分析系统，ELFK详解部署</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c1ce81c8f250a7a7a93f80392ae5644a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">mysql8 源码下载mysql8编译mysql8安装</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>