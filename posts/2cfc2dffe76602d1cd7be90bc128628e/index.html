<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>TCP传输中的“三次握手”建立连接和“四次握手”释放连接过程 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="TCP传输中的“三次握手”建立连接和“四次握手”释放连接过程" />
<meta property="og:description" content="TCP的连接管理主要面向三个连接阶段，分别是连接建立，传输数据，连接释放。
其中连接的建立和连接释放是两个重要的知识点，分别有两个比较形象的称呼：三次握手和四次握手。
最近正在学习传输层的知识，故借本文对这两个阶段进行简要整理。
首先必须明确的是TCP协议是采用客户/服务器的方式，主动发起连接建立的应用进程称为客户机，被动等待连接建立的应用进程称为服务器。
三次握手 一次连接建立的过程如下：
客户机首先向服务器发送一个TCP请求连接报文，报文不含应用层数据，比较值得注意的是就是报文首部字段，SYN = 1， seq = J；SYN=1表示这是一个请求连接报文，而seq = J 则是表示该报文段的序号，用于确保可靠传输（报文不携带数据但是仍然消耗一个序号）。服务器收到请求连接报文之后，若同意该请求，则为该TCP分配缓存，然后发送一个确认连接报文，其首部的字段分别为：SYN= 1，seq = K，ACK = 1， ack = J &#43; 1;SYN=1表示这是一个连接接收报文，seq表示服务器发送报文的序号，ACK是确认位，而ack = J &#43; 1则是表示服务端已经收到了J号报文，下一个报文希望接收的是序号为 J &#43; 1的报文。当客户端接收到服务器的确认报文之后，需要再向服务端进行确认连接。这是再发送一个普通的确认报文即可。其ACK=1，ack = K&#43;1. 这里值得注意的一个点就是，为什么不能一次或者两次握手就完成连接？
我们来假设一下，如果使用一次握手那么会存在什么样的问题？
服务端不同意请求或繁忙，但由于是一次握手，客户端不清楚服务器是否为其分配了缓存，这样就会导致后续的数据传输失效。
如果只使用二次握手，则会发生：
当服务器同意连接请求之后，发送接收确认报文后，客户端因为一些原因（如停机）导致无法传输数据，进而无法发送确认连接报文，那么服务端就会为这个掉线的客户端分配多余的资源，导致资源浪费。
四次握手 TCP的连接释放可以简单概括为两个阶段：
前两次握手是为了终止客户机到服务器的数据传输，但是服务器仍可以向客户机发送数据后两次握手是为了终止服务器向客户机发送数据。 四次握手的过程如下：
客户机向其TCP发出一个连接释放报文，其首部字段 FIN = 1，seq = u。当某一端发起一个附带FIN=1的报文时，则表示这一端终止发送数据，后续只能被动接收数据。服务器接收客户端释放报文，返回确认报文，其首部字段为 ACK=1，seq = v，ack = u &#43; 1。这样从客户端到服务器的单向数据传输就终止了。但服务器仍然可以向客户端发送数据. 若服务端没有要向客户端发送的数据了，那么服务端发出连接释放报文，其首部字段 FIN = 1，ACK= 1，seq = w，ack = u &#43; 1。客户机接收到连接释放报文之后，必须发出确认，其中ACK=1，seq = u &#43; 1， ack = w &#43; 1。此时TCP还未真正释放，必须经过时间等待计时器设置的时间2MSL后，客户端才进入关闭连接的状态。 这里需要清楚一点就是，为什么不能三次握手就完成连接的释放，即省略最后一步，确认报文。。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/2cfc2dffe76602d1cd7be90bc128628e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-10-30T19:05:30+08:00" />
<meta property="article:modified_time" content="2019-10-30T19:05:30+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">TCP传输中的“三次握手”建立连接和“四次握手”释放连接过程</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-dracula">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>TCP的连接管理主要面向三个连接阶段，分别是连接建立，传输数据，连接释放。<br> 其中连接的建立和连接释放是两个重要的知识点，分别有两个比较形象的称呼：三次握手和四次握手。<br> 最近正在学习传输层的知识，故借本文对这两个阶段进行简要整理。</p> 
<p>首先必须明确的是TCP协议是采用客户/服务器的方式，主动发起连接建立的应用进程称为客户机，被动等待连接建立的应用进程称为服务器。</p> 
<h2><a id="_6"></a>三次握手</h2> 
<p><img src="https://images2.imgbox.com/40/a4/ioSmJHYS_o.png" alt="在这里插入图片描述"><br> 一次连接建立的过程如下：</p> 
<ol><li>客户机首先向服务器发送一个<strong>TCP请求连接报文</strong>，报文不含应用层数据，比较值得注意的是就是报文首部字段，<strong>SYN = 1， seq = J</strong>；SYN=1表示这是一个请求连接报文，而seq = J 则是表示该报文段的序号，用于确保可靠传输（报文不携带数据但是仍然消耗一个序号）。</li><li>服务器收到请求连接报文之后，若同意该请求，则为该TCP分配缓存，然后发送一个确认连接报文，其首部的字段分别为：<strong>SYN= 1，seq = K，ACK = 1， ack = J + 1</strong>;SYN=1表示这是一个连接接收报文，seq表示服务器发送报文的序号，ACK是确认位，<strong>而ack = J + 1则是表示服务端已经收到了J号报文，下一个报文希望接收的是序号为 J + 1的报文。</strong></li><li>当客户端接收到服务器的确认报文之后，需要再向服务端进行确认连接。这是再发送一个普通的确认报文即可。其ACK=1，ack = K+1.</li></ol> 
<p>这里值得注意的一个点就是，为什么不能一次或者两次握手就完成连接？<br> 我们来假设一下，如果使用一次握手那么会存在什么样的问题？<br> 服务端不同意请求或繁忙，但由于是一次握手，<strong>客户端不清楚服务器是否为其分配了缓存，这样就会导致后续的数据传输失效。</strong><br> 如果只使用二次握手，则会发生：<br> 当服务器同意连接请求之后，发送接收确认报文后，客户端因为一些原因（如停机）导致无法传输数据，进而无法发送确认连接报文，那么服务端就会为这个掉线的客户端分配多余的资源，导致资源浪费。</p> 
<h2><a id="_19"></a>四次握手</h2> 
<p><img src="https://images2.imgbox.com/2d/d5/DXJwvbpl_o.png" alt="在这里插入图片描述"><br> TCP的连接释放可以简单概括为两个阶段：</p> 
<ol><li>前两次握手是<strong>为了终止客户机到服务器的数据传输</strong>，但是服务器仍可以向客户机发送数据</li><li>后两次握手是为<strong>了终止服务器向客户机发送数据。</strong></li></ol> 
<p>四次握手的过程如下：</p> 
<ol><li>客户机向其TCP发出一个连接释放报文，其首部字段 FIN = 1，seq = u。当某一端发起一个附带FIN=1的报文时，则表示这一端终止发送数据，后续只能被动接收数据。</li><li>服务器接收客户端释放报文，返回确认报文，其首部字段为 ACK=1，seq = v，ack = u + 1。<strong>这样从客户端到服务器的单向数据传输就终止了。但服务器仍然可以向客户端发送数据</strong></li><li>. 若服务端没有要向客户端发送的数据了，那么服务端发出连接释放报文，其首部字段 FIN = 1，ACK= 1，seq = w，ack = u + 1。</li><li>客户机接收到连接释放报文之后，必须发出确认，其中ACK=1，seq = u + 1， ack = w + 1。<strong>此时TCP还未真正释放，必须经过时间等待计时器设置的时间2MSL后，客户端才进入关闭连接的状态。</strong></li></ol> 
<p>这里需要清楚一点就是，为什么不能三次握手就完成连接的释放，即省略最后一步，确认报文。。<br> 因为这里是TCP协议，通过确认机制来保证可靠传输，针对一个非确认报文，接收方需要发送一个确认报文给发送方，如果客户机未接收到发送方的释放连接报文，而服务器并不清楚就主动断开连接，这样就会使得客户机继续保留维护连接的资源，造成资源浪费。一般来说，服务器未接收到确认报文的话，就会触发超时重传，确保客户机接收到连接释放的报文。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/70af12470a8332a6765929dac9f3d038/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">JavaScript递归理解（一）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/42b9cffe7cd270b227f76515184d0076/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Wireshark 无法找到接口解决方法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>