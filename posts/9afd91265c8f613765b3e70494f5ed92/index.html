<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>MapboxGL——marker轨迹动画效果，自定义速度。暂停继续轨迹运动 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="MapboxGL——marker轨迹动画效果，自定义速度。暂停继续轨迹运动" />
<meta property="og:description" content="轨迹运动的核心是不断变动marker的坐标。
最终效果：
主要参考了 Mapbox实现动态轨迹_mapbox 轨迹_二五25的博客-CSDN博客
mapbox轨迹动画效果_mapbox动画_Chaoying.的博客-CSDN博客
但是我们这里的需求有变化。使用turf.along和turf.lineChunk出来的数据，只包含坐标点.
不包含其他信息。需要携带其他的信息就没有办法。比如起点或者终点在室内，那么就办法设置楼层。
所以这里要对数组做处理。
数据处理一：将后台返回的数据处理成我们想要的格式
我这里请求路线返回的数据长这样。可以看出返回的数据结构不符合turf.lineString的要求。
处理数据，将所有的需要的数据，室内楼层，偏转角度，每段路线的终点，每段路线之间的距离通通通过handleRouteData函数处理拿到。
主要代码为：
function handleRouteData(route) { // 处理数据 返回线数据以及所以点集合 let pointCollects = [] for (let i = 0; i &lt; route.length; i&#43;&#43;) { pointCollects.push({ &#34;properties&#34;: { &#34;indoor&#34;: route[i].indoor, &#34;floor&#34;: route[i].startFloor }, &#39;geometry&#39;: route[i].geometry }); let str = route[i].geometry.coordinates.join(&#39;,&#39;).split(&#39;,&#39;) str = str.map(j =&gt; Number(j)) console.log(&#34;str&#34;, str) let totalPoint = [] for (let i = 0; i &lt; str.length; i&#43;&#43;) { if (i % 2 === 0) { totalPoint." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/9afd91265c8f613765b3e70494f5ed92/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-03-14T10:56:46+08:00" />
<meta property="article:modified_time" content="2023-03-14T10:56:46+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">MapboxGL——marker轨迹动画效果，自定义速度。暂停继续轨迹运动</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>轨迹运动的核心是不断变动marker的坐标。</p> 
<p>最终效果：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/b8/f5/PAWcskrD_o.gif"></p> 
<p style="text-align:center;"></p> 
<p></p> 
<p>主要参考了  <a href="https://blog.csdn.net/qq_44741716/article/details/127788271" title="Mapbox实现动态轨迹_mapbox 轨迹_二五25的博客-CSDN博客">Mapbox实现动态轨迹_mapbox 轨迹_二五25的博客-CSDN博客</a></p> 
<p><a href="https://blog.csdn.net/TJLCY/article/details/128417777" title="mapbox轨迹动画效果_mapbox动画_Chaoying.的博客-CSDN博客">mapbox轨迹动画效果_mapbox动画_Chaoying.的博客-CSDN博客</a></p> 
<p>但是我们这里的需求有变化。使用turf.along和turf.lineChunk出来的数据，只包含坐标点.</p> 
<p>不包含其他信息。需要携带其他的信息就没有办法。比如起点或者终点在室内，那么就办法设置楼层。</p> 
<p>所以这里要对数组做处理。</p> 
<p><strong>数据处理一：将后台返回的数据处理成我们想要的格式</strong></p> 
<p>我这里请求路线返回的数据长这样。可以看出返回的数据结构不符合turf.lineString的要求。</p> 
<p class="img-center"><img alt="" height="602" src="https://images2.imgbox.com/b4/fa/IK8j4HpS_o.png" width="1184"></p> 
<p><br><strong>处理数据，将所有的需要的数据，室内楼层，偏转角度，每段路线的终点，每段路线之间的距离通通通过handleRouteData函数处理拿到。</strong></p> 
<p> 主要代码为：</p> 
<pre><code class="language-javascript">
        function handleRouteData(route) { // 处理数据 返回线数据以及所以点集合
            let pointCollects = []

            for (let i = 0; i &lt; route.length; i++) {
                pointCollects.push({
                    "properties": {
                        "indoor": route[i].indoor,
                        "floor": route[i].startFloor
                    },
                    'geometry': route[i].geometry
                });
                let str = route[i].geometry.coordinates.join(',').split(',')
                str = str.map(j =&gt; Number(j))

                console.log("str", str)
                let totalPoint = []
                for (let i = 0; i &lt; str.length; i++) {
                    if (i % 2 === 0) {
                        totalPoint.push([str[i], str[i + 1]])
                    }
                }

                let start = turf.point(totalPoint[0])
                let end = turf.point(totalPoint[totalPoint.length - 1])
                let bearing = turf.bearing(start, end)

                if (i === route.length - 1) {
                    lastPoint = totalPoint[totalPoint.length - 1]
                }
                console.log("totalPoint", totalPoint)

                splitLine.push(turf.lineString(totalPoint))
                splitDis.push(turf.length(splitLine[i], { units: 'meters' }));
                totalFloor.push(route[i].startFloor)
                totalBearing.push(bearing)
                totalIndoor.push(route[i].indoor)

            }

            return {
                pointCollects, // 线数据
                splitLine, // 每一段路线的线信息
                splitDis, // 每一段路线的距离
                totalFloor, // 每一段路线所在楼层数
                totalBearing, // 每一段路线的偏移角度
                totalIndoor,  // 每一段路线是否在室内
                lastPoint // 每一段路线的终点
            }
        }</code></pre> 
<p><strong>数据处理二：将上一步处理好的数据，整合成数组。</strong></p> 
<p><strong>主要代码是：</strong></p> 
<pre><code class="language-javascript">   function dealData(speed) {
            let anverageLine = []
            for (let i = 0; i &lt; res.splitDis.length; i++) {
                let along = null
                if (res.totalIndoor[i]) {
                    // 如果这一度在室内 那么就多分几个点吧--因为层级的原因
                    along = turf.lineChunk(res.splitLine[i], (5 * speed) * 0.4, { units: 'meters' });
                } else {
                    along = turf.lineChunk(res.splitLine[i], 5 * speed, { units: 'meters' });
                }
                console.log(along);
                along.features.map(j =&gt; {
                    j.geometry.coordinates.map(k =&gt; {
                        anverageLine.push([k, res.totalIndoor[i], res.totalFloor[i], res.totalBearing[i]])
                    })
                })
                if (i === res.splitDis.length - 1) {
                    anverageLine.push([lastPoint, res.totalIndoor[i], res.totalFloor[i], res.totalBearing[i]])
                }
            }
            return anverageLine
        }</code></pre> 
<p>这里的思路是，<strong>根据距离将线切割成N个点，因为每次切割的点不包括这段路的终点。所以这里必须要手动加入路线终点。不然marker运动的时候，无法走到路程尽头。</strong></p> 
<p>这里的anverageLine就是我们需要marker移动所需要的所有的信息。</p> 
<p>marker移动速度的快慢就是通过speed的大小决定，speed越大，就表明这一段路线分割成的点就越少。运动速度就越快</p> 
<p>室内层级比室外层级更大，marker移动肉眼可见变得快一点，猜测是近大远小的原理吧。所以室内的点分的更多一点。至于慢多少可以由自己决定，这里是0.4.</p> 
<p>最后开启动画，使用requestAnimationFrame,让marker动起来。</p> 
<p>主要代码是</p> 
<pre><code class="language-javascript">        var requestId;
        function loop(speed) {
            requestId = undefined;
            let anverageLine = dealData(speed);
            map.easeTo({
                center: anverageLine[step][0],
                zoom: 17,
                duration: 50,
            })
            if (anverageLine[step][1]) {
                map.setLevel(anverageLine[step][2])
                map.easeTo({
                    center: anverageLine[step][0],
                    zoom: 19,
                })
            }
            step = step + 1;
  
            if (step === anverageLine.length - 1) {
                requestId = undefined;
                step = 0
                return
            }
            go(speed);
            marker.setLngLat(anverageLine[step][0])

        }

        function go(speed) {

            if (!requestId) {
                requestId = window.requestAnimationFrame(() =&gt; loop(1));
            }
        }

</code></pre> 
<p></p> 
<p>至此 大功告成</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b926b2d1d35e64b0d8ae8c374224dcf2/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">MySQL的binlog日志存储在哪个位置？</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8b0d55c8518cfe860eb8cd5fdf1d09fe/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">addEventListener 方法是干什么的？底层原理是什么？</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>