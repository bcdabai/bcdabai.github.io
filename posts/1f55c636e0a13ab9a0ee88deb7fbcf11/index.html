<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>详解SpringCloud微服务技术栈：强推！源码跟踪分析Ribbon负载均衡原理、Eureka服务部署 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="详解SpringCloud微服务技术栈：强推！源码跟踪分析Ribbon负载均衡原理、Eureka服务部署" />
<meta property="og:description" content="👨‍🎓作者简介：一位大四、研0学生，正在努力准备大四暑假的实习
🌌上期文章：详解SpringCloud微服务技术栈：认识微服务、服务拆分与远程调用
📚订阅专栏：微服务技术全家桶
希望文章对你们有所帮助
Eureka 提供者与消费者Eureka原理分析搭建Eureka服务搭建注册中心服务注册服务发现 Ribbon负载均衡原理源码跟踪原理（强推！）流程总结 负载均衡策略饥饿加载 提供者与消费者 服务提供者：一次业务中，被其它微服务调用的服务（提供接口给其他微服务）
服务消费者：一次业务中，调用其它微服务的服务（调用其它微服务提供的接口）
若服务A调用服务B，服务B调用服务C，那么服务B是什么角色？
提供者与消费者的概念是相对的，一个服务既可以是提供者也可以是消费者。
Eureka原理分析 上一节内容中服务调用存在问题，服务调用使用http请求，网址直接定死了，如果我们有多个服务集群，亦或是网址在后续开发过程中出现变更，就会产生不方便。如下所示：
我们需要解决以下三个问题：
服务消费者该如何获取服务提供者的地址信息？
如果有多个服务提供者，消费者该如何选择？
消费者如何得知服务提供者的健康状态？
而Eureka可以解决这个问题，Eureka的架构：
1、eureka-server：注册中心
2、eureka-client：
（1）服务消费者（集群）
（2）服务提供者（集群）
Eureka的作用及工作流程：
1、每个服务启动的时候，都会将注册服务信息记录在注册中心，例如端口号
2、服务信息都记住了，当服务消费者需要信息的时候，无须自己去记录，而是直接去Eureka-server中拉取，这样就可以得到服务提供者的信息
3、得到的服务提供者信息可能是个集群，包含多台服务的信息，这时候要做负载均衡去选取其中一个服务
4、消费者对提供者发起远程调用
这是核心的工作流程，另外，服务的提供者每隔30s就会向Eureka-server发送心跳续约，如果服务宕机了，那么Eureka-server就会将其剔除，这样能够保证服务消费者做远程调用的时候，能调用服务提供者都是健康的。
搭建Eureka服务 要首先Eureka服务，需要实现3点：
1、搭建注册中心（EurekaServer）
2、实现服务注册（将上一篇文章中的user-service、order-service注册到eureka）
3、实现服务发现（在order-service中完成服务拉取，然后通过负载均衡挑选一个服务，实现远程调用）
搭建注册中心 搭建EurekaServer的步骤如下：
1、创建项目，引入EurekaServer依赖：
&lt;dependencies&gt; &lt;!--Eureka服务端--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 2、编写启动类，添加@EnableEurekaServer注解：
@EnableEurekaServer @SpringBootApplication public class EurekaApplication { public static void main(String[] args) { SpringApplication.run(EurekaApplication.class, args); } } 3、添加application.yml文件，编写下列配置：
server: port: 10086 # 服务端口 spring: application: name: eurekaserver # 服务名称 eureka: client: service-url: # Eureka的地址信息 defaultZone: http://localhost:10086/eureka Eureka自己也是微服务，所以配置Eureka也需要将Eureka本身给注册。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/1f55c636e0a13ab9a0ee88deb7fbcf11/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-15T00:56:48+08:00" />
<meta property="article:modified_time" content="2024-01-15T00:56:48+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">详解SpringCloud微服务技术栈：强推！源码跟踪分析Ribbon负载均衡原理、Eureka服务部署</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <blockquote> 
 <p>👨‍🎓作者简介：一位大四、研0学生，正在努力准备大四暑假的实习<br> 🌌上期文章：<a href="https://blog.csdn.net/m0_52380556/article/details/135583389?spm=1001.2014.3001.5501">详解SpringCloud微服务技术栈：认识微服务、服务拆分与远程调用</a><br> 📚订阅专栏：<a href="https://blog.csdn.net/m0_52380556/category_12554499.html?spm=1001.2014.3001.5482">微服务技术全家桶</a><br> 希望文章对你们有所帮助</p> 
</blockquote> 
<p></p> 
<div class="toc"> 
 <h4>Eureka</h4> 
 <ul><li><a href="#_6" rel="nofollow">提供者与消费者</a></li><li><a href="#Eureka_13" rel="nofollow">Eureka原理分析</a></li><li><a href="#Eureka_39" rel="nofollow">搭建Eureka服务</a></li><li><ul><li><a href="#_45" rel="nofollow">搭建注册中心</a></li><li><a href="#_90" rel="nofollow">服务注册</a></li><li><a href="#_131" rel="nofollow">服务发现</a></li></ul> 
  </li><li><a href="#Ribbon_160" rel="nofollow">Ribbon</a></li><li><ul><li><a href="#_163" rel="nofollow">负载均衡原理</a></li><li><a href="#_173" rel="nofollow">源码跟踪原理（强推！）</a></li><li><ul><li><a href="#_203" rel="nofollow">流程总结</a></li></ul> 
   </li><li><a href="#_212" rel="nofollow">负载均衡策略</a></li><li><a href="#_235" rel="nofollow">饥饿加载</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="_6"></a>提供者与消费者</h2> 
<p>服务提供者：一次业务中，被其它微服务调用的服务（提供接口给其他微服务）<br> 服务消费者：一次业务中，调用其它微服务的服务（调用其它微服务提供的接口）</p> 
<blockquote> 
 <p>若服务A调用服务B，服务B调用服务C，那么服务B是什么角色？</p> 
</blockquote> 
<p>提供者与消费者的概念是相对的，<strong>一个服务既可以是提供者也可以是消费者</strong>。</p> 
<h2><a id="Eureka_13"></a>Eureka原理分析</h2> 
<p>上一节内容中服务调用存在问题，服务调用使用http请求，网址直接定死了，如果我们有多个服务集群，亦或是网址在后续开发过程中出现变更，就会产生不方便。如下所示：<br> <img src="https://images2.imgbox.com/d8/d3/sWDiB7aL_o.png" alt="在这里插入图片描述"></p> 
<p>我们需要解决以下三个问题：</p> 
<blockquote> 
 <p>服务消费者该如何获取服务提供者的地址信息？<br> 如果有多个服务提供者，消费者该如何选择？<br> 消费者如何得知服务提供者的健康状态？</p> 
</blockquote> 
<p>而Eureka可以解决这个问题，Eureka的架构：</p> 
<blockquote> 
 <p>1、eureka-server：注册中心<br> 2、eureka-client：<br> （1）服务消费者（集群）<br> （2）服务提供者（集群）</p> 
</blockquote> 
<p>Eureka的作用及工作流程：</p> 
<blockquote> 
 <p>1、每个服务启动的时候，都会将<strong>注册服务信息</strong>记录在<strong>注册中心</strong>，例如端口号<br> 2、服务信息都记住了，当<strong>服务消费者</strong>需要信息的时候，无须自己去记录，而是直接去<strong>Eureka-server</strong>中拉取，这样就可以得到<strong>服务提供者</strong>的信息<br> 3、得到的服务提供者信息可能是个集群，包含多台服务的信息，这时候要做<strong>负载均衡</strong>去选取其中一个服务<br> 4、消费者对提供者发起<strong>远程调用</strong></p> 
</blockquote> 
<p>这是核心的工作流程，另外，服务的提供者每隔30s就会向Eureka-server发送心跳续约，如果服务宕机了，那么Eureka-server就会将其剔除，这样能够保证服务消费者做远程调用的时候，能调用服务提供者都是健康的。</p> 
<h2><a id="Eureka_39"></a>搭建Eureka服务</h2> 
<p>要首先Eureka服务，需要实现3点：</p> 
<blockquote> 
 <p>1、搭建注册中心（EurekaServer）<br> 2、实现服务注册（将上一篇文章中的user-service、order-service注册到eureka）<br> 3、实现服务发现（在order-service中完成服务拉取，然后通过负载均衡挑选一个服务，实现远程调用）</p> 
</blockquote> 
<h3><a id="_45"></a>搭建注册中心</h3> 
<p>搭建EurekaServer的步骤如下：<br> 1、创建项目，引入EurekaServer依赖：<br> <img src="https://images2.imgbox.com/49/66/iG1C62mB_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-xml">	<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">&gt;</span></span>
        <span class="token comment">&lt;!--Eureka服务端--&gt;</span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-cloud-starter-netflix-eureka-server<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">&gt;</span></span>
</code></pre> 
<p>2、编写启动类，添加@EnableEurekaServer注解：</p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@EnableEurekaServer</span>
<span class="token annotation punctuation">@SpringBootApplication</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">EurekaApplication</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">SpringApplication</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token class-name">EurekaApplication</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>3、添加application.yml文件，编写下列配置：</p> 
<pre><code class="prism language-yaml"><span class="token key atrule">server</span><span class="token punctuation">:</span>
  <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">10086</span> <span class="token comment"># 服务端口</span>
<span class="token key atrule">spring</span><span class="token punctuation">:</span>
  <span class="token key atrule">application</span><span class="token punctuation">:</span>
    <span class="token key atrule">name</span><span class="token punctuation">:</span> eurekaserver <span class="token comment"># 服务名称</span>
<span class="token key atrule">eureka</span><span class="token punctuation">:</span>
  <span class="token key atrule">client</span><span class="token punctuation">:</span>
    <span class="token key atrule">service-url</span><span class="token punctuation">:</span> <span class="token comment"># Eureka的地址信息</span>
      <span class="token key atrule">defaultZone</span><span class="token punctuation">:</span> http<span class="token punctuation">:</span>//localhost<span class="token punctuation">:</span>10086/eureka
</code></pre> 
<p>Eureka自己也是微服务，所以配置Eureka也需要将Eureka本身给注册。</p> 
<p>接着就可以启动Eureka服务，访问端口可以看到其界面信息：<br> <img src="https://images2.imgbox.com/21/e3/w9nLFjwz_o.png" alt="在这里插入图片描述"><br> 可以发现注册到Eureka的实例，现在只有它本身。</p> 
<h3><a id="_90"></a>服务注册</h3> 
<p>将user-service注册到EurekaServer步骤如下：<br> 1、将user-service项目引入spring-cloud-starter-netflix-eureka-client的依赖：</p> 
<pre><code class="prism language-xml">	<span class="token comment">&lt;!--Eureka-Client依赖--&gt;</span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-cloud-starter-netflix-eureka-client<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>
</code></pre> 
<p>2、在application.yml文件，编写下面的配置：</p> 
<pre><code class="prism language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>
  <span class="token key atrule">application</span><span class="token punctuation">:</span>
    <span class="token key atrule">name</span><span class="token punctuation">:</span> userservice <span class="token comment"># 服务名称</span>
<span class="token key atrule">eureka</span><span class="token punctuation">:</span>
  <span class="token key atrule">client</span><span class="token punctuation">:</span>
    <span class="token key atrule">service-url</span><span class="token punctuation">:</span> <span class="token comment"># Eureka的地址信息</span>
      <span class="token key atrule">defaultZone</span><span class="token punctuation">:</span> http<span class="token punctuation">:</span>//localhost<span class="token punctuation">:</span>10086/eureka
</code></pre> 
<p>同样的方式也可以将order-service注册。<br> 刷新Eureka-server端网址：<br> <img src="https://images2.imgbox.com/db/a2/Ai0833of_o.png" alt="在这里插入图片描述"></p> 
<p>如果你出现了java.lang.NoClassDefFoundError的问题，那可能是你的依赖导入错误了，我就不小心把依赖导入成下面这个：<br> <img src="https://images2.imgbox.com/fa/95/1WuLT9tQ_o.png" alt="在这里插入图片描述"><br> 记得要加上starter，才能被SpringBoot当成启动类。</p> 
<p>另外，可以将user-service多次启动，模拟多实例部署，单位了避免端口冲突，需要修改端口设置：<br> <img src="https://images2.imgbox.com/e1/0a/JLvFyosW_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/c4/b3/87jvJVb6_o.png" alt="在这里插入图片描述"><br> 将增加的端口也运行一下，工程看到注册了2个实例的实例列表：<br> <img src="https://images2.imgbox.com/82/97/7J8owRSW_o.png" alt="在这里插入图片描述"><br> 服务注册总体来说分为两步：<br> 1、引入eureka-client依赖<br> 2、在application.yml中配置eureka地址</p> 
<p>无论消费者还是提供者，引入eureka-client依赖，知道了eureka地址后，都可以完成服务注册。</p> 
<h3><a id="_131"></a>服务发现</h3> 
<p>服务拉取是基于服务名称获取服务列表，然后对服务列表做负载均衡。<br> 1、修改OrderService代码，修改访问的url路径，用服务名来代替ip、端口：</p> 
<pre><code class="prism language-java"><span class="token class-name">String</span> url <span class="token operator">=</span> <span class="token string">"http://userservice/user/"</span> <span class="token operator">+</span> order<span class="token punctuation">.</span><span class="token function">getUserId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>2、在order-service项目的启动类OrderApplication中的RestTemplate添加<strong>负载均衡</strong>注解：</p> 
<pre><code class="prism language-java">	<span class="token annotation punctuation">@Bean</span>
    <span class="token annotation punctuation">@LoadBalanced</span>
    <span class="token keyword">public</span> <span class="token class-name">RestTemplate</span> <span class="token function">restTemplate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">RestTemplate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> 
<p>重启OrderApplication服务，按顺序访问：<br> http://localhost:8080/order/101<br> http://localhost:8080/order/102</p> 
<p>可以看到UserApplication与UserApplication2各做了一次数据库查询操作：<br> <img src="https://images2.imgbox.com/ce/2c/QXOZGqRY_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/34/fb/oaRZDA9r_o.png" alt="在这里插入图片描述"><br> 所以，服务的拉取以及负载均衡已经完成。</p> 
<p>服务发现的实现流程总结：<br> 1、引入eureka-client依赖<br> 2、在application.yml中配置eureka地址<br> 3、给RestTemplate添加@LoadBalanced注解<br> 4、给用户提供者的服务名称远程调用</p> 
<h2><a id="Ribbon_160"></a>Ribbon</h2> 
<p>在上面已经实现了服务的拉取，并且验证了负载均衡。那么其原理是怎样的，什么时候做的服务拉取，又是什么时候做的负载均衡，咱们都还不知道。<br> 而其中，负载均衡是由Ribbon组件实现的。</p> 
<h3><a id="_163"></a>负载均衡原理</h3> 
<p>首先思考，url已经做了修改：</p> 
<pre><code class="prism language-java"><span class="token class-name">String</span> url <span class="token operator">=</span> <span class="token string">"http://userservice/user/"</span> <span class="token operator">+</span> order<span class="token punctuation">.</span><span class="token function">getUserId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>然而访问一下http://userservice/user/1，并不能访问到，说明它并不是真实可用的地址。因此，中间肯定有组件拦截了这个请求并且做了处理，这个组件就叫做Ribbon。<br> 整个负载均衡的流程如下：<br> <img src="https://images2.imgbox.com/7a/54/PViBJm1f_o.png" alt="在这里插入图片描述"><br> 而具体到底是什么时候接受这个请求的，又是怎么去做后序工作的，需要跟踪源码来做分析。</p> 
<h3><a id="_173"></a>源码跟踪原理（强推！）</h3> 
<p>1、找到LoadBalancerInterceptor类，发现它实现了ClientHttpRequestInterceptor接口：<br> <img src="https://images2.imgbox.com/cb/50/p1NFqcsc_o.png" alt="在这里插入图片描述"><br> 2、进入这个接口，查看注释：<br> <img src="https://images2.imgbox.com/f0/ec/K8Z9vX8A_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>其说明的大致意思是，<strong>当客户端有http请求发出的时候，立马就会被这个接口给拦截</strong>，那大概就可以知道，当实现类调用这个接口的实现方法的时候，应该要能够实现拦截</p> 
</blockquote> 
<p>3、再回到其实现类，在实现类中打上断点，并debug模式重启OrderApplication：<br> <img src="https://images2.imgbox.com/18/0e/ppnIwKuv_o.png" alt="在这里插入图片描述"></p> 
<p>4、在浏览器中发起请求：http://localhost:8080/order/101，可以发现请求确实成功被拦截了<br> <img src="https://images2.imgbox.com/ea/44/CZx6Y9zu_o.png" alt="在这里插入图片描述"><br> 5、跟踪下去，可以看到它解析出了我们要请求的提供者服务端是userservice：<br> <img src="https://images2.imgbox.com/5d/91/W76db6NW_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/c3/dc/Arq6LQqA_o.png" alt="在这里插入图片描述"><br> 6、解析完了就要开始进行拉取了，在这里我们可以看到Ribbon的词眼：<br> <img src="https://images2.imgbox.com/f2/5f/1hfHbJ5m_o.png" alt="在这里插入图片描述"><br> 这是一个RibbonLoadBalancerClient对象，意为Ribbon负载均衡的客户端。<br> 7、跟入execute方法，查看其执行的底层：<br> <img src="https://images2.imgbox.com/77/0d/3hk29PhV_o.png" alt="在这里插入图片描述"><br> 在得到动态服务列表均衡器（DynamicServerListLoadBalancer）后，可以看到这里已经成功拉取到了服务。而getServer方法就肯定是在做负载均衡了。<br> 8、点击进入getServer方法，可以发现这里就是在做服务器的选择了：<br> <img src="https://images2.imgbox.com/25/50/ilrXvpwZ_o.png" alt="在这里插入图片描述"><br> 9、跟进，可以看到它在实现父类的方法，可以猜想到，服务器的选择是基于某种规则的：<br> <img src="https://images2.imgbox.com/06/04/XKAjQ76n_o.png" alt="在这里插入图片描述"><br> 10、找到rule的对象，这是一个接口，按住<strong>Ctrl+H</strong>找到其实现类：<br> <img src="https://images2.imgbox.com/e9/19/pr8YQ2iR_o.png" alt="在这里插入图片描述"><br> RoundRobinRule指代<strong>轮询负载均衡</strong>，RandomRule指代<strong>随机负载均衡</strong>，这些其实在nginx里面都是接触过的，到这里为止，其实现的机理就不在这里继续跟踪了，想知道的话直接学nginx就可以了。</p> 
<h4><a id="_203"></a>流程总结</h4> 
<blockquote> 
 <p>1、order-service（消费者）发起请求，负载均衡拦截器<strong>LoadBalancerInterceptor</strong>的<strong>RibbonLoadBalancerClient</strong>会接收请求的url，获取url中的服务id<br> 2、<strong>RibbonLoadBalancerClient</strong>把服务id交给<strong>DynamicServerListLoadBalancer</strong><br> 3、<strong>DynamicServerListLoadBalancer</strong>会去<strong>eureka-server</strong>中拉取userservice，并返回<strong>服务列表</strong><br> 4、<strong>DynamicServerListLoadBalancer</strong>需要在服务列表中选一个，这个选择即为<strong>负载均衡</strong>，交给了一个交IRule的接口对象。<br> 5、IRule会选择一个方法在列表中选择服务，把值返回给<strong>RibbonLoadBalancerClient</strong><br> 6、<strong>RibbonLoadBalancerClient</strong>将会修改url，使得其实正确的真实地址，即可在前端成功访问了。</p> 
</blockquote> 
<h3><a id="_212"></a>负载均衡策略</h3> 
<p>Ribbon的负载均衡规则是一个叫做IRule的接口来定义的，每个子接口都是一种规则：<br> <img src="https://images2.imgbox.com/80/55/GyC6EG3F_o.png" alt="在这里插入图片描述"><br> 其中，ZoneAvoidanceRule是默认方式，其父类的父类是基于轮询的，因此也可以推测ZoneAvoidanceRule是基于轮询的。<br> <strong>ZoneAvoidanceRule</strong>：以区域可用的服务器为基础进行服务器的选择。使用Zone对服务器进行分类，这个Zone可以理解为一个机房、一个机架等。而后再对Zone内的多个服务做轮询。（Zone可以配置，没配置就默认所有服务都在一个Zone内）。</p> 
<p>通过定义IRule可以修改负载均衡的规则，有2种方式：<br> 1、代码方式：在order-service中的OrderApplication类中，定义一个新的IRule：</p> 
<pre><code class="prism language-java">	<span class="token annotation punctuation">@Bean</span>
    <span class="token keyword">public</span> <span class="token class-name">IRule</span> <span class="token function">randomRule</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">RandomRule</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> 
<p>2、配置文件方式：在order-service的application.yml文件中，添加新的配置也可以修改规则：</p> 
<pre><code class="prism language-yaml"><span class="token key atrule">userservice</span><span class="token punctuation">:</span>
  <span class="token key atrule">ribbon</span><span class="token punctuation">:</span>
    <span class="token key atrule">NFLoadBalancerRuleClassName</span><span class="token punctuation">:</span> com.netflix.loadbalancer.RandomRule <span class="token comment"># 负载均衡规则</span>
</code></pre> 
<p>测试的话大家自己多访问几次网址，看控制台就可以知道是不是随机负载均衡了。</p> 
<h3><a id="_235"></a>饥饿加载</h3> 
<p>这部分看不懂就去回顾一下设计模式吧。<br> Ribbon默认是采用懒加载，即第一次访问时才会去创建LoadBalanceClient，请求时间会很长。<br> 而饥饿加载则会在项目启动时创建，降低第一次访问的耗时，通过下面配置开启饥饿加载：</p> 
<pre><code class="prism language-yaml"><span class="token key atrule">ribbon</span><span class="token punctuation">:</span>
  <span class="token key atrule">eager-load</span><span class="token punctuation">:</span>
    <span class="token key atrule">enabled</span><span class="token punctuation">:</span> <span class="token boolean important">true</span> <span class="token comment"># 开启饥饿加载</span>
    <span class="token key atrule">clients</span><span class="token punctuation">:</span> <span class="token comment"># 指定饥饿加载的服务名称</span>
      <span class="token punctuation">-</span> userservice
</code></pre> 
<p>总结：</p> 
<blockquote> 
 <p>1、Ribbon负载均衡规则<br> （1）规则接口是IRule<br> （2）默认实现是ZoneAvoidanceRule，根据zone选择服务列表，然后轮询<br> 2、负载均衡自定义方式<br> （1）代码方式：配置灵活，但修改时需要重新打包发布<br> （2）配置方式：直观，方便，无需重新打包发布，但是无法做全局配置<br> 3、饥饿加载<br> （1）开启饥饿加载<br> （2）指定饥饿加载的微服务名称</p> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7b82ebd382508fe84329506c6e55b2c6/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【AI】无人零售和边缘计算</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/2112016034e7fc7b614217a1d24dde65/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">camera算法集成实现流程</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>