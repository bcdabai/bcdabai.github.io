<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据挖掘学习——SOM网络聚类算法&#43;python代码实现 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="数据挖掘学习——SOM网络聚类算法&#43;python代码实现" />
<meta property="og:description" content="目录
1.SOM简述
2.SOM训练过程
（1）初始化
（2）采样（抽取样本点）
（3）竞争
（4）合作和适应（更新权重值）
（5）重复
3.python 代码实现
（1）初始化
（2）计算样本点和权向量之间的拓扑距离
（3）竞争
（4）更新权重
1.SOM简述 SOM（Self Organizing Map）自组织映射网络，又称竞争型神经网络。可以通过将高维数据映射到结构和相互关系简单的低维空间中进行展示，从而实现数据可视化、聚类、分类等功能。
SOM网络与其他的神经网络不同，比起其他的神经网络，他更接近于Kmeans聚类算法，即K-均值聚类算法。
其结构如下图所示。
从图中可以看到，输出层的每个节点，通过D条权边与输入节点相连（即输出层的每个节点用一个D维权重Wij来表征），其中输出层中每个节点之间按照距离远近存在一定联系。
2.SOM训练过程 （1）初始化 为初始权向量选择随机值
（2）采样（抽取样本点） 从输入数据中抽取一个样本点，作为输入训练向量样本
（3）竞争 对于权向量，神经元计算它们各自的判别函数值，为竞争提供基础。具有最小判别函数值的特定神经元被宣布为胜利者。（判别函数可定义为输入训练向量样本和权向量之间的平方欧几里德距离）
大白话：计算各个神经元和第二步选取的训练样本点之间的拓扑距离，距离最近的就是胜出的权向量点（winner）
（4）合作和适应（更新权重值） 在神经生物学研究中，我们发现在一组兴奋神经元内存在横向的相互作用。当一个神经元被激活时，最近的邻居节点往往比那些远离的邻居节点更兴奋。并且存在一个随距离衰减的拓扑邻域。
上一步胜出的神经元将获得权重值的决定权。不仅获胜的神经元能够得到权重更新，它的邻居也将更新它们的权重，尽管不如获胜神经元更新的幅度大。
可以理解为最近的权向量节点向样本点移动一定距离，同时邻近节点也移动一定的距离。
（5）重复 回到第二步重复，直到匹配完所有的输入数据点
3.python 代码实现 （1）初始化 def __init__(self, X, output, iteration, batch_size): &#34;&#34;&#34; :param X: 形状是N*D， 输入样本有N个,每个D维 :param output: (n,m)一个元组，为输出层的形状是一个n*m的二维矩阵 :param iteration:迭代次数 :param batch_size:每次迭代时的样本数量 初始化一个权值矩阵，形状为D*(n*m)，即有n*m权值向量。权值由numpy随机函数生成。 &#34;&#34;&#34; self.X = X self.output = output self.iteration = iteration self.batch_size = batch_size self." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/d3387e93eacd7a24b39020f56060f64c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-10-04T11:37:40+08:00" />
<meta property="article:modified_time" content="2022-10-04T11:37:40+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据挖掘学习——SOM网络聚类算法&#43;python代码实现</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="-toc" style="margin-left:40px;"></p> 
<p id="1.SOM%E7%AE%80%E8%BF%B0-toc" style="margin-left:40px;"><a href="#1.SOM%E7%AE%80%E8%BF%B0" rel="nofollow">1.SOM简述</a></p> 
<p id="2.SOM%E8%AE%AD%E7%BB%83%E8%BF%87%E7%A8%8B-toc" style="margin-left:40px;"><a href="#2.SOM%E8%AE%AD%E7%BB%83%E8%BF%87%E7%A8%8B" rel="nofollow">2.SOM训练过程</a></p> 
<p id="%EF%BC%881%EF%BC%89%E5%88%9D%E5%A7%8B%E5%8C%96-toc" style="margin-left:80px;"><a href="#%EF%BC%881%EF%BC%89%E5%88%9D%E5%A7%8B%E5%8C%96" rel="nofollow">（1）初始化</a></p> 
<p id="%EF%BC%882%EF%BC%89%E9%87%87%E6%A0%B7%EF%BC%88%E6%8A%BD%E5%8F%96%E6%A0%B7%E6%9C%AC%E7%82%B9%EF%BC%89-toc" style="margin-left:80px;"><a href="#%EF%BC%882%EF%BC%89%E9%87%87%E6%A0%B7%EF%BC%88%E6%8A%BD%E5%8F%96%E6%A0%B7%E6%9C%AC%E7%82%B9%EF%BC%89" rel="nofollow">（2）采样（抽取样本点）</a></p> 
<p id="%EF%BC%883%EF%BC%89%E7%AB%9E%E4%BA%89-toc" style="margin-left:80px;"><a href="#%EF%BC%883%EF%BC%89%E7%AB%9E%E4%BA%89" rel="nofollow">（3）竞争</a></p> 
<p id="%EF%BC%884%EF%BC%89%E5%90%88%E4%BD%9C%E5%92%8C%E9%80%82%E5%BA%94%EF%BC%88%E6%9B%B4%E6%96%B0%E6%9D%83%E9%87%8D%E5%80%BC%EF%BC%89-toc" style="margin-left:80px;"><a href="#%EF%BC%884%EF%BC%89%E5%90%88%E4%BD%9C%E5%92%8C%E9%80%82%E5%BA%94%EF%BC%88%E6%9B%B4%E6%96%B0%E6%9D%83%E9%87%8D%E5%80%BC%EF%BC%89" rel="nofollow">（4）合作和适应（更新权重值）</a></p> 
<p id="%EF%BC%885%EF%BC%89%E9%87%8D%E5%A4%8D-toc" style="margin-left:80px;"><a href="#%EF%BC%885%EF%BC%89%E9%87%8D%E5%A4%8D" rel="nofollow">（5）重复</a></p> 
<p id="3.python%20%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-toc" style="margin-left:40px;"><a href="#3.python%20%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0" rel="nofollow">3.python 代码实现</a></p> 
<p id="%EF%BC%881%EF%BC%89%E5%88%9D%E5%A7%8B%E5%8C%96-toc" style="margin-left:80px;"><a href="#%EF%BC%881%EF%BC%89%E5%88%9D%E5%A7%8B%E5%8C%96" rel="nofollow">（1）初始化</a></p> 
<p id="%EF%BC%882%EF%BC%89%E8%AE%A1%E7%AE%97%E6%A0%B7%E6%9C%AC%E7%82%B9%E5%92%8C%E6%9D%83%E5%90%91%E9%87%8F%E4%B9%8B%E9%97%B4%E7%9A%84%E6%8B%93%E6%89%91%E8%B7%9D%E7%A6%BB-toc" style="margin-left:80px;"><a href="#%EF%BC%882%EF%BC%89%E8%AE%A1%E7%AE%97%E6%A0%B7%E6%9C%AC%E7%82%B9%E5%92%8C%E6%9D%83%E5%90%91%E9%87%8F%E4%B9%8B%E9%97%B4%E7%9A%84%E6%8B%93%E6%89%91%E8%B7%9D%E7%A6%BB" rel="nofollow">（2）计算样本点和权向量之间的拓扑距离</a></p> 
<p id="%EF%BC%883%EF%BC%89%E7%AB%9E%E4%BA%89-toc" style="margin-left:80px;"><a href="#%EF%BC%883%EF%BC%89%E7%AB%9E%E4%BA%89" rel="nofollow">（3）竞争</a></p> 
<p id="%EF%BC%884%EF%BC%89%E6%9B%B4%E6%96%B0%E6%9D%83%E9%87%8D-toc" style="margin-left:80px;"><a href="#%EF%BC%884%EF%BC%89%E6%9B%B4%E6%96%B0%E6%9D%83%E9%87%8D" rel="nofollow">（4）更新权重</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h3 id="1.SOM%E7%AE%80%E8%BF%B0">1.SOM简述</h3> 
<p>       SOM（Self Organizing Map）自组织映射网络，又称竞争型神经网络。可以通过将高维数据映射到结构和相互关系简单的低维空间中进行展示，从而实现数据可视化、聚类、分类等功能。</p> 
<p>       SOM网络与其他的神经网络不同，比起其他的神经网络，他更接近于Kmeans聚类算法，即K-均值聚类算法。</p> 
<p>       其结构如下图所示。</p> 
<h3 id="%E2%80%8B%E7%BC%96%E8%BE%91"><img alt="" height="267" src="https://images2.imgbox.com/4a/c9/kOXFfX2x_o.png" width="396"></h3> 
<p> 从图中可以看到，输出层的每个节点，通过D条权边与输入节点相连（即输出层的每个节点用一个D维权重Wij来表征），其中输出层中每个节点之间按照距离远近存在一定联系。</p> 
<h3 id="2.SOM%E8%AE%AD%E7%BB%83%E8%BF%87%E7%A8%8B">2.SOM训练过程</h3> 
<h4 id="%EF%BC%881%EF%BC%89%E5%88%9D%E5%A7%8B%E5%8C%96">（1）初始化</h4> 
<p>  为初始权向量选择随机值</p> 
<h4 id="%EF%BC%882%EF%BC%89%E9%87%87%E6%A0%B7%EF%BC%88%E6%8A%BD%E5%8F%96%E6%A0%B7%E6%9C%AC%E7%82%B9%EF%BC%89">（2）采样（抽取样本点）</h4> 
<p>  从输入数据中抽取一个样本点，作为输入训练向量样本</p> 
<h4 id="%EF%BC%883%EF%BC%89%E7%AB%9E%E4%BA%89">（3）竞争</h4> 
<p>  对于权向量，神经元计算它们各自的判别函数值，为竞争提供基础。具有最小判别函数值的特定神经元被宣布为胜利者。（判别函数可定义为输入训练向量样本和权向量之间的平方欧几里德距离）</p> 
<p>  大白话：计算各个神经元和第二步选取的训练样本点之间的拓扑距离，距离最近的就是胜出的权向量点（winner）</p> 
<h4 id="%EF%BC%884%EF%BC%89%E5%90%88%E4%BD%9C%E5%92%8C%E9%80%82%E5%BA%94%EF%BC%88%E6%9B%B4%E6%96%B0%E6%9D%83%E9%87%8D%E5%80%BC%EF%BC%89">（4）合作和适应（更新权重值）</h4> 
<p>  在神经生物学研究中，我们发现在一组兴奋神经元内存在横向的相互作用。当一个神经元被激活时，最近的邻居节点往往比那些远离的邻居节点更兴奋。并且存在一个随距离衰减的拓扑邻域。</p> 
<p>  上一步胜出的神经元将获得权重值的决定权。不仅获胜的神经元能够得到权重更新，它的邻居也将更新它们的权重，尽管不如获胜神经元更新的幅度大。</p> 
<p>  可以理解为最近的权向量节点向样本点移动一定距离，同时邻近节点也移动一定的距离。</p> 
<h4 id="%EF%BC%885%EF%BC%89%E9%87%8D%E5%A4%8D">（5）重复</h4> 
<p>  回到第二步重复，直到匹配完所有的输入数据点</p> 
<h3 id="3.python%20%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0">3.python 代码实现</h3> 
<h4>（1）初始化</h4> 
<pre><code>    def __init__(self, X, output, iteration, batch_size):
        """
        :param X:  形状是N*D， 输入样本有N个,每个D维
        :param output: (n,m)一个元组，为输出层的形状是一个n*m的二维矩阵
        :param iteration:迭代次数
        :param batch_size:每次迭代时的样本数量
        初始化一个权值矩阵，形状为D*(n*m)，即有n*m权值向量。权值由numpy随机函数生成。
        """
        self.X = X
        self.output = output
        self.iteration = iteration
        self.batch_size = batch_size
        self.W = np.random.rand(X.shape[1], output[0] * output[1])
        print(self.W.shape)</code></pre> 
<h4 id="%EF%BC%882%EF%BC%89%E8%AE%A1%E7%AE%97%E6%A0%B7%E6%9C%AC%E7%82%B9%E5%92%8C%E6%9D%83%E5%90%91%E9%87%8F%E4%B9%8B%E9%97%B4%E7%9A%84%E6%8B%93%E6%89%91%E8%B7%9D%E7%A6%BB">（2）计算样本点和权向量之间的拓扑距离</h4> 
<pre><code>    def GetN(self, t):
        """
        :param t:时间t, 这里用迭代次数来表示时间
        :return: 返回一个整数，表示拓扑距离，时间越大，拓扑邻域越小
        """
        a = min(self.output)
        return int(a - float(a) * t / self.iteration)

    def Geteta(self, t, n):
        """
        :param t: 时间t, 这里用迭代次数来表示时间
        :param n: 拓扑距离
        :return: 返回学习率，
        """
        return np.power(np.e, -n) / (t + 2)</code></pre> 
<h4>（3）竞争</h4> 
<pre><code> def train(self):
        """
        train_Y:训练样本与形状为batch_size*(n*m)
        winner:一个一维向量，batch_size个获胜神经元的下标
        :return:返回值是调整后的W
        """
        count = 0
        while self.iteration &gt; count:
            train_X = self.X[np.random.choice(self.X.shape[0], self.batch_size)]
            normal_W(self.W)
            normal_X(train_X)
            train_Y = train_X.dot(self.W)
            winner = np.argmax(train_Y, axis=1).tolist()
            self.updata_W(train_X, count, winner)
            count += 1
        return self.W

    def train_result(self):
        normal_X(self.X)
        train_Y = self.X.dot(self.W)
        winner = np.argmax(train_Y, axis=1).tolist()
        print(winner)
        return winner</code></pre> 
<h4 id="%EF%BC%884%EF%BC%89%E6%9B%B4%E6%96%B0%E6%9D%83%E9%87%8D">（4）更新权重</h4> 
<pre><code>    def updata_W(self, X, t, winner):
        N = self.GetN(t)
        for x, i in enumerate(winner):
            to_update = self.getneighbor(i[0], N)
            for j in range(N + 1):
                e = self.Geteta(t, j)
                for w in to_update[j]:
                    self.W[:, w] = np.add(self.W[:, w], e * (X[x, :] - self.W[:, w]))

    def getneighbor(self, index, N):
        """
        :param index:获胜神经元的下标
        :param N: 邻域半径
        :return ans: 返回一个集合列表，分别是不同邻域半径内需要更新的神经元坐标
        """
        a, b = self.output
        length = a * b

        def distence(index1, index2):
            i1_a, i1_b = index1 // a, index1 % b
            i2_a, i2_b = index2 // a, index2 % b
            return np.abs(i1_a - i2_a), np.abs(i1_b - i2_b)

        ans = [set() for i in range(N + 1)]
        for i in range(length):
            dist_a, dist_b = distence(i, index)
            if dist_a &lt;= N and dist_b &lt;= N: ans[max(dist_a, dist_b)].add(i)
        return ans</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/56f38f3a807e6651c4c5b8f3c83cea2f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">PTA 3&#43;2 转段考试 数据库mysql (3篇)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/996f24328e9d80010aab55149f932146/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【Java】实现简单的通信软件C/S（聊天、文件）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>