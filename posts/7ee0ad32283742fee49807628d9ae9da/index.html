<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【ASP.NET Core 基础知识】--依赖注入（DI）--生命周期和作用域 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【ASP.NET Core 基础知识】--依赖注入（DI）--生命周期和作用域" />
<meta property="og:description" content="在依赖注入（Dependency Injection，简称 DI）中，生命周期和作用域是非常重要的概念，它们对于正确设计和实现软件系统具有至关重要的作用。以下是生命周期和作用域在依赖注入中重要性的详细阐述：
生命周期的重要性
资源管理：生命周期定义了对象在系统中的存在时间。正确管理生命周期可以帮助我们更有效地管理系统资源，如内存和对象实例。性能优化：根据不同的生命周期模式，我们可以优化系统的性能。例如，单例模式可以减少对象的创建和销毁开销，从而提高性能。解耦和可测试性：生命周期可以帮助我们进一步解耦，使得代码更容易测试和维护。例如，瞬时对象可以在需要时创建，从而避免了对其他对象的硬性依赖。 作用域的重要性
控制对象的使用范围：作用域定义了对象在应用程序中的可见性和使用范围。这有助于我们更好地组织和管理代码，确保对象在正确的地方被使用。避免命名冲突：通过定义不同作用域，我们可以避免在全局命名空间中出现命名冲突的问题。实现特定场景的需求：某些场景可能需要对象在整个应用程序中都是可用的（如单例模式），而其他场景可能只需要对象在特定的上下文中可用（如请求作用域）。 生命周期与作用域的结合
在依赖注入框架中，生命周期和作用域通常是相互关联的。一个对象的生命周期决定了它存在的时间，而它的作用域决定了它在哪些上下文中可用。选择合适的作用域和生命周期对于构建可扩展、可维护和高性能的应用程序至关重要。
例如，一个数据库连接池可能采用单例模式以优化资源使用，同时设置其作用域为应用程序级别，以确保在整个应用程序中都可以重用这个连接池。相反，一个请求特定的对象（如一个用户会话）可能使用请求作用域，并且每次请求时都会创建一个新的对象实例。
一、生命周期 1.1 瞬时（Transient）模式 定义
瞬时模式指的是每次注入请求都会导致创建一个新的对象实例。这意味着，对于同一个注入点，每次请求都会有一个全新的对象。这个模式类似于函数式编程中的“无状态”概念，因为每次调用都会有一个全新的实例。
使用场景
瞬时模式适用于那些不依赖于其他对象、无状态且每次请求都需要新实例的情况。一些常见的使用场景包括：
短暂的计算过程： 瞬时对象适合于执行一次性任务，例如处理某个请求或执行一次性的计算。会话相关的数据： 如果数据与用户会话相关联，那么每次会话都应该有一个新的实例。**临时数据处理：**处理临时数据或中间数据的对象通常不需要与其他对象共享状态，因此适合使用瞬时模式。 优缺点
优点
隔离和独立性：由于每次请求都有一个新的实例，瞬时对象之间的状态不会相互影响。灵活性：瞬时模式允许为每个请求定制特定的参数或行为，而不受其他请求的影响。易于测试：瞬时对象易于单元测试，因为它们没有外部状态依赖，每次测试都是从一个干净的状态开始。 缺点
资源消耗：每次请求都创建新对象可能会导致更多的内存使用和对象创建的开销。缺乏持久性：瞬时对象无法保留状态，这可能导致在需要持久化数据的场景中使用不当。潜在的性能开销：频繁的对象创建和销毁可能会影响性能，特别是在大量并发请求的场景中。 瞬时模式在需要隔离状态、无状态操作或每次请求都需要一个新实例的场景中非常有用。然而，在使用瞬时模式时，也需要注意其潜在的资源消耗和性能影响。
1.2 作用域（Scoped）模式 定义
作用域模式定义了对象在应用程序中的范围或可见性。根据不同的作用域类型，对象可以在特定的上下文中被创建和使用，并可能受到作用域类型的生命周期管理。常见的作用域类型包括：
请求/上下文作用域（Request/Context Scope）：在这种作用域下，对象在处理单个请求期间存在，并在请求结束时被销毁。会话作用域（Session Scope）：在这种作用域下，对象在整个会话期间存在，并在会话结束时被销毁。应用程序作用域（Application Scope）：在这种作用域下，对象在整个应用程序生命周期内存在，即使请求结束也不会被销毁。服务作用域（Service Scope）：在这种作用域下，对象在特定的服务调用期间存在，并在服务调用结束时被销毁。 使用场景
作用域模式的使用场景取决于应用程序的需求和设计。以下是一些典型的使用场景：
请求/上下文作用域： 用于处理请求相关的临时数据，如请求日志、临时缓存等。适用于需要在请求处理期间保持状态的组件。 会话作用域： 用于存储与用户会话相关的数据，如用户首选项、购物车信息等。适用于需要在多个请求之间保持状态的组件。 应用程序作用域： 用于存储应用程序级别的全局数据，如配置信息、数据库连接池等。适用于需要在整个应用程序生命周期内保持状态的组件。 服务作用域： 用于存储与特定服务调用相关的数据，这些数据仅在服务调用期间相关。适用于需要在服务调用期间保持状态的组件。 优缺点
优点 生命周期管理：作用域模式允许对对象的生命周期进行精细管理，确保对象在正确的上下文中创建和销毁。内存优化：通过作用域管理，可以优化内存使用，避免不必要的内存分配和垃圾回收。状态管理：作用域模式有助于维护对象的状态，确保对象在正确的上下文中保持状态。 缺点 复杂性：使用多种作用域可能会增加应用程序的复杂性，需要谨慎设计和实现。性能开销：在某些情况下，作用域管理可能会引入性能开销，特别是在创建和销毁对象时。依赖性：对象的作用域可能会影响其他组件的依赖性，需要仔细考虑作用域的选择对应用程序设计的影响。跨作用域通信困难：在不同的作用域之间共享数据或状态可能会变得复杂。生命周期管理挑战：在某些情况下，确保对象在正确的时候创建和销毁可能具有挑战性，尤其是在并发环境中。 1.3 单例（Singleton）模式 定义
在单例模式中，类的实例化过程被限制，确保只能创建一个对象实例。这个唯一的实例可以通过一个全局访问点（公共静态成员变量或静态方法）来访问。使用场景
单例模式适用于以下情况： 需要全局访问的组件：如果一个组件需要在应用程序的任何地方都能被访问，并且这个组件只应该有一个实例，那么就可以使用单例模式。资源共享的情况：如果多个对象需要共享相同的资源（如数据库连接、日志记录器等），那么单例模式可以确保这个资源只被一个对象管理。控制资源的情况下：当资源的使用需要被严格控制时，例如数据库连接、线程池等，使用单例模式可以确保资源的合理使用和性能优化。需要频繁实例化然后销毁的对象：如果一个对象在多个地方被频繁地创建和销毁，但它的生命周期并不需要这么频繁，那么使用单例模式可以减少对象的创建和销毁次数，提高性能。创建对象时耗时过多或者耗资源过多的对象：如果创建一个对象需要消耗大量的资源和时间，那么使用单例模式可以避免频繁地创建和销毁对象。有状态的工具类对象：如果一个工具类对象需要保存一些状态信息，并且这些状态信息需要在多个地方共享，那么可以使用单例模式来实现这个功能。 优缺点 优点
- 资源优化：通过限制对象的创建，单例模式可以优化资源的使用，特别是当创建对象的开销很大时。
- 全局访问：单例模式提供了一种全局访问点，使得对象可以在应用程序的任何地方被访问。
- 控制实例数量：单例模式可以确保一个类只有一个实例，这对于需要严格控制实例数量的系统很有用。缺点 可测试性差：由于单例对象在系统启动时就创建了，这使得对单例对象的测试变得困难，因为对象已经存在，无法模拟它的创建过程。设计局限性：单例模式不符合“开闭原则”（Open-Closed Principle），即开可以扩展，但不能修改已有的代码。如果要添加新的单例实例，可能需要修改原始的代码。设计模式滥用：有时候可能会过度使用单例模式，导致系统难以测试和维护。全局状态：单例模式可能导致全局状态的存在，这可能会导致设计上的问题，并增加系统的复杂性。并发问题：在多线程环境中，如果单例模式没有正确实现线程同步，可能会导致并发问题，如数据不一致性等。 单例模式它适用于需要全局访问的组件和资源共享的情况。然而，在使用单例模式时，也需要注意它的局限性和潜在问题，如可测试性差、设计局限性、全局状态和并发问题等。
二、作用域 定义" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/7ee0ad32283742fee49807628d9ae9da/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-25T00:39:15+08:00" />
<meta property="article:modified_time" content="2024-01-25T00:39:15+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【ASP.NET Core 基础知识】--依赖注入（DI）--生命周期和作用域</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>在依赖注入（Dependency Injection，简称 DI）中，生命周期和作用域是非常重要的概念，它们对于正确设计和实现软件系统具有至关重要的作用。以下是生命周期和作用域在依赖注入中重要性的详细阐述：</p> 
<ol><li> <p><strong>生命周期的重要性</strong></p> 
  <ul><li><strong>资源管理</strong>：生命周期定义了对象在系统中的存在时间。正确管理生命周期可以帮助我们更有效地管理系统资源，如内存和对象实例。</li><li><strong>性能优化</strong>：根据不同的生命周期模式，我们可以优化系统的性能。例如，单例模式可以减少对象的创建和销毁开销，从而提高性能。</li><li><strong>解耦和可测试性</strong>：生命周期可以帮助我们进一步解耦，使得代码更容易测试和维护。例如，瞬时对象可以在需要时创建，从而避免了对其他对象的硬性依赖。</li></ul> </li><li> <p><strong>作用域的重要性</strong></p> 
  <ul><li><strong>控制对象的使用范围</strong>：作用域定义了对象在应用程序中的可见性和使用范围。这有助于我们更好地组织和管理代码，确保对象在正确的地方被使用。</li><li><strong>避免命名冲突</strong>：通过定义不同作用域，我们可以避免在全局命名空间中出现命名冲突的问题。</li><li><strong>实现特定场景的需求</strong>：某些场景可能需要对象在整个应用程序中都是可用的（如单例模式），而其他场景可能只需要对象在特定的上下文中可用（如请求作用域）。</li></ul> </li><li> <p><strong>生命周期与作用域的结合</strong><br> 在依赖注入框架中，生命周期和作用域通常是相互关联的。一个对象的生命周期决定了它存在的时间，而它的作用域决定了它在哪些上下文中可用。选择合适的作用域和生命周期对于构建可扩展、可维护和高性能的应用程序至关重要。<br> 例如，一个数据库连接池可能采用单例模式以优化资源使用，同时设置其作用域为应用程序级别，以确保在整个应用程序中都可以重用这个连接池。相反，一个请求特定的对象（如一个用户会话）可能使用请求作用域，并且每次请求时都会创建一个新的对象实例。</p> </li></ol> 
<h4><a id="_14"></a>一、生命周期</h4> 
<h6><a id="11_Transient_15"></a>1.1 瞬时（Transient）模式</h6> 
<ol><li> <p><strong>定义</strong><br> 瞬时模式指的是每次注入请求都会导致创建一个新的对象实例。这意味着，对于同一个注入点，每次请求都会有一个全新的对象。这个模式类似于函数式编程中的“无状态”概念，因为每次调用都会有一个全新的实例。</p> </li><li> <p><strong>使用场景</strong><br> 瞬时模式适用于那些不依赖于其他对象、无状态且每次请求都需要新实例的情况。一些常见的使用场景包括：</p> 
  <ul><li><strong>短暂的计算过程：</strong> 瞬时对象适合于执行一次性任务，例如处理某个请求或执行一次性的计算。</li><li><strong>会话相关的数据：</strong> 如果数据与用户会话相关联，那么每次会话都应该有一个新的实例。</li><li>**临时数据处理：**处理临时数据或中间数据的对象通常不需要与其他对象共享状态，因此适合使用瞬时模式。</li></ul> </li><li> <p><strong>优缺点</strong></p> 
  <ul><li> <p><strong>优点</strong></p> 
    <ul><li><strong>隔离和独立性</strong>：由于每次请求都有一个新的实例，瞬时对象之间的状态不会相互影响。</li><li><strong>灵活性</strong>：瞬时模式允许为每个请求定制特定的参数或行为，而不受其他请求的影响。</li><li><strong>易于测试</strong>：瞬时对象易于单元测试，因为它们没有外部状态依赖，每次测试都是从一个干净的状态开始。</li></ul> </li><li> <p><strong>缺点</strong></p> 
    <ul><li><strong>资源消耗</strong>：每次请求都创建新对象可能会导致更多的内存使用和对象创建的开销。</li><li><strong>缺乏持久性</strong>：瞬时对象无法保留状态，这可能导致在需要持久化数据的场景中使用不当。</li><li><strong>潜在的性能开销</strong>：频繁的对象创建和销毁可能会影响性能，特别是在大量并发请求的场景中。</li></ul> </li></ul> </li></ol> 
<p>瞬时模式在需要隔离状态、无状态操作或每次请求都需要一个新实例的场景中非常有用。然而，在使用瞬时模式时，也需要注意其潜在的资源消耗和性能影响。</p> 
<h6><a id="12_Scoped_36"></a>1.2 作用域（Scoped）模式</h6> 
<ol><li> <p><strong>定义</strong><br> 作用域模式定义了对象在应用程序中的范围或可见性。根据不同的作用域类型，对象可以在特定的上下文中被创建和使用，并可能受到作用域类型的生命周期管理。常见的作用域类型包括：</p> 
  <ul><li><strong>请求/上下文作用域（Request/Context Scope）</strong>：在这种作用域下，对象在处理单个请求期间存在，并在请求结束时被销毁。</li><li><strong>会话作用域（Session Scope）</strong>：在这种作用域下，对象在整个会话期间存在，并在会话结束时被销毁。</li><li><strong>应用程序作用域（Application Scope）</strong>：在这种作用域下，对象在整个应用程序生命周期内存在，即使请求结束也不会被销毁。</li><li><strong>服务作用域（Service Scope）</strong>：在这种作用域下，对象在特定的服务调用期间存在，并在服务调用结束时被销毁。</li></ul> </li><li> <p><strong>使用场景</strong><br> 作用域模式的使用场景取决于应用程序的需求和设计。以下是一些典型的使用场景：</p> 
  <ul><li><strong>请求/上下文作用域</strong>： 
    <ul><li>用于处理请求相关的临时数据，如请求日志、临时缓存等。</li><li>适用于需要在请求处理期间保持状态的组件。</li></ul> </li><li><strong>会话作用域</strong>： 
    <ul><li>用于存储与用户会话相关的数据，如用户首选项、购物车信息等。</li><li>适用于需要在多个请求之间保持状态的组件。</li></ul> </li><li><strong>应用程序作用域</strong>： 
    <ul><li>用于存储应用程序级别的全局数据，如配置信息、数据库连接池等。</li><li>适用于需要在整个应用程序生命周期内保持状态的组件。</li></ul> </li><li><strong>服务作用域</strong>： 
    <ul><li>用于存储与特定服务调用相关的数据，这些数据仅在服务调用期间相关。</li><li>适用于需要在服务调用期间保持状态的组件。</li></ul> </li></ul> </li><li> <p><strong>优缺点</strong></p> 
  <ul><li><strong>优点</strong> 
    <ul><li><strong>生命周期管理</strong>：作用域模式允许对对象的生命周期进行精细管理，确保对象在正确的上下文中创建和销毁。</li><li><strong>内存优化</strong>：通过作用域管理，可以优化内存使用，避免不必要的内存分配和垃圾回收。</li><li><strong>状态管理</strong>：作用域模式有助于维护对象的状态，确保对象在正确的上下文中保持状态。</li></ul> </li><li><strong>缺点</strong> 
    <ul><li><strong>复杂性</strong>：使用多种作用域可能会增加应用程序的复杂性，需要谨慎设计和实现。</li><li><strong>性能开销</strong>：在某些情况下，作用域管理可能会引入性能开销，特别是在创建和销毁对象时。</li><li><strong>依赖性</strong>：对象的作用域可能会影响其他组件的依赖性，需要仔细考虑作用域的选择对应用程序设计的影响。</li><li><strong>跨作用域通信困难</strong>：在不同的作用域之间共享数据或状态可能会变得复杂。</li><li><strong>生命周期管理挑战</strong>：在某些情况下，确保对象在正确的时候创建和销毁可能具有挑战性，尤其是在并发环境中。</li></ul> </li></ul> </li></ol> 
<h6><a id="13_Singleton_70"></a>1.3 单例（Singleton）模式</h6> 
<ol><li><strong>定义</strong><br> 在单例模式中，类的实例化过程被限制，确保只能创建一个对象实例。这个唯一的实例可以通过一个全局访问点（公共静态成员变量或静态方法）来访问。</li><li><strong>使用场景</strong><br> 单例模式适用于以下情况： 
  <ul><li><strong>需要全局访问的组件</strong>：如果一个组件需要在应用程序的任何地方都能被访问，并且这个组件只应该有一个实例，那么就可以使用单例模式。</li><li><strong>资源共享的情况</strong>：如果多个对象需要共享相同的资源（如数据库连接、日志记录器等），那么单例模式可以确保这个资源只被一个对象管理。</li><li><strong>控制资源的情况下</strong>：当资源的使用需要被严格控制时，例如数据库连接、线程池等，使用单例模式可以确保资源的合理使用和性能优化。</li><li><strong>需要频繁实例化然后销毁的对象</strong>：如果一个对象在多个地方被频繁地创建和销毁，但它的生命周期并不需要这么频繁，那么使用单例模式可以减少对象的创建和销毁次数，提高性能。</li><li><strong>创建对象时耗时过多或者耗资源过多的对象</strong>：如果创建一个对象需要消耗大量的资源和时间，那么使用单例模式可以避免频繁地创建和销毁对象。</li><li><strong>有状态的工具类对象</strong>：如果一个工具类对象需要保存一些状态信息，并且这些状态信息需要在多个地方共享，那么可以使用单例模式来实现这个功能。</li></ul> </li><li><strong>优缺点</strong></li></ol> 
<ul><li><strong>优点</strong><br> - <strong>资源优化</strong>：通过限制对象的创建，单例模式可以优化资源的使用，特别是当创建对象的开销很大时。<br> - <strong>全局访问</strong>：单例模式提供了一种全局访问点，使得对象可以在应用程序的任何地方被访问。<br> - <strong>控制实例数量</strong>：单例模式可以确保一个类只有一个实例，这对于需要严格控制实例数量的系统很有用。</li><li><strong>缺点</strong> 
  <ul><li><strong>可测试性差</strong>：由于单例对象在系统启动时就创建了，这使得对单例对象的测试变得困难，因为对象已经存在，无法模拟它的创建过程。</li><li><strong>设计局限性</strong>：单例模式不符合“开闭原则”（Open-Closed Principle），即开可以扩展，但不能修改已有的代码。如果要添加新的单例实例，可能需要修改原始的代码。</li><li><strong>设计模式滥用</strong>：有时候可能会过度使用单例模式，导致系统难以测试和维护。</li><li><strong>全局状态</strong>：单例模式可能导致全局状态的存在，这可能会导致设计上的问题，并增加系统的复杂性。</li><li><strong>并发问题</strong>：在多线程环境中，如果单例模式没有正确实现线程同步，可能会导致并发问题，如数据不一致性等。</li></ul> </li></ul> 
<p>单例模式它适用于需要全局访问的组件和资源共享的情况。然而，在使用单例模式时，也需要注意它的局限性和潜在问题，如可测试性差、设计局限性、全局状态和并发问题等。</p> 
<h4><a id="_94"></a>二、作用域</h4> 
<ol><li> <p><strong>定义</strong><br> 作用域（Scope）在编程中是指程序中变量或函数的可访问范围，也就是变量或函数的可见性。在一个程序中，变量或函数的作用域是由声明它们的位置所决定的。在作用域内，变量或函数是可以被程序代码访问和调用的。</p> </li><li> <p><strong>作用域在依赖注入中的重要性</strong><br> 在依赖注入（Dependency Injection）中，作用域（Scope）是一个关键概念，它定义了组件实例的生命周期，即组件实例在应用程序中是如何创建和共享的。</p> 
  <ul><li><strong>控制组件实例的创建</strong>：通过定义作用域，可以控制何时以及如何创建组件实例。例如，单例作用域确保只有一个组件实例被创建，而原型作用域则每次请求都创建一个新的实例。</li><li><strong>管理组件的生命周期</strong>：作用域决定了组件实例的存在时间。例如，请求作用域的组件实例通常在请求期间创建并在请求结束时销毁。</li><li><strong>解耦和降低耦合</strong>：通过利用不同作用域的组件，可以降低组件之间的耦合度。例如，一个单例组件可以为多个请求提供服务，而不需要了解请求的细节。</li><li><strong>提高性能</strong>：在某些情况下，通过使用单例或请求作用域的组件，可以避免不必要的对象创建和销毁，从而提高应用程序的性能。</li><li><strong>实现高级依赖注入功能</strong>：某些依赖注入框架允许定义自定义作用域，这使得可以实现更复杂的组件管理策略。</li><li><strong>支持模块化开发</strong>：通过使用不同的作用域，可以更好地组织和管理应用程序的不同组件，支持模块化开发和组件重用。</li><li><strong>促进单元测试</strong>：作用域可以帮助创建适合测试的组件实例，例如，使用作用域可以创建仅在测试期间存在的组件实例。</li></ul> </li><li> <p><strong>作用域的管理方式</strong><br> 在ASP.NET Core中，作用域（Scope）管理是依赖注入（DI）系统的一部分，用于管理组件实例的生命周期。ASP.NET Core使用中间件（Middleware）和依赖注入（DI）来构建Web应用，作用域在这里扮演着重要的角色。</p> </li><li> <p><strong>IServiceScope</strong>：ASP.NET Core使用<code>IServiceScope</code>接口来创建和管理作用域。<code>IServiceScope</code>允许在当前请求的上下文中创建一个新的作用域，这个新的作用域可以包含自己的服务，并且可以访问父作用域的服务。</p> </li><li> <p><strong>ServiceLifetime</strong>：在ASP.NET Core中，服务生命周期（<code>ServiceLifetime</code>）定义了服务实例的创建和管理方式。常见的服务生命周期包括：</p> 
  <ul><li><code>Transient</code>: 每次请求创建一个新实例，适用于需要频繁创建的服务，例如日志记录器。</li><li><code>Scoped</code>: 每个请求创建一个实例，并在请求期间重复使用，适用于与请求相关的服务，例如HttpContext。</li><li><code>Singleton</code>: 整个应用程序共享一个实例，适用于不需要与请求关联的服务。</li></ul> </li><li> <p><strong>依赖注入管道</strong>：ASP.NET Core的DI容器在应用程序启动时创建，并注册服务。当请求到达时，DI容器会在相应的服务作用域中提供所需的实例。</p> </li><li> <p><strong>HttpContext.RequestServices</strong>：在ASP.NET Core中，<code>HttpContext.RequestServices</code>属性提供了当前请求作用域中的服务。这意味着在控制器、视图组件、中间件等地方，可以通过<code>HttpContext.RequestServices</code>获取需要的服务实例。</p> </li><li> <p><strong>Root Services 和 Request Services</strong>：在ASP.NET Core中，存在两种主要的服务作用域：</p> 
  <ul><li><strong>Root Services</strong>：与应用程序生命周期相同，通常用于管理全局的单例服务。</li><li><strong>Request Services</strong>：与请求生命周期相同，每次HTTP请求都会创建一个新的作用域，用于管理该请求期间需要的服务。</li></ul> </li></ol> 
<h4><a id="_120"></a>三、如何选择合适的生命周期和作用域</h4> 
<p>选择合适的服务生命周期和作用域是ASP.NET Core应用依赖注入（DI）系统中的关键决策，它直接影响到应用程序的性能和正确性。以下是一些基本指导原则来帮助你做出这些决策：</p> 
<ol><li> <p><strong>服务实例的生命周期</strong></p> 
  <ul><li><strong>瞬时（Transient）</strong>：如果每个请求需要一个独立的实例，或者实例的状态仅在该请求中有效，则使用Transient生命周期。</li><li><strong>作用域（Scoped）</strong>：如果服务实例的状态需要在多个请求之间共享，例如在同一个会话（Session）中，那么使用Scoped生命周期。</li><li><strong>单例（Singleton）</strong>：如果服务实例的状态需要在整个应用程序生命周期中保持一致，并且不需要与特定请求关联，则使用Singleton生命周期。</li></ul> </li><li> <p><strong>服务实例的作用域</strong></p> 
  <ul><li><strong>瞬时（Transient）</strong>：通常没有特定的作用域需求，因为每个请求都会创建新实例。</li><li><strong>作用域（Scoped）</strong>：如果服务需要在请求期间保持可用，并且在请求结束后可以被销毁，则使用Request Scope（Scoped）作用域。</li><li><strong>单例（Singleton）</strong>：如果服务实例需要在应用程序的所有请求之间共享，并且状态需要在请求之间持久化，则使用Singleton作用域。</li></ul> </li><li> <p><strong>性能考虑</strong></p> 
  <ul><li><strong>瞬时（Transient）</strong>：创建新实例可能会带来性能开销，但对于某些服务这是必需的。</li><li><strong>作用域（Scoped）</strong>：在请求期间重复使用同一个实例可以提高性能，但需要注意资源管理。</li><li><strong>单例（Singleton）</strong>：在整个应用程序中重复使用同一个实例可以带来性能提升，但需要谨慎处理并发访问和状态管理。</li></ul> </li><li> <p><strong>安全性考虑</strong></p> 
  <ul><li><strong>瞬时（Transient）</strong>：由于每个请求都有自己的实例，因此不存在共享状态的问题。</li><li><strong>作用域（Scoped）</strong>：需要确保服务实例在请求结束时正确释放资源，以避免潜在的安全问题。</li><li><strong>单例（Singleton）</strong>：需要特别注意线程安全和数据隔离，以防止不同请求之间的状态污染。</li></ul> </li><li> <p><strong>测试和调试</strong></p> 
  <ul><li><strong>瞬时（Transient）</strong>：对于调试和测试非常有用，因为可以在每个请求中设置断点或更改行为。</li><li><strong>作用域（Scoped）</strong>：在调试时可能不太方便，因为服务实例在请求结束后就被销毁了。</li><li><strong>单例（Singleton）</strong>：在调试和测试时可能很有用，因为可以在整个应用程序生命周期内跟踪服务实例的状态。</li></ul> </li><li> <p><strong>依赖项的性质</strong></p> 
  <ul><li><strong>瞬时（Transient）</strong>：适用于无状态或无须与其他请求共享数据的依赖项。</li><li><strong>作用域（Scoped）</strong>：适用于需要在多个请求之间维护状态或数据的依赖项。</li><li><strong>单例（Singleton）</strong>：适用于全局配置、数据库连接池等全局资源。</li></ul> </li></ol> 
<p>最后，选择生命周期和作用域时，应该考虑服务的本质以及它在整个应用程序中的使用方式。通常，最佳实践是通过代码审查和测试来验证选择的合理性，并根据实际应用程序的需求进行调整。</p> 
<h4><a id="_153"></a>五、总结</h4> 
<p>在ASP.NET Core中，依赖注入（DI）系统提供了三种服务生命周期：瞬时（Transient）、作用域（Scoped）和单例（Singleton）。瞬时服务在每个请求中都会创建新实例，适合无状态或无须共享数据的依赖项。作用域服务在请求期间重复使用同一个实例，适用于需要保持状态或数据的依赖项。单例服务在整个应用程序生命周期中只有一个实例，适用于全局配置或长时间运行的任务。<br> 作用域（Scoped）服务在ASP.NET Core中有特殊的行为，它实际上是Request Scope（请求作用域），在每个Http请求期间创建新实例并重复使用，请求结束后销毁。这种作用域适用于需要在请求处理过程中访问的依赖项，如HttpContext。<br> 选择合适的生命周期和作用域对于应用程序的性能和正确性至关重要。开发者应根据服务的需求和使用场景来决定生命周期和作用域，并通过代码审查和测试来验证选择的合理性。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4f7020feacffb3ec709097c6c4b96685/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">CentOS：重定向及nohup不输出的方法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5e399b0b998a3159968a82b1c12925e6/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">又有一款 Pi 开发板来了（Remi Pi）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>