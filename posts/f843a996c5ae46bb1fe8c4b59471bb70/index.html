<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>后序线索化二叉树及遍历（图解） - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="后序线索化二叉树及遍历（图解）" />
<meta property="og:description" content="上一篇博客对于 二叉树线索化以及线索化的先序、中序、后序遍历做了比较详细的描述
写在前面
其实，我还是很想把本篇博客和二叉树的线索化写在一块的，但是考虑到可能这博客的内容就看足以超过了上一篇的篇幅，考虑到读者可能会疲乏，而且这篇也是线索二叉树中最难的了（查阅了很多网上的资料也鲜有人来讲述后序线索二叉树的遍历，有的就算有也只是把代码放在那里，理解 对于初学者还是有点困难的）
构建节点（多了双亲节点节点）
typedef enum { Link, Thread }Pointer; typedef struct TriTreeNode { TriTreeNode(const char data) :_data(data) , pLeft(NULL) , pRight(NULL) , pParent(NULL) , Ltag(Link) , Rtag(Link) {} char _data; struct TriTreeNode* pLeft; struct TriTreeNode* pRight; struct TriTreeNode* pParent;//双亲 Pointer Ltag, Rtag; }TriTreeNode; 还是先给出一个树结构吧：
后序线索化二叉树
后序的顺序是：左- 右-根
思路：和先序、中序线索化二叉树的顺序是一样的，在此不再赘述，想看的话上一篇博客会让你满意的。
上代码：
void _PostThreading(TriTreeNode*&amp; Root) { if (Root) { _PostThreading(Root-&gt;pLeft); _PostThreading(Root-&gt;pRight); if (Root-&gt;pLeft == NULL) { Root-&gt;pLeft = Prev; Root-&gt;Ltag = Thread; } if (Prev &amp;&amp; Prev-&gt;pRight == NULL ) //条件 Prev { Prev-&gt;pRight = Root; Prev-&gt;Rtag = Thread; } Prev = Root; } } 如下图，后序线索化的二叉树" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/f843a996c5ae46bb1fe8c4b59471bb70/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2016-08-01T19:31:20+08:00" />
<meta property="article:modified_time" content="2016-08-01T19:31:20+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">后序线索化二叉树及遍历（图解）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><span style="font-size:18px">上一篇博客对于 <a target="_blank" href="http://blog.csdn.net/my_heart_/article/details/52086321" rel="noopener noreferrer">二叉树线索化以及线索化的先序、中序、后序遍历做了比较详细的描述</a></span></p> 
<p><strong><span style="font-size:24px">写在前面</span></strong></p> 
<p><span style="font-size:18px"> 其实，我还是很想把本篇博客和二叉树的线索化写在一块的，但是考虑到可能这博客的内容就看足以超过了上一篇的篇幅，考虑到读者可能会疲乏，而且这篇也是线索二叉树中最难的了（查阅了很多网上的资料也鲜有人来讲述后序线索二叉树的遍历，有的就算有也只是把代码放在那里，理解 对于初学者还是有点困难的）</span></p> 
<p><span style="font-size:18px"><br> </span></p> 
<p><span style="font-size:18px; background-color:rgb(255,255,0)">构建节点</span><span style="font-size:18px; background-color:rgb(255,255,255)">（<strong>多了双亲节点节点</strong>）</span></p> 
<p><span style="font-size:18px; background-color:rgb(240,240,240)"></span></p> 
<pre><code class="language-cpp">typedef enum
{
	Link,
	Thread
}Pointer;

typedef struct TriTreeNode
{
	TriTreeNode(const char data)
	:_data(data)
	, pLeft(NULL)
	, pRight(NULL)
	, pParent(NULL)
	, Ltag(Link)
	, Rtag(Link)
	{}
	char _data;
	struct TriTreeNode* pLeft;
	struct TriTreeNode* pRight;
	struct TriTreeNode* pParent;//双亲
	Pointer Ltag, Rtag;
}TriTreeNode;</code></pre> 
<p><br> </p> 
<p><span style="font-size:18px">还是先给出一个树结构吧：</span></p> 
<p><span style="background-color:rgb(255,255,255)"><span style="font-size:18px"><br> </span></span></p> 
<p><strong><span style="font-size:24px; color:#ff0000; background-color:rgb(255,255,0)">后序线索化二叉树</span></strong></p> 
<p><span style="font-size:18px">后序的顺序是：左- 右-根</span></p> 
<p>思路：和先序、中序线索化二叉树的顺序是一样的，在此不再赘述，想看的话上一篇博客会让你满意的。</p> 
<p><br> </p> 
<p>上代码：</p> 
<p></p> 
<pre><code class="language-cpp">void _PostThreading(TriTreeNode*&amp;  Root)
	{
		if (Root)
		{
			_PostThreading(Root-&gt;pLeft);
			_PostThreading(Root-&gt;pRight);
			if (Root-&gt;pLeft == NULL)
			{
				Root-&gt;pLeft = Prev;
				Root-&gt;Ltag = Thread;
			}
			if (Prev &amp;&amp; Prev-&gt;pRight == NULL ) //条件 Prev
			{
				Prev-&gt;pRight = Root;
				Prev-&gt;Rtag = Thread;
			}
			Prev = Root;
		}
	}</code></pre> 
<p></p> 
<p><span style="font-size:18px">如下图，后序线索化的二叉树</span></p> 
<p><span style="background-color:rgb(255,255,255)"><span style="font-size:18px"><img src="https://images2.imgbox.com/58/4e/7Afz7cBd_o.png" alt=""></span></span></p> 
<p><span style="color:#ff0000"><span style="font-size:24px; background-color:rgb(255,255,0)"><strong><br> </strong></span></span></p> 
<p><strong><span style="font-size:24px; color:#ff0000; background-color:rgb(255,255,0)">！！！</span></strong></p> 
<p><strong><span style="font-size:24px; color:#ff0000; background-color:rgb(255,255,0)">后序遍历线索二叉树</span></strong></p> 
<p><span style="font-size:18px">由后序遍历的顺序，我们很容易就想到了找到后序遍历的起点（左子树最左边的节点），然后一直遍历节点的后继（记住每次遍历的前一个节点），当遍历到节点没有后继了，我们就判断是不是到了根节点了（如果根节点没有右子树，就是这种情况了），要是还没有到根节点，那就继续找寻节点的双亲节点（此时就需要我们催节点的结构进行增加双亲节点了），一直找到根节点的位置，继续判断根节点是不是存在右子树（注意这里不能用NULL判断右子树是不是存在，而是用右子树存在的标识Rtag ）</span></p> 
<p><span style="font-size:18px">好了，描述再多还是代码代码来的实在！！！</span></p> 
<p><span style="font-size:18px"></span></p> 
<pre><code class="language-cpp">	void _PostOrder(TriTreeNode* Root)
	{
		if (Root)
		{
			TriTreeNode* pCur = Root;
			Prev = NULL;
			while (pCur != NULL)
			{
				//第一步：找树最左边的节点
				while ( pCur-&gt;pLeft != Prev &amp;&amp; pCur-&gt;Ltag == Link) //左子树
				{
					pCur = pCur-&gt;pLeft;
				}
				//循环结束后 pCur== Root 或者为空

				//第二步：访问后继
				while (pCur &amp;&amp; pCur-&gt;Rtag== Thread)
				{
					cout &lt;&lt; pCur-&gt;_data &lt;&lt; ' ';
					Prev = pCur;
					pCur = pCur-&gt;pRight;
				}
				//判断此时pCur是不是指向了根节点
				if (pCur == Root)
				{
					cout &lt;&lt; pCur-&gt;_data &lt;&lt; ' ';
					return;
				}
				while (pCur &amp;&amp; pCur-&gt;pRight == Prev)
				{
					cout &lt;&lt; pCur-&gt;_data &lt;&lt; ' ';
					Prev = pCur;
					pCur = pCur-&gt;pParent;  //往上一级走
				}
				//这里不能用NULL判断，而是用Rtag
				if (pCur &amp;&amp; pCur-&gt;Rtag == Link)
				{
					pCur = pCur-&gt;pRight;
				}
			}
	        //end-while
		}
	}</code></pre>下面就是对代码的一一讲述 &lt; 
<span style="color:#cc0000"><strong>福利来了</strong></span>&gt; 
<p></p> 
<p><span style="font-size:18px">首先对，<span style="color:#ff0000">大循环中的第一个循环解释（找到最左边的节点）</span></span></p> 
<p><img src="https://images2.imgbox.com/e8/9e/iazLKZU1_o.png" alt=""><br> </p> 
<p><span style="font-size:18px; color:#ff0000">第二个循环（访问后继）</span></p> 
<p><span style="font-size:18px"><img src="https://images2.imgbox.com/2f/68/HqeWX762_o.png" alt=""><br> </span></p> 
<p><span style="font-size:18px; color:#ff0000">第三个循环以及后面的判断</span></p> 
<img src="https://images2.imgbox.com/6f/45/I0tbKyua_o.png" alt=""> 
<p><br> </p> 
<p><span style="font-size:18px">后面就是对代码的<strong>测试</strong>了</span></p> 
<p><span style="font-size:18px"><br> </span></p> 
<p><span style="font-size:18px">来个简单的Tree</span></p> 
<p><img src="https://images2.imgbox.com/f3/83/5DqRitdQ_o.png" alt=""></p> 
<p><span style="font-size:18px">加深一点</span></p> 
<p><img src="https://images2.imgbox.com/2b/75/5GZdu7zE_o.png" alt=""></p> 
<p><span style="font-size:18px">再难点吧。哈哈</span></p> 
<p><span style="font-size:18px"><img src="https://images2.imgbox.com/54/38/fEUIzdVi_o.png" alt=""><br> </span></p> 
<p><span style="font-size:18px"><br> </span></p> 
<p><span style="font-size:18px">能看到这里的都是好样的！</span></p> 
<p><span style="font-size:18px"><br> </span></p> 
<p><span style="font-size:24px; color:#ff0000"><strong>全部代码</strong></span><span style="font-size:18px">：</span></p> 
<p><span style="font-size:18px"></span></p> 
<pre><code class="language-cpp">#define _CRT_SECURE_NO_WARNINGS 1
#include&lt;iostream&gt;
using namespace std;

typedef enum
{
	Link,
	Thread
}Pointer;

typedef struct TriTreeNode
{
	TriTreeNode(const char data)
	:_data(data)
	, pLeft(NULL)
	, pRight(NULL)
	, pParent(NULL)
	, Ltag(Link)
	, Rtag(Link)
	{}
	char _data;
	struct TriTreeNode* pLeft;
	struct TriTreeNode* pRight;
	struct TriTreeNode* pParent;//双亲
	Pointer Ltag, Rtag;
}TriTreeNode;

class PostThread_BiTree
{
public://先序遍历创建树
	PostThread_BiTree(const char arr[], size_t size)
	{
		size_t index = 0;
		TriTreeNode* parent = NULL;
		_Creat_Bitree(_pRoot, arr, size, index, parent);
	}
protected:
	void _Creat_Bitree(TriTreeNode*&amp; Root, const char arr[], size_t size, size_t&amp; index , TriTreeNode*&amp; parent)
	{
		if (arr &amp;&amp; size &gt; index &amp;&amp; arr[index] != '#')
		{
			Root = new TriTreeNode(arr[index]);
			Root-&gt;pParent = parent;

			_Creat_Bitree(Root-&gt;pLeft, arr, size, ++index , Root);  //每次传双亲节点
			_Creat_Bitree(Root-&gt;pRight, arr, size, ++index , Root);
		}
	}
public:
	//后序线索化
	void PostTreading()
	{
		_PostThreading(this-&gt;_pRoot);
	}
protected:
	void _PostThreading(TriTreeNode*&amp;  Root)
	{
		if (Root)
		{
			_PostThreading(Root-&gt;pLeft);
			_PostThreading(Root-&gt;pRight);
			if (Root-&gt;pLeft == NULL)
			{
				Root-&gt;pLeft = Prev;
				Root-&gt;Ltag = Thread;
			}
			if (Prev &amp;&amp; Prev-&gt;pRight == NULL ) //条件 Prev
			{
				Prev-&gt;pRight = Root;
				Prev-&gt;Rtag = Thread;
			}
			Prev = Root;
		}
	}
public:
	void PostOrder()
	{
		_PostOrder(this-&gt;_pRoot);
	}
protected:
	void _PostOrder(TriTreeNode* Root)
	{
		if (Root)
		{
			TriTreeNode* pCur = Root;
			Prev = NULL;
			while (pCur != NULL)
			{
				//第一步：找树最左边的节点
				while ( pCur-&gt;pLeft != Prev &amp;&amp; pCur-&gt;Ltag == Link) //左子树
				{
					pCur = pCur-&gt;pLeft;
				}
				//循环结束后 pCur== Root 或者为空

				//第二步：访问后继
				while (pCur &amp;&amp; pCur-&gt;Rtag== Thread)
				{
					cout &lt;&lt; pCur-&gt;_data &lt;&lt; ' ';
					Prev = pCur;
					pCur = pCur-&gt;pRight;
				}
				//判断此时pCur是不是指向了根节点
				if (pCur == Root)
				{
					cout &lt;&lt; pCur-&gt;_data &lt;&lt; ' ';
					return;
				}
				while (pCur &amp;&amp; pCur-&gt;pRight == Prev)
				{
					cout &lt;&lt; pCur-&gt;_data &lt;&lt; ' ';
					Prev = pCur;
					pCur = pCur-&gt;pParent;  //往上一级走
				}
				//这里不能用NULL判断，而是用Rtag
				if (pCur &amp;&amp; pCur-&gt;Rtag == Link)
				{
					pCur = pCur-&gt;pRight;
				}
			}
	        //end-while
		}
	}
private:
	TriTreeNode* _pRoot;
	TriTreeNode* Prev;
};

void Test()
{
	char* arr = "013##4##25##6##";
	PostThread_BiTree tree(arr, strlen(arr)); //构建三叉树
	tree.PostTreading();
	tree.PostOrder();//arr 3 4 1  5 6 2  0
	cout &lt;&lt; endl &lt;&lt; "______________________" &lt;&lt; endl;

	char* arr1 = "013##4##2#56###";
	char* arr2 = "12#3##4##";
	PostThread_BiTree tree1(arr2, strlen(arr2));
	tree1.PostTreading();
	tree1.PostOrder();
	cout &lt;&lt; endl &lt;&lt; "______________________" &lt;&lt; endl;

	char* arr3 = "12#3#4##5##";
	PostThread_BiTree tree2(arr3, strlen(arr3));
	tree2.PostTreading();
	tree2.PostOrder();
	cout &lt;&lt; endl &lt;&lt; "______________________" &lt;&lt; endl;

	char* arr4 = "126##3#4##5##";
	PostThread_BiTree tree3(arr4, strlen(arr4));
	tree3.PostTreading();
	tree3.PostOrder();
	cout &lt;&lt; endl &lt;&lt; "______________________" &lt;&lt; endl;

}
int main()
{
	Test();
	return 0; 
}</code></pre> 
<br> 
<br> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4c6c77ef6a8d91c59f5fa8cfdf57573c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">ubuntu 下配置并使用SQLite3</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/14cc95d00030b8f83dbea725b1461077/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">android--登录例子，保存用户名和密码到这个应用所在文件中，从文件中读取用户名和密码</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>