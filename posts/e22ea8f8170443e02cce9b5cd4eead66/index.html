<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>2024-01-19（SpringCloud&amp;ThreadLocal） - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="2024-01-19（SpringCloud&amp;ThreadLocal）" />
<meta property="og:description" content="1.Seata的TC服务注册到Nacos注册中心当中 2.Seata为我们提供了AT，TCC，SAGA，XA事务解决方案。 3.XA规范是一种分布式事务处理标准，XA规范描述了全局的TM与局部的RM之间的接口，几乎所有的主流的数据库都对XA规范提供了支持。Seata的XA模式如下： 上述Seata的XA规范保证分布式事务的执行流程（分为两阶段）：
一阶段工作：
① RM注册分支事务到TC
② RM执行分支业务sql但不提交
③ RM报告执行状态到TC
二阶段工作：
① TC检测各分支事务执行状态
a. 如果都成功，通知所有RM提交事务
b. 如果有失败的分支事务，通知所有RM回滚事务
② RM接受TC指令，提交or回滚事务。
XA规范存在的问题：
1）执行速度慢，因为要等待所有分支事务执行完成，这个过程效率比较低。
2）另外，XA规范基于openFeign来进行网络接口调用，并且是串行调用，所以第一个执行的分支事务会等待后续的分支事务执行完毕很长时间。
3）依赖关系数据库，注入redis类型数据库不支持。
4.Springboot中Seater的XA模式采用starter做了很好的依赖封装，因此使用的时候只需要引入starter依赖，并在application.yml文件中写好配置（微服务的话在nacos的配置中心中配置），然后在给发起全局事务的入口方法添加@GlobalTransactional注解就可以使用了。 5.AT模式： Seata主推的是AT模式，AT模式同样是分阶段提交的事务类型，不过弥补了XA模式中资源锁定周期过长的缺陷。
6.Seata中AT模式的执行流程： 一阶段RM的工作：
1）注册分支事务
2）记录undo-log（数据快照）
3）执行业务sql并提交
4）报告事务状态
二阶段提交（执行成功不需要回滚）时RM的工作：
1）删除undo-log即可。
二阶段回滚（执行不成功需要回滚）时RM的工作：
1）根据undo-log恢复数据到更新前即可。
流程：
7.分布式事务是存在于面试当中的技术，解决分布式事务最好的方案就是最好不要出现分布式事务。 ---------------------------------------------------------------------------------------------------------------------------------
8.ThreadLocal： set()：将变量绑定到当前线程当中
get()：获取当前线程绑定的变量
9.ThreadLocal和sychronized关键字的区别： synchronized采用时间换取空间的方式，只提供了一份变量，让不同的线程排队访问，它侧重于多个线程之间访问资源的同步；ThreadLocal采用空间换取时间的方式，为每一个线程都提供了一份变量的副本，从而实现同时访问而不互相干扰，它侧重于多线程中让每个线程之间的数据相互隔离。
10.ThreadLocal方案的好处： 在一些特定场景下具有以下两方面的优势：1.传递数据：保存每个线程所绑定的数据，在需要的地方可以直接获取，避免参数直接传递所带来的代码耦合问题；2.线程隔离：各线程之间的数据相互隔离却又具备并发性，避免同步方式带来的性能损失。
11.ThreadLocal的设计： JDK8的设计方案的两个好处：
1）每个Map存储的Entry数量减少
2）当Thread销毁的时候,，ThreadLocalMap也会随之销毁，减少内存的使用
12.11是ThreadLocal的内部结构，下面是ThreadLocal的核心方法，除了构造方法之外，ThreadLocal对外暴露的方法有以下四个：
protected T initialValue(); //返回当前线程局部变量的初始值 public void set(T value); //设置当前线程绑定的局部变量 public T get(); //获取当前线程绑定的局部变量 public void remove(); //移除当前线程绑定的局部变量 set()方法源码步骤：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/e22ea8f8170443e02cce9b5cd4eead66/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-22T14:14:49+08:00" />
<meta property="article:modified_time" content="2024-01-22T14:14:49+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">2024-01-19（SpringCloud&amp;ThreadLocal）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h4>1.Seata的TC服务注册到Nacos注册中心当中</h4> 
<h4>2.Seata为我们提供了AT，TCC，SAGA，XA事务解决方案。</h4> 
<h4>3.XA规范是一种分布式事务处理标准，XA规范描述了全局的TM与局部的RM之间的接口，几乎所有的主流的数据库都对XA规范提供了支持。Seata的XA模式如下：</h4> 
<p><img alt="" height="480" src="https://images2.imgbox.com/1d/ed/Ud74MEMz_o.png" width="955"></p> 
<p>上述Seata的XA规范保证分布式事务的执行流程（分为两阶段）：</p> 
<p>一阶段工作：</p> 
<p>① RM注册分支事务到TC</p> 
<p>② RM执行分支业务sql但不提交</p> 
<p>③ RM报告执行状态到TC</p> 
<p>二阶段工作：</p> 
<p>① TC检测各分支事务执行状态</p> 
<p>a. 如果都成功，通知所有RM提交事务</p> 
<p>b. 如果有失败的分支事务，通知所有RM回滚事务</p> 
<p>② RM接受TC指令，提交or回滚事务。</p> 
<p>XA规范存在的问题：</p> 
<p>1）执行速度慢，因为要等待所有分支事务执行完成，这个过程效率比较低。</p> 
<p>2）另外，XA规范基于openFeign来进行网络接口调用，并且是串行调用，所以第一个执行的分支事务会等待后续的分支事务执行完毕很长时间。</p> 
<p>3）依赖关系数据库，注入redis类型数据库不支持。</p> 
<h4>4.Springboot中Seater的XA模式采用starter做了很好的依赖封装，因此使用的时候只需要引入starter依赖，并在application.yml文件中写好配置（微服务的话在nacos的配置中心中配置），然后在给发起全局事务的入口方法添加<span style="color:#fe2c24;"><strong>@GlobalTransactional</strong></span>注解就可以使用了。</h4> 
<h4>5.AT模式：</h4> 
<p><span style="color:#fe2c24;"><strong>Seata主推的是AT模式</strong></span>，AT模式同样是分阶段提交的事务类型，不过弥补了XA模式中资源锁定周期过长的缺陷。</p> 
<h4>6.Seata中AT模式的执行流程：</h4> 
<p><img alt="" height="505" src="https://images2.imgbox.com/93/41/7rI56Gyx_o.png" width="940"></p> 
<p>一阶段RM的工作：</p> 
<p>1）注册分支事务</p> 
<p>2）记录undo-log（数据快照）</p> 
<p>3）执行业务sql并提交</p> 
<p>4）报告事务状态</p> 
<p>二阶段提交（执行成功不需要回滚）时RM的工作：</p> 
<p>1）删除undo-log即可。</p> 
<p>二阶段回滚（执行不成功需要回滚）时RM的工作：</p> 
<p>1）根据undo-log恢复数据到更新前即可。</p> 
<p>流程：</p> 
<p><img alt="" height="543" src="https://images2.imgbox.com/87/5f/q1wxJsjL_o.png" width="871"></p> 
<h4>7.分布式事务是存在于面试当中的技术，解决分布式事务最好的方案就是最好不要出现分布式事务。</h4> 
<p></p> 
<p>---------------------------------------------------------------------------------------------------------------------------------</p> 
<p></p> 
<h4>8.ThreadLocal：</h4> 
<p>        set()：将变量绑定到当前线程当中</p> 
<p>        get()：获取当前线程绑定的变量</p> 
<h4>9.ThreadLocal和sychronized关键字的区别：</h4> 
<p>synchronized采用时间换取空间的方式，只提供了一份变量，让不同的线程排队访问，它侧重于多个线程之间访问资源的同步；ThreadLocal采用空间换取时间的方式，为每一个线程都提供了一份变量的副本，从而实现同时访问而不互相干扰，它侧重于多线程中让每个线程之间的数据相互隔离。</p> 
<h4>10.ThreadLocal方案的好处：</h4> 
<p>在一些特定场景下具有以下两方面的优势：1.传递数据：保存每个线程所绑定的数据，在需要的地方可以直接获取，避免参数直接传递所带来的代码耦合问题；2.线程隔离：各线程之间的数据相互隔离却又具备并发性，避免同步方式带来的性能损失。</p> 
<h4>11.ThreadLocal的设计：</h4> 
<p><img alt="" height="672" src="https://images2.imgbox.com/db/02/bJsQZq0C_o.png" width="856"></p> 
<p>JDK8的设计方案的两个好处：</p> 
<p>1）每个Map存储的Entry数量减少</p> 
<p>2）当Thread销毁的时候,，ThreadLocalMap也会随之销毁，减少内存的使用</p> 
<p>12.11是ThreadLocal的内部结构，下面是ThreadLocal的核心方法，除了构造方法之外，ThreadLocal对外暴露的方法有以下四个：</p> 
<pre><code class="language-java">protected T initialValue(); //返回当前线程局部变量的初始值
public void set(T value); //设置当前线程绑定的局部变量
public T get(); //获取当前线程绑定的局部变量
public void remove(); //移除当前线程绑定的局部变量</code></pre> 
<p>set()方法源码步骤：</p> 
<p>1）首先获取当前线程，并根据当前线程获取一个Map</p> 
<p>2）如果获取的Map不为空，则将参数设置到Map当中（当前ThreadLocal的引用作为key）</p> 
<p>3）如果Map为空，则给该线程创建Map，并设置初始值。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/486363ad64123ae0bac348843eff356b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">基于 IDEA 进行 Maven 工程构建</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/54c76360924b9749ca039f1e8484acc9/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">键盘的基础知识</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>