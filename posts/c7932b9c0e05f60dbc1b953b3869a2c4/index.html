<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Unity中URP下实现能量罩（性能优化 和 BRP适配） - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Unity中URP下实现能量罩（性能优化 和 BRP适配）" />
<meta property="og:description" content="文章目录 前言一、性能优化1、尽可能减少纹理采样次数2、 尽量把 max函数 换成 saturate函数，可以减少一次GPU指令3、尽可能的把计算移到顶点着色器4、变体优化5、变量放入 常量缓冲区 二、BuideIn Render Pipeline适配1、C#脚本开启摄像机深度图2、CG语言适配 三、最终效果和代码 前言 在之前的文章中，我们实现了URP下的能量罩效果。
Unity中URP下实现能量罩（扭曲流光花纹） 我们在这篇文章中，对其进行性能优化 和 BRP下的适配。
一、性能优化 1、尽可能减少纹理采样次数 我们这里把 能量罩花纹纹理 和 抓屏扭曲纹理 合并成同一个来使用，在效果上没多大变化。但是，可以少使用一次纹理采样。 2、 尽量把 max函数 换成 saturate函数，可以减少一次GPU指令 3、尽可能的把计算移到顶点着色器 在片元着色器中计算，需要对片元中的每一个像素进行计算，消耗性能较大 4、变体优化 5、变量放入 常量缓冲区 二、BuideIn Render Pipeline适配 1、C#脚本开启摄像机深度图 Camera.main.depthTextureMode = DepthTextureMode.Depth;
2、CG语言适配 抓屏纹理 GrabPass{“_GrabPass”}
引入库修改 #include “UnityCG.cginc”
纹理申明 sampler2D _MainTex;
float4 _MainTex_ST;
sampler2D _CameraDepthTexture;
sampler2D _GrabPass;
顶点着色器中，顶点坐标系变换需要修改为BRP的方法 v2f vert(appdata v)
{
v2f o = (v2f)0;
o.positionWS = mul(unity_ObjectToWorld,v.positionOS);
o.positionVS = UnityObjectToViewPos(v." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/c7932b9c0e05f60dbc1b953b3869a2c4/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-12T15:24:53+08:00" />
<meta property="article:modified_time" content="2024-01-12T15:24:53+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Unity中URP下实现能量罩（性能优化 和 BRP适配）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#_5" rel="nofollow">前言</a></li><li><a href="#_12" rel="nofollow">一、性能优化</a></li><li><ul><li><a href="#1_13" rel="nofollow">1、尽可能减少纹理采样次数</a></li><li><a href="#2__max__saturateGPU_16" rel="nofollow">2、 尽量把 max函数 换成 saturate函数，可以减少一次GPU指令</a></li><li><a href="#3_18" rel="nofollow">3、尽可能的把计算移到顶点着色器</a></li><li><a href="#4_21" rel="nofollow">4、变体优化</a></li><li><a href="#5__23" rel="nofollow">5、变量放入 常量缓冲区</a></li></ul> 
  </li><li><a href="#BuideIn_Render_Pipeline_26" rel="nofollow">二、BuideIn Render Pipeline适配</a></li><li><ul><li><a href="#1C_27" rel="nofollow">1、C#脚本开启摄像机深度图</a></li><li><a href="#2CG_30" rel="nofollow">2、CG语言适配</a></li></ul> 
  </li><li><a href="#_59" rel="nofollow">三、最终效果和代码</a></li></ul> 
</div> 
<p></p> 
<hr> 
<h2><a id="_5"></a>前言</h2> 
<p>在之前的文章中，我们实现了URP下的能量罩效果。</p> 
<ul><li><a href="https://blog.csdn.net/qq_51603875/article/details/135531568">Unity中URP下实现能量罩（扭曲流光花纹）</a></li></ul> 
<p>我们在这篇文章中，对其进行性能优化 和 BRP下的适配。</p> 
<hr> 
<h2><a id="_12"></a>一、性能优化</h2> 
<h3><a id="1_13"></a>1、尽可能减少纹理采样次数</h3> 
<ul><li>我们这里把 能量罩花纹纹理 和 抓屏扭曲纹理 合并成同一个来使用，在效果上没多大变化。但是，可以少使用一次纹理采样。</li></ul> 
<h3><a id="2__max__saturateGPU_16"></a>2、 尽量把 max函数 换成 saturate函数，可以减少一次GPU指令</h3> 
<h3><a id="3_18"></a>3、尽可能的把计算移到顶点着色器</h3> 
<ul><li>在片元着色器中计算，需要对片元中的每一个像素进行计算，消耗性能较大</li></ul> 
<h3><a id="4_21"></a>4、变体优化</h3> 
<h3><a id="5__23"></a>5、变量放入 常量缓冲区</h3> 
<hr> 
<h2><a id="BuideIn_Render_Pipeline_26"></a>二、BuideIn Render Pipeline适配</h2> 
<h3><a id="1C_27"></a>1、C#脚本开启摄像机深度图</h3> 
<blockquote> 
 <p>Camera.main.depthTextureMode = DepthTextureMode.Depth;</p> 
</blockquote> 
<h3><a id="2CG_30"></a>2、CG语言适配</h3> 
<ul><li>抓屏纹理</li></ul> 
<blockquote> 
 <p>GrabPass{“_GrabPass”}</p> 
</blockquote> 
<ul><li>引入库修改</li></ul> 
<blockquote> 
 <p>#include “UnityCG.cginc”</p> 
</blockquote> 
<ul><li>纹理申明</li></ul> 
<blockquote> 
 <p>sampler2D _MainTex;<br> float4 _MainTex_ST;<br> sampler2D _CameraDepthTexture;<br> sampler2D _GrabPass;</p> 
</blockquote> 
<ul><li>顶点着色器中，顶点坐标系变换需要修改为BRP的方法</li></ul> 
<blockquote> 
 <p>v2f vert(appdata v)<br> {<!-- --><br> v2f o = (v2f)0;<br> o.positionWS = mul(unity_ObjectToWorld,v.positionOS);<br> o.positionVS = UnityObjectToViewPos(v.positionOS);<br> o.positionCS = UnityObjectToClipPos(v.positionOS);<br> o.normalWS = UnityObjectToWorldNormal(v.normalOS);<br> o.uv.xy = v.uv;<br> o.uv.zw = TRANSFORM_TEX(v.uv,_MainTex);<br> return o;<br> }</p> 
</blockquote> 
<ul><li>纹理采样使用 tex2D</li></ul> 
<hr> 
<h2><a id="_59"></a>三、最终效果和代码</h2> 
<p><img src="https://images2.imgbox.com/2b/97/SVP5gwZQ_o.gif" alt="请添加图片描述"></p> 
<pre><code>//流光扭曲花纹
Shader "MyShader/URP/P4_3_7"
{
    Properties
    {
        [Header(MainTex)]
        _MainTex("MainTex",2D) = "white"{}
        [Header(HighLight)]
        _HighLightColor("HighLightColor",Color) = (0,0,0,0)
        _HighLightFade("HighLightFade",Float) = 1.0
        [Header(Fresnel)]
        [PowerSlider(3)]_FresnelIntensity("FresnelIntensity",Range(0,15)) = 1.0
        _FresnelColor("FresnelColor",Color) = (0,0,0,0)
        [Header(Distort)]
        _Tilling("Distort Tilling",Float)=0
        _Distort("Distort",Range(0,1)) = 0.3
    }
    SubShader
    {
        Tags
        {
            //告诉引擎，该Shader只用于 URP 渲染管线
            "RenderPipeline"="UniversalPipeline"
            //渲染类型
            "RenderType"="Transparent"
            //渲染队列
            "Queue"="Transparent"
        }

        Pass
        {
            Blend One One
            ZWrite Off
            Name "Unlit"

            HLSLPROGRAM
            #pragma vertex vert
            #pragma fragment frag
            // Pragmas
            #pragma target 2.0

            // Includes
            #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Color.hlsl"
            #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl"
            #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Input.hlsl"

            CBUFFER_START(UnityPerMaterial)
                half4 _HighLightColor;
                half _HighLightFade;
                half _FresnelIntensity;
                half4 _FresnelColor;
                half _Tilling;
                half _Distort;
                float4 _MainTex_ST;
            CBUFFER_END

            TEXTURE2D(_MainTex);
            SAMPLER(sampler_MainTex);
            TEXTURE2D(_CameraDepthTexture);
            SAMPLER(sampler_CameraDepthTexture);
            TEXTURE2D(_CameraOpaqueTexture);
            SAMPLER(sampler_CameraOpaqueTexture);
            //struct appdata
            //顶点着色器的输入
            struct Attributes
            {
                float3 positionOS : POSITION;
                float2 uv : TEXCOORD0;
                half3 normalOS : NORMAL;
            };

            //struct v2f
            //片元着色器的输入
            struct Varyings
            {
                float4 positionCS : SV_POSITION;
                float4 uv : TEXCOORD0;
                float4 screenPos : TEXCOORD1;
                float3 positionWS : TEXCOORD2;
                float3 positionVS : TEXCOORD3;
                half3 normalWS : TEXCOORD4;
            };

            //v2f vert(Attributes v)
            //顶点着色器
            Varyings vert(Attributes v)
            {
                Varyings o = (Varyings)0;
                o.positionWS = TransformObjectToWorld(v.positionOS);
                o.positionVS = TransformWorldToView(o.positionWS);
                o.positionCS = TransformWViewToHClip(o.positionVS);
                o.screenPos = ComputeScreenPos(o.positionCS);
                o.normalWS = TransformObjectToWorldNormal(v.normalOS);
                o.uv.xy = v.uv;
                o.uv.zw = TRANSFORM_TEX(v.uv, _MainTex);
                return o;
            }

            //fixed4 frag(v2f i) : SV_TARGET
            //片元着色器
            half4 frag(Varyings i) : SV_TARGET
            {
                half4 col = 0;
                //深度图
                //float2 uv = i.screenPos.xy / i.screenPos.w;
                float2 uv = i.positionCS.xy / _ScreenParams.xy;
                half4 cameraDepthTex = SAMPLE_TEXTURE2D(_CameraDepthTexture, sampler_CameraDepthTexture, uv);
                half depthTex = LinearEyeDepth(cameraDepthTex.r, _ZBufferParams);
                half4 highLight = depthTex + i.positionVS.z;
                highLight = pow(saturate(highLight), _HighLightFade);
                highLight = 1 - highLight;
                highLight *= _HighLightColor;
                col += saturate(highLight);

                //fresnel外发光
                //pow(max(0,dot(N,V)),Intensity)
                half3 N = i.normalWS;
                half3 V = normalize(_WorldSpaceCameraPos - i.positionWS);
                half NdotV = dot(N, V);
                half4 fresnel = pow(abs(1 - saturate(NdotV)), _FresnelIntensity);
                fresnel *= _FresnelColor;
                col += fresnel;
                //能量罩花纹
                float4 mainTex = SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, i.uv.zw + float2(0,_Time.x));
                col += mainTex * 0.1;

                //流光
                half flowMask = frac(i.uv.y * _Tilling + _Time.y);
                col *= flowMask;

                //抓屏流光扭曲
                float2 distortUV = lerp(uv, mainTex.rr, _Distort);
                half4 opaqueTex = SAMPLE_TEXTURE2D(_CameraOpaqueTexture, sampler_CameraOpaqueTexture, distortUV);

                half4 distort = opaqueTex;

                col *= distort;
                return col;
            }
            ENDHLSL
        }
    }

    SubShader
    {
        Tags
        {
            //渲染类型
            "RenderType"="Transparent"
            //渲染队列
            "Queue"="Transparent"
        }

        GrabPass
        {
            "_GrabPass"
        }

        Pass
        {
            Blend One One
            ZWrite Off


            CGPROGRAM
            #pragma vertex vert
            #pragma fragment frag
            // Pragmas
            #pragma target 2.0

            // Includes
            #include "UnityCG.cginc"

            half4 _HighLightColor;
            half _HighLightFade;
            half _FresnelIntensity;
            half4 _FresnelColor;
            half _Tilling;
            half _Distort;

            sampler2D _MainTex;
            float4 _MainTex_ST;
            sampler2D _CameraDepthTexture;
            sampler2D _GrabPass;


            struct appdata
            {
                float3 positionOS : POSITION;
                float2 uv : TEXCOORD0;
                half3 normalOS : NORMAL;
            };

            //struct v2f
            //片元着色器的输入
            struct v2f
            {
                float4 positionCS : SV_POSITION;
                float4 uv : TEXCOORD0;
                float3 positionWS : TEXCOORD2;
                float3 positionVS : TEXCOORD3;
                half3 normalWS : TEXCOORD4;
            };

            //v2f vert(appdata v)
            //顶点着色器
            v2f vert(appdata v)
            {
                v2f o = (v2f)0;
                o.positionWS = mul(unity_ObjectToWorld, v.positionOS);
                o.positionVS = UnityObjectToViewPos(v.positionOS);
                o.positionCS = UnityObjectToClipPos(v.positionOS);
                o.normalWS = UnityObjectToWorldNormal(v.normalOS);
                o.uv.xy = v.uv;
                o.uv.zw = TRANSFORM_TEX(v.uv, _MainTex);
                return o;
            }

            //fixed4 frag(v2f i) : SV_TARGET
            //片元着色器
            half4 frag(v2f i) : SV_TARGET
            {
                half4 col = 0;
                //深度图
                //float2 uv = i.screenPos.xy / i.screenPos.w;
                float2 uv = i.positionCS.xy / _ScreenParams.xy;
                half4 cameraDepthTex = tex2D(_CameraDepthTexture, uv);
                half depthTex = LinearEyeDepth(cameraDepthTex);
                half4 highLight = depthTex + i.positionVS.z;
                highLight = pow(saturate(highLight), _HighLightFade);
                highLight = 1 - highLight;
                highLight *= _HighLightColor;
                col += saturate(highLight);

                //fresnel外发光
                //pow(max(0,dot(N,V)),Intensity)
                half3 N = i.normalWS;
                half3 V = normalize(_WorldSpaceCameraPos - i.positionWS);
                half NdotV = dot(N, V);
                half4 fresnel = pow(abs(1 - saturate(NdotV)), _FresnelIntensity);
                fresnel *= _FresnelColor;
                col += fresnel;
                //能量罩花纹
                float4 mainTex = tex2D(_MainTex, i.uv.zw + float2(0, _Time.x));
                col += mainTex * 0.1;

                //流光
                half flowMask = frac(i.uv.y * _Tilling + _Time.y);
                col *= flowMask;

                //抓屏流光扭曲
                float2 distortUV = lerp(uv, mainTex.rr, _Distort);
                half4 opaqueTex = tex2D(_GrabPass, distortUV);

                half4 distort = opaqueTex;

                col *= distort;
                return col;
            }
            ENDCG
        }
    }
}
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b11b2f0fe41d7880701125d46e57ee4c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">算法回忆录——DFS与BFS</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0bcd08a0f893d7f71c54b5264df639f9/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Spring Boot 整合 Camunda 实现工作流</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>