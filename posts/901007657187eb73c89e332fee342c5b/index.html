<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>九、Bean的循环依赖问题 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="九、Bean的循环依赖问题" />
<meta property="og:description" content="9.1 什么是Bean的循环依赖 A对象中有B属性。B对象中有A属性。这就是循环依赖。我依赖你，你也依赖我。
比如：丈夫类Husband，妻子类Wife。Husband中有Wife的引用。Wife中有Husband的引用。
package com.powernode.spring6.bean; /** * @author 动力节点 * @version 1.0 * @className Husband * @since 1.0 **/ public class Husband { private String name; private Wife wife; } package com.powernode.spring6.bean; /** * @author 动力节点 * @version 1.0 * @className Wife * @since 1.0 **/ public class Wife { private String name; private Husband husband; } 9.2 singleton下的set注入产生的循环依赖 我们来编写程序，测试一下在singleton&#43;setter的模式下产生的循环依赖，Spring是否能够解决？
package com.powernode.spring6.bean; /** * @author 动力节点 * @version 1." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/901007657187eb73c89e332fee342c5b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-11-12T17:14:51+08:00" />
<meta property="article:modified_time" content="2022-11-12T17:14:51+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">九、Bean的循环依赖问题</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3 id="YBXMW">9.1 什么是Bean的循环依赖</h3> 
<p id="u4095958c">A对象中有B属性。B对象中有A属性。这就是循环依赖。我依赖你，你也依赖我。</p> 
<p id="u947a4f39">比如：丈夫类Husband，妻子类Wife。Husband中有Wife的引用。Wife中有Husband的引用。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/5d/88/sI1Q1H5m_o.png"></p> 
<pre id="JZtcB">package com.powernode.spring6.bean;

/**
 * @author 动力节点
 * @version 1.0
 * @className Husband
 * @since 1.0
 **/
public class Husband {
    private String name;
    private Wife wife;
}
</pre> 
<pre id="zYb91">package com.powernode.spring6.bean;

/**
 * @author 动力节点
 * @version 1.0
 * @className Wife
 * @since 1.0
 **/
public class Wife {
    private String name;
    private Husband husband;
}
</pre> 
<h3 id="pO5Qp">9.2 singleton下的set注入产生的循环依赖</h3> 
<p id="uaf73f203">我们来编写程序，测试一下在singleton+setter的模式下产生的循环依赖，Spring是否能够解决？</p> 
<pre id="AEV8s">package com.powernode.spring6.bean;

/**
 * @author 动力节点
 * @version 1.0
 * @className Husband
 * @since 1.0
 **/
public class Husband {
    private String name;
    private Wife wife;

    public void setName(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }

    public void setWife(Wife wife) {
        this.wife = wife;
    }

    // toString()方法重写时需要注意：不能直接输出wife，输出wife.getName()。要不然会出现递归导致的栈内存溢出错误。
    @Override
    public String toString() {
        return "Husband{" +
                "name='" + name + '\'' +
                ", wife=" + wife.getName() +
                '}';
    }
}
</pre> 
<pre id="MEq76">package com.powernode.spring6.bean;

/**
 * @author 动力节点
 * @version 1.0
 * @className Wife
 * @since 1.0
 **/
public class Wife {
    private String name;
    private Husband husband;

    public void setName(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }

    public void setHusband(Husband husband) {
        this.husband = husband;
    }

    // toString()方法重写时需要注意：不能直接输出husband，输出husband.getName()。要不然会出现递归导致的栈内存溢出错误。
    @Override
    public String toString() {
        return "Wife{" +
                "name='" + name + '\'' +
                ", husband=" + husband.getName() +
                '}';
    }
}
</pre> 
<pre id="xd4Wm">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt;

    &lt;bean id="husbandBean" class="com.powernode.spring6.bean.Husband" scope="singleton"&gt;
        &lt;property name="name" value="张三"/&gt;
        &lt;property name="wife" ref="wifeBean"/&gt;
    &lt;/bean&gt;
    &lt;bean id="wifeBean" class="com.powernode.spring6.bean.Wife" scope="singleton"&gt;
        &lt;property name="name" value="小花"/&gt;
        &lt;property name="husband" ref="husbandBean"/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;</pre> 
<pre id="yRY1U">package com.powernode.spring6.test;

import com.powernode.spring6.bean.Husband;
import com.powernode.spring6.bean.Wife;
import org.junit.Test;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

/**
 * @author 动力节点
 * @version 1.0
 * @className CircularDependencyTest
 * @since 1.0
 **/
public class CircularDependencyTest {

    @Test
    public void testSingletonAndSet(){
        ApplicationContext applicationContext = new ClassPathXmlApplicationContext("spring.xml");
        Husband husbandBean = applicationContext.getBean("husbandBean", Husband.class);
        Wife wifeBean = applicationContext.getBean("wifeBean", Wife.class);
        System.out.println(husbandBean);
        System.out.println(wifeBean);
    }
}
</pre> 
<p id="u3c415202">执行结果：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/f3/2b/ZT0VLAIv_o.png"></p> 
<p id="u39de9b4d"><strong>通过测试得知：在singleton + set注入的情况下，循环依赖是没有问题的。Spring可以解决这个问题。</strong></p> 
<h3 id="E21WS">9.3 prototype下的set注入产生的循环依赖</h3> 
<p id="u851e7c4e">我们再来测试一下：prototype+set注入的方式下，循环依赖会不会出现问题？</p> 
<pre id="UwWRD">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt;

    &lt;bean id="husbandBean" class="com.powernode.spring6.bean.Husband" scope="prototype"&gt;
        &lt;property name="name" value="张三"/&gt;
        &lt;property name="wife" ref="wifeBean"/&gt;
    &lt;/bean&gt;
    &lt;bean id="wifeBean" class="com.powernode.spring6.bean.Wife" scope="prototype"&gt;
        &lt;property name="name" value="小花"/&gt;
        &lt;property name="husband" ref="husbandBean"/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;</pre> 
<p id="ue31e1ac3">执行测试程序：发生了异常，异常信息如下：</p> 
<p id="uea40ac7e">Caused by: org.springframework.beans.factory.<strong>BeanCurrentlyInCreationException</strong>: Error creating bean with name 'husbandBean': Requested bean is currently in creation: Is there an unresolvable circular reference?</p> 
<p id="u14d1bcd4">at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:265)</p> 
<p id="u26e99799">at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:199)</p> 
<p id="ubee90a99">at org.springframework.beans.factory.support.BeanDefinitionValueResolver.resolveReference(BeanDefinitionValueResolver.java:325)</p> 
<p id="uf0fa81c9">... 44 more</p> 
<p id="u72718292">翻译为：创建名为“husbandBean”的bean时出错：请求的bean当前正在创建中：是否存在无法解析的循环引用？</p> 
<p id="ub0029fc3">通过测试得知，当循环依赖的<strong>所有Bean</strong>的scope="prototype"的时候，产生的循环依赖，Spring是无法解决的，会出现<strong>BeanCurrentlyInCreationException</strong>异常。</p> 
<p id="u2f3a0dfe">大家可以测试一下，以上两个Bean，如果其中一个是singleton，另一个是prototype，是没有问题的。</p> 
<p id="uee5310de">为什么两个Bean都是prototype时会出错呢？</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/d2/fa/ORvpEl45_o.png"></p> 
<h3 id="J6q3n">9.4 singleton下的构造注入产生的循环依赖</h3> 
<p id="uc446f291">我们再来测试一下singleton + 构造注入的方式下，spring是否能够解决这种循环依赖。</p> 
<pre id="hoKJv">package com.powernode.spring6.bean2;

/**
 * @author 动力节点
 * @version 1.0
 * @className Husband
 * @since 1.0
 **/
public class Husband {
    private String name;
    private Wife wife;

    public Husband(String name, Wife wife) {
        this.name = name;
        this.wife = wife;
    }

    // -----------------------分割线--------------------------------
    public String getName() {
        return name;
    }

    @Override
    public String toString() {
        return "Husband{" +
                "name='" + name + '\'' +
                ", wife=" + wife +
                '}';
    }
}
</pre> 
<pre id="unBOK">package com.powernode.spring6.bean2;

/**
 * @author 动力节点
 * @version 1.0
 * @className Wife
 * @since 1.0
 **/
public class Wife {
    private String name;
    private Husband husband;

    public Wife(String name, Husband husband) {
        this.name = name;
        this.husband = husband;
    }

    // -------------------------分割线--------------------------------
    public String getName() {
        return name;
    }

    @Override
    public String toString() {
        return "Wife{" +
                "name='" + name + '\'' +
                ", husband=" + husband +
                '}';
    }
}
</pre> 
<pre id="xfVxy">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt;

    &lt;bean id="hBean" class="com.powernode.spring6.bean2.Husband" scope="singleton"&gt;
        &lt;constructor-arg name="name" value="张三"/&gt;
        &lt;constructor-arg name="wife" ref="wBean"/&gt;
    &lt;/bean&gt;

    &lt;bean id="wBean" class="com.powernode.spring6.bean2.Wife" scope="singleton"&gt;
        &lt;constructor-arg name="name" value="小花"/&gt;
        &lt;constructor-arg name="husband" ref="hBean"/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;</pre> 
<pre id="orU2Z">@Test
public void testSingletonAndConstructor(){
    ApplicationContext applicationContext = new ClassPathXmlApplicationContext("spring2.xml");
    Husband hBean = applicationContext.getBean("hBean", Husband.class);
    Wife wBean = applicationContext.getBean("wBean", Wife.class);
    System.out.println(hBean);
    System.out.println(wBean);
}</pre> 
<p id="u3a1147ec">执行结果：发生了异常，信息如下：</p> 
<p id="u9607f996">Caused by: org.springframework.beans.factory.<strong>BeanCurrentlyInCreationException</strong>: Error creating bean with name 'hBean': Requested bean is currently in creation: Is there an unresolvable circular reference?</p> 
<p id="u06c3f4db">at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.beforeSingletonCreation(DefaultSingletonBeanRegistry.java:355)</p> 
<p id="u4c1681ed">at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:227)</p> 
<p id="u9981d24b">at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:324)</p> 
<p id="ufda0a268">at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:199)</p> 
<p id="u305ad7d4">at org.springframework.beans.factory.support.BeanDefinitionValueResolver.resolveReference(BeanDefinitionValueResolver.java:325)</p> 
<p id="u2eedf31d">... 56 more</p> 
<p id="uebd8ab4b">和上一个测试结果相同，都是提示产生了循环依赖，并且Spring是无法解决这种循环依赖的。</p> 
<p id="ue3067c81">为什么呢？</p> 
<p id="ua201f1e1"><strong>主要原因是因为通过构造方法注入导致的：因为构造方法注入会导致</strong><strong>实例化对象的过程</strong><strong>和</strong><strong>对象属性赋值的过程</strong><strong>没有分离开，必须在一起完成导致的。</strong></p> 
<h3 id="wt8oL">9.5 Spring解决循环依赖的机理</h3> 
<p id="ua1bb94e9">Spring为什么可以解决set + singleton模式下循环依赖？</p> 
<p id="u058b3abf">根本的原因在于：这种方式可以做到将“实例化Bean”和“给Bean属性赋值”这两个动作分开去完成。</p> 
<p id="u86388174">实例化Bean的时候：调用无参数构造方法来完成。<strong>此时可以先不给属性赋值，可以提前将该Bean对象“曝光”给外界。</strong></p> 
<p id="u272c716b">给Bean属性赋值的时候：调用setter方法来完成。</p> 
<p id="u567ec976">两个步骤是完全可以分离开去完成的，并且这两步不要求在同一个时间点上完成。</p> 
<p id="ue5595b9c">也就是说，Bean都是单例的，我们可以先把所有的单例Bean实例化出来，放到一个集合当中（我们可以称之为缓存），所有的单例Bean全部实例化完成之后，以后我们再慢慢的调用setter方法给属性赋值。这样就解决了循环依赖的问题。</p> 
<p id="u8124794d">那么在Spring框架底层源码级别上是如何实现的呢？请看：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/77/33/1dSzHkMN_o.png"></p> 
<p id="ue246e8f4">在以上类中包含三个重要的属性：</p> 
<p id="u1cca8d71"><strong><em>Cache of singleton objects: bean name to bean instance. </em></strong><strong>单例对象的缓存：key存储bean名称，value存储Bean对象【一级缓存】</strong></p> 
<p id="u07ed5e18"><strong><em>Cache of early singleton objects: bean name to bean instance. </em></strong><strong>早期单例对象的缓存：key存储bean名称，value存储早期的Bean对象【二级缓存】</strong></p> 
<p id="u20371c73"><strong><em>Cache of singleton factories: bean name to ObjectFactory. </em></strong><strong>单例工厂缓存：key存储bean名称，value存储该Bean对应的ObjectFactory对象【三级缓存】</strong></p> 
<p id="u34840618">这三个缓存其实本质上是三个Map集合。</p> 
<p id="u087af1a8">我们再来看，在该类中有这样一个方法addSingletonFactory()，这个方法的作用是：将创建Bean对象的ObjectFactory对象提前曝光。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/e4/89/uqMRvXm3_o.png"></p> 
<p id="u40447faf">再分析下面的源码：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/9e/f9/kF0OUWL3_o.png"></p> 
<p id="ue1e55bd8">从源码中可以看到，spring会先从一级缓存中获取Bean，如果获取不到，则从二级缓存中获取Bean，如果二级缓存还是获取不到，则从三级缓存中获取之前曝光的ObjectFactory对象，通过ObjectFactory对象获取Bean实例，这样就解决了循环依赖的问题。</p> 
<p id="u72e9148f"><strong>总结：</strong></p> 
<p id="u952bb28a"><strong>Spring只能解决setter方法注入的单例bean之间的循环依赖。ClassA依赖ClassB，ClassB又依赖ClassA，形成依赖闭环。Spring在创建ClassA对象后，不需要等给属性赋值，直接将其曝光到bean缓存当中。在解析ClassA的属性时，又发现依赖于ClassB，再次去获取ClassB，当解析ClassB的属性时，又发现需要ClassA的属性，但此时的ClassA已经被提前曝光加入了正在创建的bean的缓存中，则无需创建新的的ClassA的实例，直接从缓存中获取即可。从而解决循环依赖问题。</strong></p> 
<p id="ufe7ad64b"></p> 
<h2 id="Qh2bg"></h2> 
<h2></h2>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/90d23c790f720633c71d2cd889eb2ae4/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【C&#43;&#43;】红黑树的插入实现</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/15dd46577cbaab68aa9e14a4400f5c10/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Linux:时间日期指令(date)&#43;查找指令(find,locate,grep)&#43;压缩和解压指令(gzip,gunzip；zip,unzip；tar)(内含详细解释&#43;操作实例)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>