<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>AJAX进阶（重点） - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="AJAX进阶（重点）" />
<meta property="og:description" content="目录
◆ 同步代码和异步代码
◆ 回调函数地狱和 Promise 链式调用
什么是回调函数地狱？
Promise - 链式调用
什么是Promise链式调用？
Promise 链式应用 （重点）
◆ async 和 await 使用
async函数和await_捕获错误 ◆ 事件循环-EventLoop（重点）
为什么要学习事件循环？
什么是事件循环？ 事件循环 - 执行过程（重点）
事件循环 - 练习 宏任务与微任务 （重点）
事件循环 - 经典面试题 ◆ Promise.all 静态方法
◆ 同步代码和异步代码 什么是同步代码，什么是异步代码？
同步代码：
异步代码：
同步代码：逐行执行，需原地等待结果后，才继续向下执行 异步代码：调用后耗时，不阻塞代码继续执行（不必原地等待），在将来完成后触发一个回调函数
例子：回答打印数字的顺序是什么？ 打印结果：1,4,2 点击按钮一次就打印一次 3 异步代码接收结果：使用回调函数
◆ 回调函数地狱和 Promise 链式调用 什么是回调函数地狱？ 需求：展示默认第一个省，第一个城市，第一个地区在下拉菜单中
概念：在回调函数中嵌套回调函数，一直嵌套下去就形成了回调函数地狱
缺点：可读性差，异常无法捕获，耦合性严重，牵一发动全身
总结：简单讲。回调函数地狱就是在回调函数中嵌套回调函数，进而导致代码耦合度高，异常难以捕获
Promise - 链式调用 什么是Promise链式调用？ 概念：依靠 then() 方法会返回一个新生成的 Promise 对象特性，继续串联下一环任务，直到结束" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/59e268b59af6e90be4260bc28e3f5ddb/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-29T22:51:36+08:00" />
<meta property="article:modified_time" content="2024-01-29T22:51:36+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">AJAX进阶（重点）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E2%97%86%20%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81%E5%92%8C%E5%BC%82%E6%AD%A5%E4%BB%A3%E7%A0%81-toc" style="margin-left:40px;"><a href="#%E2%97%86%20%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81%E5%92%8C%E5%BC%82%E6%AD%A5%E4%BB%A3%E7%A0%81" rel="nofollow">◆ 同步代码和异步代码</a></p> 
<p id="%E2%97%86%20%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E5%9C%B0%E7%8B%B1%E5%92%8C%20Promise%20%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8-toc" style="margin-left:40px;"><a href="#%E2%97%86%20%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E5%9C%B0%E7%8B%B1%E5%92%8C%20Promise%20%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8" rel="nofollow">◆ 回调函数地狱和 Promise 链式调用</a></p> 
<p id="%E4%BB%80%E4%B9%88%E6%98%AF%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E5%9C%B0%E7%8B%B1%EF%BC%9F-toc" style="margin-left:80px;"><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E5%9C%B0%E7%8B%B1%EF%BC%9F" rel="nofollow">什么是回调函数地狱？</a></p> 
<p id="Promise%20-%20%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8-toc" style="margin-left:80px;"><a href="#Promise%20-%20%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8" rel="nofollow">Promise - 链式调用</a></p> 
<p id="%E4%BB%80%E4%B9%88%E6%98%AFPromise%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8%EF%BC%9F-toc" style="margin-left:120px;"><a href="#%E4%BB%80%E4%B9%88%E6%98%AFPromise%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8%EF%BC%9F" rel="nofollow">什么是Promise链式调用？</a></p> 
<p id="Promise%20%E9%93%BE%E5%BC%8F%E5%BA%94%E7%94%A8%C2%A0%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89-toc" style="margin-left:120px;"><a href="#Promise%20%E9%93%BE%E5%BC%8F%E5%BA%94%E7%94%A8%C2%A0%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89" rel="nofollow">Promise 链式应用 （重点）</a></p> 
<p id="%E2%97%86%20async%20%E5%92%8C%20await%20%E4%BD%BF%E7%94%A8-toc" style="margin-left:40px;"><a href="#%E2%97%86%20async%20%E5%92%8C%20await%20%E4%BD%BF%E7%94%A8" rel="nofollow">◆ async 和 await 使用</a></p> 
<p id="async%E5%87%BD%E6%95%B0%E5%92%8Cawait_%E6%8D%95%E8%8E%B7%E9%94%99%E8%AF%AF%C2%A0-toc" style="margin-left:80px;"><a href="#async%E5%87%BD%E6%95%B0%E5%92%8Cawait_%E6%8D%95%E8%8E%B7%E9%94%99%E8%AF%AF%C2%A0" rel="nofollow">async函数和await_捕获错误 </a></p> 
<p id="%E2%97%86%20%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF-EventLoop%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89-toc" style="margin-left:40px;"><a href="#%E2%97%86%20%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF-EventLoop%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89" rel="nofollow">◆ 事件循环-EventLoop（重点）</a></p> 
<p id="%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%AD%A6%E4%B9%A0%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%EF%BC%9F-toc" style="margin-left:80px;"><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%AD%A6%E4%B9%A0%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%EF%BC%9F" rel="nofollow">为什么要学习事件循环？</a></p> 
<p id="%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%EF%BC%9F%C2%A0-toc" style="margin-left:80px;"><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%EF%BC%9F%C2%A0" rel="nofollow">什么是事件循环？ </a></p> 
<p id="%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%20-%20%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89-toc" style="margin-left:80px;"><a href="#%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%20-%20%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89" rel="nofollow">事件循环 - 执行过程（重点）</a></p> 
<p id="%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%20-%20%E7%BB%83%E4%B9%A0%C2%A0-toc" style="margin-left:80px;"><a href="#%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%20-%20%E7%BB%83%E4%B9%A0%C2%A0" rel="nofollow">事件循环 - 练习 </a></p> 
<p id="%E5%AE%8F%E4%BB%BB%E5%8A%A1%E4%B8%8E%E5%BE%AE%E4%BB%BB%E5%8A%A1%C2%A0%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89-toc" style="margin-left:80px;"><a href="#%E5%AE%8F%E4%BB%BB%E5%8A%A1%E4%B8%8E%E5%BE%AE%E4%BB%BB%E5%8A%A1%C2%A0%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89" rel="nofollow">宏任务与微任务 （重点）</a></p> 
<p id="%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%20-%20%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98%C2%A0-toc" style="margin-left:80px;"><a href="#%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%20-%20%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98%C2%A0" rel="nofollow">事件循环 - 经典面试题 </a></p> 
<p id="%E2%97%86%20Promise.all%20%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95-toc" style="margin-left:40px;"><a href="#%E2%97%86%20Promise.all%20%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95" rel="nofollow">◆ Promise.all 静态方法</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h3 id="%E2%97%86%20%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81%E5%92%8C%E5%BC%82%E6%AD%A5%E4%BB%A3%E7%A0%81">◆ 同步代码和异步代码</h3> 
<p>什么是同步代码，什么是异步代码？</p> 
<p><strong>同步代码：</strong></p> 
<p><img alt="" height="218" src="https://images2.imgbox.com/03/32/NtM6dJQD_o.png" width="983"></p> 
<p>异步代码：</p> 
<p><img alt="" height="103" src="https://images2.imgbox.com/b1/4a/3vGuTp2e_o.png" width="1011"> </p> 
<p>同步代码：逐行执行，<span style="color:#fe2c24;"><strong>需原地等待结果</strong></span>后，才继续向下执行 </p> 
<p>异步代码：调用后耗时，不阻塞代码继续执行（不必原地等待），在将来完成后<span style="color:#fe2c24;"><strong>触发一个回调函数</strong></span></p> 
<p></p> 
<p>例子：回答打印数字的顺序是什么？ </p> 
<p><img alt="" height="349" src="https://images2.imgbox.com/a2/95/F6Gyfb7o_o.png" width="884"></p> 
<p>打印结果：1,4,2 点击按钮一次就打印一次 3 </p> 
<p><strong>异步代码接收结果：使用回调函数</strong></p> 
<h4></h4> 
<h3 id="%E2%97%86%20%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E5%9C%B0%E7%8B%B1%E5%92%8C%20Promise%20%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8" style="background-color:transparent;">◆ 回调函数地狱和 Promise 链式调用</h3> 
<h4 id="%E4%BB%80%E4%B9%88%E6%98%AF%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E5%9C%B0%E7%8B%B1%EF%BC%9F">什么是回调函数地狱？</h4> 
<p>需求：展示默认第一个省，第一个城市，第一个地区在下拉菜单中</p> 
<p>概念：在回调函数中<span style="color:#fe2c24;"><strong>嵌套</strong></span>回调函数，一直嵌套下去就形成了回调函数地狱</p> 
<p>缺点：可读性差，异常无法捕获，耦合性严重，牵一发动全身</p> 
<p><img alt="" height="244" src="https://images2.imgbox.com/21/d0/04ZrQQER_o.png" width="589"></p> 
<p><img alt="" height="406" src="https://images2.imgbox.com/2e/91/tkpCuFyv_o.png" width="1171"> </p> 
<p><span style="color:#fe2c24;"><strong>总结：简单讲。回调函数地狱就是在回调函数中嵌套回调函数，进而导致代码耦合度高，异常难以捕获</strong></span></p> 
<p></p> 
<h4 id="Promise%20-%20%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8">Promise - 链式调用</h4> 
<h5 id="%E4%BB%80%E4%B9%88%E6%98%AFPromise%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8%EF%BC%9F">什么是Promise链式调用？</h5> 
<p>概念：依靠<span style="color:#fe2c24;"><strong> then() 方法会返回一个新生成的 Promise 对象特性</strong></span>，继续串联下一环任务，直到结束</p> 
<p>细节：then() 回调函数中的<strong>返回值</strong>，会影响新生成的<strong> Promise 对象最终状态和结果</strong> </p> 
<p>好处：通过链式调用，解决回调函数嵌套问题</p> 
<p><img alt="" height="303" src="https://images2.imgbox.com/28/49/r4H5zqLW_o.png" width="1065"></p> 
<h5 id="Promise%20%E9%93%BE%E5%BC%8F%E5%BA%94%E7%94%A8%C2%A0%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89">Promise 链式应用 （重点）</h5> 
<p>目标：使用 Promise 链式调用，解决回调函数地狱问题</p> 
<p>做法：每个 Promise 对象中管理一个异步任务，用 then 返回 Promise 对象，串联起来</p> 
<p><img alt="" height="231" src="https://images2.imgbox.com/07/2c/bxcmlN6n_o.png" width="1200"></p> 
<p><img alt="" height="529" src="https://images2.imgbox.com/ac/74/T0rbw385_o.png" width="1089"> </p> 
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;

&lt;head&gt;
  &lt;meta charset="UTF-8"&gt;
  &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;
  &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
  &lt;title&gt;Promise链式调用_解决回调地狱&lt;/title&gt;
&lt;/head&gt;

&lt;body&gt;
  &lt;form&gt;
    &lt;span&gt;省份：&lt;/span&gt;
    &lt;select&gt;
      &lt;option class="province"&gt;&lt;/option&gt;
    &lt;/select&gt;
    &lt;span&gt;城市：&lt;/span&gt;
    &lt;select&gt;
      &lt;option class="city"&gt;&lt;/option&gt;
    &lt;/select&gt;
    &lt;span&gt;地区：&lt;/span&gt;
    &lt;select&gt;
      &lt;option class="area"&gt;&lt;/option&gt;
    &lt;/select&gt;
  &lt;/form&gt;
  &lt;script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"&gt;&lt;/script&gt;
  &lt;script&gt;
    /**
     * 目标：把回调函数嵌套代码，改成Promise链式调用结构
     * 需求：获取默认第一个省，第一个市，第一个地区并展示在下拉菜单中
    */
    let pname = ''
    // 1. 得到-获取省份Promise对象
    axios({url: 'http://hmajax.itheima.net/api/province'}).then(result =&gt; {
      pname = result.data.list[0]
      document.querySelector('.province').innerHTML = pname
      // 2. 得到-获取城市Promise对象
      return axios({url: 'http://hmajax.itheima.net/api/city', params: { pname }})
    }).then(result =&gt; {
      const cname = result.data.list[0]
      document.querySelector('.city').innerHTML = cname
      // 3. 得到-获取地区Promise对象
      return axios({url: 'http://hmajax.itheima.net/api/area', params: { pname, cname }})
    }).then(result =&gt; {
      console.log(result)
      const areaName = result.data.list[0]
      document.querySelector('.area').innerHTML = areaName
    })
  &lt;/script&gt;
&lt;/body&gt;

&lt;/html&gt;</code></pre> 
<p> </p> 
<p>总结： </p> 
<blockquote> 
 <p>1. 什么是 Promise 的链式调用？</p> 
 <ul><li>➢ 使用 then 方法返回新 Promise 对象特性，一直串联下去</li></ul> 
 <p>2. then 回调函数中，return 的值会传给哪里？</p> 
 <ul><li>➢ 传给 then 方法生成的新 Promise 对象</li></ul> 
 <p>3. Promise 链式调用有什么用？</p> 
 <ul><li>➢ 解决回调函数嵌套问题 </li></ul> 
</blockquote> 
<h3 id="%E2%97%86%20async%20%E5%92%8C%20await%20%E4%BD%BF%E7%94%A8" style="background-color:transparent;">◆ async 和 await 使用</h3> 
<p>定义：</p> 
<p><img alt="" height="160" src="https://images2.imgbox.com/6a/67/Mn1dsrZU_o.png" width="1200"></p> 
<p>概念： 在 async 函数内，<span style="color:#fe2c24;"><strong>使用 await 关键字取代 then 函数</strong></span>，等待获取 Promise 对象成功状态的结果值</p> 
<p>示例：</p> 
<h4 id="%E2%80%8B%E7%BC%96%E8%BE%91%C2%A0"><img alt="" height="360" src="https://images2.imgbox.com/c0/c1/nlzd04SM_o.png" width="990"> </h4> 
<p><span style="color:#fe2c24;"><strong> 简单来说，当函数使用了async关键字，可以使用await关键字讲函数内的异步函数转化成同步函数</strong></span></p> 
<h4 id="async%E5%87%BD%E6%95%B0%E5%92%8Cawait_%E6%8D%95%E8%8E%B7%E9%94%99%E8%AF%AF%C2%A0" style="background-color:transparent;">async函数和await_捕获错误 </h4> 
<p><img alt="" height="193" src="https://images2.imgbox.com/9d/e4/5NzUQUhP_o.png" width="841"></p> 
<p><img alt="" height="313" src="https://images2.imgbox.com/cd/8d/0OCbHt1t_o.png" width="865"> </p> 
<h3></h3> 
<h3 id="%E2%97%86%20%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF-EventLoop%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89" style="background-color:transparent;">◆ 事件循环-EventLoop（重点）</h3> 
<ul><li> <h4 id="%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%AD%A6%E4%B9%A0%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%EF%BC%9F">为什么要学习事件循环？</h4> </li></ul> 
<p><span style="color:#fe2c24;"><strong>掌握 JavaScript 是如何安排和运行代码的</strong></span></p> 
<p><img alt="" height="259" src="https://images2.imgbox.com/5e/3a/f96OLMBE_o.png" width="1200"></p> 
<h4 id="%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%EF%BC%9F%C2%A0">什么是事件循环？ </h4> 
<p>概念：</p> 
<p><img alt="" height="115" src="https://images2.imgbox.com/1c/0c/i9HYDTYa_o.png" width="1200"></p> 
<p>原因：JavaScript 单线程（某一刻只能执行一行代码），为了让耗时代码不阻塞其他代码运行，设计了<span style="color:#fe2c24;"><strong>事件循环模型 </strong></span></p> 
<p></p> 
<h4 id="%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%20-%20%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89">事件循环 - 执行过程（重点）</h4> 
<p>定义：执行代码和收集异步任务的模型，<span style="color:#fe2c24;"><strong>在调用栈空闲时，反复调用任务队列里回调函数的执行机制，就叫事件循环</strong></span></p> 
<p><img alt="" height="572" src="https://images2.imgbox.com/b8/2e/SJTeoTKf_o.png" width="1200"></p> 
<p>总结：</p> 
<blockquote> 
 <p>1. 什么是事件循环？</p> 
 <ul><li>➢ 执行代码和收集异步任务，在调用栈空闲时，反复调用任务队列里</li></ul> 
 <p>回调函数执行机制<br> 2. 为什么有事件循环？</p> 
 <ul><li>➢ JavaScript 是单线程的，为了不阻塞 JS 引擎，设计执行代码的模型</li></ul> 
 <p>3. JavaScript 内代码如何执行？</p> 
 <ul><li>➢ 执行同步代码，遇到<span style="color:#fe2c24;"><strong>异步代码交给宿主浏览器环境执行</strong></span></li><li>➢ <span style="color:#fe2c24;">异步有了结果后，把回调函数放入任务队列排队</span></li><li>➢ 当<span style="color:#fe2c24;"><strong>调用栈空闲后，反复调用任务队列里的回调函数</strong></span> </li></ul> 
</blockquote> 
<h4 id="%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%20-%20%E7%BB%83%E4%B9%A0%C2%A0">事件循环 - 练习 </h4> 
<p>使用模型，分析代码执行过程</p> 
<h4 id="%E2%80%8B%E7%BC%96%E8%BE%91"><img alt="" height="525" src="https://images2.imgbox.com/40/48/h98CtUxL_o.png" width="1200"></h4> 
<h4 id="%E5%AE%8F%E4%BB%BB%E5%8A%A1%E4%B8%8E%E5%BE%AE%E4%BB%BB%E5%8A%A1%C2%A0%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89">宏任务与微任务 （重点）</h4> 
<p>ES6 之后引入了 Promise 对象， 让 JS 引擎也可以发起异步任务</p> 
<p>异步任务分为：</p> 
<p>宏任务：由浏览器环境执行的异步代码</p> 
<p>例子：</p> 
<p><img alt="" height="274" src="https://images2.imgbox.com/6e/77/GGkzx6k1_o.png" width="638"></p> 
<p>微任务：由 JS 引擎环境执行的异步代码</p> 
<p>例子：</p> 
<p><img alt="" height="168" src="https://images2.imgbox.com/f5/79/itiLqF8T_o.png" width="585"></p> 
<p><span style="color:#fe2c24;"><strong>Promise 本身是同步的，而then和catch回调函数是异步的 </strong></span></p> 
<p>使用图解-分析代码执行顺序</p> 
<p><img alt="" height="777" src="https://images2.imgbox.com/2f/d2/Aa9nIIJZ_o.png" width="1200"></p> 
<p> </p> 
<p><span style="color:#fe2c24;"><strong>JS代码的执行流程：script代码块-》代码块里的同步任务-》微任务-》宏任务 </strong></span></p> 
<p><img alt="" height="192" src="https://images2.imgbox.com/a1/e3/KCidEHaG_o.png" width="659"></p> 
<h4 id="%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%20-%20%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98%C2%A0">事件循环 - 经典面试题 </h4> 
<p><img alt="" height="772" src="https://images2.imgbox.com/60/4c/UENJHGns_o.png" width="1200"></p> 
<p>答案：1756234 </p> 
<p>总结：</p> 
<blockquote> 
 <p>1. 什么是宏任务？</p> 
 <ul><li>➢ 浏览器执行的异步代码</li><li>➢ 例如：<span style="color:#fe2c24;"><strong>JS 执行脚本事件，setTimeout/setInterval，AJAX请求完成事件，用户交互事件</strong></span>等</li></ul> 
 <p>2. 什么是微任务？</p> 
 <ul><li>➢ JS 引擎执行的异步代码</li><li>➢ 例如：<span style="color:#fe2c24;"><strong>Promise对象.then()的回调</strong></span></li></ul> 
 <p>3. JavaScript 内代码如何执行？</p> 
 <ul><li>➢ 执行第一个 script 脚本事件宏任务，里面同步代码</li><li>➢ 遇到 宏任务/微任务 交给宿主环境，有结果回调函数进入对应队列</li><li>➢ 当执行栈空闲时，清空微任务队列，再执行下一个宏任务，从1再来</li></ul> 
 <p> </p> 
</blockquote> 
<p></p> 
<h3 id="%E2%97%86%20Promise.all%20%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95" style="background-color:transparent;">◆ Promise.all 静态方法</h3> 
<p>概念：合并多个 Promise 对象，等待所有同时成功完成（或某一个失败），做后续逻辑</p> 
<p><img alt="" height="537" src="https://images2.imgbox.com/46/f5/u1WTuahB_o.png" width="1200"></p> 
<p>语法： </p> 
<p><img alt="" height="252" src="https://images2.imgbox.com/de/c4/JlrhPaAe_o.png" width="840"></p> 
<p>案例：</p> 
<p>需求：同时请求“北京”，“上海”，“广州”，“深圳”的天气并在网页尽可能同时显示</p> 
<p><img alt="" height="240" src="https://images2.imgbox.com/be/31/XAivdaZC_o.png" width="545"></p> 
<p><img alt="" height="551" src="https://images2.imgbox.com/54/8e/xn3XE4BC_o.png" width="1200"> </p> 
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;

&lt;head&gt;
  &lt;meta charset="UTF-8"&gt;
  &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;
  &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
  &lt;title&gt;Promise的all方法&lt;/title&gt;
&lt;/head&gt;

&lt;body&gt;
  &lt;ul class="my-ul"&gt;&lt;/ul&gt;
  &lt;script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"&gt;&lt;/script&gt;
  &lt;script&gt;
    /**
     * 目标：掌握Promise的all方法作用，和使用场景
     * 业务：当我需要同一时间显示多个请求的结果时，就要把多请求合并
     * 例如：默认显示"北京", "上海", "广州", "深圳"的天气在首页查看
     * code：
     * 北京-110100
     * 上海-310100
     * 广州-440100
     * 深圳-440300
    */
    // 1. 请求城市天气，得到Promise对象
    const bjPromise = axios({ url: 'http://hmajax.itheima.net/api/weather', params: { city: '110100' } })
    const shPromise = axios({ url: 'http://hmajax.itheima.net/api/weather', params: { city: '310100' } })
    const gzPromise = axios({ url: 'http://hmajax.itheima.net/api/weather', params: { city: '440100' } })
    const szPromise = axios({ url: 'http://hmajax.itheima.net/api/weather', params: { city: '440300' } })

    // 2. 使用Promise.all，合并多个Promise对象
    const p = Promise.all([bjPromise, shPromise, gzPromise, szPromise])
    p.then(result =&gt; {
      // 注意：结果数组顺序和合并时顺序是一致
      console.log(result)
      const htmlStr = result.map(item =&gt; {
        return `&lt;li&gt;${item.data.data.area} --- ${item.data.data.weather}&lt;/li&gt;`
      }).join('')
      document.querySelector('.my-ul').innerHTML = htmlStr
    }).catch(error =&gt; {
      console.dir(error)
    })
  &lt;/script&gt;
&lt;/body&gt;

&lt;/html&gt;</code></pre> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3c767040a4a8f3530dcb1df9668324f7/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">测试ASP.NET Core项目调用EasyCaching的基本用法（InMemory）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5277a1a139464e93f5fd1453d20cad15/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【BUG】golang gorm导入数据库报错 “unexpected type clause.Expr“</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>