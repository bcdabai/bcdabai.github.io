<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>AJAX跨域 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="AJAX跨域" />
<meta property="og:description" content="一、什么是AJAX跨域问题、产生AJAX跨域问题的原因 什么是AJAX跨域问题
简单来说，就是前端调用后端服务接口时如果服务接口不是同一个域，就会产生跨域问题 AJAX跨域场景
前后端分离、服务化的开发模式前后端开发独立，前端需要大量调用后端接口的场景只要后端接口不是同一个域，就会产生跨域问题跨域问题很普遍，解决跨域问题也很重要 AJAX跨域原因
浏览器限制：浏览器安全校验限制跨域（协议、域名、端口任何一个不一样都会认为是跨域）XHR（XMLHttpRequest）请求 二、AJAX跨域解决方式 AJAX跨域问题解决思路
浏览器：浏览器取下跨域校验，实际价值不大XHR：不使用XHR，使用JSONP，有很多弊端，无法满足现在的开发要求跨域：被调用方修改支持跨域调用（指定参数）；调用方修改隐藏跨域（基于代理） 1、禁止浏览器检查 cmd启动的时候添加参数关闭安全检测
--disable-web-security --user-data-dir=C:MyChromeDevUserData 2、JSONP package com.xjn.ajax.server.controller; import org.springframework.web.bind.annotation.ControllerAdvice; import org.springframework.web.servlet.mvc.method.annotation.AbstractJsonpResponseBodyAdvice; /** * &lt;br&gt; * 标题: JSONP 全局处理&lt;br&gt; * 描述: 统一处理JSONP&lt;br&gt; */ @ControllerAdvice public class JsonpAdvice extends AbstractJsonpResponseBodyAdvice{ public JsonpAdvice() { // 与前端约定好回调方法名称，默认是callback super(&#34;callback&#34;); } } $.ajax({ url: base &#43; &#34;/get1&#34;, dataType: &#34;jsonp&#34;, jsonp:&#34;callback&#34;, success: function (res) { result = res; } }); jsonp实际原理是在url后面拼接一串字符，使浏览器知道自己是jsonp请求。所以仅适用于get方法请求，后端返回来的数据经过jsonpadvice配置，返回的是javascript数据。
3、支持跨域 方法一：被调用方支持跨域
被调用方解决，基于支持跨域的解决思路，基于Http协议关于跨域的相关规定，在响应头里增加指定的字段告诉浏览器，允许调用跨域请求是直接从浏览器发送到被调用方，被调用方在响应头里增加相关信息，返回到页面，页面能正常获取请求内容。
过滤器java代码
import org." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/8ef1107c35ff6c782b63cc56b465970b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-08-17T15:32:01+08:00" />
<meta property="article:modified_time" content="2020-08-17T15:32:01+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">AJAX跨域</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>一、什么是AJAX跨域问题、产生AJAX跨域问题的原因</h3> 
<p>什么是AJAX跨域问题</p> 
<ul><li>简单来说，就是前端调用后端服务接口时</li><li>如果服务接口不是同一个域，就会产生跨域问题</li></ul> 
<p>AJAX跨域场景</p> 
<ul><li>前后端分离、服务化的开发模式</li><li>前后端开发独立，前端需要大量调用后端接口的场景</li><li>只要后端接口不是同一个域，就会产生跨域问题</li><li>跨域问题很普遍，解决跨域问题也很重要</li></ul> 
<p>AJAX跨域原因</p> 
<ul><li>浏览器限制：浏览器安全校验限制</li><li>跨域（协议、域名、端口任何一个不一样都会认为是跨域）</li><li>XHR（XMLHttpRequest）请求</li></ul> 
<h3>二、AJAX跨域解决方式</h3> 
<p>AJAX跨域问题解决思路</p> 
<ul><li>浏览器：浏览器取下跨域校验，实际价值不大</li><li>XHR：不使用XHR，使用JSONP，有很多弊端，无法满足现在的开发要求</li><li>跨域：被调用方修改支持跨域调用（指定参数）；调用方修改隐藏跨域（基于代理）</li></ul> 
<h4>1、禁止浏览器检查</h4> 
<p style="text-indent:33px;">cmd启动的时候添加参数关闭安全检测</p> 
<pre><code class="language-bash">--disable-web-security --user-data-dir=C:MyChromeDevUserData</code></pre> 
<h4>2、JSONP</h4> 
<pre><code class="language-java">package com.xjn.ajax.server.controller;

import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.servlet.mvc.method.annotation.AbstractJsonpResponseBodyAdvice;

/**
 * &lt;br&gt;
 * 标题: JSONP 全局处理&lt;br&gt;
 * 描述: 统一处理JSONP&lt;br&gt;
 */
@ControllerAdvice
public class JsonpAdvice extends AbstractJsonpResponseBodyAdvice{
    public JsonpAdvice() {
        // 与前端约定好回调方法名称，默认是callback
        super("callback");
    }
}</code></pre> 
<pre><code class="language-javascript">            $.ajax({
                url: base + "/get1",
                dataType: "jsonp",
                jsonp:"callback",
                success: function (res) {
                    result = res;
                }
            });</code></pre> 
<p style="text-indent:33px;">jsonp实际原理是在url后面拼接一串字符，使浏览器知道自己是jsonp请求。所以仅适用于get方法请求，后端返回来的数据经过jsonpadvice配置，返回的是javascript数据。</p> 
<h4 style="text-indent:0px;">3、支持跨域</h4> 
<p>方法一：被调用方支持跨域</p> 
<p style="text-indent:33px;">被调用方解决，基于支持跨域的解决思路，基于Http协议关于跨域的相关规定，在响应头里增加指定的字段告诉浏览器，允许调用跨域请求是直接从浏览器发送到被调用方，被调用方在响应头里增加相关信息，返回到页面，页面能正常获取请求内容。</p> 
<p style="text-indent:33px;">过滤器java代码</p> 
<pre><code class="language-java">import org.springframework.util.StringUtils;

import javax.servlet.*;
import javax.servlet.FilterConfig;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

/**
 * &lt;br&gt;
 * 标题: 服务端解决跨域&lt;br&gt;
 * 描述: 使用Filter&lt;br&gt;
 *
 * @author zc
 * @date 2018/04/18
 */
public class CrosFilter implements Filter {

    @Override
    public void init(FilterConfig filterConfig) throws ServletException {

    }

    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
        HttpServletResponse res = (HttpServletResponse)response;

        HttpServletRequest req = (HttpServletRequest)request;

        // 支持所有域
        String origin = req.getHeader("Origin");
        if (!StringUtils.isEmpty(origin)){
            // 支持任何域名的跨域调用 且 支持带cookie（是被调用方域名的cookie，而不是调用方的cookie）
            res.addHeader("Access-Control-Allow-Origin",origin);
        }
        // 指定允许的域，带cookie时，origin必须是全匹配，不能使用 *
//        res.addHeader("Access-Control-Allow-Origin","http://localhost:8081");
        // 允许所有域，但不能满足带 cookie 的跨域请求
//        res.addHeader("Access-Control-Allow-Origin","*");

        // 支持所有自定义头
        String headers = req.getHeader("Access-Control-Allow-Headers");
        if (!StringUtils.isEmpty(headers)){
            // 允许所有header
            res.addHeader("Access-Control-Allow-Headers",headers);
        }
        // 允许所有header
//        res.addHeader("Access-Control-Allow-Headers","*");

        // 指定允许的方法
//        res.addHeader("Access-Control-Allow-Methods","GET");
        // 允许所有方法
        res.addHeader("Access-Control-Allow-Methods","*");
        // 允许浏览器在一个小时内，缓存跨域访问信息（即上面三个信息）
        res.addHeader("Access-Control-Max-Age","3600");
        // 启用 cookie
        res.addHeader("Access-Control-Allow-Credentials","true");

        chain.doFilter(request,response);
    }

    @Override
    public void destroy() {

    }
}</code></pre> 
<p>web.xml中配置注册过滤器 （1）</p> 
<pre><code class="language-html">&lt;filter&gt;
    &lt;filter-name&gt;CrossFilter&lt;/filter-name&gt;
    &lt;filter-class&gt;com.test.ajax.cross.filter.CrossFilter&lt;/filter-class&gt;
&lt;/filter&gt;
&lt;filter-mapping&gt;
    &lt;filter-name&gt;CrossFilter&lt;/filter-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;</code></pre> 
<p>javabean方式配置过滤器</p> 
<pre><code class="language-java">import org.springframework.boot.web.servlet.FilterRegistrationBean;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

/**
 * &lt;br&gt;
 * 标题: 配置类&lt;br&gt;
 * 描述: 注册CrosFilter&lt;br&gt;
 */
@Configuration
public class FilterConfig {

    @Bean
    public FilterRegistrationBean registrationBean(){
        FilterRegistrationBean filter = new FilterRegistrationBean();
        filter.addUrlPatterns("/*");
        filter.setFilter(new CrosFilter());
        return filter;
    }
}</code></pre> 
<p>跨域携带cookie</p> 
<pre><code class="language-javascript">    function getCookie(){
         $.ajax({
             url: "http://localhost:8080/test-ajax-cross/test/getCookie",
             xhrFields:{
                 // 带上证书，发送 AJAX 请求时带上 cookie
                 withCredentials:true
             },
             // 允许跨域
             crossDomain: true,
             success:function(result){
                 console.log(result);
                 $("body").append("&lt;br&gt;" + JSON.stringify(result));
             }
         });</code></pre> 
<p>简单请求与非简单请求</p> 
<ul><li>简单请求：浏览器先发送真正的请求后检查</li><li>请求方法：GET、HEAD、POST的一种</li><li>请求header：无自定义header；Content-Type为：text/plain、multipart/form-data、application/x-www-form-urlencoded的一种</li><li>非简单请求：浏览器先发预检命令，检查通过后，才发送真正的请求</li><li>常见的有：PUT、DELETE</li><li>其它条件：发送Json格式的请求、带自定义header的请求</li><li>预检命令：浏览器检测到跨域请求, 会自动发出一个OPTIONS请求, 就是所谓的预检（preflight）请求。当预检请求通过的时候，才发送真正的请求。</li></ul> 
<p>另外可以对被调用方的apache服务器、nginx服务器进行配置跨域</p> 
<p id="crossDomain_3_2" style="text-indent:33px;"><span style="color:#e579b6;">CORS是一个W3C标准，全称是"跨域资源共享"（Cross-origin resource sharing）。它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。cors是浏览器直接访问被调用方服务器。</span></p> 
<h4>4、隐藏跨域</h4> 
<p>使用Nginx反向代理实现</p> 
<ul><li>修改主机hosts文件增加映射本地域名：127.0.0.1 a.com</li><li>在vhost目录下创建a.com.conf</li><li>启动niginx，访问a.com/ajaxserver/get1</li></ul> 
<p>编写a.com.conf</p> 
<pre><code class="language-bash">server{
    listen 80;
    server_name a.com;

    location /{
         proxy_pass http://localhost:8081/;
    }

    location /ajaxserver{
         proxy_pass http://localhost:8080/test/;
    }

}</code></pre> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/57b3bcf703e58fdaa140b6cfb7c659f0/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">PyCharm 编写 Numpy 程序时报 No module named ‘numpy‘ 错误的解决</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d07479dc898c166baa727db0d2a30b6a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Spring-----声明式事务管理-xml方式配置</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>