<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Struts2 教程 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Struts2 教程" />
<meta property="og:description" content="一、Struts2是什么 Struts2是在WebWork2基础发展而来的。和Struts1一样， Struts2也是基于MVC的web层框架。 那么既然有了Struts1，为何还要Struts2？ Struts2和Struts1虽然都是基于MVC的Web框架，但是它们的实现机制完全不同。 Struts1是基于Servlet的实现，并且Struts1的API过分依赖容器，导致了Action开发、测试都非常繁琐，而Struts2是基于过滤器的实现，API不再依赖容器，测试过程中不必再模拟Web容器环境，开发、测试较Struts1都有很大的进步。 Struts1的Action是单例模式所有请求共享一个ActionServlet，所以线程必须是安全的，而Struts2每个请求都会绑定一个Action，不再有线程安全问题。 Struts2开始支持注解并提供了更为强大的OGNL标签库以及值栈，从类到页面的开发都更加简洁高效。 Struts2和Struts1都是基于MVC的Web层框架，所以，他们工作原理还是一样的，都是对请求进行拦截、分发、处理，之后返回页面，只不过他们的实现机制不同罢了。 因此，Struts2的工作原理就不再过多介绍，下面我们来看如何使用Sturts2搭建一个Web开发环境。 二、Struts2的使用 让我们先用Sturts2 展示一个Helloworld。 1、创建web项目struts2_helloworld，添加Struts2的依赖支持 struts2-core-2.3.8.jar xwork-core-2.3.8.jar commons-lang3-3.1.jar ognl-3.0.6.jar javassist-3.11.0.GA.jar asm-3.3.jar asm-commons-3.3.jar asm-tree-3.3.jar freemarker-2.3.19.jar commons-fileupload-1.2.2.jar commons-io-2.3.jar 2、在web.xml中配置struts2 &lt;filter&gt; &lt;filter- name&gt;struts2&lt;/filter- name&gt; &lt;filter- class&gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&lt;/filter- class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter- name&gt;struts2&lt;/filter- name&gt; &lt; url-pattern&gt;/*&lt;/ url-pattern&gt; &lt;/filter-mapping&gt; 3、创建Struts2配置文件struts.xml &lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34; ?&gt; &lt;! DOCTYPE struts PUBLIC &#34;-//Apache Software Foundation//DTD Struts Configuration 2.1//EN&#34; &#34;http://struts.apache.org/dtds/struts-2.1.dtd&#34;&gt; &lt;struts&gt; &lt;package name=&#34;default&#34; namespace=&#34;/&#34; extends=&#34;struts-default&#34;&gt; &lt; action name=&#34;hello&#34; class=&#34;com.boya.struts2.web.HelloAction&#34;&gt; &lt;result&gt; /helloWorld.jsp &lt;/result&gt; &lt;/ action&gt; &lt;/package&gt; &lt;/struts&gt; 注意，与Struts1不同，Struts2的配置文件并不放在WEB-INF目录下，而需要放置在src源码根目录下 4、创建Action类 public class HelloAction { public String execute() { return &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/a41a064102cbe592d848120fbb1ef879/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2014-10-27T15:44:00+08:00" />
<meta property="article:modified_time" content="2014-10-27T15:44:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Struts2 教程</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="cnblogs_post_body" class="blogpost-body"> 
 <div> 
  <strong>一、Struts2是什么</strong> 
 </div> 
 <div>
   Struts2是在WebWork2基础发展而来的。和Struts1一样， Struts2也是基于MVC的web层框架。 
 </div> 
 <div>
   那么既然有了Struts1，为何还要Struts2？ 
 </div> 
 <div>
   Struts2和Struts1虽然都是基于MVC的Web框架，但是它们的实现机制完全不同。 
 </div> 
 <div>
   Struts1是基于Servlet的实现，并且Struts1的API过分依赖容器，导致了Action开发、测试都非常繁琐，而Struts2是基于过滤器的实现，API不再依赖容器，测试过程中不必再模拟Web容器环境，开发、测试较Struts1都有很大的进步。 
 </div> 
 <div>
   Struts1的Action是单例模式所有请求共享一个ActionServlet，所以线程必须是安全的，而Struts2每个请求都会绑定一个Action，不再有线程安全问题。 
 </div> 
 <div>
   Struts2开始支持注解并提供了更为强大的OGNL标签库以及值栈，从类到页面的开发都更加简洁高效。 
 </div> 
 <div>
     
 </div> 
 <div>
   Struts2和Struts1都是基于MVC的Web层框架，所以，他们工作原理还是一样的，都是对请求进行拦截、分发、处理，之后返回页面，只不过他们的实现机制不同罢了。 
 </div> 
 <div>
   因此，Struts2的工作原理就不再过多介绍，下面我们来看如何使用Sturts2搭建一个Web开发环境。 
 </div> 
 <div>
     
 </div> 
 <div> 
  <strong>二、Struts2的使用</strong> 
 </div> 
 <div>
   让我们先用Sturts2 展示一个Helloworld。 
 </div> 
 <div>
   1、创建web项目struts2_helloworld，添加Struts2的依赖支持 
 </div> 
 <blockquote dir="ltr"> 
  <div>
    struts2-core-2.3.8.jar 
  </div> 
  <div> 
   <div>
     xwork-core-2.3.8.jar 
   </div> 
   <div>
     commons-lang3-3.1.jar 
   </div> 
   <div>
     ognl-3.0.6.jar 
   </div> 
   <div>
     javassist-3.11.0.GA.jar 
   </div> 
   <div>
     asm-3.3.jar 
   </div> 
   <div>
     asm-commons-3.3.jar 
   </div> 
   <div>
     asm-tree-3.3.jar 
   </div> 
   <div>
     freemarker-2.3.19.jar 
   </div> 
   <div>
     commons-fileupload-1.2.2.jar 
   </div> 
   <div>
     commons-io-2.3.jar 
   </div> 
  </div> 
 </blockquote> 
 <div>
   2、在web.xml中配置struts2 
 </div> 
 <blockquote dir="ltr"> 
  <code></code> 
  <div>
      &lt;filter&gt; 
   <br>      &lt;filter- 
   <strong>name</strong>&gt;struts2&lt;/filter- 
   <strong>name</strong>&gt; 
   <br>      &lt;filter- 
   <strong>class</strong>&gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&lt;/filter- 
   <strong>class</strong>&gt; 
   <br>  &lt;/filter&gt; 
   <br>  &lt;filter-mapping&gt; 
   <br>      &lt;filter- 
   <strong>name</strong>&gt;struts2&lt;/filter- 
   <strong>name</strong>&gt; 
   <br>      &lt; 
   <strong>url</strong>-pattern&gt;/*&lt;/ 
   <strong>url</strong>-pattern&gt; 
   <br>  &lt;/filter-mapping&gt; 
  </div> 
 </blockquote> 
 <div>
   3、创建Struts2配置文件struts.xml 
 </div> 
 <blockquote dir="ltr"> 
  <code></code> 
  <div>
    &lt;?xml version="1.0" encoding="UTF-8" ?&gt; 
   <br>&lt;! 
   <strong>DOCTYPE</strong> struts PUBLIC 
   <br>    "-//Apache Software Foundation//DTD Struts Configuration 2.1//EN" 
   <br>    "http://struts.apache.org/dtds/struts-2.1.dtd"&gt; 
   <br>&lt;struts&gt; 
   <br>    &lt;package  
   <strong>name</strong>="default" namespace="/" extends="struts-default"&gt; 
   <br>        &lt; 
   <strong>action</strong>  
   <strong>name</strong>="hello"  
   <strong>class</strong>="com.boya.struts2.web.HelloAction"&gt; 
   <br>            &lt;result&gt; 
   <br>                /helloWorld.jsp 
   <br>            &lt;/result&gt; 
   <br>        &lt;/ 
   <strong>action</strong>&gt; 
   <br>    &lt;/package&gt; 
   <br>&lt;/struts&gt; 
  </div> 
 </blockquote> 
 <div>
   注意，与Struts1不同，Struts2的配置文件并不放在WEB-INF目录下，而需要放置在src源码根目录下 
 </div> 
 <div>
   4、创建Action类 
 </div> 
 <blockquote dir="ltr"> 
  <div>
    public class HelloAction { 
   <br>    public String execute() { 
   <br>        return "success"; 
   <br>    } 
   <br>} 
  </div> 
 </blockquote> 
 <div>
   5、创建返回页面helloWorld.jsp 
 </div> 
 <div>
     
 </div> 
 <div>
   现在就完成了一个简单的Struts2应用。启动Web服务器，访问： 
 </div> 
 <div> 
  <a href="http://localhost:8080/struts2_helloworld/hello" rel="nofollow">http://localhost:8080/struts2_helloworld/hello</a> 
 </div> 
 <div>
   就可以看到我们创建的helloWorld.jsp页面了。 
 </div> 
 <div>
     
 </div> 
 <div> 
  <strong>三、Sturts2的配置介绍</strong> 
 </div> 
 <div> 
  <strong>1、在web.xml配置Strut2过滤器拦截</strong> 
 </div> 
 <div>
   Sturts1是通过servlet映射实现的对请求的拦截，Struts2是通过Filter完成的对请求拦截。前者会在ActionSerlvet中加载核心配置文件，后者会在StrutsPrepareAndExecuteFilter过滤器中加载。因此，与Struts1不同的是，我们要在web.xml里面配置Struts2的Filter来拦截请求。 
 </div> 
 <div>
   配置方式见上文。 
 </div> 
 <div>
            
 </div> 
 <div> 
  <strong>2、Strtus2核心配置文件</strong> 
 </div> 
 <div>
   Struts2的默认配置文件是struts.xml,需要放置在源码根目录下。 
 </div> 
 <div>
   struts.xml中的action标签和Struts1中的作用一样，都是定义了一种映射关系。package标签则表明以包的形式来管理action和拦截器，通常情况下，按将逻辑相关一组业务Action作为一个模块放在同一个package下管理。 
 </div> 
 <div>
     
 </div> 
 <div>
   package有以下属性; 
 </div> 
 <div>
   name：包名称，其他包使用name继承当前包，不能重复 
 </div> 
 <div>
   namespace：定义当前包的命名空间，匹配请求URL的路径部分，不同的命名空间下可以有重名的action 
 </div> 
 <div>
   extends：当前包继承的父包，继承之后，当前包拥有父包中所定义的任意类、拦截器等 
 </div> 
 <div>
   abstract：定义当前包为一个抽象的包，也就是说不能有action元素在当前包中 
 </div> 
 <div>
     
 </div> 
 <div>
   action属性： 
 </div> 
 <div>
   name：action名称，用来匹配请求URL 
 </div> 
 <div>
   class：对应的具体Action实现类，默认为ActionSupport 
 </div> 
 <div>
   method：执行action时调用的方法，默认执行execute()，也可以在URL中动态指定，例如： 
 </div> 
 <div>
       &lt;a href="${ctx}/system/user!add"&gt;添加用户&lt;/a&gt; 
 </div> 
 <div>
     
 </div> 
 <div>
   result标签：定义action的返回跳转页面 
 </div> 
 <div>
   name：定义页面跳转名称，默认为success。在action中返回一个对应name的字符串，就会返回到对应的jsp页面 
 </div> 
 <div>
   type：设置返回结果类型，默认为dispatcher，用于返回jsp页面 
 </div> 
 <div>
     
 </div> 
 <div> 
  <strong>3、URL映射机制</strong> 
 </div> 
 <div>
   Struts1中，我们是使用path来映射URL请求的。在Struts2中是使用namespace + action的name来映射URL的。 
 </div> 
 <div>
   例如： 
 </div> 
 <div>
       namespace="/system" ， 
 </div> 
 <div>
       action设置name为"/user" 
 </div> 
 <div>
       那么这个action对应的URL就是 http://主机地址/工程名/system/user 
 </div> 
 <div>
     
 </div> 
 <div>
   namespace寻址机制： 
 </div> 
 <div>
   对于我们的一个URL请求，例如http://主机地址/工程名/path1/path2/path3/user 
 </div> 
 <div>
   Struts2会自动将URL中的后缀，以及Host和工程名去掉，将/path1/path2/path3这部分认为是namespace，首先会查找namespace="/path1/path2/path3"，如果这个命名空间查找不到，会继续查找namespace="/path1/path2"，仍然没有的话，会继续查找上一级命名空间，直到查找到namespace="/"为止。 
 </div> 
 <div>
   查找到命名空间，会在该命名空间的package下查找name="/user"的action。最后将这个请求交给action对应的业务处理类处理。 
 </div> 
 <div>
   namespace默认为""，当在其他namespace中映射不到的时候，都在这个namespace中寻找。 
 </div> 
 <div>
     
 </div> 
 <div>
   Struts2是用namespace和actionName来唯一区别一个Action，因此，在同一个namespace下不能配置同名的action，在不同的namespace下，可以有重名action。 
 </div> 
 <div>
     
 </div> 
 <div> 
  <strong>4、映射方式配置</strong> 
 </div> 
 <div> 
  <div>
    在web.xml的过滤器映射中除了这样配置： 
  </div> 
  <div>
    &lt;filter-mapping&gt; 
   <br>    &lt;filter- 
   <strong>name</strong>&gt;struts2&lt;/filter- 
   <strong>name</strong>&gt; 
   <br>    &lt; 
   <strong>url</strong>-pattern&gt;/*&lt;/ 
   <strong>url</strong>-pattern&gt; 
   <br>&lt;/filter-mapping&gt; 
  </div> 
  <div>
    也可以使用扩展名配置： 
  </div> 
  <div>
    &lt;filter-mapping&gt; 
   <br>    &lt;filter- 
   <strong>name</strong>&gt;struts2&lt;/filter- 
   <strong>name</strong>&gt; 
   <br>    &lt; 
   <strong>url</strong>-pattern&gt;*.action&lt;/ 
   <strong>url</strong>-pattern&gt; 
   <br>&lt;/filter-mapping&gt; 
  </div> 
  <div>
      
  </div> 
  <div>
    action是struts2默认支持的扩展名。/*在完成*.action的基础映射功能下，提供了额外的支持 
   <br>    a、用于访问classpath中特定的静态资源（如果是/struts、或者/static开始的资源，则在classpath下查找特定的包下面的匹配资源；） 
  </div> 
  <div>
        b、支持无后缀的action请求 
  </div> 
  <div>
      
  </div> 
  <div>
    使用/*方式映射时： 
  </div> 
  <div>
        访问/struts或/static目录，不希望加载strtus的静态资源的配置方式 
  </div> 
  <div>
        &lt;constant name="struts.serve.static" value="false" /&gt; 
  </div> 
  <div>
        希望强制使用扩展名映射的配置方式 
  </div> 
  <div>
        &lt;constant name="struts.action.extension" value="action" /&gt; 
  </div> 
  <div>
        同样可以使用上面的配置修改struts2的默认扩展名 
  </div> 
  <div>
        &lt;constant name="struts.action.extension" value="do" /&gt; 
  </div> 
  <div>
        不希望映射某个目录时（目录需要是一个正则表达式，因此需要使用.*的方式表示） 
  </div> 
  <div>
        &lt;constant name="struts.action.excludePattern" value="/dwr/.*,/noaction/.*" /&gt; 
  </div> 
 </div> 
 <div>
     
 </div> 
 <div> 
  <strong>5、Action的方法映射</strong> 
 </div> 
 <div>
       a、Action的方法映射可以通过method指定，未指定method方法时，默认执行execute()方法 
 </div> 
 <div>
       b、映射方法还可以在URL中动态指定（动态方法调用DMI） 
 </div> 
 <div>
           例如访问 http://localhost:8080/struts2_helloworld/hello!print 会调用hello对应的Action中的print()方法 
 </div> 
 <div>
           注：可以使用struts.enable.DynamicMethodInvocation参数配置DMI的开启关闭，默认为开启 
 </div> 
 <div> 
  <span class="tag">        &lt;<span class="tag-name">constant <span class="attribute">name=<span class="attribute-value">"struts.enable.DynamicMethodInvocation" <span class="attribute">value=<span class="attribute-value">"false" <span class="tag">/&gt;  </span></span></span></span></span></span></span> 
 </div> 
 <div>
       c、使用通配符映射 
 </div> 
 <div> 
  <div>
            &lt;action name="*_*" class="com.boya.struts2.web.{1}Action" method="{2}"&gt; 
  </div> 
  <div>
                &lt;result&gt; 
  </div> 
  <div>
                    /{0}.jsp 
  </div> 
  <div>
                   &lt;/result&gt; 
  </div>         &lt;/action&gt; 
 </div> 
 <div>
           使用{1}{2}{3}...{9}的顺序来匹配*，{0}匹配整体 
 </div> 
 <div>
           注：Struts2的通配符配置方式，极不灵活，不推荐使用 
 </div> 
 <div>
     
 </div> 
 <div> 
  <strong>6、设置返回结果类型</strong> 
 </div> 
 <div>
       返回结果类型可以通过result标签的type属性配置，默认类型为dispatcher，用于返回jsp页面。常用的返回结果类型有redirect、chain、json等 
 </div> 
 <div>
     
 </div> 
 <div>
       redirect类型配置(重定向到一个新的URL请求)： 
 </div> 
 <div>
           &lt;result name="success" type="redirect"&gt;/hello.jsp?name=${name}&lt;/result&gt; &lt;!--重定向到一个jsp页面--&gt; 
  <br>        &lt;result name="success" type="redirect"&gt;/hello.action&lt;/result&gt; &lt;!--重定向到一个acton请求--&gt; 
 </div> 
 <div>
       redirectAction类型配置(重定向到其他action)： 
 </div> 
 <div> 
  <div>
                &lt;result type="redirectAction"&gt; 
  </div> 
  <div> 
   <div> 
    <div>
                      &lt;param name="namespace"&gt;/&lt;/param&gt;    &lt;!--重定向Action所在的命名空间，默认为当前命名空间--&gt; 
    </div>                 &lt;param name="actionName"&gt;user&lt;/param&gt; &lt;!--重定向的Action名称--&gt; 
   </div>                 &lt;param name="method"&gt;login&lt;/param&gt;    &lt;!--重定向Action的方法名称--&gt; 
  </div> 
  <div>
                    &lt;param name="name"&gt;boya&lt;/param&gt;        &lt;!--重定向传参--&gt; 
  </div> 
  <div>
                    &lt;param name="password"&gt;123456&lt;/param&gt; &lt;!--重定向传参--&gt; 
  </div> 
  <div>
                &lt;/result&gt; 
  </div> 
 </div> 
 <div>
       chain类型配置，配置类似redirectAction（链到其他action，也就是转发操作）： 
 </div> 
 <div> 
  <div>
            &lt;result type="chain"&gt; 
  </div> 
  <div> 
   <div> 
    <div>
                  &lt;param name="namespace"&gt;/&lt;/param&gt; &lt;!--Action所在的命名空间，默认为当前命名空间--&gt; 
    </div>             &lt;param name="actionName"&gt;user&lt;/param&gt; &lt;!--Action名称--&gt; 
   </div>             &lt;param name="method"&gt;login&lt;/param&gt; &lt;!--Action的方法名称--&gt; 
  </div> 
  <div>
            &lt;/result&gt; 
  </div> 
  <div>
      
  </div> 
  <div>
        json类型配置 
  </div> 
  <div>
        a、添加struts2-json-plugin-2.3.8.jar 
  </div> 
  <div>
        b、Action代码（省略getter、setter方法，省略User实体类）： 
  </div> 
  <blockquote dir="ltr"> 
   <div> 
    <strong>public</strong>  
    <strong>class</strong> JsonAction  
    <strong>extends</strong> ActionSupport { 
    <br>     
    <strong>private</strong> Map&lt;String,Object&gt; dataMap; 
    <br>     
    <br>     
    <strong>public</strong> String json() { 
    <br>        dataMap =  
    <strong>new</strong> HashMap&lt;String, Object&gt;(); 
    <br>        User user =  
    <strong>new</strong> User(); 
    <br>        user.setName("张三"); 
    <br>        user.setAge(50); 
    <br>        dataMap.put("user", user); 
    <br>         
    <strong>return</strong> SUCCESS; 
    <br>    } 
    <br>} 
   </div> 
  </blockquote> 
  <div>
        c、配置struts.xml 
  </div> 
  <blockquote dir="ltr"> 
   <code></code> 
   <div>
     &lt;package  
    <strong>name</strong>="json" extends="struts-default,json-default" &gt; 
    <br>    &lt; 
    <strong>action</strong>  
    <strong>name</strong>="json"  
    <strong>class</strong>="com.boya.struts2.web.JsonAction"&gt; 
    <br>        &lt;result  
    <strong>type</strong>="json"&gt; 
    <br>            &lt; 
    <strong>param</strong>  
    <strong>name</strong>="root"&gt;dataMap&lt;/ 
    <strong>param</strong>&gt; 
    <br>        &lt;/result&gt; 
    <br>    &lt;/ 
    <strong>action</strong>&gt; 
    <br>&lt;/package&gt; 
   </div> 
  </blockquote> 
  <div>
        package需要继承"json-default" 
  </div> 
  <div>
        result类型需要配置为json     
  </div> 
  <div>
        result参数： 
  </div> 
  <div>
            root：指定返回属性，默认返回所有有返回值的getter方法的值 
  </div> 
  <div>
            excludeNullProperties：是否返回值为空的属性,值为boolean类型 
  </div> 
  <div>
            ignoreHierarchy：是否忽略父类属性，值为boolean类型 
  </div> 
  <div>
            includeProperties：指定返回root中的哪些属性，值为正则表达式，可使用逗号分隔设置多个 
  </div> 
  <div>
            excludeProperties：指定排除root中的哪些属性，值为正则表达式，可使用逗号分隔设置多个      
  </div> 
  <div>
      
  </div> 
  <div>
        d、返回内容： 
  </div> 
  <div>
            {"user":{"age":22,"name":"张三"}} 
  </div> 
  <div>
        
  </div> 
  <div> 
   <div>
     excludeProperties和includeProperties的验证区别： 
   </div> 首先，假设dataMap中返回结果为：{"users":[{"age":22,"name":"张三","password":"123456"},{"age":40,"name":"李四","password":"654321"}]}     
  </div> 
  <div>
    设置了排除或包含的属性后，以上结果需要验证的元素有users、users[0]、users[0].age、users[0].name、users[0].password、users[1]、users[1].age、users[1].name、users[1].password 
  </div> 
  <div>
    如果要排除password属性，需要设置&lt;param name="excludeProperties"&gt;users.*\.password&lt;/param&gt; ，excludeProperties是将正则表达式作为整体分别匹配以上各元素，这样就会把password排除掉。 
  </div> 
  <div>
    如果要只包含name属性，则不能设置为&lt;param name="includeProperties"&gt;users.*\.name&lt;/param&gt;，includeProperties会将正则表达式拆为users.*、users.*\.name（对分隔符，数组索引符合，对象属性间的点连接符等进行分割处理），这两个正则分别与上面各元素匹配，而users.*就会匹配全部元素，所以无法排除。 
  </div> 
  <div>
    要精确包含name属性，需要设置为：&lt;param name="includeProperties"&gt;users\[\d+\]\.name&lt;/param&gt; ，而这时，正则表达式会被拆为users, users\[\d+\], users\[\d+\]\.name ，最终只输出name属性。 
  </div> 
  <div>
      
  </div> 
 </div> 
 <div> 
  <strong>四、Action处理</strong> 
 </div> 
 <div>
   1、接收参数 
 </div> 
 <div>
       a、使用属性来接收参数 
 </div> 
 <div>
           例如，在UserAction中定义如下属性，并添加getter、setter方法 
 </div> 
 <div> 
  <div>
            private String name; 
  </div>          
  <strong>private</strong> String password; 
 </div> 
 <div>
           jsp使用对应名称的控件 
 </div> 
 <div>
           用户名&lt;input type="text" name="name"&gt;&lt;br&gt; 
 </div> 
 <div>
           密码&lt;input type="password" name="password"&gt;&lt;br&gt; 
 </div> 
 <blockquote dir="ltr"> 
  <div>
    这样就可以把提交的参数值传给UserAction的属性。 
  </div> 
  <div>
      
  </div> 
  <div>
    也可以通过URL将参数值传递给Action，如： 
  </div> 
  <div> 
   <a href="http://localhost:8080/struts2-helloworld/user!save?name=admin&amp;password=123456" rel="nofollow">http://localhost:8080/struts2-helloworld/user!save?name=admin&amp;password=123456</a> 
  </div> 
 </blockquote> 
 <div>
        
 </div> 
 <div>
       b、使用DomainModel接收参数 
 </div> 
 <div>
           例如，在UserAction中添加实体Bean类型的属性，同样需要添加getter、setter方法 
 </div> 
 <div>
                
  <strong>private User user;</strong> 
 </div> 
 <div>
           jsp的控件名称使用“对象.属性”形式，如 
 </div> 
 <div> 
  <div>
            用户名&lt;input type="text" name="user.name"&gt;&lt;br&gt; 
  </div> 
  <div>
            密码&lt;input type="password" name="user.password"&gt;&lt;br&gt; 
  </div> 
  <div>
            这样，提交的参数会自动封装如user对象中。在Action方法中，使用user.getName()就可以获取提交的用户名 
  </div> 
  <div>
             
  </div> 
  <div>
            使用URL传递参数就是这样的形式： 
  </div> 
  <div>
               
   <a href="http://localhost:8080/struts2-helloworld/user!save?user.name=admin&amp;user.password=123456" rel="nofollow">http://localhost:8080/struts2-helloworld/user!save?user.name=admin&amp;user.password=123456</a>       
  </div> 
  <div>
      
  </div> 
  <div>
    2、获取web容器的request和session 
  </div> 
  <div>
        Struts2不像Struts1那样依赖容器，默认情况下，request、session这些容器对象都是隐藏的，并且Struts2层分别使用RequestMap、SessionMap对request、session进行封装，是我们可以使用Map的key-value形式对request、session进行操作。我们可以获取RequestMap来作为request使用，也可以像传统web开发那样获取一个HttpServletRequest对象。 
  </div> 
  <div>
       
  </div> 
  <div>
        a、非IoC方式 
  </div> 
  <div>
            这种方式主要是利用了com.opensymphony.xwork2.ActionContext类以及org.apache.struts2.ServletActionContext类，分别用于获取RequestMap和HttpServletRequest对象。 
  </div> 
  <div>
            获取RequestMap、SessionMap对象 
  </div> 
  <div>
            Map request = (Map)ActionContext.getContext().get("request"); 
  </div> 
  <div>
            Map session = ActionContext.getContext().getSession(); 
  </div> 
 </div> 
 <div>
           获取HttpServletRequest、HttpSession对象         
 </div> 
 <div> 
  <div> 
   <div>
             HttpServletRequest request = ServletActionContext.getRequest(); 
   </div> 
   <div>
             HttpSession session = request.getSession(); 
   </div> 
  </div> 
  <div>
        b、IoC方式 
  </div> 
  <div>
            这种方式类似SpringIoc控制反转，是使用依赖注入的方式获得request和session对象的。 
  </div> 
  <div>
            获取RequestMap、SessionMap对象，Action需要实现RequestAware, SessionAware接口 
  </div> 
  <blockquote dir="ltr"> 
   <div>
          
    <strong>private</strong> Map request; 
   </div> 
   <div>
          
    <strong>private</strong> Map session; 
   </div> 
   <div>
          
   </div> 
   <div>
         @Override 
   </div> 
   <div>
          
    <strong>public</strong>  
    <strong>void</strong> setRequest(Map request) { 
   </div> 
   <div>
              
    <strong>this</strong>.request = request; 
   </div> 
   <div>
         } 
   </div> 
   <div>
       
   </div> 
   <div>
         @Override 
   </div> 
   <div>
          
    <strong>public</strong>  
    <strong>void</strong> setSession(Map session) { 
   </div> 
   <div>
              
    <strong>this</strong>.session = session; 
   </div>     } 
  </blockquote> 
  <div>
            获取HttpServletRequest、HttpSession对象，Action需要实现ServletRequestAware接口     
  </div> 
  <blockquote dir="ltr"> 
   <div>
          
    <strong>private</strong> HttpServletRequest request; 
   </div> 
   <div>
          
    <strong>private</strong> HttpSession session; 
   </div> 
   <div>
       
   </div> 
   <div>
         @Override 
   </div> 
   <div>
          
    <strong>public</strong>  
    <strong>void</strong> setServletRequest(HttpServletRequest request) { 
   </div> 
   <div>
              
    <strong>this</strong>.request = request; 
   </div> 
   <div>
              
    <strong>this</strong>.session = request.getSession(); 
   </div> 
   <div>
         } 
   </div> 
  </blockquote> 
  <div>
      
  </div> 
 </div> 
</div> 
<p>转载于:https://www.cnblogs.com/Raymond-YYC/p/4054365.html</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/edb0c32227ec2746ddd7bcdeca9eeb26/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Spring 教程（二）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/df828d3e00386869a3ab6f3dd3470eb6/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">VC加花指令</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>