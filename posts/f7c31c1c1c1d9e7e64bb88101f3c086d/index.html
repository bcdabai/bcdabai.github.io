<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>嵌入式——Linux 学习之路（二）：Docker - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="嵌入式——Linux 学习之路（二）：Docker" />
<meta property="og:description" content="嵌入式 —— Linux 学习之路（二）：Docker 一、Ubuntu1604 安装 Docker1、使用官方安装脚本自动安装2、使用国内 daocloud 一键安装命令3、手动安装a）卸载旧版本b）更新 apt 包索引c）安装 apt 依赖包，用于通过HTTPS来获取仓库d）添加 Docker 的官方 GPG 密钥e）写入软件源信息，设置稳定版仓库f）更新并安装 最新版本的 Docker Engine-Community 和 containerdg）测试 Docker 是否安装成功h）查找仓库中 Docker-CE 的版本i）安装指定版本的方式（与步骤 f 的区别） 4、查看 Docker 版本信息5、启动与停止 Docker 服务6、卸载 Docker 二、Win7 安装 Docker三、为什么要学习 Docker1、Linux 的部署形式2、虚拟化技术3、虚拟出一个隔离的程序运行环境4、容器技术5、为什么要选择 Docker 四、Docker 安装部署1、Docker 引擎2、Docker Daemon3、Rest 接口4、Docker Client5、Docker 平台组成6、安装 Dockera）开启 Linux 内核的流量转发（暂未使用）b）加载修改内核的参数，配置文件（暂未使用）c）安装 Docker 参考第一章节d）镜像加速器e）修改 Docker 配置文件f）重新启动服务g）查看 Docker 进程h）查看 Docker 是否正确启动 五、启动第一个 Docker 容器1、获取镜像2、运行镜像，生成容器 六、Docker 的生命周期七、Docker 镜像的原理1、 快速实践，使用 Docker，来切换不同的发行版，内核使用的都是宿主机的内核2、理解什么是 Docker 镜像4、Docker 为什么分层镜像5、可写的容器层6、Docker 镜像的内容 八、获取镜像1、镜像托管仓库2、搜索镜像3、查看本地的镜像文件有哪些4、下载 Docker 镜像5、查看 Docker 镜像的存储路径 6、使用不同的镜像，生成容器7、如何查看 centos 的标签信息 九、查看镜像1、查看本地镜像 十、删除镜像1、下载一个 hello-world 镜像2、运行 hello-world 生成容器3、删除 hello-world4、查看正在运行或运行过的容器5、删除容器记录 十一、镜像管理1、批量删除镜像的用法（危险）2、批量删除容器3、导出镜像4、导入镜像5、查看镜像详细信息 十一、容器管理1、创建 &#43; 启动2、运行一个挂掉的容器3、查看容器日志的方法4、进入容器空间内5、查看容器的详细信息6、容器的端口映射7、容器的提交 十二、Dockerfile 创建镜像1、创建镜像的两个方法2、官方提供的 Dockerfile 实例3、dockerfile 主要组成部分4、Dockerfile 指令 十三、快速入门 Dockerfile1、通过 Dockerfile，构建 nginx 镜像，且运行容器后，生成的页面是&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/f7c31c1c1c1d9e7e64bb88101f3c086d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-09-21T16:49:22+08:00" />
<meta property="article:modified_time" content="2022-09-21T16:49:22+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">嵌入式——Linux 学习之路（二）：Docker</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>嵌入式 —— Linux 学习之路（二）：Docker</h4> 
 <ul><li><a href="#Ubuntu1604__Docker_1" rel="nofollow">一、Ubuntu1604 安装 Docker</a></li><li><ul><li><a href="#1_2" rel="nofollow">1、使用官方安装脚本自动安装</a></li><li><a href="#2_daocloud__20" rel="nofollow">2、使用国内 daocloud 一键安装命令</a></li><li><a href="#3_24" rel="nofollow">3、手动安装</a></li><li><ul><li><a href="#a_25" rel="nofollow">a）卸载旧版本</a></li><li><a href="#b_apt__32" rel="nofollow">b）更新 apt 包索引</a></li><li><a href="#c_apt_HTTPS_36" rel="nofollow">c）安装 apt 依赖包，用于通过HTTPS来获取仓库</a></li><li><a href="#d_Docker__GPG__45" rel="nofollow">d）添加 Docker 的官方 GPG 密钥</a></li><li><a href="#e_49" rel="nofollow">e）写入软件源信息，设置稳定版仓库</a></li><li><a href="#f__Docker_EngineCommunity__containerd_56" rel="nofollow">f）更新并安装 最新版本的 Docker Engine-Community 和 containerd</a></li><li><a href="#g_Docker__61" rel="nofollow">g）测试 Docker 是否安装成功</a></li><li><a href="#h_DockerCE__67" rel="nofollow">h）查找仓库中 Docker-CE 的版本</a></li><li><a href="#i_f__73" rel="nofollow">i）安装指定版本的方式（与步骤 f 的区别）</a></li></ul> 
   </li><li><a href="#4_Docker__80" rel="nofollow">4、查看 Docker 版本信息</a></li><li><a href="#5_Docker__87" rel="nofollow">5、启动与停止 Docker 服务</a></li><li><a href="#6_Docker_96" rel="nofollow">6、卸载 Docker</a></li></ul> 
  </li><li><a href="#Win7__Docker_111" rel="nofollow">二、Win7 安装 Docker</a></li><li><a href="#_Docker_115" rel="nofollow">三、为什么要学习 Docker</a></li><li><ul><li><a href="#1Linux__116" rel="nofollow">1、Linux 的部署形式</a></li><li><a href="#2_133" rel="nofollow">2、虚拟化技术</a></li><li><a href="#3_135" rel="nofollow">3、虚拟出一个隔离的程序运行环境</a></li><li><a href="#4_139" rel="nofollow">4、容器技术</a></li><li><a href="#5_Docker_147" rel="nofollow">5、为什么要选择 Docker</a></li></ul> 
  </li><li><a href="#Docker__166" rel="nofollow">四、Docker 安装部署</a></li><li><ul><li><a href="#1Docker__167" rel="nofollow">1、Docker 引擎</a></li><li><a href="#2Docker_Daemon_169" rel="nofollow">2、Docker Daemon</a></li><li><a href="#3Rest__175" rel="nofollow">3、Rest 接口</a></li><li><a href="#4Docker_Client_177" rel="nofollow">4、Docker Client</a></li><li><a href="#5Docker__179" rel="nofollow">5、Docker 平台组成</a></li><li><a href="#6_Docker_207" rel="nofollow">6、安装 Docker</a></li><li><ul><li><a href="#a_Linux__208" rel="nofollow">a）开启 Linux 内核的流量转发（暂未使用）</a></li><li><a href="#b_218" rel="nofollow">b）加载修改内核的参数，配置文件（暂未使用）</a></li><li><a href="#c_Docker__223" rel="nofollow">c）安装 Docker 参考第一章节</a></li><li><a href="#d_224" rel="nofollow">d）镜像加速器</a></li><li><a href="#e_Docker__227" rel="nofollow">e）修改 Docker 配置文件</a></li><li><a href="#f_248" rel="nofollow">f）重新启动服务</a></li><li><a href="#g_Docker__254" rel="nofollow">g）查看 Docker 进程</a></li><li><a href="#h_Docker__260" rel="nofollow">h）查看 Docker 是否正确启动</a></li></ul> 
  </li></ul> 
  </li><li><a href="#_Docker__266" rel="nofollow">五、启动第一个 Docker 容器</a></li><li><ul><li><a href="#1_267" rel="nofollow">1、获取镜像</a></li><li><a href="#2_288" rel="nofollow">2、运行镜像，生成容器</a></li></ul> 
  </li><li><a href="#Docker__325" rel="nofollow">六、Docker 的生命周期</a></li><li><a href="#Docker__328" rel="nofollow">七、Docker 镜像的原理</a></li><li><ul><li><a href="#1__Docker_329" rel="nofollow">1、 快速实践，使用 Docker，来切换不同的发行版，内核使用的都是宿主机的内核</a></li><li><a href="#2_Docker__345" rel="nofollow">2、理解什么是 Docker 镜像</a></li><li><a href="#4Docker__367" rel="nofollow">4、Docker 为什么分层镜像</a></li><li><a href="#5_374" rel="nofollow">5、可写的容器层</a></li><li><a href="#6Docker__380" rel="nofollow">6、Docker 镜像的内容</a></li></ul> 
  </li><li><a href="#_388" rel="nofollow">八、获取镜像</a></li><li><ul><li><a href="#1_389" rel="nofollow">1、镜像托管仓库</a></li><li><a href="#2_391" rel="nofollow">2、搜索镜像</a></li><li><a href="#3_397" rel="nofollow">3、查看本地的镜像文件有哪些</a></li><li><a href="#4_Docker__402" rel="nofollow">4、下载 Docker 镜像</a></li><li><ul><li><a href="#5_Docker__409" rel="nofollow">5、查看 Docker 镜像的存储路径</a></li></ul> 
   </li><li><a href="#6_424" rel="nofollow">6、使用不同的镜像，生成容器</a></li><li><a href="#7_centos__431" rel="nofollow">7、如何查看 centos 的标签信息</a></li></ul> 
  </li><li><a href="#_433" rel="nofollow">九、查看镜像</a></li><li><ul><li><a href="#1_434" rel="nofollow">1、查看本地镜像</a></li></ul> 
  </li><li><a href="#_459" rel="nofollow">十、删除镜像</a></li><li><ul><li><a href="#1_helloworld__460" rel="nofollow">1、下载一个 hello-world 镜像</a></li><li><a href="#2_helloworld__464" rel="nofollow">2、运行 hello-world 生成容器</a></li><li><a href="#3_helloworld_468" rel="nofollow">3、删除 hello-world</a></li><li><a href="#4_480" rel="nofollow">4、查看正在运行或运行过的容器</a></li><li><a href="#5_488" rel="nofollow">5、删除容器记录</a></li></ul> 
  </li><li><a href="#_493" rel="nofollow">十一、镜像管理</a></li><li><ul><li><a href="#1_494" rel="nofollow">1、批量删除镜像的用法（危险）</a></li><li><a href="#2_505" rel="nofollow">2、批量删除容器</a></li><li><a href="#3_509" rel="nofollow">3、导出镜像</a></li><li><a href="#4_530" rel="nofollow">4、导入镜像</a></li><li><a href="#5_537" rel="nofollow">5、查看镜像详细信息</a></li></ul> 
  </li><li><a href="#_545" rel="nofollow">十一、容器管理</a></li><li><ul><li><a href="#1___546" rel="nofollow">1、创建 + 启动</a></li><li><a href="#2_555" rel="nofollow">2、运行一个挂掉的容器</a></li><li><a href="#3_577" rel="nofollow">3、查看容器日志的方法</a></li><li><a href="#4_588" rel="nofollow">4、进入容器空间内</a></li><li><a href="#5_593" rel="nofollow">5、查看容器的详细信息</a></li><li><a href="#6_597" rel="nofollow">6、容器的端口映射</a></li><li><a href="#7_609" rel="nofollow">7、容器的提交</a></li></ul> 
  </li><li><a href="#Dockerfile__615" rel="nofollow">十二、Dockerfile 创建镜像</a></li><li><ul><li><a href="#1_616" rel="nofollow">1、创建镜像的两个方法</a></li><li><a href="#2_Dockerfile__619" rel="nofollow">2、官方提供的 Dockerfile 实例</a></li><li><a href="#3dockerfile__621" rel="nofollow">3、dockerfile 主要组成部分</a></li><li><a href="#4Dockerfile__625" rel="nofollow">4、Dockerfile 指令</a></li></ul> 
  </li><li><a href="#_Dockerfile_637" rel="nofollow">十三、快速入门 Dockerfile</a></li><li><ul><li><a href="#1_Dockerfile_nginx_docker_638" rel="nofollow">1、通过 Dockerfile，构建 nginx 镜像，且运行容器后，生成的页面是"超哥带你学习docker"</a></li><li><a href="#2COPY__655" rel="nofollow">2、COPY 指令用法</a></li><li><a href="#3ADD__664" rel="nofollow">3、ADD 指令用法</a></li><li><a href="#3CMD__675" rel="nofollow">3、CMD 指令用法</a></li><li><a href="#4_692" rel="nofollow">4、容器内运行的程序</a></li><li><a href="#5ENTRYPOINT_707" rel="nofollow">5、ENTRYPOINT</a></li><li><a href="#6ARG__ENV_755" rel="nofollow">6、ARG 和 ENV</a></li><li><a href="#7VOLUME_767" rel="nofollow">7、VOLUME</a></li><li><a href="#8EXPOSE_785" rel="nofollow">8、EXPOSE</a></li><li><a href="#9WORKDIR_794" rel="nofollow">9、WORKDIR</a></li><li><a href="#10USER_799" rel="nofollow">10、USER</a></li></ul> 
  </li><li><a href="#_805" rel="nofollow">参考资料</a></li></ul> 
</div> 
<p></p> 
<h2><a id="Ubuntu1604__Docker_1"></a>一、Ubuntu1604 安装 Docker</h2> 
<h3><a id="1_2"></a>1、使用官方安装脚本自动安装</h3> 
<pre><code class="prism language-bash"><span class="token function">curl</span> -fsSL https://get.docker.com <span class="token operator">|</span> <span class="token function">bash</span> -s <span class="token function">docker</span> --mirror Aliyun
</code></pre> 
<blockquote> 
 <p><mark>错误1：</mark><br>   可能会提示未安装 curl，<br> <mark>解决1：</mark><br>   按照提示安装即可，sudo apt install curl<br>   <br> <mark>错误2：</mark></p> 
 <p>  <img src="https://images2.imgbox.com/19/30/adjszgf5_o.png" alt="在这里插入图片描述"></p> 
 <p><mark>解释2：</mark><br>   弃用警告<br>   这个Linux发行版（ubuntu xenia）已经到了生命的尽头，不再受此脚本的支持。<br> <mark>解决2：</mark><br>   使用其他更高版本的ubuntu，或进行手动安装</p> 
</blockquote> 
<h3><a id="2_daocloud__20"></a>2、使用国内 daocloud 一键安装命令</h3> 
<pre><code class="prism language-bash"><span class="token function">curl</span> -sSL https://get.daocloud.io/docker <span class="token operator">|</span> <span class="token function">sh</span>
</code></pre> 
<h3><a id="3_24"></a>3、手动安装</h3> 
<h4><a id="a_25"></a>a）卸载旧版本</h4> 
<pre><code class="prism language-bash"><span class="token function">sudo</span> <span class="token function">apt-get</span> remove <span class="token function">docker</span> docker-engine docker.io containerd runc
</code></pre> 
<blockquote> 
 <ol><li>Docker 的旧版本被称为 docker，docker.io 或 docker-engine 。<br> 如果已安装，请卸载它们。</li><li>当前称为 Docker Engine-Community 软件包 docker-ce。</li></ol> 
</blockquote> 
<h4><a id="b_apt__32"></a>b）更新 apt 包索引</h4> 
<pre><code class="prism language-bash"><span class="token function">sudo</span> <span class="token function">apt-get</span> update
</code></pre> 
<h4><a id="c_apt_HTTPS_36"></a>c）安装 apt 依赖包，用于通过HTTPS来获取仓库</h4> 
<pre><code class="prism language-bash"><span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> <span class="token punctuation">\</span>
    apt-transport-https <span class="token punctuation">\</span>
    ca-certificates <span class="token punctuation">\</span>
    <span class="token function">curl</span> <span class="token punctuation">\</span>
    gnupg-agent <span class="token punctuation">\</span>
    software-properties-common
</code></pre> 
<h4><a id="d_Docker__GPG__45"></a>d）添加 Docker 的官方 GPG 密钥</h4> 
<pre><code class="prism language-bash"><span class="token function">curl</span> -fsSL http://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg <span class="token operator">|</span> <span class="token function">sudo</span> apt-key <span class="token function">add</span> -
</code></pre> 
<h4><a id="e_49"></a>e）写入软件源信息，设置稳定版仓库</h4> 
<pre><code class="prism language-bash"><span class="token function">sudo</span> add-apt-repository <span class="token punctuation">\</span>
  <span class="token string">"deb [arch=amd64] http://mirrors.aliyun.com/docker-ce/linux/ubuntu \
  <span class="token variable"><span class="token variable">$(</span>lsb_release -cs<span class="token variable">)</span></span> \
  stable"</span>
</code></pre> 
<h4><a id="f__Docker_EngineCommunity__containerd_56"></a>f）更新并安装 最新版本的 Docker Engine-Community 和 containerd</h4> 
<pre><code class="prism language-bash"><span class="token function">sudo</span> <span class="token function">apt-get</span> update
<span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> docker-ce docker-ce-cli containerd.io
</code></pre> 
<h4><a id="g_Docker__61"></a>g）测试 Docker 是否安装成功</h4> 
<pre><code class="prism language-bash"><span class="token function">sudo</span> <span class="token function">docker</span> run hello-world
</code></pre> 
<blockquote> 
 <p>打印出以下信息则安装成功:<br>   <img src="https://images2.imgbox.com/7c/bb/5zTqT8CY_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<h4><a id="h_DockerCE__67"></a>h）查找仓库中 Docker-CE 的版本</h4> 
<pre><code class="prism language-bash"><span class="token function">apt-cache</span> madison docker-ce
</code></pre> 
<blockquote> 
 <p>查找即如果如下：<br>   <img src="https://images2.imgbox.com/0a/a1/l64S2l8J_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<h4><a id="i_f__73"></a>i）安装指定版本的方式（与步骤 f 的区别）</h4> 
<pre><code class="prism language-bash"><span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> docker-ce<span class="token operator">=</span><span class="token operator">&lt;</span>VERSION_STRING<span class="token operator">&gt;</span> docker-ce-cli<span class="token operator">=</span><span class="token operator">&lt;</span>VERSION_STRING<span class="token operator">&gt;</span> containerd.io
</code></pre> 
<blockquote> 
 <p>备注：<br> &lt;VERSION_STRING&gt; - 使用第二列中的版本字符串安装特定版本<br> 例如 5:20.10.7 ~ 3-0~ubuntu-xenial</p> 
</blockquote> 
<h3><a id="4_Docker__80"></a>4、查看 Docker 版本信息</h3> 
<pre><code class="prism language-bash"><span class="token function">docker</span> version
</code></pre> 
<blockquote> 
 <p>查看结果如下：<br>   <br> <img src="https://images2.imgbox.com/01/b5/t4Td69fg_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<h3><a id="5_Docker__87"></a>5、启动与停止 Docker 服务</h3> 
<pre><code class="prism language-bash"><span class="token number">1</span>. 启动
<span class="token function">sudo</span> <span class="token function">service</span> <span class="token function">docker</span> start
<span class="token number">2</span>. 停止
<span class="token function">sudo</span> <span class="token function">service</span> <span class="token function">docker</span> stop
<span class="token number">3</span>. 重启
<span class="token function">sudo</span> <span class="token function">service</span> <span class="token function">docker</span> restart
</code></pre> 
<h3><a id="6_Docker_96"></a>6、卸载 Docker</h3> 
<blockquote> 
 <p>根据自己电脑安装情况进行卸载<br>   <img src="https://images2.imgbox.com/1e/66/nhKCWDP5_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<pre><code class="prism language-bash"><span class="token number">1</span>. 查看相关插件
dpkg -l <span class="token operator">|</span> <span class="token function">grep</span> <span class="token function">docker</span> 
<span class="token number">2</span>. 删除安装包（以下两种选择其中一个）
<span class="token function">sudo</span> <span class="token function">apt-get</span> purge docker-ce
或
<span class="token function">sudo</span> <span class="token function">apt-get</span> autoremove <span class="token function">docker</span> docker-ce docker-engine  docker.io  containerd runc
<span class="token number">3</span>. 删除镜像、容器、配置文件等内容
<span class="token function">sudo</span> <span class="token function">rm</span> -rf /var/lib/docker
<span class="token number">4</span>. <span class="token function">sudo</span> <span class="token function">rm</span> -rf /etc/systemd/system/docker.service.d<span class="token punctuation">(</span>如果存在改文件<span class="token punctuation">)</span>
</code></pre> 
<h2><a id="Win7__Docker_111"></a>二、Win7 安装 Docker</h2> 
<p>1、官方网站：<a href="https://docs.docker.com/" rel="nofollow">https://docs.docker.com/</a><br>   Docker现在主推Win10下的操作，Win7使用toolbax。（官方途径下载很慢，不推荐）<br> 2、</p> 
<h2><a id="_Docker_115"></a>三、为什么要学习 Docker</h2> 
<h3><a id="1Linux__116"></a>1、Linux 的部署形式</h3> 
<blockquote> 
 <ol><li>很久很久以前是如何部署服务器应用的：<br>   <br> <img src="https://images2.imgbox.com/3f/f0/TfiXCbDf_o.png" alt="在这里插入图片描述"></li></ol> 
 <ul><li>部署非常慢</li><li>成本非常高</li><li>资源浪费</li><li>难于迁移和扩展</li><li>可能会被限定硬件厂商<br>   </li></ul> 
 <ol start="2"><li>由于物理机的诸多问题，后来出现了虚拟机，常见的形式如下：<br>   宿主机（例如：windows笔记本） + vmware 虚拟机 + ubuntu（ISO镜像） = 得到一个可以使用的 Linux 系统<br>   在安装好的 Linux 系统上部署软件<img src="https://images2.imgbox.com/99/f8/4j4wE0zI_o.png" alt="在这里插入图片描述"></li></ol> 
 <ul><li>一台物理机可以通过 vmware 虚拟化安装多个操作系统</li><li>每个操作系统可以运行单独的App</li><li>虚拟化也是有局限性的，每一个虚拟机都是一个完整的操作系统，要分配系统资源</li><li>虚拟机多到一定程度，宿主机本身的的资源也就消耗殆尽，需要进行扩容</li></ul> 
</blockquote> 
<h3><a id="2_133"></a>2、虚拟化技术</h3> 
<p><a href="https://developer.aliyun.com/article/768343" rel="nofollow">懂了！VMware/KVM/Docker原来是这么回事儿</a></p> 
<h3><a id="3_135"></a>3、虚拟出一个隔离的程序运行环境</h3> 
<blockquote> 
 <ol><li>虚拟机中的程序说：我只是想要一个单独的执行执行环境，不需要你费那么大劲去虚拟出一个完整的计算机来。</li><li>一台物理机可能同时虚拟出10台虚拟机就已经开始感到乏力了，但同时虚拟出100个虚拟的执行环境却还是能够从容应对，这对于资源的充分利用可是有巨大的好处。</li><li>容器技术可以高效地利用硬件资源实现云服务</li></ol> 
</blockquote> 
<h3><a id="4_139"></a>4、容器技术</h3> 
<blockquote> 
 <ol><li>Docker 最初是 DotCloud 公司在法国期间发起的一个公司内部项目，后来以 Apache2.0 授权协议开源，代码在 Github 上维护。</li><li>Docker 是基于 Google 公司推出的 Golang 语言开发而来，基于 Linux 内核的 Cgroups、NameSpace，以及 Union FS 等技术，对进程进行封装隔离，属于操作系统层面的虚拟化技术。</li><li>由于隔离的进程独立于宿主机和其他隔离的进程，也称之为容器。</li><li>最初的 Docker 是基于 LXC 的，后来去除 LXC 转而使用自行开发的 Libcontainer。</li><li>Docker 被定义为开源的容器引擎，可以方便地对容器进行管理，例如：对镜像打包封装，引入 Docker Registry 对镜像统一管理。</li><li>利用 Docker 可以实现开发，测试，生产环境的部署一致性，极大地减少运维成本。</li><li>容器内的应用程序直接运行在宿主机的内核上，容器内没有自己的内核，也没有对硬件进行虚拟，因此容器比起虚拟机更为轻便。</li></ol> 
</blockquote> 
<h3><a id="5_Docker_147"></a>5、为什么要选择 Docker</h3> 
<blockquote> 
 <ol><li>Docker 更高效地利用系统资源</li></ol> 
 <ul><li>容器不需要进行硬件虚拟化以及运行一个完整操作系统的额外开销，无论是应用执行，文件存储，还是在内存消耗等方面，都比传统虚拟机更高效。</li></ul> 
 <ol start="2"><li>更快的启动时间</li></ol> 
 <ul><li>Docker 容器直接运行在宿主机的内核上，无需启动一个完整的操作系统，可以达到秒级启动。</li></ul> 
 <ol start="3"><li>一致性的环境</li></ol> 
 <ul><li>在企业里，程序从开发环境，到测试服务器，到生产环境，难以保证机器环境的一致性，极大可能出现系统依赖冲突，导致难以部署等BUG。</li><li>利用 Docker 的容器-镜像技术，提供了除了内核以外完整的运行时环境，确保了应用环境的一致性。</li></ul> 
 <ol start="4"><li>持续交付和部署</li></ol> 
 <ul><li>利用 Docker 可以制定镜像，以达到持续集成，持续交付和部署。</li><li>通过 Dockerfile 来进行镜像构建，实现系统集成测试，运维进行生产环境的部署。</li><li>且 Dockerfile 可以使镜像构建透明化，方便技术团队能够快速理解运行环境部署流程。</li></ul> 
 <ol start="5"><li>更轻松的迁移</li></ol> 
 <ul><li>Docker 可以在很多平台运行，无论是物理机，虚拟机，云端服务器等环境，运行结果都是一致的。</li></ul> 
 <ol start="6"><li>Docker 能做什么</li></ol> 
 <ul><li>可以把应用程序代码及运行依赖环境打包成镜像，最为交付介质，在各个环境部署。</li><li>可以将镜像（image）启动成为容器（container），并且提供多容器的生命周期进行管理（启、停、删）。</li><li>container 容器之间相互隔离，且每个容器可以设置资源限额。</li><li>提供轻量级虚拟化功能，容器就是在宿主机中的一个个的虚拟的空间，彼此相互隔离，完全独立。</li></ul> 
</blockquote> 
<h2><a id="Docker__166"></a>四、Docker 安装部署</h2> 
<h3><a id="1Docker__167"></a>1、Docker 引擎</h3> 
<p><img src="https://images2.imgbox.com/bd/9f/vp6uzGb9_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="2Docker_Daemon_169"></a>2、Docker Daemon</h3> 
<blockquote> 
 <p>安装使用 Docker，得先运行 Docker daemon 进程，用于管理 Docker，如：</p> 
 <ul><li>镜像 images</li><li>容器 containers</li><li>网络 network</li><li>数据卷 Data Volumes</li></ul> 
</blockquote> 
<h3><a id="3Rest__175"></a>3、Rest 接口</h3> 
<blockquote> 
 <ul><li>提供和 Daemon交互的API接口</li></ul> 
</blockquote> 
<h3><a id="4Docker_Client_177"></a>4、Docker Client</h3> 
<blockquote> 
 <ul><li>客户端使用 RESET API 和 Docker Daemon 进行访问</li></ul> 
</blockquote> 
<h3><a id="5Docker__179"></a>5、Docker 平台组成</h3> 
<blockquote> 
 <p><img src="https://images2.imgbox.com/2f/03/X5iddp2L_o.png" alt="在这里插入图片描述"></p> 
 <ol><li>Images</li></ol> 
 <ul><li>镜像是一个只读模板，用于创建容器，也可以通过 Dockerfile 文本描述镜像的内容。</li><li>镜像的概念类似于编程开发里面对象的类，从一个基类开始（基础镜像 Base Image）构建容器的过程，就是运行镜像，生成容器实例。</li><li>Docker 镜像的描述文件是 Dockerfile，包含了如下指令：<br> – FROM    ，定义基础镜像<br> – MAINTAINER，作者<br> – RUN    ，运行 Linux 命令<br> – ADD    ，添加文件/目录<br> – ENV    ，环境变量<br> – CMD    ，运行进程<br>   </li></ul> 
 <ol start="2"><li>Container</li></ol> 
 <ul><li>容器是一个镜像的运行实例，镜像 &gt; 容器</li><li>创建容器的过程：<br> a）获取镜像，如：docker pull centos，从镜像仓库拉取<br> b）使用镜像创建容器<br> c）分配文件系统，挂载一个读写层，在读写层加载镜像<br> d）分配网络/网桥接口，创建一个网络接口，让容器和宿主机通讯<br> e）容器获取 IP 地址<br> f）执行容器命令，如：/bin/bash<br> g）反馈容器启动结果<br>   </li></ul> 
 <ol start="3"><li>Registry</li></ol> 
 <ul><li>Docker 镜像需要进行管理，docker 提供 Registry 仓库，其实它也是一个容器。</li><li>可以基于该容器运行私有仓库。</li><li>也可以使用 Docker Hub 互联网公有镜像仓库。</li></ul> 
</blockquote> 
<h3><a id="6_Docker_207"></a>6、安装 Docker</h3> 
<h4><a id="a_Linux__208"></a>a）开启 Linux 内核的流量转发（暂未使用）</h4> 
<pre><code class="prism language-bash"><span class="token function">cat</span> <span class="token operator">&lt;&lt;</span><span class="token string">EOF<span class="token bash punctuation"> <span class="token operator">&gt;</span> /etc/sysctl.d/docker.conf</span>
net.bridge.bridge-nf-call-ip6tables = 1
net.bridge.bridge-nf-call-iptables = 1
net.ipv4.conf.default.rp_filter = 0
net.ipv4.conf.all.rp_filter = 0
net.ipv4.ip_forward = 1
EOF</span>
</code></pre> 
<h4><a id="b_218"></a>b）加载修改内核的参数，配置文件（暂未使用）</h4> 
<pre><code class="prism language-bash">modprobe br_netfilter <span class="token comment">#（如果直接下面的命令有错，则先执行该命令）</span>
sysctl -p /etc/sysctl.d/docker.conf
</code></pre> 
<h4><a id="c_Docker__223"></a>c）安装 Docker 参考第一章节</h4> 
<h4><a id="d_224"></a>d）镜像加速器</h4> 
<blockquote> 
 <ul><li>使用 Docker 首要操作就是获取镜像文件，默认下载是从 Docker Hub 下载，网速较慢</li><li>国内很多云服务商都提供了加速服务，阿里云加速器，Daocloud 加速器，灵雀云加速器</li></ul> 
</blockquote> 
<h4><a id="e_Docker__227"></a>e）修改 Docker 配置文件</h4> 
<pre><code class="prism language-bash"><span class="token function">sudo</span> <span class="token function">vi</span> /etc/docker/daemon.json

写入内容如下：（七牛云加速器）
<span class="token punctuation">{<!-- --></span>
	<span class="token string">"registry-mirrors"</span> <span class="token builtin class-name">:</span> <span class="token punctuation">[</span>
		<span class="token string">"https://reg-mirror.qiniu.com"</span>
	<span class="token punctuation">]</span>
<span class="token punctuation">}</span>

建议添加多个
 <span class="token punctuation">{<!-- --></span>
      <span class="token string">"registry-mirrors"</span> <span class="token builtin class-name">:</span> <span class="token punctuation">[</span>
          <span class="token string">"https://reg-mirror.qiniu.com"</span>,
          <span class="token string">"https://docker.mirrors.ustc.edu.cn/"</span>,
          <span class="token string">"https://8xpk5wnt.mirror.aliyuncs.com"</span>
     <span class="token punctuation">]</span>
<span class="token punctuation">}</span>

</code></pre> 
<h4><a id="f_248"></a>f）重新启动服务</h4> 
<pre><code class="prism language-bash"><span class="token function">sudo</span> systemctl daemon-reload
<span class="token function">sudo</span> systemctl <span class="token builtin class-name">enable</span> <span class="token function">docker</span> <span class="token comment">#（设置开启自启，看自己需求设置）</span>
<span class="token function">sudo</span> systemctl restart <span class="token function">docker</span>
</code></pre> 
<h4><a id="g_Docker__254"></a>g）查看 Docker 进程</h4> 
<pre><code class="prism language-bash"><span class="token function">ps</span> -ef <span class="token operator">|</span> <span class="token function">grep</span> <span class="token function">docker</span>
</code></pre> 
<blockquote> 
 <p>查看结果如下：<br>   <img src="https://images2.imgbox.com/12/0e/LPBHijHh_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<h4><a id="h_Docker__260"></a>h）查看 Docker 是否正确启动</h4> 
<pre><code class="prism language-bash"><span class="token function">sudo</span> <span class="token function">docker</span> version
</code></pre> 
<blockquote> 
 <p>查看结果如下：<br>   <img src="https://images2.imgbox.com/2b/5b/dumc29Vj_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<h2><a id="_Docker__266"></a>五、启动第一个 Docker 容器</h2> 
<h3><a id="1_267"></a>1、获取镜像</h3> 
<blockquote> 
 <ul><li>获取镜像是从你配置好的 Docker 镜像站中，去拉取镜像</li></ul> 
 <ol><li>先搜索镜像</li></ol> 
 <pre><code class="prism language-bash"><span class="token function">sudo</span> <span class="token function">docker</span> search nginx
</code></pre> 
 <p><img src="https://images2.imgbox.com/58/0d/WKw7qWpF_o.png" alt="在这里插入图片描述"></p> 
 <ol start="2"><li>拉取镜像</li></ol> 
 <pre><code class="prism language-bash"><span class="token function">sudo</span> pull nginx
</code></pre> 
 <p><img src="https://images2.imgbox.com/e0/9a/xZK7Xwqk_o.png" alt="在这里插入图片描述"></p> 
 <ol start="3"><li>查看本地的 Docker 镜像有哪些</li></ol> 
 <pre><code class="prism language-bash"><span class="token function">sudo</span> <span class="token function">docker</span> image <span class="token function">ls</span>
</code></pre> 
 <p><img src="https://images2.imgbox.com/c2/c9/bgzDC3xd_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<h3><a id="2_288"></a>2、运行镜像，生成容器</h3> 
<blockquote> 
 <ol><li>运行该 nginx 镜像，运行出具体的容器，然后这个容器就跑着一个 nginx 服务了</li></ol> 
 <pre><code class="prism language-bash"><span class="token comment">#docker run 参数 镜像的名字/id</span>
<span class="token comment"># -d 后台运行容器</span>
<span class="token comment">#-p 80:80 端口映射，宿主机端口:容器内端口，你访问宿主机的这个端口，也就访问到了容器内的端口</span>
<span class="token comment">#docker run 命令会返回一个容器的id</span>
<span class="token function">sudo</span> <span class="token function">docker</span> run -d -p <span class="token number">80</span>:80 nginx
</code></pre> 
 <p><img src="https://images2.imgbox.com/a3/dc/S06itQAd_o.png" alt="在这里插入图片描述"></p> 
 <ol start="2"><li>查看容器是否在运行</li></ol> 
 <pre><code class="prism language-bash"><span class="token function">sudo</span> <span class="token function">docker</span> <span class="token function">ps</span>
</code></pre> 
 <p><img src="https://images2.imgbox.com/53/0d/5YxzWzE5_o.png" alt="在这里插入图片描述"></p> 
 <ol start="3"><li> <p>此时可以访问宿主机的80端口，查看到容器内的80端口的应用是什么了<br> <img src="https://images2.imgbox.com/22/e8/ICGbXq3w_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/08/84/RdClsjsv_o.png" alt="在这里插入图片描述"></p> </li><li> <p>停止具体容器的进程</p> </li></ol> 
 <pre><code class="prism language-bash"><span class="token comment">#docker stop 容器id</span>
<span class="token function">sudo</span> <span class="token function">docker</span> stop 10b91fb6f107
</code></pre> 
 <p><img src="https://images2.imgbox.com/e3/35/8NzWm7CI_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/3b/b8/BX2QbYBh_o.png" alt="在这里插入图片描述"></p> 
 <ol start="5"><li>启动容器</li></ol> 
 <pre><code class="prism language-bash"><span class="token function">sudo</span> <span class="token function">docker</span> start 10b91fb6f107
</code></pre> 
 <ol start="6"><li>删除镜像 hello-world</li></ol> 
 <pre><code class="prism language-bash"><span class="token function">sudo</span> <span class="token function">docker</span> rmi feb5d9fea6a5
</code></pre> 
</blockquote> 
<h2><a id="Docker__325"></a>六、Docker 的生命周期</h2> 
<p><img src="https://images2.imgbox.com/50/88/Qz7WOLid_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/ae/bc/yna5HUSY_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="Docker__328"></a>七、Docker 镜像的原理</h2> 
<h3><a id="1__Docker_329"></a>1、 快速实践，使用 Docker，来切换不同的发行版，内核使用的都是宿主机的内核</h3> 
<blockquote> 
 <pre><code class="prism language-bash"><span class="token comment">#运行最新的ubuntu版本</span>
<span class="token comment">#运行容器，且进入容器内</span>
<span class="token comment"># -i 交互式命令操作</span>
<span class="token comment"># -t 开启一个终端</span>
<span class="token comment"># ba6acccedd2 镜像的id</span>
<span class="token comment"># bash 进入容器后，执行的命令</span>
<span class="token function">sudo</span> <span class="token function">docker</span> run -it ba6acccedd29 <span class="token function">bash</span>

<span class="token comment"># 退出容器</span>
<span class="token builtin class-name">exit</span>
</code></pre> 
 <p><img src="https://images2.imgbox.com/ec/26/Lfovig5T_o.png" alt="在这里插入图片描述"></p> 
 <p><img src="https://images2.imgbox.com/6e/3e/771LhJVi_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<h3><a id="2_Docker__345"></a>2、理解什么是 Docker 镜像</h3> 
<blockquote> 
 <ol><li>一个完整的 Docker 镜像可以创建出 Docker 容器的运行，</li></ol> 
 <ul><li>例如一个 centos:7.8.2003 镜像文件，我们获取的是 centos7 这个发行版本</li><li>这个镜像文件是不包含 linux 内核的</li><li>Docker的架构，镜像就是一个【发行版】的作用，你需要准备好一个 linux 内核</li><li>然后上层使用不同的【发行版】就好了，这样就可以自由使用各种发行版本系统，兼容多种环境<br> <img src="https://images2.imgbox.com/31/e4/LWT8alqX_o.png" alt="在这里插入图片描述"><img src="https://images2.imgbox.com/ed/de/3KOtIaGB_o.png" alt="在这里插入图片描述"></li></ul> 
 <ol start="2"><li>Docker 镜像的层级概念</li></ol> 
 <ul><li>如果我们想要定义一个 mysql5.6 镜像，我们会这么做</li><li>获取基础镜像，选择一个发行版平台</li><li>在 ubuntu 镜像中安装 mysql5.6 软件</li><li>导出镜像，可以命名为 mysql:5.6 镜像文件</li><li>从这个过程中，我们可以感觉出这是一层层地添加的，Docker 镜像的层级概念就出来了<br> 底层是 ubuntu 镜像，上层是 mysql 镜像，ubuntu 镜像层属于父镜像<br> <img src="https://images2.imgbox.com/92/26/367vwRBx_o.png" alt="在这里插入图片描述"></li></ul> 
 <ol start="3"><li>进入到正在运行的容器内</li></ol> 
 <pre><code class="prism language-bash"><span class="token function">sudo</span> <span class="token function">docker</span> <span class="token builtin class-name">exec</span> -it  <span class="token function">bash</span>
</code></pre> 
 <p><img src="https://images2.imgbox.com/4d/3d/dzLl5kWj_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<h3><a id="4Docker__367"></a>4、Docker 为什么分层镜像</h3> 
<blockquote> 
 <ul><li>镜像分层一大好处就是共享资源</li><li>例如有多个镜像都来自于同一个 base 镜像，那么在 docker host 只需要存储一份 base 镜像</li><li>内存里也只需要加载一份 host，即可为多个容器服务</li><li>即使多个容器共享一个 base 镜像，某个容器修改了 base 镜像的内容，例如修改 /etc/下配置文件，其他容器的 /etc/ 下的内容是不会被修改的</li><li>修改动作只限制在单个容器内，这就是容器的写入时复制特性</li></ul> 
</blockquote> 
<h3><a id="5_374"></a>5、可写的容器层</h3> 
<blockquote> 
 <ul><li>当容器启动后，一个新的可写层被加载到镜像的顶部</li><li>这一层通常被称为容器层</li><li>容器层下的都称为镜像层<br> <img src="https://images2.imgbox.com/b8/60/rSwTUVu2_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/f2/d0/YWiClkOs_o.png" alt="在这里插入图片描述"></li></ul> 
</blockquote> 
<h3><a id="6Docker__380"></a>6、Docker 镜像的内容</h3> 
<blockquote> 
 <ul><li>Docker 镜像层级管理的方式大大便捷了 Docker 镜像的分发和存储</li><li>Docker Hub 是为全世界的镜像仓库</li><li>Docker 镜像代表一个容器的文件系统内容</li><li>镜像层级技术属于联合文件系统</li><li>容器是一个动态的环境，每一层镜像里的文件都属于静态内容</li><li>Dockerfile 里的 ENV、CMD等内容都会落实到容器环境里<br> <img src="https://images2.imgbox.com/b6/20/tLw9fa8o_o.png" alt="在这里插入图片描述"></li></ul> 
</blockquote> 
<h2><a id="_388"></a>八、获取镜像</h2> 
<h3><a id="1_389"></a>1、镜像托管仓库</h3> 
<blockquote> 
 <ul><li>默认的 Docker 仓库是 dockerhub，有大量的优质镜像，以及用户自己上传的镜像</li></ul> 
</blockquote> 
<h3><a id="2_391"></a>2、搜索镜像</h3> 
<pre><code class="prism language-bash"><span class="token comment"># docker search &lt;镜像名&gt;:&lt;tag&gt;</span>
<span class="token comment"># &lt;tag&gt; 为具体的标签版本</span>
<span class="token function">sudo</span> <span class="token function">docker</span> ubuntu
</code></pre> 
<h3><a id="3_397"></a>3、查看本地的镜像文件有哪些</h3> 
<pre><code class="prism language-bash"><span class="token function">sudo</span> <span class="token function">docker</span> images
<span class="token function">sudo</span> <span class="token function">docker</span> image <span class="token function">ls</span>
</code></pre> 
<h3><a id="4_Docker__402"></a>4、下载 Docker 镜像</h3> 
<pre><code class="prism language-bash"><span class="token comment"># 默认的是 centos:lastest</span>
<span class="token function">sudo</span> <span class="token function">docker</span> pull centos
<span class="token comment"># 指定版本 centos:lastest:tag</span>
<span class="token function">sudo</span> <span class="token function">docker</span> pill centos:7.8.2003
</code></pre> 
<h4><a id="5_Docker__409"></a>5、查看 Docker 镜像的存储路径</h4> 
<pre><code class="prism language-bash"><span class="token comment"># 查看 Docker 的信息</span>
<span class="token function">sudo</span> <span class="token function">docker</span> info

<span class="token comment"># 查找路径</span>
<span class="token function">sudo</span> <span class="token function">docker</span> <span class="token operator">|</span> <span class="token function">grep</span> Root

<span class="token comment"># 路径为 : /var/lib/docker/image/overlay2/imagedb/content/sha256</span>
<span class="token comment"># 该路径下的文件为 json 数据类型</span>
<span class="token comment"># 该文件的作用是 : 记录镜像和容器的配置关系</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/ae/39/7Or9W49v_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/6d/ff/2msxAJdt_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/1e/6c/iVLy4P91_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="6_424"></a>6、使用不同的镜像，生成容器</h3> 
<pre><code class="prism language-bash"><span class="token comment"># -it - 开启一个交互式的终端</span>
<span class="token comment"># --rm - 容器退出时删除该容器</span>
<span class="token comment"># bash - 进入容器后执行的内容</span>
<span class="token function">sudo</span> <span class="token function">docker</span> run -it --rm ubuntu <span class="token function">bash</span>
</code></pre> 
<h3><a id="7_centos__431"></a>7、如何查看 centos 的标签信息</h3> 
<blockquote> 
 <p>https://hub.docker.com/_/centos</p> 
</blockquote> 
<h2><a id="_433"></a>九、查看镜像</h2> 
<h3><a id="1_434"></a>1、查看本地镜像</h3> 
<pre><code class="prism language-bash"><span class="token function">sudo</span> <span class="token function">docker</span> images

<span class="token comment"># 查看具体的镜像</span>
<span class="token function">sudo</span> <span class="token function">docker</span> images ubuntu

<span class="token comment"># 指定具体的 tag</span>
<span class="token function">sudo</span> <span class="token function">docker</span> images centos:7.8.2003

<span class="token comment"># 只列出镜像的 id</span>
<span class="token comment"># -q</span>
<span class="token comment"># --quiet</span>
<span class="token function">sudo</span> dcker images -q
<span class="token function">sudo</span> dcker images -quiet

<span class="token comment"># 按格式显示</span>
<span class="token comment"># 这是 docker 的模板语言，--format</span>
<span class="token function">sudo</span> <span class="token function">docker</span> images --format <span class="token string">"{<!-- -->{.ID}}--{<!-- -->{.Repository}}"</span>

<span class="token comment"># 以表格形式显示</span>
<span class="token function">sudo</span> <span class="token function">docker</span> images --format <span class="token string">"table {<!-- -->{.ID}}<span class="token entity" title="\t">\t</span>{<!-- -->{.Repository}}<span class="token entity" title="\t">\t</span>{<!-- -->{.Tag}}"</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/b1/4f/Z5jYpcQY_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/58/c5/EqehEjwn_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="_459"></a>十、删除镜像</h2> 
<h3><a id="1_helloworld__460"></a>1、下载一个 hello-world 镜像</h3> 
<pre><code class="prism language-bash"><span class="token function">sudo</span> <span class="token function">docker</span> hello-world
</code></pre> 
<h3><a id="2_helloworld__464"></a>2、运行 hello-world 生成容器</h3> 
<pre><code class="prism language-bash"><span class="token function">sudo</span> <span class="token function">docker</span> run hello-world
</code></pre> 
<h3><a id="3_helloworld_468"></a>3、删除 hello-world</h3> 
<pre><code class="prism language-bash"><span class="token comment"># 根据镜像的 id，名字，摘要等方式进行删除</span>
<span class="token function">sudo</span> <span class="token function">docker</span> rmi hello-world

<span class="token comment"># 指定 id 的前三位即可</span>
<span class="token function">sudo</span> <span class="token function">docker</span> rmi feb
</code></pre> 
<blockquote> 
 <p>删除结果如下：删除失败，hello-world正在被容器6959e376594a 使用</p> 
 <ul><li>被删除的镜像，不得有依赖的容器记录<img src="https://images2.imgbox.com/e9/7b/QYS7i8Dj_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/c8/b0/YUA9JFvk_o.png" alt="在这里插入图片描述"></li></ul> 
</blockquote> 
<h3><a id="4_480"></a>4、查看正在运行或运行过的容器</h3> 
<pre><code class="prism language-bash"><span class="token comment"># 查看正在运行的容器</span>
<span class="token function">sudo</span> <span class="token function">docker</span> <span class="token function">ps</span>
<span class="token comment"># 查看运行过的容器</span>
<span class="token function">sudo</span> <span class="token function">docker</span> <span class="token function">ps</span> -a
</code></pre> 
<p><img src="https://images2.imgbox.com/e7/fc/Ml6iyOXC_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="5_488"></a>5、删除容器记录</h3> 
<pre><code class="prism language-bash"><span class="token function">sudo</span> <span class="token function">docker</span> <span class="token function">rm</span> ac2abc057f9b
</code></pre> 
<p><img src="https://images2.imgbox.com/a4/16/UlUjo5mJ_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="_493"></a>十一、镜像管理</h2> 
<h3><a id="1_494"></a>1、批量删除镜像的用法（危险）</h3> 
<pre><code class="prism language-bash"><span class="token comment"># 列出所有镜像</span>
<span class="token function">sudo</span> <span class="token function">docker</span> images -a
<span class="token comment"># 列出所有镜像 id</span>
<span class="token function">sudo</span> <span class="token function">docker</span> images -aq

<span class="token comment">#删除所有镜像</span>
<span class="token function">sudo</span> rmi <span class="token variable"><span class="token variable">`</span><span class="token function">docker</span> images -aq<span class="token variable">`</span></span>
</code></pre> 
<p><img src="https://images2.imgbox.com/8e/67/TqsRV5Wk_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="2_505"></a>2、批量删除容器</h3> 
<pre><code class="prism language-bash"><span class="token function">sudo</span> <span class="token function">docker</span> <span class="token function">rm</span> <span class="token variable"><span class="token variable">`</span><span class="token function">docker</span> <span class="token function">ps</span> -aq<span class="token variable">`</span></span>
</code></pre> 
<h3><a id="3_509"></a>3、导出镜像</h3> 
<pre><code class="prism language-bash"><span class="token function">sudo</span> <span class="token function">docker</span> run -it ubuntu <span class="token function">bash</span>

<span class="token comment"># 运行默认的 ubuntu 镜像不提供 vim</span>
<span class="token comment"># 可以运行该容器后，在容器内安装 vim</span>
<span class="token comment"># 然后提交该镜像，再导出该镜像为压缩文件，可以给其他人用</span>
<span class="token comment"># 提交镜像暂时不在这里讲解</span>
<span class="token function">sudo</span> <span class="token function">docker</span> image save ubuntu <span class="token operator">&gt;</span> /home/ubuntu/myubuntu.tgz
</code></pre> 
<blockquote> 
 <p>若出现如下结果，容器内无法安装 vim，则先进行 apt-get update</p> 
 <ul><li>使用容器内默认的源下载速度很慢，可以使用 sed 指令替换源</li></ul> 
 <pre><code class="prism language-bash"><span class="token comment"># 修改 /etc/apt/sources.list 文件，</span>
<span class="token comment"># 将 http://.*security.ubuntu.com替换成http://repo.huaweicloud.com 或者阿里云源（http://mirreors.aliyun.com）</span>
<span class="token function">sed</span> -i <span class="token string">"s@http://.*archive.ubuntu.com/@http://repo.huaweicloud.com/@g"</span> /etc/apt/sources.list
<span class="token function">sed</span> -i <span class="token string">"s@http://.*security.ubuntu.com/@http://repo.huaweicloud.com/@g"</span> /etc/apt/sources.list
</code></pre> 
 <p><img src="https://images2.imgbox.com/b0/20/up0yGpej_o.png" alt="在这里插入图片描述"></p> 
 <p><img src="https://images2.imgbox.com/82/d9/I8JaN33s_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<h3><a id="4_530"></a>4、导入镜像</h3> 
<pre><code class="prism language-bash"><span class="token function">sudo</span> <span class="token function">docker</span> image load -i /home/ubuntu/myubuntu.tgz
</code></pre> 
<blockquote> 
 <p>注意：myubuntu 与 ubuntu 是一致的，直接导入只显示一个，需要先删除 ubuntu<br>   <br> <img src="https://images2.imgbox.com/e1/0e/eVhtc846_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<h3><a id="5_537"></a>5、查看镜像详细信息</h3> 
<pre><code class="prism language-bash"><span class="token comment"># 查看 docker 服务的信息</span>
<span class="token function">sudo</span> <span class="token function">docker</span> info

<span class="token comment"># 列出镜像的json信息</span>
<span class="token function">sudo</span> <span class="token function">docker</span> image inspect <span class="token operator">&lt;</span>镜像id<span class="token operator">&gt;</span>
</code></pre> 
<h2><a id="_545"></a>十一、容器管理</h2> 
<h3><a id="1___546"></a>1、创建 + 启动</h3> 
<pre><code class="prism language-bash"><span class="token comment"># 如果镜像不存在本地，则会在线去下载该镜像</span>
<span class="token function">docker</span> run <span class="token operator">&lt;</span>镜像名<span class="token operator">&gt;</span>
</code></pre> 
<blockquote> 
 <ul><li>docker run 等于创建 + 启动</li><li>注意：</li></ul> 
 <ol><li>容器内的进程必须处于前台运行状态，否则容器就会直接退出（自己部署一个容器运行，命令不得后台运行，前台运行即可）</li><li>如果容器内，什么事也没做，容器也会挂掉（容器内必须有一个进程在前台运行）</li></ol> 
</blockquote> 
<h3><a id="2_555"></a>2、运行一个挂掉的容器</h3> 
<pre><code class="prism language-bash"><span class="token comment"># 这个写法会产生容器记录，且容器内没有程序在跑，因此挂了</span>
<span class="token function">sudo</span> <span class="token function">docker</span> run ubuntu

<span class="token comment">#运行容器，且进入容器内，且在容器内执行某个命令</span>
<span class="token function">sudo</span> <span class="token function">docker</span> run -it ubuntu <span class="token function">bash</span>

<span class="token comment"># 开启一个容器，并执行某个程序（属于前台运行，会卡住一个终端）</span>
<span class="token function">sudo</span> <span class="token function">docker</span> run ubuntu <span class="token function">ping</span> www.baidu.com

<span class="token comment"># 运行一个活着的容器（docker ps 可以看到的容器）</span>
<span class="token comment"># -d - 让容器在后台跑着（针对宿主机而言）</span>
<span class="token comment"># 返回容器 id</span>
<span class="token function">sudo</span> <span class="token function">docker</span> run -d ubuntu <span class="token function">ping</span> www.baidu.com

<span class="token comment"># --rm - 容器挂掉后不产生容器记录（docker ps -a 无法看到这个容器运行过的记录）</span>
<span class="token function">sudo</span> <span class="token function">docker</span> run -d --rm ubuntu <span class="token function">ping</span> www.baidu.com

<span class="token comment"># --name - 给容器起个名字叫 pingbaidu</span>
<span class="token function">sudo</span> <span class="token function">docker</span> run -d --rm --name pingbaidu ubuntu <span class="token function">ping</span> www.baidu.com
</code></pre> 
<h3><a id="3_577"></a>3、查看容器日志的方法</h3> 
<pre><code class="prism language-bash"><span class="token comment"># 打印至今为止的日志</span>
<span class="token function">sudo</span> <span class="token function">docker</span> logs <span class="token operator">&lt;</span>容器id<span class="token operator">&gt;</span>

<span class="token comment"># 实时刷新日志</span>
<span class="token function">sudo</span> <span class="token function">docker</span> logs -f <span class="token operator">&lt;</span>容器id<span class="token operator">&gt;</span>

<span class="token comment"># 查看最新的5条日志</span>
<span class="token function">sudo</span> <span class="token function">docker</span> logs <span class="token operator">&lt;</span>容器id<span class="token operator">&gt;</span> <span class="token operator">|</span> <span class="token function">tail</span> <span class="token number">5</span>
</code></pre> 
<h3><a id="4_588"></a>4、进入容器空间内</h3> 
<pre><code class="prism language-bash"><span class="token comment"># 进入正在运行的容器</span>
<span class="token function">sudo</span> <span class="token function">docker</span> <span class="token builtin class-name">exec</span> -it <span class="token operator">&lt;</span>容器id<span class="token operator">&gt;</span> <span class="token function">bash</span>
</code></pre> 
<h3><a id="5_593"></a>5、查看容器的详细信息</h3> 
<pre><code class="prism language-bash"><span class="token function">sudo</span> <span class="token function">docker</span> container inspect <span class="token operator">&lt;</span>容器id<span class="token operator">&gt;</span>
</code></pre> 
<h3><a id="6_597"></a>6、容器的端口映射</h3> 
<pre><code class="prism language-bash"><span class="token comment"># 后台运行 nginx 容器，且起个名字，且端口映射宿主机85端口，访问到容器内的80端口</span>
<span class="token function">sudo</span> <span class="token function">docker</span> run -d --name my_ngix -p <span class="token number">85</span>:80 nginx

<span class="token comment"># 查看容器的端口转发情况</span>
<span class="token function">sudo</span> <span class="token function">docker</span> port <span class="token operator">&lt;</span>容器id<span class="token operator">&gt;</span>

<span class="token comment"># 随机端口映射</span>
<span class="token comment"># 随机访问一个宿主机的空闲端口，映射到容器内打开的端口</span>
<span class="token function">sudo</span> <span class="token function">docker</span> run -d --name my_ngix_1 -P nginx
</code></pre> 
<h3><a id="7_609"></a>7、容器的提交</h3> 
<pre><code class="prism language-bash"><span class="token comment"># 运行基础的ubuntu，在容器内安装vim，然后提交新镜像</span>
<span class="token comment"># 新镜像再运行出的容器，默认就携带vim了</span>
<span class="token function">sudo</span> <span class="token function">docker</span> commit <span class="token operator">&lt;</span>容器id<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>新的镜像名<span class="token operator">&gt;</span>
</code></pre> 
<h2><a id="Dockerfile__615"></a>十二、Dockerfile 创建镜像</h2> 
<h3><a id="1_616"></a>1、创建镜像的两个方法</h3> 
<blockquote> 
 <ol><li>手动修改容器的内容，然后 docker commit 提交容器为新的镜像</li><li>通过在 dockerfile 中定义一系列的命令和参数构成的脚本，然后这些命令应用于基础镜像，依次添加层，最终生成一个新的镜像。极大地简化了部署工作。</li></ol> 
</blockquote> 
<h3><a id="2_Dockerfile__619"></a>2、官方提供的 Dockerfile 实例</h3> 
<p><a href="https://github.com/CentOS/CentOS-Dockerfiles">https://github.com/CentOS/CentOS-Dockerfiles</a></p> 
<h3><a id="3dockerfile__621"></a>3、dockerfile 主要组成部分</h3> 
<blockquote> 
 <ol><li>基础镜像信息 FROM centos:6.8</li><li>制作镜像操作指令 RUN yum install openssh-server -y</li><li>容器启动时执行指令 CMD [“/bin/bash”]</li></ol> 
</blockquote> 
<h3><a id="4Dockerfile__625"></a>4、Dockerfile 指令</h3> 
<blockquote> 
 <ol><li>FROM - 指定基础镜像（这个镜像的妈妈是谁？）</li><li>MAINTAINER - 指定维护者信息（可以没有，告诉别人，谁负责养它？）</li><li>RUN - 在命令前加上RUN即可（你想让他干啥）</li><li>ADD - 添加宿主机的文件到容器内，会自动解压（给它点创业资金）</li><li>WORKDIR - 设置当前工作目录（我是xiaoming，今天刚化了妆）</li><li>VOLUME - 设置卷，挂载主机的目录（给它一个存放行李的地方）</li><li>EXPOSE - 指定对外端口（它要打开的门是啥）</li><li>CMD - 指定容器启动后要干的事（奔跑吧，兄弟）</li><li>COPY - 和ADD的作用是一样的，复制宿主机的文件到容器内，但不会解压</li><li>ENV 环境变量</li><li>ENTRYPOINT - 容器启动会后执行的命令</li></ol> 
</blockquote> 
<h2><a id="_Dockerfile_637"></a>十三、快速入门 Dockerfile</h2> 
<h3><a id="1_Dockerfile_nginx_docker_638"></a>1、通过 Dockerfile，构建 nginx 镜像，且运行容器后，生成的页面是"超哥带你学习docker"</h3> 
<pre><code class="prism language-bash"><span class="token comment"># 1. 创建 Dockerfile，注意文件名，必须是这个</span>
FROM nginx
RUN <span class="token builtin class-name">echo</span> <span class="token string">'&lt;meta charset=utf8&gt;超哥带你用docker运行nginx服务.'</span> <span class="token operator">&gt;</span> /usr/share/nginx/html/index.html

<span class="token comment"># 2. 构建 Dockerfile</span>
<span class="token function">sudo</span> <span class="token function">docker</span> build <span class="token builtin class-name">.</span>

<span class="token comment"># 3. 修改镜像名</span>
<span class="token function">sudo</span> <span class="token function">docker</span> tag <span class="token operator">&lt;</span>镜像id<span class="token operator">&gt;</span> my_nginx

<span class="token comment"># 4. 运行该镜像</span>
<span class="token function">sudo</span> <span class="token function">docker</span> run -d -p <span class="token number">80</span>:80 my_nginx <span class="token function">bash</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/87/f3/nDURT6hE_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/48/87/Bun2is85_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="2COPY__655"></a>2、COPY 指令用法</h3> 
<pre><code class="prism language-bash">copy chaoge.py /home

<span class="token comment"># 支持多个文件，以及通配符形式复制，语法要满足Golang的filepath.Match</span>
copy chaoge* /tmp/cc?.txt /home/

<span class="token comment"># COPY指令能够保留源文件的元数据，如权限，访问时间等等</span>
</code></pre> 
<h3><a id="3ADD__664"></a>3、ADD 指令用法</h3> 
<pre><code class="prism language-bash"><span class="token comment"># 特性和COPY基本一致，不过多了一些功能</span>
<span class="token comment"># 1. 源文件是一个URL，此时docker引擎会下载该链接，放入目标路径，且权限自动设置为600，若这不是期望结果，还得增加一层RUN指令进行调整</span>
<span class="token comment"># 2. 源文件是一个URL，且是一个压缩包，不会自动解压，也得单独用RUN指令解压</span>
<span class="token comment"># 3. 源文件是一个压缩文件，且是gzip,bzip2,xz,tar情况，ADD指令会自动解压该文件到目标路径</span>

ADD xxx.tar /home/

<span class="token comment"># Dockerfile官方更推荐使用COPY，ADD包含了更多复杂的功能，且ADD会使构建缓存失效，导致镜像构建缓慢</span>
</code></pre> 
<h3><a id="3CMD__675"></a>3、CMD 指令用法</h3> 
<pre><code class="prism language-bash"><span class="token comment"># 用法，注意是双引号</span>
CMD <span class="token punctuation">[</span><span class="token string">"参数1"</span>,<span class="token string">"参数2"</span><span class="token punctuation">]</span>
<span class="token comment"># 在指定了entrypoint指令后，用CMD指定具体参数</span>

<span class="token comment"># docker不是虚拟机，容器就是一个进程，既然是进程，那么程序在启动的时候需要指定一些运行参数，这就是CMD指令的作用</span>

<span class="token comment"># 例如centos镜像默认的CMD是/bin/bash，直接docker run -it centos会直接进入bash解释器</span>
<span class="token comment"># 也可以启动容器时候，指定参数. docker run -it centos cat /etc/os-release</span>

<span class="token comment"># CMD运行shell命令，也会被转化为shell形式</span>
<span class="token comment"># 例如</span>
CMD <span class="token builtin class-name">echo</span> <span class="token environment constant">$PATH</span>
<span class="token comment"># 会被转化为</span>
CMD <span class="token punctuation">[</span><span class="token string">"sh"</span>,<span class="token string">"-c"</span>,<span class="token string">"echo <span class="token environment constant">$PATH</span>"</span><span class="token punctuation">]</span>
</code></pre> 
<h3><a id="4_692"></a>4、容器内运行的程序</h3> 
<pre><code class="prism language-bash"><span class="token comment"># 这里要注意的是，docker不是虚拟机的概念，虚拟机里的程序运行，基本都是在后台运行，利用systemctl运行，但容器内没有后台进程的概念，必须在前台运行</span>

<span class="token comment"># 容器就是为了主进程而存在的，主进程如果退出了，容器也就失去意义，自动退出</span>

<span class="token comment"># 例如有一个经典问题</span>
CMD systemctl start nginx
<span class="token comment"># 这样的写法是错误的，容器会立即退出</span>
<span class="token comment"># 因为systemctl start nginx是希望以守护进程形式驱动nginx，且CMD命令会转化为</span>
CMD <span class="token punctuation">[</span><span class="token string">"sh"</span>,<span class="token string">"-c"</span>,<span class="token string">"systemctl start nginx"</span><span class="token punctuation">]</span>
<span class="token comment"># 这样的命令主进程是sh解释器，执行完毕后立即结束了，因此容器也就退出了。</span>
<span class="token comment"># 因此正确的做法应该是</span>
CMD <span class="token punctuation">[</span><span class="token string">"nginx"</span>, <span class="token string">"-g"</span>, <span class="token string">"daemon off"</span><span class="token punctuation">]</span>
</code></pre> 
<h3><a id="5ENTRYPOINT_707"></a>5、ENTRYPOINT</h3> 
<blockquote> 
 <p>和RUN指令一样，分为两种格式</p> 
 <ul><li>exec</li><li>shell</li></ul> 
 <p>作用和CMD一样，都是在指定容器启动程序以及参数<br> 当指定了ENTRYPOINT之后，CMD指令的语义就有了变化，而是把CMD的内容当做参数传递给ENTRYPOINT指令</p> 
</blockquote> 
<blockquote> 
 <p>实际用法</p> 
 <ol><li>准备好Dockerfile</li></ol> 
 <pre><code class="prism language-bash">FROM centos:7.8.2003
RUN <span class="token function">rpm</span> --rebuilddb <span class="token operator">&amp;&amp;</span> yum <span class="token function">install</span> epel-release -y
RUN <span class="token function">rpm</span> --rebuilddb <span class="token operator">&amp;&amp;</span> yum <span class="token function">install</span> <span class="token function">curl</span> -y
CMD <span class="token punctuation">[</span><span class="token string">"curl"</span>,<span class="token string">"-s"</span>,<span class="token string">"http://ipinfo.io/ip"</span><span class="token punctuation">]</span>
<span class="token comment"># 用法如下</span>
<span class="token function">docker</span> run my_centos <span class="token function">curl</span> -s http://ipinfo.io/ip
<span class="token comment">#</span>
<span class="token function">docker</span> run my_centos

<span class="token comment"># 2. 构建镜像</span>
<span class="token function">docker</span> build <span class="token builtin class-name">.</span>

<span class="token comment"># 3. 查看结果</span>
Successfully built 92cd201c87bc

<span class="token comment"># 4.  运行镜像，生成容器记录，没有前台运行，因此立即挂了</span>
<span class="token function">docker</span> run my_centos 

<span class="token comment"># 5. 上述运行正确，但我想再传入一个参数，该怎么办</span>
<span class="token comment"># 发现是无法直接传入参数的，该形式是覆盖镜像中的cmd</span>
<span class="token function">docker</span> run ny_centos -I

<span class="token comment"># 6. 想要正确地给容器传入一个 -I 参数该怎么办</span>
<span class="token comment"># 希望容器内能正确完整执行这个命令</span>
<span class="token function">curl</span> -s  http://ipinfo.io/ip -I

<span class="token comment"># 7. 解决办法1</span>
<span class="token comment"># 给容器传入新的完整的命令</span>

<span class="token comment"># 8. 正确的方法应该是使用 ENTRYPOINT</span>
<span class="token comment"># 修改Dockerfile如下</span>
FROM centos:7.8.2003
RUN <span class="token function">rpm</span> --rebuilddb <span class="token operator">&amp;&amp;</span> yum <span class="token function">install</span> epel-release -y
RUN <span class="token function">rpm</span> --rebuilddb <span class="token operator">&amp;&amp;</span> yum <span class="token function">install</span> <span class="token function">curl</span> -y
ENTRYPOINT <span class="token punctuation">[</span><span class="token string">"curl"</span>,<span class="token string">"-s"</span>,<span class="token string">"http://ipinfo.io/ip"</span><span class="token punctuation">]</span>
</code></pre> 
 <p><img src="https://images2.imgbox.com/b6/95/7BnZFeB8_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<h3><a id="6ARG__ENV_755"></a>6、ARG 和 ENV</h3> 
<blockquote> 
 <p>都是设置环境变量，区别在于ENV无论是在镜像构建时，还是在容器运行时，该变量都可以使用<br>   <br> ARG只用于构建镜像需要设置的变量，容器运行时消失了</p> 
 <pre><code class="prism language-bash">ENV <span class="token assign-left variable">NAME</span><span class="token operator">=</span><span class="token string">"yuchao"</span>
ENV <span class="token assign-left variable">AGE</span><span class="token operator">=</span><span class="token string">"18"</span>
ENV <span class="token assign-left variable">MYSQL_VERSION</span><span class="token operator">=</span><span class="token number">5.6</span>
RUN yun <span class="token function">install</span> mysql-<span class="token variable">$NAME</span>
<span class="token comment"># 后续所有操作，通过$NAME就可以直接获取变量值操作了，维护Dockerfile脚本时更加友好方便</span>
</code></pre> 
</blockquote> 
<h3><a id="7VOLUME_767"></a>7、VOLUME</h3> 
<blockquote> 
 <p>容器在运行时，应该保证在存储层不写入任何数据，运行在容器内产生的数据，我们推荐是挂载，写到宿主机上进行维护</p> 
 <pre><code class="prism language-bash">VOLUME /data <span class="token comment"># 将容器内的/data文件夹，在容器运行时，该目录自动挂载为匿名卷，任何向该目录中写入数据的操作，都不会被容器记录，保证容器存储层无状态理念</span>

<span class="token comment"># Dockerfile</span>
FROM centos
MAINTAINER chaoge
VOLUME <span class="token punctuation">[</span><span class="token string">"/data1"</span>,<span class="token string">"/data2"</span><span class="token punctuation">]</span>
<span class="token comment"># 该容器运行时，自动和宿主机的目录做好映射关系</span>
<span class="token function">docker</span> build <span class="token builtin class-name">.</span>
<span class="token function">docker</span> run <span class="token operator">&lt;</span>容器id<span class="token operator">&gt;</span>
<span class="token function">docker</span> inspect <span class="token operator">&lt;</span>容器id<span class="token operator">&gt;</span> <span class="token comment"># 查看映射情况</span>
</code></pre> 
</blockquote> 
<blockquote> 
 <p>容器数据挂载的方式，</p> 
 <ol><li>通过Dockerfile，指定VLUME目录</li><li>通过docker run -v参数，直接设置需要映射挂载的目录</li></ol> 
</blockquote> 
<h3><a id="8EXPOSE_785"></a>8、EXPOSE</h3> 
<blockquote> 
 <p>指定容器运行时对外提供的端口服务</p> 
 <ul><li>帮助使用该镜像的人，快速理解容器的一个端口业务</li><li></ul> 
 <pre><code class="prism language-bash"><span class="token function">docker</span> port 容器
<span class="token function">docker</span> run -p 宿主机端口:容器端口
<span class="token function">docker</span> run -P <span class="token comment"># 作用是随机宿主机端口:容器端口 </span>
</code></pre> 
</blockquote> 
<h3><a id="9WORKDIR_794"></a>9、WORKDIR</h3> 
<blockquote> 
 <p>用于在Dockerfile中，目录切换，更改工作目录</p> 
 <pre><code class="prism language-bash">WORKDIR /opt
</code></pre> 
</blockquote> 
<h3><a id="10USER_799"></a>10、USER</h3> 
<blockquote> 
 <p>用于改变环境，用于切换用户</p> 
 <pre><code class="prism language-bash"><span class="token environment constant">USER</span> root
<span class="token environment constant">USER</span> chaoge
</code></pre> 
</blockquote> 
<h2><a id="_805"></a>参考资料</h2> 
<p>1、菜鸟教程<br> <a href="https://www.runoob.com/docker/ubuntu-docker-install.html" rel="nofollow">https://www.runoob.com/docker/ubuntu-docker-install.html</a><br> 2、阿里云开发者社区<br> <a href="https://developer.aliyun.com/article/110806" rel="nofollow">Docker CE 镜像源站</a><br> <a href="https://developer.aliyun.com/article/768343" rel="nofollow">懂了！VMware/KVM/Docker原来是这么回事儿</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ca7bb9d641cc72eaed6f4b8826bef4d5/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">PyCharm如何配置Qt5开发环境</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/509577381bef70349d307aa7227d55de/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">java中实现时间戳与时间格式之间的互转</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>