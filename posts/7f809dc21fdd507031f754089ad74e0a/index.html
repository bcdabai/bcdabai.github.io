<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>死锁避免——银行家算法（Banker‘s Algorithm） - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="死锁避免——银行家算法（Banker‘s Algorithm）" />
<meta property="og:description" content="Dijkstra在1965年提出的银行家算法是著名的死锁避免算法，这个用于一个银行家给多个顾客贷款的算法可以直接用于操作系统给进程分配资源，这时只要把银行家换成操作系统，把顾客换成进程，把资金换成资源，把银行家决定是否放贷时所用的判断过程（即判断顾客是否有信誉和偿还能力）换成操作系统决定是否分配资源时所用的判断过程（即判断进程是否能及时归还资源）即可。为了描述银行家算法，下面先介绍一下系统的安全状态的概念。
一、安全序列 注意：
（1）系统在某一时刻的安全状态可能不唯一，但这不影响对系统安全性的判断。
（2）安全状态是非死锁状态，而不安全状态并不一定是死锁状态。即系统处于安全状态一定可以避免死锁，而系统处于不安全状态则仅仅可能进入死锁状态。
二、银行家算法 银行家算法的实质就是要设法保证系统动态分配资源后不进入不安全状态，以避免可能产生的死锁。即没当进程提出资源请求且系统的资源能够满足该请求时，系统将判断满足此次资源请求后系统状态是否安全，如果判断结果为安全，则给该进程分配资源，否则不分配资源，申请资源的进程将阻塞。
银行家算法的执行有个前提条件，即要求进程预先提出自己的最大资源请求，并假设系统拥有固定的资源总量。下面介绍银行家算法所用的主要的数据结构。
三、具体实例 假定操作系统中的4个进程P1、P2、P3、P4和3类资源R1、R2、R3(资源数量分别为9、3、6)，在t0时刻的资源分配情况如表2-1：
四、测试代码 #include&lt;iostream&gt; using namespace std; // p 进程数，r资源种类 int p ; int r ; int maxs[10][10]; //最大需求矩阵 int allocation[10][10]; //分配矩阵 int need[10][10]; //需求矩阵 int available[10]; //可用资源向量 int request[10]; //请求向量当前进程对各类资源的申请量,算法的入口参数 //输入函数 void infInput() { int i,j; cout&lt;&lt;&#34;请输入最大需求矩阵max\n&#34;; for(i=0; i&lt;p; i&#43;&#43;) { for(j=0; j&lt;r; j&#43;&#43;) { cin&gt;&gt;maxs[i][j]; } } cout&lt;&lt;&#34;请输入分配矩阵allocation\n&#34;; for(i=0; i&lt;p; i&#43;&#43;) { for(j=0; j&lt;r; j&#43;&#43;) { cin&gt;&gt;allocation[i][j]; } } cout&lt;&lt;&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/7f809dc21fdd507031f754089ad74e0a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-06-28T08:36:31+08:00" />
<meta property="article:modified_time" content="2021-06-28T08:36:31+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">死锁避免——银行家算法（Banker‘s Algorithm）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>Dijkstra在1965年提出的银行家算法是著名的死锁避免算法，这个用于一个银行家给多个顾客贷款的算法可以直接用于操作系统给进程分配资源，这时只要把银行家换成操作系统，把顾客换成进程，把资金换成资源，把银行家决定是否放贷时所用的判断过程（即判断顾客是否有信誉和偿还能力）换成操作系统决定是否分配资源时所用的判断过程（即判断进程是否能及时归还资源）即可。为了描述银行家算法，下面先介绍一下系统的安全状态的概念。</p> 
<h3 id="scroller-0">一、安全序列</h3> 
<p><img alt="" src="https://images2.imgbox.com/b7/3c/3DsANYt6_o.png"></p> 
<p><strong> 注意：</strong></p> 
<p>（1）系统在某一时刻的安全状态可能不唯一，但这不影响对系统安全性的判断。<br> （2）安全状态是非死锁状态，而不安全状态并不一定是死锁状态。即系统处于安全状态一定可以避免死锁，而系统处于不安全状态则仅仅可能进入死锁状态。</p> 
<p><img alt="" src="https://images2.imgbox.com/cd/14/V6PcXF7t_o.png"></p> 
<h3 id="scroller-1">二、银行家算法</h3> 
<p>银行家算法的实质就是<strong>要设法保证系统动态分配资源后不进入不安全状态，以避免可能产生的死锁。</strong>即没当进程提出资源请求且系统的资源能够满足该请求时，系统将判断满足此次资源请求后系统状态是否安全，如果判断结果为安全，则给该进程分配资源，否则不分配资源，申请资源的进程将阻塞。</p> 
<p>银行家算法的执行有个前提条件，即要求进程预先提出自己的最大资源请求，并假设系统拥有固定的资源总量。下面介绍银行家算法所用的主要的数据结构。</p> 
<p><img alt="" src="https://images2.imgbox.com/e6/6b/e7TyQQnz_o.png"></p> 
<p> <img alt="" src="https://images2.imgbox.com/9b/14/5VwSfF9P_o.png"></p> 
<p><img alt="" src="https://images2.imgbox.com/5d/d5/oVK164Lw_o.png"></p> 
<h3 id="scroller-2">三、具体实例</h3> 
<p>假定操作系统中的4个进程P1、P2、P3、P4和3类资源R1、R2、R3(资源数量分别为9、3、6)，在t0时刻的资源分配情况如表2-1：</p> 
<p><img alt="" src="https://images2.imgbox.com/90/e8/Gy2WPI08_o.png"></p> 
<p><img alt="" src="https://images2.imgbox.com/bd/3e/CNHFhT6x_o.png"></p> 
<p><img alt="" src="https://images2.imgbox.com/6b/f8/7kHcOe0z_o.png"></p> 
<p><img alt="" src="https://images2.imgbox.com/9a/68/d0K3QdpP_o.png"></p> 
<p><img alt="" src="https://images2.imgbox.com/62/1d/Z1ThPDF1_o.png"></p> 
<p><img alt="" src="https://images2.imgbox.com/6d/2f/tmSIeBZ9_o.png"></p> 
<p><img alt="" src="https://images2.imgbox.com/10/8a/gouOIe4c_o.png"></p> 
<h3 id="scroller-3">四、测试代码</h3> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;
// p 进程数，r资源种类
int p ;
int r ;
int maxs[10][10]; //最大需求矩阵
int allocation[10][10]; //分配矩阵
int need[10][10];   //需求矩阵
int available[10]; //可用资源向量
int request[10];   //请求向量当前进程对各类资源的申请量,算法的入口参数
//输入函数
void infInput()
{
    int i,j;
    cout&lt;&lt;"请输入最大需求矩阵max\n";
    for(i=0; i&lt;p; i++)
    {
        for(j=0; j&lt;r; j++)
        {
            cin&gt;&gt;maxs[i][j];
        }
    }
    cout&lt;&lt;"请输入分配矩阵allocation\n";
    for(i=0; i&lt;p; i++)
    {
        for(j=0; j&lt;r; j++)
        {
            cin&gt;&gt;allocation[i][j];
        }
    }
    cout&lt;&lt;"请输入需求矩阵need\n";
    for(i=0; i&lt;p; i++)
    {
        for(j=0; j&lt;r; j++)
        {
            cin&gt;&gt;need[i][j];
        }
    }
    cout&lt;&lt;"请输入可用资源向量available\n";
    for(i=0; i&lt;r; i++)
    {
        cin&gt;&gt;available[i];
    }
}

//比较函数
//比较进程为m中的元素全大于n中的元素返回1，否则返回0
int compare(int m[],int n[])
{
    int i;
    for(i=0; i&lt;r; i++)
    {
        if(m[i]&lt;n[i])
        {
            return 0;
        }
    }
    return 1;
}


//安全性检验函数，检测是否存在安全序列
int stest()
{
    int i,j,k,l,flag=0;
    int finish[p];
    int work[r];
    for(i=0; i&lt;p; i++)
    {
        finish[i]=0;
        //vis为1即表示available满足第i进程的资源需要
    }
    for(i=0; i&lt;r; i++)
    {
        work[i]=available[i];
    }
    cout&lt;&lt;"分配序列：\n";
    cout&lt;&lt;"            allocation            need              avilable"&lt;&lt;endl;
    for(k=0; k&lt;p; k++)
    {
        for(i=0; i&lt;p; i++)
        {
            if(finish[i]==1)
            {
                continue;
            }
            else
            {
                if(compare(work,need[i]))//available&gt;=need
                {
                    finish[i]=1;
                    cout&lt;&lt;'\n'&lt;&lt;"进程"&lt;&lt;i+1&lt;&lt;'\t';
                    flag=1;
                    for (j =0; j&lt;r; j++)
                    {
                        printf("  %2d ", allocation[i][j]);
                    }
                    cout&lt;&lt;"     ";
                    for (j = 0; j &lt; r; j++)
                    {
                        printf("  %2d ", need[i][j]);
                    }
                    cout&lt;&lt;"     ";
                    for (j = 0; j &lt;r; j++)
                    {
                        printf("  %2d ", work[j] +allocation[i][j]);
                    }
                    for(l=0; l&lt;r; l++)
                    {
                        work[l]=work[l]+allocation[i][l];
                        //进程完成，释放资源
                    }
                    break;
                }
            }
            if(flag==1)
            {
                break;
            }
        }
    }
    cout&lt;&lt;'\n';
    for(l=0; l&lt;p; l++)
    {
        if(finish[l]==0)
        {
            return 0;//不存在安全序列
        }
    }
    return 1;//存在安全序列
}

//申请进程后的安全性检验函数

void rtest(int n)
{
    int j;
    //n=n-1;
    if(compare(available,request)&amp;&amp;compare(need[n-1],request))//available&gt;=request 并且 need &gt;=request
    {
        for(j=0; j&lt;r; j++)
        {
            allocation[n-1][j]=allocation[n-1][j]+request[j];
            need[n-1][j]=need[n-1][j]-request[j];
            available[j]=available[j]-request[j];
        }
        if(stest())
        {
            cout&lt;&lt;"允许"&lt;&lt;n&lt;&lt;"进程申请资源！\n";
        }
        else
        {
            cout&lt;&lt;"不允许"&lt;&lt;n&lt;&lt;"进程申请资源！\n";
            for(j=0; j&lt;r; j++)
            {
                allocation[n-1][j]=allocation[n-1][j]-request[j];
                need[n-1][j]=need[n-1][j]+request[j];
                available[j]=available[j]+request[j];
            }
        }
    }
    else
    {
        cout&lt;&lt;"申请资源量越界！\n";
    }
}

int main()
{
    int i,n;       //n-第n个资源申请
    cout&lt;&lt;"请输入进程数：";
    cin&gt;&gt;p;
    cout&lt;&lt;"请输入资源种类数：";
    cin&gt;&gt;r;
    //默认状态4、3
    infInput();//输入函数
    if(stest()==1)
    {
        cout&lt;&lt;"存在安全序列，初始状态安全。\n";
    }
    else
    {
        cout&lt;&lt;"不存在安全序列，初始状态不安全。\n";
    }
    cout&lt;&lt;"请输入发出请求向量request的进程编号：";
    cin&gt;&gt;n;
    cout&lt;&lt;"请输入请求向量request\n";
    for(i=0; i&lt;r; i++)
    {
        cin&gt;&gt;request[i];
    }
    rtest(n);
    return 0;
}
/*
4
3
3 2 2
6 1 3
3 1 4
4 2 2
1 0 0
5 1 1
2 1 1
0 0 2
2 2 2
1 0 2
1 0 3
4 2 0
1 1 2
*/</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ffc61e4bacd1a844d66b2d5a732c474d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">重写和重载的区别</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0873cb56833b35573d19a5e895459486/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">钉钉扫条形码学习2</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>