<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Skia深入分析 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Skia深入分析" />
<meta property="og:description" content="一、渲染层级 从渲染流程上分，Skia可分为如下三个层级：
1、指令层：SkPicture、SkDeferredCanvas-&gt;SkCanvas
这一层决定需要执行哪些绘图操作，绘图操作的预变换矩阵，当前裁剪区域，绘图操作产生在哪些layer上，Layer的生成与合并。
2、解析层：SkBitmapDevice-&gt;SkDraw-&gt;SkScan、SkDraw1Glyph::Proc
这一层决定绘制方式，完成坐标变换，解析出需要绘制的形体（点/线/规整矩形）并做好抗锯齿处理，进行相关资源解析并设置好Shader。
3、渲染层：SkBlitter-&gt;SkBlitRow::Proc、SkShader::shadeSpan等
这一层进行采样（如果需要），产生实际的绘制效果，完成颜色格式适配，进行透明度混合和抖动处理（如果需要）。
二、主要类介绍 1、SkCanvas 这是复杂度超出想像的一个类。
（1）API设计
a、创建：
在Android中，主要的创建方法是由SkBitmap创建SkCanvas：
explicit SkCanvas(const SkBitmap&amp; bitmap);
这个方法是由bitmap创建一个SkBitmapDevice，再将这个SkBitmapDevice设定为SkCanvas的渲染目标。
5.0之后提供了一个快捷方法创建SkCanvas：
static SkCanvas* NewRasterDirect(const SkImageInfo&amp;, void*, size_t);
这样Android的GraphicBuffer就不需要建一个SkBitmap和它关联了，可以解除SkBitmap类和android runtime的关系（虽然如此，目前Android5.0上，还是按建SkBitmap的方法去关联GraphicBuffer）。
5.0之后引入的离屏渲染：
static SkCanvas* NewRaster(const SkImageInfo&amp;);
创建一个SkCanvas，绘制的内容需要通过readPixels去读取，仍然是CPU绘图的方式。（个人觉得这个是转入GPU硬件加速的一个比较方便的接口，不知道出于什么考虑还是用CPU绘图。）
b、状态：
矩阵状态：
矩阵决定当前绘制的几何变换
rotate、skew、scale、translate、concat
裁剪状态：
裁剪决定当前绘制的生效范围
clipRect、clipRRect、clipPath、clipRegion
保存与恢复：
save、saveLayer、saveLayerAlpha、restore
c、渲染：
大部分渲染的API都可由这三个组合而成：
drawRect（矩形/图像绘制）、drawPath（不规则图形图像绘制）和drawText（文本绘制）
d、像素的读取与写入
readPixels、writePixels
这两个API主要由device实现，考虑到不同绘图设备的异质性。
（2）MCRec状态栈
fMCStack是存储的全部状态集，fMCRec则是当前的状态。
在 save saveLayer saveLayerAlpha 时，会新建一个MCRec，在restore时，销毁栈顶的MCRec。
（代码见：SkCanvas.cpp internalSave函数，通过这段代码可以了解一下new的各种用法～。）
每个状态包括如下信息：
class SkCanvas::MCRec {
public:
int fFlags;//保存的状态标识（是否保存矩阵/裁剪/图层）
SkMatrix* fMatrix;//矩阵指针，若这个状态有独立矩阵，则指向内存（fMatrixStorage），否则用上一个MCRec的fMatrix
SkRasterClip* fRasterClip;//裁剪区域，若这个状态有独立裁剪区域，则指向内存（fRasterClip），否则继承上一个的。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/71e27a63f65d445addb34f8aa2e2bc2c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2015-05-08T18:42:16+08:00" />
<meta property="article:modified_time" content="2015-05-08T18:42:16+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Skia深入分析</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <span style="color:rgb(51,51,51); font-family:Arial; line-height:26px; font-size:24px">一、渲染层级</span> 
<br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> 
<span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">从渲染流程上分，Skia可分为如下三个层级：<br> 1、指令层：SkPicture、SkDeferredCanvas-&gt;SkCanvas<br> 这一层决定需要执行哪些绘图操作，绘图操作的预变换矩阵，当前裁剪区域，绘图操作产生在哪些layer上，Layer的生成与合并。<br> 2、解析层：SkBitmapDevice-&gt;SkDraw-&gt;SkScan、SkDraw1Glyph::Proc<br> 这一层决定绘制方式，完成坐标变换，解析出需要绘制的形体（点/线/规整矩形）并做好抗锯齿处理，进行相关资源解析并设置好Shader。<br> 3、渲染层：SkBlitter-&gt;SkBlitRow::Proc、SkShader::shadeSpan等<br> </span> 
<p><span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">这一层进行采样（如果需要），产生实际的绘制效果，完成颜色格式适配，进行透明度混合和抖动处理（如果需要）。</span></p> 
<p><span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"><img src="https://images2.imgbox.com/bf/46/iXtZV5bK_o.jpg" alt=""><br> </span></p> 
<p><span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"><span style="color:rgb(51,51,51); font-family:Arial; line-height:26px; font-size:24px">二、主要类介绍</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; line-height:26px; font-size:18px">1、SkCanvas</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">这是复杂度超出想像的一个类。<br> （1）API设计<br> a、创建：<br> 在Android中，主要的创建方法是由SkBitmap创建SkCanvas：<br> explicit SkCanvas(const SkBitmap&amp; bitmap);<br> 这个方法是由bitmap创建一个SkBitmapDevice，再将这个SkBitmapDevice设定为SkCanvas的渲染目标。<br> <br> <br> 5.0之后提供了一个快捷方法创建SkCanvas：<br> static SkCanvas* NewRasterDirect(const SkImageInfo&amp;, void*, size_t);<br> 这样Android的GraphicBuffer就不需要建一个SkBitmap和它关联了，可以解除SkBitmap类和android runtime的关系（虽然如此，目前Android5.0上，还是按建SkBitmap的方法去关联GraphicBuffer）。<br> <br> <br> 5.0之后引入的离屏渲染：<br> static SkCanvas* NewRaster(const SkImageInfo&amp;);<br> 创建一个SkCanvas，绘制的内容需要通过readPixels去读取，仍然是CPU绘图的方式。（个人觉得这个是转入GPU硬件加速的一个比较方便的接口，不知道出于什么考虑还是用CPU绘图。）<br> <br> <br> b、状态：<br> 矩阵状态：<br> 矩阵决定当前绘制的几何变换<br> rotate、skew、scale、translate、concat<br> 裁剪状态：<br> 裁剪决定当前绘制的生效范围<br> clipRect、clipRRect、clipPath、clipRegion<br> 保存与恢复：<br> save、saveLayer、saveLayerAlpha、restore<br> c、渲染：<br> 大部分渲染的API都可由这三个组合而成：<br> drawRect（矩形/图像绘制）、drawPath（不规则图形图像绘制）和drawText（文本绘制）<br> d、像素的读取与写入<br> readPixels、writePixels<br> 这两个API主要由device实现，考虑到不同绘图设备的异质性。<br> <br> <br> （2）MCRec状态栈<br> fMCStack是存储的全部状态集，fMCRec则是当前的状态。<br> 在 save saveLayer saveLayerAlpha 时，会新建一个MCRec，在restore时，销毁栈顶的MCRec。<br> （代码见：SkCanvas.cpp internalSave函数，通过这段代码可以了解一下new的各种用法～。）<br> 每个状态包括如下信息：<br> class SkCanvas::MCRec {<!-- --><br> public:<br>     int             fFlags;//保存的状态标识（是否保存矩阵/裁剪/图层）<br>     SkMatrix*       fMatrix;//矩阵指针，若这个状态有独立矩阵，则指向内存（fMatrixStorage），否则用上一个MCRec的fMatrix<br>     SkRasterClip*   fRasterClip;//裁剪区域，若这个状态有独立裁剪区域，则指向内存（fRasterClip），否则继承上一个的。<br>     SkDrawFilter*   fFilter;<br>     DeviceCM* fLayer;//这个状态所拥有的layer（需要在此MCRec销毁时回收）<br>     DeviceCM* fTopLayer;//这个状态下，所需要绘制的Layer链表。（这些Layer不一定属于此状态）<br>     ......<br> };<br> DeviceCM：图层链表，包装一个SkBaseDevice，附加一个位置偏移变化的矩阵（在saveLayer时指定的坐标）。<br> <br> <br> （3）两重循环绘制<br> 研究Skia的人，一般来说都会被一开始的两重循环弄晕一会，比如drawRect的代码：<br> <br> <br>     LOOPER_BEGIN(paint, SkDrawFilter::kRect_Type, bounds)<br> <br> <br>     while (iter.next()) {<!-- --><br>         iter.fDevice-&gt;drawRect(iter, r, looper.paint());<br>     }<br> <br> <br>     LOOPER_END<br> <br> <br> 先完全展开上面的代码：<br> AutoDrawLooper  looper(this, paint, false, bounds);<br> while (looper.next(type)) {<!-- --><br>     SkDrawIter          iter(this);<br>     while (iter.next()) {<!-- --><br>         iter.fDevice-&gt;drawRect(iter, r, looper.paint());<br>     }<br> }<br> <br> <br> 第一重循环即 AutoDrawLooper，这个next实际上是做一个后处理，在存在 SkImageFilter 的情况下，先渲染到临时Layer上，再将这个Layer做Filter处理后画到当前device上。<br> 第二重循环是SkDrawIter，这个是绘制当前状态所依附的所有Layer。<br> 一般情况下，这两重循环都可以忽略，单纯当它是走下流程就好了。<br> <br> <br> 个人认为Skia在绘制入口SkCanvas的设计并不是很好，图层、矩阵与裁剪存在一起，导致渲染任务难以剥离，后面GPU渲染和延迟渲染的引入都让人感到有些生硬。<br> </span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; line-height:26px; font-size:18px">2、SkDraw、SkBlitter</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">这两个类在后续章节还会提到，这里只简单介绍：<br> SkDraw是CPU绘图的实现入口，主要任务是做渲染准备（形状确定、几何变换、字体解析、构建图像Shader等）。<br> SkBlitter 不是单独的一个类，指代了一系列根据图像格式、是否包含Shader等区分出来的一系列子类。<br> 这一族类执行大块头的渲染任务，把像素绘制上去。</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; line-height:26px; font-size:24px">三、渲染框架设计思想分析</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">1、指令层与实现层分离<br> SkCanvas不直接执行渲染，由SkBaseDevice根据设备类型，选择渲染方法。这样虽然是同一套API，但可以用作GPU绘图、pdf绘制、存储显示列表等各种功能。在API集上做优化，避免冗余绘制，也因此成为可能（注：这个google虽然在尝试，但目前看来没有明显效果，实现起来确实也很困难）。<br> 2、图=形+色的设计思想<br> 由SkDraw和SkScan类中控制绘制的形，由SkBlitter和SkShader控制绘制的色，将绘图操作分解为形状与色彩两部分，这一点和OpenGL的顶点变换——光栅——片断着色管线相似，非常有利于扩展，各种2D图元的绘制基本上就完全支持了。<br> 3、性能调优集中化<br> 将耗时的函数抽象都抽象为proc，由一个工厂制造，便于集中对这一系列函数做优化。</span><br> </span></p> 
<p><span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"><span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"><span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">此篇讲Skia绘制图片的流程，在下一篇讲图像采样原理、混合和抖动技术</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; line-height:26px; font-size:24px">1、API用法</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">（1）drawBitmap</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">void drawBitmap(const SkBitmap&amp; bitmap, SkScalar left, SkScalar top, const SkPaint* paint = NULL);</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">将bitmap画到x,y的位置（这本身是一个平移，需要和SkCanvas中的矩阵状态叠加）。</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">（2）drawBitmapRect 和 drawBitmapRectToRect</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">void drawBitmapRect(const SkBitmap&amp; bitmap, const SkRect&amp; dst, const SkPaint* paint = NULL);</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">void drawBitmapRectToRect(const SkBitmap&amp; bitmap, const SkRect* src, const SkRect&amp; dst, const SkPaint* paint, DrawBitmapRectFlags flags);</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">将源图src矩阵部分，画到目标dst区域去。</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">最后一个flags是AndroidL上为了gpu绘制效果而加上去的，在CPU绘制中不需要关注。</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">（3）drawSprite</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">void drawSprite(const SkBitmap&amp; bitmap, int x, int y, const SkPaint* paint);</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">无视SkCanvas的矩阵状态，将bitmap平移到x,y的位置。</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">（4）drawBitmapMatrix</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">void drawBitmapMatrix(const SkBitmap&amp; bitmap, const SkMatrix&amp; matrix, const SkPaint* paint);</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">绘制的bitmap带有matrix的矩形变换，需要和SkCanvas的矩形变换叠加。</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">（5）drawRect</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">void drawRect(const SkRect&amp; r, const SkPaint&amp; paint);</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">这个是最通用的方法，多用于需要加入额外效果的场景，比如需要绘制重复纹理。关于Tile的两个参数就是OpenGL纹理贴图中水平垂直方向上的边界处理模式。</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">由这种用法，大家不难类推到非矩形图像绘制的方法，比如画圆角矩形图标、把方图片裁剪成一个圆等。</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">下面是一个Demo程序</span><br> </span></span></p> 
<p><span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"><span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"><span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">#include "SkBitmapProcShader.h"<br> #include "SkCanvas.h"<br> #include "SkBitmap.h"<br> #include "SkImageDecoder.h"<br> #include "SkImageEncoder.h"<br> #include "SkRect.h"<br> int main()<br> {<!-- --><br>     const int w = 1080;<br>     const int h = 1920;<br>     /*准备目标图片和源图片*/<br>     SkBitmap dst;<br>     dst.allocPixels(SkImageInfo::Make(w, h, kN32_SkColorType, kPremul_SkAlphaType));<br>     SkCanvas c(dst);<br> <br> <br>     SkBitmap src;<br>     SkImageDecoder::DecodeFile("test.jpg", &amp;src);<br> <br> <br>     /*各种绘制图片方法使用示例*/<br>     {<!-- --><br>         c.drawBitmap(src, 0, 0, NULL);<br>     }<br> <br> <br>     {<!-- --><br>         c.drawSprite(src, 400, 400, NULL);<br>     }<br>     {<!-- --><br>         SkRect dstR;<br>         r.set(29, 29, 100, 100);<br>         SkRect srcR;<br>         r.set(0,0,40,50);<br>         c.drawBitmapRectToRect(src, &amp;srcR, dstR, NULL);<br>     }<br>     {<!-- --><br>         SkMatrix m;<br>         m.setScale(1.4,4.3);<br>         c.drawBitmapMatrix(src, m, NULL);<br>     }<br>     {<!-- --><br>         SkRect dstRect;<br>         dstRect.set(100,100,480,920);<br>         SkPaint paint;<br>         SkMatrix m;<br>         m.setScale(3.2, 4.1);<br>         SkShader* shader = CreateBitmapShader(src, SkShader::kRepeat_TileMode, SkShader::kRepeat_TileMode, m, NULL);<br>         paint.setShader(shader);<br>         SkSafeUnref(shader);<br>         c.drawRect(dstRect, paint);<br>     }<br> <br> <br>     /*输出图片*/<br>     SkImageEncoder::EncodeFile("output.jpg", dst, SkImageEncoder::kJPEG_Type, 100);<br>     return 1;<br> }<br> </span></span></span></p> 
<p><span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"><span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"><span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"><img src="https://images2.imgbox.com/07/68/k8klXTiO_o.jpg" alt=""><br> </span></span></span></p> 
<p><span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"><span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"><span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"><span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">（1）SkCanvas两重循环调到SkBitmapDevice，进而调到SkDraw</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">在SkDraw中，drawBitmap的渲染函数统一为：</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">void SkDraw::drawBitmap(const SkBitmap&amp; bitmap, const SkMatrix&amp; prematrix, const SkPaint&amp; origPaint) const;</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">（2）Sprite简易模式</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">在满足如下条件时，走进Sprite简易模式。</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">代码见 external/skia/src/core/SkDraw.cpp drawBitmap 函数</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">a、(bitmap.colorType() != kAlpha_8_SkColorType &amp;&amp; just_translate(matrix, bitmap))</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">kAlpha_8_SkColorType 的图像只有一个通道alpha，按 drawMask 方式处理，将Paint中的颜色按图像的alpha预乘，叠加到目标区域上。</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">just_translate表示matrix为一个平移矩阵，这时不涉及旋转缩放，bitmap的像素点和SkCanvas绑定的dstBitmap的像素点此时存在连续的一一对齐关系。</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">b、clipHandlesSprite(*fRC, ix, iy, bitmap))</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">这个条件是指当前SkCanvas的裁剪区域不需要考虑抗锯齿或者完全包含了bitmap的渲染区域。SkCanvas的任何渲染都必须在裁剪区域之内，因此如果图像跨越了裁剪区域边界而且裁剪区域需要考虑抗锯齿，在边界上需要做特殊处理。</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">注：裁剪区域的设置API</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">void SkCanvas::clipRect(const SkRect&amp; rect, SkRegion::Op op, bool doAA)</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">doAA即是否在r的边界非整数时考虑抗锯齿。</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">满足条件，创建SkSpriteBlitter，由SkScan::FillIRect按每个裁剪区域调用SkSpriteBlitter的blitRect。</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">这种情况下可以直接做颜色转换和透明度合成渲染过去，不需要做抗锯齿和图像插值，也就不需要走取样——混合流程，性能是最高的。</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">满足条件后通过ChooseSprite去选一个SkSpriteBlitter</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">详细代码见 external/skia/src/core/SkBlitter_Sprite.cpp 中的 ChooseSprite 函数。</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">这函数实际上很多场景都没覆盖到，因此很可能是选不到的，这时就开始转回drawRect流程。</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">（3）创建BitmapShader</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">在  SkAutoBitmapShaderInstall install(bitmap, paint); 这一句代码中，为paint创建了bitmapShader：</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">        fPaint.setShader(CreateBitmapShader(src, SkShader::kClamp_TileMode,</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">                                            SkShader::kClamp_TileMode,</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">                                            localMatrix, &amp;fAllocator));</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">然后就可以使用drawRect画图像了。</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">（4）drawRect</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">不能使用SkSpriteBlitter的场景，走drawRect通用流程。</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">这里有非常多的分支，只讲绘制实矩形的情形。</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">通过 SkAutoBlitterChoose -&gt; SkBlitter::Choose，根据Canvas绑定的Bitmap像素模式，paint属性去选择blitter。</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">绘制图片时paint有Shader（SkBitmapProcShader），因此是选的是带Shader的Blitter，比如适应ARGB格式的 SkARGB32_Shader_Blitter</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">（5）SkScan</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">在SkScan中，对每一个裁剪区域，将其与绘制的rect求交，然后渲染这个相交区域。此外，在需要时做抗锯齿。</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">做抗锯齿的基本方法就是对浮点的坐标，按其离整数的偏离度给一个alpha权重，将颜色乘以此权重（减淡颜色）画上去。</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">SkScan中在绘制矩形时，先用blitV绘制左右边界，再用blitAntiH绘制上下边界，中间大块的不需要考虑抗锯齿，因而用blitRect。</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">（6）blitRect</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">这一步先通过 Shader的shadeSpan方法取对应位置的像素，再将此像素通过SkBlitRow的proc叠加上去。</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">如果不需要考虑混合模式，可以跳过proc。</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">参考代码：external/skia/src/core/SkBlitter_ARGB32.cpp 中的blitRect</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">（7）shadeSpan</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">这里只考虑 SkBitmapProcShader 的shadeSpan，这主要是图像采样的方法。详细代码见 external/skia/src/core/SkBitmapProcShader.cpp</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">对每一个目标点，先通过 matrixProc 取出需要参考的源图像素，然后用sampleProc将这些像素合成为一个像素值。（和OpenGL里面的texture2D函数原理很类似）。</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">若存在 shaderProc（做线性插值时，上面的步骤是可以优化的，完全可以取出一群像素一起做插值计算），以shaderProc代替上面的两步流程，起性能优化作用。</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; line-height:26px; font-size:24px">3、SkBlitter接口解析</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">（1）blitH</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">virtual void blitH(int x, int y, int width);</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">从x,y坐标开始，渲染一行width个像素</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">（2）blitV</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">virtual void blitV(int x, int y, int height, SkAlpha alpha);</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">从x,y开始，渲染一列height个像素，按alpha值对颜色做减淡处理</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">（3）blitAntiH</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">virtual void blitAntiH(int x, int y, const SkAlpha antialias[], const int16_t runs[]);</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">如流程图所标示的，这个函数的用来渲染上下边界，作抗锯齿处理。</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">（4）blitRect</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">virtual void blitRect(int x, int y, int width, int height);</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">绘制矩形区域，这个地方就不需要考虑任何的几何变换、抗锯齿等因素了。</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">（5）blitMask</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">virtual void blitMask(const SkMask&amp; mask, const SkIRect&amp; clip);</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">主要绘制文字时使用，以一个颜色乘上mash中的透明度，叠加。</span><br> </span></span></span></p> 
<p><span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"><span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"><span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"><span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"><span style="color:rgb(51,51,51); font-family:Arial; line-height:26px; font-size:24px">一、采样流程</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">我们先看一个具体的blitRect实现。</span><br> </span></span></span></span></p> 
<p><span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"><span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"><span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"><span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"><span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">void SkARGB32_Shader_Blitter::blitRect(int x, int y, int width, int height) {<!-- --><br>     SkASSERT(x &gt;= 0 &amp;&amp; y &gt;= 0 &amp;&amp;<br>              x + width &lt;= fDevice.width() &amp;&amp; y + height &lt;= fDevice.height());<br>     uint32_t*          device = fDevice.getAddr32(x, y);<br>     size_t             deviceRB = fDevice.rowBytes();<br>     SkShader::Context* shaderContext = fShaderContext;<br>     SkPMColor*         span = fBuffer;<br>     if (fConstInY) {<!-- --><br>         if (fShadeDirectlyIntoDevice) {<!-- --><br>             // shade the first row directly into the device<br>             shaderContext-&gt;shadeSpan(x, y, device, width);<br>             span = device;<br>             while (--height &gt; 0) {<!-- --><br>                 device = (uint32_t*)((char*)device + deviceRB);<br>                 memcpy(device, span, width &lt;&lt; 2);<br>             }<br>         } else {<!-- --><br>             shaderContext-&gt;shadeSpan(x, y, span, width);<br>             SkXfermode* xfer = fXfermode;<br>             if (xfer) {<!-- --><br>                 do {<!-- --><br>                     xfer-&gt;xfer32(device, span, width, NULL);<br>                     y += 1;<br>                     device = (uint32_t*)((char*)device + deviceRB);<br>                 } while (--height &gt; 0);<br>             } else {<!-- --><br>                 SkBlitRow::Proc32 proc = fProc32;<br>                 do {<!-- --><br>                     proc(device, span, width, 255);<br>                     y += 1;<br>                     device = (uint32_t*)((char*)device + deviceRB);<br>                 } while (--height &gt; 0);<br>             }<br>         }<br>         return;<br>     }<br>     if (fShadeDirectlyIntoDevice) {<!-- --><br>         void* ctx;<br>         SkShader::Context::ShadeProc shadeProc = shaderContext-&gt;asAShadeProc(&amp;ctx);<br>         if (shadeProc) {<!-- --><br>             do {<!-- --><br>                 shadeProc(ctx, x, y, device, width);<br>                 y += 1;<br>                 device = (uint32_t*)((char*)device + deviceRB);<br>             } while (--height &gt; 0);<br>         } else {<!-- --><br>             do {<!-- --><br>                 shaderContext-&gt;shadeSpan(x, y, device, width);<br>                 y += 1;<br>                 device = (uint32_t*)((char*)device + deviceRB);<br>             } while (--height &gt; 0);<br>         }<br>     } else {<!-- --><br>         SkXfermode* xfer = fXfermode;<br>         if (xfer) {<!-- --><br>             do {<!-- --><br>                 shaderContext-&gt;shadeSpan(x, y, span, width);<br>                 xfer-&gt;xfer32(device, span, width, NULL);<br>                 y += 1;<br>                 device = (uint32_t*)((char*)device + deviceRB);<br>             } while (--height &gt; 0);<br>         } else {<!-- --><br>             SkBlitRow::Proc32 proc = fProc32;<br>             do {<!-- --><br>                 shaderContext-&gt;shadeSpan(x, y, span, width);<br>                 proc(device, span, width, 255);<br>                 y += 1;<br>                 device = (uint32_t*)((char*)device + deviceRB);<br>             } while (--height &gt; 0);<br>         }<br>     }<br> }<br> </span></span></span></span></span></p> 
<p><span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"><span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">其中shadeSpan用来将shader中x，y坐标处的值取n个到dst的buffer中。</span></span><span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">对于图像绘制时，它是 SkBitmapProcShader，这里是其实现：</span><span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"><span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"><br> </span>void SkBitmapProcShader::BitmapProcShaderContext::shadeSpan(int x, int y, SkPMColor dstC[],<br>                                                             int count) {<!-- --><br>     const SkBitmapProcState&amp; state = *fState;<br>     if (state.getShaderProc32()) {<!-- --><br>         state.getShaderProc32()(state, x, y, dstC, count);<br>         return;<br>     }<br> <br> <br>     uint32_t buffer[BUF_MAX + TEST_BUFFER_EXTRA];<br>     SkBitmapProcState::MatrixProc   mproc = state.getMatrixProc();<br>     SkBitmapProcState::SampleProc32 sproc = state.getSampleProc32();<br>     int max = state.maxCountForBufferSize(sizeof(buffer[0]) * BUF_MAX);<br> <br> <br>     SkASSERT(state.fBitmap-&gt;getPixels());<br>     SkASSERT(state.fBitmap-&gt;pixelRef() == NULL ||<br>              state.fBitmap-&gt;pixelRef()-&gt;isLocked());<br> <br> <br>     for (;;) {<!-- --><br>         int n = count;<br>         if (n &gt; max) {<!-- --><br>             n = max;<br>         }<br>         SkASSERT(n &gt; 0 &amp;&amp; n &lt; BUF_MAX*2);<br> #ifdef TEST_BUFFER_OVERRITE<br>         for (int i = 0; i &lt; TEST_BUFFER_EXTRA; i++) {<!-- --><br>             buffer[BUF_MAX + i] = TEST_PATTERN;<br>         }<br> #endif<br>         mproc(state, buffer, n, x, y);<br> #ifdef TEST_BUFFER_OVERRITE<br>         for (int j = 0; j &lt; TEST_BUFFER_EXTRA; j++) {<!-- --><br>             SkASSERT(buffer[BUF_MAX + j] == TEST_PATTERN);<br>         }<br> #endif<br>         sproc(state, buffer, n, dstC);<br> <br> <br>         if ((count -= n) == 0) {<!-- --><br>             break;<br>         }<br>         SkASSERT(count &gt; 0);<br>         x += n;<br>         dstC += n;<br>     }<br> }<br> </span></p> 
<p><span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"><span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">流程如下：<br> 1、存在 shaderProc，直接用<br> 2、计算一次能处理的像素数count<br> 3、mproc计算count个坐标，sproc根据坐标值去取色<br> 注意到之前三个函数指针：<br> state.getShaderProc32<br> mproc = state.getMatrixProc<br> sproc = state.getShaderProc32<br> 这三个函数指针在一开始创建blitter时设定：<br> </span><span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"></span></span></p> 
<p style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> SkBlitter::Choose -&gt; SkShader::createContext -&gt; SkBitmapProcShader::onCreateContext -&gt; SkBitmapProcState::chooseProcs</p> 
<p style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <br> </p> 
<span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">这是一个相当长的函数，它做的事情如下：<br> 1、（优化步骤）在大于SkPaint::kLow_FilterLevel的质量要求下，试图做预缩放。<br> 2、选择matrix函数：chooseMatrixProc。<br> 3、选择sample函数：<br> （1）高质量：setBitmapFilterProcs<br> （2）kLow_FilterLevel或kNone_FilterLevel：采取flags计算的方法,根据x,y变化矩阵情况和采样要求选择函数<br> 4、（优化步骤）在满足条件时，选取shader函数，此函数替代matrix和sample函数<br> 5、（优化步骤）platformProcs()，进一步选择优化版本的sample函数<br> 对于RGB565格式的目标，使用的是SkShader的 shadeSpan16 方法。shadeSpan16的代码逻辑类似，不再说明。</span> 
<br> 
<p><span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">bool SkBitmapProcState::chooseProcs(const SkMatrix&amp; inv, const SkPaint&amp; paint) {<!-- --><br>     SkASSERT(fOrigBitmap.width() &amp;&amp; fOrigBitmap.height());<br>     fBitmap = NULL;<br>     fInvMatrix = inv;<br>     fFilterLevel = paint.getFilterLevel();<br>     SkASSERT(NULL == fScaledCacheID);<br>     // possiblyScaleImage will look to see if it can rescale the image as a<br>     // preprocess; either by scaling up to the target size, or by selecting<br>     // a nearby mipmap level.  If it does, it will adjust the working<br>     // matrix as well as the working bitmap.  It may also adjust the filter<br>     // quality to avoid re-filtering an already perfectly scaled image.<br>     if (!this-&gt;possiblyScaleImage()) {<!-- --><br>         if (!this-&gt;lockBaseBitmap()) {<!-- --><br>             return false;<br>         }<br>     }<br>     // The above logic should have always assigned fBitmap, but in case it<br>     // didn't, we check for that now...<br>     // TODO(dominikg): Ask humper@ if we can just use an SkASSERT(fBitmap)?<br>     if (NULL == fBitmap) {<!-- --><br>         return false;<br>     }<br>     // If we are "still" kMedium_FilterLevel, then the request was not fulfilled by possiblyScale,<br>     // so we downgrade to kLow (so the rest of the sniffing code can assume that)<br>     if (SkPaint::kMedium_FilterLevel == fFilterLevel) {<!-- --><br>         fFilterLevel = SkPaint::kLow_FilterLevel;<br>     }<br>     bool trivialMatrix = (fInvMatrix.getType() &amp; ~SkMatrix::kTranslate_Mask) == 0;<br>     bool clampClamp = SkShader::kClamp_TileMode == fTileModeX &amp;&amp;<br>                       SkShader::kClamp_TileMode == fTileModeY;<br>     if (!(clampClamp || trivialMatrix)) {<!-- --><br>         fInvMatrix.postIDiv(fOrigBitmap.width(), fOrigBitmap.height());<br>     }<br>     // Now that all possible changes to the matrix have taken place, check<br>     // to see if we're really close to a no-scale matrix.  If so, explicitly<br>     // set it to be so.  Subsequent code may inspect this matrix to choose<br>     // a faster path in this case.<br>     // This code will only execute if the matrix has some scale component;<br>     // if it's already pure translate then we won't do this inversion.<br>     if (matrix_only_scale_translate(fInvMatrix)) {<!-- --><br>         SkMatrix forward;<br>         if (fInvMatrix.invert(&amp;forward)) {<!-- --><br>             if (clampClamp ? just_trans_clamp(forward, *fBitmap)<br>                             : just_trans_general(forward)) {<!-- --><br>                 SkScalar tx = -SkScalarRoundToScalar(forward.getTranslateX());<br>                 SkScalar ty = -SkScalarRoundToScalar(forward.getTranslateY());<br>                 fInvMatrix.setTranslate(tx, ty);<br>             }<br>         }<br>     }<br>     fInvProc        = fInvMatrix.getMapXYProc();<br>     fInvType        = fInvMatrix.getType();<br>     fInvSx          = SkScalarToFixed(fInvMatrix.getScaleX());<br>     fInvSxFractionalInt = SkScalarToFractionalInt(fInvMatrix.getScaleX());<br>     fInvKy          = SkScalarToFixed(fInvMatrix.getSkewY());<br>     fInvKyFractionalInt = SkScalarToFractionalInt(fInvMatrix.getSkewY());<br>     fAlphaScale = SkAlpha255To256(paint.getAlpha());<br>     fShaderProc32 = NULL;<br>     fShaderProc16 = NULL;<br>     fSampleProc32 = NULL;<br>     fSampleProc16 = NULL;<br>     // recompute the triviality of the matrix here because we may have<br>     // changed it!<br> <br> <br>     trivialMatrix = (fInvMatrix.getType() &amp; ~SkMatrix::kTranslate_Mask) == 0;<br> <br> <br>     if (SkPaint::kHigh_FilterLevel == fFilterLevel) {<!-- --><br>         // If this is still set, that means we wanted HQ sampling<br>         // but couldn't do it as a preprocess.  Let's try to install<br>         // the scanline version of the HQ sampler.  If that process fails,<br>         // downgrade to bilerp.<br> <br> <br>         // NOTE: Might need to be careful here in the future when we want<br>         // to have the platform proc have a shot at this; it's possible that<br>         // the chooseBitmapFilterProc will fail to install a shader but a<br>         // platform-specific one might succeed, so it might be premature here<br>         // to fall back to bilerp.  This needs thought.<br> <br> <br>         if (!this-&gt;setBitmapFilterProcs()) {<!-- --><br>             fFilterLevel = SkPaint::kLow_FilterLevel;<br>         }<br>     }<br> <br> <br>     if (SkPaint::kLow_FilterLevel == fFilterLevel) {<!-- --><br>         // Only try bilerp if the matrix is "interesting" and<br>         // the image has a suitable size.<br> <br> <br>         if (fInvType &lt;= SkMatrix::kTranslate_Mask ||<br>                 !valid_for_filtering(fBitmap-&gt;width() | fBitmap-&gt;height())) {<!-- --><br>             fFilterLevel = SkPaint::kNone_FilterLevel;<br>         }<br>     }<br> <br> <br>     // At this point, we know exactly what kind of sampling the per-scanline<br>     // shader will perform.<br> <br> <br>     fMatrixProc = this-&gt;chooseMatrixProc(trivialMatrix);<br>     // TODO(dominikg): SkASSERT(fMatrixProc) instead? chooseMatrixProc never returns NULL.<br>     if (NULL == fMatrixProc) {<!-- --><br>         return false;<br>     }<br> <br> <br>     ///<br> <br> <br>     // No need to do this if we're doing HQ sampling; if filter quality is<br>     // still set to HQ by the time we get here, then we must have installed<br>     // the shader procs above and can skip all this.<br> <br> <br>     if (fFilterLevel &lt; SkPaint::kHigh_FilterLevel) {<!-- --><br> <br> <br>         int index = 0;<br>         if (fAlphaScale &lt; 256) {  // note: this distinction is not used for D16<br>             index |= 1;<br>         }<br>         if (fInvType &lt;= (SkMatrix::kTranslate_Mask | SkMatrix::kScale_Mask)) {<!-- --><br>             index |= 2;<br>         }<br>         if (fFilterLevel &gt; SkPaint::kNone_FilterLevel) {<!-- --><br>             index |= 4;<br>         }<br>         // bits 3,4,5 encoding the source bitmap format<br>         switch (fBitmap-&gt;colorType()) {<!-- --><br>             case kN32_SkColorType:<br>                 index |= 0;<br>                 break;<br>             case kRGB_565_SkColorType:<br>                 index |= 8;<br>                 break;<br>             case kIndex_8_SkColorType:<br>                 index |= 16;<br>                 break;<br>             case kARGB_4444_SkColorType:<br>                 index |= 24;<br>                 break;<br>             case kAlpha_8_SkColorType:<br>                 index |= 32;<br>                 fPaintPMColor = SkPreMultiplyColor(paint.getColor());<br>                 break;<br>             default:<br>                 // TODO(dominikg): Should we ever get here? SkASSERT(false) instead?<br>                 return false;<br>         }<br> <br> <br>     #if !SK_ARM_NEON_IS_ALWAYS<br>         static const SampleProc32 gSkBitmapProcStateSample32[] = {<!-- --><br>             S32_opaque_D32_nofilter_DXDY,<br>             S32_alpha_D32_nofilter_DXDY,<br>             S32_opaque_D32_nofilter_DX,<br>             S32_alpha_D32_nofilter_DX,<br>             S32_opaque_D32_filter_DXDY,<br>             S32_alpha_D32_filter_DXDY,<br>             S32_opaque_D32_filter_DX,<br>             S32_alpha_D32_filter_DX,<br> <br> <br>             S16_opaque_D32_nofilter_DXDY,<br>             S16_alpha_D32_nofilter_DXDY,<br>             S16_opaque_D32_nofilter_DX,<br>             S16_alpha_D32_nofilter_DX,<br>             S16_opaque_D32_filter_DXDY,<br>             S16_alpha_D32_filter_DXDY,<br>             S16_opaque_D32_filter_DX,<br>             S16_alpha_D32_filter_DX,<br> <br> <br>             SI8_opaque_D32_nofilter_DXDY,<br>             SI8_alpha_D32_nofilter_DXDY,<br>             SI8_opaque_D32_nofilter_DX,<br>             SI8_alpha_D32_nofilter_DX,<br>             SI8_opaque_D32_filter_DXDY,<br>             SI8_alpha_D32_filter_DXDY,<br>             SI8_opaque_D32_filter_DX,<br>             SI8_alpha_D32_filter_DX,<br> <br> <br>             S4444_opaque_D32_nofilter_DXDY,<br>             S4444_alpha_D32_nofilter_DXDY,<br>             S4444_opaque_D32_nofilter_DX,<br>             S4444_alpha_D32_nofilter_DX,<br>             S4444_opaque_D32_filter_DXDY,<br>             S4444_alpha_D32_filter_DXDY,<br>             S4444_opaque_D32_filter_DX,<br>             S4444_alpha_D32_filter_DX,<br> <br> <br>             // A8 treats alpha/opaque the same (equally efficient)<br>             SA8_alpha_D32_nofilter_DXDY,<br>             SA8_alpha_D32_nofilter_DXDY,<br>             SA8_alpha_D32_nofilter_DX,<br>             SA8_alpha_D32_nofilter_DX,<br>             SA8_alpha_D32_filter_DXDY,<br>             SA8_alpha_D32_filter_DXDY,<br>             SA8_alpha_D32_filter_DX,<br>             SA8_alpha_D32_filter_DX<br>         };<br> <br> <br>         static const SampleProc16 gSkBitmapProcStateSample16[] = {<!-- --><br>             S32_D16_nofilter_DXDY,<br>             S32_D16_nofilter_DX,<br>             S32_D16_filter_DXDY,<br>             S32_D16_filter_DX,<br> <br> <br>             S16_D16_nofilter_DXDY,<br>             S16_D16_nofilter_DX,<br>             S16_D16_filter_DXDY,<br>             S16_D16_filter_DX,<br> <br> <br>             SI8_D16_nofilter_DXDY,<br>             SI8_D16_nofilter_DX,<br>             SI8_D16_filter_DXDY,<br>             SI8_D16_filter_DX,<br> <br> <br>             // Don't support 4444 -&gt; 565<br>             NULL, NULL, NULL, NULL,<br>             // Don't support A8 -&gt; 565<br>             NULL, NULL, NULL, NULL<br>         };<br>     #endif<br> <br> <br>         fSampleProc32 = SK_ARM_NEON_WRAP(gSkBitmapProcStateSample32)[index];<br>         index &gt;&gt;= 1;    // shift away any opaque/alpha distinction<br>         fSampleProc16 = SK_ARM_NEON_WRAP(gSkBitmapProcStateSample16)[index];<br> <br> <br>         // our special-case shaderprocs<br>         if (SK_ARM_NEON_WRAP(S16_D16_filter_DX) == fSampleProc16) {<!-- --><br>             if (clampClamp) {<!-- --><br>                 fShaderProc16 = SK_ARM_NEON_WRAP(Clamp_S16_D16_filter_DX_shaderproc);<br>             } else if (SkShader::kRepeat_TileMode == fTileModeX &amp;&amp;<br>                        SkShader::kRepeat_TileMode == fTileModeY) {<!-- --><br>                 fShaderProc16 = SK_ARM_NEON_WRAP(Repeat_S16_D16_filter_DX_shaderproc);<br>             }<br>         } else if (SK_ARM_NEON_WRAP(SI8_opaque_D32_filter_DX) == fSampleProc32 &amp;&amp; clampClamp) {<!-- --><br>             fShaderProc32 = SK_ARM_NEON_WRAP(Clamp_SI8_opaque_D32_filter_DX_shaderproc);<br>         }<br> <br> <br>         if (NULL == fShaderProc32) {<!-- --><br>             fShaderProc32 = this-&gt;chooseShaderProc32();<br>         }<br>     }<br>     // see if our platform has any accelerated overrides<br>     this-&gt;platformProcs();<br>     return true;<br> }<br> </span></p> 
<p><span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"><span style="color:rgb(51,51,51); font-family:Arial; line-height:26px; font-size:24px">二、MatrixProc和SampleProc</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">MatrixProc的使命是生成坐标集。SampleProc则根据坐标集取像素，采样合成<br> 我们先倒过来看 sampleProc 看这个坐标集是怎么使用的：<br> nofilter_dx系列：</span><br> </span></p> 
<p><span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"><span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">void MAKENAME(_nofilter_DXDY)(const SkBitmapProcState&amp; s,<br>         const uint32_t* SK_RESTRICT xy,<br>         int count, DSTTYPE* SK_RESTRICT colors) {<!-- --><br>     for (int i = (count &gt;&gt; 1); i &gt; 0; --i) {<!-- --><br>         XY = *xy++;<br>         SkASSERT((XY &gt;&gt; 16) &lt; (unsigned)s.fBitmap-&gt;height() &amp;&amp;<br>                 (XY &amp; 0xFFFF) &lt; (unsigned)s.fBitmap-&gt;width());<br>         src = ((const SRCTYPE*)(srcAddr + (XY &gt;&gt; 16) * rb))[XY &amp; 0xFFFF];<br>         *colors++ = RETURNDST(src);<br> <br> <br>         XY = *xy++;<br>         SkASSERT((XY &gt;&gt; 16) &lt; (unsigned)s.fBitmap-&gt;height() &amp;&amp;<br>                 (XY &amp; 0xFFFF) &lt; (unsigned)s.fBitmap-&gt;width());<br>         src = ((const SRCTYPE*)(srcAddr + (XY &gt;&gt; 16) * rb))[XY &amp; 0xFFFF];<br>         *colors++ = RETURNDST(src);<br>     }<br>     if (count &amp; 1) {<!-- --><br>         XY = *xy++;<br>         SkASSERT((XY &gt;&gt; 16) &lt; (unsigned)s.fBitmap-&gt;height() &amp;&amp;<br>                 (XY &amp; 0xFFFF) &lt; (unsigned)s.fBitmap-&gt;width());<br>         src = ((const SRCTYPE*)(srcAddr + (XY &gt;&gt; 16) * rb))[XY &amp; 0xFFFF];<br>         *colors++ = RETURNDST(src);<br>     }<br> }<br> </span></span></p> 
<p><span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"><span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"><span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">这两个系列是直接取了x,y坐标处的图像像素<br> filter_dx系列：<br> </span><span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"></span></span></span></p> 
<p style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> filter_dxdy系列：</p> void MAKENAME(_filter_DX)(const SkBitmapProcState&amp; s, 
<br>                           const uint32_t* SK_RESTRICT xy, 
<br>                            int count, DSTTYPE* SK_RESTRICT colors) { 
<br>     SkASSERT(count &gt; 0 &amp;&amp; colors != NULL); 
<br>     SkASSERT(s.fFilterLevel != SkPaint::kNone_FilterLevel); 
<br>     SkDEBUGCODE(CHECKSTATE(s);) 
<br> 
<br> 
<br> #ifdef PREAMBLE 
<br>     PREAMBLE(s); 
<br> #endif 
<br>     const char* SK_RESTRICT srcAddr = (const char*)s.fBitmap-&gt;getPixels(); 
<br>     size_t rb = s.fBitmap-&gt;rowBytes(); 
<br>     unsigned subY; 
<br>     const SRCTYPE* SK_RESTRICT row0; 
<br>     const SRCTYPE* SK_RESTRICT row1; 
<br> 
<br> 
<br>     // setup row ptrs and update proc_table 
<br>     { 
<br>         uint32_t XY = *xy++; 
<br>         unsigned y0 = XY &gt;&gt; 14; 
<br>         row0 = (const SRCTYPE*)(srcAddr + (y0 &gt;&gt; 4) * rb); 
<br>         row1 = (const SRCTYPE*)(srcAddr + (XY &amp; 0x3FFF) * rb); 
<br>         subY = y0 &amp; 0xF; 
<br>     } 
<br> 
<br> 
<br>     do { 
<br>         uint32_t XX = *xy++;    // x0:14 | 4 | x1:14 
<br>         unsigned x0 = XX &gt;&gt; 14; 
<br>         unsigned x1 = XX &amp; 0x3FFF; 
<br>         unsigned subX = x0 &amp; 0xF; 
<br>         x0 &gt;&gt;= 4; 
<br> 
<br> 
<br>         FILTER_PROC(subX, subY, 
<br>                     SRC_TO_FILTER(row0[x0]), 
<br>                     SRC_TO_FILTER(row0[x1]), 
<br>                     SRC_TO_FILTER(row1[x0]), 
<br>                     SRC_TO_FILTER(row1[x1]), 
<br>                     colors); 
<br>         colors += 1; 
<br> 
<br> 
<br>     } while (--count != 0); 
<br> 
<br> 
<br> #ifdef POSTAMBLE 
<br>     POSTAMBLE(s); 
<br> #endif 
<br> } 
<br> void MAKENAME(_filter_DXDY)(const SkBitmapProcState&amp; s, 
<br>                             const uint32_t* SK_RESTRICT xy, 
<br>                             int count, DSTTYPE* SK_RESTRICT colors) { 
<br>     SkASSERT(count &gt; 0 &amp;&amp; colors != NULL); 
<br>     SkASSERT(s.fFilterLevel != SkPaint::kNone_FilterLevel); 
<br>     SkDEBUGCODE(CHECKSTATE(s);) 
<br> 
<br> 
<br> #ifdef PREAMBLE 
<br>         PREAMBLE(s); 
<br> #endif 
<br>     const char* SK_RESTRICT srcAddr = (const char*)s.fBitmap-&gt;getPixels(); 
<br>     size_t rb = s.fBitmap-&gt;rowBytes(); 
<br> 
<br> 
<br>     do { 
<br>         uint32_t data = *xy++; 
<br>         unsigned y0 = data &gt;&gt; 14; 
<br>         unsigned y1 = data &amp; 0x3FFF; 
<br>         unsigned subY = y0 &amp; 0xF; 
<br>         y0 &gt;&gt;= 4; 
<br> 
<br> 
<br>         data = *xy++; 
<br>         unsigned x0 = data &gt;&gt; 14; 
<br>         unsigned x1 = data &amp; 0x3FFF; 
<br>         unsigned subX = x0 &amp; 0xF; 
<br>         x0 &gt;&gt;= 4; 
<br> 
<br> 
<br>         const SRCTYPE* SK_RESTRICT row0 = (const SRCTYPE*)(srcAddr + y0 * rb); 
<br>         const SRCTYPE* SK_RESTRICT row1 = (const SRCTYPE*)(srcAddr + y1 * rb); 
<br> 
<br> 
<br>         FILTER_PROC(subX, subY, 
<br>                     SRC_TO_FILTER(row0[x0]), 
<br>                     SRC_TO_FILTER(row0[x1]), 
<br>                     SRC_TO_FILTER(row1[x0]), 
<br>                     SRC_TO_FILTER(row1[x1]), 
<br>                     colors); 
<br>         colors += 1; 
<br>     } while (--count != 0); 
<br> 
<br> 
<br> #ifdef POSTAMBLE 
<br>     POSTAMBLE(s); 
<br> #endif 
<br> } 
<br> 
<p><span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"><span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"><span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">将四个相邻像素取出来之后，作Filter处理</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">看晕了么，其实总结一下是这样：</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">nofilter_dx，第一个32位数表示y，其余的32位数包含两个x坐标。</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">nofilter_dxdy，用16位表示x，16位表示y。这种情况就是取的最近值，直接到x,y坐标处取值就可以了。</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">filter_dxdy系列，每个32位数分别表示X和Y坐标（14:4:14），交错排列，中间的差值部分是相差的小数扩大16倍而得的近似整数。</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">filter_dx系列，第一个数为Y坐标用14:4:14的方式存储，后面的数为X坐标，也用14:4:14的方式存储，前后为对应坐标，中间为放大16倍的距离，这个情况是一行之内y坐标相同（只做缩放或小数平移的情况），一样是作双线性插值。</span><br> </span></span></p> 
<p><span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"><span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"><span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"><img src="https://images2.imgbox.com/dc/11/x9LAd0Lv_o.jpg" alt=""><br> </span></span></span></p> 
<p><span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"><span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"><span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"><span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">下面我们来看matrixproc的实现，<br> </span><span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"></span></span></span></span></p> 
<p style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> 先跟进 chooseMatrixProc的代码：</p> SkBitmapProcState::MatrixProc SkBitmapProcState::chooseMatrixProc(bool trivial_matrix) { 
<br> //    test_int_tileprocs(); 
<br>     // check for our special case when there is no scale/affine/perspective 
<br>     if (trivial_matrix) { 
<br>         SkASSERT(SkPaint::kNone_FilterLevel == fFilterLevel); 
<br>         fIntTileProcY = choose_int_tile_proc(fTileModeY); 
<br>         switch (fTileModeX) { 
<br>             case SkShader::kClamp_TileMode: 
<br>                 return clampx_nofilter_trans; 
<br>             case SkShader::kRepeat_TileMode: 
<br>                 return repeatx_nofilter_trans; 
<br>             case SkShader::kMirror_TileMode: 
<br>                 return mirrorx_nofilter_trans; 
<br>         } 
<br>     } 
<br> 
<br> 
<br>     int index = 0; 
<br>     if (fFilterLevel != SkPaint::kNone_FilterLevel) { 
<br>         index = 1; 
<br>     } 
<br>     if (fInvType &amp; SkMatrix::kPerspective_Mask) { 
<br>         index += 4; 
<br>     } else if (fInvType &amp; SkMatrix::kAffine_Mask) { 
<br>         index += 2; 
<br>     } 
<br> 
<br> 
<br>     if (SkShader::kClamp_TileMode == fTileModeX &amp;&amp; SkShader::kClamp_TileMode == fTileModeY) { 
<br>         // clamp gets special version of filterOne 
<br>         fFilterOneX = SK_Fixed1; 
<br>         fFilterOneY = SK_Fixed1; 
<br>         return SK_ARM_NEON_WRAP(ClampX_ClampY_Procs)[index]; 
<br>     } 
<br> 
<br> 
<br>     // all remaining procs use this form for filterOne 
<br>     fFilterOneX = SK_Fixed1 / fBitmap-&gt;width(); 
<br>     fFilterOneY = SK_Fixed1 / fBitmap-&gt;height(); 
<br> 
<br> 
<br>     if (SkShader::kRepeat_TileMode == fTileModeX &amp;&amp; SkShader::kRepeat_TileMode == fTileModeY) { 
<br>         return SK_ARM_NEON_WRAP(RepeatX_RepeatY_Procs)[index]; 
<br>     } 
<br> 
<br> 
<br>     fTileProcX = choose_tile_proc(fTileModeX); 
<br>     fTileProcY = choose_tile_proc(fTileModeY); 
<br>     fTileLowBitsProcX = choose_tile_lowbits_proc(fTileModeX); 
<br>     fTileLowBitsProcY = choose_tile_lowbits_proc(fTileModeY); 
<br>     return GeneralXY_Procs[index]; 
<br> } 
<br> 
<p><span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"><span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"><span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"><span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">有些函数是找符号找不到的，我们注意到SkBitmapProcState.cpp 中包含了多次 SkBitmapProcState_matrix.h 头文件：</span><br> </span></span></span></p> 
<p><span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">#if !SK_ARM_NEON_IS_ALWAYS<br> #define MAKENAME(suffix)        ClampX_ClampY ## suffix<br> #define TILEX_PROCF(fx, max)    SkClampMax((fx) &gt;&gt; 16, max)<br> #define TILEY_PROCF(fy, max)    SkClampMax((fy) &gt;&gt; 16, max)<br> #define TILEX_LOW_BITS(fx, max) (((fx) &gt;&gt; 12) &amp; 0xF)<br> #define TILEY_LOW_BITS(fy, max) (((fy) &gt;&gt; 12) &amp; 0xF)<br> #define CHECK_FOR_DECAL<br> #include "SkBitmapProcState_matrix.h"<br> </span></p> 
<p><span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">/*<br>  * Copyright 2011 Google Inc.<br>  *<br>  * Use of this source code is governed by a BSD-style license that can be<br>  * found in the LICENSE file.<br>  */<br> <br> <br> #include "SkMath.h"<br> #include "SkMathPriv.h"<br> <br> <br> #define SCALE_FILTER_NAME       MAKENAME(_filter_scale)<br> #define AFFINE_FILTER_NAME      MAKENAME(_filter_affine)<br> #define PERSP_FILTER_NAME       MAKENAME(_filter_persp)<br> <br> <br> #define PACK_FILTER_X_NAME  MAKENAME(_pack_filter_x)<br> #define PACK_FILTER_Y_NAME  MAKENAME(_pack_filter_y)<br> <br> <br> #ifndef PREAMBLE<br>     #define PREAMBLE(state)<br>     #define PREAMBLE_PARAM_X<br>     #define PREAMBLE_PARAM_Y<br>     #define PREAMBLE_ARG_X<br>     #define PREAMBLE_ARG_Y<br> #endif<br> <br> <br> // declare functions externally to suppress warnings.<br> void SCALE_FILTER_NAME(const SkBitmapProcState&amp; s,<br>                               uint32_t xy[], int count, int x, int y);<br> void AFFINE_FILTER_NAME(const SkBitmapProcState&amp; s,<br>                                uint32_t xy[], int count, int x, int y);<br> void PERSP_FILTER_NAME(const SkBitmapProcState&amp; s,<br>                               uint32_t* SK_RESTRICT xy, int count,<br>                               int x, int y);<br> <br> <br> static inline uint32_t PACK_FILTER_Y_NAME(SkFixed f, unsigned max,<br>                                           SkFixed one PREAMBLE_PARAM_Y) {<!-- --><br>     unsigned i = TILEY_PROCF(f, max);<br>     i = (i &lt;&lt; 4) | TILEY_LOW_BITS(f, max);<br>     return (i &lt;&lt; 14) | (TILEY_PROCF((f + one), max));<br> }<br> <br> <br> static inline uint32_t PACK_FILTER_X_NAME(SkFixed f, unsigned max,<br>                                           SkFixed one PREAMBLE_PARAM_X) {<!-- --><br>     unsigned i = TILEX_PROCF(f, max);<br>     i = (i &lt;&lt; 4) | TILEX_LOW_BITS(f, max);<br>     return (i &lt;&lt; 14) | (TILEX_PROCF((f + one), max));<br> }<br> <br> <br> void SCALE_FILTER_NAME(const SkBitmapProcState&amp; s,<br>                               uint32_t xy[], int count, int x, int y) {<!-- --><br>     SkASSERT((s.fInvType &amp; ~(SkMatrix::kTranslate_Mask |<br>                              SkMatrix::kScale_Mask)) == 0);<br>     SkASSERT(s.fInvKy == 0);<br> <br> <br>     PREAMBLE(s);<br> <br> <br>     const unsigned maxX = s.fBitmap-&gt;width() - 1;<br>     const SkFixed one = s.fFilterOneX;<br>     const SkFractionalInt dx = s.fInvSxFractionalInt;<br>     SkFractionalInt fx;<br> <br> <br>     {<!-- --><br>         SkPoint pt;<br>         s.fInvProc(s.fInvMatrix, SkIntToScalar(x) + SK_ScalarHalf,<br>                                   SkIntToScalar(y) + SK_ScalarHalf, &amp;pt);<br>         const SkFixed fy = SkScalarToFixed(pt.fY) - (s.fFilterOneY &gt;&gt; 1);<br>         const unsigned maxY = s.fBitmap-&gt;height() - 1;<br>         // compute our two Y values up front<br>         *xy++ = PACK_FILTER_Y_NAME(fy, maxY, s.fFilterOneY PREAMBLE_ARG_Y);<br>         // now initialize fx<br>         fx = SkScalarToFractionalInt(pt.fX) - (SkFixedToFractionalInt(one) &gt;&gt; 1);<br>     }<br> <br> <br> #ifdef CHECK_FOR_DECAL<br>     if (can_truncate_to_fixed_for_decal(fx, dx, count, maxX)) {<!-- --><br>         decal_filter_scale(xy, SkFractionalIntToFixed(fx),<br>                            SkFractionalIntToFixed(dx), count);<br>     } else<br> #endif<br>     {<!-- --><br>         do {<!-- --><br>             SkFixed fixedFx = SkFractionalIntToFixed(fx);<br>             *xy++ = PACK_FILTER_X_NAME(fixedFx, maxX, one PREAMBLE_ARG_X);<br>             fx += dx;<br>         } while (--count != 0);<br>     }<br> }<br> <br> <br> void AFFINE_FILTER_NAME(const SkBitmapProcState&amp; s,<br>                                uint32_t xy[], int count, int x, int y) {<!-- --><br>     SkASSERT(s.fInvType &amp; SkMatrix::kAffine_Mask);<br>     SkASSERT((s.fInvType &amp; ~(SkMatrix::kTranslate_Mask |<br>                              SkMatrix::kScale_Mask |<br>                              SkMatrix::kAffine_Mask)) == 0);<br> <br> <br>     PREAMBLE(s);<br>     SkPoint srcPt;<br>     s.fInvProc(s.fInvMatrix,<br>                SkIntToScalar(x) + SK_ScalarHalf,<br>                SkIntToScalar(y) + SK_ScalarHalf, &amp;srcPt);<br> <br> <br>     SkFixed oneX = s.fFilterOneX;<br>     SkFixed oneY = s.fFilterOneY;<br>     SkFixed fx = SkScalarToFixed(srcPt.fX) - (oneX &gt;&gt; 1);<br>     SkFixed fy = SkScalarToFixed(srcPt.fY) - (oneY &gt;&gt; 1);<br>     SkFixed dx = s.fInvSx;<br>     SkFixed dy = s.fInvKy;<br>     unsigned maxX = s.fBitmap-&gt;width() - 1;<br>     unsigned maxY = s.fBitmap-&gt;height() - 1;<br> <br> <br>     do {<!-- --><br>         *xy++ = PACK_FILTER_Y_NAME(fy, maxY, oneY PREAMBLE_ARG_Y);<br>         fy += dy;<br>         *xy++ = PACK_FILTER_X_NAME(fx, maxX, oneX PREAMBLE_ARG_X);<br>         fx += dx;<br>     } while (--count != 0);<br> }<br> <br> <br> void PERSP_FILTER_NAME(const SkBitmapProcState&amp; s,<br>                               uint32_t* SK_RESTRICT xy, int count,<br>                               int x, int y) {<!-- --><br>     SkASSERT(s.fInvType &amp; SkMatrix::kPerspective_Mask);<br> <br> <br>     PREAMBLE(s);<br>     unsigned maxX = s.fBitmap-&gt;width() - 1;<br>     unsigned maxY = s.fBitmap-&gt;height() - 1;<br>     SkFixed oneX = s.fFilterOneX;<br>     SkFixed oneY = s.fFilterOneY;<br> <br> <br>     SkPerspIter   iter(s.fInvMatrix,<br>                        SkIntToScalar(x) + SK_ScalarHalf,<br>                        SkIntToScalar(y) + SK_ScalarHalf, count);<br> <br> <br>     while ((count = iter.next()) != 0) {<!-- --><br>         const SkFixed* SK_RESTRICT srcXY = iter.getXY();<br>         do {<!-- --><br>             *xy++ = PACK_FILTER_Y_NAME(srcXY[1] - (oneY &gt;&gt; 1), maxY,<br>                                        oneY PREAMBLE_ARG_Y);<br>             *xy++ = PACK_FILTER_X_NAME(srcXY[0] - (oneX &gt;&gt; 1), maxX,<br>                                        oneX PREAMBLE_ARG_X);<br>             srcXY += 2;<br>         } while (--count != 0);<br>     }<br> }<br> <br> <br> #undef MAKENAME<br> #undef TILEX_PROCF<br> #undef TILEY_PROCF<br> #ifdef CHECK_FOR_DECAL<br>     #undef CHECK_FOR_DECAL<br> #endif<br> <br> <br> #undef SCALE_FILTER_NAME<br> #undef AFFINE_FILTER_NAME<br> #undef PERSP_FILTER_NAME<br> <br> <br> #undef PREAMBLE<br> #undef PREAMBLE_PARAM_X<br> #undef PREAMBLE_PARAM_Y<br> #undef PREAMBLE_ARG_X<br> #undef PREAMBLE_ARG_Y<br> <br> <br> #undef TILEX_LOW_BITS<br> #undef TILEY_LOW_BITS<br> </span></p> 
<p><span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"><span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">然后我们就清楚了，这些函数名是用宏组合出来的。（神一般的代码。。。。。）<br> 怎么算坐标的不详述了，主要按原理去推就可以了，坐标计算有三种模式：CLAMP（越界时限制在边界）、REPEAT（越界时从开头取起）、MIRROR（越界时取样方向倒转去取）。<br> sampleProc函数也是类似的方法组合出来的，不详述。</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; line-height:26px; font-size:24px">三、高级插值算法</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">双线性插值虽然在一般情况下够用了，但在放大图片时，效果还是不够好。需要更好的效果，可以用高级插值算法，代价是性能的大幅消耗。<br> 高级插值算法目前在Android的Java代码处是走不进去的，不知道chromium是否用到。<br> 几个要点：<br> 1、在 setBitmapFilterProcs 时判断高级插值是否支持，若支持，设置 shaderProc 为 highQualityFilter32/highQualityFilter16（也就是独立计算坐标和采样像素）<br> 2、highQualityFilter先通过变换矩阵计算原始点。<br> 3、highQualityFilter根据 SkBitmapFilter  的采样窗口，将这个窗口中的所有点按其与原始点矩离，查询对应权重值，然后相加，得到最终像素点。<br> 4、SkBitmapFilter 采用查表法去给出权重值，预计算由子类完成。<br> 5、目前Skia库用的是双三次插值 mitchell 法。<br> <br> SK_CONF_DECLARE(const char *, c_bitmapFilter, "bitmap.filter", "mitchell", "Which scanline bitmap filter to use [mitchell, lanczos, hamming, gaussian, triangle, box]");<br> 详细代码见 external/skia/src/core/SkBitmapFilter.cpp，尽量这部分代码几乎无用武之地，<span style="color:rgb(153,0,0)">但里面的公式很值得借鉴，随便改改就能做成 glsl shader 用。</span><br> <br> 看完这段代码，可以作不负责任的猜想：Skia设计之初，只考虑了近邻插值和双线性插值两种情况，因此采用这种模板方法，可以最小化代码量。而且MatrixProc和SampleProc可以后续分别作SIMD优化（Intel的SSE和ARM的Neon），以提高性能。<br> 但是对于线性插值，两步法（取值——采样）在算法实现上本来就不是最优的，后面又不得不引入shader函数，应对一些场景做优化。高阶插值无法在这个设计下实现，因此又像补丁一样打上去。</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; line-height:26px; font-size:24px">四、总结</span><br style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"> <span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px">看完这一部分代码，有三个感受。<br> 第一：绘张图片看上去一件简单的事，在渲染执行时，真心不容易，如果追求效果，还会有各种各样的花样。<br> 第二：在性能有要求的场景下，用模板真是灾难：函数改写时，遇到模板，就不得不重新定义函数，并替换之，弄得代码看上去一下子混乱不少。<br> 第三：从图像绘制这个角度上看，skia渲染性能虽然确实很好了，但远没有达到极限，仍然是有一定的优化空间的，如果这部分出现了性能问题，还是能做一定的优化的。关于Skia性能的讨论将放到介绍Skia系列的最后一章。<br> 第四：OpenGL+glsl确实是轻松且高效多了，软件渲染在复杂场景上性能很有限。</span><br> </span></p> 
<p><span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"><br> </span></p> 
<p><span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"><br> </span></p> 
<p><span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"><br> </span></p> 
<p><span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"><br> </span></p> 
<p><span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"><br> </span></p> 
<p><span style="color:rgb(51,51,51); font-family:Arial; font-size:14px; line-height:26px"><br> </span></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6803d745f07e7f82afb8415e92eb2c66/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Impala配置与错误解决方案</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/44cc61311fb3a2f78a2b56878eae49c7/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">人脸识别国内外现状及发展</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>