<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Android开发中四种常用的多线程实现方式 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Android开发中四种常用的多线程实现方式" />
<meta property="og:description" content="前言 一般来说，一个应用至少有一个进程，一个进程至少有一个线程。线程是CPU调度的基本单位，进程是系统资源分配的基本单位。
进程拥有独占的内存资源，一个进程可以看作一个JVM一个进程崩溃后，一般不会影响保护模式下的其他进程。同一进程中的线程共享内存资源，一个线程的死亡导致整个进程的死亡。
Android开发四种常用的多线程实现方式：
AsyncTask异步消息机制IntentServiceThreadPoolExcutor 1.AsyncTask
Android AsyncTask 类，它是封装好的线程池，操作 UI 线程极其方便。
AsyncTask 的三个泛型参数：
public abstract class AsyncTask&lt;Params, Progress, Result&gt; Params ，传入参数类型，即 doInBackground() 方法中的参数类型;Progress，异步任务执行过程中返回的任务执行进度类型， 即 publishProgress() 和onProgressUpdate() 方法中传入的参数类型；
Result，异步任务执行完返回的结果类型\，即 doInBackground() 方法中返回值的类型。 四个回调方法：
onPreExecute()，在主线程执行，做一些准备工作。doInBackground()，在线程池中执行，该方法是抽象方法，在此方法中可以调用 publishProgress() 更新任务进度。onProgressUpdate()，在主线程中执行，在 publishProgress() 调用之后被回调，展示任务进度。onPostExecute()，在主线程中执行，异步任务结束后，回调此方法，处理返回结果。 注意：
当AsyncTask 任务被取消时，回调 onCanceled(obj) ，此时onPostExecute()，不会被调用，AsyncTask 中的 cancel()方法并不是真正去取消任务，只是设置这个任务为取消状态，需要在 doInBackground() 中通过 isCancelled()判断终止任务。AsyncTask 必须在主线程中创建实例，execute() 方法也必须在主线程中调用。每个 AsyncTask实例只能执行一execute() ，多次执行会报错，如需执行多次，则需创建多个实例。Android 3.0 之后，AsyncTask 对象默认执行多任务是串行执行，即 mAsyncTask.execute() ，并发执行的话需要使用executeOnExecutor()。AsyncTask 用的是线程池机制和异步消息机制（基于 ThreadPoolExecutor和 Handler ）。Android 2.3 以前，AsyncTask 线程池容量是 128 ，全局线程池只有 5 个工作线程，如果运用 AsyncTask 对象来执行多个并发异步任务，那么同一时间最多只能有 5 个线程同时运行，其他线程将被阻塞。Android 3." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/eee2aeabee05ee11498296f4d8a9231f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-04-13T21:07:03+08:00" />
<meta property="article:modified_time" content="2023-04-13T21:07:03+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Android开发中四种常用的多线程实现方式</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="_0"></a>前言</h3> 
<p>一般来说，一个应用至少有一个进程，一个进程至少有一个线程。线程是CPU调度的基本单位，进程是系统资源分配的基本单位。</p> 
<p>进程拥有独占的内存资源，一个进程可以看作一个JVM一个进程崩溃后，一般不会影响保护模式下的其他进程。同一进程中的线程共享内存资源，一个线程的死亡导致整个进程的死亡。</p> 
<p><strong>Android开发四种常用的多线程实现方式：</strong></p> 
<ul><li>AsyncTask</li><li>异步消息机制</li><li>IntentService</li><li>ThreadPoolExcutor</li></ul> 
<p><strong>1.AsyncTask</strong></p> 
<p>Android AsyncTask 类，它是封装好的线程池，操作 UI 线程极其方便。<br> AsyncTask 的三个泛型参数：</p> 
<pre><code>public abstract class AsyncTask&lt;Params, Progress, Result&gt;

</code></pre> 
<ul><li>Params ，传入参数类型，即 doInBackground() 方法中的参数类型;</li><li>Progress，异步任务执行过程中返回的任务执行进度类型，</li></ul> 
<p>即 publishProgress() 和onProgressUpdate() 方法中传入的参数类型；</p> 
<ul><li>Result，异步任务执行完返回的结果类型\，即 doInBackground() 方法中返回值的类型。</li></ul> 
<p>四个回调方法：</p> 
<ul><li>onPreExecute()，在主线程执行，做一些准备工作。</li><li>doInBackground()，在线程池中执行，该方法是抽象方法，在此方法中可以调用 publishProgress() 更新任务进度。</li><li>onProgressUpdate()，在主线程中执行，在 publishProgress() 调用之后被回调，展示任务进度。</li><li>onPostExecute()，在主线程中执行，异步任务结束后，回调此方法，处理返回结果。</li></ul> 
<p><strong>注意：</strong></p> 
<ul><li>当AsyncTask 任务被取消时，回调 onCanceled(obj) ，此时onPostExecute()，不会被调用，AsyncTask 中的 cancel()方法并不是真正去取消任务，只是设置这个任务为取消状态，需要在 doInBackground() 中通过 isCancelled()判断终止任务。</li><li>AsyncTask 必须在主线程中创建实例，execute() 方法也必须在主线程中调用。</li><li>每个 AsyncTask实例只能执行一execute() ，多次执行会报错，如需执行多次，则需创建多个实例。</li><li>Android 3.0 之后，AsyncTask 对象默认执行多任务是串行执行，即 mAsyncTask.execute() ，并发执行的话需要使用executeOnExecutor()。</li><li>AsyncTask 用的是线程池机制和异步消息机制（基于 ThreadPoolExecutor和 Handler ）。Android 2.3 以前，AsyncTask 线程池容量是 128 ，全局线程池只有 5 个工作线程，如果运用 AsyncTask 对象来执行多个并发异步任务，那么同一时间最多只能有 5 个线程同时运行，其他线程将被阻塞。</li><li>Android 3.0之后 Google 又进行了调整，新增接口 executeOnExecutor() ，允许自定义线程池（那么核心线程数以及线程容量也可自定义），并提供了 SERIAL_EXECUTOR 和THREAD_POOL_EXECUTOR 预定义线程池。后来 Google 又做了一些调整（任何事物都不完美），将线程池的容量与 CPU的核心数联系起来，如目前 SDK 25 版本中，预定义的核心线程数量最少有 2 个，最多 4 个，线程池容量范围 5 ~ 9 。</li></ul> 
<p>改动如下：</p> 
<pre><code>private static final int CPU_COUNT = Runtime.getRuntime().availableProcessors();
private static final int CORE_POOL_SIZE = Math.max(2, Math.min(CPU_COUNT - 1, 4));
private static final int MAXIMUM_POOL_SIZE = CPU_COUNT * 2 + 1;
private static final int KEEP_ALIVE_SECONDS = 30;

</code></pre> 
<p><strong>2. 异步消息机制</strong></p> 
<p>异步消息机制的三大主角： <strong>Handler ，Message</strong> 和 <strong>Looper</strong> 。</p> 
<p>Looper 负责创建 MessageQueue 消息对列，然后进入一个无限 for 循环中，不断地从消息队列中取消息，如果消息队列为空，当前线程阻塞，Handler 负责向消息队列中发送消息。</p> 
<p><strong>Looper</strong></p> 
<p>Looper 有两个重要的方法： prepare() 和 loop()。</p> 
<p>prepare() ， Looper 与当前线程绑定，一个线程只能有一个 Looper 实例和一个 MessageQueue 实例。</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">prepare</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>sThreadLocal<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">"Only one Looper may be created per thread"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        sThreadLocal<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Looper</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 保证 <span class="token class-name">Looper</span> 对象在当前线程唯一
<span class="token punctuation">}</span>

<span class="token comment">// Looper 的构造方法</span>
<span class="token keyword">private</span> <span class="token class-name">Looper</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> quitAllowed<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        mQueue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MessageQueue</span><span class="token punctuation">(</span>quitAllowed<span class="token punctuation">)</span><span class="token punctuation">;</span>
        mRun <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        mThread <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre> 
<p>loop ，进入一个无限 for 循环体中，不断地从消息队列中取消息，然后交给消息的 target 属性的 dispatchMessage 方法去处理。</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">loop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">final</span> <span class="token class-name">Looper</span> me <span class="token operator">=</span> <span class="token function">myLooper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>me <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">"No Looper; Looper.prepare() wasn't called on this thread."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">final</span> <span class="token class-name">MessageQueue</span> queue <span class="token operator">=</span> me<span class="token punctuation">.</span>mQueue<span class="token punctuation">;</span>

        <span class="token comment">// Make sure the identity of this thread is that of the local process,</span>
        <span class="token comment">// and keep track of what that identity token actually is.</span>
        <span class="token class-name">Binder</span><span class="token punctuation">.</span><span class="token function">clearCallingIdentity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">final</span> <span class="token keyword">long</span> ident <span class="token operator">=</span> <span class="token class-name">Binder</span><span class="token punctuation">.</span><span class="token function">clearCallingIdentity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>


        <span class="token comment">// 无限循环体，有没有想过在 UI 线程里，有这样一个死循环，为什么界面没卡死？？</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> 
            <span class="token class-name">Message</span> msg <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// might block</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>msg <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token comment">// No message indicates that the message queue is quitting.</span>
                <span class="token keyword">return</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>

            msg<span class="token punctuation">.</span>target<span class="token punctuation">.</span><span class="token function">dispatchMessage</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>

            msg<span class="token punctuation">.</span><span class="token function">recycle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre> 
<p><strong>Handler</strong></p> 
<p>Handler 负责向消息队列中发送消息。<br> 在 Activity 中我们直接可以 new Handler ，那是因为在 Activity 的启动代码中，已经在当前 UI 线程中调用了 Looper.prepare() 和 Looper.loop() 方法。</p> 
<p>在子线程中 new Handler 必须要在当前线程（子线程）中创建好 Looper 对象和消息队列，代码如下</p> 
<p>//在子线程中</p> 
<p>Looper.prepare();</p> 
<p>handler = new Handler() {<!-- --></p> 
<pre><code>public void handleMessage(Message msg) {
    //处理消息
};

</code></pre> 
<p>};</p> 
<p>Looper.loop();</p> 
<p>之后，你拿着这个 Handler 对象就可以在其他线程中，往这个子线程的消息队列中发消息了。</p> 
<p><strong>HandlerThread</strong></p> 
<p>HandlerThread 可以看作在子线程中创建一个异步消息处理机制的简化版，HandlerThread 对象自动帮我们在工作线程里创建 Looper 对象和消息队列。</p> 
<p>使用方法：</p> 
<pre><code class="prism language-java">mHandlerThread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HandlerThread</span><span class="token punctuation">(</span><span class="token string">"MyHandlerThread"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
mHandlerThread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

mHandler <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Handler</span><span class="token punctuation">(</span>mHandlerThread<span class="token punctuation">.</span><span class="token function">getLooper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handleMessage</span><span class="token punctuation">(</span><span class="token class-name">Message</span> msg<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">//处理消息</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

</code></pre> 
<p>之后你就可以使用 Handler 对象往工作线程中的消息队列中发消息了。</p> 
<p>看一下源码片段：</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HandlerThread</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> mPriority<span class="token punctuation">;</span>
    <span class="token keyword">int</span> mTid <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token class-name">Looper</span> mLooper<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">HandlerThread</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">super</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
        mPriority <span class="token operator">=</span> <span class="token class-name">Process</span><span class="token punctuation">.</span>THREAD_PRIORITY_DEFAULT<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">onLooperPrepared</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        mTid <span class="token operator">=</span> <span class="token class-name">Process</span><span class="token punctuation">.</span><span class="token function">myTid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Looper</span><span class="token punctuation">.</span><span class="token function">prepare</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            mLooper <span class="token operator">=</span> <span class="token class-name">Looper</span><span class="token punctuation">.</span><span class="token function">myLooper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">notifyAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token class-name">Process</span><span class="token punctuation">.</span><span class="token function">setThreadPriority</span><span class="token punctuation">(</span>mPriority<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">onLooperPrepared</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Looper</span><span class="token punctuation">.</span><span class="token function">loop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        mTid <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token class-name">Looper</span> <span class="token function">getLooper</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isAlive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment">// If the thread has been started, wait until the looper has been created.</span>
        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">isAlive</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> mLooper <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
                    <span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> mLooper<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre> 
<p>**注意：**handler 在 UI 线程中初始化的，looper 在一个子线程中执行，我们必须等 mLooper 创建完成之后，才能调用 getLooper ，源码中是通过 wait 和 notify 解决两个线程的同步问题。</p> 
<p><strong>3. IntentService</strong></p> 
<p>IntentService 可以看成是 Service 和 HandlerThread 的合体。它继承自 Service ，并可以处理异步请求，其内部有一个 WorkerThread 来处理异步任务，当任务执行完毕后，IntentService 自动停止。</p> 
<p>如果多次启动 IntentService 呢？ 看到 HandlerThread ，你就应该想到多次启动 IntentService ,就是将多个异步任务放到任务队列里面，然后在 onHandlerIntent 回调方法中串行执行，执行完毕后自动结束。</p> 
<p>下面对源码进行简单的解析，IntentService 源码：</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">IntentService</span> <span class="token keyword">extends</span> <span class="token class-name">Service</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token class-name">Looper</span> mServiceLooper<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token class-name">ServiceHandler</span> mServiceHandler<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> mName<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">boolean</span> mRedelivery<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">ServiceHandler</span> <span class="token keyword">extends</span> <span class="token class-name">Handler</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">public</span> <span class="token class-name">ServiceHandler</span><span class="token punctuation">(</span><span class="token class-name">Looper</span> looper<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">super</span><span class="token punctuation">(</span>looper<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handleMessage</span><span class="token punctuation">(</span><span class="token class-name">Message</span> msg<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">//onHandleIntent 方法在工作线程中执行，执行完调用 stopSelf() 结束服务。</span>
            <span class="token function">onHandleIntent</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">Intent</span><span class="token punctuation">)</span>msg<span class="token punctuation">.</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">stopSelf</span><span class="token punctuation">(</span>msg<span class="token punctuation">.</span>arg1<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token comment">/**
     * Creates an IntentService.  Invoked by your subclass's constructor.
     *
     * @param name Used to name the worker thread, important only for debugging.
     */</span>
    <span class="token keyword">public</span> <span class="token class-name">IntentService</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        mName <span class="token operator">=</span> name<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/**
     * enabled == true 时，如果任务没有执行完，当前进程就死掉了，那么系统就会令当前进程重启。
     * 任务会被重新执行。
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setIntentRedelivery</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> enabled<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        mRedelivery <span class="token operator">=</span> enabled<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onCreate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">onCreate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 上面已经讲过，HandlerThread 对象 start 之后，会在工作线程里创建消息队列 和 Looper 对象。</span>
        <span class="token class-name">HandlerThread</span> thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HandlerThread</span><span class="token punctuation">(</span><span class="token string">"IntentService["</span> <span class="token operator">+</span> mName <span class="token operator">+</span> <span class="token string">"]"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        mServiceLooper <span class="token operator">=</span> thread<span class="token punctuation">.</span><span class="token function">getLooper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 获得 Looper 对象初始化 Handler 对象。</span>
        mServiceHandler <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ServiceHandler</span><span class="token punctuation">(</span>mServiceLooper<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onStart</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Nullable</span> <span class="token class-name">Intent</span> intent<span class="token punctuation">,</span> <span class="token keyword">int</span> startId<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// IntentService 每次启动都会往工作线程消息队列中添加消息，不会创建新的线程。</span>
        <span class="token class-name">Message</span> msg <span class="token operator">=</span> mServiceHandler<span class="token punctuation">.</span><span class="token function">obtainMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        msg<span class="token punctuation">.</span>arg1 <span class="token operator">=</span> startId<span class="token punctuation">;</span>
        msg<span class="token punctuation">.</span>obj <span class="token operator">=</span> intent<span class="token punctuation">;</span>
        mServiceHandler<span class="token punctuation">.</span><span class="token function">sendMessage</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 官方建议 IntentService onStartCommand 方法不应该被重写，注意该方法会调用 onStart 。</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">onStartCommand</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Nullable</span> <span class="token class-name">Intent</span> intent<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">,</span> <span class="token keyword">int</span> startId<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token function">onStart</span><span class="token punctuation">(</span>intent<span class="token punctuation">,</span> startId<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> mRedelivery <span class="token operator">?</span> START_REDELIVER_INTENT <span class="token operator">:</span> START_NOT_STICKY<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onDestroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>  
        <span class="token comment">//服务停止会清除消息队列中的消息，除了当前执行的任务外，后续的任务不会被执行。</span>
        mServiceLooper<span class="token punctuation">.</span><span class="token function">quit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">/**
     * 不建议通过 bind 启动 IntentService ，如果通过 bind 启动 IntentService ，那么 onHandlerIntent 方法不会被回调。Activity 与 IntentService 之间的通信一般采用广播的方式。
     */</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token annotation punctuation">@Nullable</span>
    <span class="token keyword">public</span> <span class="token class-name">IBinder</span> <span class="token function">onBind</span><span class="token punctuation">(</span><span class="token class-name">Intent</span> intent<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">/**
     * 子类必须要实现，执行具体的异步任务逻辑，由 IntentService 自动回调。
     */</span>
    <span class="token annotation punctuation">@WorkerThread</span>
    <span class="token keyword">protected</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">onHandleIntent</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Nullable</span> <span class="token class-name">Intent</span> intent<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre> 
<p>IntentService 源码很容易理解，你也可以就自己的应用场景封装自己的 IntentService 。</p> 
<p><strong>几种场景：</strong></p> 
<ul><li><strong>正常情况下，启动 IntentService ，任务完成，服务停止；</strong></li><li><strong>异步任务完成前，停止 IntentService，服务停止，但任务还会执行完成，完成后，工作线程结束；</strong></li><li><strong>多次启动 IntentService，任务会被一次串行执行，执行结束后，服务停止；</strong></li><li><strong>多次启动 IntentService ，在所有任务执行结束之前，停止 IntentService ，服务停止，除了当前执行的任务外，后续的任务不会被执行；</strong></li></ul> 
<p><strong>4. ThreadPoolExcutor</strong></p> 
<p><img src="https://images2.imgbox.com/ae/fd/swiiey09_o.png" alt=""></p> 
<p><strong>ThreadPool</strong></p> 
<p>用来管理一组工作线程，任务队列（ BlockingQueue ）中持有的任务等待着被线程池中的空闲线程执行。</p> 
<p>常用构造方法：</p> 
<pre><code class="prism language-java"><span class="token class-name">ThreadPoolExecutor</span> threadPoolExecutor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span>
    <span class="token keyword">int</span> corePoolSize<span class="token punctuation">,</span>
    <span class="token keyword">int</span> maximumPoolSize<span class="token punctuation">,</span>
    <span class="token keyword">long</span> keepAliveTime<span class="token punctuation">,</span>
    <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">,</span>
    <span class="token class-name">BlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Runnable</span><span class="token punctuation">&gt;</span></span> workQueue
<span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre> 
<ul><li>corePoolSize 核心线程池容量，即线程池中所维持线程的最低数量。corePoolSize 初始值为 0，当有新任务加入到任务队列中，新的线程将被创建，这个时候即使线程池中存在空闲线程，只要当前线程数小于 corePoolSize，那么新的线程依然被创建。</li><li>maximumPoolSize 线程池中所维持线程的最大数量。</li><li>keepAliveTime 空闲线程在没有新任务到来时的存活时间。</li><li>unit 参数 keepAliveTime 的时间单位。</li><li>workQueue 任务队列，必须是 BlockingQueue 。</li></ul> 
<p><strong>简单使用</strong></p> 
<p>创建 ThreadFactory ，当然也可以自定义。</p> 
<pre><code class="prism language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">ThreadFactory</span> sThreadFactory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">AtomicInteger</span> mCount <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">Thread</span> <span class="token function">newThread</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> r<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>r<span class="token punctuation">,</span> <span class="token string">"AsyncTask #"</span> <span class="token operator">+</span> mCount<span class="token punctuation">.</span><span class="token function">getAndIncrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

</code></pre> 
<p>创建 ThreadPoolExecutor 。</p> 
<pre><code class="prism language-java"><span class="token comment">// 根据 CPU 核心数确定线程池容量。</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> NUMBER_OF_CORES <span class="token operator">=</span> <span class="token class-name">Runtime</span><span class="token punctuation">.</span><span class="token function">getRuntime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">availableProcessors</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 

mThreadPoolExecutor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span>
        NUMBER_OF_CORES <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">,</span> 
        NUMBER_OF_CORES <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span>
        <span class="token number">60L</span><span class="token punctuation">,</span>
        <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>SECONDS<span class="token punctuation">,</span>
        <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Runnable</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        backgroundPriorityThreadFactory
<span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre> 
<p>执行。</p> 
<pre><code class="prism language-java">mThreadPoolExecutor<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> 

    <span class="token annotation punctuation">@Override</span>  
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>  
         <span class="token comment">//do something  </span>
    <span class="token punctuation">}</span> 

<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token class-name">Future</span> future <span class="token operator">=</span> mThreadPoolExecutor<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> 

    <span class="token annotation punctuation">@Override</span>  
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>  
         <span class="token comment">//do something  </span>
    <span class="token punctuation">}</span> 

<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//任务可取消</span>
future<span class="token punctuation">.</span><span class="token function">cancel</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token class-name">Future</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> futureInt <span class="token operator">=</span> mThreadPoolExecutor<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Callable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token annotation punctuation">@override</span>
    <span class="token keyword">public</span> <span class="token class-name">Integer</span> <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//获取执行结果</span>
futureInt<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token class-name">FutureTask</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> task <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FutureTask</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Callable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token annotation punctuation">@override</span>
    <span class="token keyword">public</span> <span class="token class-name">Integer</span> <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>    

<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

mThreadPoolExecutor<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>
task<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre> 
<h3><a id="_423"></a>最后</h3> 
<p>如果想要成为架构师或想突破20~30K薪资范畴，那就不要局限在编码，业务，要会选型、扩展，提升编程思维。此外，良好的职业规划也很重要，学习的习惯很重要，但是最重要的还是要能持之以恒，任何不能坚持落实的计划都是空谈。</p> 
<p>如果你没有方向，这里给大家分享一套由阿里高级架构师编写的《Android八大模块进阶笔记》，帮大家将杂乱、零散、碎片化的知识进行体系化的整理，让大家系统而高效地掌握Android开发的各个知识点。<br> <img src="https://images2.imgbox.com/ad/df/hSVf1N5L_o.png" alt="在这里插入图片描述"><br> 相对于我们平时看的碎片化内容，这份笔记的知识点更系统化，更容易理解和记忆，是严格按照知识体系编排的。</p> 
<h3><a id="_431"></a>全套视频资料：</h3> 
<p><strong>一、面试合集</strong></p> 
<p><img src="https://images2.imgbox.com/7a/2e/kHtb9UlH_o.png" alt="在这里插入图片描述"><br> <strong>二、源码解析合集</strong><br> <img src="https://images2.imgbox.com/28/37/mwbFziHS_o.png" alt="在这里插入图片描述"></p> 
<p><strong>三、开源框架合集</strong><br> <img src="https://images2.imgbox.com/0a/83/aQYyg8xT_o.png" alt="在这里插入图片描述"><br> <strong>欢迎大家一键三连支持，若需要文中资料，直接扫描文末CSDN官方认证微信卡片免费领取↓↓↓</strong><br> <img src="https://images2.imgbox.com/a4/f7/mGHAbA4a_o.png"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3ac692b4389c366dbc6b854e44782ea0/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">centos使用GeoIP设置某个国家之外的IP访问</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8f4b91b6f1681f592da8b79ae9fee94e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">快排（动图详细版，快速理解）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>