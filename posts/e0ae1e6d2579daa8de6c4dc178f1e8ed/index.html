<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Inorder Successor in BST - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Inorder Successor in BST" />
<meta property="og:description" content="Given a binary search tree and a node in it, find the in-order successor of that node in the BST.
Note: If the given node has no in-order successor in the tree, return null.
要求返回给定二叉搜索树BST的中的一个节点.要求求该节点的后继节点.
BST的特点是: 左节点的值小于等于父节点, 右节点的值大于等于父节点.所以可以利用这个属性来进行搜索.具体方案和算法导论给出的在BST中找特定节点的流程是一样的.
但是需要注意的是因为求的是后续节点.我们实际要求的是比给定节点值大的最小节点.所以每个比给定节点值大的点都可能是.但是我们需要不断缩小搜索范围. 使找到的下一个比节点值大的点的值比之前的candidate要小.
给出这种解法的代码,平均时间复杂度为O(h), h为高度.空间复杂度为O(1).
# Definition for a binary tree node. # class TreeNode(object): # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution(object): def inorderSuccessor(self, root, p): &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/e0ae1e6d2579daa8de6c4dc178f1e8ed/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-07-03T04:33:45+08:00" />
<meta property="article:modified_time" content="2019-07-03T04:33:45+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Inorder Successor in BST</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="cnblogs_post_body" class="blogpost-body"> 
 <p>Given a binary search tree and a node in it, find the in-order successor of that node in the BST.</p> 
 <p><strong>Note</strong>: If the given node has no in-order successor in the tree, return <code>null</code>.</p> 
 <p>要求返回给定二叉搜索树BST的中的一个节点.要求求该节点的后继节点.</p> 
 <p>BST的特点是: 左节点的值小于等于父节点, 右节点的值大于等于父节点.所以可以利用这个属性来进行搜索.具体方案和算法导论给出的在BST中找特定节点的流程是一样的.</p> 
 <p>但是需要注意的是因为求的是后续节点.<strong>我们实际要求的是比给定节点值大的最小节点.</strong>所以每个比给定节点值大的点都可能是.但是我们需要不断缩小搜索范围. 使找到的下一个比节点值大的点的值比之前的candidate要小.</p> 
 <p>给出这种解法的代码,平均时间复杂度为O(h), h为高度.空间复杂度为O(1).</p> 
 <div class="cnblogs_code"> 
  <pre><span style="color:#008000;">#</span><span style="color:#008000;"> Definition for a binary tree node.</span><span style="color:#008000;">
#</span><span style="color:#008000;"> class TreeNode(object):</span><span style="color:#008000;">
#</span><span style="color:#008000;">     def __init__(self, x):</span><span style="color:#008000;">
#</span><span style="color:#008000;">         self.val = x</span><span style="color:#008000;">
#</span><span style="color:#008000;">         self.left = None</span><span style="color:#008000;">
#</span><span style="color:#008000;">         self.right = None</span>

<span style="color:#0000ff;">class</span><span style="color:#000000;"> Solution(object):
    </span><span style="color:#0000ff;">def</span><span style="color:#000000;"> inorderSuccessor(self, root, p):
        </span><span style="color:#800000;">"""</span><span style="color:#800000;">
        :type root: TreeNode
        :type p: TreeNode
        :rtype: TreeNode
        </span><span style="color:#800000;">"""</span>
        <span style="color:#0000ff;">if</span> <span style="color:#0000ff;">not</span> root <span style="color:#0000ff;">or</span> <span style="color:#0000ff;">not</span><span style="color:#000000;"> p:
            </span><span style="color:#0000ff;">return</span><span style="color:#000000;"> None
        cur </span>=<span style="color:#000000;"> root
        succ </span>=<span style="color:#000000;"> None
        </span><span style="color:#0000ff;">while</span><span style="color:#000000;"> cur:
            </span><span style="color:#0000ff;">if</span> p.val &lt;<span style="color:#000000;"> cur.val:
                <strong>succ </strong></span><strong>=</strong><span style="color:#000000;"><strong> cur  #可能的后继</strong>
                <strong>cur </strong></span><strong>= <span style="color:#000000;">cur.left
            </span></strong><span style="color:#0000ff;">else</span><span style="color:#000000;">:
                cur </span>=<span style="color:#000000;"> cur.right
        </span><span style="color:#0000ff;">return</span> succ</pre> 
 </div> 
 <p>给出一个leetcode上的解释:</p> 
 <p>The idea is to compare <code>root</code>'s value with <code>p</code>'s value if <code>root</code> is not null, and consider the following two cases:</p> 
 <ul><li> <p><code>root.val &gt; p.val</code>. In this case, <code>root</code> can be a possible answer, so we store the root node first and call it <code>res</code>. However, we don't know if there is anymore node on <code>root</code>'s left that is larger than <code>p.val</code>. So we move root to its left and check again.</p> </li><li> <p><code>root.val &lt;= p.val</code>. In this case, <code>root</code> cannot be <code>p</code>'s inorder successor, neither can <code>root</code>'s left child. So we only need to consider <code>root</code>'s right child, thus we move root to its right and check again.</p> </li></ul> 
 <p>We continuously move <code>root</code> until exhausted. To this point, we only need to return the <code>res</code> in case 1.</p> 
 <p>其实本质这种策略是抛弃不可能有candidate的子树,但是保存可能是最终结果的candidate.因为每次在p.val &lt; cur.val的时候,我们继续在cur的左子树查找,所以找到的candidate肯定比cur小. succ是不断缩小的.</p> 
 <p>以上解法可以做剪枝,也就是在给定的p节点有右子数时,后续节点实际是该右子树的最左节点,代码如下:</p> 
 <div class="cnblogs_code"> 
  <pre><span style="color:#008000;">#</span><span style="color:#008000;"> Definition for a binary tree node.</span><span style="color:#008000;">
#</span><span style="color:#008000;"> class TreeNode(object):</span><span style="color:#008000;">
#</span><span style="color:#008000;">     def __init__(self, x):</span><span style="color:#008000;">
#</span><span style="color:#008000;">         self.val = x</span><span style="color:#008000;">
#</span><span style="color:#008000;">         self.left = None</span><span style="color:#008000;">
#</span><span style="color:#008000;">         self.right = None</span>

<span style="color:#0000ff;">class</span><span style="color:#000000;"> Solution(object):
    </span><span style="color:#800000;">"""</span><span style="color:#800000;">
    @param root &lt;TreeNode&gt;: The root of the BST.
    @param p &lt;TreeNode&gt;: You need find the successor node of p.
    @return &lt;TreeNode&gt;: Successor of p.
    </span><span style="color:#800000;">"""</span>
    <span style="color:#0000ff;">def</span><span style="color:#000000;"> inorderSuccessor(self, root, p):
        </span><span style="color:#0000ff;">if</span> <span style="color:#0000ff;">not</span><span style="color:#000000;"> root:
            </span><span style="color:#0000ff;">return</span><span style="color:#000000;"> None
        succesor </span>=<span style="color:#000000;"> None
        </span><span style="color:#0000ff;">if</span>  p <span style="color:#0000ff;">and</span><span style="color:#000000;"> p.right:
            succesor </span>=<span style="color:#000000;"> p.right
            </span><span style="color:#0000ff;">while</span><span style="color:#000000;"> succesor.left:
                succesor </span>=<span style="color:#000000;"> succesor.left
            </span><span style="color:#0000ff;">return</span><span style="color:#000000;"> succesor
        </span><span style="color:#0000ff;">while</span><span style="color:#000000;"> root:
            </span><span style="color:#0000ff;">if</span> root.val &gt;<span style="color:#000000;"> p.val:
                succesor </span>=<span style="color:#000000;"> root
                root </span>=<span style="color:#000000;"> root.left
            </span><span style="color:#0000ff;">elif</span> root.val &lt;<span style="color:#000000;"> p.val:
                root </span>=<span style="color:#000000;"> root.right
            </span><span style="color:#0000ff;">else</span><span style="color:#000000;">:
                </span><span style="color:#0000ff;">break</span>
        <span style="color:#0000ff;">return</span> succesor</pre> 
 </div> 
 <p> </p> 
 <p> </p> 
 <p>另外就是基于中序遍历的解法,这种不需要限定在BST上,所以更general.具体是在查找到节点后,查找后续处理的那个节点.稍微修改下非递归中序遍历的代码就可以.时间复杂度O(n)(因为遍历了,平均空间复杂度为O(logn),栈,可以验证),</p> 
 <p>代码如下:</p> 
 <div class="cnblogs_code"> 
  <pre><span style="color:#008000;">#</span><span style="color:#008000;"> Definition for a binary tree node.</span><span style="color:#008000;">
#</span><span style="color:#008000;"> class TreeNode(object):</span><span style="color:#008000;">
#</span><span style="color:#008000;">     def __init__(self, x):</span><span style="color:#008000;">
#</span><span style="color:#008000;">         self.val = x</span><span style="color:#008000;">
#</span><span style="color:#008000;">         self.left = None</span><span style="color:#008000;">
#</span><span style="color:#008000;">         self.right = None</span>

<span style="color:#0000ff;">class</span><span style="color:#000000;"> Solution(object):
    </span><span style="color:#0000ff;">def</span><span style="color:#000000;"> inorderSuccessor(self, root, p):
        </span><span style="color:#800000;">"""</span><span style="color:#800000;">
        :type root: TreeNode
        :type p: TreeNode
        :rtype: TreeNode
        </span><span style="color:#800000;">"""</span>
        <span style="color:#0000ff;">if</span> <span style="color:#0000ff;">not</span> root <span style="color:#0000ff;">or</span> <span style="color:#0000ff;">not</span><span style="color:#000000;"> p:
            </span><span style="color:#0000ff;">return</span><span style="color:#000000;"> None
        cur </span>=<span style="color:#000000;"> root
        stack </span>=<span style="color:#000000;"> []
        flag </span>=<span style="color:#000000;"> False
        </span><span style="color:#0000ff;">while</span> cur <span style="color:#0000ff;">or</span><span style="color:#000000;"> stack:
            </span><span style="color:#0000ff;">if</span><span style="color:#000000;"> cur:
                stack.append(cur)
                cur </span>=<span style="color:#000000;"> cur.left
            </span><span style="color:#0000ff;">else</span><span style="color:#000000;">:
                cur </span>=<span style="color:#000000;"> stack.pop()
                </span><span style="color:#0000ff;">if</span><span style="color:#000000;"> flag:
                    </span><span style="color:#0000ff;">return</span><span style="color:#000000;"> cur 
                </span><span style="color:#0000ff;">if</span> cur ==<span style="color:#000000;"> p:
                    flag </span>=<span style="color:#000000;"> True 
                cur </span>=<span style="color:#000000;"> cur.right
        </span><span style="color:#0000ff;">return</span> None</pre> 
 </div> 
 <p>后面这种解法可以持续不断的进行下去.查找第一个后继,第二个后继,等等,所以在Binary Search Tree Iterator这题中有应用</p> 
 <p> </p> 
</div> 
<p>转载于:https://www.cnblogs.com/sherylwang/p/5660384.html</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/877900cba23ba07da761682206bf1d37/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Sybase数据库在UNIX和Windows上的实施和管理 内容简介和目录</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/25764b56cb49024cb30afaac84586dc8/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Longest Substring Without Repeating Characters</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>