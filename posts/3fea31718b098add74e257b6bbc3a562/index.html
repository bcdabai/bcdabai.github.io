<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43;设计模式介绍、分类与设计模式原则 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C&#43;&#43;设计模式介绍、分类与设计模式原则" />
<meta property="og:description" content="目录
一、设计模式定义
二、设计模式的优点
三、设计模式缺点
四、设计模式中的抽象思维
五、抽象的方法
六、设计模式应用场景
七、设计模式分类
八、设计模式八大原则
1、依赖倒置原则（DIP）
2、开放封闭原则（OCP）
3、单一职责原则（SRP）
4、Liskov替换原则（LSP）
5、接口隔离原则（ISP）
6、优先使用对象组合，而不是类继承
7、封装变化点
8、针对接口编程，而不是针对实现编程
九、设计模式使用场景
附加知识
（1）C&#43;&#43;面向对象三种访问修饰符
（2）父类析构函数必须为虚函数
（3）override关键字使用
（4）final关键字使用
（5）父类对象可以与子类对象相互转化吗？
（6）虚函数、虚函数表介绍
一、设计模式定义 是一套被反复使用的代码设计经验的总结，是经过提炼的出色设计方法。设计模式主要是指面向对象这种编程模型下的设计模式；把变化与稳定的分割，管理变化，提高复用（稳定的部分可以封装为基类或者方法接口，使用子类应对变化）。设计模式可以更好地适应需求地变化，将变化来的代码修改影响减为最小。
二、设计模式的优点 设计模式一般应用于大型项目中，设计模式可以使各模块之间的代码灵活性和可复用性增强。
灵活性是指：可扩展性和低耦合型；增加新的功能，不需要大范围修改代码。
可复用性是指：可以到处重复使用，面向对象的三大特性：封装、继承、多态。泛型编程。面向对象程序设计原则之一：单一原则（一个类只干好一件事，不涉及其他事物）
三、设计模式缺点 代码的复杂度增加，增加了学习和阅读的负担，设计模式在一定程序会降低代码运行效率（对于带来的优点其下降运行效率一般可忽略）。
应用设计模式不当导致的代码灵活性、可复用性、可读性下降。
四、设计模式中的抽象思维 抽象思维强调对象的本质属性，主要用于一些软件设计中的解耦合的过程。
抽象思维的概念：能从事物中抽取出或者提炼出一些本质的，共性的内容，把这些共性的内容组合到一起封装成一个类或者方法。继承抽象类的子类都有不同的特点进行扩展。
五、抽象的方法 1、分解法：把一个复杂的事物分解成若干个单一功能的事物。
2、抽象法：从每个简单的事物中，抽象出本质的内容，封装起来。抽象法是设计模式的本质。
六、设计模式应用场景 通常应用于大型项目（几万到几十万行代码及以上项目），不建议应用于小型项目（小型项目要是适合也可使用设计模式）。对于大量重复性代码，需要使用设计模式进行设计，提高代码扩展性。
七、设计模式分类 常用的设计模式可以分为三大类：行为型模式、创建型模式、结构型模式
（1）创建型模式有6种：简单工厂模式(Simple Factory)、工厂方法模式(Factory Method)、抽象工厂模式(Abstract Factory)、单例模式(Singleton)、原型模式(Prototype)、建造者模式(Builder)。
（2）结构性模式有7种：装饰模式(Decorator)、外观模式(Facade)、组合模式(Composite)、享元模式(Flyweight)、代理模式(Proxy)、适配器模式(Adapter)、桥接模式(Bridge)
（3）行为型模式包括的设计模式有11种：模板方法模式(Template Method)、策略模式(Strategy)、观察者模式(Observer)、命令模式(Command)、迭代器模式(Iterator)、状态模式(State)、
中介模式(Mediator)、备忘录模式(Memento)、职责链模式(Chain Of Responsibility)、解释器模式(Interpreter)、访问者模式(Visitor)。
创建型模式定义：关注如何创建对象，将对象的创建和使用相互分离（解耦），取代传统对象创建方式带来的扩展性差的问题。
结构型模式：关注对象之间的关系。涉及如何组合各种对象以便获得更加灵活的结构，通过继承以及更多的关系组合获得更加灵活的程序结构。达到简化设计模式。
行为模式定义：关注对象的行为或者交互方面的内容，主要涉及算法和对象之间的职责分配。通过使用对象组合，行为模式可以描述一组对象如何协作来完成一个整体任务。
注意：设计模式代码一般不是一次设计设计好的，是多次修改而成。软件开发需求变化是频繁的，尝试寻找变化点，把变化部分和稳定部分分离开发，在变化的地方使用设计模式。
八、设计模式八大原则 任何设计模式的代码需要符合设计模式的原则，设计模式的原则如下：
1、依赖倒置原则（DIP） （1）高层模块（稳定）不应该依赖于低层模块（变化），二者都应该依赖于抽象（稳定）。
（2）抽象（稳定）不应该依赖于实现细节（变化），实现细节应该依赖于抽象（稳定）。
（1）中的高层模块指的是调用低层变化的Caller类对象或者方法，变化的低层模块指的是待调用Concre1、Concret2、、、对象或方法。抽象指的是对具有共同特征一类事物的抽象类。 （2）中的抽象跟（1）一致。实现细节指的是继承于抽象的具体类的子类，并对基类中的虚函数进行重写override。抽象类中不能依赖子类中的变化。 倒置原则较为重要，写个demo，如下：
#include &lt;iostream&gt; #include &lt;vector&gt; class AbsProduct { public: virtual void color(){}; virtual ~AbsProduct(){}; }; class Caller { public: std::vector&lt;AbsProduct*&gt;vecProducts; //高层模块依赖于抽象，使用指针，才可以使用多态应对变化。 void PrintProductColor(){ for(unsigned int i = 0;i &lt; vecProducts." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/3fea31718b098add74e257b6bbc3a562/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-06-14T22:00:09+08:00" />
<meta property="article:modified_time" content="2023-06-14T22:00:09+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43;设计模式介绍、分类与设计模式原则</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AE%9A%E4%B9%89-toc" style="margin-left:40px;"><a href="#%E4%B8%80%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AE%9A%E4%B9%89" rel="nofollow">一、设计模式定义</a></p> 
<p id="%E4%BA%8C%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%BC%98%E7%82%B9-toc" style="margin-left:40px;"><a href="#%E4%BA%8C%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%BC%98%E7%82%B9" rel="nofollow">二、设计模式的优点</a></p> 
<p id="%E4%B8%89%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%BC%BA%E7%82%B9-toc" style="margin-left:40px;"><a href="#%E4%B8%89%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%BC%BA%E7%82%B9" rel="nofollow">三、设计模式缺点</a></p> 
<p id="%E5%9B%9B%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%AD%E7%9A%84%E6%8A%BD%E8%B1%A1%E6%80%9D%E7%BB%B4-toc" style="margin-left:40px;"><a href="#%E5%9B%9B%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%AD%E7%9A%84%E6%8A%BD%E8%B1%A1%E6%80%9D%E7%BB%B4" rel="nofollow">四、设计模式中的抽象思维</a></p> 
<p id="%E4%BA%94%E3%80%81%E6%8A%BD%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95-toc" style="margin-left:40px;"><a href="#%E4%BA%94%E3%80%81%E6%8A%BD%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95" rel="nofollow">五、抽象的方法</a></p> 
<p id="%E5%85%AD%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-toc" style="margin-left:40px;"><a href="#%E5%85%AD%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF" rel="nofollow">六、设计模式应用场景</a></p> 
<p id="%E4%B8%83%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%88%86%E7%B1%BB-toc" style="margin-left:40px;"><a href="#%E4%B8%83%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%88%86%E7%B1%BB" rel="nofollow">七、设计模式分类</a></p> 
<p id="%E5%85%AB%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%85%AB%E5%A4%A7%E5%8E%9F%E5%88%99-toc" style="margin-left:40px;"><a href="#%E5%85%AB%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%85%AB%E5%A4%A7%E5%8E%9F%E5%88%99" rel="nofollow">八、设计模式八大原则</a></p> 
<p id="1%E3%80%81%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE%E5%8E%9F%E5%88%99%EF%BC%88DIP%EF%BC%89-toc" style="margin-left:80px;"><a href="#1%E3%80%81%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE%E5%8E%9F%E5%88%99%EF%BC%88DIP%EF%BC%89" rel="nofollow">1、依赖倒置原则（DIP）</a></p> 
<p id="2%E3%80%81%E5%BC%80%E5%8F%91%E5%B0%81%E9%97%AD%E5%8E%9F%E5%88%99%EF%BC%88OCP%EF%BC%89-toc" style="margin-left:80px;"><a href="#2%E3%80%81%E5%BC%80%E5%8F%91%E5%B0%81%E9%97%AD%E5%8E%9F%E5%88%99%EF%BC%88OCP%EF%BC%89" rel="nofollow">2、开放封闭原则（OCP）</a></p> 
<p id="3%E3%80%81%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99%EF%BC%88SRP%EF%BC%89-toc" style="margin-left:80px;"><a href="#3%E3%80%81%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99%EF%BC%88SRP%EF%BC%89" rel="nofollow">3、单一职责原则（SRP）</a></p> 
<p id="4%E3%80%81Liskov%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99%EF%BC%88LSP%EF%BC%89-toc" style="margin-left:80px;"><a href="#4%E3%80%81Liskov%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99%EF%BC%88LSP%EF%BC%89" rel="nofollow">4、Liskov替换原则（LSP）</a></p> 
<p id="5%E3%80%81%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99%EF%BC%88ISP%EF%BC%89-toc" style="margin-left:80px;"><a href="#5%E3%80%81%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99%EF%BC%88ISP%EF%BC%89" rel="nofollow">5、接口隔离原则（ISP）</a></p> 
<p id="6%E3%80%81%E4%BC%98%E5%85%88%E4%BD%BF%E7%94%A8%E5%AF%B9%E8%B1%A1%E7%BB%84%E5%90%88%EF%BC%8C%E8%80%8C%E4%B8%8D%E6%98%AF%E7%B1%BB%E7%BB%A7%E6%89%BF-toc" style="margin-left:80px;"><a href="#6%E3%80%81%E4%BC%98%E5%85%88%E4%BD%BF%E7%94%A8%E5%AF%B9%E8%B1%A1%E7%BB%84%E5%90%88%EF%BC%8C%E8%80%8C%E4%B8%8D%E6%98%AF%E7%B1%BB%E7%BB%A7%E6%89%BF" rel="nofollow">6、优先使用对象组合，而不是类继承</a></p> 
<p id="7%E3%80%81%E5%B0%81%E8%A3%85%E5%8F%98%E5%8C%96%E7%82%B9-toc" style="margin-left:80px;"><a href="#7%E3%80%81%E5%B0%81%E8%A3%85%E5%8F%98%E5%8C%96%E7%82%B9" rel="nofollow">7、封装变化点</a></p> 
<p id="8%E3%80%81%E9%92%88%E5%AF%B9%E6%8E%A5%E5%8F%A3%E7%BC%96%E7%A8%8B%EF%BC%8C%E8%80%8C%E4%B8%8D%E6%98%AF%E9%92%88%E5%AF%B9%E5%AE%9E%E7%8E%B0%E7%BC%96%E7%A8%8B-toc" style="margin-left:80px;"><a href="#8%E3%80%81%E9%92%88%E5%AF%B9%E6%8E%A5%E5%8F%A3%E7%BC%96%E7%A8%8B%EF%BC%8C%E8%80%8C%E4%B8%8D%E6%98%AF%E9%92%88%E5%AF%B9%E5%AE%9E%E7%8E%B0%E7%BC%96%E7%A8%8B" rel="nofollow">8、针对接口编程，而不是针对实现编程</a></p> 
<p id="%E4%B9%9D%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-toc" style="margin-left:40px;"><a href="#%E4%B9%9D%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF" rel="nofollow">九、设计模式使用场景</a></p> 
<p id="%E9%99%84%E5%8A%A0%E7%9F%A5%E8%AF%86-toc" style="margin-left:40px;"><a href="#%E9%99%84%E5%8A%A0%E7%9F%A5%E8%AF%86" rel="nofollow">附加知识</a></p> 
<p id="%EF%BC%881%EF%BC%89C%2B%2B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E7%A7%8D%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6-toc" style="margin-left:40px;"><a href="#%EF%BC%881%EF%BC%89C%2B%2B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E7%A7%8D%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6" rel="nofollow">（1）C++面向对象三种访问修饰符</a></p> 
<p id="%C2%A0%EF%BC%882%EF%BC%89%E7%88%B6%E7%B1%BB%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E5%BF%85%E9%A1%BB%E4%B8%BA%E8%99%9A%E5%87%BD%E6%95%B0-toc" style="margin-left:40px;"><a href="#%C2%A0%EF%BC%882%EF%BC%89%E7%88%B6%E7%B1%BB%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E5%BF%85%E9%A1%BB%E4%B8%BA%E8%99%9A%E5%87%BD%E6%95%B0" rel="nofollow">（2）父类析构函数必须为虚函数</a></p> 
<p id="%EF%BC%883%EF%BC%89override%E5%85%B3%E9%94%AE%E5%AD%97%E4%BD%BF%E7%94%A8-toc" style="margin-left:40px;"><a href="#%EF%BC%883%EF%BC%89override%E5%85%B3%E9%94%AE%E5%AD%97%E4%BD%BF%E7%94%A8" rel="nofollow">（3）override关键字使用</a></p> 
<p id="%EF%BC%884%EF%BC%89final%E5%85%B3%E9%94%AE%E5%AD%97%E4%BD%BF%E7%94%A8-toc" style="margin-left:40px;"><a href="#%EF%BC%884%EF%BC%89final%E5%85%B3%E9%94%AE%E5%AD%97%E4%BD%BF%E7%94%A8" rel="nofollow">（4）final关键字使用</a></p> 
<p id="%EF%BC%885%EF%BC%89%E7%88%B6%E7%B1%BB%E5%AF%B9%E8%B1%A1%E5%8F%AF%E4%BB%A5%E4%B8%8E%E5%AD%90%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9B%B8%E4%BA%92%E8%BD%AC%E5%8C%96%E5%90%97%EF%BC%9F-toc" style="margin-left:40px;"><a href="#%EF%BC%885%EF%BC%89%E7%88%B6%E7%B1%BB%E5%AF%B9%E8%B1%A1%E5%8F%AF%E4%BB%A5%E4%B8%8E%E5%AD%90%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9B%B8%E4%BA%92%E8%BD%AC%E5%8C%96%E5%90%97%EF%BC%9F" rel="nofollow">（5）父类对象可以与子类对象相互转化吗？</a></p> 
<p id="%EF%BC%886%EF%BC%89%E8%99%9A%E5%87%BD%E6%95%B0%E3%80%81%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8%E4%BB%8B%E7%BB%8D-toc" style="margin-left:40px;"><a href="#%EF%BC%886%EF%BC%89%E8%99%9A%E5%87%BD%E6%95%B0%E3%80%81%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8%E4%BB%8B%E7%BB%8D" rel="nofollow">（6）虚函数、虚函数表介绍</a></p> 
<hr id="hr-toc"> 
<p></p> 
<p></p> 
<h3 id="%E4%B8%80%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AE%9A%E4%B9%89">一、设计模式定义</h3> 
<p>     是一套被反复使用的代码设计经验的总结，是经过提炼的出色设计方法。设计模式主要是指面向对象这种编程模型下的设计模式；<strong>把变化与稳定的分割，管理变化，提高复用</strong>（稳定的部分可以封装为基类或者方法接口，使用子类应对变化）。<strong>设计模式可以更好地适应需求地变化</strong>，将变化来的代码修改影响减为最小。</p> 
<h3 id="%E4%BA%8C%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%BC%98%E7%82%B9"><br> 二、设计模式的优点</h3> 
<p>设计模式一般应用于大型项目中，设计模式可以使各模块之间的代码灵活性和可复用性增强。<br> 灵活性是指：可扩展性和低耦合型；增加新的功能，不需要大范围修改代码。<br> 可复用性是指：可以到处重复使用，面向对象的三大特性：封装、继承、多态。泛型编程。面向对象程序设计原则之一：单一原则（一个类只干好一件事，不涉及其他事物）</p> 
<p></p> 
<h3 id="%E4%B8%89%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%BC%BA%E7%82%B9">三、设计模式缺点</h3> 
<p> 代码的复杂度增加，增加了学习和阅读的负担，设计模式在一定程序会降低代码运行效率（对于带来的优点其下降运行效率一般可忽略）。<br> 应用设计模式不当导致的代码灵活性、可复用性、可读性下降。</p> 
<p></p> 
<h3 id="%E5%9B%9B%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%AD%E7%9A%84%E6%8A%BD%E8%B1%A1%E6%80%9D%E7%BB%B4">四、设计模式中的抽象思维</h3> 
<p>抽象思维强调对象的本质属性，主要用于一些软件设计中的解耦合的过程。<br> 抽象思维的概念：能从事物中抽取出或者提炼出一些<strong>本质的，共性的内容</strong>，把这些共性的内容组合到一起封装成一个类或者方法。继承抽象类的子类都有<strong>不同的特点进行扩展</strong>。</p> 
<h3 id="%E4%BA%94%E3%80%81%E6%8A%BD%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95"><br> 五、抽象的方法</h3> 
<p>1、分解法：把一个复杂的事物分解成若干个单一功能的事物。<br> 2、抽象法：从每个简单的事物中，抽象出本质的内容，封装起来。抽象法是设计模式的本质。</p> 
<p></p> 
<h3 id="%E5%85%AD%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF">六、设计模式应用场景</h3> 
<p>通常应用于大型项目（几万到几十万行代码及以上项目），不建议应用于小型项目（小型项目要是适合也可使用设计模式）。对于大量重复性代码，需要使用设计模式进行设计，提高代码扩展性。</p> 
<p></p> 
<h3 id="%E4%B8%83%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%88%86%E7%B1%BB">七、设计模式分类</h3> 
<p><strong>常用的设计模式可以分为三大类：行为型模式、创建型模式、结构型模式</strong><br> （1）创建型模式有6种：简单工厂模式(Simple Factory)、工厂方法模式(Factory Method)、抽象工厂模式(Abstract Factory)、单例模式(Singleton)、原型模式(Prototype)、建造者模式(Builder)。<br> （2）结构性模式有7种：装饰模式(Decorator)、外观模式(Facade)、组合模式(Composite)、享元模式(Flyweight)、代理模式(Proxy)、适配器模式(Adapter)、桥接模式(Bridge)<br> （3）行为型模式包括的设计模式有11种：模板方法模式(Template Method)、策略模式(Strategy)、观察者模式(Observer)、命令模式(Command)、迭代器模式(Iterator)、状态模式(State)、<br>     中介模式(Mediator)、备忘录模式(Memento)、职责链模式(Chain Of Responsibility)、解释器模式(Interpreter)、访问者模式(Visitor)。<br>     <br><strong>创建型模式定义</strong>：关注如何创建对象，将对象的创建和使用相互分离（解耦），取代传统对象创建方式带来的扩展性差的问题。<br><strong>结构型模式：</strong>关注对象之间的关系。涉及如何组合各种对象以便获得更加灵活的结构，通过继承以及更多的关系组合获得更加灵活的程序结构。达到简化设计模式。<br><strong>行为模式定义：</strong>关注对象的行为或者交互方面的内容，主要涉及算法和对象之间的职责分配。通过使用对象组合，行为模式可以描述一组对象如何协作来完成一个整体任务。</p> 
<p></p> 
<p><strong>注意：设计模式代码一般不是一次设计设计好的，是多次修改而成。</strong>软件开发需求变化是频繁的，尝试寻找变化点，把变化部分和稳定部分分离开发，在变化的地方使用设计模式。</p> 
<p></p> 
<h3 id="%E5%85%AB%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%85%AB%E5%A4%A7%E5%8E%9F%E5%88%99">八、设计模式八大原则</h3> 
<p>任何设计模式的代码需要符合设计模式的原则，设计模式的原则如下：</p> 
<h4 id="1%E3%80%81%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE%E5%8E%9F%E5%88%99%EF%BC%88DIP%EF%BC%89">1、依赖倒置原则（DIP）</h4> 
<p>（1）高层模块（稳定）不应该依赖于低层模块（变化），二者都应该依赖于抽象（稳定）。</p> 
<p>（2）抽象（稳定）不应该依赖于实现细节（变化），实现细节应该依赖于抽象（稳定）。</p> 
<pre><code class="language-cpp">（1）中的高层模块指的是调用低层变化的Caller类对象或者方法，变化的低层模块指的是待调用Concre1、Concret2、、、对象或方法。抽象指的是对具有共同特征一类事物的抽象类。
（2）中的抽象跟（1）一致。实现细节指的是继承于抽象的具体类的子类，并对基类中的虚函数进行重写override。抽象类中不能依赖子类中的变化。</code></pre> 
<p> 倒置原则较为重要，写个demo，如下：</p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
class AbsProduct
{
public:
    virtual void  color(){};
    virtual ~AbsProduct(){};
};

class Caller
{
public:
    std::vector&lt;AbsProduct*&gt;vecProducts;    //高层模块依赖于抽象，使用指针，才可以使用多态应对变化。

    void PrintProductColor(){
        for(unsigned int i = 0;i &lt; vecProducts.size(); i++)
        {
            vecProducts.at(i)-&gt;color();
        }

    };
};

class Product1: public AbsProduct
{
public:
    virtual void  color(){
        std::cout &lt;&lt; "Product1 color" &lt;&lt; std::endl;
    };
};

class Product2: public AbsProduct
{
public:
    virtual void  color(){
        std::cout &lt;&lt; "Product2 color" &lt;&lt; std::endl;
    };
};

int main()
{

    Caller obj;
    AbsProduct *pro1 = new  Product1();
    obj.vecProducts.push_back(pro1);

    AbsProduct *pro2 = new  Product2();
    obj.vecProducts.push_back(pro2);

    obj.PrintProductColor();

    delete pro1;
    pro1 = nullptr;
    delete pro2;
    pro2 = nullptr;
    obj.vecProducts.clear();
    return 0;
}
</code></pre> 
<p>运行结果如下：</p> 
<p><img alt="" height="81" src="https://images2.imgbox.com/79/f4/BiIJbDER_o.png" width="728"></p> 
<p>上述代码中的高层模块Caller是稳定的，低层模块是具体的产品Product1，产品Product2，产品Product3，，，等类型产品，特性是不同的。高层模块需要调用调用低层模块的接口， 而低层的多样不稳定，会使代码应对需求变化的改动较大。为使代码更具有应对变化的能力，将底层模块各种产品的共同属性抽象出一个类型，这样高层模块就会依赖抽象，低层模块也就依赖抽象，这样这个代码模块的可复用性就得到了加强。倒置是指高层的主程序调用依赖抽象接口，在抽象接口具体运行时的晚绑定的接口实现过程。</p> 
<h4 id="2%E3%80%81%E5%BC%80%E5%8F%91%E5%B0%81%E9%97%AD%E5%8E%9F%E5%88%99%EF%BC%88OCP%EF%BC%89">2、开放封闭原则（OCP）</h4> 
<p>（1）对扩展开放，对更改封闭。</p> 
<p>（2）类模块应该是可扩展的，但是不可修改。</p> 
<p>解释：（1）中的扩展指的是应对需求的变化可以创建一个继承父类的新类。对更改封闭指的是改变是在子类内部。</p> 
<h4 id="3%E3%80%81%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99%EF%BC%88SRP%EF%BC%89">3、单一职责原则（SRP）</h4> 
<p>（1）一个类应该仅有一个引起它变化的原因。</p> 
<p>（2）变化的方向隐含着该类的责任。</p> 
<h4 id="4%E3%80%81Liskov%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99%EF%BC%88LSP%EF%BC%89">4、Liskov替换原则（LSP）</h4> 
<p>（1）子类必须能够替换它们的基类（IS-A）</p> 
<p>（2）继承表达类型抽象。</p> 
<p>注意：父类让子类继承的方法注意访问修饰符。</p> 
<h4 id="5%E3%80%81%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99%EF%BC%88ISP%EF%BC%89">5、接口隔离原则（ISP）</h4> 
<p>（1）不应该强迫客户程序依赖它们不用的方法。（能用protected不用public）</p> 
<p>（2）接口应该小而完备。</p> 
<h4 id="6%E3%80%81%E4%BC%98%E5%85%88%E4%BD%BF%E7%94%A8%E5%AF%B9%E8%B1%A1%E7%BB%84%E5%90%88%EF%BC%8C%E8%80%8C%E4%B8%8D%E6%98%AF%E7%B1%BB%E7%BB%A7%E6%89%BF">6、优先使用对象组合，而不是类继承</h4> 
<p>（1）类继承通常为“白箱复用”，对象组合通常为“黑箱复用”。</p> 
<p>（2）继承在某种程度上破坏了封装性，子类父类耦合度高。</p> 
<p>（3）而对象组合则只要求被组合的对象具有良好定义的接口，耦合度低。</p> 
<h4 id="7%E3%80%81%E5%B0%81%E8%A3%85%E5%8F%98%E5%8C%96%E7%82%B9">7、封装变化点</h4> 
<p>使用<strong>封装来创建对象之间的分界层</strong>，让设计者可以在分界层的一侧进行修改，而不会对另一侧产生不良的影响，从而实现层次间的松耦合。</p> 
<h4 id="8%E3%80%81%E9%92%88%E5%AF%B9%E6%8E%A5%E5%8F%A3%E7%BC%96%E7%A8%8B%EF%BC%8C%E8%80%8C%E4%B8%8D%E6%98%AF%E9%92%88%E5%AF%B9%E5%AE%9E%E7%8E%B0%E7%BC%96%E7%A8%8B">8、针对接口编程，而不是针对实现编程</h4> 
<p>（1）不将变量类型声明为某个特定的具体类，而是声明为某个接口。（具体类不是绝对化，如vector，string,等）</p> 
<p>（2）客户程序无需获知对象的具体类型，只需要知道对象所具有的接口。</p> 
<p>（3）减少系统中各部分的依赖关系，从而实现“高内聚，松耦合”的类型设计方案。</p> 
<p></p> 
<h3 id="%E4%B9%9D%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF">九、设计模式使用场景</h3> 
<p>1、如果代码设计中存在稳定和变化的结构，则可以使用设计模式来管理变化，提高复用。</p> 
<p>2、如果代码设计中都是稳定结构，不存在变化结构部分，则不使用设计模式。</p> 
<p>3、如果代码设计中都是变化结构，不存稳定的结构部分，则不使用设计模式。</p> 
<p></p> 
<p></p> 
<p></p> 
<h3 id="%E9%99%84%E5%8A%A0%E7%9F%A5%E8%AF%86"><strong>附加知识</strong></h3> 
<p>设计模式主要利用类的多态、继承、封装方法对事物进行抽象设计。并<strong>对共用的属性和方法抽象成基类，对变化的属性使用虚函数进行多态设计。</strong>对面向对象的相关知识点可以进行回顾</p> 
<p></p> 
<h3 id="%EF%BC%881%EF%BC%89C%2B%2B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E7%A7%8D%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6">（1）C++面向对象三种访问修饰符</h3> 
<p>public: 允许该类函数、子类函数、友元函数、该类对象可以访问。<br> protected：只允许该类函数、子类函数、友元函数可以访问。<br> private：只允许本类的成员函数可以访问。</p> 
<p>具体可参考：</p> 
<p><a href="https://blog.csdn.net/scottly1/article/details/24354489" title="C++中public、protected、private的区别_风雨也无晴的博客-CSDN博客">C++中public、protected、private的区别_风雨也无晴的博客-CSDN博客</a></p> 
<p><a href="https://blog.csdn.net/hanxiaoyong_/article/details/81152405" title="友元(友元函数、友元类和友元成员函数) C++_夜雨听萧瑟的博客-CSDN博客">友元(友元函数、友元类和友元成员函数) C++_夜雨听萧瑟的博客-CSDN博客</a><br>     </p> 
<h3 id="%C2%A0%EF%BC%882%EF%BC%89%E7%88%B6%E7%B1%BB%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E5%BF%85%E9%A1%BB%E4%B8%BA%E8%99%9A%E5%87%BD%E6%95%B0">（2）父类析构函数必须为虚函数</h3> 
<p>定义父类对象初始化时，让父类对象实际指向子类。同时父类析构函数必须为虚函数，这样在父类对象析构时，不会调用子类的虚构函数，导致子类的对象不能释放，造成子类对象的内存泄露。具体可参考：<a href="https://blog.csdn.net/doubleintfloat/article/details/111186955" title="为什么父类析构函数必须为虚函数_父类析构函数不是虚函数会怎么样_IM-STONE的博客-CSDN博客">为什么父类析构函数必须为虚函数_父类析构函数不是虚函数会怎么样_IM-STONE的博客-CSDN博客</a></p> 
<h3></h3> 
<h3 id="%EF%BC%883%EF%BC%89override%E5%85%B3%E9%94%AE%E5%AD%97%E4%BD%BF%E7%94%A8">（3）override关键字使用</h3> 
<p>在子类中重写父类的虚函数时，在其后面加上override关键字，如果父类不存在该虚函数，则编译不通过。</p> 
<pre><code class="language-cpp">class A
{
public:
   virtual void FunA()=0; //纯虚函数，子类必须实现该函数。
   virtual int  FunB(){}; //虚函数，子类可以重写，也可以不用重写
}

class B:public A
{
 public:
  void FunA()override{};
  int FunB()override{};
}</code></pre> 
<p><a href="https://blog.csdn.net/han8040laixin/article/details/81703244?spm=1001.2101.3001.6650.4&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-4-81703244-blog-102612061.235%5Ev36%5Epc_relevant_anti_vip&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-4-81703244-blog-102612061.235%5Ev36%5Epc_relevant_anti_vip&amp;utm_relevant_index=9" title="C++:重载，重定义，重写的区别_重定义和重写的区别__来信的博客-CSDN博客">C++:重载，重定义，重写的区别_重定义和重写的区别__来信的博客-CSDN博客</a></p> 
<h3 id="%EF%BC%884%EF%BC%89final%E5%85%B3%E9%94%AE%E5%AD%97%E4%BD%BF%E7%94%A8">（4）final关键字使用</h3> 
<p>如果当前类不能有派生类，则可以在类后面添加关键字final；如果不想该虚函数不被重写，在该虚函数后面添加final。如果继承final类或者重载final修饰的函数，会导致编译报错。</p> 
<pre><code class="language-cpp">class A final  //用法1：该类不能被继承。
{}


class B
{
public:
    virtual void fun()final{}; //用法2：该虚函数不能被重写。
}</code></pre> 
<p><a href="https://blog.csdn.net/mayue_web/article/details/88406527" title="C++ final关键字_mayue_csdn的博客-CSDN博客">C++ final关键字_mayue_csdn的博客-CSDN博客</a></p> 
<p></p> 
<h3 id="%EF%BC%885%EF%BC%89%E7%88%B6%E7%B1%BB%E5%AF%B9%E8%B1%A1%E5%8F%AF%E4%BB%A5%E4%B8%8E%E5%AD%90%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9B%B8%E4%BA%92%E8%BD%AC%E5%8C%96%E5%90%97%EF%BC%9F">（5）父类对象可以与子类对象相互转化吗？</h3> 
<p> 父类对象与子类对象可以相互转换，前提是父类对象一定是用子类对象初始化的。子类对象是对父类对象的扩展，子类属性一般是大于父类属性。</p> 
<p>具体分析可参考：<a href="https://blog.csdn.net/qq_36470686/article/details/83385545" title="父类对象和子类对象之间可以相互转换吗_父对象转成子对象_扶公瑾以苏的博客-CSDN博客">父类对象和子类对象之间可以相互转换吗_父对象转成子对象_扶公瑾以苏的博客-CSDN博客</a></p> 
<h3 id="%EF%BC%886%EF%BC%89%E8%99%9A%E5%87%BD%E6%95%B0%E3%80%81%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8%E4%BB%8B%E7%BB%8D">（6）虚函数、虚函数表介绍</h3> 
<p>可参考下面链接</p> 
<p><a href="https://blog.csdn.net/salmonwilliam/article/details/114259314" title="(超重要)构造函数为什么不能为虚函数？析构函数为什么要虚函数？_构造函数能不能为虚函数_HeisenbergWDG的博客-CSDN博客">(超重要)构造函数为什么不能为虚函数？析构函数为什么要虚函数？_构造函数能不能为虚函数_HeisenbergWDG的博客-CSDN博客</a></p> 
<p><a href="https://blog.csdn.net/qq_20817327/article/details/108859161" title="C++中虚函数、虚指针和虚表详解_bob62856的博客-CSDN博客">C++中虚函数、虚指针和虚表详解_bob62856的博客-CSDN博客</a></p> 
<p> <a href="https://blog.csdn.net/qq_28114615/article/details/98041319" title="C++中的虚函数表和虚函数在内存中的位置_虚函数表存在什么位置_HerofH_的博客-CSDN博客">C++中的虚函数表和虚函数在内存中的位置_虚函数表存在什么位置_HerofH_的博客-CSDN博客</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/1514d716c608e4bf722947cdff328894/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">原生小程序 微信小程序 使用ucharts</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/97a0287873361be005a634865c66366b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Sonatype Nexus Repository配置搭建</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>