<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>scrapy爬虫实战 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="scrapy爬虫实战" />
<meta property="og:description" content="1、打开终端，在命令行下切换到要建立项目的文件夹：
使用scrapy startproject [项目名]，例如：scrapy startproject qsbk。这时就会在相应文件夹下生成scrapy项目：
然后用pycharm打开。scrapy.cfg是整个项目的配置文件。items.py存储的是所有爬取数据的模型。middlewares.py是中间件。pipelines.py用于处理爬取到的数据。
2、进入项目文件夹，比如：cd qsbk，然后使用scrapy genspider 项目名 域名新建一个爬虫，例如：scrapy genspider qsbk_spider &#39;qiushibaike.com&#39;:
然后就会多出一个文件：
它会自动给你生成这样一个类。
3、将settings.py中的ROBOTSTXT_OBEY设置为False，因为如果为True的话就有可能抓取不到数据。然后加上头部信息：
4、看到QsbkSpiderSpider这个类：
class QsbkSpiderSpider(scrapy.Spider): name = &#34;qsbk_spider&#34; allowed_domains = [&#34;qiushibaike.com&#34;] start_urls = [&#39;http://qiushibaike.com/&#39;] def parse(self, response): pass 它必须继承自scrapy.Spider类，然后实现三个属性：爬虫的名字、允许的域名、开始的url。
5、对要爬取的网站做一个分析：
我们发现它是分页的形式，并且每一页只有一个数字不同：https://www.qiushibaike.com/8hr/page/1/，因此把url替换为这个url。
然后打印一下response：
def parse(self, response): print(&#39;*&#39;*40) print(response) print(&#39;*&#39;*40) 接着使用命令来运行一下：
点击show in Explorer进入到项目当中:
然后在此处打开命令行，输入命令scrapy crawl qsbk_spider，crawl就是爬的意思。如果出现错误，则输入：worlon crawler-env。然后就爬取到了一些信息：
再打印一下它的类型：
然后导入这个类型：from scrapy.http.response.html import HtmlResponse。将鼠标放在这段文字上面按一下Ctrl&#43;B跳到这里：
然后发现它继承自TextResponse，然后再进去看一下：
可以获取它的encoding和文本。然后提取数据的方法有Xpath和CSS：
6、分析如何拿到其中的每一个段子
我们发现所有的段子都在这个div下，然后其中的每一个子div就代表一个段子。所以现在只需要获取这个div下的所有直接子div就可以获取所有的段子。然后我们打印一下它的类型：
print(&#39;=&#39;*40) print(type(response.xpath(&#39;//div[@class=&#34;content-block clearfix&#34;]&#39;))) print(&#39;=&#39; * 40) 由于每次都需要再命令行中去执行，因此我们新建一个python文件start.py：
from scrapy import cmdline cmdline." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/a12422b7e02cf6b4bf93aecb1de805a4/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-01-24T11:31:47+08:00" />
<meta property="article:modified_time" content="2019-01-24T11:31:47+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">scrapy爬虫实战</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>1、打开终端，在命令行下切换到要建立项目的文件夹：<br>                                                                            <img alt="" class="has" height="73" src="https://images2.imgbox.com/f9/87/6HZfbfbV_o.png" width="189"></p> 
<p>使用scrapy startproject [项目名]，例如：scrapy startproject qsbk。这时就会在相应文件夹下生成scrapy项目：</p> 
<p>                                             <img alt="" class="has" height="243" src="https://images2.imgbox.com/cb/f3/Jo6HqGLE_o.png" width="408"></p> 
<p>然后用pycharm打开。scrapy.cfg是整个项目的配置文件。items.py存储的是所有爬取数据的模型。middlewares.py是中间件。pipelines.py用于处理爬取到的数据。</p> 
<p>2、进入项目文件夹，比如：cd qsbk，然后使用scrapy genspider 项目名 域名新建一个爬虫，例如：scrapy genspider qsbk_spider  'qiushibaike.com':</p> 
<p>                              <img alt="" class="has" height="82" src="https://images2.imgbox.com/c6/bb/uPbyN8Js_o.png" width="569"></p> 
<p>然后就会多出一个文件：</p> 
<p>                                                                   <img alt="" class="has" height="76" src="https://images2.imgbox.com/39/bd/jnPySlqK_o.png" width="249"></p> 
<p>它会自动给你生成这样一个类。</p> 
<p>3、将settings.py中的ROBOTSTXT_OBEY设置为False，因为如果为True的话就有可能抓取不到数据。然后加上头部信息：<br>           <img alt="" class="has" height="241" src="https://images2.imgbox.com/20/ff/f6HZzFDD_o.png" width="827"></p> 
<p>4、看到QsbkSpiderSpider这个类：</p> 
<pre class="has"><code>class QsbkSpiderSpider(scrapy.Spider):
    name = "qsbk_spider"
    allowed_domains = ["qiushibaike.com"]
    start_urls = ['http://qiushibaike.com/']

    def parse(self, response):
        pass</code></pre> 
<p>它必须继承自scrapy.Spider类，然后实现三个属性：爬虫的名字、允许的域名、开始的url。</p> 
<p>5、对要爬取的网站做一个分析：</p> 
<p>                                       <img alt="" class="has" height="146" src="https://images2.imgbox.com/b9/a9/mUs4ChBO_o.png" width="516"></p> 
<p>我们发现它是分页的形式，并且每一页只有一个数字不同：https://www.qiushibaike.com/8hr/page/1/，因此把url替换为这个url。</p> 
<p>然后打印一下response：</p> 
<pre class="has"><code>    def parse(self, response):
        print('*'*40)
        print(response)
        print('*'*40)</code></pre> 
<p>接着使用命令来运行一下：</p> 
<p>点击show in Explorer进入到项目当中:</p> 
<p>                                                         <img alt="" class="has" height="479" src="https://images2.imgbox.com/b2/8a/dK2VvBWe_o.png" width="285"></p> 
<p>                                                <img alt="" class="has" height="201" src="https://images2.imgbox.com/f5/e1/ly9wbAZD_o.png" width="366"></p> 
<p>                                                 <img alt="" class="has" height="239" src="https://images2.imgbox.com/55/aa/4XOQIoHe_o.png" width="404"></p> 
<p>然后在此处打开命令行，输入命令scrapy crawl qsbk_spider，crawl就是爬的意思。如果出现错误，则输入：worlon crawler-env。然后就爬取到了一些信息：</p> 
<p>                                                          <img alt="" class="has" height="69" src="https://images2.imgbox.com/5e/48/v3gQiMG8_o.png" width="320"></p> 
<p>再打印一下它的类型：</p> 
<p>                                                      <img alt="" class="has" height="77" src="https://images2.imgbox.com/c5/5e/ppxk5i1f_o.png" width="343"></p> 
<p>然后导入这个类型：from scrapy.http.response.html import HtmlResponse。将鼠标放在这段文字上面按一下Ctrl+B跳到这里：</p> 
<p>                                           <img alt="" class="has" height="460" src="https://images2.imgbox.com/4e/aa/Uqw5ANQc_o.png" width="526"></p> 
<p>然后发现它继承自TextResponse，然后再进去看一下：</p> 
<p>                                                   <img alt="" class="has" height="470" src="https://images2.imgbox.com/d8/ab/f73avDWz_o.png" width="441"></p> 
<p>可以获取它的encoding和文本。然后提取数据的方法有Xpath和CSS：</p> 
<p>                                                       <img alt="" class="has" height="231" src="https://images2.imgbox.com/59/60/EHfytVop_o.png" width="402"></p> 
<p>6、分析如何拿到其中的每一个段子</p> 
<p>                                            <img alt="" class="has" height="299" src="https://images2.imgbox.com/0d/42/rAG83wZs_o.png" width="516"></p> 
<p>我们发现所有的段子都在这个div下，然后其中的每一个子div就代表一个段子。所以现在只需要获取这个div下的所有直接子div就可以获取所有的段子。然后我们打印一下它的类型：</p> 
<pre class="has"><code>print('='*40)
print(type(response.xpath('//div[@class="content-block clearfix"]')))
print('=' * 40)</code></pre> 
<p>                                                                        <img alt="" class="has" height="58" src="https://images2.imgbox.com/71/3f/Xa9BZkE3_o.png" width="325"></p> 
<p>由于每次都需要再命令行中去执行，因此我们新建一个python文件start.py：</p> 
<pre class="has"><code>from scrapy import cmdline

cmdline.execute('scrapy crawl qsbk_spider'.split())
# cmdline.execute(['scrapy','crawl','qsbk_spider'])</code></pre> 
<pre class="has"><code class="language-html">qsbk_spider.py的内容如下：</code></pre> 
<pre class="has"><code># -*- coding: utf-8 -*-
import scrapy
from scrapy.http.response.html import HtmlResponse

class QsbkSpiderSpider(scrapy.Spider):
    name = "qsbk_spider"
    allowed_domains = ["qiushibaike.com"]
    start_urls = ['https://www.qiushibaike.com/text/page/1/']

    def parse(self, response):
        duanzidivs = response.xpath('//div[@id="content-left"]/div')
        for duanzidiv in duanzidivs:
            author = duanzidiv.xpath(".//h2/text()").get().strip()#在当前标签下寻找h2标签，并获取它的文本并用strip()方法去掉前后的空白字符
            content = duanzidiv.xpath('.//div[@class="content"]//text()').getall()#因为文本信息在多个标签下面，所以用//表示查找所有的
            content = ''.join(content).strip()#由于返回的是一个列表，因此用这种方式将列表中的所有信息连接起来形成一个字符串
            print(content)</code></pre> 
<p>接下来要做到事情就是将数据保存下来，比如json文件或者csv文件，保存的工作就需要交给pipline去处理，在qsbk_spider.py文件中将数据移交给pipline：</p> 
<pre class="has"><code>duanzi  = {'作者':author,'段子':content}
            #将字典数据移交给pipline
            yield duanzi#把一个普通的函数变成一个生成器，这样一来，在遍历这个生成器的时候就会把数据一个一个的返回</code></pre> 
<p>然后来到pipline去写存储的代码，这个文件需要写三个方法：</p> 
<pre class="has"><code>class QsbkPipeline(object):
    #当爬虫打开以后就会调用这个函数
    def open_spider(self,spider):
        pass

    #在爬虫运行过程中如果传递了一些item进来就调用这个函数
    def process_item(self, item, spider):
        return item

    #当爬虫完成任务以后无事可干是就执行这个函数
    def close_spider(self,spider):
        pass</code></pre> 
<p>最终的pipline如下：</p> 
<pre class="has"><code>import csv
import json

class QsbkPipeline(object):
    def __init__(self):
        # self.fp = open('duanzi.csv','w',encoding='utf-8')
        self.fp = open('duanzi.json', 'w', encoding='utf-8')
        # fieldname = ['作者', '段子']
        # self.writer = csv.DictWriter(self.fp, fieldnames=fieldname)
        # self.writer.writeheader()

    #当爬虫打开以后就会调用这个函数
    def open_spider(self,spider):
        print('爬虫开始了...')

    #在爬虫运行过程中如果传递了一些item进来就调用这个函数
    def process_item(self, item, spider):
        item_json = json.dumps(item,ensure_ascii=False)
        self.fp.write(item_json+'\n')
        # self.writer.writerow(item)
        return item

    #当爬虫完成任务以后无事可干是就执行这个函数
    def close_spider(self,spider):
        self.fp.close()
        print('爬虫结束了...')</code></pre> 
<p>现在这个pipline还不能运行，如果想让它运行就要来到settings.py下面找到：ITEM_PIPELINES并取消注释：</p> 
<pre class="has"><code>ITEM_PIPELINES = {
   'qsbk.pipelines.QsbkPipeline': 300,
}</code></pre> 
<p>到目前为止爬取一个页面并经数据保存的代码就结束了，接下来我们再来优化一下，我们知道返回的数据是一个字典，但是scrapy建议我们针对一些这样的item，这些存储项，它已经建立好了这样的存储模型items.py，这个模型里面就有这样一些字段，比如说我们要存储这个段子的作者和内容就把这两个东西写到这里面来，在以后传入数据的时候就不要传入字典了，而是使用这里定义好的item：</p> 
<pre class="has"><code>class QsbkItem(scrapy.Item):
    author = scrapy.Field()
    content = scrapy.Field()</code></pre> 
<p>再回到qsbk_spider.py导入：from qsbk.items import QsbkItem：</p> 
<pre class="has"><code>    def parse(self, response):
        duanzidivs = response.xpath('//div[@id="content-left"]/div')
        for duanzidiv in duanzidivs:
            author = duanzidiv.xpath(".//h2/text()").get().strip()#在当前标签下寻找h2标签，并获取它的文本并用strip()方法去掉前后的空白字符
            content = duanzidiv.xpath('.//div[@class="content"]//text()').getall()#因为文本信息在多个标签下面，所以用//表示查找所有的
            content = ''.join(content).strip()#由于返回的是一个列表，因此用这种方式将列表中的所有信息连接起来形成一个字符串
            item = QsbkItem(author=author,content=content)
            #将字典数据移交给pipline
            yield item#把一个普通的函数变成一个生成器，这样一来，在遍历这个生成器的时候就会把数据一个一个的返回</code></pre> 
<p>这样的好处就是可以固定需要传入哪些参数，第二个好处就是不需要字典，只需要用这个类。但现在还是有一个问题，就是在pipline这个地方，它得到的是一个QsbkItem数据类型，而这个数据类型是不能直接被json所dump的，需要先转换为一个字典：</p> 
<pre class="has"><code class="language-html">item_json = json.dumps(dict(item),ensure_ascii=False)</code></pre> 
<p>接下来再对数据存储这块进行优化一下，在存储的时候我们是导入json模块，这样会比较乱，需要先转换为字典才能写进去，其实scrapy为我们提供了一个导出器，一个导出json的东西：</p> 
<pre class="has"><code>from scrapy.exporters import JsonItemExporter#导入导出json的导出器

class QsbkPipeline(object):
    def __init__(self):
        self.fp = open('duanzi.json', 'wb')#导出器写入数据的时候是以二进制的方式写入的
        self.exporter = JsonItemExporter(self.fp,ensure_ascii=False,encoding='utf-8')
        self.exporter.start_exporting()#开始导入

    #当爬虫打开以后就会调用这个函数
    def open_spider(self,spider):
        print('爬虫开始了...')

    #在爬虫运行过程中如果传递了一些item进来就调用这个函数
    def process_item(self, item, spider):
        self.exporter.export_item(item)#直接将item扔进去而不需要转换为字典
        return item

    #当爬虫完成任务以后无事可干是就执行这个函数
    def close_spider(self,spider):
        self.exporter.finish_exporting()#完成导入
        self.fp.close()
        print('爬虫结束了...')</code></pre> 
<p>运行结果：</p> 
<p>                                                                   <img alt="" class="has" height="177" src="https://images2.imgbox.com/2a/b3/bcM8z2PX_o.png" width="202"></p> 
<p>发现所有数据是存放在一个列表中的，为了避免这个问题，可以换一种方式，导入JsonLinesItemExporter，而且开始结束都不需要了：</p> 
<pre class="has"><code>from scrapy.exporters import JsonLinesItemExporter

class QsbkPipeline(object):
    def __init__(self):
        self.fp = open('duanzi.json', 'wb')#导出器写入数据的时候是以二进制的方式写入的
        self.exporter = JsonLinesItemExporter(self.fp,ensure_ascii=False,encoding='utf-8')

    #当爬虫打开以后就会调用这个函数
    def open_spider(self,spider):
        print('爬虫开始了...')

    #在爬虫运行过程中如果传递了一些item进来就调用这个函数
    def process_item(self, item, spider):
        self.exporter.export_item(item)#直接将item扔进去而不需要转换为字典
        return item

    #当爬虫完成任务以后无事可干是就执行这个函数
    def close_spider(self,spider):
        self.fp.close()
        print('爬虫结束了...')</code></pre> 
<p>除此以外还有CsvItemExporter、XmlItemExporter等。</p> 
<p>到目前为止爬取一个页面就写完了，接下来看一下如何爬取所有页面的数据.</p> 
<p>首先我们需要获取下一页的链接：</p> 
<p>                                                         <img alt="" class="has" height="152" src="https://images2.imgbox.com/6f/a1/6cGxh5pH_o.png" width="210"></p> 
<p>                                       <img alt="" class="has" height="200" src="https://images2.imgbox.com/b1/90/2CowplJA_o.png" width="541"></p> 
<p>发现它在class="pagination"的ul标签下的最后一个li标签下，但有个问题是如果是到了最后一页，就没有下一页了，因此应该做一个区分，首先应该取到最后一个li标签：</p> 
<pre class="has"><code>class QsbkSpiderSpider(scrapy.Spider):
    name = "qsbk_spider"
    allowed_domains = ["qiushibaike.com"]
    start_urls = ['https://www.qiushibaike.com/text/page/1/']

    def parse(self, response):
        duanzidivs = response.xpath('//div[@id="content-left"]/div')
        based_domain = 'https://www.qiushibaike.com'
        for duanzidiv in duanzidivs:
            author = duanzidiv.xpath(".//h2/text()").get().strip()#在当前标签下寻找h2标签，并获取它的文本并用strip()方法去掉前后的空白字符
            content = duanzidiv.xpath('.//div[@class="content"]//text()').getall()#因为文本信息在多个标签下面，所以用//表示查找所有的
            content = ''.join(content).strip()#由于返回的是一个列表，因此用这种方式将列表中的所有信息连接起来形成一个字符串
            item = QsbkItem(author=author,content=content)
            #将字典数据移交给pipline
            yield item#把一个普通的函数变成一个生成器，这样一来，在遍历这个生成器的时候就会把数据一个一个的返回
        next_url = response.xpath('//ul[@class="pagination"]/li[last()]/a/@href').get()#找到下一页的url
        if not next_url:
            return
        else:
            yield scrapy.Request(based_domain+next_url,callback=self.parse)#再次执行parse方法</code></pre> 
<p>为了不让服务器识别这是一个爬虫或者将服务器弄垮了，因此在settings.py中将DOWNLOAD_DELAY = 1。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/99e028e331d2358fccab0edaa527d6f5/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">win服务器下利用vlmcsd搭建KMS服务器激活win10</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/81af9f111ab86e2889494c338547a9f0/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">秒懂设计模式之建造者模式（Builder pattern）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>