<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>JUC学习笔记——并发工具线程池 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="JUC学习笔记——并发工具线程池" />
<meta property="og:description" content="在本系列内容中我们会对JUC做一个系统的学习，本片将会介绍JUC的并发工具线程池
我们会分为以下几部分进行介绍：
线程池介绍自定义线程池模式之Worker ThreadJDK线程池Tomcat线程池Fork/Join 线程池介绍 我们在这一小节简单介绍一下线程池
线程池简介 首先我们先来介绍线程池的产生背景：
在最开始我们对应每一个任务，都会创建一个线程，但该方法极度耗费资源后来我们就产生了线程池，在线程池中规定存放指定数目的线程，由线程池的指定系统来控制接受任务以及处理任务的规定 我们给出一张线程池基本图：
自定义线程池 我们在这一小节根据线程池基本图来自定义一个线程池
自定义拒绝策略接口 我们先来介绍一下拒绝策略接口：
我们定义该接口是为了处理线程池中暂时无法接收的数据的内容我们可以在该接口的抽象方法中重新定义各种处理方法，实现多种方法处理我们直接定义一个接口，里面只有一个方法，后续我们可以采用Lambda表达式或者方法来调用 我们给出拒绝策略接口代码：
// 拒绝策略 // 这里采用T来代表接收任务类型，可能是Runnable类型也可能是其他类型线程 // 这里的reject就是抽象方法，我们后续直接采用Lambda表达式重新构造即可 // BlockingQueue是阻塞队列，我们在后续创建；task是任务，我们直接传入即可 @FunctionalInterface interface RejectPolicy&lt;T&gt;{ void reject(BlockingQueue&lt;T&gt; queue,T task); } 自定义任务队列 我们来介绍一下任务队列：
我们的任务队列从根本上来说就是由队列组成的里面会存放我们需要完成的任务，同时我们需要设置相关参数以及方法完成线程对任务的调取以及结束任务 我们给出任务队列代码：
class BlockingQueue&lt;T&gt;{ //阻塞队列，存放任务 private Deque&lt;T&gt; queue = new ArrayDeque&lt;&gt;(); //队列的最大容量 private int capacity; //锁 private ReentrantLock lock = new ReentrantLock(); //生产者条件变量 private Condition fullWaitSet = lock.newCondition(); //消费者条件变量 private Condition emptyWaitSet = lock.newCondition(); //构造方法 public BlockingQueue(int capacity) { this." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/3cc4a7d4ca532c5f7d2c6e49b86e3aae/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-11-19T09:22:11+08:00" />
<meta property="article:modified_time" content="2022-11-19T09:22:11+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">JUC学习笔记——并发工具线程池</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>在本系列内容中我们会对JUC做一个系统的学习，本片将会介绍JUC的并发工具线程池</p> 
<p>我们会分为以下几部分进行介绍：</p> 
<ul><li>线程池介绍</li><li>自定义线程池</li><li>模式之Worker Thread</li><li>JDK线程池</li><li>Tomcat线程池</li><li>Fork/Join</li></ul> 
<h3 id="线程池介绍">线程池介绍</h3> 
<p>我们在这一小节简单介绍一下线程池</p> 
<h4 id="线程池简介">线程池简介</h4> 
<p>首先我们先来介绍线程池的产生背景：</p> 
<ul><li>在最开始我们对应每一个任务，都会创建一个线程，但该方法极度耗费资源</li><li>后来我们就产生了线程池，在线程池中规定存放指定数目的线程，由线程池的指定系统来控制接受任务以及处理任务的规定</li></ul> 
<p>我们给出一张线程池基本图：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/55/97/SKTAPh9Y_o.png"></p> 
<h3 id="自定义线程池">自定义线程池</h3> 
<p>我们在这一小节根据线程池基本图来自定义一个线程池</p> 
<h4 id="自定义拒绝策略接口">自定义拒绝策略接口</h4> 
<p>我们先来介绍一下拒绝策略接口：</p> 
<ul><li>我们定义该接口是为了处理线程池中暂时无法接收的数据的内容</li><li>我们可以在该接口的抽象方法中重新定义各种处理方法，实现多种方法处理</li><li>我们直接定义一个接口，里面只有一个方法，后续我们可以采用Lambda表达式或者方法来调用</li></ul> 
<p>我们给出拒绝策略接口代码：</p> 
<pre><code>// 拒绝策略
// 这里采用T来代表接收任务类型，可能是Runnable类型也可能是其他类型线程
// 这里的reject就是抽象方法，我们后续直接采用Lambda表达式重新构造即可
// BlockingQueue是阻塞队列，我们在后续创建；task是任务，我们直接传入即可
@FunctionalInterface 
interface RejectPolicy&lt;T&gt;{
    void reject(BlockingQueue&lt;T&gt; queue,T task);
}
</code></pre> 
<h4 id="自定义任务队列">自定义任务队列</h4> 
<p>我们来介绍一下任务队列：</p> 
<ul><li>我们的任务队列从根本上来说就是由队列组成的</li><li>里面会存放我们需要完成的任务，同时我们需要设置相关参数以及方法完成线程对任务的调取以及结束任务</li></ul> 
<p>我们给出任务队列代码：</p> 
<pre><code>class BlockingQueue&lt;T&gt;{
    
    //阻塞队列，存放任务
    private Deque&lt;T&gt; queue = new ArrayDeque&lt;&gt;();
    //队列的最大容量
    private int capacity;
    //锁
    private ReentrantLock lock = new ReentrantLock();
    //生产者条件变量
    private Condition fullWaitSet = lock.newCondition();
    //消费者条件变量
    private Condition emptyWaitSet = lock.newCondition();
    
    //构造方法
    public BlockingQueue(int capacity) {
        this.capacity = capacity;
    }
    
    //超时阻塞获取
    public T poll(long timeout, TimeUnit unit){
        lock.lock();
        //将时间转换为纳秒
        long nanoTime = unit.toNanos(timeout);
        try{
            while(queue.size() == 0){
                try {
                    //等待超时依旧没有获取，返回null
                    if(nanoTime &lt;= 0){
                        return null;
                    }
                    //awaitNanos方法返回的是剩余时间
                    nanoTime = emptyWaitSet.awaitNanos(nanoTime);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            T t = queue.pollFirst();
            fullWaitSet.signal();
            return t;
        }finally {
            lock.unlock();
        }
    }
    
    //阻塞获取
    public T take(){
        lock.lock();
        try{
            while(queue.size() == 0){
                try {
                    emptyWaitSet.await();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            T t = queue.pollFirst();
            fullWaitSet.signal();
            return t;
        }finally {
            lock.unlock();
        }
    }
    
    //阻塞添加
    public void put(T t){
        lock.lock();
        try{
            while (queue.size() == capacity){
                try {
                    System.out.println(Thread.currentThread().toString() + "等待加入任务队列:" + t.toString());
                    fullWaitSet.await();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            System.out.println(Thread.currentThread().toString() + "加入任务队列:" + t.toString());
            queue.addLast(t);
            emptyWaitSet.signal();
        }finally {
            lock.unlock();
        }
    }
    
    //超时阻塞添加
    public boolean offer(T t,long timeout,TimeUnit timeUnit){
        lock.lock();
        try{
            long nanoTime = timeUnit.toNanos(timeout);
            while (queue.size() == capacity){
                try {
                    if(nanoTime &lt;= 0){
                        System.out.println("等待超时，加入失败：" + t);
                        return false;
                    }
                    System.out.println(Thread.currentThread().toString() + "等待加入任务队列:" + t.toString());
                    nanoTime = fullWaitSet.awaitNanos(nanoTime);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            System.out.println(Thread.currentThread().toString() + "加入任务队列:" + t.toString());
            queue.addLast(t);
            emptyWaitSet.signal();
            return true;
        }finally {
            lock.unlock();
        }
    }
    
    // 获得当前任务队列长度
    public int size(){
        lock.lock();
        try{
            return queue.size();
        }finally{
            lock.unlock();
        }
    }
    
    // 从形参接收拒绝策略的put方法
    public void tryPut(RejectPolicy&lt;T&gt; rejectPolicy,T task){
        lock.lock();
        try{
            if(queue.size() == capacity){
                rejectPolicy.reject(this,task);
            }else{
                System.out.println("加入任务队列：" + task);
                queue.addLast(task);
                emptyWaitSet.signal();
            }
        }finally {
            lock.unlock();
        }
    }
}
</code></pre> 
<h4 id="自定义线程池-1">自定义线程池</h4> 
<p>我们来介绍一下线程池：</p> 
<ul><li>线程池中用于存放线程Thread，用于完成任务队列中的任务</li><li>我们需要设置相关参数，例如线程数量，存在时间，交互方法等内容</li></ul> 
<p>我们给出线程池代码：</p> 
<pre><code>class ThreadPool{
    
    //阻塞队列
    BlockingQueue&lt;Runnable&gt; taskQue;
    //线程集合
    HashSet&lt;Worker&gt; workers = new HashSet&lt;&gt;();
    //拒绝策略
    private RejectPolicy&lt;Runnable&gt; rejectPolicy;
    
    //构造方法
    public ThreadPool(int coreSize,long timeout,TimeUnit timeUnit,int queueCapacity,RejectPolicy&lt;Runnable&gt; rejectPolicy){
        this.coreSize = coreSize;
        this.timeout = timeout;
        this.timeUnit = timeUnit;
        this.rejectPolicy = rejectPolicy;
        taskQue = new BlockingQueue&lt;Runnable&gt;(queueCapacity);
    }
    
    //线程数
    private int coreSize;
    //任务超时时间
    private long timeout;
    //时间单元
    private TimeUnit timeUnit;
    
    //线程池的执行方法
    public void execute(Runnable task){
        //当线程数大于等于coreSize的时候，将任务放入阻塞队列
        //当线程数小于coreSize的时候，新建一个Worker放入workers
        //注意workers类不是线程安全的， 需要加锁
        synchronized (workers){
            if(workers.size() &gt;= coreSize){
                //死等
                //带超时等待
                //让调用者放弃执行任务
                //让调用者抛出异常
                //让调用者自己执行任务
                taskQue.tryPut(rejectPolicy,task);
            }else {
                Worker worker = new Worker(task);
                System.out.println(Thread.currentThread().toString() + "新增worker:" + worker + ",task:" + task);
                workers.add(worker);
                worker.start();
            }
        }
    }

    //工作类
    class Worker extends Thread{

        private Runnable task;

        public Worker(Runnable task){
            this.task = task;
        }

        @Override
        public void run() {
            //巧妙的判断
            while(task != null || (task = taskQue.poll(timeout,timeUnit)) != null){
                try{
                    System.out.println(Thread.currentThread().toString() + "正在执行:" + task);
                    task.run();
                }catch (Exception e){

                }finally {
                    task = null;
                }
            }
            synchronized (workers){
                System.out.println(Thread.currentThread().toString() + "worker被移除:" + this.toString());
                workers.remove(this);
            }
        }
    }
}
</code></pre> 
<h4 id="测试调用">测试调用</h4> 
<p>我们给出自定义线程池的测试代码：</p> 
<pre><code>public class ThreadPoolTest {
    public static void main(String[] args) {
        // 注意：这里最后传入的参数，也就是下面一大溜的方法就是拒绝策略接口，我们可以任意选择，此外put和offer是已经封装的方法
        ThreadPool threadPool = new ThreadPool(1, 1000, TimeUnit.MILLISECONDS, 1, (queue,task)-&gt;{
            //死等
//          queue.put(task);
            //带超时等待
//            queue.offer(task, 1500, TimeUnit.MILLISECONDS);
            //让调用者放弃任务执行
//            System.out.println("放弃：" + task);
            //让调用者抛出异常
//            throw new RuntimeException("任务执行失败" + task);
            //让调用者自己执行任务
            task.run();
                });
        for (int i = 0; i &lt;3; i++) {
            int j = i;
            threadPool.execute(()-&gt;{
                try {
                    System.out.println(Thread.currentThread().toString() + "执行任务：" + j);
                    Thread.sleep(1000L);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            });
        }
    }
}
</code></pre> 
<h3 id="模式之worker-thread">模式之Worker Thread</h3> 
<p>我们在这一小节将介绍一种新的模式WorkThread</p> 
<h4 id="模式定义">模式定义</h4> 
<p>首先我们给出Worker Thread的基本定义：</p> 
<ul><li>让有限的工作线程（Worker Thread）来轮流异步处理无限多的任务。</li><li>也可以将其归类为分工模式，它的典型实现就是线程池，也体现了经典设计模式中的享元模式。</li><li>注意，不同任务类型应该使用不同的线程池，这样能够避免饥饿，并能提升效率</li></ul> 
<p>我们给出一种具体的解释：</p> 
<ul><li>例如，海底捞的服务员（线程），轮流处理每位客人的点餐（任务），如果为每位客人都配一名专属的服务员，那 么成本就太高了（对比另一种多线程设计模式：Thread-Per-Message）</li><li>例如，如果一个餐馆的工人既要招呼客人（任务类型A），又要到后厨做菜（任务类型B）显然效率不咋地，分成 服务员（线程池A）与厨师（线程池B）更为合理，当然你能想到更细致的分工</li></ul> 
<h4 id="正常饥饿现象">正常饥饿现象</h4> 
<p>首先我们先来展示没有使用Worker Thread所出现的问题：</p> 
<pre><code>/*

例如我们采用newFixedThreadPool创建一个具有规定2的线程的线程池
如果我们不为他们分配职责，就有可能导致两个线程都处于等待状态而造成饥饿现象

- 两个工人是同一个线程池中的两个线程 

- 他们要做的事情是：为客人点餐和到后厨做菜，这是两个阶段的工作 
  - 客人点餐：必须先点完餐，等菜做好，上菜，在此期间处理点餐的工人必须等待 
  - 后厨做菜：做菜
- 比如工人A 处理了点餐任务，接下来它要等着 工人B 把菜做好，然后上菜
- 但现在同时来了两个客人，这个时候工人A 和工人B 都去处理点餐了，这时没人做饭了，造成饥饿

*/

/*实际代码展示*/

public class TestDeadLock {
    
    static final List&lt;String&gt; MENU = Arrays.asList("地三鲜", "宫保鸡丁", "辣子鸡丁", "烤鸡翅");
    static Random RANDOM = new Random();
    
    static String cooking() {
        return MENU.get(RANDOM.nextInt(MENU.size()));
    }
    
    public static void main(String[] args) {
        
        // 我们这里创建一个固定线程池，里面涵盖两个线程
        ExecutorService executorService = Executors.newFixedThreadPool(2);
        
        executorService.execute(() -&gt; {
            log.debug("处理点餐...");
            Future&lt;String&gt; f = executorService.submit(() -&gt; {
                log.debug("做菜");
                return cooking();
            });
            try {
                log.debug("上菜: {}", f.get());
            } catch (InterruptedException | ExecutionException e) {
                e.printStackTrace();
            }
        });
        
        // 开启下面代码即两人同时负责点餐
        /*
        executorService.execute(() -&gt; {
            log.debug("处理点餐...");
            Future&lt;String&gt; f = executorService.submit(() -&gt; {
                log.debug("做菜");
                return cooking();
            });
            try {
                log.debug("上菜: {}", f.get());
            } catch (InterruptedException | ExecutionException e) {
                e.printStackTrace();
            }
        });
        */
    }
}

/*正确运行*/

17:21:27.883 c.TestDeadLock [pool-1-thread-1] - 处理点餐...
17:21:27.891 c.TestDeadLock [pool-1-thread-2] - 做菜
17:21:27.891 c.TestDeadLock [pool-1-thread-1] - 上菜: 烤鸡翅
    
/*代码注释后运行*/
    
17:08:41.339 c.TestDeadLock [pool-1-thread-2] - 处理点餐...  
17:08:41.339 c.TestDeadLock [pool-1-thread-1] - 处理点餐... 
</code></pre> 
<h4 id="饥饿解决方法">饥饿解决方法</h4> 
<p>如果想要解除之前的饥饿现象，正确的方法就是采用Worker Thread模式为他们分配角色，让他们只专属于一份工作：</p> 
<pre><code>/*代码展示*/

public class TestDeadLock {
    
    static final List&lt;String&gt; MENU = Arrays.asList("地三鲜", "宫保鸡丁", "辣子鸡丁", "烤鸡翅");
    static Random RANDOM = new Random();
    
    static String cooking() {
        return MENU.get(RANDOM.nextInt(MENU.size()));
    }
    
    public static void main(String[] args) {
        
        // 我们这里创建两个线程池，分别包含一个线程，用于不同的分工
        ExecutorService waiterPool = Executors.newFixedThreadPool(1);
        ExecutorService cookPool = Executors.newFixedThreadPool(1);
        
        // 我们这里采用waiterPool线程池来处理点餐，采用cookPool来处理做菜
        waiterPool.execute(() -&gt; {
            log.debug("处理点餐...");
            Future&lt;String&gt; f = cookPool.submit(() -&gt; {
                log.debug("做菜");
                return cooking();
            });
            try {
                log.debug("上菜: {}", f.get());
            } catch (InterruptedException | ExecutionException e) {
                e.printStackTrace();
            }
        });
        
        // 无论多少线程他们都会正常运行
        waiterPool.execute(() -&gt; {
            log.debug("处理点餐...");
            Future&lt;String&gt; f = cookPool.submit(() -&gt; {
                log.debug("做菜");
                return cooking();
            });
            try {
                log.debug("上菜: {}", f.get());
            } catch (InterruptedException | ExecutionException e) {
                e.printStackTrace();
            }
        });
    }
}

/*结果展示*/

17:25:14.626 c.TestDeadLock [pool-1-thread-1] - 处理点餐... 
17:25:14.630 c.TestDeadLock [pool-2-thread-1] - 做菜
17:25:14.631 c.TestDeadLock [pool-1-thread-1] - 上菜: 地三鲜
17:25:14.632 c.TestDeadLock [pool-1-thread-1] - 处理点餐... 
17:25:14.632 c.TestDeadLock [pool-2-thread-1] - 做菜
17:25:14.632 c.TestDeadLock [pool-1-thread-1] - 上菜: 辣子鸡丁
</code></pre> 
<h4 id="线程池大小设计">线程池大小设计</h4> 
<p>最后我们来思考一下线程池大小的问题：</p> 
<ul><li>如果线程池设计过小，CPU利用不完善，并且同时任务过多，就会导致大量任务等待</li><li>如果线程池设计过大，CPU需要不断进行上下文切换，也会耗费大量时间，导致速率反而降低</li></ul> 
<p>我们给出两种形式下的线程池大小规范：</p> 
<ol><li><strong>CPU 密集型运算</strong></li></ol> 
<pre><code>/*
通常采用 `cpu 核数 + 1` 能够实现最优的 CPU 利用率
+1 是保证当线程由于页缺失故障（操作系统）或其它原因导致暂停时，额外的这个线程就能顶上去，保证 CPU 时钟周期不被浪费
*/
</code></pre> 
<ol><li><strong>I/O 密集型运算</strong></li></ol> 
<pre><code>/*
CPU 不总是处于繁忙状态，例如，当你执行业务计算时，这时候会使用 CPU 资源
但当你执行 I/O 操作时、远程 RPC 调用时，包括进行数据库操作时，这时候 CPU 就闲下来了，你可以利用多线程提高它的利用率。 

经验公式如下 

`线程数 = 核数 * 期望 CPU 利用率 * 总时间(CPU计算时间+等待时间) / CPU 计算时间` 

例如 4 核 CPU 计算时间是 50% ，其它等待时间是 50%，期望 cpu 被 100% 利用，套用公式 

`4 * 100% * 100% / 50% = 8` 

例如 4 核 CPU 计算时间是 10% ，其它等待时间是 90%，期望 cpu 被 100% 利用，套用公式 

`4 * 100% * 100% / 10% = 40`
*/
</code></pre> 
<h3 id="jdk线程池">JDK线程池</h3> 
<p>下面我们来介绍JDK中为我们提供的线程池设计</p> 
<h4 id="线程池构建图">线程池构建图</h4> 
<p>首先我们要知道JDK为我们提供的线程池都是通过Executors的方法来构造的</p> 
<p>我们给出继承图：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/9a/94/WjoQDZz9_o.png"></p> 
<p>其中我们所使用的线程创造类分为两种：</p> 
<ul><li>ScheduledThreadPoolExecutor是带调度的线程池</li><li>ThreadPoolExecutor是不带调度的线程池</li></ul> 
<h4 id="线程池状态">线程池状态</h4> 
<p>我们首先给出线程池状态的构造规则：</p> 
<ul><li>ThreadPoolExecutor 使用 int 的高 3 位来表示线程池状态，低 29 位表示线程数量</li></ul> 
<p>我们给出具体线程状态：</p> 
<table><thead><tr><th>状态名</th><th>高3位</th><th>接收新任务</th><th>处理阻塞队列任务</th><th>说明</th></tr></thead><tbody><tr><td>RUNNING</td><td>111</td><td>Y</td><td>Y</td><td>正常运行</td></tr><tr><td>SHUTDOWN</td><td>000</td><td>N</td><td>Y</td><td>不会接收新任务，但会处理阻塞队列剩余 任务</td></tr><tr><td>STOP</td><td>001</td><td>N</td><td>N</td><td>会中断正在执行的任务，并抛弃阻塞队列 任务</td></tr><tr><td>TIDYING</td><td>010</td><td></td><td></td><td>任务全执行完毕，活动线程为 0 即将进入 终结</td></tr><tr><td>TERMINATED</td><td>011</td><td></td><td></td><td>终结状态</td></tr></tbody></table> 
<p>从数字上比较，TERMINATED &gt; TIDYING &gt; STOP &gt; SHUTDOWN &gt; RUNNING （因为RUNNING为负数）</p> 
<h4 id="构造方法">构造方法</h4> 
<p>我们给出线程池中ThreadPoolExecutor最完善的构造方法的参数展示：</p> 
<pre><code>public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue&lt;Runnable&gt; workQueue,
                          ThreadFactory threadFactory,
                          RejectedExecutionHandler handler)
</code></pre> 
<p>我们对上述各种类型进行一一介绍：</p> 
<ul><li>corePoolSize 核心线程数目 (最多保留的线程数)</li><li>maximumPoolSize 最大线程数目</li><li>keepAliveTime 生存时间 - 针对救急线程</li><li>unit 时间单位 - 针对救急线程</li><li>workQueue 阻塞队列</li><li>threadFactory 线程工厂 - 可以为线程创建时起个好名字</li><li>handler 拒绝策略</li></ul> 
<h4 id="工作方式">工作方式</h4> 
<p>我们首先给出工作方式展示图：</p> 
<p>线程池c-2,m=3</p> 
<p>阻塞队列</p> 
<p>核心线程1</p> 
<p>核心线程2</p> 
<p>救急线程1</p> 
<p>任务1</p> 
<p>任务2</p> 
<p>size=2</p> 
<p>任务3</p> 
<p>任务4</p> 
<p>我们对此进行简单解释：</p> 
<ul><li> <p>线程池中刚开始没有线程，当一个任务提交给线程池后，线程池会创建一个新线程来执行任务。</p> </li><li> <p>当线程数达到 corePoolSize 并没有线程空闲，这时再加入任务，新加的任务会被加入workQueue 队列排 队，直到有空闲的线程。</p> </li><li> <p>如果队列选择了有界队列，那么任务超过了队列大小时，会创建 maximumPoolSize - corePoolSize 数目的线程来救急。</p> </li><li> <p>如果线程到达 maximumPoolSize 仍然有新任务这时会执行拒绝策略。</p> </li><li> <p>当高峰过去后，超过corePoolSize 的救急线程如果一段时间没有任务做,需要结束节省资源,这个时间由keepAliveTime和unit来控制。</p> </li></ul> 
<p>拒绝策略 jdk 提供了 4 种实现，其它著名框架也提供了实现:</p> 
<ul><li>AbortPolicy 让调用者抛出 RejectedExecutionException 异常，这是默认策略</li><li>CallerRunsPolicy 让调用者运行任务</li><li>DiscardPolicy 放弃本次任务</li><li>DiscardOldestPolicy 放弃队列中最早的任务，本任务取而代之</li><li>Dubbo 的实现，在抛出 RejectedExecutionException 异常之前会记录日志，并 dump 线程栈信息，方 便定位问题</li><li>Netty 的实现，是创建一个新线程来执行任务</li><li>ActiveMQ 的实现，带超时等待（60s）尝试放入队列，类似我们之前自定义的拒绝策略</li><li>PinPoint 的实现，它使用了一个拒绝策略链，会逐一尝试策略链中每种拒绝策略</li></ul> 
<h4 id="newfixedthreadpool">newFixedThreadPool</h4> 
<p>我们首先来介绍一下newFixedThreadPool：</p> 
<ul><li>创造一个具有固定线程大小的线程池</li></ul> 
<p>我们给出构造方法：</p> 
<pre><code>/*我们正常调用的方法*/

// 我们只需要提供线程数量nThreads，就会创建一个大小为nThreads的线程池
// 下面会返回一个相应配置的线程池，这里的核心线程和最大线程都是nThreads，就意味着没有救急线程，同时也不需要设置保存时间
public static ExecutorService newFixedThreadPool(int nThreads) {
    return new ThreadPoolExecutor(nThreads, nThreads,
                                  0L, TimeUnit.MILLISECONDS,
                                  new LinkedBlockingQueue&lt;Runnable&gt;());
}

/*底层实现方法*/

// 这和我们前面的构造方法是完全相同的
public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue&lt;Runnable&gt; workQueue) {
    this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,
         Executors.defaultThreadFactory(), defaultHandler);
}

/*默认工厂以及默认构造线程的方法*/

// 对应上述构造方法中的默认工厂以及线程构造，主要是控制了命名以及优先级并设置不为守护线程等内容
DefaultThreadFactory() {
    SecurityManager s = System.getSecurityManager();
    group = (s != null) ? s.getThreadGroup() :
    Thread.currentThread().getThreadGroup();
    namePrefix = "pool-" +
        poolNumber.getAndIncrement() +
        "-thread-";
}

public Thread newThread(Runnable r) {
    Thread t = new Thread(group, r,
                          namePrefix + threadNumber.getAndIncrement(),
                          0);
    if (t.isDaemon())
        t.setDaemon(false);
    if (t.getPriority() != Thread.NORM_PRIORITY)
        t.setPriority(Thread.NORM_PRIORITY);
    return t;
}

/*默认拒绝策略：抛出异常*/

private static final RejectedExecutionHandler defaultHandler = new AbortPolicy();
</code></pre> 
<p>我们最后给出具体特点：</p> 
<ul><li>核心线程数 == 最大线程数（没有救急线程被创建），因此也无需超时时间</li><li>阻塞队列是无界的，可以放任意数量的任务</li><li>适用于任务量已知，相对耗时的任务</li></ul> 
<h4 id="newcachedthreadpool">newCachedThreadPool</h4> 
<p>我们首先来介绍一下newCachedThreadPool：</p> 
<ul><li>创造一个只有救急线程的线程池</li></ul> 
<p>我们给出构造方法：</p> 
<pre><code>/*调用方法*/

public static ExecutorService newCachedThreadPool() {
    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                  60L, TimeUnit.SECONDS,
                                  new SynchronousQueue&lt;Runnable&gt;());
}

/*测试代码*/

SynchronousQueue&lt;Integer&gt; integers = new SynchronousQueue&lt;&gt;();
new Thread(() -&gt; {
    try {
        log.debug("putting {} ", 1);
        integers.put(1);
        log.debug("{} putted...", 1);
        log.debug("putting...{} ", 2);
        integers.put(2);
        log.debug("{} putted...", 2);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
},"t1").start();
sleep(1);
new Thread(() -&gt; {
    try {
        log.debug("taking {}", 1);
        integers.take();
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
},"t2").start();
sleep(1);
new Thread(() -&gt; {
    try {
        log.debug("taking {}", 2);
        integers.take();
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
},"t3").start();

/*输出结果*/

11:48:15.500 c.TestSynchronousQueue [t1] - putting 1 
11:48:16.500 c.TestSynchronousQueue [t2] - taking 1 
11:48:16.500 c.TestSynchronousQueue [t1] - 1 putted... 
11:48:16.500 c.TestSynchronousQueue [t1] - putting...2 
11:48:17.502 c.TestSynchronousQueue [t3] - taking 2 
11:48:17.503 c.TestSynchronousQueue [t1] - 2 putted... 
</code></pre> 
<p>我们给出newCachedThreadPool的特点：</p> 
<ul><li>核心线程数是 0， 最大线程数是 Integer.MAX_VALUE，救急线程的空闲生存时间是 60s， 
  <ul><li>意味着全部都是救急线程（60s 后可以回收）</li><li>救急线程可以无限创建</li></ul></li><li>队列采用了 SynchronousQueue 实现特点是，它没有容量，没有线程来取是放不进去的</li><li>整个线程池表现为线程数会根据任务量不断增长，没有上限</li><li>当任务执行完毕，空闲 1分钟后释放线 程。 适合任务数比较密集，但每个任务执行时间较短的情况</li></ul> 
<h4 id="newsinglethreadexecutor">newSingleThreadExecutor</h4> 
<p>我们先来简单介绍一下newSingleThreadExecutor：</p> 
<ul><li>希望多个任务排队执行。线程数固定为 1，任务数多于 1 时，会放入无界队列排队。任务执行完毕，这唯一的线程 也不会被释放。</li></ul> 
<p>我们给出构造方法：</p> 
<pre><code>/*构造方法*/

public static ExecutorService newSingleThreadExecutor() {
    return new FinalizableDelegatedExecutorService
        (new ThreadPoolExecutor(1, 1,
                                0L, TimeUnit.MILLISECONDS,
                                new LinkedBlockingQueue&lt;Runnable&gt;()));
}
</code></pre> 
<p>我们给出newSingleThreadExecutor的特点：</p> 
<ul><li>自己创建一个单线程串行执行任务，如果任务执行失败而终止那么没有任何补救措施，而线程池还会新建一 个线程，保证池的正常工作</li><li>Executors.newSingleThreadExecutor() 线程个数始终为1，不能修改 
  <ul><li>FinalizableDelegatedExecutorService 应用的是装饰器模式，在调用构造方法时将ThreadPoolExecutor对象传给了内部的ExecutorService接口。只对外暴露了 ExecutorService 接口，因此不能调用 ThreadPoolExecutor 中特有的方法，也不能重新设置线程池的大小。</li></ul></li><li>Executors.newFixedThreadPool(1) 初始时为1，以后还可以修改 
  <ul><li>对外暴露的是 ThreadPoolExecutor 对象，可以强转后调用 setCorePoolSize 等方法进行修改</li></ul></li></ul> 
<h4 id="提交任务">提交任务</h4> 
<p>下面我们来介绍多种提交任务的执行方法：</p> 
<pre><code>/*介绍*/

// 执行任务
void execute(Runnable command);

// 提交任务 task，用返回值 Future 获得任务执行结果
&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task);

// 提交 tasks 中所有任务
&lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)
    throws InterruptedException;

// 提交 tasks 中所有任务，带超时时间，时间超时后，会放弃执行后面的任务
&lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,
                              long timeout, TimeUnit unit)
    throws InterruptedException;

// 提交 tasks 中所有任务，哪个任务先成功执行完毕，返回此任务执行结果，其它任务取消
&lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)
    throws InterruptedException, ExecutionException;

// 提交 tasks 中所有任务，哪个任务先成功执行完毕，返回此任务执行结果，其它任务取消，带超时时间
&lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,
                long timeout, TimeUnit unit)
    throws InterruptedException, ExecutionException, TimeoutException;

/*submit*/

// 测试代码
private static void method1(ExecutorService pool) throws InterruptedException, ExecutionException {
    Future&lt;String&gt; future = pool.submit(() -&gt; {
        log.debug("running");
        Thread.sleep(1000);
        return "ok";
    });

    log.debug("{}", future.get());
}
public static void main(String[] args) throws ExecutionException, InterruptedException {
    ExecutorService pool = Executors.newFixedThreadPool(1);
    method1(pool);
}

// 结果
18:36:58.033 c.TestSubmit [pool-1-thread-1] - running
18:36:59.034 c.TestSubmit [main] - ok
    
/*invokeAll*/
    
// 测试代码
private static void method2(ExecutorService pool) throws InterruptedException {
    List&lt;Future&lt;String&gt;&gt; futures = pool.invokeAll(Arrays.asList(
        () -&gt; {
            log.debug("begin");
            Thread.sleep(1000);
            return "1";
        },
        () -&gt; {
            log.debug("begin");
            Thread.sleep(500);
            return "2";
        },
        () -&gt; {
            log.debug("begin");
            Thread.sleep(2000);
            return "3";
        }
    ));

    futures.forEach( f -&gt;  {
        try {
            log.debug("{}", f.get());
        } catch (InterruptedException | ExecutionException e) {
            e.printStackTrace();
        }
    });
}
public static void main(String[] args) throws ExecutionException, InterruptedException {
    ExecutorService pool = Executors.newFixedThreadPool(1);
    method2(pool);
}

// 结果
19:33:16.530 c.TestSubmit [pool-1-thread-1] - begin
19:33:17.530 c.TestSubmit [pool-1-thread-1] - begin
19:33:18.040 c.TestSubmit [pool-1-thread-1] - begin
19:33:20.051 c.TestSubmit [main] - 1
19:33:20.051 c.TestSubmit [main] - 2
19:33:20.051 c.TestSubmit [main] - 3
    
/*invokeAny*/
private static void method3(ExecutorService pool) throws InterruptedException, ExecutionException {
    String result = pool.invokeAny(Arrays.asList(
        () -&gt; {
            log.debug("begin 1");
            Thread.sleep(1000);
            log.debug("end 1");
            return "1";
        },
        () -&gt; {
            log.debug("begin 2");
            Thread.sleep(500);
            log.debug("end 2");
            return "2";
        },
        () -&gt; {
            log.debug("begin 3");
            Thread.sleep(2000);
            log.debug("end 3");
            return "3";
        }
    ));
    log.debug("{}", result);
}
public static void main(String[] args) throws ExecutionException, InterruptedException {
    ExecutorService pool = Executors.newFixedThreadPool(3);
    //ExecutorService pool = Executors.newFixedThreadPool(1);
    method3(pool);
}

// 结果
19:44:46.314 c.TestSubmit [pool-1-thread-1] - begin 1
19:44:46.314 c.TestSubmit [pool-1-thread-3] - begin 3
19:44:46.314 c.TestSubmit [pool-1-thread-2] - begin 2
19:44:46.817 c.TestSubmit [pool-1-thread-2] - end 2
19:44:46.817 c.TestSubmit [main] - 2

19:47:16.063 c.TestSubmit [pool-1-thread-1] - begin 1
19:47:17.063 c.TestSubmit [pool-1-thread-1] - end 1
19:47:17.063 c.TestSubmit [pool-1-thread-1] - begin 2
19:47:17.063 c.TestSubmit [main] - 1
</code></pre> 
<h4 id="关闭线程池">关闭线程池</h4> 
<p>我们给出关闭线程池的多种方法：</p> 
<pre><code>/*SHUTDOWN*/

/*
线程池状态变为 SHUTDOWN
- 不会接收新任务
- 但已提交任务会执行完
- 此方法不会阻塞调用线程的执行
*/
void shutdown();

public void shutdown() {
    final ReentrantLock mainLock = this.mainLock;
    mainLock.lock();
    try {
        checkShutdownAccess();
        // 修改线程池状态
        advanceRunState(SHUTDOWN);
        // 仅会打断空闲线程
        interruptIdleWorkers();
        onShutdown(); // 扩展点 ScheduledThreadPoolExecutor
    } finally {
        mainLock.unlock();
    }
    // 尝试终结(没有运行的线程可以立刻终结，如果还有运行的线程也不会等)
    tryTerminate();
}

/*shutdownNow*/

/*
线程池状态变为 STOP
- 不会接收新任务
- 会将队列中的任务返回
- 并用 interrupt 的方式中断正在执行的任务
*/
List&lt;Runnable&gt; shutdownNow();

public List&lt;Runnable&gt; shutdownNow() {
    List&lt;Runnable&gt; tasks;
    final ReentrantLock mainLock = this.mainLock;
    mainLock.lock();
    try {
        checkShutdownAccess();
        // 修改线程池状态
        advanceRunState(STOP);
        // 打断所有线程
        interruptWorkers();
        // 获取队列中剩余任务
        tasks = drainQueue();
    } finally {
        mainLock.unlock();
    }
    // 尝试终结
    tryTerminate();
    return tasks;
}

/*其他方法*/

// 不在 RUNNING 状态的线程池，此方法就返回 true
boolean isShutdown();
// 线程池状态是否是 TERMINATED
boolean isTerminated();
// 调用 shutdown 后，由于调用线程并不会等待所有任务运行结束，因此如果它想在线程池 TERMINATED 后做些事情，可以利用此方法等待
// 一般task是Callable类型的时候不用此方法，因为futureTask.get方法自带等待功能。
boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException;

/*测试shutdown、shutdownNow、awaitTermination*/

// 代码
@Slf4j(topic = "c.TestShutDown")
public class TestShutDown {

    public static void main(String[] args) throws ExecutionException, InterruptedException {
        ExecutorService pool = Executors.newFixedThreadPool(2);

        Future&lt;Integer&gt; result1 = pool.submit(() -&gt; {
            log.debug("task 1 running...");
            Thread.sleep(1000);
            log.debug("task 1 finish...");
            return 1;
        });

        Future&lt;Integer&gt; result2 = pool.submit(() -&gt; {
            log.debug("task 2 running...");
            Thread.sleep(1000);
            log.debug("task 2 finish...");
            return 2;
        });

        Future&lt;Integer&gt; result3 = pool.submit(() -&gt; {
            log.debug("task 3 running...");
            Thread.sleep(1000);
            log.debug("task 3 finish...");
            return 3;
        });

        log.debug("shutdown");
        pool.shutdown();
        //        pool.awaitTermination(3, TimeUnit.SECONDS);
        //        List&lt;Runnable&gt; runnables = pool.shutdownNow();
        //        log.debug("other.... {}" , runnables);
    }
}

// 结果
#shutdown依旧会执行剩下的任务
20:09:13.285 c.TestShutDown [main] - shutdown
20:09:13.285 c.TestShutDown [pool-1-thread-1] - task 1 running...
20:09:13.285 c.TestShutDown [pool-1-thread-2] - task 2 running...
20:09:14.293 c.TestShutDown [pool-1-thread-2] - task 2 finish...
20:09:14.293 c.TestShutDown [pool-1-thread-1] - task 1 finish...
20:09:14.293 c.TestShutDown [pool-1-thread-2] - task 3 running...
20:09:15.303 c.TestShutDown [pool-1-thread-2] - task 3 finish...
#shutdownNow立刻停止所有任务
20:11:11.750 c.TestShutDown [main] - shutdown
20:11:11.750 c.TestShutDown [pool-1-thread-1] - task 1 running...
20:11:11.750 c.TestShutDown [pool-1-thread-2] - task 2 running...
20:11:11.750 c.TestShutDown [main] - other.... [java.util.concurrent.FutureTask@66d33a]
</code></pre> 
<h4 id="任务调度线程池">任务调度线程池</h4> 
<p>在『任务调度线程池』功能加入之前(JDK1.3)，可以使用 java.util.Timer 来实现定时功能</p> 
<p>Timer 的优点在于简单易用，但由于所有任务都是由同一个线程来调度，因此所有任务都是串行执行的</p> 
<p>同一时间只能有一个任务在执行，前一个 任务的延迟或异常都将会影响到之后的任务。</p> 
<p>我们首先首先给出Timer的使用：</p> 
<pre><code>/*Timer使用代码*/

public static void main(String[] args) {
    Timer timer = new Timer();
    TimerTask task1 = new TimerTask() {
        @Override
        public void run() {
            log.debug("task 1");
            sleep(2);
        }
    };
    TimerTask task2 = new TimerTask() {
        @Override
        public void run() {
            log.debug("task 2");
        }
    };
    // 使用 timer 添加两个任务，希望它们都在 1s 后执行
    // 但由于 timer 内只有一个线程来顺序执行队列中的任务，因此『任务1』的延时，影响了『任务2』的执行
    timer.schedule(task1, 1000);
    timer.schedule(task2, 1000);
}

/*结果*/

20:46:09.444 c.TestTimer [main] - start... 
20:46:10.447 c.TestTimer [Timer-0] - task 1 
20:46:12.448 c.TestTimer [Timer-0] - task 2 
</code></pre> 
<p>我们再给出 ScheduledExecutorService 的改写格式：</p> 
<pre><code>/*ScheduledExecutorService代码书写*/

ScheduledExecutorService executor = Executors.newScheduledThreadPool(2);
// 添加两个任务，希望它们都在 1s 后执行
executor.schedule(() -&gt; {
    System.out.println("任务1，执行时间：" + new Date());
    try { Thread.sleep(2000); } catch (InterruptedException e) { }
}, 1000, TimeUnit.MILLISECONDS);
executor.schedule(() -&gt; {
    System.out.println("任务2，执行时间：" + new Date());
}, 1000, TimeUnit.MILLISECONDS);

/*结果*/

任务1，执行时间：Thu Jan 03 12:45:17 CST 2019 
任务2，执行时间：Thu Jan 03 12:45:17 CST 2019 
</code></pre> 
<p>我们对其再进行更细节的测试分析：</p> 
<pre><code>/*scheduleAtFixedRate:任务执行时间超过了间隔时间*/

// 代码
ScheduledExecutorService pool = Executors.newScheduledThreadPool(1);
log.debug("start...");
pool.scheduleAtFixedRate(() -&gt; {
    log.debug("running...");
    sleep(2);
}, 1, 1, TimeUnit.SECONDS);

// 结果
21:44:30.311 c.TestTimer [main] - start... 
21:44:31.360 c.TestTimer [pool-1-thread-1] - running... 
21:44:33.361 c.TestTimer [pool-1-thread-1] - running... 
21:44:35.362 c.TestTimer [pool-1-thread-1] - running... 
21:44:37.362 c.TestTimer [pool-1-thread-1] - running...
    
/*scheduleWithFixedDelay:在任务完成的基础上，设置时间间隔*/
    
// 代码
ScheduledExecutorService pool = Executors.newScheduledThreadPool(1);
log.debug("start...");
pool.scheduleWithFixedDelay(()-&gt; {
    log.debug("running...");
    sleep(2);
}, 1, 1, TimeUnit.SECONDS);

// 结果
21:40:55.078 c.TestTimer [main] - start... 
21:40:56.140 c.TestTimer [pool-1-thread-1] - running... 
21:40:59.143 c.TestTimer [pool-1-thread-1] - running... 
21:41:02.145 c.TestTimer [pool-1-thread-1] - running... 
21:41:05.147 c.TestTimer [pool-1-thread-1] - running... 
</code></pre> 
<p>我们给出ScheduledExecutorService适用范围：</p> 
<ul><li>线程数固定，任务数多于线程数时，会放入无界队列排队。</li><li>任务执行完毕，这些线程也不会被释放，用来执行延迟或反复执行的任务</li></ul> 
<h4 id="正确处理执行任务异常">正确处理执行任务异常</h4> 
<p>我们针对异常在之前一般会选择抛出或者无视，但这里我们给出应对方法：</p> 
<pre><code>/*try-catch*/

// 代码
ExecutorService pool = Executors.newFixedThreadPool(1);
pool.submit(() -&gt; {
    try {
        log.debug("task1");
        int i = 1 / 0;
    } catch (Exception e) {
        log.error("error:", e);
    }
});

// 结果
21:59:04.558 c.TestTimer [pool-1-thread-1] - task1 
21:59:04.562 c.TestTimer [pool-1-thread-1] - error: 
java.lang.ArithmeticException: / by zero 
 at cn.itcast.n8.TestTimer.lambda$main$0(TestTimer.java:28) 
 at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511) 
 at java.util.concurrent.FutureTask.run(FutureTask.java:266) 
 at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) 
 at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) 
 at java.lang.Thread.run(Thread.java:748) 
    
/*Future返回*/
    
// 我们在之前的提交任务中已经学习了submit等提交方法，当发异常时，这类返回对象Future将会返回异常信息
    
// 代码
ExecutorService pool = Executors.newFixedThreadPool(1);
Future&lt;Boolean&gt; f = pool.submit(() -&gt; {
    log.debug("task1");
    int i = 1 / 0;
    return true;
});
log.debug("result:{}", f.get());

// 结果
21:54:58.208 c.TestTimer [pool-1-thread-1] - task1 
Exception in thread "main" java.util.concurrent.ExecutionException: 
java.lang.ArithmeticException: / by zero 
 at java.util.concurrent.FutureTask.report(FutureTask.java:122) 
 at java.util.concurrent.FutureTask.get(FutureTask.java:192) 
 at cn.itcast.n8.TestTimer.main(TestTimer.java:31) 
Caused by: java.lang.ArithmeticException: / by zero 
 at cn.itcast.n8.TestTimer.lambda$main$0(TestTimer.java:28) 
 at java.util.concurrent.FutureTask.run(FutureTask.java:266) 
 at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) 
 at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) 
 at java.lang.Thread.run(Thread.java:748) 
</code></pre> 
<h4 id="定时任务">定时任务</h4> 
<p>我们进行一个简单的实例展示：</p> 
<pre><code>/*任务：在每周四下午六点执行方法*/

/* 代码 */

// 获得当前时间
LocalDateTime now = LocalDateTime.now();
// 获取本周四 18:00:00.000
LocalDateTime thursday = 
    now.with(DayOfWeek.THURSDAY).withHour(18).withMinute(0).withSecond(0).withNano(0);
// 如果当前时间已经超过 本周四 18:00:00.000， 那么找下周四 18:00:00.000
if(now.compareTo(thursday) &gt;= 0) {
    thursday = thursday.plusWeeks(1);
}
// 计算时间差，即延时执行时间
long initialDelay = Duration.between(now, thursday).toMillis();
// 计算间隔时间，即 1 周的毫秒值
long oneWeek = 7 * 24 * 3600 * 1000;
ScheduledExecutorService executor = Executors.newScheduledThreadPool(2);
System.out.println("开始时间：" + new Date());
executor.scheduleAtFixedRate(() -&gt; {
    System.out.println("执行时间：" + new Date());
}, initialDelay, oneWeek, TimeUnit.MILLISECONDS);
</code></pre> 
<h3 id="tomcat线程池">Tomcat线程池</h3> 
<p>下面我们来介绍Tomcat中所使用的线程池</p> 
<h4 id="tomcat线程池介绍">Tomcat线程池介绍</h4> 
<p>我们首先给出Tomcat线程运作的展示图：</p> 
<p>Connector-&gt;NIO EndPoint</p> 
<p>Executor</p> 
<p>有读</p> 
<p>有读</p> 
<p>socketProcessor</p> 
<p>socketProcessor</p> 
<p>LimitLatch</p> 
<p>Acceptor</p> 
<p>SocketChannel 1</p> 
<p>SocketChannel 2</p> 
<p>Poller</p> 
<p>worker1</p> 
<p>worker2</p> 
<p>我们针对上述图给出对应解释：</p> 
<ul><li>LimitLatch 用来限流，可以控制最大连接个数，类似 J.U.C 中的 Semaphore 后面再讲</li><li>Acceptor 只负责【接收新的 socket 连接】</li><li>Poller 只负责监听 socket channel 是否有【可读的 I/O 事件】</li><li>一旦可读，封装一个任务对象（socketProcessor），提交给 Executor 线程池处理</li><li>Executor 线程池中的工作线程最终负责【处理请求】</li></ul> 
<p>我们需要注意Tomcat针对原本JDK提供的线程池进行了部分修改：</p> 
<ul><li> <p>Tomcat 线程池扩展了 ThreadPoolExecutor，行为稍有不同</p> 
  <ul><li>如果总线程数达到 maximumPoolSize 
    <ul><li>这时不会立刻抛 RejectedExecutionException 异常</li><li>而是再次尝试将任务放入队列，如果还失败，才抛出 RejectedExecutionException 异常</li></ul></li></ul></li></ul> 
<p>我们给出Tomcat相关配置信息：</p> 
<ol><li><strong>Connector 配置</strong></li></ol> 
<table><thead><tr><th>配置项</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>acceptorThreadCount</code></td><td>1</td><td>acceptor 线程数量</td></tr><tr><td><code>pollerThreadCount</code></td><td>1</td><td>poller 线程数量</td></tr><tr><td><code>minSpareThreads</code></td><td>10</td><td>核心线程数，即 corePoolSize</td></tr><tr><td><code>maxThreads</code></td><td>200</td><td>最大线程数，即 maximumPoolSize</td></tr><tr><td><code>executor</code></td><td>-</td><td>Executor 名称，用来引用下面的 Executor</td></tr></tbody></table> 
<ol><li><strong>Executor 线程配置</strong></li></ol> 
<table><thead><tr><th>配置项</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>threadPriority</code></td><td>5</td><td>线程优先级</td></tr><tr><td><code>deamon</code></td><td>true</td><td>是否守护线程</td></tr><tr><td><code>minSpareThreads</code></td><td>25</td><td>核心线程数，即corePoolSize</td></tr><tr><td><code>maxThreads</code></td><td>200</td><td>最大线程数，即 maximumPoolSize</td></tr><tr><td><code>maxIdleTime</code></td><td>60000</td><td>线程生存时间，单位是毫秒，默认值即 1 分钟</td></tr><tr><td><code>maxQueueSize</code></td><td>Integer.MAX_VALUE</td><td>队列长度</td></tr><tr><td><code>prestartminSpareThreads</code></td><td>false</td><td>核心线程是否在服务器启动时启动</td></tr></tbody></table> 
<h3 id="forkjoin">Fork/Join</h3> 
<p>这一小节我们来介绍Fork/Join线程池思想</p> 
<h4 id="forkjoin简单介绍">Fork/Join简单介绍</h4> 
<p>我们首先来简单介绍一下Fork/Join：</p> 
<ul><li>Fork/Join 是 JDK 1.7 加入的新的线程池实现，它体现的是一种分治思想，适用于能够进行任务拆分的 cpu 密集型运算</li></ul> 
<p>我们来介绍一下任务拆分：</p> 
<ul><li>所谓的任务拆分，是将一个大任务拆分为算法上相同的小任务，直至不能拆分可以直接求解。</li><li>跟递归相关的一些计 算，如归并排序、斐波那契数列、都可以用分治思想进行求解</li></ul> 
<p>我们给出Fork/Join的一些思想：</p> 
<ul><li> <p>Fork/Join 在分治的基础上加入了多线程，可以把每个任务的分解和合并交给不同的线程来完成，进一步提升了运算效率</p> </li><li> <p>Fork/Join 默认会创建与 cpu 核心数大小相同的线程池</p> </li></ul> 
<h4 id="求和应用">求和应用</h4> 
<p>我们给出一个简单的应用题材来展示Fork/Join：</p> 
<ul><li>提交给 Fork/Join 线程池的任务需要继承 RecursiveTask（有返回值）或 RecursiveAction（没有返回值）</li><li>例如下 面定义了一个对 1~n 之间的整数求和的任务</li></ul> 
<p>我们给出对应代码：</p> 
<pre><code>/*求和代码*/

public static void main(String[] args) {
    ForkJoinPool pool = new ForkJoinPool(4);
    System.out.println(pool.invoke(new AddTask1(5)));
}

@Slf4j(topic = "c.AddTask")
class AddTask1 extends RecursiveTask&lt;Integer&gt; {
    int n;
    public AddTask1(int n) {
        this.n = n;
    }
    @Override
    public String toString() {
        return "{" + n + '}';
    }
    @Override
    protected Integer compute() {
        // 如果 n 已经为 1，可以求得结果了
        if (n == 1) {
            log.debug("join() {}", n);
            return n;
        }

        // 将任务进行拆分(fork)
        AddTask1 t1 = new AddTask1(n - 1);
        t1.fork();
        log.debug("fork() {} + {}", n, t1);

        // 合并(join)结果
        int result = n + t1.join();
        log.debug("join() {} + {} = {}", n, t1, result);
        return result;
    }
}

/*求和结果*/

[ForkJoinPool-1-worker-0] - fork() 2 + {1} 
[ForkJoinPool-1-worker-1] - fork() 5 + {4} 
[ForkJoinPool-1-worker-0] - join() 1 
[ForkJoinPool-1-worker-0] - join() 2 + {1} = 3 
[ForkJoinPool-1-worker-2] - fork() 4 + {3} 
[ForkJoinPool-1-worker-3] - fork() 3 + {2} 
[ForkJoinPool-1-worker-3] - join() 3 + {2} = 6 
[ForkJoinPool-1-worker-2] - join() 4 + {3} = 10 
[ForkJoinPool-1-worker-1] - join() 5 + {4} = 15 
15 
    
/*改进代码*/
    
public static void main(String[] args) {
    ForkJoinPool pool = new ForkJoinPool(4);
    System.out.println(pool.invoke(new AddTask3(1, 10)));
}

class AddTask3 extends RecursiveTask&lt;Integer&gt; {

    int begin;
    int end;
    public AddTask3(int begin, int end) {
        this.begin = begin;
        this.end = end;
    }
    @Override
    public String toString() {
        return "{" + begin + "," + end + '}';
    }
    @Override
    protected Integer compute() {
        // 5, 5
        if (begin == end) {
            log.debug("join() {}", begin);
            return begin;
        }
        // 4, 5
        if (end - begin == 1) {
            log.debug("join() {} + {} = {}", begin, end, end + begin);
            return end + begin;
        }

        // 1 5
        int mid = (end + begin) / 2; // 3
        AddTask3 t1 = new AddTask3(begin, mid); // 1,3
        t1.fork();
        AddTask3 t2 = new AddTask3(mid + 1, end); // 4,5
        t2.fork();
        log.debug("fork() {} + {} = ?", t1, t2);
        int result = t1.join() + t2.join();
        log.debug("join() {} + {} = {}", t1, t2, result);
        return result;
    }
}

/*改进结果*/

[ForkJoinPool-1-worker-0] - join() 1 + 2 = 3 
[ForkJoinPool-1-worker-3] - join() 4 + 5 = 9 
[ForkJoinPool-1-worker-0] - join() 3 
[ForkJoinPool-1-worker-1] - fork() {1,3} + {4,5} = ? 
[ForkJoinPool-1-worker-2] - fork() {1,2} + {3,3} = ? 
[ForkJoinPool-1-worker-2] - join() {1,2} + {3,3} = 6 
[ForkJoinPool-1-worker-1] - join() {1,3} + {4,5} = 15 
15 </code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f3ee9fcc861962c5ec91f7132ad63b78/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">C&#43;&#43;-CMake命令：list</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/95de08395f51f6825ef32ddbb249f7b0/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">C语言之分支结构语句</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>