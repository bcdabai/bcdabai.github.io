<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>总结之前端安全篇 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="总结之前端安全篇" />
<meta property="og:description" content="文章目录 一、XSS攻击1、什么是XSS攻击2、XSS攻击的两种方式反射型攻击持久性攻击 3、如何防止XSS攻击4、XSS攻击要做什么坏事5、预防xss攻击方法 二、CSRF攻击1、什么是CSRF攻击2、CSRF攻击方式示例 3、如何防御CSRF？验证码验证Referercookie设置sameSite添加token验证 三、SQL注入1、什么是SQL注入示例 2、原因总结3、防止方法 一、XSS攻击 1、什么是XSS攻击 XSS攻击（跨站点脚本攻击），就是黑客恶意篡改你网页的前端代码，在里面注入一些恶意的 html&#43;javascript的脚本，并在你的浏览器内运行，获取你的信息，或者进行一些恶意操作。
2、XSS攻击的两种方式 反射型攻击 黑客在钓鱼网站设置其URL链接，URL链接可为色情动图、诱惑小视频，此URL链接内嵌有其恶意脚本，你点后 ,恶意脚本被返回至你的浏览器里。此时脚本就会运行，一旦控制了浏览器可得到大量东西，浏览器内包含cookie，可利用cookie伪造你的用户登录的session 状态，去以你这个用户的名义干一些事儿。
持久性攻击 持久型攻击，论坛、社交网站之类的系统，可发布一些帖子，评论。黑客可在里面写一段恶意脚本， 然后把恶意脚本混杂在评论内容里提交到网站的数据库里去 。然后其他用户在社交网站里浏览到了黑客的这个评论，评论内容会被返回到其浏览器里去，此时评论内容是包含恶意js脚本的，马上恶意脚本运行，可利用cookie伪造你的用户登录的session 状态，去以你这个用户的名义干一些事儿。
3、如何防止XSS攻击 包含恶意URL链接的图片、视频、动图、flash动画，少点，尽量使用正规的网站 ;
消毒机制，代码里必须对内容进行消毒，就是进行一些转义，比 如说把&gt;转义为&gt;之类的，这样就可以把恶意脚本里的html标签、js代码之类的东西，都给转义掉，让这些恶意脚本失效 -&gt; ，这种东西在浏览器里是不会运行的 这样的话，转义以后的脚本被其他用户看到的时候也不会在浏览器里运行了;
HttpOnly方式，这个意思是说如果你在浏览器里存放cookie的时候，可以设置一个HttpOnly属性，比如说存放用户加密认证信息的 cookie，这样的话，在浏览器里运行的js脚本是被禁止访问这些HttpOnly cookie的，他就无法窃取你在浏览器里存储的cookie了。
4、XSS攻击要做什么坏事 窃取cookie，然后借刀杀人，借用户的身份伪造数据请求；劫持流量，后导流到他的私域网站上去；插入广告；置入木马；获取用户信息； 5、预防xss攻击方法 二、CSRF攻击 1、什么是CSRF攻击 CSRF，即 Cross Site Request Forgery，是指跨站请求伪造，是一种劫持受信任用户向服务器发送非预期请求的攻击方式。
与XSS不同，XSS攻击是向受攻击网站进行脚本注入攻击，而CSRF攻击是其他网站对受攻击网站进行伪造请求。
2、CSRF攻击方式 CSRF 攻击是借助被攻击者的 Cookie 骗取服务器的信任，以被攻击者名义伪造请求发送给受攻击服务器，从而在并未授权的情况下执行在权限保护之下的操作。
示例 银行网站A，它以GET请求来完成银行转账的操作，如：http://www.mybank.com/Transfer.php?toBankId=11&amp;money=1000
危险网站B，它里面有一段HTML的代码如下：
&lt; img src =http://www.mybank.com/Transfer.php?toBankId=11&amp;money=1000 &gt;
首先，你登录了银行网站A，然后访问危险网站B，噢，这时你会发现你的银行账户少了1000块…
为什么会这样呢？原因是银行网站A违反了HTTP规范，使用GET请求更新资源。在访问危险网站B的之前，你已经登录了银行网站A，而B中的以GET的方式请求第三方资源（这里的第三方就是指银行网站了，原本这是一个合法的请求，但这里被不法分子利用了），所以你的浏览器会带上你的银行网站A的Cookie发出Get请求，去获取资源“http://www.mybank.com/Transfer.php?toBankId=11&amp;money=1000”，结果银行网站服务器收到请求后，认为这是一个更新资源操作（转账操作），所以就立刻进行转账操作…
3、如何防御CSRF？ 验证码 由于CSRF攻击伪造请求不会经过受攻击的网站，所以我们可以在网站加入验证码，这样必须通过验证码之后才能进行请求，有效的遏制了CSRF请求。
但是，这种方式不是万能的，并不是每个请求都加验证码，那样用户体验会非常不好，只能在部分请求添加，作为一种辅助的防御手段。
验证Referer 在HTTP协议中，头部有个Referer字段，他记录了该HTTP请求的来源地址，在服务端设置该字段的检验，通过检查该字段，就可以知道该请求是否合法。
cookie设置sameSite cookies设置sameSite属性的值为strict，这样只有同源网站的请求才会带上cookie。这样cookies就不能被其他域名网站使用，达到了防御的目的。
添加token验证 这是一种相对成熟的解决方案。要抵御 CSRF，关键在于在请求中放入攻击者所不能伪造的信息，并且该信息不存在于 Cookie 之中。在服务端随机生成token，在 HTTP 请求中以参数的形式加入这个 token，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有 token 或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/61903b9bdcde1016d33e574de1a1d9e4/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-04-13T18:45:06+08:00" />
<meta property="article:modified_time" content="2023-04-13T18:45:06+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">总结之前端安全篇</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#XSS_1" rel="nofollow">一、XSS攻击</a></li><li><ul><li><a href="#1XSS_2" rel="nofollow">1、什么是XSS攻击</a></li><li><a href="#2XSS_4" rel="nofollow">2、XSS攻击的两种方式</a></li><li><ul><li><a href="#_5" rel="nofollow">反射型攻击</a></li><li><a href="#_8" rel="nofollow">持久性攻击</a></li></ul> 
   </li><li><a href="#3XSS_10" rel="nofollow">3、如何防止XSS攻击</a></li><li><a href="#4XSS_18" rel="nofollow">4、XSS攻击要做什么坏事</a></li><li><a href="#5xss_24" rel="nofollow">5、预防xss攻击方法</a></li></ul> 
  </li><li><a href="#CSRF_27" rel="nofollow">二、CSRF攻击</a></li><li><ul><li><a href="#1CSRF_28" rel="nofollow">1、什么是CSRF攻击</a></li><li><a href="#2CSRF_31" rel="nofollow">2、CSRF攻击方式</a></li><li><ul><li><a href="#_33" rel="nofollow">示例</a></li></ul> 
   </li><li><a href="#3CSRF_41" rel="nofollow">3、如何防御CSRF？</a></li><li><ul><li><a href="#_42" rel="nofollow">验证码</a></li><li><a href="#Referer_47" rel="nofollow">验证Referer</a></li><li><a href="#cookiesameSite_50" rel="nofollow">cookie设置sameSite</a></li><li><a href="#token_53" rel="nofollow">添加token验证</a></li></ul> 
  </li></ul> 
  </li><li><a href="#SQL_59" rel="nofollow">三、SQL注入</a></li><li><ul><li><a href="#1SQL_60" rel="nofollow">1、什么是SQL注入</a></li><li><ul><li><ul><li><a href="#_64" rel="nofollow">示例</a></li></ul> 
   </li></ul> 
   </li><li><a href="#2_68" rel="nofollow">2、原因总结</a></li><li><a href="#3_75" rel="nofollow">3、防止方法</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="XSS_1"></a>一、XSS攻击</h2> 
<h3><a id="1XSS_2"></a>1、什么是XSS攻击</h3> 
<p>XSS攻击（跨站点脚本攻击），就是黑客恶意篡改你网页的前端代码，在里面注入一些恶意的 html+javascript的脚本，并在你的浏览器内运行，获取你的信息，或者进行一些恶意操作。</p> 
<h3><a id="2XSS_4"></a>2、XSS攻击的两种方式</h3> 
<h4><a id="_5"></a>反射型攻击</h4> 
<p>黑客在钓鱼网站设置其URL链接，URL链接可为色情动图、诱惑小视频，此URL链接内嵌有其恶意脚本，你点后 ,恶意脚本被返回至你的浏览器里。此时脚本就会运行，一旦控制了浏览器可得到大量东西，浏览器内包含cookie，可利用cookie伪造你的用户登录的session 状态，去以你这个用户的名义干一些事儿。</p> 
<h4><a id="_8"></a>持久性攻击</h4> 
<p>持久型攻击，论坛、社交网站之类的系统，可发布一些帖子，评论。黑客可在里面写一段恶意脚本， 然后把恶意脚本混杂在评论内容里提交到网站的数据库里去 。然后其他用户在社交网站里浏览到了黑客的这个评论，评论内容会被返回到其浏览器里去，此时评论内容是包含恶意js脚本的，马上恶意脚本运行，可利用cookie伪造你的用户登录的session 状态，去以你这个用户的名义干一些事儿。</p> 
<h3><a id="3XSS_10"></a>3、如何防止XSS攻击</h3> 
<ul><li> <p>包含恶意URL链接的图片、视频、动图、flash动画，少点，尽量使用正规的网站 ;</p> </li><li> <p>消毒机制，代码里必须对内容进行消毒，就是进行一些转义，比 如说把&gt;转义为&gt;之类的，这样就可以把恶意脚本里的html标签、js代码之类的东西，都给转义掉，让这些恶意脚本失效 -&gt; ，这种东西在浏览器里是不会运行的 这样的话，转义以后的脚本被其他用户看到的时候也不会在浏览器里运行了;</p> </li><li> <p>HttpOnly方式，这个意思是说如果你在浏览器里存放cookie的时候，可以设置一个HttpOnly属性，比如说存放用户加密认证信息的 cookie，这样的话，在浏览器里运行的js脚本是被禁止访问这些HttpOnly cookie的，他就无法窃取你在浏览器里存储的cookie了。</p> </li></ul> 
<h3><a id="4XSS_18"></a>4、XSS攻击要做什么坏事</h3> 
<ul><li>窃取cookie，然后借刀杀人，借用户的身份伪造数据请求；</li><li>劫持流量，后导流到他的私域网站上去；</li><li>插入广告；</li><li>置入木马；</li><li>获取用户信息；</li></ul> 
<h3><a id="5xss_24"></a>5、预防xss攻击方法</h3> 
<p><img src="https://images2.imgbox.com/0f/b6/2pkoFnYO_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="CSRF_27"></a>二、CSRF攻击</h2> 
<h3><a id="1CSRF_28"></a>1、什么是CSRF攻击</h3> 
<p>CSRF，即 Cross Site Request Forgery，是指跨站请求伪造，是一种劫持受信任用户向服务器发送非预期请求的攻击方式。<br> 与XSS不同，XSS攻击是向受攻击网站进行脚本注入攻击，而CSRF攻击是其他网站对受攻击网站进行伪造请求。</p> 
<h3><a id="2CSRF_31"></a>2、CSRF攻击方式</h3> 
<p>CSRF 攻击是借助被攻击者的 Cookie 骗取服务器的信任，以被攻击者名义伪造请求发送给受攻击服务器，从而在并未授权的情况下执行在权限保护之下的操作。</p> 
<h4><a id="_33"></a>示例</h4> 
<p>银行网站A，它以GET请求来完成银行转账的操作，如：http://www.mybank.com/Transfer.php?toBankId=11&amp;money=1000</p> 
<p>危险网站B，它里面有一段HTML的代码如下：<br> <code>&lt; img src =http://www.mybank.com/Transfer.php?toBankId=11&amp;money=1000 &gt;</code><br> 首先，你登录了银行网站A，然后访问危险网站B，噢，这时你会发现你的银行账户少了1000块…</p> 
<p>为什么会这样呢？原因是银行网站A违反了HTTP规范，使用GET请求更新资源。在访问危险网站B的之前，你已经登录了银行网站A，而B中的以GET的方式请求第三方资源（这里的第三方就是指银行网站了，原本这是一个合法的请求，但这里被不法分子利用了），所以你的浏览器会带上你的银行网站A的Cookie发出Get请求，去获取资源“http://www.mybank.com/Transfer.php?toBankId=11&amp;money=1000”，结果银行网站服务器收到请求后，认为这是一个更新资源操作（转账操作），所以就立刻进行转账操作…</p> 
<h3><a id="3CSRF_41"></a>3、如何防御CSRF？</h3> 
<h4><a id="_42"></a>验证码</h4> 
<p>由于CSRF攻击伪造请求不会经过受攻击的网站，所以我们可以在网站加入验证码，这样必须通过验证码之后才能进行请求，有效的遏制了CSRF请求。</p> 
<p>但是，这种方式不是万能的，并不是每个请求都加验证码，那样用户体验会非常不好，只能在部分请求添加，作为一种辅助的防御手段。</p> 
<h4><a id="Referer_47"></a>验证Referer</h4> 
<p>在HTTP协议中，头部有个Referer字段，他记录了该HTTP请求的来源地址，在服务端设置该字段的检验，通过检查该字段，就可以知道该请求是否合法。</p> 
<h4><a id="cookiesameSite_50"></a>cookie设置sameSite</h4> 
<p>cookies设置sameSite属性的值为strict，这样只有同源网站的请求才会带上cookie。这样cookies就不能被其他域名网站使用，达到了防御的目的。</p> 
<h4><a id="token_53"></a>添加token验证</h4> 
<p>这是一种相对成熟的解决方案。要抵御 CSRF，关键在于在请求中放入攻击者所不能伪造的信息，并且该信息不存在于 Cookie 之中。在服务端随机生成token，在 HTTP 请求中以参数的形式加入这个 token，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有 token 或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。</p> 
<p>token会保存在服务端session中，同时保存到客户端中。在客户端中通常存储在LocalStorage中，在Vue框架中，我们还可以将token存放在Vuex的state中。</p> 
<h2><a id="SQL_59"></a>三、SQL注入</h2> 
<h3><a id="1SQL_60"></a>1、什么是SQL注入</h3> 
<p>SQL注入是一种非常常见的数据库攻击手段，SQL注入漏洞也是网络世界中最普遍的漏洞之一。<br> 就是访问用户通过网站前端对网站可以输入参数的地方进行提交参数，参数里插入了一些恶意参数传入到服务器后端里去，服务器后端并没有对其进行详细的安全过滤，导致直接进入到数据库里，执行了数据库的sql语句，sql语句可以是查询网站的管理员账号，密码，查询数据库的地址等等的敏感信息，这个就是sql注入攻击。</p> 
<h5><a id="_64"></a>示例</h5> 
<p>某学长通过攻击学校数据库修改自己成绩，一般用的就是SQL注入方法。</p> 
<h3><a id="2_68"></a>2、原因总结</h3> 
<p>对sql语句和关键字未进行过滤</p> 
<p>当前端传过来的数据进入到后端进行处理时，没做严格的判断，导致其传入的‘数据(含有sql关键字)’ 在拼接sql语句中<br> 由于其特殊性，被当作sql语句的一部分被执行，导致数据库受损(修改，删除等)</p> 
<h3><a id="3_75"></a>3、防止方法</h3> 
<ul><li> <p>过滤掉关键字：select、insert、update、delete、and等;</p> </li><li> <p>执行 sql语句时使用系统函数addslashes进行 sql语句转换</p> </li><li> <p>提高数据库命名技巧，对于一些重要字段根据程序特点命名，取不易猜到的(lcuuid as uuid)</p> </li><li> <p>对于常用的方法加以封装，避免直接暴露sql语句,例如 orm</p> </li><li> <p>开启安全模式，safe_mode=on</p> </li><li> <p>打开magic_quotes_gpc=off,默认是关闭的，它打开后自动把用户提交的sql语句进行转换（加上\转义），这对防止sql注入有很大作用；on</p> </li><li> <p>Sql语句书写尽量不要省略双引号和单引号</p> </li><li> <p>关键日志错误信息不要暴漏到页面，转到系统中去</p> </li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/1b9a8145e99c73b2c9e60884a2ac8b58/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">洛谷题解【入门一】顺序结构</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/981212ffe4ac79e316f5716243e239ca/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Java时间轮算法：多级时间轮的实现和优点</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>