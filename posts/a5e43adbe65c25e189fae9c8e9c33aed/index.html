<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【Linux】编译安装nginx，手写service配置文件，深度理解systemd控制管理服务底层原理 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【Linux】编译安装nginx，手写service配置文件，深度理解systemd控制管理服务底层原理" />
<meta property="og:description" content="目录
一、了解服务
1、服务的本质
2、centos7的systemd的服务
3、service unit file配置文件的组成以及掌握常用选项
4、关于systemd管理的命令学习
5、运行级别
二、编译安装nginx，以及手写service配置文件，请看注释
​编辑
一、了解服务 1、服务的本质 “服务”的本质是一种程序，“服务”分两种：
程序服务程序：对内，为保证计算机的正常运行，比如systemd，协助管理程序
用户服务程序：对外，给网络上用户提供各种功能，比如购物、游戏等，常见httpd
服务一般是后台运行，已准备随时调用
2、centos7的systemd的服务 centos 6采用init初始化进程，是一个一个串行启动
centos7采用systemd作为祖宗进程，systemd也是一种init程序，①解决依赖关系并行启动；②按需启动（根据服务配置设定启动）③负责在系统启动或者运行时，激活系统资源、服务进程等
systemd还提供叫醒服务，举例，安装rpcbind，将其关闭，然后用另一台主机进行探测连接，查看进程状态，实验看一下
systemd可以向后兼容sysvinit，systemd可以将多个程序进行单元管理，单元类型分类：
单元类型扩展名说明Serviceservice描述一个系统服务软件（这是我们最需要知道的）Socket.socket描述一个进程间通信的套接字Device.device描述一个内核识别的设备文件Mount.mount描述一个文件系统的挂载点Automount.automount描述一个文件系统的自动挂载点Swap.swap描述一个内存交换设备或交换文件Path.path描述一个文件系统中文件或目录Timertimer描述一个定时器 (用于实现类似cron的调度任务)Snapshot.snapshot用于保存一个systemd的状态Scope.scope使用systemd的总线接口以编程的方式创建外部进程Slice.slice描述居于Cgroup的一组通过层次组织的管理系统进程Target.taget描述一组systemd的单元（我觉得可以理解为运行级别） 3、service unit file配置文件的组成以及掌握常用选项 要知道，yum和rpm安装的时候系统，安装的是软件包，是已经写好了，会自动将service配置文件放到/usr/lib/systemd/system/这个文件夹中，让这个服务程序自动被systemd管理，但是编译安装是不会自动被管理，那么如果想要被systemd管理，则需要手动编写service配置文件。
这里拓展一下，systemd统一管理的好处：
1、对计算机而言，systemd有一套自己的启动、关闭等命令规则，这样可以套公式一样进行所有程序的管理，也可以理解为这是为了有一套制度，更好的调度计算机理解需求；
2、对于电脑面前的运维工程师，可以更好的去查看记忆程序状态，尤其是管理大量不同程序的情况下，可以统一规则。
关于配置文件的书写格式：
service unit file文件通常由三部分组成： [Unit]：定义与Unit类型无关的通用选项；用于提供unit的描述信息、unit行为及依赖关系等 [Service]：与特定类型相关的专用选项；此处为Service类型 #service这一步非常非常重要！！！ [Install]：定义由“systemctl enable”以及&#34;systemctl disable“命令在实现服务启用或禁用时用到 的一些选项 Unit段的常用选项Description描述信息（一般会写一个描述，等下看实操案例）After/Before自定义unit的启动顺序，表示当前unit应该晚于或者优先于哪些unit启动Requires依赖到的其它units，强依赖，被依赖的units无法激活时，当前unit也无法激活Wants依赖到的其它units，弱依赖Conflicts定义units间的冲突关系 Service段的常用选项 Type定义影响ExecStart及相关参数的功能的unit进程启动类型simple默认值，这个daemon主要由ExecStart接的指令串来启动，启动后常驻于内存中forking由ExecStart启动的程序透过spawns延伸出其他子程序来作为此daemon的主要服务。原生父程序在启动结束后就会终止oneshot与simple类似，不过这个程序在工作完毕后就结束了，不会常驻在内存中dbus与simple类似，但这个daemon必须要在取得一个D-Bus的名称后，才会继续运作.因此通常也要同时设定BusNname= 才行notify在启动完成后会发送一个通知消息。还需要配合 NotifyAccess 来让 Systemd 接收消息idle与simple类似，要执行这个daemon必须要所有的工作都顺利执行完毕后才会执行。这类的daemon通常是开机到最后才执行即可的服务notify在启动完成后会发送一个通知消息。还需要配合 NotifyAccess 来让 Systemd 接收消息idle与simple类似，要执行这个daemon必须要所有的工作都顺利执行完毕后才会执行。这类的daemon通常是开机到最后才执行即可的服务EnvironmentFile环境配置文件ExecStart指明启动unit要运行命令或脚本的绝对路径（最最最重要）ExecStartPre ExecStart前运行ExecStartPost ExecStart后运行ExecStop指明停止unit要运行的命令或脚本的绝对路径（最最最重要）ExecReload指明程序重新加载unit要运行的命令或脚本的绝对路径（最最最重要）Restart当设定Restart=1 时，则当次daemon服务意外终止后，会再次自动启动此服务RestartSec设置在重启服务( Restart= )前暂停多长时间。 默认值是100毫秒(100ms)。 如果未指定时间单位，那么将视为以秒为单位。 例如设为&#34;20&#34;等价于设为&#34;20s&#34;。PrivateTmp设定为yes时，会在生成/tmp/systemd-private-UUID-NAME.service-XXXXX/tmp/目录 Install字段的常用选项Alias别名，可使用systemctl command Alias.serviceRequiredBy被哪些units所依赖，强依赖WantedBy被哪些units所依赖，弱依赖（一般会写一个弱依赖，等下看实操案例）Also安装本服务的时候还要安装别的相关服务 4、关于systemd管理的命令学习 命令功能systemctl start 软件名开启进程systemctl stop 软件名关闭进程systemctl status 软件名查看进程状态systemctl restart 软件名重启进程（先关闭后启动）systemctl reload 软件名重新加载（不关闭的状态下更新）systemctl enable 软件名开机自启动systemctl enable --now 软件名开启自启动并现在启动systemctl disable 软件名开机不自启systemctl disable --now 软件名开机不自启并现在关闭systemctl daemon-reload 重新加载新服务，让系统识别" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/a5e43adbe65c25e189fae9c8e9c33aed/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-11-04T10:59:10+08:00" />
<meta property="article:modified_time" content="2023-11-04T10:59:10+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【Linux】编译安装nginx，手写service配置文件，深度理解systemd控制管理服务底层原理</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="-toc" style="margin-left:0px;"></p> 
<p id="%E4%B8%80%E3%80%81%E4%BA%86%E8%A7%A3%E6%9C%8D%E5%8A%A1-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%E4%BA%86%E8%A7%A3%E6%9C%8D%E5%8A%A1" rel="nofollow">一、了解服务</a></p> 
<p id="1%E3%80%81%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%9C%AC%E8%B4%A8-toc" style="margin-left:40px;"><a href="#1%E3%80%81%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%9C%AC%E8%B4%A8" rel="nofollow">1、服务的本质</a></p> 
<p id="2%E3%80%81centos7%E7%9A%84systemd%E7%9A%84%E6%9C%8D%E5%8A%A1-toc" style="margin-left:40px;"><a href="#2%E3%80%81centos7%E7%9A%84systemd%E7%9A%84%E6%9C%8D%E5%8A%A1" rel="nofollow">2、centos7的systemd的服务</a></p> 
<p id="3%E3%80%81service%20unit%20file%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9A%84%E7%BB%84%E6%88%90%E4%BB%A5%E5%8F%8A%E6%8E%8C%E6%8F%A1%E5%B8%B8%E7%94%A8%E9%80%89%E9%A1%B9-toc" style="margin-left:40px;"><a href="#3%E3%80%81service%20unit%20file%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9A%84%E7%BB%84%E6%88%90%E4%BB%A5%E5%8F%8A%E6%8E%8C%E6%8F%A1%E5%B8%B8%E7%94%A8%E9%80%89%E9%A1%B9" rel="nofollow">3、service unit file配置文件的组成以及掌握常用选项</a></p> 
<p id="4%E3%80%81%E5%85%B3%E4%BA%8Esystemd%E7%AE%A1%E7%90%86%E7%9A%84%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0-toc" style="margin-left:40px;"><a href="#4%E3%80%81%E5%85%B3%E4%BA%8Esystemd%E7%AE%A1%E7%90%86%E7%9A%84%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0" rel="nofollow">4、关于systemd管理的命令学习</a></p> 
<p id="5%E3%80%81%E8%BF%90%E8%A1%8C%E7%BA%A7%E5%88%AB-toc" style="margin-left:40px;"><a href="#5%E3%80%81%E8%BF%90%E8%A1%8C%E7%BA%A7%E5%88%AB" rel="nofollow">5、运行级别</a></p> 
<p id="%E4%BA%8C%E3%80%81%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85nginx%EF%BC%8C%E4%BB%A5%E5%8F%8A%E6%89%8B%E5%86%99service%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%EF%BC%8C%E8%AF%B7%E7%9C%8B%E6%B3%A8%E9%87%8A-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85nginx%EF%BC%8C%E4%BB%A5%E5%8F%8A%E6%89%8B%E5%86%99service%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%EF%BC%8C%E8%AF%B7%E7%9C%8B%E6%B3%A8%E9%87%8A" rel="nofollow">二、编译安装nginx，以及手写service配置文件，请看注释</a></p> 
<p id="%E2%80%8B%E7%BC%96%E8%BE%91-toc" style="margin-left:0px;"><a href="#%E2%80%8B%E7%BC%96%E8%BE%91" rel="nofollow">​编辑</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E4%B8%80%E3%80%81%E4%BA%86%E8%A7%A3%E6%9C%8D%E5%8A%A1">一、了解服务</h2> 
<h3 id="1%E3%80%81%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%9C%AC%E8%B4%A8">1、服务的本质</h3> 
<p><span style="background-color:#ffd900;">“服务”的本质是一种程序，</span>“服务”分两种：</p> 
<p><strong><span style="color:#fe2c24;">程序服务程序：</span>对内，为保证计算机的正常运行，比如systemd，协助管理程序</strong></p> 
<p><strong><span style="color:#fe2c24;">用户服务程序：</span>对外，给网络上用户提供各种功能，比如购物、游戏等，常见httpd</strong></p> 
<p><strong>服务一般是后台运行，已准备随时调用</strong></p> 
<h3 id="2%E3%80%81centos7%E7%9A%84systemd%E7%9A%84%E6%9C%8D%E5%8A%A1">2、centos7的systemd的服务</h3> 
<p>centos 6采用init初始化进程，是一个一个串行启动</p> 
<p>centos7采用systemd作为祖宗进程，systemd也是一种init程序，<strong>①解决依赖关系并行启动；②按需启动（根据服务配置设定启动）③负责在系统启动或者运行时，激活系统资源、服务进程等</strong></p> 
<blockquote> 
 <p><strong>systemd还提供叫醒服务，举例，安装rpcbind，将其关闭，然后用另一台主机进行探测连接，查看进程状态，实验看一下</strong></p> 
</blockquote> 
<p><img alt="" height="1075" src="https://images2.imgbox.com/46/80/PYj4z7t0_o.png" width="1200"></p> 
<p><img alt="" height="568" src="https://images2.imgbox.com/fc/f3/nz29xC9X_o.png" width="1200"></p> 
<p>systemd可以向后兼容sysvinit，<strong><span style="background-color:#ffd900;">systemd可以将多个程序进行单元管理</span></strong>，单元类型分类：</p> 
<table cellspacing="0" style="width:419pt;"><tbody><tr><td style="background-color:#c00000;border-color:#000000;vertical-align:middle;width:60pt;"><span style="color:#ffffff;"><strong>单元类型</strong></span></td><td style="background-color:#c00000;border-color:#000000;vertical-align:middle;width:66pt;"><span style="color:#ffffff;"><strong>扩展名</strong></span></td><td style="background-color:#c00000;border-color:#000000;vertical-align:middle;width:293pt;"><span style="color:#ffffff;"><strong>说明</strong></span></td></tr><tr><td style="border-color:#000000;vertical-align:middle;"><span style="color:#ff0000;"><strong>Service</strong></span></td><td style="border-color:#000000;vertical-align:middle;"><span style="color:#ff0000;"><strong>service</strong></span></td><td style="border-color:#000000;vertical-align:middle;"><span style="color:#ff0000;"><strong>描述一个系统服务软件（这是我们最需要知道的）</strong></span></td></tr><tr><td style="border-color:#000000;vertical-align:middle;"><span style="color:#000000;">Socket</span></td><td style="border-color:#000000;vertical-align:middle;"><span style="color:#000000;">.socket</span></td><td style="border-color:#000000;vertical-align:middle;"><span style="color:#000000;">描述一个进程间通信的套接字</span></td></tr><tr><td style="border-color:#000000;vertical-align:middle;"><span style="color:#000000;">Device</span></td><td style="border-color:#000000;vertical-align:middle;"><span style="color:#000000;">.device</span></td><td style="border-color:#000000;vertical-align:middle;"><span style="color:#000000;">描述一个内核识别的设备文件</span></td></tr><tr><td style="border-color:#000000;vertical-align:middle;"><span style="color:#000000;">Mount</span></td><td style="border-color:#000000;vertical-align:middle;"><span style="color:#000000;">.mount</span></td><td style="border-color:#000000;vertical-align:middle;"><span style="color:#000000;">描述一个文件系统的挂载点</span></td></tr><tr><td style="border-color:#000000;vertical-align:middle;"><span style="color:#000000;">Automount</span></td><td style="border-color:#000000;vertical-align:middle;"><span style="color:#000000;">.automount</span></td><td style="border-color:#000000;vertical-align:middle;"><span style="color:#000000;">描述一个文件系统的自动挂载点</span></td></tr><tr><td style="border-color:#000000;vertical-align:middle;"><span style="color:#000000;">Swap</span></td><td style="border-color:#000000;vertical-align:middle;"><span style="color:#000000;">.swap</span></td><td style="border-color:#000000;vertical-align:middle;"><span style="color:#000000;">描述一个内存交换设备或交换文件</span></td></tr><tr><td style="border-color:#000000;vertical-align:middle;"><span style="color:#000000;">Path</span></td><td style="border-color:#000000;vertical-align:middle;"><span style="color:#000000;">.path</span></td><td style="border-color:#000000;vertical-align:middle;"><span style="color:#000000;">描述一个文件系统中文件或目录</span></td></tr><tr><td style="border-color:#000000;vertical-align:middle;"><span style="color:#000000;">Timer</span></td><td style="border-color:#000000;vertical-align:middle;"><span style="color:#000000;">timer</span></td><td style="border-color:#000000;vertical-align:middle;"><span style="color:#000000;">描述一个定时器 (用于实现类似cron的调度任务)</span></td></tr><tr><td style="border-color:#000000;vertical-align:middle;"><span style="color:#000000;">Snapshot</span></td><td style="border-color:#000000;vertical-align:middle;"><span style="color:#000000;">.snapshot</span></td><td style="border-color:#000000;vertical-align:middle;"><span style="color:#000000;">用于保存一个systemd的状态</span></td></tr><tr><td style="border-color:#000000;vertical-align:middle;"><span style="color:#000000;">Scope</span></td><td style="border-color:#000000;vertical-align:middle;"><span style="color:#000000;">.scope</span></td><td style="border-color:#000000;vertical-align:middle;"><span style="color:#000000;">使用systemd的总线接口以编程的方式创建外部进程</span></td></tr><tr><td style="border-color:#000000;vertical-align:middle;"><span style="color:#000000;">Slice</span></td><td style="border-color:#000000;vertical-align:middle;"><span style="color:#000000;">.slice</span></td><td style="border-color:#000000;vertical-align:middle;"><span style="color:#000000;">描述居于Cgroup的一组通过层次组织的管理系统进程</span></td></tr><tr><td style="border-color:#000000;vertical-align:middle;"><span style="color:#ff0000;"><strong>Target</strong></span></td><td style="border-color:#000000;vertical-align:middle;"><span style="color:#ff0000;"><strong>.taget</strong></span></td><td style="border-color:#000000;vertical-align:middle;"><span style="color:#ff0000;"><strong>描述一组systemd的单元（我觉得可以理解为运行级别）</strong></span></td></tr></tbody></table> 
<h3 id="3%E3%80%81service%20unit%20file%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9A%84%E7%BB%84%E6%88%90%E4%BB%A5%E5%8F%8A%E6%8E%8C%E6%8F%A1%E5%B8%B8%E7%94%A8%E9%80%89%E9%A1%B9">3、service unit file配置文件的组成以及掌握常用选项</h3> 
<p>要知道，yum和rpm安装的时候系统，安装的是软件包，是已经写好了，会自动将service配置文件放到/usr/lib/systemd/system/这个文件夹中，让这个服务程序自动被systemd管理，但是编译安装是不会自动被管理，那么如果想要被systemd管理，则需要手动编写service配置文件。</p> 
<blockquote> 
 <p>这里拓展一下，systemd统一管理的好处：</p> 
 <p>1、对计算机而言，systemd有一套自己的启动、关闭等命令规则，这样可以套公式一样进行所有程序的管理，也可以理解为这是为了有一套制度，更好的调度计算机理解需求；</p> 
 <p>2、对于电脑面前的运维工程师，可以更好的去查看记忆程序状态，尤其是管理大量不同程序的情况下，可以统一规则。</p> 
</blockquote> 
<p>关于配置文件的书写格式：</p> 
<pre><code>service unit file文件通常由三部分组成：

[Unit]：定义与Unit类型无关的通用选项；用于提供unit的描述信息、unit行为及依赖关系等

[Service]：与特定类型相关的专用选项；此处为Service类型
#service这一步非常非常重要！！！

[Install]：定义由“systemctl enable”以及"systemctl disable“命令在实现服务启用或禁用时用到
的一些选项</code></pre> 
<table cellspacing="0" style="width:480pt;"><tbody><tr><td colspan="2" style="background-color:#c00000;text-align:center;vertical-align:middle;width:480pt;"><span style="color:#ffffff;"><strong>Unit段的常用选项</strong></span></td></tr><tr><td style="border-color:#000000;vertical-align:middle;"><strong><span style="color:#000000;">Description</span></strong></td><td style="border-color:#000000;vertical-align:middle;"><strong><span style="color:#000000;">描述信息（一般会写一个描述，等下看实操案例）</span></strong></td></tr><tr><td style="border-color:#000000;vertical-align:middle;"><span style="color:#000000;">After/Before</span></td><td style="border-color:#000000;vertical-align:middle;"><span style="color:#000000;">自定义unit的启动顺序，表示当前unit应该晚于或者优先于哪些unit启动</span></td></tr><tr><td style="border-color:#000000;vertical-align:middle;"><span style="color:#000000;">Requires</span></td><td style="border-color:#000000;vertical-align:middle;"><span style="color:#000000;">依赖到的其它units，强依赖，被依赖的units无法激活时，当前unit也无法激活</span></td></tr><tr><td style="border-color:#000000;vertical-align:middle;"><span style="color:#000000;">Wants</span></td><td style="border-color:#000000;vertical-align:middle;"><span style="color:#000000;">依赖到的其它units，弱依赖</span></td></tr><tr><td style="border-color:#000000;vertical-align:middle;"><span style="color:#000000;">Conflicts</span></td><td style="border-color:#000000;vertical-align:middle;"><span style="color:#000000;">定义units间的冲突关系</span></td></tr></tbody></table> 
<table cellspacing="0"><tbody><tr><td colspan="3" style="background-color:#c00000;text-align:center;vertical-align:middle;"><span style="color:#ffffff;"><strong>Service段的常用选项                                                                                  </strong></span></td></tr><tr><td rowspan="9" style="background-color:#f2f2f2;border-color:#000000;text-align:center;vertical-align:middle;"><span style="color:#000000;">Type</span></td><td colspan="2" style="background-color:#f2f2f2;border-color:#000000;text-align:left;vertical-align:middle;"><span style="color:#000000;">定义影响ExecStart及相关参数的功能的unit进程启动类型</span></td></tr><tr><td style="background-color:#f2f2f2;border-color:#000000;text-align:center;vertical-align:middle;"><span style="color:#000000;">simple</span></td><td style="background-color:#f2f2f2;border-color:#000000;text-align:left;vertical-align:middle;"><span style="color:#000000;">默认值，这个daemon主要由ExecStart接的指令串来启动，启动后常驻于内存中</span></td></tr><tr><td style="background-color:#f2f2f2;border-color:#000000;text-align:center;vertical-align:middle;"><span style="color:#000000;">forking</span></td><td style="background-color:#f2f2f2;border-color:#000000;text-align:left;vertical-align:middle;"><span style="color:#000000;">由ExecStart启动的程序透过spawns延伸出其他子程序来作为此daemon的主要服务。原生父程序在启动结束后就会终止</span></td></tr><tr><td style="background-color:#f2f2f2;border-color:#000000;text-align:center;vertical-align:middle;"><span style="color:#000000;">oneshot</span></td><td style="background-color:#f2f2f2;border-color:#000000;text-align:left;vertical-align:middle;"><span style="color:#000000;">与simple类似，不过这个程序在工作完毕后就结束了，不会常驻在内存中</span></td></tr><tr><td style="background-color:#f2f2f2;border-color:#000000;text-align:center;vertical-align:middle;"><span style="color:#000000;">dbus</span></td><td style="background-color:#f2f2f2;border-color:#000000;text-align:left;vertical-align:middle;"><span style="color:#000000;">与simple类似，但这个daemon必须要在取得一个D-Bus的名称后，才会继续运作.因此通常也要同时设定BusNname= 才行</span></td></tr><tr><td style="background-color:#f2f2f2;border-color:#000000;text-align:center;vertical-align:middle;"><span style="color:#000000;">notify</span></td><td style="background-color:#f2f2f2;border-color:#000000;text-align:left;vertical-align:middle;"><span style="color:#000000;">在启动完成后会发送一个通知消息。还需要配合 NotifyAccess 来让 Systemd 接收消息</span></td></tr><tr><td style="background-color:#f2f2f2;border-color:#000000;text-align:center;vertical-align:middle;"><span style="color:#000000;">idle</span></td><td style="background-color:#f2f2f2;border-color:#000000;text-align:left;vertical-align:middle;"><span style="color:#000000;">与simple类似，要执行这个daemon必须要所有的工作都顺利执行完毕后才会执行。这类的daemon通常是开机到最后才执行即可的服务</span></td></tr><tr><td style="background-color:#f2f2f2;border-color:#000000;text-align:center;vertical-align:middle;"><span style="color:#000000;">notify</span></td><td style="background-color:#f2f2f2;border-color:#000000;text-align:left;vertical-align:middle;"><span style="color:#000000;">在启动完成后会发送一个通知消息。还需要配合 NotifyAccess 来让 Systemd 接收消息</span></td></tr><tr><td style="background-color:#f2f2f2;border-color:#000000;text-align:center;vertical-align:middle;"><span style="color:#000000;">idle</span></td><td style="background-color:#f2f2f2;border-color:#000000;text-align:left;vertical-align:middle;"><span style="color:#000000;">与simple类似，要执行这个daemon必须要所有的工作都顺利执行完毕后才会执行。这类的daemon通常是开机到最后才执行即可的服务</span></td></tr><tr><td style="border-color:#000000;text-align:center;vertical-align:middle;"><span style="color:#000000;">EnvironmentFile</span></td><td colspan="2" style="text-align:left;vertical-align:middle;"><span style="color:#000000;">环境配置文件</span></td></tr><tr><td style="border-color:#000000;text-align:center;vertical-align:middle;"><span style="color:#ff0000;"><strong>ExecStart</strong></span></td><td colspan="2" style="text-align:left;vertical-align:middle;"><span style="color:#ff0000;"><strong>指明启动unit要运行命令或脚本的绝对路径（最最最重要）</strong></span></td></tr><tr><td style="border-color:#000000;text-align:center;vertical-align:middle;"><span style="color:#000000;">ExecStartPre</span></td><td colspan="2" style="text-align:left;vertical-align:middle;"><span style="color:#000000;"> ExecStart前运行</span></td></tr><tr><td style="border-color:#000000;text-align:center;vertical-align:middle;"><span style="color:#000000;">ExecStartPost</span></td><td colspan="2" style="text-align:left;vertical-align:middle;"><span style="color:#000000;"> ExecStart后运行</span></td></tr><tr><td style="border-color:#000000;text-align:center;vertical-align:middle;"><span style="color:#ff0000;"><strong>ExecStop</strong></span></td><td colspan="2" style="text-align:left;vertical-align:middle;"><span style="color:#ff0000;"><strong>指明停止unit要运行的命令或脚本的绝对路径（最最最重要）</strong></span></td></tr><tr><td style="border-color:#000000;text-align:center;vertical-align:middle;"><span style="color:#ff0000;"><strong>ExecReload</strong></span></td><td colspan="2" style="text-align:left;vertical-align:middle;"><span style="color:#ff0000;"><strong>指明程序重新加载unit要运行的命令或脚本的绝对路径（最最最重要）</strong></span></td></tr><tr><td style="border-color:#000000;text-align:center;vertical-align:middle;"><span style="color:#000000;">Restart</span></td><td colspan="2" style="text-align:left;vertical-align:middle;"><span style="color:#000000;">当设定Restart=1 时，则当次daemon服务意外终止后，会再次自动启动此服务</span></td></tr><tr><td style="border-color:#000000;text-align:center;vertical-align:middle;"><span style="color:#000000;">RestartSec</span></td><td colspan="2" style="text-align:left;vertical-align:middle;width:480pt;"><span style="color:#000000;">设置在重启服务( Restart= )前暂停多长时间。 默认值是100毫秒(100ms)。 如果未指定时间单位，那么将视为以秒为单位。 例如设为"20"等价于设为"20s"。</span></td></tr><tr><td style="border-color:#000000;text-align:center;vertical-align:middle;"><span style="color:#000000;">PrivateTmp</span></td><td colspan="2" style="text-align:left;vertical-align:middle;"><span style="color:#000000;">设定为yes时，会在生成/tmp/systemd-private-UUID-NAME.service-XXXXX/tmp/目录</span></td></tr></tbody></table> 
<table cellspacing="0" style="width:341pt;"><tbody><tr><td colspan="2" style="background-color:#c00000;text-align:center;vertical-align:middle;width:341pt;"><span style="color:#ffffff;"><strong>Install字段的常用选项</strong></span></td></tr><tr><td style="border-color:#000000;vertical-align:middle;"><span style="color:#000000;">Alias</span></td><td style="border-color:#000000;vertical-align:middle;"><span style="color:#000000;">别名，可使用systemctl command Alias.service</span></td></tr><tr><td style="border-color:#000000;vertical-align:middle;"><span style="color:#000000;">RequiredBy</span></td><td style="border-color:#000000;vertical-align:middle;"><span style="color:#000000;">被哪些units所依赖，强依赖</span></td></tr><tr><td style="border-color:#000000;vertical-align:middle;"><strong><span style="color:#000000;">WantedBy</span></strong></td><td style="border-color:#000000;vertical-align:middle;"><strong><span style="color:#000000;">被哪些units所依赖，弱依赖（一般会写一个弱依赖，等下看实操案例）</span></strong></td></tr><tr><td style="border-color:#000000;vertical-align:middle;"><span style="color:#000000;">Also</span></td><td style="border-color:#000000;vertical-align:middle;"><span style="color:#000000;">安装本服务的时候还要安装别的相关服务</span></td></tr></tbody></table> 
<h3 id="4%E3%80%81%E5%85%B3%E4%BA%8Esystemd%E7%AE%A1%E7%90%86%E7%9A%84%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0">4、关于systemd管理的命令学习</h3> 
<table cellspacing="0" style="width:383pt;"><tbody><tr><td style="background-color:#c00000;border-color:#000000;text-align:center;vertical-align:middle;width:188pt;"><span style="color:#ffffff;"><strong>命令</strong></span></td><td style="background-color:#c00000;border-color:#000000;text-align:center;vertical-align:middle;width:195pt;"><span style="color:#ffffff;"><strong>功能</strong></span></td></tr><tr><td style="border-color:#000000;text-align:left;vertical-align:middle;"><span style="color:#000000;">systemctl   start 软件名</span></td><td style="border-color:#000000;text-align:left;vertical-align:middle;"><span style="color:#000000;">开启进程</span></td></tr><tr><td style="border-color:#000000;text-align:left;vertical-align:middle;"><span style="color:#000000;">systemctl   stop 软件名</span></td><td style="border-color:#000000;text-align:left;vertical-align:middle;"><span style="color:#000000;">关闭进程</span></td></tr><tr><td style="border-color:#000000;text-align:left;vertical-align:middle;"><span style="color:#000000;">systemctl  status 软件名</span></td><td style="border-color:#000000;text-align:left;vertical-align:middle;"><span style="color:#000000;">查看进程状态</span></td></tr><tr><td style="border-color:#000000;text-align:left;vertical-align:middle;"><span style="color:#000000;">systemctl   restart 软件名</span></td><td style="border-color:#000000;text-align:left;vertical-align:middle;"><span style="color:#000000;">重启进程（先关闭后启动）</span></td></tr><tr><td style="border-color:#000000;text-align:left;vertical-align:middle;"><span style="color:#fe2c24;"><strong>systemctl   reload 软件名</strong></span></td><td style="border-color:#000000;text-align:left;vertical-align:middle;"><span style="color:#fe2c24;"><strong>重新加载（不关闭的状态下更新）</strong></span></td></tr><tr><td style="border-color:#000000;text-align:left;vertical-align:middle;"><span style="color:#000000;">systemctl   enable 软件名</span></td><td style="border-color:#000000;text-align:left;vertical-align:middle;"><span style="color:#000000;">开机自启动</span></td></tr><tr><td style="border-color:#000000;text-align:left;vertical-align:middle;"><span style="color:#000000;">systemctl   enable --now 软件名</span></td><td style="border-color:#000000;text-align:left;vertical-align:middle;"><span style="color:#000000;">开启自启动并现在启动</span></td></tr><tr><td style="border-color:#000000;text-align:left;vertical-align:middle;"><span style="color:#000000;">systemctl   disable 软件名</span></td><td style="border-color:#000000;text-align:left;vertical-align:middle;"><span style="color:#000000;">开机不自启</span></td></tr><tr><td style="border-color:#000000;text-align:left;vertical-align:middle;"><span style="color:#000000;">systemctl   disable  --now 软件名</span></td><td style="border-color:#000000;text-align:left;vertical-align:middle;"><span style="color:#000000;">开机不自启并现在关闭</span></td></tr><tr><td style="border-color:#000000;text-align:left;vertical-align:middle;"><span style="color:#fe2c24;"><strong>systemctl   daemon-reload </strong></span></td><td style="border-color:#000000;text-align:left;vertical-align:middle;width:195pt;"> <p><span style="color:#fe2c24;"><strong>重新加载新服务，让系统识别<br> 就是/usr/lib/systemd/system/这个文件夹加入内容后需要刷新一下</strong></span></p> <p><span style="color:#fe2c24;"><strong>daemon是守护进程的意思</strong></span></p> </td></tr></tbody></table> 
<h3 id="5%E3%80%81%E8%BF%90%E8%A1%8C%E7%BA%A7%E5%88%AB">5、运行级别</h3> 
<table cellspacing="0"><tbody><tr><td style="background-color:#c00000;border-color:#000000;vertical-align:middle;width:52pt;"><span style="color:#ffffff;"><strong>运行级别</strong></span></td><td style="background-color:#c00000;border-color:#000000;vertical-align:middle;width:114pt;"><span style="color:#ffffff;"><strong>Systemd的target</strong></span></td><td style="background-color:#c00000;border-color:#000000;vertical-align:middle;width:365pt;"><span style="color:#ffffff;"><strong>说明</strong></span></td></tr><tr><td style="border-color:#000000;text-align:center;vertical-align:middle;"><span style="color:#000000;">0</span></td><td style="border-color:#000000;text-align:center;vertical-align:middle;"><span style="color:#000000;">target</span></td><td style="border-color:#000000;vertical-align:middle;"><span style="color:#000000;"><span style="color:#ff0000;"><strong>关机状态</strong></span><span style="color:#000000;">（也可以用poweroff关机）</span></span></td></tr><tr><td style="border-color:#000000;text-align:center;vertical-align:middle;"><span style="color:#000000;">1</span></td><td style="border-color:#000000;text-align:center;vertical-align:middle;"><span style="color:#000000;">rescue.target</span></td><td style="border-color:#000000;vertical-align:middle;"><span style="color:#000000;"><span style="color:#ff0000;"><strong>单用户模式</strong></span><span style="color:#000000;">，不需要密码验证即可登录系统，多用于</span><span style="color:#ff0000;"><strong>系统维护</strong></span></span></td></tr><tr><td style="border-color:#000000;text-align:center;vertical-align:middle;"><span style="color:#000000;">2</span></td><td style="border-color:#000000;text-align:center;vertical-align:middle;"><span style="color:#000000;">multi-user.target</span></td><td style="border-color:#000000;vertical-align:middle;"><span style="color:#000000;">与3的区别是<span style="color:#000000;"><strong>不支持nfs功能</strong></span><span style="color:#000000;">。默认等同于3</span></span></td></tr><tr><td style="border-color:#000000;text-align:center;vertical-align:middle;"><span style="color:#ff0000;"><strong>3</strong></span></td><td style="border-color:#000000;text-align:center;vertical-align:middle;"><span style="color:#ff0000;"><strong>multi-user.target</strong></span></td><td style="border-color:#000000;vertical-align:middle;"><span style="color:#ff0000;"><strong>字符界面的完整多用户模式，大多数服务器主机运行在此级别（支持nfs）</strong></span></td></tr><tr><td style="border-color:#000000;text-align:center;vertical-align:middle;"><span style="color:#000000;">4</span></td><td style="border-color:#000000;text-align:center;vertical-align:middle;"><span style="color:#000000;">multi-user.target</span></td><td style="border-color:#000000;vertical-align:middle;"><span style="color:#000000;">保留的运行级别。默认等同于3</span></td></tr><tr><td style="border-color:#000000;text-align:center;vertical-align:middle;"><span style="color:#000000;">5</span></td><td style="border-color:#000000;text-align:center;vertical-align:middle;"><span style="color:#000000;">graphical.target</span></td><td style="border-color:#000000;vertical-align:middle;"><span style="color:#000000;">图形界面的多用户模式，提供了图形桌面操作环境</span></td></tr><tr><td style="border-color:#000000;text-align:center;vertical-align:middle;"><span style="color:#000000;">6</span></td><td style="border-color:#000000;text-align:center;vertical-align:middle;"><span style="color:#000000;">reboot.target</span></td><td style="border-color:#000000;vertical-align:middle;"><span style="color:#ff0000;"><strong>重新启动（也可以用reboot）</strong></span></td></tr></tbody></table> 
<p><strong>查看当前的默认运行级别：<span style="background-color:#ffd900;">systemctl  get-default</span></strong></p> 
<p><strong>修改默认运行级别：<span style="background-color:#ffd900;">systemctl set-default 加运行级别英文表达式</span></strong></p> 
<p><strong>查看当前运行级别：<span style="background-color:#ffd900;">runlevel</span></strong></p> 
<pre><code>[root@localhost ~]#runlevel
N 5

# N表示前一次的运行级别
# 5表示当前运行级别

[root@localhost ~]#init 3

[root@localhost ~]#runlevel
5 3
</code></pre> 
<h2 id="%E4%BA%8C%E3%80%81%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85nginx%EF%BC%8C%E4%BB%A5%E5%8F%8A%E6%89%8B%E5%86%99service%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%EF%BC%8C%E8%AF%B7%E7%9C%8B%E6%B3%A8%E9%87%8A">二、编译安装nginx，以及手写service配置文件，请看注释</h2> 
<pre><code>cd  /opt
wget http://nginx.org/download/nginx-1.18.0.tar.gz
tar xf   nginx-1.18.0.tar.gz
cd  nginx-1.18.0
yum -y install gcc pcre-devel openssl-devel zlib-devel openssl  openssl-devel 
#安装依赖环境

mkdir /apps/nginx -p    

./configure   --prefix=/apps/nginx
##检测安装环境，安装去指定目录，或者选择安装功能

##指明安装路径
make
##编译 将人类的高级语言翻译成二进制
make  install
##将安装好的软件放入指定路径

ln -s /apps/nginx/sbin/nginx   /usr/sbin/nginx 
#做软链接 </code></pre> 
<pre><code>##手写service配置文件

vim  /usr/lib/systemd/system/nginx.service

[Unit]
Description=The nginx HTTP and reverse proxy server
#描述软件的功能，查看进程状态的时候，会有这一段描述

[Service]
PIDFile=/apps/nginx/logs/nginx.pid
#这里指明了这个pid号的配置文件存放位置，约定俗成一般存放在安装服务的logs中，以上nginx服务编译安装在/apps/nginx中，所以路径更改为/apps/nginx/logs/nginx.pid，一旦启动进程，nginx.pid文件会自动创建

ExecStart=/apps/nginx/sbin/nginx
#使用绝对路径启动

ExecStop=/usr/bin/kill -s TERM $MAINPID
#杀死进程

ExecReload=/apps/nginx/sbin/nginx -s reload
#重新加载

[Install]
WantedBy=multi-user.target
安装在字符界面（3）




##结束以后加上  让系统识别到这个程序
systemctl daemon-reload</code></pre> 
<h2 id="%E2%80%8B%E7%BC%96%E8%BE%91"><img alt="" height="258" src="https://images2.imgbox.com/42/ad/R56LkkPi_o.png" width="1200"></h2> 
<p><img alt="" height="859" src="https://images2.imgbox.com/35/8f/8QBqo5qz_o.png" width="1200"></p> 
<p><img alt="" height="621" src="https://images2.imgbox.com/b0/92/WVrP8Axo_o.png" width="1200"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0660195c1361f9235c6e18bc4d521585/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">HAL库自学笔记（三）——中断</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/74dcc942e9325e9c9756cf1857cc8d35/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Spring Boot 设置动态定时任务，千万别再写死了~</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>