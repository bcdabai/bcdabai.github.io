<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【Android】蓝牙开发——经典蓝牙：配对与解除配对 &amp; 实现配对或连接时不弹出配对框 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【Android】蓝牙开发——经典蓝牙：配对与解除配对 &amp; 实现配对或连接时不弹出配对框" />
<meta property="og:description" content="目录
一、配对方法 二、解除配对方法
三、配对/解除配对结果
四、justwork配对模式下，不弹出配对框
五、pincode配对模式下，不弹出配对框
六、小结
在之前的文章【Android】蓝牙开发—— 经典蓝牙配对介绍（Java代码实现演示）附Demo源码 中，简单介绍和演示了经典蓝牙的配对方式，今天就在之前的基础上继续讲讲，蓝牙的配对、解除配对以及如何实现不弹出配对框。
关于“配对”、“解除配对”的说法，还有叫“绑定”、“解绑”，这里提前说一下，在之前的文章中出现，防止小伙伴们不理解。
一、配对方法 蓝牙配对方式，目前有两种，一种是通过反射的方法，还有一种是直接调用官方API的方法。
第一种：反射的方法，在低于Android API 19时，配对的方法是隐藏的方法，所以只有通过反射方法实现。
/** * 第一种 * 执行配对 反射 * @param bluetoothDevice 蓝牙设备 * @return true 执行绑定 false 未执行绑定 */ public boolean boundDevice(BluetoothDevice bluetoothDevice){ if(bluetoothDevice == null){ Log.e(TAG,&#34;boundDevice--&gt;bluetoothDevice == null&#34;); return false; } try { return ClsUtils.createBond(BluetoothDevice.class,bluetoothDevice); } catch (Exception e) { e.printStackTrace(); } return true; } ClsUtils.java中createBond()方法如下：
/** * 与设备配对 参考源码：platform/packages/apps/Settings.git * /Settings/src/com/android/settings/bluetooth/CachedBluetoothDevice.java */ @SuppressWarnings(&#34;unchecked&#34;) static public boolean createBond(@SuppressWarnings(&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/92ebce95f70547b9be4e193e9b336af2/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-12-03T15:39:15+08:00" />
<meta property="article:modified_time" content="2019-12-03T15:39:15+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【Android】蓝牙开发——经典蓝牙：配对与解除配对 &amp; 实现配对或连接时不弹出配对框</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80%E3%80%81%E9%85%8D%E5%AF%B9%E6%96%B9%E6%B3%95%C2%A0-toc" style="margin-left:80px;"><a href="#%E4%B8%80%E3%80%81%E9%85%8D%E5%AF%B9%E6%96%B9%E6%B3%95%C2%A0" rel="nofollow">一、配对方法 </a></p> 
<p id="%E4%BA%8C%E3%80%81%E8%A7%A3%E9%99%A4%E9%85%8D%E5%AF%B9%E6%96%B9%E6%B3%95-toc" style="margin-left:80px;"><a href="#%E4%BA%8C%E3%80%81%E8%A7%A3%E9%99%A4%E9%85%8D%E5%AF%B9%E6%96%B9%E6%B3%95" rel="nofollow">二、解除配对方法</a></p> 
<p id="%E4%B8%89%E3%80%81%E9%85%8D%E5%AF%B9%2F%E8%A7%A3%E9%99%A4%E9%85%8D%E5%AF%B9%E7%BB%93%E6%9E%9C-toc" style="margin-left:80px;"><a href="#%E4%B8%89%E3%80%81%E9%85%8D%E5%AF%B9%2F%E8%A7%A3%E9%99%A4%E9%85%8D%E5%AF%B9%E7%BB%93%E6%9E%9C" rel="nofollow">三、配对/解除配对结果</a></p> 
<p id="%E5%9B%9B%E3%80%81justwork%E9%85%8D%E5%AF%B9%E6%A8%A1%E5%BC%8F-toc" style="margin-left:80px;"><a href="#%E5%9B%9B%E3%80%81justwork%E9%85%8D%E5%AF%B9%E6%A8%A1%E5%BC%8F" rel="nofollow">四、justwork配对模式下，不弹出配对框</a></p> 
<p id="%C2%A0%E4%BA%94%E3%80%81pincode%E9%85%8D%E5%AF%B9%E6%A8%A1%E5%BC%8F-toc" style="margin-left:80px;"><a href="#%C2%A0%E4%BA%94%E3%80%81pincode%E9%85%8D%E5%AF%B9%E6%A8%A1%E5%BC%8F" rel="nofollow">五、pincode配对模式下，不弹出配对框</a></p> 
<p id="%E5%85%AD%E3%80%81%E5%B0%8F%E7%BB%93-toc" style="margin-left:80px;"><a href="#%E5%85%AD%E3%80%81%E5%B0%8F%E7%BB%93" rel="nofollow">六、小结</a></p> 
<hr id="hr-toc"> 
<p style="text-indent:33px;">在之前的文章<a href="https://blog.csdn.net/qq_38950819/article/details/100134692">【Android】蓝牙开发—— 经典蓝牙配对介绍（Java代码实现演示）附Demo源码</a> 中，简单介绍和演示了经典蓝牙的配对方式，今天就在之前的基础上继续讲讲，蓝牙的配对、解除配对以及如何实现不弹出配对框。</p> 
<p style="text-indent:33px;">关于“配对”、“解除配对”的说法，还有叫“绑定”、“解绑”，这里提前说一下，在之前的文章中出现，防止小伙伴们不理解。</p> 
<h4 id="%E4%B8%80%E3%80%81%E9%85%8D%E5%AF%B9%E6%96%B9%E6%B3%95%C2%A0">一、配对方法 </h4> 
<p style="text-indent:33px;">蓝牙配对方式，目前有两种，一种是通过反射的方法，还有一种是直接调用官方API的方法。</p> 
<p style="text-indent:33px;">第一种：反射的方法，在低于Android API 19时，配对的方法是隐藏的方法，所以只有通过反射方法实现。</p> 
<blockquote> 
 <pre class="has"><code class="language-java"> /**
     * 第一种
     * 执行配对 反射
     * @param bluetoothDevice 蓝牙设备
     * @return true 执行绑定 false 未执行绑定
     */
    public boolean boundDevice(BluetoothDevice bluetoothDevice){
        if(bluetoothDevice == null){
            Log.e(TAG,"boundDevice--&gt;bluetoothDevice == null");
            return false;
        }

        try {
            return ClsUtils.createBond(BluetoothDevice.class,bluetoothDevice);
        } catch (Exception e) {
            e.printStackTrace();
        }

        return true;
    }</code></pre> 
</blockquote> 
<p> ClsUtils.java中createBond()方法如下：</p> 
<blockquote> 
 <pre class="has"><code class="language-java">/**
     * 与设备配对 参考源码：platform/packages/apps/Settings.git
     * /Settings/src/com/android/settings/bluetooth/CachedBluetoothDevice.java
     */
    @SuppressWarnings("unchecked")
    static public boolean createBond(@SuppressWarnings("rawtypes") Class btClass, BluetoothDevice btDevice)
            throws Exception {
        Method createBondMethod = btClass.getMethod("createBond");
        Boolean returnValue = (Boolean) createBondMethod.invoke(btDevice);
        return returnValue.booleanValue();
    }</code></pre> 
</blockquote> 
<p style="text-indent:33px;"> 第二种：官方API，但是只支持Android API 19以上的设备。</p> 
<blockquote> 
 <pre class="has"><code class="language-java">/**
     * 第二种
     * 执行配对 官方API
     * @param bluetoothDevice  蓝牙设备
     * @return  true 执行绑定 false 未执行绑定
     */
    public boolean boundDeviceAPI(BluetoothDevice bluetoothDevice){
        if(bluetoothDevice == null){
            return false;
        }

        //注意：Android 4.4版本之后的API
        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) {
            return bluetoothDevice.createBond();
        }
        return false;
    }</code></pre> 
</blockquote> 
<p> </p> 
<h4 id="%E4%BA%8C%E3%80%81%E8%A7%A3%E9%99%A4%E9%85%8D%E5%AF%B9%E6%96%B9%E6%B3%95">二、解除配对方法</h4> 
<p style="text-indent:33px;">蓝牙解除配对的方式，因为是隐藏的方法，目前只有通过反射进行调用。</p> 
<blockquote> 
 <pre class="has"><code class="language-java">/**
     * 执行解除配对  反射
     * @param bluetoothDevice 蓝牙设备
     * @return  true 执行解绑  false未执行解绑
     */
    public boolean disBoundDevice(BluetoothDevice bluetoothDevice){
        if(bluetoothDevice == null){
            Log.e(TAG,"disBoundDevice--&gt;bluetoothDevice == null");
            return false;
        }

        try {
            return ClsUtils.removeBond(BluetoothDevice.class,bluetoothDevice);
        } catch (Exception e) {
            e.printStackTrace();
        }

        return true;
    }
</code></pre> 
</blockquote> 
<p> ClsUtils.java中removeBond()方法如下：</p> 
<blockquote> 
 <pre class="has"><code class="language-java">/**
     * 与设备解除配对 参考源码：platform/packages/apps/Settings.git
     * /Settings/src/com/android/settings/bluetooth/CachedBluetoothDevice.java
     */
    @SuppressWarnings("unchecked")
    static public boolean removeBond(Class btClass, BluetoothDevice btDevice)
            throws Exception {
        Method removeBondMethod = btClass.getMethod("removeBond");
        Boolean returnValue = (Boolean) removeBondMethod.invoke(btDevice);
        return returnValue.booleanValue();
    }</code></pre> 
</blockquote> 
<h4 id="%E4%B8%89%E3%80%81%E9%85%8D%E5%AF%B9%2F%E8%A7%A3%E9%99%A4%E9%85%8D%E5%AF%B9%E7%BB%93%E6%9E%9C">三、配对/解除配对结果</h4> 
<p style="text-indent:33px;">配对、解除配对的结果是通过系统广播出来的，所以我们在使用的时候，需要注册广播接收器来获取配对状态。</p> 
<p style="text-indent:33px;">这里我们自定义广播接收器。在onCreate()中注册该广播，在onDestroy()中注销广播。</p> 
<blockquote> 
 <pre class="has"><code class="language-java"> /**
     * 蓝牙广播接收器
     */
    private class BtBroadcastReceiver extends BroadcastReceiver {

        @Override
        public void onReceive(Context context, Intent intent) {
            String action = intent.getAction();
            if(TextUtils.equals(action,BluetoothDevice.ACTION_BOND_STATE_CHANGED)){
                BluetoothDevice bluetoothDevice = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
                int bondSate = bluetoothDevice.getBondState();
                switch(bondSate) {
                    case BluetoothDevice.BOND_NONE:
                        Log.d(TAG, "已解除配对");
                        break;

                    case BluetoothDevice.BOND_BONDING:
                        Log.d(TAG, "正在配对...");
                        break;

                    case BluetoothDevice.BOND_BONDED:
                        Log.d(TAG, "已配对");
                        break;
                }
            }
        }
    }</code></pre> 
</blockquote> 
<blockquote> 
 <pre class="has"><code class="language-java"> //注册广播接收
 btBroadcastReceiver = new BtBroadcastReceiver();
 IntentFilter intentFilter = new IntentFilter();
 intentFilter.addAction(BluetoothDevice.ACTION_BOND_STATE_CHANGED); //配对状态监听
 registerReceiver(btBroadcastReceiver,intentFilter);</code></pre> 
</blockquote> 
<blockquote> 
 <pre class="has"><code class="language-java">//注销广播接收
unregisterReceiver(btBroadcastReceiver);</code></pre> 
</blockquote> 
<h4 id="%E5%9B%9B%E3%80%81justwork%E9%85%8D%E5%AF%B9%E6%A8%A1%E5%BC%8F">四、justwork配对模式下，不弹出配对框</h4> 
<p style="text-indent:33px;"><strong>1、配对的时候</strong></p> 
<p style="text-indent:33px;">justwork配对模式下，不管是调用反射的配对方法还是官方API的配对方法，都不会弹出配对框，实现自动配对。</p> 
<p style="text-indent:33px;"><strong>2、经典蓝牙第一次连接的时候（即连接之前，与设备是没有配对的状态）</strong></p> 
<p style="text-indent:33px;">经典蓝牙建立连接时，有两种方式，一种是建立安全的连接，即需要配对的连接；</p> 
<p style="text-indent:33px;">还有一种就是建立不安全的连接，即不需要配对的连接。建立不安全的连接，实际上是因为没有进行配对，当然就不会有配对框弹出。</p> 
<blockquote> 
 <pre class="has"><code class="language-java">//1、建立安全的蓝牙连接，会弹出配对框
BluetoothSocket BluetoothSocket=bluetoothDevice.createRfcommSocketToServiceRecord(UUID.fromString(uuid));</code></pre> 
</blockquote> 
<blockquote> 
 <pre class="has"><code class="language-java">//2、建立不安全的蓝牙连接，不进行配对，就不弹出配对框
BluetoothSocket BluetoothSocket=bluetoothDevice.createInsecureRfcommSocketToServiceRecord(UUID.fromString(uuid));</code></pre> 
</blockquote> 
<h4 id="%C2%A0%E4%BA%94%E3%80%81pincode%E9%85%8D%E5%AF%B9%E6%A8%A1%E5%BC%8F">五、pincode配对模式下，不弹出配对框</h4> 
<p style="text-indent:33px;">1、注册<strong>BluetoothDevice.ACTION_PAIRING_REQUEST</strong>广播监听</p> 
<blockquote> 
 <pre class="has"><code class="language-java"> //注册广播接收
 btBroadcastReceiver = new BtBroadcastReceiver();
 IntentFilter intentFilter = new IntentFilter();
 intentFilter.addAction(BluetoothDevice.ACTION_BOND_STATE_CHANGED); //配对状态监听
 if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) {
            intentFilter.addAction(BluetoothDevice.ACTION_PAIRING_REQUEST);  //配对请求
        }
 registerReceiver(btBroadcastReceiver,intentFilter);</code></pre> 
</blockquote> 
<p style="text-indent:33px;">2、在广播接收器中处理</p> 
<blockquote> 
 <pre class="has"><code class="language-java"> /**
     * 蓝牙广播接收器
     */
    private class BtBroadcastReceiver extends BroadcastReceiver {

        @Override
        public void onReceive(Context context, Intent intent) {
            String action = intent.getAction();
            if(TextUtils.equals(action,BluetoothDevice.ACTION_BOND_STATE_CHANGED)){
                BluetoothDevice bluetoothDevice = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
                int bondSate = bluetoothDevice.getBondState();
                switch(bondSate) {
                    case BluetoothDevice.BOND_NONE:
                        Log.d(TAG, "已解除配对");
                        break;

                    case BluetoothDevice.BOND_BONDING:
                        Log.d(TAG, "正在配对...");
                        break;

                    case BluetoothDevice.BOND_BONDED:
                        Log.d(TAG, "已配对");
                        break;
                }
            }else if(TextUtils.equals(action,BluetoothDevice.ACTION_PAIRING_REQUEST)){
                int type = -1;
                if (android.os.Build.VERSION.SDK_INT &gt;= android.os.Build.VERSION_CODES.KITKAT) {
                    type = intent.getIntExtra(BluetoothDevice.EXTRA_PAIRING_VARIANT,BluetoothDevice.ERROR);
                    Log.d(TAG, "ACTION_PAIRING_REQUEST--"+type);
                    //PAIRING_VARIANT_PIN 0 
                    if(type == BluetoothDevice.PAIRING_VARIANT_PIN){
                        //防止弹出一闪而过的配对框
                        abortBroadcast();
                        //弹框后自动输入密码、自动确定
                        boolean isSetPin = curBluetoothDevice.setPin("0000".getBytes());
                        Log.d(TAG, "setPin()--&gt;" + isSetPin);

                    }
            }
        }
    }</code></pre> 
</blockquote> 
<p style="text-indent:33px;"> 因为官方的BluetoothDevice.setPin() 是支持API 19以上的设备，所以在低于API 19的设备上，需要使用反射的方法来获取setPin()方法。</p> 
<blockquote> 
 <pre class="has"><code class="language-java"> /**
     * 蓝牙广播接收器
     */
    private class BtBroadcastReceiver extends BroadcastReceiver {

        @Override
        public void onReceive(Context context, Intent intent) {
            String action = intent.getAction();
            if(TextUtils.equals(action,BluetoothDevice.ACTION_BOND_STATE_CHANGED)){
                BluetoothDevice bluetoothDevice = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
                int bondSate = bluetoothDevice.getBondState();
                switch(bondSate) {
                    case BluetoothDevice.BOND_NONE:
                        Log.d(TAG, "已解除配对");
                        break;

                    case BluetoothDevice.BOND_BONDING:
                        Log.d(TAG, "正在配对...");
                        break;

                    case BluetoothDevice.BOND_BONDED:
                        Log.d(TAG, "已配对");
                        break;
                }
            }else if(TextUtils.equals(action,BluetoothDevice.ACTION_PAIRING_REQUEST)){
                int type = -1;
                if (android.os.Build.VERSION.SDK_INT &gt;= android.os.Build.VERSION_CODES.KITKAT) {
                    type = intent.getIntExtra(BluetoothDevice.EXTRA_PAIRING_VARIANT,BluetoothDevice.ERROR);
                    Log.d(TAG, "ACTION_PAIRING_REQUEST--"+type);
                    //PAIRING_VARIANT_CONSENT 0 
                    if(type == BluetoothDevice.PAIRING_VARIANT_PIN){
                        //防止弹出一闪而过的配对框
                        abortBroadcast();
                        //弹框后自动输入密码、自动确定
                        try {
                            boolean isSetPin = ClsUtils.autoBond(BluetoothDevice.class,curBluetoothDevice,"0000");
                            Log.d(TAG, "setPin()--&gt;" + isSetPin);
                        } catch (Exception e) {
                            e.printStackTrace();
                        }

                    }
            }
        }
    }</code></pre> 
</blockquote> 
<p style="text-indent:33px;">ClsUtils.java中autoBond()方法如下：</p> 
<blockquote> 
 <pre class="has"><code class="language-java"> //自动配对设置Pin值
    static public boolean autoBond(Class btClass,BluetoothDevice device,String strPin) throws Exception {
        Method autoBondMethod = btClass.getMethod("setPin",new Class[]{byte[].class});
        Boolean result = (Boolean)autoBondMethod.invoke(device,new Object[]{strPin.getBytes()});
        return result;
    }
</code></pre> 
</blockquote> 
<p style="text-indent:33px;"> </p> 
<h4 id="%E5%85%AD%E3%80%81%E5%B0%8F%E7%BB%93">六、小结</h4> 
<p style="text-indent:33px;"><strong>1、justwork配对模式下，</strong></p> 
<p style="text-indent:33px;"><strong>（1）调用反射的配对方法或者官方API的配对方法，都能实现自动配对，不会弹出配对框。</strong></p> 
<p style="text-indent:33px;"><strong>（2）调用官方API首次连接，且建立非安全的连接，不会弹出配对框，但是本质是因为没有执行配对操作。</strong></p> 
<p style="text-indent:33px;"><strong>2、pincode配对模式下，实现自动配对的方法，只适用Android 8.0及以下的系统，Android 9.0及以上系统不生效。</strong></p> 
<p style="text-indent:33px;"><strong>3、如果想要实现弹出配对框时自动输入或点击，可以使用无障碍服务(Accessibility Service)。通过获取界面的控件，比如输入框、按钮，然后模拟输入或点击，实现自动配对。</strong></p> 
<p style="text-indent:33px;"><span style="color:#f33b45;"><strong>注意：上面所说的justwork或pincode模式也不是绝对的，因为这完全是由蓝牙设备软件工程师决定的，所以实际开发时还是要根据实际的设备进行方式的选择。</strong></span></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b499bd7bf9460182ffec0d9fb25bb328/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">[结构光三维重建] 2、基于结构光的三维重建系统工作原理总结</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/eeb8dfb779769ace8f11dde8b8d5a720/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">typescript从0到1全过程总结&#43;vue整合typescript</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>