<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43;力扣题目700--二叉搜索树中的搜索 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C&#43;&#43;力扣题目700--二叉搜索树中的搜索" />
<meta property="og:description" content="给定二叉搜索树（BST）的根节点 root 和一个整数值 val。
你需要在 BST 中找到节点值等于 val 的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 null 。
示例 1:
输入：root = [4,2,7,1,3], val = 2 输出：[2,1,3] 示例 2:
输入：root = [4,2,7,1,3], val = 5 输出：[] 思路 之前我们讲的都是普通二叉树，那么接下来看看二叉搜索树。
在关于二叉树，你该了解这些！ (opens new window)中，我们已经讲过了二叉搜索树。
二叉搜索树是一个有序树：
若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；它的左、右子树也分别为二叉搜索树 这就决定了，二叉搜索树，递归遍历和迭代遍历和普通二叉树都不一样。
本题，其实就是在二叉搜索树中搜索一个节点。那么我们来看看应该如何遍历。
#递归法 确定递归函数的参数和返回值 递归函数的参数传入的就是根节点和要搜索的数值，返回的就是以这个搜索数值所在的节点。
代码如下：
TreeNode* searchBST(TreeNode* root, int val) 确定终止条件 如果root为空，或者找到这个数值了，就返回root节点。
if (root == NULL || root-&gt;val == val) return root; 确定单层递归的逻辑 看看二叉搜索树的单层递归逻辑有何不同。
因为二叉搜索树的节点是有序的，所以可以有方向的去搜索。
如果root-&gt;val &gt; val，搜索左子树，如果root-&gt;val &lt; val，就搜索右子树，最后如果都没有搜索到，就返回NULL。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/759f16c327f197ab841f951ef56d767a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-13T12:11:07+08:00" />
<meta property="article:modified_time" content="2024-01-13T12:11:07+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43;力扣题目700--二叉搜索树中的搜索</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3><a id="_0"></a></h3> 
<p>给定二叉搜索树（BST）的根节点 <code>root</code> 和一个整数值 <code>val</code>。</p> 
<p>你需要在 BST 中找到节点值等于 <code>val</code> 的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 <code>null</code> 。</p> 
<p><strong>示例 1:</strong></p> 
<p></p> 
<p class="img-center"><img alt="" height="302" src="https://images2.imgbox.com/af/3c/klKgIXEt_o.jpg" width="422"></p> 
<pre><strong>输入：</strong>root = [4,2,7,1,3], val = 2
<strong>输出：</strong>[2,1,3]
</pre> 
<p><strong>示例 2:</strong></p> 
<p></p> 
<p class="img-center"><img alt="" height="302" src="https://images2.imgbox.com/7b/fc/VGro5rZd_o.jpg" width="422"></p> 
<pre><strong>输入：</strong>root = [4,2,7,1,3], val = 5
<strong>输出：</strong>[]</pre> 
<p> </p> 
<h3 id="思路">思路</h3> 
<p>之前我们讲的都是普通二叉树，那么接下来看看二叉搜索树。</p> 
<p>在<a href="https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html" rel="nofollow" title="关于二叉树，你该了解这些！ (opens new window)">关于二叉树，你该了解这些！ (opens new window)</a>中，我们已经讲过了二叉搜索树。</p> 
<p>二叉搜索树是一个有序树：</p> 
<ul><li>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li><li>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li><li>它的左、右子树也分别为二叉搜索树</li></ul> 
<p>这就决定了，二叉搜索树，递归遍历和迭代遍历和普通二叉树都不一样。</p> 
<p>本题，其实就是在二叉搜索树中搜索一个节点。那么我们来看看应该如何遍历。</p> 
<h4 id="递归法"><a href="https://programmercarl.com/0700.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%90%9C%E7%B4%A2.html#%E9%80%92%E5%BD%92%E6%B3%95" rel="nofollow" title="#">#</a>递归法</h4> 
<ol><li>确定递归函数的参数和返回值</li></ol> 
<p>递归函数的参数传入的就是根节点和要搜索的数值，返回的就是以这个搜索数值所在的节点。</p> 
<p>代码如下：</p> 
<pre><code class="language-cpp">TreeNode* searchBST(TreeNode* root, int val)
</code></pre> 
<p></p> 
<ol><li>确定终止条件</li></ol> 
<p>如果root为空，或者找到这个数值了，就返回root节点。</p> 
<pre><code class="language-cpp">if (root == NULL || root-&gt;val == val) return root;
</code></pre> 
<p></p> 
<ol><li>确定单层递归的逻辑</li></ol> 
<p>看看二叉搜索树的单层递归逻辑有何不同。</p> 
<p>因为二叉搜索树的节点是有序的，所以可以有方向的去搜索。</p> 
<p>如果root-&gt;val &gt; val，搜索左子树，如果root-&gt;val &lt; val，就搜索右子树，最后如果都没有搜索到，就返回NULL。</p> 
<p>代码如下：</p> 
<pre><code class="language-cpp">TreeNode* result = NULL;
if (root-&gt;val &gt; val) result = searchBST(root-&gt;left, val);
if (root-&gt;val &lt; val) result = searchBST(root-&gt;right, val);
return result;
</code></pre> 
<p></p> 
<p>很多录友写递归函数的时候 习惯直接写 <code>searchBST(root-&gt;left, val)</code>，却忘了 递归函数还有返回值。</p> 
<p>递归函数的返回值是什么? 是 左子树如果搜索到了val，要将该节点返回。 如果不用一个变量将其接住，那么返回值不就没了。</p> 
<p>所以要 <code>result = searchBST(root-&gt;left, val)</code>。</p> 
<p>整体代码如下：</p> 
<pre><code class="language-cpp">class Solution {
public:
    TreeNode* searchBST(TreeNode* root, int val) {
        if (root == NULL || root-&gt;val == val) return root;
        TreeNode* result = NULL;
        if (root-&gt;val &gt; val) result = searchBST(root-&gt;left, val);
        if (root-&gt;val &lt; val) result = searchBST(root-&gt;right, val);
        return result;
    }
};
</code></pre> 
<p></p> 
<p>或者我们也可以这么写</p> 
<pre><code class="language-cpp">class Solution {
public:
    TreeNode* searchBST(TreeNode* root, int val) {
        if (root == NULL || root-&gt;val == val) return root;
        if (root-&gt;val &gt; val) return searchBST(root-&gt;left, val);
        if (root-&gt;val &lt; val) return searchBST(root-&gt;right, val);
        return NULL;
    }
};
</code></pre> 
<p></p> 
<h4 id="迭代法"><a href="https://programmercarl.com/0700.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%90%9C%E7%B4%A2.html#%E8%BF%AD%E4%BB%A3%E6%B3%95" rel="nofollow" title="#">#</a>迭代法</h4> 
<p>一提到二叉树遍历的迭代法，可能立刻想起使用栈来模拟深度遍历，使用队列来模拟广度遍历。</p> 
<p>对于二叉搜索树可就不一样了，因为二叉搜索树的特殊性，也就是节点的有序性，可以不使用辅助栈或者队列就可以写出迭代法。</p> 
<p>对于一般二叉树，递归过程中还有回溯的过程，例如走一个左方向的分支走到头了，那么要调头，在走右分支。</p> 
<p>而<strong>对于二叉搜索树，不需要回溯的过程，因为节点的有序性就帮我们确定了搜索的方向。</strong></p> 
<p>例如要搜索元素为3的节点，<strong>我们不需要搜索其他节点，也不需要做回溯，查找的路径已经规划好了。</strong></p> 
<p>中间节点如果大于3就向左走，如果小于3就向右走，如图：</p> 
<p></p> 
<p class="img-center"><img alt="二叉搜索树" height="376" src="https://images2.imgbox.com/fe/98/tUIEXAU7_o.png" width="520"></p> 
<p>所以迭代法代码如下：</p> 
<pre><code class="language-cpp">class Solution {
public:
    TreeNode* searchBST(TreeNode* root, int val) {
        while (root != NULL) {
            if (root-&gt;val &gt; val) root = root-&gt;left;
            else if (root-&gt;val &lt; val) root = root-&gt;right;
            else return root;
        }
        return NULL;
    }
};
</code></pre> 
<p></p> 
<p>第一次看到了如此简单的迭代法，是不是感动的痛哭流涕，哭一会~</p> 
<h3 id="总结"><a href="https://programmercarl.com/0700.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%90%9C%E7%B4%A2.html#%E6%80%BB%E7%BB%93" rel="nofollow" title="#">#</a>总结</h3> 
<p>本篇我们介绍了二叉搜索树的遍历方式，因为二叉搜索树的有序性，遍历的时候要比普通二叉树简单很多。</p> 
<p>但是一些同学很容易忽略二叉搜索树的特性，所以写出遍历的代码就未必真的简单了。</p> 
<p>所以针对二叉搜索树的题目，一样要利用其特性。</p> 
<p>文中我依然给出递归和迭代两种方式，可以看出写法都非常简单，就是利用了二叉搜索树有序的特点</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/60831c9e8fb0a465cbec6b711f8c91ba/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Java锁的分类</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/7df75211158a210321f54436d0a11de4/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Dubbo的服务降级策略剖析</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>