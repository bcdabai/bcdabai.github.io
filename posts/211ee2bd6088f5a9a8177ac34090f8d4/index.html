<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>http与https、响应码（状态码）、缓存 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="http与https、响应码（状态码）、缓存" />
<meta property="og:description" content="一、url的组成？http和https是同一个协议吗？ 组成：传输协议，域名，端口，文件位置，参数。
HTTP（顺丰）：超文本传输协议（除了传递普通的文本，还可以传递文件流或者进制编码等信息），端口80
HTTPS（邮政）：基于SSL（Secure Sockets Layer 安全套接层）加密的HTTP传输协议，比HTTP更加的安全（涉及支付的网站一般都是基于HTTPS完成的），端口443
FTP（货运）：文件传输协议，一般用来实现资源文件在服务器上的上传下载
1. Https的作用
内容加密 建立一个信息安全通道，来保证数据传输的安全；
身份验证 确认网站的真实性；
数据完整性 防止内容被第三方冒充或者篡改
2. HTTPS和HTTP的区别
https协议需要到CA申请证书
http是超文本传输协议，信息时明文传输；https则是具有安全性的ssl加密传输协议
http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443
http的连接很简单，是无状态的；https协议是由SSL&#43;HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全
3. SSL（Secure Socket Layer，安全套接字层）
SSL为Netscape所研发，用以保障在Internet上数据传输之安全，利用数据加密技术，可确保数据在网络上传输过程中不会被截取，当前为3.0版本。
SSL协议可分为两层：SSL记录协议（SSL Recore Protocol）：它建立在可靠地传输协议（如TCP）之上，为高层协议提供数据封装、压缩、加密等基本功能的支持。SSL握手协议（SSL Handshake Protocol）：它建立在SSL记录协议之上，用于在实际的数据传输开始前，通讯双方进行身份证、协商加密算法、交换加密密钥等。
二、http的响应码及含义？ 1 消息
▪ 100 Continue
▪ 101 Switching Protocols
▪ 102 Processing
2 成功
▪ 200 OK
▪ 201 Created
▪ 202 Accepted
▪ 203 Non-Authoritative Information
▪ 204 No Content
▪ 205 Reset Content
▪ 206 Partial Content" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/211ee2bd6088f5a9a8177ac34090f8d4/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-09-28T14:27:49+08:00" />
<meta property="article:modified_time" content="2020-09-28T14:27:49+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">http与https、响应码（状态码）、缓存</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="urlhttphttps_0"></a>一、url的组成？http和https是同一个协议吗？</h3> 
<p><strong>组成：传输协议，域名，端口，文件位置，参数。</strong><br> HTTP（顺丰）：<strong>超文本传输协议</strong>（除了传递普通的文本，还可以传递文件流或者进制编码等信息），<strong>端口80</strong><br> HTTPS（邮政）：<strong>基于SSL</strong>（Secure Sockets Layer <strong>安全套接层</strong>）加密的HTTP传输协议，比HTTP更加的安全（涉及支付的网站一般都是基于HTTPS完成的），<strong>端口443</strong><br> FTP（货运）：<strong>文件传输协议</strong>，一般用来实现资源文件在服务器上的<strong>上传下载</strong></p> 
<p><strong>1. Https的作用</strong></p> 
<p>内容加密 建立一个信息安全通道，来保证数据传输的安全；<br> 身份验证 确认网站的真实性；<br> 数据完整性 防止内容被第三方冒充或者篡改</p> 
<p><strong>2. HTTPS和HTTP的区别</strong></p> 
<p>https协议需要到CA申请证书<br> http是超文本传输协议，信息时<strong>明文传输</strong>；https则是具有安全性的ssl<strong>加密</strong>传输协议<br> http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443<br> <strong>http的连接很简单，是无状态</strong>的；https协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全</p> 
<p><strong>3. SSL（Secure Socket Layer，安全套接字层）</strong></p> 
<p>SSL为Netscape所研发，用以保障在Internet上数据传输之安全，利用数据加密技术，可确保数据在网络上传输过程中不会被截取，当前为3.0版本。</p> 
<p>SSL协议可分为两层：SSL记录协议（SSL Recore Protocol）：它建立在可靠地传输协议（如TCP）之上，为高层协议提供数据封装、压缩、加密等基本功能的支持。SSL握手协议（SSL Handshake Protocol）：它建立在SSL记录协议之上，用于在实际的数据传输开始前，通讯双方进行身份证、协商加密算法、交换加密密钥等。</p> 
<h3><a id="http_25"></a>二、http的响应码及含义？</h3> 
<p><strong>1 消息</strong><br> ▪ <strong>100 Continue</strong><br> ▪ 101 Switching Protocols<br> ▪ 102 Processing<br> <strong>2 成功</strong><br> ▪ <strong>200 OK</strong><br> ▪ 201 Created<br> ▪ <strong>202 Accepted</strong><br> ▪ 203 Non-Authoritative Information<br> ▪ 204 No Content<br> ▪ 205 Reset Content<br> ▪ 206 Partial Content<br> ▪ 207 Multi-Status<br> <strong>3 重定向</strong><br> ▪ 300 Multiple Choices<br> ▪ <strong>301 Moved Permanently</strong><br> ▪ 302 Move Temporarily<br> ▪ 303 See Other<br> ▪ <strong>304 Not Modified</strong><br> ▪ 305 Use Proxy<br> ▪ 306 Switch Proxy<br> ▪ 307 Temporary Redirect<br> <strong>4 请求错误</strong><br> ▪ 400 Bad Request<br> ▪ <strong>401 Unauthorized</strong><br> ▪ 402 Payment Required<br> ▪ 403 Forbidden<br> ▪ <strong>404 Not Found</strong><br> ▪ 405 Method Not Allowed<br> ▪ 406 Not Acceptable<br> ▪ 407 Proxy Authentication Required<br> ▪ 408 Request Timeout<br> ▪ 409 Conflict<br> ▪ 410 Gone<br> ▪ 411 Length Required<br> ▪ 412 Precondition Failed<br> ▪ 413 Request Entity Too Large<br> ▪ 414 Request-URI Too Long<br> ▪ 415 Unsupported Media Type<br> ▪ 416 Requested Range Not Satisfiable<br> ▪ 417 Expectation Failed<br> ▪ 418 I’m a teapot<br> ▪ 421Misdirected Request<br> ▪ 422 Unprocessable Entity<br> ▪ 423 Locked<br> ▪ 424 Failed Dependency<br> ▪ 425 Too Early<br> ▪ 426 Upgrade Required<br> ▪ 449 Retry With<br> ▪ 451 Unavailable For Legal Reasons<br> <strong>5 服务器错误</strong><br> <strong>▪ 500 Internal Server Error</strong><br> ▪ 501 Not Implemented<br> ▪ 502 Bad Gateway<br> ▪ 503 Service Unavailable<br> ▪ 504 Gateway Timeout<br> ▪ 505 HTTP Version Not Supported<br> ▪ 506 Variant Also Negotiates<br> ▪ 507 Insufficient Storage<br> ▪ 509 Bandwidth Limit Exceeded<br> ▪ 510 Not Extended<br> ▪ 600 Unparseable Response Headers</p> 
<p><strong>http状态返回代码 1xx（临时响应）表示临时响应并需要请求者继续执行操作的状态代码。</strong></p> 
<p><strong>100 （继续）请求者应当继续提出请求。服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。</strong><br> 101 （切换协议）请求者已要求服务器切换协议，服务器已确认并准备切换。</p> 
<p><strong>http状态返回代码 2xx （成功）表示成功处理了请求的状态代码。</strong></p> 
<p><strong>200 （成功） 服务器已成功处理了请求，并提供了请求的网页。</strong><br> 201 （已创建） 请求成功并且服务器创建了新的资源。<br> <strong>202 （已接受） 服务器已接受请求，但尚未处理。</strong><br> 203 （非授权信息） 服务器已成功处理了请求，但返回的信息可能来自另一来源。<br> 204 （无内容） 服务器成功处理了请求，但没有返回任何内容。可能会返回新的头部元信息。<br> 205 （重置内容）服务器成功处理了请求，但没有返回任何内容。<br> 206 （部分内容） 服务器成功处理了部分 GET 请求。</p> 
<p><strong>http状态返回代码 3xx （重定向）<br> 表示要完成请求，需要进一步操作。通常，这些状态代码用来重定向。</strong><br> 300 （多种选择） 针对请求，服务器可执行多种操作。服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。<br> <strong>301 （永久移动） 请求的网页已永久移动到新位置。服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。</strong><br> 302 （临时移动） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。<br> 303 （查看其他位置）请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。<br> <strong>304 （未修改）自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容。</strong><br> 305 （使用代理）请求者只能使用代理访问请求的网页。如果服务器返回此响应，还表示请求者应使用代理。<br> 307 （临时重定向） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。</p> 
<p><strong>http状态返回代码 4xx（请求错误）</strong></p> 
<p>400 （错误请求）服务器不理解请求的语法。<br> <strong>401 （未授权）请求要求身份验证。对于需要登录的网页，服务器可能返回此响应。</strong><br> 403 （禁止）服务器拒绝请求。<br> <strong>404 （未找到）服务器找不到请求的网页。</strong><br> 405 （方法禁用）禁用请求中指定的方法。<br> 406 （不接受）无法使用请求的内容特性响应请求的网页。<br> 407 （需要代理授权）此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。<br> 408 （请求超时） 服务器等候请求时发生超时。<br> 409 （冲突） 服务器在完成请求时发生冲突。服务器必须在响应中包含有关冲突的信息。<br> 410 （已删除） 如果请求的资源已永久删除，服务器就会返回此响应。<br> 411 （需要有效长度）服务器不接受不含有效内容长度标头字段的请求。<br> 412 （未满足前提条件）服务器未满足请求者在请求中设置的其中一个前提条件。<br> 413 （请求实体过大）服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。<br> 414 （请求的 URI 过长）请求的 URI（通常为网址）过长，服务器无法处理。<br> 415 （不支持的媒体类型）请求的格式不受请求页面的支持。<br> 416 （请求范围不符合要求）如果页面无法提供请求的范围，则服务器会返回此状态代码。<br> 417 （未满足期望值）服务器未满足"期望"请求标头字段的要求。</p> 
<p><strong>http状态返回代码 5xx（服务器错误）<br> 这些状态代码表示服务器在尝试处理请求时发生内部错误。这些错误可能是服务器本身的错误，而不是请求出错。</strong><br> <strong>500 （服务器内部错误） 服务器遇到错误，无法完成请求。</strong><br> 501 （尚未实施）服务器不具备完成请求的功能。例如，服务器无法识别请求方法时可能会返回此代码。<br> 502 （错误网关）服务器作为网关或代理，从上游服务器收到无效响应。<br> 503 （服务不可用）服务器目前无法使用（由于超载或停机维护）。通常，这只是暂时状态。<br> 504 （网关超时） 服务器作为网关或代理，但是没有及时从上游服务器收到请求。<br> 505 （HTTP 版本不受支持）服务器不支持请求中所用的 HTTP 协议版本。</p> 
<p><strong>浏览器请求url后，再次刷新页面，浏览器会怎么加载资源（缓存），哪个状态码跟缓存相关？</strong><br> 200<br> 304</p> 
<h3><a id="_147"></a>三、浏览器缓存策略</h3> 
<p><img src="https://images2.imgbox.com/60/0b/XJJz7lak_o.png" alt="在这里插入图片描述"></p> 
<p><strong>1. 强缓存 : Expires &amp; Cache-control</strong></p> 
<p>强缓存策略会直接从本地拿缓存资源不向服务器发请求，请求状态直接返回状态码200， from cahe 或 from disk</p> 
<p>Expires<br> Expires 是一个GMT格式的时间值，是服务器时间，客户端第一次请求服务器，服务器在返回请求时，会在响应头中带上Expires信息，客户端拿到响应后，会把响应内容和这个响应头一起缓存下来，下一次发请求时，会在缓存中找这个资源，并把Expires和当前时间做对比，如果当前时间小于Expires，则不发送请求，直接从本地缓存拿资源，如果当前时间大于Expires，则会发送请求，从服务器拿资源，同时更新Expires。</p> 
<p>使用Expires的强缓存策略有一个缺点，即Expires是服务端时间，但浏览器比对用的当前时间是客户端时间，如果客户端时间被修改，那么可能会出现资源已经过期了，但浏览器不发请求，依然使用过期资源的情况</p> 
<p>Cache-control<br> Cache-control的强缓存策略是设置Cache-control：max-age=315360000； 时间单位为秒，缓存策略过程与上面基本相同，比对的时候是使用当前时间加上max-age 算出过期时间，然后用当前时间与过期时间比较，因为两个比较时间都是用的客户端时间，所以比Expires可靠性要高些，如果同时Expires和Cache-control：max-age, 强缓存策略会优先以Cache-control的 max-age （优先级高）来处理。</p> 
<p><strong>2. 协商缓存 Last-Modified &amp; Etag</strong></p> 
<p>必须在配置强缓存后协商缓存才生效（不一定要配置强缓存过期，可以配置Cache-control：no-cache, 让强缓存直接过渡到协商缓存），强缓存没命中后，开始协商缓存策略（见上面流程图）。协商缓存会向服务器发请求，如果缓存未过期可用，则服务器返回状态码304，Not Modified</p> 
<p>Last-Modified<br> 客户端第一次向服务器发请求，服务器会在响应头中会加上Last-Modified ，一个GMT格式的时间值，客户端在下一次请求时，会将这个Last-Modified的值写入到请求头If-Modified-Since，服务器再次收到请求时，会将If-Modified-Since与资源最后修改时间做比较，如果没有变化，则只返回304，Not Modified，如果有变化，则返回新资源，并返回新的Last-Modified。 （当返回304，Not Modified， 相当于资源没有改动，故Last-Modified也没有改变，这时Last-Modified不返回）</p> 
<p>使用Last-Modified可能会遇到的一个问题是，就是服务器时间被篡改，或资源修改的时候没有更新修改时间，那么就会出现问题，于是引出下面的处理方案。</p> 
<p>Etag<br> 处理流程与上面相似，服务器每次收到请求，都会对当前资源生成一个标记，即Etag，客户端拿到服务端返回后，在下一次请求时，会把之前的Etag值放到请求头If-None-Match中，服务器拿到请求，对当前资源生成Etag， 将此Etag和If-None-Match进行对比，如果没区别，则返回304，Not Modified， 同时将Etag返回，如果有区别，则返回资源，并返回Etag。</p> 
<p>由于每次请求，服务端都会生成Etag，所以可以解决资源改变，但缓存标记未变，或后端服务器时间被篡改的问题，同时因为每次请求都会根据资源生成新的Etag, 所以在无任何变化，304，Not Modified时同样会返回Etag.<br> <strong>3、cookies，sessionStorage 和 localStorage 的区别</strong><br> <strong>存储位置</strong>：cookie是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）。始终在同源的http请求中携带（即使不需要），记会在浏览器和服务器间来回传递。sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。<br> <strong>存储大小</strong>：cookie数据大小不能超过4k。sessionStorage和localStorage比cookie大得多，可以达到5M或更大。<br> <strong>有效时间</strong>：localStorage存储持久数据，浏览器关闭后数据不丢失除非主动删除数据；sessionStorage数据在当前浏览器窗口关闭后自动删除。cookie设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭。<br> <strong>作用域</strong>：sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；localStorage 和 cookie在所有同源窗口中都是共享的。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/438b69a65c2a0e20c543b8ea345ead8a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">SAXParseException的错误解决</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b5ae2b241906ea7d7922b2bbec6a61d9/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Mysql5.7版本中，查询分组GROUP BY通过子查询中ORDER BY进行排序无效的问题解决办法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>