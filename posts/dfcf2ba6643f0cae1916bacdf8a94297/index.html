<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Android中JNI&amp;NDK入门(四) 之 使用CMake方式编译NDK - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Android中JNI&amp;NDK入门(四) 之 使用CMake方式编译NDK" />
<meta property="og:description" content="1 前言 我们在前面几篇文章中对JNK/NDK做了一个入门的介绍，其中使用了Android.mk和Application.mk本地配置的方式进行NDK开发。但是其实在Android Studio 2.2之后便加入了CMake方式来编译NDK代码。
2 CMake CMake是一个跨平台的安装（编译）工具，可以用简单的语句来描述所有平台的安装(编译过程)。他能够输出各种各样的makefile或者project文件，能测试编译器所支持的C&#43;&#43;特性,类似UNIX下的automake。谷歌从Android Studio2.2及更高版本使用NDK和CMake将C及C&#43;&#43;代码编译到原生库中，其中通过Gradle便可方便地将SO库封装到APK中去。
3 Hello world 如果你是首次使用CMake，还要跟前面安装NDK一样，在Android Studio中的SDK管理页面勾选CMake项进行下载，操作如下面图：
待安装完毕后，便可以创建Native C&#43;&#43;项目了。在【File】 – 【New Project】弹窗中，勾上【Include C&#43;&#43; support】项，如下图：
项目创建好以后我们可以看到和普通Android项目有几下不同地方，如下图：
1. app目录下多出一个.externalNativeBuidl目录。
2. main目录下多出一个cpp目录，其中里头有一个native-lib.cpp文件，这便是放置C/C&#43;&#43;代码地方。
3. app目录下的buile.gradle内容里多出两项。能看出，第一项便上我们在新建项目时选择的C&#43;&#43;版本和勾上的-fexceptions和-frtti项，它们分别是异常支持（-fexceptions）和运行时类型信息支持（-frtti）； 第二项便是指定CMakeLists.txt文件。
4. app目录下还多出一个CMakeLists.txt文件，其内容如下：
3.1 CMakeLists.txt解说 我们看回上面CMakeLists.txt文件内容，里面去除注释就剩4行有效代码，我们来看看它们的含义。
cmake_minimum_required(VERSION major[.minor[.patch[.tweak]]][FATAL_ERROR]) 设置工程所需要的最低CMake版本，如上述最低版本是3.4.1。
add_library(&lt;name&gt; [STATIC | SHARED | MODULE] [EXCLUDE_FROM_ALL] source1 source2 ... sourceN) 添加一个库。如上述是：编译出一个动态库 native-lib，源文件只有 src/main/cpp/native-lib.cpp。参数说明：
&lt;name&gt; 表示添加一个指定名称的库文件。
[STATIC | SHARED | MODULE] 指定要创建的库的类型，STATIC对应的静态库（.a文件，编译时需要，相当于Windows中的lib文件）、SHARED对应共享动态库（.so文件，运行时需要，相当于Windows中的dll文件）、MODULE对应工程内的module。
[EXCLUDE_FROM_ALL] 若指定此属性，则对应的一些属性会在目录被创建时被设置，详细请查阅相应文档。
source1 source2 ... sourceN 指定源文件。
find_library(&lt;VAR&gt; name1 [path1 path2 ." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/dfcf2ba6643f0cae1916bacdf8a94297/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-07-17T16:35:40+08:00" />
<meta property="article:modified_time" content="2019-07-17T16:35:40+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Android中JNI&amp;NDK入门(四) 之 使用CMake方式编译NDK</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2 style="margin-left:0cm;">1 前言</h2> 
<p style="margin-left:0cm;">我们在前面几篇文章中对JNK/NDK做了一个入门的介绍，其中使用了Android.mk和Application.mk本地配置的方式进行NDK开发。但是其实在Android Studio 2.2之后便加入了CMake方式来编译NDK代码。</p> 
<h2 style="margin-left:0cm;">2 CMake</h2> 
<p style="margin-left:0cm;">CMake是一个跨平台的安装（编译）工具，可以用简单的语句来描述所有平台的安装(编译过程)。他能够输出各种各样的makefile或者project文件，能测试编译器所支持的C++特性,类似UNIX下的automake。谷歌从Android Studio2.2及更高版本使用NDK和CMake将C及C++代码编译到原生库中，其中通过Gradle便可方便地将SO库封装到APK中去。</p> 
<h2 style="margin-left:0cm;">3 Hello world</h2> 
<p style="margin-left:0cm;">如果你是首次使用CMake，还要跟前面安装NDK一样，在Android Studio中的SDK管理页面勾选CMake项进行下载，操作如下面图：</p> 
<p style="margin-left:0cm;"><img alt="" class="has" height="490" src="https://images2.imgbox.com/e4/c9/i1ZkmDUD_o.png" width="701"></p> 
<p style="margin-left:0cm;">待安装完毕后，便可以创建Native C++项目了。在【File】 – 【New Project】弹窗中，勾上【Include C++ support】项，如下图：</p> 
<p style="margin-left:0cm;"><img alt="" class="has" height="525" src="https://images2.imgbox.com/93/d1/ARlBZgHo_o.png" width="704"></p> 
<p><img alt="" class="has" height="524" src="https://images2.imgbox.com/8a/3b/Fz5Cnkxz_o.png" width="702"></p> 
<p>项目创建好以后我们可以看到和普通Android项目有几下不同地方，如下图：</p> 
<p><img alt="" class="has" height="397" src="https://images2.imgbox.com/8b/9f/I0EDphvN_o.png" width="701"></p> 
<p>1. app目录下多出一个.externalNativeBuidl目录。</p> 
<p>2. main目录下多出一个cpp目录，其中里头有一个native-lib.cpp文件，这便是放置C/C++代码地方。</p> 
<p>3. app目录下的buile.gradle内容里多出两项。能看出，第一项便上我们在新建项目时选择的C++版本和勾上的-fexceptions和-frtti项，它们分别是异常支持（-fexceptions）和运行时类型信息支持（-frtti）； 第二项便是指定CMakeLists.txt文件。</p> 
<p>4. app目录下还多出一个CMakeLists.txt文件，其内容如下：</p> 
<p><img alt="" class="has" height="673" src="https://images2.imgbox.com/72/fd/XDfy0pjd_o.png" width="707"></p> 
<p style="margin-left:0cm;"> </p> 
<h3 style="margin-left:0cm;">3.1 CMakeLists.txt解说</h3> 
<p style="margin-left:0cm;">我们看回上面CMakeLists.txt文件内容，里面去除注释就剩4行有效代码，我们来看看它们的含义。</p> 
<h4 style="margin-left:0cm;"><span style="color:#3399ea;">cmake_minimum_required(VERSION major[.minor[.patch[.tweak]]][FATAL_ERROR])</span></h4> 
<p style="margin-left:0cm;">设置工程所需要的最低CMake版本，如上述最低版本是3.4.1。</p> 
<h4 style="margin-left:0cm;"><span style="color:#3399ea;">add_library(&lt;name&gt; [STATIC | SHARED | MODULE] [EXCLUDE_FROM_ALL] source1 source2 ... sourceN)</span></h4> 
<p style="margin-left:0cm;"><strong>添加一个库</strong>。如上述是：编译出一个动态库 native-lib，源文件只有 src/main/cpp/native-lib.cpp。参数说明：</p> 
<p style="margin-left:0cm;">&lt;name&gt;                                                       表示添加一个指定名称的库文件。</p> 
<p style="margin-left:0cm;">[STATIC | SHARED | MODULE]                指定要创建的库的类型，STATIC对应的静态库（.a文件，编译时需要，相当于Windows中的lib文件）、SHARED对应共享动态库（.so文件，运行时需要，相当于Windows中的dll文件）、MODULE对应工程内的module。</p> 
<p style="margin-left:0cm;">[EXCLUDE_FROM_ALL]                           若指定此属性，则对应的一些属性会在目录被创建时被设置，详细请查阅相应文档。</p> 
<p style="margin-left:0cm;">source1 source2 ... sourceN                     指定源文件。</p> 
<h4 style="margin-left:0cm;"><span style="color:#3399ea;">find_library(&lt;VAR&gt; name1 [path1 path2 ...])</span></h4> 
<p style="margin-left:0cm;"><strong>查找一个库文件</strong>。如上述是：查找预编译库log_lib。</p> 
<h4 style="margin-left:0cm;"><span style="color:#3399ea;">target_link_libraries(&lt;name&gt; lib1 lib2 lib3)</span></h4> 
<p style="margin-left:0cm;"><strong>将给定的库链接到一个目标上</strong>。如上述是：找到预编译库 log_lib 并link到动态库 native-lib中。</p> 
<h3 style="margin-left:0cm;">3.2 代码解说</h3> 
<p style="margin-left:0cm;"><strong>native-lib.cpp</strong></p> 
<pre class="has"><code class="language-cpp">#include &lt;jni.h&gt;
#include &lt;string&gt;

extern "C" JNIEXPORT jstring JNICALL
Java_com_zyx_cmakedemo_MainActivity_stringFromJNI(JNIEnv *env, jobject /* this */) {
    std::string hello = "Hello from C++";
    return env-&gt;NewStringUTF(hello.c_str());
}</code></pre> 
<p style="margin-left:0cm;"><strong>MainActivity.java</strong></p> 
<pre class="has"><code class="language-java">public class MainActivity extends AppCompatActivity {

    // Used to load the 'native-lib' library on application startup.
    static {
        System.loadLibrary("native-lib");
    }

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        // Example of a call to a native method
        TextView tv = findViewById(R.id.sample_text);
        tv.setText(stringFromJNI());
    }

    /**
     * A native method that is implemented by the 'native-lib' native library,
     * which is packaged with this application.
     */
    public native String stringFromJNI();
}
</code></pre> 
<p style="margin-left:0cm;">非常简单的代码，在MainActivity在静态块中进行加载libnative-lib.so，然后定义了一个native 方法stringFromJNI。接着在native-lib.cpp中实现stringFromJNI方法，函数名称也是遵循规则：Java_包名_类名_方法名。</p> 
<h3 style="margin-left:0cm;">3.3运行</h3> 
<p style="margin-left:0cm;">执行编译运行，这时就会在app\build\intermediates\cmake\debug\obj目录下生成对应的so文件。然后将程序运行到手机上便会看到Java成功调用了C++代码返回了结果。</p> 
<p style="margin-left:0cm;"><img alt="" class="has" height="372" src="https://images2.imgbox.com/03/3c/7JtHdYau_o.png" width="288"> <img alt="" class="has" height="370" src="https://images2.imgbox.com/cd/73/ggaE6FwS_o.jpg" width="208"></p> 
<h2 style="margin-left:0cm;">4 引用外部so库</h2> 
<p style="margin-left:0cm;">在实际开发过程中，往往C++工程是跟Android工程分离，或者Android工程中直接引用外部提供现成的so库文件。现在我们就来模拟一下这种情况的发生。</p> 
<p style="margin-left:0cm;">首先将上述编译好的so文件拷贝到app\src\main\jniLibs中，如下图：</p> 
<p style="margin-left:0cm;"><img alt="" class="has" height="404" src="https://images2.imgbox.com/b3/2f/b7Nfx75p_o.png" width="281"></p> 
<p style="margin-left:0cm;">接着修改<strong>CMakeLists.txt</strong>内容，如下：</p> 
<pre class="has"><code class="language-cpp">cmake_minimum_required(VERSION 3.4.1)

add_library(native-lib SHARED IMPORTED)

set_target_properties(native-lib PROPERTIES IMPORTED_LOCATION ${CMAKE_SOURCE_DIR}/src/main/jniLibs/${ANDROID_ABI}/libnative-lib.so)</code></pre> 
<p style="margin-left:0cm;">下面两行代码意思是：添加一个动态库，然后设置so库的路径，其中 ${CMAKE_SOURCE_DIR} 是CMakeLists.txt所在的路径， ${ANDROID_ABI} 是标识cup类型。</p> 
<p style="margin-left:0cm;">修改完后重新编译运行即可，显示结果和上面源码集成是一样的。</p> 
<h2 style="margin-left:0cm;">5 更多资料</h2> 
<p style="margin-left:0cm;">更多关于NDK和CMake的资料，可参考：</p> 
<p style="margin-left:0cm;"><a href="https://developer.android.com/ndk/guides/index.html" rel="nofollow">https://developer.android.com/ndk/guides/index.html</a></p> 
<p style="margin-left:0cm;"><a href="https://developer.android.com/ndk/guides/cmake.html" rel="nofollow">https://developer.android.com/ndk/guides/cmake.html</a>.</p> 
<p style="margin-left:0cm;"><a href="https://www.zybuluo.com/khan-lau/note/254724" rel="nofollow">https://www.zybuluo.com/khan-lau/note/254724</a></p> 
<p style="margin-left:0cm;"><a href="https://github.com/googlesamples/android-ndk">https://github.com/googlesamples/android-ndk</a></p> 
<p style="margin-left:0cm;"><a href="https://cmake.org/cmake-tutorial/" rel="nofollow">https://cmake.org/cmake-tutorial/</a></p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;"> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3bcb16b718d2cf0d5e35a6c21f1b302e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">树形DP求树的直径</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/33d77d052c3d52f2aa48afa3d308ab5d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">二级联动加动态input输入框实现思路</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>