<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>三. LiDAR和Camera融合的BEV感知算法-BEVFusion - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="三. LiDAR和Camera融合的BEV感知算法-BEVFusion" />
<meta property="og:description" content="目录 前言0. 简述1. 算法动机&amp;开创性思路2. 主体结构2.1 相机支路2.2 点云支路2.3 Fusion 3. 损失函数4. 性能对比总结下载链接参考 前言 自动驾驶之心推出的《国内首个BVE感知全栈系列学习教程》，链接。记录下个人学习笔记，仅供自己参考
本次课程我们来学习下课程第三章——LiDAR和Camera融合的BEV感知算法，一起去学习下 BEVFusion 感知算法
课程大纲可看下面的思维导图
0. 简述 本次课程来给大家讲解一篇非常经典的融合工作叫 BEVFusion，我们依旧从算法动机&amp;开创性思路、主体结构、损失函数以及性能对比四个方面展开
BEVFusion 有两篇文章，本次课程主要讲解的是阿里和北大的：BEVFusion: A Simple and Robust LiDAR-Camera Fusion Framework
另外一篇是 MIT 的工作：BEVFusion: Multi-Task Multi-Sensor Fusion with Unified Bird’s-Eye View Representation
1. 算法动机&amp;开创性思路 我们先看 BEVFusion 这个名字能想到什么呢？很显然，我们将它拆开来看，一个是 BEV，另一个是 Fusion
那 BEV 是什么呢？是一个俯视空间，鸟瞰图，我们称之为上帝视角
那什么叫 Fusion 呢？翻译过来叫融合，那既然是融合是什么和什么的融合呢？通常情况下我们讲的融合是跨模态的融合，比如图像和语音信号的融合，图像和毫米波雷达的融合，图像和激光雷达点云的融合。
BEVFusion 属于哪种如何呢？从下面的框图中我们也能够看出来它属于图像和点云的融合
图1 BEVFusion整体结构 融合的输入知道了，那是怎么做融合的呢？那也就是说我们怎么把图像和点云融合在一起的呢？
作者认为融合方法可以分为三种，如下图所示：
图2 LiDAR-Camera融合方法对比 第一种叫做 Point-lever Fusion 也就是点级的融合，Point-level 中的 Point 指的是点云中的点，那也就是说 Point-lever 的策略是从点出发，从点云中采样出一些点，然后我们根据相机的内参和外参矩阵将采样的点投影到图像上采样出图像特征，然后再拼接到点云上。我们在 (a) 中能看到橙色 ■ 部分和蓝色 ■ 部分是对应的点特征和图像特征，我们会利用融合后的特征去做 3D 检测，这就是点级的融合。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/3f938d53843746784660471bc429cb6b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-10T21:20:59+08:00" />
<meta property="article:modified_time" content="2023-12-10T21:20:59+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">三. LiDAR和Camera融合的BEV感知算法-BEVFusion</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>目录</h4> 
 <ul><li><ul><li><a href="#_2" rel="nofollow">前言</a></li><li><a href="#0__13" rel="nofollow">0. 简述</a></li><li><a href="#1__21" rel="nofollow">1. 算法动机&amp;开创性思路</a></li><li><a href="#2__67" rel="nofollow">2. 主体结构</a></li><li><ul><li><a href="#21__84" rel="nofollow">2.1 相机支路</a></li><li><a href="#22__139" rel="nofollow">2.2 点云支路</a></li><li><a href="#23_Fusion_176" rel="nofollow">2.3 Fusion</a></li></ul> 
   </li><li><a href="#3__194" rel="nofollow">3. 损失函数</a></li><li><a href="#4__218" rel="nofollow">4. 性能对比</a></li><li><a href="#_253" rel="nofollow">总结</a></li><li><a href="#_259" rel="nofollow">下载链接</a></li><li><a href="#_264" rel="nofollow">参考</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h3><a id="_2"></a>前言</h3> 
<blockquote> 
 <p>自动驾驶之心推出的《国内首个BVE感知全栈系列学习教程》，<a href="https://www.zdjszx.com/p/t_pc/goods_pc_detail/goods_detail/course_2MjRdDQO8jGkz1Sx4AoJ0sytlIU" rel="nofollow">链接</a>。记录下个人学习笔记，<strong>仅供自己参考</strong></p> 
 <p>本次课程我们来学习下课程第三章——LiDAR和Camera融合的BEV感知算法，一起去学习下 BEVFusion 感知算法</p> 
 <p>课程大纲可看下面的思维导图</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/73/d0/kH5LvKER_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="0__13"></a>0. 简述</h3> 
<p>本次课程来给大家讲解一篇非常经典的融合工作叫 BEVFusion，我们依旧从算法动机&amp;开创性思路、主体结构、损失函数以及性能对比四个方面展开</p> 
<p>BEVFusion 有两篇文章，本次课程主要讲解的是阿里和北大的：<a href="https://arxiv.org/pdf/2205.13790.pdf" rel="nofollow">BEVFusion: A Simple and Robust LiDAR-Camera Fusion Framework</a></p> 
<p>另外一篇是 MIT 的工作：<a href="https://arxiv.org/pdf/2205.13542.pdf" rel="nofollow">BEVFusion: Multi-Task Multi-Sensor Fusion with Unified Bird’s-Eye View Representation</a></p> 
<h3><a id="1__21"></a>1. 算法动机&amp;开创性思路</h3> 
<p>我们先看 BEVFusion 这个名字能想到什么呢？很显然，我们将它拆开来看，一个是 BEV，另一个是 Fusion</p> 
<p>那 BEV 是什么呢？是一个俯视空间，鸟瞰图，我们称之为上帝视角</p> 
<p>那什么叫 Fusion 呢？翻译过来叫融合，那既然是融合是什么和什么的融合呢？通常情况下我们讲的融合是跨模态的融合，比如图像和语音信号的融合，图像和毫米波雷达的融合，图像和激光雷达点云的融合。</p> 
<p>BEVFusion 属于哪种如何呢？从下面的框图中我们也能够看出来它属于图像和点云的融合</p> 
<p><img src="https://images2.imgbox.com/2c/24/FCgPzFmK_o.png" alt="在这里插入图片描述"></p> 
<center> 
 <b>图1 BEVFusion整体结构</b> 
</center> 
<p>融合的输入知道了，那是怎么做融合的呢？那也就是说我们怎么把图像和点云融合在一起的呢？</p> 
<p>作者认为融合方法可以分为三种，如下图所示：</p> 
<p><img src="https://images2.imgbox.com/05/1c/PGJPcwAV_o.png" alt="在这里插入图片描述"></p> 
<center> 
 <b>图2 LiDAR-Camera融合方法对比</b> 
</center> 
<p>第一种叫做 <strong>Point-lever Fusion</strong> 也就是点级的融合，Point-level 中的 Point 指的是点云中的点，那也就是说 Point-lever 的策略是从点出发，从点云中采样出一些点，然后我们根据相机的内参和外参矩阵将采样的点投影到图像上采样出图像特征，然后再拼接到点云上。我们在 (a) 中能看到橙色 <font color="FFCC99">■</font> 部分和蓝色 <font color="6C8EBF">■</font> 部分是对应的点特征和图像特征，我们会利用融合后的特征去做 3D 检测，这就是点级的融合。</p> 
<p>第二种方式叫做 <strong>Feature-level Fusion</strong> 也就是特征级的融合，它会将多模态的中间特征通过内外参矩阵拼接投影融合出完整的特征，特征之间传递的是什么呢？是 Query，按照 Query 的方式，比如输入点云通过一个点云网络得到初始的位置，初始位置去图像上采样特征，是一个点云去图像的过程，采样完特征之后我们再拿回到初始的点云空间中拼接到原始的特征上，在 (b) 中蓝色的小方块 <font color="6C8EBF">■</font> 是我们从图像中采样过来的特征，而橙色的小方块 <font color="FFCC99">■</font> 是我们原始的初始的点云特征，两种类型的特征拼接在一起我们去进行 3D 检测任务。</p> 
<p>那看到这里，我们思考下 Point-level 和 Feature-level 的方法存在什么问题呢？</p> 
<p>我们从融合的流程上来看两种方案其实都离不开一个映射的过程，也就是说我们利用内参和外参矩阵需要将 3D 的点换算到 2D 空间上。我们讲过内参我们认为相机出厂之后就恒定了，是一个比较稳定的量，而相机外参是衡量相机和激光雷达间相对位置关系的，它可能由于初始的校准或者车辆运行过程中的颠簸抖动造成一定的偏差。外参如果产生偏差，从点云去往图像投影时会很直接的产生一个投影偏差，<strong>那这是第一点，即投影过程中可能产生一定的偏差</strong>。</p> 
<p>那第二点，我们即使很准确的能够看到投影点，但我们发现相机在这个点的成像效果可能并不好，比如我们点云投影到图像上之后，采样处的位置可能没有图像特征，比如像镜头脏引起的遮挡，还有像某些相机损坏可能导致的卡帧等等，我们的点云投影在图像上很难找到一个对应的特征或者说我们找到了不太好的甚至错误的特征，<strong>这是第二点，即采样的图像特征的质量并不是特别高</strong></p> 
<p>那第三点，从源头上来看，Point-level 和 Feature-level 方法全都是从点云出发的，将点云投影到图像上，假设我们的初始位置就已经丢失了，也就是点云信息没有了，那我们能难找到它在图像上所能对应的投影位置。</p> 
<p>所以像 BEVFusion 的作者认为以前的融合方式，无论是 Point-level 还是 Feature-level，它们之间存在一个主次依赖的关系-从点云出发，以点云为基础。那点云如果不准，外参如果不准，后续的检测自然也就不准了</p> 
<p>所以 BEVFusion 其实是想能够尽可能的降低这种主次依赖关系，对点云和图像分别去进行处理，然后在 BEV 空间做融合。那所以我们在 © 中可以看到输入是图像和点云，它通过两条并行的网络去做处理，然后通过一个融合模块去做融合，它们之间是没有什么主次依赖关系的，哪个好我就用哪个，那比如在某个点位可能点云信息比较好，那我们就用点云信息，比如另外一个点位可能图像信息比较好，那我们就用图像信息。</p> 
<p>另外我们介绍的这篇 BEVFusion 还有一个特点，除了我们一个融合特征的检测头之外，它在每一个模态信息下面都额外接了一个检测头，那像作者的意思是说我们可能融合之后的效果也不是很好，或者说我单一的依靠图像或者单一的依靠点云也不好，但它们是可以融合工作也可以分开独立工作，所以尽可能地避免在一些偏极端情况下产生的一些影响</p> 
<p>OK！我们在这里简单总结下，BEVFusion 的动机还是回到了标题，它是一种融合的思路，融合的是什么呢，融合的是点云和图像，怎么做融合呢，在 BEV 空间做的融合，它们的融合有主次依赖关系吗，很弱的一种依赖关系</p> 
<p>OK，以上就是 BEVFusion 算法的动机，下面我们重点来看看 BEVFusion 的主体结构，他们是怎么设计这个网络的</p> 
<h3><a id="2__67"></a>2. 主体结构</h3> 
<p>我们还是老套路看网络先看其输入和输出部分，输入是包含多模态的，一个是多视角的图像输入，还有一个是 Point Clouds 点云输入，输出是 final detection result 即最终的 3D 检测结果。</p> 
<p><img src="https://images2.imgbox.com/26/39/K4jyPQJM_o.png" alt="在这里插入图片描述"></p> 
<p>输入图像通过 <strong><font color="6C8EBF"><em>Camera Stream</em></font></strong> 图像流来处理，通过图像编码器 Encoder 可以得到 Multi-view Features 多视角的图像特征，那图像特征怎么转换到 BEV 空间呢？那其实我们在之前也讲过是一个 2D➡3D 的转换器，图像特征会从 2D 映射到 3D，再从 3D 投影到 BEV 空间得到所谓的 Camera BEV Features 即图像特征在 BEV 空间的一种表征。</p> 
<p>输入点云通过 <strong><font color="FFCC99"><em>LiDAR Stream</em></font></strong> 点云流来处理，通过 3D Backbone 我们可以得到点云的 BEV 特征，那这里的 3D Backbone 其实可以有很多，包括基于点的方式、基于体素的方式等等，这里并不局限。我们得到点云特征后，将其拍扁到 BEV 上，自然就得到了点云的 BEV 特征。</p> 
<p>OK！通过上面图像流和点云流之后，我们有了图像的 BEV 特征，有了点云的 BEV 特征，那接下来我们就需要做融合，所以作者引入了一个额外的 Fusion Module 融合模块，融合模块的输入有两个，一个是图像的 BEV Feature，另一个是纯点云的 BEV Feature，通过这个融合模块我们可以得到点云和图像的混合特征，利用混合特征去做预测。</p> 
<p>此外，作者为了实现单一模态也可以做检测的能力，额外加了两个 Detection Head 检测头，图中也列了出来，一个是 Camera Detection Result，利用图像 BEV Feature 可以得到的图像的检测结果，另一个是 LiDAR Detection Result，利用点云 BEV Feature 可以得到的点云的检测结果</p> 
<p>那以上就是 BEVFusion 的完整流程了，其实比较简单，两个支路融合然后再检测，那我们接下来具体分开看下每个支路是怎么做的，融合检测又是怎么做的，我们先从图像支路开始</p> 
<h4><a id="21__84"></a>2.1 相机支路</h4> 
<p><strong><font color="6C8EBF"><em>Camera Stream</em></font></strong> <strong>设计流程如下</strong>：</p> 
<ul><li><strong>输入</strong>：多视角图像</li><li><strong>步骤 1</strong>：2D Backbone 提取基础图像特征</li><li><strong>步骤 2</strong>：FPN+ADP，多尺度特征融合</li><li><strong>步骤 3</strong>：2D➡3D 特征转换模块</li><li><strong>步骤 4</strong>：3D➡BEV 特征编码模块</li><li><strong>输出</strong>：Camera BEV Features</li></ul> 
<p>图像支路的输入是多视角图像，输出是图像的 BEV 特征，中间会经过很多的模块，包括 Encoder、视角转换等等。我们先来看 Encoder 部分，它包含两个部分，一个是 Backbone 也就是骨干网络，比如想 ResNet 这种，然后通过 FPN(Feature Pyramid Network) 特征金字塔去做一个多尺度的融合，多尺度融合无论是 2D 还是 3D 其实都是一种通用的套路。</p> 
<p><img src="https://images2.imgbox.com/29/fe/pHetmqPT_o.png" alt="在这里插入图片描述"></p> 
<center> 
 <b>图3 FPN+ADP模块</b> 
</center> 
<p>那不同尺度的特征通过 ADP 模块去做融合，为什么需要 ADP 模块呢？那其实主要原因还是我们的多尺度特征尺寸是不一致的，它没有办法通过级联或者相加的操作直接合在一起，所以 ADP 实现的一个重要功能就是<strong>通过上采样的操作将不同尺度的特征的尺寸变得一致了</strong>，也就是说 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          F 
         
        
          2 
         
        
       
      
        F_2 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8333em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.1389em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3011em;"><span class="" style="top: -2.55em; margin-left: -0.1389em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span> <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          F 
         
        
          3 
         
        
       
      
        F_3 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8333em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.1389em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3011em;"><span class="" style="top: -2.55em; margin-left: -0.1389em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span> <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          F 
         
        
          4 
         
        
       
      
        F_4 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8333em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.1389em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3011em;"><span class="" style="top: -2.55em; margin-left: -0.1389em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span> <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          F 
         
        
          5 
         
        
       
      
        F_5 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8333em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.1389em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3011em;"><span class="" style="top: -2.55em; margin-left: -0.1389em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span> 开始是有大有小，经过 ADP 之后就是一样大了，特征一样大之后我们后续无论是级联还是相加都是可以做的。</p> 
<p><em><strong>FPN+ADP</strong></em> <strong>设计流程如下</strong>：</p> 
<ul><li><strong>输入</strong>：基础图像特征</li><li><strong>步骤 1</strong>：每层特征使用 ADP 模块</li><li><strong>步骤 2</strong>：ADP 模块包括上采样、池化、卷积</li><li><strong>步骤 3</strong>：多层特征融合</li><li><strong>输出</strong>：多尺度融合特征</li></ul> 
<p>所以图像编码部分的工作输入是多视角图像，经过 2D Backbone 得到图像特征，然后通过 FPN 得到多尺度的特征，接着通过 ADP 模块，那 ADP 其中包括一些上采样，平均池化，还有卷积，通过 ADP 模块之后我们做多尺度的特征融合，最终得到一个融合后的图像特征，那这个融合后的图像特征其实是包含了多尺度信息的。</p> 
<p>那通过 Encode 得到图像特征后，怎么通过图像特征得到我们想要的 Camera BEV Feature 呢？那这里其实是之前我们在第二章基础模块中讲过的 2D➡3D 的特征转换，大家如果忘记了可以先去复习一下。</p> 
<p><em><strong>2D➡3D</strong></em> <strong>特征转换设计流程如下</strong>：</p> 
<ul><li><strong>输入</strong>：多尺度融合特征</li><li><strong>步骤 1</strong>：深度分布估计</li><li><strong>步骤 2</strong>：2D 到 3D 投影计算</li><li><strong>输出</strong>：3D 伪体素特征</li></ul> 
<p><img src="https://images2.imgbox.com/38/84/tTrdBwl1_o.png" alt="在这里插入图片描述"></p> 
<center> 
 <b>图4 图像2D➡3D特征转换</b> 
</center> 
<p>那转换过程其实是对每一个像素位置去进行一个深度分布的预测，我们会预测一系列离散的深度概率，比如 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          α 
         
        
          0 
         
        
       
           
        
        
        
          α 
         
        
          1 
         
        
       
           
        
       
         . 
        
       
         . 
        
       
         . 
        
       
           
        
        
        
          α 
         
        
          D 
         
        
       
      
        \alpha_0 \ \alpha_1 \ ... \ \alpha_D 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.5806em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0037em;">α</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3011em;"><span class="" style="top: -2.55em; margin-left: -0.0037em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mspace"> </span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0037em;">α</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3011em;"><span class="" style="top: -2.55em; margin-left: -0.0037em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mspace"> </span><span class="mord">...</span><span class="mspace"> </span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0037em;">α</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3283em;"><span class="" style="top: -2.55em; margin-left: -0.0037em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0278em;">D</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>，那这个概率是作为一个权重乘上像素的图像特征。比如 feature <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         c 
        
       
      
        \bold{c} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.4444em;"></span><span class="mord mathbf">c</span></span></span></span></span> 是我们原本像素位置的图像特征，乘上对应权重之后从 2D 空间按照深度分布去做的特征转换映射，每一个像素点按射线去进行特征投影，把所有像素点都投影完之后其实就组成了我们所谓的 3D 空间，这个 3D 特征空间不仅有二维的图像特征，还包含有深度信息</p> 
<p>最后我们得到了一个叫做 3D 伪体素特征，那为什么叫做伪体素呢？那这个网格并不是按照我们原本输入点云的位置去划分网格的，而是按照深度去划分的网格，它是我们人为定义的一个体素，因此叫做“伪”体素</p> 
<p>通过这样的特征转换方式，我们可以把我们得到的 2D 图像特征通过离散深度分布得到 3D 伪体素特征，我们有了 3D 伪体素之后，按照高度维度，我们拍扁也好，或者利用卷积也好，池化也好投影到 BEV 空间我们就可以得到相机支路输出的核心内容了，那也就是我们所谓的 Camera BEV Feature 即相机俯视视角的特征</p> 
<p><img src="https://images2.imgbox.com/21/1a/tKUcoPlg_o.png" alt="在这里插入图片描述"></p> 
<p>有了上述分析后，我们再来总结下 <strong><font color="6C8EBF"><em>Camera Stream</em></font></strong> 整个流程，如上图所示。输入是 Multi-view Images 多视角图像，通过图像的 Encoder 编码器，图像编码器里面主要是包含两个模块，一个是 2D Backbone 也是就 2D 的主干网络，另一个是 FPN，也就是一个多尺度融合的方式，通过图像编码器后我们可以得到一个 Multi-view Features 多视角的图像特征，我们把图像特征通过我们之前讲的一个 2D➡3D 的转换模块可以映射到 BEV 上，那最终我们就能得到我们需要的图像特征构建出来的 BEV 空间。</p> 
<h4><a id="22__139"></a>2.2 点云支路</h4> 
<p>OK！我们再来看下 <strong><font color="FFCC99"><em>LiDAR Stream</em></font></strong> 点云支路是怎么做的</p> 
<p>其实相比于图像支路而言，点云支路要容易得多，因为点云本身就是 3D 的，我们只要通过我们前面得到的点云特征直接拍扁到 BEV，就可以得到 BEV 空间的点云特征，拍扁这个过程使用卷积、池化等等都可以</p> 
<p>那点云特征是怎么提取的呢，前面的 3D Backbone 是什么呢，我们在第二章中给大家讲过很多种，有基于点的方式的，也有基于体素的方式的，在 BEVFusion 文章中作者本身也提供了很多可选择的方案，包括 <a href="https://openaccess.thecvf.com/content_CVPR_2019/papers/Lang_PointPillars_Fast_Encoders_for_Object_Detection_From_Point_Clouds_CVPR_2019_paper.pdf" rel="nofollow"><em>PointPillars</em></a>、<a href="https://openaccess.thecvf.com/content/CVPR2021/papers/Yin_Center-Based_3D_Object_Detection_and_Tracking_CVPR_2021_paper.pdf" rel="nofollow"><em>CenterPoint</em></a>、<a href="https://arxiv.org/abs/2203.11496" rel="nofollow"><em>TransFusion</em></a></p> 
<p>这里我们会展开讲一个比较经典的 3D 点云特征提取网络，PointPillars</p> 
<p><img src="https://images2.imgbox.com/65/17/A7nyd6JG_o.png" alt="在这里插入图片描述"></p> 
<center> 
 <b>图5 PointPillars网络结构</b> 
</center> 
<p>上面就是 PointPillars 的原理框图，那 PointPillars 是怎么提取点云特征的呢？</p> 
<p>我们先理解下 pillar 是什么，pillar 翻译过来其实叫柱子，那这个词其实也是非常形象的，pillar 其实就是一个柱状空间，也就是图中黄色的区域，那这个柱状空间是干嘛用的呢，其实是聚合特征用的，我们之前讲过特征聚合，那比如点的方式，它是聚合我们关键点周围一定的球体空间，pillar 也是这个道理，它在柱状空间中囊括的点的特征是作为这个柱子的特征的，比如我们柱子中可能包含 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         N 
        
       
      
        N 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.109em;">N</span></span></span></span></span> 个点，假设每个点的特征是 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         D 
        
       
      
        D 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">D</span></span></span></span></span> 维，所以一个柱子特征表达就是 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         D 
        
       
         × 
        
       
         N 
        
       
      
        D\times N 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.7667em; vertical-align: -0.0833em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">D</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.109em;">N</span></span></span></span></span>，它代表每个柱子中有 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         N 
        
       
      
        N 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.109em;">N</span></span></span></span></span> 个点，每个点是 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         D 
        
       
      
        D 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">D</span></span></span></span></span> 维。那一个 3D 场景中有多少根柱子呢，我们假设有 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         P 
        
       
      
        P 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">P</span></span></span></span></span> 个柱子，那所以如果整个 3D 场景用柱子特征来表示就是 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         P 
        
       
         × 
        
       
         D 
        
       
         × 
        
       
         N 
        
       
      
        P\times D \times N 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.7667em; vertical-align: -0.0833em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">P</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.7667em; vertical-align: -0.0833em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">D</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.109em;">N</span></span></span></span></span>，其中 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         P 
        
       
      
        P 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">P</span></span></span></span></span> 代表我们 3D 场景中有 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         P 
        
       
      
        P 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">P</span></span></span></span></span> 个柱子，所以用 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         P 
        
       
         × 
        
       
         D 
        
       
         × 
        
       
         N 
        
       
      
        P\times D\times N 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.7667em; vertical-align: -0.0833em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">P</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.7667em; vertical-align: -0.0833em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">D</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.109em;">N</span></span></span></span></span> 这样的方式，我们就把完整的 3D 场景表示完了，用 pillar 的方式去进行表示。</p> 
<p>PointPillars 中默认 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         D 
        
       
      
        D 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">D</span></span></span></span></span> 是一个 9 维量，包含 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         x 
        
       
         , 
        
       
         y 
        
       
         , 
        
       
         z 
        
       
      
        x,y,z 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.1944em;"></span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord mathnormal" style="margin-right: 0.0359em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord mathnormal" style="margin-right: 0.044em;">z</span></span></span></span></span> 是我们点的坐标，<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          x 
         
        
          c 
         
        
       
         , 
        
        
        
          y 
         
        
          c 
         
        
       
         , 
        
        
        
          z 
         
        
          c 
         
        
       
      
        x_c,y_c,z_c 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.1944em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.1514em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0359em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.1514em;"><span class="" style="top: -2.55em; margin-left: -0.0359em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.044em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.1514em;"><span class="" style="top: -2.55em; margin-left: -0.044em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span> 是我们的点所在 pillar 的中心点坐标，<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          x 
         
        
          p 
         
        
       
         , 
        
        
        
          y 
         
        
          p 
         
        
       
      
        x_p,y_p 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.7167em; vertical-align: -0.2861em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.1514em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.2861em;"><span class=""></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0359em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.1514em;"><span class="" style="top: -2.55em; margin-left: -0.0359em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.2861em;"><span class=""></span></span></span></span></span></span></span></span></span></span> 是偏移量，是我们点距离柱子中心点的偏移量，还有一个反射值 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         r 
        
       
      
        r 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">r</span></span></span></span></span>，每一个点都是用这 9 维量来表示的</p> 
<blockquote> 
 <p><strong>为什么 PointPillars 不考虑 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
          
          
            z 
           
          
            p 
           
          
         
        
          z_p 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.7167em; vertical-align: -0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.044em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.1514em;"><span class="" style="top: -2.55em; margin-left: -0.044em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.2861em;"><span class=""></span></span></span></span></span></span></span></span></span></span>（z 方向的偏移量）呢</strong>？🤔</p> 
 <p>PointPillars 主要用于处理从地面车辆（如自动驾驶汽车）收集的点云数据。在这类应用中，z 方向（垂直于地面）的变化通常不如 x 和 y 方向（水平方向）那么显著或重要。因此，z 方向的偏移量 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
         
         
           z 
          
         
           p 
          
         
        
       
         z_p 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.7167em; vertical-align: -0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.044em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.1514em;"><span class="" style="top: -2.55em; margin-left: -0.044em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.2861em;"><span class=""></span></span></span></span></span></span></span></span></span></span> 可能被认为对模型的性能影响不大，而忽略它可以简化模型并减少计算需求。另一个可能的原因是在垂直方向上，点云数据可能展示出不同的分布特性，使得直接使用 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
         
         
           z 
          
         
           p 
          
         
        
       
         z_p 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.7167em; vertical-align: -0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.044em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.1514em;"><span class="" style="top: -2.55em; margin-left: -0.044em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.2861em;"><span class=""></span></span></span></span></span></span></span></span></span></span> 不如其他维度那么有效。</p> 
 <p><strong>反射值 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           r 
          
         
        
          r 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">r</span></span></span></span></span> 是什么呢</strong>？🤔</p> 
 <p>反射值 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          r 
         
        
       
         r 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">r</span></span></span></span></span> 是点云数据中的一个重要特征，它表示点云中每个点的反射强度。这个值通常由激光雷达（Lidar）传感器测量，反映了对象表面反射激光脉冲的能力。不同类型的物体和表面（如金属、塑料、植被等）会有不同的反射特性，因此反射值可用于辅助区分不同类型的物体和表面特性。在 3D 对象检测中，反射值可以帮助提高模型的准确性和鲁棒性。</p> 
</blockquote> 
<p><span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         P 
        
       
      
        P 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">P</span></span></span></span></span> 是场景中 pillar 的个数，一般是 12000，也就是说一个 3D 场景用 12000 个柱子囊括了，另外 pillar 内的点最多是 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         N 
        
       
      
        N 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.109em;">N</span></span></span></span></span> 个，<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         N 
        
       
      
        N 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.109em;">N</span></span></span></span></span> 一般是 100，所以通过这样的表示我们得到了 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         P 
        
       
         × 
        
       
         N 
        
       
         × 
        
       
         D 
        
       
      
        P\times N \times D 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.7667em; vertical-align: -0.0833em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">P</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.7667em; vertical-align: -0.0833em;"></span><span class="mord mathnormal" style="margin-right: 0.109em;">N</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">D</span></span></span></span></span> 也就是图中的 Stacked Pillars，然后我们会把 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         N 
        
       
         × 
        
       
         D 
        
       
      
        N\times D 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.7667em; vertical-align: -0.0833em;"></span><span class="mord mathnormal" style="margin-right: 0.109em;">N</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">D</span></span></span></span></span> 这个维度压缩到 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         C 
        
       
      
        C 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.0715em;">C</span></span></span></span></span> 维，我们就可以得到 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         P 
        
       
         × 
        
       
         C 
        
       
      
        P\times C 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.7667em; vertical-align: -0.0833em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">P</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.0715em;">C</span></span></span></span></span> 的图表征，<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         P 
        
       
         × 
        
       
         C 
        
       
      
        P\times C 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.7667em; vertical-align: -0.0833em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">P</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.0715em;">C</span></span></span></span></span> 是什么意思呢，我们其实刚讲过，<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         P 
        
       
      
        P 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">P</span></span></span></span></span> 代表一个 3D 场景中有多少个柱子，<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         C 
        
       
      
        C 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.0715em;">C</span></span></span></span></span> 其实是每一个柱子用 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         C 
        
       
      
        C 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.0715em;">C</span></span></span></span></span> 维向量去表示，所以用 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         P 
        
       
         × 
        
       
         C 
        
       
      
        P\times C 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.7667em; vertical-align: -0.0833em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">P</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.0715em;">C</span></span></span></span></span> 的方式我们其实就表征了一个 3D 场景，一个场景中有 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         P 
        
       
      
        P 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">P</span></span></span></span></span> 个柱子，每个柱子有 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         C 
        
       
      
        C 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.0715em;">C</span></span></span></span></span> 维向量</p> 
<p>接着我们再按照 pillar 的位置恢复到初始的空间当中，比如我们的 pillar 原本的采样空间它的 BEV 平面其实是一个 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         H 
        
       
         × 
        
       
         W 
        
       
      
        H\times W 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.7667em; vertical-align: -0.0833em;"></span><span class="mord mathnormal" style="margin-right: 0.0813em;">H</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">W</span></span></span></span></span> 的图，按照这个位置我们给它放回去得到最后的 Pseudo image 伪图，伪图的向量维度是 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         H 
        
       
         × 
        
       
         W 
        
       
         × 
        
       
         C 
        
       
      
        H\times W\times C 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.7667em; vertical-align: -0.0833em;"></span><span class="mord mathnormal" style="margin-right: 0.0813em;">H</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.7667em; vertical-align: -0.0833em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">W</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.0715em;">C</span></span></span></span></span>，那这个特征我们再熟悉不过了，图像特征都是这么表示的，当然这里的图像并不是我们真实意义上的图像，而是我们转换出来的，所以叫伪图，也就是 Pseudo image</p> 
<p>PointPillars 的输入输出是什么呢，输入是点云，输出是经过一系列柱子特征提取变换得到的一种形似图像特征的输出 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         H 
        
       
         × 
        
       
         W 
        
       
         × 
        
       
         C 
        
       
      
        H\times W\times C 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.7667em; vertical-align: -0.0833em;"></span><span class="mord mathnormal" style="margin-right: 0.0813em;">H</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.7667em; vertical-align: -0.0833em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">W</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.0715em;">C</span></span></span></span></span>，那这个输出有什么好处呢，当然我们后续可以用图像特征处理的方法来做，所以 PointPillars 中的 Backbone 我们叫做 2D CNN 网络，是一种图像处理的方式提取的特征然后去做检测</p> 
<p>我们再看另外一个问题，那这里的伪图还能叫什么呢，它其实就是我们所谓的这个 BEV 空间特征了，<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         H 
        
       
         × 
        
       
         W 
        
       
      
        H\times W 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.7667em; vertical-align: -0.0833em;"></span><span class="mord mathnormal" style="margin-right: 0.0813em;">H</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">W</span></span></span></span></span> 是我们 BEV 空间的尺寸，<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         C 
        
       
      
        C 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.0715em;">C</span></span></span></span></span> 其实是 BEV 空间每个位置上 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         C 
        
       
      
        C 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.0715em;">C</span></span></span></span></span> 维的特征向量，所以说 BEVFusion 在 <strong><font color="FFCC99"><em>LiDAR Stream</em></font></strong> 中引入的 <strong>LiDAR BEV Feature</strong> 也就是我们讲的伪图特征</p> 
<h4><a id="23_Fusion_176"></a>2.3 Fusion</h4> 
<p>OK，分析完了两个支路，我们再来梳理一下，图像支路得到的是 <strong>Camera BEV Features</strong>，点云支路得到的是 <strong>LiDAR BEV Features</strong>，除了两个额外的检测支路之外，下一步我们要做什么呢，那就是融合，也就是 Fusion Module 模块</p> 
<p><img src="https://images2.imgbox.com/be/25/ofz4xA6V_o.png" alt="在这里插入图片描述"></p> 
<p><em><strong>Fusion Module</strong></em> <strong>模块设计流程如下</strong>：</p> 
<ul><li><strong>输入</strong>：点云和图像 BEV 特征</li><li><strong>步骤 1</strong>：按通道维度级联点云和图像 BEV 特征，再通过卷积网络提取级联后的特征</li><li><strong>步骤 2</strong>：通过全局平均池化和卷积预测，实现对级联特征的自适应挑选</li><li><strong>输出</strong>：融合后的特征</li></ul> 
<p>Fusion Module 模块的输入输出是什么呢，我们一直在强调，输入包含两个，一个是图像输入 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          F 
         
         
         
           C 
          
         
           a 
          
         
           m 
          
         
           e 
          
         
           r 
          
         
           a 
          
         
        
       
      
        F_{Camera} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8333em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.1389em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3283em;"><span class="" style="top: -2.55em; margin-left: -0.1389em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0715em;">C</span><span class="mord mathnormal mtight">am</span><span class="mord mathnormal mtight" style="margin-right: 0.0278em;">er</span><span class="mord mathnormal mtight">a</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span> 一个是点云输入 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          F 
         
         
         
           L 
          
         
           i 
          
         
           D 
          
         
           A 
          
         
           R 
          
         
        
       
      
        F_{LiDAR} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8333em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.1389em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3283em;"><span class="" style="top: -2.55em; margin-left: -0.1389em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">L</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight" style="margin-right: 0.0278em;">D</span><span class="mord mathnormal mtight">A</span><span class="mord mathnormal mtight" style="margin-right: 0.0077em;">R</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>，那怎么融合呢，一个是级联一个是卷积就结束了，然后引入了一个叫 <em>Adaptive Feature Selection</em>，它其实是什么呢，其实就是一个 Attention，翻译过来叫做特征的自适应选择，那什么意思呢，其实就是注意力机制，我们在第二章的基础模块中讲过，所谓的注意力机制包括空间注意力、通道注意力、混合注意力还有 self-attention 等等，BEVFusion 中引入的 <em>Adaptive Feature Selection</em> 属于什么注意力偏向于什么层面的呢，它其实偏向通道层面，去对通道维度进行了加权，考虑的是哪个通道更重要，是点云上的通道呢，还是图像上的通道呢，通过这样一个权重的预测，对通道特征去进行重新的加权，我们从图中可以看到 ⊙ 是一个 Channel-wise 的，是一个通道的相乘，会关注一个重要的通道而忽略不重要的通道</p> 
<p>所以在这里融合模块其实可以一定程度上体现 BEVFusion 的作者在 Motivation 中阐述的一个想法，<strong>那就是点云和图像是没有主次之分的</strong>，可能对于这个场景而言，我们可能认为点云更重要，我们喜欢点云，可能对于下一个场景而言图像更重要，我们喜欢图像，那我们就多关注一点图像，那无论怎么做，它是一种网络自适应的过程，而不是说我们人为定义好了，比如我们就用点云或者就用图像，或者从点云到图像或者从图像到点云，它不是这么做的，它是一种自适应挑选的过程。那融合完成后，我们就可以得到融合特征，自然就可以用来做预测</p> 
<h3><a id="3__194"></a>3. 损失函数</h3> 
<p>OK！我们再来梳理下 BEVFusion</p> 
<p><img src="https://images2.imgbox.com/98/6f/p95dFYBD_o.png" alt="在这里插入图片描述"></p> 
<p>BEVFusion 的输入包含两个方面，一个是多视角的图像输入，还有一个是点云输入，输出对于 3D 检测任务而言是 3D 检测结果。输入图像怎么处理呢，通过 <strong><font color="6C8EBF"><em>Camera Stream</em></font></strong>，通过图像编码器 Encoder 我们可以得到图像特征，通过 2D 到 3D 的转换，图像特征可以映射到 BEV 空间，得到所谓的 <strong>Camera BEV Features</strong>，利用图像特征对 BEV 空间去进行重构。点云怎么处理呢，通过 <strong><font color="FFCC99"><em>LiDAR Stream</em></font></strong>，通过 3D Backbone 网络可以得到点云的 BEV 特征。那现在有了图像的 BEV 特征，有了点云的 BEV 特征，通过融合模块我们得到最终的特征，然后去做检测。</p> 
<p>那这里作者引入了两个额外的 Detection Head，像相机模态有一个相机的预测结果，点云模态有一个点云的预测结果，二者合在一起，融合模态有一个融合的预测结果，三个模态其实都有对应的 Loss</p> 
<p>另外我们前面提到还有一篇 BEVFusion，是 MIT 的工作，所以我们一般叫 MIT BEVFusion</p> 
<p><img src="https://images2.imgbox.com/ab/88/iMsJ75P2_o.png" alt="在这里插入图片描述"></p> 
<center> 
 <b>图7 BEVFusion-MIT</b> 
</center> 
<p>那这两篇工作属于同时期的工作，我们来看看这两篇文章的思路有什么异同点，那首先输入输出都区别吗，这篇文章的输入同样是多视角图像还有点云数据，那输出有一点点区别，除了 3D 检测任务之外，这篇工作中还引入了分割任务，那任务其实无关紧要，它只是一个额外连接的检测头罢了，任务预测基于的特征是一致的，叫做 Fused BEV Features，融合的 BEV 特征。</p> 
<p>那其实这两份工作思路是一致的，它都是通过分开提取特征再融合的方式得到融合后的 BEV 特征，其中 <strong><font color="6C8EBF"><em>Camera Stream</em></font></strong> 和 <strong><font color="FFCC99"><em>LiDAR Stream</em></font></strong> 的处理都是一致的，从思路上从框图上讲是完全一样的，有一点点区别的地方在于融合任务，MIT 额外引入了一个分割任务，另外希望大家注意到 BEVFusion-MIT 这篇文章中对单一模态没有特定的检测支路的，那到底需不需要这个额外的模块呢，那这是一个仁者见仁智者见智的事情，大家感兴趣的话也可以在 MIT 的工作基础上添加额外的检测头，看看结果会不会有什么变化</p> 
<p>另外想说的是 MIT 的工作其实更偏工程性一点，一些优化的讨论是更丰富的</p> 
<h3><a id="4__218"></a>4. 性能对比</h3> 
<p>OK，那我们看一下性能对比，性能对比是围绕我们讲解的 BEVFusion 展开的，而不是 MIT 的那篇工作</p> 
<p><img src="https://images2.imgbox.com/2a/17/ULhtuO2Y_o.png" alt="在这里插入图片描述"></p> 
<p>我们先来看总体结果，上表是不同算法在 nuScenes 验证集和测试集上的结果，可以看到和同时期的算法相比性能还是不错的，是有明显提升的</p> 
<p><img src="https://images2.imgbox.com/40/2e/xRgbSDBQ_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/f6/db/9XAvirlX_o.png" alt="在这里插入图片描述"></p> 
<p>前面只是一个总体性能，我们可以先不关注，我们重点看下消融实验部分，先看表 6，第一个叫做 BE，BEV Encoder 也就是 BEV 编码，也就是说作者不仅将图像特征拍扁了，还用了额外的特征提取，无非就是一些偏卷积的操作，它叫 BEV Encoder，那这个编码器其实提升非常大，mAP 是直接提高了四个点左右，足以说明 BEV Encoder 还是有必要的</p> 
<p>ADP 模块是我们之前讲过的特征金字塔部分中的一个上采样操作，那多尺度融合中的上采样和卷积模块提升比较小，只有 0.1，LP 叫 Large Backbone 就是一个更大的 Backbone 网络，那这个 Backbone 也有将近 4~5 个点的提升，所以说明这个暴力手法还是有用的，网络跃升提升还是非常明显的</p> 
<p>表 7 中的消融是对融合模块做的，CSF 全称 channel&amp; spatial fusion，就是通道和空间的融合，它其实就是把点云和图像特征合在一起之后去做一个卷积融合，这个操作提升还是挺多的。后面的 AFS 模块是我们之前讲的偏向通道 attention 的部分，那这一块也有一定提升</p> 
<p><img src="https://images2.imgbox.com/23/11/BGnQAGlT_o.png" alt="在这里插入图片描述"></p> 
<p>那这里作者为了验证 BEVFusion 的一个性能还提供了一些困难场景，一个是视场角限制，一个是点云丢失</p> 
<p>视场角限制是说比如我们只能获取到 -60° 到 +60° 的视场数据，那这个视场角外的数据是没有的，是第一种情况。第二种情况是说的数据丢失，物体的点云数据丢失，比如上图中的橘色框内是存在物体的，不过由于各种原因没有点云的反射值回传，也就是没有点云数据</p> 
<p>那在这两种情况下，BEVFusion 其实都可以检测到，很好理解，点云虽然丢失但图像还在，而且它们之间是没有主次关系的，哪个好用哪个，所以说在 BEVFusion 中我们即使点云丢失了，BEVFusion 也是可以去做检测的，因为我的图像内容还在。那像 TransFusion 这种更偏向于点云为基准的映射方案，那在点云数据有着明显缺少或者不准的情况下它的性能是自然有下降的</p> 
<p><img src="https://images2.imgbox.com/f0/2d/HEYOX9kc_o.png" alt="在这里插入图片描述"></p> 
<p>上面的表其实是我们刚提到的一种困难场景限制更明确的指标评价，那比如说在 -90° 到 +90° 这个视场角范围内，那 PointPillars 纯点云方案的 mAP 和 NDS 两个指标是 12.4 和 37.1，通过 BEVFusion 这种方式分别提高了 24.4 和 8.7 个点，能达到 36.8 和 45.8，后续的 CenterPoint 和 TransFusion 也是一样的对比思路。</p> 
<p>那 BEVFusion 这篇文章其实是一个非常好的多模态融合的范式，它涉及到的内容也非常全面，包括图像特征是怎么提取的，图像是怎么转换到 BEV 空间上的，点云特征是怎么提取的，点云是怎么转换到 BEV 空间上的，以及图像特征和点云特征通过什么样的方式去做融合，它们之间的注意力是怎么设计的，怎么挑选合适的图像特征和点云特征，那这都是非常基础也是非常好的范例，是非常值得大家的学习。</p> 
<h3><a id="_253"></a>总结</h3> 
<blockquote> 
 <p>这节课程我们学习了一种非常经典的多模态融合感知方案叫 BEVFusion，那 BEVFusion 的作者认为以往的多模态融合方式无论是 Point-level Fusion 还是 Feature level Fusion 都存在着严重的主次依赖关系，那作者是想尽可能的降低这种主次依赖关系对点云和图像分别进行处理在 BEV 空间上去做融合。因此 BEVFusion 的网络结构包含图像支路和点云支路两个部分，输入的多视角图像通过图像编码器得到图像特征，图像特征通过一个 2D 到 3D 的转换模块映射到 BEV 上得到我们所谓的 BEV Camera Feature；输入的点云通过点云特征提取网络得到 3D 点云特征，直接拍扁得到我们所谓的 BEV LiDAR Feature；那有了图像 BEV 特征和点云 BEV 特征之后我们通过一个融合模块得到我们最终的 BEV 特征，其中的融合模块是一个偏向通道层面的注意力机制。</p> 
 <p>OK，以上就是 BEVFusion 的全部内容了，下节我们进入 BEVFusion 的实战部分，敬请期待😄</p> 
</blockquote> 
<h3><a id="_259"></a>下载链接</h3> 
<ul><li><a href="https://pan.baidu.com/s/1QmH51czKVOyVDmD_m_n2CA" rel="nofollow">论文下载链接【提取码：6463】</a></li><li><a href="https://pan.baidu.com/s/1MS_A2-YRvFj1LsL85RuQiQ" rel="nofollow">数据集下载链接【提取码：data】</a></li></ul> 
<h3><a id="_264"></a>参考</h3> 
<ul><li>[1] <a href="https://arxiv.org/pdf/2205.13790.pdf" rel="nofollow">BEVFusion: A Simple and Robust LiDAR-Camera Fusion Framework</a></li><li>[2] <a href="https://arxiv.org/pdf/2205.13542.pdf" rel="nofollow">BEVFusion: Multi-Task Multi-Sensor Fusion with Unified Bird’s-Eye View Representation</a></li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/47ce31a6567b03f310c709126e5f2eb2/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">三. LiDAR和Camera融合的BEV感知算法-BEV-SAN</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/abb6f149f6035ca33e5125c632c9d21f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">三. LiDAR和Camera融合的BEV感知算法-BEVFusion实战</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>