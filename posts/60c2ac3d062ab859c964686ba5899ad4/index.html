<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>linux驱动 — 常用API - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="linux驱动 — 常用API" />
<meta property="og:description" content="一、设备树—API
①of_find_compatible_node 函数
②of_get_named_gpio 函数
③irq_of_parse_and_map 函数
二、GPIO—API
①gpio_request 函数
②gpio_free 函数
③gpio_direction_input 函数
④gpio_direction_output 函数
⑤gpio_is_valid 函数
⑥gpio_get_value 函数
⑦gpio_set_value 函数
三、中断—API
①request_irq 函数
②free_irq 函数
③enable_irq()与disable_irq()函数
四、Pinctrl—API ①devm_pinctrl_get 函数
②devm_pinctrl_put 函数
③pinctrl_lookup_state 函数
④pinctrl_select_state函数
inux驱动开发，首先从使用驱动的API开始，先会使用API，然后才能更深入的分析，本篇所列的都是驱动开发中非常常用的API，之所以从设备树API开始，是本人觉得驱动开发的源头在设备树，并且大部分驱动都跟设备树相关。
一、设备树—API ①of_find_compatible_node 函数 of_find_compatible_node 函数根据 device_type 和 compatible 这两个属性查找指定的节点， 函数原型如下： struct device_node *of_find_compatible_node(struct device_node,*from, const char *type,
const char *compatible) 函数参数和返回值含义如下： from：开始查找的节点，如果为 NULL 表示从根节点开始查找整个设备树。 type：要查找的节点对应的 type 字符串，也就是 device_type 属性值，可以为 NULL，表示忽略掉 device_type 属性。 compatible：要查找的节点所对应的 compatible 属性列表。 返回值：找到的节点，如果为 NULL 表示查找失败 ②of_get_named_gpio 函数 此函数获取 GPIO 编号，因为 Linux 内核中关于 GPIO 的 API 函数都要使用 GPIO 编号，此函数会将设备树中类似&lt;&amp;gpio5 7 GPIO_ACTIVE_LOW&gt;的属性信息转换为对应的 GPIO 编号，此函数在驱动中使用很频繁！函数原型如下： int of_get_named_gpio(struct device_node *np, const char *propname, int index) 函数参数和返回值含义如下： np：设备节点。 propname：包含要获取 GPIO 信息的属性名。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/60c2ac3d062ab859c964686ba5899ad4/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-10-08T14:58:04+08:00" />
<meta property="article:modified_time" content="2021-10-08T14:58:04+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">linux驱动 — 常用API</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="%E4%B8%80%E3%80%81%E8%AE%BE%E5%A4%87%E6%A0%91%E2%80%94API-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%E8%AE%BE%E5%A4%87%E6%A0%91%E2%80%94API" rel="nofollow" title="一、设备树—API">一、设备树—API</a></p> 
<p id="%E2%91%A0of_find_compatible_node%20%E5%87%BD%E6%95%B0-toc" style="margin-left:40px;"><a href="#%E2%91%A0of_find_compatible_node%20%E5%87%BD%E6%95%B0" rel="nofollow" title="①of_find_compatible_node 函数">①of_find_compatible_node 函数</a></p> 
<p id="%E2%91%A1of_get_named_gpio%20%E5%87%BD%E6%95%B0-toc" style="margin-left:40px;"><a href="#%E2%91%A1of_get_named_gpio%20%E5%87%BD%E6%95%B0" rel="nofollow" title="②of_get_named_gpio 函数">②of_get_named_gpio 函数</a></p> 
<p id="%E2%91%A2irq_of_parse_and_map%20%E5%87%BD%E6%95%B0-toc" style="margin-left:40px;"><a href="#%E2%91%A2irq_of_parse_and_map%20%E5%87%BD%E6%95%B0" rel="nofollow" title="③irq_of_parse_and_map 函数">③irq_of_parse_and_map 函数</a></p> 
<p id="%E4%BA%8C%E3%80%81GPIO%E2%80%94API-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81GPIO%E2%80%94API" rel="nofollow" title="二、GPIO—API">二、GPIO—API</a></p> 
<p id="%E2%91%A0gpio_request%20%E5%87%BD%E6%95%B0-toc" style="margin-left:40px;"><a href="#%E2%91%A0gpio_request%20%E5%87%BD%E6%95%B0" rel="nofollow" title="①gpio_request 函数">①gpio_request 函数</a></p> 
<p id="%E2%91%A1gpio_free%20%E5%87%BD%E6%95%B0-toc" style="margin-left:40px;"><a href="#%E2%91%A1gpio_free%20%E5%87%BD%E6%95%B0" rel="nofollow" title="②gpio_free 函数">②gpio_free 函数</a></p> 
<p id="%E2%91%A2gpio_direction_input%20%E5%87%BD%E6%95%B0-toc" style="margin-left:40px;"><a href="#%E2%91%A2gpio_direction_input%20%E5%87%BD%E6%95%B0" rel="nofollow" title="③gpio_direction_input 函数">③gpio_direction_input 函数</a></p> 
<p id="%E2%91%A3gpio_direction_output%20%E5%87%BD%E6%95%B0-toc" style="margin-left:40px;"><a href="#%E2%91%A3gpio_direction_output%20%E5%87%BD%E6%95%B0" rel="nofollow" title="④gpio_direction_output 函数">④gpio_direction_output 函数</a></p> 
<p id="%E2%91%A4gpio_is_valid%C2%A0%E5%87%BD%E6%95%B0-toc" style="margin-left:40px;"><a href="#%E2%91%A4gpio_is_valid%C2%A0%E5%87%BD%E6%95%B0" rel="nofollow" title="⑤gpio_is_valid 函数">⑤gpio_is_valid 函数</a></p> 
<p id="%E2%91%A4gpio_get_value%20%E5%87%BD%E6%95%B0-toc" style="margin-left:40px;"><a href="#%E2%91%A4gpio_get_value%20%E5%87%BD%E6%95%B0" rel="nofollow" title="⑥gpio_get_value 函数">⑥gpio_get_value 函数</a></p> 
<p id="%E2%91%A5gpio_set_value%20%E5%87%BD%E6%95%B0-toc" style="margin-left:40px;"><a href="#%E2%91%A5gpio_set_value%20%E5%87%BD%E6%95%B0" rel="nofollow" title="⑦gpio_set_value 函数">⑦gpio_set_value 函数</a></p> 
<p id="%E4%B8%89%E3%80%81%E4%B8%AD%E6%96%AD%E2%80%94API-toc" style="margin-left:0px;"><a href="#%E4%B8%89%E3%80%81%E4%B8%AD%E6%96%AD%E2%80%94API" rel="nofollow" title="三、中断—API">三、中断—API</a></p> 
<p id="%E2%91%A0request_irq%20%E5%87%BD%E6%95%B0-toc" style="margin-left:40px;"><a href="#%E2%91%A0request_irq%20%E5%87%BD%E6%95%B0" rel="nofollow" title="①request_irq 函数">①request_irq 函数</a></p> 
<p id="%E2%91%A1free_irq%20%E5%87%BD%E6%95%B0-toc" style="margin-left:40px;"><a href="#%E2%91%A1free_irq%20%E5%87%BD%E6%95%B0" rel="nofollow" title="②free_irq 函数">②free_irq 函数</a></p> 
<p id="%E2%91%A2enable_irq()%E4%B8%8Edisable_irq()%E5%87%BD%E6%95%B0-toc" style="margin-left:40px;"><a href="#%E2%91%A2enable_irq%28%29%E4%B8%8Edisable_irq%28%29%E5%87%BD%E6%95%B0" rel="nofollow" title="③enable_irq()与disable_irq()函数">③enable_irq()与disable_irq()函数</a></p> 
<p id="%E5%9B%9B%E3%80%81Pinctrl%E2%80%94API%C2%A0-toc" style="margin-left:0px;"><a href="#%E5%9B%9B%E3%80%81Pinctrl%E2%80%94API%C2%A0" rel="nofollow" title="四、Pinctrl—API ">四、Pinctrl—API </a></p> 
<p id="%E2%91%A0devm_pinctrl_get%C2%A0%E5%87%BD%E6%95%B0-toc" style="margin-left:40px;"><a href="#%E2%91%A0devm_pinctrl_get%C2%A0%E5%87%BD%E6%95%B0" rel="nofollow" title="①devm_pinctrl_get 函数">①devm_pinctrl_get 函数</a></p> 
<p id="%E2%91%A1devm_pinctrl_put%C2%A0%E5%87%BD%E6%95%B0-toc" style="margin-left:40px;"><a href="#%E2%91%A1devm_pinctrl_put%C2%A0%E5%87%BD%E6%95%B0" rel="nofollow" title="②devm_pinctrl_put 函数">②devm_pinctrl_put 函数</a></p> 
<p id="%E2%91%A2pinctrl_lookup_state%C2%A0%E5%87%BD%E6%95%B0-toc" style="margin-left:40px;"><a href="#%E2%91%A2pinctrl_lookup_state%C2%A0%E5%87%BD%E6%95%B0" rel="nofollow" title="③pinctrl_lookup_state 函数">③pinctrl_lookup_state 函数</a></p> 
<p id="%E2%91%A3pinctrl_select_state%E5%87%BD%E6%95%B0-toc" style="margin-left:40px;"><a href="#%E2%91%A3pinctrl_select_state%E5%87%BD%E6%95%B0" rel="nofollow" title="④pinctrl_select_state函数">④pinctrl_select_state函数</a></p> 
<hr id="hr-toc"> 
<p style="margin-left:40px;">inux驱动开发，首先从使用驱动的API开始，先会使用API，然后才能更深入的分析，本篇所列的都是驱动开发中非常常用的API，之所以从设备树API开始，是本人觉得驱动开发的源头在设备树，并且大部分驱动都跟设备树相关。</p> 
<h2 id="%E4%B8%80%E3%80%81%E8%AE%BE%E5%A4%87%E6%A0%91%E2%80%94API" style="margin-left:.0001pt;text-align:left;">一、设备树—API</h2> 
<h3 id="%E2%91%A0of_find_compatible_node%20%E5%87%BD%E6%95%B0" style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#000000;"><strong>①of_find_compatible_node </strong></span></strong><strong><span style="color:#000000;"><strong>函数 </strong></span></strong></h3> 
<blockquote> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">of_find_compatible_node </span><span style="color:#000000;">函数根据 </span><span style="color:#000000;">device_type </span><span style="color:#000000;">和 </span><span style="color:#000000;">compatible </span><span style="color:#000000;">这两个属性查找指定的节点， 函数原型如下： </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">struct device_node *of_find_compatible_node(struct device_node</span><span style="color:#000000;">,</span><span style="color:#000000;">*from, const char *type,</span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;"> const char *compatible) </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">函数参数和返回值含义如下： </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#000000;"><strong>from</strong></span></strong><span style="color:#000000;">：开始查找的节点，如果为 </span><span style="color:#000000;">NULL </span><span style="color:#000000;">表示从根节点开始查找整个设备树。 </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#000000;"><strong>type</strong></span></strong><span style="color:#000000;">：要查找的节点对应的 </span><span style="color:#000000;">type </span><span style="color:#000000;">字符串，也就是 </span><span style="color:#000000;">device_type </span><span style="color:#000000;">属性值，可以为 </span><span style="color:#000000;">NULL</span><span style="color:#000000;">，表示忽略掉 </span><span style="color:#000000;">device_type </span><span style="color:#000000;">属性。 </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#000000;"><strong>compatible</strong></span></strong><strong><span style="color:#000000;"><strong>：</strong></span></strong><span style="color:#000000;">要查找的节点所对应的 </span><span style="color:#000000;">compatible </span><span style="color:#000000;">属性列表。 </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#000000;"><strong>返回值：</strong></span></strong><span style="color:#000000;">找到的节点，如果为 </span><span style="color:#000000;">NULL </span><span style="color:#000000;">表示查找失败 </span></p> 
</blockquote> 
<p style="margin-left:.0001pt;text-align:left;"></p> 
<h3 id="%E2%91%A1of_get_named_gpio%20%E5%87%BD%E6%95%B0" style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#000000;"><strong>②of_get_named_gpio </strong></span></strong><strong><span style="color:#000000;"><strong>函数 </strong></span></strong></h3> 
<blockquote> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">此函数获取 </span><span style="color:#000000;">GPIO </span><span style="color:#000000;">编号，因为 </span><span style="color:#000000;">Linux </span><span style="color:#000000;">内核中关于 </span><span style="color:#000000;">GPIO </span><span style="color:#000000;">的 </span><span style="color:#000000;">API </span><span style="color:#000000;">函数都要使用 </span><span style="color:#000000;">GPIO </span><span style="color:#000000;">编号，此函数会将设备树中类似</span><span style="color:#000000;">&lt;&amp;gpio5 7 GPIO_ACTIVE_LOW&gt;</span><span style="color:#000000;">的属性信息转换为对应的 </span><span style="color:#000000;">GPIO </span><span style="color:#000000;">编号，此函数在驱动中使用很频繁！函数原型如下： </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">int of_get_named_gpio(struct device_node *np, const char *propname, int index) </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">函数参数和返回值含义如下： </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#000000;"><strong>np</strong></span></strong><span style="color:#000000;">：设备节点。 </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#000000;"><strong>propname</strong></span></strong><span style="color:#000000;">：包含要获取 </span><span style="color:#000000;">GPIO </span><span style="color:#000000;">信息的属性名。</span></p> 
</blockquote> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<h3 id="%E2%91%A2irq_of_parse_and_map%20%E5%87%BD%E6%95%B0" style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#000000;"><strong>③irq_of_parse_and_map </strong></span></strong><strong><span style="color:#000000;"><strong>函数</strong></span></strong></h3> 
<blockquote> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">编写驱动的时候需要用到中断号，我们用到中断号，中断信息已经写到了设备树里面，因 </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">此可以通过 </span><span style="color:#000000;">irq_of_parse_and_map </span><span style="color:#000000;">函数从 </span><span style="color:#000000;">interupts </span><span style="color:#000000;">属性中提取到对应的设备号，函数原型如下： </span><span style="color:#000000;">unsigned int irq_of_parse_and_map(struct device_node *dev, int index) </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">函数参数和返回值含义如下： </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#000000;"><strong>dev</strong></span></strong><strong><span style="color:#000000;"><strong>：</strong></span></strong><span style="color:#000000;">设备节点。 </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#000000;"><strong>index</strong></span></strong><span style="color:#000000;">：索引号，</span><span style="color:#000000;">interrupts </span><span style="color:#000000;">属性可能包含多条中断信息，通过 </span><span style="color:#000000;">index </span><span style="color:#000000;">指定要获取的信息。 </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">返回值：中断号。 </span></p> 
</blockquote> 
<p style="margin-left:.0001pt;text-align:left;"></p> 
<p id="%E7%A4%BA%E4%BE%8B" style="margin-left:.0001pt;text-align:left;">示例</p> 
<pre><code>//设备树节点
&amp;misc {
    compatible = "misc,test";    
    interrupt-parent = &lt;&amp;pio&gt;;
	interrupts = &lt;8 IRQ_TYPE_EDGE_FALLING&gt;;
	test-gpio = &lt;&amp;pio 30 0&gt;;
};

//API使用示例
//获取指定节点，获取不到时返回NULL
struct device_node *nd = of_find_compatible_node(NULL, NULL, "misc,test");

//获取GPIO编号，获取不到时返回负值
int test_gpio = of_get_named_gpio(nd, "test-gpio", 0);

//获取中断号，获取不到时返回负值
static unsigned int tp_irq = irq_of_parse_and_map(nd, 0);

...
</code></pre> 
<p style="margin-left:.0001pt;text-align:left;"></p> 
<h2 id="%E4%BA%8C%E3%80%81GPIO%E2%80%94API" style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#000000;"><strong>二、GPIO—API</strong></span></strong></h2> 
<h3 id="%E2%91%A0gpio_request%20%E5%87%BD%E6%95%B0" style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#000000;"><strong>①gpio_request </strong></span></strong><strong><span style="color:#000000;"><strong>函数 </strong></span></strong></h3> 
<blockquote> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">gpio_request </span><span style="color:#000000;">函数用于申请一个 </span><span style="color:#000000;">GPIO </span><span style="color:#000000;">管脚，在使用一个 </span><span style="color:#000000;">GPIO </span><span style="color:#000000;">之前一定要使用 </span><span style="color:#000000;">gpio_request </span><span style="color:#000000;">进行申请</span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">函数原型如下： </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">int gpio_request(unsigned gpio, const char *label) </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">函数参数和返回值含义如下： </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#000000;"><strong>gpio</strong></span></strong><span style="color:#000000;">：要申请的 </span><span style="color:#000000;">gpio </span><span style="color:#000000;">标号，使用 </span><span style="color:#000000;">of_get_named_gpio </span><span style="color:#000000;">函数从设备树获取指定 </span><span style="color:#000000;">GPIO </span><span style="color:#000000;">属性信息，此函数会返回这个 </span><span style="color:#000000;">GPIO </span><span style="color:#000000;">的标号。 </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#000000;"><strong>label</strong></span></strong><span style="color:#000000;">：给 </span><span style="color:#000000;">gpio </span><span style="color:#000000;">设置个名字。 </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#000000;"><strong>返回值：</strong></span></strong><span style="color:#000000;">0</span><span style="color:#000000;">，申请成功；其他值，申请失败。</span></p> 
</blockquote> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<h3 id="%E2%91%A1gpio_free%20%E5%87%BD%E6%95%B0" style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#000000;"><strong>②gpio_free </strong></span></strong><strong><span style="color:#000000;"><strong>函数 </strong></span></strong></h3> 
<blockquote> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">如果不使用某个 </span><span style="color:#000000;">GPIO </span><span style="color:#000000;">了，那么就可以调用 </span><span style="color:#000000;">gpio_free </span><span style="color:#000000;">函数进行释放。函数原型如下： </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">void gpio_free(unsigned gpio) </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">函数参数和返回值含义如下： </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#000000;"><strong>gpio</strong></span></strong><span style="color:#000000;">：要释放的 </span><span style="color:#000000;">gpio </span><span style="color:#000000;">标号。 </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#000000;"><strong>返回值：</strong></span></strong><span style="color:#000000;">无。 </span></p> 
</blockquote> 
<p style="margin-left:.0001pt;text-align:left;"></p> 
<h3 id="%E2%91%A2gpio_direction_input%20%E5%87%BD%E6%95%B0" style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#000000;"><strong>③gpio_direction_input </strong></span></strong><strong><span style="color:#000000;"><strong>函数 </strong></span></strong></h3> 
<blockquote> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">此函数用于设置某个 </span><span style="color:#000000;">GPIO </span><span style="color:#000000;">为输入，函数原型如下所示： </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">int gpio_direction_input(unsigned gpio) </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">函数参数和返回值含义如下： </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#000000;"><strong>gpio</strong></span></strong><span style="color:#000000;">：要设置为输入的 </span><span style="color:#000000;">GPIO </span><span style="color:#000000;">标号。 </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#000000;"><strong>返回值：</strong></span></strong><span style="color:#000000;">0</span><span style="color:#000000;">，设置成功；负值，设置失败。</span></p> 
</blockquote> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<h3 id="%E2%91%A3gpio_direction_output%20%E5%87%BD%E6%95%B0" style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#000000;"><strong>④gpio_direction_output </strong></span></strong><strong><span style="color:#000000;"><strong>函数 </strong></span></strong></h3> 
<blockquote> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">此函数用于设置某个 </span><span style="color:#000000;">GPIO </span><span style="color:#000000;">为输出，并且设置默认输出值，函数原型如下： </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">int gpio_direction_output(unsigned gpio, int value) </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">函数参数和返回值含义如下： </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#000000;"><strong>gpio</strong></span></strong><span style="color:#000000;">：要设置为输出的 </span><span style="color:#000000;">GPIO </span><span style="color:#000000;">标号。 </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#000000;"><strong>value</strong></span></strong><strong><span style="color:#000000;"><strong>：</strong></span></strong><span style="color:#000000;">GPIO </span><span style="color:#000000;">默认输出值。 </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#000000;"><strong>返回值：</strong></span></strong><span style="color:#000000;">0</span><span style="color:#000000;">，设置成功；负值，设置失败。</span></p> 
</blockquote> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<h3 id="%E2%91%A4gpio_is_valid%C2%A0%E5%87%BD%E6%95%B0" style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#000000;"><strong>⑤gpio_is_valid</strong></span> </strong><strong><span style="color:#000000;"><strong>函数 </strong></span></strong></h3> 
<blockquote> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">检测gpio端口是否合法，函数原型如下：</span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">i</span><span style="color:#000000;">nt</span> <span style="color:#000000;">gpio_is_valid(int</span> <span style="color:#000000;">number); </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">函数参数和返回值含义如下：</span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#000000;"><strong>n</strong></span></strong><strong><span style="color:#000000;"><strong>umber</strong></span></strong><strong><span style="color:#000000;"><strong>：</strong></span></strong><span style="color:#000000;">gpio</span><span style="color:#000000;">端口号</span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#000000;"><strong>返回值：</strong></span></strong><span style="color:#000000;">无效反为0</span></p> 
</blockquote> 
<p style="margin-left:.0001pt;text-align:left;"></p> 
<h3 id="%E2%91%A4gpio_get_value%20%E5%87%BD%E6%95%B0" style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#000000;"><strong>⑥gpio_get_value 函数 </strong></span></strong></h3> 
<blockquote> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">此函数用于获取某个 </span><span style="color:#000000;">GPIO </span><span style="color:#000000;">的值</span><span style="color:#000000;">(0 </span><span style="color:#000000;">或 </span><span style="color:#000000;">1)</span><span style="color:#000000;">，此函数是个宏，定义所示： </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">#define gpio_get_value __gpio_get_value </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">int __gpio_get_value(unsigned gpio) </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">函数参数和返回值含义如下：</span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#000000;"><strong>gpio</strong></span></strong><span style="color:#000000;">：要获取的 </span><span style="color:#000000;">GPIO </span><span style="color:#000000;">标号。 </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#000000;"><strong>返回值：</strong></span></strong><span style="color:#000000;">非负值，得到的 </span><span style="color:#000000;">GPIO </span><span style="color:#000000;">值；负值，获取失败。</span></p> 
</blockquote> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<h3 id="%E2%91%A5gpio_set_value%20%E5%87%BD%E6%95%B0" style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#000000;"><strong>⑦gpio_set_value </strong></span></strong><strong><span style="color:#000000;"><strong>函数 </strong></span></strong></h3> 
<blockquote> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">此函数用于设置某个 </span><span style="color:#000000;">GPIO </span><span style="color:#000000;">的值，此函数是个宏，定义如下 </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">#define gpio_set_value __gpio_set_value </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">void __gpio_set_value(unsigned gpio, int value) </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">函数参数和返回值含义如下： </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#000000;"><strong>gpio</strong></span></strong><span style="color:#000000;">：要设置的 </span><span style="color:#000000;">GPIO </span><span style="color:#000000;">标号。 </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#000000;"><strong>value</strong></span></strong><strong><span style="color:#000000;"><strong>：</strong></span></strong><span style="color:#000000;">要设置的值。 </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#000000;"><strong>返回值：</strong></span></strong><span style="color:#000000;">无 </span></p> 
</blockquote> 
<p style="margin-left:.0001pt;text-align:left;"></p> 
<p style="margin-left:.0001pt;text-align:left;">示例</p> 
<pre><code>//设备树节点
&amp;misc {
    compatible = "misc,test";    
    interrupt-parent = &lt;&amp;pio&gt;;
	interrupts = &lt;8 IRQ_TYPE_EDGE_FALLING&gt;;
	test-gpio = &lt;&amp;pio 30 0&gt;;
};

//API使用示例
//获取指定节点，获取不到时返回NULL
struct device_node *nd = of_find_compatible_node(NULL, NULL, "misc,test");

//获取GPIO编号，获取不到时返回负值
int test_gpio = of_get_named_gpio(nd, "test-gpio", 0);
/
/
//设置gpio为输出，同时设置输出寄存器为0，即低电平
int val = gpio_direction_output(test_gpio, 0);

//获取gpio状态，高低电平(0或1)
int status = gpio_get_value(test_gpio);

//设置gpio输出寄存器为1，即高电平
gpio_set_value（test_gpio, 1）;

//读写操作可能导致睡眠，在中断中就需要使用带cansleep的函数
//gpio_get_value_cansleep(test_gpio);
//gpio_set_value_cansleep(test_gpio, 1);

//设置gpio为输入
gpio_direction_input(test_gpio);

...
</code></pre> 
<p style="margin-left:.0001pt;text-align:left;"></p> 
<h2 id="%E4%B8%89%E3%80%81%E4%B8%AD%E6%96%AD%E2%80%94API" style="margin-left:.0001pt;text-align:left;">三、中断—API</h2> 
<p style="margin-left:.0001pt;text-align:left;"></p> 
<h3 id="%E2%91%A0request_irq%20%E5%87%BD%E6%95%B0" style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#000000;"><strong>①request_irq </strong></span></strong><strong><span style="color:#000000;"><strong>函数 </strong></span></strong></h3> 
<blockquote> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">在 Linux </span><span style="color:#000000;">内核中要想使用某个中断是需要申请的，</span><span style="color:#000000;">request_irq </span><span style="color:#000000;">函数用于申请中断，</span><span style="color:#000000;">request_irq</span> <span style="color:#000000;">函数可能会导致睡眠，因此不能在中断上下文或者其他禁止睡眠的代码段中使用 </span><span style="color:#000000;">request_irq </span><span style="color:#000000;">函数。</span><span style="color:#000000;">request_irq </span><span style="color:#000000;">函数会激活</span><span style="color:#000000;">(</span><span style="color:#000000;">使能</span><span style="color:#000000;">)中断，所以不需要我们手动去使能中断</span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">request_irq </span><span style="color:#000000;">函数原型如下： </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">int request_irq(unsigned int irq, irq_handler_t handler, unsigned long flags, const char *name, </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">void *dev) </span><span style="color:#000000;">函数参数和返回值含义如下： </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#000000;"><strong>irq</strong></span></strong><span style="color:#000000;">：要申请中断的中断号。 </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#000000;"><strong>handler</strong></span></strong><span style="color:#000000;">：中断处理函数，当中断发生以后就会执行此中断处理函数。 </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#000000;"><strong>flags</strong></span></strong><span style="color:#000000;">：中断标志，可以在文件 </span><span style="color:#000000;">include/linux/interrupt.h </span><span style="color:#000000;">里面查看所有的中断标志</span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#000000;"><strong>name</strong></span></strong><span style="color:#000000;">：中断名字，设置以后可以在</span><span style="color:#000000;">/proc/interrupts </span><span style="color:#000000;">文件中看到对应的中断名字。 </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#000000;"><strong>dev</strong></span></strong><strong><span style="color:#000000;"><strong>：</strong></span></strong><span style="color:#000000;">如果将 </span><span style="color:#000000;">flags </span><span style="color:#000000;">设置为 </span><span style="color:#000000;">IRQF_SHARED </span><span style="color:#000000;">的话，</span><span style="color:#000000;">dev </span><span style="color:#000000;">用来区分不同的中断，一般情况下将</span><span style="color:#000000;">dev </span><span style="color:#000000;">设置为设备结构体，</span><span style="color:#000000;">dev </span><span style="color:#000000;">会传递给中断处理函数 </span><span style="color:#000000;">irq_handler_t </span><span style="color:#000000;">的第二个参数。 </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#000000;"><strong>返回值：</strong></span></strong><span style="color:#000000;">0 </span><span style="color:#000000;">中断申请成功，其他负值 中断申请失败，如果返回</span><span style="color:#000000;">-EBUSY </span><span style="color:#000000;">的话表示中断已经 </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">被申请了。 </span></p> 
</blockquote> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<h3 id="%E2%91%A1free_irq%20%E5%87%BD%E6%95%B0" style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#000000;"><strong>②free_irq 函数</strong></span></strong></h3> 
<blockquote> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#0000ff;">void</span><span style="color:#000000;"> free_irq(unsigned </span><span style="color:#0000ff;">int</span><span style="color:#000000;"> irq, </span><span style="color:#0000ff;">void</span><span style="color:#000000;"> *dev_id)</span></p> 
 <p style="margin-left:0;text-align:left;"><span style="background-color:#ffffff;"><span style="background-color:#ffffff;"><span style="color:#000000;">关于该函数参数的一些说明如下：</span></span></span></p> 
 <ul><li style="text-align:left;"><span style="background-color:#ffffff;"><span style="color:#000000;">irq参数是已经申请的硬件中断号；</span></span></li><li style="text-align:left;"><span style="background-color:#ffffff;"><span style="color:#000000;">dev_id参数和request_irq()函数的dev参数对应，一般为设备的设备结构体或者</span></span> <span style="background-color:#ffffff;"><span style="color:#000000;">NULL。</span></span></li></ul> 
</blockquote> 
<p style="margin-left:.0001pt;text-align:left;"></p> 
<h3 id="%E2%91%A2enable_irq()%E4%B8%8Edisable_irq()%E5%87%BD%E6%95%B0" style="margin-left:.0001pt;text-align:left;">③<span style="background-color:#ffffff;"><span style="color:#000000;">enable_irq()与disable_irq()函数</span></span></h3> 
<blockquote> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;"><span style="color:#000000;">在Linux设备驱动中断编程中，如果想要使能或者屏蔽中断的话，可以使用enable_irq()和disable_irq()内核函数接口。</span></span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;"><span style="color:#000000;">使能中断IRQ，可以使用enable_irq()函数接口，该函数的定义如下：</span></span></p> 
 <pre><code class="language-cpp">void enable_irq(unsigned int irq)
{
    unsigned long flags;
    struct irq_desc *desc = irq_get_desc_buslock(irq, &amp;flags,
    IRQ_GET_DESC_CHECK_GLOBAL);

    if (!desc)
        return;

    if (WARN(!desc-&gt;irq_data.chip, \
        KERN_ERR"enable_irq before setup/request_irq: irq %u\n", irq))
        goto out;

    __enable_irq(desc);
out:
    irq_put_desc_busunlock(desc, flags);
}</code></pre> 
 <p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;">屏蔽中断IRQ，可以使用disable_irq()和disable_irq_nosync()函数，这两个函数的定义如下：</span></span></p> 
 <pre><code>void disable_irq(unsigned int irq)
{
    if (!__disable_irq_nosync(irq))
        synchronize_irq(irq);
}

void disable_irq_nosync(unsigned int irq)
{
    __disable_irq_nosync(irq);
}
</code></pre> 
 <p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;">两个函数的形参都是irq，表示要屏蔽中断的硬件中断号，这两个函数的区别在于，disable_irq()函数会等待目前的中断处理完成，而disable_irq_nosync()函数则不会等待。</span></span></p> 
</blockquote> 
<p id="%E7%A4%BA%E4%BE%8B%EF%BC%9A" style="margin-left:.0001pt;text-align:left;">示例：</p> 
<pre><code>//设备树节点
&amp;misc {
    compatible = "misc,test";    
    interrupt-parent = &lt;&amp;pio&gt;;
	interrupts = &lt;8 IRQ_TYPE_EDGE_FALLING&gt;;
	test-gpio = &lt;&amp;pio 30 0&gt;;
};

//API使用示例
//获取指定节点，获取不到时返回NULL
struct device_node *nd = of_find_compatible_node(NULL, NULL, "misc,test");

//获取GPIO编号，获取不到时返回负值
int test_gpio = of_get_named_gpio(nd, "test-gpio", 0);

//获取中断号，获取不到时返回负值
static unsigned int tp_irq = irq_of_parse_and_map(nd, 0);

//申请一个 GPIO ，使用前需要向系统申请一下，别人就用不能用了
gpio_request(test_gpio, "test_gpio");

//申请中断，同时注册test_interrupt_handler为回调函数
int ret = request_irq(tp_irq, (irq_handler_t) test_interrupt_handler, IRQF_TRIGGER_FALLING, "test-eint", NULL);

...

</code></pre> 
<p style="margin-left:.0001pt;text-align:left;"></p> 
<h2 id="%E5%9B%9B%E3%80%81Pinctrl%E2%80%94API%C2%A0" style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#000000;"><strong>四、Pinctrl—API </strong></span></strong></h2> 
<h3 id="%E2%91%A0devm_pinctrl_get%C2%A0%E5%87%BD%E6%95%B0" style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#000000;"><strong>①devm_pinctrl_get 函数</strong></span></strong></h3> 
<blockquote> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">struct pinctrl * devm_pinctrl_get(struct device *dev); </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">函数功能：根据设备获取pin操作句柄，所有的pin操作必须基于此pinctrl句柄。与pinctrl_get接口功能完全一样，只是devm_pinctrl_get会将申请的pinctrl句柄做记账，绑定到设备句柄信息中。设备驱动申请pin资源，推荐优先使用devm_pinctrl_get接口。 </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">返回值 pinctrl句柄 </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">参数 dev：使用pin的设备，pinctrl子系统会通过设备名与pin配置信息匹配。 </span></p> 
</blockquote> 
<p style="margin-left:.0001pt;text-align:left;"></p> 
<h3 id="%E2%91%A1devm_pinctrl_put%C2%A0%E5%87%BD%E6%95%B0" style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#000000;"><strong>②devm_pinctrl_put 函数</strong></span></strong></h3> 
<blockquote> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">函数原型 void devm_pinctrl_put(struct pinctrl *p); </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">函数功能 释放pinctrl句柄，必须与devm_pinctrl_get配对使用。 </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">返回值 无 </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">参数 p：pinctrl句柄 </span></p> 
</blockquote> 
<p style="margin-left:.0001pt;text-align:left;"></p> 
<h3 id="%E2%91%A2pinctrl_lookup_state%C2%A0%E5%87%BD%E6%95%B0" style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#000000;"><strong>③pinctrl_lookup_state 函数</strong></span></strong></h3> 
<blockquote> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">函数原型 struct pinctrl_state * pinctrl_lookup_state(struct pinctrl *p, const char *name); </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">函数功能 查找pin句柄指定状态下的状态句柄。 </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">返回值 状态句柄 </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">参数 p：pinctrl句柄 </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">name：状态名称，A33平台上只有default一种状态</span></p> 
</blockquote> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<h3 id="%E2%91%A3pinctrl_select_state%E5%87%BD%E6%95%B0" style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#000000;"><strong>④pinctrl_select_state函数</strong></span></strong></h3> 
<blockquote> 
 <p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;">函数原型</span></span><span style="background-color:#ffffff;"><span style="color:#000000;"> int pinctrl_select_state(struct pinctrl *p, struct pinctrl_state *s);</span></span></p> 
 <p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;">函数功能 设置pin句柄的状态到硬件</span></span></p> 
 <p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;">返回值 0表示成功，其它表示失败</span></span></p> 
 <p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;">参数 </span></span><span style="color:#000000;">p：pinctrl句柄 </span></p> 
 <p style="margin-left:.0001pt;text-align:justify;"><span style="color:#000000;">S：状态句柄</span></p> 
</blockquote> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#000000;">示例</span></p> 
<pre><code class="language-cpp">//设备树节点
default: tp_test_pins_1: eint@8 {
    pins_cmd_dat {
        pins = &lt;MT8163_PIN_30_EINT8__FUNC_GPIO30&gt;;
        /*配置成输入下拉*/
        slew-rate = &lt;0&gt;;
        bias-pull-down = &lt;00&gt;;

        /*//配置成输入pull disable
        slew-rate = &lt;0&gt;;
        bias-disable;

        //配置成输出high
        slew-rate = &lt;1&gt;;
        bias-disable;
        output-high;

        //配置成输出low
        slew-rate = &lt;1&gt;;
        bias-disable;
        output-low;*/
	};
};
	
tp_test_pins_1: eint@8 {
	pins_cmd_dat {
		pins = &lt;MT8163_PIN_30_EINT8__FUNC_GPIO30&gt;;
		slew-rate = &lt;1&gt;;
		bias-disable;
        output-high;
	};
};

&amp;misc {
    compatible = "misc,test";
    interrupt-parent = &lt;&amp;pio&gt;;
	interrupts = &lt;8 IRQ_TYPE_EDGE_FALLING&gt;;
    eint-debounce = &lt;256&gt;;	
    pinctrl-names = "default","tp_test_1";
    pinctrl-0 = &lt;&amp;default&gt;;
	pinctrl-1 = &lt;&amp;tp_test_pins_1&gt;;
	test1-gpio = &lt;&amp;pio 30 0&gt;;
    test2-gpio = &lt;&amp;pio 31 0&gt;;
	status = "okay";
};

//获得设备对应的pin control state holder
static struct pinctrl *pinctrl_test = devm_pinctrl_get(&amp;dev);

//查找pin control state
struct pinctrl_state *tp_test_1 = pinctrl_lookup_state(pinctrl_test, "default");
struct pinctrl_state *tp_test_2 = pinctrl_lookup_state(pinctrl_test, "tp_test_1");

//设置gpio功能
pinctrl_select_state(pinctrl_test, tp_test_1 );
pinctrl_select_state(pinctrl_test, tp_test_2 );

</code></pre> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<blockquote> 
 <p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;">注：</span></span><span style="background-color:#ffffff;"><span style="color:#000000;">P</span></span><span style="background-color:#ffffff;"><span style="color:#000000;">inctrl模块兼容GPIO的功能，如果pin是作为GPIO input/output,仍然可以使用gpiolib中的标准接口，但是如果要使用GPIO的复用功能，则需要使用pinctrl接口。</span></span></p> 
 <p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#000000;">在驱动代码中我们经常会见到一些以devm开头的函数，这一类的函数都是和设备资源管理（Managed Device Resource）相关的，驱动中提供这些函数主要是为了方便对于申请的资源进行释放，比如：irq、regulator、gpio等等。在驱动进行初始化的时候如果失败，那么通常会goto到某个地方释放资源，这样的标签多了之后会让代码看起来不简洁，devm就是为来处理这种情况。</span></span></p> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/524e29d39aafe180d7cb21b82d16a732/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【python】PEP 8: E302 expected 2 blank lines, found 1</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5b3c7c5e8f6a66ac43a7a055564c56e4/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Power Query 根据其它列替换值</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>