<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>2022Javascript变化 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="2022Javascript变化" />
<meta property="og:description" content="Error cause
缘由
try {
const rawResource = await fetch(“/source”);
const newResource = doComputationalJob(rawResource);
await fetch(“/upload”, { method: “POST”, body: newResource });
} catch (err) {
console.log(err); // TypeError: Failed to fetch
}
复制代码
在上面代码中，我们捕捉了错误，我们没法知道是/source接口还是/upload接口报错，提示不够详细。一般我们会自定义下error
try {
const rawResource = await fetch(“/source”).catch((err) =&gt; {
throw new Error(“获取资源失败”);
});
const newResource = doComputationalJob(rawResource);
await fetch(“/upload”, { method: “POST”, body: newResource }).catch(
(err) =&gt; {
throw new Error(“上传资源失败”);
}
);
} catch (err) {" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/581c378739d054fb24c2c5a42ed30e40/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-02-14T13:28:48+08:00" />
<meta property="article:modified_time" content="2023-02-14T13:28:48+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">2022Javascript变化</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>Error cause<br> 缘由<br> try {<!-- --><br> const rawResource = await fetch(“/source”);<br> const newResource = doComputationalJob(rawResource);<br> await fetch(“/upload”, { method: “POST”, body: newResource });<br> } catch (err) {<!-- --><br> console.log(err); // TypeError: Failed to fetch<br> }<br> 复制代码<br> 在上面代码中，我们捕捉了错误，我们没法知道是/source接口还是/upload接口报错，提示不够详细。一般我们会自定义下error<br> try {<!-- --><br> const rawResource = await fetch(“/source”).catch((err) =&gt; {<!-- --><br> throw new Error(“获取资源失败”);<br> });<br> const newResource = doComputationalJob(rawResource);<br> await fetch(“/upload”, { method: “POST”, body: newResource }).catch(<br> (err) =&gt; {<!-- --><br> throw new Error(“上传资源失败”);<br> }<br> );<br> } catch (err) {<!-- --><br> console.log(err);<br> }<br> 复制代码<br> 但是这样又把最初的err丢失了，我们自定义Error时可以把它补回来，例如<br> try {<!-- --><br> const rawResource = await fetch(“/source”).catch((err) =&gt; {<!-- --><br> const customError = new Error(“获取资源失败”);<br> customError.cause = err;<br> throw customError;<br> });<br> // …<br> } catch (err) {<!-- --><br> console.log(err); // Error: 获取资源失败<br> console.log(err.cause); // TypeError: Failed to fetch<br> }<br> 复制代码<br> 其他一些编程语言，例如Java，早有链式错误的模式，也就是给每个错误提供一个上下文信息，可以找到更低层的错误，并且可以顺着链式找到最后一层。<br> 对于Javascript虽然开发者自行可以做到链式错误的效果，例如上面的例子。但这并不是语言本身内置支持的。<br> 解决方案<br> 现在Error构造函数支持第二个参数传入可选对象，可以保留原始的错误。<br> try {<!-- --><br> const rawResource = await fetch(“/source”).catch((err) =&gt; {<!-- --><br> throw new Error(“获取资源失败”, { cause: err });<br> });<br> // …<br> } catch (err) {<!-- --><br> console.log(err); // Error: 获取资源失败<br> console.log(err.cause); // TypeError: Failed to fetch<br> }<br> 复制代码<br> 当然cause并不是必须传入Error实例，我们也可以记录详细的错误信息<br> try {<!-- --><br> const rawResource = await fetch(“/source?year=2023”).catch((err) =&gt; {<!-- --><br> throw new Error(“获取资源失败”, {<!-- --><br> cause: {<!-- --><br> url: “/source”,<br> params: {<!-- --><br> year: 2023,<br> },<br> err,<br> },<br> });<br> });<br> // …<br> } catch (err) {<!-- --><br> console.log(err); // Error: 获取资源失败<br> console.log(err.cause);<br> /**<br> {<!-- --><br> params: {year: 2023},<br> url: “/source”,<br> err: TypeError: Failed to fetch<br> }<br> */<br> }<br> 复制代码<br> 注意<br> 我们写的时候是new Error(“获取资源失败”, { cause: err })，第二个参数是个可选对象（为了向前兼容、向后扩展考虑），传入cause。而不是new Error(“获取资源失败”, err)。<br> findLast()/findLastIndex()<br> 缘由<br> 假设我们要找数组中倒数最后一个满足条件的元素，一般我们只能自己写for循环，或者数组先reverse<br> const array = [5, 12, 50, 130, 44];<br> const found = […array].reverse().find((element) =&gt; element &gt; 45); // 130<br> 复制代码<br> 要是找索引呢，那得像下面一样。<br> const foundIndex = array.length - 1 - […array].reverse().findIndex((element) =&gt; element &gt; 45); // 3<br> 复制代码<br> 但是这里可能会有人踩坑，如果找不到满足条件，索引应该返回-1，但是按上面的公式就会出问题<br> // 值为5，我们应该想要的是-1<br> let foundIndex = array.length - 1 - […array].reverse().findIndex((element) =&gt; element &gt; 135);</p> 
<p>// 所以又得加个处理<br> foundIndex = foundIndex &gt;= array.length ? -1 : foundIndex； // -1<br> 复制代码<br> 解决方案<br> 所以现在数组支持从后往前找的方法，这挺实用的。<br> const found = array.findLast((element) =&gt; element &gt; 45); // 130<br> const foundIndex = array.findLastIndex((element) =&gt; element &gt; 45); // 3<br> 复制代码<br> 其实这早已有库给我们提供了方法，例如lodash。但是为啥标准库还要去实现这个呢，主要由下</p> 
<p>性能考虑（js内置方法肯定是性能最好的）<br> 库被引用比较频繁（说明很多开发者都有这方面的需求）<br> API的完整性（比如String的padStart和padEnd方法都是成对的）</p> 
<p>没啥缺点需要注意的。<br> /pattern/d和.indices<br> 缘由<br> const str = <code> GIAC date: 2022-11-18 IDEA date: 2022-11-22</code>;<br> const matchedDate = […str.matchAll(/date:\s*(.+)/g)];<br> console.log(matchedDate);<br> /**<br> [<br> [‘date: 2022-11-18’, ‘2022-11-18’, index: 11, …]<br> [‘date: 2022-11-22’, ‘2022-11-22’, index: 38, …]<br> ]<br> <em>/<br> 复制代码<br> 用过matchAll方法的同学知道，该方法会匹配所有满足条件的字符串并返回成一个数组。举例数组第一个元素中，date: 2022-11-18代表第一个满足正则匹配的字符串，2022-11-18代表子匹配（捕获组）满足的字符串，即(.+)匹配的字符串。index: 11代表满足正则的字符串开始的索引，即date: 2022-11-18字符串从str[11]开始。<br> 但是我们不能直接获取结束的索引，以及子匹配的开始索引和结束索引。这需要我们手动计算。有些场景我们可能需要用的上这些索引值，例如在编辑器中，用户输入框搜索关键字，可以高亮显示匹配的字符串，那么需要知道匹配的字符串在整个文本中开始和结束位置。<br> 解决方案<br> 基于上面需求，我们在正则上增加个标记d，便可获取匹配字符串的开始和结束索引。<br> const matchedDate = […str.matchAll(/date:\s</em>(.+)/gd)];<br> console.log(matchedDate);<br> /**<br> [<br> [‘date: 2022-11-18’, ‘2022-11-18’, index: 11, indices: [[11, 27], [17, 27]], …]<br> [‘date: 2022-11-22’, ‘2022-11-22’, index: 38, indices: [[38, 54], [44, 54]], …]<br> ]<br> */<br> 复制代码<br> 在上面代码中，indices: [[11, 27], [17, 27]]。表示date: 2022-11-18在文本中位置为11到27，子匹配2022-11-18在文本中位置为17到27。<br> 我们需要手动添加了d标记，才会有indices值。这是因为出于性能考虑，查找匹配字符串的索引，以及更多子匹配的索引是需要额外的性能消耗。<br> 为什么是d标记？而不是i？因为i以前被占用了，它的作用是不区分大小写搜索。所以取inDices中的d。<br> Object.hasOwn()<br> 缘由<br> 我们判断指对象自身属性中是否具有指定的属性，一般会使用Object.prototype.hasOwnProperty，例如<br> const object1 = {};<br> object1.property1 = 42;<br> console.log(object1.hasOwnProperty(‘property1’)); // true<br> 复制代码<br> 但是hasOwnProperty存在着一些问题。<br> Object.create(null)创建的对象都不继承自 Object.prototype，因此 hasOwnProperty() 无法访问。<br> const foo = Object.create(null);<br> foo.prop = ‘exists’;<br> foo.hasOwnProperty(‘prop’); // Uncaught TypeError: foo.hasOwnProperty is not a function<br> 复制代码<br> 我们必须要使用另外健壮但繁琐的写法。<br> // 方式一<br> Object.prototype.hasOwnProperty.call(foo, ‘prop’); // true<br> // 方式二<br> !!Object.getOwnPropertyDescriptor(foo, ‘prop’); // true<br> 复制代码<br> 另外hasOwnProperty方法是不受保护的，我们知道调用对象的方法，js会先从对象自身找，没有才会从原型链上找。那么开发者创建的对象，自行定义了hasOwnProperty属性，将会出现问题。<br> var foo = {<!-- --><br> hasOwnProperty: function() {<!-- --><br> return false;<br> },<br> bar: ‘Here be dragons’<br> };</p> 
<p>foo.hasOwnProperty(‘bar’); // 始终返回 false<br> 复制代码<br> 解决方案<br> 那么现在Object上增加静态方法hasOwn。<br> const o = {<!-- --><br> prop: ‘exists’<br> };</p> 
<p>Object.hasOwn(o, ‘prop’); // true<br> 复制代码<br> 为什么不是命名Object.hasProperty？因为已经有Object.hasProperty方法了，更精确的说是已经有Object.prototype.hasOwnProperty了，调用Object.hasProperty其实就是调用Object.prototype.hasOwnProperty。<br> 补充个原型链图<br> <img src="https://images2.imgbox.com/64/98/A7NqJXyY_o.png" alt="在这里插入图片描述"></p> 
<p>at()<br> 缘由<br> 我们如果想得到数组的最后一项，那么需要<br> let last = arr[arr.length - 1];<br> 复制代码<br> 解决方案<br> 现在只需要<br> let last = arr.at(-1);<br> 复制代码<br> 正数的话还是和方括号的使用一样。<br> 其实这特性获取值的时候还有用，但赋值的时候其实更麻烦，比如需要数组最后一项加一<br> // 以前做法<br> ++[arr.length - 1];</p> 
<p>// 使用at<br> arr[arr.length - 1] = arr.at(-1) + 1;<br> 复制代码<br> 注意<br> arr.at(i)和arr[i]在处理非索引时语义不同。<br> 我们平时使用数组下标，例如arr[2]。JavaScript 引擎通过隐式的 toString，将 arr[2] 中的 2 强制转换为字符串，也就是说arr[2]和arr[‘2’]值是一样的，下面来验证下<br> const arr = [1, 2, 3]<br> console.log(arr[2]); // 3<br> console.log(arr[‘2’]); // 3</p> 
<p>const obj = {<!-- --><br> toString: () =&gt; 2<br> }<br> console.log(arr[obj]); // 3<br> 复制代码<br> 但是arr[2]和arr[‘02’]是不一样的，因为arr[‘02’]是在查找数组中02字符串的属性<br> console.log(arr[‘02’]); // undefined<br> arr[‘02’] = 66;<br> console.log(arr[‘02’]); // 66<br> console.log(arr); // [1, 2, 3, 02: 66]<br> 复制代码<br> at()方法处理传入的参数是不一样的，它会尝试把参数转成数字，默认0<br> const arr = [1, 2, 3];<br> arr[‘02’] = 66;<br> console.log(arr.at(‘02’)); // 3（相当于arr.at(2)）<br> console.log(arr.at(‘-02’)); // 2（相当于arr.at(-2)）</p> 
<p>console.log(arr.at(undefined)); // 1（相当于arr.at(0)）<br> console.log(arr.at(null)); // 1（相当于arr.at(0)）<br> console.log(arr.at(false)); // 1（相当于arr.at(0)）<br> console.log(arr.at(true)); // 2（相当于arr.at(1)）<br> // …<br> 复制代码<br> at(-0)获取值是什么？<br> 假设我们想使用一个变量idx作为计算值，并且使用arr.at(-idx)获取数组元素。当idx为0时，arr.at(-0)应该代表的是数组最后一位还是数组第一位？可能不同使用者的意图不一样。Javascript中，其实就相当于arr.at(0)，代表的是数组第一位。<br> at()替代方括号写法时要留意<br> 例如，假设以前的代码是正常运行的<br> const a = [1, 2, 3];<br> const i = a.findIndex((x) =&gt; x &gt; 3); // -1<br> a[i]; // undefined<br> 复制代码<br> 如果你直接使用at方法代替方括号写法，可能会使以前代码出现bug<br> a.at(i); // 3<br> 复制代码<br> 另外，String也有at()方法<br> const str = ‘Hello’;<br> const lastChar = str.charAt(str.length - 1); // o</p> 
<p>// 使用at()<br> const lastChar = str.at(-1); // o<br> 复制代码<br> Hashbang #!<br> 缘由<br> 以前我们在终端要用node跑index.js文件，必须使用node index.js来执行<br> 解决方案<br> 现在可以使用hashbang注释语法， 在index.js文件头指定该文件使用哪个解释器运行，如下<br> #!/usr/bin/env node<br> console.log(1);<br> 复制代码<br> 那么你可直接使用./index.js来执行。<br> 如果要使用Typescript运行，那么可以指定ts-node作为解释器<br> #!/usr/bin/env ts-node<br> 复制代码<br> 还有一些好处的话，以前我们node执行脚本需要提供环境变量的话，例如在mac可以使用NODE_ENV=production node ./index.js，那么index.js可以获取变量<br> console.log(process.env.NODE_ENV); // production<br> 复制代码<br> 现在使用hashbang注释语法的话，我们可以直接在文件头提供<br> #!/usr/bin/env -S NODE_ENV=production node<br> console.log(process.env.NODE_ENV); // production<br> 复制代码<br> 然后./index.js执行即可。<br> 注意<br> hashbang 注释语法以 #! 开头，并且只在脚本或模块的最开始处有效。注意，#! 标志之前不能有任何空白字符。<br> 例如这样是不行的<br> #!/usr/bin/env node<br> console.log(1);<br> 复制代码<br> hashbang原本只用于node入口脚本，例如cli。但是现在进入了标准，意味着任何脚本都可以这样做，服务端和浏览器端都可以。但其实浏览器端使用hashbang是没有任何意义的。有些人可能会滥用于同构脚本，即同一套代码，既可以运行在浏览器端，又可以运行在服务器端。比如index.js文件<br> #!/usr/bin/env node<br> console.log(1);<br> 复制代码<br> 在node环境中使用./index.js是可以的<br> 在浏览器端中，引入index.js也是没问题的</p> 
<p>复制代码<br> 但是我们要留意，假设我们在服务端把index.js的代码拼接内敛到html中，例如php</p> 
<p>复制代码<br> 然后最终html拼接后长这样</p> 
<p>复制代码<br> 这会导致浏览器端代码报语法错误，为什么？前面说了#!标志之前不能有任何空白字符。<br> 下面这样才能正常运行</p> 
<p>复制代码<br> 所以我们尽量避免这种风险。<br> Top-level await<br> 缘由<br> 假设我们现在data.mjs导出的数据是要异步获取的，在index.mjs需要使用这数据的话，导入进来是没有值的，必须延时到异步获取到值才会有，这样做法是比较坑爹的。<br> // data.mjs<br> let output;<br> (async () =&gt; {<!-- --><br> output = await fetch(‘/source’);<br> })();<br> export { output };</p> 
<p>// index.mjs<br> import { output } from “./data.mjs”;<br> console.log(output); // 还没有值，undefined<br> setTimeout(() =&gt; {<!-- --><br> console.log(output); // 获取到值<br> }, 1000);<br> 复制代码<br> 解决方案<br> 那么现在支持await直接模块中使用<br> // data.mjs<br> export const output = await fetch(‘/source’);</p> 
<p>// index.mjs<br> import { output } from “./data.mjs”;<br> console.log(output); // 获取到值<br> 复制代码<br> 这意味index.mjs引入data.mjs时，会先把data.mjs所有异步代码执行完成后，这才代表data.mjs模块初始化完，才会执行index.mjs的代码。<br> 注意<br> 这对Node项目还是ok的，但是在web中可能有坑<br> 我们先来思考下，下面打印的顺序是什么？<br> html部分</p> 复制代码 foo.js文件 // foo.js console.log(8); 复制代码 —— —— —— 现在揭晓答案，顺序为27184635。 为什么1不是最先打印？这是因为带有type="module"的script不需要使用 defer 属性，也会自动延迟加载。所以它会比标准脚本往后执行。 然后在id="module_2"模块中，会先把foo模块的代码先执行，初始化后才会执行本身模块的代码，所以打印的4会在8之后。 那么上面还好理解，并且能够把控。 现在Javascript支持顶层await后。我们把foo.js代码改变下，html保持不变，那么顺序将会发生大改变，思考一番下面揭晓。 // foo.js await new Promise(resolve =&gt; { setTimeout(() =&gt; { resolve(8) }, 1000) }).then(v =&gt; { console.log(v); }) 复制代码 —— —— —— 顺序为2716384。 发现id="module_2"的模块相关代码是最后执行的，比id="module_3"模块还后，id="module_2"的模块其实相当于被阻塞了，必须等待foo.js异步结束。TLA（顶层await）会隐式传递，所有依赖TLA的模块都会变成异步模块。 细心发现5根本没有打印出来。因为上面说了引入的模块foo.js必须得执行完，id="module_2"的模块代码才会执行，这时候load事件早已结束，那么再绑定load事件是没有意义的。 上面的操作可能导致结果出乎开发者意料。这是因为foo.js添加顶层await引起。假设以后我们不是import "./foo.js";，而是导入别人的模块，如果不清楚别人内部代码或者提前说明，那么我们根本没法保证自己代码能够按预想的情况执行。所以TLA可见性很差，很容易无意间引入包含TLA的模块，并且改变了代码的执行序。 class相关 由于篇幅有限，关于class的贺老就暂时不展开讲。class相关进入标准的有实例属性的新写法、私有方法和私有属性、静态方法和静态属性、静态的私有属性和私有方法、静态块。其实这些很早有提案，只不过现在才正式纳入标准。详细阔以查看MDN。 最后 2023年，如果有必要，那就把新特性用起来，但是千万不要踩坑哦。
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5bc22e0c6b86f94f59a1b64a483e4456/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">数据泵IMPDP导入时 报错 ，ora- 31655</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/711430dd815e35a360d021ab2ee45284/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">针对电脑软件“上锁”的问题</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>