<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Redis10大数据类型 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Redis10大数据类型" />
<meta property="og:description" content="Redis10大数据类型 Redis键（key）一、Redis字符串（string）1、最常用的2、获取指定区间范围内的值3、数值增减4、获取字符串长度和内容追加5、分布式锁（基础）6、getset 二、Redis列表（List）1、常用2、底层原理3、lpush\rpush\lrange4、lpop\rpop、lindex、len5、Irem key6、Itrim Key7、rpoplpush8、Iset key index value9、linsert key before/after 三、Redis哈希（Hash)1、常用&lt;font color=red&gt;2、hset/hget/hmset/hmget/hgetall/hdel3、hlen4、hexists key5、hkeys/hvals6、hincrby/hincrbyfloat7、hsetnx 四、Redis集合（set）1、常用2、增删改查3、SRANDMEMBER key [数字]4、SPOP key [数字]5、smove key1 key26、集合运算 五、Redis有序集合Zset（sorted set）1、常用2、添加和遍历3、获取指定分数范围的元素4、增删改查5、ZMPOP（New in 7.0）6、获得下标值 六、Redis位图（bitmap）1、简介常用2、setbit3、getbit4、统计字节数占多少5、bitcount6、bitop 七、Redis基数统计(HyperLogLog)1、常用 八、Redis地理空间（GEO）1、geoadd2、geopos3、geohash4、geodist5、georadius 九、Redis流（stream）1、底层原理2、队列相关指令XADDXRANGE\XREVRANGE\XDELXTRIMXREAD总结 3、消费组相关指令XGROUPXREADGROUP GROUP重点问题XPENDING XACK4、四个特殊符号 十、Redis位域(bitfield)1、常用命令2、溢出控制OVERFLOW [WRAPISAT FAIL] Redis键（key） 命令用途keys *查看当前库所有的keyexists key判断某个key是否存在type key查看你的key是什么类型del key删除指定的key数据unlink key非阻塞删除，仅仅将keys从keyspace元数据中州除，真正的删除会在后续异步中操作。ttl key查看还有多少秒过期，-1表示永不过期-2表示已过期expire key 秒钟为给定的key设置过期时间Bmove key dbindex 【0-15】将当前数据库的 key移动到给定的数据库db 当虫select dbindex切换数据库【0-15】，默认为0dbsize查看当前数据库key的数量flushdb清空当前库flushall通杀全部库 一、Redis字符串（string） 1、最常用的 set key value [NX|XX] [GET] [EX seconds|PX milliseconds|EXAT unix-time-seconds|PXAT unix-time-milliseconds|KEEPTTL]
Ex seconds：以秒为单位设置过期时间Fx milliseconds：以毫秒为单位设置过期时间BXAT time stamg：设置以秒为单位的UNIx时间戳所对应的时间为过期时间PXAI milliseconds-timestamp：设置以毫秒为单位的UNIx时间戳所对应的时间为过期时间NX：键不存在的时候设置键值XX：键存在的时候设置键值KEEPTTI：保留设置前指定键的生存时间GET：返回指定键原本的值，若键不存在时返回nil 命令解释SET key value设置指定 key 的值GET key获取指定key 的值。GETRANGE key start end返回 key 中字符串值的子字符GETSET key value将给定 key 的值设为 value，并返回 key 的旧值(old value)。GETBIT key offset对key 所储存的字符串值，获取指定偏移量上的位(bit)。MGET key1 [key2]获取所有(一个或多个)給定 key 的值。SETBIT key offset value对key 所储存的字符串值，设置或清除指定信移量上的位(bit)。SETEX key seconds value将值 value 关联到key，并将 key 的过期时间设为 seconds(以秒为单位)。SETNX key value只有在 key 不存在时设置 key 的值。SETRANGE key offset value用 value 参数覆写给定 key 所储存的字符牢值，从信移量 offiset 开始。STRLEN key返回 key 所储存的字符串值的长度。MSET key value [key value ." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/6802f0cce899d6e0d5406fe66451b1fd/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-07-04T09:34:49+08:00" />
<meta property="article:modified_time" content="2023-07-04T09:34:49+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Redis10大数据类型</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>Redis10大数据类型</h4> 
 <ul><li><a href="#Rediskey_4" rel="nofollow">Redis键（key）</a></li><li><a href="#Redisstring_20" rel="nofollow">一、Redis字符串（string）</a></li><li><ul><li><a href="#1_23" rel="nofollow">1、最常用的</a></li><li><a href="#2_60" rel="nofollow">2、获取指定区间范围内的值</a></li><li><a href="#3_67" rel="nofollow">3、数值增减</a></li><li><a href="#4_76" rel="nofollow">4、获取字符串长度和内容追加</a></li><li><a href="#5_80" rel="nofollow">5、分布式锁（基础）</a></li><li><a href="#6getset_92" rel="nofollow">6、getset</a></li></ul> 
  </li><li><a href="#RedisList_95" rel="nofollow">二、Redis列表（List）</a></li><li><ul><li><a href="#1_98" rel="nofollow">1、常用</a></li><li><a href="#2_119" rel="nofollow">2、底层原理</a></li><li><a href="#3lpushrpushlrange_132" rel="nofollow">3、lpush\rpush\lrange</a></li><li><a href="#4lpoprpoplindexlen_135" rel="nofollow">4、lpop\rpop、lindex、len</a></li><li><a href="#5Irem_key_140" rel="nofollow">5、Irem key</a></li><li><a href="#6Itrim_Key_144" rel="nofollow">6、Itrim Key</a></li><li><a href="#7rpoplpush_147" rel="nofollow">7、rpoplpush</a></li><li><a href="#8Iset_key_index_value_150" rel="nofollow">8、Iset key index value</a></li><li><a href="#9linsert_key_beforeafter_152" rel="nofollow">9、linsert key before/after</a></li></ul> 
  </li><li><a href="#RedisHash_156" rel="nofollow">三、Redis哈希（Hash)</a></li><li><ul><li><a href="#1_160" rel="nofollow">1、常用</a></li><li><a href="#font_colorred2hsethgethmsethmgethgetallhdel_178" rel="nofollow">&lt;font color=red&gt;2、hset/hget/hmset/hmget/hgetall/hdel</a></li><li><a href="#3hlen_180" rel="nofollow">3、hlen</a></li><li><a href="#4hexists_key_183" rel="nofollow">4、hexists key</a></li><li><a href="#5hkeyshvals_186" rel="nofollow">5、hkeys/hvals</a></li><li><a href="#6hincrbyhincrbyfloat_188" rel="nofollow">6、hincrby/hincrbyfloat</a></li><li><a href="#7hsetnx_190" rel="nofollow">7、hsetnx</a></li></ul> 
  </li><li><a href="#Redisset_192" rel="nofollow">四、Redis集合（set）</a></li><li><ul><li><a href="#1_196" rel="nofollow">1、常用</a></li><li><a href="#2_215" rel="nofollow">2、增删改查</a></li><li><a href="#3SRANDMEMBER_key__223" rel="nofollow">3、SRANDMEMBER key [数字]</a></li><li><a href="#4SPOP_key__226" rel="nofollow">4、SPOP key [数字]</a></li><li><a href="#5smove_key1_key2_229" rel="nofollow">5、smove key1 key2</a></li><li><a href="#6_232" rel="nofollow">6、集合运算</a></li></ul> 
  </li><li><a href="#RedisZsetsorted_set_250" rel="nofollow">五、Redis有序集合Zset（sorted set）</a></li><li><ul><li><a href="#1_254" rel="nofollow">1、常用</a></li><li><a href="#2_278" rel="nofollow">2、添加和遍历</a></li><li><a href="#3_294" rel="nofollow">3、获取指定分数范围的元素</a></li><li><a href="#4_303" rel="nofollow">4、增删改查</a></li><li><a href="#5ZMPOPNew_in_70_334" rel="nofollow">5、ZMPOP（New in 7.0）</a></li><li><a href="#6_338" rel="nofollow">6、获得下标值</a></li></ul> 
  </li><li><a href="#Redisbitmap_342" rel="nofollow">六、Redis位图（bitmap）</a></li><li><ul><li><a href="#1_344" rel="nofollow">1、简介</a></li><li><a href="#_350" rel="nofollow">常用</a></li><li><a href="#2setbit_359" rel="nofollow">2、setbit</a></li><li><a href="#3getbit_370" rel="nofollow">3、getbit</a></li><li><a href="#4_377" rel="nofollow">4、统计字节数占多少</a></li><li><a href="#5bitcount_388" rel="nofollow">5、bitcount</a></li><li><a href="#6bitop_391" rel="nofollow">6、bitop</a></li></ul> 
  </li><li><a href="#RedisHyperLogLog_397" rel="nofollow">七、Redis基数统计(HyperLogLog)</a></li><li><ul><li><a href="#1_405" rel="nofollow">1、常用</a></li></ul> 
  </li><li><a href="#RedisGEO_414" rel="nofollow">八、Redis地理空间（GEO）</a></li><li><ul><li><a href="#1geoadd_416" rel="nofollow">1、geoadd</a></li><li><a href="#2geopos_427" rel="nofollow">2、geopos</a></li><li><a href="#3geohash_436" rel="nofollow">3、geohash</a></li><li><a href="#4geodist_447" rel="nofollow">4、geodist</a></li><li><a href="#5georadius_458" rel="nofollow">5、georadius</a></li></ul> 
  </li><li><a href="#Redisstream_465" rel="nofollow">九、Redis流（stream）</a></li><li><ul><li><a href="#1_469" rel="nofollow">1、底层原理</a></li><li><a href="#2_479" rel="nofollow">2、队列相关指令</a></li><li><ul><li><a href="#XADD_490" rel="nofollow">XADD</a></li><li><a href="#XRANGEXREVRANGEXDEL_504" rel="nofollow">XRANGE\XREVRANGE\XDEL</a></li><li><a href="#XTRIM_515" rel="nofollow">XTRIM</a></li><li><a href="#XREAD_522" rel="nofollow">XREAD</a></li><li><a href="#_535" rel="nofollow">总结</a></li></ul> 
   </li><li><a href="#3_540" rel="nofollow">3、消费组相关指令</a></li><li><ul><li><a href="#XGROUP_554" rel="nofollow">XGROUP</a></li><li><a href="#XREADGROUP_GROUP_561" rel="nofollow">XREADGROUP GROUP</a></li><li><a href="#_570" rel="nofollow">重点问题</a></li><li><a href="#XPENDING_576" rel="nofollow">XPENDING</a></li></ul> 
   </li><li><a href="#XACK_585" rel="nofollow">XACK</a></li><li><a href="#4_590" rel="nofollow">4、四个特殊符号</a></li></ul> 
  </li><li><a href="#Redisbitfield_596" rel="nofollow">十、Redis位域(bitfield)</a></li><li><ul><li><a href="#1_601" rel="nofollow">1、常用命令</a></li><li><a href="#2OVERFLOW_WRAPISAT_FAIL_610" rel="nofollow">2、溢出控制OVERFLOW [WRAPISAT FAIL]</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<hr> 
<h2><a id="Rediskey_4"></a>Redis键（key）</h2> 
<table><thead><tr><th>命令</th><th>用途</th></tr></thead><tbody><tr><td>keys *</td><td>查看当前库所有的key</td></tr><tr><td>exists key</td><td>判断某个key是否存在</td></tr><tr><td>type key</td><td>查看你的key是什么类型</td></tr><tr><td>del key</td><td>删除指定的key数据</td></tr><tr><td>unlink key</td><td>非阻塞删除，仅仅将keys从keyspace元数据中州除，真正的删除会在后续异步中操作。</td></tr><tr><td>ttl key</td><td>查看还有多少秒过期，-1表示永不过期-2表示已过期</td></tr><tr><td>expire key 秒钟</td><td>为给定的key设置过期时间B</td></tr><tr><td>move key dbindex 【0-15】</td><td>将当前数据库的 key移动到给定的数据库db 当虫</td></tr><tr><td>select dbindex</td><td>切换数据库【0-15】，默认为0</td></tr><tr><td>dbsize</td><td>查看当前数据库key的数量</td></tr><tr><td>flushdb</td><td>清空当前库</td></tr><tr><td>flushall</td><td>通杀全部库</td></tr></tbody></table> 
<h2><a id="Redisstring_20"></a>一、Redis字符串（string）</h2> 
<p><img src="https://images2.imgbox.com/60/c2/aaQp1au8_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="1_23"></a>1、最常用的</h3> 
<p><code>set key value [NX|XX] [GET] [EX seconds|PX milliseconds|EXAT unix-time-seconds|PXAT unix-time-milliseconds|KEEPTTL]</code></p> 
<ul><li>Ex seconds：以秒为单位设置过期时间</li><li>Fx milliseconds：以毫秒为单位设置过期时间</li><li>BXAT time stamg：设置以秒为单位的UNIx时间戳所对应的时间为过期时间</li><li>PXAI milliseconds-timestamp：设置以毫秒为单位的UNIx时间戳所对应的时间为过期时间</li><li>NX：键不存在的时候设置键值</li><li>XX：键存在的时候设置键值</li><li>KEEPTTI：保留设置前指定键的生存时间</li><li>GET：返回指定键原本的值，若键不存在时返回nil</li></ul> 
<table><thead><tr><th>命令</th><th>解释</th></tr></thead><tbody><tr><td><code>SET key value</code></td><td>设置指定 key 的值</td></tr><tr><td><code>GET key</code></td><td>获取指定key 的值。</td></tr><tr><td><code>GETRANGE key start end</code></td><td>返回 key 中字符串值的子字符</td></tr><tr><td><code>GETSET key value</code></td><td>将给定 key 的值设为 value，并返回 key 的旧值(old value)。</td></tr><tr><td><code>GETBIT key offset</code></td><td>对key 所储存的字符串值，获取指定偏移量上的位(bit)。</td></tr><tr><td><code>MGET key1 [key2]</code></td><td>获取所有(一个或多个)給定 key 的值。</td></tr><tr><td><code>SETBIT key offset value</code></td><td>对key 所储存的字符串值，设置或清除指定信移量上的位(bit)。</td></tr><tr><td><code>SETEX key seconds value</code></td><td>将值 value 关联到key，并将 key 的过期时间设为 seconds(以秒为单位)。</td></tr><tr><td><code>SETNX key value</code></td><td>只有在 key 不存在时设置 key 的值。</td></tr><tr><td><code>SETRANGE key offset value</code></td><td>用 value 参数覆写给定 key 所储存的字符牢值，从信移量 offiset 开始。</td></tr><tr><td><code>STRLEN key</code></td><td>返回 key 所储存的字符串值的长度。</td></tr><tr><td><code>MSET key value [key value ..]</code></td><td>同时设置一个或多个 key-value 对。</td></tr><tr><td><code>MSETNX key value [key value]</code></td><td>同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在。</td></tr><tr><td><code>PSETEX key milliseconds value</code></td><td>这个命令和 SETEX 命令相似，但它以毫秒为单位设置 key 的生存时间，而不是像 SETEX 命令那样，以秒为单位。</td></tr><tr><td><code>INCR key</code></td><td>将key 中储存的数字值增一。</td></tr><tr><td><code>INCRBY key increment</code></td><td>将 key 所情存的值加上给定的增量值(increment ）</td></tr><tr><td><code>INCRBYFLOAT key increment</code></td><td>将 key 所储存的值加上给定的浮点增量值 increment</td></tr><tr><td><code>DECR key</code></td><td>将 key 中情存的数字值减一。</td></tr><tr><td><code>DECRBY key decrement</code></td><td>key 所储存的值减去给定的减量值(decrement</td></tr><tr><td><code>APPEND key value</code></td><td>如果 key 已经存在并且是一个字符串，APPEND 命令将 value 追加到 key 原来的值的未尾。</td></tr></tbody></table> 
<blockquote> 
 <p>MSETNX key value [key value]中所有给定的key都不能存在，一半存在一半不存在也会失败</p> 
</blockquote> 
<h3><a id="2_60"></a>2、获取指定区间范围内的值</h3> 
<pre><code class="prism language-bash">getrang/setrang
</code></pre> 
<p><img src="https://images2.imgbox.com/89/3d/HRxMWGp9_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="3_67"></a>3、数值增减</h3> 
<table><thead><tr><th>需求</th><th>命令</th></tr></thead><tbody><tr><td>递增数字</td><td>INCR key</td></tr><tr><td>增加指定的整数</td><td>INCRBY key increment</td></tr><tr><td>递减数值</td><td>DECR key</td></tr><tr><td>减少指定的整数</td><td>DECRBY key decrement</td></tr></tbody></table> 
<p><font color="red">注意：一定要是数字才能进行加减</font></p> 
<h3><a id="4_76"></a>4、获取字符串长度和内容追加</h3> 
<ul><li>STRLEN key</li><li>APPEND key value<br> <img src="https://images2.imgbox.com/10/47/UXnmxoZa_o.png" alt="在这里插入图片描述"></li></ul> 
<h3><a id="5_80"></a>5、分布式锁（基础）</h3> 
<pre><code class="prism language-bash">setnx key value
setex<span class="token punctuation">(</span>set with expire<span class="token punctuation">)</span>键秒值/setnx<span class="token punctuation">(</span>set <span class="token keyword">if</span> not exist<span class="token punctuation">)</span>
</code></pre> 
<p><code>set key value [EX seconds] [PX milliseconds] [NX|XX]</code></p> 
<ul><li>EX:key在多少秒之后过期</li><li>PX: key在多少毫秒之后过期</li><li>NX:当key不存在的时候，才创建key，效果等同于setnx</li><li>XX：当key存在的时候，覆盖key</li></ul> 
<h3><a id="6getset_92"></a>6、getset</h3> 
<p>先get再set<br> <img src="https://images2.imgbox.com/4a/72/x3GLX6Dt_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="RedisList_95"></a>二、Redis列表（List）</h2> 
<p><img src="https://images2.imgbox.com/93/1a/hGToZbMc_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="1_98"></a>1、常用</h3> 
<table><thead><tr><th>命令</th><th>解释</th></tr></thead><tbody><tr><td>BLPOP [key1 /key2]timeout</td><td>移出并获取列表的第一个元素，如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</td></tr><tr><td>BRPOP [key1/key2] timeout</td><td>移出并获取列表的最后一个元素，如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</td></tr><tr><td>BRPOPLPUSH source destination timeout</td><td>从列表中弹出一个值，将弹出的元素插入到另外一个列表中并返回它：如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</td></tr><tr><td>LINDEX key index</td><td>通过素引获取列表中的元素</td></tr><tr><td>LINSERT key BEFORE\AFTER pivot value</td><td>在列表的元素前或者后插入元素</td></tr><tr><td>LLEN key</td><td>获取列表长度</td></tr><tr><td>LPOP key</td><td>移出并获取列表的第一个元素</td></tr><tr><td>LPUSH key value1 [value2]</td><td>将一个或多个值插入到列表头部</td></tr><tr><td>LPUSHX key value</td><td>将一个或多个值插入到已存在的列表头部</td></tr><tr><td>LRANGE key start stop</td><td>获取列表指定范围内的元素</td></tr><tr><td>LREM key count value</td><td>移除列表元素</td></tr><tr><td>LSET key index value</td><td>通过素引设置列表元素的值</td></tr><tr><td>LTRIM key start stop</td><td>对一个列表进行修剪(trim)，就是说，让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除。</td></tr><tr><td>RPOP key</td><td>移除并获取列表最后一个元素</td></tr><tr><td>RPOPLPUSH source destination</td><td>移除列表的最后一个元素，并将该元素添加到另一个列表并返回</td></tr><tr><td>RPUSH key value1 [value2]</td><td>在列表中添加一个或多个值</td></tr><tr><td>RPUSHX key value</td><td>为已存在的列表添加值</td></tr></tbody></table> 
<h3><a id="2_119"></a>2、底层原理</h3> 
<blockquote> 
 <p>一个双端链表的结构，容量是2的32次方减1个元素，大概40多亿，主要功能有push/pop等，一般用在栈、队列、消息队列等场景。</p> 
</blockquote> 
<p>left、right都可以插入添加；</p> 
<p>如果键不存在，创建新的链表；</p> 
<p>如果键已存在，新增内容；</p> 
<p>如果值全移除，对应的键也就消失了。</p> 
<ul><li>它的底层实际是个双向链表，对两端的操作性能很高，通过索引下标的操作中间的节点性能会较差。</li></ul> 
<h3><a id="3lpushrpushlrange_132"></a>3、lpush\rpush\lrange</h3> 
<p>从从左、又向List中存值，lrange从左遍历List中的元素，没有从右遍历（无rrange）<br> <img src="https://images2.imgbox.com/80/d4/MUlTb4Sz_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="4lpoprpoplindexlen_135"></a>4、lpop\rpop、lindex、len</h3> 
<p>从左、右将List中元素弹出<br> <img src="https://images2.imgbox.com/69/88/VLHgijE3_o.png" alt="在这里插入图片描述"></p> 
<ul><li>lindex：按照索引下标获得元素（从上到下）</li><li>llen：获取列表中元素的个数</li></ul> 
<h3><a id="5Irem_key_140"></a>5、Irem key</h3> 
<p>数字N 给定值v1 解释（删除N个值等于v1的元素）<br> <img src="https://images2.imgbox.com/f0/04/nWDgry4r_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="6Itrim_Key_144"></a>6、Itrim Key</h3> 
<p>开始index 结束index，截取指定范围的值后再赋值给key<br> <img src="https://images2.imgbox.com/af/ea/htlMxzTs_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="7rpoplpush_147"></a>7、rpoplpush</h3> 
<p>将第一个列表（源列表）最后一个值加到第二个列表（目的列表）的第一个<br> <img src="https://images2.imgbox.com/ba/c9/Uwqq6d01_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="8Iset_key_index_value_150"></a>8、Iset key index value</h3> 
<p><img src="https://images2.imgbox.com/b3/0d/FfEzb5uP_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="9linsert_key_beforeafter_152"></a>9、linsert key before/after</h3> 
<p><code>linsert key before/after</code> 已有值 插入的新值</p> 
<p><img src="https://images2.imgbox.com/95/db/Aj7Elg0y_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="RedisHash_156"></a>三、Redis哈希（Hash)</h2> 
<p><img src="https://images2.imgbox.com/da/79/NnaxJzFX_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>KV模式不变，但V是个键值对（套娃）</p> 
</blockquote> 
<h3><a id="1_160"></a>1、常用</h3> 
<table><thead><tr><th>命令</th><th>解释</th></tr></thead><tbody><tr><td>HDEL key field2 [field2]</td><td>删除一个或多个哈希表字段</td></tr><tr><td>HEXISTS key field</td><td>直看哈希表key 中，指定的字段是否存在。</td></tr><tr><td>HGET key field</td><td>获取存储在哈希表中指定字段的值rd&gt;</td></tr><tr><td>HGETALL key</td><td>获取在哈希表中指定 key 的所有字段和值</td></tr><tr><td>HINCRBY key field increment</td><td>为哈希表key 中的指定字段的整效值加上增量 increment。</td></tr><tr><td>HINCRBYFLOAT key field increment</td><td>为哈希表 key 中的指定字段的浮点数值加上增量 increment。</td></tr><tr><td>HKEYS key</td><td>获取所有哈希表中的字段</td></tr><tr><td>HLEN key</td><td>获取哈希表中字段的数量</td></tr><tr><td>HMGET key field1 [field2]</td><td>获取所有给定字段的值</td></tr><tr><td>HMSET key field1 value1 [field2 value2 ]</td><td>同时将多个 field-value(域-值)对设置到哈希表key 中。</td></tr><tr><td>HSET key field value</td><td>将哈希表key 中的字段feld 的值设为 value。</td></tr><tr><td>HSETNX key field value</td><td>只有在字段 feld 不存在时，设置哈希表字段的值。</td></tr><tr><td>HVALS key</td><td>获取哈希表中所有值</td></tr><tr><td>HSCAN key cursor [MATCH pattern] [COUNT count]</td><td>迭代哈希表中的键值对。</td></tr></tbody></table> 
<h3><a id="font_colorred2hsethgethmsethmgethgetallhdel_178"></a><font color="red">2、hset/hget/hmset/hmget/hgetall/hdel</font></h3> 
<p><img src="https://images2.imgbox.com/6f/85/zopvc1QT_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="3hlen_180"></a>3、hlen</h3> 
<p>获取某个key内部的全部数量<br> <img src="https://images2.imgbox.com/72/80/HbtrtkNu_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="4hexists_key_183"></a>4、hexists key</h3> 
<p>查看key里面是否存在某个key，存在返回1<br> <img src="https://images2.imgbox.com/1c/4b/gybDsMAo_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="5hkeyshvals_186"></a>5、hkeys/hvals</h3> 
<p><img src="https://images2.imgbox.com/f8/c9/3ajOY8SW_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="6hincrbyhincrbyfloat_188"></a>6、hincrby/hincrbyfloat</h3> 
<p><img src="https://images2.imgbox.com/df/63/FYJZ11OP_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="7hsetnx_190"></a>7、hsetnx</h3> 
<p><img src="https://images2.imgbox.com/7b/10/JLgwikyU_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="Redisset_192"></a>四、Redis集合（set）</h2> 
<p><img src="https://images2.imgbox.com/1a/e4/xRfc1oA7_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>单值多value，且无重复</p> 
</blockquote> 
<h3><a id="1_196"></a>1、常用</h3> 
<table><thead><tr><th>命令</th><th>解释</th></tr></thead><tbody><tr><td>SADD key member1 [member2]</td><td>向集合添加一个或多个成员</td></tr><tr><td>SCARD key</td><td>获取集合的成员数</td></tr><tr><td>SDIFF key1 [key2]</td><td>返回给定所有集合的差集</td></tr><tr><td>SDIFFSTORE destination key1 [key2]</td><td>返回给定所有集合的差集并存储在 destination 中</td></tr><tr><td>SINTER key1 [key2]</td><td>返回给定所有集合的交集</td></tr><tr><td>SINTERSTORE destination key1 [key2]</td><td>返回给定所有集合的交集并存储在 destination 中</td></tr><tr><td>SISMEMBER key member</td><td>判断 member 元素是否是集合 key 的成员</td></tr><tr><td>SMEMBERS key</td><td>返回集合中的所有成员</td></tr><tr><td>SMOVE source destination member</td><td>将member 元素从 source 集合移动到 destination 集合</td></tr><tr><td>SPOP kev</td><td>移除并返回集合中的一个随机元素</td></tr><tr><td>SRANDMEMBER key [count]</td><td>返回集合中一个或多个随机数</td></tr><tr><td>SREM key member1 [member2]</td><td>移除集合中一个或多个成员</td></tr><tr><td>SUNION key1 [key2]</td><td>返回所有给定集合的并集</td></tr><tr><td>SUNIONSTORE destination key1 [key2]</td><td>所有给定集合的并集存储在 destination 集合中</td></tr><tr><td>SSCAN key cursor [MATCH pattern] [CQUNT count]</td><td>送代集合中的元素</td></tr></tbody></table> 
<h3><a id="2_215"></a>2、增删改查</h3> 
<ul><li>SADD key member [member…] 添加元素</li><li>SMEMBERS key 遍历集合中的所有元素</li><li>SISMEMBER key member 判断元素是否在集合中</li><li>SREM key member [member …] 删除元素</li><li>scard：获取集合里面的元素个数D</li></ul> 
<p><img src="https://images2.imgbox.com/bc/19/L5xnrDdS_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="3SRANDMEMBER_key__223"></a>3、SRANDMEMBER key [数字]</h3> 
<p>从集合中随机<strong>展现</strong>设置的数字个数元素，元素不删除<br> <img src="https://images2.imgbox.com/24/d9/yCWAo36g_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="4SPOP_key__226"></a>4、SPOP key [数字]</h3> 
<p>从集合中随机弹出一个元素，出一个删一个<br> <img src="https://images2.imgbox.com/b0/d1/RH6HZxiH_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="5smove_key1_key2_229"></a>5、smove key1 key2</h3> 
<p>在key1里已存在的某个值D，将key1里已存在的某个值赋给key2<br> <img src="https://images2.imgbox.com/7b/3c/MrAcFBIr_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="6_232"></a>6、集合运算</h3> 
<ul><li>集合的差集运算 A-B：属于A但不属于B的元素构成的集合</li><li>SDIFF key [key…]</li></ul> 
<p><img src="https://images2.imgbox.com/4c/e9/LANGE0PC_o.png" alt="在这里插入图片描述"></p> 
<ul><li>集合的并集运算A U B：属于A或者属于B的元素合并后的集合</li><li>SUNION key [key…]</li></ul> 
<p><img src="https://images2.imgbox.com/88/f3/e7VpVXW1_o.png" alt="在这里插入图片描述"></p> 
<ul><li>集合的交集运算AnB：属于A同时也属于B的共同拥有的元素构成的集合</li><li>SINTER key [key …]</li><li>SINTERCARD numkeys key [key …] [LIMIT limit] 
  <ul><li>redis7新命令</li><li>它不返回结果集，而只返回结果的基数。返回由所有给定集合的交集产生的集合的基数</li></ul> </li></ul> 
<p><img src="https://images2.imgbox.com/e8/7a/PKVjiZkm_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="RedisZsetsorted_set_250"></a>五、Redis有序集合Zset（sorted set）</h2> 
<p><img src="https://images2.imgbox.com/2d/0e/r8yjjJA7_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>在set基础上，每个val值前加一个score分数值。之前set是<code>k1 v1 v2 v3</code>，现在zset是<code>k1 score1 v1 score2 v2</code></p> 
</blockquote> 
<h3><a id="1_254"></a>1、常用</h3> 
<table><thead><tr><th>命令</th><th>解释</th></tr></thead><tbody><tr><td>ZADD key score1 member1 [score2 member2]</td><td>向有序集台添加一个或多个成员，或者更新已存在成员的分数</td></tr><tr><td>ZCARD key</td><td>获取有序集合的成员数</td></tr><tr><td>ZCOUNT key min max</td><td>计算在有序集合中指定区间分数的成员数</td></tr><tr><td>ZINCRBY key increment member</td><td>有序集合中对指定成员的分数加上增量 increment</td></tr><tr><td>ZINTERSTORE destination numkeys key [key]</td><td>计算给定的一个或多个有序集的交集并将结果集存情在新的有序集合 key 中</td></tr><tr><td>ZLEXCOUNT key min max</td><td>在有序集合中计算指定字典区间內成员数量</td></tr><tr><td>ZRANGE key start stop [WITHSCORES]</td><td>通过素引区间返回有序集合成指定区间内的成员</td></tr><tr><td>ZRANGEBYLEX key min max [LIMIT offset count]</td><td>通过字典区间返回有序集合的成员</td></tr><tr><td>ZRANGEBYSCORE key min max [WITHSCORES][LIMIT]</td><td>通过分数返回有序集合指定区间內的成员</td></tr><tr><td>ZRANK key member</td><td>返回有序集合中指定成员的素引</td></tr><tr><td>ZREM key member [member]</td><td>移除有序集合中的一个或多个成员</td></tr><tr><td>ZREMRANGEBYLEX key min max</td><td>移除有序集合中给定的字典区间的所有成员</td></tr><tr><td>ZREMRANGEBYRANK key start stop</td><td>移除有序集合中给定的排名区间的所有成员</td></tr><tr><td>ZREMRANGEBYSCORE key min max</td><td>移除有序集合中给定的分数区间的所有成员</td></tr><tr><td>ZREVRANGE key start stop [WITHSCORES]</td><td>返回有序集中指定区间内的成员，通过素引，分数从高到底</td></tr><tr><td>ZREVRANGEBYSCORE key max min [WITHSCORES]</td><td>返回有序集中指定分数区间内的成员，分数从高到低排序</td></tr><tr><td>ZREVRANK key member</td><td>返回有序集合中指定成员的排名，有序集成员按分数值递减(从大到小排序)</td></tr><tr><td>ZSCORE key member</td><td>返回有序集中，成员的分数值</td></tr><tr><td>ZUNIONSTORE destination numkeys key [key…]</td><td>计算给定的一个或多个有序集的并集，并存储在新的key 中</td></tr><tr><td>ZSCAN key cursor [MATCH patter] [COUNT [count]</td><td>迭代有序集合中的元素（包括元素成员和元素分值）</td></tr></tbody></table> 
<h3><a id="2_278"></a>2、添加和遍历</h3> 
<p>添加元素</p> 
<pre><code class="prism language-bash">ZADD key score member <span class="token punctuation">[</span>score member<span class="token punctuation">..</span>.<span class="token punctuation">]</span> 
</code></pre> 
<p>按照元素分数从小到大的顺序返回索引从start到stop之间的所有元素</p> 
<pre><code class="prism language-bash">ZRANGE key start stop <span class="token punctuation">[</span>WITHSCORES<span class="token punctuation">]</span> 
</code></pre> 
<p><img src="https://images2.imgbox.com/f0/61/7i44IAHC_o.png" alt="在这里插入图片描述"><br> 反转排序<br> <img src="https://images2.imgbox.com/38/08/7GnPcK4O_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="3_294"></a>3、获取指定分数范围的元素</h3> 
<pre><code class="prism language-bash">ZRANGEBYSCORE key min max <span class="token punctuation">[</span>WITHSCORESI <span class="token punctuation">[</span>LIMIT offset count<span class="token punctuation">]</span>
</code></pre> 
<ul><li><code> withscores</code>：带着value一起遍历</li><li><code>（</code> 的意思表示不包括</li><li><code>limit</code>作用是返回限制，类似于MySQL中的分页<br> <img src="https://images2.imgbox.com/d1/f1/kmk6u8gX_o.png" alt="在这里插入图片描述"></li></ul> 
<h3><a id="4_303"></a>4、增删改查</h3> 
<ul><li>获取元素的分数</li></ul> 
<pre><code class="prism language-bash">ZSCORE key member
</code></pre> 
<p><img src="https://images2.imgbox.com/af/ea/Ac3aHzSj_o.png" alt="在这里插入图片描述"></p> 
<ul><li>获取集合中元素的数量</li></ul> 
<pre><code class="prism language-bash">ZCARD key
</code></pre> 
<p><img src="https://images2.imgbox.com/f8/a6/pmmdmV4v_o.png" alt="在这里插入图片描述"></p> 
<ul><li>删除某个元素</li></ul> 
<pre><code class="prism language-bash">Zrem key 某score下对应的value值
</code></pre> 
<p><img src="https://images2.imgbox.com/2c/4e/Cu4UKFkV_o.png" alt="在这里插入图片描述"></p> 
<ul><li>增加某个元素的分数</li></ul> 
<pre><code class="prism language-bash">ZINCRBY key increment member
</code></pre> 
<p><img src="https://images2.imgbox.com/82/1f/lsmpJXj5_o.png" alt="在这里插入图片描述"></p> 
<ul><li>获取指定分数范围的元素个数</li></ul> 
<pre><code class="prism language-bash">ZCOUNT key min max
</code></pre> 
<p><img src="https://images2.imgbox.com/31/28/p9F40DG5_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="5ZMPOPNew_in_70_334"></a>5、ZMPOP（New in 7.0）</h3> 
<p>从键名列表中的第一个非空排序集中弹出一个或多个元素，它们是成员分数对</p> 
<p><img src="https://images2.imgbox.com/70/3e/soZLdjHp_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="6_338"></a>6、获得下标值</h3> 
<ul><li><code>zrank key values</code>值，作用是获得下标值</li><li><code>zrevrank key values</code>值，作用是逆序获得下标值<br> <img src="https://images2.imgbox.com/4b/51/naGgN6t8_o.png" alt="在这里插入图片描述"></li></ul> 
<h2><a id="Redisbitmap_342"></a>六、Redis位图（bitmap）</h2> 
<p><img src="https://images2.imgbox.com/45/14/dgiK1hyM_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="1_344"></a>1、简介</h3> 
<p><img src="https://images2.imgbox.com/19/94/Ewqu88Zj_o.png" alt="在这里插入图片描述"></p> 
<ul><li><font color="red">用String类型作为底层数据结构实现的一种统计二值状态的数据类型</font></li><li><font color="red">位图本质是数组，它是基于String数据类型的按位的操作。该数组由多个二进制位组成，每个二进制位都对应一个偏移量(我们称之为一个索引)。</font></li><li>Bitmap支持的最大位数是2的32次方位，它可以极大的节约存储空间，使用512M内存就可以存储多达42.9亿的字节信息(2^32 = 4294967296)</li></ul> 
<h3><a id="_350"></a>常用</h3> 
<table><thead><tr><th>命令</th><th>作用</th><th>时间复杂度</th></tr></thead><tbody><tr><td>setbit key offset val</td><td>给指定key的值的第offset赋值val</td><td>O(1)</td></tr><tr><td>getbit key offset</td><td>获取指定key的第offset位</td><td>O(1)</td></tr><tr><td>bitcount key start end</td><td>返回指定key中[start,end]中为1的数量</td><td>O(n)</td></tr><tr><td>bitop operation destkey key</td><td>对不同的二进制存储数据进行位运算(AND、 OR、 NOT、XOR)</td><td>O(n)</td></tr></tbody></table> 
<h3><a id="2setbit_359"></a>2、setbit</h3> 
<pre><code class="prism language-bash">setbit key offset value
</code></pre> 
<ul><li>setbit 键 偏移位 只能零或者1</li><li>Bitmap的偏移量是从零开始算的</li></ul> 
<p><img src="https://images2.imgbox.com/5d/52/keg2siT8_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="3getbit_370"></a>3、getbit</h3> 
<pre><code class="prism language-bash">getbit key offset
</code></pre> 
<p><img src="https://images2.imgbox.com/67/17/C3CaYXXe_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="4_377"></a>4、统计字节数占多少</h3> 
<pre><code class="prism language-bash">STRLEN key
</code></pre> 
<p><img src="https://images2.imgbox.com/0b/36/ZOnMyJ0b_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>不是字符串长度而是占据几个字节，超过8位后自己按照8位一组一byte再扩容</p> 
</blockquote> 
<h3><a id="5bitcount_388"></a>5、bitcount</h3> 
<p>统计全部键里面含有1的数量<br> <img src="https://images2.imgbox.com/f3/74/yfzkmrge_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="6bitop_391"></a>6、bitop</h3> 
<pre><code class="prism language-bash">bitop operation destkey key
</code></pre> 
<h2><a id="RedisHyperLogLog_397"></a>七、Redis基数统计(HyperLogLog)</h2> 
<p><img src="https://images2.imgbox.com/e5/4f/IHcOzQxB_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>统计某个往回走哪的UV（Unique Visitor：独立访客/用户端IP）、统计某个文章的UV、统计搜索网站关键词的数量、统计用户没天搜索不同的词条个数</p> 
</blockquote> 
<blockquote> 
 <p>Redis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定 的、并且是很小的。<br> 在Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基数」这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。<br> 但是，因为 HyperLogLog 只会根据输入元表来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集台那样，返回输入的各个元素。</p> 
</blockquote> 
<h3><a id="1_405"></a>1、常用</h3> 
<table><thead><tr><th>命令</th><th>解释</th></tr></thead><tbody><tr><td>PFADD key element [element… ]</td><td>添加指定元表到 HyperLogLog 中。</td></tr><tr><td>PFCQUNT key [key]</td><td>返回给定 HyperLogLog 的基数估算值。</td></tr><tr><td>PFMERGE destkey sourcekey [sourcekey…]</td><td>将多个 HyperLogLog 合并为一个 HyperLogLog</td></tr></tbody></table> 
<p><img src="https://images2.imgbox.com/12/f7/uQOOLb9V_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="RedisGEO_414"></a>八、Redis地理空间（GEO）</h2> 
<p><img src="https://images2.imgbox.com/79/73/yGDItpSZ_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="1geoadd_416"></a>1、geoadd</h3> 
<p>geoadd 用于存储指定的地理空间位置，可以将一个或多个经(longitude)、纬度(latitude)、位置名称(member)添加到指定的 key 中。</p> 
<p>geoadd 语法格式如下：</p> 
<pre><code class="prism language-bash">GEOADD key longitude latitude member <span class="token punctuation">[</span>longitude latitude member <span class="token punctuation">..</span>.<span class="token punctuation">]</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/69/4d/krHEJTH0_o.png" alt="在这里插入图片描述"></p> 
<p>可以看出类型为zset，在遍历时出现中文乱码问题，quit退出Redis，输入<code>redis-cli -a 1234 --raw</code>后再次进入重新遍历<br> <img src="https://images2.imgbox.com/e8/6a/EOQ1aY8m_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="2geopos_427"></a>2、geopos</h3> 
<p>geopos用于从给定的key里返回所有指定名称（member）的位置（经度和纬度），不存在的返回nill。</p> 
<p>geopos 语法格式如下：</p> 
<pre><code class="prism language-bash">GEOPOS key member <span class="token punctuation">[</span>member <span class="token punctuation">..</span>.<span class="token punctuation">]</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/1b/d1/wnTMJ3Ro_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="3geohash_436"></a>3、geohash</h3> 
<ul><li>Redis GEO 使用 geohash 来保存地理位置的坐标。</li><li>geohash 用于获取一个或多个位置元素的 geohash 值。</li></ul> 
<p>geohash 语法格式如下：</p> 
<pre><code class="prism language-bash">GEOHASH key member <span class="token punctuation">[</span>member <span class="token builtin class-name">.</span> <span class="token builtin class-name">.</span> .<span class="token punctuation">]</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/4c/2a/iOIkcLcK_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="4geodist_447"></a>4、geodist</h3> 
<ul><li>geodist 用于返回两个给定位置之间的距离。</li></ul> 
<p>geodist 语法格式如下：</p> 
<pre><code class="prism language-bash">GEODIST key member1 member2 <span class="token punctuation">[</span>mlkm /ft/mi<span class="token punctuation">]</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/f1/f3/4UkLcB1L_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="5georadius_458"></a>5、georadius</h3> 
<p>georadius 以给定的经纬度为中心， 返回键包含的位置元素当中， 与中心的距离不超过给定最大距离的所有位置元素。<br> <img src="https://images2.imgbox.com/03/98/2e0dW73V_o.png" alt="在这里插入图片描述"></p> 
<ul><li>WITHDIST: 在返回位置元素的同时， 将位置元素与中心之间的距离也一并返回。 距离的单位和用户给定的范围单位保持一致。</li><li>WITHCOORD: 将位置元素的经度和维度也一并返回。</li><li>WITHHASH: 以 52 位有符号整数的形式， 返回位置元素经过原始geohash 编码的有序集合分值。 这个选项主要用于底层应用或者调试， 实际中的作用并不大COUNT 限定返回的记录数。</li></ul> 
<h2><a id="Redisstream_465"></a>九、Redis流（stream）</h2> 
<p><img src="https://images2.imgbox.com/4f/f8/Q3Wvrcch_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>Redis流（stream）实现消息队列，它支持消息的持久化、支持自动生成全局唯一ID、支持ack确认消息的模式、支持消费组模式等，让消息队列更加的稳定和可靠</p> 
</blockquote> 
<h3><a id="1_469"></a>1、底层原理</h3> 
<p><img src="https://images2.imgbox.com/7c/0c/AEKvDFjS_o.png" alt="在这里插入图片描述"></p> 
<table><thead><tr><th></th><th>解释</th></tr></thead><tbody><tr><td>Message Content</td><td>消息内容</td></tr><tr><td>Consumer group</td><td>消费组，通过XGROUP CREATE 命令创建，同一个消费组可以有多个消费者</td></tr><tr><td>Last_delivered_id</td><td>游标，每个消费组会有个游标 last_delivered id，任意一个消费者读取了消息都会使游标 last_delivered_ id 往前移动。</td></tr><tr><td>Consumer</td><td>消费者，消费组中的消费者</td></tr><tr><td>Pending_ids</td><td>消费者会有一个状态变量，用于记录被当前消费已读取但未ack的消息ld，如果客户端没有ack,这个变量里面的消息ID会越来越多，一旦某个消息被ack它就开始减少。这个pending_ids变量在Redis官方被称之PEL(Pending Entries List)，记录了当前已经被客户端读取的消息，但是还没有 ack (Acknowledge character：确认字符），它用来确保客户端至少消费了消息一次，而不会在网络传输的中途丢失了没处理</td></tr></tbody></table> 
<h3><a id="2_479"></a>2、队列相关指令</h3> 
<table><thead><tr><th>指令名称</th><th>指令作用</th></tr></thead><tbody><tr><td>XADD</td><td>添加消息到队列末尾</td></tr><tr><td>XTRIM</td><td>限制Stream的长度，如果己经超长会进行截取</td></tr><tr><td>XDEL</td><td>删除消息</td></tr><tr><td>XLEN</td><td>获取Stream中的消息长度</td></tr><tr><td>XRANGE</td><td>获取消息列表（可以指定范围），忽略删除的消息</td></tr><tr><td>XREVRANGE</td><td>和XRANGE相比区别在于反向获取，1D从大到小</td></tr><tr><td>XREAD</td><td>获取消息（阻塞/非阻塞），返回大于指定ID的消息</td></tr></tbody></table> 
<h4><a id="XADD_490"></a>XADD</h4> 
<blockquote> 
 <p>XADD 用于向Stream 队列中添加消息，如果指定的Stream 队列不存在，则该命令执行时会新建一个Stream 队列<br> <code>* </code>号表示服务器自动生成 MessageID(类似mysql里面主键auto_increment)，后面顺序跟着一堆 业务key/value</p> 
</blockquote> 
<ul><li>消息ID必须要比上个ID大</li><li>默认用星号表示自动生成规矩</li></ul> 
<p><img src="https://images2.imgbox.com/c2/31/uNqDHChl_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>信息条目指的是序列号，在相同的毫秒下序列号从0开始递增，序列号是64位长度，理论上在同一毫秒内生成的数据量无法到达这个级别，因此不用担心序列号会不够用。millisecondsTime指的是Redis节点服务器的本地时间，如果存在当前的毫秒时间戳比以前已经存在的数据的时间戳小的话（本地时间钟后跳），那么系统将会采用以前相同的毫秒创建新的ID，也即redis 在增加信息条目时会检查当前 id 与上一条目的 id， 自动纠正错误的情况，一定要保证后面的 id 比前面大，一个流中信息条目的ID必须是单调增的，这是流的基础。</p> 
</blockquote> 
<blockquote> 
 <p>客户端显示传入规则:<br> Redis对于ID有强制要求，格式必须是时间戳-自增Id这样的方式，且后续ID不能小于前一个ID</p> 
</blockquote> 
<blockquote> 
 <p>Stream的消息内容，也就是图中的Message Content它的结构类似Hash结构，以key-value的形式存在。</p> 
</blockquote> 
<h4><a id="XRANGEXREVRANGEXDEL_504"></a>XRANGE\XREVRANGE\XDEL</h4> 
<ul><li>用于获取消息列表（可以指定范围），忽略删除的消息</li><li>start 表示开始值，-代表最小值</li><li>end 表示结束值，+代表最大值</li><li>count 表示最多获取多少个值<br> <img src="https://images2.imgbox.com/ca/ee/scAyD8TR_o.png" alt="在这里插入图片描述"></li><li>XREVRANGE<br> 与XRANGE 的区别在于，获取消息列表元素的方向是相反的，end在前，start在后</li><li>XDEL<br> <img src="https://images2.imgbox.com/86/99/I2cNXK8E_o.png" alt="在这里插入图片描述"></li></ul> 
<h4><a id="XTRIM_515"></a>XTRIM</h4> 
<ul><li>用于对Stream的长度进行截取，如超长会进行截取</li><li>MAXLEN<br> 允许的最大长度，对流进行修剪限制长度目</li><li>MINID<br> 允许的最小id，从某个ia值开始比该id值小的将会被抛弃</li></ul> 
<h4><a id="XREAD_522"></a>XREAD</h4> 
<ul><li>用于获取消息（阻塞/非阻塞），只会返回大于指定ID的消息</li></ul> 
<pre><code class="prism language-bash">XREAD <span class="token punctuation">[</span>COUNT count<span class="token punctuation">]</span><span class="token punctuation">[</span> BLOCK milliseconds<span class="token punctuation">]</span>STREAMS key <span class="token punctuation">[</span>key <span class="token punctuation">..</span> <span class="token punctuation">]</span>ID <span class="token punctuation">[</span>ID<span class="token punctuation">..</span><span class="token punctuation">]</span>
</code></pre> 
<pre><code>COUNT 最多读取多少条消息
BLOCK 是否已阻塞的方式读取消息，默认不阻塞，如果milliseconds设置为0，表示永远阻塞
</code></pre> 
<ul><li>非阻塞 
  <ul><li><code>$</code>代表特殊ID，表示以当前Stream已经存储的最大的ID作为最后一个ID，当前Stream中不存在大于当前最大ID的消息，因此此时返回nil</li><li>0-0代表从最小的ID开始获取Stream中的消息，当不指定count，将会返回Stream中的所有消息，注意也可以使用0（00/000也都是可以的……）</li></ul> </li><li>阻塞<br> <img src="https://images2.imgbox.com/d9/3a/6xX3zTgK_o.png" alt="在这里插入图片描述"></li></ul> 
<h4><a id="_535"></a>总结</h4> 
<p>Stream的基础方法，使用xadd存入消息和xread循环阻塞读取消息的方式可以实现简易版的消息队列，交互流程如下<br> <img src="https://images2.imgbox.com/fa/12/3Ac94D7n_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="3_540"></a>3、消费组相关指令</h3> 
<table><thead><tr><th>指令名称</th><th>指令作用</th></tr></thead><tbody><tr><td>XGROUP CREATE</td><td>创建消费者组</td></tr><tr><td>XREADGROUP GROUP</td><td>读取消费者组中的消息</td></tr><tr><td>XACK</td><td>ack消息，消息被标记为"已处理”</td></tr><tr><td>XGROUP SETID</td><td>设置消费者组最后递送消息的1D</td></tr><tr><td>XGROUP DELCONSUMER</td><td>删除消费者组</td></tr><tr><td>XPENDING</td><td>打印待处理消息的详细信息</td></tr><tr><td>XCLAIM</td><td>转移消息的归展权（长期未被处理/无法处理的消息，转交给其他消费者组进行处理）</td></tr><tr><td>XINFO</td><td>打印StreamIConsumerlGroup的详细信息</td></tr><tr><td>XINFO GROUPS</td><td>打印消费者组的详細信息</td></tr><tr><td>XINFO STREAM</td><td>打印Stream的详细信息</td></tr></tbody></table> 
<h4><a id="XGROUP_554"></a>XGROUP</h4> 
<p><img src="https://images2.imgbox.com/2d/3b/S27qFDJ5_o.png" alt="在这里插入图片描述"></p> 
<ul><li> <p>$表示从Stream尾部开始消费</p> </li><li> <p>0表示从Stream头部开始消费</p> </li><li> <p>创建消费者组的时候必须指定 ID, ID 为 0 表示从头开始消费，为 $ 表示只消费新的消息，队尾新来</p> </li></ul> 
<h4><a id="XREADGROUP_GROUP_561"></a>XREADGROUP GROUP</h4> 
<ul><li> <p>“&gt;”，表示从第一条尚末被消费的消息开始读取</p> </li><li> <p>消费组groupA内的消费者consumerl从mystream消息队列中读取所有消息<br> <img src="https://images2.imgbox.com/15/a1/mkN1rqCo_o.png" alt="在这里插入图片描述"></p> </li><li> <p>但是，不同消费组的消费者可以消费同一条消息 B<br> <img src="https://images2.imgbox.com/e3/86/KgJSf2xU_o.png" alt="在这里插入图片描述"></p> </li><li> <p>让组内的多个消费者共同分担读取消息，所以，我们通常会让每个消费者读取部分消息，从而实现消息读取负载在多个消费者间是均衡分布的<br> <img src="https://images2.imgbox.com/01/34/Qwn7wB6C_o.png" alt="在这里插入图片描述"></p> </li></ul> 
<h4><a id="_570"></a>重点问题</h4> 
<p>问题：基于 Stream 实现的消息队列，如何保证消费者在发生故障或宕机再次重启后，仍然可以读取未处理完的消息？</p> 
<ul><li> <p>Streams 会自动使用内部队列（也称为 PENDING List）留存消费组里每个消费者读取的消息保底措施，直到消费者使用 XACK 命令通知 Streams“消息已经处理完成”。</p> </li><li> <p>消费确认增加了消息的可靠性，一般在业务处理完成之后，需要执行 XACK 命令确认消息已经被消费完成<br> <img src="https://images2.imgbox.com/b0/5f/q0lq8cwC_o.png" alt="在这里插入图片描述"></p> </li></ul> 
<h4><a id="XPENDING_576"></a>XPENDING</h4> 
<ul><li> <p>查询每个消费组内所有消费者「已读取、但尚未确认」的消息<br> <img src="https://images2.imgbox.com/8c/4c/FL7tdxAa_o.png" alt="在这里插入图片描述"></p> </li><li> <p>查看某个消费者具体读取了哪些数据<br> <img src="https://images2.imgbox.com/20/12/TVoI6wm4_o.png" alt="在这里插入图片描述"><br> 下面抓图所示：consumer2已读取的消息的 ID是1659430293537-0<br> 一旦消息1659430293537-0被consumer2处理了consumer2就可以使用 XACK 命令通知 Streams，然后这条消息就会被删除<br> <img src="https://images2.imgbox.com/e8/a6/96VAP3Yh_o.png" alt="在这里插入图片描述"></p> </li></ul> 
<h3><a id="XACK_585"></a>XACK</h3> 
<p><img src="https://images2.imgbox.com/25/42/0YsFQ8mS_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/c4/cd/bWOBodVq_o.png" alt="在这里插入图片描述"></p> 
<p>向消息队列确认消息处理已完成</p> 
<h3><a id="4_590"></a>4、四个特殊符号</h3> 
<table><thead><tr><th><code>- +</code></th><th>最小和最大可能出现的ld</th></tr></thead><tbody><tr><td><code>$</code></td><td>$表示只消费新的消息，当前流中最大的id，可用于将要到来的信息</td></tr><tr><td><code>&gt;</code></td><td>用于XREADGROUP命令，表示迄今还没有发送给组中使用者的信息，会更新消费者组的最后 ID</td></tr><tr><td><code>*</code></td><td>用于XADD命令中，让系统自动生成id</td></tr></tbody></table> 
<h2><a id="Redisbitfield_596"></a>十、Redis位域(bitfield)</h2> 
<blockquote> 
 <p>BITFIELD 命令的作用在于它能够将很多小的整数储存到一个长度较大的位图中，又或者将一个非常庞大的键分割为多个较小的键来进行储存，从而非常高效地使用內存，使得 Redis 能够得到更多不同的应用——特别是在实时分析领域：BITFIELD 能够以指定的方式对计算溢出进行控制的能力，使得它可以被应用于这一领域。</p> 
</blockquote> 
<p><font color="red">将一个Redis字符串看作是一个由二进制位组成的数组并能对变长位宽和任意没有字节对齐的指定整型位域进行寻址和修改</font></p> 
<h3><a id="1_601"></a>1、常用命令</h3> 
<p><code>BITFIELD key [GET type offset]</code><br> <img src="https://images2.imgbox.com/55/bd/icYXbDQ6_o.png" alt="在这里插入图片描述"></p> 
<p><code>BITFIELD key [SET type offset value]</code><br> <img src="https://images2.imgbox.com/d2/38/0Lvt5hvx_o.png" alt="在这里插入图片描述"></p> 
<p><code>BITFIELD key [NCRBY type offset increment]</code><br> <img src="https://images2.imgbox.com/15/69/HhTeJQZB_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="2OVERFLOW_WRAPISAT_FAIL_610"></a>2、溢出控制OVERFLOW [WRAPISAT FAIL]</h3> 
<ul><li> <p>WRAP:使用回绕（wrap around)方法处理有符号整数和无符号整数的溢出情况<br> <img src="https://images2.imgbox.com/7a/c7/533vOquG_o.png" alt="在这里插入图片描述"></p> </li><li> <p>SAT: 使用饱和计算 (saturation arithmetic）方法处理溢出，下溢计算的结果为最小的整数值，而上溢计算的结果为最大的整数值<br> <img src="https://images2.imgbox.com/ba/4e/qB6TL2X2_o.png" alt="在这里插入图片描述"></p> </li><li> <p>FAIL: 命令将拒绝执行那些会导致上溢或者下溢情况出现的计算，并向用户返回空值表示计算未被执行<br> <img src="https://images2.imgbox.com/c4/46/8OlNyCWq_o.png" alt="在这里插入图片描述"></p> </li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9ca40a9782014767dcc0918e8aafeaee/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Python基础教程(8)——bug清除手册</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e726d2af60d0b63c4d5e2cedf661a04a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">第十章：Nginx配置详细讲解</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>