<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>SpringBoot的配置如何动态刷新（方案） - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="SpringBoot的配置如何动态刷新（方案）" />
<meta property="og:description" content="对于微服务而言配置本地化是个很大的鸡肋，不可能每次需要改个配置都要重新把服务重新启动一遍，因此最终的解决方案都是将配置外部化，托管在一个平台上达到不用重启服务即可一次修改多处生效的目的。
但是对于单体应用的Spring Boot项目而言，动态刷新显然是有点多余，反正就一个服务，改下重启不就行了，然而在某些特殊的场景下还是必须用到动态刷新的
微服务下有哪几种主流的方案？ 微服务下的动态配置中心有三种主流的方式，如下图：
上图中的三种配置中心方案可以说是现在企业中使用率最高的，分别是：
Nacos:阿里巴巴的最近开源的项目，这个家伙很牛逼，一个干掉了Eureka(停更)和Config&#43;Bus，既能作为配置中心也能作为注册中心，并且有自己的独立的 管理平台，可以说是现在最主流的一种。
Config&#43;Bus：早期在用的微服务配置中心，可以依托GitHub管理微服务的配置文件，这种现在也是有不少企业在用，但是需要自己独立部署一个微服务，和Nacos相比逊色了不少。
Apollo：携程开源项目Apollo，这个也是不少企业在用，陈某了解的不多，有兴趣的可以深入研究下。
针对Spring Boot 适用的几种方案？ 其实上述三种都可以在Spring Boot项目中适配，但是作为单体应用有些重了。
1. 如果项目是一个微服务的集群，业务功能复杂
建议： Spring Boot&#43;Nacos
2. 如果项目是单体服务，业务功能单一
建议： Spring Boot&#43;Config&#43;actuator
Spring Boot&#43;手动refresh
针对Spring Boot&#43;Nacos 阿里要做的其实是一个微服务生态，Nacos不仅仅可以作为Spring Cloud的配置和注册中心，也适配了Dubbo、K8s，官方文档中对于如何适配都做了详细的介绍，作者 这里就不再详细介绍了，如下图：
当然Nacos对Spring、Spring Boot 项目同样适用。
如何使用呢？这里作者只提供下思路，不做过多的深究，这篇在作者下个专栏Spring Cloud 进阶会详细介绍：
下载对应版本的Nacos，启动项目，访问http://localhost:8848进入Nacos的管理界面；
Spring Boot 项目引入Nacos的配置依赖nacos-config-spring-boot-starter，配置Nacos管理中心的地址。
@NacosPropertySource、@NacosValue两个注解结合完成。
@NacosPropertySource：指定配置中心的dataId，和是否自动刷新
@NacosValue替代@Value注解完成属性的自动装配
如果公司项目做了后台管理，则可以直接调用Nacos开放的API修改对应配置的值（替代了Nacos管理界面的手动操作），API的地址：https://nacos.io/zh-cn/docs/open-api.html
针对Spring Boot&#43;Config&#43;actuator 1. 添加Config的依赖，如下
&lt;!-- springCloud的依赖--&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;Hoxton.SR3&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;!-- config的依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/2516ce7fc74ae28f1e9cf165b8611c3c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-05-24T13:44:54+08:00" />
<meta property="article:modified_time" content="2023-05-24T13:44:54+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">SpringBoot的配置如何动态刷新（方案）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p></p> 
<p>对于微服务而言配置本地化是个很大的鸡肋，不可能每次需要改个配置都要重新把服务重新启动一遍，因此最终的解决方案都是将配置外部化，托管在一个平台上达到不用重启服务即可一次修改多处生效的目的。<br> 但是对于单体应用的Spring Boot项目而言，动态刷新显然是有点多余，反正就一个服务，改下重启不就行了，然而在某些特殊的场景下还是必须用到动态刷新的</p> 
<p></p> 
<h3>微服务下有哪几种主流的方案？</h3> 
<p>微服务下的动态配置中心有三种主流的方式，如下图：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/f7/61/rOvtXOv8_o.png"></p> 
<p>上图中的三种配置中心方案可以说是现在企业中使用率最高的，分别是：</p> 
<ol><li> <p>Nacos:阿里巴巴的最近开源的项目，这个家伙很牛逼，一个干掉了<code>Eureka</code>(停更)和<code>Config+Bus</code>，既能作为配置中心也能作为注册中心，并且有自己的独立的 管理平台，可以说是现在最主流的一种。</p> </li><li> <p>Config+Bus：早期在用的微服务配置中心，可以依托<code>GitHub</code>管理微服务的配置文件，这种现在也是有不少企业在用，但是需要自己独立部署一个微服务，和<code>Nacos</code>相比逊色了不少。</p> </li><li> <p>Apollo：携程开源项目Apollo，这个也是不少企业在用，陈某了解的不多，有兴趣的可以深入研究下。</p> <p></p> </li></ol> 
<h3>针对Spring Boot 适用的几种方案？</h3> 
<p>其实上述三种都可以在Spring Boot项目中适配，但是作为单体应用有些重了。</p> 
<p></p> 
<p>1. 如果项目是一个微服务的集群，业务功能复杂</p> 
<p>        建议： Spring Boot+Nacos</p> 
<p>2. 如果项目是单体服务，业务功能单一</p> 
<p>        建议： Spring Boot+Config+actuator</p> 
<p>                   Spring Boot+手动refresh</p> 
<p></p> 
<h3>针对Spring Boot+Nacos</h3> 
<p>阿里要做的其实是一个微服务生态，Nacos不仅仅可以作为Spring Cloud的配置和注册中心，也适配了Dubbo、K8s，官方文档中对于如何适配都做了详细的介绍，作者 这里就不再详细介绍了，如下图：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/00/de/CAKoLYeV_o.png"></p> 
<blockquote> 
 <p>当然Nacos对Spring、Spring Boot 项目同样适用。</p> 
</blockquote> 
<p>如何使用呢？这里作者只提供下思路，不做过多的深究，这篇在作者下个专栏Spring Cloud 进阶会详细介绍：</p> 
<ol><li> <p>下载对应版本的Nacos，启动项目，访问<code>http://localhost:8848</code>进入Nacos的管理界面；</p> </li><li> <p>Spring Boot 项目引入Nacos的配置依赖<code>nacos-config-spring-boot-starter</code>，配置Nacos管理中心的地址。</p> </li><li> <p><code>@NacosPropertySource</code>、<code>@NacosValue</code>两个注解结合完成。</p> </li></ol> 
<ul><li> <p><code>@NacosPropertySource</code>：指定配置中心的<code>dataId</code>，和是否自动刷新</p> </li><li> <p><code>@NacosValue</code>替代<code>@Value</code>注解完成属性的自动装配</p> </li></ul> 
<ol><li> <p>如果公司项目做了后台管理，则可以直接调用Nacos开放的API修改对应配置的值（替代了Nacos管理界面的手动操作），API的地址：https://nacos.io/zh-cn/docs/open-api.html</p> <p></p> </li></ol> 
<p></p> 
<h3>针对Spring Boot+Config+actuator</h3> 
<p>1. 添加Config的依赖，如下</p> 
<pre><code>&lt;!-- springCloud的依赖--&gt;
&lt;dependencyManagement&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
                &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
                &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;
                &lt;version&gt;Hoxton.SR3&lt;/version&gt;
                &lt;type&gt;pom&lt;/type&gt;
                &lt;scope&gt;import&lt;/scope&gt;
            &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/dependencyManagement&gt;

&lt;!-- config的依赖--&gt;
&lt;dependency&gt;
      &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
      &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt;
    &lt;/dependency&gt;

  &lt;!-- actuator的依赖--&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
      &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;
    &lt;/dependency&gt;</code></pre> 
<p>2. 配置文件中暴露Spring Boot的端点，如下：</p> 
<pre><code>management.endpoints.web.exposure.include=*</code></pre> 
<p>3. 配置文件中新增三个属性配置</p> 
<pre><code>config.version=22
config.app.name=dynamic-project
config.platform=mysql</code></pre> 
<p>4. 结合<code>@RefreshScope</code>注解动态刷新，写个Controller，如下：</p> 
<pre><code>@RestController
//@RefreshScope该注解必须标注，否则无法完成动态更新
@RefreshScope
public class DynamicConfigController {
    @Value("${config.version}")
    private String version;

    @Value("${config.app.name}")
    private String appName;

    @Value("${config.platform}")
    private String platform;


    @GetMapping("/show/version")
    public String test(){
        return "version="+version+"-appName="+appName+"-platform="+platform;
    }</code></pre> 
<p>5. 启动项目测试</p> 
<pre><code>1. 浏览器访问http://localhost:8080/show/version
2. 修改target目录下的配置文件，如下：
    config.version=33
    config.app.name=dynamic-project
    config.platform=ORACLE
3. POST请求http://localhost:8080/actuator/refresh接口，手动刷新下配置（必须，否则不能自动刷新）
4. 浏览器再次输入http://localhost:8080/show/version

可以看到，配置已经自动修改了</code></pre> 
<h3></h3> 
<h3>针对Spring Boot+手动refresh</h3> 
<p>经过源码分析，配置刷新是发布刷新事件，在监听器实现刷新</p> 
<pre><code>发布事件：
    以nacos为例 ： com.alibaba.cloud.nacos.refresh.NacosContextRefresher
    applicationContext.publishEvent(new RefreshEvent(this,null,"Refresh Nacos config"));



监听刷新事件： org.springframework.cloud.endpoint.event.RefreshEventListener

	@Override
	public void onApplicationEvent(ApplicationEvent event) {
		if (event instanceof ApplicationReadyEvent) {
			handle((ApplicationReadyEvent) event);
		}
		else if (event instanceof RefreshEvent) {
			handle((RefreshEvent) event);
		}
	}

	public void handle(ApplicationReadyEvent event) {
		this.ready.compareAndSet(false, true);
	}


执行刷新 ： org.springframework.cloud.context.refresh.ContextRefresher

	public synchronized Set&lt;String&gt; refresh() {
		Set&lt;String&gt; keys = refreshEnvironment();
		this.scope.refreshAll();
		return keys;
	}

	public synchronized Set&lt;String&gt; refreshEnvironment() {
		Map&lt;String, Object&gt; before = extract(
				this.context.getEnvironment().getPropertySources());
		addConfigFilesToEnvironment();
		Set&lt;String&gt; keys = changes(before,
				extract(this.context.getEnvironment().getPropertySources())).keySet();
		this.context.publishEvent(new EnvironmentChangeEvent(this.context, keys));
		return keys;
	}</code></pre> 
<p></p> 
<p>可以基于刷新自己实现动态加载</p> 
<pre><code>@GetMapping("/show/refresh")
    public String refresh(){
        //修改配置文件中属性
        HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;();
        map.put("config.version",99);
        map.put("config.app.name","appName");
        map.put("config.platform","ORACLE");
        MapPropertySource propertySource=new MapPropertySource("dynamic",map);
        //将修改后的配置设置到environment中
        environment.getPropertySources().addFirst(propertySource);
        //异步调用refresh方法，避免阻塞一直等待无响应
        new Thread(() -&gt; contextRefresher.refresh()).start();
        return "success";
    }</code></pre> 
<p>测试步骤</p> 
<pre><code>1. 浏览器访问http://localhost:8080/show/version
2. 修改target目录下的配置文件，如下：
    config.version=33
    config.app.name=dynamic-project
    config.platform=ORACLE
3. POST请求http://localhost:8080/actuator/refresh接口，手动刷新下配置（必须，否则不能自动刷新）
4. 浏览器再次输入http://localhost:8080/show/version

可以看到，配置已经自动修改了</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4afb7685c88e52b08569663a4f80e010/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">java开发环境配置</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/246114ad730fe91d2d6e41dce33ceb10/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">MySql经典语句练习50题 ---- 40 ~ 50题</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>