<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>跟着代码随想录练算法——二叉树（JS）（下） - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="跟着代码随想录练算法——二叉树（JS）（下）" />
<meta property="og:description" content="跟着代码随想录练算法——二叉树 [106. 从中序与后序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)[105. 从前序与中序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)[654. 最大二叉树](https://leetcode.cn/problems/maximum-binary-tree/)[617. 合并二叉树](https://leetcode.cn/problems/merge-two-binary-trees/)[700. 二叉搜索树中的搜索](https://leetcode.cn/problems/search-in-a-binary-search-tree/)[98. 验证二叉搜索树](https://leetcode.cn/problems/validate-binary-search-tree/)[530. 二叉搜索树的最小绝对差](https://leetcode.cn/problems/minimum-absolute-difference-in-bst/)[501. 二叉搜索树中的众数](https://leetcode.cn/problems/find-mode-in-binary-search-tree/)[236. 二叉树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/)[235. 二叉搜索树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/)[701. 二叉搜索树中的插入操作](https://leetcode.cn/problems/insert-into-a-binary-search-tree/)[450. 删除二叉搜索树中的节点](https://leetcode.cn/problems/delete-node-in-a-bst/)[669. 修剪二叉搜索树](https://leetcode.cn/problems/trim-a-binary-search-tree/)[108. 将有序数组转换为二叉搜索树](https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/)[538. 把二叉搜索树转换为累加树](https://leetcode.cn/problems/convert-bst-to-greater-tree/) 106. 从中序与后序遍历序列构造二叉树 当中序遍历和后序遍历都为空时，返回null当中序遍历和后序遍历只有一个值时，构造根节点，返回根节点即可拿出后序遍历最后一个元素，这个是当前根节点的val，根据它去分割中序序列，分成左子树的中序结果和右子树的中序结果由于中序和后序的序列长度一定是相等的，于是可以根据上一步分割出来的左子树的中序结果和右子树的中序结果的长度来分割后序序列，分为左子树的后序结果和右子树的后序结果根据前面两部得到的左右子树的中序和后序来递归建立左子树和右子树 /** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * } */ /** * @param {number[]} inorder * @param {number[]} postorder * @return {TreeNode} */ var buildTree = function(inorder, postorder) { if(inorder." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/83751889da689418f2169034438f1d46/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-07-21T13:17:01+08:00" />
<meta property="article:modified_time" content="2022-07-21T13:17:01+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">跟着代码随想录练算法——二叉树（JS）（下）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>跟着代码随想录练算法——二叉树</h4> 
 <ul><li><ul><li><ul><li><ul><li><a href="#106_httpsleetcodecnproblemsconstructbinarytreefrominorderandpostordertraversal_1" rel="nofollow">[106. 从中序与后序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)</a></li><li><a href="#105_httpsleetcodecnproblemsconstructbinarytreefrompreorderandinordertraversal_46" rel="nofollow">[105. 从前序与中序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)</a></li><li><a href="#654_httpsleetcodecnproblemsmaximumbinarytree_85" rel="nofollow">[654. 最大二叉树](https://leetcode.cn/problems/maximum-binary-tree/)</a></li><li><a href="#617_httpsleetcodecnproblemsmergetwobinarytrees_130" rel="nofollow">[617. 合并二叉树](https://leetcode.cn/problems/merge-two-binary-trees/)</a></li><li><a href="#700_httpsleetcodecnproblemssearchinabinarysearchtree_162" rel="nofollow">[700. 二叉搜索树中的搜索](https://leetcode.cn/problems/search-in-a-binary-search-tree/)</a></li><li><a href="#98_httpsleetcodecnproblemsvalidatebinarysearchtree_189" rel="nofollow">[98. 验证二叉搜索树](https://leetcode.cn/problems/validate-binary-search-tree/)</a></li><li><a href="#530_httpsleetcodecnproblemsminimumabsolutedifferenceinbst_245" rel="nofollow">[530. 二叉搜索树的最小绝对差](https://leetcode.cn/problems/minimum-absolute-difference-in-bst/)</a></li><li><a href="#501_httpsleetcodecnproblemsfindmodeinbinarysearchtree_281" rel="nofollow">[501. 二叉搜索树中的众数](https://leetcode.cn/problems/find-mode-in-binary-search-tree/)</a></li><li><a href="#236_httpsleetcodecnproblemslowestcommonancestorofabinarytree_344" rel="nofollow">[236. 二叉树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/)</a></li><li><a href="#235_httpsleetcodecnproblemslowestcommonancestorofabinarysearchtree_390" rel="nofollow">[235. 二叉搜索树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/)</a></li><li><a href="#701_httpsleetcodecnproblemsinsertintoabinarysearchtree_428" rel="nofollow">[701. 二叉搜索树中的插入操作](https://leetcode.cn/problems/insert-into-a-binary-search-tree/)</a></li><li><a href="#450_httpsleetcodecnproblemsdeletenodeinabst_461" rel="nofollow">[450. 删除二叉搜索树中的节点](https://leetcode.cn/problems/delete-node-in-a-bst/)</a></li><li><a href="#669_httpsleetcodecnproblemstrimabinarysearchtree_511" rel="nofollow">[669. 修剪二叉搜索树](https://leetcode.cn/problems/trim-a-binary-search-tree/)</a></li><li><a href="#108_httpsleetcodecnproblemsconvertsortedarraytobinarysearchtree_551" rel="nofollow">[108. 将有序数组转换为二叉搜索树](https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/)</a></li><li><a href="#538_httpsleetcodecnproblemsconvertbsttogreatertree_580" rel="nofollow">[538. 把二叉搜索树转换为累加树](https://leetcode.cn/problems/convert-bst-to-greater-tree/)</a></li></ul> 
   </li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h5><a id="106_httpsleetcodecnproblemsconstructbinarytreefrominorderandpostordertraversal_1"></a><a href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/" rel="nofollow">106. 从中序与后序遍历序列构造二叉树</a></h5> 
<ul><li>当中序遍历和后序遍历都为空时，返回null</li><li>当中序遍历和后序遍历只有一个值时，构造根节点，返回根节点即可</li><li>拿出后序遍历<strong>最后一个元素</strong>，这个是当前<strong>根节点的val</strong>，根据它去<strong>分割</strong>中序序列，分成<strong>左子树的中序结果</strong>和<strong>右子树的中序结果</strong></li><li>由于<strong>中序和后序的序列长度一定是相等</strong>的，于是可以根据上一步分割出来的左子树的中序结果和右子树的中序结果的<strong>长度</strong>来分割后序序列，分为<strong>左子树的后序结果</strong>和<strong>右子树的后序结果</strong></li><li>根据前面两部得到的左右子树的中序和后序来<strong>递归建立</strong>左子树和右子树</li></ul> 
<pre><code class="prism language-js"><span class="token comment">/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */</span>
<span class="token comment">/**
 * @param {number[]} inorder
 * @param {number[]} postorder
 * @return {TreeNode}
 */</span>
<span class="token keyword">var</span> <span class="token function-variable function">buildTree</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">inorder<span class="token punctuation">,</span> postorder</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>inorder<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">null</span>
    <span class="token keyword">let</span> rootValue <span class="token operator">=</span> postorder<span class="token punctuation">[</span>postorder<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span>
    <span class="token keyword">let</span> root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span>rootValue<span class="token punctuation">)</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>postorder<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> root
    <span class="token keyword">let</span> i
    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> inorder<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>inorder<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> rootValue<span class="token punctuation">)</span> <span class="token keyword">break</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">let</span> inLeft <span class="token operator">=</span> inorder<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span>
    <span class="token keyword">let</span> inRight <span class="token operator">=</span> inorder<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token comment">// console.log('inLeft,  inRight:',inLeft,  inRight)</span>
    <span class="token keyword">let</span> lenLeft <span class="token operator">=</span> inLeft<span class="token punctuation">.</span>length
    <span class="token keyword">let</span> lenRight <span class="token operator">=</span> inRight<span class="token punctuation">.</span>length
    <span class="token keyword">let</span> postleft <span class="token operator">=</span> postorder<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> lenLeft<span class="token punctuation">)</span>
    <span class="token keyword">let</span> postRight <span class="token operator">=</span> postorder<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span>lenLeft<span class="token punctuation">,</span> lenLeft <span class="token operator">+</span> lenRight<span class="token punctuation">)</span>
    <span class="token comment">// console.log('postleft,  postRight:',postleft,  postRight)</span>
    root<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token function">buildTree</span><span class="token punctuation">(</span>inLeft<span class="token punctuation">,</span> postleft<span class="token punctuation">)</span>
    root<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token function">buildTree</span><span class="token punctuation">(</span>inRight<span class="token punctuation">,</span> postRight<span class="token punctuation">)</span>
    <span class="token keyword">return</span> root
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<h5><a id="105_httpsleetcodecnproblemsconstructbinarytreefrompreorderandinordertraversal_46"></a><a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/" rel="nofollow">105. 从前序与中序遍历序列构造二叉树</a></h5> 
<p>与上一题类似，只是根节点的值取自前序序列的第一个元素，需要注意左右子树的前序序列分割的边界下标。</p> 
<pre><code class="prism language-js"><span class="token comment">/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */</span>
<span class="token comment">/**
 * @param {number[]} preorder
 * @param {number[]} inorder
 * @return {TreeNode}
 */</span>
<span class="token keyword">var</span> <span class="token function-variable function">buildTree</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">preorder<span class="token punctuation">,</span> inorder</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>preorder<span class="token punctuation">.</span>length <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">null</span>
    <span class="token keyword">let</span> rootVal <span class="token operator">=</span> preorder<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
    <span class="token keyword">let</span> root  <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span>rootVal<span class="token punctuation">)</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>preorder<span class="token punctuation">.</span>length <span class="token operator">===</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> root
    <span class="token keyword">let</span> i
    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> inorder<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>inorder<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> rootVal<span class="token punctuation">)</span> <span class="token keyword">break</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">let</span> inLeft <span class="token operator">=</span> inorder<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span>
    <span class="token keyword">let</span> inRight <span class="token operator">=</span> inorder<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token keyword">let</span> lenLeft <span class="token operator">=</span> inLeft<span class="token punctuation">.</span>length
    <span class="token keyword">let</span> lenRight <span class="token operator">=</span> inRight<span class="token punctuation">.</span>length
    <span class="token keyword">let</span> preLeft <span class="token operator">=</span> preorder<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span> <span class="token operator">+</span> lenLeft<span class="token punctuation">)</span>
    <span class="token keyword">let</span> preRight <span class="token operator">=</span> preorder<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">+</span> lenLeft<span class="token punctuation">)</span>
    root<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token function">buildTree</span><span class="token punctuation">(</span>preLeft<span class="token punctuation">,</span> inLeft<span class="token punctuation">)</span>
    root<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token function">buildTree</span><span class="token punctuation">(</span>preRight<span class="token punctuation">,</span> inRight<span class="token punctuation">)</span>
    <span class="token keyword">return</span> root
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<h5><a id="654_httpsleetcodecnproblemsmaximumbinarytree_85"></a><a href="https://leetcode.cn/problems/maximum-binary-tree/" rel="nofollow">654. 最大二叉树</a></h5> 
<ul><li>当 nums 中只有一个元素时：则到了叶子结点，直接返回构造出的叶子结点</li><li>当 nums 中元素大于1个时： 
  <ul><li>找到nums中的最大元素和它的下标</li><li>构造最大元素节点</li><li>分割数组</li><li>递归构造当前节点左子树和右子树</li><li>返回节点</li></ul> </li></ul> 
<pre><code class="prism language-js"><span class="token comment">/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */</span>
<span class="token comment">/**
 * @param {number[]} nums
 * @return {TreeNode}
 */</span>
<span class="token keyword">var</span> <span class="token function-variable function">constructMaximumBinaryTree</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">nums</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span>length <span class="token operator">===</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">let</span> node <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> node
    <span class="token punctuation">}</span>
    <span class="token keyword">let</span> max <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
    <span class="token keyword">let</span> index <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span>nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&gt;</span> max<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            max <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
            index <span class="token operator">=</span> i
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">let</span> node <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span>max<span class="token punctuation">)</span>
    <span class="token keyword">let</span> left <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> index<span class="token punctuation">)</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>left<span class="token punctuation">.</span>length <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> node<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token function">constructMaximumBinaryTree</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span>
    <span class="token keyword">let</span> right <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span>index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>right<span class="token punctuation">.</span>length <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> node<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token function">constructMaximumBinaryTree</span><span class="token punctuation">(</span>right<span class="token punctuation">)</span>
    <span class="token keyword">return</span> node
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<h5><a id="617_httpsleetcodecnproblemsmergetwobinarytrees_130"></a><a href="https://leetcode.cn/problems/merge-two-binary-trees/" rel="nofollow">617. 合并二叉树</a></h5> 
<ul><li>当 root1 为 null 时则返回root2（如果此时2也是null，也没关系，相当于返回null）</li><li>当 root2 为 null 时则返回root1</li><li>root1,2都不是null时，将2对应的val加到1上</li><li>递归左子树和右子树</li><li>返回root1</li></ul> 
<pre><code class="prism language-js"><span class="token comment">/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */</span>
<span class="token comment">/**
 * @param {TreeNode} root1
 * @param {TreeNode} root2
 * @return {TreeNode}
 */</span>
<span class="token keyword">var</span> <span class="token function-variable function">mergeTrees</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">root1<span class="token punctuation">,</span> root2</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>root1<span class="token punctuation">)</span> <span class="token keyword">return</span> root2
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>root2<span class="token punctuation">)</span> <span class="token keyword">return</span> root1
    root1<span class="token punctuation">.</span>val <span class="token operator">=</span> root1<span class="token punctuation">.</span>val <span class="token operator">+</span> root2<span class="token punctuation">.</span>val
    root1<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token function">mergeTrees</span><span class="token punctuation">(</span>root1<span class="token punctuation">.</span>left<span class="token punctuation">,</span> root2<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
    root1<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token function">mergeTrees</span><span class="token punctuation">(</span>root1<span class="token punctuation">.</span>right<span class="token punctuation">,</span> root2<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
    <span class="token keyword">return</span> root1 
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<h5><a id="700_httpsleetcodecnproblemssearchinabinarysearchtree_162"></a><a href="https://leetcode.cn/problems/search-in-a-binary-search-tree/" rel="nofollow">700. 二叉搜索树中的搜索</a></h5> 
<ul><li>当前节点为null或者当前节点的val和目标val相等，则返回当前节点</li><li>如果目标val大于当前节点val ，返回递归右子树的节点</li><li>如果目标val消于当前节点val ，返回递归左子树的节点</li></ul> 
<pre><code class="prism language-js"><span class="token comment">/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */</span>
<span class="token comment">/**
 * @param {TreeNode} root
 * @param {number} val
 * @return {TreeNode}
 */</span>
<span class="token keyword">var</span> <span class="token function-variable function">searchBST</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">root<span class="token punctuation">,</span> val</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>root <span class="token operator">||</span> root<span class="token punctuation">.</span>val <span class="token operator">==</span> val<span class="token punctuation">)</span> <span class="token keyword">return</span> root
    <span class="token keyword">if</span><span class="token punctuation">(</span>val <span class="token operator">&gt;</span> root<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token function">searchBST</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> val<span class="token punctuation">)</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>val <span class="token operator">&lt;</span> root<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token function">searchBST</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span>val<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<h5><a id="98_httpsleetcodecnproblemsvalidatebinarysearchtree_189"></a><a href="https://leetcode.cn/problems/validate-binary-search-tree/" rel="nofollow">98. 验证二叉搜索树</a></h5> 
<blockquote> 
 <p>搜索二叉树的中序遍历结果是递增的</p> 
</blockquote> 
<pre><code class="prism language-js"><span class="token comment">/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */</span>
<span class="token comment">/**
 * @param {TreeNode} root
 * @return {boolean}
 */</span>
<span class="token keyword">var</span> <span class="token function-variable function">isValidBST</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">let</span> ans <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token keyword">function</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token parameter">node</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>node<span class="token punctuation">)</span> <span class="token keyword">return</span>
        <span class="token function">dfs</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
        ans<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span>
        <span class="token function">dfs</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> ans<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>ans<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> ans<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<blockquote> 
 <p>也可以在递归的过程中判断：</p> 
 <ul><li>如果当前节点是null，返回true</li><li>递归左子树</li><li>pre用来记录中序遍历当前节点的前一个节点，如果当前节点值小于等于pre的值，返回false</li><li>递归右子树</li><li>左右子树都是搜索二叉树，返回true</li></ul> 
</blockquote> 
<pre><code class="prism language-js"><span class="token keyword">var</span> <span class="token function-variable function">isValidBST</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">let</span> pre <span class="token operator">=</span> <span class="token keyword">null</span>
    <span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token parameter">node</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>node<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span>
        <span class="token keyword">let</span> left <span class="token operator">=</span> <span class="token function">fn</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>pre <span class="token operator">&amp;&amp;</span> node<span class="token punctuation">.</span>val <span class="token operator">&lt;=</span> pre<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span>
        pre <span class="token operator">=</span> node
        <span class="token keyword">let</span> right <span class="token operator">=</span> <span class="token function">fn</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
        <span class="token keyword">return</span> left <span class="token operator">&amp;&amp;</span> right
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token function">fn</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<h5><a id="530_httpsleetcodecnproblemsminimumabsolutedifferenceinbst_245"></a><a href="https://leetcode.cn/problems/minimum-absolute-difference-in-bst/" rel="nofollow">530. 二叉搜索树的最小绝对差</a></h5> 
<blockquote> 
 <ol><li> <p>可以先中序遍历二叉树，得到递增数组，然后在这个数组上求得最小绝对值</p> </li><li> <p>也可以在中序遍历时记录上一个节点pre，以及当前节点和上一个节点的差值，更新差值</p> <p>这里实现一下方法2</p> </li></ol> 
</blockquote> 
<pre><code class="prism language-js"><span class="token comment">/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */</span>
<span class="token comment">/**
 * @param {TreeNode} root
 * @return {number}
 */</span>
<span class="token keyword">var</span> <span class="token function-variable function">getMinimumDifference</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">let</span> pre <span class="token operator">=</span> <span class="token keyword">null</span>
    <span class="token keyword">let</span> min <span class="token operator">=</span> <span class="token number">100001</span>
    <span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token parameter">node</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>node<span class="token punctuation">)</span> <span class="token keyword">return</span>
        <span class="token function">fn</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>pre <span class="token operator">&amp;&amp;</span> node<span class="token punctuation">.</span>val <span class="token operator">-</span> pre<span class="token punctuation">.</span>val<span class="token operator">&lt;</span> min<span class="token punctuation">)</span> min <span class="token operator">=</span> node<span class="token punctuation">.</span>val <span class="token operator">-</span> pre<span class="token punctuation">.</span>val
        pre <span class="token operator">=</span> node
        <span class="token function">fn</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token function">fn</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span>
    <span class="token keyword">return</span> min
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<h5><a id="501_httpsleetcodecnproblemsfindmodeinbinarysearchtree_281"></a><a href="https://leetcode.cn/problems/find-mode-in-binary-search-tree/" rel="nofollow">501. 二叉搜索树中的众数</a></h5> 
<blockquote> 
 <p>可以先得到中序遍历数组然后再数组上操作，也可以在遍历时操作，这里选择后者</p> 
 <p>ans 存返回的众数<strong>结果</strong>，max 存<strong>最多次数</strong>，pre 是中序对应的<strong>前一个节点</strong>，count 用于<strong>计数</strong></p> 
 <p>如果当前节点val等于pre的val，则计数器 + 1,</p> 
 <p>如果当前节点val不等于pre,比较当前计数器与max比较：</p> 
 <ul><li>count大于max，则先清空ans，然后将pre对应的值放入ans,再更新max为当前count</li><li>count等于max，将pre对应的值push进ans</li><li>小于则忽略</li></ul> 
 <p>最后还要再加一次判断</p> 
</blockquote> 
<pre><code class="prism language-js"><span class="token comment">/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */</span>
<span class="token comment">/**
 * @param {TreeNode} root
 * @return {number[]}
 */</span>
<span class="token keyword">var</span> <span class="token function-variable function">findMode</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">let</span> ans <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token keyword">let</span> max <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token keyword">let</span> count <span class="token operator">=</span> <span class="token number">1</span>
    <span class="token keyword">let</span> pre <span class="token operator">=</span> <span class="token keyword">null</span>
    <span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token parameter">node</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>node<span class="token punctuation">)</span> <span class="token keyword">return</span>
        <span class="token function">fn</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>pre<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>pre<span class="token punctuation">.</span>val <span class="token operator">==</span> node<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                count <span class="token operator">++</span>
            <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{<!-- --></span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>count <span class="token operator">&gt;</span> max<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                    ans <span class="token operator">=</span> <span class="token punctuation">[</span>pre<span class="token punctuation">.</span>val<span class="token punctuation">]</span>
                    max <span class="token operator">=</span> count
                <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>count <span class="token operator">==</span> max<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                    ans<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>pre<span class="token punctuation">.</span>val<span class="token punctuation">)</span>
                <span class="token punctuation">}</span>
                count <span class="token operator">=</span> <span class="token number">1</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        pre <span class="token operator">=</span> node
        <span class="token function">fn</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token function">fn</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>count <span class="token operator">&gt;</span> max<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        ans <span class="token operator">=</span> <span class="token punctuation">[</span>pre<span class="token punctuation">.</span>val<span class="token punctuation">]</span>
    <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>count <span class="token operator">==</span> max<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        ans<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>pre<span class="token punctuation">.</span>val<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> ans
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<h5><a id="236_httpsleetcodecnproblemslowestcommonancestorofabinarytree_344"></a><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/" rel="nofollow">236. 二叉树的最近公共祖先</a></h5> 
<blockquote> 
 <p>左右子树中一边有p，一边有q；或者当前节点是p或者q，自己孩子节点有q或者q</p> 
 <p>要从叶子节点不断向根节点寻找，只能使用携带返回值的回溯算法</p> 
</blockquote> 
<p>递归函数返回值：</p> 
<ul><li>如果当前节点等于p或者q，返回当前节点</li><li>如果找到祖先节点，返回祖先节点</li></ul> 
<p>递归函数的逻辑:</p> 
<ol><li>如果当前节点等于p，或者q，或者null 返回该节点</li><li>递归左子树和右子树，得到返回值</li><li>如果左子树和右子树的返回值都不是null，表明一边有p，一边有q，则该节点就是需要寻找的最近祖先节点，将该节点作为返回值</li><li>如果左右子树只有一个返回值不是null，则将该返回值返回</li><li>如果左右子树的返回值都是null，则返回 null</li></ol> 
<pre><code class="prism language-js"><span class="token comment">/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */</span>
<span class="token comment">/**
 * @param {TreeNode} root
 * @param {TreeNode} p
 * @param {TreeNode} q
 * @return {TreeNode}
 */</span>
<span class="token keyword">var</span> <span class="token function-variable function">lowestCommonAncestor</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">root<span class="token punctuation">,</span> p<span class="token punctuation">,</span> q</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> root <span class="token operator">==</span> p <span class="token operator">||</span>root <span class="token operator">==</span> q<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> root
    <span class="token punctuation">}</span>
    <span class="token keyword">let</span> left <span class="token operator">=</span> <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> p<span class="token punctuation">,</span> q<span class="token punctuation">)</span>
    <span class="token keyword">let</span> right <span class="token operator">=</span> <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> p<span class="token punctuation">,</span> q<span class="token punctuation">)</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>left <span class="token operator">&amp;&amp;</span> right<span class="token punctuation">)</span> <span class="token keyword">return</span> root
    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>left <span class="token operator">&amp;&amp;</span> right<span class="token punctuation">)</span> <span class="token keyword">return</span> right
    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>right <span class="token operator">&amp;&amp;</span> left<span class="token punctuation">)</span> <span class="token keyword">return</span> left
    <span class="token keyword">else</span> <span class="token keyword">return</span> <span class="token keyword">null</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<h5><a id="235_httpsleetcodecnproblemslowestcommonancestorofabinarysearchtree_390"></a><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/" rel="nofollow">235. 二叉搜索树的最近公共祖先</a></h5> 
<p>在寻找公共祖先时利用好搜索二叉树的性质，如果当前节点处于[p,q]或者[q,p]区间内，则为最近公共祖先。</p> 
<p>当节点值大于p,q的值,则继续在其左子树上搜索</p> 
<p>当节点值小于p,q的值在其右子树上搜索</p> 
<pre><code class="prism language-js"><span class="token comment">/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */</span>

<span class="token comment">/**
 * @param {TreeNode} root
 * @param {TreeNode} p
 * @param {TreeNode} q
 * @return {TreeNode}
 */</span>
<span class="token keyword">var</span> <span class="token function-variable function">lowestCommonAncestor</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">root<span class="token punctuation">,</span> p<span class="token punctuation">,</span> q</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">null</span>
    
    <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val <span class="token operator">&gt;</span> p<span class="token punctuation">.</span>val <span class="token operator">&amp;&amp;</span> root<span class="token punctuation">.</span>val <span class="token operator">&gt;</span> q<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">let</span> left <span class="token operator">=</span> <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> p<span class="token punctuation">,</span> q<span class="token punctuation">)</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span> <span class="token keyword">return</span> left
    <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> p<span class="token punctuation">.</span>val <span class="token operator">&amp;&amp;</span> root<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> q<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">let</span> right <span class="token operator">=</span> <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> p<span class="token punctuation">,</span> q<span class="token punctuation">)</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>right<span class="token punctuation">)</span> <span class="token keyword">return</span> right
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> root
    
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<h5><a id="701_httpsleetcodecnproblemsinsertintoabinarysearchtree_428"></a><a href="https://leetcode.cn/problems/insert-into-a-binary-search-tree/" rel="nofollow">701. 二叉搜索树中的插入操作</a></h5> 
<p>遍历二叉搜索树，如果节点值小于插入元素，向右；如果节点值大于插入元素，向左，当遍历到空节点，则为插入元素的合适位置。</p> 
<pre><code class="prism language-js"><span class="token comment">/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */</span>
<span class="token comment">/**
 * @param {TreeNode} root
 * @param {number} val
 * @return {TreeNode}
 */</span>
<span class="token keyword">var</span> <span class="token function-variable function">insertIntoBST</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">root<span class="token punctuation">,</span> val</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 找到合适位置</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">let</span> node <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span>
        <span class="token keyword">return</span> node
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> val<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        root<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token function">insertIntoBST</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> val<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val <span class="token operator">&gt;</span> val<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        root<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token function">insertIntoBST</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> val<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> root
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<h5><a id="450_httpsleetcodecnproblemsdeletenodeinabst_461"></a><a href="https://leetcode.cn/problems/delete-node-in-a-bst/" rel="nofollow">450. 删除二叉搜索树中的节点</a></h5> 
<blockquote> 
 <p>像增加节点一样，使用递归函数的返回值来删除节点，删除节点的几种情况：</p> 
</blockquote> 
<ul><li>没有找到删除节点：递归到空节点，返回 null</li><li>找到删除节点： 
  <ul><li>节点左右孩子都是空节点：直接删除该节点，返回null即可</li><li>节点没有左孩子，有右孩子：返回节点右孩子</li><li>节点有左孩子，没有右孩子：返回节点左孩子</li><li>节点<strong>既有左孩子也有右孩子</strong>（比较难处理）：将节点左孩子放到右孩子最左边节点的左孩子上，返回该节点的右孩子作为新节点</li></ul> </li></ul> 
<pre><code class="prism language-js"><span class="token comment">/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */</span>
<span class="token comment">/**
 * @param {TreeNode} root
 * @param {number} key
 * @return {TreeNode}
 */</span>
<span class="token keyword">var</span> <span class="token function-variable function">deleteNode</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">root<span class="token punctuation">,</span> key</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">null</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> key<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        root<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token function">deleteNode</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> key<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val <span class="token operator">&gt;</span> key<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        root<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token function">deleteNode</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> key<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">.</span>left <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">null</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">.</span>left <span class="token operator">&amp;&amp;</span> root<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token keyword">return</span> root<span class="token punctuation">.</span>right
        <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">.</span>right <span class="token operator">&amp;&amp;</span> root<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token keyword">return</span> root<span class="token punctuation">.</span>left
        <span class="token keyword">else</span><span class="token punctuation">{<!-- --></span>
            <span class="token keyword">let</span> p <span class="token operator">=</span> root<span class="token punctuation">.</span>right
            <span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                p <span class="token operator">=</span> p<span class="token punctuation">.</span>left
            <span class="token punctuation">}</span>
            <span class="token comment">// console.log('右子树最左边的孩子：',p.val)</span>
            p<span class="token punctuation">.</span>left <span class="token operator">=</span> root<span class="token punctuation">.</span>left
            <span class="token keyword">return</span> root<span class="token punctuation">.</span>right
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    
    <span class="token keyword">return</span> root
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<h5><a id="669_httpsleetcodecnproblemstrimabinarysearchtree_511"></a><a href="https://leetcode.cn/problems/trim-a-binary-search-tree/" rel="nofollow">669. 修剪二叉搜索树</a></h5> 
<p>如果当前节点为空节点，则直接返回 null</p> 
<p>如果当前节点值小于下界low，则递归右子树，将递归右子树的结果替代当前节点作为返回值</p> 
<p>如果当前节点值大于上界high，则递归左子树，将递归左子树的结果头戴当前节点作为返回值</p> 
<p>如果当前节点在[low,high]中，当前节点符合条件，递归其左子树和右子树</p> 
<pre><code class="prism language-js"><span class="token comment">/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */</span>
<span class="token comment">/**
 * @param {TreeNode} root
 * @param {number} low
 * @param {number} high
 * @return {TreeNode}
 */</span>
<span class="token keyword">var</span> <span class="token function-variable function">trimBST</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">root<span class="token punctuation">,</span> low<span class="token punctuation">,</span> high</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">null</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> low<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">let</span> right <span class="token operator">=</span> <span class="token function">trimBST</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> low<span class="token punctuation">,</span> high<span class="token punctuation">)</span>
        <span class="token keyword">return</span> right
    <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val <span class="token operator">&gt;</span> high<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">let</span> left <span class="token operator">=</span> <span class="token function">trimBST</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> low<span class="token punctuation">,</span> high<span class="token punctuation">)</span>
        <span class="token keyword">return</span> left
    <span class="token punctuation">}</span>
    root<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token function">trimBST</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> low<span class="token punctuation">,</span> high<span class="token punctuation">)</span>
    root<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token function">trimBST</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> low<span class="token punctuation">,</span> high<span class="token punctuation">)</span>
    <span class="token keyword">return</span> root
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<h5><a id="108_httpsleetcodecnproblemsconvertsortedarraytobinarysearchtree_551"></a><a href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/" rel="nofollow">108. 将有序数组转换为二叉搜索树</a></h5> 
<p>和前面的构造最大二叉树类似，不断寻找切割点然后再递归左边和右边，不过这里的切割点就是中点，这样够构造的二叉树就是平衡二叉树。如果有偶数个元素的话切割点两个都可以。</p> 
<pre><code class="prism language-js"><span class="token comment">/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */</span>
<span class="token comment">/**
 * @param {number[]} nums
 * @return {TreeNode}
 */</span>
<span class="token keyword">var</span> <span class="token function-variable function">sortedArrayToBST</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">nums</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>nums <span class="token operator">||</span> nums<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">null</span>
    <span class="token keyword">let</span> index <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span>length<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span>
    <span class="token keyword">let</span> numsLeft <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span>index<span class="token punctuation">)</span>
    <span class="token keyword">let</span> numsRight <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span>index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token keyword">let</span> node <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span>
    node<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token function">sortedArrayToBST</span><span class="token punctuation">(</span>numsLeft<span class="token punctuation">)</span>
    node<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token function">sortedArrayToBST</span><span class="token punctuation">(</span>numsRight<span class="token punctuation">)</span>
    <span class="token keyword">return</span> node
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<h5><a id="538_httpsleetcodecnproblemsconvertbsttogreatertree_580"></a><a href="https://leetcode.cn/problems/convert-bst-to-greater-tree/" rel="nofollow">538. 把二叉搜索树转换为累加树</a></h5> 
<p>要将大于自身的节点累加到当前节点上，所有需要先遍历右子树，然后需要一个指针表示前一个节点，将前一个节点的值累加到当前节点，再去遍历左子树。</p> 
<pre><code class="prism language-js"><span class="token comment">/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */</span>
<span class="token comment">/**
 * @param {TreeNode} root
 * @return {TreeNode}
 */</span>
<span class="token keyword">var</span> <span class="token function-variable function">convertBST</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">let</span> pre <span class="token operator">=</span> <span class="token keyword">null</span>
    <span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token parameter">node</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>node<span class="token punctuation">)</span> <span class="token keyword">return</span>
        <span class="token function">fn</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>pre<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            node<span class="token punctuation">.</span>val <span class="token operator">=</span> node<span class="token punctuation">.</span>val <span class="token operator">+</span> pre<span class="token punctuation">.</span>val
        <span class="token punctuation">}</span>
        pre <span class="token operator">=</span> node
        <span class="token function">fn</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token function">fn</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span>
    <span class="token keyword">return</span> root
<span class="token punctuation">}</span><span class="token punctuation">;</span>  
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/53e6995c0500ddd898848b9f5c2530b0/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【前端性能优化】前端懒加载</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b408851415a76530a17cbc5c6173817a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">常用benchmark小结</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>