<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>MaskrcnnBenchmark 源码解析-模型定义(modeling)之骨架网络(backbone) - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="MaskrcnnBenchmark 源码解析-模型定义(modeling)之骨架网络(backbone)" />
<meta property="og:description" content="源码文件 不论是在训练脚本文件 train_net.py 还是在测试脚本文件 test_net.py 中, 都调用了 build_detection_model(cfg) 函数来创建模型, 该函数封装了模型定义的内部细节, 使得我们可以通过配置文件轻松的组合出不同类型的模型, 为了能够更好的了解模型的内部细节, 我们有必要知道这些模型是如何被定义, 又是如何组合到一起的, 为此我们需要对 MaskrcnnBenchmark 的 modeling 文件夹进行解析, 该文件夹的结构及文件关系如下所示(位于 ./maskrcnn_benchmark/modeling/ 文件夹下):
backbone backbone.pyfpn.pyresnet.py detector detectors.pygeneralized_rcnn.py roi_heads box_head box_head.pyinference.pyloss.pyroi_box_feature_extractors.pyroi_box_predictors.py mask_head inference.pyloss.pymask_head.pyroi_mask_feature_extractors.py rpn anchor_generator.pyinference.pyloss.pyrpn.py balanced_positive_negative_sampler.pybox_coder.pymatcher.pypoolers.pyregistry.pyutils.py 下面, 我们根据各个文件和函数之间的逻辑关系(而不是上面的文件顺序), 对 MaskrcnnBenchmark 的模型定义模块展开详细的解析和讨论. 想要透彻了解此部分的代码, 只需要按照本文的顺序仔细阅读即可.
detector 模型定义入口 第一部分是 detector 文件夹, 该文件夹中的两个文件定义了是整个 modeling 模块的入口. 文件解析如下
## detectors.py 文件解析 第一个文件 detectors.py 中的代码只有短短几行, 其主要功能就是根据给定的配置信息实例化一个 class GeneralizedRCNN 的对象, 代码如下所示:
# ./maskrcnn_benchmark/modeling/detector/detectors.py from .generalized_rcnn import GeneralizedRCNN _DETECTION_META_ARCHITECTURES = {&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/dab756f2255f78b6ff07ac3d3427ffbe/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-12-14T16:38:59+08:00" />
<meta property="article:modified_time" content="2018-12-14T16:38:59+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">MaskrcnnBenchmark 源码解析-模型定义(modeling)之骨架网络(backbone)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="_0"></a>源码文件</h2> 
<p>不论是在训练脚本文件 <code>train_net.py</code> 还是在测试脚本文件 <code>test_net.py</code> 中, 都调用了 <code>build_detection_model(cfg)</code> 函数来创建模型, 该函数封装了模型定义的内部细节, 使得我们可以通过配置文件轻松的组合出不同类型的模型, 为了能够更好的了解模型的内部细节, 我们有必要知道这些模型是如何被定义, 又是如何组合到一起的, 为此我们需要对 MaskrcnnBenchmark 的 modeling 文件夹进行解析, 该文件夹的结构及文件关系如下所示(位于 <code>./maskrcnn_benchmark/modeling/</code> 文件夹下):</p> 
<ul><li>backbone 
  <ul><li><a href="#backbone" rel="nofollow">backbone.py</a></li><li><a href="#fpn" rel="nofollow">fpn.py</a></li><li><a href="#resnet" rel="nofollow">resnet.py</a></li></ul> </li><li>detector 
  <ul><li><a href="#detector" rel="nofollow">detectors.py</a></li><li><a href="#generalized_rcnn" rel="nofollow">generalized_rcnn.py</a></li></ul> </li><li>roi_heads 
  <ul><li>box_head 
    <ul><li><a href="#box_head" rel="nofollow">box_head.py</a></li><li><a href="#inference" rel="nofollow">inference.py</a></li><li><a href="#loss" rel="nofollow">loss.py</a></li><li><a href="#roi_box_feature_extractors" rel="nofollow">roi_box_feature_extractors.py</a></li><li><a href="#roi_box_predictors" rel="nofollow">roi_box_predictors.py</a></li></ul> </li><li>mask_head 
    <ul><li><a href="http://inference.py" rel="nofollow">inference.py</a></li><li><a href="http://loss.py" rel="nofollow">loss.py</a></li><li>mask_head.py</li><li>roi_mask_feature_extractors.py</li></ul> </li></ul> </li><li>rpn 
  <ul><li><a href="#generator" rel="nofollow">anchor_generator.py</a></li><li><a href="#inference" rel="nofollow">inference.py</a></li><li><a href="#loss" rel="nofollow">loss.py</a></li><li><a href="#rpn" rel="nofollow">rpn.py</a></li></ul> </li><li><a href="#balanced_positive_negative_sampler" rel="nofollow">balanced_positive_negative_sampler.py</a></li><li><a href="#box_coder" rel="nofollow">box_coder.py</a></li><li><a href="#matcher" rel="nofollow">matcher.py</a></li><li><a href="#poolers" rel="nofollow">poolers.py</a></li><li><a href="#registry" rel="nofollow">registry.py</a></li><li><a href="#utils" rel="nofollow">utils.py</a></li></ul> 
<p>下面, 我们根据各个文件和函数之间的逻辑关系(而不是上面的文件顺序), 对 MaskrcnnBenchmark 的模型定义模块展开详细的解析和讨论. 想要透彻了解此部分的代码, 只需要按照本文的顺序仔细阅读即可.</p> 
<h2><a id="detector__38"></a>detector 模型定义入口</h2> 
<p>第一部分是 <code>detector</code> 文件夹, 该文件夹中的两个文件定义了是整个 <code>modeling</code> 模块的入口. 文件解析如下</p> 
<span id="detectors"> ## detectors.py 文件解析 </span> 
<p>第一个文件 <code>detectors.py</code> 中的代码只有短短几行, 其主要功能就是根据给定的配置信息实例化一个 <code>class GeneralizedRCNN</code> 的对象, 代码如下所示:</p> 
<pre><code class="prism language-py"><span class="token comment"># ./maskrcnn_benchmark/modeling/detector/detectors.py</span>

<span class="token keyword">from</span> <span class="token punctuation">.</span>generalized_rcnn <span class="token keyword">import</span> GeneralizedRCNN

_DETECTION_META_ARCHITECTURES <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token string">"GeneralizedRCNN"</span><span class="token punctuation">:</span> GeneralizedRCNN<span class="token punctuation">}</span>

<span class="token comment"># 该函数是创建模型的入口函数, 也是唯一的模型创建函数</span>
<span class="token keyword">def</span> <span class="token function">build_detection_model</span><span class="token punctuation">(</span>cfg<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token comment"># 构建一个模型字典, 虽然只有一对键值, 但是可以方便后续的扩展</span>
    meta_arch <span class="token operator">=</span> _DETECTION_META_ARCHITECTURES<span class="token punctuation">[</span>cfg<span class="token punctuation">.</span>MODEL<span class="token punctuation">.</span>META_ARCHITECTURE<span class="token punctuation">]</span>
    <span class="token comment"># 下面的语句等价于</span>
    <span class="token comment"># return GeneralizedRCNN(cfg)</span>
    <span class="token keyword">return</span> meta_arch<span class="token punctuation">(</span>cfg<span class="token punctuation">)</span>
</code></pre> 
<p>上面的代码利用配置信息 <code>cfg</code> 实例化了一个 <code>class GeneralizedRCNN</code> 类, 该类定义在 <code>./maskrcnn_benchmark/modeling/detector/generalized_rcnn.py</code> 文件中, 关于该文件的解析请看下一节.</p> 
<span id="generalized_rcnn"> ## generalized_rcnn.py 文件解析 </span> 
<p>该文件定义了 MaskrcnnBenchmark 的 GeneralizedRCNN 类, 用于表示各种组合后的目标检测模型, 代码解析如下:</p> 
<pre><code class="prism language-py"><span class="token keyword">import</span> torch
<span class="token keyword">from</span> torch <span class="token keyword">import</span> nn

<span class="token comment"># 该函数定义于 ./maskrcnn_benchmark/structures/image_list.py 文件中</span>
<span class="token keyword">from</span> maskrcnn_benchmark<span class="token punctuation">.</span>structures<span class="token punctuation">.</span>image_list <span class="token keyword">import</span> to_image_list

<span class="token keyword">from</span> <span class="token punctuation">.</span><span class="token punctuation">.</span>backbone <span class="token keyword">import</span> build_backbone
<span class="token keyword">from</span> <span class="token punctuation">.</span><span class="token punctuation">.</span>rpn<span class="token punctuation">.</span>rpn <span class="token keyword">import</span> build_rpn
<span class="token keyword">from</span> <span class="token punctuation">.</span><span class="token punctuation">.</span>roi_heads<span class="token punctuation">.</span>roi_heads <span class="token keyword">import</span> build_roi_heads

<span class="token comment"># 定义类的具体实现</span>
<span class="token keyword">class</span> <span class="token class-name">GeneralizedRCNN</span><span class="token punctuation">(</span>nn<span class="token punctuation">.</span>Module<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token comment"># 该类是 MaskrcnnBenchmark 中所有模型的共同抽象, 目前支持 boxes 和 masks 两种形式的标签</span>
    <span class="token comment"># 该类主要包含以下三个部分:</span>
    <span class="token comment"># - backbone</span>
    <span class="token comment"># - rpn(option)</span>
    <span class="token comment"># - heads: 利用前面网络输出的 features 和 proposals 来计算 detections / masks.</span>

    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> cfg<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment"># 根据配置信息初始化模型</span>
        <span class="token builtin">super</span><span class="token punctuation">(</span>GeneralizedRCNN<span class="token punctuation">,</span> self<span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token punctuation">)</span>

        <span class="token comment"># 根据配置信息创建 backbone 网络</span>
        self<span class="token punctuation">.</span>backbone <span class="token operator">=</span> build_backbone<span class="token punctuation">(</span>cfg<span class="token punctuation">)</span>

        <span class="token comment"># 根据配置信息创建 rpn 网络</span>
        self<span class="token punctuation">.</span>rpn <span class="token operator">=</span> build_rpn<span class="token punctuation">(</span>cfg<span class="token punctuation">)</span>

        <span class="token comment"># 根据配置信息创建 roi_heads</span>
        self<span class="token punctuation">.</span>roi_heads <span class="token operator">=</span> build_roi_heads<span class="token punctuation">(</span>cfg<span class="token punctuation">)</span>

    <span class="token keyword">def</span> <span class="token function">forward</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> images<span class="token punctuation">,</span> targets<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment"># 定义模型的前向传播过程</span>
        <span class="token comment"># images (list[Tensor] or ImageList)</span>
        <span class="token comment"># targets (list[BoxList])</span>
        <span class="token comment"># 返回值: result (list[BoxList] or dict[Tensor])</span>
        <span class="token comment"># 在训练阶段, 返回字典类型的模型损失, 在测试阶段, 返回模型的预测结果.</span>

        <span class="token comment"># 当 training 设置为 True 时, 必须提供 targets.</span>
        <span class="token keyword">if</span> self<span class="token punctuation">.</span>training <span class="token operator">and</span> targets <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
            <span class="token keyword">raise</span> ValueError<span class="token punctuation">(</span><span class="token string">"In training mode, targets should be passed"</span><span class="token punctuation">)</span>

        images <span class="token operator">=</span> to_image_list<span class="token punctuation">(</span>images<span class="token punctuation">)</span> <span class="token comment"># 将图片的数据类型转换成 ImageList</span>

        <span class="token comment"># 利用 backbone 网络获取图片的 features</span>
        features <span class="token operator">=</span>  self<span class="token punctuation">.</span>backbone<span class="token punctuation">(</span>images<span class="token punctuation">.</span>tensors<span class="token punctuation">)</span>

        <span class="token comment"># 利用 rpn 网络获取 proposals 和相应的 loss</span>
        proposals<span class="token punctuation">,</span> proposal_losses <span class="token operator">=</span> self<span class="token punctuation">.</span>rpn<span class="token punctuation">(</span>images<span class="token punctuation">,</span> features<span class="token punctuation">,</span> targets<span class="token punctuation">)</span>
        <span class="token keyword">if</span> self<span class="token punctuation">.</span>roi_heads<span class="token punctuation">:</span> <span class="token comment"># 如何 roi_heads 不为 None 的话, 就计算其输出的结果</span>
            x<span class="token punctuation">,</span> result<span class="token punctuation">,</span> detector_losses <span class="token operator">=</span> self<span class="token punctuation">.</span>roi_heads<span class="token punctuation">(</span>features<span class="token punctuation">,</span> proposals<span class="token punctuation">,</span> targets<span class="token punctuation">)</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            <span class="token comment"># RPN-only models don't have roi_heads</span>
            x <span class="token operator">=</span> features
            result <span class="token operator">=</span> proposals
            detector_losses <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
        <span class="token keyword">if</span> self<span class="token punctuation">.</span>training<span class="token punctuation">:</span> <span class="token comment"># 在训练模式下, 输出损失值</span>
            losses <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
            losses<span class="token punctuation">.</span>update<span class="token punctuation">(</span>detector_losses<span class="token punctuation">)</span>
            losses<span class="token punctuation">.</span>update<span class="token punctuation">(</span>proposal_losses<span class="token punctuation">)</span>

        <span class="token keyword">return</span> result <span class="token comment"># 如果不在训练模式下, 则输出模型的预测结果.</span>
</code></pre> 
<p>上面的代码中, <code>to_image_list</code> 函数位于 MaskrcnnBenchmark 的结构模块当中, 具体解析可以看<a href="../PyTorch-MaskrcnnBenchmark-structures" rel="nofollow">structures</a>. 另外, 可以看出, MaskrcnnBenchmark 模型的创建主要依赖于三个函数, 即 <code>build_backbone(cfg)</code>, <code>build_rpn(cfg)</code>, <code>build_roi_heads(cfg)</code>. 下面, 我们就按照模型定义的顺序, 分别讲解这三个函数的内部实现</p> 
<h2><a id="backbone__135"></a>backbone 模型骨架定义</h2> 
<p><code>modeling/</code> 文件夹下面的 <code>backbone/</code> 文件夹定义了有关模型骨架的相关代码, 该文件夹中总共三个主要的文件, 分别为:</p> 
<ul><li><code>backbone.py</code></li><li><code>fpn.py</code></li><li><code>resnet.py</code></li></ul> 
<span id="backbone"> ## backbone.py 文件解析 </span> 
<p>我们在定义骨架网络时使用到的 <code>build_backbone(cfg)</code> 函数, 正位于 <code>./maskrcnn_benchmark/modeling/backbone/backbone.py</code> 文件中, 因此, 我们首先来看看该文件的内部实现.</p> 
<pre><code class="prism language-py"><span class="token keyword">from</span> collections <span class="token keyword">import</span> OrderedDict <span class="token comment"># 导入有序字典</span>

<span class="token keyword">from</span> torch <span class="token keyword">import</span> nn

<span class="token comment"># 注册器, 用于管理 module 的注册, 使得可以像使用字典一样使用 module</span>
<span class="token keyword">from</span> maskrcnn_benchmark<span class="token punctuation">.</span>modeling <span class="token keyword">import</span> registry

<span class="token keyword">from</span> <span class="token punctuation">.</span> <span class="token keyword">import</span> fpn <span class="token keyword">as</span> fpn_module <span class="token comment"># 同文件夹下的文件, 会在后面讲解</span>
<span class="token keyword">from</span> <span class="token punctuation">.</span> <span class="token keyword">import</span> resnet <span class="token comment"># 同文件夹下的文件, 会在后面讲解</span>

<span class="token comment"># 创建 resnet 骨架网络, 根据配置信息会被后面的 build_backbone() 函数调用</span>
@registry<span class="token punctuation">.</span>BACKBONES<span class="token punctuation">.</span>register<span class="token punctuation">(</span><span class="token string">"R-50-C4"</span><span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">build_resnet_backbone</span><span class="token punctuation">(</span>cfg<span class="token punctuation">)</span><span class="token punctuation">:</span>
    body <span class="token operator">=</span> resnet<span class="token punctuation">.</span>ResNet<span class="token punctuation">(</span>cfg<span class="token punctuation">)</span> <span class="token comment"># resnet.py 文件中的 class ResNet(cfg)</span>
    model <span class="token operator">=</span> nn<span class="token punctuation">.</span>Sequential<span class="token punctuation">(</span>OrderedDict<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">"body"</span><span class="token punctuation">,</span> body<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment"># 利用 nn.Sequential 定义模型</span>
    <span class="token keyword">return</span> model

<span class="token comment"># 创建 fpn 网络, 根据配置信息会被下面 build_backbone 函数调用</span>
@registry<span class="token punctuation">.</span>BACKBONES<span class="token punctuation">.</span>register<span class="token punctuation">(</span><span class="token string">"R-50-FPN"</span><span class="token punctuation">)</span>
@registry<span class="token punctuation">.</span>BACKBONES<span class="token punctuation">.</span>register<span class="token punctuation">(</span><span class="token string">"R-101-FPN"</span><span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">build_resnet_fpn_backbone</span><span class="token punctuation">(</span>cfg<span class="token punctuation">)</span><span class="token punctuation">:</span>
    body <span class="token operator">=</span> resnet<span class="token punctuation">.</span>ResNet<span class="token punctuation">(</span>cfg<span class="token punctuation">)</span> <span class="token comment"># 先创建 resnet 网络</span>

    <span class="token comment"># 获取 fpn 所需的channels参数</span>
    in_channels_stage2 <span class="token operator">=</span> cfg<span class="token punctuation">.</span>MODEL<span class="token punctuation">.</span>RESNETS<span class="token punctuation">.</span>RES2_OUT_CHANNELS
    out_channels <span class="token operator">=</span> cfg<span class="token punctuation">.</span>MODEL<span class="token punctuation">.</span>BACKBONE<span class="token punctuation">.</span>OUT_CHANNELS
    fpn <span class="token operator">=</span> fpn_module<span class="token punctuation">.</span>FPN<span class="token punctuation">(</span> <span class="token comment"># 利用 fpn.py 文件夹的 class FPN 创建 fpn 网络</span>
        in_channels_list<span class="token operator">=</span><span class="token punctuation">[</span>
            in_channels_stage2<span class="token punctuation">,</span>
            in_channels_stage2 <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">,</span>
            in_channels_stage2 <span class="token operator">*</span> <span class="token number">4</span><span class="token punctuation">,</span>
            in_channels_stage2 <span class="token operator">*</span> <span class="token number">8</span><span class="token punctuation">,</span>
        <span class="token punctuation">]</span><span class="token punctuation">,</span>
        out_channels<span class="token operator">=</span>out_channels<span class="token punctuation">,</span>
        top_blocks<span class="token operator">=</span>fpn_module<span class="token punctuation">.</span>LastLevelMaxPool<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">)</span>
    model <span class="token operator">=</span> nn<span class="token punctuation">.</span>Sequential<span class="token punctuation">(</span>OrderedDict<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">"body"</span><span class="token punctuation">,</span> body<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">"fpn"</span><span class="token punctuation">,</span> fpn<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> model
</code></pre> 
<p>上面两个函数分别定义了创建 ResNet 和 FPN 的代码逻辑, 下面我们就用这两个函数来进行模型创建, 代码解析如下:</p> 
<pre><code class="prism language-py"><span class="token keyword">def</span> <span class="token function">build_backbone</span><span class="token punctuation">(</span>cfg<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">assert</span> cfg<span class="token punctuation">.</span>MODEL<span class="token punctuation">.</span>BACKBONE<span class="token punctuation">.</span>CONV_BODY <span class="token keyword">in</span> registry<span class="token punctuation">.</span>BACKBONES<span class="token punctuation">,</span> \
        <span class="token string">"cfg.MODEL.BACKBONE.CONV_BODY: {} are not registered in registry"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>
            cfg<span class="token punctuation">.</span>MODEL<span class="token punctuation">.</span>BACKBONE<span class="token punctuation">.</span>CONV_BODY
        <span class="token punctuation">)</span>
    <span class="token keyword">return</span> registry<span class="token punctuation">.</span>BACKBONES<span class="token punctuation">[</span>cfg<span class="token punctuation">.</span>MODEL<span class="token punctuation">.</span>BACKBONE<span class="token punctuation">.</span>CONV_BODY<span class="token punctuation">]</span><span class="token punctuation">(</span>cfg<span class="token punctuation">)</span>
</code></pre> 
<span id="resnet"> ## resnet.py 网络主体(特征提取器) </span> 
<p>在上面一节中的 <code>backbone.py</code> 文件中的两个函数 <code>build_resnet_backbone()</code> 和 <code>build_resnet_fpn_backbone()</code> 都使用了 <code>body = resnet.ResNet(cfg)</code> 来创建网络的主体, 这部分的代码定义位于 <code>./maskrcnn_benchmark/modeling/backbone/resnet.py</code> 文件中, 下面我们就该该文件进行解析, 由于该文件篇幅较多, 因此我们先来看一下文件的整体结构:</p> 
<pre><code class="prism language-py"><span class="token comment"># ./maskrcnn_benchmark/modeling/backbone/resnet.py</span>

<span class="token comment"># 导入各种包及函数</span>
<span class="token comment"># ...</span>
<span class="token keyword">from</span> maskrcnn_benchmark<span class="token punctuation">.</span>layers ipmort FrozenBatchNorm2d
<span class="token comment"># ...</span>

<span class="token comment"># ResNet stage specification</span>
StageSpec <span class="token operator">=</span> <span class="token comment">#...</span>

<span class="token comment"># ResNet</span>
<span class="token keyword">class</span> <span class="token class-name">ResNet</span><span class="token punctuation">(</span>nn<span class="token punctuation">.</span>Module<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> cfg<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token builtin">super</span><span class="token punctuation">(</span>ResNet<span class="token punctuation">,</span> self<span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token comment"># 初始化</span>
        <span class="token comment"># ...</span>

    <span class="token keyword">def</span> <span class="token function">_freeze_backbone</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> freeze_at<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token comment"># 将指定的参数置为: requires_grad = False</span>
        <span class="token comment"># ...</span>

    <span class="token keyword">def</span> <span class="token function">forward</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token comment"># 定义 resnet 的前向传播过程</span>
        <span class="token comment"># ...</span>

<span class="token comment"># ResNetHead</span>
<span class="token keyword">class</span> <span class="token class-name">ResNetHead</span><span class="token punctuation">(</span>nn<span class="token punctuation">.</span>Module<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token comment"># 初始化</span>
        <span class="token comment"># ...</span>

    <span class="token keyword">def</span> <span class="token function">foward</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token comment"># 定义 ResNetHead 的前向传播过程</span>
        <span class="token comment"># ...</span>

<span class="token keyword">def</span> <span class="token function">_make_stage</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token comment"># 创建 ResNet 的 residual-block</span>
    <span class="token comment"># ...</span>

<span class="token keyword">class</span> <span class="token class-name">BottleneckWithFixedBatchNorm</span><span class="token punctuation">(</span>nn<span class="token punctuation">.</span>Module<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token comment"># 使用固定的BN</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token comment"># 初始化</span>
        <span class="token comment"># ...</span>
    <span class="token keyword">def</span> <span class="token function">forward</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token comment"># 定义前向传播过程</span>
        <span class="token comment"># ...</span>

<span class="token keyword">class</span> <span class="token class-name">StemWithFixedBatchNorm</span><span class="token punctuation">(</span>nn<span class="token punctuation">.</span>Module<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> cfg<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token comment"># 初始化</span>
        <span class="token comment"># ...</span>

    <span class="token keyword">def</span> <span class="token function">forward</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token comment"># 定义前向传播过程</span>
        <span class="token comment"># ...</span>

_TRANSFORMATION_MODULES <span class="token operator">=</span> Registry<span class="token punctuation">(</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">)</span>

_STEM_MODULES <span class="token operator">=</span> Registry<span class="token punctuation">(</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">)</span>

_STAGE_SPECS <span class="token operator">=</span> Registry<span class="token punctuation">(</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> 
<h4><a id="ResNet_Stage_Specification_268"></a>ResNet Stage Specification</h4> 
<p>文件的开头定义了 ResNet 的不同 stage 下的 block 的定义, 使用了 <code>namedtuple</code> 数据结构(命名元组, 可以用名字访问元素)来实现, 如下所示:</p> 
<pre><code class="prism language-py">StageSpec <span class="token operator">=</span> namedtuple<span class="token punctuation">(</span>
    <span class="token string">"StageSpec"</span><span class="token punctuation">,</span>
    <span class="token punctuation">[</span>
        <span class="token string">"index"</span><span class="token punctuation">,</span> <span class="token comment"># stage 的下标, 如 1, 2, ..., 5</span>
        <span class="token string">"block_count"</span><span class="token punctuation">,</span> <span class="token comment"># stage 当中的 block 的数量</span>
        <span class="token string">"return_features"</span><span class="token punctuation">,</span> <span class="token comment"># 布尔值, 若为 True, 则返回当前 stage 的最后一层的 feature map</span>
    <span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">)</span>

<span class="token comment"># 标准 ResNet 模块</span>

<span class="token comment"># ResNet-50 full stages 的2~5阶段的卷积层数分别为:3,4,6,3</span>
ResNet50StagesTo5 <span class="token operator">=</span> <span class="token builtin">tuple</span><span class="token punctuation">(</span> <span class="token comment"># 元组内部的元素类型为 StageSpec</span>
    StageSpec<span class="token punctuation">(</span>index<span class="token operator">=</span>i<span class="token punctuation">,</span> block_count<span class="token operator">=</span>c<span class="token punctuation">,</span> return_features<span class="token operator">=</span>r<span class="token punctuation">)</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i<span class="token punctuation">,</span> c<span class="token punctuation">,</span> r<span class="token punctuation">)</span> <span class="token keyword">in</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token boolean">False</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token boolean">False</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token boolean">False</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span>

<span class="token comment"># ResNet-50-C4, 只使用到第四阶段输出的特征图谱</span>
ResNet50StagesTo4 <span class="token operator">=</span> <span class="token builtin">tuple</span><span class="token punctuation">(</span>
    StageSpec<span class="token punctuation">(</span>index<span class="token operator">=</span>i<span class="token punctuation">,</span> block_count<span class="token operator">=</span>c<span class="token punctuation">,</span> return_features<span class="token operator">=</span>r<span class="token punctuation">)</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i<span class="token punctuation">,</span> c<span class="token punctuation">,</span> r<span class="token punctuation">)</span> <span class="token keyword">in</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token boolean">False</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token boolean">False</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span>

<span class="token comment"># ResNet-50-FPN full stages, 由于 FPN需要用到每一个阶段输出的特征图谱, 故 return_features 参数均为 True</span>
ResNet50FPNStagesTo5 <span class="token operator">=</span> <span class="token builtin">tuple</span><span class="token punctuation">(</span>
    StageSpec<span class="token punctuation">(</span>index<span class="token operator">=</span>i<span class="token punctuation">,</span> block_count<span class="token operator">=</span>c<span class="token punctuation">,</span> return_features<span class="token operator">=</span>r<span class="token punctuation">)</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i<span class="token punctuation">,</span> c<span class="token punctuation">,</span> r<span class="token punctuation">)</span> <span class="token keyword">in</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span>

<span class="token comment"># ResNet-101-FPN full stages 的卷积层数分别为: 3, 4, 23, 3</span>
ResNet101FPNStagesTo5 <span class="token operator">=</span> <span class="token builtin">tuple</span><span class="token punctuation">(</span>
    StageSpec<span class="token punctuation">(</span>index<span class="token operator">=</span>i<span class="token punctuation">,</span> block_count<span class="token operator">=</span>c<span class="token punctuation">,</span> return_features<span class="token operator">=</span>r<span class="token punctuation">)</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i<span class="token punctuation">,</span> c<span class="token punctuation">,</span> r<span class="token punctuation">)</span> <span class="token keyword">in</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">23</span><span class="token punctuation">,</span> <span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span>
</code></pre> 
<h4><a id="ResNet__309"></a>ResNet 类</h4> 
<p>为了使阅读代码时不被搞混, 我们首先将文件最后的注册的各个模块贴出来, 这些模块会通过配置文件中的字符串信息来决定调用哪一个类或者参数, 代码如下所示:</p> 
<pre><code class="prism language-py">_TRANSFORMATION_MODULES <span class="token operator">=</span> Registry<span class="token punctuation">(</span><span class="token punctuation">{<!-- --></span>
    <span class="token string">"BottleneckWithFixedBatchNorm"</span><span class="token punctuation">:</span> BottleneckWithFixedBatchNorm
<span class="token punctuation">}</span><span class="token punctuation">)</span>

_STEM_MODULES <span class="token operator">=</span> Registry<span class="token punctuation">(</span><span class="token punctuation">{<!-- --></span><span class="token string">"StemWithFixedBatchNorm"</span><span class="token punctuation">:</span> StemWithFixedBatchNorm<span class="token punctuation">}</span><span class="token punctuation">)</span>

_STAGE_SPECS <span class="token operator">=</span> Registry<span class="token punctuation">(</span><span class="token punctuation">{<!-- --></span>
    <span class="token string">"R-50-C4"</span><span class="token punctuation">:</span> ResNet50StagesTo4<span class="token punctuation">,</span>
    <span class="token string">"R-50-C5"</span><span class="token punctuation">:</span> ResNet50StagesTo5<span class="token punctuation">,</span>
    <span class="token string">"R-50-FPN"</span><span class="token punctuation">:</span> ResNet50FPNStagesTo5<span class="token punctuation">,</span>
    <span class="token string">"R-101-FPN"</span><span class="token punctuation">:</span> ResNet101FPNStagesTo5<span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> 
<p>当定义完各个 ResNet 模型的 stages 的卷积层数量后, 我们再来看一看 ResNet 类的实现, 代码解析如下所示:</p> 
<pre><code class="prism language-py"><span class="token comment"># ./maskrcnn_benchmark/modeling/backbone/resnet.py</span>

<span class="token keyword">class</span> <span class="token class-name">ResNet</span><span class="token punctuation">(</span>nn<span class="token punctuation">.</span>Module<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> cfg<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token builtin">super</span><span class="token punctuation">(</span>ResNet<span class="token punctuation">,</span> self<span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token punctuation">)</span>

        <span class="token comment"># 如果我们希望在 forward 函数中使用 cfg, 那么我们就应该创建一个副本以供其使用</span>
        <span class="token comment"># self.cfg = cfg.clone()</span>

        <span class="token comment"># 将配置文件中的字符串转化成具体的实现, 下面三个分别使用了对应的注册模块, 定义在文件的最后</span>

        <span class="token comment"># 这里是 stem 的实现, 也就是 resnet 的第一阶段 conv1</span>
        <span class="token comment"># cfg.MODEL.RESNETS.STEM_FUNC = "StemWithFixedBatchNorm"</span>
        stem_module <span class="token operator">=</span> _STEM_MODULES<span class="token punctuation">[</span>cfg<span class="token punctuation">.</span>MODEL<span class="token punctuation">.</span>RESNETS<span class="token punctuation">.</span>STEM_FUNC<span class="token punctuation">]</span>

        <span class="token comment"># resnet conv2_x~conv5_x 的实现</span>
        <span class="token comment"># eg: cfg.MODEL.CONV_BODY="R-50-FPN"</span>
        stage_specs <span class="token operator">=</span> _STAGE_SPECS<span class="token punctuation">[</span>cfg<span class="token punctuation">.</span>MODEL<span class="token punctuation">.</span>CONV_BODY<span class="token punctuation">]</span>

        <span class="token comment"># residual transformation function</span>
        <span class="token comment"># cfg.MODEL.RESNETS.TRANS_FUNC="BottleneckWithFixedBatchNorm"</span>
        transformation_module <span class="token operator">=</span> _TRANSFORMATION_MODULES<span class="token punctuation">[</span>cfg<span class="token punctuation">.</span>MODEL<span class="token punctuation">.</span>RESNETS<span class="token punctuation">.</span>TRANS_FUNC<span class="token punctuation">]</span>

        <span class="token comment"># 获取上面各个组成部分的实现以后, 就可以利用这些实现来构建模型了</span>

        <span class="token comment"># 构建 stem module(也就是 resnet 的stage1, 或者 conv1)</span>
        self<span class="token punctuation">.</span>stem <span class="token operator">=</span> stem_module<span class="token punctuation">(</span>cfg<span class="token punctuation">)</span>

        <span class="token comment"># 获取相应的信息来构建 resnet 的其他 stages 的卷积层</span>

        <span class="token comment"># 当 num_groups=1 时为 ResNet, &gt;1 时 为 ResNeXt</span>
        num_groups <span class="token operator">=</span> cfg<span class="token punctuation">.</span>MODEL<span class="token punctuation">.</span>RESNETS<span class="token punctuation">.</span>NUM_GROUPS

        <span class="token comment">#</span>
        width_per_group <span class="token operator">=</span> cfg<span class="token punctuation">.</span>MODEL<span class="token punctuation">.</span>RESNETS<span class="token punctuation">.</span>WIDTH_PER_GROUP

        <span class="token comment"># in_channels 指的是向后面的第二阶段输入时特征图谱的通道数,</span>
        <span class="token comment"># 也就是 stem 的输出通道数, 默认为 64</span>
        in_channels <span class="token operator">=</span> cfg<span class="token punctuation">.</span>MODEL<span class="token punctuation">.</span>RESNETS<span class="token punctuation">.</span>STEM_OUT_CHANNELS

        <span class="token comment"># 第二阶段输入的特别图谱的通道数</span>
        stage2_bottleneck_channels <span class="token operator">=</span> num_groups <span class="token operator">*</span> width_per_group

        <span class="token comment"># 第二阶段的输出, resnet 系列标准模型可从 resnet 第二阶段的输出通道数判断后续的通道数</span>
        <span class="token comment"># 默认为256, 则后续分别为512, 1024, 2048, 若为64, 则后续分别为128, 256, 512</span>
        stage2_out_channels <span class="token operator">=</span> cfg<span class="token punctuation">.</span>MODEL<span class="token punctuation">.</span>RESNETS<span class="token punctuation">.</span>RES2_OUT_CHANNELS

        <span class="token comment"># 创建一个空的 stages 列表和对应的特征图谱字典</span>
        self<span class="token punctuation">.</span>stages <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        self<span class="token punctuation">.</span>return_features <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>

        <span class="token keyword">for</span> stage_spec <span class="token keyword">in</span> stage_specs<span class="token punctuation">:</span> <span class="token comment"># 关于 stage_specs 的定义可以看上一节</span>
            name <span class="token operator">=</span> <span class="token string">"layer"</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>stage_spec<span class="token punctuation">.</span>index<span class="token punctuation">)</span>

            <span class="token comment"># 计算每个stage的输出通道数, 每经过一个stage, 通道数都会加倍</span>
            stage2_relative_factor <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">**</span> <span class="token punctuation">(</span>stage_spec<span class="token punctuation">.</span>index <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>

            <span class="token comment"># 计算输入图谱的通道数</span>
            bottleneck_channels <span class="token operator">=</span> stage2_bottleneck_channels <span class="token operator">*</span> stage2_relative_factor

            <span class="token comment"># 计算输出图谱的通道数</span>
            out_channels <span class="token operator">=</span> stage2_out_channels <span class="token operator">*</span> stage2_relative_factor

            <span class="token comment"># 当获取到所有需要的参数以后, 调用本文件的 `_make_stage` 函数,</span>
            <span class="token comment"># 该函数可以根据传入的参数创建对应 stage 的模块(注意是module而不是model)</span>
            module <span class="token operator">=</span> _make_stage<span class="token punctuation">(</span>
                transformation_module<span class="token punctuation">,</span>
                in_channels<span class="token punctuation">,</span> <span class="token comment"># 输入的通道数</span>
                bottleneck_channels<span class="token punctuation">,</span> <span class="token comment"># 压缩后的通道数</span>
                out_channels<span class="token punctuation">,</span> <span class="token comment"># 输出的通道数</span>
                stage_spec<span class="token punctuation">.</span>block_count<span class="token punctuation">,</span> <span class="token comment">#当前stage的卷积层数量</span>
                num_groups<span class="token punctuation">,</span> <span class="token comment"># ResNet时为1, ResNeXt时&gt;1</span>
                cfg<span class="token punctuation">.</span>MODEL<span class="token punctuation">.</span>RESNETS<span class="token punctuation">.</span>STRIDE_IN_1X1<span class="token punctuation">,</span>
                <span class="token comment"># 当处于 stage3~5时, 需要在开始的时候使用 stride=2 来downsize</span>
                first_stride<span class="token operator">=</span><span class="token builtin">int</span><span class="token punctuation">(</span>stage_spec<span class="token punctuation">.</span>index <span class="token operator">&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span>
            <span class="token punctuation">)</span>

            <span class="token comment"># 下一个 stage 的输入通道数即为当前 stage 的输出通道数</span>
            in_channels <span class="token operator">=</span> out_channels

            <span class="token comment"># 将当前stage模块添加到模型中</span>
            self<span class="token punctuation">.</span>add_module<span class="token punctuation">(</span>name<span class="token punctuation">,</span> module<span class="token punctuation">)</span>

            <span class="token comment"># 将stage的名称添加到列表中</span>
            self<span class="token punctuation">.</span>stages<span class="token punctuation">.</span>append<span class="token punctuation">(</span>name<span class="token punctuation">)</span>

            <span class="token comment"># 将stage的布尔值添加到字典中</span>
            self<span class="token punctuation">.</span>return_features<span class="token punctuation">[</span>name<span class="token punctuation">]</span> <span class="token operator">=</span> stage_spec<span class="token punctuation">.</span>return_features

        <span class="token comment"># 根据配置文件的参数选择性的冻结某些层(requires_grad=False)</span>
        self<span class="token punctuation">.</span>_freeze_backbone<span class="token punctuation">(</span>cfg<span class="token punctuation">.</span>MODEL<span class="token punctuation">.</span>BACKBONE<span class="token punctuation">.</span>FREEZE_CONV_BODY_AT<span class="token punctuation">)</span>

    <span class="token keyword">def</span> <span class="token function">_freeze_backbone</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> freeze_at<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token comment"># 根据给定的参数冻结某些层的参数更新</span>
        <span class="token keyword">for</span> stage_index <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>freeze_at<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> stage_index <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>
                m <span class="token operator">=</span> self<span class="token punctuation">.</span>stem <span class="token comment"># resnet 的第一阶段, 即为 stem</span>
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                m <span class="token operator">=</span> <span class="token builtin">getattr</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> <span class="token string">"layer"</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>stage_index<span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token comment"># 将 m 中的所有参数置为不更新状态.</span>
            <span class="token keyword">for</span> p <span class="token keyword">in</span> m<span class="token punctuation">.</span>parameters<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                p<span class="token punctuation">.</span>requires_grad <span class="token operator">=</span> <span class="token boolean">False</span>

    <span class="token comment"># 定义 ResNet 的前行传播过程</span>
    <span class="token keyword">def</span> <span class="token function">forward</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">:</span>
        outputs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        x <span class="token operator">=</span> self<span class="token punctuation">.</span>stem<span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token comment"># 先经过 stem(stage 1)</span>

        <span class="token comment"># 再依次计算 stage2~5的结果</span>
        <span class="token keyword">for</span> stage_name <span class="token keyword">in</span> self<span class="token punctuation">.</span>stages<span class="token punctuation">:</span>
            x <span class="token operator">=</span> <span class="token builtin">getattr</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> stage_name<span class="token punctuation">)</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>
            <span class="token keyword">if</span> self<span class="token punctuation">.</span>return_features<span class="token punctuation">[</span>stage_name<span class="token punctuation">]</span><span class="token punctuation">:</span>
                <span class="token comment"># 将stage2~5的所有计算结果(也就是特征图谱)以列表形式保存</span>
                outputs<span class="token punctuation">.</span>append<span class="token punctuation">(</span>x<span class="token punctuation">)</span>

        <span class="token comment"># 将结果返回, outputs为列表形式, 元素为各个stage的特征图谱, 刚好作为 FPN 的输入</span>
        <span class="token keyword">return</span> outputs
</code></pre> 
<h4><a id="ResNetHead__450"></a>ResNetHead 类</h4> 
<p>接下来, 我们来看看 <code>ResNetHead</code> 类的实现, 代码解析如下所示:</p> 
<pre><code class="prism language-py"><span class="token keyword">class</span> <span class="token class-name">ResNetHead</span><span class="token punctuation">(</span>nn<span class="token punctuation">.</span>Module<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>
        self<span class="token punctuation">,</span>
        block_module<span class="token punctuation">,</span>
        stages<span class="token punctuation">,</span>
        num_groups<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span>
        width_per_group<span class="token operator">=</span><span class="token number">64</span><span class="token punctuation">,</span>
        stride_in_1x1<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span>
        stride_init<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span>
        res2_out_channels<span class="token operator">=</span><span class="token number">256</span><span class="token punctuation">,</span>
    <span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token builtin">super</span><span class="token punctuation">(</span>ResNetHead<span class="token punctuation">,</span> self<span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token punctuation">)</span>

        <span class="token comment"># 获取不同stage的通道数相对于stage2的倍数</span>
        stage2_relative_factor <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">**</span> <span class="token punctuation">(</span>stages<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>index <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>

        <span class="token comment"># 获取压缩后的 stage2 的 channels</span>
        stage2_bottleneck_channels <span class="token operator">=</span> num_groups <span class="token operator">*</span> width_per_group

        <span class="token comment"># 获取输出的 channels</span>
        out_channels <span class="token operator">=</span> res2_out_channels <span class="token operator">*</span> stage2_relative_factor

        <span class="token comment"># 获取输入的 channels</span>
        in_channels <span class="token operator">=</span> out_channels <span class="token operator">//</span> <span class="token number">2</span>

        <span class="token comment"># 获取压缩后的 channels</span>
        bottleneck_channels <span class="token operator">=</span> stage2_bottleneck_channels <span class="token operator">*</span> stage2_relative_factor

        <span class="token comment"># 根据给定的名称获取相应 block_module</span>
        <span class="token comment"># 目前 _TRANSFORMATION_MODULES 只包含 "BottleneckWithFixedBatchNorm" 这一个模块</span>
        block_module <span class="token operator">=</span> _TRANSFORMATION_MODULES<span class="token punctuation">[</span>block_module<span class="token punctuation">]</span>

        <span class="token comment"># 创建一个空的 stages 列表</span>
        self<span class="token punctuation">.</span>stages <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>

        <span class="token comment"># 初始化 stride</span>
        stride <span class="token operator">=</span> stride_init

        <span class="token keyword">for</span> stage <span class="token keyword">in</span> stages<span class="token punctuation">:</span>
            name <span class="token operator">=</span> <span class="token string">"layer"</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>stage<span class="token punctuation">.</span>index<span class="token punctuation">)</span>
            <span class="token keyword">if</span> <span class="token operator">not</span> stride<span class="token punctuation">:</span>
                <span class="token comment"># 当处于 stage3~5时, 需要在开始的时候使用 stride=2 来downsize</span>
                stride <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span>stage<span class="token punctuation">.</span>index <span class="token operator">&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span>
            module <span class="token operator">=</span> _make_stage<span class="token punctuation">(</span>
                block_module<span class="token punctuation">,</span>
                in_channels<span class="token punctuation">,</span>
                bottleneck_channels<span class="token punctuation">,</span>
                out_channels<span class="token punctuation">,</span>
                stage<span class="token punctuation">.</span>block_count<span class="token punctuation">,</span>
                num_groups<span class="token punctuation">,</span>
                stride_in_1x1<span class="token punctuation">,</span>
                first_stride<span class="token operator">=</span>stride<span class="token punctuation">,</span>
            <span class="token punctuation">)</span>
            stride <span class="token operator">=</span> <span class="token boolean">None</span>
            self<span class="token punctuation">.</span>add_module<span class="token punctuation">(</span>name<span class="token punctuation">,</span> module<span class="token punctuation">)</span>
            self<span class="token punctuation">.</span>stages<span class="token punctuation">.</span>append<span class="token punctuation">(</span>name<span class="token punctuation">)</span>

    <span class="token comment"># 定义前向传播过程</span>
    <span class="token keyword">def</span> <span class="token function">forward</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">for</span> stage <span class="token keyword">in</span> self<span class="token punctuation">.</span>stages<span class="token punctuation">:</span>
            x <span class="token operator">=</span> <span class="token builtin">getattr</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> stage<span class="token punctuation">)</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>
        <span class="token keyword">return</span> x
</code></pre> 
<h4><a id="make_stage_519"></a>make_stage</h4> 
<p>在上面两个类中, 都使用了 <code>_make_stage()</code> 函数来创建对应的 stage, 下面, 我们就来看看该函数的具体实现, 代码解析如下所示:</p> 
<pre><code class="prism language-py"><span class="token comment"># ./maskrcnn_benchmark/modeling/backbone/resnet.py</span>

<span class="token keyword">def</span> <span class="token function">_make_stage</span><span class="token punctuation">(</span>
    transformation_module<span class="token punctuation">,</span>
    in_channels<span class="token punctuation">,</span>
    bottleneck_channels<span class="token punctuation">,</span>
    out_channels<span class="token punctuation">,</span>
    block_count<span class="token punctuation">,</span>
    num_groups<span class="token punctuation">,</span>
    stride_in_1x1<span class="token punctuation">,</span>
    first_stride<span class="token punctuation">,</span>
<span class="token punctuation">)</span><span class="token punctuation">:</span>
    blocks <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    stride <span class="token operator">=</span> first_stride
    <span class="token keyword">for</span> _ <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>block_count<span class="token punctuation">)</span><span class="token punctuation">:</span>
        blocks<span class="token punctuation">.</span>append<span class="token punctuation">(</span>
            transformation_module<span class="token punctuation">(</span>
                in_channels<span class="token punctuation">,</span>
                bottleneck_channels<span class="token punctuation">,</span>
                out_channels<span class="token punctuation">,</span>
                num_groups<span class="token punctuation">,</span>
                stride_in_1x1<span class="token punctuation">,</span>
                stride<span class="token punctuation">,</span>
            <span class="token punctuation">)</span>
        <span class="token punctuation">)</span>
        stride <span class="token operator">=</span> <span class="token number">1</span>
        in_channels <span class="token operator">=</span> out_channels
</code></pre> 
<h4><a id="StemWithFixedBatchNorm__553"></a>StemWithFixedBatchNorm 类</h4> 
<p>该类负责构建 ResNet 的 stem 模块, 也可以认为是 ResNet 的第一阶段(或者说是第零阶段), 在 ResNet 50 中, 该阶段主要包含一个 7×7 大小的卷积核, 在 MaskrcnnBenchmark 的实现中, 为了可以方便的复用实现各个 stage 的代码, 它将第二阶段最开始的 3×3 的 max pooling 层也放到了 stem 中的 <code>forward</code> 函数中实现(一般不带参数网络层的都放在 <code>forward</code> 中), 该类的实现代码解析如下:</p> 
<pre><code class="prism language-py"><span class="token comment"># ./maskrcnn_benchmark/modeling/backbone/resnet.py</span>

<span class="token keyword">class</span> <span class="token class-name">StemWithFixedBatchNorm</span><span class="token punctuation">(</span>nn<span class="token punctuation">.</span>Module<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> cfg<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token builtin">super</span><span class="token punctuation">(</span>StemWithFixedBatchNorm<span class="token punctuation">,</span> self<span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token punctuation">)</span>

        <span class="token comment"># resnet-50, out_channels=64</span>
        out_channels <span class="token operator">=</span> cfg<span class="token punctuation">.</span>MODEL<span class="token punctuation">.</span>RESNETS<span class="token punctuation">.</span>STEM_OUT_CHANNELS

        <span class="token comment"># 输入的 channels 为 3, 输出为 64</span>
        self<span class="token punctuation">.</span>conv1 <span class="token operator">=</span> Conv2d<span class="token punctuation">(</span>
            <span class="token number">3</span><span class="token punctuation">,</span> out_channels<span class="token punctuation">,</span> kernel_size<span class="token operator">=</span><span class="token number">7</span><span class="token punctuation">,</span> stride<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> padding<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span> bias<span class="token operator">=</span><span class="token boolean">False</span>
        <span class="token punctuation">)</span>

        <span class="token comment"># 使用固定参数的 BN 层</span>
        self<span class="token punctuation">.</span>bn1 <span class="token operator">=</span> FrozenBatchNorm2d<span class="token punctuation">(</span>out_channels<span class="token punctuation">)</span>

    <span class="token comment"># 定义前向传播过程</span>
    <span class="token keyword">def</span> <span class="token function">forward</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">:</span>
        x <span class="token operator">=</span> self<span class="token punctuation">.</span>conv1<span class="token punctuation">(</span>x<span class="token punctuation">)</span>
        x <span class="token operator">=</span> self<span class="token punctuation">.</span>bn1<span class="token punctuation">(</span>x<span class="token punctuation">)</span>
        x <span class="token operator">=</span> F<span class="token punctuation">.</span>relu_<span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token comment"># 原地激活, 因为不含参数, 因此不放在模型定义中, 而放在 forward 中实现</span>
        x <span class="token operator">=</span> F<span class="token punctuation">.</span>max_pool2d<span class="token punctuation">(</span>x<span class="token punctuation">,</span> kernel_size<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span> stride<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> padding<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> x
</code></pre> 
<p>上面代码中的 <code>Conv2d</code> 是封装在 <code>./maskrcnn_benchmark/layers/misc.py</code> 文件中的 <code>class Conv2d(nn.Conv2d)</code> 类, 它会根据 tensor 的 <code>numel</code> 参数决定其返回值, 当 <code>x.numel()&gt;0</code> 时, 与普通的 <code>torch.nn.Conv2d()</code> 函数没有区别. 另外还使用了 <code>./maskrcnn_benchmark/layers/batch_norm.py</code> 文件中定义的 <code>class FrozenBatchNorm2d(nn.Module)</code> 类, 该类主要实现了 BN 层的功能, 只不过其中的参数都是固定的, 而非可更新的.</p> 
<h4><a id="BottleneckWithFixedBatchNorm__586"></a>BottleneckWithFixedBatchNorm 类</h4> 
<p>创建完 stem(stage1) 以后, 接下来就是需要创建 resnet 的 stage2~5, 根据 resnet 的特点我们可以知道, resnet2~5 阶段的整体结构是非常相似的, 都是有最基础的 resnet bottleneck block 堆叠形成的, 不同 stage 的 bottleneck block 的数量不同, 对于 resnet50 来说, 每一个阶段的 bottleneck block 的数量分别为 3,4,6,3, 并且各个相邻 stage 之间的通道数都是两倍的关系, 所以可以很容易的从一个 stage 的通道数推知另一个 stage 的通道数, 关于 bottleneck block 的代码解析如下所示:</p> 
<pre><code class="prism language-py"><span class="token comment"># ./maskrcnn_benchmark/modeling/backbone/resnet.py</span>

<span class="token keyword">class</span> <span class="token class-name">BottleneckWithFixedBatchNorm</span><span class="token punctuation">(</span>nn<span class="token punctuation">.</span>Module<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>
        self<span class="token punctuation">,</span>
        in_channels<span class="token punctuation">,</span> <span class="token comment"># bottleneck 的输入 channels</span>
        bottleneck_channels<span class="token punctuation">,</span> <span class="token comment"># bottleneck 压缩后的 channels</span>
        out_channels<span class="token punctuation">,</span> <span class="token comment"># 当前stage的输出channels</span>
        num_groups<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span>
        stride_in_1x1<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span>
        stride<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span>
    <span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token builtin">super</span><span class="token punctuation">(</span>BottleneckWithFixedBatchNorm<span class="token punctuation">,</span> self<span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token punctuation">)</span>

        <span class="token comment"># downsample: 当 bottleneck 的输入和输出的 channels 不相等时, 则需要采用一定的策略</span>
        <span class="token comment"># 在原文中, 有 A, B, C三种策略, 本文采用的是 B 策略(也是原文推荐的)</span>
        <span class="token comment"># 即只有在输入输出通道数不相等时才使用 projection shortcuts,</span>
        <span class="token comment"># 也就是利用参数矩阵映射使得输入输出的 channels 相等</span>
        self<span class="token punctuation">.</span>downsample <span class="token operator">=</span> <span class="token boolean">None</span>

        <span class="token comment"># 当输入输出通道数不同时, 额外添加一个 1×1 的卷积层使得输入通道数映射成输出通道数</span>
        <span class="token keyword">if</span> in_channels <span class="token operator">!=</span> out_channels<span class="token punctuation">:</span>
            self<span class="token punctuation">.</span>downsample <span class="token operator">=</span> nn<span class="token punctuation">.</span>Sequential<span class="token punctuation">(</span>
                Conv2d<span class="token punctuation">(</span>
                    in_channels<span class="token punctuation">,</span> out_channels<span class="token punctuation">,</span> kernel_size<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> stride<span class="token operator">=</span>stride<span class="token punctuation">,</span> bias<span class="token operator">=</span><span class="token boolean">False</span>
                <span class="token punctuation">)</span><span class="token punctuation">,</span>
                FrozenBatchNorm2d<span class="token punctuation">(</span>out_channels<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment"># 后街一个固定参数的 BN 层</span>
            <span class="token punctuation">)</span>

        <span class="token comment"># 在 resnet 原文中, 会在 conv3_1, conv4_1, conv5_1 处使用 stride=2 的卷积</span>
        <span class="token comment"># 而在 fb.torch.resnet 和 caffe2 的实现中, 是将之后的 3×3 的卷积层的 stride 置为2</span>
        <span class="token comment"># 下面中的 stride 虽然默认值为1, 但是在函数调用时, 如果stage为3~5, 则会显示置为2</span>
        stride_1x1<span class="token punctuation">,</span> stride_3x3 <span class="token operator">=</span> <span class="token punctuation">(</span>stride<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">if</span> stride_in_1x1 <span class="token keyword">else</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> stride<span class="token punctuation">)</span>

        <span class="token comment"># 当获取到当前stage所需的参数后, 就创建相应的卷积层, 创建原则参见 resnet50 的定义</span>
        self<span class="token punctuation">.</span>conv1 <span class="token operator">=</span> Conv2d<span class="token punctuation">(</span>
            in_channels<span class="token punctuation">,</span>
            bottleneck_channels<span class="token punctuation">,</span>
            kernel_size<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span>
            stride<span class="token operator">=</span>stride_1x1<span class="token punctuation">,</span>
            bias<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">,</span>
        <span class="token punctuation">)</span>
        self<span class="token punctuation">.</span>bn1 <span class="token operator">=</span> FrozenBatchNorm2d<span class="token punctuation">(</span>bottleneck_channels<span class="token punctuation">)</span> <span class="token comment"># 后接一个固定参数的 BN 层</span>

        <span class="token comment"># 创建 bottleneck 的第二层卷积层</span>
        self<span class="token punctuation">.</span>conv2 <span class="token operator">=</span> Conv2d<span class="token punctuation">(</span>
            bottleneck_channels<span class="token punctuation">,</span>
            bottleneck_channels<span class="token punctuation">,</span>
            kernel_size<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span>
            stride<span class="token operator">=</span>stride_3x3<span class="token punctuation">,</span>
            padding<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span>
            bias<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">,</span>
            groups<span class="token operator">=</span>num_groups<span class="token punctuation">,</span>
        <span class="token punctuation">)</span>
        self<span class="token punctuation">.</span>bn2 <span class="token operator">=</span> FrozenBatchNorm2d<span class="token punctuation">(</span>bottleneck_channels<span class="token punctuation">)</span> <span class="token comment"># 后接一个 BN 层</span>

        <span class="token comment"># 创建 bottleneck 的最后一个卷积层, padding默认为1</span>
        self<span class="token punctuation">.</span>conv3 <span class="token operator">=</span> Conv2d<span class="token punctuation">(</span>
            bottleneck_channels<span class="token punctuation">,</span> out_channels<span class="token punctuation">,</span> kernel_size<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> bias<span class="token operator">=</span><span class="token boolean">False</span>
        <span class="token punctuation">)</span>
        self<span class="token punctuation">.</span>bn3 <span class="token operator">=</span> FrozenBatchNorm2d<span class="token punctuation">(</span>out_channels<span class="token punctuation">)</span>

    <span class="token keyword">def</span> <span class="token function">forward</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token comment"># 执行一次forward, 相当于执行一次 bottleneck,</span>
        <span class="token comment"># 默认情况下, 具有三个卷积层, 一个恒等连接, 每个卷积层之后都带有 BN 和 relu 激活</span>
        <span class="token comment"># 注意, 最后一个激活函数要放在恒等连接之后</span>

        residual <span class="token operator">=</span> x <span class="token comment"># 恒等连接, 直接令残差等于x即可</span>

        <span class="token comment"># conv1, bn1</span>
        out <span class="token operator">=</span> self<span class="token punctuation">.</span>conv1<span class="token punctuation">(</span>x<span class="token punctuation">)</span>
        out <span class="token operator">=</span> self<span class="token punctuation">.</span>bn1<span class="token punctuation">(</span>out<span class="token punctuation">)</span>
        out <span class="token operator">=</span> F<span class="token punctuation">.</span>relu_<span class="token punctuation">(</span>out<span class="token punctuation">)</span>

        <span class="token comment"># conv2, bn2</span>
        out <span class="token operator">=</span> self<span class="token punctuation">.</span>conv2<span class="token punctuation">(</span>out<span class="token punctuation">)</span>
        out <span class="token operator">=</span> self<span class="token punctuation">.</span>bn2<span class="token punctuation">(</span>out<span class="token punctuation">)</span>
        out <span class="token operator">=</span> F<span class="token punctuation">.</span>relu_<span class="token punctuation">(</span>out<span class="token punctuation">)</span>

        <span class="token comment"># conv3, bn3</span>
        out0 <span class="token operator">=</span> self<span class="token punctuation">.</span>conv3<span class="token punctuation">(</span>out<span class="token punctuation">)</span> <span class="token comment"># 这里的out0好像没必要带0?</span>
        out <span class="token operator">=</span> self<span class="token punctuation">.</span>bn3<span class="token punctuation">(</span>out0<span class="token punctuation">)</span>

        <span class="token keyword">if</span> self<span class="token punctuation">.</span>downsample <span class="token keyword">is</span> <span class="token operator">not</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
            <span class="token comment"># 如果输入输出的通道数不同, 则需要通过映射使之相同.</span>
            residual <span class="token operator">=</span> self<span class="token punctuation">.</span>downsample<span class="token punctuation">(</span>x<span class="token punctuation">)</span>

        out <span class="token operator">+=</span> residual <span class="token comment"># H = F + x</span>
        out <span class="token operator">=</span> F<span class="token punctuation">.</span>relu_<span class="token punctuation">(</span>out<span class="token punctuation">)</span> <span class="token comment"># 最后进行激活</span>

        <span class="token keyword">return</span> out <span class="token comment"># 返回带有残差项的卷积结果</span>
</code></pre> 
<span id="fpn"> ## fpn.py 特征金字塔网络 </span> 
<p>对于 ResNet-50-C4 来说, 只需要上面的 ResNet 模型即可完成特征提取任务, 但是对于 ResNet-50-FPN 来说, 我们还需要实现 FPN 网络以获得更强的特征提取能力, 在 <code>backbone.py</code> 文件中的 <code>build_resnet_fpn_backbone(cfg)</code> 函数中, 就使用了 <code>fpn = fpn_module.FPN(...)</code> 来创建一个 FPN 类的实例对象, 并且利用 <code>nn.Sequential()</code> 将 ResNet 和 FPN 组合在一起形成一个模型, 并将其返回, 下面, 我们就来看看 FPN 网络的具体实现, 实例代码位于 <code>./maskrcnn_benchmark/modeling/backbone/fpn.py</code> 文件中, 解析如下:</p> 
<pre><code class="prism language-py"><span class="token comment"># ./maskrcnn_benchmark/modeling/backbone/fpn.py</span>

<span class="token keyword">import</span> torch
<span class="token keyword">import</span> torch<span class="token punctuation">.</span>nn<span class="token punctuation">.</span>functional <span class="token keyword">as</span> F
<span class="token keyword">from</span> torch <span class="token keyword">import</span> nn

<span class="token keyword">class</span> <span class="token class-name">FPN</span><span class="token punctuation">(</span>nn<span class="token punctuation">.</span>Module<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token comment"># 在一系列的 feature map (实际上就是stage2~5的最后一层输出)添加 FPN</span>
    <span class="token comment"># 这些 feature maps 的 depth 假定是不断递增的, 并且 feature maps 必须是连续的(从stage角度)</span>

    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> in_channels_list<span class="token punctuation">,</span> out_channels<span class="token punctuation">,</span> top_blocks<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token comment"># in_channels_list (list[int]): 指示了送入 fpn 的每个 feature map 的通道数</span>
        <span class="token comment"># out_channels (int): FPN表征的通道数, 所有的特征图谱最终都会转换成这个通道数大小</span>
        <span class="token comment"># top_blocks (nn.Module or None): 当提供了 top_blocks 时, 就会在 FPN 的最后</span>
        <span class="token comment"># 的输出上进行一个额外的 op, 然后 result 会扩展成 result list 返回</span>
        <span class="token builtin">super</span><span class="token punctuation">(</span>FPN<span class="token punctuation">,</span> self<span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token punctuation">)</span>

        <span class="token comment"># 创建两个空列表</span>
        self<span class="token punctuation">.</span>inner_blocks <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        self<span class="token punctuation">.</span>layer_blocks <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>

        <span class="token comment"># 假设我们使用的是 ResNet-50-FPN 和配置, 则 in_channels_list 的值为:</span>
        <span class="token comment"># [256, 512, 1024, 2048]</span>
        <span class="token keyword">for</span> idx<span class="token punctuation">,</span> in_channels <span class="token keyword">in</span> <span class="token builtin">enumerate</span><span class="token punctuation">(</span>in_channels_list<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment"># 下标从1开始</span>
            <span class="token comment"># 用下表起名: fpn_inner1, fpn_inner2, fpn_inner3, fpn_inner4</span>
            inner_block <span class="token operator">=</span> <span class="token string">"fpn_inner{}"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>idx<span class="token punctuation">)</span>

            <span class="token comment"># fpn_layer1, fpn_layer2, fpn_layer3, fpn_layer4</span>
            layer_block <span class="token operator">=</span> <span class="token string">"fpn_layer{}"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>idx<span class="token punctuation">)</span>

            <span class="token comment"># 创建 inner_block 模块, 这里 in_channels 为各个stage输出的通道数</span>
            <span class="token comment"># out_channels 为 256, 定义在用户配置文件中</span>
            <span class="token comment"># 这里的卷积核大小为1, 该卷积层主要作用为改变通道数到 out_channels(降维)</span>
            inner_block_module <span class="token operator">=</span> nn<span class="token punctuation">.</span>Conv2d<span class="token punctuation">(</span>in_channels<span class="token punctuation">,</span> out_channels<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>

            <span class="token comment"># 改变 channels 后, 在每一个 stage 的特征图谱上再进行 3×3 的卷积计算, 通道数不变</span>
            layer_block_module <span class="token operator">=</span> nn<span class="token punctuation">.</span>Conv2d<span class="token punctuation">(</span>out_channels<span class="token punctuation">,</span> out_channels<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>

            <span class="token keyword">for</span> module <span class="token keyword">in</span> <span class="token punctuation">[</span>inner_block_module<span class="token punctuation">,</span> layer_block_module<span class="token punctuation">]</span><span class="token punctuation">:</span>
                <span class="token comment"># Caffe2 的实现使用了 XavierFill,</span>
                <span class="token comment"># 实际上相当于 PyTorch 中的 kaiming_uniform_</span>
                nn<span class="token punctuation">.</span>init<span class="token punctuation">.</span>kaiming_uniform_<span class="token punctuation">(</span>module<span class="token punctuation">.</span>weight<span class="token punctuation">,</span> a<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>
                nn<span class="token punctuation">.</span>init<span class="token punctuation">.</span>constant_<span class="token punctuation">(</span>module<span class="token punctuation">.</span>bias<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>

            <span class="token comment"># 在当前的特征图谱上添加 FPN</span>
            self<span class="token punctuation">.</span>add_module<span class="token punctuation">(</span>inner_block<span class="token punctuation">,</span> inner_block_module<span class="token punctuation">)</span> <span class="token comment">#name, module</span>
            self<span class="token punctuation">.</span>add_module<span class="token punctuation">(</span>layer_block<span class="token punctuation">,</span> layer_block_module<span class="token punctuation">)</span>

            <span class="token comment"># 将当前 stage 的 fpn 模块的名字添加到对应的列表当中</span>
            self<span class="token punctuation">.</span>inner_blocks<span class="token punctuation">.</span>append<span class="token punctuation">(</span>inner_block<span class="token punctuation">)</span>
            self<span class="token punctuation">.</span>layer_blocks<span class="token punctuation">.</span>append<span class="token punctuation">(</span>layer_block<span class="token punctuation">)</span>

        <span class="token comment"># 将top_blocks作为 FPN 类的成员变量</span>
        self<span class="token punctuation">.</span>top_blocks <span class="token operator">=</span> top_blocks

    <span class="token keyword">def</span> <span class="token function">forward</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token comment"># x (list[Tensor]): 每个 feature level 的 feature maps,</span>
        <span class="token comment"># ResNet的计算结果正好满足 FPN 的输入要求, 也因此可以使用 nn.Sequential 将二者直接结合</span>
        <span class="token comment"># results (tuple[Tensor]): 经过FPN后的特征图谱组成的列表, 排列顺序是高分辨率的在前</span>

        <span class="token comment"># 先计算最后一层(分辨率最低)特征图谱的fpn结果.</span>
        last_inner <span class="token operator">=</span> <span class="token builtin">getattr</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> self<span class="token punctuation">.</span>inner_blocks<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">(</span>x<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>

        <span class="token comment"># 创建一个空的结果列表</span>
        results<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>

        <span class="token comment"># 将最后一层的计算结果添加到 results 中</span>
        results<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token builtin">getattr</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> self<span class="token punctuation">.</span>layer_blocks<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">(</span>last_inner<span class="token punctuation">)</span><span class="token punctuation">)</span>


        <span class="token comment"># [:-1] 获取了前三项, [::-1] 代表从头到尾切片, 步长为-1, 效果为列表逆置</span>
        <span class="token comment"># 举例来说, zip里的操作 self.inner_block[:-1][::-1] 的运行结果为</span>
        <span class="token comment"># [fpn_inner3, fpn_inner2, fpn_inner1], 相当于对列表进行了逆置</span>
        <span class="token keyword">for</span> feature<span class="token punctuation">,</span> inner_block<span class="token punctuation">,</span> layer_block <span class="token keyword">in</span> <span class="token builtin">zip</span><span class="token punctuation">(</span>
            x<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>inner_block<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>layer_blocks<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>
        <span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token comment"># 根据给定的scale参数对特征图谱进行放大/缩小, 这里scale=2, 所以是放大</span>
            inner_top_down <span class="token operator">=</span> F<span class="token punctuation">.</span>interpolate<span class="token punctuation">(</span>last_inner<span class="token punctuation">,</span> scale_factor<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> mode<span class="token operator">=</span><span class="token string">"nearest"</span><span class="token punctuation">)</span>

            <span class="token comment"># 获取 inner_block 的计算结果</span>
            inner_lateral <span class="token operator">=</span> <span class="token builtin">getattr</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> inner_block<span class="token punctuation">)</span><span class="token punctuation">(</span>feature<span class="token punctuation">)</span>

            <span class="token comment"># 将二者叠加, 作为当前stage的输出 同时作为下一个stage的输入</span>
            last_inner <span class="token operator">=</span> inner_lateral <span class="token operator">+</span> inner_top_down

            <span class="token comment"># 将当前stage输出添加到结果列表中, 注意还要用 layer_block 执行卷积计算</span>
            <span class="token comment"># 同时为了使得分辨率最大的在前, 我们需要将结果插入到0位置</span>
            results<span class="token punctuation">.</span>insert<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token builtin">getattr</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> layer_block<span class="token punctuation">)</span><span class="token punctuation">(</span>last_inner<span class="token punctuation">)</span><span class="token punctuation">)</span>

        <span class="token comment"># 如果 top_blocks 不为空, 则执行这些额外op</span>
        <span class="token keyword">if</span> self<span class="token punctuation">.</span>top_blocks <span class="token keyword">is</span> <span class="token operator">not</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
            last_results <span class="token operator">=</span> self<span class="token punctuation">.</span>top_blocks<span class="token punctuation">(</span>results<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
            results<span class="token punctuation">.</span>extend<span class="token punctuation">(</span>last_results<span class="token punctuation">)</span> <span class="token comment"># 将新计算的结果追加到列表中</span>

        <span class="token comment"># 以元组(只读)形式返回</span>
        <span class="token keyword">return</span> <span class="token builtin">tuple</span><span class="token punctuation">(</span>results<span class="token punctuation">)</span>

<span class="token comment"># 最后一级的 max pool 层</span>
<span class="token keyword">class</span> <span class="token class-name">LastLevelMaxPool</span><span class="token punctuation">(</span>nn<span class="token punctuation">.</span>Module<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">forward</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token punctuation">[</span>F<span class="token punctuation">.</span>max_pool2d<span class="token punctuation">(</span>x<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7b8bd1b356df98372fbc6458e7efba0e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">java Apache poi 操作word生成word目录（根据word模板生成word文件）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e40f72fd3169c1f69c85f7fdbddfa4dc/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">网站图片需要付费禁止下载？这个网站神器轻松搞定！</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>