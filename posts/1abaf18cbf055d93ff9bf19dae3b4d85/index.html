<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【Java编程】面向对象程序设计--类与对象 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【Java编程】面向对象程序设计--类与对象" />
<meta property="og:description" content="目录
一、如何定义类
二、成员变量与成员函数
2.1 函数是通过.运算符来调用某个对象的函数
2.2 在成员函数内部直接调用自己（this) 的成员变量和其他函数
2.3 对象初始化
三、对象交互
四、封装（访问属性）
五、包
六、类变量和类函数
6.1 类变量
6.2 类函数
一、如何定义类 与C语言明显的区别在于，Java类是“对客观世界的建模方法”。
一个类由两种东西组成：表示对象“有什么的成员变量“和表示对象“能做什么的成员函数“。
类定义了对象长什么样，对象则是按照类的定义所制造出来的实体，一个类可以创建很多对象，每个对象有自己的数据。
类的定义与实例化
对象变量是对象的管理者而非所有者，所以涉及到赋值、函数参数传递和比较都与普通变量有所不同。
二、成员变量与成员函数 在没有引入类之前，变量是跟着代码走的。代码写到哪儿，变量写在哪里，那么运行的时候变量就在那儿。
现在，写在类里的成员变量，只是一个声明，变量并不在那里，变量不在类里，变量在每一个对象里。
2.1 函数是通过.运算符来调用某个对象的函数 对象名称.方法() vm.insertMoney() 这次调用临时建立方法 insertMoney() 与 vm 之间的关系，让 insertMoney()方法内部的成员变量指的是 vm 的成员变量。
2.2 在成员函数内部直接调用自己（this) 的成员变量和其他函数 在函数中可以直接写成员变量的名字来访问成员变量，需要通过 this 来实现。如果调用其他函数不用加 this。 public class test { int price = 80; //price1 void setPrice(int price) { this.price = price; // 调用自己的成员变量 price，将传进去的100通过this.price赋给price1 System.out.println(price); } public static void main(String[] args) { test myTest001 = new test(); myTest001." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/1abaf18cbf055d93ff9bf19dae3b4d85/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-05-28T11:52:30+08:00" />
<meta property="article:modified_time" content="2023-05-28T11:52:30+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【Java编程】面向对象程序设计--类与对象</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="h_630242738_0-toc" style="margin-left:40px;"><a href="#h_630242738_0" rel="nofollow">一、如何定义类</a></p> 
<p id="h_630242738_1-toc" style="margin-left:40px;"><a href="#h_630242738_1" rel="nofollow">二、成员变量与成员函数</a></p> 
<p id="h_630242738_2-toc" style="margin-left:80px;"><a href="#h_630242738_2" rel="nofollow">2.1 函数是通过.运算符来调用某个对象的函数</a></p> 
<p id="h_630242738_3-toc" style="margin-left:80px;"><a href="#h_630242738_3" rel="nofollow">2.2 在成员函数内部直接调用自己（this) 的成员变量和其他函数</a></p> 
<p id="h_630242738_4-toc" style="margin-left:80px;"><a href="#h_630242738_4" rel="nofollow">2.3 对象初始化</a></p> 
<p id="h_630242738_5-toc" style="margin-left:40px;"><a href="#h_630242738_5" rel="nofollow">三、对象交互</a></p> 
<p id="h_630242738_6-toc" style="margin-left:40px;"><a href="#h_630242738_6" rel="nofollow">四、封装（访问属性）</a></p> 
<p id="h_630242738_7-toc" style="margin-left:40px;"><a href="#h_630242738_7" rel="nofollow">五、包</a></p> 
<p id="h_630242738_8-toc" style="margin-left:40px;"><a href="#h_630242738_8" rel="nofollow">六、类变量和类函数</a></p> 
<p id="h_630242738_9-toc" style="margin-left:80px;"><a href="#h_630242738_9" rel="nofollow">6.1 类变量</a></p> 
<p id="h_630242738_10-toc" style="margin-left:80px;"><a href="#h_630242738_10" rel="nofollow">6.2 类函数</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h3 id="h_630242738_0">一、如何定义类</h3> 
<p>与C语言明显的区别在于，Java类是“<strong>对客观世界的建模方法</strong>”。</p> 
<p>一个类由两种东西组成：表示对象“<strong>有什么的成员变量“</strong>和表示对象“<strong>能做什么的成员函数“</strong>。</p> 
<p><strong>类定义了对象长什么样</strong>，对象则是按照类的定义所制造出来的实体，一个类可以创建很多对象，每个对象有自己的数据。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/c1/69/n1DB4mIv_o.png"></p> 
<p>类的定义与实例化</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/f6/7c/upne8tz4_o.png"></p> 
<p><strong>对象变量</strong>是对象的管理者而非所有者，所以涉及到赋值、函数参数传递和比较都与普通变量有所不同。</p> 
<hr> 
<h3 id="h_630242738_1">二、成员变量与成员函数</h3> 
<p><strong>在没有引入类之前，变量是跟着代码走的。代码写到哪儿，变量写在哪里，那么运行的时候变量就在那儿。</strong></p> 
<p><strong>现在，写在类里的成员变量，只是一个声明，变量并不在那里，变量不在类里，变量在每一个对象里。</strong></p> 
<p></p> 
<h4 id="h_630242738_2">2.1 函数是通过.运算符来调用某个对象的函数</h4> 
<pre><code>对象名称.方法()
vm.insertMoney()</code></pre> 
<p>这次调用临时建立方法 insertMoney() 与 vm 之间的关系，让 insertMoney()方法内部的成员变量指的是 vm 的成员变量。</p> 
<p></p> 
<h4 id="h_630242738_3"><strong>2.2 在成员函数内部直接调用自己（this) 的成员变量和其他函数</strong></h4> 
<ul><li>在<strong>函数</strong>中可以直接写<strong>成员变量</strong>的名字来访问成员变量，需要通过 this 来实现。如果调用其他函数不用加 this。</li></ul> 
<pre><code>public class test {
    int price = 80;   //price1

    void setPrice(int price) {      
            this.price = price;    // 调用自己的成员变量 price，将传进去的100通过this.price赋给price1    
            System.out.println(price);
        }

    public static void main(String[] args) {
        test myTest001 = new test();
        myTest001.setPrice(100);
        }
}</code></pre> 
<p>this 是<strong>成员函数</strong>的一个特殊的固有的<strong>本地变量</strong>。它表达了调用这个函数的那个对象（自己知道调用哪个对象）。</p> 
<p>定义在函数内部的变量是本地变量，<strong>定义在函数外部的变量叫成员变量</strong>。</p> 
<p>本地变量的生存期和作用域都是函数内部。<strong>成员变量的生存期</strong>是 new出一个对象后才存在。之前类只是规范。至于什么时候消失，Java有自动垃圾回收机制。<strong>成员变量的作用域</strong>是类内部（类里的成员函数可以去使用这些成员变量、成员变量初始化也会使用这些变量。</p> 
<h4 id="h_630242738_4">2.3 对象初始化</h4> 
<p>变量的初始化是程序安全很重要的一环。</p> 
<p>Java提供了多种手段来<strong>保障</strong>对象创建时的初始化，包括给每个成员变量默认的“0”值、定义初始化和构造函数。</p> 
<p></p> 
<p><strong>2.3.1 成员变量定义初始化</strong></p> 
<p>1. 成员变量在定义的地方就可以给出初始值。</p> 
<p>2. 没有给出初始值的成员变量会自动获得 0 值，对象变量的 0 值表示没有管理任何对象，也可以主动给null。</p> 
<p>3. 定义初始化可以<strong>调用函数</strong>，甚至可以使用已经定义的成员变量。</p> 
<pre><code>public class test {
    int price = 80;
    int number = f();
    float object;


    public test (int price) {
         this.price = price;
         System.out.println(price);
        }

    int f() {
        return number = 10;
    }

   int object(){
        System.out.println("object"+object);
        return 54;
    }



    public static void main(String[] args) {
        test myTest001 = new test(9);
        myTest001.object();
        System.out.println(myTest001.object());
    }
}
// 结果
9
object 0.0
object 0.0
54</code></pre> 
<p><strong>一旦创建了一个对象：</strong></p> 
<p>a. 【<em><strong>构造函数 </strong>test() 】</em>会被自动调用，记录一个参数 parameter price=9，但不进入构造函数内部。</p> 
<p>同时，本地变量this里，会自动生成所有的<strong>成员变量 </strong>(price, number, object)，并先初始化为0。</p> 
<p>b. 程序进入<strong><em>【构造函数外的定义初始化】</em></strong>（本地变量this管理的成员变量），开始赋值。不会进入一般<strong>成员函数</strong>。</p> 
<p>除非，成员变量定义的初始化调用了其他成员函数 f()，程序才会往下进入这个<strong>普通成员函数。</strong></p> 
<p>c. 然后，程序【<em><strong>进入构造函数】</strong></em>将传进去的 int 9，通过 this.price 传给成员变量price，置成9。</p> 
<p>d. 最后返回到创建对象的 new ，我们才有了【<em><strong>对象myTest001</strong></em>】(price=9, number=10, object=0.0）。</p> 
<p>e. 程序下行一步到<em>【调用函数】</em>myTest001.object()，进行了打印 object 的动作。object 0.0。</p> 
<p>f. 最后，打印 myTest001.object()，除了54的 return值外，还会有一次 object 0.0的打印。</p> 
<p></p> 
<p><strong>2.3.2 构造函数</strong></p> 
<p>如果有一个成员函数的名字和类的名字完全相同，则在创建这个类的每一个对象的时候会自动调用这个函数--&gt;构造函数。这个函数不能有返回类型，也不能有void。</p> 
<p>构造函数是对象一建立就运行，给对象初始化，就包括属性，执行方法中的语句。而一般函数是对象调用才执行，用“.方法名”的方式，给对象添加功能。<strong><em>一个对象建立，构造函数只运行一次</em></strong>，而一般函数可以被该对象调用多次。</p> 
<p>构造函数的特点：</p> 
<ul><li>函数名与类名相同</li><li>不用定义返回类型（不同于void类型返回值，<strong>void是没有具体返回值类型，构造函数是连类型都没有</strong>）</li><li>不可以写 return 语句（返回值类型都没有，不需要return语句）</li><li>构造方法在类创建对象时，执行。普通函数不执行，除非成员变量调用了它</li></ul> 
<p><strong>注意：一般函数是不能调用构造函数，只有构造函数才能调用构造函数</strong></p> 
<p></p> 
<p><strong>2.3.3 函数重载</strong></p> 
<ul><li>一个类可以有多个构造函数，只要他们的参数表不同。创建对象的时候<strong>给出不同的参数值</strong>（有参或无参），就会自动调用不同的构造函数。</li><li>通过<strong>this()还可以调用其他构造函数</strong>，一个类里的同名但参数表不同的函数构成了<strong>重载关系</strong>。</li></ul> 
<hr> 
<h3 id="h_630242738_5">三、对象交互</h3> 
<p>面向对象程序设计的第一步，就是<strong>在问题领域中识别出有效的对象，然后从识别出的对象中抽象出类来。</strong></p> 
<p>一个对象可以由其他类的对象来组成，就像一个人体里面有心脏、肠胃一样。对象是由其他对象组成的，而类定义了这样的组合关系。</p> 
<p>当一个对象里有多个对象的时候，对象和对象之间的联系紧密程度叫做耦合。对象和对象的耦合程度越紧，表现在源代码上，就是它们的代码是互相依赖、互相牵制的。</p> 
<p><strong>例如：创建一个类似数字时钟的程序，可以记录时间流逝。</strong></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/30/7b/kzbrhUMo_o.png"></p> 
<pre><code>// 画出表达两位的计数器
package Clock;

public  class Display {
    private int value = 0;
    private int limit = 0;

    public Display(int limit) {
        this.limit = limit;
    }

    public void increase() {      //这里没有循环
            value++;
            if (value == limit) {
                value = 0;
            }
        }

    public int getValue() {
        return value;
    }

    public static void main(String[] args) {
        Display hour = new Display(24);
        hour.increase();
        hour.getValue();
        Display minute = new Display(60);
        minute.increase();
        minute.getValue();

    }
}</code></pre> 
<p>我们理想的模型，是对象和对象之间的耦合要尽可能的松，平行的对象要尽量减少直接联系，让更高层次的对象来提供通信服务。</p> 
<pre><code>package Clock;

public class clock {
    Display hour = new Display(24);
    Display minute = new Display(60);
//一旦我们制造出1个clock对象，我们就会制造出两个Display对象（hour,minute)
// “定义变量“，步骤和第一个类“调用“一样


    public void start (){
        while(true){
            minute.increase();
            if (minute.getValue() == 0){
                hour.increase();
            }
            System.out.printf("%02d:%02d\n",hour.getValue(),minute.getValue());
        }
    }

    public static void main(String[] args) {
        clock clock = new clock();
        clock.start();
    }
}</code></pre> 
<p><strong>题目：如何做直接交互？</strong></p> 
<p>表示分钟的对象和表示小时的对象没有直接交互。如果想要做直接交互，让表示分钟的对象在翻转的时候直接调用表示小时的对象的那个increase函数，代码需要怎样修改？</p> 
<p>我改了两个面向过程的方式</p> 
<p>1. 直接用循环如下：</p> 
<pre><code>public class DigitalClock {

    public static void main(String[] args) {
        int hours =0;
        int minutes = 0;

        while (true) {
            System.out.printf("%02d:%02d\n", hours, minutes);
            // 每隔一分钟更新时间
            minutes++;
            if (minutes == 60) {
                minutes = 0;
                hours ++;
                if (hours == 24) {
                    hours = 0;
                }
            }
        }
    }
}</code></pre> 
<p>2. 弄一个 increase() 函数，调用一下。</p> 
<pre><code>public class DigitalClock {

        public static int increase(int hours) {
            hours++;
            if (hours == 24) {
                hours = 0;
            }
            return hours;
        }

        public static void main(String[] args) {
        int hours = 0;
        int minutes = 0;

        while (true) {
            System.out.printf("%02d:%02d\n", hours, minutes);
            minutes++;
            if (minutes == 60) {
                minutes = 0;
                hours = increase(hours);
            }
        }
    }
}</code></pre> 
<p>但好像总不是那么回事，题目的如何做交互，好像是在面向对象的设计方法上改的。初学还不太理解“直接交互“的意思。如果未来有大神可以指点下，或许可以醍醐灌顶一回。</p> 
<pre><code>    public  class DigitalClock {
    private int value = 0;
    private int limit = 0;

    public DigitalClock(int limit) {
        this.limit = limit;
    }
    public int getValue() {
        return value;
    }
    public void increase() {
        value++;
        if (value == limit) {
            value = 0;
        }
    }


    public static void main(String[] args) {
        DigitalClock hour = new DigitalClock(24);
        DigitalClock minute = new DigitalClock(60);

        while(true){
            minute.value ++;
            if (minute.getValue() == minute.limit){
                hour.increase();
                minute.value=0;
            }
            System.out.printf("%02d:%02d\n",hour.getValue(),minute.getValue());
        }
    }
}</code></pre> 
<h3 id="h_630242738_6">四、封装（访问属性）</h3> 
<p>封装，就是把数据和对这些数据的操作放在一起，并且<strong>用这些操作</strong>把<strong>数据</strong>掩盖起来。</p> 
<p>数据：属性或状态</p> 
<p>操作：函数</p> 
<p></p> 
<p><strong>保证在类的设计的时候做到封装</strong>：</p> 
<ol><li>所有的<strong>成员变量</strong>必须是private的，这样就避免别人任意使用你的内部数据；</li><li><strong>所有public的函数，只是用来实现这个类的对象或类自己要提供的服务的</strong>，<strong>而不是用来直接访问数据的</strong>。除非对数据的访问就是这个类及对象的服务。简单地说，给每个成员变量提供一对用于读写的 get/set 函数也是不合适的设计。</li></ol> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/5a/7e/FtiSyjtr_o.png"></p> 
<p><strong>private </strong>只有这个类内部可以访问：</p> 
<ul><li>类内部指类的成员函数和定义初始化（只能用于成员变量或成员函数，成员函数里面的变量不可以）</li><li>这个限制是<strong>对类的而不是对对象的</strong>（一个类的所有对象之间，可以互相访问别人的私有成员）</li></ul> 
<p><strong>public </strong>任何人都可以访问：</p> 
<ul><li>任何人指的是在任何类的函数或定义初始化中可以使用</li><li>使用指的是<strong>调用、访问</strong>或<strong>定义变量</strong></li></ul> 
<p><strong>friendly / default </strong>不带其他 public / private等：</p> 
<ul><li>和它位于同一个包的可以访问</li></ul> 
<p>如果一个类前面是 public 代表任何人都可以用这个类的定义来定义变量。而且这个类必须处于一个源代码文件中，这个源代码文件的文件名是和这个类的名字相同。</p> 
<p><strong>编译单元（compilation unit) </strong>一个 java文件就是一个编译单元，一个编译单元里可以有很多Java类。</p> 
<p>当一个编译单元有不止一个类的时候，只有一个类可以是 public。即一个源代码文件里面还可以有其他类，只要不是 public ，可以不写(代表 package-private）。</p> 
<hr> 
<h3 id="h_630242738_7">五、包</h3> 
<p>当程序越来越大的时候，就会需要有一个机制帮助管理一个工程中众多的类。<strong>包(package)就是Java的类库管理机制</strong>，它借助文件系统的目录来管理类库。一个包就是一个目录，一个包内的所有的类必须放在一个目录下，那个目录的名字必须是包的名字。</p> 
<p><strong>5.1 创建包 </strong>project - src -new (package)</p> 
<p>创建包的时候，包声明应该在源文件的第一行，每个源文件只能有一个包声明，这个文件中的每个类型都应用于它。如果一个源文件中没有使用包声明，那么其中的类，函数，枚举，注释等将被放在一个无名的包（unnamed package）中。</p> 
<p></p> 
<p><strong>5.2 使用其他包内成员的方法</strong></p> 
<p><strong>为了能够使用某一个包的成员</strong>，我们需要在 Java 程序中明确导入该包。使用 "import" 语句可完成此功能。在 java 源文件中 import 语句应位于 package 语句之后，所有类的定义之前，可以没有，也可以有多条，其语法格式为：</p> 
<blockquote>
  import package1[.package2…].(classname|*); 
</blockquote> 
<p>如果在一个包中，一个类想要使引用其他包中的类，可以使用的方法有：</p> 
<ul><li>使用 import 关键字引入 Employee 类：import payroll.Employee</li><li>使用类全名描述，例如：payroll.Employee</li><li>用 import 关键字引入，使用通配符 *：import payroll.* （不推荐）</li></ul> 
<p>在<strong>使用别人的类库</strong>和<strong>部署自己的程序</strong>的时候，包的使用显得尤为重要。</p> 
<hr> 
<h3 id="h_630242738_8">六、类变量和类函数</h3> 
<h4 id="h_630242738_9">6.1 类变量</h4> 
<p>类是描述，对象是实体。在类里所描述的成员变量，是位于这个类的每一个对象中的。</p> 
<p>而如果某个成员有 <strong>static（静态）</strong>关键字做修饰，就可以通过<strong><em>类的名字</em></strong>或者<strong><em>每个对象</em></strong>来访问到这些类变量和类函数。它属于属于整个类，但不再属于每一个对象（对象之所以可以调用，是因为对象知道自己属于这个类）。</p> 
<p>如果用 <strong>对象.成员变量 / 成员函数 </strong>修改了类变量，那么其他对象或者类本身调用的时候，均改变。</p> 
<h4 id="h_630242738_10">6.2 类函数</h4> 
<p>类函数由于不属于任何对象，因此也没有办法建立与调用它们的对象的关系，就不能访问任何非static的成员变量和成员函数了（static函数 可以调用其他 static 函数）。</p> 
<p>static 这些成员变量，只会在类的装载（程序进入到类里面去的时候）时被初始化。<strong>static 这些成员，他们的初始化与对象的创建是没有关系的。</strong></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/bbb4ecd581eb3908781f1ead951bc537/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">betterScroll基本使用和封装</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/23c9b872a2f1c723d92987af4c2d6129/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">三秒教会你如何使用scrcpy手机无线投屏到电脑</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>