<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>POJ 1631 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="POJ 1631" />
<meta property="og:description" content="题目链接：POJ 1631（最长上升子序列）
看了题目以后就知道这是最长上升子序列，本来想跳过去不做了。后来，觉得不能自满，于是就又敲了一边最长上升子序列的代码。结果TL了。这下囧了！一直不知道最长上升子序列还能优化的。百度了一下，原来很简单。
开一个数组d[],用d[i]表示长度为i的最小的那个数，这样可以大大地减小重复的次数。而且这样做空间复杂度还是一样的。不难发现d[i]十一个递增的数列。那么再查找的时候还可以二分（没有用二分也能过）
代码如下：
#include&lt;stdio.h&gt; #include&lt;string.h&gt; int const N = 40005; int main() { int n, p; int a[N], d[N]; while(scanf(&#34;%d&#34;, &amp;n) != EOF) { while(n--) { int ans = 1; scanf(&#34;%d&#34;, &amp;p); for(int i = 0; i &lt; p; &#43;&#43;i) scanf(&#34;%d&#34;, a &#43; i); d[1] = a[0]; int tt = 1; for(int i = 1; i &lt; p; &#43;&#43;i) { for(int j = tt; j &gt; 0; --j) { if(a[i] &gt; d[j]) { if(j &lt; tt &amp;&amp; d[j &#43; 1] &gt; a[i]) d[j &#43; 1] = a[i]; else if(j == tt) &#43;&#43;tt,d[tt] = a[i]; break; } else if(j &lt;= 2 &amp;&amp; a[i] &lt; d[1]) d[1] = a[i]; } } printf(&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/1815dac4dafbe1c41bdb959813745388/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2013-03-27T19:46:27+08:00" />
<meta property="article:modified_time" content="2013-03-27T19:46:27+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">POJ 1631</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>题目链接：<a href="http://poj.org/problem?id=1631" rel="nofollow noopener noreferrer" target="_blank">POJ 1631（最长上升子序列）</a></p> 
<p>看了题目以后就知道这是最长上升子序列，本来想跳过去不做了。后来，觉得不能自满，于是就又敲了一边最长上升子序列的代码。结果TL了。这下囧了！一直不知道最长上升子序列还能优化的。百度了一下，原来很简单。</p> 
<p><span style="font-size:18px">开一个数组d[],用d[i]表示长度为i的最小的那个数，这样可以大大地减小重复的次数。而且这样做空间复杂度还是一样的。不难发现d[i]十一个递增的数列。那么再查找的时候还可以二分（没有用二分也能过）</span></p> 
<p><span style="font-size:10px">代码如下：</span></p> 
<p><span style="font-size:10px"></span></p> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
int const N = 40005;

int main()
{
	int n, p;
	int a[N], d[N];
	while(scanf("%d", &amp;n) != EOF)
	{
		while(n--)
		{
			int ans = 1;
			scanf("%d", &amp;p);
			for(int i = 0; i &lt; p; ++i)
				scanf("%d", a + i);
			d[1] = a[0];
			int tt = 1;
			for(int i = 1; i &lt; p; ++i)
			{
				for(int j = tt; j &gt; 0; --j)
				{
					if(a[i] &gt; d[j])
					{
						if(j &lt; tt &amp;&amp; d[j + 1] &gt; a[i])
							d[j + 1] = a[i];
						else if(j == tt)
							++tt,d[tt] = a[i];
						break;
					}
					else if(j &lt;= 2 &amp;&amp; a[i] &lt; d[1])
						d[1] = a[i];
				}
			}
			printf("%d\n", tt);
		}
	}
	return 0;
}</code></pre> 
<br> 
<p>下面是用了二分的代码，二分有时候还真麻烦。因为不知道什么时候退出去。。。但是用了二分以后时间就变成了一半还少。</p> 
<p></p> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
int const N = 40005;

int main()
{
	int n, p;
	int a[N], d[N];
	int l, r;
	int tt;
	while(scanf("%d", &amp;n) != EOF)
	{
		while(n--)
		{
			int ans = 1;
			scanf("%d", &amp;p);
			for(int i = 0; i &lt; p; ++i)
				scanf("%d", a + i);
			d[1] = a[0], tt = 1;
			for(int i = 1; i &lt; p; ++i)
			{
				l = 1, r = tt;
				if(1 == r)
				{
					if(a[i] &lt; d[1]) d[1] = a[i];
					else tt = 2, d[2] = a[i];
				}
				else
				{
					int mid;
					while(1){
						mid = (l + r) &gt;&gt; 1;
						if(mid == r || (mid == l &amp;&amp; d[mid + 1] &gt; a[i]))
							break;
						if(d[mid + 1] &gt; a[i] &amp;&amp; d[mid] &lt; a[i])
							break;
						else{
							if(d[mid] &gt; a[i]) r = mid;
							else l = mid + 1;
						}
					}
					if(mid != 1 &amp;&amp; mid &lt; tt)
						d[mid + 1] = a[i];
					else if(mid == 1){
						if(a[i] &lt; d[1]) d[1] = a[i];
						else d[2] = a[i];
					}
					else{
						if(a[i] &lt; d[tt])
							d[tt] = a[i];
						else
							++tt, d[tt] = a[i];
					}
				}
			}
			printf("%d\n", tt);
		}
	}
	return 0;
}</code></pre> 
<br> 
<br> 
<p></p> 
<p></p> 
<p><span style="font-size:10px"></span></p> 看来我还是太菜了！acm之路艰巨而遥远呐！要加油！！！！ 
<br> 
<br> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/450aae4f3e6dc3468add69a85638cb96/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">SQL Server 2008 高可用性视频（二）-- 日志传送</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/133391890d0ce282b2da79f81b904e63/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">字符串处理(七)strtod、strtof、strtold等</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>