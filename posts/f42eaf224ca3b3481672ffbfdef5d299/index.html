<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>什么是多态? - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="什么是多态?" />
<meta property="og:description" content="来自http://blog.csdn.net/softart/archive/2007/10/27/1846041.aspx
一．什么是多态（Polymorphism） 多态（Polymorphism）是面向对象（Object-Oriented，OO）思想&#34;三大特征&#34;之一，其余两个分别是封装（Encapsulation）和继承（Inheritance）--可见多态的重要性。或者说，不懂得什么是多态就不能说懂得面向对象。
多态是一种机制、一种能力，而非某个关键字。它在类的继承中得以实现，在类的方法调用中得以体现。
先让我们看看MSDN里给出的定义：
Through inheritance, a class can be used as more than one type; it can be used as its own type, any base types, or any interface type if it implements interfaces. This is called polymorphism. In C#, every type is polymorphic. Types can be used as their own type or as a Object instance, because any type automatically treats Object as a base type." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/f42eaf224ca3b3481672ffbfdef5d299/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-07-04T12:30:50+08:00" />
<meta property="article:modified_time" content="2019-07-04T12:30:50+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">什么是多态?</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="cnblogs_post_body" class="blogpost-body"> 
 <p><span style="font-size:13px;">来自<span style="font-family:'宋体';">http://blog.csdn.net/softart/archive/2007/10/27/1846041.aspx</span></span></p> 
 <h4><span style="font-size:x-large;">一．什么是多态（<span style="font-family:'Times New Roman';">Polymorphism</span>）</span></h4> 
 <p>多态（Polymorphism）是面向对象（Object-Oriented，OO）思想"三大特征"之一，其余两个分别是封装（Encapsulation）和继承（Inheritance）--可见多态的重要性。或者说，不懂得什么是多态就不能说懂得面向对象。</p> 
 <p>多态是一种机制、一种能力，而非某个关键字。它在类的继承中得以实现，在类的方法调用中得以体现。</p> 
 <p>先让我们看看MSDN里给出的定义：</p> 
 <p>Through inheritance, a class can be used as more than one type; it can be used as its own type, any base types, or any interface type if it implements interfaces. This is called polymorphism. In C#, every type is polymorphic. Types can be used as their own type or as a Object instance, because any type automatically treats Object as a base type.</p> 
 <p>译文：通过继承，一个类可以被当作不止一个数据类型（type）使用，它可以被用做自身代表的数据类型（这是最常用的），还可以被当作它的任意基类所代表的数据类型，乃至任意接口类型--前提是这个类实现了这个接口。这一机制称为"多态"。在C#中，所有的数据类型都是多态的。任意一个数据类型都可以被当作自身来使用，也可以当作Object类型来使用（我怀疑原文有问题，那个instance可能是原作者的笔误），因为任何数据类型都自动以Object为自己的基类。</p> 
 <p>呵呵，除非你已经早就知道了什么是多态然后翻过头来看上面一段话，不然我敢打保票--我是清清楚楚的，你是稀里糊涂的。OK，不难为大家了，我用几个句子说明一下多态的思想。</p> 
 <p>我们先把前文中提到的"接口"理解为"一组功能的集合"，把"类"理解为功能的实现体。这样的例子多了去了。我们就拿生物界做比喻了：</p> 
 <p>功能集合1：呼吸系统</p> 
 <p>功能集合2：血液循环系统</p> 
 <p>功能集合3：神经系统</p> 
 <p>功能集合4：语言系统</p> 
 <p>类1：灵长类动物。此类实现了1到3功能集合。</p> 
 <p>类2：猴子类。继承自类1。新添加了"爬树"的功能。</p> 
 <p>类3：人类。继承自类1。同时实现了功能集合4。</p> 
 <p>类4：男人类。继承自类3。新添加了"写程序"的功能。</p> 
 <p>类5：女人类。继承自类3。新添加了"发脾气"的功能。</p> 
 <p><strong>作业：</strong>请大家把上面的关系用图画出来</p> 
 <p>OK，让我们看下面的话，判断对错：</p> 
 <p>1. 男人是男人 （√） 原因：本来就是！</p> 
 <p>2. 男人是人 （√） 原因：人类是男人类的基类</p> 
 <p>3. 男人是灵长类动物 （√）原因：灵长类是男人类的更抽象层基类</p> 
 <p>4. 男人是会说话的 （√） 原因：男人类的基类实现了语言系统</p> 
 <p>5. 女人是猴子 （×） 原因：如果我这么说，会被蹁死</p> 
 <p>6. 猴子是女人 （×） 原因：女人不是猴子的基类</p> 
 <p>7. 人会写程序 （×）原因：写程序方法是在男人类中才具体实现的</p> 
 <p>8. 女人会发脾气 （√） 原因：因为我说5..</p> 
 <p>哈哈！现在你明白什么是多态了吧！其实是非常简单的逻辑思维。上面仅仅是多态的一个概念，下面我们通过代码去研习一下程序中的多态到底是什么。</p> 
 <h4><span style="font-size:x-large;">二．多态的基础--虚函数（<span style="font-family:'Times New Roman';">virtual</span>）和重写（<span style="font-family:'Times New Roman';">override</span>）</span></h4> 
 <p>很多公司在面试的时候常拿下面几个问题当开胃小菜：</p> 
 <p>1. 如何使用virtual和override？</p> 
 <p>2. 如何使用abstract和override？</p> 
 <p>3. "重写"与"重载"一样吗？</p> 
 <p>4. "重写"、"覆盖"、"隐藏"是同一个概念吗？</p> 
 <p>顺便说一句：如果你确定能把上面的概念很熟练的掌握，发个Mail给我(<a href="mailto:bladey@tom.com" rel="nofollow">bladey@tom.com</a> )，也许你能收到一份薪水和福利都不错的Offer :p</p> 
 <p>今天我们学习多态，其实就是解决问题1。前面已经提到过，多态机制是依靠继承机制实现的。那么，在常规继承机制的基础之上，在基类中使用virtual函数，并在其派生类中对virtual函数进行override，那么多态机制就自然而然地产生了。</p> 
 <p><strong>小议</strong><strong>virtual</strong><strong>：</strong></p> 
 <p>呵呵，我这人比较笨--有我的老师和同学为证--学东西奇慢无比，所以当初在C++中学习virtual的历程是我心中永远挥之不去的阴影..倒霉就倒霉 在这个"虚"字上了。"实"的我还云里雾里呢，更何况这"虚"的，"虚"的还没搞清楚呢，"纯虚"又蹦出来了， 我#@$%!^#&amp;&amp;!..</p> 
 <p>还好，我挺过来了..回顾这段学习历程，我发现万恶之源就是这个"虚"字。</p> 
 <p>在汉语中，"虚"就是"无"，"无"就是"没有"，没有的事情就"不可说"、"不可讲"--那还讲个X？？老师也头疼，学生更头疼。拜初中语文老师所赐，我的语言逻辑还算过关，总感觉virtual function译为"虚函数"有点词不达意。</p> 
 <p>找来词典一查，virtual有这样一个词条：</p> 
 <p>Existing or resulting in essence or effect though not in actual fact, form, or name:</p> 
 <p>实质上的，实际上的：虽然没有实际的事实、形式或名义，但在实际上或效果上存在或产生的：</p> 
 <p>例句：</p> 
 <p>the virtual extinction of the buffalo.</p> 
 <p>野牛实际上已经绝迹（隐含的意思是"尽管野牛还木有死光光，但从效果上来讲.."）</p> 
 <p>啊哦~~让我想起一句话：</p> 
 <p>有的人活着他已经死了； 有的人死了他还活着..</p> 
 <p>不禁有点惊叹于母语的博大精深--</p> 
 <p>virtual function中的virtual应该译做"<strong>名存实亡</strong>"而不是"虚"！</p> 
 <p>OK，下面就让我们看看类中的virtual函数是怎么个"名存实亡"法。</p> 
 <p><strong>例子</strong><strong>1</strong><strong>：</strong> <strong>非</strong><strong>virtual / override</strong><strong>程序</strong></p> 
 <p><br> // 水之真谛 //<br> // <a href="http://blog.csdn.net/FantasiaX">http://blog.csdn.net/FantasiaX</a> //<br> // 上善若水，润物无声 //<br><br> using System;<br> using System.Collections.Generic;<br> using System.Text;<br><br> namespace Sample<br> {<!-- --><br> // 演员（类）<br> class Actor<br> {<!-- --><br> public void DoShow()<br> {<!-- --><br> Console.WriteLine("Doing a show...");<br> }<br> }<br><br> // 乐手（类），继承自Actor类<br> class Bandsman : Actor<br> {<!-- --><br> // 子类同名方法隐藏父类方法<br> // 其实标准写法应该是：<br> // public new void DoShow(){...}<br> // 为了突出"同名"，我把new省了，编译器会自动识别<br> public void DoShow()<br> {<!-- --><br> Console.WriteLine("Playing musical instrument...");<br> }<br> }<br><br> // 吉他手（类），继承自Bandsman类<br> class Guitarist : Bandsman<br> {<!-- --><br> public new void DoShow()<br> {<!-- --><br> Console.WriteLine("Playing a guitar solo...");<br> }<br> }<br><br> class Program<br> {<!-- --><br> static void Main(string[] args)<br> {<!-- --><br> // 正常声明<br> Actor actor = new Actor();<br> Bandsman bandsman = new Bandsman();<br> Guitarist guitarist = new Guitarist();<br><br> // 一般情况下，随着类的承继和方法的重写<br> // 方法是越来越具体、越来越个性化<br> actor.DoShow();<br> bandsman.DoShow();<br> guitarist.DoShow();<br><br> Console.WriteLine("===========================");<br><br> //尝试多态用法<br> Actor myActor1 = new Bandsman(); //正确：乐手是演员<br> Actor myActor2 = new Guitarist(); //正确：吉他手是演员<br> Bandsman myBandsman = new Guitarist(); //正确：吉他手是乐手<br><br> //仍然调用的是引用类型自身的方法，而非派生类的方法<br> myActor1.DoShow();<br> myActor2.DoShow();<br> myBandsman.DoShow();<br> }<br> }<br> }<br></p> 
 <p><strong>代码分析：</strong></p> 
 <p>1. 一上来，演员类、乐手类、吉他手类形成一个继承链。</p> 
 <p>2. 乐手类和吉他手类作为子类，都把其父类的DoShow()方法"隐藏"了。</p> 
 <p>3. 特别强调："隐藏"不是"覆盖"，后面要讲的"重写"才是真正的"覆盖"。</p> 
 <p>4. 隐藏是使用new修饰符实现的，但这个修饰符可以省略。</p> 
 <p>5. 隐藏（Hide）的含意是：父类的这个函数实际上还在，只是被子类的同名"藏起来"了。</p> 
 <p>6. 重写（override）与覆盖是同一个含意，只是覆盖并非编程的术语，但"覆盖"比较形象。</p> 
 <p>7. 主程序代码的上半部分是常规使用方法，没什么好说的。</p> 
 <p>8. 主程序代码的下半部分已经算是多态了，但由于没有使用virtual和override，多态最有价值的效果--个性化方法实现--没有体现出来。后面的例子专门体现这一点。</p> 
 <p><strong>例子</strong><strong>2</strong><strong>：</strong> <strong>应用</strong><strong>virtual / override</strong><strong>，真正的多态</strong></p> 
 <p align="left"><br> // 水之真谛 //<br> // <a href="http://blog.csdn.net/FantasiaX">http://blog.csdn.net/FantasiaX</a> //<br> // 上善若水，润物无声 //<br><br> using System;<br> using System.Collections.Generic;<br> using System.Text;<br><br> namespace Sample<br> {<!-- --><br> // 演员（类）<br> class Actor<br> {<!-- --><br> // 使用了virtual来修饰函数<br> // 此函数已经"名存实亡"了<br> public virtual void DoShow()<br> {<!-- --><br> Console.WriteLine("Doing a show...");<br> }<br> }<br><br> // 乐手（类），继承自Actor类<br> class Bandsman : Actor<br> {<!-- --><br> // 使用了override来修饰函数<br> // 此函数将取代（重写）父类中的同名函数<br> public override void DoShow()<br> {<!-- --><br> Console.WriteLine("Playing musical instrument...");<br> }<br> }<br><br> // 吉他手（类），继承自Bandsman类<br> class Guitarist : Bandsman<br> {<!-- --><br> public override void DoShow()<br> {<!-- --><br> Console.WriteLine("Playing a guitar solo...");<br> }<br> }<br><br> class Program<br> {<!-- --><br> static void Main(string[] args)<br> {<!-- --><br> // 正常声明<br> Actor actor = new Actor();<br> Bandsman bandsman = new Bandsman();<br> Guitarist guitarist = new Guitarist();<br><br> // 一般情况下，随着类的承继和方法的重写<br> // 方法是越来越具体、越来越个性化<br> actor.DoShow();<br> bandsman.DoShow();<br> guitarist.DoShow();<br><br> Console.WriteLine("===========================");<br><br> //尝试多态用法<br> Actor myActor1 = new Bandsman(); //正确：乐手是演员<br> Actor myActor2 = new Guitarist(); //正确：吉他手是演员<br> Bandsman myBandsman = new Guitarist(); //正确：吉他手是乐手<br><br> // Look!!!</p> 
 <p align="left">// 调用的是引用类型所引用的实例的方法</p> 
 <p align="left">// 引用类型本身的函数是virtual的</p> 
 <p align="left">// 看似"存在"，实际已经被其子类重写（不是隐藏，而是被kill掉了）</p> 
 <p>// 这正是virtual所要表达的"名存实亡"的本意，而非一个"虚"字所能传达<br> myActor1.DoShow();<br> myActor2.DoShow();<br> myBandsman.DoShow();<br> }<br> }<br> }<br></p> 
 <p><strong>代码分析：</strong></p> 
 <p>1. 除了将继承链中最顶层基类的DoShow()方法改为用virtual修饰；把继承链中派生类的DoShow()方法改为override修饰以重写基类的方法。</p> 
 <p>2. 主程序代码没变，但下半部分产生的效果完全不同！请体会"引用变量本身方法"与"引用变量所引用实例的方法"的不同--这是关键。</p> 
 <p><strong>多态成因的分析：</strong></p> 
 <p> 为什么会产生这样的效果呢？这里要提到一个"virtual表"的问题。我们看看程序中继承链的构成：Actor à Bandsman à Guitarist。因为派生类不但继承了基类的代码（确切地说是public代码）而且还有自己的特有代码（无论是不是与基类同名，都是自己特有的）。 从程序的逻辑视角来看，你可以这样想象：在内存中，子类的实例所占的内存块是在父类所占的内存块的基础上"追加"了一小块--拜托大家自己画画图。这多出 来的一小块里，装的就是子类特有的数据和代码。</p> 
 <p>我们仔细分析这几句代码：</p> 
 <p>1. Actor actor = new Actor(); //常规的声明及分配内存方法<br> 因为类是引用类型，所以actor这个引用变量是放在栈里的、类型是Actor类型，而它所引用的实例--同样也是Actor类型的--内存由new操作 符来分配并且放在堆里。这样，引用变量与实例的类型一模一样、完全匹配。换句话说：栈里的引用变量所能"管理"的堆中的内存块大小正好、不多也不少。<br></p> 
 <p>2. Actor myActor1 = new Bandsman(); //正确：乐手是演员<br> 同样是这句代码，在两个例子中产生的效果完全不同。为什么呢？且看！在例1中，在Bandsman类中只是使用new将父类的DoShow()给隐藏了 --所起的作用仅限于自己对父类追加的代码块中，丝毫没有影响到父类。而栈中的引用变量是Actor类型的myActor1，它只能管理Actor类实例 所占的那么大一块内存，而对追加的内存毫无控制能力（或者说看不见追加的这块内存）。因此，当你使用myActor1.DoShow();调用成员方法 时，myActor1只能使唤自己能管到的那块内存里的DoShow()方法。那么例2中呢？难道例2中的myActor1就能管理追加的一块内存了吗？否也！它仍然管理不了，但不要忘了--这时候Actor类中的DoShow()方法已经被virtual所修饰，同时Bandsman类中的DoShow()方法已经被override修饰。这时候，当执行myActor1.DoShow();一句时，myActor1调用自己所管辖的内存块时，发现DoShow()这个 函数已经标记为"可被重写"了（其实，在VB.NET中，与C#的virtual关键字对应的关键字就是Overridable，更直白），那么它就会尝 试去发现有没有override链（也就是virtual表，即"虚表"）的存在，如果存在，那么就调用override链上的最新可用版本--这就有了 我们在例2中看到的效果。<br></p> 
 <p>3. Actor myActor2 = new Guitarist(); //正确：吉他手是演员<br> 通过这句代码，你也可以想象一下2级重写是怎么形成的，同时也可以感悟一下所谓"重写链上最新的可用版本"是什么意思。</p> 
 <p>4. Guitarist myActor2 = new Actor(); //错误：想一想为什么？<br> 呵呵，这是错误的，原因是引用变量所管理的内存大小超出了实例实际的内存大小。</p> 
 <p><strong>乱弹：</strong></p> 
 <p> 多态，台湾的兄弟们喜欢称"多型"，一样的。"多"表示在实例化引用变量的时候，根据用户当时的使用情况（这时候程序已经Release了，不能再修改了，程序员已经不能控制程序了）智能地给出个性化的响应。</p> 
 <p> 多，谓之变。莫非"多态"亦可称为"变态"耶？咦.."变型"..让我想起Transformer来了。</p> 
 <p><strong>TO BE CONTINUE</strong></p> 
</div> 
<p>转载于:https://www.cnblogs.com/Eleanore/p/3210705.html</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/40602048c055d8c0fda6a5ddf68f148d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">SqlDataReader的用法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/245e3a35f099df6f037090f3550a207a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">VMware安装Ghost版Win10 失败的解决方法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>