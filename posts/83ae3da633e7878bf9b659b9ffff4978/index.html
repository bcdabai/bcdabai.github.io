<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>微信小程序中使用 async 和 await - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="微信小程序中使用 async 和 await" />
<meta property="og:description" content="在⼩程序的开发⼯具中，勾选 es6转es5语法下载 facebook的regenerator库中的 https://github.com/facebook/regenerator/blob/5703a79746fffc152600fdcef46ba9230671025a/packages/regenerator-runtime/runtime.js在⼩程序⽬录下新建⽂件夹 lib/runtime/runtime.js ，将代码拷⻉进去在每⼀个需要使⽤async语法的⻚⾯js⽂件中，都引⼊（不能全局引⼊） 引入方式 ： import regeneratorRuntime from ‘…/…/lib/runtime/runtime’ (一定是这一样行代码引入)
runtime.js 文件中需要拷贝的代码如下：(或者自己到github上去拷贝也可以，github链接地址在第二步上已给出)
/** * Copyright (c) 2014-present, Facebook, Inc. * * This source code is licensed under the MIT license found in the * LICENSE file in the root directory of this source tree. */ var regeneratorRuntime = (function (exports) { &#34;use strict&#34;; var Op = Object.prototype; var hasOwn = Op.hasOwnProperty; var undefined; // More compressible than void 0." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/83ae3da633e7878bf9b659b9ffff4978/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-01-22T14:09:38+08:00" />
<meta property="article:modified_time" content="2020-01-22T14:09:38+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">微信小程序中使用 async 和 await</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <ol><li>在⼩程序的开发⼯具中，勾选 es6转es5语法</li><li>下载 facebook的regenerator库中的 <a href="https://github.com/facebook/regenerator/blob/5703a79746fffc152600fdcef46ba9230671025a/packages/regenerator-runtime/runtime.js">https://github.com/facebook/regenerator/blob/5703a79746fffc152600fdcef46ba9230671025a/packages/regenerator-runtime/runtime.js</a></li><li>在⼩程序⽬录下新建⽂件夹 lib/runtime/runtime.js ，将代码拷⻉进去</li><li>在每⼀个需要使⽤async语法的⻚⾯js⽂件中，都引⼊（不能全局引⼊）</li></ol> 
<h5><a id="__4"></a>引入方式 ：</h5> 
<p><strong>import regeneratorRuntime from ‘…/…/lib/runtime/runtime’</strong> (一定是这一样行代码引入)</p> 
<p>runtime.js 文件中需要拷贝的代码如下：(或者自己到github上去拷贝也可以，github链接地址在第二步上已给出)</p> 
<pre><code class="prism language-bash">/**
 * Copyright <span class="token punctuation">(</span>c<span class="token punctuation">)</span> 2014-present, Facebook, Inc.
 *
 * This <span class="token function">source</span> code is licensed under the MIT license found <span class="token keyword">in</span> the
 * LICENSE <span class="token function">file</span> <span class="token keyword">in</span> the root directory of this <span class="token function">source</span> tree.
 */

var regeneratorRuntime <span class="token operator">=</span> <span class="token punctuation">(</span>function <span class="token punctuation">(</span>exports<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token string">"use strict"</span><span class="token punctuation">;</span>

  var Op <span class="token operator">=</span> Object.prototype<span class="token punctuation">;</span>
  var hasOwn <span class="token operator">=</span> Op.hasOwnProperty<span class="token punctuation">;</span>
  var undefined<span class="token punctuation">;</span> // More compressible than void 0.
  var <span class="token variable">$Symbol</span> <span class="token operator">=</span> typeof Symbol <span class="token operator">==</span><span class="token operator">=</span> <span class="token string">"function"</span> ? Symbol <span class="token keyword">:</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  var iteratorSymbol <span class="token operator">=</span> <span class="token variable">$Symbol</span>.iterator <span class="token operator">||</span> <span class="token string">"@@iterator"</span><span class="token punctuation">;</span>
  var asyncIteratorSymbol <span class="token operator">=</span> <span class="token variable">$Symbol</span>.asyncIterator <span class="token operator">||</span> <span class="token string">"@@asyncIterator"</span><span class="token punctuation">;</span>
  var toStringTagSymbol <span class="token operator">=</span> <span class="token variable">$Symbol</span>.toStringTag <span class="token operator">||</span> <span class="token string">"@@toStringTag"</span><span class="token punctuation">;</span>

  <span class="token keyword">function</span> wrap<span class="token punctuation">(</span>innerFn, outerFn, self, tryLocsList<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    // If outerFn provided and outerFn.prototype is a Generator, <span class="token keyword">then</span> outerFn.prototype instanceof Generator.
    var protoGenerator <span class="token operator">=</span> outerFn <span class="token operator">&amp;&amp;</span> outerFn.prototype instanceof Generator ? outerFn <span class="token keyword">:</span> Generator<span class="token punctuation">;</span>
    var generator <span class="token operator">=</span> Object.create<span class="token punctuation">(</span>protoGenerator.prototype<span class="token punctuation">)</span><span class="token punctuation">;</span>
    var context <span class="token operator">=</span> new Context<span class="token punctuation">(</span>tryLocsList <span class="token operator">||</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke <span class="token operator">=</span> makeInvokeMethod<span class="token punctuation">(</span>innerFn, self, context<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> generator<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  exports.wrap <span class="token operator">=</span> wrap<span class="token punctuation">;</span>

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries<span class="token punctuation">[</span>i<span class="token punctuation">]</span>.completion. This interface could
  // have been <span class="token punctuation">(</span>and was previously<span class="token punctuation">)</span> designed to take a closure to be
  // invoked without arguments, but <span class="token keyword">in</span> all the cases we care about we
  // already have an existing method we want to call, so there<span class="token string">'s no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don'</span>t have to <span class="token function">touch</span> the arguments object. The
  // only additional allocation required is the completion record, <span class="token function">which</span>
  // has a stable shape and so hopefully should be cheap to allocate.
  <span class="token keyword">function</span> tryCatch<span class="token punctuation">(</span>fn, obj, arg<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    try <span class="token punctuation">{<!-- --></span>
      <span class="token keyword">return</span> <span class="token punctuation">{<!-- --></span> type: <span class="token string">"normal"</span>, arg: fn.call<span class="token punctuation">(</span>obj, arg<span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> catch <span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      <span class="token keyword">return</span> <span class="token punctuation">{<!-- --></span> type: <span class="token string">"throw"</span>, arg: err <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  var GenStateSuspendedStart <span class="token operator">=</span> <span class="token string">"suspendedStart"</span><span class="token punctuation">;</span>
  var GenStateSuspendedYield <span class="token operator">=</span> <span class="token string">"suspendedYield"</span><span class="token punctuation">;</span>
  var GenStateExecuting <span class="token operator">=</span> <span class="token string">"executing"</span><span class="token punctuation">;</span>
  var GenStateCompleted <span class="token operator">=</span> <span class="token string">"completed"</span><span class="token punctuation">;</span>

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">;</span>

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties <span class="token keyword">for</span> functions that <span class="token keyword">return</span> Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  <span class="token keyword">function</span> Generator<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
  <span class="token keyword">function</span> GeneratorFunction<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
  <span class="token keyword">function</span> GeneratorFunctionPrototype<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>

  // This is a polyfill <span class="token keyword">for</span> %IteratorPrototype% <span class="token keyword">for</span> environments that
  // don<span class="token string">'t natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto &amp;&amp; getProto(getProto(values([])));
  if (NativeIteratorPrototype &amp;&amp;
      NativeIteratorPrototype !== Op &amp;&amp;
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] =
    GeneratorFunction.displayName = "GeneratorFunction";

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      prototype[method] = function(arg) {
        return this._invoke(method, arg);
      };
    });
  }

  exports.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" &amp;&amp; genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  exports.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      if (!(toStringTagSymbol in genFun)) {
        genFun[toStringTagSymbol] = "GeneratorFunction";
      }
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, <span class="token variable"><span class="token variable">`</span>await x<span class="token variable">`</span></span> is transformed to
  // <span class="token variable"><span class="token variable">`</span>yield regeneratorRuntime.awrap<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token variable">`</span></span>, so that the runtime can test
  // <span class="token variable"><span class="token variable">`</span>hasOwn.call<span class="token punctuation">(</span>value, <span class="token string">"__await"</span><span class="token punctuation">)</span><span class="token variable">`</span></span> to determine if the yielded value is
  // meant to be awaited.
  exports.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &amp;&amp;
            typeof value === "object" &amp;&amp;
            hasOwn.call(value, "__await")) {
          return Promise.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return Promise.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise&lt;{value,done}&gt; result for the
          // current iteration.
          result.value = unwrapped;
          resolve(result);
        }, function(error) {
          // If a rejected Promise was yielded, throw the rejection back
          // into the async generator function so it can be handled there.
          return invoke("throw", error, resolve, reject);
        });
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new Promise(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };
  exports.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  exports.async = function(innerFn, outerFn, self, tryLocsList) {
    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList)
    );

    return exports.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel'</span>s
          // function.sent implementation.
          context.sent <span class="token operator">=</span> context._sent <span class="token operator">=</span> context.arg<span class="token punctuation">;</span>

        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>context.method <span class="token operator">==</span><span class="token operator">=</span> <span class="token string">"throw"</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
          <span class="token keyword">if</span> <span class="token punctuation">(</span>state <span class="token operator">==</span><span class="token operator">=</span> GenStateSuspendedStart<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            state <span class="token operator">=</span> GenStateCompleted<span class="token punctuation">;</span>
            throw context.arg<span class="token punctuation">;</span>
          <span class="token punctuation">}</span>

          context.dispatchException<span class="token punctuation">(</span>context.arg<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>context.method <span class="token operator">==</span><span class="token operator">=</span> <span class="token string">"return"</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
          context.abrupt<span class="token punctuation">(</span><span class="token string">"return"</span>, context.arg<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        state <span class="token operator">=</span> GenStateExecuting<span class="token punctuation">;</span>

        var record <span class="token operator">=</span> tryCatch<span class="token punctuation">(</span>innerFn, self, context<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>record.type <span class="token operator">==</span><span class="token operator">=</span> <span class="token string">"normal"</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
          // If an exception is thrown from innerFn, we leave state <span class="token operator">==</span><span class="token operator">=</span>
          // GenStateExecuting and loop back <span class="token keyword">for</span> another invocation.
          state <span class="token operator">=</span> context.done
            ? GenStateCompleted
            <span class="token keyword">:</span> GenStateSuspendedYield<span class="token punctuation">;</span>

          <span class="token keyword">if</span> <span class="token punctuation">(</span>record.arg <span class="token operator">==</span><span class="token operator">=</span> ContinueSentinel<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">continue</span><span class="token punctuation">;</span>
          <span class="token punctuation">}</span>

          <span class="token keyword">return</span> <span class="token punctuation">{<!-- --></span>
            value: record.arg,
            done: context.done
          <span class="token punctuation">}</span><span class="token punctuation">;</span>

        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>record.type <span class="token operator">==</span><span class="token operator">=</span> <span class="token string">"throw"</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
          state <span class="token operator">=</span> GenStateCompleted<span class="token punctuation">;</span>
          // Dispatch the exception by looping back around to the
          // context.dispatchException<span class="token punctuation">(</span>context.arg<span class="token punctuation">)</span> call above.
          context.method <span class="token operator">=</span> <span class="token string">"throw"</span><span class="token punctuation">;</span>
          context.arg <span class="token operator">=</span> record.arg<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  // Call delegate.iterator<span class="token punctuation">[</span>context.method<span class="token punctuation">]</span><span class="token punctuation">(</span>context.arg<span class="token punctuation">)</span> and handle the
  // result, either by returning a <span class="token punctuation">{<!-- --></span> value, <span class="token keyword">done</span> <span class="token punctuation">}</span> result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  <span class="token keyword">function</span> maybeInvokeDelegate<span class="token punctuation">(</span>delegate, context<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    var method <span class="token operator">=</span> delegate.iterator<span class="token punctuation">[</span>context.method<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>method <span class="token operator">==</span><span class="token operator">=</span> undefined<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate <span class="token operator">=</span> null<span class="token punctuation">;</span>

      <span class="token keyword">if</span> <span class="token punctuation">(</span>context.method <span class="token operator">==</span><span class="token operator">=</span> <span class="token string">"throw"</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>delegate.iterator.return<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
          // If the delegate iterator has a <span class="token keyword">return</span> method, give it a
          // chance to clean up.
          context.method <span class="token operator">=</span> <span class="token string">"return"</span><span class="token punctuation">;</span>
          context.arg <span class="token operator">=</span> undefined<span class="token punctuation">;</span>
          maybeInvokeDelegate<span class="token punctuation">(</span>delegate, context<span class="token punctuation">)</span><span class="token punctuation">;</span>

          <span class="token keyword">if</span> <span class="token punctuation">(</span>context.method <span class="token operator">==</span><span class="token operator">=</span> <span class="token string">"throw"</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            // If maybeInvokeDelegate<span class="token punctuation">(</span>context<span class="token punctuation">)</span> changed context.method from
            // <span class="token string">"return"</span> to <span class="token string">"throw"</span>, <span class="token keyword">let</span> that override the TypeError below.
            <span class="token keyword">return</span> ContinueSentinel<span class="token punctuation">;</span>
          <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>

        context.method <span class="token operator">=</span> <span class="token string">"throw"</span><span class="token punctuation">;</span>
        context.arg <span class="token operator">=</span> new TypeError<span class="token punctuation">(</span>
          <span class="token string">"The iterator does not provide a 'throw' method"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>

      <span class="token keyword">return</span> ContinueSentinel<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    var record <span class="token operator">=</span> tryCatch<span class="token punctuation">(</span>method, delegate.iterator, context.arg<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>record.type <span class="token operator">==</span><span class="token operator">=</span> <span class="token string">"throw"</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      context.method <span class="token operator">=</span> <span class="token string">"throw"</span><span class="token punctuation">;</span>
      context.arg <span class="token operator">=</span> record.arg<span class="token punctuation">;</span>
      context.delegate <span class="token operator">=</span> null<span class="token punctuation">;</span>
      <span class="token keyword">return</span> ContinueSentinel<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    var info <span class="token operator">=</span> record.arg<span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span> info<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      context.method <span class="token operator">=</span> <span class="token string">"throw"</span><span class="token punctuation">;</span>
      context.arg <span class="token operator">=</span> new TypeError<span class="token punctuation">(</span><span class="token string">"iterator result is not an object"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      context.delegate <span class="token operator">=</span> null<span class="token punctuation">;</span>
      <span class="token keyword">return</span> ContinueSentinel<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>info.done<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName <span class="token punctuation">(</span>see delegateYield<span class="token punctuation">)</span>.
      context<span class="token punctuation">[</span>delegate.resultName<span class="token punctuation">]</span> <span class="token operator">=</span> info.value<span class="token punctuation">;</span>

      // Resume execution at the desired location <span class="token punctuation">(</span>see delegateYield<span class="token punctuation">)</span>.
      context.next <span class="token operator">=</span> delegate.nextLoc<span class="token punctuation">;</span>

      // If context.method was <span class="token string">"throw"</span> but the delegate handled the
      // exception, <span class="token keyword">let</span> the outer generator proceed normally. If
      // context.method was <span class="token string">"next"</span>, forget context.arg since it has been
      // <span class="token string">"consumed"</span> by the delegate iterator. If context.method was
      // <span class="token string">"return"</span>, allow the original .return call to <span class="token keyword">continue</span> <span class="token keyword">in</span> the
      // outer generator.
      <span class="token keyword">if</span> <span class="token punctuation">(</span>context.method <span class="token operator">!=</span><span class="token operator">=</span> <span class="token string">"return"</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        context.method <span class="token operator">=</span> <span class="token string">"next"</span><span class="token punctuation">;</span>
        context.arg <span class="token operator">=</span> undefined<span class="token punctuation">;</span>
      <span class="token punctuation">}</span>

    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
      // Re-yield the result returned by the delegate method.
      <span class="token keyword">return</span> info<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    // The delegate iterator is finished, so forget it and <span class="token keyword">continue</span> with
    // the outer generator.
    context.delegate <span class="token operator">=</span> null<span class="token punctuation">;</span>
    <span class="token keyword">return</span> ContinueSentinel<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  // Define Generator.prototype.<span class="token punctuation">{<!-- --></span>next,throw,return<span class="token punctuation">}</span> <span class="token keyword">in</span> terms of the
  // unified ._invoke helper method.
  defineIteratorMethods<span class="token punctuation">(</span>Gp<span class="token punctuation">)</span><span class="token punctuation">;</span>

  Gp<span class="token punctuation">[</span>toStringTagSymbol<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"Generator"</span><span class="token punctuation">;</span>

  // A Generator should always <span class="token keyword">return</span> itself as the iterator object when the
  // @@iterator <span class="token keyword">function</span> is called on it. Some browsers<span class="token string">' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn'</span>t happen.
  // See https://github.com/facebook/regenerator/issues/274 <span class="token keyword">for</span> <span class="token function">more</span> details.
  Gp<span class="token punctuation">[</span>iteratorSymbol<span class="token punctuation">]</span> <span class="token operator">=</span> function<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> this<span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>

  Gp.toString <span class="token operator">=</span> function<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> <span class="token string">"[object Generator]"</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>

  <span class="token keyword">function</span> pushTryEntry<span class="token punctuation">(</span>locs<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    var entry <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span> tryLoc: locs<span class="token punctuation">[</span>0<span class="token punctuation">]</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>1 <span class="token keyword">in</span> locs<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      entry.catchLoc <span class="token operator">=</span> locs<span class="token punctuation">[</span>1<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>2 <span class="token keyword">in</span> locs<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      entry.finallyLoc <span class="token operator">=</span> locs<span class="token punctuation">[</span>2<span class="token punctuation">]</span><span class="token punctuation">;</span>
      entry.afterLoc <span class="token operator">=</span> locs<span class="token punctuation">[</span>3<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    this.tryEntries.push<span class="token punctuation">(</span>entry<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">function</span> resetTryEntry<span class="token punctuation">(</span>entry<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    var record <span class="token operator">=</span> entry.completion <span class="token operator">||</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    record.type <span class="token operator">=</span> <span class="token string">"normal"</span><span class="token punctuation">;</span>
    delete record.arg<span class="token punctuation">;</span>
    entry.completion <span class="token operator">=</span> record<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">function</span> Context<span class="token punctuation">(</span>tryLocsList<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    // The root entry object <span class="token punctuation">(</span>effectively a try statement without a catch
    // or a finally block<span class="token punctuation">)</span> gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">{<!-- --></span> tryLoc: <span class="token string">"root"</span> <span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    tryLocsList.forEach<span class="token punctuation">(</span>pushTryEntry, this<span class="token punctuation">)</span><span class="token punctuation">;</span>
    this.reset<span class="token punctuation">(</span>true<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  exports.keys <span class="token operator">=</span> function<span class="token punctuation">(</span>object<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    var keys <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>var key <span class="token keyword">in</span> object<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      keys.push<span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    keys.reverse<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    // Rather than returning an object with a next method, we keep
    // things simple and <span class="token keyword">return</span> the next <span class="token keyword">function</span> itself.
    <span class="token keyword">return</span> <span class="token keyword">function</span> next<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      <span class="token keyword">while</span> <span class="token punctuation">(</span>keys.length<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        var key <span class="token operator">=</span> keys.pop<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token keyword">in</span> object<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
          next.value <span class="token operator">=</span> key<span class="token punctuation">;</span>
          next.done <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
          <span class="token keyword">return</span> next<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next <span class="token keyword">function</span> object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
      <span class="token keyword">return</span> next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>

  <span class="token keyword">function</span> values<span class="token punctuation">(</span>iterable<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>iterable<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      var iteratorMethod <span class="token operator">=</span> iterable<span class="token punctuation">[</span>iteratorSymbol<span class="token punctuation">]</span><span class="token punctuation">;</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>iteratorMethod<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> iteratorMethod.call<span class="token punctuation">(</span>iterable<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>

      <span class="token keyword">if</span> <span class="token punctuation">(</span>typeof iterable.next <span class="token operator">==</span><span class="token operator">=</span> <span class="token string">"function"</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> iterable<span class="token punctuation">;</span>
      <span class="token punctuation">}</span>

      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>isNaN<span class="token punctuation">(</span>iterable.length<span class="token punctuation">))</span> <span class="token punctuation">{<!-- --></span>
        var i <span class="token operator">=</span> -1, next <span class="token operator">=</span> <span class="token keyword">function</span> next<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
          <span class="token keyword">while</span> <span class="token punctuation">(</span>++i <span class="token operator">&lt;</span> iterable.length<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>hasOwn.call<span class="token punctuation">(</span>iterable, i<span class="token punctuation">))</span> <span class="token punctuation">{<!-- --></span>
              next.value <span class="token operator">=</span> iterable<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
              next.done <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
              <span class="token keyword">return</span> next<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
          <span class="token punctuation">}</span>

          next.value <span class="token operator">=</span> undefined<span class="token punctuation">;</span>
          next.done <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>

          <span class="token keyword">return</span> next<span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>

        <span class="token keyword">return</span> next.next <span class="token operator">=</span> next<span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    // Return an iterator with no values.
    <span class="token keyword">return</span> <span class="token punctuation">{<!-- --></span> next: doneResult <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  exports.values <span class="token operator">=</span> values<span class="token punctuation">;</span>

  <span class="token keyword">function</span> doneResult<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> <span class="token punctuation">{<!-- --></span> value: undefined, done: <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  Context.prototype <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>
    constructor: Context,

    reset: function<span class="token punctuation">(</span>skipTempReset<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      this.prev <span class="token operator">=</span> 0<span class="token punctuation">;</span>
      this.next <span class="token operator">=</span> 0<span class="token punctuation">;</span>
      // Resetting context._sent <span class="token keyword">for</span> legacy support of Babel<span class="token string">'s
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &amp;&amp;
              hasOwn.call(this, name) &amp;&amp;
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i &gt;= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc &lt;= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch &amp;&amp; hasFinally) {
            if (this.prev &lt; entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev &lt; entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev &lt; entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev &lt; entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i &gt;= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc &lt;= this.prev &amp;&amp;
            hasOwn.call(entry, "finallyLoc") &amp;&amp;
            this.prev &lt; entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &amp;&amp;
          (type === "break" ||
           type === "continue") &amp;&amp;
          finallyEntry.tryLoc &lt;= arg &amp;&amp;
          arg &lt;= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" &amp;&amp; afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i &gt;= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i &gt;= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don'</span>t
        // accidentally pass it on to the delegate.
        this.arg <span class="token operator">=</span> undefined<span class="token punctuation">;</span>
      <span class="token punctuation">}</span>

      <span class="token keyword">return</span> ContinueSentinel<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>

  // Regardless of whether this script is executing as a CommonJS module
  // or not, <span class="token keyword">return</span> the runtime object so that we can <span class="token keyword">declare</span> the variable
  // regeneratorRuntime <span class="token keyword">in</span> the outer scope, <span class="token function">which</span> allows this module to be
  // injected easily by <span class="token variable"><span class="token variable">`</span>bin/regenerator --include-runtime script.js<span class="token variable">`</span></span><span class="token keyword">.</span>
  <span class="token keyword">return</span> exports<span class="token punctuation">;</span>

<span class="token punctuation">}</span><span class="token punctuation">(</span>
  // If this script is executing as a CommonJS module, use module.exports
  // as the regeneratorRuntime namespace. Otherwise create a new empty
  // object. Either way, the resulting object will be used to initialize
  // the regeneratorRuntime variable at the <span class="token function">top</span> of this file.
  typeof module <span class="token operator">==</span><span class="token operator">=</span> <span class="token string">"object"</span> ? module.exports <span class="token keyword">:</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
<span class="token punctuation">))</span><span class="token punctuation">;</span>
</code></pre> 
<p>到此就结束了，有啥不明白的或者说我有啥写错误的地方，欢迎各位前辈随时滴滴我 !!!</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0483666aee491e509d53e47bda4d5989/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">CentOS7系统中安装JDK8</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b538d518456d92b02576deb63e3f08c6/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">注册事件的兼容性处理</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>