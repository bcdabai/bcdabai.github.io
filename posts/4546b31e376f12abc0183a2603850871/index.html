<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java基础(七)：面向对象编程-类和对象 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Java基础(七)：面向对象编程-类和对象" />
<meta property="og:description" content="Java基础系列文章
Java基础(一)：语言概述
Java基础(二)：原码、反码、补码及进制之间的运算
Java基础(三)：数据类型与进制
Java基础(四)：逻辑运算符和位运算符
Java基础(五)：流程控制语句
Java基础(六)：数组
Java基础(七)：面向对象编程
Java基础(八)：封装、继承、多态性
Java基础(九)：Object 类的使用
Java基础(十)：关键字static、代码块、关键字final
Java基础(十一)：抽象类、接口、内部类
Java基础(十二)：枚举类
Java基础(十三)：注解(Annotation)
Java基础(十四)：包装类
Java基础(十五)：异常处理
Java基础(十六)：String的常用API
Java基础(十七)：日期时间API
Java基础(十八)：java比较器、系统相关类、数学相关类
Java基础(十九)：集合框架
Java基础(二十)：泛型
Java基础(二十一)：集合源码
Java基础(二十二)：File类与IO流
Java基础(二十三)：反射机制
目录 一、面向对象编程概述二、类和对象1、类和对象概述2、成员变量(field)3、成员变量 vs 局部变量 三、方法(method)1、方法的概述2、方法调用内存分析3、方法的重载（overload）4、方法的参数传递机制 四、构造器(Constructor) 一、面向对象编程概述 早期先有面向过程思想，随着软件规模的扩大，问题复杂性的提高面向过程的弊端越来越明显，出现了面向对象思想并成为目前主流的方式 面向过程的程序设计思想（Process-Oriented Programming），简称POP
关注的焦点是过程：过程就是操作数据的步骤 如果某个过程的实现代码重复出现，那么就可以把这个过程抽取为一个函数这样就可以大大简化冗余代码，便于维护 典型的语言：C语言代码结构：以函数为组织单位是一种“执行者思维”，适合解决简单问题。扩展能力差、后期维护难度较大 面向对象的程序设计思想（ Object Oriented Programming），简称OOP
关注的焦点是类：在计算机程序设计过程中，参照现实中事物 将事物的属性特征、行为特征抽象出来，用类来表示 典型的语言：Java、C#、C&#43;&#43;、Python、Ruby和PHP等代码结构：以类为组织单位。每种事物都具备自己的属性和行为/功能是一种“设计者思维”，适合解决复杂问题。代码扩展性强、可维护性高 类比举例：人把大象装进冰箱
面向过程 1.打开冰箱 2.把大象装进冰箱 3.把冰箱门关住 面向对象：把这些步骤和功能进行封装，封装时根据不同的功能，进行不同的封装 人{ 打开（冰箱）{ 冰箱.开门();	} 操作(大象){ 大象.进入(冰箱); } 关闭(冰箱){ 冰箱.关门(); } } 冰箱{ 开门(){ } 关门(){ } } 大象{ 进入(冰箱){ } } 二、类和对象 1、类和对象概述 类(Class)和对象(Object)是面向对象的核心概念类：具有相同特征的事物的抽象描述，是抽象的、概念上的定义对象：实际存在的该类事物的每个个体，是具体的，因而也称为实例(instance) 可以理解为：类 =&gt; 抽象概念的人；对象 =&gt; 实实在在的某个人" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/4546b31e376f12abc0183a2603850871/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-05-22T22:18:06+08:00" />
<meta property="article:modified_time" content="2023-05-22T22:18:06+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java基础(七)：面向对象编程-类和对象</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-dracula">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><font size="5"><strong>Java基础系列文章</strong></font></p> 
<p><a href="https://blog.csdn.net/qq_35512802/article/details/128688166">Java基础(一)：语言概述</a></p> 
<p><a href="https://blog.csdn.net/qq_35512802/article/details/128521804">Java基础(二)：原码、反码、补码及进制之间的运算</a></p> 
<p><a href="https://blog.csdn.net/qq_35512802/article/details/128538954">Java基础(三)：数据类型与进制</a></p> 
<p><a href="https://blog.csdn.net/qq_35512802/article/details/129571287">Java基础(四)：逻辑运算符和位运算符</a></p> 
<p><a href="https://blog.csdn.net/qq_35512802/article/details/129589740">Java基础(五)：流程控制语句</a></p> 
<p><a href="https://blog.csdn.net/qq_35512802/article/details/129592661">Java基础(六)：数组</a></p> 
<p><a href="https://blog.csdn.net/qq_35512802/article/details/129718554">Java基础(七)：面向对象编程</a></p> 
<p><a href="https://blog.csdn.net/qq_35512802/article/details/129739659">Java基础(八)：封装、继承、多态性</a></p> 
<p><a href="https://blog.csdn.net/qq_35512802/article/details/129803346">Java基础(九)：Object 类的使用</a></p> 
<p><a href="https://blog.csdn.net/qq_35512802/article/details/129825811">Java基础(十)：关键字static、代码块、关键字final</a></p> 
<p><a href="https://blog.csdn.net/qq_35512802/article/details/129904302">Java基础(十一)：抽象类、接口、内部类</a></p> 
<p><a href="https://blog.csdn.net/qq_35512802/article/details/129962669">Java基础(十二)：枚举类</a></p> 
<p><a href="https://blog.csdn.net/qq_35512802/article/details/130019408">Java基础(十三)：注解(Annotation)</a></p> 
<p><a href="https://blog.csdn.net/qq_35512802/article/details/130019796">Java基础(十四)：包装类</a></p> 
<p><a href="https://blog.csdn.net/qq_35512802/article/details/130068743">Java基础(十五)：异常处理</a></p> 
<p><a href="https://blog.csdn.net/qq_35512802/article/details/130087083">Java基础(十六)：String的常用API</a></p> 
<p><a href="https://blog.csdn.net/qq_35512802/article/details/130195171">Java基础(十七)：日期时间API</a></p> 
<p><a href="https://blog.csdn.net/qq_35512802/article/details/130217979">Java基础(十八)：java比较器、系统相关类、数学相关类</a></p> 
<p><a href="https://blog.csdn.net/qq_35512802/article/details/130275421">Java基础(十九)：集合框架</a></p> 
<p><a href="https://blog.csdn.net/qq_35512802/article/details/130393711">Java基础(二十)：泛型</a></p> 
<p><a href="https://blog.csdn.net/qq_35512802/article/details/130506607">Java基础(二十一)：集合源码</a></p> 
<p><a href="https://blog.csdn.net/qq_35512802/article/details/130554372">Java基础(二十二)：File类与IO流</a></p> 
<p><a href="https://blog.csdn.net/qq_35512802/article/details/130642528">Java基础(二十三)：反射机制</a></p> 
<hr> 
<p></p> 
<div class="toc"> 
 <h4>目录</h4> 
 <ul><li><a href="#_56" rel="nofollow">一、面向对象编程概述</a></li><li><a href="#_117" rel="nofollow">二、类和对象</a></li><li><ul><li><a href="#1_121" rel="nofollow">1、类和对象概述</a></li><li><a href="#2field_131" rel="nofollow">2、成员变量(field)</a></li><li><a href="#3_vs__156" rel="nofollow">3、成员变量 vs 局部变量</a></li></ul> 
  </li><li><a href="#method_202" rel="nofollow">三、方法(method)</a></li><li><ul><li><a href="#1_204" rel="nofollow">1、方法的概述</a></li><li><a href="#2_218" rel="nofollow">2、方法调用内存分析</a></li><li><a href="#3overload_230" rel="nofollow">3、方法的重载（overload）</a></li><li><a href="#4_255" rel="nofollow">4、方法的参数传递机制</a></li></ul> 
  </li><li><a href="#Constructor_269" rel="nofollow">四、构造器(Constructor)</a></li></ul> 
</div> 
<p></p> 
<hr> 
<h2><a id="_56"></a>一、面向对象编程概述</h2> 
<ul><li>早期先有面向过程思想，随着软件规模的扩大，问题复杂性的提高</li><li>面向过程的<code>弊端</code>越来越明显，出现了面向对象思想并成为目前主流的方式</li></ul> 
<blockquote> 
 <p><strong><font size="3">面向过程的程序设计思想（Process-Oriented Programming），简称<code>POP</code></font></strong></p> 
</blockquote> 
<ul><li>关注的焦点是<code>过程</code>：过程就是操作数据的步骤 
  <ul><li>如果某个过程的实现代码重复出现，那么就可以把这个过程抽取为一个<code>函数</code></li><li>这样就可以大大简化冗余代码，便于维护</li></ul> </li><li><font color="##DC143C"><strong>典型的语言：C语言</strong></font></li><li><strong>代码结构：以<code>函数</code>为组织单位</strong></li><li>是一种“<code>执行者思维</code>”，适合解决简单问题。扩展能力差、后期维护难度较大</li></ul> 
<blockquote> 
 <p><strong><font size="3">面向对象的程序设计思想（ Object Oriented Programming），简称<code>OOP</code></font></strong></p> 
</blockquote> 
<ul><li>关注的焦点是<code>类</code>：在计算机程序设计过程中，参照现实中事物 
  <ul><li>将事物的属性特征、行为特征抽象出来，用类来表示</li></ul> </li><li><font color="##DC143C"><strong>典型的语言：Java、C#、C++、Python、Ruby和PHP等</strong></font></li><li><strong>代码结构：以<code>类</code>为组织单位。每种事物都具备自己的<code>属性</code>和<code>行为/功能</code></strong></li><li>是一种“<code>设计者思维</code>”，适合解决复杂问题。代码扩展性强、可维护性高</li></ul> 
<blockquote> 
 <p><strong><font size="3">类比举例：人把大象装进冰箱</font></strong></p> 
</blockquote> 
<ul><li><strong>面向过程</strong></li></ul> 
<pre><code>1.打开冰箱

2.把大象装进冰箱

3.把冰箱门关住
</code></pre> 
<ul><li><strong>面向对象</strong>：把这些步骤和功能进行封装，封装时根据不同的功能，进行不同的封装</li></ul> 
<pre><code>人{
    打开（冰箱）{
		冰箱.开门();	
    }
    操作(大象){
             大象.进入(冰箱);
    }
    关闭(冰箱){   
          冰箱.关门();     
    }
}

冰箱{
     开门(){ }  
     关门(){ }
}

大象{
     进入(冰箱){  }
}
</code></pre> 
<h2><a id="_117"></a>二、类和对象</h2> 
<h3><a id="1_121"></a>1、类和对象概述</h3> 
<ul><li><code>类(Class)</code>和<code>对象(Object)</code>是面向对象的核心概念</li><li><strong>类</strong>：<strong>具有相同特征的事物的抽象描述，是<code>抽象的</code>、概念上的定义</strong></li><li><strong>对象</strong>：<strong>实际存在的该类事物的<code>每个个体</code>，是<code>具体的</code>，因而也称为<code>实例(instance)</code></strong></li></ul> 
<p><img src="https://images2.imgbox.com/d5/6f/kNRaNcXC_o.png" alt="在这里插入图片描述"><br> 可以理解为：<code>类 =&gt; 抽象概念的人</code>；<code>对象 =&gt; 实实在在的某个人</code></p> 
<h3><a id="2field_131"></a>2、成员变量(field)</h3> 
<ul><li>语法格式：</li></ul> 
<pre><code>[修饰符1] class 类名{
    [修饰符2] 数据类型 成员变量名 [= 初始化值]; 
}
</code></pre> 
<ul><li>数据类型 
  <ul><li>任何基本数据类型(如int、Boolean) 或 任何引用数据类型</li></ul> </li><li>成员变量名 
  <ul><li>属于标识符，符合命名规则和规范即可</li></ul> </li><li>初始化值 
  <ul><li>根据情况，可以显式赋值；也可以不赋值，使用默认值</li></ul> </li><li>示例：</li></ul> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span><span class="token punctuation">{<!-- --></span>
	<span class="token keyword">private</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span>             <span class="token comment">//声明private变量 age</span>
	<span class="token keyword">public</span> <span class="token class-name">String</span> name <span class="token operator">=</span> “<span class="token class-name">Lila</span>”<span class="token punctuation">;</span>    <span class="token comment">//声明public变量 name</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="3_vs__156"></a>3、成员变量 vs 局部变量</h3> 
<blockquote> 
 <p><strong><font size="3">变量的分类：成员变量与局部变量</font></strong></p> 
</blockquote> 
<ul><li>在方法体外，类体内声明的变量称为<strong>成员变量</strong></li><li>在方法体内部等位置声明的变量称为<strong>局部变量</strong></li></ul> 
<p><img src="https://images2.imgbox.com/dd/b3/8pL0e0E0_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p><strong><font size="3">成员变量 与 局部变量 的对比</font></strong></p> 
</blockquote> 
<p><strong>相同点</strong></p> 
<ul><li>变量声明的格式相同： 数据类型 变量名 = 初始化值</li><li>变量必须先声明、后初始化、再使用</li><li>变量都有其对应的作用域。只在其作用域内是有效的</li></ul> 
<p><strong>不同点</strong></p> 
<ul><li><font color="##DC143C"><strong>声明位置和方式</strong> </font> 
  <ul><li>实例变量：在类中方法外</li><li>局部变量：在方法体{}中或方法的形参列表、代码块中</li></ul> </li><li><font color="##DC143C"><strong>在内存中存储的位置不同</strong> </font> 
  <ul><li>实例变量：<code>堆</code></li><li>局部变量：<code>栈</code></li></ul> </li><li><font color="##DC143C"><strong>生命周期</strong> </font> 
  <ul><li>实例变量：和对象的生命周期一样，随着对象的创建而存在，<code>随着对象被GC回收而消亡</code>，而且每一个对象的实例变量是独立的</li><li>局部变量：和方法调用的生命周期一样，每一次方法被调用而在存在，<code>随着方法执行的结束而消亡</code>，而且每一次方法调用都是独立</li></ul> </li><li><font color="##DC143C"><strong>作用域</strong> </font> 
  <ul><li>实例变量：通过对象就可以使用，本类中直接调用，其他类中“对象.实例变量”</li><li>局部变量：出了作用域就不能使用</li></ul> </li><li><font color="##DC143C"><strong>修饰符</strong> </font> 
  <ul><li>实例变量：public,protected,private,final,volatile,transient等</li><li>局部变量：<code>final</code></li></ul> </li><li><font color="##DC143C"><strong>默认值</strong> </font> 
  <ul><li>实例变量：<code>有默认值</code></li><li>局部变量：<code>没有</code>，必须手动初始化。其中的形参比较特殊，靠实参给它初始化</li></ul> </li></ul> 
<blockquote> 
 <p><strong><font size="3">对象属性的默认初始化赋值</font></strong></p> 
</blockquote> 
<p>当一个对象被创建时，会对其中各种类型的<strong>成员变量</strong>自动进行初始化赋值</p> 
<p><img src="https://images2.imgbox.com/8b/54/5txwlbuV_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="method_202"></a>三、方法(method)</h2> 
<h3><a id="1_204"></a>1、方法的概述</h3> 
<ul><li><code>方法</code>是类或对象行为特征的抽象，用来完成某个功能操作。在某些语言中也称为<code>函数</code>或<code>过程</code></li><li>将功能封装为方法的目的是，可以<code>实现代码重用，减少冗余，简化代码</code></li><li>声明方法的语法格式</li></ul> 
<pre><code>[修饰符] 返回值类型 方法名([形参列表])[throws 异常列表]{
        方法体的功能代码
}
</code></pre> 
<ul><li>方法通过方法名被调用，且只有被调用才会执行</li><li><strong>方法中可以调用类中的方法或属性，不可以在方法内部定义方法</strong></li></ul> 
<h3><a id="2_218"></a>2、方法调用内存分析</h3> 
<ul><li><strong>方法<code>没有被调用</code>的时候，都在<code>方法区</code>中的字节码文件(.class)中存储</strong></li><li><strong>方法<code>被调用</code>的时候，需要进入到<code>栈内存</code>中运行</strong> 
  <ul><li>方法每调用一次就会在栈中有一个<code>入栈</code>动作</li><li>即给当前方法开辟一块独立的内存区域</li><li>用于存储当前方法的局部变量的值</li></ul> </li><li><strong>当方法执行结束后，会释放该内存，称为<code>出栈</code></strong> 
  <ul><li>如果方法有返回值，就会把结果返回调用处</li><li>如果没有返回值，就直接结束，回到调用处继续执行下一条指令</li></ul> </li><li><strong>栈结构：先进后出，后进先出</strong></li></ul> 
<h3><a id="3overload_230"></a>3、方法的重载（overload）</h3> 
<ul><li><strong>方法重载</strong> 
  <ul><li><font color="##DC143C"><strong>在同一个类中，允许存在一个以上的同名方法，只要它们的参数列表不同即可</strong></font></li><li><strong>参数列表不同，意味着参数<code>个数</code>、<code>类型</code>或<code>顺序</code>的不同</strong></li></ul> </li><li><strong>重载的特点</strong> 
  <ul><li><mark><strong>与修饰符、返回值类型无关，只看参数列表，且参数列表必须不同</strong></mark></li></ul> </li><li>判 断与<code>void show(int a,char b,double c){}</code>构成重载的有：</li></ul> 
<pre><code class="prism language-java">a<span class="token punctuation">)</span><span class="token keyword">void</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span><span class="token keyword">char</span> y<span class="token punctuation">,</span><span class="token keyword">double</span> z<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>     <span class="token comment">// no</span>

b<span class="token punctuation">)</span><span class="token keyword">int</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span><span class="token keyword">double</span> c<span class="token punctuation">,</span><span class="token keyword">char</span> b<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>      <span class="token comment">// yes</span>

c<span class="token punctuation">)</span> <span class="token keyword">void</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span><span class="token keyword">double</span> c<span class="token punctuation">,</span><span class="token keyword">char</span> b<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>    <span class="token comment">// yes</span>

d<span class="token punctuation">)</span> <span class="token keyword">boolean</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token keyword">int</span> c<span class="token punctuation">,</span><span class="token keyword">char</span> b<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>          <span class="token comment">// yes</span>

e<span class="token punctuation">)</span> <span class="token keyword">void</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token keyword">double</span> c<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>                 <span class="token comment">// yes</span>

f<span class="token punctuation">)</span> <span class="token keyword">double</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span><span class="token keyword">char</span> y<span class="token punctuation">,</span><span class="token keyword">double</span> z<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>  <span class="token comment">// no</span>

g<span class="token punctuation">)</span> <span class="token keyword">void</span> <span class="token function">shows</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span><span class="token keyword">double</span> c<span class="token punctuation">}</span>                <span class="token comment">// no</span>
</code></pre> 
<h3><a id="4_255"></a>4、方法的参数传递机制</h3> 
<blockquote> 
 <p><strong><font size="3">形参和实参</font></strong></p> 
</blockquote> 
<ul><li><strong><font color="##DC143C">形参</font>（formal parameter）：在定义方法时，方法名后面括号()中<code>声明的变量</code>称为形式参数，简称形参</strong></li><li><strong><font color="##DC143C">实参</font>（actual parameter）：在调用方法时，方法名后面括号()中的<code>使用的值/变量/表达式</code>称为实际参数，简称实参</strong></li></ul> 
<blockquote> 
 <p><strong><font size="3">参数传递机制：值传递</font></strong></p> 
</blockquote> 
<ul><li><strong>Java里方法的参数传递方式只有一种：<code>值传递</code>。即将实际参数值的副本（复制品）传入方法内，而参数本身不受影响。</strong> 
  <ul><li><strong><font color="##DC143C">形参是基本数据类型</font>：将实参基本数据类型变量的<code>“数据值”</code>传递给形参</strong></li><li><strong><font color="##DC143C">形参是引用数据类型</font>：将实参引用数据类型变量的<code>“地址值”</code>传递给形参</strong></li></ul> </li></ul> 
<h2><a id="Constructor_269"></a>四、构造器(Constructor)</h2> 
<ul><li>我们new完对象时，所有成员变量都是默认值，如果我们需要赋别的值，需要挨个为它们再赋值，太麻烦了</li><li>我们能不能在new对象时，<font color="##DC143C"><strong>直接为当前对象的某个或所有成员变量直接赋值呢？</strong></font></li><li><strong>可以，Java给我们提供了<code>构造器（Constructor)</code>，也称为<code>构造方法</code></strong></li></ul> 
<blockquote> 
 <p><strong><font size="3">构造器的作用</font></strong></p> 
</blockquote> 
<ul><li><strong>new对象，并在new对象的时候<code>为实例变量赋值</code></strong></li><li><strong>举例：Person p = new Person(“Peter”,15);</strong></li></ul> 
<blockquote> 
 <p><strong><font size="3">构造器的语法格式</font></strong></p> 
</blockquote> 
<pre><code>[修饰符] class 类名{
    [修饰符] 构造器名(){
    	// 实例初始化代码
    }
    [修饰符] 构造器名(参数列表){
        // 实例初始化代码
    }
}
</code></pre> 
<ol><li><strong>构造器名必须与它所在的类名必须相同</strong></li><li><strong>它没有返回值，所以不需要返回值类型，也不需要void</strong></li><li><strong>构造器的修饰符只能是权限修饰符</strong> 
  <ul><li>不能被其他任何修饰</li><li>比如，不能被static、final、synchronized、abstract、native修饰</li><li>不能有return语句返回值</li></ul> </li></ol> 
<blockquote> 
 <p><strong><font size="3">使用说明</font></strong></p> 
</blockquote> 
<ul><li><strong>当我们没有显式的声明类中的构造器时，系统会默认提供一个无参的构造器并且该构造器的修饰符默认与类的修饰符相同</strong></li><li><strong>当我们显式的定义类的构造器以后，系统就不再提供默认的无参的构造器了</strong></li><li>在类中，至少会存在一个构造器</li><li>构造器是可以重载的</li></ul> 
<p><img src="https://images2.imgbox.com/f9/5d/Lxphj2bc_o.png" alt="在这里插入图片描述"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/89a2351113ec014208b46e140275b4b2/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Linux存储系统、文件系统</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4fcef9f72f2996dfb5076ee07bea6bb1/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【新星计划·2023】网络技术——VTP技术/协议讲解</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>