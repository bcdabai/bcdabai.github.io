<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>HTTP协议常问的面试题 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="HTTP协议常问的面试题" />
<meta property="og:description" content="1.http协议请求方式
HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法 HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 下面是它们的作用（背的时候可以挑常见的请求去背诵） GET: 通常用于请求服务器发送某些资源 POST: 发送数据给服务器 PUT: 用于新增资源或者使用请求中的有效负载替换目标资源的表现形式 PATCH: 用于对资源进行部分修改 DELETE: 用于删除指定的资源 HEAD: 请求资源的头部信息, 并且这些头部与 HTTP GET 方法请求时返回的一致. 该请求方法的一个使用场景是在下载一个大文件前先获取其大小再决定是否要下载, 以此可以节约带宽资源 OPTIONS: 用于获取目的资源所支持的通信选项 CONNECT: HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器 TRACE: 回显服务器收到的请求，主要用于测试或诊断 2.GET和POST有什么区别？
数据传输方式不同：GET请求通过URL传输数据，而POST的数据通过请求体传输。 安全性不同：POST的数据因为在请求主体内，所以有一定的安全性保证，而GET的数据在URL中，通过历史记录，缓存很容易查到数据信息。 数据类型不同：GET只允许 ASCII 字符，而POST无限制 GET无害： 刷新、后退等浏览器操作GET请求是无害的，POST可能重复提交表单 特性不同：GET是安全（这里的安全是指只读特性，就是使用这个方法不会引起服务器状态变化）且幂等（幂等的概念是指同一个请求方法执行多次和仅执行一次的效果完全相同），而POST是非安全非幂等 3.什么是无状态协议，HTTP 是无状态协议吗，怎么解决
无状态协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息。状态协议解决办法：通过1、Cookie 2、通过Session会话保存。
无状态协议(Stateless Protocol) 就是指浏览器对于事务的处理没有记忆能力。举个例子来说就是比如客户请求获得网页之后关闭浏览器，然后再次启动浏览器，登录该网站，但是服务器并不知道客户关闭了一次浏览器。 HTTP 就是一种无状态的协议，他对用户的操作没有记忆能力。可能大多数用户不相信，他可能觉得每次输入用户名和密码登陆一个网站后，下次登陆就不再重新输入用户名和密码了。这其实不是 HTTP 做的事情，起作用的是一个叫做 小甜饼(Cookie) 的机制。它能够让浏览器具有记忆能力。 4. UDP 和 TCP 的区别 UDP 是什么？ UDP 的全称是 User Datagram Protocol，用户数据报协议。它不需要所谓的握手操作，从而加快了通信速度，允许网络上的其他主机在接收方同意通信之前进行数据传输。 数据报是与分组交换网络关联的传输单元。 UDP 的特点主要有： UDP 能够支持容忍数据包丢失的带宽密集型应用程序 UDP 具有低延迟的特点 UDP 能够发送大量的数据包 UDP 能够允许 DNS 查找，DNS 是建立在 UDP 之上的应用层协议。 TCP 是什么？ TCP 的全称是Transmission Control Protocol ，传输控制协议。它能够帮助你确定计算机连接到 Internet 以及它们之间的数据传输。通过三次握手来建立 TCP 连接，三次握手就是用来启动和确认 TCP 连接的过程。一旦连接建立后，就可以发送数据了，当数据传输完成后，会通过关闭虚拟电路来断开连接。 TCP 的主要特点有： TCP 能够确保连接的建立和数据包的发送 TCP 支持错误重传机制 TCP 支持拥塞控制，能够在网络拥堵的情况下延迟发送 TCP 能够提供错误校验和，甄别有害的数据包。 TCP 和 UDP 的区别（重点来了） TCP 是面向连接的协议 。 UDP 是无连接的协议 TCP 在发送数据前先需要建立连接，然后再发送数据 。 UDP 无需建立连接就可以直接发送大量数据 TCP 会按照特定顺序重新排列数据包 。 UDP 数据包没有固定顺序，所有数据包都相互独立 TCP 传输的速度比较慢 。 UDP 的传输会更快 TCP 的头部字节有 20 字节 。 UDP 的头部字节只需要 8 个字节 TCP 是重量级的，在发送任何用户数据之前，TCP需要三次握手建立连接。 UDP 是轻量级的。没有跟踪连接，消息排序等。 TCP 会进行错误校验，并能够进行错误恢复 。 UDP 也会错误检查，但会丢弃错误的数据包。 TCP 有发送确认。 UDP 没有发送确认 TCP 会使用握手协议，例如 SYN，SYN-ACK，ACK。 UDP无握手协议 TCP 是可靠的，因为它可以确保将数据传送到路由器。 UDP 中不能保证将数据传送到目标。 5、说一下Http协议中302状态？ http协议中，返回状态码302表示重定向。这种情况下，服务器返回的头部信息中会包含一个Location字段，内容是重定向到的url。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/fcd7dd5eab4cdf3a390aecd5776bc44e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-02-21T16:22:11+08:00" />
<meta property="article:modified_time" content="2023-02-21T16:22:11+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">HTTP协议常问的面试题</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>1.http协议请求方式</p> 
<pre><code>HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法
HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT

下面是它们的作用（背的时候可以挑常见的请求去背诵）

GET: 通常用于请求服务器发送某些资源
POST: 发送数据给服务器
PUT: 用于新增资源或者使用请求中的有效负载替换目标资源的表现形式
PATCH: 用于对资源进行部分修改
DELETE: 用于删除指定的资源
HEAD: 请求资源的头部信息, 并且这些头部与 HTTP GET 方法请求时返回的一致. 该请求方法的一个使用场景是在下载一个大文件前先获取其大小再决定是否要下载, 以此可以节约带宽资源
OPTIONS: 用于获取目的资源所支持的通信选项
CONNECT: HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器
TRACE: 回显服务器收到的请求，主要用于测试或诊断
</code></pre> 
<p>2.GET和POST有什么区别？</p> 
<pre><code>数据传输方式不同：GET请求通过URL传输数据，而POST的数据通过请求体传输。

安全性不同：POST的数据因为在请求主体内，所以有一定的安全性保证，而GET的数据在URL中，通过历史记录，缓存很容易查到数据信息。

数据类型不同：GET只允许 ASCII 字符，而POST无限制

GET无害： 刷新、后退等浏览器操作GET请求是无害的，POST可能重复提交表单

特性不同：GET是安全（这里的安全是指只读特性，就是使用这个方法不会引起服务器状态变化）且幂等（幂等的概念是指同一个请求方法执行多次和仅执行一次的效果完全相同），而POST是非安全非幂等
</code></pre> 
<p>3.什么是无状态协议，HTTP 是无状态协议吗，怎么解决</p> 
<blockquote> 
 <p>无状态协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息。状态协议解决办法：通过1、Cookie 2、通过Session会话保存。</p> 
</blockquote> 
<pre><code>无状态协议(Stateless Protocol) 就是指浏览器对于事务的处理没有记忆能力。举个例子来说就是比如客户请求获得网页之后关闭浏览器，然后再次启动浏览器，登录该网站，但是服务器并不知道客户关闭了一次浏览器。
HTTP 就是一种无状态的协议，他对用户的操作没有记忆能力。可能大多数用户不相信，他可能觉得每次输入用户名和密码登陆一个网站后，下次登陆就不再重新输入用户名和密码了。这其实不是 HTTP 做的事情，起作用的是一个叫做 小甜饼(Cookie) 的机制。它能够让浏览器具有记忆能力。
</code></pre> 
<h4>4. UDP 和 TCP 的区别</h4> 
<pre><code>UDP 是什么？

UDP 的全称是 User Datagram Protocol，用户数据报协议。它不需要所谓的握手操作，从而加快了通信速度，允许网络上的其他主机在接收方同意通信之前进行数据传输。

数据报是与分组交换网络关联的传输单元。

UDP 的特点主要有：
UDP 能够支持容忍数据包丢失的带宽密集型应用程序
UDP 具有低延迟的特点
UDP 能够发送大量的数据包
UDP 能够允许 DNS 查找，DNS 是建立在 UDP 之上的应用层协议。

TCP 是什么？

TCP 的全称是Transmission Control Protocol ，传输控制协议。它能够帮助你确定计算机连接到 Internet 以及它们之间的数据传输。通过三次握手来建立 TCP 连接，三次握手就是用来启动和确认 TCP 连接的过程。一旦连接建立后，就可以发送数据了，当数据传输完成后，会通过关闭虚拟电路来断开连接。


TCP 的主要特点有：
TCP 能够确保连接的建立和数据包的发送
TCP 支持错误重传机制
TCP 支持拥塞控制，能够在网络拥堵的情况下延迟发送
TCP 能够提供错误校验和，甄别有害的数据包。

TCP 和 UDP 的区别（重点来了）

TCP 是面向连接的协议 。 UDP 是无连接的协议
TCP 在发送数据前先需要建立连接，然后再发送数据 。 UDP 无需建立连接就可以直接发送大量数据
TCP 会按照特定顺序重新排列数据包 。 UDP 数据包没有固定顺序，所有数据包都相互独立
TCP 传输的速度比较慢 。 UDP 的传输会更快
TCP 的头部字节有 20 字节 。 UDP 的头部字节只需要 8 个字节
TCP 是重量级的，在发送任何用户数据之前，TCP需要三次握手建立连接。 UDP 是轻量级的。没有跟踪连接，消息排序等。
TCP 会进行错误校验，并能够进行错误恢复 。 UDP 也会错误检查，但会丢弃错误的数据包。
TCP 有发送确认。 UDP 没有发送确认
TCP 会使用握手协议，例如 SYN，SYN-ACK，ACK。 UDP无握手协议
TCP 是可靠的，因为它可以确保将数据传送到路由器。 UDP 中不能保证将数据传送到目标。
</code></pre> 
<h4><br> 5、说一下Http协议中302状态？</h4> 
<blockquote> 
 <h4><br><strong>http协议中，返回状态码302表示重定向。这种情况下，服务器返回的头部信息中会包含一个Location字段，内容是重定向到的url。</strong><br><br>  </h4> 
</blockquote> 
<p>6.Http协议有什么组成？</p> 
<blockquote> 
 <p>请求报文包含三部分：请求行：包含请求方法、URI、HTTP版本信息；请求首部字段；请求内容实体。</p> 
</blockquote> 
<p>7.cookies机制和session机制的区别是什么？</p> 
<blockquote> 
 <p>（1）cookies数据保存在客户端，session数据保存在服务端；</p> 
 <p>（2）cookies可以减轻服务器压力，但是不安全，容易进行cookies欺骗；</p> 
 <p>（3）session安全一点，但是占用服务器资源。</p> 
</blockquote> 
<p>8.HTTP协议有什么特点？</p> 
<blockquote> 
 <p>（1）http无连接：限制每次连接只处理一个请求，服务端完成客户端的请求后，即断开连接。（传输速度快，减少不必要的连接，但也意味着每一次访问都要建立一次连接，效率降低）；</p> 
 <p>（2）http无状态：对于事务处理没有记忆能力。每一次请求都是独立的，不记录客户端任何行为；</p> 
 <p>（3）客户端/服务端模型：客户端支持web浏览器或其他任何客户端；</p> 
 <p>（4）简单快速；</p> 
 <p>（5）灵活：可以传输任何类型的数据。<br>  </p> 
</blockquote> 
<p>9.http和https有什么区别？</p> 
<blockquote> 
 <p>1）https有ca证书，http一般没有；</p> 
 <p>（2）http是超文本传输协议，信息是明文传输。https则是具有安全性的ssl加密传输协议；</p> 
 <p>（3）http默认80端口，https默认443端口。</p> 
</blockquote> 
<p>10. 为什么有了HTTP为什么还要HTTPS？</p> 
<blockquote>
  https是安全版的http，因为http协议的数据都是明文进行传输的，所以对于一些敏感信息的传输就很不安全，HTTPS就是为了解决HTTP的不安全而生的。 
</blockquote> 
<p>11. HTTP的keep-alive是干什么的？</p> 
<blockquote> 
 <p>在早期的HTTP/1.0中，每次http请求都要创建一个连接，而创建连接的过程需要消耗资源和时间，为了减少资源消耗，缩短响应时间，就需要重用连接。在后来的HTTP/1.0中以及HTTP/1.1中，引入了重用连接的机制，就是在http请求头中加入Connection: keep-alive来告诉对方这个请求响应完成后不要关闭，下一次咱们还用这个请求继续交流。协议规定HTTP/1.0如果想要保持长连接，需要在请求头中加上Connection: keep-alive。</p> 
 <p>keep-alive的优点：</p> 
 <ul><li>较少的CPU和内存的使用（由于同时打开的连接的减少了）</li><li>允许请求和应答的HTTP管线化</li><li> 降低拥塞控制 （TCP连接减少了）</li><li>减少了后续请求的延迟（无需再进行握手）</li><li>报告错误无需关闭TCP连</li></ul> 
</blockquote> 
<p>12.http的请求报文是什么样的</p> 
<blockquote> 
 <p>请求报文有4部分组成:</p> 
 <p>请求行</p> 
 <p>请求头部</p> 
 <p>空行</p> 
 <p>请求体</p> 
 <p>请求行包括：请求方法字段、URL字段、HTTP协议版本字段。它们用空格分隔。例如，GET /index.html HTTP/1.1。</p> 
 <p>请求头部:请求头部由关键字/值对组成，每行一对，关键字和值用英文冒号“:”分隔</p> 
 <p>User-Agent：产生请求的浏览器类型。<br> Accept：客户端可识别的内容类型列表。<br> Host：请求的主机名，允许多个域名同处一个IP地址，即虚拟主机。<br> 请求体: post put等请求携带的数据<br>  </p> 
</blockquote> 
<p>13.http的响应报文是什么样的？</p> 
<blockquote> 
 <p>响应报文有4部分组成:</p> 
 <ul><li> <p>响应行</p> </li><li> <p>响应头</p> </li><li> <p>空行</p> </li><li> <p>响应体</p> </li><li> <p>响应行： 由协议版本，状态码和状态码的原因短语组成，例如<code>HTTP/1.1 200 OK</code>。</p> </li><li> <p>响应头：响应部首组成</p> </li><li> <p>响应体：服务器响应的数据</p> </li></ul> 
</blockquote> 
<p>14.聊一聊HTTP的部首有哪些？</p> 
<p>通用首部字段（General Header Fields）：请求报文和响应报文两方都会使用的首部</p> 
<blockquote> 
 <ul><li>Cache-Control 控制缓存 ✨</li><li>Connection 连接管理、逐条首部 ✨</li></ul> 
</blockquote> 
<p>请求首部字段（Reauest Header Fields）:客户端向服务器发送请求的报文时使用的首部</p> 
<blockquote> 
 <ul><li> <p>User-Agent 客户端程序信息 ✨</p> <p>Host 请求资源所在服务器 ✨</p> <p>If-Match 比较实体标记（ETage） ✨</p> <p>If-None-Match 比较实体标记（ETage）与 If-Match相反 ✨</p> <p>If-Modified-Since 比较资源更新时间（Last-Modified）✨</p> <p>If-Unmodified-Since比较资源更新时间（Last-Modified），与 If-Modified-Since相反 ✨</p> </li></ul> 
</blockquote> 
<p>响应首部字段（Response Header Fields）:从服务器向客户端响应时使用的字段</p> 
<blockquote> 
 <ul><li>Server 服务器的信息 ✨</li><li>Location 令客户端重定向的URI </li></ul> 
</blockquote> 
<p>实体首部字段（Entiy Header Fields）:针对请求报文和响应报文的实体部分使用首部</p> 
<blockquote> 
 <ul><li>Last-Modified 资源最后的修改资源 ✨</li><li>Expires 实体主体的过期资源 ✨</li><li>Allow 资源可支持http请求的方法 </li></ul> 
</blockquote> 
<p>15、聊一聊HTTP的状态码有哪些？</p> 
<blockquote> 
 <p>2XX 成功</p> 
 <p>200 OK，表示从客户端发来的请求在服务器端被正确处理 ✨<br> 201 Created 请求已经被实现，而且有一个新的资源已经依据请求的需要而建立<br> 202 Accepted 请求已接受，但是还没执行，不保证完成请求<br> 204 No content，表示请求成功，但响应报文不含实体的主体部分<br> 206 Partial Content，进行范围请求 ✨<br> 3XX 重定向</p> 
 <p>301 moved permanently，永久性重定向，表示资源已被分配了新的 URL<br> 302 found，临时性重定向，表示资源临时被分配了新的 URL ✨<br> 303 see other，表示资源存在着另一个 URL，应使用 GET 方法丁香获取资源<br> 304 not modified，表示服务器允许访问资源，但因发生请求未满足条件的情况<br> 307 temporary redirect，临时重定向，和302含义相同<br> 4XX 客户端错误</p> 
 <p>400 bad request，请求报文存在语法错误 ✨<br> 401 unauthorized，表示发送的请求需要有通过 HTTP 认证的认证信息 ✨<br> 403 forbidden，表示对请求资源的访问被服务器拒绝 ✨<br> 404 not found，表示在服务器上没有找到请求的资源 ✨<br> 408 Request timeout, 客户端请求超时<br> 409 Confict, 请求的资源可能引起冲突<br> 5XX 服务器错误</p> 
 <p>500 internal sever error，表示服务器端在执行请求时发生了错误 ✨<br> 501 Not Implemented 请求超出服务器能力范围，例如服务器不支持当前请求所需要的某个功能，或者请求是服务器不支持的某个方法<br> 503 service unavailable，表明服务器暂时处于超负载或正在停机维护，无法处理请求<br> 505 http version not supported 服务器不支持，或者拒绝支持在请求中使用的 HTTP 版本</p> 
</blockquote> 
<p>16、TCP 三次握手和四次挥手</p> 
<blockquote> 
 <p>TCP 三次握手和四次挥手也是面试题的热门考点，它们分别对应 TCP 的连接和释放过程。下面就来简单认识一下这两个过程</p> 
</blockquote> 
<p>TCP 三次握手</p> 
<pre><code>在了解具体的流程前，我们需要先认识几个概念


消息类型 描述

SYN 这个消息是用来初始化和建立连接的。
ACK 帮助对方确认收到的 SYN 消息
SYN-ACK 本地的 SYN 消息和较早的 ACK 数据包
FIN 用来断开连接


SYN：它的全称是 Synchronize Sequence Numbers，同步序列编号。是 TCP/IP 建立连接时使用的握手信号。在客户机和服务器之间建立 TCP 连接时，首先会发送的一个信号。客户端在接受到 SYN 消息时，就会在自己的段内生成一个随机值 X。
SYN-ACK：服务器收到 SYN 后，打开客户端连接，发送一个 SYN-ACK 作为答复。确认号设置为比接收到的序列号多一个，即 X + 1，服务器为数据包选择的序列号是另一个随机数 Y。
ACK：Acknowledge character, 确认字符，表示发来的数据已确认接收无误。最后，客户端将 ACK 发送给服务器。序列号被设置为所接收的确认值即 Y + 1。
</code></pre> 
<p>接下来我用一个简单的例子去帮大家通俗易懂的去理解:happy:</p> 
<p>小明👩 - 客户端</p> 
<p>小红👨 - 服务端</p> 
<pre><code>小明给小红打电话，接通了后，小明说喂，能听到吗，这就相当于是连接建立。

小红给小明回应，能听到，你能听到我说的话吗，这就相当于是请求响应。

小明听到小红的回应后，好的，这相当于是连接确认。在这之后小明和小红就可以通话/交换信息了。
</code></pre> 
<p>TCP 四次挥手</p> 
<blockquote> 
 <blockquote> 
  <p>在连接终止阶段使用四次挥手，连接的每一端都会独立的终止。下面我们来描述一下这个过程。</p> 
 </blockquote> 
</blockquote> 
<pre><code>首先，客户端应用程序决定要终止连接(这里服务端也可以选择断开连接)。这会使客户端将 FIN 发送到服务器，并进入 FIN_WAIT_1 状态。当客户端处于 FIN_WAIT_1 状态时，它会等待来自服务器的 ACK 响应。

然后第二步，当服务器收到 FIN 消息时，服务器会立刻向客户端发送 ACK 确认消息。

当客户端收到服务器发送的 ACK 响应后，客户端就进入 FIN_WAIT_2 状态，然后等待来自服务器的 FIN 消息

服务器发送 ACK 确认消息后，一段时间（可以进行关闭后）会发送 FIN 消息给客户端，告知客户端可以进行关闭。

当客户端收到从服务端发送的 FIN 消息时，客户端就会由 FIN_WAIT_2 状态变为 TIME_WAIT 状态。处于 TIME_WAIT 状态的客户端允许重新发送 ACK 到服务器为了防止信息丢失。客户端在 TIME_WAIT 状态下花费的时间取决于它的实现，在等待一段时间后，连接关闭，客户端上所有的资源（包括端口号和缓冲区数据）都被释放。

还是可以用上面那个通话的例子来进行描述

小明对小红说，我所有的东西都说完了，我要挂电话了。
小红说，收到，我这边还有一些东西没说。
经过若干秒后，小红也说完了，小红说，我说完了，现在可以挂断了
小明收到消息后，又等了若干时间后，挂断了电话。
</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c51e98da149b83ee9ab4cd3325cac386/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">ChatGPT的出现网络安全专家是否会被替代?</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/14252be0e4330193e221c3d4eed94743/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">MySQL Workbench基本用法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>