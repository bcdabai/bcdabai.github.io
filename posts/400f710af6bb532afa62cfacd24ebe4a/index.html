<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C#使用webclient下载图片返回403forbiden - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C#使用webclient下载图片返回403forbiden" />
<meta property="og:description" content="在一次爬虫下载图片的过程中，遇到服务器返回403，然后寻找解决办法，解决办法如下：
1.一般造成403的原因是权限设置问题，也就是没有权限造成的，因此这里直接添加信任权限即可：
webclient.Credentials = CredentialCache.DefaultCredentials; // 添加授权证书 2.分析Reques tHeaders
可以看到在requet中，有host，cookie等需要设置的内容，因此加上相应的内容即可：
给webclient添加头信息
WebClient mywebclient = new WebClient(); mywebclient.Credentials = CredentialCache.DefaultCredentials; // 添加授权证书 mywebclient.Headers.Add(&#34;User-Agent&#34;, &#34;Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/74.0.3729.169 Safari/537.36&#34;); mywebclient.Headers.Add(&#34;Host&#34;, &#34;biz.touchev.com&#34;); mywebclient.Headers.Add(&#34;Cookie&#34;, &#34;UM_distinctid=16bb1d9972eab2-0ec4ae521bb726-3e385b04-1fa400-16bb1d9972f9b8; PHPSESSID=upN0hwQw8FlkIm_Y7uegI45AB8qRVRDS7yq-YGrQ5o6mm6Hc_BSqQg7hNLQ6sr8x; Hm_lvt_6dba01603aa724759d9c4ea0dddd9b72=1562056956,1562816935; CNZZDATA1273105019=948668930-1562055616-%7C1562909757; Hm_lpvt_6dba01603aa724759d9c4ea0dddd9b72=1562914189&#34;); mywebclient.DownloadFile(url, desPath); 运行，ok~
题外知识：
有关HTTP头完整、详细的说明，请参见 http://www.w3.org/Protocols/ 的HTTP规范。
1. RequestHeader分析：
Accept：浏览器可接受的MIME类型。 Accept-Charset：浏览器可接受的字符集。　Accept-Encoding：浏览器能够进行解码的数据编码方式，比如gzip。Servlet能够向支持gzip的浏览器返回经gzip编码的HTML页面。许多情形下这可以减少5到10倍的下载时间。
Accept-Language：浏览器所希望的语言种类，当服务器能够提供一种以上的语言版本时要用到。　Authorization：授权信息，通常出现在对服务器发送的WWW-Authenticate头的应答中。　Connection：表示是否需要持久连接。如果Servlet看到这里的值为“Keep-Alive”，或者看到请求使用的是HTTP 1.1（HTTP 1.1默认进行持久连接），它就可以利用持久连接的优点，当页面包含多个元素时（例如Applet，图片），显著地减少下载所需要的时间。要实现这一点，Servlet需要在应答中发送一个Content-Length头，最简单的实现方法是：先把内容写入ByteArrayOutputStream，然后在正式写出内容之前计算它的大小。　Content-Length：表示请求消息正文的长度。　Cookie：这是最重要的请求头信息之一　From：请求发送者的email地址，由一些特殊的Web客户程序使用，浏览器不会用到它。　Host：初始URL中的主机和端口。　If-Modified-Since：只有当所请求的内容在指定的日期之后又经过修改才返回它，否则返回304“Not Modified”应答。　Pragma：指定“no-cache”值表示服务器必须返回一个刷新后的文档，即使它是代理服务器而且已经有了页面的本地拷贝。　Referer：包含一个URL，用户从该URL代表的页面出发访问当前请求的页面。　User-Agent：浏览器类型，如果Servlet返回的内容与浏览器类型有关则该值非常有用。　UA-Pixels，UA-Color，UA-OS，UA-CPU：由某些版本的IE浏览器所发送的非标准的请求头，表示屏幕大小、颜色深度、操作系统和CPU类型。　每个标头独占一行， 最后必须要有一个空行。有关HTTP头完整、详细的说明，请参见http://www." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/400f710af6bb532afa62cfacd24ebe4a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-07-23T09:54:15+08:00" />
<meta property="article:modified_time" content="2019-07-23T09:54:15+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C#使用webclient下载图片返回403forbiden</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>在一次爬虫下载图片的过程中，遇到服务器返回403，然后寻找解决办法，解决办法如下：</p> 
<p>1.一般造成403的原因是权限设置问题，也就是没有权限造成的，因此这里直接添加信任权限即可：</p> 
<pre class="has"><code class="language-cs">webclient.Credentials = CredentialCache.DefaultCredentials; // 添加授权证书</code></pre> 
<p>2.分析Reques tHeaders</p> 
<p><img alt="" class="has" height="566" src="https://images2.imgbox.com/13/1b/cCBD8cL5_o.png" width="758"></p> 
<p>可以看到在requet中，有host，cookie等需要设置的内容，因此加上相应的内容即可：</p> 
<p>给webclient添加头信息</p> 
<pre class="has"><code class="language-cs">WebClient mywebclient = new WebClient();
mywebclient.Credentials = CredentialCache.DefaultCredentials; // 添加授权证书
mywebclient.Headers.Add("User-Agent", "Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/74.0.3729.169 Safari/537.36");
mywebclient.Headers.Add("Host", "biz.touchev.com");
mywebclient.Headers.Add("Cookie", "UM_distinctid=16bb1d9972eab2-0ec4ae521bb726-3e385b04-1fa400-16bb1d9972f9b8; PHPSESSID=upN0hwQw8FlkIm_Y7uegI45AB8qRVRDS7yq-YGrQ5o6mm6Hc_BSqQg7hNLQ6sr8x; Hm_lvt_6dba01603aa724759d9c4ea0dddd9b72=1562056956,1562816935; CNZZDATA1273105019=948668930-1562055616-%7C1562909757; Hm_lpvt_6dba01603aa724759d9c4ea0dddd9b72=1562914189");

mywebclient.DownloadFile(url, desPath);</code></pre> 
<p>运行，ok~</p> 
<p> </p> 
<p><span style="color:#f33b45;">题外知识：</span></p> 
<p><u><em>有关HTTP头完整、详细的说明，请参见 <a href="http://www.w3.org/Protocols/" rel="nofollow">http://www.w3.org/Protocols/</a> 的HTTP规范。</em></u></p> 
<p><strong>1. RequestHeader分析：</strong></p> 
<p><strong>Accept：</strong>浏览器可接受的MIME类型。 　　　</p> 
<p><strong>Accept-Charset：</strong>浏览器可接受的字符集。　　　</p> 
<p><strong>Accept-Encoding：</strong>浏览器能够进行解码的数据编码方式，比如gzip。Servlet能够向支持gzip的浏览器返回经gzip编码的HTML页面。许多情形下这可以减少5到10倍的下载时间。</p> 
<p><strong>Accept-Language：</strong>浏览器所希望的语言种类，当服务器能够提供一种以上的语言版本时要用到。　　　  Authorization：授权信息，通常出现在对服务器发送的WWW-Authenticate头的应答中。　　　     </p> 
<p><strong>Connection：</strong>表示是否需要持久连接。如果Servlet看到这里的值为“Keep-Alive”，或者看到请求使用的是HTTP   1.1（HTTP   1.1默认进行持久连接），它就可以利用持久连接的优点，当页面包含多个元素时（例如Applet，图片），显著地减少下载所需要的时间。要实现这一点，Servlet需要在应答中发送一个Content-Length头，最简单的实现方法是：先把内容写入ByteArrayOutputStream，然后在正式写出内容之前计算它的大小。　　　</p> 
<p><strong>Content-Length：</strong>表示请求消息正文的长度。　　　</p> 
<p><strong>Cookie：</strong>这是最重要的请求头信息之一　　　</p> 
<p><strong>From：</strong>请求发送者的email地址，由一些特殊的Web客户程序使用，浏览器不会用到它。　　　</p> 
<p><strong>Host：</strong>初始URL中的主机和端口。　　　</p> 
<p><strong>If-Modified-Since：</strong>只有当所请求的内容在指定的日期之后又经过修改才返回它，否则返回304“Not  Modified”应答。　　　</p> 
<p><strong>Pragma：</strong>指定“no-cache”值表示服务器必须返回一个刷新后的文档，即使它是代理服务器而且已经有了页面的本地拷贝。　　　</p> 
<p><strong>Referer：</strong>包含一个URL，用户从该URL代表的页面出发访问当前请求的页面。　　　</p> 
<p><strong>User-Agent：</strong>浏览器类型，如果Servlet返回的内容与浏览器类型有关则该值非常有用。　　　</p> 
<p><strong>UA-Pixels，UA-Color，UA-OS，UA-CPU：</strong>由某些版本的IE浏览器所发送的非标准的请求头，表示屏幕大小、颜色深度、操作系统和CPU类型。　　</p> 
<p>每个标头独占一行， 最后必须要有一个空行。有关HTTP头完整、详细的说明，请参见http://www.w3.org/Protocols/的HTTP规范。</p> 
<p><strong>2.webclient保持session和cookie的方法</strong></p> 
<p><a href="https://www.cnblogs.com/anjou/archive/2008/05/25/1206832.html" rel="nofollow">https://www.cnblogs.com/anjou/archive/2008/05/25/1206832.html</a></p> 
<p>有些朋友说 WebClient 不能保持 Session 和 Cookie，只有 HttpWebRequest 才能保持 Session。实际上我们只要重写 WebClient 的 GetWebRequest 方法就可以使 WebClient 保持 Session 和 Cookie。<br><br> 下面是 HttpClient 类， 它继承自 WebClient，并重写了 GetWebRequest 方法。关键是要定义一个 Cookie 容器（红色代码部分）：</p> 
<pre class="has"><code class="language-cs">/// &lt;summary&gt;
/// 支持 Session 和 Cookie 的 WebClient。
/// &lt;/summary&gt;
public class HttpClient : WebClient 
{
    // Cookie 容器
    private CookieContainer cookieContainer;

    /// &lt;summary&gt;
    /// 创建一个新的 WebClient 实例。
    /// &lt;/summary&gt;
    public HttpClient()
    {
        this.cookieContainer = new CookieContainer();
    }

    /// &lt;summary&gt;
    /// 创建一个新的 WebClient 实例。
    /// &lt;/summary&gt;
    /// &lt;param name="cookie"&gt;Cookie 容器&lt;/param&gt;
    public HttpClient(CookieContainer cookies)
    {
        this.cookieContainer = cookies;
    }

    /// &lt;summary&gt;
    /// Cookie 容器
    /// &lt;/summary&gt;
    public CookieContainer Cookies
    {
        get { return this.cookieContainer; }
        set { this.cookieContainer = value; }
    }

    /// &lt;summary&gt;
    /// 返回带有 Cookie 的 HttpWebRequest。
    /// &lt;/summary&gt;
    /// &lt;param name="address"&gt;&lt;/param&gt;
    /// &lt;returns&gt;&lt;/returns&gt;
    protected override WebRequest GetWebRequest(Uri address)
    {
        WebRequest request = base.GetWebRequest(address);
        if (request is HttpWebRequest)
        {
            HttpWebRequest httpRequest = request as HttpWebRequest;
            httpRequest.CookieContainer = cookieContainer;
        }
        return request;
    }

    #region 封装了PostData, GetSrc 和 GetFile 方法
    /// &lt;summary&gt;
    /// 向指定的 URL POST 数据，并返回页面
    /// &lt;/summary&gt;
    /// &lt;param name="uriString"&gt;POST URL&lt;/param&gt;
    /// &lt;param name="postString"&gt;POST 的 数据&lt;/param&gt;
    /// &lt;param name="postStringEncoding"&gt;POST 数据的 CharSet&lt;/param&gt;
    /// &lt;param name="dataEncoding"&gt;页面的 CharSet&lt;/param&gt;
    /// &lt;returns&gt;页面的源文件&lt;/returns&gt;
    public string PostData(string uriString, string postString, string postStringEncoding, string dataEncoding, out string msg)
    {
        try
        {
            // 将 Post 字符串转换成字节数组
            byte[] postData = Encoding.GetEncoding(postStringEncoding).GetBytes(postString);
            this.Headers.Add("Content-Type", "application/x-www-form-urlencoded");
            // 上传数据，返回页面的字节数组
            byte[] responseData = this.UploadData(uriString, "POST", postData);
            // 将返回的将字节数组转换成字符串(HTML);
            string srcString = Encoding.GetEncoding(dataEncoding).GetString(responseData);
            srcString = srcString.Replace("\t", "");
            srcString = srcString.Replace("\r", "");
            srcString = srcString.Replace("\n", "");
            msg = string.Empty;
            return srcString;
        }
        catch (WebException we)
        {
            msg = we.Message;
            return string.Empty;
        }
    }

    /// &lt;summary&gt;
    /// 获得指定 URL 的源文件
    /// &lt;/summary&gt;
    /// &lt;param name="uriString"&gt;页面 URL&lt;/param&gt;
    /// &lt;param name="dataEncoding"&gt;页面的 CharSet&lt;/param&gt;
    /// &lt;returns&gt;页面的源文件&lt;/returns&gt;
    public string GetSrc(string uriString, string dataEncoding, out string msg)
    {
        try
        {
            // 返回页面的字节数组
            byte[] responseData = this.DownloadData(uriString);
            // 将返回的将字节数组转换成字符串(HTML);
            string srcString = Encoding.GetEncoding(dataEncoding).GetString(responseData);
            srcString = srcString.Replace("\t", "");
            srcString = srcString.Replace("\r", "");
            srcString = srcString.Replace("\n", "");
            msg = string.Empty;
            return srcString;
        }
        catch (WebException we)
        {
            msg = we.Message;
            return string.Empty;
        }
    }

    /// &lt;summary&gt;
    /// 从指定的 URL 下载文件到本地
    /// &lt;/summary&gt;
    /// &lt;param name="uriString"&gt;文件 URL&lt;/param&gt;
    /// &lt;param name="fileName"&gt;本地文件的完成路径&lt;/param&gt;
    /// &lt;returns&gt;&lt;/returns&gt;
    public bool GetFile(string urlString, string fileName, out string msg)
    {
        try
        {
            this.DownloadFile(urlString, fileName);
            msg = string.Empty;
            return true;
        }
        catch (WebException we)
        {
            msg = we.Message;               
            return false;
        }
    }
    #endregion
}</code></pre> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/27ed9d24f1684e3925be3bcd19c63623/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">nrf24l01的配置流程</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/457a48cd0f40186bf72c652fcc238254/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">has been blocked by CORS policy: NO &#39;Access-Control-Allow-Origin&#39; header is present on the reauested</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>