<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据结构——查找の选择题整理 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="数据结构——查找の选择题整理" />
<meta property="og:description" content="顺序查找和折半查找 1、折半查找和二叉排序树的时间性能（）
A、相同
B、有时不相同
C、完全不同
D、无法比较
解析：选B
折半查找的性能可以用二叉排序树来衡量，是O(log2n)，但是二叉排序树的时间性能还与存入的数据有关，如果是性能比较好的情况，则为O(log2n)，如果形成了单侧二叉树，时间性能就为O(n)。如下图：
树型查找 1、含有20个结点的平衡二叉树的最大深度为（）
A、4
B、5
C、6
D、7
解析：选C
平衡二叉树的结点数递推公式为：n0=0，n1=1，n2=2，nh=1&#43;nh-1&#43;nh-2。其中h为二叉树层数，nh表示构造h层二叉树最少需要多少个结点。
2、下列关于红黑树和AVL树的描述中，不正确的是（）
A、两者都属于自平衡二叉树
B、两者插入、删除、查找的时间复杂度都相同
C、红黑树插入和删除过程至多有2次旋转操作
D、红黑树的任一结点的左右子树高度之差不超过2
解析：选C
对于A，自平衡二叉树是指二叉树当达不到平衡时，会自动进行调节，使之再次平衡。显然，红黑树和AVL树都是自平衡二叉树。
对于B，两者插入、删除、查找的时间复杂度都
对于C，在红黑树删除时，可能会出现由情况1（x的兄弟结点w是红色的）变为情况2（x的兄弟结点w是黑色的，w的左孩子是红色的，w的右孩子是黑色的）再变为情况3（x的兄弟结点w是黑色的，w的右孩子是红色的）
对于D，因为红黑树中，根节点到任意叶结点的路径上经过的黑色结点个数都相等，且除了根节点和第二层的叶结点之间，不允许有红红或黑黑的情况出现，红黑必须交叉出现，因此如果高度之差超过2，必定会出现红红或黑黑的情况或者是经过黑色结点数不相等的情况。
3、下列关于红黑树的说法中，正确的是（）
A、红黑树是一种特殊的平衡树
B、如果红黑树的所有结点都是黑色的，那么它一定是一棵满二叉树
C、红黑树的任何一个分支结点都有两个非空孩子结点
D、红黑树的子树也一定是红黑树
解析：选B
对于A，平衡树要求左右子树高度之差不超过1，红黑树只要求不超过2即可。因此不是平衡树。
对于B，因为红黑树的叶结点必须是黑色的，根节点是黑色的，除了第一层了第二层可以连着出现黑黑的情况，其他不允许出现黑黑和红红的情况，且到达叶结点的路径上经过的黑色结点数必须相等，综上所述，所有结点都是黑色的红黑树只能有下图左边两种情况，全都是满二叉树。下图最右边的图可以看到不满足“到达叶结点的路径上经过的黑色结点数必须相等”。
对于C，可以只有一个孩子结点，如下图的右子树中红色的结点，只有一个孩子结点。
对于D，红黑树子树的根结点可能是红色的，因此就不是红黑树，如下图，虚线框里的左子树就不是红黑树。
4、在任意一棵非空平衡二叉树（AVL树）T1中，删除某节点v之后形成平衡二叉树T2，再将v插入T2形成平衡二叉树T3。下列关于T1与T3的叙述中，正确的是（）
a.若v是T1的叶结点，则T1与T3可能不相同
b.若v不是T1的叶结点，则T1与T3一定不相同
c.若v不是T1的叶结点，则T1与T3一定相同
A、仅a
B、仅b
C、仅a和b
D、仅a和c
解析：选A
在下面的图中，分别演示了T1与T3不相等和相等的情况。其中蓝色的结点表示要删除或刚添加的结点。
下图分别是v不是T1的叶结点，T1与T3的情况，由图可知，T1与T3可能相同也可能不相同
B树和B&#43;树 1、具有n个关键字的m阶B树，应有（）个叶结点
A、n&#43;1
B、n-1
C、mn
D、nm/2
解析：选A
叶结点对应的是查找失败的情况，因此求叶结点数量就是求查找失败的数量，即n&#43;1
2、含有n个非叶结点的m阶B树中至少包含（）个关键字
A、n(m&#43;1)
B、n
C、n(⌈ m/2 ⌉-1)
D、(n-1)(⌈ m/2 ⌉-1)&#43;1
解析：选D
⌈ m/2 ⌉-1表示除了根结点之外，其他非叶子结点至少含有的关键字数，除根结点外，共有n-1个非叶子结点，因此共有(n-1)(⌈ m/2 ⌉-1)给关键字，根节点最少可以有1个关键字，因此至少包含关键字数量为：(n-1)(⌈ m/2 ⌉-1)&#43;1" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/50fdf704b2cc38ef96581b13a04eda41/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-07-22T20:55:12+08:00" />
<meta property="article:modified_time" content="2022-07-22T20:55:12+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据结构——查找の选择题整理</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-kimbie-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="_0"></a>顺序查找和折半查找</h2> 
<p>1、折半查找和二叉排序树的时间性能（）<br> A、相同<br> B、有时不相同<br> C、完全不同<br> D、无法比较</p> 
<blockquote> 
 <p>解析：选<strong>B</strong><br> 折半查找的性能可以用二叉排序树来衡量，是O(log<sub>2</sub>n)，但是二叉排序树的时间性能还与存入的数据有关，如果是性能比较好的情况，则为O(log<sub>2</sub>n)，如果形成了单侧二叉树，时间性能就为O(n)。如下图：<br> <img src="https://images2.imgbox.com/31/e5/6EyyU1Z2_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<hr> 
<h2><a id="_11"></a>树型查找</h2> 
<p>1、含有20个结点的平衡二叉树的最大深度为（）<br> A、4<br> B、5<br> C、6<br> D、7</p> 
<blockquote> 
 <p>解析：选<strong>C</strong><br> 平衡二叉树的结点数递推公式为：n<sub>0</sub>=0，n<sub>1</sub>=1，n<sub>2</sub>=2，n<sub>h</sub>=1+n<sub>h-1</sub>+n<sub>h-2</sub>。其中h为二叉树层数，n<sub>h</sub>表示构造h层二叉树最少需要多少个结点。<br> <img src="https://images2.imgbox.com/3f/5d/3jAFS9uZ_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<p>2、下列关于红黑树和AVL树的描述中，不正确的是（）<br> A、两者都属于自平衡二叉树<br> B、两者插入、删除、查找的时间复杂度都相同<br> C、红黑树插入和删除过程至多有2次旋转操作<br> D、红黑树的任一结点的左右子树高度之差不超过2</p> 
<blockquote> 
 <p>解析：选<strong>C</strong><br> 对于A，自平衡二叉树是指二叉树当达不到平衡时，会自动进行调节，使之再次平衡。显然，红黑树和AVL树都是自平衡二叉树。<br> 对于B，两者插入、删除、查找的时间复杂度都<br> 对于C，在红黑树删除时，可能会出现由情况1（x的兄弟结点w是红色的）变为情况2（x的兄弟结点w是黑色的，w的左孩子是红色的，w的右孩子是黑色的）再变为情况3（x的兄弟结点w是黑色的，w的右孩子是红色的）<br> 对于D，因为红黑树中，根节点到任意叶结点的路径上经过的黑色结点个数都相等，且除了根节点和第二层的叶结点之间，不允许有红红或黑黑的情况出现，红黑必须交叉出现，因此如果高度之差超过2，必定会出现红红或黑黑的情况或者是经过黑色结点数不相等的情况。</p> 
</blockquote> 
<p>3、下列关于红黑树的说法中，正确的是（）<br> A、红黑树是一种特殊的平衡树<br> B、如果红黑树的所有结点都是黑色的，那么它一定是一棵满二叉树<br> C、红黑树的任何一个分支结点都有两个非空孩子结点<br> D、红黑树的子树也一定是红黑树</p> 
<blockquote> 
 <p>解析：选<strong>B</strong><br> 对于A，平衡树要求左右子树高度之差不超过1，红黑树只要求不超过2即可。因此不是平衡树。<br> 对于B，因为红黑树的叶结点必须是黑色的，根节点是黑色的，除了第一层了第二层可以连着出现黑黑的情况，其他不允许出现黑黑和红红的情况，且到达叶结点的路径上经过的黑色结点数必须相等，综上所述，所有结点都是黑色的红黑树只能有下图左边两种情况，全都是满二叉树。下图最右边的图可以看到不满足“到达叶结点的路径上经过的黑色结点数必须相等”。<br> <img src="https://images2.imgbox.com/6b/24/NFPlnJqD_o.png" alt="在这里插入图片描述"><br> 对于C，可以只有一个孩子结点，如下图的右子树中红色的结点，只有一个孩子结点。<br> 对于D，红黑树子树的根结点可能是红色的，因此就不是红黑树，如下图，虚线框里的左子树就不是红黑树。<br> <img src="https://images2.imgbox.com/80/70/Hc2qUY86_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<p>4、在任意一棵非空平衡二叉树（AVL树）T<sub>1</sub>中，删除某节点v之后形成平衡二叉树T<sub>2</sub>，再将v插入T<sub>2</sub>形成平衡二叉树T<sub>3</sub>。下列关于T<sub>1</sub>与T<sub>3</sub>的叙述中，正确的是（）<br> a.若v是T<sub>1</sub>的叶结点，则T<sub>1</sub>与T<sub>3</sub>可能不相同<br> b.若v不是T<sub>1</sub>的叶结点，则T<sub>1</sub>与T<sub>3</sub>一定不相同<br> c.若v不是T<sub>1</sub>的叶结点，则T<sub>1</sub>与T<sub>3</sub>一定相同<br> A、仅a<br> B、仅b<br> C、仅a和b<br> D、仅a和c</p> 
<blockquote> 
 <p>解析：选<strong>A</strong><br> 在下面的图中，分别演示了T<sub>1</sub>与T<sub>3</sub>不相等和相等的情况。其中蓝色的结点表示要删除或刚添加的结点。<br> <img src="https://images2.imgbox.com/45/38/tPJBRjfF_o.png" alt="在这里插入图片描述"><br> 下图分别是v不是T<sub>1</sub>的叶结点，T<sub>1</sub>与T<sub>3</sub>的情况，由图可知，T<sub>1</sub>与T<sub>3</sub>可能相同也可能不相同<br> <img src="https://images2.imgbox.com/f7/10/82SacrIa_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<hr> 
<h2><a id="BB_67"></a>B树和B+树</h2> 
<p>1、具有n个关键字的m阶B树，应有（）个叶结点<br> A、n+1<br> B、n-1<br> C、mn<br> D、nm/2</p> 
<blockquote> 
 <p>解析：选<strong>A</strong><br> 叶结点对应的是查找失败的情况，因此求叶结点数量就是求查找失败的数量，即n+1</p> 
</blockquote> 
<p>2、含有n个非叶结点的m阶B树中至少包含（）个关键字<br> A、n(m+1)<br> B、n<br> C、n(⌈ m/2 ⌉-1)<br> D、(n-1)(⌈ m/2 ⌉-1)+1</p> 
<blockquote> 
 <p>解析：选<strong>D</strong><br> ⌈ m/2 ⌉-1表示除了根结点之外，其他非叶子结点至少含有的关键字数，除根结点外，共有n-1个非叶子结点，因此共有(n-1)(⌈ m/2 ⌉-1)给关键字，根节点最少可以有1个关键字，因此至少包含关键字数量为：(n-1)(⌈ m/2 ⌉-1)+1</p> 
</blockquote> 
<p>3、已知一棵3阶B树中有2047个关键字，则此B树的最大高度为（），最小高度为（）<br> A、11<br> B、10<br> C、8<br> D、7</p> 
<blockquote> 
 <p>解析：选<strong>A、D</strong><br> log<sub>m</sub>(n+1) &lt;= h &lt;= log<sub>⌈m/2⌉</sub>((n+1)/2)+1，其中m表示阶数，n表示关键字个数。<br> 带入解得6.94&lt;=h&lt;=11</p> 
</blockquote> 
<p>4、下列关于B树和B+树的叙述中，不正确的是（）<br> A、B树和B+树都能有效的支持顺序查找<br> B、B树和B+树都能有效地支持随机查找<br> C、B树和B+树都是平衡的多叉树<br> D、B树和B+树都可以用于文件索引结构</p> 
<blockquote> 
 <p>解析：选<strong>A</strong><br> 因为B+树叶子节点之间还有指针相连，因此支持顺序查找，且支持随即查找，而对于B树则不支持顺序查找，仅允许随机查找。</p> 
</blockquote> 
<p>5、B+树不同于B树的特点之一是（）<br> A、能支持顺序查找<br> B、结点中含有关键字<br> C、根节点至少有两个分支<br> D、所有叶结点都在同一层上</p> 
<blockquote> 
 <p>解析：选<strong>A</strong><br> 原因同上一题</p> 
</blockquote> 
<p>6、高度为5的3阶B树含有的关键字个数至少是（）<br> A、15<br> B、31<br> C、62<br> D、242</p> 
<blockquote> 
 <p>解析：选<strong>B</strong><br> h&lt;= log<sub>⌈m/2⌉</sub>((n+1)/2)+1，其中m=3，h=5，解得n=31</p> 
</blockquote> 
<hr> 
<h2><a id="_118"></a>散列表</h2> 
<p>1、只能在顺序存储结构上进行的查找方法是（）<br> A、顺序查找法<br> B、折半查找法<br> C、树型查找法<br> D、散列查找法</p> 
<blockquote> 
 <p>解析：选<strong>B</strong><br> 顺序存储一般利用数组实现。<br> 顺序查找既可以顺序存储也可以链式存储。<br> 折半查找必须要顺序存储且关键字有序<br> 树型查找只要是满足树型存储即可，树型存储可以用顺序存储实现也可以用链式存储实现<br> 散列查找中的链地址法解决冲突时，就是采用顺序存储和链式存储相结合的方法。<br> <img src="https://images2.imgbox.com/fa/1b/5BxerCBn_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<p>2、下列关于散列冲突处理方法的说法中，正确的有（）<br> a.采用再散列法处理冲突时不易产生聚集<br> b.采用线性探测法处理冲突时，所有同义词在散列表中一定相邻<br> c.采用链地址法处理冲突时，若限定在链首插入，则插入任一个元素的时间是相同的<br> d.采用链地址法处理冲突易引起聚集现象<br> A、a和c<br> B、a、b和c<br> C、c和d<br> D、a和d</p> 
<blockquote> 
 <p>解析：选<strong>A</strong><br> 利用再散列法处理冲突时，是采用跳跃式的方法寻找下一个空闲位置，不易发生聚集。<br> 采用线性探测法处理冲突时，所有同义词在散列表中不一定相邻，中间可能有原先就已经存在的数据，此时需要再向后寻找空闲位置。<br> 采用链地址法处理冲突时，若限定在链首插入，则插入任一个元素仅需要直接插入数据即可，不用管后面有多少个数据。<br> 链地址法处理冲突时将所有的同义词放在一个链表里，并不放在原先的数组中，不会引起聚集现象。</p> 
</blockquote> 
<p>3、设有一个含有200个表项的散列表，用线性探测法解决冲突，按关键字查找时找到一个表项的平均探测次数不超过1.5，则散列表项应能容纳（）个表项（设查找成功的平均查找长度为ASL=[1+1 / (1-α) ] / 2）。<br> A、400<br> B、526<br> C、624<br> D、676</p> 
<blockquote> 
 <p>解析：选<strong>A</strong><br> 由题干可知ASL&lt;=1.5，代入公式解得α&lt;=0.5。因为α=200/m，所以m&gt;=400，因此选A</p> 
</blockquote> 
<p>4、采用开放定址法解决冲突的散列查找中，发生聚集的原因主要是（）<br> A、数据元素过多<br> B、负载因子过大<br> C、散列函数选择不当<br> D、解决冲突的方法选择不当</p> 
<blockquote> 
 <p>解析：选<strong>D</strong><br> 发生聚集主要是解决冲突的方法选择不当产生的，例如相同的散列函数下，选择链地址法解决冲突就不会产生聚集，而选择线性探测法解决冲突，就可能发生聚集。</p> 
</blockquote> 
<p>5、若采用链地址法构造散列表，散列函数为H(key) = key MOD 17，则需（①）个链表。这些链的链首指针构成一个指针数组，数组的下标范围为（②）<br> ①<br> A、17<br> B、13<br> C、16<br> D、任意<br> ②<br> A、0~17<br> B、1~17<br> C、0~16<br> D、1~16</p> 
<blockquote> 
 <p>解析：选<strong>①：A；②：C</strong><br> 因为用17取模，所以结果可能是0 ~ 16共17个数，因此需要17个链表，数组从0开始到16结束，下标范围是0 ~ 16</p> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/40f7c78dcbf7edc5097297e181a4104a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Java数组的使用和方法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/33f42a064213d81628701cb13098ee02/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">开源对象存储方案</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>