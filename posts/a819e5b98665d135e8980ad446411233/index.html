<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>构造方法及重载 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="构造方法及重载" />
<meta property="og:description" content="构造器也叫构造方法(constructor)，用于对象的初始化。构造器是一个创建对象时被自动调用的特殊方法，目的是对象的初始化。构造器的名称应与类的名称一致。Java通过new关键字来调用构造器，从而返回该类的实例，是一种特殊的方法。
声明格式：　1
2
3
[修饰符] 类名(形参列表){
//n条语句
}
要点：
1. 通过new关键字调用!!
2. 构造器虽然有返回值，但是不能定义返回值类型(返回值的类型肯定是本类)，不能在构造器里使用return返回某个值。
3. 如果我们没有定义构造器，则编译器会自动定义一个无参的构造函数。如果已定义则编译器不会自动添加!
4. 构造器的方法名必须和类名一致!
/** * 测试构造方法 * @author Memorial * */ class Point{ double x,y; //构造方法名称和类名必须保持一致 public Point(double _x,double _y) { x=_x; y=_y; } Point(){ } public double getDistance(Point p) { return Math.sqrt((x-p.x)*(x-p.x)&#43;(y-p.y)*(y-p.y)); } } public class TestConstructor { public static void main(String[] args) { Point p=new Point(3.0,4.0); Point origin=new Point(0.0,0.0); //Point p2=new Point(); System." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/a819e5b98665d135e8980ad446411233/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-12-21T21:54:13+08:00" />
<meta property="article:modified_time" content="2018-12-21T21:54:13+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">构造方法及重载</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>构造器也叫构造方法(constructor)，用于对象的初始化。构造器是一个创建对象时被自动调用的特殊方法，目的是对象的初始化。构造器的名称应与类的名称一致。Java通过new关键字来调用构造器，从而返回该类的实例，是一种特殊的方法。</p> 
<p><strong>声明格式：</strong>　</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> </td><td> <p><code>[修饰符] 类名(形参列表){<!-- --></code></p> <p><code>    </code><code>//n条语句</code></p> <p><code>}</code></p> </td></tr></tbody></table> 
<p><strong>要点：</strong></p> 
<p>　　1. 通过new关键字调用!!</p> 
<p>　　2. 构造器虽然有返回值，但是不能定义返回值类型(返回值的类型肯定是本类)，不能在构造器里使用return返回某个值。</p> 
<p>　　3. 如果我们没有定义构造器，则编译器会自动定义一个无参的构造函数。如果已定义则编译器不会自动添加!</p> 
<p>　　4. 构造器的方法名必须和类名一致!</p> 
<pre class="has"><code class="language-java">/**
 * 测试构造方法
 * @author Memorial
 *
 */
class Point{
	double x,y;
	
	//构造方法名称和类名必须保持一致
	public Point(double _x,double _y) {
		x=_x;
		y=_y;
	}
Point(){
}
public double getDistance(Point p) {
	return Math.sqrt((x-p.x)*(x-p.x)+(y-p.y)*(y-p.y));
}
}
public class TestConstructor {
public static void main(String[] args) {
	Point p=new Point(3.0,4.0);
	Point origin=new Point(0.0,0.0);
	//Point p2=new Point();
	
	
	System.out.println(p.getDistance(origin));
}
}

输出：
5.0</code></pre> 
<p>构造方法的重载（创建不同的用户对象）：</p> 
<pre class="has"><code class="language-java">/**
 * 构造方法的重载
 * @author Memorial
 *
 */
public class User {
   int id;//id
   String name;//账户名
   String pwd;//密码
public User() {
	  
}
public User(int id,String name) {
	  //super();//构造方法的第一句总是super（）
	  this.id=id;//this表示创建好的对象
	  this.name=name;
  }
public User(int id,String name,String pwd) {
	this.id=id;
	this.name=name;
	this.pwd=pwd;
	
}
  public static void main(String[] args) {
	User u1=new User();
	User u2=new User(101,"Memorial");
	User u3=new User(100,"Memorial","123445");
	}
  }
  </code></pre> 
<p>如果方法构造中形参名与属性名相同时，需要使用this关键字区分属性与形参。</p> 
<p>this.id 表示属性id;id表示形参id</p> 
<pre class="has"><code class="language-java">/**
 * 测试this关键字
 * 
 * @author Memorial
 *
 */
public class User1 {
	int id;
	String name;
	String pwd;

	public User1() {

	}

	public User1(int id, String name) {
		System.out.println("正在初始化已经创建好的对象： " + this);
		this.id = id;// 不写this,无法区分局部变量id和成员变量id
		this.name = name;

	}

	public void login() {
		System.out.println(this.name + "，要登录！");// 不写this效果一样

	}

	public static void main(String[] args) {
		User1 u2 = new User1(1010, "Memorial");
		System.out.println("打印Memorial对象：" + u2);
		u2.login();
	}
}
</code></pre> 
<p>this关键字调用重载构造方法</p> 
<pre class="has"><code class="language-java">/**
 * 测试this重载
 * @author Memorial
 *
 */
public class TestThis {
int a,b,c;
TestThis(){
System.out.println("正要初始化一个Hello对象");
}
TestThis(int a,int b){
	//TestThis();//这样是无法调用构造方法的！
	this();//调用无参的构造方法，必须位于第一行
	a=a;//这里都是指的局部变量而不是成员变量
	//这样就区分了成员变量和局部变量。这种情况占了this使用情况大多数！
	this.a=a;
	this.b=b;
	
}
TestThis(int a ,int b,int c){
	this(a,b);//调用带参的构造方法，并且必须位于第一行
	this.c=c;
}
void sing() {
}
void eat() {
	this.sing();//调用本类中的sing()；
	System.out.println("快回家吃饭！");
}
public static void main(String[] args) {
	TestThis h=new TestThis(2,3);
	h.eat();
}
}


输出：
正要初始化一个Hello对象
快回家吃饭！
</code></pre> 
<p>类的构造方法</p> 
<p>1.单个构造方法</p> 
<p> </p> 
<pre class="has"><code class="language-java">/**
 * 汽车类
 * @author Memorial
 *
 */
public class Car_1 {
private String color;
private String brand;
public Car_1() {//构造函数；
	this.brand="奥迪";
	this.color="黑色";
	
}
public String getColor() {//对私有成员的get方法
	return this.color;
}
public String getBrand() {
	return this.brand;
}

}
/*
 * 构造函数，构造函数名和类名相同
 * 在创建对象时，对象成员可以是由构造函数方法进行初始化。
 * 构造函数的任务是初始化一个对象内部的状态。
 */
</code></pre> 
<p> </p> 
<pre class="has"><code class="language-java">
public class main {

	public static void main(String[] args) {
		Car_1 c = new Car_1();
		System.out.println("汽车颜色为：" + c.getColor());
		System.out.println("汽车牌子为：" + c.getBrand());
	}
}
</code></pre> 
<p>2.多个构造方法</p> 
<pre class="has"><code class="language-java">/*
 * 汽车类，其中有两个构造函数
 */
public class Car {
private String color;
private String brand;
public Car() {
	this.color="黑色";
	this.brand="奥迪";
}
public Car(String co,String br) {//有参数构造函数方法
	this.color=co;
	this.brand=br;
}
public String getColor() {//私有成员的get方法
	return this.color;
}
public String getBrand() {
	return this.brand;
}
}
/*
 * 有时一个类中可能存在多个构造函数，每个构造函数的参数类型不同
 * 多个构造函数可看做方法的重载。
 * 只能根据参数类型匹配合适的构造方法。
 */</code></pre> 
<pre class="has"><code class="language-java">/*
 * 创建两个对象，实例化汽车对象是分带参数和不带参数的。
 */
public class Main_2 {
	public static void main(String[] args) {
		Car c=new Car();
		Car c1=new Car("红色","福克斯");
		System.out.println("*********无参数构造函数******");
		System.out.println("汽车颜色为："+c.getColor());
		System.out.println("汽车牌子为："+c.getBrand());
		System.out.println("*******有参数构造函数********");
		System.out.println("汽车颜色为："+c1.getColor());
		System.out.println("汽车牌子为："+c1.getBrand());
	}

}

输出：
*********无参数构造函数******
汽车颜色为：黑色
汽车牌子为：奥迪
*******有参数构造函数********
汽车颜色为：红色
汽车牌子为：福克斯</code></pre> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e920401ca466ad170d4331e474bb9c73/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">ubuntu 16 vi 方向键乱</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/27900843c721f92f618f0e2bcdb0b5fc/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Slf4j获取日志对象(Logger)的实现分析</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>