<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【C&#43;&#43;高阶数据结构】跳表（skiplist） - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【C&#43;&#43;高阶数据结构】跳表（skiplist）" />
<meta property="og:description" content="🏆个人主页：企鹅不叫的博客
​ 🌈专栏
C语言初阶和进阶C项目Leetcode刷题初阶数据结构与算法C&#43;&#43;初阶和进阶《深入理解计算机操作系统》《高质量C/C&#43;&#43;编程》Linux ⭐️ 博主码云gitee链接：代码仓库地址
⚡若有帮助可以【关注&#43;点赞&#43;收藏】，大家一起进步！
💙系列文章💙 【C&#43;&#43;高阶数据结构】并查集
【C&#43;&#43;高阶数据结构】图
【C&#43;&#43;高阶数据结构】LRU
【C&#43;&#43;高阶数据结构】B树、B&#43;树、B*树
文章目录 💙系列文章💙💎一、概念💎二、实现💎三、性能分析 💎一、概念 假如我们每相邻两个节点升高一层，增加一个指针，让指针指向下下个节点，如下图b所示。这样所有新增加的指针连成了一个新的链表，但它包含的节点个数只有原来的一半。由于新增加的指针，我们不再需要与链表中每个节点逐个进行比较了，需要比较的节点数大概只有原来的一半。
以此类推，我们可以在第二层新产生的链表上，继续为每相邻的两个节点升高一层，增加一个指针，从而产生第三层链表。如下图c，这样搜索效率就进一步提高了。
实际上，按照上面生成链表的方式，上面每一层链表的节点个数，是下面一层的节点个数的一半，这样查找过程就非常类似二分查找，使得查找的时间复杂度可以降低到O(log n)。
不再严格要求对应比例关系，而是插入一个节点的时候随机出一个层数
一个结点到底应该给几层？
一个节点的平均层数（也即包含的平均指针数目），计算如下：
当p=1/2时，每个节点所包含的平均指针数目为2；
当p=1/4时，每个节点所包含的平均指针数目为1.33。
💎二、实现 设计跳表
思路：
首先设计节点，包含节点值和存储next指针跳表设计，定义一个头节点，最大层数，生成层数概率 struct SkiplistNode { int _val; //用来存next指针的vector vector&lt;SkiplistNode*&gt; _nextV; SkiplistNode(int val,int level) :_val(val) ,_nextV(level,nullptr) {} }; class Skiplist { typedef SkiplistNode Node; public: Skiplist() { srand(time(0)); //头结点，层数是1 _head=new Node(-1,1); } vector&lt;Node*&gt; FindPrevNode(int num) { //创建一个临时节点先指向我们的头节点 Node* cur = _head; //初始化我们的层数是我们头结点的层数 int level = _head-&gt;_nextV." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/4b5dce0a8903eb485ba7f95d17a3f2b5/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-01-07T16:17:18+08:00" />
<meta property="article:modified_time" content="2023-01-07T16:17:18+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【C&#43;&#43;高阶数据结构】跳表（skiplist）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <blockquote> 
 <p>🏆<strong>个人主页</strong>：<a href="https://blog.csdn.net/YQ20210216?spm=1000.2115.3001.5343">企鹅不叫的博客</a></p> 
 <p>​ 🌈<strong>专栏</strong></p> 
 <ul><li><a href="https://blog.csdn.net/yq20210216/category_11417182.html?spm=1001.2014.3001.5482">C语言初阶和进阶</a></li><li><a href="https://blog.csdn.net/yq20210216/category_11679165.html">C项目</a></li><li><a href="https://blog.csdn.net/yq20210216/category_11666534.html?spm=1001.2014.3001.5482">Leetcode刷题</a></li><li><a href="https://blog.csdn.net/yq20210216/category_11665095.html?spm=1001.2014.3001.5482">初阶数据结构与算法</a></li><li><a href="https://blog.csdn.net/yq20210216/category_11728338.html?spm=1001.2014.3001.5482">C++初阶和进阶</a></li><li><a href="https://blog.csdn.net/yq20210216/category_11795108.html?spm=1001.2014.3001.5482">《深入理解计算机操作系统》</a></li><li><a href="https://blog.csdn.net/yq20210216/category_11795123.html?spm=1001.2014.3001.5482">《高质量C/C++编程》</a></li><li><a href="https://blog.csdn.net/yq20210216/category_11818303.html?spm=1001.2014.3001.5482">Linux</a></li></ul> 
 <p>⭐️ <strong>博主码云gitee链接：</strong><a href="https://gitee.com/royal-never-give-up" rel="nofollow">代码仓库地址</a></p> 
 <p>⚡若有帮助可以【<font color="#DC143C">关注</font>+<font color="#FFA500">点赞</font>+<font color="#45b97c">收藏</font>】，大家一起进步！</p> 
</blockquote> 
<h2><a id="_17"></a>💙系列文章💙</h2> 
<p><a href="https://blog.csdn.net/YQ20210216/article/details/128436878?csdn_share_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%22128436878%22%2C%22source%22%3A%22YQ20210216%22%7D">【C++高阶数据结构】并查集</a></p> 
<p><a href="https://blog.csdn.net/YQ20210216/article/details/128552858?csdn_share_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%22128552858%22%2C%22source%22%3A%22YQ20210216%22%7D">【C++高阶数据结构】图</a></p> 
<p><a href="https://blog.csdn.net/YQ20210216/article/details/128565806?csdn_share_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%22128565806%22%2C%22source%22%3A%22YQ20210216%22%7D">【C++高阶数据结构】LRU</a></p> 
<p><a href="https://blog.csdn.net/YQ20210216/article/details/128584112?csdn_share_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%22128584112%22%2C%22source%22%3A%22YQ20210216%22%7D">【C++高阶数据结构】B树、B+树、B*树</a></p> 
<hr> 
<p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#_17" rel="nofollow">💙系列文章💙</a></li><li><a href="#_32" rel="nofollow">💎一、概念</a></li><li><a href="#_55" rel="nofollow">💎二、实现</a></li><li><a href="#_235" rel="nofollow">💎三、性能分析</a></li></ul> 
</div> 
<p></p> 
<hr> 
<h2><a id="_32"></a>💎一、概念</h2> 
<blockquote> 
 <ol><li> <p>假如我们每相邻两个节点升高一层，增加一个指针，让指针指向下下个节点，如下图b所示。这样所有新增加的指针连成了一个新的链表，但它包含的节点个数只有原来的一半。由于新增加的指针，我们不再需要与链表中每个节点逐个进行比较了，需要比较的节点数大概只有原来的一半。</p> </li><li> <p>以此类推，我们可以在第二层新产生的链表上，继续为每相邻的两个节点升高一层，增加一个指针，从而产生第三层链表。如下图c，这样搜索效率就进一步提高了。</p> </li><li> <p>实际上，按照上面生成链表的方式，上面每一层链表的节点个数，是下面一层的节点个数的一半，这样查找过程就非常类似二分查找，使得查找的时间复杂度可以降低到O(log n)。<img src="https://images2.imgbox.com/c1/70/vwoz4bB5_o.png" alt="在这里插入图片描述"></p> </li><li> <p>不再严格要求对应比例关系，而是插入一个节点的时候随机出一个层数</p> </li></ol> 
 <p><img src="https://images2.imgbox.com/5e/c4/bKX39A2w_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<blockquote> 
 <p>一个结点到底应该给几层？</p> 
 <p>一个节点的平均层数（也即包含的平均指针数目），计算如下：</p> 
 <p><img src="https://images2.imgbox.com/c6/06/7KPR79ka_o.png" alt="在这里插入图片描述"></p> 
 <p>当p=1/2时，每个节点所包含的平均指针数目为2；<br> 当p=1/4时，每个节点所包含的平均指针数目为1.33。</p> 
</blockquote> 
<h2><a id="_55"></a>💎二、实现</h2> 
<blockquote> 
 <p><a href="https://leetcode.cn/problems/design-skiplist/" rel="nofollow">设计跳表</a></p> 
 <p><img src="https://images2.imgbox.com/ec/f2/U06PuURP_o.png" alt="在这里插入图片描述"></p> 
 <p><img src="https://images2.imgbox.com/99/c3/Sa1Y0z3e_o.gif" alt="img"></p> 
 <p><img src="https://images2.imgbox.com/a7/34/FWTaTaji_o.png" alt="在这里插入图片描述"></p> 
 <p>思路：</p> 
 <ol><li>首先设计节点，包含节点值和存储next指针</li><li>跳表设计，定义一个头节点，最大层数，生成层数概率</li></ol> 
 <pre><code class="prism language-cpp"><span class="token keyword">struct</span> <span class="token class-name">SkiplistNode</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> _val<span class="token punctuation">;</span>
    <span class="token comment">//用来存next指针的vector</span>
    vector<span class="token operator">&lt;</span>SkiplistNode<span class="token operator">*</span><span class="token operator">&gt;</span> _nextV<span class="token punctuation">;</span>
    <span class="token function">SkiplistNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> val<span class="token punctuation">,</span><span class="token keyword">int</span> level<span class="token punctuation">)</span>
        <span class="token operator">:</span><span class="token function">_val</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span>
        <span class="token punctuation">,</span><span class="token function">_nextV</span><span class="token punctuation">(</span>level<span class="token punctuation">,</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">Skiplist</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">typedef</span> SkiplistNode Node<span class="token punctuation">;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">Skiplist</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token function">srand</span><span class="token punctuation">(</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//头结点，层数是1</span>
        _head<span class="token operator">=</span><span class="token keyword">new</span> <span class="token function">Node</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    vector<span class="token operator">&lt;</span>Node<span class="token operator">*</span><span class="token operator">&gt;</span> <span class="token function">FindPrevNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
        <span class="token comment">//创建一个临时节点先指向我们的头节点</span>
		Node<span class="token operator">*</span> cur <span class="token operator">=</span> _head<span class="token punctuation">;</span>
        <span class="token comment">//初始化我们的层数是我们头结点的层数</span>
		<span class="token keyword">int</span> level <span class="token operator">=</span> _head<span class="token operator">-&gt;</span>_nextV<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>

		<span class="token comment">// 插入位置每一层前一个节点指针</span>
		vector<span class="token operator">&lt;</span>Node<span class="token operator">*</span><span class="token operator">&gt;</span> <span class="token function">prevV</span><span class="token punctuation">(</span>level <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> _head<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">//当我们还没有走到最底下那一层的时候</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span>level <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token comment">// 目标值比下一个节点值要大，向右走</span>
			<span class="token comment">// 下一个节点是空(尾)，目标值比下一个节点值要小，向下走</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>cur<span class="token operator">-&gt;</span>_nextV<span class="token punctuation">[</span>level<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> cur<span class="token operator">-&gt;</span>_nextV<span class="token punctuation">[</span>level<span class="token punctuation">]</span><span class="token operator">-&gt;</span>_val <span class="token operator">&lt;</span> num<span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				<span class="token comment">// 向右走</span>
				cur <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>_nextV<span class="token punctuation">[</span>level<span class="token punctuation">]</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
            <span class="token comment">//如果当前层没有下一个节点了</span>
            <span class="token comment">//或者当前层的下一个节点比我们的目标值小</span>
			<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>cur<span class="token operator">-&gt;</span>_nextV<span class="token punctuation">[</span>level<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token keyword">nullptr</span>
				<span class="token operator">||</span> cur<span class="token operator">-&gt;</span>_nextV<span class="token punctuation">[</span>level<span class="token punctuation">]</span><span class="token operator">-&gt;</span>_val <span class="token operator">&gt;=</span> num<span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
                <span class="token comment">//只有当需要转移到下一层的时候，我们才找到了当前层的前置结点</span>
				<span class="token comment">// 更新level层前一个</span>
				prevV<span class="token punctuation">[</span>level<span class="token punctuation">]</span> <span class="token operator">=</span> cur<span class="token punctuation">;</span>

				<span class="token comment">// 向下走</span>
				<span class="token operator">--</span>level<span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>

		<span class="token keyword">return</span> prevV<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
    <span class="token comment">//查找数据</span>
    <span class="token keyword">bool</span> <span class="token function">search</span><span class="token punctuation">(</span><span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        Node<span class="token operator">*</span> cur<span class="token operator">=</span>_head<span class="token punctuation">;</span>
        <span class="token comment">//往最高层走</span>
        <span class="token keyword">int</span> level<span class="token operator">=</span>_head<span class="token operator">-&gt;</span>_nextV<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>level<span class="token operator">&gt;=</span><span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token comment">//目标值比下一个结点值要大，向右走</span>
            <span class="token comment">//下一个节点是空（尾），目标值比下一个结点值要小，向下走</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>cur<span class="token operator">-&gt;</span>_nextV<span class="token punctuation">[</span>level<span class="token punctuation">]</span><span class="token operator">&amp;&amp;</span>cur<span class="token operator">-&gt;</span>_nextV<span class="token punctuation">[</span>level<span class="token punctuation">]</span><span class="token operator">-&gt;</span>_val<span class="token operator">&lt;</span>target<span class="token punctuation">)</span>
            <span class="token punctuation">{<!-- --></span>
                <span class="token comment">//向右走</span>
                cur<span class="token operator">=</span>cur<span class="token operator">-&gt;</span>_nextV<span class="token punctuation">[</span>level<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>cur<span class="token operator">-&gt;</span>_nextV<span class="token punctuation">[</span>level<span class="token punctuation">]</span><span class="token operator">==</span><span class="token keyword">nullptr</span> <span class="token operator">||</span> cur<span class="token operator">-&gt;</span>_nextV<span class="token punctuation">[</span>level<span class="token punctuation">]</span><span class="token operator">-&gt;</span>_val<span class="token operator">&gt;</span>target<span class="token punctuation">)</span>
            <span class="token punctuation">{<!-- --></span>
                <span class="token comment">//向下走</span>
                <span class="token operator">--</span>level<span class="token punctuation">;</span>
            <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{<!-- --></span>
                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        vector<span class="token operator">&lt;</span>Node<span class="token operator">*</span><span class="token operator">&gt;</span> prev<span class="token operator">=</span><span class="token function">FindPrevNode</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//产生新节点的层数</span>
        <span class="token keyword">int</span> n<span class="token operator">=</span><span class="token function">RandomLevel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//数据是num，有n层的结点</span>
        Node<span class="token operator">*</span> newnode<span class="token operator">=</span><span class="token keyword">new</span> <span class="token function">Node</span><span class="token punctuation">(</span>num<span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//如果n超过了当前最大的层数，那就升高一下head的层数</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>n<span class="token operator">&gt;</span>_head<span class="token operator">-&gt;</span>_nextV<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token comment">//将头结点的next数组的大小开辟到我们当前的最大的层数大小，新的部分用nullptr填补</span>
             _head<span class="token operator">-&gt;</span>_nextV<span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">//将我们的前置结点也同样开辟到n的大小</span>
            prev<span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span>_head<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
           

        <span class="token comment">//链接前后节点</span>
        <span class="token comment">//每一层我们都是要更新的</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span>size_t i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            newnode<span class="token operator">-&gt;</span>_nextV<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>prev<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-&gt;</span>_nextV<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
            prev<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-&gt;</span>_nextV<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>newnode<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    
    <span class="token keyword">bool</span> <span class="token function">erase</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        vector<span class="token operator">&lt;</span>Node<span class="token operator">*</span><span class="token operator">&gt;</span> prev<span class="token operator">=</span><span class="token function">FindPrevNode</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//第一层下一个不是val，或者val不在表中</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>prev<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">-&gt;</span>_nextV<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token keyword">nullptr</span> <span class="token operator">||</span>prev<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">-&gt;</span>_nextV<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">-&gt;</span>_val<span class="token operator">!=</span>num<span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">else</span><span class="token punctuation">{<!-- --></span>
            Node<span class="token operator">*</span> del <span class="token operator">=</span>prev<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">-&gt;</span>_nextV<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token comment">//del结点每一层的前后指针链接起来</span>
            <span class="token keyword">for</span><span class="token punctuation">(</span>size_t i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>del<span class="token operator">-&gt;</span>_nextV<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>
            <span class="token punctuation">{<!-- --></span>
                prev<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-&gt;</span>_nextV<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>del<span class="token operator">-&gt;</span>_nextV<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">delete</span> del<span class="token punctuation">;</span>

            <span class="token comment">// 如果删除最高层节点，把头节点的层数也降一下</span>
			<span class="token keyword">int</span> i <span class="token operator">=</span> _head<span class="token operator">-&gt;</span>_nextV<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
			<span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				<span class="token keyword">if</span> <span class="token punctuation">(</span>_head<span class="token operator">-&gt;</span>_nextV<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>
					<span class="token operator">--</span>i<span class="token punctuation">;</span>
				<span class="token keyword">else</span>
					<span class="token keyword">break</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			_head<span class="token operator">-&gt;</span>_nextV<span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">int</span> <span class="token function">RandomLevel</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        size_t level<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>

        <span class="token comment">// rand()最大值在[0,RAND_MAX]之间</span>
        <span class="token comment">//相当于[0， 1]的范围</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;</span>RAND_MAX<span class="token operator">*</span>_p<span class="token operator">&amp;&amp;</span>level<span class="token operator">&lt;</span>_maxLevel<span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token operator">++</span>level<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> level<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    Node<span class="token operator">*</span> _head<span class="token punctuation">;</span><span class="token comment">//头结点</span>
    size_t _maxLevel<span class="token operator">=</span><span class="token number">32</span><span class="token punctuation">;</span><span class="token comment">//最大层数</span>
    <span class="token keyword">double</span> _p<span class="token operator">=</span><span class="token number">0.5</span><span class="token punctuation">;</span><span class="token comment">//创建新层的概率</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">/**
 * Your Skiplist object will be instantiated and called as such:
 * Skiplist* obj = new Skiplist();
 * bool param_1 = obj-&gt;search(target);
 * obj-&gt;add(num);
 * bool param_3 = obj-&gt;erase(num);
 */</span>

</code></pre> 
</blockquote> 
<h2><a id="_235"></a>💎三、性能分析</h2> 
<blockquote> 
 <ol><li>skiplist相比平衡搜索树(AVL树和红黑树)对比，都可以做到遍历数据有序，时间复杂度也差不多。skiplist的优势是：a、skiplist实现简单，容易控制。平衡树增删查改遍历都更复杂。b、skiplist的额外空间消耗更低。平衡树节点存储每个值有三叉链，平衡因子/颜色等消耗。skiplist中p=1/2时，每个节点所包含的平均指针数目为2；skiplist中p=1/4时，每个节点所包含的平均指针数目为1.33；</li><li>skiplist相比哈希表而言，就没有那么大的优势了。相比而言a、哈希表平均时间复杂度是O(1)，比skiplist快。b、哈希表空间消耗略多一点。skiplist优势如下：a、遍历数据有序b、skiplist空间消耗略小一点，哈希表存在链接指针和表空间消耗。c、哈希表扩容有性能损耗。d、哈希表再极端场景下哈希冲突高，效率下降厉害，需要红黑树补足接力</li></ol> 
</blockquote> 
<hr>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/92564745c0aed8642502d5ad903ec87c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">主板、内存条、硬盘、显卡认识和选购</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0b2e00882a7e1ff632f899dd2b74bc87/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Halcon常用算子汇总</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>