<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>算法之分治法解决平面最近点对问题 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="算法之分治法解决平面最近点对问题" />
<meta property="og:description" content="问题描述：
给定平面上n个点，找其中的一对点，使得在n个点的所有点对中，该点对的距离最小。严格地说，最接近点对可能多于1对。为了简单起见，这里只限于找其中的一对。
思路：
设S中的点为平面上的点，它们都有2个坐标值x和y。为了将平面上点集S线性分割为大小大致相等的2个子集S1和S2，我们选取一垂直线l:x=m来作为分割直线。其中m为S中各点x坐标的中位数。由此将S分割为S1={p∈S|px≤m}和S2={p∈S|px&gt;m}。从而使S1和S2分别位于直线l的左侧和右侧，且S=S1∪S2 。
由于m是S中各点x坐标值的中位数，因此S1和S2中的点数大致相等。递归地在S1和S2上解最接近点对问题，我们分别得到S1和S2中的最小距离d1和d2。现设d=min(d1,d2)。若S的最接近点对(p,q)之间的距离d(p,q)&lt;d则p和q必分属于S1和S2。不妨设p∈S1，q∈S2。那么p和q距直线l的距离均小于d。因此，我们若用P1和P2分别表示直线l的左边和右边的宽为d的2个垂直长条，则p∈S1，q∈S2，如图所示:
P1中所有点与P2中所有点构成的点对均为最接近点对的候选者。在最坏情况下有n2/4对这样的候选者。但是P1和P2中的点具有以下的稀疏性质，它使我们不必检查所有这n^2/4对候选者。考虑P1中任意一点p,它若与P2中的点q构成最接近点对的候选者，则必有d(p,q)&lt;d。满足这个条件的P2中的点一定落在一个d×2d的矩形R中。
因此，若将P1和P2中所有S的点按其y坐标排好序，则对P1中所有点p，对排好序的点列作一次扫描，就可以找出所有最接近点对的候选者，对P1中每一点最多只要检查P2中排好序的相继6个点。
//用类PointX和PointY表示依x坐标和y坐标排好序的点 class PointX { public: int operator&lt;=(PointX a)const { return (x&lt;=a.x); } int ID; //点编号 float x,y; //点坐标 }; class PointY { public: int operator&lt;=(PointY a)const { return(y&lt;=a.y); } int p; //同一点在数组x中的坐标 float x,y; //点坐标 }; #include &lt;cstdlib&gt; #include&lt;time.h&gt; #include&lt;iostream&gt; #include&lt;cmath&gt; #include&lt;stdlib.h&gt; #include&lt;math.h&gt; #include&lt;Quoit_design.h&gt; using namespace std; const int M=50; float Random(); template &lt;class Type&gt; float dis(const Type&amp;u,const Type&amp;v); bool Cpair2(PointX X[], int n,PointX&amp; a,PointX&amp; b, float&amp; d); void closest(PointX X[],PointY Y[],PointY Z[], int l, int r,PointX&amp; a,PointX&amp; b,float&amp; d); template &lt;typename Type&gt; void Copy(Type a[],Type b[], int left,int right); template &lt;class Type&gt; void Merge(Type c[],Type d[],int l,int m,int r); template &lt;class Type&gt; void MergeSort(Type a[],Type b[],int left,int right); int main() { srand((unsigned)time(0)); int length; cout&lt;&lt;&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/fe1b9655c4a500dc8fe532b40df29ba2/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-04-06T16:20:57+08:00" />
<meta property="article:modified_time" content="2020-04-06T16:20:57+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">算法之分治法解决平面最近点对问题</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>问题描述：<br> 给定平面上n个点，找其中的一对点，使得在n个点的所有点对中，该点对的距离最小。严格地说，最接近点对可能多于1对。为了简单起见，这里只限于找其中的一对。</p> 
<p>思路：<br> 设S中的点为平面上的点，它们都有2个坐标值x和y。为了将平面上点集S线性分割为大小大致相等的2个子集S1和S2，我们选取一垂直线l:x=m来作为分割直线。其中m为S中各点x坐标的中位数。由此将S分割为S1={p∈S|px≤m}和S2={p∈S|px&gt;m}。从而使S1和S2分别位于直线l的左侧和右侧，且S=S1∪S2 。<br> 由于m是S中各点x坐标值的中位数，因此S1和S2中的点数大致相等。递归地在S1和S2上解最接近点对问题，我们分别得到S1和S2中的最小距离d1和d2。现设d=min(d1,d2)。若S的最接近点对(p,q)之间的距离d(p,q)&lt;d则p和q必分属于S1和S2。不妨设p∈S1，q∈S2。那么p和q距直线l的距离均小于d。因此，我们若用P1和P2分别表示直线l的左边和右边的宽为d的2个垂直长条，则p∈S1，q∈S2，如图所示:<br> <img src="https://images2.imgbox.com/f7/46/DDceW9OE_o.png" alt="在这里插入图片描述"><br> P1中所有点与P2中所有点构成的点对均为最接近点对的候选者。在最坏情况下有n2/4对这样的候选者。但是P1和P2中的点具有以下的稀疏性质，它使我们不必检查所有这n^2/4对候选者。考虑P1中任意一点p,它若与P2中的点q构成最接近点对的候选者，则必有d(p,q)&lt;d。满足这个条件的P2中的点一定落在一个d×2d的矩形R中。<br> <img src="https://images2.imgbox.com/d4/01/cb5WMyJD_o.png" alt="在这里插入图片描述"><br> 因此，若将P1和P2中所有S的点按其y坐标排好序，则对P1中所有点p，对排好序的点列作一次扫描，就可以找出所有最接近点对的候选者，对P1中每一点最多只要检查P2中排好序的相继6个点。</p> 
<pre><code class="prism language-c++">//用类PointX和PointY表示依x坐标和y坐标排好序的点
class PointX {
	public:
		int operator&lt;=(PointX a)const
		{ return (x&lt;=a.x); }
		int ID; //点编号
		float x,y; //点坐标
};

class PointY {
	public:
		int operator&lt;=(PointY a)const
		{ return(y&lt;=a.y); }
		int p; //同一点在数组x中的坐标
		float x,y; //点坐标
};
#include &lt;cstdlib&gt;
#include&lt;time.h&gt;
#include&lt;iostream&gt;
#include&lt;cmath&gt;
#include&lt;stdlib.h&gt;
#include&lt;math.h&gt;
#include&lt;Quoit_design.h&gt;

using namespace std;
const int M=50;
float Random();
template &lt;class Type&gt;
float dis(const Type&amp;u,const Type&amp;v);
bool Cpair2(PointX X[], int n,PointX&amp; a,PointX&amp; b, float&amp; d);
void closest(PointX X[],PointY Y[],PointY Z[], int l, int r,PointX&amp; a,PointX&amp; b,float&amp; d);
template &lt;typename Type&gt;
void Copy(Type a[],Type b[], int left,int right);
template &lt;class Type&gt;
void Merge(Type c[],Type d[],int l,int m,int r);
template &lt;class Type&gt;
void MergeSort(Type a[],Type b[],int left,int right);
int main()
{
	srand((unsigned)time(0));
	int length;
	cout&lt;&lt;"请输入点对数：";
	cin&gt;&gt;length;

	PointX X[M];
	cout&lt;&lt;"随机生成的二维点对为："&lt;&lt;endl;
	for(int i=0;i&lt;length;i++)
	{
		X[i].ID=i;
		X[i].x=Random();
		X[i].y=Random();
		cout&lt;&lt;"("&lt;&lt;X[i].x&lt;&lt;","&lt;&lt;X[i].y&lt;&lt;") ";
	}

	PointX a;
	PointX b;
	float d;
	Cpair2(X,length,a,b,d);
	cout&lt;&lt;endl;
	cout&lt;&lt;"最邻近点对为：("&lt;&lt;a.x&lt;&lt;","&lt;&lt;a.y&lt;&lt;")和("&lt;&lt;b.x&lt;&lt;","&lt;&lt;b.y&lt;&lt;") "&lt;&lt;endl;
	cout&lt;&lt;"最邻近距离为： "&lt;&lt;d&lt;&lt;endl;
	return 0;
}

float Random()
{
	float result=rand()%10000;
	return result*0.01;
}

//平面上任意两点u和v之间的距离可计算如下
template &lt;class Type&gt;
inline float dis(const Type&amp; u,const Type&amp; v)
{
	float dx=u.x-v.x;
	float dy=u.y-v.y;
	return sqrt(dx*dx+dy*dy);
}

bool Cpair2(PointX X[], int n,PointX&amp; a,PointX&amp; b,float&amp; d)
{
	if(n&lt;2) return false;
	PointX* tmpX = new PointX[n];
	MergeSort(X,tmpX,0,n-1);

	PointY* Y=new PointY[n];
	for(int i=0;i&lt;n;i++) //将数组X中的点复制到数组Y中
	{
		Y[i].p=i;
		Y[i].x=X[i].x;
		Y[i].y=X[i].y;
	}

	PointY* tmpY = new PointY[n];
	MergeSort(Y,tmpY,0,n-1);

	PointY* Z=new PointY[n];
	closest(X,Y,Z,0,n-1,a,b,d);

	delete []Y;
	delete []Z;
	delete []tmpX;
	delete []tmpY;
	return true;
}
void closest(PointX X[],PointY Y[],PointY Z[], int l, int r,PointX&amp; a,PointX&amp; b,float&amp; d)
{
	if(r-l==1) //两点的情形
	{
		a=X[l];
		b=X[r];
		d=dis(X[l],X[r]);
		return;
	}

	if(r-l==2) //3点的情形
	{
		float d1=dis(X[l],X[l+1]);
		float d2=dis(X[l+1],X[r]);
		float d3=dis(X[l],X[r]);

		if(d1&lt;=d2 &amp;&amp; d1&lt;=d3)
		{
			a=X[l];
			b=X[l+1];
			d=d1;
			return;
		}
		if(d2&lt;=d3)
		{
			a=X[l+1];
			b=X[r];
			d=d2;
		}
		else {
			a=X[l];
			b=X[r];
			d=d3;
		}
		return;
	}

	//多于3点的情形，用分治法
	int m=(l+r)/2;
	int f=l,g=m+1;

	//在算法预处理阶段，将数组X中的点依x坐标排序，将数组Y中的点依y坐标排序
	//算法分割阶段，将子数组X[l:r]均匀划分成两个不想交的子集，取m=(l+r)/2
	//X[l:m]和X[m+1:r]就是满足要求的分割。
	for(int i=l;i&lt;=r;i++)
	{
		if(Y[i].p&gt;m) Z[g++]=Y[i];
		else Z[f++]=Y[i];
	}

	closest(X,Z,Y,l,m,a,b,d);
	float dr;
	PointX ar,br;
	closest(X,Z,Y,m+1,r,ar,br,dr);

	if(dr&lt;d)
	{
		a=ar;
		b=br;
		d=dr;
	}

	Merge(Z,Y,l,m,r);//重构数组Y

	//d矩形条内的点置于Z中
	int k=l;
	for(int i=l;i&lt;=r;i++)
	{
		if(fabs(X[m].x-Y[i].x)&lt;d)
		{
			Z[k++]=Y[i];
		}
	}

	//搜索Z[l:k-1]
	for(int i=l;i&lt;k;i++)
	{
		for(int j=i+1;j&lt;k &amp;&amp; Z[j].y-Z[i].y&lt;d;j++)
		{
			float dp=dis(Z[i],Z[j]);
			if(dp&lt;d)
			{
				d=dp;
				a=X[Z[i].p];
				b=X[Z[j].p];
			}
		}
	}
}

template &lt;class Type&gt;
void Merge(Type c[],Type d[],int l,int m,int r)
{
	int i = l,j = m + 1,k = l;
	while((i&lt;=m)&amp;&amp;(j&lt;=r))
	{
		if(c[i]&lt;=c[j])
		{
			d[k++] = c[i++];
		}
		else
		{
			d[k++] = c[j++];
		}
	}

	if(i&gt;m)
	{
		for(int q=j; q&lt;=r; q++)
		{
			d[k++] = c[q];
		}
	}
	else
	{
		for(int q=i; q&lt;=m; q++)
		{
			d[k++] = c[q];
		}
	}
}

template &lt;class Type&gt;
void MergeSort(Type a[],Type b[],int left,int right)
{
	if(left&lt;right)
	{
		int i = (left + right)/2;
		MergeSort(a,b,left,i);
		MergeSort(a,b,i+1,right);
		Merge(a,b,left,i,right);//合并到数组b
		Copy(a,b,left,right);//复制回数组a
	}
}

template &lt;typename Type&gt;
void Copy(Type a[],Type b[], int left,int right)
{
	for(int i=left;i&lt;=right;i++)
		a[i]=b[i];
}
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7776bab59d85e58b01940ed06f4d4839/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">PCL中使用VoxelGrid体素滤波器对点云进行降采样</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/21805504db82944d20e9deff0ce08e12/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">习题 - 数据链路层</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>