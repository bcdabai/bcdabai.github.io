<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>c&#43;&#43;递归，回溯与搜索算法 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="c&#43;&#43;递归，回溯与搜索算法" />
<meta property="og:description" content="这部分题分两个问题：1组合优化问题（顺序无关）。2排列选择问题（一般有个book[]数组记录搜索过没有）
一：回溯法 注意：回溯法是一种完全搜索，有时进行适当的裁剪可以减少好多不必要的搜索步骤！
首先实现的是一个简单版本的回溯！
#include &lt;vector&gt; using namespace std; class Solution { public: vector&lt;vector&lt;int&gt; &gt; subsets(vector&lt;int&gt; &amp;S) { vector&lt;vector&lt;int&gt;&gt; results; vector&lt;int&gt; item; results.push_back(item); generate(0,S,item,results); return results; } private: vector&lt;int&gt; S ; S.push_back(1); S.push_back(2); S.push_back(3); void generate(int i,vector&lt;int&gt;&amp; nums,vector&lt;int&gt; &amp;item,vector&lt;vector&lt;int&gt;&gt;&amp;results) { if( i &gt;nums.size()) //递归结束的条件 return; item.push_back(nums[i]);//依次添加下一个元素 results.push_back(item); //将当前生成的子集添加进results generate(i&#43;1,nums,item,results); //递归执行上边的代码，直到return时进行下边的操作 item.pop_back(); //这里是回溯的关键 generate(i&#43;1,nums,item,results); } };//这里是回溯的关键 generate(i&#43;1,nums,item,results); } }; 升级一下 再次升级：裁剪的例子 二：搜索算法 常用到的搜素算法有基于递归实现的深度优先搜素算法（DFS）和基于队列实现的广度搜素（BFS）；
需要说明：这两种算法和前面的算法没有本质的区别，都是一种完全遍历的算法，因此时间复杂度都先对较高，要想
改进就必须对回溯的过程就行修建，去掉一些不必要的步骤!
特别要注意的是DFS实现全搜索的过程是基于回溯的，回溯的过程是靠标记数组book[ ]来判断的，下边给出一个
简单的例子！
#include &lt;iostream&gt; #include &lt;string." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/1bbb1e01d47fb9d360f3446228e196ea/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-04-09T16:43:11+08:00" />
<meta property="article:modified_time" content="2018-04-09T16:43:11+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">c&#43;&#43;递归，回溯与搜索算法</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>这部分题分两个问题：1组合优化问题（顺序无关）。2排列选择问题（一般有个book[]数组记录搜索过没有）</p> 
<p><img alt="" class="has" src="https://images2.imgbox.com/47/73/C55R4Pmk_o.png"></p> 
<p><img alt="" class="has" src="https://images2.imgbox.com/d3/5e/e9DeLs4p_o.png"></p> 
<h3>一：回溯法</h3> 
<p>  <span style="color:#ff0000;"><strong>    注意：回溯法是一种完全搜索，有时进行适当的裁剪可以减少好多不必要的搜索步骤！</strong></span></p> 
<p><span style="color:#ff0000;"><strong>首先实现的是一个简单版本的回溯！</strong></span></p> 
<pre class="has"><code class="language-cpp">#include &lt;vector&gt;
using namespace std;
class Solution {
public:
    vector&lt;vector&lt;int&gt; &gt; subsets(vector&lt;int&gt; &amp;S) {
        vector&lt;vector&lt;int&gt;&gt; results;
        vector&lt;int&gt; item;
        results.push_back(item);
        generate(0,S,item,results);
        return results;
    }
private:
	vector&lt;int&gt; S ;
	S.push_back(1);
	S.push_back(2);
	S.push_back(3);
	
    void generate(int i,vector&lt;int&gt;&amp; nums,vector&lt;int&gt; &amp;item,vector&lt;vector&lt;int&gt;&gt;&amp;results)
    {
        if( i &gt;nums.size()) //递归结束的条件
            return;
        item.push_back(nums[i]);//依次添加下一个元素
        results.push_back(item); //将当前生成的子集添加进results
        generate(i+1,nums,item,results); //递归执行上边的代码，直到return时进行下边的操作
        item.pop_back(); <span style="color:#ff0000;">//这里是回溯的关键</span>
        generate(i+1,nums,item,results);
    }    
        
};</code><span style="color:#ff0000;">//这里是回溯的关键</span>
        generate(i+1,nums,item,results);
    }    
        
};</pre> 
<p><img alt="" class="has" src="https://images2.imgbox.com/07/3e/zpviA5DP_o.png"></p> 
<h4><img alt="" class="has" height="359" src="https://images2.imgbox.com/a5/ad/ehxfxPQx_o.png" width="864"></h4> 
<h4>升级一下</h4> 
<p> </p> 
<p><img alt="" class="has" src="https://images2.imgbox.com/83/a2/2WrPd3JF_o.png"></p> 
<p><img alt="" class="has" src="https://images2.imgbox.com/03/c3/tQ8jr4tt_o.png"></p> 
<h4> </h4> 
<h4>再次升级：裁剪的例子</h4> 
<p> </p> 
<p><img alt="" class="has" src="https://images2.imgbox.com/7d/ac/n9y7Ypxc_o.png"></p> 
<p> </p> 
<p><img alt="" class="has" src="https://images2.imgbox.com/fd/d5/KGj3yxPY_o.png"></p> 
<p> </p> 
<p><img alt="" class="has" src="https://images2.imgbox.com/62/43/TYGhcaKM_o.png"></p> 
<p><img alt="" class="has" src="https://images2.imgbox.com/93/b1/0aBX2FQH_o.png"></p> 
<h3>二：搜索算法</h3> 
<p>      常用到的搜素算法有基于递归实现的深度优先搜素算法（DFS）和基于队列实现的广度搜素（BFS）；</p> 
<p>      <span style="color:#ff0000;">需要说明</span>：这两种算法和前面的算法没有本质的区别，都是一种完全遍历的算法，因此时间复杂度都先对较高，要想</p> 
<p>      改进就必须对回溯的过程就行修建，去掉一些不必要的步骤!</p> 
<p>     特别要注意的是DFS实现全搜索的过程是基于回溯的，回溯的过程是靠标记数组book[ ]来判断的，下边给出一个</p> 
<p>简单的例子！</p> 
<pre class="has"><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string.h&gt;
using namespace std;
int visit[11],num[11];
int n;

void dfs(int depth)
{
    if(depth&gt;n)//注意是大于号，不是大于等于，因为在等于的时候num[depth]还没有赋值
    {
        for(int j=1;j&lt;=n;j++)
            cout&lt;&lt;num[j]&lt;&lt;" ";
        cout&lt;&lt;endl;
    }
    else
    {
        for(int i=1;i&lt;=n;i++)
        {
            if(!visit[i])//前提该数没有被访问
            {
                visit[i]=1;
                num[depth]=i;
                dfs(depth+1);
                <span style="color:#ff0000;">visit[i]=0;//返回原值，为新的排列做准备</span>
            }
        }
    }
}

int main()
{

    while(cin&gt;&gt;n)
    {
        memset(visit,0,sizeof(visit));
        dfs(1);
    }
}
</code><span style="color:#ff0000;">visit[i]=0;//返回原值，为新的排列做准备</span>
            }
        }
    }
}

int main()
{

    while(cin&gt;&gt;n)
    {
        memset(visit,0,sizeof(visit));
        dfs(1);
    }
}
</pre> 
<p><img alt="" class="has" src="https://images2.imgbox.com/f6/6d/u9b99Vq9_o.png"></p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5da799fbaecc629cbacee9c78034fb22/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【机器学习详解】SVM解二分类,多分类,及后验概率输出</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/101df1f76a88f277111f32f402d9740e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">imp-00003 遇到oracle错误959</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>