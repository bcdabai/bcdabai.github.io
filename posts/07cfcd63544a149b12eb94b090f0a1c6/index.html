<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>深度优先搜索（dfs），宽度优先搜索（bfs），深度优先遍历，宽度优先遍历 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="深度优先搜索（dfs），宽度优先搜索（bfs），深度优先遍历，宽度优先遍历" />
<meta property="og:description" content="图的遍历：我们希望从图中某一顶点出发访遍图中其余顶点，且使每一个顶点仅被访问一次。
通常有两条遍历图的路径（对有向图和无向图都适用）：①深度优先搜索 ；② 广度优先搜索。
一，DFS（深度优先搜索） 深度优先搜索（暴搜）：一条路走到黑
1，树（排列数字为例） 由题可知需按照字典序排列，所以共有 种情况。
如下图所示。
所谓深搜就是一条路走到黑。以上面的排列数字n=3为例，依次从第一层向下，直到三个位置均满之后，再回溯到上一层，再判断是否下一层还有遗漏情况。也符合字典序要求。
注意，为了避免同一顶点被访问多次，每次每层用过了一个点，需要通过辅助数组（初始值置为“假”或“零”）给该点标记一下（值变为“真”或“一”），说明已经用过。此外也需要对排列路径进行一个记录。但是一次深搜之后还需还原现场（即将标记过的点还原），以便于能继续回溯之后的搜索。
代码：
#include &lt;iostream&gt; using namespace std; const int N=8; int path[N],st[N];//path数组存路径，st数组表示访问标志数组。 int n; void dfs(int u) { if(u==n) { for(int i=0;i&lt;n;i&#43;&#43;)cout&lt;&lt;path[i]&lt;&lt;&#39; &#39;; cout&lt;&lt;endl; return ; } for(int i=1;i&lt;=n;i&#43;&#43;) { if(!st[i]) { st[i]=1; path[u]=i; dfs(u&#43;1); st[i]=0; } } } int main() { cin&gt;&gt;n; dfs(0); return 0; } 2，图（n皇后为例）： 图的深度遍历：
无向图深搜：
有向图深搜： 例题：
剪枝：提前判断当前路径是否合法，不合法提前回溯。
n皇后问题就是满足n*n的数组中，放n个皇后，并且这n个皇后不能同一列，同一行，同一对角线，同一反对角线。所以，基于全排列问题，我们再多加上对角线和反对角线即可。那么对角线和反对角线如何处理呢？
如下图所示：
代码：
#include &lt;iostream&gt; using namespace std; const int N=20; char g[N][N];//存图； int col[N],dg[N],udg[N];//col表示列，dg正对角线，udg反对角线； int n; void dfs(int u) { if(u==n) { for(int i=0;i&lt;n;i&#43;&#43;)cout&lt;&lt;g[i]&lt;&lt;endl; cout&lt;&lt;endl; return ; } for(int i=0;i&lt;n;i&#43;&#43;) { if(!" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/07cfcd63544a149b12eb94b090f0a1c6/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-07-09T11:26:15+08:00" />
<meta property="article:modified_time" content="2022-07-09T11:26:15+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">深度优先搜索（dfs），宽度优先搜索（bfs），深度优先遍历，宽度优先遍历</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>图的遍历：我们希望从图中某一顶点出发访遍图中其余顶点，且使每一个顶点仅被访问一次。</p> 
<p>通常有两条遍历图的路径（对有向图和无向图都适用）：①深度优先搜索 ；② 广度优先搜索。</p> 
<h2>一，DFS（深度优先搜索）</h2> 
<p>深度优先搜索（暴搜）：一条路走到黑</p> 
<h4>1，树（排列数字为例）</h4> 
<p style="text-align:center;"><img alt="" class="left" height="514" src="https://images2.imgbox.com/87/85/zP3cPGB0_o.png" width="505"></p> 
<p style="text-align:center;">由题可知需按照字典序排列，所以共有 <img alt="" height="39" src="https://images2.imgbox.com/9a/bf/96G2extu_o.png" width="42">种情况。</p> 
<p> 如下图所示。</p> 
<p style="text-align:center;"><img alt="" class="left" height="200" src="https://images2.imgbox.com/49/46/bragYfoc_o.png" width="597"></p> 
<p> 所谓深搜就是一条路走到黑。以上面的排列数字n=3为例，依次从第一层向下，直到三个位置均满之后，再回溯到上一层，再判断是否下一层还有遗漏情况。也符合字典序要求。</p> 
<p>注意，为了避免同一顶点被访问多次，每次每层用过了一个点，需要通过辅助数组（初始值置为“假”或“零”）给该点标记一下（值变为“真”或“一”），说明已经用过。此外也需要对排列路径进行一个记录。但是一次深搜之后还需还原现场（即将标记过的点还原），以便于能继续回溯之后的搜索。</p> 
<p> 代码：</p> 
<pre><code>#include &lt;iostream&gt;
using namespace std;
const int N=8;
int path[N],st[N];//path数组存路径，st数组表示访问标志数组。
int n;
void dfs(int u)
{
    if(u==n)
    {
        for(int i=0;i&lt;n;i++)cout&lt;&lt;path[i]&lt;&lt;' ';
        cout&lt;&lt;endl;
        return ;
    }
    for(int i=1;i&lt;=n;i++)
    {
    	if(!st[i])
    	{
    		st[i]=1;
    		path[u]=i;
    		dfs(u+1);
    		st[i]=0;
		}
	}
}
int main()
{
    cin&gt;&gt;n;
    dfs(0);
    return 0;
}</code></pre> 
<h4>2，图（n皇后为例）：</h4> 
<p>图的深度遍历：</p> 
<p>无向图深搜：</p> 
<p style="text-align:center;"><img alt="" class="left" height="316" src="https://images2.imgbox.com/9e/9d/mBmMyIj9_o.png" width="349"></p> 
<p>有向图深搜： </p> 
<p style="text-align:center;"><img alt="" class="left" height="282" src="https://images2.imgbox.com/1b/08/9bi9qDPF_o.png" width="347"></p> 
<p></p> 
<p> 例题：</p> 
<p style="text-align:center;"><img alt="" class="left" src="https://images2.imgbox.com/31/34/4xp47Doo_o.png"></p> 
<p>剪枝：提前判断当前路径是否合法，不合法提前回溯。</p> 
<p>n皇后问题就是满足n*n的数组中，放n个皇后，并且这n个皇后不能同一列，同一行，同一对角线，同一反对角线。所以，基于全排列问题，我们再多加上对角线和反对角线即可。那么对角线和反对角线如何处理呢？</p> 
<p>如下图所示：</p> 
<p style="text-align:center;"><img alt="" class="left" height="327" src="https://images2.imgbox.com/2b/90/1RIHNovV_o.png" width="484"></p> 
<p>代码：</p> 
<pre><code>#include &lt;iostream&gt;
using namespace std;
const int N=20;
char g[N][N];//存图； 
int col[N],dg[N],udg[N];//col表示列，dg正对角线，udg反对角线； 
int n;
void dfs(int u)
{
	if(u==n)
	{
		for(int i=0;i&lt;n;i++)cout&lt;&lt;g[i]&lt;&lt;endl;
		cout&lt;&lt;endl;
		return ;
	}
	for(int i=0;i&lt;n;i++)
	{
		if(!col[i]&amp;&amp;!dg[u+i]&amp;&amp;!udg[n-u+i])
		{
			col[i]=1,dg[u+i]=1,udg[n-u+i]=1;
			g[u][i]='Q';
			dfs(u+1);
			col[i]=0,dg[u+i]=0,udg[n-u+i]=0;
			g[u][i]='.';
		}
	}
}
int main()
{
	cin&gt;&gt;n;
	for(int i=0;i&lt;n;i++)
		for(int j=0;j&lt;n;j++)g[i][j]='.';
	dfs(0);
	return 0;
}</code></pre> 
<blockquote> 
 <p>总结：解决回溯问题，实际上就是一个决策树的遍历过程。回溯算法核心就是for循环里面的递归，在递归之前"做选择"，递归之后"撤销选择”。回溯算法就是纯暴力枚举，复杂度一般都很高。</p> 
</blockquote> 
<h3>二，BFS（广度优先搜索）</h3> 
<p>bfs核心算法思想：把一些问题抽象成图，从一个点开始，向四周扩散。</p> 
<p>一般来说bfs算法都是用“队列”这种数据结构，每次将一个节点周围的所有节点加入队列。</p> 
<p>使用队列：与树的层序遍历类似，越是接近根节点越早遍历。</p> 
<p>实质：从起点到终点寻找最短路径。</p> 
<h4> 例题：</h4> 
<h4>1，走迷宫</h4> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/10/3f/pKFGaIhr_o.png"></p> 
<p>分析：寻找从左上到右下的最短路径。</p> 
<p>代码：</p> 
<pre><code>#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;queue&gt;

using namespace std;
typedef pair&lt;int,int&gt;PII;
const int N=110;
queue&lt;PII&gt;q;//存图上某点坐标; 
int g[N][N];//存图;
int d[N][N];//存路径上的距离;
int m,n;
int bfs()
{
	memset(d,-1,sizeof d);
	q.push({0,0});//第一个点为起点并且标记走过;
	d[0][0]=0;
	while(!q.empty())
	{
		auto t=q.front();
		q.pop();
		
		int dx[4]={0,1,0,-1};
		int dy[4]={1,0,-1,0};
		for(int i=0;i&lt;4;i++)
		{
			int x=t.first+dx[i],y=t.second+dy[i];
			if(x&lt;n&amp;&amp;x&gt;=0&amp;&amp;y&lt;m&amp;&amp;y&gt;=0&amp;&amp;g[x][y]==0&amp;&amp;d[x][y]==-1)
			{
				d[x][y]=d[t.first][t.second]+1;
				q.push({x,y});
			}
		}
	} 
	return d[n-1][m-1];
}
int main()
{
	cin&gt;&gt;n&gt;&gt;m;
	for(int i=0;i&lt;n;i++)
	{
		for(int j=0;j&lt;m;j++)
		{
			cin&gt;&gt;g[i][j];
		}
	}
	cout&lt;&lt;bfs();
	return 0;
} </code></pre> 
<h4>2，八数码问题</h4> 
<p style="text-align:center;"><img alt="" class="left" src="https://images2.imgbox.com/d7/63/Qc3MPCSJ_o.png"></p> 
<p> 分析：类似于小时候玩的拼图游戏。</p> 
<p>首先将输入的一串字符（最开始的状态）存入队列，判断这种状态是否符合题目条件（“12345678x”的状态）即可。</p> 
<p>实现该条件存在的问题有：</p> 
<p>①状态表示复杂；</p> 
<p>处理方案：将3*3的二维数组转化为一维数组；</p> 
<p>②记录状态距离困难。</p> 
<p>处理方案：将一维数组作为key值，状态改变次数作为value存入哈希表，每改变一次状态，value加一，直到变成状态”12345678x“，如果到达不了最终状态则返回-1；</p> 
<p>代码：</p> 
<pre><code>#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;unordered_map&gt;
#include &lt;queue&gt;
using namespace std;
int bfs(string s)
{
	queue&lt;string&gt;q;
	unordered_map&lt;string,int&gt;d;
	q.push(s);
	d[s]=0;
	string end="12345678x";
	int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};
	while(!q.empty())
	{
		string t=q.front();
		q.pop();
		
		if(t==end)return d[t];
		int distant=d[t];
		int k=t.find('x');
		int x=k/3,y=k%3;
		for(int i=0;i&lt;4;i++)
		{
			int a=x+dx[i],b=y+dy[i];
			if(a&gt;=0&amp;&amp;a&lt;3&amp;&amp;b&gt;=0&amp;&amp;b&lt;3)
			{	
				
				swap(t[k],t[a*3+b]);
				if(!d.count(t))
				{
					d[t]=distant+1;	
					q.push(t);
				}
			    swap(t[k],t[a*3+b]);
			}
			
		}
	}
	return -1;
}
int main()
{
	string s;
	for(int i=0;i&lt;9;i++)
	{
		char a;
		cin&gt;&gt;a;
		s+=a;
	}
	cout&lt;&lt;bfs(s);
	return 0;
}</code></pre> 
<h2>三，深度优先遍历</h2> 
<p>例题：树的重心</p> 
<p style="text-align:center;"><img alt="" class="left" src="https://images2.imgbox.com/92/dd/FWHucyh9_o.png"></p> 
<p> 题目分析：</p> 
<p style="text-align:center;"><img alt="" class="left" height="327" src="https://images2.imgbox.com/26/7d/VfgX4ee9_o.png" width="546"></p> 
<p> 如图为题目样例，最后结果应该是最小值4 。</p> 
<p>那么我们应该如何处理这道题呢？</p> 
<p>可以利用深搜。我们以删除节点4为例，删除节点4，会生成除了4以外的三个连通子图，分别是以3为根节点的一个子树，以6为根节点的子树以及上面那一块（以1为节点但需要除去以4为根节点的子树）。如图：</p> 
<p style="text-align:center;"><img alt="" class="left" height="250" src="https://images2.imgbox.com/0b/7e/ayX10acq_o.png" width="254"></p> 
<p>我们可以利用深搜算出4下面子树节点数量，至于上面那块，由于深搜是一条路走到黑，不会回头，所以可以利用最大的树节点数量减去已知的子树节点数， 即为上面那块未知节点数量。</p> 
<p>代码：</p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;cstring&gt; 
#include &lt;cstdio&gt;

using namespace std;
const int M=100010;
const int N=2*M;
int st[M],h[M],e[N],ne[N],idx;
int ans=M,n; 
void add(int a,int b)
{
	e[idx]=b,ne[idx]=h[a],h[a]=idx++;
}
int dfs(int u)
{
	st[u]=1;//标记u已遍历；
	int res=0;
	int sum=1;
	for(int i=h[u];i!=-1;i=ne[i])
	{
		int j=e[i];
		if(st[j])continue;
		
		int s=dfs(j);
		res=max(res,s);//求删除u节点时，u节点的下方连通子树中节点的最大值。 
		sum+=s;//包含u节点总子树； 
	}
	res=max(res,n-sum);//上面求得的所有子树中的连通块最大值再跟上方那块比较，求得整棵树的最大连通块最大值。 
	ans=min(ans,res);//寻找删除各个不同节点的情况下最大值中的最小值； 
	return sum;//每次返回子树节点数 
}
int main()
{
	memset(h,-1,sizeof h);
	cin&gt;&gt;n;
	for(int i=0;i&lt;n-1;i++)
	{
	    int a,b;
	    cin&gt;&gt;a&gt;&gt;b;
	    add(a,b);
	    add(b,a);
	}
	dfs(1);
	cout&lt;&lt;ans&lt;&lt;endl;
	return 0;
}</code></pre> 
<h2> 四，宽度优先遍历</h2> 
<p>例题：图中点的层次</p> 
<p><img alt="" class="left" height="625" src="https://images2.imgbox.com/9a/60/f4bwgIk6_o.png" width="621"></p> 
<p> 题目分析：</p> 
<p>n个点m条边的有向图，求出节点1到n的最短距离。</p> 
<p>看到最短距离，应该想到bfs，bfs通常是用队列实现。</p> 
<p>从1开始遍历即可，最后返回n的距离。</p> 
<p>代码：</p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;queue&gt;
#include &lt;cstring&gt;

using namespace std;
const int N=100010;
int e[N],h[N],ne[N],idx,n,m;
int d[N];

void add(int a,int b)
{
    e[idx]=b,ne[idx]=h[a],h[a]=idx++;
}
int bfs()
{
    queue&lt;int&gt;q;
    memset(d,-1,sizeof d);
    d[1]=0;
    q.push(1);
    while(q.size())
    {
        auto t=q.front();
        q.pop();
        for(int i=h[t];i!=-1;i=ne[i])
        {
            int j=e[i];
            if(d[j]==-1)
            {
                d[j]=d[t]+1;
                q.push(j);
            }
        }
    }
    return d[n];
}

int main()
{
    memset(h,-1,sizeof h);
    cin&gt;&gt;n&gt;&gt;m;
    while(m--)
    {
        int a,b;
        cin&gt;&gt;a&gt;&gt;b;
        add(a,b);
    }
    cout&lt;&lt;bfs()&lt;&lt;endl;
    return 0;
}</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/cc6e221a1a0f0d395150a3daa8b485b6/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">火爆全网的Python数据科学手册，太有用了</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/685febd6e08d9fe8208a2bbb1deb9441/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">爬取网页动态加载的评论</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>