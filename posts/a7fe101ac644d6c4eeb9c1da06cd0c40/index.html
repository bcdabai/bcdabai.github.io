<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>OOP面向对象的知识总结 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="OOP面向对象的知识总结" />
<meta property="og:description" content="目录
一、OOP的概念
面向对象思想：
二、方法：
三、对象数组：
四、重载与构造：
五、this static 单例模式：
六、继承：
七、重写与抽象：
八、final与多态：
九、instanceof：判断运算符：
十、接口;
十一、异常：
十二、里氏替换原则：
十三、修饰符：
一、OOP的概念 1.OOP 即面向对象编程: java就是面向对象编程的语言。
世界由万物组成，万物都是对象（世界万物皆为对象）
面向对象思想： 第一步：发现类； 第二步：发现类的属性； 第三步：发现类的方法； 2.对象：客观的存在在这个世界上的每一个事物；
万事万物皆为对象；
3.类：从具有相同属性和方法的多个对象中抽取出来的；
类里面有且仅有属性与方法；(学会把类看做一种数据类型)
4.区别：对象是实实在在存在的具体的概念 ；
类是一个抽象的概念；
5.属性---本身所具备的特征；
方法---会的行为（功能）；
二、方法： 1、方法构造：修饰符 返回类型 方法名（参数）{方法体}
2、属性构造：修饰符 数据类型 变量名
3、方法返回类型：方法按照返回类型可以分为以下两种：
有返回return ： 在方法名前面接一个数据类型 ，且方法体内部最后一行必须接return 而且返回的数据类型必须和前面的数据类型保持一致！ 无返回void ： 在方法体内部不需要接return 在类里面 ，有且仅有“属性”和“方法”（禁止直接接代码） 4、方法传参：实参和形参的参数个数、数据类型、顺序一致
5、局部变量和成员变量：
局部变量没有初始值，而成员变量有 同名时，局部变量具有更高的优先级 作用域：局部变量只能在本方法中使用，成员变量可以在本类的所有方法中使用 同一个方法中，局部变量不允许重名 三、对象数组： 1、学会把类看作是一种数据类型！
2、对象数组三部曲：
定义类 声明并实例化一个对象 初始化（赋值） 3、封装两步：私有化属性 公开方法（可以根据实际情况考虑是否公开读写方法
4、this 这个 指代自己本类" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/a7fe101ac644d6c4eeb9c1da06cd0c40/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-11T21:06:52+08:00" />
<meta property="article:modified_time" content="2024-01-11T21:06:52+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">OOP面向对象的知识总结</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h4 id="%C2%A0"></h4> 
<p></p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%C2%A0-toc" style="margin-left:80px;"></p> 
<p id="-toc" style="margin-left:80px;"></p> 
<p id="%E4%B8%80%E3%80%81OOP%E7%9A%84%E6%A6%82%E5%BF%B5-toc" style="margin-left:80px;"><a href="#%E4%B8%80%E3%80%81OOP%E7%9A%84%E6%A6%82%E5%BF%B5" rel="nofollow">一、OOP的概念</a></p> 
<p id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3%EF%BC%9A" rel="nofollow">                     面向对象思想：</a></p> 
<p id="%E4%BA%8C%E3%80%81%E6%96%B9%E6%B3%95%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%E4%BA%8C%E3%80%81%E6%96%B9%E6%B3%95%EF%BC%9A" rel="nofollow">二、方法：</a></p> 
<p id="%E4%B8%89%E3%80%81%E5%AF%B9%E8%B1%A1%E6%95%B0%E7%BB%84%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%E4%B8%89%E3%80%81%E5%AF%B9%E8%B1%A1%E6%95%B0%E7%BB%84%EF%BC%9A" rel="nofollow">三、对象数组：</a></p> 
<p id="%C2%A0%E5%9B%9B%E3%80%81%E9%87%8D%E8%BD%BD%E4%B8%8E%E6%9E%84%E9%80%A0%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%C2%A0%E5%9B%9B%E3%80%81%E9%87%8D%E8%BD%BD%E4%B8%8E%E6%9E%84%E9%80%A0%EF%BC%9A" rel="nofollow">四、重载与构造：</a></p> 
<p style="margin-left:80px;"><a href="#%C2%A0%20%C2%A0%E4%BA%94%E3%80%81this%20static%20%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%EF%BC%9A" rel="nofollow">         </a><a href="#%C2%A0%20%C2%A0%E4%BA%94%E3%80%81this%20static%20%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%EF%BC%9A" rel="nofollow">五、this static 单例模式：</a></p> 
<p style="margin-left:80px;"> <a href="#%E5%85%AD%E3%80%81%E7%BB%A7%E6%89%BF%EF%BC%9A%E7%88%B6%E7%B1%BB%E4%B8%AD%E5%85%AC%E5%BC%80%E7%9A%84%E6%96%B9%E6%B3%95%E6%88%96%E8%80%85%E5%B1%9E%E6%80%A7%E5%AD%90%E7%B1%BB%E9%83%BD%E5%8F%AF%E4%BB%A5%E6%97%A0%E6%9D%A1%E4%BB%B6%E6%8B%BF%E5%88%B0%EF%BC%88%E7%BB%A7%E6%89%BF%E5%88%B0%EF%BC%89" rel="nofollow">        </a><a href="#%E5%85%AD%E3%80%81%E7%BB%A7%E6%89%BF%EF%BC%9A%E7%88%B6%E7%B1%BB%E4%B8%AD%E5%85%AC%E5%BC%80%E7%9A%84%E6%96%B9%E6%B3%95%E6%88%96%E8%80%85%E5%B1%9E%E6%80%A7%E5%AD%90%E7%B1%BB%E9%83%BD%E5%8F%AF%E4%BB%A5%E6%97%A0%E6%9D%A1%E4%BB%B6%E6%8B%BF%E5%88%B0%EF%BC%88%E7%BB%A7%E6%89%BF%E5%88%B0%EF%BC%89" rel="nofollow">六、继承：</a></p> 
<p id="%E4%B8%83%E3%80%81%E9%87%8D%E5%86%99%E4%B8%8E%E6%8A%BD%E8%B1%A1%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%E4%B8%83%E3%80%81%E9%87%8D%E5%86%99%E4%B8%8E%E6%8A%BD%E8%B1%A1%EF%BC%9A" rel="nofollow">七、重写与抽象：</a></p> 
<p id="%E5%85%AB%E3%80%81final%E4%B8%8E%E5%A4%9A%E6%80%81%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%E5%85%AB%E3%80%81final%E4%B8%8E%E5%A4%9A%E6%80%81%EF%BC%9A" rel="nofollow">八、final与多态：</a></p> 
<p id="%E4%B9%9D%E3%80%81instanceof%EF%BC%9A%E5%88%A4%E6%96%AD%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%E4%B9%9D%E3%80%81instanceof%EF%BC%9A%E5%88%A4%E6%96%AD%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%9A" rel="nofollow">九、instanceof：判断运算符：</a></p> 
<p id="%E5%8D%81%E3%80%81%E6%8E%A5%E5%8F%A3%3B-toc" style="margin-left:80px;"><a href="#%E5%8D%81%E3%80%81%E6%8E%A5%E5%8F%A3%3B" rel="nofollow">十、接口;</a></p> 
<p id="%E5%8D%81%E4%B8%80%E3%80%81%E5%BC%82%E5%B8%B8%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%E5%8D%81%E4%B8%80%E3%80%81%E5%BC%82%E5%B8%B8%EF%BC%9A" rel="nofollow">十一、异常：</a></p> 
<p id="%E5%8D%81%E4%BA%8C%E3%80%81%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%E5%8D%81%E4%BA%8C%E3%80%81%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99%EF%BC%9A" rel="nofollow">十二、里氏替换原则：</a></p> 
<p id="%E5%8D%81%E4%B8%89%E3%80%81%E4%BF%AE%E9%A5%B0%E7%AC%A6%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%E5%8D%81%E4%B8%89%E3%80%81%E4%BF%AE%E9%A5%B0%E7%AC%A6%EF%BC%9A" rel="nofollow">十三、修饰符：</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h4 id="%E4%B8%80%E3%80%81OOP%E7%9A%84%E6%A6%82%E5%BF%B5">一、OOP的概念</h4> 
<p>   <strong>  1.OOP 即面向对象编程: </strong>java就是面向对象编程的语言。<br>         世界由万物组成，万物都是对象（世界万物皆为对象）</p> 
<h4 id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3%EF%BC%9A">                     面向对象思想：</h4> 
<ul><li>             第一步：发现类；</li><li>             第二步：发现类的属性；</li><li>             第三步：发现类的方法；</li></ul> 
<p>    <strong>2.对象：</strong>客观的存在在这个世界上的每一个事物；<br>              万事万物皆为对象；<br>    <strong> 3.类：</strong>从具有相同属性和方法的多个对象中抽取出来的；<br>             类里面有且仅有属性与方法；(学会把类看做一种数据类型)<br>     <strong>4.区别：</strong>对象是实实在在存在的具体的概念 ；<br>             类是一个抽象的概念；<br>    <strong> 5.属性</strong>---本身所具备的特征；<br>        方法---会的行为（功能）；</p> 
<p></p> 
<h4 id="%E4%BA%8C%E3%80%81%E6%96%B9%E6%B3%95%EF%BC%9A">二、方法：</h4> 
<p><strong>1、方法构造：</strong>修饰符 返回类型 方法名（参数）{方法体}<br>     2、属性构造：修饰符 数据类型 变量名<br>     3、方法返回类型：方法按照返回类型可以分为以下两种：</p> 
<ul><li>            有返回return  ： 在方法名前面接一个数据类型 ，且方法体内部最后一行必须接return </li><li>             而且返回的数据类型必须和前面的数据类型保持一致！</li><li>            无返回void  ： 在方法体内部不需要接return </li><li>            在类里面 ，有且仅有“属性”和“方法”（禁止直接接代码）</li></ul> 
<p>    <strong>4、方法传参：</strong>实参和形参的参数个数、数据类型、顺序一致<br>     5、局部变量和成员变量：</p> 
<ul><li>    局部变量没有初始值，而成员变量有</li><li>    同名时，局部变量具有更高的优先级</li><li>    作用域：局部变量只能在本方法中使用，成员变量可以在本类的所有方法中使用</li><li>    同一个方法中，局部变量不允许重名</li></ul> 
<h4 id="%E4%B8%89%E3%80%81%E5%AF%B9%E8%B1%A1%E6%95%B0%E7%BB%84%EF%BC%9A">三、对象数组：</h4> 
<p>   1、学会把类看作是一种数据类型！<br>    2、对象数组三部曲：</p> 
<ul><li>        定义类</li><li>        声明并实例化一个对象</li><li>        初始化（赋值）</li></ul> 
<p>    3、封装两步：私有化属性 公开方法（可以根据实际情况考虑是否公开读写方法<br>     4、this 这个 指代自己本类</p> 
<h4 id="%C2%A0%E5%9B%9B%E3%80%81%E9%87%8D%E8%BD%BD%E4%B8%8E%E6%9E%84%E9%80%A0%EF%BC%9A"><br>  四、重载与构造：</h4> 
<p><strong>1、方法的重载 ：</strong>同名不同参（参数类型 、个数以及顺序不一致）<br>                   <strong> 构造函数</strong></p> 
<ul><li>    方法名必须跟类名相同</li><li>    没有返回类型 ，也不需要void</li><li>    根据实际情况决定参数个数</li><li>    在对象被实例化的时候被自动调用 ，不能手动用对象名去点</li><li>    可以有多个（重载）</li><li>    所有的类都自带一个无参的构造方法 ，一旦自定义了一个构造函数，系统自带的无参的就没有了</li></ul> 
<h4 id="%C2%A0%20%C2%A0%E4%BA%94%E3%80%81this%20static%20%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%EF%BC%9A">   五、this static 单例模式：</h4> 
<p> <strong> 1、this 这个 指代自己本类；</strong></p> 
<ul><li>       构造函数链:  将所有对象的实例化全部归结到一个方法中        </li><li>       用this可以在构造函数内部调用其他的构造函数 ,但是它只能放在方法体的第一行；</li></ul> 
<p><strong>    2、static</strong></p> 
<ul><li>    非静态的只能用对象名调用, 静态的既能用对象名来调用,</li><li>           又能用类名来调用</li><li>    静态的方法内部只能调用静态的 ,非静态的方法内部都能调用</li><li>    静态的在对象中是共享的,只占用一份内存空间</li><li>        代码块：分为静态代码块和非静态代码块，静态的只占有一份空间，都是在对象被实例化的时候自动调用 先静后非静</li></ul> 
<p><strong>    3、单例模式：</strong></p> 
<ul><li>       该类只能被实例化一次(设计模式)；</li></ul> 
<h4 id="%E5%85%AD%E3%80%81%E7%BB%A7%E6%89%BF%EF%BC%9A%E7%88%B6%E7%B1%BB%E4%B8%AD%E5%85%AC%E5%BC%80%E7%9A%84%E6%96%B9%E6%B3%95%E6%88%96%E8%80%85%E5%B1%9E%E6%80%A7%E5%AD%90%E7%B1%BB%E9%83%BD%E5%8F%AF%E4%BB%A5%E6%97%A0%E6%9D%A1%E4%BB%B6%E6%8B%BF%E5%88%B0%EF%BC%88%E7%BB%A7%E6%89%BF%E5%88%B0%EF%BC%89">六、继承：</h4> 
<ul><li>        父类中公开的方法或者属性子类都可以无条件拿到（继承到）</li></ul> 
<p><strong>1、继承的好处：</strong></p> 
<ul><li>       少写一些共有的代码</li><li>       提供另外一种形式的分类</li><li>       代码重用</li></ul> 
<p>   <strong> 2、语法：</strong></p> 
<ul><li>       子类 extends 父类</li></ul> 
<p> <strong>   3、super用法：</strong></p> 
<ul><li>       super.属性可以显示调用父类属性；</li><li>       super.方法可以显示调用父类方法；</li></ul> 
<p><strong>    4、子类可以直接拿到父类的公有的</strong></p> 
<ul><li>       但是父类不能拿子类的</li><li>       继承的单方向</li><li>       一个类只允许有一个父类</li><li>       继承也是单继承</li></ul> 
<p>   <strong> 5、子类在实例化的时候 会先调用父类的构造函数</strong><br>    </p> 
<h4 id="%E4%B8%83%E3%80%81%E9%87%8D%E5%86%99%E4%B8%8E%E6%8A%BD%E8%B1%A1%EF%BC%9A">七、重写与抽象：</h4> 
<p><strong>1、重写：</strong></p> 
<ul><li>      子类对于父类的不满意，可以补充，则直接重写父类的方法。</li><li>      删除重写中的super.方法();就是全部推翻父类写法。</li><li>       注意：子类的方法的名字、返回值、参数必须要与父类保持一致</li><li>      修饰符只能比父类的要高或者相等</li><li>       重写的方法是否可以重载？可以</li></ul> 
<p>  <strong>  2、抽象：</strong></p> 
<ul><li>    抽象类:不能被实例化 但是可以作为其他类的父类</li><li>    抽象方法: * 没有方法体；</li><li>                  必须在子类中实现（重写），除非子类也是一个抽象类；</li><li>                  抽象方法必须在抽象类中</li></ul> 
<h4 id="%E5%85%AB%E3%80%81final%E4%B8%8E%E5%A4%9A%E6%80%81%EF%BC%9A">八、final与多态：</h4> 
<p>    <strong>1、多态：</strong>同样一种行为，在不同的对象中（不同的环境下）会产生不同的形态【关键在于将父类作为形参】<br>    <strong> 2、final：</strong></p> 
<ul><li>    放在类前面，则该类不能被继承</li><li>    放在方法前面，则该方法不能在子类中被重写</li><li>    放在属性（变量）前面，则为常量，必须有初始值且不能被修改</li></ul> 
<h4 id="%E4%B9%9D%E3%80%81instanceof%EF%BC%9A%E5%88%A4%E6%96%AD%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%9A">九、instanceof：判断运算符：</h4> 
<p>左边是对象，右边是类；当对象是右边类或子类所创建对象时，返回true；否则，返回false</p> 
<h4 id="%E5%8D%81%E3%80%81%E6%8E%A5%E5%8F%A3%3B">十、接口;</h4> 
<p>  <strong>1、接口表示的其实是一种能力</strong></p> 
<ul><li>       对象是对现实世界物体的抽象</li><li>       类是对对象的抽象</li><li>       接口是对类的抽象</li></ul> 
<p> <strong>   2、语法：public interface 接口名</strong></p> 
<ul><li>       如果一个类要实现这些功能：</li><li>       语法是 public class 类名 implements 接口名1,接口名2...</li></ul> 
<p> <strong>   3、接口与抽象类的区别：</strong></p> 
<ul><li>     抽象类是类所以只能单继承，而接口（interface）可以多实现</li><li>     抽象类继承用extends，而接口用implements</li><li>     抽象类可以有构造，接口不能</li><li>     抽象类可以有一般的属性，接口中的属性只能是静态常量</li><li>     抽象类中可以有抽象方法，也可以有一般的方法，而接口中只能有抽象方法</li><li>     抽象类中抽象方法可以被除private以外的修饰符修饰，但是接口中只能是public</li></ul> 
<p><strong>     4、常量一定是全大写</strong></p> 
<h4 id="%E5%8D%81%E4%B8%80%E3%80%81%E5%BC%82%E5%B8%B8%EF%BC%9A">十一、异常：</h4> 
<p><strong>1、异常：</strong>就是在程序中有可能发生的问题。<br>       2、语法是：try{//监视<br>        有可能出现问题的代码<br>     }catch(异常的类型 异常信息所封装成的对象){<!-- --><br>        处理异常的代码    <br>     }finally{<!-- --><br>        最后会被执行的代码（有无异常都会被执行）<br>     }<br>       3、自定义异常 throws<br>       4、抛出异常throw</p> 
<h4 id="%E5%8D%81%E4%BA%8C%E3%80%81%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99%EF%BC%9A">十二、里氏替换原则：</h4> 
<p>用子类实例化的对象来覆盖父类(父接口)声明的对象 Pet p = new Dog();</p> 
<h4 id="%E5%8D%81%E4%B8%89%E3%80%81%E4%BF%AE%E9%A5%B0%E7%AC%A6%EF%BC%9A">十三、修饰符：</h4> 
<ul><li>      private：私有化，最小气的，只能在自己的类中访问；</li><li>      friendly：默认，友好的，只能在自己的类中、同包的类中访问；</li><li>      protected：受保护的，只能在自己的类、同包的类、子类中访问；</li><li>      public：公共的，最大方的，当前项目中所有的类都可以访问。</li></ul> 
<p><br>      </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/60379e6f1df1748bda495990bee9404f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">python如何重复执行代码</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8a58ba36517fb239a27999c75710b4fc/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Python为什么这么牛？Python真有这么好的前景？</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>