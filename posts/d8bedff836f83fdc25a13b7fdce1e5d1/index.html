<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>递归、回溯和DFS的区别 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="递归、回溯和DFS的区别" />
<meta property="og:description" content="递归是一种算法结构，回溯是一种算法思想。一个递归就是在函数中调用函数本身来解决问题。回溯就是通过不同的尝试来生成问题的解，有点类似于穷举，但是和穷举不同的是回溯会“剪枝”。 剪枝的意思也就是说对已经知道错误的结果没必要再枚举接下来的答案了，比如一个有序数列1,2,3,4,5，我要找和为5的所有集合，从前往后搜索我选了1，然后2，然后选3的时候发现和已经大于预期，那么4,5肯定也不行，这就是一种对搜索过程的优化。
回溯搜索是深度优先搜索（DFS）的一种。对于某一个搜索树来说（搜索树是起记录路径和状态判断的作用），回溯和DFS，其主要的区别是，回溯法在求解过程中不保留完整的树结构，而深度优先搜索则记下完整的搜索树。
为了减少存储空间，在深度优先搜索中，用标志的方法记录访问过的状态，这种处理方法使得深度优先搜索法与回溯法没什么区别了。
递归的一般结构：
void f() { if(符合边界条件) { /////// return; } //某种形式的调用 f(); } 回溯的一般结构：
void DFS(int 当前状态) { if(当前状态为边界状态) { 记录或输出 return; } for(i=0;i&lt;n;i&#43;&#43;) //横向遍历解答树所有子节点 { //扩展出一个子状态。 修改了全局变量 if(子状态满足约束条件) { dfs(子状态) } 恢复全局变量//回溯部分 } } BFS和DFS相似。BFS显式用队列，DFS隐式用栈，即递归。 当然，对于DFS，用递归可能会造成栈溢出，所以也可以更改为显示栈。
以下以走迷宫问题为力，做一下说明：
*表示可走 #表示障碍 T表示出口 入口是(1,1)，数据保证左上角是入口。
#include&lt;iostream&gt; using namespace std; char maze[100][100]; bool flag[100][100]; int dx[]={0,0,1,-1}; int dy[]={1,-1,0,0}; int m,n; bool dfs(int x,int y) { flag[x][y]=1; //走过的路标记为1 if(maze[x][y]==&#39;T&#39;)return true; for(int i=0;i&lt;4;i&#43;&#43;) //四个方向 { int nx=x&#43;dx[i]; int ny=y&#43;dy[i]; if(flag[nx][ny]==0||maze[nx][ny]==&#39;*&#39;||maze[nx][ny]==&#39;T&#39;&amp;&amp;nx&gt;0&amp;&amp;ny&gt;0&amp;&amp;nx&lt;m&#43;1&amp;&amp;ny&lt;n&#43;1) { return dfs(nx,ny); flag[nx][ny]=0; //回溯，将标记重新标记为0 } } return false; //找不到返回false } int main() { while(cin&gt;&gt;m&gt;&gt;n){ memset(maze,0,sizeof(maze)); memset(flag,0,sizeof(flag)); for(int i=1;i&lt;=m;i&#43;&#43;) for(int j=1;j&lt;=n;j&#43;&#43;) cin&gt;&gt;maze[i][j]; if(dfs(1,1))cout&lt;&lt;&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/d8bedff836f83fdc25a13b7fdce1e5d1/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-04-25T22:37:29+08:00" />
<meta property="article:modified_time" content="2018-04-25T22:37:29+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">递归、回溯和DFS的区别</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <ul><li>递归是一种算法结构，回溯是一种算法思想。</li><li>一个递归就是在函数中调用函数本身来解决问题。</li><li>回溯就是通过不同的尝试来生成问题的解，有点类似于穷举，但是和穷举不同的是回溯会“剪枝”。</li></ul> 
<p>剪枝的意思也就是说对已经知道错误的结果没必要再枚举接下来的答案了，比如一个有序数列1,2,3,4,5，我要找和为5的所有集合，从前往后搜索我选了1，然后2，然后选3的时候发现和已经大于预期，那么4,5肯定也不行，这就是一种对搜索过程的优化。</p> 
<p>回溯搜索是深度优先搜索（DFS）的一种。对于某一个搜索树来说（搜索树是起记录路径和状态判断的作用），回溯和DFS，其主要的区别是，回溯法在求解过程中不保留完整的树结构，而深度优先搜索则记下完整的搜索树。</p> 
<p>为了减少存储空间，在深度优先搜索中，用标志的方法记录访问过的状态，这种处理方法使得深度优先搜索法与回溯法没什么区别了。</p> 
<p>递归的一般结构：</p> 
<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword">void</span> f()  
{  
     <span class="hljs-keyword">if</span>(符合边界条件)  
     {  
        <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span><span class="hljs-xmlDocTag">///</span>/  </span>
        <span class="hljs-keyword">return</span>;  
     }  

     <span class="hljs-comment">//某种形式的调用  </span>
     f();  
}  </code></pre> 
<p>回溯的一般结构：</p> 
<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword">void</span> DFS(<span class="hljs-keyword">int</span> 当前状态)  
{  
      <span class="hljs-keyword">if</span>(当前状态为边界状态)  
      {  
        记录或输出  
        <span class="hljs-keyword">return</span>;  
      }  
      <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n;i++)       <span class="hljs-comment">//横向遍历解答树所有子节点  </span>
      {  
           <span class="hljs-comment">//扩展出一个子状态。  </span>
           修改了全局变量  
           <span class="hljs-keyword">if</span>(子状态满足约束条件)  
            {  
              dfs(子状态)  
           }  
            恢复全局变量<span class="hljs-comment">//回溯部分  </span>
      }  
}  </code></pre> 
<p>BFS和DFS相似。BFS显式用队列，DFS隐式用栈，即递归。 <br> 当然，对于DFS，用递归可能会造成栈溢出，所以也可以更改为显示栈。</p> 
<p>以下以走迷宫问题为力，做一下说明：</p> 
<p>*表示可走 <br> #表示障碍 <br> T表示出口 <br> 入口是(1,1)，数据保证左上角是入口。</p> 
<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-preprocessor">#include&lt;iostream&gt;</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;

<span class="hljs-keyword">char</span> maze[<span class="hljs-number">100</span>][<span class="hljs-number">100</span>];
<span class="hljs-keyword">bool</span> flag[<span class="hljs-number">100</span>][<span class="hljs-number">100</span>];
<span class="hljs-keyword">int</span> dx[]={<!-- --><span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>};
<span class="hljs-keyword">int</span> dy[]={<!-- --><span class="hljs-number">1</span>,-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>};
<span class="hljs-keyword">int</span> m,n;

<span class="hljs-keyword">bool</span> dfs(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)
{
    flag[x][y]=<span class="hljs-number">1</span>;              <span class="hljs-comment">//走过的路标记为1</span>
    <span class="hljs-keyword">if</span>(maze[x][y]==<span class="hljs-string">'T'</span>)<span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)       <span class="hljs-comment">//四个方向</span>
    {
        <span class="hljs-keyword">int</span> nx=x+dx[i];
        <span class="hljs-keyword">int</span> ny=y+dy[i];
        <span class="hljs-keyword">if</span>(flag[nx][ny]==<span class="hljs-number">0</span>||maze[nx][ny]==<span class="hljs-string">'*'</span>||maze[nx][ny]==<span class="hljs-string">'T'</span>&amp;&amp;nx&gt;<span class="hljs-number">0</span>&amp;&amp;ny&gt;<span class="hljs-number">0</span>&amp;&amp;nx&lt;m+<span class="hljs-number">1</span>&amp;&amp;ny&lt;n+<span class="hljs-number">1</span>)
        {
            <span class="hljs-keyword">return</span> dfs(nx,ny);   
            flag[nx][ny]=<span class="hljs-number">0</span>;    <span class="hljs-comment">//回溯，将标记重新标记为0</span>
        }
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;             <span class="hljs-comment">//找不到返回false</span>
}

<span class="hljs-keyword">int</span> main()
{

    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">cin</span>&gt;&gt;m&gt;&gt;n){
    <span class="hljs-built_in">memset</span>(maze,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(maze));
    <span class="hljs-built_in">memset</span>(flag,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(flag));
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)
            <span class="hljs-built_in">cin</span>&gt;&gt;maze[i][j];
    <span class="hljs-keyword">if</span>(dfs(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>))<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"YES"</span>&lt;&lt;endl;
    <span class="hljs-keyword">else</span> <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"NO"</span>&lt;&lt;endl;
    }
}</code></pre> 
<p>参考文献：<a href="https://www.cnblogs.com/smuxiaolei/p/7505391.html" rel="nofollow">递归，回溯和DFS的区别</a>；<a href="https://blog.csdn.net/u013497977/article/details/41879543">迷宫问题</a>；<a href="https://blog.csdn.net/fightforyourdream/article/details/12866861">递归，回溯，DFS，BFS的理解和模板</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8c9d2967f380bddf2407ae02b99384da/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Koa2 源码学习(上)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e035b0256f07a7285be1eee6f874efaa/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">在 Matlab 中如何输入希腊字母等特殊字符</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>