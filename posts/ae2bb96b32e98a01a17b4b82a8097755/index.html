<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Inno Setup 制作安装包中一些常用的知识点 新手教程 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Inno Setup 制作安装包中一些常用的知识点 新手教程" />
<meta property="og:description" content="1、Inno Setup 是什么？ Inno Setup 是一个免费的 Windows 安装程序制作软件。第一次发表是在 1997 年，Inno Setup 今天在功能设置和稳定性上的竞争力可能已经超过一些商业的安装程序制作软件。
Inno Setup 关键功能: ★ 支持现在所有正在使用的 32 位 Windows 版本: Windows 95，98，2000，Server 2003，XP，Me，NT 4.0 (不需要服务包)。
★ 支持创建单个 EXE 格式的安装程序，使你的程序可以很方便地在网络上发表。同时也支持磁盘延伸。
★ 标准的 Windows 2000/XP 样式向导界面。
★ 定制安装类型，例如：完整安装，最小安装，自定义安装。
★ 完整的卸载功能。
★ 文件安装：包括完全的“压缩”支持，bzip2 和 7-Zip LZMA 文件压缩。安装程序可以比较文件版本信息，替换正在使用的文件，使用共享文件计数，注册 DLL/OCX 和类型库，以及安装字体。
★ 可以在任意地方创快捷方式建，包括开始菜单和桌面。
★ 创建注册表和 .INI 项目。
★ 完整的 Pascal 脚本引擎。
★ 支持 multilingualLanguagessection 安装。
★ 支持密码和加密安装。
★ 后台安装和后台卸载。
★ 全部源代码公开 (Borland Delphi 2." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/ae2bb96b32e98a01a17b4b82a8097755/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-07-25T08:09:48+08:00" />
<meta property="article:modified_time" content="2023-07-25T08:09:48+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Inno Setup 制作安装包中一些常用的知识点 新手教程</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>1、Inno Setup 是什么？</h3> 
<p></p> 
<p>Inno Setup 是一个免费的 Windows 安装程序制作软件。第一次发表是在 1997 年，Inno Setup 今天在功能设置和稳定性上的竞争力可能已经超过一些商业的安装程序制作软件。</p> 
<h3>Inno Setup 关键功能:</h3> 
<p></p> 
<p>★ 支持现在所有正在使用的 32 位 Windows 版本: Windows 95，98，2000，Server 2003，XP，Me，NT 4.0 (不需要服务包)。<br> ★ 支持创建单个 EXE 格式的安装程序，使你的程序可以很方便地在网络上发表。同时也支持磁盘延伸。<br> ★ 标准的 Windows 2000/XP 样式向导界面。<br> ★ 定制安装类型，例如：完整安装，最小安装，自定义安装。<br> ★ 完整的卸载功能。<br> ★ 文件安装：包括完全的“压缩”支持，bzip2 和 7-Zip LZMA 文件压缩。安装程序可以比较文件版本信息，替换正在使用的文件，使用共享文件计数，注册 DLL/OCX 和类型库，以及安装字体。<br> ★ 可以在任意地方创快捷方式建，包括开始菜单和桌面。<br> ★ 创建注册表和 .INI 项目。<br> ★ 完整的 Pascal 脚本引擎。<br> ★ 支持 multilingualLanguagessection 安装。<br> ★ 支持密码和加密安装。<br> ★ 后台安装和后台卸载。<br> ★ 全部源代码公开 (Borland Delphi 2.0-5.0)。</p> 
<h3>第二部分 怎么使用</h3> 
<p></p> 
<p><strong>1、创建安装程序</strong><br> 安装程序用编译脚本的方式创建，脚本其实就是一个类似 .INI 文件格式的 ASCII 码文本文件。 (它不象你想象的那么复杂!)</p> 
<p>脚本用一个“.iss” (表示 Inno Setup Script) 的扩展名。脚本控制着安装程序的所有方面。由它指定哪些文件将被安装到什么地方，在哪里创建快捷方式，且被命名为什么。</p> 
<p>脚本文件一般可以用安装程序编译器程序内置的编辑器进行编辑。在你编写完脚本后，下一个最终步骤就是选择安装程序编译器中的“编译”。创建完成后，就可以运行根据你脚本编译的安装程序了。按默认，这个安装程序创建在包含脚本文件目录下的名为“输出”目录中。</p> 
<p>如果你想看看它是怎样工作的，启动安装程序编译器，单击“文件 | 打开”，并选择位于 Inno Setup 安装目录下的 Samples 子目录中的一个脚本文件。(你也可以将这些示例脚本作为你自己编写脚本的模板。)</p> 
<p><strong>2、脚本格式概述</strong></p> 
<p>Inno Setup 准备了一些段。每个段控制一个不同方面的安装程序部分。每个段用包含在括号 [] 中的段名开始，每个段里面是一些相关的条目。</p> 
<p>其中有两种不能类型的段: 有些就象 [Setup] 段，条目包含指示名和值 (格式为 Directive=Value)，还有一些就象 [Files] 段，条目被参数分隔。</p> 
<p>这里是一个例子:</p> 
<pre></pre> 
<table cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1<br> 2<br> 3<br> 4</p> </td><td> <p>[Setup]<br> AppName=My Program<br> [Files]<br> Source: "MYPROG.EXE"; DestDir: "{app}"</p> </td></tr></tbody></table> 
<p>注意，在脚本中指定多个相同名字的段是合法的。</p> 
<p>你可以通过在行起始位置加个分号“;”在脚本中写入“注释” (编译时被编译时忽略)。</p> 
<p>例如:<br> ; 这是一条注释，放在这里只是要提醒我自己…</p> 
<p>支持 A C-like #include 指示，从个别文件放入行到 #include 指示位置的脚本。</p> 
<p>语法是:</p> 
<p>#include “filename.txt”</p> 
<p>如果文件名中未提供完整的路径，编译将在包含 #include 指示的同一目录中查找。文件名用“compiler:”作为前缀的场合中，在编译器目录中查找文件。</p> 
<p><strong>3、段中参数</strong></p> 
<p>所有脚本中的段，除 [Setup]、[Messages]、[CustomMessages] 和 [LangOptions] 段，包含的行中可有多个各自的参数。下列是 [Files] 段中的一个举例:</p> 
<pre></pre> 
<table cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1<br> 2<br> 3<br> 4</p> </td><td> <p>[Files]<br> Source: "MYPROG.EXE"; DestDir: "{app}"<br> Source: "MYPROG.HLP"; DestDir: "{app}"<br> Source: "README.TXT"; DestDir: "{app}"; Flags: isreadme</p> </td></tr></tbody></table> 
<p>每个参数都由一个名字组成，然后跟随一个冒号，然后是一个值。除非另外说明，如果参数未指定，将设定为一个默认值。一行中多个参数用分号隔开，并且可以以任何次序列出。</p> 
<p>参数的值如果包含一个用户定义的字符串时，一般来说用双引号 (“) 包含，例如象文件名。引号使用不是必需的，但这样做可能会在值中的首位或末位被加入空格，以及分号和双引号。</p> 
<p>在要引用的值中使用一个双引号字符，用两个连续的双引号字符，例如:</p> 
<p>“This “” contains “” embedded “” quotes”</p> 
<p>安装程序编译器会将它视作:</p> 
<p>This ” contains ” embedded ” quotes</p> 
<p>如果你希望参数值是一个单个双引号字符，用四个双引号字符: “”””。外面的两个用于包含引用的字符；内部两个写入单个的双引号字符。</p> 
<p><strong>4、常量</strong></p> 
<p>脚本中的项目大部分可以嵌入常量。这些预定义的字符被包含在括弧 { } 中。安装程序或卸载程序会根据用户选择和系统配置将这些常量翻译为文字值。例如，{win} 在大部分系统中会被翻译为“C:\WINDOWS”。<br> 字符“{”视作为常量开始。如果你想将它作为实际字符使用，你必须使用两个连续的“{”字符。(对于“}”则不需要。)</p> 
<p>当 在常量后面直接跟随一个反斜杠时，如果常量的值末端已经包含了一个反斜杠号，安装程序或卸载程序将自动删除该反斜杠号。 因此，如果一个特殊常量值是“C:\”，{constantname}\file 将翻译为“C:\file”，而不是“C:\\file”。如果你想防止意外，将反斜框放入 { } 字符中，例如，{app}{\}。</p> 
<p>下面是支持的常量列表。</p> 
<p>目录常量</p> 
<pre></pre> 
<table cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> </td><td> <p>{app}</p> </td></tr></tbody></table> 
<p>用户在安装向导中的选择目标位置页中选定的应用程序目录。</p> 
<p>例如: 如果你在项目中指定了 {app}\MYPROG.EXE，用户选择了“C:\MYPROG”作为应用程序目录，安装程序将该文件安装到“C:\MYPROG\MYPROG.EXE”。</p> 
<pre></pre> 
<table cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> </td><td> <p>{win}</p> </td></tr></tbody></table> 
<p>系统的 Windows 目录。</p> 
<p>例如: 如果你在条目中使用了 {win}\MYPROG.INI，且系统的 Windows 目录是“C:\WINDOWS”安装程序或卸载程序将它传送到“C:\WINDOWS\MYPROG.INI”。</p> 
<pre></pre> 
<table cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> </td><td> <p>{sys}</p> </td></tr></tbody></table> 
<p>系统的 Windows System 目录 (在 NT 平台上是 System32)。</p> 
<p>例如: 如果你在条目中使用了 {sys}\CTL3D32.DLL，且系统的 Windows System 目录是“C:\WINDOWS\SYSTEM”，安装程序或卸载程序将它传送到“C:\WINDOWS\SYSTEM\CTL3D32.DLL”。</p> 
<pre></pre> 
<table cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> </td><td> <p>{src}</p> </td></tr></tbody></table> 
<p>安装程序文件所在目录。</p> 
<p>例如: 你在条目中使用了 {src}\MYPROG.EXE，且用户正在从“S:\”进行安装，安装程序将它传送到“S:\MYPROG.EXE”。</p> 
<pre></pre> 
<table cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> </td><td> <p>{sd}</p> </td></tr></tbody></table> 
<p>Windows 系统所在的驱动器。一般来说是“C:”。在 Windows NT 平台，这个目录常量等同于 SystemDrive 环境变量。</p> 
<pre></pre> 
<table cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> </td><td> <p>{pf}</p> </td></tr></tbody></table> 
<p>程序文件位置。系统的 Program Files 目录的路径，一般来说是“C:\Program Files”。</p> 
<pre></pre> 
<table cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> </td><td> <p>{cf}</p> </td></tr></tbody></table> 
<p>公共文件目录。系统的 Common Files 目录路径，一般来说是“C:\Program Files\Common Files”。</p> 
<pre></pre> 
<table cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> </td><td> <p>{tmp}</p> </td></tr></tbody></table> 
<p>用 于安装程序或卸载程序的临时目录。这不是用户的 TEMP 环境变量值。它是在安装程序启动后在用户临时目录中创建的子目录 (象名为“C:\WINDOWS\TEMP\IS-xxxxx.tmp”)。目录中的所有文件和子目录在安装程序或卸载程序退出时删除。在安装时，这主要 用于提取在 [Run] 段运行、但安装后不再需要的文件。</p> 
<pre></pre> 
<table cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> </td><td> <p>{fonts}</p> </td></tr></tbody></table> 
<p>字体目录。通常是在 Windows 下面的名字“FONTS”的目录。</p> 
<pre></pre> 
<table cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> </td><td> <p>{dao}</p> </td></tr></tbody></table> 
<p>DAO 目录，等同于 {cf}\Microsoft Shared\DAO。</p> 
<p>外壳文件夹常量</p> 
<p>Inno Setup 支持其它目录常量设置，作为外壳文件夹常量引用。它们可以与其它目录常量相同方法使用。</p> 
<p>下面的“user”常量引用到当前登录的用户配置文件，“common”常量引用到所有用户配置文件。</p> 
<p>除非有另外的注释，外壳文件夹常量工作于 Inno Setup 支持的所有 Windows 版本，包括 Windows 95 和 NT 4.0。</p> 
<p>* = 如果登录的用户缺少管理员权限，或操作系统是 Windwos 95/98/Me，“common”结构映射到“user”结构。</p> 
<pre></pre> 
<table cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> </td><td> <p>{group}</p> </td></tr></tbody></table> 
<p>开始菜单文件夹路径，由用户在安装程序的选择开始菜单文件夹向导页中选定。在 Windows NT/2000/XP，这个文件夹总是创建在所有用户配置文件下，除非非用户安装程序的用户没有管理员权限，这种情况下它将创建在用户配置文件下。</p> 
<pre></pre> 
<table cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> </td><td> <p>{localappdata}</p> </td></tr></tbody></table> 
<p>本地应用程序数据文件夹。</p> 
<pre></pre> 
<table cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> </td><td> <p>{sendto}</p> </td></tr></tbody></table> 
<p>当前用户的 Send To 文件夹路径。(这里不是指公共 Send To 文件夹。)</p> 
<pre></pre> 
<table cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> </td><td> <p>{userappdata} 和 {commonappdata}</p> </td></tr></tbody></table> 
<p>应用程序数据文件夹路径。</p> 
<pre></pre> 
<table cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> </td><td> <p>{userdesktop} 和 {commondesktop} *</p> </td></tr></tbody></table> 
<p>桌面文件夹路径。</p> 
<pre></pre> 
<table cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> </td><td> <p>{userdocs} 和 {commondocs} *</p> </td></tr></tbody></table> 
<p>我的文档 (My Documents) 文件夹路径 (在 NT 4.0，私人文件夹)。</p> 
<pre></pre> 
<table cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> </td><td> <p>{userfavorites} 和 {commonfavorites} *</p> </td></tr></tbody></table> 
<p>收 藏夹文件夹路径。这些常量设置必须 至少“4.1, 4” MinVersion 设置。只在 Windows 2000 和更高版本支持 {commonfavorites}；如果在先前的 Windows 版本中使用，它将翻译为等同于 {userfavorites} 目录。</p> 
<pre></pre> 
<table cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> </td><td> <p>{userprograms} 和 {commonprograms} *</p> </td></tr></tbody></table> 
<p>开始菜单中程序文件夹路径。</p> 
<pre></pre> 
<table cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> </td><td> <p>{userstartmenu} 和 {commonstartmenu} *</p> </td></tr></tbody></table> 
<p>开始菜单顶层路径。</p> 
<pre></pre> 
<table cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> </td><td> <p>{userstartup} 和 {commonstartup} *</p> </td></tr></tbody></table> 
<p>开始菜单启动文件夹路径。</p> 
<pre></pre> 
<table cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> </td><td> <p>{usertemplates} 和 {commontemplates} *</p> </td></tr></tbody></table> 
<p>模板文件夹路径。仅在 Windows 2000 和更高版本支持 {commontemplates}，如果使用的是先前的 Windows 版本，它将被翻译为等同于 {usertemplates} 目录。<br> 其它常量</p> 
<pre></pre> 
<table cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> </td><td> <p>{\}</p> </td></tr></tbody></table> 
<p>反斜杠字符。查阅本页顶部的注释获取使用 {\} 和只使用一个 \ 字符之间的差异。</p> 
<pre></pre> 
<table cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> </td><td> <p>{%NAME|DefaultValue}</p> </td></tr></tbody></table> 
<p>嵌入一个环境变量值。<br> ★ NAME 用于指定要使用的环境变量的名字。<br> ★ DefaultValue 确定如果指定的变量在用户系统中不存在时置入的字符串。<br> ★ 如果你想在常量内部包含一个逗号、竖条 (“|”)，或括弧后半部 (“}”)，你必须通过“%-encoding.”先用一个“%”字符然后跟随它的两上数字的十六进制代码替换，从而避开它。逗号是“%2c”，竖条是 “%7c”括弧后半部是“%7d”。如果你想实际使用“%”，使用“%25”。<br> ★ NAME 和 DefaultValue 可以包含常量。注意，你不需要将常量中的括弧替换成上面所说的字符；上面所说的括弧后半部只在使用于其它地方时需要替换。<br> 示例:</p> 
<pre></pre> 
<table cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1<br> 2<br> 3</p> </td><td> <p>{%COMSPEC}<br> {%PROMPT|$P$G}<br> {cmd}</p> </td></tr></tbody></table> 
<p>系 统标准命令解释器的完整路径名。在 Windows NT/2000/XP，是 Windows\System32\cmd.exe。在 Windows 95/98/Me，是 Windows\COMMAND.COM。注意当展开这个常量时 COMSPEC 环境变量不使用。</p> 
<pre></pre> 
<table cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> </td><td> <p>{computername}</p> </td></tr></tbody></table> 
<p>正在运行安装程序或卸载程序的电脑名 (等同于由 GetComputerName 函数返回的值)。</p> 
<pre></pre> 
<table cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> </td><td> <p>{drive:Path}</p> </td></tr></tbody></table> 
<p>从指定的路径中提取并返回驱动器卷标和冒号 (例如“C:”)在 UNC 路径的场合中，它返回服务器和共享名 (例如“\\SERVER\SHARE”)。<br> ★ Path 指定路径。<br> ★ 如果你想在常量内部包含一个逗号、竖条 (“|”)，或括弧后半部 (“}”)，你必须通过“%-encoding.”先用一个“%”字符然后跟随它的两上数字的十六进制代码替换，从而避开它。逗号是“%2c”，竖条是 “%7c”括弧后半部是“%7d”。如果你想实际使用“%”，使用“%25”。<br> ★ 可以包含常量。注意，你不需要将常量中的括弧替换成上面所说的字符；上面所说的括弧后半部只在使用于其它地方时需要替换。<br> 示例:</p> 
<pre></pre> 
<table cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1<br> 2<br> 3</p> </td><td> <p>{drive:{src}}<br> {drive:c:\path\file}<br> {drive:\\server\share\path\file}</p> </td></tr></tbody></table> 
<pre></pre> 
<table cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> </td><td> <p>{groupname}</p> </td></tr></tbody></table> 
<p>用户在安装程序向导页的选择开始菜单文件夹中选定的文件夹名。它不同于 {group}，只有名字，不包含路径。</p> 
<pre></pre> 
<table cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> </td><td> <p>{hwnd}</p> </td></tr></tbody></table> 
<p>(特殊用途) 转换为安装程序的背景窗口句柄。</p> 
<pre></pre> 
<table cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> </td><td> <p>{wizardhwnd}</p> </td></tr></tbody></table> 
<p>(特殊用途) 转换为安装程序的向导窗口句柄。如果向导窗口句柄在翻译完成时不能用，这个句柄设置为“0”。</p> 
<pre></pre> 
<table cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> </td><td> <p>{ini:Filename,Section,Key|DefaultValue}</p> </td></tr></tbody></table> 
<p>从 .INI 文件插入一个值。<br> ★ Filename 指定要读取的 .INI 文件的名字。<br> ★ Section 指定读取的段名。<br> ★ Key 指定读取的键名。<br> ★ DefaultValue 确定如果指定的键不存在时要插入的字符。<br> ★ 如果你想在常量内部包含一个逗号、竖条 (“|”)，或括弧后半部 (“}”)，你必须通过“%-encoding.”先用一个“%”字符然后跟随它的两上数字的十六进制代码替换，从而避开它。逗号是“%2c”，竖条是 “%7c”括弧后半部是“%7d”。如果你想实际使用“%”，使用“%25”。<br> ★ Filename，Section 和 Key 可以包含常量。注意，你不需要将常量中的括弧替换成上面所说的字符；上面所说的括弧后半部只在使用于其它地方时需要替换。<br> 示例:</p> 
<pre></pre> 
<table cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> </td><td> <p>{ini:{win}\MyProg.ini,Settings,Path|{pf}\My Program}</p> </td></tr></tbody></table> 
<pre></pre> 
<table cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> </td><td> <p>{language}</p> </td></tr></tbody></table> 
<p>选定语言的内部名字。查阅 [Languages] 段帮助文档获取更多信息。</p> 
<pre></pre> 
<table cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1<br> 2</p> </td><td> <p>{cm:MessageName}<br> {cm:MessageName,Arguments}</p> </td></tr></tbody></table> 
<p>根据活动语言嵌入一个自定义消息值。<br> ★ MessageName 用于指定要读取的自定义消息名。查阅 [CustomMessages] 段帮助文档获取更多信息。<br> ★ Arguments 可随意在消息值中指定逗号分隔的声明列表。<br> ★ 如果你想在常量内部包含一个逗号，垂直条 (“|”)，或括号 (“}”)，你必须使用“%-encoding.”避开它，用“%”字符，后面跟随它的两位数十六进制代码替换。逗号是“%2c”，垂直条是“%7c”， 括号是“%7d”，如果你想包含一个实际的“%”字符，用“%25”。<br> ★ 每个 Arguments 中的声明可以包含常量。注意，你不需要避开上面描述的常量中的括号，只有在别处使用这种括号时需要避开。<br> 示例:</p> 
<pre></pre> 
<table cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> </td><td> <p>{cm:LaunchProgram,Inno Setup}</p> </td></tr></tbody></table> 
<p>如果活动语言是简体中文，上面的示例被翻译为“运行 Inno Setup”。</p> 
<pre></pre> 
<table cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> </td><td> <p>{reg:HKxx\SubkeyName,ValueName|DefaultValue}</p> </td></tr></tbody></table> 
<p>插入一个注册表值。<br> ★ HKxx 指定注册表根键；查阅 [Registry] 段帮助文档获取可用根键列表。<br> ★ SubkeyName 指定要读取的子键名。<br> ★ ValueName 指定要读取的值名；如果你想读取键的“默认”值，将 ValueName 留空。<br> ★ DefaultValue 确定在指定的注册表值不存在，或不是一个字符串类型的值 (REG_SZ 或 REG_EXPAND_SZ) 时要插入的字符。<br> ★ 如果你想在常量内部包含一个逗号、竖条 (“|”)，或括弧后半部 (“}”)，你必须通过“%-encoding.”先用一个“%”字符然后跟随它的两上数字的十六进制代码替换，从而避开它。逗号是“%2c”，竖条是 “%7c”括弧后半部是“%7d”。如果你想实际使用“%”，使用“%25”。<br> ★ SubkeyName，ValueName 和 DefaultValue 可以包含常量。注意，你不需要将常量中的括弧替换成上面所说的字符；上面所说的括弧后半部只在使用于其它地方时需要替换。<br> 示例:</p> 
<pre></pre> 
<table cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> </td><td> <p>{reg:HKLM\Software\My Program,Path|{pf}\My Program}</p> </td></tr></tbody></table> 
<pre></pre> 
<table cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> </td><td> <p>{param:ParamName|DefaultValue}</p> </td></tr></tbody></table> 
<p>插入一个命令行参数值。<br> ★ ParamName 指定要读取的命令行参数名。<br> ★ DefaultValue 确定如果指定的命令行参数不存在，或它的值不能确定时要插入的字符。<br> ★ 如果你想在常量内部包含一个逗号、竖条 (“|”)，或括弧后半部 (“}”)，你必须通过“%-encoding.”先用一个“%”字符然后跟随它的两上数字的十六进制代码替换，从而避开它。逗号是“%2c”，竖条是 “%7c”括弧后半部是“%7d”。如果你想实际使用“%”，使用“%25”。<br> ★ ParamName 和 DefaultValue 可以包含常量。注意，你不需要将常量中的括弧替换成上面所说的字符；上面所说的括弧后半部只在使用于其它地方时需要替换。<br> 示例:</p> 
<pre></pre> 
<table cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> </td><td> <p>{param:Path|{pf}\My Program}</p> </td></tr></tbody></table> 
<p>如果指定命令行 /Path=”c:\My Program”，上面的例子翻译为 c:\My Program。</p> 
<pre></pre> 
<table cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> </td><td> <p>{srcexe}</p> </td></tr></tbody></table> 
<p>安装程序文件的完整路径名，例如“C:\SETUP.EXE”。</p> 
<pre></pre> 
<table cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> </td><td> <p>{uninstallexe}</p> </td></tr></tbody></table> 
<p>由 安装程序提取的卸载程序的完整路径名，例如“C:\Program Files\My Program\unins000.exe”。这个常量一般用于在 [Icons] 段条目创建一个卸载图标。它只在 Uninstallable 设为 yes (默认设置) 时有效。0</p> 
<pre></pre> 
<table cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1<br> 2</p> </td><td> <p>{sysuserinfoname}<br> {sysuserinfoorg}</p> </td></tr></tbody></table> 
<p>Windows 已许可的名字和组织，这个信息从注册表中读取。</p> 
<pre></pre> 
<table cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1<br> 2<br> 3</p> </td><td> <p>{userinfoname}<br> {userinfoorg}<br> {userinfoserial}</p> </td></tr></tbody></table> 
<p>用户在用户信息向导页 (可以通过 UserInfoPage 指示来启用) 中分别输入的名字，组织和序列号。一般来说，这些常量用于在 [Registry] 或 [INI] 条目中保存它们以后要使用的值。</p> 
<pre></pre> 
<table cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> </td><td> <p>{username}</p> </td></tr></tbody></table> 
<p>正在运行安装程序或卸载程序的用户的名字 (也可以用 GetUserName 函数返回)。<br><strong>5、公共参数</strong><br> 有三个可选的被所有段条目支持的参数，它们是:</p> 
<pre></pre> 
<table cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> </td><td> <p>Languages</p> </td></tr></tbody></table> 
<p>描述:<br> 一个用空格分隔的语言名列表，告诉安装程序条目属于哪种语言。如果最终用户从列表中选择了一个语言，该条目就执行(例如: 安装文件)。<br> 不带 Languages 参数的条目总是安装，除非其它参数中有限制。<br> 示例:</p> 
<pre></pre> 
<table cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> </td><td> <p>Languages: en nl</p> </td></tr></tbody></table> 
<p>除用空格将它们隔开外，你也可以使用 boolean 表达式。查阅组件和任务参数获取 boolean 表达式的示例。</p> 
<pre></pre> 
<table cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> </td><td> <p>MinVersion</p> </td></tr></tbody></table> 
<p>描述:<br> 指定条目要进行处理的最小 Windows 版本 Windows NT 版本。如果你在版本中的一个使用“0”，那么条目将不在平台中进行处理。构建号和/或安全服务包级别可能包含在版本号中。这将忽略任何在脚本 [Setup] 段中的 MinVersion 指示。<br> 不带 MinVersion 参数的条目总是安装，除非其它参数中有限制。<br> 示例:</p> 
<pre></pre> 
<table cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> </td><td> <p>MinVersion: 4.0,4.0</p> </td></tr></tbody></table> 
<pre></pre> 
<table cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> </td><td> <p>OnlyBelowVersion</p> </td></tr></tbody></table> 
<p>描述:<br> 基 本上是和 MinVersion 相对。指定条目不进行处理的最小 Windows 和 Windows NT 版本。例如，如果你加入 4.1,5.0，用户正在运行 Windows 95 或 NT 4.0，那么条目将进行处理，但如果用户正运行于 Windows 98 (报告它的版本是 4.1) 或 Windows 2000 (报告它的版本是 NT 5.0)，它将不进行处理。版本中的一个放入“0”表示不受版本上限。 构建号和/或安全服务包级别可能包含在版本号中。这将忽略任何在脚本 [Setup] 段中的 MinVersion 指示。<br> 不带 OnlyBelowVersion 参数的条目总是安装，除非其它参数中有限制。<br> 示例:</p> 
<pre></pre> 
<table cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> </td><td> <p>OnlyBelowVersion: 4.1,5.0</p> </td></tr></tbody></table> 
<p><strong>6、组件和任务参数</strong><br> 这里有两个可选的参数，被除 [Types]、[Components] 和 [Tasks] 段以外所有其它段中的条目支持。它们是:</p> 
<pre></pre> 
<table cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> </td><td> <p>Components</p> </td></tr></tbody></table> 
<p>描述:<br> 用空格分隔的组件名列表，告诉安装程序条目属于哪个组件。如果最终用户从列表中选择了一个组件，那么该条目就进行处理 (例如: 安装文件)。<br> 不带组件参数的条目总是安装，除非其它参数对其有限制。<br> 示例:</p> 
<pre></pre> 
<table cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1<br> 2<br> 3<br> 4</p> </td><td> <p>[Files]<br> Source: "MYPROG.EXE"; DestDir: "{app}"; Components: main<br> Source: "MYPROG.HLP"; DestDir: "{app}"; Components: help<br> Source: "README.TXT"; DestDir: "{app}"</p> </td></tr></tbody></table> 
<pre></pre> 
<table cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> </td><td> <p>Tasks</p> </td></tr></tbody></table> 
<p>描述:<br> 用空格分隔的任务名列表，告诉安装程序条目属于哪个任务。如果最终用户从列表中选择了一个任务，那么该条目就进行处理 (例如: 安装文件)。<br> 不带任务参数的条目总是安装，除非其它参数对其有限制。<br> “不创建任何快捷方式”选项框不控制 [Icons] 带任务参数的条目 (它们有自己的选项框)。因此，如果你已经定义了带任务参数的快捷方式，安装程序将改变“不创建任何快捷方式”的文字到“不创建开始菜单文件夹”。<br> 示例:</p> 
<pre></pre> 
<table cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1<br> 2<br> 3<br> 4<br> 5</p> </td><td> <p>[Icons]<br> Name: "{group}\My Program"; Filename: "{app}\MyProg.exe"; Components: main; Tasks: startmenu<br> Name: "{group}\My Program Help"; Filename: "{app}\MyProg.hlp"; Components: help;<br> Tasks: startmenu<br> Name: "{userdesktop}\My Program"; Filename: "{app}\MyProg.exe"; Components: main; Tasks: desktopicon</p> </td></tr></tbody></table> 
<p>除用空格分隔外，你也可以使用 boolean 表达式作为组件和任务参数。支持包含 not、and 和 or 操作。例如:</p> 
<pre></pre> 
<table cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1<br> 2<br> 3<br> 4<br> 5<br> 6<br> 7<br> 8<br> 9</p> </td><td> <p>[Components]<br> Name: a; Description: a<br> Name: b; Description: b<br> [Tasks]<br> Name: p; Description: a or b; Components: a or b<br> Name: q; Description: a and b; Components: a and b<br> Name: r; Description: not a or b; Components: not a or b<br> Name: s; Description: not (a or b); Components: not (a or b)<br> Name: t; Description: a or b - old style; Components: a b</p> </td></tr></tbody></table> 
<p><strong>7、安装脚本段</strong></p> 
<p><strong>[Setup] 段</strong></p> 
<p>这个段包含用于安装程序和卸载程序的全局设置。某些提示对于你创建的任何安装程序都是必需的。这是 [Setup] 段的一个示例:</p> 
<pre></pre> 
<table cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1<br> 2<br> 3<br> 4<br> 5</p> </td><td> <p>[Setup]<br> AppName=My Program<br> AppVerName=My Program version 1.4<br> DefaultDirName={pf}\My Program<br> DefaultGroupName=My Program</p> </td></tr></tbody></table> 
<p>下列指示可以放置到 [Setup] 段中:</p> 
<p>(粗体为必需项)<br> 编译器相关<br> ★ Compression<br> ★ DiskClusterSize<br> ★ DiskSliceSize<br> ★ DiskSpanning<br> ★ Encryption<br> ★ InternalCompressLevel<br> ★ MergeDuplicateFiles<br> ★ OutputBaseFilename<br> ★ OutputDir<br> ★ OutputManifestFile<br> ★ ReserveBytes<br> ★ SlicesPerDisk<br> ★ SolidCompression<br> ★ SourceDir<br> ★ UseSetupLdr<br> ★ VersionInfoCompany<br> ★ VersionInfoDescription<br> ★ VersionInfoTextVersion<br> ★ VersionInfoVersion</p> 
<p>安装程序相关<br> 功能:这些指示影响安装程序的操作，或保存和被卸载程序使用。<br> ★ AllowCancelDuringInstall<br> ★ AllowNoIcons<br> ★ AllowRootDirectory<br> ★ AllowUNCPath<br> ★ AlwaysRestart<br> ★ AlwaysShowComponentsList<br> ★ AlwaysShowDirOnReadyPage<br> ★ AlwaysShowGroupOnReadyPage<br> ★ AlwaysUsePersonalGroup<br> ★ AppendDefaultDirName<br> ★ AppendDefaultGroupName<br> ★ AppComments<br> ★ AppContact<br> ★ AppId<br> ★ AppmodifyPath<br> ★ AppMutex<br> ★ AppName<br> ★ AppPublisher<br> ★ AppPublisherURL<br> ★ AppReadmeFile<br> ★ AppSupportURL<br> ★ AppupdatesURL<br> ★ AppVersion<br> ★ AppVerName<br> ★ ChangesAssociations<br> ★ ChangesEnvironment<br> ★ createAppDir<br> ★ createUninstallRegKey<br> ★ DefaultDirName<br> ★ DefaultGroupName<br> ★ DefaultUserInfoName<br> ★ DefaultUserInfoOrg<br> ★ DefaultUserInfoSerial<br> ★ DirExistsWarning<br> ★ DisableDirPage<br> ★ DisableFinishedPage<br> ★ DisableProgramGroupPage<br> ★ DisableReadyMemo<br> ★ DisableReadyPage<br> ★ DisableStartupPrompt<br> ★ EnableDirDoesntExistWarning<br> ★ ExtraDiskSpaceRequired<br> ★ InfoAfterFile<br> ★ InfoBeforeFile<br> ★ LanguageDetectionMethod<br> ★ LicenseFile<br> ★ MinVersion<br> ★ OnlyBelowVersion<br> ★ Password<br> ★ PrivilegesRequired<br> ★ RestartIfNeededByRun<br> ★ ShowLanguageDialog<br> ★ TimeStampRounding<br> ★ TimeStampsInUTC<br> ★ Uninstallable<br> ★ UninstallDisplayIcon<br> ★ UninstallDisplayName<br> ★ UninstallFilesDir<br> ★ UninstallLogMode<br> ★ UninstallRestartComputer<br> ★ updateUninstallLogAppName<br> ★ UsePreviousAppDir<br> ★ UsePreviousGroup<br> ★ UsePreviousSetupType<br> ★ UsePreviousTasks<br> ★ UsePreviousUserInfo<br> ★ UserInfoPage</p> 
<p>修饰:这些指示只用于安装程序的显示目的。<br> ★ AppCopyright<br> ★ BackColor<br> ★ BackColor2<br> ★ BackColorDirection<br> ★ BackSolid<br> ★ FlatComponentsList<br> ★ SetupIconFile<br> ★ ShowComponentSizes<br> ★ ShowTasksTreeLines<br> ★ UninstallStyle<br> ★ WindowShowCaption<br> ★ WindowStartMaximized<br> ★ WindowResizable<br> ★ WindowVisible<br> ★ WizardImageBackColor<br> ★ WizardImageFile<br> ★ WizardImageStretch<br> ★ WizardSmallImageFile</p> 
<p>已废弃<br> ★ AdminPrivilegesRequired<br> ★ AlwayscreateUninstallIcon<br> ★ DisableAppendDir<br> ★ DontMergeDuplicateFiles<br> ★ MessagesFile<br> ★ UninstallIconFile<br> ★ UninstallIconName<br> ★ UninstallStyle<br> ★ WizardSmallImageBackColor<br> ★ WizardStyle</p> 
<p><strong>[Types] 段</strong><br> 这个段是可选的。它用来定义安装程序向导在选择组件面时可供选择的所有安装类型。如果你在 [Components] 段定义了组件，但没有定义类型，在编译时将创建一个默认的安装类型设置。如果你正在使用默认 (简体中文) 消息文件，这些类型等同于下面示例中的类型。</p> 
<p>这里是一个 [Types] 段的示例:</p> 
<pre></pre> 
<table cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1<br> 2<br> 3<br> 4</p> </td><td> <p>[Types]<br> Name: "full"; Description: "完全安装"<br> Name: "compact"; Description: "简洁安装"<br> Name: "custom"; Description: "自定义安装"; Flags: iscustom</p> </td></tr></tbody></table> 
<p>下列是所支持的参数列表:<br> Name (必需)<br> 描述:<br> 类型的内部名字。用于定义 [Components] 段中组件参数，告诉安装程序组件属于哪个类型。<br> 示例:<br> Name: “full”<br> Description (必需)<br> 描述:<br> 类型的描述，可以包含常量。这个描述在安装期间显示。<br> 示例:<br> Description: “完全安装”<br> Flags<br> 描述:<br> 这个参数是额外选项设置。多个选项可以使用空格隔开。支持下面的选项:<br> iscustom<br> 告诉安装程序这个类型是自定义类型。只在最终用户在安装期间手动改变了组件选择，安装程序就将安装类型设置为自定义类型。请注意，如果你未定义自定义类型，安装程序将只允许用户选择一个安装类型，并且不能手动选择/取消选择组件。</p> 
<p>示例:<br> Flags: iscustom</p> 
<p><strong>[Components] 段</strong></p> 
<p>这个段是可选的。它定义安装程序向导的选择组件页中显示的所有组件，以便于用户定制安装类型。<br> 光用它一个组件不会做任何事情: 它需要“链接”到其它安装条目。请查阅组件和任务参数。</p> 
<p>这里是一个 [Components] 段的示例:</p> 
<pre></pre> 
<table cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1<br> 2<br> 3<br> 4<br> 5</p> </td><td> <p>[Components]<br> Name: "main"; Description: "主文件"; Types: full compact custom; Flags: fixed<br> Name: "help"; Description: "帮助文件"; Types: full<br> Name: "help\english"; Description: "English"; Types: full<br> Name: "help\dutch"; Description: "简体中文"; Types: full</p> </td></tr></tbody></table> 
<p>上面的示例生成四种组件: “main”组件在最终用户选择一个名为“full”和“compact”的类型时都将安装。带有两个子组件的“help”组件类型仅在最终用户选择“full”类型时安装。</p> 
<p>下列是所支持的参数列表:<br> Name (必需)<br> 描述:<br> 组件的内部名字。<br> 在组件名字中的 \ 或 / 字符合计数是调用组件的层次。任何在层次 1 或更高层次的组件是子组件。在子组件前列出的小于子组件一个层次的组件是上级组件。其它有相同上级组件的组件之间是同级组件。<br> 如果上级组件未选定，则不能选定一个它的子组件。如果所有的子组件均未选定，则上级组件也不能选定，除非组件参数引用上级组件或上级组件包含 checkablealone 标记。<br> 如果同级组件已经标有 exclusive 标记，那么它们之中只有一个可选。<br> 示例:<br> Name: “help”<br> Description (必需)<br> 描述:<br> 组件的描述，可以包含常量。这个描述用于在安装期间显示给最终用户参考。</p> 
<p>示例:<br> Description: “帮助文件”<br> Types<br> 描述:<br> 用空格隔开所属组件的类型列表。如果最终用户从这个列表中选择了一个类型，这个组件将被安装。<br> 如果未使用 fixed 标记 (看下面)，这个列表中的任何自定义类型 (使用 iscustom 标记的类型) 均被安装程序忽略。</p> 
<p>示例:<br> Types: full compact<br> ExtraDiskSpaceRequired<br> 描述:<br> 这个组件所需要的额外磁盘空间，类似于 [Setup] 段中的 ExtraDiskSpaceRequired。</p> 
<p>示例:<br> ExtraDiskSpaceRequired: 0<br> Flags<br> 描述:<br> 这个参数是额外选项设置。多个选项可以使用空格隔开。支持下面的选项:<br> checkablealone<br> 指定当一个组件的子组件选中时，该组件是否可以选中。按默认，如果没有组件参数直接引用到该组件，未选中所有子组件将会使该组件变成未选中状态。<br> dontinheritcheck<br> 指定当该组件的上级被选中时，该组件应该不自动变成已选中状态。这对顶层的组件不影响，且不能与 exclusive 标记组合使用。<br> exclusive<br> 告诉安装程序这个组件与它的也使用 exclusive 标记的同级组件是互相排斥的。<br> fixed<br> 告诉安装程序这个组件不能在安装期间被最终用户手动选择或取消选择。<br> restart<br> 告诉安装程序如果用户安装了这个组件，将询问用户重新启动系统，不管它是不是需要 (例如，因为 [Files] 段条目用了 restartreplace 标记)。有点象 AlwaysRestart，但不是每个组件。<br> disablenouninstallwarning<br> 如果这个组件已经安装在用户机器中，重新安装时在用户取消这个组件选择后，这条标记告诉安装程序不警告用户不卸载该组件。<br> 考虑到你的组件的复杂性，你可以尝试使用 [Installdelete] 段和这个标记为自动“卸载”取消选定的组件。<br> 示例:<br> Flags: fixed<br><strong>[Tasks] 段</strong><br> 这个段是只选的。它定义安装程序在执行安装期间所有由用户定制的任务。这些任务以选项框和单选项形式在附加任务向导页中出现。<br> 光任务本身是不会做任何事情的: 它需要“链接”到其它安装条目。查阅组件和任务参数。<br> 这里是一个 [Tasks] 段的示例:</p> 
<pre></pre> 
<table cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1<br> 2<br> 3<br> 4<br> 5</p> </td><td> <p>[Tasks]<br> Name: desktopicon; Description: "创建桌面快捷方式(&amp;D)"; GroupDescription: "添加快捷方式:"; Components: main<br> Name: desktopicon\common; Description: "对于所有用户"; GroupDescription: "添加快捷方式:"; Components: main; Flags: exclusive<br> Name: desktopicon\user; Description: "仅对当前用户"; GroupDescription: "添加快捷方式: quicklaunchicon; Description: "创建快速运行栏快捷方式(&amp;Q)"; GroupDescription: "添加快捷方式:"; Components: main; Flags: unchecked<br> Name: associate; Description: "文件关联(&amp;A)"; GroupDescription: "其它任务:"; Flags: unchecked</p> </td></tr></tbody></table> 
<p>下列是所支持的参数列表:<br> Name (必需)<br> 描述:<br> 任务的内部名字。<br> 在任务名字中的 \ 或 / 字符合计数是调用任务的层次。任何在层次 1 或更高层次的任务是子任务。在子任务前列出的小于子任务一个层次的任务是上级任务。其它有相同上级任务的任务之间是同级任务。<br> 如果上级任务未选定，则不能选定一个它的子任务。如果所有的子任务均未选定，则上级任务也不能选定，除非任务参数引用上级任务或上级任务包含 checkablealone 标记。<br> 如果同级任务已经标有 exclusive 标记，那么它们之中只有一个可选。<br> 示例:<br> Name: “desktopicon”<br> Description (必需)<br> 描述:<br> 任务的描述，可以包含常量。这个描述用于在安装期间显示给最终用户参考。<br> 示例:<br> Description: “创建桌面快捷方式(&amp;D)”<br> GroupDescription<br> 描述:<br> 任务组的组描述，可以包含常量。用相同组描述的任务将被连续组合到文字标签下。文字标签显示组描述。<br> 示例:<br> GroupDescription: “附加图标”<br> Components<br> 描述:<br> 这个任务属于一个用空格隔开的组件列表。如果最终用户从这个列表中选择了一个组件，这个任务将显示。不带组件参数的任务条目总显示。<br> 示例:<br> Components: main<br> Flags<br> 描述:<br> 这个参数是额外选项设置。多个选项可以使用空格隔开。支持下面的选项:<br> checkablealone<br> 指定当一个任务的子任务选中时，该任务是否可以选中。按默认，如果没有任务参数直接引用到该任务，未选中所有子任务将会使该任务变成未选中状态。<br> checkedonce<br> 告诉安装程序当安装程序找到已经安装的相同应用程序先前版本时，这个任务开始应该不选中。这个标记不能与 unchecked 标记组合使用。<br> 如果 [Setup] 段的 UsePreviousTasks 指示是 no，这个标记是被禁用的。<br> dontinheritcheck<br> 指定当该任务的上级被选中时，该任务应该不自动变成已选中状态。这对顶层的任务不影响，且不能与 exclusive 标记组合使用。<br> exclusive<br> 告诉安装程序这个任务是与同样有 exclusive 标记的同级任务互斥的。<br> restart<br> 告诉安装程序如果用户安装了这个任务，将询问用户重新启动系统，不管它是不是需要 (例如，因为 [Files] 段条目用了 restartreplace 标记)。有点象 AlwaysRestart，但不是每个任务。<br> unchecked<br> 告诉安装程序这个任务在最初应该是不选中。这个标记不能与 checkedonce 标记组合使用。<br> 示例:<br> Flags: unchecked<br><strong>[Dirs] 段</strong><br> 这个可选段用来定义除创建用户选择的应用程序目录外安装程序自动创建的另外目录。在主应用程序目录下创建子目录对于这个段是公共使用的。<br> 请注意，在使用 [Files] 段安装文件前你无需一定要创建目录，这个段起初用于创建一个空的目录。<br> 这里是一个 [Dirs] 段的示例:</p> 
<pre></pre> 
<table cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1<br> 2<br> 3</p> </td><td> <p>[Dirs]<br> Name: "{app}\data"<br> Name: "{app}\bin"</p> </td></tr></tbody></table> 
<p>上面的示例中，在安装程序创建应用程序目录后，又在应用程序目录下创建了两个子目录。<br> 下列是所支持的参数列表:<br> Name (必需)<br> 描述:<br> 要创建的目录名，通常用一个目录常量开始。<br> 示例:<br> Name: “{app}\MyDir”<br> Attribs<br> 描述:<br> 指定目录的其它属性。这可以包含下面属性中的一个或多个: readonly，hidden，system。如果这个参数未指定，安装程序不会在目录中分配任何特殊的属性。<br> 如果目录已经存在，指定的属性将与目录现有的属性组合。<br> 示例:<br> Attribs: hidden system<br> Permissions<br> 描述:<br> 指定访问目录 ACL (访问控制列表) 另外的认可权限。如果你不熟悉 ACL 或不知道为什么要改变它们，则不推荐你使用这个参数，因为误用会发生系统冲突，影响安全性。<br> 使 用这个参数还有一个问题用户必须在使用 Windows 2000 或更高版本 (由于 API 的 bug，NT 4.0 不支持)，目录必须位于支持 ACL (象 NTFS) 的分区，并且当前的用户有改变目录许可的权限。如果这些条件不满足，不会显示错误消息，并且不会设置任何许可。<br> 这个参数只应该用于你应用程序的目录隐私。决不会改变顶层目录，象 {sys} 或 {pf} 的 ACL，否则你可以打开你的用户系统的安全漏洞。<br> 另 外，推荐你避免使用这个参数，同意在包含程序文件的目录的定入访问。例如，每个人都可以修改 {app} 目录的许可将允许没有权限的用户损坏你的应用程序的程序文件；这个创建会留下潜在的增加别个攻击的问题。(可是，在你的应用程序目录下的子目录的许可是安 全的，它们不包含程序文件，例如，{app}\data。)<br> 指定的许可设置不考虑安装前已有的目录。<br> 这个参数可以包含象下列格式一样一个或多个空格分隔的值:<br> &lt;用户或组标识&gt;-&lt;访问类型&gt;<br> 下列是 [Dirs] 段支持的访问类型:<br> full<br> 同意“完全控制”许可，它与下面的 modify 一样，但另加上允许指定的用户/组获取目录的所有权并改变它的许可。保守一点使用，一般 modify 就足够了。<br> modify<br> 同意“修改”许可，允许指定的用户/组读取，执行，修改和删除目录和它的子目录中的文件。<br> readexec<br> 同意“读取和执行”许可，允许指定的用户/组阅读和执行目录和它的子目录中的文件。<br> 示例:<br> Permissions: authusers-modify<br> Flags<br> 描述:<br> 这个参数是额外选项设置。多个选项可以使用空格隔开。支持下面的选项:<br> deleteafterinstall<br> 告诉安装程序照常创建目录，但当安装完成 (或中断) 后，如果它是空的，则删除它。比如，你在脚本 [Run] 段定义了一个安装时要执行的文件，可以将它提取到临时数据然后执行后这个标记就相当有用。<br> 这个标记不会导致安装前已经存在的目录被删除。<br> uninsalwaysuninstall<br> 告诉卸载程序如果目录是空的，允许删除该目录。通常卸载程序只尝试删除在安装前不存在的目录。<br> uninsneveruninstall<br> 告诉卸载程序不要删除目录。按默认，如果在 [Dirs] 段中指定的目录已经是空的，卸载程序将删除目录。<br> 示例:<br> Flags: uninsneveruninstall<br><strong>[Files] 段</strong><br> 这是定义安装程序安装文件到用户系统中的可选文件段。<br> 这里是一个 [Files] 段的示例:</p> 
<pre></pre> 
<table cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1<br> 2<br> 3<br> 4<br> 5</p> </td><td> <p>[Files]<br> Source: "CTL3DV2.DLL"; DestDir: "{sys}"; Flags: onlyifdoesntexist uninsneveruninstall<br> Source: "MYPROG.EXE"; DestDir: "{app}"<br> Source: "MYPROG.HLP"; DestDir: "{app}"<br> Source: "README.TXT"; DestDir: "{app}"; Flags: isreadme</p> </td></tr></tbody></table> 
<p>查阅本页底部的备注段获取一些重要注意事项。<br> 下列是所支持的参数列表:<br> Source (必需)<br> 描述:<br> 来源文件的名字。如果你不指定一个完整的路径名，编译器将预先考虑你的安装程序来源目录的路径。<br> 这里可以在一个条目中用通配符指定一个文件组。当使用通配符时，所有与它匹配的文件使用相同的选项。<br> 当指定 external 标记后，来源必须是发布的媒介或用户系统中现有文件 (或作用通配符) 的完整路径 (例如“{src}\license.ini”)。<br> 当指定 external 标记后，只能使用常量，因为编译器自身不能执行常量翻译。<br> 示例:<br> Source: “MYPROG.EXE”<br> Source: “Files\*”<br> DestDir (必需)<br> 描述:<br> 文件安装到用户系统中的目录。基本上都是用一个目录常量开头。如果指定的路径在用户系统中不存在，它会自动创建，并在卸载后如果是空的，卸载程序会自动删除。<br> 示例:<br> DestDir: “{app}”<br> DestDir: “{app}\subdir”<br> DestName<br> 描述:<br> 这个参数用来指定将该文件使用新的文件名安装到用户系统中，按默认，安装程序使用 Source 参数中的名字，因此大多数场合中你不需要指定这个参数。<br> 示例:<br> DestName: “MYPROG2.EXE”<br> Excludes<br> 描述:<br> 指定要排除的格式列表，用逗号分隔。这个参数不能与 external 标记组合使用。格式可以包含通配符 (“*”和“?”)。<br> 如果格式用反斜杠符号 (“\”) 如果格式用反斜杠符号 (“\”) 开始，表示它只匹配反斜杠符号左边的路径名，否则它一直匹配到路径名末端。因此“\foo”只排除树根部的名为“foo”的文件，“foo”将排除树中任何地方的名字“foo”的文件。<br> 该格式可以包含反斜框符号。“foo\bar”表示排除“foo\bar”和“subdir\foo\bar”两者。“\foo\bar”只排除“foo\bar”。<br> 示例:<br> Source: “*”; Excludes: “*.~*”<br> Source: “*”; Excludes: “*.~*,\Temp\*”; Flags: recursesubdirs<br> CopyMode<br> 描述:<br> 你不要在一些新的脚本中使用这个参数。不赞成用这个参数，用 Inno Setup 3.0.5 中用下列标记替换:</p> 
<pre></pre> 
<table cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1<br> 2<br> 3<br> 4<br> 5</p> </td><td> <p>CopyMode: normal -&gt; Flags: promptifolder<br> CopyMode: alwaysskipifsameorolder -&gt; no flags<br> CopyMode: onlyifdoesntexist -&gt; Flags: onlyifdoesntexist<br> CopyMode: alwaysoverwrite -&gt; Flags: ignoreversion<br> CopyMode: dontcopy -&gt; Flags: dontcopy</p> </td></tr></tbody></table> 
<p>什么是 CopyMode: alwaysskipifsameorolder 现在是默认动作。(以前默认是 CopyMode: normal。)<br> Attribs<br> 描述:<br> 指定文件的附加属性。这可以包含下列中的一个或多个: readonly，hidden，system。如果未指定这个参数，安装程序不会在文件中分配任何特殊属性。<br> 示例:<br> Attribs: hidden system<br> Permissions<br> 描述:<br> 指定操作 ACL (访问控制列表) 的附加许可。如果不熟悉 ACL 或不知道为什么或更改它们，推荐你不要使用，因为误用会导致冲突，影响系统安全。<br> 用 户必须在使用 Windows 2000 或更高版本，这个参数才有效 (NT 4.0 由于 API 的问题，不支持)，文件必须位于支持 supports ACL (象 NTFS) 的分区中，以及当前用户必须可以更改文件许可。如果这些条件不东路，不会显示错误消息，也不会设置许可。<br> 这个参数应该只在你的应用程序么人文件中使用，不要改变共享系统文件的 ACL，否则，你打开了你的用户系统的安全漏洞。<br> 该指定的许可设置不考虑安装前文件是否存在。<br> 这个参数可以包含象下列格式一样一个或多个空格分隔的值:<br> &lt;用户或组标识&gt;-&lt;访问类型&gt;<br> [Files] 段支持下列访问类型:<br> full<br> 同意“完全控制”许可，与修改相同 (看下面)，但又加上允许指定的用户/用户组获取文件所有权，并改变它的许可。通常保守的使用 modify 就足够了。<br> modify<br> 同意“修改”许可，允许指定的用户/用户组读取、执行、修改和删除文件。<br> readexec<br> 同意“读取和执行”许可，允许指定的用户/用户组读取和执行文件。<br> 示例:<br> Permissions: authusers-modify<br> FontInstall<br> 描述:<br> 告诉安装程序需要安装的文件是一个字体文件，这个参数值是被保存到注册表或 WIN.INI 文件中的字体名，这个名称必须与和在资源管理器中双击字体文件看到的名字相同。注意，安装程序会在字体名后自动添加“(TrueType)”。<br> 如果这个字体文件不是一个 TrueType 字体，你必须在标记参数中标记 fontisnttruetype。<br> 这里建议你在安装字体到 {fonts} 目录时，使用 onlyifdoesntexist 和 uninsneveruninstall 标记。<br> 要在 Windows 2000/XP 中成功安装字体，用户必须是超级用户或管理组成员，在 Windows NT 4.0 及早期版本，任何人都可以安装字体。<br> 示例:<br> Source: “OZHANDIN.TTF”; DestDir: “{fonts}”; FontInstall: “Oz Handicraft BT”; Flags: onlyifdoesntexist uninsneveruninstall<br> Flags<br> 描述:<br> 这个参数是额外选项设置。多个选项可以使用空格隔开。支持下面的选项:<br> allowunsafefiles<br> 禁止编译器自动检查不安全文件。强烈推荐你不要使用这个标记，除非你有绝对的把握。<br> comparetimestamp<br> (不推荐，看下面)<br> 如果安装的文件已经在用户系统中存在，以及至少下列条件中的一个为 true，则告诉安装程序进行时间戳比较:<br> 1. 现有的文件和安装的文件都没有版本信息。<br> 2. 条目中同时使用了 ignoreversion 标记。<br> 3. 未使用 replacesameversion 标记，并且现有的文件和要安装的文件版本号相同 (用文件的版本信息决定)。<br> 如果现有的文件的时间戳比安装的文件老，现有的文件将被替换。否则，将不替换。<br> 如 果还没有其它方法，不推荐使用这个标记，因为其中有一个内部问题: NTFS 分区在 UTC (不同于 FAT 分区) 贮存时间戳，因本地时间戳原因 — Inno Setup 按默认工作 — 只要用户改变他们系统的时间区域，或转到或使夏令时生效。这可能会导致用户不希望替换的文件被替换，或用户希望替换的文件未被替换。<br> confirmoverwrite<br> 替换现有的文件前总是询问用户确认。<br> createallsubdirs<br> 按默认，当编译器包含子目录搜索源文件名/通配符时，将跳过空目录。这个标记会使这些目录在安装时被创建 (就象在 [Dirs] 段创建一样)。<br> 必须和 recursesubdirs 组合使用。<br> deleteafterinstall<br> 告诉安装程序象平常一样安装文件，但一旦安装完成 (或中断) 则删除。这在提取脚本中的 [Run] 段指定要执行的临时程序时有用。<br> 这个标记不会导致安装期间未被替换的现有文件被删除。<br> 这个标记不能与 isreadme，regserver，regtypelib，restartreplace，sharedfile 或 uninsneveruninstall 标记组合使用。<br> dontcopy<br> 不复制文件到用户系统。如果文件是通过 [code] 专门处理，这个标记是有用的。<br> dontverifychecksum<br> 防止安装程序在提取后校验文件。在你想修改的已编译到安装程序中的文件使用这个标记。<br> 必须与 nocompression 组合。<br> external<br> 这个标记告诉 Inno Setup 不要编译 Source 参数指定的文件到安装程序文件中，改为从分布的媒介或用户系统中复制。查阅 Source 参数的描述获取更多信息。<br> fontisnttruetype<br> 如果用 FontInstall 参数的条目安装一个非 TrueType 字体，则使用这个标记。<br> ignoreversion<br> 不比较版本信息；不考虑版本号替换现有的文件。<br> 这个标记应该用于你私人的程序中，不要用于共享的系统文件。<br> isreadme<br> 表 示文件为“自述”文件。安装程序中只有一个文件可以使用这个标记。当文件使用这个标记时，在安装完成后询问用户是否想查看自述文件。如果选择是，安装程序 将使用与这个文件类型默认的程序打开该文件。因上，自述文件应该总是使用象 .txt，.wri 或 .doc 扩展名。<br> 请注意，如果安装程序重新启动了用户的电脑 (安装了一个带 restartreplace 标记的文件或 [Setup] 段的 AlwaysRestart 指示设为 yes)，用户将没有查看自述文件的选项。<br> nocompression<br> 预防编译器尝试压缩文件。在你知道压缩没有什么好处的文件 (例如 JPEG 图像) 上使用这个标记，可以加速编译进度，并可以使生成的安装程序更小。<br> noencryption<br> 防止文件被加密贮存。如果你已经使用了 encryption (用 [Setup] 段指示 Encryption)，但想让它可以在用户输入正确的密码之前用 [code] 段支持函数 ExtractTemporaryFile 提取该文件，则使用这个标记。<br> noregerror<br> 当与 regserver 或 regtypelib 标记中的任一一个组合使用时，安装程序将在注册失败时不显示任何错误消息。<br> onlyifdestfileexists<br> 仅在用户系统中已经存在相同名字的文件时安装文件。如果你的安装程序是已经安装的软件的补丁，并且你希望安装用户没有安装的文件时，这个标记可能有用。<br> onlyifdoesntexist<br> 仅在用户系统中不存在时安装文件。<br> overwritereadonly<br> 总是覆盖只读文件。如果不带这个标记，安装程序在遇到只读文件时询问用户是否覆盖。<br> promptifolder<br> 按 默认，当安装的文件比现有的文件是个较老的版本 (或当使用 comparetimestamp 时发现较早的时间戳)安装程序将不替换现有的文件 (查阅这个主题下面的备注段获取详细资料)。当使用这个标记时，安装程序将询问用户是否替换文件，默认的回答是保留现有的文件。<br> recursesubdirs<br> 告诉编译器或安装程序同时也搜索来源目录下子目录中的源文件名/通配符。<br> regserver<br> 注 册 OLE 服务 (a.k.a. ActiveX 控件)。使用这个标记，安装程序将查找和执行 DLL/OCX 的 DllRegisterServer 输出。卸载程序调用 DllUnregisterServer。当用于与共享文件结合时，DLL/OCX 只将在涉及的计数为零时取消注册。<br> 看这个主题下面的备注段获取更多信息。<br> regtypelib<br> 注册类型库 (.tlb)。卸载程序将撤销类型库注册 (除非指定了 uninsneveruninstall 标记)。与 regserver 标记一样，当用于与共享文件结合时，文件只将在涉及的计数为零时取消注册。<br> 看这个主题下面的备注段获取更多信息。<br> replacesameversion<br> 当使用这个标记，并且文件已经在用户系统中存在，以及它与要安装的文件版本号相同，安装程序将比较文件，如果它们的内部不同，则替换现有的文件。<br> 默认动作 (例如，当这个标记未使用) 是不替换版本号相同的已有的文件。<br> restartreplace<br> 这 个标记通常用于替换系统核心文件。如果文件预先已经存在，且发现被锁定，以至于安装程序不能替换，安装程序将注册该文件 (用 WININIT.INI 可通过使用 MoveFileEx，分别用于 Windows 和 Windows NT) 在下次系统重新启动时替换。当出现这种情况时，将在安装完成时提示用户重新启动电脑。<br> 为保持与 Windows 95/98/Me 兼容，不要在这个条目中使用长文件名，只支持“8.3”文件名。(Windows NT 平台没有这个限制。)<br> 重 要提示: 这个 restartreplace 标记只能在用户有管理员权限时才能在 Windows NT 平台成功替换使用中的文件。如果用户没有管理员权限，将显示下列消息: “RestartReplace 失败: MoveFileEx 失败; 代码 5。”因此，当使用 restartreplace 时，强烈推荐你在 [Setup] 段设置“PrivilegesRequired=admin”，让你的安装程序必需有管理员权限才能安装。<br> sharedfile<br> 使用 Windows 共享文件计数功能 (位于注册表 HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion \SharedDLLs)。这个功能是用于让文件在应用程序之间共享使用，不要不注意将它删除了。每次安装该文件，涉及的文件计数将增加，当使用这个文件 的应用程序卸载，涉及的文件计数减少。如果计数减少到零，该文件被删除 (会通知用户确认，除非同时指定了 uninsnosharedfileprompt 标记)。<br> 使用这个标记的大多数文件被安装到 Windows 系统目录，包含 .OCX、.BPL 和 .DPL 文件。<br> skipifsourcedoesntexist<br> 这个标记告诉编译器 — 或安装程序，如果同时使用了 external 标记 — 如果源文件不存在，只是跳过该条目，而不是显示一个错误消息。<br> sortfilesbyextension<br> 这个标记告诉编译器在按路径名排序前，先按文件扩展名排序压缩找到的文件。如果同时使用 SolidCompression，可以进一步减小安装程序大小。<br> touch<br> 这个标记命令安装程序设置安装的文件的时间/日期戳为 [Setup] 段 TouchDate 和 TouchTime 指示指定的值。<br> 如果与 external 标记同时使用，这个标记无效。<br> uninsnosharedfileprompt<br> 当卸载共享文件时，如果共享计数为零，不询问用户自动删除文件。必须与 sharedfile 标记组合使用才有效。<br> uninsremovereadonly<br> 当卸载文件时，在删除文件前选删除它的只读属性。<br> uninsrestartdelete<br> 当 使用这个标记、并且该文件在卸载时正在被使用，卸载将文件放置到删除队列，直到系统重新启动经。卸载结束时会询问用户是否重新启动。这个标记通常在卸载不 能用程序停止的外壳扩展的文件时有用。注意，要使用这个标记生效，在 Windows NT/2000/XP 中，必需要有管理员权限。<br> uninsneveruninstall<br> 不卸载这个文件。这个标记在安装在任何情况下不删除的公共共享文件时有用，象 MFC DLL。<br> 示例:<br> Flags: isreadme 组件和任务参数<br> 公共参数<br> 备注<br> 如果文件已经在用户系统中存在，按默认，将根据下列规则替换:<br> 1. 如果现有的文件版本老于安装的文件版本 (通过文件的版本信息确定)，现有的文件将被替换。<br> 2. 如果现有的文件版本与安装的文件版本相同，不替换现有的文件，除非使用了 replacesameversion 标记，且两个文件的内容不一致。<br> 3. 如果现有的文件版本新于安装的文件版本，或如果现有的文件有版本信息，但安装的文件没有，将不替换现有的文件。<br> 4. 如果现有的文件没有版本信息，将被替换。<br> 某些标记象 onlyifdoesntexist，ignoreversion 和 promptifolder 会更改上述的规则。<br> 如果未使用 restartreplace 标记，并且因为其它进程正在使用，安装程序不能替换现有的文件，它将继续进行四次文件替换尝试，每次尝试延时一秒。如果所有尝试失败，将显示一个错误消息。<br> 安 装程序用 regserver 或 regtypelib 标记注册所有文件为安装的最后一个步骤。但是，如果 [Setup] 段指示 AlwaysRestart 设为 yes，或如果有用 restartreplace 标记的文件，所有文件在下次重新启动后注册 (通过在 Windows RunOnce 注册表键中创建一个项目)。<br> 当卸载带扩展名 .HLP (Windows 帮助文件) 文件后，相应的 .GID 和 .FTS 文件也同样将自动卸载。</p> 
<p><strong>[Icons] 段</strong><br> 这个可选段定义所有创建在开始菜单和/或其它位置 (比如桌面) 的快捷方式。<br> 这里是 [Icons] 段的例子:</p> 
<pre></pre> 
<table cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1<br> 2<br> 3</p> </td><td> <p>[Icons]<br> Name: "{group}\My Program"; Filename: "{app}\MYPROG.EXE"; WorkingDir: "{app}"<br> Name: "{group}\Uninstall My Program"; Filename: "{uninstallexe}"</p> </td></tr></tbody></table> 
<p>下列是所支持的参数列表:<br> Name (必需)<br> 描述:<br> 要创建的快捷方式的名字和位置。在这个参数中可以使用任何外壳文件夹常量或目录常量。<br> 请注意，快捷方式是贮存为文字文件，因此在普通文件名中不能使用的字符不这里也同样不能使用。同样，因为不可能有两个相同名字的文件一样，也不可能有两个相同名字的快捷方式。<br> 示例:</p> 
<pre></pre> 
<table cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1<br> 2<br> 3<br> 4<br> 5</p> </td><td> <p>Name: "{group}\My Program"<br> Name: "{group}\Subfolder\My Program"<br> Name: "{userdesktop}\My Program"<br> Name: "{commonprograms}\My Program"<br> Name: "{commonstartup}\My Program"</p> </td></tr></tbody></table> 
<p>Filename (必需)<br> 描述:<br> 快捷方式的命令行文件名，通常用一个目录常量开头。<br> 示例:<br> Filename: “{app}\MYPROG.EXE”<br> Filename: “{uninstallexe}”<br> Parameters<br> 描述:<br> 快捷方式的可选命令行参数，可以包含常量。<br> 示例:<br> Parameters: “/play filename.mid”<br> WorkingDir<br> 描述:<br> 快捷方式的工作 (或启动) 目录，就是指示程序在哪个目录开始运行。如果这个参数未指定或是空白的，Windows 将使用一个默认路径，在 Windows 不同版本之间是不同的。这个参数可以包含常量。<br> 示例:<br> WorkingDir: “{app}”<br> HotKey<br> 描述:<br> 快捷方式的热键 (或快捷键) 设置，就是可以用于启动程序的组合键。<br> 注意: 如果你改变了快捷键并重新安装了应用程序，Windows 可以继续认可老的快捷键，直到你注销并返回或重新启动系统。<br> 示例:<br> HotKey: “ctrl+alt+k”<br> Comment<br> 描述:<br> 指定快捷方式的注释 (或描述) 对象，在 Windows 2000，Me 及更高版本中可以用来弹出提示。早期版本的 Windows 被忽略注释。<br> 示例:<br> Comment: “This is my program”<br> IconFilename<br> 描述:<br> 要显示的自定义图标文件名 (位于用户系统)。这可以是一个包含图标文件的可执行映像 (.exe, .dll)或一个 .ico 文件。如果这个参数未指定或空白，Windows 将使用文件的默认图标，这个参数可以包含常量。<br> 示例:<br> IconFilename: “{app}\myicon.ico”<br> IconIndex<br> 默认: 0<br> 描述:<br> 用 IconFilename 指定的文件中使用的以零为基点的图标索引。<br> 如果 IconIndex 非零值，以及 IconFilename 未指定或空白，它将默认为 IconFilename 与 Filename 名相同。<br> 示例:<br> IconIndex: 0<br> Flags<br> 描述:<br> 这个参数是额外选项设置。多个选项可以使用空格隔开。支持下面的选项:<br> closeonexit<br> 当设置这个标记时，安装程序将设置快捷方式的“退出时关闭”属性。这个标记只在快捷方式指向 MS-DOS 应用程序时有效 (如果它是 .pif 扩展名)。如果没有这个标记也没有指定 dontcloseonexit 标记，安装程序将尝试改变“退出时关闭”属性。<br> createonlyiffileexists<br> 当设置这个标记时，安装程序将只在用文件名参数指定的文件存在时尝试创建图标。<br> dontcloseonexit<br> 等同于 closeonexit，除了它导致安装程序不选中“退出时关闭”属性。<br> foldershortcut<br> 创建一个特殊的象“文件夹快捷方式”的快捷方式类型。一般来说，文件夹快捷方式出现在开始菜单中，单击该快捷方式会打开资源管理器窗口显示文件夹内容。与此相反，“文件夹快捷方式”将象菜单一样显示目标文件夹的内容，而不是单独打开一个窗口。<br> 文件夹快捷方式只支持 Windows 2000、Me 和最高版本，一些早期版本的 Windows，安装程序在遇到这个标记时，将返回创建一个普通快捷方式。<br> 当使用这个标记，文件夹名必须在文件名参数中指定。指定一个文件名字将导致毫无用处的快捷方式。<br> runmaximized<br> 当设置这个标记时，安装程序设置图标的“运行”设置为“最大化”，使程序在启动后初始状态为最大化。<br> runminimized<br> 当设置这个标记时，安装程序设置图标的“运行”设置为“最小化”，使程序在启动后初始状态为最小化。<br> uninsneveruninstall<br> 通知卸载程序不删除图标。<br> useapppaths<br> 当 设置这个标记时，只在文件名参数中指定文件名 (无路径)，安装程序将从“HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows \CurrentVersion\App Paths”注册表键获取路径名，并自动添加到文件名前面。<br> 示例:<br> Flags: runminimized</p> 
<p><strong>[INI] 段</strong><br> 这是你希望安装程序在用户系统中设置 .INI 文件条目的可选段。<br> 这里是 [INI] 段的例子:</p> 
<pre></pre> 
<table cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1<br> 2<br> 3</p> </td><td> <p>[INI]<br> Filename: "{win}\MYPROG.INI"; Section: "InstallSettings"; Flags: uninsdeletesection<br> Filename: "{win}\MYPROG.INI"; Section: "InstallSettings"; Key: "InstallPath"; String: "{app}"</p> </td></tr></tbody></table> 
<p>下列是所支持的参数列表:<br> Filename (必需)<br> 描述:<br> 你希望安装程序修改的 .INI 文件的名字，可以包含常量。如果这个参数是空白的，它写入到系统的 Windows 目录中的 WIN.INI 中。<br> 示例:<br> Filename: “{win}\MYPROG.INI”<br> Section (必需)<br> 描述:<br> 要创建的用于放置 INI 条目的区段名，可以包含常量。<br> 示例:<br> Section: “Settings”<br> Key<br> 描述:<br> 要设置的键名，可以包含常量。如果这个参数未指定或是空白的，将不创建键。<br> 示例:<br> Key: “Version”<br> String<br> 描述:<br> 分配给键的值，可以使用常量。如果这个参数未指定，将不创建键。<br> 示例:<br> String: “1.0”<br> Flags<br> 描述:<br> 这个参数是额外选项设置。多个选项可以使用空格隔开。支持下面的选项:<br> createkeyifdoesntexist<br> 仅在如果键名不存在时分配到键。<br> uninsdeleteentry<br> 当程序卸载时删除条目。这可以写 uninsdeletesectionifempty 标记组合使用。<br> uninsdeletesection<br> 当程序卸载时，删除条目所在的整个区段。这对于在 Windows 它自身包含的 INI 文件 (象一些 WIN.INI 中的区段) 中使用，这具有很大的危险性。你应该只在应用程序私有的文件中使用这个标记。<br> uninsdeletesectionifempty<br> 等同于 uninsdeletesection，但只在没有键剩余的情况下删除段，它可以与 uninsdeleteentry 标记组合使用。<br> 示例:<br> Flags: uninsdeleteentry</p> 
<p><strong>[Installdelete] 段</strong><br> 这个可选段格式与 [Uninstalldelete] 一样，除了它的条目处理在安装步骤之前。</p> 
<p><strong>[Languages] 段</strong><br> Inno Setup 支持多语言安装。[Languages] 段用来定义安装程序中可使用的语言。<br> 安装程序用下列顺序确定在消息中默认使用的语言:<br> 1. 搜索 LanguageID 设置的语言 (通常指定在语言文件 .isl 的 [LangOptions] 段) 匹配首选语言标识和当前用户界面语言或本地 (根据 LanguageDetectionMethod) 子语言标识两者。<br> 2. 如果未发现，只搜索匹配的首选语言标识。如果两个或多个可用文有相同的首选语言标识，它将使用在 [Languages] 段中列出的第一个。<br> 3. 如果未发现，默认为指定在 [Languages] 段的第一个语言。<br> 如果 [Setup] 段的 ShowLanguageDialog 指示设置为 yes (默认)，将显示一个选择语言对话框，使用户有机会忽略语言安装选择。<br> ShowLanguageDialog 指示设置为 yes (默认)，将显示一个选择语言对话框，使用户有机会忽略语言安装选择。<br> 下面是 [Languages] 段的一个示例。它定义两个语言: 简体中文，根据标准的汉化版的 Default.isl 文件，以及英语，原版的语言文件，汉化版中已包括。</p> 
<pre></pre> 
<table cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1<br> 2<br> 3</p> </td><td> <p>[Languages]<br> Name: "chs"; MessagesFile: "compiler:Default.isl"<br> Name: "en"; MessagesFile: "compiler:English.isl"</p> </td></tr></tbody></table> 
<p>Name (必需)<br> 描述:<br> 语言的内部名字，你可以设置为你喜欢的任何东西。这可以用作 [LangOptions] 或 [Messages] 段条目的前缀，使这些条目只用一种语言。{language} 常量返回选定语言的内部名字。<br> 示例:<br> Name: “en”<br> MessagesFile (必需)<br> 描述:<br> 指定要读取的默认消息的文件名。这个文件必须位于你的安装程序的来源目录，除非你指定了文件的完整路径或用“compiler:”作为前缀，在这种场合下它会在编译器目录下查找文件。<br> 当指定多个文件时，它按指定的顺序读取，因此最后的消息文件将覆盖前面的所有文件。<br> 查阅 [Messages] 段帮助主题获取 .isl 文件格式中的详细资料。<br> 示例:<br> MessagesFile: “compiler:Dutch.isl”<br> MessagesFile: “compiler:Default.isl,compiler:MyMessages.isl”<br> LicenseFile<br> 描述:<br> 指 定可选的许可协议文件名字，用 .txt 或 .rtf (富文本) 格式，它显示在用户选择程序的目标目录之前。在运行安装程序编译器时，这个文件必须位于你的安装程序的来源目录，除非你指定了文件的完整路径或用 “compiler:”作为前缀，在这种场合下它会在编译器目录下查找文件。<br> 示例:<br> LicenseFile: “license-Dutch.txt”<br> InfoBeforeFile<br> 描述:<br> 指 定可选的“自述”文件名字，用 .txt 或 .rtf (富文本) 格式，它显示在用户选择程序的目标目录之前。在运行安装程序编译器时，这个文件必须位于你的安装程序的来源目录，除非你指定了文件的完整路径或用 “compiler:”作为前缀，在这种场合下它会在编译器目录下查找文件。<br> 示例:<br> InfoBeforeFile: “infobefore-Dutch.txt”<br> InfoAfterFile<br> 描述:<br> 指 定可选的“自述”文件名字，用 .txt 或 .rtf (富文本) 格式，它显示在完成安装之后。在运行安装程序编译器时，这个文件必须位于你的安装程序的来源目录，除非你指定了文件的完整路径或用“compiler:” 作为前缀，在这种场合下它会在编译器目录下查找文件。<br> 这与 isreadme 文件不同，它里面的文字显示这一个向导页中，而不是一个单独的记事本窗口。<br> 示例:<br> InfoAfterFile: “infoafter-Dutch.txt”</p> 
<p><strong>[Messages] 段</strong><br> [Messages] 段用于定义显示在安装程序和卸载程序中的消息。通常，你不需要在你的脚本中创建 [Messages] 段，按默认，所有的消息在 Inno Setup 的 Default.isl 文件 (或在 [Languages] 段指定的条目) 中已经包含。<br> 但是，一些特殊的消息可 以用创建在脚本文件 [Messages] 段的内容覆盖。要覆盖消息，首先你需要知道你想更的消息 ID。这可以通过搜索 Default.isl 很容易地找到。例如，你想改变向导页“&amp;Next &gt;”按钮为“前进(&amp;F) &gt;”，此消息的 ID 是“ButtonNext”，所以你只要在 [Messages] 段写入下面的内容:<br> [Messages]<br> ButtonNext=前进(&amp;F) &gt;<br> 一 些消息包含变量，象 %1 和 %2。你可以重新排列变量顺序 (例如将 %2 移到 %1 之前)，也可以在需要的情况下重复使用同一变量 (例如“%1 … %1 %2”)。在带变量的消息中，使用两个连续的“%”字符，表示要置入单个“%”。“%n”表示换行符。<br> 如果你想翻译 所有 Inno Setup 的文本其它语言，而不是修改 Default.isl 或覆盖在你创建的所有脚本中的每个消息，将 Default.isl 复制一份，用其它名字象 MyTranslation.isl 命名。在你想使用 MyTranslation.isl 的安装程序中，创建一个 [Languages] 段 指向该文件。<br> 在一些场合中，这里有多个 [Languages] 段条目，在你的脚本中指定一个 [Messages] 段条目 (与 .isl 文件中指定的条目不同) 将按默认不考虑所有语言消息。要应用一个 [Messages] 段条目到只使用于一种语言，在语言的内部名字前加到前缀并跟随一个点。例如:<br> en.ButtonNext=前进(&amp;F) &gt;<br> 特殊用途标识<br> BeveledLabel 消息的特殊用途是可以用于指定显示在向导窗口和卸载程序窗口左下角的文本行，下面是一个示例:</p> 
<pre></pre> 
<table cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1<br> 2<br> 3<br> 4<br> 5<br> 6<br> 7<br> 8<br> 9</p> </td><td> <p>[Messages]<br> BeveledLabel=Inno Setup<br> [CustomMessages] 段<br> [CustomMessages] 段用于定义 {cm:...} 常量的自定义消息值。查阅常量帮助文档内容获取更多信息。<br> 从 [CustomMessages] 段使用 {cm:...} 常量获取的带描述的任务示例:<br> [CustomMessages]<br> createDesktopIcon=创建桌面快捷方式(&amp;D)<br> [Tasks]<br> Name: desktopicon; Description: "{cm:createDesktopIcon}"</p> </td></tr></tbody></table> 
<p>消息可以获取从 %1 到 %9 的声明。你可以重新排列它们的顺序 (例如，将 %2 移到 %1 之前)，也可以在需要时重复声明 (例如“%1 … %1 %2”)。在带声明的消息中，使用两个连续的“%”字符表示嵌入单个“%”。“%n”创建一个换行符。<br> 在 一些多个 [Languages] 段条目的场合下，在你的脚本中指定一个 [CustomMessages] 段条目 (对于 .isl 文件) 将按默认覆盖所有语言的消息。要只在一种语言中使用 [CustomMessages] 段条目，用语言的内部名字作为前缀，然后跟随一个句点。例如:<br> nl.createDesktopIcon=Maak een snelkoppeling op het &amp;bureaublad<br> 通常所有有下列自定义消息定义和每种语言的翻译已经包含在各自的语言 .isl 文件中 (以简体中文语言为例):</p> 
<pre></pre> 
<table cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1<br> 2<br> 3<br> 4<br> 5<br> 6<br> 7<br> 8<br> 9</p> </td><td> <p>NameAndVersion=%1 版本 %2<br> AdditionalIcons=附加快捷方式:<br> createDesktopIcon=创建桌面快捷方式(&amp;D)<br> createQuickLaunchIcon=创建快速运行栏快捷方式(&amp;Q)<br> ProgramOnTheWeb=%1 网站<br> UninstallProgram=卸载 %1<br> LaunchProgram=运行 %1<br> AssocFileExtension=将 %2 文件扩展名与 %1 建立关联(&amp;A)<br> AssocingFileExtension=正在将 %2 文件扩展名与 %1 建立关联...</p> </td></tr></tbody></table> 
<p>你可以在脚一中使用这些预定的自定义消息。下列是在 UninstallProgram 中使用的示例:<br> [Icons]<br> Name: “{group}\{cm:UninstallProgram,My Program}”; Filename: “{uninstallexe}”</p> 
<p><strong>[LangOptions] 段</strong><br> [LangOptions] 段用于定义特殊语言设置，象字体一样，被安装程序和卸载程序使用。通常，你不需要在你的脚本中创建 [LangOptions] 按默认，所有的特殊语言设置在 Inno Setup 的 Default.isl 文件 (或在 [Languages] 段指定的条目) 中已经包含。</p> 
<p>下面是 [LangOptions] 段的一个例子。(下面列出的设置是默认值。)</p> 
<pre></pre> 
<table cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1<br> 2<br> 3<br> 4<br> 5<br> 6<br> 7<br> 8<br> 9<br> 10<br> 11<br> 12</p> </td><td> <p>[LangOptions]<br> LanguageName=English<br> LanguageID=$0409<br> LanguageCodePage=0<br> DialogFontName=<br> DialogFontSize=8<br> WelcomeFontName=Verdana<br> WelcomeFontSize=12<br> TitleFontName=Arial<br> TitleFontSize=29<br> CopyrightFontName=Arial<br> CopyrightFontSize=8</p> </td></tr></tbody></table> 
<p>LanguageName 是语言的名字。它显示在多语言安装程序中的选择语言对话框可用语言列表中。它以 Unicode 字符形式 (在 NT 平台也是这样显示) 贮存在内部。要嵌入 Unicode 字符，使用“&lt;nnnn&gt;”，这里的“nnnn”是 4 位数的十六进制 Unicode 字符集。你可以在 Windows 2000 及更高版本中的附件中用字符映射表查找字符的 Unicode 字符集。</p> 
<p>LanguageID 是语言的数字化“语言标识”。查阅 http://msdn.microsoft.com/library/en-us/intl/nls_238z.asp 获取有效的语言标识列表。这是用来自动侦测默认使用的语言，请确保它格式使用正确，总是用一个“$”符号作为开头，因为语言标识是十六进制格式。</p> 
<p>LanguageCodePage 用来指定显示语言所需要的“代码页”。当在多语言安装的选择语言对话框中加上可用语言列表时，它的 LanguageCodePage 值与系统代码页进行比较以确定应该列出哪些语言。只有那些 LanguageCodePage 的值与系统代码页匹配的语言才能显示。目的是不显示在用户系统中不能正确显示的语言。例如，俄语文字不能在除代码页为 1251 的系统中正确显示，因此如果系统运行在其它代码页中，俄语没有必要列出。</p> 
<p>如果 LanguageCodePage 设为 0，该语言将总是在列表中列出，且不考虑系统的代码页。它可以判断在包含纯 ASCII 的语言中使用 0。例如象 English，因为 ASCII 同样可以在所有代码页中使用。</p> 
<p>DialogFontName 和 DialogFontSize 指定在对话框中使用的字体名和大小 (磅)。如果指定的字体名在用户系统中不存在，或是一个空字串，将用 8 磅大小的 Microsoft Sans Serif 或 MS Sans Serif 替换。</p> 
<p>WelcomeFontName 和 WelcomeFontSize 指定在欢迎向导页和安装完成向导页中的字体名和大小 (磅)。如果指定的字体名在用户系统中不存在，或是一个空的字符，将用 12 磅大小的 Microsoft Sans Serif 或 MS Sans Serif 替换。</p> 
<p>TitleFontName 和 TitleFontSize 指定在背景窗口顶部 (仅在 indowVisible=yes 时可见) 使用的字体名和大小 (磅)。如果指定的字体名在用户系统中不存在，将用 29 磅的 Arial 代替。如果指定的字体名是空的，将用 29 磅的 Microsoft Sans Serif 或 MS Sans Serif 代替。</p> 
<p>CopyrightFontName 和 CopyrightFontSize 指定在背景窗口中 AppCopyright 消息 (仅在 indowVisible=yes 时可见) 使用的字体名和大小 (磅)。如果指定的字体名在用户系统中不存在，将用 8 磅的 Arial 代替。如果指定的字体名是空的，将用 8 磅的 Microsoft Sans Serif 或 MS Sans Serif 代替。</p> 
<p>在有多个 [Languages] 段条目的情况下，在脚本中指定一个 [LangOptions] 段指示 (不同于 an .isl 文件) 将按默认不覆盖所有语言指示。要应用 [LangOptions] 段指示到其中一种语言，用语言的内部名字跟随一个点作为前缀。例如:</p> 
<p>en.LanguageName=English</p> 
<p><strong>[Registry] 段</strong><br> 这个可选段用来定义一些你想用安装程序在用户系统中创建、修改或删除的注册表键/值。<br> 按默认，用安装程序创建的注册表键和值在卸载时不删除。如果你想让卸载程序删除键或值，你必须包含下面 uninsdelete* 标记中的一个。</p> 
<pre></pre> 
<table cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1<br> 2<br> 3<br> 4<br> 5<br> 6</p> </td><td> <p>[Registry]<br> Root: HKCU; Subkey: "Software\My Company"; Flags: uninsdeletekeyifempty<br> Root: HKCU; Subkey: "Software\My Company\My Program"; Flags: uninsdeletekey<br> Root: HKLM; Subkey: "Software\My Company"; Flags: uninsdeletekeyifempty<br> Root: HKLM; Subkey: "Software\My Company\My Program"; Flags: uninsdeletekey<br> Root: HKLM; Subkey: "Software\My Company\My Program"; ValueType: string; ValueName: "InstallPath"; ValueData: "{app}"</p> </td></tr></tbody></table> 
<p>下列是所支持的参数列表:<br> Root (必需)<br> 描述:<br> 根键。必须是下列中的一个:<br> HKCR (HKEY_CLASSES_ROOT)<br> HKCU (HKEY_CURRENT_USER)<br> HKLM (HKEY_LOCAL_MACHINE)<br> HKU (HKEY_USERS)<br> HKCC (HKEY_CURRENT_CONFIG)<br> 示例:<br> Root: HKCU<br> Subkey (必需)<br> 描述:<br> 子键名，可以包含常量。<br> 示例:<br> Subkey: “Software\My Company\My Program”<br> ValueType<br> 描述:<br> 值的数据类型。必须是下面中的一个:<br> none<br> string<br> expandsz<br> multisz<br> dword<br> binary<br> 如果指定了 none （默认设置），安装程序将创建一个没有键值的键，在这种情况下，ValueName 和 ValueData 参数将被忽略。<br> 如果指定了 string，安装程序将创建一个字符串 （REG_SZ） 值。<br> 如果指定了 expandsz，安装程序将创建一个扩展字符串 （REG_EXPAND_SZ） 值。这种数据类型起初是用于 Windows NT/2000/XP 上，但是也支持 Windows 95/98/me。<br> 如果指定了 multisz，安装程序将创建一个多行文本 （REG_MULTI_SZ） 值。<br> 如果指定了 dword，安装程序将创建一个整数 （REG_DWORD） 值。<br> 如果指定了 binary，安装程序将创建一个二进制 （REG_BINARY） 值。<br> 示例:<br> ValueType: string<br> ValueName<br> 描述:<br> 要创建的值名，可以包含常量。如果是空白的，将写入到“默认”值。如果 ValueType 参数设置为 none，这个参数被忽略。<br> 示例:<br> ValueName: “Version”<br> ValueData<br> 描述:<br> 值 的数据。如果 ValueType 参数是 string，expandsz 或 ultisz，这是这一个可以包含常量的字符串。如果数据类型是 dword，这可以是一个十进制整数 (例如“123”)，一个十六进制整数 (例如“$7B”) 或解析为整数的常量。如果数据类型是 binary，这可以是下列形式的十六进制字节序列: “00 ff 12 34”。如果数据类型是 none，将被忽略。</p> 
<p>在 string，expandsz 或 multisz 类型值中，你可以在这个参数中使用一个特殊的常量调用 {olddata}。{olddata} 用先前的注册表值数据替换。如果你想添加一个字串到现有的值中，{olddata} 常量非常有用。例如，{olddata};{app}。如果该值不存在或现有的值不是一个字符串类型，{olddata} 常量将被删除。如果创建的值是一个 multisz 类型，但现有的值不是多行字符类型(例如，它是 REG_SZ 或 REG_EXPAND_SZ)，{olddata} 常量也将被删除。反这亦然。</p> 
<p>在 multisz 类型值中，你可以在参数中使用一个特殊常量调用 {break} 以插入换行符。<br> 示例:<br> ValueData: “1.0”<br> Permissions<br> 描述:<br> 指定登录注册表键 ACL (访问控制列表) 的附加权限。如果你不熟悉 ACL 或你不知道为什么要列改，不推荐你使用这个参数，因为误用会导致重大的系统安全问题。</p> 
<p>这个参数在用户必须运行 Windows 2000 或更高版本 (NT 4.0 由于 API 的问题不支持) 以及当前用户必须有更改注册表的权限时才有效。这些条件不满足时，不会显示错误消息，权限也不会被设置。</p> 
<p>这个参数应该只使用于你的应用程序特有的注册表键中。不要更改顶级键象 HKEY_LOCAL_MACHINE\SOFTWARE 的 ACL，否则你自己打开了用户系统的安全漏洞。</p> 
<p>指定的权限不考虑注册表键在安装前是否存在。如果 ValueType 是 none 和使用了 deletekey 或 deletevalue 标记时，不要设置这个权限。</p> 
<p>这个参数可以包含象下列格式一样一个或多个空格分隔的值:<br> &lt;用户或组标识&gt;-&lt;访问类型&gt;<br> 下面是 [Registry] 段支持的访问类型:<br> full<br> 同意“完全控制”许可，与修改相同 (看下面)，但又加上允许指定的用户/用户组获取注册表键所有权，并改变它的许可。通常保守的使用 modify 就足够了。<br> modify<br> 同意“修改”许可，允许指定的用户/用户组读取、修改和删除注册表值或子键。<br> read<br> 同意“读取和执行”许可，允许指定的用户/用户组读取注册表值或子键。<br> 示例:<br> Permissions: authusers-modify<br> Flags<br> 描述:<br> 这个参数是额外选项设置。多个选项可以使用空格隔开。支持下面的选项:<br> createvalueifdoesntexist<br> 当指定了这个标记，安装程序只在如果没有相同名字的值存在时创建值。如果值类型是 none，或如果你指定了 deletevalue 标记，这个标记无效。<br> deletekey<br> 当指定了这个标记，安装程序在如果条目存在的情况下，先将尝试删除它，包括其中的所有值和子键。如果 ValueType 不是 none，那么它将创建一个新的键和值。<br> 要防止意外，如果子键是空白的或只包含反斜框符号，安装时这个标记被忽略。<br> deletevalue<br> 当指定了这个标记，安装程序在如果值存在的情况下，先将尝试删除值，如果 ValueType 是 none，那么在键不存在的情况下，它将创建键以及新值。<br> dontcreatekey<br> 当指定了这个标记，如果键已经在用户系统中不存在，安装程序将不尝试创建键或值。如果键不存在，不显示错误消息。<br> 一般来说，这个键与 uninsdeletekey 标记组合使用，在卸载时删除键，但安装时不创建键。<br> noerror<br> 如果安装程序因任何原因创建键或值失败，不显示错误消息。<br> preservestringtype<br> 这 只在当 ValueType 参数是 string 或 expandsz 时适用。当指定这个标记，并且值不存在或现有的值不是 string 类型 (REG_SZ 或 REG_EXPAND_SZ)，它将用 ValueType 指定的类型创建。如果值存在，并且是 string 类型，它将用先存在值的相同值类型替换。<br> uninsclearvalue<br> 当卸载程序时，设置值数据为空字符 (类型 REG_SZ)。这个标记不能与 uninsdeletekey 标记组合使用。<br> uninsdeletekey<br> 当卸载程序时，删除整个键，包含其中的所有值和子键。这对于 Windows 自身使用的键明显不是一个好方法。你只能用于你的应用程序特有的键中。<br> 为防止意外，安装期间如果子键空白或只包含反斜框符号，这个标记被忽略。<br> uninsdeletekeyifempty<br> 当程序卸载时，如果这个键的内部没有值或子键，则删除这个键。这个标记可以与 uninsdeletevalue 组合使用。<br> 为防止意外，安装期间如果子键空白或只包含反斜框符号，这个标记被忽略。<br> uninsdeletevalue<br> 当程序卸载时删除该值。这个标记不能与 uninsdeletekeyifempty 组合使用。<br> 注意: 在早于 1.1 的 Inno Setup 版本中，你可以使用这个标记连同数据类型 none，那么它的功能与“如果空则删除键”标记一样。这个方法已经不支持了。你必须使用 uninsdeletekeyifempty 标记实现。<br> 示例:<br> Flags: uninsdeletevalue</p> 
<p><strong>[Run] &amp; [UninstallRun] 段</strong><br> [Run] 段是可选的，用来指定程序完成安装后、在安装程序显示最终对话框之前要执行的程序数，[UninstallRun] 段也可样是可选的，用来指定在卸载第一步要执行的程序数。除在下面有注释的外，两个段用相同的语法。<br> 程序按它们在脚本中的出现顺序执行。按默认，当处理 [Run]/[UninstallRun] 段条目时，安装程序/卸载程序将在处理下一个任务之前等待，直到程序终止。除非使用了 nowait，shellexec 或 waituntilidle 标记。<br> 注 意，按默认，如果 [Run] 段队列文件中的一个正在执行的程序要在下一次重新启动后替换 (通过调用 MoveFileEx 或通过修改 wininit.ini)，安装程序将进行侦测，并在安装结束后提示用户重新启动电脑。如果你不想这么做，设置 RestartIfNeededByRun 指示为 no。<br> 下面是 [Run] 段的一个示例。</p> 
<pre></pre> 
<table cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1<br> 2<br> 3<br> 4</p> </td><td> <p>[Run]<br> Filename: "{app}\INIT.EXE"; Parameters: "/x"<br> Filename: "{app}\README.TXT"; Description: "查看自述文件"; Flags: postinstall shellexec skipifsilent<br> Filename: "{app}\MYPROG.EXE"; Description: "运行应用程序"; Flags: postinstall nowait skipifsilent unchecked</p> </td></tr></tbody></table> 
<p>下列是所支持的参数列表:<br> Filename (必需)<br> 描述:<br> 要执行的程序，或要打开的文件/文件夹。如果 Filename 不是一个可执行文件 (.exe 或 .com) 或批处理文件 (.bat 或 .cmd)，你必须在条目中使用 the shellexec 标记。这个参数可以包含常量。<br> 示例:<br> Filename: “{app}\INIT.EXE”<br> Description<br> 描述:<br> 仅在 [Run] 段有效。这是条目的描述，可以包含常量。这个描述用于带 postinstall 标记的条目。如果条目的描述未指定，安装程序将使用一个默认描述。这个描述根据条目的类型(normal 或 shellexec)。<br> 示例:<br> Description: “查看自述文件”<br> Parameters<br> 描述:<br> 程序的可选命令行参数，可以包含常量。<br> 示例:<br> Parameters: “/x”<br> WorkingDir<br> 描述:<br> 指定程序在哪个目录启动。如果这个参数未指定或是空白的，它使用 Filename 参数中的目录。如果 Filename 不包含路径，它将使用默认目录。这个参数可以包含常量。<br> 示例:<br> WorkingDir: “{app}”<br> StatusMsg<br> 描述:<br> 仅在 [Run] 段有效。确定程序执行时显示在向导页的消息。如果这个参数未指定可是空白的，将使用默认的消息“正在完成安装…”。这个参数可以包含常量。<br> 示例:<br> StatusMsg: “正在安装 BDE…”<br> RunOnceId<br> 描述:<br> 仅 在 [UninstallRun] 段有效。如果已经安装了相同的应用程序，卸载日志文件中的“run”条目将被复制一个副本。通过分配一个字符给 RunOnceId，可以确保在卸载期间特殊的 [UninstallRun] 条目只执行一次。例如，如果卸载日志中有两个或更多“run”条目用“DelService”的 RunOnceId 设置，只执行最后一个用“DelService”的 RunOnceId 设置的条目；其它的将被忽略。注意 RunOnceId 比校是区分大小写的。<br> 示例:<br> RunOnceId: “DelService”<br> Flags<br> 描述:<br> 这个参数是额外选项设置。多个选项可以使用空格隔开。支持下面的选项:<br> hidewizard<br> 如果指定了这个标记，向导将在程序运行期间隐藏。<br> nowait<br> 如果指定了这个标记，它将在处理下一个 [Run] 条目前或完成安装前不等待进程执行完成。不能与 waituntilidle 或 waituntilterminated 组合使用。<br> postinstall<br> 仅在 [Run] 段有效。告诉安装程序在安装完成向导页创建一个选择框，用户可以选中或不选中这个选择框从而决定是否处理这个条目。以前这个标记调用 showcheckbox。<br> 如果安装程序已经重新启动了用户的电脑 (安装了一个带 restartreplace 标记的文件或如果 [Setup] 段的 AlwaysRestart 指示是 yes 引起的)，选择框没有机会出现，因此这些条目不会被处理。<br> [Files] 段条目中的 isreadme 标记现在已被废弃。如果编译器带 isreadme 标记的条目，它将从 [Files] 段条目中忽略这个标记，并在 [Run] 段条目列表的开头插入一个生成的 [Run] 条目。这相生成的 [Run] 段条目运行自述文件，并带有 shellexec、skipifdoesntexist、postinstall 和 skipifsilent 标记。<br> runhidden<br> 如果指定了这个标记，它将在隐藏窗口中运行程序。请在执行一个要提示用户输入的程序中不要使用这个标记。<br> runmaximized<br> 如果指定了这个标记，将在最大化窗口运行程序或文档。<br> runminimized<br> 如果指定了这个标记，将在最小化窗口运行程序或文档。<br> shellexec<br> 如果 Filename 不是一个直接可执行文件 (.exe 或 .com 文件)，这个标记是必需的。当设置这个标记时，Filename 可以是一个文件夹或任何已注册的文件类型 — 包括 .hlp，.doc 等。<br> 该文件将用用户系统中与这个文件类型关联的应用程序打开，与在资源管理器双击文件的方法是相同的。<br> 按默认，当使用 shellexec 标记时，将不等待，直到生成的进程终止。<br> 如果你需要，你必须添加标记 waituntilterminated。注意，如果新进程未生成，它不能执行也将不等待 — 例如，文件指定指定为一个文件夹。<br> skipifdoesntexist<br> 如果这个标记在 [Run] 段中指定，如果文件名不存在，安装程序不显示错误消息。<br> 如果这个标记在 [UninstallRun] 段中指定，如果文件名不存在，卸载程序不显示“一些元素不能删除”的警告。<br> skipifnotsilent<br> 仅在 [Run] 段有效。告诉安装程序如果安装程序未在后台运行则跳过这个条目。<br> skipifsilent<br> 仅在 [Run] 段有效。告诉安装程序如果安装程序在后台运行则跳过这个条目。<br> unchecked<br> 仅在 [Run] 段有效。告诉安装程序初始为不选中选择框。如果用户希望处理这个条目，可以通过选取选择框执行。如果 postinstall 标记未同时指定，这个标记被忽略。<br> waituntilidle<br> 如果指定了这个标记，它将在未输入期间等待，直到进程等待用户输入，而不是等待进程终止。(调用 WaitForInputIdle Win32 函数。) 不能与 nowait 或 waituntilterminted 组合使用。<br> waituntilterminated<br> 如果指定这个标记，将等待到进程完全终止。注意这是一个默认动作 (也就是你不需要指定这个标记)，除非你使用了 shellexec 标记，在这种情况下，如果你要等待，需要指定这个标记。不能与 nowait 或 waituntilidle 组合使用。<br> 示例:<br> Flags: postinstall nowait skipifsilent<br> [Uninstalldelete] 段<br> 这个可选段定义你想让卸载程序删除除用 [Files] 或 [Dirs] 条目安装/创建外的其它文件或目录，或由你应用程序创建的一些公共使用的 .INI 文件。卸载程序在卸载时最后一步处理这些条目。<br> 这里是 [Uninstalldelete] 段的一个示例:<br> [Uninstalldelete]<br> Type: files; Name: “{win}\MYPROG.INI”<br> 下列是所支持的参数列表:<br> Type (必需)<br> 描述:<br> 指定卸载程序要删除的是什么。必须是下面中的一个:<br> files<br> 该名字参数指定一个详细的文件名，或带通配符的文件名。<br> filesandordirs<br> 除同时还匹配目录名外，功能与 files 相同，并删除任何名字匹配的目录以及包含它们中的所有文件和子目录。<br> dirifempty<br> 当使用这个参数时，名字参数必须是目录名，但它不能包含通配符。该目录只在不包含任何文件或子目录的情况下才被删除。<br> 示例:<br> Type: files<br> Name (必需)<br> 描述:<br> 要删除的文件或目录名。<br> 注 意: 不要尝试在这里使用通配符用来删除 {app} 目录中的所有文件。我强烈推荐你不要这么做有两个原因。首先，用户通常不希望将他们放置在应用程序目录中的数据文件在没有警告的情况下被删除 (例如，如果用户将它移动到其它驱动器，那么有些不用删除的内容将被卸载)。最好是保留它让最终用户在卸载后手动删除。同时，如果用户由于过失刚好将程序 安装在危险的目录(例如，C:\WINDOWS)，如果这时卸载将后果严重。再说一遍，不要这么做!<br> 示例:<br> Name: “{win}\MYPROG.INI”<br> 8、Pascal脚本<br> 介绍<br> Pascal 脚本功能 (modern Delphi-like Pascal) 增加了许多新的功能定制你的安装程序和卸载程序，一些例子:<br> 支持自定义条件的情况下的中断安装和卸载。<br> 支持的安装程序运行时添加自定义向导页。<br> 在安装前、安装期间、安装后从 Pascal 脚本提取或调用 DLL 或其它文件。<br> 支持当作任何普通常量的脚本化常量，从注册表读取，从 ini 读取和从命令行读取常量等。<br> 支持运行时自定义条件下的类型、组件和/或任务的删除。<br> 根据自定义条件支持有条件的 [Files]、[Registry]、[Run] 等条目安装。<br> 几乎 Inno Setup 自身可以执行的许多支持函数来自 Pascal 脚本。<br> 也可以使用一个完整的 run-time 调试器调试你的自定义 Pascal 脚本。<br> 用于 Inno Setup 的脚本引擎是来自 Innerfuse 的 Carlo Kok 编写的 Innerfuse Pascal 脚本，Innerfuse Pascal 脚本是免费使用，并带有源代码。查阅 http://www.remobjects.com/?ps<br> 获取更多信息。<br> 创 建 [code] 段[code] 段是一个可选的指定 Pascal 脚本的段。Pascal 脚本可以用于通过多种方法定制安装程序或卸载程序。请注意，创建 Pascal 脚本不是很方便，需要有丰富的 Inno Setup 使用经验，以及 Pascal 或至少一种其它类型语言的设计知识。<br> Inno Setup 目录的“Examples”子目录下有一些“Code*.iss”和“UninstallCode*.iss”文件，包含各种 [code] 段的使用示例。请在创建你自己的 Pascal 脚本前仔细学习。<br> 注意: 要学习更多 Pascal 程序语言，你可查找一些有用的 Marco Cantu 免费的基本 Pascal 书籍。<br> 事件函数<br> Pascal 脚本可以包含单独的在适当时间调用的事件函数，对于安装程序，它们是:<br> function InitializeSetup(): Boolean;<br> 在安装程序初始化时调用，返回 False 中断安装，返回 True 反之。<br> procedure InitializeWizard();<br> 使用这个事件函数启动时改变向导或向导页。你不能在它触发之后使用 InitializeSetup 事件函数，向导窗体不退出。<br> procedure DeinitializeSetup();<br> 仅在安装程序终止前调用。注意这个函数在即使用户在任何内容安装之前退出安装程序时也会调用。<br> procedure CurStepChanged(CurStep: TSetupStep);<br> 你可以用这个事件函数执行你自己的预安装和安装后任务。<br> 在实际安装开始之前用 CurStep=ssInstall 调用，或在实际安装完成之后用 CurStep=ssPostInstall 调用，或在安装程序终止之前和安装完成之后用 CurStep=ssDone 调用。<br> function NextButtonClick(CurPageID: Integer): Boolean;<br> 当用户单击下一步按钮时调用。如果你返回 True，向导将移到下一页；如果返回 False，它仍保留在当前页 (用 CurPageID 指定)。<br> 注意，这个函数在静寂安装时也会调用，即使没有下一步按钮让用户单击。安装程序会模拟单击下一步按钮。在静寂安装中，如果你的 NextButtonClick 函数在安装之前返回 False，安装程序将自动退出。<br> function BackButtonClick(CurPageID: Integer): Boolean;<br> 当用户单击上一步按钮时调用。如果你返回 True，向导将移到上一页；如果返回 False，它仍保留在当前页 (用 CurPageID 指定)。<br> procedure CancelButtonClick(CurPageID: Integer; var Cancel, Confirm: Boolean);<br> 当 用户单击取消按钮或单击窗口中的关闭按钮时调用。Cancel 参数指定是否是一般的取消进程；默认为 True。Confirm 参数指定是否显示“退出安装程序吗？”的消息框；一般它默认为 True。如果 Cancel 设为 False，那么 Confirm 值被忽略。<br> function ShouldSkipPage(PageID: Integer): Boolean;<br> 向导调用这个事件函数确定是否在所有页或不在一个特殊页 (用 PageID 指定) 显示。如果返回 True，将跳过该页；如果你返回 False，该页被显示。<br> 注意: 这个事件函数不被 wpWelcome、wpPreparing 和 wpInstalling 页调用，还有安装程序已经确定要跳过的页也不会调用 (例如，没有包含组件安装程序的 wpselectComponents)。<br> procedure CurPageChanged(CurPageID: Integer);<br> 在新向导页 (用 CurPageID 指定) 显示后调用。<br> function CheckPassword(Password: String): Boolean;<br> 如果安装程序在 Pascal 脚本中发现 CheckPassword 事件函数，它自动显示密码页并调用 CheckPassword 检查密码。返回 True 表示接受密码，返回 False 拒绝。<br> 要避免在编译的安装程序的 [code] 段内部贮存真实的密码，你应该用其它无用的信息进行比较: 计算你自己密码的 MD5 的无用信息，然后编译到 GetMD5OfString(Password)。通过这种方法保护实际密码值。<br> 注意: 如果你已经用 CheckPassword 事件函数，并且你的用户带“/PASSWORD=”和“/SILENT”安装命令行参数运行安装程序，你的 CheckPassword 函数将在其它事件函数调用之前调用，包括 InitializeSetup。<br> function NeedRestart(): Boolean;<br> 返回 True 告诉安装程序提示用户在安装结束时重新启动系统，False 则反之。<br> function updateReadyMemo(Space, NewLine, MemoUserInfoInfo, MemoDirInfo, MemoTypeInfo, MemoComponentsInfo, MemoGroupInfo, MemoTasksInfo: String): String;<br> 如果安装程序在 Pascal 脚本中发现 updateReadyMemo 事件函数，当准备安装向导页变为激活页时自动调用。它返回的文字显示在准备安装向导页的备注注册中，该文字是用 NewLine 参数换行的字符。参数空间包含一个带安全可靠的字符。其它参数将包含安装程序用于设置段的字符 (可能是空的)。MemoDirInfo 参数包含象选择目录段的字符。<br> procedure RegisterPreviousData(PreviousDataKey: Integer);<br> 要在自定义向导页中贮存用户输入的设置，在 Pascal 脚本中放入一个 RegisterPreviousData 事件函数，并调用 SetPreviousData(PreviousDataKey, …) 替换它，每个设置一次。<br> function CheckSerial(Serial: String): Boolean;<br> 如 果安装程序在 Pascal 脚本中发现 CheckSerial 事件函数，将在用户信息向导页中自动出现一个序列号对象 (必须在你的 [Setup] 段中使用 UserInfoPage=yes!)。返回 True 表示接受序列号，返回 False 拒绝。当使用序列号时，请一定要记住，这个软件无加密可言，况且 Inno Setup 源代码是免费获取的，它对于有经验的人从安装程序中删除序列号保护并不是很困难的事。使用这个只是方便用户在你的应用程序中仔细检查输入的序列号 (贮存在 {userinfoserial} 常量)。<br> function GetCustomSetupExitCode: Integer;<br> 返回一个非零值命令安装程序返回一个自定义退出代码。这个函数只在安装程序运行完成并且退出代码已是零时调用。同时请查阅安装退出代码。<br> 对于卸载程序，它们是:<br> function InitializeUninstall(): Boolean;<br> 返回 False 中断卸载，True 则反之。<br> procedure DeinitializeUninstall();<br> procedure CurUninstallStepChanged(CurUninstallStep: TUninstallStep);<br> function UninstallNeedRestart(): Boolean;<br> 返回 True 命令卸载程序提示用户在卸载完成后重新启动系统，False 则反之。<br> 这里是这些函数使用的常量列表:<br> CurStep values<br> ssInstall, ssPostInstall, ssDone<br> CurUninstallStep values<br> usAppMutexCheck, usUninstall, usPostUninstall, usDone<br> 预定义向导页 CurPageID values<br> wpWelcome, wpLicense, wpPassword, wpInfoBefore, wpUserInfo, wpselectDir, wpselectComponents, wpselectProgramGroup, wpselectTasks, wpReady, wpPreparing, wpInstalling, wpInfoAfter, wpFinished<br> 这些函数不需要在 Pascal 脚本中出现。<br> 脚本化常量<br> Pascal 脚本可以包含当安装程序想知道脚本化的 {code:…} 常量的值时调用的函数，调用的函数必须有 1 个名为 Param 的字符串参数，并且必须返回一个字符串值。<br> {code:…} 常量语法是: {code:FunctionName|Param}<br> FunctionName 指定 Pascal 脚一函数的名字。<br> Param 指定用于函数的字符参数。如果你省略 Param，将使用一个空字符串。<br> 如 果你想在常量内部包含一个逗号，垂直条(“|”)，或括弧 (“}”)，你必须通过“%-encoding”避开它。用“%”字符串替换该字符串，后面再跟随它的两位数的十六进制代码。逗号是“%2c”，垂直条是 “%7c”，括弧是“%7d”。如果你想包含一个实际的“%”字符串，使用“%25”。<br> Param 可以包含常量。请注意，你不需要将常量的括弧替换为上面所说的结构；它只在别处使用时才需要替换。<br> 示例:<br> DefaultDirName={code:MyConst}\My Program<br> 这里是一个包含上述使用的函数的 [code] 段的示例。[code]function MyConst(Param: String): String;<br> begin<br> Result := ExpandConstant(‘{pf}’);<br> end;<br> 如果通过 {code:…} 常量指定的函数不包含在 [code] 段，它必须是一个支持的函数。这是一个示例。<br> [INI]<br> FileName: “{app}\MyIni.ini”; Section: “MySettings”; Key: “ShortApp”; String: “{code:GetShortName|{app}}”<br> 检查参数<br> 这里是一个被所有段中被参数分开的条目支持的可选参数这就是:<br> Check<br> 描述:<br> 确定是否被处理或不处理的检查函数名。函数必须是一个 [code] 段中的自定义函数或支持函数。<br> 除单一的名字外，你也可以使用 boolean 表达式。披阅组件和任务参数获取 boolean 表达式的详细资料。<br> 对于每个检查函数，可以包含一个安装程序用于检查函数的逗号隔开的参数列表。允许的参数类型是字符串，整数和布尔数。字符串参数可以包含常量。<br> 这是一个可以从参数列表内部调用的支持函数: ExpandConstant。<br> 示例:</p> 
<pre></pre> 
<table cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1<br> 2<br> 3<br> 4</p> </td><td> <p>[Files]<br> Source: "MYPROG.EXE"; DestDir: "{app}"; Check: MyProgCheck<br> Source: "A\MYFILE.TXT"; DestDir: "{app}"; Check: MyDirCheck({app}\A)<br> Source: "B\MYFILE.TXT"; DestDir: "{app}"; Check: MyDirCheck({app}\B)</p> </td></tr></tbody></table> 
<p>所有检查函数必须有一个布尔返回值。如果检查函数 (或布尔表达式) 返回 True，那么条目将被处理，否则跳过<br> 安装程序可能随时调用检查函数，即使只有一个条目使用检查函数。如果你的函数执行一个长的代码段，你可以通过在全局变量中“缓冲”结果执行代码来优化它。<br> 如果安装程序已经确定不处理条目，那么检查函数不被调用。<br> 这里是上述使用的包含检查函数的 [code] 段的示例。函数 DirExists 是支持函数，因此不包含在这个 [code] 段内。</p> 
<pre></pre> 
<table cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1<br> 2<br> 3<br> 4<br> 5<br> 6<br> 7<br> 8<br> 9<br> 10<br> 11<br> 12<br> 13<br> 14<br> 15<br> 16</p> </td><td> <p>[code]<br> var<br> MyProgChecked: Boolean;<br> MyProgCheckResult: Boolean;<br> function MyProgCheck(): Boolean;<br> begin<br> if not MyProgChecked then begin<br> MyProgCheckResult := MsgBox('Do you want to install MyProg.exe to ' + ExtractFilePath(CurrentFileName) + '?', mbConfirmation, MB_YESNO) = idYes;<br> MyProgChecked := True;<br> end;<br> Result := MyProgCheckResult;<br> end;<br> function MyDirCheck(DirName: String): Boolean;<br> begin<br> Result := DirExists(DirName);<br> end;</p> </td></tr></tbody></table> 
<p>BeforeInstall 和 AfterInstall 参数<br> 这里有两个可选的被除 [Types]、[Components] 和 [Tasks] 之外的所有段中的那些分隔到参数中的条目支持的参数。它们是:<br> BeforeInstall<br> 描述:<br> 该函数名只在条目安装之前调用一次。该函数必须是 [code] 段的自定义函数或一个支持函数。可以包含一个安装程序用于函数的逗号隔开的参数列表。允许的参数类型是字符、整数和布尔数。字符参数可以包含常量。<br> 这里是一个可以从参数列表内部调用的支持函数: ExpandConstant。<br> 示例:</p> 
<pre></pre> 
<table cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1<br> 2<br> 3<br> 4<br> 5<br> 6</p> </td><td> <p>[Files]<br> Source: "MYPROG.EXE"; DestDir: "{-app}"; BeforeInstall: MyBeforeInstall<br> Source: "A\MYFILE.TXT"; DestDir: "{-app}"; BeforeInstall: MyBeforeInstall2('{-app}\A\MYFILE.TXT')<br> Source: "B\MYFILE.TXT"; DestDir: "{-app}"; BeforeInstall: MyBeforeInstall2('{-app}\B\MYFILE.TXT')<br> Source: "MYPROG.HLP"; DestDir: "{-app}"; BeforeInstall: Log('Before MYPROG.HLP Install')<br> AfterInstall</p> </td></tr></tbody></table> 
<p>描述:<br> 该函数名只在条目安装之后调用一次。该函数必须是 [code] 段的自定义函数或一个支持函数。可以包含一个安装程序用于函数的参数。这个参数可以包含常量。<br> 示例:</p> 
<pre></pre> 
<table cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1<br> 2<br> 3<br> 4<br> 5</p> </td><td> <p>[Files]<br> Source: "MYPROG.EXE"; DestDir: "{-app}"; AfterInstall: MyAfterInstall<br> Source: "A\MYFILE.TXT"; DestDir: "{-app}"; AfterInstall: MyAfterInstall2('{-app}\A\MYFILE.TXT')<br> Source: "B\MYFILE.TXT"; DestDir: "{-app}"; AfterInstall: MyAfterInstall2('{-app}\B\MYFILE.TXT')<br> Source: "MYPROG.HLP"; DestDir: "{-app}"; AfterInstall: Log('After MYPROG.HLP Install')</p> </td></tr></tbody></table> 
<p>所有 BeforeInstall 和 AfterInstall 函数不需要有返回值。<br> 如果安装程序已经确认不处理条目，则不调用 BeforeInstall 或 AfterInstall 函数。<br> 这里是一个包含上述函数使用的 [code] 段示例，函数 Log 是一个支持函数，因此不包含在这个 [code] 段。</p> 
<pre></pre> 
<table cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1<br> 2<br> 3<br> 4<br> 5<br> 6<br> 7<br> 8<br> 9<br> 10<br> 11<br> 12<br> 13<br> 14<br> 15<br> 16<br> 17</p> </td><td> <p>[code]<br> procedure MyBeforeInstall();<br> begin<br> MsgBox('About to install MyProg.exe as ' + CurrentFileName + '.', mbInformation, MB_OK);<br> end;<br> procedure MyBeforeInstall2(FileName: String);<br> begin<br> MsgBox('About to install ' + FileName + ' as ' + CurrentFileName + '.', mbInformation, MB_OK);<br> end;<br> procedure MyAfterInstall();<br> begin<br> MsgBox('Just installed MyProg.exe as ' + CurrentFileName + '.', mbInformation, MB_OK);<br> end;<br> procedure MyAfterInstall2(FileName: String);<br> begin<br> MsgBox('Just installed ' + FileName + ' as ' + CurrentFileName + '.', mbInformation, MB_OK);<br> end;</p> </td></tr></tbody></table> 
<p>卸载代码<br> Pascal 脚本也可以包含卸载时调用的代码。查看事件函数主题获取更多信息。<br> 当 设计在卸载时执行的代码时，这是你所要知道的重要内容: 当彼此安装多个版本的应用程序时，卸载时只运行一个 Pascal 脚本。一般来说，脚本从最近安装的进行选择。如果这样，会卸载最新版本的应用程序，你最新版本的 Inno Setup 会被降级。相似情况，当安装较老版本的应用程序时，有可能会覆盖新版本的应用程序。<br> 当生成其它安装程序的补丁安装程序时，补丁安装程序将与原始安 装程序共享相同的卸载日志 (就象 Uninstallable 设为 yes 以及 AppId 设置为与原始安装程序相同)，确保补丁包含与原始安装程序完整的 [code] 段副本，否则，卸载时不会运行代码。<br> 可是，补丁安装程序中 Uninstallable 设为 no，那么安装程序不用知道现有的卸载程序或卸载日志，在这种情况下，补丁安装程序不需要包含与原始安装程序的 [code] 段副本。<br> 示例<br> Pascal Scripting 示例脚本位于单独的文件。打开 Inno Setup 安装目录下的“Examples”子目录中的“Code*.iss”文件中的一个。<br> 支持的函数参考<br> 这里是可以从 Pascal 脚本内部调用的支持的函数列表。<br> 安装或卸载信息函数</p> 
<pre></pre> 
<table cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1<br> 2<br> 3<br> 4<br> 5<br> 6<br> 7<br> 8<br> 9<br> 10<br> 11<br> 12<br> 13<br> 14<br> 15<br> 16<br> 17<br> 18<br> 19<br> 20<br> 21<br> 22<br> 23</p> </td><td> <p>function GetCmdTail: String;<br> function ParamCount: Integer;<br> function ParamStr(Index: Integer): String;<br> function ActiveLanguage: String;<br> function SetupMessage(const ID: TSetupMessageID): String;<br> function WizardDirValue: String;<br> function WizardGroupValue: String;<br> function WizardNoIcons: Boolean;<br> function WizardSetupType(const Description: Boolean): String;<br> function WizardselectedComponents(const Descriptions: Boolean): String;<br> function WizardselectedTasks(const Descriptions: Boolean): String;<br> function WizardSilent: Boolean;<br> function IsUninstaller: Boolean;<br> function UninstallSilent: Boolean;<br> function CurrentFileName: String;<br> function ExpandConstant(const S: String): String;<br> function ExpandConstantEx(const S: String; const CustomConst, CustomValue: String): String;<br> function IsComponentselected(const Components: String): Boolean;<br> function IsTaskselected(const Tasks: String): Boolean;<br> function ExtractTemporaryFile(const FileName: String);<br> function GetPreviousData(const ValueName, DefaultValueData: String): String;<br> function SetPreviousData(const PreviousDataKey: Integer; const ValueName, ValueData: String): Boolean;<br> function Terminated: Boolean;</p> </td></tr></tbody></table> 
<p>排除函数</p> 
<pre></pre> 
<table cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1<br> 2<br> 3<br> 4</p> </td><td> <p>procedure Abort;<br> procedure RaiseException(const Msg: String);<br> function GetExceptionMessage: String;<br> procedure ShowExceptionMessage;</p> </td></tr></tbody></table> 
<p>系统函数</p> 
<pre></pre> 
<table cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1<br> 2</p> </td><td> <p>function IsAdminLoggedOn: Boolean;<br> function IsPowerUserLoggedOn: Boolean;</p> </td></tr></tbody></table> 
<p>函数必须有 1 个名为 Param 的字符串参数，并且必须返回一个字符串值。<br> {code:…} 常量语法是: {code:FunctionName|Param}<br> FunctionName 指定 Pascal 脚一函数的名字。<br> Param 指定用于函数的字符参数。如果你省略 Param，将使用一个空字符串。<br> 如 果你想在常量内部包含一个逗号，垂直条(“|”)，或括弧 (“}”)，你必须通过“%-encoding”避开它。用“%”字符串替换该字符串，后面再跟随它的两位数的十六进制代码。逗号是“%2c”，垂直条是 “%7c”，括弧是“%7d”。如果你想包含一个实际的“%”字符串，使用“%25”。<br> Param 可以包含常量。请注意，你不需要将常量的括弧替换为上面所说的结构；它只在别处使用时才需要替换。<br> 示例:<br> DefaultDirName={code:MyConst}\My Program<br> 这里是一个包含上述使用的函数的 [code] 段的示例。[code]function MyConst(Param: String): String;<br> begin<br> Result := ExpandConstant(‘{pf}’);<br> end;<br> 如果通过 {code:…} 常量指定的函数不包含在 [code] 段，它必须是一个支持的函数。这是一个示例。<br> [INI]<br> FileName: “{app}\MyIni.ini”; Section: “MySettings”; Key: “ShortApp”; String: “{code:GetShortName|{app}}”<br> 检查参数<br> 这里是一个被所有段中被参数分开的条目支持的可选参数这就是:<br> Check<br> 描述:<br> 确定是否被处理或不处理的检查函数名。函数必须是一个 [code] 段中的自定义函数或支持函数。<br> 除单一的名字外，你也可以使用 boolean 表达式。披阅组件和任务参数获取 boolean 表达式的详细资料。<br> 对于每个检查函数，可以包含一个安装程序用于检查函数的逗号隔开的参数列表。允许的参数类型是字符串，整数和布尔数。字符串参数可以包含常量。<br> 这是一个可以从参数列表内部调用的支持函数: ExpandConstant。<br> 示例:</p> 
<pre></pre> 
<table cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1<br> 2<br> 3<br> 4</p> </td><td> <p>[Files]<br> Source: "MYPROG.EXE"; DestDir: "{app}"; Check: MyProgCheck<br> Source: "A\MYFILE.TXT"; DestDir: "{app}"; Check: MyDirCheck({app}\A)<br> Source: "B\MYFILE.TXT"; DestDir: "{app}"; Check: MyDirCheck({app}\B)</p> </td></tr></tbody></table> 
<p>所有检查函数必须有一个布尔返回值。如果检查函数 (或布尔表达式) 返回 True，那么条目将被处理，否则跳过。</p> 
<pre></pre> 
<table cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1<br> 2<br> 3<br> 4<br> 5<br> 6<br> 7<br> 8<br> 9<br> 10<br> 11<br> 12<br> 13<br> 14<br> 15<br> 16<br> 17<br> 18<br> 19<br> 20<br> 21<br> 22<br> 23<br> 24<br> 25<br> 26<br> 27<br> 28<br> 29<br> 30</p> </td><td> <p>string): Integer;<br> function Format1(const Format, S1: String): String;<br> function Format2(const Format, S1, S2: String): String;<br> function Format3(const Format, S1, S2, S3: String): String;<br> function Format4(const Format, S1, S2, S3, S4: String): String;<br> function Trim(const S: string): String;<br> function TrimLeft(const S: string): String;<br> function TrimRight(const S: string): String;<br> function StrToIntDef(s: string; def: Longint): Longint;<br> function StrToInt(s: string): Longint;<br> function IntToStr(i: Longint): String;<br> function CharLength(const S: String; const Index: Integer): Integer;<br> function AddBackslash(const S: String): String;<br> function RemoveBackslashUnlessRoot(const S: String): String;<br> function RemoveBackslash(const S: String): String;<br> function AddPeriod(const S: String): String;<br> function ExtractFileExt(const FileName: string): String;<br> function ExtractFileDir(const FileName: string): String;<br> function ExtractFilePath(const FileName: string): String;<br> function ExtractFileName(const FileName: string): String;<br> function ExtractFileDrive(const FileName: string): String;<br> function ExtractRelativePath(const BaseName, DestName: String): String;<br> function ExpandFileName(const FileName: string): String;<br> function ExpandUNCFileName(const FileName: string): String;<br> function GetDateTimeString(const DateTimeFormat: String; const DateSeparator, TimeSeparator: Char): String;<br> procedure SetLength(var S: String; L: Longint);<br> procedure CharToOemBuff(var S: String);<br> procedure OemToCharBuff(var S: String);<br> function GetMD5OfString(const S: String): String;<br> function SysErrorMessage(ErrorCode: Integer): String;</p> </td></tr></tbody></table> 
<p>排列函数</p> 
<pre></pre> 
<table cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1<br> 2</p> </td><td> <p>function GetArrayLength(var Arr: Array): Longint;<br> procedure SetArrayLength(var Arr: Array; I: Longint);</p> </td></tr></tbody></table> 
<p>文件系统函数</p> 
<pre></pre> 
<table cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1<br> 2<br> 3<br> 4<br> 5<br> 6<br> 7<br> 8<br> 9<br> 10<br> 11<br> 12<br> 13<br> 14<br> 15<br> 16<br> 17<br> 18<br> 19<br> 20<br> 21<br> 22</p> </td><td> <p>function DirExists(const Name: String): Boolean;<br> function FileExists(const Name: String): Boolean;<br> function FileOrDirExists(const Name: String): Boolean;<br> function FileSize(const Name: String; var Size: Integer): Boolean;<br> function GetSpaceOnDisk(const Path: String; const InMegabytes: Boolean; var Free, Total: Cardinal): Boolean;<br> function FileSearch(const Name, DirList: string): String;<br> function FindFirst(const FileName: String; var FindRec: TFindRec): Boolean;<br> function FindNext(var FindRec: TFindRec): Boolean;<br> procedure FindClose(var FindRec: TFindRec);<br> function GetCurrentDir: String;<br> function SetCurrentDir(const Dir: string): Boolean;<br> function GetWinDir: String;<br> function GetSystemDir: String;<br> function GetTempDir: String;<br> function GetShellFolder(Common: Boolean; const ID: TShellFolderID): String;<br> function GetShellFolderByCSIDL(const Folder: Integer; const create: Boolean): String;<br> function GetShortName(const LongName: String): String;<br> function GenerateUniqueName(Path: String; const Extension: String): String;<br> function GetVersionNumbers(const Filename: String; var VersionMS, VersionLS: Cardinal): Boolean;<br> function GetVersionNumbersString(const Filename: String; var Version: String): Boolean;<br> function IsProtectedSystemFile(const Filename: String): Boolean;<br> function GetMD5OfFile(const Filename: String): String;</p> </td></tr></tbody></table> 
<p>文件函数</p> 
<pre></pre> 
<table cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1<br> 2<br> 3<br> 4<br> 5<br> 6<br> 7<br> 8<br> 9<br> 10<br> 11<br> 12<br> 13<br> 14<br> 15<br> 16<br> 17<br> 18<br> 19<br> 20<br> 21<br> 22<br> 23<br> 24<br> 25<br> 26</p> </td><td> <p>function Exec(function GetShellFolderByCSIDL(const Folder: Integer; const create: Boolean): String;<br> const Filename, Params, WorkingDir: String; const ShowCmd: Integer; const Wait: TExecWait; var ResultCode: Integer): Boolean;<br> function ShellExec(const Verb, Filename, Params, WorkingDir: String; const ShowCmd: Integer; const Wait: TExecWait; var ErrorCode: Integer): Boolean;<br> function renameFile(const OldName, NewName: string): Boolean;<br> function ChangeFileExt(const FileName, Extension: string): String;<br> function FileCopy(const ExistingFile, NewFile: String; const FailIfExists: Boolean): Boolean;<br> function deleteFile(const FileName: string): Boolean;<br> procedure DelaydeleteFile(const Filename: String; const Tries: Integer);<br> function LoadStringFromFile(const FileName: String; var S: String): Boolean;<br> function LoadStringsFromFile(const FileName: String; var S: TArrayOfString): Boolean;<br> function SaveStringToFile(const FileName, S: String; const Append: Boolean): Boolean;<br> function SaveStringsToFile(const FileName: String; const S: TArrayOfString; const Append: Boolean): Boolean;<br> function createDir(const Dir: string): Boolean;<br> function ForceDirectories(Dir: string): Boolean;<br> function RemoveDir(const Dir: string): Boolean;<br> function DelTree(const Path: String; const IsDir, deleteFiles, deleteSubdirsAlso: Boolean): Boolean;<br> function createShellLink(const Filename, Description, ShortcutTo, Parameters, WorkingDir, IconFilename: String; const IconIndex, ShowCmd: Integer): String;<br> procedure RegisterServer(const Filename: String; const FailCriticalErrors: Boolean);<br> function UnregisterServer(const Filename: String; const FailCriticalErrors: Boolean): Boolean;<br> procedure RegisterTypeLibrary(const Filename: String);<br> function UnregisterTypeLibrary(const Filename: String): Boolean<br> procedure IncrementSharedCount(const Filename: String; const AlreadyExisted: Boolean);<br> function DecrementSharedCount(const Filename: String): Boolean;<br> procedure RestartReplace(const TempFile, DestFile: String);<br> procedure UnregisterFont(const FontName, FontFilename: String);<br> function modifyPifFile(const Filename: String; const CloseOnExit: Boolean): Boolean;</p> </td></tr></tbody></table> 
<p>注册表函数</p> 
<pre></pre> 
<table cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1<br> 2<br> 3<br> 4<br> 5<br> 6<br> 7<br> 8<br> 9<br> 10<br> 11<br> 12<br> 13<br> 14<br> 15<br> 16</p> </td><td> <p>function RegKeyExists(const RootKey: Integer; const SubKeyName: String): Boolean;<br> function RegValueExists(const RootKey: Integer; const SubKeyName, ValueName: String): Boolean;<br> function RegGetSubkeyNames(const RootKey: Integer; const SubKeyName: String; var Names: TArrayOfString): Boolean;<br> function RegGetValueNames(const RootKey: Integer; const SubKeyName: String; var Names: TArrayOfString): Boolean;<br> function RegQueryStringValue(const RootKey: Integer; const SubKeyName, ValueName: String; var ResultStr: String): Boolean;<br> function RegQueryMultiStringValue(const RootKey: Integer; const SubKeyName, ValueName: String; var ResultStr: String): Boolean;<br> function RegQueryDWordValue(const RootKey: Integer; const SubKeyName, ValueName: String; var ResultDWord: Cardinal): Boolean;<br> function RegQueryBinaryValue(const RootKey: Integer; const SubKeyName, ValueName: String; var ResultStr: String): Boolean;<br> function RegWriteStringValue(const RootKey: Integer; const SubKeyName, ValueName, Data: String): Boolean;<br> function RegWriteExpandStringValue(const RootKey: Integer; const SubKeyName, ValueName, Data: String): Boolean;<br> function RegWriteMultiStringValue(const RootKey: Integer; const SubKeyName, ValueName, Data: String): Boolean;<br> function RegWriteDWordValue(const RootKey: Integer; const SubKeyName, ValueName: String; const Data: Cardinal) Boolean;<br> function RegWriteBinaryValue(const RootKey: Integer; const SubKeyName, ValueName, Data: String): Boolean;<br> function RegdeleteKeyIncludingSubkeys(const RootKey: Integer; const SubkeyName: String): Boolean;<br> function RegdeleteKeyIfEmpty(const RootKey: Integer; const SubkeyName: String): Boolean;<br> function RegdeleteValue(const RootKey: Integer; const SubKeyName, ValueName: String): Boolean;</p> </td></tr></tbody></table> 
<p>INI 文件函数</p> 
<pre></pre> 
<table cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1<br> 2<br> 3<br> 4<br> 5<br> 6<br> 7<br> 8<br> 9<br> 10<br> 11</p> </td><td> <p>function IniKeyExists(const Section, Key, Filename: String): Boolean;<br> function IsIniSectionEmpty(const Section, Filename: String): Boolean;<br> function GetIniBool(const Section, Key: String; const Default: Boolean; const Filename: String): Boolean<br> function GetIniInt(const Section, Key: String; const Default, Min, Max: Longint; const Filename: String): Longint;<br> function GetIniString(const Section, Key, Default, Filename: String): String;<br> function SetIniBool(const Section, Key: String; const Value: Boolean; const Filename: String):<br> Boolean;<br> function SetIniInt(const Section, Key: String; const Value: Longint; const Filename: String): Boolean;<br> function SetIniString(const Section, Key, Value, Filename: String): Boolean;<br> procedure deleteIniSection(const Section, Filename: String);<br> procedure deleteIniEntry(const Section, Key, Filename: String);</p> </td></tr></tbody></table> 
<p>自定义安装程序向导页函数</p> 
<pre></pre> 
<table cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1<br> 2<br> 3<br> 4<br> 5<br> 6<br> 7<br> 8<br> 9<br> 10<br> 11<br> 12</p> </td><td> <p>function createInputQueryPage(const AfterID: Integer; const ACaption, ADescription, ASubCaption: String): TInputQueryWizardPage;<br> function createInputOptionPage(const AfterID: Integer; const ACaption, ADescription, ASubCaption: String; Exclusive, ListBox: Boolean): TInputOptionWizardPage;<br> function createInputDirPage(const AfterID: Integer; const ACaption, ADescription, ASubCaption: String; AAppendDir: Boolean; ANewFolderName: String): TInputDirWizardPage;<br> function createInputFilePage(const AfterID: Integer; const ACaption, ADescription, ASubCaption: String): TInputFileWizardPage;<br> function createOutputMsgPage(const AfterID: Integer; const ACaption, ADescription, AMsg: String): TOutputMsgWizardPage;<br> function createOutputMsgMemoPage(const AfterID: Integer; const ACaption, ADescription, ASubCaption, AMsg: String): TOutputMsgMemoWizardPage;<br> function createOutputProgressPage(const ACaption, ADescription: String): TOutputProgressWizardPage;<br> function createCustomPage(const AfterID: Integer; const ACaption, ADescription: String): TWizardPage;<br> function createCustomForm: TSetupForm;<br> function PageFromID(const ID: Integer): TWizardPage;<br> function ScaleX(X: Integer): Integer;<br> function ScaleY(Y: Integer): Integer;</p> </td></tr></tbody></table> 
<p>对话框函数</p> 
<pre></pre> 
<table cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1<br> 2<br> 3<br> 4<br> 5</p> </td><td> <p>function MsgBox(const Text: String; const Typ: TMsgBoxType; const Buttons: Integer): Integer;<br> function SuppressibleMsgBox(const Text: String; const Typ: TMsgBoxType; const Buttons, Default: Integer): Integer;<br> function GetOpenFileName(const Prompt: String; var FileName: String; const InitialDirectory, Filter, DefaultExtension: String): Boolean;<br> function BrowseForFolder(const Prompt: String; var Directory: String; const NewFolderButton: Boolean): Boolean;<br> function ExitSetupMsgBox: Boolean;</p> </td></tr></tbody></table> 
<p>COM 自动操作对象支持函数</p> 
<pre></pre> 
<table cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1<br> 2</p> </td><td> <p>function createOleObject(const ClassName: string): Variant;<br> function GetActiveOleObject(const ClassName: string): Variant;</p> </td></tr></tbody></table> 
<p>安装程序记录函数</p> 
<pre></pre> 
<table cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> </td><td> <p>procedure Log(const S: String);</p> </td></tr></tbody></table> 
<p>其它函数</p> 
<pre></pre> 
<table cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1<br> 2<br> 3<br> 4</p> </td><td> <p>procedure Sleep(const Milliseconds: LongInt);<br> function Random(const Range: Integer): Integer;<br> procedure Beep;<br> procedure BringToFrontAndRestore;</p> </td></tr></tbody></table> 
<p>不建议使用的函数</p> 
<pre></pre> 
<table cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1<br> 2<br> 3<br> 4<br> 5</p> </td><td> <p>function LoadDLL(const DLLName: String; var ErrorCode: Integer): Longint;<br> function CallDLLProc(const DLLHandle: Longint; const ProcName: String; const Param1, Param2: Longint; var Result: Longint): Boolean;<br> function FreeDLL(const DLLHandle: Longint): Boolean;<br> function castStringToInteger(var S: String): Longint;<br> function castIntegerToString(const L: Longint): String;</p> </td></tr></tbody></table> 
<p>这里是用于这些函数的常量列表:<br> CurStep 值<br> ssInstall, ssPostInstall, ssDone<br> CurPage 值<br> wpWelcome, wpLicense, wpPassword, wpInfoBefore, wpUserInfo, wpselectDir, wpselectComponents, wpselectProgramGroup, wpselectTasks, wpReady, wpPreparing, wpInstalling, wpInfoAfter, wpFinished<br> TMsgBoxType<br> mbInformation, mbConfirmation, mbError, mbCriticalError<br> MsgBox – 按钮标记<br> MB_OK, MB_OKCANCEL, MB_ABORTRETRYIGNORE, MB_YESNOCANCEL, MB_YESNO, MB_RETRYCANCEL, MB_DEFBUTTON1, MB_DEFBUTTON2, MB_DEFBUTTON3, MB_SETFOREGROUND<br> MsgBox – 返回值<br> IDOK, IDCANCEL, IDABORT, IDRETRY, IDIGNORE, IDYES, IDNO<br> TGetShellFolderID<br> sfDesktop, sfStartMenu, sfPrograms, sfStartup, sfSendTo, sfFonts, sfAppData, sfDocs, sfTemplates, sfFavorites, sfLocalAppData<br> Reg* – 根键值<br> HKEY_CLASSES_ROOT, HKEY_CURRENT_USER, HKEY_LOCAL_MACHINE, HKEY_USERS, HKEY_PERFORMANCE_DATA, HKEY_CURRENT_CONFIG, HKEY_DYN_DATA,<br> HKCR, HKCU, HKLM, HKU, HKCC<br> TShouldProcessEntryResult<br> srNo, srYes, srUnknown<br> InstallOnThisVersion – 返回值<br> irInstall, irNotOnThisPlatform, irVerTooLow, irVerTooHigh, irInvalid<br> TSetupMessageID<br> 用 ‘msg’ + 消息名。 示例: SetupMessage(msgSetupAppTitle)<br> Exec 和 ShellExec – ShowCmd 值<br> SW_SHOW, SW_SHOWNORMAL, SW_SHOWMAXIMIZED, SW_SHOWMINIMIZED, SW_SHOWMINNOACTIVE, SW_HIDE</p> 
<p>Inno setup 5.5.5 汉化增强版下载：</p> 
<p><a href="https://pan.baidu.com/s/1qYkuHXYKdqWHsOLpq_m8_Q" rel="nofollow" title="点击下载">点击下载</a>（提取码：53cz）<br><a href="https://url89.ctfile.com/f/3965089-510668318-9a39cd" rel="nofollow" title="点击下载">点击下载</a>（提取码：536766）<br><a href="https://url89.ctfile.com/f/3965089-510668318-9a39cd" rel="nofollow" title="点击下载">点击下载</a>（提取码：536766）<br><a href="https://pan.baidu.com/s/1vLV5-CdBIUHIVW7bOUKAFA" rel="nofollow" title="点击下载">点击下载</a>（提取码：hnc8）</p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f9d45aaa0ece0fe735dd7fc8e7b14420/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">NMOS管和PMOS管使用区别之一</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f71ac1fb5f7b59ad3f141e93eee21533/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Docker之使用Dockerfile创建新镜像</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>