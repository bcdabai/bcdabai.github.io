<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>android存储2--初始化.存储service的启动 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="android存储2--初始化.存储service的启动" />
<meta property="og:description" content="android版本：android-11.0.0_r21
http://aospxref.com/android-11.0.0_r21/
android存储初始化分3个阶段：
1）清理环境。因android支持多用户，解锁后登录的可能是另一个用户，需把之前用户执行的一些信息清理干净。《android存储1--初始化.清理环境》已做分析，总结如下：
start primary user
发送START消息、H_BOOT_COMPLETED消息给其他service处理。init用户目录的加密状态
初始化软件加解密的device的用户目录加密状态；对于硬件加密的device，什么事也不做。reset external storage service
umount外部存储、关闭mount service的所有connection。按电源键开机，外部存储还没有挂载，所以不需要卸载任何存储设备，也不需要关闭任何connection。reset vold service
销毁volume、重置disk对象、清空用户、添加用户。开机场景不需要销毁volume、重置disk对象、清空用户。添加用户
在mAddedUsers中记录主用户。 2）启动存储服务（mount、vold、storaged这些service）。
3）挂载emulated存储（这系列文章只分析emulated存储）。
本文分析“启动存储服务”，涉及mount、vold、storaged service的启动流程。
一、存储相关的service 1，service介绍 存储有3个关键service：mount、vold、storaged，通过adb shell &#34;service list&#34;可以看到。
service代码：
service代码路径mount serviceframeworks/base/services/core/java/com/android/server/StorageManagerService.javavold servicesystem/vold 目录
（注意，虽然vold是一个用户态程序，但它的log默认在内核里，需通过dmesg查看）storaged servicesystem/core/storaged 目录 mount service负责mount和umount存储设备或存储卷，提供文件系统的访问接口。它的mount、umount请求下发给native层的vold处理。
vold (Volume Daemon)位于framework和kernel之间，管理存储卷的生命周期、处理mount service的mount和umount请求，以及提供存储卷的管理接口。
vold主要功能：
1）监听内核的存储设备uevent事件，并上报给mount service。
2）处理mount service下发的mount、umount请求。
storaged是一个deamon进程，提供存储相关的统计数据（磁盘使用信息、应用io信息、存储寿命信息等），并通过向应用程序和系统组件提供 API 接口，使它们能够监控和管理存储资源的使用情况。提供的命令如下：
命令输出说明storaged或storaged -s 注册storaged service和storaged_pri service。
系统启动时int进程解析/system/etc/init/storaged.rc，执行storaged命令。
我们在调试的过程中，不需要再执行storaged命令了。
storaged -u
storaged -t 调试时，该命令用的比较多 &lt;uid&gt;/&lt;foreground read bytes&gt; &lt;foreground write bytes&gt; &lt;foreground read chars&gt; &lt;foreground write chars&gt; &lt;background read bytes&gt; &lt;background write bytes&gt; &lt;background read chars&gt; &lt;background write chars&gt; storaged的help信息： -u Dump uid I/O usage to stdout -t Dump task I/O usage to stdout 但是，system/core/storaged/main." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/fad8b35534b971eab240023e927e7791/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-06-20T14:14:04+08:00" />
<meta property="article:modified_time" content="2023-06-20T14:14:04+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">android存储2--初始化.存储service的启动</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>android版本：android-11.0.0_r21<br> http://aospxref.com/android-11.0.0_r21/</p> 
<p>android存储初始化分3个阶段：<br> 1）清理环境。因android支持多用户，解锁后登录的可能是另一个用户，需把之前用户执行的一些信息清理干净。<a class="link-info" href="https://blog.csdn.net/geshifei/article/details/130194916" title="《android存储1--初始化.清理环境》">《android存储1--初始化.清理环境》</a>已做分析，总结如下：</p> 
<ul><li>start primary user<br> 发送START消息、H_BOOT_COMPLETED消息给其他service处理。</li><li>init用户目录的加密状态<br> 初始化软件加解密的device的用户目录加密状态；对于硬件加密的device，什么事也不做。</li><li>reset external storage service<br> umount外部存储、关闭mount service的所有connection。按电源键开机，外部存储还没有挂载，所以不需要卸载任何存储设备，也不需要关闭任何connection。</li><li>reset vold service<br> 销毁volume、重置disk对象、清空用户、添加用户。开机场景不需要销毁volume、重置disk对象、清空用户。</li><li>添加用户<br> 在mAddedUsers中记录主用户。</li></ul> 
<p>2）启动存储服务（mount、vold、storaged这些service）。<br> 3）挂载emulated存储（这系列文章只分析emulated存储）。</p> 
<p>   本文分析“启动存储服务”，涉及mount、vold、storaged service的启动流程。</p> 
<h2>一、存储相关的service</h2> 
<h3>1，service介绍</h3> 
<p>存储有3个关键service：mount、vold、storaged，通过adb shell "service list"可以看到。</p> 
<p>service代码：</p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:630px;"><tbody><tr><td style="width:110px;">service</td><td style="width:518px;">代码路径</td></tr><tr><td style="width:110px;">mount service</td><td style="width:518px;">frameworks/base/services/core/java/com/android/server/StorageManagerService.java</td></tr><tr><td style="width:110px;">vold service</td><td style="width:518px;">system/vold 目录<br> （注意，虽然vold是一个用户态程序，但它的log默认在内核里，需通过dmesg查看）</td></tr><tr><td style="width:110px;">storaged service</td><td style="width:518px;">system/core/storaged 目录</td></tr></tbody></table> 
<p>mount service负责mount和umount存储设备或存储卷，提供文件系统的访问接口。它的mount、umount请求下发给native层的vold处理。</p> 
<p>vold (Volume Daemon)位于framework和kernel之间，管理存储卷的生命周期、处理mount service的mount和umount请求，以及提供存储卷的管理接口。<br> vold主要功能：<br> 1）监听内核的存储设备uevent事件，并上报给mount service。<br> 2）处理mount service下发的mount、umount请求。</p> 
<p>storaged是一个deamon进程<code>，</code>提供存储相关的统计数据（磁盘使用信息、应用io信息、存储寿命信息等），并通过向应用程序和系统组件提供 API 接口，使它们能够监控和管理存储资源的使用情况。提供的命令如下：</p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:650px;"><tbody><tr><td style="text-align:center;width:94px;">命令</td><td style="text-align:center;width:554px;">输出说明</td></tr><tr><td style="width:94px;">storaged或storaged -s</td><td style="width:554px;"> <p>注册storaged service和storaged_pri service。<br> 系统启动时int进程解析/system/etc/init/storaged.rc，执行storaged命令。</p> <p></p> <p>我们在调试的过程中，不需要再执行storaged命令了。</p> </td></tr><tr><td style="width:94px;">storaged -u<br> storaged -t</td><td style="width:554px;"> <pre>调试时，该命令用的比较多

&lt;uid&gt;/&lt;foreground read bytes&gt; &lt;foreground write bytes&gt; &lt;foreground read chars&gt; &lt;foreground write chars&gt; &lt;background read bytes&gt; &lt;background write bytes&gt; &lt;background read chars&gt; &lt;background write chars&gt;

storaged的help信息：
-u Dump uid I/O usage to stdout
-t Dump task I/O usage to stdout

<span style="color:#fe2c24;">但是，system/core/storaged/main.cpp的main函数中，-u,-t调用的都是storaged_service-&gt;dumpUids(&amp;uid_io)，所以功能是一样的。</span>
</pre> </td></tr><tr><td style="width:94px;">storaged -p</td><td style="width:554px;">Dump I/O perf history to stdout</td></tr></tbody></table> 
<h3>2，service之间的关系</h3> 
<p>mount、vold、storaged之间的层次关系如下：</p> 
<p><img alt="" src="https://images2.imgbox.com/f3/a3/TYFqZiqZ_o.png"></p> 
<p> 图中标号说明：</p> 
<p><span style="color:#fe2c24;">①：looper线程监听ACTION_USER_ADDED和ACTION_USER_REMOVED消息。</span></p> 
<p>StorageManagerService::StorageManagerService --&gt; mContext.registerReceiver(mUserReceiver, userFilter, null, mHandler)注册了BroadcastReceiver ，接收ACTION_USER_ADDED和ACTION_USER_REMOVED类型的 IntentFilter 广播消息， 参数mHandle所代表的线程上执行 BroadcastReceiver。</p> 
<p>在StorageManagerService方法中，mHandler = new StorageManagerServiceHandler(hthread.getLooper())，所以Handler 代表的线程是looper线程。</p> 
<p>mount service收到ACTION_USER_ADDED和ACTION_USER_REMOVED后，会做mount或者unmount操作。</p> 
<p><span style="color:#fe2c24;">②：mount service设置一个监听器，监听vold状态。</span></p> 
<p>StorageManagerService::connectVold --&gt; mVold = IVold.Stub.asInterface(binder)获取vold service的Binder对象，接着mount service通过mVold.setListener(mListener)设置监听器监听vold状态变化，监听器回调方法在StorageManagerService的匿名内部类中（见private final IVoldListener mListener = new IVoldListener.Stub()处的匿名类）。一旦vold状态变化，就会执行监听器回调方法，见⑤。</p> 
<p><span style="color:#fe2c24;">③：mount service获取storaged的binder对象，需要的时候执行storaged中的方法。</span></p> 
<p>StorageManagerService::connectStoraged --&gt; mStoraged = IStoraged.Stub.asInterface(binder)获取storaged service的Binder对象。mount service接收到相关事件后，比如unlock user，remove user等，执行storaged中的函数mStoraged.onUserStarted(userId)，mStoraged.onUserStopped(userId)等。</p> 
<p><span style="color:#fe2c24;">④：VoldNativeService执行VolumeManager中的方法。</span></p> 
<p>VoldNativeService通过类似于translate(VolumeManager::Instance()-&gt;XXX执行VolumeManager中的方法。比如VoldNativeService::onUserAdded --&gt; translate(VolumeManager::Instance()-&gt;onUserAdded(userId, userSerial))，执行的是VolumeManager::onUserAdded。</p> 
<p><span style="color:#fe2c24;">⑤：VolumeManager上报存储设备事件给mount service。</span></p> 
<p>用户add或删除，需要mount或者umount掉emulated storage；热插拔存储设备，kernel会上报uevent事件，这些都会引起vold状态变化，此时mount service在②中设置的监听器就监听到这些事件，执行对应的监听器回调方法。</p> 
<p><span style="color:#fe2c24;">⑥：NetlinkManager初始化socket，用于接收kernel的uevent事件。</span></p> 
<p>system/vold/main.cpp中通过nm = NetlinkManager::Instance()实例化了一个NetlinkManager，用于接收kernel的uevent事件。</p> 
<p><span style="color:#fe2c24;">⑦：VolumeManager执行系统调用，执行mount等操作。</span></p> 
<p>VolumeManager通过VolumeManager类执行kernel的系统调用，比如VolumeManager::mountAppFuse --&gt; android::vold::MountAppFuse --&gt; RunCommand --&gt; mount等。</p> 
<h2>二、mount service的启动</h2> 
<p>SystemServer类定义了STORAGE_MANAGER_SERVICE_CLASS常量：<br><a class="link-info" href="http://aospxref.com/android-11.0.0_r21/xref/frameworks/base/services/java/com/android/server/SystemServer.java#SystemServer" rel="nofollow" title="http://aospxref.com/android-11.0.0_r21/xref/frameworks/base/services/java/com/android/server/SystemServer.java#SystemServer">http://aospxref.com/android-11.0.0_r21/xref/frameworks/base/services/java/com/android/server/SystemServer.java#SystemServer</a></p> 
<pre><code class="language-java">
private static final String JOB_SCHEDULER_SERVICE_CLASS =
              "com.android.server.job.JobSchedulerService";
private static final String LOCK_SETTINGS_SERVICE_CLASS =
              "com.android.server.locksettings.LockSettingsService$Lifecycle";
private static final String STORAGE_MANAGER_SERVICE_CLASS =</code></pre> 
<p><a class="link-info" href="http://aospxref.com/android-11.0.0_r21/xref/frameworks/base/services/java/com/android/server/SystemServer.java#SystemServer" rel="nofollow" title="http://aospxref.com/android-11.0.0_r21/xref/frameworks/base/services/java/com/android/server/SystemServer.java#SystemServer">http://aospxref.com/android-11.0.0_r21/xref/frameworks/base/services/java/com/android/server/SystemServer.java#SystemServer</a></p> 
<p>Android启动时，SystemServer 进程启动其他系统服务（startOtherServices）。在这个过程中，SystemServer类定义的常量被用于加载各个服务。<br> 以com.android.server.StorageManagerService$Lifecycle为例，看一下service的注册过程。</p> 
<div> 
 <pre><code class="language-java">SystemServer::run
  --&gt; startOtherServices(t)
        --&gt; mSystemServiceManager.startService(STORAGE_MANAGER_SERVICE_CLASS)
              --&gt; SystemService startService(String className)
                    --&gt; &lt;T extends SystemService&gt; T startService(Class&lt;T&gt; serviceClass)
                          --&gt; startService(@NonNull final SystemService service)
                                --&gt; service.onStart();以存储为例，即StorageManagerService$Lifecycle::onStart
                                      --&gt; publishBinderService("mount", mStorageManagerService) //注册到SystemServiceManager中                                 </code></pre> 
</div> 
<p>service.onStart对应的StorageManagerService$Lifecycle::onStart函数:</p> 
<p><a href="http://aospxref.com/android-11.0.0_r21/xref/frameworks/base/services/core/java/com/android/server/StorageManagerService.java#255" rel="nofollow" title="http://aospxref.com/android-11.0.0_r21/xref/frameworks/base/services/core/java/com/android/server/StorageManagerService.java#255">http://aospxref.com/android-11.0.0_r21/xref/frameworks/base/services/core/java/com/android/server/StorageManagerService.java#255</a></p> 
<div> 
 <pre><code class="language-java">210  class StorageManagerService extends IStorageManager.Stub
211          implements Watchdog.Monitor, ScreenObserver {
          ……
246      public static class Lifecycle extends SystemService {
247          private StorageManagerService mStorageManagerService;
248  
249          public Lifecycle(Context context) {
250              super(context);
251          }
252  
253          @Override
254          public void onStart() {
255              mStorageManagerService = new StorageManagerService(getContext());
256              publishBinderService("mount", mStorageManagerService);
257              mStorageManagerService.start();
258          }</code></pre> 
</div> 
<p>255行，实例化一个StorageManagerService对象，在其构造函数：</p> 
<p>1）通过HandlerThread hthread = new HandlerThread(TAG)创建一个消息处理线程，线程名为“StorageManagerService”（注意，内核记录的线程名最多16个字符，所以ps -AT看到的线程名是不完整的），处理ACTION_USER_ADDED和ACTION_USER_REMOVED事件。</p> 
<p>2）通过mStorageSessionController = new StorageSessionController(mContext, mIsFuseEnabled)创建一个StorageSessionController，用来控制访问外部存储。</p> 
<p><span style="color:#fe2c24;">256行，publishBinderService将255行新创建的StorageManagerService以“mount”名字注册到serviceManager中（可通过adb shell "service list"命令查看service）</span>。</p> 
<p>257行， mStorageManagerService.start()启动service，代码如下：</p> 
<div> 
 <pre><code class="language-java">1891      private void start() {
1892          connectStoraged();
1893          connectVold();
1894      }</code></pre> 
</div> 
<p> connectStoraged()和connectVold()都是在StorageManagerService类中定义的，简化后的代码：</p> 
<div> 
 <pre><code class="language-java">private void connectStoraged() {
1897          IBinder binder = ServiceManager.getService("storaged");
			  ……
1914          mStoraged = IStoraged.Stub.asInterface(binder);
1926      }
1927  
1928      private void connectVold() {
1929          IBinder binder = ServiceManager.getService("vold"); // ⑧
			  ……
1946          mVold = IVold.Stub.asInterface(binder); // ⑨
1948          mVold.setListener(mListener); // ⑩
1964      }</code></pre> 
</div> 
<p>connectStoraged() 设置 IStoraged  mStoraged变量，connectVold() 设置 IVold  mVold变量。以connectVold()为例说明代码：</p> 
<p>⑧：获取名为 "vold" 的服务的 Binder 对象。</p> 
<p>⑨：将获取到的 Binder 对象转换为 IVold 接口的实例，并将其赋值给变量mVold。</p> 
<p>⑩：设置监听器，监听到mVold状态变化时，执行mListener的回调函数，比如onDiskCreated，onVolumeCreated等。</p> 
<h2>三、vold service的启动</h2> 
<p>init.rc脚本中定义了start vold语句，inti进程启动vold服务*（这里说的服务是linux中的service，不是android中的service）。<br><a href="http://aospxref.com/android-11.0.0_r21/xref/system/core/rootdir/init.rc#453" rel="nofollow" title="http://aospxref.com/android-11.0.0_r21/xref/system/core/rootdir/init.rc#453">http://aospxref.com/android-11.0.0_r21/xref/system/core/rootdir/init.rc#453</a><br>  </p> 
<div> 
 <pre><code class="language-bash">451 on early-fs
452     # Once metadata has been mounted, we'll need vold to deal with userdata checkpointing
453     start vold</code></pre> 
</div> 
<p>vold服务*（linux中的service）的描述：<br><a href="http://aospxref.com/android-11.0.0_r21/xref/system/vold/vold.rc" rel="nofollow" title="vold.rc - OpenGrok cross reference for /system/vold/vold.rc">vold.rc - OpenGrok cross reference for /system/vold/vold.rc</a></p> 
<div> 
 <pre><code class="language-bash">1 service vold /system/bin/vold \
2         --blkid_context=u:r:blkid:s0 --blkid_untrusted_context=u:r:blkid_untrusted:s0 \
3         --fsck_context=u:r:fsck:s0 --fsck_untrusted_context=u:r:fsck_untrusted:s0
4     class core
5     ioprio be 2
6     writepid /dev/cpuset/foreground/tasks
7     shutdown critical
8     group root reserved_disk</code></pre> 
</div> 
<p>nti进程加载/system/bin/vold二进制文件，启动vold进程。system/vold/main.cpp文件中main函数简化如下：</p> 
<div> 
 <pre><code class="language-cpp">int main(int argc, char** argv) {

    VolumeManager* vm;
    NetlinkManager* nm;

    //实例化一个VolumeManager，用于管理所有的volume，VolumeManager成员mDisks记录系统中所有的disk，Disk类描述disk，Disk成员mVolumes记录了本disk所有的分区。
    if (!(vm = VolumeManager::Instance())) {
        LOG(ERROR) &lt;&lt; "Unable to create VolumeManager";
        exit(1);
    }

    //实例化一个NetlinkManager，用于接收kernel的uevent事件
    if (!(nm = NetlinkManager::Instance())) {
        LOG(ERROR) &lt;&lt; "Unable to create NetlinkManager";
        exit(1);
    }

    //实例化一个VolumeBase，用来描述"/data/media"路径的emulated volume，并将该volume加入到mInternalEmulatedVolumes链表。注意，这个时候只是初始化了vloume（VolumeBase类型）的部分成员，并没有创建emulated volume，也即没有执行mount外部存储等一些列操作。
    if (vm-&gt;start()) {
        PLOG(ERROR) &lt;&lt; "Unable to start VolumeManager";
        exit(1);
    }

    //通过BinderService&lt;VoldNativeService&gt;::publish()发布"vold"服务。VoldNativeService::getServiceName返回的是"vold"字符串。
    if (android::vold::VoldNativeService::start() != android::OK) {
        LOG(ERROR) &lt;&lt; "Unable to start VoldNativeService";
        exit(1);
    }

    //nm-&gt;start初始化了socket，启动NetlinkManager监听kernel的uevent事件。
    if (nm-&gt;start()) {
        PLOG(ERROR) &lt;&lt; "Unable to start NetlinkManager";
        exit(1);
    }

    //当前线程加入到Binder线程池，一旦线程加入到Binder线程池中，它将持续监听并处理来自客户端的Binder调用请求。当有请求到达时，线程将调用相应的服务方法来处理请求，并将结果返回给客户端。
    android::IPCThreadState::self()-&gt;joinThreadPool();
}</code></pre> 
</div> 
<p><span style="color:#fe2c24;">main函数中的android::vold::VoldNativeService::start()发布vold service（android中的service概念，通过service list命令查看）。</span></p> 
<h2>四、storaged service的启动</h2> 
<p>storaged服务定义在system/core/storaged/storaged.rc中，编译刷机运行，脚本在/system/etc/init/storaged.rc。</p> 
<p>system/core/init/main.cpp中main --&gt; SecondStageMain --&gt; LoadBootScripts --&gt; parser.ParseConfig("/system/etc/init")代码如下：<br><a href="http://aospxref.com/android-11.0.0_r21/xref/system/core/init/parser.cpp#184" rel="nofollow" title="http://aospxref.com/android-11.0.0_r21/xref/system/core/init/parser.cpp#184">http://aospxref.com/android-11.0.0_r21/xref/system/core/init/parser.cpp#184</a></p> 
<div> 
 <pre><code class="language-cpp">184  bool Parser::ParseConfig(const std::string&amp; path) {
185      if (is_dir(path.c_str())) {
186          return ParseConfigDir(path);
187      }
188      return ParseConfigFile(path);
189  }</code></pre> 
</div> 
<p>/system/etc/init是一个目录，所以执行ParseConfigDir函数。</p> 
<p><a class="link-info" href="http://aospxref.com/android-11.0.0_r21/xref/system/core/init/parser.cpp#ParseConfigDir" rel="nofollow" title="http://aospxref.com/android-11.0.0_r21/xref/system/core/init/parser.cpp#ParseConfigDir">http://aospxref.com/android-11.0.0_r21/xref/system/core/init/parser.cpp#ParseConfigDir</a></p> 
<div> 
 <pre><code class="language-cpp">157  bool Parser::ParseConfigDir(const std::string&amp; path) {
158      LOG(INFO) &lt;&lt; "Parsing directory " &lt;&lt; path &lt;&lt; "...";
159      std::unique_ptr&lt;DIR, decltype(&amp;closedir)&gt; config_dir(opendir(path.c_str()), closedir);
160      if (!config_dir) {
161          PLOG(INFO) &lt;&lt; "Could not import directory '" &lt;&lt; path &lt;&lt; "'";
162          return false;
163      }
164      dirent* current_file;
165      std::vector&lt;std::string&gt; files;
166      while ((current_file = readdir(config_dir.get()))) {
167          // Ignore directories and only process regular files.
168          if (current_file-&gt;d_type == DT_REG) {
169              std::string current_path =
170                  android::base::StringPrintf("%s/%s", path.c_str(), current_file-&gt;d_name);
171              files.emplace_back(current_path);
172          }
173      }
174      // Sort first so we load files in a consistent order (bug 31996208)
175      std::sort(files.begin(), files.end());
176      for (const auto&amp; file : files) {
177          if (!ParseConfigFile(file)) {
178              LOG(ERROR) &lt;&lt; "could not import file '" &lt;&lt; file &lt;&lt; "'";
179          }
180      }
181      return true;
182  }</code></pre> 
</div> 
<p>ParseConfigDir遍历目录下的文件，然后调用ParseConfigFile启动/system/etc/init/storaged.rc定的storaged服务*（这里说的服务是linux中的service，不是android中的service）。</p> 
<p>storaged服务描述：<br><a href="http://aospxref.com/android-11.0.0_r21/xref/system/core/storaged/storaged.rc" rel="nofollow" title="http://aospxref.com/android-11.0.0_r21/xref/system/core/storaged/storaged.rc">http://aospxref.com/android-11.0.0_r21/xref/system/core/storaged/storaged.rc</a></p> 
<pre><code class="language-bash">1 service storaged /system/bin/storaged
2     class main
3     capabilities DAC_READ_SEARCH
4     priority 10
5     file /d/mmc0/mmc0:0001/ext_csd r
6     writepid /dev/cpuset/system-background/tasks
7     user root
8     group package_info</code></pre> 
<p>inti进程加载/system/bin/storaged二进制文件，启动storaged进程。system/core/storaged/main.cpp中main函数简化如下：</p> 
<pre><code class="language-cpp">int main(int argc, char** argv) {

    // storaged或者storaged -s命令，周期性统计
    if (flag_main_service) { // start main thread
        // Start the main thread of storaged
        storaged_sp = new storaged_t();
        storaged_sp-&gt;init();
        storaged_sp-&gt;report_storage_info();
        pthread_t storaged_main_thread;
        errno = pthread_create(&amp;storaged_main_thread, NULL, storaged_main, NULL);
        if (errno != 0) {
            PLOG(ERROR) &lt;&lt; "Failed to create main thread";
            return -1;
        }

        if (StoragedService::start() != android::OK ||
            StoragedPrivateService::start() != android::OK) {
            PLOG(ERROR) &lt;&lt; "Failed to start storaged service";
            return -1;
        }

        android::ProcessState::self()-&gt;startThreadPool();
        IPCThreadState::self()-&gt;joinThreadPool();
        pthread_join(storaged_main_thread, NULL);

        return 0;
    }

    sp&lt;IStoragedPrivate&gt; storaged_service = get_storaged_pri_service();
    if (storaged_service == NULL) {
        fprintf(stderr, "Cannot find storaged service.\nMaybe run storaged --start first?\n");
        return -1;
    }

    // 根据help信息：
    // storaged -u按uid统计io使用信息，storaged -t按线程统计io使用信息
    // flag_dump_uid代表storaged -u，flag_dump_task代码表stoaged -t
    // 但我们从代码中可以看出，-u和-t是一样的，都是按uid统计io信息
    if (flag_dump_uid || flag_dump_task) {
        vector&lt;UidInfo&gt; uid_io;
        binder::Status status = storaged_service-&gt;dumpUids(&amp;uid_io);
        if (!status.isOk() || uid_io.size() == 0) {
            fprintf(stderr, "UID I/O info is not available.\n");
            return 0;
        }

        sort_running_uids_info(uid_io);
        log_console_running_uids_info(uid_io, flag_dump_task);
    }

    //storaged -p统计io性能数据
    if (flag_dump_perf) {
        vector&lt;int&gt; perf_history;
        binder::Status status = storaged_service-&gt;dumpPerfHistory(&amp;perf_history);
        if (!status.isOk() || perf_history.size() == 0) {
            fprintf(stderr, "I/O perf history is not available.\n");
            return 0;
        }

        log_console_perf_history(perf_history);
    }

    return 0;
}
</code></pre> 
<p>init进程执行的是/system/bin/storaged命令，所以 执行if (flag_main_service)为ture的分支，在这个分支中，<span style="color:#fe2c24;">StoragedService::start()发布storaged service（android中的service概念，通过service list命令查看），StoragedPrivateService::start()发布storaged_pri service（android中的service概念，通过service list命令查看）。</span></p> 
<p>下一篇文章讲解锁时，存储相关的流程。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/aae8d260776ce6cc1f9344deaeb53717/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">vue-element文件上传组件el-upload的使用(导入)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/7bc567d9818d524304deca41fdef84f0/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Rust类型转换知多少</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>