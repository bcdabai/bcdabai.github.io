<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>用AS3.0开发flash版SLG游戏-1 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="用AS3.0开发flash版SLG游戏-1" />
<meta property="og:description" content="说到经典的战棋游戏，我还是最痴迷于曹操传，以前也曾因为研究曹操传MOD而废寖忘食，也做过一个曹操传的MOD小热一时，
却没想到曹操传MOD已经发展到现在这种地步，无论是画面还是技术都有了大规模的突破
但是，修改永远是修改，总会遇到各种限制，想要突破，当然要自己动手，开发自己的引擎。
但是，在这里，我研究flash版的曹操传，目的并不是想要有任何突破，只是单纯的为了研究一下，熟悉一下用flash完成各种游戏的制作而已。
先看几个预览
下面开始制作过程
首先，先建立一个战场，显示一张地图吧，
导出一张曹操传第一关颖川的地图，把它转化成gif格式，命名为1.gif待用
然后，建立1S.xml，作为S剧本，内容
&lt;?xml version=&#34;1.0&#34; encoding=&#34;GB2312&#34;?&gt;
&lt;data&gt;
&lt;Map&gt;1&lt;/Map&gt;
&lt;/data&gt;
里面的1就是地图的代号，对应的地图就是1.gif了
要显示它，就很简单了
建立两个Sprite，
//最底层Sprite
private var _bakSprite:Sprite;
//地图Sprite
private var _mapSprite:Sprite;
将地图建立在底层的Sprite，方便之后操作
_bakSprite.addChild(_mapSprite);
//加载地图
_pic_loader = new Loader();
_pic_loader.contentLoaderInfo.addEventListener(Event.COMPLETE, onCompleteMap);
var mapName:String = &#34;Images/HM/&#34; &#43; _fightXml.Map &#43; &#34;.gif&#34;;
_pic_loader.load(new URLRequest(mapName));
//加载地图完毕
private function onCompleteMap(event:Event):void {
_pic_loader.contentLoaderInfo.removeEventListener(Event.COMPLETE, onCompleteMap);
_image = Bitmap(_pic_loader.content);
_mapSprite.addChild(_image);
}
然后，一张地图，就可以显示出来了
当然，光显示出来还不行，因为地图很大，窗口显示不了全部的地图，这样，就要像曹操传中的那样，当鼠标移动到边界的时候，地图就发生移动，看到自己想看的位置
所以，需要加入鼠标移动事件
//鼠标移动事件
this.addEventListener(MouseEvent.MOUSE_MOVE, mouseMoveHandler); //鼠标移动事件
private function mouseMoveHandler(event:MouseEvent):void{
var intX:int = event." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/902358a119de80d388811a78e6810d81/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2010-05-29T10:34:00+08:00" />
<meta property="article:modified_time" content="2010-05-29T10:34:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">用AS3.0开发flash版SLG游戏-1</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>说到经典的战棋游戏，我还是最痴迷于曹操传，以前也曾因为研究曹操传MOD而废寖忘食，也做过一个曹操传的MOD小热一时，</p> 
<p>却没想到曹操传MOD已经发展到现在这种地步，无论是画面还是技术都有了大规模的突破</p> 
<p>但是，修改永远是修改，总会遇到各种限制，想要突破，当然要自己动手，开发自己的引擎。<br>但是，在这里，我研究flash版的曹操传，目的并不是想要有任何突破，只是单纯的为了研究一下，熟悉一下用flash完成各种游戏的制作而已。</p> 
<p>先看几个预览</p> 
<p><img src="https://images2.imgbox.com/ff/15/SSpayRQB_o.jpg" alt="预览" width="972" height="634"></p> 
<p><img src="https://images2.imgbox.com/ca/ef/JnpmrhPy_o.gif" alt="预览" width="972" height="634"></p> 
<p><img src="https://images2.imgbox.com/50/f2/QmAFl7qH_o.jpg" alt="预览" width="979" height="638"></p> 
<p> </p> 
<p>下面开始制作过程</p> 
<p>首先，先建立一个战场，显示一张地图吧，<br>导出一张曹操传第一关颖川的地图，把它转化成gif格式，命名为1.gif待用<br>然后，建立1S.xml，作为S剧本，内容<br>&lt;?xml version="1.0" encoding="GB2312"?&gt;<br>&lt;data&gt;<br>    &lt;Map&gt;1&lt;/Map&gt;<br>&lt;/data&gt;<br>里面的1就是地图的代号，对应的地图就是1.gif了<br>要显示它，就很简单了<br>建立两个Sprite，<br>//最底层Sprite<br>private var _bakSprite:Sprite;<br>//地图Sprite<br>private var _mapSprite:Sprite;<br>将地图建立在底层的Sprite，方便之后操作<br>_bakSprite.addChild(_mapSprite);</p> 
<p>//加载地图<br>_pic_loader = new Loader();<br>_pic_loader.contentLoaderInfo.addEventListener(Event.COMPLETE, onCompleteMap);<br>var mapName:String = "Images/HM/" + _fightXml.Map + ".gif";<br>_pic_loader.load(new URLRequest(mapName));</p> 
<p>//加载地图完毕<br>private function onCompleteMap(event:Event):void {<!-- --><br>    _pic_loader.contentLoaderInfo.removeEventListener(Event.COMPLETE, onCompleteMap);<br>    _image = Bitmap(_pic_loader.content);<br>    _mapSprite.addChild(_image);<br>}<br>然后，一张地图，就可以显示出来了<br>当然，光显示出来还不行，因为地图很大，窗口显示不了全部的地图，这样，就要像曹操传中的那样，当鼠标移动到边界的时候，地图就发生移动，看到自己想看的位置<br>所以，需要加入鼠标移动事件<br>   //鼠标移动事件<br>   this.addEventListener(MouseEvent.MOUSE_MOVE, mouseMoveHandler); </p> 
<p>  //鼠标移动事件<br>  private function mouseMoveHandler(event:MouseEvent):void{<!-- --><br>   var intX:int = event.currentTarget.mouseX;<br>   var intY:int = event.currentTarget.mouseY;<br>   if(intX &lt; 48){<!-- --><br>     _mapXadd = 48;<br>   }else if(intX &gt; Sav.gamedata["stageWidth"] - 48){<!-- --><br>    _mapXadd = -48;<br>   }else{<!-- --><br>    _mapXadd = 0;<br>   }<br>   if(intY &lt; 48){<!-- --><br>    _mapYadd = 48;<br>   }else if(intY &gt; Sav.gamedata["stageHeight"] - 48){<!-- --><br>    _mapYadd = -48;<br>   }else{<!-- --><br>    _mapYadd = 0;<br>   }<br>  }<br>Sav.gamedata["stageWidth"] 是flash窗口的宽度，我把它存在了静态变量里了，方便用的时候取出来<br>这样，根据鼠标和地图位置，先来确定地图移动的x,y的方向和步长<br>然后，加入一个贞事件，来控制地图的移动<br>   //贞事件<br>   this.addEventListener(Event.ENTER_FRAME, mapMoveHandler); <br>  //贞事件<br>  private function mapMoveHandler(event:Event):void{<!-- --><br>   if(_mapMoveCtrl &gt; 5){<!-- --><br>    //根据地图移动用ｘｙ步长移动地图<br>    _bakSprite.x += _mapXadd;<br>    _bakSprite.y += _mapYadd;<br>    _mapMoveCtrl = 0;<br>   }<br>   //控制地图不移出指定范围<br>   if(_bakSprite.x &gt; 0){<!-- --><br>    _bakSprite.x = 0;<br>   }else if( _bakSprite.x &lt; Sav.gamedata["stageWidth"] - _bakSprite.width){<!-- --><br>    _bakSprite.x = Sav.gamedata["stageWidth"] - _bakSprite.width;<br>   }<br>   if(_bakSprite.y &gt; 0){<!-- --><br>    _bakSprite.y = 0;<br>   }else if( _bakSprite.y &lt; Sav.gamedata["stageHeight"] - _bakSprite.height){<!-- --><br>    _bakSprite.y = Sav.gamedata["stageHeight"] - _bakSprite.height;<br>   }<br>   _mapMoveCtrl ++;<br>  }<br>_mapMoveCtrl 用来控制地图移动的速度，然后只要控制地图不移出指定的范围就可以了<br>这样，运行一下，就可以让地图自由的移动位置了</p> 
<p> </p> 
<p>接下来，让地图上显示一个人物<br>导出曹操传中曹操的三个图片，去除背景，并保存为gif格式，就像下面这样</p> 
<p><img src="https://images2.imgbox.com/ef/90/NKz9AZPY_o.gif" alt="素材" width="48" height="528"></p> 
<p>首先，在1S.xml中加入<br>    &lt;Our&gt;<br>        &lt;List&gt;Caocao&lt;/List&gt;<br>    &lt;/Our&gt;<br>建立一个用来显示人物动作的类CharacterMC，<br>在类里面，读取完图片之后，将其按照规律拆分成数组，和之前我在做flashRPG游戏的时候一样，用的同样的方法，<br>  //Unit_mov图片加载完成<br>  public function onCompleteUnit_mov(event:Event):void {<!-- --><br>   _image = Bitmap(_loader.content);<br>   //初始化显示数组<br>   _bitShowArr = new Array();<br>   //将位图数据拆分成小块，装入bitmapArr<br>   _bitmapArr=ImageCtrl.divide(_image,1,11);<br>   var newArr:Array;<br>   //得到向上行走数组<br>   newArr = new Array(_bitmapArr[2][0],_bitmapArr[3][0]);<br>   //将向上行走数组加入到显示数组 编号:0<br>   _bitShowArr.push(newArr);<br>   //得到向下行走数组<br>   newArr = new Array(_bitmapArr[0][0],_bitmapArr[1][0]);<br>   //将向下行走数组加入到显示数组 编号:1<br>   _bitShowArr.push(newArr);<br>   //得到向左行走数组<br>   newArr = new Array(_bitmapArr[4][0],_bitmapArr[5][0]);<br>   //将向左行走数组加入到显示数组 编号:2<br>   _bitShowArr.push(newArr);<br>   //得到向右行走数组<br>   newArr = new Array(ImageCtrl.bitHorizontal(_bitmapArr[4][0]),ImageCtrl.bitHorizontal(_bitmapArr[5][0]));<br>   //将向右行走数组加入到显示数组 编号:3<br>   _bitShowArr.push(newArr);<br>   <br>   startFrame();<br>  }<br>然后显示的时候，只需要调用不同的编号，就可以显示不同的动作了<br>新建一个人物属性类，Character ，存放人物的属性<br> public class Character {<!-- --><br>  //人物显示控制类<br>  private var _characterMC:CharacterMC;<br>  //人物移动力<br>  private var _moveLong:int;<br>  //人物编号<br>  private var _charaIndex:int;</p> 
<p>然后在战场上，再另建一个Sprite，用来显示人物<br>  //人物Sprite<br>  private var _characterSprite:Sprite;<br>然后，在读取S剧本完成时，把人物加入<br>   //我军人物添加<br>   _ourArr = new Array();<br>   //根据xml内容，得到我军人物,添加至战场<br>   for each ( var ourment:XML in _fightXml.Our.elements( ) ) {<!-- --><br>    var ourName:String = ourment.toString();<br>    var ourchara:XML = XML(_pXml[ourName]);<br>    _characterMC = new CharacterMC(int(ourchara.Id));<br>    _character = new Character(_characterMC,int(ourchara.Move),int(ourchara.Id));<br>    _characterSprite.addChild(_characterMC);<br>    _ourArr.push(_character);<br>   }<br>运行就可以看到曹操出现在战场上了<br><img src="https://images2.imgbox.com/37/a8/PSSZRPpK_o.jpg" alt="预览" width="980" height="638"></p> 
<p>下面，开始控制曹操移动</p> 
<p>首先，先在CS4里，建立一个MC,加入三个按钮，如图<br><img src="https://images2.imgbox.com/c6/c8/4rhGqsjl_o.jpg" alt="素材" width="82" height="68"></p> 
<p>我暂时把地形全都设定成为可移动，且地形全都消耗1，1S.xml中<br>    &lt;DataMap&gt;<br> &lt;list&gt;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0&lt;/list&gt;<br> &lt;list&gt;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0&lt;/list&gt;<br> &lt;list&gt;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0&lt;/list&gt;<br> &lt;list&gt;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0&lt;/list&gt;<br> &lt;list&gt;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0&lt;/list&gt;<br> &lt;list&gt;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0&lt;/list&gt;<br> &lt;list&gt;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0&lt;/list&gt;<br> &lt;list&gt;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0&lt;/list&gt;<br> &lt;list&gt;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0&lt;/list&gt;<br> &lt;list&gt;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0&lt;/list&gt;<br> &lt;list&gt;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0&lt;/list&gt;<br> &lt;list&gt;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0&lt;/list&gt;<br> &lt;list&gt;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0&lt;/list&gt;<br> &lt;list&gt;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0&lt;/list&gt;<br> &lt;list&gt;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0&lt;/list&gt;<br> &lt;list&gt;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0&lt;/list&gt;<br> &lt;list&gt;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0&lt;/list&gt;<br> &lt;list&gt;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0&lt;/list&gt;<br> &lt;list&gt;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0&lt;/list&gt;<br> &lt;list&gt;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0&lt;/list&gt;<br>    &lt;/DataMap&gt;</p> 
<p>加入鼠标点击事件<br>   //鼠标点击事件<br>   addEventListener(MouseEvent.CLICK,onClick);</p> 
<p>  //鼠标点击事件<br>  private function onClick(event:Event):void{<!-- --><br>   var __mouseX:Number = event.currentTarget.mouseX;<br>   var __mouseY:Number = event.currentTarget.mouseY;<br>   var i:int;<br>   if(_clickCtrl == "NULL"){<!-- --><br>    for(i=0;i&lt;_ourArr.length;i++){<!-- --><br>     _character = _ourArr[i] as Character;<br>     _characterMC = _character.characterMC;<br>     if(Math.floor(_characterMC.x/48) == Math.floor(__mouseX/48) &amp;&amp; Math.floor(_characterMC.y/48) == Math.floor(__mouseY/48)){<!-- --><br>      _nowChatacter = _character;<br>      setRoad(_nowChatacter);<br>      _clickCtrl = "ROAD_SHOW";<br>      removeEventListener(MouseEvent.CLICK,onClick);<br>      _roadSprite.addEventListener(MouseEvent.CLICK,onClick);<br>      break;<br>     }<br>    }<br>   }else if(_clickCtrl == "ROAD_SHOW"){<!-- --><br>    _characterMC = _nowChatacter.characterMC;<br>    for(i=0;i&lt;_roadShowArray.length;i++){<!-- --><br>      _nowPoint = new Point(Math.floor(_characterMC.x/48),Math.floor(_characterMC.y/48));<br>      _nowDirection = _characterMC.getDir();<br>      _toPoint = new Point(Math.floor(__mouseX/48),Math.floor(__mouseY/48));<br>      _roadArray = _roadQuery.path4(_nowPoint,_toPoint,_roadShowArray);<br>      if(_roadArray != null &amp;&amp; _roadArray.length &gt; 0){<!-- --><br>       addEventListener(Event.ENTER_FRAME, onFrame);<br>       _clickCtrl == "MOVE_NOW"<br>       SpriteRemove.removeAllChildren(_roadSprite);<br>       _roadSprite.removeEventListener(MouseEvent.CLICK,onClick);<br>      }<br>    }<br>   }<br>   <br>   <br>  }<br>_clickCtrl 用来控制点击鼠标时，战场上的状态，当为NULL的时候，寻找点击的人物，然后开始寻找最大可移动的范围<br>    //循环搜寻可到达的点<br>    public function loopPath(thisPoint:Object):void{<!-- --><br>     if(thisPoint.moveLong &lt;= 0){<!-- --><br>      return;<br>     }<br>     <br>      if(! thisPoint.isChecked){<!-- --><br>      _path.push(thisPoint);<br>       thisPoint.isChecked = true;<br>      }<br>                    var checkList:Array = [];<br>                    //获取周围四个点<br>                    if (thisPoint.y&gt;0) {<!-- --><br>                       checkList.push(_map[(thisPoint.y-1)][thisPoint.x]);<br>                    }<br>                    if (thisPoint.x&gt;0) {<!-- --><br>                        checkList.push(_map[thisPoint.y][(thisPoint.x-1)]);<br>                    }<br>                    if (thisPoint.x&lt;_w-1) {<!-- --><br>                         checkList.push(_map[thisPoint.y][(thisPoint.x+1)]);<br>                    }<br>                    if (thisPoint.y&lt;_h-1) {<!-- --><br>                         checkList.push(_map[(thisPoint.y+1)][thisPoint.x]);<br>                    }<br>     for(var i=0;i&lt;checkList.length;i++){<!-- --><br>      if(!checkList[i].isChecked || checkList[i].moveLong &lt; thisPoint.moveLong){<!-- --><br>       checkList[i].moveLong = thisPoint.moveLong - 1;<br>       loopPath(checkList[i]);<br>      }<br>     } <br>    }<br>    //搜寻最大路径<br>                public function makePath(star:Point, moveLong:int):Array {<!-- --><br>                    _path = [];<br>                    var isOver:Boolean = false;<br>                    setStart();<br>                    _starPoint = _map[star.y][star.x];<br>     _starPoint.moveLong = moveLong;<br>     loopPath(_starPoint);<br>     return _path;<br>    }</p> 
<p><img src="https://images2.imgbox.com/a6/2f/WmSqpm8X_o.jpg" alt="预览" width="980" height="638"></p> 
<p>最大路径找好后，点击目标点，利用A*算法，走到目标点<br>_clickCtrl 用来控制点击鼠标时，战场上的状态，当为ROAD_SHOW的时候，查找路径，并走到目标点<br>A*算法，比较麻烦，就不多解释了，想了解的，可以看源代码<br>然后，行走完毕后，要显示出选择菜单，<br>  //人物移动事件贞控制<br>  private function onFrame(event:Event):void {<!-- --><br>   _characterMC = _nowChatacter.characterMC;<br>   if(_roadArray != null &amp;&amp; _roadArray.length &gt; 1){<!-- --><br>    if(_characterMC.x % 48 == 0 &amp;&amp; _characterMC.y % 48 == 0){<!-- --><br>      if(_roadArray[0].x == _roadArray[1].x){<!-- --><br>      if(_roadArray[0].y &gt; _roadArray[1].y){<!-- --><br>       _characterMC.setDir(0);<br>       _xadd = 0;<br>       _yadd = -_addLeng;<br>      }else{<!-- --><br>       _characterMC.setDir(1);<br>       _xadd = 0;<br>       _yadd = _addLeng;<br>      }<br>     }else{<!-- --><br>      if(_roadArray[0].x &gt; _roadArray[1].x){<!-- --><br>       _characterMC.setDir(2);<br>       _xadd = -_addLeng;<br>       _yadd = 0;<br>      }else{<!-- --><br>       _characterMC.setDir(3);<br>       _xadd = _addLeng;<br>       _yadd = 0;<br>      }<br>     }     </p> 
<p>     _roadArray.splice(0,1);<br>                                        <br>    }<br>    _characterMC.x += _xadd;<br>    _characterMC.y += _yadd;<br>                                <br>   }else if(_characterMC.x % 48 == 0 &amp;&amp; _characterMC.y % 48 == 0){<!-- --><br>    removeEventListener(Event.ENTER_FRAME, onFrame);<br>    _selectBox.visible = true;<br>    _selectBox.x = _characterMC.x + 48;<br>    _selectBox.y = _characterMC.y;<br>   }else{<!-- --><br>   <br>    _characterMC.x += _xadd;<br>    _characterMC.y += _yadd;<br>   }<br>  }<br>所以在战场初始化的时候，加入菜单按钮等事件<br>   <br>   //点击停止事件<br>   _selectBox.btnStop.addEventListener(MouseEvent.CLICK, charaStopHandler); <br>   //点击取消事件<br>   _selectBox.btnCan.addEventListener(MouseEvent.CLICK, charaCanHandler); <br>   //菜单隐藏<br>   _selectBox.visible = false;<br>效果如下图<br><img src="https://images2.imgbox.com/d0/2d/xvMuTo9J_o.jpg" alt="预览" width="980" height="638"></p> 
<p>接下来，显示一下地形，<br>准备一个Terrain.xml<br>&lt;?xml version="1.0" encoding="GB2312"?&gt;<br>&lt;data&gt;<br>    &lt;Terrain0&gt;<br> &lt;Name&gt;平原&lt;/Name&gt;<br> &lt;Image&gt;&lt;/Image&gt;<br>    &lt;/Terrain0&gt;<br>    &lt;Terrain1&gt;<br> &lt;Name&gt;草原&lt;/Name&gt;<br> &lt;Image&gt;&lt;/Image&gt;<br>    &lt;/Terrain1&gt;<br>    &lt;Terrain2&gt;<br> &lt;Name&gt;树林&lt;/Name&gt;<br> &lt;Image&gt;&lt;/Image&gt;<br>    &lt;/Terrain2&gt;<br>&lt;/data&gt;<br>暂时添加这三个地形，等有时间了之后，再慢慢加<br>然后，在CS4里，建立一个MC，如下，用来显示地形</p> 
<p><img src="https://images2.imgbox.com/0a/18/BWVaG3Us_o.jpg" alt="素材" width="145" height="146"></p> 
<p>剩下的就简单了，<br>在战场的鼠标点击事件中，当状态为NULL的时候，<br>   if(_clickCtrl == "NULL"){<!-- --><br>    var queryPeople:Boolean = false;<br>    //点击我军人物判断<br>    for(i=0;i&lt;_ourArr.length;i++){<!-- --><br>     _character = _ourArr[i] as Character;<br>     _characterMC = _character.characterMC;<br>     if(Math.floor(_characterMC.x/48) == Math.floor(__mouseX/48) &amp;&amp; Math.floor(_characterMC.y/48) == Math.floor(__mouseY/48)){<!-- --><br>      _nowChatacter = _character;<br>      setRoad(_nowChatacter);<br>      _clickCtrl = "ROAD_SHOW";<br>      removeEventListener(MouseEvent.CLICK,onClick);<br>      _roadSprite.addEventListener(MouseEvent.CLICK,onClick);<br>      queryPeople = true;<br>      break;<br>     }<br>    }<br>    //点击敌军人物判断<br>    for(i=0;i&lt;_enemyArr.length;i++){<!-- --><br>     //点击敌军人物动作<br>    }<br>    if(!queryPeople){<!-- --><br>     //点击地图，显示地形<br>     _clickCtrl = "TERRAIN_SHOW";<br>     var mapX:int = Math.floor((__mouseX - _bakSprite.x)/48);<br>     var mapY:int = Math.floor((__mouseY - _bakSprite.y)/48);<br>     var showX:int = Math.floor(__mouseX/48);<br>     var showY:int = Math.floor(__mouseY/48);<br>     var terrainId:int = _mapDate[mapX][mapY];<br>     var terrainName:String = "Terrain" + terrainId;<br>     _terrainBox.x = showX*48 - 48;<br>     _terrainBox.y = showY*48 - 48;<br>     if(_terrainBox.x &lt; 0){<!-- --><br>      _terrainBox.x = 0;<br>     }else if(_terrainBox.x &gt; Sav.gamedata["stageWidth"] - 144){<!-- --><br>      _terrainBox.x = Sav.gamedata["stageWidth"] - 144;<br>     }<br>     if(_terrainBox.y &lt; 0){<!-- --><br>      _terrainBox.y = 0;<br>     }else if(_terrainBox.y &gt; Sav.gamedata["stageHeight"] - 144){<!-- --><br>      _terrainBox.y = Sav.gamedata["stageHeight"] - 144;<br>     }<br>     _terrainBox.TerrainName.text = _terrain[terrainName].Name;<br>     SpriteRemove.removeAllChildren(_terrainBox.TerrainShow);<br>     _terrainBox.TerrainShow.addChild(ImageCtrl.getImage(_bmapimage,mapX*48,mapY*48,48,48));<br>     removeEventListener(MouseEvent.CLICK,onClick);<br>     _terrainBox.visible = true;<br>    }<br>   }else if(_clickCtrl == "ROAD_SHOW"){<!-- --><br>就是说，点击的地方如果没有人，则显示地形框<br>然后，在鼠标移动的时候，把地形框隐藏掉<br>  //鼠标移动事件<br>  private function mouseMoveHandler(event:MouseEvent):void{<!-- --><br>   var intX:int = event.currentTarget.mouseX;<br>   var intY:int = event.currentTarget.mouseY;<br>   if(intX &lt; 48){<!-- --><br>     _mapXadd = 48;<br>   }else if(intX &gt; Sav.gamedata["stageWidth"] - 48 &amp;&amp; intX &lt;= Sav.gamedata["stageWidth"]){<!-- --><br>    _mapXadd = -48;<br>   }else{<!-- --><br>    _mapXadd = 0;<br>   }<br>   if(intY &lt; 48){<!-- --><br>    _mapYadd = 48;<br>   }else if(intY &gt; Sav.gamedata["stageHeight"] - 48 &amp;&amp; intY &lt;= Sav.gamedata["stageHeight"]){<!-- --><br>    _mapYadd = -48;<br>   }else{<!-- --><br>    _mapYadd = 0;<br>   }<br>   if(_terrainBox.visible){<!-- --><br>    _clickCtrl = "NULL";<br>    _terrainBox.visible = false;<br>    addEventListener(MouseEvent.CLICK,onClick);<br>   }<br>  }<br>看吧，效果如下图</p> 
<p><img src="https://images2.imgbox.com/d2/40/Ey1nAwqE_o.jpg" alt="预览" width="972" height="634"></p> 
<p>因为地形我全都设定成了0，所以现在点哪里都是平原</p> 
<p>剩下的就是把1S.xml的地形好好设定下了</p> 
<p>下次，研究在各种地形下行走的范围^0^!</p> 
<p>下面，来继续在不同地形下的寻路问题<br>首先，准备好兵种数据Arms.xml<br>&lt;?xml version="1.0" encoding="GB2312"?&gt;<br>&lt;data&gt;<br>    &lt;Arms1&gt;<br> &lt;Name&gt;英雄&lt;/Name&gt;<br> &lt;Property&gt;<br>     &lt;Attack&gt;A&lt;/Attack&gt;<br>     &lt;Spirit&gt;A&lt;/Spirit&gt;<br>     &lt;Defense&gt;A&lt;/Defense&gt;<br>     &lt;Breakout&gt;A&lt;/Breakout&gt;<br>     &lt;Morale&gt;A&lt;/Morale&gt;<br> &lt;/Property&gt;<br> &lt;Terrain&gt;<br>     &lt;Terrain0&gt;1&lt;/Terrain0&gt;<br>     &lt;Terrain1&gt;1&lt;/Terrain1&gt;<br>     &lt;Terrain2&gt;2&lt;/Terrain2&gt;<br>     &lt;Terrain3&gt;100&lt;/Terrain3&gt;<br>     &lt;Terrain4&gt;100&lt;/Terrain4&gt;<br>     &lt;Terrain5&gt;1&lt;/Terrain5&gt;<br>     &lt;Terrain6&gt;1&lt;/Terrain6&gt;<br>     &lt;Terrain7&gt;1&lt;/Terrain7&gt;<br> &lt;/Terrain&gt;<br>    &lt;/Arms1&gt;<br>&lt;/data&gt;<br>地形数据Terrain.xml<br>&lt;?xml version="1.0" encoding="GB2312"?&gt;<br>&lt;data&gt;<br>    &lt;Terrain0&gt;平原&lt;/Terrain0&gt;<br>    &lt;Terrain1&gt;草原&lt;/Terrain1&gt;<br>    &lt;Terrain2&gt;树林&lt;/Terrain2&gt;<br>    &lt;Terrain3&gt;大河&lt;/Terrain3&gt;<br>    &lt;Terrain4&gt;栅栏&lt;/Terrain4&gt;<br>    &lt;Terrain5&gt;城池&lt;/Terrain5&gt;<br>    &lt;Terrain6&gt;村庄&lt;/Terrain6&gt;<br>    &lt;Terrain7&gt;帐篷&lt;/Terrain7&gt;<br>&lt;/data&gt;<br>人物属性上当然要对应好兵种<br>&lt;?xml version="1.0" encoding="GB2312"?&gt;<br>&lt;data&gt;<br>    &lt;Caocao&gt;<br> &lt;Id&gt;1&lt;/Id&gt;<br> &lt;Name&gt;曹操&lt;/Name&gt;<br> &lt;Arms&gt;1&lt;/Arms&gt;<br> &lt;Lv&gt;1&lt;/Lv&gt;<br> &lt;Exp&gt;0&lt;/Exp&gt;<br> &lt;HP&gt;100&lt;/HP&gt;<br> &lt;MP&gt;50&lt;/MP&gt;<br> &lt;Move&gt;5&lt;/Move&gt;<br>    &lt;/Caocao&gt;<br>&lt;/data&gt;<br>其中，Arms是兵种ID,Move是移动力<br>最后，设定下战场文件1S.xml<br>&lt;?xml version="1.0" encoding="GB2312"?&gt;<br>&lt;data&gt;<br>    &lt;Map&gt;1&lt;/Map&gt;<br>    &lt;DataMap&gt;<br> &lt;list&gt;1,1,1,1,1,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1&lt;/list&gt;<br> &lt;list&gt;3,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1&lt;/list&gt;<br> &lt;list&gt;3,3,1,1,1,1,0,0,0,0,1,1,1,1,1,1,1,1,1,1&lt;/list&gt;<br> &lt;list&gt;3,3,3,1,1,1,1,0,0,0,1,1,1,1,1,1,1,1,3,3&lt;/list&gt;<br> &lt;list&gt;3,3,3,3,1,1,1,0,0,0,0,1,1,1,1,1,1,3,3,3&lt;/list&gt;<br> &lt;list&gt;3,3,3,3,3,1,1,0,0,0,0,0,1,1,1,1,1,3,3,3&lt;/list&gt;<br> &lt;list&gt;3,3,3,3,3,4,4,4,4,0,0,4,4,4,4,1,1,3,3,3&lt;/list&gt;<br> &lt;list&gt;3,3,3,3,3,4,6,0,0,0,0,0,0,6,4,1,3,3,3,3&lt;/list&gt;<br> &lt;list&gt;3,3,3,3,3,4,6,0,0,0,0,0,0,6,4,1,3,3,3,3&lt;/list&gt;<br> &lt;list&gt;3,3,3,3,0,4,6,0,0,0,0,0,0,0,4,1,3,3,3,3&lt;/list&gt;<br> &lt;list&gt;3,3,3,0,0,0,0,0,0,4,4,0,0,0,4,3,3,3,3,3&lt;/list&gt;<br> &lt;list&gt;3,3,0,0,0,0,0,0,0,5,7,0,0,0,4,3,3,3,3,3&lt;/list&gt;<br> &lt;list&gt;3,0,0,0,0,4,0,0,0,0,0,0,0,0,4,3,3,3,3,3&lt;/list&gt;<br> &lt;list&gt;0,0,0,0,0,4,6,6,0,0,0,0,0,7,4,0,3,3,3,3&lt;/list&gt;<br> &lt;list&gt;0,0,0,0,0,4,4,4,4,0,0,4,4,4,4,0,1,1,3,3&lt;/list&gt;<br> &lt;list&gt;0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,1,1,3&lt;/list&gt;<br> &lt;list&gt;1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,1,1&lt;/list&gt;<br> &lt;list&gt;1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,1&lt;/list&gt;<br> &lt;list&gt;1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,1,1,1,1&lt;/list&gt;<br> &lt;list&gt;1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,1,1,1,1,1&lt;/list&gt;<br>    &lt;/DataMap&gt;<br>    &lt;Our&gt;<br>        &lt;List x="10" y="5"&gt;Caocao&lt;/List&gt;<br>    &lt;/Our&gt;<br>    &lt;Enemy /&gt;<br>&lt;/data&gt;</p> 
<p>然后开始利用这些数据，完成寻路<br>首先在添加战场人物的时候，要把相应的兵种和移动力都得到<br>   //我军人物添加<br>   _ourArr = new Array();<br>   //根据xml内容，得到我军人物,添加至战场<br>   for each ( var ourment:XML in _fightXml.Our.elements( ) ) {<!-- --><br>    var ourName:String = ourment.toString();<br>    var ourchara:XML = XML(_pXml[ourName]);<br>    _characterMC = new CharacterMC(int(ourchara.Id));<br>    _characterMC.x = int(<a href="mailto:ourment.@x%29*48" rel="nofollow">ourment.@x)*48</a>;<br>    _characterMC.y = int(<a href="mailto:ourment.@y%29*48" rel="nofollow">ourment.@y)*48</a>;<br>    _character = new Character(_characterMC,int(ourchara.Move),int(ourchara.Id),int(ourchara.Arms));<br>    _characterSprite.addChild(_characterMC);<br>    _ourArr.push(_character);<br>   }<br>Character类中，加入兵种ID属性就可以了</p> 
<p>然后，寻路的时候，把当前人物传到makePath方法中</p> 
<p>  //寻找最大移动范围<br>  private function setRoad(chara:Character){<!-- --><br>   _roadShowArray = _roadQuery.makePath(chara);<br>   <br>   if(_roadShowArray != null &amp;&amp; _roadShowArray.length &gt; 0){<!-- --><br>    var sign:Sign;<br>    for(var i:int = 0;i&lt;_roadShowArray.length;i++){<!-- --><br>     sign = new Sign();<br>     sign.x = _roadShowArray[i].x * 48;<br>     sign.y = _roadShowArray[i].y * 48;<br>     _roadSprite.addChild(sign);<br>    }<br>   }<br>  }</p> 
<p>_roadQuery方法中,移动力和起始坐标都根据当前人物得到<br>                public function makePath(chara:Character):Array {<!-- --><br>     _chara = chara;<br>                    _path = [];<br>                    var isOver:Boolean = false;<br>                    setStart();<br>                    _starPoint = _map[Math.floor(chara.characterMC.y/48)][Math.floor(chara.characterMC.x/48)];<br>     _starPoint.moveLong = chara.moveLong;<br>     loopPath(_starPoint);<br>     return _path;<br>    }<br>然后，在loopPath方法中，做最后的修改<br>checkPoint.moveLong = thisPoint.moveLong - 1;是用来计算下一个点的剩余移动力的，<br>之前，所有点的移动力都是由当前点的移动力-1<br>把它改为<br>var cost:int = int(XML(Sav.gamedata["Arms"])["Arms" + _chara.armsIndex]["Terrain"]["Terrain" + _map[checkPoint.y][checkPoint.x].value]);<br>       checkPoint.moveLong = thisPoint.moveLong - cost;<br>就是减去下一个点的消耗移动力，这个消耗移动力在兵种数据文件中已经设定好了，直接读取就可以了<br>运行代码，效果如下</p> 
<p><img src="https://images2.imgbox.com/30/0a/EOq0a8hf_o.jpg" alt="预览" width="972" height="634"></p> 
<p>下次，该研究一下，加入敌军的人物问题了</p> 
<p>其实，加入敌军人物，只需要在1S.xml中加入几个人物就可以了<br>    &lt;Our&gt;<br>        &lt;List x="10" y="4"&gt;1&lt;/List&gt;<br>        &lt;List x="10" y="5"&gt;98&lt;/List&gt;<br>    &lt;/Our&gt;<br>    &lt;Enemy&gt;<br>        &lt;List x="12" y="5"&gt;100&lt;/List&gt;<br>        &lt;List x="16" y="5"&gt;103&lt;/List&gt;<br>    &lt;/Enemy&gt;<br>然后配置好，相应的兵种数据和人物数据，就可以在战场上显示了<br>剩下的还要改动一下寻路的方法，把战场上有人物的地方，改为消耗移动力100</p> 
<p>                public function makePath(chara:Character):Array {<!-- --><br>     _chara = chara;<br>                    _path = [];<br>                    var isOver:Boolean = false;<br>                    setStart();<br>     _enemyCost = new Object();<br>     var i:int = 0;<br>     var objarr:Array;<br>     objarr = _fightMap.enemyArr;<br>     for(i=0;i&lt;objarr.length;i++){<!-- --><br>      _enemyCost[objarr[i].locationX + "-" +objarr[i].locationY] = 100;<br>     }<br>     objarr = _fightMap.ourArr;<br>     for(i=0;i&lt;objarr.length;i++){<!-- --><br>      _enemyCost[objarr[i].locationX + "-" +objarr[i].locationY] = 100;<br>     }<br>                    _starPoint = _map[Math.floor(chara.character.y/48)][Math.floor(chara.character.x/48)];<br>     _starPoint.moveLong = chara.moveLong;<br>     loopPath(_starPoint);<br>     <br>     return _path;<br>    }</p> 
<p>    public function loopPath(thisPoint:Object):void{<!-- --><br>     if(thisPoint.moveLong &lt;= 0){<!-- --><br>      return;<br>     }<br>     <br>      if(! thisPoint.isChecked){<!-- --><br>      _path.push(thisPoint);<br>       thisPoint.isChecked = true;<br>      }<br>                    var checkList:Array = [];<br>                    //获取周围四个点<br>                    if (thisPoint.y&gt;0) {<!-- --><br>                       checkList.push(_map[(thisPoint.y-1)][thisPoint.x]);<br>                    }<br>                    if (thisPoint.x&gt;0) {<!-- --><br>                        checkList.push(_map[thisPoint.y][(thisPoint.x-1)]);<br>                    }<br>                    if (thisPoint.x&lt;_w-1) {<!-- --><br>                         checkList.push(_map[thisPoint.y][(thisPoint.x+1)]);<br>                    }<br>                    if (thisPoint.y&lt;_h-1) {<!-- --><br>                         checkList.push(_map[(thisPoint.y+1)][thisPoint.x]);<br>                    }<br>     for(var i=0;i&lt;checkList.length;i++){<!-- --><br>                         var checkPoint:Object = checkList[i];<br>      if(!checkPoint.isChecked || checkPoint.moveLong &lt; thisPoint.moveLong){<!-- --><br>       var cost:int = int(XML(Sav.gamedata["Arms"])["Arms" + _chara.armsIndex]["Terrain"]["Terrain" + _map[checkPoint.y][checkPoint.x].value]);<br>       cost += _enemyCost[checkPoint.x + "-" + checkPoint.y] == null ? 0:_enemyCost[checkPoint.x + "-" + checkPoint.y];<br>       checkPoint.moveLong = thisPoint.moveLong - cost;<br>       loopPath(checkPoint);<br>      }<br>     } <br>    }<br>这样战场上有人的地方就移动不过去了</p> 
<p>接下来，来给每个人加上攻击范围的光标<br>准备好攻击范围显示的光标MC</p> 
<p><img src="https://images2.imgbox.com/3e/c5/X1kuepOj_o.jpg" alt="素材" width="53" height="53"></p> 
<p>然后，在相应的兵种数据中加上攻击范围的控制<br>如英雄<br>    &lt;Arms1&gt;<br> &lt;Name&gt;英雄&lt;/Name&gt;<br> &lt;Property&gt;<br>     &lt;Attack&gt;A&lt;/Attack&gt;<br>     &lt;Spirit&gt;A&lt;/Spirit&gt;<br>     &lt;Defense&gt;A&lt;/Defense&gt;<br>     &lt;Breakout&gt;A&lt;/Breakout&gt;<br>     &lt;Morale&gt;A&lt;/Morale&gt;<br> &lt;/Property&gt;<br> &lt;Terrain&gt;<br>     &lt;Terrain0&gt;1&lt;/Terrain0&gt;<br>     &lt;Terrain1&gt;1&lt;/Terrain1&gt;<br>     &lt;Terrain2&gt;2&lt;/Terrain2&gt;<br>     &lt;Terrain3&gt;100&lt;/Terrain3&gt;<br>     &lt;Terrain4&gt;100&lt;/Terrain4&gt;<br>     &lt;Terrain5&gt;1&lt;/Terrain5&gt;<br>     &lt;Terrain6&gt;1&lt;/Terrain6&gt;<br>     &lt;Terrain7&gt;1&lt;/Terrain7&gt;<br> &lt;/Terrain&gt;<br> &lt;RangeAttack&gt;<br>     &lt;List&gt;0,-1&lt;/List&gt;<br>     &lt;List&gt;0,1&lt;/List&gt;<br>     &lt;List&gt;-1,0&lt;/List&gt;<br>     &lt;List&gt;1,0&lt;/List&gt;<br> &lt;/RangeAttack&gt;<br>    &lt;/Arms1&gt;<br>其中RangeAttack代表以当前人物为坐标的相对攻击范围<br>然后在战场类中加一个函数<br>  //攻击范围显示<br>  private function setAttRound(armIndex:int):void{<!-- --><br>   var attRoundArr:Array;<br>   var attRound:AttBox;<br>   for each ( var roundment:XML in _arms["Arms" + armIndex]["RangeAttack"].elements( ) ) {<!-- --><br>    attRound = new AttBox();<br>    attRoundArr = roundment.toString().split(",");<br>    attRound.x = (int(attRoundArr[0]) + _nowChatacter.locationX )*48;<br>    attRound.y = (int(attRoundArr[1]) + _nowChatacter.locationY) *48;<br>    _roadSprite.addChild(attRound);<br>   }<br>   <br>  }<br>其中AttBox是预先准备好的攻击范围显示的光标MC<br>然后，在寻找最大行动范围的时候，调用这个函数<br>就可以显示攻击范围了，效果如图</p> 
<p><img src="https://images2.imgbox.com/5b/0b/0bW9aptH_o.jpg" alt="预览" width="980" height="638"></p> 
<p>接下来，研究一下回合控制，和敌军回合的时候，敌军的行动</p> 
<p>这次除了添加一些东西外，改动也比较大<br>具体改了哪里，也忘了做记录了<br>最后成形的战场类代码如下FightMap .as</p> 
<p>package Caocao.Mains{<!-- --><br> import Lufy.Images.ImageCtrl;<br> import Lufy.Sprite.SpriteRemove;<br> import Caocao.Character.CharacterMC;<br> import Caocao.Character.Character;<br> import Caocao.ot.RoadQuery;<br> import Lufy.Xml.XMLLoader;<br> <br> import flash.net.URLLoader;<br> import flash.display.Sprite;<br> import flash.display.Bitmap;<br> import flash.display.BitmapData;<br> import flash.display.Loader;<br> import flash.events.Event;<br> import flash.net.URLRequest;<br> import flash.geom.Point;<br> import flash.events.MouseEvent;<br>    import flash.utils.Timer;<br> import flash.events.KeyboardEvent;<br> import flash.text.*;<br> <br> public class FightMap extends Sprite { <br>  //最底层Sprite<br>  private var _bakSprite:Sprite;<br>  //地图Sprite<br>  private var _mapSprite:Sprite;<br>  //人物Sprite<br>  private var _characterSprite:Sprite;<br>  //通路Sprite<br>  private var _roadSprite:Sprite;<br>  //战场Xml<br>  private var _fightXml:XML;<br>  //地形数组<br>  private var _mapData:Array;<br>  //图片载入器<br>  private var _pic_loader:Loader;<br>  //xml载入器<br>  private var _xml_loader:XMLLoader;<br>  //声明Bitmap<br>  private var _image:Bitmap;<br>  //大地图Bitmap<br>  private var _bmapimage:Bitmap;<br>  //人物类<br>  private var _character:Character;<br>  private var _characterMC:CharacterMC;<br>  private var _nowChatacter:Character;<br>  //我军数组<br>  private var _ourArr:Array;<br>  //敌军数组<br>  private var _enemyArr:Array;<br>  //寻路类<br>  private var _roadQuery:RoadQuery;<br>  //储存路径数组<br>  private var _roadArray:Array;<br>  //表示路径数组<br>  private var _roadShowArray:Array;<br>  //人物移动控制<br>  private var _xadd:int = 0;<br>  private var _yadd:int = 0;<br>  //人物移动步长<br>  private var _addLeng:int = 4;<br>  //移动起始坐标<br>  private var _nowPoint:Point;<br>  //移动起始方向<br>  private var _nowDirection:int;<br>  //移动目的地坐标<br>  private var _toPoint:Point;<br>  //点击动作控制<br>  private var _clickCtrl:String = "NULL";<br>  //人物数据<br>  private var _pXml:XML;<br>  //地形数据<br>  private var _terrain:XML;<br>  //兵种数据<br>  private var _arms:XML;<br>  //选择菜单<br>  private var _selectBox:SelectBox;<br>  //地图移动速度控制<br>  private var _mapMoveCtrl:int = 0;<br>  //地图移动用ｘｙ步长<br>  private var _mapXadd:int = 0;<br>  private var _mapYadd:int = 0;<br>  //地形框<br>  private var _terrainBox:TerrainShowBox;<br>  //回合控制<br>  private var _roundCtrl:String = "我方回合";<br>  //回合数<br>  private var _roundIndex:int = 1;<br>  //鼠标框<br>  private var _mouseBox:MouseBox;<br>  //敌方行动控制用<br>  private var _enemyActionCtrl:int = 0;<br>  //回合显示信息<br>  private var _roundShow:TextField ;<br>  //回合显示信息控制用<br>  private var _roundShowCtrl:int = 0;<br>  public function FightMap(mapXmlSrc:String,fun:Function,gameMap:GameStart) { <br>   //添加显示Sprite<br>   _bakSprite = new Sprite();<br>   addChild(_bakSprite);<br>   _mapSprite = new Sprite();<br>   _bakSprite.addChild(_mapSprite);<br>   _characterSprite = new Sprite();<br>   _bakSprite.addChild(_characterSprite);<br>   _roadSprite = new Sprite();<br>   _bakSprite.addChild(_roadSprite);<br>   <br>   _mouseBox = new MouseBox();<br>   _bakSprite.addChild(_mouseBox);<br>   <br>   _selectBox = new SelectBox();<br>   _bakSprite.addChild(_selectBox);<br>   <br>   _terrainBox = new TerrainShowBox();<br>   addChild(_terrainBox);<br>   <br>   textInit();<br>   <br>   //菜单事件<br>   //点击停止事件<br>   _selectBox.btnStop.addEventListener(MouseEvent.CLICK, charaStopHandler); <br>   //点击取消事件<br>   _selectBox.btnCan.addEventListener(MouseEvent.CLICK, charaCanHandler); <br>   //菜单隐藏<br>   _selectBox.visible = false;<br>   <br>   <br>   //地形显示框隐藏<br>   _terrainBox.visible = false;<br>   <br>   //得到所有人物数据<br>   _pXml = Sav.gamedata["people"] as XML;<br>   //得到所有地形数据<br>   _terrain = Sav.gamedata["Terrain"] as XML;<br>   //得到所有兵种数据<br>   _arms = Sav.gamedata["Arms"] as XML;<br>   <br>   //鼠标点击事件<br>   _bakSprite.addEventListener(MouseEvent.CLICK,onClick);<br>   //贞事件<br>   this.addEventListener(Event.ENTER_FRAME, mapMoveHandler); <br>   <br>   //鼠标移动事件<br>   addEventListener(MouseEvent.MOUSE_MOVE, mouseMoveHandler); <br>   //鼠标移动事件<br>   _bakSprite.addEventListener(MouseEvent.MOUSE_MOVE, mouseBakMoveHandler); <br>   <br>   //载入人物属性Xml<br>   _xml_loader = new XMLLoader();<br>   _xml_loader.onLoadComplete      = initStage;<br>   _xml_loader.load(mapXmlSrc, XMLLoader.GB2312);<br>  }<br>  //文本格式<br>  private function textInit():void{<!-- --><br>  <br>   _roundShow = new TextField();<br>   _roundShow.autoSize = TextFieldAutoSize.LEFT;<br>   var formatter:TextFormat = new TextFormat( );<br>   formatter.color = 0xCCCCCC;<br>   formatter.size = 60;<br>   formatter.bold = true;<br>   _roundShow.defaultTextFormat = formatter;<br>   _roundShow.text = "";<br>   addChild(_roundShow);<br>  }<br>  //贞事件<br>  private function mapMoveHandler(event:Event):void{<!-- --><br>   if(_mapMoveCtrl &gt; 5){<!-- --><br>    //根据地图移动用ｘｙ步长移动地图<br>    _bakSprite.x += _mapXadd;<br>    _bakSprite.y += _mapYadd;<br>    _mapMoveCtrl = 0;<br>   }<br>   //控制地图不移出指定范围<br>   if(_bakSprite.x &gt; 0){<!-- --><br>    _bakSprite.x = 0;<br>   }else if( _bakSprite.x &lt; Sav.gamedata["stageWidth"] - _bakSprite.width){<!-- --><br>    _bakSprite.x = Sav.gamedata["stageWidth"] - _bakSprite.width;<br>   }<br>   if(_bakSprite.y &gt; 0){<!-- --><br>    _bakSprite.y = 0;<br>   }else if( _bakSprite.y &lt; Sav.gamedata["stageHeight"] - _bakSprite.height){<!-- --><br>    _bakSprite.y = Sav.gamedata["stageHeight"] - _bakSprite.height;<br>   }<br>   if(_roundShowCtrl == 0){<!-- --><br>    _roundShow.text = "第" + _roundIndex + "回合/n";<br>    _roundShow.x = (Sav.gamedata["stageWidth"] - _roundShow.width)/2;<br>    _roundShow.y = (Sav.gamedata["stageHeight"] - _roundShow.height)/2;<br>   }else if(_roundShowCtrl == 40){<!-- --><br>    _roundShow.text = "/n" + _roundCtrl;<br>    _roundShow.x = (Sav.gamedata["stageWidth"] - _roundShow.width)/2;<br>    _roundShow.y = (Sav.gamedata["stageHeight"] - _roundShow.height)/2;<br>   }else if(_roundShowCtrl == 80){<!-- --><br>    _roundShow.text = "";<br>    if(_roundCtrl == "我方回合"){<!-- --><br>     _bakSprite.addEventListener(MouseEvent.CLICK,onClick);<br>    }else if(_roundCtrl == "敌方回合"){<!-- --><br>     addEventListener(Event.ENTER_FRAME, onEnemyFrame);<br>    }<br>   }<br>   _roundShowCtrl++;<br>   _mapMoveCtrl ++;<br>  }<br>  //鼠标移动事件<br>  private function mouseBakMoveHandler(event:MouseEvent):void{<!-- --><br>   var intX:int = event.currentTarget.mouseX;<br>   var intY:int = event.currentTarget.mouseY;<br>   _mouseBox.x = Math.floor(intX/48)*48;<br>   _mouseBox.y = Math.floor(intY/48)*48;<br>  }<br>  //鼠标移动事件<br>  private function mouseMoveHandler(event:MouseEvent):void{<!-- --><br>   var intX:int = event.currentTarget.mouseX;<br>   var intY:int = event.currentTarget.mouseY;<br>   if(intX &lt; 48){<!-- --><br>     _mapXadd = 48;<br>   }else if(intX &gt; Sav.gamedata["stageWidth"] - 48 &amp;&amp; intX &lt;= Sav.gamedata["stageWidth"]){<!-- --><br>    _mapXadd = -48;<br>   }else{<!-- --><br>    _mapXadd = 0;<br>   }<br>   if(intY &lt; 48){<!-- --><br>    _mapYadd = 48;<br>   }else if(intY &gt; Sav.gamedata["stageHeight"] - 48 &amp;&amp; intY &lt;= Sav.gamedata["stageHeight"]){<!-- --><br>    _mapYadd = -48;<br>   }else{<!-- --><br>    _mapYadd = 0;<br>   }<br>   if(_terrainBox.visible){<!-- --><br>    _clickCtrl = "NULL";<br>    _terrainBox.visible = false;<br>    _bakSprite.addEventListener(MouseEvent.CLICK,onClick);<br>   }<br>   if(_clickCtrl == "ENEMY_ROUND_SHOW"){<!-- --><br>    _clickCtrl = "NULL";<br>    SpriteRemove.removeAllChildren(_roadSprite);<br>    _bakSprite.addEventListener(MouseEvent.CLICK,onClick);<br>   }<br>  }<br>  <br>  //用来重新载入点击事件<br>  private function onClickFrame(event:Event):void {<!-- --><br>   removeEventListener(Event.ENTER_FRAME, onClickFrame);<br>   var ctrl:Boolean = false;<br>   var i:int;<br>   for(i = 0;i&lt;_ourArr.length;i++){<!-- --><br>    if(!_ourArr[i].actionCtrl){<!-- --><br>     ctrl = true;<br>     break;<br>    }<br>   }<br>   if(!ctrl){<!-- --><br>    _roundCtrl = "敌方回合";<br>    for(i=0;i&lt;_enemyArr.length;i++){<!-- --><br>     _enemyArr[i].actionCtrl = false;<br>    }<br>    _enemyActionCtrl = 0;<br>    //addEventListener(Event.ENTER_FRAME, onEnemyFrame);<br>    _roundShowCtrl  = 40;<br>   }else{<!-- --><br>    _bakSprite.addEventListener(MouseEvent.CLICK,onClick);<br>   }<br>  }<br>  <br>  //控制敌军行动事件<br>  private function onEnemyFrame(event:Event):void {<!-- --><br>   var i:int;<br>   var toDistance:int;<br>   var checkDistance:int;<br>   if(_clickCtrl == "NULL"){<!-- --><br>    _nowChatacter = null;<br>    //寻找未行动人员<br>    for(i=0;i&lt;_enemyArr.length;i++){<!-- --><br>     if(!_enemyArr[i].actionCtrl){<!-- --><br>      _nowChatacter = _enemyArr[i];<br>      break;<br>     } <br>    }<br>    //如果全部行动完毕，则进入我军回合<br>    if(_nowChatacter == null){<!-- --><br>     _roundCtrl = "我方回合";<br>     for(i=0;i&lt;_ourArr.length;i++){<!-- --><br>      _ourArr[i].actionCtrl = false;<br>     }<br>     removeEventListener(Event.ENTER_FRAME, onEnemyFrame);<br>     _roundIndex ++;<br>     _roundShowCtrl  = 0;<br>     return;<br>    }<br>    if(_enemyActionCtrl == 0){<!-- --><br>     //得到为行动人员，开始寻路显示<br>     _clickCtrl = "ROAD_SHOW";<br>     setRoad(_nowChatacter);<br>    }<br>   }<br>   if(_clickCtrl == "ROAD_SHOW" &amp;&amp; _enemyActionCtrl == 10){<!-- --><br>    //开始行动<br>    _toPoint = new Point(_roadShowArray[0].x,_roadShowArray[0].y);<br>    i = Math.random() * _ourArr.length;<br>    _character = _ourArr[i];<br>    toDistance = Math.abs(_character.locationX - _toPoint.x) + Math.abs(_character.locationY - _toPoint.y) ;<br>    for(i=1;i&lt;_roadShowArray.length;i++){<!-- --><br>     checkDistance = Math.abs(_character.locationX - _roadShowArray[i].x) + Math.abs(_character.locationY - _roadShowArray[i].y) ;<br>     if(checkDistance &lt; toDistance){<!-- --><br>      toDistance = checkDistance;<br>      _toPoint.x = _roadShowArray[i].x;<br>      _toPoint.y = _roadShowArray[i].y;<br>     }<br>    }<br>    _nowPoint = new Point( _nowChatacter.locationX, _nowChatacter.locationY);<br>    _nowDirection = _characterMC.getDir();<br>    charaToMove();<br>   }<br>   _enemyActionCtrl ++;<br>   <br>  }<br>  //点击停止事件<br>  private function charaStopHandler(event:MouseEvent):void{<!-- --><br>   _clickCtrl = "NULL";<br>   _nowChatacter.actionCtrl = true;<br>   _selectBox.visible = false;<br>   addEventListener(Event.ENTER_FRAME, onClickFrame);<br>  }<br>  //点击取消事件<br>  private function charaCanHandler(event:MouseEvent):void{<!-- --><br>   _clickCtrl = "NULL";<br>   _selectBox.visible = false;<br>   _characterMC = _nowChatacter.character;<br>   _characterMC.x = _nowPoint.x * 48;<br>   _characterMC.y = _nowPoint.y * 48;<br>   _characterMC.setDir(_nowDirection);<br>   addEventListener(Event.ENTER_FRAME, onClickFrame);<br>  }<br>  <br>  //寻找最大移动范围<br>  private function setRoad(chara:Character){<!-- --><br>   _roadShowArray = _roadQuery.makePath(chara);<br>   <br>   if(_roadShowArray != null &amp;&amp; _roadShowArray.length &gt; 0){<!-- --><br>    var sign:Sign;<br>    for(var i:int = 0;i&lt;_roadShowArray.length;i++){<!-- --><br>     sign = new Sign();<br>     sign.x = _roadShowArray[i].x * 48;<br>     sign.y = _roadShowArray[i].y * 48;<br>     _roadSprite.addChild(sign);<br>    }<br>    setAttRound(_pXml["peo" + _nowChatacter.charaIndex].Arms);<br>   }<br>  }<br>  //攻击范围显示<br>  private function setAttRound(armIndex:int):void{<!-- --><br>   var attRoundArr:Array;<br>   var attRound:AttBox;<br>   for each ( var roundment:XML in _arms["Arms" + armIndex]["RangeAttack"].elements( ) ) {<!-- --><br>    attRound = new AttBox();<br>    attRoundArr = roundment.toString().split(",");<br>    attRound.x = (int(attRoundArr[0]) + _nowChatacter.locationX )*48;<br>    attRound.y = (int(attRoundArr[1]) + _nowChatacter.locationY) *48;<br>    _roadSprite.addChild(attRound);<br>   }<br>   <br>  }<br>  //鼠标点击事件<br>  private function onClick(event:Event):void{<!-- --><br>   var __mouseX:Number = event.currentTarget.mouseX;<br>   var __mouseY:Number = event.currentTarget.mouseY;<br>   var i:int;<br>   if(_clickCtrl == "NULL"){<!-- --><br>    var queryPeople:Boolean = false;<br>    //点击我军人物判断<br>    for(i=0;i&lt;_ourArr.length;i++){<!-- --><br>     _character = _ourArr[i] as Character;<br>     _characterMC = _character.character;<br>     if(Math.floor(_characterMC.x/48) == Math.floor(__mouseX/48) &amp;&amp; Math.floor(_characterMC.y/48) == Math.floor(__mouseY/48)){<!-- --><br>      _nowChatacter = _character;<br>      setRoad(_nowChatacter);<br>      _clickCtrl = "ROAD_SHOW";<br>      _bakSprite.removeEventListener(MouseEvent.CLICK,onClick);<br>      _roadSprite.addEventListener(MouseEvent.CLICK,onClick);<br>      queryPeople = true;<br>      break;<br>     }<br>    }<br>    //点击敌军人物判断<br>    for(i=0;i&lt;_enemyArr.length &amp;&amp; !queryPeople;i++){<!-- --><br>     _character = _enemyArr[i] as Character;<br>     _characterMC = _character.character;<br>     if(Math.floor(_characterMC.x/48) == Math.floor(__mouseX/48) &amp;&amp; Math.floor(_characterMC.y/48) == Math.floor(__mouseY/48)){<!-- --><br>      _nowChatacter = _character;<br>      setRoad(_nowChatacter);<br>      _clickCtrl = "ENEMY_ROUND_SHOW";<br>      _bakSprite.removeEventListener(MouseEvent.CLICK,onClick);<br>      queryPeople = true;<br>      break;<br>     }<br>    }<br>    if(!queryPeople){<!-- --><br>     //点击地图，显示地形<br>     _clickCtrl = "TERRAIN_SHOW";<br>     var mapX:int = Math.floor(__mouseX/48);<br>     var mapY:int = Math.floor(__mouseY/48);<br>     var terrainId:int = _mapData[mapY][mapX];<br>     var terrainName:String = "Terrain" + terrainId;<br>     _terrainBox.x = mapX *48 - 48 + _bakSprite.x;<br>     _terrainBox.y = mapY*48 - 48 + _bakSprite.y;<br>     if(_terrainBox.x &lt; 0){<!-- --><br>      _terrainBox.x = 0;<br>     }else if(_terrainBox.x &gt; Sav.gamedata["stageWidth"] - 144){<!-- --><br>      _terrainBox.x = Sav.gamedata["stageWidth"] - 144;<br>     }<br>     if(_terrainBox.y &lt; 0){<!-- --><br>      _terrainBox.y = 0;<br>     }else if(_terrainBox.y &gt; Sav.gamedata["stageHeight"] - 144){<!-- --><br>      _terrainBox.y = Sav.gamedata["stageHeight"] - 144;<br>     }<br>     _terrainBox.TerrainName.text = _terrain[terrainName];<br>     SpriteRemove.removeAllChildren(_terrainBox.TerrainShow);<br>     _terrainBox.TerrainShow.addChild(ImageCtrl.getImage(_bmapimage,mapX*48,mapY*48,48,48));<br>     _bakSprite.removeEventListener(MouseEvent.CLICK,onClick);<br>     _terrainBox.visible = true;<br>    }<br>   }else if(_clickCtrl == "ROAD_SHOW"){<!-- --><br>    _characterMC = _nowChatacter.character;<br>    for(i=0;i&lt;_roadShowArray.length;i++){<!-- --><br>      _nowPoint = new Point(_nowChatacter.locationX,_nowChatacter.locationY);<br>      _nowDirection = _characterMC.getDir();<br>      _toPoint = new Point(Math.floor(__mouseX/48),Math.floor(__mouseY/48));<br>      charaToMove();<br>    }<br>   }<br>   <br>   <br>  }<br>  //当前人物开始移动<br>  private function charaToMove():void{<!-- --><br>   _roadArray = _roadQuery.path4(_nowPoint,_toPoint,_roadShowArray);<br>   if(_roadArray != null &amp;&amp; _roadArray.length &gt; 0){<!-- --><br>    addEventListener(Event.ENTER_FRAME, onFrame);<br>    _clickCtrl == "MOVE_NOW"<br>    SpriteRemove.removeAllChildren(_roadSprite);<br>    if(_roundCtrl == "我方回合"){<!-- --><br>     _roadSprite.removeEventListener(MouseEvent.CLICK,onClick);<br>    }<br>   }<br>  }<br>  //人物移动事件贞控制<br>  private function onFrame(event:Event):void {<!-- --><br>   _characterMC = _nowChatacter.character;<br>   if(_roadArray != null &amp;&amp; _roadArray.length &gt; 1){<!-- --><br>    if(_characterMC.x % 48 == 0 &amp;&amp; _characterMC.y % 48 == 0){<!-- --><br>      if(_roadArray[0].x == _roadArray[1].x){<!-- --><br>      if(_roadArray[0].y &gt; _roadArray[1].y){<!-- --><br>       _characterMC.setDir(0);<br>       _xadd = 0;<br>       _yadd = -_addLeng;<br>      }else{<!-- --><br>       _characterMC.setDir(1);<br>       _xadd = 0;<br>       _yadd = _addLeng;<br>      }<br>     }else{<!-- --><br>      if(_roadArray[0].x &gt; _roadArray[1].x){<!-- --><br>       _characterMC.setDir(2);<br>       _xadd = -_addLeng;<br>       _yadd = 0;<br>      }else{<!-- --><br>       _characterMC.setDir(3);<br>       _xadd = _addLeng;<br>       _yadd = 0;<br>      }<br>     }     </p> 
<p>     _roadArray.splice(0,1);<br>                                        <br>    }<br>    _characterMC.x += _xadd;<br>    _characterMC.y += _yadd;<br>                                <br>   }else if(_characterMC.x % 48 == 0 &amp;&amp; _characterMC.y % 48 == 0){<!-- --><br>    removeEventListener(Event.ENTER_FRAME, onFrame);<br>    if(_roundCtrl == "我方回合"){<!-- --><br>     _selectBox.visible = true;<br>     _selectBox.x = _characterMC.x + 48;<br>     _selectBox.y = _characterMC.y;<br>    }else if(_roundCtrl == "敌方回合"){<!-- --><br>     _nowChatacter.actionCtrl = true;<br>     _enemyActionCtrl = 0;<br>     _clickCtrl = "NULL";<br>     addEventListener(Event.ENTER_FRAME, onEnemyFrame);<br>    }<br>   }else{<!-- --><br>   <br>    _characterMC.x += _xadd;<br>    _characterMC.y += _yadd;<br>   }<br>  }</p> 
<p>  //得到战场xml信息<br>  private function initStage(xml:XML):void{<!-- --><br>   _fightXml = xml;<br>   _mapData= new Array();<br>   //根据xml内容，得到地形数组<br>   for each ( var datement:XML in _fightXml.DataMap.elements( ) ) {<!-- --><br>    var dates:Array = ("" + datement).split( ",");<br>    _mapData.push(dates);<br>   }<br>   _roadQuery = new RoadQuery(this);<br>   <br>   //我军人物添加<br>   _ourArr = new Array();<br>   //根据xml内容，得到我军人物,添加至战场<br>   for each ( var ourment:XML in _fightXml.Our.elements( ) ) {<!-- --><br>    var ourId:int = int(ourment);<br>    var ourchara:XML = XML(_pXml["peo" + ourId]);<br>    _characterMC = new CharacterMC(ourId);<br>    _characterMC.x = int(<a href="mailto:ourment.@x%29*48" rel="nofollow">ourment.@x)*48</a>;<br>    _characterMC.y = int(<a href="mailto:ourment.@y%29*48" rel="nofollow">ourment.@y)*48</a>;<br>    _character = new Character(_characterMC,int(ourchara.Move),int(ourchara.sImage),int(ourchara.Arms));<br>    _characterSprite.addChild(_characterMC);<br>    _ourArr.push(_character);<br>   }<br>   //敌军人物添加<br>   _enemyArr = new Array();<br>   //根据xml内容，得到敌军人物,添加至战场<br>   for each ( var enemyment:XML in _fightXml.Enemy.elements( ) ) {<!-- --><br>    var enemyId:int = int(enemyment);<br>    var enemychara:XML = XML(_pXml["peo" + enemyId]);<br>    _characterMC = new CharacterMC(enemyId);<br>    _characterMC.x = int(<a href="mailto:enemyment.@x%29*48" rel="nofollow">enemyment.@x)*48</a>;<br>    _characterMC.y = int(<a href="mailto:enemyment.@y%29*48" rel="nofollow">enemyment.@y)*48</a>;<br>    _character = new Character(_characterMC,int(enemychara.Move),int(enemychara.sImage),int(enemychara.Arms));<br>    _characterSprite.addChild(_characterMC);<br>    _enemyArr.push(_character);<br>   }<br>   //加载地图<br>   _pic_loader = new Loader();<br>   _pic_loader.contentLoaderInfo.addEventListener(Event.COMPLETE, onCompleteMap);<br>   var mapName:String = "Images/HM/" + _fightXml.Map + ".gif";<br>   _pic_loader.load(new URLRequest(mapName));<br>  }<br>  //加载地图完毕<br>  private function onCompleteMap(event:Event):void {<!-- --><br>   _pic_loader.contentLoaderInfo.removeEventListener(Event.COMPLETE, onCompleteMap);<br>   _bmapimage = Bitmap(_pic_loader.content);<br>   _mapSprite.addChild(_bmapimage);<br>   <br>  }<br>  public function get map():Array{<!-- --><br>   return _mapData;<br>  }<br>  public function get roundCtrl():String{<!-- --><br>   return _roundCtrl;<br>  }<br>  public function get enemyArr():Array{<!-- --><br>   return _enemyArr;<br>  }<br>  public function get ourArr():Array{<!-- --><br>   return _ourArr;<br>  }<br>  <br> }<br>}</p> 
<p>效果如下图<br><img src="https://images2.imgbox.com/35/12/M02vmCAb_o.jpg" alt="预览" width="979" height="638"></p> 
<p><img src="https://images2.imgbox.com/9b/49/o2DddIWi_o.jpg" alt="预览" width="979" height="638"></p> 
<p><img src="https://images2.imgbox.com/ec/d1/lf6S6oj0_o.jpg" alt="预览" width="979" height="638"></p> 
<p>暂时，敌军只会跟随我军某个人物移动，等下面再慢慢研究敌方的AI<br>下次，在战场上显示人物的攻击防御等属性:)</p> 
<p>要显示人物属性了，把相应的人物数据和兵种数据改好，如下&lt;?xml version="1.0" encoding="GB2312"?&gt;<br>&lt;data&gt;<br>    &lt;peo1&gt;<br> &lt;Name&gt;曹操&lt;/Name&gt;<br> &lt;Arms&gt;1&lt;/Arms&gt;<br> &lt;Lv&gt;1&lt;/Lv&gt;<br> &lt;Exp&gt;0&lt;/Exp&gt;<br> &lt;HP&gt;124&lt;/HP&gt;<br> &lt;MP&gt;85&lt;/MP&gt;<br> &lt;Move&gt;5&lt;/Move&gt;<br> &lt;Face&gt;1&lt;/Face&gt;<br> &lt;sImage&gt;1&lt;/sImage&gt;<br> &lt;Force&gt;80&lt;/Force&gt;<br> &lt;Intelligence&gt;96&lt;/Intelligence&gt;<br> &lt;Command&gt;98&lt;/Command&gt;<br> &lt;Agile&gt;83&lt;/Agile&gt;<br> &lt;Luck&gt;88&lt;/Luck&gt;<br> &lt;Attack&gt;82&lt;/Attack&gt;<br> &lt;Spirit&gt;92&lt;/Spirit&gt;<br> &lt;Defense&gt;80&lt;/Defense&gt;<br> &lt;Breakout&gt;85&lt;/Breakout&gt;<br> &lt;Morale&gt;80&lt;/Morale&gt;<br> &lt;Introduction&gt;&lt;/Introduction&gt;<br>    &lt;/peo1&gt;<br>......<br>&lt;?xml version="1.0" encoding="GB2312"?&gt;<br>&lt;data&gt;<br>    &lt;Arms1&gt;<br> &lt;Name&gt;英雄&lt;/Name&gt;<br> &lt;Property&gt;<br>     &lt;Attack&gt;A&lt;/Attack&gt;<br>     &lt;Spirit&gt;A&lt;/Spirit&gt;<br>     &lt;Defense&gt;A&lt;/Defense&gt;<br>     &lt;Breakout&gt;A&lt;/Breakout&gt;<br>     &lt;Morale&gt;A&lt;/Morale&gt;<br> &lt;/Property&gt;<br> &lt;Weapon&gt;剑&lt;/Weapon&gt;<br> &lt;Equipment&gt;铠甲&lt;/Equipment&gt;<br> &lt;Terrain&gt;<br>     &lt;Terrain0&gt;1&lt;/Terrain0&gt;<br>     &lt;Terrain1&gt;1&lt;/Terrain1&gt;<br>     &lt;Terrain2&gt;2&lt;/Terrain2&gt;<br>     &lt;Terrain3&gt;100&lt;/Terrain3&gt;<br>     &lt;Terrain4&gt;100&lt;/Terrain4&gt;<br>     &lt;Terrain5&gt;1&lt;/Terrain5&gt;<br>     &lt;Terrain6&gt;1&lt;/Terrain6&gt;<br>     &lt;Terrain7&gt;1&lt;/Terrain7&gt;<br> &lt;/Terrain&gt;<br> &lt;RangeAttack&gt;<br>     &lt;List&gt;0,-1&lt;/List&gt;<br>     &lt;List&gt;0,1&lt;/List&gt;<br>     &lt;List&gt;-1,0&lt;/List&gt;<br>     &lt;List&gt;1,0&lt;/List&gt;<br> &lt;/RangeAttack&gt;<br> &lt;Introduction&gt;&lt;/Introduction&gt;<br>    &lt;/Arms1&gt;<br>......<br>在data.xml中设定升级所需EXP和能力上限值<br>&lt;?xml version="1.0" encoding="GB2312"?&gt;<br>&lt;data&gt;<br> &lt;varlable&gt;255&lt;/varlable&gt;<br> &lt;MaxExp&gt;100&lt;/MaxExp&gt;<br> &lt;MaxAbility&gt;1000&lt;/MaxAbility&gt;<br>&lt;/data&gt;<br>然后，就像.net编辑From一样，开始准备所需要的MC<br><img src="https://images2.imgbox.com/84/a9/5FfdN7cv_o.gif" alt="素材" width="150" height="48"></p> 
<p><img src="https://images2.imgbox.com/1d/3b/yhcB1B21_o.gif" alt="素材" width="305" height="405"></p> 
<p>在读取完data.xml时，把需要的升级所需EXP和能力上限值保存，方便随时取用<br>   Sav.gamedata["MaxAbility"] = xml.MaxAbility;<br>   Sav.gamedata["MaxExp"] = xml.MaxExp;<br>战场上，把整个战场向下移动48个像素，用来仿照曹操传放置按钮，<br>在曹操传中，左击鼠标用来察看人物属性，但是flash中是没有办法弄成这样的，至少现在不能，因为flash左击鼠标，会弹出flash菜单<br>所以，我在最上面的菜单上，放置了两个按钮，用来察看我军和敌军属性，按钮用了普通的士兵S形象，点击我军或者敌军的S形象按钮就能察看我军和敌军的属性了<br>   //查看武将-我军按钮<br>   _ourShow = new PeopleShow();<br>   _ourShow.x = 500;<br>   addChild(_ourShow);<br>   _ourShow.addEventListener(MouseEvent.CLICK, ourShowHandler); <br>   //查看武将-敌军按钮<br>   _enemyShow = new PeopleShowEnemy();<br>   _enemyShow.x = 548;<br>   addChild(_enemyShow);<br>   _enemyShow.addEventListener(MouseEvent.CLICK, enemyShowHandler); </p> 
<p>然后添加现实HP，MP和人物属性的MC<br>   _hpmp = new HPMP();<br>   _bakSprite.addChild(_hpmp);<br>   _hpmp.visible = false;<br>这个HPMP，是用来显示当前的HP和MP的MC，就是上面一开始准备的第一个图<br>   //查看武将MC<br>   _peopleShow = new CharacterProperty();<br>   _peopleShow.x = (Sav.gamedata["stageWidth"] - _peopleShow.width)/2;<br>   _peopleShow.y = (Sav.gamedata["stageHeight"] - _peopleShow.height)/2;<br>   this.addChild(_peopleShow);<br>   _peopleShow.btnGenerals.visible = false;<br>   _peopleShow.visible = false;<br>这个CharacterProperty就是准备好的显示人物属性的MC,就是上面的第二个图</p> 
<p><br>当鼠标移动到我军或敌军身上时，就显示其HP和MP</p> 
<p>  //鼠标移动事件<br>  private function mouseBakMoveHandler(event:MouseEvent):void{<!-- --><br>   var intX:int = event.currentTarget.mouseX;<br>   var intY:int = event.currentTarget.mouseY;<br>   _mouseBox.x = Math.floor(intX/48)*48;<br>   _mouseBox.y = Math.floor(intY/48)*48;<br>   var queryPeople:Boolean = false;<br>   var i:int;<br>   for(i=0;i&lt;_ourArr.length;i++){<!-- --><br>    _character = _ourArr[i] as Character;<br>    if(_character.x == _mouseBox.x &amp;&amp; _character.y == _mouseBox.y){<!-- --><br>     _nowChatacter = _character;<br>     queryPeople = true;<br>     break;<br>    }<br>   }<br>   <br>   for(i=0;i&lt;_enemyArr.length &amp;&amp; !queryPeople;i++){<!-- --><br>    _character = _enemyArr[i] as Character;<br>    if(_character.x == _mouseBox.x &amp;&amp; _character.y == _mouseBox.y){<!-- --><br>     _nowChatacter = _character;<br>     queryPeople = true;<br>     break;<br>    }<br>   }<br>   if(!queryPeople){<!-- --><br>    _hpmp.visible = false;<br>   }else{<!-- --><br>     _hpmp.visible = true;<br>     _hpmp.x = _mouseBox.x  - 102;<br>     _hpmp.y = _mouseBox.y - 48;<br>     if(_hpmp.x &lt; 0){<!-- --><br>      _hpmp.x = 0;<br>     }<br>     if(_hpmp.y &lt; 0){<!-- --><br>      _hpmp.y = 0;<br>     }<br>    _hpmp.txtHP.text = _nowChatacter.nowHP + "/" + _nowChatacter.HP;<br>    _hpmp.spHP.width = 100 * (_nowChatacter.nowHP/_nowChatacter.HP);<br>    _hpmp.txtMP.text = _nowChatacter.nowMP + "/" + _nowChatacter.MP;<br>    _hpmp.spMP.width = 100 * (_nowChatacter.nowMP/_nowChatacter.MP);<br>   }<br>  }</p> 
<p> </p> 
<p>添加好点击事件，显示人物属性时，实现相应的切换</p> 
<p>   _peopleShow.visible = false;<br>   //添加各个按钮点击事件<br>   _peopleShow.btnGenerals.addEventListener(MouseEvent.CLICK, onClickGenerals); <br>   _peopleShow.btnForce.addEventListener(MouseEvent.CLICK, onClickForce); <br>   _peopleShow.btnAbility.addEventListener(MouseEvent.CLICK, onClickAbility); <br>   _peopleShow.btnEquipment.addEventListener(MouseEvent.CLICK, onClickEquipment); <br>   _peopleShow.btnTactics.addEventListener(MouseEvent.CLICK, onClickTactics); <br>   _peopleShow.btnClose.addEventListener(MouseEvent.CLICK, onClickClose); <br>   _peopleShow.btnLast.addEventListener(MouseEvent.CLICK, onClickLast); <br>   _peopleShow.btnNext.addEventListener(MouseEvent.CLICK, onClickNext); </p> 
<p><br>  //察看武将-按钮全部显示<br>  private function _peopleBtnToTrue(){<!-- --><br>   _peopleShow.btnGenerals.visible = true;<br>   _peopleShow.btnForce.visible = true;<br>   _peopleShow.btnAbility.visible = true;<br>   _peopleShow.btnEquipment.visible = true;<br>   _peopleShow.btnTactics.visible = true;<br>  <br>  }<br>  //察看武将-点击上一武将<br>  private function onClickLast(event:MouseEvent):void{<!-- --><br>   peopleShowFromIndex(-1);<br>  }<br>  //察看武将-点击下一武将<br>  private function onClickNext(event:MouseEvent):void{<!-- --><br>   peopleShowFromIndex(1);<br>  }<br>  //察看武将-点击关闭<br>  private function onClickClose(event:MouseEvent):void{<!-- --><br>   if(_peopleShow.btnGenerals.visible){<!-- --><br>    _peopleShow.gotoAndStop(1);<br>   }<br>   _peopleShow.visible = false;<br>  }<br>  //察看武将-点击武将列传<br>  private function onClickGenerals(event:MouseEvent):void{<!-- --><br>   _peopleShow.gotoAndStop(1);<br>   _peopleBtnToTrue();<br>   _peopleShow.btnGenerals.visible = false;<br>   setGenerals();<br>  }<br>  //察看武将-点击部队属性<br>  private function onClickForce(event:MouseEvent):void{<!-- --><br>   _peopleShow.gotoAndStop(2);<br>   _peopleBtnToTrue();<br>   _peopleShow.btnForce.visible = false;<br>   setForce();<br>  }<br>  //察看武将-点击能力<br>  private function onClickAbility(event:MouseEvent):void{<!-- --><br>   _peopleShow.gotoAndStop(3);<br>   _peopleBtnToTrue();<br>   _peopleShow.btnAbility.visible = false;<br>   setAbility();<br>  }<br>  //察看武将-点击装备<br>  private function onClickEquipment(event:MouseEvent):void{<!-- --><br>   _peopleShow.gotoAndStop(4);<br>   _peopleBtnToTrue();<br>   _peopleShow.btnEquipment.visible = false;<br>   setEquipment();<br>  }<br>  //察看武将-点击策略<br>  private function onClickTactics(event:MouseEvent):void{<!-- --><br>   _peopleShow.gotoAndStop(5);<br>   _peopleBtnToTrue();<br>   _peopleShow.btnTactics.visible = false;<br>   setTactics();<br>  }</p> 
<p><br>  //察看我军<br>  private function ourShowHandler(event:MouseEvent):void{<!-- --><br>   _peopleShowIndex= 0;<br>   _peopleShowCtrl = "Our";<br>   peopleShowFromIndex(0);<br>  }<br>  //察看敌军<br>  private function enemyShowHandler(event:MouseEvent):void{<!-- --><br>   _peopleShowIndex = 0;<br>   _peopleShowCtrl = "Enemy";<br>   peopleShowFromIndex(0);<br>  }<br>  //根据人物序号显示人物属性<br>  private function peopleShowFromIndex(addIndex:int):void{<!-- --><br>   _peopleShowIndex += addIndex;<br>   if(_peopleShowCtrl == "Our"){<!-- --><br>    if(_peopleShowIndex &lt; 0){<!-- --><br>     _peopleShowIndex = _ourArr.length - 1;<br>    }else if(_peopleShowIndex &gt;= _ourArr.length){<!-- --><br>     _peopleShowIndex = 0;<br>    }<br>    _nowChatacter = _ourArr[_peopleShowIndex] as Character;<br>   _peopleShow.txtForceShow.text = "我军";<br>   }else if(_peopleShowCtrl == "Enemy"){<!-- --><br>    if(_peopleShowIndex &lt; 0){<!-- --><br>     _peopleShowIndex = _enemyArr.length - 1;<br>    }else if(_peopleShowIndex &gt;= _enemyArr.length){<!-- --><br>     _peopleShowIndex = 0;<br>    }<br>    _nowChatacter = _enemyArr[_peopleShowIndex] as Character;<br>    _peopleShow.txtForceShow.text = "敌军";<br>   }<br>   _peopleShow.txtName.text = _pXml["peo" + _nowChatacter.charaIndex].Name.toString();<br>   _peopleShow.txtArms.text = _pXml["peo" + _nowChatacter.charaIndex].Arms.toString();<br>   _peopleShow.txtLv.text = _pXml["peo" + _nowChatacter.charaIndex].Lv.toString();<br>   _peopleShow.txtExp.text = _pXml["peo" + _nowChatacter.charaIndex].Exp + "/" + Sav.gamedata["MaxExp"];<br>   _peopleShow.spExp.width = 50 * (int(_pXml["peo" + _nowChatacter.charaIndex].Exp)/int(Sav.gamedata["MaxExp"]));<br>   _peopleShow.txtHP.text = _nowChatacter.nowHP + "/" + _nowChatacter.HP;<br>   _peopleShow.spHP.width = 100 * (_nowChatacter.nowHP/_nowChatacter.HP);<br>   _peopleShow.txtMP.text = _nowChatacter.nowMP + "/" + _nowChatacter.MP;<br>   _peopleShow.spMP.width = 100 * (_nowChatacter.nowMP/_nowChatacter.MP);<br>   _peopleShow.txtStatus.text = _nowChatacter.getfStatus();<br>   for(var i:int = 0;i&lt;_nowChatacter.statusArr.length;i++){<!-- --><br>    _peopleShow.txtStatus.appendText(_nowChatacter.statusArr[0] + " ");<br>   }<br>   <br>   //加载人物头像<br>   var faceStr:String = "Images/Face/" + _pXml["peo" + _nowChatacter.charaIndex].Face.toString().split(",")[0] + ".gif";<br>   _pic_loader = new Loader();<br>   _pic_loader.contentLoaderInfo.addEventListener(Event.COMPLETE, onCompleteFace);<br>   _pic_loader.load(new URLRequest(faceStr));<br>   if(!_peopleShow.btnGenerals.visible){<!-- --><br>    setGenerals();<br>   }else if(!_peopleShow.btnForce.visible){<!-- --><br>    setForce();<br>   }else if(!_peopleShow.btnAbility.visible){<!-- --><br>    setAbility();<br>   }else if(!_peopleShow.btnEquipment.visible){<!-- --><br>    setEquipment();<br>   }else if(!_peopleShow.btnTactics.visible){<!-- --><br>    setTactics();<br>   }<br>  }<br>  //加载人物头像完毕<br>  private function onCompleteFace(event:Event):void {<!-- --><br>   _pic_loader.contentLoaderInfo.removeEventListener(Event.COMPLETE, onCompleteFace);<br>   _image = Bitmap(_pic_loader.content);<br>   SpriteRemove.removeAllChildren(_peopleShow.faceImage);<br>   _peopleShow.faceImage.addChild(_image);<br>   _peopleShow.visible = true;<br>  }<br>  //察看武将-显示武将列传<br>  private function setGenerals():void{<!-- --><br>   _peopleShow.txtForce.text = _pXml["peo" + _nowChatacter.charaIndex].Force.toString();<br>   _peopleShow.txtIntelligence.text = _pXml["peo" + _nowChatacter.charaIndex].Intelligence.toString();<br>   _peopleShow.txtCommand.text = _pXml["peo" + _nowChatacter.charaIndex].Command.toString();<br>   _peopleShow.txtAgile.text = _pXml["peo" + _nowChatacter.charaIndex].Agile.toString();<br>   _peopleShow.txtLuck.text = _pXml["peo" + _nowChatacter.charaIndex].Luck.toString();<br>   _peopleShow.txtIntroduction.text = _pXml["peo" + _nowChatacter.charaIndex].Introduction.toString();<br>  }<br>  //察看武将-显示部队属性<br>  private function setForce():void{<!-- --><br>   _peopleShow.txtAttack.text = _arms["Arms" + _nowChatacter.armsIndex].Property.Attack.toString();<br>   _peopleShow.txtSpirit.text = _arms["Arms" + _nowChatacter.armsIndex].Property.Spirit.toString();<br>   _peopleShow.txtDefense.text = _arms["Arms" + _nowChatacter.armsIndex].Property.Defense.toString();<br>   _peopleShow.txtBreakout.text = _arms["Arms" + _nowChatacter.armsIndex].Property.Breakout.toString();<br>   _peopleShow.txtMorale.text = _arms["Arms" + _nowChatacter.armsIndex].Property.Morale.toString();<br>   _peopleShow.txtArmsPro.text = _arms["Arms" + _nowChatacter.armsIndex].Introduction.toString();<br>   _peopleShow.txtArms2.text = _pXml["peo" + _nowChatacter.charaIndex].Arms.toString();<br>   _peopleShow.txtWeapon.text = _arms["Arms" + _nowChatacter.armsIndex].Weapon.toString();<br>   _peopleShow.txtEquipment.text = _arms["Arms" + _nowChatacter.armsIndex].Equipment.toString();<br>   SpriteRemove.removeAllChildren(_peopleShow.armsImage);<br>   _peopleShow.armsImage.addChild(new Bitmap(_nowChatacter.character.getBitmapData()));<br>  }<br>  //察看武将-显示能力<br>  private function setAbility():void{<!-- --><br>   _peopleShow.txtAttack1.text = _pXml["peo" + _nowChatacter.charaIndex].Attack.toString();<br>   _peopleShow.txtSpirit1.text = _pXml["peo" + _nowChatacter.charaIndex].Spirit.toString();<br>   _peopleShow.txtDefense1.text = _pXml["peo" + _nowChatacter.charaIndex].Defense.toString();<br>   _peopleShow.txtBreakout1.text = _pXml["peo" + _nowChatacter.charaIndex].Breakout.toString();<br>   _peopleShow.txtMorale1.text = _pXml["peo" + _nowChatacter.charaIndex].Morale.toString();<br>   _peopleShow.spAttack1.width = 100 * int(_pXml["peo" + _nowChatacter.charaIndex].Attack) / int(Sav.gamedata["MaxAbility"]);<br>   _peopleShow.spSpirit1.width = 100 * int(_pXml["peo" + _nowChatacter.charaIndex].Spirit) / int(Sav.gamedata["MaxAbility"]);<br>   _peopleShow.spDefense1.width = 100 * int(_pXml["peo" + _nowChatacter.charaIndex].Defense) / int(Sav.gamedata["MaxAbility"]);<br>   _peopleShow.spBreakout1.width = 100 * int(_pXml["peo" + _nowChatacter.charaIndex].Breakout) / int(Sav.gamedata["MaxAbility"]);<br>   _peopleShow.spMorale1.width = 100 * int(_pXml["peo" + _nowChatacter.charaIndex].Morale) / int(Sav.gamedata["MaxAbility"]);<br>  }<br>  //察看武将-显示装备<br>  private function setEquipment():void{}<br>  //察看武将-显示策略<br>  private function setTactics():void{}</p> 
<p>就是这样了，然后，运行一下flash，可以看到下面的图<br><img src="https://images2.imgbox.com/a9/15/3D1f9McK_o.gif" alt="预览" width="972" height="634"></p> 
<p><img src="https://images2.imgbox.com/7d/5b/UvEOrfLc_o.gif" alt="预览" width="972" height="634"></p> 
<p>该研究攻击了，这个比较复杂，先来看，我军方面的攻击<br>当然，首先要把攻击动作等补全<br>CharacterMC中，把攻击图片和被攻击图片等全部载入<br>  //Unit_mov图片加载完成<br>  public function onCompleteUnit_mov(event:Event):void {<!-- --><br>   _image = Bitmap(_loader.content);<br>   //初始化显示数组<br>   _bitShowArr = new Array();<br>   //将位图数据拆分成小块，装入bitmapArr<br>   _bitmapArr=ImageCtrl.divide(_image,1,11);<br>   var newArr:Array;<br>   //得到向上行走数组<br>   newArr = new Array(_bitmapArr[2][0],_bitmapArr[3][0]);<br>   //将向上行走数组加入到显示数组 编号:0<br>   _bitShowArr.push(newArr);<br>   //得到向下行走数组<br>   newArr = new Array(_bitmapArr[0][0],_bitmapArr[1][0]);<br>   //将向下行走数组加入到显示数组 编号:1<br>   _bitShowArr.push(newArr);<br>   //得到向左行走数组<br>   newArr = new Array(_bitmapArr[4][0],_bitmapArr[5][0]);<br>   //将向左行走数组加入到显示数组 编号:2<br>   _bitShowArr.push(newArr);<br>   //得到向右行走数组<br>   newArr = new Array(ImageCtrl.bitHorizontal(_bitmapArr[4][0]),ImageCtrl.bitHorizontal(_bitmapArr[5][0]));<br>   //将向右行走数组加入到显示数组 编号:3<br>   _bitShowArr.push(newArr);<br>   //得到向上站立数组<br>   newArr = new Array(_bitmapArr[7][0]);<br>   //将向上站立数组加入到显示数组 编号:4<br>   _bitShowArr.push(newArr);<br>   //得到向下站立数组<br>   newArr = new Array(_bitmapArr[6][0]);<br>   //将向下站立数组加入到显示数组 编号:5<br>   _bitShowArr.push(newArr);<br>   //得到向左站立数组<br>   newArr = new Array(_bitmapArr[8][0]);<br>   //将向左站立数组加入到显示数组 编号:6<br>   _bitShowArr.push(newArr);<br>   //得到向右站立数组<br>   newArr = new Array(ImageCtrl.bitHorizontal(_bitmapArr[8][0]));<br>   //将向右站立数组加入到显示数组 编号:7<br>   _bitShowArr.push(newArr);<br>   //得到喘气数组<br>   newArr = new Array(_bitmapArr[9][0],_bitmapArr[10][0]);<br>   //将喘气数组加入到显示数组 编号:8<br>   _bitShowArr.push(newArr);<br>   <br>             //Unit_atk图片加载;           <br>     _loader = new Loader();  <br>   _loader.contentLoaderInfo.addEventListener(Event.COMPLETE, onCompleteUnit_atk);<br>   var atkName:String = "Images/Unit_atk/" + _imageIndex + ".gif";<br>   _loader.load(new URLRequest(atkName));<br>  }<br>  //Unit_atk图片加载完成<br>  public function onCompleteUnit_atk(event:Event):void {<!-- --><br>   _image = Bitmap(_loader.content);<br>   //将位图数据拆分成小块，装入bitmapArr<br>   _bitmapArr=ImageCtrl.divide(_image,1,12);<br>   var newArr:Array;<br>   //得到向上攻击数组<br>   newArr = new Array(_bitmapArr[4][0],_bitmapArr[5][0],_bitmapArr[6][0],_bitmapArr[7][0]);<br>   //将向上攻击数组加入到显示数组 编号:9<br>   _bitShowArr.push(newArr);<br>   //得到向下攻击数组<br>   newArr = new Array(_bitmapArr[0][0],_bitmapArr[1][0],_bitmapArr[2][0],_bitmapArr[3][0]);<br>   //将向下攻击数组加入到显示数组 编号:10<br>   _bitShowArr.push(newArr);<br>   //得到向左攻击数组<br>   newArr = new Array(_bitmapArr[8][0],_bitmapArr[9][0],_bitmapArr[10][0],_bitmapArr[11][0]);<br>   //将向左攻击数组加入到显示数组 编号:11<br>   _bitShowArr.push(newArr);<br>   //得到向右攻击数组<br>   newArr = new Array(ImageCtrl.bitHorizontal(_bitmapArr[8][0]),ImageCtrl.bitHorizontal(_bitmapArr[9][0]),ImageCtrl.bitHorizontal(_bitmapArr[10][0]),ImageCtrl.bitHorizontal(_bitmapArr[11][0]));<br>   //将向右攻击数组加入到显示数组 编号:12<br>   _bitShowArr.push(newArr);<br>   <br>             //Unit_spc图片加载;           <br>     _loader = new Loader();  <br>   _loader.contentLoaderInfo.addEventListener(Event.COMPLETE, onCompleteUnit_spc);<br>   var spcName:String = "Images/Unit_spc/" + _imageIndex + ".gif";<br>   _loader.load(new URLRequest(spcName));<br>  }<br>  //Unit_spc图片加载完成<br>  public function onCompleteUnit_spc(event:Event):void {<!-- --><br>   _image = Bitmap(_loader.content);<br>   //将位图数据拆分成小块，装入bitmapArr<br>   _bitmapArr=ImageCtrl.divide(_image,1,5);<br>   var newArr:Array;<br>   //得到向上挡格数组<br>   newArr = new Array(_bitmapArr[1][0]);<br>   //将向上挡格数组加入到显示数组 编号:13<br>   _bitShowArr.push(newArr);<br>   //得到向下挡格数组<br>   newArr = new Array(_bitmapArr[0][0]);<br>   //将向下挡格数组加入到显示数组 编号:14<br>   _bitShowArr.push(newArr);<br>   //得到向左挡格数组<br>   newArr = new Array(_bitmapArr[2][0]);<br>   //将向左挡格数组加入到显示数组 编号:15<br>   _bitShowArr.push(newArr);<br>   //得到向右挡格数组<br>   newArr = new Array(ImageCtrl.bitHorizontal(_bitmapArr[2][0]));<br>   //将向右挡格数组加入到显示数组 编号:16<br>   _bitShowArr.push(newArr);<br>   //得到受攻击数组<br>   newArr = new Array(_bitmapArr[3][0]);<br>   //将受攻击数组加入到显示数组 编号:17<br>   _bitShowArr.push(newArr);<br>   //得到升级数组<br>   newArr = new Array(_bitmapArr[4][0]);<br>   //将升级数组加入到显示数组 编号:18<br>   _bitShowArr.push(newArr);<br>   <br>   startFrame();<br>  }</p> 
<p>CharacterIndex中，把相应的动作代号补全，以方便使用<br>package Caocao.Character {<!-- --><br> public class CharacterIndex {<!-- --><br>  public static const UP:int = 0;<br>  public static const DOWN:int = 1;<br>  public static const LEFT:int = 2;<br>  public static const RIGHT:int = 3;<br>  public static const UP_STOP:int = 4;<br>  public static const DOWN_STOP:int = 5;<br>  public static const LEFT_STOP:int = 6;<br>  public static const RIGHT_STOP:int = 7;<br>  public static const PANT:int = 8;<br>  public static const ATTACK_UP:int = 9;<br>  public static const ATTACK_DWON:int = 10;<br>  public static const ATTACK_LEFT:int = 11;<br>  public static const ATTACK_RIGHT:int = 12;<br>  public static const WARD_UP:int = 13;<br>  public static const WARD_DWON:int = 14;<br>  public static const WARD_LEFT:int = 15;<br>  public static const WARD_RIGHT:int = 16;<br>  public static const TAKE_A_BEAT:int = 17;<br>  public static const UPGRADE:int = 18;<br>  public function CharacterIndex() { }<br> }<br>}<br>然后，继续在人物动作类CharacterMC中加入一个被攻击人员和一个可以随时改变值的自定义函数<br>  //对手<br>  public var _rival:Character;<br>  private var _rivalMC:CharacterMC;<br>  //执行函数<br>  public var _fun:Function;</p> 
<p>然后，在战场类FightMap中把战斗按钮上加上点击事件<br>   //点击攻击事件<br>   _selectBox.btnAttAck.addEventListener(MouseEvent.CLICK, charaAttHandler); <br>  //点击攻击事件<br>  private function charaAttHandler(event:MouseEvent):void{<!-- --><br>   _clickCtrl = "ATTACK";<br>   _selectBox.visible = false;<br>   _roadSprite.addEventListener(MouseEvent.CLICK,onClick);<br>   setAttRound2(_pXml["peo" + _nowChatacter.charaIndex].Arms);<br>  }<br>这里的setAttRound2，用红色半透明MC来显示攻击范围<br>  //攻击范围显示<br>  private function setAttRound2(armIndex:int):void{<!-- --><br>   var attRoundArr:Array;<br>   var attRound:AttShow;<br>   for each ( var roundment:XML in _arms["Arms" + armIndex]["RangeAttack"].elements( ) ) {<!-- --><br>    attRound = new AttShow();<br>    attRoundArr = roundment.toString().split(",");<br>    attRound.x = (int(attRoundArr[0]) + _nowChatacter.locationX )*48;<br>    attRound.y = (int(attRoundArr[1]) + _nowChatacter.locationY) *48;<br>    _roadSprite.addChild(attRound);<br>   }<br>   <br>  }<br>这时候，点击状态已经改变为"ATTACK"<br>在点击事件中，加上攻击事件<br>......<br>else if(_clickCtrl == "ATTACK"){<!-- --><br>    //寻找攻击目标<br>    for(i=0;i&lt;_enemyArr.length &amp;&amp; !queryPeople;i++){<!-- --><br>     _character = _enemyArr[i] as Character;<br>     _characterMC = _character.character;<br>     if(Math.floor(_characterMC.x/48) == Math.floor(__mouseX/48) &amp;&amp; Math.floor(_characterMC.y/48) == Math.floor(__mouseY/48)){<!-- --><br>      <br>      SpriteRemove.removeAllChildren(_roadSprite);<br>      _nowChatacter.character._rival = _character;<br>      _nowChatacter.character._fun = function(){<!-- --><br>       _clickCtrl = "NULL";<br>       _nowChatacter.actionCtrl = true;<br>       addEventListener(Event.ENTER_FRAME, onClickFrame);<br>      }<br>      _nowChatacter.attack();<br>      <br>      break;<br>     }<br>     <br>    }<br>   }<br>这里的_fun很重要，用来处理攻击完之后的事件代码<br>当然，给函数赋了值就要有执行的地方，<br>下面修改人物动作类CharacterMC的动态显示贞事件<br>  //动态显示<br>  public function onFrame(event:Event):void {<!-- --><br>   var dir:int = _showIndex;<br>   _peopleBitmap.bitmapData = _bitShowArr[dir][_pointer];<br>   _count += _speed;<br>   _pointer += int(_count) ;<br>   _count=_count%1;<br>   //当人物攻击时，在攻击的第三个动作，被攻击人物显示被攻击动作<br>   if((dir == CharacterIndex.ATTACK_UP || dir == CharacterIndex.ATTACK_DWON || <br>    dir == CharacterIndex.ATTACK_LEFT || dir == CharacterIndex.ATTACK_RIGHT ) &amp;&amp; _pointer == 2){<!-- --><br>    //得到被攻击人物动作显示类<br>    _rivalMC = _rival.character;<br>    //根据攻击人物方向，设定攻击和被攻击完毕之后的人物方向<br>    if(_rivalMC.x - this.x &gt; 0){<!-- --><br>     this._direct = CharacterIndex.RIGHT;<br>     _rivalMC._direct = CharacterIndex.LEFT;<br>    }else if(_rivalMC.x - this.x &lt; 0){<!-- --><br>     this._direct = CharacterIndex.LEFT;<br>     _rivalMC._direct = CharacterIndex.RIGHT;<br>    }else if(_rivalMC.y - this.y &gt; 0){<!-- --><br>     this._direct = CharacterIndex.DOWN;<br>     _rivalMC._direct = CharacterIndex.UP;<br>    }else if(_rivalMC.y - this.y &lt; 0){<!-- --><br>     this._direct = CharacterIndex.UP;<br>     _rivalMC._direct = CharacterIndex.DOWN;<br>    }<br>    _rivalMC.setDir(CharacterIndex.TAKE_A_BEAT);<br>   }<br>   if(_pointer &gt;= _bitShowArr[dir].length){<!-- --><br>    //人物动作不是移动动作的时候，动作结束后，根据动作前的方向，显示移动动作<br>    switch(dir){<!-- --><br>     case CharacterIndex.TAKE_A_BEAT:<br>      _showIndex = _direct;<br>      break;<br>     case CharacterIndex.ATTACK_UP:<br>      _showIndex = _direct;<br>      _fun();<br>     case CharacterIndex.ATTACK_DWON:<br>      _showIndex = _direct;<br>      _fun();<br>     case CharacterIndex.ATTACK_LEFT:<br>      _showIndex = _direct;<br>      _fun();<br>     case CharacterIndex.ATTACK_RIGHT:<br>      _showIndex = _direct;<br>      _fun();<br>      break;<br>    }<br>    <br>    _pointer = 0;<br>    _count = 0;<br>   }<br>  }<br>之后，在动作类中，加入两个函数，用来控制人物行动前和行动后的亮度，就像曹操传里的行动完之后，人物会变暗<br>  //转为静态<br>  public function stand():void{<!-- --><br>   switch(_showIndex){<!-- --><br>    case CharacterIndex.UP:<br>     setDir(CharacterIndex.UP_STOP);<br>     break;<br>    case CharacterIndex.DOWN:<br>     setDir(CharacterIndex.DOWN_STOP);<br>     break;<br>    case CharacterIndex.LEFT:<br>     setDir(CharacterIndex.LEFT_STOP);<br>     break;<br>    case CharacterIndex.RIGHT:<br>     setDir(CharacterIndex.RIGHT_STOP);<br>     break;<br>   }<br>   this.transform.colorTransform = _standColor;<br>  }<br>  //转为动态<br>  public function run():void{<!-- --><br>   switch(_showIndex){<!-- --><br>    case CharacterIndex.UP_STOP:<br>     setDir(CharacterIndex.UP);<br>     break;<br>    case CharacterIndex.DOWN_STOP:<br>     setDir(CharacterIndex.DOWN);<br>     break;<br>    case CharacterIndex.LEFT_STOP:<br>     setDir(CharacterIndex.LEFT);<br>     break;<br>    case CharacterIndex.RIGHT_STOP:<br>     setDir(CharacterIndex.RIGHT);<br>     break;<br>   }<br>   this.transform.colorTransform = _runColor;<br>  }<br>主要是这些修改，其他的都是些小改动</p> 
<p>目前，只写了我军的攻击，而且只是攻击动作，敌人也不掉血，不过加个掉血并不难，<br>难的是敌军的攻击，现在敌军回合，敌军依然只会跟随我军某一个人物移动，等研究完敌军攻击之后，把代码放出来，</p> 
<p>好了，现在先看一下效果吧<br><img src="https://images2.imgbox.com/a4/de/HIYc5NXB_o.jpg" alt="预览" width="972" height="634"></p> 
<p><img src="https://images2.imgbox.com/27/69/MQNjud3P_o.jpg" alt="预览" width="972" height="634"></p> 
<p>下次，研究一下敌人的攻击</p> 
<p>到了复杂的地方了，敌军的AI问题了</p> 
<p>曹操传中敌军的行动方针有很多种，敌军根据相应的行动方针进行不同的行为<br>所以，我们首先在人物类中，加上行动方针一项<br>  //行动方针<br>  private var _mission:String;<br>默认是"DEFAULT"，现在不研究太复杂，目前只考虑这一个行动方针<br>并且，默认下就选择攻击<br>敌人选择攻击目标的时候，会优先选择一击可以杀死的人物，<br>这里就要在选择攻击目标之前，先来判断一下攻击的这个人能否被杀死<br>那么，就要有物理攻击计算<br>那就利用曹操传中的物理攻击公式在战场类中写一个方法<br>  /*物理攻击的伤害值计算<br>   X代表攻击方的攻击力，Y代表被攻击方的防御力，Lv表示攻击方的等级。R表示伤害值<br>   首先会根据地形修正攻击和防御力为X',Y'<br>   if (x'&gt;y')<br>   r=Lv+25+(X'-Y')/2;<br>   else<br>   r=Lv+25-(Y'-X')/2<br>   然后再根据兵种相克和宝物进行修正<br>  */<br>  public function getAttHurt(attChara:Character,hertChara:Character):int{<!-- --><br>   var r:int;<br>   //得到攻击方的攻击力和等级<br>   var attLv:int =  int(_pXml["peo" + attChara.charaIndex].Lv);<br>   var attAttack:int = int(_pXml["peo" + attChara.charaIndex].Attack);<br>   //得到防御方的防御力<br>   var hertDefense:int = int(_pXml["peo" + hertChara.charaIndex].Defense);<br>   //计算攻击方所在地形<br>   var attTerrain:String = "Terrain" + _mapData[attChara.locationY][attChara.locationX];<br>   //计算防御方所在地形<br>   var hertTerrain:String = "Terrain" + _mapData[hertChara.locationY][hertChara.locationX];<br>   //根据地形修正攻击和防御力<br>   var attAttackAddition:int = Math.floor((int(_arms["Arms" + attChara.armsIndex].Terrain[attTerrain].@Addition)/100) * attAttack);<br>   var hertDefenseAddition:int = Math.floor((int(_arms["Arms" + hertChara.armsIndex].Terrain[hertTerrain].@Addition)/100) * hertDefense);<br>   //物理攻击的伤害值计算<br>   if(attAttackAddition &gt; hertDefenseAddition){<!-- --><br>    r = attLv + 25 + (attAttackAddition - hertDefenseAddition)/2;<br>   }else{<!-- --><br>    r = attLv + 25 + (hertDefenseAddition - attAttackAddition)/2;<br>   }<br>   return r;<br>  }<br>好了，有了伤害计算了，在攻击的时候，先寻找到所有可以攻击到的位置，<br>  //计算所有攻击范围<br>  private function getAttRange(chara:Character):Object{<!-- --><br>   var attArr:Array = new Array();<br>   var attRoundArr:Array;<br>   var i:int;<br>   var j:int;<br>   var objAll:Object = new Object();<br>   var objCheck:Object = new Object();<br>   var obj:Object = new Object();<br>   var attRound:Array = new Array();<br>   //兵种攻击范围<br>   for each ( var roundment:XML in _arms["Arms" + chara.armsIndex]["RangeAttack"].elements( ) ) {<!-- --><br>    attRoundArr = roundment.toString().split(",");<br>    attRound.push(new Point(int(attRoundArr[0]), int(attRoundArr[1])));<br>   }<br>   //根据移动范围来计算所有攻击范围<br>   for(i=0;i&lt;_roadShowArray.length;i++){<!-- --><br>    for(j=0;j&lt;attRound.length;j++){<!-- --><br>     obj = new Object();<br>     obj.x = _roadShowArray[i].x + attRound[j].x;<br>     obj.y = _roadShowArray[i].y + attRound[j].y;<br>     if(objAll[obj.x + "," + obj.y] == null){<!-- --><br>      obj.nodeparent = _roadShowArray[i];<br>      objAll[obj.x + "," + obj.y] = obj;<br>      attArr.push(obj);<br>     }<br>    }<br>   }<br>   objAll.attArr = attArr;<br>   return objAll;<br>  }<br>这里，添加了一个obj.nodeparent，用来确定攻击的时候所移动的位置</p> 
<p>好了，现在就简单了，因为可以利用上面的两个方法轻松找到攻击目标了<br>  //计算攻击目标<br>  public function getAttTarget(chara:Character,peoArr:Array):Object{<!-- --><br>   var i:int;<br>   var objResult:Object;<br>   var obj:Object;<br>   //计算所有攻击范围<br>   var objAll:Object = getAttRange(chara);<br>   var attArr:Array = new Array();<br>   var intHert:int;<br>   for(i=0;i&lt;peoArr.length;i++){<!-- --><br>    var checkChara:Character = peoArr[i];<br>    obj = objAll[checkChara.locationX + "," + checkChara.locationY];<br>    if(obj != null){<!-- --><br>     intHert = getAttHurt(chara,checkChara);<br>     obj.chara = checkChara;<br>     //判断是否有一击可以杀死的人，有的话直接确立目标<br>     if(intHert &gt;= checkChara.nowHP){<!-- --><br>      return obj;<br>     }<br>     attArr.push(obj);<br>    }<br>   }<br>   //没有一击可以杀死的人的时候，如果有可以攻击到的人，则随即抽取可以攻击到的人，确立目标<br>   if(attArr.length &gt; 0 ){<!-- --><br>    i = Math.random() * attArr.length;<br>    return attArr[i];<br>   }<br>   //没有可以攻击到的人，没有找到目标<br>   return null;<br>  }<br>然后，在敌军寻路完成后，就可以判断下行动方针，当然这里的行动方针只有一个，哈哈<br>    if(_nowChatacter.mission == "DEFAULT"){<!-- --><br>     //查找攻击目标<br>     var obj:Object = getAttTarget(_nowChatacter,_ourArr);<br>     if(obj != null){<!-- --><br>      _nowChatacter.character._rival = obj.chara;<br>      _toPoint = new Point(obj.nodeparent.x,obj.nodeparent.y);<br>     }else{<!-- --><br>      //开始行动<br>      _toPoint = new Point(_roadShowArray[0].x,_roadShowArray[0].y);<br>      i = Math.random() * _ourArr.length;<br>      _character = _ourArr[i];<br>      toDistance = Math.abs(_character.locationX - _toPoint.x) + Math.abs(_character.locationY - _toPoint.y) ;<br>      for(i=1;i&lt;_roadShowArray.length;i++){<!-- --><br>       checkDistance = Math.abs(_character.locationX - _roadShowArray[i].x) + Math.abs(_character.locationY - _roadShowArray[i].y) ;<br>       if(checkDistance &lt; toDistance){<!-- --><br>        toDistance = checkDistance;<br>        _toPoint.x = _roadShowArray[i].x;<br>        _toPoint.y = _roadShowArray[i].y;<br>       }<br>      }<br>      _nowChatacter.character._rival = null;<br>     }<br>     _nowPoint = new Point( _nowChatacter.locationX, _nowChatacter.locationY);<br>     _characterMC = _nowChatacter.character;<br>     _nowDirection = _characterMC.getDir();<br>     charaToMove();<br>    }</p> 
<p>看，obj.nodeparent.x,obj.nodeparent.y就是之前确定好的移动位置</p> 
<p>然后，在敌军武将移动完毕时，判断一下是不是有攻击目标<br>没有的话，结束行动，有的话，进入攻击状态<br>     if(_nowChatacter.rival == null){<!-- --><br>      _nowChatacter.actionCtrl = true;<br>      _enemyActionCtrl = 0;<br>      _clickCtrl = "NULL";<br>     }else{<!-- --><br>      _clickCtrl = "ATTACK";<br>     }<br>     addEventListener(Event.ENTER_FRAME, onEnemyFrame);<br>然后，在控制敌军行动事件中，加上攻击代码，和我军攻击的时候是一样的，不同的是，攻击完毕的时候，所调用的方法不一样，我方攻击的时候，需要调用鼠标点击事件，这次需要调用控制敌军行动事了<br> if(_clickCtrl == "ATTACK"){<!-- --><br>    removeEventListener(Event.ENTER_FRAME, onEnemyFrame);<br>    _nowChatacter.character._fun = function(){<!-- --><br>     _clickCtrl = "NULL";<br>     _nowChatacter.actionCtrl = true;<br>     _enemyActionCtrl = 0;<br>     addEventListener(Event.ENTER_FRAME, onEnemyFrame);<br>    }<br>    _nowChatacter.attack();<br>   }</p> 
<p>好了，运行下程序，可以看到敌军也会进行攻击了<br>当然攻击是不掉血的，嘿嘿</p> 
<p>敌军步兵的攻击<br><img src="https://images2.imgbox.com/73/89/cf0YBCHd_o.jpg" alt="预览" width="972" height="634"></p> 
<p><img src="https://images2.imgbox.com/e3/87/hdRsLqNp_o.jpg" alt="预览" width="972" height="634"></p> 
<p>下次，该研究掉血和掉血的时候显示一下了</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/722ae08649f0838bb531ab0edd2a06dc/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">为Asterisk增加中文语音合成TTS功能-eSpeak应用（转）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4b868b430f95a1627ffcf877534d5ecb/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">MySQL-Front 5 注册码(转)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>