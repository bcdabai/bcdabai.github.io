<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>2023首届大学生算法大赛——补题 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="2023首届大学生算法大赛——补题" />
<meta property="og:description" content="1. 拿饼干
内存限制：128Mb
时间限制：1s
题目描述
小明今天外出野炊。他的母亲为他制作了M种他喜欢的饼干，共有N块。每块饼干都被标了编号，从1一直标到N。第i块饼干的重量是W[i]。饼干种类的编号是T[i]，从1一直到M。小明想尽可能拿到最大总重量的饼干，但每种饼干只拿一块，而且他的背包的最大承重不能超过C。请帮助小明进行选择，别忘了要确保每种饼干至少拿一块。
输入
第一行包含三个整数N,M,C，之间用一个空格隔开。N代表饼干总数，M代表饼干种类数，C代表小明的背包的总重量。
第二行包含包含N个整数，W[1], W[2], …, W[i], …, W[N]，之间用一个空格隔开，标明了每块饼干的重量。
第三行包含N个整数，T[1], T[2], …, T[i], …, T[N] ，之间用一个空格隔开，标明了每块饼干的类型。
输出
显示小明的背包拿足了饼干后的重量。
样例输入
复制
5 3 50 10 3 23 13 21 1 2 2 1 3 样例输出
复制
37 提示
约束条件 1 &lt;= M &lt;= N &lt;= 500
1 &lt;= C &lt;= 10000
1 &lt;= W[i] &lt;= 50
1 &lt;= T[i] &lt;= M
输入样例 1 5 3 50" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/e33cf7f3df7beca3812f2f054817d1af/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-04-07T15:04:37+08:00" />
<meta property="article:modified_time" content="2023-04-07T15:04:37+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">2023首届大学生算法大赛——补题</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>1. 拿饼干</p> 
<p>内存限制：128Mb</p> 
<p>时间限制：1s</p> 
<p></p> 
<p>题目描述</p> 
<p>小明今天外出野炊。他的母亲为他制作了M种他喜欢的饼干，共有N块。每块饼干都被标了编号，从1一直标到N。第i块饼干的重量是W[i]。饼干种类的编号是T[i]，从1一直到M。小明想尽可能拿到最大总重量的饼干，但每种饼干只拿一块，而且他的背包的最大承重不能超过C。请帮助小明进行选择，别忘了要确保每种饼干至少拿一块。</p> 
<p>输入</p> 
<p>第一行包含三个整数N,M,C，之间用一个空格隔开。N代表饼干总数，M代表饼干种类数，C代表小明的背包的总重量。</p> 
<p>第二行包含包含N个整数，W[1], W[2], …, W[i], …, W[N]，之间用一个空格隔开，标明了每块饼干的重量。</p> 
<p>第三行包含N个整数，T[1], T[2], …, T[i], …, T[N] ，之间用一个空格隔开，标明了每块饼干的类型。</p> 
<p>输出</p> 
<p>显示小明的背包拿足了饼干后的重量。</p> 
<p>样例输入</p> 
<p>复制</p> 
<p></p> 
<pre>5 3 50
10 3 23 13 21
1 2 2 1 3</pre> 
<p>样例输出</p> 
<p>复制</p> 
<p></p> 
<pre>37</pre> 
<p>提示</p> 
<h4>约束条件</h4> 
<p>1 &lt;= M &lt;= N &lt;= 500</p> 
<p>1 &lt;= C &lt;= 10000</p> 
<p>1 &lt;= W[i] &lt;= 50</p> 
<p>1 &lt;= T[i] &lt;= M</p> 
<h4>输入样例 1</h4> 
<p>5 3 50</p> 
<p>10 3 23 13 21</p> 
<p>1 2 2 1 3</p> 
<h4>输出样例 1</h4> 
<p>37</p> 
<h4>输入样例说明1</h4> 
<p>小明可以这样选择饼干：</p> 
<p>1. 重量为13的第1种饼干；</p> 
<p>2. 重量为3的第2种饼干；</p> 
<p>3. 重量为21的第3种饼干；</p> 
<p>因此总重量为13 + 3 + 21 = 37，未超过背包的最大承重。</p> 
<p></p> 
<h4>输入样例 2</h4> 
<p>3 2 10</p> 
<p>11 12 13</p> 
<p>1 2 1</p> 
<h4>输出样例 2</h4> 
<p>0</p> 
<p></p> 
<h4>输入样例说明2</h4> 
<p>小明无论怎么拿都超过了背包最大承重量，因此无法拿走任何一块饼干。</p> 
<h4><span style="background-color:#38d8f0;">题解 ：</span></h4> 
<p>分析：典型的分组背包，为确保每种饼干至少拿一块，所以要做标记。</p> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstring&gt;
using namespace std;
int n,m,c;
int s[501],t[501],w[501][501];
int dp[10003],vis[10003],vis2[10003];

int main(){
	cin&gt;&gt;n&gt;&gt;m&gt;&gt;c;
	for(int i=1; i&lt;=n; i++) cin&gt;&gt;t[i];
	for(int type,i=1; i&lt;=n; i++){
		cin&gt;&gt;type;
		w[type][++s[type]]=t[i];
	}
	for(int i=1; i&lt;=m; i++){
		for(int j=1;j&lt;=c;j++) vis[j]=vis2[j];
		memset(vis2, 0, sizeof(vis2));
		for(int j=c; j&gt;=1; j--){
			for(int k=1; k&lt;=s[i]; k++){
				if(j&gt;=w[i][k]&amp;&amp;(i==1||vis[j-w[i][k]])){
					if(dp[j-w[i][k]]+w[i][k]&gt;dp[j]){
						dp[j]=dp[j-w[i][k]]+w[i][k];
						vis2[j]=1;
					}
				}
			}
		}
	}
	cout&lt;&lt;dp[c];
	return 0;
}</code></pre> 
<p>2. 村庄</p> 
<p>内存限制：64Mb</p> 
<p>时间限制：1s</p> 
<p></p> 
<p>题目描述</p> 
<p>很久很久以前, 在一个国家里有N个村庄。起初，这N个村庄相互之间通过M座桥梁相连，桥梁从1到M进行编号。第i座桥在第Ai​个村庄和第Bi​个村庄之间进行连接。因此人们可以在任意两个村庄之间利用这些桥梁进行通行。</p> 
<p>为了阻止人们相互联络，入侵者决定一个接一个地毁坏这些桥梁。从第1座桥开始，依次摧毁，直至第K(1 &lt;= K &lt;= M)座桥。</p> 
<p>村庄a和村庄b组成一个村庄组合(a, b)(a &lt; b)，当第一座桥到第K座桥被依次摧毁后，计算到底有多少个 (a, b)(a &lt; b)这样的村庄组合不能通过剩余的一座或多座桥梁进行来往通行。</p> 
<p>输入</p> 
<p>第一行包含三个整数<em><strong>N</strong></em><em><strong>, M, K,</strong></em>分别表示村庄总数、桥梁总数和被摧毁的桥梁数目。</p> 
<p>接着有<em><strong>M</strong></em>行，每一行包含两个整数<em><strong>ai, bi</strong></em>，表示由第i座桥梁连接着的两个村庄的编号。</p> 
<p>输出</p> 
<p>打印出在第一座桥到第K座桥被摧毁后相互不能通行村庄组合的数目。</p> 
<p>样例输入</p> 
<p>复制</p> 
<p></p> 
<pre>4 5 3
1 2
2 3
3 4
4 1
1 3
</pre> 
<p>样例输出</p> 
<p>复制</p> 
<p></p> 
<pre>3</pre> 
<p>提示</p> 
<p>数据范围：</p> 
<p>       2 &lt;= N &lt;= 10^5</p> 
<p>       1 &lt;= K &lt;= M &lt;= 10^5</p> 
<p>       1 &lt;= ai &lt; bi &lt;= N</p> 
<p>       所有的村庄组合(ai, bi) 各不相同。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/ee/c2/AfC0dfrm_o.png"></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/36/3c/q99thhz6_o.png"></p> 
<h4><span style="background-color:#38d8f0;">题解：</span> </h4> 
<p>分析：这道题跟图论不占边，考的是并查集的算法。</p> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
using  namespace std;
int n,m,k;
int pre[100003],num[100003];

int find(int x){
	if(x==pre[x]) return x;
	return pre[x]=find(pre[x]);
}

void join(int x,int y){
	int fx=find(x);
	int fy=find(y);
	if(fx!=fy){
		pre[fx]=fy;
	}
}

int main(){
	cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;
	for(int i=1;i&lt;=n;i++) pre[i]=i;
	for(int x,y,i=1;i&lt;=m;i++){
		cin&gt;&gt;x&gt;&gt;y;
		if(i&gt;k){
			join(x,y);
		}
	}
	for(int i=1; i&lt;=n; i++){
		num[find(i)]++;
	}
	long long ans=0;
	for(int i=1; i&lt;=n; i++){
		if(num[i]){
			for(int j=i+1; j&lt;=n; j++){
				if(num[j]) ans+=num[i]*num[j];
			}
		}
	}
	cout&lt;&lt;ans;
	return 0;
}</code></pre> 
<p>3. 幸运数字</p> 
<p>内存限制：64Mb</p> 
<p>时间限制：1s</p> 
<p></p> 
<p>题目描述</p> 
<p>数字8、2、6、9是大多数中国人中最喜欢的幸运数字。这几个数字的组合也被视为幸运数字，例如88。</p> 
<p>小龙非常喜欢幸运数字。他认为只有满足以下条件的正整数才算是好的整数：</p> 
<p>8、2、6、9中的每个数字至少在这个整数中出现一次，而且没有除了这四个之外的其他数字。</p> 
<p>小龙想知道在1和N（含N）之间有多少个满足这一条件的整数。</p> 
<p>输入</p> 
<p>输入一个整数N。</p> 
<p>输出</p> 
<p>打印输出1到N（含N）之间幸运数字的总数量。</p> 
<p>样例输入</p> 
<p>复制</p> 
<p></p> 
<pre>5673</pre> 
<p>样例输出</p> 
<p>复制</p> 
<p></p> 
<pre>6</pre> 
<p>提示</p> 
<p>数据范围：</p> 
<p>       1 &lt;= N &lt; 10^12</p> 
<p>样例说明：</p> 
<p>       有6个不大于5673的幸运数字：2689、2698、2869、2896、2968、2986</p> 
<h4><span style="background-color:#38d8f0;">题解：</span> </h4> 
<p>分析：DFS。（学习了此人的博客）<a href="https://blog.csdn.net/qq_74910785/article/details/129915644?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168057176016800211535615%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=168057176016800211535615&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~times_rank-1-129915644-null-null.142%5Ev81%5Einsert_down38,201%5Ev4%5Eadd_ask,239%5Ev2%5Einsert_chatgpt&amp;utm_term=2023%E9%A6%96%E5%B1%8A%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%AE%97%E6%B3%95%E5%A4%A7%E8%B5%9B%E2%80%94%E2%80%94%E6%AD%A3%E5%BC%8F%E8%B5%9B&amp;spm=1018.2226.3001.4187" title="2023首届大学生算法大赛——正式赛 5、7（DFS）_panjyash的博客-CSDN博客">2023首届大学生算法大赛——正式赛 5、7（DFS）_panjyash的博客-CSDN博客</a></p> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;
typedef long long LL;
LL n,ans;

void dfs(LL u,bool f2,bool f6,bool f8,bool f9){
	if(u&gt;n) return ;
	if(f2&amp;&amp;f6&amp;&amp;f8&amp;&amp;f9) ans++;
	dfs(u*10+2,1,f6,f8,f9);
	dfs(u*10+6,f2,1,f8,f9);
	dfs(u*10+8,f2,f6,1,f9);
	dfs(u*10+9,f2,f6,f8,1);
}

int main(){
	cin&gt;&gt;n;
	dfs(0, 0, 0, 0, 0);
	cout&lt;&lt;ans;
	return 0;
}</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/997187b4848a95e9633b1c77b4ec6efe/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">第十一届蓝桥杯大赛决赛试题 C&amp;C&#43;&#43; 大学 C 组</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/fd52a36619d49286915dd6984fccae19/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">.NET Framework 3.5 安装报错</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>