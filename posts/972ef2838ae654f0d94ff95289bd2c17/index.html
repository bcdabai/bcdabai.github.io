<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>力扣：494. 目标和（动态规划）（01背包） - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="力扣：494. 目标和（动态规划）（01背包）" />
<meta property="og:description" content="题目： 给你一个非负整数数组 nums 和一个整数 target 。
向数组中的每个整数前添加 ‘&#43;’ 或 ‘-’ ，然后串联起所有整数，可以构造一个 表达式
例如，nums = [2, 1] ，可以在 2 之前添加 ‘&#43;’ ，在 1 之前添加 ‘-’ ，然后串联起来得到表达式 “&#43;2-1” 。
返回可以通过上述方法构造的、运算结果等于 target 的不同 表达式 的数目。
示例 1：
输入：
nums = [1,1,1,1,1], target = 3
输出：
5
解释：
一共有 5 种方法让最终目标和为 3 。
-1 &#43; 1 &#43; 1 &#43; 1 &#43; 1 = 3
&#43;1 - 1 &#43; 1 &#43; 1 &#43; 1 = 3" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/972ef2838ae654f0d94ff95289bd2c17/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-20T14:09:12+08:00" />
<meta property="article:modified_time" content="2024-01-20T14:09:12+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">力扣：494. 目标和（动态规划）（01背包）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="_0"></a>题目：</h2> 
<p>给你一个非负整数数组 nums 和一个整数 target 。</p> 
<p>向数组中的每个整数前添加 ‘+’ 或 ‘-’ ，然后串联起所有整数，可以构造一个 表达式</p> 
<p>例如，nums = [2, 1] ，可以在 2 之前添加 ‘+’ ，在 1 之前添加 ‘-’ ，然后串联起来得到表达式 “+2-1” 。<br> 返回可以通过上述方法构造的、运算结果等于 target 的不同 表达式 的数目。</p> 
<p><strong>示例</strong> 1：</p> 
<p>输入：</p> 
<blockquote> 
 <p>nums = [1,1,1,1,1], target = 3</p> 
</blockquote> 
<p>输出：</p> 
<blockquote> 
 <p>5</p> 
</blockquote> 
<p>解释：</p> 
<blockquote> 
 <p>一共有 5 种方法让最终目标和为 3 。<br> -1 + 1 + 1 + 1 + 1 = 3<br> +1 - 1 + 1 + 1 + 1 = 3<br> +1 + 1 - 1 + 1 + 1 = 3<br> +1 + 1 + 1 - 1 + 1 = 3<br> +1 + 1 + 1 + 1 - 1 = 3</p> 
</blockquote> 
<p><strong>示例 2</strong>：</p> 
<p>输入：</p> 
<blockquote> 
 <p>nums = [1], target = 1</p> 
</blockquote> 
<p>输出：</p> 
<blockquote> 
 <p>1</p> 
</blockquote> 
<p><strong>提示</strong>：</p> 
<ul><li>1 &lt;= nums.length &lt;= 20</li><li>0 &lt;= nums[i] &lt;= 1000</li><li>0 &lt;= sum(nums[i]) &lt;= 1000</li><li>-1000 &lt;= target &lt;= 1000</li></ul> 
<h2><a id="_47"></a>思路：</h2> 
<p>本题可以用回溯来解决（但是会超时），也可以用动态规划中的01背包来解决，<br> 如何转化为01背包问题呢。</p> 
<p>假设加法的总和为x，那么减法对应的总和就是sum - x。</p> 
<p>所以我们要求的是 x - (sum - x) = target</p> 
<p>x = (target + sum) / 2</p> 
<p>此时问题就转化为，装满容量为x的背包，有几种方法。</p> 
<p>这里的x，就是bagSize，也就是我们后面要求的背包容量。</p> 
<p>大家看到(target + sum) / 2 应该担心计算的过程中向下取整有没有影响。</p> 
<p>这么担心就对了，例如sum 是5，S是2的话其实就是无解的，所以：</p> 
<pre><code class="prism language-python">        <span class="token comment"># 如果nums的和与target的和的奇偶性不同，无法得到目标和为target的子集</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token builtin">sum</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token operator">+</span> target<span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token number">0</span>
</code></pre> 
<p>同时如果 S的绝对值已经大于sum，那么也是没有方案的。</p> 
<pre><code class="prism language-python">        <span class="token comment"># 如果目标和的绝对值大于nums的和，无法得到目标和为target的子集</span>
        <span class="token keyword">if</span> <span class="token builtin">abs</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token builtin">sum</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token number">0</span>
</code></pre> 
<p>再回归到01背包问题，为什么是01背包呢？</p> 
<p>因为每个物品（题目中的1）只用一次</p> 
<p>这次和之前遇到的背包问题不一样了，之前都是求容量为j的背包，最多能装多少。</p> 
<p>本题则是装满有几种方法。其实这就是一个组合问题了。</p> 
<p><strong>动态规划五部曲</strong>：</p> 
<ol><li><strong>确定dp数组以及下标的含义</strong></li></ol> 
<p>dp[j] 表示：填满j（包括j）这么大容积的包，有dp[j]种方法</p> 
<ol start="2"><li><strong>确定递推公式</strong></li></ol> 
<p>有哪些来源可以推出dp[j]呢？</p> 
<p>只要搞到nums[i]，凑成dp[j]就有dp[j - nums[i]] 种方法。</p> 
<p>例如：dp[j]，j 为5，</p> 
<ul><li>已经有一个1（nums[i]） 的话，有 dp[4]种方法 凑成 dp[5]。</li><li>已经有一个2（nums[i]） 的话，有 dp[3]种方法 凑成 dp[5]。</li><li>已经有一个3（nums[i]） 的话，有 dp[2]中方法 凑成 dp[5]。</li><li>已经有一个4（nums[i]） 的话，有 dp[1]中方法 凑成 dp[5]。</li><li>已经有一个5（nums[i]） 的话，有 dp[0]中方法 凑成 dp[5]。</li></ul> 
<p>那么凑整dp[5]有多少方法呢，也就是把 所有的 dp[j - nums[i]] 累加起来。</p> 
<pre><code class="prism language-python">dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+=</span> dp<span class="token punctuation">[</span>j <span class="token operator">-</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span>
</code></pre> 
<p>这个跟爬楼梯（力扣：70爬楼梯）和不同路径（力扣：62.不同路径）的思路有点类似，现在在重新分析一下：<br> 现在有dp[4]种方法凑成4,你手上还有一个数字1，那么凑成5的话有几种方法？ 还是dp[4]种方法！为什么不是dp[4] + 1 种方法呢？因为这个数字1是确定只能是+1，而不能是-1，只有一种方法使4变成5。可以这样理解，这里的方法数量最后是dp[4] * 1，<br> 如果这里1可以是+1也可以是-1的话那方法数量应该是dp[4] * 2</p> 
<p>同理，有dp[3]种方法凑成3，现在手上还有一个2，那么有几种方法凑成5？还是dp[3]种！</p> 
<ol start="3"><li><strong>dp数组如何初始化</strong></li></ol> 
<p>从递推公式可以看出，在初始化的时候dp[0] 一定要初始化为1，因为dp[0]是在公式中一切递推结果的起源，如果dp[0]是0的话，递推结果将都是0。</p> 
<p>这里有录友可能认为从dp数组定义来说 dp[0] 应该是0，也有录友认为dp[0]应该是1。</p> 
<p>其实不要硬去解释它的含义，咱就把 dp[0]的情况带入本题看看应该等于多少。</p> 
<p>如果数组[0] ，target = 0，那么 bagSize = (target + sum) / 2 = 0。 dp[0]也应该是1， 也就是说给数组里的元素 0 前面无论放加法还是减法，都是 1 种方法。</p> 
<p>所以本题我们应该初始化 dp[0] 为 1。</p> 
<ol start="4"><li><strong>确定遍历顺序</strong></li></ol> 
<p>毋庸置疑，对于01背包问题一维dp的遍历，nums放在外循环，target在内循环，且内循环倒序。</p> 
<ol start="5"><li><strong>举例推导dp数组</strong></li></ol> 
<p>输入：nums: [1, 1, 1, 1, 1], S: 3</p> 
<p>bagSize = (S + sum) / 2 = (3 + 5) / 2 = 4</p> 
<p>dp数组状态变化如下：<br> <img src="https://images2.imgbox.com/2b/d0/CIqd3sIo_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="_142"></a>代码及详细注释：</h2> 
<p>一维dp数组：</p> 
<pre><code class="prism language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">findTargetSumWays</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">,</span> target<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">int</span><span class="token punctuation">:</span>
        <span class="token comment"># 如果nums的和与target的和的奇偶性不同，无法得到目标和为target的子集</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token builtin">sum</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token operator">+</span> target<span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token number">0</span>
        <span class="token comment"># 如果目标和的绝对值大于nums的和，无法得到目标和为target的子集</span>
        <span class="token keyword">if</span> <span class="token builtin">abs</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token builtin">sum</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token number">0</span>
        <span class="token comment"># 计算S，S为目标和</span>
        S <span class="token operator">=</span> <span class="token punctuation">(</span>target <span class="token operator">+</span> <span class="token builtin">sum</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">//</span> <span class="token number">2</span>
        <span class="token comment"># 创建一个长度为S+1的数组dp，用于记录可以得到和为i的子集的个数</span>
        dp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token punctuation">(</span>S <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>
        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>  <span class="token comment"># 初始化dp[0]为1</span>
        <span class="token comment"># 遍历nums中的每个数字</span>
        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token comment"># 从S到nums[i]遍历，更新dp数组</span>
            <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>S<span class="token punctuation">,</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                <span class="token comment"># 更新dp[j]的值</span>
                dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+=</span> dp<span class="token punctuation">[</span>j <span class="token operator">-</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span>
        <span class="token comment"># 返回dp[S]，表示可以得到和为S的子集的个数</span>
        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>S<span class="token punctuation">]</span>

</code></pre> 
<ul><li>时间复杂度：O(n × m)，n为正数个数，m为背包容量</li><li>空间复杂度：O(m)，m为背包容量</li></ul> 
<p>回溯版本：</p> 
<pre><code class="prism language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>


    <span class="token keyword">def</span> <span class="token function">backtracking</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> candidates<span class="token punctuation">,</span> target<span class="token punctuation">,</span> total<span class="token punctuation">,</span> startIndex<span class="token punctuation">,</span> path<span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> total <span class="token operator">==</span> target<span class="token punctuation">:</span>
            result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>path<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment"># 将当前路径的副本添加到结果中</span>
        <span class="token comment"># 如果 sum + candidates[i] &gt; target，则停止遍历</span>
        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>startIndex<span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">(</span>candidates<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> total <span class="token operator">+</span> candidates<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&gt;</span> target<span class="token punctuation">:</span>
                <span class="token keyword">break</span>
            total <span class="token operator">+=</span> candidates<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
            path<span class="token punctuation">.</span>append<span class="token punctuation">(</span>candidates<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
            self<span class="token punctuation">.</span>backtracking<span class="token punctuation">(</span>candidates<span class="token punctuation">,</span> target<span class="token punctuation">,</span> total<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> path<span class="token punctuation">,</span> result<span class="token punctuation">)</span>
            total <span class="token operator">-=</span> candidates<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
            path<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token keyword">def</span> <span class="token function">findTargetSumWays</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">,</span> target<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">int</span><span class="token punctuation">:</span>
        total <span class="token operator">=</span> <span class="token builtin">sum</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span>
        <span class="token keyword">if</span> target <span class="token operator">&gt;</span> total<span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token number">0</span>  <span class="token comment"># 此时没有方案</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>target <span class="token operator">+</span> total<span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token number">0</span>  <span class="token comment"># 此时没有方案，两个整数相加时要注意数值溢出的问题</span>
        bagSize <span class="token operator">=</span> <span class="token punctuation">(</span>target <span class="token operator">+</span> total<span class="token punctuation">)</span> <span class="token operator">//</span> <span class="token number">2</span>  <span class="token comment"># 转化为组合总和问题，bagSize就是目标和</span>

        <span class="token comment"># 以下是回溯法代码</span>
        result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        nums<span class="token punctuation">.</span>sort<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># 需要对nums进行排序</span>
        self<span class="token punctuation">.</span>backtracking<span class="token punctuation">(</span>nums<span class="token punctuation">,</span> bagSize<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> result<span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token builtin">len</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span>


</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/1c4c574ef8186f916be143a5f4ce1bd1/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">laravel8.*集成dingo</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/cb217ecf4f353923ab8619cc4f0a1e7b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Transformer技术深度剖析：AI语言处理的新纪元</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>