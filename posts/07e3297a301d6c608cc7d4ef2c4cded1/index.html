<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>KMP算法最浅显理解——一看就明白 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="KMP算法最浅显理解——一看就明白" />
<meta property="og:description" content="说明 KMP算法看懂了觉得特别简单，思路很简单，看不懂之前，查各种资料，看的稀里糊涂，即使网上最简单的解释，依然看的稀里糊涂。 我花了半天时间，争取用最短的篇幅大致搞明白这玩意到底是啥。 这里不扯概念，只讲算法过程和代码理解：
KMP算法求解什么类型问题 字符串匹配。给你两个字符串，寻找其中一个字符串是否包含另一个字符串，如果包含，返回包含的起始位置。 如下面两个字符串：
char *str = &#34;bacbababadababacambabacaddababacasdsd&#34;; char *ptr = &#34;ababaca&#34;; str有两处包含ptr 分别在str的下标10，26处包含ptr。
“bacbababadababacambabacaddababacasdsd”;\ 问题类型很简单，下面直接介绍算法
算法说明 一般匹配字符串时，我们从目标字符串str（假设长度为n）的第一个下标选取和ptr长度（长度为m）一样的子字符串进行比较，如果一样，就返回开始处的下标值，不一样，选取str下一个下标，同样选取长度为n的字符串进行比较，直到str的末尾（实际比较时，下标移动到n-m）。这样的时间复杂度是O(n*m)。
KMP算法：可以实现复杂度为O(m&#43;n)
为何简化了时间复杂度： 充分利用了目标字符串ptr的性质（比如里面部分字符串的重复性，即使不存在重复字段，在比较时，实现最大的移动量）。 上面理不理解无所谓，我说的其实也没有深刻剖析里面的内部原因。
考察目标字符串ptr： ababaca 这里我们要计算一个长度为m的转移函数next。
next数组的含义就是一个固定字符串的最长前缀和最长后缀相同的长度。
比如：abcjkdabc，那么这个数组的最长前缀和最长后缀相同必然是abc。 cbcbc，最长前缀和最长后缀相同是cbc。 abcbc，最长前缀和最长后缀相同是不存在的。
**注意最长前缀：是说以第一个字符开始，但是不包含最后一个字符。 比如aaaa相同的最长前缀和最长后缀是aaa。** 对于目标字符串ptr，ababaca，长度是7，所以next[0]，next[1]，next[2]，next[3]，next[4]，next[5]，next[6]分别计算的是 a，ab，aba，abab，ababa，ababac，ababaca的相同的最长前缀和最长后缀的长度。由于a，ab，aba，abab，ababa，ababac，ababaca的相同的最长前缀和最长后缀是“”，“”，“a”，“ab”，“aba”，“”，“a”,所以next数组的值是[-1,-1,0,1,2,-1,0]，这里-1表示不存在，0表示存在长度为1，2表示存在长度为3。这是为了和代码相对应。
下图中的1，2，3，4是一样的。1-2之间的和3-4之间的也是一样的，我们发现A和B不一样；之前的算法是我把下面的字符串往前移动一个距离，重新从头开始比较，那必然存在很多重复的比较。现在的做法是，我把下面的字符串往前移动，使3和2对其，直接比较C和A是否一样。
代码解析 void cal_next(char *str, int *next, int len) { next[0] = -1;//next[0]初始化为-1，-1表示不存在相同的最大前缀和最大后缀 int k = -1;//k初始化为-1 for (int q = 1; q &lt;= len-1; q&#43;&#43;) { while (k &gt; -1 &amp;&amp; str[k &#43; 1] !" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/07e3297a301d6c608cc7d4ef2c4cded1/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2017-02-07T17:41:08+08:00" />
<meta property="article:modified_time" content="2017-02-07T17:41:08+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">KMP算法最浅显理解——一看就明白</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3 id="说明">说明</h3> 
<p>KMP算法看懂了觉得特别简单，思路很简单，看不懂之前，查各种资料，看的稀里糊涂，即使网上最简单的解释，依然看的稀里糊涂。 <br> 我花了半天时间，争取用最短的篇幅大致搞明白这玩意到底是啥。 <br> 这里不扯概念，只讲算法过程和代码理解：</p> 
<h3 id="kmp算法求解什么类型问题">KMP算法求解什么类型问题</h3> 
<p>字符串匹配。给你两个字符串，寻找其中一个字符串是否包含另一个字符串，如果包含，返回包含的起始位置。 <br> 如下面两个字符串：</p> 
<pre class="prettyprint"><code class=" hljs rust"><span class="hljs-keyword">char</span> *<span class="hljs-keyword">str</span> = <span class="hljs-string">"bacbababadababacambabacaddababacasdsd"</span>;
<span class="hljs-keyword">char</span> *ptr = <span class="hljs-string">"ababaca"</span>;</code></pre> 
<p>str有两处包含ptr <br> 分别在str的下标10，26处包含ptr。</p> 
<p>“bacbababad<font color="red">ababaca</font>mbabacadd<font color="red">ababaca</font>sdsd”;\ <br> <img src="https://images2.imgbox.com/64/6a/PUd2EBgN_o.jpg" alt="这里写图片描述" title=""></p> 
<p>问题类型很简单，下面直接介绍算法</p> 
<h3 id="算法说明">算法说明</h3> 
<p>一般匹配字符串时，我们从目标字符串str（假设长度为n）的第一个下标选取和ptr长度（长度为m）一样的子字符串进行比较，如果一样，就返回开始处的下标值，不一样，选取str下一个下标，同样选取长度为n的字符串进行比较，直到str的末尾（实际比较时，下标移动到n-m）。<strong>这样的时间复杂度是O(n*m)</strong>。</p> 
<p><strong>KMP算法：可以实现复杂度为O(m+n)</strong></p> 
<p>为何简化了时间复杂度： <br> <font color="red"><strong>充分利用了目标字符串ptr的性质（比如里面部分字符串的重复性，即使不存在重复字段，在比较时，实现最大的移动量）。</strong></font> <br> 上面理不理解无所谓，我说的其实也没有深刻剖析里面的内部原因。</p> 
<p><strong>考察目标字符串ptr</strong>： <br> <font color="red">ababaca</font> <br> 这里我们要计算一个长度为m的转移函数next。</p> 
<p>next数组的含义就是一个固定字符串的最长前缀和最长后缀相同的长度。</p> 
<p>比如：abcjkdabc，那么这个数组的最长前缀和最长后缀相同必然是abc。 <br> cbcbc，最长前缀和最长后缀相同是cbc。 <br> abcbc，最长前缀和最长后缀相同是不存在的。</p> 
<p>**注意最长前缀：是说以第一个字符开始，但是不包含最后一个字符。 <br> 比如aaaa相同的最长前缀和最长后缀是aaa。** <br> 对于目标字符串ptr，<font color="red">ababaca</font>，长度是7，所以next[0]，next[1]，next[2]，next[3]，next[4]，next[5]，next[6]分别计算的是 <br> <font color="red">a</font>，<font color="red">ab</font>，<font color="red">aba</font>，<font color="red">abab</font>，<font color="red">ababa</font>，<font color="red">ababac</font>，<font color="red">ababaca</font>的相同的最长前缀和最长后缀的长度。由于<font color="red">a</font>，<font color="red">ab</font>，<font color="red">aba</font>，<font color="red">abab</font>，<font color="red">ababa</font>，<font color="red">ababac</font>，<font color="red">ababaca</font>的相同的最长前缀和最长后缀是“”，“”，“a”，“ab”，“aba”，“”，“a”,所以next数组的值是[-1,-1,0,1,2,-1,0]，这里-1表示不存在，0表示存在长度为1，2表示存在长度为3。这是为了和代码相对应。</p> 
<p>下图中的1，2，3，4是一样的。1-2之间的和3-4之间的也是一样的，我们发现A和B不一样；之前的算法是我把下面的字符串往前移动一个距离，重新从头开始比较，那必然存在很多重复的比较。现在的做法是，我把下面的字符串往前移动，使3和2对其，直接比较C和A是否一样。</p> 
<p><img src="https://images2.imgbox.com/4b/49/o7aUGIXm_o.jpg" alt="这里写图片描述" title=""></p> 
<p><img src="https://images2.imgbox.com/f5/07/xn1kSJkF_o.jpg" alt="这里写图片描述" title=""></p> 
<h3 id="代码解析">代码解析</h3> 
<pre class="prettyprint"><code class=" hljs axapta"><span class="hljs-keyword">void</span> cal_next(<span class="hljs-keyword">char</span> *<span class="hljs-keyword">str</span>, <span class="hljs-keyword">int</span> *next, <span class="hljs-keyword">int</span> len)
{
    next[<span class="hljs-number">0</span>] = -<span class="hljs-number">1</span>;<span class="hljs-comment">//next[0]初始化为-1，-1表示不存在相同的最大前缀和最大后缀</span>
    <span class="hljs-keyword">int</span> k = -<span class="hljs-number">1</span>;<span class="hljs-comment">//k初始化为-1</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> q = <span class="hljs-number">1</span>; q &lt;= len-<span class="hljs-number">1</span>; q++)
    {
        <span class="hljs-keyword">while</span> (k &gt; -<span class="hljs-number">1</span> &amp;&amp; <span class="hljs-keyword">str</span>[k + <span class="hljs-number">1</span>] != <span class="hljs-keyword">str</span>[q])<span class="hljs-comment">//如果下一个不同，那么k就变成next[k]，注意next[k]是小于k的，无论k取任何值。</span>
        {
            k = next[k];<span class="hljs-comment">//往前回溯</span>
        }
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">str</span>[k + <span class="hljs-number">1</span>] == <span class="hljs-keyword">str</span>[q])<span class="hljs-comment">//如果相同，k++</span>
        {
            k = k + <span class="hljs-number">1</span>;
        }
        next[q] = k;<span class="hljs-comment">//这个是把算的k的值（就是相同的最大前缀和最大后缀长）赋给next[q]</span>
    }
}</code></pre> 
<h3 id="kmp">KMP</h3> 
<p>这个和next很像，具体就看代码，其实上面已经大概说完了整个匹配过程。</p> 
<pre class="prettyprint"><code class=" hljs axapta"><span class="hljs-keyword">int</span> KMP(<span class="hljs-keyword">char</span> *<span class="hljs-keyword">str</span>, <span class="hljs-keyword">int</span> slen, <span class="hljs-keyword">char</span> *ptr, <span class="hljs-keyword">int</span> plen)
{
    <span class="hljs-keyword">int</span> *next = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[plen];
    cal_next(ptr, next, plen);<span class="hljs-comment">//计算next数组</span>
    <span class="hljs-keyword">int</span> k = -<span class="hljs-number">1</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; slen; i++)
    {
        <span class="hljs-keyword">while</span> (k &gt;-<span class="hljs-number">1</span>&amp;&amp; ptr[k + <span class="hljs-number">1</span>] != <span class="hljs-keyword">str</span>[i])<span class="hljs-comment">//ptr和str不匹配，且k&gt;-1（表示ptr和str有部分匹配）</span>
            k = next[k];<span class="hljs-comment">//往前回溯</span>
        <span class="hljs-keyword">if</span> (ptr[k + <span class="hljs-number">1</span>] == <span class="hljs-keyword">str</span>[i])
            k = k + <span class="hljs-number">1</span>;
        <span class="hljs-keyword">if</span> (k == plen-<span class="hljs-number">1</span>)<span class="hljs-comment">//说明k移动到ptr的最末端</span>
        {
            <span class="hljs-comment">//cout &lt;&lt; "在位置" &lt;&lt; i-plen+1&lt;&lt; endl;</span>
            <span class="hljs-comment">//k = -1;//重新初始化，寻找下一个</span>
            <span class="hljs-comment">//i = i - plen + 1;//i定位到该位置，外层for循环i++可以继续找下一个（这里默认存在两个匹配字符串可以部分重叠），感谢评论中同学指出错误。</span>
            <span class="hljs-keyword">return</span> i-plen+<span class="hljs-number">1</span>;<span class="hljs-comment">//返回相应的位置</span>
        }
    }
    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;  
}</code></pre> 
<h3 id="测试">测试</h3> 
<pre class="prettyprint"><code class=" hljs rust">    <span class="hljs-keyword">char</span> *<span class="hljs-keyword">str</span> = <span class="hljs-string">"bacbababadababacambabacaddababacasdsd"</span>;
    <span class="hljs-keyword">char</span> *ptr = <span class="hljs-string">"ababaca"</span>;
    <span class="hljs-keyword">int</span> a = KMP(<span class="hljs-keyword">str</span>, <span class="hljs-number">36</span>, ptr, <span class="hljs-number">7</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</code></pre> 
<p>注意如果str里有多个匹配ptr的字符串，要想求出所有的满足要求的下标位置，在KMP算法需要稍微修改一下。见上面注释掉的代码。</p> 
<h3 id="复杂度分析">复杂度分析</h3> 
<p>next函数计算复杂度是(m)，开始以为是O(m^2)，后来仔细想了想，cal__next里的while循环，以及外层for循环，利用均摊思想，其实是O(m)，这个以后想好了再写上。</p> 
<p>………………………………………..分割线…………………………………….. <br> 其实本文已经结束，后面的只是针对评论里的疑问，我尝试着进行解答的。</p> 
<h3 id="进一步说明2018-3-14">进一步说明（2018-3-14）</h3> 
<p>看了评论，大家对cal_next(..)函数和KMP()函数里的</p> 
<pre class="prettyprint"><code class=" hljs rust"><span class="hljs-keyword">while</span> (k &gt; -<span class="hljs-number">1</span> &amp;&amp; <span class="hljs-keyword">str</span>[k + <span class="hljs-number">1</span>] != <span class="hljs-keyword">str</span>[q])
        {
            k = next[k];
        }</code></pre> 
<p>和</p> 
<pre class="prettyprint"><code class=" hljs ruby"><span class="hljs-keyword">while</span> (k &gt;-<span class="hljs-number">1</span>&amp;&amp; ptr[k + <span class="hljs-number">1</span>] != str[i])
            k = <span class="hljs-keyword">next</span>[k];</code></pre> 
<p>这个while循环和k=next[k]很疑惑！ <br> <strong>确实啊，我开始看这几行代码，相当懵逼，这写的啥啊，为啥这样写；后来上机跑了一下，慢慢了解到为何这样写了。这几行代码，可谓是对KMP算法本质得了解非常清楚才能想到的。很牛逼！</strong> <br> <strong>直接看cal_next(..)函数：</strong> <br> 首先我们看第一个while循环，它到底干了什么。</p> 
<p>在此之前，我们先回到原程序。原程序里有一个大的<strong>for()</strong>循环，那这个for()循环是干嘛的？</p> 
<p>这个for循环就是计算next[0]，next[1],…next[q]…的值。</p> 
<p>里面最后一句next[q]=k就是说明每次循环结束，我们已经计算了ptr的前(q+1)个字母组成的子串的“<strong>相同的最长前缀和最长后缀的长度</strong>”。（这句话前面已经解释了！） 这个“<strong>长度</strong>”就是k。</p> 
<p>好，到此为止，假设循环进行到 第 q 次，即已经计算了next[q]，我们是怎么计算next[q+1]呢？</p> 
<p>比如我们已经知道<strong>ababab</strong>，q=4时，next[4]=2（k=2，表示该字符串的前5个字母组成的子串<strong>ababa</strong>存在<strong>相同的最长前缀和最长后缀的长度</strong>是3，所以k=2,next[4]=2。这个结果可以理解成我们自己观察算的，也可以理解成程序自己算的，这不是重点，重点是程序根据目前的结果怎么算next[5]的）.，那么对于字符串<strong>ababab</strong>，我们计算next[5]的时候，此时q=5, k=2（上一步循环结束后的结果）。那么我们需要比较的是str[k+1]和str[q]是否相等，其实就是str[1]和str[5]是否相等！，为啥从k+1比较呢，因为上一次循环中，<strong>我们已经保证了str[k]和str[q]（注意这个q是上次循环的q）是相等的</strong>（这句话自己想想，很容易理解），所以到本次循环，我们直接比较str[k+1]和str[q]是否相等（这个q是本次循环的q）。 <br> 如果相等，那么跳出while()，进入if()，k=k+1，接着next[q]=k。即对于<strong>ababab</strong>，我们会得出next[5]=3。 这是程序自己算的，和我们观察的是一样的。 <br> 如果不等，我们可以用”<strong>ababac</strong>“描述这种情况。 不等，进入while()里面，进行k=next[k]，这句话是说，在str[k + 1] != str[q]的情况下，我们往前找一个k，使str[k + 1]==str[q]，是往前一个一个找呢，还是有更快的找法呢？ （<strong>一个一个找必然可以，即你把 k = next[k] 换成k- -也是完全能运行的（更正：这句话不对啊，把k=next[k]换成k–是不行的，评论25楼举了个反例）</strong>。但是程序给出了一种更快的找法，那就是 k = next[k]。 程序的意思是说，一旦str[k + 1] != str[q]，即在后缀里面找不到时，我是可以直接跳过中间一段，跑到前缀里面找，<strong>next[k]</strong>就是<strong>相同的最长前缀和最长后缀的长度</strong>。所以，k=next[k]就变成，k=next[2]，即k=0。此时再比较str[0+1]和str[5]是否相等，不等，则k=next[0]=-1。跳出循环。 <br> （这个解释能懂不？）</p> 
<p>以上就是这个cal_next()函数里的</p> 
<pre class="prettyprint"><code class=" hljs rust"><span class="hljs-keyword">while</span> (k &gt; -<span class="hljs-number">1</span> &amp;&amp; <span class="hljs-keyword">str</span>[k + <span class="hljs-number">1</span>] != <span class="hljs-keyword">str</span>[q])
        {
            k = next[k];
        }</code></pre> 
<p>最难理解的地方的一个我的理解，有不对的欢迎指出。</p> 
<p>复杂度分析：</p> 
<p>分析KMP复杂度，那就直接看KMP函数。</p> 
<pre class="prettyprint"><code class=" hljs axapta"><span class="hljs-keyword">int</span> KMP(<span class="hljs-keyword">char</span> *<span class="hljs-keyword">str</span>, <span class="hljs-keyword">int</span> slen, <span class="hljs-keyword">char</span> *ptr, <span class="hljs-keyword">int</span> plen)
{
    <span class="hljs-keyword">int</span> *next = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[plen];
    cal_next(ptr, next, plen);<span class="hljs-comment">//计算next数组</span>
    <span class="hljs-keyword">int</span> k = -<span class="hljs-number">1</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; slen; i++)
    {
        <span class="hljs-keyword">while</span> (k &gt;-<span class="hljs-number">1</span>&amp;&amp; ptr[k + <span class="hljs-number">1</span>] != <span class="hljs-keyword">str</span>[i])<span class="hljs-comment">//ptr和str不匹配，且k&gt;-1（表示ptr和str有部分匹配）</span>
            k = next[k];<span class="hljs-comment">//往前回溯</span>
        <span class="hljs-keyword">if</span> (ptr[k + <span class="hljs-number">1</span>] == <span class="hljs-keyword">str</span>[i])
            k = k + <span class="hljs-number">1</span>;
        <span class="hljs-keyword">if</span> (k == plen-<span class="hljs-number">1</span>)<span class="hljs-comment">//说明k移动到ptr的最末端</span>
        {
            <span class="hljs-comment">//cout &lt;&lt; "在位置" &lt;&lt; i-plen+1&lt;&lt; endl;</span>
            <span class="hljs-comment">//k = -1;//重新初始化，寻找下一个</span>
            <span class="hljs-comment">//i = i - plen + 1;//i定位到该位置，外层for循环i++可以继续找下一个（这里默认存在两个匹配字符串可以部分重叠），感谢评论中同学指出错误。</span>
            <span class="hljs-keyword">return</span> i-plen+<span class="hljs-number">1</span>;<span class="hljs-comment">//返回相应的位置</span>
        }
    }
    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;  
}</code></pre> 
<p>这玩意真的不好解释，简单说一下： <br> 从代码解释复杂度是一件比较难的事情，我们从 <br> <img src="https://images2.imgbox.com/65/db/k9Xd6leM_o.jpg" alt="这里写图片描述" title=""></p> 
<p>这个图来解释。</p> 
<p>我们可以看到，匹配串每次往前移动，都是一大段一大段移动，假设匹配串里不存在重复的前缀和后缀，即next的值都是-1，那么每次移动其实就是一整个匹配串往前移动m个距离。然后重新一一比较，这样就比较m次，概括为，移动m距离，比较m次，移到末尾，就是比较n次，O(n)复杂度。 假设匹配串里存在重复的前缀和后缀，我们移动的距离相对小了点，但是比较的次数也小了，整体代价也是O(n)。 <br> 所以复杂度是一个线性的复杂度。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/1926774e597a0bdafd679a1bc335d60a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">用OpenSSL编写SSL,TLS程序（1）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d54d8b7e861d6cfa3ec0de685aa80e64/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Photoshop常用技能</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>