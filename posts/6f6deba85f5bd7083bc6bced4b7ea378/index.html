<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>探索Gin框架：快速构建高性能的Golang Web应用 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="探索Gin框架：快速构建高性能的Golang Web应用" />
<meta property="og:description" content="前言 Gin框架是一个轻量级的Web框架，基于Go语言开发，旨在提供高性能和简洁的API。它具有快速的路由和中间件支持，使得构建Web应用变得更加简单和高效。无论是构建小型的API服务还是大型的Web应用，Gin框架都能够满足你的需求。
无论你是一个有经验的开发者，还是一个刚刚入门的初学者，本文都将为你提供清晰的指导和实用的示例代码。无论你是想构建一个简单的API服务，还是一个复杂的Web应用，Gin框架都能够帮助你快速实现你的想法。
目录 ​编辑
前言
适用人群
构建第一个Gin应用
1.下载并安装Gin
2.项目导入
3.快速使用示例
路由和中间件
API路由配置
路由分组
静态文件路由设置
静态路径映射
静态文件路由
路由中间件
优雅封装
Gin客户端初始化
定义api路由
在项目入口启动Gin服务
总结
适用人群 懂得安装 Go 环境及其基本语法会使用 Go Modules 管理项目 构建第一个Gin应用 1.下载并安装Gin go get -u github.com/gin-gonic/gin 2.项目导入 import &#34;github.com/gin-gonic/gin&#34; 3.快速使用示例 package main import &#34;github.com/gin-gonic/gin&#34; func main() { r := gin.Default() r.GET(&#34;/ping&#34;, func(c *gin.Context) { c.JSON(200, gin.H{ &#34;message&#34;: &#34;pong&#34;, }) }) r.Run() // 监听并在 0.0.0.0:8080 上启动服务 } 路由和中间件 API路由配置 Gin的API路由配置相当简单，只需要调用对应请求方式的方法，设置请求路径，与请求函数即可" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/6f6deba85f5bd7083bc6bced4b7ea378/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-24T19:14:03+08:00" />
<meta property="article:modified_time" content="2024-01-24T19:14:03+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">探索Gin框架：快速构建高性能的Golang Web应用</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2 id="%E2%80%8B%E7%BC%96%E8%BE%91"><img alt="" height="771" src="https://images2.imgbox.com/ed/f7/oUzfd3Ye_o.png" width="1135"></h2> 
<h2 id="%E5%89%8D%E8%A8%80">前言</h2> 
<p><img alt="" height="80" src="https://images2.imgbox.com/16/01/dpbJRRba_o.png" width="640"></p> 
<p><img alt="" height="798" src="https://images2.imgbox.com/bc/e4/KCvtuuel_o.png" width="1200"></p> 
<p>        Gin框架是一个轻量级的Web框架，基于Go语言开发，旨在提供高性能和简洁的API。它具有快速的路由和中间件支持，使得构建Web应用变得更加简单和高效。无论是构建小型的API服务还是大型的Web应用，Gin框架都能够满足你的需求。</p> 
<p>        无论你是一个有经验的开发者，还是一个刚刚入门的初学者，本文都将为你提供清晰的指导和实用的示例代码。无论你是想构建一个简单的API服务，还是一个复杂的Web应用，Gin框架都能够帮助你快速实现你的想法。</p> 
<h3 id="main-toc"><strong>目录</strong></h3> 
<p id="%E2%80%8B%E7%BC%96%E8%BE%91-toc" style="margin-left:0px;"><a href="#%E2%80%8B%E7%BC%96%E8%BE%91" rel="nofollow">​编辑</a></p> 
<p id="%E5%89%8D%E8%A8%80-toc" style="margin-left:0px;"><a href="#%E5%89%8D%E8%A8%80" rel="nofollow">前言</a></p> 
<p id="%E9%80%82%E7%94%A8%E4%BA%BA%E7%BE%A4-toc" style="margin-left:0px;"><a href="#%E9%80%82%E7%94%A8%E4%BA%BA%E7%BE%A4" rel="nofollow">适用人群</a></p> 
<p id="%E6%9E%84%E5%BB%BA%E7%AC%AC%E4%B8%80%E4%B8%AAGin%E5%BA%94%E7%94%A8-toc" style="margin-left:0px;"><a href="#%E6%9E%84%E5%BB%BA%E7%AC%AC%E4%B8%80%E4%B8%AAGin%E5%BA%94%E7%94%A8" rel="nofollow">构建第一个Gin应用</a></p> 
<p id="1.%E4%B8%8B%E8%BD%BD%E5%B9%B6%E5%AE%89%E8%A3%85Gin-toc" style="margin-left:80px;"><a href="#1.%E4%B8%8B%E8%BD%BD%E5%B9%B6%E5%AE%89%E8%A3%85Gin" rel="nofollow">1.下载并安装Gin</a></p> 
<p id="2.%E9%A1%B9%E7%9B%AE%E5%AF%BC%E5%85%A5-toc" style="margin-left:80px;"><a href="#2.%E9%A1%B9%E7%9B%AE%E5%AF%BC%E5%85%A5" rel="nofollow">2.项目导入</a></p> 
<p id="3.%E5%BF%AB%E9%80%9F%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B-toc" style="margin-left:80px;"><a href="#3.%E5%BF%AB%E9%80%9F%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B" rel="nofollow">3.快速使用示例</a></p> 
<p id="%E8%B7%AF%E7%94%B1%E5%92%8C%E4%B8%AD%E9%97%B4%E4%BB%B6-toc" style="margin-left:0px;"><a href="#%E8%B7%AF%E7%94%B1%E5%92%8C%E4%B8%AD%E9%97%B4%E4%BB%B6" rel="nofollow">路由和中间件</a></p> 
<p id="API%E8%B7%AF%E7%94%B1%E9%85%8D%E7%BD%AE-toc" style="margin-left:40px;"><a href="#API%E8%B7%AF%E7%94%B1%E9%85%8D%E7%BD%AE" rel="nofollow">API路由配置</a></p> 
<p id="%E8%B7%AF%E7%94%B1%E5%88%86%E7%BB%84-toc" style="margin-left:40px;"><a href="#%E8%B7%AF%E7%94%B1%E5%88%86%E7%BB%84" rel="nofollow">路由分组</a></p> 
<p id="%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6%E8%B7%AF%E7%94%B1%E8%AE%BE%E7%BD%AE-toc" style="margin-left:40px;"><a href="#%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6%E8%B7%AF%E7%94%B1%E8%AE%BE%E7%BD%AE" rel="nofollow">静态文件路由设置</a></p> 
<p id="%E9%9D%99%E6%80%81%E8%B7%AF%E5%BE%84%E6%98%A0%E5%B0%84-toc" style="margin-left:80px;"><a href="#%E9%9D%99%E6%80%81%E8%B7%AF%E5%BE%84%E6%98%A0%E5%B0%84" rel="nofollow">静态路径映射</a></p> 
<p id="%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6%E8%B7%AF%E7%94%B1-toc" style="margin-left:80px;"><a href="#%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6%E8%B7%AF%E7%94%B1" rel="nofollow">静态文件路由</a></p> 
<p id="-toc" style="margin-left:40px;"></p> 
<p id="%E8%B7%AF%E7%94%B1%E4%B8%AD%E9%97%B4%E4%BB%B6-toc" style="margin-left:40px;"><a href="#%E8%B7%AF%E7%94%B1%E4%B8%AD%E9%97%B4%E4%BB%B6" rel="nofollow">路由中间件</a></p> 
<p id="%E4%BC%98%E9%9B%85%E5%B0%81%E8%A3%85-toc" style="margin-left:0px;"><a href="#%E4%BC%98%E9%9B%85%E5%B0%81%E8%A3%85" rel="nofollow">优雅封装</a></p> 
<p id="Gin%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%88%9D%E5%A7%8B%E5%8C%96-toc" style="margin-left:40px;"><a href="#Gin%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%88%9D%E5%A7%8B%E5%8C%96" rel="nofollow">Gin客户端初始化</a></p> 
<p id="%E5%AE%9A%E4%B9%89api%E8%B7%AF%E7%94%B1-toc" style="margin-left:40px;"><a href="#%E5%AE%9A%E4%B9%89api%E8%B7%AF%E7%94%B1" rel="nofollow">定义api路由</a></p> 
<p id="%E5%9C%A8%E9%A1%B9%E7%9B%AE%E5%85%A5%E5%8F%A3%E5%90%AF%E5%8A%A8Gin%E6%9C%8D%E5%8A%A1-toc" style="margin-left:40px;"><a href="#%E5%9C%A8%E9%A1%B9%E7%9B%AE%E5%85%A5%E5%8F%A3%E5%90%AF%E5%8A%A8Gin%E6%9C%8D%E5%8A%A1" rel="nofollow">在项目入口启动Gin服务</a></p> 
<p id="%E6%80%BB%E7%BB%93-toc" style="margin-left:0px;"><a href="#%E6%80%BB%E7%BB%93" rel="nofollow">总结</a></p> 
<hr id="hr-toc"> 
<p></p> 
<p><img alt="" height="80" src="https://images2.imgbox.com/5a/da/nVc6WWvy_o.png" width="640"></p> 
<h2 id="%E9%80%82%E7%94%A8%E4%BA%BA%E7%BE%A4">适用人群</h2> 
<ul><li>懂得安装 Go 环境及其基本语法</li><li>会使用 Go Modules 管理项目</li></ul> 
<h2 id="%E6%9E%84%E5%BB%BA%E7%AC%AC%E4%B8%80%E4%B8%AAGin%E5%BA%94%E7%94%A8">构建第一个Gin应用</h2> 
<h4 id="1.%E4%B8%8B%E8%BD%BD%E5%B9%B6%E5%AE%89%E8%A3%85Gin">1.下载并安装Gin</h4> 
<pre><code class="language-Go">go get -u github.com/gin-gonic/gin</code></pre> 
<h4 id="2.%E9%A1%B9%E7%9B%AE%E5%AF%BC%E5%85%A5">2.项目导入</h4> 
<pre><code class="language-Go">import "github.com/gin-gonic/gin"</code></pre> 
<h4 id="3.%E5%BF%AB%E9%80%9F%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B">3.快速使用示例</h4> 
<pre><code class="language-Go">package main

import "github.com/gin-gonic/gin"

func main() {
	r := gin.Default()
	r.GET("/ping", func(c *gin.Context) {
		c.JSON(200, gin.H{
			"message": "pong",
		})
	})
	r.Run() // 监听并在 0.0.0.0:8080 上启动服务
}</code></pre> 
<h2 id="%E8%B7%AF%E7%94%B1%E5%92%8C%E4%B8%AD%E9%97%B4%E4%BB%B6">路由和中间件</h2> 
<h3 id="API%E8%B7%AF%E7%94%B1%E9%85%8D%E7%BD%AE">API路由配置</h3> 
<p>Gin的API路由配置相当简单，只需要调用对应请求方式的方法，设置请求路径，与请求函数即可</p> 
<pre><code class="language-Go">router.GET("/ping", func(c *gin.Context) {
		c.JSON(200, gin.H{
			"message": "pong",
		})
	})</code></pre> 
<h3 id="%E8%B7%AF%E7%94%B1%E5%88%86%E7%BB%84">路由分组</h3> 
<p>我们可通过Group方法设置路由分组</p> 
<pre><code class="language-Go">// 可使用Group方法设置路由分组
userGroup := router.Group("/user")
// 该接口实际路径为/user/register
userGroup.POST("/register", controller.UserController.Register)
userGroup.POST("/login", controller.UserController.Login)</code></pre> 
<h3 id="%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6%E8%B7%AF%E7%94%B1%E8%AE%BE%E7%BD%AE">静态文件路由设置</h3> 
<h4 id="%E9%9D%99%E6%80%81%E8%B7%AF%E5%BE%84%E6%98%A0%E5%B0%84">静态路径映射</h4> 
<p>router.Static允许我们指定路径映射，如下，当我们访问路径为localhost:8080/storage时，实际上是访问到localhost:8080/storage/app/public</p> 
<pre><code class="language-Go">//当访问路径为localhost:8080/storage时，实际上是访问到localhost:8080/storage/app/public
router.Static("/storage", "./storage/app/public")</code></pre> 
<h4 id="%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6%E8%B7%AF%E7%94%B1">静态文件路由</h4> 
<p>设置静态文件夹路由</p> 
<pre><code class="language-Go">router.Static("/assets", "./assets")</code></pre> 
<p>设置静态文件路由</p> 
<pre><code class="language-Go">router.StaticFile("/favicon.ico", "./resources/favicon.ico")</code></pre> 
<h3></h3> 
<h3 id="%E8%B7%AF%E7%94%B1%E4%B8%AD%E9%97%B4%E4%BB%B6">路由中间件</h3> 
<p>使用use方法可使用gin自带的中间件或者自定义的中间件</p> 
<p>我们这里自定义中间件函数，返回类型需为gin.HandlerFunc，这里我们定义三个常用的中间件作为示例</p> 
<p>跨域处理中间件</p> 
<pre><code class="language-Go">// 跨域处理中间件
func Cors() gin.HandlerFunc {
    config := cors.DefaultConfig()
    config.AllowAllOrigins = true
    config.AllowHeaders = []string{"Origin", "Content-Length", "Content-Type", "Authorization"}
    config.AllowCredentials = true
    config.ExposeHeaders = []string{"New-Token", "New-Expires-In", "Content-Disposition"}
    return cors.New(config)
}</code></pre> 
<p>登录认证中间件，这里使用的是JWT认证</p> 
<pre><code class="language-Go">// JWTAuth JWT 鉴权中间件
func JWTAuth(GuardName string) gin.HandlerFunc {
	return func(c *gin.Context) {
		// Token 获取
		tokenStr := c.Request.Header.Get("Authorization")
		if tokenStr == "" {
			response.TokenFail(c)
			c.Abort() // 终止请求
			return
		}
		tokenStr = tokenStr[len(service.TokenType)+1:]
		// Token 解析校验
		token, err := jwt.ParseWithClaims(tokenStr, &amp;service.CustomClaims{}, func(token *jwt.Token) (interface{}, error) {
			return []byte(global.App.Config.Jwt.Secret), nil
		})
		// Token 黑名单校验
		if err != nil || service.JwtService.IsInBlacklist(tokenStr) {
			response.TokenFail(c)
			c.Abort()
			return
		}
		// Token 发布者校验和过期校验
		claims := token.Claims.(*service.CustomClaims)
		if claims.Issuer != GuardName || !token.Valid {
			response.TokenFail(c)
			c.Abort()
			return
		}
		// token 续签
		if claims.ExpiresAt.Time.Unix()-time.Now().Unix() &lt; global.App.Config.Jwt.RefreshGracePeriod {
			lock := global.Lock("refresh_token_lock", global.App.Config.Jwt.JwtBlacklistGracePeriod)
			if lock.Get() {
				err, user := service.JwtService.GetUserInfo(GuardName, claims.ID)
				if err != nil {
					global.App.Log.Error(err.Error())
					lock.Release()
				} else {
					tokenData, _, _ := service.JwtService.CreateToken(GuardName, user)
					c.Header("new-token", tokenData.AccessToken)
					c.Header("new-expires-in", strconv.Itoa(tokenData.ExpiresIn))
					_ = service.JwtService.JoinBlackList(token)
				}
			}
		}
		//将token信息和id信息存入上下文
		c.Set("token", token)
		c.Set("id", claims.ID)
	}
}</code></pre> 
<p>gin自带的Recovery中间件默认日志是是打印在控制台的，故使用自定义Recovery中间件来自定义日志输出方式</p> 
<p>这些配置信息根据自己情况调整，这里我是通过viper读取配置到全局变量中，后面我应该会出文讲解Go使用Viper读取配置</p> 
<pre><code class="language-Go">// CustomRecovery 进行程序的恢复（防止程序因 panic 而终止）和记录错误日志的中间件
func CustomRecovery() gin.HandlerFunc {
    // 开启程序的恢复，并将错误日志写入到指定的日志文件中
    return gin.RecoveryWithWriter(
       &amp;lumberjack.Logger{
          // 日志文件名
          Filename:   global.App.Config.Log.RootDir + "/" + global.App.Config.Log.Filename,
          // 文件最大大小
          MaxSize:    global.App.Config.Log.MaxSize,
          // 旧文件的最大个数
          MaxBackups: global.App.Config.Log.MaxBackups,
          // 旧文件的最大保留天数
          MaxAge:     global.App.Config.Log.MaxAge,
          // 是否压缩
          Compress:   global.App.Config.Log.Compress,
       },
       response.ServerError)
}</code></pre> 
<p>挂载自定义的中间件，需要注意使用中间件的顺序，gin.Logger()中间件需要放在其他中间件前面，不然可能导致middleware.CustomRecovery()中的日志无法正常使用</p> 
<pre><code class="language-Go">router := gin.New()
router.Use(gin.Logger(), middleware.Cors(), middleware.CustomRecovery())</code></pre> 
<h2 id="%E4%BC%98%E9%9B%85%E5%B0%81%E8%A3%85">优雅封装</h2> 
<p>接下来我们优雅的封装Gin的大部分使用</p> 
<h3 id="Gin%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%88%9D%E5%A7%8B%E5%8C%96">Gin客户端初始化</h3> 
<p>我们在RunServer()方法中实现了优雅地关闭服务器，当关闭服务器时，如果有请求未结束，会等待5秒，5秒后再关闭服务器</p> 
<pre><code class="language-Go">// bootstrap/Router.go
package bootstrap
import (
	"context"
	"github.com/gin-gonic/gin"
	swaggerfiles "github.com/swaggo/files"
	ginSwagger "github.com/swaggo/gin-swagger"
	"log"
	"net/http"
	_ "online-practice-system/docs"
	"online-practice-system/global"
	"online-practice-system/internal/middleware"
	"online-practice-system/routes"
	"os"
	"os/signal"
	"syscall"
	"time"
)
// 初始化路由
func setupRouter() *gin.Engine {
	if global.App.Config.App.Env == "production" {
		gin.SetMode(gin.ReleaseMode)
	}
	router := gin.New()
	router.Use(gin.Logger(), middleware.Cors(), middleware.CustomRecovery())
	// 前端项目静态资源
	router.Static("/storage", "./storage/app/public")
	// Swagger 配置
	router.GET("/swagger/*any", ginSwagger.WrapHandler(swaggerfiles.Handler))
	// 注册 api 分组路由
	apiGroup := router.Group("/api")
	routes.SetUserGroupRoutes(apiGroup)
	return router
}
// RunServer 启动服务器
func RunServer() {
	r := setupRouter()
	//创建一个 http.Server 对象 srv，其中指定服务器的监听地址和路由处理器为之前设置的路由 r
	srv := &amp;http.Server{
		Addr:    ":" + global.App.Config.App.Port,
		Handler: r,
	}
	//使用 srv.ListenAndServe() 方法来异步启动服务器。
	go func() {
		if err := srv.ListenAndServe(); err != nil &amp;&amp; err != http.ErrServerClosed {
			global.App.Log.Fatal("服务器启动失败：" + err.Error())
		}
	}()
	// 等待中断信号以优雅地关闭服务器（设置 5 秒的超时时间）, 当收到中断信号时，会触发 quit 通道，从而执行后续的关闭服务器操作。
	quit := make(chan os.Signal)
	//Notify函数让signal包将输入的中断信号 SIGINT 或终止信号 SIGTERM 转发到通道quit
	signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
	//收到信号后，会执行下面的代码，首先打印日志，然后调用 srv.Shutdown() 方法来关闭服务器。
	&lt;-quit
	log.Println("Shutdown Server ...")
	//创建一个带有超时的上下文 ctx，超时时间设置为 5 秒
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()
	//调用 srv.Shutdown() 方法来关闭服务器，此时会触发 http.Server 的关闭事件，从而退出阻塞
	if err := srv.Shutdown(ctx); err != nil {
		global.App.Log.Fatal("服务器关闭时出现错误：" + err.Error())
	}
	global.App.Log.Fatal("服务器顺利关闭~~~")
}</code></pre> 
<h3 id="%E5%AE%9A%E4%B9%89api%E8%B7%AF%E7%94%B1">定义api路由</h3> 
<pre><code class="language-Go">// api/Router.go
package routes
import (
	"github.com/gin-gonic/gin"
	"online-practice-system/internal/controller"
	"online-practice-system/internal/middleware"
	"online-practice-system/internal/service"
)
// SetUserGroupRoutes 定义 User 分组路由
func SetUserGroupRoutes(router *gin.RouterGroup) {
	userGroup := router.Group("/user")
	userGroup.POST("/register", controller.UserController.Register)
	userGroup.POST("/login", controller.UserController.Login)
	//使用 JWTAuth 鉴权中间件
	authRouter := userGroup.Use(middleware.JWTAuth(service.AppGuardName))
	{
		authRouter.GET("/userInfo", controller.UserController.GetUserInfo)
		authRouter.GET("/logout", controller.UserController.UserLogout)
		authRouter.POST("/image_upload", controller.UploadController.ImageUpload)
		authRouter.GET("/image_get_url/:id", controller.UploadController.GetUrlById)
	}
}</code></pre> 
<h3 id="%E5%9C%A8%E9%A1%B9%E7%9B%AE%E5%85%A5%E5%8F%A3%E5%90%AF%E5%8A%A8Gin%E6%9C%8D%E5%8A%A1">在项目入口启动Gin服务</h3> 
<pre><code class="language-Go">package main

import (
	"online-practice-system/bootstrap"
)

func main() {
	// 启动gin web服务器
	bootstrap.RunServer()
}</code></pre> 
<p></p> 
<h2 id="%E6%80%BB%E7%BB%93">总结</h2> 
<p>        感谢您的观看，如果您对gin的使用感兴趣的可以看看我几个月前搭建的go web脚手架，使用了一些主流的开发框架，虽然可能部分设计不是很合理，但是对于我个人来说搭建一般的web项目还是足够了。未使用go-wire的版本：<a href="https://gitee.com/liushijie-kitie/go-web-starter" rel="nofollow" title="go-web-starter: 基于gin，form框架的web开发脚手架 (gitee.com)">go-web-starter: 基于gin，form框架的web开发脚手架 (gitee.com)</a>，使用了go-wire进行全局依赖注入的改造版：<a href="https://gitee.com/liushijie-kitie/go-web-wire-starter" rel="nofollow" title="go-web-wire-starter: 使用go-wire框架与gin框架搭建的web开发脚手架，有助于web开发者快速开发curd操作，以及学习go-wire框架的工程化实践 (gitee.com)">go-web-wire-starter: 使用go-wire框架与gin框架搭建的web开发脚手架，有助于web开发者快速开发curd操作，以及学习go-wire框架的工程化实践 (gitee.com)</a></p> 
<p>实现的功能有如下：</p> 
<p>• 配置统一管理</p> 
<p>• Jwt令牌生成，校验，续签，黑名单</p> 
<p>• 定时任务</p> 
<p>• 文件存储（支持本地，七牛云Kodo，阿里云Oss，腾讯云Cos等存储服务，支持扩展）</p> 
<p>• 分布式锁</p> 
<p>• 限流器（基于令牌桶算法）</p> 
<p>• 邮件服务</p> 
<p>• 自定义命令行命令（代码中以数据库迁移migrate命令为示例）</p> 
<p>使用的技术栈如下图：</p> 
<p><img alt="" height="632" src="https://images2.imgbox.com/7b/10/sKtIc47k_o.png" width="843"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/352b4d591397732fca53aa51a2021127/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">docker: 搭建 harbor 镜像仓库</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5dac9a66574e5a8ea630d490be1925e8/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">设计模式三(原型模式)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>