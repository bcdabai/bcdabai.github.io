<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>你一定要了解的Kubernetes - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="你一定要了解的Kubernetes" />
<meta property="og:description" content="前言 随着容器技术的发展，Docker近几年突然崛起，变得炙手可热，已经成为容器技术的事实标准。然而想要在生成环境中成功部署和操作容器的关键是容器编排技术，市场上有各种各样的容器编排工具（如Docker原生的Swarm），其中谷歌公司开发的Kubernetes得到开源社区的全力支持，IBM、惠普、微软、RedHat等业界巨头纷纷加入，Kubernetes已经成为GitHub上的明星开源项目。 简介 Kubernetes这个名字源于希腊语，是舵手的意思，所以它的Logo既像一张渔网，又像一个罗盘。有意思的是Docker的Logo为驮着集装箱在大海上遨游的鲸鱼，Kubernetes与Docker的关系可见一斑。
[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-mvXVtVZH-1587721676743)(https://img-blog.csdn.net/20180116211103919?)] Kubernetes（也常称K8s，用8代替8个字符“ubernete”而成的缩写。）是一个全新的基于容器技术的分布式架构方案，它源自Google内部大规模集群管理系统——Borg，也是CNCF（Cloud Native Computing Foundation，今属Linux基金会）最重要的项目之一，旨在让部署容器化的应用简单并且高效。
Kubernetes 具备完善的集群管理能力，包括多层次的安全防护和准入机制、多租户应用支撑能力、透明的服务注册和服务发现机制、内建负载均衡器、故障发现和自我修复能力、服务滚动升级和在线扩容、可扩展的资源自动调度机制、多粒度的资源配额管理能力。还提供完善的管理工具，涵盖开发、部署测试、运维监控等各个环节。
Kubernetes 于2015年7月22日迭代到 v 1.0并正式对外公布，截至2018年1月5日稳定版已经发布到 v.1.9.1。无论是英文还是中文社区都非常活跃，全球开源解决方案领导者 RedHat 公司已经将自己Paas产品OpenShift V3 的底层技术换成了Kubernetes与Docker。Kubernetes俨然已经成为全新容器生态的领导者。
架构 Kubernetes使用Go语言开发，集群采用 Master/Node（最初称为Minion，后改名Node） 的结构，Master（主节点）控制整个集群，Node（从节点）为集群提供计算能力。用户可以通过命令行或者Web页面的方式来操作集群。 Master是Kubernetes集群的大脑，负责公开集群的API，调度部署和管理整个集群。集群至少有一个Master节点，如果在生产环境中要达到高可用，还需要配置Master集群。
Master主要包含API Server、Scheduler、Controller三个组件，需要etcd组件来保存整个集群的状态。
**etcd：**由CoreOS开发，是一个高可用、强一致性的服务发现存储仓库，为Kubernetes集群提供存储服务，类似于zookeper。
API Server： kubernetes最重要的核心组件之一，提供资源操作的唯一入口（其他模块通过API Server查询或修改数据，只有API Server才直接操作etcd），并提供认证、授权、访问控制、API注册和发现等机制。
**Scheduler：**负责资源的调度，按照预定的调度策略将Pod（k8s中调度的基本单位）调度到相应的Node上。
**Controller：**通过API Server来监控整个集群的状态，并确保集群处于预期的工作状态，比如故障检测、自动扩展、滚动更新等。
Node是Kubernetes集群的工作节点，可以是物理机也可以是虚拟机。Node需要包含容器、kubelet、kube-proxy等组件。Fluentd用来提供日志收集功能（可选）。
**kubelet：**维护容器的生命周期，同时也负责Volume（CVI）和网络（CNI）的管理。每个节点上都会运行一个kubelet服务进程，接收并执行Master发来的指令，管理Pod及Pod中的容器。每个kubelet进程会在API Server上注册节点自身信息，定期向Master节点汇报节点的资源使用情况，并通过cAdvisor监控节点和容器的资源。
kube-proxy： 为 Service 提供集群内部的服务发现和负载均衡，监听 API Server 中 service和endpoint的变化情况，并通过iptables等方式来为服务配置负载均衡。
Docker： 每台Node上需要安装Docker来运行镜像，但是Docker不是唯一选择，Kubernetes支持多种容器，比如CoreOS公司的Rkt容器（之前称为Rocket，现更名为Rkt）。
资源对象 API对象是Kubernetes集群中的管理操作单元。集群中的众多技术概念分别对应着API对象，每个API对象都有3大类属性：
metadata（元数据）：用来标识API对象，包含namespace、name、uid等。
spec （规范）：描述用户期望达到的理想状态，所有的操作都是声明式（Declarative）的而不是命令式（Imperative），在分布式系统中的好处是稳定，不怕丢操作或运行多次。比如设置期望3个运行Nginx的pod，运行多次也还是一个结果，而给副本数加1的操作就不是声明式的，运行多次结果就错了。
status（状态）：描述系统当前实际达到的状态，比如期望3个pod，现在实际创建好了2个。
在Kubernetes众多的API对象中，Pod是最重要的也是最基础的，是kubernetes中可以创建的最小部署单元。Pod就像是豌豆荚一样，它可以由一个或者多个容器组成，这些容器共享存储、网络和配置项。
目前Kubernetes中的业务类型可以分为长期伺服型（long-running）、批处理型（batch）、节点后台支撑型（node-daemon）和有状态应用型（stateful application）这四种类型，而这四种类型的业务又可以由不同类型的Pod控制器来完成，分别为：Deployment、Job、DaemonSet和StatefulSet。
Deployment： 复制控制器（Replication Controller，RC）是集群中最早的保证Pod高可用的API对象，副本集（Replica Set，RS）是它的升级，能支持更多种类的匹配模式。部署(Deployment)又是比RS应用模式更广的API对象，以Kubernetes的发展方向，未来对所有长期伺服型的的业务的管理，都会通过Deployment来管理。
Service： Deployment保证了Pod的数量，但是没有解决如何访问Pod的问题，一个Pod只是一个运行服务的实例，随时可能在一个节点上停止，在另一个节点以一个新的IP启动一个新的Pod，因此不能以确定的IP和端口号提供服务。要稳定地提供服务需要服务发现和负载均衡能力，Service可以稳定为用户提供服务。
Job： 用来控制批处理型任务，Job管理的Pod根据用户的设置把任务成功完成就自动退出了。
DaemonSet： 后台支撑型服务的核心关注点在集群中的Node，要保证每个Node上都有一个此类Pod运行。比如用来收集日志的Pod。
StatefulSet： 不同于RC和RS，StatefulSet主要提供有状态的服务，StatefulSet中Pod的名字都是事先确定的，不能更改，每个Pod挂载自己独立的存储，如果一个Pod出现故障，从其他节点启动一个同样名字的Pod，要挂载上原来Pod的存储继续以它的状态提供服务。比如数据库服务MySQL，我们不希望一个Pod故障后，MySQL中的数据即丢失。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/e0089ff76e8d8072067b8698bc21016e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-04-24T17:48:20+08:00" />
<meta property="article:modified_time" content="2020-04-24T17:48:20+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">你一定要了解的Kubernetes</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <table><tbody><tr><td bgcolor="#35343A"><font size="5" color="white">前言</font></td></tr></tbody></table> 
<br>   随着容器技术的发展，Docker近几年突然崛起，变得炙手可热，已经成为容器技术的事实标准。然而想要在生成环境中成功部署和操作容器的关键是容器编排技术，市场上有各种各样的容器编排工具（如Docker原生的Swarm），其中谷歌公司开发的Kubernetes得到开源社区的全力支持，IBM、惠普、微软、RedHat等业界巨头纷纷加入，Kubernetes已经成为GitHub上的明星开源项目。 
<table><tbody><tr><td bgcolor="#35343A"><font size="5" color="white">简介</font></td></tr></tbody></table> 
<br> 
<p>  Kubernetes这个名字源于希腊语，是舵手的意思，所以它的Logo既像一张渔网，又像一个罗盘。有意思的是Docker的Logo为驮着集装箱在大海上遨游的鲸鱼，Kubernetes与Docker的关系可见一斑。</p> 
<div align="center">
  [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-mvXVtVZH-1587721676743)(https://img-blog.csdn.net/20180116211103919?)] 
</div> 
<p>  Kubernetes（也常称K8s，用8代替8个字符“ubernete”而成的缩写。）是一个全新的基于容器技术的分布式架构方案，它源自Google内部大规模集群管理系统——Borg，也是CNCF（Cloud Native Computing Foundation，今属Linux基金会）最重要的项目之一，旨在让部署容器化的应用简单并且高效。<br>   Kubernetes 具备完善的集群管理能力，包括多层次的安全防护和准入机制、多租户应用支撑能力、透明的服务注册和服务发现机制、内建负载均衡器、故障发现和自我修复能力、服务滚动升级和在线扩容、可扩展的资源自动调度机制、多粒度的资源配额管理能力。还提供完善的管理工具，涵盖开发、部署测试、运维监控等各个环节。</p> 
<div align="center"> 
 <img src="https://images2.imgbox.com/9a/37/R5oAuXYY_o.png" width="650"> 
</div> 
<p>  Kubernetes 于2015年7月22日迭代到 v 1.0并正式对外公布，截至2018年1月5日稳定版已经发布到 v.1.9.1。无论是英文还是中文社区都非常活跃，全球开源解决方案领导者 RedHat 公司已经将自己Paas产品OpenShift V3 的底层技术换成了Kubernetes与Docker。Kubernetes俨然已经成为全新容器生态的领导者。</p> 
<table><tbody><tr><td bgcolor="#35343A"><font size="5" color="white">架构</font></td></tr></tbody></table> 
<br>   Kubernetes使用Go语言开发，集群采用 Master/Node（最初称为Minion，后改名Node） 的结构，Master（主节点）控制整个集群，Node（从节点）为集群提供计算能力。用户可以通过命令行或者Web页面的方式来操作集群。 
<div align="center"> 
 <img src="https://images2.imgbox.com/91/0f/ckeBmJ3j_o.png" width="600"> 
</div> 
<p>  <strong>Master</strong>是Kubernetes集群的大脑，负责公开集群的API，调度部署和管理整个集群。集群至少有一个Master节点，如果在生产环境中要达到高可用，还需要配置Master集群。<br>   Master主要包含API Server、Scheduler、Controller三个组件，需要etcd组件来保存整个集群的状态。</p> 
<ul><li> <p>**etcd：**由CoreOS开发，是一个高可用、强一致性的服务发现存储仓库，为Kubernetes集群提供存储服务，类似于zookeper。</p> </li><li> <p><strong>API Server：</strong> kubernetes最重要的核心组件之一，提供资源操作的唯一入口（其他模块通过API Server查询或修改数据，只有API Server才直接操作etcd），并提供认证、授权、访问控制、API注册和发现等机制。</p> </li><li> <p>**Scheduler：**负责资源的调度，按照预定的调度策略将Pod（k8s中调度的基本单位）调度到相应的Node上。</p> </li><li> <p>**Controller：**通过API Server来监控整个集群的状态，并确保集群处于预期的工作状态，比如故障检测、自动扩展、滚动更新等。</p> </li></ul> 
<div align="center"> 
 <img src="https://images2.imgbox.com/46/ce/kxpWVIQg_o.png" width="600"> 
</div> 
<p>  Node是Kubernetes集群的工作节点，可以是物理机也可以是虚拟机。Node需要包含容器、kubelet、kube-proxy等组件。Fluentd用来提供日志收集功能（可选）。</p> 
<ul><li> <p>**kubelet：**维护容器的生命周期，同时也负责Volume（CVI）和网络（CNI）的管理。每个节点上都会运行一个kubelet服务进程，接收并执行Master发来的指令，管理Pod及Pod中的容器。每个kubelet进程会在API Server上注册节点自身信息，定期向Master节点汇报节点的资源使用情况，并通过cAdvisor监控节点和容器的资源。</p> </li><li> <p><strong>kube-proxy：</strong> 为 Service 提供集群内部的服务发现和负载均衡，监听 API Server 中 service和endpoint的变化情况，并通过iptables等方式来为服务配置负载均衡。</p> </li><li> <p><strong>Docker：</strong> 每台Node上需要安装Docker来运行镜像，但是Docker不是唯一选择，Kubernetes支持多种容器，比如CoreOS公司的Rkt容器（之前称为Rocket，现更名为Rkt）。</p> </li></ul> 
<div align="center"> 
 <img src="https://images2.imgbox.com/4d/b7/xDeRQD4E_o.png" width="600"> 
</div> 
<table><tbody><tr><td bgcolor="#35343A"><font size="5" color="white">资源对象</font></td></tr></tbody></table> 
<br> 
<p>  API对象是Kubernetes集群中的管理操作单元。集群中的众多技术概念分别对应着API对象，每个API对象都有3大类属性：</p> 
<ul><li> <p>metadata（元数据）：用来标识API对象，包含namespace、name、uid等。</p> </li><li> <p>spec （规范）：描述用户期望达到的理想状态，所有的操作都是声明式（Declarative）的而不是命令式（Imperative），在分布式系统中的好处是稳定，不怕丢操作或运行多次。比如设置期望3个运行Nginx的pod，运行多次也还是一个结果，而给副本数加1的操作就不是声明式的，运行多次结果就错了。</p> </li><li> <p>status（状态）：描述系统当前实际达到的状态，比如期望3个pod，现在实际创建好了2个。</p> </li></ul> 
<div align="center"> 
 <img src="https://images2.imgbox.com/3a/a8/rXUikzG5_o.png" width="650"> 
</div> 
<p>  在Kubernetes众多的API对象中，Pod是最重要的也是最基础的，是kubernetes中可以创建的最小部署单元。Pod就像是豌豆荚一样，它可以由一个或者多个容器组成，这些容器共享存储、网络和配置项。</p> 
<p>  目前Kubernetes中的业务类型可以分为长期伺服型（long-running）、批处理型（batch）、节点后台支撑型（node-daemon）和有状态应用型（stateful application）这四种类型，而这四种类型的业务又可以由不同类型的Pod控制器来完成，分别为：<strong>Deployment</strong>、<strong>Job</strong>、<strong>DaemonSet</strong>和<strong>StatefulSet</strong>。</p> 
<ul><li> <p><strong>Deployment：</strong> 复制控制器（Replication Controller，RC）是集群中最早的保证Pod高可用的API对象，副本集（Replica Set，RS）是它的升级，能支持更多种类的匹配模式。部署(Deployment)又是比RS应用模式更广的API对象，以Kubernetes的发展方向，未来对所有长期伺服型的的业务的管理，都会通过Deployment来管理。</p> </li><li> <p><strong>Service：</strong> Deployment保证了Pod的数量，但是没有解决如何访问Pod的问题，一个Pod只是一个运行服务的实例，随时可能在一个节点上停止，在另一个节点以一个新的IP启动一个新的Pod，因此不能以确定的IP和端口号提供服务。要稳定地提供服务需要服务发现和负载均衡能力，Service可以稳定为用户提供服务。</p> </li><li> <p><strong>Job：</strong> 用来控制批处理型任务，Job管理的Pod根据用户的设置把任务成功完成就自动退出了。</p> </li><li> <p><strong>DaemonSet：</strong> 后台支撑型服务的核心关注点在集群中的Node，要保证每个Node上都有一个此类Pod运行。比如用来收集日志的Pod。</p> </li><li> <p><strong>StatefulSet：</strong> 不同于RC和RS，StatefulSet主要提供有状态的服务，StatefulSet中Pod的名字都是事先确定的，不能更改，每个Pod挂载自己独立的存储，如果一个Pod出现故障，从其他节点启动一个同样名字的Pod，要挂载上原来Pod的存储继续以它的状态提供服务。比如数据库服务MySQL，我们不希望一个Pod故障后，MySQL中的数据即丢失。</p> </li></ul> 
<table><tbody><tr><td bgcolor="#35343A"><font size="5" color="white">小结</font></td></tr></tbody></table> 
<br>   事实上，Kubernetes的资源对象不止这些，要熟练的操作Kubernetes并了解其原理还有很长的路要走。本文只是宏观上的介绍了Kubernetes，对于想要了解Kubernetes的朋友是个不错的开始。
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/098b9f714ef9cdab87e6e9af00fb8b6a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">GIS技术在水资源领域的应用与发展</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1e58322b2ae7df80a9f410322fd5d2a6/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">linux虚拟机网络配置之桥接模式</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>