<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>通讯录（静态） - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="通讯录（静态）" />
<meta property="og:description" content="cotact.h #define _CRT_SECURE_NO_WARNINGS 1
#define MAX 100
#define MAXname 20
#define MAXsex 10
#define MAXtre 12
#define MAXaddr 30
#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
#include&lt;assert.h&gt;
#include&lt;stdlib.h&gt;
//类型声明
//人的信息
typedef struct p
{
char name[MAXname];
int age;
char sex[MAXsex];//性别
char tele[MAXtre];//电话
char address[MAXaddr];//地址
}p;//加了typedef,就把结构体类型struct p重命名为了p
//封装一个通讯录（由于data和count都是通讯录的成员，同时变化且变化量相同，所以在头文件中封装，更容易找到）
typedef struct Contact
{
p data[MAX];//存放100个人的信息
int count;//记录当前通讯录中人的实时个数，添加一个&#43;1，删除一个-1
}Contact;
//初始化通讯录
void InitContact(Contact* pc);//由于我们要通过pc指针来改变con的内容，所以不需要&#43;const进行修饰
//增加联系人到通讯录
void AddContact(Contact* pc);
//显示通讯录中的信息
void ShowContact(const Contact*pc);//此处添加const是为了保护con的信息不被改动
//删除指定联系人
void DelContact(const Contact* pc);
//查找指定联系人" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/a2f7b18ae0766f17bc88ae49863372e8/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-03T12:23:17+08:00" />
<meta property="article:modified_time" content="2024-01-03T12:23:17+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">通讯录（静态）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2><strong>cotact.h</strong></h2> 
<p>#define _CRT_SECURE_NO_WARNINGS 1<br> #define  MAX 100<br> #define  MAXname 20<br> #define  MAXsex 10<br> #define  MAXtre 12<br> #define  MAXaddr 30<br> #include&lt;stdio.h&gt;<br> #include&lt;string.h&gt;<br> #include&lt;assert.h&gt;<br> #include&lt;stdlib.h&gt;<br> //类型声明<br> //人的信息<br> typedef struct p<br> {<!-- --><br>     char name[MAXname];<br>     int age;<br>     char sex[MAXsex];//性别<br>     char tele[MAXtre];//电话<br>     char address[MAXaddr];//地址<br> }p;//加了typedef,就把结构体类型struct p重命名为了p<br> //封装一个通讯录（由于data和count都是通讯录的成员，同时变化且变化量相同，所以在头文件中封装，更容易找到）<br> typedef struct Contact<br> {<!-- --><br>     p data[MAX];//存放100个人的信息<br>     int count;//记录当前通讯录中人的实时个数，添加一个+1，删除一个-1<br> }Contact;<br> //初始化通讯录<br> void InitContact(Contact* pc);//由于我们要通过pc指针来改变con的内容，所以不需要+const进行修饰<br> //增加联系人到通讯录<br> void AddContact(Contact* pc);<br> //显示通讯录中的信息<br> void ShowContact(const Contact*pc);//此处添加const是为了保护con的信息不被改动<br> //删除指定联系人<br> void DelContact(const Contact* pc);<br> //查找指定联系人<br> void SearchContact(Contact* pc);<br> //修改指定联系人<br> void ModifyContact(Contact* pc);<br> //排序通讯录中的联系人<br> //按照名字、年龄.......来排序<br> void SortContact(Contact* pc);</p> 
<p></p> 
<h2><strong>test.c</strong></h2> 
<p><br> //实现一个通讯录<br> 人的信息：<br> //名字<br> //年龄<br> //性别<br> //电话<br> //地址</p> 
<p>实现功能：<br> // 存放100个人的信息<br> // 1.增添联系人<br> // 2.删除联系人<br> // 3.查找联系人<br> // 4.修改联系人<br> // 5.显示联系人<br> // 6.联系人排序</p> 
<p>文件构成：<br> //test6.8.c        测试功能<br> //contact.c     通讯录相关功能的实现<br> //contact.h     通讯录相关的声明</p> 
<p>#define _CRT_SECURE_NO_WARNINGS 1<br> #include"contact.h"<br> void menu()<br> {<!-- --><br>     printf("****************************\n");<br>     printf("***  1.add     2.del     ***\n");<br>     printf("***  3.search  4.modify  ***\n");<br>     printf("***  5.show    6.sort    ***\n");<br>     printf("***  0.exit              ***\n");<br>     printf("****************************\n");<br> }<br> int main()<br> {<!-- --><br>     int input = 0;<br>     Contact con;//通讯录<br>     //创建一个函数，初始化通讯录<br>     //为什么不直接初始化，而是借助函数进行初始化。<br>     //1.我们尽量把代码分装成模块的形式，写一个函数来完成此项工作（模块化工作）<br>     //2.如果我们想对通讯录的数据初始化的内容不能通过{}来初始化，我们想用另一种方法初始化或初始化成我们指定的内容，即此时用{}初始化不方便<br>     InitContact(&amp;con);//传参为地址是因为，后续还要对con进行更改，并且结构体传参尽量传地址，这样效率更高（传con，无法对其进行更改）<br>     do<br>     {<!-- --><br>         menu();//菜单<br>         printf("请选择：");<br>         scanf("%d",&amp;input);<br>         switch (input)<br>         {<!-- --><br>         case 1:<br>             AddContact(&amp;con);//结构体传参传地址效率更高<br>             break;<br>         case 2:<br>             DelContact(&amp;con);<br>             break;<br>         case 3:<br>             SearchContact(&amp;con);<br>             break;<br>         case 4:<br>             ModifyContact(&amp;con);<br>             break;<br>         case 5:<br>             ShowContact(&amp;con);<br>             break;<br>         case 6:<br>             SortContact(&amp;con);<br>             break;<br>         case 0:<br>             printf("退出通讯录：\n");<br>             break;<br>         default:<br>             printf("选择错误：\n");<br>             break;<br>         }<br>     } while(input);//输入0，为假，就跳出代码<br>     return 0;<br> }</p> 
<h2><strong>cotact.c</strong></h2> 
<p>#define _CRT_SECURE_NO_WARNINGS 1<br> #include"contact.h"<br> void InitContact(Contact* pc)<br> {<!-- --><br>     assert(pc);<br>     pc-&gt;count = 0;<br>     memset(pc-&gt;data, 0, sizeof(pc-&gt;data));<br>     //memset内存设置函数，将每个字节都进行设置，个数取决于第三个参数sizeof(pc-&gt;data)<br>     //若不是用memset，则需要借助循环进行初始化<br> }<br> //增添<br> void AddContact(Contact* pc)<br> {<!-- --><br>     assert(pc);<br>     if (pc-&gt;count == MAX)<br>     {<!-- --><br>         printf("通讯录已满，无法添加\n");<br>         return 0;<br>     }<br>     printf("请输入名字：");<br>     scanf("%s",pc-&gt;data[pc-&gt;count].name);//scanf中，需要将数据输入到地址中，而name为数组，本身就是地址，所以不需要&amp;<br>     printf("请输入年龄：");<br>     scanf("%d", &amp;(pc-&gt;data[pc-&gt;count].age));//而age为变量，因此想要更改其值就要使用其地址，即&amp;age<br>     printf("请输入性别：");<br>     scanf("%s", pc-&gt;data[pc-&gt;count].sex);<br>     printf("请输入电话：");<br>     scanf("%s", pc-&gt;data[pc-&gt;count].tele);<br>     printf("请输入地址：");<br>     scanf("%s", pc-&gt;data[pc-&gt;count].address);<br>     pc-&gt;count++;//此联系人添加完，就轮到下一个人<br>     printf("增加成功");<br> }<br> //显示<br> void ShowContact(const Contact* pc)<br> {<!-- --><br>     assert(pc);<br>     int i = 0;<br>     printf("%-20s\t%-5s\t%-5s\t%-12s\t%-30s\n", "名字", "年龄", "性别", "电话","地址");//由于1个汉字占2个字符<br>     //左对齐让占位符前面的数字为负数即可<br>     for (i = 0; i &lt; pc-&gt;count; i++)<br>     {<!-- --><br>         printf("%-20s\t%-5d\t%-5s\t%-12s\t%-30s\n",pc-&gt;data[i].name<br>                                              , pc-&gt;data[i].age<br>                                              , pc-&gt;data[i].sex<br>                                              , pc-&gt;data[i].tele<br>                                              , pc-&gt;data[i].address);//\t:水平制表符，让其空开<br>     }<br> }<br> //此程序所有的信息只存于内存中，不能长时间保存，要长时间保存需要放在数据库中！！！！<br> static int Fingbyname(Contact* pc, char name[])//此处添加static会让此函数声明仅能在contact.c文件中看到。<br> //该函数未在头文件声明是为了不想让别人看到。并且后续功能的实现还需要此函数<br> {<!-- --><br>     assert(pc);<br>     int i = 0;<br>     for (i = 0; i &lt; pc-&gt;count; i++)<br>     {<!-- --><br>         if (0 == strcmp(pc-&gt;data[i].name, name))<br>         {<!-- --><br>             return i;//找到了，返回其下标<br>         }<br>     }<br>     //由于函数返回类型为int，所以就不再设置else，返回-1了，直接作为函数返回值<br>     return -1;<br> }<br> //删除<br> void DelContact(Contact* pc)<br> {<!-- --><br>     char name[MAXname] = {0};<br>     int i = 0;<br>     assert(pc);<br>     if (pc-&gt;count == 0)<br>     {<!-- --><br>         printf("通讯录为空，没有信息可删除：");<br>         return;<br>     }<br>     printf("q请输入要删除人的名字:");<br>     scanf("%s",name);<br>     //删除之前，要先查找，再删除<br>     //1.查找<br>     int n=Fingbyname(pc,name);//找不到返回-1，即n就相当于下标<br>     if (n == -1)<br>     {<!-- --><br>         printf("要删除的人不存在：");<br>         return;//退出该函数<br>     }<br>     //2.删除(要将此位置为空的地方，存放后续添加的联系人)<br>     for (i = n; i &lt; pc-&gt;count-1; i++)<br>     {<!-- --><br>         //加入现在有100个人的信息，即count=100，i=99，+1=100，而下标最大为99（就已经是最后一个元素，再大就越界了）<br>         //所以for语句中pc-&gt;count要-1，避免越界，也刚好满足条件<br>         pc-&gt;data[i] = pc-&gt;data[i + 1];<br>     }//若删除最后一个元素，就相当于最后一个元素的后面的一个元素进行覆盖，相当于没覆盖，最后一个元素覆不覆盖无所谓<br>     pc-&gt;count--;//但是通过pc-&gt;count--，假设100个元素，删除最后一个元素的话，只需要count--，我们最后一个元素不覆盖也可以，count--为99，最后一个元素我们也访问不到，因为我们是拿count来访问我们的数据的<br>     printf("删除成功！！！");<br> }<br> //查找<br> void SearchContact(Contact* pc)<br> {<!-- --><br>     assert(pc);<br>     char name[MAXname] = {0};<br>     printf("请输入要要查找人的名字:");<br>     scanf("%s", name);<br>     //1.查找<br>     int n = Fingbyname(pc, name);<br>     if (n == -1)<br>     {<!-- --><br>         printf("要查找的人不存在！！！");<br>         return;//找不到就返回<br>     }<br>     else//(找到了，打印出来)<br>     {<!-- --><br>         printf("%-20s\t%-5s\t%-5s\t%-12s\t%-30s\n", "名字", "年龄", "性别", "电话", "地址");//由于1个汉字占2个字符<br>         //左对齐让占位符前面的数字为负数即可<br>         printf("%-20s\t%-5d\t%-5s\t%-12s\t%-30s\n", pc-&gt;data[n].name<br>                 , pc-&gt;data[n].age<br>                 , pc-&gt;data[n].sex<br>                 , pc-&gt;data[n].tele<br>                 , pc-&gt;data[n].address);<br>     }<br> }<br> //修改<br> void ModifyContact(Contact* pc)<br> {<!-- --><br>     assert(pc);<br>     char name[MAXname] = { 0 };<br>     printf("请输入要修改人的名字:");<br>     scanf("%s", name);<br>     //1.查找<br>     int n = Fingbyname(pc, name);<br>     if (n == -1)<br>     {<!-- --><br>         printf("要修改的人不存在！！！");<br>         return;//找不到就返回<br>     }<br>     printf("要修改的联系人已经查找到，请您进行修改：");<br>     //修改，并重新录入<br>     printf("请输入名字：");<br>     scanf("%s", pc-&gt;data[n].name);    //此时下标为n<br>     printf("请输入年龄：");<br>     scanf("%d", &amp;(pc-&gt;data[n].age));<br>     printf("请输入性别：");<br>     scanf("%s", pc-&gt;data[n].sex);<br>     printf("请输入电话：");<br>     scanf("%s", pc-&gt;data[n].tele);<br>     printf("请输入地址：");<br>     scanf("%s", pc-&gt;data[n].address);<br>     printf("修改成功！！！");<br> }<br> //排序<br> int cmp_peo_by_name(const void* e1, const void* e2)<br> {<!-- --><br>     return strcmp(((p*)e1)-&gt;name,((p*)e2)-&gt;name);<br> }<br> //按照名字来排序<br> void SortContact(Contact* pc)<br> {<!-- --><br>     assert(pc);<br>     qsort(pc-&gt;data, pc-&gt;count, sizeof(p), cmp_peo_by_name);// sizeof(p)可替换为 sizeof(pc-&gt;data[0]),p只是元素pc-&gt;data的类型，拿下标为0的元素来计算也可以<br>     printf("排序成功！！！");<br> }<br> //qsort:比较函数（可以排序任意类型的数据），头文件&lt;stdlib.h&gt;，&lt;search.h&gt;<br> //其参数为：void qsort(void* base, size_t num, size_t width,int(*cmp)(const void* e1,const void* e2))<br> //void* base:指的是我们要排序的数据的起始位置<br> // size_t num:待排序的数据元素的个数<br> // size_t width:待排序的数据元素的大小（占几个字节）<br> //int(*cmp)(const void* e1,const void* e2):函数指针，需声明新的函数，并使用strcmp去比较所想比较的内容</p> 
<p>循环结束标志<br> //return: 从当前的方法中退出,返回到该调用的方法的语句处,继续执行。<br> //continue: 终止当前的一次循环过程，其 不 跳出循环,而是继续往下判断循环条件执行语句。<br> //          只能结束循环中的一次过程, 但不能终止循环继续进行。<br> //break: 直接跳出 当前 的循环，从当前循环外面开始执行,忽略循环体中任何其他语句和循环条件测试。<br> //       它只能跳出一层循环，如果你的循环是嵌套循环，那么你需要按照你嵌套的层次，逐步使用break来跳出。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/adab3441d428e31150cb93b1d66d13ea/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">RA4000CE (RTC模块)适用于汽车，工作温度范围宽，稳定性高</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6ca8aeb2003227a582fdb385798ce420/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">TypeScrip快速入门</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>