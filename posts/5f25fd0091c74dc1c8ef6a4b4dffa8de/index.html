<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>优化的 MCM-GPU 比具有相同 SM 总数和 DRAM 带宽的同等配备的多 GPU 系统快 26.8%。 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="优化的 MCM-GPU 比具有相同 SM 总数和 DRAM 带宽的同等配备的多 GPU 系统快 26.8%。" />
<meta property="og:description" content="MCM-GPU: Multi-chip-module GPUs for Continued Performance Scalability
抽象： 从历史上看，基于 GPU 的高性能计算的改进与晶体管缩放紧密相连。随着摩尔定律的减慢，每个芯片的晶体管数量不再以历史速度增长，单个单片GPU的性能曲线最终将趋于稳定。然而，许多领域对更高性能 GPU 的需求仍然存在。为了满足这一需求，在本文中，我们证明了多个 GPU 模块的封装级集成以构建更大的逻辑 GPU 可以实现超越摩尔定律的持续性能扩展。具体来说，我们建议将 GPU 划分为易于制造的基本 GPU 模块 （GPM），并使用高带宽和高能效信号技术将它们集成到封装上。我们列出了基本多芯片模块GPU（MCM-GPU）设计的细节并评估了可行性。然后，我们提出了三种架构优化，可显著提高GPM数据局部性，并最大限度地降低GPM间带宽的灵敏度。我们的评估表明，与基本的 MCM-GPU 架构相比，优化后的 MCM-GPU 实现了 22.8% 的加速和 5 倍的 GPM 间带宽降低。最重要的是，优化的 MCM-GPU 设计比最大的可实现单片 GPU 快 45.5%，性能在假设（且不可构建）单片 GPU 的 10% 以内。最后，我们展示了我们优化的 MCM-GPU 比具有相同 SM 总数和 DRAM 带宽的同等配备的多 GPU 系统快 26.8%。
介绍 基于GPU的计算加速是推动高性能计算（HPC）系统[12]–[29]、大规模云安装中的机器学习和数据分析应用以及个人计算设备[15]–[47]性能的主要工具。在此类设备中，每个计算节点或计算设备通常由具有一个或多个 GPU 加速器的 CPU 组成。这些领域的前进道路，无论是在HPC中实现百万兆次级性能，还是使用深度卷积神经网络实现人类水平的人工智能，都依赖于持续扩展GPU性能的能力[29]，[47]。因此，在这样的系统中，每个GPU在最先进的技术节点上都具有最大可能的晶体管数量，并使用最先进的内存技术[17]。直到最近，晶体管缩放通过增加 GPU 代之间的流式多处理器 （SM） 数量来提高单个 GPU 性能。然而，晶体管的缩放速度已经大大放缓，预计最终会结束[7]，[8]。此外，光学和制造限制限制了光罩尺寸，而光罩尺寸又限制了最大芯片尺寸（例如 ~800毫米2[18]， [48]）。此外，由于大量无法修复的制造故障，非常大的模具具有极低的良率[31]。这会将大型单片 GPU 的成本提高到不理想的水平。因此，这些趋势限制了未来单GPU性能的扩展，并可能使其停滞不前。
在不超过最大芯片尺寸的情况下扩展性能的另一种方法依赖于 PCB 上连接的多个 GPU，例如 Tesla K10 和 K80 [10]。然而，正如我们在本文中所展示的，在这种“多 GPU”系统上扩展 GPU 工作负载是很困难的，即使它们在单个 GPU 上扩展得非常好。这是由于在慢速车载互连网络中与工作分区、负载均衡和数据共享相关的多个未解决的挑战[20]–[36]。然而，由于封装[30]和信令技术[45]的最新进展，封装级集成提供了一个很有前途的集成层，位于现有的片上和板载集成技术之间。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/5f25fd0091c74dc1c8ef6a4b4dffa8de/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-06T17:47:10+08:00" />
<meta property="article:modified_time" content="2023-12-06T17:47:10+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">优化的 MCM-GPU 比具有相同 SM 总数和 DRAM 带宽的同等配备的多 GPU 系统快 26.8%。</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>MCM-GPU: Multi-chip-module GPUs for Continued Performance Scalability</p> 
<h2><a id="_3"></a>抽象：</h2> 
<p>从历史上看，基于 GPU 的高性能计算的改进与晶体管缩放紧密相连。随着摩尔定律的减慢，每个芯片的晶体管数量不再以历史速度增长，单个单片GPU的性能曲线最终将趋于稳定。然而，许多领域对更高性能 GPU 的需求仍然存在。为了满足这一需求，在本文中，我们证明了多个 GPU 模块的封装级集成以构建更大的逻辑 GPU 可以实现超越摩尔定律的持续性能扩展。具体来说，我们建议将 GPU 划分为易于制造的基本 GPU 模块 （GPM），并使用高带宽和高能效信号技术将它们集成到封装上。我们列出了基本多芯片模块GPU（MCM-GPU）设计的细节并评估了可行性。然后，我们提出了三种架构优化，可显著提高GPM数据局部性，并最大限度地降低GPM间带宽的灵敏度。我们的评估表明，与基本的 MCM-GPU 架构相比，优化后的 MCM-GPU 实现了 22.8% 的加速和 5 倍的 GPM 间带宽降低。最重要的是，优化的 MCM-GPU 设计比最大的可实现单片 GPU 快 45.5%，性能在假设（且不可构建）单片 GPU 的 10% 以内。最后，我们展示了我们优化的 MCM-GPU 比具有相同 SM 总数和 DRAM 带宽的同等配备的多 GPU 系统快 26.8%。</p> 
<h2><a id="_5"></a>介绍</h2> 
<p>基于GPU的计算加速是推动高性能计算（HPC）系统[12]–[29]、大规模云安装中的机器学习和数据分析应用以及个人计算设备[15]–[47]性能的主要工具。在此类设备中，每个计算节点或计算设备通常由具有一个或多个 GPU 加速器的 CPU 组成。这些领域的前进道路，无论是在HPC中实现百万兆次级性能，还是使用深度卷积神经网络实现人类水平的人工智能，都依赖于持续扩展GPU性能的能力[29]，[47]。因此，在这样的系统中，每个GPU在最先进的技术节点上都具有最大可能的晶体管数量，并使用最先进的内存技术[17]。直到最近，晶体管缩放通过增加 GPU 代之间的流式多处理器 （SM） 数量来提高单个 GPU 性能。然而，晶体管的缩放速度已经大大放缓，预计最终会结束[7]，[8]。此外，光学和制造限制限制了光罩尺寸，而光罩尺寸又限制了最大芯片尺寸（例如 ~800毫米2[18]， [48]）。此外，由于大量无法修复的制造故障，非常大的模具具有极低的良率[31]。这会将大型单片 GPU 的成本提高到不理想的水平。因此，这些趋势限制了未来单GPU性能的扩展，并可能使其停滞不前。</p> 
<p>在不超过最大芯片尺寸的情况下扩展性能的另一种方法依赖于 PCB 上连接的多个 GPU，例如 Tesla K10 和 K80 [10]。然而，正如我们在本文中所展示的，在这种“多 GPU”系统上扩展 GPU 工作负载是很困难的，即使它们在单个 GPU 上扩展得非常好。这是由于在慢速车载互连网络中与工作分区、负载均衡和数据共享相关的多个未解决的挑战[20]–[36]。然而，由于封装[30]和信令技术[45]的最新进展，封装级集成提供了一个很有前途的集成层，位于现有的片上和板载集成技术之间。</p> 
<p>利用这一新的集成层，我们提出了一种新颖的多芯片模块GPU（MCM-GPU）架构，该架构能够在晶体管缩放和光掩模版限制放缓的情况下继续扩展GPU性能。我们的建议将多个 GPU 模块 （GPM） 聚合在一个封装中，如图 1 所示。首先，我们详细介绍了利用 NVIDIA 最先进的地面参考信令 （GRS） 的基本 MCM-GPU 架构 [45]。然后，我们使用三种架构创新来优化我们提议的 MCM-GPU 设计，旨在改善局部性并最大限度地减少 GPM 间通信：（i） 用于捕获本地 GPM 中的远程流量的硬件缓存，（ii） 分布式和批处理协作线程阵列 （CTA） 调度，以更好地利用 GPM 内的 CTA 间位置，以及 （iii） 首次接触页面分配策略，以最大限度地减少 GPM 间流量。总体而言，本文做出了以下贡献：</p> 
<p>我们通过展示当今许多 GPU 应用程序随着 SM 数量的增加而很好地扩展，从而激发了对更强大 GUP 的需求。鉴于未来的 GPU 无法再使用当今的单片架构继续其性能扩展，我们提出了 MCM-GPU 架构，该架构允许性能和节能扩展超出当今的可能性。</p> 
<p>我们展示了具有 256 个 SM 的模块化 MCM-GPU，并讨论了其内存系统、封装集成和信令技术。我们通过分析和仿真展示了其对 GPM 间带宽的性能敏感性。我们的评估表明，由于 GPM 间带宽低于单片 GPU 的片上带宽，因此 MCM-GPU 中暴露了封装上的非一致性内存访问 （NUMA） 架构。</p> 
<p>我们提出了一种更适合其 NUMA 特性的局部感知 MCM-GPU 架构。我们使用架构增强功能来减轻非一致性内存访问带来的损失。我们的评估表明，与基准 MCM-GPU 相比，这些优化提供了令人印象深刻的 5 倍 GPM 间带宽减少，并导致性能加速 22.8%。我们优化的 MCM-GPU 架构比最大的单片 GPU（假设为 44 个 SM GPU）加速了 5.128%，性能仅为不可构建的类似大小的单片 GPU 的 10%。</p> 
<h2><a id="_18"></a>动机和背景</h2> 
<p>现代 GPU 加速了科学计算、数据分析和机器学习领域的各种并行应用。这些应用中丰富的并行性不断增加对更高性能 GPU 的需求。表 1 列出了过去 14 年发布的不同代 NVIDIA GPU。该表显示了每一代新GPU的流式多处理器（SM）、内存带宽和晶体管数量的增长趋势[&lt;&gt;]。</p> 
<h3><a id="21_GPU_21"></a>2.1 GPU应用可扩展性</h3> 
<p>为了了解增加 GPU SM 数量的好处，图 2 显示了性能与 GPU 上 SM 数量的函数关系。L2 缓存和 DRAM 带宽容量随 SM 计数按比例扩展，即 384 SM GPU 为 32 GB/s，3 SM GPU 为 256 TB/s1.该图显示了随着 SM 计数的增加而出现的两种不同的性能行为。首先是具有有限并行度的应用程序的趋势，其性能随着 SM 数量的增加而趋于稳定（有限并行度应用程序）。由于缺乏可用的并行性（即线程数）来充分利用大量 SM，这些应用程序表现出较差的性能可伸缩性（在评估的 15 个应用程序中有 48 个）。另一方面，我们发现 33 个应用程序中有 48 个表现出高度的并行性，并充分利用了 256-SM GPU。请注意，这种 GPU 比目前可用的 GPU 大得多 （4.5 ×）。对于这些高并行度应用程序，如果可以制造如此大的 GPU，则有可能实现 87.8% 的线性缩放理论性能提升。</p> 
<p>遗憾的是，尽管随着 SM 数量的增加，应用性能具有可扩展性，但单片单芯片 GPU 设计无法实现观察到的性能提升。这是因为晶体管缩放速度减慢[8]最终限制了可以集成到给定芯片面积上的SM数量。此外，传统的光刻技术限制了最大可能的掩模版尺寸，从而限制了最大可能的芯片尺寸。例如，≈800毫米2预计是可以制造的最大可能模具尺寸[18]，[48]。出于本文的目的，我们假设大于 128 个 SM 的 GPU 不能在单片芯片上制造。我们在图 2 中用虚线说明了这种不可制造的 GPU 的性能。</p> 
<h3><a id="22_MultiGPU_25"></a>2.2 Multi-GPU替代方案</h3> 
<p>另一种方法是，通过将多个最大尺寸的单片 GPU 连接到多 GPU 系统中，停止扩展单个 GPU 性能，并通过板级和系统级集成来提高应用程序性能。虽然概念简单，但多 GPU 系统带来了一系列关键挑战。例如，跨GPU的工作分配无法轻松透明地完成，需要大量的程序员专业知识[20]–[50]。自动化的多GPU运行时和系统软件方法在工作分区、负载均衡和同步方面也面临挑战[23]，[49]。</p> 
<p>此外，多 GPU 方法严重依赖于多级系统互连。需要注意的是，沿这些互连耗散的数据移动和同步能量会显著影响此类多 GPU 系统的整体性能和能效。不幸的是，随着通信从封装外、板外移动，并最终从节点外移动，互连技术在可用带宽和每比特能量方面的质量会逐渐变差，如表2 [9]–[46]所示。虽然上述集成层是大型系统的重要组成部分（例如[19]），但更希望通过构建功能更强大的GPU来减少板外和节点外通信。</p> 
<h3><a id="23__30"></a>2.3 包级集成</h3> 
<p>有机封装技术的最新进展有望解决当今的挑战，并实现有源组件的封装集成。例如，下一代封装预计将支持 77mm 基板尺寸 [30]，为集成本文所述的 MCM-GPU 架构提供足够的空间。此外，封装级信令技术的进步，如 NVIDIA 的地面参考信令 （GRS），为有机封装基板提供了必要的高速、高带宽信令。GRS信令可以以20 Gb/s的速度运行，而在标准0nm工艺中仅消耗54.28 pJ/bit[45]。随着这项技术的发展，我们可以预期它将支持高达数TB/s的封装带宽。这使得封装信令带宽比板载信令带宽大八倍。</p> 
<p>上述因素使封装级集成成为很有前途的集成层，在质量上介于芯片级和板级集成层之间（见表2）。在本文中，我们旨在利用这一集成层，并设定一个雄心勃勃的目标，即探索如何制造一个功能更强大 2× 的 GPU，在单个 GPU 封装中包含 256 个或更多 SM。</p> 
<h2><a id="_GPU_35"></a>多芯片模块 GPU</h2> 
<p>所提出的多芯片模块 GPU （MCM-GPU） 架构基于将多个 GPU 模块 （GPM） 聚合在单个封装中，而不是目前基于单个单片芯片的 GPU 架构。这可以通过增加每个 GPU 的晶体管、DRAM 和 I/O 带宽的数量来扩展单个 GPU 的性能。图 1 显示了一个 MCM-GPU 架构示例，该架构在单个封装上具有 4 个 GPM，与目前生产中最大的 GPU 相比，该架构可能实现高达 2× 的 SM 数量（芯片面积）和 &lt;&gt;× 的内存带宽（边缘尺寸）。</p> 
<h3><a id="31_MCMGPU_38"></a>3.1 MCM-GPU组织</h3> 
<p>在本文中，我们提出 MCM-GPU 是共享资源的 GPM 集合，并作为单个单片 GPU 呈现给软件和程序员。池化硬件资源和共享 I/O 集中在一个共享的封装模块（SYS + I/O 模块，如图 1 所示）。该 MCM-GPU 的目标是提供与单个（不可制造）单片芯片相同的性能特征。通过这样做，操作系统和程序员与单个逻辑 GPU 现在可能是多个 GPM 协同工作的事实隔离开来。该组织有两个关键优势。首先，它支持在单个 GPU 中共享未充分利用的结构的资源，并消除 GPM 之间的硬件复制。其次，应用程序将能够透明地利用更大、更强大的 GPU，而无需任何额外的编程工作。</p> 
<p>或者，封装上的 GPM 可以组织成多个功能齐全且自主的 GPU，具有非常高的互连速度。但是，由于这种方法的缺点和资源利用效率低下，我们不建议这种方法。例如，如果作为多个 GPU 实现，则在 GPM 之间拆分包外 I/O 带宽可能会损害整体带宽利用率。其他常见的体系结构组件（如虚拟内存管理、DMA 引擎和硬件上下文管理）也将是私有资源，而不是池资源。此外，操作系统和程序员必须意识到在这样的 MCM-GPU 上运行的任务之间潜在的负载不平衡和数据分区，这些 MCM-GPU 在单个包中组织为多个独立的 GPU。</p> 
<h3><a id="32_MCMGPU__GPM__42"></a>3.2 MCM-GPU 和 GPM 架构</h3> 
<p>如第 1 节和第 2 节所述，要超过 128 个 SM 计数，几乎可以肯定的是，GPU 中至少需要两个 GPM。由于较小的 GPM 明显更具成本效益 [31]，因此在本文中，我们评估了在 256 个 GPM 中构建一个 64 SM GPU，每个 GPM 为 40 个 SM。这样，每个 GPM 的配置都与当今最大的 GPU 非常相似。从面积上看，假设工艺节点缩小到 60nm 或 10nm，预计每个 GPM 将比当今最大的 GPU 小 7%–1%。每个 GPM 都由多个 SM 及其专用 L2 缓存组成。SM 通过 GPM-Xbar 连接到 GPM 内存子系统，该子系统由本地内存端 L45 缓存和 DRAM 分区组成。GPM-Xbar 还通过封装上的 GRS [&lt;&gt;] GPM 间链路提供与相邻 GPM 的连接。</p> 
<p>图 3 显示了此 4-GPM MCM-GPU 的高级图。这样的MCM-GPU预计将配备3TB/s的总DRAM带宽和16MB的总L2缓存。所有 DRAM 分区在所有 GPM 之间提供全局共享的内存地址空间，地址在所有物理 DRAM 分区之间进行细粒度交错，以实现最大的资源利用率。GPM-Xbars 根据物理地址将内存访问路由到正确的位置（本地或远程 L2 缓存组）。它们还共同提供模块化的封装环形或网状互连网络。这种组织在本地 SM 和内存分区之间提供空间流量局部性，并降低封装上的带宽要求。其他网络拓扑结构也是可能的，特别是随着GPM数量的增加，但对GPM间网络拓扑结构的全面探索超出了本文的范围。L2 缓存是内存端缓存，仅从其本地 DRAM 分区缓存数据。因此，每个缓存行只有一个位置，并且不需要跨 L2 缓存组的缓存一致性。在基线 MCM-GPU 架构中，我们采用集中式 CTA 调度器，当 SM 可供执行时，该调度器以循环方式将 CTA 调度到全局 MCM-GPU SM，就像典型的单片 GPU 一样。<br> MCM-GPU 内存系统是一种非一致性内存访问 （NUMA） 架构，因为其 GPM 间链路预计不会为每个 GPM 提供完整的聚合 DRAM 带宽。此外，在远程 GPM 上访问内存时，预计会出现额外的延迟损失。此延迟包括本地 GPM 内到芯片边缘的数据移动时间、GPM 间链路上的序列化和反序列化延迟，以及到下一个 GPM 的线路延迟。对于封装互连中潜在的多跳路径，我们估计每个额外的 GPM 跳间延迟为 32 个周期。与本地 DRAM 访问相比，每增加一跳也会增加能源成本。尽管我们预计 MCM-GPU 架构会产生这些带宽、延迟和能源损失，但与多 GPU 系统中的封装外互连相比，我们预计它们会低得多（参见表 2）。</p> 
<h3><a id="33__48"></a>3.3 封装带宽注意事项</h3> 
<h4><a id="331__49"></a>3.3.1 封装上带宽要求的估算</h4> 
<p>我们计算通用 MCM-GPU 中所需的 GPM 间带宽。我们分析的基本原则是，封装上链路需要足够大，以便充分利用昂贵的DRAM带宽资源。让我们考虑一个 4-GPM 系统，其总 DRAM 带宽为 4b 个单位（在我们的示例中为 3TB/s），因此b带宽单位（在我们的示例中为 768 GB/s）由直接附加到每个 GPM 的本地内存分区提供。假设平均情况下 L2 缓存命中率为 ~ 50%，则每个 L2 缓存分区将提供 2b 个带宽单位。在统计上均匀的地址分布场景中，所有四个 GPM 将平均消耗每个内存分区的 2b 个带宽单位。 扩展此练习以捕获进出所有内存分区的 GPM 间通信会导致 MCM-GPU 的总 GPM 间带宽需求。需要 4b 的链路带宽才能提供 4b 的总 DRAM 带宽。在具有 4TB/s DRAM 带宽 （3b） 的 4-GPM MCM-GPU 示例中，小于 3TB/s 的链路带宽设置预计会因 NUMA 效应而导致性能下降。或者，大于 3TB/s 的 GPM 间带宽设置预计不会产生任何额外的性能。</p> 
<h4><a id="332__52"></a>3.3.2 对封装带宽的性能敏感度</h4> 
<p>图 4 显示了 256 SM MCM-GPU 系统的性能敏感度，因为我们将 GPM 间带宽从每条链路的 6TB/s 一直降低到 384GB/s。这些应用分为高并行度和低并行度两大类，如图 2 所示。可扩展的高并行性类别进一步细分为内存密集型和计算密集型应用程序（有关应用程序类别和模拟方法的更多详细信息，请参阅第 4 节）。</p> 
<p>我们的仿真结果支持了我们上面的分析估计。将链路带宽增加到 6TB/s 会给整套应用程序带来递减甚至没有回报。正如预期的那样，MCM-GPU 性能会受到低于 3TB/s 的 GPM 间链路带宽设置的显着影响。例如，内存密集型类别中的应用程序对链路带宽最敏感，12.40TB/s、57GB/s 和 1GB/s 设置的性能分别下降了 5%、768% 和 384%。计算密集型应用程序对较低的链路带宽设置也很敏感，但性能下降较低。令人惊讶的是，即使是并行度有限且内存强度低的不可扩展应用程序，由于在低带宽场景中排队延迟增加和通信延迟增加，对 GPM 间链路带宽表现出性能敏感性。</p> 
<h4><a id="333__57"></a>3.3.3 包上链路带宽配置</h4> 
<p>NVIDIA 的 GRS 技术可提供每根线高达 20 Gbps 的信令速率。我们的 256 SM MCM-GPU 的实际封装链路带宽设置可能会因与实际链路设计复杂性相关的设计工作量和成本、封装技术的选择以及封装路由层的数量而有所不同。因此，根据我们的估计，GPM GRS间链路带宽为768 GB/s（等于本地DRAM分区带宽）是很容易实现的。1.5 TB/s 等更大的带宽设置是可能的，尽管更难实现，而 3TB/s 链路需要在信令和封装技术方面进行进一步的投资和创新。此外，高于必要的链路带宽设置将导致额外的芯片成本和功率开销。尽管封装互连比板载互连更有效，但其效率仍然远低于片上导线，因此我们必须尽可能减少 GPM 间链路带宽消耗。</p> 
<p>在本文中，我们假设一个 768GB/s 的低工作量、低成本和低能耗链路设计点，并试图通过架构创新来弥合由于相对较低的带宽设置而导致的性能差距，这些创新提高了通信局部性，从根本上消除了对更昂贵和更低能效链路的需求。本文的其余部分提出了在GPM模块中捕获数据局部性的架构机制，从而消除了对昂贵的GPM间带宽解决方案的需求。</p> 
<h2><a id="4_62"></a>第4节模拟方法</h2> 
<p>我们使用 NVIDIA 内部模拟器进行性能研究。我们建模的GPU与最近发布的NVIDIA Pascal GPU[17]相似，但大小是外推的。我们的 SM 被建模为按顺序执行处理器，可准确模拟 warp 级并行性。我们对多级缓存层次结构进行建模，每个 SM 有一个专用 L1 缓存和一个共享 L2 缓存。缓存被存储，以便它们可以提供必要的并行性，使DRAM带宽饱和。我们在私有缓存中对基于软件的缓存一致性进行建模，类似于最先进的 GPU。表3总结了基线仿真参数。<br> 我们研究了一组不同的 48 个基准测试，这些基准测试来自四个基准测试套件。我们的评估包括来自 CORAL 基准测试 [6] 的一组生产级 HPC 基准测试、来自 Lonestar 套件 [43] 的图形应用程序、来自 Rodinia [24] 的计算应用程序以及一组 NVIDIA 内部 CUDA 基准测试。我们的应用程序集涵盖了广泛的 GPU 应用领域，包括机器学习、深度神经网络、流体动力学、医学成像、图形搜索等。我们根据可用的并行度将应用程序分为两类 - 高并行度应用（并行效率≥ 25%）和有限并行度应用（并行效率&lt; 25%）。我们根据高并行性应用程序是内存密集型（M 密集型）还是计算密集型（C 密集型）进一步对它们进行分类。如果应用程序在系统内存带宽减半时性能下降超过 20%，我们将应用程序归类为内存密集型应用程序。由于篇幅所限，我们提供了 M 密集型工作负载的详细每个应用程序结果，并仅提供了 C-密集型和有限并行度工作负载的平均数字。表 4 详细介绍了 M - Intensive 基准测试集及其内存占用情况。我们模拟了 &lt;&gt; 亿条翘曲指令的所有基准，或完成，以先发生者为准。<br> 第5节优化的 MCM-GPU<br> 我们提出了三种机制，通过捕获GPM内的数据局部性来最小化GPM间带宽。首先，我们重新审视 MCM-GPU 缓存层次结构，并提出 GPM 端硬件缓存。其次，我们通过分布式 CTA 调度来增强我们的架构，以利用 GPM 端缓存和内存中的 CTA 间数据局部性。最后，我们提出了数据分区和位置感知页面放置，以进一步降低封装上的带宽要求。这三种机制相结合可显著提高 MCM-GPU 性能。</p> 
<h2><a id="51__MCMGPU__68"></a>5.1 重新审视 MCM-GPU 缓存架构</h2> 
<h4><a id="511__L15__69"></a>5.1.1 引入 L1.5 缓存</h4> 
<p>我们建议减少包上链路带宽的第一种机制是增强 MCM -GPU 缓存层次结构。我们建议使用位于 L3 和 L1 缓存之间的 GPM 端缓存来增强图 2 中的基线 GPM 架构。我们将这个新的缓存级别称为 L1.5 缓存，如图 5 所示。从架构上讲，L1.5 缓存可以被视为 L1 缓存的扩展，并由 GPM 内的所有 SM 共享。我们建议 L1.5 缓存存储由 GPM 分区进行的远程数据访问。换句话说，所有本地内存访问都将绕过 L1.5 缓存。这样做可以减少远程数据访问延迟和 GPM 间带宽。这两个特性都通过避免 GPM 间通信来提高性能并降低能耗。</p> 
<p>为了避免增加 L1.5 缓存的片上晶体管开销，我们通过以 iso-transistor 方式重新平衡 L2 和 L1.5 缓存之间的缓存容量来增加它。我们将 GPU L1 缓存一致性机制也扩展到 GPM 端的 L1.5 缓存。这样，每当在同步事件（例如到达内核执行边界）时刷新 L1 缓存时，L1.5 缓存也会刷新。由于 L1.5 缓存可以从 GPM SM 接收多个失效命令，因此我们确保 L1.5 缓存对于每个同步事件仅失效一次。</p> 
<h4><a id="512_L15_74"></a>5.1.2 L1.5缓存的设计空间探索</h4> 
<p>我们评估了三种不同 L1.5 缓存容量的 MCM-GPU 性能：8MB L1.5 缓存，其中一半的内存端 L2 缓存容量移动到 L1.5 缓存，16MB L1.5 缓存，几乎所有内存端 L2 缓存都移动到 L1.5 缓存3，最后是 32MB 的 L1.5 缓存，这是一种非 iso-transistor 场景，除了将整个 L2 缓存容量移动到 L1.5 缓存之外，我们还增加了额外的 16MB 缓存容量。由于 L1.5 缓存的主要目标是减少 GPM 间带宽消耗，因此我们根据访问是本地还是远程 DRAM 分区来评估不同的缓存分配策略。</p> 
<p>图 6 总结了不同 L1.5 缓存大小的 MCM-GPU 性能。我们报告了每个类别的平均性能加速，并通过显示其各个应用程序的加速来关注内存密集型类别。我们观察到，内存密集型应用程序的性能对 L1.5 缓存容量很敏感，而计算密集型和有限并行性类别中的应用程序对各种缓存配置的敏感度非常低。当专注于内存密集型应用时，与基准 MCM-GPU 相比，8MB iso 晶体管 L1.5 缓存的平均性能提高了 4%。16MB iso 晶体管 L1.5 缓存实现了 8% 的性能提升，而 32MB L1.5 缓存将晶体管预算增加了一倍，实现了 18.3% 的性能提升。我们为 L16.1 选择了 5MB 的缓存容量，并保持总缓存面积不变。</p> 
<p>我们的仿真结果证实了 L1.5 缓存的最佳分配策略是仅缓存远程访问的直觉，因此我们在此缓存中采用了仅远程分配策略。从图 6 中我们可以看出，这种配置在两种 iso 晶体管配置中实现了最高的平均性能加速。它比内存密集型 GPU 应用程序的基准速度提高了 11.4%。虽然 GPM 端 L1.5 缓存对计算密集型 GPU 应用程序的影响很小，但它能够捕获有限并行度 GPU 应用程序的相对较小的工作集，并提供比基线 3.5% 的性能加速。最后，图 6 显示，L1.5 缓存通常有助于在从 6TB/s 的 GPM 间带宽设置移动到 768GB/s 时造成显著性能损失的应用程序。从图中可以看出这种趋势，因为内存密集型应用程序按其 GPM 间带宽敏感度从左到右排序。</p> 
<p>除了提高 MCM-GPU 性能外，GPM 端 L1.5 缓存还有助于显著降低与封装数据移动相关的 GPM 间通信能量。如图 7 所示，该图总结了使用和不使用 L1.5 缓存的 GPM 间总带宽。在内存密集型工作负载中，SSSP 应用程序的 GPM 间带宽减少了 39.9%，内存密集型、计算密集型和有限并行性工作负载的平均 GPM 间带宽分别减少了 16.9%、36.4% 和 32.9%。平均而言，在所有评估的工作负载中，我们观察到，由于引入了 GPM 端 L28.1 缓存，GPM 间带宽利用率降低了 5%。</p> 
<h3><a id="52_GPM__CTA__83"></a>5.2 GPM 局部性的 CTA 调度</h3> 
<p>在类似于单片 GPU 的基线 MCM-GPU 中，在内核启动时，第一批 CTA 由集中式调度器按顺序调度到 SM。但是，在内核执行期间，CTA 会根据 SM 中用于执行给定 CTA 的资源可用性，以循环顺序分配给 SM。在稳态应用程序执行中，这可能导致在不同 GPM 的 SM 上调度连续的 CTA，如图 8（a） 所示。此图中的颜色表示四组连续的 CTA，如果它们被安排在附近并共享内存系统资源，则它们可能会享有数据局部性。虽然之前的工作试图在私有 L1 缓存中利用这种 CTA 间位置 [37]，但在这里，由于 MCM-GPU 设计的 NUMA 性质，我们提出了一个 CTA 调度策略，以在与 GPM 相关的所有内存系统组件中利用这种位置。<br> 对于 Srad-v2 和 Kmeans 等工作负载，分布式调度和仅远程缓存的组合可显著提高性能，而仅远程缓存并不能单独提高性能（图 6）。这是由于在应用分布式调度时，L1.5 缓存中的 CTA 间数据重用得到了改进。尽管分布式调度为许多已评估的工作负载提供了显著的额外性能优势，但我们观察到，它会导致某些应用程序的性能下降。此类工作负载往往会受到 CTA 划分的粗粒度的影响，并且分配给每个 GPM 的连续 CTA 数量较少时，性能可能会更好。可以提出一个选择团体规模的动态机制的案例。虽然本文没有探讨这样的设计，但我们希望动态 CTA 调度器能够获得进一步的性能提升。</p> 
<h3><a id="53_GPM__87"></a>5.3 GPM 局部性的数据分区</h3> 
<p>NUMA系统之前的工作重点是通过调度线程并将这些线程访问的页面放在非常近的位置来共置代码和数据[27]–[53]。这样做可以通过减少远程访问来限制高延迟、低带宽节点间链路对性能的负面影响。在 MCM-GPU 系统中，虽然 GPM 间链路的属性优于先前工作中假设的传统包间链路（即，本地内存带宽与远程内存带宽的比率要大得多，而包间链路的延迟要低得多），但我们重新审视页面放置策略以减少 GPM 间带宽。<br> 为了提高 MCM-GPU 性能，需要特别注意页面放置，以尽可能减少 GPM 间流量。理想情况下，我们希望将内存页映射到物理 DRAM 分区，以便它们产生尽可能多的本地内存访问。为了最大限度地提高 DRAM 带宽利用率并防止在内存分区内的内存通道上扎营，我们仍然会在每个内存分区的内存通道之间以细粒度交错地址（类似于第 3.2 节中描述的基线）。</p> 
<p>图 11 显示了我们在 MCM-GPU 中采用的首次触摸 （FT） 页面映射策略的示意图。在 FT 策略中首次引用页面时，页面映射机制会检查引用来自哪个 GPM，并将页面映射到该 GPM 的本地内存分区 （MP）。例如，在图中，页面 P0 首先由在 GPM0 上执行的 CTA - X 访问。这导致 P0 在 MPO 中分配。随后，在 GPM1 上执行的 CTA-Y 首先访问页面 P2 和 P1，从而将这些页面映射到 MP1。在此之后，CTA-X 首先访问页面 P3，该页面将页面映射到 MPO。此策略导致 DRAM 访问主要保持在本地。无论引用顺序如何，如果在 GPM0 中首次从 CTA-X 引用页面，则该页面将映射到 MPO，这将使对该页面的访问保持在本地并避免 GPM 之间的通信。此页面放置机制是通过扩展当前 GPU 驱动程序功能在软件层实现的。此类驱动程序修改对操作系统是透明的，不需要程序员进行任何特殊处理。</p> 
<p>第一个触摸映射策略的一个重要好处是它与第 5.2 节中描述的 CTA 调度策略协同作用。我们观察到，CTA 间局部性存在于多个内核之间，并且每个内核内都存在页面粒度。例如，在包含收敛循环的应用程序中，同一内核在循环中以迭代方式启动，并且具有相同索引的 CTA 可能会访问相同的页面。图 12 显示了一个示例。由于我们的分布式 CTA 调度策略和上述第一个触摸页面映射策略，我们也能够利用跨内核执行边界的 CTA 间位置。之所以启用此功能，是因为具有相同索引的 CTA 在内核的多次迭代启动时绑定到相同的 GPM，因此允许引入 GPM 内存分区的内存页在后续内核启动时继续是本地的。请注意，如果没有第一个触摸页面映射策略，此位置不会显示自身，因为它不会提高 L1.5 缓存命中率，因为缓存在内核边界刷新。但是，当分布式调度与首次接触映射相结合时，我们从更多的本地访问中受益匪浅。</p> 
<p>FT 还允许更有效地使用缓存层次结构。由于 FT 页面放置使许多访问保持在 CTA 的 GPM 内存分区的本地，因此它减少了对 L1.5 缓存的需求压力，以防止请求进入远程内存分区。事实上，使用首次接触策略会将性能瓶颈从 GPM 间带宽转移到本地内存带宽。图 13 显示了这种效果。在此图中，我们显示了每个带有 DS 和 16MB 远程 L1.5 缓存的基准 FT 以及带有 DS 和 8MB 远程仅 L1.5 缓存的 FT 的两个条形。16MB 的 L1.5 缓存在每个 GPM 中只留出 32KB 的 L2 缓存空间。这会导致性能欠佳，因为分配给本地内存流量的缓存容量不足。我们观察到，在存在 FT 的情况下，8MB L1.5 缓存和更大的 8MB L2 可以实现更好的性能。结果表明，与基准 MCM-GPU 相比，在这种配置下，我们可以分别在内存密集型、计算密集型和有限并行度应用中获得 51%/11.3%/7.9% 的性能提升。最后，图 14 显示，使用 FT 页面放置时，大量工作负载的 GPM 间流量会急剧减少，有时几乎完全消除了它。平均而言，与基准 MCM-GPU 相比，我们提出的 MCM-GPU 实现了 5 × 的 GPM 间带宽减少。</p> 
<h3><a id="54_MCMGPU__96"></a>5.4 MCM-GPU 性能总结</h3> 
<p>图 15 显示了 S 曲线，该曲线描述了 MCM-GPU 在我们研究中所有工作负载的性能改进。在评估的 48 个工作负载中，有 31 个工作负载的性能有所提高，而 9 个工作负载的性能有所下降。由于我们的优化，CFD、CoMD 等 M 密集型工作负载的 GPM 间流量大幅减少，因此性能分别显著提升了 3.2 × 和 3.5 ×。对 GPM 间带宽表现出高敏感度的 C 密集型和有限并行性类别中的工作负载也获得了显著的性能提升（例如，SP 为 4.4× XSBench 为 3.1 倍）。另一方面，我们观察到所提出的优化的两个副作用。例如，对于 DWT 和 NN 等并行性有限且本质上对 GPM 间带宽不敏感的工作负载，L1.5 缓存的存在带来的额外延迟可能会导致性能下降高达 14.6%。在 Streamcluster 中观察到的潜在性能损失的另一个原因是片上写回 L2 缓存的容量降低4这会导致对 DRAM 的写入流量增加。这导致该应用的性能损失高达 25.3%。最后，我们观察到，在一些工作负载（我们的评估集中有两个）中，不同的 CTA 执行的工作量不相等。由于粗粒度的分布式调度，这会导致工作负载不平衡。我们将 MCM-GPU 架构的进一步优化留给未来的工作，以利用这一潜在机会获得更好的性能。<br> 总之，我们对基线 MCM-GPU 架构提出了三个重要的 mircroarchitecal 增强功能：（i） 仅远程 L1.5 缓存，（ii） 分布式 CTA 调度器，以及 （iii） 首次接触数据页面放置策略。需要注意的是，这些独立的优化在组合在一起时效果最好。图 16 显示了单独使用这三种机制的性能优势。引入 L1.5 缓存可提供 5.2% 的性能。另一方面，分布式调度和首次触摸页面放置在单独应用时根本不会提高性能。事实上，它们甚至会导致性能下降，例如，首次触摸页面放置策略的 -4.7%。</p> 
<p>然而，当这三种机制同时应用时，我们观察到优化的 MCM-GPU 实现了 22.8% 的加速，如图 16 所示。我们观察到，将分布式调度与仅远程缓存相结合可以提高缓存性能并进一步降低 GPM 间带宽。与仅使用远程缓存相比，这可带来 4.9% 的额外性能优势，同时还将 GPM 间带宽额外减少 5%。同样，当首次触摸页面放置与仅远程缓存和分布式调度结合使用时，它提供了 12.7% 的额外加速，并将 GPM 间带宽额外减少了 47.2%。这些结果表明，我们提出的增强功能不仅利用了程序中当前可用的数据局部性，而且还对其进行了改进。总而言之，这三种局部增强机制都实现了 5 × 的 GPM 间带宽减少。这些优化使所提出的 MCM-GPU 与最大的可实现单片 GPU 相比实现了 45.5% 的加速，并且与同等装备但无法构建的单片 GPU 相差 10% 以内。</p> 
<h2><a id="6MCMGPU__GPU_102"></a>第6节MCM-GPU 与多 GPU</h2> 
<p>扩展 GPU 性能的另一种方法是构建多 GPU 系统。本节比较了 MCM-GPU 和两种可能的多 GPU 系统的性能和能效。</p> 
<h3><a id="61_GPU_105"></a>6.1 性能与多GPU</h3> 
<p>还可以通过互连两个最大尺寸的独立 GPU（每个 256 个 SM）来构建具有 128 个 SM 的系统。与我们的 MCM-GPU 提案类似，每个 GPU 每个 SM 都有一个专用的 128KB L1 缓存、一个 8MB 的内存侧缓存和 1.5 TB/s 的 DRAM 带宽。我们假设这样的配置是未来最大尺寸的单片 GPU 设计。我们假设两个 GPU 通过下一代板载级链路互连，总带宽为 256 GB/s，比目前市售的 160 GB/s 有所改进 [17]。我们假设多 GPU 对程序员是完全透明的。这是通过假设以下两个功能来实现的：（i） 两个对等 GPU 之间的统一内存架构，其中两个 GPU 都可以通过加载/存储语义访问本地和远程 DRAM 资源，（ii） 系统软件和硬件的组合，自动在 GPU 之间分配同一内核的 CTA。<br> 在这样的多 GPU 系统中，由于较低的 GPU 间带宽带来的严重 NUMA 效应，第 3 节和第 5 节中讨论的负载不平衡、数据放置、工作负载分配和互连带宽等挑战被放大。分布式 CTA 调度以及首次接触页面分配机制（分别在第 5.2 节和第 5.3 节中描述）也适用于多 GPU。我们将此设计称为基线多 GPU 系统。虽然没有对各种多GPU设计选项进行全面研究，但研究了CTA调度和页面分配的替代选项。例如，探索了跨 GPU 的细粒度 CTA 分配，但由于 GPU 之间的互连延迟较高，其性能非常差。同样，循环页面分配会导致我们的基准测试套件中的性能非常低且不一致。</p> 
<p>与 MCM-GPU 相比，多 GPU 中的远程内存访问成本更高，因为板载互连的质量相对较低。我们通过添加远程 GPU 内存的 GPU 端硬件缓存来优化多 GPU 基线，类似于为 MCM-GPU 提出的 L1.5 缓存。我们探索了各种 L1.5 缓存分配配置，并观察到最佳平均性能，其中一半的 L2 缓存容量移动到专用于缓存远程 DRAM 访问的 L1.5 缓存，另一半保留为用于缓存本地 DRAM 访问的 L2 缓存。我们将其称为优化的多 GPU。</p> 
<p>图 17 总结了不同可构建 GPU 组织和无法实现的假设设计的性能结果，所有这些都归一化为基线多 GPU 配置。具有 GPU 端缓存的优化多 GPU 性能平均比基准多 GPU 高出 25.1%。另一方面，我们提出的 MCM-GPU 的性能比基准多 GPU 平均高出 51.9%，这主要是由于更高质量的封装互连。</p> 
<h3><a id="62_MCMGPU_113"></a>6.2 MCM-GPU效率</h3> 
<p>除了实现性能可扩展性外，MCM-GPU 还具有能源和成本效益。MCM-GPU 非常节能，因为它们能够将 GPU 模块更密集地集成在封装上，或者像在多 GPU 情况下一样在 PCB 级别连接。在此过程中，MCM-GPU 需要更小的系统尺寸，并利用更高效的互连技术，例如，0.5 pJ/b 的封装互连与 10 pJ/b 的板载互连。此外，如果我们假设 GPU 和系统功耗几乎恒定，MCM -GPU 的性能优势将转化为额外的节能效果。此外，通过 MCM-GPU 方法实现的卓越晶体管密度允许降低 GPU 工作电压和频率。这会将 GPU 移动到晶体管电压-频率曲线上更节能的工作点。因此，它允许牺牲充足的性能（通过丰富的并行性和封装中的晶体管数量实现）以获得更好的电源效率。</p> 
<p>最后，在 HPC 集群等大规模应用中，MCM-GPU 可提高性能密度，从而减少每个节点的 GPU 数量和/或每个机柜的节点数量。这导致系统级别的机柜数量减少。较小的总系统尺寸意味着更少的通信代理数量、更小的网络规模和更短的通信距离。这些导致通信、供电和冷却的系统级能量耗散降低。同样，如上所述，更高的系统密度也会带来总系统成本优势和更低的开销。此外，MCM-GPU 有望降低 GPU 硅成本，因为它们用具有显着更高硅产量和成本优势的中型芯片取代大型芯片。</p> 
<h2><a id="7_118"></a>第7节相关工作</h2> 
<p>多芯片模块是一个有吸引力的设计点，已在工业中广泛使用，用于在同一封装中集成多个异构或同构芯片。在同构方面，IBM Power 7 [5] 集成了 4 个模块，每个模块有 8 个内核，AMD Opteron 6300 [4] 集成了 2 个模块，每个模块有 8 个内核。在异构方面，IBM z196 [3] 在同一封装中集成了 6 个处理器，每个处理器有 4 个内核和 2 个存储控制器单元。Microsoft Xbox360 [1] 中使用的 Xenos 处理器将 GPU 和 EDRAM 内存模块与其内存控制器集成在一起。同样，英特尔提供异构和同构 MCM 设计，例如分别使用 Iris Pro [11] 和 Xeon X5365 [2] 处理器。虽然 MCM 在各个领域都很受欢迎，但我们不知道有任何尝试以操作系统和程序员透明的方式将同构高性能 GPU 模块集成在同一封装上。据我们所知，这是首次利用 MCM 技术来扩展 GPU 性能。</p> 
<p>MCM 封装级集成需要高效的信令技术。最近，Kannan等[31]探索了用于分解多核CPU芯片的各种封装和架构选项，并研究了其以有效方式提供缓存一致性流量的适用性。低功率链路领域的最新工作集中在差分信令上，因为它具有更好的抗噪性和更低的噪声产生[40]，[44]。一些现代 MCM，例如用于 Power 6 处理器的 MCM，具有 800 多个单端链路，从单个处理器以高达 3.2 Gbps 的速度运行[28]。NVIDIA 用于有机封装基板的地面参考信号 （GRS） 技术已被证明可在 20 Gbps 下工作，而在标准 0nm 工艺中功耗仅为 54.28pJ/位 [45]。</p> 
<p>MCM-GPU 设计公开了 NUMA 架构。提高 NUMA 系统性能的主要机制之一是通过在靠近数据的位置分配线程来保留局部性。在多核域中，现有工作试图通过线程到内核映射 [21]–[51] 或内存分配策略 [22]–[34] 来最小化内存访问延迟。MCM-GPU 系统也存在类似的问题，其中主要瓶颈是 GPM 间互连带宽。此外，还提出了改进的 CTA 调度，以利用单片 GPU 的 CTA 间位置、更高的缓存命中率和内存库级并行性 [37]–[52]。在我们的示例中，分布式 CTA 调度以及首次接触内存映射策略利用了内核内和多个内核之间的 CTA 间位置，并提高了新引入的 GPM 端 L1.5 缓存的效率。</p> 
<p>最后，我们建议通过硬件创新和对驱动程序软件的扩展，将 MCM-GPU 公开为单个逻辑 GPU，以提供程序员和操作系统透明的执行。虽然已经有研究提出了有效利用多GPU系统的技术[20]–[36]，但没有一个提案提供适用于MCM-GPU的完全透明的方法。</p> 
<h2><a id="8_127"></a>第8节结论</h2> 
<p>当今许多重要的 GPU 应用程序都可以通过 GPU 计算能力进行扩展，而 exas-cale 计算和人工智能等许多领域的未来进展将取决于 GPU 性能的持续增长。构建更强大的 GPU 的最大挑战来自晶体管密度缩放的终点，以及无法进一步增加单个单片 GPU 芯片的面积。在本文中，我们提出了 MCM-GPU，这是一种新颖的 GPU 架构，可在封装级别扩展 GPU 性能，超出当今的可能性。为此，我们将 GPU 划分为易于制造的基本构建块 （GPM），并利用电路社区开发的信号技术进步，以节能的方式将 GPM 连接到封装上。</p> 
<p>我们讨论了 MCM-GPU 架构的细节，并表明我们的 MCM-GPU 设计自然而然地适合于 NUMA 系统中的许多历史观察结果。我们探讨了 MCM-GPU 中硬件缓存、CTA 调度和数据放置的相互作用，以优化此架构。我们表明，通过这些优化，256 个 SM 的 MCM-GPU 比具有 45 个 SM 的最大单片 GPU 实现了 5.128% 的加速。此外，它的性能比同等装备的独立多 GPU 高 26.8%，其性能与假设的单片 GPU 的性能相差 10% 以内，而假设的单片 GPU 无法根据今天的技术路线图构建。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2e9ad18d75607eec9c9cf51d94dd1c49/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">vue-socket.io以及原生websocket的使用</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ac1477b7499c88875a954691df3e1669/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">androidstudio设置内存</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>