<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>dma_alloc_writecombine - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="dma_alloc_writecombine" />
<meta property="og:description" content="先理解cache的作用
CPU在访问内存时，首先判断所要访问的内容是否在Cache中，如果在，就称为“命中（hit）”，此时CPU直接从Cache中调用该内容；否则，就 称为“ 不命中”，CPU只好去内存中调用所需的子程序或指令了。CPU不但可以直接从Cache中读出内容，也可以直接往其中写入内容。由于Cache的存取速 率相当快，使得CPU的利用率大大提高，进而使整个系统的性能得以提升。
Cache的一致性就是直Cache中的数据，与对应的内存中的数据是一致的。
DMA是直接操作总线地址的，这里先当作物理地址来看待吧（系统总线地址和物理地址只是观察内存的角度不同）。如果cache缓存的内存区域不包括DMA分配到的区域，那么就没有一致性的问题。但是如果cache缓存包括了DMA目的地址的话，会出现什么什么问题呢？
问题出在，经过DMA操作，cache缓存对应的内存数据已经被修改了，而CPU本身不知道（DMA传输是不通过CPU的），它仍然认为cache中的数 据就是内存中的数据，以后访问Cache映射的内存时，它仍然使用旧的Cache数据。这样就发生Cache与内存的数据“不一致性”错误。
题外话：好像2.6.29内核中，6410的总线地址和物理地址是一样的，因为我在查看vir_to_bus函数的时候，发现在/arch/arm/linux/asm/memory.h中这样定义： #ifndef __virt_to_bus
#define __virt_to_bus __virt_to_phys
#define __bus_to_virt __phys_to_virt
#endif
而且用source Insight搜索了一遍，没有发现6410相关的代码中，重新定义__vit_to_bus，因此擅自认为2.6内核中，6410的总线地址就是物理地址。希望高手指点。
顺便提一下，总线地址是从设备角度上看到的内存，物理地址是CPU的角度看到的未经过转换的内存（经过转换的是虚拟地址）
由上面可以看出，DMA如果使用cache，那么一定要考虑cache的一致性。解决DMA导致的一致性的方法最简单的就是禁止DMA目标地址范围内的cache功能。但是这样就会牺牲性能。
因此在DMA是否使用cache的问题上，可以根据DMA缓冲区期望保留的的时间长短来决策。DAM的映射就分为：一致性DMA映射和流式DMA映射。
一致性DMA映射申请的缓存区能够使用cache，并且保持cache一致性。一致性映射具有很长的生命周期，在这段时间内占用的映射寄存器，即使不使用也不会释放。生命周期为该驱动的生命周期
流式DMA映射实现比较复杂，因为没具体了解，就不说明了。只知道种方式的生命周期比较短，而且禁用cache。一些硬件对流式映射有优化。建立流式DMA映射，需要告诉内核数据的流动方向。
因为LCD随时都在使用，因此在Frame buffer驱动中，使用一致性DMA映射
上面的代码中用到 dma_alloc_writecombine函数，另外还有一个一致性DMA映射函数dma_alloc_coherent
两者的区别在于：
查看两者的源代码 /*
* Allocate DMA-coherent memory space and return both the kernel remapped
* virtual and bus address for that space.
*/
void *
dma_alloc_coherent(struct device *dev, size_t size, dma_addr_t *handle, gfp_t gfp)
{
void *memory;
if (dma_alloc_from_coherent(dev, size, handle, &amp;memory))" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/6e536c6d1baacc7a52e8e73d29cb76e9/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2011-08-08T17:41:56+08:00" />
<meta property="article:modified_time" content="2011-08-08T17:41:56+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">dma_alloc_writecombine</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="blog_text" class="cnt"> 
 <p><font face="SimSun"><strong><span style="color:#000000"><span style="font-size:16px">先理解cache的作用</span><br> <span style="font-size:16px">CPU在访问内存时，首先判断所要访问的内容是否在Cache中，如果在，就称为“命中（hit）”，此时CPU直接从Cache中调用该内容；否则，就 称为“ 不命中”，CPU只好去内存中调用所需的子程序或指令了。CPU不但可以直接从Cache中读出内容，也可以直接往其中写入内容。由于Cache的存取速 率相当快，使得CPU的利用率大大提高，进而使整个系统的性能得以提升。</span><br> <br> <span style="font-size:16px">Cache的一致性就是直Cache中的数据，与对应的内存中的数据是一致的。</span><br> <br> <span style="font-size:16px">DMA是直接操作总线地址的，这里先当作物理地址来看待吧（系统总线地址和物理地址只是观察内存的角度不同）。如果cache缓存的内存区域不包括DMA分配到的区域，那么就没有一致性的问题。但是如果cache缓存包括了DMA目的地址的话，会出现什么什么问题呢？</span><br> <br> <span style="font-size:16px">问题出在，经过DMA操作，cache缓存对应的内存数据已经被修改了，而CPU本身不知道（DMA传输是不通过CPU的），它仍然认为cache中的数 据就是内存中的数据，以后访问Cache映射的内存时，它仍然使用旧的Cache数据。这样就发生Cache与内存的数据“不一致性”错误。</span><br> <br> <span style="font-size:16px">题外话：好像2.6.29内核中，6410的总线地址和物理地址是一样的，因为我在查看vir_to_bus函数的时候，发现在/arch/arm/linux/asm/memory.h中这样定义：</span></span> <br> <span style="color:#0000ff"><span style="font-size:16px">#ifndef __virt_to_bus</span><br> <span style="font-size:16px">#define __virt_to_bus    __virt_to_phys</span><br> <span style="font-size:16px">#define __bus_to_virt    __phys_to_virt</span><br> <span style="font-size:16px">#endif</span></span><br> <span style="color:#000000"><span style="font-size:16px">而且用source Insight搜索了一遍，没有发现6410相关的代码中，重新定义__vit_to_bus，因此擅自认为2.6内核中，6410的总线地址就是物理地址。希望高手指点。</span><br> <br> <span style="font-size:16px">顺便提一下，总线地址是从设备角度上看到的内存，物理地址是CPU的角度看到的未经过转换的内存（经过转换的是虚拟地址）</span><br> <br> <span style="font-size:16px">由上面可以看出，DMA如果使用cache，那么一定要考虑cache的一致性。解决DMA导致的一致性的方法最简单的就是禁止DMA目标地址范围内的cache功能。但是这样就会牺牲性能。</span><br> <br> <span style="font-size:16px">因此在DMA是否使用cache的问题上，可以根据DMA缓冲区期望保留的的时间长短来决策。DAM的映射就分为：一致性DMA映射和流式DMA映射。</span><br> <br> <span style="font-size:16px">一致性DMA映射申请的缓存区能够使用cache，并且保持cache一致性。一致性映射具有很长的生命周期，在这段时间内占用的映射寄存器，即使不使用也不会释放。生命周期为该驱动的生命周期</span><br> <br> <span style="font-size:16px">流式DMA映射实现比较复杂，因为没具体了解，就不说明了。只知道种方式的生命周期比较短，而且禁用cache。一些硬件对流式映射有优化。建立流式DMA映射，需要告诉内核数据的流动方向。</span><br> <br> <br> <span style="font-size:16px">因为LCD随时都在使用，因此在Frame buffer驱动中，使用一致性DMA映射</span><br> <span style="font-size:16px">上面的代码中用到</span></span> <span style="color:#000000"><span style="font-size:16px">dma_alloc_writecombine函数，另外还有一个一致性DMA映射函数dma_alloc_coherent</span><br> <br> <span style="font-size:16px">两者的区别在于：</span><br> <span style="font-size:16px">查看两者的源代码</span></span> <br> <span style="color:#0000ff"><span style="font-size:16px">/*</span><br> <span style="font-size:16px">* Allocate DMA-coherent memory space and return both the kernel remapped</span><br> <span style="font-size:16px">* virtual and bus address for that space.</span><br> <span style="font-size:16px">*/</span><br> <span style="font-size:16px">void *</span><br> <span style="font-size:16px">dma_alloc_coherent(struct device *dev, size_t size, dma_addr_t *handle, gfp_t gfp)</span><br> <span style="font-size:16px">{<!-- --></span><br> <span style="font-size:16px">void *memory;</span><br> <br> <span style="font-size:16px">if (dma_alloc_from_coherent(dev, size, handle, &amp;memory))</span><br> <span style="font-size:16px">return memory;</span><br> <br> <span style="font-size:16px">if (arch_is_coherent()) {<!-- --></span><br> <span style="font-size:16px">void *virt;</span><br> <br> <span style="font-size:16px">virt = kmalloc(size, gfp);</span><br> <span style="font-size:16px">if (!virt)</span><br> <span style="font-size:16px">return NULL;</span><br> <span style="font-size:16px">*handle =  virt_to_dma(dev, virt);</span><br> <br> <span style="font-size:16px">return virt;</span><br> <span style="font-size:16px">}</span><br> <br> <span style="font-size:16px">return __dma_alloc(dev, size, handle, gfp,</span><br> <span style="color:#ff0000"><span style="font-size:16px">pgprot_noncached(pgprot_kernel));</span><br> <span style="color:#000000"><span style="font-size:16px">}</span></span></span><br> <br> <span style="font-size:16px">/*</span><br> <span style="font-size:16px">* Allocate a writecombining region, in much the same way as</span><br> <span style="font-size:16px">* dma_alloc_coherent above.</span><br> <span style="font-size:16px">*/</span><br> <span style="font-size:16px">void *</span><br> <span style="font-size:16px">dma_alloc_writecombine(struct device *dev, size_t size, dma_addr_t *handle, gfp_t gfp)</span><br> <span style="font-size:16px">{<!-- --></span><br> <span style="font-size:16px">return __dma_alloc(dev, size, handle, gfp,</span><br> <span style="color:#ff0000"><span style="font-size:16px">pgprot_writecombine(pgprot_kernel)</span></span><span style="font-size:16px">);</span><br> <span style="font-size:16px">}</span></span><br> </strong></font></p> 
 <p><font face="SimSun"><strong><span style="color:#0000ff"><span style="font-size:16px">#define pgprot_noncached(prot)  __pgprot(pgprot_val(prot) &amp;</span><span style="color:#ff0000"><span style="font-size:16px">~(L_PTE_CACHEABLE | L_PTE_BUFFERABLE)</span></span><span style="font-size:16px">)</span><br> <span style="font-size:16px">#define pgprot_writecombine(prot) __pgprot(pgprot_val(prot) &amp;</span><span style="color:#ff0000"><span style="font-size:16px">~L_PTE_CACHEABLE</span></span><span style="font-size:16px">)</span></span></strong></font></p> 
 <p><span style="font-family:SimSun"><strong><span style="color:#000000"><span style="font-size:16px">再结合网上的资料（不过我感觉那文章写的有些问题，我修改了一下），由上面代码可以看出，两个函数都调用了__dma_alloc函数，区别只在于最后一个参数。</span></span></strong></span></p> 
 <p><span style="font-family:SimSun"><strong><span style="color:#000000"><span style="font-size:16px">dma_alloc_coherent 在 arm 平台上会禁止页表项中的 C （Cacheable） 域以及 B (Bufferable)域。而 dma_alloc_writecombine 只禁止 C （Cacheable） 域.</span></span></strong></span></p> 
 <p><span style="font-family:SimSun"><strong><span style="color:#000000"><span style="font-size:16px"> C 代表是否使用高速缓冲存储器， 而 B 代表是否使用写缓冲区。</span></span></strong></span></p> 
 <p><span style="font-family:SimSun"><strong><span style="color:#000000"><span style="font-size:16px">这样，dma_alloc_writecombine 分配出来的内存不使用缓存，但是会使用写缓冲区。而 dma_alloc_coherent  则二者都不使用。</span></span></strong></span></p> 
 <span style="font-family:SimSun"><strong><span style="color:#000000"><span style="font-size:16px">C B 位的具体含义</span><br> <span style="font-size:16px">0 0 无cache，无写缓冲；任何对memory的读写都反映到总线上。对 memory 的操作过程中CPU需要等待。</span><br> <span style="font-size:16px">0 1 无cache，有写缓冲；读操作直接反映到总线上；写操作，CPU将数据写入到写缓冲后继续运行，由写缓冲进行写回操作。</span><br> <span style="font-size:16px">1 0 有cache，写通模式；读操作首先考虑cache hit；写操作时直接将数据写入写缓冲，如果同时出现cache hit，那么也更新cache。</span><br> <span style="font-size:16px">1 1 有cache，写回模式；读操作首先考虑cache hit；写操作也首先考虑cache hit。</span><br> <br> <span style="font-size:16px">这样，两者的区别就很清楚了。</span></span> <br> <br> <span style="color:#ff0000"><span style="font-size:16px">A</span></span> <span style="color:#000000"> <span style="font-size:16px">= dma_alloc_writecombine(struct device *</span></span><span style="color:#ff0000"><span style="font-size:16px">dev</span></span><span style="color:#000000"><span style="font-size:16px">, size_t</span></span> <span style="color:#ff0000"><span style="font-size:16px">size</span></span><span style="color:#000000"><span style="font-size:16px">,dma_addr_t *</span></span><span style="color:#ff0000"><span style="font-size:16px">handle</span></span><span style="color:#000000"><span style="font-size:16px">, gfp_t</span></span> <span style="color:#ff0000"><span style="font-size:16px">gfp</span></span><span style="color:#000000"><span style="font-size:16px">);</span></span><br> <br> <span style="color:#000000"><span style="font-size:16px">含义：</span><br> <span style="font-size:16px">A          : 内存的虚拟起始地址，在内核要用此地址来操作所分配的内存</span><br> <span style="font-size:16px">dev      : 可以平台初始化里指定，主要是用到dma_mask之类参数，可参考framebuffer</span><br> <span style="font-size:16px">size      : 实际分配大小，传入dma_map_size即可</span><br> <span style="font-size:16px">handle: 返回的内存物理地址，dma就可以用。</span><br> <br> </span></strong></span> 
 <p><span style="font-family:SimSun"><strong><span style="color:#000000"><span style="font-size:16px">A和hanle是一一对应的，A是虚拟地址，而handle是总线地址。对任意一个操作都将改变写缓冲区内容。</span></span></strong></span></p> 
 <p><span style="font-family:SimSun"><strong><span style="color:#000000"><span style="font-size:16px">copy from:</span></span><span style="font-size:16px">http://xmxohy.blog.163.com/blog/static/53469584201082734630713/</span></strong></span></p> 
</div> 
<br>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3473a12cac71dee601e5ea653c6936e7/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">HDU1237简单计算器</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/bf015ce89b0c76934c216d55655d65b9/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">详细介绍c&#43;&#43;中的类对象内存模型</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>