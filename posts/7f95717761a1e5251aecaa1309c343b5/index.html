<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Node.js学习笔记 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Node.js学习笔记" />
<meta property="og:description" content="// 这是路由模块 // 1. 导入 express const express = require(&#39;express&#39;) // 2. 创建路由对象 const router = express.Router() // 3. 挂载具体的路由 router.get(&#39;/user/list&#39;, (req, res) =&gt; { res.send(&#39;Get user list.&#39;) }) router.post(&#39;/user/add&#39;, (req, res) =&gt; { res.send(&#39;Add new user.&#39;) }) // 4. 向外导出路由对象 module.exports = router 介绍： 此文章为黑马程序员视频参考笔记
仅供回顾内容参考
目录
介绍： 一、初识Node.js
1.1Node.js是什么，它是用来做什么的？
1.2node.js能干什么？
1.3前端用nodejs能做什么
1.4nodejs可以用来做什么
1.5nodejs 具体是做什么用的
1.6 node能做什么?
1.7node.js中的JavaScript运行环境 1.8node.js的学习路径 二、fs文件系统模块
2.1 读取指定文件中的内容
2.2 写入指定文件内容
2.3 成绩管理练习
2.4 fs模块-路径动态拼接问题" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/7f95717761a1e5251aecaa1309c343b5/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-12-05T17:00:56+08:00" />
<meta property="article:modified_time" content="2022-12-05T17:00:56+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Node.js学习笔记</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <pre><code class="language-javascript">// 这是路由模块
// 1. 导入 express
const express = require('express')
// 2. 创建路由对象
const router = express.Router()

// 3. 挂载具体的路由
router.get('/user/list', (req, res) =&gt; {
  res.send('Get user list.')
})
router.post('/user/add', (req, res) =&gt; {
  res.send('Add new user.')
})

// 4. 向外导出路由对象
module.exports = router
</code></pre> 
<h2 id="%C2%A0%E4%B8%80%E3%80%81%E5%88%9D%E8%AF%86Node.js"><strong> 介绍：        </strong></h2> 
<blockquote> 
 <p><strong>                此文章为黑马程序员视频参考笔记</strong></p> 
 <p><strong>                仅供回顾内容参考</strong></p> 
</blockquote> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%C2%A0%E4%B8%80%E3%80%81%E5%88%9D%E8%AF%86Node.js-toc" style="margin-left:0px;"><a href="#%C2%A0%E4%B8%80%E3%80%81%E5%88%9D%E8%AF%86Node.js" rel="nofollow"> 介绍：        </a></p> 
<p id="-toc" style="margin-left:0px;"></p> 
<p id="-toc" style="margin-left:0px;"></p> 
<p id="%E4%B8%80%E3%80%81%E5%88%9D%E8%AF%86Node.js-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%E5%88%9D%E8%AF%86Node.js" rel="nofollow">一、初识Node.js</a></p> 
<p id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A01.1Node.js%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E5%AE%83%E6%98%AF%E7%94%A8%E6%9D%A5%E5%81%9A%E4%BB%80%E4%B9%88%E7%9A%84%EF%BC%9F-toc" style="margin-left:0px;"><a href="#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A01.1Node.js%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E5%AE%83%E6%98%AF%E7%94%A8%E6%9D%A5%E5%81%9A%E4%BB%80%E4%B9%88%E7%9A%84%EF%BC%9F" rel="nofollow">        1.1Node.js是什么，它是用来做什么的？</a></p> 
<p id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A01.2node.js%E8%83%BD%E5%B9%B2%E4%BB%80%E4%B9%88%EF%BC%9F-toc" style="margin-left:40px;"><a href="#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A01.2node.js%E8%83%BD%E5%B9%B2%E4%BB%80%E4%B9%88%EF%BC%9F" rel="nofollow">        1.2node.js能干什么？</a></p> 
<p id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A01.3%E5%89%8D%E7%AB%AF%E7%94%A8nodejs%E8%83%BD%E5%81%9A%E4%BB%80%E4%B9%88-toc" style="margin-left:40px;"><a href="#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A01.3%E5%89%8D%E7%AB%AF%E7%94%A8nodejs%E8%83%BD%E5%81%9A%E4%BB%80%E4%B9%88" rel="nofollow">        1.3前端用nodejs能做什么</a></p> 
<p id="%C2%A01.4nodejs%E5%8F%AF%E4%BB%A5%E7%94%A8%E6%9D%A5%E5%81%9A%E4%BB%80%E4%B9%88-toc" style="margin-left:40px;"><a href="#%C2%A01.4nodejs%E5%8F%AF%E4%BB%A5%E7%94%A8%E6%9D%A5%E5%81%9A%E4%BB%80%E4%B9%88" rel="nofollow">         1.4nodejs可以用来做什么</a></p> 
<p id="%C2%A01.5nodejs%20%E5%85%B7%E4%BD%93%E6%98%AF%E5%81%9A%E4%BB%80%E4%B9%88%E7%94%A8%E7%9A%84-toc" style="margin-left:40px;"><a href="#%C2%A01.5nodejs%20%E5%85%B7%E4%BD%93%E6%98%AF%E5%81%9A%E4%BB%80%E4%B9%88%E7%94%A8%E7%9A%84" rel="nofollow">         1.5nodejs 具体是做什么用的</a></p> 
<p id="1.6%20node%E8%83%BD%E5%81%9A%E4%BB%80%E4%B9%88%3F-toc" style="margin-left:40px;"><a href="#1.6%20node%E8%83%BD%E5%81%9A%E4%BB%80%E4%B9%88%3F" rel="nofollow">        1.6 node能做什么?</a></p> 
<p id="1.7node.js%E4%B8%AD%E7%9A%84JavaScript%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83%C2%A0-toc" style="margin-left:40px;"><a href="#1.7node.js%E4%B8%AD%E7%9A%84JavaScript%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83%C2%A0" rel="nofollow">        1.7node.js中的JavaScript运行环境 </a></p> 
<p id="1.8node.js%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%B7%AF%E5%BE%84%C2%A0-toc" style="margin-left:40px;"><a href="#1.8node.js%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%B7%AF%E5%BE%84%C2%A0" rel="nofollow">        1.8node.js的学习路径 </a></p> 
<p id="%E4%BA%8C%E3%80%81fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A8%A1%E5%9D%97-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A8%A1%E5%9D%97" rel="nofollow">二、fs文件系统模块</a></p> 
<p id="%C2%A0%20%C2%A02.1%20%E8%AF%BB%E5%8F%96%E6%8C%87%E5%AE%9A%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E5%86%85%E5%AE%B9-toc" style="margin-left:40px;"><a href="#%C2%A0%20%C2%A02.1%20%E8%AF%BB%E5%8F%96%E6%8C%87%E5%AE%9A%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E5%86%85%E5%AE%B9" rel="nofollow">        2.1 读取指定文件中的内容</a></p> 
<p id="%C2%A0%202.2%20%E5%86%99%E5%85%A5%E6%8C%87%E5%AE%9A%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9-toc" style="margin-left:40px;"><a href="#%C2%A0%202.2%20%E5%86%99%E5%85%A5%E6%8C%87%E5%AE%9A%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9" rel="nofollow">        2.2 写入指定文件内容</a></p> 
<p id="2.3%20%E6%88%90%E7%BB%A9%E7%AE%A1%E7%90%86%E7%BB%83%E4%B9%A0-toc" style="margin-left:40px;"><a href="#2.3%20%E6%88%90%E7%BB%A9%E7%AE%A1%E7%90%86%E7%BB%83%E4%B9%A0" rel="nofollow">        2.3 成绩管理练习</a></p> 
<p id="2.4%20fs%E6%A8%A1%E5%9D%97-%E8%B7%AF%E5%BE%84%E5%8A%A8%E6%80%81%E6%8B%BC%E6%8E%A5%E9%97%AE%E9%A2%98-toc" style="margin-left:40px;"><a href="#2.4%20fs%E6%A8%A1%E5%9D%97-%E8%B7%AF%E5%BE%84%E5%8A%A8%E6%80%81%E6%8B%BC%E6%8E%A5%E9%97%AE%E9%A2%98" rel="nofollow">        2.4 fs模块-路径动态拼接问题</a></p> 
<p id="%E4%B8%89%E3%80%81path%E8%B7%AF%E5%BE%84%E6%A8%A1%E5%9D%97-toc" style="margin-left:0px;"><a href="#%E4%B8%89%E3%80%81path%E8%B7%AF%E5%BE%84%E6%A8%A1%E5%9D%97" rel="nofollow">三、path路径模块</a></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.1%20%E4%BB%80%E4%B9%88%E6%98%AFpath%E8%B7%AF%E5%BE%84%E6%A8%A1%E5%9D%97-toc" style="margin-left:40px;"><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.1%20%E4%BB%80%E4%B9%88%E6%98%AFpath%E8%B7%AF%E5%BE%84%E6%A8%A1%E5%9D%97" rel="nofollow">        3.1 什么是path路径模块</a></p> 
<p id="%C2%A03.3%20%E6%97%B6%E9%92%9F%E6%A1%88%E5%88%97-toc" style="margin-left:40px;"><a href="#%C2%A03.3%20%E6%97%B6%E9%92%9F%E6%A1%88%E5%88%97" rel="nofollow">         3.3 时钟案列  </a></p> 
<p id="%E5%9B%9B%E3%80%81http%20%E6%A8%A1%E5%9D%97-toc" style="margin-left:0px;"><a href="#%E5%9B%9B%E3%80%81http%20%E6%A8%A1%E5%9D%97" rel="nofollow">四、http 模块</a></p> 
<p id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A04.1%E4%BB%80%E4%B9%88%E6%98%AFhttp%E6%A8%A1%E5%9D%97-toc" style="margin-left:40px;"><a href="#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A04.1%E4%BB%80%E4%B9%88%E6%98%AFhttp%E6%A8%A1%E5%9D%97" rel="nofollow">        4.1什么是http模块</a></p> 
<p id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A04.2%E5%88%9B%E5%BB%BA%E5%9F%BA%E6%9C%AC%E7%9A%84web%E6%9C%8D%E5%8A%A1%E5%99%A8-toc" style="margin-left:40px;"><a href="#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A04.2%E5%88%9B%E5%BB%BA%E5%9F%BA%E6%9C%AC%E7%9A%84web%E6%9C%8D%E5%8A%A1%E5%99%A8" rel="nofollow">         4.2创建基本的web服务器</a></p> 
<p id="%E4%BA%94%E3%80%81node.js%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%9D%97%E5%8C%96-toc" style="margin-left:0px;"><a href="#%E4%BA%94%E3%80%81node.js%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%9D%97%E5%8C%96" rel="nofollow">五、node.js中的模块化</a></p> 
<p id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A05.1%E6%A8%A1%E5%9D%97%E5%8C%96%E5%88%86%E7%B1%BB-toc" style="margin-left:0px;"><a href="#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A05.1%E6%A8%A1%E5%9D%97%E5%8C%96%E5%88%86%E7%B1%BB" rel="nofollow">        5.1模块化分类</a></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A05.2%E5%8A%A0%E8%BD%BD%E6%A8%A1%E5%9D%97-toc" style="margin-left:40px;"><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A05.2%E5%8A%A0%E8%BD%BD%E6%A8%A1%E5%9D%97" rel="nofollow">         5.2加载模块</a></p> 
<p id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A05.3%20%E6%A8%A1%E5%9D%97%E4%BD%9C%E7%94%A8%E5%9F%9F-toc" style="margin-left:40px;"><a href="#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A05.3%20%E6%A8%A1%E5%9D%97%E4%BD%9C%E7%94%A8%E5%9F%9F" rel="nofollow">        5.3 模块作用域</a></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%205.5%20module%E5%AF%B9%E8%B1%A1%C2%A0-toc" style="margin-left:40px;"><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%205.5%20module%E5%AF%B9%E8%B1%A1%C2%A0" rel="nofollow">        5.5 module对象 </a></p> 
<p id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A05.6%20exports%E5%AF%B9%E8%B1%A1%C2%A0-toc" style="margin-left:40px;"><a href="#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A05.6%20exports%E5%AF%B9%E8%B1%A1%C2%A0" rel="nofollow">        5.6 exports对象 </a></p> 
<p id="%C2%A05.7%20npm%20%E4%B8%8E%E5%8C%85-toc" style="margin-left:40px;"><a href="#%C2%A05.7%20npm%20%E4%B8%8E%E5%8C%85" rel="nofollow"> 5.7 npm 与包</a></p> 
<p id="%C2%A0%20%C2%A05.8%20%E6%B7%98%E5%AE%9D%E9%95%9C%E5%83%8F%20cnpm%20%E9%85%8D%E7%BD%AE-toc" style="margin-left:40px;"><a href="#%C2%A0%20%C2%A05.8%20%E6%B7%98%E5%AE%9D%E9%95%9C%E5%83%8F%20cnpm%20%E9%85%8D%E7%BD%AE" rel="nofollow">   5.8 淘宝镜像 cnpm 配置</a></p> 
<p id="5.9%20devDependencies%20%E7%BB%93%E7%82%B9%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0-toc" style="margin-left:40px;"><a href="#5.9%20devDependencies%20%E7%BB%93%E7%82%B9%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0" rel="nofollow">5.9 devDependencies 结点        </a></p> 
<p id="5.9.1%20nrm%E5%B7%A5%E5%85%B7%20%E8%A7%A3%E5%86%B3%E4%B8%8B%E5%8C%85%E9%80%9F%E5%BA%A6%E6%85%A2%E7%9A%84%E9%97%AE%E9%A2%98%C2%A0-toc" style="margin-left:40px;"><a href="#5.9.1%20nrm%E5%B7%A5%E5%85%B7%20%E8%A7%A3%E5%86%B3%E4%B8%8B%E5%8C%85%E9%80%9F%E5%BA%A6%E6%85%A2%E7%9A%84%E9%97%AE%E9%A2%98%C2%A0" rel="nofollow">5.9.1 nrm工具 解决下包速度慢的问题 </a></p> 
<p id="5.9..2%20%E9%A1%B9%E7%9B%AE%E5%8C%85%C2%A0-toc" style="margin-left:40px;"><a href="#5.9..2%20%E9%A1%B9%E7%9B%AE%E5%8C%85%C2%A0" rel="nofollow">5.9..2 项目包 </a></p> 
<hr id="hr-toc"> 
<p></p> 
<p></p> 
<h2></h2> 
<h2></h2> 
<h2 id="%E4%B8%80%E3%80%81%E5%88%9D%E8%AF%86Node.js"><strong>一、初识Node.js</strong></h2> 
<h2 id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A01.1Node.js%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E5%AE%83%E6%98%AF%E7%94%A8%E6%9D%A5%E5%81%9A%E4%BB%80%E4%B9%88%E7%9A%84%EF%BC%9F">        1.1Node.js是什么，它是用来做什么的？</h2> 
<blockquote> 
 <p>对一些特殊用例进行优化，提供替代的API，使得V8在非浏览器环境下运行得更好，V8引擎执行Javascript的速度非常快，性能非常好，基于ChromeJavaScript运行时建立的平台，用于方便地搭建响应速度快、易于扩展的网络应用。</p> 
 <p>发布于2009年5月，由RyanDahl开发，<strong>是一个基于Chrome V8引擎的JavaScript运行环境</strong>，使用了一个事件驱动、非阻塞式I/O模型，让JavaScript运行在服务端的开发平台，它让JavaScript成为与PHP、Python、Perl、<a href="https://so.csdn.net/so/search?q=Ruby&amp;spm=1001.2101.3001.7020" title="Ruby">Ruby</a>等服务端语言平起平坐的脚本语言。</p> 
 <p>功能模块：Node使用Module模块去划分不同的功能，以简化应用的开发。Modules模块有点像C++语言中的类库。</p> 
 <p>每一个Node的类库都包含了十分丰富的各类函数，比如http模块就包含了和http功能相关的很多函数，可以帮助开发者很容易地对比如http,tcp/udp等进行操作，还可以很容易的创建http和tcp/udp的服务器。</p> 
 <p>要在程序中使用模块是十分方便的，只需要如下：在这里，引入了http类库，并且对http类库的引用存放在http变量中了。</p> 
 <p>这个时候，Node会在我们应用中搜索是否存在node_modules的目录，并且搜索这个目录中是否存在http的模块。</p> 
 <p>如果找不到这个目录，则会到全局模块缓存中去寻找，用户可以通过相对或者绝对路径，指定模块的位置。</p> 
</blockquote> 
<h3 id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A01.2node.js%E8%83%BD%E5%B9%B2%E4%BB%80%E4%B9%88%EF%BC%9F">        1.2node.js能干什么？</h3> 
<blockquote> 
 <p>        </p> 
 <p>1.JavaScript为HTML设计师提供了一种编程工具HTML创作者往往都不是程序员，但是JavaScript却是一种只拥有极其简单的语法的脚本语言！</p> 
 <p>几乎每个人都有能力将短小的代码片断放入他们的HTML页面当中。</p> 
 <p>2.JavaScript可以将动态的文本放入HTML页面类似于这样的一段JavaScript声明可以将一段可变的文本放入HTML页面：document.write(""+name+"")3.JavaScript可以对事件作出响应可以将JavaScript设置为当某事件发生时才会被执行，例如页面载入完成或者当用户点击某个HTML元素时。</p> 
 <p>4.JavaScript可以读写HTML元素JavaScript可以读取及改变HTML元素的内容。</p> 
 <p>5.JavaScript可被用来验证数据在数据被提交到服务器之前，JavaScript可被用来验证这些数据。</p> 
 <p>6.JavaScript可被用来检测访问者的浏览器JavaScript可被用来检测访问者的浏览器，并根据所检测到的浏览器，为这个浏览器载入相应的页面。</p> 
 <p>7.JavaScript可被用来创建cookiesJavaScript可被用来存储和取回位于访问者的计算机中的信息</p> 
</blockquote> 
<h3 id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A01.3%E5%89%8D%E7%AB%AF%E7%94%A8nodejs%E8%83%BD%E5%81%9A%E4%BB%80%E4%B9%88">        1.3前端用nodejs能做什么</h3> 
<blockquote> 
 <p>        </p> 
 <p>到底是什么？是一个JavaScript的编译环境，当前端语言JavaScript在写完之后可以交给进行编译和解释，它的存在对于JavaScript有了质的飞跃。</p> 
 <p>下面就是一个简单的命令#node目前，在大部分领域都占有一席之地，尤其是I/O密集型的。比如Web开发，微服务，前端构建等。</p> 
 <p>不少大型网站都是使用作为后台开发语言的，用的最多的就是使用做前端渲染和架构优化，比如淘宝双十一、去哪儿网的PC端核心业务等。</p> 
 <p>另外，有不少知名的前端库也是使用开发的，如Webpack是一个强大的打包器，React/Vue是成熟的前端组件化框架。</p> 
 <p>通常被用来开发低延迟的网络应用，也就是那些需要在服务器端环境和前端实时收集和交换数据的应用（API、即时聊天、微服务）。</p> 
 <p>阿里巴巴、腾讯、Qunar、百度、PayPal、道琼斯、沃尔玛和LinkedIn都采用了框架搭建应用。</p> 
 <p>另外，编写的包管理器npm已成为开源包管理了领域最好的生态，直接到2017年10月份，有模块超过47万，每周下载量超过32亿次，每个月有超过700万开发者使用npm。</p> 
 <p>是一个对于前端工作者不可或缺的工具。尤其是对于JavaScript有着巨大的提升，现阶段的应用已经有了非常蓬勃的发展。对于的学习和熟练运用，必不可少！</p> 
</blockquote> 
<h3 id="%C2%A01.4nodejs%E5%8F%AF%E4%BB%A5%E7%94%A8%E6%9D%A5%E5%81%9A%E4%BB%80%E4%B9%88">         1.4nodejs可以用来做什么</h3> 
<blockquote> 
 <p>        1、nodejs搭配MongoDB作后端；</p> 
 <p>        2、nodejs搭配“终端”作前端的编译工具使用；</p> 
 <p>        3、编辑一些小工具，例如“网络爬虫”啥的；</p> 
 <p>        4、在不使用浏览器的控制台功能时，可用nodejs达到同样的目的</p> 
</blockquote> 
<h3 id="%C2%A01.5nodejs%20%E5%85%B7%E4%BD%93%E6%98%AF%E5%81%9A%E4%BB%80%E4%B9%88%E7%94%A8%E7%9A%84">         1.5nodejs 具体是做什么用的</h3> 
<blockquote> 
 <p>是一个运行在chromeJavascript运行环境下（俗称GoogleV8引擎）的开发平台，用来方便快捷的创建服务器端网络应用程序。</p> 
 <p>你可以把它理解为一个轻量级的JSP或PHP环境，但是用来开发Web应用的话，有时要便捷很多。很多人都不明白，为什么一个javascript的东西用在了服务器端的开发上。</p> 
 <p>一般认为javascript是浏览器端的脚本语言，但是google将其再开发，用来作为服务器端脚本环境，其性能自称比Python、Perl、PHP还要快。</p> 
 <p>的最大优点是处理并行访问，如果一个web应用程序同时会有很多访问连接，就能体现使用的优势。另一个好处是，使用javascript作为服务器端脚本语言，可以消除一些与浏览器端js脚本的冲突。</p> 
 <p>甚至发挥javascript动态编程的特性，在服务器与浏览器之间建立直接的动态程序。</p> 
</blockquote> 
<h3 id="1.6%20node%E8%83%BD%E5%81%9A%E4%BB%80%E4%B9%88%3F">        1.6 node能做什么?</h3> 
<blockquote> 
 <p>        </p> 
 <p>是一个运行在chromeJavascript运行环境下（俗称GoogleV8引擎）的开发平台，用来方便快捷的创建服务器端网络应用程序。</p> 
 <p>的优点是：</p> 
 <p>        1、处理并行访问，如果一个web应用程序同时会有很多访问连接，就能体现使用的优势。</p> 
 <p>        2、使用javascript作为服务器端脚本语言，可以消除一些与浏览器端js脚本的冲突。</p> 
 <p>甚至发挥javascript动态编程的特性，在服务器与浏览器之间建立直接的动态程序。</p> 
 <p>        <img alt="" height="141" src="https://images2.imgbox.com/6a/d0/VKJx96YS_o.png" width="513"></p> 
 <p></p> 
</blockquote> 
<h3 id="1.7node.js%E4%B8%AD%E7%9A%84JavaScript%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83%C2%A0">        1.7node.js中的JavaScript运行环境 </h3> 
<blockquote> 
 <p>        1、浏览器是JavaScript的前端运行环境</p> 
 <p>        2、Node.js是JavaScript的后端运行环境</p> 
 <p>        3、<strong>Node.js中无法调用DOM和BOM等浏览器内置API</strong></p> 
</blockquote> 
<h3 id="1.8node.js%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%B7%AF%E5%BE%84%C2%A0">        1.8node.js的学习路径 </h3> 
<blockquote> 
 <p><img alt="" height="69" src="https://images2.imgbox.com/8a/e0/ivfl70d3_o.png" width="680"></p> 
 <p></p> 
</blockquote> 
<h2 id="%E4%BA%8C%E3%80%81fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A8%A1%E5%9D%97">二、fs文件系统模块</h2> 
<p></p> 
<p></p> 
<h3 id="%C2%A0%20%C2%A02.1%20%E8%AF%BB%E5%8F%96%E6%8C%87%E5%AE%9A%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E5%86%85%E5%AE%B9">        2.1 读取指定文件中的内容</h3> 
<pre><code class="language-javascript">//引入fs模块读取文件内容
const fs=require('fs')
/**
 * fs.readFile()
 * path:必选参数，字符串，表示文件内容
 * option：可选参数，表示以什么编码格式来读取文件
 * callback：必选参数,文件读取完成后，通过回调函数拿到读取的结果
 */
fs.readFile('12.txt','utf8',function(err,dataStr){
    console.log(err);//读取成功为NULL 读取失败为错误对象
    console.log("---------");
    console.log(dataStr);//读取成功 这是一段测试文本 读取失败为undefined
})</code></pre> 
<h3 id="%C2%A0%202.2%20%E5%86%99%E5%85%A5%E6%8C%87%E5%AE%9A%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9">        2.2 写入指定文件内容</h3> 
<p>        </p> 
<pre><code class="language-javascript">//向指定的文件写入内容
/**
 * fs.writeFile()
 *  path:必选参数，字符串，表示文件路径
 * data [option]：表示写入的内容
 * callback：必选参数,文件写入完成后，通过回调函数拿到读取的结果
 */
 fs.writeFile('1.txt','hahahahha',function(err){
    console.log(err);//写入为NULL 写入失败为错误对象 
})</code></pre> 
<h3 id="2.3%20%E6%88%90%E7%BB%A9%E7%AE%A1%E7%90%86%E7%BB%83%E4%B9%A0">        2.3 成绩管理练习</h3> 
<pre><code class="language-TypeScript">const fs=require('fs')
fs.readFile('score.txt','utf8',(err,data)=&gt;{
   
    //判断是否读取成功
    if(err){
        return console.log('读取文件失败 \n'+err.message)
    }
    console.log("读取文件成功！"+data);
    const arrOld=data.split(" ")
    console.log(arrOld);
    const arrNew=[]
   arrOld.forEach(item =&gt; {
       arrNew.push(item.replace('=',':'))
    });
    const newStr=arrNew.join('\r\n')
//writeFile 只能用来创建文件 不能用来创建路径 并且 重新写入的数据会覆盖原本文档中的数据
    fs.writeFile('score.txt',newStr,(err)=&gt;{
        console.log(err);
        if(err){
            return console.log("写入文件失败！"+err.message);
        }
        console.log("写入文件成功");
    })
})</code></pre> 
<h3 id="2.4%20fs%E6%A8%A1%E5%9D%97-%E8%B7%AF%E5%BE%84%E5%8A%A8%E6%80%81%E6%8B%BC%E6%8E%A5%E9%97%AE%E9%A2%98">        2.4 fs模块-路径动态拼接问题</h3> 
<p>        <img alt="" height="100" src="https://images2.imgbox.com/e8/57/OJQqTS95_o.png" width="748"></p> 
<p></p> 
<pre><code class="language-TypeScript">   // __dirname 表示当前文件所处路径
        console.log(__dirname);</code></pre> 
<h2 id="%E4%B8%89%E3%80%81path%E8%B7%AF%E5%BE%84%E6%A8%A1%E5%9D%97">三、path路径模块</h2> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.1%20%E4%BB%80%E4%B9%88%E6%98%AFpath%E8%B7%AF%E5%BE%84%E6%A8%A1%E5%9D%97">        3.1 什么是path路径模块</h3> 
<p>               <img alt="" height="147" src="https://images2.imgbox.com/75/94/EkYACd7P_o.png" width="697"></p> 
<p>         </p> 
<pre><code class="language-javascript">const path =require("path")
// console.log(path);
/**
 * path.join()：可以把多个路径片段拼接为完整 的路径字符串
 * path.join([...paths])
 * ...paths&lt;string&gt; 路径片段的序列
 * 返回值&lt;string&gt;
 */
const pathStr= path.join('/a',"/b/c","../../","/d","/e")// ../会抵消前面一个路径 如/c就会被抵消掉
console.log(pathStr);//打印出来为 \a\d\e 几个../就抵消前面几个



/**
 * path.basename(path[,ext]) //获取文件路径名
 * path&lt;string&gt;必选参数，表示一个路径的字符串
 * ext&lt;string&gt;可选参数，表示文件扩展名
 * 返回:&lt;string&gt;表示路径中的最后一部分
 */
var fpath="/a/b/c/index.html"
var fullname= path.basename(fpath)
console.log(fullname); //输出 index.html
var fullname= path.basename(fpath,".html")
console.log(fullname); //输出 index




/**
 * path.extname() 获取文件扩展名部分
 * 
 */
var fpath="/a/b/c/index.html" 
let fext= path.extname(fpath)
console.log(fext);//.html</code></pre> 
<h3 id="%C2%A03.3%20%E6%97%B6%E9%92%9F%E6%A1%88%E5%88%97">         3.3 时钟案列  </h3> 
<pre><code class="language-javascript">const fs= require('fs')
const { basename } = require('path')

const path =require("path")

// 定义正则表达式
/**
 * /s 表示匹配空白字符
 * /S表示匹配非空白字符
 * 
 */
const regStyle=/&lt;style&gt;[\s\S]*&lt;\/style&gt;/
const regScript=/&lt;script&gt;[\s\S]*&lt;\/script&gt;/

fs.readFile(path.join(__dirname,"index.html"),'utf8',(err,data)=&gt;{
    console.log(err);
    if(err){
        return console.log("读取文件失败"+err.message);
    }
    // console.log(data);
    resolveCSS(data)
    resolveJS(data)
    resolveHTML(data)
})
// 3.1 定义处理 css 样式的方法
function resolveCSS(htmlStr){
    const r1 =regStyle.exec(htmlStr)
    // console.log(r1)
    //将提取出的字符串 进行替换操作
    const newCSS=r1[0].replace("&lt;style&gt;","").replace('&lt;/style&gt;',"")
    console.log(newCSS);
    // 将提取出来的内容放在index.css中去
    fs.writeFile(path.join(__dirname,"index.css"),newCSS,(err)=&gt;{
        if(err) return console.log('写入失败');
        console.log('写入成功');
    })
}
// 4.1 定义处理 js 脚本的方法
function resolveJS(htmlStr) {
    // 4.2 通过正则，提取对应的 &lt;script&gt;&lt;/script&gt; 标签内容
    const r2 = regScript.exec(htmlStr)
    // 4.3 将提取出来的内容，做进一步的处理
    const newJS = r2[0].replace('&lt;script&gt;', '').replace('&lt;/script&gt;', '')
    // 4.4 将处理的结果，写入到 clock 目录中的 index.js 文件里面
    fs.writeFile(path.join(__dirname, './clock/index.js'), newJS, function(err) {
      if (err) return console.log('写入 JavaScript 脚本失败！' + err.message)
      console.log('写入 JS 脚本成功！')
    })
  }
//   5.1定义处理HTML文本
function resolveHTML(htmlStr){
    const newHtml=htmlStr.replace(regStyle.exec(htmlStr),"&lt;link rel='stylesheet' href='index.css'/&gt;")
    .replace(regScript.exec(htmlStr),"&lt;script src='index.js'&gt;&lt;/script&gt;")
    //将替换好的文件写入html中
    fs.writeFile(path.join(__dirname,"index.html"),newHtml,(err)=&gt;{

        if(err) return "写入HTML失败！"
        console.log("写入html成功");

    })
}</code></pre> 
<h2 id="%E5%9B%9B%E3%80%81http%20%E6%A8%A1%E5%9D%97">四、http 模块</h2> 
<p>       </p> 
<h3 id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A04.1%E4%BB%80%E4%B9%88%E6%98%AFhttp%E6%A8%A1%E5%9D%97">        4.1什么是http模块</h3> 
<p>        <img alt="" height="148" src="https://images2.imgbox.com/a0/95/rfostR8E_o.png" width="695"></p> 
<p></p> 
<h3 id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A04.2%E5%88%9B%E5%BB%BA%E5%9F%BA%E6%9C%AC%E7%9A%84web%E6%9C%8D%E5%8A%A1%E5%99%A8"><strong>         4.2创建基本的web服务器</strong></h3> 
<p><strong>        </strong></p> 
<pre><code class="language-javascript">// 1.导入http模块
const http=require("http");
//调用http.createServer()方法 即可快速创建一个web服务器实列
//2.创建web 服务器实列
const server=http.createServer()
//使用服务器实验的.on（）方法，为服务器绑定一个request事件
//3.为服务器石烈绑定request事件 监听客户端的请求
server.on('request',(req,res)=&gt;{
    // 只要有客户端来请求我们自己的服务器，就会触发request 事件，从而调用这个事件处理函数
    console.log("someone require your web");
    // console.log(res);
})

//调用服务器实列的.listen（）方法 即可启动当前的web服务器是列
//4.启动服务器
server.listen(8080,()=&gt;{
    console.log('http://127.0.0.1:8080');
})</code></pre> 
<p>        req res 的方法</p> 
<pre><code class="language-javascript"> /**
     * req 是请求对象 包含了客户端相关的数据和属性
     * res 是响应对象  包含了与服务器相关的数据和属性
     */
    const url=req.url
    const method=req.method
    // console.log(url,method);
    /**
     * res.end()方法的作用
     * 要发送到客户端的字符串
     * 向客户端发送指定的内容，并结束这次请求的处理过程
     */
    //  res.end("浏览器界面")
    /**
     *  当发送内容包含中文的时候会出现乱码问题
     * 为了防止中文乱码的问题，需要设置响应头
     * Content-type 的值为 text/html；charset=utf-8
     */
    res.setHeader('Content-type','text/html;charset=utf8')
    res.end("浏览器界面")
    </code></pre> 
<pre><code class="language-javascript">  // 3.2 把请求的 URL 地址映射为具体文件的存放路径
  // const fpath = path.join(__dirname, url)
  // 5.1 预定义一个空白的文件存放路径
  let fpath = ''
  if (url === '/') {
    fpath = path.join(__dirname, './clock/index.html')
  } else {
    //     /index.html
    //     /index.css
    //     /index.js
    fpath = path.join(__dirname, '/clock', url)
  }
</code></pre> 
<h2 id="%E4%BA%94%E3%80%81node.js%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%9D%97%E5%8C%96">五、node.js中的模块化</h2> 
<h2 id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A05.1%E6%A8%A1%E5%9D%97%E5%8C%96%E5%88%86%E7%B1%BB">        5.1模块化分类</h2> 
<p>                <img alt="" height="137" src="https://images2.imgbox.com/58/b3/n0Z8756J_o.png" width="762"></p> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A05.2%E5%8A%A0%E8%BD%BD%E6%A8%A1%E5%9D%97">         5.2加载模块</h3> 
<p>        <img alt="" height="318" src="https://images2.imgbox.com/e5/96/usGZrmV6_o.png" width="642"></p> 
<p><strong> 注意：使用require方法加载其他模块时候，会执行其他模块中的代码</strong></p> 
<pre><code class="language-javascript">// 当前这个文件，就是一个用户自定义模块 m1.js
console.log('加载了06这个用户自定义模块')


//m2.js
const m1 = require('./m1.js') //可以省略.js
console.log(m1)
//输出 加载了06这个用户自定义模块
//{}
</code></pre> 
<h3 id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A05.3%20%E6%A8%A1%E5%9D%97%E4%BD%9C%E7%94%A8%E5%9F%9F">        5.3 模块作用域</h3> 
<blockquote> 
 <p>                 引入其他文件 无法访问其他文件中的变量 方法</p> 
 <p>                   防止全局变量污染的问题</p> 
 <p>                        js中是没有防止全局变量污染的</p> 
 <p>                     </p> 
</blockquote> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%205.5%20module%E5%AF%B9%E8%B1%A1%C2%A0">        5.5 module对象 </h3> 
<p>                        1.module对象</p> 
<p>                在每个.js文件自定义模块中都有一个module对象，它里面<strong>存储了和其当前模块有关的信</strong>息，打印如下：</p> 
<p>        <img alt="" height="458" src="https://images2.imgbox.com/12/2d/awloUJgm_o.png" width="527"></p> 
<p>         </p> 
<pre><code class="language-javascript">// 在一个自定义模块中，默认情况下， module.exports = {}

const age = 20

// 向 module.exports 对象上挂载 username 属性
module.exports.username = 'zs'
// 向 module.exports 对象上挂载 sayHello 方法
module.exports.sayHello = function() {
  console.log('Hello!')
}
module.exports.age = age

// 让 module.exports 指向一个全新的对象
module.exports = {
  nickname: '小黑',
  sayHi() {
    console.log('Hi!')
  }
}


//其他文件引用 打印出来就是{ nickname: '小黑', sayHi: [Function: sayHi] }
</code></pre> 
<blockquote> 
 <p>        向外共享模块作用域中的成员</p> 
 <p>        注意点：使用require()方法导入模块时，导入的结果，永远以module.exports指向对象为准。</p> 
 <p></p> 
</blockquote> 
<h3 id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A05.6%20exports%E5%AF%B9%E8%B1%A1%C2%A0">        5.6 exports对象 </h3> 
<p>       <img alt="" height="139" src="https://images2.imgbox.com/8d/a5/AFc73hiI_o.png" width="775"></p> 
<p></p> 
<pre><code class="language-javascript">// console.log(exports)
// console.log(module.exports)

// console.log(exports === module.exports) //true

const username = 'zs'

module.exports.username = username
exports.age = 20
exports.sayHello = function() {
  console.log('大家好！')
}

// 最终，向外共享的结果，永远都是 module.exports 所指向的对象

//其他文件引用打印输出  { username: 'zs', age: 20, sayHello: [Function (anonymous)] }
     </code></pre> 
<p><img alt="" height="324" src="https://images2.imgbox.com/92/43/eojLzmbL_o.png" width="794"></p> 
<p></p> 
<p> <img alt="" height="227" src="https://images2.imgbox.com/fb/b4/r5wOPgOK_o.png" width="708"></p> 
<h3 id="%C2%A05.7%20npm%20%E4%B8%8E%E5%8C%85"> 5.7 npm 与包</h3> 
<p>        <img alt="" height="158" src="https://images2.imgbox.com/8f/6d/4GcVmdu0_o.png" width="628"></p> 
<h3 id="%C2%A0%20%C2%A05.8%20%E6%B7%98%E5%AE%9D%E9%95%9C%E5%83%8F%20cnpm%20%E9%85%8D%E7%BD%AE">   5.8 淘宝镜像 cnpm 配置</h3> 
<p>        <strong>方法一：</strong></p> 
<p><strong>                </strong>使用阿里定制的cnpm命令行工具代替默认的npm，输入以下代码</p> 
<blockquote> 
 <p>                        </p> 
 <pre><code> npm install -g cnpm --registry=http://registry.npmmirror.com</code></pre> 
</blockquote> 
<p>检查是否安装成功： </p> 
<blockquote> 
 <p>        </p> 
 <pre><code> $ cnpm -v</code></pre> 
</blockquote> 
<p>安装成功之后，以后安装依赖包的方式和npm的是一样的，只是npm的命令换成是cnpm就可以了。</p> 
<p><strong>方法二：</strong></p> 
<p></p> 
<blockquote> 
 <p>         a:单次使用：</p> 
 <pre><code> npm install --registry=http://registry.npmmirror.com</code></pre> 
 <p> b:永久替换：</p> 
 <p><strong>        在开发react-native的时候</strong>，不要使用cnpm，cnpm安装的模块路径比较奇怪，packager不能正常识别。</p> 
 <p>所以，为了方便开发，我们最好是直接永久使用淘宝的镜像源</p> 
 <p>直接命令行的设置</p> 
 <pre><code> $ npm config set registry http://registry.npmmirror.com</code></pre> 
</blockquote> 
<p>手动修改设置 </p> 
<blockquote> 
 <p>        </p> 
 <pre><code> 1.打开.npmrc文件（C:\Program Files\nodejs\node_modules\npm\npmrc，没有的话可以使用git命令行建一个( touch .npmrc)，用cmd命令建会报错）
 2.增加 registry =http://registry.npmmirror.com  即可。</code></pre> 
</blockquote> 
<p><strong>如果需要恢复成原来的官方地址只需要执行如下命令: </strong></p> 
<p><strong>        </strong></p> 
<pre><code class="language-javascript"> npm config set registry https://registry.npmjs.org</code></pre> 
<p>检测是否安装成功：</p> 
<p>        </p> 
<pre><code class="language-javascript"> npm config get registry</code></pre> 
<p><img alt="" height="272" src="https://images2.imgbox.com/6a/45/ARlS3SJB_o.png" width="556"></p> 
<p></p> 
<pre><code class="language-javascript">         npm init -y //初始化包 快速创建一个package.json</code></pre> 
<h3 id="5.9%20devDependencies%20%E7%BB%93%E7%82%B9%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0">5.9 devDependencies 结点        </h3> 
<blockquote> 
 <p>        如果某些包只在<strong><span style="color:#fe2c24;">项目开发阶段会用到</span></strong>，在<strong><span style="color:#fe2c24;">项目上线之后不会用到</span></strong>，则建议把这些包记录到devDpendencies结点中，与之对应的，如果某些包在开发和项目上线之后都需要用到，则建议把这些包记录到dependencies节点中去</p> 
 <pre><code class="language-javascript">//安装指定包，并记录到devDependencies节点中
npm i 包名 -D
//注意：上述命令是简写形式，等价于下面完整的写法
npm install 包名 --sava-dev</code></pre> 
 <p>        通过查看包的官方文档来判断此包是否需要加入到devDependencies节点中</p> 
</blockquote> 
<h3 id="5.9.1%20nrm%E5%B7%A5%E5%85%B7%20%E8%A7%A3%E5%86%B3%E4%B8%8B%E5%8C%85%E9%80%9F%E5%BA%A6%E6%85%A2%E7%9A%84%E9%97%AE%E9%A2%98%C2%A0">5.9.1 nrm工具 解决下包速度慢的问题 </h3> 
<blockquote> 
 <p>        </p> 
 <pre><code class="language-javascript"># 通过npm 包管理器，将nrm 安装为全局可用的工具
npm i nrm -g

#查看所有可用的镜像源

nrm 1s

#将下包的镜像源切换为taobao 镜像
nrm use taobao</code></pre> 
 <p></p> 
</blockquote> 
<h3 id="5.9..2%20%E9%A1%B9%E7%9B%AE%E5%8C%85%C2%A0">5.9..2 项目包 </h3> 
<p>        </p> 
<pre><code class="language-javascript">
/**
 * 那些被安装到项目的node_modules目录中的包都是项目包
 * 项目包又分两类，分别是：
 * 1、开发依赖包（被记录到devDependencies节点中的包，只会在开发期间用得到）
 * 2、核心依赖包（被记录到dependencies节点中的包，在开发期间和项目上线后都会用得到）
 * 
 */
npm i 包名 -D //开发依赖包（会被记录到devDependencies节点下） 
npm i 包名   //核心依赖包 （会记录到dependencies节点下）
npm i 包名 -g //全局包 卸载全局去安装包 npm uninstall 包名 -g

/**
 * 只有工具类的包才有全局安装的必要性 因为他们提供了好用的终端命令
 * 判断某个包是否需要全局安装后才能使用，可以参考官网提供的使用说明即可
 */</code></pre> 
<h2>六、express</h2> 
<h3>        1.express:基于 <a href="https://nodejs.org/en/" rel="nofollow" title="Node.js">Node.js</a> 平台，快速、开放、极简的 Web 开发框架 <a class="link-info" href="https://www.expressjs.com.cn/" rel="nofollow" title="🔗">🔗</a></h3> 
<p>        </p> 
<pre><code class="language-javascript">// 1. 导入 express
const express = require('express')
// 2. 创建 web 服务器
const app = express()

// 4. 监听客户端的 GET 和 POST 请求，并向客户端响应具体的内容
app.get('/user', (req, res) =&gt; {
  // 调用 express 提供的 res.send() 方法，向客户端响应一个 JSON 对象
  res.send({ name: 'zs', age: 20, gender: '男' })
})
app.post('/user', (req, res) =&gt; {
  // 调用 express 提供的 res.send() 方法，向客户端响应一个 文本字符串
  res.send('请求成功')
})
app.get('/', (req, res) =&gt; {
  // 通过 req.query 可以获取到客户端发送过来的 查询参数
  // 注意：默认情况下，req.query 是一个空对象
  console.log(req.query)
  res.send(req.query)
})
// 注意：这里的 :id 是一个动态的参数
  // username后面接？表示可选
app.get('/user/:ids/:username', (req, res) =&gt; {
  // req.params 是动态匹配到的 URL 参数，默认也是一个空对象
  console.log(req.params)
  res.send(req.params)
})

// 3. 启动 web 服务器
app.listen(80, () =&gt; {
  console.log('express server running at http://127.0.0.1')
})
</code></pre> 
<h3>     6.1使用exoress.static对外提供静态资源</h3> 
<p>        </p> 
<pre><code class="language-javascript">const express = require('express')
const app = express()

// 在这里，调用 express.static() 方法，
// 快速的对外提供静态资源
/**
 * 托管多个静态资源目录
 * 多次调用app.use（express.static（））
 * ./files路径不会出现在url地址上
 */
app.use('/files', express.static('./files'))
app.use(express.static('./clock'))

app.listen(80, () =&gt; {
  console.log('express server running at http://127.0.0.1')
})
</code></pre> 
<p><img alt="" height="315" src="https://images2.imgbox.com/1d/82/PuAi8Mxn_o.png" width="606"></p> 
<h3> 6.2 nodemon</h3> 
<p>        <img alt="" height="142" src="https://images2.imgbox.com/78/60/E0b4WPle_o.png" width="746"></p> 
<p><strong> 使用方法 nodemon 项目名字</strong></p> 
<h3>6.3 express 路由</h3> 
<p>        <img alt="" height="244" src="https://images2.imgbox.com/6e/22/c2LkzOSL_o.png" width="700"></p> 
<p> <img alt="" height="316" src="https://images2.imgbox.com/6b/b7/cUQv1vRy_o.png" width="339"></p> 
<p> <img alt="" height="165" src="https://images2.imgbox.com/9d/95/4Xnx8NPR_o.png" width="699"></p> 
<p> <img alt="" height="375" src="https://images2.imgbox.com/8b/a0/pAhjlkvq_o.png" width="1200"></p> 
<p></p> 
<h3> 6.4 模块化路由</h3> 
<p><img alt="" height="286" src="https://images2.imgbox.com/0c/4e/ZZ6SXvGj_o.png" width="673"></p> 
<p><strong> index.js</strong></p> 
<p>        </p> 
<pre><code class="language-javascript">const express = require('express')
const app = express()

// app.use('/files', express.static('./files'))

// 1. 导入路由模块
const router = require('./03.router')
// 2. 注册路由模块
// /api 表示 请求前面必须加/api 才能访问到
app.use('/api', router)

// 注意： app.use() 函数的作用，就是来注册全局中间件

app.listen(80, () =&gt; {
  console.log('http://127.0.0.1')
})
</code></pre> 
<p><strong>router.js</strong></p> 
<p><strong>        </strong></p> 
<pre><code class="language-javascript">// 这是路由模块
// 1. 导入 express
const express = require('express')
// 2. 创建路由对象
const router = express.Router()

// 3. 挂载具体的路由
router.get('/user/list', (req, res) =&gt; {
  res.send('Get user list.')
})
router.post('/user/add', (req, res) =&gt; {
  res.send('Add new user.')
})

// 4. 向外导出路由对象
module.exports = router
</code></pre> 
<h3> 6.4 Express 中间件</h3> 
<blockquote> 
 <p>        <img alt="" height="305" src="https://images2.imgbox.com/b4/ec/TQGNKbFJ_o.png" width="620"></p> 
 <p> <img alt="" height="245" src="https://images2.imgbox.com/8d/81/XD3SaJFf_o.png" width="669"></p> 
 <p></p> 
</blockquote> 
<h4><strong>        next函数的作用</strong></h4> 
<blockquote> 
 <p>        <img alt="" height="265" src="https://images2.imgbox.com/4a/b2/miSnaFzb_o.png" width="554"></p> 
 <p> <img alt="" height="398" src="https://images2.imgbox.com/94/92/8rdZBlUu_o.png" width="569"></p> 
 <p> <img alt="" height="346" src="https://images2.imgbox.com/e1/07/k3O3u2YA_o.png" width="736"></p> 
 <p> <img alt="" height="622" src="https://images2.imgbox.com/b7/36/52OoptMf_o.png" width="1064"></p> 
 <p> <img alt="" height="282" src="https://images2.imgbox.com/de/3e/PakGn0wq_o.png" width="602"></p> 
 <p> <img alt="" height="344" src="https://images2.imgbox.com/e7/da/rLjqluSW_o.png" width="811"></p> 
 <p> <img alt="" height="342" src="https://images2.imgbox.com/1e/d8/eLKWkujf_o.png" width="722"></p> 
 <p> express.josn（） express.urlencoded()中间件使用</p> 
 <pre><code class="language-javascript">// 导入 express 模块
const express = require('express')
// 创建 express 的服务器实例
const app = express()

// 注意：除了错误级别的中间件，其他的中间件，必须在路由之前进行配置
// 通过 express.json() 这个中间件，解析表单中的 JSON 格式的数据
app.use(express.json())
// 通过 express.urlencoded() 这个中间件，来解析 表单中的 url-encoded 格式的数据
app.use(express.urlencoded({ extended: false }))

app.post('/user', (req, res) =&gt; {
  // 在服务器，可以使用 req.body 这个属性，来接收客户端发送过来的请求体数据
  // 默认情况下，如果不配置解析表单数据的中间件，则 req.body 默认等于 undefined
  console.log(req.body)
  res.send('ok')
})

app.post('/book', (req, res) =&gt; {
  // 在服务器端，可以通过 req,body 来获取 JSON 格式的表单数据和 url-encoded 格式的数据
  console.log(req.body)
  res.send('ok')
})

// 调用 app.listen 方法，指定端口号并启动web服务器
app.listen(80, function () {
  console.log('Express server running at http://127.0.0.1')
})
</code></pre> 
 <p><img alt="" height="235" src="https://images2.imgbox.com/0b/22/B65sulys_o.png" width="963"></p> 
 <p></p> 
</blockquote> 
<h3> 6.5 使用express 写接口</h3> 
<p>                </p> 
<p> 3. 什么是 CORS</p> 
<blockquote> 
 <p>CORS （Cross-Origin Resource Sharing，跨域资源共享）由一系列 HTTP 响应头组成，这些 HTTP 响应头决定浏览器是否阻止前端 JS 代码跨域获取资源。</p> 
 <p>浏览器的<strong>同源安全策略默认会阻止网页“跨域”获取资源</strong>。但如果接口服务<strong>器配置了 CORS 相</strong>关的 <strong>HTTP 响应头</strong>，就可以<strong>解除浏览器端的跨域访问限制。</strong></p> 
 <p><img alt="" height="223" src="https://images2.imgbox.com/3c/3a/KEQ0aVZd_o.png" width="348"><img alt="" height="223" src="https://images2.imgbox.com/5e/88/kKxmHwhn_o.png" width="417"></p> 
 <p> </p> 
 <p> </p> 
</blockquote> 
<blockquote> 
 <p>CORS 响应头部</p> 
 <p>        响应头部中可以携带一个 Access-Control-Allow-Origin 字段，其语法如下:     </p> 
 <pre><code class="language-javascript">Access-Control-Allow-Origin:&lt;origin&gt;|*</code></pre> 
 <p>        其中，origin参数的值指定了允许访问该资源外域URL。</p> 
 <p>        列如，下面的字段值将只允许来自 http：//itcast.cn</p> 
 <p><img alt="" height="112" src="https://images2.imgbox.com/de/03/nMn8BBY9_o.png" width="728"></p> 
 <p>如果指定了 Access-Control-Allow-Origin 字段的值为通配符 *，表示允许来自任何域的请求，示例代码如下：</p> 
 <p> <img alt="" height="112" src="https://images2.imgbox.com/a5/aa/WOKbQf77_o.png" width="728"></p> 
 <p> </p> 
 <p><strong>CORS 响应头部 - Access-Control-Allow-Headers</strong></p> 
 <p>        默认情况下，CORS 仅支持客户端向服务器发送如下的 9 个请求头： Accept、Accept-Language、Content-Language、DPR、Downlink、Save-Data、Viewport-Width、Width 、Content-Type （值仅限于 text/plain、multipart/form-data、application/x-www-form-urlencoded 三者之一） 如果客户端向服务器发送了额外的请求头信息，则需要在服务器端，通过 Access-Control-Allow-Headers 对额外的请求头进行声明，否则这次请求会失败！</p> 
 <p><img alt="" height="97" src="https://images2.imgbox.com/9d/41/Rjl6RAi0_o.png" width="681"></p> 
 <p> </p> 
 <p><strong>CORS 响应头部 - Access-Control-Allow-Methods</strong></p> 
 <p>        默认情况下，CORS 仅支持客户端发起 GET、POST、HEAD 请求。 如果客户端希望通过 PUT、DELETE 等方式请求服务器的资源，则需要在服务器端，通过 Access-Control-Alow-Methods来指明实际请求所允许使用的 HTTP 方法。</p> 
 <p>示例代码如下：​​​​​​</p> 
 <p><img alt="" height="101" src="https://images2.imgbox.com/27/31/Tgxn64mK_o.png" width="499"></p> 
 <p> </p> 
</blockquote> 
<h3><strong> 6.8. CORS请求的分类</strong></h3> 
<blockquote> 
 <p>        客户端在请求 CORS 接口时，根据请求方式和请求头的不同，可以将 CORS 的请求分为两大类，分别是：</p> 
 <p>简单请求</p> 
 <p>        <span style="color:#ff9900;"><strong>请求方式</strong></span>：<strong>GET、POST、HEAD 三者之一</strong></p> 
 <p>         HTTP 头部信息不超过以下几种字段：无自定义头部字段、Accept、Accept-Language、Content-Language、DPR、Downlink、Save-Data、Viewport-Width、Width 、Content-Type（只有三个值<strong><span style="color:#fe2c24;">application/x-www-form-urlencoded、multipart/form-data、text/plain</span></strong>）</p> 
 <p></p> 
 <p><span style="color:#ff9900;"><strong>预检请求:</strong></span></p> 
 <p><strong>只要符合以下任何一个条件的请求，都需要进行预检请求：  </strong></p> 
 <p><strong>        请求方式为</strong><span style="color:#fe2c24;"><strong> GET、POST、HEAD 之外的请求 Method 类型</strong></span><strong> </strong></p> 
 <p><strong>         请求头中包含自定义头部字段  向服务器发送了 </strong><span style="color:#fe2c24;"><strong>application/json 格式的数据</strong></span></p> 
 <p><strong>在浏览器与服务器正式通信之前，浏览器会先发送</strong><span style="color:#fe2c24;"><strong> OPTION 请求进行预检</strong></span><strong>，以获知服务器是否允许该实际请求，</strong><span style="color:#fe2c24;"><strong>所以这一次的 OPTION 请求称为“预检请求”。</strong></span><strong>服务器成功响应预检请求后，才会发送真正的请求，并且携带真实数据。</strong></p> 
</blockquote> 
<h3>6.9 简单请求和预检请求的区别</h3> 
<blockquote> 
 <p><strong><em>简单请求的特点</em></strong>：客户端与服务器之间只会发生一次请求。</p> 
 <p><br><strong>预检请求的特点</strong>：客户端与服务器之间会发生两次请求，OPTION 预检请求成功之后，才会发起真正的请求。</p> 
 <p></p> 
</blockquote> 
<p><img alt="" height="253" src="https://images2.imgbox.com/b6/aa/k5kCXmC6_o.png" width="760"></p> 
<p> </p> 
<p></p> 
<p></p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/69d9ad165695ccfde95434e31d7a312d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">第二十五章《图书管理系统》第1节：图书管理系统简介</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/00c86178d54398c880f7ce75f07e85b4/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">gcc-linaro-7.5.0-2019.12-x86_64_aarch64-linux-gnu交叉编译Arm Linux环境下的身份证读卡器so库操作步骤</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>