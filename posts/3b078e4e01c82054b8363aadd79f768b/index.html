<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>LeetCode——动态规划篇（六） - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="LeetCode——动态规划篇（六）" />
<meta property="og:description" content="刷题顺序及思路来源于代码随想录，网站地址：https://programmercarl.com 目录
300. 最长递增子序列 - 力扣（LeetCode）
674. 最长连续递增序列 - 力扣（LeetCode）
718. 最长重复子数组 - 力扣（LeetCode）
1143. 最长公共子序列 - 力扣（LeetCode）
1035. 不相交的线 - 力扣（LeetCode）
300. 最长递增子序列 - 力扣（LeetCode） 给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。
子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。
输入：nums = [10,9,2,5,3,7,101,18] 输出：4 解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 import java.util.Arrays; /** * @author light * @Description 最长递增子序列 * * * （思路：数组中只要有递增的就行，无需连续 * 动态规划--弄明白dp数组所表示的含义 * dp[i]:nums[i]之前（包括nums[i])的字序列最大递增子序列长度为dp[i] * @create 2023-10-15 9:50 */ public class LengthOfLISTest { public static void main(String[] args) { int[] nums={0,1,0,3,2}; System." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/3b078e4e01c82054b8363aadd79f768b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-10-17T17:15:12+08:00" />
<meta property="article:modified_time" content="2023-10-17T17:15:12+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">LeetCode——动态规划篇（六）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>刷题顺序及思路来源于代码随想录，网站地址：<a href="https://programmercarl.com/" rel="nofollow" title="https://programmercarl.com">https://programmercarl.com</a> </p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="300.%20%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97%20-%20%E5%8A%9B%E6%89%A3%EF%BC%88LeetCode%EF%BC%89-toc" style="margin-left:0px;"><a href="#300.%20%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97%20-%20%E5%8A%9B%E6%89%A3%EF%BC%88LeetCode%EF%BC%89" rel="nofollow">300. 最长递增子序列 - 力扣（LeetCode）</a></p> 
<p id="674.%20%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E9%80%92%E5%A2%9E%E5%BA%8F%E5%88%97%20-%20%E5%8A%9B%E6%89%A3%EF%BC%88LeetCode%EF%BC%89-toc" style="margin-left:0px;"><a href="#674.%20%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E9%80%92%E5%A2%9E%E5%BA%8F%E5%88%97%20-%20%E5%8A%9B%E6%89%A3%EF%BC%88LeetCode%EF%BC%89" rel="nofollow">674. 最长连续递增序列 - 力扣（LeetCode）</a></p> 
<p id="718.%20%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E5%AD%90%E6%95%B0%E7%BB%84%20-%20%E5%8A%9B%E6%89%A3%EF%BC%88LeetCode%EF%BC%89-toc" style="margin-left:0px;"><a href="#718.%20%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E5%AD%90%E6%95%B0%E7%BB%84%20-%20%E5%8A%9B%E6%89%A3%EF%BC%88LeetCode%EF%BC%89" rel="nofollow">718. 最长重复子数组 - 力扣（LeetCode）</a></p> 
<p id="1143.%20%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97%20-%20%E5%8A%9B%E6%89%A3%EF%BC%88LeetCode%EF%BC%89-toc" style="margin-left:0px;"><a href="#1143.%20%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97%20-%20%E5%8A%9B%E6%89%A3%EF%BC%88LeetCode%EF%BC%89" rel="nofollow">1143. 最长公共子序列 - 力扣（LeetCode）</a></p> 
<p id="1035.%20%E4%B8%8D%E7%9B%B8%E4%BA%A4%E7%9A%84%E7%BA%BF%20-%20%E5%8A%9B%E6%89%A3%EF%BC%88LeetCode%EF%BC%89-toc" style="margin-left:0px;"><a href="#1035.%20%E4%B8%8D%E7%9B%B8%E4%BA%A4%E7%9A%84%E7%BA%BF%20-%20%E5%8A%9B%E6%89%A3%EF%BC%88LeetCode%EF%BC%89" rel="nofollow">1035. 不相交的线 - 力扣（LeetCode）</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="300.%20%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97%20-%20%E5%8A%9B%E6%89%A3%EF%BC%88LeetCode%EF%BC%89"><a href="https://leetcode.cn/problems/longest-increasing-subsequence/description/" rel="nofollow" title="300. 最长递增子序列 - 力扣（LeetCode）">300. 最长递增子序列 - 力扣（LeetCode）</a></h2> 
<p>给你一个整数数组 <code>nums</code> ，找到其中最长严格递增子序列的长度。</p> 
<p><strong>子序列 </strong>是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，<code>[3,6,2,7]</code> 是数组 <code>[0,3,1,6,2,2,7]</code> 的子序列。</p> 
<pre><code class="language-java">输入：nums = [10,9,2,5,3,7,101,18]
输出：4
解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 </code></pre> 
<pre><code class="language-java">
import java.util.Arrays;

/**
 * @author light
 * @Description 最长递增子序列
 *
 *
 * （思路：数组中只要有递增的就行，无需连续
 * 动态规划--弄明白dp数组所表示的含义
 * dp[i]:nums[i]之前（包括nums[i])的字序列最大递增子序列长度为dp[i]
 * @create 2023-10-15 9:50
 */
public class LengthOfLISTest {
	public static void main(String[] args) {
		int[] nums={0,1,0,3,2};
		System.out.println(lengthOfLIS(nums));
	}

	public static  int lengthOfLIS(int[] nums) {

		int[] dp=new int[nums.length];
		Arrays.fill(dp, 1);//初始化

		int result=1;
		for (int i = 1; i &lt; nums.length; i++) {
			for (int j = 0; j &lt; i; j++) {
				if (nums[i] &gt; nums[j]) dp[i] = Math.max(dp[i], dp[j] + 1);
			}
			if (dp[i] &gt; result) result = dp[i]; // 取长的子序列
		}
		return result;
	}
}
</code></pre> 
<h2 id="674.%20%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E9%80%92%E5%A2%9E%E5%BA%8F%E5%88%97%20-%20%E5%8A%9B%E6%89%A3%EF%BC%88LeetCode%EF%BC%89"><a href="https://leetcode.cn/problems/longest-continuous-increasing-subsequence/description/" rel="nofollow" title="674. 最长连续递增序列 - 力扣（LeetCode）">674. 最长连续递增序列 - 力扣（LeetCode）</a></h2> 
<p>给定一个未经排序的整数数组，找到最长且<strong> 连续递增的子序列</strong>，并返回该序列的长度。</p> 
<p><strong>连续递增的子序列</strong> 可以由两个下标 <code>l</code> 和 <code>r</code>（<code>l &lt; r</code>）确定，如果对于每个 <code>l &lt;= i &lt; r</code>，都有 <code>nums[i] &lt; nums[i + 1]</code> ，那么子序列 <code>[nums[l], nums[l + 1], ..., nums[r - 1], nums[r]]</code> 就是连续递增子序列。</p> 
<pre><code class="language-java">
import java.util.Arrays;

/**
 * @author light
 * @Description  最长连续递增的子序列

 * （思路：只需考虑nums[i]和nums[i-1]
 * @create 2023-10-15 10:49
 */
public class FindLengthOfLCISTest {

	public int findLengthOfLCIS(int[] nums) {
		int[] dp=new int[nums.length];
		Arrays.fill(dp,1);
		int res=1;
		for (int i = 1; i &lt; nums.length; i++) {
			if(nums[i]&gt;nums[i-1]){
				dp[i]=dp[i-1]+1;
			}
			res=Math.max(dp[i],res);
		}
		return res;
	}
}
</code></pre> 
<h2 id="718.%20%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E5%AD%90%E6%95%B0%E7%BB%84%20-%20%E5%8A%9B%E6%89%A3%EF%BC%88LeetCode%EF%BC%89"><a href="https://leetcode.cn/problems/maximum-length-of-repeated-subarray/description/" rel="nofollow" title="718. 最长重复子数组 - 力扣（LeetCode）">718. 最长重复子数组 - 力扣（LeetCode）</a></h2> 
<p>给两个整数数组 <code>nums1</code> 和 <code>nums2</code> ，返回 <em>两个数组中 <strong>公共的</strong> 、长度最长的子数组的长度 </em>。</p> 
<pre><code class="language-java">输入：nums1 = [1,2,3,2,1], nums2 = [3,2,1,4,7]
输出：3
解释：长度最长的公共子数组是 [3,2,1] 。</code></pre> 
<pre><code class="language-java">
/**
 * @author light
 * @Description 最长重复子数组
 *
 * 给两个整数数组 nums1 和 nums2 ，返回 两个数组中 公共的 、长度最长的子数组的长度 。
 *
 * （思路：搞清dp数组含义
 * dp[i][j]:以i-1为结尾的数组nums1和以j-1为结尾的数组nums2的最长重复子数组长度为dp[i][j]
 * 比以i,j为结尾的好处：简化了dp数组的初始化；使得dp[i][0]和dp[0][j]没有意义
 * @create 2023-10-15 13:38
 */
public class FindLengthTest {
	public int findLength(int[] nums1, int[] nums2) {
		//dp[i][j]:以i-1为结尾的数组nums1和以j-1为结尾的数组nums2的最长重复子数组长度为dp[i][j]
		int[][] dp=new int[nums1.length+1][nums2.length+1];
		int res=0;
		for (int i = 1; i &lt;=nums1.length; i++) {
			for (int j = 1; j &lt;=nums2.length; j++) {
				if(nums1[i-1]==nums2[j-1]){
					dp[i][j]=dp[i-1][j-1]+1;
				}
				res= Math.max(dp[i][j],res);
			}
		}
		return res;
	}
}
</code></pre> 
<h2 id="1143.%20%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97%20-%20%E5%8A%9B%E6%89%A3%EF%BC%88LeetCode%EF%BC%89"><a href="https://leetcode.cn/problems/longest-common-subsequence/description/" rel="nofollow" title="1143. 最长公共子序列 - 力扣（LeetCode）">1143. 最长公共子序列 - 力扣（LeetCode）</a></h2> 
<p>给定两个字符串 <code>text1</code> 和 <code>text2</code>，返回这两个字符串的最长 <strong>公共子序列</strong> 的长度。如果不存在 <strong>公共子序列</strong> ，返回 <code>0</code> 。</p> 
<p>一个字符串的 <strong>子序列</strong><em> </em>是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p> 
<ul><li>例如，<code>"ace"</code> 是 <code>"abcde"</code> 的子序列，但 <code>"aec"</code> 不是 <code>"abcde"</code> 的子序列。</li></ul> 
<p>两个字符串的 <strong>公共子序列</strong> 是这两个字符串所共同拥有的子序列。</p> 
<pre><code>输入：text1 = "abcde", text2 = "ace" 
输出：3  
解释：最长公共子序列是 "ace" ，它的长度为 3 。</code></pre> 
<pre><code class="language-java">
/**
 * @author light
 * @Description 最长公共子序列

 *
 * （不要求连续，但不能改变顺序
 * @create 2023-10-16 12:46
 */
public class LongestCommonSubsequenceTest {
	public int longestCommonSubsequence(String text1, String text2) {
		//下标为[0,i-1]的text1和下标为[0,j-1]的text2中，最长公共子序列长度为dp[i][j]
		int[][] dp=new int[text1.length()+1][text2.length()+1];
		for (int i = 1; i &lt;=text1.length(); i++) {
			for (int j = 1; j &lt;=text2.length(); j++) {
				if(text1.charAt(i-1)==text2.charAt(j-1)){
					dp[i][j]=dp[i-1][j-1]+1;
				}else {
					dp[i][j]=Math.max(dp[i-1][j],dp[i][j-1]);
				}
			}
		}
		return dp[text1.length()][text2.length()];
	}
}
</code></pre> 
<h2 id="1035.%20%E4%B8%8D%E7%9B%B8%E4%BA%A4%E7%9A%84%E7%BA%BF%20-%20%E5%8A%9B%E6%89%A3%EF%BC%88LeetCode%EF%BC%89"><a href="https://leetcode.cn/problems/uncrossed-lines/description/" rel="nofollow" title="1035. 不相交的线 - 力扣（LeetCode）">1035. 不相交的线 - 力扣（LeetCode）</a></h2> 
<p>在两条独立的水平线上按给定的顺序写下 <code>nums1</code> 和 <code>nums2</code> 中的整数。</p> 
<p>现在，可以绘制一些连接两个数字 <code>nums1[i]</code> 和 <code>nums2[j]</code> 的直线，这些直线需要同时满足满足：</p> 
<ul><li> <code>nums1[i] == nums2[j]</code></li><li>且绘制的直线不与任何其他连线（非水平线）相交。</li></ul> 
<p>请注意，连线即使在端点也不能相交：每个数字只能属于一条连线。</p> 
<p>以这种方法绘制线条，并返回可以绘制的最大连线数。</p> 
<p><img alt="" height="560" src="https://images2.imgbox.com/a1/71/Z6UJEWmk_o.png" width="695"></p> 
<pre><code class="language-java">/**
 * @author light
 * @Description 不相交的线
 *
 * （思路：直线不能相交，这就是说明在字符串A中 找到一个与字符串B相同的子序列，
 * 且这个子序列不能改变相对顺序，只要相对顺序不改变，链接相同数字的直线就不会相交。
 *
 * 本质，求两数组最长公共子序列长度
 * @create 2023-10-16 13:11
 */
public class MaxUncrossedLinesTest {
	public int maxUncrossedLines(int[] nums1, int[] nums2) {
		//dp[i][j]:[0,i-1]的数组nums1，[0,j-1]的数组nums2的公共子序列长度为dp[i][j]
		int[][] dp=new int[nums1.length+1][nums2.length+1];
		for (int i = 1; i &lt;= nums1.length; i++) {
			for (int j = 1; j &lt;=nums2.length; j++) {
				if(nums1[i-1]==nums2[j-1]){
					dp[i][j]=dp[i-1][j-1]+1;
				}else {
					dp[i][j]=Math.max(dp[i-1][j],dp[i][j-1]);
				}
			}

		}
		return dp[nums1.length][nums2.length];
	}
}
</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2e30568d83b6372f62ed72a847f6cb06/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">vue3&#43;element-plus 封装列表页，分页，排序，导出</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/88a068cf39873b4305db3b266d787a68/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">滚动条样式优化</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>