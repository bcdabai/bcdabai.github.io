<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java虚拟机之强引用、软引用、弱引用、虚引用详解 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Java虚拟机之强引用、软引用、弱引用、虚引用详解" />
<meta property="og:description" content="背景 在JDK 1.2以前，Java中的引用定义很传统：如果reference类型的数据中存储的数值代表的是另一块内存的起始地址，就称这块内存代表着一个引用。这种定义很纯粹，但是太过狭隘，一个对象在这种定义下，只有被引用或者没有被引用这两种状态，对于如何描述一些“食之无味，弃之可惜”的对象就显得无能为力。我们对于这样一类对象需要一种新的引用方式：当内存空间还足够时，则能保留在内存之中；如果内存空间在进行垃圾回收后还是非常紧张，则可以抛弃这些对象。很多系统的缓存功能都是符合这样的应用场景。
所以，JDK 1.2对引用的概念进行了扩充，将引用分为强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference）4种，这4种的引用强度依次逐渐减弱。
强引用
强引用是指在程序代码中普遍存在的，类似Object obj = new Object()这类的引用，只要强引用还存在，垃圾回收器永远不会回收掉被引用的对象。
软引用
软引用用来描述一些还有用但并非必需的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。在JDK 1.2之后，提供了SoftReference类来实现软引用。
应用场景：软引用通常用来实现内存敏感的缓存。如果内存空间还有剩余，就可以暂时保留缓存，当内存不足时，就可以将缓存清除，这样就保证了使用缓存的同时，不会耗尽内存。
弱引用
弱引用也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾回收之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在JDK 1.2之后，提供了WeakReference类来实现弱引用。
应用场景：弱应用同样可用于内存敏感的缓存。与软引用不同的是，在内存空间还足够时，软引用的对象不会被回收，但是，弱引用的对象有可能会被回收，其存活时间相比于弱引用更短一点。
虚引用
虚引用也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是在这个对象被垃圾回收器回收时收到一个系统通知。在JDK 1.2之后，提供了PhantomReference类来实现虚引用。
应用场景：可以用虚引用来跟踪对象被垃圾回收器回收的活动，当一个虚引用关联的对象被垃圾收集器回收之前会收到一条系统通知。
软引用、弱引用和虚引用可以和一个引用队列（ReferenceQueue）联合使用，如果它们所引用的对象被垃圾回收，Java虚拟机就会把这个引用加入到与之关联的引用队列中。采用软引用、弱引用和虚引用可以预防Java虚拟机抛出OOM异常以及内存泄漏的问题。
软引用、弱引用和虚引用存在的必要性 在Java程序中，如果我们想回收一个对象，可以把对象引用置为null，这样，在下次垃圾回收之前，就可以回收该对象，如下所示：
Object object = new Object(); object = null; 但是手动置为null这种方式太繁琐，而且我们编写程序时也不能一直保证对引用的置空操作是正确的，这种方式完全违背了Java虚拟机自动回收垃圾的概念。同时，采用该种方式会存在以下问题：
对于需要系统缓存的Java程序，在程序运行期间，缓存内容就不能被垃圾回收器回收，如果我们已经不再需要某项缓存，那将其置为null，是不是就可以了呢？
答案是不行的，若缓存使用HashMap&lt;Product, Integer&gt;来实现，其中，key代表一种商品缓存信息，value为商品剩余数目，当商品售空时，我们将指向Product商品的引用（假设为productRef）productRef置为null，然而垃圾回收器并不会回收Product对象，因为在HashMap的Node结点中，仍然保留着一个对Product对象的引用，若是想要回收该对象，必须还得将该条目从HashMap中删除，否则会产生内存泄漏问题。这同样违背了Java虚拟机自动回收垃圾的概念。
对于上述的问题，我们都可以通过软引用和弱引用解决。对于使用单个引用的对象，示例代码如下所示：
public class ReferenceTest1 { // 循环检测引用队列是否有值 static class CheckReferenceQueueThread extends Thread { private ReferenceQueue&lt;Object&gt; referenceQueue; public CheckReferenceQueueThread(ReferenceQueue&lt;Object&gt; referenceQueue) { this.referenceQueue = referenceQueue; } @Override public void run() { super." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/2de57223dfa8f7213702b48efc74d91d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-05-26T15:51:14+08:00" />
<meta property="article:modified_time" content="2018-05-26T15:51:14+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java虚拟机之强引用、软引用、弱引用、虚引用详解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h4>背景</h4> 
<p>在JDK 1.2以前，Java中的引用定义很传统：如果reference类型的数据中存储的数值代表的是另一块内存的起始地址，就称这块内存代表着一个引用。这种定义很纯粹，但是太过狭隘，一个对象在这种定义下，只有被引用或者没有被引用这两种状态，对于如何描述一些“食之无味，弃之可惜”的对象就显得无能为力。我们对于这样一类对象需要一种新的引用方式：当内存空间还足够时，则能保留在内存之中；如果内存空间在进行垃圾回收后还是非常紧张，则可以抛弃这些对象。很多系统的缓存功能都是符合这样的应用场景。</p> 
<p>所以，JDK 1.2对引用的概念进行了扩充，将引用分为强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference）4种，这4种的引用强度依次逐渐减弱。</p> 
<p>强引用</p> 
<p>强引用是指在程序代码中普遍存在的，类似Object obj = new Object()这类的引用，只要强引用还存在，垃圾回收器永远不会回收掉被引用的对象。</p> 
<p>软引用</p> 
<p>软引用用来描述一些还有用但并非必需的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。在JDK 1.2之后，提供了SoftReference类来实现软引用。</p> 
<p><strong>应用场景：</strong>软引用通常用来实现内存敏感的缓存。如果内存空间还有剩余，就可以暂时保留缓存，当内存不足时，就可以将缓存清除，这样就保证了使用缓存的同时，不会耗尽内存。</p> 
<p>弱引用</p> 
<p>弱引用也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾回收之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在JDK 1.2之后，提供了WeakReference类来实现弱引用。</p> 
<p><strong>应用场景：</strong>弱应用同样可用于内存敏感的缓存。与软引用不同的是，在内存空间还足够时，软引用的对象不会被回收，但是，弱引用的对象有可能会被回收，其存活时间相比于弱引用更短一点。</p> 
<p>虚引用</p> 
<p>虚引用也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是在这个对象被垃圾回收器回收时收到一个系统通知。在JDK 1.2之后，提供了PhantomReference类来实现虚引用。</p> 
<p><strong>应用场景：</strong>可以用虚引用来跟踪对象被垃圾回收器回收的活动，当一个虚引用关联的对象被垃圾收集器回收之前会收到一条系统通知。</p> 
<p>软引用、弱引用和虚引用可以和一个引用队列（ReferenceQueue）联合使用，如果它们所引用的对象被垃圾回收，Java虚拟机就会把这个引用加入到与之关联的引用队列中。采用软引用、弱引用和虚引用可以预防Java虚拟机抛出OOM异常以及内存泄漏的问题。</p> 
<h4>软引用、弱引用和虚引用存在的必要性</h4> 
<p>在Java程序中，如果我们想回收一个对象，可以把对象引用置为null，这样，在下次垃圾回收之前，就可以回收该对象，如下所示：</p> 
<pre class="has"><code class="language-java">Object object = new Object();
object = null;</code></pre> 
<p>但是手动置为null这种方式太繁琐，而且我们编写程序时也不能一直保证对引用的置空操作是正确的，这种方式完全违背了Java虚拟机自动回收垃圾的概念。同时，采用该种方式会存在以下问题：</p> 
<p>对于需要系统缓存的Java程序，在程序运行期间，缓存内容就不能被垃圾回收器回收，如果我们已经不再需要某项缓存，那将其置为null，是不是就可以了呢？</p> 
<p>答案是不行的，若缓存使用HashMap&lt;Product, Integer&gt;来实现，其中，key代表一种商品缓存信息，value为商品剩余数目，当商品售空时，我们将指向Product商品的引用（假设为productRef）productRef置为null，然而垃圾回收器并不会回收Product对象，因为在HashMap的Node结点中，仍然保留着一个对Product对象的引用，若是想要回收该对象，必须还得将该条目从HashMap中删除，否则会产生内存泄漏问题。这同样违背了Java虚拟机自动回收垃圾的概念。</p> 
<p>对于上述的问题，我们都可以通过软引用和弱引用解决。对于使用单个引用的对象，示例代码如下所示：</p> 
<pre class="has"><code class="language-java">public class ReferenceTest1 {
	// 循环检测引用队列是否有值
	static class CheckReferenceQueueThread extends Thread {
		private ReferenceQueue&lt;Object&gt; referenceQueue;
		
		public CheckReferenceQueueThread(ReferenceQueue&lt;Object&gt; referenceQueue) {
			this.referenceQueue = referenceQueue;
		}
		
		@Override
		public void run() {
			super.run();
			
			while (!Thread.interrupted()) {
				Reference&lt;? extends Object&gt; reference = referenceQueue.poll();
				if (reference != null) {
					System.out.println("弱引用对象已被回收，已被加入到引用队列中");
				}
			}
		}
	}
	
	// 循环获取弱引用指向的对象
	static class GetValueThread extends Thread {
		private WeakReference&lt;Object&gt; weakReference;
		
		public GetValueThread(WeakReference&lt;Object&gt; weakReference) {
			this.weakReference = weakReference;
		}
		
		@Override
		public void run() {
			super.run();
			
			while (!Thread.interrupted()) {
				Object object = weakReference.get();
				if (object == null) {
					System.out.println("弱引用对象已被回收，重新为弱引用赋值");
					weakReference = new WeakReference&lt;&gt;(new Object());
				}
			}
		}
	}
	
	private static final ReferenceQueue&lt;Object&gt; REFERENCE_QUEUE = new ReferenceQueue&lt;&gt;();

	public static void main(String[] args) throws InterruptedException {
		GetValueThread getValueThread = new GetValueThread(getWeakReference());
		CheckReferenceQueueThread checkReferenceQueueThread = new CheckReferenceQueueThread(REFERENCE_QUEUE);
		
		getValueThread.start();
		checkReferenceQueueThread.start();
		
		Thread.sleep(1000);
		System.gc();
		Thread.sleep(1000);
		
		getValueThread.interrupt();
		checkReferenceQueueThread.interrupt();
	}
	
	private static WeakReference&lt;Object&gt; getWeakReference() {
		Object object = new Object();
		WeakReference&lt;Object&gt; weakReference = new WeakReference&lt;Object&gt;(object, REFERENCE_QUEUE);
		return weakReference;
	}
}</code></pre> 
<p>运行结果为：</p> 
<pre class="has"><code class="language-plain language-java">弱引用对象已被回收，重新为弱引用赋值
弱引用对象已被回收，已被加入到引用队列中</code></pre> 
<p>可以看到，被引用的对象可以自动被垃圾回收器回收，若此时我们仍需要使用此对象，则可以重新生成对象。如果是缓存的话，可以对缓存信息进行重新读取。</p> 
<p>同样，对于使用Map引用的对象，Java类库为我们提供了WeakHashMap类，使用和这个类，它的键自然就是弱引用对象，无需我们再手动包装原始对象。当一个键对象被垃圾回收器回收时，那么相应的值对象的引用会从Map中删除。WeakHashMap能够节约存储空间，可用来缓存那些非必须存在的数据。</p> 
<h4>相关博客</h4> 
<p><a href="https://blog.csdn.net/qq_38293564/article/details/80462506">Java集合之WeakHashMap详解</a></p> 
<h4>参考资料</h4> 
<p>周志明：《深入理解Java虚拟机》</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/186305c72e0e443f789747fb8b131783/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">PHP实现最简单的登录界面</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0df2b9a8dd94edcb232d7f25ffadc6ba/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">把毫秒值转变为对应的年月日时分秒格式的时间</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>