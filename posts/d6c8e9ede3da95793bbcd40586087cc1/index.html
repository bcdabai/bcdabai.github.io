<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>java：java8新特性（Lambda 表达式、方法引用、构造器引用、数组引用、Stream API） - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="java：java8新特性（Lambda 表达式、方法引用、构造器引用、数组引用、Stream API）" />
<meta property="og:description" content="速度更快
对 HashMap 、ConcurrentHashMap低层的数据结构（数组&#43;链表&#43;二叉树）
低层的内存结构（将永久区更新为元空间，元空间使用的是物理内存）
代码更少（增加了新的语法 Lambda 表达式）
强大 Stream API
便于并行
最大化减少空指针异常 Optional
关于时间日期的 API
目录
一、Lambda 表达式
为什么使用 Lambda 表达式
Lambda 表达式的基础语法
函数式接口
Java8内置四大核心函数式接口
其他接口
二、方法引用、构造器引用、数组引用
方法引用
构造器引用
数组引用
三、Stream API
Stream 操作的三个步骤：
创建 Stream
中间操作
终止操作
一、Lambda 表达式 为什么使用 Lambda 表达式 //原来将匿名内部类作为参数进行传递 @Test public void test1(){ TreeSet&lt;String&gt; ts = new TreeSet&lt;&gt;(new Comparator&lt;String&gt;() { @Override public int compare(String o1, String o2) { return o1.compareTo(o2); } }); } //java8中的 Lambda 表达式 @Test public void test2(){ TreeSet&lt;String&gt; ts = new TreeSet&lt;&gt;((x, y) -&gt; x." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/d6c8e9ede3da95793bbcd40586087cc1/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-06-01T10:51:37+08:00" />
<meta property="article:modified_time" content="2020-06-01T10:51:37+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">java：java8新特性（Lambda 表达式、方法引用、构造器引用、数组引用、Stream API）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p> </p> 
<ul><li> <p>速度更快</p> 
  <ul><li> <p>对 HashMap 、ConcurrentHashMap低层的数据结构（数组+链表+二叉树）</p> </li><li> <p>低层的内存结构（将永久区更新为元空间，元空间使用的是物理内存）</p> </li></ul></li><li> <p>代码更少（增加了新的语法 Lambda 表达式）</p> </li><li> <p>强大 Stream API</p> </li><li> <p>便于并行</p> </li><li> <p>最大化减少空指针异常 Optional</p> </li><li> <p>关于时间日期的 API</p> </li></ul> 
<hr> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80%E3%80%81Lambda%20%E8%A1%A8%E8%BE%BE%E5%BC%8F-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81Lambda%20%E8%A1%A8%E8%BE%BE%E5%BC%8F" rel="nofollow">一、Lambda 表达式</a></p> 
<p id="%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%20Lambda%20%E8%A1%A8%E8%BE%BE%E5%BC%8F-toc" style="margin-left:40px;"><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%20Lambda%20%E8%A1%A8%E8%BE%BE%E5%BC%8F" rel="nofollow">为什么使用 Lambda 表达式</a></p> 
<p id="Lambda%20%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95-toc" style="margin-left:40px;"><a href="#Lambda%20%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95" rel="nofollow">Lambda 表达式的基础语法</a></p> 
<p id="%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3-toc" style="margin-left:40px;"><a href="#%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3" rel="nofollow">函数式接口</a></p> 
<p id="Java8%E5%86%85%E7%BD%AE%E5%9B%9B%E5%A4%A7%E6%A0%B8%E5%BF%83%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3-toc" style="margin-left:40px;"><a href="#Java8%E5%86%85%E7%BD%AE%E5%9B%9B%E5%A4%A7%E6%A0%B8%E5%BF%83%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3" rel="nofollow">Java8内置四大核心函数式接口</a></p> 
<p id="%E5%85%B6%E4%BB%96%E6%8E%A5%E5%8F%A3-toc" style="margin-left:40px;"><a href="#%E5%85%B6%E4%BB%96%E6%8E%A5%E5%8F%A3" rel="nofollow">其他接口</a></p> 
<p id="%E4%BA%8C%E3%80%81%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%E3%80%81%E6%9E%84%E9%80%A0%E5%99%A8%E5%BC%95%E7%94%A8%E3%80%81%E6%95%B0%E7%BB%84%E5%BC%95%E7%94%A8-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%E3%80%81%E6%9E%84%E9%80%A0%E5%99%A8%E5%BC%95%E7%94%A8%E3%80%81%E6%95%B0%E7%BB%84%E5%BC%95%E7%94%A8" rel="nofollow">二、方法引用、构造器引用、数组引用</a></p> 
<p id="%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8-toc" style="margin-left:40px;"><a href="#%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8" rel="nofollow">方法引用</a></p> 
<p id="%E6%9E%84%E9%80%A0%E5%99%A8%E5%BC%95%E7%94%A8-toc" style="margin-left:40px;"><a href="#%E6%9E%84%E9%80%A0%E5%99%A8%E5%BC%95%E7%94%A8" rel="nofollow">构造器引用</a></p> 
<p id="%E6%95%B0%E7%BB%84%E5%BC%95%E7%94%A8-toc" style="margin-left:40px;"><a href="#%E6%95%B0%E7%BB%84%E5%BC%95%E7%94%A8" rel="nofollow">数组引用</a></p> 
<p id="%E4%B8%89%E3%80%81Stream%20API-toc" style="margin-left:0px;"><a href="#%E4%B8%89%E3%80%81Stream%20API" rel="nofollow">三、Stream API</a></p> 
<p id="Stream%20%E6%93%8D%E4%BD%9C%E7%9A%84%E4%B8%89%E4%B8%AA%E6%AD%A5%E9%AA%A4%EF%BC%9A-toc" style="margin-left:40px;"><a href="#Stream%20%E6%93%8D%E4%BD%9C%E7%9A%84%E4%B8%89%E4%B8%AA%E6%AD%A5%E9%AA%A4%EF%BC%9A" rel="nofollow">Stream 操作的三个步骤：</a></p> 
<p id="%E5%88%9B%E5%BB%BA%20Stream-toc" style="margin-left:80px;"><a href="#%E5%88%9B%E5%BB%BA%20Stream" rel="nofollow">创建 Stream</a></p> 
<p id="%E4%B8%AD%E9%97%B4%E6%93%8D%E4%BD%9C-toc" style="margin-left:80px;"><a href="#%E4%B8%AD%E9%97%B4%E6%93%8D%E4%BD%9C" rel="nofollow">中间操作</a></p> 
<p id="%E7%BB%88%E6%AD%A2%E6%93%8D%E4%BD%9C-toc" style="margin-left:80px;"><a href="#%E7%BB%88%E6%AD%A2%E6%93%8D%E4%BD%9C" rel="nofollow">终止操作</a></p> 
<hr id="hr-toc"> 
<p> </p> 
<p> </p> 
<h2 id="%E4%B8%80%E3%80%81Lambda%20%E8%A1%A8%E8%BE%BE%E5%BC%8F">一、Lambda 表达式</h2> 
<h3 id="%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%20Lambda%20%E8%A1%A8%E8%BE%BE%E5%BC%8F">为什么使用 Lambda 表达式</h3> 
<pre><code class="language-java">	//原来将匿名内部类作为参数进行传递
	@Test
	public void test1(){
		TreeSet&lt;String&gt; ts = new TreeSet&lt;&gt;(new Comparator&lt;String&gt;() {
			@Override
			public int compare(String o1, String o2) {
				return o1.compareTo(o2);
			}
		});
	}
	
	//java8中的 Lambda 表达式
	@Test
	public void test2(){
		TreeSet&lt;String&gt; ts = new TreeSet&lt;&gt;((x, y) -&gt; x.compareTo(y));
	}</code></pre> 
<p>代码简洁。方便，快速的完成了接口实例和内部类的功能。</p> 
<p> </p> 
<h3 id="Lambda%20%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95">Lambda 表达式的基础语法</h3> 
<p>Lambda 提供了一个全新的操作符，该操作符为“ -&gt; ”, 该操作符称为箭头操作或Lambda操作符。</p> 
<p>箭头操作符将 Lambda 表达式分为两部分：</p> 
<p>左侧：对应函数式接口中抽象方法的参数列表</p> 
<p>右侧：对函数式接口中抽象方法的实现，即 Lambda 体</p> 
<ul><li>语法格式一：无参，无返回值</li></ul> 
<pre><code class="language-java">Runnable r1 = () -&gt; System.out.println("Hello Lambda!");</code></pre> 
<ul><li>语法格式二：有一个参数，无返回值</li></ul> 
<pre><code class="language-java">Cusumer&lt;String&gt; cus = (x) -&gt; System.out.println(x);</code></pre> 
<ul><li>语法格式三：若Lambda表达式左侧只有一个参数</li></ul> 
<pre><code class="language-java">Cusumer&lt;String&gt; cus = x -&gt; System.out.println(x);</code></pre> 
<ul><li>语法格式四：有两个以上参数，Lambda体中有多个条语句，有返回值</li></ul> 
<pre><code class="language-java">Comparator&lt;Integer&gt; com = (x, y) -&gt; {
  	System.out.println("Lambda体中多条语句");
        return Integer.compare(x, y);
};</code></pre> 
<ul><li>语法格式五：若 Lambda 体中只有一条语句，return 和 大括号可以省略不写</li></ul> 
<pre><code class="language-java">Comparator&lt;Integer&gt; com = (x, y) -&gt; Integer.compare(x, y);</code></pre> 
<ul><li>语法格式六：Lambda 左侧参数列表可以省略不写，因为 Java 编译器可以通过上下文推断出数据类型，即“<strong>类型推断</strong>”</li></ul> 
<pre><code class="language-java">Comparator&lt;Integer&gt; com = (Integer x, Integer y) -&gt; Integer.compare(x, y);</code></pre> 
<p>注意：Lambda 表达式需要函数式接口的支持</p> 
<p> </p> 
<h3 id="%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3">函数式接口</h3> 
<p>若一个接口中只有一个抽象方法，该接口为函数式接口。可以使用 @FunctionalInterface 修饰，说明该接口必须是函数式接口</p> 
<pre><code class="language-java">@FunctionalInterface
public interface MyFunction&lt;T&gt;{
    T apply(T t);
}</code></pre> 
<p> </p> 
<h3 id="Java8%E5%86%85%E7%BD%AE%E5%9B%9B%E5%A4%A7%E6%A0%B8%E5%BF%83%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3">Java8内置四大核心函数式接口</h3> 
<table border="1" cellspacing="0" style="width:700px;"><tbody><tr><td style="border-color:#ffffff;text-align:center;vertical-align:top;width:172pt;"> <p style="margin-left:0in;"><strong>函数式接口</strong></p> </td><td style="border-color:#ffffff;text-align:center;vertical-align:top;width:172pt;"> <p style="margin-left:0in;"><strong>参数类型</strong></p> </td><td style="border-color:#ffffff;text-align:center;vertical-align:top;width:172pt;"> <p style="margin-left:0in;"><strong>返回类型</strong></p> </td><td style="border-color:#ffffff;text-align:center;vertical-align:top;width:224px;"> <p style="margin-left:0in;"><strong>用途</strong></p> </td></tr><tr><td style="border-color:#ffffff;text-align:center;vertical-align:top;width:172pt;"> <p style="margin-left:0in;"><strong>Consumer&lt;T&gt;</strong></p> <p style="margin-left:0in;"><strong>消费型接口</strong></p> </td><td style="border-color:#ffffff;text-align:center;vertical-align:top;width:172pt;"> <p style="margin-left:0in;">T</p> </td><td style="border-color:#ffffff;text-align:center;vertical-align:top;width:172pt;"> <p style="margin-left:0in;">void</p> </td><td style="border-color:#ffffff;text-align:center;vertical-align:top;width:224px;"> <p style="margin-left:0in;">对类型为T的对象应用操作，包含方法：</p> <p style="margin-left:0in;">void accept(T t)</p> </td></tr><tr><td style="border-color:#ffffff;text-align:center;vertical-align:top;width:172pt;"> <p style="margin-left:0in;"><strong>Supplier&lt;T&gt;</strong></p> <p style="margin-left:0in;"><strong>供给型接口</strong></p> </td><td style="border-color:#ffffff;text-align:center;vertical-align:top;width:172pt;"> <p style="margin-left:0in;">无</p> </td><td style="border-color:#ffffff;text-align:center;vertical-align:top;width:172pt;"> <p style="margin-left:0in;">T</p> </td><td style="border-color:#ffffff;text-align:center;vertical-align:top;width:224px;"> <p style="margin-left:0in;">返回类型为T的对象，包含方法：T get();</p> </td></tr><tr><td style="border-color:#ffffff;text-align:center;vertical-align:top;width:172pt;"> <p style="margin-left:0in;"><strong>Function&lt;T, R&gt;</strong></p> <p style="margin-left:0in;"><strong>函数型接口</strong></p> </td><td style="border-color:#ffffff;text-align:center;vertical-align:top;width:172pt;"> <p style="margin-left:0in;">T</p> </td><td style="border-color:#ffffff;text-align:center;vertical-align:top;width:172pt;"> <p style="margin-left:0in;">R</p> </td><td style="border-color:#ffffff;text-align:center;vertical-align:top;width:224px;"> <p style="margin-left:0in;">对类型为T的对象应用操作，并返回结果。结果是R类型的对象。包含方法：R apply(T t);</p> </td></tr><tr><td style="border-color:#ffffff;text-align:center;vertical-align:top;width:172pt;"> <p style="margin-left:0in;"><strong>Predicate&lt;T&gt;</strong></p> <p style="margin-left:0in;"><strong>断定型接口</strong></p> </td><td style="border-color:#ffffff;text-align:center;vertical-align:top;width:172pt;"> <p style="margin-left:0in;">T</p> </td><td style="border-color:#ffffff;text-align:center;vertical-align:top;width:172pt;"> <p style="margin-left:0in;">boolean</p> </td><td style="border-color:#ffffff;text-align:center;vertical-align:top;width:224px;"> <p style="margin-left:0in;">确定类型为T的对象是否满足某约束，并返回 boolean 值。包含方法</p> <p style="margin-left:0in;">boolean test(T t);</p> </td></tr></tbody></table> 
<p> </p> 
<h3 id="%E5%85%B6%E4%BB%96%E6%8E%A5%E5%8F%A3"><span style="color:#000000;"><strong>其他</strong></span><span style="color:#000000;"><strong>接口</strong></span></h3> 
<table border="1" cellspacing="0"><tbody><tr><td style="border-color:#ffffff;text-align:center;vertical-align:top;width:255pt;"> <p style="margin-left:0in;"><strong>函数式接口</strong></p> </td><td style="border-color:#ffffff;text-align:center;vertical-align:top;width:88pt;"> <p style="margin-left:0in;"><strong>参数类型</strong></p> </td><td style="border-color:#ffffff;text-align:center;vertical-align:top;width:171pt;"> <p style="margin-left:0in;"><strong>返回类型</strong></p> </td><td style="border-color:#ffffff;text-align:center;vertical-align:top;width:171pt;"> <p style="margin-left:0in;"><strong>用途</strong></p> </td></tr><tr><td style="border-color:#ffffff;text-align:justify;vertical-align:top;width:255pt;"> <p style="margin-left:0in;"><strong>BiFunction&lt;T, U, R&gt;</strong></p> </td><td style="border-color:#ffffff;text-align:justify;vertical-align:top;width:88pt;"> <p style="margin-left:0in;">T, U</p> </td><td style="border-color:#ffffff;text-align:justify;vertical-align:top;width:171pt;"> <p style="margin-left:0in;">R</p> </td><td style="border-color:#ffffff;text-align:justify;vertical-align:top;width:171pt;"> <p style="margin-left:0in;">对类型为 T, U 参数应用操作，返回 R 类型的结果。包含方法为</p> <p style="margin-left:0in;">R apply(T t, U u);</p> </td></tr><tr><td style="border-color:#ffffff;text-align:justify;vertical-align:top;width:255pt;"> <p style="margin-left:0in;"><strong>UnaryOperator&lt;T&gt;</strong></p> <p style="margin-left:0in;"><strong>(Function子接口)</strong></p> </td><td style="border-color:#ffffff;text-align:justify;vertical-align:top;width:88pt;"> <p style="margin-left:0in;">T</p> </td><td style="border-color:#ffffff;text-align:justify;vertical-align:top;width:171pt;"> <p style="margin-left:0in;">T</p> </td><td style="border-color:#ffffff;text-align:justify;vertical-align:top;width:171pt;"> <p style="margin-left:0in;">对类型为T的对象进行一元运算，并返回T类型的结果。包含方法为</p> <p style="margin-left:0in;">T apply(T t);</p> </td></tr><tr><td style="border-color:#ffffff;text-align:justify;vertical-align:top;width:255pt;"> <p style="margin-left:0in;"><strong>BinaryOperator&lt;T&gt;</strong></p> <p style="margin-left:0in;"><strong>(BiFunction</strong> <strong>子接口)</strong></p> </td><td style="border-color:#ffffff;text-align:justify;vertical-align:top;width:88pt;"> <p style="margin-left:0in;">T, T</p> </td><td style="border-color:#ffffff;text-align:justify;vertical-align:top;width:171pt;"> <p style="margin-left:0in;">T</p> </td><td style="border-color:#ffffff;text-align:justify;vertical-align:top;width:171pt;"> <p style="margin-left:0in;">对类型为T的对象进行二元运算，并返回T类型的结果。包含方法为</p> <p style="margin-left:0in;">T apply(T t1, T t2);</p> </td></tr><tr><td style="border-color:#ffffff;text-align:justify;vertical-align:top;width:255pt;"> <p style="margin-left:0in;"><strong>BiConsumer&lt;T, U&gt;</strong></p> </td><td style="border-color:#ffffff;text-align:justify;vertical-align:top;width:88pt;"> <p style="margin-left:0in;">T, U</p> </td><td style="border-color:#ffffff;text-align:justify;vertical-align:top;width:171pt;"> <p style="margin-left:0in;">void</p> </td><td style="border-color:#ffffff;text-align:justify;vertical-align:top;width:171pt;"> <p style="margin-left:0in;">对类型为T, U 参数应用操作。包含方法为</p> <p style="margin-left:0in;">void accept(T t, U u)</p> </td></tr><tr><td style="border-color:#ffffff;text-align:justify;vertical-align:top;width:255pt;"> <p style="margin-left:0in;"><strong>ToIntFunction&lt;T&gt;</strong></p> <p style="margin-left:0in;"><strong>ToLongFunction&lt;T&gt;</strong></p> <p style="margin-left:0in;"><strong>ToDoubleFunction&lt;T&gt;</strong></p> </td><td style="border-color:#ffffff;text-align:justify;vertical-align:top;width:88pt;"> <p style="margin-left:0in;">T</p> </td><td style="border-color:#ffffff;text-align:justify;vertical-align:top;width:171pt;"> <p style="margin-left:0in;">int</p> <p style="margin-left:0in;">long</p> <p style="margin-left:0in;">double</p> </td><td style="border-color:#ffffff;text-align:justify;vertical-align:top;width:171pt;"> <p style="margin-left:0in;">分别计算int、long、double、值的函数</p> </td></tr><tr><td style="border-color:#ffffff;text-align:justify;vertical-align:top;width:255pt;"> <p style="margin-left:0in;"><strong>IntFunction&lt;R&gt;</strong></p> <p style="margin-left:0in;"><strong>LongFunction&lt;R&gt;</strong></p> <p style="margin-left:0in;"><strong>DoubleFunction&lt;R&gt;</strong></p> </td><td style="border-color:#ffffff;text-align:justify;vertical-align:top;width:88pt;"> <p style="margin-left:0in;">int</p> <p style="margin-left:0in;">long</p> <p style="margin-left:0in;">double</p> </td><td style="border-color:#ffffff;text-align:justify;vertical-align:top;width:171pt;"> <p style="margin-left:0in;">R</p> </td><td style="border-color:#ffffff;text-align:justify;vertical-align:top;width:171pt;"> <p style="margin-left:0in;">参数分别为int、long、double 类型的函数</p> </td></tr></tbody></table> 
<p> </p> 
<h2 id="%E4%BA%8C%E3%80%81%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%E3%80%81%E6%9E%84%E9%80%A0%E5%99%A8%E5%BC%95%E7%94%A8%E3%80%81%E6%95%B0%E7%BB%84%E5%BC%95%E7%94%A8">二、方法引用、构造器引用、数组引用</h2> 
<h3 id="%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8"><strong>方法引用</strong></h3> 
<p>若 Lambda 体中需要完成的功能，已经有现成的方法，提供了实现，可以选择使用方法引用替代Lambda表达式。（<span style="color:#f33b45;">方法引用是 Lambda 表达式的另外一种表现形式</span>）</p> 
<p><strong>格式：</strong></p> 
<p>对象::实例方法名</p> 
<pre><code class="language-java">Consumer&lt;String&gt; con = (x) -&gt; System.out.println(x);
Consumer&lt;String&gt; con2 = System.out::println;</code></pre> 
<p>注意：接口中抽象方法的参数列表必须与Lambda体中调用方法的参数列表保持一致！</p> 
<p>类::静态方法名</p> 
<pre><code class="language-java">Compartor&lt;Integer&gt; com = Integer::compare;</code></pre> 
<p>类::实例方法名</p> 
<pre><code class="language-java">BiPredicate&lt;String, String&gt; bp = (x, y) -&gt; x.equals(y);
BiPredicate&lt;String, String&gt; bp2 = String::equals;</code></pre> 
<p>注意：若Lambda参数列表中第一个参数，是 Lambda体中方法的调用者，第二个参数是Lambda体中方法的参数</p> 
<p> </p> 
<h3 id="%E6%9E%84%E9%80%A0%E5%99%A8%E5%BC%95%E7%94%A8">构造器引用</h3> 
<p style="margin-left:0in;"><span style="color:#000000;"><strong>格式：   </strong></span><span style="color:#ff0000;"><strong>ClassName</strong></span><span style="color:#ff0000;"><strong>::</strong></span><span style="color:#ff0000;"><strong>new </strong></span></p> 
<p style="margin-left:0in;"><span style="color:#000000;">与</span><span style="color:#000000;">函数式接口相结合，自动与函数式接口中方法兼容</span><span style="color:#000000;">。</span></p> 
<p style="margin-left:0in;"><span style="color:#000000;">可以把构造器引用赋值给定义的方法，与构造器参数列表要与接口中抽象方法的参数列表一致！</span></p> 
<p><img alt="" height="128" src="https://images2.imgbox.com/21/f5/11mCoa8r_o.png" width="557"></p> 
<p> </p> 
<h3 id="%E6%95%B0%E7%BB%84%E5%BC%95%E7%94%A8"><span style="color:#000000;"><strong>数组引用</strong></span></h3> 
<p style="margin-left:0in;"><strong><span style="color:#000000;">格式： </span><span style="color:#ff0000;">type[ ] :: </span><span style="color:#ff0000;">new</span></strong></p> 
<p><img alt="" height="185" src="https://images2.imgbox.com/18/df/dehcNbv9_o.png" width="622"></p> 
<p> </p> 
<h2 id="%E4%B8%89%E3%80%81Stream%20API">三、<span style="color:#000000;"><strong>Stream API</strong></span></h2> 
<p style="margin-left:0in;"><span style="color:#000000;">Java8</span><span style="color:#000000;">中有两大最为重要的改变。第一个是 </span><span style="color:#000000;">Lambda </span><span style="color:#000000;">表达式；另外一个则是 </span><span style="color:#0070c0;"><strong>Stream API(</strong></span><span style="color:#0070c0;"><strong>java.util.stream</strong></span><span style="color:#0070c0;"><strong>.*)</strong></span><span style="color:#000000;">。</span></p> 
<p style="margin-left:0in;"><span style="color:#000000;">Stream </span><span style="color:#000000;">是 </span><span style="color:#000000;">Java8 </span><span style="color:#000000;">中处理集合的关键抽象概念，它可以指定你希望对集合进行的操作，可以执行非常复杂的查找、过滤和映射数据等操作。 使用</span><span style="color:#000000;">Stream API </span><span style="color:#000000;">对集合数据进行操作，就类似于使用 </span><span style="color:#000000;">SQL </span><span style="color:#000000;">执行的数据库查询。也可以使用 </span><span style="color:#000000;">Stream API </span><span style="color:#000000;">来并行执行操作。简而言之，</span><span style="color:#000000;">Stream API </span><span style="color:#000000;">提供了一种高效且易于使用的处理数据的方式</span><span style="color:#000000;">。</span></p> 
<p style="text-align:center;"><img alt="" height="129" src="https://images2.imgbox.com/ce/a0/vuMbVgZe_o.png" width="700"></p> 
<h3 id="Stream%20%E6%93%8D%E4%BD%9C%E7%9A%84%E4%B8%89%E4%B8%AA%E6%AD%A5%E9%AA%A4%EF%BC%9A">Stream 操作的三个步骤：</h3> 
<ul><li> <h4 id="%E5%88%9B%E5%BB%BA%20Stream">创建 Stream</h4> </li></ul> 
<pre><code class="language-java">	//1. 创建 Stream 的四种方式
	@Test
	public void test1(){
		//1. 通过 Collection 系列集合提供两个 stream() 和 parallelStream()
		List&lt;String&gt; list = new ArrayList&lt;&gt;();
		Stream&lt;String&gt; stream1 = list.stream();
		
		//2. 通过 Arrays 中的 stream() 获取一个数组流
		Integer[] nums = new Integer[10];
		Stream&lt;Integer&gt; stream2 = Arrays.stream(nums);
		
		//3. 通过 Stream 类中静态方法 of
		Stream stream3 = Stream.of("aaa", "bb", "cc");
		
		//4. 创建无限流
		//迭代
		/*Stream stream4 = Stream.iterate(0, (x) -&gt; x + 2);
		stream4.forEach(System.out::println);*/

		//生成
		Stream stream5 = Stream.generate(Math::random).limit(2);
		stream5.forEach(System.out::println);
	}</code></pre> 
<ul><li> <h4 id="%E4%B8%AD%E9%97%B4%E6%93%8D%E4%BD%9C">中间操作</h4> </li></ul> 
<p><span style="color:#f33b45;">中间操作流不会进行任何操作，只有做了终止操作后，流一次性的执行全部，“惰性求值”</span></p> 
<p><strong>筛选与切片</strong> filter——接收 Lambda ， 从流中排除某些元素。 limit——截断流，使其元素不超过给定数量。 skip(n) —— 跳过元素，返回一个扔掉了前 n 个元素的流。若流中元素不足 n 个，则返回一个空流。与 limit(n) 互补 distinct——筛选，通过流所生成元素的 hashCode() 和 equals() 去除重复元素</p> 
<p><strong>映射</strong> map——接收 Lambda ， 将元素转换成其他形式或提取信息。接收一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素。 flatMap——接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流</p> 
<ul><li> <h4 id="%E7%BB%88%E6%AD%A2%E6%93%8D%E4%BD%9C">终止操作</h4> </li></ul> 
<p> </p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7c4aae18da9f547c938cbc8d473aa999/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">json概念信息</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9f71b5a0b998ab8ff1b07fcc1ab1f922/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【计算机网络 22】基础知识总结</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>