<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C语言 函数 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C语言 函数" />
<meta property="og:description" content="一、什么是函数 （模块化设计） 概念： 函数（function)是C语言用来实现一个或多个功能的代码块（个人理解），实现了C语言面向过程，面向结构的设计思路，是C语言的核心和主体。（后面加括号就表示它是一个函数） 函数对C语言的作用（优化C语言中结构套结构的问题） 1、提高代码的复用
相同的功能可以封装成一个函数，用到该功能时直接调用函数；
2、提高代码的扩展性
增删功能，不用在整体代码上删改，这样容易出错，把功能封装成函数后，只要修改相应功能模块就行了
3、增强代码的维护性
出现问题可以直接找到实现该功能的代码，方便修改和判断位置
补：
面向过程：把问题分解成一个个步骤（功能），按照一定顺序实现一个个步骤（功能），实现模块化程序设计的思路。
面向对象：面向对象是把构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为。当解决一个问题的时候，面向对象会把事物抽象成对象的概念，就是说这个问题里面有哪些对象，然后给对象赋一些属性和方法，然后让每个对象去执行自己的方法，问题得到解决。 二、函数的相关语法 1、函数的三要素 函数名 函数形参 函数返回值 int main (int argc,char ** argv) int 表示函数的返回值类型是整形
main 主函数名，程序运行第一个执行的函数
(int argc,char ** argv) 函数形参,命令行参数，Linux终端运行程序时用来给主程序传入参数 ，./run也算一个命令行参数，argc 表示命令行参数个数，char ** argv也可以写成char * argv[ ],数组指针，指针指向数组的每一个元素
return 0;在Linux中给系统返回程序运行状态，最好加上，可以及时回收系统资源，其他情况return可以返回不同类型（根据定义类型）的函数返回值
命令行参数例：
#include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; int main(int argc,char ** argv) { if(argc!= 3) { printf(&#34;please input three name&#34;); exit(1); } printf(&#34;%s %s\n&#34;,argv[1],argv[2]); return 0; } 2、函数的使用形式 函数声明 函数定义 函数返回值（越学越感觉重要） 1、函数调用包含元素：函数名 实参的变量名或地址（重点传值还是传地址） 2、函数声明包含元素：函数名 返回值 形参的类型，可以不提供变量名（函数声明不是定义，不分配内存） 注意：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/f0818ef5fca998d3497821c9e7cba7bd/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-01-07T14:30:30+08:00" />
<meta property="article:modified_time" content="2022-01-07T14:30:30+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C语言 函数</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>一、什么是函数 （模块化设计）</h2> 
<h4>     概念：   函数（function)是C语言用来实现一个或多个<span style="color:#fe2c24;">功能</span>的代码块（个人理解），实现了C语言面向过程，面向结构的设计思路，是C语言的核心和主体。（后面加括号就表示它是一个函数）</h4> 
<h4>函数对C语言的作用（优化C语言中结构套结构的问题）</h4> 
<p>        1、提高代码的复用</p> 
<p>相同的功能可以封装成一个函数，用到该功能时直接调用函数；</p> 
<p>        2、提高代码的扩展性</p> 
<p>增删功能，不用在整体代码上删改，这样容易出错，把功能封装成函数后，只要修改相应功能模块就行了</p> 
<p>        3、增强代码的维护性</p> 
<p>出现问题可以直接找到实现该功能的代码，方便修改和判断位置</p> 
<p>补：</p> 
<p>        面向过程：把问题分解成一个个步骤（功能），按照一定顺序实现一个个步骤（功能），实现模块化程序设计的思路。</p> 
<p>        面向对象：面向对象是把构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为。当解决一个问题的时候，面向对象会把事物抽象成对象的概念，就是说这个问题里面有哪些对象，然后给对象赋一些属性和方法，然后让每个对象去执行自己的方法，问题得到解决。  </p> 
<h2>二、函数的相关语法</h2> 
<h3><strong>1、函数的三要素 <span style="color:#fe2c24;">函数名</span> <span style="color:#fe2c24;">函数形参 函数返回值</span></strong></h3> 
<p>           int main (int argc,char ** argv)       </p> 
<p>int 表示函数的返回值类型是整形</p> 
<p>main 主函数名，程序运行第一个执行的函数</p> 
<p>  (int argc,char ** argv)     函数形参,命令行参数，Linux终端运行程序时用来给主程序传入参数 ，./run也算一个命令行参数，argc 表示命令行参数个数，char ** argv也可以写成char * argv[ ],数组指针，指针指向数组的每一个元素</p> 
<p>return 0;在Linux中给系统返回程序运行状态，最好加上，可以及时回收系统资源，其他情况return可以返回不同类型（根据定义类型）的函数返回值</p> 
<p> 命令行参数例：</p> 
<pre><code>#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;

int main(int argc,char ** argv)
{
    if(argc!= 3)
    {
        printf("please input three name");
        exit(1);
    }
    printf("%s %s\n",argv[1],argv[2]);
 return 0;

}</code></pre> 
<p><img alt="" height="71" src="https://images2.imgbox.com/97/a6/ggn1NWLt_o.png" width="854"></p> 
<p></p> 
<p>               </p> 
<h3>2、函数的使用形式 函数声明 函数定义 函数返回值（越学越感觉重要）</h3> 
<h4>        1、函数调用包含元素：函数名 实参的变量名或地址（重点传值还是传地址）</h4> 
<h4>        2、函数声明包含元素：函数名 返回值 形参的类型，可以不提供变量名（函数声明不是定义，不分配内存）</h4> 
<p><strong> 注意</strong>：</p> 
<p>        a、<span style="color:#fe2c24;">声明不分配内存，函数声明是为了提前告诉编译器这是一个函数，调用时不出错，</span>所以在调用函数位置后定义的函数要在调用前加上函数声明</p> 
<p>        b、<span style="color:#fe2c24;">实参传递时要根据调用函数的类型</span>，什么类型传什么函数实参，或者说形参定义什么类型接实参要根据实参的类型。</p> 
<p>指针传参        实参是一维指针地址用二维指针接，传递一维指针名用一维指针</p> 
<h4>       3、 函数调用过程</h4> 
<p>a、通过函数名找到函数入口地址</p> 
<p>函数地址=函数入口地址=&amp;函数名（函数指针(*a)(void *),指针保存函数的地址，其实就是函数名被指针代替）</p> 
<p>b、给形参分配空间（传参时）</p> 
<p>c、传参 将实参复制一份（注意区分是地址还是值）传递给形参的空间储存</p> 
<p>d、执行函数体的语句</p> 
<p>e、函数返回，释放函数分配的空间（函数分配的空间是局部变量）</p> 
<p>    </p> 
<h4>  4、传值 （传的是实参变量名）VS 传地址（传实参变量的地址）</h4> 
<p>        传值，相当于把实参值复制一份给形参变量，与当前变量的没有关系，就是说形参发生改变，实参变量不变</p> 
<p>        传地址相当于把地址传复制一份给形参变量，我改变传递的地址同样不关实参的事，但是我可已通过地址找到地址中的内容，改变内容，实参内容肯定就会变了</p> 
<p>        例：传值，相当于你(形参)根据我（实参）的房子盖了一样的房子，你在你家怎么折腾都对我家没影响；传地址相当于我把我家地址写个纸条给你，你对这个纸条地址怎么改我家地址还是不会变，但你是根据地址到我家来了，你对我家做的任何事都会对我家产生实际影响</p> 
<pre><code>#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
void func1(char * ptr )
{
    ptr++;
}
void func2(char ** ptr )
{
   (*ptr)++; 
}
void func3(char * ptr)
{
    ++ptr;
    * ptr = 'E';
}
int main(int argc,char**argv)
{
    char *ptr = "hello world";
    func1(ptr);
    printf("ptr1 = %s\n",ptr);

    func2(&amp;ptr);
    printf("ptr2 = %s\n",ptr);

    char buffer[20] = {"hello world"};
    //char buffer[20];
    //buffer[20] = {"hello world"};//不能先定义后赋值
    char * ptr3 = buffer; //指针的内容是数组的地址，不是指向
    func3(ptr3);
    printf("buffer = %s\n",buffer);

    return 0;
}</code></pre> 
<p><span style="color:#fe2c24;"><strong>  </strong></span><img alt="" height="136" src="https://images2.imgbox.com/b0/75/5LzuiOgh_o.png" width="729"><span style="color:#fe2c24;"><strong>  注意：</strong></span></p> 
<p><span style="color:#fe2c24;">       1、 使用不修改实参内存空间的值时传值，即使用又修改实参变量的值时传地址，</span></p> 
<p><span style="color:#fe2c24;">        2、传什么类型用什么类型去接，不然出错</span></p> 
<p><span style="color:#fe2c24;">        3、一般不直接把传递的形参作为变量使用，在自定义的函数中另外定义一个临时变量使用，防止出错        </span></p> 
<p><span style="color:#fe2c24;">        4、传指针不能认为就是传地址</span></p> 
<p><span style="color:#fe2c24;">        5、函数的调用和返回开销比较大，在一些特定情况下可以用其他方法代替，如宏定义函数等</span></p> 
<p></p> 
<h2>三、函数编码规范</h2> 
<p>        实现高内聚，低耦合</p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<h2></h2> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3318aec1c90925628f805e9e9912a6ec/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Jetson NX通过SSD硬盘启动的方法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ed91f861d09ec4e931de191ec8b33802/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">CMake 设置Target输出目录和后缀名</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>