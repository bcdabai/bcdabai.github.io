<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>mysql InnoDB 数据存储和查找 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="mysql InnoDB 数据存储和查找" />
<meta property="og:description" content="InnoDB 引擎数据存储 要想了解数据库 InnoDB 引擎是怎么样存储数据的，必须先了解 B&#43;Tree，了解之后才容易理解其存储原理
在 InnoDB 存储引擎中，也有页的概念，默认每个页的大小为 16K，也就是每次读取数据时都是读取 4*4K 的大小。
一般表的主键类型为INT（占用4个字节）或BIGINT（占用8个字节），指针类型也一般为4或8个字节，也就是说一个页（B&#43;Tree中的一个节点）中大概存储16KB/(8B&#43;8B)=1K个键值（因为是估值，为方便计算，这里的K取值为 10^3）。也就是说一个深度为3的B&#43;Tree索引可以维护10^3 * 10^3 * 10^3 = 10亿 条记录。
实际情况中每个节点可能不能填充满，因此在数据库中，B&#43;Tree的高度一般都在2~4层。mysql的InnoDB存储引擎在设计时是将根节点常驻内存的，也就是说查找某一键值的行记录时最多只需要1~3次磁盘I/O操作
假设我们现在有一个用户表，我们往里面写数据，如下图：
注意：在某个页内插入新数据时，为了减少数据的移动，通常是插入到当前行的后面或者是已删除行留下来的空间，所以在某一个页内的数据并不是完全有序的。为了数据访问的顺序性，每条记录中都有指向下一条记录的指针，以此构成了一个有序的链表
由于只有10条记录，可以放在同一页 page1上，如果每页只能存放10条记录，当第 11 条记录插入时，数据是怎么存放的呢？如下图：
存储过程如下：
1、创建新页 page2，将 page1 的数据复制到 page2上
2、创建新页 page3，将新数据插入到 page3中
3、原来的 page1 还作为根节点，但是变成了一个只存放索引（11）不存放数据的页了，它有两个子节点 page2 和 page3
这里有以下两个问题
1、为什么要复制 page1 数据到 page2 而不是创建一个新的 page1 作为根节点 ，原来的 page1 成为 page2，这样子就减少了数据复制开销？
如果是创建新的 page1 为根节点的话，其存储的物理地址可能会变，在 InnoDB 引擎中根结点是会预读到内存中的，如果根节点的地址变了，不利于数据查找了
2、插入第 11 条数据之后，节点裂变了，根据 B&#43;Tree 的特性，它至少是 11 阶，而裂变之后每个节点的元素至少为 11/2 = 5个，那么数据分布应该是 1-5 key的数据放到 page2 中，6-11 key的数据放到 page3 中，根节点存放主键 key 6呢？" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/cc5724e7d3a2dc2e0801de366a15576d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-08-06T10:36:46+08:00" />
<meta property="article:modified_time" content="2019-08-06T10:36:46+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">mysql InnoDB 数据存储和查找</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h4>InnoDB 引擎数据存储</h4> 
<p>要想了解数据库 InnoDB 引擎是怎么样存储数据的，必须先了解 <a href="https://blog.csdn.net/ywlmsm1224811/article/details/97890446">B+Tree</a>，了解之后才容易理解其存储原理</p> 
<p>在 InnoDB 存储引擎中，也有页的概念，<strong><span style="color:#f33b45;">默认每个页的大小为 16K</span></strong>，也就是每次读取数据时都是读取 <span style="color:#f33b45;"><strong>4*4K </strong></span>的大小。</p> 
<p>一般表的主键类型为INT（占用4个字节）或BIGINT（占用8个字节），指针类型也一般为4或8个字节，也就是说一个页（B+Tree中的一个节点）中大概存储16KB/(8B+8B)=1K个键值（因为是估值，为方便计算，这里的K取值为 10^3）。也就是说一个深度为3的B+Tree索引可以维护10^3 * 10^3 * 10^3 = 10亿 条记录。</p> 
<p>实际情况中每个节点可能不能填充满，因此在数据库中，<strong><span style="color:#f33b45;">B+Tree的高度一般都在2~4层</span></strong>。mysql的InnoDB存储引擎在设计时是将<span style="color:#f33b45;"><strong>根节点常驻内存的</strong></span>，也就是说查找某一键值的行记录时最多只需要<span style="color:#f33b45;"><strong>1~3次磁盘I/O</strong></span>操作</p> 
<p>假设我们现在有一个用户表，我们往里面写数据，如下图：</p> 
<p><img alt="" class="has" height="411" src="https://images2.imgbox.com/56/d7/Vaoh5IPe_o.png" width="267"></p> 
<p>注意：在某个页内插入新数据时，为了减少数据的移动，通常是插入到当前行的后面或者是已删除行留下来的空间，所以在某一个页内的数据并不是完全有序的。为了数据访问的顺序性，每条记录中都有指向下一条记录的指针，以此构成了一个有序的链表</p> 
<p>由于只有10条记录，可以放在同一页 page1上，如果每页只能存放10条记录，当第 11 条记录插入时，数据是怎么存放的呢？如下图：</p> 
<p><img alt="" class="has" height="429" src="https://images2.imgbox.com/ae/90/RBVIohYa_o.png" width="499"></p> 
<p>存储过程如下：</p> 
<p><span style="color:#f33b45;">1、创建新页 page2，将 page1 的数据复制到 page2上</span></p> 
<p><span style="color:#f33b45;">2、创建新页 page3，将新数据插入到 page3中</span></p> 
<p><span style="color:#f33b45;">3、原来的 page1 还作为根节点，但是变成了一个只存放索引（11）不存放数据的页了，它有两个子节点 page2 和 page3</span></p> 
<p>这里有以下两个问题</p> 
<p><span style="color:#86ca5e;">1、为什么要复制 page1 数据到 page2 而不是创建一个新的 page1 作为根节点 ，原来的 page1 成为 page2，这样子就减少了数据复制开销？</span></p> 
<p>如果是创建新的 page1 为根节点的话，其存储的物理地址可能会变，在 InnoDB 引擎中根结点是会预读到内存中的，如果根节点的地址变了，不利于数据查找了</p> 
<p><span style="color:#86ca5e;">2、插入第 11 条数据之后，节点裂变了，根据 B+Tree 的特性，它至少是 11 阶，而裂变之后每个节点的元素至少为 11/2 = 5个，那么数据分布应该是 1-5 key的数据放到 page2 中，6-11 key的数据放到 page3 中，根节点存放主键 key 6呢？</span></p> 
<p>如果是这样的话，新页的利用率只有 50%，而且还会导致频繁的页（节点）分裂</p> 
<p>由于这个缺点，InnoDB 对这一点做了优化，<strong><span style="color:#f33b45;">新插入的数据放到新创建的页，原有页的数据不移动</span></strong></p> 
<p>随着数据的不断写入，B+Tree数据存储如下图：</p> 
<p><img alt="" class="has" height="438" src="https://images2.imgbox.com/c3/3b/cxnyoBfZ_o.png" width="834"></p> 
<p> </p> 
<p> </p> 
<p><br><strong>主键自增</strong></p> 
<p>每当数据页写满之后就会创建新的页来存储，这里其实有个隐含条件，那就是主键自增。</p> 
<p><span style="color:#f33b45;"><strong>主键自增优势：插入效率高，页的利用率高</strong></span></p> 
<p>主键自增时新插入的数据不会影响到原有页的数据，不仅插入效率高，而且页的利用率也高。如果主键无序或者随机，每次插入数据可能会导致原有页频繁分裂，严重影响插入效率，同时页的利用率也比较低。这也是为什么在 InnoDB 中建议设置主键自增的原因</p> 
<p><span style="color:#86ca5e;">B+Tree 非叶子节点存放的都是主键索引，如果一个表中没有设置主键会怎么处理呢？</span></p> 
<p>如果一个表中没有设置主键，<span style="color:#f33b45;"><strong>默认会找一个建了唯一索引的列。如果唯一索引列也没有，则会生成一个隐形的字段作为主键</strong></span></p> 
<p>如果表频繁的插入和删除的话，会导致页产生碎片，降低页的空间利用率，即降低查询效率，这可以通过索引重建来消除碎片，提高查询效率</p> 
<h4>InnoDB 引擎数据查找</h4> 
<p>通常在B+Tree上有两个头指针，<strong><span style="color:#f33b45;">一个指向根节点，另一个指向 key(关键字)最小的叶子节点</span></strong>，而且所有叶子节点（即数据节点）之间是一种链式环结构。因此可以对B+Tree进行两种查找运算：<span style="color:#f33b45;"><strong>一种是对于主键的范围查找和分页查找，另一种是从根节点开始，进行随机查找</strong></span>。</p> 
<p>InnoDB 存储数据后，怎么做查找的呢？通过以下两个步骤查找</p> 
<p><span style="color:#f33b45;"><strong>1、找到数据所在的页</strong></span>，这个过程就是 B+Tree 查找，即从根节点开始一直找到叶子节点（数据所在页）</p> 
<p><span style="color:#f33b45;"><strong>2、在数据页内查找数据</strong></span>，读取 1 中查找到的叶子节点数据（页数据）到内存中，然后通过<span style="color:#f33b45;"><strong>分块查找的方法</strong></span>找到具体数据</p> 
<p>这个查找过程就像是到新华字典上查找某一个汉字，先定位到哪一页，然后在页中找到具体的汉字。</p> 
<p>InnoDB 在页中使用了哪种策略快速查找某个主键呢？这就要我们从页结构了解开始，如下图：</p> 
<p><img alt="" class="has" height="597" src="https://images2.imgbox.com/a7/82/qgvBmpu7_o.png" width="455"></p> 
<p><strong>左边区域：</strong>左边蓝色区域称为 <span style="color:#f33b45;"><strong>Page Directory(页目录)</strong></span>，这块区域由多个 Slot 组成，是一个<span style="color:#f33b45;"><strong>稀疏索引结构</strong></span>，即一个槽中可能属于多个记录，最少属于 <span style="color:#f33b45;"><strong>4</strong></span> 条记录，最多属于 <span style="color:#f33b45;"><strong>8 </strong></span>条记录。槽内的数据是<span style="color:#f33b45;"><strong>有序存放</strong></span>的，所以当我们寻找一条数据的时候可以<span style="color:#f33b45;"><strong>先在槽中通过二分法查找到一个大致的位置</strong></span></p> 
<p><strong>右边区域：<span style="color:#f33b45;">数据区域</span></strong>，每一个数据页中都包含多条行数据。注意看图中最上面和最下面的两条特殊的行记录 Infimum 和 Supremum，这是两个虚拟的行记录。在<strong>没有其他用户数据的时候 Infimum 的下一条记录的指针指向 Supremum</strong>。当有用户数据的时候，<span style="color:#f33b45;"><strong>Infimum 的下一条记录的指针指向当前页中最小的用户记录</strong></span>，<span style="color:#f33b45;"><strong>当前页中最大的用户记录的下一条记录的指针指向 Supremum</strong></span>，至此整个页内的所有行记录形成一个单向链表</p> 
<p>行记录（右边数据区）被 Page Directory 逻辑的分成了多个块，<strong>块与块之间是有序的</strong>，也就是说“4”这个槽指向的数据块内最大的行记录的主键都要比“8”这个槽指向的数据块内最小的行记录的主键要小。但是<strong>块内部的行记录不一定有序</strong>。每个行记录的都有一个 n_owned 的区域（图中粉红色区域），<strong><span style="color:#f33b45;">n_owned 标识这个块有多少条数据</span></strong>。伪记录 <strong>Infimum 的 n_owned 值总是 1</strong>，记录 <strong>Supremum 的 n_owned 的取值范围为[1,8]</strong>，其他用户记录 n_owned 的取值范围<strong>[4,8]</strong>。并且<span style="color:#f33b45;"><strong>只有每个块中最大的那条记录的 n_owned 才会有值</strong></span>，其他的用户记录的 n_owned 为 0。</p> 
<p>因此当我们要找主键为 6 的记录时，分为下面的步骤：</p> 
<p>1、先通过<span style="color:#f33b45;"><strong>二分法在稀疏索引（左边页目录）中找到对应的槽</strong></span>，也就是 Page Directory 中“8”这个槽。“8”这个槽指向的是该数据块中最大的记录，而数据是单向链表结构，所以无法逆向查找。</p> 
<p>2、由于8 槽无法找到数据，则只能找到上一个槽即“4”这个槽，然后通过“4”这个槽中<strong><span style="color:#f33b45;">最大的用户记录的指针沿着链表顺序查找到目标记录</span></strong>。</p> 
<h4>聚集索引和辅助索引（非聚集索引）</h4> 
<p>数据库中的B+Tree索引可以分为<span style="color:#f33b45;"><strong>聚集索引（clustered index）</strong></span>和<span style="color:#f33b45;"><strong>辅助索引（也称非聚集索引，secondary index）</strong></span>。</p> 
<p><strong>聚集索引：</strong>上面的InnoDB 引擎数据存储中的示例图在数据库中的实现即为聚集索引，<span style="color:#f33b45;"><strong>聚集索引的 B+Tree 中的叶子节点存放的是整张表的行记录数据</strong></span></p> 
<p><strong>辅助索引（非聚集索引）：<span style="color:#f33b45;">辅助索引的 B+Tree 中的叶子节点存放的是表的行数据的聚集索引键（key），即主键</span></strong>，和聚集索引不同的是它<strong>不存放行记录的全部数据</strong></p> 
<p>如果上面的用户表需要以“用户名字”建立一个辅助索引，是怎么实现的呢？辅助索引树如下图：</p> 
<p><img alt="" class="has" height="423" src="https://images2.imgbox.com/67/5a/KJdQAGTV_o.png" width="1025"><br> 从上图可以看出，非叶子节点中存放的全部是辅助索引（用户名字），而叶子节点存放的则是辅助索引（用户名字）+ 主键 key</p> 
<p>因此当我们<span style="color:#f33b45;"><strong>使用辅助索引查找数据时，先通过辅助索引在辅助索引树中找到辅助索引对应的主键 key（聚集索引键），然后在用主键 key 到聚集索引树上查找对应的数据</strong></span>，这个过程称为回表。</p> 
<h4>InnoDB 与 MyISAM 引擎对比</h4> 
<p>InnoDB 与 MyISAM 引擎在存储数据和查找数据方面有什么不同呢？下面通过一张图来简单了解一下二者区别，MyISAM 聚集索引的存储结构如下图：</p> 
<p>从上图可以看出，MyISAM 和 InnoDB 的不同主要体现在两个方面：</p> 
<p><span style="color:#f33b45;">1、MyISAM 的 B+Tree 叶子节点数据区存放的不是数据，而是数据记录对应的地址</span></p> 
<p><span style="color:#f33b45;">2、数据的存储不是按照主键顺序存放的，而是按照写入顺序存储的</span></p> 
<p><span style="color:#f33b45;"><strong>结论：InnoDB 引擎数据在物理上是按主键 key 顺序存放，而 MyISAM 引擎数据在物理上按插入的顺序存放</strong></span></p> 
<p>由于MyISAM 的叶子结点不存放具体数据，因此辅助索引的存储结构与聚集索引类似，在使用辅助索引查找数据的时候通过辅助索引树就能直接找到数据的地址了，不需要回表，这比 InnoDB 的查找效率高呢</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/cfddabb0d1e4e130aa51e22808bad40b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【LeetCode】详解旋转数组189. Rotate Array Given an array, rotate the array to the right by k steps, where k</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d5789a6e1697c684909e8fe6ab0b8930/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">将一个字符串插入另外一个字符串指定的位置</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>