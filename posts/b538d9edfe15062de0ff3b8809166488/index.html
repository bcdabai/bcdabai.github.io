<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>EJB开发手册 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="EJB开发手册" />
<meta property="og:description" content="第1章 EJB开发手册
1.1. 简介
1.1.1. Enterprise JavaBean简介
1.1.1.1. 作为组件模型的EJB
1.1.1.1.1. 特征
1.1.1.1.2. 使用EJB组件模型的优势
1.1.1.2. EJB组件模型
1.1.1.2.1. 客户端类型
1.1.1.2.2. EJB组件模型的组成部分
1.1.1.3. EJB的类型
1.1.2. Session Bean
1.1.2.1. 什么是Session Bean
1.1.2.2. Session Bean的生存时间
1.1.2.3. 会话状态
1.1.2.3.1. 无状态的Session Bean
1.1.2.3.2. 有状态的Session Bean
1.1.3. Entity Bean
1.1.3.1. 什么是Entity Bean
1.1.3.1.1. Session Bean与Entity Bean
1.1.3.1.2. 容器管理持久性（Container-managed Persistence，CMP）
1.1.3.1.3. 容器管理关系（Container-managed Relationship，CMR）
1.1.3.1.4. 容器管理关系的方向
1.1.3.2. Entity Bean的特征
1.1.3.2.1. 持久性
1.1.3.2.2. 持久业务数据的对象表示
1.1.3.2.3. 表示相同的底层数据的多个Entity Bean实例
1.1.3.2.4. 可查找的Entity Bean" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/b538d9edfe15062de0ff3b8809166488/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2010-11-10T15:01:42+08:00" />
<meta property="article:modified_time" content="2010-11-10T15:01:42+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">EJB开发手册</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>第1章 EJB开发手册<br>1.1. 简介<br>1.1.1. Enterprise JavaBean简介<br>1.1.1.1. 作为组件模型的EJB<br>1.1.1.1.1. 特征<br>1.1.1.1.2. 使用EJB组件模型的优势<br>1.1.1.2. EJB组件模型<br>1.1.1.2.1. 客户端类型<br>1.1.1.2.2. EJB组件模型的组成部分<br>1.1.1.3. EJB的类型<br>1.1.2. Session Bean<br>1.1.2.1. 什么是Session Bean<br>1.1.2.2. Session Bean的生存时间<br>1.1.2.3. 会话状态<br>1.1.2.3.1. 无状态的Session Bean<br>1.1.2.3.2. 有状态的Session Bean<br>1.1.3. Entity Bean<br>1.1.3.1. 什么是Entity Bean<br>1.1.3.1.1. Session Bean与Entity Bean<br>1.1.3.1.2. 容器管理持久性（Container-managed Persistence，CMP）<br>1.1.3.1.3. 容器管理关系（Container-managed Relationship，CMR）<br>1.1.3.1.4. 容器管理关系的方向<br>1.1.3.2. Entity Bean的特征<br>1.1.3.2.1. 持久性<br>1.1.3.2.2. 持久业务数据的对象表示<br>1.1.3.2.3. 表示相同的底层数据的多个Entity Bean实例<br>1.1.3.2.4. 可查找的Entity Bean<br>1.1.4. Message-driven Bean<br>1.1.4.1. Message-driven Bean 的产生原因<br>1.1.4.2. Message-driven Bean 作为一般的JMS 使用者(consumer)<br>1.1.4.3. Message-driven Bean 与其他Enterprise Bean<br>1.1.5. 使用接口定义客户访问<br>1.1.5.1. 远程访问<br>1.1.5.2. 本地访问<br>1.1.5.3. 本地接口与容器管理关系<br>1.1.5.4. 方法参数和返回值<br>1.1.5.5. 远程还是本地<br>1.1.5.6. 执行效率与组件接口类型<br>1.1.6. Enterprise Bean的内容<br>1.1.7. EJB组件模型的灵活性<br>1.1.8. 何时使用EJB组件<br>1.2. 会话Bean<br>1.2.1. 会话Bean<br>1.2.1.1. 容器与会话Bean<br>1.2.1.2. 会话Bean的会话状态<br>1.2.1.2.1. 有状态Session Bean实例的钝化与激活<br>1.2.1.2.2. 会话状态<br>1.2.1.2.3. 事务操作与状态域<br>1.2.2. 组件模型单元<br>1.2.2.1. Home接口<br>1.2.2.1.1. 远程Home接口<br>1.2.2.1.2. 本地Home接口<br>1.2.2.2. 业务（组件）接口<br>1.2.2.2.1. 远程接口<br>1.2.2.2.2. 本地接口<br>1.2.2.3. 组件类<br>1.2.2.3.1. 在组件类中使用注解<br>1.2.2.3.2. javax.ejb.SessionBean接口<br>1.2.2.3.3. SessionContext接口<br>1.2.2.3.4. 可选的SessionSynchronization接口<br>1.2.2.3.5. 串行化的会话Bean方法调用<br>1.2.2.3.6. 业务方法必须遵守的规则<br>1.2.2.3.7. 代码范例<br>1.2.3. 生存周期<br>1.2.3.1. 有状态Session Bean的生存周期<br>1.2.3.2. 无状态Session Bean的生存周期<br>1.3. Message-driven Bean<br>1.3.1. Message-driven Bean<br>1.3.1.1. Message-driven Bean与EJB容器、客户端、消息系统<br>1.3.2. 组件模型单元<br>1.3.2.1. 组件类<br>1.3.2.1.1. javax.ejb.MessageDrivenBean接口<br>1.3.2.1.2. javax.jms.MessageListener接口<br>1.3.2.1.3. javax.ejb.MessageDrivenContext接口<br>1.3.2.1.4. 串行化的调用<br>1.3.2.1.5. 消息处理的并发<br>1.3.2.1.6. Message-driven Bean方法的事务上下文<br>1.3.2.1.7. 消息接收确认（Message Acknowledgement）<br>1.3.2.1.8. 指定队列（Queue）或主题（Topic）<br>1.3.2.1.9. 异常处理<br>1.3.2.1.10. 遗漏的PreDestroy调用<br>1.3.2.2. 必须遵守的规则<br>1.3.2.2.1. 组件类<br>1.3.2.2.2. onMessage方法<br>1.3.2.2.3. ejbRemove方法<br>1.3.3. 生存周期<br>1.4. Entity Bean<br>1.4.1. 概览<br>1.4.1.1. 数据的对象视图<br>1.4.1.2. 组件结构<br>1.4.1.3. Primary Key<br>1.4.2. 客户端<br>1.4.2.1. JNDI<br>1.4.2.2. 远程客户<br>1.4.2.3. 本地客户<br>1.4.3. 容器与Entity Bean<br>1.4.3.1. 通过JNDI定位远程Home接口<br>1.4.3.2. 通过JNDI定位本地Home接口<br>1.4.4. 组件模型<br>1.4.4.1. Home接口<br>1.4.4.1.1. 远程Home接口<br>1.4.4.1.2. 本地Home接口<br>1.4.4.2. Primary Key<br>1.4.4.3. 组件接口<br>1.4.4.3.1. 远程接口<br>1.4.4.3.2. 本地接口<br>1.4.4.4. 组件类<br>1.4.5. 生存周期<br>1.5. Bean管理持久性的Entity Bean<br>1.5.1. 概述<br>1.5.2. Bean管理持久性的Entity Bean<br>1.5.2.1. 打开与释放资源<br>1.5.2.2. 实例的创建<br>1.5.2.3. 实例状态与持久存储<br>1.5.2.4. 实例的清除<br>1.5.3. 必须遵守的规则与范例<br>1.5.3.1. 组件类<br>1.5.3.1.1. ejbCreate方法<br>1.5.3.1.2. ejbPostCreate方法<br>1.5.3.1.3. ejbRemove方法<br>1.5.3.1.4. finder方法<br>1.5.3.1.5. 业务方法<br>1.5.3.1.6. Home方法<br>1.5.3.2. Home接口<br>1.5.3.3. 组件接口<br>1.5.4. 异常处理<br>1.5.4.1. 系统级异常<br>1.5.4.2. 应用级异常<br>1.5.4.3. 组件异常类型<br>1.6. 容器管理持久性的Entity Bean<br>1.6.1. 概述<br>1.6.2. 容器管理持久性的Entity Bean<br>1.6.2.1. CMP模型<br>1.6.2.2. 例子说明<br>1.6.2.3. 抽象持久性模式（Abstract persistence schema）<br>1.6.2.3.1. 容器管理持久性域（cmp-field）<br>1.6.2.3.2. 容器管理关系（cmr）与容器管理关系域（cmr-field）<br>1.6.2.3.3. 辅助值对象（dependent value object）<br>1.6.2.3.4. 自动建表与自动生成主键<br>1.6.2.3.5. 装载单元<br>1.6.2.3.6. 关系的赋值语义<br>1.6.2.4. Primary Key<br>1.6.2.5. 实例的清除<br>1.6.2.5.1. remove方法<br>1.6.2.5.2. 级联（cascade）移除<br>1.6.2.6. Finder方法<br>1.6.2.6.1. 单个对象的查找<br>1.6.2.6.2. 多个对象的查找<br>1.6.2.6.3. 容器自动生成查询<br>1.6.2.7. Select方法<br>1.6.2.7.1. 返回单个对象的select方法<br>1.6.2.7.2. 返回多个对象的select方法<br>1.6.2.8. 实例的生存周期与开发中的约定<br>1.6.2.8.1. 实例的生存周期<br>1.6.2.8.2. 开发中的约定<br>1.6.3. 必须遵守的规则<br>1.6.3.1. 类与接口<br>1.6.3.2. 组件类<br>1.6.3.3. 辅助类<br>1.6.3.4. ejbCreate方法<br>1.6.3.5. ejbPostCreate方法<br>1.7. EJB QL<br>1.7.1. 概述<br>1.7.2. 定义<br>1.7.2.1. 抽象持久类型与查询范围<br>1.7.2.2. 命名<br>1.7.2.3. 范例<br>1.7.2.4. 返回值类型<br>1.7.2.5. FROM子句与定位声明<br>1.7.2.5.1. 标识符（Identifier）<br>1.7.2.5.2. 标记变量(indentification variables)<br>1.7.2.5.3. 范围变量声明<br>1.7.2.5.4. 集合成员变量声明<br>1.7.2.5.5. 范例<br>1.7.2.5.6. 路径表达式<br>1.7.2.5.7. WHERE子句与条件表达式<br>1.7.2.6. SELECT子句<br>1.7.2.7. ORDER BY字句<br>1.7.2.8. NULL值<br>1.7.2.9. 相等语义<br>1.7.2.10. 查询语句的限制<br>1.7.3. 范例<br>1.7.3.1. 简单查询<br>1.7.3.2. 使用关系的查询<br>1.7.3.3. 使用输入参数的查询<br>1.7.3.4. 定义select方法的查询<br>1.7.3.5. EJB QL与SQL<br>1.7.4. EJB QL BNF<br>1.8. Java Persistence API<br>1.8.1. 概览<br>1.8.2. 实体<br>1.8.2.1. 什么是实体<br>1.8.2.2. 实体类的一些需求<br>1.8.2.3. 持久类的持久值域与持久属性<br>1.8.2.4. 持久值域<br>1.8.2.5. 持久属性<br>1.8.2.6. 实体的主键<br>1.8.2.7. 主键类<br>1.8.3. 实体的关系<br>1.8.3.1. 实体关系的多重性<br>1.8.3.2. 实体关系的方向<br>1.8.3.2.1. 双向关系<br>1.8.3.2.2. 单向关系<br>1.8.3.2.3. 查询与关系方向<br>1.8.3.2.4. 级联删除关系<br>1.8.3.3. 实体的继承关系<br>1.8.3.3.1. 抽象实体<br>1.8.3.3.2. 映射超类(Mapped superclass)<br>1.8.3.3.3. 非实体超类<br>1.8.3.4. 继承结构映射策略<br>1.8.3.4.1. 单表映射继承结构策略<br>1.8.3.4.2. 单表映射具体实体类策略<br>1.8.3.4.3. 子类连接策略<br>1.8.4. 管理实体<br>1.8.4.1. 实体管理器Entity Manager<br>1.8.4.1.1. 容器管理的实体管理器<br>1.8.4.1.2. 应用管理的实体管理器<br>1.8.4.1.3. 使用EntityManager查找实例<br>1.8.4.2. 管理实体实例的生存周期<br>1.8.4.2.1. 持久化实体实例<br>1.8.4.2.2. 清除实体实例<br>1.8.4.2.3. 同步实体数据到数据库<br>1.8.4.3. 创建查询<br>1.8.4.4. 查询中的命名参数<br>1.8.4.5. 查询中的顺序参数<br>1.8.5. 持久单元<br>1.8.5.1. persistence.xml文件<br>1.9. Java持久查询语言<br>1.9.1. 新特性<br>1.9.1.1. 批量更新与删除<br>1.9.1.2. 连接操作<br>1.9.1.2.1. 内连接（关系连接）<br>1.9.1.2.2. 左连接（LEFT JOIN）<br>1.9.1.2.3. 获取连接（FETCH JOIN）<br>1.9.1.3. GROUP BY和HAVING子句<br>1.9.1.4. 投影<br>1.9.1.5. SELECT子句中的构造表达式<br>1.9.1.6. 子查询<br>1.9.1.7. 查询中的命名参数<br>1.9.2. Java持久查询语言BNF<br>1.10. EJB的环境<br>1.10.1. 概述<br>1.10.2. 环境项（environment entry）<br>1.10.2.1. 访问环境项<br>1.10.2.2. 设置环境项<br>1.10.3. EJB引用<br>1.10.3.1. 访问EJB引用<br>1.10.3.2. 声明EJB引用<br>1.10.3.2.1. ejb-link<br>1.10.4. 资源管理器的连接创建器引用（resource manager connection factory reference）<br>1.10.4.1. 使用资源管理器的连接创建器引用<br>1.10.4.2. 声明连接创建器引用<br>1.10.4.3. 引用的映射<br>1.10.4.4. 访问引用<br>1.10.4.5. 标准的连接创建器类型<br>1.10.5. 资源环境引用（resource environment references）<br>1.10.5.1. 声明资源环境引用<br>1.10.5.2. 访问资源环境引用<br>1.10.6. javax.transaction.UserTransaction接口<br>1.11. EJB的事务<br>1.11.1. 概述<br>1.11.2. 客户端事务与未指明的事务上下文<br>1.11.3. EJB的事务划分<br>1.11.3.1. Bean管理事务（程序型的事务划分）<br>1.11.3.1.1. 使用Bean管理事务的限制<br>1.11.3.1.2. 事务上下文<br>1.11.3.2. 容器管理事务（声明型的事务划分）<br>1.11.3.2.1. setRollbackOnly与getRollbackOnly方法<br>1.11.3.2.2. 使用JMS API的考虑<br>1.11.3.2.3. 事务属性<br>1.11.3.2.4. 必须遵守的规则<br>1.11.4. 使用Bean管理事务与容器管理事务<br>1.12. EJB的安全管理<br>1.12.1. 安全模型<br>1.12.1.1. 安全角色（Security Role）与方法权限<br>1.12.1.2. 安全主体（Security Principal）<br>1.12.1.3. 安全角色与安全主体的映射<br>1.12.2. 使用安全模型<br>1.12.2.1. 声明安全角色<br>1.12.2.2. 定义方法许可<br>1.12.2.3. 定义角色映射<br>1.12.2.4. 调用中的身份传播<br>1.12.2.5. 关于安全角色引用<br>1.12.2.6. getCallerPrincipal<br>1.12.2.7. isCallerInRole<br>1.12.2.8. 声明代码中使用的安全角色引用<br>1.13. EJB Timer Service<br>1.13.1. 概述<br>1.13.2. 组件模型单元<br>1.13.2.1. 接口描述<br>1.13.2.1.1. TimerService接口<br>1.13.2.1.2. TimedObject接口<br>1.13.2.1.3. TimerHandle接口<br>1.13.2.1.4. Timer接口<br>1.13.2.2. 功能实现框架<br>1.13.3. 使用EJB Timer Service<br>1.13.3.1. 使用范围<br>1.13.3.2. 创建Timer<br>1.13.3.3. 定义Timer需要执行的内容<br>1.13.3.4. 取消和保存Timer<br>1.13.3.5. 获得Timer的信息<br>1.13.3.6. Timer和交易</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/966ba676deb89eefac056caa37603843/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">EJB2.0  ejb-jar.xml配置文件详解</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/71b28ab01c21490cd52ff6c8ef813356/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">php基础学习</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>