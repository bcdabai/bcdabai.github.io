<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43;八股文(一) - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C&#43;&#43;八股文(一)" />
<meta property="og:description" content="C&#43;&#43;八股文(一) 1.1 C&#43;&#43;语言的特点 C&#43;&#43;在C的基础上引入了面向对象机制，同时也兼容C语言；C&#43;&#43;三大特性：封装、继承、多态；C&#43;&#43;程序结构清晰、易于扩充、程序可读性好；C&#43;&#43;代码质量高，运行效率高、仅比汇编语言慢10%~20%；C&#43;&#43;更安全，增加const常量、引用、四类cast转换(static_cast、dynamic_cast、const_cast、reinterpret_cast)、智能指针、try-catch等等；C&#43;&#43;可复用性高，C&#43;&#43;引入了模板的概念，有专门的模板库(STL)；C&#43;&#43;是不断发展的语言，C&#43;&#43;11中新引入了nullptr、auto变量、Lambda匿名函数、右值引用、智能指针。 1.2 C&#43;&#43;和C语言的区别 C语言是C&#43;&#43;的子集，C&#43;&#43;可以很好兼容C语言。但是C&#43;&#43;又有很多新特性，如引用、智能指针、auto变量等；C&#43;&#43;是面对对象的编程语言；C语言是面对过程的编程语言；C语言有一些不安全的语言特性，如指针使用的潜在危险、强制转换的不确定性、内存泄露等。而C&#43;&#43;对此增加了不少新特性来改善安全性，如const常量、引用、cast转换、智能指针、try—catch等等；C&#43;&#43;可复用性高，C&#43;&#43;引入了模板的概念，后面在此基础上，实现了方便开发的标准模板库STL。C&#43;&#43;的STL库相对于C语言的函数库更灵活、更通用。 1.3 C&#43;&#43;中 struct 和 class 的区别 struct 一般用于描述一个数据结构集合，而 class 是对一个对象数据的封装；struct 中默认的访问控制权限是 public 的，而 class 中默认的访问控制权限是 private 的；在继承关系中，struct 默认是公有继承，而 class 是私有继承；class 关键字可以用于定义模板参数，就像 typename，而 struct 不能用于定义模板参数。 1.4 include头文件的顺序以及双引号&#34;&#34;和尖括号&lt;&gt;的区别 区别： 尖括号&lt;&gt;的头文件是系统文件，双引号&#34;&#34;的头文件是自定义文件；编译器预处理阶段查找头文件的路径不一样； 查找路径; 使用尖括号&lt;&gt;的头文件的查找路径：编译器设置的头文件路径–&gt;系统变量;使用双引号&#34;&#34;的头文件的查找路径：当前头文件目录–&gt;编译器设置的头文件路径–&gt;系统变量。 1.5 C&#43;&#43;结构体和C结构体的区别 C的结构体内不允许有函数存在，C&#43;&#43;允许有内部成员函数，且允许该函数是虚函数；C的结构体对内部成员变量的访问权限只能是public，而C&#43;&#43;允许public,protected,private三种；C 中使用结构体需要加上 struct 关键字，或者对结构体使用 typedef 取别名，而 C&#43;&#43; 中可以省略 struct 关键字直接使用；C语言的结构体是不可以继承的，C&#43;&#43;的结构体是可以从其他的结构体或者类继承过来的。 1.6 导入C函数的关键字是什么，C&#43;&#43;编译时和C有什么不同？ 关键字：在C&#43;&#43;中，导入C函数的关键字是extern，表达形式为extern “C”， extern &#34;C&#34;的主要作用就是为了能够正确实现C&#43;&#43;代码调用其他C语言代码。加上extern &#34;C&#34;后，会指示编译器这部分代码按C语言的进行编译，而不是C&#43;&#43;的。
编译区别：由于C&#43;&#43;支持函数重载，因此编译器编译函数的过程中会将函数的参数类型也加到编译后的代码中，而不仅仅是函数名；而C语言并不支持函数重载，因此编译C语言代码的函数时不会带上函数的参数类型，一般只包括函数名。
1.7 简述C&#43;&#43;从代码到可执行二进制文件的过程 预编译、编译、汇编、链接
预编译：这个过程主要的处理操作如下：
（1） 将所有的#define删除，并且展开所有的宏定义
（2） 处理所有的条件预编译指令，如#if、#ifdef
（3） 处理#include预编译指令，将被包含的文件插入到该预编译指令的位置。
（4） 过滤所有的注释" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/b255d79bc05ad197fc720e2257c39d95/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-07-11T18:38:34+08:00" />
<meta property="article:modified_time" content="2022-07-11T18:38:34+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43;八股文(一)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="C_0"></a>C++八股文(一)</h3> 
<h4><a id="11_C_2"></a>1.1 C++语言的特点</h4> 
<ol><li>C++在C的基础上引入了<strong>面向对象</strong>机制，同时也兼容C语言；</li><li>C++三大特性：封装、继承、多态；</li><li>C++程序结构清晰、易于扩充、程序可读性好；</li><li>C++代码质量高，<strong>运行效率高</strong>、仅比汇编语言慢10%~20%；</li><li>C++更安全，增加const常量、引用、四类cast转换(static_cast、dynamic_cast、const_cast、reinterpret_cast)、智能指针、try-catch等等；</li><li>C++可复用性高，C++引入了模板的概念，有专门的模板库(STL)；</li><li>C++是不断发展的语言，C++11中新引入了nullptr、auto变量、Lambda匿名函数、右值引用、智能指针。</li></ol> 
<h4><a id="12_CC_12"></a>1.2 C++和C语言的区别</h4> 
<ol><li>C语言是C++的子集，C++可以很好兼容C语言。但是C++又有很多<strong>新特性</strong>，如引用、智能指针、auto变量等；</li><li>C++是<strong>面对对象</strong>的编程语言；C语言是<strong>面对过程</strong>的编程语言；</li><li>C语言有一些不安全的语言特性，如指针使用的潜在危险、强制转换的不确定性、内存泄露等。而C++对此增加了不少新特性来<strong>改善安全性</strong>，如const常量、引用、cast转换、智能指针、try—catch等等；</li><li>C++<strong>可复用性</strong>高，C++引入了<strong>模板</strong>的概念，后面在此基础上，实现了方便开发的标准模板库STL。C++的STL库相对于C语言的函数库<strong>更灵活、更通用</strong>。</li></ol> 
<h4><a id="13_C_struct__class__19"></a>1.3 C++中 struct 和 class 的区别</h4> 
<ol><li>struct 一般用于描述一个数据结构集合，而 class 是对一个对象数据的封装；</li><li>struct 中默认的访问控制权限是 public 的，而 class 中默认的访问控制权限是 private 的；</li><li>在继承关系中，struct 默认是公有继承，而 class 是私有继承；</li><li>class 关键字可以用于定义模板参数，就像 typename，而 struct 不能用于定义模板参数。</li></ol> 
<h4><a id="14_include_26"></a>1.4 include头文件的顺序以及双引号""和尖括号&lt;&gt;的区别</h4> 
<ol><li>区别： 
  <ol><li>尖括号&lt;&gt;的头文件是<strong>系统文件</strong>，双引号""的头文件是<strong>自定义文件</strong>；</li><li>编译器预处理阶段查找头文件的路径不一样；</li></ol> </li><li>查找路径; 
  <ol><li>使用尖括号&lt;&gt;的头文件的查找路径：编译器设置的头文件路径–&gt;系统变量;</li><li>使用双引号""的头文件的查找路径：当前头文件目录–&gt;编译器设置的头文件路径–&gt;系统变量。</li></ol> </li></ol> 
<h4><a id="15_CC_35"></a>1.5 C++结构体和C结构体的区别</h4> 
<ol><li>C的结构体内不允许有函数存在，C++允许有内部成员函数，且允许该函数是虚函数；</li><li>C的结构体对内部成员变量的访问权限只能是public，而C++允许public,protected,private三种；</li><li>C 中使用结构体需要加上 struct 关键字，或者对结构体使用 typedef 取别名，而 C++ 中可以省略 struct 关键字直接使用；</li><li>C语言的结构体是不可以继承的，C++的结构体是可以从其他的结构体或者类继承过来的。</li></ol> 
<h4><a id="16_CCC_42"></a>1.6 导入C函数的关键字是什么，C++编译时和C有什么不同？</h4> 
<p><strong>关键字：<strong>在C++中，导入C函数的关键字是</strong>extern</strong>，表达形式为<strong>extern “C”</strong>， extern "C"的主要作用就是为了能够正确实现C++代码调用其他C语言代码。加上extern "C"后，会指示编译器这部分代码按<strong>C语言</strong>的进行编译，而不是C++的。</p> 
<p><strong>编译区别：<strong>由于C++支持函数重载，因此编译器编译函数的过程中会将函数的</strong>参数类型</strong>也加到编译后的代码中，而不仅仅是<strong>函数名</strong>；而C语言并不支持函数重载，因此编译C语言代码的函数时不会带上函数的参数类型，一般只包括<strong>函数名</strong>。</p> 
<h4><a id="17_C_48"></a>1.7 简述C++从代码到可执行二进制文件的过程</h4> 
<p><strong>预编译、编译、汇编、链接</strong></p> 
<ol><li> <p>预编译：这个过程主要的处理操作如下：</p> <p>（1） 将所有的#define删除，并且展开所有的宏定义</p> <p>（2） 处理所有的条件预编译指令，如#if、#ifdef</p> <p>（3） 处理#include预编译指令，将被包含的文件插入到该预编译指令的位置。</p> <p>（4） 过滤所有的注释</p> <p>（5） 添加行号和文件名标识</p> </li><li> <p>编译：这个过程主要的处理操作如下：</p> <p>（1） 词法分析：将源代码的字符序列分割成一系列的记号。</p> <p>（2） 语法分析：对记号进行语法分析，产生语法树。</p> <p>（3） 语义分析：判断表达式是否有意义。</p> <p>（4） 代码优化：</p> <p>（5） 目标代码生成：<strong>生成汇编代码</strong>。</p> <p>（6） 目标代码优化</p> </li><li> <p>汇编：这个过程主要是将汇编代码转变成机器可以执行的指令。</p> </li><li> <p>链接：将不同的源文件产生的目标文件进行链接，从而形成一个可以执行的程序。</p> <p>​ 链接分为静态链接和动态链接。</p> <p>​ (1) 静态链接，是在链接的时候就已经把要调用的函数或者过程链接到了生成的可执行文件中，就算你在去把静态库删除也不会影响可执行程序的执行；生成的静态链接库，Windows下以.lib为后缀，Linux下以.a为后缀。</p> <p>​ (2) 而动态链接，是在链接的时候没有把调用的函数代码链接进去，而是在执行的过程中，再去找要链接的函数，生成的可执行文件中没有函数代码，只包含<strong>函数的重定位信息</strong>，所以当你删除动态库时，可执行程序就不能运行。生成的动态链接库，Windows下以.dll为后缀，Linux下以.so为后缀。</p> </li></ol> 
<h4><a id="18_static_88"></a>1.8 static关键字的作用</h4> 
<ol><li><strong>定义全局静态变量和局部静态变量</strong>：在变量前面加上static关键字。static的变量默认初始化为0。（static变量）初始化的静态变量会在数据段分配内存，未初始化的静态变量会在BSS段分配内存。直到程序结束，静态变量始终会维持前值。只不过全局静态变量和局部静态变量的作用域不一样；</li><li><strong>定义静态函数</strong>：在函数返回类型前加上static关键字，函数即被定义为静态函数。静态函数只能在<strong>本源文件</strong>中使用；</li><li>在变量类型前加上static关键字，变量即被定义为静态变量。<strong>静态变量只能在本源文件中使用</strong>；</li><li>在c++中，<strong>static关键字可以用于定义类中的静态成员变量</strong>：使用静态数据成员，它既可以被当成全局变量那样去存储，但又被隐藏在类的内部。类中的static静态数据成员拥有一块单独的存储区，而不管创建了多少个该类的对象。所有这些对象的静态数据成员都<strong>共享</strong>这一块静态存储空间，static修饰的变量要在类外初始化。</li><li>在c++中，<strong>static关键字可以用于定义类中的静态成员函数</strong>：与静态成员变量类似，类里面同样可以定义静态成员函数。只需要在函数前加上关键字static即可。如静态成员函数也是类的一部分，而不是对象的一部分。所有这些对象的静态数据成员都<strong>共享</strong>这一块静态存储空间，只能访问类的static成员变量，static修饰的变量要在类外初始化。</li></ol> 
<h4><a id="19__96"></a>1.9 数组和指针的区别</h4> 
<p><strong>概念</strong>：</p> 
<p>(1）数组：数组是用于储存多个相同类型数据的集合。数组名是首元素的地址。</p> 
<p>(2）指针：指针相当于一个变量，但是它和不同变量不一样，它存放的是其它变量在<strong>内存中的地址</strong>。指针名指向了内存的首地址。</p> 
<p><strong>区别</strong>：</p> 
<ol><li><strong>赋值</strong>：同类型指针变量可以相互赋值；数组不行，只能一个一个元素的赋值或拷贝；</li><li><strong>存储方式</strong>： 
  <ol><li>数组：数组在内存中是连续存放的，开辟一块连续的内存空间。数组是根据数组的下进行访问的，数组的存储空间，不是在静态区就是在栈上。</li><li>指针：指针很灵活，它可以指向任意类型的数据。指针的类型说明了它所指向地址空间的内存。由于指针本身就是一个变量，再加上它所存放的也是变量，所以指针的存储空间不能确定。</li></ol> </li><li>…感觉这道题不是很好</li></ol> 
<h4><a id="110__112"></a>1.10 什么是函数指针，如何定义函数指针，有什么使用场景</h4> 
<p><strong>概念</strong>：函数指针就是<strong>指向函数</strong>的指针变量。每一个函数都有一个入口地址，该入口地址就是函数指针所指向的地址。</p> 
<p><strong>定义形式：</strong></p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>f<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span> 
f <span class="token operator">=</span> <span class="token operator">&amp;</span>func<span class="token punctuation">;</span>
</code></pre> 
<p><strong>使用场景：</strong> <strong>回调</strong>（callback）。我们调用别人提供的 API函数(Application Programming Interface,应用程序编程接口)，称为Call；如果别人的库里面调用我们的函数，就叫Callback。</p> 
<pre><code class="prism language-cpp"><span class="token comment">//以库函数qsort排序函数为例，它的原型如下：</span>
<span class="token keyword">void</span> <span class="token function">qsort</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>base<span class="token punctuation">,</span><span class="token comment">//void*类型，代表原始数组</span>
           size_t nmemb<span class="token punctuation">,</span> <span class="token comment">//第二个是size_t类型，代表数据数量</span>
           size_t size<span class="token punctuation">,</span> <span class="token comment">//第三个是size_t类型，代表单个数据占用空间大小</span>
           <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token operator">*</span>compar<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">,</span><span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token comment">//第四个参数是函数指针</span>
          <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//第四个参数告诉qsort，应该使用哪个函数来比较元素，即只要我们告诉qsort比较大小的规则，它就可以帮我们对任意数据类型的数组进行排序。在库函数qsort调用我们自定义的比较函数，这就是回调的应用。</span>

<span class="token comment">//示例</span>
<span class="token keyword">int</span> num<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">cmp_int</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">void</span><span class="token operator">*</span> _a <span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span><span class="token operator">*</span> _b<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span><span class="token comment">//参数格式固定</span>
    <span class="token keyword">int</span><span class="token operator">*</span> a <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span>_a<span class="token punctuation">;</span>    <span class="token comment">//强制类型转换</span>
    <span class="token keyword">int</span><span class="token operator">*</span> b <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span>_b<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token operator">*</span>a <span class="token operator">-</span> <span class="token operator">*</span>b<span class="token punctuation">;</span>　　
<span class="token punctuation">}</span>
<span class="token function">qsort</span><span class="token punctuation">(</span>num<span class="token punctuation">,</span><span class="token number">100</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>num<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>cmp_int<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//回调</span>
</code></pre> 
<h4><a id="111__145"></a>1.11 静态变量什么时候初始化</h4> 
<p>对于C语言的全局和静态变量，初始化发生在任何代码执行之前，属于编译期初始化。</p> 
<p>而C++标准规定：全局或静态对象当且仅当对象首次用到时才进行构造。</p> 
<h4><a id="112_nullptr_151"></a>1.12 nullptr调用成员函数可以吗？为什么？</h4> 
<p>可以。因为在<strong>编译时对象</strong>就绑定了<strong>函数地址</strong>，和指针空不空没关系。</p> 
<pre><code class="prism language-cpp"><span class="token comment">//给出实例</span>
<span class="token keyword">class</span> <span class="token class-name">animal</span><span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">void</span> <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"animal sleep"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token keyword">void</span> <span class="token function">breathe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"animal breathe haha"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">fish</span> <span class="token operator">:</span><span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">animal</span></span><span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">void</span> <span class="token function">breathe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"fish bubble"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    animal <span class="token operator">*</span>pAn<span class="token operator">=</span><span class="token keyword">nullptr</span><span class="token punctuation">;</span>
    pAn<span class="token operator">-&gt;</span><span class="token function">breathe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 输出：animal breathe haha</span>
    fish <span class="token operator">*</span>pFish <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
    pFish<span class="token operator">-&gt;</span><span class="token function">breathe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出：fish bubble</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>  
<span class="token comment">// 原因：因为在编译时对象就绑定了函数地址，和指针空不空没关系。pAn-&gt;breathe();编译的时候，函数的地址就和指针pAn绑定了；调用breath(*this), this就等于pAn。由于函数中没有需要解引用this的地方，所以函数运行不会出错，但是若用到this，因为this=nullptr，运行出错。</span>
</code></pre> 
<h4><a id="113__176"></a>1.13 什么是野指针，怎么产生的，如何避免？</h4> 
<ol><li> <p>**概念：**野指针就是指针指向的位置是不可知的（随机的、不正确的、没有明确限制的）;</p> </li><li> <p><strong>产生原因</strong>：释放内存后指针不及时置空（野指针），依然指向了该内存，那么可能出现非法访问的错误。这些我们都要注意避免。</p> </li><li> <p><strong>避免办法：</strong></p> <p>（1）初始化置NULL</p> <p>（2）申请内存后判空</p> <p>（3）指针释放后置NULL</p> <p>（4）使用智能指针</p> </li></ol> 
<h4><a id="114__192"></a>1.14 静态局部变量，全局变量，局部变量的特点，以及使用场景</h4> 
<ol><li> <p><strong>首先从作用域考虑</strong>：C++里作用域可分为6种：全局，局部，类，语句，命名空间和文件作用域。</p> <p>全局变量：全局作用域，可以通过extern作用于其他非定义的源文件。</p> <p>静态全局变量 ：全局作用域+文件作用域，所以无法在其他文件中使用。</p> <p>局部变量：局部作用域，比如函数的参数，函数内的局部变量等等。</p> <p>静态局部变量 ：局部作用域，只被初始化一次，直到程序结束。</p> </li><li> <p><strong>从所在空间考虑</strong>：除了局部变量在栈上外，其他都在静态存储区。因为静态变量都在静态存储区，所以下次调用函数的时候还是能取到原来的值。</p> </li><li> <p><strong>生命周期</strong>： 局部变量在栈上，出了作用域就回收内存；而全局变量、静态全局变量、静态局部变量都在静态存储区，直到程序结束才会回收内存。</p> </li><li> <p><strong>使用场景</strong>：从它们各自特点就可以看出各自的应用场景，不再赘述。</p> </li></ol> 
<h4><a id="115_httpsblogcsdnnetm0_56077202articledetails125571831spm1001201430015501_210"></a>1.15 <a href="https://blog.csdn.net/m0_56077202/article/details/125571831?spm=1001.2014.3001.5501">内联函数和宏函数的区别</a></h4> 
<h4><a id="116_newmalloc_212"></a>1.16 new和malloc的区别，各自底层实现原理</h4> 
<ol><li>new是操作符，而malloc是函数。</li><li>new在调用的时候先分配内存，在调用构造函数，释放的时候调用析构函数；而malloc没有构造函数和析构函数。</li><li>malloc需要给定申请内存的大小，返回的指针需要强转；new会调用构造函数，不用指定内存的大小，返回指针不用强转。</li><li>new可以被重载；malloc不行</li><li>new分配内存更直接和安全。</li><li>new发生错误抛出异常，malloc返回null</li></ol> 
<h4><a id="117_constdefinehttpsblogcsdnnetm0_56077202articledetails125571831spm1001201430015501_221"></a>1.17 <a href="https://blog.csdn.net/m0_56077202/article/details/125571831?spm=1001.2014.3001.5501">const和define的区别</a></h4> 
<h4><a id="118_C_223"></a>1.18 C++中函数指针和指针函数的区别</h4> 
<ol><li> <p><strong>定义不同</strong><br> 指针函数本质是一个函数，其返回值为指针。<br> 函数指针本质是一个指针，其指向一个函数。</p> </li><li> <p><strong>写法不同</strong></p> <pre><code class="prism language-cpp">指针函数：<span class="token keyword">int</span> <span class="token operator">*</span><span class="token function">fun</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span><span class="token keyword">int</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>
函数指针：<span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>fun<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span><span class="token keyword">int</span> y<span class="token punctuation">)</span>
</code></pre> </li><li> <p><strong>用法不同</strong></p> <pre><code class="prism language-cpp"><span class="token comment">//指针函数示例</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">_Data</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> a<span class="token punctuation">;</span>
    <span class="token keyword">int</span> b<span class="token punctuation">;</span>
<span class="token punctuation">}</span>Data<span class="token punctuation">;</span>
<span class="token comment">//指针函数</span>
Data<span class="token operator">*</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span><span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    Data <span class="token operator">*</span> data <span class="token operator">=</span> <span class="token keyword">new</span> Data<span class="token punctuation">;</span>
    <span class="token comment">//...</span>
    <span class="token keyword">return</span> data<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token comment">//调用指针函数</span>
    Data <span class="token operator">*</span> myData <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//Data * myData = static_cast&lt;Data*&gt;(f(4,5));</span>
   <span class="token comment">//...</span>
<span class="token punctuation">}</span>

<span class="token comment">//函数指针示例</span>
<span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span><span class="token keyword">int</span> y<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> x<span class="token operator">+</span>y<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//函数指针</span>
<span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>fun<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span><span class="token keyword">int</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//赋值</span>
fun <span class="token operator">=</span> add<span class="token punctuation">;</span>
<span class="token comment">//调用</span>
cout <span class="token operator">&lt;&lt;</span> <span class="token string">"(*fun)(1,2) = "</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span><span class="token operator">*</span>fun<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>
<span class="token comment">//输出结果</span>
<span class="token comment">//(*fun)(1,2) =  3</span>
</code></pre> </li></ol> 
<h4><a id="119__271"></a>1.19 常量指针和指针常量</h4> 
<pre><code class="prism language-cpp"><span class="token number">1.</span> <span class="token keyword">const</span> <span class="token keyword">int</span> a<span class="token punctuation">;</span>     <span class="token comment">//指的是a是一个常量，不允许修改。</span>
<span class="token number">2.</span> <span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span>a<span class="token punctuation">;</span>    <span class="token comment">//a指针所指向的内存里的值不变，即（*a）不变</span>
<span class="token number">3.</span> <span class="token keyword">int</span> <span class="token keyword">const</span> <span class="token operator">*</span>a<span class="token punctuation">;</span>    <span class="token comment">//同const int *a;</span>
<span class="token number">4.</span> <span class="token keyword">int</span> <span class="token operator">*</span><span class="token keyword">const</span> a<span class="token punctuation">;</span>    <span class="token comment">//a指针所指向的内存地址不变，即a不变</span>
<span class="token number">5.</span> <span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span><span class="token keyword">const</span> a<span class="token punctuation">;</span>   <span class="token comment">//都不变，即（*a）不变，a也不变</span>
</code></pre> 
<h4><a id="120__281"></a>1.20 使用指针需要注意什么？</h4> 
<ol><li>定义指针时，先初始化为NULL。</li><li>用malloc或new申请内存之后，应该<strong>立即检查</strong>指针值是否为NULL。防止使用指针值为NULL的内存。</li><li>不要忘记为数组和动态内存<strong>赋初值</strong>。防止将未被初始化的内存作为右值使用。</li><li>避免数字或指针的下标<strong>越界</strong>，特别要当心发生“多1”或者“少1”操作</li><li>动态内存的申请与释放必须配对，防止<strong>内存泄漏</strong></li><li>用free或delete释放了内存之后，立即将指针<strong>设置为NULL</strong>，防止“野指针”</li></ol> 
<h5><a id="121__290"></a>1.21 内联函数和函数的区别</h5> 
<ol><li>内联函数比普通函数多了关键字<strong>inline</strong>；</li><li>内联函数避免了函数调用的<strong>开销</strong>；普通函数有调用的开销；</li><li>普通函数在被调用的时候，需要<strong>寻址（函数入口地址）</strong>；内联函数不需要寻址。</li><li>内联函数有一定的限制，内联函数体要求<strong>代码简单</strong>，不能包含复杂的结构控制语句(内联函数内不允许用循环语句和开关语句。)；普通函数没有这个要求。</li></ol> 
<h4><a id="122_C_297"></a>1.22 简述C++有几种传值方式，之间的区别是什么？</h4> 
<p><strong>值传递、引用传递、指针传递</strong></p> 
<ol><li>值传递：形参即使在函数体内值发生变化，也不会影响实参的值；</li><li>引用传递：形参在函数体内值发生变化，会影响实参的值；</li><li>指针传递：在指针指向没有发生改变的前提下，形参在函数体内值发生变化，会影响实参的值；</li></ol> 
<h4><a id="123_casthttpsblog51ctocomu_122044153804319_305"></a>1.23 <a href="https://blog.51cto.com/u_12204415/3804319" rel="nofollow">四种cast类型转换</a></h4> 
<p>​ 作用：克服c中强制类型转化带来的风险，C++引入四种更加安全的强制类型转换运算符（明确转换的目 的，偏于程序的维护和分析）</p> 
<ol><li>const_cast：</li></ol> 
<pre><code class="prism language-cpp"><span class="token comment">// 1.去除const属性，将只读变为只读写</span>
<span class="token comment">// 2.针对常量指针、常量引用和常量对象</span>
<span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>
<span class="token keyword">char</span> <span class="token operator">*</span>p1 <span class="token operator">=</span> <span class="token generic-function"><span class="token function">const_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>​ 2. static_cast</p> 
<pre><code class="prism language-cpp"><span class="token comment">// 1.内置数据类型之间的转换，int转double，char转int</span>
<span class="token comment">// 2.基类指针与派生类之间的转换，只能转换有继承或派生关系的类。用于类层次结构之间基类和派生类指针和引用之间的转换，进行向上转型是安全的，但是进行向下转型是不安全的，但是是可以转换的;向上转型：我们知道基类的引用和指针都可以指向派生类的对象，那么将派生类的指针或者引用强转为基类的指针或者引用，那么这就是向上转型，也就是向父类转;向下转型：向下转型就和向上转型相反，它是将父类的指针或者引用，强制转换为子类的指针或者引用</span>
<span class="token comment">// 3.把void类型指针转换为目标类型的指针</span>
<span class="token comment">// 4.任何类型的表达式转化为void类型</span>

<span class="token comment">// 整形转浮点型</span>
<span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token keyword">double</span> b <span class="token operator">=</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">&gt;</span>a<span class="token punctuation">;</span>
 
<span class="token comment">//基类指针转派生类</span>
<span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">A</span></span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">;</span>
 
A <span class="token operator">*</span>pA <span class="token operator">=</span> <span class="token keyword">new</span> A<span class="token punctuation">;</span>
 
B <span class="token operator">*</span>pB <span class="token operator">=</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>B<span class="token operator">*</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>pA<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<ol start="3"><li> <p>reinterpret_cast</p> 
  <ul><li> <p>可以将一个类型的指针转换为其它任意类型的指针，也可以用在指针和整形数据之间的转换它是很<strong>危险</strong>的，如果我们没有使用它的充分理由，那么就不要使用它</p> </li><li> <p>为运算对象的位模式提供较低层次上的重新解释</p> </li><li> <p>用于底层的强制转换，依赖于机器，一般使用较少</p> </li></ul> </li><li> <p>dynamic_cast</p> 
  <ul><li>dynamic_cast是<strong>运行时处理</strong>的，运行时进行类型检查，其他三种是编译时处理的</li><li>不能用于内置数据类型之间的转换</li><li>dynamic_cast在进行上行转换时和static_cast效果是一样的，但是进行下行转换时会进行类型检查，比static_cast更加安全，下行转换是否成功取决于转换对象的实际类型与目标类型是否相同</li><li>要求基类必须具有虚函数，否则编译不通过</li><li>若转换成功，返回的是指向目标的指针或引用，不成功返回NULL</li></ul> </li></ol> 
<h4><a id="124_Chttpsblogcsdnnetas14569852articledetails76386998_353"></a>1.24 <a href="https://blog.csdn.net/as14569852/article/details/76386998">C++继承</a></h4> 
<ol><li>公有继承public：基类的公有成员和保护成员作为派生类的成员时，它们都保持原有的状态，而基类的私有成员仍然是私有的，不能被这个派生类的子类所访问。</li><li>私有继承private：私有继承的特点是基类的公有成员和保护成员都作为派生类的私有成员，并且不能被这个派生类的子类所访问。</li><li>保护继承protect：保护继承的特点是基类的所有公有成员和保护成员都成为派生类的保护成员，并且只能被它的派生类成员函数或友元访问，基类的私有成员仍然是私有的。</li></ol>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/bf113089f32f48095f914089f2612e96/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Java简单案例练习</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/df4e35004aa150c30e5aadcb87061074/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">基于Java——SpringBoot的洗浴会所管理系统</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>