<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>泛型知识点 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="泛型知识点" />
<meta property="og:description" content="目录
1. 泛型
2. 限定通配符与非限定通配符
1. 泛型 泛型就是将类型参数化，其在编译的时候才确定具体的参数。
可以在类、接口、方法中创建，分别称为反省类、泛型接口、泛型方法。
在jdk1.5之前（泛型是Jdk1.5 之后才有的），没有泛型的概念，要使用Object来实现通用、不同类型的处理：缺点：（1）每次使用时都要强制转换为想要的类型。（2）在编译时编译器不知道类型的转换是否异常，运行时才知道，不安全。
泛型是一种语法糖，基本原理就是类型擦除（使用泛型时候加上的类型参数，编译器在编译的时候去掉类型参数）。泛型只存在于编译阶段，不存在与运行阶段。
public class A&lt;T&gt; { private T num; } 大部分情况下，泛型类型都会以Object 进行替换，但当使用了extends 和 super 语法时，就不能简单用Object来替换了。
public class A &lt;T extends String&gt; { private T num; } 这种情况下，num的类型会被替换为String，而不是Object。这是类型限定的一个语法，它限定T是String的子类或者就是 String ，无论T是什么类型，String都是父类，不会出现类型不匹配的问题，于是可以使用String进行类型擦除。
使用泛型的好处：
1. 类型安全
（1）泛型的主要目标就是提高Java程序的类型安全。
（2）编译时期就可以检查出因Java类型不正确导致的类型转换异常。
（3）符合越早出错代价越小原则。
2. 消除强制类型转换
（1）使用时直接得到目标类型，消除许多强制类型转换。
（2）所得即所需，减少出错机会。
3. 潜在的性能收益 （1）所有工作都在编译器完成。
（2）编译器生成的代码与不适用泛型时所写的代码几乎一致。
2. 限定通配符与非限定通配符 限定通配符： &lt;? extends T&gt; 确保类型必须是T的子类或者就是T，设定了类型的上界。
&lt;? super T &gt; 确保类型必须是T的父类或者就是T，设定了类型的下界。
非限定通配符： 非限定通配符&lt;？&gt; ，可以用任意类型来代替。如 List&lt;?&gt;，他可以是List&lt;A&gt;，List&lt;B&gt;，List&lt;C&gt;等等。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/72615ef893eea8c334955a4e814ccd66/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-08-30T18:35:39+08:00" />
<meta property="article:modified_time" content="2022-08-30T18:35:39+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">泛型知识点</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%C2%A01.%20%E6%B3%9B%E5%9E%8B-toc" style="margin-left:0px;"><a href="#%C2%A01.%20%E6%B3%9B%E5%9E%8B" rel="nofollow"> 1. 泛型</a></p> 
<p id="%C2%A02.%20%E9%99%90%E5%AE%9A%E9%80%9A%E9%85%8D%E7%AC%A6%E4%B8%8E%E9%9D%9E%E9%99%90%E5%AE%9A%E9%80%9A%E9%85%8D%E7%AC%A6-toc" style="margin-left:0px;"><a href="#%C2%A02.%20%E9%99%90%E5%AE%9A%E9%80%9A%E9%85%8D%E7%AC%A6%E4%B8%8E%E9%9D%9E%E9%99%90%E5%AE%9A%E9%80%9A%E9%85%8D%E7%AC%A6" rel="nofollow"> 2. 限定通配符与非限定通配符</a></p> 
<p></p> 
<h2 id="%C2%A01.%20%E6%B3%9B%E5%9E%8B"> 1. 泛型</h2> 
<blockquote> 
 <p><strong>泛型就是将类型参数化，其在编译的时候才确定具体的参数。</strong></p> 
</blockquote> 
<p>可以在类、接口、方法中创建，分别称为反省类、泛型接口、泛型方法。</p> 
<blockquote> 
 <p>在jdk1.5之前（泛型是Jdk1.5 之后才有的），没有泛型的概念，要使用Object来实现通用、不同类型的处理：<strong>缺点：（1）<span style="color:#fe2c24;">每次使用时都要强制转换为想要的类型。</span>（2）<span style="color:#fe2c24;">在编译时编译器不知道类型的转换是否异常，运行时才知道，不安全。</span></strong></p> 
</blockquote> 
<blockquote> 
 <p>泛型是一种语法糖，基本原理就是<span style="color:#fe2c24;"><strong>类型擦除（</strong></span><span style="color:#0d0016;"><strong>使用泛型时候加上的类型参数，编译器在编译的时候去掉类型参数）</strong></span><span style="color:#fe2c24;"><strong>。泛型只存在于编译阶段，不存在与运行阶段。</strong></span></p> 
</blockquote> 
<pre><code class="language-java">public class A&lt;T&gt; {
    private T num;
}</code></pre> 
<blockquote> 
 <p> 大部分情况下，泛型类型都会以Object 进行替换，但当使用了extends 和 super 语法时，就不能简单用Object来替换了。</p> 
</blockquote> 
<pre><code class="language-java">public class A &lt;T extends String&gt; {
    private T num;
}</code></pre> 
<blockquote> 
 <p>这种情况下，num的类型会被替换为String，而不是Object。这是<span style="color:#fe2c24;"><strong>类型限定</strong></span>的一个语法，它限定<strong>T是String的子类或者就是 String</strong> ，无论T是什么类型，String都是父类，不会出现类型不匹配的问题，于是可以使用String进行类型擦除。</p> 
</blockquote> 
<blockquote> 
 <p>使用泛型的好处：</p> 
 <p><span style="color:#fe2c24;"><strong>1. 类型安全</strong></span></p> 
 <p><strong>（1）泛型的主要目标就是提高Java程序的类型安全。</strong></p> 
 <p><strong>（2）编译时期就可以检查出因Java类型不正确导致的类型转换异常。</strong></p> 
 <p><strong>（3）符合越早出错代价越小原则。</strong></p> 
 <p><span style="color:#fe2c24;"><strong>2. 消除强制类型转换</strong></span></p> 
 <p><strong>（1）使用时直接得到目标类型，消除许多强制类型转换。</strong></p> 
 <p><strong>（2）所得即所需，减少出错机会。</strong></p> 
 <p><span style="color:#fe2c24;"><strong>3. 潜在的性能收益 </strong></span></p> 
 <p><strong>（1）所有工作都在编译器完成。</strong></p> 
 <p><strong>（2）编译器生成的代码与不适用泛型时所写的代码几乎一致。</strong></p> 
</blockquote> 
<h2 id="%C2%A02.%20%E9%99%90%E5%AE%9A%E9%80%9A%E9%85%8D%E7%AC%A6%E4%B8%8E%E9%9D%9E%E9%99%90%E5%AE%9A%E9%80%9A%E9%85%8D%E7%AC%A6"> 2. 限定通配符与非限定通配符</h2> 
<p><span style="color:#0d0016;"><strong>限定通配符：</strong> </span></p> 
<blockquote> 
 <p><span style="color:#fe2c24;"><strong>&lt;? extends T&gt;  </strong></span><span style="color:#0d0016;"><strong>确保类型必须是T的子类或者就是T，设定了类型的上界。</strong></span></p> 
 <p><span style="color:#fe2c24;"><strong>&lt;? super T &gt;  确保类型必须是T的父类或者就是T，设定了类型的下界。</strong></span></p> 
</blockquote> 
<p> 非<span style="color:#0d0016;"><strong>限定通配符：</strong> </span></p> 
<blockquote> 
 <p> 非<span style="color:#0d0016;"><strong>限定通配符&lt;？&gt; ，可以用任意类型来代替。如 List&lt;?&gt;，他可以是List&lt;A&gt;，List&lt;B&gt;，List&lt;C&gt;等等。</strong></span></p> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/474201cd8f3fe69015e00c755da8911a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">朴素贝叶斯算法原理以及python实现</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/67e5eb36bb510df75f3f0a93ac868555/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">嵌入式linux开发实用工具小程序</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>