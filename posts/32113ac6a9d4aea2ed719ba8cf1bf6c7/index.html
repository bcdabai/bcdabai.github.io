<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>zoj 3543 E - Number String - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="zoj 3543 E - Number String" />
<meta property="og:description" content="链接：https://cn.vjudge.net/contest/264706#problem/E
思路：很容易就可以想到dp来做，一开始想到的是用dp[ i ][ j ] 表示长度为i 末尾元素为j 的序列，但是其实可以发现这样表示根本就没有办法向下推。然后就gg 了，其实这个题 dp[ i ][ j ] 表示的是长度为 i 末尾元素为 j 的（1到 i ）的符合条件的全排列方式，这样就可以完全保证 没有用到重复的元素。 这样递推的话，如果是I 那么我就找比前一位比j 小的所有方案加和。如果是D 那么我就找前一位&gt;=j&amp;&amp;&lt;=i-1的方案加和。
推荐一篇博客： https://blog.csdn.net/a497406594/article/details/38317993
代码：
#include&lt;bits/stdc&#43;&#43;.h&gt; using namespace std; typedef long long ll; const ll mod= 1e9&#43;7; char str[1010]; ll dp[1005][1005]; int main(){ while(~scanf(&#34;%s&#34;,str&#43;2)){ int len=strlen(str&#43;2)&#43;1; for(int i=0;i&lt;=len&#43;2;i&#43;&#43;) { for(int j=0;j&lt;=len&#43;2;j&#43;&#43;) { dp[i][j]=0; } } dp[1][1]=1; for(int i=2;i&lt;=len;i&#43;&#43;){ if(str[i]==&#39;I&#39;||str[i]==&#39;?&#39;) { ll ss=0; for(int j=1;j&lt;=i;j&#43;&#43;) { dp[i][j]=(dp[i][j]&#43;ss)%mod; ss=(ss&#43;dp[i-1][j])%mod; } } if(str[i]==&#39;D&#39;||str[i]==&#39;?" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/32113ac6a9d4aea2ed719ba8cf1bf6c7/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-11-01T12:33:05+08:00" />
<meta property="article:modified_time" content="2018-11-01T12:33:05+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">zoj 3543 E - Number String</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>链接：<a href="https://cn.vjudge.net/contest/264706#problem/E" rel="nofollow">https://cn.vjudge.net/contest/264706#problem/E</a></p> 
<p>思路：很容易就可以想到dp来做，一开始想到的是用dp[ i ][ j ] 表示长度为i 末尾元素为j 的序列，但是其实可以发现这样表示根本就没有办法向下推。然后就gg 了，<span style="color:#f33b45;">其实这个题 dp[ i ][ j ] 表示的是长度为 i 末尾元素为 j 的（1到 i ）的符合条件的全排列方式，这样就可以完全保证 没有用到重复的元素。</span> <span style="color:#86ca5e;">这样递推的话，如果是I 那么我就找比前一位比j 小的所有方案加和。如果是D 那么我就找前一位&gt;=j&amp;&amp;&lt;=i-1的方案加和。</span></p> 
<p>推荐一篇博客： <a href="https://blog.csdn.net/a497406594/article/details/38317993">https://blog.csdn.net/a497406594/article/details/38317993</a></p> 
<p>代码：</p> 
<pre class="has"><code>#include&lt;bits/stdc++.h&gt;

using namespace std;
typedef long long ll;
const ll mod= 1e9+7;

char str[1010];
ll dp[1005][1005];

int main(){
	while(~scanf("%s",str+2)){
		int len=strlen(str+2)+1;

		for(int i=0;i&lt;=len+2;i++)
        {
            for(int j=0;j&lt;=len+2;j++)
            {
                dp[i][j]=0;
            }
        }
		dp[1][1]=1;

		for(int i=2;i&lt;=len;i++){
			if(str[i]=='I'||str[i]=='?')
            {
                ll ss=0;
                for(int j=1;j&lt;=i;j++)
                {
                    dp[i][j]=(dp[i][j]+ss)%mod;
                    ss=(ss+dp[i-1][j])%mod;
                }
            }
            if(str[i]=='D'||str[i]=='?')
            {
                ll ss=dp[i-1][i-1];
                for(int j=i-1;j&gt;=1;j--)
                {
                    dp[i][j]=(dp[i][j]+ss)%mod;
                    ss=(ss+dp[i-1][j-1])%mod;
                }
            }
		}
		ll ans=0;
		for(int i=1;i&lt;=len;i++)
        {
            ans=(ans+dp[len][i])%mod;
        }

        printf("%lld\n",ans);
	}

	return 0;
}

</code></pre> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/31f408210897ed25db8745fcd502e7bd/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">小白学Linux——实践2（开机启动）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/091dd7f4d38770c2dc549e5ad54d27e7/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Python--遍历列表时删除元素的正确做法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>