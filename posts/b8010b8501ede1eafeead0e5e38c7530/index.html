<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据库中Select For update语句的解析 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="数据库中Select For update语句的解析" />
<meta property="og:description" content="——————————— Oracle —————————————————– Oracle 的for update行锁
键字: oracle 的for update行锁 SELECT…FOR UPDATE 语句的语法如下： SELECT … FOR UPDATE [OF column_list][WAIT n|NOWAIT][SKIP LOCKED]; 其中： OF 子句用于指定即将更新的列，即锁定行上的特定列。 WAIT 子句指定等待其他用户释放锁的秒数，防止无限期的等待。 “使用FOR UPDATE WAIT”子句的优点如下： １防止无限期地等待被锁定的行； ２允许应用程序中对锁的等待时间进行更多的控制。 ３对于交互式应用程序非常有用，因为这些用户不能等待不确定 ４ 若使用了skip locked，则可以越过锁定的行，不会报告由wait n 引发的‘资源忙’异常报告
示例1: create table t(a varchar2(20),b varchar2(20)); insert into t values(‘1’,’1’); insert into t values(‘2’,’2’); insert into t values(‘3’,’3’); insert into t values(‘4’,’4’); 现在执行如下操作： 在plsql develope中打开两个sql窗口， 在1窗口中运行sql select * from t where a=’1’ for update; 在2窗口中运行sql1 1." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/b8010b8501ede1eafeead0e5e38c7530/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2017-10-25T00:13:17+08:00" />
<meta property="article:modified_time" content="2017-10-25T00:13:17+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据库中Select For update语句的解析</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>——————————— <strong>Oracle</strong> —————————————————– <br> <strong>Oracle 的for update行锁</strong></p> 
<p>键字: oracle 的for update行锁 <br> 　　SELECT…FOR UPDATE 语句的语法如下： <br> 　　SELECT … FOR UPDATE [OF column_list][WAIT n|NOWAIT][SKIP LOCKED]; <br> 其中： <br> 　　OF 子句用于指定即将更新的列，即锁定行上的特定列。 <br> 　　WAIT 子句指定等待其他用户释放锁的秒数，防止无限期的等待。 <br> 　　“使用FOR UPDATE WAIT”子句的优点如下： <br> 　　１防止无限期地等待被锁定的行； <br> 　　２允许应用程序中对锁的等待时间进行更多的控制。 <br> 　　３对于交互式应用程序非常有用，因为这些用户不能等待不确定 <br> 　　４ 若使用了skip locked，则可以越过锁定的行，不会报告由wait n 引发的‘资源忙’异常报告</p> 
<p><strong>示例1:</strong> <br> create table t(a varchar2(20),b varchar2(20)); <br> insert into t values(‘1’,’1’); <br> insert into t values(‘2’,’2’); <br> insert into t values(‘3’,’3’); <br> insert into t values(‘4’,’4’); <br> 现在执行如下操作： <br> 在plsql develope中打开两个sql窗口， <br> 在1窗口中运行sql <br> select * from t where a=’1’ for update; <br> 在2窗口中运行sql1 <br> 1. select * from t where a=’1’; 这一点问题也没有，因为行级锁不会影响纯粹的select语句 <br> 再运行sql2 <br> 2. select * from t where a=’1’ for update; 则这一句sql在执行时，永远处于等待状态，除非窗口1中sql被提交或回滚。 <br> 如何才能让sql2不等待或等待指定的时间呢？ 我们再运行sql3 <br> 3. select * from t where a=’1’ for update nowait; 则在执行此sql时，直接报资源忙的异常。 <br> 若执行 select * from t where a=’1’ for update wait 6; 则在等待6秒后，报 资源忙的异常。 <br> 如果我们执行sql4 <br> 4. select * from t where a=’1’ for update nowait skip Locked; 则执行sql时，即不等待，也不报资源忙异常。 <br> 现在我们看看执行如下操作将会发生什么呢？ <br> 在窗口1中执行： <br> select * from t where rownum&lt;=3 nowait skip Locked; <br> 在窗口2中执行： <br> select * from t where rownum&lt;=6 nowait skip Locked; <br> select for update 也就如此了吧，insert、update、delete操作默认加行级锁，其原理和操作与select for update并无两样。 <br> select for update of，这个of子句在牵连到多个表时，具有较大作用，如不使用of指定锁定的表的列，则所有表的相关行均被锁定，若在of中指定了需修改的列，则只有与这些列相关的表的行才会被锁定。</p> 
<p><strong>实例2</strong> <br> elect * from t for update 会等待行锁释放之后，返回查询结果。 <br> select * from t for update nowait 不等待行锁释放，提示锁冲突，不返回结果 <br> select * from t for update wait 5 等待5秒，若行锁仍未释放，则提示锁冲突，不返回结果 <br> select * from t for update skip locked 查询返回查询结果，但忽略有行锁的记录</p> 
<p>——————————— <strong>MySQL</strong> —————————————————–</p> 
<p><strong>MySQL中select * for update锁表的问题</strong></p> 
<p>页级:引擎 BDB。 <br> 表级:引擎 MyISAM ， 理解为锁住整个表，可以同时读，写不行 <br> 行级:引擎 INNODB ， 单独的一行记录加锁 <br> 表级，直接锁定整张表，在你锁定期间，其它进程无法对该表进行写操作。如果你是写锁，则其它进程则读也不允许 <br> 行级,，仅对指定的记录进行加锁，这样其它进程还是可以对同一个表中的其它记录进行操作。 <br> 页级，表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。 <br> MySQL 5.1支持对MyISAM和MEMORY表进行表级锁定，对BDB表进行页级锁定，对InnoDB表进行行级锁定。 <br> 对WRITE，MySQL使用的表锁定方法原理如下： <br> 如果在表上没有锁，在它上面放一个写锁。 <br> 否则，把锁定请求放在写锁定队列中。 <br> 对READ，MySQL使用的锁定方法原理如下： <br> 如果在表上没有写锁定，把一个读锁定放在它上面 <br> 否则，把锁请求放在读锁定队列中。 <br> InnoDB使用行锁定，BDB使用页锁定。对于这两种存储引擎，都可能存在死锁。这是因为，在SQL语句处理期间，InnoDB自动获得行锁定和BDB获得页锁定，而不是在事务启动时获得。 </p> 
<p>MySQL中select * for update锁表的问题 <br> 由于InnoDB预设是Row-Level Lock，所以只有「明确」的指定主键，MySQL才会执行Row lock (只锁住被选取的资料例) ，否则MySQL将会执行Table Lock (将整个资料表单给锁住)。 <br> 举个例子: <br> 假设有个表单products ，里面有id跟name二个栏位，id是主键。 <br> 例1: (明确指定主键，并且有此笔资料，row lock) <br> SELECT * FROM products WHERE id=’3’ FOR UPDATE; <br> SELECT * FROM products WHERE id=’3’ and type=1 FOR UPDATE;</p> 
<p>例2: (明确指定主键，若查无此笔资料，无lock) <br> SELECT * FROM products WHERE id=’-1’ FOR UPDATE;</p> 
<p>例2: (无主键，table lock) <br> SELECT * FROM products WHERE name=’Mouse’ FOR UPDATE;</p> 
<p>例3: (主键不明确，table lock) <br> SELECT * FROM products WHERE id&lt;&gt;’3’ FOR UPDATE;</p> 
<p>例4: (主键不明确，table lock) <br> SELECT * FROM products WHERE id LIKE ‘3’ FOR UPDATE;</p> 
<p>注1: FOR UPDATE仅适用于InnoDB，且必须在交易区块(BEGIN/COMMIT)中才能生效。 <br> 注2: 要测试锁定的状况，可以利用MySQL的Command Mode ，开二个视窗来做测试。</p> 
<p>在MySql 5.0中测试确实是这样的 <br> 另外：MyAsim 只支持表级锁，InnerDB支持行级锁 <br> 添加了(行级锁/表级锁)锁的数据不能被其它事务再锁定，也不被其它事务修改（修改、删除） <br> 是表级锁时，不管是否查询到记录，都会锁定表</p> 
<p><strong>关于Oracle中for update的补充说明：</strong></p> 
<p>分成两类：加锁范围子句和加锁行为子句</p> 
<p><strong>加锁范围子句：</strong> <br> 在select…for update之后，可以使用of子句选择对select的特定数据表进行加锁操作。默认情况下，不使用of子句表示在select所有的数据表中加锁</p> 
<p><strong>加锁行为子句：</strong> <br> 当我们进行for update的操作时，与普通select存在很大不同。一般select是不需要考虑数据是否被锁定，最多根据多版本一致读的特性读取之前的版本。加入for update之后，Oracle就要求启动一个新事务，尝试对数据进行加锁。如果当前已经被加锁，默认的行为必然是block等待。使用nowait子句的作用就是避免进行等待，当发现请求加锁资源被锁定未释放的时候，直接报错返回。</p> 
<p>在日常中，我们对for update的使用还是比较普遍的，特别是在如pl/sql developer中手工修改数据。此时只是觉得方便，而对for update真正的含义缺乏理解。</p> 
<p>For update是Oracle提供的手工提高锁级别和范围的特例语句。Oracle的锁机制是目前各类型数据库锁机制中比较优秀的。所以，Oracle认为一般不需要用户和应用直接进行锁的控制和提升。甚至认为死锁这类锁相关问题的出现场景，大都与手工提升锁有关。所以，Oracle并不推荐使用for update作为日常开发使用。而且，在平时开发和运维中，使用了for update却忘记提交，会引起很多锁表故障。</p> 
<p>那么，什么时候需要使用for update？就是那些需要业务层面数据独占时，可以考虑使用for update。场景上，比如火车票订票，在屏幕上显示邮票，而真正进行出票时，需要重新确定一下这个数据没有被其他客户端修改。所以，在这个确认过程中，可以使用for update。这是统一的解决方案方案问题，需要前期有所准备。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c3344530b81510afc90e3a3106a0ebff/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Binary Hacks：黑客秘笈100选</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c9d37fe78757676b0ebf342a71de22e0/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">波束形成半功率宽度（HPBW）和瑞利限（BW）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>