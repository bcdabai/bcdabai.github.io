<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【设计模式】-建造者模式 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【设计模式】-建造者模式" />
<meta property="og:description" content="Java建造者模式：创建复杂对象的灵活构建者 在软件开发中，我们经常遇到需要创建一个复杂对象的情况。如果使用传统的构造函数进行对象创建，可能会导致构造函数参数过多，难以管理和维护。建造者模式（Builder Pattern）通过引入建造者对象来逐步构建复杂对象，使得对象的构建过程更加灵活、可控，同时还能提供更好的代码可读性和维护性。
一、原理 建造者模式的核心思想是将一个复杂对象的构建过程与它的表示分离，使得同样的构建过程可以创建不同的表示。具体来说，建造者模式通过将对象的构建过程委派给不同的建造者类，每个建造者类都负责创建对象的一部分，并最终将这些部分组装成完整的对象。
它由四个主要的角色组成：产品类（Product）、抽象建造者类（Builder）、具体建造者类（ConcreteBuilder）和指导者类（Director）
产品类（Product）：表示最终构建的对象。该类具有一些属性，可以通过设置相应的setter方法进行赋值，并且定义了一个展示产品的方法。抽象建造者类（Builder）：定义了产品构建的抽象方法。包括构建不同部分的方法和获取最终产品的方法，由具体建造者类来实现。具体建造者类（ConcreteBuilder）：继承自抽象建造者类，实现了具体的构建过程。包括构建不同部分和获取最终产品的方法。指导者类（Director）：负责使用具体的建造者类来构建产品。通过调用具体建造者的方法来完成产品的构造，并最终返回一个完整的产品对象。 产品类
public class Product { private String partA; private String partB; private String partC; public void setPartA(String partA) { this.partA = partA; } public void setPartB(String partB) { this.partB = partB; } public void setPartC(String partC) { this.partC = partC; } public void show() { System.out.println(&#34;Product: &#34; &#43; partA &#43; &#34;, &#34; &#43; partB &#43; &#34;, &#34; &#43; partC); } } 抽象建造者类" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/92e8622e5a2e75ecbddae198885cdb3c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-08-07T15:51:56+08:00" />
<meta property="article:modified_time" content="2023-08-07T15:51:56+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【设计模式】-建造者模式</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2><span style="color:#be191c;">Java建造者模式：创建复杂对象的灵活构建者</span></h2> 
<blockquote> 
 <p>在软件开发中，我们经常遇到需要创建一个复杂对象的情况。如果使用传统的构造函数进行对象创建，可能会导致构造函数参数过多，难以管理和维护。建造者模式（Builder  Pattern）通过引入建造者对象来逐步构建复杂对象，使得对象的构建过程更加灵活、可控，同时还能提供更好的代码可读性和维护性。</p> 
</blockquote> 
<h3>一、原理</h3> 
<p>建造者模式的核心思想是将一个复杂对象的<strong>构建过程</strong>与<strong>它的表示</strong>分离，使得同样的构建过程可以创建不同的表示。具体来说，建造者模式通过将对象的构建过程委派给不同的建造者类，每个建造者类都负责创建对象的一部分，并最终将这些部分组装成完整的对象。</p> 
<p>它由四个主要的角色组成：<strong>产品类（Product）</strong>、<strong>抽象建造者类（Builder）</strong>、<strong>具体建造者类（ConcreteBuilder）</strong>和<strong>指导者类（Director）</strong></p> 
<ul><li>产品类（Product）：表示最终构建的对象。该类具有一些属性，可以通过设置相应的setter方法进行赋值，并且定义了一个展示产品的方法。</li><li>抽象建造者类（Builder）：定义了产品构建的抽象方法。包括构建不同部分的方法和获取最终产品的方法，由具体建造者类来实现。</li><li>具体建造者类（ConcreteBuilder）：继承自抽象建造者类，实现了具体的构建过程。包括构建不同部分和获取最终产品的方法。</li><li>指导者类（Director）：负责使用具体的建造者类来构建产品。通过调用具体建造者的方法来完成产品的构造，并最终返回一个完整的产品对象。</li></ul> 
<p><strong>产品类</strong></p> 
<pre><code class="language-java">public class Product {
    private String partA;
    private String partB;
    private String partC;

    public void setPartA(String partA) {
        this.partA = partA;
    }

    public void setPartB(String partB) {
        this.partB = partB;
    }

    public void setPartC(String partC) {
        this.partC = partC;
    }

    public void show() {
        System.out.println("Product: " + partA + ", " + partB + ", " + partC);
    }
}</code></pre> 
<p><strong>抽象建造者类</strong></p> 
<pre><code class="language-java">public abstract class Builder {
    public abstract void buildPartA();
    public abstract void buildPartB();
    public abstract void buildPartC();
    public abstract Product buildProduct();
}</code></pre> 
<p><strong>具体建造者类</strong></p> 
<pre><code class="language-java">public class ConcreteBuilder extends Builder {
   private Product product = new Product();

    @Override
    public void buildPartA() {
        product.setPartA("生产线1&gt;&gt;&gt;--------&gt;产品A");
    }

    @Override
    public void buildPartB() {
        product.setPartB("生产线1&gt;&gt;&gt;--------&gt;产品B");
    }

    @Override
    public void buildPartC() {
        product.setPartC("生产线1&gt;&gt;&gt;--------&gt;产品C");
    }

    @Override
    public Product buildProduct() {
        return product;
    }
}</code></pre> 
<p><strong>指导者类</strong></p> 
<pre><code class="language-java">public class Director {
   public Builder construct(Builder builder) {
        builder.buildPartA();
        builder.buildPartB();
        builder.buildPartC();
        return builder;
    }
}</code></pre> 
<p><strong>测试</strong></p> 
<pre><code class="language-java">public class Client {
    public static void main(String[] args) {
        // 指导者
        Director director = new Director();
        // 生产线1
        Builder construct = director.construct(new ConcreteBuilder());
        Product product = construct.buildProduct();

        // 显示生产了什么产品
        product.show();
    }
}</code></pre> 
<p><strong>运行结果如下:</strong></p> 
<p><img alt="" class="left" height="194" src="https://images2.imgbox.com/99/82/zUDmxNtI_o.png" width="1132"></p> 
<p> 观察代码，可以发现建造者模式的流程如下：</p> 
<ol><li>第一步，创建<strong>指导者(Director)对象</strong>和<strong>具体建造者(ConcreteBuilder)</strong>对象来开始构建创建过程。</li><li>第二步，<strong>指导者(Director)对象</strong>根据具体的建造者类完成建造过程，调用<strong>具体建造者的方法</strong>来构建产品的各个部分。也就是其方法中的<span style="color:#4da8ee;"><strong>builder.buildPartA();  builder.buildPartB(); builder.buildPartC();</strong></span></li><li>建造者将构建好的部分返回给指导者。</li><li>指导者最终返回一个完整的产品对象，供客户端使用。</li></ol> 
<p></p> 
<p>也就说，Product这个类属性的创建，不由它自身来控制，而是由具体的<strong>指导者(Director)对象</strong>来控制</p> 
<p>那这样感觉把一个对象的创建变得复杂化了，为什么这么做呢? 这么做有什么好处和坏处呢??</p> 
<p><strong>优点：</strong></p> 
<ul><li> <p>可以将复杂对象的构建过程与其表示分离，使得<strong>同样的构建过程可以创建不同的表示</strong>。</p> </li><li> <p>通过增加新的具体建造者类，可以轻松扩展和改变产品的建造过程，符合开闭原则。</p> </li><li> <p>使<strong>用建造者模式可以隐藏产品的内部细节</strong>，对客户端来说只关心如何创建对象，而不需要关心具体的构建过程。</p> </li></ul> 
<p><strong>缺点：</strong></p> 
<ul><li> <p><strong>增加了类的数量，增加了代码的复杂性</strong>。</p> </li><li> <p>对于简单的对象，使用建造者模式可能会显得繁琐。如果一个对象就那么几个字段，且其字段的使用场景比较固定，再用建造者模式就很繁琐了，还不够费劲的呢...</p> </li></ul> 
<p><strong>适用场景</strong></p> 
<ul><li> <p>需要创建的对象具有复杂的内部结构，创建过程需要多个步骤。</p> </li><li> <p>需要创建的对象的属性之间有一定的依赖关系。</p> </li><li> <p>需要创建的对象的表示有多种方式，可以通过建造者模式灵活配置建造过程，得到不同的表示结果。</p> </li></ul> 
<p><strong>总结</strong></p> 
<p>建造者模式通过将对象的构建过程与表示分离，使得同样的构建过程可以创建不同的表示。它可以帮助我们创建复杂的对象，并保证对象的构建过程可配置和可扩展。在实际应用中，建造者模式具有较高的灵活性和可扩展性</p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3c8cdbdb86fca66b1002663eb0ec392e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【设计模式】-代理模式</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/eedee173548fd11b5bd2daddf1019fa3/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">t-SNE（t-Distributed Stochastic Neighbor Embedding）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>