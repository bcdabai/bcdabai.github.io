<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>VS2017开发动态链接库并调试 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="VS2017开发动态链接库并调试" />
<meta property="og:description" content="VS2017开发动态链接库并调试 一、创建动态链接库工程 启动VS2017，选择菜单栏文件 &gt; 新建 &gt; 项目 &gt; 已安装 &gt; Visual C&#43;&#43; &gt; Windows桌面 &gt; 具有导出项的(DLL)动态链接库，设置好工程名称和路径，单击确定完成工程创建。
动态链接库工程创建后，会生成一个模板工程，如图所示。在模板工程中给出了怎样导出类、变量和函数的例子。
在mydll.h文件中已经定义好了动态链接库的导出宏。
// 下列 ifdef 块是创建使从 DLL 导出更简单的 // 宏的标准方法。此 DLL 中的所有文件都是用命令行上定义的 MYDLL_EXPORTS // 符号编译的。在使用此 DLL 的 // 任何项目上不应定义此符号。这样，源文件中包含此文件的任何其他项目都会将 // MYDLL_API 函数视为是从 DLL 导入的，而此 DLL 则将用此宏定义的 // 符号视为是被导出的。 #ifdef MYDLL_EXPORTS #define MYDLL_API __declspec(dllexport) #else #define MYDLL_API __declspec(dllimport) #endif 为了便于多文件导出目标函数，先对模板工程进行简单修改，在解决方案窗口中，右键mydll工程 &gt; 添加 &gt; 新建项 &gt; 已安装 &gt; Visual C&#43;&#43; &gt; 头文件，将文件名修改为export.h，单击添加完成。
在export.h文件中添加如下代码。
#pragma once #ifndef MYDLL_EXPORT_H_ #define MYDLL_EXPORT_H_ // 下列 ifdef 块是创建使从 DLL 导出更简单的 // 宏的标准方法。此 DLL 中的所有文件都是用命令行上定义的 MYDLL_EXPORTS // 符号编译的。在使用此 DLL 的 // 任何项目上不应定义此符号。这样，源文件中包含此文件的任何其他项目都会将 // MYDLL_API 函数视为是从 DLL 导入的，而此 DLL 则将用此宏定义的 // 符号视为是被导出的。 #ifdef MYDLL_EXPORTS #define MYDLL_API __declspec(dllexport) #else #define MYDLL_API __declspec(dllimport) #endif #endif // !" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/9f2ef1d1a01025002d7c356e46117111/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-03-25T11:39:49+08:00" />
<meta property="article:modified_time" content="2022-03-25T11:39:49+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">VS2017开发动态链接库并调试</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="VS2017_0"></a>VS2017开发动态链接库并调试</h2> 
<h2><a id="_2"></a>一、创建动态链接库工程</h2> 
<ol><li> <p>启动VS2017，选择菜单栏<strong>文件 &gt; 新建 &gt; 项目 &gt; 已安装 &gt; Visual C++ &gt; Windows桌面 &gt; 具有导出项的(DLL)动态链接库</strong>，设置好工程名称和路径，单击<strong>确定</strong>完成工程创建。</p> <p><img src="https://images2.imgbox.com/6e/3b/mZkSX5Qx_o.png" alt="在这里插入图片描述"></p> </li><li> <p>动态链接库工程创建后，会生成一个模板工程，如图所示。在模板工程中给出了怎样导出<strong>类、变量和函数</strong>的例子。</p> <p><img src="https://images2.imgbox.com/77/8b/bJhPzoLj_o.png" alt="在这里插入图片描述"></p> </li><li> <p>在<strong>mydll.h</strong>文件中已经定义好了动态链接库的导出宏。</p> <pre><code class="prism language-C++">// 下列 ifdef 块是创建使从 DLL 导出更简单的
// 宏的标准方法。此 DLL 中的所有文件都是用命令行上定义的 MYDLL_EXPORTS
// 符号编译的。在使用此 DLL 的
// 任何项目上不应定义此符号。这样，源文件中包含此文件的任何其他项目都会将
// MYDLL_API 函数视为是从 DLL 导入的，而此 DLL 则将用此宏定义的
// 符号视为是被导出的。
#ifdef MYDLL_EXPORTS
#define MYDLL_API __declspec(dllexport)
#else
#define MYDLL_API __declspec(dllimport)
#endif
</code></pre> </li><li> <p>为了便于多文件导出目标函数，先对模板工程进行简单修改，在解决方案窗口中，<strong>右键mydll工程 &gt; 添加 &gt; 新建项 &gt; 已安装 &gt; Visual C++ &gt; 头文件</strong>，将文件名修改为<strong>export.h</strong>，单击<strong>添加</strong>完成。</p> <p><img src="https://images2.imgbox.com/91/ef/aCRbirzs_o.png" alt="在这里插入图片描述"></p> </li><li> <p>在<strong>export.h</strong>文件中添加如下代码。</p> <pre><code class="prism language-C++">#pragma once
#ifndef MYDLL_EXPORT_H_
#define MYDLL_EXPORT_H_

// 下列 ifdef 块是创建使从 DLL 导出更简单的
// 宏的标准方法。此 DLL 中的所有文件都是用命令行上定义的 MYDLL_EXPORTS
// 符号编译的。在使用此 DLL 的
// 任何项目上不应定义此符号。这样，源文件中包含此文件的任何其他项目都会将
// MYDLL_API 函数视为是从 DLL 导入的，而此 DLL 则将用此宏定义的
// 符号视为是被导出的。
#ifdef MYDLL_EXPORTS
#define MYDLL_API __declspec(dllexport)
#else
#define MYDLL_API __declspec(dllimport)
#endif

#endif // !MYDLL_EXPORT_H_
</code></pre> <p>删除<strong>mydll.h</strong>中的如下代码</p> <pre><code class="prism language-C++">// 下列 ifdef 块是创建使从 DLL 导出更简单的
// 宏的标准方法。此 DLL 中的所有文件都是用命令行上定义的 MYDLL_EXPORTS
// 符号编译的。在使用此 DLL 的
// 任何项目上不应定义此符号。这样，源文件中包含此文件的任何其他项目都会将
// MYDLL_API 函数视为是从 DLL 导入的，而此 DLL 则将用此宏定义的
// 符号视为是被导出的。
#ifdef MYDLL_EXPORTS
#define MYDLL_API __declspec(dllexport)
#else
#define MYDLL_API __declspec(dllimport)
#endif
</code></pre> <p>在最上方添加</p> <pre><code class="prism language-C++">#include "export.h"
</code></pre> <p>当动态链接库工程包含多个文件时，只需在各文件引入头文件<strong>export.h</strong>即可完成目标接口的导出。</p> </li><li> <p>在菜单栏选择<strong>生成 &gt; 生成解决方案</strong>，生成成功后会生成如下文件。</p> <p><img src="https://images2.imgbox.com/1a/de/v6dwU8qG_o.png" alt="在这里插入图片描述"></p> <p>并可在VS2017输出窗口查看到编译成功的信息。</p> <pre><code class="prism language-powershell">1&gt;<span class="token operator">--</span>-<span class="token operator">--</span><span class="token operator">-</span> 已启动生成: 项目: mydll<span class="token punctuation">,</span> 配置: Debug Win32 <span class="token operator">--</span>-<span class="token operator">--</span><span class="token operator">-</span>
1&gt;pch<span class="token punctuation">.</span><span class="token function">cpp</span>
1&gt;dllmain<span class="token punctuation">.</span><span class="token function">cpp</span>
1&gt;mydll<span class="token punctuation">.</span><span class="token function">cpp</span>
1&gt;正在生成代码<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
1&gt;  正在创建库 E:\Code<span class="token operator">-</span>of<span class="token operator">-</span>C+<span class="token operator">+</span>\vs2017_test\mydll\Debug\MYDLL<span class="token punctuation">.</span>lib 和对象 E:\Code<span class="token operator">-</span>of<span class="token operator">-</span>C+<span class="token operator">+</span>\vs2017_test\mydll\Debug\MYDLL<span class="token punctuation">.</span>exp
1&gt;mydll<span class="token punctuation">.</span>vcxproj <span class="token operator">-</span>&gt; E:\Code<span class="token operator">-</span>of<span class="token operator">-</span>C+<span class="token operator">+</span>\vs2017_test\mydll\Debug\MYDLL<span class="token punctuation">.</span>dll
========== 生成: 成功 1 个，失败 0 个，最新 0 个，跳过 0 个 ==========
</code></pre> </li><li> <p>修改<strong>mydll.h</strong>和<strong>mydll.cpp</strong>，实现一些具体接口，便于下一步进行调试。</p> 
  <ul><li> <p><strong>mydll.h</strong></p> <pre><code class="prism language-C++">#include "export.h"

#include &lt;iostream&gt;
#include &lt;string&gt;

/**
 * @enum	INFO_TYPE
 * @brief	消息等级
 */
enum INFO_TYPE
{
	MY_INFO,		///&lt; 普通消息
	MY_WARNING,		///&lt; 警告消息
	MY_ERROR,		///&lt; 错误消息
};

/**
 * @struct	MY_INFO
 * @brief	定义消息结构体
 */
typedef struct MY_MSG {
	INFO_TYPE infoType;			///&lt; 消息等级
	std::string msg;			///&lt; 详细信息
	std::string funcName;		///&lt; 函数名称
} MY_MSG;

/**
 * @class	DllTest
 * @brief	动态链接库导出类测试
 */
class MYDLL_API DllTest
{
public:
	/**
	 * @brief	构造函数
	 */
	DllTest(std::string &amp;s);
	
	/**
	 * @brief	析构函数
	 */
	~DllTest();

	DllTest &amp;setStr(std::string &amp;s);
	/**
	 *******************************************************************************
	 * @brief 		输出字符串
	 * @ref  		\n
	 * @return 		void
	 * - 返回值描述
	 * @author		AILEE
	 * @date		2020-12-31
	 * @par 示例:
	 * @code
	 * @endcode
	 * @see
	 *******************************************************************************
	 */
	void printStr();

private:
	std::string str;
};

/**
 *******************************************************************************
 * @brief 		输出消息
 * @param[in]  	MY_MSG &amp; msg	: 消息结构体
 * @ref  		\n
 * @return 		void
 * - 无返回值
 * @author		AILEE
 * @date		2020-12-31
 * @par 示例:
 * @code
 * @endcode
 * @see
 *******************************************************************************
 */
MYDLL_API void printInfo(MY_MSG &amp;msg);
</code></pre> </li><li> <p><strong>mydll.cpp</strong></p> <pre><code class="prism language-c++">// mydll.cpp : 定义 DLL 的导出函数。
//

#include "pch.h"
#include "framework.h"
#include "mydll.h"

DllTest::DllTest(std::string &amp; s) :str(s) {}

DllTest::~DllTest() {}

DllTest &amp; DllTest::setStr(std::string &amp; s)
{
	str = s;
	return *this;
}

void DllTest::printStr()
{
	std::cout &lt;&lt; str &lt;&lt; std::endl;
}

void printInfo(MY_MSG &amp;msg)
{
	switch (msg.infoType)
	{
	case MY_INFO:
		std::cout &lt;&lt; "[INFO]: " &lt;&lt; msg.msg &lt;&lt; std::endl;
		break;
	case MY_WARNING:
		std::cout &lt;&lt; "[WARNING]: " &lt;&lt; msg.funcName &lt;&lt; ": " &lt;&lt; msg.msg &lt;&lt; std::endl;
		break;
	case MY_ERROR:
		std::cout &lt;&lt; "[ERROR]: " &lt;&lt; msg.funcName &lt;&lt; ": " &lt;&lt; msg.msg &lt;&lt; std::endl;
		break;
	default:
		break;
	}
}
</code></pre> </li></ul> </li><li> <p>重新编译</p> </li></ol> 
<h2><a id="2__232"></a>2. 创建控制台应用工程，调用动态链接库并进行联合调试。</h2> 
<ol><li> <p>选择解决方案窗口，<strong>右键解决方案 &gt; 添加 &gt; 新建项目 &gt; 已安装 &gt; Visual C++ &gt; Windows桌面 &gt; 控制台应用</strong>，设置好项目名称，单击<strong>确定</strong>完成。</p> <p><img src="https://images2.imgbox.com/fe/98/XH71GO1O_o.png" alt="在这里插入图片描述"></p> </li><li> <p>右键解决方案列表中的mydll_example项目，选择<strong>设为启动项目</strong>。</p> </li><li> <p>右键解决方案列表中的mydll_example项目，选择<strong>生成依赖项 &gt; 项目依赖项</strong>，在弹出的窗口中，勾选<strong>mydll</strong>。</p> <p><img src="https://images2.imgbox.com/51/f0/9qN1M23z_o.png" alt="在这里插入图片描述"></p> </li><li> <p>右键解决方案列表中的mydll_example项目，<strong>选择属性</strong>，在弹出的属性页中，将<strong>配置</strong>改为<strong>所有配置</strong>，然后选择<strong>链接器 &gt; 常规 &gt; 附加库目录 &gt; 编辑 &gt; 宏</strong>，进行如下配置。</p> <p><img src="https://images2.imgbox.com/f3/dc/XvxWQ6II_o.png" alt="在这里插入图片描述"></p> <p><img src="https://images2.imgbox.com/13/22/DMYMhGbq_o.png" alt="在这里插入图片描述"></p> <p>选择<strong>属性页 &gt; 链接器 &gt; 输入 &gt; 附加依赖项 &gt; 编辑</strong>，添加<strong>MYDLL.lib</strong>。</p> <p><img src="https://images2.imgbox.com/a8/19/JlNqQVB7_o.png" alt="在这里插入图片描述"></p> <p><img src="https://images2.imgbox.com/f9/6a/N5RBQFmr_o.png" alt="在这里插入图片描述"></p> <p>单击<strong>确定</strong>，完成属性设置。</p> </li><li> <p>在<strong>mydll_example.cpp</strong>的最上面添加，因为mydll工程和mydll_example工程是同一级目录，因此添加<strong>mydll.h</strong>头文件时需要先返回上一级目录。</p> <pre><code class="prism language-C++">#include "../mydll/mydll.h"
</code></pre> </li><li> <p>将<strong>mydll_example.cpp</strong>修改为如下内容</p> <pre><code class="prism language-C++">#include "../mydll/mydll.h"

int main()
{
	std::string str = "hello world!\n";
	// 创建对象
	DllTest dllTest(str);
	// 打印对象中的字符串
	dllTest.printStr();
	// 设置对象中的字符串
	str = "hello dll!\n";
	dllTest.setStr(str);
	// 打印对象中的字符串
	dllTest.printStr();

	// 调用打印消息函数，输出消息
	std::string warning_msg = "this is a waring.";
	MY_MSG msg;
	msg.infoType = MY_WARNING;
	msg.funcName = __FUNCTION__;
	msg.msg = warning_msg;
	printInfo(msg);
}
</code></pre> </li><li> <p>选择菜单栏中<strong>调试 &gt; 开始执行(不调试)</strong>，将在命令行窗口输出如下内容。</p> <p><img src="https://images2.imgbox.com/95/11/ItHvMZ0U_o.png" alt="在这里插入图片描述"></p> </li><li> <p>设置好断点，选择菜单栏中<strong>调试 &gt; 开始调试</strong>，即可进行调试。</p> <p><img src="https://images2.imgbox.com/6e/d9/DrYlnkYD_o.png" alt="在这里插入图片描述"></p> </li><li> <p>切换到Release配置，重新生成解决方案，即可在<strong>mydll</strong>工程文件夹下的<strong>Release</strong>文件夹下找到<strong>MYDLL.dll</strong>和<strong>MDLL.lib</strong>，将其拷贝一份，并复制工程对应的头文件，按如下方式组织，即可进行动态链接库的发布，方便以后使用。</p> 
  <ul><li>mydll_x86_release 
    <ul><li>bin 
      <ul><li>mydll.dll</li></ul> </li><li>include 
      <ul><li>export.h</li><li>framework.h</li><li>mydll.h</li><li>pch.h</li></ul> </li><li>lib 
      <ul><li>mydll.lib</li></ul> </li></ul> </li></ul> </li></ol> 
<h2><a id="_321"></a>参考文献</h2> 
<ul><li><a href="https://blog.csdn.net/cynophile/article/details/79749524">使用VS2017创建DLL并链接至其他项目中【转】</a></li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/1342c13208f99bdf5e3fe0386ae5cf07/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Flutter framework在线上构建时的包大小优化</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a1f9f70235013ff6ba0dc6b1a86d56d1/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Centos7 安装nginx-1.9.9教程</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>