<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>网络编程—Socket套接字详解 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="网络编程—Socket套接字详解" />
<meta property="og:description" content="目录
一、网络编程
1.1、为什么需要网络编程？
1.2、什么是网络编程
1.3、发送端和接收端
​编辑1.4、请求和响应
​编辑1.5、客户端和服务端 二、Socket套接字 2.1、概念
2.2、分类 2.2.1、流套接字 2.2.2、数据报套接字 2.2.3、原始套接字 2.3、Socket编程注意事项 一、网络编程 1.1、为什么需要网络编程？ 现在网络普及程度越来越高，网络上保存着我们日常生活中所需要的各种资源，使用程序通过网络来获取这些资源的过程就需要网络编程来实现。
1.2、什么是网络编程 网络编程，是指网络上的主机，通过不同的进程，以程序的方式实现网络编程(网络数据传输)。
当然，只要满足不同的进程就行；所以即便是同一个主机，只要是不同的进程，基于网络来传输数据，也属于网络编程。 对于条件有限情况下，一般也都是在一个主机中运行多个进程来完成网络编程。
但是，一定要明确，目的是提供网络上不同主机，基于网络来传输数据资源。
进程A：编程来获取网络资源进程B：编程来提供网络资源 1.3、发送端和接收端 在第一次网络数据传输时：
发送端：数据的发送方进程，称为发送端，发送端主机即网络通信中的源主机。
接收端：数据的接收方进程，称为接收端，接收端主机即网络通信中的目的主机。
收发端：发送端和接收端两端，简称为收发端。
注意：发送端和接收端只是相对的，只是一次网络数据传输产生数据流向后的概念。
1.4、请求和响应 一般来说，获取一个网络资源，涉及到两次数据传输:
第一次:请求数据的发送第二次:响应数据的发送 好比餐馆吃饭：先要发起请求—点份炒饭；响应对方的请求—提供一份炒饭。
1.5、客户端和服务端 服务端：在常见的网络数据传输的场景下，把提供服务的一方进程，称为服务端，可以对外提供服务。 客户端：获取服务的一方进程，称为客户端。
对于服务来说，一般是提供：
客户端获取服务资源 客户端保存资源在服务端 好比我们在银行办理业务 银行提供存款服务：用户(客户端)存储现金(资源)在银行(服务端).银行提供取款服务：用户(客户端)取存储的现金(获取用户端资源). 常见的客户端和服务端模型
客户端是只给用户使用的程序，服务端是提供用户服务的程序。 客户端先发送请求到服务端.服务端根据请求数据，执行相应的业务处理.服务端返回响应，发送业务处理结果.客户端根据响应数据，展示处理结果(获取的资源，或提示保存资源的处理结果). 二、Socket套接字 2.1、概念 Socket套接字，是由系统提供用于网络通信的技术，是基于TCP/IP协议的网络通信的基本操作单元。基于Socket套接字的网络程序开发就是网络编程。
2.2、分类 Socket套接字主要针对传输层协议划分为如下三类：
2.2.1、流套接字 使用传输层TCP协议，以下为TCP协议的特点
有连接可靠传输面向字节流有接收缓冲区，也有发送缓冲区大小不限 对于字节流来说，可以简单理解为，传输数据是基于IO流，流式数据的特征就是在IO流没有关闭的情况下，是无边界的数据，可以多次发送，也可以分开多次发送。
2.2.2、数据报套接字 使用传输层UDP协议 ，以下为UDP协议的特点
有连接不可靠传输面向数据报有接收缓冲区，也有发送缓冲区大小受限:一次最多传输64k 对于数据报来说，可以简单理解为，传输数据是一块一块的，发送一块数据假如是100个字节，必须一次性发送，接收也必须一次性接收，而不能分一百接收，每次接收一个字节。
2.2.3、原始套接字 原始套接字用于自定义传输协议，用于读写内核没有处理的IP协议数据。
有兴趣了解的盆友可以去看看这位大佬的博客原始套接字 2.3、Socket编程注意事项 客户端和服务端：开发时，经常是基于一个主机开启两个进程作为客户端和服务端，但真实的场景，一般都是不同主机。注意目的IP和目的端口号，标识了一次数据传输时要发送数据的终点主机和进程。Socket编程我们是使用流套接字和数据报套接字，基于传输层的TCP或UDP协议，但应用层协议，也需要考虑，这块我们在后续来说明如何设计应用层协议。关于端口被占用的问题。 如果一个进程A已经绑定了一个端口，再启动一个进程B绑定该端口，就会报错，这种情况也叫端口占用。对于java进程来说端口占用报错信息
此时就需要检查进程B绑定的是哪个端口，再查看哪个端口被占用，以下为端口查看进程的方式
1、打开命令行窗口输入命令，查找占用端口的应用进程。则可以显示对应进程的pid。如以下命令显示了8888进程的pid。
netstat -ano|findstr 端口号 2、在任务管理器中，通过pid查找进程" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/fd7174e937c3fbd88ea897adb38ac7e3/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-07-08T15:35:52+08:00" />
<meta property="article:modified_time" content="2023-07-08T15:35:52+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">网络编程—Socket套接字详解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80%E3%80%81%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-toc" style="margin-left:40px;"><a href="#%E4%B8%80%E3%80%81%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B" rel="nofollow">一、网络编程</a></p> 
<p id="1.1%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%EF%BC%9F-toc" style="margin-left:80px;"><a href="#1.1%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%EF%BC%9F" rel="nofollow">1.1、为什么需要网络编程？</a></p> 
<p id="1.2%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-toc" style="margin-left:80px;"><a href="#1.2%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B" rel="nofollow">1.2、什么是网络编程</a></p> 
<p id="1.3%E3%80%81%E5%8F%91%E9%80%81%E7%AB%AF%E5%92%8C%E6%8E%A5%E6%94%B6%E7%AB%AF-toc" style="margin-left:80px;"><a href="#1.3%E3%80%81%E5%8F%91%E9%80%81%E7%AB%AF%E5%92%8C%E6%8E%A5%E6%94%B6%E7%AB%AF" rel="nofollow">1.3、发送端和接收端</a></p> 
<p id="%E2%80%8B%E7%BC%96%E8%BE%911.4%E3%80%81%E8%AF%B7%E6%B1%82%E5%92%8C%E5%93%8D%E5%BA%94-toc" style="margin-left:80px;"><a href="#%E2%80%8B%E7%BC%96%E8%BE%911.4%E3%80%81%E8%AF%B7%E6%B1%82%E5%92%8C%E5%93%8D%E5%BA%94" rel="nofollow">​编辑1.4、请求和响应</a></p> 
<p id="%E2%80%8B%E7%BC%96%E8%BE%911.5%E3%80%81%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%92%8C%E6%9C%8D%E5%8A%A1%E7%AB%AF%C2%A0-toc" style="margin-left:80px;"><a href="#%E2%80%8B%E7%BC%96%E8%BE%911.5%E3%80%81%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%92%8C%E6%9C%8D%E5%8A%A1%E7%AB%AF%C2%A0" rel="nofollow">​编辑1.5、客户端和服务端 </a></p> 
<p id="%E4%BA%8C%E3%80%81Socket%E5%A5%97%E6%8E%A5%E5%AD%97%C2%A0-toc" style="margin-left:40px;"><a href="#%E4%BA%8C%E3%80%81Socket%E5%A5%97%E6%8E%A5%E5%AD%97%C2%A0" rel="nofollow">二、Socket套接字 </a></p> 
<p id="2.1%E3%80%81%E6%A6%82%E5%BF%B5-toc" style="margin-left:80px;"><a href="#2.1%E3%80%81%E6%A6%82%E5%BF%B5" rel="nofollow">2.1、概念</a></p> 
<p id="2.2%E3%80%81%E5%88%86%E7%B1%BB%C2%A0-toc" style="margin-left:80px;"><a href="#2.2%E3%80%81%E5%88%86%E7%B1%BB%C2%A0" rel="nofollow">2.2、分类 </a></p> 
<p id="2.2.1%E3%80%81%E6%B5%81%E5%A5%97%E6%8E%A5%E5%AD%97%C2%A0-toc" style="margin-left:120px;"><a href="#2.2.1%E3%80%81%E6%B5%81%E5%A5%97%E6%8E%A5%E5%AD%97%C2%A0" rel="nofollow">2.2.1、流套接字 </a></p> 
<p id="2.2.2%E3%80%81%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%A5%97%E6%8E%A5%E5%AD%97%C2%A0-toc" style="margin-left:120px;"><a href="#2.2.2%E3%80%81%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%A5%97%E6%8E%A5%E5%AD%97%C2%A0" rel="nofollow">2.2.2、数据报套接字 </a></p> 
<p id="2.2.3%E3%80%81%E5%8E%9F%E5%A7%8B%E5%A5%97%E6%8E%A5%E5%AD%97%C2%A0-toc" style="margin-left:120px;"><a href="#2.2.3%E3%80%81%E5%8E%9F%E5%A7%8B%E5%A5%97%E6%8E%A5%E5%AD%97%C2%A0" rel="nofollow">2.2.3、原始套接字 </a></p> 
<p id="2.3%E3%80%81Socket%E7%BC%96%E7%A8%8B%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%C2%A0-toc" style="margin-left:80px;"><a href="#2.3%E3%80%81Socket%E7%BC%96%E7%A8%8B%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%C2%A0" rel="nofollow">2.3、Socket编程注意事项 </a></p> 
<hr id="hr-toc"> 
<p></p> 
<h3>一、网络编程</h3> 
<h4 id="1.1%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%EF%BC%9F">1.1、为什么需要网络编程？</h4> 
<p>现在网络普及程度越来越高，网络上保存着我们日常生活中所需要的各种资源，使用程序通过网络来获取这些资源的过程就需要网络编程来实现。</p> 
<h4 id="1.2%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B">1.2、什么是网络编程</h4> 
<p>网络编程，是指网络上的主机，通过不同的进程，以程序的方式实现网络编程(网络数据传输)。</p> 
<p><img alt="" height="472" src="https://images2.imgbox.com/57/3a/xHtGVJg7_o.png" width="907"></p> 
<blockquote> 
 <p>当然，只要满足不同的进程就行；所以即便是同一个主机，只要是不同的进程，基于网络来传输数据，也属于网络编程。 </p> 
 <p>对于条件有限情况下，一般也都是在一个主机中运行多个进程来完成网络编程。</p> 
 <p>但是，一定要明确，目的是提供网络上不同主机，基于网络来传输数据资源。</p> 
 <ul><li>进程A：编程来获取网络资源</li><li>进程B：编程来提供网络资源</li></ul> 
</blockquote> 
<h4 id="1.3%E3%80%81%E5%8F%91%E9%80%81%E7%AB%AF%E5%92%8C%E6%8E%A5%E6%94%B6%E7%AB%AF">1.3、发送端和接收端</h4> 
<p>在第一次网络数据传输时：</p> 
<p><strong>发送端</strong>：数据的<strong>发送方进程</strong>，称为发送端，发送端主机即网络通信中的源主机。</p> 
<p><strong>接收端</strong>：数据的<strong>接收方进程</strong>，称为接收端，接收端主机即网络通信中的目的主机。</p> 
<p><strong>收发端</strong>：发送端和接收端两端，简称为收发端。</p> 
<p>注意：发送端和接收端只是相对的，只是一次网络数据传输产生数据流向后的概念。</p> 
<h4 id="%E2%80%8B%E7%BC%96%E8%BE%911.4%E3%80%81%E8%AF%B7%E6%B1%82%E5%92%8C%E5%93%8D%E5%BA%94"><img alt="" height="444" src="https://images2.imgbox.com/4b/9c/E6FVvLg8_o.png" width="868">1.4、请求和响应</h4> 
<p>一般来说，获取一个网络资源，涉及到两次数据传输:</p> 
<ul><li>第一次:请求数据的发送</li><li>第二次:响应数据的发送</li></ul> 
<p>好比餐馆吃饭：先要发起请求—点份炒饭；响应对方的请求—提供一份炒饭。</p> 
<h4 id="%E2%80%8B%E7%BC%96%E8%BE%911.5%E3%80%81%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%92%8C%E6%9C%8D%E5%8A%A1%E7%AB%AF%C2%A0"><img alt="" height="464" src="https://images2.imgbox.com/53/1a/tMhgwFdo_o.png" width="873">1.5、客户端和服务端 </h4> 
<p><strong>服务端</strong>：在常见的网络数据传输的场景下，把提供服务的一方进程，称为服务端，可以对外提供服务。 </p> 
<p><strong>客户端</strong>：<strong><span style="color:#956fe7;">获取服务</span></strong>的一方进程，称为客户端。</p> 
<p>对于服务来说，一般是提供：</p> 
<ul><li>客户端获取服务资源</li></ul> 
<p><img alt="" height="456" src="https://images2.imgbox.com/3e/9b/X9xohCbl_o.png" width="895"></p> 
<ul><li>客户端保存资源在服务端  </li></ul> 
<p><img alt="" height="466" src="https://images2.imgbox.com/a6/2f/XoJdC2tB_o.png" width="853"></p> 
<p>好比我们在银行办理业务 </p> 
<blockquote> 
 <ul><li>银行提供存款服务：用户(客户端)存储现金(资源)在银行(服务端).</li><li>银行提供取款服务：用户(客户端)取存储的现金(获取用户端资源).</li></ul> 
</blockquote> 
<p>常见的客户端和服务端模型</p> 
<p>客户端是只给用户使用的程序，服务端是提供用户服务的程序。 </p> 
<blockquote> 
 <ol><li> 客户端先发送请求到服务端.</li><li>服务端根据请求数据，执行相应的业务处理.</li><li>服务端返回响应，发送业务处理结果.</li><li>客户端根据响应数据，展示处理结果(获取的资源，或提示保存资源的处理结果).</li></ol> 
</blockquote> 
<p> <img alt="" height="449" src="https://images2.imgbox.com/02/b7/InbypI6z_o.png" width="877"></p> 
<h3 id="%E4%BA%8C%E3%80%81Socket%E5%A5%97%E6%8E%A5%E5%AD%97%C2%A0">二、Socket套接字 </h3> 
<h4 id="2.1%E3%80%81%E6%A6%82%E5%BF%B5">2.1、概念</h4> 
<p>Socket套接字，是由系统提供用于网络通信的技术，是基于TCP/IP协议的网络通信的基本操作单元。基于Socket套接字的网络程序开发就是网络编程。</p> 
<h4 id="2.2%E3%80%81%E5%88%86%E7%B1%BB%C2%A0">2.2、分类 </h4> 
<p>Socket套接字主要针对传输层协议划分为如下三类：</p> 
<h5 id="2.2.1%E3%80%81%E6%B5%81%E5%A5%97%E6%8E%A5%E5%AD%97%C2%A0"><strong>2.2.1、流套接字 </strong></h5> 
<p>使用传输层TCP协议，以下为TCP协议的特点</p> 
<blockquote> 
 <ul><li>有连接</li><li>可靠传输</li><li>面向字节流</li><li>有接收缓冲区，也有发送缓冲区</li><li>大小不限</li></ul> 
</blockquote> 
<p>对于字节流来说，可以简单理解为，传输数据是基于IO流，流式数据的特征就是在IO流没有关闭的情况下，是无边界的数据，可以多次发送，也可以分开多次发送。</p> 
<h5 id="2.2.2%E3%80%81%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%A5%97%E6%8E%A5%E5%AD%97%C2%A0">2.2.2、数据报套接字 </h5> 
<p>使用传输层UDP协议 ，以下为UDP协议的特点</p> 
<blockquote> 
 <ul><li>有连接</li><li>不可靠传输</li><li>面向数据报</li><li>有接收缓冲区，也有发送缓冲区</li><li>大小受限:一次最多传输64k</li></ul> 
</blockquote> 
<p>对于数据报来说，可以简单理解为，传输数据是一块一块的，发送一块数据假如是100个字节，必须一次性发送，接收也必须一次性接收，而不能分一百接收，每次接收一个字节。</p> 
<h5 id="2.2.3%E3%80%81%E5%8E%9F%E5%A7%8B%E5%A5%97%E6%8E%A5%E5%AD%97%C2%A0">2.2.3、原始套接字 </h5> 
<p>原始套接字用于自定义传输协议，用于读写内核没有处理的IP协议数据。</p> 
<p>有兴趣了解的盆友可以去看看这位大佬的博客<a href="https://blog.csdn.net/weixin_43288201/article/details/106266418?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168879998216800225593597%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=168879998216800225593597&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-106266418-null-null.142%5Ev88%5Einsert_down38v5,239%5Ev2%5Einsert_chatgpt&amp;utm_term=%E5%8E%9F%E5%A7%8B%E5%A5%97%E6%8E%A5%E5%AD%97&amp;spm=1018.2226.3001.4187" title="原始套接字">原始套接字</a> </p> 
<h4 id="2.3%E3%80%81Socket%E7%BC%96%E7%A8%8B%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%C2%A0">2.3、Socket编程注意事项 </h4> 
<ol><li>客户端和服务端：开发时，经常是基于一个主机开启两个进程作为客户端和服务端，但真实的场景，一般都是不同主机。</li><li>注意目的IP和目的端口号，标识了一次数据传输时要发送数据的终点主机和进程。</li><li>Socket编程我们是使用流套接字和数据报套接字，基于传输层的TCP或UDP协议，但应用层协议，也需要考虑，这块我们在后续来说明如何设计应用层协议。</li><li>关于端口被占用的问题。</li></ol> 
<p>如果一个进程A已经绑定了一个端口，再启动一个进程B绑定该端口，就会报错，这种情况也叫端口占用。对于java进程来说端口占用报错信息</p> 
<p><img alt="" height="834" src="https://images2.imgbox.com/fb/be/SZ9a1Zl9_o.png" width="1200">此时就需要检查进程B绑定的是哪个端口，再查看哪个端口被占用，以下为端口查看进程的方式</p> 
<blockquote> 
 <p>1、打开命令行窗口输入命令，查找占用端口的应用进程。则可以显示对应进程的pid。如以下命令显示了8888进程的pid。</p> 
 <p></p> 
 <pre><code class="language-java">netstat -ano|findstr 端口号</code></pre> 
 <p><img alt="" height="177" src="https://images2.imgbox.com/40/f8/Oq1iKe5U_o.png" width="1200"></p> 
 <p>2、在任务管理器中，通过pid查找进程</p> 
 <p><img alt="" height="703" src="https://images2.imgbox.com/ff/eb/0WXlJBgQ_o.png" width="751"></p> 
 <p>解决端口被占用的问题：</p> 
 <ul><li>如果占用端口的进程A不需要运行，就可以关闭A后，再启动需要绑定该端口的进程B</li><li>如果需要运行A进程，则可以修改进程B的绑定端口，换为其他没有使用的端口。 </li></ul> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/14e2dad2275fd6441e0ec7a35b59b920/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Shiro安全框架讲解及应用</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8469826fc493ebe40f9c363c47ce5ffa/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">基于SpringBoot&#43;vue校园信息交流互助系统</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>