<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>算法训练三（DFS、BFS、回溯）（含解题思路）（下） - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="算法训练三（DFS、BFS、回溯）（含解题思路）（下）" />
<meta property="og:description" content="目录
7-13 桥短几何（深度优先搜索&#43;广度优先搜索）
AC代码：
7-15 01迷宫（广度优先搜索）
AC代码：
7-17 生化危机（图的深度优先搜索）
AC代码：
7-18 模拟炸弹人（广度优先搜索）
AC代码：
7-19 N皇后问题（回溯）
AC代码：
7-20 图着色问题（图的应用）
AC代码：
7-21 排座位（图的应用）
AC代码：
7-22 红色警报 （图的连通分量）
AC代码：
7-23 列出连通集（深度优先搜索/广度优先搜索）
AC代码：
7-25 功夫传人 (广度优先搜索)
AC代码：
7-26 深入虎穴 （广度优先搜索）
AC代码：
7-27 肿瘤诊断 （三维广度优先搜索）
AC代码：
因题集题目较多，上半部分请移步这里：
算法训练三(DFS、BFS、回溯)(含模板)(上)_清晨喝碗粥的博客-CSDN博客
7-13 桥短几何（深度优先搜索&#43;广度优先搜索） 在一个NxN的布尔矩阵中，0表示水，1表示陆地，一片由1围成的最大区域就是一个岛，假定方阵中有且只有两个岛，请计算连接这两个岛的最短的桥的长度（架桥相当于翻转0为1，使两个岛相连）。
输入样例1：
第一行一个正整数N（取值范围在[2--100]）。
以后N行以空格分隔的0或1，每行N个（0表示水，1表示陆地）。
3
0 0 1
0 0 1
1 1 0
输出样例1：
一个表示最短的桥的长度的正整数，本例中，正中间或右下角均是可行方案。
1
输入样例2：
第一行一个正整数N（取值范围在[2--100]）。
以后N行以空格分隔的0或1，每行N个（0表示水，1表示陆地）。
5
1 1 1 1 1" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/d57fb9be0c461eaaa1348abd82be36a9/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-01-14T14:17:38+08:00" />
<meta property="article:modified_time" content="2023-01-14T14:17:38+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">算法训练三（DFS、BFS、回溯）（含解题思路）（下）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="-toc" style="margin-left:0px;"></p> 
<p id="7-13%20%E6%A1%A5%E7%9F%AD%E5%87%A0%E4%BD%95%EF%BC%88%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%2B%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%EF%BC%89-toc" style="margin-left:0px;"><a href="#7-13%20%E6%A1%A5%E7%9F%AD%E5%87%A0%E4%BD%95%EF%BC%88%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%2B%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%EF%BC%89" rel="nofollow">7-13 桥短几何（深度优先搜索+广度优先搜索）</a></p> 
<p id="AC%E4%BB%A3%E7%A0%81%EF%BC%9A-toc" style="margin-left:0px;"><a href="#AC%E4%BB%A3%E7%A0%81%EF%BC%9A" rel="nofollow">AC代码：</a></p> 
<p id="7-15%2001%E8%BF%B7%E5%AE%AB%EF%BC%88%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%EF%BC%89-toc" style="margin-left:0px;"><a href="#7-15%2001%E8%BF%B7%E5%AE%AB%EF%BC%88%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%EF%BC%89" rel="nofollow">7-15 01迷宫（广度优先搜索）</a></p> 
<p id="AC%E4%BB%A3%E7%A0%81%EF%BC%9A-toc" style="margin-left:0px;"><a href="#AC%E4%BB%A3%E7%A0%81%EF%BC%9A" rel="nofollow">AC代码：</a></p> 
<p id="7-17%20%E7%94%9F%E5%8C%96%E5%8D%B1%E6%9C%BA%EF%BC%88%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%EF%BC%89-toc" style="margin-left:0px;"><a href="#7-17%20%E7%94%9F%E5%8C%96%E5%8D%B1%E6%9C%BA%EF%BC%88%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%EF%BC%89" rel="nofollow">7-17 生化危机（图的深度优先搜索）</a></p> 
<p id="AC%E4%BB%A3%E7%A0%81%EF%BC%9A-toc" style="margin-left:0px;"><a href="#AC%E4%BB%A3%E7%A0%81%EF%BC%9A" rel="nofollow">AC代码：</a></p> 
<p id="7-18%20%E6%A8%A1%E6%8B%9F%E7%82%B8%E5%BC%B9%E4%BA%BA%EF%BC%88%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%EF%BC%89-toc" style="margin-left:0px;"><a href="#7-18%20%E6%A8%A1%E6%8B%9F%E7%82%B8%E5%BC%B9%E4%BA%BA%EF%BC%88%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%EF%BC%89" rel="nofollow">7-18 模拟炸弹人（广度优先搜索）</a></p> 
<p id="AC%E4%BB%A3%E7%A0%81%EF%BC%9A-toc" style="margin-left:0px;"><a href="#AC%E4%BB%A3%E7%A0%81%EF%BC%9A" rel="nofollow">AC代码：</a></p> 
<p id="7-19%20N%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98%EF%BC%88%E5%9B%9E%E6%BA%AF%EF%BC%89-toc" style="margin-left:0px;"><a href="#7-19%20N%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98%EF%BC%88%E5%9B%9E%E6%BA%AF%EF%BC%89" rel="nofollow">7-19 N皇后问题（回溯）</a></p> 
<p id="AC%E4%BB%A3%E7%A0%81%EF%BC%9A-toc" style="margin-left:0px;"><a href="#AC%E4%BB%A3%E7%A0%81%EF%BC%9A" rel="nofollow">AC代码：</a></p> 
<p id="7-20%20%E5%9B%BE%E7%9D%80%E8%89%B2%E9%97%AE%E9%A2%98%EF%BC%88%E5%9B%BE%E7%9A%84%E5%BA%94%E7%94%A8%EF%BC%89-toc" style="margin-left:0px;"><a href="#7-20%20%E5%9B%BE%E7%9D%80%E8%89%B2%E9%97%AE%E9%A2%98%EF%BC%88%E5%9B%BE%E7%9A%84%E5%BA%94%E7%94%A8%EF%BC%89" rel="nofollow">7-20 图着色问题（图的应用）</a></p> 
<p id="AC%E4%BB%A3%E7%A0%81%EF%BC%9A-toc" style="margin-left:0px;"><a href="#AC%E4%BB%A3%E7%A0%81%EF%BC%9A" rel="nofollow">AC代码：</a></p> 
<p id="7-21%20%E6%8E%92%E5%BA%A7%E4%BD%8D%EF%BC%88%E5%9B%BE%E7%9A%84%E5%BA%94%E7%94%A8%EF%BC%89-toc" style="margin-left:0px;"><a href="#7-21%20%E6%8E%92%E5%BA%A7%E4%BD%8D%EF%BC%88%E5%9B%BE%E7%9A%84%E5%BA%94%E7%94%A8%EF%BC%89" rel="nofollow">7-21 排座位（图的应用）</a></p> 
<p id="AC%E4%BB%A3%E7%A0%81%EF%BC%9A-toc" style="margin-left:0px;"><a href="#AC%E4%BB%A3%E7%A0%81%EF%BC%9A" rel="nofollow">AC代码：</a></p> 
<p id="7-22%20%E7%BA%A2%E8%89%B2%E8%AD%A6%E6%8A%A5%20%EF%BC%88%E5%9B%BE%E7%9A%84%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F%EF%BC%89-toc" style="margin-left:0px;"><a href="#7-22%20%E7%BA%A2%E8%89%B2%E8%AD%A6%E6%8A%A5%20%EF%BC%88%E5%9B%BE%E7%9A%84%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F%EF%BC%89" rel="nofollow">7-22 红色警报 （图的连通分量）</a></p> 
<p id="AC%E4%BB%A3%E7%A0%81%EF%BC%9A-toc" style="margin-left:0px;"><a href="#AC%E4%BB%A3%E7%A0%81%EF%BC%9A" rel="nofollow">AC代码：</a></p> 
<p id="7-23%20%E5%88%97%E5%87%BA%E8%BF%9E%E9%80%9A%E9%9B%86%EF%BC%88%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%2F%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%EF%BC%89-toc" style="margin-left:0px;"><a href="#7-23%20%E5%88%97%E5%87%BA%E8%BF%9E%E9%80%9A%E9%9B%86%EF%BC%88%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%2F%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%EF%BC%89" rel="nofollow">7-23 列出连通集（深度优先搜索/广度优先搜索）</a></p> 
<p id="AC%E4%BB%A3%E7%A0%81%EF%BC%9A-toc" style="margin-left:0px;"><a href="#AC%E4%BB%A3%E7%A0%81%EF%BC%9A" rel="nofollow">AC代码：</a></p> 
<p id="7-25%20%E5%8A%9F%E5%A4%AB%E4%BC%A0%E4%BA%BA%20(%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2)-toc" style="margin-left:0px;"><a href="#7-25%20%E5%8A%9F%E5%A4%AB%E4%BC%A0%E4%BA%BA%20%28%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%29" rel="nofollow">7-25 功夫传人 (广度优先搜索)</a></p> 
<p id="AC%E4%BB%A3%E7%A0%81%EF%BC%9A-toc" style="margin-left:0px;"><a href="#AC%E4%BB%A3%E7%A0%81%EF%BC%9A" rel="nofollow">AC代码：</a></p> 
<p id="7-26%20%E6%B7%B1%E5%85%A5%E8%99%8E%E7%A9%B4%20%EF%BC%88%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%EF%BC%89-toc" style="margin-left:0px;"><a href="#7-26%20%E6%B7%B1%E5%85%A5%E8%99%8E%E7%A9%B4%20%EF%BC%88%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%EF%BC%89" rel="nofollow">7-26 深入虎穴 （广度优先搜索）</a></p> 
<p id="AC%E4%BB%A3%E7%A0%81%EF%BC%9A-toc" style="margin-left:0px;"><a href="#AC%E4%BB%A3%E7%A0%81%EF%BC%9A" rel="nofollow">AC代码：</a></p> 
<p id="7-27%20%E8%82%BF%E7%98%A4%E8%AF%8A%E6%96%AD%20%EF%BC%88%E4%B8%89%E7%BB%B4%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%EF%BC%89-toc" style="margin-left:0px;"><a href="#7-27%20%E8%82%BF%E7%98%A4%E8%AF%8A%E6%96%AD%20%EF%BC%88%E4%B8%89%E7%BB%B4%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%EF%BC%89" rel="nofollow">7-27 肿瘤诊断 （三维广度优先搜索）</a></p> 
<p id="AC%E4%BB%A3%E7%A0%81%EF%BC%9A-toc" style="margin-left:0px;"><a href="#AC%E4%BB%A3%E7%A0%81%EF%BC%9A" rel="nofollow">AC代码：</a></p> 
<hr id="hr-toc"> 
<p>因题集题目较多，上半部分请移步这里：</p> 
<blockquote> 
 <p><a href="https://blog.csdn.net/G_matinal/article/details/128683679?spm=1001.2014.3001.5501" title="算法训练三(DFS、BFS、回溯)(含模板)(上)_清晨喝碗粥的博客-CSDN博客">算法训练三(DFS、BFS、回溯)(含模板)(上)_清晨喝碗粥的博客-CSDN博客</a></p> 
</blockquote> 
<h2 id="7-13%20%E6%A1%A5%E7%9F%AD%E5%87%A0%E4%BD%95%EF%BC%88%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%2B%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%EF%BC%89"><span style="color:#333333;">7-13 桥短几何（深度优先搜索+广度优先搜索）</span></h2> 
<p>在一个NxN的布尔矩阵中，0表示水，1表示陆地，一片由1围成的最大区域就是一个岛，假定方阵中有且只有两个岛，请计算连接这两个岛的最短的桥的长度（架桥相当于翻转0为1，使两个岛相连）。</p> 
<p><strong>输入样例1：</strong></p> 
<p>第一行一个正整数N（取值范围在[2--100]）。<br> 以后N行以空格分隔的0或1，每行N个（0表示水，1表示陆地）。</p> 
<blockquote> 
 <p>3<br> 0 0 1<br> 0 0 1<br> 1 1 0</p> 
</blockquote> 
<p><strong>输出样例1：</strong></p> 
<p>一个表示最短的桥的长度的正整数，本例中，正中间或右下角均是可行方案。</p> 
<blockquote> 
 <p>1</p> 
</blockquote> 
<p><strong>输入样例2：</strong></p> 
<p>第一行一个正整数N（取值范围在[2--100]）。<br> 以后N行以空格分隔的0或1，每行N个（0表示水，1表示陆地）。</p> 
<blockquote> 
 <p>5<br> 1 1 1 1 1<br> 1 0 0 0 0<br> 1 0 0 0 0<br> 1 0 0 0 0<br> 1 0 0 0 1</p> 
</blockquote> 
<p><strong>输出样例2：</strong></p> 
<p>一个表示最短的桥的长度的正整数，本例中，最后一行是可行方案。</p> 
<blockquote> 
 <p>3</p> 
</blockquote> 
<p><strong><span style="color:#333333;">思路：</span></strong><span style="color:#333333;">可以先用深度优先搜索找到一座岛，然后再用广度优先搜索寻找与另一座岛接邻的最短的桥</span> </p> 
<h2 id="AC%E4%BB%A3%E7%A0%81%EF%BC%9A">AC代码：</h2> 
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
vector&lt;pair&lt;int, int&gt;&gt;dirs = {<!-- -->{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
int dfs(vector&lt;vector&lt;int&gt;&gt; &amp;nums) {
    vector&lt;pair&lt;int, int&gt;&gt;temp;
    queue&lt;pair&lt;int, int&gt;&gt;Q;
    int i, j, k, n;
    for (i = 0; i &lt; nums.size(); i++) {
        for (j = 0; j &lt; nums.size(); j++) {
            if (nums[i][j] == 1) {
                nums[i][j] = -1;
                Q.push(pair&lt;int, int&gt;(i, j));
                while (!Q.empty()) {
                    int new_x, new_y;
                    temp.push_back(pair&lt;int, int&gt;(Q.front().first, Q.front().second));
                    for (auto &amp; dir : dirs) {
                        new_x = Q.front().first + dir.first;
                        new_y = Q.front().second + dir.second;
                        if (new_x &gt;= 0 &amp;&amp; new_x &lt; nums.size() &amp;&amp; new_y &gt;= 0 &amp;&amp; new_y &lt; nums.size() &amp;&amp; nums[new_x][new_y] == 1) {
                            Q.push(pair&lt;int, int&gt;(new_x, new_y));
                            nums[new_x][new_y] = -1;
                        }
                    }
                    Q.pop();
                }
                for (auto &amp; a : temp) {
                    Q.push(pair&lt;int, int&gt;(a.first, a.second));
                }
                int step = 0;
                while (!Q.empty()) {
                    int size = Q.size();
                    for (k = 0; k &lt; size; k++) {
                        int x = Q.front().first;
                        int y = Q.front().second;
                        Q.pop();
                        int new_x, new_y;
                        for (auto &amp; dir : dirs) {
                            new_x = x + dir.first;
                            new_y = y + dir.second;
                            if (new_x &gt;= 0 &amp;&amp; new_x &lt; nums.size() &amp;&amp; new_y &gt;= 0 &amp;&amp; new_y &lt; nums.size()) {
                                if (nums[new_x][new_y] == 0) {
                                    Q.push(pair&lt;int, int&gt;(new_x, new_y));
                                    nums[new_x][new_y] = -1;
                                } else if (nums[new_x][new_y] == 1) {
                                    return step;
                                }
                            }
                        }
                    }
                    step++;
                }
            }
        }
    }
    return 0;
}
int main()
{
    int i, j, k, n;
    cin &gt;&gt; n;
    vector&lt;vector&lt;int&gt;&gt;nums(n, vector&lt;int&gt;(n, 0));
    for (i = 0; i &lt; n; i++) {
        for (j = 0; j &lt; n; j++) {
            cin &gt;&gt; nums[i][j];
        }
    }
    cout &lt;&lt; dfs(nums) &lt;&lt; endl;

    system("pause");
    return 0;
}</code></pre> 
<h2 id="7-15%2001%E8%BF%B7%E5%AE%AB%EF%BC%88%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%EF%BC%89" style="margin-left:0px;text-align:justify;"><span style="color:#333333;">7-15 01迷宫（广度优先搜索）</span></h2> 
<p>有一个仅由数字0与1组成的n*n格迷宫。若你位于一格0上，那么你可以移动到相邻4格中的某一格1上，同样若你位于一格1上，那么你可以移动到相邻4格中的某一格0上。</p> 
<p>你的任务是：对于给定的迷宫，询问从某一格开始能移动到多少个格子（包含自身）。</p> 
<p><strong>输入格式：</strong></p> 
<p>第1行为两个正整数n,m。</p> 
<p>下面n行，每行n个字符，字符只可能是0或者1，字符之间没有空格。</p> 
<p>接下来m行，每行2个用空格分隔的正整数i,j，对应了迷宫中第i行第j列的一个格子，询问从这一格开始能移动到多少格。<br> （n &lt;= 1000, m &lt;= 100000）</p> 
<p><strong>输出格式：</strong></p> 
<p>m行，对于每个询问输出相应答案。</p> 
<p><strong>输入样例：</strong></p> 
<blockquote> 
 <p>2 2<br> 01<br> 10<br> 1 1<br> 2 2</p> 
</blockquote> 
<p><strong>输出样例：</strong></p> 
<blockquote> 
 <p>4<br> 4</p> 
</blockquote> 
<h2>AC代码：</h2> 
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
vector&lt;pair&lt;int, int&gt;&gt;dirs = {<!-- -->{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
vector&lt;string&gt;G;
vector&lt;vector&lt;int&gt;&gt;visit;
vector&lt;int&gt;item(100005, 0);
int cur = 1;
typedef struct point {
    int x, y;
}point;
int bfs(int start_x, int start_y) {
    point start;
    start.x = start_x;
    start.y = start_y;
    int step = 1;
    queue&lt;point&gt;Q;
    Q.push(start);
    while (!Q.empty()) {
        int x = Q.front().x;
        int y = Q.front().y;
        int new_x, new_y;
        for (auto &amp; dir : dirs) {
            new_x = x + dir.first;
            new_y = y + dir.second;
            if (new_x &gt;= 0 &amp;&amp; new_x &lt; G.size() &amp;&amp; new_y &gt;= 0 &amp;&amp; new_y &lt; G[0].length() &amp;&amp; visit[new_x][new_y] == 0) {
                if (G[new_x][new_y] == '0' &amp;&amp; G[x][y] == '1' || G[new_x][new_y] == '1' &amp;&amp; G[x][y] == '0') {
                    point temp;
                    temp.x = new_x;
                    temp.y = new_y;
                    step++;
                    visit[new_x][new_y] = cur;
                    Q.push(temp);
                }
            }
        }
        Q.pop();
    }
    item[cur] = step;
    cur++;
    return step;
}
int solve() {
    int start_x, start_y;
    cin &gt;&gt; start_x &gt;&gt; start_y;
    start_x -= 1;
    start_y -= 1;
    if (visit[start_x][start_y] != 0)
        return item[visit[start_x][start_y]];
    visit[start_x][start_y] = cur;
    return bfs(start_x, start_y);
}
int main()
{
    int i, j, k, n, m;
    cin &gt;&gt; n &gt;&gt; m;
    G.resize(n);
    visit.resize(n);
    for (i = 0; i &lt; n; i++) {
        visit[i].resize(n, 0);
    }
    for (i = 0; i &lt; n; i++) {
        cin &gt;&gt; G[i];
    }
    vector&lt;int&gt;res;
    while (m--) {
        res.push_back(solve());
    }
    for (i = 0; i &lt; res.size(); i++) {
        cout &lt;&lt; res[i] &lt;&lt; endl;
    }

    system("pause");
    return 0;
}</code></pre> 
<h2 id="7-17%20%E7%94%9F%E5%8C%96%E5%8D%B1%E6%9C%BA%EF%BC%88%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%EF%BC%89" style="margin-left:0px;text-align:justify;"><span style="color:#333333;">7-17 生化危机（图的深度优先搜索）</span></h2> 
<p>人类正在经历一场生化危机，许多城市已经被病毒侵袭，这些城市中的人们为了避免感染病毒，计划开车逃往其他没有被病毒入侵的城市（安全城市）。有些城市之间有公路直达，有些没有。虽然他们知道哪些城市是安全的，但是不知道有没有一条安全路径能够到达安全城市（只有该路径上经过的所有城市都是安全的，该路径才是安全路径）。请你编写一个程序帮助他们判断。</p> 
<p><strong>输入格式：</strong></p> 
<p>输入第一行为三个正整数，分别表示所有城市个数m（m&lt;=100）、安全城市个数n（m&lt;=50）、公路个数k（k&lt;=100）。随后一行给出n个安全城市的编号。随后k行，每一行给出两个整数，表示连接一条公路的两个城市编号。最后一行输入两个整数，分别表示当前所在城市s、目标城市d。每行整数之间都用空格分隔。</p> 
<p><strong>输出格式：</strong></p> 
<p>若目标城市已被病毒入侵（非安全城市），输出"The city i is not safe!"；若目标城市为安全城市且从当前所在城市能够经过一条安全路径到达目标城市，输出"The city can arrive safely！"；若目标城市为安全城市但是从当前所在城市没有一条安全路径到达目标城市，输出"The city can not arrive safely！"，i为目标城市编号。</p> 
<p><strong>输入样例1：</strong></p> 
<blockquote> 
 <p>5 2 5<br> 3 4<br> 0 1<br> 0 2<br> 0 4<br> 1 2<br> 2 4<br> 0 4</p> 
</blockquote> 
<p><strong>输出样例1：</strong></p> 
<blockquote> 
 <p>The city 4 can arrive safely!</p> 
</blockquote> 
<p><strong>输入样例2：</strong></p> 
<blockquote> 
 <p>5 2 5<br> 3 4<br> 0 1<br> 0 2<br> 0 4<br> 1 2<br> 2 4<br> 0 3</p> 
</blockquote> 
<p><strong>输出样例2：</strong></p> 
<blockquote> 
 <p>The city 3 can not arrive safely!</p> 
</blockquote> 
<p><strong>输入样例3：</strong></p> 
<blockquote> 
 <p>5 2 5<br> 3 4<br> 0 1<br> 0 2<br> 0 4<br> 1 2<br> 2 4<br> 0 1</p> 
</blockquote> 
<p><strong>输出样例3： </strong></p> 
<blockquote> 
 <p>The city 1 is not safe!</p> 
</blockquote> 
<p><strong> </strong><span style="color:#333333;"><strong>思路：</strong>用safe数组保存每个地点是否是安全城市，然后对图进行深度优先搜索即可，如果城市安全且没走过则递归调用</span></p> 
<h2>AC代码：</h2> 
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
vector&lt;vector&lt;int&gt;&gt;G;
vector&lt;bool&gt;visit;
vector&lt;bool&gt;safe;
bool flag = false;
void dfs(int start, int end) {
    if (start == end)
        flag = true;
    visit[start] = true;
    for (auto &amp; a : G[start]) {
        if (safe[a] &amp;&amp; visit[a] == false)
            dfs(a, end);
    }
}
int main()
{
    int i, j, k, n, m;
    cin &gt;&gt; m &gt;&gt; n &gt;&gt; k;
    G.resize(m);
    visit.resize(m, false);
    safe.resize(m, false);
    for (i = 0; i &lt; n; i++) {
        int x, y;
        cin &gt;&gt; x;
        safe[x] = true;
    }
    for (i = 0; i &lt; k; i++) {
        int city1, city2;
        cin &gt;&gt; city1 &gt;&gt; city2;
        G[city1].push_back(city2);
        G[city2].push_back(city1);
    }
    int start, end;
    cin &gt;&gt; start &gt;&gt; end;
    if (safe[end] == false)
        cout &lt;&lt; "The city " &lt;&lt; end &lt;&lt;" is not safe!" &lt;&lt; endl;
    else {
        dfs(start, end);
        if (flag)
            cout &lt;&lt; "The city " &lt;&lt; end &lt;&lt; " can arrive safely!" &lt;&lt; endl;
        else
            cout &lt;&lt; "The city " &lt;&lt; end &lt;&lt; " can not arrive safely!" &lt;&lt; endl;
    }

    system("pause");
    return 0;
}</code></pre> 
<h2 id="7-18%20%E6%A8%A1%E6%8B%9F%E7%82%B8%E5%BC%B9%E4%BA%BA%EF%BC%88%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%EF%BC%89" style="margin-left:0px;text-align:justify;"><span style="color:#333333;">7-18 模拟炸弹人（广度优先搜索）</span></h2> 
<blockquote> 
 <p><span style="color:#333333;">《炸弹人》是HUDSON出品的一款ACT类型游戏，经典的第一作登陆在FC版本，游戏于1983年发行。游戏具体操作是一个机器人放置炸弹来炸死敌人，但也可以炸死自己，还有些增强威力与技能道具增加了游戏的可玩性。<br>     接下来我们就对《炸弹人》进行一次简化模拟：</span></p> 
</blockquote> 
<p>首先我们需要一个 N×M 大小的矩阵来存放地图，矩阵中 '*' 代表没有点燃的炸弹，‘0’代表空地，玩家可以自定义炸弹的威力为 p （由于我们是简化模拟，所以 p 只会取 1 或者 2 ）；像《炸弹人》一样，炸弹可以引发自己上、下、左、右（<strong>斜角不算</strong>）各 p 格范围内产生爆炸，并且爆炸可以产生连锁反应，问至少需要进行几次引爆才可以让所有的炸弹都爆炸。</p> 
<p>例如：<br> 在 5×7 的矩阵</p> 
<p style="text-align:center;"> <img alt="" class="left" height="178" src="https://images2.imgbox.com/f0/72/l9K1QFQk_o.png" width="258"></p> 
<p> 中，当玩家把炸弹的威力 p 设为 1 时至少需要进行 4 次引爆，</p> 
<p>而当玩家把炸弹的威力 p 设为 2 时至少需要进行 3 次引爆。</p> 
<p><strong>输入格式：</strong></p> 
<p>在第一行定义矩阵的大小 n,m,1≤n,m≤10^3 和炸弹的威力 p,p∈{1,2}，数字之间用空格隔开</p> 
<p>随后 n 行是由‘0’和‘*’两种字符组成的 n×m 矩阵，字符之间用空格隔开。</p> 
<p><strong>输出格式：</strong></p> 
<p>在一行中输出至少需要进行几次引爆可以让所有的炸弹都爆炸。</p> 
<p><strong>输入样例1：</strong></p> 
<blockquote> 
 <p>5 7 1<br> 0 0 * * 0 0 0<br> 0 0 * 0 0 0 0<br> 0 0 0 0 0 * 0<br> 0 * * 0 0 0 0<br> 0 0 0 * 0 0 0</p> 
</blockquote> 
<p><strong>输出样例1：</strong></p> 
<blockquote> 
 <p>4</p> 
</blockquote> 
<p><strong>输入样例2：</strong></p> 
<blockquote> 
 <p>5 7 2<br> 0 0 * * 0 0 0<br> 0 0 * 0 0 0 0<br> 0 0 0 0 0 * 0<br> 0 * * 0 0 0 0<br> 0 0 0 * 0 0 0</p> 
</blockquote> 
<p><strong>输出样例2：</strong></p> 
<blockquote> 
 <p>3</p> 
</blockquote> 
<h2>AC代码：</h2> 
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
vector&lt;vector&lt;char&gt;&gt;G;
typedef struct point {
    int x, y;
}point;
void bfs(int start_x, int start_y, int p) {
    point start;
    start.x = start_x;
    start.y = start_y;
    queue&lt;point&gt;Q;
    Q.push(start);
    while (!Q.empty()) {
        int i, j;
        int x = Q.front().x;
        int y = Q.front().y;
        for (i = x - p; i &lt;= x + p; i++) {
            for (j = y - p; j &lt;= y + p; j++) {
                if (i &gt;= 0 &amp;&amp; i &lt; G.size() &amp;&amp; j &gt;= 0 &amp;&amp; j &lt; G[0].size() &amp;&amp; G[i][j] == '*' &amp;&amp; (i == x || j == y)) {
                    G[i][j] = '#';
                    point temp;
                    temp.x = i;
                    temp.y = j;
                    Q.push(temp);
                }
            }
        }
        Q.pop();
    }
}
int main()
{
    int i, j, n, m, p, count = 0;
    cin &gt;&gt; n &gt;&gt; m &gt;&gt; p;
    G.resize(n);
    for (i = 0; i &lt; n; i++) {
        G[i].resize(m);
        for (j = 0; j &lt; m; j++) {
            cin &gt;&gt; G[i][j];
        }
    }
    for (i = 0; i &lt; n; i++) {
        for (j = 0; j &lt; m; j++) {
            if (G[i][j] == '*') {
                G[i][j] = '#';
                bfs(i, j, p);
                count++;
            }
        }
    }
    cout &lt;&lt; count &lt;&lt; endl;

    system("pause");
    return 0;
}</code></pre> 
<h2 id="7-19%20N%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98%EF%BC%88%E5%9B%9E%E6%BA%AF%EF%BC%89" style="margin-left:0px;text-align:justify;"><span style="color:#333333;">7-19 N皇后问题（回溯）</span></h2> 
<p>在N×N格的国际象棋盘上摆放N个皇后，使其不能互相攻击，即任意两个皇后都不能处于同一行、同一列或同一斜线上，对于给定的N，求出有多少种合法的放置方法。</p> 
<p style="text-align:center;"><img alt="" class="left" height="222" src="https://images2.imgbox.com/dc/ce/2jrqwPYw_o.png" width="224"></p> 
<p><strong>输入格式：</strong></p> 
<p>一个正整数N≤10，表示棋盘和皇后的数量；</p> 
<p><strong>输出格式：</strong></p> 
<p>一个正整数，表示对应输入行的皇后的不同放置方法。</p> 
<p><strong>输入样例：</strong></p> 
<blockquote> 
 <p>8</p> 
</blockquote> 
<p><strong>输出样例：</strong></p> 
<blockquote> 
 <p>92</p> 
</blockquote> 
<h2>AC代码：</h2> 
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
vector&lt;vector&lt;int&gt;&gt;G;
bool isvalid(int row, int col, int n) {
    int i, j;
    for (i = 0; i &lt; row; i++) {
        if (G[i][col] == 1)
            return false;
    }
    for (i = row - 1, j = col - 1; i &gt;= 0 &amp;&amp; j &gt;= 0; i--, j--) {
        if (G[i][j] == 1)
            return false;
    }
    for (i = row - 1, j = col + 1; i &gt;= 0 &amp;&amp; j &lt; n; i--, j++) {
        if (G[i][j] == 1)
            return false;
    }
    return true;
}
void backtracking(int row, int n, int &amp;count) {
    if (row == n) {
        count++;
        return;
    }
    for (int col = 0; col &lt; n; col++) {
        if (isvalid(row, col, n)) {
            G[row][col] = 1;
            backtracking(row + 1, n, count);
            G[row][col] = 0;
        }
    }
}
int main()
{
    int i, n, count = 0;
    cin &gt;&gt; n;
    G.resize(n, vector&lt;int&gt;(n, 0));
    backtracking(0, n, count);
    cout &lt;&lt; count &lt;&lt; endl;

    system("pause");
    return 0;
}</code></pre> 
<h2 id="7-20%20%E5%9B%BE%E7%9D%80%E8%89%B2%E9%97%AE%E9%A2%98%EF%BC%88%E5%9B%BE%E7%9A%84%E5%BA%94%E7%94%A8%EF%BC%89" style="margin-left:0px;text-align:justify;"><span style="color:#333333;">7-20 图着色问题（图的应用）</span></h2> 
<p>图着色问题是一个著名的NP完全问题。给定无向图G=(V,E)，问可否用K种颜色为V中的每一个顶点分配一种颜色，使得不会有两个相邻顶点具有同一种颜色？</p> 
<p>但本题并不是要你解决这个着色问题，而是对给定的一种颜色分配，请你判断这是否是图着色问题的一个解。</p> 
<p><strong>输入格式：</strong></p> 
<p>输入在第一行给出3个整数V（0&lt;V≤500）、E（≥0）和K（0&lt;K≤V），分别是无向图的顶点数、边数、以及颜色数。顶点和颜色都从1到V编号。随后E行，每行给出一条边的两个端点的编号。在图的信息给出之后，给出了一个正整数N（≤20），是待检查的颜色分配方案的个数。随后N行，每行顺次给出V个顶点的颜色（第i个数字表示第i个顶点的颜色），数字间以空格分隔。题目保证给定的无向图是合法的（即不存在自回路和重边）。</p> 
<p><strong>输出格式：</strong></p> 
<p>对每种颜色分配方案，如果是图着色问题的一个解则输出<code>Yes</code>，否则输出<code>No</code>，每句占一行。</p> 
<p><strong>输入样例：</strong></p> 
<blockquote> 
 <p>6 8 3<br> 2 1<br> 1 3<br> 4 6<br> 2 5<br> 2 4<br> 5 4<br> 5 6<br> 3 6<br> 4<br> 1 2 3 3 1 2<br> 4 5 6 6 4 5<br> 1 2 3 4 5 6<br> 2 3 4 2 3 4</p> 
</blockquote> 
<p><strong>输出样例：</strong></p> 
<blockquote> 
 <p>Yes<br> Yes<br> No<br> No</p> 
</blockquote> 
<p style="margin-left:0;text-align:justify;"><span style="color:#333333;"><strong>思路：</strong>1、用map存储方案中的每个节点的颜色</span></p> 
<p style="margin-left:0;text-align:justify;"><span style="color:#333333;">           2、用set进行计数，若与顶点数不相等或颜色数字大于顶点个数则为NO</span></p> 
<p style="margin-left:0;text-align:justify;"><span style="color:#333333;">           3、对每个顶点周围的点进行遍历，若有邻接的两个色块颜色相同则为NO</span></p> 
<p style="margin-left:0;text-align:justify;"><span style="color:#333333;">           4、其他情况则是YES</span></p> 
<h2>AC代码：</h2> 
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
vector&lt;vector&lt;int&gt;&gt;G;
string solve(map&lt;int, int&gt; &amp;mp) {
    int i, j, n;
    for (i = 1; i &lt; G.size(); i++) {
        for (j = 0; j &lt; G[i].size(); j++) {
            if (mp[G[i][j]] == mp[i])
                return "No";
        }
    }
    return "Yes";
}
int main()
{
    int i, j, k, n, v, e, x;
    cin &gt;&gt; v &gt;&gt; e &gt;&gt; k;
    G.resize(v + 1);
    for (i = 0; i &lt; e; i++) {
        int edge1, edge2;
        cin &gt;&gt; edge1 &gt;&gt; edge2;
        G[edge1].push_back(edge2);
        G[edge2].push_back(edge1);
    }
    cin &gt;&gt; n;
    vector&lt;string&gt;res;
    while (n--) {
        map&lt;int, int&gt;mp;
        set&lt;int&gt;st;
        for (i = 1; i &lt;= v; i++) {
            cin &gt;&gt; x;
            mp[i] = x;
            st.insert(x);
        }
        if (st.size() != k || *st.rbegin() &gt; v)
            res.push_back("No");
        else
            res.push_back(solve(mp));
    }
    for (i = 0; i &lt; res.size(); i++) {
        cout &lt;&lt; res[i] &lt;&lt; endl;
    }


    system("pause");
    return 0;
}</code></pre> 
<h2 id="7-21%20%E6%8E%92%E5%BA%A7%E4%BD%8D%EF%BC%88%E5%9B%BE%E7%9A%84%E5%BA%94%E7%94%A8%EF%BC%89" style="margin-left:0px;text-align:justify;"><span style="color:#333333;">7-21 排座位（图的应用）</span></h2> 
<p>布置宴席最微妙的事情，就是给前来参宴的各位宾客安排座位。无论如何，总不能把两个死对头排到同一张宴会桌旁！这个艰巨任务现在就交给你，对任何一对客人，请编写程序告诉主人他们是否能被安排同席。</p> 
<p><strong>输入格式：</strong></p> 
<p>输入第一行给出3个正整数：<code>N</code>（≤100），即前来参宴的宾客总人数，则这些人从1到<code>N</code>编号；<code>M</code>为已知两两宾客之间的关系数；<code>K</code>为查询的条数。随后<code>M</code>行，每行给出一对宾客之间的关系，格式为：<code>宾客1 宾客2 关系</code>，其中<code>关系</code>为1表示是朋友，-1表示是死对头。注意两个人不可能既是朋友又是敌人。最后<code>K</code>行，每行给出一对需要查询的宾客编号。</p> 
<p>这里假设朋友的朋友也是朋友。但敌人的敌人并不一定就是朋友，朋友的敌人也不一定是敌人。只有单纯直接的敌对关系才是绝对不能同席的。</p> 
<p><strong>输出格式：</strong></p> 
<p>对每个查询输出一行结果：如果两位宾客之间是朋友，且没有敌对关系，则输出<code>No problem</code>；如果他们之间并不是朋友，但也不敌对，则输出<code>OK</code>；如果他们之间有敌对，然而也有共同的朋友，则输出<code>OK but...</code>；如果他们之间只有敌对关系，则输出<code>No way</code>。</p> 
<p><strong>输入样例：</strong></p> 
<blockquote> 
 <p>7 8 4<br> 5 6 1<br> 2 7 -1<br> 1 3 1<br> 3 4 1<br> 6 7 -1<br> 1 2 1<br> 1 4 1<br> 2 3 -1<br> 3 4<br> 5 7<br> 2 3<br> 7 2</p> 
</blockquote> 
<p><strong>输出样例：</strong></p> 
<blockquote> 
 <p>No problem<br> OK<br> OK but...<br> No way</p> 
</blockquote> 
<p><strong> </strong><span style="color:#333333;"><strong>思路：</strong>按题目要求输出即可，当两个人是死对头的时候要对图进行遍历，看是否纯在共同朋友关系，最后对应输出</span></p> 
<h2>AC代码：</h2> 
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
vector&lt;vector&lt;int&gt;&gt;G;
string solve() {
    int i, peo1, peo2;
    cin &gt;&gt; peo1 &gt;&gt; peo2;
    if (G[peo1][peo2] == 1)
        return "No problem";
    if (G[peo1][peo2] == 0)
        return "OK";
    if (G[peo1][peo2] == -1) {
        for (i = 1; i &lt; G.size(); i++) {
            if (G[i][peo1] &amp;&amp; G[i][peo2])
                return "OK but...";
        }
    }
    return "No way";
}
int main()
{
    int i, j, k, n, m;
    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;
    G.resize(n + 1, vector&lt;int&gt;(n + 1, 0));
    for (i = 0; i &lt; m; i++) {
        int peo1, peo2, flag;
        cin &gt;&gt; peo1 &gt;&gt; peo2 &gt;&gt; flag;
        G[peo1][peo2] = flag;
        G[peo2][peo1] = flag;
    }
    vector&lt;string&gt;res;
    while (k--) {
        res.push_back(solve());
    }
    for (i = 0; i &lt; res.size(); i++) {
        cout &lt;&lt; res[i] &lt;&lt; endl;
    }

    system("pause");
    return 0;
}</code></pre> 
<h2 id="7-22%20%E7%BA%A2%E8%89%B2%E8%AD%A6%E6%8A%A5%20%EF%BC%88%E5%9B%BE%E7%9A%84%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F%EF%BC%89" style="margin-left:0px;text-align:justify;"><span style="color:#333333;">7-22 红色警报</span> <span style="color:#333333;">（图的连通分量）</span></h2> 
<p>战争中保持各个城市间的连通性非常重要。本题要求你编写一个报警程序，当失去一个城市导致国家被分裂为多个无法连通的区域时，就发出红色警报。注意：若该国本来就不完全连通，是分裂的k个区域，而失去一个城市并不改变其他城市之间的连通性，则不要发出警报。</p> 
<p><strong>输入格式：</strong></p> 
<p>输入在第一行给出两个整数<code>N</code>（0 &lt; <code>N</code> ≤ 500）和<code>M</code>（≤ 5000），分别为城市个数（于是默认城市从0到<code>N</code>-1编号）和连接两城市的通路条数。随后<code>M</code>行，每行给出一条通路所连接的两个城市的编号，其间以1个空格分隔。在城市信息之后给出被攻占的信息，即一个正整数<code>K</code>和随后的<code>K</code>个被攻占的城市的编号。</p> 
<p>注意：输入保证给出的被攻占的城市编号都是合法的且无重复，但并不保证给出的通路没有重复。</p> 
<p><strong>输出格式：</strong></p> 
<p>对每个被攻占的城市，如果它会改变整个国家的连通性，则输出<code>Red Alert: City k is lost!</code>，其中<code>k</code>是该城市的编号；否则只输出<code>City k is lost.</code>即可。如果该国失去了最后一个城市，则增加一行输出<code>Game Over.</code>。</p> 
<p><strong>输入样例：</strong></p> 
<blockquote> 
 <p>5 4<br> 0 1<br> 1 3<br> 3 0<br> 0 4<br> 5<br> 1 2 0 4 3</p> 
</blockquote> 
<p><strong>输出样例：</strong></p> 
<blockquote> 
 <p>City 1 is lost.<br> City 2 is lost.<br> Red Alert: City 0 is lost!<br> City 4 is lost.<br> City 3 is lost.<br> Game Over.</p> 
</blockquote> 
<p><span style="color:#333333;"><strong>思路：</strong>先用一次深度优先搜索计算出连通分量，然后将被攻占的区域重新赋值为不连通（即图没有相应的边连通），最后在用一次深度优先搜索计算被攻占后的连通分量，然后进行对比，如果连通分量增加了，那么攻占的城市是会改变国家的连通性，失去最后一个城市利用数量进行判断即可</span> </p> 
<h2>AC代码：</h2> 
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
vector&lt;vector&lt;int&gt;&gt;G;
vector&lt;bool&gt;visit;
void dfs(int u) {
    visit[u] = true;
    for (int i = 0; i &lt; G.size(); i++) {
        if (G[i][u] == 1 &amp;&amp; visit[i] == false) 
            dfs(i);
    }
}
void dfs2(vector&lt;bool&gt; &amp;vis, int u) {
    vis[u] = true;
    for (int i = 0; i &lt; G.size(); i++) {
        if (G[i][u] == 1 &amp;&amp; vis[i] == false)
            dfs2(vis, i);
    }
}
int main()
{
    int i, j, k, n, m;
    cin &gt;&gt; n &gt;&gt; m;
    G.resize(n, vector&lt;int&gt;(n, 0));
    visit.resize(n, false);
    for (i = 0; i &lt; m; i++) {
        int city1, city2;
        cin &gt;&gt; city1 &gt;&gt; city2;
        G[city1][city2] = 1;
        G[city2][city1] = 1;
    }
    cin &gt;&gt; k;
    vector&lt;int&gt;nums(k, 0);
    for (i = 0; i &lt; k; i++) {
        cin &gt;&gt; nums[i];
    }
    int count1 = 0, count2;
    for (i = 0; i &lt; n; i++) {
        if (visit[i] == false) {
            dfs(i);
            count1++;
        }
    }
    for (i = 0; i &lt; nums.size(); i++) {
        vector&lt;bool&gt;vis(n, false);
        count2 = 0;
        for (j = 0; j &lt; G.size(); j++) {
            G[nums[i]][j] = 0;
            G[j][nums[i]] = 0;
        }
        for (j = 0; j &lt;= i; j++) {
            vis[nums[j]] = true;
        }
        for (j = 0; j &lt; n; j++) {
            if (vis[j] == false) {
                dfs2(vis, j);
                count2++;
            }
        }
        if (count2 &gt; count1)
            cout &lt;&lt; "Red Alert: City " &lt;&lt; nums[i] &lt;&lt;" is lost!" &lt;&lt; endl;
        else
            cout &lt;&lt; "City " &lt;&lt; nums[i] &lt;&lt; " is lost." &lt;&lt; endl;
        count1 = count2;
    }
    if (k == n)
        cout &lt;&lt; "Game Over." &lt;&lt; endl;

    system("pause");
    return 0;
}</code></pre> 
<h2 id="7-23%20%E5%88%97%E5%87%BA%E8%BF%9E%E9%80%9A%E9%9B%86%EF%BC%88%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%2F%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%EF%BC%89" style="margin-left:0px;text-align:justify;"><span style="color:#333333;">7-23 列出连通集（深度优先搜索/广度优先搜索）</span></h2> 
<p>给定一个有N个顶点和E条边的无向图，请用DFS和BFS分别列出其所有的连通集。假设顶点从0到N−1编号。进行搜索时，假设我们总是从编号最小的顶点出发，按编号递增的顺序访问邻接点。</p> 
<p><strong>输入格式：</strong></p> 
<p>输入第1行给出2个整数N(0&lt;N≤10)和E，分别是图的顶点数和边数。随后E行，每行给出一条边的两个端点。每行中的数字之间用1空格分隔。</p> 
<p><strong>输出格式：</strong></p> 
<p>按照"{ v1​ v2​ ... vk​ }"的格式，每行输出一个连通集。先输出DFS的结果，再输出BFS的结果。</p> 
<p><strong>输入样例：</strong></p> 
<blockquote> 
 <p>8 6<br> 0 7<br> 0 1<br> 2 0<br> 4 1<br> 2 4<br> 3 5</p> 
</blockquote> 
<p><strong>输出样例：</strong></p> 
<blockquote> 
 <p>{ 0 1 4 2 7 }<br> { 3 5 }<br> { 6 }<br> { 0 1 2 7 4 }<br> { 3 5 }<br> { 6 }</p> 
</blockquote> 
<p style="margin-left:0;text-align:justify;"><span style="background-color:#FFFFFF;"><strong>思路：</strong>相应的利用深搜和广搜即可，具体写法可以看代码</span></p> 
<h2>AC代码：</h2> 
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
vector&lt;vector&lt;int&gt;&gt;G;
vector&lt;bool&gt;visit1, visit2;
void dfs(vector&lt;int&gt; &amp;v, int u) {
    visit1[u] = true;
    v.push_back(u);
    for (int i = 0; i &lt; G.size(); i++) {
        if (visit1[i] == false &amp;&amp; G[i][u] == 1) 
            dfs(v, i);
    }
}
void bfs(vector&lt;int&gt; &amp;v, int u) {
    queue&lt;int&gt;Q;
    Q.push(u);
    visit2[u] = true;
    while (!Q.empty()) {
        int index = Q.front();
        v.push_back(index);
        for (int i = 0; i &lt; G.size(); i++) {
            if (G[i][index] == 1 &amp;&amp; visit2[i] == false) {
                Q.push(i);
                visit2[i] = true;
            }
        }
        Q.pop();
    }
}
int main()
{
    int i, j, k, n, m;
    cin &gt;&gt; n &gt;&gt; m;
    vector&lt;vector&lt;int&gt;&gt;res1, res2;
    G.resize(n, vector&lt;int&gt;(n, 0));
    visit1.resize(n, false);
    visit2.resize(n, false);
    for (i = 0; i &lt; m; i++) {
        int u1, u2;
        cin &gt;&gt; u1 &gt;&gt; u2;
        G[u1][u2] = 1;
        G[u2][u1] = 1;
    }
    for (i = 0; i &lt; n; i++) {
        vector&lt;int&gt;v;
        if (visit1[i] == false) {
            dfs(v, i);
            res1.push_back(v);
        }
    }
    for (i = 0; i &lt; n; i++) {
        vector&lt;int&gt;v;
        if (visit2[i] == false) {
            bfs(v, i);
            res2.push_back(v);
        }
    }
    for (i = 0; i &lt; res1.size(); i++) {
        cout &lt;&lt; "{";
        for (j = 0; j &lt; res1[i].size(); j++) {
            cout &lt;&lt; " " &lt;&lt; res1[i][j];
        }
        cout &lt;&lt; " }" &lt;&lt; endl;
    }
    for (i = 0; i &lt; res2.size(); i++) {
        cout &lt;&lt; "{";
        for (j = 0; j &lt; res2[i].size(); j++) {
            cout &lt;&lt; " " &lt;&lt; res2[i][j];
        }
        cout &lt;&lt; " }" &lt;&lt; endl;
    }

    system("pause");
    return 0;
}</code></pre> 
<h2 id="7-25%20%E5%8A%9F%E5%A4%AB%E4%BC%A0%E4%BA%BA%20(%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2)" style="margin-left:0px;text-align:justify;"><span style="color:#333333;">7-25 功夫传人 (广度优先搜索)</span></h2> 
<p>一门武功能否传承久远并被发扬光大，是要看缘分的。一般来说，师傅传授给徒弟的武功总要打个折扣，于是越往后传，弟子们的功夫就越弱…… 直到某一支的某一代突然出现一个天分特别高的弟子（或者是吃到了灵丹、挖到了特别的秘笈），会将功夫的威力一下子放大N倍 —— 我们称这种弟子为“得道者”。</p> 
<p>这里我们来考察某一位祖师爷门下的徒子徒孙家谱：假设家谱中的每个人只有1位师傅（除了祖师爷没有师傅）；每位师傅可以带很多徒弟；并且假设辈分严格有序，即祖师爷这门武功的每个第<code>i</code>代传人只能在第<code>i-1</code>代传人中拜1个师傅。我们假设已知祖师爷的功力值为<code>Z</code>，每向下传承一代，就会减弱<code>r%</code>，除非某一代弟子得道。现给出师门谱系关系，要求你算出所有得道者的功力总值。</p> 
<p><strong>输入格式：</strong></p> 
<p>输入在第一行给出3个正整数，分别是：N（≤105）——整个师门的总人数（于是每个人从0到N−1编号，祖师爷的编号为0）；Z——祖师爷的功力值（不一定是整数，但起码是正数）；r ——每传一代功夫所打的折扣百分比值（不超过100的正数）。接下来有N行，第i行（i=0,⋯,N−1）描述编号为i的人所传的徒弟，格式为：</p> 
<p>Ki​ ID[1] ID[2] ⋯ ID[Ki​]</p> 
<p>其中Ki​是徒弟的个数，后面跟的是各位徒弟的编号，数字间以空格间隔。Ki​为零表示这是一位得道者，这时后面跟的一个数字表示其武功被放大的倍数。</p> 
<p><strong>输出格式：</strong></p> 
<p>在一行中输出所有得道者的功力总值，只保留其整数部分。题目保证输入和正确的输出都不超过1010。</p> 
<p><strong>输入样例：</strong></p> 
<blockquote> 
 <p>10 18.0 1.00<br> 3 2 3 5<br> 1 9<br> 1 4<br> 1 7<br> 0 7<br> 2 6 1<br> 1 8<br> 0 9<br> 0 4<br> 0 3</p> 
</blockquote> 
<p><strong>输出样例：</strong></p> 
<blockquote> 
 <p>404</p> 
</blockquote> 
<p><span style="color:#333333;"><strong>思路：</strong>利用map嵌套vector来构造这样的一个多叉树结构，我们把每个子树的根节点设置为判断节点如果小于0则为得道者，利用bfs对每一层进行遍历，每遍历一层武功都要折扣，直到遇见得道者，将得道者的武功放大相应求和即可，这里需要注意以下祖师爷有可能也是得道者所以优先判断一下</span> </p> 
<h2>AC代码：</h2> 
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
map&lt;int, vector&lt;int&gt;&gt;mp;
double bfs(double z, double r) {
    int i, j, k, n;
    double res = 0;
    queue&lt;int&gt;Q;
    if (mp[0][0] &lt; 0)
        return (int)(z * fabs(mp[0][0]));
    for (i = 0; i &lt; mp[0].size(); i++) {
        Q.push(mp[0][i]);
    }
    while (!Q.empty()) {
        int size = Q.size();
        z -= (z * 1.0 * r / 100);
        while (size--) {
            if (mp.find(Q.front()) != mp.end() &amp;&amp; mp[Q.front()][0] &lt; 0) {
                res += z * 1.0 * fabs(mp[Q.front()][0]);
                mp[Q.front()][0] = -1;
            }
            if (mp.find(Q.front()) != mp.end() &amp;&amp; mp[Q.front()][0] != -1) {
                for (i = 0; i &lt; mp[Q.front()].size(); i++) {
                    Q.push(mp[Q.front()][i]);
                }                
            }
            Q.pop();
        }
    }
    return res;
}
int main()
{
    int i, j, n, res = 0;
    double z, r;
    cin &gt;&gt; n &gt;&gt; z &gt;&gt; r;
    for (i = 0; i &lt; n; i++) {
        int k;
        cin &gt;&gt; k;
        for (j = 0; j &lt; k; j++) {
            int x;
            cin &gt;&gt; x;
            mp[i].push_back(x);
        }
        if (k == 0) {
            int x;
            cin &gt;&gt; x;
            mp[i].push_back(-x);
        }
    }

    res = (int)bfs(z, r);
    cout &lt;&lt; res &lt;&lt; endl;

    system("pause");
    return 0;
}</code></pre> 
<h2 id="7-26%20%E6%B7%B1%E5%85%A5%E8%99%8E%E7%A9%B4%20%EF%BC%88%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%EF%BC%89" style="margin-left:0px;text-align:justify;"><span style="color:#333333;">7-26 深入虎穴</span> <span style="color:#333333;">（广度优先搜索）</span></h2> 
<p>著名的王牌间谍 007 需要执行一次任务，获取敌方的机密情报。已知情报藏在一个地下迷宫里，迷宫只有一个入口，里面有很多条通路，每条路通向一扇门。每一扇门背后或者是一个房间，或者又有很多条路，同样是每条路通向一扇门…… 他的手里有一张表格，是其他间谍帮他收集到的情报，他们记下了每扇门的编号，以及这扇门背后的每一条通路所到达的门的编号。007 发现不存在两条路通向同一扇门。</p> 
<p>内线告诉他，情报就藏在迷宫的最深处。但是这个迷宫太大了，他需要你的帮助 —— 请编程帮他找出距离入口最远的那扇门。</p> 
<p><strong>输入格式：</strong></p> 
<p>输入首先在一行中给出正整数 N（&lt;10^5），是门的数量。最后 N 行，第 i 行（1≤i≤N）按以下格式描述编号为 i 的那扇门背后能通向的门：</p> 
<blockquote> 
 <p>K D[1] D[2] ... D[K]</p> 
</blockquote> 
<p>其中 <code>K</code> 是通道的数量，其后是每扇门的编号。 </p> 
<p><strong>输出格式：</strong></p> 
<p>在一行中输出距离入口最远的那扇门的编号。题目保证这样的结果是唯一的。</p> 
<p><strong>输入样例：</strong></p> 
<blockquote> 
 <p>13<br> 3 2 3 4<br> 2 5 6<br> 1 7<br> 1 8<br> 1 9<br> 0<br> 2 11 10<br> 1 13<br> 0<br> 0<br> 1 12<br> 0<br> 0</p> 
</blockquote> 
<p><strong>输出样例：</strong></p> 
<blockquote> 
 <p>12</p> 
</blockquote> 
<p><span style="color:#333333;"><strong>思路：</strong>利用map嵌套vector构造多叉树，然后对树进行广度优先搜索即可，直到搜索到最远的叶子即最终答案</span> </p> 
<h2>AC代码：</h2> 
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
map&lt;int, vector&lt;int&gt;&gt;mp;
vector&lt;bool&gt;visit;
int bfs() {
    int i, res = 0;
    queue&lt;int&gt;Q;
    for (i = 1; i &lt; visit.size(); i++) {
        if (visit[i] == false) {
            Q.push(i);
            break;
        }
    }
    while (!Q.empty()) {
        res = Q.front();
        if (mp[Q.front()][0] != 0) {
            for (i = 0; i &lt; mp[Q.front()].size(); i++) {
                Q.push(mp[Q.front()][i]);
            }
        }
        Q.pop();
    }
    return res;
}
int main()
{
    int i, j, k, n;
    cin &gt;&gt; n;
    visit.resize(n + 1, false);
    for (i = 1; i &lt;= n; i++) {
        cin &gt;&gt; k;
        if (k == 0)
            mp[i].push_back(0);
        for (j = 0; j &lt; k; j++) {
            int x;
            cin &gt;&gt; x;
            visit[x] = true;
            mp[i].push_back(x);
        }
    }
    cout &lt;&lt; bfs() &lt;&lt; endl;

    system("pause");
    return 0;
}</code></pre> 
<h2 id="7-27%20%E8%82%BF%E7%98%A4%E8%AF%8A%E6%96%AD%20%EF%BC%88%E4%B8%89%E7%BB%B4%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%EF%BC%89" style="margin-left:0px;text-align:justify;"><span style="color:#333333;">7-27 肿瘤诊断</span> <span style="color:#333333;">（三维广度优先搜索）</span></h2> 
<p>在诊断肿瘤疾病时，计算肿瘤体积是很重要的一环。给定病灶扫描切片中标注出的疑似肿瘤区域，请你计算肿瘤的体积。</p> 
<p><strong>输入格式：</strong></p> 
<p>输入第一行给出4个正整数：M、N、L、T，其中M和N是每张切片的尺寸（即每张切片是一个M×N的像素矩阵。最大分辨率是1286×128）；L（≤60）是切片的张数；T是一个整数阈值（若疑似肿瘤的连通体体积小于T，则该小块忽略不计）。</p> 
<p>最后给出L张切片。每张用一个由0和1组成的M×N的矩阵表示，其中1表示疑似肿瘤的像素，0表示正常像素。由于切片厚度可以认为是一个常数，于是我们只要数连通体中1的个数就可以得到体积了。麻烦的是，可能存在多个肿瘤，这时我们只统计那些体积不小于T的。两个像素被认为是“连通的”，如果它们有一个共同的切面，如下图所示，所有6个红色的像素都与蓝色的像素连通。</p> 
<p style="text-align:center;"><img alt="" class="left" height="164" src="https://images2.imgbox.com/9a/5d/w01wyFXs_o.png" width="209"></p> 
<p> <strong>输出格式：</strong></p> 
<p>在一行中输出肿瘤的总体积。</p> 
<p><strong>输入样例：</strong></p> 
<blockquote> 
 <p>3 4 5 2<br> 1 1 1 1<br> 1 1 1 1<br> 1 1 1 1<br> 0 0 1 1<br> 0 0 1 1<br> 0 0 1 1<br> 1 0 1 1<br> 0 1 0 0<br> 0 0 0 0<br> 1 0 1 1<br> 0 0 0 0<br> 0 0 0 0<br> 0 0 0 1<br> 0 0 0 1<br> 1 0 0 0</p> 
</blockquote> 
<p><strong>输出样例：</strong></p> 
<blockquote> 
 <p>26</p> 
</blockquote> 
<p><span style="color:#333333;"><strong>思路：</strong>这道题仔细看一下会发现是三维的，我们用一个三维数组存储即可，然后利用bfs对其每一块肿瘤进行遍历，如果遍历的肿瘤体积小于给定阈值则忽略，否则就加入到结果变量res中</span> </p> 
<h2>AC代码：</h2> 
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt;G;
vector&lt;vector&lt;vector&lt;bool&gt;&gt;&gt;visit;
vector&lt;vector&lt;int&gt;&gt;dirs = {<!-- -->{0, 0, 1}, {0, 0, -1}, {0, 1, 0}, {0, -1, 0}, {1, 0, 0}, {-1, 0, 0}};
typedef struct point{
    int x, y, z;
}point;
int bfs(int i, int j, int k, int t) {
    int volume = 1;
    point start;
    start.x = j;
    start.y = k;
    start.z = i;
    queue&lt;point&gt;Q;
    Q.push(start);
    while (!Q.empty()) {
        int x = Q.front().x;
        int y = Q.front().y;
        int z = Q.front().z;
        int new_x, new_y, new_z;
        for (auto &amp; dir : dirs) {
            new_x = x + dir[0];
            new_y = y + dir[1];
            new_z = z + dir[2];
            if (new_z &gt;= 0 &amp;&amp; new_z &lt; G.size() &amp;&amp; new_x &gt;= 0 &amp;&amp; new_x &lt; G[0].size() &amp;&amp; new_y &gt;= 0 &amp;&amp; new_y &lt; G[0][0].size()) {
                if (G[new_z][new_x][new_y] == 1 &amp;&amp; visit[new_z][new_x][new_y] == false) {
                    visit[new_z][new_x][new_y] = true;
                    point temp;
                    temp.x = new_x;
                    temp.y = new_y;
                    temp.z = new_z;
                    Q.push(temp);
                    volume++;
                }
            }
        }
        Q.pop();
    }
    if (volume &lt; t)
        return 0;
    return volume;
}
int main()
{
    int i, j, k, n, m, l, t, res = 0;
    cin &gt;&gt; m &gt;&gt; n &gt;&gt; l &gt;&gt; t;
    G.resize(l, vector&lt;vector&lt;int&gt;&gt;(m, vector&lt;int&gt;(n, 0)));
    visit.resize(l, vector&lt;vector&lt;bool&gt;&gt;(m, vector&lt;bool&gt;(n, false)));
    for (i = 0; i &lt; l; i++) {
        for (j = 0; j &lt; m; j++) {
            for (k = 0; k &lt; n; k++) {
                cin &gt;&gt; G[i][j][k];
            }
        }
    }
    for (i = 0; i &lt; l; i++) {
        for (j = 0; j &lt; m; j++) {
            for (k = 0; k &lt; n; k++) {
                if (visit[i][j][k] == false &amp;&amp; G[i][j][k] == 1) {
                    visit[i][j][k] = true;
                    res += bfs(i, j, k, t);
                }
            }
        }
    }
    cout &lt;&lt; res &lt;&lt; endl;

    system("pause");
    return 0;
}</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f207d80890883cc7d1659b0974dd43ad/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">VMware虚拟机装win7教程</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/70c2c69e3a868d9dc9c990d1eebd34ac/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">运放指标-压摆率SR</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>