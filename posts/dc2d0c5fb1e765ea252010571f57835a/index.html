<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>WebGL基础与入门示例 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="WebGL基础与入门示例" />
<meta property="og:description" content="我们都知道最新的HTML5中支持了画布操作，可以在上面绘制各种二三维图形图像，相应的H5标签就是&lt;canvas&gt;
二维图形绘制：Canvas API和WebGL API，三维图形绘制：WebGL API。
一.WebGL定义：webgl是一种3D绘图库及框架协议，衍生自OpenGL ES2.0，可结合H5和js实现在web端进行二三维图形的渲染和交互，未来支持可穿戴设备的沉浸式渲染交互。
二.WebGL用途：主要应用于数据可视化，图形可视化引擎或在线游戏引擎。
三.WebGL优势：
1.内置在任意浏览器中，几乎每台电子产品都都相应的浏览器支持，无需安装任何插件。
2.几乎不需要任何编程环境，可以用vim或者记事本即可快速编写三维图形程序。
3.快速上手入门，快速呈现效果。
四.WebGL呈现形式：webgl的GLSL ES是以字符串形式存在于javascript，所以整体需用一个单引号括起来的。也可以用后缀名为glsl文件将webgl代码单独存放，然后在js中引入进来，具体引入代码如下：
import waterVertexShader from &#39;./shaders/vertex.glsl&#39;;//顶点着色器 import waterFragmentShader from &#39;./shaders/fragment.glsl&#39;;//片元着色器 五.WebGL坐标系和绘图区域(0点在整个画布的正中心）
六.WebGL绘制流程和不同类型变量的设置流程
七.WebGL缓冲区对象的获取配置流程
可以将同一个缓冲器对象不同部分数据设置到着色器变量中。
八.着色器之间传递数据的方式
利用varying类型的变量绘制图形，在顶点着色器和片元着色器中都要声明varying变量，并且一致，在顶点着色器向片元着色器传递数据，并在片元着色器中使用。详见示例2。
varying vec4 vColor;
执行流程
九.3D图形绘制基础
三维图形在屏幕上绘制需要了解以下几个知识点，分别为视点、目标点、上方向，三者的相对关系如下：
任何一个立体图形要被观察到，其实是被人为的投影到观察平面后形成的，观察平面与物理图形之间的关系如下。
具体实现详见下方示例2。
十.WebGL典型示例
0.公共引用的index.js文件
function initShader(gl, VERTEX_SHADER_SOURCE, FRAGMENT_SHADER_SOURCE) { const vertexShader = gl.createShader(gl.VERTEX_SHADER); const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER); gl.shaderSource(vertexShader, VERTEX_SHADER_SOURCE) // 指定顶点着色器的源码 gl.shaderSource(fragmentShader, FRAGMENT_SHADER_SOURCE) // 指定片元着色器的源码 // 编译着色器 gl.compileShader(vertexShader) gl.compileShader(fragmentShader) // 创建一个程序对象 const program = gl.createProgram(); gl." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/dc2d0c5fb1e765ea252010571f57835a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-02-04T22:53:41+08:00" />
<meta property="article:modified_time" content="2023-02-04T22:53:41+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">WebGL基础与入门示例</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>我们都知道最新的HTML5中支持了画布操作，可以在上面绘制各种二三维图形图像，相应的H5标签就是&lt;canvas&gt;</p> 
<p>二维图形绘制：Canvas API和WebGL API，三维图形绘制：WebGL API。</p> 
<p><strong>一.WebGL定义：</strong>webgl是一种3D绘图库及框架协议，衍生自OpenGL ES2.0，可结合H5和js实现在web端进行二三维图形的渲染和交互，未来支持可穿戴设备的沉浸式渲染交互。</p> 
<p><strong>二.WebGL用途：</strong>主要应用于数据可视化，图形可视化引擎或在线游戏引擎。</p> 
<p><strong>三.WebGL优势：</strong></p> 
<p>1.内置在任意浏览器中，几乎每台电子产品都都相应的浏览器支持，无需安装任何插件。</p> 
<p>2.几乎不需要任何编程环境，可以用vim或者记事本即可快速编写三维图形程序。</p> 
<p>3.快速上手入门，快速呈现效果。</p> 
<p><strong>四.WebGL呈现形式：</strong>webgl的GLSL ES是以字符串形式存在于javascript，所以整体需用一个单引号括起来的。也可以用后缀名为glsl文件将webgl代码单独存放，然后在js中引入进来，具体引入代码如下：</p> 
<pre><code class="language-javascript">import waterVertexShader from './shaders/vertex.glsl';//顶点着色器
import waterFragmentShader from './shaders/fragment.glsl';//片元着色器</code></pre> 
<p><strong>五.WebGL坐标系和绘图区域</strong>(0点在整个画布的正中心）</p> 
<p><img alt="" height="185" src="https://images2.imgbox.com/5d/bf/YivWewHX_o.png" width="272">   <img alt="" height="200" src="https://images2.imgbox.com/2e/5d/Uh36QbQh_o.png" width="270"></p> 
<p><strong>六.WebGL绘制流程和不同类型变量的设置流程</strong></p> 
<p><img alt="" height="183" src="https://images2.imgbox.com/60/c1/Dj2MwQi7_o.png" width="323"><img alt="" height="191" src="https://images2.imgbox.com/10/04/fbyR6jNK_o.png" width="305"></p> 
<p><strong>七.WebGL缓冲区对象的获取配置流程</strong></p> 
<p><img alt="" height="317" src="https://images2.imgbox.com/48/3a/vWQAa2SH_o.png" width="170">   <img alt="" height="295" src="https://images2.imgbox.com/b0/2c/rZ5U4jb3_o.png" width="472"></p> 
<p>可以将同一个缓冲器对象不同部分数据设置到着色器变量中。</p> 
<p><img alt="" height="204" src="https://images2.imgbox.com/7a/bf/vXp97mCv_o.png" width="453"></p> 
<p><strong>八.着色器之间传递数据的方式</strong></p> 
<p>利用varying类型的变量绘制图形，在顶点着色器和片元着色器中都要声明varying变量，并且一致，在顶点着色器向片元着色器传递数据，并在片元着色器中使用。详见示例2。</p> 
<p>varying vec4 vColor;</p> 
<p>执行流程</p> 
<p><img alt="" height="174" src="https://images2.imgbox.com/c6/89/G2xNQAOO_o.png" width="470"></p> 
<p><strong>九.3D图形绘制基础</strong></p> 
<p>三维图形在屏幕上绘制需要了解以下几个知识点，分别为视点、目标点、上方向，三者的相对关系如下：</p> 
<p><img alt="" height="148" src="https://images2.imgbox.com/8e/90/8irmfTB9_o.png" width="438"></p> 
<p>任何一个立体图形要被观察到，其实是被人为的投影到观察平面后形成的，观察平面与物理图形之间的关系如下。</p> 
<p><img alt="" height="225" src="https://images2.imgbox.com/91/b3/qnPLKsbT_o.png" width="429"></p> 
<p>具体实现详见下方示例2。</p> 
<p><strong>十.WebGL典型示例</strong></p> 
<p>0.公共引用的index.js文件</p> 
<pre><code class="language-javascript">function initShader(gl, VERTEX_SHADER_SOURCE, FRAGMENT_SHADER_SOURCE) {
const vertexShader = gl.createShader(gl.VERTEX_SHADER);
const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);

gl.shaderSource(vertexShader, VERTEX_SHADER_SOURCE) // 指定顶点着色器的源码
gl.shaderSource(fragmentShader, FRAGMENT_SHADER_SOURCE) // 指定片元着色器的源码

// 编译着色器
gl.compileShader(vertexShader)
gl.compileShader(fragmentShader)

// 创建一个程序对象
const program = gl.createProgram();
gl.attachShader(program, vertexShader)
gl.attachShader(program, fragmentShader)
gl.linkProgram(program)
gl.useProgram(program)
return program;
}</code></pre> 
<p>1.绘制二维图形示例，如下图形的显示，代码如下：</p> 
<p><img alt="" height="223" src="https://images2.imgbox.com/bb/8f/HVN2PQMy_o.png" width="209"></p> 
<pre><code class="language-javascript">&lt;canvas id="canvas" width="400" height="400"&gt;
此浏览器不支持canvas
&lt;/canvas&gt;
&lt;script&gt;
//1.获得canvas对象
const ctx = document.getElementById('canvas')
//2.获得webgl对象，后续使用。
// const gl = ctx.getContext('webgl')
const gl = ctx.getContext('webgl2')
// //获得canvas api对象
// const c = ctx.getContext('2d')
// c.fillStyle = 'red'
// c.fillRect(10,10,100,100)//左上角坐标，宽，高

//3.创建着色器源码
const VERTEX_SHADER_SOURCE = `
// 只传递顶点数据
attribute vec4 aPosition;
// 必须要存在 main 函数
void main() {
gl_Position = aPosition; // vec4(0.0,0.0,0.0,1.0)
gl_PointSize = 10.0;
}
`; // 3.1顶点着色器

const FRAGMENT_SHADER_SOURCE = `
// 必须要存在 main 函数
void main() {
gl_FragColor = vec4(0.0,0.0,1.0,1.0);
}
`; // 3.2片元着色器

//4.获得一个程序对象
const program = initShader(gl, VERTEX_SHADER_SOURCE, FRAGMENT_SHADER_SOURCE)
//获得顶点着色器中的一个attriute变量
const aPosition = gl.getAttribLocation(program, 'aPosition');

//5.类型化数组
//创建顶点数据
const points = new Float32Array([
-0.5, -0.5,
0.5, -0.5,
-0.5, 0.5,
0.5, 0.5,
])
//6.创建缓冲区对象
const buffer = gl.createBuffer();
//7.绑定缓冲区对象
gl.bindBuffer(gl.ARRAY_BUFFER, buffer);//第一个参数是缓冲区存储的是顶点数据（也可以是顶点的索引值，即ELEMENT_ARRAY_BUFFER)，第二个参数是创建的缓冲区对象。
//8.将数据写入缓冲区对象
gl.bufferData(gl.ARRAY_BUFFER, points, gl.STATIC_DRAW);
//9.将缓冲区对象分配给一个attribute变量
gl.vertexAttribPointer(aPosition, 2, gl.FLOAT, false, 0, 0);
//10.开启attribute变量
gl.enableVertexAttribArray(aPosition)
// gl.vertexAttrib2f(aPosition, 0.0, 0.0)

//11.绘制不同的图形
gl.drawArrays(gl.POINTS, 0, 2);
gl.drawArrays(gl.LINES, 0, 2); // 最少需要有两个点，
gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
&lt;/script&gt;</code></pre> 
<p></p> 
<p>以下是实现多缓冲区的代码，其他同上</p> 
<pre><code class="language-javascript">&lt;script&gt;
const ctx = document.getElementById('canvas')
const gl = ctx.getContext('webgl')

// 创建着色器源码
const VERTEX_SHADER_SOURCE = `
attribute vec4 aPosition;
attribute float aPointSize;
void main() {
gl_Position = aPosition;
gl_PointSize = aPointSize;
}
`; // 顶点着色器

const FRAGMENT_SHADER_SOURCE = `
void main() {
gl_FragColor = vec4(1.0,0.0,0.0,1.0);
}
`; // 片元着色器

const program = initShader(gl, VERTEX_SHADER_SOURCE, FRAGMENT_SHADER_SOURCE)
const aPosition = gl.getAttribLocation(program, 'aPosition');
const aPointSize = gl.getAttribLocation(program, 'aPointSize');
const points = new Float32Array([
-0.5, -0.5, 10.0, // 10.0
0.5, -0.5, 20.0, // 20.0
0.0, 0.5, 30.0, // 30.0
])

const buffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
gl.bufferData(gl.ARRAY_BUFFER, points, gl.STATIC_DRAW);
const BYTES = points.BYTES_PER_ELEMENT;
gl.vertexAttribPointer(aPosition, 2, gl.FLOAT, false, BYTES * 3, 0);//每行3列数据，前2个用作aPosition，每次取2个数据，取数据时，每行位移为0
gl.enableVertexAttribArray(aPosition)
gl.vertexAttribPointer(aPointSize, 1, gl.FLOAT, false, BYTES * 3, BYTES * 2);//每行3列数据，每次取1个数据，取数据时，每行位移为2*BYTES
gl.enableVertexAttribArray(aPointSize)
gl.drawArrays(gl.POINTS, 0, 3);
&lt;/script&gt;</code></pre> 
<p></p> 
<p>2.绘制三维图形示例</p> 
<p>在三维空间中，任意一个正方体的构成如下，正方体是由8个顶点和6个面构成的，顶点变化如下图。</p> 
<p><img alt="" height="184" src="https://images2.imgbox.com/65/9b/xQlFaikm_o.png" width="211">   <img alt="" height="184" src="https://images2.imgbox.com/20/d3/93ruQBKs_o.gif" width="219"></p> 
<p>其他代码类似上面示例1，顶点法主体代码如下：</p> 
<pre><code class="language-javascript">&lt;script&gt;
const ctx = document.getElementById('canvas')
const gl = ctx.getContext('webgl')
// 创建着色器源码
const VERTEX_SHADER_SOURCE = `
attribute vec4 aPosition;
attribute vec4 aColor;
varying vec4 vColor;
uniform mat4 mat;
void main() {
gl_Position = mat * aPosition;
vColor = aPosition;//aColor;
}
`; // 顶点着色器
const FRAGMENT_SHADER_SOURCE = `
precision lowp float;
varying vec4 vColor;
void main() {
gl_FragColor = vColor;
}
`; // 片元着色器

const program = initShader(gl, VERTEX_SHADER_SOURCE, FRAGMENT_SHADER_SOURCE)
const aPosition = gl.getAttribLocation(program, 'aPosition');
const aColor = gl.getAttribLocation(program, 'aColor');
const mat = gl.getUniformLocation(program, 'mat');

// 顶点-8个点
const v0 = [1,1,1];
const v1 = [-1,1,1];
const v2 = [-1,-1,1];
const v3 = [1,-1,1];
const v4 = [1,-1,-1];
const v5 = [1,1,-1];
const v6 = [-1,1,-1];
const v7 = [-1,-1,-1];
//正方体每个面的构成顶点组合，三角网格（Mesh）
const points = new Float32Array([
...v0,...v1,...v2, ...v0,...v2, ...v3, // 前
...v0,...v3,...v4, ...v0,...v4, ...v5, // 右
...v0,...v5,...v6, ...v0,...v6, ...v1, // 上面
...v1,...v6,...v7, ...v1,...v7, ...v2, // 左
...v7,...v4,...v3, ...v7,...v3, ...v2, // 底
...v4,...v7,...v6, ...v4,...v6, ...v5, // 后
])
const buffer = gl.createBuffer();
const BYTES = points.BYTES_PER_ELEMENT;
gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
gl.bufferData(gl.ARRAY_BUFFER, points, gl.STATIC_DRAW);
gl.vertexAttribPointer(aPosition, 3, gl.FLOAT, false, 0, 0);
gl.enableVertexAttribArray(aPosition)

//每个面的构成颜色，共6个面，每个面是由6个点组成
const colorData = new Float32Array([
1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,
0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,
0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,1,1,0,1,1,0,1,1,0,1,1,0,1,1,0,1,1,
])
const colorBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
gl.bufferData(gl.ARRAY_BUFFER, colorData, gl.STATIC_DRAW);
gl.vertexAttribPointer(aColor, 3, gl.FLOAT, false, 0, 0);
gl.enableVertexAttribArray(aColor)

//视点定义
let eyex = 3;
let eyey = 3;
let eyez = 5;

//观察角定义
let deg = 0;
function draw() {
deg += 0.01;
const rotate = getRotateMatrix(deg);
const vm = getViewMatrix(eyex,eyey,eyez,0.0,0.0,0.0,0.0,0.6,0.0);
const perspective = getPerspective(30, ctx.width / ctx.height, 100, 1);
gl.enable(gl.DEPTH_TEST);
gl.uniformMatrix4fv(mat, false, mixMatrix(mixMatrix(perspective, vm), rotate));
gl.drawArrays(gl.TRIANGLES, 0, points.length / 3);
requestAnimationFrame(draw)
}
draw()
&lt;/script&gt;</code></pre> 
<p>其他代码类似上面示例1，索引法主体代码如下：</p> 
<pre><code class="language-javascript">&lt;script&gt;
const ctx = document.getElementById('canvas')
const gl = ctx.getContext('webgl')
// 创建着色器源码
const VERTEX_SHADER_SOURCE = `
attribute vec4 aPosition;
attribute vec4 aColor;
varying vec4 vColor;
uniform mat4 mat;
void main() {
gl_Position = mat * aPosition;
vColor = aPosition;
}
`; // 顶点着色器
const FRAGMENT_SHADER_SOURCE = `
precision lowp float;
varying vec4 vColor;
void main() {
gl_FragColor = vColor;
}
`; // 片元着色器

const program = initShader(gl, VERTEX_SHADER_SOURCE, FRAGMENT_SHADER_SOURCE)
const aPosition = gl.getAttribLocation(program, 'aPosition');
const aColor = gl.getAttribLocation(program, 'aColor');
const mat = gl.getUniformLocation(program, 'mat');
// 顶点-8个点
const vertices = new Float32Array([
1, 1, 1,
-1, 1, 1,
-1,-1, 1,
1,-1, 1,
1,-1,-1,
1, 1,-1,
-1, 1,-1,
-1,-1,-1,
])

const buffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
gl.vertexAttribPointer(aPosition, 3, gl.FLOAT, false, 0, 0);
gl.enableVertexAttribArray(aPosition)

//正方体每个面的构成顶点索引组合，每个面6个顶点，三角网格（Mesh）
const indeces = new Uint8Array([
0,1,2,0,2,3,
0,3,4,0,4,5,
0,5,6,0,6,1,
1,6,7,1,7,2,
7,4,3,7,3,2,
4,6,7,4,6,5,
])
const indexBuffer = gl.createBuffer();
gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indeces, gl.STATIC_DRAW);
//视点定义
let eyex = 3;
let eyey = 3;
let eyez = 5;
//观察角定义
let deg = 0;
function draw() {
deg += 0.01;
const rotate = getRotateMatrix(deg);
const vm = getViewMatrix(eyex,eyey,eyez,0.0,0.0,0.0,0.0,0.6,0.0);
const perspective = getPerspective(30, ctx.width / ctx.height, 100, 1);
gl.enable(gl.DEPTH_TEST);
gl.uniformMatrix4fv(mat, false, mixMatrix(mixMatrix(perspective, vm), rotate));
gl.drawElements(gl.TRIANGLES, indeces.length, gl.UNSIGNED_BYTE, 0);
requestAnimationFrame(draw)
}
draw()
&lt;/script&gt;</code></pre> 
<p><strong>十一.WebGL开源引擎有哪些：</strong></p> 
<p>1.Threejs：快速实现三维图形的轻量级引擎</p> 
<p>2.BabyIon.js：Web3D图形引擎</p> 
<p>3.KickJS：web开源图形和游戏引擎</p> 
<p>4.ClayGL：可扩展的Web3D应用程序</p> 
<p>5.Luma：Uber的3D WebGL可视化库</p> 
<p>6.A-Frame：构建VR(虚拟现实)体验的web框架</p> 
<p>7.Unity：游戏引擎，轻量级引擎</p> 
<p>8.Unreal Engine：游戏引擎，支持大场景大模型</p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/bce974fc933c49520d712e03ce830e7e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">windows 10 __同时管理多个窗口的使用技巧（拼接多个窗口，虚拟桌面等）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/36069a1d99ed7413aec4ba3b2c2a32c7/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Typescript中的reference（三斜线指令）是什么</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>