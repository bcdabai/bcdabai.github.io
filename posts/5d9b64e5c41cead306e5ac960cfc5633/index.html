<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>noi 2729:Blah数集——单调队列 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="noi 2729:Blah数集——单调队列" />
<meta property="og:description" content="2729:Blah数集 Description 大数学家高斯小时候偶然间发现一种有趣的自然数集合Blah，对于以a为基的集合Ba定义如下： (1) a是集合Ba的基，且a是Ba的第一个元素； (2)如果x在集合Ba中，则2x&#43;1和3x&#43;1也都在集合Ba中； (3)没有其他元素在集合Ba中了。 现在小高斯想知道如果将集合Ba中元素按照升序排列，第N个元素会是多少？ Input 输入包括很多行，每行输入包括两个数字，集合的基a(1&lt;=a&lt;=50))以及所求元素序号n(1&lt;=n&lt;=1000000) Output 对于每个输入，输出集合Ba的第n个元素值 Sample Input 1 100 28 5437 Sample Output 418 900585
题目分析：本来想着要省事，用优先队列吧，虽然知道n=10^6 ，优先队列nlong（n)要超时，还是想随便写写，看过几个点，结果一个也不过。
本题要要递增的数列，所以用单调队列。定义两个队头指针，head2，head3分别代表2*x&#43;1,3*x&#43;1；比较head2和head3，谁小谁入队列，入队列后指针后移，如果相等，只入一次，两个指针都后移。0（n）的做法，本来要800多ms,用位运算后能到500多Ms。
程序
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
using namespace std;
long long q[1000010];
long long a,n,head2,head3,tail;
void work(){
head2=1;//2*x&#43;1; head3=1;//3*x&#43;1;
tail=1;
q[1]=a;
while(tail&lt;n){ long long t1=(q[head2]&lt;&lt;1)&#43;1, t2=(q[head3]&lt;&lt;1)&#43;q[head3]&#43;1; if(t1&lt;t2){ //2*q[head2]&#43;1&lt;3q[head3 ] &#43;1 q[&#43;&#43;tail]=t1;
head2&#43;&#43;;
}
else{
if(t1&gt;t2){
q[&#43;&#43;tail]=t2;
head3&#43;&#43;;
}
else{//相等，重复的数，只进一次栈 q[&#43;&#43;tail]=t1;
head3&#43;&#43;;
head2&#43;&#43;;
}
}
}
printf(&#34;%d\n&#34;,q[tail]);
}" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/5d9b64e5c41cead306e5ac960cfc5633/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2016-01-11T14:52:54+08:00" />
<meta property="article:modified_time" content="2016-01-11T14:52:54+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">noi 2729:Blah数集——单调队列</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    2729:Blah数集 
<br> 
<br> Description 
<br> 大数学家高斯小时候偶然间发现一种有趣的自然数集合Blah，对于以a为基的集合Ba定义如下： 
<br> (1) a是集合Ba的基，且a是Ba的第一个元素； 
<br> (2)如果x在集合Ba中，则2x+1和3x+1也都在集合Ba中； 
<br> (3)没有其他元素在集合Ba中了。 
<br> 现在小高斯想知道如果将集合Ba中元素按照升序排列，第N个元素会是多少？ 
<br> Input 
<br> 输入包括很多行，每行输入包括两个数字，集合的基a(1&lt;=a&lt;=50))以及所求元素序号n(1&lt;=n&lt;=1000000) 
<br> Output 
<br> 对于每个输入，输出集合Ba的第n个元素值 
<br> Sample Input 
<br> 1 100 
<br> 28 5437 
<br> Sample Output 
<br> 418 
<br> 
<p>900585</p> 
<p><br> </p> 
<p>题目分析：本来想着要省事，用优先队列吧，虽然知道n=10^6 ，优先队列nlong（n)要超时，还是想随便写写，看过几个点，结果一个也不过。</p> 
<p>本题要要递增的数列，所以用单调队列。定义两个队头指针，head2，head3分别代表2*x+1,3*x+1；比较head2和head3，谁小谁入队列，入队列后指针后移，如果相等，只入一次，两个指针都后移。0（n）的做法，本来要800多ms,用位运算后能到500多Ms。</p> 
<p>程序</p> 
<p>#include&lt;iostream&gt;<br> #include&lt;cstdio&gt;<br> using namespace std;<br> long long q[1000010];<br> long long a,n,head2,head3,tail;<br> <br> <br> void work(){<!-- --><br>    head2=1;//2*x+1; <br>     head3=1;//3*x+1;<br>     tail=1;<br>     q[1]=a;<br>     while(tail&lt;n){ <br> <span style="white-space:pre"></span>long long t1=(q[head2]&lt;&lt;1)+1, t2=(q[head3]&lt;&lt;1)+q[head3]+1;         <br>        if(t1&lt;t2){ //2*q[head2]+1&lt;3q[head3 ] +1           <br>              q[++tail]=t1;<br>              head2++;<br>        }<br>        else{<!-- --><br>              if(t1&gt;t2){<!-- --><br>                  q[++tail]=t2;<br>                  head3++;<br>              }<br>              else{//相等，重复的数，只进一次栈 <br>                  q[++tail]=t1;<br>                  head3++;<br>                  head2++;<br>              }<br>        }<br>     }<br>      printf("%d\n",q[tail]);<br> }<br> int main(){<!-- --><br>    while(scanf("%d%d",&amp;a,&amp;n)&gt;0)<br>          work();<br>    return 0;<br> }<br> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9d63602368224793d7d717ede8aa0c76/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">[消息传递之五]－NSMatchPort练习</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/58c8792cca7a40a6775607579148d432/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">android 显示系统初步总结</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>