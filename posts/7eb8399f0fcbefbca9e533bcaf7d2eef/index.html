<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>RestTemplate 简单使用 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="RestTemplate 简单使用" />
<meta property="og:description" content="目录
引用:
简述
一、环境配置
1.1 非 Spring 环境下使用 RestTemplate
注意:
1.2、Spring 环境下使用 RestTemplate
二、API 实践
2.1、GET 请求
不带参的get请求
带参的get请求(restful风格)
带参的get请求(使用占位符号传参)
2.2、POST 请求
模拟表单请求，post方法测试
模拟表单请求，post方法测试（对象接受）
模拟 JSON 请求，post 方法测试
模拟页面重定向，post请求
2.3、PUT 请求 2.4、DELETE 请求
2.5、通用请求方法 exchange 方法
2.6、excute()指定调用方式
注意:
2.6 手动指定转换器(HttpMessageConverter)
2.7 设置底层连接方式
2.8 设置拦截器(ClientHttpRequestInterceptor)
引用 引用了很多作者的内容,有一小部分是自己添加的 ,原文在这里:
真不是我吹，Spring里这款牛逼的网络工具库我估计你都没用过！ Springboot — 用更优雅的方式发HTTP请求(RestTemplate详解) - 云&#43;社区 - 腾讯云
RestTemplate - 简书
简述 RestTemplate 是一个执行HTTP请求的同步阻塞式工具类，它仅仅只是在 HTTP 客户端库（例如 JDK HttpURLConnection，Apache HttpComponents，okHttp 等）基础上，封装了更加简单易用的模板方法 API，方便程序员利用已提供的模板方法发起网络请求和处理，能很大程度上提升我们的开发效率。 是Spring用于同步client端的核心类，简化了与http服务的通信，并满足RestFul原则，程序代码可以给它提供URL，并提取结果。默认情况下，RestTemplate默认依赖jdk的HTTP连接工具。当然你也可以 通过setRequestFactory属性切换到不同的HTTP源，比如Apache HttpComponents、Netty和OkHttp。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/7eb8399f0fcbefbca9e533bcaf7d2eef/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-02-28T17:52:13+08:00" />
<meta property="article:modified_time" content="2022-02-28T17:52:13+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">RestTemplate 简单使用</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p><a href="#%E5%BC%95%E7%94%A8%3A" rel="nofollow">引用:</a></p> 
<p id="%E7%AE%80%E8%BF%B0-toc" style="margin-left:0px;"><a href="#%E7%AE%80%E8%BF%B0" rel="nofollow">简述</a></p> 
<p id="%C2%A0%E4%B8%80%E3%80%81%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE-toc" style="margin-left:0px;"><a href="#%C2%A0%E4%B8%80%E3%80%81%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE" rel="nofollow"> 一、环境配置</a></p> 
<p id="1.1%C2%A0%E9%9D%9E%20Spring%20%E7%8E%AF%E5%A2%83%E4%B8%8B%E4%BD%BF%E7%94%A8%20RestTemplate-toc" style="margin-left:40px;"><a href="#1.1%C2%A0%E9%9D%9E%20Spring%20%E7%8E%AF%E5%A2%83%E4%B8%8B%E4%BD%BF%E7%94%A8%20RestTemplate" rel="nofollow">1.1 非 Spring 环境下使用 RestTemplate</a></p> 
<p id="%E6%B3%A8%E6%84%8F%3A-toc" style="margin-left:40px;"><a href="#%E6%B3%A8%E6%84%8F%3A" rel="nofollow">注意:</a></p> 
<p id="1.2%E3%80%81Spring%20%E7%8E%AF%E5%A2%83%E4%B8%8B%E4%BD%BF%E7%94%A8%20RestTemplate-toc" style="margin-left:40px;"><a href="#1.2%E3%80%81Spring%20%E7%8E%AF%E5%A2%83%E4%B8%8B%E4%BD%BF%E7%94%A8%20RestTemplate" rel="nofollow">1.2、Spring 环境下使用 RestTemplate</a></p> 
<p id="%E4%BA%8C%E3%80%81API%20%E5%AE%9E%E8%B7%B5-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81API%20%E5%AE%9E%E8%B7%B5" rel="nofollow">二、API 实践</a></p> 
<p id="2.1%E3%80%81GET%20%E8%AF%B7%E6%B1%82-toc" style="margin-left:40px;"><a href="#2.1%E3%80%81GET%20%E8%AF%B7%E6%B1%82" rel="nofollow">2.1、GET 请求</a></p> 
<p id="%E4%B8%8D%E5%B8%A6%E5%8F%82%E7%9A%84get%E8%AF%B7%E6%B1%82-toc" style="margin-left:80px;"><a href="#%E4%B8%8D%E5%B8%A6%E5%8F%82%E7%9A%84get%E8%AF%B7%E6%B1%82" rel="nofollow">不带参的get请求</a></p> 
<p id="%E5%B8%A6%E5%8F%82%E7%9A%84get%E8%AF%B7%E6%B1%82(restful%E9%A3%8E%E6%A0%BC)-toc" style="margin-left:80px;"><a href="#%E5%B8%A6%E5%8F%82%E7%9A%84get%E8%AF%B7%E6%B1%82%28restful%E9%A3%8E%E6%A0%BC%29" rel="nofollow">带参的get请求(restful风格)</a></p> 
<p id="%E5%B8%A6%E5%8F%82%E7%9A%84get%E8%AF%B7%E6%B1%82(%E4%BD%BF%E7%94%A8%E5%8D%A0%E4%BD%8D%E7%AC%A6%E5%8F%B7%E4%BC%A0%E5%8F%82)-toc" style="margin-left:80px;"><a href="#%E5%B8%A6%E5%8F%82%E7%9A%84get%E8%AF%B7%E6%B1%82%28%E4%BD%BF%E7%94%A8%E5%8D%A0%E4%BD%8D%E7%AC%A6%E5%8F%B7%E4%BC%A0%E5%8F%82%29" rel="nofollow">带参的get请求(使用占位符号传参)</a></p> 
<p id="2.2%E3%80%81POST%20%E8%AF%B7%E6%B1%82-toc" style="margin-left:40px;"><a href="#2.2%E3%80%81POST%20%E8%AF%B7%E6%B1%82" rel="nofollow">2.2、POST 请求</a></p> 
<p id="%E6%A8%A1%E6%8B%9F%E8%A1%A8%E5%8D%95%E8%AF%B7%E6%B1%82%EF%BC%8Cpost%E6%96%B9%E6%B3%95%E6%B5%8B%E8%AF%95-toc" style="margin-left:80px;"><a href="#%E6%A8%A1%E6%8B%9F%E8%A1%A8%E5%8D%95%E8%AF%B7%E6%B1%82%EF%BC%8Cpost%E6%96%B9%E6%B3%95%E6%B5%8B%E8%AF%95" rel="nofollow">模拟表单请求，post方法测试</a></p> 
<p id="%E6%A8%A1%E6%8B%9F%E8%A1%A8%E5%8D%95%E8%AF%B7%E6%B1%82%EF%BC%8Cpost%E6%96%B9%E6%B3%95%E6%B5%8B%E8%AF%95%EF%BC%88%E5%AF%B9%E8%B1%A1%E6%8E%A5%E5%8F%97%EF%BC%89-toc" style="margin-left:80px;"><a href="#%E6%A8%A1%E6%8B%9F%E8%A1%A8%E5%8D%95%E8%AF%B7%E6%B1%82%EF%BC%8Cpost%E6%96%B9%E6%B3%95%E6%B5%8B%E8%AF%95%EF%BC%88%E5%AF%B9%E8%B1%A1%E6%8E%A5%E5%8F%97%EF%BC%89" rel="nofollow">模拟表单请求，post方法测试（对象接受）</a></p> 
<p id="%E6%A8%A1%E6%8B%9F%20JSON%20%E8%AF%B7%E6%B1%82%EF%BC%8Cpost%20%E6%96%B9%E6%B3%95%E6%B5%8B%E8%AF%95-toc" style="margin-left:80px;"><a href="#%E6%A8%A1%E6%8B%9F%20JSON%20%E8%AF%B7%E6%B1%82%EF%BC%8Cpost%20%E6%96%B9%E6%B3%95%E6%B5%8B%E8%AF%95" rel="nofollow">模拟 JSON 请求，post 方法测试</a></p> 
<p id="%E6%A8%A1%E6%8B%9F%E9%A1%B5%E9%9D%A2%E9%87%8D%E5%AE%9A%E5%90%91%EF%BC%8Cpost%E8%AF%B7%E6%B1%82-toc" style="margin-left:80px;"><a href="#%E6%A8%A1%E6%8B%9F%E9%A1%B5%E9%9D%A2%E9%87%8D%E5%AE%9A%E5%90%91%EF%BC%8Cpost%E8%AF%B7%E6%B1%82" rel="nofollow">模拟页面重定向，post请求</a></p> 
<p id="2.3%E3%80%81PUT%20%E8%AF%B7%E6%B1%82%C2%A0-toc" style="margin-left:40px;"><a href="#2.3%E3%80%81PUT%20%E8%AF%B7%E6%B1%82%C2%A0" rel="nofollow">2.3、PUT 请求 </a></p> 
<p id="2.4%E3%80%81DELETE%20%E8%AF%B7%E6%B1%82-toc" style="margin-left:40px;"><a href="#2.4%E3%80%81DELETE%20%E8%AF%B7%E6%B1%82" rel="nofollow">2.4、DELETE 请求</a></p> 
<p id="%C2%A02.5%E3%80%81%E9%80%9A%E7%94%A8%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95%20exchange%20%E6%96%B9%E6%B3%95-toc" style="margin-left:40px;"><a href="#%C2%A02.5%E3%80%81%E9%80%9A%E7%94%A8%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95%20exchange%20%E6%96%B9%E6%B3%95" rel="nofollow">2.5、通用请求方法 exchange 方法</a></p> 
<p id="2.6%E3%80%81excute()%E6%8C%87%E5%AE%9A%E8%B0%83%E7%94%A8%E6%96%B9%E5%BC%8F-toc" style="margin-left:40px;"><a href="#2.6%E3%80%81excute%28%29%E6%8C%87%E5%AE%9A%E8%B0%83%E7%94%A8%E6%96%B9%E5%BC%8F" rel="nofollow">2.6、excute()指定调用方式</a></p> 
<p id="%E6%B3%A8%E6%84%8F%3A-toc" style="margin-left:40px;"><a href="#%E6%B3%A8%E6%84%8F%3A" rel="nofollow">注意:</a></p> 
<p id="2.6%C2%A0%E6%89%8B%E5%8A%A8%E6%8C%87%E5%AE%9A%E8%BD%AC%E6%8D%A2%E5%99%A8(HttpMessageConverter)-toc" style="margin-left:40px;"><a href="#2.6%C2%A0%E6%89%8B%E5%8A%A8%E6%8C%87%E5%AE%9A%E8%BD%AC%E6%8D%A2%E5%99%A8%28HttpMessageConverter%29" rel="nofollow">2.6 手动指定转换器(HttpMessageConverter)</a></p> 
<p id="2.7%C2%A0%E8%AE%BE%E7%BD%AE%E5%BA%95%E5%B1%82%E8%BF%9E%E6%8E%A5%E6%96%B9%E5%BC%8F-toc" style="margin-left:40px;"><a href="#2.7%C2%A0%E8%AE%BE%E7%BD%AE%E5%BA%95%E5%B1%82%E8%BF%9E%E6%8E%A5%E6%96%B9%E5%BC%8F" rel="nofollow">2.7 设置底层连接方式</a></p> 
<p id="2.8%20%E8%AE%BE%E7%BD%AE%E6%8B%A6%E6%88%AA%E5%99%A8(ClientHttpRequestInterceptor)-toc" style="margin-left:40px;"><a href="#2.8%20%E8%AE%BE%E7%BD%AE%E6%8B%A6%E6%88%AA%E5%99%A8%28ClientHttpRequestInterceptor%29" rel="nofollow">2.8 设置拦截器(ClientHttpRequestInterceptor)</a></p> 
<p></p> 
<hr id="hr-toc"> 
<h4 id="%E5%BC%95%E7%94%A8%3A">引用</h4> 
<blockquote> 
 <p>引用了很多作者的内容,有一小部分是自己添加的 ,原文在这里:</p> 
 <pre><a href="https://mp.weixin.qq.com/s/OOnrRPNVgp8gOciom5d6Ew" rel="nofollow" title="真不是我吹，Spring里这款牛逼的网络工具库我估计你都没用过！">真不是我吹，Spring里这款牛逼的网络工具库我估计你都没用过！</a></pre> 
 <p><a href="https://cloud.tencent.com/developer/article/1546738" rel="nofollow" title="Springboot — 用更优雅的方式发HTTP请求(RestTemplate详解) - 云+社区 - 腾讯云">Springboot — 用更优雅的方式发HTTP请求(RestTemplate详解) - 云+社区 - 腾讯云</a></p> 
 <p><a href="https://www.jianshu.com/p/90ec27b3b518" rel="nofollow" title="RestTemplate - 简书">RestTemplate - 简书</a></p> 
</blockquote> 
<h2 id="%E7%AE%80%E8%BF%B0">简述</h2> 
<blockquote> 
 <p><strong><span style="color:#a2e043;"> <code>RestTemplate </code></span></strong>是一个执行<code>HTTP</code>请求的同步阻塞式工具类，它仅仅只是在 <code>HTTP</code> 客户端库（例如 JDK HttpURLConnection，Apache HttpComponents，okHttp 等）基础上，封装了更加简单易用的模板方法 API，方便程序员利用已提供的模板方法发起网络请求和处理，能很大程度上提升我们的开发效率。 </p> 
</blockquote> 
<blockquote> 
 <p> 是Spring用于同步client端的核心类，简化了与http服务的通信，并满足RestFul原则，程序代码可以给它提供URL，并提取结果。默认情况下，RestTemplate默认依赖jdk的HTTP连接工具。当然你也可以 通过setRequestFactory属性切换到不同的HTTP源，比如Apache HttpComponents、Netty和OkHttp。</p> 
</blockquote> 
<p></p> 
<h2 id="%C2%A0%E4%B8%80%E3%80%81%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE"> 一、环境配置</h2> 
<h3 id="1.1%C2%A0%E9%9D%9E%20Spring%20%E7%8E%AF%E5%A2%83%E4%B8%8B%E4%BD%BF%E7%94%A8%20RestTemplate">1.1 非 Spring 环境下使用 RestTemplate</h3> 
<p>如果当前项目不是<code>Spring</code>项目，加入<code>spring-web</code>包，即可引入<code>RestTemplate</code>类</p> 
<pre><code class="language-XML">&lt;dependency&gt;
  &lt;groupId&gt;org.springframework&lt;/groupId&gt;
  &lt;artifactId&gt;spring-web&lt;/artifactId&gt;
  &lt;version&gt;5.2.6.RELEASE&lt;/version&gt;
&lt;/dependency&gt;

</code></pre> 
<p>编写一个单元测试类，使用<code>RestTemplate</code>发送一个<code>GET</code>请求，看看程序运行是否正常</p> 
<pre><code class="language-java">@Test
public void simpleTest() {
    RestTemplate restTemplate = new RestTemplate();
    String url = "http://jsonplaceholder.typicode.com/posts/1";
    String str = restTemplate.getForObject(url, String.class);
    System.out.println(str);
}</code></pre> 
<h3 id="%E6%B3%A8%E6%84%8F%3A"><span style="color:#fe2c24;"><strong>注意:</strong></span></h3> 
<blockquote> 
 <p>RestTemplate 使用 转换器(HttpMessageConverter) 来处理请求数据和返回数据, 非 Spring 环境下有些包不全,会导致某些转换器不可用,例如将 javabean转换为json的 MappingJackson2XmlHttpMessageConverter 转换器, 所以要使用所有转换器的话需要额外添加这些转换器依赖的包,Spring环境的依赖包是包含这些缺失包的,不用额外添加</p> 
 <p></p> 
</blockquote> 
<pre><code class="language-XML">         &lt;!--  HttpMessageConverter :  MappingJackson2HttpMessageConverter--&gt;
 
        &lt;dependency&gt;
           &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
           &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;
           &lt;version&gt;2.13.1&lt;/version&gt;
       &lt;/dependency&gt;
       &lt;dependency&gt;
           &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
           &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt;
           &lt;version&gt;2.13.1&lt;/version&gt;
       &lt;/dependency&gt;

       &lt;dependency&gt;
           &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
           &lt;artifactId&gt;jackson-core&lt;/artifactId&gt;
           &lt;version&gt;2.13.1&lt;/version&gt;
       &lt;/dependency&gt;


        &lt;!-- HttpMessageConverter : MappingJackson2XmlHttpMessageConverter --&gt;
       &lt;dependency&gt;
           &lt;groupId&gt;com.fasterxml.jackson.dataformat&lt;/groupId&gt;
           &lt;artifactId&gt;jackson-dataformat-xml&lt;/artifactId&gt;
           &lt;version&gt;2.13.1&lt;/version&gt;
       &lt;/dependency&gt;</code></pre> 
<p></p> 
<p>具体是那些转换器和这些转换器缺什么包,可以移步源码:</p> 
<pre><code class="language-java">// 文件:  RestTemplate.java
// 行数: 137行

package org.springframework.web.client;

public RestTemplate() {
		this.messageConverters.add(new ByteArrayHttpMessageConverter());
		this.messageConverters.add(new StringHttpMessageConverter());
		this.messageConverters.add(new ResourceHttpMessageConverter(false));
		try {
			this.messageConverters.add(new SourceHttpMessageConverter&lt;&gt;());
		}
		catch (Error err) {
			// Ignore when no TransformerFactory implementation is available
		}
		this.messageConverters.add(new AllEncompassingFormHttpMessageConverter());

		if (romePresent) {
			this.messageConverters.add(new AtomFeedHttpMessageConverter());
			this.messageConverters.add(new RssChannelHttpMessageConverter());
		}

		if (jackson2XmlPresent) {
			this.messageConverters.add(new MappingJackson2XmlHttpMessageConverter());
		}
		else if (jaxb2Present) {
			this.messageConverters.add(new Jaxb2RootElementHttpMessageConverter());
		}

		if (jackson2Present) {
			this.messageConverters.add(new MappingJackson2HttpMessageConverter());
		}
		else if (gsonPresent) {
			this.messageConverters.add(new GsonHttpMessageConverter());
		}
		else if (jsonbPresent) {
			this.messageConverters.add(new JsonbHttpMessageConverter());
		}

		if (jackson2SmilePresent) {
			this.messageConverters.add(new MappingJackson2SmileHttpMessageConverter());
		}
		if (jackson2CborPresent) {
			this.messageConverters.add(new MappingJackson2CborHttpMessageConverter());
		}

		this.uriTemplateHandler = initUriTemplateHandler();
	}</code></pre> 
<p></p> 
<p></p> 
<p></p> 
<h3 id="1.2%E3%80%81Spring%20%E7%8E%AF%E5%A2%83%E4%B8%8B%E4%BD%BF%E7%94%A8%20RestTemplate">1.2、Spring 环境下使用 RestTemplate</h3> 
<p>如果当前项目是<code>SpringBoot</code>，添加如下依赖接口！</p> 
<pre><code class="language-XML">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre> 
<p>同时，将<code>RestTemplate</code>配置初始化为一个<code>Bean</code>。</p> 
<pre><code class="language-java">@Configuration
public class RestTemplateConfig {

    /**
     * 没有实例化RestTemplate时，初始化RestTemplate
     * @return
     */
    @ConditionalOnMissingBean(RestTemplate.class)
    @Bean
    public RestTemplate restTemplate(){
        RestTemplate restTemplate = new RestTemplate();
        return restTemplate;
    }
}

</code></pre> 
<p>注意，这种初始化方法，是使用了<code>JDK</code>自带的<code>HttpURLConnection</code>作为底层<code>HTTP</code>客户端实现。</p> 
<p>当然，我们还可以修改<code>RestTemplate</code>默认的客户端，例如将其改成<code>HttpClient</code>客户端，方式如下：</p> 
<pre><code class="language-java">@Configuration
public class RestTemplateConfig {


    /**
     * 没有实例化RestTemplate时，初始化RestTemplate
     * @return
     */
    @ConditionalOnMissingBean(RestTemplate.class)
    @Bean
    public RestTemplate restTemplate(){
        RestTemplate restTemplate = new RestTemplate(getClientHttpRequestFactory());
        return restTemplate;
    }

    /**
     * 使用HttpClient作为底层客户端
     * @return
     */
    private ClientHttpRequestFactory getClientHttpRequestFactory() {
        int timeout = 5000;
        RequestConfig config = RequestConfig.custom()
                .setConnectTimeout(timeout)
                .setConnectionRequestTimeout(timeout)
                .setSocketTimeout(timeout)
                .build();
        CloseableHttpClient client = HttpClientBuilder
                .create()
                .setDefaultRequestConfig(config)
                .build();
        return new HttpComponentsClientHttpRequestFactory(client);
    }

}
</code></pre> 
<p>在需要使用<code>RestTemplate</code>的位置，注入并使用即可！</p> 
<pre><code class="language-java">@Autowired
private RestTemplate restTemplate;
</code></pre> 
<p>从开发人员的反馈，和网上的各种<code>HTTP</code>客户端性能以及易用程度评测来看，<code>OkHttp</code> 优于 <code>Apache</code>的<code>HttpClient</code>、<code>Apache</code>的<code>HttpClient</code>优于<code>HttpURLConnection</code>。</p> 
<p>因此，我们还可以通过如下方式，将底层的<code>http</code>客户端换成<code>OkHttp</code>！</p> 
<pre><code class="language-java">/**
 * 使用OkHttpClient作为底层客户端
 * @return
 */
private ClientHttpRequestFactory getClientHttpRequestFactory(){
    OkHttpClient okHttpClient = new OkHttpClient.Builder()
            .connectTimeout(5, TimeUnit.SECONDS)
            .writeTimeout(5, TimeUnit.SECONDS)
            .readTimeout(5, TimeUnit.SECONDS)
            .build();
    return new OkHttp3ClientHttpRequestFactory(okHttpClient);
}</code></pre> 
<p></p> 
<h2 id="%E4%BA%8C%E3%80%81API%20%E5%AE%9E%E8%B7%B5">二、API 实践</h2> 
<p><code>RestTemplate</code>最大的特色就是对各种网络请求方式做了包装，能极大的简化开发人员的工作量，下面我们以<code>GET</code>、<code>POST</code>、<code>PUT</code>、<code>DELETE</code>、<code>文件上传与下载</code>为例，分别介绍各个<code>API</code>的使用方式！</p> 
<h3 id="2.1%E3%80%81GET%20%E8%AF%B7%E6%B1%82">2.1、GET 请求</h3> 
<p>通过<code>RestTemplate</code>发送<code>HTTP GET</code>协议请求，经常使用到的方法有两个：</p> 
<ul><li> <p>getForObject()</p> </li><li> <p>getForEntity()</p> </li></ul> 
<p>二者的主要区别在于，<code><strong>getForObject</strong>()</code>返回值是<code>HTTP</code>协议的响应体。</p> 
<p><code><strong>getForEntity</strong>()</code>返回的是<strong><code>ResponseEntity</code>，<code>ResponseEntity</code></strong>是对<code>HTTP</code>响应的封装，除了包含响应体，还包含<code>HTTP</code>状态码、<code>contentType</code>、<code>contentLength</code>、<code>Header</code>等信息。</p> 
<p>在<strong><code>Spring Boot</code></strong>环境下写一个单元测试用例，首先创建一个<code>Api</code>接口，然后编写单元测试进行服务测试。</p> 
<ul><li> <h4 id="%E4%B8%8D%E5%B8%A6%E5%8F%82%E7%9A%84get%E8%AF%B7%E6%B1%82">不带参的get请求</h4> </li></ul> 
<pre><code class="language-java">@RestController
public class TestController {

    /**
     * 不带参的get请求
     * @return
     */
    @RequestMapping(value = "testGet", method = RequestMethod.GET)
    public ResponseBean testGet(){
        ResponseBean result = new ResponseBean();
        result.setCode("200");
        result.setMsg("请求成功，方法：testGet");
        return result;
    }
}
</code></pre> 
<pre><code class="language-java">public class ResponseBean {

    private String code;

    private String msg;

    public String getCode() {
        return code;
    }

    public void setCode(String code) {
        this.code = code;
    }

    public String getMsg() {
        return msg;
    }

    public void setMsg(String msg) {
        this.msg = msg;
    }

    @Override
    public String toString() {
        return "ResponseBean{" +
                "code='" + code + '\'' +
                ", msg='" + msg + '\'' +
                '}';
    }
}
</code></pre> 
<pre><code class="language-java">@Autowired
private RestTemplate restTemplate;

/**
 * 单元测试（不带参的get请求）
 */
@Test
public void testGet(){
    //请求地址
    String url = "http://localhost:8080/testGet";

    //发起请求,直接返回对象
    ResponseBean responseBean = restTemplate.getForObject(url, ResponseBean.class);
    System.out.println(responseBean.toString());
}
</code></pre> 
<ul><li> <h4 id="%E5%B8%A6%E5%8F%82%E7%9A%84get%E8%AF%B7%E6%B1%82(restful%E9%A3%8E%E6%A0%BC)"><strong>带参的get请求(restful风格)</strong></h4> </li></ul> 
<pre><code class="language-java">@RestController
public class TestController {

    /**
     * 带参的get请求(restful风格)
     * @return
     */
    @RequestMapping(value = "testGetByRestFul/{id}/{name}", method = RequestMethod.GET)
    public ResponseBean testGetByRestFul(@PathVariable(value = "id") String id, @PathVariable(value = "name") String name){
        ResponseBean result = new ResponseBean();
        result.setCode("200");
        result.setMsg("请求成功，方法：testGetByRestFul，请求参数id：" +  id + "请求参数name：" + name);
        return result;
    }
}
</code></pre> 
<pre><code class="language-java">@Autowired
private RestTemplate restTemplate;


 /**
 * 单元测试（带参的get请求）
 */
@Test
public void testGetByRestFul(){
    //请求地址
    String url = "http://localhost:8080/testGetByRestFul/{1}/{2}";

    //发起请求,直接返回对象（restful风格）
    ResponseBean responseBean = restTemplate.getForObject(url, ResponseBean.class, "001", "张三");
    System.out.println(responseBean.toString());
}
</code></pre> 
<ul><li> <h4 id="%E5%B8%A6%E5%8F%82%E7%9A%84get%E8%AF%B7%E6%B1%82(%E4%BD%BF%E7%94%A8%E5%8D%A0%E4%BD%8D%E7%AC%A6%E5%8F%B7%E4%BC%A0%E5%8F%82)"><strong>带参的get请求(使用占位符号传参)</strong></h4> </li></ul> 
<pre><code class="language-java">@RestController
public class TestController {

    /**
     * 带参的get请求(使用占位符号传参)
     * @return
     */
    @RequestMapping(value = "testGetByParam", method = RequestMethod.GET)
    public ResponseBean testGetByParam(@RequestParam("userName") String userName,
                                             @RequestParam("userPwd") String userPwd){
        ResponseBean result = new ResponseBean();
        result.setCode("200");
        result.setMsg("请求成功，方法：testGetByParam，请求参数userName：" +  userName + ",userPwd：" + userPwd);
        return result;
    }
}
</code></pre> 
<pre><code class="language-java">@Autowired
private RestTemplate restTemplate;

 /**
 * 单元测试（带参的get请求）
 */
@Test
public void testGetByParam(){
    //请求地址
    String url = "http://localhost:8080/testGetByParam?userName={userName}&amp;userPwd={userPwd}";

    //请求参数
    Map&lt;String, String&gt; uriVariables = new HashMap&lt;&gt;();
    uriVariables.put("userName", "唐三藏");
    uriVariables.put("userPwd", "123456");

    //发起请求,直接返回对象（带参数请求）
    ResponseBean responseBean = restTemplate.getForObject(url, ResponseBean.class, uriVariables);
    System.out.println(responseBean.toString());
}
</code></pre> 
<p>上面的所有的<strong><code>getForObject</code></strong>请求传参方法，<strong><code>getForEntity</code></strong>都可以使用，使用方法上也几乎是一致的，只是在返回结果接收的时候略有差别。</p> 
<p>使用<strong><code>ResponseEntity&lt;T&gt; responseEntity</code></strong>来接收响应结果。用<strong><code>responseEntity.getBody()</code></strong>获取响应体。</p> 
<pre><code class="language-java"> /**
 * 单元测试
 */
@Test
public void testAllGet(){
    //请求地址
    String url = "http://localhost:8080/testGet";

    //发起请求，返回全部信息
    ResponseEntity&lt;ResponseBean&gt; response = restTemplate.getForEntity(url, ResponseBean.class);

    // 获取响应体
    System.out.println("HTTP 响应body：" + response.getBody().toString());

    // 以下是getForEntity比getForObject多出来的内容
    HttpStatus statusCode = response.getStatusCode();
    int statusCodeValue = response.getStatusCodeValue();
    HttpHeaders headers = response.getHeaders();

    System.out.println("HTTP 响应状态：" + statusCode);
    System.out.println("HTTP 响应状态码：" + statusCodeValue);
    System.out.println("HTTP Headers信息：" + headers);
}</code></pre> 
<p></p> 
<h3 id="2.2%E3%80%81POST%20%E8%AF%B7%E6%B1%82">2.2、POST 请求</h3> 
<p>其实<strong><code>POST</code></strong>请求方法和<strong><code>GET</code></strong>请求方法上大同小异，<strong><code>RestTemplate</code></strong>的<code>POST</code>请求也包含两个主要方法：</p> 
<ul><li> <p>postForObject()</p> </li><li> <p>postForEntity()</p> </li></ul> 
<p><code><strong>postForEntity</strong>()</code>返回全部的信息，<code><strong>postForObject</strong>()</code>方法返回<code>body</code>对象，具体使用方法如下！</p> 
<p></p> 
<ul><li> <h4 id="%E6%A8%A1%E6%8B%9F%E8%A1%A8%E5%8D%95%E8%AF%B7%E6%B1%82%EF%BC%8Cpost%E6%96%B9%E6%B3%95%E6%B5%8B%E8%AF%95">模拟表单请求，post方法测试</h4> <pre><code class="language-java">@RestController
public class TestController {

    /**
     * 模拟表单请求，post方法测试
     * @return
     */
    @RequestMapping(value = "testPostByForm", method = RequestMethod.POST)
    public ResponseBean testPostByForm(@RequestParam("userName") String userName,
                                        @RequestParam("userPwd") String userPwd){
        ResponseBean result = new ResponseBean();
        result.setCode("200");
        result.setMsg("请求成功，方法：testPostByForm，请求参数userName：" + userName + ",userPwd:" + userPwd);
        return result;
    }
}
</code></pre> <pre><code class="language-java">@Autowired
private RestTemplate restTemplate;

/**
 * 模拟表单提交，post请求
 */
@Test
public void testPostByForm(){
    //请求地址
    String url = "http://localhost:8080/testPostByForm";

    // 请求头设置,x-www-form-urlencoded格式的数据
    HttpHeaders headers = new HttpHeaders();
    headers.setContentType(MediaType.APPLICATION_FORM_URLENCODED);

    //提交参数设置
    MultiValueMap&lt;String, String&gt; map = new LinkedMultiValueMap&lt;&gt;();
    map.add("userName", "唐三藏");
    map.add("userPwd", "123456");

    // 组装请求体
    HttpEntity&lt;MultiValueMap&lt;String, String&gt;&gt; request = new HttpEntity&lt;&gt;(map, headers);

    //发起请求
    ResponseBean responseBean = restTemplate.postForObject(url, request, ResponseBean.class);
    System.out.println(responseBean.toString());
}
</code></pre> </li><li> <h4 id="%E6%A8%A1%E6%8B%9F%E8%A1%A8%E5%8D%95%E8%AF%B7%E6%B1%82%EF%BC%8Cpost%E6%96%B9%E6%B3%95%E6%B5%8B%E8%AF%95%EF%BC%88%E5%AF%B9%E8%B1%A1%E6%8E%A5%E5%8F%97%EF%BC%89">模拟表单请求，post方法测试（对象接受）</h4> </li><li> <pre><code class="language-java">@RestController
public class TestController {

    /**
     * 模拟表单请求，post方法测试
     * @param request
     * @return
     */
    @RequestMapping(value = "testPostByFormAndObj", method = RequestMethod.POST)
    public ResponseBean testPostByForm(RequestBean request){
        ResponseBean result = new ResponseBean();
        result.setCode("200");
        result.setMsg("请求成功，方法：testPostByFormAndObj，请求参数：" + JSON.toJSONString(request));
        return result;
    }
}
</code></pre> <pre><code class="language-java">public class RequestBean {


    private String userName;


    private String userPwd;


    public String getUserName() {
        return userName;
    }

    public void setUserName(String userName) {
        this.userName = userName;
    }

    public String getUserPwd() {
        return userPwd;
    }

    public void setUserPwd(String userPwd) {
        this.userPwd = userPwd;
    }
}
</code></pre> <pre><code class="language-java">@Autowired
private RestTemplate restTemplate;

/**
 * 模拟表单提交，post请求
 */
@Test
public void testPostByForm(){
    //请求地址
    String url = "http://localhost:8080/testPostByFormAndObj";

    // 请求头设置,x-www-form-urlencoded格式的数据
    HttpHeaders headers = new HttpHeaders();
    headers.setContentType(MediaType.APPLICATION_FORM_URLENCODED);

    //提交参数设置
    MultiValueMap&lt;String, String&gt; map = new LinkedMultiValueMap&lt;&gt;();
    map.add("userName", "唐三藏");
    map.add("userPwd", "123456");

    // 组装请求体
    HttpEntity&lt;MultiValueMap&lt;String, String&gt;&gt; request = new HttpEntity&lt;&gt;(map, headers);

    //发起请求
    ResponseBean responseBean = restTemplate.postForObject(url, request, ResponseBean.class);
    System.out.println(responseBean.toString());
}
</code></pre> </li><li> <h4 id="%E6%A8%A1%E6%8B%9F%20JSON%20%E8%AF%B7%E6%B1%82%EF%BC%8Cpost%20%E6%96%B9%E6%B3%95%E6%B5%8B%E8%AF%95">模拟 JSON 请求，post 方法测试</h4> </li><li> <pre><code class="language-java">@RestController
public class TestController {

    /**
     * 模拟JSON请求，post方法测试
     * @param request
     * @return
     */
    @RequestMapping(value = "testPostByJson", method = RequestMethod.POST)
    public ResponseBean testPostByJson(@RequestBody RequestBean request){
        ResponseBean result = new ResponseBean();
        result.setCode("200");
        result.setMsg("请求成功，方法：testPostByJson，请求参数：" + JSON.toJSONString(request));
        return result;
    }
}
</code></pre> <pre><code class="language-java">@Autowired
private RestTemplate restTemplate;

/**
 * 模拟JSON提交，post请求
 */
@Test
public void testPostByJson(){
    //请求地址
    String url = "http://localhost:8080/testPostByJson";

    //入参
    RequestBean request = new RequestBean();
    request.setUserName("唐三藏");
    request.setUserPwd("123456789");

   
    //发送post请求，并打印结果，以String类型接收响应结果JSON字符串
    ResponseBean responseBean = restTemplate.postForObject(url, request, ResponseBean.class);
    System.out.println(responseBean.toString());
}
</code></pre> </li><li> <h4 id="%E6%A8%A1%E6%8B%9F%E9%A1%B5%E9%9D%A2%E9%87%8D%E5%AE%9A%E5%90%91%EF%BC%8Cpost%E8%AF%B7%E6%B1%82">模拟页面重定向，post请求</h4> </li><li> <pre><code class="language-java">@Controller
public class LoginController {

    /**
     * 重定向
     * @param request
     * @return
     */
    @RequestMapping(value = "testPostByLocation", method = RequestMethod.POST)
    public String testPostByLocation(@RequestBody RequestBean request){
        return "redirect:index.html";
    }
}

</code></pre> <pre><code class="language-java">@Autowired
private RestTemplate restTemplate;

/**
 * 重定向，post请求
 */
@Test
public void testPostByLocation(){
    //请求地址
    String url = "http://localhost:8080/testPostByLocation";

    //入参
    RequestBean request = new RequestBean();
    request.setUserName("唐三藏");
    request.setUserPwd("123456789");

    //用于提交完成数据之后的页面跳转，返回跳转url
    URI uri = restTemplate.postForLocation(url, request);
    System.out.println(uri.toString());
}
</code></pre> <p>输出结果如下：</p> <pre><code class="language-java">http://localhost:8080/index.html</code></pre> </li></ul> 
<h3 id="2.3%E3%80%81PUT%20%E8%AF%B7%E6%B1%82%C2%A0">2.3、PUT 请求 </h3> 
<p><strong><code>put</code></strong>请求方法，可能很多人都没用过，它指的是修改一个已经存在的资源或者插入资源，该方法会向<code>URL</code>代表的资源发送一个<code>HTTP PUT</code>方法请求，示例如下！</p> 
<pre><code class="language-java">@RestController
public class TestController {

    /**
     * 模拟JSON请求，put方法测试
     * @param request
     * @return
     */
    @RequestMapping(value = "testPutByJson", method = RequestMethod.PUT)
    public void testPutByJson(@RequestBody RequestBean request){
        System.out.println("请求成功，方法：testPutByJson，请求参数：" + JSON.toJSONString(request));
    }
}
</code></pre> 
<pre><code class="language-java">@Autowired
private RestTemplate restTemplate;

/**
 * 模拟JSON提交，put请求
 */
@Test
public void testPutByJson(){
    //请求地址
    String url = "http://localhost:8080/testPutByJson";

    //入参
    RequestBean request = new RequestBean();
    request.setUserName("唐三藏");
    request.setUserPwd("123456789");

    //模拟JSON提交，put请求
    restTemplate.put(url, request);
}
</code></pre> 
<h3 id="2.4%E3%80%81DELETE%20%E8%AF%B7%E6%B1%82">2.4、DELETE 请求</h3> 
<p>与之对应的还有<strong><code>delete</code></strong>方法协议，表示删除一个已经存在的资源，该方法会向<code>URL</code>代表的资源发送一个<code>HTTP DELETE</code>方法请求。</p> 
<pre><code class="language-java">@RestController
public class TestController {

    /**
     * 模拟JSON请求，delete方法测试
     * @return
     */
    @RequestMapping(value = "testDeleteByJson", method = RequestMethod.DELETE)
    public void testDeleteByJson(){
        System.out.println("请求成功，方法：testDeleteByJson");
    }
}
</code></pre> 
<pre><code class="language-java">@Autowired
private RestTemplate restTemplate;

/**
 * 模拟JSON提交，delete请求
 */
@Test
public void testDeleteByJson(){
    //请求地址
    String url = "http://localhost:8080/testDeleteByJson";

    //模拟JSON提交，delete请求
    restTemplate.delete(url);
}</code></pre> 
<h3 id="%C2%A02.5%E3%80%81%E9%80%9A%E7%94%A8%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95%20exchange%20%E6%96%B9%E6%B3%95">2.5、通用请求方法 exchange 方法</h3> 
<p></p> 
<p>如果以上方法还不满足你的要求。在<strong><code>RestTemplate</code></strong>工具类里面，还有一个<strong><code>exchange</code></strong>通用协议请求方法，它可以发送<strong><code>GET</code></strong>、<strong><code>POST</code>、<code>DELETE</code>、<code>PUT</code>、<code>OPTIONS</code>、<code>PATCH</code></strong>等等<strong><code>HTTP</code></strong>方法请求。</p> 
<p>示例:</p> 
<pre><code class="language-java">@Test
    public void rtExchangeTest() throws JSONException {
        RestTemplate restTemplate = new RestTemplate();
        String url = "http://xxx.top/notice/list";
        HttpHeaders headers = new HttpHeaders();
        headers.setContentType(MediaType.APPLICATION_FORM_URLENCODED);
        JSONObject jsonObj = new JSONObject();
        jsonObj.put("start",1);
        jsonObj.put("page",5);
 
        HttpEntity&lt;String&gt; entity = new HttpEntity&lt;&gt;(jsonObj.toString(), headers);
        ResponseEntity&lt;JSONObject&gt; exchange = restTemplate.exchange(url,
                                          HttpMethod.GET, entity, JSONObject.class);
        System.out.println(exchange.getBody());
    }</code></pre> 
<p></p> 
<h3 id="2.6%E3%80%81excute()%E6%8C%87%E5%AE%9A%E8%B0%83%E7%94%A8%E6%96%B9%E5%BC%8F">2.6、excute()指定调用方式</h3> 
<p>excute()的用法与exchange()大同小异了，它同样可以指定不同的HttpMethod，不同的是它返回的对象是响应体所映射成的对象，而不是ResponseEntity。</p> 
<p>需要强调的是，execute()方法是以上所有方法的底层调用。随便看一个：</p> 
<pre><code class="language-java">@Override
    @Nullable
    public &lt;T&gt; T postForObject(String url, @Nullable Object request, Class&lt;T&gt; responseType, Map&lt;String, ?&gt; uriVariables)
            throws RestClientException {
 
        RequestCallback requestCallback = httpEntityCallback(request, responseType);
        HttpMessageConverterExtractor&lt;T&gt; responseExtractor =
                new HttpMessageConverterExtractor&lt;&gt;(responseType, getMessageConverters(), logger);
        return execute(url, HttpMethod.POST, requestCallback, responseExtractor, uriVariables);
    }</code></pre> 
<p></p> 
<h3><span style="color:#fe2c24;">注意:</span></h3> 
<blockquote> 
 <p>restTemplate.postForEntity等方法虽然表面上接收的request是@Nullable Object request类型，但是你追踪下去会发现，这个request是用HttpEntity来解析,所以就直接使用HttpEntity.</p> 
 <p>核心代码如下：</p> 
</blockquote> 
<pre><code class="language-java">//文件: RestTemplate.java
//行数: 899

package org.springframework.web.client;

public HttpEntityRequestCallback(@Nullable Object requestBody, @Nullable Type responseType) {
			super(responseType);
			if (requestBody instanceof HttpEntity) {
				this.requestEntity = (HttpEntity&lt;?&gt;) requestBody;
			}
			else if (requestBody != null) {
				this.requestEntity = new HttpEntity&lt;&gt;(requestBody);
			}
			else {
				this.requestEntity = HttpEntity.EMPTY;
			}
		}</code></pre> 
<p></p> 
<h3 id="2.6%C2%A0%E6%89%8B%E5%8A%A8%E6%8C%87%E5%AE%9A%E8%BD%AC%E6%8D%A2%E5%99%A8(HttpMessageConverter)">2.6 手动指定转换器(HttpMessageConverter)</h3> 
<blockquote> 
 <p>我们知道，调用reseful接口传递的数据内容是json格式的字符串，返回的响应也是json格式的字符串。然而<code>restTemplate.postForObject</code>方法的请求参数<code>RequestBean</code>和返回参数<code>ResponseBean</code>却都是java类。是<code>RestTemplate</code>通过<code>HttpMessageConverter</code>自动帮我们做了转换的操作。</p> 
 <p>默认情况下<code>RestTemplate</code>自动帮我们注册了一组<code>HttpMessageConverter</code>用来处理一些不同的<code>contentType</code>的请求。<br> 如<code>StringHttpMessageConverter</code>来处理<code>text/plain</code>;<code>MappingJackson2HttpMessageConverter</code>来处理<code>application/json</code>;<code>MappingJackson2XmlHttpMessageConverter</code>来处理<code>application/xml</code>。<br> 你可以在<code>org.springframework.http.converter</code>包下找到所有spring帮我们实现好的转换器。<br> 如果现有的转换器不能满足你的需求，你还可以实现<code>org.springframework.http.converter.HttpMessageConverter</code>接口自己写一个。详情<a href="https://links.jianshu.com/go?to=http%3A%2F%2Fdocs.spring.io%2Fspring-framework%2Fdocs%2F4.3.7.RELEASE%2Fjavadoc-api%2Forg%2Fspringframework%2Fhttp%2Fconverter%2Fpackage-summary.html" rel="nofollow" title="参考官方api">参考官方api</a>。</p> 
 <p>选好了<code>HttpMessageConverter</code>后怎么把它注册到我们的<code>RestTemplate</code>中呢。</p> 
</blockquote> 
<pre><code class="language-java">  RestTemplate restTemplate = new RestTemplate();
        //获取RestTemplate默认配置好的所有转换器
        List&lt;HttpMessageConverter&lt;?&gt;&gt; messageConverters = restTemplate.getMessageConverters();
        //默认的MappingJackson2HttpMessageConverter在第7个 先把它移除掉
        messageConverters.remove(6);
        //添加上GSON的转换器
        messageConverters.add(6, new GsonHttpMessageConverter());</code></pre> 
<p>这个简单的例子展示了如何使用<code>GsonHttpMessageConverter</code>替换掉默认用来处理<code>application/json</code>的<code>MappingJackson2HttpMessageConverter</code>。</p> 
<p></p> 
<h3 id="2.7%C2%A0%E8%AE%BE%E7%BD%AE%E5%BA%95%E5%B1%82%E8%BF%9E%E6%8E%A5%E6%96%B9%E5%BC%8F">2.7 设置底层连接方式</h3> 
<blockquote> 
 <p>要创建一个<code>RestTemplate</code>的实例，您可以像上述例子中简单地调用默认的无参数构造函数。这将使用<code>java.net</code>包中的标准Java类作为底层实现来创建HTTP请求。<br> 但很多时候我们需要像传统的<code>HttpClient</code>那样设置HTTP请求的一些属性。<code>RestTemplate</code>使用了一种很偷懒的方式实现了这个需求，那就是直接使用一个<code>HttpClient</code>作为底层实现......</p> 
</blockquote> 
<pre><code class="language-java">     //生成一个设置了连接超时时间、请求超时时间、异常最大重试次数的httpClient
        RequestConfig config = RequestConfig.custom().setConnectionRequestTimeout(10000).setConnectTimeout(10000).setSocketTimeout(30000).build();
        HttpClientBuilder builder = HttpClientBuilder.create().setDefaultRequestConfig(config).setRetryHandler(new DefaultHttpRequestRetryHandler(5, false));
        HttpClient httpClient = builder.build();
        //使用httpClient创建一个ClientHttpRequestFactory的实现
        ClientHttpRequestFactory requestFactory = new HttpComponentsClientHttpRequestFactory(httpClient);
         //ClientHttpRequestFactory作为参数构造一个使用作为底层的RestTemplate
        RestTemplate restTemplate = new RestTemplate(requestFactory);</code></pre> 
<h3 id="2.8%20%E8%AE%BE%E7%BD%AE%E6%8B%A6%E6%88%AA%E5%99%A8(ClientHttpRequestInterceptor)">2.8 设置拦截器(ClientHttpRequestInterceptor)</h3> 
<blockquote> 
 <p>有时候我们需要对请求做一些通用的拦截设置，这就可以使用拦截器进行处理。拦截器需要我们实现<code>org.springframework.http.client.ClientHttpRequestInterceptor</code>接口自己写。</p> 
 <p>举个简单的例子，写一个在header中根据请求内容和地址添加令牌的拦截器。</p> 
 <p></p> 
</blockquote> 
<p></p> 
<pre><code class="language-java">public class TokenInterceptor implements ClientHttpRequestInterceptor
{
    @Override
    public ClientHttpResponse intercept(HttpRequest request, byte[] body, ClientHttpRequestExecution execution) throws IOException
    {
        //请求地址
        String checkTokenUrl = request.getURI().getPath();
        //token有效时间
        int ttTime = (int) (System.currentTimeMillis() / 1000 + 1800);
        //请求方法名 POST、GET等
        String methodName = request.getMethod().name();
        //请求内容
        String requestBody = new String(body);
        //生成令牌 此处调用一个自己写的方法，有兴趣的朋友可以自行google如何使用ak/sk生成token，此方法跟本教程无关，就不贴出来了
        String token = TokenHelper.generateToken(checkTokenUrl, ttTime, methodName, requestBody);
        //将令牌放入请求header中
        request.getHeaders().add("X-Auth-Token",token);

        return execution.execute(request, body);
    }
}</code></pre> 
<p>创建<code>RestTemplate</code>实例的时候可以这样向其中添加拦截器</p> 
<p> </p> 
<pre><code class="language-java">        RestTemplate restTemplate = new RestTemplate();
        //向restTemplate中添加自定义的拦截器
        restTemplate.getInterceptors().add(new TokenInterceptor());</code></pre> 
<p></p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b7a7bd0ee5f0a2baa8a8473fdce085d6/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">yolov4论文解读</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/22875bc1e26acc24fefe167e941f8edb/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">springsecurity认证流程</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>