<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>每天五分钟玩转K8S（五） - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="每天五分钟玩转K8S（五）" />
<meta property="og:description" content="一、service的必要性 对于k8s，pod不需要是robust的，因为可以通过controller来动态创建和销毁pod来保证应用整体的健壮性。由于每个pod都有自己的地址，所以当controller用新pod替代发生故障的pod时，新pod会分配新的ip地址。那么会导致ip地址发生变化，这时候就需要使用service来维护一个对外网络。
Kubernetes Service从逻辑上代表了一组Pod， 具体是哪些Pod则是由label来挑选的。 Service有自己的IP， 而且这个IP是不变的。 客户端只需要访问Service的IP， Kubernetes则负责建立和维护Service与Pod的映射关系。 无论后端Pod如何变化， 对客户端不会有任何影响， 因为Service没有变。
二、创建一个service 首先先创建一个deployment，记得加上selector
创建成功！
例行检查一下pod的情况，kubectl get pod -o wide
pod分配了各自的ip，这些ip只能被集群中的容器和节点访问
接着我们来创建一个service，老办法，先查询一下service的版本
kubectl api-resources | grep Service 创建service的yml文件
字段解释：
selector指明挑选那些label为run:httpd的pod作为service的后端
service的8080端口映射到pod的80端口，使用tcp协议
检查一下service的状况，
经操作，发现连接不到这个服务，查书才知道，原来service是通过selector指明挑选那些label为run:httpd的pod作为service的后端。
而在上面的deployment文件中，我将label设置为app:httpd，所以service不能成功挑选。修改后如下：
重新尝试访问，果然成功了
总结：service是创建了一个统一的访问接口，对内屏蔽了各个容器的具体接口，只需要关注service的接口即可使用。
（如果需要从外部访问service的话，还得再进行别的设置此时就该NodePort出场了）
利用kubectl describe可以查看httpd-svc和pod的对应关系，
Endpoints罗列了三个Pod的IP和端口。 我们知道Pod的IP是在容器中配置的， 那么Service的Cluster IP又是配置在哪里的呢？CLUSTERIP又是如何映射到Pod IP的呢？答案就是通过iptables这尊大佛
三、cluster ip底层实现 通过iptables-save命令查询具体的iptables规则
这两条规则是：
（1）如果Cluster内的Pod（源地址来自10.244.0.0/16） 要访问httpd-svc， 则允许。
（2）其他源地址访问httpd-svc， 跳转到规则KUBE-SVC-IYRDZZKXS5EOQ6Q6
KUBE-SVC-IYRDZZKXS5EOQ6Q6的规则是
（1）1/3跳转到
（2）1/3概率（剩下2/3的一半）跳转到
（3）1/3概率跳转到
总结：iptables将访问service的流量转发到后端pod，而且使用类似轮询的负载均衡策略。而且cluter的每一个节点都配置了相同的iptables规则，这样就可以确保整个cluster都能够通过service的clusterip访问service
四、dns访问service kubeadm部署时会默认安装kube-dns组件
每当有新的service被创建，就会添加该service的dns记录。cluster的pod可以通过service_name.namespace_name访问service
尝试使用http-svc.default访问service httpd-svc
五、外网访问service 除了Cluster内部可以访问Service， 很多情况下我们也希望应用的Service能够暴露给Cluster外部。 Kubernetes提供了多种类型的Service， 默认是ClusterIP。
ClusterIP" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/2c75ac091066b63f19979529a325f700/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-12-01T15:11:37+08:00" />
<meta property="article:modified_time" content="2021-12-01T15:11:37+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">每天五分钟玩转K8S（五）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="service_0"></a>一、service的必要性</h2> 
<p>对于k8s，pod不需要是robust的，因为可以通过controller来动态创建和销毁pod来保证应用整体的健壮性。由于每个pod都有自己的地址，所以当controller用新pod替代发生故障的pod时，新pod会分配新的ip地址。那么会导致ip地址发生变化，这时候就需要使用service来维护一个对外网络。<br> Kubernetes Service从逻辑上代表了一组Pod， 具体是哪些Pod则是由label来挑选的。 Service有自己的IP， 而且这个IP是不变的。 客户端只需要访问Service的IP， Kubernetes则负责建立和维护Service与Pod的映射关系。 无论后端Pod如何变化， 对客户端不会有任何影响， 因为Service没有变。</p> 
<h2><a id="service_3"></a>二、创建一个service</h2> 
<p>首先先创建一个deployment，记得加上selector<br> <img src="https://images2.imgbox.com/35/f6/KZmMY28f_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/6c/8c/oT4XqO2c_o.png" alt="在这里插入图片描述"><br> 创建成功！<br> 例行检查一下pod的情况，<code>kubectl get pod -o wide</code><br> <img src="https://images2.imgbox.com/dc/94/swbmuwbH_o.png" alt="在这里插入图片描述"><br> pod分配了各自的ip，这些ip只能被集群中的容器和节点访问<br> <img src="https://images2.imgbox.com/53/e8/VDvFntVK_o.png" alt="在master节点进行查询"><br> <img src="https://images2.imgbox.com/dd/b8/gGcAX9J0_o.png" alt="在node节点进行查询"><br> 接着我们来创建一个service，老办法，先查询一下service的版本</p> 
<pre><code>kubectl api-resources | grep Service
</code></pre> 
<p><img src="https://images2.imgbox.com/07/cf/RSl8bPna_o.png" alt="在这里插入图片描述"><br> 创建service的yml文件<br> <img src="https://images2.imgbox.com/03/51/hCG419oa_o.png" alt="在这里插入图片描述"><br> 字段解释：<br> <strong>selector指明挑选那些label为run:httpd的pod作为service的后端</strong><br> <strong>service的8080端口映射到pod的80端口，使用tcp协议</strong></p> 
<p>检查一下service的状况，<br> <img src="https://images2.imgbox.com/4b/e2/oNkGH9Pc_o.png" alt="在这里插入图片描述"><br> 经操作，发现连接不到这个服务，查书才知道，原来service是通过<strong>selector指明挑选那些label为run:httpd的pod作为service的后端</strong>。<br> <img src="https://images2.imgbox.com/15/35/sDBn8tMp_o.jpg" alt="在这里插入图片描述"></p> 
<p>而在上面的deployment文件中，我将<strong>label设置为app:httpd</strong>，所以service不能成功挑选。修改后如下：<br> <img src="https://images2.imgbox.com/4b/25/HYZKUwS0_o.png" alt="修改了selector的内容"><br> 重新尝试访问，果然成功了<br> <img src="https://images2.imgbox.com/15/8e/9zOiiBaG_o.png" alt="在这里插入图片描述"><br> 总结：service是创建了一个统一的访问接口，对内屏蔽了各个容器的具体接口，只需要关注service的接口即可使用。<br> （<strong>如果需要从外部访问service的话，还得再进行别的设置<s>此时就该NodePort出场了</s></strong>）</p> 
<p>利用kubectl describe可以查看httpd-svc和pod的对应关系，<br> <img src="https://images2.imgbox.com/81/fa/erOLcoGx_o.png" alt="在这里插入图片描述"><br> Endpoints罗列了三个Pod的IP和端口。 我们知道Pod的IP是在容器中配置的， 那么Service的Cluster IP又是配置在哪里的呢？CLUSTERIP又是如何映射到Pod IP的呢？答案就是通过<strong>iptables</strong>这尊大佛</p> 
<h2><a id="cluster_ip_41"></a>三、cluster ip底层实现</h2> 
<p>通过<code>iptables-save</code>命令查询具体的iptables规则<br> <img src="https://images2.imgbox.com/48/97/h9deRG0S_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/7b/7f/qBbWaJtQ_o.png" alt="在这里插入图片描述"><br> 这两条规则是：<br> （1）如果Cluster内的Pod（源地址来自10.244.0.0/16） 要访问httpd-svc， 则允许。<br> （2）其他源地址访问httpd-svc， 跳转到规则KUBE-SVC-IYRDZZKXS5EOQ6Q6<br> KUBE-SVC-IYRDZZKXS5EOQ6Q6的规则是<br> <img src="https://images2.imgbox.com/63/30/rEbkLrPC_o.png" alt="在这里插入图片描述"><br> （1）1/3跳转到<br> <img src="https://images2.imgbox.com/66/da/ihnK2Naq_o.png" alt="在这里插入图片描述"></p> 
<p>（2）1/3概率（剩下2/3的一半）跳转到<br> <img src="https://images2.imgbox.com/a3/bd/WwtbRYa3_o.png" alt="在这里插入图片描述"></p> 
<p>（3）1/3概率跳转到<br> <img src="https://images2.imgbox.com/89/2d/QuyCDBr3_o.png" alt="在这里插入图片描述"><br> 总结：iptables将访问service的流量转发到后端pod，而且使用类似轮询的负载均衡策略。而且cluter的每一个节点都配置了相同的iptables规则，这样就可以确保整个cluster都能够通过service的clusterip访问service<br> <img src="https://images2.imgbox.com/46/5d/nOZBpTa6_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="dnsservice_60"></a>四、dns访问service</h2> 
<p>kubeadm部署时会默认安装kube-dns组件<br> <img src="https://images2.imgbox.com/9f/83/b98B2KDi_o.png" alt="在这里插入图片描述"><br> 每当有新的service被创建，就会添加该service的dns记录。cluster的pod可以通过service_name.namespace_name访问service<br> 尝试使用http-svc.default访问service httpd-svc<br> <img src="https://images2.imgbox.com/dd/75/9CwXyjaw_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="service_66"></a>五、外网访问service</h2> 
<p>除了Cluster内部可以访问Service， 很多情况下我们也希望应用的Service能够暴露给Cluster外部。 Kubernetes提供了多种类型的Service， 默认是ClusterIP。</p> 
<ul><li>ClusterIP<br> Service通过Cluster内部的IP对外提供服务， 只有Cluster内的节点和Pod可访问， 这是默认的Service类型， 前面实验中的Service都是ClusterIP。（对内的）</li><li>NodePort<br> Service通过Cluster节点的静态端口对外提供服务。 Cluster外部可以通过（这里的node是指node主机的ip，不是指kubectl get pods -o wide打输出的node ip）:访问Service。（对外的）</li><li>LoadBalancer<br> Service利用cloud provider特有的load balancer对外提供服务，cloud provider负责将load balancer的流量导向Service。 目前支持的cloud provider有GCP、 AWS、 Azur等</li></ul> 
<p>写文件创建nodeport<br> <img src="https://images2.imgbox.com/b3/86/UXF8uYPK_o.png" alt="在这里插入图片描述"><br> selector记得和deployment的label对应</p> 
<p>执行后我们来看看情况，<br> <img src="https://images2.imgbox.com/b6/7f/tUS2UiyW_o.png" alt="在这里插入图片描述"><br> （1）external-ip为none，指不可以通过cluster每个节点自身的ip去访问service<br> 当external-ip为nodes时，才可以通过访问节点ip进行访问service<br> （2）port(s)为8080:30331。8080是clusterip监听的端口，30331是节点上监听的端口。k8s会从30000-32767中分配一个可用的端口，每个节点都会监听此端口并将请求转发给service。（每个节点是指物理节点，是指kubectl get node的点 ）</p> 
<p>下面将从cluster内和cluster外进行测试访问：<br> cluster内：<br> 直接对serviceip+对内暴露port进行访问<br> <img src="https://images2.imgbox.com/22/8c/KwdFFIze_o.png" alt="在这里插入图片描述"><br> cluster外：<br> 利用节点ip+对外暴露的port进行访问<br> <img src="https://images2.imgbox.com/57/5d/E5gaaMqK_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/46/eb/SY9r2YJK_o.png" alt="在这里插入图片描述"><br> 接下来我们来研究一下k8s如何实现将nodeip:nodeport映射到pod上，还是利用iptables-save来查询，找到nodeport对应的信息<br> <img src="https://images2.imgbox.com/7f/57/2XmMm0wY_o.png" alt="在这里插入图片描述"><br> 访问当前节点30331的端口的请求，会应用规则KUBE-SVC-IYRDZZKXS5EOQ6Q6。我们来找一下对应的规则内容<br> <img src="https://images2.imgbox.com/92/bf/R6wKWqV0_o.png" alt="在这里插入图片描述"><br> 其作用和上面提到的类似，也就是负载均衡到每一个pod上。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e8b0ade5420a5fd00125532d48e6dbac/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">操作系统实验Ucore:Kernel_init(四)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6e10c146888bf7ea53ed2d0d63e1bb86/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">腾讯云-OCR</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>