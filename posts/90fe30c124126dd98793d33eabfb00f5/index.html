<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>五、Docker镜像讲解 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="五、Docker镜像讲解" />
<meta property="og:description" content="目录
1.Docker镜像加载原理
2.分层理解
3.commit镜像
镜像是什么？
镜像是一种轻量级、可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，它包含运行某个软件所需的所有内容，包括代码、运行时库、环境变量和配置文件。
将所有的应用和环境，直接打包为docker镜像，就可以直接运行。
1.Docker镜像加载原理 UnionFs （联合文件系统）
联合文件系统（UnionFS）是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下(unite several directories into a single virtual filesystem)。
联合文件系统是 Docker 镜像的基础。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。
特性：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系
统叠加起来，这样最终的文件系统会包含所有底层的文件和目录。
Docker镜像加载原理
docker的镜像实际上由一层一层的文件系统组成，这种层级的文件系统UnionFS。
bootfs（boot file system）主要包含 bootloader和 Kernel, bootloader主要是引导加 kernel,Linux刚启动时会加bootfs文件系统，在 Docker镜像的最底层是 bootfs。这一层与我们典型的Linux/Unix系统是一样的，包含boot加载器和内核。当boot加载完成之后整个内核就都在内存中了，此时内存的使用权已由 bootfs转交给内核，此时系统也会卸载bootfs。
rootfs（root file system）在 bootfs之上。包含的就是典型 Linux系统中的/dev,/proc,/bin,/etc等标准目录和文件。 rootfs就是各种不同的操作系统发行版，比如 Ubuntu,Centos等等
虚拟机里的CentOS都是好几个G，为什么Docker里才200M？
对于个精简的OS,rootfs可以很小，只需要包合最基本的命令，工具和程序库就可以了，因为底层直接用Host的kernel，自己只需要提供rootfs就可以了。由此可见对于不同的Linux发行版， bootfs基本是一致的， rootfs会有差別，因此不同的发行版可以共用bootfs。
虚拟机启动是分钟级别，容器是秒级！
2.分层理解 我们可以去下载一个镜像，注意观察下载的日志输出，可以看到是一层层的在下载
[root@fedora ~]# docker pull redis Using default tag: latest latest: Pulling from library/redis a2abf6c4d29d: Already exists c7a4e4382001: Pull complete 4044b9ba67c9: Pull complete c8388a79482f: Pull complete 413c8bb60be2: Pull complete 1abfd3011519: Pull complete Digest: sha256:db485f2e245b5b3329fdc7eff4eb00f913e09d8feb9ca720788059fdc2ed8339 Status: Downloaded newer image for redis:latest docker." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/90fe30c124126dd98793d33eabfb00f5/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-06-26T07:30:00+08:00" />
<meta property="article:modified_time" content="2022-06-26T07:30:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">五、Docker镜像讲解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="1.Docker%E9%95%9C%E5%83%8F%E5%8A%A0%E8%BD%BD%E5%8E%9F%E7%90%86-toc" style="margin-left:40px;"><a href="#1.Docker%E9%95%9C%E5%83%8F%E5%8A%A0%E8%BD%BD%E5%8E%9F%E7%90%86" rel="nofollow">1.Docker镜像加载原理</a></p> 
<p id="2.%E5%88%86%E5%B1%82%E7%90%86%E8%A7%A3-toc" style="margin-left:40px;"><a href="#2.%E5%88%86%E5%B1%82%E7%90%86%E8%A7%A3" rel="nofollow">2.分层理解</a></p> 
<p id="3.commit%E9%95%9C%E5%83%8F-toc" style="margin-left:40px;"><a href="#3.commit%E9%95%9C%E5%83%8F" rel="nofollow">3.commit镜像</a></p> 
<hr id="hr-toc"> 
<p></p> 
<p><strong>镜像是什么？</strong></p> 
<p>镜像是一种轻量级、可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，它包含运行某个软件所需的所有内容，包括代码、运行时库、环境变量和配置文件。</p> 
<p>将所有的应用和环境，直接打包为docker镜像，就可以直接运行。</p> 
<hr> 
<h3 id="1.Docker%E9%95%9C%E5%83%8F%E5%8A%A0%E8%BD%BD%E5%8E%9F%E7%90%86">1.Docker镜像加载原理</h3> 
<p><strong>UnionFs （联合文件系统）</strong></p> 
<p>联合文件系统（<a href="https://en.wikipedia.org/wiki/UnionFS" rel="nofollow" title="UnionFS">UnionFS</a>）是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下(unite several directories into a single virtual filesystem)。</p> 
<p>联合文件系统是 Docker 镜像的基础。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。</p> 
<p>特性：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系<br> 统叠加起来，这样最终的文件系统会包含所有底层的文件和目录。</p> 
<p><strong>Docker镜像加载原理</strong></p> 
<p>docker的镜像实际上由一层一层的文件系统组成，这种层级的文件系统UnionFS。</p> 
<p>bootfs（boot file system）主要包含 bootloader和 Kernel, bootloader主要是引导加 kernel,Linux刚启动时会加bootfs文件系统，在 Docker镜像的最底层是 bootfs。这一层与我们典型的Linux/Unix系统是一样的，包含boot加载器和内核。当boot加载完成之后整个内核就都在内存中了，此时内存的使用权已由 bootfs转交给内核，此时系统也会卸载bootfs。</p> 
<p>rootfs（root file system）在 bootfs之上。包含的就是典型 Linux系统中的/dev,/proc,/bin,/etc等标准目录和文件。 rootfs就是各种不同的操作系统发行版，比如 Ubuntu,Centos等等</p> 
<p><strong>虚拟机里的CentOS都是好几个G，为什么Docker里才200M？</strong></p> 
<p>对于个精简的OS,rootfs可以很小，只需要包合最基本的命令，工具和程序库就可以了，因为底层直接用Host的kernel，自己只需要提供rootfs就可以了。由此可见对于不同的Linux发行版， bootfs基本是一致的， rootfs会有差別，因此不同的发行版可以共用bootfs。</p> 
<p>虚拟机启动是分钟级别，容器是秒级！</p> 
<h3 id="2.%E5%88%86%E5%B1%82%E7%90%86%E8%A7%A3">2.分层理解</h3> 
<p>我们可以去下载一个镜像，注意观察下载的日志输出，可以看到是一层层的在下载</p> 
<pre><code>[root@fedora ~]# docker pull redis
Using default tag: latest
latest: Pulling from library/redis
a2abf6c4d29d: Already exists 
c7a4e4382001: Pull complete 
4044b9ba67c9: Pull complete 
c8388a79482f: Pull complete 
413c8bb60be2: Pull complete 
1abfd3011519: Pull complete 
Digest: sha256:db485f2e245b5b3329fdc7eff4eb00f913e09d8feb9ca720788059fdc2ed8339
Status: Downloaded newer image for redis:latest
docker.io/library/redis:latest</code></pre> 
<p>思考：为什么Docker镜像要采用这种分层的结构呢？</p> 
<p>最大的好处，我觉得莫过于资源共享了！比如有多个镜像都从相同的Base镜像构建而来，那么宿主机<br> 只需在磁盘上保留一份base镜像，同时内存中也只需要加载一份base镜像，这样就可以为所有的容器<br> 服务了，而且镜像的每一层都可以被共享。</p> 
<p>查看镜像分层的方式可以通过docker image inspect 命令</p> 
<p>docker image inspect redis</p> 
<pre><code>[root@fedora ~]# docker image inspect redis
[
    {
        "Id": "sha256:7614ae9453d1d87e740a2056257a6de7135c84037c367e1fffa92ae922784631",
        "RepoTags": [
            "redis:latest"
        ],
       ......
       ......
        "RootFS": {
            "Type": "layers",
            "Layers": [
                "sha256:2edcec3590a4ec7f40cf0743c15d78fb39d8326bc029073b41ef9727da6c851f",
                "sha256:9b24afeb7c2f21e50a686ead025823cd2c6e9730c013ca77ad5f115c079b57cb",
                "sha256:4b8e2801e0f956a4220c32e2c8b0a590e6f9bd2420ec65453685246b82766ea1",
                "sha256:529cdb636f61e95ab91a62a51526a84fd7314d6aab0d414040796150b4522372",
                "sha256:9975392591f2777d6bf4d9919ad1b2c9afa12f9a9b4d260f45025ec3cc9b18ed",
                "sha256:8e5669d8329116b8444b9bbb1663dda568ede12d3dbcce950199b582f6e94952"
            ]
        },
        "Metadata": {
            "LastTagTime": "0001-01-01T00:00:00Z"
        }
    }
]</code></pre> 
<p id="tid-xkKSpS"><strong>理解</strong></p> 
<p>所有的Docker镜像都起始于一个基础镜像层，当进行修改或增加新的内容时，就会在当前镜像层之上，创建新的镜像层。</p> 
<p>举一个简单的例子，假如基于<code>Ubuntu Linux 16.04</code>创建一个新的镜像，这就是新镜像的第一层；如果在该镜像中添加Python包，就会在基础镜像层之上创建第二个镜像层；如果继续添加一个安全补丁，就会创建第三个镜像层。</p> 
<p>该镜像当前已经包含3个镜像层，如下图所示（这只是一个用于演示的很简单的例子）。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/1b/b1/SAPZFdqz_o.png"></p> 
<p>在添加额外的镜像层的同时，镜像始终保持是当前所有镜像的组合，理解这一点非常重要。下图中举了一个简单的例子，每个镜像层包含3个文件，而整体的镜像包含了来自两个镜像层的6个文件。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/bb/ac/cUWljoCL_o.png"></p> 
<p>上图中的鏡像层跟之前图中的略有区别，主要目的是便于展示文件。</p> 
<p>下图中展示了一个稍微复杂的三层镜像，在外部看来整个镜像只有6个文件，这是因为最上层中的文件7是文件5的一个更新版本。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/91/be/31RJRIoS_o.png"></p> 
<p>这种情况下，上层镜像层中的文件覆盖了底层镜像层中的文件。这样就使得文件的更新版本作为一个新镜像层添加到镜像当中。</p> 
<p>Docker通过存储引擎（新版本采用快照机制）的方式来实现镜像层堆栈，并保证多镜像层对外展示为统一的文件系统。</p> 
<p>Linux上可用的存储引擎有<code>AUFS</code>，<code>Overlay2</code>，<code>Device Mapper</code>，<code>Btrfs</code>以及<code>ZFS</code>。顾名思义，每种存储引擎都基于Linux中对应的文件系统或者块设备技术，并且每种存储引擎都有其独有的性能特点。</p> 
<p>Docker在Windows上仅支持<code>windowsfilter</code>一种存储引擎，该引擎基于<code>NTFS</code>文件系统之上实现了分层和<code>Cow</code>。</p> 
<p>如上边的三层镜像，Docker最终会把所有镜像层堆叠并合并，对外提供统一的视图，如下图。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/99/d6/4QubHa0O_o.png"></p> 
<p id="tid-NG3T6T"><strong>说明</strong></p> 
<p>Docker镜像都是只读的，当容器启动时，一个新的可写层被加载到镜像的顶部，只有这个顶部是可写的。</p> 
<p>而这一层就是我们通常说的容器层，容器之下的都叫镜像层。</p> 
<p>如下图：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/14/83/lyuWcXb3_o.png"></p> 
<p>下面这张图更加形象：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/a5/a8/wLEmSihq_o.png"></p> 
<h3 id="3.commit%E9%95%9C%E5%83%8F">3.commit镜像</h3> 
<pre><code>docker commit # 提交容器成为一个新的副本

# 命令和git原理类似
docker commit -a="作者" -m="提交的描述信息" 容器ID 目标镜像名:[Tag]</code></pre> 
<pre><code># 测试
# 1.启动一个默认的tomcat
# 2.发现这个tomcat没有webapps应用，(镜像的原因)官方的镜像默认webapps下是没有文件的
# 3.将基本文件拷贝进去
# 4.将我们操作过的的容器通过commit提交为一个镜像！
# 以后使用修改过的镜像即可，这就是一个我们自己修改过的镜像</code></pre> 
<pre><code>[root@fedora ~]# docker run -it -p 8080:8080 tomcat /bin/bash
root@7389f7990e71:/usr/local/tomcat# ls
BUILDING.txt	 README.md	conf		temp
CONTRIBUTING.md  RELEASE-NOTES	lib		webapps
LICENSE		 RUNNING.txt	logs		webapps.dist
NOTICE		 bin		native-jni-lib	work
root@7389f7990e71:/usr/local/tomcat# cp -r webapps.dist/* webapps
root@7389f7990e71:/usr/local/tomcat# ls webapps/
ROOT  docs  examples  host-manager  manager
# CTRL + P + Q 退出容器
[root@fedora ~]# docker ps
CONTAINER ID   IMAGE     COMMAND       CREATED         STATUS         PORTS                                       NAMES
7389f7990e71   tomcat    "/bin/bash"   4 minutes ago   Up 4 minutes   0.0.0.0:8080-&gt;8080/tcp, :::8080-&gt;8080/tcp   musing_davinci
[root@fedora ~]# docker commit -a="charlie" -m="add webapps app" 7389f7990e71 tomcat:1.0
sha256:90f6753a853b6f7a4188762aace702b5e131c94ba0b853121b1f5ec1ca8a6a47
[root@fedora ~]# docker images
REPOSITORY            TAG       IMAGE ID       CREATED          SIZE
tomcat                1.0       90f6753a853b   14 seconds ago   684MB
tomcat                latest    fb5657adc892   6 months ago     680MB</code></pre> 
<hr> 
<p>Docker 入门成功 ！！ </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/aec3a5eeaa82c76503e8f7ab28d896d3/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">用java写一个贪吃蛇小游戏（源码在最后）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/7705ec93c9e9dcd5a6417398813a92a3/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">“由于没有公钥，无法验证下列签名”解决办法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>