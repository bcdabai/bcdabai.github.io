<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java类的继承 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Java类的继承" />
<meta property="og:description" content="目录
1.类的继承概念 2.类的继承格式
3.作用
4.方法重写
5.自动转型（向上转型）
1.类的继承概念 类的继承就是子类继承父类的属性和方法，使得子类具有与父类相同的属性和方法。
举一个生活中的例子就是：汽车属于一个类，汽车品牌奥迪、奔驰就属于其子类，其具有汽车的一般特性，但二者在性能上也有一定的差别。所以子类会具有父类的一般特性，也会具有其自身的特性。
2.类的继承格式 在Java中通过extends关键字可以生命一个类是从另一个类继承而来的，形式如下：
class 父类{ } class 子类 extends 父类{ } 3.作用 为什么需要继承类呢？接下来我们举一个例子来说明：
比如说，有一个电脑类，其中有两种品牌联想和惠普，要求如下：
联想 属性：品牌名 方法：游戏
惠普 属性：品牌名 方法：游戏
代码示例如下：
联想类：
public class Legend { private String name; public void setName(String name) { this.name = name; } public String getName() { return name; } public void game() { System.out.println(name&#43;&#34;可以游戏&#34;); } } 惠普类：
public class Hp { private String name; public void setName(String name) { this." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/6a64c93292f5beea5f5c04a5436fc9b1/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-03-29T23:10:50+08:00" />
<meta property="article:modified_time" content="2023-03-29T23:10:50+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java类的继承</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%C2%A01.%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF%E6%A6%82%E5%BF%B5%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0-toc" style="margin-left:0px;"><a href="#%C2%A01.%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF%E6%A6%82%E5%BF%B5%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0" rel="nofollow">1.类的继承概念       </a></p> 
<p id="1.%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF%E6%A0%BC%E5%BC%8F-toc" style="margin-left:0px;"><a href="#1.%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF%E6%A0%BC%E5%BC%8F" rel="nofollow">2.类的继承格式</a></p> 
<p id="2.%E4%BD%9C%E7%94%A8-toc" style="margin-left:0px;"><a href="#2.%E4%BD%9C%E7%94%A8" rel="nofollow">3.作用</a></p> 
<p id="3.%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99-toc" style="margin-left:0px;"><a href="#3.%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99" rel="nofollow">4.方法重写</a></p> 
<p id="4.%E8%87%AA%E5%8A%A8%E8%BD%AC%E5%9E%8B%EF%BC%88%E5%90%91%E4%B8%8A%E8%BD%AC%E5%9E%8B%EF%BC%89-toc" style="margin-left:0px;"><a href="#4.%E8%87%AA%E5%8A%A8%E8%BD%AC%E5%9E%8B%EF%BC%88%E5%90%91%E4%B8%8A%E8%BD%AC%E5%9E%8B%EF%BC%89" rel="nofollow">5.自动转型（向上转型）</a></p> 
<p style="margin-left:0px;"></p> 
<h2 id="%C2%A01.%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF%E6%A6%82%E5%BF%B5%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0">1.类的继承概念       </h2> 
<p>        类的继承就是子类继承父类的属性和方法，使得子类具有与父类相同的属性和方法。</p> 
<p>        举一个生活中的例子就是：汽车属于一个类，汽车品牌奥迪、奔驰就属于其子类，其具有汽车的一般特性，但二者在性能上也有一定的差别。所以子类会具有父类的一般特性，也会具有其自身的特性。</p> 
<h2 id="1.%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF%E6%A0%BC%E5%BC%8F">2.类的继承格式</h2> 
<p>        在Java中通过extends关键字可以生命一个类是从另一个类继承而来的，形式如下：</p> 
<pre><code class="language-java">class 父类{

}
class 子类 extends 父类{

}</code></pre> 
<h2 id="2.%E4%BD%9C%E7%94%A8">3.作用</h2> 
<p>        为什么需要继承类呢？接下来我们举一个例子来说明：</p> 
<p>         比如说，有一个电脑类，其中有两种品牌联想和惠普，要求如下：</p> 
<p>                                联想 属性：品牌名  方法：游戏</p> 
<p>                                惠普 属性：品牌名 方法：游戏</p> 
<p>代码示例如下：</p> 
<p> 联想类：</p> 
<pre><code class="language-java">public class Legend {
	private String name;
    
    public void setName(String name) {
    	this.name = name;
    }
    public String getName() {
    	return name;
    }
    public void game() {
    	System.out.println(name+"可以游戏");
    }
}</code></pre> 
<p>惠普类：</p> 
<pre><code class="language-java">public class Hp {
	private String name;
    
    public void setName(String name) {
    	this.name = name;
    }
    public String getName() {
    	return name;
    }
    public void game() {
    	System.out.println(name+"可以游戏");
    }
}</code></pre> 
<p>        从这两段代码可以看出来，代码重复了，这样会导致代码量大且繁琐，后期对代码的维护不方便，要解决这个问题就需要用到继承，就是将两端代码中相同的部分提取出来组成一个父类。</p> 
<p>公共父类代码：</p> 
<pre><code class="language-java">public class Computer {
	private String name;
    
    public void setName(String name) {
    	this.name = name;
    }
    public String getName() {
    	return name;
    }
    public void game() {
    	System.out.println(name+"可以游戏");
    }
}
</code></pre> 
<p>        这样Computer就可以作为一个父类，用联想类和惠普类继承这个类之后，就具有父类当中的属性和方法，代码更加简洁。继承之后的代码：</p> 
<p>联想类：</p> 
<pre><code class="language-java">public class Legend extends Computer{

}</code></pre> 
<p>惠普类：</p> 
<pre><code class="language-java">public class Hp extends Computer{

}</code></pre> 
<p>        此时两段代码中没有内容，但在主函数中使用Legend的类创建对象，发现其拥有父类中的属性和方法。注：（同包下）子类会继承父类中的所有属性和方法，但私有属性和方法不能直接使用。</p> 
<pre><code class="language-java">public class Manage {
    public static void main(String[] args) {
    	Legend le = new Legend();
    	le.setName("联想");
    	le.game();
    }
}
</code></pre> 
<p>运行结果如下：</p> 
<p> <img alt="" height="107" src="https://images2.imgbox.com/c7/cf/iMcpwXyu_o.png" width="561"></p> 
<p>        <span style="background-color:#cccccc;">注：Java不支持多继承，即一个子类不可以同时继承两个父类，但支持多层次继承，简单来说，子类可以拥有父类，其父类也可以拥有父类。</span></p> 
<h2 id="3.%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99">4.方法重写</h2> 
<p>        由于子类在拥有父类共性的同时也拥有部分独有的属性和方法，因此有时需要对父类中的方法进行改造，这就叫做方法重写。</p> 
<p>        方法重写的条件：1.必须是两个有继承关系类之间才能进行方法重写 2.返回值类型，方法名，参数类型（个数、顺序）完全一样。</p> 
<p>例如:在Legend类里重写其父类（Computer类）的 public void game 方法：</p> 
<pre><code class="language-java">public class Legend extends Computer{
	public void game() {
		System.out.println("子类重写父类方法");
	}
}</code></pre> 
<p> 重写后，执行结果如下：</p> 
<p><img alt="" height="80" src="https://images2.imgbox.com/31/ca/Yw0d96P6_o.png" width="541"></p> 
<p>      <span style="background-color:#cccccc;">  注：子类方法重写时，访问修饰符访问权限要大于或等于父类。</span></p> 
<p>    （访问修饰符共有四种，分别为：public（公用的）private（私有的）protected(受保护的) 缺省的:返回类型前什么都不写就是缺省的返回修饰符。根据测试访问修饰符权限大小分别为：public&gt;protected&gt;缺省的&gt;private）</p> 
<p>        方法重写时，如果需要保留父类的功能，在父类原有功能的基础上再增加新的功能，此时需要在重写的方法中调用父类的方法。调用父类方法的关键字super ，其表示当前类的父类对象。</p> 
<p>示例代码如下：</p> 
<pre><code class="language-java">public class Legend extends Computer{
	protected void game() {
		super.game();
		System.out.println("子类重写父类方法");
	}
}
</code></pre> 
<p>执行结果为： </p> 
<p><img alt="" height="96" src="https://images2.imgbox.com/65/97/OOUxEltg_o.png" width="728"></p> 
<h2 id="4.%E8%87%AA%E5%8A%A8%E8%BD%AC%E5%9E%8B%EF%BC%88%E5%90%91%E4%B8%8A%E8%BD%AC%E5%9E%8B%EF%BC%89">5.自动转型（向上转型）</h2> 
<p>        自动转型的形式：在 B extends A 的情况西 可以使用 A a = new B（）；的方法创建对象。</p> 
<p>        例：Comeputer le = new Legend（）；当创建子类对象时，你创建的对象被保存在父类中，就是你创建的对象向上转型，转为父类了。示例代码如下：</p> 
<pre><code class="language-java">public class Manage {
    public static void main(String[] args) {
    	Computer le = new Legend();
    	le.setName("联想");
    	le.game();
    }
}</code></pre> 
<p>        但当你调用e.game()时，你会发现，其运行时调用的方法仍然为子类中的方法，这是因为它运行时会从父类开始检索是否定义过该方法，如果定义过，会接着在子类中检索是否重写过该方法，如果发现其已经重写，则优先调用子类中的方法。 </p> 
<p>        自动转型带来的问题：自动转型后的对象只能调用子类中重写的方法。在下面的示例中由于work方法是子类Legend中独有的方法，因此le对象在其转型为Computer类之后调用该方法时会报错。</p> 
<p><img alt="" height="205" src="https://images2.imgbox.com/35/22/bwC0pHSh_o.png" width="484"></p> 
<p> <img alt="" height="184" src="https://images2.imgbox.com/89/21/qJCptv81_o.png" width="493"></p> 
<p> </p> 
<p>        解决这个问题的方法就是强制转型（向下转型）</p> 
<p>示例代码如下：</p> 
<pre><code class="language-java">public class Manage {
    public static void main(String[] args) {
    	Computer le = new Legend();
    	le.setName("联想");
    	le.game();
    	Legend leg = (Legend)le;//强制转型
    	leg.work();//调用work（）方法
    }
}
</code></pre> 
<p>        进行强制转型后就可以调用work方法，但记住：<span style="background-color:#cccccc;">强制转型的前提是该对象自动转型过。</span></p> 
<p>        到这里解释完自动转型的概念，接下来介绍一下其在java中的实际应用场景：比如说有一个学生，他游戏使用的电脑既可以联想也可以是惠普。我们现在创建一个学生类，此时在Student类中，就需要创建两个方法，代码示例如下：当他使用的电脑类型越多，随之创建的方法也越多，但由于其功能相同，代码段也会不断重复。</p> 
<pre><code class="language-java">public class Student {
	public void use(Legend name) {
		name.game();
	}
	public void use(Hp name) {
		name.game();
	}
}
</code></pre> 
<p>        为使代码简化，可以应用自动转型的功能，传入参数的类型使用其父类的类型，当你创建子类对象调用该方法时，该对象会自动转型成为其父类类型，这样当多个子类对象需要调用同一方法时，就可以只写一个方法，而不是多个，从而达到简化代码的目的。</p> 
<pre><code class="language-java">public class Student {
	public void use(Computer name) {//传入参数类型使用父类类型
		name.game();
	}
}
</code></pre> 
<pre><code class="language-java">public class Manage {
    public static void main(String[] args) {
    	Legend le = new Legend();
    	le.setName("联想");
    	
    	Hp hp = new Hp();
    	hp.setName("惠普");
    	
    	Student st = new Student();
    	st.use(le);//调用该方法时原来为Legend类型的le转型成为Computer类
    	st.use(hp);//同样的，原Hp类的参数hp转型成为Computer类
    }
}
</code></pre> 
<p>        最后补充一个知识：任何一个类，都可以调用一些方法，这是因为java中每个类都会默认继承Object类 。</p> 
<p><img alt="" height="182" src="https://images2.imgbox.com/80/04/nRjLgzua_o.png" width="309"><img alt="" height="180" src="https://images2.imgbox.com/9b/d2/oJxb2kSo_o.png" width="351"></p> 
<p> </p> 
<p> </p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/cdb5a038681bd141271a25220033cce1/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">深入浅出Java线程池Worker类</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a1372506697f75754bab42d49fccca16/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">解决使用FastJson将Redis中的对象进行反序列化时出现报错的问题</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>