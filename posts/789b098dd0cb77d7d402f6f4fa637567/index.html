<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>ajax、axios、fetch优缺点对比 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="ajax、axios、fetch优缺点对比" />
<meta property="og:description" content="1.jQuery ajax
Ajax即“Asynchronous Javascript And XML”（异步 JavaScript 和 XML），是指一种创建交互式网页应用的网页开发技术。
用法：
$.ajax({ type: &#39;POST&#39;, url: url, data: data, dataType: dataType, success: function () {}, error: function () {} }); 本身虽然简单，但常常会涉及到一些问题：如
CSRF攻击
CSRF（Cross-site request forgery）跨站请求伪造，也被称为“One Click Attack”或者Session Riding，通常缩写为CSRF或者XSRF，是一种对网站的恶意利用。
通过这6个步骤达到攻击的目的。
XSS攻击
Cross-Site Scripting（跨站脚本攻击）简称 XSS，是一种代码注入攻击。攻击者通过在目标网站上注入恶意脚本，使之在用户的浏览器上运行。利用这些恶意脚本，攻击者可获取用户的敏感信息如 Cookie、SessionID 等，进而危害数据安全。
为了和 CSS 区分，这里把攻击的第一个字母改成了 X，于是叫做 XSS。
XSS 的本质是：恶意代码未经过滤，与网站正常的代码混在一起；浏览器无法分辨哪些脚本是可信的，导致恶意脚本被执行。
而由于直接在用户的终端执行，恶意代码能够直接获取用户的信息，或者利用这些信息冒充用户向网站发起攻击者定义的请求。
简单的解决方法：
1、将能被转换为html的输入内容，在写代码时改为innerText而不用innerHTML。（过滤用户输入的 检查用户输入的内容中是否有非法内容。如&lt;&gt;（尖括号）、”（引号）、 ‘（单引号）、%（百分比符号）、;（分号）、()（括号）、&amp;（&amp; 符号）、&#43;（加号）等。、严格控制输出。）
2、实在没有办法的情况下可用如下方法（js代码）
function safeStr(str){ return str.replace(/&lt;/g,&#39;&amp;lt;&#39;).replace(/&gt;/g,&#39;&amp;gt;&#39;).replace(/&#34;/g, &#34;&amp;quot;&#34;).replace(/&#39;/g, &#34;&amp;#039;&#34;); } （表单提交或者url参数传递前，对需要的参数进行过滤,请看如下XSS过滤工具类代码） 将含有&lt;&gt;等符号转化为其他字符简单方便。
优缺点：
本身是针对MVC的编程,不符合现在前端MVVM的浪潮基于原生的XHR开发，XHR本身的架构不清晰，已经有了fetch的替代方案。JQuery整个项目太大，单纯使用ajax却要引入整个JQuery非常的不合理（采取个性化打包的方案又不能享受CDN服务）。 2.axios" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/789b098dd0cb77d7d402f6f4fa637567/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-12-10T14:53:33+08:00" />
<meta property="article:modified_time" content="2021-12-10T14:53:33+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">ajax、axios、fetch优缺点对比</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><strong>1.jQuery ajax</strong><br> Ajax即“Asynchronous Javascript And XML”（异步 JavaScript 和 XML），是指一种创建交互式网页应用的网页开发技术。</p> 
<p>用法：</p> 
<pre><code>$.ajax({
   type: 'POST',
   url: url,
   data: data,
   dataType: dataType,
   success: function () {},
   error: function () {}
});
</code></pre> 
<p>本身虽然简单，但常常会涉及到一些问题：如</p> 
<p><strong>CSRF攻击</strong><br> CSRF（Cross-site request forgery）跨站请求伪造，也被称为“One Click Attack”或者Session Riding，通常缩写为CSRF或者XSRF，是一种对网站的恶意利用。<br> <img src="https://images2.imgbox.com/00/3a/koPvBqPr_o.png" alt="在这里插入图片描述"><br> 通过这6个步骤达到攻击的目的。</p> 
<p><strong>XSS攻击</strong><br> Cross-Site Scripting（跨站脚本攻击）简称 XSS，是一种代码注入攻击。攻击者通过在目标网站上注入恶意脚本，使之在用户的浏览器上运行。利用这些恶意脚本，攻击者可获取用户的敏感信息如 Cookie、SessionID 等，进而危害数据安全。</p> 
<p>为了和 CSS 区分，这里把攻击的第一个字母改成了 X，于是叫做 XSS。</p> 
<p>XSS 的本质是：恶意代码未经过滤，与网站正常的代码混在一起；浏览器无法分辨哪些脚本是可信的，导致恶意脚本被执行。</p> 
<p>而由于直接在用户的终端执行，恶意代码能够直接获取用户的信息，或者利用这些信息冒充用户向网站发起攻击者定义的请求。<br> <img src="https://images2.imgbox.com/1e/ef/1tbePX74_o.png" alt="在这里插入图片描述"><br> <strong>简单的解决方法：</strong><br> 1、将能被转换为html的输入内容，在写代码时改为innerText而不用innerHTML。（过滤用户输入的 检查用户输入的内容中是否有非法内容。如&lt;&gt;（尖括号）、”（引号）、 ‘（单引号）、%（百分比符号）、;（分号）、()（括号）、&amp;（&amp; 符号）、+（加号）等。、严格控制输出。）</p> 
<p>2、实在没有办法的情况下可用如下方法（js代码）</p> 
<pre><code>function safeStr(str){
return str.replace(/&lt;/g,'&amp;lt;').replace(/&gt;/g,'&amp;gt;').replace(/"/g, "&amp;quot;").replace(/'/g, "&amp;#039;");
}
（表单提交或者url参数传递前，对需要的参数进行过滤,请看如下XSS过滤工具类代码）
</code></pre> 
<p>将含有&lt;&gt;等符号转化为其他字符简单方便。</p> 
<p>优缺点：</p> 
<ul><li>本身是针对MVC的编程,不符合现在前端MVVM的浪潮</li><li>基于原生的XHR开发，XHR本身的架构不清晰，已经有了fetch的替代方案。</li><li>JQuery整个项目太大，单纯使用ajax却要引入整个JQuery非常的不合理（采取个性化打包的方案又不能享受CDN服务）。</li></ul> 
<p><strong>2.axios</strong><br> axios 基于promise用于浏览器和node.js的http客户端。</p> 
<p>用法：</p> 
<pre><code>axios({
    method: 'post',
    url: '/user/12345',
    data: {
        firstName: 'Fred',
        lastName: 'Flintstone'
    }
})
.then(function (response) {
    console.log(response);
})
.catch(function (error) {
    console.log(error);
});
</code></pre> 
<p>优缺点：</p> 
<ul><li>从 node.js 创建 http 请求。</li><li>支持 Promise API。</li><li>提供了一些并发请求的接口（重要，方便了很多的操作）。</li><li>在浏览器中创建 XMLHttpRequests。</li><li>在 node.js 则创建 http 请求。（自动性强）</li><li>支持 Promise API。</li><li>支持拦截请求和响应。</li><li>转换请求和响应数据。</li><li>取消请求。</li><li>自动转换 JSON 数据。</li><li>客户端支持防止CSRF。</li><li>客户端支持防御 XSRF。</li></ul> 
<p><strong>3.fetch</strong><br> fetch号称是AJAX的替代品，是在ES6出现的，使用了ES6中的promise对象。Fetch是基于promise设计的。Fetch的代码结构比起ajax简单多了，参数有点像jQuery ajax。但是，一定记住fetch不是ajax的进一步封装，而是原生js，没有使用XMLHttpRequest对象。（然而问题还是有很多）</p> 
<p>用法：</p> 
<pre><code>try {
  let response = await fetch(url);
  let data = response.json();
  console.log(data);
} catch(e) {
  console.log("Oops, error", e);
}
</code></pre> 
<p>优缺点：</p> 
<ul><li>符合关注分离，没有将输入、输出和用事件来跟踪的状态混杂在一个对象里</li><li>更好更方便的写法</li><li>更加底层，提供的API丰富（request, response）</li><li>脱离了XHR，是ES规范里新的实现方式</li><li>fetchtch只对网络请求报错，对400，500都当做成功的请求，需要封装去处理</li><li>fetch默认不会带cookie，需要添加配置项</li><li>fetch不支持abort，不支持超时控制，使用setTimeout及Promise.reject的实现的超时控制并不能阻止请求过程继续在后台运行，造成了量的浪费</li><li>fetch没有办法原生监测请求的进度，而XHR可以。</li></ul> 
<p><strong>为什么要用axios?</strong><br> axios 是一个基于Promise 用于浏览器和 nodejs 的 HTTP 客户端，它本身具有以下特征：</p> 
<ul><li>从浏览器中创建 XMLHttpRequest</li><li>从 node.js 发出 http 请求</li><li>支持 Promise API</li><li>拦截请求和响应</li><li>转换请求和响应数据</li><li>取消请求</li><li>自动转换JSON数据</li><li>客户端支持防止CSRF/XSRF</li><li>axios既提供了并发的封装，也没有fetch的各种问题，而且体积也较小，当之无愧现在最应该选用的请求的方式。</li></ul> 
<p>三选一绝必是axios了。其流程图如下：<br> <img src="https://images2.imgbox.com/79/0c/W3CEgZEc_o.png" alt="在这里插入图片描述"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/710e44de8e810290bc806b3ad9eadaba/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">springboot启动后自动退出</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/53b9d81e7a89f5b5cda42d2fb0f3048f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">钉钉api推送markdown群消息格式不起作用</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>