<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>域名服务器从k8s访问不稳定,k8s与dns--coredns的一些实战经验 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="域名服务器从k8s访问不稳定,k8s与dns--coredns的一些实战经验" />
<meta property="og:description" content="coredns简介
安装新版本k8s，coredns已经成为默认dns了。之前是kube-dns。coredns是一个灵活，可扩展的DNS服务器，可以作为Kubernetes集群DNS。与Kubernetes一样，CoreDNS项目由CNCF主持。但是在实际使用中，需要一些注意的地方。
增加应用的反亲和性，防止coredns调度到一台主机上
coredns 所需要的资源非常小，所以很容易调度到一台主机上。coredns是一个系统组件，我们应该尽量让coredns分散部署，增强其可用性。故在deployment的yaml中增加如下设置：
affinity:
podAntiAffinity:
requiredDuringSchedulingIgnoredDuringExecution:
- labelSelector:
matchExpressions:
- key: app
operator: In
values:
- coredns
topologyKey: kubernetes.io/hostname
这里利用到了k8s的一个属性反亲和性。
选择合理的coredns 伸缩
很多k8s部署，默认是部署两个coredns 实例，但是当我们集群逐步变大的时候，2个实例是不能满足需求的。因而coredns的伸缩就非常重要了。切记coredns 千万不要用hpa来弹性伸缩coredns。频繁的伸缩，会导致业务很多dns解析失败的情况。需要用cluster-proportional-autoscaler组件，我一般是选择根据node节点数来伸缩dns。具体的伸缩策略大家可以选择。
如何利用coredns 禁用ipv6的解析
如果K8S集群宿主机没有关闭IPV6内核模块的话，容器请求coredns时的默认行为是同时发起IPV4和IPV6解析。
由于我们通常只使用IPV4地址，或者是你对主机环境暂无支持ipv6，那么实际的业务场景中，AAAA解析成功返回来的IPv6地址，是会访问失败的。如下：
2019/09/06 18:12:37 [error] 37#0: *265 connect() to [2404:6800:4003:c03::5f]:443 failed (101: Network is unreachable), client: 100.125.198.131, server: , request: &#34;POST /user/google/signin HTTP/1.1&#34;, host: &#34;user.inner.xxx.com&#34;
2019/09/06 18:12:37 [error] 37#0: *265 [lua] http_util.lua:49: http_get(): http request error, url = https://www.googleapis.com/oauth2/v1/userinfo?access_token=ya29.Glt7B5qqIHMVkyJNSmE32jGAo-hkEgIyK2CzMcO0ksrXcCZSMts4VcBoY-uNQmXdEhb8QJQAhVsv-5LxESalKNiD7rJrBgYJgfV-z81No9a_vwW59RgBEvYJMAAr; request headers = null ; request body = ; error = network is unreachable, client: 100." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/059dbb51c1f51f1a9776e291a14da671/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-08-12T21:34:49+08:00" />
<meta property="article:modified_time" content="2021-08-12T21:34:49+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">域名服务器从k8s访问不稳定,k8s与dns--coredns的一些实战经验</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div style="font-size:16px;"> 
 <p>coredns简介</p> 
 <p>安装新版本k8s，coredns已经成为默认dns了。之前是kube-dns。coredns是一个灵活，可扩展的DNS服务器，可以作为Kubernetes集群DNS。与Kubernetes一样，CoreDNS项目由CNCF主持。但是在实际使用中，需要一些注意的地方。</p> 
 <p>增加应用的反亲和性，防止coredns调度到一台主机上</p> 
 <p>coredns 所需要的资源非常小，所以很容易调度到一台主机上。coredns是一个系统组件，我们应该尽量让coredns分散部署，增强其可用性。故在deployment的yaml中增加如下设置：</p> 
 <p>affinity:</p> 
 <p>podAntiAffinity:</p> 
 <p>requiredDuringSchedulingIgnoredDuringExecution:</p> 
 <p>- labelSelector:</p> 
 <p>matchExpressions:</p> 
 <p>- key: app</p> 
 <p>operator: In</p> 
 <p>values:</p> 
 <p>- coredns</p> 
 <p>topologyKey: kubernetes.io/hostname</p> 
 <p>这里利用到了k8s的一个属性反亲和性。</p> 
 <p>选择合理的coredns 伸缩</p> 
 <p>很多k8s部署，默认是部署两个coredns 实例，但是当我们集群逐步变大的时候，2个实例是不能满足需求的。因而coredns的伸缩就非常重要了。切记coredns 千万不要用hpa来弹性伸缩coredns。频繁的伸缩，会导致业务很多dns解析失败的情况。需要用cluster-proportional-autoscaler组件，我一般是选择根据node节点数来伸缩dns。具体的伸缩策略大家可以选择。</p> 
 <p>如何利用coredns 禁用ipv6的解析</p> 
 <p>如果K8S集群宿主机没有关闭IPV6内核模块的话，容器请求coredns时的默认行为是同时发起IPV4和IPV6解析。</p> 
 <p>由于我们通常只使用IPV4地址，或者是你对主机环境暂无支持ipv6，那么实际的业务场景中，AAAA解析成功返回来的IPv6地址，是会访问失败的。如下：</p> 
 <p>2019/09/06 18:12:37 [error] 37#0: *265 connect() to [2404:6800:4003:c03::5f]:443 failed (101: Network is unreachable), client: 100.125.198.131, server: , request: "POST /user/google/signin HTTP/1.1", host: "user.inner.xxx.com"</p> 
 <p>2019/09/06 18:12:37 [error] 37#0: *265 [lua] http_util.lua:49: http_get(): http request error, url = https://www.googleapis.com/oauth2/v1/userinfo?access_token=ya29.Glt7B5qqIHMVkyJNSmE32jGAo-hkEgIyK2CzMcO0ksrXcCZSMts4VcBoY-uNQmXdEhb8QJQAhVsv-5LxESalKNiD7rJrBgYJgfV-z81No9a_vwW59RgBEvYJMAAr; request headers = null ; request body = ; error = network is unreachable, client: 100.125.198.131, server: , request: "POST /user/google/signin HTTP/1.1", host: "user.inner.xxx.com"</p> 
 <p>所以此时如果我们仅仅在coredns中配置DOMAIN -&gt; IPV4地址的解析的话，当coredns收到IPV6解析请求的时候就会因为本地找不到配置而foward到upstream DNS服务器解析，从而导致容器的DNS解析请求变慢。</p> 
 <p>coredns提供了一种plugin叫做template，经过配置后可以给所有的IPV6请求立即返回一个空结果的应答，避免请求forward到上游DNS。</p> 
 <p>而对于业务来说，ipv6解析不成功，会降级到ipv4的A解析。</p> 
 <p>template插件默认是在coredns启用的，只需要在配置文件中添加如下配置即可：</p> 
 <p>template ANY AAAA {<!-- --></p> 
 <p>rcode NXDOMAIN</p> 
 <p>}</p> 
 <p>coredns 配置stub domain和upstream nameserver</p> 
 <p>在实际场景中，我们经常会有自己的内部dns服务器，例如我们的Consul域服务器位于10.150.0.1，并且所有Consul名称都具有后缀.consul.local。要在CoreDNS中配置它，集群管理员在CoreDNS ConfigMap中创建以下配置：</p> 
 <p>consul.local:53 {<!-- --></p> 
 <p>errors</p> 
 <p>cache 30</p> 
 <p>forward . 10.150.0.1</p> 
 <p>}</p> 
 <p>有疑问加站长微信联系(非本文作者)</p> 
 <p align="center"></p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d3da440fcf2562216b224ed689681c8d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">虚拟主机换服务器,虚拟主机怎么换服务器吗</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/528150f7a6ff9aaf7df8d8289fb4a879/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">ASP.NET Core初步使用Quartz.NET</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>