<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【GDB】 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【GDB】" />
<meta property="og:description" content="GDB VX：hao541022348 1. GDB调试器1.1 前言1.2 GDB编译程序1.3 启动GDB1.4 载入被调试程序1.4.1 本地调试1.4.2 远程调试 1.5 查看源码1.6 运行程序1.7 断点设置1.7.1 通过行号设置断点1.7.2 通过函数名设置断点1.7.3 通过条件设置断点1.7.4 查看断点信息1.7.5 删除断点 1.8 单步调试1.9 查看变量1.10 修改变量1.11 设置观察点1.12 打印表达式1.13 查看运行信息1.14 分割窗口 2. GDB调试core文件2.1 设定core文件的最大值2.2 临时修改core文件的生成路径2.2.1 示例一：除数设为02.2.2 示例二：这里scanf后的参数没有加&amp; 2.3 1. GDB调试器 1.1 前言 GDB是GNU调试器（GNU Debugger）的缩写，是一种功能强大的调试工具，可以用于调试多种编程语言的程序，如C、C&#43;&#43;、汇编等。GDB可以帮助程序员在程序运行时进行调试，包括查看变量的值、跟踪程序执行流程、设置断点等。
GDB支持多种操作系统，包括Linux、Unix、Windows等。
1.2 GDB编译程序 文件编译
g&#43;&#43; main.cpp -o main带有GDB debug功能，编译
g&#43;&#43; -g main.cpp -o main查看可执行文件是否带有debug功能
readelf -S main | grep debug
1.3 启动GDB 1.4 载入被调试程序 1.4.1 本地调试 ~#gdb ./build
1.4.2 远程调试 远程调试需要两个GDB程序，运行在远程设备（target）上的程序称之为gdbserver，运行在本地主机host上的gdb程序为交叉编译器，即在x86平台上运行arm平台的gdb程序，记作gdb_client" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/3f711bc77ece6196c43da89985409f64/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-03T13:30:43+08:00" />
<meta property="article:modified_time" content="2024-01-03T13:30:43+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【GDB】</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>GDB VX：hao541022348</h4> 
 <ul><li><a href="#1_GDB_1" rel="nofollow">1. GDB调试器</a></li><li><ul><li><a href="#11__2" rel="nofollow">1.1 前言</a></li><li><a href="#12_GDB_5" rel="nofollow">1.2 GDB编译程序</a></li><li><a href="#13_GDB_13" rel="nofollow">1.3 启动GDB</a></li><li><a href="#14__15" rel="nofollow">1.4 载入被调试程序</a></li><li><ul><li><a href="#141__16" rel="nofollow">1.4.1 本地调试</a></li><li><a href="#142__22" rel="nofollow">1.4.2 远程调试</a></li></ul> 
   </li><li><a href="#15__39" rel="nofollow">1.5 查看源码</a></li><li><a href="#16__50" rel="nofollow">1.6 运行程序</a></li><li><a href="#17__67" rel="nofollow">1.7 断点设置</a></li><li><ul><li><a href="#171__81" rel="nofollow">1.7.1 通过行号设置断点</a></li><li><a href="#172__83" rel="nofollow">1.7.2 通过函数名设置断点</a></li><li><a href="#173__85" rel="nofollow">1.7.3 通过条件设置断点</a></li><li><a href="#174__90" rel="nofollow">1.7.4 查看断点信息</a></li><li><a href="#175__94" rel="nofollow">1.7.5 删除断点</a></li></ul> 
   </li><li><a href="#18__97" rel="nofollow">1.8 单步调试</a></li><li><a href="#19__108" rel="nofollow">1.9 查看变量</a></li><li><a href="#110__122" rel="nofollow">1.10 修改变量</a></li><li><a href="#111__124" rel="nofollow">1.11 设置观察点</a></li><li><a href="#112__128" rel="nofollow">1.12 打印表达式</a></li><li><a href="#113__142" rel="nofollow">1.13 查看运行信息</a></li><li><a href="#114__152" rel="nofollow">1.14 分割窗口</a></li></ul> 
  </li><li><a href="#2_GDBcore_163" rel="nofollow">2. GDB调试core文件</a></li><li><ul><li><a href="#21_core_164" rel="nofollow">2.1 设定core文件的最大值</a></li><li><a href="#22_core_169" rel="nofollow">2.2 临时修改core文件的生成路径</a></li><li><ul><li><a href="#221_0_172" rel="nofollow">2.2.1 示例一：除数设为0</a></li><li><a href="#222__scanf_189" rel="nofollow">2.2.2 示例二：这里scanf后的参数没有加&amp;</a></li></ul> 
   </li><li><a href="#23_200" rel="nofollow">2.3</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="1_GDB_1"></a>1. GDB调试器</h2> 
<h3><a id="11__2"></a>1.1 前言</h3> 
<p><strong>GDB是GNU调试器（GNU Debugger）的缩写，是一种功能强大的调试工具，可以用于调试多种编程语言的程序，如C、C++、汇编等。GDB可以帮助程序员在程序运行时进行调试，包括查看变量的值、跟踪程序执行流程、设置断点等。</strong><br> GDB支持多种操作系统，包括Linux、Unix、Windows等。</p> 
<h3><a id="12_GDB_5"></a>1.2 GDB编译程序</h3> 
<ul><li>文件编译<br> g++ main.cpp -o main</li><li>带有GDB debug功能，编译<br> g++ -g main.cpp -o main</li><li>查看可执行文件是否带有debug功能<br> readelf -S main | grep debug<br> <img src="https://images2.imgbox.com/9a/f3/3mmuoHe3_o.png" alt="在这里插入图片描述"></li></ul> 
<h3><a id="13_GDB_13"></a>1.3 启动GDB</h3> 
<p><img src="https://images2.imgbox.com/8d/eb/mQO0Xu8y_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="14__15"></a>1.4 载入被调试程序</h3> 
<h4><a id="141__16"></a>1.4.1 本地调试</h4> 
<p>~#gdb ./build</p> 
<p><img src="https://images2.imgbox.com/5b/67/M5iXnsDa_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="142__22"></a>1.4.2 远程调试</h4> 
<p>远程调试需要两个GDB程序，运行在远程设备（target）上的程序称之为gdbserver，运行在本地主机host上的gdb程序为交叉编译器，即在x86平台上运行arm平台的gdb程序，记作gdb_client<br> 远程设备 target gdbserver<br> 本地主机 host gdb</p> 
<ol><li> <p>嵌入式设备执行：~#./gdbserver 192.168.10.2:1234 ./build<br> 其中192.168.10.2表示允许从这个IP地址登录道嵌入式设备，一般我们的PC服务器地址，也尅省略，表示允许从任何IP连入，:1234为端口号，build为即将调试的应用程序。</p> </li><li> <p>PC端执行：<br> ~#arm-linux-gdb ./build_Debug<br> handle SIGPIPE SIGUSR2 SIG32 nostop noprint<br> target remote 172.8.4.11:1234 //与服务端建立关联<br> 其中172.8.4.11为当前嵌入式设备的IP地址，:1234位端口，必须与嵌入式设备运行时指定的端口一直，两者均为必填项，不能省略。<br> 注：</p> </li></ol> 
<ul><li>设备端无需输入build_Debug ，否则加载会非常慢</li><li>由于设备端内存等的原因，一般情况下我们都是使用远程调试</li></ul> 
<h3><a id="15__39"></a>1.5 查看源码</h3> 
<table><thead><tr><th align="left">属性</th><th align="left">描述</th><th align="left">示例</th></tr></thead><tbody><tr><td align="left">list ：简记为其作用就是列出程序的源代码，默认每次显示10行。</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">list 行号：</td><td align="left">将显示当前文件以“行号”为中心的前后10行代码，</td><td align="left">如：list 12</td></tr><tr><td align="left">list 函数名：</td><td align="left">将显示“函数名”所在函数的源代码，</td><td align="left">如：list main</td></tr><tr><td align="left">list 不带参数：</td><td align="left">将接着上一次 list 命令的，输出下边的内容。</td><td align="left"></td></tr></tbody></table> 
<p>list / l [first, last]（行号）<br> <img src="https://images2.imgbox.com/ef/a1/a2DGkzWe_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="16__50"></a>1.6 运行程序</h3> 
<p>运行命令</p> 
<table><thead><tr><th align="left">属性</th><th align="left">描述</th><th align="left">示例</th></tr></thead><tbody><tr><td align="left">run：</td><td align="left">简记为 r ，</td><td align="left">其作用是运行程序，当遇到断点后，程序会在断点处停止运行，等待用户输入下一步的命令。</td></tr><tr><td align="left">continue</td><td align="left">（简写c ）：</td><td align="left">继续执行，到下一个断点处（或运行结束）</td></tr><tr><td align="left">next：</td><td align="left">（简写 n）</td><td align="left">单步跟踪程序，当遇到函数调用时，也不进入此函数体；此命令同 step 的主要区别是，step 遇到用户自定义的函数，将步进到函数中去运行，而 next 则直接调用函数，不会进入到函数体内。</td></tr><tr><td align="left">step</td><td align="left">（简写s）：</td><td align="left">单步调试如果有函数调用，则进入函数；与命令n不同，n是不进入调用的函数的</td></tr><tr><td align="left">until：</td><td align="left"></td><td align="left">当你厌倦了在一个循环体内单步跟踪时，这个命令可以运行程序直到退出循环体。</td></tr><tr><td align="left">until+行号:</td><td align="left"></td><td align="left">运行至某行，不仅仅用来跳出循环</td></tr><tr><td align="left">finish：</td><td align="left"></td><td align="left">运行程序，直到当前函数完成返回，并打印函数返回时的堆栈地址和返回值及参数值等信息。</td></tr><tr><td align="left">call 函数(参数)：</td><td align="left"></td><td align="left">调用程序中可见的函数，并传递“参数”， 如：call gdb_test(55)</td></tr><tr><td align="left">quit：</td><td align="left">简记为 q ，</td><td align="left">退出gdb</td></tr></tbody></table> 
<p>run / r<br> <img src="https://images2.imgbox.com/eb/30/ckSkYb83_o.png" alt="在这里插入图片描述"><br> 若程序运行时需要参数,在run命令后加上参数即可.</p> 
<h3><a id="17__67"></a>1.7 断点设置</h3> 
<table><thead><tr><th align="left">属性</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">break n （简写b n）:</td><td align="left">在第n行处设置断点（可以带上代码路径和代码名称： b OAGUPDATE.cpp:578）</td></tr><tr><td align="left">b fn1 if a＞b：</td><td align="left">条件断点设置</td></tr><tr><td align="left">break func（break缩写为b）：</td><td align="left">在函数func()的入口处设置断点，如：break cb_button</td></tr><tr><td align="left">delete 断点号n：</td><td align="left">删除第n个断点</td></tr><tr><td align="left">disable 断点号n：</td><td align="left">暂停第n个断点</td></tr><tr><td align="left">enable 断点号n：</td><td align="left">开启第n个断点</td></tr><tr><td align="left">clear 行号n：</td><td align="left">清除第n行的断点</td></tr><tr><td align="left">info b （info breakpoints） ：</td><td align="left">显示当前程序的断点设置情况</td></tr><tr><td align="left">delete breakpoints：</td><td align="left">清除所有断点：</td></tr></tbody></table> 
<p>break / b 行号/函数名/条件|</p> 
<h4><a id="171__81"></a>1.7.1 通过行号设置断点</h4> 
<p><img src="https://images2.imgbox.com/4e/2f/5kHalSjb_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="172__83"></a>1.7.2 通过函数名设置断点</h4> 
<p><img src="https://images2.imgbox.com/8a/98/7cl12YKD_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="173__85"></a>1.7.3 通过条件设置断点</h4> 
<p>当n &gt; 1时会在OddOrEven函数中停止执行<br> <img src="https://images2.imgbox.com/13/fd/Az7n8O2e_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/3f/1a/eONEnHZm_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="174__90"></a>1.7.4 查看断点信息</h4> 
<p>info breakpoints<br> <img src="https://images2.imgbox.com/c4/3e/bDde12JS_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="175__94"></a>1.7.5 删除断点</h4> 
<p>delete breakpointNum<br> <img src="https://images2.imgbox.com/4b/ae/8hD4q9Hz_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="18__97"></a>1.8 单步调试</h3> 
<table><thead><tr><th align="left">属性</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">step / s:</td><td align="left">每次执行一步，碰到函数会进入函数内部执行</td></tr><tr><td align="left">next / n:</td><td align="left">每次执行一步，碰到函数会一步将函数执行完成（不进入函数内部）</td></tr><tr><td align="left">finish:</td><td align="left">在处于函数内部时，使用该命令会直接将该函数执行完，若函数内部还有其他断点则执行到断点处</td></tr><tr><td align="left">continue / c:</td><td align="left">执行到下一个断点处</td></tr><tr><td align="left">skip:</td><td align="left">设置跳过执行某一个函数，即设置之后使用step不会进入函数内部</td></tr></tbody></table> 
<p><img src="https://images2.imgbox.com/b5/7b/wPb3dPAt_o.png" alt="在这里插入图片描述"><br> 删除skip: skip delete [num]</p> 
<h3><a id="19__108"></a>1.9 查看变量</h3> 
<p>print / p<br> 命令格式：p/格式 变量；</p> 
<table><thead><tr><th align="left">格式</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">x</td><td align="left">显示为16进制</td></tr><tr><td align="left">d</td><td align="left">显示为10进制</td></tr><tr><td align="left">u</td><td align="left">显示为无符号10进制</td></tr><tr><td align="left">o</td><td align="left">显示为8进制</td></tr><tr><td align="left">t</td><td align="left">显示为2进制数，t表示two</td></tr><tr><td align="left">a</td><td align="left">地址</td></tr><tr><td align="left">c</td><td align="left">显示为字符</td></tr><tr><td align="left">f</td><td align="left">浮点小数</td></tr><tr><td align="left">s</td><td align="left">显示为字符串</td></tr></tbody></table> 
<h3><a id="110__122"></a>1.10 修改变量</h3> 
<p>set / print 变量名 = 值</p> 
<h3><a id="111__124"></a>1.11 设置观察点</h3> 
<p>（当变量发生变化后，程序暂停执行并将变量的原值和新值都打印出来）<br> watch [变量名]<br> <img src="https://images2.imgbox.com/1f/5c/xztUO4JP_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="112__128"></a>1.12 打印表达式</h3> 
<table><thead><tr><th align="left">属性</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">print 表达式：</td><td align="left">简记为 p ，其中“表达式”可以是任何当前正在被测试程序的有效表达式，比如当前正在调试C语言的程序，那么“表达式”可以是任何C语言的有效表达式，包括数字，变量甚至是函数调用。</td></tr><tr><td align="left">print a：</td><td align="left">将显示整数 a 的值</td></tr><tr><td align="left">print ++a：</td><td align="left">将把 a 中的值加1,并显示出来</td></tr><tr><td align="left">print name：</td><td align="left">将显示字符串 name 的值</td></tr><tr><td align="left">print gdb_test(22)：</td><td align="left">将以整数22作为参数调用 gdb_test() 函数</td></tr><tr><td align="left">print gdb_test(a)：</td><td align="left">将以变量 a 作为参数调用 gdb_test() 函数</td></tr><tr><td align="left">display 表达式：</td><td align="left">在单步运行时将非常有用，使用display命令设置一个表达式后，它将在每次单步进行指令后，紧接着输出被设置的表达式及值。如： display a</td></tr><tr><td align="left">watch 表达式：</td><td align="left">设置一个监视点，一旦被监视的“表达式”的值改变，gdb将强行终止正在被调试的程序。如： watch a</td></tr><tr><td align="left">whatis ：</td><td align="left">查询变量或函数</td></tr><tr><td align="left">info function：</td><td align="left">查询函数</td></tr><tr><td align="left">扩展info locals：</td><td align="left">显示当前堆栈页的所有变量</td></tr></tbody></table> 
<h3><a id="113__142"></a>1.13 查看运行信息</h3> 
<table><thead><tr><th align="left">属性</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">where/bt ：</td><td align="left">当前运行的堆栈列表；</td></tr><tr><td align="left">bt backtrace</td><td align="left">显示当前调用堆栈</td></tr><tr><td align="left">up/down</td><td align="left">改变堆栈显示的深度</td></tr><tr><td align="left">set args 参数:</td><td align="left">指定运行时的参数</td></tr><tr><td align="left">show args：</td><td align="left">查看设置好的参数</td></tr><tr><td align="left">info program：</td><td align="left">来查看程序的是否在运行，进程号，被暂停的原因。</td></tr></tbody></table> 
<h3><a id="114__152"></a>1.14 分割窗口</h3> 
<table><thead><tr><th align="left">属性</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">layout：</td><td align="left">用于分割窗口，可以一边查看代码，一边测试：</td></tr><tr><td align="left">layout src：</td><td align="left">显示源代码窗口</td></tr><tr><td align="left">layout asm：</td><td align="left">显示反汇编窗口</td></tr><tr><td align="left">layout regs：</td><td align="left">显示源代码/反汇编和CPU寄存器窗口</td></tr><tr><td align="left">layout split：</td><td align="left">显示源代码和反汇编窗口</td></tr><tr><td align="left">Ctrl + L：</td><td align="left">刷新窗口</td></tr></tbody></table> 
<hr> 
<h2><a id="2_GDBcore_163"></a>2. GDB调试core文件</h2> 
<h3><a id="21_core_164"></a>2.1 设定core文件的最大值</h3> 
<p>ulimit -c [n]<br> 有参数n为设置，没有参数n为查看，若core文件最大值为0则不会生成coredump<br> <img src="https://images2.imgbox.com/a7/04/q8HAXi4q_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="22_core_169"></a>2.2 临时修改core文件的生成路径</h3> 
<p>echo /root/achen/project/coredump/core.%e.%p&gt; /proc/sys/kernel/core_pattern<br> %e为程序名，%p为进程id</p> 
<h4><a id="221_0_172"></a>2.2.1 示例一：除数设为0</h4> 
<p><img src="https://images2.imgbox.com/ce/68/mXxlQvBn_o.png" alt="在这里插入图片描述"><br> 编译后运行，并将除数设为0<br> 提示核心已转储（coredump），查看coredump目录下，生成了core文件<br> <img src="https://images2.imgbox.com/5b/c7/RpqYU2O8_o.png" alt="在这里插入图片描述"><br> 使用GDB对core进行调试<br> core-file core文件<br> <img src="https://images2.imgbox.com/1d/f0/ltc9uFaP_o.png" alt="在这里插入图片描述"><br> 这里提示信号终止了程序，发成了arithmetic异常（由于除数为0）<br> 查看函数的调用栈帧和层级关系<br> backtrace / bt<br> <img src="https://images2.imgbox.com/8e/90/msZ5KTLL_o.png" alt="在这里插入图片描述"><br> 这里和上面core-file都有一串问号，原因是没加载符号表，解决方案为在core-file之前先载入被调试程序<br> <img src="https://images2.imgbox.com/db/4f/2YhAazVV_o.png" alt="在这里插入图片描述"><br> 调用bt命令<br> <img src="https://images2.imgbox.com/ea/5f/BqZedkon_o.png" alt="在这里插入图片描述"><br> 结果为函数调用的栈帧和层级关系，因为该程序中没有函数调用，所以只有显示main函数，且错误行数为第9行</p> 
<h4><a id="222__scanf_189"></a>2.2.2 示例二：这里scanf后的参数没有加&amp;</h4> 
<p><img src="https://images2.imgbox.com/64/16/QKvuRANO_o.png" alt="在这里插入图片描述"><br> 这里scanf后的参数没有加&amp;<br> 编译后运行<br> <img src="https://images2.imgbox.com/40/76/33KNovx7_o.png" alt="在这里插入图片描述"><br> 发生coredump，查看coredump目录，生成了core文件<br> <img src="https://images2.imgbox.com/38/07/9AK7ILaR_o.png" alt="在这里插入图片描述"><br> 使用GDB进行调试<br> <img src="https://images2.imgbox.com/b0/cc/1reieflR_o.png" alt="在这里插入图片描述"><br> 这里显示信号终止了服务，发生了段错误<br> 查看栈帧和层级关系发现函数调用关系为main-&gt;scanf-&gt;_IO_vfscanf，函数错误为第6行</p> 
<h3><a id="23_200"></a>2.3</h3>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6ca8aeb2003227a582fdb385798ce420/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">TypeScrip快速入门</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4d9dc3fb6d584cd15769a3e91c0a9fe7/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">git教程</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>