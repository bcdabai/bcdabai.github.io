<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>八股文C&#43;&#43;篇（超级全） - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="八股文C&#43;&#43;篇（超级全）" />
<meta property="og:description" content="文章目录 const说说const int *a, int const *a, const int a, int *const a, const int *const a分别是什么，有什么特点。const成员函数const和#define的区别什么const在常量区，什么const在栈区，什么const放入符号表优化 C&#43;&#43;内存分区（五）内存对齐原因什么时候不应该内存对齐？内存对齐的规则 虚函数作用实现纯虚函数虚函数在什么时候调用？大小C&#43;&#43; 中哪些函数不能被声明为虚函数？为什么虚函数不能是模板函数？虚函数表既然希望类的所有对象共享为什么不放在全局区 菱形继承类型转换static_castdynamic_castdynamic_cast和虚函数的区别 reinterpret_castconst_castvolatile关键字 构造函数一大家子拷贝构造函数什么时候调用拷贝构造函数？ 析构函数为什么要用虚的？ 移动构造函数 C&#43;&#43;类内是否可以定义引用？模板类模板实例化模板具体化模板为了解决什么问题？模板的声明和定义为什么不能分开写，要想分开写该怎么做模板特化全特化偏特化 模板在编译时生成的代码是否会相同，生成的相同的代码如何处理 C&#43;&#43; 类对象的初始化顺序STL容器顺序型容器vector第二个模板形参？vector调用resize的时候，如果是元素是一个类，会不会调用这些函数的析构函数？使用Vector需要注意什么？如果扩容时会引发自定义类型挨个复制构造，C&#43;&#43;有什么机制来避免这一点 dequelist 关联式容器setmap红黑树的性质，各种操作时间复杂度 unordered_map哈希表跟红黑树的比较，优缺点、适用场合，各种操作的时空复杂度 空间配置器定义背景实现迭代器迭代器用过吗？什么时候会失效？迭代器的作用迭代器相较于指针 说说 STL 中 resize 和 reserve 的区别resize:reserve: STL 容器动态链接可能产生的问题push_back 和 emplace_back 的区别STL 中 vector 与 list 具体是怎么实现的？常见操作的时间复杂度是多少？ 新特性智能指针share_ptrunique_ptrweak_ptr怎么知道weak_ptr失效了没 lambda表达式lambda语法：[capture]含义（parameters）含义mutable 或 exception 声明-&gt;return-type-&gt;{statement}{函数体} Lambda表达式如何对应到函数对象圆括号传参数是如何实现的方括号捕获外部变量（闭包）是如何实现的 右值引用由来增加右值引用之后移动语义如何将左值强制转换为右值？ 移动构造函数和拷贝构造函数的区别转发和完美转发常规转发完美转发 auto关键字，lambda表达式，nullptr，成员初始化列表 static关键字面向过程面向对象初始化 C&#43;&#43;编译过程动态链接和静态链接 内联函数定义意义哪些不适合作为内联函数使用内联的缺点和宏的区别 程序启动的过程多态静态多态动态多态虚函数动态绑定 多态的好处多态的形式 杂项32位整型在大小端的区别 (0x12345678)一个空类的大小是几字节？指针和引用的区别浅拷贝和深拷贝的区别？struct和class的区别导入C函数的关键字是什么，C&#43;&#43;编译时和C有什么不同？函数指针new和mallocdelete如何知道该释放多大的空间，这些信息存在什么位置 delete[]和delete的区别，基本数据类型的数组使用delete可以释放完全吗堆和栈的区别内存泄漏说说C&#43;&#43;的重载和重写是如何实现的重载重写 说说 C 语言如何实现 C&#43;&#43; 语言中的重载简述下向上转型和向下转型子类转换为父类父类转换为子类 请问构造函数中的能不能调用虚方法那么析构函数中能不能调用虚方法请问拷贝构造函数的参数是什么传递方式，为什么仿函数C&#43;&#43;中类模板和模板类的区别64位系统存一个地址多大空间函数传递时会不会在内存拷贝为什么要使用友元？检查内存泄漏的方法C&#43;&#43;编译和C编译的区别如何判断一段函数是C&#43;&#43;编译的还是C编译的 如何在不用sizeof的情况下判断系统是多少位重复多次 fclose 一个打开过一次的 FILE *fp 指针会有什么结果，并请解释为什么函数传递数组参数，结果数组会被修改，而值不行？main 函数执行以前，还会执行什么代码？字符指针、浮点数指针、以及函数指针这三种类型的变量哪个占用的内存最大？为什么？C&#43;&#43;几个基本类型占用空间继承时应该要写哪些类的成员函数怎样让对象只能创建在栈/堆/内存池中RTTI原理，type_info信息存在虚函数表的哪里C&#43;&#43;在哪些情况下会产生临时对象C&#43;&#43;静态链接库（lib）和动态链接库（dll）的区别memory_move和memory_copy两者的作用和区别 const 说说const int *a, int const *a, const int a, int *const a, const int *const a分别是什么，有什么特点。 const int *a==int const *a:都是指a所指向的值不能改，但是a可以指向别的东西const int a:a变量变成常量，不可修改int *const a:a的值可以更改，但是指向它的指针不能更改int const *const a:a本身和指向它的指针都不能更改 const成员函数 常函数内不能修改成员变量对于类的成员函数，有时候必须指定其返回值为const类型，以使得其返回值不为“左值”。 例如，假设有一个类A，它有一个私有成员变量x和一个公有成员函数getX()，如果getX()返回x的引用，并且不加const修饰，那么就可以这样写：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/06490efd7a4f27e3c33d91069df9bbb3/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-03-10T09:50:46+08:00" />
<meta property="article:modified_time" content="2023-03-10T09:50:46+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">八股文C&#43;&#43;篇（超级全）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#const_1" rel="nofollow">const</a></li><li><ul><li><a href="#const_int_a_int_const_a_const_int_a_int_const_a_const_int_const_a_2" rel="nofollow">说说const int *a, int const *a, const int a, int *const a, const int *const a分别是什么，有什么特点。</a></li><li><a href="#const_9" rel="nofollow">const成员函数</a></li><li><a href="#constdefine_19" rel="nofollow">const和#define的区别</a></li><li><a href="#constconstconst_26" rel="nofollow">什么const在常量区，什么const在栈区，什么const放入符号表优化</a></li></ul> 
  </li><li><a href="#C_32" rel="nofollow">C++内存分区（五）</a></li><li><a href="#_40" rel="nofollow">内存对齐</a></li><li><ul><li><a href="#_44" rel="nofollow">原因</a></li><li><a href="#_48" rel="nofollow">什么时候不应该内存对齐？</a></li><li><a href="#_50" rel="nofollow">内存对齐的规则</a></li></ul> 
  </li><li><a href="#_57" rel="nofollow">虚函数</a></li><li><ul><li><a href="#_58" rel="nofollow">作用</a></li><li><a href="#_61" rel="nofollow">实现</a></li><li><a href="#_64" rel="nofollow">纯虚函数</a></li><li><a href="#_67" rel="nofollow">虚函数在什么时候调用？</a></li><li><a href="#_69" rel="nofollow">大小</a></li><li><a href="#C__73" rel="nofollow">C++ 中哪些函数不能被声明为虚函数？</a></li><li><a href="#_78" rel="nofollow">为什么虚函数不能是模板函数？</a></li><li><a href="#_80" rel="nofollow">虚函数表既然希望类的所有对象共享为什么不放在全局区</a></li></ul> 
  </li><li><a href="#_85" rel="nofollow">菱形继承</a></li><li><a href="#_87" rel="nofollow">类型转换</a></li><li><ul><li><a href="#static_cast_88" rel="nofollow">static_cast</a></li><li><a href="#dynamic_cast_90" rel="nofollow">dynamic_cast</a></li><li><ul><li><a href="#dynamic_cast_92" rel="nofollow">dynamic_cast和虚函数的区别</a></li></ul> 
   </li><li><a href="#reinterpret_cast_94" rel="nofollow">reinterpret_cast</a></li><li><a href="#const_cast_96" rel="nofollow">const_cast</a></li><li><ul><li><a href="#volatile_99" rel="nofollow">volatile关键字</a></li></ul> 
  </li></ul> 
  </li><li><a href="#_101" rel="nofollow">构造函数一大家子</a></li><li><ul><li><a href="#_105" rel="nofollow">拷贝构造函数</a></li><li><ul><li><a href="#_106" rel="nofollow">什么时候调用拷贝构造函数？</a></li></ul> 
   </li><li><a href="#_112" rel="nofollow">析构函数</a></li><li><ul><li><a href="#_113" rel="nofollow">为什么要用虚的？</a></li></ul> 
   </li><li><a href="#_119" rel="nofollow">移动构造函数</a></li></ul> 
  </li><li><a href="#C_124" rel="nofollow">C++类内是否可以定义引用？</a></li><li><a href="#_127" rel="nofollow">模板类</a></li><li><ul><li><a href="#_129" rel="nofollow">模板实例化</a></li><li><a href="#_131" rel="nofollow">模板具体化</a></li><li><a href="#_133" rel="nofollow">模板为了解决什么问题？</a></li><li><a href="#_136" rel="nofollow">模板的声明和定义为什么不能分开写，要想分开写该怎么做</a></li><li><a href="#_184" rel="nofollow">模板特化</a></li><li><ul><li><a href="#_186" rel="nofollow">全特化</a></li><li><a href="#_188" rel="nofollow">偏特化</a></li></ul> 
   </li><li><a href="#_190" rel="nofollow">模板在编译时生成的代码是否会相同，生成的相同的代码如何处理</a></li></ul> 
  </li><li><a href="#C__194" rel="nofollow">C++ 类对象的初始化顺序</a></li><li><a href="#STL_198" rel="nofollow">STL</a></li><li><ul><li><a href="#_199" rel="nofollow">容器</a></li><li><ul><li><a href="#_200" rel="nofollow">顺序型容器</a></li><li><ul><li><a href="#vector_202" rel="nofollow">vector</a></li><li><ul><li><a href="#_208" rel="nofollow">第二个模板形参？</a></li><li><a href="#vectorresize_213" rel="nofollow">vector调用resize的时候，如果是元素是一个类，会不会调用这些函数的析构函数？</a></li><li><a href="#Vector_216" rel="nofollow">使用Vector需要注意什么？</a></li><li><a href="#C_221" rel="nofollow">如果扩容时会引发自定义类型挨个复制构造，C++有什么机制来避免这一点</a></li></ul> 
     </li><li><a href="#deque_226" rel="nofollow">deque</a></li><li><a href="#list_232" rel="nofollow">list</a></li></ul> 
    </li><li><a href="#_238" rel="nofollow">关联式容器</a></li><li><ul><li><a href="#set_239" rel="nofollow">set</a></li><li><a href="#map_246" rel="nofollow">map</a></li><li><ul><li><a href="#_252" rel="nofollow">红黑树的性质，各种操作时间复杂度</a></li></ul> 
     </li><li><a href="#unordered_map_257" rel="nofollow">unordered_map</a></li><li><ul><li><a href="#_259" rel="nofollow">哈希表跟红黑树的比较，优缺点、适用场合，各种操作的时空复杂度</a></li></ul> 
    </li></ul> 
   </li></ul> 
   </li><li><a href="#_263" rel="nofollow">空间配置器</a></li><li><ul><li><a href="#_264" rel="nofollow">定义</a></li><li><a href="#_266" rel="nofollow">背景</a></li><li><a href="#_268" rel="nofollow">实现</a></li><li><a href="#_272" rel="nofollow">迭代器</a></li><li><ul><li><a href="#_273" rel="nofollow">迭代器用过吗？什么时候会失效？</a></li><li><a href="#_277" rel="nofollow">迭代器的作用</a></li><li><a href="#_283" rel="nofollow">迭代器相较于指针</a></li></ul> 
    </li><li><a href="#_STL__resize__reserve__286" rel="nofollow">说说 STL 中 resize 和 reserve 的区别</a></li><li><ul><li><a href="#resize_289" rel="nofollow">resize:</a></li><li><a href="#reserve_291" rel="nofollow">reserve:</a></li></ul> 
    </li><li><a href="#STL__296" rel="nofollow">STL 容器动态链接可能产生的问题</a></li><li><a href="#push_back__emplace_back__299" rel="nofollow">push_back 和 emplace_back 的区别</a></li><li><a href="#STL__vector__list__302" rel="nofollow">STL 中 vector 与 list 具体是怎么实现的？常见操作的时间复杂度是多少？</a></li></ul> 
  </li></ul> 
  </li><li><a href="#_304" rel="nofollow">新特性</a></li><li><ul><li><a href="#_305" rel="nofollow">智能指针</a></li><li><ul><li><a href="#share_ptr_306" rel="nofollow">share_ptr</a></li><li><a href="#unique_ptr_308" rel="nofollow">unique_ptr</a></li><li><a href="#weak_ptr_313" rel="nofollow">weak_ptr</a></li><li><ul><li><a href="#weak_ptr_317" rel="nofollow">怎么知道weak_ptr失效了没</a></li></ul> 
   </li></ul> 
   </li><li><a href="#lambda_322" rel="nofollow">lambda表达式</a></li><li><ul><li><a href="#lambda_323" rel="nofollow">lambda语法：</a></li><li><ul><li><a href="#capture_325" rel="nofollow">[capture]含义</a></li><li><a href="#parameters_343" rel="nofollow">（parameters）含义</a></li><li><a href="#mutable__exception__355" rel="nofollow">mutable 或 exception 声明</a></li><li><a href="#returntype_361" rel="nofollow">-&gt;return-type-&gt;</a></li><li><a href="#statement_366" rel="nofollow">{statement}{函数体}</a></li></ul> 
    </li><li><a href="#Lambda_370" rel="nofollow">Lambda表达式如何对应到函数对象</a></li><li><a href="#_372" rel="nofollow">圆括号传参数是如何实现的</a></li><li><a href="#_381" rel="nofollow">方括号捕获外部变量（闭包）是如何实现的</a></li></ul> 
   </li><li><a href="#_408" rel="nofollow">右值引用</a></li><li><ul><li><a href="#_410" rel="nofollow">由来</a></li><li><a href="#_418" rel="nofollow">增加右值引用之后</a></li><li><a href="#_430" rel="nofollow">移动语义</a></li><li><ul><li><a href="#_440" rel="nofollow">如何将左值强制转换为右值？</a></li></ul> 
    </li><li><a href="#_448" rel="nofollow">移动构造函数和拷贝构造函数的区别</a></li><li><a href="#_452" rel="nofollow">转发和完美转发</a></li><li><ul><li><a href="#_454" rel="nofollow">常规转发</a></li><li><a href="#_456" rel="nofollow">完美转发</a></li></ul> 
   </li></ul> 
   </li><li><a href="#autolambdanullptr_527" rel="nofollow">auto关键字，lambda表达式，nullptr，成员初始化列表</a></li></ul> 
  </li><li><a href="#static_529" rel="nofollow">static关键字</a></li><li><ul><li><a href="#_530" rel="nofollow">面向过程</a></li><li><a href="#_534" rel="nofollow">面向对象</a></li><li><a href="#_538" rel="nofollow">初始化</a></li></ul> 
  </li><li><a href="#C_545" rel="nofollow">C++编译过程</a></li><li><ul><li><a href="#_552" rel="nofollow">动态链接和静态链接</a></li></ul> 
  </li><li><a href="#_557" rel="nofollow">内联函数</a></li><li><ul><li><a href="#_558" rel="nofollow">定义</a></li><li><a href="#_561" rel="nofollow">意义</a></li><li><a href="#_567" rel="nofollow">哪些不适合作为内联函数</a></li><li><a href="#_573" rel="nofollow">使用内联的缺点</a></li><li><a href="#_580" rel="nofollow">和宏的区别</a></li></ul> 
  </li><li><a href="#_584" rel="nofollow">程序启动的过程</a></li><li><a href="#_595" rel="nofollow">多态</a></li><li><ul><li><a href="#_596" rel="nofollow">静态多态</a></li><li><a href="#_598" rel="nofollow">动态多态</a></li><li><ul><li><a href="#_599" rel="nofollow">虚函数</a></li><li><a href="#_600" rel="nofollow">动态绑定</a></li></ul> 
   </li><li><a href="#_603" rel="nofollow">多态的好处</a></li><li><a href="#_606" rel="nofollow">多态的形式</a></li></ul> 
  </li><li><a href="#_613" rel="nofollow">杂项</a></li><li><ul><li><a href="#32_0x12345678_614" rel="nofollow">32位整型在大小端的区别 (0x12345678)</a></li><li><a href="#_618" rel="nofollow">一个空类的大小是几字节？</a></li><li><a href="#_621" rel="nofollow">指针和引用的区别</a></li><li><a href="#_624" rel="nofollow">浅拷贝和深拷贝的区别？</a></li><li><a href="#structclass_628" rel="nofollow">struct和class的区别</a></li><li><a href="#CCC_631" rel="nofollow">导入C函数的关键字是什么，C++编译时和C有什么不同？</a></li><li><a href="#_636" rel="nofollow">函数指针</a></li><li><a href="#newmalloc_644" rel="nofollow">new和malloc</a></li><li><ul><li><a href="#delete_650" rel="nofollow">delete如何知道该释放多大的空间，这些信息存在什么位置</a></li></ul> 
   </li><li><a href="#deletedeletedelete_653" rel="nofollow">delete[]和delete的区别，基本数据类型的数组使用delete可以释放完全吗</a></li><li><a href="#_662" rel="nofollow">堆和栈的区别</a></li><li><a href="#_667" rel="nofollow">内存泄漏</a></li><li><a href="#C_673" rel="nofollow">说说C++的重载和重写是如何实现的</a></li><li><ul><li><a href="#_674" rel="nofollow">重载</a></li><li><a href="#_676" rel="nofollow">重写</a></li></ul> 
   </li><li><a href="#_C__C__679" rel="nofollow">说说 C 语言如何实现 C++ 语言中的重载</a></li><li><a href="#_682" rel="nofollow">简述下向上转型和向下转型</a></li><li><ul><li><a href="#_683" rel="nofollow">子类转换为父类</a></li><li><a href="#_685" rel="nofollow">父类转换为子类</a></li></ul> 
   </li><li><a href="#_688" rel="nofollow">请问构造函数中的能不能调用虚方法</a></li><li><a href="#_690" rel="nofollow">那么析构函数中能不能调用虚方法</a></li><li><a href="#_700" rel="nofollow">请问拷贝构造函数的参数是什么传递方式，为什么</a></li><li><a href="#_703" rel="nofollow">仿函数</a></li><li><a href="#C_720" rel="nofollow">C++中类模板和模板类的区别</a></li><li><a href="#64_724" rel="nofollow">64位系统存一个地址多大空间</a></li><li><a href="#_727" rel="nofollow">函数传递时会不会在内存拷贝</a></li><li><a href="#_730" rel="nofollow">为什么要使用友元？</a></li><li><a href="#_734" rel="nofollow">检查内存泄漏的方法</a></li><li><a href="#CC_740" rel="nofollow">C++编译和C编译的区别</a></li><li><ul><li><a href="#CC_743" rel="nofollow">如何判断一段函数是C++编译的还是C编译的</a></li></ul> 
   </li><li><a href="#sizeof_753" rel="nofollow">如何在不用sizeof的情况下判断系统是多少位</a></li><li><a href="#_fclose__FILE_fp__756" rel="nofollow">重复多次 fclose 一个打开过一次的 FILE *fp 指针会有什么结果，并请解释</a></li><li><a href="#_759" rel="nofollow">为什么函数传递数组参数，结果数组会被修改，而值不行？</a></li><li><a href="#main__763" rel="nofollow">main 函数执行以前，还会执行什么代码？</a></li><li><a href="#_766" rel="nofollow">字符指针、浮点数指针、以及函数指针这三种类型的变量哪个占用的内存最大？为什么？</a></li><li><a href="#C_769" rel="nofollow">C++几个基本类型占用空间</a></li><li><a href="#_779" rel="nofollow">继承时应该要写哪些类的成员函数</a></li><li><a href="#_783" rel="nofollow">怎样让对象只能创建在栈/堆/内存池中</a></li><li><a href="#RTTItype_info_858" rel="nofollow">RTTI原理，type_info信息存在虚函数表的哪里</a></li><li><a href="#C_868" rel="nofollow">C++在哪些情况下会产生临时对象</a></li><li><a href="#Clibdll_883" rel="nofollow">C++静态链接库（lib）和动态链接库（dll）的区别</a></li><li><a href="#memory_movememory_copy_887" rel="nofollow">memory_move和memory_copy两者的作用和区别</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="const_1"></a>const</h2> 
<h3><a id="const_int_a_int_const_a_const_int_a_int_const_a_const_int_const_a_2"></a>说说const int *a, int const *a, const int a, int *const a, const int *const a分别是什么，有什么特点。</h3> 
<ul><li>const int *a==int const *a:都是指a所指向的值不能改，但是a可以指向别的东西</li><li>const int a:a变量变成常量，不可修改</li><li>int *const a:a的值可以更改，但是指向它的指针不能更改</li><li>int const *const a:a本身和指向它的指针都不能更改</li></ul> 
<h3><a id="const_9"></a>const成员函数</h3> 
<ul><li>常函数内不能修改成员变量</li><li>对于类的成员函数，有时候必须指定其返回值为const类型，以使得其返回值不为“左值”。</li></ul> 
<blockquote> 
 <p>例如，假设有一个类A，它有一个私有成员变量x和一个公有成员函数getX()，如果getX()返回x的引用，并且不加const修饰，那么就可以这样写：<br> A a;<br> a.getX() = 10; //修改了x的值<br> 这样就破坏了类的封装性和数据安全性。但如果getX()返回x的引用，并且加上const修饰，那么就会报错</p> 
</blockquote> 
<h3><a id="constdefine_19"></a>const和#define的区别</h3> 
<p>（1） const 常量有数据类型，而宏常量没有数据类型。编译器可以对前者进行类型安全检查。<br> 而对后者只进行字符替换，没有类型安全检查，并且在字符替换可能会产生意料不到的错误（边际效应） 。<br> （2）有些集成化的调试工具可以对 const 常量进行调试，但是不能对宏常量进行调试。<br> （3）#define是在编译的预处理阶段起作用，而const是在编译、运行的时候起作用。<br> （4）#define定义的常量不分配内存，而const定义的常量会分配在常量存储区中。</p> 
<h3><a id="constconstconst_26"></a>什么const在常量区，什么const在栈区，什么const放入符号表优化</h3> 
<ul><li>如果const修饰的是全局变量放到常量区</li><li>如果const修饰的是局部变量放在栈区</li><li>如果const修饰的变量没有被使用则会放到符号表中，其内容不会分配空间</li></ul> 
<h2><a id="C_32"></a>C++内存分区（五）</h2> 
<ul><li>堆区</li><li>栈区</li><li>全局/静态区</li><li>常量区</li><li>程序代码区</li></ul> 
<h2><a id="_40"></a>内存对齐</h2> 
<blockquote> 
 <p>经过内存对⻬之后，CPU 的内存访问速度⼤⼤提升。因为 CPU 把内存当成是⼀块⼀块的，块的⼤⼩可以是 2，4，8，16 个字节，因此 CPU 在读取内存的时候是⼀块⼀块进⾏读取的，块的大小称为内存读取粒度。⽐如说 CPU 要读取⼀个 4 个字节的数据到寄存器中（假设内存读取粒度是 4），如果数据是从 0 字节开始的，那么直接将 0-3 四个字节完全读取到寄存器中进⾏处理即可。<br> 如果数据是从 1 字节开始的，就⾸先要将前 4 个字节读取到寄存器，并再次读取 4-7 个字节数据进⼊寄存器，接着把 0 字节，5，6，7 字节的数据剔除，最后合并 1，2，3，4字节的数据进⼊寄存器，所以说，当内存没有对⻬时，寄存器进⾏了很多额外的操作，⼤⼤降低了 CPU 的性能。</p> 
</blockquote> 
<h3><a id="_44"></a>原因</h3> 
<p>平台原因：不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。<br> 性能原因：应该尽可能地在自然边界上对齐。原因在于，为了访问未对齐的内存，处理器需要作两次内存访问；而对齐的内存访问仅需要一次就可以了。</p> 
<h3><a id="_48"></a>什么时候不应该内存对齐？</h3> 
<p>什么时候不希望进行内存对齐呢？一般来说，当我们追求空间效率而不是时间效率时，我们可以选择取消或者减小内存对齐。例如，在嵌入式系统中，由于资源有限，我们可能更关心节省空间而不是提高速度。此时我们可以使用编译器提供的选项来调整或者关闭内存对齐。</p> 
<h3><a id="_50"></a>内存对齐的规则</h3> 
<ul><li>对于结构体的各个成员，第一个成员位于偏移为0的位置，结构体第一个成员的偏移量(offset)为0，以后每个成员相对于结构体首地址的offset都是该成员大小与有效对齐值中较小那个的整数倍，如有需要编译器会在成员之间加上填充字节。</li><li>有效对齐值是给定值#pragma pack (n)和结构体中最长数据类型长度中较小的那个，其中n是编译器提供的选项，可以是1,2,4,8,16等</li><li>除了结构成员需要对齐，结构本身也需要对齐，结构的长度必须是编译器默认的对齐长度和成员中最长类型中最小的数据大小的倍数对齐。</li></ul> 
<h2><a id="_57"></a>虚函数</h2> 
<h3><a id="_58"></a>作用</h3> 
<p>父类型的指针指向其子类的实例，然后通过父类的指针调用实际子类的成员函数。</p> 
<h3><a id="_61"></a>实现</h3> 
<p>每个虚函数都会有一个与之对应的虚函数表，该虚函数表的实质是一个指针数组，存放的是每一个对象的虚函数入口地址。对于一个派生类来说，他会继承基类的虚函数表同时增加自己的虚函数入口地址，如果派生类重写了基类的虚函数的话，那么继承过来的虚函数入口地址将被派生类的重写虚函数入口地址替代。那么在程序运行时会发生动态绑定，将父类指针绑定到实例化的对象实现多态。每个类只有一个虚函数表，虚函数表是在编译的时候就确定的了。</p> 
<h3><a id="_64"></a>纯虚函数</h3> 
<p>用户不能创建基类的实例，只能创建派生类的实例</p> 
<h3><a id="_67"></a>虚函数在什么时候调用？</h3> 
<p>虚函数在运行时根据实际对象的类型来确定调用哪个函数，而不是根据指针或引用的类型来确定。当一个虚函数被定义为类的成员函数时，它会被标记为虚函数。在调用虚函数时，程序会查找该函数的实际类型，并在运行时调用该类型的实现。这就允许程序在运行时动态地选择执行哪个版本的虚函数，从而实现多态性。虚函数通常与基类指针或引用一起使用，可以实现基类指针或引用调用派生类的函数。</p> 
<h3><a id="_69"></a>大小</h3> 
<p>虚函数表是一个存储虚函数指针的数组，每个类有一个虚函数表，每个对象有一个指向虚函数表的指针。虚函数表的大小取决于类中有多少个虚函数，而对象中的虚函数表指针的大小取决于编译器和操作系统2。一般来说，在32位系统下，指针占4个字节，在64位系统下，指针占8个字节。</p> 
<h3><a id="C__73"></a>C++ 中哪些函数不能被声明为虚函数？</h3> 
<p>构造函数：构造函数不能被声明为虚函数。因为构造函数是用来创建对象的，而虚函数是根据对象的类型来动态调用的。如果构造函数是虚函数，那么在创建对象时就无法确定调用哪个版本的构造函数，会导致逻辑错误<br> 友元函数：你说得对，构造函数不能被声明为虚函数。因为构造函数是用来创建对象的，而虚函数是根据对象的类型来动态调用的。如果构造函数是虚函数，那么在创建对象时就无法确定调用哪个版本的构造函数，会导致逻辑错误<br> 普通函数：普通函数只能被重载，不能被重写</p> 
<h3><a id="_78"></a>为什么虚函数不能是模板函数？</h3> 
<p>因为模板函数在编译时会被实例化为多个不同的函数，而虚函数需要在运行时才能确定调用哪个函数。在C++中，虚函数的实现依赖于虚函数表（vtable）和虚函数指针（vptr），而这些在编译时就需要确定下来。因此，虚函数不能是模板函数。</p> 
<h3><a id="_80"></a>虚函数表既然希望类的所有对象共享为什么不放在全局区</h3> 
<p>虚函数表不能放在全局区，因为全局区是存放全局变量和静态变量的，而虚函数表不是变量，而是一组指向类成员函数的指针。如果放在全局区，会导致内存浪费和混乱。<br> 混乱：虚函数表是在编译期就确定了大小和内容的，而全局区是在运行期才分配空间的。如果把虚函数表放在全局区，就需要在运行期动态地为每个类分配空间，并且要保证不同类之间不会发生冲突。这样就增加了程序的复杂度和出错的可能性</p> 
<h2><a id="_85"></a>菱形继承</h2> 
<p>解决方法：将两个父类添加成virtual，相当于爷爷直接拿出指针给孙子</p> 
<h2><a id="_87"></a>类型转换</h2> 
<h3><a id="static_cast_88"></a>static_cast</h3> 
<p>static_cast 用于执行<strong>非多态</strong>类型之间的类型转换，例如整型和浮点型之间的转换、基类和派生类之间的指针或引用转换、void 指针和其他指针类型之间的转换等。该转换在<strong>编译时</strong>完成，通常不会检查运行时错误。</p> 
<h3><a id="dynamic_cast_90"></a>dynamic_cast</h3> 
<p>dynamic_cast 用于在运行时进行<strong>多态</strong>类型的转换。它通常用于将<strong>基类</strong>指针或引用转换为<strong>派生类</strong>指针或引用，以及在类层次结构中进行下行转换</p> 
<h4><a id="dynamic_cast_92"></a>dynamic_cast和虚函数的区别</h4> 
<p>dynamic_cast和虚函数的区别</p> 
<h3><a id="reinterpret_cast_94"></a>reinterpret_cast</h3> 
<p>reinterpret_cast 用于在<strong>不同的指针</strong>类型之间进行转换，**例如将一个指针转换为一个整数，或将一个整数转换为一个指针。**该转换通常不进行类型检查，因此潜在地不安全，只应在极少数特殊情况下使用。</p> 
<h3><a id="const_cast_96"></a>const_cast</h3> 
<p>const_cast 用于在<strong>去除</strong>变量的 const 修饰符或 volatile 修饰符时使用。它可以将指向<strong>常量</strong>对象的指针或引用转换为指向<strong>非常量</strong>对象的指针或引用，或者将指向非常量对象的指针或引用转换为指向常量对象的指针或引用。</p> 
<h4><a id="volatile_99"></a>volatile关键字</h4> 
<p>在 C++ 中，关键字 volatile 用于声明一个变量是易变的（volatile variable），即该变量可能会在程序中的任意时刻被意外地改变。这意味着，当读取一个易变的变量时，编译器不会从缓存中读取该变量的值，而是每次都会从内存中重新读取该变量的值。同样地，当写入一个易变的变量时，编译器也不会将该变量的值存储在缓存中，而是立即将该变量的值写入内存中。</p> 
<h2><a id="_101"></a>构造函数一大家子</h2> 
<h3><a id="_105"></a>拷贝构造函数</h3> 
<h4><a id="_106"></a>什么时候调用拷贝构造函数？</h4> 
<ul><li>用已经初始化的对象给另一个初始化的对象赋值</li><li>函数用对象作为返回值</li><li>函数用对象作为参数</li></ul> 
<h3><a id="_112"></a>析构函数</h3> 
<h4><a id="_113"></a>为什么要用虚的？</h4> 
<p>A* p = new B;<br> delete p;（A是父类 B是子类）<br> 如果不定义虚析构 那么删除P只调用A的析构<br> 定义为虚析构之后，删除P就会调用AB的析构</p> 
<h3><a id="_119"></a>移动构造函数</h3> 
<p>在C++中，当一个对象被复制时，其内部资源通常会被复制，这可能会导致性能问题，特别是在处理大型数据结构时。</p> 
<p>移动语义是指，当一个对象被移动而不是复制时，其内部资源可以被“窃取”，而不需要进行复制操作。移动操作比复制操作更高效，因为它不需要分配新的内存或复制现有的内存。</p> 
<h2><a id="C_124"></a>C++类内是否可以定义引用？</h2> 
<p>可以，但是必须使用成员初始化列表为引用变量初始化，构造函数的形参也必须是引用类型</p> 
<h2><a id="_127"></a>模板类</h2> 
<p>模板类是什么时候实现的</p> 
<h3><a id="_129"></a>模板实例化</h3> 
<p>显式是程序员指定什么样的类型实现什么样的函数，后者是编译器来决定什么类型</p> 
<h3><a id="_131"></a>模板具体化</h3> 
<p>当模板使用某种类型类型实例化后生成的类或函数不能满足需要时，可以考虑对模板进行具体化。具体化时可以修改原模板的定义，当使用该类型时，按照具体化后的定义实现，具体化相当于对某种类型进行特殊处理。</p> 
<h3><a id="_133"></a>模板为了解决什么问题？</h3> 
<p>简单来讲 就是解决多态问题</p> 
<h3><a id="_136"></a>模板的声明和定义为什么不能分开写，要想分开写该怎么做</h3> 
<p>模板的声明和定义不能分开写的原因是，编译器在编译模板时需要知道模板的完整定义，才能根据具体的类型参数生成相应的代码。如果只有声明而没有定义，编译器就无法生成正确的代码，链接时就会出现未定义引用的错误。</p> 
<p>法一：一种是在声明文件中包含定义文件</p> 
<pre><code class="prism language-cpp"><span class="token comment">// template.h</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span>T<span class="token operator">&amp;</span> a<span class="token punctuation">,</span> T<span class="token operator">&amp;</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"template.cpp"</span></span>
</code></pre> 
<pre><code class="prism language-cpp"><span class="token comment">// template.cpp</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span>T<span class="token operator">&amp;</span> a<span class="token punctuation">,</span> T<span class="token operator">&amp;</span> b<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  T temp <span class="token operator">=</span> a<span class="token punctuation">;</span>
  a <span class="token operator">=</span> b<span class="token punctuation">;</span>
  b <span class="token operator">=</span> temp<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>这样做的好处是可以保持声明和定义的分离，但缺点是每次修改定义文件都需要重新编译所有包含声明文件的源文件。<br> 法二：在定义文件中显式实例化需要用到的类型参数</p> 
<pre><code class="prism language-cpp"><span class="token comment">// template.h</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span>T<span class="token operator">&amp;</span> a<span class="token punctuation">,</span> T<span class="token operator">&amp;</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<pre><code class="prism language-cpp"><span class="token comment">// template.cpp</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span>T<span class="token operator">&amp;</span> a<span class="token punctuation">,</span> T<span class="token operator">&amp;</span> b<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  T temp <span class="token operator">=</span> a<span class="token punctuation">;</span>
  a <span class="token operator">=</span> b<span class="token punctuation">;</span>
  b <span class="token operator">=</span> temp<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// explicit instantiation for int and double types</span>
<span class="token keyword">template</span> <span class="token keyword">void</span> <span class="token generic-function"><span class="token function">swap</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">&amp;</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">template</span> <span class="token keyword">void</span> <span class="token generic-function"><span class="token function">swap</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token keyword">double</span><span class="token operator">&amp;</span><span class="token punctuation">,</span> <span class="token keyword">double</span><span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>这样做的好处是可以避免重复编译和代码膨胀，但缺点是需要提前知道所有可能用到的类型参数，并且每增加一个类型参数都需要修改定义文件</p> 
<h3><a id="_184"></a>模板特化</h3> 
<p>模板特化是指为某些特定类型提供不同于通用模板的具体实现</p> 
<h4><a id="_186"></a>全特化</h4> 
<p>全特化是指为所有的模板参数都指定具体类型或值的情况</p> 
<h4><a id="_188"></a>偏特化</h4> 
<p>偏特化是指只为部分的模板参数指定具体类型或值，或者限制参数的范围。偏特化只适用于类模板，不适用于函数模板</p> 
<h3><a id="_190"></a>模板在编译时生成的代码是否会相同，生成的相同的代码如何处理</h3> 
<p>一种情况是，如果模板的定义和声明都放在头文件中，并且在多个源文件中被包含和使用，那么编译器会为每个源文件生成相同的模板实例化代码。这样会导致目标文件中存在重复的代码段，增加了目标文件的大小，并且可能引起链接错误。为了避免这种情况，可以使用 extern 关键字来声明一个外部模板，在一个源文件中显式地实例化该模板，并且在其他源文件中只引用该实例化。<br> 另一种情况是，如果模板的定义放在一个源文件中，并且在其他源文件中被包含和使用，那么编译器会根据不同的类型参数生成不同的模板实例化代码。这样可以避免重复的代码段，但是也可能导致链接错误，因为其他源文件无法找到该源文件中定义的模板。为了避免这种情况，可以将模板的声明放在头文件中，并且在需要使用该模板的源文件中包含该头文件</p> 
<h2><a id="C__194"></a>C++ 类对象的初始化顺序</h2> 
<p>父类构造函数–&gt;成员类对象构造函数–&gt;自身构造函数<br> （当一个类的成员是另一个类的对象时，这个对象就叫成员对象.）</p> 
<h2><a id="STL_198"></a>STL</h2> 
<h3><a id="_199"></a>容器</h3> 
<h4><a id="_200"></a>顺序型容器</h4> 
<h5><a id="vector_202"></a>vector</h5> 
<p>特点：</p> 
<ul><li>顺序序列</li><li>动态数组</li><li>尾删有较佳性能</li></ul> 
<h6><a id="_208"></a>第二个模板形参？</h6> 
<p>vector 的第二个模板形参是分配器（allocator），用于分配和管理 vector 内部存储元素的内存。分配器可以控制内存分配的策略，例如内存池等。如果不指定分配器，默认使用 std::allocator。</p> 
<p>分配器通常是一个模板类，提供了 allocate 和 deallocate 等成员函数来分配和释放内存。在 vector 内部，使用分配器来分配和释放存储元素的内存，可以方便地替换默认的内存分配器，实现自定义的内存分配策略。</p> 
<h6><a id="vectorresize_213"></a>vector调用resize的时候，如果是元素是一个类，会不会调用这些函数的析构函数？</h6> 
<blockquote> 
 <p>如果调用resize函数使得vector的大小变小了，那么后面的元素会被析构掉，也就是会调用元素类的析构函数。如果调用resize函数使得vector的大小变大了，那么新添加的元素会调用元素类的默认构造函数进行初始化，而不会调用析构函数。</p> 
</blockquote> 
<h6><a id="Vector_216"></a>使用Vector需要注意什么？</h6> 
<ul><li>为避免频繁的扩容操作，可以使用 reserve() 方法在插入元素之前预留一定的空间，以提高性能</li><li>在使用 vector 进行大量元素操作时，可以使用 emplace_back() 方法而不是 push_back() 方法，以避免元素拷贝的开销</li><li>在需要删除元素时，可以使用 erase() 方法进行删除。但是，需要注意的是，如果要删除多个元素，应该首先对要删除的元素进行排序，并使用 erase() 方法一次性删除，以避免多次扩容操作</li></ul> 
<h6><a id="C_221"></a>如果扩容时会引发自定义类型挨个复制构造，C++有什么机制来避免这一点</h6> 
<p>在进行 vector 扩容时，如果存储的是自定义类型，会挨个复制构造元素，可能会造成性能问题。为了避免这一点，可以使用移动语义来优化。</p> 
<p>在 C++11 引入的移动语义中，我们可以通过 std::move() 函数将一个对象转化为右值引用，这样就可以在元素的拷贝构造函数中实现移动语义，将对象的资源所有权从一个对象转移到另一个对象中，而不是进行深拷贝。</p> 
<h5><a id="deque_226"></a>deque</h5> 
<p>特性：</p> 
<ul><li>双向队列</li><li>在两端增删元素有较佳性能</li></ul> 
<h5><a id="list_232"></a>list</h5> 
<p>特性：</p> 
<ul><li>双向链表</li><li>不支持随机存取</li></ul> 
<h4><a id="_238"></a>关联式容器</h4> 
<h5><a id="set_239"></a>set</h5> 
<p>特性：</p> 
<ul><li>不允许相同元素</li><li>自动排序</li><li>原理：红黑树</li></ul> 
<h5><a id="map_246"></a>map</h5> 
<ul><li>first和second，并且根据first排序</li><li>实现原理：红黑树</li><li>map不允许容器中有重复的key值元素</li></ul> 
<h6><a id="_252"></a>红黑树的性质，各种操作时间复杂度</h6> 
<p>自动排序，稳定<br> 查找，插入，删除都是O（logn）</p> 
<h5><a id="unordered_map_257"></a>unordered_map</h5> 
<p>umap底层是哈希表</p> 
<h6><a id="_259"></a>哈希表跟红黑树的比较，优缺点、适用场合，各种操作的时空复杂度</h6> 
<p>哈希表适合小数据，查找插入删除最好都是O(1),最坏O(n),缺点是容易发生哈希冲突，设计哈希函数也比较困难<br> 红黑树适合大数据集，但是代码实现较为复杂</p> 
<h3><a id="_263"></a>空间配置器</h3> 
<h4><a id="_264"></a>定义</h4> 
<p>在C++ STL中，空间配置器便是用来实现内存空间(一般是内存，也可以是硬盘等空间)分配的工具，他与容器联系紧密，每一种容器的空间分配都是通过空间分配器alloctor实现的。</p> 
<h4><a id="_266"></a>背景</h4> 
<p>开辟内存一般分为两步，一步是用构造函数，一部分用malloc或者new，前者直接在函数调用栈开辟空间，而后者先在堆里开辟空间，再隐式调用构造函数</p> 
<h4><a id="_268"></a>实现</h4> 
<p>关于内存空间的配置与释放，SGI STL采用了两级配置器：一级配置器主要是考虑大块内存空间，利用malloc和free实现；二级配置器主要是考虑小块内存空间而设计的（为了最大化解决内存碎片问题，进而提升效率），采用链表free_list来维护内存池（memory pool），free_list通过union结构实现，空闲的内存块互相挂接在一块，内存块一旦被使用，则被从链表中剔除，易于维护。</p> 
<h4><a id="_272"></a>迭代器</h4> 
<h5><a id="_273"></a>迭代器用过吗？什么时候会失效？</h5> 
<p>顺序容器使用删除会使后面的迭代器失效（自动往前进一，导致地址全变，所以会失效），解决办法：it=earse(it)，即返回删除元素下一个的迭代器<br> 关联容器map由于内部是红黑树，使用erase不会失效，但是需要记录一下下一个元素的迭代器，list使用上面两种方法都行</p> 
<h5><a id="_277"></a>迭代器的作用</h5> 
<p>和指针的区别：<br> 迭代器不是指针，是类模板，表现的像指针。他只是模拟了指针的一些功能，重载了指针的一些操作符，–&gt;、++、–等。迭代器封装了指针，是一个”可遍历STL（ Standard Template Library）容器内全部或部分元素”的对象，本质是封装了原生指针，是指针概念的一种提升，提供了比指针更高级的行为，相当于一种智能指针，他可以根据不同类型的数据结构来实现不同的++，–等操作。</p> 
<p>迭代器返回的是对象引用而不是对象的值，所以cout只能输出迭代器使用取值后的值而不能直接输出其自身</p> 
<h5><a id="_283"></a>迭代器相较于指针</h5> 
<p>迭代器相对于指针的优点在于，它提供了一些安全性和抽象性的保证。例如，如果你使用一个指向数组元素的指针，你可以对它进行任何操作，包括越界访问和非法修改等操作，这可能会导致内存错误和程序崩溃。而如果你使用一个vector迭代器，则可以避免这些问题，因为迭代器会自动检查越界和非法操作，并在出错时抛出异常或者进行其他处理。</p> 
<h4><a id="_STL__resize__reserve__286"></a>说说 STL 中 resize 和 reserve 的区别</h4> 
<p>介绍概念:capacity:该值在容器初始化时赋值，指的是容器能够容纳的最大的元素的个数。还不能通过下标等访问，因为此时容器中还没有创建任何对象。<br> size指的是此时容器中实际的元素个数。可以通过下标访问0-(size-1)范围内的对象。</p> 
<h5><a id="resize_289"></a>resize:</h5> 
<p>resize即修改capacity大小，也修改size大小</p> 
<h5><a id="reserve_291"></a>reserve:</h5> 
<p>reserve只修改capcaity大小</p> 
<blockquote> 
 <p>resize既分配了空间，也创建了对象；reserve表示容器预留空间，但并不是真正的创建对象，需要通过insert（）或push_back（）等创建对象。</p> 
</blockquote> 
<h4><a id="STL__296"></a>STL 容器动态链接可能产生的问题</h4> 
<p>给动态库函数传递容器的对象本身，则会出现内存堆栈破坏的问题。<br> 产生问题的原因，容器和动态链接库相互支持不够好，动态链接库函数中使用容器时，参数中只能传递容器的引用，并且要保证容器的大小不能超出初始大小，否则导致容器自动重新分配，就会出现内存堆栈破坏问题。</p> 
<h4><a id="push_back__emplace_back__299"></a>push_back 和 emplace_back 的区别</h4> 
<p>如果要将一个临时变量push到容器的末尾，push_back()需要先构造临时对象，再将这个对象拷贝到容器的末尾，而emplace_back()则直接在容器的末尾构造对象，这样就省去了拷贝的过程。</p> 
<h4><a id="STL__vector__list__302"></a>STL 中 vector 与 list 具体是怎么实现的？常见操作的时间复杂度是多少？</h4> 
<p>vector:开辟三倍内存，旧数据开辟到新内存，释放旧的内存，指向新内存</p> 
<h2><a id="_304"></a>新特性</h2> 
<h3><a id="_305"></a>智能指针</h3> 
<h4><a id="share_ptr_306"></a>share_ptr</h4> 
<p>std::shared_ptr是一种共享式智能指针，它可以让多个shared_ptr实例同时拥有同一个内存资源。shared_ptr内部维护了一个计数器，记录当前有多少个shared_ptr实例共享同一块内存。只有当计数器变为0时，才会自动释放内存。因此，shared_ptr可以避免多个指针指向同一块内存时出现的内存泄漏和悬空指针等问题。</p> 
<h4><a id="unique_ptr_308"></a>unique_ptr</h4> 
<p>std::unique_ptr是一种独占式智能指针，它可以保证指向的内存只被一个unique_ptr实例所拥有。当unique_ptr被销毁时，它所拥有的内存也会被自动释放。unique_ptr还支持移动语义，因此可以通过std::move来转移拥有权。</p> 
<blockquote> 
 <p>使用release()方法来移交指向的对象</p> 
</blockquote> 
<h4><a id="weak_ptr_313"></a>weak_ptr</h4> 
<p>用来解决shared_prt相互引用冲突的结果<br> 举个一个不太恰当的例子，A和B相互加了微信，假设我们用一个指针来指向自己的微信朋友，如果是shared_ptr，那么A和B的生命周期是相互影响的，而实际上我们并不希望这种强绑定，比如假设B注销了账户，A根本不用知道，只有当A想发消息给B的时候系统才会发出提示：您还不是该用户的朋友。这时候weak_ptr就派上用场了。这也就是weak_ptr的第一种使用场景：<br> 当你想使用对象，但是并不想管理对象，并且在需要使用对象时可以判断对象是否还存在</p> 
<h5><a id="weak_ptr_317"></a>怎么知道weak_ptr失效了没</h5> 
<p>可以通过expired()函数来判断一个weak_ptr是否已经失效，如果expired()返回true，则表示它指向的对象已经被销毁或释放了。另外，使用lock()函数获取weak_ptr指向的对象时，如果返回的是一个空的shared_ptr，也可以判断weak_ptr是否已经失效。</p> 
<h3><a id="lambda_322"></a>lambda表达式</h3> 
<h4><a id="lambda_323"></a>lambda语法：</h4> 
<p><strong>[capture] (parameters) mutable -&gt;return-type{statement}</strong></p> 
<h5><a id="capture_325"></a>[capture]含义</h5> 
<ul><li>[]。没有任何函数对象参数。</li><li>[=]。函数体内可以使用 Lambda 所在范围内所有可见的局部变量（包括 Lambda 所在类的<br> this），并且是值传递方式（相当于编译器自动为我们按值传递了所有局部变量）。</li><li>[&amp;]。函数体内可以使用 Lambda 所在范围内所有可见的局部变量（包括 Lambda 所在类的<br> this），并且是引用传递方式（相当于是编译器自动为我们按引用传递了所有局部变量）。</li><li>[this]。函数体内可以使用 Lambda 所在类中的成员变量。</li><li>[a]。将 a 按值进行传递。按值进行传递时，函数体内不能修改传递进来的 a 的拷贝，因为默认情况下函数是 const<br> 的，要修改传递进来的拷贝，可以添加 mutable 修饰符。</li><li>[&amp;a]。将 a 按引用进行传递。</li></ul> 
<p>中括号 “[]” 表示Lambda表达式的捕获列表，用于指定Lambda表达式访问外部作用域中的变量的方式。捕获列表可以为空，或者包含一个或多个捕获项，</p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span> lambda <span class="token operator">=</span> <span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token keyword">int</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> a <span class="token operator">+</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>在这个例子中，捕获列表包含一个捕获项 “a”，表示Lambda表达式将访问外部作用域中的变量 “a”。</p> 
<h5><a id="parameters_343"></a>（parameters）含义</h5> 
<blockquote> 
 <p>标识重载的 () 操作符的参数，没有参数时，这部分可以省略。参数可以通过按值（如: (a, b)）和按引用 (如: (&amp;a, &amp;b))<br> 两种方式进行传递。</p> 
</blockquote> 
<pre><code class="prism language-cpp"><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token keyword">int</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span> <span class="token punctuation">}</span>
</code></pre> 
<p>圆括号 “()” 表示Lambda表达式的参数列表，可以包含零个或多个参数。在这个例子中，Lambda表达式有两个参数，分别是一个整数 “x” 和一个整数 “y”</p> 
<h5><a id="mutable__exception__355"></a>mutable 或 exception 声明</h5> 
<blockquote> 
 <p>这部分可以省略。按值传递函数对象参数时，加上 mutable<br> 修饰符后，可以修改传递进来的拷贝（注意是能修改拷贝，而不是值本身）。exception<br> 声明用于指定函数抛出的异常，如抛出整数类型的异常，可以使用 throw(int)。</p> 
</blockquote> 
<h5><a id="returntype_361"></a>-&gt;return-type-&gt;</h5> 
<blockquote> 
 <p>返回值类型：标识函数返回值的类型，当返回值为 void，或者函数体中只有一处 return<br> 的地方（此时编译器可以自动推断出返回值类型）时，这部分可以省略</p> 
</blockquote> 
<h5><a id="statement_366"></a>{statement}{函数体}</h5> 
<blockquote> 
 <p>标识函数的实现，这部分不能省略，但函数体可以为空。</p> 
</blockquote> 
<h4><a id="Lambda_370"></a>Lambda表达式如何对应到函数对象</h4> 
<p>当定义一个Lambda表达式时，编译器会生成一个与Lambda表达式对应的新的（未命名的）函数对象类型和该类型的一个对象。这个函数对象可以重载函数调用运算符()，从而具有类似函数的行为。</p> 
<h4><a id="_372"></a>圆括号传参数是如何实现的</h4> 
<p>圆括号传参数是通过函数调用运算符()来实现的。</p> 
<p>当你使用圆括号传递参数给一个lambda表达式时，实际上是调用了它生成的函数对象的函数调用运算符()，并将参数传递给它。</p> 
<p>函数调用运算符()会根据lambda表达式的定义来执行相应的代码，并返回一个值（如果有的话）。</p> 
<p>所以，你可以把圆括号传参数看作是一种调用函数对象的方式，它让你不需要知道函数对象的名字或者类型就可以使用它。</p> 
<h4><a id="_381"></a>方括号捕获外部变量（闭包）是如何实现的</h4> 
<p>方括号捕获外部变量（闭包）是通过将外部变量作为函数对象的成员来实现的。</p> 
<p>当你在方括号中指定一个外部变量时，编译器会为你生成一个函数对象类型，它包含了这个外部变量作为它的一个成员。</p> 
<p>当你创建一个函数对象时，这个成员会被初始化为外部变量的值或者引用，这取决于你是用=还是&amp;来捕获它。</p> 
<p>当你调用函数对象时，这个成员就可以在lambda表达式中使用，就像一个普通的局部变量一样。</p> 
<p>所以，你可以把方括号捕获外部变量看作是一种创建闭包的语法糖，它让你不需要显式地定义一个类或者接口来保存外部变量的状态。</p> 
<ul><li>值捕获（capture by value）：使用 “=”<br> 将外部变量按值进行捕获。Lambda表达式会在创建时将外部变量的值复制一份到闭包中</li><li>引用捕获（capture by reference）：使用 “&amp;”<br> 将外部变量按引用进行捕获。Lambda表达式会在创建时绑定到外部变量的内存地址，以便在Lambda表达式中修改变量的值</li><li>隐式捕获：使用 “[]” 作为空方括号，表示隐式捕获所有在Lambda表达式中使用的外部变量。在Lambda表达式中使用的变量会被自动按值进行捕获。</li></ul> 
<pre><code class="prism language-cpp"> <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span> lambda <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> x <span class="token operator">*</span> x<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token function">lambda</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// result = 9</span>
</code></pre> 
<blockquote> 
 <p>需要注意的是，对于值捕获和隐式捕获，Lambda表达式在创建时会复制一份外部变量的值到闭包中，如果在Lambda表达式中修改闭包中的变量值，不会影响外部变量的值。而对于引用捕获，Lambda表达式会直接操作外部变量，可以改变其值。</p> 
</blockquote> 
<h3><a id="_408"></a>右值引用</h3> 
<p>右值引用是C++11引入的一种引用类型，它用于表示临时对象和即将销毁的对象</p> 
<h4><a id="_410"></a>由来</h4> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token operator">&amp;</span>b <span class="token operator">=</span> num<span class="token punctuation">;</span> <span class="token comment">//正确</span>
<span class="token keyword">int</span> <span class="token operator">&amp;</span>c <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token comment">//错误</span>
</code></pre> 
<h4><a id="_418"></a>增加右值引用之后</h4> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token comment">//int &amp;&amp; a = num;  //右值引用不能初始化为左值</span>
<span class="token keyword">int</span> <span class="token operator">&amp;&amp;</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
</code></pre> 
<p>和常量左值引用不同的是，右值引用还可以对右值进行修改。例如：int &amp;&amp; a = 10;<br> a = 100;<br> cout &lt;&lt; a &lt;&lt; endl;</p> 
<h4><a id="_430"></a>移动语义</h4> 
<p>移动语义是C++11引入的一项重要特性，它允许将一个对象的资源所有权从一个对象转移到另一个对象，而不需要进行昂贵的复制操作。<br> 移动语义通过将右值引用传递给移动构造函数和移动赋值运算符，使得可以将一个临时对象或者即将销毁的对象的资源转移到一个新的对象中，从而避免了进行昂贵的复制操作。</p> 
<pre><code class="prism language-cpp">std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> vec1 <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> vec2 <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>vec1<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h5><a id="_440"></a>如何将左值强制转换为右值？</h5> 
<p>move函数</p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token keyword">int</span><span class="token operator">&amp;&amp;</span> r <span class="token operator">=</span> <span class="token function">move</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//将左值强制转换为右值</span>
</code></pre> 
<h4><a id="_448"></a>移动构造函数和拷贝构造函数的区别</h4> 
<ol><li>拷贝构造函数用于创建一个新对象，并将其初始化为已存在的对象的副本。这个过程通常涉及到内存的分配和数据的复制，因此它可能比较昂贵。</li><li>移动构造函数用于创建一个新对象，并将其初始化为另一个对象的资源所有权的转移。这个过程通常涉及到指针的复制，而不是数据的复制，因此它通常比拷贝构造函数更加高效。移动构造函数通常会使用右值引用来接受一个临时对象或者一个即将被销毁的对象，并将其资源所有权转移到新对象中。</li></ol> 
<h4><a id="_452"></a>转发和完美转发</h4> 
<p>转发是指在函数中将参数按照原始的类型和值，转发给另一个函数。</p> 
<h5><a id="_454"></a>常规转发</h5> 
<p>常规转发是指将参数通过传值或引用的方式传递给另一个函数，这是C++中的传参方式。但是在传递参数时，会存在一些问题。例如，当我们想把一个右值参数传递给一个函数时，我们可能会遇到编译器错误。另一个例子是当我们要将一个右值参数转发给一个函数时，但是我们不知道该使用传值还是传引用，因为这个决定取决于被调用的函数的定义。为了解决这些问题，C++11 引入了完美转发。</p> 
<h5><a id="_456"></a>完美转发</h5> 
<p>完美转发是指将参数以原始的类型和值传递给另一个函数，并保留其右值或左值特性。这可以通过使用转发引用（forwarding reference）和 std::forward 函数来实现。转发引用是一种通用引用，它可以引用任何类型的值，并且可以保留值的右值或左值特性。当我们使用转发引用作为函数的参数时，我们可以在函数内部使用 std::forward 来将参数转发给另一个函数，以保留参数的右值或左值特性。</p> 
<ol><li>必须使用转发引用作为参数类型。</li><li>必须使用 std::forward 函数进行转发</li><li>被转发的参数必须是右值或左值引用。</li></ol> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;utility&gt;</span></span>


<span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"foo(int): "</span> <span class="token operator">&lt;&lt;</span> n <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> n<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"bar(const int&amp;): "</span> <span class="token operator">&lt;&lt;</span> n <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">callFoo</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">//常规转发</span>
    <span class="token function">foo</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">callBar</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token comment">常规转发</span>
    <span class="token function">bar</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 完美转发</span>
<span class="token keyword">void</span> <span class="token function">foo2</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"foo2(int): "</span> <span class="token operator">&lt;&lt;</span> n <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">bar2</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> n<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"bar2(const int&amp;): "</span> <span class="token operator">&lt;&lt;</span> n <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">callFoo2</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">foo2</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">forward</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">callBar2</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">bar2</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">forward</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>

    <span class="token comment">// 常规转发</span>
    <span class="token function">callFoo</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 输出 foo(int): 42</span>
    <span class="token function">callBar</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 输出 bar(const int&amp;): 42</span>

    <span class="token comment">// 完美转发</span>
    <span class="token function">callFoo2</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 输出 foo2(int): 42</span>
    <span class="token function">callFoo2</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 输出 foo2(int): 42</span>

    <span class="token function">callBar2</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 输出 bar2(const int&amp;): 42</span>
    <span class="token function">callBar2</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 输出 bar2(const int&amp;): 42</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre> 
<blockquote> 
 <p>在常规转发中，参数被传递给了被调用函数，但是它们的类型都是引用类型，因此在函数内部处理时，不会进行任何类型转换。也就是说，如果我们传递给常规转发的参数是一个左值，那么被调用函数内部处理时，它们依然是左值引用；如果我们传递的是一个右值，那么它们依然是右值引用。这样可能会导致一些效率问题，比如如果被调用函数需要将参数进行复制，那么这个过程可能会比较耗时。<br> 而在完美转发中，我们使用了转发引用 T&amp;&amp;，并在函数内部使用了 std::forward 函数来进行类型转换。这样可以保留参数的原有类型特性，使得被调用函数内部处理时，参数的类型会根据传递给它的参数类型进行调整，从而避免了一些不必要的类型转换操作。此外，通过完美转发，我们还可以保留参数的右值特性，避免了一些额外的复制操作，从而提高了代码的效率。</p> 
</blockquote> 
<h3><a id="autolambdanullptr_527"></a>auto关键字，lambda表达式，nullptr，成员初始化列表</h3> 
<h2><a id="static_529"></a>static关键字</h2> 
<h3><a id="_530"></a>面向过程</h3> 
<p>静态全局变量：静态全局变量在声明它的整个文件中都是可见的，而在文件之外是不可见的；（作用域是整个文件）变量的生存周期存在于整个程序运行期间。<br> 静态局部变量：内存存放在程序的全局数据区中，静态局部变量在程序执行到该对象声明时，会被首次初始化。其后运行到该对象的声明时，不会再次初始化（只会被初始化一次），变量的生存周期存在于整个程序运行期间。<br> 静态函数（主要目的确定作用域）：作用域只在声明它的文件当中，不能被其他文件引用，其他文件可以定义同名的全局函数，其他文件想要调用本文件的静态函数，需要显示的调用extern关键字修饰其声明。</p> 
<h3><a id="_534"></a>面向对象</h3> 
<p>静态成员变量：用于修饰 class 的数据成员，即所谓“静态成员”。这种数据成员的生存期大于 class 的对象（实体 instance）。静态数据成员是每个 class 有一份，普通数据成员是每个 instance 有一份，因此静态数据成员也叫做类变量，而普通数据成员也叫做实例变量。诞生比构造函数早，在类声明的时候就产生了。<br> 静态成员函数：静态成员函数不能访问非静态(包括成员函数和数据成员)，但是非静态可以访问静态</p> 
<h3><a id="_538"></a>初始化</h3> 
<p>对于C语言的全局和静态变量，初始化发生在任何代码执行之前，属于编译期初始化。</p> 
<p>而C++标准规定：全局或静态对象当且仅当对象首次用到时才进行构造（静态全局和静态局部）。<br> 然而，静态成员变量与静态局部变量和全局变量不同。它们必须在类的外部进行初始化，并且在程序开始执行之前就已经被分配内存并初始化了。</p> 
<h2><a id="C_545"></a>C++编译过程</h2> 
<ul><li>预编译：展开所有宏定义，处理#ifdef等，过滤所有注释</li><li>编译：产生语法树，产生汇编代码</li><li>汇编：将汇编代码转为机器语言，生成目标文件</li><li>链接：将不同目标文件连接到一起，形成可执行文件</li></ul> 
<h3><a id="_552"></a>动态链接和静态链接</h3> 
<ul><li>静态:连接的时候就把需要的函数或者过程放进了可执行文件中,即使静态库删除了依旧可以运行</li><li>动态：是在链接的时候没有把调用的函数代码链接进去，而是在执行的过程中，再去找要链接的函数，生成的可执行文件中没有函数代码，静态库删除就找不到函数了。</li></ul> 
<h2><a id="_557"></a>内联函数</h2> 
<h3><a id="_558"></a>定义</h3> 
<p>内联函数是在 C++ 中增加的一个功能，可以提高程序执行效率。如果函数是内联的，编译器在编译时，会把内联函数的实现替换到每个调用内联函数的地方，可以与宏函数作类比，但宏函数不会进行类型检查。</p> 
<h3><a id="_561"></a>意义</h3> 
<p>引入内联函数主要是解决一些频繁调用的小函数消耗大量空间的问题。</p> 
<p>通常情况下，在调用函数时，程序会将控制权从调用程序处转移到被调用函数处，在这个过程中，传递参数、寄存器操作、返回值等会消耗额外的时间和内存，如果调用的函数代码量很少，也许转移到调用函数的时间比函数执行的时间更长。而如果使用内联函数，内联函数会在调用</p> 
<h3><a id="_567"></a>哪些不适合作为内联函数</h3> 
<ol><li>递归调用本身的函数</li><li>包含复杂语句的函数，例如：for、while、switch 等；</li><li>函数包含静态变量（内联函数的定义和调用是在编译期进行的，而不是在运行期1。编译器会将内联函数的代码直接嵌入到调用它的地方，从而避免了函数调用的开销。但是，这也意味着每次调用内联函数时，都会生成一份新的函数代码。<br> 如果内联函数中有静态变量，那么每次生成新的函数代码时，也会生成新的静态变量3。这样就会导致多个静态变量共存于程序中，并且互相独立，无法保持一致性）；</li></ol> 
<h3><a id="_573"></a>使用内联的缺点</h3> 
<p>如果使用很多内联函数，生成的二进制文件会变大；</p> 
<p><strong>编译的时间会增加，因为每次内联函数有修改，就需要重新编译代码。</strong></p> 
<p>所以，并不是所有函数都要声明为内联函数，需要视具体情况而定。</p> 
<h3><a id="_580"></a>和宏的区别</h3> 
<p>宏函数是在<strong>预编译</strong>的时候把所有的宏名用宏体来替换，简单的说就是字符串替换 ；而内联函数则是在<strong>编译</strong>的时候进行代码插入，编译器会在每处调用内联函数的地方直接把内联函数的内容展开，这样可以省去函数的调用的开销，提高效率<br> 宏定义是<strong>没有类型检查</strong>的，无论对还是错都是直接替换；而内联函数在编译的时候会进行<strong>类型检查</strong>，内联函数满足函数的性质，比如有返回值、参数列表等</p> 
<h2><a id="_584"></a>程序启动的过程</h2> 
<ol><li>加载可执行程序：操作系统根据可执行的文件信息，分配进程空间，将代码段，数据段，BSS段等映射到进程的虚拟空间中</li><li>初始化：操作系统调用C++运行库的初始化代码，进行初始化，包括初始化全局变量，构造静态对象等</li><li>调用main（）函数</li><li>根据程序设计和逻辑，在运行过程中，可能需要分配动态内存、创建新的线程、进行 I/O 操作等。</li><li>退出：当 main() 函数执行完毕，或者调用 exit() 函数结束程序运行，操作系统会回收进程空间和资源，完成程序的退出过程。</li></ol> 
<h2><a id="_595"></a>多态</h2> 
<h3><a id="_596"></a>静态多态</h3> 
<p>编译器在编译期间完成的，编译器会根据实参类型来推断该调用哪个函数，如果有对应的函数，就调用，没有则在编译时报错。</p> 
<h3><a id="_598"></a>动态多态</h3> 
<h4><a id="_599"></a>虚函数</h4> 
<h4><a id="_600"></a>动态绑定</h4> 
<p>动态绑定是指在运行时确定函数的实际调用函数。如果一个函数被声明为虚函数，那么在运行时就可以使用动态绑定，使得调用正确的实现。这种绑定通常是通过虚函数表（Virtual Table）来实现的，虚函数表是一个存储指向虚函数地址的指针数组，每个包含虚函数的类都有一个虚函数表。例如调用 ptr-&gt;speak() 时，根据指针实际指向的对象类型进行动态绑定，调用相应的 speak() 实现</p> 
<h3><a id="_603"></a>多态的好处</h3> 
<p>增强程序的可扩充性，即程序需要修改或增加功能时，只需改动或增加较少的代码。简化代码，使得不同的子类对象都可以使用同一个名称的函数，而具有不同的实现。实现动态绑定，即在运行时根据对象的实际类型来调用相应的虚函数。</p> 
<h3><a id="_606"></a>多态的形式</h3> 
<ul><li>虚函数多态</li><li>类模板多态</li><li>重载多态</li></ul> 
<h2><a id="_613"></a>杂项</h2> 
<h3><a id="32_0x12345678_614"></a>32位整型在大小端的区别 (0x12345678)</h3> 
<p>小端：78 56 34 12(低位在低字节)<br> 大端：12 34 56 78(低位在高字节)</p> 
<h3><a id="_618"></a>一个空类的大小是几字节？</h3> 
<p>1</p> 
<h3><a id="_621"></a>指针和引用的区别</h3> 
<p>引用和引用变量共同占一个空间，可以说，指针看的是地址，引用看的是变量本身，所以引用更加安全（不能取到引用本身的地址。如果去取引用的地址，编译器会帮你变成去所指向变量的地址123。所以对引用取地址，其实取到的是所指向的值的地址）</p> 
<h3><a id="_624"></a>浅拷贝和深拷贝的区别？</h3> 
<p>浅拷贝只复制指针，新旧两个东西共享同一块内存，当对象拥有动态分配的内存时，使用浅拷贝可能会导致资源泄露或内存访问错误<br> 深拷贝会创建一个新的对象，包括内存，这意味着每个对象都有自己独立的内存副本，即使一个对象被改变，另一个也不会受影响</p> 
<h3><a id="structclass_628"></a>struct和class的区别</h3> 
<p>struct默认公有继承，class默认私有继承<br> struct内不能声明函数，class可以</p> 
<h3><a id="CCC_631"></a>导入C函数的关键字是什么，C++编译时和C有什么不同？</h3> 
<ul><li>C++中，导入C函数的关键字是extern，表达形式为extern “C”， extern "C"的主要作用就是为了能够正确实现C++代码调用其他C语言代码。加上extern "C"后，会指示编译器这部分代码按C语言的进行编译，而不是C++的。</li><li>由于C++支持函数重载，因此编译器编译函数的过程中会将函数的参数类型也加到编译后的代码中，而不仅仅是函数名；而C语言并不支持函数重载，因此编译C语言代码的函数时不会带上函数的参数类型，一般只包括函数名。</li></ul> 
<h3><a id="_636"></a>函数指针</h3> 
<p>函数A（）；<br> 函数B（）；<br> Bfuc(A);<br> B就是回调</p> 
<p>意义：因为传进来的函数是不确定的。可以传函数a，也可以传函数b，直接在函数体里面调用就写死了</p> 
<h3><a id="newmalloc_644"></a>new和malloc</h3> 
<ul><li>new是操作符 malloc是函数</li><li>new在调用的时候先分配内存，在调用构造函数，释放的时候调用析构函数；而malloc没有构造函数和析构函数。</li><li>new发生错误抛出异常，malloc返回null</li><li>new返回具体类型指针，malloc需要强制转换</li></ul> 
<h4><a id="delete_650"></a>delete如何知道该释放多大的空间，这些信息存在什么位置</h4> 
<ul><li>一种是在分配内存时，在内存首地址之前存储一个额外的值，表示数组的大小或者元素个数。这样，在释放内存时，就可以根据这个值来确定要释放多少空间。</li><li>另一种是在编译时，编译器会记录数组类型和大小的信息，并在生成代码时，将这些信息传递给delete[]操作符。这样，在运行时，delete[]就可以根据类型和大小来调用相应的析构函数和free函数</li></ul> 
<h3><a id="deletedeletedelete_653"></a>delete[]和delete的区别，基本数据类型的数组使用delete可以释放完全吗</h3> 
<p>当new申请的是C++对象数组时，delete和delete []差别就很大了，delete只会析构一个对象<br> delete和delete[]的区别主要在于是否调用析构函数。如果用delete[]，则在回收空间之前所有对象都会首先调用自己的析构函数。基本类型的对象没有析构函数，所以回收基本类型组成的数组空间用delete和delete[]都是应该可以的；但是对于类对象数组，只能用delete[]。否则可能会造成内存泄漏或者其他错误。</p> 
<p>存储</p> 
<ol><li>内存首地址</li><li>还有一种是在内存中保存一个数据结构，例如哈希表或者链表，其中记录了每个分配的内存块的地址和大小。这样，在释放内存时，就可以通过查找数据结构来获取相应的信息，并传递给delete[]操作符。</li></ol> 
<h3><a id="_662"></a>堆和栈的区别</h3> 
<ul><li>堆栈空间分配不同：栈由操作系统自行释放，堆一般由程序员释放</li><li>缓冲方式不同：堆一般是<strong>二级存储</strong>，会慢一点，栈是一级存储，函数调用完直接释放</li><li>数据结构不同：栈类似栈，而堆类似数组</li></ul> 
<h3><a id="_667"></a>内存泄漏</h3> 
<ul><li>父类析构不是虚析构</li><li>用malloc或new申请资源后，没有释放</li><li>share_ptr互相引用对方</li></ul> 
<h3><a id="C_673"></a>说说C++的重载和重写是如何实现的</h3> 
<h4><a id="_674"></a>重载</h4> 
<p>函数重载的关键是函数的参数列表——也称为函数特征标（function signature）。如果两个函数的参数数目和类型相同，同时<strong>参数的排列顺序</strong>也相同，则它们的特征标相同，而变量名是无关紧要的。C++允许定义名称相同的函数，条件是它们的特征标不同。如果参数数目和或参数类型不同，则特征标也不同。</p> 
<h4><a id="_676"></a>重写</h4> 
<p>在基类的函数前加上virtual关键字，在派生类中重写该函数，运行时将会根据对象的实际类型来调用相应的函数。如果对象类型是派生类，就调用派生类的函数；如果对象类型是基类，就调用基类的函数。</p> 
<h3><a id="_C__C__679"></a>说说 C 语言如何实现 C++ 语言中的重载</h3> 
<p>使用函数指针来实现，重载的函数不能使用同名称，只是类似的实现了函数重载功能</p> 
<h3><a id="_682"></a>简述下向上转型和向下转型</h3> 
<h4><a id="_683"></a>子类转换为父类</h4> 
<p>向上转型（Upcasting）是指将一个派生类的指针或引用转换为它的基类的指针或引用的过程。这种转型是安全的，因为一个派生类对象也是一个基类对象，基类指针或引用可以指向派生类对象。</p> 
<h4><a id="_685"></a>父类转换为子类</h4> 
<p>向下转型（Downcasting）是指将一个基类的指针或引用转换为它的派生类的指针或引用的过程。这种转型是不安全的，因为一个基类对象可能不是一个派生类对象，如果对其进行向下转型，可能会导致未定义的行为或内存错误。向下转型应该尽可能避免使用，除非可以确定基类对象是派生类对象。</p> 
<h3><a id="_688"></a>请问构造函数中的能不能调用虚方法</h3> 
<p>在 C++ 中，构造函数可以调用虚函数，但是要注意一些细节。在构造函数中调用虚函数时，实际调用的是当前正在构造的对象的虚函数，而不是派生类中重写的虚函数。这是因为在执行派生类的构造函数之前，基类的构造函数会先被执行，此时派生类的对象尚未构造完成，因此调用派生类中的虚函数是不安全的。</p> 
<h3><a id="_690"></a>那么析构函数中能不能调用虚方法</h3> 
<p>同上，在析构函数中调用虚函数时，也会按照当前对象的类型来执行，而不是动态绑定到基类的实现</p> 
<pre><code class="prism language-cpp">Base constructor
Base <span class="token keyword">virtual</span> method
Derived constructor
可以看到，Base 的构造函数中调用了虚函数，但是实际执行的是 Base 类中的虚函数，而不是 Derived 类中的虚函数。因此，在构造函数中调用虚函数时，需要特别小心，以避免出现问题。
</code></pre> 
<h3><a id="_700"></a>请问拷贝构造函数的参数是什么传递方式，为什么</h3> 
<p>必须是引用,如果拷贝构造函数中的参数不是一个引用，即形如CClass(const CClass c_class)，那么就相当于采用了传值的方式(pass-by-value)，而传值的方式会调用该类的拷贝构造函数，从而造成无穷递归地调用拷贝构造函数。因此拷贝构造函数的参数必须是一个引用。</p> 
<h3><a id="_703"></a>仿函数</h3> 
<p>把函数当成类用</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">SquareFunctor</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> x <span class="token operator">*</span> x<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<pre><code class="prism language-cpp">SquareFunctor square<span class="token punctuation">;</span>
<span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token function">square</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 计算 5 的平方，结果为 25</span>
</code></pre> 
<h3><a id="C_720"></a>C++中类模板和模板类的区别</h3> 
<p>类模板是模板的定义，不是一个实实在在的类，定义中用到通用类型参数<br> 模板类是实实在在的类定义，是类模板的实例化。类定义中参数被实际类型所代替。</p> 
<h3><a id="64_724"></a>64位系统存一个地址多大空间</h3> 
<p>64位系统存一个地址的空间大小取决于内存地址的位数。一般来说，一个内存地址对应一个字节（8位），所以64位系统可以表示16个16进制数（64位）的内存地址。这样，64位系统的最大寻址空间为2的64次方字节，即16384PB或16777216TB。但是，并不是所有的64位系统都能使用这么大的寻址空间，因为有些CPU只有40位或48位的地址线，而且操作系统也有自己的限制。</p> 
<h3><a id="_727"></a>函数传递时会不会在内存拷贝</h3> 
<p>在C++中，定义函数int function(int a[], int b)，这里数组a不会在内存中拷贝，传递的是指针。数组名就是一个指向数组第一个元素的指针，所以当你把数组名作为参数传递时，实际上是传递了一个指针。如果你想要传递整个数组的副本，你可以使用引用或者复制数组的内容到另一个数组。</p> 
<h3><a id="_730"></a>为什么要使用友元？</h3> 
<p>使用友元可以简化代码，提高效率。<br> 举例来说，假设有一个类 A 和一个函数 F，A 中有一个私有成员变量 x，而 F 函数需要访问这个私有变量。如果不使用友元，就只能使用 A 的公有接口来获取 x，这样会增加代码的复杂性和开销。</p> 
<h3><a id="_734"></a>检查内存泄漏的方法</h3> 
<ul><li>使用第三方工具</li><li>重写new和delete，给出关键信息</li><li>使用智能指针</li></ul> 
<h3><a id="CC_740"></a>C++编译和C编译的区别</h3> 
<p>链接库：C语言和C++语言使用的链接库不同，C语言使用C标准库，C++语言使用C++标准库。C++标准库中包含了C标准库中的所有函数，同时还包含了STL（标准模板库）和一些面向对象的特性，如命名空间、类、继承等。</p> 
<h4><a id="CC_743"></a>如何判断一段函数是C++编译的还是C编译的</h4> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">__cplusplus</span></span>
<span class="token comment">// Code being compiled as C++.</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
</code></pre> 
<p>这是一个预处理器指令，它可以让你在编译前对源代码进行一些操作。#ifdef __cplusplus 的意思是如果__cplusplus 宏被定义了，就执行后面的代码。__cplusplus 宏是一个特殊的宏，它只有在C++ 编译器下才会被定义，所以这个指令可以用来检查当前的编译环境是否是C++。#endif 的意思是结束#ifdef 的范围。</p> 
<h3><a id="sizeof_753"></a>如何在不用sizeof的情况下判断系统是多少位</h3> 
<p>ISWow64Process函数</p> 
<h3><a id="_fclose__FILE_fp__756"></a>重复多次 fclose 一个打开过一次的 FILE *fp 指针会有什么结果，并请解释</h3> 
<p>导致文件描述符结构中指针指向的内存被重复释放，进而导致一些不可预期的异常。</p> 
<h3><a id="_759"></a>为什么函数传递数组参数，结果数组会被修改，而值不行？</h3> 
<p>当数组名作为参数时，传递的实际上是地址。<br> 而其他类型如int作为参数时，由于函数参数值实质上是实参的一份拷贝，被调函数内部对形参的改变并不影响实参的值。</p> 
<h3><a id="main__763"></a>main 函数执行以前，还会执行什么代码？</h3> 
<p>全局对象的构造函数会在main 函数之前执行。</p> 
<h3><a id="_766"></a>字符指针、浮点数指针、以及函数指针这三种类型的变量哪个占用的内存最大？为什么？</h3> 
<p>指针变量也占用内存单元，而且所有指针变量占用内存单元的数量都是相同的。32位4个字节，64位8个字节<br> 就是说，不管是指向何种对象的指针变量，它们占用内存的字节数都是一样的，并且要足够把程序中所能用到的最大地址表示出来（通常是一个机器字长）。</p> 
<h3><a id="C_769"></a>C++几个基本类型占用空间</h3> 
<p>数据类型 16位系统 32位系统 64位系统<br> bool 1字节 1字节 1字节<br> char 1字节 1字节 1字节<br> int 2字节 4字节 4字节<br> float 4字节 4字节 4字节<br> double 8字节 8字节 8字节<br> void 不占空间 不占空间 不占空间<br> wchar_t 2字节 2或4字节5 2或4或8字节5</p> 
<h3><a id="_779"></a>继承时应该要写哪些类的成员函数</h3> 
<p>C++继承时，一般要写类的构造函数（包括拷贝构造）、析构函数、赋值运算符重载函数，以及其他需要实现类的功能或接口的成员函数</p> 
<h3><a id="_783"></a>怎样让对象只能创建在栈/堆/内存池中</h3> 
<p>只允许在栈上创建对象：</p> 
<ul><li>可以通过将构造函数声明为私有来实现，从而防止在堆或自由存储区创建对象</li></ul> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">MyClass</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token comment">// ...</span>

<span class="token keyword">private</span><span class="token operator">:</span>
  <span class="token function">MyClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>  <span class="token comment">// 私有构造函数</span>
  <span class="token keyword">friend</span> <span class="token keyword">class</span> <span class="token class-name">StackOnly</span><span class="token punctuation">;</span>  <span class="token comment">// 声明友元类</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">StackOnly</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token function">StackOnly</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>  <span class="token comment">// 默认构造函数</span>
  <span class="token operator">~</span><span class="token function">StackOnly</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span> <span class="token comment">// 默认析构函数</span>

  <span class="token keyword">static</span> <span class="token keyword">void</span><span class="token operator">*</span> <span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>size_t<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>  <span class="token comment">// 禁用 new 运算符</span>
  <span class="token keyword">static</span> <span class="token keyword">void</span><span class="token operator">*</span> <span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>size_t<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>  <span class="token comment">// 禁用 new[] 运算符</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  StackOnly stack<span class="token punctuation">;</span>
  MyClass obj<span class="token punctuation">;</span>  <span class="token comment">// 错误：不能在堆上创建对象</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>只允许在堆上创建对象：</p> 
<blockquote> 
 <p>编译器在栈上创建对象时，如果类的析构函数是私有的，则无法回收栈上的内存。因此无法在栈上创建，所以可以将析构变成私有。这样做也有一个缺点，就是需要提供一个公有的静态成员函数来释放堆区对象的内存</p> 
</blockquote> 
<p>只允许在内存池中创建对象：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">MyPool</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">static</span> <span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">allocate</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>size_t size<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 自定义内存池分配内存</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">deallocate</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> ptr<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>size_t size<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 自定义内存池释放内存</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">MyObject</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">void</span><span class="token operator">*</span> <span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>size_t size<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> <span class="token class-name">MyPool</span><span class="token double-colon punctuation">::</span><span class="token function">allocate</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">void</span> <span class="token keyword">operator</span> <span class="token keyword">delete</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> ptr<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token class-name">MyPool</span><span class="token double-colon punctuation">::</span><span class="token function">deallocate</span><span class="token punctuation">(</span>ptr<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>MyObject<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">void</span><span class="token operator">*</span> <span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>size_t size<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>
  <span class="token keyword">void</span> <span class="token keyword">operator</span> <span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> ptr<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<blockquote> 
 <p>在上面的示例中，MyObject 类重载了 operator new 和 operator delete<br> 运算符，从而实现了只允许在内存池中创建对象的功能。operator new 运算符调用 MyPool::allocate<br> 方法从内存池中分配内存，而 operator delete 运算符调用 MyPool::deallocate 方法释放内存。同时，禁用了<br> operator new[] 和 operator delete[]<br> 运算符，从而防止在自由存储区创建数组对象。在实际使用时，需要根据具体的内存池实现来修改 MyPool 类中的代码。</p> 
</blockquote> 
<h3><a id="RTTItype_info_858"></a>RTTI原理，type_info信息存在虚函数表的哪里</h3> 
<p>RTTI就是运行时动态绑定</p> 
<p>同时，编译器也会在每个有虚函数的类对应的type_info对象中存储该类的类型信息。type_info对象是一个标准库提供的类，它包含了类型名称、哈希码等信息，并且重载了==和!=运算符来比较两个类型是否相同。</p> 
<p>为了让type_info对象和虚函数表关联起来，编译器会在虚函数表 的开头插入一个指针，指向当前类对应的type_info对象。这样，在运行时就可以通过基类指针p找到vfptr，再通过vfptr找到type_info对象指针，进而取得类型信息。</p> 
<p>type_info信息存在虚函数表的开头，也就是虚函数表的第一个元素是一个指向type_info对象的指针 。</p> 
<h3><a id="C_868"></a>C++在哪些情况下会产生临时对象</h3> 
<p>C++中，临时对象是编译器在不同的情况下创建的没有名字的对象。临时对象通常出现在以下场景：</p> 
<pre><code class="prism language-cpp">引用初始化，例如 <span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> r <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>
参数传递，例如 <span class="token function">f</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
表达式求值，例如 a <span class="token operator">+</span> b<span class="token punctuation">;</span>
函数返回，例如 <span class="token keyword">return</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span>
异常抛出，例如 <span class="token keyword">throw</span> x<span class="token punctuation">;</span>
临时对象有一个生命周期，由它们的创建点和销毁点决定<span class="token number">4</span>。任何创建多个临时对象的表达式最终会按照创建的逆序销毁它们<span class="token number">3</span>。临时对象的销毁时间取决于它们的使用方式<span class="token number">4</span>：
</code></pre> 
<p>用于初始化const引用的临时对象：如果引用是局部变量，则在引用离开作用域时销毁；如果引用是类成员，则在类实例被销毁时销毁。<br> 用于初始化非const引用或值类型的临时对象：在表达式结束后立即销毁。</p> 
<h3><a id="Clibdll_883"></a>C++静态链接库（lib）和动态链接库（dll）的区别</h3> 
<p>静态链接库（lib）是在编译时将库的代码直接复制到可执行文件中，所以在程序运行时不需要依赖任何外部库文件，所有的代码都在一个可执行文件中。因此，静态链接库的优点是移植方便，无需安装其他库文件，程序运行时速度较快。缺点是占用硬盘空间较大，同时也存在代码重复的情况，不利于代码的更新和维护。</p> 
<p>动态链接库（dll）是在程序运行时才被加载到内存中，程序需要调用库函数时才会加载对应的库文件。因此，动态链接库的优点是共享库文件，节省了硬盘空间，同时也方便了库文件的更新和维护。缺点是相对于静态链接库，程序运行时会存在一定的额外开销，如加载库文件、解析符号等。</p> 
<h3><a id="memory_movememory_copy_887"></a>memory_move和memory_copy两者的作用和区别</h3> 
<p>memcpy 的实现比较简单，它只是简单地把数据从源地址按字节逐一复制到目标地址。这意味着，如果源地址和目标地址存在重叠，即它们指向同一块内存区域，那么 memcpy 可能会出现未定义的行为，也就是数据会被错误地覆盖。因此，使用 memcpy 时需要确保源地址和目标地址不会发生重叠。</p> 
<p>而 memmove 的实现则更为复杂，它能够处理源地址和目标地址重叠的情况，即使这两个地址相互重叠，也能够保证正确地复制数据。具体来说，memmove 在复制数据时会先把数据拷贝到一个临时缓冲区中，然后再把数据从缓冲区复制到目标地址，这样就避免了源地址和目标地址重叠时数据被错误地覆盖的问题。但是，由于要使用临时缓冲区，所以 memmove 的性能可能会稍微低一些。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0fc6039ad7be67da0e22fecb7eb93e59/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">系统启动超过497天后日志显示信息 “truncating integer value ＞ 32 bits“</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1ca28f01e6fb79d6d2dca3c64faf7353/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【无标题】compose系列教程-4.相对布局ConstraintLayout的使用</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>