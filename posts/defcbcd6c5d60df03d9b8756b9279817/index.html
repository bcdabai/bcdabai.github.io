<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据结构——深度优先遍历（栈） - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="数据结构——深度优先遍历（栈）" />
<meta property="og:description" content="寻找下一个访问点的方法： （1）邻接矩阵：因为邻接矩阵的列的编号顺序是从小到大，所以寻找下一个访问点可以直接访问当前访问点对应行的第一个非零元素（w未被访问） （2）邻接表：访问该点对应的边表，且前提是边表的所有结点是由下标从小到大进行排列 核心算法代码： /*无向图邻接矩阵*/ void DFSTraverse(int arc[][MAX_VERTEX], DataType *vertex, int *visited, int vertexNum, int v) { //v是遍历的起始位置的编号 static int flag = 0; if (flag == 0) {//第一次需要初始化 initvertex(vertexNum, visited); flag = 1; } visit(vertex, v); //输出访问过的顶点信息 visited[v] = 1; for (int i = 0; i &lt; vertexNum; i&#43;&#43;) { //因为是邻接矩阵，所以编号的顺序本来就是由小到大的.所以不用遍历找 if (arc[v][i] != 0 &amp;&amp; visited[i] == 0) DFSTraverse(arc, vertex, visited, vertexNum, i); //二维数组传参，调用时实参直接写数组名 } } /*有向图邻接表*/ void DFSTraverse(VertexNode *adjList, int *visited, int vertexNum, int v) { static int flag = 0; if (flag == 0) {//第一次需要初始化 initvertex(vertexNum, visited); flag = 1; } visit(adjList, v); //输出访问过的顶点信息 visited[v] = 1; ArcNode *p = adjList[v]." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/defcbcd6c5d60df03d9b8756b9279817/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-09-19T16:59:29+08:00" />
<meta property="article:modified_time" content="2022-09-19T16:59:29+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据结构——深度优先遍历（栈）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><img alt="" src="https://images2.imgbox.com/f8/30/X0cpm4mg_o.png"></p> 
<blockquote> 
 <h3><strong>寻找下一个访问点的方法：</strong></h3> 
 <h3>（1）<a href="https://so.csdn.net/so/search?q=%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5&amp;spm=1001.2101.3001.7020" title="邻接矩阵">邻接矩阵</a>：因为邻接矩阵的列的编号顺序是从小到大，所以寻找下一个访问点可以直接访问当前访问点对应行的第一个非零元素（w未被访问）</h3> 
 <h3>（2）<a href="https://so.csdn.net/so/search?q=%E9%82%BB%E6%8E%A5%E8%A1%A8&amp;spm=1001.2101.3001.7020" title="邻接表">邻接表</a>：访问该点对应的边表，且前提是边表的所有结点是由下标从小到大进行排列</h3> 
</blockquote> 
<hr> 
<h2>核心算法代码：</h2> 
<pre><code class="language-cpp">/*无向图邻接矩阵*/
void DFSTraverse(int arc[][MAX_VERTEX], DataType *vertex, int *visited, int vertexNum,
                 int v) { //v是遍历的起始位置的编号
	static int flag = 0;
	if (flag == 0) {//第一次需要初始化
		initvertex(vertexNum, visited);
		flag = 1;
	}
	visit(vertex, v); //输出访问过的顶点信息
	visited[v] = 1;
	for (int i = 0; i &lt; vertexNum; i++) { //因为是邻接矩阵，所以编号的顺序本来就是由小到大的.所以不用遍历找
		if (arc[v][i] != 0 &amp;&amp; visited[i] == 0)
			DFSTraverse(arc, vertex, visited, vertexNum, i); //二维数组传参，调用时实参直接写数组名
	}
}</code></pre> 
<hr> 
<pre><code class="language-cpp">/*有向图邻接表*/
void DFSTraverse(VertexNode *adjList, int *visited, int vertexNum, int v) {
	static int flag = 0;
	if (flag == 0) {//第一次需要初始化
		initvertex(vertexNum, visited);
		flag = 1;
	}
	visit(adjList, v); //输出访问过的顶点信息
	visited[v] = 1;
	ArcNode *p = adjList[v].firstEdge;
	while (p != NULL) {
		if (visited[p-&gt;adjvex] == 0)
			DFSTraverse(adjList, visited, vertexNum, p-&gt;adjvex);
		p = p-&gt;next;
	}
}
void initvertex(int vertexNum, int *visited) { //初始化visited函数
	for (int i = 0; i &lt; vertexNum; i++)
		visited[i] = 0;
}
 
void visit(VertexNode *adjList, int v) { //输出访问过的顶点信息
	printf("%d ", adjList[v].vertex);//记得改变输出时要改变数据类型
}
 
void ranklist(VertexNode *adjList, int vertexNum) { //将边表进行升序的排序，便于遍历操作
	ArcNode *p, *q;
	int temp;
	for (int i = 0; i &lt; vertexNum; i++) {
		p = adjList[i].firstEdge;
		q = p;
		while (p != NULL) {
			while (q != NULL) {
				if (p-&gt;adjvex &gt; q-&gt;adjvex) {
					temp = p-&gt;adjvex;
					p-&gt;adjvex = q-&gt;adjvex;
					q-&gt;adjvex = temp;
				}
				q = q-&gt;next;
			}
			p = p-&gt;next;
		}
	}
}</code></pre> 
<p></p> 
<h2>完整代码：</h2> 
<p><img alt="" src="https://images2.imgbox.com/d0/56/haBkh4WL_o.png"></p> 
<p></p> 
<pre><code class="language-cpp">/*无向图 邻接矩阵*/
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#define MAX_VERTEX 10//最大的顶点个数
typedef int DataType;
 
//以下是无向图的定义
void MGraph(DataType *vertex, int arc[][MAX_VERTEX], int vertexNum, int arcNum) { //初始化构造图（邻接矩阵法）
	printf("请逐个输入顶点的内容：");
	DataType x;
	DataType vi, vj; //构建邻接矩阵时，一条边的两个结点编号
	for (int i = 0; i &lt; vertexNum; i++) { //顶点数组赋值
		scanf("%d", &amp;x);
		vertex[i] = x;
	}
	for (int i = 0; i &lt; vertexNum; i++) //初始化邻接矩阵
		for (int j = 0; j &lt; vertexNum; j++)
			arc[i][j] = 0;
	int count = 1;
	for (int i = 0; i &lt; arcNum; i++) { //依次输入每一条边
		printf("请输入第%d条边依附的两个顶点的编号：", count++);
		scanf("%d %d", &amp;vi, &amp;vj); //输入该边依附的顶点的编号
		arc[vi][vj] = 1; //置有边标志
		arc[vj][vi] = 1;
	}
 
}
 
void printMGraph(DataType *vertex, int arc[][MAX_VERTEX], int vertexNum) { //输出
	printf("vertex:");
	for (int i = 0; i &lt; vertexNum; i++) {
		printf("%d ", vertex[i]);
	}
	printf("\n");
	printf("arc:\n");
	for (int i = 0; i &lt; vertexNum; i++) {
		for (int j = 0; j &lt; vertexNum; j++) {
			if (j == vertexNum - 1)
				printf("%d\n", arc[i][j]);
			else
				printf("%d ", arc[i][j]);
		}
	}
 
}
 
int isLinked(int arc[][MAX_VERTEX], int i, int j) { //两顶点i,j是否有边相连,1是相连，0是不相连
	if (arc[i][j] == 1)
		return 1;
	else
		return 0;
}
 
int nodeDepth(int arc[][MAX_VERTEX], int index, int vertexNum) { //任意一顶点的度
	//无向图任意遍历行\列求和
	int count = 0;
	for (int i = 0; i &lt; vertexNum; i++) {
		if (arc[index][i] == 1)
			count++;
	}
	return count;
}
 
void initvertex(int vertexNum, int *visited) { //初始化visited函数
	for (int i = 0; i &lt; vertexNum; i++)
		visited[i] = 0;
}
 
void visit(DataType *vertex, int v) { //输出访问过的顶点信息
	printf("%d ", vertex[v]);
 
}
 
void DFSTraverse(int arc[][MAX_VERTEX], DataType *vertex, int *visited, int vertexNum,
                 int v) { //v是遍历的起始位置的编号
	static int flag = 0;
	if (flag == 0) {//第一次需要初始化
		initvertex(vertexNum, visited);
		flag = 1;
	}
	visit(vertex, v); //输出访问过的顶点信息
	visited[v] = 1;
	for (int i = 0; i &lt; vertexNum; i++) { //因为是邻接矩阵，所以编号的顺序本来就是由小到大的.所以不用遍历找
		if (arc[v][i] != 0 &amp;&amp; visited[i] == 0)
			DFSTraverse(arc, vertex, visited, vertexNum, i); //二维数组传参，调用时实参直接写数组名
	}
}</code></pre> 
<pre><code class="language-cpp">/*擦拭代码主函数*/
#include "图_邻接矩阵.h"
 
main() {
	DataType vertex[MAX_VERTEX];//储存所有的顶点
	int arc[MAX_VERTEX][MAX_VERTEX];//邻接矩阵，结点间的连通关系
	int vertexNum, arcNum; //结点个数，边的个数
	printf("输入顶点个数:");
	scanf("%d", &amp;vertexNum);
	printf("输入边个数:");
	scanf("%d", &amp;arcNum);
	MGraph(vertex, arc, vertexNum, arcNum);
	printMGraph(vertex, arc, vertexNum);
	printf("测试判断两顶点是否相连，请输入两个顶点下标:");
	int i, j;
	scanf("%d %d", &amp;i, &amp;j);
	if (isLinked(arc, i, j) == 1)
		printf("相连！\n");
	else
		printf("不相连！\n");
	printf("测试求顶点的度，请输入一个顶点下标:");
	int index;
	scanf("%d", &amp;index);
	printf("该顶点的度为:%d\n", nodeDepth(arc, index, vertexNum));
	printf("测试邻接矩阵的深度优先遍历:\n");
	int visited[vertexNum];//判断结点是否访问过，访问过设置1，未访问过为0
	int v;
	printf("请输入深度优先遍历的第一个结点编号:");
	scanf("%d", &amp;v);
	printf("深度优先遍历序列:");
	DFSTraverse(arc, vertex, visited, vertexNum, v);
 
}</code></pre> 
<hr> 
<p><img alt="" src="https://images2.imgbox.com/dc/1c/5B2gfg1p_o.png"></p> 
<hr> 
<h3><img alt="" src="https://images2.imgbox.com/5a/73/sT5f3H6a_o.png"><strong> </strong></h3> 
<h3><strong> 完整代码（有向图邻接表）：</strong></h3> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#define MAX_VERTEX 10//最大的顶点个数
typedef char DataType;
 
/*
当DataType为char时要特别注意输入时空格和换行符，分别利用getchar()
和fflush(stdin);来清空内存区
*/
typedef struct ArcNode { /*边表结点*/
	int adjvex;//边表数据域，即下标
	struct ArcNode *next; //指针域
} ArcNode;
 
typedef struct VertexNode { /*顶点表结点*/
	DataType vertex;//顶点的数据
	ArcNode *firstEdge; //指向储存该顶点所连接所有结点的边表
} VertexNode;
void initVertex(DataType *, int);
 
//以下是有向图的定义
void ALGraph(DataType *vertex, VertexNode *adjList, int vertexNum, int arcNum) { //初始化构造图（邻接表法）
	int vi, vj;
	int count = 0;
	initVertex(vertex, vertexNum);
	for (int i = 0; i &lt; vertexNum; i++) { //初始化顶点表
		adjList[i].vertex = vertex[i];
		adjList[i].firstEdge = NULL;
	}
	for (int i = 0; i &lt; arcNum; i++) {
		//输入边的信息储存在边表中
		printf("请输入第%d条边依附的两个顶点的编号(方向-&gt;)：", count++);
		fflush(stdin);//清除输入缓冲区（否则这里就会直接跳过scanf）
/*当DataType为int时要去掉上面这个语句*/
		scanf("%d %d", &amp;vi, &amp;vj); //输入该边依附的顶点的编号
		ArcNode *s;
		s = (ArcNode *)malloc(sizeof(ArcNode));
		if (s != NULL) {
			s-&gt;adjvex = vj;
			s-&gt;next = adjList[vi].firstEdge; //头插法建立链表
			adjList[vi].firstEdge = s;
		} else
			printf("init error!\n");
	}
}
 
void initVertex(DataType *vertex, int vertexNum) {//输入函数
	printf("请逐个输入顶点的内容：");
	DataType x;
	for (int i = 0; i &lt; vertexNum; i++) { //顶点数组赋值
		getchar();//吸收空格，当DataType为int时要去掉这个语句
		scanf("%c", &amp;x);
		vertex[i] = x;
	}
}
 
void printALGraph(VertexNode *adjList, int vertexNum) {
	printf("vertex  firstEdge\n");
	ArcNode *p ;
	for (int i = 0; i &lt; vertexNum; i++) {
		printf("%3c --&gt;", adjList[i].vertex);
		p = adjList[i].firstEdge;
		while (p != NULL) {
			printf("%d --&gt;", p-&gt;adjvex);
			p = p-&gt;next;
		}
		printf("NULL\n");
		printf("\n");
	}
}
 
int isLinked(VertexNode *adjList, int i, int j) { //两顶点i,j是否有边相连,1是相连，0是不相连
	ArcNode *p = adjList[i].firstEdge ;
	while (p != NULL) {
		if (p-&gt;adjvex == j)
			return 1;
		else
			p = p-&gt;next;
	}
	p = adjList[j].firstEdge;
	while (p != NULL) {
		if (p-&gt;adjvex == i)
			return 1;
		else
			p = p-&gt;next;
	}
	return 0;
}
 
int nodeDepth(VertexNode *adjList, int index, int vertexNum) { //任意一顶点的度
	int count = 0;
	ArcNode *p = adjList[index].firstEdge;
	while (p != NULL) {
		count++;
		p = p-&gt;next;
	}
	return count;
}
 
void freeArcNode(VertexNode *adjList, int vertexNum) {
	ArcNode *p;
	ArcNode *temp;
	for (int i = 0; i &lt; vertexNum; i++) {
		p = adjList[i].firstEdge ;
		while (p != NULL) {
			temp = p;
			p = p-&gt;next;
			free(temp);
		}
	}
}
 
void initvertex(int vertexNum, int *visited) { //初始化visited函数
	for (int i = 0; i &lt; vertexNum; i++)
		visited[i] = 0;
}
 
void visit(VertexNode *adjList, int v) { //输出访问过的顶点信息
	printf("%c ", adjList[v].vertex);//记得改变输出时要改变数据类型
}
 
void DFSTraverse(VertexNode *adjList, int *visited, int vertexNum, int v) {
	static int flag = 0;
	if (flag == 0) {//第一次需要初始化
		initvertex(vertexNum, visited);
		flag = 1;
	}
	visit(adjList, v); //输出访问过的顶点信息
	visited[v] = 1;
	ArcNode *p = adjList[v].firstEdge;
	while (p != NULL) {
		if (visited[p-&gt;adjvex] == 0)
			DFSTraverse(adjList, visited, vertexNum, p-&gt;adjvex);
		p = p-&gt;next;
	}
}
 
void ranklist(VertexNode *adjList, int vertexNum) { //将边表进行升序的排序，便于遍历操作
	ArcNode *p, *q;
	int temp;
	for (int i = 0; i &lt; vertexNum; i++) {
		p = adjList[i].firstEdge;
		q = p;
		while (p != NULL) {
			while (q != NULL) {
				if (p-&gt;adjvex &gt; q-&gt;adjvex) {
					temp = p-&gt;adjvex;
					p-&gt;adjvex = q-&gt;adjvex;
					q-&gt;adjvex = temp;
				}
				q = q-&gt;next;
			}
			p = p-&gt;next;
		}
	}
}</code></pre> 
<hr> 
<pre><code class="language-cpp">/*测试函数主函数*/
#include "图_邻接表.h"
 
int main() {
	DataType vertex[MAX_VERTEX];//储存所有的顶点
	int vertexNum, arcNum; //结点个数，边的个数
	printf("输入顶点个数:");
	scanf("%d", &amp;vertexNum);
	printf("输入边个数:");
	scanf("%d", &amp;arcNum);
	VertexNode adjList[vertexNum];//顶点表
	ALGraph(vertex, adjList, vertexNum, arcNum);
	ranklist(adjList, vertexNum);
	printALGraph(adjList, vertexNum);
	printf("测试判断两顶点是否相连，请输入两个顶点下标:");
	int i, j;
	scanf("%d %d", &amp;i, &amp;j);
	if (isLinked(adjList, i, j) == 1)
		printf("相连！\n");
	else
		printf("不相连！\n");
	printf("测试求顶点的度，请输入一个顶点下标:");
	int index;
	scanf("%d", &amp;index);
	printf("该顶点的度为:%d\n", nodeDepth(adjList, index, vertexNum));
	printf("测试邻接表的深度优先遍历:\n");
	int visited[vertexNum];//判断结点是否访问过，访问过设置1，未访问过为0
	int v;
	printf("请输入深度优先遍历的第一个结点编号:");
	scanf("%d", &amp;v);
	printf("深度优先遍历序列:");
	DFSTraverse(adjList, visited, vertexNum, v);
	freeArcNode(adjList, vertexNum);
}</code></pre> 
<p><img alt="" src="https://images2.imgbox.com/f0/f3/ifAHNq7f_o.png"></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4b1c9b3e15ed4f1f4bd8416fb68c9294/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">MySQl优化：使用 jemalloc 分配内存</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c5acccd39c91d34a619613906644f809/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">LibreCAD使用记录</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>