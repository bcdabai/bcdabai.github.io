<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Netstat 命令详解 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Netstat 命令详解" />
<meta property="og:description" content="参考：http://www.cnblogs.com/ggjucheng/archive/2012/01/08/2316661.html
参考：http://www.jb51.net/LINUXjishu/152405.html
netstat 命令：http://man.linuxde.net/netstat
Netstat 用于显示与 IP、TCP、UDP 和 ICMP 协议相关的统计数据，一般用于检验本机各端口的网络连接情况。如果你的计算机有时候接收到的数据报导致出错数据或故障，你不必感到奇怪，TCP/IP可以容许这些类型的错误，并能够自动重发数据报。但如果累计的出错情况数目占到所接收的IP数据报相当大的百分比，或者它的数目正迅速增加，那么你就应该使用 Netstat 查一查为什么会出现这些情况了。
在 windows下有个小工具挺好的，TCPView。当然如果要详细分析数据包，可选用 sniffer、Wireshark 等更强大的工具。
1. 网络连接状态详解 共有 12 中可能的状态，前面11种是按照 TCP 连接建立的三次握手和 TCP 连接断开的四次挥手过程来描述的。
1)、LISTEN:首先服务端需要打开一个socket进行监听，状态为LISTEN. /* The socket is listening for incoming connections. 侦听来自远方TCP端口的连接请求 */ 2)、SYN_SENT:客户端通过应用程序调用connect进行active open.于是客户端tcp发送一个SYN以请求建立一个连接.之后状态置为SYN_SENT. /*The socket is actively attempting to establish a connection. 在发送连接请求后等待匹配的连接请求 */ 3)、SYN_RECV:服务端应发出ACK确认客户端的 SYN,同时自己向客户端发送一个SYN. 之后状态置为SYN_RECV /* A connection request has been received from the network. 在收到和发送一个连接请求后等待对连接请求的确认 */ 4)、ESTABLISHED: 代表一个打开的连接，双方可以进行或已经在数据交互了。 /* The socket has an established connection." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/0fdc217e38f9d162c43eef419d556caa/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2016-12-08T17:01:50+08:00" />
<meta property="article:modified_time" content="2016-12-08T17:01:50+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Netstat 命令详解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>参考：<a href="http://www.cnblogs.com/ggjucheng/archive/2012/01/08/2316661.html" rel="nofollow">http://www.cnblogs.com/ggjucheng/archive/2012/01/08/2316661.html</a></p> 
<p>参考：<a href="http://www.jb51.net/LINUXjishu/152405.html" rel="nofollow">http://www.jb51.net/LINUXjishu/152405.html</a></p> 
<p>netstat 命令：<a href="http://man.linuxde.net/netstat" rel="nofollow">http://man.linuxde.net/netstat</a></p> 
<p> </p> 
<p><span style="color:#333333;">Netstat 用于显示与 IP、TCP、UDP 和 ICMP 协议相关的统计数据，一般用于检验<strong>本机各端口的网络连接情况</strong>。</span><span style="color:#333333;">如果你的计算机有时候接收到的数据报导致出错数据或故障，你不必感到奇怪，TCP/IP可以容许这些类型的错误，并能够自动重发数据报。但如果累计的出错情况数目占到所接收的IP数据报相当大的百分比，或者它的数目正迅速增加，那么你就应该使用 Netstat 查一查为什么会出现这些情况了。</span></p> 
<p>在 windows下有个小工具挺好的，TCPView。当然如果要详细分析数据包，可选用 sniffer、Wireshark 等更强大的工具。</p> 
<p> </p> 
<p> </p> 
<h2>1. 网络连接状态详解</h2> 
<p> </p> 
<p>共有 12 中可能的状态，前面11种是按照 TCP 连接建立的三次握手和 TCP 连接断开的四次挥手过程来描述的。</p> 
<pre class="has"><code class="language-plain">1)、LISTEN:首先服务端需要打开一个socket进行监听，状态为LISTEN.
    /* The socket is listening for incoming connections. 侦听来自远方TCP端口的连接请求 */

2)、SYN_SENT:客户端通过应用程序调用connect进行active open.于是客户端tcp发送一个SYN以请求建立一个连接.之后状态置为SYN_SENT.
    /*The socket is actively attempting to establish a connection. 在发送连接请求后等待匹配的连接请求 */

3)、SYN_RECV:服务端应发出ACK确认客户端的 SYN,同时自己向客户端发送一个SYN. 之后状态置为SYN_RECV
    /* A connection request has been received from the network. 在收到和发送一个连接请求后等待对连接请求的确认 */

4)、ESTABLISHED: 代表一个打开的连接，双方可以进行或已经在数据交互了。
    /* The socket has an established connection. 代表一个打开的连接，数据可以传送给用户 */

5)、FIN_WAIT1:主动关闭(active close)端应用程序调用close，于是其TCP发出FIN请求主动关闭连接，之后进入FIN_WAIT1状态.
    /* The socket is closed, and the connection is shutting down. 等待远程TCP的连接中断请求，或先前的连接中断请求的确认 */

6)、CLOSE_WAIT:被动关闭(passive close)端TCP接到FIN后，就发出ACK以回应FIN请求(它的接收也作为文件结束符传递给上层应用程序),并进入CLOSE_WAIT.
    /* The remote end has shut down, waiting for the socket to close. 等待从本地用户发来的连接中断请求 */

7)、FIN_WAIT2:主动关闭端接到ACK后，就进入了 FIN-WAIT-2 .
    /* Connection is closed, and the socket is waiting for a shutdown from the remote end. 从远程TCP等待连接中断请求 */

8)、LAST_ACK:被动关闭端一段时间后，接收到文件结束符的应用程序将调用CLOSE关闭连接。这导致它的TCP也发送一个 FIN,等待对方的ACK.就进入了LAST-ACK .
    /* The remote end has shut down, and the socket is closed. Waiting for acknowledgement. 等待原来发向远程TCP的连接中断请求的确认 */

9)、TIME_WAIT:在主动关闭端接收到FIN后，TCP 就发送ACK包，并进入TIME-WAIT状态。
    /* The socket is waiting after close to handle packets still in the network.等待足够的时间以确保远程TCP接收到连接中断请求的确认 */

10)、CLOSING: 比较少见.
    /* Both sockets are shut down but we still don’t have all our data sent. 等待远程TCP对连接中断的确认 */

11)、CLOSED: 被动关闭端在接受到ACK包后，就进入了closed的状态。连接结束.
    /* The socket is not being used. 没有任何连接状态 */

12)、UNKNOWN: 未知的Socket状态。
    /* The state of the socket is unknown. */</code></pre> 
<pre class="has"><code class="language-plain">SYN: (同步序列编号,Synchronize Sequence Numbers)该标志仅在三次握手建立TCP连接时有效。表示一个新的TCP连接请求。
ACK: (确认编号,Acknowledgement Number)是对TCP请求的确认标志,同时提示对端系统已经成功接收所有数据。
FIN: (结束标志,FINish)用来结束一个TCP回话.但对应端口仍处于开放状态,准备接收后续数据。</code></pre> 
<p>TCP 3 次握手，4 次挥手</p> 
<p>TCP状态转换图详解：<a href="https://www.pianshen.com/article/6579280764/" rel="nofollow">https://www.pianshen.com/article/6579280764/</a></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/85/c1/FLPqn1SJ_o.jpg"></p> 
<p>TCP三路握手过程的状态变迁：</p> 
<ol><li><strong>CLOSED</strong>：起始点，在超时或者连接关闭时候进入此状态，这并不是一个真正的状态，而是这个状态图的假想起点和终点。</li><li><strong>LISTEN</strong>：服务器端等待连接的状态。服务器经过 socket，bind，listen 函数之后进入此状态，开始监听客户端发过来的连接请求。此称为应用程序被动打开（等到客户端连接请求）。</li><li><strong>SYN_SENT</strong>：第一次握手发生阶段，客户端发起连接。客户端调用 connect，发送 SYN 给服务器端，然后进入 SYN_SENT 状态，等待服务器端确认（三次握手中的第二个报文）。如果服务器端不能连接，则直接进入CLOSED状态。</li><li><strong>SYN_RCVD</strong>：第二次握手发生阶段，跟 3 对应，这里是服务器端接收到了客户端的 SYN，此时服务器由 LISTEN 进入 SYN_RCVD状态，同时服务器端回应一个 ACK，然后再发送一个 SYN 即 SYN+ACK 给客户端。状态图中还描绘了这样一种情况，当客户端在发送 SYN 的同时也收到服务器端的 SYN请求，即两个同时发起连接请求，那么客户端就会从 SYN_SENT 转换到 SYN_REVD 状态。</li><li><strong>ESTABLISHED</strong>：第三次握手发生阶段，客户端接收到服务器端的 ACK 包（ACK，SYN）之后，也会发送一个 ACK 确认包，客户端进入 ESTABLISHED 状态，表明客户端这边已经准备好，但TCP 需要两端都准备好才可以进行数据传输。服务器端收到客户端的 ACK 之后会从 SYN_RCVD 状态转移到 ESTABLISHED 状态，表明服务器端也准备好进行数据传输了。这样客户端和服务器端都是 ESTABLISHED 状态，就可以进行后面的数据传输了。所以 ESTABLISHED 也可以说是一个数据传送状态。</li></ol> 
<p>上面就是 TCP 三次握手过程的状态变迁。从报文的角度看状态变迁：SYN_SENT 状态表示已经客户端已经发送了 SYN 报文，SYN_RCVD 状态表示服务器端已经接收到了 SYN 报文。</p> 
<p>下面看看TCP四次挥手过程的状态变迁：</p> 
<ol><li><strong>FIN_WAIT_1</strong>：第一次挥手。主动关闭的一方（执行主动关闭的一方既可以是客户端，也可以是服务器端，这里以客户端执行主动关闭为例），终止连接时，发送 FIN 给对方，然后等待对方返回 ACK 。调用 close() 第一次挥手就进入此状态。</li><li><strong>CLOSE_WAIT</strong>：接收到FIN 之后，被动关闭的一方进入此状态。具体动作是接收到 FIN，同时发送 ACK。之所以叫 CLOSE_WAIT 可以理解为被动关闭的一方此时正在等待上层应用程序发出关闭连接指令。前面已经说过，TCP关闭是全双工过程，这里客户端执行了主动关闭，被动方服务器端接收到FIN 后也需要调用 close 关闭，这个 CLOSE_WAIT 就是处于这个状态，等待发送 FIN，发送了FIN 则进入 LAST_ACK 状态。</li><li><strong>FIN_WAIT_2</strong>：主动端（这里是客户端）先执行主动关闭发送FIN，然后接收到被动方返回的 ACK 后进入此状态。</li><li><strong>LAST_ACK</strong>：被动方（服务器端）发起关闭请求，由状态2 进入此状态，具体动作是发送 FIN给对方，同时在接收到ACK 时进入CLOSED状态。</li><li><strong>CLOSING</strong>：两边同时发起关闭请求时（即主动方发送FIN，等待被动方返回ACK，同时被动方也发送了FIN，主动方接收到了FIN之后，发送ACK给被动方），主动方会由FIN_WAIT_1 进入此状态，等待被动方返回ACK。</li><li><strong>TIME_WAIT</strong>：从状态变迁图会看到，四次挥手操作最后都会经过这样一个状态然后进入CLOSED状态。共有三个状态会进入该状态</li></ol> 
<ul><li>由CLOSING进入：同时发起关闭情况下，当主动端接收到ACK后，进入此状态，实际上这里的同时是这样的情况：客户端发起关闭请求，发送FIN之后等待服务器端回应ACK，但此时服务器端同时也发起关闭请求，也发送了FIN，并且被客户端先于ACK接收到。</li><li>由FIN_WAIT_1进入：发起关闭后，发送了FIN，等待ACK的时候，正好被动方（服务器端）也发起关闭请求，发送了FIN，这时客户端接收到了先前ACK，也收到了对方的FIN，然后发送ACK（对对方FIN的回应），与CLOSING进入的状态不同的是接收到FIN和ACK的先后顺序。</li><li>由FIN_WAIT_2进入：这是不同时的情况，主动方在完成自身发起的主动关闭请求后，接收到了对方发送过来的FIN，然后回应 ACK。</li></ul> 
<p>下面来看看这个看似有点多余的TIME_WAIT状态：从上面进入TIME_WAIT状态的三个状态动作来看（可以直接看状态变迁图）都是主动方最后回应一个ACK（CLOSING实际上前面的那个FIN_WAIT_1状态就已经回应了ACK）。</p> 
<p>先考虑这样的一个情况，假如这个最后回应的ACK丢失了，也就是服务器端接收不到这个ACK，那么服务器将继续发送它最终的那个FIN，因此客户端必须维护状态信息（TIME_WAIT）允许它重发最后的那个ACK。如果没有这个TIME_WAIT状态，客户端处于CLOSED状态（开头就说了CLOSED状态实际并不存在，是我们为了方便描述假想的），那么客户端将响应RST，服务器端收到后会将该RST分节解释成一个错误，也就不能实现最后的全双工关闭了（可能是主动方单方的关闭）。所以要实现TCP全双工连接的正常终止（两方都关闭连接），必须处理终止过程中四个分节任何一个分节的丢失情况，那么主动关闭连接的主动端必须维持TIME_WAIT状态，最后一个回应ACK的是主动执行关闭的那端。从变迁图可以看出，如果没有TIME_WAIT状态，我们将没有任何机制来保证最后一个ACK能够正常到达。前面的FIN，ACK正常到达均有相应的状态对应。</p> 
<p>还有这样一种情况，如果目前的通信双方都已经调用了 close()，都到达了CLOSED状态，没有TIME_WAIT状态时，会出现这样一种情况，现在有一个新的连接被建立起来，使用的IP地址和端口和这个先前到达了CLOSED状态的完全相同，假定原先的连接中还有数据报残存在网络之中，这样新的连接建立以后传输的数据极有可能就是原先的连接的数据报，为了防止这一点，TCP不允许从处于TIME_WAIT状态的socket 建立一个连接。处于TIME_WAIT状态的 socket 在等待了两倍的MSL时间之后，将会转变为CLOSED状态。这里TIME_WAIT状态持续的时间是2MSL（MSL是任何IP数据报能够在因特网中存活的最长时间），足以让这两个方向上的数据包被丢弃（最长是2MSL）。通过实施这个规则，我们就能保证每成功建立一个TCP连接时，来自该连接先前化身的老的重复分组都已经在网络中消逝了。</p> 
<p>  综上来看：TIME_WAIT存在的两个理由就是</p> 
<ol><li>可靠地实现TCP全双工连接的终止；</li><li>允许老的重复分节（数据报）在网络中消逝。</li></ol> 
<p>参考资料《UNIX环境高级编程》《TCP/IP 卷1》</p> 
<p>TCP 状态转移过程图</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/df/3f/kTsj1v8T_o.jpg"></p> 
<p> </p> 
<p> </p> 
<h2>2. Windows 下 netstat 参数</h2> 
<p> </p> 
<p><span style="color:#333333;">C:\&gt;</span><span style="color:#7c79e5;"><strong> netstat /?</strong></span><br><span style="color:#333333;">显示协议统计信息和当前 TCP/IP 网络连接。</span></p> 
<pre class="has"><code class="language-plain">NETSTAT [-a] [-b] [-e] [-n] [-o] [-p proto] [-r] [-s] [-v] [interval]
  -a            显示所有连接和监听端口。
  -b            显示包含于创建每个连接或监听端口的可执行组件。即 显示在创建网络连接和侦听端口时所涉及的可执行程序。
                在某些情况下已知可执行组件拥有多个独立组件，并且在这些情况下包含于创建连接或监听端口的组件序列被显示。
                这种情况下，可执行组件名在底部的 [] 中，顶部是其调用的组件等等，直到 TCP/IP部分。
                注意此选项可能需要很长时间，如果没有足够权限可能失败。
  -e            显示以太网统计信息。此选项可以与 -s选项组合使用。
  -n            以数字形式显示地址和端口号。禁止域名解析 
  -o            显示与每个连接相关的所属进程 ID。
  -p proto      显示 proto 指定的协议的连接；proto 可以是下列协议之一: TCP、UDP、TCPv6 或 UDPv6。
                如果与 -s 选项一起使用以显示按协议统计信息，proto可以是下列协议之一:IP、IPv6、ICMP、ICMPv6、TCP、TCPv6、UDP 或()UDPv6。
  -r            显示路由表。
  -s            显示按协议统计信息。默认地，显示 IP、IPv6、ICMP、ICMPv6、TCP、TCPv6、UDP 和 UDPv6 的统计信息；-p 选项用于指定默认情况的子集。
  -t            显示当前连接卸载状态。
  -v            与 -b 选项一起使用时将显示包含于为所有可执行组件创建连接或监听端口的组件。
  interval      重新显示选定统计信息，每次显示之间暂停时间间隔(以秒计)。按 CTRL+C 停止重新显示统计信息。
                如果省略，netstat 显示当前配置信息(只显示一次)</code></pre> 
<p><strong>Netstat 的一些常用选项</strong><span style="color:#333333;"><strong> </strong></span></p> 
<ul><li><span style="color:#7c79e5;"><strong>netstat -s</strong></span><span style="color:#333333;">    </span><span style="color:#333333;">按照各个协议分别显示其统计数据。如果你的应用程序（如Web浏览器）运行速度比较慢，或者不能显示Web页之类的数据，那么你就可以用本选项来查看一下所显示的信息。你需要仔细查看统计数据的各行，找到出错的关键字，进而确定问题所在。 </span></li><li><span style="color:#7c79e5;"><strong>netstat -e</strong></span><span style="color:#333333;">    </span><span style="color:#333333;">显示关于以太网的统计数据。它列出的项目包括传送的数据报的总字节数、错误数、删除数、数据报的数量和广播的数量。这些统计数据既有发送的数据报数量，也有接收的数据报数量。这个选项可以用来统计一些基本的网络流量。 </span></li><li><span style="color:#7c79e5;"><strong>netstat -r</strong></span><span style="color:#333333;">    </span><span style="color:#333333;">显示关于路由表的信息，类似于使用 route print 命令时看到的 信息。除了显示有效路由外，还显示当前有效的连接。 </span></li><li><span style="color:#7c79e5;"><strong>netstat -a</strong></span><span style="color:#333333;">    </span><span style="color:#333333;">显示一个所有的有效连接信息列表，包括已建立的连接（ESTABLISHED），也包括监听连接请求（LISTENING）的那些连接，断开连接（CLOSE_WAIT）或者处于联机等待状态的（TIME_WAIT）等</span></li><li><span style="color:#7c79e5;"><strong>netstat -n</strong></span><span style="color:#333333;">    以 <strong>点分四段式 </strong>的形式<strong>输出IP地址</strong>，而不是象征性的主机名和网络名。如果想避免通过网络查找地址（比如避开DNS或NIS服务器），这一点是特别有用的。 </span></li></ul> 
<p><span style="color:#333333;">调用 </span><span style="color:#7c79e5;"><strong>netstat -ta</strong></span><span style="color:#333333;"> 时，输出结果如下： </span></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/c2/f2/QslwPoep_o.png"></p> 
<p>linux 结果截图：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/81/cd/4aDaO73N_o.png"></p> 
<p><span style="color:#333333;">上面的输出表明部分服务器处于等待接入连接状态。利用 -</span><span style="color:#333333;">a 选项的话，netstat 还会显示出所有的套接字。注意根据端口号，可以判断出一条连接是否是外出连接。对呼叫方主机来说，列出的端口号应该一直是一个</span><span style="color:#333333;">整数，而对众所周知服务（well known service）端口正在使用中的被呼叫方来说，netstat 采用的则是取自 /etc/services 文件的象征性服务名。</span></p> 
<p> </p> 
<p><span style="color:#333333;">Netstat 可以用来获得系统网络连接的信息（使用的端口，在使用的协议等 ），收到和发出的数据，被连接的远程系统的端口，Netstat 在内存中读取所有的网络信息。</span><span style="color:#333333;">在Internet RFC标准中，Netstat 的定义是： Netstat 是在内核中访问网络及相关信息的程序，它能提供TCP连接，TCP和UDP监听，进程内存管理的相关报告。对于好奇心极强的人来说，上面的理论是远远不够的，接下来我们来详细的解释一下各个参数的使用，看看执行之后会发生什么，显示的信息又是什么意思，好了，废话不说了，让我们一起来实践一下吧：）</span></p> 
<pre class="has"><code class="language-plain">C:\&gt;netstat -a
Active Connections
  Proto  Local Address          Foreign Address        State
  TCP    Eagle:ftp              Eagle:0                LISTENING
  TCP    Eagle:8001             Eagle:0                LISTENING
  TCP    Eagle:8005             Eagle:0                LISTENING
  TCP    Eagle:8065             Eagle:0                LISTENING
  TCP    Eagle:microsoft-ds     localhost:1031         ESTABLISHED
  TCP    Eagle:1031             localhost:microsoft-ds  ESTABLISHED
  TCP    Eagle:1040             Eagle:0                LISTENING
  TCP    Eagle:netbios-ssn      Eagle:0                LISTENING
  TCP    Eagle:1213             218.85.139.65:9002     CLOSE_WAIT
  TCP    Eagle:2927             219.137.227.10:4899    TIME_WAIT
  TCP    Eagle:2928             219.137.227.10:4899    TIME_WAIT
  TCP    Eagle:2929             219.137.227.10:4899    ESTABLISHED
  TCP    Eagle:3455             218.85.139.65:9002     ESTABLISHED
  TCP    Eagle:netbios-ssn      Eagle:0                LISTENING
  UDP    Eagle:microsoft-ds     *:*
  UDP    Eagle:1046             *:*
  UDP    Eagle:netbios-ns       *:*
  UDP    Eagle:netbios-dgm      *:*</code></pre> 
<p>我们拿其中一行来解释：</p> 
<pre class="has"><code class="language-plain">Proto  Local Address          Foreign Address        State
TCP    Eagle:2929             219.137.227.10:4899    ESTABLISHED</code></pre> 
<pre class="has"><code class="language-plain">协议（Proto）：TCP，指是传输层通讯协议（什么？不懂？请用baidu搜索"TCP"，OSI七层和TCP/IP四层可是基础^_^）
本地机器名（Local  Address）：Eagle，计算机名，安装系统时设置的，可以在“我的电脑”属性中修改，本地打开并用于连接的端口：2929）   
远程机器名（Foreign  Address）：219.137.227.10
远程端口：4899  
状态：ESTABLISHED  </code></pre> 
<p><span style="color:#333333;"><strong>状态列表</strong></span></p> 
<pre class="has"><code class="language-plain">LISTEN  ：在监听状态中。   
ESTABLISHED：已建立联机的联机情况。 
TIME_WAIT：该联机在目前已经是等待的状态。 </code></pre> 
<p><span style="color:#333333;">-a 参数常用于获得你的本地系统开放的端口，用它您可以自己检查你的系统上有没有被安装木马（ps：有很多好程序用来检测木马，但你的目的是想成为真正的hacker，手工检测要比只按一下“scan”按钮好些----仅个人观点）。如果您 Netstat 你自己的话，发现下面的信息： </span><br><span style="color:#333333;">　　</span><br><span style="color:#333333;">　　Port 12345(TCP) Netbus </span><br><span style="color:#333333;">　　Port 31337(UDP) Back Orifice </span><br><span style="color:#333333;">　　</span><br><span style="color:#333333;">　　祝贺!您中了最常见的木马（^_^，上面4899是我连别人的，而且这个radmin 是商业软件，目前我最喜欢的远程控制软件） </span><br><span style="color:#333333;">　　如果你需要木马及其端口列表的话，去国内的 H站找找，或者baidu，google吧 </span><br><span style="color:#333333;">　　</span><br><span style="color:#333333;">　　***************************************************************** </span><span style="color:#333333;">　</span><br><span style="color:#333333;">　　#一些原理：也许你有这样的问题：“在机器名后的端口号代表什么？ </span><br><span style="color:#333333;">　　例子：Eagle:2929</span><br><span style="color:#333333;">　　小于1024的端口通常运行一些网络服务，大于1024的端口用来与远程机器建立连接。　　</span><br><span style="color:#333333;">　　*****************************************************************</span><br><br><span style="color:#333333;">继续我们的探讨，使用 -n 参数。命令：</span><span style="color:#7c79e5;"><strong>netstat -n</strong></span><span style="color:#333333;">   基本上是 -a 参数的数字形式：</span></p> 
<pre class="has"><code class="language-plain">C:\&gt;netstat -n
Active Connections
  Proto  Local Address          Foreign Address        State
  TCP    127.0.0.1:445          127.0.0.1:1031         ESTABLISHED
  TCP    127.0.0.1:1031         127.0.0.1:445          ESTABLISHED
  TCP    192.168.1.180:1213     218.85.139.65:9002     CLOSE_WAIT
  TCP    192.168.1.180:2416     219.133.63.142:443     CLOSE_WAIT
  TCP    192.168.1.180:2443     219.133.63.142:443     CLOSE_WAIT
  TCP    192.168.1.180:2907     192.168.1.101:2774     CLOSE_WAIT
  TCP    192.168.1.180:2916     192.168.1.101:23       ESTABLISHED
  TCP    192.168.1.180:2929     219.137.227.10:4899    ESTABLISHED
  TCP    192.168.1.180:3048     192.168.1.1:8004       SYN_SENT
  TCP    192.168.1.180:3455     218.85.139.65:9002     ESTABLISHED</code></pre> 
<p><span style="color:#333333;">得到 IP 等于得到一切，它是最容易使机器受到攻击的东东，所以隐藏自己 IP，获得别人的 IP 对 hacker 来说非常重要，现在隐藏 IP 技术很流行，但那些隐藏工具或服务真的让你隐身吗？我看不见得，呵呵，代理，跳板不属于今天讨论，一个获取对方IP的简单例子请参考我前面的文章【 </span><a href="http://hawkoo.bokee.com/viewdiary.10456844.html" rel="nofollow">用DOS命令查QQ好友IP地址</a> <span style="color:#333333;">】</span></p> 
<p><span style="color:#333333;"><strong>-a 和 -n 是最常用的命令</strong>，如果要显示一些协议的更详细信息，就要用 -p 这个参数了，它其实是 -a 和 -n 的一个变种，我们来看一个实例，你就明白了：【netstat -p @@@ 其中@@@为TCP或者UDP】</span></p> 
<pre class="has"><code class="language-plain">C:\&gt;netstat -p tcp
Active Connections
  Proto  Local Address          Foreign Address        State
  TCP    Eagle:microsoft-ds     localhost:1031         ESTABLISHED
  TCP    Eagle:1031             localhost:microsoft-ds  ESTABLISHED
  TCP    Eagle:1213             218.85.139.65:9002     CLOSE_WAIT
  TCP    Eagle:2416             219.133.63.142:https   CLOSE_WAIT
  TCP    Eagle:2443             219.133.63.142:https   CLOSE_WAIT
  TCP    Eagle:2907             192.168.1.101:2774     CLOSE_WAIT
  TCP    Eagle:2916             192.168.1.101:telnet   ESTABLISHED
  TCP    Eagle:2929             219.137.227.10:4899    ESTABLISHED
  TCP    Eagle:3455             218.85.139.65:9002     ESTABLISHED</code></pre> 
<p><span style="color:#7c79e5;"><strong>netstat -e </strong></span><span style="color:#333333;">：含义：本选项用于显示关于以太网的统计数据。它列出的项目包括传送的数据报的总字节数、错误数、删除数、数据报的数量和广播的数量。这些统计数据既有发送的数据报数量，也有接收的数据报数量。这个选项可以用来统计一些基本的网络流量。</span></p> 
<pre class="has"><code class="language-plain">C:\&gt;netstat -e
Interface Statistics
                           Received            Sent
Bytes                     143090206        44998789
Unicast packets              691805          363603
Non-unicast packets          886526            2386
Discards                          0               0
Errors                            0               0
Unknown protocols              4449</code></pre> 
<p><span style="color:#333333;">    若接收错和发送错接近为零或全为零，网络的接口无问题。但当这两个字段有100个以上的出错分组时就可以认为是高出错率了。高的发送错表示本地网络饱和或在主机与网络之间有不良的物理连接;  高的接收错表示整体网络饱和、本地主机过载或物理连接有问题，可以用Ping命令统计误码率，进一步确定故障的程度。netstat -e 和ping结合使用能解决一大部分网络故障。</span><span style="color:#333333;">    </span></p> 
<p><span style="color:#7c79e5;"><strong>netstat -r</strong></span><span style="color:#333333;">  <strong>是用来显示路由表信息</strong>，我们来看例子：</span></p> 
<pre class="has"><code class="language-plain">C:\&gt;netstat -r
Route Table（路由表）
===========================================================================
Interface List（网络接口列表）
0x1 ........................... MS TCP Loopback interface
0x10003 ...00 0c f1 02 76 81 ...... Intel(R) PRO/Wireless LAN 2100 3B Mini PCI
dapter
0x10004 ...00 02 3f 00 05 cb ...... Realtek RTL8139/810x Family Fast Ethernet
C
===========================================================================
===========================================================================
Active Routes:（动态路由）
Network Destination        Netmask          Gateway       Interface  Metric
          0.0.0.0          0.0.0.0    192.168.1.254   192.168.1.181       30
          0.0.0.0          0.0.0.0    192.168.1.254   192.168.1.180       20
        127.0.0.0        255.0.0.0        127.0.0.1       127.0.0.1       1
      192.168.1.0    255.255.255.0    192.168.1.180   192.168.1.180       20
      192.168.1.0    255.255.255.0    192.168.1.181   192.168.1.181       30
    192.168.1.180  255.255.255.255        127.0.0.1       127.0.0.1       20
    192.168.1.181  255.255.255.255        127.0.0.1       127.0.0.1       30
    192.168.1.255  255.255.255.255    192.168.1.180   192.168.1.180       20
    192.168.1.255  255.255.255.255    192.168.1.181   192.168.1.181       30
        224.0.0.0        240.0.0.0    192.168.1.180   192.168.1.180       20
        224.0.0.0        240.0.0.0    192.168.1.181   192.168.1.181       30
  255.255.255.255  255.255.255.255    192.168.1.180   192.168.1.180       1
  255.255.255.255  255.255.255.255    192.168.1.181   192.168.1.181       1
Default Gateway:     192.168.1.254（默认网关）
===========================================================================
Persistent Routes:（静态路由）
  None
C:\&gt;</code></pre> 
<p><span style="color:#7c79e5;"><strong>netstat -s</strong></span><span style="color:#333333;"> 参数的作用前面有详细的说明，来看例子</span></p> 
<pre class="has"><code class="language-plain">C:\&gt;netstat -s
IPv4 Statistics       （IP统计结果）    
  Packets Received                   = 369492（接收包数）
  Received Header Errors             = 0（接收头错误数）
  Received Address Errors            = 2（接收地址错误数）
  Datagrams Forwarded                = 0（数据报递送数）
  Unknown Protocols Received         = 0（未知协议接收数）
  Received Packets Discarded         = 4203（接收后丢弃的包数）
  Received Packets Delivered         = 365287（接收后转交的包数）
  Output Requests                    = 369066（请求数）
  Routing Discards                   = 0（路由丢弃数 ）
  Discarded Output Packets           = 2172（包丢弃数）
  Output Packet No Route             = 0（不路由的请求包）
  Reassembly Required                = 0（重组的请求数）
  Reassembly Successful              = 0（重组成功数）
  Reassembly Failures                = 0（重组失败数）
  Datagrams Successfully Fragmented  = 0（分片成功的数据报数）
  Datagrams Failing Fragmentation    = 0（分片失败的数据报数）
  Fragments Created                  = 0（分片建立数）
ICMPv4 Statistics （ICMP统计结果）包括Received和Sent两种状态
                            Received    Sent
  Messages                  285         784（消息数）
  Errors                    0           0（错误数）
  Destination Unreachable   53          548（无法到达主机数目）
  Time Exceeded             0           0（超时数目）
  Parameter Problems        0           0（参数错误）
  Source Quenches           0           0（源夭折数）
  Redirects                 0           0（重定向数）
  Echos                     25          211（回应数）
  Echo Replies              207         25（回复回应数）
  Timestamps                0           0（时间戳数）
  Timestamp Replies         0           0（时间戳回复数）
  Address Masks             0           0（地址掩码数）
  Address Mask Replies      0           0（地址掩码回复数）
TCP Statistics for IPv4（TCP统计结果）
  Active Opens                        = 5217（主动打开数）
  Passive Opens                       = 80（被动打开数）
  Failed Connection Attempts          = 2944（连接失败尝试数）
  Reset Connections                   = 529（复位连接数）
  Current Connections                 = 9（当前连接数目）
  Segments Received                   = 350143（当前已接收的报文数）
  Segments Sent                       = 347561（当前已发送的报文数）
  Segments Retransmitted              = 6108（被重传的报文数目）
UDP Statistics for IPv4（UDP统计结果）
  Datagrams Received    = 14309（接收的数据包）
  No Ports              = 1360（无端口数）
  Receive Errors        = 0（接收错误数）
  Datagrams Sent        = 14524（数据包发送数）
C:\&gt;</code></pre> 
<p><span style="color:#333333;">还有几个常用的命令参数是 WindowsXP 独有的，-b 和 -v 这两个参数的解释在前面也是很详细了，我下面展示两个例子吧（主要是要显示对应的应用程序组件等详细信息，有马儿立刻献身喔，^_^）</span></p> 
<pre class="has"><code class="language-plain">C:\&gt;netstat -b

Active Connections

  Proto  Local Address          Foreign Address        State           PID
  TCP    Eagle:microsoft-ds     localhost:1031         ESTABLISHED     4
  [System]

  TCP    Eagle:1031             localhost:microsoft-ds  ESTABLISHED     4
  [System]

  TCP    Eagle:2929             219.137.227.10:4899    ESTABLISHED     3224
  [radmin.exe]

  TCP    Eagle:3455             218.85.139.65:9002     ESTABLISHED     1924
  [DCA.exe]

  TCP    Eagle:1213             218.85.139.65:9002     CLOSE_WAIT      1924
  [DCA.exe]

  TCP    Eagle:2416             219.133.63.142:https   CLOSE_WAIT      596
  [QQ.exe]

  TCP    Eagle:2443             219.133.63.142:https   CLOSE_WAIT      596
  [QQ.exe]

  TCP    Eagle:2907             192.168.1.101:2774     CLOSE_WAIT      596
  [QQ.exe]


C:\&gt;netstat -v
Active Conne</code></pre> 
<p> </p> 
<p> </p> 
<h2>3. linux 下 netstat 参数</h2> 
<p> </p> 
<p>netstat --- <em>Print network connections, routing tables, interface statistics, masquerade connections, and multi‐cast memberships。</em></p> 
<p>Netstat 命令用于显示各种网络相关信息，如网络连接，路由表，接口状态 (Interface Statistics)，masquerade 连接，多播成员 (Multicast Memberships) 等等。</p> 
<pre class="has"><code class="language-plain">root@kali:~# netstat -h
usage: netstat [-vWeenNcCF] [&lt;Af&gt;] -r         netstat {-V|--version|-h|--help}
       netstat [-vWnNcaeol] [&lt;Socket&gt; ...]
       netstat { [-vWeenNac] -i | [-cnNe] -M | -s [-6tuw] }

        -r, --route              显示路由表.显示核心路由表，类似 route -e。
        -i, --interfaces         显示网卡接口。即显示所有网络接口的信息。
        -g, --groups             显示多播组成员。显示多重广播功能群组组员名单。
        -s, --statistics         显示网络统计数据 (like SNMP)。 按各个协议进行统计。
        -M, --masquerade         display masqueraded connections。显示伪装的网络连线。

        -v, --verbose            详细信息
        -W, --wide               不截断IP地址
        -n, --numeric            不解析主机名。即使用数字形式的 IP 地址。禁止域名解析 
        --numeric-hosts          不解析主机名
        --numeric-ports          不解析端口名
        --numeric-users          不解析用户名
        -N, --symbolic           解析硬件名。显示网络硬件外围设备的符号连接名称。
        -e, --extend             显示网络其他更多相关信息。显示扩展信息。
        -p, --programs           显示正在使用Socket的程序PID和程序名称。
        -o, --timers             display timers。显示计时器。
        -c, --continuous         列出所有连接。每隔1秒就重新显示一遍，直到用户中断它。

        -l, --listening          显示服务器处于监听中的套接字。
        -a, --all                显示所有套接字 (默认: connected)。包括正在监听的。
        -F, --fib                display Forwarding Information Base (default)。显示FIB。
        -C, --cache              display routing cache instead of FIB。显示路由器缓存信息。
        -Z, --context            display SELinux security context for sockets

  &lt;Socket&gt;={-t|--tcp} {-u|--udp} {-U|--udplite} {-S|--sctp} {-w|--raw}
           {-x|--unix} --ax25 --ipx --netrom
  &lt;AF&gt;=Use '-6|-4' or '-A &lt;af&gt;' or '--&lt;af&gt;'; default: inet  
      -A&lt;网络类型&gt; 或 --&lt;网络类型&gt;     列出该网络类型连线中的相关地址。
  下面列出了可用的 address families (支持路由的):
    inet (DARPA Internet) inet6 (IPv6) ax25 (AMPR AX.25) netrom (AMPR NET/ROM) ipx (Novell IPX) ddp (Appletalk DDP) x25 (CCITT X.25)
root@kali:~#

-t 或 --tcp          显示TCP协议的连接情况
-u 或 --udp          显示UDP协议的连接情况。
-v 或 --verbose      显示指令执行过程。即显示正在进行的工作。
-V 或 --version      显示版本信息。
-w 或 --raw          显示RAW传输协议的连线状况。
-x 或 --unix         此参数的效果和指定 "-A unix" 参数相同。
--ip 或 --inet        此参数的效果和指定 "-A inet" 参数相同。</code></pre> 
<p>提示：LISTEN 和 LISTENING 的状态只有用 -a 或者 -l 才能看到</p> 
<blockquote> 
 <p>统计机器中网络连接各个状态个数。<br>         命令：netstat -a | awk '/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}'</p> 
 <p>把状态全都取出来后使用 uniq -c 统计后再进行排序。<br>         命令：netstat -nat |awk '{print $6}'|sort|uniq -c</p> 
 <p>查看连接某服务端口最多的的IP地址。<br>         命令：netstat -nat | grep "192.168.120.20:16067" |awk '{print $5}'|awk -F: '{print $4}'|sort|uniq -c|sort -nr|head -20</p> 
 <p>找出 ssh 程序运行的端口。<br>         命令：netstat -ap | grep ssh</p> 
 <p>在 netstat 输出中显示 PID 和进程名称。<br>         命令：netstat -pt</p> 
 <p>找出<strong>运行在指定端口的进程</strong>。然后再通过 ps 命令就可以找到具体的应用程序了。<br>         命令：netstat -anpt | grep ':16064'    </p> 
 <p>其他组合：-tan、-uan、-tnl、-unl、-tunlp、-tal</p> 
</blockquote> 
<p><span style="color:#333333;">netstat 支持用于显示活动或被动套接字的选项集。<strong><em>选项  -t、-u、-w 和 -</em></strong></span><span style="color:#333333;"><strong><em>x 分别表示 TCP、UDP、RAW 和 UNIX套接字连接。</em></strong>如果你另外还提供了一个 -</span><span style="color:#333333;">a 标记，还会显示出等待连接（也就是说处于监听模式）的套接字。这样就可以得到一份当前运行于系统中的所有服务清单。 </span></p> 
<p><span style="color:#7c79e5;"><strong>netstat -i</strong></span><span style="color:#333333;"> 的输出结果是这样的： </span></p> 
<p style="text-align:center;"><img alt="" height="156" src="https://images2.imgbox.com/68/47/VeAOjRz7_o.png" width="1058"></p> 
<ul><li><span style="color:#333333;">MTU 和 Met 字段表示的是接口的MTU和度量值值；</span></li><li><span style="color:#333333;">RX和TX这两列表示的是已经准确无误地收发了多少数据包（ RX - OK / TX -</span></li><li><span style="color:#333333;">OK）、产生了多少错误（</span><span style="color:#333333;">RX-ERR/TX-ERR）、丢弃了多少包（RX-DRP/TX-DRP），由于误差而遗失了多少包（RX-OVR/TX-OVR）；</span></li><li><span style="color:#333333;">最后一列展示的是为这个接口设置的标记，在利用 ifconfig 显示接口配置时，这些标记都采用一个字母。它们的说明如下： </span> <pre class="has"><code class="language-plain">■ B 已经设置了一个广播地址。 
■ L 该接口是一个回送设备。 
■ M 接收所有数据包（混乱模式）。 
■ N 避免跟踪。 
■ O 在该接口上，禁用A R P。 
■ P 这是一个点到点链接。 
■ R 接口正在运行。 
■ U 接口处于“活动”状态。 ◆ 显示路由表 </code></pre> </li></ul> 
<p><span style="color:#7c79e5;"><strong>netstat -r</strong></span><span style="color:#333333;"> 显示内核路由表，就像我们利用 route 命令一样。产生的输出如下： </span></p> 
<p style="text-align:center;"><img alt="" height="158" src="https://images2.imgbox.com/37/7e/OfjA5vHA_o.png" width="1020"></p> 
<p><span style="color:#333333;">netstat 输出结果中，第二列展示的是路由条目所指的网关，如果没有使用网关，就会出现一个星号（*）或者0.0.0.0；第三列展示路由的概述，在</span><br><span style="color:#333333;">为具体的I P地址找出最恰当的路由时，内核将查看路由表内的所有条目，在对找到的路由与目标路由比较之前，将对I</span><span style="color:#333333;">P地址和genmask进行按位“与”计算；第四列显示了不同的标记，这些标记的说明如下： </span></p> 
<pre class="has"><code class="language-plain">■ G 路由将采用网关。 
■ U 准备使用的接口处于“活动”状态。 
■ H 通过该路由，只能抵达一台主机。 
■ D 如果路由表的条目是由ICMP重定向消息生成的，就会设置这个标记。 
■ M 如果路由表条目已被ICMP重定向消息修改，就会设置这个标记。 </code></pre> 
<p><span style="color:#333333;">netstat 输出结果的 Iface 显示该连接所用的物理网卡，如eth0表示用第一张，eth1表示用第二张。</span></p> 
<p><strong> -n 参数 对比</strong></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/34/a8/Abef12QC_o.png"></p> 
<p> </p> 
<h3>使用示例</h3> 
<p>无参数使用 netstat</p> 
<pre class="has"><code class="language-plain">[root@localhost ~]# netstat
Active Internet connections (w/o servers)
Proto Recv-Q Send-Q Local Address               Foreign Address             State      
tcp        0    268 192.168.120.204:ssh         10.2.0.68:62420             ESTABLISHED 
udp        0      0 192.168.120.204:4371        10.58.119.119:domain        ESTABLISHED 
Active UNIX domain sockets (w/o servers)
Proto RefCnt Flags       Type       State         I-Node Path
unix  2      [ ]         DGRAM                    1491   @/org/kernel/udev/udevd
unix  4      [ ]         DGRAM                    7337   /dev/log
unix  2      [ ]         DGRAM                    708823 
unix  2      [ ]         DGRAM                    7539   
unix  3      [ ]         STREAM     CONNECTED     7287   
unix  3      [ ]         STREAM     CONNECTED     7286   
[root@localhost ~]#</code></pre> 
<p><strong>netstat 的输出结果说明</strong></p> 
<p>从整体上看，netstat 的输出结果可以分为两个部分：</p> 
<ul><li>一个是 <strong>Active Internet connections</strong>，称为 <span style="color:#7c79e5;"><strong>有源TCP连接</strong></span>，其中 "<strong>Recv-Q</strong>" 和 "<strong>Send-Q</strong>" 指的是 <strong>接收队列</strong> 和 <strong>发送队列</strong>。这些数字一般都应该是0。如果不是则表示软件包正在队列中堆积。这种情况只能在非常少的情况见到。</li><li>另一个是 <strong>Active UNIX domain sockets</strong>，称为 <span style="color:#7c79e5;"><strong>有源Unix域套接口</strong></span> ( 和 <strong>网络套接字一样，但是只能用于本机通信，性能可以提高一倍</strong>)。        <br>         Proto 显示连接使用的协议，<br>         RefCnt 表示连接到本套接口上的进程号，<br>         Types 显示套接口的类型，<br>         State 显示套接口当前的状态，<br>         Path表示连接到套接口的其它进程使用的路径名。</li></ul> 
<p><strong>套接口类型：</strong></p> 
<pre class="has"><code class="language-plain">-t ：TCP
-u ：UDP
-raw ：RAW类型
--unix ：UNIX域类型
--ax25 ：AX25类型
--ipx ：ipx类型
--netrom ：netrom类型</code></pre> 
<p><strong>状态说明：</strong></p> 
<pre class="has"><code class="language-plain">LISTEN：      侦听来自远方的TCP端口的连接请求
SYN-SENT：    再发送连接请求后等待匹配的连接请求（如果有大量这样的状态包，检查是否中招了）
SYN-RECEIVED：再收到和发送一个连接请求后等待对方对连接请求的确认（如有大量此状态，估计被flood攻击了）
ESTABLISHED： 代表一个打开的连接
FIN-WAIT-1：  等待远程TCP连接中断请求，或先前的连接中断请求的确认
FIN-WAIT-2：  从远程TCP等待连接中断请求
CLOSE-WAIT：  等待从本地用户发来的连接中断请求
CLOSING：     等待远程TCP对连接中断的确认
LAST-ACK：    等待原来的发向远程TCP的连接中断请求的确认（不是什么好东西，此项出现，检查是否被攻击）
TIME-WAIT：   等待足够的时间以确保远程TCP接收到连接中断请求的确认
CLOSED：      没有任何连接状态</code></pre> 
<p> </p> 
<p><strong>列出所有端口。命令：<span style="color:#7c79e5;">netstat -a</span></strong></p> 
<pre class="has"><code class="language-plain">[root@localhost ~]# netstat -a
Active Internet connections (servers and established)
Proto Recv-Q Send-Q Local Address               Foreign Address             State      
tcp        0      0 localhost:smux              *:*                         LISTEN      
tcp        0      0 *:svn                       *:*                         LISTEN      
tcp        0      0 *:ssh                       *:*                         LISTEN      
tcp        0    284 192.168.120.204:ssh         10.2.0.68:62420             ESTABLISHED 
udp        0      0 localhost:syslog            *:*                                     
udp        0      0 *:snmp                      *:*                                     
Active UNIX domain sockets (servers and established)
Proto RefCnt Flags       Type       State         I-Node Path
unix  2      [ ACC ]     STREAM     LISTENING     708833 /tmp/ssh-yKnDB15725/agent.15725
unix  2      [ ACC ]     STREAM     LISTENING     7296   /var/run/audispd_events
unix  2      [ ]         DGRAM                    1491   @/org/kernel/udev/udevd
unix  4      [ ]         DGRAM                    7337   /dev/log
unix  2      [ ]         DGRAM                    708823 
unix  2      [ ]         DGRAM                    7539   
unix  3      [ ]         STREAM     CONNECTED     7287   
unix  3      [ ]         STREAM     CONNECTED     7286   
[root@localhost ~]# </code></pre> 
<p> </p> 
<p><strong>netstat 示例</strong></p> 
<pre class="has"><code class="language-plain">netstat -a     列出所有端口
netstat -n     显示所有已建立的有效连接 ( 用点分四段式的形式显示ip )。
netstat -at    列出 所有 TCP 端口
netstat -au    列出 所有 UDP 端口
netstat -nu    列出 所有 UDP 端口
netstat -apu   显示UDP端口号的使用情况。
netstat -ax    列出 所有 UNIX 端口
netstat -g     显示组播组的关系。

netstat -l    显示监听端口。即 显示监听的套接字。
netstat -lt   显示监听的 TCP 端口
netstat -lu   显示监听的 UDP 端口
netstat -lx   显示监听的 UNIX 端口

netstat -s    显示所有端口的协议统计信息
netstat -st   或者  -su    显示 TCP 或者 UDP 端口统计信息
netstat -p    -p 开关可以与其他开关一起使用，就可以添加 “PID/进程名称” 到netstat的输出中
netstat -pt   
netstat -an   以数字形式显示(不使用主机名)
netstat -a --numeric-ports
netstat -a --numeric-hosts
netstat -a --numeric-users

netstat -c     每隔一秒输出网络信息
netstat --verbose    显示系统不支持的地址族
netstat -r     显示核心路由信息
netstat -rn    显示数字格式，不查询主机名

netstat -ap | grep ssh    找出程序运行端口
netstat -an | grep ':80'    找出运行在指定端口的进程
netstat -i      显示网络接口列表。即 显示网卡列表。
netstat -ie     显示详细信息。跟 ifconfig 很像。

netstat -ntl    用来查看linux的端口使用情况
netstat -natp
netstat -ntlp
netstat -anp | grep 3306
netstat -an
netstat -ae |grep mysql

netstat -e     显示关于以太网的统计数据。  
netstat -i -e  显示主机上每个网络接口的配置和状态
netstat -lp    标识正在监听的网络服务
netstat -rn    检查路由表
 
Linux查看端口及服务 
　　# netstat -tulpn 
　　或者是
　　# netstat -npl


查看TIME_WAIT连接数
netstat -ae|grep "TIME_WAIT" |wc -l     
netstat -n | awk '/^tcp/ {++state[$NF]} END {for(key in state) print key,"\t",state[key]}' 

查找较多time_wait连接
netstat -n|grep TIME_WAIT|awk '{print $5}'|sort|uniq -c|sort -rn|head -n20
 
netstat + awk 查询连接数两种方法，意义相同
1：netstat -pnt | awk '/^tcp/{print $5}' | cut -d: -f 1 | sort -n |uniq -c
2：netstat -pnt | awk '/^tcp/{s=split($5,N,":");A[N[s-1]]++} END{ for (k in A) print k,A[k]}'</code></pre> 
<div> 
 <p> </p> 
 <p><strong>系统连接状态篇：</strong></p> 
 <pre class="has"><code class="language-plain">1.查看TCP连接状态
    netstat -tnl | grep 443    查看443端口是否被占用。
    netstat -pnl | grep 443    可显示出占用本机443端口的进程PID。
    
    netstat -nat |awk ‘{print $6}’|sort|uniq -c|sort -rn
    netstat -n | awk ‘/^tcp/ {++S[$NF]};END {for(a in S) print a, S[a]}’ 
    或
    netstat -n | awk ‘/^tcp/ {++state[$NF]}; END {for(key in state) print key,”\t”,state[key]}’
    netstat -n | awk ‘/^tcp/ {++arr[$NF]};END {for(k in arr) print k,”\t”,arr[k]}’
    netstat -n |awk ‘/^tcp/ {print $NF}’|sort|uniq -c|sort -rn
    netstat -ant | awk ‘{print $NF}’ | grep -v ‘[a-z]‘ | sort | uniq -c

2.查找请求数请20个IP（常用于查找攻来源）：
    netstat -anlp|grep 80|grep tcp|awk ‘{print $5}’|awk -F: ‘{print $1}’|sort|uniq -c|sort -nr|head -n20
    netstat -ant |awk ‘/:80/{split($5,ip,”:”);++A[ip[1]]}END{for(i in A) print A[i],i}’ |sort -rn|head -n20

3.用tcpdump嗅探80端口的访问看看谁最高
    tcpdump -i eth0 -tnn dst port 80 -c 1000 | awk -F”.” ‘{print $1″.”$2″.”$3″.”$4}’ | sort | uniq -c | sort -nr |head -20

4.查找较多time_wait连接
    netstat -n|grep TIME_WAIT|awk ‘{print $5}’|sort|uniq -c|sort -rn|head -n20

5.找查较多的SYN连接
    netstat -an | grep SYN | awk ‘{print $5}’ | awk -F: ‘{print $1}’ | sort | uniq -c | sort -nr | more

6.根据端口列进程
    netstat -ntlp | grep 80 | awk ‘{print $7}’ | cut -d/ -f1</code></pre> 
 <p> </p> 
 <p><strong>网站日志分析篇1（Apache）</strong></p> 
 <pre class="has"><code class="language-plain">1.获得访问前10位的ip地址
    cat access.log|awk ‘{print $1}’|sort|uniq -c|sort -nr|head -10
    cat access.log|awk ‘{counts[$(11)]+=1}; END {for(url in counts) print counts[url], url}’

2.访问次数最多的文件或页面,取前20
    cat access.log|awk ‘{print $11}’|sort|uniq -c|sort -nr|head -20

3.列出传输最大的几个exe文件（分析下载站的时候常用）
    cat access.log |awk ‘($7~/\.exe/){print $10 ” ” $1 ” ” $4 ” ” $7}’|sort -nr|head -20

4.列出输出大于200000byte(约200kb)的exe文件以及对应文件发生次数
    cat access.log |awk ‘($10 &gt; 200000 &amp;&amp; $7~/\.exe/){print $7}’|sort -n|uniq -c|sort -nr|head -100

5.如果日志最后一列记录的是页面文件传输时间，则有列出到客户端最耗时的页面
    cat access.log |awk ‘($7~/\.php/){print $NF ” ” $1 ” ” $4 ” ” $7}’|sort -nr|head -100

6.列出最最耗时的页面(超过60秒的)的以及对应页面发生次数
    cat access.log |awk ‘($NF &gt; 60 &amp;&amp; $7~/\.php/){print $7}’|sort -n|uniq -c|sort -nr|head -100

7.列出传输时间超过 30 秒的文件
    cat access.log |awk ‘($NF &gt; 30){print $7}’|sort -n|uniq -c|sort -nr|head -20

8.统计网站流量（G)
    cat access.log |awk ‘{sum+=$10} END {print sum/1024/1024/1024}’

9.统计404的连接
    awk ‘($9 ~/404/)’ access.log | awk ‘{print $9,$7}’ | sort

10. 统计http status.
    cat access.log |awk ‘{counts[$(9)]+=1}; END {for(code in counts) print code, counts[code]}'
    cat access.log |awk '{print $9}'|sort|uniq -c|sort -rn

10.蜘蛛分析
    查看是哪些蜘蛛在抓取内容。
    /usr/sbin/tcpdump -i eth0 -l -s 0 -w - dst port 80 | strings | grep -i user-agent | grep -i -E 'bot|crawler|slurp|spider'</code></pre> 
 <p> </p> 
 <p><strong>网站日分析2 (Squid篇 ）</strong></p> 
 <p>2.按域统计流量<br> zcat squid_access.log.tar.gz| awk '{print $10,$7}' |awk 'BEGIN{FS="[ /]"}{trfc[$4]+=$1}END{for(domain in trfc){printf "%s\t%d\n",domain,trfc[domain]}}'<br><br> 效率更高的perl版本请到此下载:http://docs.linuxtone.org/soft/tools/tr.pl<br><br> 数据库篇<br> 1.查看数据库执行的sql<br> /usr/sbin/tcpdump -i eth0 -s 0 -l -w - dst port 3306 | strings | egrep -i 'SELECT|UPDATE|DELETE|INSERT|SET|COMMIT|ROLLBACK|CREATE|DROP|ALTER|CALL'<br><br> 系统Debug分析篇<br><br> 1.调试命令<br> strace -p pid<br><br> 2.跟踪指定进程的PID<br> gdb -p pid<br><br> 详细访问linuxtone.org</p> 
 <p> </p> 
 <p> </p> 
 <p> </p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9ea79b751c261d7a8dce1207eeb0cda5/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">图片瀑布流</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/cfb021c1099314ec43df30a17265575a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">maven 生成webservice客户端代码</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>