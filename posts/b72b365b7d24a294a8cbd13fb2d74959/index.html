<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>完全解读Prometheus查询 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="完全解读Prometheus查询" />
<meta property="og:description" content="文章目录 01 引言02 概念2.1 表达式类型（Expression language data types）2.2 字面量（Literals）2.2.1 String 字面量（String literals）2.2.2 Float 字面量（Float literals） 2.3 时间序列选择器（Time series Selectors）2.3.1 瞬时向量选择器（Instant vector selectors）2.3.2 范量向量选择器（Range Vector Selectors）2.3.3 持续时间（Time Durations）2.3.4 Offset修饰符（Offset modifier）2.3.5 @ modifier 2.4 子查询（Subquery）2.5 操作符（Operators）2.5.1 二元作符（Binary operators）2.5.1.1 算术二元操作符（Arithmetic binary operators）2.5.1.2 三角二元操作符符（Trigonometric binary operators）2.5.1.3 比较二元操作符（Comparison binary operators）2.5.1.4 逻辑二元操作符（Logical/set binary operators） 2.5.2 向量匹配（Vector matching）2.5.2.1 一对一向量匹配（One-to-one vector matches）2.5.2.2 多对一和一对多向量匹配（Many-to-one and one-to-many vector matches） 2.5.3 聚合运算符（Aggregation operators）2.5.4 二元操作符优先级（Binary operator precedence） 2.6 函数（Functions）2.7 注释（Comments）2.8 陷阱（Gotchas）2.8.1 过时（Staleness）2." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/b72b365b7d24a294a8cbd13fb2d74959/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-04-29T10:02:38+08:00" />
<meta property="article:modified_time" content="2022-04-29T10:02:38+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">完全解读Prometheus查询</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-dracula">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#font_colorpurple01_font_2" rel="nofollow"><font color="purple">01 引言</font></a></li><li><a href="#font_colorpurple02_font_16" rel="nofollow"><font color="purple">02 概念</font></a></li><li><ul><li><a href="#font_colorpurple21_Expression_language_data_typesfont_18" rel="nofollow"><font color="purple">2.1 表达式类型（Expression language data types）</font></a></li><li><a href="#font_colorpurple22_Literalsfont_25" rel="nofollow"><font color="purple">2.2 字面量（Literals）</font></a></li><li><ul><li><a href="#font_colorpurple221_String_String_literalsfont_26" rel="nofollow"><font color="purple">2.2.1 String 字面量（String literals）</font></a></li><li><a href="#font_colorpurple222_Float_Float_literalsfont_41" rel="nofollow"><font color="purple">2.2.2 Float 字面量（Float literals）</font></a></li></ul> 
   </li><li><a href="#font_colorpurple23_Time_series_Selectorsfont_62" rel="nofollow"><font color="purple">2.3 时间序列选择器（Time series Selectors）</font></a></li><li><ul><li><a href="#font_colorpurple231_Instant_vector_selectorsfont_63" rel="nofollow"><font color="purple">2.3.1 瞬时向量选择器（Instant vector selectors）</font></a></li><li><a href="#font_colorpurple232_Range_Vector_Selectorsfont_121" rel="nofollow"><font color="purple">2.3.2 范量向量选择器（Range Vector Selectors）</font></a></li><li><a href="#font_colorpurple233_Time_Durationsfont_131" rel="nofollow"><font color="purple">2.3.3 持续时间（Time Durations）</font></a></li><li><a href="#font_colorpurple234_OffsetOffset_modifierfont_149" rel="nofollow"><font color="purple">2.3.4 Offset修饰符（Offset modifier）</font></a></li><li><a href="#font_colorpurple235__modifierfont_177" rel="nofollow"><font color="purple">2.3.5 @ modifier</font></a></li></ul> 
   </li><li><a href="#font_colorpurple24_Subqueryfont_218" rel="nofollow"><font color="purple">2.4 子查询（Subquery）</font></a></li><li><a href="#font_colorpurple25_Operatorsfont_228" rel="nofollow"><font color="purple">2.5 操作符（Operators）</font></a></li><li><ul><li><a href="#font_colorpurple251_Binary_operatorsfont_231" rel="nofollow"><font color="purple">2.5.1 二元作符（Binary operators）</font></a></li><li><ul><li><a href="#font_colorpurple2511_Arithmetic_binary_operatorsfont_233" rel="nofollow"><font color="purple">2.5.1.1 算术二元操作符（Arithmetic binary operators）</font></a></li><li><a href="#font_colorpurple2512_Trigonometric_binary_operatorsfont_247" rel="nofollow"><font color="purple">2.5.1.2 三角二元操作符符（Trigonometric binary operators）</font></a></li><li><a href="#font_colorpurple2513_Comparison_binary_operatorsfont_253" rel="nofollow"><font color="purple">2.5.1.3 比较二元操作符（Comparison binary operators）</font></a></li><li><a href="#font_colorpurple2514_Logicalset_binary_operatorsfont_262" rel="nofollow"><font color="purple">2.5.1.4 逻辑二元操作符（Logical/set binary operators）</font></a></li></ul> 
    </li><li><a href="#font_colorpurple252_Vector_matchingfont_269" rel="nofollow"><font color="purple">2.5.2 向量匹配（Vector matching）</font></a></li><li><ul><li><a href="#font_colorpurple2521_Onetoone_vector_matchesfont_272" rel="nofollow"><font color="purple">2.5.2.1 一对一向量匹配（One-to-one vector matches）</font></a></li><li><a href="#font_colorpurple2522_Manytoone_and_onetomany_vector_matchesfont_308" rel="nofollow"><font color="purple">2.5.2.2 多对一和一对多向量匹配（Many-to-one and one-to-many vector matches）</font></a></li></ul> 
    </li><li><a href="#font_colorpurple253_Aggregation_operatorsfont_336" rel="nofollow"><font color="purple">2.5.3 聚合运算符（Aggregation operators）</font></a></li><li><a href="#font_colorpurple254_Binary_operator_precedencefont_362" rel="nofollow"><font color="purple">2.5.4 二元操作符优先级（Binary operator precedence）</font></a></li></ul> 
   </li><li><a href="#font_colorpurple26_Functionsfont_373" rel="nofollow"><font color="purple">2.6 函数（Functions）</font></a></li><li><a href="#font_colorpurple27_Commentsfont_427" rel="nofollow"><font color="purple">2.7 注释（Comments）</font></a></li><li><a href="#font_colorpurple28_Gotchasfont_434" rel="nofollow"><font color="purple">2.8 陷阱（Gotchas）</font></a></li><li><ul><li><a href="#font_colorpurple281_Stalenessfont_435" rel="nofollow"><font color="purple">2.8.1 过时（Staleness）</font></a></li><li><a href="#font_colorpurple282_Avoiding_slow_queries_and_overloadsfont_438" rel="nofollow"><font color="purple">2.8.2 避免慢查询和重载（Avoiding slow queries and overloads）</font></a></li></ul> 
  </li></ul> 
  </li><li><a href="#font_colorpurple03_font_442" rel="nofollow"><font color="purple">03 举例</font></a></li><li><ul><li><a href="#font_colorpurple31_Simple_time_series_selectionfont_443" rel="nofollow"><font color="purple">3.1 简单的时间序列选择（Simple time series selection）</font></a></li><li><a href="#font_colorpurple32_Subqueryfont_471" rel="nofollow"><font color="purple">3.2 子查询（Subquery）</font></a></li><li><a href="#font_colorpurple34_Using_functions_operators_etcfont_482" rel="nofollow"><font color="purple">3.4 方法、操作符（Using functions, operators, etc.）</font></a></li></ul> 
  </li><li><a href="#font_colorpurple04_HTTPfont_528" rel="nofollow"><font color="purple">04 HTTP接口获取</font></a></li><li><a href="#font_colorpurple05_font_532" rel="nofollow"><font color="purple">05 小结</font></a></li></ul> 
</div> 
<p></p> 
<h2><a id="font_colorpurple01_font_2"></a><font color="purple">01 引言</font></h2> 
<blockquote> 
 <p>Prometheus查询语法官方文档地址：<a href="https://prometheus.io/docs/prometheus/latest/querying/basics/" rel="nofollow">https://prometheus.io/docs/prometheus/latest/querying/basics/</a></p> 
</blockquote> 
<p><strong>Prometheus</strong>提供了一种名为<code>PromQL (Prometheus query language)</code>的函数式查询语言，允许用户实时选择和聚合时间序列数据，表达式的结果可以以图形的形式显示，通过<a href="https://prometheus.io/docs/prometheus/latest/querying/api/" rel="nofollow">HTTP API</a>由外部系统使用。</p> 
<p>在Prometheus页面，输入查询语句，可以看到类似于如下接界面：</p> 
<table><thead><tr><th>Table</th><th>Graph</th></tr></thead><tbody><tr><td><img src="https://images2.imgbox.com/4f/72/sI7hbyfA_o.png" alt="在这里插入图片描述"></td><td><img src="https://images2.imgbox.com/a2/38/6ca6auLR_o.png" alt="在这里插入图片描述"></td></tr></tbody></table> 
<p>接下来，详细讲解下<code>Prometheus</code>的查询语法。</p> 
<h2><a id="font_colorpurple02_font_16"></a><font color="purple">02 概念</font></h2> 
<h3><a id="font_colorpurple21_Expression_language_data_typesfont_18"></a><font color="purple">2.1 表达式类型（Expression language data types）</font></h3> 
<p>在<code>Prometheus</code>的表达语言中，一个表达式或子表达式可以总结为以下四种类型:</p> 
<ul><li><strong>瞬时向量（<code>Instant vector </code>）</strong>：一组时间序列，包含每个时间序列的单一样本，所有共享相同的时间戳；</li><li><strong>范围向量（<code>Range vector</code>）</strong>：一组时间序列，包含每个时间序列在一段时间内的数据点范围；</li><li><strong>标量（<code>Scalar</code>）</strong>：一个简单的数字浮点值；</li><li><strong>字符串（<code>String</code>）</strong>：一个简单的字符串值（目前未使用）；</li></ul> 
<h3><a id="font_colorpurple22_Literalsfont_25"></a><font color="purple">2.2 字面量（Literals）</font></h3> 
<h4><a id="font_colorpurple221_String_String_literalsfont_26"></a><font color="purple">2.2.1 String 字面量（String literals）</font></h4> 
<p>字符串可以指定为单引号、双引号或反引号中的文字。</p> 
<p><code>PromQL</code>遵循与<a href="https://golang.org/ref/spec#String_literals" rel="nofollow">Go相同的转义规则</a>。在单引号或双引号中，反斜杠开始转义序列，转义序列后面可以是<code>a、b、f、n、r、t、v</code>或<code>\</code>。可以使用八进制(<code>\nnn</code>)或十六进制(<code>\xnn， \unnnn和\ unnnnnn</code>)提供特定字符。</p> 
<p>反引号内不处理转义，与<code>Go</code>不同，<code>Prometheus</code>不会在反引号内丢弃换行符。</p> 
<p>例子:</p> 
<pre><code class="prism language-java"><span class="token string">"this is a string"</span>
'these are unescaped<span class="token operator">:</span> \n \\ \t'
`these are not unescaped<span class="token operator">:</span> \n ' " \t`
</code></pre> 
<h4><a id="font_colorpurple222_Float_Float_literalsfont_41"></a><font color="purple">2.2.2 Float 字面量（Float literals）</font></h4> 
<p>标量浮点值可以写成文字整型数或浮点数格式（仅包含空格以提高可读性）:</p> 
<pre><code class="prism language-bash"><span class="token punctuation">[</span>-+<span class="token punctuation">]</span>?<span class="token punctuation">(</span>
      <span class="token punctuation">[</span><span class="token number">0</span>-9<span class="token punctuation">]</span>*<span class="token punctuation">\</span>.?<span class="token punctuation">[</span><span class="token number">0</span>-9<span class="token punctuation">]</span>+<span class="token punctuation">(</span><span class="token punctuation">[</span>eE<span class="token punctuation">]</span><span class="token punctuation">[</span>-+<span class="token punctuation">]</span>?<span class="token punctuation">[</span><span class="token number">0</span>-9<span class="token punctuation">]</span>+<span class="token punctuation">)</span>?
    <span class="token operator">|</span> <span class="token number">0</span><span class="token punctuation">[</span>xX<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span>-9a-fA-F<span class="token punctuation">]</span>+
    <span class="token operator">|</span> <span class="token punctuation">[</span>nN<span class="token punctuation">]</span><span class="token punctuation">[</span>aA<span class="token punctuation">]</span><span class="token punctuation">[</span>nN<span class="token punctuation">]</span>
    <span class="token operator">|</span> <span class="token punctuation">[</span>iI<span class="token punctuation">]</span><span class="token punctuation">[</span>nN<span class="token punctuation">]</span><span class="token punctuation">[</span>fF<span class="token punctuation">]</span>
<span class="token punctuation">)</span>
</code></pre> 
<p>举例：</p> 
<pre><code class="prism language-bash"><span class="token number">23</span>
-2.43
<span class="token number">3</span>.4e-9
0x8f
-Inf
NaN
</code></pre> 
<h3><a id="font_colorpurple23_Time_series_Selectorsfont_62"></a><font color="purple">2.3 时间序列选择器（Time series Selectors）</font></h3> 
<h4><a id="font_colorpurple231_Instant_vector_selectorsfont_63"></a><font color="purple">2.3.1 瞬时向量选择器（Instant vector selectors）</font></h4> 
<p><strong>瞬时向量选择器</strong>：允许在给定的时间戳(即时)上选择一组时间序列和每个序列的单个样本值，在最简单的形式中，只指定一个度量名称。这将产生一个包含所有具有此度量名称的时间序列元素的即时向量。</p> 
<p>这个例子选择了所有带有<code>http_requests_total</code>度量名称的时间序列:</p> 
<pre><code class="prism language-bash">http_requests_total
</code></pre> 
<p><font color="red">通过在花括号(<code>{}</code>)中添加逗号分隔的标签匹配器列表，可以进一步过滤这些时间序列</font>。</p> 
<p>举例：只选择那些带有<code>http_requests_total</code>度量名称的时间序列，并且作业标签设置为<code>prometheus</code>，它们的组标签设置为<code>canary</code>：</p> 
<pre><code class="prism language-bash">http_requests_total<span class="token punctuation">{<!-- --></span>job<span class="token operator">=</span><span class="token string">"prometheus"</span>,group<span class="token operator">=</span><span class="token string">"canary"</span><span class="token punctuation">}</span>
</code></pre> 
<p>也可以对标签值进行负匹配，或者将标签值与正则表达式进行匹配，存在以下标签匹配操作符:</p> 
<ul><li><strong><code>=</code></strong>: 选择与提供的字符串完全相等的标签；</li><li><strong><code>!=</code></strong>: 选择与提供的字符串不相等的标签；</li><li><strong><code>=~</code></strong>: 选择正则表达式与提供的字符串匹配的标签；</li><li><strong><code>!~</code></strong>: 选择与提供的字符串不匹配的标签；</li></ul> 
<p>正则表达式匹配是完全对应的，匹配<code>env=~"foo"</code>被视为<code>env=~"^foo$"</code>。</p> 
<p>举例：这将为<code>staging、testing和development</code>环境以及除<code>GET</code>之外的<code>HTTP</code>方法选择所有<code>http_requests_total</code>时间序列：</p> 
<pre><code class="prism language-bash">http_requests_total<span class="token punctuation">{<!-- --></span>environment<span class="token operator">=~</span><span class="token string">"staging|testing|development"</span>,method<span class="token operator">!=</span><span class="token string">"GET"</span><span class="token punctuation">}</span>
</code></pre> 
<p>注意：<font color="blue">向量选择器必须指定一个名称或至少一个与空字符串不匹配的标签匹配器</font>，下面的表达式是非法的:</p> 
<pre><code class="prism language-bash"><span class="token punctuation">{<!-- --></span>job<span class="token operator">=~</span><span class="token string">".*"</span><span class="token punctuation">}</span> <span class="token comment"># Bad!</span>
</code></pre> 
<p>相反，这些表达式是有效的，因为它们都有一个不匹配空标签值的选择器：</p> 
<pre><code class="prism language-bash"><span class="token punctuation">{<!-- --></span>job<span class="token operator">=~</span><span class="token string">".+"</span><span class="token punctuation">}</span>              <span class="token comment"># Good!</span>
<span class="token punctuation">{<!-- --></span>job<span class="token operator">=~</span><span class="token string">".*"</span>,method<span class="token operator">=</span><span class="token string">"get"</span><span class="token punctuation">}</span> <span class="token comment"># Good!</span>
</code></pre> 
<p>通过与内部的<code>__name__</code>标签进行匹配，标签匹配器也可以应用于度量名称。例如，表达式<code>http_requests_total</code>等价于<code>{__name__="http_requests_total"}</code>，除<code>= (!=， =~， !~)</code>也可以使用，以下表达式选择名称以<code>job</code>开头的所有指标:</p> 
<pre><code class="prism language-bash"><span class="token punctuation">{<!-- --></span>__name__<span class="token operator">=~</span><span class="token string">"job:.*"</span><span class="token punctuation">}</span>
</code></pre> 
<p>指标名不能是关键字<code>bool, on, ignoring, group_left</code>和<code>group_right</code>中的一个。下面的表达式是非法的:</p> 
<pre><code class="prism language-bash">on<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span> <span class="token comment"># Bad!</span>
</code></pre> 
<p>解决这个限制的方法是使用<code>__name__</code>标签:</p> 
<pre><code class="prism language-bash"><span class="token punctuation">{<!-- --></span>__name__<span class="token operator">=</span><span class="token string">"on"</span><span class="token punctuation">}</span> <span class="token comment"># Good!</span>
</code></pre> 
<p><font color="red">Prometheus中的所有正则表达式都使用 <a href="https://github.com/google/re2/wiki/Syntax">RE2语法</a></font>。</p> 
<h4><a id="font_colorpurple232_Range_Vector_Selectorsfont_121"></a><font color="purple">2.3.2 范量向量选择器（Range Vector Selectors）</font></h4> 
<p>范量标量：工作方式类似于瞬时向量，只是它们选择了从当前瞬间返回的一个样本范围。</p> 
<p>从语法上讲，时间持续时间被附加在向量选择器末尾的方括号(<code>[]</code>)中，以指定应该为<font color="blue"><u>每个结果范围向量元素提取到多远的时间值</u></font>。</p> 
<p>举例：选择在过去5分钟内记录的所有时间序列的值，这些时间序列的度量名称为<code>http_requests_total</code>，作业标签设置为<code>prometheus</code>:</p> 
<pre><code class="prism language-bash">http_requests_total<span class="token punctuation">{<!-- --></span>job<span class="token operator">=</span><span class="token string">"prometheus"</span><span class="token punctuation">}</span><span class="token punctuation">[</span>5m<span class="token punctuation">]</span>
</code></pre> 
<h4><a id="font_colorpurple233_Time_Durationsfont_131"></a><font color="purple">2.3.3 持续时间（Time Durations）</font></h4> 
<p>时间持续时间指定为一个数字，后面紧跟着下列的其中一个单位：</p> 
<ul><li><code>ms</code> ：毫秒</li><li><code>s</code> ：秒</li><li><code>m</code> ： 分钟</li><li><code>h</code> ： 小时</li><li><code>d</code> ： 天（一天24小时）</li><li><code>w</code> ： 周（一周7天）<br> -<code>y</code>：年（一年365天）</li></ul> 
<p>时间持续时间可以进行串联组合（注意：<em><strong>单位必须从最长到最短订购，一个给定的单位在一段时间内只能出现一次</strong></em>），举例：</p> 
<pre><code class="prism language-bash">5h
1h30m
5m
10s
</code></pre> 
<h4><a id="font_colorpurple234_OffsetOffset_modifierfont_149"></a><font color="purple">2.3.4 Offset修饰符（Offset modifier）</font></h4> 
<p><strong><code>offset</code>修饰符</strong>：允许在查询中更改单个瞬间和范围向量的时间偏移量。</p> 
<p>举例：以下表达式返回相对于当前查询评估时间过去5分钟的<code>http_requests_total</code>的值:</p> 
<pre><code class="prism language-bash">http_requests_total offset 5m
</code></pre> 
<p>注意：<code>offset修饰符</code>必须跟在选择器后面，即:</p> 
<pre><code class="prism language-bash">sum<span class="token punctuation">(</span>http_requests_total<span class="token punctuation">{<!-- --></span>method<span class="token operator">=</span><span class="token string">"GET"</span><span class="token punctuation">}</span> offset 5m<span class="token punctuation">)</span> // GOOD.
</code></pre> 
<p>如果这样是错误的：</p> 
<pre><code class="prism language-bash">sum<span class="token punctuation">(</span>http_requests_total<span class="token punctuation">{<!-- --></span>method<span class="token operator">=</span><span class="token string">"GET"</span><span class="token punctuation">}</span><span class="token punctuation">)</span> offset 5m // INVALID.
</code></pre> 
<p>对于范围向量也是一样的，下面例子将返回<code>http_requests_total</code>一周前的5分钟速率:</p> 
<pre><code class="prism language-bash">rate<span class="token punctuation">(</span>http_requests_total<span class="token punctuation">[</span>5m<span class="token punctuation">]</span> offset 1w<span class="token punctuation">)</span>
</code></pre> 
<p>对于时间上向前移动的比较，可以指定负偏移量:</p> 
<pre><code class="prism language-bash">rate<span class="token punctuation">(</span>http_requests_total<span class="token punctuation">[</span>5m<span class="token punctuation">]</span> offset -1w<span class="token punctuation">)</span>
</code></pre> 
<h4><a id="font_colorpurple235__modifierfont_177"></a><font color="purple">2.3.5 @ modifier</font></h4> 
<p><strong>@修饰符</strong>：允许在查询中改变单个瞬间向量和范围向量的计算时间，提供给@修饰符的时间是一个<code>unix</code>时间戳，用浮点文字描述。</p> 
<p>例如，以下表达式返回<code>http_requests_total</code>在<code>2021-01-04T07:40:00+00:00</code>的值:</p> 
<pre><code class="prism language-bash">http_requests_total @ <span class="token number">1609746000</span>
</code></pre> 
<p>注意，<strong>@修饰符</strong>必须跟在选择器后面，举例:</p> 
<pre><code class="prism language-bash">sum<span class="token punctuation">(</span>http_requests_total<span class="token punctuation">{<!-- --></span>method<span class="token operator">=</span><span class="token string">"GET"</span><span class="token punctuation">}</span> @ <span class="token number">1609746000</span><span class="token punctuation">)</span> // GOOD.
</code></pre> 
<p>以下是错误写法：</p> 
<pre><code class="prism language-bash">sum<span class="token punctuation">(</span>http_requests_total<span class="token punctuation">{<!-- --></span>method<span class="token operator">=</span><span class="token string">"GET"</span><span class="token punctuation">}</span><span class="token punctuation">)</span> @ <span class="token number">1609746000</span> // INVALID.
</code></pre> 
<p>对于范围向量也是一样的，下面表达式将返回<code>http_requests_total</code>在<code>2021-01-04T07:40:00+00:00</code>处的5分钟速率:</p> 
<pre><code class="prism language-bash">rate<span class="token punctuation">(</span>http_requests_total<span class="token punctuation">[</span>5m<span class="token punctuation">]</span> @ <span class="token number">1609746000</span><span class="token punctuation">)</span>
</code></pre> 
<p><strong>@修饰符</strong>在<code>int64</code>范围内支持上述浮点数字面量的所有表示。它还可以与<strong>offset修饰符</strong>一起使用，<code>offset</code>是相对于**@修饰符**时间应用的，而不管哪个修饰符先写，这两个查询将产生相同的结果。</p> 
<pre><code class="prism language-bash"><span class="token comment"># offset after @</span>
http_requests_total @ <span class="token number">1609746000</span> offset 5m
<span class="token comment"># offset before @</span>
http_requests_total offset 5m @ <span class="token number">1609746000</span>
</code></pre> 
<p>另外，<code>start()</code>和<code>end()</code>也可以作为**@修饰符**的特殊值使用，对于范围查询，它们分别解析到范围查询的开始和结束，并对所有步骤保持相同，对于即时查询，start()和end()都解析为计算时间。</p> 
<pre><code class="prism language-bash">http_requests_total @ start<span class="token punctuation">(</span><span class="token punctuation">)</span>
rate<span class="token punctuation">(</span>http_requests_total<span class="token punctuation">[</span>5m<span class="token punctuation">]</span> @ end<span class="token punctuation">(</span><span class="token punctuation">))</span>
</code></pre> 
<p>注意，<strong>@修饰符</strong>允许查询提前查看其计算时间。</p> 
<h3><a id="font_colorpurple24_Subqueryfont_218"></a><font color="purple">2.4 子查询（Subquery）</font></h3> 
<p>子查询允许您对给定的范围即时查询，子查询的结果是一个范围向量。</p> 
<p>语法：</p> 
<pre><code class="prism language-bash"><span class="token operator">&lt;</span>instant_query<span class="token operator">&gt;</span> <span class="token string">'['</span> <span class="token operator">&lt;</span>range<span class="token operator">&gt;</span> <span class="token string">':'</span> <span class="token punctuation">[</span><span class="token operator">&lt;</span>resolution<span class="token operator">&gt;</span><span class="token punctuation">]</span> <span class="token string">']'</span> <span class="token punctuation">[</span> @ <span class="token operator">&lt;</span>float_literal<span class="token operator">&gt;</span> <span class="token punctuation">]</span> <span class="token punctuation">[</span> offset <span class="token operator">&lt;</span>duration<span class="token operator">&gt;</span> <span class="token punctuation">]</span>
</code></pre> 
<p><code>&lt;resolution&gt;</code>：是可选的，默认是全局计算间隔。</p> 
<h3><a id="font_colorpurple25_Operatorsfont_228"></a><font color="purple">2.5 操作符（Operators）</font></h3> 
<p><code>Prometheus</code>支持许多二进制和聚合操作符，详情参考：<a href="https://prometheus.io/docs/prometheus/latest/querying/operators/" rel="nofollow">https://prometheus.io/docs/prometheus/latest/querying/operators/</a></p> 
<h4><a id="font_colorpurple251_Binary_operatorsfont_231"></a><font color="purple">2.5.1 二元作符（Binary operators）</font></h4> 
<p><code>Prometheus</code>的查询语言支持基本的逻辑和算术运算符。对于两个瞬时向量之间的运算，可以修改<a href="https://prometheus.io/docs/prometheus/latest/querying/operators/#vector-matching" rel="nofollow">匹配行为</a>。</p> 
<h5><a id="font_colorpurple2511_Arithmetic_binary_operatorsfont_233"></a><font color="purple">2.5.1.1 算术二元操作符（Arithmetic binary operators）</font></h5> 
<p>在<code>Prometheus</code>中存在以下二进制算术运算符:</p> 
<ul><li><code>+</code> ：(加)</li><li><code>-</code> ：(减)</li><li><code>*</code> ：(乘)<br> -<code> /</code> ：(除)</li><li><code>%</code> ：(取余)</li><li><code>^ </code>：(求幂)</li></ul> 
<p>二进制算术运算符定义在标量/标量、向量/标量和向量/向量值对之间：</p> 
<ul><li><strong>两个标量之间的行为很明显</strong>:它们计算另一个标量，这个标量是应用于两个标量操作数的运算符的结果。</li><li><strong>在瞬时向量和标量之间</strong>，将运算符应用于向量中每个数据样本的值。例如，如果一个时间序列瞬间向量乘以2，结果是另一个向量，其中原始向量的每个样本值乘以2，指标名称被删除。</li><li><strong>在两个瞬时向量之间</strong>：对左边向量中的每一个元素以及右边向量中与其匹配的元素应用一个二元算术运算符。结果被传播到结果向量，分组标签成为输出标签集。指标名称被删除。右边向量中找不到匹配项的项不属于结果的一部分。</li></ul> 
<h5><a id="font_colorpurple2512_Trigonometric_binary_operatorsfont_247"></a><font color="purple">2.5.1.2 三角二元操作符符（Trigonometric binary operators）</font></h5> 
<p>以下是在弧度上工作的三角二元运算符，在普罗米修斯中存在:</p> 
<ul><li>atan2(基于<a href="https://pkg.go.dev/math#Atan2" rel="nofollow">https://pkg.go.dev/math#Atan2</a>)</li></ul> 
<p>三角运算符允许使用向量匹配对两个向量执行三角函数，这在普通函数中是不可用的。它们的作用与算术运算符相同。</p> 
<h5><a id="font_colorpurple2513_Comparison_binary_operatorsfont_253"></a><font color="purple">2.5.1.3 比较二元操作符（Comparison binary operators）</font></h5> 
<p>比较二元操作符有如下：</p> 
<ul><li>== (等于)</li><li>!= (不等于)</li><li> 
  <blockquote> 
   <p>(大于)</p> 
  </blockquote> </li><li>&lt; (小于)</li><li> 
  <blockquote> 
   <p>= (大于等于)</p> 
  </blockquote> </li><li>&lt;= (小于等于)</li></ul> 
<h5><a id="font_colorpurple2514_Logicalset_binary_operatorsfont_262"></a><font color="purple">2.5.1.4 逻辑二元操作符（Logical/set binary operators）</font></h5> 
<p>逻辑二元操作符如下：</p> 
<ul><li><strong>and</strong>： (intersection)</li><li><strong>or</strong>： (union)</li><li><strong>unless</strong>：(complement)</li></ul> 
<h4><a id="font_colorpurple252_Vector_matchingfont_269"></a><font color="purple">2.5.2 向量匹配（Vector matching）</font></h4> 
<p>向量之间的运算试图为左边的每一个元素在右边的向量中找到一个匹配的元素。匹配行为有两种基本类型:一对一和多对一/一对多。</p> 
<h5><a id="font_colorpurple2521_Onetoone_vector_matchesfont_272"></a><font color="purple">2.5.2.1 一对一向量匹配（One-to-one vector matches）</font></h5> 
<p>一对一从操作的每一边找到一个唯一的条目对。在默认情况下，这是一个遵循<code>vector1 &lt;操作符&gt; vector2</code>格式的操作。</p> 
<p>如果两个条目具有完全相同的标签集和相应的值，则它们是匹配的。<code>ignore</code>关键字允许在匹配时忽略某些标签，而<code>on</code>关键字允许将考虑的标签集缩减为所提供的列表:</p> 
<pre><code class="prism language-bash"><span class="token operator">&lt;</span>vector expr<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>bin-op<span class="token operator">&gt;</span> ignoring<span class="token punctuation">(</span><span class="token operator">&lt;</span>label list<span class="token operator">&gt;</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span>vector expr<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>vector expr<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>bin-op<span class="token operator">&gt;</span> on<span class="token punctuation">(</span><span class="token operator">&lt;</span>label list<span class="token operator">&gt;</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span>vector expr<span class="token operator">&gt;</span>
</code></pre> 
<p><strong>input举例：</strong></p> 
<pre><code class="prism language-bash">method_code:http_errors:rate5m<span class="token punctuation">{<!-- --></span>method<span class="token operator">=</span><span class="token string">"get"</span>, <span class="token assign-left variable">code</span><span class="token operator">=</span><span class="token string">"500"</span><span class="token punctuation">}</span>  <span class="token number">24</span>
method_code:http_errors:rate5m<span class="token punctuation">{<!-- --></span>method<span class="token operator">=</span><span class="token string">"get"</span>, <span class="token assign-left variable">code</span><span class="token operator">=</span><span class="token string">"404"</span><span class="token punctuation">}</span>  <span class="token number">30</span>
method_code:http_errors:rate5m<span class="token punctuation">{<!-- --></span>method<span class="token operator">=</span><span class="token string">"put"</span>, <span class="token assign-left variable">code</span><span class="token operator">=</span><span class="token string">"501"</span><span class="token punctuation">}</span>  <span class="token number">3</span>
method_code:http_errors:rate5m<span class="token punctuation">{<!-- --></span>method<span class="token operator">=</span><span class="token string">"post"</span>, <span class="token assign-left variable">code</span><span class="token operator">=</span><span class="token string">"500"</span><span class="token punctuation">}</span> <span class="token number">6</span>
method_code:http_errors:rate5m<span class="token punctuation">{<!-- --></span>method<span class="token operator">=</span><span class="token string">"post"</span>, <span class="token assign-left variable">code</span><span class="token operator">=</span><span class="token string">"404"</span><span class="token punctuation">}</span> <span class="token number">21</span>

method:http_requests:rate5m<span class="token punctuation">{<!-- --></span>method<span class="token operator">=</span><span class="token string">"get"</span><span class="token punctuation">}</span>  <span class="token number">600</span>
method:http_requests:rate5m<span class="token punctuation">{<!-- --></span>method<span class="token operator">=</span><span class="token string">"del"</span><span class="token punctuation">}</span>  <span class="token number">34</span>
method:http_requests:rate5m<span class="token punctuation">{<!-- --></span>method<span class="token operator">=</span><span class="token string">"post"</span><span class="token punctuation">}</span> <span class="token number">120</span>
</code></pre> 
<p><strong>query举例：</strong></p> 
<pre><code class="prism language-bash">method_code:http_errors:rate5m<span class="token punctuation">{<!-- --></span>code<span class="token operator">=</span><span class="token string">"500"</span><span class="token punctuation">}</span> / ignoring<span class="token punctuation">(</span>code<span class="token punctuation">)</span> method:http_requests:rate5m
</code></pre> 
<p>举例：下面将返回一个结果向量，其中包含每个方法在过去5分钟内的状态码为500的HTTP请求的比例。如果不忽略(代码)，就不会有匹配，因为度量标准不共享相同的标签集。带有put和del方法的条目没有匹配，不会在结果中显示:</p> 
<pre><code class="prism language-bash"><span class="token punctuation">{<!-- --></span>method<span class="token operator">=</span><span class="token string">"get"</span><span class="token punctuation">}</span>  <span class="token number">0.04</span>            //  <span class="token number">24</span> / <span class="token number">600</span>
<span class="token punctuation">{<!-- --></span>method<span class="token operator">=</span><span class="token string">"post"</span><span class="token punctuation">}</span> <span class="token number">0.05</span>            //   <span class="token number">6</span> / <span class="token number">120</span>
</code></pre> 
<h5><a id="font_colorpurple2522_Manytoone_and_onetomany_vector_matchesfont_308"></a><font color="purple">2.5.2.2 多对一和一对多向量匹配（Many-to-one and one-to-many vector matches）</font></h5> 
<p>多对一和一对多匹配指的是“一”面上的每个向量元素都可以与“多”面上的多个元素匹配。这必须使用group_left或group_right修饰符显式地请求，其中left/right决定哪个向量具有更高的基数。</p> 
<pre><code class="prism language-bash"><span class="token operator">&lt;</span>vector expr<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>bin-op<span class="token operator">&gt;</span> ignoring<span class="token punctuation">(</span><span class="token operator">&lt;</span>label list<span class="token operator">&gt;</span><span class="token punctuation">)</span> group_left<span class="token punctuation">(</span><span class="token operator">&lt;</span>label list<span class="token operator">&gt;</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span>vector expr<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>vector expr<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>bin-op<span class="token operator">&gt;</span> ignoring<span class="token punctuation">(</span><span class="token operator">&lt;</span>label list<span class="token operator">&gt;</span><span class="token punctuation">)</span> group_right<span class="token punctuation">(</span><span class="token operator">&lt;</span>label list<span class="token operator">&gt;</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span>vector expr<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>vector expr<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>bin-op<span class="token operator">&gt;</span> on<span class="token punctuation">(</span><span class="token operator">&lt;</span>label list<span class="token operator">&gt;</span><span class="token punctuation">)</span> group_left<span class="token punctuation">(</span><span class="token operator">&lt;</span>label list<span class="token operator">&gt;</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span>vector expr<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>vector expr<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>bin-op<span class="token operator">&gt;</span> on<span class="token punctuation">(</span><span class="token operator">&lt;</span>label list<span class="token operator">&gt;</span><span class="token punctuation">)</span> group_right<span class="token punctuation">(</span><span class="token operator">&lt;</span>label list<span class="token operator">&gt;</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span>vector expr<span class="token operator">&gt;</span>
</code></pre> 
<p>与组修饰符一起提供的标签列表包含了要包含在结果度量中的来自“一侧”的附加标签。在一个标签上只能出现在一个列表中。结果向量的每个时间序列必须是唯一可识别的。</p> 
<p>分组修饰符只能用于比较和算术。操作as和，除非和或默认匹配右向量中的所有可能条目。</p> 
<p>示例查询:</p> 
<pre><code class="prism language-bash">method_code:http_errors:rate5m / ignoring<span class="token punctuation">(</span>code<span class="token punctuation">)</span> group_left method:http_requests:rate5m
</code></pre> 
<p>在这种情况下，左向量每个方法标签值包含多个条目。因此，我们使用group_left来表示这一点。右边的元素现在与左边的多个具有相同方法标签的元素相匹配:</p> 
<pre><code class="prism language-bash"><span class="token punctuation">{<!-- --></span>method<span class="token operator">=</span><span class="token string">"get"</span>, <span class="token assign-left variable">code</span><span class="token operator">=</span><span class="token string">"500"</span><span class="token punctuation">}</span>  <span class="token number">0.04</span>            //  <span class="token number">24</span> / <span class="token number">600</span>
<span class="token punctuation">{<!-- --></span>method<span class="token operator">=</span><span class="token string">"get"</span>, <span class="token assign-left variable">code</span><span class="token operator">=</span><span class="token string">"404"</span><span class="token punctuation">}</span>  <span class="token number">0.05</span>            //  <span class="token number">30</span> / <span class="token number">600</span>
<span class="token punctuation">{<!-- --></span>method<span class="token operator">=</span><span class="token string">"post"</span>, <span class="token assign-left variable">code</span><span class="token operator">=</span><span class="token string">"500"</span><span class="token punctuation">}</span> <span class="token number">0.05</span>            //   <span class="token number">6</span> / <span class="token number">120</span>
<span class="token punctuation">{<!-- --></span>method<span class="token operator">=</span><span class="token string">"post"</span>, <span class="token assign-left variable">code</span><span class="token operator">=</span><span class="token string">"404"</span><span class="token punctuation">}</span> <span class="token number">0.175</span>           //  <span class="token number">21</span> / <span class="token number">120</span>
</code></pre> 
<p>多对一和一对多匹配是应该仔细考虑的高级用例。通常，正确使用<code>ignoring(&lt;labels&gt;)</code>会提供所需的结果。</p> 
<h4><a id="font_colorpurple253_Aggregation_operatorsfont_336"></a><font color="purple">2.5.3 聚合运算符（Aggregation operators）</font></h4> 
<p><code>Prometheus</code>支持以下内置的聚合操作符，可用于聚合单个瞬时向量的元素，从而生成一个具有聚合值的元素更少的新向量:</p> 
<ul><li><strong>sum</strong> (calculate sum over dimensions)</li><li><strong>min</strong> (select minimum over dimensions)</li><li><strong>max</strong> (select maximum over dimensions)</li><li><strong>avg</strong> (calculate the average over dimensions)</li><li><strong>group</strong> (all values in the resulting vector are 1)</li><li><strong>stddev</strong> (calculate population standard deviation over dimensions)</li><li><strong>stdvar</strong> (calculate population standard variance over dimensions)</li><li><strong>count</strong> (count number of elements in the vector)</li><li><strong>count_values</strong> (count number of elements with the same value)</li><li><strong>bottomk</strong> (smallest k elements by sample value)</li><li><strong>topk</strong> (largest k elements by sample value)</li><li><strong>quantile</strong> (calculate φ-quantile (0 ≤ φ ≤ 1) over dimensions)</li></ul> 
<p>这些操作符既可以用于对所有标签维度进行聚合，也可以通过包含<code>without</code>或<code>by</code>子句来保留不同的维度。这些子句可以在表达式之前或之后使用。</p> 
<pre><code class="prism language-bash"><span class="token operator">&lt;</span>aggr-op<span class="token operator">&gt;</span> <span class="token punctuation">[</span>without<span class="token operator">|</span>by <span class="token punctuation">(</span><span class="token operator">&lt;</span>label list<span class="token operator">&gt;</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token punctuation">[</span>parameter,<span class="token punctuation">]</span> <span class="token operator">&lt;</span>vector expression<span class="token operator">&gt;</span><span class="token punctuation">)</span>
</code></pre> 
<p>或者</p> 
<pre><code class="prism language-bash"><span class="token operator">&lt;</span>aggr-op<span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">[</span>parameter,<span class="token punctuation">]</span> <span class="token operator">&lt;</span>vector expression<span class="token operator">&gt;</span><span class="token punctuation">)</span> <span class="token punctuation">[</span>without<span class="token operator">|</span>by <span class="token punctuation">(</span><span class="token operator">&lt;</span>label list<span class="token operator">&gt;</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
</code></pre> 
<h4><a id="font_colorpurple254_Binary_operator_precedencefont_362"></a><font color="purple">2.5.4 二元操作符优先级（Binary operator precedence）</font></h4> 
<p>下面的列表显示了二元制操作符在普罗米修斯中从高到低的优先级：</p> 
<ol><li><code>^</code></li><li><code> *, /, %, atan2</code></li><li><code>+, -</code></li><li><code>==, !=, &lt;=, &lt;, &gt;=, &gt;</code></li><li><code>and, unless</code></li><li><code>or</code></li></ol> 
<p>具有相同优先级的操作符是左结合的。例如，<code>2 * 3% % 2</code>等于<code>(2 * 3)% 2</code>。然而<code>^</code>是右结合律，所以<code>2 ^ 3 ^ 2</code>等于<code>2 ^ (3 ^ 2)</code></p> 
<h3><a id="font_colorpurple26_Functionsfont_373"></a><font color="purple">2.6 函数（Functions）</font></h3> 
<p><code>Prometheus</code>支持对数据进行操作的几个函数，详情参考：<a href="https://prometheus.io/docs/prometheus/latest/querying/functions/" rel="nofollow">https://prometheus.io/docs/prometheus/latest/querying/functions/</a></p> 
<table><thead><tr><th align="left">函数名</th><th align="left">解析</th></tr></thead><tbody><tr><td align="left">abs()</td><td align="left">求瞬时向量绝对值</td></tr><tr><td align="left">absent()</td><td align="left">传入一个瞬时非空向量则返回空向量，否则返回不带名称值为1的指标，用来监控空数据的情况，即nodata监控</td></tr><tr><td align="left">absent_over_time()</td><td align="left">返回一个空向量;如果传递给它的范围向量没有元素，则返回一个1元素的值为1的向量。</td></tr><tr><td align="left">ceil()</td><td align="left">四舍五入取整</td></tr><tr><td align="left">changes()</td><td align="left">计算区间向量中每个样本值变化次数，返回的是瞬时向量</td></tr><tr><td align="left">clamp()</td><td align="left">所有元素的样本值，使其下限为min，上限为max。</td></tr><tr><td align="left">clamp_max()</td><td align="left">瞬时向量值如果大于max 则值修改为max，否则值不变（用于将向量规范到一个不大于max的区间内）</td></tr><tr><td align="left">clamp_min()</td><td align="left">同理，将向量规范到一个不小于min值的范围内</td></tr><tr><td align="left">day_of_month()</td><td align="left">返回 1～31 向量所在UTC时间中的所在月份的第几天</td></tr><tr><td align="left">day_of_week()</td><td align="left">返回被给定 UTC 时间所在周的第几天。返回值范围：0~6，0 表示星期天。</td></tr><tr><td align="left">days_in_month()</td><td align="left">返回当月一共有多少天。返回值范围：28~31。</td></tr><tr><td align="left">delta()</td><td align="left">参数是一个区间向量，返回一个瞬时向量。它计算一个区间向量 v 的第一个元素和最后一个元素之间的差值（和张羽看了prometheus的实现代码，可以简单理解为就是最后一个点的值减去第一个点的值。但是实际上真实场景中，第一个点和最后一个点不可能每次都正好每和时间区间的第一个时间点和最后一个时间点相吻合，所以prometheus在代码中做了大量的计算，由于涉及到很多除法运算，因此结果一般都是小数）</td></tr><tr><td align="left">deriv()</td><td align="left">参数是一个区间向量,返回一个瞬时向量。它使用简单的线性回归计算区间向量 v 中各个时间序列的导数。</td></tr><tr><td align="left">exp()</td><td align="left">输入一个瞬时向量，返回各个样本值的 e 的指数值，即 e 的 N 次方。当得到一个无穷大的值，显示 +Inf， 反之显示0, e的负数次方无限趋进0。e的空向量指数依然为空向量。</td></tr><tr><td align="left">floor()</td><td align="left">与 ceil() 函数相反，舍弃小数部分取整</td></tr><tr><td align="left">histogram_quantile()</td><td align="left">从直方图的桶b计算φ-分位数(0≤φ≤1)。</td></tr><tr><td align="left">holt_winters()</td><td align="left">生成一个基于v的范围的时间序列的平滑值，平滑因子sf越低，旧数据越重要。趋势因子tf越高，数据中考虑的趋势越多。sf和tf都必须在0和1之间。</td></tr><tr><td align="left">hour()</td><td align="left">函数返回被给定 UTC 时间的当前第几个小时，时间范围：0~23。</td></tr><tr><td align="left">idelta()</td><td align="left">参数是一个区间向量, 返回一个瞬时向量。它计算最新的 2 个样本值之间的差值。(当区间内仅有一个向量时无返回值)</td></tr><tr><td align="left">increase()</td><td align="left">函数获取区间向量中的第一个和最后一个样本并返回其增长量，它会在单调性发生变化时(如由于采样目标重启引起的计数器复位)自动中断。</td></tr><tr><td align="left">irate()</td><td align="left">使用rate计算快速变化的样本平均增长率时，容易陷入长尾问题，因为它用平均值将峰值削平了，无法反映时间窗口内样本数据的快速变化。与rate类似，irate同样可以计算counter的平均增长率，但其反映出的是瞬时增长率。irate计算增长率时，使用指定时间范围内的最后两个样本数据</td></tr><tr><td align="left">label_join()</td><td align="left">函数可以将时间序列 v 中多个标签 src_label 的值，通过 separator 作为连接符写入到一个新的标签 dst_label 中。可以有多个 src_label 标签</td></tr><tr><td align="left">label_replace()</td><td align="left">在原标签中匹配字符，放到目标标签中</td></tr><tr><td align="left">ln()</td><td align="left">计算瞬时向量 v 中所有样本数据的自然对数。</td></tr><tr><td align="left">log2()</td><td align="left">计算瞬时向量 v 中所有样本数据的二进制对数。特殊情况同ln</td></tr><tr><td align="left">log10()</td><td align="left">计算瞬时向量 v 中所有样本数据的十进制对数。特殊情况同ln。</td></tr><tr><td align="left">minute()</td><td align="left">函数返回给定 UTC 时间当前小时的第多少分钟。结果范围：0~59。</td></tr><tr><td align="left">month()</td><td align="left">函数返回给定 UTC 时间当前属于第几个月，结果范围：0~12。</td></tr><tr><td align="left">predict_linear()</td><td align="left">可以预测时间序列 v 在 t 秒后的值。它基于简单线性回归的方式，对时间窗口内的样本数据进行统计，从而可以对时间序列的变化趋势做出预测。</td></tr><tr><td align="left">rate()</td><td align="left">用于计算区间向量平均增长率，如计算QPS</td></tr><tr><td align="left">resets()</td><td align="left">对于每个时间序列，它都返回一个计数器重置的次数。两个连续样本之间单调性发生变化被认为是一次计数器重置。</td></tr><tr><td align="left">round()</td><td align="left">与 ceil 和 floor 函数类似，返回向量中所有样本值的最接近to_nearest值整数倍的值，当to_nearest=1时等价于ceil。</td></tr><tr><td align="left">scalar()</td><td align="left">返回一个单元素瞬时向量的样本值，当多元素或者没有元素返回Nan。</td></tr><tr><td align="left">sgn()</td><td align="left">返回一个向量，所有样本值都转换为它们的符号，定义为:1如果v是正的，-1如果v是负的，0如果v等于0。</td></tr><tr><td align="left">sort()</td><td align="left">对向量按元素的值进行升序排序。</td></tr><tr><td align="left">sort_desc()</td><td align="left">对向量按元素的值进行降序排序。</td></tr><tr><td align="left">sqrt()</td><td align="left">计算向量 v 中所有元素的平方根。</td></tr><tr><td align="left">time()</td><td align="left">返回自UTC 1970年1月1日以来的秒数。请注意，这实际上并不返回当前时间，而是表达式被求值的时间。</td></tr><tr><td align="left">timestamp()</td><td align="left">返回向量 v 中的每个样本的时间戳（从 1970-01-01 到现在的秒数）。</td></tr><tr><td align="left">vector()</td><td align="left">将标量 s 作为没有标签的向量返回（和scalar作用刚好相反）。</td></tr><tr><td align="left">year()</td><td align="left">函数返回被给定 UTC 时间的当前年份。</td></tr><tr><td align="left"><code>&lt;aggregation&gt;_over_time()</code></td><td align="left">允许在一段时间内聚合给定范围向量的每个序列，并返回带有每个序列聚合结果的即时向量</td></tr></tbody></table> 
<h3><a id="font_colorpurple27_Commentsfont_427"></a><font color="purple">2.7 注释（Comments）</font></h3> 
<p>PromQL 支持以<code>#</code>开头的注释， 例如:</p> 
<pre><code class="prism language-bash"><span class="token comment"># This is a comment</span>
</code></pre> 
<h3><a id="font_colorpurple28_Gotchasfont_434"></a><font color="purple">2.8 陷阱（Gotchas）</font></h3> 
<h4><a id="font_colorpurple281_Stalenessfont_435"></a><font color="purple">2.8.1 过时（Staleness）</font></h4> 
<p>这里主要声明一些关于过期的描述，直接贴图：<br> <img src="https://images2.imgbox.com/c5/63/ZTcK2NMa_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="font_colorpurple282_Avoiding_slow_queries_and_overloadsfont_438"></a><font color="purple">2.8.2 避免慢查询和重载（Avoiding slow queries and overloads）</font></h4> 
<p>这里主要讲慢查询和重载的注意点，直接贴图：<br> <img src="https://images2.imgbox.com/62/a8/JsDr2Z25_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="font_colorpurple03_font_442"></a><font color="purple">03 举例</font></h2> 
<h3><a id="font_colorpurple31_Simple_time_series_selectionfont_443"></a><font color="purple">3.1 简单的时间序列选择（Simple time series selection）</font></h3> 
<p>返回带有度量<code>http_requests_total</code>的所有时间序列:</p> 
<pre><code class="prism language-bash">http_requests_total
</code></pre> 
<p>返回带有指标http_requests_total和给定的作业和处理器标签的所有时间序列:</p> 
<pre><code class="prism language-bash">http_requests_total<span class="token punctuation">{<!-- --></span>job<span class="token operator">=</span><span class="token string">"apiserver"</span>, <span class="token assign-left variable">handler</span><span class="token operator">=</span><span class="token string">"/api/comments"</span><span class="token punctuation">}</span>
</code></pre> 
<p>返回同一向量的整个时间范围(在本例中为5分钟)，使其成为一个范围向量:</p> 
<pre><code class="prism language-bash">http_requests_total<span class="token punctuation">{<!-- --></span>job<span class="token operator">=</span><span class="token string">"apiserver"</span>, <span class="token assign-left variable">handler</span><span class="token operator">=</span><span class="token string">"/api/comments"</span><span class="token punctuation">}</span><span class="token punctuation">[</span>5m<span class="token punctuation">]</span>
</code></pre> 
<p>请注意，产生范围向量的表达式不能直接绘制图形，而是在表达式浏览器的表格(“Console”)视图中查看。</p> 
<p>使用正则表达式，您可以仅为名称匹配特定模式的作业选择时间序列，在本例中，所有以server结尾的作业:</p> 
<pre><code class="prism language-bash">http_requests_total<span class="token punctuation">{<!-- --></span>job<span class="token operator">=~</span><span class="token string">".*server"</span><span class="token punctuation">}</span>
</code></pre> 
<p>要选择除4xx以外的所有HTTP状态码，可以运行:</p> 
<pre><code class="prism language-bash">http_requests_total<span class="token punctuation">{<!-- --></span>status<span class="token operator">!</span>~<span class="token string">"4.."</span><span class="token punctuation">}</span>
</code></pre> 
<h3><a id="font_colorpurple32_Subqueryfont_471"></a><font color="purple">3.2 子查询（Subquery）</font></h3> 
<p>返回过去30分钟http_requests_total度量的5分钟速率，分辨率为1分钟。</p> 
<pre><code class="prism language-bash">rate<span class="token punctuation">(</span>http_requests_total<span class="token punctuation">[</span>5m<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">[</span>30m:1m<span class="token punctuation">]</span>
</code></pre> 
<p>这是一个嵌套子查询的示例。派生函数的子查询使用默认分辨率。注意，不必要地使用子查询是不明智的。</p> 
<pre><code class="prism language-bash">max_over_time<span class="token punctuation">(</span>deriv<span class="token punctuation">(</span>rate<span class="token punctuation">(</span>distance_covered_total<span class="token punctuation">[</span>5s<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">[</span>30s:5s<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">[</span>10m:<span class="token punctuation">]</span><span class="token punctuation">)</span>
</code></pre> 
<h3><a id="font_colorpurple34_Using_functions_operators_etcfont_482"></a><font color="purple">3.4 方法、操作符（Using functions, operators, etc.）</font></h3> 
<p>返回带有http_requests_total指标名称的所有时间序列的每秒速率，在过去5分钟内测量:</p> 
<pre><code class="prism language-bash">rate<span class="token punctuation">(</span>http_requests_total<span class="token punctuation">[</span>5m<span class="token punctuation">]</span><span class="token punctuation">)</span>
</code></pre> 
<p>假设http_requests_total时间序列都有标签job(根据作业名称fanout)和instance(根据作业实例fanout)，我们可能想要对所有实例的速率求和，这样我们得到更少的输出时间序列，但仍然保留作业维度:</p> 
<pre><code class="prism language-bash"><span class="token function">sum</span> by <span class="token punctuation">(</span>job<span class="token punctuation">)</span> <span class="token punctuation">(</span>
  rate<span class="token punctuation">(</span>http_requests_total<span class="token punctuation">[</span>5m<span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span>
</code></pre> 
<p>如果我们有两个具有相同维度标签的不同度量，我们可以对它们应用二元运算符，两边具有相同标签集的元素将被匹配并传播到输出中。例如，该表达式返回MiB中每个实例的未使用内存(在一个虚构的集群调度程序上，暴露其运行的实例的这些指标):</p> 
<pre><code class="prism language-bash"><span class="token punctuation">(</span>instance_memory_limit_bytes - instance_memory_usage_bytes<span class="token punctuation">)</span> / <span class="token number">1024</span> / <span class="token number">1024</span>
</code></pre> 
<p>同样的表达式，但是通过应用求和，可以写成这样:</p> 
<pre><code class="prism language-bash"><span class="token function">sum</span> by <span class="token punctuation">(</span>app, proc<span class="token punctuation">)</span> <span class="token punctuation">(</span>
  instance_memory_limit_bytes - instance_memory_usage_bytes
<span class="token punctuation">)</span> / <span class="token number">1024</span> / <span class="token number">1024</span>
</code></pre> 
<p>如果同一个虚构的集群调度程序暴露了每个实例的CPU使用率指标，如下所示:</p> 
<pre><code class="prism language-bash">instance_cpu_time_ns<span class="token punctuation">{<!-- --></span>app<span class="token operator">=</span><span class="token string">"lion"</span>, <span class="token assign-left variable">proc</span><span class="token operator">=</span><span class="token string">"web"</span>, <span class="token assign-left variable">rev</span><span class="token operator">=</span><span class="token string">"34d0f99"</span>, <span class="token assign-left variable">env</span><span class="token operator">=</span><span class="token string">"prod"</span>, <span class="token assign-left variable">job</span><span class="token operator">=</span><span class="token string">"cluster-manager"</span><span class="token punctuation">}</span>
instance_cpu_time_ns<span class="token punctuation">{<!-- --></span>app<span class="token operator">=</span><span class="token string">"elephant"</span>, <span class="token assign-left variable">proc</span><span class="token operator">=</span><span class="token string">"worker"</span>, <span class="token assign-left variable">rev</span><span class="token operator">=</span><span class="token string">"34d0f99"</span>, <span class="token assign-left variable">env</span><span class="token operator">=</span><span class="token string">"prod"</span>, <span class="token assign-left variable">job</span><span class="token operator">=</span><span class="token string">"cluster-manager"</span><span class="token punctuation">}</span>
instance_cpu_time_ns<span class="token punctuation">{<!-- --></span>app<span class="token operator">=</span><span class="token string">"turtle"</span>, <span class="token assign-left variable">proc</span><span class="token operator">=</span><span class="token string">"api"</span>, <span class="token assign-left variable">rev</span><span class="token operator">=</span><span class="token string">"4d3a513"</span>, <span class="token assign-left variable">env</span><span class="token operator">=</span><span class="token string">"prod"</span>, <span class="token assign-left variable">job</span><span class="token operator">=</span><span class="token string">"cluster-manager"</span><span class="token punctuation">}</span>
instance_cpu_time_ns<span class="token punctuation">{<!-- --></span>app<span class="token operator">=</span><span class="token string">"fox"</span>, <span class="token assign-left variable">proc</span><span class="token operator">=</span><span class="token string">"widget"</span>, <span class="token assign-left variable">rev</span><span class="token operator">=</span><span class="token string">"4d3a513"</span>, <span class="token assign-left variable">env</span><span class="token operator">=</span><span class="token string">"prod"</span>, <span class="token assign-left variable">job</span><span class="token operator">=</span><span class="token string">"cluster-manager"</span><span class="token punctuation">}</span>
<span class="token punctuation">..</span>.
</code></pre> 
<p>我们可以得到按应用程序(app)和进程类型(proc)分组的前3名CPU用户，如下所示:</p> 
<pre><code class="prism language-bash">topk<span class="token punctuation">(</span><span class="token number">3</span>, <span class="token function">sum</span> by <span class="token punctuation">(</span>app, proc<span class="token punctuation">)</span> <span class="token punctuation">(</span>rate<span class="token punctuation">(</span>instance_cpu_time_ns<span class="token punctuation">[</span>5m<span class="token punctuation">]</span><span class="token punctuation">))</span><span class="token punctuation">)</span>
</code></pre> 
<p>假设这个指标包含每个运行实例一个时间序列，你可以这样计算每个应用程序运行实例的数量:</p> 
<pre><code class="prism language-bash">count by <span class="token punctuation">(</span>app<span class="token punctuation">)</span> <span class="token punctuation">(</span>instance_cpu_time_ns<span class="token punctuation">)</span>
</code></pre> 
<h2><a id="font_colorpurple04_HTTPfont_528"></a><font color="purple">04 HTTP接口获取</font></h2> 
<p>当前稳定的HTTP API在Prometheus服务器的/ API /v1下是可访问的，详情参考：<a href="https://prometheus.io/docs/prometheus/latest/querying/api/" rel="nofollow">https://prometheus.io/docs/prometheus/latest/querying/api/</a></p> 
<h2><a id="font_colorpurple05_font_532"></a><font color="purple">05 小结</font></h2> 
<p>本文主要讲解了<code>PromSQL</code>的构造以及每块组成部分的解析，具体还需要去详细查看<a href="https://prometheus.io/docs/prometheus/latest/querying/basics/" rel="nofollow">官方的文档</a>，本文就不再过细的描述了。谢谢大家的阅读，本文完！</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/838eb85f4264c8f03365abc711231f4c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Python Pandas 中的数据结构（超详细，你确定不学习一下？）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c5e2b043570fc2fa8b12ffbade75dfc7/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">第三方应用调用系统SO 库失败Caused by: java.lang.UnsatisfiedLinkError: dlopen failed: library</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>