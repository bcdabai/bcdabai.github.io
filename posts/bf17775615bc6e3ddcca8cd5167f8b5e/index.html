<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>filelist_package的使用 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="filelist_package的使用" />
<meta property="og:description" content="filelist_package的使用 文章目录 filelist_package的使用不使用pkg的filist首先filelist（tb.f）中如果只是包含文件夹，不是指定包含文件。如果文件不在同一文件夹下 在filelist使用pkg（作用是避免过多使用`include或在filelist中放入过多条目）不能将pkg在module内部中`include。也不能在pkg内`include &#34;pkg&#34;。还有也不能在pkg内`include &#34;interface.sv&#34;。filist中加上pkg嵌套的package以及非嵌套package。 总结 验证中filelist以及package的使用
Systemverilog 中`include 和 filelist区别
下面的例子中使用的makefile：
dumpfile：
不使用pkg的filist 首先filelist（tb.f）中如果只是包含文件夹，不是指定包含文件。 比如我们有三个文件在同一个文件夹下：
第一个lab_task.sv，里面只包含了一个task print_t,但是这个task使用,lab_task0.sv里面定义的print_i task。
第二个lab_task0.sv，也只定义一个task
第三个就是一个testbench的文件，注释部分先不用看。这里面只是调用了print_t这个task。
filelist我们这样写：注释的部分不用看（//）
此时lab_task.sv和lab_task0.sv是没有包含出来，只是列举了包含他们的path ./。但是lab28_dpi是列出来的，编译结果是：
可以看到 ，编译找不到print_t，那么我们就需要显示的将lab_task.sv和lab_task0.sv包含进去。显示包含有两种方式：
第一种方式是直接在filelist中。将两个文件列出来，需要注意文件顺序。（这里其实&#43;incdir&#43;./可以不要，因为我们需要的两个文件已经列出来）
编译结果就不会报错：
第二种就是tb.f不变，但是在lab28_dpi中将两个文件`include进来。这种也不会报错（但是注意&#43;incdir&#43;./不能省略，因为可能lab_task可能和testbench不在同一个文件夹下，所以需要指明路径，这里省略是因为在同一个目录下）。
如果两种方式同时使用就会报重复编译错误，也就是如果filist列举出来，那么就不用include进去（这种情况可以使用宏来避免）。
如果文件不在同一文件夹下 如果我们把lab_task.sv和lab_task0.sv放在上一级目录，filist为：
testbench依然为：
编译报错，找不到对应的lab_task.sv，和lab_task0.sv：
这说明我们需要把这两个文件显示的包含进来，和上面一样，也是上面这两种方式：
首先说第二种include方式，我们可以在testbench的include上加上路径，include &#34;../lab_task.sv&#34; ,include “…/lab_task0.sv”，这样也会编译出结果，但是这种不常用。常用的是tb.f中加上上一级目录，同时testbench中include不变。也就是只需要把tb.f改为：
第一种方式在filist中加上这两个文件申明，就是加上两行…/lab_task.sv，…/lab_task0.sv。但是就别既在filist中加文件，又在testbench中加include。比如我们两种都使用，那么就会报错：
（如果想要避免这种错误，可以使用宏定义来控制）。
在filelist使用pkg（作用是避免过多使用`include或在filelist中放入过多条目） 不能将pkg在module内部中include。也不能在pkg内include “pkg”。还有也不能在pkg内`include “interface.sv”。 比如，下面两种都会报错
module test() `include &#34;pkg1.sv&#34; endmodule package pkg1; `include &#34;pkg2.sv&#34; endpackage 正确的应该是在外面`include(因为include就是把代码段嵌入include处)，在里面import。比如
`include &#34;pkg1.sv&#34; module test(); import pkg1::*; endmodule filist中加上pkg 比如我们现在用一个pkg将两个task文件包进去（此时lab_task.sv，lab_task0.sv,lab_pkg.sv都在目录…/下,而makefile，filelist，testbench都在./（当前目录） ）,文件内容如下（注释部分先不去管）：
此时，我们也可以使用两种方式来使用pkg." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/bf17775615bc6e3ddcca8cd5167f8b5e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-09-05T11:24:16+08:00" />
<meta property="article:modified_time" content="2023-09-05T11:24:16+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">filelist_package的使用</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="filelist_package_0"></a>filelist_package的使用</h2> 
<p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#filelist_package_0" rel="nofollow">filelist_package的使用</a></li><li><ul><li><a href="#pkgfilist_15" rel="nofollow">不使用pkg的filist</a></li><li><ul><li><a href="#filelisttbf_17" rel="nofollow">首先filelist（tb.f）中如果只是包含文件夹，不是指定包含文件。</a></li><li><a href="#_61" rel="nofollow">如果文件不在同一文件夹下</a></li></ul> 
   </li><li><a href="#filelistpkgincludefilelist_88" rel="nofollow">在filelist使用pkg（作用是避免过多使用`include或在filelist中放入过多条目）</a></li><li><ul><li><a href="#pkgmoduleincludepkginclude_pkgpkginclude_interfacesv_90" rel="nofollow">不能将pkg在module内部中`include。也不能在pkg内`include "pkg"。还有也不能在pkg内`include "interface.sv"。</a></li><li><a href="#filistpkg_115" rel="nofollow">filist中加上pkg</a></li><li><a href="#packagepackage_143" rel="nofollow">嵌套的package以及非嵌套package。</a></li></ul> 
   </li><li><a href="#_233" rel="nofollow">总结</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<blockquote> 
 <p><a href="https://blog.csdn.net/geter_CS/article/details/125689476">验证中filelist以及package的使用</a></p> 
 <p><a href="https://blog.csdn.net/weixin_42760668/article/details/120335905">Systemverilog 中`include 和 filelist区别</a></p> 
</blockquote> 
<p>下面的例子中使用的makefile：</p> 
<p><img src="https://images2.imgbox.com/73/35/3sz05dta_o.png" alt="在这里插入图片描述"></p> 
<p>dumpfile：</p> 
<p><img src="https://images2.imgbox.com/9c/fc/LqHzsnNj_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="pkgfilist_15"></a>不使用pkg的filist</h3> 
<h4><a id="filelisttbf_17"></a>首先filelist（tb.f）中如果只是包含文件夹，不是指定包含文件。</h4> 
<p>比如我们有三个文件在同一个文件夹下：</p> 
<p>第一个lab_task.sv，里面只包含了一个task print_t,但是这个task使用,lab_task0.sv里面定义的print_i task。</p> 
<p><img src="https://images2.imgbox.com/66/93/dbYCknaS_o.png" alt="在这里插入图片描述"></p> 
<p>第二个lab_task0.sv，也只定义一个task</p> 
<p><img src="https://images2.imgbox.com/52/24/juraBRtf_o.png" alt="img"></p> 
<p>第三个就是一个testbench的文件，注释部分先不用看。这里面只是调用了print_t这个task。</p> 
<p><img src="https://images2.imgbox.com/1c/11/0pHHXalj_o.png" alt="在这里插入图片描述"></p> 
<p>filelist我们这样写：注释的部分不用看（//）</p> 
<p><img src="https://images2.imgbox.com/42/1d/ADqLwoUD_o.png" alt="在这里插入图片描述"></p> 
<p>此时lab_task.sv和lab_task0.sv是没有包含出来，只是列举了包含他们的path ./。但是lab28_dpi是列出来的，编译结果是：</p> 
<p><img src="https://images2.imgbox.com/bf/cb/U1kbMtwl_o.png" alt="在这里插入图片描述"></p> 
<p>可以看到 ，编译找不到print_t，那么我们就需要显示的将lab_task.sv和lab_task0.sv包含进去。显示包含有两种方式：</p> 
<p>第一种方式是直接在filelist中。将两个文件列出来，需要注意文件顺序。（这里其实+incdir+./可以不要，因为我们需要的两个文件已经列出来）</p> 
<p><img src="https://images2.imgbox.com/84/ad/vfhraWv9_o.png" alt="在这里插入图片描述"></p> 
<p>编译结果就不会报错：</p> 
<p><img src="https://images2.imgbox.com/3b/ee/w95ftceE_o.png" alt="在这里插入图片描述"></p> 
<p>第二种就是tb.f不变，但是在lab28_dpi中将两个文件`include进来。这种也不会报错（<strong>但是注意+incdir+./不能省略，因为可能lab_task可能和testbench不在同一个文件夹下，所以需要指明路径，这里省略是因为在同一个目录下</strong>）。</p> 
<p><img src="https://images2.imgbox.com/2a/59/uhEy4CSu_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/3b/7c/0CV5INnU_o.png" alt="在这里插入图片描述"></p> 
<p>如果两种方式同时使用就会报重复编译错误，也就是如果filist列举出来，那么就不用include进去（这种情况可以使用宏来避免）。</p> 
<h4><a id="_61"></a>如果文件不在同一文件夹下</h4> 
<p>如果我们把lab_task.sv和lab_task0.sv放在上一级目录，filist为：</p> 
<p><img src="https://images2.imgbox.com/ee/0a/pdSkuxQs_o.png" alt="在这里插入图片描述"></p> 
<p>testbench依然为：</p> 
<p><img src="https://images2.imgbox.com/77/d9/dc6jJ8Ad_o.png" alt="在这里插入图片描述"></p> 
<p>编译报错，找不到对应的lab_task.sv，和lab_task0.sv：</p> 
<p><img src="https://images2.imgbox.com/c8/69/WkxYvFJo_o.png" alt="在这里插入图片描述"></p> 
<p>这说明我们需要把这两个文件显示的包含进来，和上面一样，也是上面这两种方式：</p> 
<p>首先说第二种include方式，我们可以在testbench的include上加上路径，<code>include "../lab_task.sv" ,</code>include “…/lab_task0.sv”，这样也会编译出结果，但是这种不常用。常用的是tb.f中加上上一级目录，同时testbench中include不变。也就是只需要把tb.f改为：</p> 
<p><img src="https://images2.imgbox.com/f7/06/ruHLfyMG_o.png" alt="在这里插入图片描述"></p> 
<p>第一种方式在filist中加上这两个文件申明，就是加上两行…/lab_task.sv，…/lab_task0.sv。但是就别既在filist中加文件，又在testbench中加include。比如我们两种都使用，那么就会报错：</p> 
<p><img src="https://images2.imgbox.com/13/4a/5qrVvZd0_o.png" alt="在这里插入图片描述"></p> 
<p>（<strong>如果想要避免这种错误，可以使用宏定义来控制</strong>）。</p> 
<h3><a id="filelistpkgincludefilelist_88"></a>在filelist使用pkg（作用是避免过多使用`include或在filelist中放入过多条目）</h3> 
<h4><a id="pkgmoduleincludepkginclude_pkgpkginclude_interfacesv_90"></a>不能将pkg在module内部中<code>include。也不能在pkg内</code>include “pkg”。还有也不能在pkg内`include “interface.sv”。</h4> 
<p>比如，下面两种都会报错</p> 
<pre><code class="prism language-verilog">module test()
`include "pkg1.sv"
endmodule
</code></pre> 
<pre><code class="prism language-verilog">package pkg1;
`include "pkg2.sv"
endpackage
</code></pre> 
<p>正确的应该是在外面`include(因为include就是把代码段嵌入include处)，在里面import。比如</p> 
<pre><code class="prism language-verilog">`include "pkg1.sv"
module test();
import pkg1::*;
endmodule
</code></pre> 
<h4><a id="filistpkg_115"></a>filist中加上pkg</h4> 
<p>比如我们现在用一个pkg将两个task文件包进去（此时lab_task.sv，lab_task0.sv,lab_pkg.sv都在目录…/下,而makefile，filelist，testbench都在./（当前目录） ）,文件内容如下（注释部分先不去管）：</p> 
<p><img src="https://images2.imgbox.com/dc/c6/htlDfiap_o.png" alt="在这里插入图片描述"></p> 
<p>此时，我们也可以使用两种方式来使用pkg.</p> 
<p>第一种，也是在filist中将其列出来（注意一般都需要将所在目录加上，因为有依赖文件，比如lab_pkg.sv依赖lab_task.sv和lab_task0.sv，所以…incdir+…/需要加上）：</p> 
<p><img src="https://images2.imgbox.com/3f/3d/HawuX4ZO_o.png" alt="在这里插入图片描述"></p> 
<p>然后直接在testbench中去import(注意就不用`include了，否则重复编译) 。</p> 
<p><img src="https://images2.imgbox.com/c3/a9/iHIEwZbT_o.png" alt="在这里插入图片描述"></p> 
<p>编译结果：</p> 
<p><img src="https://images2.imgbox.com/40/c9/VV0e3sdz_o.png" alt="在这里插入图片描述"></p> 
<p>第二种，不在fileist中将lab_pkg列出来，然后在testbench中使用include和import来使用lab_pkg.此时filelist为：</p> 
<p><img src="https://images2.imgbox.com/db/b5/bh5uTVBE_o.png" alt="在这里插入图片描述"></p> 
<p>testbench为：</p> 
<p><img src="https://images2.imgbox.com/62/f3/3COs2Q1U_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="packagepackage_143"></a>嵌套的package以及非嵌套package。</h4> 
<p>比如现在lab_pkg.sv只包含lab_task.sv，lab_pkg0.sv只包含lab_task0.sv，两个pkg的内容如下。</p> 
<p><img src="https://images2.imgbox.com/c0/1d/3k4LZJJv_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/de/b9/F3Aqd2SE_o.png" alt="在这里插入图片描述"></p> 
<p>如果我们filelist如下：</p> 
<p><img src="https://images2.imgbox.com/4d/96/95XZo5tm_o.png" alt="img"></p> 
<p>testbench如下：</p> 
<p><img src="https://images2.imgbox.com/69/b1/CNNA0YZr_o.png" alt="img"></p> 
<p>那么编译会报错：</p> 
<p><img src="https://images2.imgbox.com/f1/a4/CqINOdbU_o.png" alt="在这里插入图片描述"></p> 
<p>因为lab_pkg0没有include进来。</p> 
<p>我们可以在lab_pkg.sv中将lab_pkg0.sv include进去。入下修改lab_pkg.sv为：</p> 
<p><img src="https://images2.imgbox.com/24/be/LXajXcaj_o.png" alt="在这里插入图片描述"></p> 
<p>这样编译就不会报错：</p> 
<p><img src="https://images2.imgbox.com/fc/6a/9ko3dAyd_o.png" alt="在这里插入图片描述"></p> 
<p>但是这样嵌套使用，如果我在testbench中想直接使用print_i是使用不了的。因为对嵌套使用的pkg里的内容对于testbench是不可见的。比如testbench改为：</p> 
<p><img src="https://images2.imgbox.com/11/38/bQb1clFZ_o.png" alt="在这里插入图片描述"></p> 
<p>会报错找不到print_i:</p> 
<p><img src="https://images2.imgbox.com/a5/09/7bQ8ixR4_o.png" alt="在这里插入图片描述"></p> 
<p>要想在testbench上也可以直接使用print_i，这里举三种方式：</p> 
<p>A.一种是print_i所在的lab_task0.sv不使用pkg来打包，而是直接include 进入lab_task0.sv。这样就不是期嵌套的使用pkg，而是直接include的一个文件，那么print_i对于testbench就是可见的（其他文件不变）。代码如下：<br> <img src="https://images2.imgbox.com/b9/bb/aZBHd1EE_o.png" alt="在这里插入图片描述"></p> 
<p>但是注意不可在pkg定义外面include，这样也会报错的，lab_task会找不到print_i。</p> 
<p>错误示范：</p> 
<p><img src="https://images2.imgbox.com/08/0e/DDbbNJLU_o.png" alt="在这里插入图片描述"></p> 
<p>编译报错：</p> 
<p><img src="https://images2.imgbox.com/5b/48/x2XJofcK_o.png" alt="img"></p> 
<p>但是注意这种情况对于testbench来说，print_i是可见的，比如我们将上面报错地方lab_task.sv中对print_i注释掉。其他代码保持如上：</p> 
<p><img src="https://images2.imgbox.com/1b/95/ne0HBUkn_o.png" alt="在这里插入图片描述"></p> 
<p>编译结果不会报错：</p> 
<p><img src="https://images2.imgbox.com/fb/6e/J3oOrkCN_o.png" alt="img"></p> 
<p>B. 上面错误示范情况知道，pkg外include的文件内容可以在其他地方使用（也就是一地include，多地使用），但是对于pkg内的是不可见（如果pkg外include是pkg文件，则需要在pkg内加上对此include文件的import才可以），所以可以lab_pkg不变，tb.f也不变，只需在testbench中加上import lab_pkg0::*就可以（这里就是一次include pkg文件，多地import）。</p> 
<p><img src="https://images2.imgbox.com/52/6b/0whzLVGD_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/36/ec/Q6CoG7Pa_o.png" alt="在这里插入图片描述"></p> 
<p>编译结果，print_i执行两次：</p> 
<p><img src="https://images2.imgbox.com/08/9e/KYMBv6Y8_o.png" alt="在这里插入图片描述"></p> 
<p>C.另种是可以直接在filist中加上…/lab_pkg0.sv这一行，然后lab_pkg.sv中取消掉`include “lab_pkg0.sv”(避免重复编译)，同时testbench上加上，import lab_pkg0::*这一行，就可以了。文件内容如下：</p> 
<p>filelist：</p> 
<p><img src="https://images2.imgbox.com/da/12/bd6ZxzIl_o.png" alt="在这里插入图片描述"></p> 
<p>lab_pkg:</p> 
<p><img src="https://images2.imgbox.com/6a/66/WvkFOD80_o.png" alt="在这里插入图片描述"></p> 
<p>testbench（<em><strong>*注意lab_pkg.sv在testbench中做了include，如果不想include需要在filelist中列出lab_pkg.sv*</strong></em>）:</p> 
<p><img src="https://images2.imgbox.com/18/30/q8jZiscM_o.png" alt="在这里插入图片描述"></p> 
<p>编译结果：</p> 
<p><img src="https://images2.imgbox.com/62/70/NH4RvDUo_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_233"></a>总结</h3> 
<p><code>总结来说：规则是，要想使用某个文件内容，要么将文件在filelist中列出来，要吗include进去（filelist中列出相应文件夹）。嵌套的pkg只对于当前pkg中内容可见。pkg需要import。</code></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/77f8e78d2f455c459a2d55a319ff2037/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">CPU扫盲</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e4e5783847b9365625a8498bb2097cb8/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">javaScript:DOM元素的获取（静态/动态获取）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>