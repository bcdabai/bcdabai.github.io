<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>BeanFactory源码体系解析一 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="BeanFactory源码体系解析一" />
<meta property="og:description" content="BeanFactory:用于管理Bean的顶级工厂接口，它负责生产和管理bean，职责包括实例化、定位、配置应用程序中的对象，以及建立这些对象间的依赖。 1、FACTORY_BEAN_PREFIX= &#34;&amp;&#34; 对FactoryBean的转义定义，使用bean名字检索FactoryBean得到的是工厂生成的对象，得到工厂实例本身需要转义。 2、getBean(String name) 根据Bean名字或者bean实例，单例对象在容器启动时进行创建。 3、getBean(String name, @Nullable Class&lt;T&gt; requiredType) 根据bean名字和Class类型获取bean实例，增加了类型安全验证机制。 4、getBean(String name, Object... args) 通过bean的名称和参数来获取bean实例 5、boolean containsBean(String name) 通过beanname查看容器是否存在bean 6、boolean isSingleton(String name) 判断bean是否是单例 7、String[] getAliases(String name) 得到bean的别名，如果根据别名查找，那么其原名也会查找出来。 HierarchicalBeanFactory：这些bean有继承关系，每个bean有可能有父bean，支持父子上下文，分层可以使容器的每层都专注于特定的层次，比如 WebApplicationContext(专注于提供对web的支持) -&gt; ApplicationContext(专注于提供容器的扩展功能) -&gt; BeanFactory(专注基础功能) 1、BeanFactory getParentBeanFactory() 获取 parent bean factory 2、boolean containsLocalBean(String name) 判断当前BeanFactory实例中是否有指定名称的bean，只在当前bean factory中检索，不会在 parent bean factory 中检索 ListableBeanFactory:这些bean是可列表化，即Listable可以列举，在BeanFactory的基础上扩展了Beaan的清单，根据清单可以判断容器中是否存在指定的Bean，统计Bean的数量，获取满足要求的Bean的名称，获取满足要求的所有Bean 1、boolean containsBeanDefinition(String beanName) 是否包含指定名称的BeanDefinition 2、int getBeanDefinitionCount() 获取BeanDefinition数量 3、String[] getBeanDefinitionNames() 获取所有Bean的名称 4、getBeanProvider 多种参数(饥饿加载、懒加载)获取Bean对应的BeanProvier 5、getBeanNamesForType 多种入参获取所有的Bean名称 6、getBeansOfType 获取指定Type的所有Bean，返回Map key=name，value=Bean实例 7、String[] getBeanNamesForAnnotation 获取指定注解的所有Bean名称 8、findAnnotationOnBean(String beanName, Class&lt;A&gt; annotationType) 获取指定Bean名称对应的注解实例 SingletonBeanRegistry :单例的顶级接口，定义了单例的通用操作 1、registerSingleton(String beanName, Object singletonObject) 注册单例 2、Object getSingleton(String beanName) 获取单例 3、boolean containsSingleton(String beanName) 判断是否包括指定Bean名称的单例 4、String[] getSingletonNames() 获取所有已创建的单例名称 5、int getSingletonCount() 获取所有已创建的单例数量 6、Object getSingletonMutex() 获取单例注册的互斥锁 ConfigurableBeanFactory : 在HierarchicalBeanFactory、SingletonBeanRegistry2个接口的基础上定义了BeanFactory的通用配置(类加载器、类型转换、属性编辑器、BeanPostProcessor、作用域、Bean定义处理依赖关系、Bean如何销毁)，继承SingletonBeanRegistry扩展单例功能 属性SCOPE_SINGLETON(单例)、SCOPE_PROTOTYPE(原型) 设置父工厂，和HierarchicalBeanFactory的getParentBeanFactory方法互补 void setParentBeanFactory(BeanFactory parentBeanFactory); 四个和类加载器有关的方法工厂类加载器、临时类加载器 void setBeanClassLoader(@Nullable ClassLoader beanClassLoader); ClassLoader getBeanClassLoader(); void setTempClassLoader(@Nullable ClassLoader tempClassLoader); ClassLoader getTempClassLoader(); 两个设置是否缓存元数据的方法 void setCacheBeanMetadata(boolean cacheBeanMetadata); boolean isCacheBeanMetadata(); 11个处理Bean注册，加载等细节的方法，Bean表达式分解器 void setBeanExpressionResolver(@Nullable BeanExpressionResolver resolver); BeanExpressionResolver getBeanExpressionResolver(); 转换服务 void setConversionService(@Nullable ConversionService conversionService); ConversionService getConversionService(); 属性编辑器属性编辑注册 void addPropertyEditorRegistrar(PropertyEditorRegistrar registrar); void registerCustomEditor(Class&lt;?" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/23bc73f991c42a2f0662f4699a5f4f0d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-02-21T20:42:23+08:00" />
<meta property="article:modified_time" content="2022-02-21T20:42:23+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">BeanFactory源码体系解析一</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><img alt="" height="755" src="https://images2.imgbox.com/8a/70/FBA6h3W7_o.png" width="1200"></p> 
<pre>BeanFactory:用于管理Bean的顶级工厂接口，它负责生产和管理bean，职责包括实例化、定位、配置应用程序中的对象，以及建立这些对象间的依赖。
1、FACTORY_BEAN_PREFIX= "&amp;" 对FactoryBean的转义定义，使用bean名字检索FactoryBean得到的是工厂生成的对象，得到工厂实例本身需要转义。
2、getBean(String name) 根据Bean名字或者bean实例，单例对象在容器启动时进行创建。
3、getBean(String name, @Nullable Class&lt;T&gt; requiredType) 根据bean名字和Class类型获取bean实例，增加了类型安全验证机制。
4、getBean(String name, Object... args) 通过bean的名称和参数来获取bean实例
5、boolean containsBean(String name) 通过beanname查看容器是否存在bean
6、boolean isSingleton(String name) 判断bean是否是单例
7、String[] getAliases(String name) 得到bean的别名，如果根据别名查找，那么其原名也会查找出来。</pre> 
<pre>HierarchicalBeanFactory：这些bean有继承关系，每个bean有可能有父bean，支持父子上下文，分层可以使容器的每层都专注于特定的层次，比如 WebApplicationContext(专注于提供对web的支持) -&gt; ApplicationContext(专注于提供容器的扩展功能) -&gt; BeanFactory(专注基础功能)
1、BeanFactory getParentBeanFactory() 获取 parent bean factory
2、boolean containsLocalBean(String name) 判断当前BeanFactory实例中是否有指定名称的bean，只在当前bean factory中检索，不会在 parent bean factory 中检索</pre> 
<pre>ListableBeanFactory:这些bean是可列表化，即Listable可以列举，在BeanFactory的基础上扩展了Beaan的清单，根据清单可以判断容器中是否存在指定的Bean，统计Bean的数量，获取满足要求的Bean的名称，获取满足要求的所有Bean
1、boolean containsBeanDefinition(String beanName) 是否包含指定名称的BeanDefinition
2、int getBeanDefinitionCount() 获取BeanDefinition数量
3、String[] getBeanDefinitionNames() 获取所有Bean的名称
4、getBeanProvider 多种参数(饥饿加载、懒加载)获取Bean对应的BeanProvier
5、getBeanNamesForType 多种入参获取所有的Bean名称
6、getBeansOfType 获取指定Type的所有Bean，返回Map key=name，value=Bean实例
7、String[] getBeanNamesForAnnotation 获取指定注解的所有Bean名称
8、findAnnotationOnBean(String beanName, Class&lt;A&gt; annotationType) 获取指定Bean名称对应的注解实例

SingletonBeanRegistry :单例的顶级接口，定义了单例的通用操作
1、registerSingleton(String beanName, Object singletonObject) 注册单例
2、Object getSingleton(String beanName) 获取单例
3、boolean containsSingleton(String beanName) 判断是否包括指定Bean名称的单例
4、String[] getSingletonNames() 获取所有已创建的单例名称
5、int getSingletonCount() 获取所有已创建的单例数量
6、Object getSingletonMutex() 获取单例注册的互斥锁
ConfigurableBeanFactory : 在HierarchicalBeanFactory、SingletonBeanRegistry2个接口的基础上定义了BeanFactory的通用配置(类加载器、类型转换、属性编辑器、BeanPostProcessor、作用域、Bean定义处理依赖关系、Bean如何销毁)，继承SingletonBeanRegistry扩展单例功能
属性SCOPE_SINGLETON(单例)、SCOPE_PROTOTYPE(原型)
设置父工厂，和HierarchicalBeanFactory的getParentBeanFactory方法互补
void setParentBeanFactory(BeanFactory parentBeanFactory);
四个和类加载器有关的方法工厂类加载器、临时类加载器
void setBeanClassLoader(@Nullable ClassLoader beanClassLoader);
ClassLoader getBeanClassLoader();
void setTempClassLoader(@Nullable ClassLoader tempClassLoader);
ClassLoader getTempClassLoader();
两个设置是否缓存元数据的方法
void setCacheBeanMetadata(boolean cacheBeanMetadata);
boolean isCacheBeanMetadata();
11个处理Bean注册，加载等细节的方法，Bean表达式分解器
void setBeanExpressionResolver(@Nullable BeanExpressionResolver resolver);
BeanExpressionResolver getBeanExpressionResolver();
转换服务
void setConversionService(@Nullable ConversionService conversionService);
ConversionService getConversionService();
属性编辑器属性编辑注册
void addPropertyEditorRegistrar(PropertyEditorRegistrar registrar);
void registerCustomEditor(Class&lt;?&gt; requiredType, Class&lt;? extends PropertyEditor&gt; propertyEditorClass);
void copyRegisteredEditorsTo(PropertyEditorRegistry registry);
类型转换器
void setTypeConverter(TypeConverter typeConverter);
TypeConverter getTypeConverter();
嵌入式的字符串分解器
void addEmbeddedValueResolver(StringValueResolver valueResolver);
boolean hasEmbeddedValueResolver();
String resolveEmbeddedValue(String value);
Bean的后置处理器
void addBeanPostProcessor(BeanPostProcessor beanPostProcessor);
int getBeanPostProcessorCount();
生命周期注册范围
void registerScope(String scopeName, Scope scope);
String[] getRegisteredScopeNames();
Scope getRegisteredScope(String scopeName);
容器启动状态
void setApplicationStartup(ApplicationStartup applicationStartup);
ApplicationStartup getApplicationStartup();
返回安全访问上下文的方法
AccessControlContext getAccessControlContext();
从其他工程复制相关的所有配置
void copyConfigurationFrom(ConfigurableBeanFactory otherFactory);
两个Bean别名的方法
void registerAlias(String beanName, String alias);
void resolveAliases(StringValueResolver valueResolver);
合并Bean定义
BeanDefinition getMergedBeanDefinition(String beanName) ;
判断是否为工厂Bean
boolean isFactoryBean(String name) ;
Bean创建时机
void setCurrentlyInCreation(String beanName, boolean inCreation);
boolean isCurrentlyInCreation(String beanName);
Bean依赖相关方法
void registerDependentBean(String beanName, String dependentBeanName);
String[] getDependentBeans(String beanName);
String[] getDependenciesForBean(String beanName);
三个销毁方法
void destroyBean(String beanName, Object beanInstance);
void destroyScopedBean(String beanName);
void destroySingletons();
</pre> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8033df08bed3307537ac3bf2e4535002/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Games101笔记——Lecture 20:Color and Perception</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/171332b14b40cfec4ea3b3bf80f9ccbc/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">问题1： class DescriptorBase(metaclass=DescriptorMetaclass): ^Syntax invalid syntax</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>