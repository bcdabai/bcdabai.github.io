<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Gateway网关拦截器的ServerWebExchange - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Gateway网关拦截器的ServerWebExchange" />
<meta property="og:description" content="ServerWebExcahnge的解释如下：
Contract for an HTTP request-response interaction. Provides access to the HTTP request and response and also exposes additional server-side processing related properties and features such as request attributes.
大概是说：ServerWebExchange是一个HTTP请求-响应交互的契约。提供对HTTP请求和响应的访问，并公开额外的服务器端处理相关属性和特性，如请求属性，有点像Context的角色。
在 HTTP 协议中，请求头和请求体是请求的重要组成部分，ServerWebExchange 提供了丰富的方法来对其进行处理。
请求数据读取 例如，可以通过 ServerWebExchange.getRequest().getHeaders() 方法获取请求头：
ServerHttpRequest request = exchange.getRequest(); HttpHeaders headers = request.getHeaders(); String userAgent = headers.getFirst(HttpHeaders.USER_AGENT); 可以通过 ServerWebExchange.getRequest().getBody() 方法获取请求体：
ServerHttpRequest request = exchange.getRequest(); Mono&lt;String&gt; requestBody = request.getBody().map(dataBuffer -&gt; { byte[] buffer = new byte[dataBuffer.readableByteCount()]; dataBuffer.read(buffer); DataBufferUtils." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/b07373238ab937198883fdbb395e75c4/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-24T17:34:56+08:00" />
<meta property="article:modified_time" content="2024-01-24T17:34:56+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Gateway网关拦截器的ServerWebExchange</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p> ServerWebExcahnge的解释如下：</p> 
<blockquote> 
 <p>Contract for an HTTP request-response interaction. Provides access to the HTTP request and response and also exposes additional server-side processing related properties and features such as request attributes.</p> 
</blockquote> 
<p>大概是说：ServerWebExchange是一个HTTP请求-响应交互的契约。提供对HTTP请求和响应的访问，并公开额外的服务器端处理相关属性和特性，如请求属性，有点像Context的角色。</p> 
<p>在 HTTP 协议中，请求头和请求体是请求的重要组成部分，ServerWebExchange 提供了丰富的方法来对其进行处理。</p> 
<h4>请求数据读取</h4> 
<p>例如，可以通过 ServerWebExchange.getRequest().getHeaders() 方法获取请求头：</p> 
<pre><code>ServerHttpRequest request = exchange.getRequest();
HttpHeaders headers = request.getHeaders();
String userAgent = headers.getFirst(HttpHeaders.USER_AGENT);</code></pre> 
<p>可以通过 ServerWebExchange.getRequest().getBody() 方法获取请求体：</p> 
<pre><code>ServerHttpRequest request = exchange.getRequest();
Mono&lt;String&gt; requestBody = request.getBody().map(dataBuffer -&gt; {
    byte[] buffer = new byte[dataBuffer.readableByteCount()];
    dataBuffer.read(buffer);
    DataBufferUtils.release(dataBuffer);
    Charset charset = Charset.forName("UTF-8");
    return new String(buffer, charset);
});</code></pre> 
<p>这里使用 BodyExtractors.toMono(String.class) 也可以获取请求体，但是这种方式只适用于请求体是 JSON、XML 等文本格式的情况。而如果请求体是二进制文件，则需要使用上面的方式来获取。</p> 
<p>简单的理解是，ServerWebExcahnge包含了http请求的请求数据(ServerHttpRequest)，返回数据(ServerHttpResponse)。</p> 
<h4>从新封装请求</h4> 
<p>       ServerHttpRequest是一个只读类，对于读多写少的场景，这种设计模式是值得借鉴的。但是有时候我们也需要修改。则可以通过以下实现修改：</p> 
<pre><code class="language-java">ServerHttpRequest serverHttpRequest = exchange.getRequest().mutate().path(newPath).method(HttpMethod.GET).build();
ServerWebExchange serverWebExchange = exchange.mutate().request(serverHttpRequest).build();
return chain.filter(exchange);</code></pre> 
<p>     但是请求中的body参数流(inputstream)只能被读取一次，但是，我们通常由很多个过滤器，所以可能需要读取多次消息。解决这个办法需要用到官方提供的：ContentCachingRequestWrapper类。</p> 
<pre><code class="language-java">public ContentCachingRequestWrapper(HttpServletRequest request) {
    super(request);
    int contentLength = request.getContentLength();
    this.cachedContent = new ByteArrayOutputStream(contentLength &gt;= 0 ? contentLength : 1024);
    this.contentCacheLimit = null;
}</code></pre> 
<p>包装ContentCachingRequestWrapper，主要就做了一件事儿，感知request里面内容的长度，为自己开一个同样大小的输出流cachedContent。然后重写其中的方法：</p> 
<pre><code class="language-java">//重写方法getInputStream
@Override
public ServletInputStream getInputStream() throws IOException {
    if (this.inputStream == null) {
        this.inputStream = new ContentCachingInputStream(getRequest().getInputStream());
    }
    return this.inputStream;
}

//重写java.io.InputStream#read()方法
@Override
public int read() throws IOException {
	int ch = this.is.read();
	if (ch != -1 &amp;&amp; !this.overflow) {
		if (contentCacheLimit != null &amp;&amp; cachedContent.size() == contentCacheLimit) {
			this.overflow = true;
			handleContentOverflow(contentCacheLimit);
		}
		else {
			cachedContent.write(ch);
		}
	}
	return ch;
}

//重写方法inputStream中的read(byte b[], int off, int len)
@Override
public int read(final byte[] b, final int off, final int len) throws IOException {
	int count = this.is.read(b, off, len);
	writeToCache(b, off, count);
	return count;
}</code></pre> 
<p>总之，ContentCachingRequestWrapper通过覆盖inpuStream方法，通过移花接木的方式，将每次调用inputStream读的时候都将其放置到输出流当中。这样后续input<a href="https://so.csdn.net/so/search?q=Stream%E6%B5%81&amp;spm=1001.2101.3001.7020" title="Stream流">Stream流</a>被关闭了，我们还可以通过使用cachedContent内容读取入参内容。</p> 
<h4>构造返回数据</h4> 
<pre><code class="language-java">private void doResponse(ServletResponse servletResponse) throws IOException{
     servletResponse.setContentType(MediaType.APPLICATION_JSON_UTF8_VALUE);
     HttpServletResponse httpServletResponse = (HttpServletResponse)servletResponse;
     httpServletResponse.setStatus(401);
     PrintWriter writer = servletResponse.getWriter();
     writer.write("xxxxx");
}
    
private void doFileResponse(ServletResponse servletResponse) throws IOException{
    //1. 用于读取文件
    FileInputStream fis = new FileInputStream("d://xxx/xxx/a.jpg");
    //2. 获取response字节输出流
    ServletOutputStream os = servletResponse.getOutputStream();
    //3. 完成流的复制
    byte[] buff = new byte[1024];
    int len = 0;
    while ((len = fis.read(buff))!= -1){
       os.write(buff,0,len);
    }
    fis.close();
}</code></pre> 
<p>读取返回数据：</p> 
<p></p> 
<p>https://www.cnblogs.com/fdzang/p/11812348.html</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6da6364c71716d512d3473b1113b99ce/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">PHP中一些特征函数导致的漏洞总结</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/78b40043002a8b772099540e72e26fb1/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">2024-01-24（ElasticSearch）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>