<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>lsyncd实时同步工具 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="lsyncd实时同步工具" />
<meta property="og:description" content="首先介绍一下架构
有3台app服务器，每次上线，是通过shell脚本将代码传输至app_1
然后app_1自动同步到app_2和app_3
代码路径为/www
有一台code服务器，专门用来下载所有服务器代码的。
路径为/data
最开始的同步策略是rsync&#43;inotify
用了一段时间，发现有时会出现app_2和app_3没有同步代码的问题。
发现是因为inotify的shell脚本，意外终止了。
后来发现有unison，测试发现，还是要写shell脚本
再后来sersync，这个是基于rsync的，需要有rsync客户端和服务端，比较麻烦
配置文件是xml。
最后用的是lsyncd
Lysncd 实际上是lua语言封装了 inotify 和 rsync 工具，采用了 Linux 内核（2.6.13 及以后）里的 inotify 触发机制，然后通过rsync去差异同步，达到实时的效果。
完美解决了 inotify &#43; rsync海量文件同步带来的文件频繁发送文件列表的问题 —— 通过时间延迟或累计触发事件次数实现。
有2种方法可以安装
yum安装，前提是安装了epel更新源。使用命令：yum install -y lsyncd
github下载，地址为：https://github.com/axkibe/lsyncd
我用的是github方式，因为版本是比yum要新一点
软件部署：
app_1,app_2,app_3必须要安装rsync
必须要有/usr/bin/rsync文件
这3台服务器，必须要拥有/usr/bin/rsync文件
这3台服务器，必须要拥有/usr/bin/rsync文件
这3台服务器，必须要拥有/usr/bin/rsync文件
重要的事情说三遍！
app_1必须能无密码登录app_2和app_3
ssh秘钥认证，请自行百度。
app_1只需要安装lsyncd就可以了
3台rsync配置文件，不需要创建，不需要修改
安装lua软件包
yum install -y lua lua-devel
解压下载的压缩包
unzip lsyncd-master.zip -d /usr/src/
进入目录
cd /usr/src/lsyncd-master/
使用cmake编译，如果没有安装cmake,可以yum安装一下
cmake -DCMAKE_INSTALL_PREFIX=/usr/local/lsyncd
make &amp;&amp; make install" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/1bd8862543924fa770667620a800cace/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-11-17T09:16:35+08:00" />
<meta property="article:modified_time" content="2022-11-17T09:16:35+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">lsyncd实时同步工具</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>首先介绍一下架构<br> <img src="https://images2.imgbox.com/78/4c/QrFlwWaP_o.png" alt="在这里插入图片描述"></p> 
<p>有3台app服务器，每次上线，是通过shell脚本将代码传输至app_1</p> 
<p>然后app_1自动同步到app_2和app_3</p> 
<p>代码路径为/www</p> 
<p>有一台code服务器，专门用来下载所有服务器代码的。</p> 
<p>路径为/data</p> 
<p>最开始的同步策略是rsync+inotify</p> 
<p>用了一段时间，发现有时会出现app_2和app_3没有同步代码的问题。</p> 
<p>发现是因为inotify的shell脚本，意外终止了。</p> 
<p>后来发现有unison，测试发现，还是要写shell脚本</p> 
<p>再后来sersync，这个是基于rsync的，需要有rsync客户端和服务端，比较麻烦</p> 
<p>配置文件是xml。</p> 
<p>最后用的是lsyncd</p> 
<p>Lysncd 实际上是lua语言封装了 inotify 和 rsync 工具，采用了 Linux 内核（2.6.13 及以后）里的 inotify 触发机制，然后通过rsync去差异同步，达到实时的效果。</p> 
<p>完美解决了 inotify + rsync海量文件同步带来的文件频繁发送文件列表的问题 —— 通过时间延迟或累计触发事件次数实现。</p> 
<p>有2种方法可以安装</p> 
<p>yum安装，前提是安装了epel更新源。使用命令：yum install -y lsyncd</p> 
<p>github下载，地址为：https://github.com/axkibe/lsyncd</p> 
<p>我用的是github方式，因为版本是比yum要新一点</p> 
<p>软件部署：</p> 
<p>app_1,app_2,app_3必须要安装rsync</p> 
<p>必须要有/usr/bin/rsync文件</p> 
<p>这3台服务器，必须要拥有/usr/bin/rsync文件</p> 
<p>这3台服务器，必须要拥有/usr/bin/rsync文件</p> 
<p>这3台服务器，必须要拥有/usr/bin/rsync文件</p> 
<p>重要的事情说三遍！</p> 
<p>app_1必须能无密码登录app_2和app_3</p> 
<p>ssh秘钥认证，请自行百度。</p> 
<p>app_1只需要安装lsyncd就可以了</p> 
<p>3台rsync配置文件，不需要创建，不需要修改</p> 
<p>安装lua软件包</p> 
<p>yum install -y lua lua-devel</p> 
<p>解压下载的压缩包</p> 
<p>unzip lsyncd-master.zip -d /usr/src/</p> 
<p>进入目录</p> 
<p>cd /usr/src/lsyncd-master/</p> 
<p>使用cmake编译，如果没有安装cmake,可以yum安装一下</p> 
<p>cmake -DCMAKE_INSTALL_PREFIX=/usr/local/lsyncd</p> 
<p>make &amp;&amp; make install</p> 
<p>进入安装目录</p> 
<p>cd /usr/local/lsyncd/</p> 
<p>创建配置文件目录和日志目录</p> 
<p>mkdir etc var</p> 
<p>进入配置文件目录</p> 
<p>cd etc/</p> 
<p>编译配置文件</p> 
<p>vim lsyncd.conf</p> 
<p>内容如下:</p> 
<p>settings {<!-- --></p> 
<p>–pid文件</p> 
<p>logfile = “/usr/local/lsyncd/var/lsyncd.log”,</p> 
<p>–状态文件</p> 
<p>statusFile = “/usr/local/lsyncd/var/lsyncd.status”,</p> 
<p>–同步模式，意思就是有更新就同步</p> 
<p>inotifyMode = “CloseWrite or Modify”,</p> 
<p>–最大8个进程</p> 
<pre><code>maxProcesses = 8,
</code></pre> 
<p>}</p> 
<p>–需要同步服务器的IP地址池</p> 
<p>servers = {<!-- --></p> 
<p>“192.168.74.128”,</p> 
<p>“192.168.74.129”,</p> 
<p>}</p> 
<p>–使用for循环遍历IP池</p> 
<p>for _, server in ipairs(servers) do</p> 
<p>sync {<!-- --></p> 
<p>–本地目录间同步，使用rsync</p> 
<p>default.rsync,</p> 
<p>–同步的源目录，使用绝对路径</p> 
<p>source = “/www/dts”,</p> 
<p>–定义目的地址,注意:冒号后面是绝对路径</p> 
<p>target = server…“:/www/dts”,</p> 
<p>–累计事件，等待rsync同步延时时间。这里设置0秒，表示实时同步。</p> 
<p>delay = 0,</p> 
<p>rsync ={<!-- --></p> 
<p>–rsync命令的绝对路径</p> 
<p>binary =“/usr/bin/rsync”,</p> 
<p>archive =true,</p> 
<p>compress =true,</p> 
<p>verbose = true,</p> 
<p>–使用ssh协议连接到目标服务器，如果端口不是22，请修改一下。</p> 
<p>rsh = “/usr/bin/ssh -p 22 -o StrictHostKeyChecking=no”</p> 
<p>},</p> 
<p>}</p> 
<p>end</p> 
<p>–因为有一台服务器，是供下载代码的。路径跟for循环里面的不一样，所以单独列出来。</p> 
<p>sync {<!-- --></p> 
<p>default.rsync,</p> 
<p>source = “/www/dts”,</p> 
<p>–定义目的地址，这里和上面的不一样。因为IP就一个，所以就直接写了。</p> 
<p>target = “192.168.74.130:/data/dts”,</p> 
<p>delay = 0,</p> 
<p>rsync ={<!-- --></p> 
<p>binary =“/usr/bin/rsync”,</p> 
<p>archive =true,</p> 
<p>compress =true,</p> 
<p>verbose = true,</p> 
<p>rsh = “/usr/bin/ssh -p 22 -o StrictHostKeyChecking=no”</p> 
<p>},</p> 
<p>}</p> 
<p>启动服务</p> 
<p>/usr/local/lsyncd/bin/lsyncd /usr/local/lsyncd/etc/lsyncd.conf</p> 
<p>查看进程是否存在</p> 
<p>ps -aux | grep lsyncd</p> 
<p>如果不存在进程，请查看/usr/local/lsyncd/var/lsyncd.log</p> 
<p>如果正常的话，请测试配置文件里面出现的每一个IP</p> 
<p>用ssh连接，是否成功。注意，是不需要输入密码的！！！</p> 
<p>ssh -p 端口 root@ip地址</p> 
<p>编译启动脚本</p> 
<p>vim /etc/init.d/lsyncd</p> 
<p>#!/bin/bash</p> 
<h2><a id="_224"></a></h2> 
<h2><a id="chkconfig__85_15_226"></a>chkconfig: - 85 15</h2> 
<h2><a id="description_Lightweight_inotify_based_sync_daemon_228"></a>description: Lightweight inotify based sync daemon</h2> 
<h2><a id="_230"></a></h2> 
<h2><a id="processname__lsyncd_232"></a>processname: lsyncd</h2> 
<h2><a id="config_______usrlocallsyncdetclsyncdconf_234"></a>config: /usr/local/lsyncd/etc/lsyncd.conf</h2> 
<h2><a id="config_______etcsysconfiglsyncd_236"></a>config: /etc/sysconfig/lsyncd</h2> 
<h2><a id="pidfile______varrunlsyncdpid_238"></a>pidfile: /var/run/lsyncd.pid</h2> 
<h2><a id="Source_function_library_240"></a>Source function library</h2> 
<p>. /etc/init.d/functions</p> 
<h2><a id="Source_networking_configuration_244"></a>Source networking configuration.</h2> 
<p>. /etc/sysconfig/network</p> 
<h2><a id="Check_that_networking_is_up_248"></a>Check that networking is up.</h2> 
<p>[ “$NETWORKING” = “no” ] &amp;&amp; exit 0</p> 
<p>LSYNCD_OPTIONS=“-pidfile /var/run/lsyncd.pid /usr/local/lsyncd/etc/lsyncd.conf”</p> 
<p>if [ -e /etc/sysconfig/lsyncd ]; then</p> 
<p>. /etc/sysconfig/lsyncd</p> 
<p>fi</p> 
<p>RETVAL=0</p> 
<p>prog=“lsyncd”</p> 
<p>thelock=/var/lock/subsys/lsyncd</p> 
<p>start() {<!-- --></p> 
<p>[ -f /usr/local/lsyncd/etc/lsyncd.conf ] || exit 6</p> 
<pre><code>    echo -n $"Starting $prog: "

    if [ $UID -ne 0 ]; then

            RETVAL=1

            failure

    else

            daemon ${LSYNCD_USER:+--user ${LSYNCD_USER}} /usr/local/lsyncd/bin/lsyncd $LSYNCD_OPTIONS

            RETVAL=$?

            [ $RETVAL -eq 0 ] &amp;&amp; touch $thelock

    fi;

    echo

    return $RETVAL
</code></pre> 
<p>}</p> 
<p>stop() {<!-- --></p> 
<pre><code>    echo -n $"Stopping $prog: "

    if [ $UID -ne 0 ]; then

            RETVAL=1

            failure

    else
</code></pre> 
<p>killproc lsyncd</p> 
<pre><code>            RETVAL=$?

            [ $RETVAL -eq 0 ] &amp;&amp; rm -f $thelock

    fi;

    echo

    return $RETVAL
</code></pre> 
<p>}</p> 
<p>reload(){<!-- --></p> 
<pre><code>    echo -n $"Reloading $prog: "

    killproc lsyncd -HUP

    RETVAL=$?

  echo

    return $RETVAL
</code></pre> 
<p>}</p> 
<p>restart(){<!-- --></p> 
<pre><code>    stop

    start
</code></pre> 
<p>}</p> 
<p>condrestart(){<!-- --></p> 
<pre><code>[ -e $thelock ] &amp;&amp; restart

return 0
</code></pre> 
<p>}</p> 
<p>case “$1” in</p> 
<p>start)</p> 
<p>start</p> 
<pre><code>    ;;
</code></pre> 
<p>stop)</p> 
<pre><code>    stop

    ;;
</code></pre> 
<p>restart)</p> 
<pre><code>    restart

    ;;
</code></pre> 
<p>reload)</p> 
<pre><code>    reload

    ;;
</code></pre> 
<p>condrestart)</p> 
<pre><code>    condrestart

    ;;
</code></pre> 
<p>status)</p> 
<pre><code>    status lsyncd

    RETVAL=$?

 ;;
</code></pre> 
<p>*)</p> 
<pre><code>    echo $"Usage: $0 {start|stop|status|restart|condrestart|reload}"

    RETVAL=1
</code></pre> 
<p>esac</p> 
<p>exit $RETVAL</p> 
<p>设置权限</p> 
<p>chmod 755 /etc/init.d/lsyncd</p> 
<p>添加到开机自启动文件中</p> 
<p>echo “/etc/init.d/lsyncd start” &gt;&gt; /etc/rc.local</p> 
<p>测试编辑app_1的文件，在其他服务器查看文件是否有更新。</p> 
<p>cd /www/dts</p> 
<p>touch 1.txt</p> 
<p>备注:</p> 
<p>如果只是一对一的同步</p> 
<p>配置文件可以简化一点</p> 
<p>settings {<!-- --></p> 
<p>–pid文件</p> 
<p>logfile = “/usr/local/lsyncd/var/lsyncd.log”,</p> 
<p>–状态文件</p> 
<p>statusFile = “/usr/local/lsyncd/var/lsyncd.status”,</p> 
<p>–同步模式，意思就是有更新就同步</p> 
<p>inotifyMode = “CloseWrite or Modify”,</p> 
<p>–最大8个进程</p> 
<pre><code>maxProcesses = 8,
</code></pre> 
<p>}</p> 
<p>sync {<!-- --></p> 
<p>default.rsync,</p> 
<p>source = “/www/dts”,</p> 
<p>–定义目的地址</p> 
<p>target = “192.168.74.130:/data/dts”,</p> 
<p>delay = 0,</p> 
<p>rsync ={<!-- --></p> 
<p>binary =“/usr/bin/rsync”,</p> 
<p>archive =true,</p> 
<p>compress =true,</p> 
<p>verbose = true,</p> 
<p>rsh = “/usr/bin/ssh -p 22 -o StrictHostKeyChecking=no”</p> 
<p>},</p> 
<p>}</p> 
<p>如果遇到不同步的情况：</p> 
<p>1.检查几台服务器是否存在文件/usr/bin/rsync</p> 
<p>2.检查source和target文件目录是否存在</p> 
<p>3.检查iptables和selinux是否关闭</p> 
<p>4.检查几台服务器之间是否做了秘钥认证，能够无密码ssh登录</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/da37164da652bb0c4dfe047afa29deaa/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Linux 压缩、解压缩和文件切割的学习笔记</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9df81aad25fd5434809dfd28fb56853b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">如何将视频的每一帧提取成图片</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>