<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>＜数据结构＞ - 数据结构在算法比赛中的应用（上） - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="＜数据结构＞ - 数据结构在算法比赛中的应用（上）" />
<meta property="og:description" content="目录
单链表
双链表
单调栈
单调队列&amp;滑动窗口
KMP字符串
单链表
思路：
工程链表：
typedef struct SListNode { int data; // val struct SListNode* next; // 存储下一个节点的地址 }SLN; 算法表示法： head 表示头结点的下标，数组e[]表示链表 date值，ne[]表示存储下一个节点的地址的指针next，idx 存储当前已经用到了哪个点
#include &lt;iostream&gt; using namespace std; const int N = 100010; // head 表示头结点的指针 // e[i] 表示节点i的值 // ne[i] 表示节点i的next指针是多少 // idx 存储当前已经用到了哪个点,工程链表中的新地址 int head, e[N], ne[N], idx; // 初始化 void init() { head = -1; //-1表示指向空 idx = 0; //下标索引从0开始 } // 将x插到头结点 void add_to_head(int x) { e[idx] = x, ne[idx] = head, head = idx &#43;&#43; ; } // 将x插到下标是k的点后面 void add(int k, int x) { e[idx] = x, ne[idx] = ne[k], ne[k] = idx &#43;&#43; ; } // 将下标是k的点后面的点删掉 void remove(int k) { ne[k] = ne[ne[k]]; //让结点直接指向下一个结点的next，不用管内存泄漏 } int main() { int m; cin &gt;&gt; m; init(); while (m -- ) { int k, x; char op; cin &gt;&gt; op; if (op == &#39;H&#39;) { cin &gt;&gt; x; add_to_head(x); } else if (op == &#39;D&#39;) { cin &gt;&gt; k; if (!" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/3454967dca672bc77caae35627b2daa4/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-09-03T00:01:36+08:00" />
<meta property="article:modified_time" content="2022-09-03T00:01:36+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">＜数据结构＞ - 数据结构在算法比赛中的应用（上）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p></p> 
<p id="%E5%8D%95%E9%93%BE%E8%A1%A8-toc" style="margin-left:0px;"><a href="#%E5%8D%95%E9%93%BE%E8%A1%A8" rel="nofollow">单链表</a></p> 
<p id="%E5%8F%8C%E9%93%BE%E8%A1%A8-toc" style="margin-left:0px;"><a href="#%E5%8F%8C%E9%93%BE%E8%A1%A8" rel="nofollow">双链表</a></p> 
<p id="%E5%8D%95%E8%B0%83%E6%A0%88-toc" style="margin-left:0px;"><a href="#%E5%8D%95%E8%B0%83%E6%A0%88" rel="nofollow">单调栈</a></p> 
<p id="%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%26%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3-toc" style="margin-left:0px;"><a href="#%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%26%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3" rel="nofollow">单调队列&amp;滑动窗口</a></p> 
<p id="KMP%E5%AD%97%E7%AC%A6%E4%B8%B2-toc" style="margin-left:40px;"><a href="#KMP%E5%AD%97%E7%AC%A6%E4%B8%B2" rel="nofollow">KMP字符串</a></p> 
<hr id="hr-toc"> 
<p></p> 
<p></p> 
<h2 id="%E5%8D%95%E9%93%BE%E8%A1%A8">单链表<br>  </h2> 
<p><img alt="" height="1063" src="https://images2.imgbox.com/c5/fe/gXfUnQ5q_o.png" width="979"></p> 
<p>思路：</p> 
<p>工程链表：</p> 
<pre><code class="language-cpp">
typedef struct SListNode
{
	int data; // val
	struct SListNode* next; // 存储下一个节点的地址
}SLN;</code></pre> 
<p> 算法表示法： </p> 
<p>head 表示头结点的下标，数组e[]表示链表 date值，ne[]表示存储下一个节点的地址的指针next，idx 存储当前已经用到了哪个点</p> 
<p><img alt="" height="656" src="https://images2.imgbox.com/08/bc/PwEAz2Vv_o.png" width="1200"></p> 
<p><img alt="" height="222" src="https://images2.imgbox.com/7c/49/56ptmkFV_o.png" width="291"></p> 
<p></p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;

using namespace std;

const int N = 100010;


// head 表示头结点的指针
// e[i] 表示节点i的值
// ne[i] 表示节点i的next指针是多少
// idx 存储当前已经用到了哪个点,工程链表中的新地址
int head, e[N], ne[N], idx;

// 初始化
void init()
{
    head = -1;  //-1表示指向空
    idx = 0;    //下标索引从0开始
}

// 将x插到头结点
void add_to_head(int x)
{
    e[idx] = x, ne[idx] = head, head = idx ++ ;
}

// 将x插到下标是k的点后面
void add(int k, int x)
{
    e[idx] = x, ne[idx] = ne[k], ne[k] = idx ++ ;
}

// 将下标是k的点后面的点删掉
void remove(int k)
{
    ne[k] = ne[ne[k]];    //让结点直接指向下一个结点的next，不用管内存泄漏
}

int main()
{
    int m;
    cin &gt;&gt; m;

    init();

    while (m -- )
    {
        int k, x;
        char op;

        cin &gt;&gt; op;
        if (op == 'H')
        {
            cin &gt;&gt; x;
            add_to_head(x);
        }
        else if (op == 'D')
        {
            cin &gt;&gt; k;
            if (!k) head = ne[head];    //如果k为0，删除头结点，ne[head]必指向空
            else remove(k - 1);    //k-1对应从0开始的idx
        }
        else
        {
            cin &gt;&gt; k &gt;&gt; x;
            add(k - 1, x);
        }
    }

    for (int i = head; i != -1; i = ne[i]) cout &lt;&lt; e[i] &lt;&lt; ' ';
    cout &lt;&lt; endl;

    return 0;
}
</code></pre> 
<p></p> 
<p></p> 
<h2 id="%E5%8F%8C%E9%93%BE%E8%A1%A8">双链表</h2> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/c4/82/FNAGtAxK_o.png" width="1200"></p> 
<p> 思路：</p> 
<blockquote> 
 <p>与单链表类似，e[N]存值，l[N]、r[N]表示左右指针</p> 
 <p></p> 
 <p>双链表初始化：</p> 
 <p>0号店表示头结点，1号表示尾节点</p> 
 <p><img alt="" height="218" src="https://images2.imgbox.com/99/5b/S5cTyBJC_o.png" width="410"></p> 
 <pre><code class="language-cpp">    r[0] = 1, l[1] = 0;
    idx = 2;</code></pre> 
 <p></p> 
 <p>删除节点a的remove（）函数<img alt="" height="585" src="https://images2.imgbox.com/62/69/I66l9UNh_o.png" width="1200"></p> 
 <pre><code class="language-cpp">void remove(int a)
{
    l[r[a]] = l[a];
    r[l[a]] = r[a];
}
</code></pre> 
 <p></p> 
 <p></p> 
 <p> 在节点k的右边插入一个数x方法</p> 
 <p></p> 
 <p>第一步：开一个新节点，左右指针指向k，与k的下一个节点<img alt="" height="379" src="https://images2.imgbox.com/ce/ee/AvIhjmsB_o.png" width="1145"></p> 
 <p>第二步：先让k的下一个节点的左指针指向新点，再用k的右指针指向新点；顺序搞错会导致数据覆盖 </p> 
 <p><img alt="" height="399" src="https://images2.imgbox.com/7b/fd/0CgnTd31_o.png" width="1200"></p> 
 <pre><code class="language-cpp">void insert(int a, int x)
{
    e[idx] = x;
    l[idx] = a, r[idx] = r[a];
    l[r[a]] = idx, r[a] = idx ++ ;
}</code></pre> 
 <p></p> 
</blockquote> 
<pre><code class="language-cpp">#include &lt;iostream&gt;

using namespace std;

const int N = 100010;

int m;
int e[N], l[N], r[N], idx;

// 在节点a的右边插入一个数x
void insert(int a, int x)
{
    e[idx] = x;
    l[idx] = a, r[idx] = r[a];
    l[r[a]] = idx, r[a] = idx ++ ;
}

// 删除节点a
void remove(int a)
{
    l[r[a]] = l[a];
    r[l[a]] = r[a];
}

int main()
{
    cin &gt;&gt; m;

    // 0是左端点，1是右端点
    r[0] = 1, l[1] = 0;
    idx = 2;

    while (m -- )
    {
        string op;
        cin &gt;&gt; op;
        int k, x;
        if (op == "L")
        {
            cin &gt;&gt; x;
            insert(0, x);
        }
        else if (op == "R")
        {
            cin &gt;&gt; x;
            insert(l[1], x);
        }
        else if (op == "D")
        {
            cin &gt;&gt; k;
            remove(k + 1);  //idx从2开始，插入节点夹在head与tail之间
        }
        else if (op == "IL")
        {
            cin &gt;&gt; k &gt;&gt; x;
            insert(l[k + 1], x);
        }
        else
        {
            cin &gt;&gt; k &gt;&gt; x;
            insert(k + 1, x);
        }
    }

    for (int i = r[0]; i != 1; i = r[i]) cout &lt;&lt; e[i] &lt;&lt; ' ';
    cout &lt;&lt; endl;

    return 0;
}

</code></pre> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<h2 id="%E5%8D%95%E8%B0%83%E6%A0%88">单调栈</h2> 
<p><img alt="" height="755" src="https://images2.imgbox.com/25/ed/QANTVyAr_o.png" width="1147"></p> 
<p></p> 
<p><img alt="在这里插入图片描述" src="https://images2.imgbox.com/bd/b4/kXNPNTFC_o.gif"></p> 
<p></p> 
<p>cin，cout速度大幅提高方法： </p> 
<pre><code class="language-cpp">cin.tie(0);
ios::sync_with_stdio(false);</code></pre> 
<pre><code class="language-cpp">#include &lt;iostream&gt;

using namespace std;

const int N = 100010;

int stk[N], tt;

int main()
{
    //cin.tie(0);
   // ios::sync_with_stdio(false);
    int n;
    cin &gt;&gt; n;
    while (n -- )
    {
        int x;
        cin&gt;&gt;x;
        while (tt &amp;&amp; stk[tt] &gt;= x) tt -- ;  //不符合，出栈
        if (!tt) cout&lt;&lt;"-1"&lt;&lt;" ";
        else cout&lt;&lt;stk[tt]&lt;&lt;" ";
        
        stk[ ++ tt] = x;    //当前值入栈，与下一个数比较
    }

    return 0;
}

</code></pre> 
<p></p> 
<p></p> 
<p></p> 
<h2 id="%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%26%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3">单调队列&amp;滑动窗口</h2> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/89/fd/E6a22uMk_o.png" width="1127"></p> 
<p>思路：</p> 
<blockquote> 
 <ul><li>利用双端队列思想</li><li>设 队列q[hh],q[tt]分别表示窗口左边界（队头）与右边界（队尾），存储下标</li><li>用 i 表示窗口进程，则窗口范围【i-k+1,i】</li></ul> 
 <p></p> 
 <p>（先求最小值）根据滑动窗口性质，队头的数会先消失，如果队尾插入的值比前一个数小，则前数不是最小值，所以直到出窗口也不会被输出</p> 
 <p>核心操作：<strong>如果队尾插入的值比前一个数小，那么将前一个数移出队列，最终队列会形成单调递增</strong>，取最小值永远在q[hh]处取</p> 
 <p><img alt="" height="354" src="https://images2.imgbox.com/01/e7/DoOskX4G_o.png" width="746"></p> 
 <p></p> 
</blockquote> 
<pre><code class="language-cpp">#include &lt;iostream&gt;

using namespace std;

const int N = 1000010;

int a[N], q[N];

int main()
{
    int n, k;
    scanf("%d%d", &amp;n, &amp;k);
    for (int i = 0; i &lt; n; i ++ ) scanf("%d", &amp;a[i]);

    int hh = 0, tt = -1;    //分别表示窗口左边界与右边界
    for (int i = 0; i &lt; n; i ++ )
    {
        if (hh &lt;= tt &amp;&amp; i - k + 1 &gt; q[hh]) hh ++ ;  //队首出窗口，hh++

        while (hh &lt;= tt &amp;&amp; a[q[tt]] &gt;= a[i]) tt -- ;    //队列不满足单调，tt--将元素移出
        q[ ++ tt] = i;      //将新元素下标入队尾

        if (i &gt;= k - 1) printf("%d ", a[q[hh]]);    //满足遍历个数大于窗口k值，输出队头
    }

    puts("");

    hh = 0, tt = -1;
    for (int i = 0; i &lt; n; i ++ )
    {
        if (hh &lt;= tt &amp;&amp; i - k + 1 &gt; q[hh]) hh ++ ;

        while (hh &lt;= tt &amp;&amp; a[q[tt]] &lt;= a[i]) tt -- ;    //对于最大值，直接改为单调递减即可
        q[ ++ tt] = i;

        if (i &gt;= k - 1) printf("%d ", a[q[hh]]);
    }

    puts("");

    return 0;
}

</code></pre> 
<p></p> 
<p></p> 
<p></p> 
<h3 id="KMP%E5%AD%97%E7%AC%A6%E4%B8%B2">KMP字符串</h3> 
<p><img alt="" height="959" src="https://images2.imgbox.com/e9/1f/kUgGOnz2_o.png" width="943"></p> 
<p>一个人能走的多远不在于他在顺境时能走的多快，而在于他在逆境时多久能找到曾经的自己。<br>                                                                                                                                       ------- KMP</p> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;

const int N=100010,M=1000010;

int n,m;
int ne[N];
char s[M],p[N];

int main()
{
    cin&gt;&gt;n&gt;&gt;p+1&gt;&gt;m&gt;&gt;s+1;
    
    for(int i=2,j=0;i&lt;=n;i++)   //构造next数组
    {
        while(j&amp;&amp;p[i]!=p[j+1]) j=ne[j];
        if(p[i]==p[j+1]) j++;
        ne[i]=j;
    }
    
    for(int i=1,j=0;i&lt;=m;i++)
    {
        while(j&amp;&amp;s[i]!=p[j+1]) j=ne[j];
        if(s[i]==p[j+1]) j++;
        if(j==n)
        {
            printf("%d ",i-n);
            //j=ne[j];  找到后直接跳过j段
        }
    }
    return 0;
}</code></pre> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/196c22f3e8d32c774de2bbcce6cee6c4/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【mysql基础系列十一】用户权限管理</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/80e433e1e1936541510473dc10d55ae8/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">记录一下 springboot 整合 SecurityConfig后, 前端访问后端跨域的坑</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>