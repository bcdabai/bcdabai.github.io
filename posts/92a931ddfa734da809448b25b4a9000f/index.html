<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>时间序列预测之--ARIMA实战 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="时间序列预测之--ARIMA实战" />
<meta property="og:description" content="导读 本文主要分为四个部分：
用pandas处理时序数据
怎样检查时序数据的稳定性
怎样让时序数据具有稳定性
时序数据的预测
用pandas导入和处理时序数据 第一步：导入常用的库
import pandas as pd import numpy as np import matplotlib.pylab as plt from matplotlib.pylab import rcParams #rcParams设定好画布的大小 rcParams[&#39;figure.figsize&#39;] = 15, 6 第二步：导入时序数据
数据文件可在github：
http://github.com/aarshayj/Analytics_Vidhya/tree/master/Articles/Time_Series_Analysis 中下载
#导入数据 data = pd.read_csv(&#34;../testdata/AirPassengers.csv&#34;) print (data.head()) print (&#39;\n Data types:&#39;) print (data.dtypes) 运行结果如下：数据包括每个月对应的passenger的数目。
可以看到data已经是一个DataFrame，包含两列Month和#Passengers，其中Month的类型是object，而index是0,1,2…
第三步：处理时序数据
我们需要将Month的类型变为datetime，同时作为index。
#处理时序数据 #我们需要将Month的类型变为datetime，同时作为index dateparse = lambda dates: pd.datetime.strptime(dates, &#39;%Y-%m&#39;) #---其中parse_dates 表明选择数据中的哪个column作为date-time信息， #---index_col 告诉pandas以哪个column作为 index #--- date_parser 使用一个function(本文用lambda表达式代替)，使一个string转换为一个datetime变量 data = pd.read_csv(&#39;../testdata/AirPassengers.csv&#39;, parse_dates=[&#39;Month&#39;], index_col=&#39;Month&#39;,date_parser=dateparse) print (data." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/92a931ddfa734da809448b25b4a9000f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-09-08T20:31:53+08:00" />
<meta property="article:modified_time" content="2020-09-08T20:31:53+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">时间序列预测之--ARIMA实战</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="_0"></a>导读</h2> 
<p>本文主要分为四个部分：<br> 用pandas处理时序数据<br> 怎样检查时序数据的稳定性<br> 怎样让时序数据具有稳定性<br> 时序数据的预测</p> 
<h3><a id="pandas_6"></a>用pandas导入和处理时序数据</h3> 
<p>第一步：导入常用的库</p> 
<pre><code>import pandas as pd
import numpy as np
import matplotlib.pylab as plt
from matplotlib.pylab import rcParams
#rcParams设定好画布的大小
rcParams['figure.figsize'] = 15, 6
</code></pre> 
<p>第二步：导入时序数据<br> 数据文件可在github：<br> http://github.com/aarshayj/Analytics_Vidhya/tree/master/Articles/Time_Series_Analysis 中下载</p> 
<pre><code>#导入数据
data = pd.read_csv("../testdata/AirPassengers.csv")
print (data.head())
print ('\n Data types:')
print (data.dtypes)
</code></pre> 
<p>运行结果如下：数据包括每个月对应的passenger的数目。<br> 可以看到data已经是一个DataFrame，包含两列Month和#Passengers，其中Month的类型是object，而index是0,1,2…<br> <img src="https://images2.imgbox.com/47/f2/6Qvqal1T_o.png" alt="filelist"><br> 第三步：处理时序数据<br> 我们需要将Month的类型变为datetime，同时作为index。</p> 
<pre><code>#处理时序数据
#我们需要将Month的类型变为datetime，同时作为index
dateparse = lambda dates: pd.datetime.strptime(dates, '%Y-%m')
#---其中parse_dates 表明选择数据中的哪个column作为date-time信息，
#---index_col 告诉pandas以哪个column作为 index
#--- date_parser 使用一个function(本文用lambda表达式代替)，使一个string转换为一个datetime变量
data = pd.read_csv('../testdata/AirPassengers.csv', parse_dates=['Month'], index_col='Month',date_parser=dateparse)
print (data.head())
print (data.index)
</code></pre> 
<p>结果如下：可以看到data的index已经变成datetime类型的Month了。<br> <img src="https://images2.imgbox.com/6e/57/Mu4V51RN_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="Stationarity_46"></a>怎样检查时序数据的稳定性(Stationarity)</h3> 
<p>因为ARIMA模型要求数据是稳定的，所以这一步至关重要。<br> <strong>1. 判断数据是稳定的常基于对于时间是常量的几个统计量：</strong><br> 常量的均值<br> 常量的方差<br> 与时间独立的自协方差<br> 用图像说明如下：<br> 均值<br> <img src="https://images2.imgbox.com/46/95/cKJJpZSd_o.png" alt="filelist"><br> X是时序数据的值，t是时间。可以看到左图，数据的均值对于时间轴来说是常量，即数据的均值不是时间的函数,所有它是稳定的；右图随着时间的推移，数据的值整体趋势是增加的，所有均值是时间的函数，数据具有趋势，所以是非稳定的。<br> 方差<br> <img src="https://images2.imgbox.com/70/32/PuZhMeZy_o.png" alt="filelist"><br> 可以看到左图，数据的方差对于时间是常量，即数据的值域围绕着均值上下波动的振幅是固定的，所以左图数据是稳定的。而右图，数据的振幅在不同时间点不同，所以方差对于时间不是独立的，数据是非稳定的。但是左、右图的均值是一致的。<br> 自协方差<br> <img src="https://images2.imgbox.com/83/ad/YKnhGh5T_o.png" alt="filelist"><br> 一个时序数据的自协方差，就是它在不同两个时刻i,j的值的协方差。可以看到左图的自协方差于时间无关；而右图，随着时间的不同，数据的波动频率明显不同，导致它i，j取值不同，就会得到不同的协方差，因此是非稳定的。虽然右图在均值和方差上都是与时间无关的，但仍是非稳定数据。<br> <strong>2. python判断时序数据稳定性</strong><br> 有两种方法：<br> 1.Rolling statistic-- 即每个时间段内的平均的数据均值和标准差情况。<br> 2. Dickey-Fuller Test – 这个比较复杂，大致意思就是在一定置信水平下，对于时序数据假设 Null hypothesis: 非稳定。<br> if 通过检验值(statistic)&lt; 临界值(critical value)，则拒绝null hypothesis，即数据是稳定的；反之则是非稳定的。</p> 
<pre><code># python判断时序数据稳定性
#ARIMA模型要求数据是稳定的，所以这一步至关重要
# 有两种方法：
# 1.Rolling statistic-- 即每个时间段内的平均的数据均值和标准差情况。
# 2. Dickey-Fuller Test -- 这个比较复杂，大致意思就是在一定置信水平下，对于时序数据假设 Null hypothesis: 非稳定。
# if 通过检验值(statistic)&lt; 临界值(critical value)，则拒绝null hypothesis，即数据是稳定的；反之则是非稳定的。
from statsmodels.tsa.stattools import adfuller
def test_stationarity(timeseries):
    # 这里以一年为一个窗口，每一个时间t的值由它前面12个月（包括自己）的均值代替，标准差同理。
    rolmean = timeseries.rolling(12).mean()
    rolstd = timeseries.rolling(12).std()

    # plot rolling statistics:
    fig = plt.figure()
    fig.add_subplot()
    orig = plt.plot(timeseries, color='blue', label='Original')
    mean = plt.plot(rolmean, color='red', label='rolling mean')
    std = plt.plot(rolstd, color='black', label='Rolling standard deviation')

    plt.legend(loc='best')
    plt.title('Rolling Mean &amp; Standard Deviation')
    plt.show(block=False)

    # Dickey-Fuller test:

    print ('Results of Dickey-Fuller Test:')
    dftest = adfuller(timeseries, autolag='AIC')
    # dftest的输出前一项依次为检测值，p值，滞后数，使用的观测数，各个置信度下的临界值
    dfoutput = pd.Series(dftest[0:4], index=['Test Statistic', 'p-value', '#Lags Used', 'Number of Observations Used'])
    for key, value in dftest[4].items():
        dfoutput['Critical value (%s)' % key] = value

    print (dfoutput)
ts = data['Passengers']
test_stationarity(ts)
</code></pre> 
<p>结果如下：<br> <img src="https://images2.imgbox.com/7e/2c/m9lYnvr6_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/7d/7b/rarBqU8N_o.png" alt="在这里插入图片描述"><br> 可以看到，数据的rolling均值/标准差具有越来越大的趋势，是不稳定的。<br> 且DF-test可以明确的指出，在任何置信度下，数据都不是稳定的。</p> 
<p><strong>3. 让时序数据变成稳定的方法</strong><br> 让数据变得不稳定的原因主要有俩：</p> 
<p>趋势（trend）-数据随着时间变化。比如说升高或者降低。<br> 季节性(seasonality)-数据在特定的时间段内变动。比如说节假日，或者活动导致数据的异常。<br> 由于原数据值域范围比较大，为了缩小值域，同时保留其他信息，常用的方法是对数化，取log。</p> 
<pre><code>ts_log = np.log(ts)
</code></pre> 
<p>检测和去除趋势<br> 通常有三种方法：<br> 聚合 : 将时间轴缩短，以一段时间内星期/月/年的均值作为数据值。使不同时间段内的值差距缩小。<br> 平滑： 以一个滑动窗口内的均值代替原来的值，为了使值之间的差距缩小<br> 多项式过滤：用一个回归模型来拟合现有数据，使得数据更平滑。<br> 本文主要使用平滑方法<br> Moving Average–移动平均</p> 
<pre><code>#平滑方法
#Moving Average--移动平均
moving_avg = ts_log.rolling(12).mean()
plt.plot(ts_log ,color = 'blue')
plt.plot(moving_avg, color='red')
plt.show()
</code></pre> 
<p><img src="https://images2.imgbox.com/d8/d6/yZeYe7Gu_o.png" alt="在这里插入图片描述"><br> 可以看出moving_average要比原值平滑许多。<br> 然后作差：</p> 
<pre><code>ts_log_moving_avg_diff = ts_log-moving_avg
ts_log_moving_avg_diff.dropna(inplace = True)
test_stationarity(ts_log_moving_avg_diff)
</code></pre> 
<p><img src="https://images2.imgbox.com/4e/18/7IZEoVAv_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/02/6b/mTKyrywS_o.png" alt="在这里插入图片描述"><br> 可以看到，做了处理之后的数据基本上没有了随时间变化的趋势，DFtest的结果告诉我们在95%的置信度下，数据是稳定的。</p> 
<p>上面的方法是将所有的时间平等看待，而在许多情况下，可以认为越近的时刻越重要。所以引入指数加权移动平均-- Exponentially-weighted moving average.（pandas中通过ewm()函数提供了此功能。）</p> 
<pre><code># halflife的值决定了衰减因子alpha：  alpha = 1 - exp(log(0.5) / halflife)
expweighted_avg = pd.DataFrame.ewm(ts_log,halflife=12).mean()
ts_log_ewma_diff = ts_log - expweighted_avg
test_stationarity(ts_log_ewma_diff)
</code></pre> 
<p><img src="https://images2.imgbox.com/2c/73/K7f1JNT6_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/4e/a0/MS0VI6Lm_o.png" alt="在这里插入图片描述"></p> 
<p>可以看到相比普通的Moving Average，新的数据平均标准差更小了。而且DFtest可以得到结论：数据在99%的置信度上是稳定的。</p> 
<p>检测和去除季节性<br> 有两种方法：<br> 1 差分化： 以特定滞后数目的时刻的值的作差<br> 2 分解： 对趋势和季节性分别建模在移除它们<br> Differencing–差分</p> 
<pre><code>ts_log_diff = ts_log - ts_log.shift()
ts_log_diff.dropna(inplace=True)
test_stationarity(ts_log_diff)
</code></pre> 
<p><img src="https://images2.imgbox.com/bc/a0/2tZTeik4_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/a6/b2/zuaBlact_o.png" alt="在这里插入图片描述"><br> 如图，可以看出相比MA方法，Differencing方法处理后的数据的均值和方差的在时间轴上的振幅明显缩小了。DFtest的结论是在90%的置信度下，数据是稳定的。</p> 
<p>3.Decomposing-分解</p> 
<pre><code>#分解(decomposing) 可以用来把时序数据中的趋势和周期性数据都分离出来:
from statsmodels.tsa.seasonal import seasonal_decompose
def decompose(timeseries):
    
    # 返回包含三个部分 trend（趋势部分） ， seasonal（季节性部分） 和residual (残留部分)
    decomposition = seasonal_decompose(timeseries)
    
    trend = decomposition.trend
    seasonal = decomposition.seasonal
    residual = decomposition.resid
    
    plt.subplot(411)
    plt.plot(ts_log, label='Original')
    plt.legend(loc='best')
    plt.subplot(412)
    plt.plot(trend, label='Trend')
    plt.legend(loc='best')
    plt.subplot(413)
    plt.plot(seasonal,label='Seasonality')
    plt.legend(loc='best')
    plt.subplot(414)
    plt.plot(residual, label='Residuals')
    plt.legend(loc='best')
    plt.tight_layout()
    
    return trend , seasonal, residual
</code></pre> 
<p><img src="https://images2.imgbox.com/2c/0d/JSed9byY_o.png" alt="在这里插入图片描述"></p> 
<p>如图可以明显的看到，将original数据 拆分成了三份。Trend数据具有明显的趋势性，Seasonality数据具有明显的周期性，Residuals是剩余的部分，可以认为是去除了趋势和季节性数据之后，稳定的数据，是我们所需要的。</p> 
<pre><code>#消除了trend 和seasonal之后，只对residual部分作为想要的时序数据进行处理
trend , seasonal, residual = decompose(ts_log)
residual.dropna(inplace=True)
test_stationarity(residual)
</code></pre> 
<p><img src="https://images2.imgbox.com/71/c0/vxupNPEz_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/29/1d/yvPGZdUs_o.png" alt="在这里插入图片描述"></p> 
<p>如图所示，数据的均值和方差趋于常数，几乎无波动(看上去比之前的陡峭，但是要注意他的值域只有[-0.05,0.05]之间)，所以直观上可以认为是稳定的数据。另外DFtest的结果显示，Statistic值原小于1%时的Critical value，所以在99%的置信度下，数据是稳定的。</p> 
<p><strong>4. 对时序数据进行预测</strong><br> 假设经过处理，已经得到了稳定时序数据。接下来，我们使用ARIMA模型<br> 对数据已经预测。<a href="https://blog.csdn.net/qq_30868737/article/details/108471991">ARIMA的介绍可以见另一篇文章</a>。</p> 
<p>step1： 通过ACF,PACF进行ARIMA（p，d，q）的p，q参数估计</p> 
<p>由前文Differencing部分已知，一阶差分后数据已经稳定，所以d=1。<br> 所以用一阶差分化的ts_log_diff = ts_log - ts_log.shift() 作为输入。<br> 等价于 yt=Yt−Yt−1 作为输入。</p> 
<p>先画出ACF,PACF的图像,代码如下：</p> 
<pre><code>#ACF and PACF plots:
from statsmodels.tsa.stattools import acf, pacf
lag_acf = acf(ts_log_diff, nlags=20)
lag_pacf = pacf(ts_log_diff, nlags=20, method='ols')
#Plot ACF: 
plt.subplot(121) 
plt.plot(lag_acf)
plt.axhline(y=0,linestyle='--',color='gray')
plt.axhline(y=-1.96/np.sqrt(len(ts_log_diff)),linestyle='--',color='gray')
plt.axhline(y=1.96/np.sqrt(len(ts_log_diff)),linestyle='--',color='gray')
plt.title('Autocorrelation Function')

#Plot PACF:
plt.subplot(122)
plt.plot(lag_pacf)
plt.axhline(y=0,linestyle='--',color='gray')
plt.axhline(y=-1.96/np.sqrt(len(ts_log_diff)),linestyle='--',color='gray')
plt.axhline(y=1.96/np.sqrt(len(ts_log_diff)),linestyle='--',color='gray')
plt.title('Partial Autocorrelation Function')
plt.tight_layout()
</code></pre> 
<p><img src="https://images2.imgbox.com/48/97/pW6n0ID7_o.png" alt="在这里插入图片描述"></p> 
<p>图中，上下两条灰线之间是置信区间，p的值就是ACF第一次穿过上置信区间时的横轴值。q的值就是PACF第一次穿过上置信区间的横轴值。所以从图中可以得到p=2，q=2。</p> 
<p>step2： 得到参数估计值p，d，q之后，生成模型ARIMA（p，d，q）<br> 为了突出差别，用三种参数取值的三个模型作为对比。<br> 模型1：AR模型(ARIMA(2,1,0))</p> 
<pre><code>from statsmodels.tsa.arima_model import ARIMA
model = ARIMA(ts_log, order=(2, 1, 0))  
results_AR = model.fit(disp=-1)  
plt.plot(ts_log_diff)
plt.plot(results_AR.fittedvalues, color='red')
plt.title('RSS: %.4f'% sum((results_AR.fittedvalues-ts_log_diff)**2))
</code></pre> 
<p><img src="https://images2.imgbox.com/ff/bc/TgodNReU_o.png" alt="在这里插入图片描述"></p> 
<p>图中，蓝线是输入值，红线是模型的拟合值，RSS的累计平方误差。</p> 
<p>模型2：MA模型（ARIMA（0,1,2））</p> 
<pre><code>model = ARIMA(ts_log, order=(0, 1, 2))  
results_MA = model.fit(disp=-1)  
plt.plot(ts_log_diff)
plt.plot(results_MA.fittedvalues, color='red')
plt.title('RSS: %.4f'% sum((results_MA.fittedvalues-ts_log_diff)**2))
</code></pre> 
<p><img src="https://images2.imgbox.com/4f/72/pb6JZEPg_o.png" alt="在这里插入图片描述"></p> 
<p>模型3：ARIMA模型(ARIMA(2,1,2))</p> 
<pre><code>model = ARIMA(ts_log, order=(2, 1, 2))  
results_ARIMA = model.fit(disp=-1)  
plt.plot(ts_log_diff)
plt.plot(results_ARIMA.fittedvalues, color='red')
plt.title('RSS: %.4f'% sum((results_ARIMA.fittedvalues-ts_log_diff)**2))
</code></pre> 
<p><img src="https://images2.imgbox.com/38/98/ceXi4cOn_o.png" alt="在这里插入图片描述"></p> 
<p>由RSS，可知模型3–ARIMA（2,1,2）的拟合度最好，所以我们确定了最终的预测模型。</p> 
<p>step3: 将模型代入原数据进行预测<br> 因为上面的模型的拟合值是对原数据进行稳定化之后的输入数据的拟合，所以需要对拟合值进行相应处理的逆操作，使得它回到与原数据一致的尺度。</p> 
<pre><code>#ARIMA拟合的其实是一阶差分ts_log_diff，predictions_ARIMA_diff[i]是第i个月与i-1个月的ts_log的差值。
#由于差分化有一阶滞后，所以第一个月的数据是空的，
predictions_ARIMA_diff = pd.Series(results_ARIMA.fittedvalues, copy=True)
print predictions_ARIMA_diff.head()
#累加现有的diff，得到每个值与第一个月的差分（同log底的情况下）。
#即predictions_ARIMA_diff_cumsum[i] 是第i个月与第1个月的ts_log的差值。
predictions_ARIMA_diff_cumsum = predictions_ARIMA_diff.cumsum()
#先ts_log_diff =&gt; ts_log=&gt;ts_log =&gt; ts 
#先以ts_log的第一个值作为基数，复制给所有值，然后每个时刻的值累加与第一个月对应的差值(这样就解决了，第一个月diff数据为空的问题了)
#然后得到了predictions_ARIMA_log =&gt; predictions_ARIMA
predictions_ARIMA_log = pd.Series(ts_log.ix[0], index=ts_log.index)
predictions_ARIMA_log = predictions_ARIMA_log.add(predictions_ARIMA_diff_cumsum,fill_value=0)
predictions_ARIMA = np.exp(predictions_ARIMA_log)
plt.figure()
plt.plot(ts)
plt.plot(predictions_ARIMA)
plt.title('RMSE: %.4f'% np.sqrt(sum((predictions_ARIMA-ts)**2)/len(ts)))
plt.show()
</code></pre> 
<p><img src="https://images2.imgbox.com/e9/b7/qICuFrHM_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/d8/e8/bEpvasYV_o.png" alt="在这里插入图片描述"><br> step4: 预测后一年的数据变化</p> 
<p>5.总结<br> 前面一篇文章，总结了ARIMA建模的步骤。<br> (1). 获取被观测系统时间序列数据；<br> (2). 对数据绘图，观测是否为平稳时间序列；对于非平稳时间序列要先进行d阶差分运算，化为平稳时间序列；<br> (3). 经过第二步处理，已经得到平稳时间序列。要对平稳时间序列分别求得其自相关系数ACF 和偏自相关系数PACF，通过对自相关图和偏自相关图的分析，得到最佳的阶层 p 和阶数 q<br> (4). 由以上得到的d、q、p，得到ARIMA模型。然后开始对得到的模型进行模型检验。<br> 本文结合一个例子，说明python如何解决：<br> 1.判断一个时序数据是否是稳定。对应步骤(1)<br> 2. 怎样让时序数据稳定化。对应步骤(2)<br> 3. 使用ARIMA模型进行时序数据预测。对应步骤(3,4)</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7adb6590313accc20678510acbe3dd98/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【Maven】IDEA中Maven生命周期</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/cead9280ee1ef6b66ea5f9c377b08686/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">同一个类或者两个分别不同的类中a方法调用b方法事务的隔离级别问题</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>