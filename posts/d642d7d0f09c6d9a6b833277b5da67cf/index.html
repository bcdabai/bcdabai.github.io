<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43;[面向对象的程序设计]_基础入门（中）(万字总结)（建议收藏！！！） - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C&#43;&#43;[面向对象的程序设计]_基础入门（中）(万字总结)（建议收藏！！！）" />
<meta property="og:description" content="目录
2. C&#43;&#43; 核心编程
2.1 程序的内存模型
2.1.1 内存四区 - 代码区
2.1.2 内存四区 - 全局区
2.1.3 内存四区 - 栈区
2.1.4 内存四区 - 堆区
2.1.5 new 运算符
2.2 C&#43;&#43; 中的引用
2.2.1 引用的基本语法
2.2.2 引用的注意事项
2.2.3 引用做函数参数
2.2.4 引用做函数返回值
2.2.5 引用的本质
2.2.6 常量引用
2.3 函数高级
2.3.1 函数的默认参数
2.3.2 函数的占位参数
2.3.3 函数重载 - 基本语法
2.3.4 函数重载 - 注意事项
2.4 类和对象
2.4.1 封装
2.4.1.1 封装的意义
2.4.1.2 struct 和 class的区别
2.4.1.3 成员属性设置为私有
2.4.2 对象的初始化和清理
2.4.2.1 构造函数和析构函数" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/d642d7d0f09c6d9a6b833277b5da67cf/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-11T11:11:05+08:00" />
<meta property="article:modified_time" content="2023-12-11T11:11:05+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43;[面向对象的程序设计]_基础入门（中）(万字总结)（建议收藏！！！）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="2.%20C%2B%2B%20%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B-toc" style="margin-left:0px;"><a href="#2.%20C%2B%2B%20%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B" rel="nofollow">2. C++ 核心编程</a></p> 
<p id="2.1%20%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B-toc" style="margin-left:40px;"><a href="#2.1%20%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B" rel="nofollow">2.1 程序的内存模型</a></p> 
<p id="2.1.1%20%E5%86%85%E5%AD%98%E5%9B%9B%E5%8C%BA%20-%20%E4%BB%A3%E7%A0%81%E5%8C%BA-toc" style="margin-left:80px;"><a href="#2.1.1%20%E5%86%85%E5%AD%98%E5%9B%9B%E5%8C%BA%20-%20%E4%BB%A3%E7%A0%81%E5%8C%BA" rel="nofollow">2.1.1 内存四区 - 代码区</a></p> 
<p id="2.1.2%20%E5%86%85%E5%AD%98%E5%9B%9B%E5%8C%BA%20-%20%E5%85%A8%E5%B1%80%E5%8C%BA-toc" style="margin-left:80px;"><a href="#2.1.2%20%E5%86%85%E5%AD%98%E5%9B%9B%E5%8C%BA%20-%20%E5%85%A8%E5%B1%80%E5%8C%BA" rel="nofollow">2.1.2 内存四区 - 全局区</a></p> 
<p id="2.1.3%20%E5%86%85%E5%AD%98%E5%9B%9B%E5%8C%BA%20-%20%E6%A0%88%E5%8C%BA-toc" style="margin-left:80px;"><a href="#2.1.3%20%E5%86%85%E5%AD%98%E5%9B%9B%E5%8C%BA%20-%20%E6%A0%88%E5%8C%BA" rel="nofollow">2.1.3 内存四区 - 栈区</a></p> 
<p id="2.1.4%20%E5%86%85%E5%AD%98%E5%9B%9B%E5%8C%BA%20-%20%E5%A0%86%E5%8C%BA-toc" style="margin-left:80px;"><a href="#2.1.4%20%E5%86%85%E5%AD%98%E5%9B%9B%E5%8C%BA%20-%20%E5%A0%86%E5%8C%BA" rel="nofollow">2.1.4 内存四区 - 堆区</a></p> 
<p id="2.1.5%20new%20%E8%BF%90%E7%AE%97%E7%AC%A6-toc" style="margin-left:80px;"><a href="#2.1.5%20new%20%E8%BF%90%E7%AE%97%E7%AC%A6" rel="nofollow">2.1.5 new 运算符</a></p> 
<p id="2.2%20C%2B%2B%20%E4%B8%AD%E7%9A%84%E5%BC%95%E7%94%A8-toc" style="margin-left:40px;"><a href="#2.2%20C%2B%2B%20%E4%B8%AD%E7%9A%84%E5%BC%95%E7%94%A8" rel="nofollow">2.2 C++ 中的引用</a></p> 
<p id="2.2.1%20%E5%BC%95%E7%94%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95-toc" style="margin-left:80px;"><a href="#2.2.1%20%E5%BC%95%E7%94%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95" rel="nofollow">2.2.1 引用的基本语法</a></p> 
<p id="2.2.2%20%E5%BC%95%E7%94%A8%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-toc" style="margin-left:80px;"><a href="#2.2.2%20%E5%BC%95%E7%94%A8%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9" rel="nofollow">2.2.2 引用的注意事项</a></p> 
<p id="2.2.3%20%E5%BC%95%E7%94%A8%E5%81%9A%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0-toc" style="margin-left:80px;"><a href="#2.2.3%20%E5%BC%95%E7%94%A8%E5%81%9A%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0" rel="nofollow">2.2.3 引用做函数参数</a></p> 
<p id="2.2.4%20%E5%BC%95%E7%94%A8%E5%81%9A%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC-toc" style="margin-left:80px;"><a href="#2.2.4%20%E5%BC%95%E7%94%A8%E5%81%9A%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC" rel="nofollow">2.2.4 引用做函数返回值</a></p> 
<p id="2.2.5%20%E5%BC%95%E7%94%A8%E7%9A%84%E6%9C%AC%E8%B4%A8-toc" style="margin-left:80px;"><a href="#2.2.5%20%E5%BC%95%E7%94%A8%E7%9A%84%E6%9C%AC%E8%B4%A8" rel="nofollow">2.2.5 引用的本质</a></p> 
<p id="2.2.6%20%E5%B8%B8%E9%87%8F%E5%BC%95%E7%94%A8-toc" style="margin-left:80px;"><a href="#2.2.6%20%E5%B8%B8%E9%87%8F%E5%BC%95%E7%94%A8" rel="nofollow">2.2.6 常量引用</a></p> 
<p id="2.3%20%E5%87%BD%E6%95%B0%E9%AB%98%E7%BA%A7-toc" style="margin-left:40px;"><a href="#2.3%20%E5%87%BD%E6%95%B0%E9%AB%98%E7%BA%A7" rel="nofollow">2.3 函数高级</a></p> 
<p id="2.3.1%20%E5%87%BD%E6%95%B0%E7%9A%84%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0-toc" style="margin-left:80px;"><a href="#2.3.1%20%E5%87%BD%E6%95%B0%E7%9A%84%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0" rel="nofollow">2.3.1 函数的默认参数</a></p> 
<p id="2.3.2%20%E5%87%BD%E6%95%B0%E7%9A%84%E5%8D%A0%E4%BD%8D%E5%8F%82%E6%95%B0-toc" style="margin-left:80px;"><a href="#2.3.2%20%E5%87%BD%E6%95%B0%E7%9A%84%E5%8D%A0%E4%BD%8D%E5%8F%82%E6%95%B0" rel="nofollow">2.3.2 函数的占位参数</a></p> 
<p id="2.3.3%20%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%20-%20%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95-toc" style="margin-left:80px;"><a href="#2.3.3%20%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%20-%20%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95" rel="nofollow">2.3.3 函数重载 - 基本语法</a></p> 
<p id="2.3.4%20%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%20-%20%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-toc" style="margin-left:80px;"><a href="#2.3.4%20%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%20-%20%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9" rel="nofollow">2.3.4 函数重载 - 注意事项</a></p> 
<p id="2.4%20%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1-toc" style="margin-left:40px;"><a href="#2.4%20%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1" rel="nofollow">2.4 类和对象</a></p> 
<p id="2.4.1%20%E5%B0%81%E8%A3%85-toc" style="margin-left:80px;"><a href="#2.4.1%20%E5%B0%81%E8%A3%85" rel="nofollow">2.4.1 封装</a></p> 
<p id="2.4.1.1%20%E5%B0%81%E8%A3%85%E7%9A%84%E6%84%8F%E4%B9%89-toc" style="margin-left:120px;"><a href="#2.4.1.1%20%E5%B0%81%E8%A3%85%E7%9A%84%E6%84%8F%E4%B9%89" rel="nofollow">2.4.1.1 封装的意义</a></p> 
<p id="2.4.1.2%20struct%20%E5%92%8C%20class%E7%9A%84%E5%8C%BA%E5%88%AB-toc" style="margin-left:120px;"><a href="#2.4.1.2%20struct%20%E5%92%8C%20class%E7%9A%84%E5%8C%BA%E5%88%AB" rel="nofollow">2.4.1.2 struct 和 class的区别</a></p> 
<p id="2.4.1.3%20%E6%88%90%E5%91%98%E5%B1%9E%E6%80%A7%E8%AE%BE%E7%BD%AE%E4%B8%BA%E7%A7%81%E6%9C%89-toc" style="margin-left:120px;"><a href="#2.4.1.3%20%E6%88%90%E5%91%98%E5%B1%9E%E6%80%A7%E8%AE%BE%E7%BD%AE%E4%B8%BA%E7%A7%81%E6%9C%89" rel="nofollow">2.4.1.3 成员属性设置为私有</a></p> 
<p id="2.4.2%20%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E6%B8%85%E7%90%86-toc" style="margin-left:80px;"><a href="#2.4.2%20%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E6%B8%85%E7%90%86" rel="nofollow">2.4.2 对象的初始化和清理</a></p> 
<p id="2.4.2.1%20%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0-toc" style="margin-left:120px;"><a href="#2.4.2.1%20%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0" rel="nofollow">2.4.2.1 构造函数和析构函数</a></p> 
<p id="2.4.2.2%20%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E5%88%86%E7%B1%BB%E5%8F%8A%E8%B0%83%E7%94%A8-toc" style="margin-left:120px;"><a href="#2.4.2.2%20%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E5%88%86%E7%B1%BB%E5%8F%8A%E8%B0%83%E7%94%A8" rel="nofollow">2.4.2.2 构造函数的分类及调用</a></p> 
<p id="2.4.2.3%20%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%97%B6%E6%9C%BA-toc" style="margin-left:120px;"><a href="#2.4.2.3%20%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%97%B6%E6%9C%BA" rel="nofollow">2.4.2.3 拷贝构造函数调用时机</a></p> 
<p id="2.4.2.4%20%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%A7%84%E5%88%99-toc" style="margin-left:120px;"><a href="#2.4.2.4%20%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%A7%84%E5%88%99" rel="nofollow">2.4.2.4 构造函数调用规则</a></p> 
<p id="2.4.2.5%20%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D-toc" style="margin-left:120px;"><a href="#2.4.2.5%20%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D" rel="nofollow">2.4.2.5 深拷贝与浅拷贝</a></p> 
<p id="2.4.2.6%20%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8-toc" style="margin-left:120px;"><a href="#2.4.2.6%20%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8" rel="nofollow">2.4.2.6 初始化列表</a></p> 
<p id="2.4.2.7%20%E7%B1%BB%E5%AF%B9%E8%B1%A1%E4%BD%9C%E4%B8%BA%E7%B1%BB%E6%88%90%E5%91%98-toc" style="margin-left:120px;"><a href="#2.4.2.7%20%E7%B1%BB%E5%AF%B9%E8%B1%A1%E4%BD%9C%E4%B8%BA%E7%B1%BB%E6%88%90%E5%91%98" rel="nofollow">2.4.2.7 类对象作为类成员</a></p> 
<p id="2.4.2.8%20%E9%9D%99%E6%80%81%E6%88%90%E5%91%98-toc" style="margin-left:120px;"><a href="#2.4.2.8%20%E9%9D%99%E6%80%81%E6%88%90%E5%91%98" rel="nofollow">2.4.2.8 静态成员</a></p> 
<p id="2.4.3%20C%2B%2B%20%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E5%92%8C%20this%20%E6%8C%87%E9%92%88-toc" style="margin-left:80px;"><a href="#2.4.3%20C%2B%2B%20%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E5%92%8C%20this%20%E6%8C%87%E9%92%88" rel="nofollow">2.4.3 C++ 对象模型和 this 指针</a></p> 
<p id="2.4.3.1%20%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%92%8C%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E5%88%86%E5%BC%80%E5%AD%98%E5%82%A8-toc" style="margin-left:120px;"><a href="#2.4.3.1%20%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%92%8C%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E5%88%86%E5%BC%80%E5%AD%98%E5%82%A8" rel="nofollow">2.4.3.1 成员变量和成员函数分开存储</a></p> 
<p id="2.4.3.2%20this%20%E6%8C%87%E9%92%88%E6%A6%82%E5%BF%B5-toc" style="margin-left:120px;"><a href="#2.4.3.2%20this%20%E6%8C%87%E9%92%88%E6%A6%82%E5%BF%B5" rel="nofollow">2.4.3.2 this 指针概念</a></p> 
<p id="2.4.3.3%20%E7%A9%BA%E6%8C%87%E9%92%88%E8%AE%BF%E9%97%AE%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0-toc" style="margin-left:120px;"><a href="#2.4.3.3%20%E7%A9%BA%E6%8C%87%E9%92%88%E8%AE%BF%E9%97%AE%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0" rel="nofollow">2.4.3.3 空指针访问成员函数</a></p> 
<p id="2.4.3.4%20const%20%E4%BF%AE%E9%A5%B0%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0-toc" style="margin-left:120px;"><a href="#2.4.3.4%20const%20%E4%BF%AE%E9%A5%B0%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0" rel="nofollow">2.4.3.4 const 修饰成员函数</a></p> 
<p id="2.4.4%20%E5%8F%8B%E5%85%83-toc" style="margin-left:80px;"><a href="#2.4.4%20%E5%8F%8B%E5%85%83" rel="nofollow">2.4.4 友元</a></p> 
<p id="2.4.5%20%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD-toc" style="margin-left:80px;"><a href="#2.4.5%20%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD" rel="nofollow">2.4.5 运算符重载</a></p> 
<p id="2.4.5.1%20%E5%8A%A0%E5%8F%B7%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD-toc" style="margin-left:120px;"><a href="#2.4.5.1%20%E5%8A%A0%E5%8F%B7%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD" rel="nofollow">2.4.5.1 加号运算符重载</a></p> 
<p id="2.4.5.2%20%E5%B7%A6%E7%A7%BB%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD-toc" style="margin-left:120px;"><a href="#2.4.5.2%20%E5%B7%A6%E7%A7%BB%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD" rel="nofollow">2.4.5.2 左移运算符重载</a></p> 
<p id="2.4.5.3%20%E9%80%92%E5%A2%9E%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD-toc" style="margin-left:120px;"><a href="#2.4.5.3%20%E9%80%92%E5%A2%9E%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD" rel="nofollow">2.4.5.3 递增运算符重载</a></p> 
<p id="2.4.5.4%20%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD-toc" style="margin-left:120px;"><a href="#2.4.5.4%20%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD" rel="nofollow">2.4.5.4 赋值运算符重载</a></p> 
<p id="2.4.5.5%20%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD-toc" style="margin-left:120px;"><a href="#2.4.5.5%20%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD" rel="nofollow">2.4.5.5 关系运算符重载</a></p> 
<p id="2.4.5.6%20%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD-toc" style="margin-left:120px;"><a href="#2.4.5.6%20%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD" rel="nofollow">2.4.5.6 函数调用运算符重载</a></p> 
<p id="2.4.6%20%E7%BB%A7%E6%89%BF-toc" style="margin-left:80px;"><a href="#2.4.6%20%E7%BB%A7%E6%89%BF" rel="nofollow">2.4.6 继承</a></p> 
<p id="2.4.6.1%20%E7%BB%A7%E6%89%BF%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95-toc" style="margin-left:120px;"><a href="#2.4.6.1%20%E7%BB%A7%E6%89%BF%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95" rel="nofollow">2.4.6.1 继承的基本语法</a></p> 
<p id="2.4.6.2%20%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F-toc" style="margin-left:120px;"><a href="#2.4.6.2%20%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F" rel="nofollow">2.4.6.2 继承方式</a></p> 
<p id="2.4.6.3%20%E7%BB%A7%E6%89%BF%E4%B8%AD%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-toc" style="margin-left:120px;"><a href="#2.4.6.3%20%E7%BB%A7%E6%89%BF%E4%B8%AD%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B" rel="nofollow">2.4.6.3 继承中的对象模型</a></p> 
<p id="2.4.6.4%20%E7%BB%A7%E6%89%BF%E4%B8%AD%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84%E9%A1%BA%E5%BA%8F-toc" style="margin-left:120px;"><a href="#2.4.6.4%20%E7%BB%A7%E6%89%BF%E4%B8%AD%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84%E9%A1%BA%E5%BA%8F" rel="nofollow">2.4.6.4 继承中构造和析构顺序</a></p> 
<p id="2.4.6.5%20%E7%BB%A7%E6%89%BF%E5%90%8C%E5%90%8D%E6%88%90%E5%91%98%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F-toc" style="margin-left:120px;"><a href="#2.4.6.5%20%E7%BB%A7%E6%89%BF%E5%90%8C%E5%90%8D%E6%88%90%E5%91%98%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F" rel="nofollow">2.4.6.5 继承同名成员处理方式</a></p> 
<p id="2.4.6.6%20%E7%BB%A7%E6%89%BF%E5%90%8C%E5%90%8D%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F-toc" style="margin-left:120px;"><a href="#2.4.6.6%20%E7%BB%A7%E6%89%BF%E5%90%8C%E5%90%8D%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F" rel="nofollow">2.4.6.6 继承同名静态成员处理方式</a></p> 
<p id="2.4.6.7%20%E5%A4%9A%E7%BB%A7%E6%89%BF%E8%AF%AD%E6%B3%95-toc" style="margin-left:120px;"><a href="#2.4.6.7%20%E5%A4%9A%E7%BB%A7%E6%89%BF%E8%AF%AD%E6%B3%95" rel="nofollow">2.4.6.7 多继承语法</a></p> 
<p id="2.4.6.8%20%E8%8F%B1%E5%BD%A2%E7%BB%A7%E6%89%BF-toc" style="margin-left:120px;"><a href="#2.4.6.8%20%E8%8F%B1%E5%BD%A2%E7%BB%A7%E6%89%BF" rel="nofollow">2.4.6.8 菱形继承</a></p> 
<p id="2.4.7%20%E5%A4%9A%E6%80%81-toc" style="margin-left:80px;"><a href="#2.4.7%20%E5%A4%9A%E6%80%81" rel="nofollow">2.4.7 多态</a></p> 
<p id="2.4.7.1%20%E5%A4%9A%E6%80%81%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-toc" style="margin-left:120px;"><a href="#2.4.7.1%20%E5%A4%9A%E6%80%81%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5" rel="nofollow">2.4.7.1 多态的基本概念</a></p> 
<p id="2.4.7.2%20%E5%A4%9A%E6%80%81%E7%9A%84%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90-toc" style="margin-left:120px;"><a href="#2.4.7.2%20%E5%A4%9A%E6%80%81%E7%9A%84%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90" rel="nofollow">2.4.7.2 多态的原理剖析</a></p> 
<p id="2.4.7.3%20%E6%A1%88%E4%BE%8B%E4%B8%80%EF%BC%9A%E8%AE%A1%E7%AE%97%E5%99%A8%E7%B1%BB-toc" style="margin-left:120px;"><a href="#2.4.7.3%20%E6%A1%88%E4%BE%8B%E4%B8%80%EF%BC%9A%E8%AE%A1%E7%AE%97%E5%99%A8%E7%B1%BB" rel="nofollow">2.4.7.3 案例一：计算器类</a></p> 
<p id="2.4.7.4%20%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB-toc" style="margin-left:120px;"><a href="#2.4.7.4%20%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB" rel="nofollow">2.4.7.4 纯虚函数和抽象类</a></p> 
<p id="2.4.7.5%20%E6%A1%88%E4%BE%8B%E4%BA%8C%EF%BC%9A%E5%88%B6%E4%BD%9C%E9%A5%AE%E5%93%81-toc" style="margin-left:120px;"><a href="#2.4.7.5%20%E6%A1%88%E4%BE%8B%E4%BA%8C%EF%BC%9A%E5%88%B6%E4%BD%9C%E9%A5%AE%E5%93%81" rel="nofollow">2.4.7.5 案例二：制作饮品</a></p> 
<p id="2.4.7.6%20%E8%99%9A%E6%9E%90%E6%9E%84%E5%92%8C%E7%BA%AF%E8%99%9A%E6%9E%90%E6%9E%84-toc" style="margin-left:120px;"><a href="#2.4.7.6%20%E8%99%9A%E6%9E%90%E6%9E%84%E5%92%8C%E7%BA%AF%E8%99%9A%E6%9E%90%E6%9E%84" rel="nofollow">2.4.7.6 虚析构和纯虚析构</a></p> 
<p id="2.5%20%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C-toc" style="margin-left:40px;"><a href="#2.5%20%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C" rel="nofollow">2.5 文件操作</a></p> 
<p id="2.5.1%20%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%C2%A0-toc" style="margin-left:80px;"><a href="#2.5.1%20%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%C2%A0" rel="nofollow">2.5.1 文本文件 </a></p> 
<p id="2.5.1.1%20%E5%86%99%E6%96%87%E4%BB%B6-toc" style="margin-left:120px;"><a href="#2.5.1.1%20%E5%86%99%E6%96%87%E4%BB%B6" rel="nofollow">2.5.1.1 写文件</a></p> 
<p id="2.5.1.2%20%E8%AF%BB%E6%96%87%E4%BB%B6-toc" style="margin-left:120px;"><a href="#2.5.1.2%20%E8%AF%BB%E6%96%87%E4%BB%B6" rel="nofollow">2.5.1.2 读文件</a></p> 
<p id="2.5.2%20%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6-toc" style="margin-left:80px;"><a href="#2.5.2%20%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6" rel="nofollow">2.5.2 二进制文件</a></p> 
<p id="2.5.2.1%20%E5%86%99%E6%96%87%E4%BB%B6-toc" style="margin-left:120px;"><a href="#2.5.2.1%20%E5%86%99%E6%96%87%E4%BB%B6" rel="nofollow">2.5.2.1 写文件</a></p> 
<p id="2.5.2.2%20%E8%AF%BB%E6%96%87%E4%BB%B6-toc" style="margin-left:120px;"><a href="#2.5.2.2%20%E8%AF%BB%E6%96%87%E4%BB%B6" rel="nofollow">2.5.2.2 读文件</a></p> 
<p id="2.6%20%E8%81%8C%E5%B7%A5%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F-toc" style="margin-left:40px;"><a href="#2.6%20%E8%81%8C%E5%B7%A5%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F" rel="nofollow">2.6 职工管理系统</a></p> 
<p id="2.6.1%20%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E9%9C%80%E6%B1%82-toc" style="margin-left:80px;"><a href="#2.6.1%20%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E9%9C%80%E6%B1%82" rel="nofollow">2.6.1 管理系统需求</a></p> 
<p id="2.6.2%20%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE-toc" style="margin-left:80px;"><a href="#2.6.2%20%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE" rel="nofollow">2.6.2 创建项目</a></p> 
<p id="2.6.3%20%E5%88%9B%E5%BB%BA%E7%AE%A1%E7%90%86%E7%B1%BB-toc" style="margin-left:80px;"><a href="#2.6.3%20%E5%88%9B%E5%BB%BA%E7%AE%A1%E7%90%86%E7%B1%BB" rel="nofollow">2.6.3 创建管理类</a></p> 
<p id="2.6.4%20%E8%8F%9C%E5%8D%95%E5%8A%9F%E8%83%BD-toc" style="margin-left:80px;"><a href="#2.6.4%20%E8%8F%9C%E5%8D%95%E5%8A%9F%E8%83%BD" rel="nofollow">2.6.4 菜单功能</a></p> 
<p id="2.6.5%20%E9%80%80%E5%87%BA%E5%8A%9F%E8%83%BD-toc" style="margin-left:80px;"><a href="#2.6.5%20%E9%80%80%E5%87%BA%E5%8A%9F%E8%83%BD" rel="nofollow">2.6.5 退出功能</a></p> 
<p id="2.6.6%20%E5%88%9B%E5%BB%BA%E8%81%8C%E5%B7%A5%E7%B1%BB-toc" style="margin-left:80px;"><a href="#2.6.6%20%E5%88%9B%E5%BB%BA%E8%81%8C%E5%B7%A5%E7%B1%BB" rel="nofollow">2.6.6 创建职工类</a></p> 
<p id="2.6.7%20%E6%B7%BB%E5%8A%A0%E8%81%8C%E5%B7%A5-toc" style="margin-left:80px;"><a href="#2.6.7%20%E6%B7%BB%E5%8A%A0%E8%81%8C%E5%B7%A5" rel="nofollow">2.6.7 添加职工</a></p> 
<p id="2.6.8%20%E6%96%87%E4%BB%B6%E4%BA%A4%E4%BA%92%20-%20%E5%86%99%E6%96%87%E4%BB%B6-toc" style="margin-left:80px;"><a href="#2.6.8%20%E6%96%87%E4%BB%B6%E4%BA%A4%E4%BA%92%20-%20%E5%86%99%E6%96%87%E4%BB%B6" rel="nofollow">2.6.8 文件交互 - 写文件</a></p> 
<p id="2.6.9%20%E6%96%87%E4%BB%B6%E4%BA%A4%E4%BA%92%20-%20%E8%AF%BB%E6%96%87%E4%BB%B6-toc" style="margin-left:80px;"><a href="#2.6.9%20%E6%96%87%E4%BB%B6%E4%BA%A4%E4%BA%92%20-%20%E8%AF%BB%E6%96%87%E4%BB%B6" rel="nofollow">2.6.9 文件交互 - 读文件</a></p> 
<p id="2.6.10%20%E6%98%BE%E7%A4%BA%E8%81%8C%E5%B7%A5-toc" style="margin-left:80px;"><a href="#2.6.10%20%E6%98%BE%E7%A4%BA%E8%81%8C%E5%B7%A5" rel="nofollow">2.6.10 显示职工</a></p> 
<p id="2.6.11%20%E5%88%A0%E9%99%A4%E8%81%8C%E5%B7%A5-toc" style="margin-left:80px;"><a href="#2.6.11%20%E5%88%A0%E9%99%A4%E8%81%8C%E5%B7%A5" rel="nofollow">2.6.11 删除职工</a></p> 
<p id="2.6.12%20%E4%BF%AE%E6%94%B9%E8%81%8C%E5%B7%A5-toc" style="margin-left:80px;"><a href="#2.6.12%20%E4%BF%AE%E6%94%B9%E8%81%8C%E5%B7%A5" rel="nofollow">2.6.12 修改职工</a></p> 
<p id="2.6.13%20%E6%9F%A5%E6%89%BE%E8%81%8C%E5%B7%A5-toc" style="margin-left:80px;"><a href="#2.6.13%20%E6%9F%A5%E6%89%BE%E8%81%8C%E5%B7%A5" rel="nofollow">2.6.13 查找职工</a></p> 
<p id="2.6.14%20%E6%8E%92%E5%BA%8F-toc" style="margin-left:80px;"><a href="#2.6.14%20%E6%8E%92%E5%BA%8F" rel="nofollow">2.6.14 排序</a></p> 
<p id="2.6.15%20%E6%B8%85%E7%A9%BA%E6%96%87%E4%BB%B6-toc" style="margin-left:80px;"><a href="#2.6.15%20%E6%B8%85%E7%A9%BA%E6%96%87%E4%BB%B6" rel="nofollow">2.6.15 清空文件</a></p> 
<p id="2.6.16%20%E5%AE%8C%E6%95%B4%E7%A8%8B%E5%BA%8F%E4%BB%A3%E7%A0%81-toc" style="margin-left:80px;"><a href="#2.6.16%20%E5%AE%8C%E6%95%B4%E7%A8%8B%E5%BA%8F%E4%BB%A3%E7%A0%81" rel="nofollow">2.6.16 完整程序代码</a></p> 
<p id="2.6.16.1%20ManagerWorker.cpp-toc" style="margin-left:120px;"><a href="#2.6.16.1%20ManagerWorker.cpp" rel="nofollow">2.6.16.1 ManagerWorker.cpp</a></p> 
<p id="2.6.16.2%20ManagerWorker.h-toc" style="margin-left:120px;"><a href="#2.6.16.2%20ManagerWorker.h" rel="nofollow">2.6.16.2 ManagerWorker.h</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="2.%20C%2B%2B%20%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B"><span style="color:#956fe7;">2. C++ 核心编程</span></h2> 
<h3 id="2.1%20%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span style="color:#4da8ee;">2.1 程序的内存模型</span></h3> 
<p>C++ 程序在执行时，将内存大方向划分为<span style="color:#0d0016;"><strong> 4 个区域</strong>：</span></p> 
<ul><li>        <strong>代码区</strong>：存放<strong>函数体的二进制代码</strong>，由操作系统进行管理</li><li>        <strong>全局区</strong>：存放<strong>全局变量</strong>和<strong>静态变量</strong>以及<strong>常量</strong></li><li>        <strong>栈区</strong>：由编译器自动分配释放，存放<span style="color:#0d0016;"><strong>函数的参数值</strong>，<strong>局部变量</strong></span>等</li><li>        <strong>堆区</strong>：由程序员分配和释放，若程序员不释放，程序结束时由操作系统回收<span style="color:#0d0016;">（<strong>存放动态开辟的内存空间</strong>）</span></li></ul> 
<p><span style="color:#0d0016;"><strong>内存四区的意义</strong>：</span>不同的区域存放不同的数据，赋予不同的生命周期，给我们更大的灵活编程空间！</p> 
<h4 id="2.1.1%20%E5%86%85%E5%AD%98%E5%9B%9B%E5%8C%BA%20-%20%E4%BB%A3%E7%A0%81%E5%8C%BA"><span style="color:#38d8f0;">2.1.1 内存四区 - 代码区</span></h4> 
<p>        在程序编译后，会生成一个<span style="color:#0d0016;"><strong> .exe 的可执行文件</strong></span>，还没有执行该程序前会分成<span style="color:#0d0016;"><strong>两部分</strong>：</span></p> 
<p><span style="color:#0d0016;"><strong>代码区：</strong></span></p> 
<p>        <img alt="" height="100" src="https://images2.imgbox.com/ec/3f/EWUkdSzZ_o.png" width="324"></p> 
<p>        这就是一个 .exe 的可执行文件，也就是说点击这个文件就会执行我们的程序！（<span style="color:#0d0016;"><strong>注意</strong></span>：这个文件是<span style="color:#0d0016;"><strong>编译代码</strong></span>后生成的，而不是运行代码后生成的；）</p> 
<blockquote> 
 <p>1. 该区域存放 CPU 执行的机器指令</p> 
 <p>2. 代码区是<span style="color:#fe2c24;"><strong>共享</strong></span>的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可（<strong><span style="color:#0d0016;">因为双击 .exe 文件就会运行我们的程序，如果双击第一次运行程序之后，再次双击执行该程序时，没必要再次把程序拿到 CPU 去执行，只需要执行上次的代码即可！</span></strong><span style="color:#0d0016;">）</span></p> 
 <p>3. 代码区是<span style="color:#fe2c24;"><strong>只读</strong></span>的，使其只读的原因是防止程序意外地修改了它的指令</p> 
</blockquote> 
<h4 id="2.1.2%20%E5%86%85%E5%AD%98%E5%9B%9B%E5%8C%BA%20-%20%E5%85%A8%E5%B1%80%E5%8C%BA"><span style="color:#38d8f0;">2.1.2 内存四区 - 全局区</span></h4> 
<p>        上面说了没有执行程序之前，编译代码会生成一个 .exe 文件，没有执行程序之前会分成两部分，上面指出了一部分是代码区，那么<span style="color:#0d0016;"><strong>另一部分就是这里提及的全局区</strong>：</span></p> 
<blockquote> 
 <p>1. 全局变量和静态变量存放在此！</p> 
 <p>2. 全局区还包含常量区，字符串常量和其他常量也存放在此！（其中其他常量主要指 const 变量修饰的常量）</p> 
 <p>3. 该区域的数据在程序结束后由操作系统释放！</p> 
</blockquote> 
<pre><code>int g_a = 10;
int g_b = 20;

const int c_l_a = 10;
const int c_l_b = 20;

int main()
{
	int a = 10;
	int b = 20;

	static int s_a = 10;
	static int s_b = 20;
	// 常量分为  1. 字符串常量   2. const 修饰的变量
	// const 修饰的变量分为  1. const 修饰的全局变量	2. const 修饰的局部变量
	const int c_g_a = 10;
	const int c_g_b = 20;

	cout &lt;&lt; "局部变量a的地址：" &lt;&lt; (int)&amp;a &lt;&lt; endl;
	cout &lt;&lt; "局部变量b的地址：" &lt;&lt; (int)&amp;b &lt;&lt; endl;
	cout &lt;&lt; "全局变量g_a的地址：" &lt;&lt; (int)&amp;g_a &lt;&lt; endl;
	cout &lt;&lt; "全局变量g_b的地址：" &lt;&lt; (int)&amp;g_b &lt;&lt; endl;
	cout &lt;&lt; "静态变量s_a的地址：" &lt;&lt; (int)&amp;s_a &lt;&lt; endl;
	cout &lt;&lt; "静态变量s_b的地址：" &lt;&lt; (int)&amp;s_b &lt;&lt; endl;

	cout &lt;&lt; "字符串常量的地址为：" &lt;&lt; (int)"HelloWorld" &lt;&lt; endl;

	cout &lt;&lt; "const修饰的局部变量c_g_a的地址：" &lt;&lt; (int)&amp;c_g_a &lt;&lt; endl;
	cout &lt;&lt; "const修饰的局部变量c_g_b的地址：" &lt;&lt; (int)&amp;c_g_b &lt;&lt; endl;
	cout &lt;&lt; "const修饰的全局变量c_l_a的地址：" &lt;&lt; (int)&amp;c_l_a &lt;&lt; endl;
	cout &lt;&lt; "const修饰的全局变量c_l_b的地址：" &lt;&lt; (int)&amp;c_l_b &lt;&lt; endl;

	system("pause"); // 按任意键继续！
	return 0;
}</code></pre> 
<p><img alt="" height="220" src="https://images2.imgbox.com/e0/ba/17JBWYG3_o.png" width="442"></p> 
<blockquote> 
 <p><span style="color:#0d0016;"><strong>这里可以看出：</strong></span></p> 
 <p>       <span style="color:#0d0016;"><strong> 局部变量</strong></span>和<span style="color:#0d0016;"><strong> const 修饰的局部变量</strong></span>属于<span style="color:#0d0016;"><strong>栈区</strong></span>，因此它们的地址在同一个分区内！</p> 
 <p>        <span style="color:#0d0016;"><strong>全局变量</strong></span>和<span style="color:#0d0016;"><strong>静态变量</strong></span>以及<span style="color:#0d0016;"><strong>常量（这里说的常量指的是字符串常量和 const 修饰的全局变量）</strong></span>属于<span style="color:#0d0016;"><strong>全局区</strong></span>，因此它们的地址在同一个分区内！</p> 
</blockquote> 
<blockquote> 
 <p>这里再次提一下：不管是代码区还是全局区，都是在<span style="color:#0d0016;"><strong>程序执行之前生成的两个区</strong></span>；而在<span style="color:#0d0016;"><strong>程序运行之后产生的两个区叫做：堆区和栈区</strong>；</span></p> 
</blockquote> 
<h4 id="2.1.3%20%E5%86%85%E5%AD%98%E5%9B%9B%E5%8C%BA%20-%20%E6%A0%88%E5%8C%BA"><span style="color:#38d8f0;">2.1.3 内存四区 - 栈区</span></h4> 
<p><span style="color:#0d0016;"><strong>栈区特点：</strong></span></p> 
<p>        1. 由编译器自动分配释放（也就是说栈区的数据的生命周期不是我们可以控制的），存放函数的参数值，局部变量等。</p> 
<p>      <span style="color:#0d0016;"><strong>  注意</strong><strong>：不要返回局部变量的地址，栈区开辟的数据由编译器自动释放！</strong></span></p> 
<pre><code>int* Function() // 这里因为需要返回局部变量a的地址，所以函数类型定义为 int*
{
	int a = 10; // 这里函数定义一个局部变量a，局部变量是存放在栈区
					 // 栈区是由编译器来管理的，变量的声明周期不由我们来设定！
	return &amp;a; // 返回局部变量a的地址
}

int main()
{
	// 栈区数据的注意事项 ---- 不要返回局部变量的地址
	// 栈区的数据由编译器管理开辟和释放！！！
	int* p = Function(); // 定义指针p来接收函数的返回类型
	cout &lt;&lt; "p=" &lt;&lt; *p &lt;&lt; endl; 
	// 这里解释一下为什么第一次是10，刚刚不是说了局部变量离开函数生命周期就会被销毁吗，怎么还会打印10？
	// 这是因为编译器做了一次保留，编译器认为我们是误操作，所以进行了一次保留
	cout &lt;&lt; "p=" &lt;&lt; *p &lt;&lt; endl;
	// 第二次打印出来是乱码，是因为编译器只进行了一次的保留！

	system("pause"); // 按任意键继续！
	return 0;
}</code></pre> 
<p><img alt="" height="150" src="https://images2.imgbox.com/40/92/1dkmuQwa_o.png" width="366"></p> 
<h4 id="2.1.4%20%E5%86%85%E5%AD%98%E5%9B%9B%E5%8C%BA%20-%20%E5%A0%86%E5%8C%BA"><span style="color:#38d8f0;">2.1.4 内存四区 - 堆区</span></h4> 
<p><span style="color:#0d0016;"><strong>堆区特点：</strong></span></p> 
<p>        由程序员分配释放（这一点和栈区的数据正好相对应，其生命周期是由程序员来管理的！），若程序员不释放，程序结束时由操作系统回收！</p> 
<p><span style="color:#0d0016;">        <strong>在 C++ 中主要利用 new 在堆区开辟内存！</strong></span></p> 
<p><img alt="" height="430" src="https://images2.imgbox.com/93/07/f2Hie6ul_o.png" width="747"></p> 
<p>可以看出在堆区开辟的内存空间，程序员是可以管理其生命周期的！！！</p> 
<p><img alt="" height="450" src="https://images2.imgbox.com/c3/bd/moiuIWlh_o.png" width="651"></p> 
<h4 id="2.1.5%20new%20%E8%BF%90%E7%AE%97%E7%AC%A6"><span style="color:#38d8f0;">2.1.5 new 运算符</span></h4> 
<p>        C++ 中利用 new 操作符在堆区开辟数据。</p> 
<p>        堆区开辟的数据，由程序员手动开辟，手动释放，释放利用操作符 delete；</p> 
<p>      <span style="color:#0d0016;"><strong>  语法：</strong></span>new 数据类型</p> 
<p>        利用 new 创建的数据，会返回该数据对应的类型的指针！</p> 
<p><img alt="" height="500" src="https://images2.imgbox.com/d9/fc/GDjxGiCD_o.png" width="682"></p> 
<blockquote> 
 <p>在上述的 Test() 函数中，先打印两个解引用的 *p，然后 delete 释放开辟的这段内存；然后再去打印 *p，此时就会报错！！！因此开辟的堆区空间已经被释放了！</p> 
</blockquote> 
<p><img alt="" height="500" src="https://images2.imgbox.com/2a/cd/CxhDfnWP_o.png" width="769"></p> 
<h3 id="2.2%20C%2B%2B%20%E4%B8%AD%E7%9A%84%E5%BC%95%E7%94%A8"><span style="color:#4da8ee;">2.2 C++ 中的引用</span></h3> 
<h4 id="2.2.1%20%E5%BC%95%E7%94%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span style="color:#38d8f0;">2.2.1 引用的基本语法</span></h4> 
<p>        <span style="color:#0d0016;"><strong>作用：</strong></span>给变量起别名</p> 
<p>      <span style="color:#0d0016;">  <strong>语法：</strong></span><span style="background-color:#ffd900;">数据类型  &amp;别名 = 原名</span></p> 
<p><img alt="" height="400" src="https://images2.imgbox.com/2c/46/iXAhSilM_o.png" width="831"></p> 
<h4 id="2.2.2%20%E5%BC%95%E7%94%A8%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span style="color:#38d8f0;">2.2.2 引用的注意事项</span></h4> 
<blockquote> 
 <p><strong>1. </strong>引用必须初始化</p> 
 <p><strong>2. </strong>引用在初始化后，不可以改变</p> 
</blockquote> 
<p><img alt="" height="250" src="https://images2.imgbox.com/3b/08/7fIYnyYx_o.png" width="482"></p> 
<p><img alt="" height="300" src="https://images2.imgbox.com/ab/b2/3DYbnQVE_o.png" width="386"></p> 
<p><img alt="" height="350" src="https://images2.imgbox.com/ff/2b/8J6BwfrW_o.png" width="290"></p> 
<h4 id="2.2.3%20%E5%BC%95%E7%94%A8%E5%81%9A%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0"><span style="color:#38d8f0;">2.2.3 引用做函数参数</span></h4> 
<p><span style="color:#0d0016;">        <strong>作用</strong>：</span>函数传参时，可以利用引用的技术让形参修饰实参</p> 
<p>    <span style="color:#0d0016;">    <strong>优点</strong>：</span>可以简化指针修改实参</p> 
<blockquote> 
 <p>在之前的学习中，我们知道函数传参存在<span style="color:#0d0016;"><strong>值传递</strong></span>和<span style="color:#0d0016;"><strong>地址传递</strong></span>，在值传递的过程中，形参的改变是不会影响到实参的；但是<strong>在<span style="color:#0d0016;"> C++ 中，可以用引用技术来实现形参修饰实参！！！</span></strong></p> 
</blockquote> 
<pre><code>#define _CRT_SECURE_NO_WARNINGS 1
#include &lt;iostream&gt;
#include &lt;string&gt; // 用 C++ 风格的字符串需要包含这个头文件
#include &lt;ctime&gt; // time 系统时间头文件包含
using namespace std;

// 1. 值传递
void Swap01(int a,int b)
{
	int Temp = a;
	a = b;
	b = Temp;

	cout &lt;&lt; "Swap01 a=" &lt;&lt; a &lt;&lt; endl;
	cout &lt;&lt; "Swap01 b=" &lt;&lt; b &lt;&lt; endl;
}
// 2. 地址传递
void Swap02(int* a,int* b)
{
	int Temp = *a;
	*a = *b;
	*b = Temp;

	cout &lt;&lt; "Swap02 a=" &lt;&lt; *a &lt;&lt; endl;
	cout &lt;&lt; "Swap02 b=" &lt;&lt; *b &lt;&lt; endl;
}
// 3. 引用传递
void Swap03(int &amp;a,int &amp;b)
{
	int Temp = a;
	a = b;
	b = Temp;

	cout &lt;&lt; "Swap03 a=" &lt;&lt; a &lt;&lt; endl;
	cout &lt;&lt; "Swap03 b=" &lt;&lt; b &lt;&lt; endl;
}
int main()
{
	int a = 10;
	int b = 20;

	//Swap01(a, b); // 值传递，形参的改变是不会影响到实参的！
	//cout &lt;&lt; "a=" &lt;&lt; a &lt;&lt; endl;
	//cout &lt;&lt; "b=" &lt;&lt; b &lt;&lt; endl;
	//Swap02(&amp;a,&amp;b); // 地址传递，形参的改变是会影响到实参的！
	//cout &lt;&lt; "a=" &lt;&lt; a &lt;&lt; endl;
	//cout &lt;&lt; "b=" &lt;&lt; b &lt;&lt; endl;
	Swap03(a,b); // 引用传递，形参也会修饰到实参！
	cout &lt;&lt; "a=" &lt;&lt; a &lt;&lt; endl;
	cout &lt;&lt; "b=" &lt;&lt; b &lt;&lt; endl;

	system("pause"); // 按任意键继续！
	return 0;
}</code></pre> 
<p><img alt="" height="150" src="https://images2.imgbox.com/a7/28/NgqQZYOp_o.png" width="557"></p> 
<blockquote> 
 <p><span style="color:#0d0016;"><strong>这里来解释一下：</strong><strong>为什么引用也会使得实参发生改变！！！</strong></span></p> 
 <p>        首先引用函数 Swap03 的参数是 int &amp;a，相当于变量 a 起了个别名，别名是可以和原变量一个名字的，别名是具有和原变量相同的功能的；所以这里更改别名相当于更改了原变量；</p> 
</blockquote> 
<h4 id="2.2.4%20%E5%BC%95%E7%94%A8%E5%81%9A%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC"><span style="color:#38d8f0;">2.2.4 引用做函数返回值</span></h4> 
<p>       <span style="color:#0d0016;"> <strong>作用</strong>：</span>引用是可以作为函数的返回值存在的</p> 
<p>        <span style="color:#0d0016;"><strong>注意</strong>：</span>不要返回局部变量引用</p> 
<p><img alt="" height="450" src="https://images2.imgbox.com/2e/d2/eedmV9Wv_o.png" width="837"></p> 
<p><img alt="" height="450" src="https://images2.imgbox.com/c9/c4/XtLAMtSO_o.png" width="702"></p> 
<p><img alt="" height="600" src="https://images2.imgbox.com/a8/a5/iWTAiIvT_o.png" width="712"></p> 
<h4 id="2.2.5%20%E5%BC%95%E7%94%A8%E7%9A%84%E6%9C%AC%E8%B4%A8"><span style="color:#38d8f0;">2.2.5 引用的本质</span></h4> 
<p>        <span style="color:#0d0016;"><strong>本质</strong>：</span>引用的本质在 C++ 内部实现是一个<span style="color:#0d0016;"><strong>指针常量</strong>。</span></p> 
<pre><code>// 1. 引用的本质：指针常量
void function(int&amp; ref) // 发现是引用，转换为 int* const ref = &amp;a;
{
	ref = 100; // ref 是引用，转换为 *ref = 100;
}
int main()
{
	int a = 10;

	int &amp;ref = a;
	// 自动转换为 int* const ref = &amp;a; 指针常量 const 修饰指针常量，指针的指向不可以更改，这也说明了为什么引用不可以更改
	ref = 20; // 当内部发现 ref 是引用之后，会自动的帮我们转换成：*ref = 20;

	system("pause"); // 按任意键继续！
	return 0;
}</code></pre> 
<blockquote> 
 <p><span style="color:#0d0016;"><strong>引用的本质就是指针常量</strong>！</span></p> 
 <p>当我们定义一个局部变量 int a = 10；以后，系统就会自动的在内存中开辟一块内存，并给这块内存起个名字 a，方便我们调用这块内存；然后 int &amp;ref = a；相当于给这块内存起了个别名 ref；实际上编译器底层接收到的是：int* const ref = &amp;a；指针常量；const 修饰 ref，指针的指向是不能发生改变的，这也意味着引用是不能被修改的；ref = 20；在内存中执行的实际上是对指针的解引用，拿到的是一个数据；</p> 
</blockquote> 
<h4 id="2.2.6%20%E5%B8%B8%E9%87%8F%E5%BC%95%E7%94%A8"><span style="color:#38d8f0;">2.2.6 常量引用</span></h4> 
<p>        <span style="color:#0d0016;"><strong>作用</strong>：</span>常量引用主要用来修饰形参，防止误操作</p> 
<p>        在函数形参列表中，可以加 const 修饰形参，防止形参改变实参</p> 
<blockquote> 
 <pre><code>// 1. const修饰形参
void ShowValue(int &amp;Val)
{
	Val = 2000; // 这里通过引用传递形参是可以改变实参的！
	cout &lt;&lt; "Val= " &lt;&lt; Val &lt;&lt; endl;
}
int main()
{
	int a = 10;
	ShowValue(a);

	system("pause"); // 按任意键继续！
	return 0;
}</code></pre> 
 <p><img alt="" height="130" src="https://images2.imgbox.com/ff/62/PzVWmzmg_o.png" width="431"></p> 
</blockquote> 
<blockquote> 
 <pre><code>// 1. const修饰形参
void ShowValue(const int &amp;Val)
{
	//Val = 2000; // 当 const 修饰之后，值就不可以修改，形参的改变也就不会影响到实参
	cout &lt;&lt; "Val= " &lt;&lt; Val &lt;&lt; endl;
}
int main()
{
	int a = 10;
	ShowValue(a);

	system("pause"); // 按任意键继续！
	return 0;
}</code></pre> 
 <p><img alt="" height="100" src="https://images2.imgbox.com/c8/dc/1kTC9d7A_o.png" width="273"></p> 
</blockquote> 
<blockquote> 
 <pre><code>int main()
{
	int a = 10;
	int &amp;ref = a; //这样定义别名是没有问题的
	int &amp;ref = 10; //但是这样定义别名就会出错！
	const int &amp;ref = 10; // 但是如果加上 const 修饰就不会报错了
	// 原因在于编译器：const int &amp;ref = 10; 这行代码的意思是：编译器已经定义某个变量为10,
	// 但是不知道是哪个变量，直接给这个未知的变量起个变量 ref；

	system("pause"); // 按任意键继续！
	return 0;
}</code></pre> 
</blockquote> 
<h3 id="2.3%20%E5%87%BD%E6%95%B0%E9%AB%98%E7%BA%A7"><span style="color:#4da8ee;">2.3 函数高级</span></h3> 
<h4 id="2.3.1%20%E5%87%BD%E6%95%B0%E7%9A%84%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0"><span style="color:#38d8f0;">2.3.1 函数的默认参数</span></h4> 
<p>        在 C++ 中，函数的形参列表中的形参是可以有默认值的</p> 
<p>        <span style="color:#0d0016;"><strong>语法</strong>：</span><span style="background-color:#ffd900;">返回值类型  函数名  (参数 = 默认值) { }</span></p> 
<pre><code>// 函数的默认参数
int Function(int a,int b=20,int c=30)
{
	return a + b + c;
}
// 函数参数初始化的过程中需要注意：
// 如果某个位置已经有了默认参数，那么从这个位置往后，从左到右都必须有默认值
// 意思就是说：如果初始化a=10，那么b和c就必须初始化；
// 如果初始化b=20，那么c就必须初始化，但是a就不用初始化了；
// 如果初始化c=30，那么a和b就都不用初始化；
int Function01(int a, int b = 20, int c = 30)
{
	return a + b + c;
}
int main()
{
	// cout &lt;&lt; Function(10, 20, 30) &lt;&lt; endl; // 计算三个值的和，这个很清楚，应该是60

	// 但是当我们只给其中的一个参数的时候，就会报错！
	// cout &lt;&lt; Function(10) &lt;&lt; endl; // 错误类型：函数调用的参数太少

	// C++ 中规定是可以对函数的参数进行初始化的
	cout &lt;&lt; Function(10) &lt;&lt; endl; // 此时就不会报错，因为int Function(int a,int b=20,int c=30) b 和 c 是有初始值的，此时结果还是60
	cout &lt;&lt; Function(10,30) &lt;&lt; endl; // 此时结果就是70，意思就是说：如果没有默认参数，那么默认使用初始化的 int b = 20；
														   // 如果函数定义了参数，那么使用定义的 30 ；此时结果就是 10+30+30=70；

	system("pause"); // 按任意键继续！
	return 0;
}</code></pre> 
<pre><code>// 在函数声明和函数实现中，只能有一个默认参数
int Function(int a,int b); // 声明的好处就在于：提前告诉编译器有这么一个函数，此时这个函数就可以放在main函数后面了

int Function(int a,int b)
{
	return a + b;
}
// 此时不管是初始化声明还是初始化定义的参数；只能初始化其中的一个；
// int Function(int a=10,int b=10);
/*int Function(int a=10, int b=10)
{
	return a + b;
}*/
// 只能初始化上述两个其中一个;

int main()
{
	

	system("pause"); // 按任意键继续！
	return 0;
}</code></pre> 
<h4 id="2.3.2%20%E5%87%BD%E6%95%B0%E7%9A%84%E5%8D%A0%E4%BD%8D%E5%8F%82%E6%95%B0"><span style="color:#38d8f0;">2.3.2 函数的占位参数</span></h4> 
<p>        C++ 中函数的形参列表里可以有占位参数，用来作占位，调用函数时必须填补该位置</p> 
<p>      <span style="color:#0d0016;">  <strong>语法</strong>：</span><span style="background-color:#ffd900;">返回值类型   函数名 （数据类型） { }</span></p> 
<p>        在现阶段函数的占位参数存在意义不大，但是在后面的课程中会用到该技术</p> 
<p><img alt="" height="500" src="https://images2.imgbox.com/a0/45/QyXzlFs9_o.png" width="796"></p> 
<h4 id="2.3.3%20%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%20-%20%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span style="color:#38d8f0;">2.3.3 函数重载 - 基本语法</span></h4> 
<p>        <span style="color:#0d0016;"><strong>作用</strong>：</span>函数名可以相同，提高复用性</p> 
<blockquote> 
 <p><span style="color:#0d0016;"><strong>函数重载满足条件：</strong></span></p> 
 <p>        同一个作用域下</p> 
 <p>        函数名称相同</p> 
 <p>        函数参数<span style="color:#0d0016;"><strong>类型不同</strong> </span>或者 <span style="color:#0d0016;"><strong>个数不同</strong> </span>或者<span style="color:#0d0016;"> <strong>顺序不同</strong></span></p> 
</blockquote> 
<p>     <span style="color:#0d0016;">   <strong>注意</strong>：</span>函数的返回值不可以作为函数重载的条件</p> 
<pre><code>// 函数重载
// 可以让函数名相同，提高复用性

// 函数重载必须满足条件：
// 1. 同一个作用域下（此时下面的两个函数都在全局域下，也就是都不在main函数里，所以都满足）
// 2. 函数名称相同（这个也满足，两个函数显然名称相同）
// 3. 函数参数类型不同，或者个数不同，或者顺序不同都可以

// void Function()		 void Function(int a)  此时函数参数个数不同
// void Function(int a)		 void Function(double a)  此时函数参数类型不同
// void Function(int a, double b)		 void Function(double a, int b)  此时函数参数顺序不同

void Function()
{
	cout &lt;&lt; "函数的复用性 " &lt;&lt; endl;
}
void Function() 
{
	cout &lt;&lt; "函数的复用性！！！ " &lt;&lt; endl;
}

int main()
{
	Function(); // 此时会报错，程序不知道执行哪个函数

	system("pause"); // 按任意键继续！
	return 0;
}
// 注意事项
// 函数的返回值不可以作为函数重载的条件

// 意思就是说：
// int Function()  和  double Function() 是不能作为函数重载的条件的！！！</code></pre> 
<h4 id="2.3.4%20%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%20-%20%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span style="color:#38d8f0;">2.3.4 函数重载 - 注意事项</span></h4> 
<ul><li>        引用作为重载条件</li><li>        函数重载碰到函数默认参数</li></ul> 
<pre><code>// 函数重载的注意事项
// 1. 引用作为重载的条件
void Func(int &amp;a)
{
	cout &lt;&lt; "Func(int &amp;a)调用 " &lt;&lt; endl;
}
void Func(const int &amp;a)
{
	cout &lt;&lt; "Func(const int &amp;a)调用 " &lt;&lt; endl;
}

// 2. 函数重载碰到默认参数
void Function(int a,int b =10)
{
	cout &lt;&lt; "Func(int &amp;a)调用 " &lt;&lt; endl;
}
void Function(int a)
{
	cout &lt;&lt; "Func(const int &amp;a)调用 " &lt;&lt; endl;
}

int main()
{
	int a = 10;
	Func(a);  // 此时打印的结果是：Func(int &amp;a)调用
	// 因为 int a = 10 是定义一个变量，而 const 修饰的 int &amp;a 是只允许读的，不允许更改，也就是不允许写！！！
	// void Func(int &amp;a) 接收到的是：int &amp;a = a；这是成立的，别名是可以和原名相同的！
	// const int &amp;a = a；这是不成立的！！！

	Func(10);  // 此时打印的结果是：Func(const int &amp;a)调用
	// 因为 void Func(int &amp;a) 接收到的是：int &amp;a = 10；这是不成立的；
	// 但是 const int &amp;a = 10；这个是成立的！！！

	Function(10); // 此时程序就会报错，函数重载碰到默认参数，出现二义性；也就是说Function(10);同时满足 void Function(int a,int b=10) 和 void Function(int a) 的条件，两个函数都可以执行！！！
	// void Function(int a,int b=10) 和 void Function(int a) 满足函数重载的条件
	// 但是在满足函数重载的条件下，同时也满足了默认参数

	Function(10,20); // 这样就没问题， 肯定是走 void Function(int a,int b =10) 这个函数了

	system("pause"); // 按任意键继续！
	return 0;
}
</code></pre> 
<h3 id="2.4%20%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1"><span style="color:#4da8ee;">2.4 类和对象</span></h3> 
<p>        C++ 面向对象的三个特性为：封装、继承、多态</p> 
<p>        C++ 认为万事万物都皆可为对象，对象上有其属性和行为</p> 
<blockquote> 
 <p><span style="color:#0d0016;"><strong>例如：</strong></span></p> 
 <p>        人可以作为对象，属性有姓名、年龄、身高、体重……，行为有走、跑、跳、吃饭……</p> 
 <p>        车也可以作为对象，属性有轮胎、方向盘、车灯……行为有载人、放音乐、放空调……</p> 
 <p>        具有相同性质的对象，我们可以抽象称为类，人属于人类，车属于车类；</p> 
</blockquote> 
<h4 id="2.4.1%20%E5%B0%81%E8%A3%85"><span style="color:#38d8f0;">2.4.1 封装</span></h4> 
<h5 id="2.4.1.1%20%E5%B0%81%E8%A3%85%E7%9A%84%E6%84%8F%E4%B9%89"><span style="color:#a2e043;">2.4.1.1 封装的意义</span></h5> 
<p>        封装是 C++ 面向对象的三大特性之一</p> 
<blockquote> 
 <p><span style="color:#0d0016;"><strong>封装的意义：</strong></span></p> 
 <p>        <span style="color:#0d0016;"><strong>ag. </strong></span>人可以作为对象，属性有姓名、年龄、身高、体重……，行为有走、跑、跳、吃饭……</p> 
 <p>        1. 将属性和行为作为一个整体，表现生活中的事物</p> 
 <p>        2. 将属性和行为加以权限限制</p> 
</blockquote> 
<blockquote> 
 <p><span style="color:#0d0016;"><strong>封装意义一：</strong></span></p> 
 <p>        在设计类的时候，属性和行为写在一起，表现事物</p> 
 <p>        <span style="color:#0d0016;"><strong>语法</strong>：</span>class 类名 {       访问权限： 属性  /  行为    }；</p> 
 <p><br>        <span style="color:#0d0016;"> <strong>示例一</strong>：</span>设计一个圆类，求圆的周长</p> 
 <pre><code>const double π = 3.14; // 圆周率
// 设计一个圆类，来求圆的周长
// 圆求周长的公式：2*PI*半径( 2πr )

// C++ 中当写出一个 class 的时候就代表我们要设计一个类，类后面紧跟着的就是类名称！！！
class Circle
{
	// 类中要包括类的属性和类的行为
	// 访问权限
	// 公共权限
public:

	// 属性
	int m_r; // 半径
	// 行为
	double CalculateZC()  // 计算圆的周长
	{
		return 2 * π*m_r;
	}
};

int main()
{
	// 通过圆类来创建一个具体的圆（对象）
	Circle cl; // Circle 代表类，相当于通过一个类创建一个具体的圆；
	// 给圆对象的属性进行具体的赋值：
	cl.m_r = 10;  // 定义圆的半径为10

	cout &lt;&lt; "圆的周长为： " &lt;&lt; cl.CalculateZC() &lt;&lt; endl;

	system("pause"); // 按任意键继续！
	return 0;
}</code></pre> 
 <p><img alt="" height="150" src="https://images2.imgbox.com/93/79/XRY1JBX6_o.png" width="402"></p> 
 <p>         <span style="color:#0d0016;"><strong>示例二</strong>：</span>设计一个学生类，属性有姓名和学号，可以给姓名和学号赋值，可以显示学生的姓名和学号！</p> 
 <pre><code>// 设计一个学生类，属性有姓名和学号，可以给姓名和学号赋值，可以显示学生的姓名和学号！
class Student
{
public:

	// 属性
	string m_name; // 姓名
	int m_ID; // 学号
	// 行为
	// 1. 显示姓名和学号的函数
	void ShowStudent()
	{
		cout &lt;&lt; "姓名：" &lt;&lt; m_name &lt;&lt;"      "&lt;&lt; "学号：" &lt;&lt; m_ID &lt;&lt; endl;
	}
};

int main()
{
	// 创建一个具体的学生，实例化对象
	Student Stu;
	Stu.m_name = "张三";
	Stu.m_ID = 666;

	Stu.ShowStudent();

	Student STU;
	STU.m_name = "李四";
	STU.m_ID = 888;

	STU.ShowStudent();

	system("pause"); // 按任意键继续！
	return 0;
}</code></pre> 
 <p><img alt="" height="100" src="https://images2.imgbox.com/9b/73/E8KG083o_o.png" width="389"></p> 
 <p> <span style="color:#0d0016;">       <strong>当然也可以通过函数来进行属性的赋值！！！</strong></span></p> 
 <pre><code>// 设计一个学生类，属性有姓名和学号，可以给姓名和学号赋值，可以显示学生的姓名和学号！
class Student
{
public:

	// 属性
	string m_name; // 姓名
	int m_ID; // 学号
	// 行为
	// 1. 显示姓名和学号的函数
	void ShowStudent()
	{
		cout &lt;&lt; "姓名：" &lt;&lt; m_name &lt;&lt;"      "&lt;&lt; "学号：" &lt;&lt; m_ID &lt;&lt; endl;
	}
	// 2. 给姓名赋值
	void SetName(string name)
	{
		m_name = name;
	}
	// 3. 给 ID 号赋值
	void SetID(int ID)
	{
		m_ID = ID;
	}
};

int main()
{
	// 创建一个具体的学生，实例化对象
	Student Stu;
	Stu.SetName("张三");
	Stu.SetID(666);
	Stu.ShowStudent();

	Student STU;
	STU.SetName("李四");
	STU.SetID(888);
	STU.ShowStudent();

	system("pause"); // 按任意键继续！
	return 0;
}</code></pre> 
 <p><img alt="" height="100" src="https://images2.imgbox.com/32/49/icdWpOAh_o.png" width="377"></p> 
 <p>        类中的属性和行为，我们统一称为成员；</p> 
 <p>        类中的属性：成员属性、成员变量</p> 
 <p>        类中的行为：成员函数、成员方法</p> 
</blockquote> 
<blockquote> 
 <p><span style="color:#0d0016;"><strong>封装意义二：</strong></span></p> 
 <p>         类在设计时，可以把属性和行为放在不同的权限下，加以控制</p> 
 <p><span style="color:#0d0016;"><strong>访问权限有三种：</strong></span></p> 
 <p>       <span style="color:#0d0016;"> <strong>1. public         公共权限  </strong> </span>             类内可以访问，类外可以访问（类内指的就是 Class 里面）</p> 
 <p>      <span style="color:#0d0016;">  <strong>2. protected   保护权限    </strong>  </span>          类内可以访问，类外不可以访问</p> 
 <p>    <span style="color:#0d0016;">    <strong>3. private       私有权限 </strong>        </span>        类内可以访问，类外不可以访问</p> 
 <pre><code>// 1. public         公共权限                类内可以访问，类外可以访问（类内指的就是 Class 里面）
// 2. protected   保护权限                类内可以访问，类外不可以访问					儿子可以访问父亲中的保护内容
// 3. private        私有权限                类内可以访问，类外不可以访问					儿子不可以访问父亲的私有内容
class People
{
public:
	// 公共权限
	string m_name; // 姓名
protected:
	// 保护权限
	string m_car;	// 汽车
private:
	// 私有权限
	int m_Password; // 银行卡密码

public: // 类内可以访问，也就是在 class 内部可以访问
	void Function()
	{
		m_name = "张三";
		m_car = "拖拉机";
		m_Password = 123456;
	}
};

int main()
{
	People Stu; // 通过类实例化一个具体的对象
	Stu.m_name = "李四";
	Stu.m_car = "奔驰"; // 保护权限不可以在类外进行访问
	Stu.m_Password = 123; // 私有权限在类外也是不可以访问的

	Stu.Function();

	system("pause"); // 按任意键继续！
	return 0;
}</code></pre> 
 <p><img alt="" height="300" src="https://images2.imgbox.com/de/b2/ouix2b9H_o.png" width="518"></p> 
</blockquote> 
<h5 id="2.4.1.2%20struct%20%E5%92%8C%20class%E7%9A%84%E5%8C%BA%E5%88%AB"><span style="color:#a2e043;">2.4.1.2 struct 和 class的区别</span></h5> 
<p>        在 C++ 中 struct 和 class 唯一的<span style="color:#0d0016;"><strong>区别</strong></span>就在于：<span style="color:#0d0016;"><strong>默认的访问权限不同</strong></span></p> 
<blockquote> 
 <p>区别：</p> 
 <p>        struct 默认权限为公共</p> 
 <p>        class 默认权限为私有</p> 
</blockquote> 
<p><img alt="" height="500" src="https://images2.imgbox.com/bc/cb/GcMfYEro_o.png" width="574"></p> 
<h5 id="2.4.1.3%20%E6%88%90%E5%91%98%E5%B1%9E%E6%80%A7%E8%AE%BE%E7%BD%AE%E4%B8%BA%E7%A7%81%E6%9C%89"><span style="color:#a2e043;">2.4.1.3 成员属性设置为私有</span></h5> 
<p>       <span style="color:#0d0016;"> <strong>优点1</strong>：</span>将所有成员属性设置为私有，可以自己控制读写权限</p> 
<p>        <span style="color:#0d0016;"><strong>优点2</strong>：</span>对于写权限，我们可以检测数据的有效性</p> 
<blockquote> 
 <p><span style="color:#0d0016;"><strong>优点1</strong>：</span>将所有成员属性设置为私有，可以自己控制读写权限</p> 
 <pre><code>// 成员属性设置为私有
// 1. 可以自己控制读写权限
// 2. 对于写可以检测数据有效性

// 人类
class People
{
	// 但是实际的应用中为了保证某些成员变量可读可写
	// 进行如下设置
public:
	void SetName(string name)
	{
		m_Name = name;
	}
	string GetName()
	{
		return m_Name;
	}
	int GetAge()
	{
		return m_Age;
	}
	void SetIdol(string Idol)
	{
		m_Idol = Idol;
	}

private:
	string m_Name; // 姓名 可读可写

	int m_Age=18; // 年龄 只读

	string m_Idol; // 偶像 只写
};

int main()
{
	// 如果类 class 中设置的是 private，所以类外不可以访问；
	People C1;
	C1.SetName("张三");
	cout &lt;&lt; "姓名：" &lt;&lt; C1.GetName() &lt;&lt; endl;
	cout &lt;&lt; "年龄：" &lt;&lt; C1.GetAge() &lt;&lt; endl;

	system("pause"); // 按任意键继续！
	return 0;
}</code></pre> 
</blockquote> 
<blockquote> 
 <p><span style="color:#0d0016;"> <strong>优点2</strong>：</span>对于写权限，我们可以检测数据的有效性</p> 
 <pre><code>// 所谓检测数据有效性就是，假设现在我们可以设置年龄了，但是年龄只能处于0~150岁！
// 加上所谓的限制条件！！！
void SetAge(int Age)
	{
		if (Age&lt;0 || Age&gt;150)
		{
			cout &lt;&lt; "年龄输入有误，赋值失败！" &lt;&lt; endl;
		}
		m_Age = Age;
	}</code></pre> 
</blockquote> 
<blockquote> 
 <p><span style="color:#0d0016;"><strong>练习案例一：</strong></span>设计立方体类</p> 
 <p>        设计立方体类（Cube）</p> 
 <p>        求出立方体的面积和体积</p> 
 <p>        分别用全局函数和成员函数判断两个立方体是否相等</p> 
 <p><img alt="" height="300" src="https://images2.imgbox.com/c9/8e/O9XZEMzk_o.png" width="352"></p> 
 <pre><code>#define _CRT_SECURE_NO_WARNINGS 1
#include &lt;iostream&gt;
#include &lt;string&gt; // 用 C++ 风格的字符串需要包含这个头文件
#include &lt;ctime&gt; // time 系统时间头文件包含
using namespace std;

// 设计立方体类（Cube）
// 求出立方体的面积和体积
// 分别用全局函数和成员函数判断两个立方体是否相等

class Cube
{
public:
	// 行为
	// 设置长宽高和获取长宽高
	void SetLength(int Length)
	{
		m_L = Length;
	}
	int GetLength()
	{
		return m_L;
	}
	void SetWidth(int Width)
	{
		m_W = Width;
	}
	int GetWidth()
	{
		return m_W;
	}
	void SetHigh(int High)
	{
		m_H = High;
	}
	int GetHigh()
	{
		return m_H;
	}
	int S()
	{
		return (m_L*m_W + m_L*m_H + m_H*m_W) * 2;
	}
	int V()
	{
		return m_L*m_H*m_W;
	}

private: // 设置为私有属性，只能类内进行访问
	// 属性
	int m_L; // 长
	int m_W; // 宽
	int m_H; // 高
public:
	// 利用成员函数来判断两个立方体是否相等
	bool IsSameFromClass(Cube &amp;C2)
	{
		if (m_L == C2.GetLength() &amp;&amp; m_W == C2.GetWidth() &amp;&amp; m_H == C2.GetHigh())
		{
			return true;
		}
		return false;
	}
};

// 设置全局函数来判断两个立方体是否相等
bool IsSame(Cube &amp;C1,Cube &amp;C2)
{
	if (C1.GetLength() == C2.GetLength() &amp;&amp; C1.GetWidth() == C2.GetWidth() &amp;&amp; C1.GetHigh() == C2.GetHigh())
	{
		return true;
	}
	return false;
}

int main()
{
	Cube C1;
	C1.SetLength(10);
	C1.SetWidth(20);
	C1.SetHigh(30);
	cout &lt;&lt; "立方体的长度为：" &lt;&lt; C1.GetLength() &lt;&lt; endl;
	cout &lt;&lt; "立方体的宽度为：" &lt;&lt; C1.GetWidth() &lt;&lt; endl;
	cout &lt;&lt; "立方体的高度为：" &lt;&lt; C1.GetHigh() &lt;&lt; endl;
	cout &lt;&lt; "立方体的面积为：" &lt;&lt; C1.S() &lt;&lt; endl;
	cout &lt;&lt; "立方体的体积为：" &lt;&lt; C1.V() &lt;&lt; endl;

	Cube C2;
	C2.SetLength(10);
	C2.SetWidth(20);
	C2.SetHigh(30);
	
	bool ret = IsSame(C1,C2);
	if (ret==true)
	{
		cout &lt;&lt; "C1和C2是相等的！" &lt;&lt; endl;
	}
	else
		cout &lt;&lt; "C1和C2是不相等的！" &lt;&lt; endl;

	// 利用成员函数来判断
	bool Temp = C2.IsSameFromClass(C2);
	if (Temp==true)
	{
		cout &lt;&lt; "成员函数判断：C1和C2是相等的！" &lt;&lt; endl;
	}
	else
		cout &lt;&lt; "成员函数判断：C1和C2是不相等的！" &lt;&lt; endl;

	system("pause"); // 按任意键继续！
	return 0;
}

</code></pre> 
</blockquote> 
<blockquote> 
 <p><span style="color:#0d0016;"><strong>练习案例二</strong>：</span>点和圆的关系</p> 
 <p>        设计一个圆类（Circle），和一个点类（Point），计算点和圆的关系。</p> 
 <p><img alt="" height="200" src="https://images2.imgbox.com/af/69/Ri9sMdYa_o.png" width="542"></p> 
 <pre><code>#define _CRT_SECURE_NO_WARNINGS 1
#include &lt;iostream&gt;
#include &lt;string&gt; // 用 C++ 风格的字符串需要包含这个头文件
#include &lt;ctime&gt; // time 系统时间头文件包含
using namespace std;

// 设计一个圆类（Circle），和一个点类（Point），计算点和圆的关系
class Point
{
public:
	// 设置圆心坐标、获取圆心坐标
	void SetX(int x)
	{
		m_X = x;
	}
	int GetX()
	{
		return m_X;
	}
	void SetY(int y)
	{
		m_Y = y;
	}
	int GetY()
	{
		return m_Y;
	}

private:
	int m_X; // 圆心的 X 轴坐标
	int m_Y; // 圆心的 Y 轴坐标
};

class Circle
{
public:
	// 设置半径、获取半径；
	// 设置圆心、获取圆心；
	void SetR(int R)
	{
		m_R = R;
	}
	int GetR()
	{
		return m_R;
	}
	void SetCenter(Point Center)
	{
		m_Center = Center;
	}
	Point GetCenter()
	{
		return m_Center;
	}
private: // 实际开发中通常把是属性设置为私有类型
	int m_R; // 圆的半径
	Point m_Center; // 圆心
};

// 进行比较
void IsCompareState(Circle &amp;R,Point &amp;Center)
{
	int Distant = // 两个坐标之间的距离
		(R.GetCenter().GetX() - Center.GetX()) * (R.GetCenter().GetX() - Center.GetX()) +
		(R.GetCenter().GetY() - Center.GetY()) * (R.GetCenter().GetY() - Center.GetY());
	// Circle 是圆的类，Point 是对应点的类
	// 我们需要从圆类里面获取圆的坐标，从点类里面获取点的坐标；
	int R_Distant = R.GetR() * R.GetR();  // 半径的平方
	if (Distant == R_Distant)
	{
		cout &lt;&lt; "点在圆上！" &lt;&lt; endl;
	}
	else if (Distant&lt;R_Distant)
	{
		cout &lt;&lt; "点在圆内！" &lt;&lt; endl;
	}
	else
		cout &lt;&lt; "点在圆外！" &lt;&lt; endl;
}

int main()
{
	// 创建圆
	Circle C;
	C.SetR(10);
	Point Center;
	Center.SetX(10); // 这里设置圆心坐标为 (10,0)；
	Center.SetY(0);
	C.SetCenter(Center); // 将圆心坐标放进来

	// 创建点
	Point P;
	P.SetX(10);
	P.SetY(10);

	// 判断它们两者之间的关系
	IsCompareState(C,P);

	system("pause"); // 按任意键继续！
	return 0;
}

</code></pre> 
</blockquote> 
<h4 id="2.4.2%20%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E6%B8%85%E7%90%86"><span style="color:#38d8f0;">2.4.2 对象的初始化和清理</span></h4> 
<p>        生活中我们买的电子产品都基本会有出厂设置，在某一天我们不用的时候也会删除一些自己信息数据保证安全</p> 
<p>        C++ 面向对象来源于生活，每个对象也都会有初始设置以及 对象销毁前的清理数据的设置</p> 
<h5 id="2.4.2.1%20%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span style="color:#a2e043;">2.4.2.1 构造函数和析构函数</span></h5> 
<p>        对象的<span style="color:#0d0016;"><strong>初始化和清理</strong></span>也是两个非常重要的安全问题</p> 
<p>                一个对象或者变量没有初始状态，对其使用后果是未知的</p> 
<p>                同样的使用完一个对象或变量，没有及时清理，也会造成一定的安全问题</p> 
<p>        C++ 利用了构造函数和析构函数解决上述问题，这两个函数将会被编译器自动调用，完成对象的初始化和清理工作！</p> 
<p>        对象的初始化和清理工作是编译器强制我们要做的事情，因此<span style="color:#0d0016;"><strong><span style="background-color:#ffd900;">如果我们不提供构造和析构，编译器会提供编译器提供的构造函数和析构函数是空实现！</span></strong></span></p> 
<p>                <span style="color:#0d0016;"><strong>构造函数</strong>：</span>主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用</p> 
<p>                <span style="color:#0d0016;"><strong>析构函数</strong>：</span>主要作用在于对象<span style="color:#fe2c24;"><strong>销毁前</strong></span>系统自动调用，执行一些清理工作</p> 
<blockquote> 
 <p><span style="color:#0d0016;"><strong>构造函数语法：</strong><strong>类名（）{}</strong></span></p> 
 <p>        1. 构造函数，没有返回值也不写 void</p> 
 <p>        2. 函数名称与类名相同</p> 
 <p>        3. 构造函数可以有参数，因此可以发送重载</p> 
 <p>        4. 程序在调用对象时候会自动调用构造，无须手动调用，而且只会调用一次 （就像我们用手机一样，不用每天起床都要初始化一次）</p> 
 <p><span style="color:#0d0016;"><strong>析构函数语法：~</strong><strong>类名（）{}</strong></span></p> 
 <p>        1. 析构函数，没有返回值也不写 void</p> 
 <p>        2. 函数名称与类名相同，在名称前面加上 ~</p> 
 <p>        3. 析构函数不可以有参数，因此不可以发送重载</p> 
 <p>        4. 程序在对象销毁前会自动调用析构，无须手动调用，而且只会调用一次</p> 
</blockquote> 
<blockquote> 
 <pre><code>// 对象的初始化和清理
// 1. 构造函数  进行初始化操作
class People
{
public:
	// 1.1 构造函数
	// 没有返回值 不用写 void
	// 函数名 与类名相同
	// 构造函数可以有参数，可以发送重载
	// 创建对象的时候，构造函数会自动调用，而且只调用一次
	People()
	{
		cout &lt;&lt; "构造函数的调用" &lt;&lt; endl;
	}
};
void Test01()
{
	People P;
}
// 2. 析构函数  进行清理的操作

int main()
{
	Test01();

	system("pause"); // 按任意键继续！
	return 0;
}</code></pre> 
 <p><img alt="" height="100" src="https://images2.imgbox.com/df/a7/toZMMNYL_o.png" width="457"></p> 
 <p>        通过上述程序可以发现：在测试函数中，只是定义了一个对象 P，而没有去 P.People()，调用这个函数，但是主函数中运行测试函数，依然可以打印；这就再一次证实了构造函数是自动调用的，而且只会调用一次；如果我们不写这样的一个构造函数，那么编译器默认的构造函数是下面这样的：</p> 
 <pre><code>People()
{
    // 无		
}</code></pre> 
</blockquote> 
<blockquote> 
 <pre><code>// 对象的初始化和清理
// 1. 构造函数  进行初始化操作
class People
{
public:
	// 1.1 构造函数
	// 没有返回值 不用写 void
	// 函数名 与类名相同
	// 构造函数可以有参数，可以发送重载
	// 创建对象的时候，构造函数会自动调用，而且只调用一次
	People()
	{
		cout &lt;&lt; "构造函数的调用" &lt;&lt; endl;
	}
	// 2. 析构函数  进行清理的操作
	// 没有返回值 不用写 void
	// 函数名和类名相同 在名称前加 ~
	// 析构函数不可以有参数，也就是不可以发生重载
	// 对象在销毁前会自动调用析构函数，而且只会调用一次
	~People()
	{
		cout &lt;&lt; "析构函数的调用" &lt;&lt; endl;
	}
};
void Test01()
{
	People P;
}


int main()
{
	Test01();

	system("pause"); // 按任意键继续！
	return 0;
}</code></pre> 
 <p><img alt="" height="100" src="https://images2.imgbox.com/a1/df/Ww4zaT7U_o.png" width="380"></p> 
 <p><span style="color:#0d0016;"><strong>这里可以发现：</strong></span>析构函数只是在类里定义，却没有运行，但是最终也打印出了析构函数的调用</p> 
 <p>                        <span style="color:#0d0016;"> <strong>原因在于：</strong></span>主函数运行测试函数 Test01，测试函数内部创建局部变量对象 P，局部变量是存放在栈区的，栈区的生命周期是运行完毕后就会自动的释放！</p> 
 <p>                                           析构函数的原则就是对象在销毁前就会自动调用析构函数，既然局部变量离开函数就会释放内存，也就等价于销毁，那么随之就会调用析构函数！</p> 
 <p>        如果我们不写析构函数的话，那么对应的析构函数是空函数！</p> 
</blockquote> 
<h5 id="2.4.2.2%20%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E5%88%86%E7%B1%BB%E5%8F%8A%E8%B0%83%E7%94%A8"><span style="color:#a2e043;">2.4.2.2 构造函数的分类及调用</span></h5> 
<p><span style="color:#0d0016;"><strong>两种分类方式：</strong></span></p> 
<p>     <span style="color:#0d0016;"><strong>   按参数分为：</strong></span>有参构造和无参构造</p> 
<p>   <span style="color:#0d0016;"><strong>     按类型分为：</strong></span>普通构造和拷贝构造</p> 
<p><span style="color:#0d0016;"><strong>三种调用方法：</strong></span></p> 
<p>        括号法</p> 
<p>        显示法</p> 
<p>        隐式转换法</p> 
<pre><code>// 1. 构造函数的分类及调用
// 分类
class People
{
public:
	// 构造函数
	//		按参数分类	无参构造（默认构造）  和  有参构造
	//		按类型分类   普通构造  和  拷贝构造函数
	People()
	{
		cout &lt;&lt; "People 的无参构造函数调用" &lt;&lt; endl;
	}
	People(int a)
	{
		age = a;
		cout &lt;&lt; "People 的有参构造函数调用" &lt;&lt; endl;
	}
	// 拷贝构造函数
	People(const People &amp;p) // 拷贝 拷贝 就是把原本的构造函数重新复制一份
		// 所以参数就是 People p，因为拷贝的过程中不能改变，所以加上 const 修饰，const People &amp;p这是标准的拷贝函数的参数
	{
		// 拷贝构造函数的使用：就是在原本的构造函数基础上，通过调用实现相同的功能
		// 比如说，上述将输入的年龄a赋值给age
		// 那么拷贝函数中就可以：将传入的人身上的所有属性，拷贝到我身上！
		age = p.age;
		cout &lt;&lt; "People 的拷贝构造函数调用" &lt;&lt; endl;
	}
	// 析构函数
	~People()
	{
		cout &lt;&lt; "People 的析构函数调用" &lt;&lt; endl;
	}

	int age;
};
// 调用
void test01()
{
	// 默认构造函数调用
	People p;

	// 1. 括号法
	People P2(10); // 有参构造函数
	People P3(P2); // 拷贝构造函数

	cout &lt;&lt; "P2的年龄是：" &lt;&lt; P2.age &lt;&lt; endl;
	cout &lt;&lt; "P3的年龄是：" &lt;&lt; P3.age &lt;&lt; endl;

	// 括号法的注意事项：
	//			默认进行构造函数的时候，不要加小括号，也就是不要 People p();
	//			这样编译器会认为是一个函数的声明，不会认为在创建对象！

	// 2. 显示法
	People p1; // 默认函数构造
	People p2 = People(10); // 有参构造
	People p3 = People(p2); // 拷贝构造

	People(10); // 匿名对象  特点：当前执行结束后，系统会自动回收掉匿名对象

	// 注意事项
	// 不要利用拷贝构造函数  初始化匿名对象
	// People(p3); // 编译器会认为这是一个对象的声明

	// 3. 隐式转换法
	People p4 = 10; // 编译器会显示的转换为 People p4 = People(10);
	People p5 = p4; // 拷贝构造
}

int main()
{
	test01();

	system("pause"); // 按任意键继续！
	return 0;
}</code></pre> 
<h5 id="2.4.2.3%20%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%97%B6%E6%9C%BA"><span style="color:#a2e043;">2.4.2.3 拷贝构造函数调用时机</span></h5> 
<p>        C++ 中拷贝构造函数调用时机通常有三种情况：</p> 
<ul><li>                使用一个已经创建完毕的对象来初始化一个新对象</li><li>                值传递的方式给函数参数传值</li><li>                以值方式返回局部对象</li></ul> 
<pre><code>class People
{
public:
	People()
	{
		cout &lt;&lt; "构造函数的调用！" &lt;&lt; endl;
	}
	People(int Age) 
	{
		cout &lt;&lt; "有参构造函数的调用！" &lt;&lt; endl;
		m_Age = Age;
	}
	People(const People &amp;p) // 拷贝构造函数
	{
		cout &lt;&lt; "拷贝构造函数的调用！" &lt;&lt; endl;
		m_Age = p.m_Age;
	}
	~People()
	{
		cout &lt;&lt; "析构函数的调用！" &lt;&lt; endl;
	}
	int m_Age;
};

// 拷贝构造函数的调用时机
// 1. 使用一个已经创建完毕的对象来初始化一个新对象
void test01()
{
	People p1(10); // 有参构造函数
	People p2(p1); // 拷贝构造函数

	cout &lt;&lt; "p2的年龄为：" &lt;&lt; p2.m_Age &lt;&lt; endl;
}
// 2. 值传递的方式给函数参数传值
void doWork(People p) // 此时这种方式也会调用拷贝构造函数
{
	// 因为参数 People p 是值传递，也就是拷贝一个新的 p，这个 p 和函数传参的 p 不是一个 p
	// 此时函数体内 p.m_Age = 1000，实参的年龄仍然不会改变
}
void test02()
{
	People p;
	doWork(p); // 值传递传过去的只是拷贝的值，在拷贝的过程中会调用拷贝构造函数
}
// 3. 值方式返回局部对象
People doWork02()
{
	People p;
	return p; // 这里解释一下：return p，返回的是局部变量 p，局部变量的生命周期仅限于该函数！
	// 但是我的返回类型为 People，相当于离开这个函数之后重新构造了一个People类型的变量，相当于拷贝了一个 p
}
void test03()
{
	People p = doWork02(); // 存在拷贝的过程，因此会调用拷贝构造函数！
}

int main()
{
	// test01();
	//test02();
	test03();

	system("pause"); // 按任意键继续！
	return 0;
}</code></pre> 
<h5 id="2.4.2.4%20%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%A7%84%E5%88%99"><span style="color:#a2e043;">2.4.2.4 构造函数调用规则</span></h5> 
<blockquote> 
 <p><span style="color:#0d0016;"><strong>默认情况下，C++ 编译器至少给一个类添加 3 个函数：</strong></span></p> 
 <p>        1. 默认构造函数（无参，函数体为空）</p> 
 <p>        2. 默认析构函数（无参，函数体为空）</p> 
 <p>        3. 默认拷贝构造函数，对属性进行值拷贝</p> 
 <pre><code>// 默认情况下，C++ 编译器至少给一个类添加 3 个函数：
// 1. 默认构造函数（无参，函数体为空）
// 2. 默认析构函数（无参，函数体为空）
// 3. 默认拷贝构造函数，对属性进行值拷贝

class People
{
public:
	People()
	{
		cout &lt;&lt; "默认构造函数的调用！" &lt;&lt; endl;
	}
	People(int Age)
	{
		m_Age = Age;
		cout &lt;&lt; "有参构造函数的调用！" &lt;&lt; endl;
	}
	People(const People &amp;p)
	{
		cout &lt;&lt; "拷贝构造函数的调用！" &lt;&lt; endl;
		m_Age = p.m_Age;
	}
	~People()
	{
		cout &lt;&lt; "析构函数的调用！" &lt;&lt; endl;
	}
	int m_Age;
};
// 1. 如果用户定义有参构造函数，C++ 不再提供默认无参构造，但是会提供默认拷贝构造

// 2. 如果用户定义拷贝构造函数，C++ 不会再提供其他构造函数

int main()
{
	

	system("pause"); // 按任意键继续！
	return 0;
}</code></pre> 
</blockquote> 
<blockquote> 
 <p><span style="color:#0d0016;"><strong>构造函数调用规则如下：</strong></span></p> 
 <p><span style="color:#0d0016;">        <strong>如果用户定义有参构造函数，C++ 不再提供默认无参构造，但是会提供默认拷贝构造</strong></span></p> 
 <pre><code>// 默认情况下，C++ 编译器至少给一个类添加 3 个函数：
// 1. 默认构造函数（无参，函数体为空）
// 2. 默认析构函数（无参，函数体为空）
// 3. 默认拷贝构造函数，对属性进行值拷贝

class People
{
public:
	/*People()
	{
		cout &lt;&lt; "默认构造函数的调用！" &lt;&lt; endl;
	}*/
	People(int Age)
	{
		m_Age = Age;
		cout &lt;&lt; "有参构造函数的调用！" &lt;&lt; endl;
	}
	People(const People &amp;p)
	{
		cout &lt;&lt; "拷贝构造函数的调用！" &lt;&lt; endl;
		m_Age = p.m_Age;
	}
	~People()
	{
		cout &lt;&lt; "析构函数的调用！" &lt;&lt; endl;
	}
	int m_Age;
};
// 1. 如果用户定义有参构造函数，C++ 不再提供默认无参构造，但是会提供默认拷贝构造
void Test()
{
	People p;
}
// 2. 如果用户定义拷贝构造函数，C++ 不会再提供其他构造函数

int main()
{
	Test();

	system("pause"); // 按任意键继续！
	return 0;
}</code></pre> 
 <p><img alt="" height="150" src="https://images2.imgbox.com/87/6b/IZOYldas_o.png" width="1156"></p> 
 <p>        这里可以发现，上述程序会提示出错：我们屏蔽默认构造函数的代码，同时定义有参构造，这时 C++ 编译器会默认不再提供无参构造，因此通过 Test() 调用默认构造函数会出错！！！</p> 
 <p>        <span style="color:#0d0016;"><strong>如果用户定义拷贝构造函数，C++ 不会再提供其他构造函数</strong></span></p> 
 <pre><code>// 默认情况下，C++ 编译器至少给一个类添加 3 个函数：
// 1. 默认构造函数（无参，函数体为空）
// 2. 默认析构函数（无参，函数体为空）
// 3. 默认拷贝构造函数，对属性进行值拷贝

class People
{
public:
	/*People() 
	{
		cout &lt;&lt; "默认构造函数的调用！" &lt;&lt; endl;
	}*/
	/*People(int Age)
	{
		m_Age = Age;
		cout &lt;&lt; "有参构造函数的调用！" &lt;&lt; endl;
	}*/
	People(const People &amp;p)
	{
		cout &lt;&lt; "拷贝构造函数的调用！" &lt;&lt; endl;
		m_Age = p.m_Age;
	}
	/*~People()
	{
		cout &lt;&lt; "析构函数的调用！" &lt;&lt; endl;
	}*/
	int m_Age;
};
// 1. 如果用户定义有参构造函数，C++ 不再提供默认无参构造，但是会提供默认拷贝构造
void Test()
{
	People p;
}
// 2. 如果用户定义拷贝构造函数，C++ 不会再提供其他构造函数

int main()
{
	Test();

	system("pause"); // 按任意键继续！
	return 0;
}</code></pre> 
 <p><img alt="" height="150" src="https://images2.imgbox.com/04/3a/TImIcgDp_o.png" width="1200"></p> 
 <p>        此时程序依然会出错，因为我们屏蔽其他代码，只留下拷贝构造函数，C++ 编译器默认提供拷贝构造函数的情况下，不再提供其他构造函数！！！</p> 
</blockquote> 
<h5 id="2.4.2.5%20%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D"><span style="color:#a2e043;">2.4.2.5 深拷贝与浅拷贝</span></h5> 
<p>        深浅拷贝是面试的经典问题：</p> 
<p><span style="color:#0d0016;"><strong>浅拷贝</strong>：</span>简单的赋值拷贝操作</p> 
<p><span style="color:#0d0016;"><strong>深拷贝</strong>：</span>在堆区重新申请空间，进行拷贝操作</p> 
<blockquote> 
 <p><span style="color:#0d0016;"><strong>浅拷贝：</strong></span></p> 
 <pre><code>// 浅拷贝：简单的赋值拷贝操作（也就是编译器提供的等号赋值操作）
// 深拷贝：在堆区重新申请空间，进行拷贝操作

class People
{
public:
	People()
	{
		cout &lt;&lt; "People 默认构造函数的调用！" &lt;&lt; endl;
	}
	People(int Age)
	{
		m_Age = Age;
		cout &lt;&lt; "People 有参构造函数的调用！" &lt;&lt; endl;
	}
	~People()
	{
		cout &lt;&lt; "People 析构函数的调用！" &lt;&lt; endl;
	}
	int m_Age; // 年龄
};
void Test()
{
	People p1;
	p1.m_Age = 18; // 这里均为浅拷贝，只是编译器提供的简单的赋值拷贝操作

	cout &lt;&lt; "p1 的年龄为：" &lt;&lt; p1.m_Age &lt;&lt; endl;

	People p2;
	p2.m_Age = 20; // 这里均为浅拷贝，只是编译器提供的简单的赋值拷贝操作

	cout &lt;&lt; "p2 的年龄为：" &lt;&lt; p2.m_Age &lt;&lt; endl;
}

int main()
{
	Test();

	system("pause"); // 按任意键继续！
	return 0;
}</code></pre> 
 <p><img alt="" height="170" src="https://images2.imgbox.com/e1/da/zJdvnRW8_o.png" width="424"></p> 
</blockquote> 
<blockquote> 
 <p><span style="color:#0d0016;"><strong>深拷贝：</strong></span></p> 
 <pre><code>// 浅拷贝：简单的赋值拷贝操作（也就是编译器提供的等号赋值操作）
// 深拷贝：在堆区重新申请空间，进行拷贝操作

class People
{
public:
	People()
	{
		cout &lt;&lt; "People 默认构造函数的调用！" &lt;&lt; endl;
	}
	People(int Age,int Higher)
	{
		m_Age = Age;
		m_Higher = new int(Higher); // new 相当于在堆区开辟相应的内存
		cout &lt;&lt; "People 有参构造函数的调用！" &lt;&lt; endl;
	}
	~People()
	{
		// 既然堆区开辟相应的内存，那么通过析构函数在函数消亡前将对应的内存释放
		if (m_Higher != NULL )
		{
			delete(m_Higher); // 通过 delete 动态释放
			m_Higher = NULL;
		}
		cout &lt;&lt; "People 析构函数的调用！" &lt;&lt; endl;
	}
	int m_Age; // 年龄
	int* m_Higher; // 现在用指针类型定义一个身高，指针指向地址，在堆区开辟相应的内存
};
void Test()
{
	People p1(18,160);// 这里均为浅拷贝，只是编译器提供的简单的赋值拷贝操作

	cout &lt;&lt; "p1 的年龄为：" &lt;&lt; p1.m_Age &lt;&lt;"p1 的身高为："&lt;&lt;*p1.m_Higher&lt;&lt; endl;

	People p2(p1); // 虽然程序没有定义拷贝构造函数，但是编译器自动提供了拷贝构造函数

	cout &lt;&lt; "p2 的年龄为：" &lt;&lt; p2.m_Age &lt;&lt; "p2 的身高为：" &lt;&lt; *p2.m_Higher &lt;&lt; endl;
}

int main()
{
	Test();

	system("pause"); // 按任意键继续！
	return 0;
}</code></pre> 
 <p><img alt="" height="350" src="https://images2.imgbox.com/fc/2e/8ue6Kiwu_o.png" width="617"></p> 
 <p>        上述程序是通过是通过浅拷贝来实现的，但是程序在运行过程中却崩溃了，这里我们来分析一下上述出现这种情况的原因是什么？通过也引出了浅拷贝的致命缺点：对内存的重复释放导致程序出现异常！！！</p> 
 <p><img alt="" height="500" src="https://images2.imgbox.com/2a/31/QUurrVtn_o.png" width="1134"></p> 
 <pre><code>// 浅拷贝：简单的赋值拷贝操作（也就是编译器提供的等号赋值操作）
// 深拷贝：在堆区重新申请空间，进行拷贝操作

class People
{
public:
	People()
	{
		cout &lt;&lt; "People 默认构造函数的调用！" &lt;&lt; endl;
	}
	People(int Age,int Higher)
	{
		m_Age = Age;
		m_Higher = new int(Higher); // new 相当于在堆区开辟相应的内存
		cout &lt;&lt; "People 有参构造函数的调用！" &lt;&lt; endl;
	}
	// 自己创建拷贝构造函数，解决浅拷贝带来的问题
	People(const People &amp;p)
	{
		m_Age = p.m_Age;
		// m_Higher = p.m_Higher; // 现在我们不再采用该代码，因为这行代码是编译器提供的浅拷贝代码，简单的赋值拷贝
		m_Higher = new int(*p.m_Higher); // new 默认返回类型为 int 类型的指针
		cout &lt;&lt; "拷贝构造函数的调用！" &lt;&lt; endl;
	}
	~People()
	{
		// 既然堆区开辟相应的内存，那么通过析构函数在函数消亡前将对应的内存释放
		if (m_Higher != NULL )
		{
			delete(m_Higher); // 通过 delete 动态释放
			m_Higher = NULL;
		}
		cout &lt;&lt; "People 析构函数的调用！" &lt;&lt; endl;
	}
	int m_Age; // 年龄
	int* m_Higher; // 现在用指针类型定义一个身高，指针指向地址，在堆区开辟相应的内存
};
void Test()
{
	People p1(18,160);// 这里均为浅拷贝，只是编译器提供的简单的赋值拷贝操作

	cout &lt;&lt; "p1 的年龄为：" &lt;&lt; p1.m_Age &lt;&lt;"  身高为："&lt;&lt;*p1.m_Higher&lt;&lt; endl;

	People p2(p1); // 虽然程序没有定义拷贝构造函数，但是编译器自动提供了拷贝构造函数

	cout &lt;&lt; "p2 的年龄为：" &lt;&lt; p2.m_Age &lt;&lt; "  身高为：" &lt;&lt; *p2.m_Higher &lt;&lt; endl;
}

int main()
{
	Test();

	system("pause"); // 按任意键继续！
	return 0;
}</code></pre> 
 <p><img alt="" height="150" src="https://images2.imgbox.com/e2/a1/7hLjuMif_o.png" width="426"></p> 
</blockquote> 
<blockquote> 
 <p><span style="color:#0d0016;"><strong>总结：</strong></span></p> 
 <p>        如果属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的问题！</p> 
</blockquote> 
<h5 id="2.4.2.6%20%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8"><span style="color:#a2e043;">2.4.2.6 初始化列表</span></h5> 
<p>      <span style="color:#0d0016;">  <strong>作用</strong>：</span>C++ 提供了初始化列表语法，用来初始化属性</p> 
<p>   <span style="color:#0d0016;">     <strong>语法</strong>：</span>构造函数()：属性1(值1)，属性2(值2)……{ }</p> 
<blockquote> 
 <p><span style="color:#0d0016;"><strong>传统意义上的属性初始化：</strong></span></p> 
 <pre><code>// 之前我们学习了构造函数，并且知道构造函数就是为属性进行初始化用的
// 同时 C++ 也提供了初始化列表的语法

// 构造函数()：属性1(值1)，属性2(值2)……{}
class People
{
public:
	// 传统意义上的属性初始化采用构造函数的形式进行初始化
	People(int a, int b, int c)
	{
		m_A = a;
		m_B = b;
		m_C = c;
	}
	int m_A;
	int m_B;
	int m_C;
};
void Test()
{
	People p(10, 20, 30);
	cout &lt;&lt; "m_A=" &lt;&lt; p.m_A &lt;&lt; endl;
	cout &lt;&lt; "m_B=" &lt;&lt; p.m_B &lt;&lt; endl;
	cout &lt;&lt; "m_C=" &lt;&lt; p.m_C &lt;&lt; endl;
}

int main()
{
	Test();

	system("pause"); // 按任意键继续！
	return 0;
}</code></pre> 
</blockquote> 
<blockquote> 
 <p><span style="color:#0d0016;"><strong>采用 C++ 提供的初始化列表进行初始化</strong></span></p> 
 <pre><code>// 之前我们学习了构造函数，并且知道构造函数就是为属性进行初始化用的
// 同时 C++ 也提供了初始化列表的语法

// 构造函数()：属性1(值1)，属性2(值2)……{}
class People
{
public:
	// 传统意义上的属性初始化采用构造函数的形式进行初始化
	/*People(int a, int b, int c)
	{
		m_A = a;
		m_B = b;
		m_C = c;
	}*/
	People() :m_A(10), m_B(20), m_C(30) // 这就相当于进行了初始化操作
	{

	}
	int m_A;
	int m_B;
	int m_C;
};
void Test()
{
	//People p(10, 20, 30);
	People p;
	cout &lt;&lt; "m_A=" &lt;&lt; p.m_A &lt;&lt; endl;
	cout &lt;&lt; "m_B=" &lt;&lt; p.m_B &lt;&lt; endl;
	cout &lt;&lt; "m_C=" &lt;&lt; p.m_C &lt;&lt; endl;
}

int main()
{
	Test();

	system("pause"); // 按任意键继续！
	return 0;
}</code></pre> 
 <p><img alt="" height="120" src="https://images2.imgbox.com/2c/07/bBCp8N9K_o.png" width="399"></p> 
 <p><span style="color:#fe2c24;"><strong>更灵活的：</strong></span></p> 
 <pre><code>// 之前我们学习了构造函数，并且知道构造函数就是为属性进行初始化用的
// 同时 C++ 也提供了初始化列表的语法

// 构造函数()：属性1(值1)，属性2(值2)……{}
class People
{
public:
	// 传统意义上的属性初始化采用构造函数的形式进行初始化
	/*People(int a, int b, int c)
	{
		m_A = a;
		m_B = b;
		m_C = c;
	}*/
	People(int a,int b,int c) :m_A(a), m_B(b), m_C(c) // 这就相当于进行了初始化操作
	{

	}
	int m_A;
	int m_B;
	int m_C;
};
void Test()
{
	//People p(10, 20, 30);
	People p(30,20,10);
	cout &lt;&lt; "m_A=" &lt;&lt; p.m_A &lt;&lt; endl;
	cout &lt;&lt; "m_B=" &lt;&lt; p.m_B &lt;&lt; endl;
	cout &lt;&lt; "m_C=" &lt;&lt; p.m_C &lt;&lt; endl;
}

int main()
{
	Test();

	system("pause"); // 按任意键继续！
	return 0;
}</code></pre> 
 <p><img alt="" height="120" src="https://images2.imgbox.com/94/94/NsakACvg_o.png" width="409"></p> 
</blockquote> 
<h5 id="2.4.2.7%20%E7%B1%BB%E5%AF%B9%E8%B1%A1%E4%BD%9C%E4%B8%BA%E7%B1%BB%E6%88%90%E5%91%98"><span style="color:#a2e043;">2.4.2.7 类对象作为类成员</span></h5> 
<p>        C++ 类中的成员可以是另一个类的对象，我们称该成员为<span style="color:#0d0016;"> <strong>对象成员</strong></span></p> 
<pre><code>class A {}
class B
{
    A a;
}

// B 类中有对象 A 作为成员，A 为对象成员</code></pre> 
<pre><code>// 类对象作为类成员
// 对象成员
class Phone
{
public:
	Phone(string PName)
	{
		cout &lt;&lt; "Phone 构造函数的调用" &lt;&lt; endl;
		m_PName = PName;
	}
	string m_PName; // 手机的型号
};
class People
{
public:
	People(string Name, string MName) :m_Name(Name), m_Phone(MName)
	{
		cout &lt;&lt; "People 构造函数的调用" &lt;&lt; endl;
	}
	string m_Name; // 姓名
	Phone m_Phone; // 手机
};
void Test()
{
	People p("张三","苹果MAX");
	cout &lt;&lt; p.m_Name &lt;&lt; "拿着：" &lt;&lt; p.m_Phone.m_PName &lt;&lt; endl;
}
int main()
{
	Test();

	system("pause"); // 按任意键继续！
	return 0;
}</code></pre> 
<p><img alt="" height="150" src="https://images2.imgbox.com/48/e6/6izSAvua_o.png" width="461"></p> 
<p></p> 
<blockquote> 
 <p><span style="color:#0d0016;"><strong>结论：</strong></span></p> 
 <p>        通过上述程序可以发现：当一个类作为另一个类的成员时，类内其他对象的构造函数先调用；相反的，类内其他对象的析构函数则后调用！</p> 
</blockquote> 
<h5 id="2.4.2.8%20%E9%9D%99%E6%80%81%E6%88%90%E5%91%98"><span style="color:#a2e043;">2.4.2.8 静态成员</span></h5> 
<p><span style="color:#0d0016;">        </span><strong><span style="color:#0d0016;">静态成员就是在成员变量和成员函数前加上关键字 static</span> </strong>，称其为静态成员</p> 
<p><span style="color:#0d0016;"><strong>静态成员变量：</strong></span></p> 
<ul><li>        所有对象共享同一份数据</li><li>        在编译阶段分配内存</li><li>        类内声明，类外初始化</li></ul> 
<pre><code>// 静态成员变量
class People
{
public:

	// 1. 所有对象都共享同一份数据
	// 2. 编译阶段就分配内存
	// 3. 类内声明，类外初始化操作

	static int m_A; // 类内声明
};

int People::m_A = 100; // 类外初始化

int main()
{	
	People p;
	
	cout &lt;&lt; p.m_A &lt;&lt; endl;

	People p1;
	p1.m_A = 200; 

	cout &lt;&lt; p.m_A &lt;&lt; endl; // 所有对象共享同一份数据
	// 也就是说对象 p1 将 m_A 重新设置为 200
	// 此时用对象 p 去访问，m_A 的值还是 200；

	system("pause"); // 按任意键继续！
	return 0;
}</code></pre> 
<p><span style="color:#0d0016;"><strong>静态成员变量的访问方式：</strong></span></p> 
<p><img alt="" height="600" src="https://images2.imgbox.com/9b/91/344fxusp_o.png" width="444"></p> 
<p><span style="color:#0d0016;"><strong>静态成员变量同样存在访问权限：</strong></span></p> 
<p><img alt="" height="500" src="https://images2.imgbox.com/36/27/nsQKfEbD_o.png" width="660"></p> 
<p><span style="color:#0d0016;"><strong>静态成员函数：</strong></span></p> 
<ul><li>        所有对象共享同一个函数</li><li>        静态成员函数只能访问静态成员变量</li></ul> 
<pre><code>// 静态成员函数
// 1. 所有对象共享同一个函数
// 2. 静态成员函数只能访问静态成员变量 

class People
{
public:
	static void func() // 静态成员函数
	{ 
		m_A = 200; // static void func() 是静态成员函数，因此可以访问静态成员变量 m_A
		m_B = 200; // m_B 不是静态成员变量，因此静态成员函数不可以访问 m_B
		cout &lt;&lt; "static void func() 的调用" &lt;&lt; endl;
	}
	static int m_A; // 静态成员变量
	int m_B;
};

// 静态成员变量必须类内声明，类外访问
int People::m_A = 100;

// 访问静态成员函数
void Test()
{
	// 1. 通过对象进行访问
	People p;
	p.func();

	// 2. 通过类名进行访问
	People::func();
}

int main()
{	
	Test();

	system("pause"); // 按任意键继续！
	return 0;
}

// 之所以 m_B 会报错，是因为 m_B 不是静态成员变量，函数无法判断它属于哪个对象
// 之所以 m_A 就可以，是因为 m_A 是静态成员变量，静态成员变量本身不属于任何对象，它是共享的！</code></pre> 
<h4 id="2.4.3%20C%2B%2B%20%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E5%92%8C%20this%20%E6%8C%87%E9%92%88"><span style="color:#38d8f0;">2.4.3 C++ 对象模型和 this 指针</span></h4> 
<h5 id="2.4.3.1%20%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%92%8C%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E5%88%86%E5%BC%80%E5%AD%98%E5%82%A8"><span style="color:#a2e043;">2.4.3.1 成员变量和成员函数分开存储</span></h5> 
<p><span style="color:#0d0016;">        <strong>在 C++ 中，类内的成员变量和成员函数分开存储</strong></span></p> 
<p><span style="color:#0d0016;"><strong>        只有非静态成员变量才属于类的对象上</strong></span></p> 
<pre><code>// 成员变量 和 成员函数分开存储
class People
{
public:
	int m_A; // 定义一个非静态的成员变量

	static int m_B; // 定义一个静态成员变量

	void Func() // 定义一个非静态的成员函数
	{

	}
	static void Func01(); // 静态成员函数 
};

int People::m_B = 100; // 静态成员变量类内声明，类外初始化

void Test()
{
	People p;
	// 因为上述定义的对象是空的，首先先来看一下空的对象占用多大的内存空间：
	cout &lt;&lt; "Sizeof p =" &lt;&lt; sizeof(p) &lt;&lt; endl;
	// 打印可以显示：空的对象占用1个字节大小的内存
	// 原因在于：C++ 编译器会给每个空对象也分配一个字节空间，是为了区分空对象占内存的位置
	// 简单来说就是：现在假设我创建两个对象 p 和 p1，为了在内存上区别这两个对象，防止这两个对象占用同一块内存

	// Sizeof p =1
}
void Test01()
{
	People p;
	cout &lt;&lt; "Sizeof p =" &lt;&lt; sizeof(p) &lt;&lt; endl; 
	// 此时类中有一个非静态的成员变量
	// 虽然空的对象本身占用1个字节大小，但是这一个字节大小是为了区分不同对象
	// 当类中不为空时，以实际存储的变量为主

	// Sizeof p =4

}
void Test02()
{
	People p;
	cout &lt;&lt; "Sizeof p =" &lt;&lt; sizeof(p) &lt;&lt; endl;
	// 此时类中有一个非静态的成员变量 + 一个静态成员变量
	
	// 之所以 非静态的成员变量 + 一个静态成员变量 打印结果还是 4 
	// 是因为 静态成员变量 不属于任何一个类，它是被共享的
	// Sizeof p =4

}
void Test03()
{
	People p;
	cout &lt;&lt; "Sizeof p =" &lt;&lt; sizeof(p) &lt;&lt; endl;
	// 此时类中有一个非静态的成员变量 + 一个静态成员变量 + 一个非静态的成员函数

	// 之所以 非静态的成员变量 + 一个静态成员变量 + 一个非静态的成员函数 打印结果还是 4 
	// 是因为 非静态成员变量 也是不属于任何一个类，成员变量 和 成员函数分开存储
	// Sizeof p =4

}

int main()
{	 
	// Test();
	//Test01();
	//Test02();
	Test03();

	system("pause"); // 按任意键继续！
	return 0;
}</code></pre> 
<blockquote> 
 <p><span style="color:#0d0016;"><strong>注：</strong></span></p> 
 <p>        只有非静态成员变量才属于类，其余的包括 静态成员变量、非静态成员函数 和 静态成员函数都不属于类；</p> 
 <p>        另外，一个空的对象的大小为 1 字节；</p> 
</blockquote> 
<h5 id="2.4.3.2%20this%20%E6%8C%87%E9%92%88%E6%A6%82%E5%BF%B5"><span style="color:#a2e043;">2.4.3.2 this 指针概念</span></h5> 
<p>        通过上一节的学习，我们知道 C++ 中成员变量和成员函数是分开存储的</p> 
<p>        每一个非静态成员函数只诞生一个函数实例，也就是说多个同类型的对象对共用同一块代码，也就是说多个对象都可以调用这一个非静态成员函数</p> 
<p>        那么如何区分到底是哪一个对象调用的成员函数呢？</p> 
<blockquote> 
 <p>C++ 通过特殊的对象指针，<span style="color:#0d0016;"><strong>this 指针</strong></span>，解决上述问题，<span style="color:#0d0016;"><strong>this 指针指向被调用的成员函数所属的对象</strong></span></p> 
 <p>        this 指针是隐含在每一个非静态成员函数内的一种指针</p> 
 <p>        this 指针不需要定义，直接使用即可</p> 
 <p><span style="color:#0d0016;"><strong>this 指针的用途：</strong></span></p> 
 <p>        当形参和成员变量同名时，可用 this 指针来区分</p> 
 <p>        在类的非静态成员函数中返回对象本身，可使用 return *this</p> 
</blockquote> 
<pre><code>class People
{
public:
	People(int age)
	{
		// this 指针指向 被调用的成员函数所属的对象
		// 解释一下上述这句话：如果不加 this 指针，那么无法区分形参和成员变量age
		// 如果加上this，那么此时this指向被调用的成员函数所属的对象
		// 主函数运行Test01    People p(18); ，this 指针指向被调用的成员函数People(int age)所属的对象
		// 成员函数 People 谁在调用呢？显然是 p，所以this指针指向成员函数所属的 p1；
		this-&gt;age = age;
	}
	People&amp; PeopleAddAge(People p)
	{
		this-&gt;age = this-&gt;age + p.age; // 这段代码的意思就是：调用该函数传进来一个年龄，加到我们已有的age上，实现年龄的加法
		return *this;
	}
	int age;
};

// 1. 解决名称冲突
void Test01()
{
	People p(18); // 通过查看上述代码可以发现：函数的形参和成员变量相同都为age
	// 编译器认为三个 age 都是相同的，所以不存在赋值操作
	cout &lt;&lt; "年龄为：" &lt;&lt;p.age&lt;&lt; endl;
	
	// 最终输出结果  年龄为：-858993460
	// 要想解决这一问题，1. 修改成员变量和形参变得不同；2. 需要引入 this 指针；
	// 加上 this 指针后输出的结果为 ：年龄为：18
}
// 2. 返回对象本身用 *this
void Test02()
{
	People p1(10);
	People p2(10);

	// 下述程序实现把 p2 的年龄加到 p1 上；
	// p2.PeopleAddAge(p1);
	// 打印结果为 20 没有问题

	// 现在我加一次不爽，我想要多加几次
	p2.PeopleAddAge(p1).PeopleAddAge(p1).PeopleAddAge(p1); // 可以看到此时程序在报错
	// 如何更改我们看下述代码：

	// 首先明白出错的原因在于：p2.PeopleAddAge(p1)无返回值，也就是说加一次之后，返回值并不是p2，无法再调用下一个PeopleAddAge(p1)函数
	// 我们给它加上返回值
	// 因为this指向被调用成员函数所属的对象，本身是一个指针，解引用拿到对象本体
	/* People&amp; PeopleAddAge(People p)
	 {
		 this-&gt;age = this-&gt;age + p.age; // 这段代码的意思就是：调用该函数传进来一个年龄，加到我们已有的age上，实现年龄的加法
		 return *this; 
	 }*/
	// 此时程序打印结果为 ： 40

	// 接着看：
	/* People PeopleAddAge(People p)
	{
	this-&gt;age = this-&gt;age + p.age; // 这段代码的意思就是：调用该函数传进来一个年龄，加到我们已有的age上，实现年龄的加法
	return *this;
	}*/
	// 如果函数返回类型为 People，也就是按值返回，在之前的学习中，我们知道，按值返回只是重新拷贝了另一个变量，跟原本的p2是不同的
	// p2.PeopleAddAge(p1).PeopleAddAge(p1).PeopleAddAge(p1); 
	// p2.PeopleAddAge(p1)返回一个 p2'，p2' 和 p2 是截然不同的
	// p2'.PeopleAddAge(p1)返回一个 p2''，p2'' 和 p2 也是截然不同的

	// 所以最终打印结果为 20 ，只有第一次相加是有效的

	cout &lt;&lt; "p2 的年龄为：" &lt;&lt; p2.age &lt;&lt; endl;
}

int main()
{	 
	//Test01();
	Test02();

	system("pause"); // 按任意键继续！
	return 0;
}</code></pre> 
<blockquote> 
 <p><span style="color:#0d0016;"><strong>切记：</strong></span></p> 
 <p>        如果用值来返回，那么会一直产生一个新的变量，每一次产生的变量都是不同的；</p> 
 <p>        如果采用引用来返回，那么每一次返回的都是 p2 ，也就是都是相同的；</p> 
</blockquote> 
<h5 id="2.4.3.3%20%E7%A9%BA%E6%8C%87%E9%92%88%E8%AE%BF%E9%97%AE%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span style="color:#a2e043;">2.4.3.3 空指针访问成员函数</span></h5> 
<p><span style="color:#0d0016;">        <strong>C++ 中空指针也是可以调用成员函数的，但是也要注意有没有用到 this 指针</strong></span></p> 
<p><span style="color:#0d0016;"><strong>        如果用到 this 指针，那么需要加以判断保证代码的健壮性！</strong></span></p> 
<pre><code>// 空指针调用成员函数
class People
{
public:
	void ShowClassName()
	{
		cout &lt;&lt; "void ShowClassName()" &lt;&lt; endl;
	}
	void ShowPeopleAge()
	{
		if (this==NULL)
		{
			return;
		} // 加上上述这个 if 判断语句，如果 this 指针指向 NULL，则直接 return 退出，保证代码的健壮性！
		cout &lt;&lt; "age=" &lt;&lt; m_Age &lt;&lt; endl;
	}
	int m_Age;
};

void Test01()
{
	People* p = NULL;
	p-&gt;ShowClassName(); // 单独运行这个是不会报错的
	p-&gt;ShowPeopleAge();

	// 代码运行的结果是：void ShowClassName()
	// 之所以不运行 age= 
	// 是因为 cout &lt;&lt; "age=" &lt;&lt; m_Age &lt;&lt; endl; 在编译器中
	// 默认 m_Age 之前是有 this 指向的
	// cout &lt;&lt; "age=" &lt;&lt; this-&gt;m_Age &lt;&lt; endl;
	// 这个时候 p 指针初始化为NULL，导致 this 指针指向成员变量所对应的 p 也为NULL，所以系统报异常，导致访问不到指针指向的地址
}

int main()
{	 
	
	Test01();

	system("pause"); // 按任意键继续！
	return 0;
}</code></pre> 
<h5 id="2.4.3.4%20const%20%E4%BF%AE%E9%A5%B0%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span style="color:#a2e043;">2.4.3.4 const 修饰成员函数</span></h5> 
<blockquote> 
 <p><span style="color:#0d0016;"><strong>常函数：</strong></span></p> 
 <p>        成员函数后加 const 我们称这个函数为<span style="color:#0d0016;"><strong>常函数</strong></span></p> 
 <p>        常函数内不可以修改成员属性</p> 
 <p>        成员属性声明时加关键字<span style="color:#0d0016;"> <strong>mutable（英文译为可变的）</strong> </span>后，在常函数中依然可以修改</p> 
 <p><span style="color:#0d0016;"><strong>常对象：</strong></span></p> 
 <p>        声明对象前加 const 称该对象为常对象</p> 
 <p>        常对象只能调用<span style="color:#0d0016;"><strong>常函数</strong></span></p> 
</blockquote> 
<blockquote> 
 <p><span style="color:#0d0016;"><strong>常函数：</strong></span></p> 
 <pre><code>// 常函数：
//		成员函数后加 const 我们称这个函数为常函数
//		常函数内不可以修改成员属性
//		成员属性声明时加关键字 mutable（英文译为可变的） 后，在常函数中依然可以修改
// 常对象：
//		声明对象前加 const 称该对象为常对象
//		常对象只能调用常函数
class People
{
public:
	// this 指针的本质		是指针常量，也就是说指针指向地址的值可以改变，但是指针的指向是不可以发生改变的
	// 如果在成员函数后面加上 const，修饰的是 this 的指向，让指针指向的值也不可以发生改变
	// 相当于 const People* const this
	void ShowPerson() const  // 常函数			此时都会报错！！！
	{
		/*this-&gt;m_A = 100;
		this = NULL;*/
		this-&gt;m_B = 100;
	}
	int m_A;
	mutable int m_B;  // 定义一个新的变量，在常函数中也可以修改值，用 mutable；
};

int main()
{	 
	
	

	system("pause"); // 按任意键继续！
	return 0;
}</code></pre> 
</blockquote> 
<h4 id="2.4.4%20%E5%8F%8B%E5%85%83"><span style="color:#38d8f0;">2.4.4 友元</span></h4> 
<p>        生活中你的家有客厅（Public），有你的卧室（Private）</p> 
<p>        客厅所有来的客人都可以进去，但是你的卧室是私有的，也就是说只有你能进去</p> 
<p>        但是呢，你也可以允许你的好闺蜜好基友进去。</p> 
<p>        <span style="color:#0d0016;"><strong>定义：</strong></span>在程序里，有些私有属性，也想让类外特殊的一些函数或者类进行访问，就需要用到友元的技术</p> 
<p>        <span style="color:#0d0016;"><strong><span style="background-color:#ffd900;">友元的目的就是让一个函数或者类  访问另一个类中的私有成员</span></strong></span></p> 
<p>        友元的关键字为：<span style="color:#0d0016;"><strong><span style="background-color:#ffd900;">friend</span></strong></span></p> 
<blockquote> 
 <p><span style="color:#0d0016;"><strong>友元的三种实现：</strong></span></p> 
 <p>        全局函数做友元</p> 
 <p>        类做友元</p> 
 <p>        成员函数做友元</p> 
</blockquote> 
<blockquote> 
 <p><span style="color:#0d0016;"><strong>全局函数做友元：</strong></span></p> 
 <pre><code>// 全局函数做友元
class Building
{
	// 类似于函数的声明，在函数 void GoodGay(Building *Building); 之前加上关键字 friend
	// 表示 函数void GoodGay(Building *Building);是类的好朋友，此时可以访问私有权限下的属性
	friend void GoodGay(Building *Building);
public:
	Building()
	{
		m_SittingRoom = "客厅";
		m_BedRoom = "卧室"; 
	}
public: // 公共权限，类内可以访问，类外也可以访问
	string m_SittingRoom;  // 客厅
private: // 私人权限，类内可以访问，类外不可以访问
	string m_BedRoom;  // 卧室
};
// 现在通过全局函数做友元，访问私人权限
void GoodGay(Building *Building)
{
	cout &lt;&lt; "好基友全局函数 正在访问：" &lt;&lt; Building-&gt;m_SittingRoom &lt;&lt; endl;

	// cout &lt;&lt; "好基友全局函数 正在访问：" &lt;&lt; Building-&gt;m_BedRoom &lt;&lt; endl; // 如果访问 m_BedRoom 的话，很显然会报错，因为 m_BedRoom 是私人权限下
	// 但是如果加上关键字 friend，就不一样了：
	cout &lt;&lt; "好基友全局函数 正在访问：" &lt;&lt; Building-&gt;m_BedRoom &lt;&lt; endl;
}
void Test()
{
	Building building;
	GoodGay(&amp;building); // 因为 GoodGay 函数的参数是指针类型，所以需要传地址进去
}

int main()
{	 
	Test();

	system("pause"); // 按任意键继续！
	return 0;
}</code></pre> 
 <p><img alt="" height="100" src="https://images2.imgbox.com/15/3a/yPvwBVUg_o.png" width="398"></p> 
</blockquote> 
<blockquote> 
 <p><span style="color:#0d0016;"><strong>类做友元：</strong></span></p> 
 <pre><code>// 类做友元
// 也就是一个类可以访问另一个类中的私有属性
class Building; // 必须声明这个对象，不然 GoodGay 中调用了Building这个类就会报错
class GoodGay
{
public:
	GoodGay();
	void visit(); // 定义visit函数用于去访问Building类的成员属性

	Building *building;
};
class Building
{
	// GoodGay() 是本类的好朋友，可以访问本类的私有属性
	friend class GoodGay;
public:
	Building(); // 构造函数初始化成员属性
public:
	string m_SittingRoom;  // 卧室
private:
	string m_BedRoom; // 客厅
};
// 类外初始化成员属性
Building::Building()
{
	m_SittingRoom = "客厅";
	m_BedRoom = "卧室";
}
GoodGay::GoodGay()
{
	building = new Building; // 相当于在堆区开辟一个对象，让 building 指向这个新开辟的对象
}
void GoodGay::visit()
{
	cout &lt;&lt; "好基友正在访问：" &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;
	cout &lt;&lt; "好基友正在访问：" &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;
}
void Test()
{
	GoodGay gg; // 代码比较乱，下面解释一下这段代码什么意思？
	// 首先给类 GoodGay 创建一个对象gg，首先 GoodGay 就会调用自身的构造函数进行初始化，
	// 初始化中 building = new Building;  相当于在堆区创建一个对象 Building ，Building 就会调用自身的构造函数进行初始化
	// 此时会初始化 m_SittingRoom 和 m_BedRoom；
	gg.visit(); // 通过对象 gg 访问 visit() 
}
int main()
{	 
	Test();
	system("pause"); // 按任意键继续！
	return 0;
}</code></pre> 
 <p><img alt="" height="100" src="https://images2.imgbox.com/67/22/xanPUb91_o.png" width="454"></p> 
</blockquote> 
<blockquote> 
 <p><span style="color:#0d0016;"><strong>成员函数做友元：</strong></span></p> 
 <pre><code>// 类做友元
// 也就是一个类可以访问另一个类中的私有属性
class Building; // 必须声明这个对象，不然 GoodGay 中调用了Building这个类就会报错
class GoodGay
{
public:
	GoodGay();
	void visit(); // 定义visit函数用于去访问Building类的成员属性

	Building *building;
};
class Building
{
	// 这一行代码表示：成员函数做类的友元，也就表示该成员函数是Building的朋友，可以访问私有属性
	// GoodGay::visit(); 这是为了告诉编译器 visit 属于类 GoodGay;
	friend void GoodGay::visit();
public:
	Building(); // 构造函数初始化成员属性
public:
	string m_SittingRoom;  // 卧室
private:
	string m_BedRoom; // 客厅
};
// 类外初始化成员属性
Building::Building()
{
	m_SittingRoom = "客厅";
	m_BedRoom = "卧室";
}
GoodGay::GoodGay()
{
	building = new Building; // 相当于在堆区开辟一个对象，让 building 指向这个新开辟的对象
}
void GoodGay::visit()
{
	cout &lt;&lt; "好基友正在访问：" &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;
	cout &lt;&lt; "好基友正在访问：" &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;
}
void Test()
{
	GoodGay gg; // 代码比较乱，下面解释一下这段代码什么意思？
	// 首先给类 GoodGay 创建一个对象gg，首先 GoodGay 就会调用自身的构造函数进行初始化，
	// 初始化中 building = new Building;  相当于在堆区创建一个对象 Building ，Building 就会调用自身的构造函数进行初始化
	// 此时会初始化 m_SittingRoom 和 m_BedRoom；
	gg.visit(); // 通过对象 gg 访问 visit() 
}
int main()
{
	Test();
	system("pause"); // 按任意键继续！
	return 0;
}</code></pre> 
 <p><img alt="" height="120" src="https://images2.imgbox.com/4b/d0/9naZMKTF_o.png" width="405"></p> 
</blockquote> 
<h4 id="2.4.5%20%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span style="color:#38d8f0;">2.4.5 运算符重载</span></h4> 
<p>        <span style="color:#0d0016;"><strong>运算符重载的概念</strong>：</span>对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型</p> 
<pre><code>// 对于内置的数据类型，编译器是知道如何去运算的
// 何为内置的数据类型，比如说加减乘除等……
int a = 10;
int b = 10;
int c = a + b; // 编译器是知道加法如何运算的

// 但是：
class People
{
public:
	int m_A;
	int m_B;
};
void Test()
{
	People p1;
	p1.m_A = 10;
	p1.m_B = 10;

	People p2;
	p2.m_A = 10;
	p2.m_B = 10;

	People p3 = p1 + p2; // 此时编译器是无法计算诸如这类的加法运算的;
}</code></pre> 
<pre><code>// 通过自己写成员函数，实现两个对象相加属性后返回新的对象
People PeopleAddPerson(People &amp;p) // 保证返回类型是 People 类型
{
	People Temp;
	Temp.m_A = this-&gt;m_A + p.m_A;
	Temp.m_B = this-&gt;m_B + p.m_B;
	return Temp;
}</code></pre> 
<h5 id="2.4.5.1%20%E5%8A%A0%E5%8F%B7%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span style="color:#a2e043;">2.4.5.1 加号运算符重载</span></h5> 
<p>        <span style="color:#0d0016;"><strong>作用</strong>：</span>实现两个自定义数据类型相加的运算</p> 
<blockquote> 
 <p><span style="color:#0d0016;"><strong>成员函数重载加号：</strong></span></p> 
 <pre><code>// 加号运算符重载

class People
{
public:
	// 1. 成员函数重载+号
	People operator+(People &amp;p)
	{
		People Temp;
		Temp.m_A = this-&gt;m_A + p.m_A;
		Temp.m_B = this-&gt;m_B + p.m_B;
		return Temp;
	}

public:
	int m_A;
	int m_B;
};
void Test()
{
	People p1;
	p1.m_A = 10;
	p1.m_B = 10;

	People p2;
	p2.m_A = 10;
	p2.m_B = 10;

	People p3 = p1 +  p2; // 这样会报错，显示没有与这个运算符相匹配的运算符
	// 但是如果上述定义了成员函数重载的话，那么这个加法就不再会报错了

	cout &lt;&lt; "p3.m_A=" &lt;&lt; p3.m_A &lt;&lt; endl;
	cout &lt;&lt; "p3.m_B=" &lt;&lt; p3.m_B &lt;&lt; endl;
}

// 2. 全局函数重载+号


int main()
{
	Test();
	system("pause"); // 按任意键继续！
	return 0;
}</code></pre> 
 <p><img alt="" height="100" src="https://images2.imgbox.com/8e/73/TGmvjOQI_o.png" width="420"></p> 
</blockquote> 
<blockquote> 
 <p><span style="color:#0d0016;"><strong>全局函数重载加号：</strong></span></p> 
 <pre><code>// 加号运算符重载

class People
{
public:
	// 1. 成员函数重载+号
	/*People operator+(People &amp;p)
	{
		People Temp;
		Temp.m_A = this-&gt;m_A + p.m_A;
		Temp.m_B = this-&gt;m_B + p.m_B;
		return Temp;
	}*/

public:
	int m_A;
	int m_B;
};
// 2. 全局函数重载+号
People operator+(People &amp;p1,People &amp;p2)
{
	People Temp;
	Temp.m_A = p1.m_A + p2.m_A;
	Temp.m_B = p1.m_B + p2.m_B;
	return Temp;
}
void Test()
{
	People p1;
	p1.m_A = 10;
	p1.m_B = 10;

	People p2;
	p2.m_A = 10;
	p2.m_B = 10;

	People p3 = p1 +  p2; // 这样会报错，显示没有与这个运算符相匹配的运算符
	// 但是如果上述定义了成员函数重载的话，那么这个加法就不再会报错了

	cout &lt;&lt; "p3.m_A=" &lt;&lt; p3.m_A &lt;&lt; endl;
	cout &lt;&lt; "p3.m_B=" &lt;&lt; p3.m_B &lt;&lt; endl;
}


int main()
{
	Test();
	system("pause"); // 按任意键继续！
	return 0;
}</code></pre> 
 <p><img alt="" height="100" src="https://images2.imgbox.com/90/1e/Rl9wLGGb_o.png" width="428"></p> 
</blockquote> 
<pre><code>// 学到这里，我们要明白：
// People p3 = p1 + p2;
// 成员函数实现运算符重载的本质：
// People p3 = p1.operator+(p2);
// 全局函数实现运算符的本质
// People p3 = operator+(p1,p2);</code></pre> 
<h5 id="2.4.5.2%20%E5%B7%A6%E7%A7%BB%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span style="color:#a2e043;">2.4.5.2 左移运算符重载</span></h5> 
<p>        <span style="color:#0d0016;"><strong>作用</strong>：</span>可以输出自定义数据类型</p> 
<blockquote> 
 <p><span style="color:#0d0016;"><strong>所谓的</strong>：</span>可以输出自定义数据类型的意思就是说：</p> 
 <pre><code>class People
{
public:

	int m_A;
	int m_B;
};
void Test()
{
	People p;
	p.m_A = 10;
	p.m_B = 10;
    // 上述程序很简单，就是创建一个类，定义全局函数 Test 去初始化这个类

	cout &lt;&lt; p &lt;&lt; endl;  // 这句代码显然会出错
	// 上述代码的意思就是打印自定义的数据类型p；
	// 实际上编译器是不知道 p 里面有 m_A 和 m_B 的；
	// 但是通过左移运算符重载可以实现输出自定义的数据类型;
}</code></pre> 
</blockquote> 
<pre><code>// 左移运算符的重载
class People
{
	friend ostream &amp; operator&lt;&lt;(ostream &amp;cout, People &amp;p);
public:
	People(int a, int b)
	{
		m_A = a;
		m_B = b;
	}
private:
	int m_A;
	int m_B;
};
// 采用全局函数进行运算符重载
ostream &amp; operator&lt;&lt;(ostream &amp;cout, People &amp;p)
{
	cout &lt;&lt; "m_A=" &lt;&lt; p.m_A &lt;&lt; " m_B=" &lt;&lt; p.m_B;
	return cout; // 保证链式程序编写
}
void Test()
{
	People p(10,10);
	cout &lt;&lt; p &lt;&lt; endl;
}

int main()
{
	Test();
	system("pause"); // 按任意键继续！
	return 0;
}</code></pre> 
<p><img alt="" height="100" src="https://images2.imgbox.com/0d/2b/aZvqX2Se_o.png" width="472"></p> 
<blockquote> 
 <p><span style="color:#fe2c24;"><strong>这里解释一下：</strong></span></p> 
 <p>        为什么加法运算符重载可以用成员函数实现，也可以使用全局函数实现；而左移运算符只能用全局函数来实现；</p> 
 <p>        因为重载的是cout，如果使用成员函数来实现的话，就是 People operator&lt;&lt;(People &amp;p)，想当于 p&lt;&lt;cout，正好和我们打印输出 cout&lt;&lt;p 是相反的；</p> 
</blockquote> 
<h5 id="2.4.5.3%20%E9%80%92%E5%A2%9E%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span style="color:#a2e043;">2.4.5.3 递增运算符重载</span></h5> 
<p>     <span style="color:#0d0016;"><strong>   作用：</strong></span>通过重载递增运算符，实现自己的整型数据</p> 
<pre><code>// 重载递增运算符

// 自定义整型
class MyInteger
{
	friend ostream&amp; operator&lt;&lt;(ostream&amp; cout, MyInteger &amp;p);
public:
	MyInteger()
	{
		m_Num = 0;
	}
	// 重载前置++运算符
	MyInteger&amp; operator++() // 返回引用是为了一直对一个数据进行递增操作
		// 如果是返回值的话，那么每一次返回的值都不一样，相当于创建了一个新的数据
		// 引用只能初始化一次，是无法改变的；
	{
		m_Num++; // 先进行 ++ 运算
		return *this; // 然后再将自身做返回  (先加加再返回就是前置++的运算流程) 
	}
	// 重载后置++运算符
	MyInteger operator++(int) // 如果不加int，那么前置++和后置++会认为是函数重定义，返回类型是无法区分函数重定义的
		// 加上int，int代表占位参数，可以用于区分前置和后置递增；
	{
		MyInteger Temp = *this;
		m_Num++;
		return Temp; // 后置++就是先加完，然后返回加完之后的值；
		// 需要先定义一个变量记录当前的值，然后加完
		// 完后之前的值
	}// 之所以返回值而不是返回引用，是因为返回引用相当于返回Temp一个局部变量，局部变量的生命周期随函数的消亡而消亡！
	// 离开这个函数，局部变量Temp就无了，相当于非法操作！

private:
	int m_Num;
};
ostream&amp; operator&lt;&lt;(ostream&amp; cout, MyInteger &amp;p) // 左移运算符重载
{
	cout &lt;&lt; "m_Num=" &lt;&lt; p.m_Num;
	return cout;
}
void Test()
{
	MyInteger myint;

	cout &lt;&lt; ++myint &lt;&lt; endl;
	cout &lt;&lt; myint++ &lt;&lt; endl;
}

int main()
{
	Test();
	system("pause"); // 按任意键继续！
	return 0;
}</code></pre> 
<p><img alt="" height="100" src="https://images2.imgbox.com/31/d8/enu6vjHY_o.png" width="463"></p> 
<h5 id="2.4.5.4%20%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span style="color:#a2e043;">2.4.5.4 赋值运算符重载</span></h5> 
<p><span style="color:#0d0016;"><strong>C++ 编译器至少给一个类添加 4 个函数：</strong></span></p> 
<ul><li>        1. 默认构造函数（无参，函数体为空）</li><li>        2. 默认析构函数（无参，函数体为空）</li><li>        3. 默认拷贝构造函数，对属性进行值拷贝</li><li>        4. 赋值运算符 operator=，对属性进行值拷贝</li></ul> 
<p>如果<span style="color:#0d0016;"><strong><span style="background-color:#ffd900;">类中有属性指向堆区</span></strong></span>，做赋值操作时也会出现深浅拷贝问题；</p> 
<blockquote> 
 <p><span style="color:#fe2c24;"><strong>首先先来看这样的一个问题：</strong></span></p> 
 <p><img alt="" height="350" src="https://images2.imgbox.com/0d/1c/Gjc179Ae_o.png" width="470"></p> 
 <p>        <span style="color:#0d0016;"><strong>首先，很明显内置运算符是允许我们进行 a=b=c 的操作的，显然输出的值是 30；<span style="background-color:#ffd900;">那么赋值运算符重载是否允许呢？</span></strong></span></p> 
</blockquote> 
<blockquote> 
 <pre><code>// 赋值运算符重载
class People
{
public:
	People(int age)
	{
		m_Age = new int(age);
	}
	// 堆区开辟的内存需要我们主动去释放掉！
	~People()
	{
		if (m_Age!=NULL) // 开辟内存地址指向不为空
		{
			delete m_Age;
			m_Age = NULL;
		}
	}
	// 重载 赋值运算符
	People&amp; operator=(People &amp;p)
	{
		// 编译器提供的是浅拷贝，也就是最简单的赋值操作
		// m_Age = p.m_Age;

		// 先判断是否有属性在堆区，如果有先释放干净，然后再深拷贝
		if (m_Age!=NULL)
		{
			delete m_Age;
			m_Age = NULL;
		}
		// 深拷贝
		m_Age = new int(*p.m_Age); // 在堆区重新开辟一个和 m_Age 同样大小的空间来存储数据 m_Age;
		// 返回自身
		return *this;
	}
	int *m_Age;
};
void Test()
{
	People p1(18);
	People p2(20);
	People p3(30);

	p3 = p2 = p1; // 赋值操作
	// 赋值操作后，主动的释放掉内存，会报错
	// 此时会出现浅拷贝的问题，导致内存出现重复释放的问题；
	// 需要深拷贝来解决这一问题

	cout &lt;&lt; "p1的年龄为：" &lt;&lt; *p1.m_Age&lt;&lt;endl;
	cout &lt;&lt; "p2的年龄为：" &lt;&lt; *p2.m_Age &lt;&lt; endl;
	cout &lt;&lt; "p3的年龄为：" &lt;&lt; *p3.m_Age &lt;&lt; endl;
}

int main()
{
	Test();
	/*int a = 10;
	int b = 20;
	int c = 30;

	a = b = c;
	cout &lt;&lt; "a=" &lt;&lt; a &lt;&lt; endl;
	cout &lt;&lt; "b=" &lt;&lt; b &lt;&lt; endl;
	cout &lt;&lt; "c=" &lt;&lt; c &lt;&lt; endl;*/

	system("pause"); // 按任意键继续！
	return 0;
}</code></pre> 
 <p><img alt="" height="100" src="https://images2.imgbox.com/c5/2a/1R2XK3kf_o.png" width="397"></p> 
</blockquote> 
<h5 id="2.4.5.5%20%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span style="color:#a2e043;">2.4.5.5 关系运算符重载</span></h5> 
<p>        <span style="color:#0d0016;"><strong>作用：</strong></span>重载关系运算符，可以让两个自定义类型对象进行对比操作</p> 
<pre><code>// 关系运算符重载
class People
{
public:
	People(string Name,int Age)
	{
		m_Name = Name;
		m_Age = Age;
	}
	// 重载等号
	bool operator==(People &amp;p)
	{
		if (this-&gt;m_Name == p.m_Name &amp;&amp; this-&gt;m_Age == p.m_Age)
			return true;
		else
			return false;
	}
	// 重载不等于！=
	bool operator!=(People &amp;p)
	{
		if (this-&gt;m_Name == p.m_Name &amp;&amp; this-&gt;m_Age == p.m_Age)
			return false;
		else
			return true;
	}

	string m_Name;
	int m_Age;
};

void Test()
{
	People p1("Tom",18);
	People p2("Tom", 18);

	if (p1!=p2)
	{
		cout &lt;&lt; "p1 和 p2 是不相等的！" &lt;&lt; endl;
	}
	else
		cout &lt;&lt; "p1 和 p2 是相等的！" &lt;&lt; endl;
}
int main()
{
	Test();
	
	system("pause"); // 按任意键继续！
	return 0;
}</code></pre> 
<p><img alt="" height="100" src="https://images2.imgbox.com/aa/f3/w7192r2L_o.png" width="485"></p> 
<h5 id="2.4.5.6%20%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span style="color:#a2e043;">2.4.5.6 函数调用运算符重载</span></h5> 
<ul><li>        <span style="color:#fe2c24;"><strong>函数调用运算符（）</strong></span>也可以重载</li><li>        由于重载后使用的方式非常像函数的调用，因此称为仿函数</li><li>        仿函数没有固定写法，非常灵活</li></ul> 
<pre><code>// 函数调用运算符重载  小括号()
class MyPrint
{
public:
	// 重载函数调用运算符
	void operator()(string test) // 打印，所以把要打印的字符串作为参数传过来
	{
		cout &lt;&lt; test &lt;&lt; endl;
	}
};

void Test()
{
	MyPrint myprint;
	myprint("Hello World！");
}
// 仿函数非常灵活，接着看
class MyAdd
{
public:
	int operator()(int a,int b)
	{
		return a + b;
	}
};
void Test01()
{
	MyAdd myadd;
	int Temp=myadd(10, 10);
	cout &lt;&lt; "Temp=" &lt;&lt; Temp &lt;&lt; endl;

	// 匿名函数对象
	cout &lt;&lt; MyAdd()(10, 10) &lt;&lt; endl;
	// MyAdd() 这称为匿名对象，MyAdd myadd;则代表给它起了个名字;
}

int main()
{
	Test();
	Test01();
	
	system("pause"); // 按任意键继续！
	return 0;
}</code></pre> 
<p><img alt="" height="120" src="https://images2.imgbox.com/a9/75/w0ydDL5M_o.png" width="446"></p> 
<h4 id="2.4.6%20%E7%BB%A7%E6%89%BF"><span style="color:#38d8f0;">2.4.6 继承</span></h4> 
<p>        <span style="color:#fe2c24;"><strong>继承是面向对象三个特性之一；</strong></span></p> 
<blockquote> 
 <p><span style="color:#0d0016;"><strong>有些类与类之间存在特殊的关系，例如下图中：</strong></span></p> 
 <p><img alt="" height="350" src="https://images2.imgbox.com/53/f3/VR6iie79_o.png" width="987"></p> 
 <p>我们发现，定义这些类时，下级别的成员除了拥有上一级的共性，还有自己的特性</p> 
 <p>这个时候我们就可以考虑利用继承的技术，减少重复代码；</p> 
</blockquote> 
<h5 id="2.4.6.1%20%E7%BB%A7%E6%89%BF%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span style="color:#a2e043;">2.4.6.1 继承的基本语法</span></h5> 
<p>        假设我们要设计一个页面，那么不同页面必不可少的存在相同的部分，页头相同，又或者页尾相同，又或者左侧栏相同；</p> 
<p>        如果借助继承的思想，可明显减少代码量；</p> 
<blockquote> 
 <pre><code>// 普通页面实现
// Jave 页面
class Jave
{
public:
	// 页面的头部、尾部。左侧列表基本上都一样
	void Header()
	{
		cout &lt;&lt; "首页、公开课、登录、注册……（公共头部）" &lt;&lt; endl;
	}
	void footer()
	{
		cout &lt;&lt; "帮助中心、交流合作、站内地图……（公共底部）" &lt;&lt; endl;
	}
	void left()
	{
		cout &lt;&lt; "Jave、Pathon、C++/……（公共分类列表）" &lt;&lt; endl;
	}
	// 一个页面的中心内容，或者可以说是一个页面的核心是不同的
	void conter()
	{
		cout &lt;&lt; "Jave学科视频" &lt;&lt; endl;
	}
};
// Python 页面
class Python
{
public:
	// 页面的头部、尾部。左侧列表基本上都一样
	void Header()
	{
		cout &lt;&lt; "首页、公开课、登录、注册……（公共头部）" &lt;&lt; endl;
	}
	void footer()
	{
		cout &lt;&lt; "帮助中心、交流合作、站内地图……（公共底部）" &lt;&lt; endl;
	}
	void left()
	{
		cout &lt;&lt; "Jave、Pathon、C++/……（公共分类列表）" &lt;&lt; endl;
	}
	// 一个页面的中心内容，或者可以说是一个页面的核心是不同的
	void conter()
	{
		cout &lt;&lt; "Python学科视频" &lt;&lt; endl;
	}
};
// C++ 页面
class CPP
{
public:
	// 页面的头部、尾部。左侧列表基本上都一样
	void Header()
	{
		cout &lt;&lt; "首页、公开课、登录、注册……（公共头部）" &lt;&lt; endl;
	}
	void footer()
	{
		cout &lt;&lt; "帮助中心、交流合作、站内地图……（公共底部）" &lt;&lt; endl;
	}
	void left()
	{
		cout &lt;&lt; "Jave、Pathon、C++/……（公共分类列表）" &lt;&lt; endl;
	}
	// 一个页面的中心内容，或者可以说是一个页面的核心是不同的
	void conter()
	{
		cout &lt;&lt; "C++学科视频" &lt;&lt; endl;
	}
};
void Test()
{
	cout &lt;&lt; "Jave下载视频页面如下：" &lt;&lt; endl;
	Jave jave;
	jave.Header();
	jave.footer();
	jave.left();
	jave.conter();
	cout &lt;&lt; "------------------------- " &lt;&lt; endl;
	cout &lt;&lt; "Python下载视频页面如下：" &lt;&lt; endl;
	Python python;
	python.Header();
	python.footer();
	python.left();
	python.conter();
	cout &lt;&lt; "------------------------- " &lt;&lt; endl;
	cout &lt;&lt; "C++下载视频页面如下：" &lt;&lt; endl;
	CPP cpp;
	cpp.Header();
	cpp.footer();
	cpp.left();
	cpp.conter();
}

int main()
{
	Test();
	
	system("pause"); // 按任意键继续！
	return 0;
}</code></pre> 
 <p><img alt="" height="300" src="https://images2.imgbox.com/9e/22/Cf80dQR7_o.png" width="349"></p> 
 <p>        <span style="color:#0d0016;"><strong>仔细看上述代码：</strong></span>可以发现代码的重复部分很多，在实际的代码编写过程中，应<strong><span style="background-color:#ffd900;">尽可能的避免重复代码的出现</span></strong>；这就需要用到<span style="color:#fe2c24;"><strong>继承</strong></span>；</p> 
</blockquote> 
<blockquote> 
 <p><span style="color:#fe2c24;"><strong>继承的思想：</strong></span></p> 
 <p><span style="color:#0d0016;"><strong>继承的好处：</strong></span>可以减少重复代码</p> 
 <p><span style="color:#0d0016;"><strong>语法：</strong></span><span style="background-color:#ffd900;">class 子类 : 继承方式  父类</span></p> 
 <p><span style="color:#0d0016;"><strong>子类：</strong></span>也称为  <span style="background-color:#ffd900;">派生类</span></p> 
 <p><span style="color:#0d0016;"><strong>父类：</strong></span>也称为  <span style="background-color:#ffd900;">基类</span></p> 
 <pre><code>// 普通页面实现
// 继承思想实现页面
// 公共页面，大家都具有的元素
class BasePage
{
public:
	// 页面的头部、尾部。左侧列表基本上都一样
	void Header() 
	{
		cout &lt;&lt; "首页、公开课、登录、注册……（公共头部）" &lt;&lt; endl;
	}
	void footer()
	{
		cout &lt;&lt; "帮助中心、交流合作、站内地图……（公共底部）" &lt;&lt; endl;
	}
	void left()
	{
		cout &lt;&lt; "Jave、Pathon、C++/……（公共分类列表）" &lt;&lt; endl;
	}
};
// Jave 页面
class Jave :public BasePage // 继承思想下，class Jave 是不断的，加上冒号，public BasePage 表示公共的部分，
	// 也就表示 Jave 这个类默认调用公共的类：public BasePage
{
public:
	void center()
	{
		cout &lt;&lt; "Jave 网课视频" &lt;&lt; endl;
	}
};
// C++ 页面
class CPP:public BasePage
{
public:
	void center()
	{
		cout &lt;&lt; "C++ 网课视频" &lt;&lt; endl;
	}
};
// Python 页面
class Python:public BasePage
{
public:
	void center()
	{
		cout &lt;&lt; "Python 网课视频" &lt;&lt; endl;
	}
};

void Test()
{
	cout &lt;&lt; "Jave下载视频页面如下：" &lt;&lt; endl;
	Jave jave;
	jave.Header();
	jave.footer();
	jave.left();
	jave.center();
	cout &lt;&lt; "------------------------- " &lt;&lt; endl;
	cout &lt;&lt; "Python下载视频页面如下：" &lt;&lt; endl;
	Python python;
	python.Header();
	python.footer();
	python.left();
	python.center();
	cout &lt;&lt; "------------------------- " &lt;&lt; endl;
	cout &lt;&lt; "C++下载视频页面如下：" &lt;&lt; endl;
	CPP cpp;
	cpp.Header();
	cpp.footer();
	cpp.left();
	cpp.center();
}

int main()
{
	Test();
	
	system("pause"); // 按任意键继续！
	return 0;
}
</code></pre> 
 <p><img alt="" height="300" src="https://images2.imgbox.com/1b/b5/WcLCybt9_o.png" width="405"></p> 
</blockquote> 
<h5 id="2.4.6.2%20%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F"><span style="color:#a2e043;">2.4.6.2 继承方式</span></h5> 
<p><span style="color:#0d0016;"><strong>继承的语法：</strong></span><span style="background-color:#ffd900;">class 子类 : 继承方式  父类</span></p> 
<blockquote> 
 <p><span style="color:#0d0016;"><strong>继承方式一共有三种：</strong></span></p> 
 <ul><li>        公共继承</li><li>        保护继承</li><li>        私有继承</li></ul> 
</blockquote> 
<p><img alt="" height="500" src="https://images2.imgbox.com/eb/e3/rh6irfQa_o.png" width="676"></p> 
<blockquote> 
 <p><span style="color:#0d0016;"><strong>上述流程图的意思就是说：</strong></span></p> 
 <p>        <span style="color:#0d0016;"><strong>继承</strong></span>主要分为<span style="color:#0d0016;"><strong>公共继承</strong></span>、<span style="color:#0d0016;"><strong>保护继承</strong></span>和<span style="color:#0d0016;"><strong>私有继承</strong></span>；</p> 
 <p>        继承不管是哪种继承，父类中的私有属性三种继承都不可以访问；（也可以理解为父类也是有隐私的，子类不可以访问）</p> 
 <p>        如果是<span style="color:#fe2c24;"><strong>共用继承</strong></span>，Public，那么父类中成员属性属于哪个类，共有继承得到的就是哪个类</p> 
 <p>        如果是<span style="color:#fe2c24;"><strong>保护继承</strong></span>，Protected，那么父类中不管属性是属于哪个类，保护继承得到的都属于保护权限；</p> 
 <p>        如果是<span style="color:#fe2c24;"><strong>私有继承</strong></span>，Private，那么父类中不管属性是属于哪个类，私有继承得到的都属于私有权限；</p> 
</blockquote> 
<blockquote> 
 <p> <img alt="" height="500" src="https://images2.imgbox.com/b5/e7/FbDtrjvn_o.png" width="545"></p> 
 <p><img alt="" height="450" src="https://images2.imgbox.com/bb/91/k0NqwgXj_o.png" width="881"></p> 
 <p><img alt="" height="400" src="https://images2.imgbox.com/51/b0/8N2wlK86_o.png" width="660"></p> 
</blockquote> 
<h5 id="2.4.6.3%20%E7%BB%A7%E6%89%BF%E4%B8%AD%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B"><span style="color:#a2e043;">2.4.6.3 继承中的对象模型</span></h5> 
<p>        <span style="color:#0d0016;"><strong>本部分主要解决一个问题：</strong></span><span style="background-color:#ffd900;">从父类继承过来的成员，哪些属于子类对象中？</span></p> 
<pre><code>// 继承中的对象模型
// 父类
class Father
{
public:
	int m_A;
protected:
	int m_B;
private:
	int m_C;
};

class Son :public Father
{
public:
	int m_D;
};
void Test()
{
	Son son;
	// 父类中非静态的成员属性都会被子类所继承下去
	cout &lt;&lt; "Size Of Son=" &lt;&lt; sizeof(son) &lt;&lt; endl; // 16
	// 这个16是子类的4个字节m_D+父类的 m_A、m_B、m_C 12个字节
	// 这里可能会有疑问，私有属性不是不可以访问吗？
	// 事实上，父类中私有属性是被编译器给隐藏了，因此是访问不到，但是确实被继承下去了
}

int main()
{
	Test();
	
	system("pause"); // 按任意键继续！
	return 0;
}</code></pre> 
<h5 id="2.4.6.4%20%E7%BB%A7%E6%89%BF%E4%B8%AD%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84%E9%A1%BA%E5%BA%8F"><span style="color:#a2e043;">2.4.6.4 继承中构造和析构顺序</span></h5> 
<p>        <span style="background-color:#ffd900;">子类继承父类后，当创建子类对象，也会调用父亲的构造函数。</span></p> 
<p>        <span style="color:#0d0016;"><strong>问题：</strong></span>父类和子类的构造和析构顺序是谁先谁后呢？</p> 
<pre><code>// 继承中的构造和析构的顺序
class Father
{
public:
	Father()
	{
		cout &lt;&lt; "Father 的构造函数" &lt;&lt; endl;
	}
	~Father()
	{
		cout &lt;&lt; "Father 的析构函数" &lt;&lt; endl;
	}
};
class Son :public Father
{
public:
	Son()
	{
		cout &lt;&lt; "Son 的构造函数" &lt;&lt; endl;
	}
	~Son()
	{
		cout &lt;&lt; "Son 的析构函数" &lt;&lt; endl;
	}
};
void Test()
{
	Son son; // 调用子类的对象，那么子类的对象对同时的调用父类的默认函数！
}

int main()
{
	Test();
	
	system("pause"); // 按任意键继续！
	return 0;
}</code></pre> 
<p><img alt="" height="130" src="https://images2.imgbox.com/2f/75/mKJfSMmp_o.png" width="430"></p> 
<blockquote> 
 <p><span style="color:#fe2c24;"><strong>综上所述：</strong></span></p> 
 <p>        继承中的构造和析构的顺序是：<span style="color:#0d0016;"><strong>先有父类的构造，再有子类的构造；析构的顺序和构造顺序是相反的；（这也很好理解，先有父亲然后才能再有儿子）</strong></span></p> 
</blockquote> 
<h5 id="2.4.6.5%20%E7%BB%A7%E6%89%BF%E5%90%8C%E5%90%8D%E6%88%90%E5%91%98%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F"><span style="color:#a2e043;">2.4.6.5 继承同名成员处理方式</span></h5> 
<p>        <span style="color:#fe2c24;"><strong>问题：</strong></span>当子类与父类出现同名的成员，如何通过子类对象，访问到子类或父类中同名的数据呢？</p> 
<ul><li>        访问子类同名成员        直接访问即可</li><li>        访问父类同名成员        需要加作用域</li></ul> 
<blockquote> 
 <p><span style="color:#fe2c24;"><strong>同名成员变量：</strong></span></p> 
 <pre><code>// 继承中同名成员处理方式
class Father
{
public:
	Father()
	{
		m_A = 100;
	}
	int m_A;
};
class Son :public Father
{
public:
	Son()
	{
		m_A = 200;
	}
	int m_A;
};
void Test()
{
	Son son; 
	cout &lt;&lt; "m_A=" &lt;&lt; son.m_A &lt;&lt; endl; // 当子类和父类成员变量出现同名的情况时，直接访问得到的是子类的成员变量，此时打印的是200
	// 要想要通过子类访问父类的同名成员变量，需要加作用域
	cout &lt;&lt; "m_A=" &lt;&lt; son.Father::m_A &lt;&lt; endl; // 当加上作用域 Father 表示访问的是父类，此时打印的是 100；
}

int main()
{
	Test();
	
	system("pause"); // 按任意键继续！
	return 0;
}</code></pre> 
 <p><img alt="" height="100" src="https://images2.imgbox.com/ae/46/Ma25vcw1_o.png" width="375"></p> 
</blockquote> 
<blockquote> 
 <p><span style="color:#fe2c24;"><strong>同名成员函数：</strong></span></p> 
 <pre><code>// 继承中同名成员处理方式
class Father
{
public:
	Father()
	{
		m_A = 100;
	}
	void Func()
	{
		cout &lt;&lt; "Father 下成员函数Func（）的调用：" &lt;&lt; endl;
	}
	int m_A;
};
class Son :public Father
{
public:
	Son()
	{
		m_A = 200;
	}
	void Func()
	{
		cout &lt;&lt; "Son 下成员函数Func（）的调用：" &lt;&lt; endl;
	}
	int m_A;
};
void Test()
{
	Son son; 
	cout &lt;&lt; "m_A=" &lt;&lt; son.m_A &lt;&lt; endl; // 当子类和父类成员变量出现同名的情况时，直接访问得到的是子类的成员变量，此时打印的是200
	// 要想要通过子类访问父类的同名成员变量，需要加作用域
	cout &lt;&lt; "m_A=" &lt;&lt; son.Father::m_A &lt;&lt; endl; // 当加上作用域 Father 表示访问的是父类，此时打印的是 100；
}
// 成员函数同名的处理法则
void Test01()
{
	Son ss;
	ss.Func(); // 成员函数同名，直接访问的仍然是子类的成员函数，打印的结果是：Son 下成员函数Func（）的调用：
	// 要想通过子类访问父类同名的成员函数，同样需要加作用域
	ss.Father::Func(); // 当成员函数同名时，需要加上作用域，表示Func成员函数属于Father类；此时打印的结果是：Father 下成员函数Func（）的调用：
}

int main()
{
	// Test();
	Test01();
	
	system("pause"); // 按任意键继续！
	return 0;
}</code></pre> 
 <p><span style="color:#0d0016;"><strong>注意：</strong></span>如果子类中出现和父类同名的成员函数，子类的同名成员函数会隐藏掉父类中所有同名成员函数！</p> 
 <p>           <span style="color:#0d0016;"><strong>这个意思就是说</strong></span>：假设子类中有一个成员函数，但是父类中有100个成员函数，只要这100个成员函数中有一个成员函数和子类的成员函数同名，那么子类的这一个成员函数会隐藏掉父类中100个成员函数，这个需要特别注意，不是隐藏一个，而是隐藏掉100个成员函数，如果程序中调用父类的成员函数，就会报错，因为被隐藏掉了，需要加作用域；</p> 
</blockquote> 
<h5 id="2.4.6.6%20%E7%BB%A7%E6%89%BF%E5%90%8C%E5%90%8D%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F"><span style="color:#a2e043;">2.4.6.6 继承同名静态成员处理方式</span></h5> 
<p>        <span style="color:#0d0016;"><strong>问题：</strong></span>继承中同名的静态成员在子类对象上如何进行访问？</p> 
<p>        静态成员和非静态成员出现同名，处理方式一致</p> 
<ul><li>        访问子类同名成员        直接访问即可</li><li>        访问父类同名成员        需要加作用域</li></ul> 
<blockquote> 
 <p><span style="color:#fe2c24;"><strong>同名静态变量访问：</strong></span></p> 
 <pre><code>// 继承中同名静态成员处理方式
class Father
{
public:
	static int m_A; 
	// 1. 静态成员变量类内声明，类外初始化！
	// 2. 所有变量共享一个函数域！
	// 3. 静态成员变量在编译时就分配内存！
};
int Father::m_A = 100;
class Son :public Father
{
public:
	static int m_A;
	// 1. 静态成员变量类内声明，类外初始化！
	// 2. 所有变量共享一个函数域！
	// 3. 静态成员变量在编译时就分配内存！
};
int Son::m_A = 200;
void Test()
{
	// 1. 静态成员变量可以通过类来访问
	cout &lt;&lt; "通过对象来访问：" &lt;&lt; endl;
	Son son;
	cout &lt;&lt; "m_A=" &lt;&lt; son.m_A &lt;&lt; endl; // 直接访问的是子类的静态成员变量
	cout &lt;&lt; "m_A=" &lt;&lt; son.Father::m_A  &lt;&lt; endl; // 加上作用域访问的就是父类的静态成员变量

	// 2. 静态成员变量还可以通过类名来访问
	cout &lt;&lt; "通过类名来访问：" &lt;&lt; endl;
	cout &lt;&lt; "m_A=" &lt;&lt; Son::m_A &lt;&lt; endl; // 直接访问的是子类的静态成员变量
	cout &lt;&lt; "m_A=" &lt;&lt; Son::Father::m_A &lt;&lt; endl; // 加上作用域访问的就是父类的静态成员变量
}

int main()
{
	Test();
	
	system("pause"); // 按任意键继续！
	return 0;
}</code></pre> 
 <p><img alt="" height="150" src="https://images2.imgbox.com/df/d8/j7B1mJOi_o.png" width="404"></p> 
</blockquote> 
<blockquote> 
 <p><span style="color:#fe2c24;"><strong>同名静态函数访问：</strong></span></p> 
 <pre><code>// 继承中同名静态成员处理方式
class Father
{
public:
	static int m_A; 
	// 1. 静态成员变量类内声明，类外初始化！
	// 2. 所有变量共享一个函数域！
	// 3. 静态成员变量在编译时就分配内存！
	static void Func()
	{
		cout &lt;&lt; "父类下同名函数 Func() 的调用：" &lt;&lt; endl;
	}
};
int Father::m_A = 100;
class Son :public Father
{
public:
	static int m_A;
	// 1. 静态成员变量类内声明，类外初始化！
	// 2. 所有变量共享一个函数域！
	// 3. 静态成员变量在编译时就分配内存！
	static void Func()
	{
		cout &lt;&lt; "子类下同名函数 Func() 的调用：" &lt;&lt; endl;
	}
};
int Son::m_A = 200;
void Test()
{
	// 1. 静态成员变量可以通过类来访问
	cout &lt;&lt; "通过对象来访问：" &lt;&lt; endl;
	Son son;
	cout &lt;&lt; "m_A=" &lt;&lt; son.m_A &lt;&lt; endl; // 直接访问的是子类的静态成员变量
	cout &lt;&lt; "m_A=" &lt;&lt; son.Father::m_A  &lt;&lt; endl; // 加上作用域访问的就是父类的静态成员变量

	// 2. 静态成员变量还可以通过类名来访问
	cout &lt;&lt; "通过类名来访问：" &lt;&lt; endl;
	cout &lt;&lt; "m_A=" &lt;&lt; Son::m_A &lt;&lt; endl; // 直接访问的是子类的静态成员变量
	cout &lt;&lt; "m_A=" &lt;&lt; Son::Father::m_A &lt;&lt; endl; // 加上作用域访问的就是父类的静态成员变量
}
void Test01()
{
	// 1. 静态成员函数可以通过类来访问
	cout &lt;&lt; "通过对象来访问：" &lt;&lt; endl;
	Son son;
	son.Func(); // 直接访问的是子类的静态成员函数
	son.Father::Func(); // 加上作用域访问的就是父类的静态成员函数

	// 2. 静态成员函数还可以通过类名来访问
	cout &lt;&lt; "通过类名来访问：" &lt;&lt; endl;
	Son::Func(); // 直接访问的是子类的静态成员函数
	Son::Father::Func(); // 加上作用域访问的就是父类的静态成员函数
}

int main()
{
	Test01();
	
	system("pause"); // 按任意键继续！
	return 0;
}</code></pre> 
 <p><img alt="" height="150" src="https://images2.imgbox.com/e9/dd/TjZ3JnHb_o.png" width="385"></p> 
 <p><span style="color:#0d0016;"><strong>注意：</strong></span>如果子类中出现和父类同名的成员函数，子类的同名成员函数会隐藏掉父类中所有同名成员函数！</p> 
 <p>           <span style="color:#0d0016;"><strong>这个意思就是说</strong></span>：假设子类中有一个成员函数，但是父类中有100个成员函数，只要这100个成员函数中有一个成员函数和子类的成员函数同名，那么子类的这一个成员函数会隐藏掉父类中100个成员函数，这个需要特别注意，不是隐藏一个，而是隐藏掉100个成员函数，如果程序中调用父类的成员函数，就会报错，因为被隐藏掉了，需要加作用域；</p> 
</blockquote> 
<h5 id="2.4.6.7%20%E5%A4%9A%E7%BB%A7%E6%89%BF%E8%AF%AD%E6%B3%95"><span style="color:#a2e043;">2.4.6.7 多继承语法</span></h5> 
<p>      <span style="color:#fe2c24;"><strong>  C ++ 中允许一个类继承多个类</strong></span></p> 
<p>       <span style="color:#fe2c24;"><strong> 语法：</strong></span><span style="background-color:#ffd900;">class 子类：继承方式  父类1，继承方式  父类2……</span></p> 
<p>        多继承可能会引发父类中有同名成员出现，需要加作用域区分</p> 
<p>        <span style="color:#fe2c24;"><strong>C++ 在实际的开发中不建议使用多继承</strong></span></p> 
<pre><code>// 多继承语法
class Father1
{
public:
	Father1()
	{
		m_A = 100;
	}
	int m_A;
};
class Father2
{
public:
	Father2()
	{
		m_A = 200;
	}
	int m_A;
};
// 多继承，Son 同时继承Father1和Father2
class Son :public Father1, public Father2
{
public:
	Son()
	{
		m_C = 300;
		m_D = 400;
	}
	int m_C;
	int m_D;
};
void Test()
{
	Son son; // 因为此时子类son同时继承了两个父类
				  // 此时如果要访问m_A，那么究竟访问的是Father1中的m_A还是Father2中的m_A，我们不得而知！
	cout &lt;&lt; "Father1 中的m_A=" &lt;&lt; son.Father1::m_A &lt;&lt; endl;
	cout &lt;&lt; "Father2 中的m_A=" &lt;&lt; son.Father2::m_A &lt;&lt; endl;
}
int main()
{
	Test();
	
	system("pause"); // 按任意键继续！
	return 0;
}</code></pre> 
<p><img alt="" height="100" src="https://images2.imgbox.com/e6/8c/zmS6cJr1_o.png" width="370"></p> 
<h5 id="2.4.6.8%20%E8%8F%B1%E5%BD%A2%E7%BB%A7%E6%89%BF"><span style="color:#a2e043;">2.4.6.8 菱形继承</span></h5> 
<p>        <span style="color:#0d0016;"><strong>菱形继承是继承机制中一个非常有意思的现象：</strong></span></p> 
<blockquote> 
 <p><span style="color:#0d0016;"><strong>菱形继承的概念：</strong></span></p> 
 <p>        两个派生类（子类）继承同一个基类（父类）</p> 
 <p>        又有某个类同时继承着两个派生类</p> 
 <p>        这种继承被称为<span style="color:#0d0016;"><strong>菱形继承</strong></span>，或者<span style="color:#0d0016;"><strong>钻石继承</strong></span></p> 
</blockquote> 
<pre><code>// 动物类
class Animal
{
public:
	int m_Age;
};
// 羊类
// 利用虚继承可以解决菱形继承带来的问题
// 继承之前  加上关键字 virtual 变为虚继承
// Animal 类称为：虚基类

class Sheep :virtual public Animal
{

};
//驼类
class Tuo :virtual public Animal
{

};
// 羊驼类
class SheepTuo :public Sheep, public Tuo
{

};
void Test()
{
	SheepTuo ss;
	ss.Sheep::m_Age = 18; // 羊类继承而来的年龄为18
	ss.Tuo::m_Age = 20; // 驼类继承来的年龄为20

	// 1. 当菱形继承时，两个父类拥有相同的数据，需要加以作用域区分
	cout &lt;&lt; "ss.Sheep::m_Age=" &lt;&lt; ss.Sheep::m_Age &lt;&lt; endl;
	cout &lt;&lt; "ss.Tuo::m_Age=" &lt;&lt; ss.Tuo::m_Age &lt;&lt; endl;
	// 2. 这份数据我们知道，菱形继承导致数据有两份，也就是说羊驼类继承羊类和驼类，会分别得到其中的年龄
	//     由于这两个年龄都是从动物类继承而来的，所以数据是相同的，两份会导致数据重叠，导致资源浪费！！！

}
int main()
{
	Test();
	
	system("pause"); // 按任意键继续！
	return 0;
}</code></pre> 
<p><img alt="" height="100" src="https://images2.imgbox.com/75/91/eW5HcF58_o.png" width="392"></p> 
<h4 id="2.4.7%20%E5%A4%9A%E6%80%81"><span style="color:#38d8f0;">2.4.7 多态</span></h4> 
<p>        <span style="color:#0d0016;"><strong>多态是 C++ 面向对象三大特性之一</strong></span></p> 
<h5 id="2.4.7.1%20%E5%A4%9A%E6%80%81%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span style="color:#a2e043;">2.4.7.1 多态的基本概念</span></h5> 
<p><span style="color:#fe2c24;"><strong>多态分为两类：</strong></span></p> 
<ul><li>       <span style="color:#0d0016;"><strong> 静态多态：</strong></span>函数重载 和 运算符重载属于静态多态，复用函数名</li><li>       <span style="color:#0d0016;"><strong> 动态多态：</strong></span>派生类和虚函数实现运行时多态</li></ul> 
<p><span style="color:#fe2c24;"><strong>静态多态和动态多态的区别：</strong></span></p> 
<ul><li>        静态多态的函数地址早绑定 - 编译阶段确定函数地址</li><li>        动态多态的函数地址晚绑定 - 运行阶段确定函数地址</li></ul> 
<pre><code>// 多态
// 动物类
class Animal
{
public:
	virtual void speak() // 加上virtual表示父类的成员函数变为了虚函数
	{
		cout &lt;&lt; "动物在说话" &lt;&lt; endl;
	}
};
// 猫类
class Cat:public Animal
{
public:
	void speak()
	{
		cout &lt;&lt; "小猫在说话" &lt;&lt; endl;
	}
};
// 执行说话的函数
void DoSpeak(Animal &amp;animal)
{
	animal.speak(); 
}
void Test()
{
	Cat cat;
	DoSpeak(cat); // 此时打印出的结果是动物在说话
	// 这里就有疑问了，明明输入的参数是cat，最终打印出的却是动物在说话！！！
	// 原因在于void DoSpeak(Animal &amp;animal)的参数是父类Animal类，DoSpeak(cat); 的参数却是子类的对象
	// 现在就是说父类函数在调用子类参数

	// 存在一个地址早绑定的问题，也就是说编译的时候地址就已经绑定好了：
	// 如果想打印小猫在说话的话，那么就不能地址早绑定，需要地址晚绑定！！！
	// 实现地址晚绑定，很简单，将父类的成员函数变为虚函数即可；
	// virtual void speak()
}

int main()
{
	Test();
	
	system("pause"); // 按任意键继续！
	return 0;
}
// 总结：
// 动态多态需要满足：
// 1. 必须存在父子继承关系
// 2. 子类重写父类虚函数（也就是子类重写了父类的virtual void speak()函数，至于virtual可加可不加）
//     重写的概念是：函数返回值类型、函数名、参数列表——完全相同

// 动态多态使用
// 父类的指针或者引用  指向子类对象
// void DoSpeak(Animal &amp;animal)，参数是父类 Animal 的引用 &amp;animal
// 但是父类的引用却指向了子类的对象：Animal &amp; animal = cat;</code></pre> 
<h5 id="2.4.7.2%20%E5%A4%9A%E6%80%81%E7%9A%84%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90"><span style="color:#a2e043;">2.4.7.2 多态的原理剖析</span></h5> 
<p>        建立在上述代码的基础之上：</p> 
<blockquote> 
 <p><span style="color:#fe2c24;"><strong>1. </strong></span>假设我们先去掉 virtual，那么此时就不存在虚函数之说，那么就是<span style="color:#0d0016;"><strong>父类引用指向子类对象，</strong>先来打印 Animal 的大小；</span></p> 
 <pre><code>void Test01()
{
	cout &lt;&lt; "sizeof Animal=" &lt;&lt; sizeof(Animal) &lt;&lt; endl;
	// 此时打印的结果是 1
	// Animal 中只有一个非静态的成员函数，分开存储，不属于类上的对象 
	// 编译器默认让类为1，在内存上区分不同之间的类

	// 但是当加上 virtual 之后，打印结果变为了 4 个字节
	// 试着猜想一下，类内增加了什么东西
	// 增加这4个字节，实际上是增加了一个指针
}</code></pre> 
</blockquote> 
<blockquote> 
 <p><span style="color:#fe2c24;"><strong>2. </strong></span></p> 
 <pre><code>class Animal
{
public:
	virtual void speak() // 加上virtual表示父类的成员函数变为了虚函数
	{
		cout &lt;&lt; "动物在说话" &lt;&lt; endl;
	}
};</code></pre> 
 <p>我们来<span style="color:#fe2c24;"><strong>看一下这个<strong> </strong>Animal 动物类的内部结构</strong></span>：</p> 
 <p>        首先上面第一条我们已经证明了虚函数本质还是一个指针，占用 4 个字节，该指针称为：<span style="color:#0d0016;"><strong>vfptr（虚函数指针）</strong></span></p> 
 <p>        v --- virtual</p> 
 <p>        f  --- function</p> 
 <p>        ptr  --- pointer</p> 
 <p>        <span style="color:#0d0016;"><strong>虚函数指针 vfptr</strong></span> 指向<span style="color:#0d0016;"><strong>虚函数表 vftable</strong></span></p> 
 <p>        v --- virtual</p> 
 <p>        f  --- function</p> 
 <p>        table  --- table</p> 
 <p>        虚函数表中存储的是：虚函数 virtual void speak() 的地址；也就是<span style="color:#fe2c24;"><strong> &amp;Animal::speak()</strong></span>；</p> 
 <p>我们来<span style="color:#fe2c24;"><strong>看一下这个<strong> </strong>Cat 猫类的内部结构</strong></span>：</p> 
 <p>        首先假设猫类还没有重写（函数返回值类型、函数名、参数列表完全相同）虚函数的时候：</p> 
 <pre><code>class Cat:public Animal
{
public:
	
};</code></pre> 
 <p>        这个时候猫类的内部结构依然是<span style="color:#0d0016;"><strong>一个虚函数指向一个虚函数表</strong></span>：</p> 
 <p>        不过这个时候是继承动物类 Animal 的，所以虚函数表中存储的依然是：<span style="color:#fe2c24;"><strong>&amp;Animal::speak()</strong></span>；</p> 
 <pre><code>class Cat:public Animal
{
public:
	void speak()
	{
		cout &lt;&lt; "小猫在说话" &lt;&lt; endl;
	}
};</code></pre> 
 <p>        但是当子类重写父类的虚函数的时候，<span style="color:#0d0016;"><strong>子类的虚函数表中就会存储子类的虚函数地址</strong></span>：<span style="color:#fe2c24;"><strong>&amp;Cat::speak()</strong></span>；</p> 
 <p>        这个时候就会出现<span style="color:#0d0016;"><strong>动态多态</strong></span>的情况，也就是不再在编译的时候确定函数地址，而是在运行的时候确定函数地址；</p> 
 <p><br>         <span style="color:#fe2c24;"><strong>当父类的指针或者引用指向子类的对象时，就会发生多态</strong></span></p> 
 <p><span style="color:#fe2c24;"><strong>        Animal&amp; animal = cat；</strong></span></p> 
 <p><span style="color:#fe2c24;"><strong>        animal.speak（）；</strong></span></p> 
</blockquote> 
<h5 id="2.4.7.3%20%E6%A1%88%E4%BE%8B%E4%B8%80%EF%BC%9A%E8%AE%A1%E7%AE%97%E5%99%A8%E7%B1%BB"><span style="color:#a2e043;">2.4.7.3 案例一：计算器类</span></h5> 
<p>        <span style="color:#fe2c24;"><strong>案例描述：</strong></span>分别利用<span style="color:#0d0016;"><strong>普通写法</strong></span>和<span style="color:#0d0016;"><strong>多态技术</strong></span>，设计<span style="color:#0d0016;"><strong>实现两个操作数进行运算的计算器类</strong></span></p> 
<blockquote> 
 <p><span style="color:#fe2c24;"><strong>普通写法：</strong></span><span style="color:#0d0016;"><strong>实现两个操作数进行运算的计算器类</strong></span></p> 
 <pre><code>// 普通写法
class Calculator
{
public:
	int GetResult(string str)
	{
		if (str=="+")
		{
			return m_A + m_B;
		}
		else if (str == "-")
		{
			return m_A - m_B;
		}
		else if (str == "*")
		{
			return m_A * m_B;
		}
		else if (str == "/")
		{
			return m_A / m_B;
		}
	}
	int m_A;
	int m_B;
};
void Test()
{
	Calculator c;
	c.m_A = 10;
	c.m_B = 10;

	cout &lt;&lt; c.m_A &lt;&lt; "+" &lt;&lt; c.m_B &lt;&lt; "=" &lt;&lt; c.GetResult("+") &lt;&lt; endl;
	cout &lt;&lt; c.m_A &lt;&lt; "-" &lt;&lt; c.m_B &lt;&lt; "=" &lt;&lt; c.GetResult("-") &lt;&lt; endl;
	cout &lt;&lt; c.m_A &lt;&lt; "*" &lt;&lt; c.m_B &lt;&lt; "=" &lt;&lt; c.GetResult("*") &lt;&lt; endl;
	cout &lt;&lt; c.m_A &lt;&lt; "/" &lt;&lt; c.m_B &lt;&lt; "=" &lt;&lt; c.GetResult("/") &lt;&lt; endl;

}

int main()
{
	Test();
	system("pause"); // 按任意键继续！
	return 0;
}
</code></pre> 
 <p><img alt="" height="130" src="https://images2.imgbox.com/46/0f/Ei4q1STS_o.png" width="421"></p> 
</blockquote> 
<blockquote> 
 <p><span style="color:#fe2c24;"><strong>多态技术：</strong></span><span style="color:#0d0016;"><strong>实现两个操作数进行运算的计算器类</strong></span></p> 
 <p><span style="color:#fe2c24;"><strong>多态的优点：</strong></span></p> 
 <p>        1. 代码组织结构清晰</p> 
 <p>        2. 可读性强<br>  </p> 
 <pre><code>// 实现计算器抽象类
class AbstructCalculator
{
public:
	virtual int GetResult()
	{
		return 0;
	}
	int m_A;
	int m_B;
};
// 加法计算器类
class AddCalzulator :public AbstructCalculator
{
public:
	int GetResult()
	{
		return m_A + m_B;
	}
};
// 减法计算器类
class SubCalzulator :public AbstructCalculator
{
public:
	int GetResult()
	{
		return m_A - m_B;
	}
};
// 乘法计算器类
class MulCalzulator :public AbstructCalculator
{
public:
	int GetResult()
	{
		return m_A * m_B;
	}
};
void Test()
{
	// 多态的使用条件：
	// 父类的指针或者引用指向子类的对象
	// 加法运算
	AbstructCalculator *abc = new AddCalzulator; // 父类的指针指向子类的对象
	abc-&gt;m_A = 100;
	abc-&gt;m_B = 100;
	cout &lt;&lt; abc-&gt;m_A &lt;&lt; "+" &lt;&lt; abc-&gt;m_B &lt;&lt; "=" &lt;&lt; abc-&gt;GetResult() &lt;&lt; endl;
	delete abc;
	// 减法运算
	abc = new SubCalzulator; // 父类的指针指向子类的对象
	abc-&gt;m_A = 100;
	abc-&gt;m_B = 100;
	cout &lt;&lt; abc-&gt;m_A &lt;&lt; "-" &lt;&lt; abc-&gt;m_B &lt;&lt; "=" &lt;&lt; abc-&gt;GetResult() &lt;&lt; endl;
	delete abc;
	// 乘法运算
	abc = new MulCalzulator; // 父类的指针指向子类的对象
	abc-&gt;m_A = 100;
	abc-&gt;m_B = 100;
	cout &lt;&lt; abc-&gt;m_A &lt;&lt; "*" &lt;&lt; abc-&gt;m_B &lt;&lt; "=" &lt;&lt; abc-&gt;GetResult() &lt;&lt; endl;
	delete abc;
}

int main()
{
	Test();
	system("pause"); // 按任意键继续！
	return 0;
}</code></pre> 
 <p><img alt="" height="120" src="https://images2.imgbox.com/e0/2e/nQXWd9Ni_o.png" width="449"></p> 
</blockquote> 
<h5 id="2.4.7.4%20%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span style="color:#a2e043;">2.4.7.4 纯虚函数和抽象类</span></h5> 
<p>        在<span style="color:#0d0016;"><strong>多态中，通常父类中虚函数的实现是毫无意义的，主要都是调用子类重写的内容</strong></span></p> 
<p>        因此可以<span style="color:#fe2c24;"><strong>将虚函数改为纯虚函数</strong></span></p> 
<p>        <span style="color:#0d0016;"><strong>纯虚函数语法</strong></span>：<span style="color:#fe2c24;"><strong>virtual  返回值类型  函数名  （参数列表）= 0；</strong></span></p> 
<p>        当类中有了纯虚函数，这个类也称为<span style="color:#fe2c24;"><strong>抽象类</strong></span></p> 
<blockquote> 
 <p><span style="color:#fe2c24;"><strong>抽象类的特点：</strong></span></p> 
 <p>        1. 无法实例化对象</p> 
 <p>        2. 子类必须重写抽象类中的纯虚函数，否则也属于抽象类</p> 
</blockquote> 
<pre><code>// 纯虚类和抽象类

// 实现计算器抽象类
class Father
{
public:
	virtual int GetResult() = 0;
	// 因为虚函数的内容本身是不起作用的，主要是子类重写虚函数
	// 所以父类的虚函数可以设置为纯虚函数，此时这个类称为抽象类；
	// virtual int GetResult() = 0; 这样的语法在 C++ 中是可以通过的
	// 但是如果不加virtual，int GetResult() = 0; 这样的语法是不被通过的；
	int m_A;
	int m_B;
};
// 抽象类的特点
// 1. 无法实例化对象
// 2. 抽象类的子类  必须要重写父类中的纯虚函数，否则也属于抽象类
// （子类必须重写父类的纯虚函数，否则就会报错！！！）

void Test()
{
	
}

int main()
{
	Test();
	system("pause"); // 按任意键继续！
	return 0;
}</code></pre> 
<h5 id="2.4.7.5%20%E6%A1%88%E4%BE%8B%E4%BA%8C%EF%BC%9A%E5%88%B6%E4%BD%9C%E9%A5%AE%E5%93%81"><span style="color:#a2e043;">2.4.7.5 案例二：制作饮品</span></h5> 
<p>        <span style="color:#fe2c24;"><strong>案例描述：</strong></span>制作饮品的大致流程为：<span style="color:#0d0016;"><strong>煮水 - 冲泡 - 倒入杯中 - 加入辅料</strong></span></p> 
<p>        利用多态技术实现本案例，提供抽象制作饮品基类，提供子类制作咖啡和茶叶</p> 
<pre><code>// 制作饮品的大致流程为：煮水 - 冲泡 - 倒入杯中 - 加入辅料
// 利用多态技术实现本案例，提供抽象制作饮品基类，提供子类制作咖啡和茶叶
class AbstructDrinking
{
public:
	// 煮水：
	virtual void Boil() = 0;
	// 冲泡
	virtual void Brew() = 0;
	// 倒入杯中
	virtual void PourInCup() = 0;
	// 加入辅料
	virtual void PutSomeThing() = 0; 
	// 以上均为纯虚函数
	
	// 制作饮品
	void MakeDrink()
	{
		Boil();
		Brew();
		PourInCup();
		PutSomeThing();
	}
};
// 制作咖啡
class Coffee:public AbstructDrinking
{
public:
	// 煮水：
	virtual void Boil()
	{
		cout &lt;&lt; "煮水" &lt;&lt; endl;
	}
	// 冲泡
	virtual void Brew()
	{
		cout &lt;&lt; "冲泡咖啡" &lt;&lt; endl;
	}
	// 倒入杯中
	virtual void PourInCup()
	{
		cout &lt;&lt; "倒入杯中" &lt;&lt; endl;
	}
	// 加入辅料
	virtual void PutSomeThing()
	{
		cout &lt;&lt; "加入糖和牛奶" &lt;&lt; endl;
	}
};
// 制作茶叶
class Tea :public AbstructDrinking
{
public:
	// 煮水：
	virtual void Boil()
	{
		cout &lt;&lt; "煮水" &lt;&lt; endl;
	}
	// 冲泡
	virtual void Brew()
	{
		cout &lt;&lt; "冲泡茶叶" &lt;&lt; endl;
	}
	// 倒入杯中
	virtual void PourInCup()
	{
		cout &lt;&lt; "倒入杯中" &lt;&lt; endl;
	}
	// 加入辅料
	virtual void PutSomeThing()
	{
		cout &lt;&lt; "加入柠檬" &lt;&lt; endl;
	}
};
// 制作
void DoWork(AbstructDrinking* abc) // 提供一个父类的指针
{
	abc-&gt;MakeDrink();
	delete abc;
}
void Test()
{
	// 制作咖啡
	DoWork(new Coffee); // 这句程序相当于：AbstructDrinking* abc = new Coffee；
	// 相当于父类的指针指向了子类的对象，产生动态多态；
	cout &lt;&lt; "---------------------" &lt;&lt; endl;
	// 制作茶叶
	DoWork(new Tea);
}
int main()
{
	Test();
	system("pause"); // 按任意键继续！
	return 0;
}</code></pre> 
<p><img alt="" height="200" src="https://images2.imgbox.com/e7/5d/iB5djkFK_o.png" width="437"></p> 
<h5 id="2.4.7.6%20%E8%99%9A%E6%9E%90%E6%9E%84%E5%92%8C%E7%BA%AF%E8%99%9A%E6%9E%90%E6%9E%84"><span style="color:#a2e043;">2.4.7.6 虚析构和纯虚析构</span></h5> 
<p>        <span style="color:#0d0016;"><strong>多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码</strong></span></p> 
<p>        <span style="color:#fe2c24;"><strong>解决方法</strong></span>：将父类中的析构函数改为<span style="color:#0d0016;"><strong>虚析构</strong></span>或者<span style="color:#0d0016;"><strong>纯虚析构</strong></span></p> 
<p><span style="color:#0d0016;"><strong>虚析构和纯虚析构共性：</strong></span></p> 
<ul><li>        1. 可以解决父类指针释放子类对象的问题</li><li>        2. 都需要有具体的函数实现</li></ul> 
<p><span style="color:#0d0016;"><strong>虚析构和纯虚析构的区别：</strong></span></p> 
<ul><li>        如果是纯虚析构，那么该类属于抽象类，无法实例化对象</li></ul> 
<p><span style="color:#fe2c24;"><strong>虚析构语法：</strong></span><span style="color:#0d0016;"><strong>virtual ~类名( ){ }</strong></span></p> 
<p><span style="color:#fe2c24;"><strong>纯虚析构语法：</strong></span><span style="color:#0d0016;"><strong>virtual ~类名( ) = 0；</strong></span></p> 
<p><span style="color:#0d0016;"><strong>                         类名::~类名(){}</strong></span></p> 
<pre><code>// 虚析构和纯虚析构
class Animal
{
public:
	Animal()
	{
		cout &lt;&lt; "Animal 的构造函数调用" &lt;&lt; endl;
	}
	// 纯虚函数
	virtual void speak() = 0;  
	~Animal()
	{
		cout &lt;&lt; "Animal 的析构函数调用" &lt;&lt; endl;
	}
};
class Cat :public Animal
{
public:
	Cat(string name)
	{
		cout &lt;&lt; "Cat 的构造函数调用" &lt;&lt; endl;
		m_Name = new string(name); // 这句代码的意思就是在堆区存储这个字符串string
		// 返回的类型就是 string 指针类型；用 m_Name 指针类型来接收
	}
	virtual void speak()
	{
		cout &lt;&lt;*m_Name&lt;&lt; "小猫在说话" &lt;&lt; endl;
	}
	~Cat()
	{
		if (m_Name!=NULL)
		{
			cout &lt;&lt; "Cat 的析构函数调用"&lt;&lt;endl;
			delete m_Name;
			m_Name = NULL;
		}
	}
	string* m_Name;
};
void Test()
{
	Animal* animal = new Cat("Tom");
	animal-&gt;speak();
	// 父类指针在析构时候，不用调用子类中析构函数，导致子类如果有堆区属性，出现内存泄露！ 
	delete animal;
}

int main()
{
	Test();
	system("pause"); // 按任意键继续！
	return 0;
}
</code></pre> 
<p><img alt="" height="120" src="https://images2.imgbox.com/ea/1a/iyWobx60_o.png" width="397"></p> 
<p><span style="color:#0d0016;"><strong>此时会发现：</strong></span>父类指针在析构的时候，不会调用子类析构函数，导致子类如果有堆区属性，出现内存泄露！！！</p> 
<p><span style="color:#0d0016;"><strong>如何解决这个问题：</strong></span></p> 
<p><span style="color:#0d0016;"><strong>        </strong></span>只需要把父类的析构函数改为虚析构函数；</p> 
<p><img alt="" height="250" src="https://images2.imgbox.com/a9/58/hHqQbMZq_o.png" width="464"></p> 
<p>        此时就会执行子类的虚构函数！！！（可以发现，此时打印出：<span style="color:#fe2c24;"><strong>子类 Cat 析构函数调用</strong></span>）</p> 
<blockquote> 
 <p><span style="color:#0d0016;"><strong>纯虚析构：</strong></span></p> 
 <pre><code>// 纯虚析构
virtual ~Animal()=0；
// 纯虚析构这样定义是会报错的！
// 因为析构函数内部一般需要定义！
// 这是因为父类也可能在堆区开辟内存，这样就需要析构函数是处理这块内存！</code></pre> 
</blockquote> 
<h3 id="2.5%20%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C"><span style="color:#4da8ee;">2.5 文件操作</span></h3> 
<p>        程序运行时产生的数据都属于临时数据，程序一旦运行结束都会被释放</p> 
<p>        通过<span style="color:#fe2c24;"><strong>文件可以将数据持久化</strong></span></p> 
<p>        C++ 中对文件操作需要包含头文件<span style="color:#0d0016;"><strong><span style="background-color:#ffd900;"> &lt;fstream&gt;</span></strong></span></p> 
<p><span style="color:#fe2c24;"><strong>文件类型分为两种：</strong></span></p> 
<ul><li>        <span style="color:#0d0016;"><strong>1. 文本文件</strong></span>   - 文件以文本的 <span style="color:#fe2c24;"><strong>ASCII 码</strong></span>形式存储在计算机中</li><li>       <span style="color:#0d0016;"><strong> 2. 二进制文件</strong></span>   - 文件以文本的<span style="color:#fe2c24;"><strong>二进制</strong></span>形式存储在计算机中，用户一般不能直接读懂它们</li></ul> 
<p><span style="color:#fe2c24;"><strong>操作文件的三大类：</strong></span></p> 
<ul><li>        <span style="color:#0d0016;"><strong>1. ofstream：</strong></span>写操作（o代表output）</li><li>        <span style="color:#0d0016;"><strong>2. ifstream：</strong></span>读操作（i代表input）</li><li>       <span style="color:#0d0016;"><strong> 3. fstream：</strong></span>读写操作</li></ul> 
<h4 id="2.5.1%20%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%C2%A0"><span style="color:#38d8f0;">2.5.1 文本文件 </span></h4> 
<h5 id="2.5.1.1%20%E5%86%99%E6%96%87%E4%BB%B6"><span style="color:#a2e043;">2.5.1.1 写文件</span></h5> 
<blockquote> 
 <p><span style="color:#fe2c24;"><strong>写文件步骤如下：</strong></span></p> 
 <p>        <span style="color:#0d0016;"><strong>1. 包含头文件</strong></span></p> 
 <p>                #include &lt;fstream&gt;</p> 
 <p>        <span style="color:#0d0016;"><strong>2. 创建流对象</strong></span></p> 
 <p>                ofstream ofs；</p> 
 <p>        <span style="color:#0d0016;"><strong>3. 打开文件</strong></span></p> 
 <p>                ofs.open（"文件路径"，打开方式）；</p> 
 <p>打开方式                        解释</p> 
 <p><span style="color:#0d0016;"><strong>ios::in                        为读文件而打开文件</strong></span></p> 
 <p><span style="color:#0d0016;"><strong>ios::out                      为写文件而打开文件</strong></span></p> 
 <p>ios::ate                      初始位置：文件尾</p> 
 <p>ios::app                     追加方式写文件</p> 
 <p>ios::trunc                   如果文件存在先删除，再创建</p> 
 <p>ios::binary                 二进制方式</p> 
 <p><span style="color:#0d0016;"><strong>注意：</strong></span>文件打开方式可以配合使用，利用 | 操作符</p> 
 <p><span style="color:#0d0016;"><strong>例如：</strong></span>用二进制方式写文件 ios::binary | ios::out</p> 
 <p>      <span style="color:#0d0016;"><strong>  4. 写数据</strong></span></p> 
 <p>                ofs&lt;&lt;"写入的数据";</p> 
 <p>        <span style="color:#0d0016;"><strong>5. 关闭文件</strong></span></p> 
 <p>                ofs.close（）;</p> 
</blockquote> 
<pre><code>#define _CRT_SECURE_NO_WARNINGS 1
#include &lt;iostream&gt;
#include &lt;string&gt; // 用 C++ 风格的字符串需要包含这个头文件
#include &lt;ctime&gt; // time 系统时间头文件包含
#include &lt;fstream&gt; // 文件操作必须引用该头文件
using namespace std;

// 文本文件  写文件
void Test()
{
	// 1. 包含头文件 fstream
	// #include &lt;fstream&gt;
	// 2. 创建流对象
	ofstream ofs;
	// 3. 指定打开方式
	ofs.open("text.txt",ios::out);
	// 4. 写内容
	ofs &lt;&lt; "姓名：张三" &lt;&lt; endl;
	ofs &lt;&lt; "姓别：男" &lt;&lt; endl;
	ofs &lt;&lt; "年龄：18" &lt;&lt; endl;
	// 5. 关闭文件
	ofs.close();
}

int main()
{
	Test();
	system("pause"); // 按任意键继续！
	return 0;
}
</code></pre> 
<p><img alt="" height="150" src="https://images2.imgbox.com/44/b6/5SUoDxBx_o.png" width="397"></p> 
<blockquote> 
 <p><span style="color:#fe2c24;"><strong>总结：</strong></span></p> 
 <p>        1. 文件操作必须包括头文件 fstream</p> 
 <p>        2. 读文件可以利用 ofstream，或者 fstream 类</p> 
 <p>        3. 打开文件时候需要指定操作文件的路径，以及打开方式</p> 
 <p>        4. 利用&lt;&lt;可以向文件中写数据</p> 
 <p>        5. 操作完毕，要关闭文件</p> 
</blockquote> 
<h5 id="2.5.1.2%20%E8%AF%BB%E6%96%87%E4%BB%B6"><span style="color:#a2e043;">2.5.1.2 读文件</span></h5> 
<blockquote> 
 <p><span style="color:#fe2c24;"><strong>读文件步骤如下：</strong></span></p> 
 <p>        <span style="color:#0d0016;"><strong>1. 包含头文件</strong></span></p> 
 <p>                #include &lt;fstream&gt;</p> 
 <p>        <span style="color:#0d0016;"><strong>2. 创建流对象</strong></span></p> 
 <p>                ofstream ifs；</p> 
 <p>        <span style="color:#0d0016;"><strong>3. 打开文件</strong></span></p> 
 <p>                ifs.open（"文件路径"，打开方式）；</p> 
 <p>打开方式                        解释</p> 
 <p><span style="color:#0d0016;"><strong>ios::in                        为读文件而打开文件</strong></span></p> 
 <p><span style="color:#0d0016;"><strong>ios::out                      为写文件而打开文件</strong></span></p> 
 <p>ios::ate                      初始位置：文件尾</p> 
 <p>ios::app                     追加方式写文件</p> 
 <p>ios::trunc                   如果文件存在先删除，再创建</p> 
 <p>ios::binary                 二进制方式</p> 
 <p><span style="color:#0d0016;"><strong>注意：</strong></span>文件打开方式可以配合使用，利用 | 操作符</p> 
 <p><span style="color:#0d0016;"><strong>例如：</strong></span>用二进制方式写文件 ios::binary | ios::out</p> 
 <p>      <span style="color:#0d0016;"><strong>  4. 读数据</strong></span></p> 
 <p>                四种方式读取；</p> 
 <p>        <span style="color:#0d0016;"><strong>5. 关闭文件</strong></span></p> 
 <p>                ifs.close（）;</p> 
</blockquote> 
<pre><code>// 文本文件  读文件
void Test()
{
	// 1. 包含头文件 fstream
	// #include &lt;fstream&gt;
	// 2. 创建流对象
	ifstream ifs;
	// 3. 指定打开方式
	ifs.open("text.txt", ios::in);
	// 4. 读内容
	// 通过上节的写内容，此时 text.txt 里面存储着张三的姓名、年龄和性别
	if (!ifs.is_open()) // 判断是否打开文件成功
	{
		cout &lt;&lt; "文件打开失败！" &lt;&lt; endl;
		return;
	}
	// 第一种方式读数据
	/*char buf[1024] = { 0 };
	while (ifs &gt;&gt; buf) // 一行一行的读，当读到头；当右移到头，返回一个假的标志！
	{
		cout &lt;&lt; buf &lt;&lt; endl;
	}*/
	// 第二种方式读数据
	//char buf[1024] = { 0 };
	//while (ifs.getline(buf,sizeof(buf)))// getline 一行一行的读
	//	// 第一个参数 指针类型，正好数组名表示首元素地址
	//	// 第二个参数 要读的字节大小
	//{
	//	cout &lt;&lt; buf &lt;&lt; endl;
	//}
	// 第三种方式读数据
	//string buf;
	//while (getline(ifs,buf)) // 全局函数getline
	//{
	//	cout &lt;&lt; buf &lt;&lt; endl;
	//}
	// 第四种方式读数据
	char c;
	while ((c=ifs.get())!=EOF) // 一个字符一个字符的读，只要读到的不是字符尾部
		// 字符尾部标志为 EOF
	{
		cout &lt;&lt; c;
	}

	// 5. 关闭文件
	ifs.close();
}

int main()
{
	Test();
	system("pause"); // 按任意键继续！
	return 0;
}</code></pre> 
<h4 id="2.5.2%20%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6"><span style="color:#38d8f0;">2.5.2 二进制文件</span></h4> 
<p>        <span style="color:#0d0016;"><strong>以二进制的方式对文件进行读写操作</strong></span></p> 
<p>        打开方式要指定为 <span style="color:#0d0016;"><strong><span style="background-color:#ffd900;">ios::binary</span></strong></span></p> 
<h5 id="2.5.2.1%20%E5%86%99%E6%96%87%E4%BB%B6"><span style="color:#a2e043;">2.5.2.1 写文件</span></h5> 
<p>        <span style="color:#0d0016;"><strong>二进制方式写文件</strong></span>主要利用<span style="color:#fe2c24;"><strong>流对象调用成员函数 write</strong></span></p> 
<p>        <span style="color:#0d0016;"><strong>函数原型：<span style="background-color:#ffd900;">ostream&amp; write（const char* buffer，int len）;</span></strong></span></p> 
<p>        <span style="color:#0d0016;"><strong>参数解释：</strong></span>字符指针 buffer 指向内存中一段存储空间。len 是读写的字节数</p> 
<pre><code>// 二进制文件
// 写文件
class People
{
public:
	char m_Name[64]; // 姓名
	int m_Age; // 年龄
};
void Test()
{
	// 1. 包含头文件
	// 2. 创建流对象
	ofstream ofs;
	// 3. 打开文件
	ofs.open("People.txt",ios::out | ios::binary); // 二进制下写
	// 4. 写文件
	People p = { "张三", 18 };
	ofs.write((const char*)&amp;p,sizeof(People));
	// 5. 关闭文件
	ofs.close();
}
int main()
{
	Test();
	system("pause"); // 按任意键继续！
	return 0;
}</code></pre> 
<p><img alt="" height="100" src="https://images2.imgbox.com/a7/82/9pMBia4Y_o.png" width="536"></p> 
<h5 id="2.5.2.2%20%E8%AF%BB%E6%96%87%E4%BB%B6"><span style="color:#a2e043;">2.5.2.2 读文件</span></h5> 
<p>        <span style="color:#0d0016;"><strong>二进制方式读文件</strong></span>主要利用<span style="color:#0d0016;"><strong>流对象调用成员函数 read</strong></span></p> 
<p>        <span style="color:#0d0016;"><strong>函数原型：<span style="background-color:#ffd900;">istream&amp; read（char* buffer，int len）；</span></strong></span></p> 
<p>        <span style="color:#0d0016;"><strong>参数解释：</strong></span>字符指针 buffer 指向内存中一段存储空间。len 是读写的字节数</p> 
<pre><code>// 二进制文件
// 读文件
class People
{
public:
	char m_Name[64]; // 姓名
	int m_Age; // 年龄
};
void Test()
{
	// 1. 包含头文件
	// 2. 创建流对象
	ifstream ifs;
	// 3. 打开文件   判断文件是否打开成功
	ifs.open("People.txt", ios::in | ios::binary); // 二进制下读
	if (!ifs.is_open())
	{
		cout &lt;&lt; "文件打开失败！" &lt;&lt; endl;
		return;
	}
	// 4. 读文件 
	People p;
	ifs.read((char*)&amp;p, sizeof(People));
	cout &lt;&lt; "姓名：" &lt;&lt; p.m_Name &lt;&lt; endl;
	cout &lt;&lt; "年龄：" &lt;&lt; p.m_Age &lt;&lt; endl;
	// 5. 关闭文件
	ifs.close();
}
int main()
{
	Test();
	system("pause"); // 按任意键继续！
	return 0;
}</code></pre> 
<p><img alt="" height="100" src="https://images2.imgbox.com/db/9a/erNjpao2_o.png" width="450"></p> 
<h3 id="2.6%20%E8%81%8C%E5%B7%A5%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F"><span style="color:#4da8ee;">2.6 职工管理系统</span></h3> 
<h4 id="2.6.1%20%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E9%9C%80%E6%B1%82"><span style="color:#38d8f0;">2.6.1 管理系统需求</span></h4> 
<p>        职工管理系统可以用来管理公司内所有员工的信息</p> 
<p>        本次利用<span style="color:#fe2c24;"><strong> C++ 来实现一个基于多态的职工管理系统</strong></span></p> 
<blockquote> 
 <p>公司中职工分为三类：<span style="color:#fe2c24;"><strong>普通员工、经理、老板</strong></span>，显示信息时，需要显示<span style="color:#fe2c24;"><strong>职工编号、职工姓名、职工岗位、以及职责</strong></span>；</p> 
 <p><span style="color:#0d0016;"><strong>普通员工职责：</strong></span>完成经理交给的任务</p> 
 <p><span style="color:#0d0016;"><strong>经理职责：</strong></span>完成老板交给的任务，并下发任务给员工</p> 
 <p><span style="color:#0d0016;"><strong>老板职责：</strong></span>管理公司所有事务</p> 
</blockquote> 
<p><span style="color:#fe2c24;"><strong>管理系统中需要实现的功能如下：</strong></span></p> 
<ul><li>        <span style="color:#0d0016;"><strong>退出管理程序：</strong></span>退出当前管理系统</li><li>        <span style="color:#0d0016;"><strong>增加职工信息：</strong></span>实现批量添加职工功能，将信息录入到文件中，职工信息为：职工编号、姓名、部门编号</li><li>        <span style="color:#0d0016;"><strong>显示职工信息：</strong></span>显示公司内部所有职工的信息</li><li>        <span style="color:#0d0016;"><strong>删除离职职工：</strong></span>按照编号删除指定的职工</li><li>        <span style="color:#0d0016;"><strong>修改职工信息：</strong></span>按照编号修改职工个人信息</li><li>        <span style="color:#0d0016;"><strong>查找职工信息：</strong></span>按照职工的编号或者职工的姓名进行查找相关的人员信息</li><li>        <span style="color:#0d0016;"><strong>按照编号排序：</strong></span>按照职工编号进行排序，排序规则由用户指定</li><li>        <span style="color:#0d0016;"><strong>清空所有文档：</strong></span>清空文件中记录的所有职工信息（清空前需要再次确认，防止误删）</li></ul> 
<h4 id="2.6.2%20%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE"><span style="color:#38d8f0;">2.6.2 创建项目</span></h4> 
<p><span style="color:#0d0016;"><strong>创建项目：</strong></span></p> 
<p>        创建项目就是在 Visual Studio 中创建一个项目，这个具体可参考：<a href="https://blog.csdn.net/light_2025/article/details/134320141" title="C++[面向对象的程序设计]_基础入门（上）(万字总结)（建议收藏！！！）-CSDN博客">C++[面向对象的程序设计]_基础入门（上）(万字总结)（建议收藏！！！）-CSDN博客</a></p> 
<h4 id="2.6.3%20%E5%88%9B%E5%BB%BA%E7%AE%A1%E7%90%86%E7%B1%BB"><span style="color:#38d8f0;">2.6.3 创建管理类</span></h4> 
<p><span style="color:#fe2c24;"><strong>管理类负责的内容如下：</strong></span></p> 
<ul><li>        与用户的沟通菜单界面</li><li>        对职工增删改查的操作</li><li>        与文件的读写交互</li></ul> 
<p><span style="color:#fe2c24;"><strong>.cpp文件</strong></span></p> 
<pre><code>#define _CRT_SECURE_NO_WARNINGS 1
#include &lt;iostream&gt;
#include &lt;string&gt; // 用 C++ 风格的字符串需要包含这个头文件
#include &lt;ctime&gt; // time 系统时间头文件包含
#include &lt;fstream&gt; // 文件操作必须引用该头文件
#include "HelloWorld.h"
using namespace std;

// 构造和析构函数空实现
WorkerManager::WorkerManager() // 通过调用类初始化构造函数
{

}
WorkerManager::~WorkerManager() // 通过调用类初始化析构函数
{

}</code></pre> 
<p><span style="color:#fe2c24;"><strong>.h 头文件</strong></span></p> 
<pre><code>#pragma once   // 防止头文件重叠
#include &lt;iostream&gt;  // 包含输入输出流文件
using namespace std;  // 使用标准命名空间



class WorkerManager
{
public:
	// 构造函数
	WorkerManager();
	// 析构函数
	~WorkerManager();
};</code></pre> 
<h4 id="2.6.4%20%E8%8F%9C%E5%8D%95%E5%8A%9F%E8%83%BD"><span style="color:#38d8f0;">2.6.4 菜单功能</span></h4> 
<p><span style="color:#fe2c24;"><strong>.h文件</strong></span></p> 
<p><span style="color:#0d0016;">在</span><span style="color:#0d0016;"><strong> .h 文件</strong></span><span style="color:#0d0016;">中添加 </span><span style="color:#0d0016;"><strong>展示菜单的函数！</strong></span></p> 
<pre><code>class WorkerManager
{
public:
	// 构造函数
	WorkerManager();

	// 展示菜单的函数
	void Show_Menu();

	// 析构函数
	~WorkerManager();
};</code></pre> 
<p><span style="color:#fe2c24;"><strong>.cpp 文件</strong></span></p> 
<pre><code>// 展示菜单的函数
void WorkerManager::Show_Menu() // 调用类初始化菜单函数，表示该成员函数属于类 WorkerManager
{
	cout &lt;&lt; "**********************************************" &lt;&lt; endl;
	cout &lt;&lt; "*********** 欢迎使用职工管理系统！************" &lt;&lt; endl;
	cout &lt;&lt; "*************  0. 退出管理程序  **************" &lt;&lt; endl;
	cout &lt;&lt; "*************  1. 增加职工信息  **************" &lt;&lt; endl;
	cout &lt;&lt; "*************  2. 显示职工信息  **************" &lt;&lt; endl;
	cout &lt;&lt; "*************  3. 删除离职职工  **************" &lt;&lt; endl;
	cout &lt;&lt; "*************  4. 修改职工信息  **************" &lt;&lt; endl;
	cout &lt;&lt; "*************  5. 查找职工信息  **************" &lt;&lt; endl;
	cout &lt;&lt; "*************  6. 按照编号排序  **************" &lt;&lt; endl;
	cout &lt;&lt; "*************  7. 清空所以文档  **************" &lt;&lt; endl;
	cout &lt;&lt; "**********************************************" &lt;&lt; endl;
	cout &lt;&lt; endl;
}</code></pre> 
<p><span style="color:#fe2c24;"><strong>main 函数</strong></span></p> 
<pre><code>int main()
{
	WorkerManager workerManager;
	workerManager.Show_Menu();  // 显示菜单

	system("pause"); // 按任意键继续！
	return 0;
}</code></pre> 
<h4 id="2.6.5%20%E9%80%80%E5%87%BA%E5%8A%9F%E8%83%BD"><span style="color:#38d8f0;">2.6.5 退出功能</span></h4> 
<pre><code>// 退出系统的函数
void WorkerManager::Exit_System()
{
	cout &lt;&lt; "欢迎下次使用！" &lt;&lt; endl;
	system("pause");
	exit(0);  // 退出程序
}</code></pre> 
<h4 id="2.6.6%20%E5%88%9B%E5%BB%BA%E8%81%8C%E5%B7%A5%E7%B1%BB"><span style="color:#38d8f0;">2.6.6 创建职工类</span></h4> 
<pre><code>// 职工抽象类
class Worker
{
public:
	// 显示个人信息
	virtual void ShowInfo() = 0;
	// 获取岗位的名称
	virtual string GetDeptName() = 0;

	// 编号
	int m_ID;
	// 姓名
	string m_Name;
	// 部门编号
	int m_DeptID;
};

// 创建一个员工类去继承Worker职工类
class Employee :public Worker
{
public:
	// 构造函数
	Employee(int ID, string Name, int DID);
	// 重写
	// 显示个人信息
	void ShowInfo();
	// 获取岗位的名称
	string GetDeptName();
};

// 构造函数
Employee::Employee(int ID, string Name, int DID)
{
	this-&gt;m_ID = ID; // this 指向自身，表示初始化自身的ID、姓名以及编号
	this-&gt;m_Name = Name;
	this-&gt;m_DeptID = DID;
}
// 显示个人信息
void Employee::ShowInfo()
{
	cout &lt;&lt; "职工的编号：" &lt;&lt; this-&gt;m_ID
		&lt;&lt; "\t职工的姓名：" &lt;&lt; this-&gt;m_Name
		&lt;&lt; "\t职工的岗位：" &lt;&lt; this-&gt;GetDeptName()
		&lt;&lt; "\t岗位职责：完成经理交给的任务" &lt;&lt; endl;
}
// 获取岗位的名称
string Employee::GetDeptName()
{
	return string("员工");
}

// 创建一个经理类去继承Worker职工类
class Manager :public Worker
{
public:
	// 构造函数
	Manager(int ID, string Name, int DID);
	// 重写
	// 显示个人信息
	void ShowInfo();
	// 获取岗位的名称
	string GetDeptName();
};
// 构造函数
Manager::Manager(int ID, string Name, int DID)
{
	this-&gt;m_ID = ID; // this 指向自身，表示初始化自身的ID、姓名以及编号
	this-&gt;m_Name = Name;
	this-&gt;m_DeptID = DID;
}
// 显示个人信息
void Manager::ShowInfo()
{
	cout &lt;&lt; "职工的编号：" &lt;&lt; this-&gt;m_ID
		&lt;&lt; "\t职工的姓名：" &lt;&lt; this-&gt;m_Name
		&lt;&lt; "\t职工的岗位：" &lt;&lt; this-&gt;GetDeptName()
		&lt;&lt; "\t岗位职责：完成老板交给的任务，并且下发任务给普通员工" &lt;&lt; endl;
}
// 获取岗位的名称
string Manager::GetDeptName()
{
	return string("经理");
}

// 创建一个老板类去继承Worker职工类
class Boss :public Worker
{
public:
	// 构造函数
	Boss(int ID, string Name, int DID);
	// 重写
	// 显示个人信息
	void ShowInfo();
	// 获取岗位的名称
	string GetDeptName();
};
// 构造函数
Boss::Boss(int ID, string Name, int DID)
{
	this-&gt;m_ID = ID; // this 指向自身，表示初始化自身的ID、姓名以及编号
	this-&gt;m_Name = Name;
	this-&gt;m_DeptID = DID;
}
// 显示个人信息
void Boss::ShowInfo()
{
	cout &lt;&lt; "职工的编号：" &lt;&lt; this-&gt;m_ID
		&lt;&lt; "\t职工的姓名：" &lt;&lt; this-&gt;m_Name
		&lt;&lt; "\t职工的岗位：" &lt;&lt; this-&gt;GetDeptName()
		&lt;&lt; "\t岗位职责：管理公司所有的事务" &lt;&lt; endl;
}
// 获取岗位的名称
string Boss::GetDeptName()
{
	return string("总裁");
}</code></pre> 
<h4 id="2.6.7%20%E6%B7%BB%E5%8A%A0%E8%81%8C%E5%B7%A5"><span style="color:#38d8f0;">2.6.7 添加职工</span></h4> 
<pre><code>// 添加职工的过程
// 用户在批量创建时，可能会创建不同种类的职工
// 如果想将所有不同种类的员工都放入到一个数组中，可以将所有员工的指针维护到一个数组中
// 如果想在程序中维护这个不定长度的数组，可以将数组创建到堆区，并利用 Worker ** 的指针维护
// 添加职工
void WorkerManager::Add_Emp()
{
	cout &lt;&lt; "请输入添加职工的数量：" &lt;&lt; endl;

	int AddNum = 0; // 保存用户的输入数量
	cin &gt;&gt; AddNum;

	if (AddNum&gt;0)
	{
		// 计算添加新数据的大小
		int NewSize = this-&gt;m_EmpNum + AddNum; // 新空间的人数 = 原来记录的人数 + 新添加的人数

		// 开辟新空间
		Worker** NewSpace = new Worker*[NewSize]; // 在上面计算出的新空间人数的基础上，在堆区开辟对应空间大小的新空间，new返回类型为指针

		// 假设原来就有人，那么需要把原来的人拷贝到新开辟的空间上
		if (this-&gt;m_EmpArray!=NULL)
		{
			for (int i = 0; i &lt; this-&gt;m_EmpNum;i++) // 创建 for 循环，循环体大小为原来数组中已有的人数，因为要实现把已有的人转移到新数组中
			{
				NewSpace[i] = this-&gt;m_EmpArray[i]; // 拷贝到新空间
			}
		}

		// 添加新数据
		for (int i = 0; i &lt; AddNum;i++)
		{
			int ID; // 职工编号
			string Name; // 职工姓名
			int DSelect; // 部门选择

			cout &lt;&lt; "请输入第" &lt;&lt; i + 1 &lt;&lt; "个新职工编号：" &lt;&lt; endl;
			cin &gt;&gt; ID;
			cout &lt;&lt; "请输入第" &lt;&lt; i + 1 &lt;&lt; "个新职工姓名：" &lt;&lt; endl;
			cin &gt;&gt; Name;

			cout &lt;&lt; "请输入该职工岗位：" &lt;&lt; endl;
			cout &lt;&lt; "1、普通职工" &lt;&lt; endl;
			cout &lt;&lt; "2、经理" &lt;&lt; endl;
			cout &lt;&lt; "3、老板" &lt;&lt; endl;
			cin &gt;&gt; DSelect;

			Worker *worker = NULL;
			switch (DSelect)
			{
			case 1:
				worker = new Employee(ID, Name, 1);
				break;
			case 2:
				worker = new Manager(ID, Name, 2);
				break;
			case 3:
				worker = new Boss(ID, Name, 3);
				break;
			default:
				break;
			}
			// 将创建的职工职责，保存到新数组中 
			NewSpace[this-&gt;m_EmpNum + i] = worker;
		}
		// 释放原有的空间
		delete [] this-&gt;m_EmpArray;

		// 更改新空间的指向
		this-&gt;m_EmpArray = NewSpace;

		// 更新新的职工人数
		this-&gt;m_EmpNum = NewSize;

		// 提示
		cout &lt;&lt; "成功添加" &lt;&lt; AddNum &lt;&lt; "名新职员！" &lt;&lt; endl;
	}
	else
	{
		cout &lt;&lt; "输入有误！" &lt;&lt; endl;
	}

	// 按任意键清屏，回到上级目录
	system("pause");
	system("cls");
}</code></pre> 
<h4 id="2.6.8%20%E6%96%87%E4%BB%B6%E4%BA%A4%E4%BA%92%20-%20%E5%86%99%E6%96%87%E4%BB%B6"><span style="color:#38d8f0;">2.6.8 文件交互 - 写文件</span></h4> 
<pre><code>// 保存文件
void WorkerManager::Save()
{
	ofstream ofs;
	ofs.open(FILENAME,ios::out); // 用输出的方式打开文件，也就是写文件 

	// 将每个人的数据写到文件中
	for (int i = 0; i &lt; this-&gt;m_EmpNum;i++)
	{ // m_EmpArray是一个指针数组，所以该数组内存储的都是指针，可以指向Worker
		ofs &lt;&lt; this-&gt;m_EmpArray[i]-&gt;m_ID &lt;&lt; " "
			&lt;&lt; this-&gt;m_EmpArray[i]-&gt;m_Name &lt;&lt; " "
			&lt;&lt; this-&gt;m_EmpArray[i]-&gt;m_DeptID &lt;&lt; endl;
	}
	ofs.close();
}</code></pre> 
<h4 id="2.6.9%20%E6%96%87%E4%BB%B6%E4%BA%A4%E4%BA%92%20-%20%E8%AF%BB%E6%96%87%E4%BB%B6"><span style="color:#38d8f0;">2.6.9 文件交互 - 读文件</span></h4> 
<pre><code>#define FILENAME "EmpFile.txt"

// 构造函数空实现
WorkerManager::WorkerManager() // 通过调用类初始化构造函数
{
	// 1、文件不存在
	ifstream ifs;
	ifs.open(FILENAME,ios::in); // 读取这个文件

	if (!ifs.is_open())
	{
		cout &lt;&lt; "文件不存在" &lt;&lt; endl;
		// 初始化成员属性
		this-&gt;m_EmpNum = 0;
		this-&gt;m_EmpArray = NULL;
		this-&gt;m_FileIsEmpty = true;
		ifs.close();
		return;
	}

	// 2、文件存在  数据为空
	char ch;
	ifs &gt;&gt; ch; // 一个字符一个字符的读该文件
	if (ifs.eof())
	{
		// 文件为空
		cout &lt;&lt; "文件为空！" &lt;&lt; endl;
		// 初始化成员属性
		this-&gt;m_EmpNum = 0;
		this-&gt;m_EmpArray = NULL;
		this-&gt;m_FileIsEmpty = true;
		ifs.close();
		return;
	}
	
	// 3、文件存在且保存职工数据
	int Num = this-&gt;Get_EmpNum();
	cout &lt;&lt; "职工人数为：" &lt;&lt; Num &lt;&lt; endl;
	this-&gt;m_EmpNum = Num; 

	this-&gt;m_EmpArray = new Worker*[this-&gt;m_EmpNum];
	// 将文件中的数据存放到数组中
	this-&gt;Init_Emp();

	for (int i = 0; i &lt; this-&gt;m_EmpNum; i++)
	{
		cout &lt;&lt; "职工编号：" &lt;&lt; this-&gt;m_EmpArray[i]-&gt;m_ID
			&lt;&lt; "\t姓名：" &lt;&lt; this-&gt;m_EmpArray[i]-&gt;m_Name
			&lt;&lt; "\t部门编号：" &lt;&lt; this-&gt;m_EmpArray[i]-&gt;m_DeptID &lt;&lt; endl;
	}
}</code></pre> 
<h4 id="2.6.10%20%E6%98%BE%E7%A4%BA%E8%81%8C%E5%B7%A5"><span style="color:#38d8f0;">2.6.10 显示职工</span></h4> 
<pre><code>// 显示职工
void WorkerManager::Show_Emp()
{
	// 判断文件是否为空
	if (this-&gt;m_FileIsEmpty)
	{
		cout &lt;&lt; "文件不存在或记录为空！" &lt;&lt; endl;
	}
	else
	{
		for (int i = 0; i &lt; m_EmpNum;i++)
		{
			// 利用多态调用程序接口
			this-&gt;m_EmpArray[i]-&gt;ShowInfo();
		}
	}
	// 按任意键后清屏
	system("pause");
	system("cls");
}</code></pre> 
<h4 id="2.6.11%20%E5%88%A0%E9%99%A4%E8%81%8C%E5%B7%A5"><span style="color:#38d8f0;">2.6.11 删除职工</span></h4> 
<pre><code>// 按照职工编号判断教职工是否存在，若存在返回职工在数组中的位置，不存在返回-1
int WorkerManager::IsExist(int ID)
{
	int Index = -1;

	for (int i = 0; i &lt; this-&gt;m_EmpNum;i++)
	{
		if (this-&gt;m_EmpArray[i]-&gt;m_ID == ID) // 找到了，存在
		{ 
			Index = i;
			break;
		}
	}
	return Index;
}

// 删除职工
void WorkerManager::Del_Emp()
{
	if (this-&gt;m_FileIsEmpty)
	{
		cout &lt;&lt; "文件不存在或记录为空！" &lt;&lt; endl;
	}
	else
	{
		// 按照职工的编号进行删除职工
		int ID = 0;
		cout &lt;&lt; "请输入要删除职工的编号：" &lt;&lt; endl;
		cin &gt;&gt; ID;

		int Index = this-&gt;IsExist(ID);
		if (Index != -1) // 职工存在，并且这个职工在数组中的下标就是Index
		{
			for (int i = Index; i &lt; this-&gt;m_EmpNum-1;i++) // 从当前找到的这个位置开始数据前移
			{
				this-&gt;m_EmpArray[i] = this-&gt;m_EmpArray[i + 1];
			}
			this-&gt;m_EmpNum--; // 更新数组中人员个数
			// 同步到文件中
			this-&gt;Save();

			cout &lt;&lt; "删除成功！" &lt;&lt; endl;
		}
		else
		{
			cout &lt;&lt; "删除失败，未找到该职工" &lt;&lt; endl;
		}
	}
	system("pause");
	system("cls");
}</code></pre> 
<h4 id="2.6.12%20%E4%BF%AE%E6%94%B9%E8%81%8C%E5%B7%A5"><span style="color:#38d8f0;">2.6.12 修改职工</span></h4> 
<pre><code>// 修改职工
void WorkerManager::Mod_Emp()
{
	if (this-&gt;m_FileIsEmpty)
	{
		cout &lt;&lt; "文件不存在或记录为空！" &lt;&lt; endl;
	}
	else
	{
		cout &lt;&lt; "请输入修改职工的编号：" &lt;&lt; endl;
		int ID;
		cin &gt;&gt; ID;

		int Ret = this-&gt;IsExist(ID);
		if (Ret!=-1) // 存在
		{
			// 释放原来的数据，创建新的
			delete this-&gt;m_EmpArray[Ret];

			int NewID = 0;
			string NewName = "";
			int NewDID = 0;

			cout &lt;&lt; "查到：" &lt;&lt; ID &lt;&lt; "号职工，请输入新职工号" &lt;&lt; endl;
			cin &gt;&gt; NewID;

			cout &lt;&lt; "请输入新姓名" &lt;&lt; endl;
			cin &gt;&gt; NewName;

			cout &lt;&lt; "请输入新岗位" &lt;&lt; endl;
			cout &lt;&lt; "1、普通职工" &lt;&lt; endl;
			cout &lt;&lt; "2、经理" &lt;&lt; endl;
			cout &lt;&lt; "3、老板" &lt;&lt; endl;
			cin &gt;&gt; NewDID;

			Worker* worker = NULL;
			switch (NewDID)
			{
			case 1:
				worker = new Employee(NewID, NewName, NewDID);
				break;
			case 2:
				worker = new Manager(NewID, NewName, NewDID);
				break;
			case 3:
				worker = new Boss(NewID, NewName, NewDID);
				break;
			default:
				break;
			}
		 // 更新数据到数组中
			this-&gt;m_EmpArray[Ret] = worker;

			// 修改成功
			cout &lt;&lt; "修改成功！" &lt;&lt; endl;

			// 保存到文件中
			this-&gt;Save();
		}
		else
		{
			cout &lt;&lt; "修改失败，查无此人！" &lt;&lt; endl;
		}
	}
	system("pause");
	system("cls");
}</code></pre> 
<h4 id="2.6.13%20%E6%9F%A5%E6%89%BE%E8%81%8C%E5%B7%A5"><span style="color:#38d8f0;">2.6.13 查找职工</span></h4> 
<pre><code class="hljs">// 查找职工
void WorkerManager::Find_Emp()
{
	if (this-&gt;m_FileIsEmpty)
	{
		cout &lt;&lt; "文件不存在或记录为空！" &lt;&lt; endl;
	}
	else
	{
		cout &lt;&lt; "请输入查找的方式：" &lt;&lt; endl;
		cout &lt;&lt; "1、按职工编号查找" &lt;&lt; endl;
		cout &lt;&lt; "2、按职工姓名查找" &lt;&lt; endl;
		int Select = 0;
		cin &gt;&gt; Select;

		if (Select==1)
		{
			// 按照编号查
			int id;
			cout &lt;&lt; "请输入查找职工的编号：" &lt;&lt; endl;
			cin &gt;&gt; id;

			int ID = this-&gt;IsExist(id);
			if (ID!=-1) // 找到了
			{
				cout &lt;&lt; "查找成功！该职工的信息如下：" &lt;&lt; endl;
				this-&gt;m_EmpArray[ID]-&gt;ShowInfo();
			}
			else
			{
				cout &lt;&lt; "查找失败！查无此人！" &lt;&lt; endl;
			}
		}
		else if (Select == 2)
		{
			// 按照姓名查
			string Name;
			cout &lt;&lt; "请输入查找的姓名：" &lt;&lt; endl;
			cin &gt;&gt; Name;

			// 加入一个是否查到的标志 
			bool Flag = false;

			for (int i = 0; i &lt; this-&gt;m_EmpNum; i++)
			{
				if (this-&gt;m_EmpArray[i]-&gt;m_Name==Name)
				{
					cout &lt;&lt; "查找成功，职工编号为：" &lt;&lt; this-&gt;m_EmpArray[i]-&gt;m_ID &lt;&lt; "号职工信息如下：" &lt;&lt; endl;
					this-&gt;m_EmpArray[i]-&gt;ShowInfo();
					Flag = true;
				}
			}
			if (Flag == false)
			{
				cout &lt;&lt; "查找失败，查无此人！" &lt;&lt; endl;
			}
		}
		else
		{
			cout &lt;&lt; "输入选项有误！" &lt;&lt; endl;
		}
	}
	system("pause");
	system("cls");
}</code></pre> 
<h4 id="2.6.14%20%E6%8E%92%E5%BA%8F"><span style="color:#38d8f0;">2.6.14 排序</span></h4> 
<pre><code class="hljs">// 排序职工
void WorkerManager::Sort_Emp()
{
	if (this-&gt;m_FileIsEmpty)
	{
		cout &lt;&lt; "文件不存在或记录为空！" &lt;&lt; endl;
		system("pause");
		system("cls");
	}
	else
	{ 
		cout &lt;&lt; "请选择排序方式：" &lt;&lt; endl;
		cout &lt;&lt; "1、按职工号进行升序" &lt;&lt; endl;
		cout &lt;&lt; "2、按职工号进行降序" &lt;&lt; endl;
		int Select = 0;
		cin &gt;&gt; Select;

		// 这里使用选择排序的思想进行排序：
		// 思想是：
		// 首先假设数组中第一个元素是最小值，从第二个元素开始遍历，遍历整个数组
		// 如果找到比第一个元素还要小的值，就和第一个元素进行互换；
		// 然后从第三个元素开始遍历找到比第二个元素还要小的值，和第二个元素进行互换；
		// 依次循环即可！

		for (int i = 0; i &lt; this-&gt;m_EmpNum;i++)
		{
			int MinOrMax = i; // 定义一个最小值或者最大值的变量，用于进行升序或者降序的排列
			for (int j = i + 1; j&lt;this-&gt;m_EmpNum;j++)
			{
				if (Select == 1) // 升序
				{
					if (this-&gt;m_EmpArray[MinOrMax]-&gt;m_ID &gt; this-&gt;m_EmpArray[j]-&gt;m_ID)
					{
						MinOrMax = j; // 通过遍历整个数组的编号，一旦有比第一个元素小的，就将小的这个编号赋值给MinOrMax
						// 循环结束MinOrMax得到的就是最小的编号
					}
				}
				else
				{
					if (this-&gt;m_EmpArray[MinOrMax]-&gt;m_ID &lt; this-&gt;m_EmpArray[j]-&gt;m_ID)
					{
						MinOrMax = j;
					}
				}
			}
			// 通过上述循环结束就可以得到最小或者最大的编号
			// 判断一开始认定的最小值是不是实际的最小值
			if (i != MinOrMax) // 也就是说我们一开始认定的编号最小值不是实际的编号最小值，此时把编号对应的信息进行交换
			{
				Worker* Temp = this-&gt;m_EmpArray[i];
				this-&gt;m_EmpArray[i] = this-&gt;m_EmpArray[MinOrMax];
				this-&gt;m_EmpArray[MinOrMax] = Temp;
			}
		}
		cout &lt;&lt; "排序成功！排序以后的结果为：" &lt;&lt; endl;
		this-&gt;Save();
		this-&gt;Show_Emp();
	}
}</code></pre> 
<h4 id="2.6.15%20%E6%B8%85%E7%A9%BA%E6%96%87%E4%BB%B6"><span style="color:#38d8f0;">2.6.15 清空文件</span></h4> 
<pre><code class="hljs">// 清空文件
void WorkerManager::Clean_File()
{
	cout &lt;&lt; "确认清空？" &lt;&lt; endl;
	cout &lt;&lt; "1、确认" &lt;&lt; endl;
	cout &lt;&lt; "2、返回" &lt;&lt; endl;

	int Select = 0;
	cin &gt;&gt; Select;

	if (Select==1)
	{
		// 打开模式  ios::trunc  如果存在删除文件并重新创建
		ofstream ofs(FILENAME,ios::trunc);
		ofs.close();

		if (this-&gt;m_EmpArray!=NULL) // 如果该数组不为空，则释放该数组
		{
			for (int i = 0; i &lt; this-&gt;m_EmpNum;i++) // 通过 for 循环依次遍历整个数组
			{
				if (this-&gt;m_EmpArray != NULL)
				{
					delete this-&gt;m_EmpArray[i]; // 依次释放数组中的每一项
				}
			}
			this-&gt;m_EmpNum = 0; // 将数组中的成员数量设置为0
			delete[] this-&gt;m_EmpArray; // 在堆区将动态开辟的数组释放掉！
			this-&gt;m_EmpArray = NULL; // 将指针指向空
			this-&gt;m_FileIsEmpty = true;
		}
		cout &lt;&lt; "清空成功！" &lt;&lt; endl;
	}
	system("pause");
	system("cls");
}</code></pre> 
<h4 id="2.6.16%20%E5%AE%8C%E6%95%B4%E7%A8%8B%E5%BA%8F%E4%BB%A3%E7%A0%81"><span style="color:#38d8f0;">2.6.16 完整程序代码</span></h4> 
<h5 id="2.6.16.1%20ManagerWorker.cpp"><span style="color:#a2e043;">2.6.16.1 ManagerWorker.cpp</span></h5> 
<pre><code class="hljs">#define _CRT_SECURE_NO_WARNINGS 1
#include &lt;iostream&gt;
#include &lt;string&gt; // 用 C++ 风格的字符串需要包含这个头文件
#include &lt;ctime&gt; // time 系统时间头文件包含
#include &lt;fstream&gt; // 文件操作必须引用该头文件
#include "HelloWorld.h"
using namespace std;

#define FILENAME "EmpFile.txt"

class Worker;

// 构造函数空实现
WorkerManager::WorkerManager() // 通过调用类初始化构造函数
{
	// 1、文件不存在
	ifstream ifs;
	ifs.open(FILENAME,ios::in); // 读取这个文件

	if (!ifs.is_open())
	{
		cout &lt;&lt; "文件不存在" &lt;&lt; endl;
		// 初始化成员属性
		this-&gt;m_EmpNum = 0;
		this-&gt;m_EmpArray = NULL;
		this-&gt;m_FileIsEmpty = true;
		ifs.close();
		return;
	}

	// 2、文件存在  数据为空
	char ch;
	ifs &gt;&gt; ch; // 一个字符一个字符的读该文件
	if (ifs.eof())
	{
		// 文件为空
		cout &lt;&lt; "文件为空！" &lt;&lt; endl;
		// 初始化成员属性
		this-&gt;m_EmpNum = 0;
		this-&gt;m_EmpArray = NULL;
		this-&gt;m_FileIsEmpty = true;
		ifs.close();
		return;
	}
	
	// 3、文件存在且保存职工数据
	int Num = this-&gt;Get_EmpNum();
	cout &lt;&lt; "职工人数为：" &lt;&lt; Num &lt;&lt; endl;
	this-&gt;m_EmpNum = Num; 

	this-&gt;m_EmpArray = new Worker*[this-&gt;m_EmpNum];
	// 将文件中的数据存放到数组中
	this-&gt;Init_Emp();

	for (int i = 0; i &lt; this-&gt;m_EmpNum; i++)
	{
		cout &lt;&lt; "职工编号：" &lt;&lt; this-&gt;m_EmpArray[i]-&gt;m_ID
			&lt;&lt; "\t姓名：" &lt;&lt; this-&gt;m_EmpArray[i]-&gt;m_Name
			&lt;&lt; "\t部门编号：" &lt;&lt; this-&gt;m_EmpArray[i]-&gt;m_DeptID &lt;&lt; endl;
	}
}

// 展示菜单的函数
void WorkerManager::Show_Menu() // 调用类初始化菜单函数，表示该成员函数属于类 WorkerManager
{
	cout &lt;&lt; "**********************************************" &lt;&lt; endl;
	cout &lt;&lt; "*********** 欢迎使用职工管理系统！************" &lt;&lt; endl;
	cout &lt;&lt; "*************  0. 退出管理程序  **************" &lt;&lt; endl;
	cout &lt;&lt; "*************  1. 增加职工信息  **************" &lt;&lt; endl;
	cout &lt;&lt; "*************  2. 显示职工信息  **************" &lt;&lt; endl;
	cout &lt;&lt; "*************  3. 删除离职职工  **************" &lt;&lt; endl;
	cout &lt;&lt; "*************  4. 修改职工信息  **************" &lt;&lt; endl;
	cout &lt;&lt; "*************  5. 查找职工信息  **************" &lt;&lt; endl;
	cout &lt;&lt; "*************  6. 按照编号排序  **************" &lt;&lt; endl;
	cout &lt;&lt; "*************  7. 清空所以文档  **************" &lt;&lt; endl;
	cout &lt;&lt; "**********************************************" &lt;&lt; endl;
	cout &lt;&lt; endl;
}

// 退出系统的函数
void WorkerManager::Exit_System()
{
	cout &lt;&lt; "欢迎下次使用！" &lt;&lt; endl;
	system("pause");
	exit(0);  // 退出程序
}

// 创建一个员工类去继承Worker职工类
class Employee :public Worker
{
public:
	// 构造函数
	Employee(int ID, string Name, int DID);
	// 重写
	// 显示个人信息
	void ShowInfo();
	// 获取岗位的名称
	string GetDeptName();
};

// 构造函数
Employee::Employee(int ID, string Name, int DID)
{
	this-&gt;m_ID = ID; // this 指向自身，表示初始化自身的ID、姓名以及编号
	this-&gt;m_Name = Name;
	this-&gt;m_DeptID = DID;
}
// 显示个人信息
void Employee::ShowInfo()
{
	cout &lt;&lt; "职工编号：" &lt;&lt; this-&gt;m_ID
		&lt;&lt; "\t职工姓名：" &lt;&lt; this-&gt;m_Name
		&lt;&lt; "\t职工岗位：" &lt;&lt; this-&gt;GetDeptName()
		&lt;&lt; "\t岗位职责：完成经理交给的任务" &lt;&lt; endl;
}
// 获取岗位的名称
string Employee::GetDeptName()
{
	return string("员工");
}

// 创建一个经理类去继承Worker职工类
class Manager :public Worker
{
public:
	// 构造函数
	Manager(int ID, string Name, int DID);
	// 重写
	// 显示个人信息
	void ShowInfo();
	// 获取岗位的名称
	string GetDeptName();
};
// 构造函数
Manager::Manager(int ID, string Name, int DID)
{
	this-&gt;m_ID = ID; // this 指向自身，表示初始化自身的ID、姓名以及编号
	this-&gt;m_Name = Name;
	this-&gt;m_DeptID = DID;
}
// 显示个人信息
void Manager::ShowInfo()
{
	cout &lt;&lt; "职工编号：" &lt;&lt; this-&gt;m_ID
		&lt;&lt; "\t职工姓名：" &lt;&lt; this-&gt;m_Name
		&lt;&lt; "\t职工岗位：" &lt;&lt; this-&gt;GetDeptName()
		&lt;&lt; "\t岗位职责：完成老板交给的任务，并且下发任务给普通员工" &lt;&lt; endl;
}
// 获取岗位的名称
string Manager::GetDeptName()
{
	return string("经理");
}

// 创建一个老板类去继承Worker职工类
class Boss :public Worker
{
public:
	// 构造函数
	Boss(int ID, string Name, int DID);
	// 重写
	// 显示个人信息
	void ShowInfo();
	// 获取岗位的名称
	string GetDeptName();
};
// 构造函数
Boss::Boss(int ID, string Name, int DID)
{
	this-&gt;m_ID = ID; // this 指向自身，表示初始化自身的ID、姓名以及编号
	this-&gt;m_Name = Name;
	this-&gt;m_DeptID = DID;
}
// 显示个人信息
void Boss::ShowInfo()
{
	cout &lt;&lt; "职工编号：" &lt;&lt; this-&gt;m_ID
		&lt;&lt; "\t职工姓名：" &lt;&lt; this-&gt;m_Name
		&lt;&lt; "\t职工岗位：" &lt;&lt; this-&gt;GetDeptName()
		&lt;&lt; "\t岗位职责：管理公司所有的事务" &lt;&lt; endl;
}
// 获取岗位的名称
string Boss::GetDeptName()
{
	return string("总裁");
}

// 添加职工的过程
// 用户在批量创建时，可能会创建不同种类的职工
// 如果想将所有不同种类的员工都放入到一个数组中，可以将所有员工的指针维护到一个数组中
// 如果想在程序中维护这个不定长度的数组，可以将数组创建到堆区，并利用 Worker ** 的指针维护
// 添加职工
void WorkerManager::Add_Emp()
{
	cout &lt;&lt; "请输入添加职工的数量：" &lt;&lt; endl;

	int AddNum = 0; // 保存用户的输入数量
	cin &gt;&gt; AddNum;

	if (AddNum&gt;0)
	{
		// 计算添加新数据的大小
		int NewSize = this-&gt;m_EmpNum + AddNum; // 新空间的人数 = 原来记录的人数 + 新添加的人数

		// 开辟新空间
		Worker** NewSpace = new Worker*[NewSize]; // 在上面计算出的新空间人数的基础上，在堆区开辟对应空间大小的新空间，new返回类型为指针

		// 假设原来就有人，那么需要把原来的人拷贝到新开辟的空间上
		if (this-&gt;m_EmpArray!=NULL)
		{
			for (int i = 0; i &lt; this-&gt;m_EmpNum;i++) // 创建 for 循环，循环体大小为原来数组中已有的人数，因为要实现把已有的人转移到新数组中
			{
				NewSpace[i] = this-&gt;m_EmpArray[i]; // 拷贝到新空间
			}
		}

		// 添加新数据
		for (int i = 0; i &lt; AddNum;i++)
		{
			int ID; // 职工编号
			string Name; // 职工姓名
			int DSelect; // 部门选择

			cout &lt;&lt; "请输入第" &lt;&lt; i + 1 &lt;&lt; "个新职工编号：" &lt;&lt; endl;
			cin &gt;&gt; ID;
			cout &lt;&lt; "请输入第" &lt;&lt; i + 1 &lt;&lt; "个新职工姓名：" &lt;&lt; endl;
			cin &gt;&gt; Name;

			cout &lt;&lt; "请输入该职工岗位：" &lt;&lt; endl;
			cout &lt;&lt; "1、普通职工" &lt;&lt; endl;
			cout &lt;&lt; "2、经理" &lt;&lt; endl;
			cout &lt;&lt; "3、老板" &lt;&lt; endl;
			cin &gt;&gt; DSelect;

			Worker *worker = NULL;
			switch (DSelect)
			{
			case 1:
				worker = new Employee(ID, Name, 1);
				break;
			case 2:
				worker = new Manager(ID, Name, 2);
				break;
			case 3:
				worker = new Boss(ID, Name, 3);
				break;
			default:
				break;
			}
			// 将创建的职工职责，保存到新数组中 
			NewSpace[this-&gt;m_EmpNum + i] = worker;
		}
		// 释放原有的空间
		delete [] this-&gt;m_EmpArray;

		// 更改新空间的指向
		this-&gt;m_EmpArray = NewSpace;

		// 更新新的职工人数
		this-&gt;m_EmpNum = NewSize;

		// 更新职工不为空的标志
		this-&gt;m_FileIsEmpty = false;

		// 提示
		cout &lt;&lt; "成功添加" &lt;&lt; AddNum &lt;&lt; "名新职员！" &lt;&lt; endl;

		this-&gt;Save(); // 添加完以后，将这个人保存到文件中
	}
	else
	{
		cout &lt;&lt; "输入有误！" &lt;&lt; endl;
	}

	// 按任意键清屏，回到上级目录
	system("pause");
	system("cls");
}

// 保存文件
void WorkerManager::Save()
{
	ofstream ofs;
	ofs.open(FILENAME,ios::out); // 用输出的方式打开文件，也就是写文件 

	// 将每个人的数据写到文件中
	for (int i = 0; i &lt; this-&gt;m_EmpNum;i++)
	{ // m_EmpArray是一个指针数组，所以该数组内存储的都是指针，可以指向Worker
		ofs &lt;&lt; this-&gt;m_EmpArray[i]-&gt;m_ID &lt;&lt; " "
			&lt;&lt; this-&gt;m_EmpArray[i]-&gt;m_Name &lt;&lt; " "
			&lt;&lt; this-&gt;m_EmpArray[i]-&gt;m_DeptID &lt;&lt; endl;
	}
	ofs.close();
}

// 统计文件中的人数
int WorkerManager::Get_EmpNum()
{
	ifstream ifs;
	ifs.open(FILENAME, ios::in); // 打开文件 读

	int ID;
	string Name;
	int DID;

	int Num = 0;

	while (ifs&gt;&gt;ID &amp;&amp; ifs&gt;&gt;Name &amp;&amp; ifs&gt;&gt;DID)
	{
		// 统计人数
		Num++;
	}
	return Num;
}

// 初始化员工
void WorkerManager::Init_Emp()
{
	ifstream ifs;
	ifs.open(FILENAME,ios::in);

	int ID;
	string Name;
	int DID;

	int Index = 0;
	while (ifs&gt;&gt;ID &amp;&amp; ifs&gt;&gt;Name &amp;&amp; ifs&gt;&gt;DID)
	{
		Worker* worker = NULL;

		if (DID==1) // 普通员工
		{
			worker = new Employee(ID,Name,DID);
		}
		else if (DID == 2) // 经理员工
		{
			worker = new Manager(ID, Name, DID);
		}
		else if (DID == 3) // 老板员工
		{
			worker = new Boss(ID, Name, DID);
		}
		this-&gt;m_EmpArray[Index] = worker;
		Index++;
	}
	ifs.close();
}

// 显示职工
void WorkerManager::Show_Emp()
{
	// 判断文件是否为空
	if (this-&gt;m_FileIsEmpty)
	{
		cout &lt;&lt; "文件不存在或记录为空！" &lt;&lt; endl;
	}
	else
	{
		for (int i = 0; i &lt; m_EmpNum;i++)
		{
			// 利用多态调用程序接口
			this-&gt;m_EmpArray[i]-&gt;ShowInfo();
		}
	}
	// 按任意键后清屏
	system("pause");
	system("cls");
}

// 按照职工编号判断教职工是否存在，若存在返回职工在数组中的位置，不存在返回-1
int WorkerManager::IsExist(int ID)
{
	int Index = -1;

	for (int i = 0; i &lt; this-&gt;m_EmpNum;i++)
	{
		if (this-&gt;m_EmpArray[i]-&gt;m_ID == ID) // 找到了，存在
		{ 
			Index = i;
			break;
		}
	}
	return Index;
}

// 删除职工
void WorkerManager::Del_Emp()
{
	if (this-&gt;m_FileIsEmpty)
	{
		cout &lt;&lt; "文件不存在或记录为空！" &lt;&lt; endl;
	}
	else
	{
		// 按照职工的编号进行删除职工
		int ID = 0;
		cout &lt;&lt; "请输入要删除职工的编号：" &lt;&lt; endl;
		cin &gt;&gt; ID;

		int Index = this-&gt;IsExist(ID);
		if (Index != -1) // 职工存在，并且这个职工在数组中的下标就是Index
		{
			for (int i = Index; i &lt; this-&gt;m_EmpNum-1;i++) // 从当前找到的这个位置开始数据前移
			{
				this-&gt;m_EmpArray[i] = this-&gt;m_EmpArray[i + 1];
			}
			this-&gt;m_EmpNum--; // 更新数组中人员个数
			// 同步到文件中
			this-&gt;Save();

			cout &lt;&lt; "删除成功！" &lt;&lt; endl;
		}
		else
		{
			cout &lt;&lt; "删除失败，未找到该职工" &lt;&lt; endl;
		}
	}
	system("pause");
	system("cls");
}

// 修改职工
void WorkerManager::Mod_Emp()
{
	if (this-&gt;m_FileIsEmpty)
	{
		cout &lt;&lt; "文件不存在或记录为空！" &lt;&lt; endl;
	}
	else
	{
		cout &lt;&lt; "请输入修改职工的编号：" &lt;&lt; endl;
		int ID;
		cin &gt;&gt; ID;

		int Ret = this-&gt;IsExist(ID);
		if (Ret!=-1) // 存在
		{
			// 释放原来的数据，创建新的
			delete this-&gt;m_EmpArray[Ret];

			int NewID = 0;
			string NewName = "";
			int NewDID = 0;

			cout &lt;&lt; "查到：" &lt;&lt; ID &lt;&lt; "号职工，请输入新职工号" &lt;&lt; endl;
			cin &gt;&gt; NewID;

			cout &lt;&lt; "请输入新姓名" &lt;&lt; endl;
			cin &gt;&gt; NewName;

			cout &lt;&lt; "请输入新岗位" &lt;&lt; endl;
			cout &lt;&lt; "1、普通职工" &lt;&lt; endl;
			cout &lt;&lt; "2、经理" &lt;&lt; endl;
			cout &lt;&lt; "3、老板" &lt;&lt; endl;
			cin &gt;&gt; NewDID;

			Worker* worker = NULL;
			switch (NewDID)
			{
			case 1:
				worker = new Employee(NewID, NewName, NewDID);
				break;
			case 2:
				worker = new Manager(NewID, NewName, NewDID);
				break;
			case 3:
				worker = new Boss(NewID, NewName, NewDID);
				break;
			default:
				break;
			}
		 // 更新数据到数组中
			this-&gt;m_EmpArray[Ret] = worker;

			// 修改成功
			cout &lt;&lt; "修改成功！" &lt;&lt; endl;

			// 保存到文件中
			this-&gt;Save();
		}
		else
		{
			cout &lt;&lt; "修改失败，查无此人！" &lt;&lt; endl;
		}
	}
	system("pause");
	system("cls");
}

// 查找职工
void WorkerManager::Find_Emp()
{
	if (this-&gt;m_FileIsEmpty)
	{
		cout &lt;&lt; "文件不存在或记录为空！" &lt;&lt; endl;
	}
	else
	{
		cout &lt;&lt; "请输入查找的方式：" &lt;&lt; endl;
		cout &lt;&lt; "1、按职工编号查找" &lt;&lt; endl;
		cout &lt;&lt; "2、按职工姓名查找" &lt;&lt; endl;
		int Select = 0;
		cin &gt;&gt; Select;

		if (Select==1)
		{
			// 按照编号查
			int id;
			cout &lt;&lt; "请输入查找职工的编号：" &lt;&lt; endl;
			cin &gt;&gt; id;

			int ID = this-&gt;IsExist(id);
			if (ID!=-1) // 找到了
			{
				cout &lt;&lt; "查找成功！该职工的信息如下：" &lt;&lt; endl;
				this-&gt;m_EmpArray[ID]-&gt;ShowInfo();
			}
			else
			{
				cout &lt;&lt; "查找失败！查无此人！" &lt;&lt; endl;
			}
		}
		else if (Select == 2)
		{
			// 按照姓名查
			string Name;
			cout &lt;&lt; "请输入查找的姓名：" &lt;&lt; endl;
			cin &gt;&gt; Name;

			// 加入一个是否查到的标志 
			bool Flag = false;

			for (int i = 0; i &lt; this-&gt;m_EmpNum; i++)
			{
				if (this-&gt;m_EmpArray[i]-&gt;m_Name==Name)
				{
					cout &lt;&lt; "查找成功，职工编号为：" &lt;&lt; this-&gt;m_EmpArray[i]-&gt;m_ID &lt;&lt; "号职工信息如下：" &lt;&lt; endl;
					this-&gt;m_EmpArray[i]-&gt;ShowInfo();
					Flag = true;
				}
			}
			if (Flag == false)
			{
				cout &lt;&lt; "查找失败，查无此人！" &lt;&lt; endl;
			}
		}
		else
		{
			cout &lt;&lt; "输入选项有误！" &lt;&lt; endl;
		}
	}
	system("pause");
	system("cls");
}

// 排序职工
void WorkerManager::Sort_Emp()
{
	if (this-&gt;m_FileIsEmpty)
	{
		cout &lt;&lt; "文件不存在或记录为空！" &lt;&lt; endl;
		system("pause");
		system("cls");
	}
	else
	{ 
		cout &lt;&lt; "请选择排序方式：" &lt;&lt; endl;
		cout &lt;&lt; "1、按职工号进行升序" &lt;&lt; endl;
		cout &lt;&lt; "2、按职工号进行降序" &lt;&lt; endl;
		int Select = 0;
		cin &gt;&gt; Select;

		// 这里使用选择排序的思想进行排序：
		// 思想是：
		// 首先假设数组中第一个元素是最小值，从第二个元素开始遍历，遍历整个数组
		// 如果找到比第一个元素还要小的值，就和第一个元素进行互换；
		// 然后从第三个元素开始遍历找到比第二个元素还要小的值，和第二个元素进行互换；
		// 依次循环即可！

		for (int i = 0; i &lt; this-&gt;m_EmpNum;i++)
		{
			int MinOrMax = i; // 定义一个最小值或者最大值的变量，用于进行升序或者降序的排列
			for (int j = i + 1; j&lt;this-&gt;m_EmpNum;j++)
			{
				if (Select == 1) // 升序
				{
					if (this-&gt;m_EmpArray[MinOrMax]-&gt;m_ID &gt; this-&gt;m_EmpArray[j]-&gt;m_ID)
					{
						MinOrMax = j; // 通过遍历整个数组的编号，一旦有比第一个元素小的，就将小的这个编号赋值给MinOrMax
						// 循环结束MinOrMax得到的就是最小的编号
					}
				}
				else
				{
					if (this-&gt;m_EmpArray[MinOrMax]-&gt;m_ID &lt; this-&gt;m_EmpArray[j]-&gt;m_ID)
					{
						MinOrMax = j;
					}
				}
			}
			// 通过上述循环结束就可以得到最小或者最大的编号
			// 判断一开始认定的最小值是不是实际的最小值
			if (i != MinOrMax) // 也就是说我们一开始认定的编号最小值不是实际的编号最小值，此时把编号对应的信息进行交换
			{
				Worker* Temp = this-&gt;m_EmpArray[i];
				this-&gt;m_EmpArray[i] = this-&gt;m_EmpArray[MinOrMax];
				this-&gt;m_EmpArray[MinOrMax] = Temp;
			}
		}
		cout &lt;&lt; "排序成功！排序以后的结果为：" &lt;&lt; endl;
		this-&gt;Save();
		this-&gt;Show_Emp();
	}
}

// 清空文件
void WorkerManager::Clean_File()
{
	cout &lt;&lt; "确认清空？" &lt;&lt; endl;
	cout &lt;&lt; "1、确认" &lt;&lt; endl;
	cout &lt;&lt; "2、返回" &lt;&lt; endl;

	int Select = 0;
	cin &gt;&gt; Select;

	if (Select==1)
	{
		// 打开模式  ios::trunc  如果存在删除文件并重新创建
		ofstream ofs(FILENAME,ios::trunc);
		ofs.close();

		if (this-&gt;m_EmpArray!=NULL) // 如果该数组不为空，则释放该数组
		{
			for (int i = 0; i &lt; this-&gt;m_EmpNum;i++) // 通过 for 循环依次遍历整个数组
			{
				if (this-&gt;m_EmpArray != NULL)
				{
					delete this-&gt;m_EmpArray[i]; // 依次释放数组中的每一项
				}
			}
			this-&gt;m_EmpNum = 0; // 将数组中的成员数量设置为0
			delete[] this-&gt;m_EmpArray; // 在堆区将动态开辟的数组释放掉！
			this-&gt;m_EmpArray = NULL; // 将指针指向空
			this-&gt;m_FileIsEmpty = true;
		}
		cout &lt;&lt; "清空成功！" &lt;&lt; endl;
	}
	system("pause");
	system("cls");
}

// 析构函数空实现
WorkerManager::~WorkerManager() // 通过调用类初始化析构函数
{
	if (this-&gt;m_EmpArray!=NULL)
	{
		for (int i = 0; i &lt; this-&gt;m_EmpNum;i++)
		{
			if (this-&gt;m_EmpArray[i]!=NULL)
			{
				delete this-&gt;m_EmpArray[i];
			}
		}
		delete[] this-&gt;m_EmpArray;
		this-&gt;m_EmpArray = NULL;
	}
}

// 测试函数
void Test()
{
	Worker *worker; // 父类指针或者引用指向子类对象，引起多态
	worker = new Employee(1, "张三", 1);
	worker-&gt;ShowInfo();
	delete worker;

	worker = new Manager(2, "李四", 2);
	worker-&gt;ShowInfo();
	delete worker;

	worker = new Boss(3, "王五", 3);
	worker-&gt;ShowInfo();
	delete worker;
}

int main()
{
	// Test();
	WorkerManager workerManager;
	int Choice = 0; // 定义变量记录用户的选择

	while (true)
	{
		workerManager.Show_Menu();  // 显示菜单
		cout &lt;&lt; "请输入您的选择：" &lt;&lt; endl;
		cin &gt;&gt; Choice;

		switch (Choice)
		{
		case 0: // 退出系统
			workerManager.Exit_System();
			break;
		case 1: // 增加职工
			workerManager.Add_Emp();
			break;
		case 2: // 显示职工
			workerManager.Show_Emp();
			break;
		case 3: // 删除职工
			workerManager.Del_Emp();
			break;
		case 4: // 修改职工
			workerManager.Mod_Emp();
			break;
		case 5: // 查找职工
			workerManager.Find_Emp();
			break;
		case 6: // 排序职工
			workerManager.Sort_Emp();
			break;
		case 7: // 清空文档
			workerManager.Clean_File();
			break;
		default:
			system("cls"); // 清屏
			break;
		}
	}
	 
	system("pause"); // 按任意键继续！
	return 0;
}

</code></pre> 
<h5 id="2.6.16.2%20ManagerWorker.h"><span style="color:#a2e043;">2.6.16.2 ManagerWorker.h</span></h5> 
<pre><code class="hljs">#pragma once   // 防止头文件重叠
#include &lt;iostream&gt;  // 包含输入输出流文件
#include &lt;fstream&gt;
using namespace std;  // 使用标准命名空间


class Worker;

class WorkerManager
{
public:
	// 构造函数
	WorkerManager();

	// 展示菜单的函数
	void Show_Menu();

	// 退出系统
	void Exit_System();

	// 添加职工
	void Add_Emp();

	// 保存文件
	void Save();

	// 判断文件是否为空的标志
	bool m_FileIsEmpty;

	// 统计文件中的人数
	int Get_EmpNum();

	// 初始化员工
	void Init_Emp();

	// 记录职工人数
	int m_EmpNum;

	// 显示职工
	void Show_Emp();

	// 按照职工编号判断教职工是否存在，若存在返回职工在数组中的位置，不存在返回-1
	int IsExist(int ID);

	// 删除职工
	void Del_Emp();

	// 修改职工
	void Mod_Emp();

	// 查找职工
	void Find_Emp();

	// 职工数组指针
	Worker** m_EmpArray; // 用二维指针来维护，因为添加职工可能会一起添加很多人，每个人对应的职位也不同
										  // 所以借助数组来维护！

	// 排序职工
	void Sort_Emp();

	// 清空文件
	void Clean_File();

	// 析构函数
	~WorkerManager();
};

// 职工抽象类
// 职工包括员工、经理和老板，
// 这三类人统一继承职工
class Worker
{
public:
	// 显示个人信息
	virtual void ShowInfo() = 0;
	// 获取岗位的名称
	virtual string GetDeptName() = 0;

	// 编号
	int m_ID;
	// 姓名
	string m_Name;
	// 部门编号
	int m_DeptID;
};</code></pre> 
<p></p> 
<h2 id="3.%20C%2B%2B%20%E6%8F%90%E9%AB%98%E7%BC%96%E7%A8%8B"></h2> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/42d30e309eb716c0731b123832e85e06/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">流量预处理-3：利用cic-flowmeter工具提取流量特征</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/929f102a9de0d3c8b99809804cc16bae/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Unity&amp;&amp;C#学习笔记-反射</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>