<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>c  mysql 链接池溢出_连接池溢出以及大量查询系统表的问题 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="c  mysql 链接池溢出_连接池溢出以及大量查询系统表的问题" />
<meta property="og:description" content="&#43;Resin JNDI数据源,都出现了连接溢出的问题.
我当时猜测不是连接池的问题,就是驱动程序bug的问题.
当然经过排查,确实是连接池的问题.有溢出.
我将连接池更换为c3p0 v0.9.5.1之后,大量连接Oracle的问题已经解决.终于监听器日志不再刷了.
隔天,AWR检查,发现一个SQL在4个小时内居然执行196w次.占用数据库负载3%左右.
SELECT NULL AS table_cat,
o.owner AS table_schem,
o.object_name AS table_name,
o.object_type AS table_type,
NULL AS remarks
FROM all_objects o
WHERE o.owner LIKE :1
AND o.object_name LIKE :2
AND o.object_type IN (&#39;xxx&#39;, &#39;TABLE&#39;)
ORDER BY table_type, table_schem, table_name
刚开始以为是系统被SQL注入了..
因为之前正在排查硬解析过高的问题
后来发现是JDBC Metadata的调用.
但是这个调用的频率,明显异常.
最后发现,原来是我使用c3p0连接池的时候,还需要配置preferredTestQuery参数.
否则,默认测试连接的行为,就是DatabaseMetaData.getTables()这种操作.
preferredTestQuery设置为&#34;select 1 from dual&#34; 问题解决.
原文如下:
http://www.mchange.com/projects/c3p0/#configuring_connection_testing
Configuring Connection Testing
c3p0 can be configured to test the Connections that it pools in a variety of ways, to minimize the likelihood that your application will see broken or &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/794bfddea6f629da9d6c46eef36cbb8b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-01-28T03:05:23+08:00" />
<meta property="article:modified_time" content="2021-01-28T03:05:23+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">c  mysql 链接池溢出_连接池溢出以及大量查询系统表的问题</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div style="font-size:16px;"> 
 <p>+Resin JNDI数据源,都出现了连接溢出的问题.</p> 
 <p>我当时猜测不是连接池的问题,就是驱动程序bug的问题.</p> 
 <p>当然经过排查,确实是连接池的问题.有溢出.</p> 
 <p>我将连接池更换为c3p0 v0.9.5.1之后,大量连接Oracle的问题已经解决.终于监听器日志不再刷了.</p> 
 <p>隔天,AWR检查,发现一个SQL在4个小时内居然执行196w次.占用数据库负载3%左右.</p> 
 <p>SELECT NULL AS table_cat,</p> 
 <p>o.owner AS table_schem,</p> 
 <p>o.object_name AS table_name,</p> 
 <p>o.object_type AS table_type,</p> 
 <p>NULL AS remarks</p> 
 <p>FROM all_objects o</p> 
 <p>WHERE o.owner LIKE :1</p> 
 <p>AND o.object_name LIKE :2</p> 
 <p>AND o.object_type IN ('xxx', 'TABLE')</p> 
 <p>ORDER BY table_type, table_schem, table_name</p> 
 <p>刚开始以为是系统被SQL注入了..</p> 
 <p>因为之前正在排查硬解析过高的问题</p> 
 <p>后来发现是JDBC Metadata的调用.</p> 
 <p>但是这个调用的频率,明显异常.</p> 
 <p>最后发现,原来是我使用c3p0连接池的时候,还需要配置preferredTestQuery参数.</p> 
 <p>否则,默认测试连接的行为,就是DatabaseMetaData.getTables()这种操作.</p> 
 <p>preferredTestQuery设置为"select 1 from dual" 问题解决.</p> 
 <p>原文如下:</p> 
 <p>http://www.mchange.com/projects/c3p0/#configuring_connection_testing</p> 
 <p align="center">Configuring Connection Testing<img src="https://images2.imgbox.com/f0/dc/OwKij6yk_o.png" alt="187fad33ca24d1ac6f7da3b5569612da.png"></p> 
 <p>c3p0 can be configured to test the Connections that it pools in a variety of ways, to minimize the likelihood that your application will see broken or "stale" Connections. Pooled Connections can go bad for a variety of reasons -- some JDBC drivers intentionally "time-out" long-lasting database Connections; back-end databases or networks sometimes go down "stranding" pooled Connections; and Connections can simply become corrupted over time and use due to resource leaks, driver bugs, or other causes.</p> 
 <p>c3p0 provides users a great deal of flexibility in testing Connections, via the following configuration parameters:</p> 
 <p>idleConnectionTestPeriod, testConnectionOnCheckout, and testConnectionOnCheckin control when Connections will be tested. automaticTestTable, connectionTesterClassName, and preferredTestQuery control how they will be tested.</p> 
 <p>When configuring Connection testing, first try to minimize the cost of each test. If you are using a JDBC driver that you are certain supports the new(ish) jdbc4 API — and if you are using c3p0-0.9.5 or higher! — let your driver handle this for you. jdbc4 Connections include a method called isValid() that should be implemented as a fast, reliable Connection test. By default, c3p0 will use that method if it is present.</p> 
 <p>However, if your driver does not support this new-ish API, c3p0's default behavior is to test Connections by calling the getTables() method on a Connection's associated DatabaseMetaData object. This has the advantage of being very robust and working with any database, regardless of the database schema. However, a call to DatabaseMetaData.getTables() is often much slower than a simple database query, and using this test may significantly impair your pool's performance.</p> 
 <p>The simplest way to speed up Connection testing under a JDBC 3 driver (or a pre-0.9.5 version of c3p0) is to define a test query with the preferredTestQuery parameter. Be careful, however. Setting preferredTestQuery will lead to errors as Connection tests fail if the query target table does not exist in your database prior to initialization of your DataSource. Depending on your database and JDBC driver, a table-independent query like SELECT 1 may (or may not) be sufficient to verify the Connection. If a table-independent query is not sufficient, instead of preferredTestQuery, you can set the parameter automaticTestTable. Using the name you provide, c3p0 will create an empty table, and make a simple query against it to test the database.</p> 
 <p>The most reliable time to test Connections is on check-out. But this is also the most costly choice from a client-performance perspective. Most applications should work quite reliably using a combination of idleConnectionTestPeriod and testConnectionOnCheckin. Both the idle test and the check-in test are performed asynchronously, which can lead to better performance, both perceived and actual.</p> 
 <p>For some applications, high performance is more important than the risk of an occasional database exception. In its default configuration, c3p0 does no Connection testing at all. Setting a fairly long idleConnectionTestPeriod, and not testing on checkout and check-in at all is an excellent, high-performance approach.</p> 
 <p>It is possible to customize how c3p0's DefaultConnectionTester tests when no preferredTestQuery or automaticTestTable are available. Please see Configuring DefaultConnectionTester.isValidTimeout and Configuring DefaultConnectionTester.QuerylessTestRunner.</p> 
 <p>Advanced users may define any kind of Connection testing they wish, by implementing a ConnectionTester and supplying the fully qualified name of the class as connectionTesterClassName. If you'd like your custom ConnectionTesters to honor and support thepreferredTestQuery and automaticTestTable parameters, implement UnifiedConnectionTester, most conveniently by extending AbstractConnectionTester. See the api docs for more information.</p> 
 <p>If you know you want to use the jdbc4 Connection.isValid() method, but you want to set a timeout, consider writing a trivial extension of IsValidConnectionTester.</p> 
 <p>package com.mchange.v2.c3p0.example;</p> 
 <p>import com.mchange.v2.c3p0.util.IsValidOnlyConnectionTester;</p> 
 <p>public final class IsValidOnlyConnectionTester30 extends IsValidOnlyConnectionTester</p> 
 <p>{<!-- --></p> 
 <p>protected int getIsValidTimeout() { return 30; }</p> 
 <p>}</p> 
 <p>See? These really are trivial to write.</p> 
 <p>Simple advice on Connection testing</p> 
 <p>If you don't know what to do, try this:</p> 
 <p>If you know your driver supports the JDBC 4 Connection.isValid(...) method and you are using c3p0-0.9.5 or above, don't set a preferredTestQuery. If your driver does not support this method (or if you are not sure), try SELECT 1 for your preferredTestQuery, if you are running MySQL or Postgres. For other databases, look for suggestions here. Leave automatedTestTable undefined.</p> 
 <p>Begin by setting testConnectionOnCheckout to true and get your application to run correctly and stably. If you are happy with your application's performance, you can stop here! This is the simplest, most reliable form of Connection-testing, but it does have a client-visible performance cost.</p> 
 <p>If you'd like to improve performance by eliminating Connection testing from clients' code path:</p> 
 <p>Set testConnectionOnCheckout to false</p> 
 <p>Set testConnectionOnCheckin to true</p> 
 <p>Set idleConnectionTestPeriod to 30, fire up you application and observe. This is a pretty robust setting, all Connections will tested on check-in and every 30 seconds thereafter while in the pool. Your application should experience broken or stale Connections only very rarely, and the pool should recover from a database shutdown and restart quickly. But there is some overhead associated with all that Connection testing.</p> 
 <p>If database restarts will be rare so quick recovery is not an issue, consider reducing the frequency of tests by idleConnectionTestPeriod to, say, 300, and see whether clients are troubled by stale or broken Connections. If not, stick with 300, or try an even bigger number. Consider settingtestConnectionOnCheckin back to false to avoid unnecessary tests on checkin. Alternatively, if your application does encounter bad Connections, consider reducing idleConnectionTestPeriod and set testConnectionOnCheckin back to true. There are no correct or incorrect values for these parameters: you are trading off overhead for reliability in deciding how frequently to test. The exact numbers are not so critical. It's usually easy to find configurations that perform well. It's rarely worth spending time in pursuit of "optimal" values here.</p> 
 <p>So, when should you stick with simple and reliable (Step 2 above), and when is it worth going for better performance (Step 3)? In general, it depends on how much work clients typically do with Connections once they check them out. If clients usually make complex queries and/or perform multiple operations, adding the extra cost of one fast test per checkout will not much affect performance. But if your application typically checks out a Connection and performs one simple query with it, throwing in an additional test can really slow things down.</p> 
 <p>That's nice in theory, but often people don't really have a good sense of how much work clients perform on average. The best thing to do is usually to try Step 3, see if it helps (however you measure performance), see if it hurts (is your application troubled by broken Connections? does it recover from database restarts well enough?), and then decide. You can always go back to simple, slow, and robust. Just set testConnectionOnCheckout to true, testConnectionOnCheckin to false, and set idleConnectionTestPeriod to 0.</p> 
 <p>But do, always, be sure that your tests themselves are performant, either because your JDBC driver supportsConnection.isValid(...)or because you have set an efficient preferredTestQuery !!!</p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/101d57d9e30e4b5b2f8ac48880a562d1/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">快速识别无效数据（数据有效性/数据验证）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6199aaab22db7f2407fd36089b1dca1b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">C&#43;&#43;20 标准简介</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>