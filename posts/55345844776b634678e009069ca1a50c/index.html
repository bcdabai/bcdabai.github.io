<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【UE4 C&#43;&#43;】根据指定路径生成静态网格体 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【UE4 C&#43;&#43;】根据指定路径生成静态网格体" />
<meta property="og:description" content="在上一篇博客中（【UE C&#43;&#43;】蓝图调用C&#43;&#43;函数），我们用C&#43;&#43;创建了一个蓝图函数库，本篇文章在这个蓝图函数库基础上增加一个方法，该方法只需输入一个文件目录路径，就可在场景中生成该目录下得所有静态网格体。（如果不想写C&#43;&#43;的话，可以用这篇文章的方法：UE4 | BP | 使用蓝图获取Uasset资源_ue4 蓝图加载uasset资产）
在.cpp文件中增加如下代码：
TArray&lt;UObject*&gt; UMyBlueprintFunctionLibrary::FindOrLoadAssetsByPath(const FString&amp; FilePath) { TArray&lt;UObject*&gt; LoadedObjects; EngineUtils::FindOrLoadAssetsByPath(FilePath, LoadedObjects, EngineUtils::ATL_Regular); return LoadedObjects; } 在.h文件中添加如下代码：
UFUNCTION(BlueprintCallable, Category=&#34;LibraryFunction&#34;) static TArray&lt;UObject*&gt; FindOrLoadAssetsByPath(const FString&amp; FilePath); 编译后，打开虚幻编辑器，新建一个父类为Actor的蓝图类，这里命名为“BP_CreateStaticMesh”
打开“BP_CreateStaticMesh”，添加一个静态网格体组件
添加一个变量，这里命名为“Mesh”
“Mesh”变量的变量类型是静态网格体的对象引用。勾选可编辑实例、生成时公开
在构造函数中添加如下节点，这样在“BP_CreateStaticMesh”生成时，就能根据传入给Mesh的模型来生成静态网格体
再新建一个Actor蓝图，这里命名为“BP_CreateStaticMeshByPath”
打开“BP_CreateStaticMeshByPath”，在事件图表中添加如下节点
如下是我静态网格体的存放路径
将“BP_CreateStaticMeshByPath”拖入视口
运行游戏可以看到生成了静态网格体
有时候用户想自己改变这个静态网格体，该如何做？我目前进展是：
首先打包设置中，取消勾选“使用Pak文件”，这样打包后Content文件夹中就不再仅是一个.pak文件，而是和打包前工程目录中的Content文件夹一样。
打包后，比如我删除了“Key”这个文件夹，场景中确实不会出现对应的静态网格体，还原后也还是能生成之前的静态网格体。
但是让人头大的是打包后的模型不再是FBX或是obj之类的模型，而是变成了.uasset格式文件，这样用户就不能直接向文件夹中导入一个3D模型让引擎调用。
我特地搜了一下如何将FBX转.uasset格式文件，例如：[UE4 convert .fbx to .uasset commandlet] - #7 by nyudeb - Pipeline &amp; Plugins - Epic Developer Community Forums
，但是即使生成了.uasset文件还是不行，我将.uexp文件删除后，打包后的exe就无法运行并且弹出报错的窗口。
如果路过的大佬有什么见解，还希望在评论区指点一下，谢谢~
相关文章 【UE】在游戏运行时，通过选择uasset来生成静态网格体-CSDN博客
参考文章 1. UE4 根据文件夹路径生成文件夹下的所有静态网格体(蓝图)_ue4将静态网格体转换成蓝图" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/55345844776b634678e009069ca1a50c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-10-07T14:56:26+08:00" />
<meta property="article:modified_time" content="2023-10-07T14:56:26+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【UE4 C&#43;&#43;】根据指定路径生成静态网格体</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>在上一篇博客中（<a href="https://blog.csdn.net/ChaoChao66666/article/details/131675195?spm=1001.2014.3001.5502" title="【UE C++】蓝图调用C++函数">【UE C++】蓝图调用C++函数</a>），我们用C++创建了一个蓝图函数库，本篇文章在这个蓝图函数库基础上增加一个方法，该方法只需输入一个文件目录路径，就可在场景中生成该目录下得所有静态网格体。（如果不想写C++的话，可以用这篇文章的方法：<a href="https://blog.csdn.net/weixin_40821143/article/details/112981474" title="UE4 | BP | 使用蓝图获取Uasset资源_ue4 蓝图加载uasset资产">UE4 | BP | 使用蓝图获取Uasset资源_ue4 蓝图加载uasset资产</a>）</p> 
<p>在.cpp文件中增加如下代码：</p> 
<p><img alt="" height="537" src="https://images2.imgbox.com/11/8f/xF28JKPN_o.png" width="970"></p> 
<pre><code class="language-cpp">TArray&lt;UObject*&gt; UMyBlueprintFunctionLibrary::FindOrLoadAssetsByPath(const FString&amp; FilePath)
{
	TArray&lt;UObject*&gt; LoadedObjects;

	EngineUtils::FindOrLoadAssetsByPath(FilePath, LoadedObjects, EngineUtils::ATL_Regular);
	return LoadedObjects;
}</code></pre> 
<p> 在.h文件中添加如下代码：</p> 
<p><img alt="" height="596" src="https://images2.imgbox.com/ab/65/6QrK9HsP_o.png" width="834"></p> 
<pre><code class="language-cpp">UFUNCTION(BlueprintCallable, Category="LibraryFunction")
	static TArray&lt;UObject*&gt; FindOrLoadAssetsByPath(const FString&amp; FilePath);</code></pre> 
<p>编译后，打开虚幻编辑器，新建一个父类为Actor的蓝图类，这里命名为“BP_CreateStaticMesh”</p> 
<p><img alt="" height="215" src="https://images2.imgbox.com/ff/17/Qc7varH8_o.png" width="497"></p> 
<p> 打开“BP_CreateStaticMesh”，添加一个静态网格体组件</p> 
<p><img alt="" height="262" src="https://images2.imgbox.com/65/dd/dmIvjBVX_o.png" width="440"></p> 
<p> 添加一个变量，这里命名为“Mesh”</p> 
<p><img alt="" height="150" src="https://images2.imgbox.com/df/56/CUzfQlJV_o.png" width="247"></p> 
<p>“Mesh”变量的变量类型是静态网格体的对象引用。勾选可编辑实例、生成时公开</p> 
<p><img alt="" height="366" src="https://images2.imgbox.com/e6/0d/FGMUVoiP_o.png" width="290"></p> 
<p> 在构造函数中添加如下节点，这样在“BP_CreateStaticMesh”生成时，就能根据传入给Mesh的模型来生成静态网格体</p> 
<p><img alt="" height="829" src="https://images2.imgbox.com/b9/8c/K3jX0SEV_o.png" width="806"></p> 
<p> 再新建一个Actor蓝图，这里命名为“BP_CreateStaticMeshByPath”</p> 
<p><img alt="" height="225" src="https://images2.imgbox.com/42/4e/rBkWWSOC_o.png" width="477"></p> 
<p> 打开“BP_CreateStaticMeshByPath”，在事件图表中添加如下节点</p> 
<p><img alt="" height="832" src="https://images2.imgbox.com/44/db/Xvc4S1PD_o.png" width="1200"></p> 
<p><img alt="" height="605" src="https://images2.imgbox.com/87/8f/BV5CnYzq_o.png" width="1200"></p> 
<p><img alt="" height="252" src="https://images2.imgbox.com/a7/79/SUyBuHg6_o.png" width="551"></p> 
<p> <img alt="" height="390" src="https://images2.imgbox.com/35/4b/Az90AM1W_o.png" width="378"></p> 
<p> 如下是我静态网格体的存放路径</p> 
<p><img alt="" height="182" src="https://images2.imgbox.com/c8/a8/HcomivEX_o.png" width="323"></p> 
<p><img alt="" height="279" src="https://images2.imgbox.com/4b/30/y8WNOsnx_o.png" width="399"></p> 
<p> <img alt="" height="191" src="https://images2.imgbox.com/1b/62/hMGZClAR_o.png" width="338"></p> 
<p>将“BP_CreateStaticMeshByPath”拖入视口</p> 
<p><img alt="" height="720" src="https://images2.imgbox.com/eb/d4/nIowHkNB_o.png" width="565"></p> 
<p> 运行游戏可以看到生成了静态网格体</p> 
<p><img alt="" height="688" src="https://images2.imgbox.com/2a/b4/BKHaIC0j_o.png" width="1200"></p> 
<p></p> 
<p>有时候用户想自己改变这个静态网格体，该如何做？我目前进展是：</p> 
<p>首先打包设置中，取消勾选“使用Pak文件”，这样打包后Content文件夹中就不再仅是一个.pak文件，而是和打包前工程目录中的Content文件夹一样。</p> 
<p><img alt="" height="489" src="https://images2.imgbox.com/14/f8/CWLgsNVy_o.png" width="775"></p> 
<p> 打包后，比如我删除了“Key”这个文件夹，场景中确实不会出现对应的静态网格体，还原后也还是能生成之前的静态网格体。</p> 
<p><img alt="" height="184" src="https://images2.imgbox.com/ab/29/EIVok3ph_o.png" width="663"></p> 
<p> 但是让人头大的是打包后的模型不再是FBX或是obj之类的模型，而是变成了.uasset格式文件，这样用户就不能直接向文件夹中导入一个3D模型让引擎调用。</p> 
<p>我特地搜了一下如何将FBX转.uasset格式文件，例如：<a href="https://forums.unrealengine.com/t/ue4-convert-fbx-to-uasset-commandlet/379054/7" rel="nofollow" title="[UE4 convert .fbx to .uasset commandlet] - #7 by nyudeb - Pipeline &amp; Plugins - Epic Developer Community Forums">[UE4 convert .fbx to .uasset commandlet] - #7 by nyudeb - Pipeline &amp; Plugins - Epic Developer Community Forums</a></p> 
<p>，但是即使生成了.uasset文件还是不行，我将.uexp文件删除后，打包后的exe就无法运行并且弹出报错的窗口。</p> 
<p><img alt="" height="255" src="https://images2.imgbox.com/fb/c1/UnumDk5F_o.png" width="689"></p> 
<p>如果路过的大佬有什么见解，还希望在评论区指点一下，谢谢~</p> 
<p></p> 
<h4>相关文章</h4> 
<p><a href="https://blog.csdn.net/ChaoChao66666/article/details/133638995?spm=1001.2014.3001.5502" title="【UE】在游戏运行时，通过选择uasset来生成静态网格体-CSDN博客">【UE】在游戏运行时，通过选择uasset来生成静态网格体-CSDN博客</a></p> 
<p></p> 
<h4>参考文章</h4> 
<p><a href="https://blog.csdn.net/qq_42673921/article/details/107318002" title="1. UE4 根据文件夹路径生成文件夹下的所有静态网格体(蓝图)_ue4将静态网格体转换成蓝图">1. UE4 根据文件夹路径生成文件夹下的所有静态网格体(蓝图)_ue4将静态网格体转换成蓝图</a></p> 
<p><a href="https://zhuanlan.zhihu.com/p/142651913" rel="nofollow" title="2. UE4 替换打包后的项目资源 - 知乎">2. UE4 替换打包后的项目资源 - 知乎</a></p> 
<p><a href="https://blog.csdn.net/weixin_40821143/article/details/112981474" title="3. UE4 | BP | 使用蓝图获取Uasset资源_ue4 蓝图加载uasset资产">3. UE4 | BP | 使用蓝图获取Uasset资源_ue4 蓝图加载uasset资产</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/12f9224241e0191441300ea6f93682e8/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">基于全新电脑环境安装pytorch的GPU版本</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/186ca6ad039f50e05f55bb5ee717f81c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">LLMops：大模型时代的运维与部署之道</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>