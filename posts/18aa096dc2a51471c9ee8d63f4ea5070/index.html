<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Android Framework 包管理子系统（05）intent查询组件 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Android Framework 包管理子系统（05）intent查询组件" />
<meta property="og:description" content="该系列文章总纲链接：专题分纲目录 Android Framework 包管理子系统
本章关键点总结 &amp; 说明： 导图是不断迭代的，这里主要关注➕ 查询intent组件部分。主要对PkgMS查询组件的流程进行分析，通过intent找到对应的组件并返回。简介了intent和intentFilter，说明了查询的接口，同时对queryIntentActivities接口进行流程解读。
1 intent 和 intentFilter简介
1.1 intent简介
Intent中文是“意图”的意思，它是Android系统中很常用的概念；个人认为 这种基本思想源于对生活的抽象；人与人沟通用的是语言，表达的是意图，比如：
startActivity(Intent intent) startService(Intent intent) bindService(Intent intent) sendBrodcast(Intent intent) 之所以可以用使用intent表达意图，是因为只要用特定的某种格式就可以精确的表达“意图”，因此格式的设定非常关键，intent的属性分类如下：
启动类：有ComponentName（显式）,Action（隐式），Category（隐式）。传值类：有Data（隐式），Type（隐式），Extra（隐式、显式）。启动模式类：有Flag，这意味着可以根据flag做不同的处理。 我们对比我们平时的沟通模式，启动类 对应 动词，传值类 对应 宾语，加起来就是一个动宾结构，而这就是语言中最核心的结构，“主谓宾” 是我们表达意图最常用、也是最熟悉的方式。那么根据是否有主语决定了 是显示调用还是隐式调用。而这也是intent分类的根源所在(以上仅为自己的知识积累所做的一个概述)，intent的分类如下：
Explicit Intents(显示)：这类Intent明确指明 主语。在代码中通过setComponent或setClass来锁定目标对象。处理这种Intent高效
Implicit Intents(隐示)：这一类Intents只指明动宾关系，主语是一个范围。对于这类意图，处理相对复杂。
1.2 intentFilter简介
在与人沟通的模型中，找合适的人（与谁沟通）是一个很关键的事情，比如找对象、找合作伙伴、筛选简历等等，首先我们会给出筛选的原则，之后会根据筛选原则去和遇到的每个人去匹配，而在Android中这项工作被称为Intent Resolution。在做匹配工作时，将以Intent Filter 列出的3项内容为参考 标准，具体步骤如下：
匹配IntentFilter的Action，如果Intent设置的Action不满足IntentFilter的Action，则匹配失败。如果IntentFilter未设定Action，则匹配成功。检查IntentFilter的Category，匹配方法同Action的匹配，唯一有些例外的是Category为CATEGORY_DEFAULT的情况。检查Data。Data的匹配过程比较繁琐，因为它和IntentFilter设置的Data内容有关 这里IntentFilter中的Data可以包括两个内容：
URI：完整格式为“scheme://host:port/path”，包含4个部分，scheme、host、port和path。其中host和port合起来标示URI authority，指明服务器网络地址（IP &amp; port）。由于URI最多可包含4个部分，因此要根据情况相应部分做匹配检查。Date type：指定数据的MIME类型（注意：URI中也可以携带数据的类型信息，所以在匹配过程中，还需要考虑URI中指定的数据类型） 2 通过intent查询组件
2.1 查询基础
PkgMS中很重的一项工作就是根据intent来查询处理Intent的续组件信息，处理Intent的查询接口如下：
queryIntentActivities queryIntentServices queryIntentReceivers queryIntentContentProviders 系统中响应某个intent的组件可能有多个，因此返回值是一个列表，android系统中用ResolveInfo类来表示所有组件，ResolveInfo定义如下：
public class ResolveInfo implements Parcelable { private static final String TAG = &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/18aa096dc2a51471c9ee8d63f4ea5070/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-07-18T20:20:46+08:00" />
<meta property="article:modified_time" content="2019-07-18T20:20:46+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Android Framework 包管理子系统（05）intent查询组件</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>该系列文章总纲链接：<a href="https://blog.csdn.net/vviccc/article/details/104195000">专题分纲目录 Android Framework 包管理子系统</a></p> 
<hr> 
<h3>本章关键点总结 &amp; 说明：</h3> 
<p style="text-align:center;"><img alt="" class="has" height="323" src="https://images2.imgbox.com/1f/bd/KauTDHzQ_o.png" width="600"></p> 
<p>导图是不断迭代的，这里主要关注➕ 查询intent组件部分。主要对PkgMS查询组件的流程进行分析，通过intent找到对应的组件并返回。简介了intent和intentFilter，说明了查询的接口，同时对queryIntentActivities接口进行流程解读。</p> 
<p><strong>1 intent 和 intentFilter简介</strong></p> 
<p><strong>1.1 intent简介</strong></p> 
<p>Intent中文是“意图”的意思，它是Android系统中很常用的概念；个人认为 这种基本思想源于对生活的抽象；人与人沟通用的是语言，表达的是意图，比如：</p> 
<pre class="has"><code class="language-java">startActivity(Intent intent)

startService(Intent intent)

bindService(Intent intent)

sendBrodcast(Intent intent)</code></pre> 
<p>之所以可以用使用intent表达意图，是因为只要用特定的某种格式就可以精确的表达“意图”，因此格式的设定非常关键，intent的属性分类如下：</p> 
<ol><li>启动类：有ComponentName（显式）,Action（隐式），Category（隐式）。</li><li>传值类：有Data（隐式），Type（隐式），Extra（隐式、显式）。</li><li>启动模式类：有Flag，这意味着可以根据flag做不同的处理。</li></ol> 
<p>我们对比我们平时的沟通模式，启动类 对应 动词，传值类 对应 宾语，加起来就是一个动宾结构，而这就是语言中最核心的结构，“主谓宾” 是我们表达意图最常用、也是最熟悉的方式。那么根据是否有主语决定了 是显示调用还是隐式调用。而这也是intent分类的根源所在<span style="color:#3399ea;">(以上仅为自己的知识积累所做的一个概述)，</span>intent的分类如下：</p> 
<p>Explicit Intents(显示)：这类Intent明确指明 主语。在代码中通过setComponent或setClass来锁定目标对象。处理这种Intent高效</p> 
<p>Implicit Intents(隐示)：这一类Intents只指明动宾关系，主语是一个范围。对于这类意图，处理相对复杂。</p> 
<p><strong>1.2 intentFilter简介</strong></p> 
<p>在与人沟通的模型中，找合适的人（与谁沟通）是一个很关键的事情，比如找对象、找合作伙伴、筛选简历等等，首先我们会给出筛选的原则，之后会根据筛选原则去和遇到的每个人去匹配，而在Android中这项工作被称为Intent Resolution。在做匹配工作时，将以Intent Filter 列出的3项内容为参考 标准，具体步骤如下：</p> 
<ol><li>匹配IntentFilter的Action，如果Intent设置的Action不满足IntentFilter的Action，则匹配失败。如果IntentFilter未设定Action，则匹配成功。</li><li>检查IntentFilter的Category，匹配方法同Action的匹配，唯一有些例外的是Category为CATEGORY_DEFAULT的情况。</li><li>检查Data。Data的匹配过程比较繁琐，因为它和IntentFilter设置的Data内容有关</li></ol> 
<p>这里IntentFilter中的Data可以包括两个内容：</p> 
<ol><li>URI：完整格式为“scheme://host:port/path”，包含4个部分，scheme、host、port和path。其中host和port合起来标示URI   authority，指明服务器网络地址（IP &amp; port）。由于URI最多可包含4个部分，因此要根据情况相应部分做匹配检查。</li><li>Date type：指定数据的MIME类型<span style="color:#3399ea;">（注意：URI中也可以携带数据的类型信息，所以在匹配过程中，还需要考虑URI中指定的数据类型）</span></li></ol> 
<p><strong>2 通过intent查询组件</strong></p> 
<p><strong>2.1 查询基础</strong></p> 
<p>PkgMS中很重的一项工作就是根据intent来查询处理Intent的续组件信息，处理Intent的查询接口如下：</p> 
<pre class="has"><code class="language-java">queryIntentActivities
queryIntentServices
queryIntentReceivers
queryIntentContentProviders</code></pre> 
<p>系统中响应某个intent的组件可能有多个，因此返回值是一个列表，android系统中用ResolveInfo类来表示所有组件，ResolveInfo定义如下：</p> 
<pre class="has"><code class="language-java">public class ResolveInfo implements Parcelable {
    private static final String TAG = "ResolveInfo";
    public ActivityInfo activityInfo;
    public ServiceInfo serviceInfo;
    public ProviderInfo providerInfo;
    public IntentFilter filter;
	//...
}</code></pre> 
<p style="text-indent:0;"><strong>2.2 queryIntentActivities案例</strong></p> 
<p style="text-indent:0;">几种查询组件的方式类似，这里以queryIntentActivities为例来分析查询过程，代码如下：</p> 
<pre class="has"><code class="language-java">@Override
public List&lt;ResolveInfo&gt; queryIntentActivities(Intent intent,
        String resolvedType, int flags, int userId) {
    if (!sUserManager.exists(userId)) return Collections.emptyList();
    //检查调用接口的用户权限
    enforceCrossUserPermission(Binder.getCallingUid(), userId, false, false, "query intent activities");
    ComponentName comp = intent.getComponent();
    if (comp == null) {
        if (intent.getSelector() != null) {
            intent = intent.getSelector(); 
            comp = intent.getComponent();
        }
    }

    if (comp != null) {
        //如果指定饿模块和组名，则只有一个匹配项
        final List&lt;ResolveInfo&gt; list = new ArrayList&lt;ResolveInfo&gt;(1);
        //通过模块信息得到ActivityInfo
        final ActivityInfo ai = getActivityInfo(comp, flags, userId);
        if (ai != null) {
            final ResolveInfo ri = new ResolveInfo();
            ri.activityInfo = ai;
            list.add(ri);
        }
        return list;
    }

    // reader
    synchronized (mPackages) {
        final String pkgName = intent.getPackage();
        if (pkgName == null) {//如果intent中没有包名，则在系统中查找
            List&lt;CrossProfileIntentFilter&gt; matchingFilters =
                    getMatchingCrossProfileIntentFilters(intent, resolvedType, userId);
            // Check for results that need to skip the current profile.
            ResolveInfo resolveInfo  = querySkipCurrentProfileIntents(matchingFilters, intent,
                    resolvedType, flags, userId);
            if (resolveInfo != null) {
                List&lt;ResolveInfo&gt; result = new ArrayList&lt;ResolveInfo&gt;(1);
                result.add(resolveInfo);
                return result;
            }
            //在当前profile中查找
            resolveInfo = queryCrossProfileIntents(
                    matchingFilters, intent, resolvedType, flags, userId);

            // Check for results in the current profile.
            List&lt;ResolveInfo&gt; result = mActivities.queryIntent(
                    intent, resolvedType, flags, userId);
            if (resolveInfo != null) {
                result.add(resolveInfo);
                Collections.sort(result, mResolvePrioritySorter);
            }
            return result;
        }
        //如果intent中有包名，则在指定的包中查找。
        final PackageParser.Package pkg = mPackages.get(pkgName);
        if (pkg != null) {
            return mActivities.queryIntentForPackage(intent, resolvedType, flags,
                    pkg.activities, userId);
        }
        return new ArrayList&lt;ResolveInfo&gt;();
    }
}
</code></pre> 
<p>该方法会根据Intent的信息来分别处理。整体来说，分三步处理如下：</p> 
<ol><li>如果intent中指明Component，则直接查询该Component对应的ActivityInfo，执行getActivityInfo后直接返回ActivityInfo。这是最快的方式。</li><li>如果只有包名，则调用queryIntentForPackage来，根据Package名找到该Package，然后再从该Package包含的Activities中进行匹配查询。</li><li>如果前面条件都不满足，则调用QueryIntent来搜索所有的安装包，也是最慢的查询方式。</li></ol> 
<p>queryIntentActivities的函数实现，目的就是进行Intent匹配查询。</p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6ae7df6e64bf857a46c08fd53fdae48b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Android Framework 包管理子系统（04）应用卸载</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/92829a3f96c3874e5f8fef49477c99bf/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Android Framework 包管理子系统（06）解读installd</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>