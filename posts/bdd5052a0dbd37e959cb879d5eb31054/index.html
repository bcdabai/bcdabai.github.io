<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Qt：信号和槽总结（1，C&#43;&#43;11下的信号和槽  2，第五个参数  3，阻塞 ） - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Qt：信号和槽总结（1，C&#43;&#43;11下的信号和槽  2，第五个参数  3，阻塞 ）" />
<meta property="og:description" content="Qt：信号和槽总结（1，C&#43;&#43;11下的信号和槽 2，第五个参数 3，阻塞 ）
信号和槽是Qt特有的一种通讯方法，具有以下特点：
信号与槽的连接比较灵活，可以一对一，一对多或者是多对一信号与槽的绑定与解除也十分的灵活，使用connect以及disconnect就可以了信号和槽可以用来实现线程之间的通信（信号和槽的第五个参数） 目录
常规信号和槽：
C&#43;&#43;11下的信号和槽：
信号和槽的第五个参数：
阻塞：
常规信号和槽： connect(const QObject *sender, const char *signal, const QObject *receiver, const char *method, Qt::ConnectionType type = Qt::AutoConnection)
信号和槽的标准形式如上：
//标准信号和槽
//const QObject *sender：信号发出者
//const char *signal：发出信号的名称
//const QObject *receiver：信号接受者
//const char *method：信号接收函数（槽函数）的名称
//Qt::ConnectionType type = Qt::AutoConnection：连接方式，一般默认为自动，不需要输入，Qt会自动判断，属于第五个参数
举例：
connect(begin,&amp;QPushButton::clicked,this,on_connect_clicked); begin为信号的发出者，信号为clicked，接受者是connect所在的类，执行内容为 on_connect_clicked
C&#43;&#43;11下的信号和槽： 此形式是C&#43;&#43;11中更新的内容：
形式如下：
connect(const QObject *sender,const char *signal, [=]() { ............. //相应的数据操作 ............ } ） 举例：
connect(ui-&gt;example,&amp;QAction::triggered, [=]() { qDebug()&lt;&lt;&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/bdd5052a0dbd37e959cb879d5eb31054/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-04-04T18:43:58+08:00" />
<meta property="article:modified_time" content="2019-04-04T18:43:58+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Qt：信号和槽总结（1，C&#43;&#43;11下的信号和槽  2，第五个参数  3，阻塞 ）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>Qt：信号和槽总结（1，C++11下的信号和槽  2，第五个参数  3，阻塞 ）</p> 
<p>信号和槽是Qt特有的一种通讯方法，具有以下特点：</p> 
<ol><li>信号与槽的连接比较灵活，可以一对一，一对多或者是多对一</li><li>信号与槽的绑定与解除也十分的灵活，使用connect以及disconnect就可以了</li><li>信号和槽可以用来实现线程之间的通信（信号和槽的第五个参数）</li></ol> 
<hr> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E5%B8%B8%E8%A7%84%E4%BF%A1%E5%8F%B7%E5%92%8C%E6%A7%BD%EF%BC%9A-toc" style="margin-left:0px;"><a href="#%E5%B8%B8%E8%A7%84%E4%BF%A1%E5%8F%B7%E5%92%8C%E6%A7%BD%EF%BC%9A" rel="nofollow">常规信号和槽：</a></p> 
<p id="C%2B%2B11%E4%B8%8B%E7%9A%84%E4%BF%A1%E5%8F%B7%E5%92%8C%E6%A7%BD%EF%BC%9A-toc" style="margin-left:0px;"><a href="#C%2B%2B11%E4%B8%8B%E7%9A%84%E4%BF%A1%E5%8F%B7%E5%92%8C%E6%A7%BD%EF%BC%9A" rel="nofollow">C++11下的信号和槽：</a></p> 
<p id="%E4%BF%A1%E5%8F%B7%E5%92%8C%E6%A7%BD%E7%9A%84%E7%AC%AC%E4%BA%94%E4%B8%AA%E5%8F%82%E6%95%B0%EF%BC%9A-toc" style="margin-left:0px;"><a href="#%E4%BF%A1%E5%8F%B7%E5%92%8C%E6%A7%BD%E7%9A%84%E7%AC%AC%E4%BA%94%E4%B8%AA%E5%8F%82%E6%95%B0%EF%BC%9A" rel="nofollow">信号和槽的第五个参数：</a></p> 
<p id="%E9%98%BB%E5%A1%9E%EF%BC%9A-toc" style="margin-left:0px;"><a href="#%E9%98%BB%E5%A1%9E%EF%BC%9A" rel="nofollow">阻塞：</a></p> 
<hr> 
<h2 id="%E5%B8%B8%E8%A7%84%E4%BF%A1%E5%8F%B7%E5%92%8C%E6%A7%BD%EF%BC%9A">常规信号和槽：</h2> 
<p>connect(const <a href="qobject.html#QObject" rel="nofollow">QObject</a> *sender, const char *signal, const <a href="qobject.html#QObject" rel="nofollow">QObject</a> *receiver, const char *method, <a href="qt.html#ConnectionType-enum" rel="nofollow">Qt::ConnectionType</a> type = Qt::AutoConnection)</p> 
<p style="margin-left:0pt;">信号和槽的标准形式如上：</p> 
<p style="margin-left:0pt;"><span style="color:#008000;">//标准信号和槽</span></p> 
<p style="margin-left:0pt;"><span style="color:#008000;">//</span>const <a href="qobject.html#QObject" rel="nofollow">QObject</a> *sender<span style="color:#008000;">：信号发出者</span></p> 
<p style="margin-left:0pt;"><span style="color:#008000;">//</span>const char *signal<span style="color:#008000;">：发出信号的名称</span></p> 
<p style="margin-left:0pt;"><span style="color:#008000;">//</span>const <a href="qobject.html#QObject" rel="nofollow">QObject</a> *receiver<span style="color:#008000;">：信号接受者</span></p> 
<p style="margin-left:0pt;"><span style="color:#008000;">//</span>const char *method<span style="color:#008000;">：信号接收函数（槽函数）的名称</span></p> 
<p style="margin-left:0pt;"><span style="color:#008000;">//</span><a href="qt.html#ConnectionType-enum" rel="nofollow">Qt::ConnectionType</a> type = Qt::AutoConnection：连接方式，一般默认为自动，不需要输入，Qt会自动判断，属于第五个参数</p> 
<p> 举例：</p> 
<pre class="has"><code class="language-cpp">connect(begin,&amp;QPushButton::clicked,this,on_connect_clicked);</code></pre> 
<p>begin为信号的发出者，信号为clicked，接受者是connect所在的类，执行内容为 on_connect_clicked</p> 
<hr> 
<h2 id="C%2B%2B11%E4%B8%8B%E7%9A%84%E4%BF%A1%E5%8F%B7%E5%92%8C%E6%A7%BD%EF%BC%9A">C++11下的信号和槽：</h2> 
<p>此形式是C++11中更新的内容：</p> 
<p>形式如下：</p> 
<pre class="has"><code class="language-cpp">connect(const QObject *sender,const char *signal,
            [=]()
{
        .............
        //相应的数据操作
        ............

}

）</code></pre> 
<p>举例：</p> 
<pre class="has"><code class="language-cpp">connect(ui-&gt;example,&amp;QAction::triggered,
            [=]()
    {
        
        qDebug()&lt;&lt;"example is triggered";
       

}
）</code></pre> 
<p>此方法省去了信号的接受者和接收后的槽函数，显然，信号的接受者为connect所在的类，执行内容为{}中的内容。</p> 
<hr> 
<h2 id="%E4%BF%A1%E5%8F%B7%E5%92%8C%E6%A7%BD%E7%9A%84%E7%AC%AC%E4%BA%94%E4%B8%AA%E5%8F%82%E6%95%B0%EF%BC%9A">信号和槽的第五个参数：</h2> 
<p>信号和槽可以进行跨线程通讯，一般不需要写第五个参数（第五个参数，connection Type）</p> 
<p>因为信号和槽默认第五个参数是Qt::AutoConnection。</p> 
<p>connect会自动判断信号<strong><span style="color:#3399ea;">发送者</span></strong>，<strong><span style="color:#86ca5e;">接受者</span></strong>，<strong><span style="color:#7c79e5;">槽函数</span></strong>的位置，根据位置来判断使用<span style="color:#86ca5e;">队列</span>还是<span style="color:#ffbb66;">直接</span>方式</p> 
<p>连接方式具体分为以下几种：</p> 
<ul><li style="margin-left:0pt;">如果是单线程通讯，使用<span style="color:#ffbb66;"><strong><strong>直接</strong></strong></span>方式</li></ul> 
<p style="margin-left:0pt;"><span style="color:#ffbb66;"><strong><strong>（</strong></strong></span>Qt::DirectConnection<span style="color:#ffbb66;"><strong><strong>）直接</strong></strong></span>：槽函数和所在线程和发送者一样。</p> 
<p style="margin-left:0pt;">   如果接收者和发送者不在一个线程，则自动使用Qt::QueuedConnection类型</p> 
<ul><li style="margin-left:0pt;">如果是多线程之间通讯，使用<strong><span style="color:#00b050;"><strong>队列</strong></span></strong>方式</li></ul> 
<p style="margin-left:0pt;"><strong><span style="color:#00b050;"><strong>（</strong></span></strong>Qt::QueuedConnection<strong><span style="color:#00b050;"><strong>）队列</strong></span></strong>：槽函数所在的线程和接受者一样</p> 
<p style="margin-left:0pt;">  一般默认是自动方式，Qt会自动进行判断，如果是多线程，会进行多线程队列的连接方式，如果是单线程，会采用直接的连接 方式</p> 
<hr> 
<h2 id="%E9%98%BB%E5%A1%9E%EF%BC%9A">阻塞：</h2> 
<p>在必要的时候，需要断开信号和槽，此时使用阻塞（ disconnect() ）即可</p> 
<p>其原型如下：</p> 
<pre class="has"><code class="language-cpp">bool QObject::disconnect(const QObject *sender, const char *signal, const QObject *receiver, const char *method)</code></pre> 
<ul><li>从原型中可以看见，返回值为bool类型</li></ul> 
<ol><li>当成功断开时，返回true</li><li>当断开失败时，返回false</li></ol> 
<p>disconnect（）有三种使用方法：<br> 1.（一刀切模式）断开所有和myObject对象的信号连接的槽函数</p> 
<pre class="has"><code class="language-cpp">disconnect(myObject, 0, 0, 0);</code></pre> 
<p>等价于</p> 
<pre class="has"><code class="language-cpp">myObject-&gt;disconnect();</code></pre> 
<p><br> 2.断开myObject对象中mySignal()信号与其他槽函数的连接</p> 
<pre class="has"><code class="language-cpp">disconnect(myObject, SIGNAL(mySignal()), 0, 0);</code></pre> 
<p>等价于</p> 
<pre class="has"><code class="language-cpp">myObject-&gt;disconnect(SIGNAL(mySignal()));</code></pre> 
<p><br> 3.断开myObject对象与myReceiver对象间的连接，两个类之间无法进行通讯工作</p> 
<pre class="has"><code class="language-cpp">disconnect(myObject, 0, myReceiver, 0);</code></pre> 
<p>等价于</p> 
<pre class="has"><code class="language-cpp">myObject-&gt;disconnect(myReceiver);</code></pre> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e9dafaf2838c122ce306a9421056f2c0/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">logstash中file输入插件配置注意事项</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/74bd7964988e919a6e917110af2d8773/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">cmd命令行启动MySQL提示服务名无效/服务无法启动</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>