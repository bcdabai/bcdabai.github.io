<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>基础算法 - 常见算法模板题（最简洁写法）【下】 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="基础算法 - 常见算法模板题（最简洁写法）【下】" />
<meta property="og:description" content="目录
双指针
最长连续不重复子序列​编辑
二进制中1的个数
区间和
区间合并
双指针 最长连续不重复子序列 思路：
设左右指针 j，i；用 i 遍历数组，对【j，i】范围路径数值出现次数记录若次数大于1，则将 j 向前走，直到范围中没有重复数字对每一步记录，即比较每个范围的长度，取最大值 #include&lt;iostream&gt; using namespace std; int a[100010],s[100010]; int main() { int n,j=0,res=0; cin&gt;&gt;n; for(int i=0;i&lt;n;i&#43;&#43;) { cin&gt;&gt;a[i]; s[a[i]]&#43;&#43;; while(s[a[i]]&gt;1) { s[a[j]]--; j&#43;&#43;; } res=max(res,i-j&#43;1); } cout&lt;&lt;res&lt;&lt;endl; return 0; } 二进制中1的个数 思路：
位运算（&amp; | ~ ^ ＞＞ ＜＜）_NO.-LL的博客-CSDN博客
利用模板
while(b) b=b&amp;(b-1); //二进制中有多少个1就循环多少次
#include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; using namespace std; const int N=1e5&#43;10; int cnt(int b) { int res=0; while(b) { b=b&amp;(b-1); res&#43;&#43;; } return res; } int main() { int n,b; cin&gt;&gt;n; for(int i=0;i&lt;n;i&#43;&#43;) { cin&gt;&gt;b; cout&lt;&lt;cnt(b)&lt;&lt;&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/3c8a24f4057d63e812d1812ae3851cbb/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-08-30T12:27:50+08:00" />
<meta property="article:modified_time" content="2022-08-30T12:27:50+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">基础算法 - 常见算法模板题（最简洁写法）【下】</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="-toc" style="margin-left:0px;"></p> 
<p id="%E5%8F%8C%E6%8C%87%E9%92%88-toc" style="margin-left:0px;"><a href="#%E5%8F%8C%E6%8C%87%E9%92%88" rel="nofollow">双指针</a></p> 
<p id="%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E4%B8%8D%E9%87%8D%E5%A4%8D%E5%AD%90%E5%BA%8F%E5%88%97%E2%80%8B%E7%BC%96%E8%BE%91-toc" style="margin-left:40px;"><a href="#%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E4%B8%8D%E9%87%8D%E5%A4%8D%E5%AD%90%E5%BA%8F%E5%88%97%E2%80%8B%E7%BC%96%E8%BE%91" rel="nofollow">最长连续不重复子序列​编辑</a></p> 
<p id="%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0" rel="nofollow">二进制中1的个数</a></p> 
<p id="%C2%A0%E5%8C%BA%E9%97%B4%E5%92%8C-toc" style="margin-left:0px;"><a href="#%C2%A0%E5%8C%BA%E9%97%B4%E5%92%8C" rel="nofollow">区间和</a></p> 
<p id="%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6-toc" style="margin-left:0px;"><a href="#%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6" rel="nofollow">区间合并</a></p> 
<hr id="hr-toc"> 
<p></p> 
<p></p> 
<h2></h2> 
<h2 id="%E5%8F%8C%E6%8C%87%E9%92%88">双指针</h2> 
<p></p> 
<h3 id="%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E4%B8%8D%E9%87%8D%E5%A4%8D%E5%AD%90%E5%BA%8F%E5%88%97%E2%80%8B%E7%BC%96%E8%BE%91">最长连续不重复子序列<img alt="" height="728" src="https://images2.imgbox.com/34/b5/GvBRETCn_o.png" width="992"></h3> 
<blockquote> 
 <p> 思路：</p> 
 <ol><li>设左右指针 j，i；用 i 遍历数组，对【j，i】范围路径数值出现次数记录</li><li>若次数大于1，则将 j 向前走，直到范围中没有重复数字</li><li>对每一步记录，即比较每个范围的长度，取最大值<img alt="" height="23" src="https://images2.imgbox.com/db/6c/2o7MvIUp_o.png" width="23"></li></ol> 
 <p></p> 
</blockquote> 
<p></p> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;
int a[100010],s[100010];
int main()
{
    int n,j=0,res=0;
    cin&gt;&gt;n;
    for(int i=0;i&lt;n;i++) 
    {
        cin&gt;&gt;a[i];
        s[a[i]]++;
        while(s[a[i]]&gt;1)
        {
            s[a[j]]--;
            j++;
        }
        res=max(res,i-j+1);
    }
    cout&lt;&lt;res&lt;&lt;endl;
    
    return 0;
}</code></pre> 
<p></p> 
<p></p> 
<p></p> 
<h2 id="%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0">二进制中1的个数</h2> 
<p><img alt="" height="754" src="https://images2.imgbox.com/2c/f7/iS4RRZon_o.png" width="1000"></p> 
<p> 思路：</p> 
<p><a href="https://blog.csdn.net/qq_61386381/article/details/123031003" title="位运算（&amp; | ~ ^ ＞＞ ＜＜）_NO.-LL的博客-CSDN博客">位运算（&amp; | ~ ^ ＞＞ ＜＜）_NO.-LL的博客-CSDN博客</a></p> 
<p>利用模板</p> 
<blockquote> 
 <p>  while(b)  b=b&amp;(b-1);  //二进制中有多少个1就循环多少次</p> 
</blockquote> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
const int N=1e5+10;

int cnt(int b)
{
    int res=0;
    while(b)
    {
        b=b&amp;(b-1);
        res++;
    }
    return res;
}

int main()
{
    int n,b;
    cin&gt;&gt;n;
    for(int i=0;i&lt;n;i++)
    {
        cin&gt;&gt;b;
        cout&lt;&lt;cnt(b)&lt;&lt;" ";
    }
    return 0;
}</code></pre> 
<p></p> 
<p></p> 
<p></p> 
<h2 id="%C2%A0%E5%8C%BA%E9%97%B4%E5%92%8C"> 区间和</h2> 
<p><img alt="" height="1115" src="https://images2.imgbox.com/8d/6c/G9yLzvij_o.png" width="1002"></p> 
<p>思路：</p> 
<blockquote> 
 <p>1、设vector&lt;pair&lt;int,int&gt; &gt;  add 用于存储下标x 与要加的值c ，query用于记录要求和的区间【l,r】</p> 
 <p>2、将下标与区间(x,l,r)都存入alls中，准备离散化</p> 
 <p>3、对alls排序并去重</p> 
 <pre><code class="language-cpp"> alls.erase(unique(alls.begin(), alls.end()), alls.end());</code></pre> 
 <p>unique作用：把alls重复元素删除，返回新数组的最后一个位置</p> 
 <p>erase作用：把后面的元素删除，只留下去重元素</p> 
 <p> 4、设计find函数查找x，并一一映射到数组a中</p> 
 <p>5、用前缀和就是区间和</p> 
 <p>6、通过遍历query，完成求区间[l,r]的和。</p> 
</blockquote> 
<p> 为什么不直接用前缀和呢？</p> 
<ul><li>因为数据为-1e9到1e9，没办法开这么大的数组，且x下标存在负值无法存储</li></ul> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

typedef pair&lt;int, int&gt; PII;

const int N = 300010;

int n, m;
int a[N], s[N];

vector&lt;int&gt; alls;
vector&lt;PII&gt; add, query;

int find(int x)     //找到大于等于x的第一个值
{
    int l = 0, r = alls.size() - 1;
    while (l &lt; r)
    {
        int mid = l + r &gt;&gt; 1;
        if (alls[mid] &gt;= x) r = mid;
        else l = mid + 1;
    }
    return r + 1;    //让下标从1开始，方便前缀和计算
}

/*int find(int x)
{
    return lower_bound(alls.begin(),alls.end(),x)-alls.begin() +1;
}*/

int main()
{
    cin &gt;&gt; n &gt;&gt; m;
    for (int i = 0; i &lt; n; i ++ )
    {
        int x, c;
        cin &gt;&gt; x &gt;&gt; c;
        add.push_back({x, c});

        alls.push_back(x);
    }

    for (int i = 0; i &lt; m; i ++ )
    {
        int l, r;
        cin &gt;&gt; l &gt;&gt; r;
        query.push_back({l, r});

        alls.push_back(l);
        alls.push_back(r);
    }

    // 去重
    sort(alls.begin(), alls.end());
    alls.erase(unique(alls.begin(), alls.end()), alls.end());

    // 处理插入
    for (auto item : add)
    {
        int x = find(item.first);
        a[x] += item.second;
    }

    // 预处理前缀和
    for (int i = 1; i &lt;= alls.size(); i ++ ) s[i] = s[i - 1] + a[i];

    // 处理询问
    for (auto item : query)
    {
        int l = find(item.first), r = find(item.second);
        cout &lt;&lt; s[r] - s[l - 1] &lt;&lt; endl;
    }

    return 0;
}
</code></pre> 
<p></p> 
<p></p> 
<p></p> 
<h2 id="%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6">区间合并</h2> 
<p><img alt="" height="984" src="https://images2.imgbox.com/a9/9e/OsGGMCAD_o.png" width="615"></p> 
<p> <img alt="" height="275" src="https://images2.imgbox.com/14/57/Osra0ZiZ_o.png" width="709"></p> 
<p></p> 
<blockquote> 
 <p>思路：</p> 
 <ol><li>记录区间左端点st与右端点ed，将区间按左端点排序</li><li>因为左端点有序，只需要判断该区间左端点与前一个区间右端位置，即可确定是否合并</li></ol> 
</blockquote> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

typedef pair&lt;int, int&gt; PII;

void merge(vector&lt;PII&gt; &amp;segs)
{
    vector&lt;PII&gt; res;

    sort(segs.begin(), segs.end()); //将左边界排序

    int st = -2e9, ed = -2e9;
    for (auto seg : segs)
        if (ed &lt; seg.first) //不重叠，取新区间
        {
            if (st != -2e9) res.push_back({st, ed});    //不是第一次，插入新区间
            st = seg.first, ed = seg.second;
        }
        else ed = max(ed, seg.second);  //有重叠，取交集

    if (st != -2e9) res.push_back({st, ed});    //循环结束，对最后一个区间插入

    segs = res;
}

int main()
{
    int n;
    scanf("%d", &amp;n);

    vector&lt;PII&gt; segs;
    for (int i = 0; i &lt; n; i ++ )
    {
        int l, r;
        scanf("%d%d", &amp;l, &amp;r);
        segs.push_back({l, r});
    }

    merge(segs);

    cout &lt;&lt; segs.size() &lt;&lt; endl;

    return 0;
}

</code></pre> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0b9c744972a209b7ce6203f7dc662e13/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">CentOS7开机时的菜单选项及时间的修改</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/67e830bcf1b04cafd7706b925da7de9d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">c语言-----整型数据类型详解</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>