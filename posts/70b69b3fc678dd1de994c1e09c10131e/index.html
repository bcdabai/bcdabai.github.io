<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>第四章 面向对象 题库 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="第四章 面向对象 题库" />
<meta property="og:description" content="1、在类的继承关系中，需要遵循以下哪个继承原则（）
A、 多重
B、 单一
C、 双重
D、 不能继承
答案： B
2、类中的一个成员方法被下面哪个修饰符修饰，该方法只能在本类被访问（） A、 public
B、 private
C、 protected
D、 default
答案： B
3、已知类的继承关系如下： A、 ass Employee;
B、 ass Manager extends Employee;
C、 ass Director extends Employee;
下语句能通过编译的是（）
A、 Employee e = new Manager();
B、 Director d = new Manager();
C、 Director d = new Employee ();
D、 Manager m = new Director();
答案： A
笔记：
1.父类 xx = new 子类（）定义的对象只能调用继承来的方法。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/70b69b3fc678dd1de994c1e09c10131e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-06-04T19:47:21+08:00" />
<meta property="article:modified_time" content="2023-06-04T19:47:21+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">第四章 面向对象 题库</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p style="margin-left:0;text-align:center;"></p> 
<p style="margin-left:0cm;"><strong>1、在类的继承关系中，需要遵循以下哪个继承原则（）</strong></p> 
<p style="margin-left:0;">A、 多重</p> 
<p style="margin-left:0;">B、 单一</p> 
<p style="margin-left:0;">C、 双重</p> 
<p style="margin-left:0;">D、 不能继承</p> 
<p style="margin-left:0;">答案： B</p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0cm;"><strong>2</strong><strong>、类中的一个成员方法被下面哪个修饰符修饰，该方法只能在本类被访问（） </strong></p> 
<p style="margin-left:0;">A、 public</p> 
<p style="margin-left:0;">B、 private</p> 
<p style="margin-left:0;">C、 protected</p> 
<p style="margin-left:0;">D、 default</p> 
<p style="margin-left:0;">答案： B</p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0cm;"><strong>3</strong><strong>、已知类的继承关系如下： </strong></p> 
<p style="margin-left:0;">A、 ass Employee;</p> 
<p style="margin-left:0;">B、 ass Manager extends Employee;</p> 
<p style="margin-left:0;">C、 ass Director extends Employee;</p> 
<p style="margin-left:0;"> 下语句能通过编译的是（）</p> 
<p style="margin-left:0;">A、 Employee e = new Manager();</p> 
<p style="margin-left:0;">B、 Director d = new Manager();</p> 
<p style="margin-left:0;">C、 Director d = new Employee ();</p> 
<p style="margin-left:0;">D、 Manager m = new Director();</p> 
<p style="margin-left:0;">答案： A</p> 
<p style="margin-left:0;"><span style="color:#494949;">笔记：</span></p> 
<p>1.父类 xx = new 子类（）定义的对象只能调用继承来的方法。</p> 
<p> 2.父类 xx = new 子类（）定义的对象调用的是子类的方法，而不是父类的。</p> 
<p>简单的说，就是自己用自己的，儿子有父亲一样的，就用儿子的。</p> 
<p></p> 
<p style="margin-left:0;"><strong>4、请阅读下面代码：</strong></p> 
<p style="margin-left:0;">class A {<!-- --></p> 
<p style="margin-left:0;">   public int i = 10;</p> 
<p style="margin-left:0;">}</p> 
<p style="margin-left:0;">class B extends A{<!-- --></p> 
<p style="margin-left:0;">   public int i = 20;</p> 
<p style="margin-left:0;">}</p> 
<p style="margin-left:0;">public class Test{<!-- --></p> 
<p style="margin-left:0;"> public static void main(String args[]){<!-- --></p> 
<p style="margin-left:0;"> B b = new B();</p> 
<p style="margin-left:0;"> A a = b;      </p> 
<p style="margin-left:0;"> System.out.println(b.i);</p> 
<p style="margin-left:0;"> System.out.println(a.i);</p> 
<p style="margin-left:0;">}</p> 
<p style="margin-left:0;">}</p> 
<p style="margin-left:0;"> 以上程序的输出结果是 ()</p> 
<p style="margin-left:0;">A、 10  10</p> 
<p style="margin-left:0;">B、 10  20</p> 
<p style="margin-left:0;">C、 20  10</p> 
<p style="margin-left:0;">D、 20  20</p> 
<p style="margin-left:0;">答案： C</p> 
<p style="margin-left:0;">笔记： 没new的对象 只能访问该类中的静态方法或静态成员变量</p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0cm;"><strong>5</strong><strong>、下列关于类的继承的描述，正确的是（）。 </strong></p> 
<p style="margin-left:0;">A、 一个类可以继承多个父类</p> 
<p style="margin-left:0;">B、 一个类可以具有多个子类</p> 
<p style="margin-left:0;">C、 子类可以使用父类的所有方法</p> 
<p style="margin-left:0;">D、 子类一定比父类有更多的成员方法</p> 
<p style="margin-left:0;">答案： B<br> 解析：A、一个类只能继承一个父类｜C、子类可以使用父类的非私有方法｜D、子类不一定比父类有更多的成员方法</p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0cm;"><strong>6</strong><strong>、Java中，如果类C是类B的子类，类B是类A的子类，那么下面描述正确的是（）。 </strong></p> 
<p style="margin-left:0;">A、 C可以继承B中的公有成员，同样也可以继承A中的公有成员</p> 
<p style="margin-left:0;">B、 C只继承了B中的成员</p> 
<p style="margin-left:0;">C、 C只继承了A中的成员</p> 
<p style="margin-left:0;">D、 C不能继承A或B中的成员</p> 
<p style="margin-left:0;">答案： A</p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;"><strong>7、<span style="color:#303133;">阅读下面代码：</span></strong></p> 
<p style="margin-left:0;"><span style="color:#303133;">class Parent{<!-- --></span></p> 
<p style="margin-left:0;"><span style="color:#303133;">  public String name;</span></p> 
<p style="margin-left:0;"><span style="color:#303133;"> public Parent(String pName){<!-- --></span></p> 
<p style="margin-left:0;"><span style="color:#303133;">   this.name = pName;</span></p> 
<p style="margin-left:0;"><span style="color:#303133;">  }</span></p> 
<p style="margin-left:0;"><span style="color:#303133;"> }</span></p> 
<p style="margin-left:0;"><span style="color:#303133;"> public class Test  extends Parent {  //第1行</span></p> 
<p style="margin-left:0;"><span style="color:#303133;">  public Test(String Name){              //第2行</span></p> 
<p style="margin-left:0;"><span style="color:#303133;">   name="hello";          //第3行</span></p> 
<p style="margin-left:0;"><span style="color:#303133;">   super("kitty");          //第4行</span></p> 
<p style="margin-left:0;"><span style="color:#303133;">  }   </span></p> 
<p style="margin-left:0;"><span style="color:#303133;"> }</span></p> 
<p style="margin-left:0;"><span style="color:#303133;">下列选项说法正确的是（</span> <span style="color:#303133;">）。</span></p> 
<p style="margin-left:0;">A、第2行错误，Test类的构造函数中参数名称应与其父类构造函数中的参数名相同</p> 
<p style="margin-left:0;">B、第3行错误，应使用super关键字调用父类的name属性，改为super.name="hello";</p> 
<p style="margin-left:0;">C、第4行错误，调用父类构造方法的语句必须放在子类构造方法中的第一行</p> 
<p style="margin-left:0;">D、程序编译通过，无错误</p> 
<p style="margin-left:0;">答案： C</p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;"><strong>8、<span style="color:#303133;">阅读下面代码：</span></strong></p> 
<p style="margin-left:0;"><span style="color:#303133;">public static void main (String [] args){<!-- --></span></p> 
<p style="margin-left:0;"><span style="color:#303133;">  String s;</span></p> 
<p style="margin-left:0;"><span style="color:#303133;"> System.out.println(“s=”+s);      </span></p> 
<p style="margin-left:0;"><span style="color:#303133;"> }</span></p> 
<p style="margin-left:0;"><span style="color:#303133;">编译运行以上程序，结果是（）</span></p> 
<p style="margin-left:0;">A、 编译错误</p> 
<p style="margin-left:0;">B、 编译通过，但出现运行时错误</p> 
<p style="margin-left:0;">C、正常运行，输出s=null</p> 
<p style="margin-left:0;">D、 正常运行，输出s=</p> 
<p style="margin-left:0;">答案： A</p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;"><strong>9、<span style="color:#303133;">阅读下面代码：</span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;"> </span></strong><span style="color:#303133;">class Parent {<!-- --></span></p> 
<p style="margin-left:0;"><span style="color:#303133;">  public int count() {                 // 第1行</span></p> 
<p style="margin-left:0;"><span style="color:#303133;">   return 0;</span></p> 
<p style="margin-left:0;"><span style="color:#303133;">  }</span></p> 
<p style="margin-left:0;"><span style="color:#303133;"> }</span></p> 
<p style="margin-left:0;"><span style="color:#303133;"> public  class Test  extends Parent {<!-- --></span></p> 
<p style="margin-left:0;"><span style="color:#303133;">  public float count() {              // 第2行</span></p> 
<p style="margin-left:0;"><span style="color:#303133;">   return 9;                    // 第3行</span></p> 
<p style="margin-left:0;"><span style="color:#303133;">  }</span></p> 
<p style="margin-left:0;"><span style="color:#303133;"> }</span></p> 
<p style="margin-left:0;"><span style="color:#303133;">编译时，会出现以下（</span> <span style="color:#303133;">）情况。</span></p> 
<p style="margin-left:0;">A、 编译通过</p> 
<p style="margin-left:0;">B、 在第1行引发编译错误</p> 
<p style="margin-left:0;">C、在第2行引发编译错误</p> 
<p style="margin-left:0;">D、在第3行引发编译错误</p> 
<p style="margin-left:0;">答案： C</p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;"><strong>10、<span style="color:#303133;">阅读下面代码：</span></strong></p> 
<p style="margin-left:0;"><span style="color:#303133;"> class Parent1 {<!-- --></span></p> 
<p style="margin-left:0;"><span style="color:#303133;">  Parent1(String s){<!-- --></span></p> 
<p style="margin-left:0;"><span style="color:#303133;">   System.out.println(s);</span></p> 
<p style="margin-left:0;"><span style="color:#303133;">  }</span></p> 
<p style="margin-left:0;"><span style="color:#303133;"> }</span></p> 
<p style="margin-left:0;"><span style="color:#303133;"> class Parent2  extends Parent1{<!-- --></span></p> 
<p style="margin-left:0;"><span style="color:#303133;">  Parent2(){<!-- --></span></p> 
<p style="margin-left:0;"><span style="color:#303133;">   System.out.println("parent2");</span></p> 
<p style="margin-left:0;"><span style="color:#303133;">  }</span></p> 
<p style="margin-left:0;"><span style="color:#303133;"> }</span></p> 
<p style="margin-left:0;"><span style="color:#303133;"> public class Child extends Parent2 {<!-- --></span></p> 
<p style="margin-left:0;"><span style="color:#303133;"> public static void main(String[] args) {<!-- --></span></p> 
<p style="margin-left:0;"><span style="color:#303133;">   Child child = new Child();</span></p> 
<p style="margin-left:0;"><span style="color:#303133;">  }</span></p> 
<p style="margin-left:0;"><span style="color:#303133;"> }</span></p> 
<p style="margin-left:0;"><span style="color:#303133;">编译并运行Child.java，以上代码运行结果为（</span> <span style="color:#303133;">）。</span></p> 
<p style="margin-left:0;">A、 编译错误：没有找到构造器Child()</p> 
<p style="margin-left:0;">B、编译错误：没有找到构造器Parent1()</p> 
<p style="margin-left:0;">C、正确运行，没有输出值</p> 
<p style="margin-left:0;">D、正确运行，输出结果为：parent2</p> 
<p style="margin-left:0;">答案： B<br> 解析：<span style="color:#606266;">C</span><span style="color:#606266;">选项是因为当我们给出了构造方法，系统将不再提供默认的无参构造函数</span></p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;"><strong>11、<span style="color:#303133;">阅读下面代码：</span></strong></p> 
<p style="margin-left:0;"><span style="color:#303133;"> class Parent {<!-- --></span></p> 
<p style="margin-left:0;"><span style="color:#303133;"> Parent() {<!-- --></span></p> 
<p style="margin-left:0;"><span style="color:#303133;"> System.out.println("parent");</span></p> 
<p style="margin-left:0;"><span style="color:#303133;"> }</span></p> 
<p style="margin-left:0;"><span style="color:#303133;"> }</span></p> 
<p style="margin-left:0;"><span style="color:#303133;"> public class Child extends Parent {<!-- --></span></p> 
<p style="margin-left:0;"><span style="color:#303133;"> Child(String s) {<!-- --></span></p> 
<p style="margin-left:0;"><span style="color:#303133;"> System.out.println(s);</span></p> 
<p style="margin-left:0;"><span style="color:#303133;"> }</span></p> 
<p style="margin-left:0;"><span style="color:#303133;">public static void main(String[] args) {<!-- --></span></p> 
<p style="margin-left:0;"><span style="color:#303133;"> Child child = new Child("child");</span></p> 
<p style="margin-left:0;"><span style="color:#303133;"> }</span></p> 
<p style="margin-left:0;"><span style="color:#303133;">}</span></p> 
<p style="margin-left:0;"><span style="color:#303133;">上述代码的运行结果为（）</span></p> 
<p style="margin-left:0;">A、 child</p> 
<p style="margin-left:0;">B、 child parent</p> 
<p style="margin-left:0;">C、parent child</p> 
<p style="margin-left:0;">D、编译错误</p> 
<p style="margin-left:0;">答案： C</p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;"><strong>12、<span style="color:#303133;">阅读下面代码：</span></strong></p> 
<p style="margin-left:0;"><span style="color:#303133;">class Parent {<!-- --></span></p> 
<p style="margin-left:0;"><span style="color:#303133;">  public void count() {<!-- --></span></p> 
<p style="margin-left:0;"><span style="color:#303133;">   System.out.println(10%3);</span></p> 
<p style="margin-left:0;"><span style="color:#303133;">  }</span></p> 
<p style="margin-left:0;"><span style="color:#303133;"> }</span></p> 
<p style="margin-left:0;"><span style="color:#303133;"> public class Child  extends Parent{<!-- --></span></p> 
<p style="margin-left:0;"><span style="color:#303133;">  public void count() {<!-- --></span></p> 
<p style="margin-left:0;"><span style="color:#303133;">   System.out.println(10/3);</span></p> 
<p style="margin-left:0;"><span style="color:#303133;"> }</span></p> 
<p style="margin-left:0;"><span style="color:#303133;">  public static void main(String args[]) {<!-- --></span></p> 
<p style="margin-left:0;"><span style="color:#303133;">   Parent p = new Child();</span></p> 
<p style="margin-left:0;"><span style="color:#303133;">   p.count();</span></p> 
<p style="margin-left:0;"><span style="color:#303133;">  }</span></p> 
<p style="margin-left:0;"><span style="color:#303133;"> }</span></p> 
<p style="margin-left:0;"><span style="color:#303133;">下列选项中的输出结果正确的是（</span> <span style="color:#303133;">）。</span></p> 
<p style="margin-left:0;">A、 1</p> 
<p style="margin-left:0;">B、 1.0</p> 
<p style="margin-left:0;">C、 3</p> 
<p style="margin-left:0;">D、 3.3333333333333335</p> 
<p style="margin-left:0;">答案： C</p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;"><strong>13、<span style="color:#303133;">阅读下面代码：</span></strong></p> 
<p style="margin-left:0;"><span style="color:#303133;">class Base {<!-- --></span></p> 
<p style="margin-left:0;"><span style="color:#303133;">  public void method(){<!-- --></span></p> 
<p style="margin-left:0;"><span style="color:#303133;">   System.out.print ("Base method");</span></p> 
<p style="margin-left:0;"><span style="color:#303133;">  }</span></p> 
<p style="margin-left:0;"><span style="color:#303133;"> }</span></p> 
<p style="margin-left:0;"><span style="color:#303133;"> class Child extends Base{   </span></p> 
<p style="margin-left:0;"><span style="color:#303133;">  public void methodB(){<!-- --></span></p> 
<p style="margin-left:0;"><span style="color:#303133;">   System.out.print ("Child methodB");</span></p> 
<p style="margin-left:0;"><span style="color:#303133;">  }</span></p> 
<p style="margin-left:0;"><span style="color:#303133;"> }</span></p> 
<p style="margin-left:0;"><span style="color:#303133;"> class Sample {<!-- --></span></p> 
<p style="margin-left:0;"><span style="color:#303133;">  public static void main(String[] args) {<!-- --></span></p> 
<p style="margin-left:0;"><span style="color:#303133;">   Base base= new Child();</span></p> 
<p style="margin-left:0;"><span style="color:#303133;">  base.methodB();</span></p> 
<p style="margin-left:0;"><span style="color:#303133;">  }</span></p> 
<p style="margin-left:0;"><span style="color:#303133;"> }</span></p> 
<p style="margin-left:0;"><span style="color:#303133;">下列选项中的输出结果正确的是（）</span></p> 
<p style="margin-left:0;">A、 Base method</p> 
<p style="margin-left:0;">B、 Child methodB</p> 
<p style="margin-left:0;">C、 Base method Child MethodB</p> 
<p style="margin-left:0;">D、 编译错误</p> 
<p style="margin-left:0;">答案： D</p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;"><strong>14、<span style="color:#303133;">阅读下面代码：</span></strong></p> 
<p style="margin-left:0;"><span style="color:#303133;">interface Parent{<!-- --></span></p> 
<p style="margin-left:0;"><span style="color:#303133;">  public int count(int i);</span></p> 
<p style="margin-left:0;"><span style="color:#303133;"> }</span></p> 
<p style="margin-left:0;"><span style="color:#303133;"> public class Test implements Parent {<!-- --></span></p> 
<p style="margin-left:0;"><span style="color:#303133;">  public int count(int i){<!-- --></span></p> 
<p style="margin-left:0;"><span style="color:#303133;">   return i % 9;</span></p> 
<p style="margin-left:0;"><span style="color:#303133;">  }</span></p> 
<p style="margin-left:0;"><span style="color:#303133;">  public static void main(String[] args){<!-- --></span></p> 
<p style="margin-left:0;"><span style="color:#303133;">  ________________</span></p> 
<p style="margin-left:0;"><span style="color:#303133;">   int i = p.count(20);</span></p> 
<p style="margin-left:0;"><span style="color:#303133;">  }</span></p> 
<p style="margin-left:0;"><span style="color:#303133;"> }</span></p> 
<p style="margin-left:0;"><span style="color:#303133;">在_____横线处加入（</span> <span style="color:#303133;">）语句，可以使这段代码编译通过。</span></p> 
<p style="margin-left:0;">A、 Test p = new Test();</p> 
<p style="margin-left:0;">B、 Parent p;</p> 
<p style="margin-left:0;">C、 Parent p = new Parent();</p> 
<p style="margin-left:0;">D、 Test p = new Parent();</p> 
<p style="margin-left:0;">答案： A</p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0cm;"><strong>15</strong><strong>、下列选项中关于Java中super关键字的说法，错误的是（ ）。 </strong></p> 
<p style="margin-left:0;">A、 当子类和父类中成员变量重名的时候,在子类方法中想输出父类成员变量的值,可以用super区分子父类成员变量</p> 
<p style="margin-left:0;">B、 super语句可以放在构造函数的任意一行</p> 
<p style="margin-left:0;">C、 子类可以通过super关键字调用父类的方法</p> 
<p style="margin-left:0;">D、 子类可以通过super关键字调用父类的属性</p> 
<p style="margin-left:0;">答案： B</p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0cm;"><strong>16</strong><strong>、下面关于匿名内部类、接口、抽象类和局部内部类的说法，正确的是( ) </strong></p> 
<p style="margin-left:0;">A、 匿名内部类编译后不会生成.class文件</p> 
<p style="margin-left:0;">B、 接口编译后不会生成.class文件</p> 
<p style="margin-left:0;">C、 抽象类中没有构造方法</p> 
<p style="margin-left:0;">D、 局部内部类只能访问被final修饰的局部变量</p> 
<p style="margin-left:0;">答案： D</p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;"><strong>17、<span style="color:#303133;">阅读下面代码：</span></strong></p> 
<p style="margin-left:0;"><span style="color:#303133;"> public class Test{<!-- --></span></p> 
<p style="margin-left:0;"><span style="color:#303133;">  private static final int counter=10;       </span></p> 
<p style="margin-left:0;"><span style="color:#303133;">  public static void main(String [] args){          </span></p> 
<p style="margin-left:0;"><span style="color:#303133;">   System.out.println(++counter);        </span></p> 
<p style="margin-left:0;"><span style="color:#303133;">  }    </span></p> 
<p style="margin-left:0;"><span style="color:#303133;"> }</span></p> 
<p style="margin-left:0;"> <span style="color:#303133;">编译运行Test.java，结果是</span> <span style="color:#303133;">（）</span></p> 
<p style="margin-left:0;">A、 10</p> 
<p style="margin-left:0;">B、 11</p> 
<p style="margin-left:0;">C、 编译错误</p> 
<p style="margin-left:0;">D、 运行时出现异常</p> 
<p style="margin-left:0;">答案： C<br> 解析：</p> 
<p style="margin-left:0;">final修饰的变量不可以被改变。</p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0cm;"><strong>18</strong><strong>、在Java中，如果父类中的某些方法不包含任何逻辑，并且需要有子类重写，应该使用（）关键字来声明父类的这些方法 </strong></p> 
<p style="margin-left:0;">A、 final</p> 
<p style="margin-left:0;">B、 static</p> 
<p style="margin-left:0;">C、 abstract</p> 
<p style="margin-left:0;">D、 void</p> 
<p style="margin-left:0;">答案： C</p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;"><strong>19、<span style="color:#303133;">阅读下面代码：</span></strong></p> 
<p style="margin-left:0;"><span style="color:#303133;"> public interface Face{<!-- --></span></p> 
<p style="margin-left:0;"><span style="color:#303133;">  int counter = 40;   </span></p> 
<p style="margin-left:0;"><span style="color:#303133;"> }     </span></p> 
<p style="margin-left:0;"><span style="color:#303133;"> public class Test implements Face{<!-- --></span></p> 
<p style="margin-left:0;"><span style="color:#303133;">  private static int counter;   </span></p> 
<p style="margin-left:0;"><span style="color:#303133;">  public static void main(String[]args){<!-- --></span></p> 
<p style="margin-left:0;"><span style="color:#303133;">   System.out.println(++counter);       </span></p> 
<p style="margin-left:0;"><span style="color:#303133;">  }   </span></p> 
<p style="margin-left:0;"><span style="color:#303133;"> }  </span></p> 
<p style="margin-left:0;"><span style="color:#303133;">Test.java 的编译运行结果是（）。</span></p> 
<p style="margin-left:0;">A、 40</p> 
<p style="margin-left:0;">B、 41</p> 
<p style="margin-left:0;">C、 0</p> 
<p style="margin-left:0;">D、 1</p> 
<p style="margin-left:0;">答案： D</p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0cm;"><strong>20</strong><strong>、在Java中，多态的实现不仅能减少编码的工作量，还能大大提高程序的可维护性及可扩展性，下面哪一个选项不属于多态的条件（）。 </strong></p> 
<p style="margin-left:0;">A、 子类重写父类的方法</p> 
<p style="margin-left:0;">B、 子类重载同一个方法</p> 
<p style="margin-left:0;">C、 要有继承或实现</p> 
<p style="margin-left:0;">D、 父类引用指向子类对象</p> 
<p style="margin-left:0;">答案： B</p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0cm;"><strong>21</strong><strong>、在Java中，要想让一个类继承另一个类，可以使用以下哪个关键字（） </strong></p> 
<p style="margin-left:0;">A、 inherits</p> 
<p style="margin-left:0;">B、 extends</p> 
<p style="margin-left:0;">C、 implements</p> 
<p style="margin-left:0;">D、 modifies</p> 
<p style="margin-left:0;">答案： B</p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0cm;"><strong>22</strong><strong>、下面说法中错误的是（） </strong></p> 
<p style="margin-left:0;">A、 静态代码块只在类加载后执行一次,以后再创建对象的时候不执行</p> 
<p style="margin-left:0;">B、 局部代码块的作用是为了限制变量的生命周期</p> 
<p style="margin-left:0;">C、 构造代码块在每创建一次对象就执行一次</p> 
<p style="margin-left:0;">D、 以上都不对</p> 
<p style="margin-left:0;">答案： D</p> 
<p style="margin-left:0;">笔记：</p> 
<p style="margin-left:0;">1.随着类的加载而执行，只执行一次，并优先于主函数。</p> 
<p style="margin-left:0;">2.普通代码块（局部代码快）是在方法名后面用 {} 括起来的代码段，不能够单独存在，必须要紧跟在方法名后面且必须使用方法名调用它，作用是限定变量的<a href="https://so.csdn.net/so/search?q=%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F&amp;spm=1001.2101.3001.7020" title="生命周期">生命周期</a>和提高效率。</p> 
<p style="margin-left:0;"><span style="color:#494949;">3.每当实例化一个XX类对象，都会在执行构造方法之前执行构造代码块。</span></p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;"><strong>23、<span style="color:#303133;">分析如下</span></strong><strong><span style="color:#303133;">Java</span><span style="color:#303133;">代码，如果想在控制台上输出</span></strong><strong><span style="color:#303133;">“B</span><span style="color:#303133;">类的</span></strong><strong><span style="color:#303133;">test()</span><span style="color:#303133;">方法</span></strong><strong><span style="color:#303133;">”</span><span style="color:#303133;">，则在主函数应填入（）。</span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;"> </span></strong><span style="color:#303133;">class A {<!-- --></span></p> 
<p style="margin-left:0;"><span style="color:#303133;"> public void test() {<!-- --></span></p> 
<p style="margin-left:0;"><span style="color:#303133;"> System.out.println("A类的test()方法");</span></p> 
<p style="margin-left:0;"><span style="color:#303133;"> }</span></p> 
<p style="margin-left:0;"><span style="color:#303133;"> }</span></p> 
<p style="margin-left:0;"><span style="color:#303133;"> class B extends A {<!-- --></span></p> 
<p style="margin-left:0;"><span style="color:#303133;"> public void test() {<!-- --></span></p> 
<p style="margin-left:0;"><span style="color:#303133;"> System.out.println("B类的test()方法");</span></p> 
<p style="margin-left:0;"><span style="color:#303133;"> }</span></p> 
<p style="margin-left:0;"><span style="color:#303133;"> public static void main(String args[]) {<!-- --></span></p> 
<p style="margin-left:0;"><span style="color:#303133;"> }</span></p> 
<p style="margin-left:0;"><span style="color:#303133;"> }</span></p> 
<p style="margin-left:0;">A、A a = new B(); a.test();</p> 
<p style="margin-left:0;">B、 A a = new A(); a.test();</p> 
<p style="margin-left:0;">C、 B b = new A(); b.test();</p> 
<p style="margin-left:0;">D、 new B().test();</p> 
<p style="margin-left:0;">答案： AD</p> 
<p style="margin-left:0;">笔记：<u>多态成员方法：编译看左边，运行看右边</u></p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0cm;"><strong>24</strong><strong>、关于super关键字以下说法哪些是正确的（） </strong></p> 
<p style="margin-left:0;">A、 super关键字可以调用父类的构造方法</p> 
<p style="margin-left:0;">B、 super关键字可以调用父类的普通方法</p> 
<p style="margin-left:0;">C、 super与this不能同时存在于同一个构造方法中</p> 
<p style="margin-left:0;">D、 super与this可以同时存在于同一个构造方法中</p> 
<p style="margin-left:0;">答案： ABC</p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;"><strong>25、<span style="color:#303133;">阅读下面代码：</span></strong></p> 
<p style="margin-left:0;"><span style="color:#303133;">public class Parent{<!-- --></span></p> 
<p style="margin-left:0;"><span style="color:#303133;">  int change(){<!-- --></span></p> 
<p style="margin-left:0;"><span style="color:#303133;">    …</span></p> 
<p style="margin-left:0;"><span style="color:#303133;">  }</span></p> 
<p style="margin-left:0;"><span style="color:#303133;"> }</span></p> 
<p style="margin-left:0;"><span style="color:#303133;"> Class Child extends Parent{<!-- --></span></p> 
<p style="margin-left:0;"><span style="color:#303133;"> _______ (此处可以放入下面哪个选项)</span></p> 
<p style="margin-left:0;"><span style="color:#303133;"> }</span></p> 
<p style="margin-left:0;"><span style="color:#303133;">下面选项中可以加入Child类中的方法是（）</span></p> 
<p style="margin-left:0;">A、 public int change(){}</p> 
<p style="margin-left:0;">B、int show(int i){}</p> 
<p style="margin-left:0;">C、private int change(){}</p> 
<p style="margin-left:0;">D、 abstract int change(){}</p> 
<p style="margin-left:0;">答案： AB<br> 解析：<span style="color:#606266;">C</span><span style="color:#606266;">选项</span><span style="color:#606266;">private</span><span style="color:#606266;">的权限低于默认修饰符</span></p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;"><strong>26、<span style="color:#303133;">阅读下面代码：</span></strong></p> 
<p style="margin-left:0;"><span style="color:#303133;">abstract class Shape     {<!-- --></span></p> 
<p style="margin-left:0;"><span style="color:#303133;">  abstract void draw( );     </span></p> 
<p style="margin-left:0;"><span style="color:#303133;"> }</span></p> 
<p style="margin-left:0;"> <span style="color:#303133;">要创建Shape类的子类Circle，以下代码正确的是（）。</span></p> 
<p style="margin-left:0;">A、class Circle extends Shape{ int draw( ){} }</p> 
<p style="margin-left:0;">B、abstract class Circle extends Shape{ }</p> 
<p style="margin-left:0;">C、class Circle extends Shape{ void draw( ); }</p> 
<p style="margin-left:0;">D、class Circle extends Shape{ void draw( ){} }</p> 
<p style="margin-left:0;">答案： BD</p> 
<p style="margin-left:0;">笔记：</p> 
<p style="margin-left:0in;text-align:left;"><span style="color:#494949;">1.</span><span style="color:#333333;">抽象方法的定义格式如下：abstract void 方法名称(参数); </span></p> 
<p style="margin-left:0in;text-align:left;"><span style="color:#333333;">2.抽象类和抽象方法都要使用abstract关键字声明。</span></p> 
<p style="margin-left:0in;text-align:left;"><span style="color:#333333;">3.</span>抽象类必须有子类，使用extends继承，一个子类只能继承一个抽象类；</p> 
<p style="margin-left:0in;text-align:left;"><span style="color:#333333;">4.子类（如果不是抽象类）则必须覆写抽象类之中的全部抽象方法（如果子类没有实现父类的抽象方法，则必须将子类也定义为为abstract类。</span></p> 
<p style="margin-left:0in;text-align:left;"></p> 
<p style="margin-left:0cm;"><strong>27</strong><strong>、在Java中，下面关于抽象类的描述正确的是（）。 </strong></p> 
<p style="margin-left:0;">A、 抽象类可以被实例化</p> 
<p style="margin-left:0;">B、 如果一个类中有一个方法被声明为抽象的，那么这个类必须是抽象类</p> 
<p style="margin-left:0;">C、 抽象类中的方法必须都是抽象的</p> 
<p style="margin-left:0;">D、 声明抽象类必须带有关键字abstract</p> 
<p style="margin-left:0;">答案： BD</p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0cm;"><strong>28</strong><strong>、下面选项中不能和abstract关键字共用的是() </strong></p> 
<p style="margin-left:0;">A、 abstract不可以和private共用</p> 
<p style="margin-left:0;">B、 abstract不可以和static共用</p> 
<p style="margin-left:0;">C、 abstract不可以和final共用</p> 
<p style="margin-left:0;">D、 abstract不可以和public共用</p> 
<p style="margin-left:0;">答案： ABC</p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0cm;"><strong>29</strong><strong>、在java中，已定义了两个接口B和C，下面继承语句正确的是（） </strong></p> 
<p style="margin-left:0;">A、 interface A extends B,C</p> 
<p style="margin-left:0;">B、 interface A implements B,C</p> 
<p style="margin-left:0;">C、 class A implements B,C</p> 
<p style="margin-left:0;">D、 class A implements B,implements C</p> 
<p style="margin-left:0;">答案： AC</p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0cm;"><strong>30</strong><strong>、下面关于Java接口的说法正确的是（） </strong></p> 
<p style="margin-left:0;">A、 Java接口中定义的是扩展功能</p> 
<p style="margin-left:0;">B、 Java接口中可以被多个子类实现,一个类也可以同时实现多个接口</p> 
<p style="margin-left:0;">C、 Java接口中可以声明私有成员</p> 
<p style="margin-left:0;">D、 Java接口不能被实例化</p> 
<p style="margin-left:0;">答案： ABD</p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0cm;"><strong>31</strong><strong>、在Java接口中定义常量，下面语法正确的是（）。 </strong></p> 
<p style="margin-left:0;">A、 static int MALE = 1;</p> 
<p style="margin-left:0;">B、 final int MALE = 1;</p> 
<p style="margin-left:0;">C、 int MALE = 1;</p> 
<p style="margin-left:0;">D、 private int MALE = 1;</p> 
<p style="margin-left:0;">答案： ABC</p> 
<p style="margin-left:0;">笔记：</p> 
<p style="margin-left:0;">1.接口当中也可以定义“成员变量”，但是必须使用public static final三个关键字进行修饰。</p> 
<p style="margin-left:0;">2.接口当中的常量，可以省略public static final，注意：不写也照样是这样。</p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0cm;"><strong>32</strong><strong>、不存在继承关系的情况下，也可以实现重写。 </strong></p> 
<p style="margin-left:0;">答案： 错误<br> 解析：不存在继承关系的情况下，不可以实现重写。</p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0cm;"><strong>33</strong><strong>、Java中，子类可以覆盖父类中的任意方法。 </strong></p> 
<p style="margin-left:0;">答案： 错误</p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0cm;"><strong>34</strong><strong>、Java中被final关键字修饰的变量，不能被重新赋值。 </strong></p> 
<p style="margin-left:0;">答案： 正确<br> 解析：Java中被final关键字修饰的变量，称为常量，他只能被赋值一次。</p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0cm;"><strong>35</strong><strong>、super调用父类构造方法的代码必须位于子类构造方法的第一行。 </strong></p> 
<p style="margin-left:0;">答案： 正确<br> 解析：super调用父类构造方法的代码必须位于子类构造方法的第一行。</p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0cm;"><strong>36</strong><strong>、抽象方法必须定义在抽象类中，所以抽象类中的方法都是抽象方法。 </strong></p> 
<p style="margin-left:0;">答案： 错误<br> 解析：抽象类可以不包含任何抽象方法</p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0cm;"><strong>37</strong><strong>、如果一个类继承了一个抽象类，但是没有完全复写父类的所有的抽象方法那么这个类也是抽象类。 </strong></p> 
<p style="margin-left:0;">答案： 正确</p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0cm;"><strong>38</strong><strong>、Throwable有两个直接子类Error和Exception，其中Error代表程序中产生的异常，Exception代表程序中产生的错误。 </strong></p> 
<p style="margin-left:0;">答案： 错误</p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0cm;"><strong>39</strong><strong>、使用【】关键字修饰的类不可以被继承。 </strong></p> 
<p style="margin-left:0;">答案： final；</p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0cm;"><strong>40</strong><strong>、一个类如果实现一个接口，那么他就需要实现接口定义的全部【】，否则该类就必须定义成【】。 </strong></p> 
<p style="margin-left:0;">答案： 抽象方法；抽象类；<br> 解析：当一个类实现接口时，如果这个类是抽象类，只需要实现接口中的部分抽象方法即可，否则需要实现接口中的所有抽象方法。</p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0cm;"><strong>41</strong><strong>、一个类可以从其他的类中派生出来，派生出来的类称为【】，用于派生的类称为【】或者【】。 </strong></p> 
<p style="margin-left:0;">答案： 子类；基类；父类；</p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0cm;"><strong>42</strong><strong>、在继承关系中，子类会自动继承父类中的方法，但有时在子类中需要对继承的方法进行一些修改，即对父类的方法进行【】。 </strong></p> 
<p style="margin-left:0;">答案： 重写；</p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0cm;"><strong>43</strong><strong>、在定义方法时不写方法体，这种不包含方法体的方法为【】方法。 </strong></p> 
<p style="margin-left:0;">答案： 抽象；</p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0cm;"><strong>44</strong><strong>、在Java语言中，所有的类都直接或间接继承自【】类。 </strong></p> 
<p style="margin-left:0;">答案： Object；</p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0cm;"><strong>45</strong><strong>、Object类中的equals方法的参数是【】类型的参数。 </strong></p> 
<p style="margin-left:0;">答案： Object；</p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0cm;"><strong>46</strong><strong>、RuntimeException类及其子类都是【】异常。 </strong></p> 
<p style="margin-left:0;">答案： 运行时；</p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0cm;"><strong>47</strong><strong>、Java中提供了大量的异常类，这些类都继承自【】类。 </strong></p> 
<p style="margin-left:0;">答案： java.lang.Throwable；</p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0cm;"><strong>48</strong><strong>、【】关键字用于在方法中声明抛出异常的实例对象。 </strong></p> 
<p style="margin-left:0;">答案： throws；</p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;"><strong>49、请阅读下面代码：</strong></p> 
<p style="margin-left:0;">class A {<!-- --></p> 
<p style="margin-left:0;">   public int i = 10;</p> 
<p style="margin-left:0;">}</p> 
<p style="margin-left:0;">class B extends A{<!-- --></p> 
<p style="margin-left:0;">   public int i = 20;</p> 
<p style="margin-left:0;">}</p> 
<p style="margin-left:0;">public class Test{<!-- --></p> 
<p style="margin-left:0;"> public static void main(String args[]){<!-- --></p> 
<p style="margin-left:0;"> B b = new B();</p> 
<p style="margin-left:0;"> A a = b;      </p> 
<p style="margin-left:0;"> System.out.println(b.i);</p> 
<p style="margin-left:0;"> System.out.println(a.i);</p> 
<p style="margin-left:0;">}</p> 
<p style="margin-left:0;">}</p> 
<p style="margin-left:0;"> 以上程序的输出结果是 ()</p> 
<p style="margin-left:0;">A、 10  10</p> 
<p style="margin-left:0;">B、 10  20</p> 
<p style="margin-left:0;">C、 20  10</p> 
<p style="margin-left:0;">D、 20  20</p> 
<p style="margin-left:0;">答案： C</p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;"><strong>50、<span style="color:#303133;">阅读下面代码：</span></strong></p> 
<p style="margin-left:0;"><span style="color:#303133;">class Parent{<!-- --></span></p> 
<p style="margin-left:0;"><span style="color:#303133;">  public String name;</span></p> 
<p style="margin-left:0;"><span style="color:#303133;"> public Parent(String pName){<!-- --></span></p> 
<p style="margin-left:0;"><span style="color:#303133;">   this.name = pName;</span></p> 
<p style="margin-left:0;"><span style="color:#303133;">  }</span></p> 
<p style="margin-left:0;"><span style="color:#303133;"> }</span></p> 
<p style="margin-left:0;"><span style="color:#303133;"> public class Test  extends Parent {  //第1行</span></p> 
<p style="margin-left:0;"><span style="color:#303133;">  public Test(String Name){              //第2行</span></p> 
<p style="margin-left:0;"><span style="color:#303133;">   name="hello";          //第3行</span></p> 
<p style="margin-left:0;"><span style="color:#303133;">   super("kitty");          //第4行</span></p> 
<p style="margin-left:0;"><span style="color:#303133;">  }   </span></p> 
<p style="margin-left:0;"><span style="color:#303133;"> }</span></p> 
<p style="margin-left:0;"><span style="color:#303133;">下列选项说法正确的是（</span> <span style="color:#303133;">）。</span></p> 
<p style="margin-left:0;">A、第2行错误，Test类的构造函数中参数名称应与其父类构造函数中的参数名相同</p> 
<p style="margin-left:0;">B、第3行错误，应使用super关键字调用父类的name属性，改为super.name="hello";</p> 
<p style="margin-left:0;">C、第4行错误，调用父类构造方法的语句必须放在子类构造方法中的第一行</p> 
<p style="margin-left:0;">D、程序编译通过，无错误</p> 
<p style="margin-left:0;">答案： C</p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;"><strong>51、<span style="color:#303133;">阅读下面代码：</span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;">public static void main (String [] args){<!-- --></span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;">  String s;</span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;"> System.out.println(“s=”+s);      </span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;"> }</span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;">编译运行以上程序，结果是（）</span></strong></p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;">A、 编译错误</p> 
<p style="margin-left:0;">B、 编译通过，但出现运行时错误</p> 
<p style="margin-left:0;">C、</p> 
<p style="margin-left:0;">正常运行，输出s=null</p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;">D、 正常运行，输出s=</p> 
<p style="margin-left:0;">答案： A</p> 
<p style="margin-left:0;"><strong>52、<span style="color:#303133;">阅读下面代码：</span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;"> class Parent {<!-- --></span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;">  public int count() {                 // </span><span style="color:#303133;">第</span></strong><strong><span style="color:#303133;">1</span><span style="color:#303133;">行</span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;">   return 0;</span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;">  }</span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;"> }</span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;"> public  class Test  extends Parent {<!-- --></span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;">  public float count() {              // </span><span style="color:#303133;">第</span></strong><strong><span style="color:#303133;">2</span><span style="color:#303133;">行</span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;">   return 9;                    // </span><span style="color:#303133;">第</span></strong><strong><span style="color:#303133;">3</span><span style="color:#303133;">行</span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;">  }</span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;"> }</span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;">编译时，会出现以下（</span> <span style="color:#303133;">）情况。</span></strong></p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;">A、 编译通过</p> 
<p style="margin-left:0;">B、 在第1行引发编译错误</p> 
<p style="margin-left:0;">C、</p> 
<p style="margin-left:0;">在第2行引发编译错误</p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;">D、</p> 
<p style="margin-left:0;">在第3行引发编译错误</p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;">答案： C</p> 
<p style="margin-left:0;"><strong>53、<span style="color:#303133;">阅读下面代码：</span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;"> class Parent1 {<!-- --></span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;">  Parent1(String s){<!-- --></span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;">   System.out.println(s);</span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;">  }</span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;"> }</span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;"> class Parent2  extends Parent1{<!-- --></span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;">  Parent2(){<!-- --></span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;">   System.out.println("parent2");</span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;">  }</span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;"> }</span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;"> public class Child extends Parent2 {<!-- --></span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;"> public static void main(String[] args) {<!-- --></span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;">   Child child = new Child();</span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;">  }</span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;"> }</span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;">编译并运行</span></strong><strong><span style="color:#303133;">Child.java</span><span style="color:#303133;">，以上代码运行结果为（</span> <span style="color:#303133;">）。</span></strong></p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;">A、 编译错误：没有找到构造器Child()</p> 
<p style="margin-left:0;">B、</p> 
<p style="margin-left:0;">编译错误：没有找到构造器Parent1()</p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;">C、</p> 
<p style="margin-left:0;">正确运行，没有输出值</p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;">D、</p> 
<p style="margin-left:0;">正确运行，输出结果为：parent2</p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;">答案： B<br> 解析：<span style="color:#606266;">C</span><span style="color:#606266;">选项是因为当我们给出了构造方法，系统将不再提供默认的无参构造函数</span></p> 
<p style="margin-left:0;"><strong>54、<span style="color:#303133;">阅读下面代码：</span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;"> class Parent {<!-- --></span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;"> Parent() {<!-- --></span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;"> System.out.println("parent");</span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;"> }</span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;"> }</span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;"> public class Child extends Parent {<!-- --></span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;"> Child(String s) {<!-- --></span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;"> System.out.println(s);</span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;"> }</span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;">public static void main(String[] args) {<!-- --></span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;"> Child child = new Child("child");</span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;"> }</span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;">}</span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;">上述代码的运行结果为（）</span></strong></p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;">A、 child</p> 
<p style="margin-left:0;">B、 child parent</p> 
<p style="margin-left:0;">C、</p> 
<p style="margin-left:0;">parent child</p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;">D、</p> 
<p style="margin-left:0;">编译错误</p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;">答案： C</p> 
<p style="margin-left:0;"><strong>55、<span style="color:#303133;">阅读下面代码：</span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;">class Parent {<!-- --></span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;">  public void count() {<!-- --></span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;">   System.out.println(10%3);</span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;">  }</span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;"> }</span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;"> public class Child  extends Parent{<!-- --></span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;">  public void count() {<!-- --></span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;">   System.out.println(10/3);</span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;"> }</span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;">  public static void main(String args[]) {<!-- --></span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;">   Parent p = new Child();</span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;">   p.count();</span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;">  }</span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;"> }</span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;">下列选项中的输出结果正确的是（</span> <span style="color:#303133;">）。</span></strong></p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;">A、 1</p> 
<p style="margin-left:0;">B、 1.0</p> 
<p style="margin-left:0;">C、 3</p> 
<p style="margin-left:0;">D、</p> 
<p style="margin-left:0;">3.3333333333333335</p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;">答案： C</p> 
<p style="margin-left:0;"><strong>56、<span style="color:#303133;">阅读下面代码：</span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;">class Base {<!-- --></span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;">  public void method(){<!-- --></span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;">   System.out.print ("Base method");</span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;">  }</span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;"> }</span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;"> class Child extends Base{   </span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;">  public void methodB(){<!-- --></span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;">   System.out.print ("Child methodB");</span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;">  }</span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;"> }</span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;"> class Sample {<!-- --></span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;">  public static void main(String[] args) {<!-- --></span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;">   Base base= new Child();</span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;">  base.methodB();</span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;">  }</span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;"> }</span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;">下列选项中的输出结果正确的是（）</span></strong></p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;">A、</p> 
<p style="margin-left:0;">Base method</p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;">B、</p> 
<p style="margin-left:0;">Child methodB</p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;">C、</p> 
<p style="margin-left:0;">Base method Child MethodB</p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;">D、 编译错误</p> 
<p style="margin-left:0;">答案： D</p> 
<p style="margin-left:0;"><strong>57、<span style="color:#303133;">阅读下面代码：</span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;">interface Parent{<!-- --></span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;">  public int count(int i);</span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;"> }</span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;"> public class Test implements Parent {<!-- --></span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;">  public int count(int i){<!-- --></span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;">   return i % 9;</span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;">  }</span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;">  public static void main(String[] args){<!-- --></span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;">  ________________</span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;">   int i = p.count(20);</span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;">  }</span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;"> }</span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;">在</span></strong><strong><span style="color:#303133;">_____</span><span style="color:#303133;">横线处加入（</span> <span style="color:#303133;">）语句，可以使这段代码编译通过。</span></strong></p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;">A、 Test p = new Test();</p> 
<p style="margin-left:0;">B、</p> 
<p style="margin-left:0;">Parent p;</p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;">C、 Parent p = new Parent();</p> 
<p style="margin-left:0;">D、</p> 
<p style="margin-left:0;">Test p = new Parent();</p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;">答案： A</p> 
<p style="margin-left:0;"><strong>58、<span style="color:#303133;">阅读下面代码：</span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;"> public class Test{<!-- --></span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;">  private static final int counter=10;       </span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;">  public static void main(String [] args){          </span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;">   System.out.println(++counter);        </span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;">  }    </span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;"> }</span></strong></p> 
<p style="margin-left:0;"><strong> <span style="color:#303133;">编译运行</span></strong><strong><span style="color:#303133;">Test.java</span><span style="color:#303133;">，结果是</span> <span style="color:#303133;">（）</span></strong></p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;">A、 10</p> 
<p style="margin-left:0;">B、 11</p> 
<p style="margin-left:0;">C、</p> 
<p style="margin-left:0;">编译错误</p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;">D、</p> 
<p style="margin-left:0;">运行时出现异常</p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;">答案： C<br> 解析：</p> 
<p style="margin-left:0;">final修饰的变量不可以被改变。</p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;"><strong>59、<span style="color:#303133;">阅读下面代码：</span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;"> public interface Face{<!-- --></span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;">  int counter = 40;   </span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;"> }     </span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;"> public class Test implements Face{<!-- --></span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;">  private static int counter;   </span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;">  public static void main(String[]args){<!-- --></span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;">   System.out.println(++counter);       </span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;">  }   </span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;"> }  </span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;">Test.java </span><span style="color:#303133;">的编译运行结果是（）。</span></strong></p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;">A、 40</p> 
<p style="margin-left:0;">B、 41</p> 
<p style="margin-left:0;">C、 0</p> 
<p style="margin-left:0;">D、 1</p> 
<p style="margin-left:0;">答案： D</p> 
<p style="margin-left:0;"><strong>60、<span style="color:#303133;">分析如下</span></strong><strong><span style="color:#303133;">Java</span><span style="color:#303133;">代码，如果想在控制台上输出</span></strong><strong><span style="color:#303133;">“B</span><span style="color:#303133;">类的</span></strong><strong><span style="color:#303133;">test()</span><span style="color:#303133;">方法</span></strong><strong><span style="color:#303133;">”</span><span style="color:#303133;">，则在主函数应填入（）。</span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;"> class A {<!-- --></span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;"> public void test() {<!-- --></span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;"> System.out.println("A</span><span style="color:#303133;">类的</span></strong><strong><span style="color:#303133;">test()</span><span style="color:#303133;">方法</span></strong><strong><span style="color:#303133;">");</span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;"> }</span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;"> }</span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;"> class B extends A {<!-- --></span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;"> public void test() {<!-- --></span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;"> System.out.println("B</span><span style="color:#303133;">类的</span></strong><strong><span style="color:#303133;">test()</span><span style="color:#303133;">方法</span></strong><strong><span style="color:#303133;">");</span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;"> }</span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;"> public static void main(String args[]) {<!-- --></span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;"> }</span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;"> }</span></strong></p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;">A、</p> 
<p style="margin-left:0;">A a = new B(); a.test();</p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;">B、 A a = new A(); a.test();</p> 
<p style="margin-left:0;">C、 B b = new A(); b.test();</p> 
<p style="margin-left:0;">D、 new B().test();</p> 
<p style="margin-left:0;">答案： AD</p> 
<p style="margin-left:0;"><strong>61、<span style="color:#303133;">阅读下面代码：</span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;">public class Parent{<!-- --></span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;">  int change(){<!-- --></span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;">    …</span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;">  }</span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;"> }</span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;"> Class Child extends Parent{<!-- --></span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;"> _______ (</span><span style="color:#303133;">此处可以放入下面哪个选项</span></strong><strong><span style="color:#303133;">)</span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;"> }</span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;">下面选项中可以加入</span></strong><strong><span style="color:#303133;">Child</span><span style="color:#303133;">类中的方法是（）</span></strong></p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;">A、 public int change(){}</p> 
<p style="margin-left:0;">B、</p> 
<p style="margin-left:0;">int show(int i){}</p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;">C、</p> 
<p style="margin-left:0;">private int change(){}</p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;">D、 abstract int change(){}</p> 
<p style="margin-left:0;">答案： AB<br> 解析：<span style="color:#606266;">C</span><span style="color:#606266;">选项</span><span style="color:#606266;">private</span><span style="color:#606266;">的权限低于默认修饰符</span></p> 
<p style="margin-left:0;"><strong>62、<span style="color:#303133;">阅读下面代码：</span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;">abstract class Shape     {<!-- --></span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;">  abstract void draw( );     </span></strong></p> 
<p style="margin-left:0;"><strong><span style="color:#303133;"> }</span></strong></p> 
<p style="margin-left:0;"><strong> <span style="color:#303133;">要创建</span></strong><strong><span style="color:#303133;">Shape</span><span style="color:#303133;">类的子类</span></strong><strong><span style="color:#303133;">Circle</span><span style="color:#303133;">，以下代码正确的是（）。</span></strong></p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;">A、</p> 
<p style="margin-left:0;">class Circle extends Shape{ int draw( ){} }</p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;">B、</p> 
<p style="margin-left:0;">abstract class Circle extends Shape{ }</p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;">C、</p> 
<p style="margin-left:0;">class Circle extends Shape{ void draw( ); }</p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;">D、</p> 
<p style="margin-left:0;">class Circle extends Shape{ void draw( ){} }</p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;">答案： BD</p> 
<p style="margin-left:0;"><strong>63、<br> Throwable类中的printStackTrace(PrintStream s)方法用于将此throwable及其追踪输出至标准错误流。</strong></p> 
<p style="margin-left:0;">答案： 正确</p> 
<p style="margin-left:0;"><strong>64、<br> Throwable类中的printStackTrace ()方法用于将此throwable及其追踪输出至标准错误流。</strong></p> 
<p style="margin-left:0;">答案： 正确</p> 
<p style="margin-left:0;"><strong>65、<br> Throwable类中的getMessage()方法用于返回此throwable 的详细消息字符串。</strong></p> 
<p style="margin-left:0;">答案： 正确</p> 
<p style="margin-left:0;"><strong>66、<br> 【】类及其子类用于表示运行时异常。</strong></p> 
<p style="margin-left:0;">答案：</p> 
<p style="margin-left:0;">RuntimeException</p> 
<p style="margin-left:0;">；</p> 
<p style="margin-left:0;"><strong>67、<br> Exception类称为异常类，它表示程序本身可以处理的错误，在开发Java程序中进行的异常处理，都是针对Exception类及其子类。</strong></p> 
<p style="margin-left:0;">答案： 正确</p> 
<p style="margin-left:0;"><strong>68、<br> Error类称为错误类，它表示Java运行时产生的系统内部错误或资源耗尽的错误，是比较严重的，仅靠修改程序本身是不能恢复执行的。</strong></p> 
<p style="margin-left:0;">答案： 正确</p> 
<p style="margin-left:0;"><strong>69、<br> Throwable有两个直接子类是？（  ）</strong></p> 
<p style="margin-left:0;">A、 Error</p> 
<p style="margin-left:0;">B、 Exception</p> 
<p style="margin-left:0;">C、 ArithmeticException</p> 
<p style="margin-left:0;">D、 以上说法都不对</p> 
<p style="margin-left:0;">答案： AB</p> 
<p style="margin-left:0;"><strong>70、<br> Throwable有两个直接子类Error和Exception，其中Error代表程序中产生的异常，Exception代表程序中产生的错误。</strong></p> 
<p style="margin-left:0;">答案： 错误</p> 
<p style="margin-left:0;"><strong>71、<br> Java中的异常类都继承自java.lang.Throwable类。</strong></p> 
<p style="margin-left:0;">答案： 正确</p> 
<p style="margin-left:0;"><strong>72、<br> Java中提供了大量的异常类，这些类都继承自【】类</strong></p> 
<p style="margin-left:0;">答案：</p> 
<p style="margin-left:0;">java.lang.Throwable</p> 
<p style="margin-left:0;">；</p> 
<p style="margin-left:0;"><strong>73、<br> 下列符号中，哪个用于分隔throws关键字抛出的多个异常（）</strong></p> 
<p style="margin-left:0;">A、 ；</p> 
<p style="margin-left:0;">B、 ，</p> 
<p style="margin-left:0;">C、 &amp;</p> 
<p style="margin-left:0;">D、 |</p> 
<p style="margin-left:0;">答案： B<br> 解析：方法中如果有多个异常，他们之间使用逗号隔开。</p> 
<p style="margin-left:0;"><strong>74、<br> 若有父类Animal及其两个子类Cat、Dog，则以下类型转换正确的有（    ）</strong></p> 
<p style="margin-left:0;">A、 Cat cat = (Cat)new Animal();</p> 
<p style="margin-left:0;">B、 Animal a = new Cat(); Cat cat = (Cat) a;</p> 
<p style="margin-left:0;">C、 Animal animal = new Cat();</p> 
<p style="margin-left:0;">D、 Animal a = new Dog(); Cat cat = (Cat) a;</p> 
<p style="margin-left:0;">答案： BC<br> 解析：无论是向上还是向下转型，最终都是子类对象做着类型的转换。</p> 
<p style="margin-left:0;"><strong>75、<br> 若Animal 是Cat,Dog的父类，则下列选项中，正确的是（）</strong></p> 
<p style="margin-left:0;">A、 Animal animal = new Cat();</p> 
<p style="margin-left:0;">B、 Cat cat = (Cat)new Animal();</p> 
<p style="margin-left:0;">C、 Animal animal = new Dog();</p> 
<p style="margin-left:0;">D、 Cat cat = (Cat)new Dog();</p> 
<p style="margin-left:0;">答案： AC<br> 解析：将子类对象当做父类使用时不需要任何显式地声明，需要注意的是，此时不能通过父类变量去调用子类中某些方法。</p> 
<p style="margin-left:0;"><strong>76、<br> 下面选项中哪一行代码能正确赋值（）</strong></p> 
<p style="margin-left:0;">A、 final int num1 = 10;</p> 
<p style="margin-left:0;">B、 static int num2 = 20;</p> 
<p style="margin-left:0;">C、 abstract int num3 = 30;</p> 
<p style="margin-left:0;">D、 private int num4 = 40;</p> 
<p style="margin-left:0;">答案： A<br> 解析：final可以修饰局部变量。</p> 
<p style="margin-left:0;"><strong>77、<br> 已知类的继承关系如下： <br> class A<br> class B extends A<br> class C extends A<br> 则以下语句能通过编译的是（    ）</strong></p> 
<p style="margin-left:0;">A、 A a=new B();</p> 
<p style="margin-left:0;">B、 C c=new B();</p> 
<p style="margin-left:0;">C、 C c=new A();</p> 
<p style="margin-left:0;">D、 B b=new C();</p> 
<p style="margin-left:0;">答案： A<br> 解析：假设A为犬类，B为狗，C为狼，那么狗当然属于犬类对象。</p> 
<p style="margin-left:0;"><strong>78、<br> 下列关于自定义异常的说法中，错误的是（  ）</strong></p> 
<p style="margin-left:0;">A、 自定义异常要继承Exception类</p> 
<p style="margin-left:0;">B、 自定义异常继承Exception类后，具有可抛性</p> 
<p style="margin-left:0;">C、 自定义异常可以在构造方法中用super关键字传递异常信息给父类</p> 
<p style="margin-left:0;">D、 自定义异常必须继承Error类</p> 
<p style="margin-left:0;">答案： D<br> 解析：自定义异常的特点。</p> 
<p style="margin-left:0;"><strong>79、<br> 如果类的成员被（    ）访问控制符来修饰，则这个成员只能被该类的其它成员访问，其它类无法直接访问。</strong></p> 
<p style="margin-left:0;">A、 private</p> 
<p style="margin-left:0;">B、 default</p> 
<p style="margin-left:0;">C、 protected</p> 
<p style="margin-left:0;">D、 public</p> 
<p style="margin-left:0;">答案： A<br> 解析：如果类的成员被private访问控制符来修饰，则这个成员只能被该类的其它成员访问，其它类无法直接访问。类的良好封装就是通过private关键字来实现的</p> 
<p style="margin-left:0;"><strong>80、<br> 开发中，编译时期产生的异常，可以不进行处理，依然可以通过编译。</strong></p> 
<p style="margin-left:0;">答案： 正确<br> 解析：在实际开发中，经常会在程序编译时期产生一些异常，而这些异常必须要进行处理，这种异常被称为编译时期异常。</p> 
<p style="margin-left:0;"><strong>81、<br> 以下关于编译异常说法正确的是（  ）</strong></p> 
<p style="margin-left:0;">A、 编译异常就是指Exception以及其子类</p> 
<p style="margin-left:0;">B、 编译异常如果产生，可以不用处理</p> 
<p style="margin-left:0;">C、 编译异常如果产生，必须处理，要么捕获，要么抛出</p> 
<p style="margin-left:0;">D、 编译异常指的就是Error</p> 
<p style="margin-left:0;">答案： C<br> 解析：编译异常如果产生，必须处理，要么捕获，要么抛出。</p> 
<p style="margin-left:0;"><strong>82、在类的继承关系中，需要遵循以下哪个继承原则（）</strong></p> 
<p style="margin-left:0;">A、 多重</p> 
<p style="margin-left:0;">B、 单一</p> 
<p style="margin-left:0;">C、 双重</p> 
<p style="margin-left:0;">D、 不能继承</p> 
<p style="margin-left:0;">答案： B</p> 
<p style="margin-left:0;"><strong>83、类中的一个成员方法被下面哪个修饰符修饰，该方法只能在本类被访问（）</strong></p> 
<p style="margin-left:0;">A、 public</p> 
<p style="margin-left:0;">B、 private</p> 
<p style="margin-left:0;">C、 protected</p> 
<p style="margin-left:0;">D、 default</p> 
<p style="margin-left:0;">答案： B</p> 
<p style="margin-left:0;"><strong>84、下列关于类的继承的描述，正确的是（）。</strong></p> 
<p style="margin-left:0;">A、 一个类可以继承多个父类</p> 
<p style="margin-left:0;">B、 一个类可以具有多个子类</p> 
<p style="margin-left:0;">C、 子类可以使用父类的所有方法</p> 
<p style="margin-left:0;">D、 子类一定比父类有更多的成员方法</p> 
<p style="margin-left:0;">答案： B<br> 解析：A、一个类只能继承一个父类｜C、子类可以使用父类的非私有方法｜D、子类不一定比父类有更多的成员方法</p> 
<p style="margin-left:0;"><strong>85、Java中，如果类C是类B的子类，类B是类A的子类，那么下面描述正确的是（）。</strong></p> 
<p style="margin-left:0;">A、 C可以继承B中的公有成员，同样也可以继承A中的公有成员</p> 
<p style="margin-left:0;">B、 C只继承了B中的成员</p> 
<p style="margin-left:0;">C、 C只继承了A中的成员</p> 
<p style="margin-left:0;">D、 C不能继承A或B中的成员</p> 
<p style="margin-left:0;">答案： A</p> 
<p style="margin-left:0;"><strong>86、下列选项中关于Java中super关键字的说法，错误的是（ ）。</strong></p> 
<p style="margin-left:0;">A、 当子类和父类中成员变量重名的时候,在子类方法中想输出父类成员变量的值,可以用super区分子父类成员变量</p> 
<p style="margin-left:0;">B、 super语句可以放在构造函数的任意一行</p> 
<p style="margin-left:0;">C、 子类可以通过super关键字调用父类的方法</p> 
<p style="margin-left:0;">D、 子类可以通过super关键字调用父类的属性</p> 
<p style="margin-left:0;">答案： B</p> 
<p style="margin-left:0;"><strong>87、下面关于匿名内部类、接口、抽象类和局部内部类的说法，正确的是( )</strong></p> 
<p style="margin-left:0;">A、 匿名内部类编译后不会生成.class文件</p> 
<p style="margin-left:0;">B、 接口编译后不会生成.class文件</p> 
<p style="margin-left:0;">C、 抽象类中没有构造方法</p> 
<p style="margin-left:0;">D、 局部内部类只能访问被final修饰的局部变量</p> 
<p style="margin-left:0;">答案： D</p> 
<p style="margin-left:0;"><strong>88、在Java中，如果父类中的某些方法不包含任何逻辑，并且需要有子类重写，应该使用（）关键字来声明父类的这些方法</strong></p> 
<p style="margin-left:0;">A、 final</p> 
<p style="margin-left:0;">B、 static</p> 
<p style="margin-left:0;">C、 abstract</p> 
<p style="margin-left:0;">D、 void</p> 
<p style="margin-left:0;">答案： C</p> 
<p style="margin-left:0;"><strong>89、在Java中，多态的实现不仅能减少编码的工作量，还能大大提高程序的可维护性及可扩展性，下面哪一个选项不属于多态的条件（）。</strong></p> 
<p style="margin-left:0;">A、 子类重写父类的方法</p> 
<p style="margin-left:0;">B、 子类重载同一个方法</p> 
<p style="margin-left:0;">C、 要有继承或实现</p> 
<p style="margin-left:0;">D、 父类引用指向子类对象</p> 
<p style="margin-left:0;">答案： B</p> 
<p style="margin-left:0;"><strong>90、在Java中，要想让一个类继承另一个类，可以使用以下哪个关键字（）</strong></p> 
<p style="margin-left:0;">A、 inherits</p> 
<p style="margin-left:0;">B、 extends</p> 
<p style="margin-left:0;">C、 implements</p> 
<p style="margin-left:0;">D、 modifies</p> 
<p style="margin-left:0;">答案： B</p> 
<p style="margin-left:0;"><strong>91、下面说法中错误的是（）</strong></p> 
<p style="margin-left:0;">A、 静态代码块只在类加载后执行一次,以后再创建对象的时候不执行</p> 
<p style="margin-left:0;">B、 局部代码块的作用是为了限制变量的生命周期</p> 
<p style="margin-left:0;">C、 构造代码块在每创建一次对象就执行一次</p> 
<p style="margin-left:0;">D、 以上都不对</p> 
<p style="margin-left:0;">答案： D</p> 
<p style="margin-left:0;"><strong>92、关于super关键字以下说法哪些是正确的（）</strong></p> 
<p style="margin-left:0;">A、 super关键字可以调用父类的构造方法</p> 
<p style="margin-left:0;">B、 super关键字可以调用父类的普通方法</p> 
<p style="margin-left:0;">C、 super与this不能同时存在于同一个构造方法中</p> 
<p style="margin-left:0;">D、 super与this可以同时存在于同一个构造方法中</p> 
<p style="margin-left:0;">答案： ABC</p> 
<p style="margin-left:0;"><strong>93、在Java中，下面关于抽象类的描述正确的是（）。</strong></p> 
<p style="margin-left:0;">A、 抽象类可以被实例化</p> 
<p style="margin-left:0;">B、 如果一个类中有一个方法被声明为抽象的，那么这个类必须是抽象类</p> 
<p style="margin-left:0;">C、 抽象类中的方法必须都是抽象的</p> 
<p style="margin-left:0;">D、 声明抽象类必须带有关键字abstract</p> 
<p style="margin-left:0;">答案： BD</p> 
<p style="margin-left:0;"><strong>94、下面选项中不能和abstract关键字共用的是()</strong></p> 
<p style="margin-left:0;">A、 abstract不可以和private共用</p> 
<p style="margin-left:0;">B、 abstract不可以和static共用</p> 
<p style="margin-left:0;">C、 abstract不可以和final共用</p> 
<p style="margin-left:0;">D、 abstract不可以和public共用</p> 
<p style="margin-left:0;">答案： ABC</p> 
<p style="margin-left:0;"><strong>95、在java中，已定义了两个接口B和C，下面继承语句正确的是（）</strong></p> 
<p style="margin-left:0;">A、 interface A extends B,C</p> 
<p style="margin-left:0;">B、 interface A implements B,C</p> 
<p style="margin-left:0;">C、 class A implements B,C</p> 
<p style="margin-left:0;">D、 class A implements B,implements C</p> 
<p style="margin-left:0;">答案： AC</p> 
<p style="margin-left:0;"><strong>96、下面关于Java接口的说法正确的是（）</strong></p> 
<p style="margin-left:0;">A、 Java接口中定义的是扩展功能</p> 
<p style="margin-left:0;">B、 Java接口中可以被多个子类实现,一个类也可以同时实现多个接口</p> 
<p style="margin-left:0;">C、 Java接口中可以声明私有成员</p> 
<p style="margin-left:0;">D、 Java接口不能被实例化</p> 
<p style="margin-left:0;">答案： ABD</p> 
<p style="margin-left:0;"><strong>97、在Java接口中定义常量，下面语法正确的是（）。</strong></p> 
<p style="margin-left:0;">A、 static int MALE = 1;</p> 
<p style="margin-left:0;">B、 final int MALE = 1;</p> 
<p style="margin-left:0;">C、 int MALE = 1;</p> 
<p style="margin-left:0;">D、 private int MALE = 1;</p> 
<p style="margin-left:0;">答案： ABC</p> 
<p style="margin-left:0;"><strong>98、不存在继承关系的情况下，也可以实现重写。</strong></p> 
<p style="margin-left:0;">答案： 错误<br> 解析：不存在继承关系的情况下，不可以实现重写。</p> 
<p style="margin-left:0;"><strong>99、Java中，子类可以覆盖父类中的任意方法。</strong></p> 
<p style="margin-left:0;">答案： 错误</p> 
<p style="margin-left:0;"><strong>100、Java中被final关键字修饰的变量，不能被重新赋值。</strong></p> 
<p style="margin-left:0;">答案： 正确<br> 解析：Java中被final关键字修饰的变量，称为常量，他只能被赋值一次。</p> 
<p style="margin-left:0;"><strong>101、super调用父类构造方法的代码必须位于子类构造方法的第一行。</strong></p> 
<p style="margin-left:0;">答案： 正确<br> 解析：super调用父类构造方法的代码必须位于子类构造方法的第一行。</p> 
<p style="margin-left:0;"><strong>102、抽象方法必须定义在抽象类中，所以抽象类中的方法都是抽象方法。</strong></p> 
<p style="margin-left:0;">答案： 错误<br> 解析：抽象类可以不包含任何抽象方法</p> 
<p style="margin-left:0;"><strong>103、如果一个类继承了一个抽象类，但是没有完全复写父类的所有的抽象方法那么这个类也是抽象类。</strong></p> 
<p style="margin-left:0;">答案： 正确</p> 
<p style="margin-left:0;"><strong>104、Throwable有两个直接子类Error和Exception，其中Error代表程序中产生的异常，Exception代表程序中产生的错误。</strong></p> 
<p style="margin-left:0;">答案： 错误</p> 
<p style="margin-left:0;"><strong>105、使用【】关键字修饰的类不可以被继承。</strong></p> 
<p style="margin-left:0;">答案：</p> 
<p style="margin-left:0;">final</p> 
<p style="margin-left:0;">；</p> 
<p style="margin-left:0;"><strong>106、一个类如果实现一个接口，那么他就需要实现接口定义的全部【】，否则该类就必须定义成【】。</strong></p> 
<p style="margin-left:0;">答案：</p> 
<p style="margin-left:0;">抽象方法；</p> 
<p style="margin-left:0;">抽象类；<br> 解析：当一个类实现接口时，如果这个类是抽象类，只需要实现接口中的部分抽象方法即可，否则需要实现接口中的所有抽象方法。</p> 
<p style="margin-left:0;"><strong>107、一个类可以从其他的类中派生出来，派生出来的类称为【】，用于派生的类称为【】或者【】。</strong></p> 
<p style="margin-left:0;">答案：</p> 
<p style="margin-left:0;">子类；</p> 
<p style="margin-left:0;">基类</p> 
<p style="margin-left:0;">；</p> 
<p style="margin-left:0;">父类</p> 
<p style="margin-left:0;">；</p> 
<p style="margin-left:0;"><strong>108、在继承关系中，子类会自动继承父类中的方法，但有时在子类中需要对继承的方法进行一些修改，即对父类的方法进行【】。</strong></p> 
<p style="margin-left:0;">答案：</p> 
<p style="margin-left:0;">重写</p> 
<p style="margin-left:0;">；</p> 
<p style="margin-left:0;"><strong>109、在定义方法时不写方法体，这种不包含方法体的方法为【】方法。</strong></p> 
<p style="margin-left:0;">答案：</p> 
<p style="margin-left:0;">抽象</p> 
<p style="margin-left:0;">；</p> 
<p style="margin-left:0;"><strong>110、在Java语言中，所有的类都直接或间接继承自【】类。</strong></p> 
<p style="margin-left:0;">答案：</p> 
<p style="margin-left:0;">Object</p> 
<p style="margin-left:0;">；</p> 
<p style="margin-left:0;"><strong>111、Object类中的equals方法的参数是【】类型的参数。</strong></p> 
<p style="margin-left:0;">答案：</p> 
<p style="margin-left:0;">Object</p> 
<p style="margin-left:0;">；</p> 
<p style="margin-left:0;"><strong>112、RuntimeException类及其子类都是【】异常。</strong></p> 
<p style="margin-left:0;">答案：</p> 
<p style="margin-left:0;">运行时</p> 
<p style="margin-left:0;">；</p> 
<p style="margin-left:0;"><strong>113、Java中提供了大量的异常类，这些类都继承自【】类。</strong></p> 
<p style="margin-left:0;">答案：</p> 
<p style="margin-left:0;">java.lang.Throwable</p> 
<p style="margin-left:0;">；</p> 
<p style="margin-left:0;"><strong>114、【】关键字用于在方法中声明抛出异常的实例对象。</strong></p> 
<p style="margin-left:0;">答案：</p> 
<p style="margin-left:0;">throws</p> 
<p style="margin-left:0;">；</p> 
<p style="margin-left:0;"><strong>115、<br> 下面程序的运行结果是（    ）<br> public class Demo {<!-- --><br>  public static void main(String[] args) {<!-- --><br>   try {<!-- --><br>    System.out.println(10 / 0);<br>   } catch (RuntimeException e) {<!-- --><br>    System.out.println("RuntimeException");<br>   } catch (ArithmeticException e) {<!-- --><br>    System.out.println("ArithmeticException");<br>   }<br>  }<br> }</strong></p> 
<p style="margin-left:0;">A、 编译失败</p> 
<p style="margin-left:0;">B、 编译通过，没有结果输出</p> 
<p style="margin-left:0;">C、 输出：RuntimeException</p> 
<p style="margin-left:0;">D、 输出：ArithmeticException</p> 
<p style="margin-left:0;">答案： A<br> 解析：在用try…catch处理异常的时候，子类异常一定要先catch，父类异常最后catch。</p> 
<p style="margin-left:0;"><strong>116、<br> 【】关键字用于在方法中声明抛出异常的实例对象。</strong></p> 
<p style="margin-left:0;">答案：</p> 
<p style="margin-left:0;">throw</p> 
<p style="margin-left:0;">；<br> 解析：这时就需要用到throw关键字，throw关键字用于在方法中声明抛出异常的实例对象。</p> 
<p style="margin-left:0;"><strong>117、<br> 编译时异常的处理方案有几种?分别是什么?</strong></p> 
<p style="margin-left:0;">答案：</p> 
<p style="margin-left:0;">有两种。<br> 方式1：使用try…catch语句对异常进行捕获<br> 方式2：使用throws关键字声明抛出异常","调用者对其处理。</p> 
<p style="margin-left:0;"><br> 解析：在Java中，Exception类中除了RuntimeException类及其的子类都是编译时异常。编译时异常的特点是Java编译器会对其进行检查，如果出现异常就必须对异常进行处理，否则程序无法通过编译。<br> 处理编译时期的异常有两种方式，具体如下：<br> 使用try…catch语句对异常进行捕获<br>  </p> 
<p style="margin-left:0;"><strong>118、<br> 如果一个方法要抛出多个异常，则需要使用多个throws进行抛出。</strong></p> 
<p style="margin-left:0;">答案： 错误<br> 解析：如果一个方法要抛出多个异常，使用一个throws就可以了，但多个异常之间需要用逗号隔开。</p> 
<p style="margin-left:0;"><strong>119、<br> throw关键字后面必须写异常对象。</strong></p> 
<p style="margin-left:0;">答案： 正确<br> 解析：throw关键字用在方法内部，后面必须写异常对象。</p> 
<p style="margin-left:0;"><strong>120、<br> 请阅读下面的程序，在空白处填写正确的代码。<br> class Demo{<!-- --><br>    public static void main(String[] args){<!-- --><br>            try{<!-- --><br> System.out.println(getArea(6.1,4.1));<br> }catch(【】 e){}<br> }<br> public  static double getArea (double d1,double d2)throws Exception{<!-- --><br>    if(d1 &lt;0|| d2 &lt; 0)<br>       throw new Exception();<br>     return d1*d2;<br> }<br> }</strong></p> 
<p style="margin-left:0;">答案：</p> 
<p style="margin-left:0;">Exception</p> 
<p style="margin-left:0;">；<br> 解析：try...catch语句,Exception。</p> 
<p style="margin-left:0;"><strong>121、<br> 定义一个方法，只想被不同包下的子类使用，需要使用访问修饰符【】。</strong></p> 
<p style="margin-left:0;">答案：</p> 
<p style="margin-left:0;">protected</p> 
<p style="margin-left:0;">；<br> 解析：protected受保护权限。</p> 
<p style="margin-left:0;"><strong>122、<br> 在try…catch语句中，try语句块存放可能发生异常的语句。</strong></p> 
<p style="margin-left:0;">答案： 正确<br> 解析：try语句块中存放可能发生异常的语句，一旦发生异常，通过catch语句块进行捕获。</p> 
<p style="margin-left:0;"><strong>123、<br> Java中的异常分为两种,一种是【】另外一种是运行时异常。</strong></p> 
<p style="margin-left:0;">答案：</p> 
<p style="margin-left:0;">编译时异常</p> 
<p style="margin-left:0;">；<br> 解析：Java中的异常分为两种,一种是编译时异常另外一种是运行时异常。</p> 
<p style="margin-left:0;"><strong>124、<br> 编译异常如果产生，可以处理，也可以不用处理。</strong></p> 
<p style="margin-left:0;">答案： 错误<br> 解析：编译异常如果产生了，要求我们在必须处理，要么捕获，要么抛出。</p> 
<p style="margin-left:0;"><strong>125、<br> 请阅读下面的程序，在空白处填写正确的代码，使程序可以编译通过<br> class Demo{<!-- --><br>    public static void main(String[] args){<!-- --><br>            try{<!-- --><br> System.out.println(getArea(6.1,4.1));<br> }catch(Exception e){}<br> }<br> public  static double getArea (double d1,double d2)throws Exception{<!-- --><br>    if(d1 &lt;0|| d2 &lt; 0)<br>       【】 Exception();<br>     return d1*d2;<br> }<br> }</strong></p> 
<p style="margin-left:0;">答案：</p> 
<p style="margin-left:0;">throw</p> 
<p style="margin-left:0;">；<br> 解析：throw用法，异常对象。</p> 
<p style="margin-left:0;"><strong>126、<br> 下列异常中，属于编译时异常的是（  ）</strong></p> 
<p style="margin-left:0;">A、 NumberFormatException</p> 
<p style="margin-left:0;">B、 ArithmeticException</p> 
<p style="margin-left:0;">C、 ClassNotFoundException</p> 
<p style="margin-left:0;">D、 RuntimeException</p> 
<p style="margin-left:0;">答案： C</p> 
<p style="margin-left:0;"><strong>127、<br> 下列关于throws的描述中，正确的是（  ）</strong></p> 
<p style="margin-left:0;">A、 throws是用来声明一个方法可能抛出的异常信息</p> 
<p style="margin-left:0;">B、 throws语句用在方法声明后面</p> 
<p style="margin-left:0;">C、 方法中没有使用catch处理的异常必须使用throws抛出</p> 
<p style="margin-left:0;">D、 throws关键字对外声明该方法有可能发生的异常，调用者在调用方法时必须在程序中对异常进行处理</p> 
<p style="margin-left:0;">答案： ABCD<br> 解析：针对这种情况，Java中允许在方法的后面使用throws关键字对外声明该方法有可能发生的异常，这样调用者在调用方法时，就明确地知道该方法有异常，并且必须在程序中对异常进行处理，否则编译无法通过。</p> 
<p style="margin-left:0;"><strong>128、<br> 下面程序的运行结果是（    ）<br> public class Demo {<!-- --><br>  public static void main(String[] args) {<!-- --><br>       try {<!-- --><br>       System.out.println(10 / 0);<br>       System.out.println("除法正常运行");<br>       } catch (ArithmeticException e) {<!-- --><br>       System.out.println("除数不能为0");<br>       }<br>      }<br> }</strong></p> 
<p style="margin-left:0;">A、 编译失败</p> 
<p style="margin-left:0;">B、 编译通过，没有结果输出</p> 
<p style="margin-left:0;">C、 输出：除法正常运行</p> 
<p style="margin-left:0;">D、 输出：除数不能为0</p> 
<p style="margin-left:0;">答案： D<br> 解析：虽然是运行时期异常，但是也可以使用try…catch语句进行处理。一旦进入处理语句就不会再回去执行。</p> 
<p style="margin-left:0;"><strong>129、<br> 下列关于自定义异常的描述中，正确的是（    ）</strong></p> 
<p style="margin-left:0;">A、 自定义的异常类需继承Exception类，在构造方法中使用super()语句调用Exception的构造方法</p> 
<p style="margin-left:0;">B、 自定义异常类需要用throw关键字在方法中声明抛出异常的实例对象</p> 
<p style="margin-left:0;">C、 如果想要调用者捕获throw抛出的异常，需要在抛出异常的方法中使用throws关键字指明异常</p> 
<p style="margin-left:0;">D、 抛出的异常对象可以使用try…catch语句对其进行处理</p> 
<p style="margin-left:0;">答案： ABCD</p> 
<p style="margin-left:0;"><strong>130、<br> 运行时异常是必须进行处理的异常，否则程序编译不能通过。</strong></p> 
<p style="margin-left:0;">答案： 错误<br> 解析：运行时异常的特点是Java编译器不会对其进行检查，也就是说，当程序中出现这类异常时，即使没有使用try..catch语句捕获或使用throws关键字声明抛出，程序也能编译通过。</p> 
<p style="margin-left:0;"><strong>131、<br> 自定义一个运行时异常,要求如下：<br> 1） 类名为MyRuntimeException<br> 2） 将异常描述信息传递给父类</strong></p> 
<p style="margin-left:0;">答案：</p> 
<p style="margin-left:0;">public class MyRuntimeException extends RuntimeException{<!-- --><br>    public MyRuntimeException(String message){<!-- --><br>          super(message);<br> }<br> }</p> 
<p style="margin-left:0;"><br> 解析：继承RuntimeException，super传递异常信息。</p> 
<p style="margin-left:0;"><strong>132、<br> 下列关于throws关键字的描述中，正确的是（  ）</strong></p> 
<p style="margin-left:0;">A、 thorws可以声明在方法上也可以声明在方法体中</p> 
<p style="margin-left:0;">B、 方法上使用throws抛出一个异常则这个方法中一定有trycatch代码块</p> 
<p style="margin-left:0;">C、 使用throws抛出多个异常时各个异常之间必须使用逗号隔开</p> 
<p style="margin-left:0;">D、 throws必须和throw配合使用</p> 
<p style="margin-left:0;">答案： C<br> 解析：throws关键字声明抛出异常的语法格式如下：<br> 修饰符 返回值类型 方法名([参数1，参数2.....])throws ExceptionType1[,ExceptionType2.....]{<!-- --><br> }</p> 
<p style="margin-left:0;"><strong>133、<br> 下面程序运行的结果是（  ）<br>  class Demo{<!-- --><br>       public static void main(String[] args){<!-- --><br>             int x = div(1,2);<br>             try{<!-- --><br>             }catch(Exception e){<!-- --><br>                 System.out.println(e);<br>             }<br>             System.out.println(x);<br>         }<br>         public static int div(int a,int b){<!-- --><br>             return a / b ;<br>         }<br>     }</strong></p> 
<p style="margin-left:0;">A、 输出1</p> 
<p style="margin-left:0;">B、 输出0</p> 
<p style="margin-left:0;">C、 输出0.5</p> 
<p style="margin-left:0;">D、 编译失败</p> 
<p style="margin-left:0;">答案： B</p> 
<p style="margin-left:0;"><strong>134、<br> throw关键字用于在方法中声明抛出异常的【】。</strong></p> 
<p style="margin-left:0;">答案：</p> 
<p style="margin-left:0;">实例对象</p> 
<p style="margin-left:0;">；<br> 解析：throw关键字用于在方法中声明抛出异常的实例对象。</p> 
<p style="margin-left:0;"><strong>135、<br> 编译异常如果产生了，要求我们在必须处理，要么捕获，要么抛出。</strong></p> 
<p style="margin-left:0;">答案： 正确<br> 解析：编译异常如果产生了，要求我们在必须处理，要么捕获，要么抛出</p> 
<p style="margin-left:0;"><strong>136、<br> protected修饰的类，类中的所有方法只能给子类使用。</strong></p> 
<p style="margin-left:0;">答案： 错误<br> 解析：protecetd不能修饰类。</p> 
<p style="margin-left:0;"><strong>137、<br> throw关键字用于在方法上声明抛出异常的实例对象。</strong></p> 
<p style="margin-left:0;">答案： 错误<br> 解析：throw关键字用于在方法中声明抛出异常的实例对象<br> throws关键字需要写在方法声明的后面，throws后面需要声明方法中发生异常的类型。</p> 
<p style="margin-left:0;"><strong>138、<br> protected修饰的方法，只能给子类使用。</strong></p> 
<p style="margin-left:0;">答案： 错误<br> 解析：同一包下的类也可以使用。</p> 
<p style="margin-left:0;"><strong>139、<br> RuntimeException类及其子类都是【】异常。</strong></p> 
<p style="margin-left:0;">答案：</p> 
<p style="margin-left:0;">运行时</p> 
<p style="margin-left:0;">；<br> 解析：RuntimeException类及其子类都是运行时异常。</p> 
<p style="margin-left:0;"><strong>140、<br> 阅读下面的程序，分析代码是否能够编译通过，如果能编译通过，请列出运行的结果。否则请说明编译失败的原因。<br> public class Demo {<!-- --><br>  public static void main(String[] args) throws Exception {<!-- --><br>   System.out.println(showNum());<br>  }<br>  public static int showNum() throws Exception {<!-- --><br>   int i = 10;<br>   try {<!-- --><br>    if (i++ == 10) {<!-- --><br>     throw new Exception();<br>    }<br>    i += 5;<br>    System.out.println(i);<br>    return i;<br>   } catch (Exception e) {<!-- --><br>    i++;<br>    return i;<br>   } finally {<!-- --><br>    i++;<br>   }<br>  }<br> }</strong></p> 
<p style="margin-left:0;">答案：</p> 
<p style="margin-left:0;">12</p> 
<p style="margin-left:0;"><br> 解析：if条件结果为true,跳转到catch,这时i的值为11,在catch中执行了<br> i++后结果为12,因为有finally，这时会将结果存储到内存中，当执行完<br> finally内容，这时的i的值为13,但是在catch中有return了，这时返<br>  </p> 
<p style="margin-left:0;"><strong>141、<br> class MyException extends (1) {<!-- --><br> }<br> public class Demo {<!-- --><br>  public static void main(String[] args) {<!-- --><br>   try {<!-- --><br>    show();<br>   } catch (  (2)  e) {<!-- --><br>    e.printStackTrace();<br>   }<br>  }<br>  public static void show() (3) MyException {<!-- --><br>   throw  new  MyException();<br>  }<br> 以上程序，创建了一个自定义异常(编译异常)，请补全空白处代码（    ）</strong></p> 
<p style="margin-left:0;">A、 (1)Exception(2)MyException(3)throws</p> 
<p style="margin-left:0;">B、 (1)MyException(2)Exception(3)throws</p> 
<p style="margin-left:0;">C、 (1)Exception(2)Exception(3)throws</p> 
<p style="margin-left:0;">D、 (1)Exception(2)MyException(3)Exception</p> 
<p style="margin-left:0;">答案： A<br> 解析：自定义的异常类继承自Exception或其子类。Throws用于抛出异常。</p> 
<p style="margin-left:0;"><strong>142、<br> 阅读下面的程序，分析代码是否能够编译通过，如果能编译通过，请列出运行的结果并分析出现此结果的原因。否则请说明编译失败的原因。<br> class Cat{<!-- --><br>  void mi( ) throws NullPointerException{<!-- --><br>   System.out.println( "Cat mi mi .. " );<br>  }<br> }<br> public class SmallCat extends Cat{<!-- --><br>  void mi( ) throws Exception{<!-- --><br>   System.out.println( "SmallCat mi mi .. " );<br>  }<br>  public static void main( String[] a ) throws Exception{<!-- --><br>   Cat cat = new SmallCat();<br>   cat.mi();<br>  }<br> }</strong></p> 
<p style="margin-left:0;">答案：</p> 
<p style="margin-left:0;">程序编译失败。在子类中","如果要覆盖父类的一个方法","而父类中的方法声明了throws异常","则子类的方法也可以抛出异常","但切记子类方法抛出的异常只能是父类方法抛出的异常的同类或子类","而不能是父类。</p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;"><strong>143、<br> 编写一段代码证明 java对try——catch——finally的执行机制是这样的：在虚拟机不退出，即程序不终止的情况下，finally方法总会得到执行，即便catch块里有return语句也会执行完finally再返回。并且返回的是catch快中return的值（finally中不存在return）。</strong></p> 
<p style="margin-left:0;">答案：</p> 
<p style="margin-left:0;">public class TestFinally{<!-- --><br>  public static void main(String[] args) {  <br>         System.out.println("i的值为。。。"+new TestFinally().test());  <br>     }  <br>     private int test(){  <br>         int i = 1;  <br>         try {  <br>             return i;  <br>         }finally{  <br>             ++i;  <br>             System.out.println("finally is Executed...");  <br>         }  <br>     }  <br> }   <br> 输出结果为：finally is Executed...<br>            i的值为。。。1</p> 
<p style="margin-left:0;"><br> 解析：在高级语言中，调用一个方法，若其有返回值，总是会返回return后面变量或语句的值，这时java机制会把return后面变量或语句的值存储在某一内存空间，只是由于还有finally还没执行，故暂不返回，等finally执行完毕，就返回刚才已经储存的i值。</p> 
<p style="margin-left:0;"><strong>144、<br> JDK中定义了大量的异常类，这些异常类足够我们使用了，所以，我们不需要自己定义异常类。</strong></p> 
<p style="margin-left:0;">答案： 错误<br> 解析：JDK中定义了大量的异常类，虽然这些异常类可以描述编程时出现的大部分异常情况，但是在程序开发中有时可能需要描述程序中特有的异常情况，所以，我们在开发中还是需要自己定义异常类。</p> 
<p style="margin-left:0;"><strong>145、<br> 【】是指除了RuntimeException及其子类外的异常。</strong></p> 
<p style="margin-left:0;">答案：</p> 
<p style="margin-left:0;">编译时异常</p> 
<p style="margin-left:0;">；<br> 解析：编译时异常是指除了RuntimeException及其子类外的异常。</p> 
<p style="margin-left:0;"><strong>146、<br> 在Java中允许用户自定义异常，但自定义的异常类必须继承自Exception或其子类。</strong></p> 
<p style="margin-left:0;">答案： 正确<br> 解析：在Java中允许用户自定义异常，但自定义的异常类必须继承自Exception或其子类，只有这样，你的类才能被认为是异常体系结构的一部分，是一个异常类。</p> 
<p style="margin-left:0;"><strong>147、<br> throws关键字用于对外声明方法可能发生的异常，这样调用者在调用方法时，可以明确知道该方法有异常，并进行相关处理。</strong></p> 
<p style="margin-left:0;">答案： 正确<br> 解析：throws主要是声明这个方法会抛出这种类型的异常，使它的调用者知道要捕获这个异常。</p> 
<p style="margin-left:0;"><strong>148、<br> 下列选项中，不属于运行时异常类子类的是（    ）</strong></p> 
<p style="margin-left:0;">A、 ArrayStoreException</p> 
<p style="margin-left:0;">B、 ClassCastException</p> 
<p style="margin-left:0;">C、 IllegalArgumentException</p> 
<p style="margin-left:0;">D、 ThreadDeath</p> 
<p style="margin-left:0;">答案： D<br> 解析：ThreadDeath属于Error类的子类。</p> 
<p style="margin-left:0;"><strong>149、<br> 下面关于throws作用的描述中，正确的是（  ）</strong></p> 
<p style="margin-left:0;">A、 一个方法只能抛出一个异常信息</p> 
<p style="margin-left:0;">B、 一个方法上使用throws声明一个异常说明这个方法运行时一定会抛出这个异常</p> 
<p style="margin-left:0;">C、 throws可以声明在方法体中用来指定抛出的具体异常</p> 
<p style="margin-left:0;">D、 throws关键字需要写在方法声明的后面</p> 
<p style="margin-left:0;">答案： D<br> 解析：throws关键字需要写在方法声明的后面，throws后面需要声明方法中发生异常的类型，通常将这种做法称为方法声明抛出一个异常。</p> 
<p style="margin-left:0;"><strong>150、<br> 下列关于protected的说法中，正确的是（）</strong></p> 
<p style="margin-left:0;">A、 protected修饰的方法，只能给子类使用</p> 
<p style="margin-left:0;">B、 protected修饰的类，类中的所有方法只能给子类使用</p> 
<p style="margin-left:0;">C、 如果一个类的成员被protected修饰，那么这个成员既能被同一包下的其它类访问，也能被不同包下该类的子类访问。</p> 
<p style="margin-left:0;">D、 以上都不对</p> 
<p style="margin-left:0;">答案： C<br> 解析：如果一个类的成员被protected访问控制符修饰，那么这个成员既能被同一包下的其它类访问，也能被不同包下该类的子类访问。</p> 
<p style="margin-left:0;"><strong>151、<br> 自定义运行时异常，必须继承自（  ）类。</strong></p> 
<p style="margin-left:0;">A、 Error</p> 
<p style="margin-left:0;">B、 Exception</p> 
<p style="margin-left:0;">C、 RuntimeException</p> 
<p style="margin-left:0;">D、 Throwable</p> 
<p style="margin-left:0;">答案： C<br> 解析：RuntimeException运行时异常的超类。</p> 
<p style="margin-left:0;"><strong>152、<br> 请按照以下要求设计一个自定义异常，并进行测试。<br> 要求如下：<br> 1） 创建一个BlueException，要求继承自Exception.并提供可以自定义异常信息的构造方法<br> 2） 创建一个BlueExceptionTest类，提供一个静态方法test。这个方法抛出BlueException<br> 3） 在BlueExceptionTest创建一个main方法，并在mai方法中调用test方法使用try-catch处理这个方法产生的异常。将异常信息打印到控制台上</strong></p> 
<p style="margin-left:0;">答案：</p> 
<p style="margin-left:0;">class BlueException extends Exception{<!-- --><br>  public BlueException(String message) {<!-- --><br>   super(message);<br>  }<br> }<br> class BlueExceptionTest{<!-- --><br>  public static void test() throws BlueException{<!-- --><br>  }<br>  public static void main(String[] args) {<!-- --><br>   try{<!-- --><br>    test();<br>   }catch(BlueException e){<!-- --><br>    System.out.println(e.getMessage());<br>   }<br>  }<br> }</p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;"><strong>153、<br> 运行时异常可以使用try…catch语句对异常进行捕获或者使用throws关键字声明抛出异常。</strong></p> 
<p style="margin-left:0;">答案： 正确<br> 解析：运行时异常的特点是Java编译器不会对其进行检查。但是，如果你使用try…catch语句对异常进行捕获或者使用throws关键字声明抛出异常也是没有问题的。</p> 
<p style="margin-left:0;"><strong>154、<br> 自定义异常需要继承【】类。</strong></p> 
<p style="margin-left:0;">答案：</p> 
<p style="margin-left:0;">Exception</p> 
<p style="margin-left:0;">；<br> 解析：Exception，所有异常超类。</p> 
<p style="margin-left:0;"><strong>155、</strong></p> 
<p style="margin-left:0;"><strong>如果一个方法要抛出多个异常，可以使用throws进行声明。</strong></p> 
<p style="margin-left:0;">答案： 正确<br> 解析：一个方法中可以抛出多个异常，可以使用throws关键字，并且每个异常之间用逗号隔开。</p> 
<p style="margin-left:0;"><strong>156、<br> 在Java中，针对类、成员方法和属性提供了四种访问级别，分别是private、static、protected和public。</strong></p> 
<p style="margin-left:0;">答案： 正确<br> 解析：在Java中，针对类、成员方法和属性提供了四种访问级别，分别是private、default、protected和public。</p> 
<p style="margin-left:0;"><strong>157、<br> 运行时异常的特点是Java编译器【】（会/不会？）对其进行检查。</strong></p> 
<p style="margin-left:0;">答案：</p> 
<p style="margin-left:0;">不会</p> 
<p style="margin-left:0;">；<br> 解析：运行时异常的特点是Java编译器不会对其进行检查，也就是说，当程序中出现这类异常时，即使没有使用try..catch语句捕获或使用throws关键字声明抛出，程序也能编译通过。</p> 
<p style="margin-left:0;"><strong>158、<br> 下列异常声明中，正确的是（  ）</strong></p> 
<p style="margin-left:0;">A、 publicvoidthrowsIOExceptionfun(){}</p> 
<p style="margin-left:0;">B、 publicvoidfunthrowsIOException(){}</p> 
<p style="margin-left:0;">C、 publicvoidfun()throwsIOException{}</p> 
<p style="margin-left:0;">D、 publicvoidfun()throwsIOException,throwsSQLException{}</p> 
<p style="margin-left:0;">答案： C<br> 解析：throws关键字需要写在方法声明的后面，throws后面需要声明方法中发生异常的类型，通常将这种做法称为方法声明抛出一个异常。</p> 
<p style="margin-left:0;"><strong>159、<br> throws声明在一个方法上，说明这个方法一定会抛出异常。</strong></p> 
<p style="margin-left:0;">答案： 错误<br> 解析：throws声明在一个方法上，不能说明这个方法一定会抛出异常。</p> 
<p style="margin-left:0;"><strong>160、<br> 自定义的异常类必须继承自Exception或其子类。</strong></p> 
<p style="margin-left:0;">答案： 正确</p> 
<p style="margin-left:0;"><strong>161、<br> java中，方法上如果可能抛出多个异常，多个异常可以使用【】（中文填写）隔开。</strong></p> 
<p style="margin-left:0;">答案：</p> 
<p style="margin-left:0;">逗号</p> 
<p style="margin-left:0;">；<br> 解析：方法上如果可能抛出多个异常。多个异常可以使用逗号隔开。</p> 
<p style="margin-left:0;"><strong>162、<br> 关键字【】通常被应用在声明方法时，用来指定可能抛出的异常。</strong></p> 
<p style="margin-left:0;">答案：</p> 
<p style="margin-left:0;">throws</p> 
<p style="margin-left:0;">；<br> 解析：throws通常被应用在声明方法时，用来指定可能抛出的异常。</p> 
<p style="margin-left:0;"><strong>163、<br> 以下对于try…catch语句描述正确的是（  ）</strong></p> 
<p style="margin-left:0;">A、 try…catch语句处理程序中的错误</p> 
<p style="margin-left:0;">B、 try...catch语句处理程序中的bug</p> 
<p style="margin-left:0;">C、 try...catch语句处理程序中的异常</p> 
<p style="margin-left:0;">D、 以上说法都不正确</p> 
<p style="margin-left:0;">答案： C<br> 解析：try...catch语句处理程序中的异常。</p> 
<p style="margin-left:0;"><strong>164、<br> Object是所有类的父类。</strong></p> 
<p style="margin-left:0;">答案： 正确<br> 解析：Object是所有类的父类。</p> 
<p style="margin-left:0;"><strong>165、<br> Object类中的toString()方法用于返回对象的字符串表示形式。</strong></p> 
<p style="margin-left:0;">答案： 正确<br> 解析：toString()方法返回对象的字符串表示形式。</p> 
<p style="margin-left:0;"><strong>166、<br> 下列关于匿名内部类的描述，错误的是（    ）</strong></p> 
<p style="margin-left:0;">A、 匿名内部类是内部类的简化形式</p> 
<p style="margin-left:0;">B、 匿名内部类的前提是必须要继承父类或实现接口</p> 
<p style="margin-left:0;">C、 匿名内部类的格式是"new父类(参数列表)或父接口(){}"</p> 
<p style="margin-left:0;">D、 匿名内部类可以有构造方法</p> 
<p style="margin-left:0;">答案： D<br> 解析：匿名内部类不能有构造方法，它连类名都没有。</p> 
<p style="margin-left:0;"><strong>167、<br> 阅读下面的程序，分析代码是否能够编译通过，如果能编译通过，请列出运行的结果。否则请说明编译失败的原因。<br> public class Demo {<!-- --><br>  public static void main(String[] args) {<!-- --><br>   String name=new Father("tom"){<!-- --><br>   }.getName();<br>   System.out.println(name);<br>  }<br> }<br> class Father {<!-- --><br>  private String name;<br>  public String getName() {<!-- --><br>   return name;<br>  }<br>  public void setName(String name) {<!-- --><br>   this.name = name;<br>  }<br>  public Father(String name) {<!-- --><br>   this.name = name;<br>  }<br> }</strong></p> 
<p style="margin-left:0;">答案：</p> 
<p style="margin-left:0;">tom</p> 
<p style="margin-left:0;"><br> 解析：匿名内部类继承了Father类，并自动继承了父类中的普通方法，其中包括setName()和getName()方法，匿名内部类并未对父类继承的方法进行重写，因此在调用getName()方法时打印输出了tom。</p> 
<p style="margin-left:0;"><strong>168、<br> Object类的构造方法第一行是super()语句。</strong></p> 
<p style="margin-left:0;">答案： 错误<br> 解析：Object没有父类，构造方法第一行不是super。</p> 
<p style="margin-left:0;"><strong>169、<br> 任何类都可以写成匿名内部类的形式。</strong></p> 
<p style="margin-left:0;">答案： 错误<br> 解析：final类不可以被继承。</p> 
<p style="margin-left:0;"><strong>170、<br> 下列程序运行结果是（  ）<br> public class Demo {<!-- --><br>  public static void main(String[] args) {<!-- --><br>   Object obj=new Father(){<!-- --><br>    public void show(){<!-- --><br>     System.out.println("helloworld");<br>    }<br>   };<br>   obj.show();<br>  }<br> }<br> class Father{<!-- --><br>  public void show(){<!-- --><br>   System.out.println("hello father");<br>  }<br> }</strong></p> 
<p style="margin-left:0;">A、 hellofather</p> 
<p style="margin-left:0;">B、 helloworld</p> 
<p style="margin-left:0;">C、 无结果</p> 
<p style="margin-left:0;">D、 程序编译报错</p> 
<p style="margin-left:0;">答案： D<br> 解析：父类引用不能调用子类的特有的方法。</p> 
<p style="margin-left:0;"><strong>171、<br> Java中所有的类都是通过直接或间接地继承（   ）类得到的。</strong></p> 
<p style="margin-left:0;">A、 java.lang.Object</p> 
<p style="margin-left:0;">B、 java.lang.Class</p> 
<p style="margin-left:0;">C、 任意类</p> 
<p style="margin-left:0;">D、 以上答案都不对</p> 
<p style="margin-left:0;">答案： A<br> 解析：Object是所有类的父类。</p> 
<p style="margin-left:0;"><strong>172、<br> 阅读下段代码，<br> class Dog<br> {<!-- --><br>  public String name;<br>  Dog(String name){<!-- --><br>       this.name =name; <br>  }<br> }<br> public class Demo1<br> {<!-- --><br>  public static void main(String[] args){<!-- --><br>       Dog dog1 = new Dog("xiaohuang");<br>    Dog dog2 = new Dog("xiaohuang");<br>         String s1 = dog1.toString();<br>    String s2 = dog2.toString();<br>    String s3 = "xiaohuang";<br>    String s4 = "xiaohuang";<br>  }<br> }<br> 返回值为true的是（   ）</strong></p> 
<p style="margin-left:0;">A、 dog1.equals(dog2)</p> 
<p style="margin-left:0;">B、 s1.equals(s2)</p> 
<p style="margin-left:0;">C、 s3.equals(s4)</p> 
<p style="margin-left:0;">D、 dog1==dog2</p> 
<p style="margin-left:0;">答案： C<br> 解析：选项A比较的是两个对象的地址，结果为false，选项B比较的是dog1和dog2对象的to String()值，结果为false，选项C，比较的是内容，内容相同，所以为true，选项D比较的是dog1和dog2对象的地址，结果为false。</p> 
<p style="margin-left:0;"><strong>173、<br> 阅读下列的程序<br> public class Example {<!-- --><br>  public static void main(String[] args) {<!-- --><br>   new Father () {<!-- --><br>    public void show() {<!-- --><br>     System.out.println("helloworld");<br>    }<br>   }.show();<br>  }<br> }<br> class Father {<!-- --><br>  public void show() {<!-- --><br>   System.out.println("hellofather");<br>  }<br> }<br> 下列选项中，程序的运行结果是（    ）</strong></p> 
<p style="margin-left:0;">A、 hellofather</p> 
<p style="margin-left:0;">B、 helloworld</p> 
<p style="margin-left:0;">C、 编译报错</p> 
<p style="margin-left:0;">D、 编译通过，运行报错</p> 
<p style="margin-left:0;">答案： B<br> 解析：匿名内部类对Father类中的show()方法进行了重写，程序调用的是匿名内部类中的show()方法。</p> 
<p style="margin-left:0;"><strong>174、<br> try…catch语句，catch部分可以独立存在。</strong></p> 
<p style="margin-left:0;">答案： 错误<br> 解析：catch必须跟随try一起使用,不能独立存在。</p> 
<p style="margin-left:0;"><strong>175、<br> 阅读下面的程序，分析代码是否能够编译通过，如果能编译通过，请列出运行的结果。否则请说明编译失败的原因。<br> public class Demo {<!-- --><br>  public static void main(String[] args) {<!-- --><br>   new Object(){<!-- --><br>    public void show(){<!-- --><br>     System.out.println("helloworld");<br>    }<br>   }.show();<br>  }<br> }</strong></p> 
<p style="margin-left:0;">答案：</p> 
<p style="margin-left:0;">helloworld</p> 
<p style="margin-left:0;"><br> 解析：匿名内部类继承了Object类，并自定义了一个show()方法，<br>  * 使用匿名内部类调用show()方法，调用的是子类也就是匿名内部类自身的show()方法，<br>  * 编译和运行均能正常进行，因此打印输出了helloworld。</p> 
<p style="margin-left:0;"><strong>176、<br> 阅读下面的程序，分析代码是否能够编译通过，如果能编译通过，请列出运行的结果。否则请说明编译失败的原因。<br> public class Demo {<!-- --><br>  public static void main(String[] args) {<!-- --><br>   Base b1=Base.getBaseInstance1();<br>   System.out.print(b1.getS());<br>   Base b2=Base.getBaseInstance2();<br>   System.out.print(b2.getS());<br>  }<br> }<br> abstract class Base {<!-- --><br>  private static String s = "base";<br>  public static Base getBaseInstance1() {<!-- --><br>   return new Base() {<!-- --><br>    public String getS() {<!-- --><br>     return s;<br>    }<br>   };<br>  }<br>  public static Base getBaseInstance2() {<!-- --><br>   return new Base("good") {<!-- --><br>    public String getS() {<!-- --><br>     return s;<br>    }<br>   };<br>  }<br>  public Base() {<!-- --><br>  }<br>  public Base(String s) {<!-- --><br>   this.s = s;<br>  }<br>  public abstract String getS();<br> }</strong></p> 
<p style="margin-left:0;">答案：</p> 
<p style="margin-left:0;">basegood</p> 
<p style="margin-left:0;"><br> 解析：当程序执行getBaseInstance1()方法时，调用Base的空构造函数，s值不变，然后调用b1的getS()方法时，输出默认值base；当程序执行getBaseInstance2()方法时，调用了Base的有参构造函数，s重新赋值为good，然后调用b2的getS()方法时，输出修改后的值good；因此输出结果为 base good。</p> 
<p style="margin-left:0;"><strong>177、<br> 匿名内部类就是一个没有类名的内部类。</strong></p> 
<p style="margin-left:0;">答案： 正确<br> 解析：java的匿名内部类，当我们只需要创建一个类的对象而且用不上它的名字时，使用内部类可以使代码看上去简洁清楚。</p> 
<p style="margin-left:0;"><strong>178、</strong></p> 
<p style="margin-left:0;"><strong>下列程序运行结果是（  ）<br> public class Demo {<!-- --><br>  public static void main(String[] args) {<!-- --><br>   Demo demo = new Demo();<br>   demo.show(new Car() {<!-- --><br>    public void run() {<!-- --><br>     System.out.println("demo run");<br>    }<br>   });<br>  }<br>  public void show(Car c) {<!-- --><br>   c.run();<br>  }<br> }<br> abstract class Car {<!-- --><br>  public void run() {<!-- --><br>   System.out.println("car run...");<br>  }<br> }</strong></p> 
<ul><li><strong>A</strong><strong>、</strong></li><li></ul> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;">A、 car run...</p> 
<p style="margin-left:0;">B、 demo run</p> 
<p style="margin-left:0;">C、 无结果</p> 
<p style="margin-left:0;">D、 程序编译报错</p> 
<p style="margin-left:0;">答案： B<br> 解析：使用在show()方法中传入匿名内部类对象，匿名内部类中重写了父类Car中run()方法。</p> 
<p style="margin-left:0;"><strong>179、<br> 下列关于对象的类型转换的描述，说法错误的是（    ）</strong></p> 
<p style="margin-left:0;">A、 对象的类型转换可通过自动转换或强制转换进行</p> 
<p style="margin-left:0;">B、 无继承关系的两个类的对象之间试图转换会出现编译错误</p> 
<p style="margin-left:0;">C、 由new语句创建的父类对象可以强制转换为子类的对象</p> 
<p style="margin-left:0;">D、 子类的对象转换为父类类型后，父类对象不能调用子类的特有方法</p> 
<p style="margin-left:0;">答案： C<br> 解析：由new语句创建的父类对象不能转换为子类的对象，否则会报编译出错。</p> 
<p style="margin-left:0;"><strong>180、<br> 下列选项中，哪一个类是Object的子类（）</strong></p> 
<p style="margin-left:0;">A、 public final class String{}</p> 
<p style="margin-left:0;">B、 ﻿public class Person{}</p> 
<p style="margin-left:0;">C、 public abstrac tAnimal{}</p> 
<p style="margin-left:0;">D、 以上三个类都是Object子类</p> 
<p style="margin-left:0;">答案： D<br> 解析：所有类都是Object子类。</p> 
<p style="margin-left:0;"><strong>181、<br> 以下关于抽象类的描述中，正确的是（）</strong></p> 
<p style="margin-left:0;">A、 抽象类是对一系列看上去不同，但本质上相同的具体概念的抽象</p> 
<p style="margin-left:0;">B、 当一个类中包含了抽象方法，该类必须使用abstract关键字来修饰</p> 
<p style="margin-left:0;">C、 抽象类可以不定义抽象方法</p> 
<p style="margin-left:0;">D、 抽象类不能被实例化</p> 
<p style="margin-left:0;">答案： ABCD<br> 解析：在定义抽象类时需要注意，包含抽象方法的类必须声明为抽象类，但抽象类可以不包含任何抽象方法，只需使用abstract关键字来修饰即可，另外，抽象类是不可以被实例化。</p> 
<p style="margin-left:0;"><strong>182、</strong></p> 
<p style="margin-left:0;"><strong>接口中只能定义常量和抽象方法。</strong></p> 
<ul><li><strong>对</strong></li><li><strong>错</strong></li><li></ul> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;">答案： 正确<br> 解析：接口中只能定义常量和抽象方法。</p> 
<p style="margin-left:0;"><strong>183、<br> instanceof关键字可以用于判断一个对象是否为某个类(或接口)的实例或者子类实例。</strong></p> 
<p style="margin-left:0;">答案： 正确<br> 解析：instanceof关键字可以用于判断一个对象是否为某个类(或接口)的实例或者子类实例。</p> 
<p style="margin-left:0;"><strong>184、<br> 下列选项中，关于final修饰成员变量的说法正确的是（    ）</strong></p> 
<p style="margin-left:0;">A、 被final修饰的成员变量可以被多次赋值</p> 
<p style="margin-left:0;">B、 被final修饰的成员变量为常量</p> 
<p style="margin-left:0;">C、 final只能在接口中修饰成员变量</p> 
<p style="margin-left:0;">D、 以上都不对</p> 
<p style="margin-left:0;">答案： B<br> 解析：被final修饰的变量为常量，不能被第二次赋值或改变引用。</p> 
<p style="margin-left:0;"><strong>185、<br> 抽象方法必须定义在抽象类中，所以抽象类中的方法都是抽象方法。</strong></p> 
<p style="margin-left:0;">答案： 错误<br> 解析：抽象类中可以没有抽象方法。</p> 
<p style="margin-left:0;"><strong>186、<br> 请阅读下面的程序，写出最终的结果：<br> interface Inter {<!-- --><br>  public void show();<br> }<br> abstract class AbstractInter implements Inter {<!-- --><br>  public void show() {<!-- --><br>   System.out.println("AbstractInter show()");<br>  }<br> }<br> class InterImpl extends AbstractInter {<!-- --><br>  public void show() {<!-- --><br>   System.out.println("InterImpl show()");<br>  }<br> }<br> public class InterImplTest {<!-- --><br>  public static void main(String[] args) {<!-- --><br>   InterImpl i = new InterImpl();<br>   i. show();<br>  }<br> }</strong></p> 
<p style="margin-left:0;">答案：</p> 
<p style="margin-left:0;">InterImpl show()</p> 
<p style="margin-left:0;"><br> 解析：创建具体类的对象，最终调用的也是具体类中的方法。</p> 
<p style="margin-left:0;"><strong>187、<br> 下面哪个修饰符不可以修饰接口中的成员变量（）</strong></p> 
<p style="margin-left:0;">A、 public</p> 
<p style="margin-left:0;">B、 static</p> 
<p style="margin-left:0;">C、 final</p> 
<p style="margin-left:0;">D、 private</p> 
<p style="margin-left:0;">答案： D<br> 解析：接口中的成员变量其实是一个常量，用public static final修饰，所以，用private修饰是错误的。</p> 
<p style="margin-left:0;"><strong>188、<br> 定义一个抽象类的关键字是【】。</strong></p> 
<p style="margin-left:0;">答案：</p> 
<p style="margin-left:0;">abstract</p> 
<p style="margin-left:0;">；<br> 解析：Abstract是定义抽象类的固定修饰符。</p> 
<p style="margin-left:0;"><strong>189、<br> 阅读下列的程序，并在程序空白处补充空缺的代码，以实现程序依次输出、执行B类的和c类的方法。<br> public class Demo{<!-- --><br>  public static void main(String[] args) {<!-- --><br>    A a1= ____;  <br>    a1.fun();<br>    <br>    A a2= ____;  <br>    a2.fun();<br>  }<br> }<br> abstract class A{<!-- --><br>  public abstract void fun();<br> }<br> class B extends A{<!-- --><br>  public void fun() {<!-- --><br>   System.out.println("执行B类的方法");<br>  }<br> }<br> class C extends A{<!-- --><br>  public void fun() {<!-- --><br>   System.out.println("执行c类的方法");<br>  }<br> }</strong></p> 
<p style="margin-left:0;">答案：</p> 
<p style="margin-left:0;">new B()   new C()</p> 
<p style="margin-left:0;"><br> 解析：多态中子类可以强制转换为父类，编译时看父类有没有对应的属性和方法，运行时调用子类的属性或方法（静态的方法子类不能复写）。</p> 
<p style="margin-left:0;"><strong>190、<br> 当一个类实现接口时，必须实现接口中的所有方法。</strong></p> 
<p style="margin-left:0;">答案： 正确<br> 解析：当一个类实现接口时，如果这个类是抽象类，则实现接口中的部分方法即可，否则需要实现接口中的所有方法。</p> 
<p style="margin-left:0;"><strong>191、<br> 接口可以实例化对象。</strong></p> 
<p style="margin-left:0;">答案： 错误<br> 解析：接口中的方法都是抽象的，不能实例化对象。</p> 
<p style="margin-left:0;"><strong>192、<br> Java提供了一个关键字【】，可以判断一个对象是否为某个类(或接口)的实例或者子类实例。</strong></p> 
<p style="margin-left:0;">答案：</p> 
<p style="margin-left:0;">instanceof</p> 
<p style="margin-left:0;">；<br> 解析：Java提供了一个关键字instanceof，它可以判断一个对象是否为某个类(或接口)的实例或者子类实例。</p> 
<p style="margin-left:0;"><strong>193、<br> 在Java中一个接口可以继承多个接口，继承的接口之间使用【】隔开即可。</strong></p> 
<p style="margin-left:0;">答案：</p> 
<p style="margin-left:0;">逗号</p> 
<p style="margin-left:0;">；<br> 解析：在Java中，一个接口可以通过extends关键字继承多个接口，接口之间只需用逗号隔开即可。</p> 
<p style="margin-left:0;"><strong>194、<br> 被final修饰的成员变量不能被继承。</strong></p> 
<p style="margin-left:0;">答案： 错误<br> 解析：被final修饰的变量可以被继承，被final修饰的类不能被继承。</p> 
<p style="margin-left:0;"><strong>195、<br> 抽象类中不一定有抽象函数，但抽象函数一定在抽象类中。</strong></p> 
<p style="margin-left:0;">答案： 正确<br> 解析：在定义抽象类时需要注意，包含抽象方法的类必须声明为抽象类，但抽象类可以不包含任何抽象方法。</p> 
<p style="margin-left:0;"><strong>196、<br> 下列关于对象间类型转换的描述中，正确的是（  ）</strong></p> 
<p style="margin-left:0;">A、 类型转换的前提是存在继承关系</p> 
<p style="margin-left:0;">B、 强制类型转换可以实现对象间的类型转换。</p> 
<p style="margin-left:0;">C、 对象之间的类型转换是多态的一种体现</p> 
<p style="margin-left:0;">D、 对象之间的类型转换可以降低代码的耦合度</p> 
<p style="margin-left:0;">答案： ACD<br> 解析：类型转换的定义和作用。</p> 
<p style="margin-left:0;"><strong>197、<br> 子类和父类对象在进行类型转换时，子类对象可以被视为父类的一个对象，父类对象不能被当作是某一个子类的对象。</strong></p> 
<p style="margin-left:0;">答案： 正确<br> 解析：子父类的对象进行类型转换时，子类对象可以被视为是其父类的一个对象，父类对象不能被当作是某一个子类的对象。</p> 
<p style="margin-left:0;"><strong>198、<br> 在定义方法时不写方法体，这种不包含方法体的方法为【】方法。</strong></p> 
<p style="margin-left:0;">答案：</p> 
<p style="margin-left:0;">抽象</p> 
<p style="margin-left:0;">；<br> 解析：Java允许在定义方法时不写方法体，不包含方法体的方法为抽象方法，抽象方法必须使用abstract关键字来修饰。</p> 
<p style="margin-left:0;"><strong>199、<br> 一个具体类实现接口时，需要重写接口中的（）</strong></p> 
<p style="margin-left:0;">A、 成员变量</p> 
<p style="margin-left:0;">B、 局部变量</p> 
<p style="margin-left:0;">C、 成员方法</p> 
<p style="margin-left:0;">D、 构造方法</p> 
<p style="margin-left:0;">答案： C<br> 解析：接口中只有常量和抽象方法，所以类实现接口，要重写接口中的抽象方法也就是成员方法。</p> 
<p style="margin-left:0;"><strong>200、</strong></p> 
<p style="margin-left:0;"><strong>如果一个类继承了一个抽象类，但是没有完全复写父类的所有的抽象方法那么这个类也必须是抽象类。</strong></p> 
<ul><li></ul> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;">答案： 正确<br> 解析：抽象方法是没有方法体的，不可以被调用，如果想调用抽象类中定义的方法，则需要创建一个子类，在子类中将抽象类中的抽象方法进行实现。</p> 
<p style="margin-left:0;"><strong>201、<br> 一个类如果要实现一个接口，可以通过关键字【】来实现这个接口。</strong></p> 
<p style="margin-left:0;">答案：</p> 
<p style="margin-left:0;">implements</p> 
<p style="margin-left:0;">；<br> 解析：接口中的方法都是抽象方法，我们可以定义一个类，并使用implements关键字实现接口中所有的方法。</p> 
<p style="margin-left:0;"><strong>202、</strong></p> 
<p style="margin-left:0;"><strong>有如下三个类<br> class A<br> {...}<br> class B extends A<br> {...}<br> class C extends A<br> {...}<br> 因为 B类和C类不存在继承关系 ，因此他们之间不能进行类型转换。</strong></p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;">答案： 正确<br> 解析：不存在继承关系的对象之间不能进行类型转换。</p> 
<p style="margin-left:0;"><strong>203、<br> 阅读下面的程序，分析代码是否能够编译通过，如果能编译通过，请列出运行的结果，否则请说明编译失败的原因。<br> public class Demo {<!-- --><br>  public static void main(String[] args) {<!-- --><br>   Father f=new Son();<br>  f.show();<br>  }<br> }<br> class Father{<!-- --><br>  public void show(){<!-- --><br>   System.out.print("father show");<br>  }<br> }<br> class Son extends Father{<!-- --><br>  public void show(){<!-- --><br>   super.show();<br>   System.out.print("son show");<br>  }<br> }</strong></p> 
<p style="margin-left:0;">答案：</p> 
<p style="margin-left:0;">father showson show</p> 
<p style="margin-left:0;"><br> 解析：在main()方法中，创建Son类的对象，并将其父类也就是Father类的引用指向了该对象，在调用show()方法时，其实调用的是子类的show()方法，子类的show()方法中又通过super关键字调用了父类的show()方法，因此程序先输出了"father show"，接着输出了"son show"。</p> 
<p style="margin-left:0;"><strong>204、<br> 对于使用多态的应用程序，某个对象的确切类型何时能知道（    ）</strong></p> 
<p style="margin-left:0;">A、 执行时才可以知道</p> 
<p style="margin-left:0;">B、 应用程序编译时能够判断</p> 
<p style="margin-left:0;">C、 程序员编写程序时就已知道</p> 
<p style="margin-left:0;">D、 永远不会知道</p> 
<p style="margin-left:0;">答案： B<br> 解析：如果对象的类型转换错误，那么应用程序编译时能够判断，以此得出答案选B。</p> 
<p style="margin-left:0;"><strong>205、<br> 抽象类实现接口时，可以不实现接口中的任何方法。</strong></p> 
<p style="margin-left:0;">答案： 正确<br> 解析：当一个类实现接口时，如果这个类是抽象类，则实现接口中的部分方法即可(其实也可以不实现)，否则需要实现接口中的所有方法。</p> 
<p style="margin-left:0;"><strong>206、<br> 下列关于接口的说法中，错误的是（    ）</strong></p> 
<p style="margin-left:0;">A、 接口中定义的方法默认使用“publicabstract”来修饰</p> 
<p style="margin-left:0;">B、 接口中的变量默认使用“publicstaticfinal”来修饰</p> 
<p style="margin-left:0;">C、 接口中的所有方法都是抽象方法</p> 
<p style="margin-left:0;">D、 接口中定义的变量可以被修改</p> 
<p style="margin-left:0;">答案： D<br> 解析：接口中定义的变量是常量，不能被修改。</p> 
<p style="margin-left:0;"><strong>207、<br> 抽象类中的方法只能定义成抽象的方法。</strong></p> 
<p style="margin-left:0;">答案： 错误<br> 解析：抽象类可以不包含任何抽象方法。</p> 
<p style="margin-left:0;"><strong>208、<br> 下列选项中，不可以被final修饰的是（    ）</strong></p> 
<p style="margin-left:0;">A、 接口</p> 
<p style="margin-left:0;">B、 类</p> 
<p style="margin-left:0;">C、 方法</p> 
<p style="margin-left:0;">D、 变量</p> 
<p style="margin-left:0;">答案： A<br> 解析：final关键字可用于修饰类、变量和方法。</p> 
<p style="margin-left:0;"><strong>209、<br> 阅读下面的程序，在不new Cat类的情况下,添加代码运行Demo的mian方法后执行Cat的eat()方法。<br> public class Demo {<!-- --><br>  public static void main(String[] args) {<!-- --><br>   Animal animal = new Cat();<br>   ________；<br>   cat.eat();<br>  }<br> }<br> class Animal{<!-- --><br>  public void eat(){<!-- --><br>   System.out.println("animal eat");<br>  }<br> }<br> class Cat extends Animal{<!-- --><br>  public void eat(){<!-- --><br>   System.out.println("cat eat");<br>  }<br> }</strong></p> 
<p style="margin-left:0;">答案：</p> 
<p style="margin-left:0;">Cat cat = (Cat)animal;</p> 
<p style="margin-left:0;">；<br> 解析：由子类对象转化得到的父类对象可以强制转换为同类型的子类对象。</p> 
<p style="margin-left:0;"><strong>210、<br> 父类的引用指向自己子类的对象是多态的一种体现形式。</strong></p> 
<p style="margin-left:0;">答案： 正确<br> 解析：在Java中为了实现多态，允许使用一个父类类型的变量来引用一个子类类型的对象，根据被引用子类对象特征的不同，得到不同的运行结果。</p> 
<p style="margin-left:0;"><strong>211、<br> 下列关于对象间类型转换的说法中，正确的是（  ）</strong></p> 
<p style="margin-left:0;">A、 与基本数据类型的相互转换一样，对象的类型转换可通过自动转换或强制转换进行</p> 
<p style="margin-left:0;">B、 无继承关系的两个类的对象之间试图转换时出现编译错误</p> 
<p style="margin-left:0;">C、 有继承关系的两个类的对象之间，子类的对象转换为父类的对象，可自动转换也可以强制转换</p> 
<p style="margin-left:0;">D、 由new语句创建的父类对象不能转换为子类的对象</p> 
<p style="margin-left:0;">答案： ABCD</p> 
<p style="margin-left:0;"><strong>212、</strong></p> 
<p style="margin-left:0;"><strong>如果一个方法的形式参数定义的是父类对象,那么调用这个方法时,可以使用子类对象作为实际参数。</strong></p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;">答案： 正确<br> 解析：如果一个方法的形式参数定义的是父类对象,那么调用这个方法时,可以使用子类对象作为实际参数。</p> 
<p style="margin-left:0;"><strong>213、<br> 我们可以使用final关键字修饰抽象方法。</strong></p> 
<p style="margin-left:0;">答案： 错误<br> 解析：final关键字和abstract关键字不能一起使用。</p> 
<p style="margin-left:0;"><strong>214、<br> final修饰符不可以修饰如下哪个内容（）</strong></p> 
<p style="margin-left:0;">A、 类</p> 
<p style="margin-left:0;">B、 接口</p> 
<p style="margin-left:0;">C、 方法</p> 
<p style="margin-left:0;">D、 变量</p> 
<p style="margin-left:0;">答案： B<br> 解析：final关键字可用于修饰类、变量和方法。</p> 
<p style="margin-left:0;"><strong>215、<br> final即可以修饰局部变量也可以修饰成员变量。</strong></p> 
<p style="margin-left:0;">答案： 正确<br> 解析：Final即可以修饰成员变量也可以修饰局部变量。</p> 
<p style="margin-left:0;"><strong>216、<br> 下列选项中，可以被final修饰符修饰的是（）</strong></p> 
<p style="margin-left:0;">A、 抽象方法</p> 
<p style="margin-left:0;">B、 局部变量</p> 
<p style="margin-left:0;">C、 接口</p> 
<p style="margin-left:0;">D、 抽象类</p> 
<p style="margin-left:0;">答案： B<br> 解析：final关键字一般用于修饰类、变量和方法。还可以修饰局部变量。但不能与abstract修饰符一起使用，而且不能用于接口中。</p> 
<p style="margin-left:0;"><strong>217、<br> 请阅读下面的程序，写出运行结果，如果编译失败，写明失败原因。<br> abstract class Animal{<!-- --><br>    public final abstract void eat();<br> }<br> class Cat extends Animal{<!-- --><br>    public void eat(){<!-- --><br>         System.out.println("cat...fish");<br>    }<br> }<br> class CatDemo{<!-- --><br>    public static void main(String[] args){<!-- --><br>        Animal a = new Cat();<br>        a.eat();<br>    }<br> }</strong></p> 
<p style="margin-left:0;">答案：</p> 
<p style="margin-left:0;">编译失败","非法修饰符组合。</p> 
<p style="margin-left:0;"><br> 解析：abstract和 final关键字不能共用。abstract方法需要子类重写，final修饰后不能重写，编译失败。</p> 
<p style="margin-left:0;"><strong>218、<br> final修饰的成员变量初始化赋值有两种方式,第一显示初始化赋值,第二【】初始化赋值。</strong></p> 
<p style="margin-left:0;">答案：</p> 
<p style="margin-left:0;">构造函数</p> 
<p style="margin-left:0;">；<br> 解析：final修饰的成员变量初始化赋值有两种方式,第一显示初始化赋值,第二构造函数初始化赋值。</p> 
<p style="margin-left:0;"><strong>219、<br> 关于final修饰成员变量说法正确的是（）</strong></p> 
<p style="margin-left:0;">A、 被final修饰的成员变量为常量</p> 
<p style="margin-left:0;">B、 被final修饰的成员变量不能被继承</p> 
<p style="margin-left:0;">C、 被final修饰的成员变量可以被多次赋值</p> 
<p style="margin-left:0;">D、 final只能在接口中修饰成员变量</p> 
<p style="margin-left:0;">答案： A<br> 解析：被final修饰的变量可以被继承，被final修饰的类不能被继承，被final修饰的变量为常量不能被第二次赋值或改变引用。</p> 
<p style="margin-left:0;"><strong>220、<br> final修饰符修饰方法时，不能和以下哪个修饰符共用（）</strong></p> 
<p style="margin-left:0;">A、 public</p> 
<p style="margin-left:0;">B、 static</p> 
<p style="margin-left:0;">C、 abstract</p> 
<p style="margin-left:0;">D、 synchronized</p> 
<p style="margin-left:0;">答案： C<br> 解析：final修饰符不能和abstract修饰符一起使用。</p> 
<p style="margin-left:0;"><strong>221、<br> Java中的类被final关键字修饰后，该类将不可以被继承。</strong></p> 
<p style="margin-left:0;">答案： 正确<br> 解析：Java中的类被final关键字修饰后，该类将不可以被继承，也就是不能够派生子类。</p> 
<p style="margin-left:0;"><strong>222、<br> final修饰的方法，不能被子类【】。</strong></p> 
<p style="margin-left:0;">答案：</p> 
<p style="margin-left:0;">重写</p> 
<p style="margin-left:0;">；<br> 解析：final修饰的方法为最终方法，不能被重写。</p> 
<p style="margin-left:0;"><strong>223、<br> 请阅读下面的程序，写出运行结果，若编译失败写出原因。<br> class SubString extends java.lang.String{<!-- --><br>      public boolean equals(Object obj){<!-- --><br>                  return true;<br>      }<br> }<br> class Demo{<!-- --><br>    public static void main(String[] args){<!-- --><br>     SubString s = new SubString();<br>     System.out.println(s.equals("s"));<br> }<br> }</strong></p> 
<p style="margin-left:0;">答案：</p> 
<p style="margin-left:0;">编译失败","String是final修饰类","不能继承。</p> 
<p style="margin-left:0;"><br> 解析：String类被final修饰，不能被继承。</p> 
<p style="margin-left:0;"><strong>224、<br> 【】关键字可用于修饰类、变量和方法，它有“这是无法改变的”或者“最终”的含义。</strong></p> 
<p style="margin-left:0;">答案：</p> 
<p style="margin-left:0;">final</p> 
<p style="margin-left:0;">；<br> 解析：final关键字可用于修饰类、变量和方法，它有“这是无法改变的”或者“最终”的含义。</p> 
<p style="margin-left:0;"><strong>225、<br> 分析下面的程序，输出的结果是？<br> public class Test {<!-- --><br>  public static void main(String[] args) {<!-- --><br>   final Person p = new Person("张三", 23);<br>   p.setName("李四");<br>   p.setAge(24);<br>   System.out.println(p);<br>  }<br> }<br> class Person {<!-- --><br>  private String name;<br>  private int age;<br>  public Person() {<!-- --><br>   super();<br>   }<br>  public Person(String name, int age) {<!-- --><br>   super();<br>   this.name = name;<br>   this.age = age;<br>  }<br>  public String getName() {<!-- --><br>   return name;<br>  }<br>  public void setName(String name) {<!-- --><br>   this.name = name;<br>  }<br>  public int getAge() {<!-- --><br>   return age;<br>  }<br>  public void setAge(int age) {<!-- --><br>   this.age = age;<br>  }<br>  @Override<br>  public String toString() {<!-- --><br>   return "我的姓名是:" + name + ",我的年龄是:" + age ;<br>  }<br> }</strong></p> 
<p style="margin-left:0;">答案：</p> 
<p style="margin-left:0;">我的姓名是:李四","我的年龄是:24</p> 
<p style="margin-left:0;"><br> 解析：final修饰引用数据类型不能改变的是地址值,但是可以改变的是属性。</p> 
<p style="margin-left:0;"><strong>226、<br> final修饰的局部变量只能被赋值【】（大写）次。</strong></p> 
<p style="margin-left:0;">答案：</p> 
<p style="margin-left:0;">一</p> 
<p style="margin-left:0;">；<br> 解析：final最终变量，只能赋值一次。</p> 
<p style="margin-left:0;"><strong>227、<br> 请定义一个由public修饰符修饰的int型成员变量MAX_LENGTH，并使该值保持为常数100，则定义这个变量的语句是（）</strong></p> 
<p style="margin-left:0;">A、 public int MAX_LENGTH=100</p> 
<p style="margin-left:0;">B、 public const int MAX_LENGTH=100</p> 
<p style="margin-left:0;">C、 final int MAX_LENGTH=100</p> 
<p style="margin-left:0;">D、 public final int MAX_LENGTH=100</p> 
<p style="margin-left:0;">答案： D<br> 解析：应题目的要求，需要将该值保持为常数，那么就需要使用关键字final，所以选择D，const是java的保留关键字,在java中使用final定义常量。</p> 
<p style="margin-left:0;"><strong>228、<br> 以下代码的运行结果是<br> public class Temp {<!-- --><br>   public static final StringBuffer buffer = new StringBuffer("中国");<br>   public static void main(String[] args) {<!-- --><br>   Temp.buffer.append("你好");<br>   System.out.println(Temp.buffer);<br>  }<br> }</strong></p> 
<p style="margin-left:0;">答案：</p> 
<p style="margin-left:0;">中国你好</p> 
<p style="margin-left:0;"><br> 解析：final修饰的非基本类型的成员变量其引用不能改变，内容可以改变，所以当我们向buffer对象中增加内容后，内容被正常输出。</p> 
<p style="margin-left:0;"><strong>229、<br> final修饰的静态方法可以被类名直接调用。</strong></p> 
<p style="margin-left:0;">答案： 正确<br> 解析：final修饰静态方法，可以被类名调用。</p> 
<p style="margin-left:0;"><strong>230、<br> final修饰的成员变量可以在构造方法中对其重新赋值。</strong></p> 
<p style="margin-left:0;">答案： 错误<br> 解析：final修饰的成员变量不可以再被重新赋值。</p> 
<p style="margin-left:0;"><strong>231、<br> 定义一个类Demo类， 使该类成为最终类，不能再被继承。</strong></p> 
<p style="margin-left:0;">答案：</p> 
<p style="margin-left:0;">public final class Demo{<!-- --><br> }</p> 
<p style="margin-left:0;"><br> 解析：使用final关键字定义的类为最终类，不能被继承。</p> 
<p style="margin-left:0;"><strong>232、<br> Java中任何类都直接或间接继承了Object类。</strong></p> 
<p style="margin-left:0;">答案： 正确<br> 解析：Java中任何类都直接或间接继承了Object类。</p> 
<p style="margin-left:0;"><strong>233、<br> Java中一个类最多可以继承【】（大写）个类。</strong></p> 
<p style="margin-left:0;">答案：</p> 
<p style="margin-left:0;">一</p> 
<p style="margin-left:0;">；<br> 解析：类的单继承<br> 在Java中，类只支持单继承，不允许多重继承，也就是说一个类只能有一个直接父类，因此Java中一个类最多可以继承一个类。</p> 
<p style="margin-left:0;"><strong>234、<br> 下列选项中，关于类的继承说法正确的是（ ）</strong></p> 
<p style="margin-left:0;">A、 一个类只能有一个直接父类</p> 
<p style="margin-left:0;">B、 多个类可以继承一个父类</p> 
<p style="margin-left:0;">C、 一个类的父类可以再去继承另外的一个类</p> 
<p style="margin-left:0;">D、 一个类可以有多个直接父类</p> 
<p style="margin-left:0;">答案： ABC<br> 解析：一个类只能有一个直接父类，多个类可以继承一个父类，一个类的父类可以再去继承另外的父类。</p> 
<p style="margin-left:0;"><strong>235、<br> 以下关于super关键字的说法中，正确的是（    ）</strong></p> 
<p style="margin-left:0;">A、 super()与this()可以同时存在于同一个构造方法中</p> 
<p style="margin-left:0;">B、 super()与this()不能同时存在于同一个构造方法中</p> 
<p style="margin-left:0;">C、 super关键字可以调用父类的成员方法</p> 
<p style="margin-left:0;">D、 super关键字可以调用父类的构造方法</p> 
<p style="margin-left:0;">答案： BCD<br> 解析：super关键字用于访问父类的成员。例如访问父类的成员变量、成员方法和构造方法。super和this关键字都必须写在第一行的开头不能同时使用在同一个构造方法中。</p> 
<p style="margin-left:0;"><strong>236、<br> 子类重写父类的方法时，重写的方法可以与父类被重写的方法名、参数列表以及返回值类型不相同。</strong></p> 
<p style="margin-left:0;">答案： 错误<br> 解析：在子类中重写的方法需要和父类被重写的方法具有相同的方法名、参数列表以及返回值类型。</p> 
<p style="margin-left:0;"><strong>237、<br> 下列关于super关键字的说法中，正确的是（    ）</strong></p> 
<p style="margin-left:0;">A、 super关键字是在子类对象内部指代其父类对象的引用</p> 
<p style="margin-left:0;">B、 super关键字不仅可以指代子类的直接父类，还可以指代父类的父类</p> 
<p style="margin-left:0;">C、 子类通过super关键字只能调用父类的方法，而不能调用父类的属性</p> 
<p style="margin-left:0;">D、 子类通过super关键字只能调用父类的属性，而不能调用父类的方法</p> 
<p style="margin-left:0;">答案： A<br> 解析：super关键字是在子类对象内部指代其父类对象的引用，通过super关键字既能调用父类的属性，又能调用父类的方法。</p> 
<p style="margin-left:0;"><strong>238、<br> 以下关于继承的描述，说法正确的是（  ）</strong></p> 
<p style="margin-left:0;">A、 子类继承父类的所有属性和方法</p> 
<p style="margin-left:0;">B、 子类可以继承父类的私有的属性和方法</p> 
<p style="margin-left:0;">C、 子类可以继承父类的公有的属性和方法</p> 
<p style="margin-left:0;">D、 创建子类对象时，父类的所有构造方法都会被执行</p> 
<p style="margin-left:0;">答案： C<br> 解析：子类可以继承父类的非私有成员，并且在创建子类时默认会调用父类的无参构造方法。</p> 
<p style="margin-left:0;"><strong>239、<br> final可以在方法中修饰基本数据类型变量,但是不可以修饰引用数据类型变量。</strong></p> 
<p style="margin-left:0;">答案： 错误<br> 解析：final即可以修饰引用数据类型变量,也可以修饰基本数据类型变量。</p> 
<p style="margin-left:0;"><strong>240、<br> 在实例化子类对象时，会自动调用父类无参的构造方法。</strong></p> 
<p style="margin-left:0;">答案： 正确<br> 解析：在子类的构造方法中通过super指定调用父类的哪个构造方法，如果没有指定，在实例化子类对象时，会自动调用父类无参的构造方法。</p> 
<p style="margin-left:0;"><strong>241、<br> 下列选项中，哪个是子类重写父类方法时，必须与父类方法一致的（）</strong></p> 
<p style="margin-left:0;">A、 返回值类型</p> 
<p style="margin-left:0;">B、 修饰符</p> 
<p style="margin-left:0;">C、 函数名</p> 
<p style="margin-left:0;">D、 参数列表</p> 
<p style="margin-left:0;">答案： ACD<br> 解析：子类在重写父类方法时，要求子类方法的返回值类型、函数名和参数列表必须与父类方法一致。</p> 
<p style="margin-left:0;"><strong>242、<br> 下面选项中，哪个关键字可以修饰局部变量（）</strong></p> 
<p style="margin-left:0;">A、 abstract</p> 
<p style="margin-left:0;">B、 final</p> 
<p style="margin-left:0;">C、 static</p> 
<p style="margin-left:0;">D、 private</p> 
<p style="margin-left:0;">答案： B<br> 解析：final可以修饰局部变量。</p> 
<p style="margin-left:0;"><strong>243、<br> 请阅读下面的程序，在空白处填写正确的代码，使Son类的eat方法重写Father的eat方法。<br> public class Father {<!-- --><br>  public void eat(String name){<!-- --><br>   System.out.println(name+"吃番薯");<br>  }<br> }<br> class Son ______________{<!-- --><br>  @Override<br>  public void eat(String name){<!-- --><br>   System.out.println(name+"吃米饭");<br>  }<br> }</strong></p> 
<p style="margin-left:0;">答案：</p> 
<p style="margin-left:0;">extends Father</p> 
<p style="margin-left:0;">；<br> 解析：函数的重写前提是继承。</p> 
<p style="margin-left:0;"><strong>244、<br> 在Java中，子类可以覆盖父类中的任意方法。</strong></p> 
<p style="margin-left:0;">答案： 错误<br> 解析：子类不能覆盖父类的私有方法和final方法。</p> 
<p style="margin-left:0;"><strong>245、<br> super调用父类构造方法的代码必须位于子类构造方法的第一行。</strong></p> 
<p style="margin-left:0;">答案： 正确<br> 解析：通过super调用父类构造方法的代码必须位于子类构造方法的第一行，并且只能出现一次。</p> 
<p style="margin-left:0;"><strong>246、<br> 现有两个类A、B，以下描述中表示B继承自A的是（）</strong></p> 
<p style="margin-left:0;">A、 class A extends B.class</p> 
<p style="margin-left:0;">B、 class B implements A</p> 
<p style="margin-left:0;">C、 class A implements B</p> 
<p style="margin-left:0;">D、 class B extends A</p> 
<p style="margin-left:0;">答案： D<br> 解析：类的继承 关键字 extends<br> 在Java中，类的继承是通过extends关键字表示的，要想描述B继承自A，则正确的写法是class B extends A。</p> 
<p style="margin-left:0;"><strong>247、<br> 以下关于方法重写，说法错误的是（   ）</strong></p> 
<p style="margin-left:0;">A、 方法重写时，子类的函数名与形参列表必须与父类的一致</p> 
<p style="margin-left:0;">B、 方法重写时，子类的返回值类型必须大于或者等于父类的返回值类型</p> 
<p style="margin-left:0;">C、 方法重写时，子类的权限修饰符必须大于或者等于父类的权限修饰符</p> 
<p style="margin-left:0;">D、 方法重写与返回值类型无关</p> 
<p style="margin-left:0;">答案： BD<br> 解析：方法重写时，子类的返回值类型必须小于或者等于父类的返回值类型 。且在子类中重写的方法需要和父类被重写的方法具有相同的方法名、参数列表以及返回值类型。</p> 
<p style="margin-left:0;"><strong>248、</strong></p> 
<p style="margin-left:0;"><strong>方法重写时，子类抛出的异常类型大于等于父类抛出的异常类型。</strong></p> 
<ul><li></ul> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;">答案： 错误<br> 解析：方法重写时，子类抛出的异常类型小于等于父类抛出的异常类型。</p> 
<p style="margin-left:0;"><strong>249、<br> 方法重写的前提是必须存在着继承关系。</strong></p> 
<p style="margin-left:0;">答案： 正确<br> 解析：方法重写的前提是必须存在着继承关系。</p> 
<p style="margin-left:0;"><strong>250、<br> 如果父类的方法是静态的，则子类的方法被（）修饰才能覆盖父类的静态方法 。</strong></p> 
<p style="margin-left:0;">A、 protected</p> 
<p style="margin-left:0;">B、 static</p> 
<p style="margin-left:0;">C、 private</p> 
<p style="margin-left:0;">D、 final</p> 
<p style="margin-left:0;">答案： B<br> 解析：只有子类的方法为静态时才能重写父类的静态方法。</p> 
<p style="margin-left:0;"><strong>251、<br> 函数重写与函数重载的相同之处是（）</strong></p> 
<p style="margin-left:0;">A、 权限修饰符</p> 
<p style="margin-left:0;">B、 函数名</p> 
<p style="margin-left:0;">C、 返回值类型</p> 
<p style="margin-left:0;">D、 形参列表</p> 
<p style="margin-left:0;">答案： B<br> 解析：无论是函数重写还是函数重载都要求函数名要一致。</p> 
<p style="margin-left:0;"><strong>252、<br> class A{<!-- --><br>     String name;<br>     A(){<!-- --><br>         System.out.println("父类默认隐式的构造方法！");<br>     }<br>     A(String name){<!-- --><br>         System.out.println("父类显式的构造方法！");<br>     }<br> }<br> class B extends A{<!-- --><br>     B(){<!-- --><br>         super(null);<br>         System.out.println("子类默认隐式的构造方法！");<br>     }<br><br> }<br> public class Animal {<!-- --><br>     public static void main(String[] args) {<!-- --><br>         new B();<br>     }<br> }</strong></p> 
<p style="margin-left:0;">答案：</p> 
<p style="margin-left:0;">父类显式的构造方法！</p> 
<p style="margin-left:0;">子类默认隐式的构造方法！</p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;"><br> 解析：</p> 
<p style="margin-left:0;">表示父类对象的默认引用</p> 
<p style="margin-left:0;">如果子类要调用父类被覆盖的实例方法，可用super作为调用者调用父类被覆盖的实例方法。</p> 
<p style="margin-left:0;">使用super调用父类方法</p> 
<p style="margin-left:0;">使用super调用父类的构造方法</p> 
<p style="margin-left:0;">调用构造方法</p> 
<p style="margin-left:0;">本类中调用另一个重载构造方法用this(参数列表)</p> 
<p style="margin-left:0;">子类构造方法调用父类构造方法用super(参数列表)</p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;"><strong>253、<br> 下列关于继承的描述中，错误的是（）</strong></p> 
<p style="margin-left:0;">A、 在Java中，类只支持单继承，不允许多重继承，也就是说一个类只能有一个直接父类</p> 
<p style="margin-left:0;">B、 多个类可以继承一个父类</p> 
<p style="margin-left:0;">C、 在Java中，多层继承是可以的，即一个类的父类可以再去继承另外的父类，例如C类继承自B类，而B类又可以去继承A类，这时，C类也可称作A类的子类</p> 
<p style="margin-left:0;">D、 Java是支持多继承的</p> 
<p style="margin-left:0;">答案： D<br> 解析：Java不支持多继承。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/02897e57513db1a7962caa53607a08ac/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">windows安全事件查看及安全事件id汇总</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d561f74046de1fc5459984c98f5ef743/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">SPSS学习3 数据读取、文件横纵合并（零基础）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>