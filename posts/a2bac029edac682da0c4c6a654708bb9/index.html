<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>两个列表的最小索引总和_在最小时间复杂度中找到总和最接近零的对 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="两个列表的最小索引总和_在最小时间复杂度中找到总和最接近零的对" />
<meta property="og:description" content="两个列表的最小索引总和
Problem statement
问题陈述 Given an array with both positive and negative integers. Find the pair whose sum is closest to zero in minimum time complexity.
给定一个既有正整数又有负整数的数组。 找到总和最接近零的最小时间复杂度对。 Description: 描述： Here we are going to see the algorithm with minimum time complexity to find a pair such that their sum is closest to 0.
在这里，我们将看到具有最小时间复杂度的算法，以找到对使得它们的总和最接近0。 Algorithm:
算法： Sort the array.
对数组进行排序。 Maintain two indexes, one at beginning, i, (i=0) &amp; the other at the ending, j, (j=n-1, where n is the array length)." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/a2bac029edac682da0c4c6a654708bb9/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-08-04T13:13:18+08:00" />
<meta property="article:modified_time" content="2020-08-04T13:13:18+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">两个列表的最小索引总和_在最小时间复杂度中找到总和最接近零的对</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div style="font-size: 16px;"> 
 <p>两个列表的最小索引总和</p> 
 <p><b>Problem statement</b></p> 
 <p> <b class="raw_b_node">问题陈述</b> </p> 
 <p>Given an array with both positive and negative integers. Find the pair whose sum is closest to zero in minimum time complexity.</p> 
 <p> 给定一个既有正整数又有负整数的数组。 找到总和最接近零的最小时间复杂度对。 </p> 
 <p><b>Description: </b></p> 
 <p> <b class="raw_b_node">描述：</b> </p> 
 <p>Here we are going to see the algorithm with minimum time complexity to find a pair such that their sum is closest to 0.</p> 
 <p> 在这里，我们将看到具有最小时间复杂度的算法，以找到对使得它们的总和最接近0。 </p> 
 <p><b>Algorithm:</b></p> 
 <p> <b class="raw_b_node">算法：</b> </p> 
 <ol><li><p>Sort the array.</p><p> 对数组进行排序。 </p></li><li><p>Maintain two indexes, one at beginning, <span class="w3-codespan">i</span>, <span class="w3-codespan">(i=0)</span> &amp; the other at the ending, <span class="w3-codespan">j</span>, (<span class="w3-codespan">j=n-1</span>, where <span class="w3-codespan">n</span> is the array length).</p><p> 保持两个索引，一个索引在开头i (i = 0) ，另一个索引在结尾j ( j = n-1 ，其中n是数组长度)。 </p></li><li><p>Maintain two variables <span class="w3-codespan">indexP</span> and <span class="w3-codespan">indexN</span> to keep track of the pairs which sum closest to 0.</p><p> 保持两个变量indexP和indexN来跟踪总和最接近0的对。 </p></li><li><p>Set a variable minsum to <span class="w3-codespan">INT_MAX</span>.</p><p> 将变量minsum设置为INT_MAX 。 </p></li><li><p> While (i&lt;j) </p><p> 而(i &lt;j) </p> 
   <ul><li>If abs(current pair-sum)&lt; abs(minsum)</li><li>If(current pair-sum&gt;0)</li></ul></li><li><p> End loop</p><p> 结束循环 </p></li><li><p><span class="w3-codespan">indexP</span> &amp; <span class="w3-codespan">indexN</span> marks to the pair that sum closest to 0.</p><p> indexP和indexN标记为总和最接近0的对。 </p></li><li><p>Print <span class="w3-codespan">array[indexN]</span> &amp; <span class="w3-codespan">array[indexP]</span>.</p><p> 打印array [indexN]和array [indexP] 。 </p></li></ol> 
 <p><b>Time complexity:</b> O(nlogn) (O(logn) for sorting the array)</p> 
 <p> <b class="raw_b_node">时间复杂度：</b> O(nlogn)(用于数组排序的O(logn)) </p> 
 <p><b>Space complexity:</b> O(1)</p> 
 <p> <b class="raw_b_node">空间复杂度：</b> O(1) </p> 
 <h3> 该算法的C ++实现 <span style="font-weight: bold;">(</span>C++ implementation of the algorithm <span style="font-weight: bold;">)</span></h3> 
 <pre><code class="has">#include&lt;bits/stdc++.h&gt;
using namespace std;

void findpairs(int* a, int n){<!-- -->
	//sort the array using default sort library function, O(logn) generally
	sort(a,a+n);   
	int temp,i=0,j=n-1,minsum=INT_MAX,indexN=i,indexP=j;

	while(i&lt;j){<!-- -->
		// current pair-sum
		temp=a[i]+a[j];  
		//if abs(current pair-sum)&lt;abs(minsum)
		if(abs(temp)&lt;abs(minsum)){<!-- -->      
			minsum=temp;
			indexN=i;
			indexP=j;
		}
		//if current pair-sum&lt;0
		if(temp&lt;0){<!-- -->  
			//Increment i
			i++;           
		}
		else		
		j--; // Decrement j
	}
	
	//print the pair
	cout&lt;&lt;"the pair is "&lt;&lt;a[indexN]&lt;&lt;","&lt;&lt;a[indexP]&lt;&lt;endl;    
}

int main(){<!-- -->

	int x,count=0,n;

	// enter array length
	cout&lt;&lt;"enter no of elements\n";        
	cin&gt;&gt;n;
	
	int* a=(int*)(malloc(sizeof(int)*n));
	
	//fill the array
	cout&lt;&lt;"enter elements................\n";  
	for(int i=0;i&lt;n;i++)
		scanf("%d",&amp;a[i]);

	findpairs(a,n);           

	return 0;	
}
</code>
</pre> 
 <p><b>Output</b></p> 
 <p> <b class="raw_b_node">输出量</b> </p> 
 <pre><code class="has">enter no of elements
9
enter elements................
11
-4
7 
31
-30
-6
8
17
-14
the pair is -30,31
</code>

</pre> 
 <blockquote> 
  <p>翻译自: <a href="https://www.includehelp.com/algorithms/find-the-pair-whose-sum-is-closest-to-zero-in-minimum-time-complexity.aspx" rel="nofollow">https://www.includehelp.com/algorithms/find-the-pair-whose-sum-is-closest-to-zero-in-minimum-time-complexity.aspx</a></p> 
 </blockquote> 
 <p>两个列表的最小索引总和</p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/17830f3cf279f886357d39e5fea2d1c3/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Fullcalendar 在vue中鼠标hover显示悬浮框（tippy.js插件）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f53a2b8c87d14165a6c7dbc5bdd76199/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">大数据分析和数据挖掘区别_大数据分析和数据挖掘之间的区别，大数据的未来范围...</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>