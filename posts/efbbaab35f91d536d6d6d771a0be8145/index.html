<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>vue生命周期和vue请求&#43;动画&#43;组件 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="vue生命周期和vue请求&#43;动画&#43;组件" />
<meta property="og:description" content="1.生命周期
（1）beforeCreate()
这是我们遇到的第一个生命周期函数，表示实例完全被创建出来之前，会执行它
注意： 在 beforeCreate 生命周期函数执行的时候，data 和 methods 中的 数据都还没有没初始化
（2）created() 这是第二个生命周期函数
在 created 中，data 和 methods 都已经被初始化好了！
如果要调用 methods 中的方法，或者操作 data 中的数据，最早，只能在 created 中操作
（3）beforeMount()
这是遇到的第3个生命周期函数，表示 模板已经在内存中编辑完成了，但是尚未把 模板渲染到 页面中
在 beforeMount 执行的时候，页面中的元素，还没有被真正替换过来，只是之前写的一些模板字符串
（4）mounted()
这是遇到的第4个生命周期函数，表示，内存中的模板，已经真实的挂载到了页面中，用户已经可以看到渲染好的页面了
mounted 是 实例创建期间的最后一个生命周期函数，当执行完 mounted 就表示，实例已经被完全创建好了，此时，如果没有其它操作的话，这个实例，就静静的 躺在我们的内存中，一动不动
（5）beforeUpdate()
这时候，表示 我们的界面还没有被更新【数据被更新了吗？ 数据肯定被更新了
当执行 beforeUpdate 的时候，页面中的显示的数据，还是旧的，此时 data 数据是最新的，页面尚未和 最新的数据保持同步
（6）updated()
updated 事件执行的时候，页面和 data 数据已经保持同步了，都是最新的
（7）beforedestroyed()
退出操作之前
(8)destroyed()
关闭缓存
&lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue({ el: &#39;#app&#39;, data: { msg: &#39;ok&#39; }, methods: { show() { console." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/efbbaab35f91d536d6d6d771a0be8145/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-05-31T21:04:00+08:00" />
<meta property="article:modified_time" content="2023-05-31T21:04:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">vue生命周期和vue请求&#43;动画&#43;组件</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>1.生命周期</p> 
<p><img alt="" height="776" src="https://images2.imgbox.com/82/a7/5ceqjab9_o.png" width="693"></p> 
<p>（1）beforeCreate()</p> 
<p><span style="color:#595959;">这是我们遇到的第一个生命周期函数，表示实例完全被创建出来之前，会执行它</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"> 注意： 在 beforeCreate 生命周期函数执行的时候，data 和 methods 中的 数据都还没有没初始化</p> 
<p>（2）created() </p> 
<p>这是第二个生命周期函数</p> 
<p><span style="color:#595959;"> 在 created 中，data 和 methods 都已经被初始化好了！</span></p> 
<p><span style="color:#595959;"> 如果要调用 methods 中的方法，或者操作 data 中的数据，最早，只能在 created 中操作</span></p> 
<p>（3）beforeMount()</p> 
<p><span style="color:#595959;">这是遇到的第3个生命周期函数，表示 模板已经在内存中编辑完成了，但是尚未把 模板渲染到 页面中</span></p> 
<p><span style="color:#595959;">在 beforeMount 执行的时候，页面中的元素，还没有被真正替换过来，只是之前写的一些模板字符串</span></p> 
<p>（4）mounted()</p> 
<p><span style="color:#595959;">这是遇到的第4个生命周期函数，表示，内存中的模板，已经真实的挂载到了页面中，用户已经可以看到渲染好的页面了</span></p> 
<p><span style="color:#595959;">mounted 是 实例创建期间的最后一个生命周期函数，当执行完 mounted 就表示，实例已经被完全创建好了，此时，如果没有其它操作的话，这个实例，就静静的 躺在我们的内存中，一动不动</span></p> 
<p>（5）beforeUpdate()</p> 
<p style="margin-left:.0001pt;text-align:justify;">这时候，表示 我们的界面还没有被更新【数据被更新了吗？  数据肯定被更新了</p> 
<p style="margin-left:.0001pt;text-align:justify;">当执行 beforeUpdate 的时候，页面中的显示的数据，还是旧的，此时 data 数据是最新的，页面尚未和 最新的数据保持同步</p> 
<p>（6）updated()</p> 
<p style="margin-left:.0001pt;text-align:justify;">updated 事件执行的时候，页面和 data 数据已经保持同步了，都是最新的</p> 
<p>（7）beforedestroyed()</p> 
<p>退出操作之前</p> 
<p>(8)destroyed()</p> 
<p>关闭缓存</p> 
<pre><code class="language-javascript">&lt;script&gt;
    // 创建 Vue 实例，得到 ViewModel
    var vm = new Vue({
      el: '#app',
      data: {
        msg: 'ok'
      },
      methods: {
        show() {
          console.log('执行了show方法')
        }
      },
      beforeCreate() { // 这是我们遇到的第一个生命周期函数，表示实例完全被创建出来之前，会执行它
        // console.log(this.msg)
        // this.show()
        // 注意： 在 beforeCreate 生命周期函数执行的时候，data 和 methods 中的 数据都还没有没初始化
      },
      created() { // 这是遇到的第二个生命周期函数
        // console.log(this.msg)
        // this.show()
        //  在 created 中，data 和 methods 都已经被初始化好了！
        // 如果要调用 methods 中的方法，或者操作 data 中的数据，最早，只能在 created 中操作
      },
      beforeMount() { // 这是遇到的第3个生命周期函数，表示 模板已经在内存中编辑完成了，但是尚未把 模板渲染到 页面中
        // console.log(document.getElementById('h3').innerText)
        // 在 beforeMount 执行的时候，页面中的元素，还没有被真正替换过来，只是之前写的一些模板字符串
      },
      mounted() { // 这是遇到的第4个生命周期函数，表示，内存中的模板，已经真实的挂载到了页面中，用户已经可以看到渲染好的页面了
        // console.log(document.getElementById('h3').innerText)
        // 注意： mounted 是 实例创建期间的最后一个生命周期函数，当执行完 mounted 就表示，实例已经被完全创建好了，此时，如果没有其它操作的话，这个实例，就静静的 躺在我们的内存中，一动不动
      },


      // 接下来的是运行中的两个事件
      beforeUpdate() { // 这时候，表示 我们的界面还没有被更新【数据被更新了吗？  数据肯定被更新了】
        /* console.log('界面上元素的内容：' + document.getElementById('h3').innerText)
        console.log('data 中的 msg 数据是：' + this.msg) */
        // 得出结论： 当执行 beforeUpdate 的时候，页面中的显示的数据，还是旧的，此时 data 数据是最新的，页面尚未和 最新的数据保持同步
      },
      updated() {
        console.log('界面上元素的内容：' + document.getElementById('h3').innerText)
        console.log('data 中的 msg 数据是：' + this.msg)
        // updated 事件执行的时候，页面和 data 数据已经保持同步了，都是最新的
      }
    });
  &lt;/script&gt;</code></pre> 
<p> 2.axios的使用</p> 
<p><span style="color:#000088;">&lt;script</span> <span style="color:#660066;">src</span><span style="color:#666600;">=</span>"https://cdn.staticfile.org/axios/0.18.0/axios.min.js"<span style="color:#000088;">&gt;&lt;/script&gt;</span><span style="color:#0d0016;">（1）get请求</span></p> 
<p><span style="color:#0d0016;">(1)get请求</span></p> 
<p>//生命周期</p> 
<p>            created() {<!-- --></p> 
<p></p> 
<p>                axios.get(this.baseUrl + "/weChat/applet/course/banner/list?number=3").then((res) =&gt; {<!-- --></p> 
<p>                    // console.log(res.data.data);</p> 
<p>                    this.swiperList = res.data.data</p> 
<p>                    // console.log(this.swiperList);</p> 
<p>                    // 初始化  </p> 
<p>                    var swiper = new Swiper('.swiper-container', {<!-- --></p> 
<p>                        spaceBetween: 30,</p> 
<p>                        centeredSlides: true,</p> 
<p>                        autoplay: {<!-- --></p> 
<p>                            delay: 2500,</p> 
<p>                            disableOnInteraction: false,</p> 
<p>                        },</p> 
<p>                        pagination: {<!-- --></p> 
<p>                            el: '.swiper-pagination',</p> 
<p>                            clickable: true,</p> 
<p>                        },</p> 
<p>                        navigation: {<!-- --></p> 
<p>                            nextEl: '.swiper-button-next',</p> 
<p>                            prevEl: '.swiper-button-prev',</p> 
<p>                        },</p> 
<p>                    });</p> 
<p>                })</p> 
<p>            }</p> 
<p><span style="color:#0d0016;">(2)post请求</span></p> 
<p>created() {<!-- --></p> 
<p>                axios.post(this.baseUrl + '/weChat/applet/subject/list', { enable: 1 }).then((res) =&gt; {<!-- --></p> 
<p>                    // console.log(res);</p> 
<p>                    this.optionList = res.data.rows</p> 
<p>                })</p> 
<p>            }</p> 
<p>与ajax的get或者post用法相同</p> 
<p>3.动画</p> 
<pre><code class="language-javascript">&lt;style&gt;
            * {
                text-align: center;
            }

            button {
                margin-top: 200px;
                padding: 10px 20px;
            }

            p {
                width: 20px;
                height: 20px;
                background-color: red;
                border-radius: 50%;
                position: absolute;
            }

            /* 定义进入和离开时候的过渡状态 */
            .fade-enter-active,
            .fade-leave-active {
                transition: all 5s ease;
            }

            ​

            /* 定义进入过渡的开始状态 和 离开过渡的结束状态 */
            .fade-enter,
            .fade-leave-to {
                opacity: 0;
                transform: translate(720px,220px);
                /* transform: translateY(300px); */
            }
        &lt;/style&gt;
    &lt;/head&gt;

    &lt;body&gt;
        &lt;div id="app"&gt;
            &lt;transition name="fade"&gt;
                &lt;p v-show="isshow"&gt;*&lt;/p&gt;
            &lt;/transition&gt;
            &lt;button @click="getplay"&gt;果宝特攻归位&lt;/button&gt;
        &lt;/div&gt;
    &lt;/body&gt;
    &lt;script&gt;
        new Vue({
            el: '#app',
            data: {
                isshow:false
            },
            methods: {
                getplay(){
                    this.isshow=!this.isshow
                }
            }
        })
    &lt;/script&gt;</code></pre> 
<p> 4.动画钩子函数</p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>定义 transition 组件以及三个钩子函数：</strong></strong></p> 
<p><span style="background-color:#bebebe;"><span style="background-color:#bebebe;">&lt;div id="app"&gt;</span></span></p> 
<p><span style="background-color:#bebebe;"><span style="background-color:#bebebe;">  &lt;input type="button" value="切换动画" @click="isshow = !isshow"&gt;</span><br><span style="background-color:#bebebe;">  &lt;transition</span><br><span style="background-color:#bebebe;">  @before-enter="beforeEnter"</span><br><span style="background-color:#bebebe;">  @enter="enter"</span><br><span style="background-color:#bebebe;">  @after-enter="afterEnter"&gt;</span><br><span style="background-color:#bebebe;">    &lt;div v-if="isshow" class="show"&gt;OK&lt;/div&gt;</span><br><span style="background-color:#bebebe;">  &lt;/transition&gt;</span><br><span style="background-color:#bebebe;">&lt;/div&gt;</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>定义三个 methods 钩子方法：</strong></strong></p> 
<p><span style="background-color:#bebebe;"><span style="background-color:#bebebe;">methods: {<!-- --></span></span></p> 
<p><span style="background-color:#bebebe;"><span style="background-color:#bebebe;">      beforeEnter(el) { // 动画进入之前的回调</span><br><span style="background-color:#bebebe;">        el.style.transform = 'translateX(500px)';</span><br><span style="background-color:#bebebe;">      },</span><br><span style="background-color:#bebebe;">      enter(el, done) { // 动画进入完成时候的回调</span><br><span style="background-color:#bebebe;">        el.offsetWidth;</span><br><span style="background-color:#bebebe;">        el.style.transform = 'translateX(0px)';</span><br><span style="background-color:#bebebe;">        done();</span><br><span style="background-color:#bebebe;">      },</span><br><span style="background-color:#bebebe;">      afterEnter(el) { // 动画进入完成之后的回调</span><br><span style="background-color:#bebebe;">        this.isshow = !this.isshow;</span><br><span style="background-color:#bebebe;">      }</span></span></p> 
<p><span style="background-color:#bebebe;"><span style="background-color:#bebebe;">}</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>定义动画过渡时长和样式：</strong></strong></p> 
<p><span style="background-color:#bebebe;"><span style="background-color:#bebebe;">.show{<!-- --></span></span></p> 
<p><span style="background-color:#bebebe;"><span style="background-color:#bebebe;">transition: all 0.4s ease;</span></span></p> 
<p><span style="background-color:#bebebe;"><span style="background-color:#bebebe;">}</span></span></p> 
<p>4.组件</p> 
<p>（1）创建的四种方法</p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>1</strong></strong><strong><strong>.</strong></strong><strong><strong>使用 Vue.extend 配合 Vue.component 方法：</strong></strong><strong><strong> 写在js中和vue之前</strong></strong></p> 
<p>var login = Vue.extend({<!-- --></p> 
<p>    template: '&lt;h1&gt;登录&lt;/h1&gt;'富文本<br>   });<br>   Vue.component('login', login);  单引号常量，无引号变量 在html直接引用login变量标签</p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>2.</strong></strong><strong><strong>直接使用 Vue.component 方法：</strong></strong></p> 
<p>Vue.component('register', {<!-- --></p> 
<p>    template: '&lt;h1&gt;注册&lt;/h1&gt;'<br>   });</p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>3.</strong></strong><strong><strong>将模板字符串，定义到</strong></strong><strong><strong>新的</strong></strong><strong><strong>script标签</strong></strong><strong><strong>中</strong></strong><strong><strong>：</strong></strong></p> 
<p>&lt;script id="tmpl" type="x-template"&gt;</p> 
<p>    &lt;div&gt;&lt;a href="#"&gt;登录&lt;/a&gt; | &lt;a href="#"&gt;注册&lt;/a&gt;&lt;/div&gt;<br>   &lt;/script&gt;</p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>同时，需要使用 Vue.component 来定义组件：</strong></strong></p> 
<p>Vue.component('account', {<!-- --></p> 
<p>    template: '#tmpl'<br>   });</p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>4</strong></strong><strong><strong>.</strong></strong><strong><strong>将模板字符串，定义到template标签</strong></strong><strong><strong>中</strong></strong><strong><strong>：</strong></strong><strong><strong>不用加入新的script标签中</strong></strong></p> 
<p>&lt; template id="tmpl"&gt; <span style="background-color:#ff0000;">tmpl可以直接在body里当标签使用</span></p> 
<p>    &lt;div&gt;&lt;a href="#"&gt;登录&lt;/a&gt; | &lt;a href="#"&gt;注册&lt;/a&gt;&lt;/div&gt;<br>   &lt;/ template &gt;</p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>同时，需要使用 Vue.component 来定义组件：</strong></strong></p> 
<p>Vue.component('account', {<!-- --></p> 
<p>    template: '#tmpl'<br>   });</p> 
<p><strong><strong>注意：</strong></strong>组件中的DOM结构，有且只能有<span style="background-color:#ff0000;">唯一</span>的根元素（Root Element）来进行包裹！</p> 
<p>不可同名兄弟多个</p> 
<p>(2)组件中展示数据和响应事件</p> 
<p>Vue.component('account', {<!-- --></p> 
<p>    template: '#tmpl',<br>    <span style="background-color:#ff0000;"> data() {<!-- --></span><span style="background-color:#ff0000;">与vue不同的是此处为函数</span><br><span style="background-color:#ff0000;">      return {<!-- --></span><br><span style="background-color:#ff0000;">        msg: '大家好！'</span><br><span style="background-color:#ff0000;">      }</span><br><span style="background-color:#ff0000;">    },</span><br>     methods:{<!-- --><br>       login(){<!-- --><br>         alert('点击了登录按钮');<br>       }<br>     }<br>   });</p> 
<p><strong><strong>在子组件中，如果将模板字符串，定义到了script标签中，那么，要访问子组件身上的</strong></strong><strong><strong>data</strong></strong><strong><strong>属性中的值，需要使用</strong></strong><strong><strong>this</strong></strong><strong><strong>来访问</strong></strong></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/56b85c27783e823848c3820fb87a0c30/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">最惊艳的sql</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/fa6971919034f1be728474ccd6551036/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">win11如何从文件管理器快速打开windows terminal（wt）？</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>