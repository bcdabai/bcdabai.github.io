<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>java集合之LinkList解析 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="java集合之LinkList解析" />
<meta property="og:description" content="LinkeList是基于双向链表的实现，同时它也实现了Queue队列,Deque栈的实现,使得我们可以进行双向队列的实现,上一节java集合之ArrayList解析中说过ArrayList查询效率比较高,添加和删除集合中的元素效率比较低,而LinkList正好相反. LinkList组织结构图 LinkList继承自AbstractSequentialList(ArrayList继承AbstractList)同时实现了Serializable和Cloneable标记接口,相比于ArrayList缺少了RandomAccess，说明进行随机访问效率比较低,多了Deque及Queue可以进行栈和队列的操作.
队列Queue public interface Queue&lt;E&gt; extends Collection&lt;E&gt; { boolean add(E var1); boolean offer(E var1); E remove(); E poll(); E element(); E peek(); } LinkList实现了队列Queue,Queue扩展了Collection,队列的特点是先进先出,在尾部添加数据，在头部删除数据. 使用add,offer在尾部添加数据使用remove,poll获取头部数据，并删除头部数据，会改变队列结构使用element,peek仅仅是获取头部数据，不会改变队列结构 每种操作都有两种形式,它们的区别是什么?区别就在于针对队列特殊情况的处理上,所谓队列的特殊情况即队列满和队列空.
当队列满的时候执行add操作会抛出IllegalStateException，而offer只会返回false.
当队列空的时候执行remove和element会抛出NoSuchElementException,而poll和peek会返回null。
LinkList队列没有长度的限制,其他的特定队列是有长度的。
LinkList作为队列使用:
Queue&lt;Integer&gt; queue=new LinkedList&lt;&gt;(); queue.offer(1); queue.offer(2); queue.offer(3); while (queue.peek()!=null){ System.out.println(queue.poll());//输出1&gt;2&gt;3 } } Deque双端队列 栈和队列都可以进行双端操作,只是栈只能操作头部,而队列可以操作头部和尾部,在尾部添加数据,在头部删除数据.
LinkList实现了栈,栈在开发中很常见,栈的特点是先进后出.Deque继承了队列Queue,它同样是个接口。
public interface Deque&lt;E&gt; extends Queue&lt;E&gt; { boolean add(E var1); boolean offer(E var1); E remove(); E poll(); E element(); E peek(); void push(E var1); E pop(); int size(); Iterator&lt;E&gt; iterator(); Iterator&lt;E&gt; descendingIterator(); void addFirst(E e); void addLast(E e); E getFirst(); E getLast(); boolean offerFirst(E e); boolean offerLast(E e); E peekFirst(); E peekLast(); E pollFirst(); E pollLast(); E removeFirst(); E removeLast(); } Deque栈扩展了队列,实现入栈和出栈操作。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/bd9fcda1b3bf7b4ce368cf3ddb7e55c7/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2017-09-13T17:36:58+08:00" />
<meta property="article:modified_time" content="2017-09-13T17:36:58+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">java集合之LinkList解析</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h6 id="linkelist是基于双向链表的实现同时它也实现了queue队列deque栈的实现使得我们可以进行双向队列的实现上一节java集合之arraylist解析中说过arraylist查询效率比较高添加和删除集合中的元素效率比较低而linklist正好相反">LinkeList是基于双向链表的实现，同时它也实现了Queue队列,Deque栈的实现,使得我们可以进行双向队列的实现,上一节<a href="http://blog.csdn.net/u012233285/article/details/77966340" target="_blank" rel="noopener noreferrer">java集合之ArrayList解析</a>中说过ArrayList查询效率比较高,添加和删除集合中的元素效率比较低,而LinkList正好相反.</h6> 
<h6 id="linklist组织结构图">LinkList组织结构图</h6> 
<p><img src="https://images2.imgbox.com/a8/92/pOYv0Ld1_o.png" alt="这里写图片描述" title=""> <br> LinkList继承自AbstractSequentialList(ArrayList继承AbstractList)同时实现了Serializable和Cloneable标记接口,相比于ArrayList缺少了RandomAccess，说明进行随机访问效率比较低,多了Deque及Queue可以进行栈和队列的操作.</p> 
<h5 id="队列queue">队列Queue</h5> 
<pre class="prettyprint"><code class=" hljs axapta"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Queue</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-inheritance"><span class="hljs-keyword">extends</span></span> <span class="hljs-title">Collection</span>&lt;<span class="hljs-title">E</span>&gt; {<!-- --></span>
    <span class="hljs-keyword">boolean</span> add(E var1);

    <span class="hljs-keyword">boolean</span> offer(E var1);

    E remove();

    E poll();

    E element();

    E peek();
}</code></pre> 
<h6 id="linklist实现了队列queuequeue扩展了collection队列的特点是先进先出在尾部添加数据在头部删除数据">LinkList实现了队列Queue,Queue扩展了Collection,队列的特点是先进先出,在尾部添加数据，在头部删除数据.</h6> 
<ul><li>使用add,offer在尾部添加数据</li><li>使用remove,poll获取头部数据，并删除头部数据，会改变队列结构</li><li>使用element,peek仅仅是获取头部数据，不会改变队列结构</li></ul> 
<blockquote> 
 <p>每种操作都有两种形式,它们的区别是什么?区别就在于针对队列特殊情况的处理上,所谓队列的特殊情况即队列满和队列空.</p> 
 <p>当队列满的时候执行add操作会抛出IllegalStateException，而offer只会返回false.</p> 
 <p>当队列空的时候执行remove和element会抛出NoSuchElementException,而poll和peek会返回null。</p> 
 <p>LinkList队列没有长度的限制,其他的特定队列是有长度的。</p> 
</blockquote> 
<p>LinkList作为队列使用:</p> 
<pre class="prettyprint"><code class=" hljs lasso"> <span class="hljs-built_in">Queue</span><span class="hljs-subst">&lt;</span><span class="hljs-built_in">Integer</span><span class="hljs-subst">&gt;</span> <span class="hljs-built_in">queue</span><span class="hljs-subst">=</span><span class="hljs-literal">new</span> LinkedList<span class="hljs-subst">&lt;&gt;</span>();
       <span class="hljs-built_in">queue</span><span class="hljs-built_in">.</span>offer(<span class="hljs-number">1</span>);
       <span class="hljs-built_in">queue</span><span class="hljs-built_in">.</span>offer(<span class="hljs-number">2</span>);
       <span class="hljs-built_in">queue</span><span class="hljs-built_in">.</span>offer(<span class="hljs-number">3</span>);

       <span class="hljs-keyword">while</span> (<span class="hljs-built_in">queue</span><span class="hljs-built_in">.</span>peek()<span class="hljs-subst">!=</span><span class="hljs-built_in">null</span>){
           System<span class="hljs-built_in">.</span>out<span class="hljs-built_in">.</span>println(<span class="hljs-built_in">queue</span><span class="hljs-built_in">.</span>poll());<span class="hljs-comment">//输出1&gt;2&gt;3</span>
       }
   }
</code></pre> 
<h5 id="deque双端队列">Deque双端队列</h5> 
<p>栈和队列都可以进行双端操作,只是栈只能操作头部,而队列可以操作头部和尾部,在尾部添加数据,在头部删除数据.</p> 
<p>LinkList实现了栈,栈在开发中很常见,栈的特点是先进后出.Deque继承了队列Queue,它同样是个接口。</p> 
<pre class="prettyprint"><code class=" hljs scss">public interface Deque&lt;E&gt; extends Queue&lt;E&gt; {


    boolean <span class="hljs-function">add(E var1)</span>;

    boolean <span class="hljs-function">offer(E var1)</span>;

    E <span class="hljs-function">remove()</span>;

    E <span class="hljs-function">poll()</span>;

    E <span class="hljs-function">element()</span>;

    E <span class="hljs-function">peek()</span>;

    void <span class="hljs-function">push(E var1)</span>;

    E <span class="hljs-function">pop()</span>;

    int <span class="hljs-function">size()</span>;

    Iterator&lt;E&gt; <span class="hljs-function">iterator()</span>;

    Iterator&lt;E&gt; <span class="hljs-function">descendingIterator()</span>;
    void <span class="hljs-function">addFirst(E e)</span>;
    void <span class="hljs-function">addLast(E e)</span>;
    E <span class="hljs-function">getFirst()</span>;
    E <span class="hljs-function">getLast()</span>;
    boolean <span class="hljs-function">offerFirst(E e)</span>;
    boolean <span class="hljs-function">offerLast(E e)</span>;
    E <span class="hljs-function">peekFirst()</span>;
    E <span class="hljs-function">peekLast()</span>;
    E <span class="hljs-function">pollFirst()</span>;
    E <span class="hljs-function">pollLast()</span>;
    E <span class="hljs-function">removeFirst()</span>;
    E <span class="hljs-function">removeLast()</span>;
}</code></pre> 
<blockquote> 
 <p>Deque栈扩展了队列,实现入栈和出栈操作。</p> 
 <p>push表示入栈,在头部添加数据,如果这时栈满,报IllegalStateException异常.</p> 
 <p>pop表示出栈,返回头部数据,并且从栈中删除,如果栈是空的,报NoSuchElementException异常</p> 
 <p>peek表示获取栈中头部数据,并返回头部数据,不改变栈结构,若栈是空的，就返回null.</p> 
 <p>xxxFirst操作头部，xxxLast操作尾部。与队列类似，每种操作有两种形式，区别也是在队列为空或满时，处理不同。为空时，getXXX/removeXXX会抛出异常，而peekXXX/pollXXX会返回null。队列满时，addXXX会抛出异常，offerXXX只是返回false。</p> 
 <p>栈和队列只是双端队列的特殊情况，它们的方法都可以使用双端队列的方法替代，不过，使用不同的名称和方法，概念上更为清晰</p> 
 <p>Iterator descendingIterator();迭代器方法，可以从后往前遍历</p> 
</blockquote> 
<p>LinkList作为栈使用</p> 
<pre class="prettyprint"><code class=" hljs cpp">Deque&lt;Integer&gt; <span class="hljs-built_in">deque</span>=<span class="hljs-keyword">new</span> LinkedList&lt;&gt;();
       <span class="hljs-built_in">deque</span>.push(<span class="hljs-number">1</span>);
       <span class="hljs-built_in">deque</span>.push(<span class="hljs-number">2</span>);
       <span class="hljs-built_in">deque</span>.push(<span class="hljs-number">3</span>);

       <span class="hljs-keyword">while</span> (<span class="hljs-built_in">deque</span>.peek()!=null){
           System.out.println(<span class="hljs-built_in">deque</span>.pop());<span class="hljs-comment">//输出3&gt;2&gt;1</span>
       }
</code></pre> 
<p>在java中Stack类也用于表示栈,具体的实现细节大家可以自己看看源码。LinkedList的用法是比较简单的，与ArrayList用法类似，支持List接口，只是，LinkedList增加了一个接口Deque，可以把它看做队列、栈、双端队列，方便的在两端进行操作。</p> 
<hr> 
<h6 id="linklist源码分析">LinkList源码分析:</h6> 
<p>ArrayList内部的实现是基于动态数组,数据元素在内存中是连续存放的.而LinkList是基于双向链表实现的,在物理上链表中的数据元素在内存中的形态是非连续的，它是靠链表的前后节点Node指向进行关联的，下面是双链表的结构图.</p> 
<p><img src="https://images2.imgbox.com/e0/ba/QX9lRYI8_o.jpg" alt="这里写图片描述" title=""></p> 
<p>LinkList中的内部类Node</p> 
<blockquote> 
 <p>Node类表示节点，item表示当前的数据元素,prev指向前一个节点,next指向下一个节点.</p> 
 <p>First节点也叫头节点,它的prev是null</p> 
 <p>Last节点又叫尾节点,它的next是null.</p> 
</blockquote> 
<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> Node {
    E item;
    Node next;
    Node prev;

    Node(Node prev, E element, Node next) {
        <span class="hljs-keyword">this</span>.item = element;
        <span class="hljs-keyword">this</span>.next = next;
        <span class="hljs-keyword">this</span>.prev = prev;
    }
}    </code></pre> 
<blockquote> 
 <p>LinkList中的成员变量,分别代表如下含义:</p> 
 <p>size表示链表的长度即数据元素的个数</p> 
 <p>first代表头节点,last代表尾节点,默认都是null</p> 
 <p>LinkList的所有操作都是围绕上面这三个成员变量展开的。</p> 
</blockquote> 
<pre class="prettyprint"><code class=" hljs java"><span class="hljs-keyword">transient</span> <span class="hljs-keyword">int</span> size;
<span class="hljs-keyword">transient</span> LinkedList.Node&lt;E&gt; first;
<span class="hljs-keyword">transient</span> LinkedList.Node&lt;E&gt; last;</code></pre> 
<h5 id="linklist的add操作">LinkList的add操作</h5> 
<pre class="prettyprint"><code class=" hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span>(E e) {
        <span class="hljs-keyword">this</span>.linkLast(e);
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
    }</code></pre> 
<p>(1)在执行add操作的时候调用了添加数据元素e到链表尾部的方法linkLast,并返回true.</p> 
<pre class="prettyprint"><code class=" hljs java"><span class="hljs-keyword">void</span> linkLast(E e) {
    <span class="hljs-keyword">final</span> Node l = last;
    <span class="hljs-keyword">final</span> Node newNode = <span class="hljs-keyword">new</span> Node&lt;&gt;(l, e, <span class="hljs-keyword">null</span>);
    last = newNode;
    <span class="hljs-keyword">if</span> (l == <span class="hljs-keyword">null</span>)
        first = newNode;
    <span class="hljs-keyword">else</span>
        l.next = newNode;
    size++;
    modCount++;
}
</code></pre> 
<p>(2)得到当前链表的尾节点并赋值给节点l</p> 
<p>(3)创建一个新节点newNode，将节点l设置为它的前驱节点,数据元素e为其数据,null为后继节点。</p> 
<p>(4)将newNode节点设置为last节点.</p> 
<p>(5)如果l为null，表明当前列表是空链表,这时设置头节点first为newNode否则执行第6步。</p> 
<p>(6)设置头节点的next节点为newNode <br> (7)让size加1，modCount加1,modCount的作用代表修改次数与ArrayList相同。</p> 
<h5 id="linklist的remove操作">LinkList的remove操作</h5> 
<pre class="prettyprint"><code class=" hljs axapta"><span class="hljs-keyword">public</span> E remove(<span class="hljs-keyword">int</span> <span class="hljs-keyword">index</span>) {
        <span class="hljs-keyword">this</span>.checkElementIndex(<span class="hljs-keyword">index</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.unlink(<span class="hljs-keyword">this</span>.node(<span class="hljs-keyword">index</span>));
    }</code></pre> 
<p>(1)首先调用checkElementIndex方法检查索引是不是合法，如果不合法抛出IndexOutOfBoundsException异常，否则执行第2步。</p> 
<p>(2)调用unlink(node(index))方法,其中node(index)表示根据索引查询链表中的node元素.</p> 
<pre class="prettyprint"><code class=" hljs perl">Node node(<span class="hljs-keyword">int</span> <span class="hljs-keyword">index</span>) {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">index</span> &lt; (size &gt;&gt; <span class="hljs-number">1</span>)) {
        Node <span class="hljs-keyword">x</span> = first;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">index</span>; i++)
            <span class="hljs-keyword">x</span> = <span class="hljs-keyword">x</span>.<span class="hljs-keyword">next</span>;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">x</span>;
    } <span class="hljs-keyword">else</span> {
        Node <span class="hljs-keyword">x</span> = <span class="hljs-keyword">last</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = size - <span class="hljs-number">1</span>; i &gt; <span class="hljs-keyword">index</span>; i--)
            <span class="hljs-keyword">x</span> = <span class="hljs-keyword">x</span>.prev;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">x</span>;
    }
}</code></pre> 
<p>(3)如果索引index</p> 
<pre class="prettyprint"><code class=" hljs vbscript">E unlink(Node x) {
    final E element = x.item;
    final Node <span class="hljs-keyword">next</span> = x.<span class="hljs-keyword">next</span>;
    final Node prev = x.prev;

    <span class="hljs-keyword">if</span> (prev == <span class="hljs-literal">null</span>) {
        first = <span class="hljs-keyword">next</span>;
    } <span class="hljs-keyword">else</span> {
        prev.<span class="hljs-keyword">next</span> = <span class="hljs-keyword">next</span>;
        x.prev = <span class="hljs-literal">null</span>;
    }

    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">next</span> == <span class="hljs-literal">null</span>) {
        last = prev;
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">next</span>.prev = prev;
        x.<span class="hljs-keyword">next</span> = <span class="hljs-literal">null</span>;
    }

    x.item = <span class="hljs-literal">null</span>;
    size--;
    modCount++;
    return element;
}
</code></pre> 
<p>(5)删除node节点x的基本思路是就是把x节点的前驱节点与后继节点直接关联起来,然后修改x.item=null以及size进行减1，modCount加1操作。</p> 
<hr> 
<p>至此LinkList的add与remove操作源码分析完了，其他的get/size等方法也就可以很容易的看懂了，由于时间的关系这里不再赘述了。</p> 
<h6 id="linklist的总结">LinkList的总结</h6> 
<ul><li>LinkedList内部是用双向链表实现的，维护了长度、头节点和尾节点</li><li>按需分配空间，不需要预先分配很多空间</li><li>不可以随机访问，按照索引位置访问效率比较低，必须从头或尾顺着链接找，效率为O(N/2).</li><li>不管列表是否已排序，只要是按照内容查找元素，效率都比较低，必须逐个比较，效率为O(N)。</li><li>在两端添加、删除元素的效率很高，为O(1)。</li><li>在中间插入、删除元素，要先定位，效率比较低，为O(N)，但修改本身的效率很高，效率为O(1)。</li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6d4ca34d2096a3dba25638860723d71a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">java杂文系列(2) eclipse集成drools规则引擎</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/78b8651fff3bcb27554f7301a334bc33/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">[UOJ]#61. 【UR #5】怎样更有力气</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>