<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>js高级笔记 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="js高级笔记" />
<meta property="og:description" content="目录
1 概述
1.1 面向对象介绍
2 ES6中的类和对象
2.1 面向对象思维特点
2.2 对象
2.3 类class
2.4 创建类 2.5 类的继承
2.5.1 类的继承语法规范
2.5.2 super关键字
2.5.3 this的指向问题
2.6 添加新元素新方法
3 js注意点和补充
4 构造函数和原型
4.1 概述
4.2 构造函数
4.2.1 静态成员和实例成员
4.3 构造函数原型prototype
4.4 对象原型__proto__（两边是两个下划线）
4.5 原型constructor
4.6 构造函数、实例、原型对象三者之间的关系
4.7 原型链
4.8 原型对象中this的指向
4.9 扩展内置对象
5 继承
5.1 call（）
5.2 利用构造函数继承父类型中的属性
6 类的本质
7 数组的迭代和遍历方法
7.1 数组方法
7.1.1 forEach（）
7.1.2 filter（）
7.1.3 some（）查找元素中是否有满足条件的元素
7.1.4 forEach和som的区别" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/6e0f9c6b79456d02a0d8977e78293602/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-04-18T17:25:25+08:00" />
<meta property="article:modified_time" content="2022-04-18T17:25:25+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">js高级笔记</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E9%87%8D%E8%A6%81%E9%83%A8%E5%88%86%EF%BC%9B%E9%87%8D%E7%82%B9%E6%A0%87%E6%B3%A8%EF%BC%9B%E6%AC%A1%E9%87%8D%E8%A6%81%E6%A0%87%E6%B3%A8%EF%BC%9B%E7%90%86%E8%A7%A3%E8%AF%B4%E6%98%8E-toc" style="margin-left:0px;"></p> 
<p id="1%20%E6%A6%82%E8%BF%B0-toc" style="margin-left:0px;"><a href="#1%20%E6%A6%82%E8%BF%B0" rel="nofollow">1 概述</a></p> 
<p id="1.1%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%BB%8B%E7%BB%8D-toc" style="margin-left:40px;"><a href="#1.1%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%BB%8B%E7%BB%8D" rel="nofollow">1.1 面向对象介绍</a></p> 
<p id="2%20ES6%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1-toc" style="margin-left:0px;"><a href="#2%20ES6%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1" rel="nofollow">2 ES6中的类和对象</a></p> 
<p id="2.1%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E7%BB%B4%E7%89%B9%E7%82%B9-toc" style="margin-left:40px;"><a href="#2.1%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E7%BB%B4%E7%89%B9%E7%82%B9" rel="nofollow">2.1 面向对象思维特点</a></p> 
<p id="2.2%20%E5%AF%B9%E8%B1%A1-toc" style="margin-left:40px;"><a href="#2.2%20%E5%AF%B9%E8%B1%A1" rel="nofollow">2.2 对象</a></p> 
<p id="2.3%20%E7%B1%BBclass-toc" style="margin-left:40px;"><a href="#2.3%20%E7%B1%BBclass" rel="nofollow">2.3 类class</a></p> 
<p id="2.4%20%E5%88%9B%E5%BB%BA%E7%B1%BB%C2%A0-toc" style="margin-left:40px;"><a href="#2.4%20%E5%88%9B%E5%BB%BA%E7%B1%BB%C2%A0" rel="nofollow">2.4 创建类 </a></p> 
<p id="2.5%20%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF-toc" style="margin-left:40px;"><a href="#2.5%20%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF" rel="nofollow">2.5 类的继承</a></p> 
<p id="2.5.1%20%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF%E8%AF%AD%E6%B3%95%E8%A7%84%E8%8C%83-toc" style="margin-left:80px;"><a href="#2.5.1%20%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF%E8%AF%AD%E6%B3%95%E8%A7%84%E8%8C%83" rel="nofollow">2.5.1 类的继承语法规范</a></p> 
<p id="2.5.2%20super%E5%85%B3%E9%94%AE%E5%AD%97-toc" style="margin-left:80px;"><a href="#2.5.2%20super%E5%85%B3%E9%94%AE%E5%AD%97" rel="nofollow">2.5.2 super关键字</a></p> 
<p id="2.5.3%20this%E7%9A%84%E6%8C%87%E5%90%91%E9%97%AE%E9%A2%98-toc" style="margin-left:80px;"><a href="#2.5.3%20this%E7%9A%84%E6%8C%87%E5%90%91%E9%97%AE%E9%A2%98" rel="nofollow">2.5.3 this的指向问题</a></p> 
<p id="2.6%20%E6%B7%BB%E5%8A%A0%E6%96%B0%E5%85%83%E7%B4%A0%E6%96%B0%E6%96%B9%E6%B3%95-toc" style="margin-left:40px;"><a href="#2.6%20%E6%B7%BB%E5%8A%A0%E6%96%B0%E5%85%83%E7%B4%A0%E6%96%B0%E6%96%B9%E6%B3%95" rel="nofollow">2.6 添加新元素新方法</a></p> 
<p id="3%20js%E6%B3%A8%E6%84%8F%E7%82%B9%E5%92%8C%E8%A1%A5%E5%85%85-toc" style="margin-left:0px;"><a href="#3%20js%E6%B3%A8%E6%84%8F%E7%82%B9%E5%92%8C%E8%A1%A5%E5%85%85" rel="nofollow">3 js注意点和补充</a></p> 
<p id="4%20%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E5%8E%9F%E5%9E%8B-toc" style="margin-left:0px;"><a href="#4%20%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E5%8E%9F%E5%9E%8B" rel="nofollow">4 构造函数和原型</a></p> 
<p id="4.1%20%E6%A6%82%E8%BF%B0-toc" style="margin-left:40px;"><a href="#4.1%20%E6%A6%82%E8%BF%B0" rel="nofollow">4.1 概述</a></p> 
<p id="4.2%20%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-toc" style="margin-left:40px;"><a href="#4.2%20%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0" rel="nofollow">4.2 构造函数</a></p> 
<p id="4.2.1%20%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%92%8C%E5%AE%9E%E4%BE%8B%E6%88%90%E5%91%98-toc" style="margin-left:80px;"><a href="#4.2.1%20%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%92%8C%E5%AE%9E%E4%BE%8B%E6%88%90%E5%91%98" rel="nofollow">4.2.1 静态成员和实例成员</a></p> 
<p id="4.3%20%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8Bprototype-toc" style="margin-left:40px;"><a href="#4.3%20%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8Bprototype" rel="nofollow">4.3 构造函数原型prototype</a></p> 
<p id="4.4%20%E5%AF%B9%E8%B1%A1%E5%8E%9F%E5%9E%8B__proto__%EF%BC%88%E4%B8%A4%E8%BE%B9%E6%98%AF%E4%B8%A4%E4%B8%AA%E4%B8%8B%E5%88%92%E7%BA%BF%EF%BC%89-toc" style="margin-left:40px;"><a href="#4.4%20%E5%AF%B9%E8%B1%A1%E5%8E%9F%E5%9E%8B__proto__%EF%BC%88%E4%B8%A4%E8%BE%B9%E6%98%AF%E4%B8%A4%E4%B8%AA%E4%B8%8B%E5%88%92%E7%BA%BF%EF%BC%89" rel="nofollow">4.4 对象原型__proto__（两边是两个下划线）</a></p> 
<p id="4.5%20%E5%8E%9F%E5%9E%8Bconstructor-toc" style="margin-left:40px;"><a href="#4.5%20%E5%8E%9F%E5%9E%8Bconstructor" rel="nofollow">4.5 原型constructor</a></p> 
<p id="4.6%20%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E3%80%81%E5%AE%9E%E4%BE%8B%E3%80%81%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1%E4%B8%89%E8%80%85%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB-toc" style="margin-left:40px;"><a href="#4.6%20%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E3%80%81%E5%AE%9E%E4%BE%8B%E3%80%81%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1%E4%B8%89%E8%80%85%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB" rel="nofollow">4.6 构造函数、实例、原型对象三者之间的关系</a></p> 
<p id="4.7%20%E5%8E%9F%E5%9E%8B%E9%93%BE-toc" style="margin-left:40px;"><a href="#4.7%20%E5%8E%9F%E5%9E%8B%E9%93%BE" rel="nofollow">4.7 原型链</a></p> 
<p id="4.8%20%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1%E4%B8%ADthis%E7%9A%84%E6%8C%87%E5%90%91-toc" style="margin-left:40px;"><a href="#4.8%20%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1%E4%B8%ADthis%E7%9A%84%E6%8C%87%E5%90%91" rel="nofollow">4.8 原型对象中this的指向</a></p> 
<p id="4.9%20%E6%89%A9%E5%B1%95%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1-toc" style="margin-left:40px;"><a href="#4.9%20%E6%89%A9%E5%B1%95%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1" rel="nofollow">4.9 扩展内置对象</a></p> 
<p id="5%20%E7%BB%A7%E6%89%BF-toc" style="margin-left:0px;"><a href="#5%20%E7%BB%A7%E6%89%BF" rel="nofollow">5 继承</a></p> 
<p id="5.1%20call%EF%BC%88%EF%BC%89-toc" style="margin-left:40px;"><a href="#5.1%20call%EF%BC%88%EF%BC%89" rel="nofollow">5.1 call（）</a></p> 
<p id="5.2%20%E5%88%A9%E7%94%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%BB%A7%E6%89%BF%E7%88%B6%E7%B1%BB%E5%9E%8B%E4%B8%AD%E7%9A%84%E5%B1%9E%E6%80%A7-toc" style="margin-left:40px;"><a href="#5.2%20%E5%88%A9%E7%94%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%BB%A7%E6%89%BF%E7%88%B6%E7%B1%BB%E5%9E%8B%E4%B8%AD%E7%9A%84%E5%B1%9E%E6%80%A7" rel="nofollow">5.2 利用构造函数继承父类型中的属性</a></p> 
<p id="6%20%E7%B1%BB%E7%9A%84%E6%9C%AC%E8%B4%A8-toc" style="margin-left:0px;"><a href="#6%20%E7%B1%BB%E7%9A%84%E6%9C%AC%E8%B4%A8" rel="nofollow">6 类的本质</a></p> 
<p id="7%20%E6%95%B0%E7%BB%84%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%92%8C%E9%81%8D%E5%8E%86%E6%96%B9%E6%B3%95-toc" style="margin-left:0px;"><a href="#7%20%E6%95%B0%E7%BB%84%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%92%8C%E9%81%8D%E5%8E%86%E6%96%B9%E6%B3%95" rel="nofollow">7 数组的迭代和遍历方法</a></p> 
<p id="7.1%20%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95-toc" style="margin-left:40px;"><a href="#7.1%20%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95" rel="nofollow">7.1 数组方法</a></p> 
<p id="7.1.1%C2%A0%20forEach%EF%BC%88%EF%BC%89-toc" style="margin-left:80px;"><a href="#7.1.1%C2%A0%20forEach%EF%BC%88%EF%BC%89" rel="nofollow">7.1.1  forEach（）</a></p> 
<p id="7.1.2%20filter%EF%BC%88%EF%BC%89-toc" style="margin-left:80px;"><a href="#7.1.2%20filter%EF%BC%88%EF%BC%89" rel="nofollow">7.1.2 filter（）</a></p> 
<p id="7.1.3%20some%EF%BC%88%EF%BC%89%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E4%B8%AD%E6%98%AF%E5%90%A6%E6%9C%89%E6%BB%A1%E8%B6%B3%E6%9D%A1%E4%BB%B6%E7%9A%84%E5%85%83%E7%B4%A0-toc" style="margin-left:80px;"><a href="#7.1.3%20some%EF%BC%88%EF%BC%89%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E4%B8%AD%E6%98%AF%E5%90%A6%E6%9C%89%E6%BB%A1%E8%B6%B3%E6%9D%A1%E4%BB%B6%E7%9A%84%E5%85%83%E7%B4%A0" rel="nofollow">7.1.3 some（）查找元素中是否有满足条件的元素</a></p> 
<p id="7.1.4%20forEach%E5%92%8Csom%E7%9A%84%E5%8C%BA%E5%88%AB-toc" style="margin-left:80px;"><a href="#7.1.4%20forEach%E5%92%8Csom%E7%9A%84%E5%8C%BA%E5%88%AB" rel="nofollow">7.1.4 forEach和som的区别</a></p> 
<p id="7.2%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%96%B9%E6%B3%95-toc" style="margin-left:40px;"><a href="#7.2%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%96%B9%E6%B3%95" rel="nofollow">7.2 字符串方法</a></p> 
<p id="7.3%20Object%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95-toc" style="margin-left:40px;"><a href="#7.3%20Object%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95" rel="nofollow">7.3 Object静态方法</a></p> 
<p id="7.3.1%20object.keys(obj%EF%BC%89-toc" style="margin-left:80px;"><a href="#7.3.1%20object.keys%28obj%EF%BC%89" rel="nofollow">7.3.1 object.keys(obj）</a></p> 
<p id="7.3.2%20%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7%E7%9A%84%E7%9B%B8%E5%85%B3%E7%89%B9%E5%BE%81-toc" style="margin-left:80px;"><a href="#7.3.2%20%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7%E7%9A%84%E7%9B%B8%E5%85%B3%E7%89%B9%E5%BE%81" rel="nofollow">7.3.2 定义属性的相关特征</a></p> 
<p id="8%20%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6-toc" style="margin-left:0px;"><a href="#8%20%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6" rel="nofollow">8 函数进阶</a></p> 
<p id="8.1%20%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E8%B0%83%E7%94%A8-toc" style="margin-left:40px;"><a href="#8.1%20%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E8%B0%83%E7%94%A8" rel="nofollow">8.1 函数的定义和调用</a></p> 
<p id="8.1.1%20%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89%E6%96%B9%E5%BC%8F-toc" style="margin-left:80px;"><a href="#8.1.1%20%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89%E6%96%B9%E5%BC%8F" rel="nofollow">8.1.1 函数定义方式</a></p> 
<p id="8.1.2%20%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%96%B9%E5%BC%8F-toc" style="margin-left:80px;"><a href="#8.1.2%20%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%96%B9%E5%BC%8F" rel="nofollow">8.1.2 函数调用方式</a></p> 
<p id="8.2%20this%E7%9A%84%E5%87%BD%E6%95%B0%E6%8C%87%E5%90%91-toc" style="margin-left:40px;"><a href="#8.2%20this%E7%9A%84%E5%87%BD%E6%95%B0%E6%8C%87%E5%90%91" rel="nofollow">8.2 this的函数指向</a></p> 
<p id="8.2.1%20this%E7%9A%84%E6%8C%87%E5%90%91-toc" style="margin-left:80px;"><a href="#8.2.1%20this%E7%9A%84%E6%8C%87%E5%90%91" rel="nofollow">8.2.1 this的指向</a></p> 
<p id="8.2.2%20%E6%94%B9%E5%8F%98%E5%87%BD%E6%95%B0%E5%86%85%E9%83%A8this%E6%8C%87%E5%90%91-toc" style="margin-left:80px;"><a href="#8.2.2%20%E6%94%B9%E5%8F%98%E5%87%BD%E6%95%B0%E5%86%85%E9%83%A8this%E6%8C%87%E5%90%91" rel="nofollow">8.2.2 改变函数内部this指向</a></p> 
<p id="8.3%20%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F-toc" style="margin-left:40px;"><a href="#8.3%20%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F" rel="nofollow">8.3 严格模式</a></p> 
<p id="8.3.1%20%E5%BC%80%E5%90%AF%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F-toc" style="margin-left:80px;"><a href="#8.3.1%20%E5%BC%80%E5%90%AF%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F" rel="nofollow">8.3.1 开启严格模式</a></p> 
<p id="8.3.2%20%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F%E4%B8%AD%E7%9A%84%E5%8F%98%E5%8C%96-toc" style="margin-left:80px;"><a href="#8.3.2%20%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F%E4%B8%AD%E7%9A%84%E5%8F%98%E5%8C%96" rel="nofollow">8.3.2 严格模式中的变化</a></p> 
<p id="8.4%20%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0-toc" style="margin-left:40px;"><a href="#8.4%20%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0" rel="nofollow">8.4 高阶函数</a></p> 
<p id="8.5%20%E9%97%AD%E5%8C%85*-toc" style="margin-left:40px;"><a href="#8.5%20%E9%97%AD%E5%8C%85*" rel="nofollow">8.5 闭包*</a></p> 
<p id="8.5.1%20%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F-toc" style="margin-left:80px;"><a href="#8.5.1%20%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F" rel="nofollow">8.5.1 变量作用域</a></p> 
<p id="8.5.2%20%E4%BB%80%E4%B9%88%E6%98%AF%E9%97%AD%E5%8C%85-toc" style="margin-left:80px;"><a href="#8.5.2%20%E4%BB%80%E4%B9%88%E6%98%AF%E9%97%AD%E5%8C%85" rel="nofollow">8.5.2 什么是闭包</a></p> 
<p id="8.6%20%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0-toc" style="margin-left:40px;"><a href="#8.6%20%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0" rel="nofollow">8.6 递归函数</a></p> 
<p id="8.6.1%20%E4%BB%80%E4%B9%88%E6%98%AF%E9%80%92%E5%BD%92-toc" style="margin-left:80px;"><a href="#8.6.1%20%E4%BB%80%E4%B9%88%E6%98%AF%E9%80%92%E5%BD%92" rel="nofollow">8.6.1 什么是递归</a></p> 
<p id="8.7%20%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D-toc" style="margin-left:40px;"><a href="#8.7%20%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D" rel="nofollow">8.7 浅拷贝和深拷贝</a></p> 
<p id="9%20%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%88%E5%90%AC%E8%AF%B4%E9%9D%9E%E5%B8%B8%E7%AE%80%E5%8D%95%EF%BC%89-toc" style="margin-left:0px;"><a href="#9%20%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%88%E5%90%AC%E8%AF%B4%E9%9D%9E%E5%B8%B8%E7%AE%80%E5%8D%95%EF%BC%89" rel="nofollow">9 正则表达式（听说非常简单）</a></p> 
<p id="9.1%20%E6%A6%82%E8%BF%B0-toc" style="margin-left:40px;"><a href="#9.1%20%E6%A6%82%E8%BF%B0" rel="nofollow">9.1 概述</a></p> 
<p id="9.2%20%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E7%BC%BA%E7%82%B9-toc" style="margin-left:40px;"><a href="#9.2%20%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E7%BC%BA%E7%82%B9" rel="nofollow">9.2 表达式的缺点</a></p> 
<p id="9.3%20%E5%88%9B%E5%BB%BA%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-toc" style="margin-left:40px;"><a href="#9.3%20%E5%88%9B%E5%BB%BA%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F" rel="nofollow">9.3 创建正则表达式</a></p> 
<p id="9.4%20%E6%B5%8B%E8%AF%95%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8Ftest%EF%BC%88%EF%BC%89%E6%96%B9%E6%B3%95-toc" style="margin-left:40px;"><a href="#9.4%20%E6%B5%8B%E8%AF%95%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8Ftest%EF%BC%88%EF%BC%89%E6%96%B9%E6%B3%95" rel="nofollow">9.4 测试正则表达式test（）方法</a></p> 
<p id="9.5%20%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%AD%E7%9A%84%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6-toc" style="margin-left:40px;"><a href="#9.5%20%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%AD%E7%9A%84%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6" rel="nofollow">9.5 正则表达式中的特殊字符</a></p> 
<p id="9.6%20%E5%AD%97%E7%AC%A6%E7%B1%BB-toc" style="margin-left:40px;"><a href="#9.6%20%E5%AD%97%E7%AC%A6%E7%B1%BB" rel="nofollow">9.6 字符类</a></p> 
<p id="9.6.1%20%5B-%5D%E8%8C%83%E5%9B%B4%E7%AC%A6-toc" style="margin-left:80px;"><a href="#9.6.1%20%5B-%5D%E8%8C%83%E5%9B%B4%E7%AC%A6" rel="nofollow">9.6.1 [-]范围符</a></p> 
<p id="9.6.2%20%E9%87%8F%E8%AF%8D%E7%AC%A6-toc" style="margin-left:80px;"><a href="#9.6.2%20%E9%87%8F%E8%AF%8D%E7%AC%A6" rel="nofollow">9.6.2 量词符</a></p> 
<p id="9.7%20%E9%A2%84%E5%AE%9A%E4%B9%89%E7%B1%BB-toc" style="margin-left:40px;"><a href="#9.7%20%E9%A2%84%E5%AE%9A%E4%B9%89%E7%B1%BB" rel="nofollow">9.7 预定义类</a></p> 
<p id="9.8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%AD%E7%9A%84%E6%9B%BF%E6%8D%A2-toc" style="margin-left:40px;"><a href="#9.8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%AD%E7%9A%84%E6%9B%BF%E6%8D%A2" rel="nofollow">9.8正则表达式中的替换</a></p> 
<p id="10%20ES6%E7%AE%80%E4%BB%8B-toc" style="margin-left:0px;"><a href="#10%20ES6%E7%AE%80%E4%BB%8B" rel="nofollow">10 ES6简介</a></p> 
<p id="10.1%20let%E5%85%B3%E9%94%AE%E5%AD%97-toc" style="margin-left:40px;"><a href="#10.1%20let%E5%85%B3%E9%94%AE%E5%AD%97" rel="nofollow">10.1 let关键字</a></p> 
<p id="10.2%20conset%E5%A3%B0%E6%98%8E%E5%B8%B8%E9%87%8F-toc" style="margin-left:40px;"><a href="#10.2%20conset%E5%A3%B0%E6%98%8E%E5%B8%B8%E9%87%8F" rel="nofollow">10.2 conset声明常量</a></p> 
<p id="10.3%20let%E3%80%81const%E3%80%81var%E7%9A%84%E5%8C%BA%E5%88%AB-toc" style="margin-left:40px;"><a href="#10.3%20let%E3%80%81const%E3%80%81var%E7%9A%84%E5%8C%BA%E5%88%AB" rel="nofollow">10.3 let、const、var的区别</a></p> 
<p id="11%20%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC%EF%BC%88%E8%AF%AD%E6%B3%95%E7%B3%96%EF%BC%89-toc" style="margin-left:0px;"><a href="#11%20%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC%EF%BC%88%E8%AF%AD%E6%B3%95%E7%B3%96%EF%BC%89" rel="nofollow">11 数据解构赋值（语法糖）</a></p> 
<p id="11.1%20%E6%95%B0%E7%BB%84%E8%A7%A3%E6%9E%84-toc" style="margin-left:40px;"><a href="#11.1%20%E6%95%B0%E7%BB%84%E8%A7%A3%E6%9E%84" rel="nofollow">11.1 数组解构</a></p> 
<p id="11.2%20%E5%AF%B9%E8%B1%A1%E8%A7%A3%E6%9E%84-toc" style="margin-left:40px;"><a href="#11.2%20%E5%AF%B9%E8%B1%A1%E8%A7%A3%E6%9E%84" rel="nofollow">11.2 对象解构</a></p> 
<p id="11.3%20%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0-toc" style="margin-left:40px;"><a href="#11.3%20%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0" rel="nofollow">11.3 箭头函数</a></p> 
<p id="11.3.1%20%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0this-toc" style="margin-left:80px;"><a href="#11.3.1%20%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0this" rel="nofollow">11.3.1 箭头函数this</a></p> 
<p id="11.4%20%E5%89%A9%E4%BD%99%E5%8F%82%E6%95%B0-toc" style="margin-left:40px;"><a href="#11.4%20%E5%89%A9%E4%BD%99%E5%8F%82%E6%95%B0" rel="nofollow">11.4 剩余参数</a></p> 
<p id="11.5%20%E6%89%A9%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6(%E5%B1%95%E5%BC%80%E8%AF%AD%E6%B3%95)-toc" style="margin-left:80px;"><a href="#11.5%20%E6%89%A9%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6%28%E5%B1%95%E5%BC%80%E8%AF%AD%E6%B3%95%29" rel="nofollow">11.5 扩展运算符(展开语法)</a></p> 
<p id="12%20Array%E7%9A%84%E6%89%A9%E5%B1%95%E6%96%B9%E6%B3%95-toc" style="margin-left:0px;"><a href="#12%20Array%E7%9A%84%E6%89%A9%E5%B1%95%E6%96%B9%E6%B3%95" rel="nofollow">12 扩展方法</a></p> 
<p id="12.1%20Array.from()-toc" style="margin-left:40px;"><a href="#12.1%20Array.from%28%29" rel="nofollow">12.1 Array.from()</a></p> 
<p id="12.2%20%E6%95%B0%E7%BB%84%E5%AE%9E%E4%BE%8B%E7%9A%84%E6%96%B9%E6%B3%95-toc" style="margin-left:40px;"><a href="#12.2%20%E6%95%B0%E7%BB%84%E5%AE%9E%E4%BE%8B%E7%9A%84%E6%96%B9%E6%B3%95" rel="nofollow">12.2 数组实例的方法</a></p> 
<p id="12.2.1%C2%A0find%E6%96%B9%E6%B3%95-toc" style="margin-left:80px;"><a href="#12.2.1%C2%A0find%E6%96%B9%E6%B3%95" rel="nofollow">12.2.1 find方法</a></p> 
<p id="12.2.2%20findIndex%E6%96%B9%E6%B3%95-toc" style="margin-left:80px;"><a href="#12.2.2%20findIndex%E6%96%B9%E6%B3%95" rel="nofollow">12.2.2 findIndex方法</a></p> 
<p id="12.2.3%20includes%E6%96%B9%E6%B3%95-toc" style="margin-left:80px;"><a href="#12.2.3%20includes%E6%96%B9%E6%B3%95" rel="nofollow">12.2.3 includes方法</a></p> 
<p id="12.3%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95-toc" style="margin-left:40px;"><a href="#12.3%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95" rel="nofollow">12.3 字符串实例方法</a></p> 
<p id="12.3.1%20startsWith%EF%BC%88%EF%BC%89%E5%92%8CendsWith%EF%BC%88%EF%BC%89-toc" style="margin-left:80px;"><a href="#12.3.1%20startsWith%EF%BC%88%EF%BC%89%E5%92%8CendsWith%EF%BC%88%EF%BC%89" rel="nofollow">12.3.1 startsWith（）和endsWith（）</a></p> 
<p id="12.3.2%20repeat%E6%96%B9%E6%B3%95-toc" style="margin-left:80px;"><a href="#12.3.2%20repeat%E6%96%B9%E6%B3%95" rel="nofollow">12.3.2 repeat方法</a></p> 
<p id="13%20set%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-toc" style="margin-left:0px;"><a href="#13%20set%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84" rel="nofollow">13 set数据结构</a></p> 
<p id="13.1%20set%E5%88%9B%E5%BB%BA%E5%AE%9E%E4%BE%8B-toc" style="margin-left:40px;"><a href="#13.1%20set%E5%88%9B%E5%BB%BA%E5%AE%9E%E4%BE%8B" rel="nofollow">13.1 set创建实例</a></p> 
<p id="13.2%20set%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95-toc" style="margin-left:40px;"><a href="#13.2%20set%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95" rel="nofollow">13.2 set实例方法</a></p> 
<p id="13.3%20%E9%81%8D%E5%8E%86forEach-toc" style="margin-left:40px;"><a href="#13.3%20%E9%81%8D%E5%8E%86forEach" rel="nofollow">13.3 遍历forEach</a></p> 
<p id="13.4%20%E5%88%A9%E7%94%A8set%E5%AE%9E%E7%8E%B0%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D-toc" style="margin-left:40px;"><a href="#13.4%20%E5%88%A9%E7%94%A8set%E5%AE%9E%E7%8E%B0%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D" rel="nofollow">13.4 利用set实现数组去重</a></p> 
<p id="14%20promise%E5%AF%B9%E8%B1%A1%E8%A1%A5%E5%85%85-toc" style="margin-left:0px;"><a href="#14%20promise%E5%AF%B9%E8%B1%A1%E8%A1%A5%E5%85%85" rel="nofollow">14 promise对象补充</a></p> 
<p id="14.1%20%E6%A6%82%E8%BF%B0-toc" style="margin-left:40px;"><a href="#14.1%20%E6%A6%82%E8%BF%B0" rel="nofollow">14.1 概述</a></p> 
<p id="14.2%20%E7%89%B9%E7%82%B9-toc" style="margin-left:40px;"><a href="#14.2%20%E7%89%B9%E7%82%B9" rel="nofollow">14.2 特点</a></p> 
<p id="14.3%20%E7%90%86%E8%A7%A3-toc" style="margin-left:40px;"><a href="#14.3%20%E7%90%86%E8%A7%A3" rel="nofollow">14.3 理解</a></p> 
<p id="15%20Symbol%E8%A1%A5%E5%85%85-toc" style="margin-left:0px;"><a href="#15%20Symbol%E8%A1%A5%E5%85%85" rel="nofollow">15 Symbol补充</a></p> 
<p id="15.1%20Symbol%E6%A6%82%E5%BF%B5-toc" style="margin-left:40px;"><a href="#15.1%20Symbol%E6%A6%82%E5%BF%B5" rel="nofollow">15.1 Symbol概念</a></p> 
<p id="15.2%20%E8%AF%AD%E6%B3%95-toc" style="margin-left:40px;"><a href="#15.2%20%E8%AF%AD%E6%B3%95" rel="nofollow">15.2 语法</a></p> 
<p id="15.3%20Symbol%20%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95-toc" style="margin-left:40px;"><a href="#15.3%20Symbol%20%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95" rel="nofollow">15.3 Symbol 高级用法</a></p> 
<p id="16%20js%E9%AB%98%E7%BA%A7%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A1%A5%E5%85%85-toc" style="margin-left:0px;"><a href="#16%20js%E9%AB%98%E7%BA%A7%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A1%A5%E5%85%85" rel="nofollow">16 js高级知识点补充</a></p> 
<p id="16.1%C2%A0hasOwnProperty%E6%96%B9%E6%B3%95-toc" style="margin-left:40px;"><a href="#16.1%C2%A0hasOwnProperty%E6%96%B9%E6%B3%95" rel="nofollow">16.1 hasOwnProperty方法</a></p> 
<p id="16.1.1%20%E8%AF%AD%E6%B3%95-toc" style="margin-left:80px;"><a href="#16.1.1%20%E8%AF%AD%E6%B3%95" rel="nofollow">16.1.1 语法</a></p> 
<hr id="hr-toc"> 
<p style="margin-left:40px;"></p> 
<h2 id="%E9%87%8D%E8%A6%81%E9%83%A8%E5%88%86%EF%BC%9B%E9%87%8D%E7%82%B9%E6%A0%87%E6%B3%A8%EF%BC%9B%E6%AC%A1%E9%87%8D%E8%A6%81%E6%A0%87%E6%B3%A8%EF%BC%9B%E7%90%86%E8%A7%A3%E8%AF%B4%E6%98%8E"><span style="color:#f33b45;">重要部分</span>&gt;<span style="color:#ffbb66;">重点标注</span>&gt;<span style="color:#86ca5e;">次重要标注</span>&gt;<span style="color:#e579b6;">理解说明</span>&gt;<span style="color:#3399ea;">补充说明</span></h2> 
<h2 id="1%20%E6%A6%82%E8%BF%B0">1 概述</h2> 
<h3 id="1.1%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%BB%8B%E7%BB%8D">1.1 面向对象介绍</h3> 
<p>（1）面向过程 POP</p> 
<p>分析出解决问题所需要的的步骤，然后用函数把这些步骤一步一步的实现</p> 
<p>（2）面向对象OOP</p> 
<p>把事务分解为一个个对象，然后由对象之间分工和合作</p> 
<p>（3）面向过程和面向对象的对比</p> 
<p><img alt="" height="152" src="https://images2.imgbox.com/d9/88/qoqiRoNH_o.png" width="830"></p> 
<h2 id="2%20ES6%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1">2 ES6中的类和对象</h2> 
<h3 id="2.1%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E7%BB%B4%E7%89%B9%E7%82%B9">2.1 面向对象思维特点</h3> 
<p><img alt="" height="286" src="https://images2.imgbox.com/03/9b/D0kkzbNT_o.png" width="722"></p> 
<h3 id="2.2%20%E5%AF%B9%E8%B1%A1">2.2 对象</h3> 
<p>万物皆对象，对象是一个具体的事物，看得见摸得着的实物，在</p> 
<p>js中对象是一组无序的相关属性和方法的集合，所有的事物都可以抽象为对象，属性事物的特征，方法事物的行为</p> 
<h3 id="2.3%20%E7%B1%BBclass">2.3 类class</h3> 
<p>类抽象了对象的公共部分，它泛指某一大类，对象特指某一个，通过类实例化一个具体的对象</p> 
<h3 id="2.4%20%E5%88%9B%E5%BB%BA%E7%B1%BB%C2%A0">2.4 创建类 </h3> 
<p>(1)创建类,class创建一个明星类,实例是类创建出来的对象</p> 
<blockquote> 
 <p>class Star{<!-- --></p> 
 <p>        constructor(uname) {<!-- --></p> 
 <p>         this.uname = uname;</p> 
 <p>        }</p> 
 <p>}</p> 
</blockquote> 
<p>(2)利用类创建对象new</p> 
<p>var ldh = new Star('刘德华');</p> 
<ul><li>通过class关键字创建类,类名还是首字母大写</li><li>类里面有个constructor函数,可以接受传递过来的参数,同时返回实例对象</li><li>constructor函数只要new生成示例时,就会自动调用这个函数,如果我们不写这个函数,类也会自动生成这个函数</li><li>生成示例new不能省略</li><li>最后注意语法规范,创建类,类名后面不要加小括号,生成实例 类名后面加小括号,构造函数不要加function</li><li>class中所有的函数不需要加function</li><li>所有的函数中间不加,分割</li></ul> 
<p><span style="color:#fe2c24;">(3)constructor 相当于创建的对象实例的构造函数的原型对象的constructor属性</span></p> 
<p>(4)class在constructor外声明公用函数,<span style="color:#86ca5e;"><strong>其并不属于创建对象的方法,但可以实现多个对象公用的功能,节省了空间</strong></span></p> 
<h3 id="2.5%20%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF"><span style="color:#f33b45;"><strong>2.5 类的继承</strong></span></h3> 
<h4 id="2.5.1%20%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF%E8%AF%AD%E6%B3%95%E8%A7%84%E8%8C%83">2.5.1 类的继承语法规范</h4> 
<blockquote> 
 <p>class Father {<!-- --></p> 
 <p>     constructor() {<!-- --></p> 
 <p>     }</p> 
 <p>}</p> 
 <p>class Son extends Father {<!-- --></p> 
 <p>     constructor() {<!-- --></p> 
 <p>           super()</p> 
 <p>     }</p> 
 <p>}</p> 
</blockquote> 
<h4 id="2.5.2%20super%E5%85%B3%E9%94%AE%E5%AD%97">2.5.2 super关键字</h4> 
<p>(1) super关键字</p> 
<p>调用了父类中的构造函数</p> 
<ul><li>子类的constructor中,可以使用super关键字,借用父类的constructor为子类的实例添加属性和方法</li></ul> 
<p>   <span style="color:#86ca5e;">注意:在子类的constructor没添加属性和方法之前,必须要先调用 super</span></p> 
<ul><li>子类的实例可以调用父类的公共方法</li></ul> 
<p>   <span style="color:#86ca5e;">注意:实例调用方法的时候,会优先调用自身方法,如果没有则调用类的公共方法,如果没有则调用父类的公共方法.</span></p> 
<p>(2) super关键字调用父类的普通函数</p> 
<p>super.父类普通函数()  调用父类中的普通函数</p> 
<p>继承中属性或方法查找的原则:就近原则</p> 
<ul><li>继承中,如果实例化子类输出一个方法,先看子类有没有这个方法,如果有就先执行子类的</li><li>继承中,如果子类里面没有,就去查找父类有没有这个方法,如果有,就执行父类这个方法</li></ul> 
<p>(3) 实例：子类继承父类方法,同时扩展减法方法</p> 
<pre><code class="language-javascript"> // 父类有加法方法
        class Father {
            constructor(x, y) {
                this.x = x;
                this.y = y;
            }
            sum() {
                console.log(this.x + this.y);
            }
        }
        // 子类继承父类加法方法 同时 扩展减法方法
        class Son extends Father {
            constructor(x, y) {
                // 利用super 调用父类的构造函数
                // super 必须在子类this之前调用
                super(x, y); //已经从父类中继承获得x,y属性,不需再次创建

            }
            subtract() {
                console.log(this.x - this.y);

            }
        }
        var son = new Son(5, 3);
        son.subtract();
        son.sum();</code></pre> 
<p>在ES6中没有变量提升,所以必须先定义类,才能通过类实例化对象</p> 
<p><span style="color:#ffbb66;">类里面的共有属性和方法一定要加this并使用super，表示复制父类的属性和方法,在继承时必须书写</span></p> 
<h4 id="2.5.3%20this%E7%9A%84%E6%8C%87%E5%90%91%E9%97%AE%E9%A2%98">2.5.3 this的指向问题</h4> 
<p>(1)this指向的是并不是特定的对象,而是在运行中,谁调用就指向谁</p> 
<p>(2)constructor里面的this指向的是实例对象(<span style="color:#e579b6;"><strong>new关键词创建新实例时,会调用构造函数,而构造函数本身this并没有什么意义,只有在new时才会变化,并将this指向实例</strong></span>)</p> 
<h3 id="2.6%20%E6%B7%BB%E5%8A%A0%E6%96%B0%E5%85%83%E7%B4%A0%E6%96%B0%E6%96%B9%E6%B3%95">2.6 添加新元素新方法</h3> 
<p>（1）element.insertAdjacentHTML(position,text)</p> 
<p>不同于appendChild，这可以直接追加字符串识别为新标签，把text添加到父元素的指定位置。</p> 
<p>position取值</p> 
<p>beforebegin：插入到标签开始前——前面的兄弟</p> 
<p>afterbegin：插入到标签开始标记之后——第一个子标签</p> 
<p>beforeend：插入到标签结束标记——最后一个子标签</p> 
<p>afterend：插入到标签结束标记后——后面的兄弟</p> 
<h2 id="3%20js%E6%B3%A8%E6%84%8F%E7%82%B9%E5%92%8C%E8%A1%A5%E5%85%85"><span style="color:#3399ea;">3 js注意点和补充</span></h2> 
<p>（1）<em>getElementsByTagName和getElementsByClassName是一个动态的集合（页面结构发生变化-删除添加）结果也会自动变化</em></p> 
<p>（2）<img alt="" height="56" src="https://images2.imgbox.com/10/89/FJOcukah_o.png" width="472">（防止index小于1，无法获取到元素的写法）</p> 
<p>（3）获取元素时如果没有获取到，得到的结果是null。</p> 
<p>（4）if 语句可以简写，如果花括号内只有一句话可以省略，但是有两句话以上时，不可以省略</p> 
<p><em>（5）window.getSelection().toString获得选定的文字</em></p> 
<h2 id="4%20%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E5%8E%9F%E5%9E%8B">4 构造函数和原型</h2> 
<h3 id="4.1%20%E6%A6%82%E8%BF%B0">4.1 概述</h3> 
<p><img alt="" height="330" src="https://images2.imgbox.com/97/cd/3dm96JjT_o.png" width="839"></p> 
<h3 id="4.2%20%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span style="color:#f33b45;">4.2 构造函数</span></h3> 
<p><img alt="" height="287" src="https://images2.imgbox.com/4d/32/aQptg4da_o.png" width="743"></p> 
<h4 id="4.2.1%20%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%92%8C%E5%AE%9E%E4%BE%8B%E6%88%90%E5%91%98">4.2.1 静态成员和实例成员</h4> 
<p>（1）静态成员（<span style="color:#86ca5e;">构造函数本身的属性和方法</span>）</p> 
<p>在构造函数本身上添加的成员</p> 
<p>静态成员只能通过构造函数来访问</p> 
<p>（2）实例成员（<span style="color:#86ca5e;">构造函数创建出来的对象中的属性和方法</span>）</p> 
<p>就是构造函数内部通过this添加的成员实例成员只能通过实例化的对象来访问（不可以通过构造函数来访问）</p> 
<h3 id="4.3%20%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8Bprototype">4.3 构造函数原型prototype</h3> 
<p>原型对象：每一个构造函数都有这个属性</p> 
<ul><li>我们可以把那些不变的方法，直接定义在prototype对象中，这样所有的实例就可以<span style="color:#ffbb66;"><u><strong>共享这些方法</strong></u></span></li><li>一般情况下，我们<span style="color:#86ca5e;">公共属性定义到构造函数里面，公共的方法我们放在原型对象身上</span></li><li>原型对象在函数对象被创建的时候就一起就创建了</li><li>原型对象的属性和方法，能够被函数创建的实例调用</li><li>实例调用属性、方法的时候，如果自身已经有了该属性、方法，则不会调用原型对象的属性和方法</li><li>实例对象中没有prototype中的属性和方法，但是可以被实例调用</li></ul> 
<h3 id="4.4%20%E5%AF%B9%E8%B1%A1%E5%8E%9F%E5%9E%8B__proto__%EF%BC%88%E4%B8%A4%E8%BE%B9%E6%98%AF%E4%B8%A4%E4%B8%AA%E4%B8%8B%E5%88%92%E7%BA%BF%EF%BC%89">4.4 对象原型__proto__（两边是两个下划线）</h3> 
<p>（1）对象会有一个属性__proto__指向构造函数中的原型对象</p> 
<p>对象身上系统自动添加一个__proto__，<span style="color:#ffbb66;">对象中的原型和构造函数中的原型对象是等价的</span></p> 
<p>（2）方法查找规则：首先先看ldh对象身上是否有sing方法，如果有就执行这个对象上的sing</p> 
<p>如果没有这个方法，因为有__proto__的存在，就去构造函数原型对象prototype身上去查找sing这个方法</p> 
<p>__proto__对象原型的意义就在于为对象的查找机制提供一个方向，或者说一条路线，但是他是一个非标准属性，因此实际开发中，不可以使用这一个属性（<span style="color:#86ca5e;"><em>可以修改，但是修改后改变的是构造函数中的原型对象，而不是实例中__proto__，所以实际开发中不推荐这么使用</em></span>），它只是内部指向原型对象prototype</p> 
<p><img alt="" height="197" src="https://images2.imgbox.com/3a/ac/XC5vyCSE_o.png" width="590"></p> 
<h3 id="4.5%20%E5%8E%9F%E5%9E%8Bconstructor">4.5 原型constructor</h3> 
<p>实例的对象原型和构造函数原型对象里面都有一个constructor属性，这个属性我们称为构造函数，因为它指回构造函数本身</p> 
<p><span style="color:#e579b6;">constructor： 构造函数名（原型对象中constructor相当这个操作）</span></p> 
<h3 id="4.6%20%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E3%80%81%E5%AE%9E%E4%BE%8B%E3%80%81%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1%E4%B8%89%E8%80%85%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB">4.6 构造函数、实例、原型对象三者之间的关系</h3> 
<p><img alt="" height="354" src="https://images2.imgbox.com/ca/56/6nARjznR_o.png" width="588"></p> 
<h3 id="4.7%20%E5%8E%9F%E5%9E%8B%E9%93%BE"><span style="color:#f33b45;">4.7 原型链</span></h3> 
<p>（1）只要有对象就有__proto__原型，指向原型对象（<span style="color:#e579b6;"><strong>相当于每个对象都是由一个构造函数（Object）实例化的（可以这么理解，因为可以通过var xx = new Object（）创建空对象，），并由__proto__指向它Object的原型对象</strong></span>）</p> 
<p>（2）我们star原型对象里面的__proto__原型指向的是Object.prototype</p> 
<p><img alt="" height="361" src="https://images2.imgbox.com/ad/ab/fZK9gImB_o.png" width="813"></p> 
<p>对象原型__proto__来自于构造函数的原型对象，在实例中展示的是原型对象。</p> 
<p><span style="color:#38d8f0;">(3) 补充:</span></p> 
<p><span style="color:#38d8f0;">通过构造函数实例化的对象,__proto__指向构造函数的原型对象,然后原型对象中__proto__指向Object构造函数,但构造函数本身的__proto__指向为Function这个构造函数,然后再指向Object构造函数</span></p> 
<h3 id="4.8%20%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1%E4%B8%ADthis%E7%9A%84%E6%8C%87%E5%90%91">4.8 原型对象中this的指向</h3> 
<p>原型对象函数里面的this指向的是，实例对象（一般情况）</p> 
<h3 id="4.9%20%E6%89%A9%E5%B1%95%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1">4.9 扩展内置对象</h3> 
<p> <span style="color:#ffbb66;">（1）Object.getPrototypeOf（实例对象）返回的是构造函数的原型对象。</span></p> 
<p>可以通过原型对象，对原来的内置对象进行扩展自定义的方法，比如给数组增加自定义方法</p> 
<p><span style="color:#e579b6;"><em>（Object和Array是每一个对象和数组通过对象原型指向原型对象的构造函数（通过构造函数创建的实例，会先指向构造函数的原型对象，后指向Object或Array中的原型对象），他原型对象的方法便成为了js中的内置数组或对象方法）</em></span></p> 
<p>内置的构造函数Object等是不允许赋值的</p> 
<h2 id="5%20%E7%BB%A7%E6%89%BF">5 继承</h2> 
<p>ES6之前，没有extends继承，通过构造函数+原型对象模拟继承，被称为组合继承</p> 
<h3 id="5.1%20call%EF%BC%88%EF%BC%89">5.1 call（）</h3> 
<p>（1）call（）方法可以调用函数fn.call（）</p> 
<p><span style="color:#f33b45;"><strong>（2）修改函数里面的this指向</strong></span></p> 
<p>fn.call（需要被指向的对象，函数原来的参数）相当于通过call方法，让此对象调用函数。<em>call使用时函数不加括号，加在call后面</em></p> 
<h3 id="5.2%20%E5%88%A9%E7%94%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%BB%A7%E6%89%BF%E7%88%B6%E7%B1%BB%E5%9E%8B%E4%B8%AD%E7%9A%84%E5%B1%9E%E6%80%A7">5.2 利用构造函数继承父类型中的属性</h3> 
<p><img alt="" height="292" src="https://images2.imgbox.com/5c/f6/c5a4BZit_o.png" width="388"></p> 
<p>Son.Prototype = Father.Prototype只是将父原型对象地址给子原型对象，他们指向的是同一个数据，所以修改son的原型对象也是在修改父原型对象</p> 
<p>Son.prototype = new Father();通过这种方式才可以<span style="color:#e579b6;"> //相当于将Son的原型对象变为father的实例对象，而他的__proto__指向father的原型对象prototype，所以son的实例也通过__proto__指向son的原型对象prototype</span></p> 
<p>Son.prototype.constructor = son如果利用对象的形式修改了原型对象，别忘了利用constructor指回原来的原型对象</p> 
<h2 id="6%20%E7%B1%BB%E7%9A%84%E6%9C%AC%E8%B4%A8">6 类的本质</h2> 
<p>类：创建对象的模板，本质还是一个函数，我们也可以简单的认为类就是构造函数的另外的一种写法</p> 
<ul><li>类有原型对象</li><li>类有constructor，并指回类的本身</li><li>类也可以通过原型对象，添加方法</li><li>语法糖：就是一种便捷写法，简单理解，有两种方法可以实现同样的功能，但是一种写法更加清晰、方便那么这个方法就是语法糖。</li></ul> 
<p><img alt="" height="451" src="https://images2.imgbox.com/8b/86/wLo6VYIj_o.png" width="362">这两种方式相同，后者是语法糖</p> 
<h2 id="7%20%E6%95%B0%E7%BB%84%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%92%8C%E9%81%8D%E5%8E%86%E6%96%B9%E6%B3%95">7 数组的迭代和遍历方法</h2> 
<h3 id="7.1%20%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95">7.1 数组方法</h3> 
<p>迭代方法： forEach（）、map（）、filter（）、some（）、every（）；</p> 
<h4 id="7.1.1%C2%A0%20forEach%EF%BC%88%EF%BC%89">7.1.1  forEach（）</h4> 
<p><img alt="" height="146" src="https://images2.imgbox.com/a3/78/SfnfSKVo_o.png" width="520"></p> 
<p>三个参数，分别表示，数组元素、数组元素的索引号、数组本身</p> 
<h4 id="7.1.2%20filter%EF%BC%88%EF%BC%89">7.1.2 filter（）</h4> 
<p>主要筛选数组，返回的是一个新的数组，三个参数，数组元素，索引，和数组</p> 
<p>return中写条件<img alt="" height="146" src="https://images2.imgbox.com/05/26/ZM9Ul3U8_o.png" width="507"></p> 
<p>返回return条件为true的值到新数组</p> 
<h4 id="7.1.3%20some%EF%BC%88%EF%BC%89%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E4%B8%AD%E6%98%AF%E5%90%A6%E6%9C%89%E6%BB%A1%E8%B6%B3%E6%9D%A1%E4%BB%B6%E7%9A%84%E5%85%83%E7%B4%A0">7.1.3 some（）查找元素中是否有满足条件的元素</h4> 
<p>返回值是布尔值，如果查找到这个元素，就是true，反之false，三个参数</p> 
<p>找到一个满足条件的元素，就停止循环。</p> 
<h4 id="7.1.4%20forEach%E5%92%8Csom%E7%9A%84%E5%8C%BA%E5%88%AB">7.1.4 forEach和som的区别</h4> 
<p>（1）<span style="color:#86ca5e;">forEach中return不会终止迭代（遍历元素）</span></p> 
<p>（2）在some中遇到return true会终止遍历，效率更高（<span style="color:#86ca5e;">return true代表条件满足，有第一个满足条件的元素就会终止</span>）</p> 
<p>（3）filter不会终止迭代</p> 
<p>（4）如果在数组找唯一的元素，最好用some。</p> 
<h3 id="7.2%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%96%B9%E6%B3%95">7.2 字符串方法</h3> 
<p>（1）trim方法</p> 
<p>去除字符串两侧空格，ele.trim（），返回一个新的字符串，不会去掉中间的空格</p> 
<h3 id="7.3%20Object%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95">7.3 Object静态方法</h3> 
<h4 id="7.3.1%20object.keys(obj%EF%BC%89">7.3.1 object.keys(obj）</h4> 
<p>用于获取对象自身所有的属性</p> 
<p>相当于for i in k</p> 
<p>返回一个由属性名组成的数组</p> 
<h4 id="7.3.2%20%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7%E7%9A%84%E7%9B%B8%E5%85%B3%E7%89%B9%E5%BE%81">7.3.2 定义属性的相关特征</h4> 
<p>（1）Object.defineProperty()定义对象中新属性或修改原有的属性</p> 
<p>Object.defineProperty(对象，"添加或修改的属性"，descriptor（以对象形式{}书写）)：</p> 
<p>descriptor：</p> 
<ul><li>value：设置属性的值，默认为undefined</li><li>writable：值是否可以重写。true | false 默认为false</li><li>enumerate：目标属性是否可以被遍历。true | false 默认为false</li><li>configurable：目标属性是否可以被删除或是否可以再次修改特性true | false 默认为false</li></ul> 
<h2 id="8%20%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6">8 函数进阶</h2> 
<h3 id="8.1%20%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E8%B0%83%E7%94%A8">8.1 函数的定义和调用</h3> 
<h4 id="8.1.1%20%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89%E6%96%B9%E5%BC%8F">8.1.1 函数定义方式</h4> 
<p>（1）函数声明function关键字（命名函数）</p> 
<p>（2）函数表达式</p> 
<p>var fn = function（） {}</p> 
<p>（3）利用new Function（‘参数一’，‘参数二’，...，‘函数体’）</p> 
<p>var f = new Function（‘console.log（123）’）</p> 
<ul><li>函数体和参数都是以字符串的形式书写</li><li>第三种方式执行效率低</li><li>所有的函数都是Function的实例（对象）</li><li>函数也属性对象</li></ul> 
<p><img alt="" height="219" src="https://images2.imgbox.com/34/ae/zNItqMXz_o.png" width="675"></p> 
<h4 id="8.1.2%20%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%96%B9%E5%BC%8F">8.1.2 函数调用方式</h4> 
<p>（1）普通函数</p> 
<p>fn（）；fn.call();</p> 
<p>（2）对象的方法</p> 
<p>var o = {sayHi:function(){}}; o.sayHi</p> 
<p>（3）构造函数</p> 
<p>function Star（） {}； new Star();</p> 
<p>(4)绑定事件函数</p> 
<p>btn.onclick = function() {}; //触发事件调用</p> 
<p>(5)定时器函数</p> 
<p>每个一段时间调用一次</p> 
<p>(6)立即执行函数 自己调用</p> 
<h3 id="8.2%20this%E7%9A%84%E5%87%BD%E6%95%B0%E6%8C%87%E5%90%91">8.2 this的函数指向</h3> 
<h4 id="8.2.1%20this%E7%9A%84%E6%8C%87%E5%90%91">8.2.1 this的指向</h4> 
<p>(1)普通函数——window</p> 
<p>(2)对象的方法------对象</p> 
<p>(3)构造函数--------指向实例对象</p> 
<p>(4)绑定事件函数-------指向函数的调用者,事件源</p> 
<p>(5)定时器函数-------指向window</p> 
<p>(6)立即执行函数--------指向window</p> 
<h4 id="8.2.2%20%E6%94%B9%E5%8F%98%E5%87%BD%E6%95%B0%E5%86%85%E9%83%A8this%E6%8C%87%E5%90%91">8.2.2 改变函数内部this指向</h4> 
<p>(1)call方法 fn.call(被指向的对象,函数参数)</p> 
<p>主要作用可以实现继承</p> 
<pre><code class="language-javascript">var obj = {

name: 123,

fun: function() {

    console.log(this)  

    function fn() {

        console.log(this)

    }

    fn() 

    fn.call(this) 

    }
    
}

obj.fun.call(this) //window window window</code></pre> 
<p>第一步:改变对象方法的指向为window；第二步：方法内函数fn改变为对象的this指向(此时this已被改变为window),所以输出结果window window</p> 
<p>(2)apply调用函数,也可以改变函数内部this的指向</p> 
<ul><li>但是他的<span style="color:#86ca5e;">参数必须是数组形式(伪数组)apply(被指向的对象,['1','2'])</span></li><li>apply的主要应用:</li><li>利用apply借助数学内置对象求最大值等:Math.max.apply(Math, 数组) <span style="color:#e579b6;"><em>//指向没有改变,所以只是相当于调用Math.max方法,数组(apply传参方式)为此方法本来需要传递的参数.</em></span></li></ul> 
<p>(3) <span style="color:#f33b45;">bind方法 绑定的意思</span></p> 
<p>fn.bind(被指向的对象)</p> 
<ul><li><span style="color:#ffbb66;">不会调用原来的函数</span></li><li>可以改变原来函数内部的this指向</li><li>返回的是原函数改变this之后产生的新函数,不会改变原函数</li></ul> 
<p>新函数传参进去会把形参替换成实参后,生成新函数(但形参的位置和形式还在)</p> 
<p>新函数不传参,形参不被替换,可以正常使用新函数的形参</p> 
<p>如果有的函数我们不需要立即调用,但是又想改变这个函数内部的this指向此时用bind</p> 
<h3 id="8.3%20%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F">8.3 严格模式</h3> 
<p><img alt="" height="297" src="https://images2.imgbox.com/87/eb/AoIEJOyw_o.png" width="732"></p> 
<h4 id="8.3.1%20%E5%BC%80%E5%90%AF%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F">8.3.1 开启严格模式</h4> 
<p>(1)为脚本开启</p> 
<p>最上面写,为整个脚本开启严格模式</p> 
<p></p> 
<p>(2)为函数开启严格模式</p> 
<p></p> 
<p>function fn() {<!-- --></p> 
<p>'use strict';</p> 
<p>//函数内部下面按照严格模式执行</p> 
<p>}</p> 
<p></p> 
<h4 id="8.3.2%20%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F%E4%B8%AD%E7%9A%84%E5%8F%98%E5%8C%96">8.3.2 严格模式中的变化</h4> 
<p>(1)变量</p> 
<p><img alt="" height="104" src="https://images2.imgbox.com/0e/f3/vu1zCpiq_o.png" width="718"></p> 
<p>(2)严格模式this的指向</p> 
<p><img alt="" height="273" src="https://images2.imgbox.com/83/60/p3BSIr5t_o.png" width="528"></p> 
<p>(3)函数的变化</p> 
<p><img alt="" height="91" src="https://images2.imgbox.com/88/d2/cD5s4D3C_o.png" width="694"></p> 
<p>不能再函数之外的{}中声明函数</p> 
<h3 id="8.4%20%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0">8.4 高阶函数</h3> 
<p>是对其他函数进行操作的函数,它接收函数作为参数或将函数作为返回值输出</p> 
<p><img alt="" height="271" src="https://images2.imgbox.com/bd/d4/rK4b0wLh_o.png" width="842"></p> 
<h3 id="8.5%20%E9%97%AD%E5%8C%85*"><br><span style="color:#f33b45;">8.5 闭包*</span></h3> 
<h4 id="8.5.1%20%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F">8.5.1 变量作用域</h4> 
<p><img alt="" height="152" src="https://images2.imgbox.com/80/c1/kH9PG5Mq_o.png" width="380"></p> 
<h4 id="8.5.2%20%E4%BB%80%E4%B9%88%E6%98%AF%E9%97%AD%E5%8C%85">8.5.2 什么是闭包</h4> 
<p>闭包指可以被另外一个函数访问其变量的函数</p> 
<p>就是一个作用域可以访问另一个作用域中的变量</p> 
<p>function fn() {<!-- --></p> 
<p>            var num = 10;</p> 
<p>            function fun() {<!-- --></p> 
<p>                console.log(num);</p> 
<p>            }</p> 
<p>            return fun</p> 
<p>        }</p> 
<p>        var r = fn();</p> 
<p>        r();</p> 
<p>        console.dir(r);</p> 
<p><span style="color:#ffbb66;"><u>闭包的主要作用,延伸了变量的作用范围</u></span></p> 
<p><span style="color:#e579b6;"><em>上层作用域的变量，会通过[[Scopes]]属性存在闭包函数中，而这个属性中的 Closure对象就是我们需要的闭包数据，上层作用域里的变量数据,所以,造成内存被占用,一直不释放,数据较多时，会造成内存泄漏.可以实现外部访问闭包函数.一个作用域的变量互通</em></span></p> 
<p><img alt="" height="390" src="https://images2.imgbox.com/f1/8e/wJkEYQa3_o.png" width="752"></p> 
<p><span style="color:#3399ea;">立即执行函数也称为小闭包</span></p> 
<h3 id="8.6%20%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0">8.6 递归函数</h3> 
<h4 id="8.6.1%20%E4%BB%80%E4%B9%88%E6%98%AF%E9%80%92%E5%BD%92">8.6.1 什么是递归</h4> 
<p>如果一个函数内部可以调用其本身，这个函数就是递归函数</p> 
<p>使用递归，很容易发生栈溢出，所以需要加退出条件（<em>递归函数会等待函数调用完成，满足退出条件后，才依次结束</em>）</p> 
<pre><code class="language-javascript">&lt;script&gt;

        var data = [{
            id: 1,
            name: '家电',
            goods: [{
                id: 11,
                gname: '冰箱',
                goods: [{
                        id: 111,
                        gname: '海尔'
                    }, {
                        id: 112,
                        gname: '美的'
                    },
                ]
            }, {
                id: 12,
                gname: '洗衣机'
            }]
        }, {
            id: 2,
            name: '服饰'
        }];
        // 我们想要做输入id号,就可以返回的数据对象
        // 1. 利用 forEach 去遍历里面的每一个对象
        function getID(json, id) {
            var o = {};
            json.forEach(function(item) {
                // console.log(item); // 2个数组元素
                if (item.id == id) {
                    // console.log(item);
                    o = item;
                    return o;
                    // 2. 我们想要得里层的数据 11 12 可以利用递归函数
                    // 里面应该有goods这个数组并且数组的长度不为 0 
                } else if (item.goods &amp;&amp; item.goods.length &gt; 0) {
                    o = getID(item.goods, id);     //getID这里只是一次函数的调用，和原函数getID是两个不同的函数，
//有不用的作用域，所以这两者的变量不通用，这里的调用给o赋值并不会改变原本o的值，所以需要o来重新接受该函数的返回值。
                }
            });
            return o;
        }
        console.log(getID(data, 1));
        console.log(getID(data, 2));
        console.log(getID(data, 11));
        console.log(getID(data, 12));
        console.log(getID(data, 111));
    &lt;/script&gt;</code></pre> 
<h3 id="8.7%20%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D">8.7 浅拷贝和深拷贝</h3> 
<p>浅拷贝只是拷贝一层，对深层次对象级别的只拷贝引用</p> 
<p>深拷贝拷贝多层，每一级别的属性都会拷贝</p> 
<p>浅拷贝语法糖：Object.assign(需要拷贝, 被拷贝的数据 ); </p> 
<p>深拷贝语法：</p> 
<p><span style="color:#ffbb66;">// 深拷贝拷贝多层，每一级别的数据都会拷贝</span></p> 
<pre><code class="language-javascript">        var obj = {
            id: "1",
            name: "andy",
            msg: {
                age: 18
            },
            color: ['pink', 'red']
        }
        var o = {};
        // 封装函数
        function deepCopy(newObj, oldObj) {
            for (var k in oldObj) {
                // 判断我们的属性属于那种数据类型
                // 1. 获取属性值  oldObj[k]
                var item = oldObj[k];
                // 2. 判断这个值是否是数组
                if (item instanceof Array) {
                    newObj[k] = [];
                    deepCopy(newObj[k], item);
                } else if (item instanceof Object) {
                    // 3. 判断这个值是否是对象
                    newObj[k] = {};
                    deepCopy(newObj[k], item);
                } else {
                    // 4. 属于简单数据类型
                    newObj[k] = item;
                }
            }
        }
        deepCopy(o, obj);</code></pre> 
<p><span style="color:#86ca5e;">数组也属一种特殊的对象，所以写深拷贝时需要先写数组，</span></p> 
<h2 id="9%20%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%88%E5%90%AC%E8%AF%B4%E9%9D%9E%E5%B8%B8%E7%AE%80%E5%8D%95%EF%BC%89">9 正则表达式（听说非常简单）</h2> 
<h3 id="9.1%20%E6%A6%82%E8%BF%B0">9.1 概述</h3> 
<p>匹配字符串中的字符组合，是有规律的一种表达式，作为一种对象存在</p> 
<p>（1）匹配输入框中内容（匹配）</p> 
<p>（2）替换过滤内容中的一些敏感词（替换）</p> 
<p>（3）从字符串中获取我们想要的特定部分。（提取）</p> 
<p>（4）验证表单是否符合规则（验证）</p> 
<h3 id="9.2%20%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E7%BC%BA%E7%82%B9">9.2 表达式的缺点</h3> 
<p><img alt="" height="141" src="https://images2.imgbox.com/cc/92/oDmKaNX3_o.png" width="732"></p> 
<h3 id="9.3%20%E5%88%9B%E5%BB%BA%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F">9.3 创建正则表达式</h3> 
<p>（1）利用RegExp对象来创建</p> 
<p>var 变量名 = new RegExp（）；</p> 
<p>（2）利用字面量创建 </p> 
<p>var 变量名 = /内容/</p> 
<h3 id="9.4%20%E6%B5%8B%E8%AF%95%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8Ftest%EF%BC%88%EF%BC%89%E6%96%B9%E6%B3%95">9.4 测试正则表达式test（）方法</h3> 
<p><img alt="" height="222" src="https://images2.imgbox.com/fa/79/FAO4ffAc_o.png" width="724"></p> 
<h3 id="9.5%20%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%AD%E7%9A%84%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6">9.5 正则表达式中的特殊字符</h3> 
<p>元字符： 有特殊意义的字符</p> 
<p>边界符^ $</p> 
<p>(1)/abc/包含即可</p> 
<p>(2)/^abc/必须以adc开头</p> 
<p>(3)/abc$/必须以abc结尾</p> 
<p>(4)/^abc$/精确匹配abc</p> 
<h3 id="9.6%20%E5%AD%97%E7%AC%A6%E7%B1%BB">9.6 字符类</h3> 
<p>[]有一系列字符可供选择,只要匹配其中一个就可以了</p> 
<p>[^abc$]三选一只有a或b或c这三个字母才返回true</p> 
<h4 id="9.6.1%20%5B-%5D%E8%8C%83%E5%9B%B4%E7%AC%A6">9.6.1 [-]范围符</h4> 
<p>[a-z]a到z的范围,26个英文字母有任意一个即可</p> 
<p>字符组合/^[a-zA-Z0-9]$/只能输入范围中的一个</p> 
<p>[^]尖括号里面的^代表取反</p> 
<p>| 将正则表达式一分为二，将需要或逻辑的表达式用小括号包裹起来，可以表示或。注意：在中括号中表示一个字符|</p> 
<h4 id="9.6.2%20%E9%87%8F%E8%AF%8D%E7%AC%A6">9.6.2 量词符</h4> 
<p>用来设定某个模式出现的次数,只修饰紧挨着 的前面的一部分,可以用圆括号包裹作为一部分</p> 
<p>*规定了出现了0次或很多次</p> 
<p>+规定了可以出现1次或很多次</p> 
<p>?相当于出现零次或一次</p> 
<p>{n}重复n次</p> 
<p>{n,}大于等于n次</p> 
<p>{n,m}n-m次</p> 
<p>（）表示的是优先级</p> 
<p>input事件,在表单元素输入的时候触发</p> 
<p>onchange事件，表单元素的值被改变、失去焦点</p> 
<p>onblur事件，时区焦点</p> 
<h3 id="9.7%20%E9%A2%84%E5%AE%9A%E4%B9%89%E7%B1%BB">9.7 预定义类</h3> 
<p><img alt="" height="204" src="https://images2.imgbox.com/00/70/6VUz0Zmk_o.png" width="694"></p> 
<h3 id="9.8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%AD%E7%9A%84%E6%9B%BF%E6%8D%A2">9.8正则表达式中的替换</h3> 
<p>replace（）</p> 
<p>ele.replace('被替换的字符'/正则表达式，替换的字符)</p> 
<p>replace只替换第一个满足条件的字符。</p> 
<p>解决方法： /表达式/[switch]</p> 
<p>switch也称修饰符，按照什么样的模式来匹配，有三种值</p> 
<p>g：全局匹配</p> 
<p>i： 忽略大小写</p> 
<p>gi：全局匹配+忽略大小写</p> 
<h2 id="10%20ES6%E7%AE%80%E4%BB%8B">10 ES6简介</h2> 
<h3 id="10.1%20let%E5%85%B3%E9%94%AE%E5%AD%97">10.1 let关键字</h3> 
<p>（1）特性：</p> 
<ul><li>let声明的变量只在所处于的块级有效 （用{}可以限制变量的使用范围：for循环中声明的i是局部变量）；</li><li>在一个大括号中，使用let关键字声明的变量才具有块级作用域，var关键字没有此特点</li><li>防止循环变量变为全局变量</li><li>使用let声明的变量没有变量提升</li><li>使用let声明的变量具有暂时性死区（一个块级作用域中，如果有变量生成，就只能使用声明的变量，声明前不能使用，声明之后可以正常使用（<span style="color:#86ca5e;"><em>全局变量的访问只能是在块级作用域中没有声明同名变量时有效，若存在同名变量也是依照暂时性死区看待</em></span>），使用var声明的变量具有变量提升</li></ul> 
<h3 id="10.2%20conset%E5%A3%B0%E6%98%8E%E5%B8%B8%E9%87%8F">10.2 conset声明常量</h3> 
<p>（1）作用：声明常量，常量就是值（内存地址）不能变化的量</p> 
<p>（2）特征：</p> 
<ul><li>具有块级作用域</li><li>没有变量提升</li><li>有暂时性死区</li><li>声明常量是必须赋初始值</li><li><span style="color:#ff9900;">常量赋值后，值不能修改（指的是值对应的内存地址不可更改，复杂数据类型数据结构内部的值可以更改，但复杂数据本身不可更改）</span></li></ul> 
<h3 id="10.3%20let%E3%80%81const%E3%80%81var%E7%9A%84%E5%8C%BA%E5%88%AB">10.3 let、const、var的区别</h3> 
<p><img alt="" height="294" src="https://images2.imgbox.com/e8/e0/B1KamJrr_o.png" width="661"></p> 
<h2 id="11%20%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC%EF%BC%88%E8%AF%AD%E6%B3%95%E7%B3%96%EF%BC%89">11 数据解构赋值（语法糖）</h2> 
<h3 id="11.1%20%E6%95%B0%E7%BB%84%E8%A7%A3%E6%9E%84">11.1 数组解构</h3> 
<ul><li>ES6中允许从数组中提取值，按照对应位置，对变量赋值，对象也可以实现解构。</li><li>数组解构  let[a, b, c] = arry允许我们按照一一对应的关系从数组中提取值，然后将值赋值给变量</li><li>假如对应的变量比数组中的元素多时，多出来的变量的值是undefined。</li><li>假如对应的变量比数组中的元素少时，只接受对应的值。</li><li><span style="color:#86ca5e;">使用'，，'空出来位置，可以跳跃赋值</span></li></ul> 
<h3 id="11.2%20%E5%AF%B9%E8%B1%A1%E8%A7%A3%E6%9E%84">11.2 对象解构</h3> 
<p>（1）对象解构允许我们使用变量的名字匹配对象的属性，匹配成功将对象属性的值赋值给变量</p> 
<p><img alt="" height="69" src="https://images2.imgbox.com/b2/f3/xvA8L1Zz_o.png" width="617"></p> 
<p>按照属性名称去匹配对应的数据，和顺序无关</p> 
<p>（2）匹配左侧属性名，匹配成功，将右侧属性的值赋值给左侧属性名冒号后的变量。</p> 
<p><img alt="" height="111" src="https://images2.imgbox.com/6e/9d/slFnjicR_o.png" width="576"></p> 
<p>这两者可以混合写</p> 
<h3 id="11.3%20%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0"><span style="color:#f33b45;">11.3 箭头函数</span></h3> 
<p>（1）箭头函数式用来简化函数定义语法的</p> 
<p>（） =&gt; {}；</p> 
<p>const fn = () =&gt; {}；</p> 
<p>（2）特点</p> 
<p>函数体中只有一句代码，且代码的执行结果就是返回值，可以省略大括号</p> 
<p>如果形参只有一个，可以省略小括号</p> 
<p>不能使用arguments</p> 
<h4 id="11.3.1%20%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0this">11.3.1 箭头函数this</h4> 
<p><span style="color:#ffbb66;">箭头函数不绑定this，箭头函数中的this，指向的是函数定义位置的上下文this，且永远不会被改变（且不会被bind，call等改变）</span></p> 
<h3 id="11.4%20%E5%89%A9%E4%BD%99%E5%8F%82%E6%95%B0">11.4 剩余参数</h3> 
<p>剩余参数语法允许我们将一个不定数量的参数表示为一个数组</p> 
<p>var fn （a，b，...demo）=&gt; console.log(demo);</p> 
<p><span style="color:#86ca5e;">剩余元素必须写在最后</span></p> 
<p>fn（11,22,33，44,22）//demo接收的是实参匹配形参后剩余的实参。</p> 
<h4 id="11.5%20%E6%89%A9%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6(%E5%B1%95%E5%BC%80%E8%AF%AD%E6%B3%95)">11.5 扩展运算符(展开语法)</h4> 
<p>var arr = [3, 5, 7] ...arr //3， 5， 7</p> 
<p>扩展运算符可以将数组拆分成逗号分隔的参数序列，console.log(..arr) //1 2 3</p> 
<p>应用：（1）合并数组 let arr1 = [1, 2, 3];  let arr2 = [4, 5, 6]; let arr3 = [...arr1,...arr2] 或者 arr1.push(...arr2);</p> 
<p>(2) 对象的扩展运算符</p> 
<p><img alt="" height="75" src="https://images2.imgbox.com/c5/3c/MFx44vKw_o.png" width="798"></p> 
<h2 id="12%20Array%E7%9A%84%E6%89%A9%E5%B1%95%E6%96%B9%E6%B3%95">12 扩展方法</h2> 
<h3 id="12.1%20Array.from()">12.1 Array.from()</h3> 
<p>将伪数组转换为真正数组的方法（<span style="color:#86ca5e;">使用的是构造函数Array的方法，不是实例方法</span>）</p> 
<p>参数：</p> 
<p>第一个参数表示要转换的伪数组</p> 
<p>第二参数是一个函数，数组中每一项需要处理的程序，该函数参数item可以接收元素的值，return后写处理的程序。</p> 
<h3 id="12.2%20%E6%95%B0%E7%BB%84%E5%AE%9E%E4%BE%8B%E7%9A%84%E6%96%B9%E6%B3%95">12.2 数组实例的方法</h3> 
<h4 id="12.2.1%C2%A0find%E6%96%B9%E6%B3%95">12.2.1 find方法</h4> 
<p>用于找出第一个符合条件的成员对象，如果没有找到返回undefined（也会遍历数组，如果找到第一项满足条件的结果就会停止遍历）</p> 
<p>array.find(item =&gt; 条件)</p> 
<h4 id="12.2.2%20findIndex%E6%96%B9%E6%B3%95">12.2.2 findIndex方法</h4> 
<p>用于找出第一个符合条件的数组成员的位置，如果没有找到返回-1</p> 
<p>array.findIndex(item =&gt; 条件)</p> 
<h4 id="12.2.3%20includes%E6%96%B9%E6%B3%95">12.2.3 includes方法</h4> 
<p>表示某个数组中是否包含给定的值，返回布尔值</p> 
<p>array.includes(需要判断的元素)</p> 
<p><span style="color:#86ca5e;">只能判断字符串</span></p> 
<h3 id="12.3%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95">12.3 字符串实例方法</h3> 
<h4 id="12.3.1%20startsWith%EF%BC%88%EF%BC%89%E5%92%8CendsWith%EF%BC%88%EF%BC%89">12.3.1 startsWith（）和endsWith（）</h4> 
<p>判断字符串是否以某一个字符开头或结尾，返回值是true和false</p> 
<h4 id="12.3.2%20repeat%E6%96%B9%E6%B3%95">12.3.2 repeat方法</h4> 
<p>表示将原字符串重复n次，返回一个新的字符串</p> 
<h2 id="13%20set%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">13 set数据结构</h2> 
<h3 id="13.1%20set%E5%88%9B%E5%BB%BA%E5%AE%9E%E4%BE%8B">13.1 set创建实例</h3> 
<p>ES6提供了新的数据结构Set，它类似于数组，但是成员的值都是唯一的，没有重复的值。</p> 
<ul><li>Set本身是一个构造函数，用来生成Set数据结构</li><li>Set创建实例的时候可以传递参数，作用初始值，实现初始化</li><li><span style="color:#86ca5e;">传递多个参数时，需要使用[]形式传入</span></li><li>set创建的实例不允许有重复的元素,假如传递的初始值有重复，会去重后存储（<span style="color:#86ca5e;">会把后面重复的去除，保留前面</span>）</li></ul> 
<p><span style="color:#3399ea;">set.size 属性可以得到set数据结构的长度</span></p> 
<h3 id="13.2%20set%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95">13.2 set实例方法</h3> 
<p>（1）add（value）：添加某个值，返回Set结构本身<span style="color:#86ca5e;">,可以链式添加，add("a").add('b').add('c')</span></p> 
<p>（2）delete（value）：删除某个值，返回一个布尔值，表示删除是否成功</p> 
<p>（3）has（value）：判断某一个值，是否数据结构中的一员，返回值是布尔值</p> 
<p>（4）clear（）：清空set数据结构中的值，返回set.size</p> 
<h3 id="13.3%20%E9%81%8D%E5%8E%86forEach">13.3 遍历forEach</h3> 
<p>使用方法与数组遍历相同</p> 
<h3 id="13.4%20%E5%88%A9%E7%94%A8set%E5%AE%9E%E7%8E%B0%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D">13.4 利用set实现数组去重</h3> 
<p>var arr = ['a', 'b', 'c', 'a'];</p> 
<p>arr = Array.from(new Set(arr));</p> 
<h2 id="14%20promise%E5%AF%B9%E8%B1%A1%E8%A1%A5%E5%85%85"><span style="color:#38d8f0;">14 promise对象补充</span></h2> 
<h3 id="14.1%20%E6%A6%82%E8%BF%B0">14.1 概述</h3> 
<p>Promise 对象代表了未来将要发生的事件，用来传递异步操作的消息。</p> 
<p>Promise作用：解决异步回调的问题</p> 
<p>（1）语法格式</p> 
<p>var promise = new Promise(function(resolve, reject) { // 异步处理</p> 
<p>// 处理结束后、调用resolve 或 reject });</p> 
<p><span style="color:#a2e043;">注意：通过使用函数将其封装起来，调用的时候和then方法一同调用</span></p> 
<h3 id="14.2%20%E7%89%B9%E7%82%B9">14.2 特点</h3> 
<p>(1) 对象的状态不受外界影响。Promise 对象代表一个异步操作，有三种状态：</p> 
<ul><li>pending: 初始状态，不是成功或失败状态。</li><li>fulfilled: 意味着操作成功完成。</li><li>rejected: 意味着操作失败。</li></ul> 
<p>只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是 Promise 这个名字的由来，它的英语意思就是「承诺」，表示其他手段无法改变。</p> 
<p>(2) 一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise 对象的状态改变，只有两种可能：从 Pending 变为 Resolved 和从 Pending 变为 Rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果。就算改变已经发生了，你再对 Promise 对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。</p> 
<p>(3) 对于已经实例化过的 promise 对象可以调用 promise.then() 方法，传递 resolve 和 reject 方法作为回调,<span style="color:#a2e043;">对异步的数据进行进一步的处理</span></p> 
<p>(4) 有了 Promise 对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，Promise 对象提供统一的接口，使得控制异步操作更加容易。</p> 
<p>(5) 要想创建一个 promise 对象、可以使用 new 来调用 Promise 的构造器来进行实例化。</p> 
<h3 id="14.3%20%E7%90%86%E8%A7%A3">14.3 理解</h3> 
<p>promise对象为了处理异步任务,所以他的then方法虽然是异步进程,但执行优先度高于一般的异步进程（微任务）.</p> 
<p>then方法的作用在于将Resolved和reject接收的异步进程数据,进行进一步的异步处理,</p> 
<h2 id="15%20Symbol%E8%A1%A5%E5%85%85"><span style="color:#38d8f0;">15 Symbol补充</span></h2> 
<h3 id="15.1%20Symbol%E6%A6%82%E5%BF%B5">15.1 Symbol概念</h3> 
<p>ES6中引入了一种新的原始数据类型</p> 
<p>常见的数据类型都有哪些</p> 
<p><img alt="" height="36" src="https://images2.imgbox.com/80/d1/bHcET60K_o.png" width="867"></p> 
<p>Symbol的作用</p> 
<p>可以表示独一无二的值，比如定义对象的唯一属性名，定义不会重复的常量等等</p> 
<h3 id="15.2%20%E8%AF%AD%E6%B3%95">15.2 语法</h3> 
<p>Symbol (description) // 描述信息可以有,也可以没有</p> 
<p>var s = Symbol();</p> 
<p>typeof s //Symbol</p> 
<p>注意点: </p> 
<ul><li>Symbol不是构造函数,不能使用new关键字,否则会有异常</li><li>Symbol() 括号中内容代表symbol的描述,只是为了方便辨识,并不是它的值</li><li>每一个Symbol类型数据都独一无二,不会相等</li><li>Symbol不能和其他值参与运算(不能进行隐式转换)</li><li>Symbol可以显示的转为字符串,布尔值,但是不能转为数字型</li></ul> 
<h3 id="15.3%20Symbol%20%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95">15.3 Symbol 高级用法</h3> 
<p>场景: 使用Symbol可以定义对象的唯一属性名</p> 
<p>这个属性不会被Object.keys或者for...in遍历到,起到保护个别隐私属性的作用</p> 
<p>var s = Symbol();</p> 
<p>var a = {};</p> 
<p>a[s] = "xxx";</p> 
<p>或者这种写法</p> 
<p><img alt="" height="125" src="https://images2.imgbox.com/99/8a/9ntCo8HM_o.png" width="152"></p> 
<p>注意点:</p> 
<ul><li>Symbol值作为对象的属性名时不能使用点运算符</li><li>如果要访问Symbol的值要用a[s]的形式访问</li><li>这个属性不会被Object.keys或者for...in遍历到</li></ul> 
<h2 id="16%20js%E9%AB%98%E7%BA%A7%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A1%A5%E5%85%85">16 js高级知识点补充</h2> 
<h3 id="16.1%C2%A0hasOwnProperty%E6%96%B9%E6%B3%95">16.1 hasOwnProperty方法</h3> 
<p>存在于构造函数Object的原型对象prototype的一个方法</p> 
<h4 id="16.1.1%20%E8%AF%AD%E6%B3%95">16.1.1 语法</h4> 
<p>实例对象调用此方法（传入一个参数，参数为需要判断的属性名）</p> 
<pre><code class="language-javascript">const obj = new Object
obj.name = 'zs'
console.log(obj.hasOwnProperty('name')) // true
console.log(obj.hasOwnProperty('age')) // false</code></pre> 
<p><span style="color:#ff9900;">注：此方法只能判断自身具有的属性，不能判断构造函数上拥有的属性或方法（false）</span></p> 
<h3>16.2 数组的fill方法</h3> 
<p>将数组的一部分内容替换成传入的值</p> 
<p>（1）语法</p> 
<pre><code class="language-javascript">let arr = [1, 2, 3]
arr.fill(5, 1, 2) // [1, 5, 3]
</code></pre> 
<p>（2）参数</p> 
<p>参数1：表示需要替换的值</p> 
<p>参数2：要替换的开始位置（从开始位置后替换）</p> 
<p>参数3：要替换的结束位置</p> 
<p><span style="color:#a2e043;">注意：当不传入参数的时候，将数组的全部内容替换</span></p> 
<h3>16.3 Object.assign() 方法</h3> 
<p>方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。</p> 
<p>（1）参数</p> 
<p>参数1：表示目标对象</p> 
<p>参数2-x：表示源对象</p> 
<p>（2）注意</p> 
<ul><li>该方法可以实现对象的浅拷贝，而不是对对象地址的引用（深拷贝）（<span style="color:#a2e043;">只能实现第一层的拷贝，如果对象的属性仍是复杂数据类型，则只是引用地址</span>）</li><li>Object.assign 会跳过那些值为 null 或 undefined 的源对象。</li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/469d1ac6e44c0456fbb241e3a0fca5d5/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">.gitignore文件用法及如何配置</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/33215bbbeb9bdfda4e5f95591ce493bd/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">openwrt默认应用源码路径</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>