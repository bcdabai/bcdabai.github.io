<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>JVM面试题 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="JVM面试题" />
<meta property="og:description" content="1、什么情况下会发生堆、栈内存溢出。 栈溢出：方法执行时创建的栈帧超过了栈的深度 ，最有可能就是方法递归调用。
堆溢出：heap space表示堆空间，堆中主要存储的是对象。不断的new对象会导致堆中的空间溢出
2、JVM的内存结构，Eden和Survivor比例。 JVM区域总体分两类，heap区和非heap区。
heap区又分为：
Eden Space（伊甸园）、Survivor Space(幸存者区)、Old Gen（老年代）。 非heap区又分：
Code Cache(代码缓存区)；Perm Gen（永久代）；（jdk1.8为元空间）Jvm Stack(java虚拟机栈)；Local Method Statck(本地方法栈)； 1个Eden区和2个Survivor区（分别叫from和to）。默认比例为8：1
3、JVM内存为什么要分成新生代，老年代，持久代。新生代中为什么要分为Eden和Survivor。 Eden和Survivor的比例是8:1.
首先说如果没有Survivor区会出现什么情况：此时每触发一次Minor GC，就会把Eden区的对象复制到老年代，这样当老年代满了之后会触发Major Gc(通常伴随着MinorGC，可以看做Full GC)，比较耗时。
如果只有1个Survivor区，那当Eden区满了之后，就会复制对象到Survivor区，容易产生内存碎片化。严重影响性能。
所以使用2个Survivor区，始终保持有一个空的Survivor区，可以避免内存碎片化。
Survivor减少被送到老年代的对象，进而减少Full GC的发生，Survivor的预筛选保证，只有经历多次Minor GC还能在新生代中存活的对象，才会被送到老年代。
4、JVM中一次完整的GC流程是怎样的，对象如何晋升到老年代，说说你知道的几种主要的JVM参 数。 对象诞生即新生代-&gt;eden，在进行minor gc过程中，如果依旧存活，移动到from，变成Survivor，进行标记代数，如此检查一定次数后，晋升为老年代。
https://wangkang007.gitbooks.io/jvm/content/jvmcan_shu_xiang_jie.html
5、垃圾回收算法的实现原理 引用计数，标记-清除，标记-整理，复制，分代收集
https://blog.csdn.net/zdp072/article/details/51116081
6、你知道哪几种垃圾收集器，各自的优缺点，重点讲下cms和G1，包括原理，流程，优缺点。 Serial、parNew、ParallelScavenge、SerialOld、ParallelOld、CMS、G1 CMS:
一、初始标记：此时标记需要用户线程停下来；
二、并发标记：此时标记可以和用户线程一起运行；
三、重新标记：此时标记需要用户线程停下来，主要母的是为了对并发标记的垃圾进行审核；
四、并发清除：与用户线程一起与运行进行垃圾清除；
缺点：
1、CMS收集器对cpu资源非常敏感；
2、CMS收集器无法清除浮动垃圾；
3、cms基于标记清除的算法实现的，所以内存碎片会产生过多。
G1收集器：
1、初始标记：标记GC Root能直接关联的对象，并且修改TAMS的值，让下一阶段的用户进行并发运行是，能够正确运用Region创建新对象，这阶段需要停顿，但停顿时间很短
2、并发标记：从GC Root开始对堆进行可达性分析，找出存活的对象，这段耗时较长，但可以与用户线程并发执行。
3、最终标记是为了修正在并发标记阶段因用户程序继续运作导致标记产生变动的那一部分的标记记录，虚拟机将这部分标记记录在线程Remembered Set中，这阶段需要停顿线程，但是可并行执行。
4、筛选回收：首先对各个Region的回收价值和成本进行排序，根据用户所期待的GC停顿时间来制定回收计划，这个阶段也可以与用户线程并行执行，但由于只回收一部分的Region,时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。
7、当出现了内存溢出，你怎么排错。 首先分析是什么类型的内存溢出，对应的调整参数或者优化代码。 https://wangkang007.gitbooks.io/jvm/content/4jvmdiao_you.html
8、JVM内存模型的相关知识了解多少，比如重排序，内存屏障，happen-before，主内存，工作 内存等。 内存屏障：为了保障执行顺序和可见性的一条cpu指令 重排序：为了提高性能，编译器和处理器会对执行进行重拍 happen-before：操作间执行的顺序关系。有些操作先发生。 主内存：共享变量存储的区域即是主内存 工作内存：每个线程copy的本地内存，存储了该线程以读/写共享变量的副本 9、简单说说你了解的类加载器，可以打破双亲委派么，怎么打破。 类加载器 就是根据指定全限定名称将class文件加载到JVM内存，转为Class对象。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/77f2078f53a4861636b4e2107b8c6fb5/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-08-22T11:22:20+08:00" />
<meta property="article:modified_time" content="2019-08-22T11:22:20+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">JVM面试题</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h4 style="margin-left:0pt;"><strong>1、什么情况下会发生堆、栈内存溢出。</strong></h4> 
<p>栈溢出：方法执行时创建的栈帧超过了栈的深度 ，最有可能就是方法递归调用。</p> 
<p>堆溢出：heap space表示堆空间，堆中主要存储的是对象。不断的new对象会导致堆中的空间溢出</p> 
<h4 style="margin-left:0pt;">2、JVM的内存结构，Eden和Survivor比例。</h4> 
<p>JVM区域总体分两类，heap区和非heap区。<br> heap区又分为：</p> 
<ul><li>Eden Space（伊甸园）、</li><li>Survivor Space(幸存者区)、</li><li>Old Gen（老年代）。</li></ul> 
<p>非heap区又分：</p> 
<ul><li>Code Cache(代码缓存区)；</li><li>Perm Gen（永久代）；（jdk1.8为元空间）</li><li>Jvm Stack(java虚拟机栈)；</li><li>Local Method Statck(本地方法栈)；</li></ul> 
<p> 1个Eden区和2个Survivor区（分别叫from和to）。默认比例为8：1</p> 
<h4 style="margin-left:0pt;">3、JVM内存为什么要分成新生代，老年代，持久代。新生代中为什么要分为Eden和Survivor。</h4> 
<blockquote> 
 <p>Eden和Survivor的比例是8:1.</p> 
</blockquote> 
<p>        首先说如果没有Survivor区会出现什么情况：此时每触发一次Minor GC，就会把Eden区的对象复制到老年代，这样当老年代满了之后会触发Major Gc(通常伴随着MinorGC，可以看做Full GC)，比较耗时。</p> 
<blockquote> 
 <p> </p> 
 <p>如果只有1个Survivor区，那当Eden区满了之后，就会复制对象到Survivor区，容易产生内存碎片化。严重影响性能。<br> 所以使用2个Survivor区，始终保持有一个空的Survivor区，可以避免内存碎片化。</p> 
</blockquote> 
<p style="margin-left:0pt;">Survivor减少被送到老年代的对象，进而减少Full GC的发生，Survivor的预筛选保证，只有经历多次Minor GC还能在新生代中存活的对象，才会被送到老年代。</p> 
<h4 style="margin-left:0pt;">4、JVM中一次完整的GC流程是怎样的，对象如何晋升到老年代，说说你知道的几种主要的JVM参 数。</h4> 
<p>对象诞生即新生代-&gt;eden，在进行minor gc过程中，如果依旧存活，移动到from，变成Survivor，进行标记代数，如此检查一定次数后，晋升为老年代。</p> 
<p><a href="https://wangkang007.gitbooks.io/jvm/content/jvmcan_shu_xiang_jie.html" rel="nofollow">https://wangkang007.gitbooks.io/jvm/content/jvmcan_shu_xiang_jie.html</a></p> 
<h4>5、垃圾回收算法的实现原理</h4> 
<p>引用计数，标记-清除，标记-整理，复制，分代收集</p> 
<p><a href="https://blog.csdn.net/zdp072/article/details/51116081">https://blog.csdn.net/zdp072/article/details/51116081</a></p> 
<h4 style="margin-left:0pt;">6、你知道哪几种垃圾收集器，各自的优缺点，重点讲下cms和G1，包括原理，流程，优缺点。</h4> 
<p>Serial、parNew、ParallelScavenge、SerialOld、ParallelOld、CMS、G1 </p> 
<p>CMS:<br> 一、初始标记：此时标记需要用户线程停下来；<br> 二、并发标记：此时标记可以和用户线程一起运行；<br> 三、重新标记：此时标记需要用户线程停下来，主要母的是为了对并发标记的垃圾进行审核；<br> 四、并发清除：与用户线程一起与运行进行垃圾清除；<br> 缺点：<br>      1、CMS收集器对cpu资源非常敏感；<br>      2、CMS收集器无法清除浮动垃圾；</p> 
<p>     3、cms基于标记清除的算法实现的，所以内存碎片会产生过多。</p> 
<p>G1收集器：</p> 
<p>    1、初始标记：标记GC Root能直接关联的对象，并且修改TAMS的值，让下一阶段的用户进行并发运行是，能够正确运用Region创建新对象，这阶段需要停顿，但停顿时间很短</p> 
<p>   2、并发标记：从GC Root开始对堆进行可达性分析，找出存活的对象，这段耗时较长，但可以与用户线程并发执行。</p> 
<p>    3、最终标记是为了修正在并发标记阶段因用户程序继续运作导致标记产生变动的那一部分的标记记录，虚拟机将这部分标记记录在线程Remembered Set中，这阶段需要停顿线程，但是可并行执行。</p> 
<p>   4、筛选回收：首先对各个Region的回收价值和成本进行排序，根据用户所期待的GC停顿时间来制定回收计划，这个阶段也可以与用户线程并行执行，但由于只回收一部分的Region,时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。</p> 
<p> </p> 
<h4 style="margin-left:0pt;">7、当出现了内存溢出，你怎么排错。</h4> 
<p>首先分析是什么类型的内存溢出，对应的调整参数或者优化代码。 </p> 
<p><a href="https://wangkang007.gitbooks.io/jvm/content/4jvmdiao_you.html" rel="nofollow">https://wangkang007.gitbooks.io/jvm/content/4jvmdiao_you.html</a></p> 
<h4 style="margin-left:0pt;">8、JVM内存模型的相关知识了解多少，比如重排序，内存屏障，happen-before，主内存，工作 内存等。</h4> 
<ul><li>内存屏障：为了保障执行顺序和可见性的一条cpu指令 </li><li>重排序：为了提高性能，编译器和处理器会对执行进行重拍 </li><li>happen-before：操作间执行的顺序关系。有些操作先发生。 </li><li>主内存：共享变量存储的区域即是主内存 </li><li>工作内存：每个线程copy的本地内存，存储了该线程以读/写共享变量的副本 </li></ul> 
<h4 style="margin-left:0pt;">9、简单说说你了解的类加载器，可以打破双亲委派么，怎么打破。</h4> 
<p>类加载器 就是根据指定全限定名称将class文件加载到JVM内存，转为Class对象。</p> 
<blockquote> 
 <ul><li>启动类加载器（Bootstrap ClassLoader）：由C++语言实现（针对HotSpot）,负责将存放在\lib目录或-Xbootclasspath参数指定的路径中的类库加载到内存中。</li><li>其他类加载器：由Java语言实现，继承自抽象类ClassLoader。如：</li><li>扩展类加载器（Extension ClassLoader）：负责加载\lib\ext目录或java.ext.dirs系统变量指定的路径中的所有类库。</li><li>应用程序类加载器（Application ClassLoader）。负责加载用户类路径（classpath）上的指定类库，我们可以直接使用这个类加载器。一般情况，如果我们没有自定义类加载器默认就是用这个加载器。</li></ul> 
</blockquote> 
<p>打破: 线程上下文加载器(Thread Context ClassLoader)   打破双亲委派机制则不仅要继承ClassLoader类，还要重写loadClass和findClass方法。</p> 
<p>1：自己写一个类加载器</p> 
<p>2：重写loadclass方法</p> 
<p>3：重写findclass方法</p> 
<h4 style="margin-left:0pt;">10、讲讲JAVA的反射机制。</h4> 
<p>Java程序在运行状态可以动态的获取类的所有属性和方法，并实例化该类，调用方法的功能 </p> 
<h4 style="margin-left:0pt;">11、你们线上应用的JVM参数有哪些。</h4> 
<p>-server （64位无需此参数）<br> Xms6000M <br> -Xmx6000M <br> -Xmn500M <br> -XX:PermSize=500M <br> -XX:MaxPermSize=500M <br> -XX:SurvivorRatio=65536 <br> -XX:MaxTenuringThreshold=0 <br> -Xnoclassgc <br> -XX:+DisableExplicitGC <br> -XX:+UseParNewGC <br> -XX:+UseConcMarkSweepGC <br> -XX:+UseCMSCompactAtFullCollection <br> -XX:CMSFullGCsBeforeCompaction=0 <br> -XX:+CMSClassUnloadingEnabled <br> -XX:-CMSParallelRemarkEnabled <br> -XX:CMSInitiatingOccupancyFraction=90 <br> -XX:SoftRefLRUPolicyMSPerMB=0 <br> -XX:+PrintClassHistogram <br> -XX:+PrintGCDetails <br> -XX:+PrintGCTimeStamps <br> -XX:+PrintHeapAtGC <br> -Xloggc:log/gc.log</p> 
<h4 style="margin-left:0pt;">12、G1和cms区别,吞吐量优先和响应优先的垃圾收集器选择。</h4> 
<p>Cms是以获取最短回收停顿时间为目标的收集器。基于标记-清除算法实现。比较占用cpu资源，切易造成碎片。 <br> G1是面向服务端的垃圾收集器，是jdk9默认的收集器，基于标记-整理算法实现。可利用多核、多cpu，保留分代，实现可预测停顿，可控。 、</p> 
<p><a href="https://blog.csdn.net/KilluaZoldyck/article/details/75081875">https://blog.csdn.net/KilluaZoldyck/article/details/75081875</a></p> 
<h4 style="margin-left:0pt;">13、怎么打出线程栈信息。</h4> 
<p>利用jps 、 top 、jstack命令找到进程中耗时最大的线程，以及线程状态等等，同时最后还可以显示出死锁的线程 查找：Found one Java-level deadlock 即可</p> 
<p><a href="https://my.oschina.net/liufukin/blog/2222495" rel="nofollow">https://my.oschina.net/liufukin/blog/2222495</a></p> 
<h4 style="margin-left:0pt;">14、请解释如下jvm参数的含义:</h4> 
<blockquote> 
 <p style="margin-left:0pt;">-server -Xms512m -Xmx512m -Xss1024K</p> 
 <p style="margin-left:0pt;">-XX:PermSize=256m -XX:MaxPermSize=512m -</p> 
 <p style="margin-left:0pt;">XX:MaxTenuringThreshold=20 XX:CMSInitiatingOccupancyFraction=80 -</p> 
 <p style="margin-left:0pt;">XX:+UseCMSInitiatingOccupancyOnly。</p> 
</blockquote> 
<p>Server模式启动 <br> 最小堆内存512m <br> 最大512m <br> 每个线程栈空间1m <br> 永久代256 <br> 最大永久代256 <br> 最大转为老年代检查次数20 <br> Cms回收开启时机：内存占用80% <br> 只以CMS的阈值来收集垃圾</p> 
<p>注释：</p> 
<p>-XX：+UseCMSInitiatingOccupancyOnly</p> 
<p>-XX+UseCMSInitiatingOccupancyOnly标志来命令JVM不基于运行时收集的数据来启动CMS垃圾收集周期。而是当该标志被开启时，JVM通过CMSInitiatingOccupancyFraction的值进行每一次CMS收集，而不仅仅是第一次。大多数情况下，JVM比我们自己能作出更好的垃圾收集决策。只有当我们充足的理由(比如测试)并且对应用程序产生的对象的生命周期有深刻的认知时，才应使用该标志。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ea16db43630bdcbf3ae01556d42bdcd8/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">在浏览器输入 URL 回车之后发生了什么（超详细版）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d5cb2e64d269541f2402b92f39640b09/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">06-Ubuntu18.04&amp;16.04安装PHP(7.0|7.1|7.2|7.3)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>