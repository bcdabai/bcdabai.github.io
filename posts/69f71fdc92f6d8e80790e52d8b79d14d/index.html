<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Python Web开发库之vcrpy 使用详解 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Python Web开发库之vcrpy 使用详解" />
<meta property="og:description" content="概要 在现代Web开发中，HTTP请求是不可避免的一部分。然而，通过网络发送HTTP请求可能会导致一些问题，如慢速响应、网络不稳定和API限制。为了解决这些问题，Python社区开发了一些工具和库，其中之一就是vcrpy。vcrpy是一个用于优化HTTP请求的强大工具，它可以捕获、回放和存储HTTP请求和响应，以提高测试效率和降低对外部服务的依赖。本文将详细介绍vcrpy的功能和用法，并提供丰富的示例代码来帮助大家深入了解它。
安装和导入vcrpy 要开始使用vcrpy，首先需要安装它。
可以使用pip进行安装：
pip install vcrpy 安装完成后，可以在Python中导入vcr模块：
import vcr 基本用法 vcrpy的基本思想是将HTTP请求和响应记录到磁盘上的“磁带”文件中，以便在以后的测试中回放。
以下是一个简单的示例，演示了如何使用vcrpy记录和回放HTTP请求：
import requests import vcr # 创建一个VCR对象来管理记录和回放 with vcr.use_cassette(&#39;example_cassette.yml&#39;): # 发送HTTP请求，并将响应存储到磁带中 response = requests.get(&#39;https://jsonplaceholder.typicode.com/posts/1&#39;) print(response.json()) # 在以后的测试中，可以回放磁带中的HTTP请求，而不必访问网络 在这个示例中，首先创建了一个VCR对象，然后使用with语句将HTTP请求和响应记录到名为example_cassette.yml的磁带文件中。在以后的测试中，可以回放这个磁带中的HTTP请求，而不必访问网络，从而提高测试的效率和稳定性。
高级用法
除了基本用法外，vcrpy还提供了一些高级功能，如过滤器、请求匹配和自定义存储等。
1. 过滤器 vcrpy可以定义一些过滤器，以过滤HTTP请求中的敏感信息，如API密钥或个人令牌。
以下是一个示例，演示了如何使用过滤器来屏蔽HTTP请求中的敏感信息：
import requests import vcr # 创建一个自定义过滤器，将所有请求中的&#34;Authorization&#34;头字段替换为&#34;FILTERED&#34; def custom_filter(r): r.headers[&#39;Authorization&#39;] = &#39;FILTERED&#39; return r with vcr.use_cassette(&#39;filtered_cassette.yml&#39;, before_record_response=custom_filter): response = requests.get(&#39;https://api.example.com/resource&#39;, headers={&#39;Authorization&#39;: &#39;Bearer my-secret-token&#39;}) print(response.json()) 在这个示例中，创建了一个名为custom_filter的自定义过滤器，它会将HTTP请求中的Authorization头字段替换为FILTERED，从而隐藏了敏感信息。
2. 请求匹配 vcrpy可以定义请求匹配规则，以便在回放时选择正确的磁带。这对于处理多个相似的HTTP请求非常有用。
以下是一个示例，演示了如何使用请求匹配规则：
import requests import vcr # 创建一个请求匹配规则，仅匹配GET请求，并且URL中包含&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/69f71fdc92f6d8e80790e52d8b79d14d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-12T10:22:23+08:00" />
<meta property="article:modified_time" content="2024-01-12T10:22:23+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Python Web开发库之vcrpy 使用详解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2><img alt="" height="466" src="https://images2.imgbox.com/9d/f3/4CnvnJUL_o.png" width="755"></h2> 
<hr> 
<h3>概要</h3> 
<p>在现代Web开发中，HTTP请求是不可避免的一部分。然而，通过网络发送HTTP请求可能会导致一些问题，如慢速响应、网络不稳定和API限制。为了解决这些问题，Python社区开发了一些工具和库，其中之一就是<code>vcrpy</code>。<code>vcrpy</code>是一个用于优化HTTP请求的强大工具，它可以捕获、回放和存储HTTP请求和响应，以提高测试效率和降低对外部服务的依赖。本文将详细介绍<code>vcrpy</code>的功能和用法，并提供丰富的示例代码来帮助大家深入了解它。</p> 
<hr> 
<h3>安装和导入vcrpy</h3> 
<p>要开始使用<code>vcrpy</code>，首先需要安装它。</p> 
<p>可以使用pip进行安装：</p> 
<pre><code>pip install vcrpy
</code></pre> 
<p>安装完成后，可以在Python中导入<code>vcr</code>模块：</p> 
<pre><code>import vcr
</code></pre> 
<h3 style="background-color:transparent;">基本用法</h3> 
<p><code>vcrpy</code>的基本思想是将HTTP请求和响应记录到磁盘上的“磁带”文件中，以便在以后的测试中回放。</p> 
<p>以下是一个简单的示例，演示了如何使用<code>vcrpy</code>记录和回放HTTP请求：</p> 
<pre><code>import requests
import vcr

# 创建一个VCR对象来管理记录和回放
with vcr.use_cassette('example_cassette.yml'):
    # 发送HTTP请求，并将响应存储到磁带中
    response = requests.get('https://jsonplaceholder.typicode.com/posts/1')
    print(response.json())
    
# 在以后的测试中，可以回放磁带中的HTTP请求，而不必访问网络
</code></pre> 
<p>在这个示例中，首先创建了一个<code>VCR</code>对象，然后使用<code>with</code>语句将HTTP请求和响应记录到名为<code>example_cassette.yml</code>的磁带文件中。在以后的测试中，可以回放这个磁带中的HTTP请求，而不必访问网络，从而提高测试的效率和稳定性。</p> 
<p style="background-color:transparent;">高级用法</p> 
<p>除了基本用法外，<code>vcrpy</code>还提供了一些高级功能，如过滤器、请求匹配和自定义存储等。</p> 
<h4>1. 过滤器</h4> 
<p><code>vcrpy</code>可以定义一些过滤器，以过滤HTTP请求中的敏感信息，如API密钥或个人令牌。</p> 
<p>以下是一个示例，演示了如何使用过滤器来屏蔽HTTP请求中的敏感信息：</p> 
<pre><code>import requests
import vcr

# 创建一个自定义过滤器，将所有请求中的"Authorization"头字段替换为"FILTERED"
def custom_filter(r):
    r.headers['Authorization'] = 'FILTERED'
    return r

with vcr.use_cassette('filtered_cassette.yml', before_record_response=custom_filter):
    response = requests.get('https://api.example.com/resource', headers={'Authorization': 'Bearer my-secret-token'})
    print(response.json())
</code></pre> 
<p>在这个示例中，创建了一个名为<code>custom_filter</code>的自定义过滤器，它会将HTTP请求中的<code>Authorization</code>头字段替换为<code>FILTERED</code>，从而隐藏了敏感信息。</p> 
<h4>2. 请求匹配</h4> 
<p><code>vcrpy</code>可以定义请求匹配规则，以便在回放时选择正确的磁带。这对于处理多个相似的HTTP请求非常有用。</p> 
<p>以下是一个示例，演示了如何使用请求匹配规则：</p> 
<pre><code>import requests
import vcr

# 创建一个请求匹配规则，仅匹配GET请求，并且URL中包含"/posts/"
my_matcher = vcr.matchers.RequestMatcher(method='GET', uri='/posts/')

with vcr.use_cassette('matcher_cassette.yml', match_on=[my_matcher]):
    response = requests.get('https://jsonplaceholder.typicode.com/posts/1')
    print(response.json())
</code></pre> 
<p>在这个示例中，创建了一个自定义的请求匹配规则<code>my_matcher</code>，它会匹配所有GET请求，且URL中包含<code>"/posts/"</code>的请求。这样，只有符合匹配规则的请求才会从磁带中回放。</p> 
<h4>3. 自定义存储</h4> 
<p><code>vcrpy</code>可以自定义存储后端，以便将HTTP请求和响应记录到不同类型的存储中，如数据库或云存储。</p> 
<p>以下是一个示例，演示了如何使用自定义存储后端：</p> 
<pre><code>import requests
import vcr

class MyCustomStorage(vcr.storages.BaseStorage):
    def store(self, cassette):
        # 在这里自定义存储逻辑
        pass

    def load(self):
        # 在这里自定义加载逻辑
        pass

# 创建一个VCR对象，指定自定义存储后端
my_storage = MyCustomStorage()
with vcr.use_cassette('custom_storage_cassette.yml', storage=my_storage):
    response = requests.get('https://jsonplaceholder.typicode.com/posts/1')
    print(response.json())
</code></pre> 
<p>在这个示例中，创建了一个名为<code>MyCustomStorage</code>的自定义存储后端，并将其传递给<code>VCR</code>对象。这允许你完全控制HTTP请求和响应的存储和加载过程。</p> 
<h3>实际应用场景</h3> 
<p>当使用<code>vcrpy</code>时，它可以在各种实际应用场景中发挥作用。以下是一些具体的示例代码，演示了如何在这些场景中使用<code>vcrpy</code>。</p> 
<h4>1. 单元测试</h4> 
<p>在编写单元测试时，<code>vcrpy</code>可以模拟外部服务的响应，以确保代码在不同情况下都能正常工作。</p> 
<p>以下是一个示例，演示了如何在Python的unittest框架中使用<code>vcrpy</code>进行单元测试：</p> 
<pre><code>import unittest
import vcr
import requests

class MyTestCase(unittest.TestCase):

    @vcr.use_cassette('test_data.yml')
    def test_api_request(self):
        response = requests.get('https://jsonplaceholder.typicode.com/posts/1')
        self.assertEqual(response.status_code, 200)

if __name__ == '__main__':
    unittest.main()
</code></pre> 
<p>在这个示例中，使用<code>vcr.use_cassette</code>装饰器来记录和回放HTTP请求，以模拟对外部API的请求。这样，可以在单元测试中使用真实的HTTP请求，同时也可以保持测试的稳定性和可重复性。</p> 
<h4>2. 集成测试</h4> 
<p>在执行集成测试时，<code>vcrpy</code>可以验证的应用程序与外部服务的交互是否正常。</p> 
<p>以下是一个示例，演示了如何在集成测试中使用<code>vcrpy</code>：</p> 
<pre><code>import pytest
import vcr
import requests

@pytest.fixture
def vcr_cassette():
    with vcr.use_cassette('integration_test.yml'):
        yield

def test_integration_with_external_api(vcr_cassette):
    response = requests.get('https://jsonplaceholder.typicode.com/posts/1')
    assert response.status_code == 200
</code></pre> 
<p>在这个示例中，使用pytest和pytest-vcr插件来执行集成测试。<code>vcr_cassette</code>是一个测试fixture，它使用<code>vcr.use_cassette</code>来记录和回放HTTP请求。这样，可以在集成测试中模拟对外部服务的交互，以验证应用程序的行为。</p> 
<h4>3. API开发</h4> 
<p>当开发和测试API时，<code>vcrpy</code>可以用于记录和回放API请求，以便更轻松地调试和验证API的行为。</p> 
<p>以下是一个示例，演示了如何在Flask应用中使用<code>vcrpy</code>进行API开发和测试：</p> 
<pre><code>import vcr
from flask import Flask, jsonify
import requests

app = Flask(__name__)

@app.route('/api/posts/&lt;int:post_id&gt;')
@vcr.use_cassette('api_test.yml')
def get_post(post_id):
    response = requests.get(f'https://jsonplaceholder.typicode.com/posts/{post_id}')
    return jsonify(response.json())

if __name__ == '__main__':
    app.run()
</code></pre> 
<p>在这个示例中，创建了一个简单的Flask API，它根据<code>post_id</code>参数获取外部API的数据。使用<code>vcr.use_cassette</code>来记录和回放API请求，以便在开发和测试过程中重复使用已记录的数据。</p> 
<h4>4. 数据抓取</h4> 
<p>在进行数据抓取时，<code>vcrpy</code>可以缓存和重复使用已下载的数据，以减少网络请求和提高效率。</p> 
<p>以下是一个示例，演示了如何使用<code>vcrpy</code>进行数据抓取：</p> 
<pre><code>import vcr
import requests

def fetch_data():
    with vcr.use_cassette('data_caching.yml'):
        response = requests.get('https://api.example.com/data')
        return response.json()

data = fetch_data()  # 第一次请求，数据被缓存到磁带中

# 在以后的请求中，数据将被从缓存中回放，而不必再次访问外部API
</code></pre> 
<p>在这个示例中，定义了一个<code>fetch_data</code>函数，它使用<code>vcr.use_cassette</code>来记录和回放数据抓取请求。第一次调用<code>fetch_data</code>时，数据被下载并缓存到磁带中。在以后的请求中，数据将从缓存中回放，而不必再次访问外部API，从而提高了数据抓取的效率。</p> 
<h3>总结</h3> 
<p><code>vcrpy</code>是一个强大的Python工具，用于优化HTTP请求。它可以捕获、回放和存储HTTP请求和响应，以提高测试效率和降低对外部服务的依赖。通过本文的介绍和示例代码，应该已经对<code>vcrpy</code>的功能和用法有了深入的了解，可以开始在自己的项目中使用它，以提高HTTP请求的效率和可靠性。</p> 
<p>如果你觉得文章还不错，请大家 点赞、分享、留言 下，因为这将是我持续输出更多优质文章的最强动力！</p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9d3e3fcbe4b7a1af28a4a68da2cead28/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">微信小程序显示和隐藏分享按钮</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/953b1cac4d710aa0643a94992a9b369e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">uniapp搜索附近蓝牙信标（iBeacon）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>