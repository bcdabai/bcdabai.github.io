<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【初阶数据结构与算法】第十篇——八大排序算法（头脑风暴逻辑分析&#43;动图详解一看就会&#43;代码分析信手捏来） - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【初阶数据结构与算法】第十篇——八大排序算法（头脑风暴逻辑分析&#43;动图详解一看就会&#43;代码分析信手捏来）" />
<meta property="og:description" content="🏆个人主页：企鹅不叫的博客
​ 🌈专栏
C语言初阶和进阶C项目Leetcode刷题初阶数据结构与算法C&#43;&#43;初阶和进阶 ⭐️ 博主码云gitee链接：代码仓库地址
⚡若有帮助可以【关注&#43;点赞&#43;收藏】，大家一起进步！
💙系列文章💙 【初阶数据结构与算法】第一篇：算法中的时间复杂度和空间复杂度
【初阶数据结构与算法】第二篇：顺序表
【初阶数据结构与算法】第三篇：单链表
【初阶数据结构与算法】第四篇：链表面试题详解
【初阶数据结构与算法】第五篇：双链表
【初阶数据结构与算法】第六篇：栈和队列（各个功能实现&#43;练习题包含多种方法）
【初阶数据结构与算法】第七篇：二叉树和堆的基本概念&#43;以及堆的实现
【初阶数据结构与算法】第八篇——二叉树的顺序结构的应用（堆排序&#43;TOPK问题）
【初阶数据结构与算法】第九篇——二叉树（链式结构实现&#43;四种遍历方式&#43;基本操作实现&#43;基本练习详解）
文章目录 💙系列文章💙🌏一、排序介绍🍯1.排序概念🍯2.排序分类 🌏二.插入排序🍯1.直接插入排序🍍基本思想🍍实现过程🍍时间复杂度、空间复杂度、稳定性分析 🍯2.希尔排序🍍基本思想🍍实现过程🍍时间复杂度、空间复杂度、稳定性分析 🌏三.选择排序🍯1.直接选择排序🍍基本思想🍍实现过程🍍时间复杂度、空间复杂度、稳定性分析 🍯2.堆排序（[详细介绍点这里](https://blog.csdn.net/YQ20210216/article/details/123938785?spm=1001.2014.3001.5501)）🍍基本思想🍍实现过程🍍时间复杂度、空间复杂度、稳定性分析 🌏四.交换排序🍯1.冒泡排序🍍基本思想🍍实现过程🍍时间复杂度、空间复杂度、稳定性分析 🍯2.快速排序（递归版本）🍍hoare版本🔑基本思想🔑实现过程 🍍挖坑法🔑基本思想🔑实现过程 🍍前后指针法🔑基本思想🔑实现过程 🍍时间复杂度、空间复杂度、稳定性分析🍍优化快速排序🔑选出中间值优化🌰基本思想和代码实现 🔑小区间优化🌰基本思想和代码实现 🍯3.快速排序（非递归版本）🍍基本思想🍍实现过程 🌏五.归并排序🍯1.递归实现🍍相较于其他排序的优势🍍基本思想🍍实现过程🍍时间复杂度、空间复杂度、稳定性分析 🍯2.非递归实现🍍基本思想🍍实现过程 🌏六.计数排序（非比较排序）🍍基本思想🍍实现过程🍍时间复杂度、空间复杂度、稳定性分析 🌏七.八大排序比较🍯1.性能测试代码🍯2.排序空间复杂度、时间复杂度、稳定性 🌏总结 前言 🌏一、排序介绍 🍯1.排序概念 ⭐️ 排序：所谓排序，就是使一串记录，按照其中的某个或某些关键字的大小，递增或递减的排列起来的操作。
⭐️ 排序的稳定性:假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，r[i]=r[j]，且r[i]在r[j]之前，而在排序后的序列中，r[i]仍在r[j]之前，则称这种排序算法是稳定的；否则称为不稳定的。
⭐️内部排序 ：数据元素全部放在内存中的排序。
⭐️外部排序：数据元素太多不能同时放在内存中，根据排序过程的要求不能在内外存之间移动数据的排序。
🍯2.排序分类 🌏二.插入排序 🍯1.直接插入排序 🍍基本思想 ⭐️现在有一个有序的区间，我们插入一个数据，保持它依旧有序
⭐️一般地，我们把第一个看作是有序的，所以我们可以从第二个数开始往前插入，使得前两个数是有序的，然后将第三个数插入直到最后一个数插入。
🍍实现过程 ⭐️单趟排序：首先选中end&#43;1下标位置的数据存放到tmp中之后依次从end位置开始向前比较，直到end小于0，每个数进行比较，最后将tmp插入即可
⭐️整合： 总共有n个数，所以需要排序n-1次
void InsertSort(int* a, int n) { //有n个数据只用n-1趟排序 for (int i = 0; i &lt; n - 1; &#43;&#43;i) { //单趟排序 int end = i; //待插入的数据 int tmp = a[end &#43; 1]; //依次往前移动 while (end &gt;= 0) { //依次比较 //降序只需要将下面改成 &lt; 即可 if (a[end] &gt; tmp) { a[end &#43; 1] = a[end]; end--; } else { //当插入的数据是最小值的话，end移动到0位置处理完后，所有数据都往后移完了 //那下一次end为-1时，结束循环没有成功插入数据 //a[end &#43; 1] = tmp; break; } a[end &#43; 1] = tmp; } } } 🍍时间复杂度、空间复杂度、稳定性分析 ⭐️时间复杂度：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/f7f9c79ccd55d1d9c113b47bfbfd90ac/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-10-21T23:12:17+08:00" />
<meta property="article:modified_time" content="2023-10-21T23:12:17+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【初阶数据结构与算法】第十篇——八大排序算法（头脑风暴逻辑分析&#43;动图详解一看就会&#43;代码分析信手捏来）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><img src="https://images2.imgbox.com/95/dd/VY9zzeh5_o.gif" alt=""></p> 
<blockquote> 
 <p>🏆<strong>个人主页：</strong><a href="https://blog.csdn.net/YQ20210216?spm=1000.2115.3001.5343">企鹅不叫的博客</a></p> 
 <p>​ 🌈<strong>专栏</strong></p> 
 <ul><li><a href="https://blog.csdn.net/yq20210216/category_11417182.html?spm=1001.2014.3001.5482">C语言初阶和进阶</a></li><li><a href="https://blog.csdn.net/yq20210216/category_11679165.html">C项目</a></li><li><a href="https://blog.csdn.net/yq20210216/category_11666534.html?spm=1001.2014.3001.5482">Leetcode刷题</a></li><li><a href="https://blog.csdn.net/yq20210216/category_11665095.html?spm=1001.2014.3001.5482">初阶数据结构与算法</a></li><li><a href="https://blog.csdn.net/yq20210216/category_11728338.html?spm=1001.2014.3001.5482">C++初阶和进阶</a></li></ul> 
 <p>⭐️ <strong>博主码云gitee链接：</strong><a href="https://gitee.com/royal-never-give-up" rel="nofollow">代码仓库地址</a></p> 
 <p>⚡若有帮助可以【<font color="#DC143C">关注</font>+<font color="#FFA500">点赞</font>+<font color="#45b97c">收藏</font>】，大家一起进步！</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/0a/1c/l7ojZ4R5_o.gif" alt=""></p> 
<h2><a id="_20"></a>💙系列文章💙</h2> 
<p><a href="https://blog.csdn.net/YQ20210216/article/details/123263859?spm=1001.2014.3001.5501">【初阶数据结构与算法】第一篇：算法中的时间复杂度和空间复杂度</a></p> 
<p><a href="https://blog.csdn.net/YQ20210216/article/details/123339348?spm=1001.2014.3001.5501">【初阶数据结构与算法】第二篇：顺序表</a></p> 
<p><a href="https://blog.csdn.net/YQ20210216/article/details/123440506?spm=1001.2014.3001.5501">【初阶数据结构与算法】第三篇：单链表</a></p> 
<p><a href="https://blog.csdn.net/YQ20210216/article/details/123608084?spm=1001.2014.3001.5501">【初阶数据结构与算法】第四篇：链表面试题详解</a></p> 
<p><a href="https://blog.csdn.net/YQ20210216/article/details/123646794?spm=1001.2014.3001.5501">【初阶数据结构与算法】第五篇：双链表</a></p> 
<p><a href="https://blog.csdn.net/YQ20210216/article/details/123719975?spm=1001.2014.3001.5501">【初阶数据结构与算法】第六篇：栈和队列（各个功能实现+练习题包含多种方法）</a></p> 
<p><a href="https://blog.csdn.net/YQ20210216/article/details/123853818?spm=1001.2014.3001.5501">【初阶数据结构与算法】第七篇：二叉树和堆的基本概念+以及堆的实现</a></p> 
<p><a href="https://blog.csdn.net/YQ20210216/article/details/123938785?spm=1001.2014.3001.5501">【初阶数据结构与算法】第八篇——二叉树的顺序结构的应用（堆排序+TOPK问题）</a></p> 
<p><a href="https://blog.csdn.net/YQ20210216/article/details/124085848?spm=1001.2014.3001.5501">【初阶数据结构与算法】第九篇——二叉树（链式结构实现+四种遍历方式+基本操作实现+基本练习详解）</a></p> 
<hr> 
<p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#_20" rel="nofollow">💙系列文章💙</a></li><li><a href="#_51" rel="nofollow">🌏一、排序介绍</a></li><li><ul><li><a href="#1_53" rel="nofollow">🍯1.排序概念</a></li><li><a href="#2_61" rel="nofollow">🍯2.排序分类</a></li></ul> 
  </li><li><a href="#_65" rel="nofollow">🌏二.插入排序</a></li><li><ul><li><a href="#1_67" rel="nofollow">🍯1.直接插入排序</a></li><li><ul><li><a href="#_69" rel="nofollow">🍍基本思想</a></li><li><a href="#_77" rel="nofollow">🍍实现过程</a></li><li><a href="#_111" rel="nofollow">🍍时间复杂度、空间复杂度、稳定性分析</a></li></ul> 
   </li><li><a href="#2_133" rel="nofollow">🍯2.希尔排序</a></li><li><ul><li><a href="#_135" rel="nofollow">🍍基本思想</a></li><li><a href="#_147" rel="nofollow">🍍实现过程</a></li><li><a href="#_264" rel="nofollow">🍍时间复杂度、空间复杂度、稳定性分析</a></li></ul> 
  </li></ul> 
  </li><li><a href="#_284" rel="nofollow">🌏三.选择排序</a></li><li><ul><li><a href="#1_286" rel="nofollow">🍯1.直接选择排序</a></li><li><ul><li><a href="#_288" rel="nofollow">🍍基本思想</a></li><li><a href="#_294" rel="nofollow">🍍实现过程</a></li><li><a href="#_328" rel="nofollow">🍍时间复杂度、空间复杂度、稳定性分析</a></li></ul> 
   </li><li><a href="#2httpsblogcsdnnetYQ20210216articledetails123938785spm1001201430015501_346" rel="nofollow">🍯2.堆排序（[详细介绍点这里](https://blog.csdn.net/YQ20210216/article/details/123938785?spm=1001.2014.3001.5501)）</a></li><li><ul><li><a href="#_348" rel="nofollow">🍍基本思想</a></li><li><a href="#_352" rel="nofollow">🍍实现过程</a></li><li><a href="#_401" rel="nofollow">🍍时间复杂度、空间复杂度、稳定性分析</a></li></ul> 
  </li></ul> 
  </li><li><a href="#_417" rel="nofollow">🌏四.交换排序</a></li><li><ul><li><a href="#1_419" rel="nofollow">🍯1.冒泡排序</a></li><li><ul><li><a href="#_421" rel="nofollow">🍍基本思想</a></li><li><a href="#_427" rel="nofollow">🍍实现过程</a></li><li><a href="#_452" rel="nofollow">🍍时间复杂度、空间复杂度、稳定性分析</a></li></ul> 
   </li><li><a href="#2_468" rel="nofollow">🍯2.快速排序（递归版本）</a></li><li><ul><li><a href="#hoare_470" rel="nofollow">🍍hoare版本</a></li><li><ul><li><a href="#_472" rel="nofollow">🔑基本思想</a></li><li><a href="#_482" rel="nofollow">🔑实现过程</a></li></ul> 
    </li><li><a href="#_525" rel="nofollow">🍍挖坑法</a></li><li><ul><li><a href="#_527" rel="nofollow">🔑基本思想</a></li><li><a href="#_535" rel="nofollow">🔑实现过程</a></li></ul> 
    </li><li><a href="#_581" rel="nofollow">🍍前后指针法</a></li><li><ul><li><a href="#_583" rel="nofollow">🔑基本思想</a></li><li><a href="#_591" rel="nofollow">🔑实现过程</a></li></ul> 
    </li><li><a href="#_636" rel="nofollow">🍍时间复杂度、空间复杂度、稳定性分析</a></li><li><a href="#_656" rel="nofollow">🍍优化快速排序</a></li><li><ul><li><a href="#_658" rel="nofollow">🔑选出中间值优化</a></li><li><ul><li><a href="#_660" rel="nofollow">🌰基本思想和代码实现</a></li></ul> 
     </li><li><a href="#_735" rel="nofollow">🔑小区间优化</a></li><li><ul><li><a href="#_737" rel="nofollow">🌰基本思想和代码实现</a></li></ul> 
    </li></ul> 
   </li></ul> 
   </li><li><a href="#3_771" rel="nofollow">🍯3.快速排序（非递归版本）</a></li><li><ul><li><a href="#_773" rel="nofollow">🍍基本思想</a></li><li><a href="#_779" rel="nofollow">🍍实现过程</a></li></ul> 
  </li></ul> 
  </li><li><a href="#_817" rel="nofollow">🌏五.归并排序</a></li><li><ul><li><a href="#1_819" rel="nofollow">🍯1.递归实现</a></li><li><ul><li><a href="#_821" rel="nofollow">🍍相较于其他排序的优势</a></li><li><a href="#_825" rel="nofollow">🍍基本思想</a></li><li><a href="#_835" rel="nofollow">🍍实现过程</a></li><li><a href="#_889" rel="nofollow">🍍时间复杂度、空间复杂度、稳定性分析</a></li></ul> 
   </li><li><a href="#2_908" rel="nofollow">🍯2.非递归实现</a></li><li><ul><li><a href="#_910" rel="nofollow">🍍基本思想</a></li><li><a href="#_916" rel="nofollow">🍍实现过程</a></li></ul> 
  </li></ul> 
  </li><li><a href="#_976" rel="nofollow">🌏六.计数排序（非比较排序）</a></li><li><ul><li><ul><li><a href="#_978" rel="nofollow">🍍基本思想</a></li><li><a href="#_984" rel="nofollow">🍍实现过程</a></li><li><a href="#_1023" rel="nofollow">🍍时间复杂度、空间复杂度、稳定性分析</a></li></ul> 
  </li></ul> 
  </li><li><a href="#_1042" rel="nofollow">🌏七.八大排序比较</a></li><li><ul><li><a href="#1_1044" rel="nofollow">🍯1.性能测试代码</a></li><li><a href="#2_1182" rel="nofollow">🍯2.排序空间复杂度、时间复杂度、稳定性</a></li></ul> 
  </li><li><a href="#_1199" rel="nofollow">🌏总结</a></li></ul> 
</div> 
<p></p> 
<hr> 
<h2 align="center">前言</h2> 
<img src="https://images2.imgbox.com/8c/6b/mAYgVlLc_o.jpg"> 
<hr> 
<h2><a id="_51"></a>🌏一、排序介绍</h2> 
<h3><a id="1_53"></a>🍯1.排序概念</h3> 
<blockquote> 
 <p>⭐️ <strong>排序</strong>：所谓排序，就是使一串记录，按照其中的某个或某些关键字的大小，递增或递减的排列起来的操作。<br> ⭐️ <strong>排序的稳定性</strong>:假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，r[i]=r[j]，且r[i]在r[j]之前，而在排序后的序列中，r[i]仍在r[j]之前，则称这种排序算法是稳定的；否则称为不稳定的。</p> 
 <p>⭐️<strong>内部排序</strong> ：数据元素全部放在内存中的排序。<br> ⭐️<strong>外部排序</strong>：数据元素太多不能同时放在内存中，根据排序过程的要求不能在内外存之间移动数据的排序。</p> 
</blockquote> 
<h3><a id="2_61"></a>🍯2.排序分类</h3> 
<img src="https://images2.imgbox.com/1f/9f/ChvfDStw_o.png"> 
<h2><a id="_65"></a>🌏二.插入排序</h2> 
<h3><a id="1_67"></a>🍯1.直接插入排序</h3> 
<h4><a id="_69"></a>🍍基本思想</h4> 
<blockquote> 
 <p>⭐️现在有一个有序的区间，我们插入一个数据，保持它依旧有序</p> 
 <p>⭐️一般地，我们把第一个看作是有序的，所以我们可以从第二个数开始往前插入，使得前两个数是有序的，然后将第三个数插入直到最后一个数插入。</p> 
 <p><img src="https://images2.imgbox.com/6e/89/et7a8J1D_o.gif" alt=""></p> 
</blockquote> 
<h4><a id="_77"></a>🍍实现过程</h4> 
<blockquote> 
 <p>⭐️<strong>单趟排序</strong>：首先选中<mark>end+1</mark>下标位置的数据存放到<mark>tmp</mark>中之后依次从<mark>end</mark>位置开始向前比较，直到<mark>end</mark>小于0，每个数进行比较，最后将<mark>tmp</mark>插入即可</p> 
 <p>⭐️<strong>整合：</strong> 总共有n个数，所以需要排序<mark>n-1</mark>次</p> 
</blockquote> 
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">InsertSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">//有n个数据只用n-1趟排序</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">//单趟排序</span>
        <span class="token keyword">int</span> end <span class="token operator">=</span> i<span class="token punctuation">;</span>
        <span class="token comment">//待插入的数据</span>
        <span class="token keyword">int</span> tmp <span class="token operator">=</span> a<span class="token punctuation">[</span>end <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token comment">//依次往前移动</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>end <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">//依次比较</span>
            <span class="token comment">//降序只需要将下面改成 &lt; 即可</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>end<span class="token punctuation">]</span> <span class="token operator">&gt;</span> tmp<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                a<span class="token punctuation">[</span>end <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>end<span class="token punctuation">]</span><span class="token punctuation">;</span>
                end<span class="token operator">--</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
                <span class="token comment">//当插入的数据是最小值的话，end移动到0位置处理完后，所有数据都往后移完了</span>
                <span class="token comment">//那下一次end为-1时，结束循环没有成功插入数据</span>
                <span class="token comment">//a[end + 1] = tmp;</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            a<span class="token punctuation">[</span>end <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h4><a id="_111"></a>🍍时间复杂度、空间复杂度、稳定性分析</h4> 
<blockquote> 
 <p>⭐️<strong>时间复杂度：</strong><br> <span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           O 
          
         
           （ 
          
          
          
            N 
           
          
            2 
           
          
         
           ） 
          
         
        
          O（N^2） 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8641em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">O</span><span class="mord cjk_fallback">（</span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.109em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.8641em;"><span class="" style="top: -3.113em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord cjk_fallback">）</span></span></span></span></span></span><br> 第一趟<mark>end</mark>最多往前移动1次，第二趟是2次……第<strong>n-1</strong>趟是<strong>n-1</strong>次，所以总次数是<strong>1+2+3+……+n-1=n*(n-1)/2</strong>，所以说时间复杂度是<mark>O(N<sup>2</sup>)</mark></p> 
 <p><strong>最好情况</strong>：O（N）顺序</p> 
 <p><strong>最坏的情况</strong>：O（N<sup>2</sup>）逆序</p> 
 <p>⭐️<strong>空间复杂度：</strong><br> <span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           O 
          
         
           ( 
          
         
           1 
          
         
           ) 
          
         
        
          O(1) 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span></span><br> 没有开辟额外空间</p> 
 <p>⭐️<strong>稳定性：</strong></p> 
 <p>直接插入排序在遇到相同的数时，可以不移动，就可以保持稳定性了，所以说这个排序是<mark>稳定的</mark>。</p> 
</blockquote> 
<h3><a id="2_133"></a>🍯2.希尔排序</h3> 
<h4><a id="_135"></a>🍍基本思想</h4> 
<blockquote> 
 <p>⭐️希尔排序是建立在直接插入排序之上的一种排序，希尔排序的思想上是把较大的数尽快的移动到后面，把较小的数尽快的移动到前面。所以先预排序使数据接近有序，然后再直接插入排序。</p> 
 <p>⭐️先选定一个整数，把待排序数列中所有记录分成多个组，所有距离为的记录分在同一组内，并对每一组内的记录进行排序。（直接插入排序的步长为1），这里的步长不为1，而是大于1，我们把步长这个量称为<mark>gap</mark>，当<mark>gap</mark>&gt;1时，都是在进行预排序，当<mark>gap</mark>==1时，进行的是直接插入排序。</p> 
 <p>⭐️如果<mark>gap</mark>越小，说明，数组越接近有序，如果<mark>gap</mark>越大，大的数据可以更快的到后面，小的数据可以更快的到前面，然是整个数组越不接近有序</p> 
 <p><img src="https://images2.imgbox.com/9c/6b/ZbAmqfc9_o.png" alt=""></p> 
 <p><img src="https://images2.imgbox.com/5c/69/f2swzi3J_o.gif" alt="希尔排序动图"></p> 
</blockquote> 
<h4><a id="_147"></a>🍍实现过程</h4> 
<blockquote> 
 <p>⭐️单趟排序，和直接插入差不多，原来是<mark>gap == 1</mark>,现在是<mark>gap</mark>了。</p> 
</blockquote> 
<pre><code class="prism language-c"><span class="token comment">//单组</span>
<span class="token keyword">int</span> end <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> tmp <span class="token operator">=</span> a<span class="token punctuation">[</span>end <span class="token operator">+</span> gap<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>end <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>end<span class="token punctuation">]</span> <span class="token operator">&gt;</span> tmp<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		a<span class="token punctuation">[</span>end <span class="token operator">+</span> gap<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>end<span class="token punctuation">]</span><span class="token punctuation">;</span>
		end <span class="token operator">-=</span> gap<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">else</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">break</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
a<span class="token punctuation">[</span>end <span class="token operator">+</span> gap<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>

</code></pre> 
<blockquote> 
 <p>⭐️首先对于每一组进行排序，之后再进行下一组排序</p> 
</blockquote> 
<pre><code class="prism language-c"><span class="token comment">// gap组</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> gap<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token operator">-</span>gap<span class="token punctuation">;</span> i<span class="token operator">+=</span>gap<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">int</span> end <span class="token operator">=</span> i<span class="token punctuation">;</span>
		<span class="token keyword">int</span> tmp <span class="token operator">=</span> a<span class="token punctuation">[</span>end <span class="token operator">+</span> gap<span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span>end <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>end<span class="token punctuation">]</span> <span class="token operator">&gt;</span> tmp<span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				a<span class="token punctuation">[</span>end <span class="token operator">+</span> gap<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>end<span class="token punctuation">]</span><span class="token punctuation">;</span>
				end <span class="token operator">-=</span> gap<span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			<span class="token keyword">else</span>
			<span class="token punctuation">{<!-- --></span>
				<span class="token keyword">break</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
		a<span class="token punctuation">[</span>end <span class="token operator">+</span> gap<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre> 
<blockquote> 
 <p>⭐️所有数据一起排序，不再是一组一组数据排序，少嵌套一层循环</p> 
</blockquote> 
<pre><code class="prism language-c"><span class="token comment">// 一起预排序</span>
<span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token comment">//最后一个数据下标是n-1,那么我们只要到n-1-gap下标循环后就截止</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n <span class="token operator">-</span> gap<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> end <span class="token operator">=</span> i<span class="token punctuation">;</span>
	<span class="token keyword">int</span> tmp <span class="token operator">=</span> a<span class="token punctuation">[</span>end <span class="token operator">+</span> gap<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token comment">//将所有间隔gap的数据排列</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>end <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>end<span class="token punctuation">]</span> <span class="token operator">&gt;</span> tmp<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			a<span class="token punctuation">[</span>end <span class="token operator">+</span> gap<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>end<span class="token punctuation">]</span><span class="token punctuation">;</span>
			end <span class="token operator">-=</span> gap<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">else</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">break</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	a<span class="token punctuation">[</span>end <span class="token operator">+</span> gap<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre> 
<blockquote> 
 <p>⭐️关于<mark>gap</mark>取值，当<mark>gap</mark>=1时，直接插入排序，当<mark>gap</mark> &gt; 1时，预排序，并且<mark>gap</mark>越大，预排序越快，排序结果越不接近有序，<mark>gap</mark>越小，排序越慢，预排序后越接近有序</p> 
 <p>⭐️对于控制<mark>gap</mark>，我们可以让最初的<mark>gap</mark>控制为n，最后一次<mark>gap</mark>控制为1就可以了，我们可以<mark>gap /= 2</mark>（最后一个是偶数，也是1），也可以<br> <span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           g 
          
         
           a 
          
         
           p 
          
         
           = 
          
         
           g 
          
         
           a 
          
         
           p 
          
         
           / 
          
         
           3 
          
         
           + 
          
         
           1 
          
         
        
          gap = gap / 3+1 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.0359em;">g</span><span class="mord mathnormal">a</span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0359em;">g</span><span class="mord mathnormal">a</span><span class="mord mathnormal">p</span><span class="mord">/3</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">1</span></span></span></span></span></span><br> <strong>加1是为了，防止gap为0</strong></p> 
</blockquote> 
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">ShellSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> gap <span class="token operator">=</span> n<span class="token punctuation">;</span>
    <span class="token comment">//注意gap&gt;1，可以保证最后一次是2</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>gap <span class="token operator">&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        gap <span class="token operator">=</span> gap <span class="token operator">/</span> <span class="token number">3</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token comment">//最后一个数据下标是n-1,那么我们只要到n-1-gap下标循环后就截止</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n <span class="token operator">-</span> gap<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">int</span> end <span class="token operator">=</span> i<span class="token punctuation">;</span>
            <span class="token keyword">int</span> tmp <span class="token operator">=</span> a<span class="token punctuation">[</span>end <span class="token operator">+</span> gap<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span>end <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>end<span class="token punctuation">]</span> <span class="token operator">&gt;</span> tmp<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                    a<span class="token punctuation">[</span>end <span class="token operator">+</span> gap<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>end<span class="token punctuation">]</span><span class="token punctuation">;</span>
                    end <span class="token operator">-=</span> gap<span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
                    <span class="token keyword">break</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
            a<span class="token punctuation">[</span>end <span class="token operator">+</span> gap<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre> 
<h4><a id="_264"></a>🍍时间复杂度、空间复杂度、稳定性分析</h4> 
<blockquote> 
 <p><strong>⭐️时间复杂度：</strong><br> <span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           O 
          
         
           ( 
          
          
          
            N 
           
          
            1.3 
           
          
         
           ) 
          
         
        
          O(N^{1.3}) 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1.1141em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.109em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.8641em;"><span class="" style="top: -3.113em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1.3</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></span></p> 
 <p>当gap很大的时候几乎都跳到后面去了，差不多时O(N),很小差不多也是O(N)</p> 
 <p><strong>平均下来是O(N<sup>1.3</sup>)</strong></p> 
 <p><strong>⭐️空间复杂度：</strong><br> <span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           O 
          
         
           ( 
          
         
           1 
          
         
           ) 
          
         
        
          O(1) 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span></span><br> <strong>⭐️稳定性分析：</strong></p> 
 <p>相同的数，可能被分到不同的gap当中，<mark><strong>不稳定</strong></mark>。</p> 
</blockquote> 
<h2><a id="_284"></a>🌏三.选择排序</h2> 
<h3><a id="1_286"></a>🍯1.直接选择排序</h3> 
<h4><a id="_288"></a>🍍基本思想</h4> 
<blockquote> 
 <p>⭐️ 每次从数组中选择最大的一个数和最小的一个数，把他们放到开头和结尾，然后再取次大的一个数和次小的一个数，放到开头第二或者结尾第二，依次这样进行，直到只剩下一个元素或者没有。</p> 
 <p><img src="https://images2.imgbox.com/87/13/b4tSowDs_o.gif" alt=""></p> 
</blockquote> 
<h4><a id="_294"></a>🍍实现过程</h4> 
<blockquote> 
 <p>⭐️首先选出第一个元素left和最后一个元素right，同时从两头二分数组，创建当前最小下标和最大下标，选出最小下标mini和最大下标maxi，然后交换left下标的值和mini下标的值，再交换right下标的值和maxi下标的值的时候，要判断left下标是否和maxi下标相等，防止接下来的交换将maxi掉包</p> 
</blockquote> 
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">SelectSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> right <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">//初始化记录最大下标和最小下标</span>
        <span class="token keyword">int</span> mini <span class="token operator">=</span> left<span class="token punctuation">,</span> maxi <span class="token operator">=</span> left<span class="token punctuation">;</span>
        <span class="token comment">//i从left+1开始，是因为mini从left开始了，然后两边都是闭区间</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> right<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">//如果i下标对应的数比mini下标对应数大，则交换</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>mini<span class="token punctuation">]</span> <span class="token operator">&gt;</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                mini <span class="token operator">=</span> i<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token comment">如果i下标对应的数比maxi下标对应数小，则交换</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>maxi<span class="token punctuation">]</span> <span class="token operator">&lt;</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                maxi <span class="token operator">=</span> i<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token function">Swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">[</span>mini<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//left和maxi重叠，说明maxi被换到mini原来的位置上去了，修正一下maxi即可</span>
        <span class="token comment">//防止left和maxi相等时，mini与left交换会导致maxi的位置发生变化</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">==</span> maxi<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            maxi <span class="token operator">=</span> mini<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token function">Swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">[</span>maxi<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        right<span class="token operator">--</span><span class="token punctuation">;</span>
        left<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h4><a id="_328"></a>🍍时间复杂度、空间复杂度、稳定性分析</h4> 
<blockquote> 
 <p><strong>⭐️时间复杂度：</strong></p> 
 <p align="center">O(N^2)</p> 
 <p>第一趟遍历<strong>n-1</strong>个数，选出两个数，第二趟遍历<strong>n-3</strong>个数，选出两个数……最后一次遍历1个数（n为偶数）或2个数（n为奇数），所以总次数是<strong>n-1+n-3+……+2</strong>，所以说时间复杂度是<strong>O(n^2)</strong></p> 
 <p><strong>⭐️空间复杂度：</strong></p> 
 <p align="center">O(1)</p> 
 <p><strong>⭐️稳定性分析：</strong></p> 
 <p>下面就是<font color="#DC143C">红色</font>的5和黑色的5相对顺序变了<strong>不稳定</strong>。</p> 
 <p><img src="https://images2.imgbox.com/86/4f/OfTtgymh_o.png" alt=""></p> 
</blockquote> 
<h3><a id="2httpsblogcsdnnetYQ20210216articledetails123938785spm1001201430015501_346"></a>🍯2.堆排序（<a href="https://blog.csdn.net/YQ20210216/article/details/123938785?spm=1001.2014.3001.5501">详细介绍点这里</a>）</h3> 
<h4><a id="_348"></a>🍍基本思想</h4> 
<blockquote> 
 <p>⭐️首先建立堆（升序建大堆，降序建小堆），然后调整数据</p> 
</blockquote> 
<h4><a id="_352"></a>🍍实现过程</h4> 
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">AdjustDown</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> a<span class="token punctuation">,</span> <span class="token class-name">size_t</span> size<span class="token punctuation">,</span> <span class="token class-name">size_t</span> root<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token class-name">size_t</span> parent <span class="token operator">=</span> root<span class="token punctuation">;</span>
    <span class="token class-name">size_t</span> child <span class="token operator">=</span> parent <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>child <span class="token operator">&lt;</span> size<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 1、选出左右孩子中小的那个，注意，child+1 &lt; size要写在前面，防止越界</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>child <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;</span> size <span class="token operator">&amp;&amp;</span> a<span class="token punctuation">[</span>child <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&gt;</span> a<span class="token punctuation">[</span>child<span class="token punctuation">]</span><span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token operator">++</span>child<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 2、如果孩子小于父亲，则交换，并继续往下调整</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>child<span class="token punctuation">]</span> <span class="token operator">&gt;</span> a<span class="token punctuation">[</span>parent<span class="token punctuation">]</span><span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token function">Swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">[</span>child<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">[</span>parent<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            parent <span class="token operator">=</span> child<span class="token punctuation">;</span>
            child <span class="token operator">=</span> parent <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">else</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">HeapSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 向下调整--建堆 O(N)</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token function">AdjustDown</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> n<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token function">swap</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">AdjustDown</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> i<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//size_t end = n - 1;</span>
    <span class="token comment">//while (end &gt; 0)</span>
    <span class="token comment">//{<!-- --></span>
    <span class="token comment">//    Swap(&amp;a[0], &amp;a[end]);</span>
    <span class="token comment">//    AdjustDown(a, end, 0);</span>
    <span class="token comment">//    --end;</span>
    <span class="token comment">//}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h4><a id="_401"></a>🍍时间复杂度、空间复杂度、稳定性分析</h4> 
<blockquote> 
 <p><strong>⭐️时间复杂度：</strong><br> <span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           O 
          
         
           ( 
          
         
           N 
          
         
           l 
          
         
           o 
          
         
           g 
          
         
           N 
          
         
           ) 
          
         
        
          O(NlogN) 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right: 0.0197em;">Nl</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right: 0.0359em;">g</span><span class="mord mathnormal" style="margin-right: 0.109em;">N</span><span class="mclose">)</span></span></span></span></span></span><br> <strong>⭐️空间复杂度：</strong><br> <span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           O 
          
         
           ( 
          
         
           1 
          
         
           ) 
          
         
        
          O(1) 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span></span><br> <strong>⭐️稳定性分析：</strong></p> 
 <p>升序大堆，两个数都是8，之后最上面8插入到最后一个顺序就颠倒了<strong>不稳定</strong></p> 
 <p><img src="https://images2.imgbox.com/09/9e/ycnX5GPv_o.png" alt="image-20220426170212908"></p> 
</blockquote> 
<h2><a id="_417"></a>🌏四.交换排序</h2> 
<h3><a id="1_419"></a>🍯1.冒泡排序</h3> 
<h4><a id="_421"></a>🍍基本思想</h4> 
<blockquote> 
 <p>⭐️以升序为例，每一趟的冒泡排序都是把一个最大的数放到最后面，如果 <mark>a[i-1]&gt;a[i]</mark>,我们将<mark>i-1</mark>,i的值进行交换，依次循环反复。</p> 
 <p><img src="https://images2.imgbox.com/97/26/PXnPqp4t_o.gif" alt=""></p> 
</blockquote> 
<h4><a id="_427"></a>🍍实现过程</h4> 
<blockquote> 
 <p>⭐️<mark>用升序举例子</mark>首先从下标为1的数开始，依次将前一个数和后一个数交换，之后每一次遍历都会少一个需要遍历的数，单趟冒泡完了，每一个都小于后一个数，那么后面就不需要遍历了</p> 
</blockquote> 
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">BubbleSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">//多趟</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">//发生了交换，将flag置1</span>
        <span class="token keyword">int</span> flag <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token comment">//单趟，从1开始，让前一个与后一个比较</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n <span class="token operator">-</span> j<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> a<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token function">Swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                flag <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token comment">//没有发生交换，后续不需要再冒泡</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>flag <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h4><a id="_452"></a>🍍时间复杂度、空间复杂度、稳定性分析</h4> 
<blockquote> 
 <p>⭐️<strong>时间复杂度：</strong></p> 
 <p>第一趟最多比较<strong>n-1</strong>次，第二趟最多比较<strong>n-2</strong>次……最后一次最多比较<strong>1</strong>次，所以总次数是<strong>n-1+n-2+……+1</strong>，所以说时间复杂度是<strong>O(N<sup>2</sup>)</strong><br> <strong>最好的情况：</strong> O(N)（顺序）<br> <strong>最坏的情况：</strong> O(N<sup>2</sup>)（逆序）</p> 
 <p>⭐️<strong>空间复杂度：</strong></p> 
 <p><strong>O(1)</strong>，没有开辟额外空间</p> 
 <p>⭐️<strong>稳定性：</strong></p> 
 <p>冒泡排序在比较遇到相同的数时，不进行交换，这样就保证了稳定性，所以说冒泡排序数<mark>稳定的</mark>。</p> 
</blockquote> 
<h3><a id="2_468"></a>🍯2.快速排序（递归版本）</h3> 
<h4><a id="hoare_470"></a>🍍hoare版本</h4> 
<h5><a id="_472"></a>🔑基本思想</h5> 
<blockquote> 
 <p>⭐️<mark>用升序举例子</mark>:首先定义一个关键字<mark>Key</mark>（一般是第一个或者是最后一个），然后将数组第一个定义为<mark>begin</mark>和最后一个定义为<mark>end</mark>，<mark>end</mark>负责找小，如果遇到<mark>end</mark>比<mark>Key</mark>小的话，移动<mark>begin</mark>，找到比<mark>Key</mark>大的位置，然后交换<mark>begin</mark>和<mark>end</mark>，如果<mark>begin</mark>和<mark>end</mark>相遇则将相遇的位置与<mark>Key</mark>交换。</p> 
 <p>⭐️原则：<strong>关键词取左，<mark>右边先</mark>找小再左边找大；关键词取右，<mark>左边先</mark>找大再右边找小</strong>。可以保证相遇位置比<mark>Key</mark>小</p> 
 <p><img src="https://images2.imgbox.com/f9/b5/QoLcRBPn_o.gif" alt=""></p> 
 <p>⭐️一趟单趟排序排完后，此时<mark>keyi</mark>下标对应的数不用变了，接下来将<mark>keyi</mark>左边和右边分别分治递归即可，直至左右两边都有序</p> 
</blockquote> 
<h5><a id="_482"></a>🔑实现过程</h5> 
<blockquote> 
 <p>⭐️<mark>hoare</mark>版本找<mark>keyi</mark>值代码，注意如果<mark>left</mark>和<mark>right</mark>都一样时，<mark>right</mark>和<mark>left</mark>也要移动，不忍会死循环，如果是顺序的数组，要判断下标防止越界</p> 
</blockquote> 
<pre><code class="prism language-c"><span class="token comment">//horae</span>
<span class="token keyword">int</span> <span class="token function">PartSort1</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">//将第一个值作为keyi</span>
    <span class="token keyword">int</span> keyi <span class="token operator">=</span> left<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">//（5，5，2，3，5）</span>
        <span class="token comment">//没有等于的问题是，如果left下标对应的值和right下标对应的值和keyi下标对应的值相等，则会死循环</span>
        <span class="token comment">//（1，2，3，4，5）</span>
        <span class="token comment">//如果没有判断left和right，数组是升序的话，right和left会一直访问直到越界</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">&gt;=</span> a<span class="token punctuation">[</span>keyi<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            right<span class="token operator">--</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> a<span class="token punctuation">[</span>keyi<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            left<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token function">Swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">Swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">[</span>keyi<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//返回数组第一个元素下标,返回的是left 不是keyi</span>
    <span class="token keyword">return</span> left<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<blockquote> 
 <p>⭐️快排代码，找出<mark>keyi</mark>下标，此时不变，将<mark>keyi</mark>下标分成左右两个区间，依次递归</p> 
</blockquote> 
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">QuickSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">//此时区间不可以再分割了,此时区间不存在 </span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">&gt;=</span> right<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">int</span> keyi <span class="token operator">=</span> <span class="token function">PartSort1</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> left<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//[left, keyi-1] keyi [keyi+1, right]</span>
    <span class="token function">QuickSort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> left<span class="token punctuation">,</span> keyi <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">QuickSort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> keyi <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h4><a id="_525"></a>🍍挖坑法</h4> 
<h5><a id="_527"></a>🔑基本思想</h5> 
<blockquote> 
 <p>⭐️相较于horae法，挖坑发不需要理解为什么，最终相遇的位置比<mark>key</mark>小，不需要理解为什么左边作为<mark>key</mark>要右边先走.</p> 
 <p>⭐️选出第一个数或者最后一个数作为坑位储存起来，包括下标，然后然后从右往左找到比<mark>key</mark>小的数字，将<mark>key</mark>替换为此数，然后从左往右找到比<mark>key</mark>大的数字，然后替换为此数，循环往复，直到<mark>right</mark>和<mark>left</mark>相等</p> 
 <p><img src="https://images2.imgbox.com/8f/a9/00RtJo1Y_o.gif" alt=""></p> 
</blockquote> 
<h5><a id="_535"></a>🔑实现过程</h5> 
<blockquote> 
 <p>⭐️将<mark>a[left]<mark>存到</mark>key</mark>中，将<mark>left</mark>下标存到<mark>pit</mark>中，然后先移动<mark>right</mark>，交换坑位，之后移动<mark>left</mark>交换坑位，最后结束循环放入坑位</p> 
</blockquote> 
<pre><code class="prism language-c"><span class="token comment">//挖坑法</span>
<span class="token keyword">int</span> <span class="token function">PartSort2</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> key <span class="token operator">=</span> a<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token comment">//坑位</span>
    <span class="token keyword">int</span> pit <span class="token operator">=</span> left<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>right <span class="token operator">&gt;</span> left<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">//（5，5，2，3，5）</span>
        <span class="token comment">//没有等于的问题是，如果left下标对应的值和right下标对应的值和keyi下标对应的值相等，则会死循环</span>
        <span class="token comment">//（1，2，3，4，5）</span>
        <span class="token comment">//如果没有判断left和right，数组是升序的话，right和left会一直访问直到越界</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>right <span class="token operator">&gt;</span> left <span class="token operator">&amp;&amp;</span> a<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">&gt;=</span> key<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            right<span class="token operator">--</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        a<span class="token punctuation">[</span>pit<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">;</span>
        pit <span class="token operator">=</span> right<span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>right <span class="token operator">&gt;</span> left <span class="token operator">&amp;&amp;</span> a<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> key<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            left<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        a<span class="token punctuation">[</span>pit<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">;</span>
        pit <span class="token operator">=</span> left<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    a<span class="token punctuation">[</span>pit<span class="token punctuation">]</span> <span class="token operator">=</span> key<span class="token punctuation">;</span>
    <span class="token keyword">return</span> pit<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<blockquote> 
 <p>⭐️全趟递归</p> 
</blockquote> 
<pre><code class="prism language-C">void QuickSort(int* a, int left, int right) {
    //此时区间不可以再分割了,此时区间不存在 
    if (left &gt;= right) {
        return;
    }
    int keyi = PartSort2(a, left, right);
    //[left, keyi-1] keyi [keyi+1, right]
    QuickSort(a, left, keyi - 1);
    QuickSort(a, keyi + 1, right);
}
</code></pre> 
<h4><a id="_581"></a>🍍前后指针法</h4> 
<h5><a id="_583"></a>🔑基本思想</h5> 
<blockquote> 
 <p>⭐️从左边开始，选择第一个数作为<mark>keyi</mark>，那么<mark>pre</mark>从下标为0开始，<mark>cur</mark>从下标为1开始，直到<mark>cur</mark>到最后一个数结束，<mark>cur</mark>在前面找小，找到了，<mark>prev</mark>往前走一步，然后交换<mark>pre</mark>和<mark>cur</mark><strong>所在位置的值，然后<mark>cur</mark>继续找小，直到<mark>cur</mark>走到空指针的位置就结束，最后将</strong><mark>pre</mark><strong>的值与</strong><mark>key</mark>交换就完成了一次分割区间的操作</p> 
 <p>⭐️如果选择右边作为<mark>keyi</mark>的话，那么<mark>pre</mark>起始下标从-1位置开始，<mark>cur</mark>从0位置开始，循环在<mark>right-1</mark>位置结束</p> 
 <p><img src="https://images2.imgbox.com/2e/98/cs3v0MdH_o.gif" alt=""></p> 
</blockquote> 
<h5><a id="_591"></a>🔑实现过程</h5> 
<blockquote> 
 <p>⭐️<strong>用第一个数为<mark>keyi</mark>为例</strong>：<mark>pre</mark>为第一个数下标，<mark>cur</mark>为第二个数下标，<mark>cur</mark>一直往后走，直到到<mark>right</mark>结束，当以<mark>cur</mark>为下标的值遇到以<mark>keyi</mark>为下标的值要小，则将<mark>pre</mark>往后移动一位，同时判断<mark>pre</mark>如果不等于<mark>cur</mark>则将<mark>cur</mark>的值与<mark>pre</mark>的值交换，之后<mark>cur</mark>往后走，循环结束后，交换<mark>pre</mark>下标的值和<mark>keyi</mark>下标的值，并且返回作为头的<mark>pre</mark></p> 
</blockquote> 
<pre><code class="prism language-c"><span class="token comment">//前后指针法</span>
<span class="token keyword">int</span> <span class="token function">PartSort3</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> keyi <span class="token operator">=</span> left<span class="token punctuation">;</span>
    <span class="token keyword">int</span> pre <span class="token operator">=</span> left<span class="token punctuation">;</span>
    <span class="token keyword">int</span> cur <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token comment">//cur走到尾就结束了，需要等于不然最后一组没有测到</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>cur <span class="token operator">&lt;=</span> right<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">//首先往后找比keyi要小的数</span>
        <span class="token comment">//找到了比keyi小的数就先++pre</span>
        <span class="token comment">//如果pre和cur相等就不交换两个数，如果不相等就交换两个数，防止自己和自己交换</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>cur<span class="token punctuation">]</span> <span class="token operator">&lt;</span> a<span class="token punctuation">[</span>keyi<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> a<span class="token punctuation">[</span><span class="token operator">++</span>pre<span class="token punctuation">]</span> <span class="token operator">!=</span> a<span class="token punctuation">[</span>cur<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token function">Swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">[</span>cur<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">[</span>pre<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">//cur接着往下走</span>
        cur<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//交换后，此时pre左边比keyi小，右边比keyi大</span>
    <span class="token function">Swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">[</span>pre<span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>a<span class="token punctuation">[</span>keyi<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//返回值给keyi</span>
    <span class="token keyword">return</span> pre<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<blockquote> 
 <p>⭐️全趟递归</p> 
</blockquote> 
<pre><code class="prism language-C">void QuickSort(int* a, int left, int right) {
    //此时区间不可以再分割了,此时区间不存在 
    if (left &gt;= right) {
        return;
    }
    int keyi = PartSort3(a, left, right);
    //[left, keyi-1] keyi [keyi+1, right]
    QuickSort(a, left, keyi - 1);
    QuickSort(a, keyi + 1, right);
}
</code></pre> 
<h4><a id="_636"></a>🍍时间复杂度、空间复杂度、稳定性分析</h4> 
<blockquote> 
 <p><strong>⭐️时间复杂度：</strong><br> <span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           O 
          
         
           ( 
          
         
           N 
          
         
           l 
          
         
           o 
          
         
           g 
          
         
           N 
          
         
           ) 
          
         
        
          O(NlogN) 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right: 0.0197em;">Nl</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right: 0.0359em;">g</span><span class="mord mathnormal" style="margin-right: 0.109em;">N</span><span class="mclose">)</span></span></span></span></span></span><br> 最好情况每次都选的是中间为<mark>key</mark></p> 
 <p>最坏情况是每次选的<mark>keyi</mark>都是第一个或者是最后一个，那么每次循环都要遍历所有的数**（此时可能会导致栈溢出）**</p> 
 <p><strong>⭐️空间复杂度：</strong></p> 
 <p><strong>空间复杂度一般为为O(logN)，最坏情况下是O(N),需要进行n‐1递归调用,退化为冒泡排序</strong></p> 
 <p><strong>⭐️稳定性分析：</strong></p> 
 <p>黑色<mark>key</mark> 2 要放到中间去，有点不稳==<strong>不稳定</strong>==</p> 
 <p><img src="https://images2.imgbox.com/ea/6a/Du3MUKz8_o.png" alt=""></p> 
</blockquote> 
<h4><a id="_656"></a>🍍优化快速排序</h4> 
<h5><a id="_658"></a>🔑选出中间值优化</h5> 
<h6><a id="_660"></a>🌰基本思想和代码实现</h6> 
<blockquote> 
 <p>⭐️选出不是最大或者最小的函数，因为遇到的数组是随机的，可能有序可能无序，如果是有序，那么三数取中后时间复杂度从最坏变到最好，随机的情况，即最坏的情况也被避免掉了选出数组中间值的下标，然后每次单趟排序时，将中间的值和第一个数交换，下面是选出中间值代码。</p> 
</blockquote> 
<pre><code class="prism language-c"><span class="token keyword">int</span> <span class="token function">MidIndex</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    	
        <span class="token comment">//防止数据溢出</span>
	<span class="token keyword">int</span> mid <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> left<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">&lt;</span> a<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;</span> a<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> mid<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">&lt;</span> a<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> right<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">else</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> left<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">else</span> <span class="token comment">//a[left] &gt; a[mid]</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&gt;</span> a<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> mid<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">&lt;</span> a<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> left<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">else</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> right<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<blockquote> 
 <p>⭐️此时的单趟排序中改变的只是，中间值和第一个数交换了而已</p> 
</blockquote> 
<pre><code class="prism language-c"><span class="token keyword">int</span> <span class="token function">PartSort1</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
  	  <span class="token comment">//选出中间值下标，然后交换中间值和第一个数</span>
	<span class="token keyword">int</span> midi <span class="token operator">=</span> <span class="token function">MidIndex</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> left<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">Swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">[</span>midi<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">//最左边的做key为例</span>
	<span class="token keyword">int</span> key <span class="token operator">=</span> left<span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>left<span class="token operator">&lt;</span>right<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token comment">//因为我们是最左边的取key，所以必须是右边先走找比key小的，思考下为什么？</span>
		<span class="token comment">//右边先走</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right <span class="token operator">&amp;&amp;</span> a<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">&gt;=</span> a<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token operator">--</span>right<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token comment">//然后左边走</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right <span class="token operator">&amp;&amp;</span> a<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">&lt;</span> a<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token operator">++</span>left<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token function">Swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token function">Swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//此时left已经和right相遇，一样的</span>
	<span class="token keyword">return</span> left<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre> 
<h5><a id="_735"></a>🔑小区间优化</h5> 
<h6><a id="_737"></a>🌰基本思想和代码实现</h6> 
<blockquote> 
 <p>⭐️在多次排序中，会多次递归调用，最后区间会被切成很小的一块，但其实，<strong>当区间变得很小的时候再去递归效率就会显得很慢</strong>，所以我们可以选择其他排序来解决这个问题。</p> 
 <p><img src="https://images2.imgbox.com/c1/95/SUQ5cHDh_o.png" alt="image-20220425114542542"></p> 
 <p>⭐️还有一个我们要思考的问题就是最后这段小区间用什么排序比较好？<br> 希尔排序适应的是比较多的数据才有优势，堆排序需要建堆，其他三个插入排序、选择排序和冒泡排序相比，还是插入排序比较优，所以我们小区间选择用<strong>插入排序</strong>进行排序。</p> 
</blockquote> 
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">QuickSort2</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> begin<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token comment">// 子区间相等只有一个值或者不存在那么就是递归结束的子问题</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>begin <span class="token operator">&gt;=</span> end<span class="token punctuation">)</span>
		<span class="token keyword">return</span><span class="token punctuation">;</span>

	<span class="token comment">// 当区间个数小于10时为小区间，小区间直接插入排序控制有序</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>end <span class="token operator">-</span> begin <span class="token operator">+</span> <span class="token number">1</span>  <span class="token operator">&lt;=</span> <span class="token number">10</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
        	<span class="token comment">//确定任意位置的小区间</span>
		<span class="token function">InsertSort</span><span class="token punctuation">(</span>a <span class="token operator">+</span> begin<span class="token punctuation">,</span> end <span class="token operator">-</span> begin <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">else</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">int</span> keyi <span class="token operator">=</span> <span class="token function">PartSort3</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> begin<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token comment">// [begin, keyi-1] keyi [keyi+1, end]</span>
		<span class="token function">QuickSort2</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> begin<span class="token punctuation">,</span> keyi <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">QuickSort2</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> keyi <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="3_771"></a>🍯3.快速排序（非递归版本）</h3> 
<h4><a id="_773"></a>🍍基本思想</h4> 
<blockquote> 
 <p>⭐️<strong>原因</strong>:当递归深度过大，可能会造成栈溢出。</p> 
 <p>⭐️利用栈，首先将要插入的区间头尾放到栈当中，然后循环取出头尾，得到<mark>keyi</mark>再将[left, keyi-1]和 [keyi+1,right]依次放到栈当中，直到栈为空停止。</p> 
</blockquote> 
<h4><a id="_779"></a>🍍实现过程</h4> 
<blockquote> 
 <p>⭐️首先创建一个栈，然后把我们传过来的区间放到栈当中，然后取出栈当中区间的两头，同时单趟排一遍得到<mark>keyi</mark>此时<mark>keyi</mark>左边比<mark>keyi</mark>小，右边比<mark>keyi</mark>大，然后判断左右两个区间的边界范围，如果边界相等说明只有一个元素了，就不用再入栈了，依次循环直到栈为空。</p> 
 <p><img src="https://images2.imgbox.com/0f/a8/jTSS6b23_o.gif" alt=""></p> 
</blockquote> 
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">QuickSort2</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">//创建并且初始化st然后将</span>
    ST st<span class="token punctuation">;</span>
    <span class="token function">StackInit</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>st<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//将最开始的区间插入到栈当中</span>
    <span class="token function">StackPush</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>st<span class="token punctuation">,</span> left<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">StackPush</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>st<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//栈为空，表示排完了</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">StackEmpty</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>st<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">//取出我们要排序的区间头和尾,注意栈是先入后出</span>
        <span class="token keyword">int</span> right <span class="token operator">=</span> <span class="token function">StackTop</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>st<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">StackPop</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>st<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token function">StackTop</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>st<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">StackPop</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>st<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//单趟排序得到keyi</span>
        <span class="token keyword">int</span> keyi <span class="token operator">=</span> <span class="token function">PartSort3</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> left<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//[left, keyi-1] keyi [keyi+1, right]</span>
        <span class="token comment">//当区间越界了就不会再入栈了，说明排到底了</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> keyi <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token function">StackPush</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>st<span class="token punctuation">,</span> left<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">StackPush</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>st<span class="token punctuation">,</span> keyi <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>keyi <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token function">StackPush</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>st<span class="token punctuation">,</span> keyi <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">StackPush</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>st<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token function">StackDestory</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>st<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h2><a id="_817"></a>🌏五.归并排序</h2> 
<h3><a id="1_819"></a>🍯1.递归实现</h3> 
<h4><a id="_821"></a>🍍相较于其他排序的优势</h4> 
<blockquote> 
 <p>⭐️前面的排序都是内排序，数据在内存，访问速度快，但是访问量小，下标随机访问，归并排序是外排序，数据在磁盘，访问速度漫，但是访问量大，串行访问。</p> 
</blockquote> 
<h4><a id="_825"></a>🍍基本思想</h4> 
<blockquote> 
 <p>⭐️该算法是采用<strong>分治法</strong>的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。</p> 
 <p>⭐️其实就是先分治再递归，分成若干个小区间然后再合并。</p> 
 <img src="https://images2.imgbox.com/f2/da/Kh1BSbUf_o.png" alt="image-20220425172801752"> 
 <p><img src="https://images2.imgbox.com/36/cc/Ehh9Y2ku_o.gif" alt=""></p> 
</blockquote> 
<h4><a id="_835"></a>🍍实现过程</h4> 
<blockquote> 
 <p>⭐️创建一个临时数组，然后将需要排序的数组和临时数组都传送到子函数当中，首先分治：如果只剩下一个元素或者第一个元素下标超出最后一个元素下标时，返回否则获得中间节点，然后将中间节点的左区间和右区间分别分治。然后归并：将两个区间一起比较，将较小的值放入<mark>tmp</mark>中，之后将未排序完的数组放入到<mark>tmp</mark>中，再把<mark>tmp</mark>拷贝到<mark>a</mark>中</p> 
</blockquote> 
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">_MergeSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">*</span> tmp<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">//当区间只剩下一个值（=）或者超出区间（&gt;）的时候,结束返回</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">&gt;=</span> right<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> 
    <span class="token comment">//得到中间节点</span>
    <span class="token keyword">int</span> mid <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> left<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token comment">//分治[left, mid][mid+1, right]</span>
    <span class="token comment">//最好不要[left, mid-1][mid, right]，容易左右不均匀</span>
    <span class="token function">_MergeSort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> left<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> tmp<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">_MergeSort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> right<span class="token punctuation">,</span> tmp<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//归并[left, mid][mid+1, right]</span>
    <span class="token comment">//printf("归并[%d,%d][%d,%d]\n", left, mid, mid+1, right);</span>
    <span class="token comment">//两组left和right分别决定归并的左右两组，两边分别让它们有序</span>
    <span class="token keyword">int</span> left1 <span class="token operator">=</span> left<span class="token punctuation">,</span> right1 <span class="token operator">=</span> mid<span class="token punctuation">;</span>
    <span class="token keyword">int</span> left2 <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> right2 <span class="token operator">=</span> right<span class="token punctuation">;</span>
    <span class="token comment">//记录tmp下标的</span>
    <span class="token keyword">int</span> index <span class="token operator">=</span> left<span class="token punctuation">;</span>
    <span class="token comment">//归并过程是，有一组结束了循环结束</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>left1 <span class="token operator">&lt;</span> right1 <span class="token operator">&amp;&amp;</span> left2 <span class="token operator">&lt;</span> right2<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">//升序：将两个区间中较小的一个放到tmp中</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>left1<span class="token punctuation">]</span> <span class="token operator">&lt;</span> a<span class="token punctuation">[</span>left2<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            tmp<span class="token punctuation">[</span>index<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>left1<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
            tmp<span class="token punctuation">[</span>index<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>left2<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//检查两个区间中剩下的数归并到tmp中</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>left1 <span class="token operator">&lt;=</span> right1<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        tmp<span class="token punctuation">[</span>index<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>left1<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>left2 <span class="token operator">&lt;=</span> right2<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        tmp<span class="token punctuation">[</span>index<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>left2<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//拷贝数据从tmp到a，闭区间个数要加1</span>
    <span class="token comment">//+left：每次拷贝不是考全部，只需要拷贝归并的那一段就可以了</span>
    <span class="token function">memcpy</span><span class="token punctuation">(</span>a<span class="token operator">+</span>left<span class="token punctuation">,</span> tmp<span class="token operator">+</span>left<span class="token punctuation">,</span><span class="token punctuation">(</span>right<span class="token operator">-</span>left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">MergeSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">//创建一个临时数组</span>
    <span class="token keyword">int</span><span class="token operator">*</span> tmp <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">*</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assert</span><span class="token punctuation">(</span>tmp<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">_MergeSort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> tmp<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">free</span><span class="token punctuation">(</span>tmp<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h4><a id="_889"></a>🍍时间复杂度、空间复杂度、稳定性分析</h4> 
<blockquote> 
 <p><strong>⭐️时间复杂度：</strong></p> 
 <p><span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           O 
          
         
           ( 
          
         
           N 
          
         
           l 
          
         
           o 
          
         
           g 
          
         
           N 
          
         
           ) 
          
         
        
          O(NlogN) 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right: 0.0197em;">Nl</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right: 0.0359em;">g</span><span class="mord mathnormal" style="margin-right: 0.109em;">N</span><span class="mclose">)</span></span></span></span></span></span><br> 递归过程中每次都将一组平均分，分完后高度大概是logN</p> 
 <p><strong>⭐️空间复杂度：</strong><br> <span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           O 
          
         
           ( 
          
         
           N 
          
         
           ) 
          
         
        
          O(N) 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right: 0.109em;">N</span><span class="mclose">)</span></span></span></span></span></span><br> 要来一个临时空间存放归并好的区间的数据</p> 
 <p><strong>⭐️稳定性分析：</strong></p> 
 <p>在遇到相同的数时，可以就先将放前一段区间的数，再放后一段区间的数就可以保持稳定性了，所以说这个排序是<strong>稳定的</strong>.</p> 
</blockquote> 
<h3><a id="2_908"></a>🍯2.非递归实现</h3> 
<h4><a id="_910"></a>🍍基本思想</h4> 
<blockquote> 
 <p>⭐️首先区间的间距是1，所以就以间距为1一组一组合并，然后区间间距是2，所以就以间距是2一组一组合并，以此类推，直到所有区间都合并了。</p> 
 <p><img src="https://images2.imgbox.com/dc/a8/WgsOzrxX_o.png" alt="image-20220426151318810"></p> 
</blockquote> 
<h4><a id="_916"></a>🍍实现过程</h4> 
<blockquote> 
 <p>⭐️首先创建一个临时数组<mark>tmp</mark>，一开始<mark>gap</mark>间距是1，饭后我们定义左区间是[i, i+gap-1]，右区间是[i+gap, i+2*gap-1]，每一次循环到n-1为止，间隔是跳过两个区间，如果遇到<mark>right1</mark>越界则修正，<mark>left2</mark>越界则表示区间不存在，<mark>left2</mark>正常<mark>right2</mark>越界则修正<mark>right2</mark>，接着就是归并的过程，例如升序就将两个区间中较小的值放入<mark>tmp</mark>中，直到直到两个区间中有一个没有数据了结束，之后检查两个区间中剩下的数归并到<mark>tmp</mark>中，然后将<mark>tmp</mark>中的数拷贝到a中。</p> 
 <p><img src="https://images2.imgbox.com/08/52/SUKmqeXa_o.png" alt="image-20220426153427094"></p> 
</blockquote> 
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">MergeSortNot</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span><span class="token operator">*</span> tmp <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">*</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assert</span><span class="token punctuation">(</span>tmp<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> gap <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token comment">//当间距小于数组长度时继续</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>gap <span class="token operator">&lt;</span> n<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i <span class="token operator">+=</span> gap <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">//控制两个区间的边界</span>
            <span class="token comment">//[i, i+gap-1] [i+gap, i+2*gap-1]</span>
            <span class="token keyword">int</span> left1 <span class="token operator">=</span> i<span class="token punctuation">,</span> right1 <span class="token operator">=</span> i <span class="token operator">+</span> gap <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token keyword">int</span> left2 <span class="token operator">=</span> i <span class="token operator">+</span> gap<span class="token punctuation">,</span> right2 <span class="token operator">=</span> i <span class="token operator">+</span> gap <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token keyword">int</span> index <span class="token operator">=</span> i<span class="token punctuation">;</span>
            <span class="token comment">// 情况1  right1越界 修正</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>right1 <span class="token operator">&gt;=</span> n<span class="token punctuation">)</span>
                right1 <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token comment">// 情况2  left2越界 表示第二个区间不存在，修正成一个不存在的区间</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>left2 <span class="token operator">&gt;=</span> n<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                left2 <span class="token operator">=</span> n<span class="token punctuation">;</span>
                right2 <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token comment">// 情况3 left2正常 right2越界 修正right2</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>left2 <span class="token operator">&lt;</span> n <span class="token operator">&amp;&amp;</span> right2 <span class="token operator">&gt;=</span> n<span class="token punctuation">)</span>
                right2 <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"归并[%d,%d][%d,%d]--gap = %d\n"</span><span class="token punctuation">,</span> left1<span class="token punctuation">,</span> right1<span class="token punctuation">,</span> left2<span class="token punctuation">,</span> right2<span class="token punctuation">,</span>gap<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">//归并过程是，有一组结束了循环结束</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span>left1 <span class="token operator">&lt;=</span> right1 <span class="token operator">&amp;&amp;</span> left2 <span class="token operator">&lt;=</span> right2<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token comment">//升序：将两个区间中较小的一个放到tmp中</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>left1<span class="token punctuation">]</span> <span class="token operator">&lt;</span> a<span class="token punctuation">[</span>left2<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                    tmp<span class="token punctuation">[</span>index<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>left1<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
                    tmp<span class="token punctuation">[</span>index<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>left2<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
            <span class="token comment">//检查两个区间中剩下的数归并到tmp中</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span>left1 <span class="token operator">&lt;=</span> right1<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                tmp<span class="token punctuation">[</span>index<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>left1<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span>left2 <span class="token operator">&lt;=</span> right2<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                tmp<span class="token punctuation">[</span>index<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>left2<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token comment">//拷贝数据从tmp到a，闭区间个数要加1</span>
        <span class="token comment">//+left：每次拷贝不是考全部，只需要拷贝归并的那一段就可以了</span>
        <span class="token function">memcpy</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> tmp<span class="token punctuation">,</span> n <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//每次gap间距都乘以2</span>
        gap <span class="token operator">*=</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">free</span><span class="token punctuation">(</span>tmp<span class="token punctuation">)</span><span class="token punctuation">;</span>
    tmp <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h2><a id="_976"></a>🌏六.计数排序（非比较排序）</h2> 
<h4><a id="_978"></a>🍍基本思想</h4> 
<blockquote> 
 <p>⭐️计数排序是一个非基于比较的排序算法，优势在于在对一定范围内的整数排序时，它的复杂度为Ο(n+k)（其中k是整数的范围），快于任何比较排序算法。 当然这是一种牺牲空间换取时间的做法，而且当O(k)&gt;O(n*log(n))的时候其效率反而不如基于比较的排序。基数排序可以排序负数，但是不能排序浮点数</p> 
 <p><img src="https://images2.imgbox.com/a9/a9/2ZOB7alZ_o.gif" alt=""></p> 
</blockquote> 
<h4><a id="_984"></a>🍍实现过程</h4> 
<blockquote> 
 <p>⭐️为了不必要的空间浪费，我们首先采用相对映射的方法，计算出数组中的最大值和最小值，然后依据最大值和最小值开辟一个空间count，然后将所有数组映射到count中，之后偏离数组将所有数组依次取出来</p> 
</blockquote> 
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">CountSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">//初始化min和max</span>
    <span class="token keyword">int</span> min <span class="token operator">=</span> a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> max <span class="token operator">=</span> a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token comment">//相对映射，可以节省不比要空间,而且可以从第二个数开始比较</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&gt;</span> max<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            max <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> min<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            min <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//开辟的范围</span>
    <span class="token keyword">int</span> range <span class="token operator">=</span> max <span class="token operator">-</span> min <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token comment">//计数数组</span>
    <span class="token keyword">int</span><span class="token operator">*</span> count <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">calloc</span><span class="token punctuation">(</span>range<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assert</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//遍历映射计数</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        count<span class="token punctuation">[</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> min<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//遍历排序数组</span>
    <span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> range<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>count<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            a<span class="token punctuation">[</span>index<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> i <span class="token operator">+</span> min<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token function">free</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>
    count <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h4><a id="_1023"></a>🍍时间复杂度、空间复杂度、稳定性分析</h4> 
<blockquote> 
 <p><strong>⭐️时间复杂度：</strong></p> 
 <p><span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           O 
          
         
           ( 
          
         
           N 
          
         
           + 
          
         
           K 
          
         
           ) 
          
         
        
          O(N+K) 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right: 0.109em;">N</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0715em;">K</span><span class="mclose">)</span></span></span></span></span></span><br> 取决于次数和数组范围谁更大</p> 
 <p><strong>⭐️空间复杂度：</strong><br> <span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           O 
          
         
           ( 
          
         
           N 
          
         
           ) 
          
         
        
          O(N) 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right: 0.109em;">N</span><span class="mclose">)</span></span></span></span></span></span><br> <strong>⭐️稳定性分析：</strong></p> 
 <p>计数是在统计每个数出现的次数，但是相同的数哪个在前哪个在后，并没有区分，所以<strong>我们写的</strong><mark><strong>不稳定</strong>.</mark>。</p> 
 <p><font color="#DC143C">但是只是我们这里写的不稳定，计数排序可以写成稳定的，所以综合来说是稳定的</font></p> 
</blockquote> 
<h2><a id="_1042"></a>🌏七.八大排序比较</h2> 
<h3><a id="1_1044"></a>🍯1.性能测试代码</h3> 
<pre><code class="prism language-C++">#define N 10000

void TestOP()
{
	srand((unsigned int)time(NULL));

	int* a1 = (int*)malloc(sizeof(int) * N);
	int* a2 = (int*)malloc(sizeof(int) * N);
	int* a3 = (int*)malloc(sizeof(int) * N);
	int* a4 = (int*)malloc(sizeof(int) * N);
	int* a5 = (int*)malloc(sizeof(int) * N);
	int* a6 = (int*)malloc(sizeof(int) * N);
	int* a7 = (int*)malloc(sizeof(int) * N);
	int* a8 = (int*)malloc(sizeof(int) * N);

	int i = 0;
	for (i = 0; i &lt; N; i++)
	{
		a1[i] = rand();
		a2[i] = a1[i];
		a3[i] = a2[i];
		a4[i] = a3[i];
		a5[i] = a4[i];
		a6[i] = a5[i];
		a7[i] = a6[i];
		a8[i] = a7[i];
	}

	int begin1 = clock();
	//InsertSort(a1, N);
	int end1 = clock();

	int begin2 = clock();
	//ShellSort(a2, N);
	int end2 = clock();

	int begin3 = clock();
	//SelectSort(a3, N);
	int end3 = clock();

	int begin4 = clock();
	//HeapSort(a4, N);
	int end4 = clock();

	int begin5 = clock();
	//QuickSort(a5, 0, N - 1);
	int end5 = clock();

	int begin6 = clock();
	//MergeSort(a6, N);

	int end6 = clock();

	int begin7 = clock();
	//BubbleSort(a7, N);
	int end7 = clock();

	int begin8 = clock();
	//CountSort(a7, N);
	int end8 = clock();

	printf("InsertSort:%dms\n", end1 - begin1);
	printf("ShellSort:%dms\n", end2 - begin2);
	printf("SelectSort:%dms\n", end3 - begin3);
	printf("HeapSort:%dms\n", end4 - begin4);
	printf("QuickSort:%dms\n", end5 - begin5);
	printf("MergeSort:%dms\n", end6 - begin6);
	printf("BubbleSort:%dms\n", end7 - begin7);
	printf("CountSort:%dms\n", end8 - begin8);

	free(a1);
	free(a2);
	free(a3);
	free(a4);
	free(a5);
	free(a6);
	free(a7);
	free(a8);
}


void TextInsertSort() {
	int a[] = { 9,1,2,5,7,4,8,6,3,5 };
	InsertSort(a, sizeof(a) / sizeof(a[0]));
	PrintArry(a, sizeof(a) / sizeof(a[0]));
}

void TextBubbleSort() {
	int a[] = { 9,1,2,5,7,4,8,6,3,5 };
	BubbleSort(a, sizeof(a) / sizeof(a[0]));
	PrintArry(a, sizeof(a) / sizeof(a[0]));
}

void TextShellSort() {
	int a[] = { 9,1,2,5,7,4,8,6,3,5 };
	ShellSort(a, sizeof(a) / sizeof(a[0]));
	PrintArry(a, sizeof(a) / sizeof(a[0]));
}
void TextHeapSort() {
	int a[] = { 9,1,2,5,7,4,8,6,3,5 };
	HeapSort(a, sizeof(a) / sizeof(a[0]));
	PrintArry(a, sizeof(a) / sizeof(a[0]));
}
void TextSelectSort() {
	int a[] = { 9,1,2,5,7,4,8,6,3,5 };
	SelectSort(a, sizeof(a) / sizeof(a[0]));
	PrintArry(a, sizeof(a) / sizeof(a[0]));
}
void TextQuickSort() {
	int a[] = { 9,1,2,5,7,4,8,6,3,5 };
	QuickSort2(a, 0, sizeof(a) / sizeof(a[0])-1);
	PrintArry(a, sizeof(a) / sizeof(a[0]));
}
void TextMergeSort() {
	int a[] = { 10,6,7,1,3,9,4,2,5,2 };
	PrintArry(a, sizeof(a) / sizeof(a[0]));
	MergeSort(a, sizeof(a) / sizeof(a[0]));
	PrintArry(a, sizeof(a) / sizeof(a[0]));
}
void TextMergeSortNot() {
	int a[] = { 4,5,2,9,3,4,7,5,8 };
	PrintArry(a, sizeof(a) / sizeof(a[0]));
	MergeSortNot(a, sizeof(a) / sizeof(a[0]));
	PrintArry(a, sizeof(a) / sizeof(a[0]));
}
void TextCountSort() {
	int a[] = { 4,5,2,9,3,4,7,5,8 };
	//PrintArry(a, sizeof(a) / sizeof(a[0]));
	CountSort(a, sizeof(a) / sizeof(a[0]));
	PrintArry(a, sizeof(a) / sizeof(a[0]));
}
</code></pre> 
<h3><a id="2_1182"></a>🍯2.排序空间复杂度、时间复杂度、稳定性</h3> 
<blockquote> 
 <p>⭐️<strong>稳定性</strong>：相同的数排完数之后，相对顺序不变，那么就是稳定的。</p> 
</blockquote> 
<table><thead><tr><th align="center">排序方法</th><th align="center">时间复杂度（平均情况）</th><th align="center">时间复杂度（最好）</th><th align="center">时间复杂度（最坏）</th><th align="center">空间复杂度</th><th align="center">稳定性</th></tr></thead><tbody><tr><td align="center">插入排序</td><td align="center">O(N<sup>2</sup>)</td><td align="center">O(N)</td><td align="center">O(N<sup>2</sup>)</td><td align="center">O(1)</td><td align="center">稳定</td></tr><tr><td align="center">希尔排序</td><td align="center">O(N<sup>1.3</sup>)</td><td align="center">O(N)</td><td align="center">O(N<sup>2</sup>)</td><td align="center">O(1)</td><td align="center">不稳定</td></tr><tr><td align="center">选择排序</td><td align="center">O(N<sup>2</sup>)</td><td align="center">O(N<sup>2</sup>)</td><td align="center">O(N<sup>2</sup>)</td><td align="center">O(1)</td><td align="center">不稳定</td></tr><tr><td align="center">堆排序</td><td align="center">O(NlogN)</td><td align="center">O(NlogN)</td><td align="center">O(NlogN)</td><td align="center">O(1)</td><td align="center">不稳定</td></tr><tr><td align="center">冒泡排序</td><td align="center">O(N<sup>2</sup>)</td><td align="center">O(N)</td><td align="center">O(N<sup>2</sup> )</td><td align="center">O(1)</td><td align="center">稳定</td></tr><tr><td align="center">快速排序</td><td align="center">O(NlogN)</td><td align="center">O(NlogN)</td><td align="center">O(N<sup>2</sup> )</td><td align="center">O(logN)</td><td align="center">不稳定</td></tr><tr><td align="center">归并排序</td><td align="center">O(NlogN)</td><td align="center">O(NlogN)</td><td align="center">O(NlogN)</td><td align="center">O(N)</td><td align="center">稳定</td></tr><tr><td align="center">计数排序</td><td align="center">O(N+K)（k是整数的范围）</td><td align="center">O(N+K)</td><td align="center">O(N+K)</td><td align="center">O(N+K)</td><td align="center">稳定</td></tr></tbody></table> 
<hr> 
<h2><a id="_1199"></a>🌏总结</h2> 
<blockquote> 
 <p>⭐️排序当然不止这八种，过不这几种比较经典，感谢阅读。</p> 
 <p>⭐️<font color="#DC143C"><strong>码字不易喜欢的话，欢迎大家点赞支持和指正~</strong></font></p> 
</blockquote> 
<img src="https://images2.imgbox.com/09/75/K9lmTks4_o.jpg">
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/cb0d4a515d9e500b68c4ba2545be0202/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Python报错：PermissionError: [Errno 13] Permission denied解决方案</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/de246cf01b5801df653f0d561dffbbd9/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【Spring Cloud】openfeign负载均衡方案(和lb发展历史)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>