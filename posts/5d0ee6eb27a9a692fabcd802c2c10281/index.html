<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43;智能指针3——弱指针weak_ptr详解 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C&#43;&#43;智能指针3——弱指针weak_ptr详解" />
<meta property="og:description" content="目录
shared_ptr指针存在的问题
循环引用示例
代码
运行结果
使用weak_ptr解决循环引用问题
代码
运行结果
共享指针shared_ptr指针存在的问题 使用共享指针shared_ptr指针的主要原因是避免手动管理指针所关联的资源。但是，在某些情况下共享指针shared_ptr不能实现预期的行为：
一种情况是循环引用。如果两个对象使用shared_ptr指针相互引用，并且不存在对这些对象的其他引用，若要释放这些对象及其关联的资源，则共享指针shared_ptr不会释放数据，因为每个对象的引用计数仍为1。在这种情况下，可能想使用普通的指针，但是这样做需要手动管理相关资源的释放。另一种情况是当明确想要共享但不拥有对象。这种情况下引用的生存期超过了它所引用的对象的生命周期。如果使用共享指针shared_ptr指针则其将永远不会释放对象。如果使用普通指针则可能出现指针所引用的对象不再有效，这会带来访问已释放数据的风险。 对于这两种情况都可以使用弱指针weak_ptr指针处理。弱指针weak_ptr是共享指针shared_ptr的辅助类。该类允许共享但不拥有对象。它的use_count()返回对象的共享指针shared_ptr拥有者数量，共享该对象的弱指针weak_ptr指针不计入该数量。
弱指针weak_ptr需要共享指针shared_ptr才能创建。每当拥有该对象的最后一个共享指针失去其所有权时，任何弱指针weak_ptr都会自动变为空。因此，除了default和copy构造函数外，弱指针weak_ptr指针仅提供采用共享指针shared_ptr的构造函数。
使用初始指针所指对象的类型来对weak_ptr&lt;&gt;类进行模板化：
namespace std { template &lt;typename T&gt; class weak_ptr { public: typedef T element_type; ... }; } 不能使用运算符*和-&gt;直接访问weak_ptr的引用对象。相反，必须从中创建一个共享指针。这有两个原因：
根据弱指针创建共享指针，以检查是否存在（仍然）关联对象。如果不是，此操作将引发异常或创建一个空的共享指针（实际发生的情况取决于所使用的操作）。在处理引用的对象时，共享指针无法释放。 因此，弱指针weak_ptr仅提供少量操作：足以创建，复制和赋值一个弱指针，并将其转换为共享指针或检查它是否指向对象。
循环引用示例 代码 #include &lt;iostream&gt; #include &lt;string&gt; #include &lt;vector&gt; #include &lt;memory&gt; using namespace std; class Person { public: string m_sName; shared_ptr&lt;Person&gt; m_pMother; shared_ptr&lt;Person&gt; m_pFather; vector&lt;shared_ptr&lt;Person&gt;&gt; m_oKids; Person (const string&amp; sName, shared_ptr&lt;Person&gt; pMother = nullptr, shared_ptr&lt;Person&gt; pFather = nullptr) : m_sName(sName), m_pMother(pMother), m_pFather(pFather) { } ~Person() { cout &lt;&lt; &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/5d0ee6eb27a9a692fabcd802c2c10281/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-01-30T11:21:04+08:00" />
<meta property="article:modified_time" content="2020-01-30T11:21:04+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43;智能指针3——弱指针weak_ptr详解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="-toc" style="margin-left:0px;"> </p> 
<p id="shared_ptr%E6%8C%87%E9%92%88%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98-toc" style="margin-left:0px;"><a href="#shared_ptr%E6%8C%87%E9%92%88%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98" rel="nofollow">shared_ptr指针存在的问题</a></p> 
<p id="%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E7%A4%BA%E4%BE%8B-toc" style="margin-left:40px;"><a href="#%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E7%A4%BA%E4%BE%8B" rel="nofollow">循环引用示例</a></p> 
<p id="%E4%BB%A3%E7%A0%81-toc" style="margin-left:80px;"><a href="#%E4%BB%A3%E7%A0%81" rel="nofollow">代码</a></p> 
<p id="%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C-toc" style="margin-left:80px;"><a href="#%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C" rel="nofollow">运行结果</a></p> 
<p id="%E4%BD%BF%E7%94%A8weak_ptr%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E9%97%AE%E9%A2%98-toc" style="margin-left:0px;"><a href="#%E4%BD%BF%E7%94%A8weak_ptr%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E9%97%AE%E9%A2%98" rel="nofollow">使用weak_ptr解决循环引用问题</a></p> 
<p style="margin-left:40px;"><a href="#%E4%BB%A3%E7%A0%81" rel="nofollow">代码</a></p> 
<p style="margin-left:40px;"><a href="#%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C" rel="nofollow">运行结果</a></p> 
<hr id="hr-toc"> 
<h2 id="shared_ptr%E6%8C%87%E9%92%88%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98">共享指针shared_ptr指针存在的问题</h2> 
<p>使用共享指针shared_ptr指针的主要原因是避免手动管理指针所关联的资源。但是，在某些情况下共享指针shared_ptr不能实现预期的行为：</p> 
<ul><li>一种情况是循环引用。如果两个对象使用shared_ptr指针相互引用，并且不存在对这些对象的其他引用，若要释放这些对象及其关联的资源，则共享指针shared_ptr不会释放数据，因为每个对象的引用计数仍为1。在这种情况下，可能想使用普通的指针，但是这样做需要手动管理相关资源的释放。</li><li>另一种情况是当明确想要共享但不拥有对象。这种情况下引用的生存期超过了它所引用的对象的生命周期。如果使用共享指针shared_ptr指针则其将永远不会释放对象。如果使用普通指针则可能出现指针所引用的对象不再有效，这会带来访问已释放数据的风险。</li></ul> 
<p>对于这两种情况都可以使用弱指针weak_ptr指针处理。弱指针weak_ptr是共享指针shared_ptr的辅助类。该类允许共享但不拥有对象。它的use_count()返回对象的共享指针shared_ptr拥有者数量，共享该对象的弱指针weak_ptr指针不计入该数量。</p> 
<p>弱指针weak_ptr需要共享指针shared_ptr才能创建。每当拥有该对象的最后一个共享指针失去其所有权时，任何弱指针weak_ptr都会自动变为空。因此，除了default和copy构造函数外，弱指针weak_ptr指针仅提供采用共享指针shared_ptr的构造函数。</p> 
<p>使用初始指针所指对象的类型来对weak_ptr&lt;&gt;类进行模板化：</p> 
<pre class="has"><code class="language-cpp">namespace std {
    template &lt;typename T&gt;
    class weak_ptr
    {
        public:
            typedef T element_type;
            ...
    };
}</code></pre> 
<p>不能使用运算符*和-&gt;直接访问weak_ptr的引用对象。相反，必须从中创建一个共享指针。这有两个原因：</p> 
<ol><li>根据弱指针创建共享指针，以检查是否存在（仍然）关联对象。如果不是，此操作将引发异常或创建一个空的共享指针（实际发生的情况取决于所使用的操作）。</li><li>在处理引用的对象时，共享指针无法释放。</li></ol> 
<p>因此，弱指针weak_ptr仅提供少量操作：足以创建，复制和赋值一个弱指针，并将其转换为共享指针或检查它是否指向对象。</p> 
<h3 id="%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E7%A4%BA%E4%BE%8B">循环引用示例</h3> 
<h4 id="%E4%BB%A3%E7%A0%81">代码</h4> 
<pre class="has"><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;memory&gt;

using namespace std;

class Person {
  public:
    string m_sName;
    shared_ptr&lt;Person&gt; m_pMother;
    shared_ptr&lt;Person&gt; m_pFather;
    vector&lt;shared_ptr&lt;Person&gt;&gt; m_oKids;

    Person (const string&amp; sName,
            shared_ptr&lt;Person&gt; pMother = nullptr,
            shared_ptr&lt;Person&gt; pFather = nullptr)
     : m_sName(sName), m_pMother(pMother), m_pFather(pFather) {
    }

    ~Person() {
      cout &lt;&lt; "删除 " &lt;&lt; m_sName &lt;&lt; endl;
    }
};

shared_ptr&lt;Person&gt; initFamily (const string&amp; sName)
{
    shared_ptr&lt;Person&gt; pMom(new Person(sName + "的母亲"));
    shared_ptr&lt;Person&gt; pDad(new Person(sName + "的父亲"));
    shared_ptr&lt;Person&gt; pKid(new Person(sName, pMom, pDad));
    pMom-&gt;m_oKids.push_back(pKid);
    pDad-&gt;m_oKids.push_back(pKid);
    return pKid;
}

int main()
{
    string sName = "张三";
    shared_ptr&lt;Person&gt; pPerson = initFamily(sName);

    cout &lt;&lt; sName &lt;&lt; "家存在" &lt;&lt; endl;
    cout &lt;&lt; "- " &lt;&lt; sName &lt;&lt; "被分享" &lt;&lt; pPerson.use_count() &lt;&lt; "次" &lt;&lt; endl;
    cout &lt;&lt; "- " &lt;&lt; sName &lt;&lt; "母亲第一个孩子的名字是："
         &lt;&lt; pPerson-&gt;m_pMother-&gt;m_oKids[0]-&gt;m_sName &lt;&lt; endl;

    sName = "李四";
    pPerson = initFamily(sName);
    cout &lt;&lt; sName &lt;&lt; "家已存在" &lt;&lt; endl;
}</code></pre> 
<h4 id="%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C">运行结果</h4> 
<pre class="has"><code>张三家存在
- 张三被分享3次
- 张三母亲第一个孩子的名字是：张三
李四家已存在</code></pre> 
<p>以上代码中一个类Person具有名称和对其他Person的可选引用，即父母（母亲和父亲）和孩子。</p> 
<p>首先，initFamily()创建三个Person对象：pMom，pDad和pKid，并根据传递的参数使用相应的名称进行初始化。另外，将孩子与父母一起初始化，并且对于两个父母，将孩子插入父母对象的孩子列表中。最后，initFamily()返回孩子对象的共享指针shared_ptr。</p> 
<p>下图显示了initFamily()末尾以及调用并将结果赋给pPerson之后的结果情况。</p> 
<p><img alt="" class="has" height="497" src="https://images2.imgbox.com/6e/22/pP5STED4_o.png" width="859"></p> 
<p>pPerson是家庭的最后一个句柄。但是，在内部，每个对象都有从孩子到每个父对象的引用。例如，在pPerson获得新值之前，张三被共享了3次。现在，如果我们释放该家族的最后一个句柄（通过为pPerson分配一个新的Person对象或nullptr），则不会释放任何Person对象，因为每个Person对象仍然至少具有一个共享的指针指向它。结果，每个Person对象的析构函数（将显示“删除名称”）都不会被调用。</p> 
<h2 id="%E4%BD%BF%E7%94%A8weak_ptr%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E9%97%AE%E9%A2%98">使用weak_ptr解决循环引用问题</h2> 
<h3>代码</h3> 
<pre class="has"><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;memory&gt;

using namespace std;

class Person {
  public:
    string m_sName;
    shared_ptr&lt;Person&gt; m_pMother;
    shared_ptr&lt;Person&gt; m_pFather;
    vector&lt;weak_ptr&lt;Person&gt;&gt; m_oKids; //弱指针

    Person (const string&amp; sName,
            shared_ptr&lt;Person&gt; pMother = nullptr,
            shared_ptr&lt;Person&gt; pFather = nullptr)
     : m_sName(sName), m_pMother(pMother), m_pFather(pFather) {
    }

    ~Person() {
      cout &lt;&lt; "删除 " &lt;&lt; m_sName &lt;&lt; endl;
    }
};

shared_ptr&lt;Person&gt; initFamily (const string&amp; sName)
{
    shared_ptr&lt;Person&gt; pMom(new Person(sName + "的母亲"));
    shared_ptr&lt;Person&gt; pDad(new Person(sName + "的父亲"));
    shared_ptr&lt;Person&gt; pKid(new Person(sName, pMom, pDad));
    pMom-&gt;m_oKids.push_back(pKid);
    pDad-&gt;m_oKids.push_back(pKid);
    return pKid;
}

int main()
{
    string sName = "张三";
    shared_ptr&lt;Person&gt; pPerson = initFamily(sName);

    cout &lt;&lt; sName &lt;&lt; "家存在" &lt;&lt; endl;
    cout &lt;&lt; "- " &lt;&lt; sName &lt;&lt; "被分享" &lt;&lt; pPerson.use_count() &lt;&lt; "次" &lt;&lt; endl;
    cout &lt;&lt; "- " &lt;&lt; sName &lt;&lt; "母亲第一个孩子的名字是："
         &lt;&lt; pPerson-&gt;m_pMother-&gt;m_oKids[0].lock()-&gt;m_sName &lt;&lt; endl;

    sName = "李四";
    pPerson = initFamily(sName);
    cout &lt;&lt; sName &lt;&lt; "家已存在" &lt;&lt; endl;
}</code></pre> 
<h3>运行结果</h3> 
<pre class="has"><code>张三家存在
- 张三被分享1次
- 张三母亲第一个孩子的名字是：张三
删除 张三
删除 张三的父亲
删除 张三的母亲
李四家已存在
删除 李四
删除 李四的父亲
删除 李四的母亲</code></pre> 
<p>通过将vector中的共享指针shared_ptr指针换成弱指针weak_ptr指针，可以打破共享指针shared_ptr的循环，以便在一个方向上（从孩子到父母）使用共享指针，而从父母到孩子，则使用弱指针，如下图所示。</p> 
<p><img alt="" class="has" height="440" src="https://images2.imgbox.com/20/13/H13ZuN0o_o.png" width="855"></p> 
<p>一旦失去对创建的家庭的句柄（通过为pPerson分配新值或通过离开main()函数），孩子的对象将失去其最后一个所有者，这又会使父母双方都失去了最后的所有者。因此，最初由new创建的所有对象现在都将被删除，以便调用它们的析构函数。</p> 
<p>请注意，要使用弱指针，必须稍微修改通过弱指针访问对象的方式。需要在表达式中插入lock()函数如下所示</p> 
<pre class="has"><code class="language-cpp">pPerson-&gt;mother-&gt;kids[0].lock()-&gt;name</code></pre> 
<p>而不是调用</p> 
<pre class="has"><code class="language-cpp">pPerson-&gt;mother-&gt;kids[0]-&gt;name</code></pre> 
<p>lock()函数从kids的向量所包含的弱指针weak_ptr中产生一个共享指针shared_ptr。如果无法进行此修改（例如，由于该对象的最后所有者同时释放了该对象），则lock()函数会生成一个空的shared_ptr。在这种情况下，调用运算符*或-&gt;将导致未定义的行为。</p> 
<p>如果不确定弱指针指向的对象是否仍然存在，则可以使用以下几种方法：</p> 
<ol><li>调用expired()，如果弱指针weak_ptr不再共享对象，则返回true。此选项等效于检查use_count()是否等于0，但可能更快。</li><li>通过使用相应的共享指针shared_ptr构造函数将弱指针weak_ptr显式转换为共享指针shared_ptr。如果没有有效的引用对象，则此构造方法将引发bad_weak_ptr异常。这个异常是从std::exception派生的类的异常，其中what()会返回“ bad_weak_ptr”。</li><li>调用use_count()来询问关联对象拥有的所有者数量。如果返回值为0，则不再有有效的对象。但是请注意，通常只应出于调试目的调用use_count()，因为C++标准库明确指出：“use_count()不一定有效。”</li></ol> 
<h2>接口列表</h2> 
<p>下表为弱指针提供的所有操作。</p> 
<table cellspacing="0"><tbody><tr><td>操作</td><td>结果</td></tr><tr><td>weak_ptr&lt;T&gt; wp</td><td>默认构造函数；创建一个空的弱指针</td></tr><tr><td>weak_ptr&lt;T&gt; wp(sp)</td><td>创建一个弱指针，共享由sp拥有的指针的所有权</td></tr><tr><td>weak_ptr&lt;T&gt; wp(wp2)</td><td>创建一个弱指针，共享由wp2拥有的指针的所有权</td></tr><tr><td>wp.~weak_ptr()</td><td>析构函数；销毁弱指针，但对拥有的对象无效</td></tr><tr><td>wp = wp2</td><td>赋值（wp之后共享wp2的所有权，放弃先前拥有的对象的所有权）</td></tr><tr><td>wp = sp</td><td>用共享指针sp进行赋值（wp之后共享sp的所有权，放弃先前拥有的对象的所有权）</td></tr><tr><td>wp.swap(wp2)</td><td>交换wp和wp2的指针</td></tr><tr><td>swap(wp1,wp2)</td><td>交换wp1和wp2的指针</td></tr><tr><td>wp.reset()</td><td>放弃拥有对象的所有权（如果有的话），并重新初始化为空的弱指针</td></tr><tr><td>wp.use_count()</td><td>返回共享所有者的数量（拥有对象的shared_ptr数目）；如果弱指针为空，则返回0</td></tr><tr><td>wp.expired()</td><td>返回wp是否为空（等同于wp.use_count() == 0，但可能更快）</td></tr><tr><td>wp.lock()</td><td>返回共享指针，该共享指针共享弱指针拥有的指针的所有权（如果没有共享指针，则为空共享指针）</td></tr><tr><td>wp.owner_before(wp2)</td><td>提供严格的弱排序和另一个弱指针</td></tr><tr><td>wp.owner_before(sp)</td><td>通过共享指针提供严格的弱排序</td></tr></tbody></table> 
<p>构造函数创建一个空的弱指针，调用它的expired()会返回true。因为lock()会返回一个共享指针，所以对象的使用计数在共享指针的生命周期内会增加。这是处理弱指针共享对象的唯一方法。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/61c2e78f594f10ed39dfad5eba2197d3/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Vue 页面载入时立刻触发某个函数</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3973651db4cde94e05ca6d1e0b4da0b1/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">论文笔记——Thompson Sampling for Contextual Bandits with Linear Payoffs(线性收益)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>