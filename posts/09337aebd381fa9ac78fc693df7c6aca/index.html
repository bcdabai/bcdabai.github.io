<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>红黑树知识全面详解之节点插入 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="红黑树知识全面详解之节点插入" />
<meta property="og:description" content="将一个节点插入到红黑树中，需要执行哪些步骤呢？首先，将红黑树当作一颗二叉查找树，将节点插入；然后，将节点着色为红色；最后，通过旋转和重新着色等方法来修正该树，使之重新成为一颗红黑树。详细描述如下：
第一步: 将红黑树当作一颗二叉查找树，将节点插入。
红黑树本身就是一颗二叉查找树，将节点插入后，该树仍然是一颗二叉查找树。也就意味着，树的键值仍然是有序的。此外，无论是左旋还是右旋，若旋转之前这棵树是二叉查找树，旋转之后它一定还是二叉查找树。这也就意味着，任何的旋转和重新着色操作，都不会改变它仍然是一颗二叉查找树的事实。
好吧？那接下来，我们就来想方设法的旋转以及重新着色，使这颗树重新成为红黑树！
第二步：将插入的节点着色为&#34;红色&#34;。
为什么着色成红色，而不是黑色呢？为什么呢？在回答之前，我们需要重新温习一下红黑树的特性：
(1) 每个节点或者是黑色，或者是红色。
(2) 根节点是黑色。
(3) 每个叶子节点是黑色。 [注意：这里叶子节点，是指为空的叶子节点！]
(4) 如果一个节点是红色的，则它的子节点必须是黑色的。
(5) 从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。
将插入的节点着色为红色，不会违背&#34;特性(5)&#34;！少违背一条特性，就意味着我们需要处理的情况越少。接下来，就要努力的让这棵树满足其它性质即可；满足了的话，它就又是一颗红黑树了。
第三步: 通过一系列的旋转或着色等操作，使之重新成为一颗红黑树。
第二步中，将插入节点着色为&#34;红色&#34;之后，不会违背&#34;特性(5)&#34;。那它到底会违背哪些特性呢？
对于&#34;特性(1)&#34;，显然不会违背了。因为我们已经将它涂成红色了。
对于&#34;特性(2)&#34;，显然也不会违背。在第一步中，我们是将红黑树当作二叉查找树，然后执行的插入操作。而根据二叉查找数的特点，插入操作不会改变根节点。所以，根节点仍然是黑色。
对于&#34;特性(3)&#34;，显然不会违背了。这里的叶子节点是指的空叶子节点，插入非空节点并不会对它们造成影响。
对于&#34;特性(4)&#34;，是有可能违背的！
那接下来，想办法使之&#34;满足特性(4)&#34;，就可以将树重新构造成红黑树了。
根据被插入节点的父节点的情况，可以将&#34;当节点z被着色为红色节点，并插入二叉树&#34;划分为三种情况来处理。
① 情况说明：被插入的节点是根节点。
处理方法：直接把此节点涂为黑色。
② 情况说明：被插入的节点的父节点是黑色。
处理方法：什么也不需要做。节点被插入后，仍然是红黑树。
③ 情况说明：被插入的节点的父节点是红色。
处理方法：那么，该情况与红黑树的“特性(5)”相冲突。这种情况下，被插入节点是一定存在非空祖父节点的；进一步的讲，被插入节点也一定存在叔叔节点(即使叔叔节点为空，我们也视之为存在，空节点本身就是黑色节点)。理解这点之后，我们依据&#34;叔叔节点的情况&#34;，将这种情况进一步划分为3种情况(Case)。
现象说明
处理策略
Case 1
当前节点的父节点是红色，且当前节点的祖父节点的另一个子节点（叔叔节点）也是红色。
(01) 将“父节点”设为黑色。
(02) 将“叔叔节点”设为黑色。
(03) 将“祖父节点”设为“红色”。
(04) 将“祖父节点”设为“当前节点”(红色节点)；即，之后继续对“当前节点”进行操作。
Case 2
当前节点的父节点是红色，叔叔节点是黑色，且当前节点是其父节点的右孩子
(01) 将“父节点”作为“新的当前节点”。
(02) 以“新的当前节点”为支点进行左旋。
Case 3
当前节点的父节点是红色，叔叔节点是黑色，且当前节点是其父节点的左孩子
(01) 将“父节点”设为“黑色”。
(02) 将“祖父节点”设为“红色”。
(03) 以“祖父节点”为支点进行右旋。
1. (Case 1)叔叔是红色" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/09337aebd381fa9ac78fc693df7c6aca/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-11-25T18:33:34+08:00" />
<meta property="article:modified_time" content="2018-11-25T18:33:34+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">红黑树知识全面详解之节点插入</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p style="margin-left:0pt;"><span style="color:#4f4f4f;">将一个节点插入到红黑树中，需要执行哪些步骤呢？首先，将红黑树当作一颗二叉查找树，将节点插入；然后，将节点着色为红色；最后，通过旋转和重新着色等方法来修正该树，使之重新成为一颗红黑树。详细描述如下</span><span style="color:#4f4f4f;">：</span></p> 
<p style="margin-left:0pt;"><span style="color:#f33b45;">第一步: 将红黑树当作一颗二叉查找树，将节点插入。</span><br><span style="color:#4f4f4f;">       红黑树本身就是一颗二叉查找树，将节点插入后，该树仍然是一颗二叉查找树。也就意味着，树的键值仍然是有序的。此外，无论是左旋还是右旋，若旋转之前这棵树是二叉查找树，旋转之后它一定还是二叉查找树。这也就意味着，任何的旋转和重新着色操作，都不会改变它仍然是一颗二叉查找树的事实。</span><br><span style="color:#4f4f4f;">       好吧？那接下来，我们就来想方设法的旋转以及重新着色，使这颗树重新成为红黑树！</span></p> 
<p style="margin-left:0pt;"><span style="color:#f33b45;">第二步：将插入的节点着色为"红色"。</span><br><span style="color:#4f4f4f;">       为什么着色成红色，而不是黑色呢？为什么呢？在回答之前，我们需要重新温习一下红黑树的特性：</span><br><span style="color:#4f4f4f;">(1) 每个节点或者是黑色，或者是红色。</span><br><span style="color:#4f4f4f;">(2) 根节点是黑色。</span><br><span style="color:#4f4f4f;">(3) 每个叶子节点是黑色。 [注意：这里叶子节点，是指为空的叶子节点！]</span><br><span style="color:#4f4f4f;">(4) 如果一个节点是红色的，则它的子节点必须是黑色的。</span><br><span style="color:#4f4f4f;">(5) 从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。</span><br><span style="color:#4f4f4f;">       将插入的节点着色为红色，不会违背"特性(5)"！少违背一条特性，就意味着我们需要处理的情况越少。接下来，就要努力的让这棵树满足其它性质即可；满足了的话，它就又是一颗红黑树了。</span></p> 
<p style="margin-left:0pt;"><span style="color:#f33b45;">第三步: 通过一系列的旋转或着色等操作，使之重新成为一颗红黑树。</span><br><span style="color:#4f4f4f;">       第二步中，将插入节点着色为"红色"之后，不会违背"特性(5)"。那它到底会违背哪些特性呢？</span><br><span style="color:#4f4f4f;">       对于"特性(1)"，显然不会违背了。因为我们已经将它涂成红色了。</span><br><span style="color:#4f4f4f;">       对于"特性(2)"，显然也不会违背。在第一步中，我们是将红黑树当作二叉查找树，然后执行的插入操作。而根据二叉查找数的特点，插入操作不会改变根节点。所以，根节点仍然是黑色。</span><br><span style="color:#4f4f4f;">       对于"特性(3)"，显然不会违背了。这里的叶子节点是指的空叶子节点，插入非空节点并不会对它们造成影响。</span><br><span style="color:#4f4f4f;">       对于"特性(4)"，是有可能违背的！</span><br><span style="color:#4f4f4f;">       那接下来，想办法使之"满足特性(4)"，就可以将树重新构造成红黑树了。</span></p> 
<p style="margin-left:0pt;"> </p> 
<p style="text-indent:0;"><span style="color:#4f4f4f;">根据被插入节点的父节点的情况，可以将"当节点z被着色为红色节点，并插入二叉树"划分为三种情况来处理。</span><br><span style="color:#4f4f4f;">① 情况说明：被插入的节点是根节点。</span><br><span style="color:#4f4f4f;">    处理方法：直接把此节点涂为黑色。</span><br><span style="color:#4f4f4f;">② 情况说明：被插入的节点的父节点是黑色。</span><br><span style="color:#4f4f4f;">    处理方法：什么也不需要做。节点被插入后，仍然是红黑树。</span><br><span style="color:#4f4f4f;">③ 情况说明：被插入的节点的父节点是红色。</span><br><span style="color:#4f4f4f;">    处理方法：那么，该情况与红黑树的“特性(5)”相冲突。这种情况下，被插入节点是一定存在非空祖父节点的；进一步的讲，被插入节点也一定存在叔叔节点(即使叔叔节点为空，我们也视之为存在，空节点本身就是黑色节点)。理解这点之后，我们依据"叔叔节点的情况"，将这种情况进一步划分为3种情况(Case)。</span></p> 
<table border="1" cellspacing="0" style="margin-left:-5.1pt;"><tbody><tr><td style="background-color:#ffffff;width:56.75pt;"> <p style="margin-left:0pt;"> </p> </td><td style="background-color:#ffffff;width:190pt;"> <p style="margin-left:0pt;"><span style="color:#000066;">现象说明</span></p> </td><td style="background-color:#ffffff;width:189.55pt;"> <p style="margin-left:0pt;"><span style="color:#000000;">处理策略</span></p> </td></tr><tr><td style="background-color:#ffffff;width:56.75pt;"> <p style="margin-left:0pt;"><span style="color:#000000;">Case 1</span></p> </td><td style="background-color:#ffffff;width:190pt;"> <p style="margin-left:0pt;"><span style="color:#000000;">当前节点的父节点是红色，且当前节点的祖父节点的另一个子节点（叔叔节点）也是红色。</span></p> </td><td style="background-color:#ffffff;width:189.55pt;"> <p style="margin-left:0pt;"><span style="color:#000000;">(01) 将“父节点”设为黑色。</span><br><span style="color:#000000;">(02) 将“叔叔节点”设为黑色。</span><br><span style="color:#000000;">(03) 将“祖父节点”设为“红色”。</span><br><span style="color:#000000;">(04) 将“祖父节点”设为“当前节点”(红色节点)；即，之后继续对“当前节点”进行操作。</span></p> </td></tr><tr><td style="background-color:#ffffff;width:56.75pt;"> <p style="margin-left:0pt;"><span style="color:#000000;">Case 2</span></p> </td><td style="background-color:#ffffff;width:190pt;"> <p style="margin-left:0pt;"><span style="color:#000000;">当前节点的父节点是红色，叔叔节点是黑色，且当前节点是其父节点的右孩子</span></p> </td><td style="background-color:#ffffff;width:189.55pt;"> <p style="margin-left:0pt;"><span style="color:#000000;">(01) 将“父节点”作为“新的当前节点”。</span><br><span style="color:#000000;">(02) 以“新的当前节点”为支点进行左旋。</span></p> </td></tr><tr><td style="background-color:#ffffff;width:56.75pt;"> <p style="margin-left:0pt;"><span style="color:#000000;">Case 3</span></p> </td><td style="background-color:#ffffff;width:190pt;"> <p style="margin-left:0pt;"><span style="color:#000000;">当前节点的父节点是红色，叔叔节点是黑色，且当前节点是其父节点的左孩子</span></p> </td><td style="background-color:#ffffff;width:189.55pt;"> <p style="margin-left:0pt;"><span style="color:#000000;">(01) 将“父节点”设为“黑色”。</span><br><span style="color:#000000;">(02) 将“祖父节点”设为“红色”。</span><br><span style="color:#000000;">(03) 以“祖父节点”为支点进行右旋。</span></p> </td></tr></tbody></table> 
<p style="margin-left:0pt;"><span style="color:#4f4f4f;">1. (Case 1)叔叔是红色</span></p> 
<p style="text-indent:0;"><span style="color:#4f4f4f;">1.1 现象说明</span><br><span style="color:#4f4f4f;">当前节点(即，被插入节点)的父节点是红色，且当前节点的祖父节点的另一个子节点（叔叔节点）也是红色。</span></p> 
<p style="margin-left:0pt;"><span style="color:#4f4f4f;">1.2 处理策略</span><br><span style="color:#4f4f4f;">(01) 将“父节点”设为黑色。</span><br><span style="color:#4f4f4f;">(02) 将“叔叔节点”设为黑色。</span><br><span style="color:#4f4f4f;">(03) 将“祖父节点”设为“红色”。</span><br><span style="color:#4f4f4f;">(04) 将“祖父节点”设为“当前节点”(红色节点)；即，之后继续对“当前节点”进行操作。</span><br><span style="color:#4f4f4f;">    “当前节点”和“父节点”都是红色，违背“特性(4)”。所以，将“父节点”设置“黑色”以解决这个问题。</span><br><span style="color:#4f4f4f;">    但是，将“父节点”由“红色”变成“黑色”之后，违背了“特性(5)”：因为，包含“父节点”的分支的黑色节点的总数增加了1。解决这个问题的办法是：将“祖父节点”由“黑色”变成红色，同时，将“叔叔节点”由“红色”变成“黑色”。关于这里，说明几点：</span><span style="color:#4f4f4f;">第一，</span><span style="color:#4f4f4f;">为什么“祖父节点”之前是黑色？这个应该很容易想明白，因为在变换操作之前，该树是红黑树，“父节点”是红色，那么“祖父节点”一定是黑色。 第二，为什么将“祖父节点”由“黑色”变成红色，同时，将“叔叔节点”由“红色”变成“黑色”；能解决“包含‘父节点’的分支的黑色节点的总数增加了1”的问题。这个道理也很简单。“包含‘父节点’的分支的黑色节点的总数增加了1” 同时也意味着 “包含‘祖父节点’的分支的黑色节点的总数增加了1”，既然这样，我们通过将“祖父节点”由“黑色”变成“红色”以解决“包含‘祖父节点’的分支的黑色节点的总数增加了1”的问题； 但是，这样处理之后又会引起另一个问题“包含‘叔叔’节点的分支的黑色节点的总数减少了1”，现在我们已知“叔叔节点”是“红色”，将“叔叔节点”设为“黑色”就能解决这个问题。 所以，将“祖父节点”由“黑色”变成红色，同时，将“叔叔节点”由“红色”变成“黑色”；就解决了该问题。</span><br><span style="color:#4f4f4f;">    按照上面的步骤处理之后：当前节点、父节点、叔叔节点之间都不会违背红黑树特性，但祖父节点却不一定。若此时，祖父节点是根节点，直接将祖父节点设为“黑色”，那就完全解决这个问题了；若祖父节点不是根节点，那我们需要将“祖父节点”设为“新的当前节点”，接着对“新的当前节点”进行分析。</span></p> 
<p style="text-align:center;"><img alt="" class="has" src="https://images2.imgbox.com/b7/8e/P9gsFGZ2_o.png"></p> 
<p style="margin-left:0pt;"><span style="color:#4f4f4f;">2.</span><span style="color:#4f4f4f;"> (Case 2)叔叔是黑色，且当前节点是右孩子</span></p> 
<p style="text-indent:0;"><span style="color:#4f4f4f;">2.1 现象说明</span><br><span style="color:#4f4f4f;">当前节点(即，被插入节点)的父节点是红色，叔叔节点是黑色，且当前节点是其父节点的右孩子</span></p> 
<p style="margin-left:0pt;"><span style="color:#4f4f4f;">2.2 处理策略</span><br><span style="color:#4f4f4f;">(01) 将“父节点”作为“新的当前节点”。</span><br><span style="color:#4f4f4f;">(02) 以“新的当前节点”为支点进行左旋。</span><br><span style="color:#4f4f4f;">      首先，将“父节点”作为“新的当前节点”；接着，以“新的当前节点”为支点进行左旋。 为了便于理解，我们先说明第(02)步，再说明第(01)步；为了便于说明，我们设置“父节点”的代号为F(Father)，“当前节点”的代号为S(Son)。</span><br><span style="color:#4f4f4f;">为什么要“以F为支点进行左旋”呢？根据已知条件可知：S是F的右孩子。而之前我们说过，我们处理红黑树的核心思想：将红色的节点移到根节点；然后，将根节点设为黑色。既然是“将红色的节点移到根节点”，那就是说要不断的将破坏红黑树特性的红色节点上移(即向根方向移动)。 而S又是一个右孩子，因此，我们可以通过“左旋”来将S上移！ </span><br><span style="color:#4f4f4f;">      按照上面的步骤(以F为支点进行左旋)处理之后：若S变成了根节点，那么直接将其设为“黑色”，就完全解决问题了；若S不是根节点，那我们需要执行步骤(01)，即“将F设为‘新的当前节点’”。那为什么不继续以S为新的当前节点继续处理，而需要以F为新的当前节点来进行处理呢？这是因为“左旋”之后，F变成了S的“子节点”，即S变成了F的父节点；而我们处理问题的时候，需要从下至上(由叶到根)方向进行处理；也就是说，必须先解决“孩子”的问题，再解决“父亲”的问题；所以，我们执行步骤(01)：将“父节点”作为“新的当前节点”。</span></p> 
<p style="text-align:center;"><img alt="" class="has" src="https://images2.imgbox.com/94/9b/eLHVQEh5_o.png"></p> 
<p style="margin-left:0pt;"><span style="color:#4f4f4f;">3. (Case 3)叔叔是黑色，且当前节点是左孩子</span></p> 
<p style="margin-left:0pt;"><span style="color:#4f4f4f;">3.1 现象说明</span><br><span style="color:#4f4f4f;">当前节点(即，被插入节点)的父节点是红色，叔叔节点是黑色，且当前节点是其父节点的左孩子</span></p> 
<p style="margin-left:0pt;"><span style="color:#4f4f4f;">3.2 处理策略</span><br><span style="color:#4f4f4f;">(01) 将“父节点”设为“黑色”。</span><br><span style="color:#4f4f4f;">(02) 将“祖父节点”设为“红色”。</span><br><span style="color:#4f4f4f;">(03) 以“祖父节点”为支点进行右旋。</span></p> 
<p style="margin-left:0pt;"><span style="color:#4f4f4f;">      下面谈谈为什么要这样处理。(建议理解的时候，通过下面的图进行对比)</span><br><span style="color:#4f4f4f;">      为了便于说明，我们设置“当前节点”为S(Original Son)，“兄弟节点”为B(Brother)，“叔叔节点”为U(Uncle)，“父节点”为F(Father)，祖父节点为G(Grand-Father)。</span><br><span style="color:#4f4f4f;">      S和F都是红色，违背了红黑树的“特性(4)”，我们可以将F由“红色”变为“黑色”，就解决了“违背‘特性(4)’”的问题；但却引起了其它问题：违背特性(5)，因为将F由红色改为黑色之后，所有经过F的分支的黑色节点的个数增加了1。那我们如何解决“所有经过F的分支的黑色节点的个数增加了1”的问题呢？ 我们可以通过“将G由黑色变成红色”，同时“以G为支点进行右旋”来解决。</span></p> 
<p style="text-align:center;"><img alt="" class="has" src="https://images2.imgbox.com/86/1e/k6HSKOoz_o.png"></p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d39bb7da885186cd20eac76a922966cb/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Ubuntu18.04 安装gnome-tweak-tool安装TopIcons Plus | 解决软件图标不显示问题 | 解决坚果云图标不显示问题</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/13c5f5e7a2df1b4f4a322a8109c0fbca/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">以指针作为函数参数，读入三个浮点数，将数字的整数部分和小数部分分别输出</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>