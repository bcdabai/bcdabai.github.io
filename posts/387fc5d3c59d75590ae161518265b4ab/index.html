<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Xilinx RTL编码指南(一) - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Xilinx RTL编码指南(一)" />
<meta property="og:description" content="Xilinx RTL编码指南一 控制信号与控制集Reset使用复位的时间和位置同步复位与异步复位复位编码实例 1：乘法器与异步复位异步复位RTLsynthesis 同步复位RTLsynthesis 尝试消除HDL代码复位时出现问题 时钟使能创建时钟使能复位和时钟使能的先后使用综合属性控制使能/重置提取DIRECT_ENABLEDIRECT_RESET 将逻辑从控制引脚推到数据引脚 信号控制技巧 该一系列为学习ug949-vivado-design-methodology.pdf的记录，该文档包含了对Xilinx器件最佳实践的方法学。 控制信号与控制集 ​ 控制集指用于驱动任何给定 SRL、 LUTRAM 或寄存器的控制信号组 （置位/复位、时钟使能和时钟）。对任意控制信号的独特组合，都能构成独立控制集。背后的原因是一个重要的概念，即在 7 系列 slice 中的寄存器都共享相同的控制信号，因此只有使用相同控制集的寄存器才能打包到同一个 slice 中。不同slice可以有不同的控制信号。例如，如果具有给定控制集的寄存器仅具有一个寄存器作为加载，则被占据的片中的其他七个寄存器将不可用。（在wp 405-7 series FPGAS The Logical Advantage里面说明了确实是这样）
​ 同时拥有多个独立控制集的设计会造成大量资源浪费和布局选项数量减少，导致功耗上升，性能下降。从布局的角度而言，拥有较少数量控制集的设计能提供更多选项和更高灵活性，一般也能产生更加理想的结果。在 UltraScale™ 器件中，在 CLB 内部能灵活地实现控制集的映射。未驱动的复位不形成控制集的一部分，因为是在片内局部生成的。然而，限制独立控制集数目是为一组逻辑布局提供最大灵活性的一个好方法。
Reset 复位是需要在设计中考虑和设限的更常见也更重要的控制信号之一。复位会给用户设计的性能、占位面积和功耗产生显著影响。
经引用得到的同步代码会产生下列资源：
LUT寄存器移位寄存器 LUT(SRL)块存储器或 LUT 存储器DSP48 寄存器 复位的选择和使用会影响上述组件的选择，导致给定设计中资源利用率下降。如果在阵列上误置复位，会产生截然不同的结果，可能是推断出一个块 RAM，也可能是推断出数千个寄存器。在乘法器输入或输出处描述异步复位，可能造成寄存器布置在 slice 上而非 DSP 块上。在此类情况以及在其它情况下，会给资源数量造成影响。总体功耗和性能也会受到显著影响。在大多数情况下，这会影响性能。它还对器件利用率和功耗有负面影响。
使用复位的时间和位置 赛灵思器件提供专用的全局置位/复位信号 (GSR)。在器件配置结束时，该信号将器件配置中所有顺序单元的初始值。如果未指定初始状态，则为顺序原语分配默认值。在大多数情况下，默认值为零。 FDSE 和 FDPE 原语是例外，默认为逻辑 1。每个寄存器在配置结束时将处于已知状态。因此没有必要单独为初始化加电器件编写全局复位代码。赛灵思强烈建议用户仔细判断设计何时需要复位，何时不需要复位。大多数情况下，在控制路径逻辑上可能需要复位以确保正常运行。然而在数据路径逻辑上通常不需要复位。限制复位使用的方法如下：
限制复位网络的总体扇出。
减少复位路由所需的互联数量。
简化复位路径的时序。
从而在许多情况下能够从整体上提升性能、缩小占位面积和降低功耗。
使用功能仿真应能够轻松地判断是否需要复位。对没有编码复位功能的逻辑，在选择用于映射逻辑的 FPGA 资源方面具有更高的灵活性。综合工具随后能为该代码选择最优资源，为了实现可能的最佳结果，应考虑到以下因素，如：
要求的功能性能要求可用器件资源功耗 同步复位与异步复位 如果需要复位，赛灵思建议代码同步复位。与异步复位相比，同步复位拥有众多优势。
同步复位可以直接映射到 FPGA 器件架构中的更多资源元件。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/387fc5d3c59d75590ae161518265b4ab/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-04-03T23:45:26+08:00" />
<meta property="article:modified_time" content="2021-04-03T23:45:26+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Xilinx RTL编码指南(一)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>Xilinx RTL编码指南一</h4> 
 <ul><li><a href="#_2" rel="nofollow">控制信号与控制集</a></li><li><a href="#Reset_7" rel="nofollow">Reset</a></li><li><ul><li><a href="#_21" rel="nofollow">使用复位的时间和位置</a></li><li><a href="#_38" rel="nofollow">同步复位与异步复位</a></li><li><a href="#_1_51" rel="nofollow">复位编码实例 1：乘法器与异步复位</a></li><li><ul><li><a href="#_53" rel="nofollow">异步复位</a></li><li><ul><li><a href="#RTL_84" rel="nofollow">RTL</a></li><li><a href="#synthesis_89" rel="nofollow">synthesis</a></li></ul> 
    </li><li><a href="#_96" rel="nofollow">同步复位</a></li><li><ul><li><a href="#RTL_127" rel="nofollow">RTL</a></li><li><a href="#synthesis_133" rel="nofollow">synthesis</a></li></ul> 
   </li></ul> 
   </li><li><a href="#HDL_139" rel="nofollow">尝试消除HDL代码复位时出现问题</a></li></ul> 
  </li><li><a href="#_213" rel="nofollow">时钟使能</a></li><li><ul><li><a href="#_228" rel="nofollow">创建时钟使能</a></li><li><a href="#_283" rel="nofollow">复位和时钟使能的先后</a></li><li><a href="#_287" rel="nofollow">使用综合属性控制使能/重置提取</a></li><li><ul><li><a href="#DIRECT_ENABLE_297" rel="nofollow">DIRECT_ENABLE</a></li><li><a href="#DIRECT_RESET_313" rel="nofollow">DIRECT_RESET</a></li></ul> 
   </li><li><a href="#_330" rel="nofollow">将逻辑从控制引脚推到数据引脚</a></li></ul> 
  </li><li><a href="#_393" rel="nofollow">信号控制技巧</a></li></ul> 
</div> 
<br> 该一系列为学习ug949-vivado-design-methodology.pdf的记录，该文档包含了对Xilinx器件最佳实践的方法学。 
<p></p> 
<h2><a id="_2"></a>控制信号与控制集</h2> 
<p>​ 控制集指用于驱动任何给定 SRL、 LUTRAM 或寄存器的控制信号组 （置位/复位、时钟使能和时钟）。对任意控制信号的独特组合，都能构成独立控制集。背后的原因是一个重要的概念，即在 7 系列 slice 中的寄存器都共享相同的控制信号，因此只有使用相同控制集的寄存器才能打包到同一个 slice 中。不同slice可以有不同的控制信号。例如，如果具有给定控制集的寄存器仅具有一个寄存器作为加载，则被占据的片中的其他七个寄存器将不可用。（在wp 405-7 series FPGAS The Logical Advantage里面说明了确实是这样）</p> 
<p>​ 同时拥有多个独立控制集的设计会造成大量资源浪费和布局选项数量减少，导致功耗上升，性能下降。从布局的角度而言，拥有较少数量控制集的设计能提供更多选项和更高灵活性，一般也能产生更加理想的结果。在 UltraScale™ 器件中，在 CLB 内部能灵活地实现控制集的映射。未驱动的复位不形成控制集的一部分，因为是在片内局部生成的。然而，限制独立控制集数目是为一组逻辑布局提供最大灵活性的一个好方法。</p> 
<h2><a id="Reset_7"></a>Reset</h2> 
<p>复位是需要在设计中考虑和设限的更常见也更重要的控制信号之一。复位会给用户设计的性能、占位面积和功耗产生显著影响。</p> 
<p>经引用得到的同步代码会产生下列资源：</p> 
<ul><li>LUT</li><li>寄存器</li><li>移位寄存器 LUT(SRL)</li><li>块存储器或 LUT 存储器</li><li>DSP48 寄存器</li></ul> 
<p>复位的选择和使用会影响上述组件的选择，导致给定设计中资源利用率下降。如果在阵列上误置复位，会产生截然不同的结果，可能是推断出一个块 RAM，也可能是推断出数千个寄存器。在乘法器输入或输出处描述异步复位，可能造成寄存器布置在 slice 上而非 DSP 块上。在此类情况以及在其它情况下，会给资源数量造成影响。总体功耗和性能也会受到显著影响。在大多数情况下，这会影响性能。它还对器件利用率和功耗有负面影响。</p> 
<h3><a id="_21"></a>使用复位的时间和位置</h3> 
<p>赛灵思器件提供专用的全局置位/复位信号 (GSR)。在器件配置结束时，该信号将器件配置中所有顺序单元的初始值。如果未指定初始状态，则为顺序原语分配默认值。在大多数情况下，默认值为零。 FDSE 和 FDPE 原语是例外，默认为逻辑 1。每个寄存器在配置结束时将处于已知状态。因此没有必要单独为初始化加电器件编写全局复位代码。赛灵思强烈建议用户仔细判断设计何时需要复位，何时不需要复位。大多数情况下，在控制路径逻辑上可能需要复位以确保正常运行。然而在数据路径逻辑上通常不需要复位。限制复位使用的方法如下：</p> 
<ul><li> <p>限制复位网络的总体扇出。</p> </li><li> <p>减少复位路由所需的互联数量。</p> </li><li> <p>简化复位路径的时序。</p> </li><li> <p>从而在许多情况下能够从整体上提升性能、缩小占位面积和降低功耗。</p> </li></ul> 
<p>使用功能仿真应能够轻松地判断是否需要复位。对没有编码复位功能的逻辑，在选择用于映射逻辑的 FPGA 资源方面具有更高的灵活性。综合工具随后能为该代码选择最优资源，为了实现可能的最佳结果，应考虑到以下因素，如：</p> 
<ul><li>要求的功能</li><li>性能要求</li><li>可用器件资源</li><li>功耗</li></ul> 
<h3><a id="_38"></a>同步复位与异步复位</h3> 
<p>如果需要复位，赛灵思建议代码同步复位。与异步复位相比，同步复位拥有众多优势。</p> 
<ul><li> <p>同步复位可以直接映射到 FPGA 器件架构中的更多资源元件。</p> </li><li> <p>异步复位还会影响通用逻辑结构的性能。由于所有赛灵思 FPGA 通用寄存器都能置位/复位为异步或同步，通常认为使用异步复位不会造成时间延迟。这种假设往往是不对的。使用全局异步复位时，虽然控制集的数量不会增多，但由于需要把这个复位信号路由到所有的寄存器元件，时序复杂性会增大。</p> </li><li> <p>在使用异步复位时，务必记住同步异步复位的取消断言。</p> </li><li> <p>在需要较大密度或精细化布局的情况下，同步复位能够更加灵活地实现控制集的重新映射。如果在布局更加理想的 slice 中发现有不兼容的复位，可以把同步复位重新映射到该寄存器的数据路径中。这样可以在需要时缩小走线宽度，提升密度，从而实现良好的适配和更加优异的性能。</p> </li><li> <p>异步复位可能需要多周期激活，以确保电路正确复位且稳定。如果正确地被时序约束了，同步复位则不包含此要求。</p> </li><li> <p>在复位激活过程中，若异步复位有更高概率发生块 RAM、 LUTRAM、以及 SRL 存储内容翻转时，可以使用同步复位。</p> </li><li> <p>DSP48 和块 RAM 等部分资源只为块中的寄存器元件提供同步复位。当需要在这些元件相关的寄存器元件上使用异步复位时，不能将这些寄存器直接推断到这些块中，否则会造成功能异常</p> </li></ul> 
<h3><a id="_1_51"></a>复位编码实例 1：乘法器与异步复位</h3> 
<h4><a id="_53"></a>异步复位</h4> 
<pre><code class="prism language-verilog">module test(
input clk,
input rst,
input [15:0] a,
input [15:0] b,
output  [31:0]  dout
    );
    reg [15:0] a1,a2,b1,b2;
    reg [31:0] dout_reg;
    always @(posedge clk,posedge rst) begin
        if(rst)begin
            a1&lt;=0;
            a2&lt;=0;
            b1&lt;=0;
            b2&lt;=0;
            dout_reg &lt;= 0;
        end else begin
            a1&lt;=a;
            a2&lt;=a1;
            b1&lt;=b;
            b2&lt;=b1;
            dout_reg &lt;= a2*b2;
        end
    end
    assign dout = dout_reg;
endmodule
</code></pre> 
<h5><a id="RTL_84"></a>RTL</h5> 
<p><img src="https://images2.imgbox.com/87/da/PNYTKzfq_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="synthesis_89"></a>synthesis</h5> 
<p>只截取了一部分图。乘法部分使用了DSP48的资源</p> 
<p><img src="https://images2.imgbox.com/07/76/F8Nda9a0_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="_96"></a>同步复位</h4> 
<pre><code class="prism language-verilog">module test(
input clk,
input rst,
input [15:0] a,
input [15:0] b,
output  [31:0]  dout
    );
    reg [15:0] a1,a2,b1,b2;
    reg [31:0] dout_reg;
    always @(posedge clk) begin
        if(rst)begin
            a1&lt;=0;
            a2&lt;=0;
            b1&lt;=0;
            b2&lt;=0;
            dout_reg &lt;= 0;
        end else begin
            a1&lt;=a;
            a2&lt;=a1;
            b1&lt;=b;
            b2&lt;=b1;
            dout_reg &lt;= a2*b2;
        end
    end
    assign dout = dout_reg;
endmodule
</code></pre> 
<h5><a id="RTL_127"></a>RTL</h5> 
<p><img src="https://images2.imgbox.com/c2/ab/Ysa3YCqg_o.png" alt="在这里插入图片描述"></p> 
<p>这两份代码的RTL的图似乎没有区别，只是前面一个使用了的异步复位，复位端rst接到了寄存器的CLR端，后一个使用了同步复位，复位端rst接到了寄存器的RST端。这说明RTL中CLR是异步清零端，RST是同步复位端，再来看综合后的图：</p> 
<h5><a id="synthesis_133"></a>synthesis</h5> 
<p><img src="https://images2.imgbox.com/b3/fd/lj8E9ZNQ_o.png" alt="在这里插入图片描述"></p> 
<p>对比异步复位综合后的图，可以发现同步复位少了一个触发器和32个LUT2查找表。由于DSP无异步复位，综合器选择用一个触发器和 32 个 LUT2来模拟 DSP 输出上的异步复位 。</p> 
<h3><a id="HDL_139"></a>尝试消除HDL代码复位时出现问题</h3> 
<pre><code class="prism language-verilog">module test(
input clk,
input rst,
input [15:0] din,
output  [15:0]  dout
    );
    reg [15:0] d1,d2;
    reg [15:0] dout_reg;
    always @(posedge clk,posedge rst) begin
        if(rst)begin
            d1&lt;=0;
            d2&lt;=0;
            dout_reg &lt;= 0;
        end else begin
            d1&lt;=din;
            d2&lt;=d1;
            dout_reg &lt;= d2;
        end
    end
    assign dout = dout_reg;
endmodule
</code></pre> 
<p>上面一段代码将生成下图的RTL：<br> <img src="https://images2.imgbox.com/ab/e2/VchadZI3_o.png" alt="在这里插入图片描述"></p> 
<p>若用户想取消d1,d2的异步复位，选择如下修改：</p> 
<pre><code class="prism language-verilog">  			//d1&lt;=0;
           // d2&lt;=0;
</code></pre> 
<p>仅仅在复位条件内注释掉d1,d2,则会产生下面的RTL：<br> <img src="https://images2.imgbox.com/4c/b9/4dd9ubtT_o.png" alt="在这里插入图片描述"></p> 
<p>综合器会推断出d1和d2隐含保持的含义，因此增加了2个2选择器，并将选择器输出直连到d1,d2的使能端。</p> 
<p>去除复位的最佳方法是创建单独的顺序逻辑过程，一个用于复位条件，另一个用于非复位条件。</p> 
<pre><code class="prism language-verilog">module test(
input clk,
input rst,
input [15:0] din,
output  [15:0]  dout
    );
    reg [15:0] d1,d2;
    reg [15:0] dout_reg;
    always @(posedge clk) begin
            d1&lt;=din;
            d2&lt;=d1;
    end   
    always @(posedge clk) begin
        if(rst)begin
            dout_reg &lt;= 0;
        end else begin
            dout_reg &lt;= d2;
        end
    end
    assign dout = dout_reg;
endmodule

</code></pre> 
<p>这样生成的RTL才符合用户的原始想法。</p> 
<p><img src="https://images2.imgbox.com/e0/1e/g07FHSZU_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="_213"></a>时钟使能</h2> 
<p>​ 如果正确使用，时钟使能能够显著地降低系统功耗，同时对面积或性能的影响极小。但是如果不正确地使用时钟使能，</p> 
<p>可能会造成下列后果：</p> 
<ul><li> <p>面积增大</p> </li><li> <p>密度减小</p> </li><li> <p>功耗上升</p> </li><li> <p>性能下降</p> </li></ul> 
<p>​ 在许多使用大量控制集的设计中，低扇出时钟使能可能是导致控制集数量众多的主要原因。</p> 
<h3><a id="_228"></a>创建时钟使能</h3> 
<p>​ 如果在同步块中编写不完整条件语句，就能创建时钟使能。推断时钟使能的目的是当前提条件无法满足时，保留最后一个值。如果这是需要的功能，用这种方式编码就是有效的。</p> 
<pre><code class="prism language-verilog">module test(
input clk,
input en,
input din,
output dout
    );
    reg dout_reg;
    always @(posedge clk) begin
        if(en)begin
            dout_reg &lt;= din;
        end 
    end
    assign dout = dout_reg;
endmodule


</code></pre> 
<p><img src="https://images2.imgbox.com/e3/ca/03FUk2P8_o.png" alt="在这里插入图片描述"></p> 
<p>​ 但是在有些情况下，虽然前提条件值未得到满足，但输出无所谓。此时赛灵思建议用设定的常数 （即为信号赋值 1 或 0）关闭该条件 （即使用 else 子句）。</p> 
<pre><code class="prism language-verilog">module test(
input clk,
input en,
input din,
output dout
    );
    reg dout_reg;
    always @(posedge clk) begin
        if(en)begin
            dout_reg &lt;= din;
        end 
        else begin
            dout_reg &lt;= 16'b0;
        end

    end
    assign dout = dout_reg;
endmodule


</code></pre> 
<p><img src="https://images2.imgbox.com/e5/a4/vvxmoK4v_o.png" alt="在这里插入图片描述"></p> 
<p>此时的en信号并未直接连接到寄存器的使能端了。</p> 
<p>​ 在大多数实现方案中，这不会造成额外的逻辑，同时可避免使用时钟使能。不过有个情况例外，即对大型总线而言，如果推断时钟使能信号，保持上述的最后一个值，有助于降低功耗。基本前提是如果推断的寄存器数量较少，时钟使能会存在较大弊端，因为它会增加控制集的数量。但是对较大型的群组而言，其利大于弊，所以建议使用。</p> 
<h3><a id="_283"></a>复位和时钟使能的先后</h3> 
<p>​ 在赛灵思 FPGA 器件中，所有寄存器的置位/复位功能的优先级均高于时钟使能，不论是异步置位/复位还是同步置位/复位都是如此。为取得最佳结果，赛灵思建议在同步块中的 if/else 结构中，应一直在时钟使能 （如有必要使用）之前对置位/复位进行编码。优先对时钟使能进行编码会强制复位进入数据路径，并导致产生更多逻辑。</p> 
<h3><a id="_287"></a>使用综合属性控制使能/重置提取</h3> 
<p>您可以通过DIRECT_RESET，DIRECT_ENABLE ，EXTRACT_RESET</p> 
<p>EXTRACT_ENABLE 属性来强制控制器集映射，以处理给定结构的控制器集的映射。当设计包括同步复位/使能时，当负载等于或高于由 “-control_set_opt_threshold” 综合开关设置的阈值时，通过CE/R/S 引脚映射的综合创建逻辑椎，或如果低于阈值，通过 D 引脚映射创建逻辑椎。默认阈值为：</p> 
<ul><li> <p>7 系列器件：4</p> </li><li> <p>UltraScale 器件：2</p> </li></ul> 
<h4><a id="DIRECT_ENABLE_297"></a>DIRECT_ENABLE</h4> 
<p>要使用控制器集映射，你可以将属性应用于连接启用/复位信号的网络，但这将强制综合使用 CE/R 引脚。在下图中，使能信号 (en) 只连接到一个触发器上。因此，综合引擎将 en 信号连接到逻辑的 FDRE/D 引脚椎。注意，CE 引脚连接到逻辑 1。<br> <img src="https://images2.imgbox.com/be/66/3XxMF3uO_o.png" alt="在这里插入图片描述"></p> 
<p>要覆盖此默认行为，可以使用 DIRECT_ENABLE 属性。例如，下图显示了如何通过将 DIRECT_ENABLE 属性添加到端口/信号来将使能信号 (en) 连接到寄存器的 CE 引脚。</p> 
<p><img src="https://images2.imgbox.com/4b/22/FB64qgc9_o.png" alt="在这里插入图片描述"></p> 
<p>但在vivado2019中，未加“direct_enable = true”就已经是综合成下面的情况了，直接使用了en使能端。</p> 
<p><img src="https://images2.imgbox.com/83/d1/mpVvggcB_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="DIRECT_RESET_313"></a>DIRECT_RESET</h4> 
<p>下图显示了RTL 代码，其中 global_rst 或 int_rst 可以复位寄存器。默认情况下。</p> 
<p><img src="https://images2.imgbox.com/6b/80/KVvoNgbz_o.png" alt="在这里插入图片描述"></p> 
<p>仔细看,可以发现dout_reg的R复位端没有接，而是将global_rst和int_rst融入了数据路径中。</p> 
<p>您可以使用 DIRECT_RESET 属性来指定连接到寄存器复位引脚的复位信号。例如，下图显示了如何使用 DIRECT_RESET 属性仅将 global_rst 信号连接到寄存器 FDRE/R 引脚，并将 int_rst 信号连接到逻辑的 FDRE/D 椎形。</p> 
<p><img src="https://images2.imgbox.com/9a/38/CnUrQJMv_o.png" alt="在这里插入图片描述"></p> 
<p>但同样在vivado2019中，未加“direct_reset = true”就已经是综合成下面的情况了，直接使用RST端。</p> 
<p><img src="https://images2.imgbox.com/bf/80/ybl1TiKQ_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_330"></a>将逻辑从控制引脚推到数据引脚</h3> 
<p>​ 在分析关键路径时，您可能会发现以控制引脚结束的多个路径。您必须分析这些路径，以确定是否有一种方法将逻辑推入数据路径，而不会产生损失，例如额外的逻辑层。由于存在最后一个 LUT 的输出到 FF 的 D 输入的直接连接，在给定相同逻辑层的情况下，到 D 引脚路径的延迟比到 CE/R/S 引脚少。以下编码示例说明如何将逻辑从控制引脚推送到寄存器的数据引脚。</p> 
<p>在以下示例中，dout_reg_reg 的CE使能引脚具有 2 个逻辑层，数据引脚D具有1个逻辑层。</p> 
<pre><code class="prism language-verilog">module test(
input clk,
input [1:0] en,
input din,
output dout
    );
    reg [1:0] en_reg;
    reg dout_reg,din_reg;
    wire en_temp = &amp;en_reg;
    always @(posedge clk) begin
        en_reg &lt;= en;
        din_reg &lt;= din;     
        if(en_temp)
        begin
            dout_reg &lt;= din_reg;
        end
    end
    assign dout = dout_reg;
endmodule

</code></pre> 
<p><img src="https://images2.imgbox.com/fa/f3/gQjny6Xb_o.png" alt="在这里插入图片描述"></p> 
<p>​ 在这种情况下，通过将 RTL 文件中 dout_reg 寄存器定义中的 EXTRACT_ENABLE 属性设置为“no”，可以将使能逻辑移至 D 引脚，从而提高时序。</p> 
<pre><code class="prism language-verilog">module test(
input clk,
input [1:0] en,
input din,
output dout
    );
    reg [1:0] en_reg;
    reg dout_reg,din_reg;
    (*KEEP  = "true" *) reg dout_next;
    wire en_temp = &amp;en_reg;

    always @(*) begin
        dout_next = dout_reg;
        if(en_temp)
        dout_next = din_reg;
    end
    always @(posedge clk) begin
        en_reg &lt;= en;
        din_reg &lt;= din;     
        dout_reg &lt;= dout_next;
    end
    assign dout = dout_reg;
endmodule
</code></pre> 
<p><img src="https://images2.imgbox.com/43/e8/magAspkd_o.png" alt="在这里插入图片描述"></p> 
<p>此时dout_reg_reg的CE使能端直接接高电平。保持的实现通过dout_reg_reg的Q输出端-&gt;LUT4 I1-&gt;dout_reg_reg的D输入端实现。</p> 
<h2><a id="_393"></a>信号控制技巧</h2> 
<ul><li>检查是否真正需要全局复位。</li><li>避免异步控制信号。</li><li>保持时钟、使能和复位信号极性一致。</li><li>勿将置位和复位编码到同一寄存器元件中。</li><li>如果确实需要异步复位，应务必与异步复位的解除保持同步。</li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a4111c33b81633b125336db2967c1124/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">GitBash中文乱码解决</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c204ecd0c04173113670132aaf175836/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">利用七牛云SDK实现文件的简单上传和下载</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>