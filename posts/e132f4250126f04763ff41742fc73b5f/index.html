<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43; ——一文读懂：关键字override - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C&#43;&#43; ——一文读懂：关键字override" />
<meta property="og:description" content="override在C&#43;&#43;中它是覆盖了一个方法并且对其重写，从而达到不同的作用。在我们C&#43;&#43;编程过程中，最熟悉的就是对接口方法的实现，在接口中一般只是对方法进行了声明，而我们在实现时，就需要实现接口声明的所有方法。还有一个典型应用就是在继承中也可能会在子类覆盖父类的方法。
1.公有继承 包含两部分：一是“接口”(interface)，二是 “实现” (implementation)。
class Shape { public: virtual void Draw() const = 0; // 1) 纯虚函数 virtual void Error(const string&amp; msg); // 2) 普通虚函数 int ObjectID() const; // 3) 非虚函数 }; class Rectangle: public Shape { ... }; class Ellipse: public Shape { ... }; 1. 1 纯虚函数 纯虚函数，继承的是基类成员函数的接口，必须在派生类中重写该函数的实现：
Shape *ps1 = new Rectangle; ps1-&gt;Draw(); // calls Rectangle::Draw Shape *ps2 = new Ellipse; ps2-&gt;Draw(); // calls Ellipse::Draw 调用基类的 Draw()，须加 类作用域操作符 ::" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/e132f4250126f04763ff41742fc73b5f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-04-05T16:42:45+08:00" />
<meta property="article:modified_time" content="2022-04-05T16:42:45+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43; ——一文读懂：关键字override</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-dracula">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>override在C++中它是覆盖了一个方法并且对其重写，从而达到不同的作用。在我们C++编程过程中，最熟悉的就是对接口方法的实现，在接口中一般只是对方法进行了声明，而我们在实现时，就需要实现接口声明的所有方法。还有一个典型应用就是在继承中也可能会在子类覆盖父类的方法。</p> 
<h2><a id="1_1"></a>1.公有继承</h2> 
<p>包含两部分：一是“接口”(interface)，二是 “实现” (implementation)。</p> 
<pre><code class="prism language-c">class Shape <span class="token punctuation">{<!-- --></span>
public<span class="token operator">:</span>
    virtual <span class="token keyword">void</span> <span class="token function">Draw</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">// 1) 纯虚函数</span>
    virtual <span class="token keyword">void</span> <span class="token function">Error</span><span class="token punctuation">(</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span> msg<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 2) 普通虚函数</span>
    <span class="token keyword">int</span> <span class="token function">ObjectID</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>  <span class="token comment">// 3) 非虚函数</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

class Rectangle<span class="token operator">:</span> public Shape <span class="token punctuation">{<!-- --></span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
class Ellipse<span class="token operator">:</span> public Shape <span class="token punctuation">{<!-- --></span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<h3><a id="1_1__16"></a>1. 1 纯虚函数</h3> 
<p>纯虚函数，继承的是基类成员函数的接口，必须在派生类中重写该函数的实现：</p> 
<pre><code class="prism language-c">Shape <span class="token operator">*</span>ps1 <span class="token operator">=</span> new Rectangle<span class="token punctuation">;</span>
ps1<span class="token operator">-&gt;</span><span class="token function">Draw</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// calls Rectangle::Draw</span>

Shape <span class="token operator">*</span>ps2 <span class="token operator">=</span> new Ellipse<span class="token punctuation">;</span>
ps2<span class="token operator">-&gt;</span><span class="token function">Draw</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// calls Ellipse::Draw</span>
</code></pre> 
<p>调用基类的 Draw()，须加 类作用域操作符 ::</p> 
<pre><code class="prism language-c">ps1<span class="token operator">-&gt;</span>Shape<span class="token operator">::</span><span class="token function">Draw</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// calls Shape::draw</span>
</code></pre> 
<h3><a id="12__29"></a>1.2 普通虚函数</h3> 
<p>普通虚函数，对应在基类中定义一个缺省的实现 (default implementation)，表示继承的是基类成员函数的接口和缺省的实现，由派生类自行选择是否重写该函数。</p> 
<pre><code>实际上，允许普通虚函数同时继承接口和缺省实现是危险的。 如下, CarA 和 CarB 是 Car的两种类型，且二者的运行方式完全相同
</code></pre> 
<pre><code class="prism language-c">class Car<span class="token punctuation">{<!-- --></span> 
public<span class="token operator">:</span> 
 virtual <span class="token keyword">void</span> <span class="token function">Run</span><span class="token punctuation">(</span><span class="token keyword">const</span> Car<span class="token operator">&amp;</span> destination<span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span><span class="token punctuation">;</span> 
class CarA<span class="token operator">:</span> public Car<span class="token punctuation">{<!-- --></span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> 
class CarB<span class="token operator">:</span> public Car<span class="token punctuation">{<!-- --></span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>这是典型的面向对象设计，两个类共享一个特性 – Run，则 Run可在基类中实现，并由两个派生类继承。</p> 
<p>现增加一个新的飞机型号 CarC，其飞行方式与 CarA，CarB 并不相同，假如不小心忘了在 CarC 中重写新的 Fly 函数</p> 
<pre><code class="prism language-c">class CarC<span class="token operator">:</span> public Car<span class="token punctuation">{<!-- --></span> 
 <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token comment">// no fly function is declared </span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>则调用 CarC 中的 Run 函数，就是调用 Car::Run，但是 CarC的运行方式和缺省的并不相同</p> 
<pre><code class="prism language-c">Car <span class="token operator">*</span>pa <span class="token operator">=</span> new CarC<span class="token punctuation">;</span> 
pa<span class="token operator">-&gt;</span><span class="token function">Run</span><span class="token punctuation">(</span>Beijing<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// calls Car::Run!</span>
</code></pre> 
<p>这就是前面所说的，普通虚函数同时继承接口和缺省实现是危险的，最好是基类中实现缺省行为 (behavior)，但只有在派生类要求时才提供该缺省行为.</p> 
<p><strong>1. 方法一：</strong></p> 
<p>一种方法是<strong>纯虚函数 + 缺省实现</strong>，因为是纯虚函数，所以只有接口被继承，其缺省的实现不会被继承。派生类要想使用该缺省的实现，必须显式的调用:</p> 
<pre><code class="prism language-c">class Car<span class="token punctuation">{<!-- --></span> 
public<span class="token operator">:</span> 
 virtual <span class="token keyword">void</span> <span class="token function">Run</span><span class="token punctuation">(</span><span class="token keyword">const</span> Run<span class="token operator">&amp;</span> destination<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span><span class="token punctuation">;</span> 
  
<span class="token keyword">void</span> Car<span class="token operator">::</span><span class="token function">Run</span><span class="token punctuation">(</span><span class="token keyword">const</span> Airport<span class="token operator">&amp;</span> destination<span class="token punctuation">)</span> 
<span class="token punctuation">{<!-- --></span> 
 <span class="token comment">// a pure virtual function default code for Run an Car to the given destination </span>
<span class="token punctuation">}</span> 
  
class CarA<span class="token operator">:</span> public Car<span class="token punctuation">{<!-- --></span> 
public<span class="token operator">:</span> 
 virtual <span class="token keyword">void</span> <span class="token function">Run</span><span class="token punctuation">(</span><span class="token keyword">const</span> Car<span class="token operator">&amp;</span> destination<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> Car<span class="token operator">::</span><span class="token function">Run</span><span class="token punctuation">(</span>destination<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> 
</code></pre> 
<p>这样在派生类 CarC 中，即使一不小心忘记重写 Run函数，也不会调用 Car的缺省实现</p> 
<pre><code class="prism language-c">class CarC<span class="token operator">:</span> public CAr<span class="token punctuation">{<!-- --></span> 
public<span class="token operator">:</span> 
 virtual <span class="token keyword">void</span> <span class="token function">Run</span><span class="token punctuation">(</span><span class="token keyword">const</span> Car<span class="token operator">&amp;</span> destination<span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span><span class="token punctuation">;</span> 
  
<span class="token keyword">void</span> CarC<span class="token operator">::</span><span class="token function">Run</span><span class="token punctuation">(</span><span class="token keyword">const</span> Car<span class="token operator">&amp;</span> destination<span class="token punctuation">)</span> 
<span class="token punctuation">{<!-- --></span> 
 <span class="token comment">// code for Run a CarC Car to the given destination </span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>2. 方法二：</strong></p> 
<p>可以看到，上面问题的关键就在于，一不小心在派生类 CarC中忘记重写 Run函数，C++11 中使用关键字 override，可以避免这样的“一不小心”。<br> 非虚函数：</p> 
<p>非虚成员函数没有virtual关键字，表示派生类不但继承了接口，而且继承了一个强制实现（mandatory implementation），既然继承了一个强制的实现，则在派生类中，无须重新定义继承自基类的成员函数，如下：</p> 
<p>使用指针调用 Name 函数，则都是调用的 Person::Name()</p> 
<pre><code class="prism language-c">Student s1<span class="token punctuation">;</span> <span class="token comment">// s1 is an object of type Student </span>
  
Person <span class="token operator">*</span>p<span class="token operator">=</span> <span class="token operator">&amp;</span>s1<span class="token punctuation">;</span> <span class="token comment">// get pointer to s1 </span>
p<span class="token operator">-&gt;</span><span class="token function">Name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// call Name() through pointer </span>
  
Student <span class="token operator">*</span>s<span class="token operator">=</span> <span class="token operator">&amp;</span>s1<span class="token punctuation">;</span> <span class="token comment">// get pointer to s1 </span>
s<span class="token operator">-&gt;</span><span class="token function">Name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// call Name() through pointer</span>
</code></pre> 
<p>如果在派生类中重新定义了继承自基类的成员函数 Name</p> 
<pre><code class="prism language-c">class Student <span class="token operator">:</span> public Person<span class="token punctuation">{<!-- --></span> 
public<span class="token operator">:</span> 
 <span class="token keyword">int</span> <span class="token function">Name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span> <span class="token comment">// hides Person::Name </span>
<span class="token punctuation">}</span><span class="token punctuation">;</span> 
  
p<span class="token operator">-&gt;</span><span class="token function">Name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// calls Person::Name() </span>
s<span class="token operator">-&gt;</span><span class="token function">Name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// calls Student::Name() </span>
</code></pre> 
<p>此时，派生类中重新定义的成员函数会 “隐藏” (hide) 继承自基类的成员函数</p> 
<p>这是因为非虚函数是 “静态绑定” 的，p被声明的是 Person* 类型的指针，则通过 p调用的非虚函数都是基类中的，既使 p指向的是派生类。</p> 
<p>与“静态绑定”相对的是虚函数的“动态绑定”，即无论 p被声明为 Person* 还是 Student* 类型，其调用的虚函数取决于 p实际指向的对象类型</p> 
<h2><a id="2__override_125"></a>2 重写 (override)</h2> 
<p>在程序中加override 关键字，可以避免派生类中忘记重写虚函数的错误</p> 
<p>下面以 Base 基类和 Derived 派生类为例，详细阐述之</p> 
<pre><code class="prism language-c">class Base <span class="token punctuation">{<!-- --></span> 
public<span class="token operator">:</span> 
 virtual <span class="token keyword">void</span> <span class="token function">fun1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span> 
 virtual <span class="token keyword">void</span> <span class="token function">fun2</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span> 
 virtual <span class="token keyword">void</span> <span class="token function">fun3</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token punctuation">;</span> 
 <span class="token keyword">void</span> <span class="token function">fun4</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span> <span class="token comment">// is not declared virtual in Base </span>
<span class="token punctuation">}</span><span class="token punctuation">;</span> 
  
class Derived<span class="token operator">:</span> public Base <span class="token punctuation">{<!-- --></span> 
public<span class="token operator">:</span> 
 virtual <span class="token keyword">void</span> <span class="token function">fun1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// declared const in Base, but not in Derived. </span>
 virtual <span class="token keyword">void</span> <span class="token function">fun2</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// takes an int in Base, but an unsigned int in Derived </span>
 virtual <span class="token keyword">void</span> <span class="token function">fun3</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span><span class="token punctuation">;</span> <span class="token comment">// is lvalue-qualified in Base, but rvalue-qualified in Derived. </span>
 <span class="token keyword">void</span> <span class="token function">fun4</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>   
<span class="token punctuation">}</span><span class="token punctuation">;</span> 
</code></pre> 
<p>在派生类中，重写 (override) 继承自基类成员函数的实现 (implementation) 时，要满足如下条件：</p> 
<ul><li> <p>一虚：基类中，成员函数声明为虚拟的 (virtual)</p> </li><li> <p>二容：基类和派生类中，成员函数的返回类型和异常规格 (exception specification) 必须兼容</p> </li><li> <p>四同：基类和派生类中，成员函数名、形参类型、常量属性 (constness) 和 引用限定符 (reference qualifier) 必须完全相同</p> </li></ul> 
<p>如此多的限制条件，导致了虚函数重写如上述代码，极容易因为一个不小心而出错</p> 
<p>C++11 中的 override 关键字，可以显式的在派生类中声明，哪些成员函数需要被重写，如果没被重写，则编译器会报错。</p> 
<pre><code class="prism language-c">class Derived<span class="token operator">:</span> public Base <span class="token punctuation">{<!-- --></span> 
public<span class="token operator">:</span> 
 virtual <span class="token keyword">void</span> <span class="token function">fun1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> override<span class="token punctuation">;</span> 
 virtual <span class="token keyword">void</span> <span class="token function">fun2</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> x<span class="token punctuation">)</span> override<span class="token punctuation">;</span> 
 virtual <span class="token keyword">void</span> <span class="token function">fun3</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> override<span class="token punctuation">;</span> 
 virtual <span class="token keyword">void</span> <span class="token function">fun4</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> override<span class="token punctuation">;</span> 
<span class="token punctuation">}</span><span class="token punctuation">;</span>
class Derived<span class="token operator">:</span> public Base <span class="token punctuation">{<!-- --></span> 
public<span class="token operator">:</span> 
 virtual <span class="token keyword">void</span> <span class="token function">fun1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> override<span class="token punctuation">;</span> <span class="token comment">// adding "virtual" is OK, but not necessary </span>
 virtual <span class="token keyword">void</span> <span class="token function">fun2</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> override<span class="token punctuation">;</span> 
 <span class="token keyword">void</span> <span class="token function">fun3</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> override<span class="token punctuation">;</span> 
 <span class="token keyword">void</span> <span class="token function">fun4</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> override<span class="token punctuation">;</span> 
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>1） 公有继承</p> 
<ul><li>纯虚函数 =&gt; 继承的是：接口 (interface)</li><li>普通虚函数 =&gt; 继承的是：接口 + 缺省实现 (default implementation)<br> - 非虚成员函数 =&gt;继承的是：接口 + 强制实现 (mandatory implementation)</li></ul> 
<p>2） 不要重新定义一个继承自基类的非虚函数 (never redefine an inherited non-virtual function<br> 3）在声明需要重写的函数后，加关键字 override<br> 这样，即使不小心漏写了虚函数重写的某个苛刻条件，也可以通过编译器的报错，快速改正错误。</p> 
<p>在使用中需要注意以下几点：</p> 
<ul><li>覆盖的方法的标志必须要和被覆盖的方法的标志完全匹配，才能达到覆盖的效果；</li><li>覆盖的方法的返回值必须和被覆盖的方法的返回一致；</li><li>覆盖的方法所抛出的异常必须和被覆盖方法的所抛出的异常一致，或者是其子类；</li><li>被覆盖的方法不能为private，否则在其子类中只是新定义了一个方法，并没有对其进行覆盖。</li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/60a7fb205fc28c6f603b4cc260ae0a12/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【PHP基础-7】HTML&#43;PHP简单综合应用—对用户登录进行验证</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1c83cda5273f8716ff1d7c3d5905193d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">记录:OpenJDK 64-Bit Server VM warning: Sharing is only supported for boot loade...idea debug启动报错【解决方案】</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>