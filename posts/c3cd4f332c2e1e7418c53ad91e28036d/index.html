<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【框架】Mybatis - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【框架】Mybatis" />
<meta property="og:description" content="1. Mybatis简介 1.1 Mybatis特性 是一个基于Java的持久层框架MyBatis是支持定制化SQL、存储过程以及高级映射的优秀的持久层框架MyBatis避免了几乎所有的JDBC代码和手动设置参数以及获取结果集MyBatis可以使用简单的XML或注解用于配置和原始映射，将接口和Java的POJO（Plain Old Java Objects，普通的Java对象）映射成数据库中的记录MyBatis 是一个半自动的ORM（Object Relation Mapping）框架 1.2 和其它持久化层技术对比 JDBC SQL夹杂在Java代码中耦合度高，导致硬编码内伤维护不易且实际开发需求中SQL有变化，频繁修改的情况多见代码冗长，开发效率低Hibernate和JPA 操作简便，开发效率高程序中的长难复杂SQL需要绕过框架内部自动生产的SQL，不容易做特殊优化基于全映射的全自动框架，大量字段的POJO进行部分映射时比较困难。反射操作太多，导致数据库性能下降MyBatis 轻量级，性能出色SQL和Java编码分开，功能边界清晰。Java代码专注业务、SQL语句专注数据开发效率稍逊于HIbernate，但是完全能够接受 2. 搭建Mybatis 2.1 开发环境 IDE：idea2021.3构建工具：maven3.8.4MySQL版本：MySQL8.0.28MyBatis版本：MyBatis3.5.9 2.2 创建maven工程 打包方式：jar包引入依赖 &lt;dependencies&gt; &lt;!-- Mybatis核心 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.9&lt;/version&gt; &lt;/dependency&gt; &lt;!-- junit测试 --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.13.2&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- MySQL驱动 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.28&lt;/version&gt; &lt;/dependency&gt; &lt;!-- log4j日志 --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 2.3 创建Mybatis的核心配置文件 习惯上命名为mybatis-config.xml，这个文件名仅仅只是建议，并非强制要求。存放的位置是src/main/resources目录下。将来整合Spring之后，这个配置文件可以省略，所以大家操作时可以直接复制、粘贴。核心配置文件主要用于配置连接数据库的环境以及MyBatis的全局配置信息 &lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34; ?&gt; &lt;!DOCTYPE configuration PUBLIC &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/c3cd4f332c2e1e7418c53ad91e28036d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-02-22T14:44:31+08:00" />
<meta property="article:modified_time" content="2023-02-22T14:44:31+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【框架】Mybatis</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>1. Mybatis简介</h3> 
<h4>1.1 Mybatis特性</h4> 
<ul><li>是一个基于Java的持久层框架</li><li>MyBatis是支持定制化SQL、存储过程以及高级映射的优秀的持久层框架</li><li>MyBatis避免了几乎所有的JDBC代码和手动设置参数以及获取结果集</li><li>MyBatis可以使用简单的XML或注解用于配置和原始映射，将接口和Java的POJO（Plain Old Java Objects，普通的Java对象）映射成数据库中的记录</li><li>MyBatis 是一个半自动的ORM（Object Relation Mapping）框架</li></ul> 
<h4>1.2 和其它持久化层技术对比</h4> 
<ul><li>JDBC 
  <ul><li>SQL夹杂在Java代码中耦合度高，导致硬编码内伤</li><li>维护不易且实际开发需求中SQL有变化，频繁修改的情况多见</li><li>代码冗长，开发效率低</li></ul></li><li>Hibernate和JPA 
  <ul><li>操作简便，开发效率高</li><li>程序中的长难复杂SQL需要绕过框架</li><li>内部自动生产的SQL，不容易做特殊优化</li><li>基于全映射的全自动框架，大量字段的POJO进行部分映射时比较困难。</li><li>反射操作太多，导致数据库性能下降</li></ul></li><li>MyBatis 
  <ul><li>轻量级，性能出色</li><li>SQL和Java编码分开，功能边界清晰。Java代码专注业务、SQL语句专注数据</li><li>开发效率稍逊于HIbernate，但是完全能够接受</li></ul></li></ul> 
<h3>2. 搭建Mybatis</h3> 
<h4>2.1 开发环境</h4> 
<ul><li>IDE：idea2021.3</li><li>构建工具：maven3.8.4</li><li>MySQL版本：MySQL8.0.28</li><li>MyBatis版本：MyBatis3.5.9</li></ul> 
<h4>2.2 创建maven工程</h4> 
<ul><li>打包方式：jar包</li><li>引入依赖</li></ul> 
<pre><code>&lt;dependencies&gt;
    &lt;!-- Mybatis核心 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
        &lt;artifactId&gt;mybatis&lt;/artifactId&gt;
        &lt;version&gt;3.5.9&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;!-- junit测试 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;junit&lt;/groupId&gt;
        &lt;artifactId&gt;junit&lt;/artifactId&gt;
        &lt;version&gt;4.13.2&lt;/version&gt;
        &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
    &lt;!-- MySQL驱动 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;mysql&lt;/groupId&gt;
        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
        &lt;version&gt;8.0.28&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;!-- log4j日志 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;log4j&lt;/groupId&gt;
        &lt;artifactId&gt;log4j&lt;/artifactId&gt;
        &lt;version&gt;1.2.17&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;</code></pre> 
<h4>2.3 创建Mybatis的核心配置文件</h4> 
<ul><li>习惯上命名为mybatis-config.xml，这个文件名仅仅只是建议，并非强制要求。存放的位置是src/main/resources目录下。将来整合Spring之后，这个配置文件可以省略，所以大家操作时可以直接复制、粘贴。<span style="color:#fe2c24;"><strong>核心配置文件主要用于配置连接数据库的环境以及MyBatis的全局配置信息</strong></span></li></ul> 
<pre><code>&lt;?xml version="1.0" encoding="UTF-8" ?&gt;
&lt;!DOCTYPE configuration
        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;
&lt;configuration&gt;
    &lt;!--
        Mybatis核心配置文件中，标签的顺序有要求，不遵循会报错：
        properties?,settings?,typeAliases?,typeHandlers?,objectFactory?,objectWrapperFactory?,
        reflectorFactory?,plugins?,environments?,databaseIdProvider?,mappers?
    --&gt;
    &lt;!--引入properties文件，此时就可以${属性名}的方式访问属性值--&gt;
    &lt;properties resource="jdbc.properties"/&gt;
    &lt;!--设置类型别名(alias)--&gt;
    &lt;typeAliases&gt;
        &lt;!--
            typeAlias：设置某个具体的类型的别名
            属性：
                type：需要设置别名的类型的全类名
                alias：设置此类型的别名，若不设置此属性，该类型拥有默认的别名，即类名且不区分大小写
        --&gt;
        &lt;typeAlias type="com.atguigu.mybatis.pojo.User" alias="User"/&gt;
        &lt;!--
            以包为单位，设置该包下所有的类型都拥有默认的别名，即类名且不区分大小写
        --&gt;
        &lt;package name="com.atguigu.mybatis.pojo"/&gt;
    &lt;/typeAliases&gt;
    &lt;!--
        environments:配置多个连接数据库的环境
        属性default：来设置默认使用的环境的id，可以通过设置default的值来决定使用哪个环境
    --&gt;
    &lt;environments default="development"&gt;
        &lt;!--
            environment:配置某个具体的连接数据库的环境
            属性id：表示连接数据库的环境的唯一标识，不能重复
        --&gt;
        &lt;environment id="development"&gt;
            &lt;!--
                transactionManager:事务管理器
                属性type：设置事务的管理方式，其值有两种：JDBC/MANAGED
                    JDBC:表示当前环境中，执行SQL时，使用的是JDBC中原生的事务管理方式，事务的提交或回滚需要手动处理
                    MANAGED:设置事务被管理，例如spring
                dataSource:配置数据源
                属性type：设置数据源的类型，其值有三种：POOLED/UNPOOLED/JNDI
                    POOLED:表示使用数据库连接池缓存数据库连接，下次使用可以从缓存中直接获取，不需要重新创建
                    UNPOOLED:表示不使用数据库连接池
                    JNDI:表示使用上下文中的数据源
            --&gt;
            &lt;transactionManager type="JDBC"/&gt;
            &lt;dataSource type="POOLED"&gt;
                &lt;!--设置连接数据库的驱动、连接地址、用户名、密码--&gt;
                &lt;property name="driver" value="com.mysql.cj.jdbc.Driver"/&gt;
                &lt;property name="url" value="jdbc:mysql://localhost:3306/mybatis?serverTimezone=UTC"/&gt;
                &lt;property name="username" value="root"/&gt;
                &lt;property name="password" value="abc123"/&gt;
            &lt;/dataSource&gt;
        &lt;/environment&gt;
        &lt;environment id="test"&gt;
            &lt;transactionManager type="JDBC"/&gt;
            &lt;dataSource type="POOLED"&gt;
                &lt;property name="driver" value="${jdbc.driver}"/&gt;
                &lt;property name="url" value="${jdbc.url}"/&gt;
                &lt;property name="username" value="${jdbc.username}"/&gt;
                &lt;property name="password" value="${jdbc.password}"/&gt;
            &lt;/dataSource&gt;
        &lt;/environment&gt;
    &lt;/environments&gt;
    &lt;!--引入映射文件--&gt;
    &lt;mappers&gt;
        &lt;!--引入单个--&gt;
        &lt;!--&lt;mapper resource="mappers/UserMapper.xml"/&gt;--&gt;
        &lt;!--
            以包为单位引入映射文件
            要求：
            1.mapper接口所在的包要和映射文件所在的包一致
            2.mapper接口要和映射文件的名字一致
            3.resource中创建包的方式：创建directory，命名方式用 "/" 隔开
        --&gt;
        &lt;package name="com.atguigu.mybatis.mapper"/&gt;
    &lt;/mappers&gt;
&lt;/configuration&gt;</code></pre> 
<h4>2.4 创建Mapper接口</h4> 
<ul><li>MyBatis中的mapper接口相当于以前的dao。但是区别在于，mapper仅仅是接口，我们不需要提供实现类。</li></ul> 
<pre><code>public interface UserMapper {
    /**
     * Mybatis面向接口编程的两个一致：
     * 1.映射文件的namespace要和mapper接口的全类名保持一致
     * 2.映射文件中sql语句的id要和Mapper接口中的方法名一致
     * 对应关系：
     * 表 - 实体类 - mapper接口 - 映射文件
     */
    /**
     * 添加用户信息
     */
    int insertUser();
    /**
     * 修改用户信息
     */
    void updateUser();
    /**
     * 查询单个用户信息
     */
    User selectUser();
    /**
     * 查询多个用户信息
     */
    List&lt;User&gt; selectUsers();
    /**
     * 删除用户信息
     */
    void deleteUser();
}</code></pre> 
<h4>2.5 创建Mybatis的映射文件</h4> 
<ul><li>ORM：对象关系映射</li><li>对象：java的实体类对象</li><li>关系：关系型数据库</li><li>映射：二者之间的对应关系</li></ul> 
<pre><code>&lt;?xml version="1.0" encoding="UTF-8" ?&gt;
&lt;!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;
&lt;mapper namespace="com.atguigu.mybatis.mapper.UserMapper"&gt;
    &lt;!--int insertUser();--&gt;
    &lt;insert id="insertUser"&gt;
        insert into t_user values(null,'admin','123456',23,'男','12345@qq.com')
    &lt;/insert&gt;
    &lt;!--void updateUser();--&gt;
    &lt;update id="updateUser"&gt;
        update t_user set username = '张三' where id = 3
    &lt;/update&gt;
    &lt;!--void deleteUser();--&gt;
    &lt;delete id="deleteUser"&gt;
        delete from t_user where id = 4
    &lt;/delete&gt;
    &lt;!--User selectUser();--&gt;
    &lt;!--
        查询功能的标签必须设置resultType或resultMap
        resultType：设置的是默认的映射关系(要求表的字段名和java实体类的属性名一致，然后就可以自动创建映射关系，把查询出来的字段名为相对应的属性赋值)
        resultMap：设置的是自定义的映射关系()
    --&gt;
    &lt;select id="selectUser" resultType="com.atguigu.mybatis.pojo.User"&gt;
        select * from t_user where id = 2
    &lt;/select&gt;
    &lt;!--List&lt;User&gt; selectUsers();--&gt;
    &lt;select id="selectUsers" resultType="com.atguigu.mybatis.pojo.User"&gt;
        select * from t_user
    &lt;/select&gt;
&lt;/mapper&gt;</code></pre> 
<h4>2.6 通过junit测试功能</h4> 
<pre><code>public class MybatisTest {
    /**
     * sqlSession默认不自动提交事务，需要使用sqlSession.commit()手动提交事务
     * 若需要自动提交事务，可以使用qlSessionFactory.openSession(true)
     */
    @Test
    public void testMybatis() throws IOException {
        //获取SQLSession:代表Java程序和数据库之间的会话。（HttpSession是Java程序和浏览器之间的会话）
        //1.加载核心配置文件，读取配置文件，获取对应的字节输入流
        InputStream is = Resources.getResourceAsStream("mybatis-config.xml");
        //2.获取SQLSessionFactoryBuilder（是一个提供SQLSession的一个工厂对象的一个构件对象）对象
        SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder();
        //3.获取SQLSessionFactory对象
        SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(is);
        //4.获取Mybatis操作数据库的一个会话对象：SqlSession对象，此时通过SqlSession对象所操作的sql都会自动提交
        SqlSession sqlSession = sqlSessionFactory.openSession(true);
        //通过代理模式创建UserMapper接口的代理实现类对象
        UserMapper userMapper = sqlSession.getMapper(UserMapper.class);
        //测试功能
        int result = userMapper.insertUser();
        System.out.println("result:"+result);
        //提交事务，使用sqlSessionFactory.openSession()获取sqlSession时，需要手动提交事务;
        //使用sqlSessionFactory.openSession(true)获取sqlSession时，代表自动提交事务;
        //sqlSession.commit();
    }
}</code></pre> 
<h4>2.7 加入log4j日志功能</h4> 
<pre><code>###################加入依赖
&lt;!-- log4j日志 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;log4j&lt;/groupId&gt;
    &lt;artifactId&gt;log4j&lt;/artifactId&gt;
    &lt;version&gt;1.2.17&lt;/version&gt;
&lt;/dependency&gt;
###################加入log4j的配置文件
&lt;?xml version="1.0" encoding="UTF-8" ?&gt;
&lt;!DOCTYPE log4j:configuration SYSTEM "log4j.dtd"&gt;
&lt;log4j:configuration xmlns:log4j="http://jakarta.apache.org/log4j/"&gt;
    &lt;appender name="STDOUT" class="org.apache.log4j.ConsoleAppender"&gt;
        &lt;param name="Encoding" value="UTF-8"/&gt;
        &lt;layout class="org.apache.log4j.PatternLayout"&gt;
            &lt;param name="ConversionPattern" value="%-5p %d{MM-dd HH:mm:ss,SSS}%m (%F:%L) \n"/&gt;
        &lt;/layout&gt;
    &lt;/appender&gt;
    &lt;logger name="java.sql"&gt;
        &lt;level value="debug"/&gt;
    &lt;/logger&gt;
    &lt;logger name="org.apache.ibatis"&gt;
        &lt;level value="info"/&gt;
    &lt;/logger&gt;
    &lt;root&gt;
        &lt;level value="debug"/&gt;
        &lt;appender-ref ref="STDOUT"/&gt;
    &lt;/root&gt;
&lt;/log4j:configuration&gt;
</code></pre> 
<h3>3. 核心配置文件详解</h3> 
<ul><li>核心配置文件中的标签必须按照固定的顺序，否则会报错： 
  <ul><li>properties?,settings?,typeAliases?,typeHandlers?,objectFactory?,objectWrapperFactory?,reflectorFactory?,plugins?,environments?,databaseIdProvider?,mappers?</li></ul></li></ul> 
<pre><code>&lt;?xml version="1.0" encoding="UTF-8" ?&gt;
&lt;!DOCTYPE configuration
    PUBLIC "-//MyBatis.org//DTD Config 3.0//EN"
    "http://MyBatis.org/dtd/MyBatis-3-config.dtd"&gt;
&lt;configuration&gt;
    &lt;!--引入properties文件，此时就可以${属性名}的方式访问属性值--&gt;
    &lt;properties resource="jdbc.properties"&gt;&lt;/properties&gt;
    &lt;settings&gt;
        &lt;!--将表中字段的下划线自动转换为驼峰--&gt;
        &lt;setting name="mapUnderscoreToCamelCase" value="true"/&gt;
        &lt;!--开启延迟加载--&gt;
        &lt;setting name="lazyLoadingEnabled" value="true"/&gt;
    &lt;/settings&gt;
    &lt;typeAliases&gt;
        &lt;!--
            typeAlias：设置某个具体的类型的别名
            属性：
            type：需要设置别名的类型的全类名
            alias：设置此类型的别名，若不设置此属性，该类型拥有默认的别名，即类名且不区分大小写
            若设置此属性，此时该类型的别名只能使用alias所设置的值
        --&gt;
        &lt;!--&lt;typeAlias type="com.atguigu.mybatis.bean.User"&gt;&lt;/typeAlias&gt;--&gt;
        &lt;!--&lt;typeAlias type="com.atguigu.mybatis.bean.User" alias="abc"&gt;&lt;/typeAlias&gt;--&gt;
        &lt;!--以包为单位，设置改包下所有的类型都拥有默认的别名，即类名且不区分大小写--&gt;
        &lt;package name="com.atguigu.mybatis.bean"/&gt;
    &lt;/typeAliases&gt;
    &lt;!--
        environments：设置多个连接数据库的环境
        属性default：设置默认使用的环境的id
    --&gt;
    &lt;environments default="mysql_test"&gt;
        &lt;!--
            environment：设置具体的连接数据库的环境信息
            属性id：设置环境的唯一标识，可通过environments标签中的default设置某一个环境的id，表示默认使用的环境
        --&gt;
        &lt;environment id="mysql_test"&gt;
            &lt;!--
                transactionManager：设置事务管理方式
                属性type：设置事务管理方式，type="JDBC|MANAGED"
                type="JDBC"：设置当前环境的事务管理都必须手动处理
                type="MANAGED"：设置事务被管理，例如spring中的AOP
             --&gt;
            &lt;transactionManager type="JDBC"/&gt;
            &lt;!--
                dataSource：设置数据源
                属性type：设置数据源的类型，type="POOLED|UNPOOLED|JNDI"
                type="POOLED"：使用数据库连接池，即会将创建的连接进行缓存，下次使用可以从缓存中直接获取，不需要重新创建
                type="UNPOOLED"：不使用数据库连接池，即每次使用连接都需要重新创建
                type="JNDI"：调用上下文中的数据源
            --&gt;
            &lt;dataSource type="POOLED"&gt;
                &lt;!--设置驱动类的全类名--&gt;
                &lt;property name="driver" value="${jdbc.driver}"/&gt;
                &lt;!--设置连接数据库的连接地址--&gt;
                &lt;property name="url" value="${jdbc.url}"/&gt;
                &lt;!--设置连接数据库的用户名--&gt;
                &lt;property name="username" value="${jdbc.username}"/&gt;
                &lt;!--设置连接数据库的密码--&gt;
                &lt;property name="password" value="${jdbc.password}"/&gt;
            &lt;/dataSource&gt;
        &lt;/environment&gt;
    &lt;/environments&gt;
    &lt;!--引入映射文件--&gt;
    &lt;mappers&gt;
        &lt;mapper resource="UserMapper.xml"/&gt;
        &lt;!--
            以包为单位，将包下所有的映射文件引入核心配置文件
            注意：此方式必须保证mapper接口和mapper映射文件必须在相同的包下
        --&gt;
        &lt;package name="com.atguigu.mybatis.mapper"/&gt;
    &lt;/mappers&gt;
&lt;/configuration&gt;</code></pre> 
<h3>4. Mybatis的增删改查</h3> 
<pre><code>##########添加################
&lt;!--int insertUser();--&gt;
&lt;insert id="insertUser"&gt;
    insert into t_user values(null,'admin','123456',23,'男','12345@qq.com')
&lt;/insert&gt;
##########修改################
&lt;!--void updateUser();--&gt;
&lt;update id="updateUser"&gt;
    update t_user set username = '张三' where id = 3
&lt;/update&gt;
##########删除################
&lt;!--void deleteUser();--&gt;
&lt;delete id="deleteUser"&gt;
    delete from t_user where id = 4
&lt;/delete&gt;
##########查询一个实体类对象################
&lt;!--User selectUser();--&gt;
&lt;!--
    查询功能的标签必须设置resultType或resultMap
    resultType：设置的是默认的映射关系(要求表的字段名和java实体类的属性名一致，然后就可以自动创建映射关系，把查询出来的字段名为相对应的属性赋值)
    resultMap：设置的是自定义的映射关系()
--&gt;
&lt;select id="selectUser" resultType="com.atguigu.mybatis.pojo.User"&gt;
    select * from t_user where id = 2
&lt;/select&gt;
##########查询集合################
&lt;!--
    当查询的数据为多条时，不能使用实体类作为返回值，只能使用集合，否则会抛出异常TooManyResultsException；
    但是若查询的数据只有一条，可以使用实体类或集合作为返回值    
--&gt;
&lt;!--List&lt;User&gt; selectUsers();--&gt;
&lt;select id="selectUsers" resultType="com.atguigu.mybatis.pojo.User"&gt;
    select * from t_user
&lt;/select&gt;</code></pre> 
<h3>5. Mybatis获取参数值的两种方式(重点)</h3> 
<ul><li>Mybatis获取参数值的两种方式：${}和#{}</li><li><span style="color:#fe2c24;"><strong>${}的本质是字符串拼接，可能会造成sql注入，' '需要手动拼接</strong></span></li><li><span style="color:#fe2c24;"><strong>#{}的本质是占位符赋值，</strong></span>只需要把需要获取的值放在相对应的位置上</li><li>${}使用字符串拼接的方式拼接sql，<span style="color:#fe2c24;"><strong>若为字符串类型或日期类型的字段进行赋值，需要手动加单引号</strong></span>；但是<span style="color:#fe2c24;"><strong>#{}</strong></span>使用占位符赋值的方式拼接sql，此时为字符串类型或日期类型的字段进行赋值时，<span style="color:#fe2c24;"><strong>可以自动添加单引号</strong></span></li></ul> 
<h4>5.1 单个字面量类型的参数</h4> 
<ul><li>若mapper接口中的方法参数为单个的字面量类型，此时可以使用${}和#{}以任意的名称获取参数的值，注意${}需要手动加单引号</li></ul> 
<pre><code>public interface ParameterMapper {
    /**
     * 根据用户名查询用户信息
     */
    User getUserByUserName(String username);
}
ParameterMapper.xml
&lt;!--User getUserByUserName(String username);--&gt;
&lt;select id="getUserByUserName" resultType="User"&gt;
    &lt;!--select * from t_user where username = #{username}--&gt;
    select * from t_user where username = '${username}'
&lt;/select&gt;</code></pre> 
<h4>5.2 多个字面量类型的参数</h4> 
<ul><li>若mapper接口中的方法参数为多个时，此时MyBatis会自动将这些参数放在一个map集合中，以arg0,arg1...为键，以参数为值；以param1,param2...为键，以参数为值；因此只需要通过${}和#{}访问map集合的键就可以获取相对应的值，注意${}需要手动加单引号</li></ul> 
<pre><code> public interface ParameterMapper{
    /**
     * 通过用户名和密码进行验证登录
     */
    User checkLogin(String username,String password);
}
ParameterMapper.xml
&lt;!--User checkLogin(String username,String password);--&gt;
&lt;select id="checkLogin" resultType="User"&gt;
    &lt;!--select * from t_user where username = #{arg0} and password = #{arg1}--&gt;
    select * from t_user where username = '${arg0}' and password = '${arg1}'
&lt;/select&gt;</code></pre> 
<h4>5.3 map集合类型的参数</h4> 
<ul><li>若mapper接口中的方法需要参数为多个时，可以手动创建map集合，将这些数据放在map中只需要通过${}和#{}访问map集合的键就可以获取相对应的值，注意${}需要手动加单引号</li></ul> 
<pre><code>public interface ParameterMapper {
    /**
     * 通过用户名和密码进行验证登录（参数为map）
     */
    User checkLoginByMap(Map&lt;String,Object&gt; map);
}
ParameterMapper.xml
&lt;!--User checkLoginByMap(Map&lt;String,Object&gt; map);--&gt;
&lt;select id="checkLoginByMap" resultType="User"&gt;
    select * from t_user where username = #{username} and password = #{password}
&lt;/select&gt;</code></pre> 
<h4>5.4 实体类类型的参数</h4> 
<ul><li>若mapper接口中的方法参数为实体类对象时，此时可以使用${}和#{}，通过访问实体类对象中的属性名获取属性值，注意${}需要手动加单引号</li></ul> 
<pre><code>public interface ParameterMapper {
    /**
     * 添加一个用户信息
     */
    int insertUser(User user);
}
ParameterMapper.xml
&lt;!--int insertUser(User user);--&gt;
&lt;insert id="insertUser"&gt;
    insert into t_user values(null,#{username},#{password},#{age},#{sex},#{email})
&lt;/insert&gt;</code></pre> 
<h4>5.5 使用@Param标识参数</h4> 
<ul><li>可以通过@Param注解标识mapper接口中的方法参数，此时，会将这些参数放在map集合中，以@Param注解的value属性值为键，以参数为值；以param1,param2...为键，以参数为值；只需要通过${}和#{}访问map集合的键就可以获取相对应的值，注意${}需要手动加单引号</li></ul> 
<pre><code>public interface ParameterMapper {
    /**
     * 验证登录（使用@param）
     */
    User checkLoginByParam(@Param("username") String username, @Param("password") String password);
}
ParameterMapper.xml
&lt;!--User checkLoginByParam(@Param("username") String username, @Param("password") String password);--&gt;
&lt;select id="checkLoginByParam" resultType="User"&gt;
    select * from t_user where username = #{username} and password = #{password}
&lt;/select&gt;</code></pre> 
<h3>6. Mybatis的各种查询功能</h3> 
<h4>6.1 查询一个实体类对象</h4> 
<pre><code>/**
 * 根据用户id查询用户信息
 */
User getUserById(@Param("id") Integer id);
&lt;!--User getUserById(@Param("id") Integer id);--&gt;
&lt;select id="getUserById" resultType="User"&gt;
    select * from t_user where id = #{id}
&lt;/select&gt;</code></pre> 
<h4>6.2 查询一个List集合</h4> 
<pre><code>/**
 * 查询所有的用户的信息
 */
List&lt;User&gt; getAllUser();
&lt;!--List&lt;User&gt; getAllUser();--&gt;
&lt;select id="getAllUser" resultType="User"&gt;
    select * from t_user
&lt;/select&gt;</code></pre> 
<h4>6.3 查询单个数据</h4> 
<pre><code>/**
 * 查询用户信息的总记录数
 * 在Mybatis中，对于Java中常用的类型都设置了类型别名
 * java.lang.Integer --&gt; int|integer
 * int --&gt; _int|_integer
 * Map --&gt; map
 * List --&gt; list
 */
Integer getCount();
&lt;!--Integer getCount();--&gt;
&lt;select id="getCount" resultType="java.lang.Integer"&gt;
    select count(*) from t_user
&lt;/select&gt;
</code></pre> 
<h4>6.4 查询一条数据为map集合</h4> 
<pre><code>/**
 * 根据id查询用户信息为一个map集合
 */
Map&lt;String,Object&gt; getUserByIdToMap(@Param("id") Integer id);
&lt;!--Map&lt;String,Object&gt; getUserByIdToMap(@Param("id") Integer id);--&gt;
&lt;select id="getUserByIdToMap" resultType="map"&gt;
    select * from t_user where id = #{id}
&lt;/select&gt;
&lt;!--结果：{password=123456, sex=男, id=1, age=23, username=admin}--&gt;</code></pre> 
<h4>6.5 查询多条数据为map集合</h4> 
<pre><code>/**
 * 查询所有用户信息为一个map集合
 * 将表中的数据以map集合的方式查询，一条数据对应一个map；
 * 若有多条数据，就会产生多个map集合，此时可以将这些map放在一个list集合中获取
 */
方式1：
List&lt;Map&lt;String,Object&gt;&gt; getAllUserToMap();
&lt;!--List&lt;Map&lt;String,Object&gt;&gt; getAllUserToMap();--&gt;
&lt;select id="getAllUserToMap" resultType="map"&gt;
    select * from t_user
&lt;/select&gt;
/**
 * 查询所有用户信息为一个map集合
 * 将表中的数据以map集合的方式查询，一条数据对应一个map；
 * 若有多条数据，就会产生多个map集合，并且最终要以一个map的方式返回数据
 * 此时需要通过@MapKey注解设置Map集合的键，值是每条数据所对应的map集合
 */
方式2：
@MapKey("id")
Map&lt;String,Object&gt; getAllUserToMap();
&lt;!--Map&lt;String, Object&gt; getAllUserToMap();--&gt;
&lt;select id="getAllUserToMap" resultType="map"&gt;
    select * from t_user
&lt;/select&gt;
结果：
&lt;!--
    {
        1={password=123456, sex=男, id=1, age=23, username=admin},
        2={password=123456, sex=男, id=2, age=23, username=张三},
        3={password=123456, sex=男, id=3, age=23, username=张三}
    }
--&gt;
</code></pre> 
<h3>7. 特殊SQL的执行</h3> 
<h4>7.1 模糊查询</h4> 
<pre><code>/**
 * 根据用户名模糊查询用户信息
 */
List&lt;User&gt; getUserByLike(@Param("username") String username);
&lt;!--List&lt;User&gt; getUserByLike(@Param("username") String username);--&gt;
&lt;select id="getUserByLike" resultType="User"&gt;
    &lt;!--select * from t_user where username like '%${username}%'--&gt;
    &lt;!--select * from t_user where username like concat('%',#{username},'%')--&gt;
    select * from t_user where username like "%"#{username}"%"
&lt;/select&gt;
</code></pre> 
<h4>7.2 批量删除</h4> 
<pre><code>/**
 * 批量删除
 */
int deleteMore(@Param("ids") String ids);
&lt;!--int deleteMore(@Param("ids") String ids);--&gt;
&lt;delete id="deleteMore"&gt;
    delete from t_user where id in (${ids})
&lt;/delete&gt;</code></pre> 
<h4>7.3 动态设置表名</h4> 
<pre><code>/**
 * 查询指定表中的数据
 */
List&lt;User&gt; getUserByTableName(@Param("tableName") String tableName);
&lt;!--List&lt;User&gt; getUserByTableName(@Param("tableName") String tableName);--&gt;
&lt;select id="getUserByTableName" resultType="User"&gt;
    select * from ${tableName}
&lt;/select&gt;</code></pre> 
<h4>7.4 添加功能获取自增的主键</h4> 
<pre><code>/**
 * 添加用户信息
 * useGeneratedKeys：设置使用自增的主键
 * keyProperty：因为增删改有统一的返回值是受影响的行数
 * 因此只能将获取的自增的主键放在传输的参数user对象的某个属性中
 */
int insertUser(User user);
&lt;!--
    int insertUser(User user);
    useGeneratedKeys:设置当前标签中的sql使用了自增的主键(id)
    keyProperty:将自增的主键（id）的值赋值给传输到映射文件中参数的某个属性
--&gt;
&lt;insert id="insertUser" useGeneratedKeys="true" keyProperty="id"&gt;
    insert into t_user values(null,#{username},#{password},#{age},#{sex},#{email})
&lt;/insert&gt;</code></pre> 
<h3>8. 自定义映射resultMap</h3> 
<h4>8.1 resultMap处理字段和属性的映射关系</h4> 
<ul><li>若字段名和实体类中的属性名不一致，则可以通过resultMap设置自定义映射</li></ul> 
<pre><code>&lt;!--
    resultMap：设置自定义映射
    属性：
        id：表示自定义映射的唯一标识
        type：查询的数据要映射的实体类的类型
    子标签：
        id：设置主键的映射关系
        result：设置普通字段的映射关系
        association：设置多对一的映射关系
        collection：设置一对多的映射关系
    属性：
        property：设置映射关系中实体类中的属性名
        column：设置映射关系中表中的字段名
--&gt;
&lt;resultMap id="userMap" type="User"&gt;
    &lt;id property="id" column="id"&gt;&lt;/id&gt;
    &lt;result property="userName" column="user_name"&gt;&lt;/result&gt;
    &lt;result property="password" column="password"&gt;&lt;/result&gt;
    &lt;result property="age" column="age"&gt;&lt;/result&gt;
    &lt;result property="sex" column="sex"&gt;&lt;/result&gt;
&lt;/resultMap&gt;
&lt;!--List&lt;User&gt; testMohu(@Param("mohu") String mohu);--&gt;
&lt;select id="testMohu" resultMap="userMap"&gt;
    &lt;!--select * from t_user where username like '%${mohu}%'--&gt;
    select id,user_name,password,age,sex from t_user where user_name like concat('%',#{mohu},'%')
&lt;/select&gt;</code></pre> 
<h4>8.2 多对一映射处理</h4> 
<ul><li>查询员工信息以及员工所对应的部门信息</li></ul> 
<p>8.2.1 实体类Emp和Dept</p> 
<pre><code>public class Dept {
    private Integer did;
    private String deptName;
    private List&lt;Emp&gt; empList;//一对多
}
public class Emp implements Serializable {
    private Integer eid;
    private String empName;
    private Integer age;
    private String sex;
    private String email;
    private Dept dept;//多对一
}</code></pre> 
<p>8.2.2 级联方式处理映射关系</p> 
<pre><code>&lt;resultMap id="empDeptMap" type="Emp"&gt;
    &lt;id column="eid" property="eid"&gt;&lt;/id&gt;
    &lt;result column="ename" property="ename"&gt;&lt;/result&gt;
    &lt;result column="age" property="age"&gt;&lt;/result&gt;
    &lt;result column="sex" property="sex"&gt;&lt;/result&gt;
    &lt;result column="did" property="dept.did"&gt;&lt;/result&gt;
    &lt;result column="dname" property="dept.dname"&gt;&lt;/result&gt;
&lt;/resultMap&gt;
&lt;!--Emp getEmpAndDeptByEid(@Param("eid") int eid);--&gt;
&lt;select id="getEmpAndDeptByEid" resultMap="empDeptMap"&gt;
    select emp.*,dept.* from t_emp emp left join t_dept dept on emp.did = dept.did where emp.eid = #{eid}
&lt;/select&gt;</code></pre> 
<p>8.2.3 使用association处理映射关系</p> 
<pre><code>&lt;resultMap id="empAndDeptResultMap" type="Emp"&gt;
    &lt;id property="eid" column="eid"/&gt;
    &lt;result property="empName" column="emp_name"/&gt;
    &lt;result property="age" column="age"/&gt;
    &lt;result property="sex" column="sex"/&gt;
    &lt;result property="email" column="email"/&gt;
    &lt;!--association：处理多对一的映射关系，property是实体类的属性，javaType是属性对应的实体类--&gt;
    &lt;association property="dept" javaType="Dept"&gt;
        &lt;id property="did" column="did"/&gt;
        &lt;result property="deptName" column="dept_name"/&gt;
    &lt;/association&gt;
&lt;/resultMap&gt;
&lt;!--Emp getEmpAndDeptById(@Param("eid") Integer eid); --&gt;
&lt;select id="getEmpAndDeptById" resultMap="empAndDeptResultMap"&gt;
    select * from t_emp emp left join t_dept dept on emp.did = dept.did where emp.eid = #{eid}
&lt;/select&gt;</code></pre> 
<p>8.2.4 分步查询</p> 
<pre><code>1&gt;查询员工信息
/**
 * 通过分步查询查询员工信息
 */
Emp getEmpByStep(@Param("eid") int eid);
&lt;resultMap id="empDeptStepMap" type="Emp"&gt;
    &lt;id column="eid" property="eid"&gt;&lt;/id&gt;
    &lt;result column="ename" property="ename"&gt;&lt;/result&gt;
    &lt;result column="age" property="age"&gt;&lt;/result&gt;
    &lt;result column="sex" property="sex"&gt;&lt;/result&gt;
    &lt;!--
        select：设置分步查询，查询某个属性的值的sql的标识（namespace.sqlId）
        column：将sql以及查询结果中的某个字段设置为分步查询的条件
    --&gt;
    &lt;association property="dept" select="com.atguigu.MyBatis.mapper.DeptMapper.getEmpDeptByStep" column="did"&gt;&lt;/association&gt;
&lt;/resultMap&gt;
&lt;!--Emp getEmpByStep(@Param("eid") int eid);--&gt;
&lt;select id="getEmpByStep" resultMap="empDeptStepMap"&gt;
    select * from t_emp where eid = #{eid}
&lt;/select&gt;
2&gt;根据员工所对应的部门id查询部门信息
/**
 * 分步查询的第二步：根据员工所对应的did查询部门信息
 */
Dept getEmpDeptByStep(@Param("did") int did);
&lt;!--Dept getEmpDeptByStep(@Param("did") int did);--&gt;
&lt;select id="getEmpDeptByStep" resultType="Dept"&gt;
    select * from t_dept where did = #{did}
&lt;/select&gt;</code></pre> 
<h4>8.3 一对多映射处理</h4> 
<p>8.3.1 使用collection处理映射关系</p> 
<pre><code>/**
 * 根据部门id查新部门以及部门中的员工信息
 */
Dept getDeptEmpByDid(@Param("did") int did);
&lt;resultMap id="deptEmpMap" type="Dept"&gt;
    &lt;id property="did" column="did"&gt;&lt;/id&gt;
    &lt;result property="dname" column="dname"&gt;&lt;/result&gt;
    &lt;!--
        ofType：设置collection标签所处理的集合属性中存储数据的类型
    --&gt;
    &lt;collection property="emps" ofType="Emp"&gt;
        &lt;id property="eid" column="eid"&gt;&lt;/id&gt;
        &lt;result property="ename" column="ename"&gt;&lt;/result&gt;
        &lt;result property="age" column="age"&gt;&lt;/result&gt;
        &lt;result property="sex" column="sex"&gt;&lt;/result&gt;
    &lt;/collection&gt;
&lt;/resultMap&gt;
&lt;!--Dept getDeptEmpByDid(@Param("did") int did);--&gt;
&lt;select id="getDeptEmpByDid" resultMap="deptEmpMap"&gt;
    select dept.*,emp.* from t_dept dept left join t_emp emp on dept.did = emp.did where dept.did = #{did}
&lt;/select&gt;</code></pre> 
<p>8.3.2 分步查询</p> 
<pre><code>1&gt;查询部门信息
/**
 * 分步查询部门和部门中的员工
 */
Dept getDeptByStep(@Param("did") int did);
&lt;resultMap id="deptEmpStep" type="Dept"&gt;
    &lt;id property="did" column="did"&gt;&lt;/id&gt;
    &lt;result property="dname" column="dname"&gt;&lt;/result&gt;
    &lt;collection property="emps" fetchType="eager" select="com.atguigu.MyBatis.mapper.EmpMapper.getEmpListByDid" column="did"&gt;&lt;/collection&gt;
&lt;/resultMap&gt;
&lt;!--Dept getDeptByStep(@Param("did") int did);--&gt;
&lt;select id="getDeptByStep" resultMap="deptEmpStep"&gt;
    select * from t_dept where did = #{did}
&lt;/select&gt;
2&gt;查询员工信息
/**
 * 根据部门id查询员工信息
 */
List&lt;Emp&gt; getEmpListByDid(@Param("did") int did);
&lt;!--List&lt;Emp&gt; getEmpListByDid(@Param("did") int did);--&gt;
&lt;select id="getEmpListByDid" resultType="Emp"&gt;
    select * from t_emp where did = #{did}
&lt;/select&gt;</code></pre> 
<h4>8.4 分步查询的优点</h4> 
<ul><li>可以实现延迟加载，但是必须在核心配置文件中设置全局配置信息</li><li>lazyLoadingEnabled：延迟加载的全局开关。当开启时，所有关联对象都会延迟加载</li><li>aggressiveLazyLoading：当开启时，任何方法的调用都会加载该对象的所有属性。 否则，每个属性会按需加载</li><li>此时就可以实现按需加载，获取的数据是什么，就只会执行相应的sql。此时可通过association和collection中的fetchType属性设置当前的分步查询是否使用延迟加载，fetchType="lazy(延迟加载)|eager(立即加载)"</li></ul> 
<h3>9. 动态SQL</h3> 
<ul><li>Mybatis框架的动态SQL技术是一种根据特定条件动态拼装SQL语句的功能，它存在的意义是为了解决拼接SQL语句字符串时的痛点问题。</li></ul> 
<h4>9.1 if</h4> 
<ul><li>if标签可通过test属性的表达式进行判断，若表达式的结果为true，则标签中的内容会执行；反之标签中的内容不会执行</li><li>SQL语句：select * from t_emp where 1=1中，where 1=1 是为了避免where 关键字后面的第一个词直接就是 “and”而导致语法错误。 因为table中根本就没有名称为1的字段，所以该SQL等效于select * from t_emp</li></ul> 
<pre><code>&lt;!--List&lt;Emp&gt; getEmpListByMoreTJ(Emp emp);--&gt;
&lt;select id="getEmpListByMoreTJ" resultType="Emp"&gt;
    select * from t_emp where 1=1
    &lt;if test="empName != '' and empName != null"&gt;
        and emp_name = #{empName}
    &lt;/if&gt;
    &lt;if test="age != '' and age != null"&gt;
        and age = #{age}
    &lt;/if&gt;
    &lt;if test="sex != '' and sex != null"&gt;
        and sex = #{sex}
    &lt;/if&gt;
    &lt;if test="email != '' and email != null"&gt;
        and email = #{email}
    &lt;/if&gt;
&lt;/select&gt;</code></pre> 
<h4>9.2 where</h4> 
<ul><li>where和if一般结合使用： 
  <ul><li>若where标签中的if条件都不满足，则where标签没有任何功能，即不会添加where关键字</li><li>若where标签中的if条件满足，则where标签会自动添加where关键字，并将条件最前方多余的and去掉</li><li>注意：where标签不能去掉条件最后多余的and</li></ul></li></ul> 
<pre><code>&lt;select id="getEmpListByMoreTJ2" resultType="Emp"&gt;
    select * from t_emp
    &lt;where&gt;
        &lt;if test="empName != '' and empName != null"&gt;
            emp_name = #{empName}
        &lt;/if&gt;
        &lt;if test="age != '' and age != null"&gt;
            and age = #{age}
        &lt;/if&gt;
        &lt;if test="sex != '' and sex != null"&gt;
            and sex = #{sex}
        &lt;/if&gt;
        &lt;if test="email != '' and email != null"&gt;
            and email = #{email}
        &lt;/if&gt;
    &lt;/where&gt;
&lt;/select&gt;</code></pre> 
<h4>9.3 trim</h4> 
<ul><li>trim用于去掉或添加标签中的内容</li><li>常用属性： 
  <ul><li>prefix：在trim标签中的内容的前面添加某些内容</li><li>prefixOverrides：在trim标签中的内容的前面去掉某些内容</li><li>suffix：在trim标签中的内容的后面添加某些内容</li><li>suffixOverrides：在trim标签中的内容的后面去掉某些内容</li></ul></li></ul> 
<pre><code>&lt;select id="getEmpListByMoreTJ" resultType="Emp"&gt;
    select * from t_emp
    &lt;trim prefix="where" suffixOverrides="and|or"&gt;
        &lt;if test="empName != '' and empName != null"&gt;
            emp_name = #{empName} and
        &lt;/if&gt;
        &lt;if test="age != '' and age != null"&gt;
            age = #{age} or
        &lt;/if&gt;
        &lt;if test="sex != '' and sex != null"&gt;
            sex = #{sex} and
        &lt;/if&gt;
        &lt;if test="email != '' and email != null"&gt;
            email = #{email} and
        &lt;/if&gt;
    &lt;/trim&gt;
&lt;/select&gt;</code></pre> 
<h4>9.4 choose、when、otherwise</h4> 
<ul><li>choose、when、otherwise相当于if...else if..else</li></ul> 
<pre><code>&lt;!--List&lt;Emp&gt; getEmpByChoose(Emp emp);--&gt;
&lt;select id="getEmpByChoose" resultType="Emp"&gt;
    select * from t_emp
    &lt;where&gt;
        &lt;choose&gt;
            &lt;when test="empName != '' and empName != null"&gt;
                emp_name = #{empName}
            &lt;/when&gt;
            &lt;when test="age != '' and age != null"&gt;
                age = #{age}
            &lt;/when&gt;
            &lt;when test="sex != '' and sex != null"&gt;
                sex = #{sex}
            &lt;/when&gt;
            &lt;when test="email != '' and email != null"&gt;
                email = #{email}
            &lt;/when&gt;
            &lt;otherwise&gt;
                did = 1
            &lt;/otherwise&gt;
        &lt;/choose&gt;
    &lt;/where&gt;
&lt;/select&gt;</code></pre> 
<h4>9.5 foreach</h4> 
<ul><li>属性： 
  <ul><li>collection：设置要循环的数组或集合</li><li>item：表示集合或数组中的每一个数据</li><li>separator：设置循环体之间的分隔符</li><li>open：设置foreach标签中的内容的开始符</li><li>close：设置foreach标签中的内容的结束符</li></ul></li></ul> 
<pre><code>&lt;!--int insertMoreByList(@Param("emps") List&lt;Emp&gt; emps);--&gt;
&lt;insert id="insertMoreByList"&gt;
    insert into t_emp values
    &lt;foreach collection="emps" item="emp" separator=","&gt;
        (null,#{emp.empName},#{emp.age},#{emp.sex},#{emp.email},null)
    &lt;/foreach&gt;
&lt;/insert&gt;
&lt;!--int deleteMoreByArray(@Param("eids") Integer[] eids);--&gt;
&lt;delete id="deleteMoreByArray"&gt;
    delete from t_emp where
    &lt;foreach collection="eids" item="eid" separator="or"&gt;
        eid = #{eid}
    &lt;/foreach&gt;
&lt;/delete&gt;
&lt;!--int deleteMoreByArray(int[] eids);--&gt;
&lt;delete id="deleteMoreByArray"&gt;
    delete from t_emp where eid in
    &lt;foreach collection="eids" item="eid" separator="," open="(" close=")"&gt;
        #{eid}
    &lt;/foreach&gt;
&lt;/delete&gt;</code></pre> 
<h4>9.6 SQL片段</h4> 
<ul><li>sql片段，可以记录一段公共sql片段，在使用的地方通过include标签进行引入</li></ul> 
<pre><code>&lt;sql id="empColumns"&gt;
    eid,ename,age,sex,did
&lt;/sql&gt;
select &lt;include refid="empColumns"&gt;&lt;/include&gt; from t_emp</code></pre> 
<h3>10. Mybatis的缓存</h3> 
<h4>10.1 Mybatis的一级缓存</h4> 
<ul><li>一级缓存是SqlSession级别的，<span style="color:#fe2c24;"><strong>通过同一个SqlSession查询的数据会被缓存，下次查询相同的数据，就会从缓存中直接获取，不会从数据库重新访问</strong></span></li><li><span style="color:#fe2c24;"><strong>使一级缓存失效的四种情况：</strong></span> 
  <ul><li>不同的SqlSession对应不同的一级缓存</li><li>同一个SqlSession但是查询条件不同</li><li>同一个SqlSession两次查询期间执行了任何一次增删改操作</li><li>同一个SqlSession两次查询期间手动清空了缓存</li></ul></li></ul> 
<h4>10.2 Mybatis的二级缓存</h4> 
<ul><li>二级缓存是SqlSessionFactory级别，<span style="color:#fe2c24;"><strong>通过同一个SqlSessionFactory创建的SqlSession查询的结果会被缓存；此后若再次执行相同的查询语句，结果就会从缓存中获取</strong></span></li><li>二级缓存开启的条件： 
  <ul><li>在核心配置文件中，设置全局配置属性cacheEnabled="true"，默认为true，不需要设置</li><li>在映射文件中设置标签：&lt;cache type="org.mybatis.caches.ehcache.EhcacheCache"/&gt;</li><li>二级缓存必须在SqlSession关闭或提交之后有效</li><li>查询的数据所转换的实体类类型必须实现序列化的接口</li></ul></li><li>使二级缓存失效的情况： 
  <ul><li>两次查询之间执行了任意的增删改，会使一级和二级缓存同时失效</li></ul></li></ul> 
<h4>10.3 二级缓存的相关配置</h4> 
<ul><li>在mapper配置文件中添加的cache标签可以设置一些属性： 
  <ul><li>eviction属性：缓存回收策略 
    <ul><li>LRU（Least Recently Used） – 最近最少使用的：移除最长时间不被使用的对象。</li><li>FIFO（First in First out） – 先进先出：按对象进入缓存的顺序来移除它们。</li><li>SOFT – 软引用：移除基于垃圾回收器状态和软引用规则的对象。</li><li>WEAK – 弱引用：更积极地移除基于垃圾收集器状态和弱引用规则的对象。</li><li>默认的是 LRU。</li></ul></li><li>flushInterval属性：刷新间隔，单位毫秒 
    <ul><li>默认情况是不设置，也就是没有刷新间隔，缓存仅仅调用语句时刷新</li></ul></li><li>size属性：引用数目，正整数 
    <ul><li>代表缓存最多可以存储多少个对象，太大容易导致内存溢出</li></ul></li><li>readOnly属性：只读，true/false 
    <ul><li>true：只读缓存；会给所有调用者返回缓存对象的相同实例。因此这些对象不能被修改。这提供了很重要的性能优势。</li><li>false：读写缓存；会返回缓存对象的拷贝（通过序列化）。这会慢一些，但是安全，因此默认是false。</li></ul></li></ul></li></ul> 
<h4>10.4 MyBatis缓存查询的顺序</h4> 
<ul><li>先查询二级缓存，因为二级缓存中可能会有其他程序已经查出来的数据，可以拿来直接使用。</li><li>如果二级缓存没有命中，再查询一级缓存</li><li>如果一级缓存也没有命中，则查询数据库</li><li>SqlSession关闭之后，一级缓存中的数据会写入二级缓存</li></ul> 
<h4>10.5 整合第三方缓存EHCache</h4> 
<p>10.5.1 添加依赖</p> 
<pre><code class="hljs">&lt;!-- Mybatis EHCache整合包 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.mybatis.caches&lt;/groupId&gt;
    &lt;artifactId&gt;mybatis-ehcache&lt;/artifactId&gt;
    &lt;version&gt;1.2.1&lt;/version&gt;
&lt;/dependency&gt;
&lt;!-- slf4j日志门面的一个具体实现 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;
    &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;
    &lt;version&gt;1.2.3&lt;/version&gt;
&lt;/dependency&gt;</code></pre> 
<p>10.5.2 各jar包功能</p> 
<p><img alt="" height="189" src="https://images2.imgbox.com/45/4b/8qPAXmwM_o.png" width="544"></p> 
<p>10.5.3 创建EHCache的配置文件ehcache.xml</p> 
<pre><code class="hljs">&lt;?xml version="1.0" encoding="utf-8" ?&gt;
&lt;ehcache xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:noNamespaceSchemaLocation="../config/ehcache.xsd"&gt;
    &lt;!-- 磁盘保存路径 --&gt;
    &lt;diskStore path="D:\atguigu\ehcache"/&gt;

    &lt;defaultCache
        maxElementsInMemory="1000"
        maxElementsOnDisk="10000000"
        eternal="false"
        overflowToDisk="true"
        timeToIdleSeconds="120"
        timeToLiveSeconds="120"
        diskExpiryThreadIntervalSeconds="120"
        memoryStoreEvictionPolicy="LRU"&gt;
    &lt;/defaultCache&gt;
&lt;/ehcache&gt;</code></pre> 
<p>10.5.4 在CacheMapper.xml映射文件中设置二级缓存的类型</p> 
<pre><code class="hljs">&lt;cache type="org.mybatis.caches.ehcache.EhcacheCache"/&gt;
</code></pre> 
<p>10.5.5 加入logback日志</p> 
<ul><li>存在SLF4j时，作为简易日志的log4j将失效，此时我们需要借助SLF4j的具体实现logback来打印日志。创建logback的配置文件logback.xml</li></ul> 
<pre><code class="hljs">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;configuration debug="true"&gt;
    &lt;!-- 指定日志输出的位置 --&gt;
    &lt;appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender"&gt;
        &lt;encoder&gt;
            &lt;!-- 日志输出的格式 --&gt;
            &lt;!-- 按照顺序分别是：时间、日志级别、线程名称、打印日志的类、日志主体内容、换行 --&gt;
            &lt;pattern&gt;[%d{HH:mm:ss.SSS}] [%-5level] [%thread] [%logger] [%msg]%n&lt;/pattern&gt;
        &lt;/encoder&gt;
    &lt;/appender&gt;

    &lt;!--设置全局日志级别。日志级别按顺序分别是：DEBUG、INFO、WARN、ERROR --&gt;
    &lt;!-- 指定任何一个日志级别都只打印当前级别和后面级别的日志。 --&gt;
    &lt;root level="DEBUG"&gt;
        &lt;!-- 指定打印日志的appender，这里通过“STDOUT”引用了前面配置的appender --&gt;
        &lt;appender-ref ref="STDOUT"/&gt;
    &lt;/root&gt;

    &lt;!-- 根据特殊需求指定局部日志级别 --&gt;
    &lt;logger name="com.atguigu.crowd.mapper" level="DEBUG"/&gt;

&lt;/configuration&gt;</code></pre> 
<p>10.5.6 EHCache配置文件说明</p> 
<p><img alt="" height="680" src="https://images2.imgbox.com/82/c3/1euIQMIP_o.png" width="550"></p> 
<h3>11. Mybatis的逆向工程</h3> 
<ul><li>正向工程：先创建java实体类，由框架负责根据实体类生成数据库表，Hibernate是支持正向工程的</li><li>逆向工程：先创建数据库表，由框架负责根据数据库表，反向生成如下资源： 
  <ul><li>java实体类</li><li>Mapper接口</li><li>Mapper映射文件</li></ul></li></ul> 
<h4>11.1 创建逆向工程的步骤</h4> 
<p>①.添加依赖和插件</p> 
<pre><code class="hljs">&lt;dependencies&gt;
    &lt;!-- Mybatis核心 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
        &lt;artifactId&gt;mybatis&lt;/artifactId&gt;
        &lt;version&gt;3.5.9&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;!-- junit测试 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;junit&lt;/groupId&gt;
        &lt;artifactId&gt;junit&lt;/artifactId&gt;
        &lt;version&gt;4.13.2&lt;/version&gt;
        &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
    &lt;!-- MySQL驱动 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;mysql&lt;/groupId&gt;
        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
        &lt;version&gt;8.0.28&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;!-- log4j日志 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;log4j&lt;/groupId&gt;
        &lt;artifactId&gt;log4j&lt;/artifactId&gt;
        &lt;version&gt;1.2.17&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;

&lt;!-- 控制Maven在构建过程中相关配置 --&gt;
&lt;build&gt;
    &lt;!-- 构建过程中用到的插件 --&gt;
    &lt;plugins&gt;
        &lt;!-- 具体插件，逆向工程的操作是以构建过程中插件形式出现的 --&gt;
        &lt;plugin&gt;
            &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt;
            &lt;version&gt;1.3.0&lt;/version&gt;

            &lt;!-- 插件的依赖 --&gt;
            &lt;dependencies&gt;
                &lt;!-- 逆向工程的核心依赖 --&gt;
                &lt;dependency&gt;
                    &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt;
                    &lt;artifactId&gt;mybatis-generator-core&lt;/artifactId&gt;
                    &lt;version&gt;1.3.2&lt;/version&gt;
                &lt;/dependency&gt;

                &lt;!-- 数据库连接池 --&gt;
                &lt;dependency&gt;
                    &lt;groupId&gt;com.mchange&lt;/groupId&gt;
                    &lt;artifactId&gt;c3p0&lt;/artifactId&gt;
                    &lt;version&gt;0.9.2&lt;/version&gt;
                &lt;/dependency&gt;

                &lt;!-- MySQL驱动 --&gt;
                &lt;dependency&gt;
                    &lt;groupId&gt;mysql&lt;/groupId&gt;
                    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
                    &lt;version&gt;8.0.28&lt;/version&gt;
                &lt;/dependency&gt;
            &lt;/dependencies&gt;
        &lt;/plugin&gt;
    &lt;/plugins&gt;
&lt;/build&gt;</code></pre> 
<p>②.创建Mybatis的核心配置文件</p> 
<pre><code class="hljs">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;
&lt;!DOCTYPE configuration
        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;
&lt;configuration&gt;

    &lt;properties resource="jdbc.properties"/&gt;

    &lt;typeAliases&gt;
        &lt;package name=""/&gt;
    &lt;/typeAliases&gt;

    &lt;environments default="development"&gt;
        &lt;environment id="development"&gt;
            &lt;transactionManager type="JDBC"/&gt;
            &lt;dataSource type="POOLED"&gt;
                &lt;property name="driver" value="${jdbc.driver}"/&gt;
                &lt;property name="url" value="${jdbc.url}"/&gt;
                &lt;property name="username" value="${jdbc.username}"/&gt;
                &lt;property name="password" value="${jdbc.password}"/&gt;
            &lt;/dataSource&gt;
        &lt;/environment&gt;
    &lt;/environments&gt;

    &lt;mappers&gt;
        &lt;package name=""/&gt;
    &lt;/mappers&gt;

&lt;/configuration&gt;</code></pre> 
<p>③.创建逆向工程的配置文件，文件名必须是：generatorConfig.xml</p> 
<pre><code class="hljs">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE generatorConfiguration
        PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN"
        "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd"&gt;
&lt;generatorConfiguration&gt;
    &lt;!--
        targetRuntime: 用于选择执行生成的逆向工程的版本
        MyBatis3Simple: 生成基本的CRUD（清新简洁版）
        MyBatis3: 生成带条件的CRUD（奢华尊享版）
    --&gt;
    &lt;context id="DB2Tables" targetRuntime="MyBatis3"&gt;
        &lt;!-- 数据库的连接信息 --&gt;
        &lt;jdbcConnection driverClass="com.mysql.cj.jdbc.Driver"
                        connectionURL="jdbc:mysql://localhost:3306/mybatis?serverTimezone=UTC"
                        userId="root"
                        password="abc123"&gt;
        &lt;/jdbcConnection&gt;
        &lt;!-- 
             javaBean(实体类)的生成策略
             targetPackage：包名；
             targetProject：包的位置
        --&gt;
        &lt;javaModelGenerator targetPackage="com.atguigu.mybatis.pojo" targetProject=".\src\main\java"&gt;
            &lt;!--enableSubPackages:是否能够使用子包；trimStrings：去掉字符串前后的空格--&gt;
            &lt;property name="enableSubPackages" value="true" /&gt;
            &lt;property name="trimStrings" value="true" /&gt;
        &lt;/javaModelGenerator&gt;
        &lt;!-- SQL映射文件的生成策略 --&gt;
        &lt;sqlMapGenerator targetPackage="com.atguigu.mybatis.mapper" targetProject=".\src\main\resources"&gt;
            &lt;property name="enableSubPackages" value="true" /&gt;
        &lt;/sqlMapGenerator&gt;
        &lt;!-- Mapper接口的生成策略 --&gt;
        &lt;javaClientGenerator type="XMLMAPPER" targetPackage="com.atguigu.mybatis.mapper" targetProject=".\src\main\java"&gt;
            &lt;property name="enableSubPackages" value="true" /&gt;
        &lt;/javaClientGenerator&gt;
        &lt;!-- 逆向分析的表 --&gt;
        &lt;!-- tableName设置为*号，可以对应所有表，此时不写domainObjectName --&gt;
        &lt;!-- domainObjectName属性指定生成出来的实体类的类名 --&gt;
        &lt;table tableName="t_emp" domainObjectName="Emp"/&gt;
        &lt;table tableName="t_dept" domainObjectName="Dept"/&gt;
    &lt;/context&gt;
&lt;/generatorConfiguration&gt;</code></pre> 
<p>④.执行MBG插件的generate目标</p> 
<p><img alt="" height="749" src="https://images2.imgbox.com/86/73/vCTnYfLU_o.png" width="1112"></p> 
<h4>11.2 QBC查询</h4> 
<pre><code class="hljs">@Test
public void testMBG() throws IOException {
    InputStream is = Resources.getResourceAsStream("mybatis-config.xml");
    SqlSession sqlSession = new SqlSessionFactoryBuilder().build(is).openSession(true);
    EmpMapper mapper = sqlSession.getMapper(EmpMapper.class);
    EmpExample empExample = new EmpExample();
    //创建条件对象，通过andXXX方法为SQL添加查询添加，每个条件之间是and关系
    empExample.createCriteria().andEnameLike("a").andAgeGreaterThan(20).andDidIsNotNull();
    //将之前添加的条件通过or拼接其他条件
    empExample.or().andSexEqualTo("男");
    List&lt;Emp&gt; list = mapper.selectByExample(empExample);
    for (Emp emp : list) {
        System.out.println(emp);
    }
}</code></pre> 
<h3>12. 分页插件</h3> 
<h4>12.1 添加依赖，并配置分页插件</h4> 
<pre><code class="hljs">&lt;!--分页插件--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;
    &lt;artifactId&gt;pagehelper&lt;/artifactId&gt;
    &lt;version&gt;5.2.0&lt;/version&gt;
&lt;/dependency&gt;
###################在Mybatis的核心配置文件中配置插件
&lt;plugins&gt;
    &lt;!--设置分页插件--&gt;
    &lt;plugin interceptor="com.github.pagehelper.PageInterceptor"/&gt;
&lt;/plugins&gt;</code></pre> 
<h4>12.2 分页插件的使用</h4> 
<ul><li>在查询功能之前使用PageHelper.startPage(int pageNum, int pageSize)开启分页功能 
  <ul><li>pageNum：当前页的页码</li><li>pageSize：每页显示的条数</li></ul></li><li>在查询获取list集合之后，使用PageInfo&lt;T&gt; pageInfo = new PageInfo&lt;&gt;(List&lt;T&gt; list, int navigatePages)获取分页相关数据 
  <ul><li>list：分页之后的数据</li><li>navigatePages：导航分页的页码数</li></ul></li></ul> 
<pre><code class="hljs">public class PageHelperTest {
    /**
     * sql分页：
     * limit index,pageSize
     * index:当前页的起始索引
     * pageSize：每页显示的条数
     * pageNum：当前页的页码
     * index=(pageNum-1)*pageSize
     *
     * 使用Mybatis的分页插件实现分页功能：
     * 1.在查询功能之前开启分页：PageHelper.startPage(int pageNum, int pageSize)开启分页功能
     *  pageNum：当前页的页码
     *  pageSize：每页显示的条数
     * 2.在查询获取list集合之后，使用PageInfo&lt;T&gt; pageInfo = new PageInfo&lt;&gt;(List&lt;T&gt; list, int navigatePages)获取分页相关信息
     *  list：表示分页数据
     *  navigatePages：表示当前导航分页的数量
     */
    @Test
    public void testPageHelper(){
        SqlSession sqlSession = SqlSessionUtils.getSqlSession();
        EmpMapper mapper = sqlSession.getMapper(EmpMapper.class);
        //查询功能之前开启分页功能
        PageHelper.startPage(2, 3);
        List&lt;Emp&gt; emps = mapper.getEmps();
        emps.forEach(System.out::println);
        //在查询获取list集合之后，使用PageInfo&lt;T&gt; pageInfo = new PageInfo&lt;&gt;(List&lt;T&gt; list, int navigatePages)获取分页相关数据
        //list：分页之后的数据
        //navigatePages：导航分页的页码数
        PageInfo&lt;Emp&gt; pageInfo = new PageInfo&lt;&gt;(emps,3);
        System.out.println(pageInfo);
    }
}</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9117624f898b90ebca2d62eb460494b3/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">volatile</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1f210312268886327730ec73c507c718/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">ESP8266 如何使用 GPIO13 &amp; GPIO15 进行 UART0 通信？</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>