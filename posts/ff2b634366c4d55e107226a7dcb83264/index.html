<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>supervisord部署使用超级详细版 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="supervisord部署使用超级详细版" />
<meta property="og:description" content="supervisord部署使用超级详细版 一. 安装 pip 命令（安装python 环境）
因为 supervisord本身是基于Python开发的，所以在使用时需要先安装Python 的运行环境
1.下载阿里的epel源
wget -O /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-7.repo 2.安装pip
yum -y install python-pip 3.设置socks代理,安装pysocks库。
pip install socks pip install pysocks 二. 安装 supervisor
1.使用pip 命令进行安装
pip install supervisor 2.使用命令测试是否安装成功
supervisord --help 三. 修改配置文件
1.生成配置文件并重定向到我们需要的目录
echo_supervisord_conf &gt; /opt/supervisor/conf/supervisord.conf 2.修改 [inet_http_server] 配置访问前端界面 可以看附文本参考
注意：127.0.0.1 可能会访问失败 ，建议使用ip
3.配置进程示例（[program:名称]）
[program:producer] command=java -jar producer-service-0.0.1-SNAPSHOT.jar process_name=%(program_name)s directory=/usr/local/java priority=999 tdout_logfile=/usr/local/java/tdoutProducer.log 四.启动命令
supervisord -c /opt/supervisor/conf/supervisord.conf 附录：
一. supervisord 常用命令（可以使用 supervisord -help 在系统中直接查看）" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/ff2b634366c4d55e107226a7dcb83264/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-09-06T21:56:04+08:00" />
<meta property="article:modified_time" content="2021-09-06T21:56:04+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">supervisord部署使用超级详细版</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="supervisord_0"></a><strong>supervisord部署使用超级详细版</strong></h3> 
<p><strong>一. 安装 pip 命令（安装python 环境）</strong><br> 因为 supervisord本身是基于Python开发的，所以在使用时需要先安装Python 的运行环境</p> 
<p>1.下载阿里的epel源</p> 
<pre><code class="prism language-bash"><span class="token function">wget</span> -O /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-7.repo
</code></pre> 
<p>2.安装pip</p> 
<pre><code class="prism language-bash">yum -y <span class="token function">install</span> python-pip
</code></pre> 
<p>3.设置socks代理,安装pysocks库。</p> 
<pre><code class="prism language-bash">pip <span class="token function">install</span> socks
pip <span class="token function">install</span> pysocks
</code></pre> 
<p><strong>二. 安装 supervisor</strong><br> 1.使用pip 命令进行安装</p> 
<pre><code class="prism language-bash">pip <span class="token function">install</span> supervisor
</code></pre> 
<p>2.使用命令测试是否安装成功</p> 
<pre><code class="prism language-bash">supervisord --help
</code></pre> 
<p><strong>三. 修改配置文件</strong><br> 1.生成配置文件并重定向到我们需要的目录</p> 
<pre><code class="prism language-bash">echo_supervisord_conf <span class="token operator">&gt;</span> /opt/supervisor/conf/supervisord.conf
</code></pre> 
<p>2.修改 [inet_http_server] 配置访问前端界面 可以看附文本参考<br> 注意：127.0.0.1 可能会访问失败 ，建议使用ip</p> 
<p>3.配置进程示例（[program:名称]）</p> 
<pre><code class="prism language-bash"><span class="token punctuation">[</span>program:producer<span class="token punctuation">]</span>
<span class="token assign-left variable">command</span><span class="token operator">=</span>java -jar producer-service-0.0.1-SNAPSHOT.jar 
<span class="token assign-left variable">process_name</span><span class="token operator">=</span>%<span class="token punctuation">(</span>program_name<span class="token punctuation">)</span>s 
<span class="token assign-left variable">directory</span><span class="token operator">=</span>/usr/local/java 
<span class="token assign-left variable">priority</span><span class="token operator">=</span><span class="token number">999</span>
<span class="token assign-left variable">tdout_logfile</span><span class="token operator">=</span>/usr/local/java/tdoutProducer.log
</code></pre> 
<p><strong>四.启动命令</strong></p> 
<pre><code class="prism language-bash">supervisord -c /opt/supervisor/conf/supervisord.conf
</code></pre> 
<p><strong>附录：</strong><br> <strong>一. supervisord 常用命令（可以使用 supervisord -help 在系统中直接查看）</strong></p> 
<pre><code class="prism language-bash">-c/——configuration FILENAME——配置文件路径<span class="token punctuation">(</span>如果没有指定，搜索<span class="token punctuation">)</span>
-n/——nodaemon——在前台运行<span class="token punctuation">(</span>与配置文件中的<span class="token string">'nodaemon=true'</span>相同<span class="token punctuation">)</span>
-s/——silent——no logs to stdout<span class="token punctuation">(</span>映射到配置文件中的<span class="token string">'silent=true'</span><span class="token punctuation">)</span>
-h/——help——打印此用法信息并退出
-v/——version——打印主程序版本号并退出
-u/——user user——作为这个用户运行supervisor<span class="token punctuation">(</span>或者数字uid<span class="token punctuation">)</span>
-m/——umask umask——将这个umask用于守护子进程<span class="token punctuation">(</span>默认为022<span class="token punctuation">)</span>
-d/——directory directory——directory to chdir to when daemonized
-l/——logfile FILENAME——使用FILENAME作为日志文件路径
-y/——logfile_maxbytes BYTES——使用BYTES限制logfile的最大大小
-z/——logfile_backups NUM——当达到最大字节数时保留的备份数量
-e/——loglevel LEVEL——使用LEVEL作为日志级别<span class="token punctuation">(</span>debug,info,warn,error,critical<span class="token punctuation">)</span>
-j/——pidfile FILENAME——将守护进程的pid文件写入FILENAME
-i/——identifier STR——用于该实例的标识符
-q/——childlogdir DIRECTORY——子进程日志目录
-k/——nocleanup——阻止进程执行清理<span class="token punctuation">(</span>删除旧的自动子日志文件<span class="token punctuation">)</span>启动时。
-a/——minfds NUM——启动成功所需的文件描述符的最小数量
-t/——strip_ansi——strip进程输出中的ANSI转义代码
——minprocs NUM——可以成功启动的最小进程数
——profile_options OPTIONS——在profiler下运行supervisor并输出
结果基于OPTIONS，它是逗号分隔的
<span class="token string">'累计'</span>、<span class="token string">'呼叫'</span>和/或<span class="token string">'呼叫'</span>的列表，
如。“累积,调用者”<span class="token punctuation">)</span>
</code></pre> 
<p><strong>二.supervisord 进程相关命令</strong></p> 
<pre><code class="prism language-bash">supervisorctl status 查看进程运行状态
supervisorctl start 进程名 启动进程
supervisorctl stop 进程名 关闭进程
supervisorctl restart 进程名 重启进程
supervisorctl update 重新载入配置文件
supervisorctl <span class="token function">shutdown</span> 关闭supervisord
supervisorctl <span class="token function">clear</span> 进程名 清空进程日志
supervisorctl 进入到交互模式下。使用help查看所有命令。
start stop restart + all 表示启动，关闭，重启所有进程
</code></pre> 
<p><strong>三. supervisord.conf 中文版简介</strong></p> 
<p>1.[unix_http_server]</p> 
<pre><code class="prism language-bash"><span class="token punctuation">[</span>unix_http_server<span class="token punctuation">]</span>            
<span class="token assign-left variable">file</span><span class="token operator">=</span>/tmp/supervisor.sock  <span class="token punctuation">;</span> socket文件的路径，supervisorctl用XML_RPC和supervisord通信就是通过它进行的。如不设置的话，supervisorctl也就不能用了不设置的话，默认为none。 非必须设置
<span class="token punctuation">;</span><span class="token assign-left variable">chmod</span><span class="token operator">=</span>0700         <span class="token punctuation">;</span> 这个简单，就是修改上面的那个socket文件的权限为0700不设置的话，默认为0700。 非必须设置
<span class="token punctuation">;</span><span class="token assign-left variable">chown</span><span class="token operator">=</span>nobody:nogroup      <span class="token punctuation">;</span> 这个一样，修改上面的那个socket文件的属组为user.group不设置的话，默认为启动supervisord进程的用户及属组。非必须设置
<span class="token punctuation">;</span><span class="token assign-left variable">username</span><span class="token operator">=</span>user              <span class="token punctuation">;</span> 使用supervisorctl连接的时候，认证的用户不设置的话，默认为不需要用户。 非必须设置
<span class="token punctuation">;</span><span class="token assign-left variable">password</span><span class="token operator">=</span><span class="token number">123</span>               <span class="token punctuation">;</span> 和上面的用户名对应的密码，可以直接使用明码，也可以使用SHA加密如：<span class="token punctuation">{<!-- --></span>SHA<span class="token punctuation">}</span>82ab876d1387bfafe46cc1c8a2ef074eae50cb1d默认不设置。。。非必须设置

</code></pre> 
<p>2.[inet_http_server]</p> 
<pre><code class="prism language-bash"><span class="token punctuation">;</span><span class="token punctuation">[</span>inet_http_server<span class="token punctuation">]</span>         <span class="token punctuation">;</span> 侦听在TCP上的socket，Web Server和远程的supervisorctl都要用到他不设置的话，默认为不开启。非必须设置
<span class="token punctuation">;</span><span class="token assign-left variable">port</span><span class="token operator">=</span><span class="token number">127.0</span>.0.1:9001        <span class="token punctuation">;</span> 这个是侦听的IP和端口，侦听所有IP用 :9001或*:9001。这个必须设置，只要上面的<span class="token punctuation">[</span>inet_http_server<span class="token punctuation">]</span>开启了，就必须设置它
<span class="token punctuation">;</span><span class="token assign-left variable">username</span><span class="token operator">=</span>user              <span class="token punctuation">;</span> 这个和上面的uinx_http_server一个样。非必须设置
<span class="token punctuation">;</span><span class="token assign-left variable">password</span><span class="token operator">=</span><span class="token number">123</span>               <span class="token punctuation">;</span> 这个也一个样。非必须设置
</code></pre> 
<p>3.[supervisord]</p> 
<pre><code class="prism language-bash"><span class="token punctuation">[</span>supervisord<span class="token punctuation">]</span>                <span class="token punctuation">;</span>这个主要是定义supervisord这个服务端进程的一些参数的这个必须设置，不设置，supervisor就不用干活了
<span class="token assign-left variable">logfile</span><span class="token operator">=</span>/tmp/supervisord.log <span class="token punctuation">;</span> 这个是supervisord这个主进程的日志路径，注意和子进程的日志不搭嘎。默认路径<span class="token variable">$CWD</span>/supervisord.log，<span class="token variable">$CWD</span>是当前目录。。非必须设置
<span class="token assign-left variable">logfile_maxbytes</span><span class="token operator">=</span>50MB        <span class="token punctuation">;</span> 这个是上面那个日志文件的最大的大小，当超过50M的时候，会生成一个新的日志文件。当设置为0时，表示不限制文件大小默认值是50M，非必须设置。              
<span class="token assign-left variable">logfile_backups</span><span class="token operator">=</span><span class="token number">10</span>           <span class="token punctuation">;</span> 日志文件保持的数量，supervisor在启动程序时，会自动创建10个buckup文件，用于log rotate 当设置为0时，表示不限制文件的数量。默认情况下为10。。。非必须设置
<span class="token assign-left variable">loglevel</span><span class="token operator">=</span>info                <span class="token punctuation">;</span> 日志级别，有critical, error, warn, info, debug, trace, or blather等默认为info。。。非必须设置项
<span class="token assign-left variable">pidfile</span><span class="token operator">=</span>/tmp/supervisord.pid <span class="token punctuation">;</span> supervisord的pid文件路径。默认为<span class="token variable">$CWD</span>/supervisord.pid。。。非必须设置
<span class="token assign-left variable">nodaemon</span><span class="token operator">=</span>false               <span class="token punctuation">;</span> 如果是true，supervisord进程将在前台运行默认为false，也就是后台以守护进程运行。。。非必须设置
<span class="token assign-left variable">minfds</span><span class="token operator">=</span><span class="token number">1024</span>                  <span class="token punctuation">;</span> 这个是最少系统空闲的文件描述符，低于这个值supervisor将不会启动。系统的文件描述符在这里设置cat /proc/sys/fs/file-max默认情况下为1024。。。非必须设置
<span class="token assign-left variable">minprocs</span><span class="token operator">=</span><span class="token number">200</span>                 <span class="token punctuation">;</span> 最小可用的进程描述符，低于这个值supervisor也将不会正常启动。ulimit  -u这个命令，可以查看linux下面用户的最大进程数默认为200。。。非必须设置
<span class="token punctuation">;</span><span class="token assign-left variable">umask</span><span class="token operator">=</span>022                   <span class="token punctuation">;</span> 进程创建文件的掩码默认为022。。非必须设置项
<span class="token punctuation">;</span><span class="token assign-left variable">user</span><span class="token operator">=</span>chrism                 <span class="token punctuation">;</span> 这个参数可以设置一个非root用户，当我们以root用户启动supervisord之后。我这里面设置的这个用户，也可以对supervisord进行管理默认情况是不设置。。。非必须设置项
<span class="token punctuation">;</span><span class="token assign-left variable">identifier</span><span class="token operator">=</span>supervisor       <span class="token punctuation">;</span> 这个参数是supervisord的标识符，主要是给XML_RPC用的。当你有多个supervisor的时候，而且想调用XML_RPC统一管理，就需要为每个supervisor设置不同的标识符了默认是supervisord。。。非必需设置
<span class="token punctuation">;</span><span class="token assign-left variable">directory</span><span class="token operator">=</span>/tmp              <span class="token punctuation">;</span> 这个参数是当supervisord作为守护进程运行的时候，设置这个参数的话，启动supervisord进程之前，会先切换到这个目录默认不设置。。。非必须设置
<span class="token punctuation">;</span><span class="token assign-left variable">nocleanup</span><span class="token operator">=</span>true              <span class="token punctuation">;</span> 这个参数当为false的时候，会在supervisord进程启动的时候，把以前子进程产生的日志文件<span class="token punctuation">(</span>路径为AUTO的情况下<span class="token punctuation">)</span>清除掉。有时候咱们想要看历史日志，当 然不想日志被清除了。所以可以设置为true默认是false，有调试需求的同学可以设置为true。。。非必须设置
<span class="token punctuation">;</span><span class="token assign-left variable">childlogdir</span><span class="token operator">=</span>/tmp            <span class="token punctuation">;</span> 当子进程日志路径为AUTO的时候，子进程日志文件的存放路径。默认路径是这个东西，执行下面的这个命令看看就OK了，处理的东西就默认路径 python -c <span class="token string">"import tempfile;print tempfile.gettempdir()"</span>非必须设置
<span class="token punctuation">;</span><span class="token assign-left variable">environment</span><span class="token operator">=</span>KEY<span class="token operator">=</span><span class="token string">"value"</span>     <span class="token punctuation">;</span> 这个是用来设置环境变量的，supervisord在linux中启动默认继承了linux的环境变量，在这里可以设置supervisord进程特有的其他环境变量。supervisord启动子进程时，子进程会拷贝父进程的内存空间内容。 所以设置的这些环境变量也会被子进程继承。小例子：environment<span class="token operator">=</span>name<span class="token operator">=</span><span class="token string">"haha"</span>,age<span class="token operator">=</span><span class="token string">"hehe"</span>默认为不设置。。。非必须设置
<span class="token punctuation">;</span><span class="token assign-left variable">strip_ansi</span><span class="token operator">=</span>false            <span class="token punctuation">;</span> 这个选项如果设置为true，会清除子进程日志中的所有ANSI 序列。什么是ANSI序列呢？就是我们的<span class="token punctuation">\</span>n,<span class="token punctuation">\</span>t这些东西。默认为false。。。非必须设置

<span class="token punctuation">;</span> the below section must remain <span class="token keyword">in</span> the config <span class="token function">file</span> <span class="token keyword">for</span> RPC
<span class="token punctuation">;</span> <span class="token punctuation">(</span>supervisorctl/web interface<span class="token punctuation">)</span> to work, additional interfaces may be
<span class="token punctuation">;</span> added by defining them <span class="token keyword">in</span> separate rpcinterface: sections
<span class="token punctuation">[</span>rpcinterface:supervisor<span class="token punctuation">]</span>    <span class="token punctuation">;</span>这个选项是给XML_RPC用的，当然你如果想使用supervisord或者web server 这个选项必须要开启的
supervisor.rpcinterface_factory <span class="token operator">=</span> supervisor.rpcinterface:make_main_rpcinterface 



</code></pre> 
<p>4.[supervisorctl]</p> 
<pre><code class="prism language-bash"><span class="token punctuation">[</span>supervisorctl<span class="token punctuation">]</span>              <span class="token punctuation">;</span>这个主要是针对supervisorctl的一些配置  
<span class="token assign-left variable">serverurl</span><span class="token operator">=</span>unix:///tmp/supervisor.sock <span class="token punctuation">;</span> 这个是supervisorctl本地连接supervisord的时候，本地UNIX socket
路径，注意这个是和前面的<span class="token punctuation">[</span>unix_http_server<span class="token punctuation">]</span>对应的默认值就是unix:///tmp/supervisor.sock。。非必须设置
<span class="token punctuation">;</span><span class="token assign-left variable">serverurl</span><span class="token operator">=</span>http://127.0.0.1:9001 <span class="token punctuation">;</span> 这个是supervisorctl远程连接supervisord的时候，用到的TCP socket路径注意这个和前面的<span class="token punctuation">[</span>inet_http_server<span class="token punctuation">]</span>对应默认就是http://127.0.0.1:9001。。。非必须项
<span class="token punctuation">;</span><span class="token assign-left variable">username</span><span class="token operator">=</span>chris              <span class="token punctuation">;</span> 用户名默认空。。非必须设置
<span class="token punctuation">;</span><span class="token assign-left variable">password</span><span class="token operator">=</span><span class="token number">123</span>                <span class="token punctuation">;</span> 密码默认空。。非必须设置
<span class="token punctuation">;</span><span class="token assign-left variable">prompt</span><span class="token operator">=</span>mysupervisor         <span class="token punctuation">;</span> 输入用户名密码时候的提示符默认supervisor。。非必须设置
<span class="token punctuation">;</span><span class="token assign-left variable">history_file</span><span class="token operator">=</span>~/.sc_history  <span class="token punctuation">;</span> 这个参数和shell中的history类似，我们可以用上下键来查找前面执行过的命令默认是no file的。。所以我们想要有这种功能，必须指定一个文件。。。非必须设置

<span class="token punctuation">;</span> The below sample program section shows all possible program subsection values,
<span class="token punctuation">;</span> create one or <span class="token function">more</span> <span class="token string">'real'</span> program: sections to be able to control them under
<span class="token punctuation">;</span> supervisor.
</code></pre> 
<p>5.[program:theprogramname]</p> 
<pre><code class="prism language-bash">
<span class="token punctuation">;</span><span class="token punctuation">[</span>program:theprogramname<span class="token punctuation">]</span>      <span class="token punctuation">;</span>这个就是咱们要管理的子进程了，<span class="token string">":"</span>后面的是名字，最好别乱写和实际进程有点关联最好。这样的program我们可以设置一个或多个，一个program就是要被管理的一个进程
<span class="token punctuation">;</span><span class="token assign-left variable">command</span><span class="token operator">=</span>/bin/cat              <span class="token punctuation">;</span> 这个就是我们的要启动进程的命令路径了，可以带参数例子：/home/test.py -a <span class="token string">'hehe'</span>有一点需要注意的是，我们的command只能是那种在终端运行的进程，不能是守护进程。这个想想也知道了，比如说command<span class="token operator">=</span>service httpd start。httpd这个进程被linux的service管理了，我们的supervisor再去启动这个命令这已经不是严格意义的子进程了。这个是个必须设置的项
<span class="token punctuation">;</span><span class="token assign-left variable">process_name</span><span class="token operator">=</span>%<span class="token punctuation">(</span>program_name<span class="token punctuation">)</span>s <span class="token punctuation">;</span> 这个是进程名，如果我们下面的numprocs参数为1的话，就不用管这个参数了，它默认值%<span class="token punctuation">(</span>program_name<span class="token punctuation">)</span>s也就是上面的那个program冒号后面的名字，但是如果numprocs为多个的话，那就不能这么干了。想想也知道，不可能每个进程都用同一个进程名吧。

                                
<span class="token punctuation">;</span><span class="token assign-left variable">numprocs</span><span class="token operator">=</span><span class="token number">1</span>                    <span class="token punctuation">;</span> 启动进程的数目。当不为1时，就是进程池的概念，注意process_name的设置默认为1    。。非必须设置
<span class="token punctuation">;</span><span class="token assign-left variable">directory</span><span class="token operator">=</span>/tmp                <span class="token punctuation">;</span> 进程运行前，会前切换到这个目录默认不设置。。。非必须设置
<span class="token punctuation">;</span><span class="token assign-left variable">umask</span><span class="token operator">=</span>022                     <span class="token punctuation">;</span> 进程掩码，默认none，非必须
<span class="token punctuation">;</span><span class="token assign-left variable">priority</span><span class="token operator">=</span><span class="token number">999</span>                  <span class="token punctuation">;</span> 子进程启动关闭优先级，优先级低的，最先启动，关闭的时候最后关闭默认值为999 。。非必须设置
<span class="token punctuation">;</span><span class="token assign-left variable">autostart</span><span class="token operator">=</span>true                <span class="token punctuation">;</span> 如果是true的话，子进程将在supervisord启动后被自动启动默认就是true   。。非必须设置
<span class="token punctuation">;</span><span class="token assign-left variable">autorestart</span><span class="token operator">=</span>unexpected        <span class="token punctuation">;</span> 这个是设置子进程挂掉后自动重启的情况，有三个选项，false,unexpected和true。如果为false的时候，无论什么情况下，都不会被重新启动，如果为unexpected，只有当进程的退出码不在下面的exitcodes里面定义的退 出码的时候，才会被自动重启。当为true的时候，只要子进程挂掉，将会被无条件的重启
<span class="token punctuation">;</span><span class="token assign-left variable">startsecs</span><span class="token operator">=</span><span class="token number">1</span>                   <span class="token punctuation">;</span> 这个选项是子进程启动多少秒之后，此时状态如果是running，则我们认为启动成功了默认值为1 。。非必须设置
<span class="token punctuation">;</span><span class="token assign-left variable">startretries</span><span class="token operator">=</span><span class="token number">3</span>                <span class="token punctuation">;</span> 当进程启动失败后，最大尝试启动的次数。。当超过3次后，supervisor将把此进程的状态置为FAIL默认值为3 。。非必须设置
<span class="token punctuation">;</span><span class="token assign-left variable">exitcodes</span><span class="token operator">=</span><span class="token number">0,2</span>                 <span class="token punctuation">;</span> 注意和上面的的autorestart<span class="token operator">=</span>unexpected对应。。exitcodes里面的定义的退出码是expected的。
<span class="token punctuation">;</span><span class="token assign-left variable">stopsignal</span><span class="token operator">=</span>QUIT               <span class="token punctuation">;</span> 进程停止信号，可以为<span class="token environment constant">TERM</span>, HUP, INT, QUIT, KILL, USR1, or USR2等信号默认为<span class="token environment constant">TERM</span> 。。当用设定的信号去干掉进程，退出码会被认为是expected非必须设置
<span class="token punctuation">;</span><span class="token assign-left variable">stopwaitsecs</span><span class="token operator">=</span><span class="token number">10</span>               <span class="token punctuation">;</span> 这个是当我们向子进程发送stopsignal信号后，到系统返回信息给supervisord，所等待的最大时间。 超过这个时间，supervisord会向该子进程发送一个强制kill的信号。默认为10秒。。非必须设置
<span class="token punctuation">;</span><span class="token assign-left variable">stopasgroup</span><span class="token operator">=</span>false             <span class="token punctuation">;</span> 这个东西主要用于，supervisord管理的子进程，这个子进程本身还有子进程。那么我们如果仅仅干掉supervisord的子进程的话，子进程的子进程有可能会变成孤儿进程。所以咱们可以设置可个选项，把整个该子进程的整个进程组都干掉。 设置为true的话，一般killasgroup也会被设置为true。需要注意的是，该选项发送的是stop信号默认为false。。非必须设置。。
<span class="token punctuation">;</span><span class="token assign-left variable">killasgroup</span><span class="token operator">=</span>false             <span class="token punctuation">;</span> 这个和上面的stopasgroup类似，不过发送的是kill信号
<span class="token punctuation">;</span><span class="token assign-left variable">user</span><span class="token operator">=</span>chrism                   <span class="token punctuation">;</span> 如果supervisord是root启动，我们在这里设置这个非root用户，可以用来管理该program默认不设置。。。非必须设置项
<span class="token punctuation">;</span><span class="token assign-left variable">redirect_stderr</span><span class="token operator">=</span>true          <span class="token punctuation">;</span> 如果为true，则stderr的日志会被写入stdout日志文件中默认为false，非必须设置
<span class="token punctuation">;</span><span class="token assign-left variable">stdout_logfile</span><span class="token operator">=</span>/a/path        <span class="token punctuation">;</span> 子进程的stdout的日志路径，可以指定路径，AUTO，none等三个选项。设置为none的话，将没有日志产生。设置为AUTO的话，将随机找一个地方生成日志文件，而且当supervisord重新启动的时候，以前的日志文件会被清空。当 <span class="token assign-left variable">redirect_stderr</span><span class="token operator">=</span>true的时候，sterr也会写进这个日志文件
<span class="token punctuation">;</span><span class="token assign-left variable">stdout_logfile_maxbytes</span><span class="token operator">=</span>1MB   <span class="token punctuation">;</span> 日志文件最大大小，和<span class="token punctuation">[</span>supervisord<span class="token punctuation">]</span>中定义的一样。默认为50
<span class="token punctuation">;</span><span class="token assign-left variable">stdout_logfile_backups</span><span class="token operator">=</span><span class="token number">10</span>     <span class="token punctuation">;</span> 和<span class="token punctuation">[</span>supervisord<span class="token punctuation">]</span>定义的一样。默认10
<span class="token punctuation">;</span><span class="token assign-left variable">stdout_capture_maxbytes</span><span class="token operator">=</span>1MB   <span class="token punctuation">;</span> 这个东西是设定capture管道的大小，当值不为0的时候，子进程可以从stdout发送信息，而supervisor可以根据信息，发送相应的event。默认为0，为0的时候表达关闭管道。。。非必须项
<span class="token punctuation">;</span><span class="token assign-left variable">stdout_events_enabled</span><span class="token operator">=</span>false   <span class="token punctuation">;</span> 当设置为ture的时候，当子进程由stdout向文件描述符中写日志的时候，将触发supervisord发送PROCESS_LOG_STDOUT类型的event默认为false。。。非必须设置
<span class="token punctuation">;</span><span class="token assign-left variable">stderr_logfile</span><span class="token operator">=</span>/a/path        <span class="token punctuation">;</span> 这个东西是设置stderr写的日志路径，当redirect_stderr<span class="token operator">=</span>true。这个就不用设置了，设置了也是白搭。因为它会被写入stdout_logfile的同一个文件中默认为AUTO，也就是随便找个地存，supervisord重启被清空。。非必须设置
<span class="token punctuation">;</span><span class="token assign-left variable">stderr_logfile_maxbytes</span><span class="token operator">=</span>1MB   <span class="token punctuation">;</span> 这个出现好几次了，就不重复了
<span class="token punctuation">;</span><span class="token assign-left variable">stderr_logfile_backups</span><span class="token operator">=</span><span class="token number">10</span>     <span class="token punctuation">;</span> 这个也是
<span class="token punctuation">;</span><span class="token assign-left variable">stderr_capture_maxbytes</span><span class="token operator">=</span>1MB   <span class="token punctuation">;</span> 这个一样，和stdout_capture一样。 默认为0，关闭状态
<span class="token punctuation">;</span><span class="token assign-left variable">stderr_events_enabled</span><span class="token operator">=</span>false   <span class="token punctuation">;</span> 这个也是一样，默认为false
<span class="token punctuation">;</span><span class="token assign-left variable">environment</span><span class="token operator">=</span>A<span class="token operator">=</span><span class="token string">"1"</span>,B<span class="token operator">=</span><span class="token string">"2"</span>       <span class="token punctuation">;</span> 这个是该子进程的环境变量，和别的子进程是不共享的
<span class="token punctuation">;</span><span class="token assign-left variable">serverurl</span><span class="token operator">=</span>AUTO                <span class="token punctuation">;</span> 

<span class="token punctuation">;</span> The below sample eventlistener section shows all possible
<span class="token punctuation">;</span> eventlistener subsection values, create one or <span class="token function">more</span> <span class="token string">'real'</span>
<span class="token punctuation">;</span> eventlistener: sections to be able to handle event notifications
<span class="token punctuation">;</span> sent by supervisor.
</code></pre> 
<p>6.[eventlistener:theeventlistenername]</p> 
<pre><code class="prism language-bash"><span class="token punctuation">;</span><span class="token punctuation">[</span>eventlistener:theeventlistenername<span class="token punctuation">]</span> <span class="token punctuation">;</span>这个东西其实和program的地位是一样的，也是suopervisor启动的子进程，不过它干的活是订阅supervisord发送的event。他的名字就叫listener了。我们可以在listener里面做一系列处理，比如报警等等
<span class="token punctuation">;</span><span class="token assign-left variable">command</span><span class="token operator">=</span>/bin/eventlistener    <span class="token punctuation">;</span> 这个和上面的program一样，表示listener的可执行文件的路径
<span class="token punctuation">;</span><span class="token assign-left variable">process_name</span><span class="token operator">=</span>%<span class="token punctuation">(</span>program_name<span class="token punctuation">)</span>s <span class="token punctuation">;</span> 这个也一样，进程名，当下面的numprocs为多个的时候，才需要。否则默认就OK了
<span class="token punctuation">;</span><span class="token assign-left variable">numprocs</span><span class="token operator">=</span><span class="token number">1</span>                    <span class="token punctuation">;</span> 相同的listener启动的个数
<span class="token punctuation">;</span><span class="token assign-left variable">events</span><span class="token operator">=</span>EVENT                  <span class="token punctuation">;</span> event事件的类型，也就是说，只有写在这个地方的事件类型。才会被发送
<span class="token punctuation">;</span><span class="token assign-left variable">buffer_size</span><span class="token operator">=</span><span class="token number">10</span>                <span class="token punctuation">;</span> 这个是event队列缓存大小，单位不太清楚，楼主猜测应该是个吧。当buffer超过10的时候，最旧的event将会被清除，并把新的event放进去。默认值为10。。非必须选项
<span class="token punctuation">;</span><span class="token assign-left variable">directory</span><span class="token operator">=</span>/tmp                <span class="token punctuation">;</span> 进程执行前，会切换到这个目录下执行默认为不切换。。。非必须
<span class="token punctuation">;</span><span class="token assign-left variable">umask</span><span class="token operator">=</span>022                     <span class="token punctuation">;</span> 淹没，默认为none，不说了
<span class="token punctuation">;</span><span class="token assign-left variable">priority</span><span class="token operator">=</span>-1                   <span class="token punctuation">;</span> 启动优先级，默认-1，也不扯了
<span class="token punctuation">;</span><span class="token assign-left variable">autostart</span><span class="token operator">=</span>true                <span class="token punctuation">;</span> 是否随supervisord启动一起启动，默认true
<span class="token punctuation">;</span><span class="token assign-left variable">autorestart</span><span class="token operator">=</span>unexpected        <span class="token punctuation">;</span> 是否自动重启，和program一个样，分true,false,unexpected等，注意unexpected和exitcodes的关系
<span class="token punctuation">;</span><span class="token assign-left variable">startsecs</span><span class="token operator">=</span><span class="token number">1</span>                   <span class="token punctuation">;</span> 也是一样，进程启动后跑了几秒钟，才被认定为成功启动，默认1
<span class="token punctuation">;</span><span class="token assign-left variable">startretries</span><span class="token operator">=</span><span class="token number">3</span>                <span class="token punctuation">;</span> 失败最大尝试次数，默认3
<span class="token punctuation">;</span><span class="token assign-left variable">exitcodes</span><span class="token operator">=</span><span class="token number">0,2</span>                 <span class="token punctuation">;</span> 期望或者说预料中的进程退出码，
<span class="token punctuation">;</span><span class="token assign-left variable">stopsignal</span><span class="token operator">=</span>QUIT               <span class="token punctuation">;</span> 干掉进程的信号，默认为<span class="token environment constant">TERM</span>，比如设置为QUIT，那么如果QUIT来干这个进程那么会被认为是正常维护，退出码也被认为是expected中的
<span class="token punctuation">;</span><span class="token assign-left variable">stopwaitsecs</span><span class="token operator">=</span><span class="token number">10</span>               <span class="token punctuation">;</span> max num secs to <span class="token function">wait</span> b4 SIGKILL <span class="token punctuation">(</span>default <span class="token number">10</span><span class="token punctuation">)</span>
<span class="token punctuation">;</span><span class="token assign-left variable">stopasgroup</span><span class="token operator">=</span>false             <span class="token punctuation">;</span> send stop signal to the UNIX process group <span class="token punctuation">(</span>default <span class="token boolean">false</span><span class="token punctuation">)</span>
<span class="token punctuation">;</span><span class="token assign-left variable">killasgroup</span><span class="token operator">=</span>false             <span class="token punctuation">;</span> SIGKILL the UNIX process group <span class="token punctuation">(</span>def <span class="token boolean">false</span><span class="token punctuation">)</span>
<span class="token punctuation">;</span><span class="token assign-left variable">user</span><span class="token operator">=</span>chrism                   <span class="token punctuation">;</span>设置普通用户，可以用来管理该listener进程。默认为空。。非必须设置
<span class="token punctuation">;</span><span class="token assign-left variable">redirect_stderr</span><span class="token operator">=</span>true          <span class="token punctuation">;</span> 为true的话，stderr的log会并入stdout的log里面默认为false。。。非必须设置
<span class="token punctuation">;</span><span class="token assign-left variable">stdout_logfile</span><span class="token operator">=</span>/a/path        
<span class="token punctuation">;</span><span class="token assign-left variable">stdout_logfile_maxbytes</span><span class="token operator">=</span>1MB   
<span class="token punctuation">;</span><span class="token assign-left variable">stdout_logfile_backups</span><span class="token operator">=</span><span class="token number">10</span>     
<span class="token punctuation">;</span><span class="token assign-left variable">stdout_events_enabled</span><span class="token operator">=</span>false   <span class="token punctuation">;</span> 这个其实是错的，listener是不能发送event
<span class="token punctuation">;</span><span class="token assign-left variable">stderr_logfile</span><span class="token operator">=</span>/a/path        
<span class="token punctuation">;</span><span class="token assign-left variable">stderr_logfile_maxbytes</span><span class="token operator">=</span>1MB   
<span class="token punctuation">;</span>stderr_logfile_backups
<span class="token punctuation">;</span><span class="token assign-left variable">stderr_events_enabled</span><span class="token operator">=</span>false   <span class="token punctuation">;</span> 这个也是错的，listener不能发送event
<span class="token punctuation">;</span><span class="token assign-left variable">environment</span><span class="token operator">=</span>A<span class="token operator">=</span><span class="token string">"1"</span>,B<span class="token operator">=</span><span class="token string">"2"</span>       <span class="token punctuation">;</span> 这个是该子进程的环境变量默认为空。。。非必须设置
<span class="token punctuation">;</span><span class="token assign-left variable">serverurl</span><span class="token operator">=</span>AUTO                <span class="token punctuation">;</span> override serverurl computation <span class="token punctuation">(</span>childutils<span class="token punctuation">)</span>

<span class="token punctuation">;</span> The below sample group section shows all possible group values,
<span class="token punctuation">;</span> create one or <span class="token function">more</span> <span class="token string">'real'</span> group: sections to create <span class="token string">"heterogeneous"</span>
<span class="token punctuation">;</span> process groups.
</code></pre> 
<p>7.[group:thegroupname]</p> 
<pre><code class="prism language-bash"><span class="token punctuation">;</span><span class="token punctuation">[</span>group:thegroupname<span class="token punctuation">]</span>  <span class="token punctuation">;</span>这个东西就是给programs分组，划分到组里面的program。我们就不用一个一个去操作了我们可以对组名进行统一的操作。 注意：program被划分到组里面之后，就相当于原来的配置从supervisor的配置文件里消失了。。。supervisor只会对组进行管理，而不再会对组里面的单个program进行管理了
<span class="token punctuation">;</span><span class="token assign-left variable">programs</span><span class="token operator">=</span>progname1,progname2  <span class="token punctuation">;</span> 组成员，用逗号分开这个是个必须的设置项
<span class="token punctuation">;</span><span class="token assign-left variable">priority</span><span class="token operator">=</span><span class="token number">999</span>                  <span class="token punctuation">;</span> 优先级，相对于组和组之间说的默认999。。非必须选项

<span class="token punctuation">;</span> The <span class="token punctuation">[</span>include<span class="token punctuation">]</span> section can just contain the <span class="token string">"files"</span> setting.  This
<span class="token punctuation">;</span> setting can list multiple files <span class="token punctuation">(</span>separated by whitespace or
<span class="token punctuation">;</span> newlines<span class="token punctuation">)</span>.  It can also contain wildcards.  The filenames are
<span class="token punctuation">;</span> interpreted as relative to this file.  Included files *cannot*
<span class="token punctuation">;</span> include files themselves.
</code></pre> 
<p>8.[include]</p> 
<pre><code class="prism language-bash">
<span class="token punctuation">;</span><span class="token punctuation">[</span>include<span class="token punctuation">]</span>   <span class="token punctuation">;</span>这个东西挺有用的，当我们要管理的进程很多的时候，写在一个文件里面就有点大了。我们可以把配置信息写到多个文件中，然后include过来
<span class="token punctuation">;</span>files <span class="token operator">=</span> relative/directory/*.ini
OK,上面提到的非必须设置项，一般来说，都是有默认值的，可以根据自己的需要去设置。。。如果不设置的，supervisor也能用起来.

</code></pre> 
<blockquote> 
 <p>原文地址：https://www.cnblogs.com/axinno1/p/14617780.html</p> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/94219647bc6787148437a8f91bf5a6a4/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">跨域解决方法 &amp;简单请求 &amp; 非简单请求</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/78de7c70dd4e801d12e97a5b0b8e9cfb/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">浅谈智能推荐</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>