<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Socket用法详解 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Socket用法详解" />
<meta property="og:description" content="一、构造Socket Socket的构造方法有以下几种重载形式： （1）Socket() （2）Socket(InetAddress address, int port)throws UnknownHostException,IOException （3）Socket(InetAddress address, int port, InetAddress localAddr, int localPort)throws IOException （4）Socket(String host, int port) throws UnknownHostException,IOException （5）Socket(String host, int port, InetAddress localAddr, int localPort) throws IOException 各构造方法的用法如下： 1. 设定等待建立连接的超时时间： Socket socket=new Socket(); SocketAddress remoteAddr=new InetSocketAddress(&#34;localhost&#34;,8000); //等待建立连接的超时时间为1分钟 socket.connect(remoteAddr, 60000); 2. 设定服务器的地址： Socket(InetAddress address, int port) Socket(String host, int port) InetAddress类表示IP地址，其用法如下： //返回本地主机的IP地址 InetAddress addr1=InetAddress.getLocalHost(); //返回代表&#34;222.34.5.7&#34;的IP地址 InetAddress addr2=InetAddress.getByName(&#34;222.34.5.7&#34;); //返回域名为&#34;www.javathinker.org&#34;的IP地址 InetAddress addr3=InetAddress.getByName(&#34;www.javathinker.org&#34;); 3. 设定客户端的地址： 在一个Socket对象中，既包含远程服务器的IP地址和端口信息，也包含本地客户端的IP地址和端口信息。默认情况下，客户端的IP地址来自于客户程序所在的主机，客户端的端口则由操作系统随机分配。Socket类还有两个构造方法允许显式的设置客户端的IP地址和端口： Socket(InetAddress address, int port, InetAddress localAddr, int localPort )throws IOException Socket(String host, int port, InetAddress localAddr, int localPort ) throws IOException 4." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/fe93312d337d64a3fab4682f21927b1b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2010-07-08T16:56:00+08:00" />
<meta property="article:modified_time" content="2010-07-08T16:56:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Socket用法详解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h6><span style="font-size: small;">一、构造Socket</span> </h6> 
<p><span style="font-size: small;">Socket的构造方法有以下几种重载形式：</span> </p> 
<p><span style="font-size: small;">（1）Socket()</span> </p> 
<p><span style="font-size: small;">（2）Socket(InetAddress address, int port)throws UnknownHostException,IOException</span> </p> 
<p><span style="font-size: small;">（3）Socket(InetAddress address, int port, InetAddress localAddr, int localPort)throws IOException</span> </p> 
<p><span style="font-size: small;">（4）Socket(String host, int port) throws UnknownHostException,IOException</span> </p> 
<p><span style="font-size: small;">（5）Socket(String host, int port, InetAddress localAddr, int localPort) throws IOException</span> </p> 
<p><span style="font-size: small;">各构造方法的用法如下：</span> </p> 
<p><span style="font-size: small;">1. 设定等待建立连接的超时时间： </span> </p> 
<table border="1" cellspacing="0" cellpadding="0"><tbody><tr><td width="608"> <p><span style="font-size: small;">Socket socket=new Socket();</span> </p> <p><span style="font-size: small;">SocketAddress remoteAddr=new InetSocketAddress("localhost",8000);</span> </p> <p><span style="font-size: small;">//等待建立连接的超时时间为1分钟</span> </p> <p><span style="font-size: small;">socket.connect(remoteAddr, 60000);</span> </p> </td></tr></tbody></table> 
<p></p> 
<p><span style="font-size: small;">2. 设定服务器的地址：</span> </p> 
<p><span style="font-size: small;">Socket(InetAddress address, int port)</span> </p> 
<p><span style="font-size: small;">Socket(String host, int port) </span> </p> 
<table border="1" cellspacing="0" cellpadding="0"><tbody><tr><td width="608"> <p><span style="font-size: small;">InetAddress类表示IP地址，其用法如下：</span> </p> <p><span style="font-size: small;">//返回本地主机的IP地址</span> </p> <p><span style="font-size: small;">InetAddress addr1=InetAddress.getLocalHost();</span> </p> <p><span style="font-size: small;">//返回代表"222.34.5.7"的IP地址</span> </p> <p><span style="font-size: small;">InetAddress addr2=InetAddress.getByName("222.34.5.7");</span> </p> <p><span style="font-size: small;">//返回域名为"www.javathinker.org"的IP地址</span> </p> <p><span style="font-size: small;">InetAddress addr3=InetAddress.getByName("www.javathinker.org");</span> </p> </td></tr></tbody></table> 
<p></p> 
<p><span style="font-size: small;">3. 设定客户端的地址：</span> </p> 
<p><span style="font-size: small;">在一个Socket对象中，既包含远程服务器的IP地址和端口信息，也包含本地客户端的IP地址和端口信息。默认情况下，客户端的IP地址来自于客户程序所在的主机，客户端的端口则由操作系统随机分配。Socket类还有两个构造方法允许显式的设置客户端的IP地址和端口： </span> </p> 
<table border="1" cellspacing="0" cellpadding="0"><tbody><tr><td width="608"> <p><span style="font-size: small;">Socket(InetAddress address, int port,<strong> InetAddress localAddr, int localPort</strong> )throws IOException</span> </p> <p><span style="font-size: small;">Socket(String host, int port,<strong> InetAddress localAddr, int localPort</strong> ) throws IOException</span> </p> </td></tr></tbody></table> 
<p></p> 
<p><span style="font-size: small;">4. 客户连接服务器时可能抛出的异常：</span> </p> 
<p><span style="font-size: small;">当Socket的构造方法请求连接服务器时，可能会抛出以下异常：</span> </p> 
<p><span style="font-size: small;">l UnknownHostException：如果无法识别主机的名字或IP地址，就会抛出这种异常。</span> </p> 
<p><span style="font-size: small;">l ConnectException：如果没有服务器进程监听指定的端口，或者服务器进程拒绝连接，就会抛出这种异常。</span> </p> 
<p><span style="font-size: small;">l SocketTimeoutException：如果等待连接超时，就会抛出这种异常。</span> </p> 
<p><span style="font-size: small;">l BindException：如果无法把Socket对象与指定的本地IP地址或端口绑定，就会抛出这种异常。</span> </p> 
<h6><span style="font-size: small;">二、获取Socket的信息</span> </h6> 
<p><span style="font-size: small;">以下方法用于获取Socket的有关信息：</span> </p> 
<p><span style="font-size: small;">l getInetAddress()：获得远程服务器的IP地址。</span> </p> 
<p><span style="font-size: small;">l getPort()：获得远程服务器的端口。</span> </p> 
<p><span style="font-size: small;">l getLocalAddress()：获得客户本地的IP地址。</span> </p> 
<p><span style="font-size: small;">l getLocalPort()：获得客户本地的端口。</span> </p> 
<p><span style="font-size: small;">l getInputStream()：获得输入流。如果Socket还没有连接，或者已经关闭，或者已经通过shutdownInput()方法关闭输入流，那么此方法会抛出IOException。</span> </p> 
<p><span style="font-size: small;">l getOutputStream()：获得输出流。如果Socket还没有连接，或者已经关闭，或者已经通过shutdownOutput()方法关闭输出流，那么此方法会抛出IOException。</span> </p> 
<h6><span style="font-size: small;">三、关闭Socket</span> </h6> 
<p><span style="font-size: small;">1. 当客户与服务器的通信结束，应该及时关闭Socket，以释放Socket占用的包括端口在内的各种资源。Socket的close()方法负责关闭Socket。推荐代码如下： </span> </p> 
<table border="1" cellspacing="0" cellpadding="0"><tbody><tr><td width="608"> <p><span style="font-size: small;">Socket socket=<strong>null</strong> ;</span> </p> <p><span style="font-size: small;"><strong>try</strong> {<!-- --></span> </p> <p><span style="font-size: small;">socket=<strong>new</strong> Socket("www.javathinker.org",80);</span> </p> <p><span style="font-size: small;">//执行接收和发送数据的操作</span> </p> <p><span style="font-size: small;"><span style="text-decoration: underline;">…</span> </span> </p> <p><span style="font-size: small;">}<strong>catch</strong> (IOException e){<!-- --></span> </p> <p><span style="font-size: small;">e.printStackTrace();</span> </p> <p><span style="font-size: small;">}<strong>finally</strong> {<!-- --></span> </p> <p><span style="font-size: small;"><strong>try</strong> {<!-- --></span> </p> <p><span style="font-size: small;"><strong>if</strong> <strong>(socket!=</strong> <strong>null</strong> <strong>)socket.close();</strong> </span> </p> <p><span style="font-size: small;">}<strong>catch</strong> (IOException e){e.printStackTrace();}</span> </p> <p><span style="font-size: small;"><span style="text-decoration: underline;">}</span> </span> </p> </td></tr></tbody></table> 
<p></p> 
<p><span style="font-size: small;">2. Socket类提供了三个状态测试方法：</span> </p> 
<p><span style="font-size: small;">l isClosed()</span> </p> 
<p><span style="font-size: small;">l isConnected()</span> </p> 
<p><span style="font-size: small;">l isBound()</span> </p> 
<p><span style="font-size: small;">3. 如果要判断一个Socket对象当前是否处于连接状态，可采用以下方式： </span> </p> 
<table border="1" cellspacing="0" cellpadding="0"><tbody><tr><td width="664"> <p><span style="font-size: small;">boolean isConnected=socket.isConnected() &amp;&amp; !socket.isClosed();</span> </p> </td></tr></tbody></table> 
<p></p> 
<h6><span style="font-size: small;">四、半关闭Socket</span> </h6> 
<p><span style="font-size: small;">1. 有的时候，可能仅仅希望关闭输出流或输入流之一。此时可以采用Socket类提供的半关闭方法：</span> </p> 
<p><span style="font-size: small;">l shutdownInput()：关闭输入流。</span> </p> 
<p><span style="font-size: small;">l shutdownOutput(): 关闭输出流。</span> </p> 
<p><span style="font-size: small;">2. 先后调用Socket的shutdownInput()和shutdownOutput()方法，仅仅关闭了输入流和输出流，并不等价于调用Socket的close()方法。在通信结束后，仍然要调用Socket的close()方法，因为只有该方法才会释放Socket占用的资源，比如占用的本地端口等。</span> </p> 
<p><span style="font-size: small;">3. Socket类还提供了两个状态测试方法，用来判断输入流和输出流是否关闭：</span> </p> 
<p><span style="font-size: small;">l public boolean isInputShutdown()</span> </p> 
<p><span style="font-size: small;">l public boolean isOutputShutdown()</span> </p> 
<h6><span style="font-size: small;">五、设置Socket的选项</span> </h6> 
<p><span style="font-size: small;">Socket有以下几个选项：</span> </p> 
<p><span style="font-size: small;">n TCP_NODELAY：表示立即发送数据。</span> </p> 
<p><span style="font-size: small;">n SO_RESUSEADDR：表示是否允许重用Socket所绑定的本地地址。</span> </p> 
<p><span style="font-size: small;">n SO_TIMEOUT：表示接收数据时的等待超时时间。</span> </p> 
<p><span style="font-size: small;">n SO_LINGER：表示当执行Socket的close()方法时，是否立即关闭底层的Socket。</span> </p> 
<p><span style="font-size: small;">n SO_SNFBUF：表示发送数据的缓冲区的大小。</span> </p> 
<p><span style="font-size: small;">n SO_RCVBUF：表示接收数据的缓冲区的大小。</span> </p> 
<p><span style="font-size: small;">n SO_KEEPALIVE：表示对于长时间处于空闲状态的Socket，是否要自动把它关闭。</span> </p> 
<p><span style="font-size: small;">n OOBINLINE：表示是否支持发送一个字节的TCP紧急数据。</span> </p> 
<p><span style="font-size: small;">1. TCP_NODELAY选项</span> </p> 
<p><span style="font-size: small;">1) 设置该选项：public void setTcpNoDelay(boolean on) throws SocketException</span> </p> 
<p><span style="font-size: small;">2) 读取该选项：public boolean getTcpNoDelay() throws SocketException</span> </p> 
<p><span style="font-size: small;">3) TCP_NODEALY的默认值为false，表示采用Negale算法。如果调用setTcpNoDelay(true)方法，就会关闭Socket的缓冲，确保数据及时发送：</span> </p> 
<p><span style="font-size: small;"><strong>if(!socket.getTcpNoDelay()) socket.setTcpNoDelay(true);</strong> </span> </p> 
<p><span style="font-size: small;">4) 如果Socket的底层实现不支持TCP_NODELAY选项，那么getTcpNoDelay()和setTcpNoDelay()方法会抛出SocketException。</span> </p> 
<p><span style="font-size: small;">2. SO_RESUSEADDR选项</span> </p> 
<p><span style="font-size: small;">1) 设置该选项：public void setResuseAddress(boolean on) throws SocketException</span> </p> 
<p><span style="font-size: small;">2) 读取该选项：public boolean getResuseAddress() throws SocketException</span> </p> 
<p><span style="font-size: small;">3) 为了确保一个进程关闭了Socket后，即使它还没释放端口，同一个主机上的其他进程还可以立刻重用该端口，可以调用Socket的setResuseAddress(true)方法：</span> </p> 
<p><span style="font-size: small;"><strong>if(!socket.getResuseAddress()) socket.setResuseAddress(true);</strong> </span> </p> 
<p><span style="font-size: small;">4) 值得注意的是socket.setResuseAddress(true)方法必须在Socket还没有绑定到一个本地端口之前调用，否则执行socket.setResuseAddress(true)方法无效。因此必须按照以下方式创建Socket对象，然后再连接远程服务器： </span> </p> 
<table border="1" cellspacing="0" cellpadding="0"><tbody><tr><td width="580"> <p><span style="font-size: small;">Socket socket = <strong>new</strong> Socket(); //此时Socket对象未绑定到本地端口，并且未连接远程服务器</span> </p> <p><span style="font-size: small;">socket.setResuseAddress(<strong>true</strong> );</span> </p> <p><span style="font-size: small;">SocketAddress remoteAddr = <strong>new</strong> InetSocketAddress("remotehost",8000);</span> </p> <p><span style="font-size: small;">socket.connect(remoteAddr)<span style="text-decoration: underline;">;</span> //连接远程服务器，并且绑定匿名的本地端口</span> </p> <p><span style="font-size: small;">或者：</span> </p> <p><span style="font-size: small;">Socket socket = <strong>new</strong> Socket(); //此时Socket对象未绑定到本地端口，并且未连接远程服务器</span> </p> <p><span style="font-size: small;">socket.setResuseAddress(<strong>true</strong> );</span> </p> <p><span style="font-size: small;">SocketAddress localAddr = <strong>new</strong> InetSocketAddress("localhost",9000);</span> </p> <p><span style="font-size: small;">SocketAddress remoteAddr = <strong>new</strong> InetSocketAddress("remotehost",8000);</span> </p> <p><span style="font-size: small;">socket.bind(localAddr); //与本地端口绑定</span> </p> <p><span style="font-size: small;">socket.connect(remoteAddr)<span style="text-decoration: underline;">;</span> //连接远程服务器，并且绑定匿名的本地端口</span> </p> </td></tr></tbody></table> 
<p></p> 
<p><span style="font-size: small;">3. SO_TIMEOUT选项</span> </p> 
<p><span style="font-size: small;">1) 设置该选项：public void setSoTimeout(int milliseconds) throws SocketException</span> </p> 
<p><span style="font-size: small;">2) 读取该选项：public int getSoTimeOut() throws SocketException</span> </p> 
<p><span style="font-size: small;">3) 当通过Socket的输入流读数据时，如果还没有数据，就会等待。Socket类的SO_TIMEOUT选项用于设定接收数据的等待超时时间，单位为毫秒，它的默认值为0，表示会无限等待，永远不会超时。</span> </p> 
<p><span style="font-size: small;">4) Socket的setSoTimeout()方法必须在接收数据之前执行才有效。此外，当输入流的read()方法抛出SocketTimeoutException后，Socket仍然是连接的，可以尝试再次读取数据。</span> </p> 
<p><span style="font-size: small;">4. SO_LINGER选项</span> </p> 
<p><span style="font-size: small;">1) 设置该选项：public void setSoLinger(boolean on, int seconds) throws SocketException</span> </p> 
<p><span style="font-size: small;">2) 读取该选项：public int getSoLinger() throws SocketException</span> </p> 
<p><span style="font-size: small;">3) SO_LINGER选项用来控制Socket关闭时的行为。</span> </p> 
<p><span style="font-size: small;">l socket.setSoLinger(true,0)：执行Socket的close()方法时，该方法也会立即返回，但底层的Socket也会立即关闭，所有未发送完的剩余数据被丢弃。</span> </p> 
<p><span style="font-size: small;">l socket.setSoLinger(true,3600)：执行Socket的close()方法时，该方法不会立即返回，而进入阻塞状态，同时，底层的Socket会尝试发送剩余的数据。只有满足以下两个条件之一，close()方法才返回：</span> </p> 
<p><span style="font-size: small;">n 底层的Socket已经发送完所有的剩余数据。</span> </p> 
<p><span style="font-size: small;">n 尽管底层的Socket还没有发送完所有的剩余数据，但已经阻塞了3600秒。close()方法的阻塞时间超过3600秒，也会返回，剩余未发送的数据被丢弃。</span> </p> 
<p><span style="font-size: small;">以上两种情况内，当close()方法返回后，底层的Socket会被关闭，断开连接。</span> </p> 
<p><span style="font-size: small;">4) setSoLinger(boolean on ,int second)方法中的seconds参数以秒为单位，而不是以毫秒为单位。</span> </p> 
<p><span style="font-size: small;">5. SO_RCVBUF选项</span> </p> 
<p><span style="font-size: small;">1) 设置该选项：public void setReceiveBufferSize(int size) throws SocketException</span> </p> 
<p><span style="font-size: small;">2) 读取该选项：public int getReceiveBufferSize() throws SocketException</span> </p> 
<p><span style="font-size: small;">3) SO_RCVBUF表示Socket的用于输入数据的缓冲区的大小。</span> </p> 
<p><span style="font-size: small;">4) 如果底层Socket不支持SO_RCVBUF选项，那么setReceiveBufferSize()方法会抛出SocketException。</span> </p> 
<p><span style="font-size: small;">6. SO_SNDBUF选项</span> </p> 
<p><span style="font-size: small;">1) 设置该选项：public void setSendBufferSize(int size) throws SocketException</span> </p> 
<p><span style="font-size: small;">2) 读取该选项：public int getSendBufferSize() throws SocketException</span> </p> 
<p><span style="font-size: small;">3) SO_SNDBUF表示Socket的用于输出数据的缓冲区的大小。</span> </p> 
<p><span style="font-size: small;">4) 如果底层Socket不支持SO_SNDBUF选项，setSendBufferSize()方法会抛出SocketException。</span> </p> 
<p><span style="font-size: small;">7. SO_KEEPALIVE选项</span> </p> 
<p><span style="font-size: small;">1) 设置该选项：public void setKeepAlive(boolean on) throws SocketException</span> </p> 
<p><span style="font-size: small;">2) 读取该选项：public int getKeepAlive() throws SocketException</span> </p> 
<p><span style="font-size: small;">3) 当SO_KEEPALIVE选项为true，表示底层的TCP实现会监视该连接是否有效。</span> </p> 
<p><span style="font-size: small;">4) SO_KEEPALIVE选项的默认值为false，表示TCP不会监视连接是否有效，不活动的客户端可能会永久存在下去，而不会注意到服务器已经崩溃。</span> </p> 
<p><span style="font-size: small;">8. OOBINLINE选项</span> </p> 
<p><span style="font-size: small;">1) 设置该选项：public void setOOBInline(int size) throws SocketException</span> </p> 
<p><span style="font-size: small;">2) 读取该选项：public int getOOBInline () throws SocketException</span> </p> 
<p><span style="font-size: small;">3) 当OOBINLINE为true时，表示支持发送一个字节的TCP紧急数据。Socket类的sendUrgentDate(int data)方法用于发送一个字节的TCP紧急数据。</span> </p> 
<p><span style="font-size: small;">4) OOBINLINE的默认值为false，在这种情况下，当接收方收到紧急数据时不作任何处理，直接将其丢弃。如果用户希望发送紧急数据，应该把OOBINLINE设为true：socket.setOOBInline(true); 此时接收方会把接收到的紧急数据与普通数据放在同样的队列中。值得注意的是，除非使用一些更高层次的协议，否则接收方处理紧急数据的能力非常有限，当紧急数据到来时，接收方不会得到任何通知，因此接收方很难区分普通数据与紧急数据，只好按照同样的方式处理它们。</span> </p> 
<p><span style="font-size: small;">9. 服务类型选项</span> </p> 
<p><span style="font-size: small;">1) IP规定了四种服务类型，用来定性的描述服务的质量：</span> </p> 
<p><span style="font-size: small;">l 低成本：发送成本低。</span> </p> 
<p><span style="font-size: small;">l 高可靠性：保证把数据可靠的送达目的地。</span> </p> 
<p><span style="font-size: small;">l 最高吞吐量：一次可以接收或发送大批量的数据。</span> </p> 
<p><span style="font-size: small;">l 最小延迟：传输数据的速度快，把数据快速送达目的地。</span> </p> 
<p><span style="font-size: small;">2) 这四种服务类型还可以进行组合，例如，可以同时要求获得高可靠性和最小延迟。Socket类中提供了设置和读取服务类型的方法：</span> </p> 
<p><span style="font-size: small;">l 设置服务类型：public void setTrafficClass(int trafficClass) throws SocketException</span> </p> 
<p><span style="font-size: small;">l 读取服务类型：public int getTrafficClass() throws SocketException</span> </p> 
<p><span style="font-size: small;">3) Socket类用四个整数表示服务类型：</span> </p> 
<p><span style="font-size: small;">l 低成本：0x02 （二进制的倒数第二位为1）</span> </p> 
<p><span style="font-size: small;">l 高可靠性：0x04（二进制的倒数第三位为1）</span> </p> 
<p><span style="font-size: small;">l 最高吞吐量：0x08（二进制的倒数第四位为1）</span> </p> 
<p><span style="font-size: small;">l 最小延迟：0x10（二进制的倒数第五位为1）</span> </p> 
<p><span style="font-size: small;">10. 设定连接时间、延迟和带宽的相对重要性</span> </p> 
<p><span style="font-size: small;">public void setPerformancePreferences(int connectionTime,int latency,int bandwidth)</span> </p> 
<p><span style="font-size: small;">以上方法的三个参数表示网络传输数据的三项指标：</span> </p> 
<p><span style="font-size: small;">n 参数connectionTime：表示用最少时间建立连接。</span> </p> 
<p><span style="font-size: small;">n 参数latency：表示最小延迟。</span> </p> 
<p><span style="font-size: small;">n 参数bandwidth：表示最高带宽。</span> </p> 
<p><span style="font-size: small;">setPerformancePreferences()方法用来设定这三项指标之间的相对重要性。可以为这些参数赋予任意的整数，这些整数之间的相对大小就决定了相应参数的相对重要性。例如，如果参数connectionTime为2，参数latency为1，而参数bandwidth为3，就表示最高带宽最重要，其次是最少连接时间，最后是最小延迟。</span> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p><span style="font-size: xx-large;"><span style="color: #ff0000;"><a href="http://blog.csdn.net/blog/622079">SocketConnection 参数详细介绍</a> </span> </span> </p> 
<p> </p> 
<p><span style="font-size: large;"><span style="color: #ff0000;"><br> </span> </span> </p> 
<div class="blog_content"> 
 <p><span style="line-height: 18px; font-family: arial;"> </span></p> 
 <div class="f14" style="padding: 0px; font-size: 14px; margin: 0px;">
   请大家看下面的代码：  
  <br style="padding: 0px; margin: 0px;"> 
  <span style="padding: 0px; margin: 0px; color: #0000ff;">len = is.read(gData);</span>   
  <br style="padding: 0px; margin: 0px;"> 这句代码会阻塞在这里，用了上面红色标出的代码后，能不能实现，超过5秒没反应后，read就不阻塞，而向下执行代码！   
  <br style="padding: 0px; margin: 0px;"> try  
  <br style="padding: 0px; margin: 0px;"> {  
  <br style="padding: 0px; margin: 0px;"> int len = 0;  
  <br style="padding: 0px; margin: 0px;">     sc = (SocketConnection) Connector.open("socket://100.42.25.3:885");  
  <br style="padding: 0px; margin: 0px;">     is = sc.openInputStream();  
  <br style="padding: 0px; margin: 0px;">     os = sc.openOutputStream();  
  <br style="padding: 0px; margin: 0px;">     sc.setSocketOption( 
  <strong style="padding: 0px; margin: 0px; color: black; background-color: #ffff66;">SocketConnection.LINGER</strong> , 5);  
  <br style="padding: 0px; margin: 0px;">     pmm.gDataBuf = null;  
  <br style="padding: 0px; margin: 0px;">     sender = new Sender(os);  
  <br style="padding: 0px; margin: 0px;">     sender.send(pmm.gStringReq);  
  <br style="padding: 0px; margin: 0px;">     // Loop forever, receiving data  
  <br style="padding: 0px; margin: 0px;">     gData = new byte[pmm.BUF_LENGTH];  
  <br style="padding: 0px; margin: 0px;">     currentIndex = 0;  
  <br style="padding: 0px; margin: 0px;">     gBuf = new byte[50*1024];  
  <br style="padding: 0px; margin: 0px;">     while (!pmm.bStopConnect)  
  <br style="padding: 0px; margin: 0px;">     {  
  <br style="padding: 0px; margin: 0px;"> len = is.read(gData);  
  <br style="padding: 0px; margin: 0px;">     System.arraycopy(gData,0,gBuf,currentIndex,len);  
  <br style="padding: 0px; margin: 0px;">     currentIndex += len;  
  <br style="padding: 0px; margin: 0px;">     if(currentIndex &gt; 300){  
  <br style="padding: 0px; margin: 0px;">     if(newVerifyXml()){  
  <br style="padding: 0px; margin: 0px;">     if((currentIndex%8) != 0){  
  <br style="padding: 0px; margin: 0px;">     int left = 8 - currentIndex%8;  
  <br style="padding: 0px; margin: 0px;">     byte[] byteTmp = new byte[left];  
  <br style="padding: 0px; margin: 0px;">     is.read(byteTmp);  
  <br style="padding: 0px; margin: 0px;"> }  
  <br style="padding: 0px; margin: 0px;">     opHandle();currentIndex=0;  
  <br style="padding: 0px; margin: 0px;">     }  
  <br style="padding: 0px; margin: 0px;">     }  
  <br style="padding: 0px; margin: 0px;">     }  
  <br style="padding: 0px; margin: 0px;">     stop();  
  <br style="padding: 0px; margin: 0px;"> } catch (ConnectionNotFoundException cnfe) {  
  <br style="padding: 0px; margin: 0px;">     Alert a = new Alert("错误", "无法连接服务器", null, AlertType.ERROR);  
  <br style="padding: 0px; margin: 0px;">     a.setTimeout(Alert.FOREVER);  
  <br style="padding: 0px; margin: 0px;">     display.setCurrent(a) ;  
  <br style="padding: 0px; margin: 0px;"> } catch (IOException ioe) {  
  <br style="padding: 0px; margin: 0px;">     if (!stop) {  
  <br style="padding: 0px; margin: 0px;"> ioe.printStackTrace();  
  <br style="padding: 0px; margin: 0px;">     }  
  <br style="padding: 0px; margin: 0px;"> } catch (Exception e) {  
  <br style="padding: 0px; margin: 0px;">     e.printStackTrace();  
  <br style="padding: 0px; margin: 0px;"> }  
  <br style="padding: 0px; margin: 0px;"> 
 </div> 
 <div class="f14" style="padding: 0px; font-size: 14px; margin: 0px;">
   实现不了吧， 你弄个timer吧。 超时就把所有object 设置为null 
 </div> 
 <div class="answer_info" style="padding: 10px 0px 0px; margin: 0px; color: #aaaaaa; text-align: right;">
     
 </div> 
 <div class="f14" style="padding: 0px; font-size: 14px; margin: 0px;">
   SocketConnection.DELAY：开启Nagle算法？（0/1）  
  <br style="padding: 0px; margin: 0px;"> 
  <strong style="padding: 0px; margin: 0px; color: black; background-color: #ffff66;">SocketConnection.LINGER</strong> ：服务器悬挂等待时间  
  <br style="padding: 0px; margin: 0px;"> SocketConnection.KEEPALIVE：长连接时间  
  <br style="padding: 0px; margin: 0px;"> SocketConnection.RCVBUF：接收缓冲  
  <br style="padding: 0px; margin: 0px;"> SocketConnection.SNDBUF：发送缓冲  
  <br style="padding: 0px; margin: 0px;"> 
  <br style="padding: 0px; margin: 0px;"> 不过虚拟机上可能支持的不好，或者不保证每次都准确  
  <br style="padding: 0px; margin: 0px;"> 建议使用定时器  
  <br style="padding: 0px; margin: 0px;"> 超时就把该关流，连接的全关了  
  <br style="padding: 0px; margin: 0px;"> 再置null 
 </div> 
 <p></p> 
 <p> </p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f23ba107228b4f01e37434a63bf0312f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">MySQL-Front 5 注册码</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/08fa71144cf02b5cf2597e2d40ed9f99/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">1631 Bridging signals  nlogn最长上升子序列</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>