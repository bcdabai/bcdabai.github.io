<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>介绍几个好用的guava工具类 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="介绍几个好用的guava工具类" />
<meta property="og:description" content="前言 平时我们都会封装一些处理缓存或其他的小工具。但每个人都封装一次，重复造轮子，有点费时间。有没有一些好的工具库推荐-guava。guava是谷歌基于java封装好的开源库，它的性能、实用性，比我们自己造的轮子更好，毕竟谷歌出品，下面介绍下几个常用的guava工具类
LoadingCache（本地缓存）Multimap 和 MultisetBiMapTable（表）Sets和Maps（交并差）EventBus（事件）StopWatch（秒表）Files（文件操作）RateLimiter（限流器）Guava Retry（重试） 如何使用Guava &lt;dependency&gt; &lt;groupId&gt;com.google.guava&lt;/groupId&gt; &lt;artifactId&gt;guava&lt;/artifactId&gt; &lt;version&gt;27.0-jre&lt;/version&gt; &lt;/dependency&gt; LoadingCache LoadingCache 在实际场景中有着非常广泛的使用，通常情况下如果遇到需要大量时间计算或者缓存值的场景，就应当将值保存到缓存中。LoadingCache 和 ConcurrentMap 类似，但又不尽相同。最大的不同是 ConcurrentMap 会永久的存储所有的元素值直到他们被显示的移除，但是 LoadingCache 会为了保持内存使用合理会根据配置自动将过期值移除通常情况下，Guava caching 适用于以下场景： 花费一些内存来换取速度一些 key 会被不止一次被调用缓存内容有限，不会超过内存空间的值，Guava caches 不会存储内容到文件或者到服务器外部，如果有此类需求考虑使用 Memcached, RedisLoadingCache 不能缓存 null keyCacheBuilder 构造 LoadingCache 参数介绍 CacheBuilder 方法参数
描述
initialCapacity(int initialCapacity)
缓存池的初始大小
concurrencyLevel(int concurrencyLevel)
设置并发数
maximumSize(long maximumSize)
缓存池大小，在缓存项接近该大小时， Guava开始回收旧的缓存项
weakValues()
设置value的存储引用是虚引用
softValues()
设置value的存储引用是软引用
expireAfterWrite(long duration, TimeUnit unit)
设置时间对象没有被写则对象从内存中删除(在另外的线程里面不定期维护)
expireAfterAccess(long duration, TimeUnit unit)
设置时间对象没有被读/写访问则对象从内存中删除(在另外的线程里面不定期维护)
refreshAfterWrite(long duration, TimeUnit unit)
和expireAfterWrite类似，不过不立马移除key，而是在下次更新时刷新，这段时间可能会返回旧值" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/6085d764b7809e406ff5f9aa818c7b03/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-05T00:30:32+08:00" />
<meta property="article:modified_time" content="2023-12-05T00:30:32+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">介绍几个好用的guava工具类</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h4 id="8lr4o"><strong>前言</strong></h4> 
<p>平时我们都会封装一些处理缓存或其他的小工具。但每个人都封装一次，重复造轮子，有点费时间。有没有一些好的工具库推荐-guava。guava是谷歌基于java封装好的开源库，它的性能、实用性，比我们自己造的轮子更好，毕竟谷歌出品，下面介绍下几个常用的guava工具类</p> 
<ul><li>LoadingCache（本地缓存）</li><li>Multimap 和 Multiset</li><li>BiMap</li><li>Table（表）</li><li>Sets和Maps（交并差）</li><li>EventBus（事件）</li><li>StopWatch（秒表）</li><li>Files（文件操作）</li><li>RateLimiter（限流器）</li><li>Guava Retry（重试）</li></ul> 
<h4 id="5905p"><strong>如何使用Guava</strong></h4> 
<pre><code class="language-XML">&lt;dependency&gt;
　　&lt;groupId&gt;com.google.guava&lt;/groupId&gt;
　　&lt;artifactId&gt;guava&lt;/artifactId&gt;
　　&lt;version&gt;27.0-jre&lt;/version&gt;
 &lt;/dependency&gt;</code></pre> 
<h4 id="vasn"><strong>LoadingCache</strong></h4> 
<ul><li>LoadingCache 在实际场景中有着非常广泛的使用，通常情况下如果遇到需要大量时间计算或者缓存值的场景，就应当将值保存到缓存中。LoadingCache 和 ConcurrentMap 类似，但又不尽相同。最大的不同是 ConcurrentMap 会永久的存储所有的元素值直到他们被显示的移除，但是 LoadingCache 会为了保持内存使用合理会根据配置自动将过期值移除</li><li>通常情况下，Guava caching 适用于以下场景： 
  <ul><li>花费一些内存来换取速度</li><li>一些 key 会被不止一次被调用</li><li>缓存内容有限，不会超过内存空间的值，Guava caches 不会存储内容到文件或者到<a href="https://cloud.tencent.com/act/pro/promotion-cvm?from_column=20065&amp;from=20065" rel="nofollow" title="服务器">服务器</a>外部，如果有此类需求考虑使用 Memcached, <a href="https://cloud.tencent.com/product/crs?from_column=20065&amp;from=20065" rel="nofollow" title="Redis">Redis</a></li></ul></li><li>LoadingCache 不能缓存 null key</li><li>CacheBuilder 构造 LoadingCache 参数介绍</li></ul> 
<table><thead><tr><th> <p>CacheBuilder 方法参数</p> </th><th> <p>描述</p> </th></tr></thead><tbody><tr><td> <p>initialCapacity(int initialCapacity)</p> </td><td> <p>缓存池的初始大小</p> </td></tr><tr><td> <p>concurrencyLevel(int concurrencyLevel)</p> </td><td> <p>设置并发数</p> </td></tr><tr><td> <p>maximumSize(long maximumSize)</p> </td><td> <p>缓存池大小，在缓存项接近该大小时， Guava开始回收旧的缓存项</p> </td></tr><tr><td> <p>weakValues()</p> </td><td> <p>设置value的存储引用是虚引用</p> </td></tr><tr><td> <p>softValues()</p> </td><td> <p>设置value的存储引用是软引用</p> </td></tr><tr><td> <p>expireAfterWrite(long duration, TimeUnit unit)</p> </td><td> <p>设置时间对象没有被写则对象从内存中删除(在另外的线程里面不定期维护)</p> </td></tr><tr><td> <p>expireAfterAccess(long duration, TimeUnit unit)</p> </td><td> <p>设置时间对象没有被读/写访问则对象从内存中删除(在另外的线程里面不定期维护)</p> </td></tr><tr><td> <p>refreshAfterWrite(long duration, TimeUnit unit)</p> </td><td> <p>和expireAfterWrite类似，不过不立马移除key，而是在下次更新时刷新，这段时间可能会返回旧值</p> </td></tr><tr><td> <p>removalListener( RemovalListener&lt;? super K1, ? super V1&gt; listener)</p> </td><td> <p>监听器，缓存项被移除时会触发</p> </td></tr><tr><td> <p>build(CacheLoader&lt;? super K1, V1&gt; loader)</p> </td><td> <p>当数据不存在时，则使用loader加载数据</p> </td></tr></tbody></table> 
<ul><li>LoadingCache <code>V get(K key)</code>, 获取缓存值，如果键不存在值，将调用CacheLoader的load方法加载新值到该键中 <pre><code class="language-java">LoadingCache&lt;Integer,Long&gt; cacheMap = CacheBuilder.newBuilder().initialCapacity(10)
    .concurrencyLevel(10)
    .expireAfterAccess(Duration.ofSeconds(10))
    .weakValues()
    .recordStats()
    .removalListener(new RemovalListener&lt;Integer,Long&gt;(){
        @Override
        public void onRemoval(RemovalNotification&lt;Integer, Long&gt; notification) {
            System.out.println(notification.getValue());
        }
    })
    .build(new CacheLoader&lt;Integer,Long&gt;(){
        @Override
        public Long load(Integer key) throws Exception {
            return System.currentTimeMillis();
        }
    });
cacheMap.get(1);</code></pre> <h4 id="8m0um"><strong>Multimap 和 MultiSet</strong></h4> </li><li>Multimap的特点其实就是可以包含有几个重复Key的value，可以put进入多个不同value但是相同的key，但是又不会覆盖前面的内容</li></ul> 
<pre><code class="language-java">//Multimap: key-value  key可以重复，value也可重复
Multimap&lt;String, String&gt; multimap = ArrayListMultimap.create();
multimap.put("csc","1");
multimap.put("lwl","1");
multimap.put("csc","1");
multimap.put("lwl","one");
System.out.println(multimap.get("csc"));
System.out.println(multimap.get("lwl"));
---------------------------
[1, 1]
[1, one]</code></pre> 
<ul><li>MultiSet 有一个相对有用的场景，就是跟踪每种对象的数量，所以可以用来进行数量统计</li></ul> 
<pre><code class="language-java">//MultiSet: 无序+可重复   count()方法获取单词的次数  增强了可读性+操作简单
Multiset&lt;String&gt; set = HashMultiset.create();
set.add("csc");
set.add("lwl");
set.add("csc");
System.out.println(set.size());
System.out.println(set.count("csc"));
---------------------------
3
2</code></pre> 
<h4 id="fchkf"><strong>BiMap</strong></h4> 
<p>BiMap的键必须唯一，值也必须唯一，可以实现value和key互转</p> 
<pre><code class="language-java">BiMap&lt;Integer,String&gt; biMap = HashBiMap.create();
biMap.put(1,"lwl");
biMap.put(2,"csc");
BiMap&lt;String, Integer&gt; map = biMap.inverse(); // value和key互转
map.forEach((v, k) -&gt; System.out.println(v + "-" + k));</code></pre> 
<h4 id="5c08s"><strong>Table</strong></h4> 
<ul><li><code>Table&lt;R,C,V&gt; table = HashBasedTable.create();</code>，由泛型可以看出，table由双主键R（行）,C（列）共同决定，V是存储值</li><li>新增数据：<code>table.put(R,C,V)</code></li><li>获取数据：<code>V v = table.get(R,C)</code></li></ul> 
<p>遍历数据: <code>Set&lt;R&gt; set = table.rowKeySet(); Set&lt;C&gt; set = table.columnKeySet();</code></p> 
<pre><code class="language-java">// 双键的Map Map--&gt; Table--&gt;rowKey+columnKey+value  
Table&lt;String, String, Integer&gt; tables = HashBasedTable.create();
tables.put("csc", "lwl", 1);
//row+column对应的value
System.out.println(tables.get("csc","lwl"));</code></pre> 
<p><strong>Sets和Maps</strong></p> 
<ul><li> <h5 id="8f450"><strong>set的交集, 并集, 差集</strong></h5> </li></ul> 
<pre><code class="language-java">HashSet setA = newHashSet(1, 2, 3, 4, 5);  
HashSet setB = newHashSet(4, 5, 6, 7, 8); 
//并集
SetView union = Sets.union(setA, setB);   
//差集 setA-setB
SetView difference = Sets.difference(setA, setB);  
//交集
SetView intersection = Sets.intersection(setA, setB);  </code></pre> 
<h5 id="8j5fc"><strong>map的交集，并集，差集</strong></h5> 
<pre><code class="language-java">HashMap&lt;String, Integer&gt; mapA = Maps.newHashMap();
mapA.put("a", 1);mapA.put("b", 2);mapA.put("c", 3);
HashMap&lt;String, Integer&gt; mapB = Maps.newHashMap();
mapB.put("b", 20);mapB.put("c", 3);mapB.put("d", 4);
MapDifference&lt;String, Integer&gt; mapDifference = Maps.difference(mapA, mapB);
//mapA 和 mapB 相同的 entry
System.out.println(mapDifference.entriesInCommon());
//mapA 和 mapB key相同的value不同的 entry
System.out.println(mapDifference.entriesDiffering());
//只存在 mapA 的 entry
System.out.println(mapDifference.entriesOnlyOnLeft());
//只存在 mapB 的 entry
System.out.println(mapDifference.entriesOnlyOnRight());;
-------------结果-------------
{c=3}
{b=(2, 20)}
{a=1}
{d=4}</code></pre> 
<h4 id="9vice"><strong>EventBus</strong></h4> 
<ul><li>EventBus是Guava的事件处理机制，是设计模式中的观察者模式（生产/消费者编程模型）的优雅实现。对于事件监听和发布订阅模式</li></ul> 
<p>EventBus内部实现原理不复杂，EventBus内部会维护一个Multimap&lt;Class&lt;?&gt;, Subscriber&gt; map，key就代表消息对应的类(不同消息不同类，区分不同的消息)、value是一个Subscriber，Subscriber其实就是对应消息处理者。如果有消息发布就去这个map里面找到这个消息对应的Subscriber去执行</p> 
<pre><code class="language-java">@Data
@AllArgsConstructor
public class OrderMessage {
    String message;
}
//使用 @Subscribe 注解,表明使用dealWithEvent 方法处理 OrderMessage类型对应的消息
//可以注解多个方法,不同的方法 处理不同的对象消息
public class OrderEventListener {
    @Subscribe
    public void dealWithEvent(OrderMessage event) {
        System.out.println("内容：" + event.getMessage());
    }
}
-------------------------------------
// new AsyncEventBus(String identifier, Executor executor);
EventBus eventBus = new EventBus("lwl"); 
eventBus.register(new OrderEventListener());
// 发布消息
eventBus.post(new OrderMessage("csc"));</code></pre> 
<h4 id="53mm3"><strong>StopWatch</strong></h4> 
<pre><code class="language-java">Stopwatch stopwatch = Stopwatch.createStarted();
for(int i=0; i&lt;100000; i++){
    // do some thing
}
long nanos = stopwatch.elapsed(TimeUnit.MILLISECONDS);
System.out.println("逻辑代码运行耗时："+nanos);</code></pre> 
<h4 id="8gn7i"><strong>Files文件操作</strong></h4> 
<ul><li>数据写入</li></ul> 
<pre><code class="language-java">File newFile = new File("D:/text.txt");
Files.write("this is a test".getBytes(), newFile);
//再次写入会把之前的内容冲掉
Files.write("csc".getBytes(), newFile);
//追加写
Files.append("lwl", newFile, Charset.defaultCharset());</code></pre> 
<ul><li>文本数据读取</li></ul> 
<pre><code class="language-java">File newFile = new File("E:/text.txt");
List&lt;String&gt; lines = Files.readLines(newFile, Charset.defaultCharset());</code></pre> 
<ul><li>其他操作</li></ul> 
<table><thead><tr><th> <p>方法</p> </th><th> <p>描述</p> </th></tr></thead><tbody><tr><td> <p>Files.copy(File from, File to)</p> </td><td> <p>复制文件</p> </td></tr><tr><td> <p>Files.deleteDirectoryContents(File directory)</p> </td><td> <p>删除文件夹下的内容(包括文件与子文件夹)</p> </td></tr><tr><td> <p>Files.deleteRecursively(File file)</p> </td><td> <p>删除文件或者文件夹</p> </td></tr><tr><td> <p>Files.move(File from, File to)</p> </td><td> <p>移动文件</p> </td></tr><tr><td> <p>Files.touch(File file)</p> </td><td> <p>创建或者更新文件的时间戳</p> </td></tr><tr><td> <p>Files.getFileExtension(String file)</p> </td><td> <p>获得文件的扩展名</p> </td></tr><tr><td> <p>Files.getNameWithoutExtension(String file)</p> </td><td> <p>获得不带扩展名的文件名</p> </td></tr><tr><td> <p>Files.map(File file, MapMode mode)</p> </td><td> <p>获取内存映射buffer</p> </td></tr></tbody></table> 
<h4 id="8paio"><strong>11RateLimiter</strong></h4> 
<pre><code>//RateLimiter 构造方法，每秒限流permitsPerSecond
public static RateLimiter create(double permitsPerSecond) 
//每秒限流 permitsPerSecond，warmupPeriod 则是数据初始预热时间，从第一次acquire 或 tryAcquire 执行开时计算
public static RateLimiter create(double permitsPerSecond, Duration warmupPeriod)
//获取一个令牌，阻塞，返回阻塞时间
public double acquire()
//获取 permits 个令牌，阻塞，返回阻塞时间
public double acquire(int permits)
//获取一个令牌，超时返回
public boolean tryAcquire(Duration timeout)
获取 permits 个令牌，超时返回
public boolean tryAcquire(int permits, Duration timeout)
</code></pre> 
<p>复制</p> 
<ul><li>使用示例</li></ul> 
<pre><code>RateLimiter limiter = RateLimiter.create(2, 3, TimeUnit.SECONDS);
System.out.println("get one permit cost time: " + limiter.acquire(1) + "s");
System.out.println("get one permit cost time: " + limiter.acquire(1) + "s");
System.out.println("get one permit cost time: " + limiter.acquire(1) + "s");
System.out.println("get one permit cost time: " + limiter.acquire(1) + "s");
System.out.println("get one permit cost time: " + limiter.acquire(1) + "s");
System.out.println("get one permit cost time: " + limiter.acquire(1) + "s");
System.out.println("get one permit cost time: " + limiter.acquire(1) + "s");
System.out.println("get one permit cost time: " + limiter.acquire(1) + "s");
---------------  结果 -------------------------
get one permit cost time: 0.0s
get one permit cost time: 1.331672s
get one permit cost time: 0.998392s
get one permit cost time: 0.666014s
get one permit cost time: 0.498514s
get one permit cost time: 0.498918s
get one permit cost time: 0.499151s
get one permit cost time: 0.488548s
</code></pre> 
<p>复制</p> 
<ul><li>因为RateLimiter滞后处理的，所以第一次无论取多少都是零秒</li><li>可以看到前四次的acquire，花了三秒时间去预热数据，在第五次到第八次的acquire耗时趋于平滑</li></ul> 
<h4 id="27nte"><strong>12Guava Retry</strong></h4> 
<ul><li>maven引入</li></ul> 
<pre><code>&lt;dependency&gt;
  &lt;groupId&gt;com.github.rholder&lt;/groupId&gt;
  &lt;artifactId&gt;guava-retrying&lt;/artifactId&gt;
  &lt;version&gt;2.0.0&lt;/version&gt;
&lt;/dependency&gt;
</code></pre> 
<p>复制</p> 
<ul><li>RetryerBuilder 构造方法</li></ul> 
<table><thead><tr><th> <p>RetryerBuilder方法</p> </th><th> <p>描述</p> </th></tr></thead><tbody><tr><td> <p>withRetryListener</p> </td><td> <p>重试监听器</p> </td></tr><tr><td> <p>withWaitStrategy</p> </td><td> <p>失败后重试间隔时间</p> </td></tr><tr><td> <p>withStopStrategy</p> </td><td> <p>停止策略</p> </td></tr><tr><td> <p>withBlockStrategy</p> </td><td> <p>阻塞策略BlockStrategy</p> </td></tr><tr><td> <p>withAttemptTimeLimiter</p> </td><td> <p>执行时间限制策略</p> </td></tr><tr><td> <p>retryIfException</p> </td><td> <p>发生异常，则重试</p> </td></tr><tr><td> <p>retryIfRuntimeException</p> </td><td> <p>发生RuntimeException异常，则重试</p> </td></tr><tr><td> <p>retryIfExceptionOfType(Class&lt;? extends Throwable&gt; ex)</p> </td><td> <p>发生ex异常，则重试</p> </td></tr><tr><td> <p>retryIfException(Predicate&lt;Throwable&gt; exceptionPredicate)</p> </td><td> <p>对异常判断，是否重试</p> </td></tr><tr><td> <p>retryIfResult(Predicate&lt;V&gt; resultPredicate)</p> </td><td> <p>对返回结果判断，是否重试</p> </td></tr></tbody></table> 
<pre><code>Retryer&lt;Boolean&gt; retryer = RetryerBuilder.&lt;Boolean&gt;newBuilder()
    .retryIfException()
    .retryIfResult(Predicates.equalTo(false))
    .withAttemptTimeLimiter(AttemptTimeLimiters.fixedTimeLimit(1, TimeUnit.SECONDS))
    .withStopStrategy(StopStrategies.stopAfterAttempt(5))
    .build();
//Retryer调用                
retryer.call(() -&gt; true);
</code></pre> 
<p>复制</p> 
<ul><li>spring也有对应的重试机制，相关文章可以看看<strong>重试框架Guava-Retry和spring-Retry[1]</strong>欢迎指正文中错误（故事纯属虚构，如有雷同纯属巧合）</li></ul> 
<hr> 
<h4 id="dnhrd"><strong>13参考文章</strong></h4> 
<ul><li><strong>Google guava工具类的介绍和使用[2]</strong></li><li><strong>重试框架Guava-Retry和spring-Retry[3]</strong></li><li><strong>超详细的Guava RateLimiter限流原理解析[4]</strong></li></ul> 
<h5 id="9goti"><strong>参考资料</strong></h5> 
<p>[1]</p> 
<p>重试框架Guava-Retry和spring-Retry: <em>https://blog.csdn.net/zzzgd_666/article/details/84377962</em></p> 
<p>[2]</p> 
<p>Google guava工具类的介绍和使用: <em>https://blog.csdn.net/wwwdc1012/article/details/82228458</em></p> 
<p>[3]</p> 
<p>重试框架Guava-Retry和spring-Retry: <em>https://blog.csdn.net/zzzgd_666/article/details/84377962</em></p> 
<p>[4]</p> 
<p>超详细的Guava RateLimiter限流原理解析: <em>https://zhuanlan.zhihu.com/p/60979444</em></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9bb727e9b519418ca7c7487f36907c8d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">公开Java框架开源到Maven中央仓库（避坑）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a368f56bfaaf1b6684d3e6b5e31395c4/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">windows 安装两个mysql</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>