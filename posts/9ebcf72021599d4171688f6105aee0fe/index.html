<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>从Redis List的各种使用场景来深刻理解它 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="从Redis List的各种使用场景来深刻理解它" />
<meta property="og:description" content="文章目录 一. 任务队列：由于Redis List支持阻塞式弹出元素，并且支持多个客户端同时阻塞在同一个List上，因此可以用来实现任务队列。例如，将需要异步执行的任务存储在一个List中，多个工作线程则通过阻塞式地弹出元素来获取任务。二. 实现日志记录：Redis的list还可以用来存储日志记录。比如说，在Web应用中，我们可以将用户请求的URL和请求时间push到一个list中，并设置list的长度为一定值，当需要查看日志时就可以通过lrange命令获取之前请求过的URL和请求时间。三. 分页查询：由于Redis List支持按照索引访问元素，因此可以用来实现分页查询。四. 消息通知：由于Redis List支持阻塞式弹出元素，并且支持多个客户端同时阻塞在同一个List上，因此可以用来实现消息通知。例如，将需要推送给用户的消息存储在一个List中，多个客户端则通过阻塞式地弹出元素来获取消息通知。五. 消息队列：由于Redis List支持阻塞式弹出元素，因此可以用来实现消息队列。生产者将消息推入List中，消费者则通过阻塞式地弹出元素来获取消息。六. 列表：Redis的List是一个双向链表，可以在列表两端进行快速的插入和删除操作。因此，List可以用来实现队列、栈等数据结构。七. 实现轮询队列：Redis的list还可以用来实现轮询队列。比如说，在在线客服系统中，我们可以将客户发送过来的消息push到一个list中，并由多个客服进程并发地从list中获取消息进行回复。这种方式既能够保证每个消息都会被处理到，又能够提高客服回复效率。八. 实现缓存淘汰策略：Redis支持设置key过期时间，但是在某些情况下，我们也可以使用list来实现缓存淘汰策略。比如说，在缓存系统中，我们可以将需要缓存的数据push到一个list中，并设置list的长度为一定值，当需要插入新数据时就可以将最早插入的数据pop出去，从而实现缓存淘汰。九. 实现任务调度：Redis的list还可以用来实现任务调度。比如说，在电商网站中，我们可以将需要发送邮件或短信通知的订单信息push到一个list中，并设置每个订单需要执行通知任务的时间戳。然后使用Redis提供的sorted set结构体按照时间戳排序获取需要执行通知任务的订单信息。十. 排行榜：由于Redis List支持按照索引访问元素，并且支持对List进行排序，因此可以用来实现排行榜。例如，在一个List中存储用户的积分信息，并按照积分从高到低排序。十一. 地理位置：由于Redis List支持按照索引访问元素，并且支持对List进行排序，因此可以用来实现地理位置。例如，在一个List中存储所有用户的经纬度信息，并按照距离从近到远排序，则可以通过取某个范围内的元素来获取附近的用户。十二. 实现分布式锁：Redis的list还可以用来实现分布式锁。比如说，在分布式系统中，我们可以将获取锁的请求push到一个list中，并通过lindex命令获取第一个请求进行加锁操作。这种方式既能够保证同一时间只有一个进程持有锁，又能够避免死锁等问题。十三. 时间轴：Redis List还可以用来实现时间轴功能。比如微博应用中用户发表一条微博就会被添加到自己的时间轴上，而其他用户关注该用户后也会将其微博添加到自己的时间轴上。这个功能可以通过将每个用户的时间轴作为一个List来实现。十四. 数据缓存：Redis List还可以用来实现数据缓存功能。比如需要缓存一些数据以加速读取速度，就可以将这些数据作为List中的元素，并且使用Redis提供的LRU淘汰策略控制缓存大小和淘汰过期数据。十五.栈：Redis list还可以被当做栈来使用，即只能在列表的头部添加和弹出元素。这种使用场景常用于浏览器历史记录、撤销操作等需要后进先出（LIFO）的场景。十六.实时在线用户列表十七.秒杀活动抢购十八.延迟任务队列十九.异步任务：通过将任务信息存储在Redis的List中，并使用多个worker进程来处理这些任务，可以实现异步任务处理。生产者向List中添加任务信息，worker进程则从List中取出任务并执行。二十.流水线操作：由于Redis支持管道操作，因此我们可以使用Redis List进行流水线操作。将需要执行的多个命令按顺序存储在List中，并通过一次性发送给Redis服务器来减少网络延迟和通信开销。二十一.实时聊天室：Redis的List可以作为聊天室中消息的缓存区域。每当有用户发送一条新消息时，就将该消息添加到聊天室对应的List中，并通过订阅/发布机制将该消息广播给所有在线用户。 一. 任务队列：由于Redis List支持阻塞式弹出元素，并且支持多个客户端同时阻塞在同一个List上，因此可以用来实现任务队列。例如，将需要异步执行的任务存储在一个List中，多个工作线程则通过阻塞式地弹出元素来获取任务。 Redis list 可以很方便地实现任务队列。任务队列是一种常见的设计模式，它用于在系统中排队和处理一系列异步任务。Redis list 可以用来存储任务，同时提供 push 和 pop 操作，实现任务的添加和取出。
具体实现步骤如下：
创建一个 Redis list，作为任务队列。
向任务队列中 push 任务，使用 lpush 或 rpush 操作。
从任务队列中取出任务，使用 lpop 或 rpop 操作。
处理任务。
下面是一个简单的示例，演示如何使用 Redis list 实现任务队列。
import redis # 连接 Redis r = redis.Redis() # 定义任务队列 key task_queue_key = &#39;my_task_queue&#39; # 添加任务到队列 r." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/9ebcf72021599d4171688f6105aee0fe/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-05-10T12:27:53+08:00" />
<meta property="article:modified_time" content="2023-05-10T12:27:53+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">从Redis List的各种使用场景来深刻理解它</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><ul><li><a href="#_Redis_ListListList_2" rel="nofollow">一. 任务队列：由于Redis List支持阻塞式弹出元素，并且支持多个客户端同时阻塞在同一个List上，因此可以用来实现任务队列。例如，将需要异步执行的任务存储在一个List中，多个工作线程则通过阻塞式地弹出元素来获取任务。</a></li><li><a href="#_RedislistWebURLpushlistlistlrangeURL_47" rel="nofollow">二. 实现日志记录：Redis的list还可以用来存储日志记录。比如说，在Web应用中，我们可以将用户请求的URL和请求时间push到一个list中，并设置list的长度为一定值，当需要查看日志时就可以通过lrange命令获取之前请求过的URL和请求时间。</a></li><li><a href="#_Redis_List_98" rel="nofollow">三. 分页查询：由于Redis List支持按照索引访问元素，因此可以用来实现分页查询。</a></li><li><a href="#_Redis_ListListList_149" rel="nofollow">四. 消息通知：由于Redis List支持阻塞式弹出元素，并且支持多个客户端同时阻塞在同一个List上，因此可以用来实现消息通知。例如，将需要推送给用户的消息存储在一个List中，多个客户端则通过阻塞式地弹出元素来获取消息通知。</a></li><li><a href="#_Redis_ListList_181" rel="nofollow">五. 消息队列：由于Redis List支持阻塞式弹出元素，因此可以用来实现消息队列。生产者将消息推入List中，消费者则通过阻塞式地弹出元素来获取消息。</a></li><li><a href="#_RedisListList_278" rel="nofollow">六. 列表：Redis的List是一个双向链表，可以在列表两端进行快速的插入和删除操作。因此，List可以用来实现队列、栈等数据结构。</a></li><li><a href="#_Redislistpushlistlist_318" rel="nofollow">七. 实现轮询队列：Redis的list还可以用来实现轮询队列。比如说，在在线客服系统中，我们可以将客户发送过来的消息push到一个list中，并由多个客服进程并发地从list中获取消息进行回复。这种方式既能够保证每个消息都会被处理到，又能够提高客服回复效率。</a></li><li><a href="#_Rediskeylistpushlistlistpop_348" rel="nofollow">八. 实现缓存淘汰策略：Redis支持设置key过期时间，但是在某些情况下，我们也可以使用list来实现缓存淘汰策略。比如说，在缓存系统中，我们可以将需要缓存的数据push到一个list中，并设置list的长度为一定值，当需要插入新数据时就可以将最早插入的数据pop出去，从而实现缓存淘汰。</a></li><li><a href="#_RedislistpushlistRedissorted_set_350" rel="nofollow">九. 实现任务调度：Redis的list还可以用来实现任务调度。比如说，在电商网站中，我们可以将需要发送邮件或短信通知的订单信息push到一个list中，并设置每个订单需要执行通知任务的时间戳。然后使用Redis提供的sorted set结构体按照时间戳排序获取需要执行通知任务的订单信息。</a></li><li><a href="#_Redis_ListListList_368" rel="nofollow">十. 排行榜：由于Redis List支持按照索引访问元素，并且支持对List进行排序，因此可以用来实现排行榜。例如，在一个List中存储用户的积分信息，并按照积分从高到低排序。</a></li><li><a href="#_Redis_ListListList_403" rel="nofollow">十一. 地理位置：由于Redis List支持按照索引访问元素，并且支持对List进行排序，因此可以用来实现地理位置。例如，在一个List中存储所有用户的经纬度信息，并按照距离从近到远排序，则可以通过取某个范围内的元素来获取附近的用户。</a></li><li><a href="#_Redislistpushlistlindex_406" rel="nofollow">十二. 实现分布式锁：Redis的list还可以用来实现分布式锁。比如说，在分布式系统中，我们可以将获取锁的请求push到一个list中，并通过lindex命令获取第一个请求进行加锁操作。这种方式既能够保证同一时间只有一个进程持有锁，又能够避免死锁等问题。</a></li><li><a href="#_Redis_ListList_435" rel="nofollow">十三. 时间轴：Redis List还可以用来实现时间轴功能。比如微博应用中用户发表一条微博就会被添加到自己的时间轴上，而其他用户关注该用户后也会将其微博添加到自己的时间轴上。这个功能可以通过将每个用户的时间轴作为一个List来实现。</a></li><li><a href="#_Redis_ListListRedisLRU_474" rel="nofollow">十四. 数据缓存：Redis List还可以用来实现数据缓存功能。比如需要缓存一些数据以加速读取速度，就可以将这些数据作为List中的元素，并且使用Redis提供的LRU淘汰策略控制缓存大小和淘汰过期数据。</a></li><li><a href="#Redis_listLIFO_481" rel="nofollow">十五.栈：Redis list还可以被当做栈来使用，即只能在列表的头部添加和弹出元素。这种使用场景常用于浏览器历史记录、撤销操作等需要后进先出（LIFO）的场景。</a></li><li><a href="#_503" rel="nofollow">十六.实时在线用户列表</a></li><li><a href="#_556" rel="nofollow">十七.秒杀活动抢购</a></li><li><a href="#_569" rel="nofollow">十八.延迟任务队列</a></li><li><a href="#RedisListworkerListworkerList_614" rel="nofollow">十九.异步任务：通过将任务信息存储在Redis的List中，并使用多个worker进程来处理这些任务，可以实现异步任务处理。生产者向List中添加任务信息，worker进程则从List中取出任务并执行。</a></li><li><a href="#RedisRedis_ListListRedis_616" rel="nofollow">二十.流水线操作：由于Redis支持管道操作，因此我们可以使用Redis List进行流水线操作。将需要执行的多个命令按顺序存储在List中，并通过一次性发送给Redis服务器来减少网络延迟和通信开销。</a></li><li><a href="#RedisListList_618" rel="nofollow">二十一.实时聊天室：Redis的List可以作为聊天室中消息的缓存区域。每当有用户发送一条新消息时，就将该消息添加到聊天室对应的List中，并通过订阅/发布机制将该消息广播给所有在线用户。</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h3><a id="_Redis_ListListList_2"></a>一. 任务队列：由于Redis List支持阻塞式弹出元素，并且支持多个客户端同时阻塞在同一个List上，因此可以用来实现任务队列。例如，将需要异步执行的任务存储在一个List中，多个工作线程则通过阻塞式地弹出元素来获取任务。</h3> 
<p>Redis list 可以很方便地实现任务队列。任务队列是一种常见的设计模式，它用于在系统中排队和处理一系列异步任务。Redis list 可以用来存储任务，同时提供 push 和 pop 操作，实现任务的添加和取出。</p> 
<p>具体实现步骤如下：</p> 
<ol><li> <p>创建一个 Redis list，作为任务队列。</p> </li><li> <p>向任务队列中 push 任务，使用 lpush 或 rpush 操作。</p> </li><li> <p>从任务队列中取出任务，使用 lpop 或 rpop 操作。</p> </li><li> <p>处理任务。</p> </li></ol> 
<p>下面是一个简单的示例，演示如何使用 Redis list 实现任务队列。</p> 
<pre><code class="prism language-python"><span class="token keyword">import</span> redis

<span class="token comment"># 连接 Redis</span>
r <span class="token operator">=</span> redis<span class="token punctuation">.</span>Redis<span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment"># 定义任务队列 key</span>
task_queue_key <span class="token operator">=</span> <span class="token string">'my_task_queue'</span>

<span class="token comment"># 添加任务到队列</span>
r<span class="token punctuation">.</span>lpush<span class="token punctuation">(</span>task_queue_key<span class="token punctuation">,</span> <span class="token string">'task1'</span><span class="token punctuation">)</span>
r<span class="token punctuation">.</span>lpush<span class="token punctuation">(</span>task_queue_key<span class="token punctuation">,</span> <span class="token string">'task2'</span><span class="token punctuation">)</span>
r<span class="token punctuation">.</span>lpush<span class="token punctuation">(</span>task_queue_key<span class="token punctuation">,</span> <span class="token string">'task3'</span><span class="token punctuation">)</span>

<span class="token comment"># 处理任务</span>
<span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>
    task <span class="token operator">=</span> r<span class="token punctuation">.</span>rpop<span class="token punctuation">(</span>task_queue_key<span class="token punctuation">)</span>
    <span class="token keyword">if</span> task <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
        <span class="token keyword">break</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Handling task:'</span><span class="token punctuation">,</span> task<span class="token punctuation">)</span>
</code></pre> 
<p>在这个例子中，我们首先连接 Redis，并定义了一个任务队列的 key。然后，我们向任务队列中添加了三个任务，使用 lpush 操作。接下来，我们使用一个无限循环来取出任务，使用 rpop 操作。如果任务队列为空，rpop 操作会返回 None，这时我们退出循环。如果任务队列不为空，我们就处理取出的任务，并打印出来。</p> 
<p>这个例子只是一个简单的示例，实际的任务队列可能会更复杂，需要处理更多的任务和数据。但是，使用 Redis list 实现任务队列的思路是相似的。</p> 
<h3><a id="_RedislistWebURLpushlistlistlrangeURL_47"></a>二. 实现日志记录：Redis的list还可以用来存储日志记录。比如说，在Web应用中，我们可以将用户请求的URL和请求时间push到一个list中，并设置list的长度为一定值，当需要查看日志时就可以通过lrange命令获取之前请求过的URL和请求时间。</h3> 
<p>Redis是一个高效的内存键值数据库，它支持多种数据结构，包括字符串、哈希、列表、集合和有序集合等。其中，列表（List）是一种简单的数据结构，它可以用来实现队列、栈和日志记录等功能。</p> 
<p>在Redis中，列表的基本操作包括左右入队、左右出队、获取元素和获取列表长度等。这些操作的时间复杂度都是O(1)，因此Redis列表非常适合用来实现日志记录。</p> 
<p>具体实现方式如下：</p> 
<ol><li>创建一个Redis列表，用于存储日志记录。</li></ol> 
<pre><code class="prism language-redis">   redis-cli&gt; LPUSH logs "log1"
   redis-cli&gt; LPUSH logs "log2"
   redis-cli&gt; LPUSH logs "log3"
   


2. 向列表中添加新的日志记录。

   
```redis
   redis-cli&gt; LPUSH logs "log4"
   


3. 获取最新的日志记录。

   
```redis
   redis-cli&gt; LINDEX logs 0
   


4. 获取指定范围内的日志记录。

   
```redis
   redis-cli&gt; LRANGE logs 0 1
   


5. 获取日志记录的总数。

   
```redis
   redis-cli&gt; LLEN logs
</code></pre> 
<p>通过上述操作，我们可以轻松地实现日志记录功能，并且可以随时获取最新的日志记录和历史记录。此外，Redis还支持列表的阻塞式操作，可以让程序在列表为空时等待新的数据到来，从而实现更加高效的日志记录。</p> 
<h3><a id="_Redis_List_98"></a>三. 分页查询：由于Redis List支持按照索引访问元素，因此可以用来实现分页查询。</h3> 
<p>例如，在一个List中存储所有文章的ID，并按照发布时间从晚到早排序，则可以通过取某个范围内的元素来实现分页查询。</p> 
<p>Redis的list数据结构可以用来实现分页查询。具体实现方法是通过lrange命令来获取指定下标范围内的元素，将每页的数据存储在一个list中，然后使用lrange命令获取对应页码的数据。</p> 
<p>举个例子，假设我们有一个名为“users”的list，其中存储了所有用户的信息，每个用户信息用一个JSON字符串表示。我们需要将所有用户信息分页展示，每页展示10条数据。我们可以按以下步骤实现：</p> 
<ol><li>将所有用户信息存储在“users”列表中，使用lpush命令将每个用户信息作为一个元素插入到列表的头部：</li></ol> 
<pre><code>lpush users {"id":1,"name":"Alice","age":25}
lpush users {"id":2,"name":"Bob","age":30}
lpush users {"id":3,"name":"Charlie","age":20}
......
</code></pre> 
<ol start="2"><li>获取总的用户数量，计算总页数：</li></ol> 
<pre><code>llen users  // 获取用户总数
// 假设返回值为40，总页数为4页
</code></pre> 
<ol start="3"><li>将每页的数据存储在一个新的列表中：</li></ol> 
<pre><code>// 获取第一页数据并存储到“users:page:1”列表中
lrange users 0 9 &gt; users:page:1
// 获取第二页数据并存储到“users:page:2”列表中
lrange users 10 19 &gt; users:page:2
// 获取第三页数据并存储到“users:page:3”列表中
lrange users 20 29 &gt; users:page:3
// 获取第四页数据并存储到“users:page:4”列表中
lrange users 30 39 &gt; users:page:4
</code></pre> 
<ol start="4"><li>根据页码获取对应的数据：</li></ol> 
<pre><code>// 获取第一页的数据
lrange users:page:1 0 9
// 获取第二页的数据
lrange users:page:2 0 9
// 获取第三页的数据
lrange users:page:3 0 9
// 获取第四页的数据
lrange users:page:4 0 9
</code></pre> 
<p>这样就实现了基于Redis list的分页查询。需要注意的是，每次数据更新后，需要重新计算总页数和重新生成每页数据的列表。</p> 
<h3><a id="_Redis_ListListList_149"></a>四. 消息通知：由于Redis List支持阻塞式弹出元素，并且支持多个客户端同时阻塞在同一个List上，因此可以用来实现消息通知。例如，将需要推送给用户的消息存储在一个List中，多个客户端则通过阻塞式地弹出元素来获取消息通知。</h3> 
<p>Redis的list数据结构可以用来实现消息通知功能。具体实现方式是，将消息作为列表中的一个元素存储在Redis中，当需要通知某个用户时，将消息从列表中删除，并将其发送给该用户。</p> 
<p>例如，假设有一个在线商城，用户可以在上面购买商品。当用户购买商品成功后，系统需要向用户发送订单确认消息。这时，系统可以将消息存储在Redis的一个列表中，例如名为“orders”的列表。当需要通知用户时，系统可以使用Redis的lpop命令将消息从“orders”列表中删除并发送给用户。</p> 
<p>具体实现步骤如下：</p> 
<ol><li>在Redis中创建一个名为“orders”的列表。</li><li>当用户购买商品成功后，将订单确认消息作为一个元素添加到“orders”列表中，使用Redis的rpush命令。</li><li>当需要通知用户时，使用Redis的lpop命令将“orders”列表中的第一个元素弹出，并发送给用户。</li><li>如果“orders”列表为空，则等待新的订单确认消息。</li></ol> 
<p>示例代码如下：</p> 
<pre><code class="prism language-python"><span class="token keyword">import</span> redis

<span class="token comment"># 连接Redis数据库</span>
r <span class="token operator">=</span> redis<span class="token punctuation">.</span>Redis<span class="token punctuation">(</span>host<span class="token operator">=</span><span class="token string">'localhost'</span><span class="token punctuation">,</span> port<span class="token operator">=</span><span class="token number">6379</span><span class="token punctuation">,</span> db<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span>

<span class="token comment"># 添加订单确认消息到Redis的“orders”列表中</span>
r<span class="token punctuation">.</span>rpush<span class="token punctuation">(</span><span class="token string">'orders'</span><span class="token punctuation">,</span> <span class="token string">'您的订单已确认，订单号为123456。'</span><span class="token punctuation">)</span>

<span class="token comment"># 从Redis的“orders”列表中取出第一个消息并发送给用户</span>
message <span class="token operator">=</span> r<span class="token punctuation">.</span>lpop<span class="token punctuation">(</span><span class="token string">'orders'</span><span class="token punctuation">)</span>
send_message_to_user<span class="token punctuation">(</span>message<span class="token punctuation">)</span>
</code></pre> 
<h3><a id="_Redis_ListList_181"></a>五. 消息队列：由于Redis List支持阻塞式弹出元素，因此可以用来实现消息队列。生产者将消息推入List中，消费者则通过阻塞式地弹出元素来获取消息。</h3> 
<p>Redis list可以很好地实现消息队列的功能。当我们需要处理某些任务时，可以将任务以消息的形式添加到Redis list的尾部，然后从Redis list的头部取出消息进行处理。这样可以实现先进先出的任务处理顺序。</p> 
<p>具体实现步骤如下：</p> 
<ol><li>创建Redis list：</li></ol> 
<p>使用Redis命令<code>LPUSH</code>或<code>RPUSH</code>可以向Redis list的头部或尾部添加元素，可以使用<code>LPUSH</code>创建一个空的Redis list：</p> 
<pre><code>
```powershell
LPUSH task_queue
</code></pre> 
<pre><code>
2. 添加任务：

使用`RPUSH`命令将任务添加到Redis list的尾部：

</code></pre> 
<pre><code class="prism language-powershell">
RPUSH task_queue <span class="token string">"task1"</span>
RPUSH task_queue <span class="token string">"task2"</span>
RPUSH task_queue <span class="token string">"task3"</span>
</code></pre> 
<pre><code>
</code></pre> 
<ol start="3"><li>取出任务：</li></ol> 
<p>使用<code>LPOP</code>命令从Redis list的头部取出任务进行处理：</p> 
<pre><code>
```powershell
task = LPOP task_queue
</code></pre> 
<pre><code>
4. 处理任务：

对取出的任务进行处理，例如执行一个函数：


```python
def process_task(task):
    print("Processing task: {}".format(task))

process_task(task)
</code></pre> 
<ol start="5"><li>循环处理任务：</li></ol> 
<p>可以使用一个循环来不断地从Redis list中取出任务进行处理：</p> 
<pre><code>while True:
    task = LPOP task_queue
    if task is None:
        break
    process_task(task)
</code></pre> 
<p>这样就可以实现一个简单的消息队列。举个例子，假设我们有一个在线商城，需要处理用户的订单。我们可以将用户的订单信息作为消息添加到Redis list中，然后从Redis list中取出订单进行处理。具体的实现可以参考以下代码：</p> 
<pre><code>import redis

# 创建Redis连接
r = redis.Redis(host='localhost', port=6379, db=0)

# 添加订单
r.rpush('order_queue', 'order1')
r.rpush('order_queue', 'order2')
r.rpush('order_queue', 'order3')

# 处理订单
def process_order(order):
    print("Processing order: {}".format(order))

while True:
    order = r.lpop('order_queue')
    if order is None:
        break
    process_order(order)
</code></pre> 
<p>这样就可以实现一个简单的订单处理系统了。</p> 
<h3><a id="_RedisListList_278"></a>六. 列表：Redis的List是一个双向链表，可以在列表两端进行快速的插入和删除操作。因此，List可以用来实现队列、栈等数据结构。</h3> 
<p>Redis list是一种数据结构，用于存储有序的字符串列表。它允许在列表的两端执行插入和删除操作，因此可以用于队列、堆栈和双端队列的实现。</p> 
<p>在Redis中，list被实现为一个链表，每个节点都包含一个字符串值，以及指向前一个和后一个节点的指针。可以使用LPUSH和RPUSH命令在列表的左侧或右侧插入一个或多个元素，使用LPOP和RPOP命令从列表的左侧或右侧删除元素。还可以使用LINDEX命令获取列表中指定索引位置的元素，使用LLEN命令获取列表的长度。</p> 
<p>以下是一个简单的示例，展示如何在Redis中使用list：</p> 
<pre><code># 连接Redis
$ redis-cli

# 在列表的左侧插入两个元素
127.0.0.1:6379&gt; LPUSH mylist "hello"
(integer) 1
127.0.0.1:6379&gt; LPUSH mylist "world"
(integer) 2

# 在列表的右侧插入一个元素
127.0.0.1:6379&gt; RPUSH mylist "!"
(integer) 3

# 获取列表的长度
127.0.0.1:6379&gt; LLEN mylist
(integer) 3

# 获取列表的第二个元素
127.0.0.1:6379&gt; LINDEX mylist 1
"hello"

# 从列表的左侧删除一个元素
127.0.0.1:6379&gt; LPOP mylist
"world"

# 获取剩余的两个元素
127.0.0.1:6379&gt; LRANGE mylist 0 -1
1) "hello"
2) "!"
</code></pre> 
<h3><a id="_Redislistpushlistlist_318"></a>七. 实现轮询队列：Redis的list还可以用来实现轮询队列。比如说，在在线客服系统中，我们可以将客户发送过来的消息push到一个list中，并由多个客服进程并发地从list中获取消息进行回复。这种方式既能够保证每个消息都会被处理到，又能够提高客服回复效率。</h3> 
<p>Redis List可以很方便地实现轮询队列。具体实现方法是：将需要轮询的元素放入Redis List中，然后使用RPOP命令弹出最后一个元素并将其插入到列表的开头，从而实现轮询。</p> 
<p>举个例子，假设我们有一个需要轮询的任务列表，其中包含了4个任务，编号分别为1，2，3和4。我们可以将这些任务依次插入Redis List中：</p> 
<pre><code>RPUSH task_list 1
RPUSH task_list 2
RPUSH task_list 3
RPUSH task_list 4
</code></pre> 
<p>然后，我们可以使用RPOP命令弹出最后一个任务，并将其插入到列表的开头，从而实现轮询。例如，我们可以执行以下命令：</p> 
<pre><code>RPOP task_list
LPUSH task_list 1
</code></pre> 
<p>这样，我们就将任务4弹出，并将其插入到了列表的开头，变成了下一次轮询的第一个任务。接下来，我们再次执行RPOP和LPUSH命令，就可以得到轮询的下一个任务：</p> 
<pre><code>RPOP task_list
LPUSH task_list 2
</code></pre> 
<p>以此类推，我们可以一直使用RPOP和LPUSH命令进行轮询，直到任务列表中的所有任务都被处理完毕。</p> 
<h3><a id="_Rediskeylistpushlistlistpop_348"></a>八. 实现缓存淘汰策略：Redis支持设置key过期时间，但是在某些情况下，我们也可以使用list来实现缓存淘汰策略。比如说，在缓存系统中，我们可以将需要缓存的数据push到一个list中，并设置list的长度为一定值，当需要插入新数据时就可以将最早插入的数据pop出去，从而实现缓存淘汰。</h3> 
<h3><a id="_RedislistpushlistRedissorted_set_350"></a>九. 实现任务调度：Redis的list还可以用来实现任务调度。比如说，在电商网站中，我们可以将需要发送邮件或短信通知的订单信息push到一个list中，并设置每个订单需要执行通知任务的时间戳。然后使用Redis提供的sorted set结构体按照时间戳排序获取需要执行通知任务的订单信息。</h3> 
<p>Redis List可以用来实现任务调度，具体实现方法如下：</p> 
<ol><li> <p>在Redis中创建一个List，用来存储要执行的任务。</p> </li><li> <p>每个任务都是一个字符串，可以包含任务的名称、参数等信息。</p> </li><li> <p>使用LPUSH命令将任务添加到List中。</p> </li><li> <p>使用BRPOP命令从List中取出任务，执行任务后再将任务从List中删除。</p> </li><li> <p>如果任务执行失败，可以使用LPUSH命令将任务重新添加到List中。</p> </li></ol> 
<p>举个例子，假设我们需要每隔一段时间执行一次任务，任务的具体内容为向指定的手机号发送一条短信。可以将要发送的短信内容和手机号拼接成一个字符串，然后使用LPUSH命令将任务添加到Redis List中。然后使用BRPOP命令从List中取出任务，执行任务后再将任务从List中删除。如果短信发送失败，则可以使用LPUSH命令将任务重新添加到List中，等待下一次执行。</p> 
<p>例如，向手机号码为13888888888发送内容为“Hello Redis”的短信任务可以表示为字符串“send_sms 13888888888 Hello Redis”，然后将该字符串使用LPUSH命令添加到Redis List中。当需要执行该任务时，使用BRPOP命令从List中取出任务，并解析出手机号码和短信内容，然后调用短信发送接口发送短信。如果发送失败，则可以将任务重新添加到List中，等待下一次执行。</p> 
<h3><a id="_Redis_ListListList_368"></a>十. 排行榜：由于Redis List支持按照索引访问元素，并且支持对List进行排序，因此可以用来实现排行榜。例如，在一个List中存储用户的积分信息，并按照积分从高到低排序。</h3> 
<p>Redis list可以用来实现排行榜，具体实现方式如下：</p> 
<ol><li>使用Redis的有序集合(sorted set)存储每个元素的得分和成员名。</li><li>将有序集合中的成员名作为元素，得分作为元素的值，存储在Redis list中。</li><li>使用Redis提供的list操作函数，例如LPUSH、LTRIM等，对排行榜进行更新和维护。</li></ol> 
<p>举例来说，我们有一个游戏的得分榜，存储每个玩家的得分和用户名。使用Redis list实现排行榜的步骤如下：</p> 
<ol><li>创建一个有序集合，存储每个玩家的得分和用户名。假设玩家A得分为10，用户名为"playerA"，玩家B得分为20，用户名为"playerB"，则有序集合的命令如下：</li></ol> 
<pre><code>ZADD scores 10 playerA
ZADD scores 20 playerB
</code></pre> 
<ol start="2"><li>将有序集合中的成员名作为元素，得分作为元素的值，存储在Redis list中。假设我们要展示前5名玩家的得分榜，命令如下：</li></ol> 
<pre><code>ZREVRANGE scores 0 4 &gt; scores_list
</code></pre> 
<p>这个命令将有序集合scores中的前5名玩家的得分和用户名取出，按照得分从高到低的顺序存储在Redis list scores_list中。</p> 
<ol start="3"><li>使用Redis提供的list操作函数，例如LPUSH、LTRIM等，对排行榜进行更新和维护。比如，当玩家C得分为30时，我们需要更新排行榜，命令如下：</li></ol> 
<pre><code>ZADD scores 30 playerC
ZREVRANGE scores 0 4 &gt; scores_list
</code></pre> 
<p>这个命令将玩家C的得分和用户名添加到有序集合scores中，然后重新生成前5名的得分榜，存储在Redis list scores_list中。</p> 
<h3><a id="_Redis_ListListList_403"></a>十一. 地理位置：由于Redis List支持按照索引访问元素，并且支持对List进行排序，因此可以用来实现地理位置。例如，在一个List中存储所有用户的经纬度信息，并按照距离从近到远排序，则可以通过取某个范围内的元素来获取附近的用户。</h3> 
<h3><a id="_Redislistpushlistlindex_406"></a>十二. 实现分布式锁：Redis的list还可以用来实现分布式锁。比如说，在分布式系统中，我们可以将获取锁的请求push到一个list中，并通过lindex命令获取第一个请求进行加锁操作。这种方式既能够保证同一时间只有一个进程持有锁，又能够避免死锁等问题。</h3> 
<p>Redis 利用其高效的内存数据库特性，可以实现分布式锁，具体实现可采用 Redis 的 List 数据结构。</p> 
<p>实现过程如下：</p> 
<ol><li> <p>首先，客户端向 Redis 服务器发送 SETNX 命令，请求设置一个键值对，并将其值设置为一个随机的唯一标识符（UUID），用于标识这个锁的持有者。</p> </li><li> <p>如果 SETNX 命令返回 1，说明当前 Redis 实例中不存在这个键，即客户端成功获取锁。此时锁的状态为“已锁定”，客户端可以继续执行共享资源的操作。</p> </li><li> <p>如果 SETNX 命令返回 0，说明当前 Redis 实例中已经存在这个键，即锁已经被其他客户端持有。此时客户端不能获取锁，需要等待一段时间后再次尝试获取锁。</p> </li><li> <p>在客户端完成共享资源的操作后，需要释放锁。客户端向 Redis 服务器发送 DEL 命令，请求删除这个键值对。如果删除成功，说明客户端成功释放了锁。</p> </li></ol> 
<p>实例：</p> 
<p>假设现在有两个客户端 A 和 B 需要共享资源，他们通过 Redis 实现分布式锁。</p> 
<ol><li> <p>客户端 A 向 Redis 发送 SETNX 命令，请求设置 key = “lock”，value = “uuid_A”。Redis 返回 1，客户端 A 成功获取锁。</p> </li><li> <p>客户端 B 向 Redis 发送 SETNX 命令，请求设置 key = “lock”，value = “uuid_B”。Redis 返回 0，客户端 B 获取锁失败。</p> </li><li> <p>客户端 A 完成操作后，向 Redis 发送 DEL 命令，请求删除 key = “lock”。Redis 返回 1，客户端 A 成功释放锁。</p> </li><li> <p>客户端 B 再次向 Redis 发送 SETNX 命令，请求设置 key = “lock”，value = “uuid_B”。Redis 返回 1，客户端 B 成功获取锁。</p> </li></ol> 
<p>通过这种方式，客户端 A 和客户端 B 可以通过 Redis 实现分布式锁，保证在任意时刻只有一个客户端可以访问共享资源。</p> 
<h3><a id="_Redis_ListList_435"></a>十三. 时间轴：Redis List还可以用来实现时间轴功能。比如微博应用中用户发表一条微博就会被添加到自己的时间轴上，而其他用户关注该用户后也会将其微博添加到自己的时间轴上。这个功能可以通过将每个用户的时间轴作为一个List来实现。</h3> 
<p>Redis List可以实现时间轴，主要是因为List在Redis数据结构中是一个双向链表，可以方便地支持在列表的两端进行插入和删除操作，这使得它非常适合存储和处理时间序列数据。</p> 
<p>具体实现方法是，将每个时间点的数据作为一个列表元素，按照时间顺序依次插入到Redis List中。这样，就可以通过Redis List的左右两端操作来获取时间轴上的数据，例如获取最新的数据、获取最旧的数据、获取某个时间点之后的数据等。</p> 
<p>下面是一个示例，假设我们需要存储一些用户的登录记录，并按照时间顺序展示：</p> 
<ol><li>将每个登录事件作为一个列表元素插入Redis List中，假设我们有3个用户分别在不同的时间点进行了登录：</li></ol> 
<pre><code>LPUSH login_events "User1 login at 2022-01-01 00:01:00"
LPUSH login_events "User2 login at 2022-01-01 00:02:00"
LPUSH login_events "User3 login at 2022-01-01 00:03:00"
</code></pre> 
<ol start="2"><li>获取最新的登录事件：</li></ol> 
<pre><code>LINDEX login_events 0
</code></pre> 
<ol start="3"><li>获取最旧的登录事件：</li></ol> 
<pre><code>LINDEX login_events -1
</code></pre> 
<ol start="4"><li>获取2022-01-01 00:02:00之后的所有登录事件：</li></ol> 
<pre><code>LRANGE login_events 1 -1
</code></pre> 
<p>以上操作都可以通过Redis List的左右两端操作来实现，非常方便实用。<br> Redis list作为时间序列数据存储：Redis list可以被用来存储时间序列数据。例如，在监控系统中，我们可能需要记录某个指标（如CPU利用率、内存使用量等）在一段时间内的变化情况。我们可以将每个采样点表示成一个JSON字符串，并将其添加到Redis list中。然后，我们可以使用LRANGE命令获取某个时间范围内的采样点，并使用自定义脚本对这些采样点进行聚合计算。</p> 
<h3><a id="_Redis_ListListRedisLRU_474"></a>十四. 数据缓存：Redis List还可以用来实现数据缓存功能。比如需要缓存一些数据以加速读取速度，就可以将这些数据作为List中的元素，并且使用Redis提供的LRU淘汰策略控制缓存大小和淘汰过期数据。</h3> 
<p>28.循环队列：Redis list还支持循环操作，即当到达列表末尾时自动回到开头继续添加和弹出元素。这种使用场景常用于缓存池、日志轮换等需要循环利用资源的场景。</p> 
<h3><a id="Redis_listLIFO_481"></a>十五.栈：Redis list还可以被当做栈来使用，即只能在列表的头部添加和弹出元素。这种使用场景常用于浏览器历史记录、撤销操作等需要后进先出（LIFO）的场景。</h3> 
<p>Redis list可以很方便地实现栈的功能，因为它支持在列表头部进行元素的添加和弹出操作。具体来说，可以使用LPUSH命令向列表头部添加元素，使用LPOP命令从列表头部弹出元素。这样就可以实现后进先出的栈功能。</p> 
<p>举个例子，假设我们要实现一个浏览器的历史记录功能。每当用户访问一个新的网页时，就将该网页的URL添加到历史记录中，同时限制历史记录的长度为10。当用户点击浏览器的“后退”按钮时，就从历史记录中弹出最近访问的网页，并将该网页的URL显示在浏览器中。</p> 
<p>使用Redis list可以很方便地实现这个功能。具体步骤如下：</p> 
<ol><li>使用LPUSH命令将当前访问的网页URL添加到列表头部。</li></ol> 
<pre><code>LPUSH history https://www.google.com
</code></pre> 
<ol start="2"><li>使用LPOP命令从列表头部弹出最近访问的网页URL。</li></ol> 
<pre><code>LPOP history
</code></pre> 
<ol start="3"><li>在浏览器中显示弹出的网页URL。</li></ol> 
<p>通过这种方式，就可以轻松地实现浏览器历史记录的功能。类似的，还可以使用Redis list实现其他需要后进先出的场景，比如撤销操作、消息队列等。</p> 
<h3><a id="_503"></a>十六.实时在线用户列表</h3> 
<p>每当有用户登录或退出系统时，都向一个名为online_users的List中添加或删除该用户ID。通过lrange命令获取在线用户列表。</p> 
<p>Redis list可以很好地实现实时在线用户列表。具体实现方法是，每当一个用户登录或退出系统时，将其信息添加或从Redis list中删除。这样，我们就可以实时地获得在线用户列表。</p> 
<p>下面是一个简单的示例代码，它展示了如何使用Redis list来实现实时在线用户列表：</p> 
<pre><code>import redis

# 连接Redis数据库
r = redis.Redis(host='localhost', port=6379, db=0)

# 将用户添加到在线列表中
def add_user_to_online_list(user_id):
    r.lpush('online_users', user_id)

# 将用户从在线列表中删除
def remove_user_from_online_list(user_id):
    r.lrem('online_users', 1, user_id)

# 获取在线用户列表
def get_online_user_list():
    return r.lrange('online_users', 0, -1)
</code></pre> 
<p>在这个示例代码中，我们使用Redis的lpush和lrem命令来添加和删除用户信息。同时，我们还使用lrange命令来获取在线用户列表。lrange命令可以接受两个参数，分别是起始和结束位置。我们使用0和-1作为这两个参数的值，这意味着我们要获取整个列表。</p> 
<p>这样，我们就可以实时地获得在线用户列表了。当用户登录或退出系统时，我们只需要调用add_user_to_online_list或remove_user_from_online_list函数即可。</p> 
<p>例如，如果用户A、B、C和D都在线，那么我们可以通过调用get_online_user_list函数来获得在线用户列表：</p> 
<pre><code>&gt;&gt;&gt; get_online_user_list()
[b'D', b'C', b'B', b'A']
</code></pre> 
<p>当用户B退出系统时，我们可以调用remove_user_from_online_list函数来将其从在线列表中删除：</p> 
<pre><code>&gt;&gt;&gt; remove_user_from_online_list('B')
1
</code></pre> 
<p>现在，我们再次调用get_online_user_list函数来查看在线用户列表：</p> 
<pre><code>&gt;&gt;&gt; get_online_user_list()
[b'D', b'C', b'A']
</code></pre> 
<p>可以看到，用户B已经从在线列表中删除了。</p> 
<h3><a id="_556"></a>十七.秒杀活动抢购</h3> 
<p>将商品数量作为一个值存储在Redis中，并使用incrby/decrby命令对其进行原子性操作。同时将参与抢购的用户ID存储在Set中，避免重复参与。</p> 
<p>Redis list可以很好地实现实杀活动抢购。具体方式是将商品数量作为一个值存储在Redis中，并使用incrby/decrby命令对其进行原子性操作。同时，将参与抢购的用户ID存储在Set中，避免重复参与。</p> 
<p>举例来说，假设有一个限量100件的商品，需要进行实杀活动抢购。首先在Redis中创建一个key为"goods:count"的值，初始值为100。当用户抢购成功时，使用decrby命令将商品数量减1。如果商品数量已经为0，则抢购失败。</p> 
<p>同时，还需要将参与抢购的用户ID存储在Redis的Set中。使用sadd命令将用户ID添加到Set中，如果用户已经存在，则表示该用户已经参与过抢购，不能重复参与。</p> 
<p>在实际应用中，可以使用Redis分布式锁来避免多个用户同时抢购同一件商品的问题。在抢购开始前，使用setnx命令获取锁，抢购结束后再使用del命令释放锁。这样可以确保同时只有一个用户进行抢购，避免超卖和重复抢购的问题。</p> 
<p>总之，Redis list可以很好地实现实杀活动抢购，具有高效、稳定、原子性等优点。</p> 
<h3><a id="_569"></a>十八.延迟任务队列</h3> 
<p>将需要延迟执行的任务按照执行时间放入Sorted Set中，然后启动一个定时器轮询Sorted Set，取出当前需要执行的任务并放入List中，再由Worker线程从List中取出任务并执行。</p> 
<p>Redis可以使用list数据结构来实现延迟任务队列。其基本思路是将任务按照执行时间先后顺序加入到list中，并使用Redis的sorted set数据结构来存储任务的执行时间和任务的ID，sorted set的score为任务执行的时间戳，value为任务ID。每次从sorted set中取出第一个任务，判断是否到了执行时间，如果到了则将任务从sorted set中删除，并将任务从list中弹出，执行任务中的操作。</p> 
<p>以下是一个使用Redis list实现延迟任务队列的简单示例：</p> 
<ol><li>将任务加入到延迟任务队列中</li></ol> 
<pre><code># 任务执行时间为5秒后
timestamp = int(time.time()) + 5

# 任务ID为1
task_id = 1

# 将任务ID添加到sorted set中，score为执行时间戳
redis.zadd('tasks', {task_id: timestamp})

# 将任务ID添加到list中
redis.rpush('task_queue', task_id)
</code></pre> 
<ol start="2"><li>检查任务是否需要执行</li></ol> 
<pre><code># 从sorted set中取出第一个任务
task_id = redis.zrange('tasks', 0, 0, withscores=True)[0][0]
timestamp = redis.zscore('tasks', task_id)

# 如果任务的执行时间已经到了，则从sorted set和list中删除该任务，并执行任务中的操作
if timestamp &lt;= int(time.time()):
    redis.zrem('tasks', task_id)
    redis.lrem('task_queue', 0, task_id)
    perform_task(task_id)
</code></pre> 
<ol start="3"><li>执行任务中的操作</li></ol> 
<pre><code>def perform_task(task_id):
    # 执行任务中的操作
    print('Perform task:', task_id)
</code></pre> 
<h3><a id="RedisListworkerListworkerList_614"></a>十九.异步任务：通过将任务信息存储在Redis的List中，并使用多个worker进程来处理这些任务，可以实现异步任务处理。生产者向List中添加任务信息，worker进程则从List中取出任务并执行。</h3> 
<h3><a id="RedisRedis_ListListRedis_616"></a>二十.流水线操作：由于Redis支持管道操作，因此我们可以使用Redis List进行流水线操作。将需要执行的多个命令按顺序存储在List中，并通过一次性发送给Redis服务器来减少网络延迟和通信开销。</h3> 
<h3><a id="RedisListList_618"></a>二十一.实时聊天室：Redis的List可以作为聊天室中消息的缓存区域。每当有用户发送一条新消息时，就将该消息添加到聊天室对应的List中，并通过订阅/发布机制将该消息广播给所有在线用户。</h3>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5b008538e3fc03829edc65597066cf67/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">笔记本电脑没有声音怎么办？5个必会方法分享</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/deccd0af1bdf7f991fc2d3cb4d132fc4/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">微信小程序开发-云数据库Excel转JSON格式导入</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>