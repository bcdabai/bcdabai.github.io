<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>REST端点，可使用Apache Camel进行集成 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="REST端点，可使用Apache Camel进行集成" />
<meta property="og:description" content="REST是一种用于组织资源的体系结构样式，当应用于基于HTTP的服务时，REST可以构建无状态的，解耦的，可伸缩的服务。 HTTP方法，HTTP标头和mime类型都允许开发人员实现REST样式。 诸如Jersey和Fuse Services Framework（Apache CXF）之类的框架可用于加快服务的开发和部署，以尝试实现RESTful风格，在本博文中，我想讨论如何构建资源的后端，依赖于Fuse中介路由器（也称为Apache Camel）提供的集成。 顺便说一句，对于那些想知道您的体系结构确实是RESTful还是REST试图缓解的高度耦合的RPC风格的人，也许我很感兴趣。 关于REST撰写论文的Roy Fielding积极主张资源表示中的超链接对于REST风格必不可少的观点，甚至进一步阐明了实现REST的不确定性。 该示例的源代码可以在我的github存储库中找到 Fuse中介路由器是FuseSource的企业级硬化版Apache Camel，提供了舒适的DSL，用于描述集成，中介和路由。 它是免费的开放源代码，并具有Apache许可证。 对于那些不熟悉Mediation Router / Camel的人，请看DZone企业集成区Apache Camel：Integration Nirvana的 Jon Anstey（ Camel in Action的合著者）的介绍。 我们将使用中介路由器来帮助在REST端点和文件系统上的资源文件之间编写简单的集成。 我将使用camel-cxfrs组件公开REST端点，并将使用camel-file组件读取文件系统上的目录。 该样本的目的是描述必要的配置，以通过中介路由器公开REST接口，以某种方式与后端集成，将数据转换为适当的REST响应并发送回该响应。 首先，让我们专注于如何设置REST端点。 为此，您将创建一个JAX-RS资源，该资源描述将用作REST端点的java方法。 此样本代码要求熟悉RESTful Web服务 （又称JAX-RS）的Java API 。 对于那些不熟悉的人，这里有一些不错的教程，可以帮助您理解JAX-RS。 @Path(&#34;/customerservice/&#34;) public class CustomerServiceResource { // NOTE: The instance member variables will not be available to the // Camel Exchange. They must be used as method parameters for them to // be made available @Context private UriInfo uriInfo; public CustomerServiceResource() { } @GET @Path(&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/f50ba7bc5f92766f17e55da5ed2eb226/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-05-08T12:33:03+08:00" />
<meta property="article:modified_time" content="2020-05-08T12:33:03+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">REST端点，可使用Apache Camel进行集成</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div class="entry" style="font-size: 16px;"> 
 <div class="e3lan-post"> 
  <div> 
   <span class="bt-uid-tg"></span> 
  </div> 
 </div> 
 <div dir="ltr"> 
  REST是一种用于组织资源的体系结构样式，当应用于基于HTTP的服务时，REST可以构建无状态的，解耦的，可伸缩的服务。 
  HTTP方法，HTTP标头和mime类型都允许开发人员实现REST样式。 
  诸如<a href="https://jersey.java.net/" rel="nofollow">Jersey</a>和<a href="http://fusesource.com/products/enterprise-cxf/" rel="nofollow">Fuse Services Framework（Apache CXF）之类的框架</a>可用于加快服务的开发和部署，以尝试实现RESTful风格，在本博文中，我想讨论如何构建资源的后端，依赖于<a href="http://fusesource.com/products/enterprise-camel/" rel="nofollow">Fuse中介路由器（</a>也称为<a href="https://camel.apache.org/" rel="nofollow">Apache Camel）</a>提供的集成。 
  <p> 顺便说一句，对于那些想知道您的体系结构确实是RESTful还是REST试图缓解的高度耦合的RPC风格的人，也许我很感兴趣。 关于REST撰写论文的Roy Fielding积极主张<a href="http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven" rel="nofollow">资源表示中的超链接</a>对于REST风格<a href="http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven" rel="nofollow">必不可少</a>的观点，甚至进一步阐明了实现REST的不确定性。 </p> 
  <p> 该示例的源代码可以<a href="https://github.com/christian-posta/file-rest-blog">在我的github存储库中</a>找到 </p> 
  <p> <a href="http://fusesource.com/products/enterprise-camel/" rel="nofollow">Fuse中介路由器</a>是<a href="http://architects.dzone.com/articles/apache-camel-integration" rel="nofollow">FuseSource的</a>企业级硬化版Apache Camel，提供了舒适的DSL，用于描述集成，中介和路由。 它是免费的开放源代码，并具有Apache许可证。 对于那些不熟悉Mediation Router / Camel的人，请看DZone企业集成区<a href="http://architects.dzone.com/articles/apache-camel-integration" rel="nofollow">Apache Camel：Integration Nirvana的</a> Jon Anstey（ <a href="https://www.amazon.com/gp/product/1935182366/ref=as_li_ss_tl?ie=UTF8&amp;tag=christianc0aa-20&amp;linkCode=as2&amp;camp=1789&amp;creative=390957&amp;creativeASIN=1935182366" rel="nofollow">Camel in Action的</a>合著者）的介绍。 </p> 
  <p> 我们将使用中介路由器来帮助在REST端点和文件系统上的资源文件之间编写简单的集成。 我将使用<a href="http://fusesource.com/docs/router/2.8/component_ref/_IDU_CXFRS.html" rel="nofollow">camel-cxfrs</a>组件公开REST端点，并将使用<a href="http://fusesource.com/docs/router/2.8/component_ref/_IDU_File2.html" rel="nofollow">camel-file</a>组件读取文件系统上的目录。 该样本的目的是描述必要的配置，以通过中介路由器公开REST接口，以某种方式与后端集成，将数据转换为适当的REST响应并发送回该响应。 </p> 
  <p> 首先，让我们专注于如何设置REST端点。 为此，您将创建一个JAX-RS资源，该资源描述将用作REST端点的java方法。 此样本代码要求熟悉<a href="https://jcp.org/en/jsr/detail?id=311" rel="nofollow">RESTful Web服务</a> （又称JAX-RS）的<a href="https://jcp.org/en/jsr/detail?id=311" rel="nofollow">Java API</a> 。 对于那些不熟悉的人，这里有一些<a href="http://www.mkyong.com/tutorials/jax-rs-tutorials/" rel="nofollow">不错的教程，</a>可以帮助您理解JAX-RS。 </p> 
  <pre class="has"><code class="notranslate brush:java">@Path("/customerservice/")
public class CustomerServiceResource {

// NOTE: The instance member variables will not be available to the
// Camel Exchange. They must be used as method parameters for them to
// be made available
@Context
private UriInfo uriInfo;

public CustomerServiceResource() {
}

@GET
@Path("/customers/{id}/")
@Produces("text/xml")
public Customer getCustomer(@PathParam("id") String id) {
    return null;
}

@PUT
@Path("/customers/")
public Response updateCustomer(Customer customer) {
    return null;
}

}</code></pre> 
  <p> 如您所见，注释是JAX-RS注释，用于描述REST端点所涉及的操作，HTTP方法和mime类型。 注意，返回值全为空，因为此类实际上将不会用于处理进入端点的请求。 中介路由器路由将负责处理和响应。 但是请注意，实例成员不可用于中介路由器交换，即，通过JAX-RS @Context注释注入的任何实例成员将不可用。 要使它们可用，请将它们作为参数添加到您的方法中。 </p> 
  <p> 可以使用以下两种方法之一来声明使用中介路由器的CXF-RS端点：直接在端点配置中，如下所示： </p> 
  <pre class="has"><code class="notranslate brush:java">from("cxfrs://http://localhost:9090/route?resourceClasses=com.fusesource.samples.CustomerServiceResource")</code></pre> 
  <p> 直接在配置中创建它需要较少的xml配置，但灵活性有限。 另一个选择是创建一个负责端点的单独的bean，然后在端点配置中引用它： </p> 
  <pre class="has"><code class="notranslate brush:java">from("cxfrs:bean:rsServer")</code></pre> 
  <p> Bean <em>rsServer</em>应该在骆驼上下文中定义。 例如： </p> 
  <pre class="has"><code class="notranslate brush:xml">&lt;cxf:rsServer id="rsServer" address="http://localhost:9090/route"
              serviceClass="com.fusesource.samples.CustomerServiceResource"/&gt;</code></pre> 
  <p> 这种方法允许您解耦端点配置，并允许端点配置更快，更省力。 尽管使用了第一个选项，但两个选项都显示在示例代码中。 </p> 
  <p> 这就是使用中介路由器公开REST端点所需的全部配置。 很简单。 下一步是根据来自REST端点的内容来使用文件系统中的文件。 该文件的内容将返回给REST调用的客户端。 为此，我们使用<a href="http://fusesource.com/docs/router/2.8/component_ref/_IDU_File2.html" rel="nofollow">骆驼文件</a>组件，并通过DSL中的<a href="http://fusesource.com/docs/router/2.8/apidoc/org/apache/camel/model/ProcessorDefinition.html#pollEnrich%28java.lang.String%29" rel="nofollow">pollEnrich</a>调用丰富Exchange： </p> 
  <pre class="has"><code class="notranslate brush:java">.setHeader(Exchange.FILE_NAME, simple("test-${body}.xml"))
.pollEnrich("file:src/data?noop=true", 1000, new CustomerEnricher())</code></pre> 
  <p> 我们不能在pollEnrich调用中使用任何动态表达式，因此我们在设置扩展之前设置文件组件可以理解的标头。 在这种情况下，REST消息的主体是可用于对文件系统资源进行模板化的标识符。 </p> 
  <p> 最后，我们可以对路线进行一些附加处理： </p> 
  <pre class="has"><code class="notranslate brush:java">.process(new CustomerServiceProcessor())</code></pre> 
  <p> 如上所述，该示例的目的是显示如何配置终结点并将其附加到进一步的中介路由器处理中。 请注意，REST端点的消息交换模式（MEP）为InOut并期望响应。 该示例并不意味着是完整的端到端解决方案，因为该解决方案将根据预期的功能而有所不同。 请注意上面有关<a href="http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven" rel="nofollow">Roy</a>关于什么是REST和不是REST <a href="http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven" rel="nofollow">的讨论</a>的链接。 </p> 
  <p> 如果我遗漏了一些内容，或者您​​需要对示例进行更多说明，请给我评论，我们可以进行讨论。 </p> 
  <p> <strong><i class="raw_i_node">参考：</i></strong>来自<a href="http://www.christianposta.com/blog/" rel="nofollow">Christian Posta Software</a>博客的<a href="//www.javacodegeeks.com/p/jcg.html" rel="nofollow">JCG合作伙伴</a> Christian Posta <a href="http://www.christianposta.com/blog/?p=229" rel="nofollow">使用Apache Camel进行集成的REST端点</a> 。 </p> 
 </div> 
 <br> 
 <blockquote> 
  <p>翻译自: <a href="https://www.javacodegeeks.com/2012/05/rest-endpoint-for-integration-using.html" rel="nofollow">https://www.javacodegeeks.com/2012/05/rest-endpoint-for-integration-using.html</a></p> 
 </blockquote> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4d2965154b4d2806062c85aca9ce878e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">资料有点多4412开发板</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ddd897070cd2c07319b8793a19def754/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">使用ZeroMemory、memset对结构体、数组的初始化</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>