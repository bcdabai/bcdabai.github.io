<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java面试问题和答案（三） - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Java面试问题和答案（三）" />
<meta property="og:description" content="1.HashMap和HashTable有何不同？
（1）HashMap允许key和value为null，而HashTable不允许。
（2）HashTable是同步的，而HashMap不是。所以HashMap适合单线程环境，HashTable适合多线程环境。
（3）在Java1.4中引入了LinkedHashMap，HashMap的一个子类，假如你想要遍历顺序，你很容易从HashMap转向LinkedHashMap，但是HashTable不是这样的，它的顺序是不可预知的。
（4）HashMap提供对key的Set进行遍历，因此它是fail-fast的，但HashTable提供对key的Enumeration进行遍历，它不支持fail-fast。
（5）HashTable被认为是个遗留的类，如果你寻求在迭代的时候修改Map，你应该使用CocurrentHashMap。
2.如何决定选用HashMap还是TreeMap？
对于在Map中插入、删除和定位元素这类操作，HashMap是最好的选择。然而，假如你需要对一个有序的key集合进行遍历，TreeMap是更好的选择。基于你的collection的大小，也许向HashMap中添加元素会更快，将map换为TreeMap进行有序key的遍历。
3.ArrayList和Vector有何异同点？
ArrayList和Vector在很多时候都很类似。
（1）两者都是基于索引的，内部由一个数组支持。
（2）两者维护插入的顺序，我们可以根据插入顺序来获取元素。
（3）ArrayList和Vector的迭代器实现都是fail-fast的。
（4）ArrayList和Vector两者允许null值，也可以使用索引值对元素进行随机访问。
以下是ArrayList和Vector的不同点。
（1）Vector是同步的，而ArrayList不是。然而，如果你寻求在迭代的时候对列表进行改变，你应该使用CopyOnWriteArrayList。
（2）ArrayList比Vector快，它因为有同步，不会过载。
（3）ArrayList更加通用，因为我们可以使用Collections工具类轻易地获取同步列表和只读列表。
4.Array和ArrayList有何区别？什么时候更适合用Array？
Array可以容纳基本类型和对象，而ArrayList只能容纳对象。
Array是指定大小的，而ArrayList大小是固定的。
Array没有提供ArrayList那么多功能，比如addAll、removeAll和iterator等。尽管ArrayList明显是更好的选择，但也有些时候Array比较好用。
（1）如果列表的大小已经指定，大部分情况下是存储和遍历它们。
（2）对于遍历基本数据类型，尽管Collections使用自动装箱来减轻编码任务，在指定大小的基本类型的列表上工作也会变得很慢。
（3）如果你要使用多维数组，使用[][]比List&lt;List&lt;&gt;&gt;更容易。
5.ArrayList和LinkedList有何区别？
ArrayList和LinkedList两者都实现了List接口，但是它们之间有些不同。
（1）ArrayList是由Array所支持的基于一个索引的数据结构，所以它提供对元素的随机访问，复杂度为O(1)，但LinkedList存储一系列的节点数据，每个节点都与前一个和下一个节点相连接。所以，尽管有使用索引获取元素的方法，内部实现是从起始点开始遍历，遍历到索引的节点然后返回元素，时间复杂度为O(n)，比ArrayList要慢。
（2）与ArrayList相比，在LinkedList中插入、添加和删除一个元素会更快，因为在一个元素被插入到中间的时候，不会涉及改变数组的大小，或更新索引。
（3）LinkedList比ArrayList消耗更多的内存，因为LinkedList中的每个节点存储了前后节点的引用。
6.哪些集合类提供对元素的随机访问？
ArrayList、HashMap、TreeMap和HashTable类提供对元素的随机访问。
27.EnumSet是什么？
java.util.EnumSet是使用枚举类型的集合实现。当集合创建时，枚举集合中的所有元素必须来自单个指定的枚举类型，可以是显示的或隐示的。EnumSet是不同步的，不允许值为null的元素。它也提供了一些有用的方法，比如copyOf(Collection c)、of(E first,E…rest)和complementOf(EnumSet s)。
8.哪些集合类是线程安全的？
Vector、HashTable、Properties和Stack是同步类，所以它们是线程安全的，可以在多线程环境下使用。Java1.5并发API包括一些集合类，允许迭代时修改，因为它们都工作在集合的克隆上，所以它们在多线程环境中是安全的。
9.并发集合类是什么？
Java1.5并发包（java.util.concurrent）包含线程安全集合类，允许在迭代时修改集合。迭代器被设计为fail-fast的，会抛出ConcurrentModificationException。一部分类为：CopyOnWriteArrayList、 ConcurrentHashMap、CopyOnWriteArraySet。
10.BlockingQueue是什么？
Java.util.concurrent.BlockingQueue是一个队列，在进行检索或移除一个元素的时候，它会等待队列变为非空；当在添加一个元素时，它会等待队列中的可用空间。BlockingQueue接口是Java集合框架的一部分，主要用于实现生产者-消费者模式。我们不需要担心等待生产者有可用的空间，或消费者有可用的对象，因为它都在BlockingQueue的实现类中被处理了。Java提供了集中BlockingQueue的实现，比如ArrayBlockingQueue、LinkedBlockingQueue、PriorityBlockingQueue,、SynchronousQueue等。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/a998e300e39036f8144f507efd5a6cff/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2015-05-22T14:32:21+08:00" />
<meta property="article:modified_time" content="2015-05-22T14:32:21+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java面试问题和答案（三）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p style="border:0px; margin-top:0px; margin-bottom:20px; padding-top:0px; padding-bottom:0px; font-size:14px; font-family:'Microsoft YaHei',宋体,'Myriad Pro',Lato,'Helvetica Neue',Helvetica,Arial,sans-serif; line-height:21px"> <span style="border:0px; margin:0px; padding:0px">1.HashMap和HashTable有何不同？</span></p> 
<p style="border:0px; margin-top:0px; margin-bottom:20px; padding-top:0px; padding-bottom:0px; font-size:14px; font-family:'Microsoft YaHei',宋体,'Myriad Pro',Lato,'Helvetica Neue',Helvetica,Arial,sans-serif; line-height:21px"> （1）HashMap允许key和value为null，而HashTable不允许。</p> 
<p style="border:0px; margin-top:0px; margin-bottom:20px; padding-top:0px; padding-bottom:0px; font-size:14px; font-family:'Microsoft YaHei',宋体,'Myriad Pro',Lato,'Helvetica Neue',Helvetica,Arial,sans-serif; line-height:21px"> （2）HashTable是同步的，而HashMap不是。所以HashMap适合单线程环境，HashTable适合多线程环境。</p> 
<p style="border:0px; margin-top:0px; margin-bottom:20px; padding-top:0px; padding-bottom:0px; font-size:14px; font-family:'Microsoft YaHei',宋体,'Myriad Pro',Lato,'Helvetica Neue',Helvetica,Arial,sans-serif; line-height:21px"> （3）在Java1.4中引入了LinkedHashMap，HashMap的一个子类，假如你想要遍历顺序，你很容易从HashMap转向LinkedHashMap，但是HashTable不是这样的，它的顺序是不可预知的。</p> 
<p style="border:0px; margin-top:0px; margin-bottom:20px; padding-top:0px; padding-bottom:0px; font-size:14px; font-family:'Microsoft YaHei',宋体,'Myriad Pro',Lato,'Helvetica Neue',Helvetica,Arial,sans-serif; line-height:21px"> （4）HashMap提供对key的Set进行遍历，因此它是fail-fast的，但HashTable提供对key的Enumeration进行遍历，它不支持fail-fast。</p> 
<p style="border:0px; margin-top:0px; margin-bottom:20px; padding-top:0px; padding-bottom:0px; font-size:14px; font-family:'Microsoft YaHei',宋体,'Myriad Pro',Lato,'Helvetica Neue',Helvetica,Arial,sans-serif; line-height:21px"> （5）HashTable被认为是个遗留的类，如果你寻求在迭代的时候修改Map，你应该使用CocurrentHashMap。</p> 
<p style="border:0px; margin-top:0px; margin-bottom:20px; padding-top:0px; padding-bottom:0px; font-size:14px; font-family:'Microsoft YaHei',宋体,'Myriad Pro',Lato,'Helvetica Neue',Helvetica,Arial,sans-serif; line-height:21px"> <span style="border:0px; margin:0px; padding:0px">2.如何决定选用HashMap还是TreeMap？</span></p> 
<p style="border:0px; margin-top:0px; margin-bottom:20px; padding-top:0px; padding-bottom:0px; font-size:14px; font-family:'Microsoft YaHei',宋体,'Myriad Pro',Lato,'Helvetica Neue',Helvetica,Arial,sans-serif; line-height:21px"> 对于在Map中插入、删除和定位元素这类操作，HashMap是最好的选择。然而，假如你需要对一个有序的key集合进行遍历，TreeMap是更好的选择。基于你的collection的大小，也许向HashMap中添加元素会更快，将map换为TreeMap进行有序key的遍历。</p> 
<p style="border:0px; margin-top:0px; margin-bottom:20px; padding-top:0px; padding-bottom:0px; font-size:14px; font-family:'Microsoft YaHei',宋体,'Myriad Pro',Lato,'Helvetica Neue',Helvetica,Arial,sans-serif; line-height:21px"> <span style="border:0px; margin:0px; padding:0px">3.ArrayList和Vector有何异同点？</span></p> 
<p style="border:0px; margin-top:0px; margin-bottom:20px; padding-top:0px; padding-bottom:0px; font-size:14px; font-family:'Microsoft YaHei',宋体,'Myriad Pro',Lato,'Helvetica Neue',Helvetica,Arial,sans-serif; line-height:21px"> ArrayList和Vector在很多时候都很类似。</p> 
<p style="border:0px; margin-top:0px; margin-bottom:20px; padding-top:0px; padding-bottom:0px; font-size:14px; font-family:'Microsoft YaHei',宋体,'Myriad Pro',Lato,'Helvetica Neue',Helvetica,Arial,sans-serif; line-height:21px"> （1）两者都是基于索引的，内部由一个数组支持。</p> 
<p style="border:0px; margin-top:0px; margin-bottom:20px; padding-top:0px; padding-bottom:0px; font-size:14px; font-family:'Microsoft YaHei',宋体,'Myriad Pro',Lato,'Helvetica Neue',Helvetica,Arial,sans-serif; line-height:21px"> （2）两者维护插入的顺序，我们可以根据插入顺序来获取元素。</p> 
<p style="border:0px; margin-top:0px; margin-bottom:20px; padding-top:0px; padding-bottom:0px; font-size:14px; font-family:'Microsoft YaHei',宋体,'Myriad Pro',Lato,'Helvetica Neue',Helvetica,Arial,sans-serif; line-height:21px"> （3）ArrayList和Vector的迭代器实现都是fail-fast的。</p> 
<p style="border:0px; margin-top:0px; margin-bottom:20px; padding-top:0px; padding-bottom:0px; font-size:14px; font-family:'Microsoft YaHei',宋体,'Myriad Pro',Lato,'Helvetica Neue',Helvetica,Arial,sans-serif; line-height:21px"> （4）ArrayList和Vector两者允许null值，也可以使用索引值对元素进行随机访问。</p> 
<p style="border:0px; margin-top:0px; margin-bottom:20px; padding-top:0px; padding-bottom:0px; font-size:14px; font-family:'Microsoft YaHei',宋体,'Myriad Pro',Lato,'Helvetica Neue',Helvetica,Arial,sans-serif; line-height:21px"> 以下是ArrayList和Vector的不同点。</p> 
<p style="border:0px; margin-top:0px; margin-bottom:20px; padding-top:0px; padding-bottom:0px; font-size:14px; font-family:'Microsoft YaHei',宋体,'Myriad Pro',Lato,'Helvetica Neue',Helvetica,Arial,sans-serif; line-height:21px"> （1）Vector是同步的，而ArrayList不是。然而，如果你寻求在迭代的时候对列表进行改变，你应该使用CopyOnWriteArrayList。</p> 
<p style="border:0px; margin-top:0px; margin-bottom:20px; padding-top:0px; padding-bottom:0px; font-size:14px; font-family:'Microsoft YaHei',宋体,'Myriad Pro',Lato,'Helvetica Neue',Helvetica,Arial,sans-serif; line-height:21px"> （2）ArrayList比Vector快，它因为有同步，不会过载。</p> 
<p style="border:0px; margin-top:0px; margin-bottom:20px; padding-top:0px; padding-bottom:0px; font-size:14px; font-family:'Microsoft YaHei',宋体,'Myriad Pro',Lato,'Helvetica Neue',Helvetica,Arial,sans-serif; line-height:21px"> （3）ArrayList更加通用，因为我们可以使用Collections工具类轻易地获取同步列表和只读列表。</p> 
<p style="border:0px; margin-top:0px; margin-bottom:20px; padding-top:0px; padding-bottom:0px; font-size:14px; font-family:'Microsoft YaHei',宋体,'Myriad Pro',Lato,'Helvetica Neue',Helvetica,Arial,sans-serif; line-height:21px"> <span style="border:0px; margin:0px; padding:0px">4.Array和ArrayList有何区别？什么时候更适合用Array？</span></p> 
<p style="border:0px; margin-top:0px; margin-bottom:20px; padding-top:0px; padding-bottom:0px; font-size:14px; font-family:'Microsoft YaHei',宋体,'Myriad Pro',Lato,'Helvetica Neue',Helvetica,Arial,sans-serif; line-height:21px"> Array可以容纳基本类型和对象，而ArrayList只能容纳对象。</p> 
<p style="border:0px; margin-top:0px; margin-bottom:20px; padding-top:0px; padding-bottom:0px; font-size:14px; font-family:'Microsoft YaHei',宋体,'Myriad Pro',Lato,'Helvetica Neue',Helvetica,Arial,sans-serif; line-height:21px"> Array是指定大小的，而ArrayList大小是固定的。</p> 
<p style="border:0px; margin-top:0px; margin-bottom:20px; padding-top:0px; padding-bottom:0px; font-size:14px; font-family:'Microsoft YaHei',宋体,'Myriad Pro',Lato,'Helvetica Neue',Helvetica,Arial,sans-serif; line-height:21px"> Array没有提供ArrayList那么多功能，比如addAll、removeAll和iterator等。尽管ArrayList明显是更好的选择，但也有些时候Array比较好用。</p> 
<p style="border:0px; margin-top:0px; margin-bottom:20px; padding-top:0px; padding-bottom:0px; font-size:14px; font-family:'Microsoft YaHei',宋体,'Myriad Pro',Lato,'Helvetica Neue',Helvetica,Arial,sans-serif; line-height:21px"> （1）如果列表的大小已经指定，大部分情况下是存储和遍历它们。</p> 
<p style="border:0px; margin-top:0px; margin-bottom:20px; padding-top:0px; padding-bottom:0px; font-size:14px; font-family:'Microsoft YaHei',宋体,'Myriad Pro',Lato,'Helvetica Neue',Helvetica,Arial,sans-serif; line-height:21px"> （2）对于遍历基本数据类型，尽管Collections使用自动装箱来减轻编码任务，在指定大小的基本类型的列表上工作也会变得很慢。</p> 
<p style="border:0px; margin-top:0px; margin-bottom:20px; padding-top:0px; padding-bottom:0px; font-size:14px; font-family:'Microsoft YaHei',宋体,'Myriad Pro',Lato,'Helvetica Neue',Helvetica,Arial,sans-serif; line-height:21px"> （3）如果你要使用多维数组，使用[][]比List&lt;List&lt;&gt;&gt;更容易。</p> 
<p style="border:0px; margin-top:0px; margin-bottom:20px; padding-top:0px; padding-bottom:0px; font-size:14px; font-family:'Microsoft YaHei',宋体,'Myriad Pro',Lato,'Helvetica Neue',Helvetica,Arial,sans-serif; line-height:21px"> <span style="border:0px; margin:0px; padding:0px">5.ArrayList和LinkedList有何区别？</span></p> 
<p style="border:0px; margin-top:0px; margin-bottom:20px; padding-top:0px; padding-bottom:0px; font-size:14px; font-family:'Microsoft YaHei',宋体,'Myriad Pro',Lato,'Helvetica Neue',Helvetica,Arial,sans-serif; line-height:21px"> ArrayList和LinkedList两者都实现了List接口，但是它们之间有些不同。</p> 
<p style="border:0px; margin-top:0px; margin-bottom:20px; padding-top:0px; padding-bottom:0px; font-size:14px; font-family:'Microsoft YaHei',宋体,'Myriad Pro',Lato,'Helvetica Neue',Helvetica,Arial,sans-serif; line-height:21px"> （1）ArrayList是由Array所支持的基于一个索引的数据结构，所以它提供对元素的随机访问，复杂度为O(1)，但LinkedList存储一系列的节点数据，每个节点都与前一个和下一个节点相连接。所以，尽管有使用索引获取元素的方法，内部实现是从起始点开始遍历，遍历到索引的节点然后返回元素，时间复杂度为O(n)，比ArrayList要慢。</p> 
<p style="border:0px; margin-top:0px; margin-bottom:20px; padding-top:0px; padding-bottom:0px; font-size:14px; font-family:'Microsoft YaHei',宋体,'Myriad Pro',Lato,'Helvetica Neue',Helvetica,Arial,sans-serif; line-height:21px"> （2）与ArrayList相比，在LinkedList中插入、添加和删除一个元素会更快，因为在一个元素被插入到中间的时候，不会涉及改变数组的大小，或更新索引。</p> 
<p style="border:0px; margin-top:0px; margin-bottom:20px; padding-top:0px; padding-bottom:0px; font-size:14px; font-family:'Microsoft YaHei',宋体,'Myriad Pro',Lato,'Helvetica Neue',Helvetica,Arial,sans-serif; line-height:21px"> （3）LinkedList比ArrayList消耗更多的内存，因为LinkedList中的每个节点存储了前后节点的引用。</p> 
<p style="border:0px; margin-top:0px; margin-bottom:20px; padding-top:0px; padding-bottom:0px; font-size:14px; font-family:'Microsoft YaHei',宋体,'Myriad Pro',Lato,'Helvetica Neue',Helvetica,Arial,sans-serif; line-height:21px"> <span style="border:0px; margin:0px; padding:0px">6.哪些集合类提供对元素的随机访问？</span></p> 
<p style="border:0px; margin-top:0px; margin-bottom:20px; padding-top:0px; padding-bottom:0px; font-size:14px; font-family:'Microsoft YaHei',宋体,'Myriad Pro',Lato,'Helvetica Neue',Helvetica,Arial,sans-serif; line-height:21px"> ArrayList、HashMap、TreeMap和HashTable类提供对元素的随机访问。</p> 
<p style="border:0px; margin-top:0px; margin-bottom:20px; padding-top:0px; padding-bottom:0px; font-size:14px; font-family:'Microsoft YaHei',宋体,'Myriad Pro',Lato,'Helvetica Neue',Helvetica,Arial,sans-serif; line-height:21px"> <span style="border:0px; margin:0px; padding:0px">27.EnumSet是什么？</span></p> 
<p style="border:0px; margin-top:0px; margin-bottom:20px; padding-top:0px; padding-bottom:0px; font-size:14px; font-family:'Microsoft YaHei',宋体,'Myriad Pro',Lato,'Helvetica Neue',Helvetica,Arial,sans-serif; line-height:21px"> java.util.EnumSet是使用枚举类型的集合实现。当集合创建时，枚举集合中的所有元素必须来自单个指定的枚举类型，可以是显示的或隐示的。EnumSet是不同步的，不允许值为null的元素。它也提供了一些有用的方法，比如copyOf(Collection c)、of(E first,E…rest)和complementOf(EnumSet s)。</p> 
<p style="border:0px; margin-top:0px; margin-bottom:20px; padding-top:0px; padding-bottom:0px; font-size:14px; font-family:'Microsoft YaHei',宋体,'Myriad Pro',Lato,'Helvetica Neue',Helvetica,Arial,sans-serif; line-height:21px"> <span style="border:0px; margin:0px; padding:0px">8.哪些集合类是线程安全的？</span></p> 
<p style="border:0px; margin-top:0px; margin-bottom:20px; padding-top:0px; padding-bottom:0px; font-size:14px; font-family:'Microsoft YaHei',宋体,'Myriad Pro',Lato,'Helvetica Neue',Helvetica,Arial,sans-serif; line-height:21px"> Vector、HashTable、Properties和Stack是同步类，所以它们是线程安全的，可以在多线程环境下使用。Java1.5并发API包括一些集合类，允许迭代时修改，因为它们都工作在集合的克隆上，所以它们在多线程环境中是安全的。</p> 
<p style="border:0px; margin-top:0px; margin-bottom:20px; padding-top:0px; padding-bottom:0px; font-size:14px; font-family:'Microsoft YaHei',宋体,'Myriad Pro',Lato,'Helvetica Neue',Helvetica,Arial,sans-serif; line-height:21px"> <span style="border:0px; margin:0px; padding:0px">9.并发集合类是什么？</span></p> 
<p style="border:0px; margin-top:0px; margin-bottom:20px; padding-top:0px; padding-bottom:0px; font-size:14px; font-family:'Microsoft YaHei',宋体,'Myriad Pro',Lato,'Helvetica Neue',Helvetica,Arial,sans-serif; line-height:21px"> Java1.5并发包（java.util.concurrent）包含线程安全集合类，允许在迭代时修改集合。迭代器被设计为fail-fast的，会抛出ConcurrentModificationException。一部分类为：CopyOnWriteArrayList、 ConcurrentHashMap、CopyOnWriteArraySet。</p> 
<p style="border:0px; margin-top:0px; margin-bottom:20px; padding-top:0px; padding-bottom:0px; font-size:14px; font-family:'Microsoft YaHei',宋体,'Myriad Pro',Lato,'Helvetica Neue',Helvetica,Arial,sans-serif; line-height:21px"> <span style="border:0px; margin:0px; padding:0px">10.BlockingQueue是什么？</span></p> 
<p style="border:0px; margin-top:0px; margin-bottom:20px; padding-top:0px; padding-bottom:0px; font-size:14px; font-family:'Microsoft YaHei',宋体,'Myriad Pro',Lato,'Helvetica Neue',Helvetica,Arial,sans-serif; line-height:21px"> Java.util.concurrent.BlockingQueue是一个队列，在进行检索或移除一个元素的时候，它会等待队列变为非空；当在添加一个元素时，它会等待队列中的可用空间。BlockingQueue接口是Java集合框架的一部分，主要用于实现生产者-消费者模式。我们不需要担心等待生产者有可用的空间，或消费者有可用的对象，因为它都在BlockingQueue的实现类中被处理了。Java提供了集中BlockingQueue的实现，比如ArrayBlockingQueue、LinkedBlockingQueue、PriorityBlockingQueue,、SynchronousQueue等。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7bfc257dfdf7ead2d24083fac02d16de/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">父页面调用iframe子页面函数</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/fc3bb3ab52b7d63d8bb916a0b047ccd1/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">解析错误富文本json字符串（带双引号）的解决办法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>