<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>React项目文件中-index.ts的作用 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="React项目文件中-index.ts的作用" />
<meta property="og:description" content="小白的疑问 如果项目中文件夹有index.ts, A.tsx,B.tsx,
A文件:export const TestA
A文件:export const TestB
那么index文件应该怎么写?
身为自学的小白,产生了疑问.
写法介绍 在这个场景下,index.tsx 文件应该作为 A.tsx 和 B.tsx 的入口文件,用于重新导出其导出的内容
例如,如果 A.tsx 中导出:
export const TestA = &#39;A&#39;; B.tsx 中导出:
export const TestB = &#39;B&#39;; 则 index.tsx 可以写成:
export { TestA } from &#39;./A&#39;; export { TestB } from &#39;./B&#39;; 这样就可以从 index.tsx 引入 TestA 和 TestB:
import { TestA, TestB } from &#39;./index&#39;; 所以,index.tsx 的作用是方便用户更简洁地导入文件夹下的内容,而不需要直接导入每个文件。
类似的结构在 TypeScript、React 项目中很常见,例如:
- src/ - components/ - Button." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/56ab19a0a32d1435e86306e5a17481c6/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-05-29T10:59:42+08:00" />
<meta property="article:modified_time" content="2023-05-29T10:59:42+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">React项目文件中-index.ts的作用</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="_0"></a>小白的疑问</h3> 
<p>如果项目中文件夹有index.ts, A.tsx,B.tsx,<br> A文件:export const TestA<br> A文件:export const TestB<br> 那么index文件应该怎么写?<br> 身为自学的小白,产生了疑问.</p> 
<h3><a id="_7"></a>写法介绍</h3> 
<p>在这个场景下,index.tsx 文件应该作为 A.tsx 和 B.tsx 的入口文件,用于重新导出其导出的内容<br> 例如,如果 A.tsx 中导出:</p> 
<pre><code>export const TestA = 'A';
</code></pre> 
<p>B.tsx 中导出:</p> 
<pre><code>export const TestB = 'B';
</code></pre> 
<p>则 index.tsx 可以写成:</p> 
<pre><code>export { TestA } from './A';
export { TestB } from './B';
</code></pre> 
<p>这样就可以从 index.tsx 引入 TestA 和 TestB:</p> 
<pre><code>import { TestA, TestB } from './index';
</code></pre> 
<p>所以,index.tsx 的作用是方便用户更简洁地导入文件夹下的内容,而不需要直接导入每个文件。<br> 类似的结构在 TypeScript、React 项目中很常见,例如:</p> 
<pre><code>- src/
  - components/
    - Button.tsx
    - Input.tsx
    - index.ts // 重新导出 Button 和 Input
    - ...
  - pages/
    - Home.tsx
    - About.tsx
    - index.ts // 重新导出 Home 和 About
</code></pre> 
<pre><code>- ... 
</code></pre> 
<p>等等<br> 通过定义 index.ts/index.tsx 这样的入口文件,项目结构和导入会显得更加清晰和简洁。<br> 所以,如果在项目中有多个可导出的文件,推荐:</p> 
<ol><li>在每个文件中使用 export 导出需要导出的内容</li><li>在文件夹下创建 index.ts/index.tsx 文件</li><li>在 index 文件中使用 export { … } from ‘./…’ 重新导出其他文件中的内容</li><li>鼓励用户使用 export from ‘./index’ 导入文件夹下的所有内容</li></ol> 
<h3><a id="_57"></a>另一种写法(不推荐)</h3> 
<p>如果 index.tsx 写成:</p> 
<pre><code>export * from './A';
</code></pre> 
<p>则可以在导入时直接从 index 导入 A 中的内容,例如:</p> 
<pre><code>import { TestA } from './index';
</code></pre> 
<p>export * 的作用是重新导出 A.tsx 中的所有导出内容,这在简化导入方面与手动列出每个导出是等效的。<br> 所以上面的写法在本例中是等价的,使用 export * 可以更简洁一些。它表示从 A 中重新导出所有的内容,使用方可以直接从 index 导入需要的任何导出。<br> 但是,export * 也有一定的缺点:</p> 
<ol><li>如果 A.tsx 中的导出接口/类型名与其他文件冲突,会造成覆盖,这可能导致意料之外的错误。</li><li>如果 A.tsx 的导出内容改变,使用 export * 的文件也需要重新编译。而手动导出的话,如果新增内容与当前使用无关,则不会影响其他文件。</li><li>阅读 export * 时不直接知道它重新导出了哪些具体内容,需要打开 A.tsx 查看。<br> 所以,总体来说,在小范围内使用 export * 是比较方便的,但在大型项目或公共库中,手动导出可能会更明了也更稳健。<br> 这完全取决于具体场景和工程需要。</li></ol> 
<p>总结一下:</p> 
<ol><li>export * 可以简洁地重新导出其他文件的所有导出内容</li><li>使用 export * 的 index文件支持直接从中导入源文件中的任何内容</li><li>相比手动导出,export * 有一定的缺点,如名称冲突的风险和上述其他提到的问题</li><li>在工程化项目中,明确导出可能会更清晰和稳定</li></ol> 
<h3><a id="_85"></a>项目多层级时</h3> 
<p>当项目结构较深,包含多层文件夹时,为了方便导入,通常会在每一层文件夹中创建 index.ts/index.tsx 文件,用于重新导出下一层文件夹的内容。</p> 
<pre><code>- src/
  - components/
    - Button.tsx
    - Input.tsx
  - containers/
    - Header/
      - Logo.tsx
      - Nav.tsx
      - index.ts // 导出 Logo和Nav
    - Footer/  
      - Copyright.tsx
      - Nav.tsx  
      - index.ts // 导出 Copyright和Nav 
    - index.ts // 导出 Header和Footer
</code></pre> 
<p>则可以这样导入:</p> 
<pre><code>import { Logo, Nav } from './containers/Header'; 
import { Copyright, Nav } from './containers/Footer';
import { Header, Footer } from './containers'; 
</code></pre> 
<p>可以看到,通过在每一层创建 index.ts 文件重新导出下一层的内容,可以轻松地从任意层导入需要的组件。<br> 所以,在处理较深或复杂的项目结构时,建议:</p> 
<ol><li>在每个文件夹内部使用 export 导出子组件</li><li>在文件夹下创建 index.ts 文件,使用 export * 或手动导出重新导出子组件</li><li>上一层的 index 文件再重新导出该文件夹的内容</li><li>以此类推,直到页面级别</li></ol> 
<p>这种层级化的结构和重新导出,让项目具有极高的可读性,也方便了各个层级内外的引用。<br> 使用这种结构的项目,其导入语句也会自然呈现出层级感,一目了然。</p> 
<p>总结一下:</p> 
<ol><li>在多层目录结构中创建 index.ts 文件进行重新导出</li><li>上一层的 index 文件再重新导出下层的 index 文件</li><li>鼓励从尽量高的层级导入,使导入语句自然呈现层级关系</li><li>这种结构清晰且易于使用,是工程化项目的常见实践</li></ol>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/318b388ccca639264ea279e7a25e7e3b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">HTTPS加密流程</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1cb966166bf0634631bbb11b5a615b41/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">linux网络配置命令(ifconfig)和网络任务管理命令(ip)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>