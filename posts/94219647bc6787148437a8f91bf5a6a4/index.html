<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>跨域解决方法 &amp;简单请求 &amp; 非简单请求 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="跨域解决方法 &amp;简单请求 &amp; 非简单请求" />
<meta property="og:description" content=" 为什么会有跨域的问题以及解决方式
视频： click
文章：click
引起跨域的原因：
1、协议、域名、端口有一个不一样就构成了跨域。同源策略：从同一个源加载文档或脚本
2、js中自带跨域技能的标签：&lt;img/&gt;&lt;script&gt;&lt;/script&gt;&lt;link&gt;
解决办法：
CORS：跨站资源共享。使用自定义的HTTP头部让浏览器与服务器进行沟通。浏览器自动进行CORS通信，后端配置消息头：res.header(“Access-Control-Allow-Origin”,&#34;*&#34;)该属性表示那些域名可以访问资源，通配符*表示所有网站都可以访问。支持所有请求方法。cors请求包括简单请求和非简单请求。 简单请求 请求方法是以下三种方法之一：HEAD GET POST HTTP的头信息不超出以下几种字段：Accept Accept-Language Content-Type Last-Event-ID Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain 复杂请求 不满足以上条件 对服务器有特殊要求的请求，比如请求方法是PUT或DELETE，或者Content-Type字段的类型是application/json。 简单请求：浏览器在发出CORS 请求时会在 头信息 之中增加一个Origin字段。许可访问时服务器的返回会多出3个字段：
字段必须/可选解释Access-Control-Allow-Origin必须允许跨域的源，要么是一个*，表示接受任意域名的请求。Access-Control-Allow-Credentials可选表示服务器是否允许客户端发送Cookie。默认情况下，Cookie可以包含在请求中，一起发给服务器，如果服务器不需要浏览器发送Cookie，删除该字段即可。Access-Control-Expose-Headers可选CORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定。如指定Access-Control-Expose-Headers: FooBar，则可通过getResponseHeader(‘FooBar’)获取FooBar字段的值。 不被许可时没有以上字段，会抛出一个错误，被XMLHttpRequest的onerror回调函数捕获。
非简单请求的CORS请求会在正式通信之前，增加一次HTTP查询请求，称为&#34;预检&#34;请求（preflight）。
&#34;预检&#34;请求用的请求方法是OPTIONS，表示这个请求是用来询问的。请求头信息里面，关键字段是Origin，表示请求来自哪个源。浏览器先询问服务器，1、当前网页所在的域名是否在服务器的许可名单之中，2、可以使用哪些方法，3、可以使用那些头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。
预检请求字段说明：
字段是否可选含义Access-Control-Allow-Methods必需值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法,不单是浏览器请求的那个方法。这是为了避免多次&#34;预检&#34;请求Access-Control-Allow-Headers如果浏览器请求包括Access-Control-Request-Headers字段，则Access-Control-Allow-Headers字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在&#34;预检&#34;中请求的字段。Access-Control-Allow-Credentials可选该字段与简单请求时的含义相同。Access-Control-Max-Age可选用来指定本次预检请求的有效期，单位为秒。有效期内不用发出另一条预检请求。 预检请求通过后会发送正常请求，请求头由origin，响应头由Access-control-allow-origin，如图：
JSONP：是JSON with Padding的略称。利用script标签的src属性来实现跨域，将前端方法作为参数传递到服务器端，然后由服务器端注入参数之后再返回，实现服务器端向客户端通信，仅支持get方法。webSockets，不受同源策略影响，它不使用HTTP协议Nginx，反向代理跨域，使用代理服务器。步骤：1. 把访问其它域的请求替换为本域的请求。2. 服务器端的动态脚本负责将本域的请求转发成实际的请求。更加直接，因为同源限制是浏览器实现的。click通过修改document.domain来跨子域使用window.name来进行跨域使用HTML5中新引进的window.postMessage方法来跨域传送数据 " />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/94219647bc6787148437a8f91bf5a6a4/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-09-06T20:43:10+08:00" />
<meta property="article:modified_time" content="2021-09-06T20:43:10+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">跨域解决方法 &amp;简单请求 &amp; 非简单请求</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><strong>为什么会有跨域的问题以及解决方式</strong><br> 视频： <a href="https://www.cnblogs.com/soyxiaobi/p/9616011.html" rel="nofollow">click</a><br> 文章：<a href="https://www.jianshu.com/p/827b041be446" rel="nofollow">click</a></p> 
<p><strong>引起跨域的原因：</strong><br> 1、协议、域名、端口有一个不一样就构成了跨域。同源策略：从同一个源加载文档或脚本<br> 2、js中自带跨域技能的标签：&lt;img/&gt;&lt;script&gt;&lt;/script&gt;&lt;link&gt;</p> 
<p><strong>解决办法：</strong></p> 
<ol><li>CORS：跨站资源共享。使用<strong>自定义的HTTP头部</strong>让浏览器与服务器进行沟通。浏览器自动进行CORS通信，后端配置消息头：res.header(“Access-Control-Allow-Origin”,"*")该属性表示那些域名可以访问资源，通配符*表示所有网站都可以访问。支持所有请求方法。cors请求包括简单请求和非简单请求。</li></ol> 
<dl> 
 
   简单请求 
  
 <dd>
   请求方法是以下三种方法之一：HEAD GET POST 
 </dd> 
 <dd>
   HTTP的头信息不超出以下几种字段：Accept Accept-Language Content-Type Last-Event-ID 
 </dd> 
 <dd>
   Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain 
 </dd> 
 
   复杂请求 
  
 <dd>
   不满足以上条件 
 </dd> 
 <dd>
   对服务器有特殊要求的请求，比如请求方法是PUT或DELETE，或者Content-Type字段的类型是application/json。 
 </dd> 
</dl> 
<p>简单请求：浏览器在发出CORS <strong>请求</strong>时会在 <strong>头信息</strong> 之中增加一个Origin字段。许可访问时<strong>服务器</strong>的<strong>返回</strong>会多出3个字段：</p> 
<table><thead><tr><th align="center">字段</th><th align="center">必须/可选</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center">Access-Control-Allow-Origin</td><td align="center">必须</td><td align="center">允许跨域的源，要么是一个*，表示接受任意域名的请求。</td></tr><tr><td align="center">Access-Control-Allow-Credentials</td><td align="center">可选</td><td align="center">表示服务器是否允许客户端发送Cookie。默认情况下，Cookie可以包含在请求中，一起发给服务器，如果服务器不需要浏览器发送Cookie，删除该字段即可。</td></tr><tr><td align="center">Access-Control-Expose-Headers</td><td align="center">可选</td><td align="center">CORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定。如指定Access-Control-Expose-Headers: FooBar，则可通过getResponseHeader(‘FooBar’)获取FooBar字段的值。</td></tr></tbody></table> 
<p><img src="https://images2.imgbox.com/b3/1b/EFk7VTlH_o.png" alt="在这里插入图片描述"><br> 不被许可时没有以上字段，会抛出一个错误，被XMLHttpRequest的onerror回调函数捕获。</p> 
<p>非简单请求的CORS请求会在正式通信之前，增加一次HTTP查询请求，称为"预检"请求（preflight）。<br> "预检"请求用的请求方法是OPTIONS，表示这个请求是用来询问的。请求头信息里面，关键字段是Origin，表示请求来自哪个源。浏览器先询问服务器，1、当前网页所在的域名是否在服务器的许可名单之中，2、可以使用哪些方法，3、可以使用那些头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。<br> <img src="https://images2.imgbox.com/48/48/bcX5bn2U_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/7a/28/eNg6ihwz_o.png" alt="在这里插入图片描述">预检请求字段说明：</p> 
<table><thead><tr><th align="center">字段</th><th align="center">是否可选</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">Access-Control-Allow-Methods</td><td align="center">必需</td><td align="center">值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法,不单是浏览器请求的那个方法。这是为了避免多次"预检"请求</td></tr><tr><td align="center">Access-Control-Allow-Headers</td><td align="center">如果浏览器请求包括Access-Control-Request-Headers字段，则Access-Control-Allow-Headers字段是必需的。</td><td align="center">它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在"预检"中请求的字段。</td></tr><tr><td align="center">Access-Control-Allow-Credentials</td><td align="center">可选</td><td align="center">该字段与简单请求时的含义相同。</td></tr><tr><td align="center">Access-Control-Max-Age</td><td align="center">可选</td><td align="center">用来指定本次预检请求的有效期，单位为秒。有效期内不用发出另一条预检请求。</td></tr></tbody></table> 
<p>预检请求通过后会发送正常请求，请求头由origin，响应头由Access-control-allow-origin，如图：<br> <img src="https://images2.imgbox.com/fa/e9/4ygn0a3m_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/94/24/6PR5WvAN_o.png" alt="在这里插入图片描述"></p> 
<ol start="2"><li>JSONP：是JSON with Padding的略称。利用script标签的src属性来实现跨域，将前端方法作为参数传递到服务器端，然后由服务器端注入参数之后再返回，实现服务器端向客户端通信，仅支持get方法。</li><li>webSockets，不受同源策略影响，它不使用HTTP协议</li><li>Nginx，反向代理跨域，使用代理服务器。步骤：1. 把访问其它域的请求替换为本域的请求。2. 服务器端的动态脚本负责将本域的请求转发成实际的请求。更加直接，因为同源限制是浏览器实现的。<a href="https://blog.csdn.net/weixin_45656737/article/details/120441632">click</a></li><li>通过修改document.domain来跨子域</li><li>使用window.name来进行跨域</li><li>使用HTML5中新引进的window.postMessage方法来跨域传送数据</li></ol>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5052e768ba07d23a09fd354bc938e0f3/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">shell 字符串和数字互相转换</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ff2b634366c4d55e107226a7dcb83264/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">supervisord部署使用超级详细版</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>