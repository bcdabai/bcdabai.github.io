<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Python 知识点 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Python 知识点" />
<meta property="og:description" content="Python 知识点 1.对不定长参数的理解？ 不定长参数有两种：*args和**kwargs；
*args：是不定长参数，用来将参数打包成tuple给函数体调用；
**kwargs:是关键字参数，打包关键字参数成dict给函数体调用在定义函数的时候不确定要传入的参数个数会有多少个的时候就可以使用不定长参数作为形参。
2.对缺省参数的理解？ 缺省参数指在调用函数的时候没有传入参数的情况下,调用默认的参数,在调用函数的同时赋值时,所传入的参数会替代默认参数。
3.什么是lambda函数？它有什么好处？写一个匿名函数求两个数的和。 lambda函数是匿名函数；使用lambda函数能创建小型匿名函数。这种函数得名于省略了用def声明函数的标准步骤；
f = lambda x,y:x&#43;y print(f(2017,2018)) 4.深拷贝和浅拷贝的区别？ （1）python中的拷贝分为浅拷贝和深拷贝，若不特殊说明拷贝一般是浅拷贝
（2）浅拷贝是将对象顶层拷贝，拷贝了引用，并没有拷贝内容，原对象改变新对象也跟着改变
（3）深拷贝是对一个对象的所有层次的拷贝（递归），但是修改原来的值，新对象不受影响
（4）浅拷贝对于可变类型和不可变类型是不同的，对于可变类型只拷贝顶层，不可变类型依然是原来的对象
5.什么是可变、不可变？元组里添加字典，会改变id吗？ （1）可变不可变指的是内存中的值是否可以被改变，不可变类型指的是对象所在内存块里面的值不可以改变，有数值、字符串、元组；可变类型则是可以改变，主要有列表、字典
（2）元组的顶层元素中包含可变类型，在可变类型中修改或添加字典id不会改变
6.生成器、迭代器的区别？ （1）在Python中，一边循环一边计算的机制，称为生成器：generator，生成器是可以迭代对象，但是生成器可以通过send传值返回到前面；
（2）迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。
迭代器是一个可以记住遍历的位置的对象。 7.range（）和xrange（）函数的用法？ （1）range(start,stop,step)函数按照从start到stop每个step生成一个数值，生成的是列表对象，一次性将所有数据都返回；
（2）xrange(start,stop,step)函数按照从start到stop每个step生成一个数值，返回的是可迭代对象，每次调用返回其中的一个值
8.对装饰器的理解，写出一个装饰器用来打印函数的执行时间。
装饰器本质上是一个Python函数，它可以让其他函数在不需要做任何代码变动的前提下增加额外功能，装饰器的返回值也是一个函数对象
import time def timeit(func): def wrapper(): start = time.clock() func() end =time.clock() result = end - start print（end） return wrapper @timeit def foo(): Print(‘函数执行时间’) foo() 什么单例模式，其应用场景都有哪些？ class Single(object): def __new__(cls, *args, **kwargs): if not hasattr(cls, &#39;_instance&#39;):（hasattr判断里面有没有某个属性或者方法） cls._instance = super(DanLi, cls)." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/af253b4433335f38f2e9cb6b091a25b4/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-03-13T12:43:06+08:00" />
<meta property="article:modified_time" content="2019-03-13T12:43:06+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Python 知识点</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2 style="margin-left:0cm;"><a name="_Toc505361693"></a><a name="_Toc20498"><strong><span style="color:#000000;">                                      Python 知识点</span></strong></a></h2> 
<h4 style="margin-left:0cm;"><strong><a name="_Toc505361695"></a><a name="_Toc19560"></a><a name="_Toc1466"></a><a name="_Toc8826"></a><a name="_Toc13141"></a><a name="_Toc23035"></a><a name="_Toc31890"><span style="color:#000000;">1.</span></a><span style="color:#000000;">对不定长参数的理解</span><span style="color:#000000;">？</span></strong></h4> 
<p style="margin-left:18.15pt;"><span style="color:#000000;">不定长参数有两种：*args和**kwargs；</span></p> 
<p style="margin-left:18.15pt;"><span style="color:#000000;">*args：是不定长参数，用来将参数打包成tuple给函数体调用；</span></p> 
<p style="margin-left:18.15pt;"><span style="color:#000000;">**kwargs:是关键字参数，打包关键字参数成dict给函数体调用在定义函数的时候不确定要传入的参数个数会有多少个的时候就可以使用不定长参数作为形参。</span></p> 
<h4 style="margin-left:0cm;"><strong><a name="_Toc505361688"></a><a name="_Toc4504"></a><a name="_Toc26013"></a><a name="_Toc19007"></a><a name="_Toc30093"></a><a name="_Toc9903"></a><a name="_Toc3339"><span style="color:#000000;">2.</span></a><span style="color:#000000;">对缺省参数的理解？</span></strong></h4> 
<p style="margin-left:18.15pt;"><span style="color:#000000;">缺省参数指在调用函数的时候没有传入参数的情况下,调用默认的参数,在调用函数的同时赋值时,所传入的参数会替代默认参数。</span></p> 
<h4 style="margin-left:0cm;"><strong><a name="_Toc505266594"></a><a name="_Toc28897"></a><a name="_Toc4116"></a><a name="_Toc8442"></a><a name="_Toc14279"></a><a name="_Toc5165"></a><a name="_Toc27324"><span style="color:#000000;">3.</span></a><span style="color:#000000;">什么是lambda函数？它有什么好处？写一个匿名函数求两个数的和。</span></strong></h4> 
<p style="margin-left:18.15pt;"><span style="color:#000000;">lambda函数是匿名函数；使用lambda函数能创建小型匿名函数。这种函数得名于省略了用def声明函数的标准步骤；</span></p> 
<pre class="has"><code>f = lambda x,y:x+y
print(f(2017,2018))</code></pre> 
<h4 style="margin-left:0cm;"><a name="_Toc9450"></a><a name="_Toc4572"></a><a name="_Toc3952"></a><a name="_Toc26408"></a><a name="_Toc24692"></a><a name="_Toc17594"></a><a name="_Toc31760"></a></h4> 
<h3 style="margin-left:0cm;"><strong><span style="color:#000000;">4.</span><span style="color:#000000;">深拷贝和浅拷贝的区别？</span></strong></h3> 
<p style="margin-left:0cm;"><span style="color:#000000;">（1）python中的拷贝分为浅拷贝和深拷贝，若不特殊说明拷贝一般是浅拷贝</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">（2）浅拷贝是将对象顶层拷贝，拷贝了引用，并没有拷贝内容，原对象改变新对象也跟着改变</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">（3）深拷贝是对一个对象的所有层次的拷贝（递归），但是修改原来的值，新对象不受影响</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">（4）浅拷贝对于可变类型和不可变类型是不同的，对于可变类型只拷贝顶层，不可变类型依然是原来的对象</span></p> 
<h3 style="margin-left:0cm;"><strong><a name="_Toc505266611"></a><a name="_Toc16981"></a><a name="_Toc11633"></a><a name="_Toc14870"></a><a name="_Toc5017"></a><a name="_Toc14268"><span style="color:#000000;">5.</span></a><span style="color:#000000;">什么是可变、不可变？元组里添加字典，会改变id吗？</span></strong></h3> 
<p style="margin-left:18.15pt;"><span style="color:#000000;">（1）可变不可变指的是内存中的值是否可以被改变，不可变类型指的是对象所在内存块里面的值不可以改变，有数值、字符串、元组；可变类型则是可以改变，主要有列表、字典</span></p> 
<p style="margin-left:18.15pt;"><span style="color:#000000;">（2）元组的顶层元素中包含可变类型，在可变类型中修改或添加字典id不会改变</span></p> 
<h4 style="margin-left:0cm;"><strong><span style="color:#000000;">6.</span><span style="color:#000000;">生成器、迭代器的区别？</span></strong></h4> 
<p style="margin-left:0cm;"><span style="color:#000000;">（1）在Python中，一边循环一边计算的机制，称为生成器：generator，生成器是可以迭代对象，但是生成器可以通过send传值返回到前面；</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">（2）迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。</span></p> 
<ol><li><span style="color:#000000;">迭代器是一个可以记住遍历的位置的对象。</span></li></ol> 
<h4 style="margin-left:0cm;"><strong><a name="_Toc505361717"></a><a name="_Toc11670"></a><a name="_Toc2004"></a><a name="_Toc5588"></a><a name="_Toc6380"></a><a name="_Toc15154"><span style="color:#000000;">7.range</span></a><span style="color:#000000;">（）和xrange（）函数的用法？</span></strong></h4> 
<p style="margin-left:0cm;"><span style="color:#000000;">（1）range(start,stop,step)函数按照从start到stop每个step生成一个数值，生成的是列表对象，一次性将所有数据都返回；</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">（2）xrange(start,stop,step)函数按照从start到stop每个step生成一个数值，返回的是可迭代对象，每次调用返回其中的一个值</span></p> 
<p style="margin-left:0cm;"><strong><a name="_Toc505361694"></a><a name="_Toc4913"></a><a name="_Toc1955"></a><a name="_Toc22268"></a><a name="_Toc505361689"></a><a name="_Toc25117"></a><a name="_Toc25182"></a><a name="_Toc6255"></a><a name="_Toc18243"></a><a name="_Toc5774"></a><a name="_Toc29132"></a><a name="_Toc2815"><span style="color:#000000;">8.</span></a><span style="color:#000000;">对装饰器的理解，写出一个装饰器用来打印函数的执行时间。</span></strong></p> 
<p style="margin-left:18.15pt;"><span style="color:#000000;">装饰器本质上是一个Python函数，它可以让其他函数在不需要做任何代码变动的前提下增加额外功能，装饰器的返回值也是一个函数对象</span></p> 
<pre class="has"><code>import time

def timeit(func):

　　def wrapper():

　　　　start = time.clock()

　　　　func()

end =time.clock()

result = end - start

　　　　print（end）

　　　　return wrapper

@timeit

def foo():

Print(‘函数执行时间’)

foo()</code></pre> 
<ol><li><strong><a name="_Toc5646"></a><a name="_Toc16"></a><a name="_Toc16947"></a><a name="_Toc22792"></a><a name="_Toc11976"></a><a name="_Toc505361691"></a><a name="_Toc23749"></a><a name="_Toc13563"> <span style="color:#000000;">什么单例模式</span></a><span style="color:#000000;">，其应用场景都有哪些？</span></strong></li></ol> 
<p style="margin-left:0cm;">      </p> 
<pre class="has"><code class="language-python">class Single(object):

           def __new__(cls, *args, **kwargs):

              if not hasattr(cls, '_instance'):（hasattr判断里面有没有某个属性或者方法）

              cls._instance = super(DanLi, cls).__new__(cls)

           return cls._instance

      

single1 = Single()

single2 = Single()

Print(id(single1))

Print(id(single2))</code></pre> 
<p style="margin-left:0cm;"> </p> 
<p style="text-indent:0;">      （1）__new__()在__init__()之前被调用，用于生成实例对象，利用这个方法和类的属性的特点可以实现设计模式的单例模           式。单例模式是指创建唯一对象，单利模式设计的类只能实例化一个对象。</p> 
<p style="margin-left:18.15pt;"><span style="color:#000000;">（2）确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，单例模式是一种对象创建型模式。</span></p> 
<p style="margin-left:18.15pt;"><span style="color:#000000;">Windows的Task Manager（任务管理器）、Recycle Bin（回收站）、网站计数器</span></p> 
<p style="margin-left:18.15pt;"><span style="color:#000000;">（3）单例模式应用的场景一般发现在以下条件下：</span></p> 
<p style="margin-left:18.15pt;"><span style="color:#000000;">资源共享的情况下，避免由于资源操作时导致的性能或损耗等。如上述中的日志文件，应用配置。</span></p> 
<p style="margin-left:18.15pt;"><span style="color:#000000;">控制资源的情况下，方便资源之间的互相通信。如线程池等</span></p> 
<h4 style="margin-left:0cm;"><strong><a name="_Toc505266630"></a><a name="_Toc1684"><span style="color:#000000;">10</span></a><span style="color:#000000;">．并行（parallel）和并发（concurrency）？</span><span style="color:#000000;">线程是并发还是并行，进程是并发还是并行？</span></strong></h4> 
<p style="margin-left:18.15pt;"><span style="color:#000000;">（1）线程是并发，进程是并行；进程之间相互独立，是系统分配资源的最小单位，同一个线程中的所有线程共享资源</span></p> 
<p style="margin-left:18.15pt;"><span style="color:#000000;">（2）并行：同一时刻多个任务同时在运行</span></p> 
<p style="margin-left:18.15pt;"><span style="color:#000000;">（3）并发：在同一时间间隔内多个任务都在运行，但是并不会在同一时刻同时运行，存在交替执行的情况</span></p> 
<p style="margin-left:18.15pt;"><span style="color:#000000;">（4）实现并行的库有：multiprocessing</span></p> 
<p style="margin-left:18.15pt;"><span style="color:#000000;">（5）实现并发的库有：threading</span></p> 
<p style="margin-left:18.15pt;"><span style="color:#000000;">（6）程序需要执行较多的读写、请求和回复任务的需要大量的IO操作，IO密集型操作使用并发更好</span></p> 
<p style="margin-left:18.15pt;"><span style="color:#000000;">CPU运算量大的程序程序，使用并行会更好</span></p> 
<h4 style="margin-left:0cm;"><strong><a name="_Toc505361690"></a><a name="_Toc26154"></a><a name="_Toc11761"></a><a name="_Toc5219"></a><a name="_Toc1756"></a><a name="_Toc15425"></a><a name="_Toc21234"></a><a name="_Toc2711"><span style="color:#000000;">11.</span></a><span style="color:#000000;">什么是线程安全，什么是互斥锁？</span></strong></h4> 
<p style="margin-left:18.15pt;"><span style="color:#000000;">（1）每个对象都对应于一个可称为" 互斥锁" 的标记，这个标记用来保证在任一时刻，只能有一个线程访问该对象。</span></p> 
<p style="margin-left:18.15pt;"><span style="color:#000000;">（2）同一个进程中的多线程之间是共享系统资源的,多个线程同时对一个对象进行操作,一个线程操作尚未结束,另一个线程已经对其进行操作,导致最终结果出现错误,此时需要对被操作对象添加互斥锁,保证每个线程对该对象的操作都得到正确的结果</span></p> 
<h4 style="margin-left:0cm;"><strong><span style="color:#000000;">12.python</span><span style="color:#000000;">的内存管理机制及调优手段？</span></strong></h4> 
<p style="margin-left:0cm;"><span style="color:#000000;">内存管理机制：引用计数、垃圾回收、内存池</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">（1）引用计数</span></p> 
<p style="margin-left:18.15pt;"><span style="color:#000000;">引用计数是一种非常高效的内存管理手段, 当一个Python对象被引</span> <span style="color:#000000;">用时其引用计数增加1, 当其不再被一个变量引用时则计数减1. 当引用计数等于0时对象被删除.</span></p> 
<p style="margin-left:0cm;"><strong><span style="color:#000000;">（</span></strong><strong><span style="color:#000000;">2</span></strong><strong><span style="color:#000000;">）垃圾回收</span></strong></p> 
<ol><li><a name="_Toc20967"></a><a name="_Toc16331"></a><a name="_Toc4440"></a><a name="_Toc25814"></a><a name="_Toc5375"></a><a name="_Toc16671"></a><a name="_Toc9564"></a><a name="_Toc25334"></a><a name="_Toc27294"></a><a name="_Toc5553"><span style="color:#000000;">引用计数</span></a></li></ol> 
<p style="margin-left:18.15pt;"><span style="color:#000000;">引用计数也是一种垃圾收集机制，而且也是一种最直观，最简单的垃圾收集技术。当Python的某个对象的引用计数降为0时，说明没有任何引用指向该对象，该对象就成为要被回收的垃圾了。比如某个新建对象，它被分配给某个引用，对象的引用计数变为1。如果引用被删除，对象的引用计数为0，那么该对象就可以被垃圾回收。</span> <br><span style="color:#000000;">不过如果出现循环引用的话，引用计数机制就不再起有效的作用了</span></p> 
<ol><li><a name="_Toc32341"></a><a name="_Toc29435"></a><a name="_Toc17014"></a><a name="_Toc11827"></a><a name="_Toc16721"></a><a name="_Toc14630"></a><a name="_Toc25315"></a><a name="_Toc29100"></a><a name="_Toc28696"></a><a name="_Toc13814"><span style="color:#000000;">标记清除</span></a></li></ol> 
<p style="margin-left:18.15pt;"><span style="color:#000000;">如果两个对象的引用计数都为1，但是仅仅存在他们之间的循环引用，那么这两个对象都是需要被回收的，也就是说，它们的引用计数虽然表现为非0，但实际上有效的引用计数为0。所以先将循环引用摘掉，就会得出这两个对象的有效计数。</span></p> 
<ol><li><a name="_Toc19173"></a><a name="_Toc3759"></a><a name="_Toc8864"></a><a name="_Toc3862"></a><a name="_Toc1310"></a><a name="_Toc19991"></a><a name="_Toc28565"></a><a name="_Toc16009"></a><a name="_Toc8251"></a><a name="_Toc10803"><span style="color:#000000;">分代回收</span></a></li></ol> 
<p style="margin-left:18.15pt;"><span style="color:#000000;">从前面“标记-清除”这样的垃圾收集机制来看，这种垃圾收集机制所带来的额外操作实际上与系统中总的内存块的数量是相关的，当需要回收的内存块越多时，垃圾检测带来的额外操作就越多，而垃圾回收带来的额外操作就越少；反之，当需回收的内存块越少时，垃圾检测就将比垃圾回收带来更少的额外操作。</span> </p> 
<p style="margin-left:0cm;"><span style="color:#000000;">（3）内存池</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">1.Python的内存机制呈现金字塔形状，-1，-2层主要有操作系统进行操作；</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">2.第0层是C中的malloc，free等内存分配和释放函数进行操作；</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">3.第1层和第2层是内存池，有Python的接口函数PyMem_Malloc函数实现，当对象小于256K时有该层直接分配内存；</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">4.第3层是最上层，也就是我们对Python对象的直接操作；</span></p> 
<p style="margin-left:18.15pt;"><span style="color:#000000;">Python在运行期间会大量地执行malloc和free的操作，频繁地在用户态和核心态之间进行切换，这将严重影响Python的执行效率。为了加速Python的执行效率，Python引入了一个内存池机制，用于管理对小块内存的申请和释放。 <br>     Python内部默认的小块内存与大块内存的分界点定在256个字节，当申请的内存小于256字节时，PyObject_Malloc会在内存池中申请内存；当申请的内存大于256字节时，PyObject_Malloc的行为将蜕化为malloc的行为。当然，通过修改Python源代码，我们可以改变这个默认值，从而改变Python的默认内存管理行为。</span></p> 
<p style="margin-left:0cm;"><strong><span style="color:#000000;">（</span></strong><strong><span style="color:#000000;">4</span></strong><strong><span style="color:#000000;">）调优手段（了解）</span></strong><strong>  </strong></p> 
<p style="margin-left:18.15pt;"><a name="_Toc18551"></a><a name="_Toc16588"></a><a name="_Toc31902"></a><a name="_Toc22063"></a><a name="_Toc18005"></a><a name="_Toc28434"></a><a name="_Toc24703"></a><a name="_Toc2866"></a><a name="_Toc6510"></a><a name="_Toc12341"><span style="color:#000000;">1.</span></a><span style="color:#000000;">手动垃圾回收</span></p> 
<p style="margin-left:18.15pt;"><a name="_Toc18787"></a><a name="_Toc5868"></a><a name="_Toc5385"></a><a name="_Toc3699"></a><a name="_Toc17593"></a><a name="_Toc10996"></a><a name="_Toc28046"></a><a name="_Toc2644"></a><a name="_Toc26004"></a><a name="_Toc21587"><span style="color:#000000;">2.</span></a><span style="color:#000000;">调高垃圾回收阈值</span></p> 
<p style="margin-left:18.15pt;"><a name="_Toc761"></a><a name="_Toc15114"></a><a name="_Toc8482"></a><a name="_Toc1436"></a><a name="_Toc10915"></a><a name="_Toc24460"></a><a name="_Toc25525"></a><a name="_Toc16739"></a><a name="_Toc10515"></a><a name="_Toc19719"><span style="color:#000000;">3.</span></a><span style="color:#000000;">避免循环引用（手动解循环引用和使用弱引用）</span></p> 
<h4 style="margin-left:0cm;"><strong><a name="_Toc31797"><span style="color:#000000;">13</span></a><span style="color:#000000;">．read、readline和readlines的区别</span></strong></h4> 
<p style="margin-left:0cm;"><span style="color:#000000;">read:读取整个文件</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">readline：读取下一行，使用生成器方法</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">readlines：读取整个文件到一个迭代器以供我们遍历</span></p> 
<h4 style="margin-left:0cm;"><strong><a name="_Toc505361699"></a><a name="_Toc6214"></a><a name="_Toc7964"></a><a name="_Toc21330"></a><a name="_Toc27435"></a><a name="_Toc9420"></a><a name="_Toc14951"><span style="color:#000000;">14</span></a><span style="color:#000000;">．什么是死锁以及怎么解决</span><span style="color:#000000;">?</span></strong></h4> 
<p style="margin-left:18.15pt;"><span style="color:#000000;">死锁：在线程间共享多个资源的时候，如果两个线程分别占有一部分资源并且同时等待对方的资源，就会造成死锁</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">给互斥锁添加超时时间</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">程序设计时要尽量避免（银行家算法）</span></p> 
<h4 style="margin-left:0cm;"><a name="_Toc505361697"></a><a name="_Toc5429"></a><a name="_Toc28691"></a><a name="_Toc15507"></a><a name="_Toc24079"></a><a name="_Toc22458"></a><a name="_Toc19469"><span style="color:#000000;">15</span></a><span style="color:#000000;">．解释一下什么是闭包</span></h4> 
<p style="margin-left:18.15pt;"><span style="color:#000000;">在函数内部再定义一个函数，并且这个函数用到了外边函数的变量，那么将这个函数以及用到的一些变量称之为闭包</span></p> 
<h4 style="margin-left:0cm;"><a name="_Toc505361732"></a><a name="_Toc26145"><span style="color:#000000;">16</span></a><span style="color:#000000;">．描述Python GIL的概念，以及它对Python多线程的影响？</span></h4> 
<p style="margin-left:18.15pt;"><span style="color:#000000;">GIL：全局解释器锁。每个线程在执行的过程都需要先获取GIL，保证同一时刻只有一个线程可以执行字节码。</span></p> 
<p style="margin-left:18.15pt;"><span style="color:#000000;">线程释放GIL锁的情况：</span></p> 
<p style="margin-left:18.15pt;"><span style="color:#000000;">在IO操作等可能会引起阻塞的system call之前,可以暂时释放GIL,但在执行完毕后,必须重新获取GIL</span></p> 
<p style="margin-left:18.15pt;"><span style="color:#000000;">Python 3.x使用计时器（执行时间达到阈值后，当前线程释放GIL）或Python 2.x，tickets计数达到100</span></p> 
<p style="margin-left:18.15pt;"><span style="color:#000000;">Python使用多进程是可以利用多核的CPU资源的。</span></p> 
<p style="margin-left:18.15pt;"><span style="color:#000000;">多线程爬取比单线程性能有提升，因为遇到IO阻塞会自动释放GIL锁</span></p> 
<h4 style="margin-left:0cm;"><strong><a name="_Toc505361702"></a><a name="_Toc16349"></a><a name="_Toc10121"></a><a name="_Toc13770"></a><a name="_Toc19924"></a><a name="_Toc28086"><span style="color:#000000;">17</span></a><span style="color:#000000;">．Python中有日志吗?怎么使用?</span></strong></h4> 
<p style="margin-left:18.15pt;"><span style="color:#000000;">有日志；</span></p> 
<p style="margin-left:18.15pt;"><span style="color:#000000;">python自带logging模块，调用logging.basicConfig()方法，配置需要的日志等级和相应的参数，python解释器会按照配置的参数生成相应的日志。</span></p> 
<h4 style="margin-left:0cm;"><strong><span style="color:#000000;">18.与、或、亦或的优先级（and、or、xor）</span></strong></h4> 
<p style="margin-left:0cm;"><span style="color:#000000;">答：xor的优先级高，因为是单运算符，and和or的优先级比较低，and比   or有限级高。</span></p> 
<h4 style="margin-left:0cm;"><strong><span style="color:#000000;">19.</span></strong><strong><span style="color:#000000;">说说进程、线程、协程</span></strong></h4> 
<p style="margin-left:0cm;"><span style="color:#000000;">进程是系统进行资源分配的最小单位，每个进程都有自己的独立内存空间，不用进程通过进程间通信来通信。但是进程占据独立空间，比较重量级，所以上下文进程间的切换开销比较大，但是比较稳定安全。</span></p> 
<p style="margin-left:0cm;">   <span style="color:#000000;">线程是进程的一个实体，是CPU进行调度的最小单位，他是比进程更小能独立运行的基本单位。线程基本不拥有系统资源，只占用一点运行中的资源（如程序计数器,一组寄存器和栈），但是它可以与同属于一个进程的其他线程共享全部的资源。提高程序的运行速率，上下文切换快，开销比较少，但是不够稳定，容易丢失数据，形成死锁。</span></p> 
<p style="margin-left:0cm;">    <span style="color:#000000;">协程：是更小的执行单位，是一种轻量级的线程，协程的切换只是单纯的操作CPU的上下文，所以切换速度特别快，且耗能小。线程切换从系统层面远不止保存和恢复CPU上下文这么简单，操作系统为了程序运行的高效性，每个线程会有缓存的数据，操作系统还会做回复数据的操作，实际上是消耗性能的。</span></p> 
<p style="margin-left:0cm;">     <span style="color:#000000;">对于IO密集型的程序，由于IO操作远远慢于CPU的操作，所以往往需要CPU去等IO操作，这样在同步IO下就需要切换线程，让操作系统去执行其他的代码，但是这样带来大量的性能浪费。如果把一个IO操作写成一个协程。当触发IO操作时候自动让出CPU给其他协程，协程的切换轻的，协程通过这种异步IO的封装，即保留了性能也保证了代码的可读性，在高IO密集型的程序下很好，但是高CPU密集型的程序就不好了。</span></p> 
<h4 style="margin-left:0cm;"><strong><span style="color:#000000;">20.</span></strong><strong><span style="color:#000000;">面向对象有哪些方法</span></strong></h4> 
<p style="margin-left:0cm;"><span style="color:#000000;">（实例方法、静态方法、类方法）</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">静态方法需要@staticmethod进行修饰，不需要定义参数。类方法是类对象所拥有的方法，需要用装饰器@classmethod来标示，以cls为第一个参数，能够通过实例对象和类对象去访问。实例方法以self为第一个参数，可以通过self访问实力属性</span></p> 
<h4 style="margin-left:0cm;"><strong><span style="color:#000000;">21.生产者消费者模型优点</span></strong></h4> 
<p style="margin-left:0cm;"><span style="color:#000000;">生产者消费者模型：解耦，通过队列降低耦合，支持并发，生产者和消费者是两个独立的并发体，他们之间使用缓冲区作为桥梁连接，生产者只往里丢数据，就可以生产下一个数据了，消费者从中拿数据，这样就不会阻塞，影响速度。可以很好的支持任务的忙闲不均匀的问题。</span></p> 
<h4 style="margin-left:0cm;"><strong><span style="color:#000000;">22.</span></strong>在当前目录以及子目录下查找文件名包含指定字符串的文件，并打印出完整路径</h4> 
<pre class="has"><code class="language-python">import os

MySelectPath = 'D:\\tmp'


def Findtxt(MyPath):
    for i in os.listdir(MyPath):
        FilePath = os.path.abspath(os.path.join(MyPath, i))

            #	输出找到的.txt格式的文件
        if os.path.splitext(i)[1] == '.txt':
            print('找到txt文件 ：', i)
            print('文件路径是 ：', FilePath)
        elif os.path.isdir(FilePath):
            #   print FilePath
            #   print '进入文件夹 ：', i
            Findtxt(FilePath)


Findtxt(MySelectPath)</code></pre> 
<ol><li><strong>python如何获取一个文件夹内包括子文件夹所有文件的名字和路径</strong></li></ol> 
<pre class="has"><code class="language-python">import os
dir="./"
f=open("dir.txt","a")
for root,dirs,files in os.walk(dir):
    for file in files:
        f.writelines(os.path.join(root,file)+"\n")</code></pre> 
<ol><li><strong>写一个列表生成式</strong><strong> </strong><strong>例如产生一个公差为的等差数列</strong></li></ol> 
<pre class="has"><code class="language-python">a = [i for i in range(10)]      #公差为1
a = [i*2 for i in range(10)]    #公差为2</code></pre> 
<h4 style="margin-left:0cm;"><strong>25.</strong><strong>新式类与经典类区别</strong></h4> 
<p style="margin-left:0cm;"><span style="color:#000000;">从继承上说，新式类默认从object继承，经典类需要指定(python3中没有)</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">经典类继承深度优先（先深入继承左侧，再返回，在开始找右侧）</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">新式类继承广度优先（优先水平搜索）</span></p> 
<h4 style="margin-left:0cm;"><strong><span style="color:#000000;">26.</span></strong><strong><span style="color:#000000;">谈谈你对查询集的理解</span></strong></h4> 
<p style="margin-left:0cm;"><span style="color:#000000;">查询集表示从数据库中获取的对象集合，在管理器上调用过滤器方法返回查询集，查询集可以包括一个、两个或者多个过滤器。过滤器基于所给的参数限制查询的结果。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">查询集的特性之一是：惰性--创建查询机不会访问数据库，直到调用数据时，才会访问数据库。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">查询集的另一个特性是：缓存：使用同一个查询集，第一次使用时会发生数据库的查询，再次使用这个查询集时会使用缓存的数据。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">如果是两个相同的查询集，无法重用缓存，每次查询都会和数据库进行一次交互，增加了数据库的负载。缓存可以加快获取数据的速率，减轻数据库的压力。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">过滤器种类：all()  返回所有数据。filter()返回满足条件的数据，过滤。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">exclude()返回满足条件之外的数据  order_by（）对结果排序。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">get()返回单个满足条件的对象。  count()返回当前查询结果的总条数  aggregrate()聚合，返回一个字典   exist()判断查询机是否有数据。</span></p> 
<p style="margin-left:0cm;"> </p> 
<h4 style="margin-left:0cm;"><strong><span style="color:#000000;">27.</span></strong><strong><span style="color:#000000;">谈谈你对</span></strong><strong><span style="color:#000000;">Django</span></strong><strong><span style="color:#000000;">查询中</span></strong><strong><span style="color:#000000;">F</span></strong><strong><span style="color:#000000;">与</span></strong><strong><span style="color:#000000;">Q</span></strong><strong><span style="color:#000000;">对象的理解</span></strong></h4> 
<p style="margin-left:0cm;"><span style="color:#000000;">1.之前的查询都是属性与常量值的比较，F对象实现了属性与属性之间的比较</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">BookInfo.objects.filter(bread__gt=F('bcomment'))属性名一定要有单引号。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">BookInfo.objects.filter(bread__gt=F('bcomment')*2) 2倍的记录。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">2.可以直接使用条件表达式来描述逻辑与and,逻辑非not的关系，但是逻辑或or的关系不行。Q对象：描述逻辑关系。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">Q对象可以使用&amp;,|连接，&amp;表示逻辑与，|表示逻辑或  Q对象前可以使用~操作符，表示非（not）</span></p> 
<h4 style="margin-left:0cm;"><strong><span style="color:#000000;">28.如何用函数的形式将两个有序集合合并成一个有序集合？</span></strong></h4> 
<p style="margin-left:0cm;"><span style="color:#000000;">1.函数</span></p> 
<pre class="has"><code class="language-python">def fun(list1,list2):
    result = []
    while list1 and list2:

        if list1[0] &lt; list2[0]:

            result.append(list1[0])

            del list1[0]
        else:

            result.append(list2[0])

            del list2[0]
    if list1:
        result.extend(list1)
    if list2:
        result.extend(list2)
    return result


ret = fun([1,2,3,4],[4,5,6])

print(ret)</code></pre> 
<ol><li><strong><span style="color:#000000;">内置函数</span></strong></li></ol> 
<pre class="has"><code class="language-python">list1 = [1,2,3,4]
list2 = [5,6,7,8]
for i in list2:

    list1.append(i)

    list1.sort()

print(list1)</code></pre> 
<p style="margin-left:0cm;"> </p> 
<h4 style="margin-left:0cm;"><strong><span style="color:#000000;">29.</span></strong><strong><span style="color:#000000;">反向解析：</span></strong></h4> 
<p style="margin-left:0cm;">使用场景：模板中的超链接，视图中的重定向</p> 
<p style="margin-left:0cm;">使用：在定义url时为include定义namespace属性，为url定义name属性</p> 
<p style="margin-left:0cm;">在模板中使用url标签：{% url 'namespace_value:name_value'%}</p> 
<p style="margin-left:0cm;">在视图中使用reverse函数：redirect(reverse('namespce_value:name_value’))</p> 
<p style="margin-left:0cm;">根据正则表达式动态生成地址，减轻后期维护成本。</p> 
<p style="margin-left:0cm;">注意反向解析传参数，主要是在我们的反向解析的规则后面天界了两个参数，两个参数之间使用空格隔开：&lt;a href="{% url 'booktest:fan2' 2 3 %}"&gt;位置参数&lt;/a&gt;</p> 
<p style="margin-left:0cm;"><strong><span style="color:#000000;">30.monkey patch(猴子补丁）</span></strong></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">用来在运行时动态修改已有的代码，而不需要修改原始代码。在gevent中，会在开头的地方gevent.monkey.patch_all(）,把标准库中的thread/socket等给替换掉，这样我们后面使用socket的时候能够跟寻常一样使用，无序改动代码，可以使他变成非堵塞的。</span></p> 
<p style="margin-left:0cm;"> </p> 
<h4 style="margin-left:0cm;"><strong><span style="color:#000000;">31.git</span></strong><strong><span style="color:#000000;">简介及相关命令的使用</span></strong></h4> 
<p style="margin-left:0cm;"><span style="color:#333333;">总结git的两大特点：</span></p> 
<ul><li><span style="color:#333333;">版本控制：可以解决多人同时开发的代码问题，也可以解决找回历史代码的问题</span></li><li><span style="color:#333333;">分布式：Git是分布式版本控制系统，同一个Git仓库，可以分布到不同的机器上。首先找一台电脑充当服务器的角色，每天24小时开机，其他每个人都从这个“服务器”仓库克隆一份到自己的电脑上，并且各自把各自的提交推送到服务器仓库里，也从服务器仓库中拉取别人的提交。可以自己搭建这台服务器，也可以使用GitHub网站</span></li></ul> 
<p style="margin-left:0cm;">   <span style="color:#333333;">步骤及相关命令：</span></p> 
<ul><li><span style="color:#333333;">组员在ubuntu中生成ssh密钥，然后交给项目经理添加到github中，</span><span style="color:#333333;">等项目经理在github上添加后，会将项目地址下发，然后就可以参与到项目开发中进行后续操作</span></li></ul> 
<ol><li><code><span style="color:#333333;">ssh-keygen -t rsa -C "Github</span></code><code><span style="color:#333333;">账号，可以是用户名，也可以是邮箱地址"。</span></code></li><li><code><span style="color:#333333;">将项目克隆到本地（git clone 项目地址），在克隆下来的目录下隐藏目录.git存储了服务器、分支、文件变更等信息</span></code></li><li><code><span style="color:#333333;">以自己的姓名创建分支，要保证分支名字唯一（git checkout -b name）</span></code></li><li><code><span style="color:#333333;">将本地分支推送到服务器（git push origin name）</span></code></li><li><code><span style="color:#333333;">将本地分支跟踪服务器分支（git branch --set-upstream=origin/分支 分支）</span></code></li><li><code><span style="color:#333333;">将GitHub上的dev分支同步到本地，因为开发过程中所有组员都向这个分支上提交阶段性代码，并从这个分支获取阶段性代码。（git checkout -b dev origin/dev）</span></code></li><li><code><span style="color:#333333;">查看当前状态：git status 保存现场：git stash</span></code></li><li><code><span style="color:#333333;">工作区向暂存区提交代码git add 文件或目录。恢复代码git checkout --文件，删除文件 git rm 文件</span></code></li><li><code><span style="color:#333333;">暂存区与仓库区：提交git commit -m ‘备注’，恢复git reset HEA或版本号</span></code></li></ol> 
<p style="margin-left:0cm;"><code><span style="color:#333333;">10</span></code><code><span style="color:#333333;">本地与服务器</span></code><span style="color:#333333;">推送指将特定分支在本地仓库区的记录发送到服务器上</span></p> 
<p style="margin-left:0cm;"><code><span style="color:#333333;">git push origin</span></code><code><span style="color:#333333;">分支</span></code></p> 
<p style="margin-left:0cm;"><span style="color:#333333;">将服务器特定分支向本地工作区同步</span></p> 
<p style="margin-left:0cm;"><span style="color:#333333;">git checkout dev</span></p> 
<p style="margin-left:0cm;"><span style="color:#333333;">git pull</span></p> 
<p style="margin-left:0cm;"><span style="color:#333333;">git checkout zhujiao</span></p> 
<h4 style="margin-left:0cm;"><strong><span style="color:#333333;">33.restful</span></strong><strong><span style="color:#333333;">风格：</span></strong></h4> 
<p style="margin-left:0cm;"><span style="color:#333333;">1.</span><span style="color:#333333;">每一种请求都代表一种资源，它主要强调http应该以资源为中心，并且规范了URI的风格，URI：统一资源标志符，某一规则下能把一个资源独一无二地标识出来，好比每个人都有身份证号码</span></p> 
<p style="margin-left:0cm;"><span style="color:#333333;">2.</span><span style="color:#333333;">它有四种对资源操作的请求，分别是POST新增资源，GET获取资源，PUT更新资源，DELETE删除资源，客户端通过这四个请求对资源进行操作，实现表现层状态转换。</span></p> 
<p style="margin-left:0cm;"> </p> 
<h3 style="margin-left:0cm;"><strong><a name="_Toc505361740"></a><a name="_Toc29787"></a><a name="_Toc12933"></a><a name="_Toc27507"><span style="color:#000000;">第二章 网络编程</span></a><a name="_Toc505361743"></a><a name="_Toc15435"></a><a name="_Toc11180"></a></strong></h3> 
<h3 style="margin-left:0cm;"><strong><span style="color:#000000;">1</span><span style="color:#000000;">．Tcp协议和udp协议有什么区别</span><span style="color:#000000;">？</span></strong></h3> 
<p style="margin-left:0cm;"><span style="color:#000000;">（1）TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接<br>     （2）TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保   证可靠交付<br>     （3）TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的，UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">（4）每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信<br>     （5）TCP首部开销20字节;UDP的首部开销小，只有8个字节<br>     （6）TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道</span></p> 
<h3 style="margin-left:0cm;"><strong><a name="_Toc505361747"></a><a name="_Toc31078"></a><a name="_Toc14557"></a><a name="_Toc16329"></a><a name="_Toc23472"><span style="color:#000000;">2</span></a><span style="color:#000000;">．Post和get区别？</span></strong></h3> 
<p style="margin-left:0cm;"><span style="color:#000000;">（1）GET请求，请求的数据会附加在URL之后，以?分割URL和传输数据，多个参数用&amp;连接。URL的编码格式采用的是ASCII编码，而不是uniclde，即是说所有的非ASCII字符都要编码之后再传输。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">POST</span><span style="color:#000000;">请求：POST请求会把请求的数据放置在HTTP请求包的包体中。上面的item=bandsaw就是实际的传输数据。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">因此，GET请求的数据会暴露在地址栏中，而POST请求则不会。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">（2）传输数据的大小</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">在HTTP规范中，没有对URL的长度和传输的数据大小进行限制。但是在实际开发过程中，对于GET，特定的浏览器和服务器对URL的长度有限制。因此，在使用GET请求时，传输数据会受到URL长度的限制。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">对于POST，由于不是URL传值，理论上是不会受限制的，但是实际上各个服务器会规定对POST提交数据大小进行限制，Apache、IIS都有各自的配置。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">（3）安全性</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">POST</span><span style="color:#000000;">的安全性比GET的高。这里的安全是指真正的安全，而不同于上面GET提到的安全方法中的安全，上面提到的安全仅仅是不修改服务器的数据。比如，在进行登录操作，通过GET请求，用户名和密码都会暴露再URL上，因为登录页面有可能被浏览器缓存以及其他人查看浏览器的历史记录的原因，此时的用户名和密码就很容易被他人拿到了。除此之外，GET请求提交的数据还可能会造成Cross-site request frogery攻击。</span></p> 
<h3 style="margin-left:0cm;"><strong><a name="_Toc505361748"></a><a name="_Toc11450"></a><a name="_Toc1712"><span style="color:#000000;">3</span></a><span style="color:#000000;">．cookie 和session 的区别？</span></strong></h3> 
<p style="margin-left:0cm;"><strong><span style="color:#000000;">（</span></strong><strong><span style="color:#000000;">1</span></strong><strong><span style="color:#000000;">）</span></strong><strong><span style="color:#000000;">cookie</span></strong><strong><span style="color:#000000;">数据存放在客户的浏览器上，</span></strong><strong><span style="color:#000000;">session</span></strong><strong><span style="color:#000000;">数据放在服务器上。</span></strong></p> 
<p style="margin-left:0cm;"><strong><span style="color:#000000;">（</span></strong><strong><span style="color:#000000;">2</span></strong><strong><span style="color:#000000;">）</span></strong><strong><span style="color:#000000;">cookie</span></strong><strong><span style="color:#000000;">不是很安全，别人可以分析存放在本地的</span></strong><strong><span style="color:#000000;">COOKIE</span></strong><strong><span style="color:#000000;">并进行</span></strong><strong><span style="color:#000000;">COOKIE</span></strong><strong><span style="color:#000000;">欺骗考虑到安全应当使用</span></strong><strong><span style="color:#000000;">session</span></strong><strong><span style="color:#000000;">。</span></strong></p> 
<p style="margin-left:0cm;"><strong><span style="color:#000000;">（</span></strong><strong><span style="color:#000000;">3</span></strong><strong><span style="color:#000000;">）</span></strong><strong><span style="color:#000000;">session</span></strong><strong><span style="color:#000000;">会在一定时间内保存在服务器上。当访问增多，会比较占用服务器的性能考虑到减轻服务器性能方面，应当使用</span></strong><strong><span style="color:#000000;">COOKIE</span></strong><strong><span style="color:#000000;">。</span></strong></p> 
<p style="margin-left:0cm;"><strong><span style="color:#000000;">（</span></strong><strong><span style="color:#000000;">4</span></strong><strong><span style="color:#000000;">）单个</span></strong><strong><span style="color:#000000;">cookie</span></strong><strong><span style="color:#000000;">保存的数据不能超过</span></strong><strong><span style="color:#000000;">4K</span></strong><strong><span style="color:#000000;">，很多浏览器都限制一个站点最多保存</span></strong><strong><span style="color:#000000;">20</span></strong><strong><span style="color:#000000;">个</span></strong><strong><span style="color:#000000;">cookie</span></strong><strong><span style="color:#000000;">。</span></strong></p> 
<p style="margin-left:0cm;"><strong><span style="color:#000000;">（</span></strong><strong><span style="color:#000000;">5</span></strong><strong><span style="color:#000000;">）建议：</span></strong><br><strong>   </strong><strong><span style="color:#000000;">将登陆信息等重要信息存放为</span></strong><strong><span style="color:#000000;">SESSION<br>    </span></strong><strong><span style="color:#000000;">其他信息如果需要保留，可以放在</span></strong><strong><span style="color:#000000;">COOKIE</span></strong><strong><span style="color:#000000;">中</span></strong></p> 
<h3 style="margin-left:0cm;"><strong><a name="_Toc505361750"></a><a name="_Toc28543"></a><a name="_Toc8154"></a><a name="_Toc31585"></a><a name="_Toc681"><span style="color:#000000;">4</span></a><span style="color:#000000;">．请简单说一下三次握手和四次挥手？什么是2msl？为什么要这样做？</span></strong></h3> 
<p style="margin-left:0cm;"><img alt="" class="has" height="648" src="https://images2.imgbox.com/c0/52/mnbNPrLp_o.png" width="464"></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">（1）2MSL即两倍的MSL，TCP的TIME_WAIT状态也称为2MSL等待状态，</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">（2）当TCP的一端发起主动关闭，在发出最后一个ACK包后，即第3次握手完成后发送了第四次握手的ACK包后就进入了TIME_WAIT状态，</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">必须在此状态上停留两倍的MSL时间，等待2MSL时间主要目的是怕最后一个 ACK包对方没收到，那么对方在超时后将重发第三次握手的FIN包，主动关闭端接到重发的FIN包后可以再发一个ACK应答包。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">（3）在TIME_WAIT状态</span> <span style="color:#000000;">时两端的端口不能使用，要等到2MSL时间结束才可继续使用。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">（4）当连接处于2MSL等待阶段时任何迟到的报文段都将被丢弃。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">不过在实际应用中可以通过设置 SO_REUSEADDR选项达到不必等待2MSL时间结束再使用此端口。</span></p> 
<h3 style="margin-left:0cm;"><strong><a name="_Toc505361700"></a><a name="_Toc24030"></a><a name="_Toc15714"></a><a name="_Toc26203"></a><a name="_Toc14281"></a><a name="_Toc19518"></a><a name="_Toc4124"><span style="color:#000000;">5</span></a><span style="color:#000000;">．什么是僵尸进程和孤儿进程,怎么避免僵尸进程</span><span style="color:#000000;">?</span></strong></h3> 
<p style="margin-left:0cm;"><span style="color:#000000;">（1）孤儿进程：父进程退出，子进程还在运行的这些子进程都是孤儿进程，孤儿进程将被init进程(进</span> <span style="color:#000000;">程号为1)所收养，并由init进程对它们完成状态收集工作。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">（2）僵尸进程：进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中的这些进程是僵尸进程。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">（3）避免僵尸进程的方法：</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">1.fork两次用孙子进程去完成子进程的任务。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">2.用wait()函数使父进程阻塞。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">3.使用信号量，在signal handler中调用 waitpid，这样父进程不用阻塞。</span></p> 
<h3 style="margin-left:0cm;"><strong><a name="_Toc505361745"></a><a name="_Toc22031"><span style="color:#000000;">6.</span></a><span style="color:#000000;">长链接与短链接的区别？</span></strong></h3> 
<p style="margin-left:0cm;"><span style="color:#000000;">（1）短连接</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">连接-&gt;传输数据-&gt;关闭连接</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">HTTP</span><span style="color:#000000;">是无状态的，浏览器和服务器每进行一次HTTP操作，就建立一次连接，但任务结束后就中断连接。短连接是指SOCKET连接后发送后接收完数据后马上断开连接。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">（2）长连接</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">连接-&gt;传输数据-&gt;保持连接-&gt;传输数据-&gt;....-&gt;关闭连接</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">长连接指建立SOCKET连接后不管是否使用都保持连接，但安全性较差。</span></p> 
<h3 style="margin-left:0cm;"><strong><a name="_Toc505361746"></a><a name="_Toc1937"><span style="color:#000000;">7.HTTP</span></a><span style="color:#000000;">协议状态码有什么用，都表示什么意思</span><span style="color:#000000;">？</span></strong></h3> 
<p style="margin-left:0cm;"><span style="color:#000000;">作用：告诉用户当前操作所处的状态</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">200 OK </span><span style="color:#000000;">服务器成功处理了请求（这个是我们见到最多的）</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">301/302 Moved Permanently</span><span style="color:#000000;">（重定向）请求的URL已移走。Response中应该包含一个Location URL, 说明资源现在所处的位置</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">304 Not Modified</span><span style="color:#000000;">（未修改）客户的缓存资源是最新的， 要客户端使用缓存</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">404 Not Found </span><span style="color:#000000;">未找到资源</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">501 Internal Server Error</span><span style="color:#000000;">服务器遇到一个错误，使其无法对请求提供服</span></p> 
<h3 style="margin-left:0cm;"><strong><span style="color:#000000;">8</span><span style="color:#000000;">、死锁</span></strong></h3> 
<p style="margin-left:0cm;"><span style="color:#000000;">（1）原因: 1.竞争资源2.程序推进顺序不当</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">（2）必要条件：1.互斥条件2.请求和保持条件3.不剥夺条件4.环路等待条件</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">（3）处理死锁基本方法：</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">1</span><span style="color:#000000;">、预防死锁(摒弃除1以外的条件)</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">2</span><span style="color:#000000;">、避免死锁(银行家算法)</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">3</span><span style="color:#000000;">、检测死锁(资源分配图)</span></p> 
<p style="margin-left:0cm;">    <span style="color:#000000;">（4）解除死锁:1.剥夺死锁 2.撤销进程</span></p> 
<h3 style="margin-left:0cm;"><strong><a name="_Toc505361753"></a><a name="_Toc10173"><span style="color:#000000;">9.</span></a><span style="color:#000000;">从输入http://www.baidu.com/到页面返回，中间都是发生了什么？</span></strong></h3> 
<p style="margin-left:7.1pt;"><span style="color:#000000;">(浏览器发送一个请求到返回一个页面的具体过程)</span></p> 
<p style="margin-left:0cm;"><a name="_Toc28862"><span style="color:#000000;">第一步，解析域名，找到</span></a><span style="color:#000000;">ip</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">浏览器会缓存DNS一段时间，一般2-30分钟不等，如果有缓存，直接返回ip，否则下一步。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">缓存中无法找到ip，浏览器会进行一个系统调用，查询hosts文件。如果找到，直接返回ip，否则下一步。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">进行1 和2 本地查询无果，只能借助于网络，路由器一般都会有自己的DNS缓存，ISP服务商DNS缓存，这时一般都能够得到相应的ip，如果还是无果，只能借助于DNS递归解析了。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">这时ISP的DNS服务器就会开始从根域名服务器开始递归搜索，从.com 顶级域名服务器，到baidu的域名服务器。</span> <br><span style="color:#000000;">到这里，浏览器就获得网络ip，在DNS解析过程中，常常解析出不同的IP。</span></p> 
<p style="margin-left:0cm;"><a name="_Toc25090"><span style="color:#000000;">第二步，浏览器于网站建立</span></a><span style="color:#000000;">TCP连接</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">浏览器利用ip直接网站主机通信，浏览器发出TCP连接请求，主机返回TCP应答报文，浏览器收到应答报文发现ACK标志位为1，表示连接请求确认，浏览器返回TCP（）确认报文，主机收到确认报文，三次握手，TCP连接建立完成。</span></p> 
<p style="margin-left:0cm;"><a name="_Toc22124"><span style="color:#000000;">第三步，</span></a> <span style="color:#000000;">浏览器发起默认的GET请求</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">浏览器向主机发起一个HTTP-GET方法报文请求，请求中包含访问的URL，也就是<a href="http://www.baidu.com/" rel="nofollow"><span style="color:#000000;">http://www.baidu.com/</span></a>还有User-Agent用户浏览器操作系统信息，编码等，值得一提的是Accep-Encoding和Cookies项。Accept-Encoding一般采用gzip，压缩之后传输html文件，Cookies如果是首次访问，会提示服务器简历用户缓存信息，如果不是，可以利用Cookies对应键值，找到相应缓存，缓存里面存放着用户名，密码和一些用户设置项</span></p> 
<p style="margin-left:0cm;"><a name="_Toc8766"><span style="color:#000000;">第四步，显示页面或返回其他</span></a></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">返回状态码200 OK，表示服务器可以响应请求，返回报文，由于在报头中Content-type为“text/html”,浏览器以HTML形式呈现，而不是下载文件。</span> <br><span style="color:#000000;">但是对于大型网站存在多个主机站点，往往不会直接返回请求页面，而是重定向。返回的状态码就不是 200 OK，</span> <span style="color:#000000;">而是301,302以3开头的重定向吗。浏览器在获取了重定向响应后，在响应报文中Location项找到重定向地址，浏览器重新第一步访问即可。</span></p> 
<p style="margin-left:0cm;"><strong><span style="color:#000000;">10.</span></strong><strong><span style="color:#000000;">使用</span></strong><strong><span style="color:#000000;">Socket</span></strong><strong><span style="color:#000000;">套接字需要传入哪些参数：</span></strong></p> 
<p style="margin-left:0cm;"><strong><span style="color:#000000;">1.</span></strong><strong><span style="color:#000000;">通讯方式</span></strong><span style="color:#333333;">可以选择AF_INET（用于 Internet 进程间通信） 或者 AF_UNIX（用于同一台机器进程间通信）,实际工作中常用AF_INET</span></p> 
<p style="margin-left:0cm;"><strong><span style="color:#000000;">2.</span></strong><strong><span style="color:#000000;">套接字类型</span></strong><span style="color:#333333;">套接字类型，</span><span style="color:#333333;">可以是 SOCK_STREAM（流式套接字，主要用于 TCP 协议）或者 SOCK_DGRAM（数据报套接字，主要用于 UDP 协议）</span></p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;"> </p> 
<h3 style="margin-left:0cm;"><strong><span style="color:#000000;">                                              第三章 数据库</span></strong></h3> 
<h3 style="margin-left:0cm;"><strong><span style="color:#000000;">1.</span><span style="color:#000000;">说一下mysql数据库存储的原理？</span></strong></h3> 
<p style="margin-left:0cm;"><span style="color:#000000;">储存过程是一个可编程的函数，它在数据库中创建并保存。它可以有SQL语句和一些特殊的控制结构组成。当希望在不同的应用程序或平台上执行相同的函数，或者封装特定功能时，存储过程是非常有用的。数据库中的存储过程可以看做是对编程中面向对象方法的模拟。它允许控制数据的访问方式。存储过程通常有以下优点：</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">a</span><span style="color:#000000;">、存储过程能实现较快的执行速度。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">b</span><span style="color:#000000;">、存储过程允许标准组件是编程。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">c</span><span style="color:#000000;">、存储过程可以用流程控制语句编写，有很强的灵活性，可以完成复杂的判断和较复杂的运算。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">d</span><span style="color:#000000;">、存储过程可被作为一种安全机制来充分利用。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">e</span><span style="color:#000000;">、存储过程能够减少网络流量。</span></p> 
<h3 style="margin-left:0cm;"><strong><span style="color:#000000;">2.</span><span style="color:#000000;">事务的特性？</span></strong></h3> 
<p style="margin-left:0cm;"><span style="color:#000000;">（1）原子性(Atomicity)：事务中的全部操作在数据库中是不可分割的，要么全部完成，要么均不执行。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">（2）一致性(Consistency)：几个并行执行的事务，其执行结果必须与按某一顺序串行执行的结果相一致。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">（3）隔离性(Isolation)：事务的执行不受其他事务的干扰，事务执行的中间结果对其他事务必须是透明的。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">（4）持久性(Durability)：对于任意已提交事务，系统必须保证该事务对数据库的改变不被丢失，即使数据库出现故障</span></p> 
<h3 style="margin-left:0cm;"><strong><a name="_Toc16879"></a><a name="_Toc505266664"></a><a name="_Toc5436"><span style="color:#000000;">3</span></a><span style="color:#000000;">．使用Mysql数据库中的</span><span style="color:#000000;">事务的方法？</span></strong></h3> 
<p style="margin-left:18pt;"><span style="color:#000000;">MYSQL </span><span style="color:#000000;">事务处理主要有两种方法：</span></p> 
<p style="margin-left:18pt;"><a name="_Toc31107"><span style="color:#000000;">1</span></a><span style="color:#000000;">、用 BEGIN, ROLLBACK, COMMIT来实现</span></p> 
<p style="margin-left:18pt;"><span style="color:#000000;">BEGIN </span><span style="color:#000000;">开始一个事务</span></p> 
<p style="margin-left:18pt;"><span style="color:#000000;">ROLLBACK </span><span style="color:#000000;">事务回滚</span></p> 
<p style="margin-left:18pt;"><span style="color:#000000;">COMMIT </span><span style="color:#000000;">事务确认</span></p> 
<p style="margin-left:18pt;"><a name="_Toc20015"><span style="color:#000000;">2</span></a><span style="color:#000000;">、直接用 SET 来改变 MySQL 的自动提交模式:</span></p> 
<p style="margin-left:18pt;"><span style="color:#000000;">SET AUTOCOMMIT=0 </span><span style="color:#000000;">禁止自动提交</span></p> 
<p style="margin-left:18pt;"><span style="color:#000000;">SET AUTOCOMMIT=1 </span><span style="color:#000000;">开启自动提交</span></p> 
<p style="margin-left:0cm;"><strong><span style="color:#000000;">4</span></strong><strong><span style="color:#000000;">．数据库索引</span></strong></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">数据库索引，是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。索引的实现通常使用B_TREE。B_TREE索引加速了数据访问，因为存储引擎不会再去扫描整张表得到需要的数据；相反，它从根节点开始，根节点保存了子节点的指针，存储引擎会根据指针快速寻找数据。</span></p> 
<h3 style="margin-left:0cm;"><strong><a name="_Toc31329"></a><a name="_Toc505266667"><span style="color:#000000;">5</span></a><span style="color:#000000;">．索引怎么建立？原理是什么？</span></strong></h3> 
<p style="margin-left:17.8pt;"><span style="color:#000000;">在表格上面创建某个一个唯一的索引。唯一的索引意味着两个行不能拥有相同的索引值。</span></p> 
<p style="margin-left:17.8pt;"><span style="color:#000000;">CREATE UNIQUE INDEX </span><span style="color:#000000;">索引名称</span></p> 
<p style="margin-left:17.8pt;"><span style="color:#000000;">ON </span><span style="color:#000000;">表名称 (列名称) </span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">“列名称”规定你需要索引的列</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">原理：索引问题就是一个查找问题。</span></p> 
<p style="margin-left:17.8pt;"><span style="color:#000000;">数据库索引，是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。索引的实现通常使用B树及其变种B+树。<br> 在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。</span></p> 
<p style="margin-left:0cm;"><strong><span style="color:#000000;">6.</span></strong><strong><span style="color:#000000;">在关系型数据库中，索引（index）存在的意义是什么？</span></strong></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">（1）通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">（2）可以大大加快数据的检索速度，这也是创建索引的最主要的原因。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">（3）可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">（4）在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">（5）通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。 </span></p> 
<p style="margin-left:0cm;"><strong><span style="color:#000000;">7.BTree</span></strong><strong><span style="color:#000000;">索引和Hash索引的优缺点各是什么？</span></strong></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">（1）BTree（多路搜索树，并不是二叉的）是一种常见的数据结构。使用BTree结构可以显著减少定位记录时所经历的中间过程，从而加快存取速度。这个数据结构一般用于数据库的索引，综合效率较高。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">不适合：单列索引的列不能包含null的记录，复合索引的各个列不能包含同时为null的记录，否则会全表扫描；</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">不适合键值较少的列（重复数据较多的列）；前导模糊查询不能利用索引(like '%XX'或者like '%XX%')</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">（2）Hash散列索引</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">Hash</span><span style="color:#000000;">散列索引是根据HASH算法来构建的索引。虽然 Hash 索引效率高，但是 Hash 索引本身由于其特殊性也带来了很多限制和弊端，主要有以下这些。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">适合：精确查找非常快（包括= &lt;&gt; 和in），其检索效率非常高，索引的检索可以一次定位，不像BTree 索引需要从根节点到枝节点，所以 Hash 索引的查询效率要远高于 B-Tree 索引。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">不适合：</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">1</span><span style="color:#000000;">、不适合模糊查询和范围查询（包括like，&gt;，&lt;，between……and等），由于 Hash 索引比较的是进行 Hash 运算之后的 Hash 值，所以它只能用于等值的过滤，不能用于基于范围的过滤，因为经过相应的 Hash 算法处理之后的 Hash 值的大小关系，并不能保证和Hash运算前完全一样；</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">2</span><span style="color:#000000;">、不适合排序，数据库无法利用索引的数据来提升排序性能，同样是因为Hash值的大小不确定；</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">复合索引不能利用部分索引字段查询，Hash 索引在计算 Hash 值的时候是组合索引键合并后再一起计算 Hash 值，而不是单独计算 Hash 值，所以通过组合索引的前面一个或几个索引键进行查询的时候，Hash 索引也无法被利用。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">同样不适合键值较少的列（重复值较多的列）；</span></p> 
<p style="margin-left:0cm;"><strong><span style="color:#000000;">8.redis </span></strong><strong><span style="color:#000000;">和 mysql 的区别 </span></strong></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">readis </span><span style="color:#000000;">是内存数据库， 数据保存在内存中， 速度快。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">mysql </span><span style="color:#000000;">是关系型数据库，持久化存储，存放在磁盘里面，功能强大。检索的话， 会涉及到一定的 IO， 数据访问也就慢。</span></p> 
<p style="margin-left:0cm;"><strong><span style="color:#000000;">9.</span></strong><strong><span style="color:#000000;">你用的mysql是哪个引擎，各引擎之间有什么区别？</span></strong></p> 
<p style="margin-left:0cm;"><strong><span style="color:#000000;">主要 MyISAM 与 InnoDB 两个引擎，其主要区别如下：</span></strong></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">InnoDB </span><span style="color:#000000;">支持事务，MyISAM 不支持，这一点是非常之重要。事务是一种高级的处理方式，如在一些列增删改中只要哪个出错还可以回滚还原，而 MyISAM就不可以了；</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">MyISAM </span><span style="color:#000000;">适合查询以及插入为主的应用，InnoDB 适合频繁修改以及涉及到安全性较高的应用；</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">InnoDB </span><span style="color:#000000;">支持外键，MyISAM 不支持；</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">MyISAM </span><span style="color:#000000;">是默认引擎，InnoDB 需要指定；</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">InnoDB </span><span style="color:#000000;">不支持 FULLTEXT 类型的索引；</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">InnoDB </span><span style="color:#000000;">中不保存表的行数，如 select count(*) from table 时，InnoDB；需要扫描一遍整个表来计算有多少行，但是 MyISAM 只要简单的读出保存好的行数即可。注意的是，当 count(*)语句包含 where 条件时 MyISAM 也需要扫描整个表；</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">对于自增长的字段，InnoDB 中必须包含只有该字段的索引，但是在 MyISAM表中可以和其他字段一起建立联合索引；清空整个表时，InnoDB 是一行一行的删除，效率非常慢。MyISAM 则会重建表；</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">InnoDB </span><span style="color:#000000;">支持行锁（某些情况下还是锁整表，如 update table set a=1 where user like '%lee%'</span></p> 
<p style="margin-left:0cm;"><strong><span style="color:#000000;">10.Redis</span></strong><strong><span style="color:#000000;">和MongoDB的优缺点</span></strong></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">MongoDB </span><span style="color:#000000;">和 Redis 都是 NoSQL， 采用结构型数据存储。 二者在使用场景中， 存在一定的区别， 这也主要由于二者在内存映射的处理过程， 持久化的处理方法不同。 MongoDB 建议集群部署， 更多的考虑到集群方案，Redis 更偏重于进程顺序写入， 虽然支持集群， 也仅限于主-从模式.</span></p> 
<p style="margin-left:0cm;"><strong><span style="color:#000000;">Redis </span></strong><strong><span style="color:#000000;">优点：</span></strong></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">读写性能优异</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">支持数据持久化， 支持 AOF 和 RDB 两种持久化方式</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">支持主从复制， 主机会自动将数据同步到从机， 可以进行读写分离。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">数据结构丰富： 除了支持 string 类型的 value 外还支持string、 hash、 set、 sortedset、 list 等数据结构。</span></p> 
<p style="margin-left:0cm;"><strong><span style="color:#000000;">Redis</span></strong><strong><span style="color:#000000;">缺点：</span></strong></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">Redis </span><span style="color:#000000;">不具备自动容错和恢复功能， 主机从机的宕机都会导致前端部分读写请求失败， 需要等待机器重启或者手动切换前端的 IP才能恢复。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">主机宕机， 宕机前有部分数据未能及时同步到从机， 切换 IP后还会引入数据不一致的问题， 降低了系统的可用性。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">Redis </span><span style="color:#000000;">的主从复制采用全量复制， 复制过程中主机会 fork 出一个子进程对内存做一份快照， 并将子进程的内存快照保存为文件发送给从机， 这一过程需要确保主机有足够多的空余内存。 若快照文件较大， 对集群的服务能力会产生较大的影响， 而且复制过程是在从机新加入集群或者从机和主机网络断开重连时都会进行， 也就是网络波动都会造成主机和从机间的一次全量的数据复制， 这对实际的系统运营造成了不小的麻烦。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">Redis </span><span style="color:#000000;">较难支持在线扩容， 在集群容量达到上限时在线扩容会变得很复杂。 为避免这一问题， 运维人员在系统上线时必须确保有足够的空间， 这对资源造成了很大的浪费。</span></p> 
<p style="margin-left:0cm;"><strong><span style="color:#000000;">MongoDB</span></strong><strong><span style="color:#000000;">优点:</span></strong></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">弱一致性（最终一致） ， 更能保证用户的访问速度文档结构的存储方式， 能够更便捷的获取数内置 GridFS， 高效存储二进制大对象 (比如照片和视频)</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">支持复制集、 主备、 互为主备、 自动分片等特性</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">动态查询</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">全索引支持,扩展到内部对象和内嵌数组</span></p> 
<p style="margin-left:0cm;"><strong><span style="color:#000000;">MongoDB</span></strong><strong><span style="color:#000000;">缺点：</span></strong></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">不支持事务</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">MongoDB </span><span style="color:#000000;">占用空间过大</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">维护工具不够成熟</span></p> 
<p style="margin-left:0cm;"><strong><span style="color:#000000;">10.</span></strong><strong><span style="color:#000000;">数据库优化方案</span></strong></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">优化索引、SQL 语句、分析慢查询</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">设计表的时候严格根据数据库的设计范式来设计数据库</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">使用缓存，把经常访问到的数据而且不需要经常变化的数据放在缓存中，能节约磁盘IO</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">优化硬件；采用SSD，使用磁盘队列技术(RAID0,RAID1,RDID5)等；</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">采用MySQL 内部自带的表分区技术，把数据分层不同的文件，能够提高磁盘的读取效率</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">垂直分表；把一些不经常读的数据放在一张表里，节约磁盘I/O</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">主从分离读写；采用主从复制把数据库的读操作和写入操作分离开来</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">分库分表分机器（数据量特别大），主要的的原理就是数据路由</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">选择合适的表引擎，参数上的优化</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">进行架构级别的缓存，静态化和分布式</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">不采用全文索引</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">采用更快的存储方式，例如NoSql存储经常访问的数据</span></p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;"><strong><span style="color:#000000;">11.</span></strong><strong><span style="color:#000000;">怎样解决海量数据的存储和访问造成系统设计瓶颈的问题？ </span></strong></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">- </span><span style="color:#000000;">水平切分数据库： 可以降低单台机器的负载， 同时最大限度的降低了宕机造成的损失； 分库降低了单点机器的负载； 分表， 提高了数据操作的效率，</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">- </span><span style="color:#000000;">负载均衡策略： 可以降低单台机器的访问负载， 降低宕机的可能性；</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">- </span><span style="color:#000000;">集群方案：解决了数据库宕机带来的单点数据库不能访问的问题；</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">- </span><span style="color:#000000;">读写分离策略：最大限度了提高了应用中读取数据的速度和并发量；</span></p> 
<p style="margin-left:0cm;"><a name="_Toc505266680"></a><a name="_Toc10656"><strong><span style="color:#000000;">12.</span></strong></a><strong><span style="color:#000000;">怎样解决数据库高并发的问题？</span></strong></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">解决数据库高并发：</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">分表分库</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">数据库索引</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">redis缓存数据库</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">读写分离</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">负载均衡集群：将大量的并发请求分担到多个处理节点。由于单个处理节点的故障不影响整个服务，负载均衡集群同时也实现了高可用性。</span></p> 
<p style="margin-left:0cm;"><strong><span style="color:#000000;">12.</span></strong><strong><span style="color:#000000;">数据库负载均衡</span></strong></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">负载均衡集群是由一组相互独立的计算机系统构成，通过常规网络或专用网络进行连接， 由路由器衔接在一起， 各节点相互协作、 共同负载、 均衡压力， 对客户端来说， 整个群集可以视为一台具有超高性能的独立服务器。</span></p> 
<p style="margin-left:0cm;"><strong><span style="color:#000000;">1</span></strong><strong><span style="color:#000000;">、 实现原理</span></strong></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">实现数据库的负载均衡技术，首先要有一个可以控制连接数据库的控制端。 在这里， 它截断了数据库和程序的直接连接， 由所有的程序来访问这个中间层， 然后再由中间层来访问数据库。 这样， 我们就可以具体控制访问某个数据库了，然后还可以根据数据库的当前负载采取有效的均衡策略， 来调整每次连接到哪个数据库。</span></p> 
<p style="margin-left:0cm;"><strong><span style="color:#000000;">2</span></strong><strong><span style="color:#000000;">、 实现多据库数据同步</span></strong></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">对于负载均衡，最重要的就是所有服务器的数据都是实时同步的。这是一个集群所必需的， 因为， 如果数不据实时、 不同步， 那么用户从一台服务器读出的数据， 就有别于从另一台服务器读出的数据， 这是不能允许的。 所以必须实现数据库的数据同步。 这样， 在查询的时候就可以有多个资源， 实现均衡。比较常用的方法是 Moebius for SQL Server 集群， Moebius for SQL Server 集群采用将核心程序驻留在每个机器的数据库中的办法， 这个核心程序称为 Moebius for SQL Server 中间件， 主要作用是监测数据库内数据的变化并将变化的数据同步到其他数据库中。 数据同步完成后客户端才会得到响应， 同步过程是并发完成的，所以同步到多个数据库和同步到一个数据库的时间基本相等； 另外同步的过程是在事务的环境下完成的， 保证了多份数据在任何时刻数据的一致性。 正因为 Moebius 中间件宿主在数据库中的创新， 让中间件不但能知道数据的变化， 而且知道引起数据变化的 SQL 语句，根据 SQL 语句的类型智能的采取不同的数据同步的策略以保证数据同步成本的最小化。数据条数很少， 数据内容也不大， 则直接同步数据数据条数很少， 但是里面包含大数据类型， 比如文本， 二进制数</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">据等， 则先对数据进行压缩然后再同步， 从而减少网络带宽的占用和传输所用的时间。数据条数很多，此时中间件会拿到造成数据变化的 SQL 语句， 然后对 SQL 语句进行解析， 分析其执行计划和执行成本， 并选择是同步数据还是同步 SQL 语句到其他的数据库中。此种情况应用在对表结构进行调整或者批量更改数据的时候非常有用。</span></p> 
<p style="margin-left:0cm;"><strong><span style="color:#000000;">3</span></strong><strong><span style="color:#000000;">、 优缺点优点：</span></strong></p> 
<p style="margin-left:0cm;"><strong><span style="color:#000000;">**</span></strong><strong><span style="color:#000000;">优点：**</span></strong></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">- (1) </span><span style="color:#000000;">扩展性强： 当系统要更高数据库处理速度时， 只要简单地增加数据库服务器就 可以得到扩展。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">- (2) </span><span style="color:#000000;">可维护性： 当某节点发生故障时， 系统会自动检测故障并转移故障节点的应用， 保证数据库的持续工作。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">- (3) </span><span style="color:#000000;">安全性： 因为数据会同步的多台服务器上， 可以实现数据集的冗余， 通过多份数据来保证安全性。 另外它成功地将数据库放到了内网之中， 更好地保护了数据库的安全性。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">- (4) </span><span style="color:#000000;">易用性： 对应用来说完全透明， 集群暴露出来的就是一个IP</span></p> 
<p style="margin-left:0cm;"><strong><span style="color:#000000;">**</span></strong><strong><span style="color:#000000;">缺点：**</span></strong></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">- (1) </span><span style="color:#000000;">不能够按照 Web 服务器的处理能力分配负载。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">- (2) </span><span style="color:#000000;">负载均衡器(控制端)故障， 会导致整个数据库系统瘫痪。</span></p> 
<p style="margin-left:0cm;"><a name="_Toc505266665"></a><a name="_Toc27606"><strong><span style="color:#000000;">13.</span></strong></a><strong><span style="color:#000000;">数据库备份怎么做，服务器挂了怎么办？</span></strong></p> 
<p style="margin-left:18pt;"><strong><span style="color:#000000;">备份数据库</span></strong></p> 
<p style="margin-left:18pt;"><span style="color:#000000;">shell&gt; mysqldump -h host -u root -p dbname &gt;dbname_backup.sql</span></p> 
<p style="margin-left:18pt;"><strong><span style="color:#000000;">恢复数据库</span></strong></p> 
<p style="margin-left:18pt;"><span style="color:#000000;">shell&gt; mysqladmin -h myhost -u root -p create dbname</span></p> 
<p style="margin-left:18pt;"><span style="color:#000000;">shell&gt; mysqldump -h host -u root -p dbname &lt; dbname_backup.sql</span></p> 
<p style="margin-left:0cm;"><a name="_Toc30926"></a><a name="_Toc505266715"><strong><span style="color:#000000;">14.</span></strong></a><strong><span style="color:#000000;">如何把整个数据库导出来，再导入指定数据库中</span></strong></p> 
<p style="margin-left:0cm;"><strong><span style="color:#000000;">导出：</span></strong></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">mysqldump  [-h</span><span style="color:#000000;">主机]  -u用户名 -p 数据库名 &gt; 导出的数据库名.sql</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">导入指定的数据库中:</span></p> 
<p style="margin-left:0cm;"><a name="_Toc16440"><strong><span style="color:#000000;">第一种方法：</span></strong></a></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">mysqldump  [-h</span><span style="color:#000000;">主机]   -u用户名 -p 数据库名 &lt; 导出的数据库名.sql</span></p> 
<p style="margin-left:0cm;"><a name="_Toc15908"><strong><span style="color:#000000;">第二种方法：</span></strong></a></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">先创建好数据库,因为导出的文件里没有创建数据库的语句,如果数据库已经建好,则不用再创建。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">create database example charset=utf8;</span><span style="color:#000000;">（数据库名可以不一样）  </span></p> 
<p style="margin-left:0cm;"><strong><span style="color:#000000;">切换数据库：</span></strong></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">use example;  </span></p> 
<p style="margin-left:0cm;"><strong><span style="color:#000000;">导入指定sql文件：</span></strong></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">mysql&gt;source /path/example.sql;  </span></p> 
<p style="margin-left:0cm;"><strong><span style="color:#000000;">15.</span></strong><strong><span style="color:#000000;">数据库怎么优化查询效率？</span></strong></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">1</span><span style="color:#000000;">、储存引擎选择：如果数据表需要事务处理，应该考虑使用InnoDB，因为它完全符合ACID特性。如果不需要事务处理，使用默认存储引擎MyISAM是比较明智的</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">2</span><span style="color:#000000;">、分表分库，主从。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">3</span><span style="color:#000000;">、对查询进行优化，要尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">4</span><span style="color:#000000;">、应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">5</span><span style="color:#000000;">、应尽量避免在 where 子句中使用 != 或 &lt;&gt; 操作符，否则将引擎放弃使用索引而进行全表扫描</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">6</span><span style="color:#000000;">、应尽量避免在 where 子句中使用 or 来连接条件，如果一个字段有索引，一个字段没有索引，将导致引擎放弃使用索引而进行全表扫描</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">7</span><span style="color:#000000;">、Update 语句，如果只更改1、2个字段，不要Update全部字段，否则频繁调用会引起明显的性能消耗，同时带来大量日志</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">8</span><span style="color:#000000;">、对于多张大数据量（这里几百条就算大了）的表JOIN，要先分页再JOIN，否则逻辑读会很高，性能很差。</span></p> 
<h3 style="margin-left:0cm;"><strong><a name="_Toc2431"></a><a name="_Toc505266672"><span style="color:#000000;">16.</span></a><span style="color:#000000;">如果每天有5T的用户数据量需要存入mysql中，怎么优化数据库？</span></strong></h3> 
<p style="margin-left:0cm;"><span style="color:#000000;">1</span><span style="color:#000000;">、尽量使数据库一次性写入Data File <br>     2、减少数据库的checkpoint 操作 <br>     3、程序上尽量缓冲数据，进行批量式插入与提交 <br>     4、减少系统的IO冲突</span></p> 
<h3 style="margin-left:0cm;"><strong><a name="_Toc505266663"></a><a name="_Toc3135"><span style="color:#000000;">17.</span></a><span style="color:#000000;">如何查找MySQL中查询慢的SQL语句</span></strong></h3> 
<p style="margin-left:18pt;"><a name="_Toc14774"><span style="color:#000000;">1</span></a><span style="color:#000000;">，slow_query_log</span></p> 
<p style="margin-left:18pt;"><span style="color:#000000;">这个参数设置为ON，可以捕获执行时间超过一定数值的SQL语句。</span></p> 
<p style="margin-left:18pt;"><a name="_Toc10888"><span style="color:#000000;">2</span></a><span style="color:#000000;">，long_query_time</span></p> 
<p style="margin-left:18pt;"><span style="color:#000000;">当SQL语句执行时间超过此数值时，就会被记录到日志中，建议设置为1或者更短。</span></p> 
<p style="margin-left:0cm;"> </p> 
<h3 style="margin-left:0cm;"><strong><span style="color:#000000;">                                                 第四章 前端</span></strong></h3> 
<p style="margin-left:0cm;"><strong><span style="color:#000000;">1.</span></strong><strong><span style="color:#000000;">什么是css初始化？有什么好处？</span></strong></p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;"><span style="color:#000000;">- CSS</span><span style="color:#000000;">初始化是指重设浏览器的样式。不同的浏览器默认的样式可能不尽相同，如果没对CSS初始化往往会出现浏览器之间的页面差异。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">- </span><span style="color:#000000;">好处：能够统一标签在各大主流浏览器中的默认样式，使得我们开发网页内容时更加方便简洁，同时减少CSS代码量，节约网页下载时间。</span></p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;"><strong><span style="color:#000000;">2.</span></strong><strong><span style="color:#000000;">简述浮动的特征和清除浮动的方法？</span></strong></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">- <strong>**</strong></span><strong><span style="color:#000000;">浮动的特征：**</span></strong></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">- </span><span style="color:#000000;">浮动元素有左浮动(float:left)和右浮动(float:right)两种</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">- </span><span style="color:#000000;">浮动的元素会向左或向右浮动，碰到父元素边界、其他元素才停下来</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">- </span><span style="color:#000000;">相邻浮动的块元素可以并在一行，超出父级宽度就换行</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">- </span><span style="color:#000000;">浮动让行内元素或块元素转化为有浮动特性的行内块元素(此时不会有行内块元素间隙问题)</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">- </span><span style="color:#000000;">父元素如果没有设置尺寸(一般是高度不设置)，父元素内整体浮动的子元素无法撑开父元素，父元素需要清除浮动</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">- <strong>**</strong></span><strong><span style="color:#000000;">清除浮动的方法：**</span></strong></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">- </span><span style="color:#000000;">父级上增加属性overflow：hidden</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">- </span><span style="color:#000000;">在最后一个子元素的后面加一个空的div，给它样式属性 clear:both</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">- </span><span style="color:#000000;">使用成熟的清浮动样式类，clearfix</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">```css</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">.clearfix:after,.clearfix:before{ content: "";display: table;}</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">.clearfix:after{ clear:both;}</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">.clearfix{zoom:1;}</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">```</span></p> 
<h3 style="margin-left:0cm;"><strong><a name="_Toc505266660"></a><a name="_Toc3257"><span style="color:#000000;">3.</span></a><span style="color:#000000;">对react和vue的了解？</span> </strong></h3> 
<p style="margin-left:0cm;"><strong><span style="color:#000000;">      React</span></strong><strong><span style="color:#000000;">是一个用于构建用户界面的</span></strong><strong><span style="color:#000000;">js</span></strong><strong><span style="color:#000000;">库</span></strong><strong><span style="color:#000000;"> React</span></strong><strong><span style="color:#000000;">主要用于构建</span></strong><strong><span style="color:#000000;">UI</span></strong><strong><span style="color:#000000;">，</span></strong><strong> </strong><strong><span style="color:#000000;">是</span></strong><strong><span style="color:#000000;"> MVC </span></strong><strong><span style="color:#000000;">中的</span></strong><strong><span style="color:#000000;"> V</span></strong><strong><span style="color:#000000;">（视图）拥有较高的性能，代码逻辑非常简单</span></strong></p> 
<p style="margin-left:0cm;"><strong><span style="color:#000000;">   Vue </span></strong><strong><span style="color:#000000;">是一套用于构建用户界面的渐进式框架</span></strong><strong><span style="color:#000000;">Vue </span></strong><strong><span style="color:#000000;">被设计为可以自底向上逐层应用。</span></strong><strong><span style="color:#000000;">Vue </span></strong><strong><span style="color:#000000;">的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。</span></strong></p> 
<p style="margin-left:0cm;"> </p> 
<p> </p> 
<h3 style="margin-left:0cm;"><strong><span style="color:#000000;">                                                  第五章 web框架</span></strong></h3> 
<p style="margin-left:0cm;"><strong><span style="color:#000000;">1.MVC</span></strong><strong><span style="color:#000000;">解读</span></strong></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">M</span><span style="color:#000000;">：Model，模型，和数据库进行交互</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">V</span><span style="color:#000000;">：View，视图，负责产生Html页面</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">C</span><span style="color:#000000;">：Controller，控制器，接收请求，进行处理，与M和V进行交互，返回应答。</span></p> 
<p style="margin-left:0cm;"><img alt="" class="has" height="577" src="https://images2.imgbox.com/17/9c/IhvBCX4M_o.png" width="925"></p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;"><span style="color:#000000;">1</span><span style="color:#000000;">、 用户点击注按钮，将要注册的信息发送给网站服务器。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">2</span><span style="color:#000000;">、 Controller控制器接收到用户的注册信息，Controller会告诉Model层将用户的注册信息保存到数据库</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">3</span><span style="color:#000000;">、 Model层将用户的注册信息保存到数据库</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">4</span><span style="color:#000000;">、 数据保存之后将保存的结果返回给Model模型，</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">5</span><span style="color:#000000;">、 Model层将保存的结果返回给Controller控制器。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">6</span><span style="color:#000000;">、 Controller控制器收到保存的结果之后，或告诉View视图，view视图产生一个html页面。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">7</span><span style="color:#000000;">、 View将产生的Html页面的内容给了Controller控制器。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">8</span><span style="color:#000000;">、 Controller将Html页面的内容返回给浏览器。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">9</span><span style="color:#000000;">、 浏览器接受到服务器Controller返回的Html页面进行解析展示。</span></p> 
<p style="margin-left:0cm;"> </p> 
<h3 style="margin-left:0cm;"><strong><a name="_Toc1006"></a><a name="_Toc505266682"></a><a name="_Toc28243"><span style="color:#000000;">2.Django</span></a><span style="color:#000000;">创建项目后，项目文件夹下的组成部分（对mvt的理解）</span><span style="color:#000000;">？</span></strong></h3> 
<h4 style="margin-left:0cm;"><strong><span style="color:#000000;">项目文件夹下的组成部分：</span></strong></h4> 
<p style="margin-left:0cm;"><span style="color:#000000;">manage.py</span><span style="color:#000000;">是项目运行的入口，指定配置文件路径。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">与项目同名的目录，包含项目的配置文件</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">___init.py</span><span style="color:#000000;">是一个空文件，作用是这个目录可以被当作包使用。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">settings.py</span><span style="color:#000000;">是项目的整体配置文件。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">urls.py</span><span style="color:#000000;">是项目的URL配置文件。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">wsgi.py</span><span style="color:#000000;">是项目与WSGI兼容的Web服务器入口</span></p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;"><strong><span style="color:#000000;">3.MVT</span></strong><strong><span style="color:#000000;">解读</span></strong></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">M</span><span style="color:#000000;">：Model，模型，和MVC中的M功能相同，和数据库进行交互。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">V</span><span style="color:#000000;">：view，视图，和MVC中的C功能相同，接收请求，进行处理，与M和T进行交互，返回应答。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">T</span><span style="color:#000000;">：Template，模板，和MVC中的V功能相同，产生Html页面</span></p> 
<p style="margin-left:0cm;"><img alt="" class="has" height="621" src="https://images2.imgbox.com/6b/24/nCSk8W4j_o.png" width="926"></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">1</span><span style="color:#000000;">、 用户点击注册按钮，将要注册的内容发送给网站的服务器。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">2</span><span style="color:#000000;">、 View视图，接收到用户发来的注册数据，View告诉Model将用户的注册信息保存进数据库。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">3</span><span style="color:#000000;">、 Model层将用户的注册信息保存到数据库中。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">4</span><span style="color:#000000;">、 数据库将保存的结果返回给Model</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">5</span><span style="color:#000000;">、 Model将保存的结果给View视图。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">6</span><span style="color:#000000;">、 View视图告诉Template模板去产生一个Html页面。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">7</span><span style="color:#000000;">、 Template生成html内容返回给View视图。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">8</span><span style="color:#000000;">、 View将html页面内容返回给浏览器。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">9</span><span style="color:#000000;">、 浏览器拿到view返回的html页面内容进行解析，展示。</span></p> 
<p style="margin-left:0cm;"><strong><span style="color:#000000;">（新增）说一下Django，MIDDLEWARES中间件的作用？</span></strong></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">中间件是介于request与response处理之间的一道处理过程，相对比较轻量级，并且在全局上改变django的输入与输出。</span></p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;"><strong><span style="color:#000000;">（新增）django中那里用到了线程，那里用到了协程，那里用到了进程？</span></strong></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">```</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">1.django</span><span style="color:#000000;">利用多线程增加异步任务.celery消息队列.</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">2.django</span><span style="color:#000000;">中使用多线程发送邮件.send_mail().</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">3.django</span><span style="color:#000000;">原生为单线程序,当第一个请求没有完成时,第二个请求阻塞,直到第一个请求完成,第二个请 求才会执行.</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">使用uwsgi编程多并发,使用nginx+uwsgi提供高并发,nginx的并发能力超高,单台并发能力过万 (不绝对).</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">4.django</span><span style="color:#000000;">自带的development server为多线程模式,但是他还有一个小问题就是它不是线程安全的。 可能在请求很多时会出现数据不同步，当然，这一般不是问题，因为我们通常只在自己机器上调试时才用Development Server。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">```</span></p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;"><strong><span style="color:#000000;">4.django</span></strong><strong><span style="color:#000000;">关闭浏览器，怎么清除cookies和session？</span></strong></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">cookie</span><span style="color:#000000;">是有过期时间的，如果不指定，默认关闭浏览器之后cookie就会过期。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">如果 SESSION_EXPIRE_AT_BROWSER_CLOSE 设置为 False ，cookie可以在用户浏览器中保持有效达 SESSION_COOKIE_AGE 秒(存活时间)。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">如果不想用户每次打开浏览器都必须重新登陆的话，可以用这个参数。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">如果 SESSION_EXPIRE_AT_BROWSER_CLOSE 设置为 True ，当浏览器关闭时，Django会使cookie失效</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">Django</span><span style="color:#000000;">中操作session：</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">session</span><span style="color:#000000;">也是有过期时间，如果不指定，默认两周就会过期。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">request.session.set_expiry(0);</span><span style="color:#000000;">那么当浏览器关闭时，session失效</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">删除session：del request[key]</span></p> 
<p style="margin-left:0cm;"><strong><span style="color:#000000;">5.Django</span></strong><strong><span style="color:#000000;">里QuerySet的get和filter方法的区别</span></strong></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">1</span><span style="color:#000000;">、输入参数</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">- get </span><span style="color:#000000;">的参数只能是model中定义的那些字段，只支持严格匹配</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">- filter </span><span style="color:#000000;">的参数可以是字段，也可以是扩展的where查询关键字，如in，like等</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">2</span><span style="color:#000000;">、返回值</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">- get </span><span style="color:#000000;">返回值是一个定义的model对象</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">- filter </span><span style="color:#000000;">返回值是一个新的QuerySet对象，然后可以对QuerySet在进行查询返回新的QuerySet对象，支持链式操作QuerySet一个集合对象，可使用迭代或者遍历，切片等，但是不等于list类型(使用一定要注意)</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">3</span><span style="color:#000000;">、异常</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">- get </span><span style="color:#000000;">只有一条记录返回的时候才正常,也就说明get的查询字段必须是主键或者唯一约束的字段。当返回多条记录或者是没有找到记录的时候都会抛出异常</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">- filter </span><span style="color:#000000;">有没有匹配的记录都可以。</span></p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;"><strong><span style="color:#000000;">6.</span></strong><strong><span style="color:#000000;">简述Django对http请求的执行流程</span></strong></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">&gt; </span><span style="color:#000000;">在接受一个Http请求之前的准备</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">&gt; </span><span style="color:#000000;">启动一个支持WSGI网关协议的服务器监听端口等待外界的Http请求，比如Django自带的开发者服务器或者uWSGI服务器。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">&gt; </span><span style="color:#000000;">服务器根据WSGI协议指定相应的Handler来处理Http请求，并且初始化该Handler，在Django框架中由框架自身负责实现这一个Handler。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">&gt; </span><span style="color:#000000;">此时服务器已处于监听状态，可以接受外界的Http请求</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">&gt; </span><span style="color:#000000;">当一个http请求到达服务器的时候</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">&gt; </span><span style="color:#000000;">服务器根据WSGI协议从Http请求中提取出必要的参数组成一个字典（environ）并传入Handler中进行处理。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">&gt; </span><span style="color:#000000;">在Handler中对已经符合WSGI协议标准规定的http请求进行分析，比如加载Django提供的中间件，路由分配，调用路由匹配的视图等。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">&gt; </span><span style="color:#000000;">返回一个可以被浏览器解析的符合Http协议的HttpResponse。</span></p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;"><strong><span style="color:#000000;">7.</span></strong><strong><span style="color:#000000;">简述Django下的（内建）缓存机制</span></strong></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">&gt; Django</span><span style="color:#000000;">根据设置的缓存方式，浏览器第一次请求时，cache会缓存单个变量或整个网页等内容到硬盘或者内存中，同时设置response头部，当浏览器再次发起请求时，附带f-Modified-Since请求时间到Django，Django 发现f-Modified-Since会先去参数之后，会与缓存中的过期时间相比较，如果缓存时间比较新，则会重新请求数据，并缓存起来然后返回response给客户端，如果缓存没有过期，则直接从缓存中提取数据，返回给response给客户端。</span></p> 
<p style="margin-left:0cm;"><strong><span style="color:#000000;">8.Django</span></strong><strong><span style="color:#000000;">中model的SlugField类型字段有什么用途？</span></strong></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">&gt; SlugField</span><span style="color:#000000;">字段是将输入的内容中的空格都替换成‘-’之后保存，Slug 是一个新闻术语，通常是某些东西的短标签。一个slug只能包含字母、数字、下划线或者是连字符，通常用来作为短标签。通常它们是用来放在URL里的。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">&gt; SlugField</span><span style="color:#000000;">字段的Field.db_index自动设置为True。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">&gt; </span><span style="color:#000000;">通常根据另一个值自动生成slug来填充到SlugField的值</span></p> 
<h3 style="margin-left:0cm;"><strong><a name="_Toc31142"></a><a name="_Toc505266688"><span style="color:#000000;">9.</span></a><span style="color:#000000;">第三方支付是如何实现的？</span></strong></h3> 
<p style="margin-left:0cm;"><span style="color:#000000;">聚合支付：ping++，付钱拉，Paymax...</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">直接对接：支付宝，微信，qq钱包，银联，百度钱包...</span></p> 
<p style="margin-left:0cm;"><strong><span style="color:#000000;">建议：</span></strong><span style="color:#000000;">去该类官网了解接口相关知识</span></p> 
<p style="margin-left:0cm;"><a name="_Toc28688"><strong><span style="color:#000000;">1</span></strong></a><strong><span style="color:#000000;">、简单加密</span></strong></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">目的是为了保证上传的参数信息没有被篡改，主要分成三部分</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">接口参数 : 需要和第三方对接的参数</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">加密类型 : 使用什么类型加密，一般为MD5</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">加密密文 : 使用接口参数和第三方生成的Code值(固定salt),进行MD5加密成密文</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">Md5</span><span style="color:#000000;">作为数字签名 H(A)=P 已知A P，在特殊情况下可以伪造A1 满足H(A1)=p</span></p> 
<p style="margin-left:0cm;"><a name="_Toc21849"><strong><span style="color:#000000;">2</span></strong></a><strong><span style="color:#000000;">、生成加密的密钥Key</span></strong></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">随机生成16位的加密密钥Key，用于对上一步的内容进行对称加密</span></p> 
<p style="margin-left:0cm;"><a name="_Toc5925"><strong><span style="color:#000000;">3</span></strong></a><strong><span style="color:#000000;">、使用证书加密密钥Key</span></strong></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">对随机生成的密钥key进行加密。防止在传输过程中被截获破解。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">使用了三种加密算法：</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">摘要算法：验证原文是否被篡改</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">对称加密算法：使用密钥对原文进行加密(AES)</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">非对称加密算法：对密钥进行分发</span></p> 
<p style="margin-left:0cm;"><strong><span style="color:#000000;">发送方：</span></strong></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">入参 + H(入参+分配的code)= P 得到键值对 ParamMap</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">AES ( ParamMap + </span><span style="color:#000000;">随机生成的Key ) 进行对称加密得到 DecodeString</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">随机生成的Key + 私钥证书加密， 得到 EnCodeKey</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">Http</span><span style="color:#000000;">发送请求, 将 DecodeString 和 EnCodeKey发送给第三方支付公司</span></p> 
<p style="margin-left:0cm;"><strong><span style="color:#000000;">接收方：</span></strong></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">证书加密的随机数，使用私钥解密得到 Akey</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">AES(AKey) = sourceCode("</span><span style="color:#000000;">入参","P")</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">验证：H(sourceCode + code) = P</span></p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;"><strong><span style="color:#000000;">（新增）Form表单的提交和ajax的提交</span></strong></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">1</span><span style="color:#000000;">、提交方式</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">form</span><span style="color:#000000;">表单通常是通过在HTML中定义的action，method及submit来进行表单提交，另外也可以通过在js中调用submit函数来进行表单提交。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">具体的提交方式有很多种，比如可以通过封装成XMLHttpRequest对象进行提交。Ajax是基于XMLHttpRequest进行的。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">2</span><span style="color:#000000;">、页面刷新</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">Form</span><span style="color:#000000;">提交，更新数据完成后，需要转到一个空白页面再对原页面进行提交后处理。哪怕是提交给自己本身的页面，也是需要刷新的，因此局限性很大。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">Ajax</span><span style="color:#000000;">可以实现页面的局部刷新，整个页面不会刷新。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">3</span><span style="color:#000000;">、请求由谁来提交</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">Form</span><span style="color:#000000;">提交是浏览器完成的，无论浏览器是否开启JS，都可以提交表单。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">Ajax</span><span style="color:#000000;">是通过js来提交请求，请求与响应均由js引擎来处理，因此不启用JS的浏览器，无法完成该操作。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">4</span><span style="color:#000000;">、是否可以上传文件</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">最初，ajax出于安全性考虑，不能对文件进行操作，所以就不能通过ajax来实现文件上传，但是通过隐藏form提交则可以实现这个功能，所以这也是用隐藏form提交的主要用途。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">后来XMLHttpRequest引入了FormData类型，使得通过Ajax也可以实现文件上传。</span></p> 
<p style="margin-left:0cm;"><strong><span style="color:#000000;">（新增）类似qq在线人数，用ajax怎么实现？</span></strong></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">可以使用ajax的异步处理,(单使一个一个进程或线程)每隔一段时间请求数据库人数数据。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">Ajax</span><span style="color:#000000;">主要功能是实现异步,事件触发,Ajax 会创建一个xmlhttprequest,对象,把http方法和目标url,以及回调函数函数设置到xmlhttprequest对象,通过xmlhttprequest对象向浏览器发送请求,请求发送后继续响应用户,并交互,只有等到请求真正从服务器返回的时候才调用callback()函数,对响应数据进行处理.</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">关键的技术: xhtml css ,用来格式化输出页面,dom (动态修改文档的内容和结构,)，xml进行数据交换和处理, javascript 进行上述技术的捆绑,使其协同工作.</span></p> 
<p style="margin-left:0cm;"><strong><span style="color:#000000;">**</span></strong><strong><span style="color:#000000;">总结：**</span></strong></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">```</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">Ajax </span><span style="color:#000000;">利用javascript创建xmlhttpscript对象,再由javascript调用xmljtmlscript对象完成随异步通讯最后通过javascript 调用dom的属性和方法进行页面不完全刷新</span></p> 
<p style="margin-left:0cm;"><strong><span style="color:#000000;">（新增）项目中使用什么调试？</span></strong></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">- 1</span><span style="color:#000000;">、在Eclipse+Pydev中调试Django</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">适用于测试环境。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">可进行单步调试，查看变量值，当出现except时，可以用Python标准模块traceback的print_exc()函数查看函数调用链，</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">是最强大的调试利器。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">- 2</span><span style="color:#000000;">、使用Django的error page</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">适用于测试环境。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">Django</span><span style="color:#000000;">的error page功能很强大，能提供详细的traceback，包括局部变量的值，以及一个纯文本的异常信息。拥有同phpinfo()</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">一样的作用，可以展示当前应用的相关设置，包括请求中的 GET, POST and COOKIE 数据以及HTTP环境中的所有重要META fields。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">- 3</span><span style="color:#000000;">、django-debug-toolbar</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">不确定是否用于生产环境。听说功能非常强大。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">- 4</span><span style="color:#000000;">、输出log到开发服务器终端中</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">适用于生产环境。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">借助python的logging模块</span></p> 
<p style="margin-left:0cm;"><strong><span style="color:#000000;">10.</span></strong><strong><span style="color:#000000;">项目怎么优化？提过哪些建议？</span></strong></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">对于开发人员来说，网站性能优化一般包括Web前端性能优化、应用服务器性能优化、存储服务器性能优化三类。</span></p> 
<p style="margin-left:0cm;"><strong><span style="color:#000000;">**Web</span></strong><strong><span style="color:#000000;">前端性能优化：**</span></strong></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">- 1</span><span style="color:#000000;">、减少http请求 http协议是无状态的应用层协议，意味着每次http请求都需要建立通信链路、进行数据传输，而在服务器端，每个http请求都需要启动独立的线程去处理。减少http请求的数目可有效提高访问性能。<strong>**减少http的主要手段是合并CSS、合并javascript、合并图片。**</strong></span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">- 2</span><span style="color:#000000;">、使用浏览器缓存 对一个网站而言，CSS、javascript、logo、图标，这些静态资源文件更新的频率都比较低，而这些文件又几乎是每次http请求都需要的。如果将这些文件缓存在浏览器中，可以极好的改善性能。通过设置http头中的cache-control和expires的属性，可设定浏览器缓存，缓存时间可以自定义。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">- 3</span><span style="color:#000000;">、启用压缩 在服务器端对文件进行压缩，在浏览器端对文件解压缩，可有效减少通信传输的数据量。如果可以的话，尽可能的将外部的脚本、样式进行合并，多个合为一个。文本文件的压缩效率可达到80%以上，因此HTML、CSS、javascript文件启用GZip压缩可达到较好的效果。但是压缩对服务器和浏览器产生一定的压力，在网络带宽良好，而服务器资源不足的情况下要综合考虑。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">- 4</span><span style="color:#000000;">、CSS放在页面最上部，javascript放在页面最下面 浏览器会在下载完成全部CSS之后才对整个页面进行渲染，因此最好的做法是将CSS放在页面最上面，让浏览器尽快下载CSS。 Javascript则相反，浏览器在加载javascript后立即执行，有可能会阻塞整个页面，造成页面显示缓慢，因此javascript最好放在页面最下面。</span></p> 
<p style="margin-left:0cm;"><strong><span style="color:#000000;">**</span></strong><strong><span style="color:#000000;">应用服务器优化**</span></strong></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">应用服务器也就是处理网站业务的服务器，网站的业务代码都部署在这里，主要优化方案有缓存、异步、集群等。</span></p> 
<p style="margin-left:0cm;"><strong><span style="color:#000000;">**1</span></strong><strong><span style="color:#000000;">、合理使用缓存**</span></strong></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">当网站遇到性能瓶颈时，第一个解决方案一般是缓存。在整个网站应用中，缓存几乎无处不在，无论是客户端，还是应用服务器，或是数据库服务器。在客户端和服务器的交互中，无论是数据、文件都可以缓存，合理使用缓存对网站性能优化非常重要。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">缓存一般用来存放那些读写次数比较高，变化较少的数据，比如网站首页的信息、商品的信息等。应用程序读取数据时，一般是先从缓存中读取，如果读取不到或数据已失效，再访问磁盘数据库，并将数据再次写入缓存。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">缓存的基本原理是将数据存储在相对有较高访问速度的存储介质中，比如内存。一方面缓存访问速度快，另一方面，如果缓存的数据是需要经过计算处理得到的，那使用缓存还可以减少服务器处理数据的计算时间。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">使用缓存并不是没有缺陷：内存资源是比较宝贵的，不可能将所有数据都缓存，一般频繁修改的数据不建议使用缓存，这会导致数据不一致。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">网站数据缓存一般遵循二八定律，即80%的访问都在20%的数据上。所以，一般将这20%的数据缓存，可以起到改善系统性能，提高服务器读取效率。</span></p> 
<p style="margin-left:0cm;"><strong><span style="color:#000000;">**2</span></strong><strong><span style="color:#000000;">、异步操作**</span></strong></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">使用消息队列将调用异步化，可以改善网站系统的性能。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">在不使用消息队列的情况下，用户的请求直接写入数据库，在高并发的情况下，会对数据库造成非常大的压力，也会延迟响应时间。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">在使用消息队列后，用户请求的数据会发送给消息队列服务器，消息队列服务器会开启进程，将数据异步写入数据库。消息队列服务器的处理速度远超过数据库，因此用户的响应延迟可得到改善。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">消息队列可以将短时间内的高并发产生的事务消息，存储在消息队列中，从而提高网站的并发处理能力。在电商网站的促销活动中，合理使用消息队列，可以抵御短时间内用户高并发的冲击。</span></p> 
<p style="margin-left:0cm;"><strong><span style="color:#000000;">**3</span></strong><strong><span style="color:#000000;">、使用集群**</span></strong></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">在网站高并发访问的情况下，使用负载均衡技术，可以为一个应用构建由多台服务器组成的服务器集群，将并发访问请求，分发到多台服务器上处理，避免单一服务器因负载过大，而导致响应延迟。</span></p> 
<p style="margin-left:0cm;"><strong><span style="color:#000000;">**4</span></strong><strong><span style="color:#000000;">、代码优化**</span></strong></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">网站的业务逻辑代码主要部署在应用服务器上，需要处理复杂的并发事务。合理优化业务代码，也可以改善网站性能。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">任何web网站都会遇到多用户的并发访问，大型网站的并发用户会达到数万。每个用户请求都会创建一个独立的系统进程去处理。由于线程比进程更轻量，占用资源更少，所以，目前主流的web应用服务器都采用多线程的方式，处理并发用户的请求，因此，网站开发多数都是多线程编程。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">使用多线程的另一个原因是服务器有多个CPU，现在手机都到了8核CPU的时代，一般的服务器至少是16核CPU，要想最大限度的使用这些CPU，必须启动多线程。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">那么，启动多少线程合适呢？</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">启动线程数和CPU内核数量成正比，和IO等待时间成正比。如果都是计算型的任务，那么线程数最多不要超过CPU内核数，因为启动再多，CPU也来不及调用。如果任务是等待读写磁盘、网络响应，那么多启动线程会提高任务并发度，提高服务器性能。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">或者用个简化的公式来描述：</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">启动线程数 = (任务执行时间/(任务执行事件 - IO等待时间)) * CPU内核数</span></p> 
<p style="margin-left:0cm;"><strong><span style="color:#000000;">**5</span></strong><strong><span style="color:#000000;">、存储优化**</span></strong></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">数据的读写是网站处理并发访问的另一瓶颈。使用缓存虽然可以解决一部分数据读写压力，但很多时候，磁盘仍然是系统最严重的瓶颈。而且磁盘是网站最重要的资产，磁盘的可用性和容错性也至关重要。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">机械硬盘和固态硬盘 机械硬盘是目前最常用的硬盘，通过马达带动磁头到指定磁盘的位置访问数据，每次访问数据都需要移动磁头，在读取连续数据和随机访问上，磁头移动的次数相差巨大，因此机械硬盘的性能表现差别巨大，读写效率较低。而在网站应用中，大多数数据的访问都是随机的，在这种情况下，固态硬盘具有更高的性能。但目前固态硬盘在工艺上、数据可靠性上还有待提升，因此固态硬盘的使用尚未普及，从发展趋势看，取代机械硬盘应该是迟早的事情。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">总结：</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">网站性能优化是在用户高并发访问，网站遇到问题时的解决方案。所以网站性能优化的主要内容是改善高并发用户访问情况下的网站响应速度。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">网站性能优化的最终目的是改善用户的体验。但性能优化本身也是需要综合考虑的。比如说，性能提高一倍，服务器数量也要增加一倍，这样的优化是否可以考虑？</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">技术是由业务驱动的，离开业务的支撑，任何性能优化都是空中楼阁。</span></p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;"><strong><span style="color:#000000;">11.Flask</span></strong><strong><span style="color:#000000;">和Django路由映射的区别？</span></strong></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">在django中，路由是浏览器访问服务器时，先访问的项目中的url，再由项目中的url找到应用中url，这些url是放在一个列表里，遵从从前往后匹配的规则。在flask中，路由是通过装饰器给每个视图函数提供的，而且根据请求方式的不同可以一个url用于不同的作用。</span></p> 
<h3 style="margin-left:0cm;"><strong><a name="_Toc505266703"></a><a name="_Toc23665"><span style="color:#000000;">12.Flask</span></a><span style="color:#000000;">中正则URL的实现？</span></strong></h3> 
<p style="margin-left:0cm;"><span style="color:#000000;">@app.route('&lt;URL&gt;')</span><span style="color:#000000;">中URL显式支持string、int、float、path 4种类型，隐式支持正则</span></p> 
<p style="margin-left:0cm;"><a name="_Toc22311"><span style="color:#000000;">第一步：写正则类，继承BaseConverter，将匹配到的值设置为regex的值</span></a></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">class RegexUrl(BaseConverter):</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">    def __init__(self, url_map, *args):</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">        super(RegexUrl, self).__init__(url_map)</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">        self.regex = args[0]</span></p> 
<p style="margin-left:0cm;"><a name="_Toc29783"><span style="color:#000000;">第二步：把正则类赋值给我们定义的正则规则</span></a></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">app.url_map.converters['re'] = RegexUrl</span></p> 
<p style="margin-left:0cm;"><a name="_Toc9774"><span style="color:#000000;">第三步：在URL中使用正则</span></a></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">@app.route('/regex/&lt;re("[a-z]{3}"):id&gt;')</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">def regex111(id):</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">return 'id:%s'%id</span></p> 
<p style="margin-left:0cm;"> </p> 
<h3 style="margin-left:0cm;"><strong><a name="_Toc505266704"></a><a name="_Toc22334"><span style="color:#000000;">13.Flask</span></a><span style="color:#000000;">中请求上下文和应用上下文的区别和作用？</span></strong></h3> 
<p style="margin-left:0cm;"><span style="color:#000000;">current_app</span><span style="color:#000000;">、g就是应用上下文<br> requests、session就是请求上下文</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">手动创建上下文的两种方法：</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">with app.app_context()</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">app = current_app._get_current_object()</span></p> 
<p style="margin-left:0cm;"> </p> 
<h3 style="margin-left:0cm;"><strong><a name="_Toc505266705"></a><a name="_Toc32348"><span style="color:#000000;">14.</span></a><span style="color:#000000;">一个变量后写多个过滤器是如何执行？</span></strong></h3> 
<p style="margin-left:0cm;"><span style="color:#000000;">{<!-- -->{ expression | filter1 | filter2 | ... }}  </span><span style="color:#000000;">即 表达式(expression)使用filter1过滤后再使用filter2过滤..</span></p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;"> </p> 
<h3 style="margin-left:0cm;"><strong><a name="_Toc415"></a><a name="_Toc505266706"><span style="color:#000000;">15.Flask</span></a><span style="color:#000000;">中数据库app.config['SQLALCHEMY_COMMIT_ON_TEARDOWN']设置的作用？</span></strong></h3> 
<p style="margin-left:0cm;"><span style="color:#000000;">作用：可以配置请求执行完逻辑之后自动提交，而不用我们每次都手动调用session.commit()</span></p> 
<p style="margin-left:0cm;"><strong><span style="color:#000000;">补充：</span></strong></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">监听数据库中的数据，当发生改变，就会显示一些内容</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">app.config['SQLALCHEMY_TRACK_MODIFICATIONS']=True</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">显示打印的数据以及sql语句，建议不设置，默认为False</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">app.config['SQLALCHEMY_ECHO'] = True</span></p> 
<h3 style="margin-left:0cm;"><strong><a name="_Toc505266707"></a><a name="_Toc4206"><span style="color:#000000;">16.</span></a><span style="color:#000000;">模糊查询和精确查询的区别？</span></strong></h3> 
<p style="margin-left:0cm;"><span style="color:#000000;">filter()</span><span style="color:#000000;">模糊查询:把过滤器添加到原查询上，返回一个新查询</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">filter_by()</span><span style="color:#000000;">精确查询:把等值过滤器添加到原查询上，返回一个新查询</span></p> 
<h3 style="margin-left:0cm;"><strong><a name="_Toc21230"></a><a name="_Toc505266708"><span style="color:#000000;">17.</span></a><span style="color:#000000;">对flask蓝图(Blueprint)的理解？</span></strong></h3> 
<p style="margin-left:0cm;"><a name="_Toc22624"><strong><span style="color:#000000;">1.</span></strong></a><strong><span style="color:#000000;">蓝图定义：</span></strong></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">蓝图 /Blueprint 是Flask应用程序 组件化 的方法，可以在一个应用内或跨越 多个项目共用蓝图。使用蓝图可以极大地简化大型应用的开发难度，也为Flask扩展 提供了一种在应用中注册服务的集中式机制。</span></p> 
<p style="margin-left:0cm;"><a name="_Toc32468"><strong><span style="color:#000000;">2.</span></strong></a><strong><span style="color:#000000;">蓝图的应用场景</span></strong></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">1</span><span style="color:#000000;">，把一个应用分解为一个蓝图的集合。这对大型应用是理想的。一个项目可以实例化一个应用对象，初始化几个扩展，并注册一集合的蓝图。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">2</span><span style="color:#000000;">，以 URL 前缀和/或子域名，在应用上注册一个蓝图。 URL 前缀/子域名中的参数即成为这个蓝图下的所有视图函数的共同的视图参数（默认情况下）。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">3</span><span style="color:#000000;">，在一个应用中用不同的 URL 规则多次注册一个蓝图。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">4</span><span style="color:#000000;">，通过蓝图提供模板过滤器、静态文件、模板和其它功能。一个蓝图不一定要实现应用或者视图函数。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">5</span><span style="color:#000000;">，初始化一个 Flask 扩展时，在这些情况中注册一个蓝图。</span></p> 
<p style="margin-left:0cm;"><a name="_Toc22475"><strong><span style="color:#000000;">3.</span></strong></a><strong><span style="color:#000000;">蓝图的缺点</span></strong></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">不能在应用创建后撤销注册一个蓝图而不销毁整个应用对象。</span></p> 
<p style="margin-left:0cm;"><a name="_Toc7586"><strong><span style="color:#000000;">4.</span></strong></a><strong><span style="color:#000000;">使用蓝图的三个步骤</span></strong></p> 
<p style="margin-left:0cm;"><a name="_Toc30939"><span style="color:#000000;">1.</span></a><span style="color:#000000;">创建 一个蓝图对象</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">blue = Blueprint("blue",__name__)</span></p> 
<p style="margin-left:0cm;"><a name="_Toc17442"><span style="color:#000000;">2.</span></a><span style="color:#000000;">在这个蓝图对象上进行 操作 ，例如注册路由、指定静态文件夹、注册模板过滤器...</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">@blue.route('/')</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">def blue_index():</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">    return 'Welcome to my blueprint'</span></p> 
<p style="margin-left:0cm;"><a name="_Toc25062"><span style="color:#000000;">3.</span></a><span style="color:#000000;">在应用对象上 注册 这个蓝图对象</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">app.register_blueprint(blue,url_prefix='/blue')</span></p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;"> </p> 
<h3 style="margin-left:0cm;"><strong><a name="_Toc505266709"></a><a name="_Toc29259"><span style="color:#000000;">18.</span></a><span style="color:#000000;">跨站请求伪造和跨站请求保护的实现？</span></strong></h3> 
<p style="margin-left:0cm;"><img alt="" class="has" height="277" src="https://images2.imgbox.com/ef/a3/WrqqYzpN_o.png" width="624"></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">图中Browse是浏览器，WebServerA是受信任网站/被攻击网站A，WebServerB是恶意网站/攻击网站B。<br> （1）一开始用户打开浏览器，访问受信任网站A，输入用户名和密码登陆请求登陆网站A。<br> （2）网站A验证用户信息，用户信息通过验证后，网站A产生Cookie信息并返回给浏览器。<br> （3）用户登陆网站A成功后，可以正常请求网站A。<br> （4）用户未退出网站A之前，在同一浏览器中，打开一个TAB访问网站B。<br> （5）网站B看到有人方式后，他会返回一些攻击性代码。<br> （6）浏览器在接受到这些攻击性代码后，促使用户不知情的情况下浏览器携带Cookie（包括sessionId）信息，请求网站A。这种请求有可能更新密码，添加用户什么的操作。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">从上面CSRF攻击原理可以看出，要完成一次CSRF攻击，需要被攻击者完成两个步骤：<br>    1.登陆受信任网站A，并在本地生成COOKIE。<br>    2.在不登出A的情况下，访问危险网站 B。<br> 如果不满足以上两个条件中的一个，就不会受到CSRF的攻击，以下情况可能会导致CSRF：<br>     1.登录了一个网站后，打开一个tab页面并访问另外的网站。<br>     2.关闭浏览器了后，本地的Cookie尚未过期，你上次的会话还没有已经结束。（事实上，关闭浏览器不能结束一个会话，但大多数人都会错误的认为关闭浏览器就等于退出登录/结束会话了……）</span></p> 
<p style="margin-left:0cm;"><strong><span style="color:#000000;">解决办法：</span></strong><span style="color:#000000;">就是在表单中添加from.csrf_token</span></p> 
<h3 style="margin-left:0cm;"><strong><a name="_Toc505266710"></a><a name="_Toc30346"><span style="color:#000000;">19.Flask</span></a><span style="color:#000000;">项目中如何实现session信息的写入？</span></strong></h3> 
<p style="margin-left:0cm;"><strong><span style="color:#000000;">flask</span></strong><strong><span style="color:#000000;">中有三个session：</span></strong></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">第一个：数据库中的session，例如:db.session.add()</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">第二个：在flask_session扩展中的session，使用：from flask_session import Session，使用第三方扩展的session可以把信息存储在服务器中，客户端浏览器中只存储sessionid</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">第三个：flask自带的session，是一个请求上下文， 使用：from flask import session。自带的session把信息加密后都存储在客户端的浏览器cookie中</span></p> 
<h3 style="margin-left:0cm;"><strong><a name="_Toc3591"></a><a name="_Toc505266712"><span style="color:#000000;">20.Flask(__name__)</span></a><span style="color:#000000;">中的__name__可以传入哪些值？</span></strong></h3> 
<p style="margin-left:0cm;"><strong><span style="color:#000000;">可以传入的参数：</span></strong></p> 
<p style="margin-left:0cm;"><a name="_Toc1666"><span style="color:#000000;">1</span></a><span style="color:#000000;">，字符串：‘hello’,</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">但是‘abc’,不行，因为abc是python内置的模块</span></p> 
<p style="margin-left:0cm;"><a name="_Toc26849"><span style="color:#000000;">2</span></a><span style="color:#000000;">，__name__，约定俗成</span></p> 
<p style="margin-left:0cm;"><strong><span style="color:#000000;">不可以插入的参数</span></strong></p> 
<p style="margin-left:0cm;"><a name="_Toc13148"><span style="color:#000000;">1</span></a><span style="color:#000000;">，python内置的模块，re,urllib,abc等</span></p> 
<p style="margin-left:0cm;"><a name="_Toc6293"><span style="color:#000000;">2</span></a><span style="color:#000000;">，数字</span></p> 
<h3 style="margin-left:0cm;"><strong><a name="_Toc505266713"></a><a name="_Toc5534"><span style="color:#000000;">21.Flask</span></a><span style="color:#000000;">中请求钩子的理解和应用</span></strong></h3> 
<p style="margin-left:0cm;"><span style="color:#000000;">请求钩子是通过装饰器的形式实现的，支持以下四种：</span></p> 
<p style="margin-left:0cm;"><a name="_Toc3743"><span style="color:#000000;">1</span></a><span style="color:#000000;">，before_first_request在处理第一个请求前运行</span></p> 
<p style="margin-left:0cm;"><a name="_Toc8273"><span style="color:#000000;">2</span></a><span style="color:#000000;">，before_request:在每次请求前运行</span></p> 
<p style="margin-left:0cm;"><a name="_Toc8436"><span style="color:#000000;">3</span></a><span style="color:#000000;">，after_request:如果没有未处理的异常抛出，在每次请求后运行</span></p> 
<p style="margin-left:0cm;"><a name="_Toc2643"><span style="color:#000000;">4</span></a><span style="color:#000000;">，teardown_request:即使有未处理的异常抛出，在每次请求后运行</span></p> 
<p style="margin-left:0cm;"><strong><span style="color:#000000;">应用：</span></strong></p> 
<p style="margin-left:0cm;"><span style="color:#000000;"># </span><span style="color:#000000;">请求钩子</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">@api.after_request</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">def after_request(response):</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">    """</span><span style="color:#000000;">设置默认的响应报文格式为application/json"""</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">    # </span><span style="color:#000000;">如果响应报文response的Content-Type是以text开头，则将其改为默认的json类型</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">    if response.headers.get("Content-Type").startswith("text"):</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">        response.headers["Content-Type"] = "application/json"</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">return response</span></p> 
<h3 style="margin-left:0cm;"><strong><a name="_Toc30351"></a><a name="_Toc505266714"><span style="color:#000000;">22.</span></a><span style="color:#000000;">自定义过滤器的步骤？</span></strong></h3> 
<p style="margin-left:0cm;"><a name="_Toc10000"><strong><span style="color:#000000;">第一步：</span></strong></a><span style="color:#000000;">先定义自定义过滤器函数</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">def count_substring(string, substring):</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">    return string.count(substring)</span></p> 
<p style="margin-left:0cm;"><a name="_Toc13881"><strong><span style="color:#000000;">第二步：</span></strong></a><span style="color:#000000;">注册自己定义的过滤器</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">app.jinja_env.filters['count_substring'] = count_substring</span></p> 
<p style="margin-left:0cm;"><a name="_Toc18642"><strong><span style="color:#000000;">第三步：</span></strong></a><span style="color:#000000;">最后在模板文件html中直接使用注册时的键名</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">{#</span><span style="color:#000000;">前面的作为原字符串string,传入的作为子字符串substring#}</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">{<!-- -->{ 'A long long long long long  long longabc string ' | count_substring('long') }}&lt;br/&gt;</span></p> 
<p style="margin-left:0cm;"> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/eaea9c0031fd403741296a24ac824240/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">flutter 依赖库版本不一致问题</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1a2281dd165efb0d676164aeb886257e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">机器视觉中非常好的github仓库</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>