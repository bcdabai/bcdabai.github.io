<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>距离向量路由算法实现java_距离向量路由协议及优化链路状态路由协议 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="距离向量路由算法实现java_距离向量路由协议及优化链路状态路由协议" />
<meta property="og:description" content="1、距离向量路由算
距离向量路由算法要求每个路由器维护一张距离表和路由表，并在表中给出到每个已知目的地的最短距离和路径。在距离表中，列表示和这个节点直接相连的邻居，表中的行表示目的节点，而表中的元素表示“距离”，“距离”可以是跳跃次数、时延或丢失的数据包的数量等。距离向量路由算法通过路由表之间周期性的交换数据来更新网络拓扑结构。
距离向量路由选择算法的缺陷：收敛时间较长是此路由选择算法所遇到的一个重要问题，网络收敛缓慢产生了相矛盾的路由选择条目，这种条件下数据包会一直在网络上循环发送，因此就产生了路由环路。
可用的解决方法有：
1、定义最大值
2、简单水平分割
3、带毒性的逆转水平分割
4、触发更新
5、抑制计时
实际中较常使用的是定义最大值、触发更新、抑制计时。
2、链路状态路由算法(Link State Routing)[2]
链路状态路由算法需要每个路由器保存一份最新的关于整个网络的拓扑结构数据库。
算法描述：
1、每个路由器与邻机会话。
2、每个路由器构建一个“链路状态包(Link-State Packets)”，包含邻机名字及费用。
3、LSP被传送到所有别的路由器，每个路由器都有其他路由器最新的LSP所有路由器都会根据搜集到的信息建立全网的拓扑数据库(L-S图)。
4、每个路由器计算出到每个目的地址的路由，建立路由表。
图表4 LSR泛洪法示意图
(同样的，路由器A在接收到路由器C的LSP后,同样会通过洪泛法转发来自路由器C的LSP)
计算路由的方法：
1、每个路由器根据其最新的链路状态包(LSP)构建链路状态数据库。
2、PATH由ID、路径代价、转发方向构成。
3、TENT由ID、路径代价、转发方向形式(可能的最佳路径)，当路径被证实是最佳的后，该节点将从TENT移到PATH中。
4、转发数据库，包括ID、转发方向。
每台路由器使用数据库构建一个完整的拓扑图并计算通向每个目的网络的最佳路径。就像拥有了地图一样，路由器现在拥有关于拓扑中所有目的地以及通向各个目的地的路由的详图。所有的路由器将会有共同的拓扑图或拓扑树，但是每一个路由器独立确定到达拓扑内每一个网络的最佳路径。
3、优化链路状态路由算法(OptimizedLink State Routing,OLSR)
在链路状态算法中，所有相邻的节点都会转发状态包。这样在相邻节点较多的情况下，泛洪开销较大；如果我们选择部分特定的节点泛洪转发数据包，使得网络中所有路由器同样可以收到数据包，可以大大减少泛洪开销，这就是OLSR算法的基本思想。
OLSR中的关键概念是多点转播(MPRs)，MPRs是在广播洪泛的过程中挑选的转发广播的节点。传统的链路状态协议每个节点都转发它收到信息的第一份拷贝，同它相比，OLSR很大程度上减少了转发的信息。在OLSR协议中，链路状态信息都是由被挑选为MPRs的节点产生的，这样减少了在网络中洪泛的控制信息，实现了第二步优化。第三步优化是MPR节点只选择在MPR或者MPR选择者之间传递链接状态信息。因此，同传统LS协议相比，在网络中分布着部分链路状态信息，这些信息将用于路由计算。
MPR的选择分为两步：
1、首先选择能够覆盖「孤立二跳邻居节点」的一跳邻居节点。这里孤立二跳邻居节点是指仅通过一个邻居节点同目标节点相连的二跳邻居节点；
2、在余下的一跳邻居节点中，按照覆盖二跳邻居节点的数量从高到低依次选择，直到覆盖所有的二跳邻居节点。
图表5 MPR选择算法
以图表5为例，首先二跳邻居节点为1、2、3、4、5、6、7，孤立二跳邻居节点为1、5，其对应的一跳节点为A、E,将A和E加入MPR列表中，此时1、2、3、5均被覆盖；在剩余的一跳节点中，将覆盖最多二跳节点的B加入MPR，然后是E，最后是G，在G加入MPR后，所有的二跳邻居节点都被MPR覆盖，此时MPR即为我们选择的MPR全集。
MPR表会通过Hello信息同步给下一跳邻居节点。这样每个节点能够建立本地的MPR Selector表，此表表明节点自己应该转发来自哪些节点的广播消息。
网络节点可能会经常性的撤销旧节点、增加新节点，网络拓扑结构也会因此改变，在OLSR算法中通过MPR节点周期性地泛洪拓扑控制(Topology Control,TC)消息来实现网络拓扑结构的维护。OLSR算法相比于LSR算法减少了泛洪开销，但也需要TC消息维护拓扑结构，增加了网络中的控制开销，并且固定的泛洪周期还会造成网络带宽的浪费。
为此，文献[3]提出了一种基于优化链路状态路由的低开销的拓扑维护算法。通过减少MPR节点的个数从而减少了TC消息产生的数量和转发次数；同时通过对比上一次发送周期的MPR选择集的变动情况，在不变量和删减量中选择较小的和新增量一起组成TC消息进行发送，最后根据网络拓扑的变化情况动态地调整TC消息的发送周期。仿真结果表明，该算法能有效降低网络的控制开销和端到端时延，提升网络的吞吐量。
参考文献 [1]王宏宇,李晗静．距离向量路由选择算法浅析[J]．智能计算机与应用,2003,000(003):16-17
[2]黄劲荣,李振坤,林穗．浅析两种分布式路由选择算法[J]．现代计算机(专业版),2004,000(011):81-83
[3]任智，周舟，吴本源，陈加林．基于优化链路状态路由的低开销拓扑维护算法[J]．计算机工程.https://doi.org/10.19678/j.issn.1000-3428.0059016" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/1eabff35d98ed8ec1e2e17f33285c652/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-12-16T02:57:42+08:00" />
<meta property="article:modified_time" content="2020-12-16T02:57:42+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">距离向量路由算法实现java_距离向量路由协议及优化链路状态路由协议</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div class="._5ce-wx-style" style="font-size:16px;"> 
 <div class="rich_media_content" id="js_content"> 
  <p>1、距离向量路由算</p> 
  <p>距离向量路由算法要求每个路由器维护一张距离表和路由表，并在表中给出到每个已知目的地的最短距离和路径。在距离表中，列表示和这个节点直接相连的邻居，表中的行表示目的节点，而表中的元素表示“距离”，“距离”可以是跳跃次数、时延或丢失的数据包的数量等。距离向量路由算法通过路由表之间周期性的交换数据来更新网络拓扑结构。</p> 
  <p><img src="https://images2.imgbox.com/d5/48/O3J1b0D5_o.png" alt="99597f920f746abf35f6b7e053f6b8cf.png"></p> 
  <p><img src="https://images2.imgbox.com/47/35/WBth3MAp_o.png" alt="60cc4b6f47b1848c9a25bb9f0688548a.png"></p> 
  <p><img src="https://images2.imgbox.com/cd/27/2pibgsUa_o.png" alt="a98ecb3daf4c60a1d3679e6a30f59d58.png"></p> 
  <p>距离向量路由选择算法的缺陷：收敛时间较长是此路由选择算法所遇到的一个重要问题，网络收敛缓慢产生了相矛盾的路由选择条目，这种条件下数据包会一直在网络上循环发送，因此就产生了路由环路。</p> 
  <p>可用的解决方法有：</p> 
  <p>1、定义最大值</p> 
  <p>2、简单水平分割</p> 
  <p>3、带毒性的逆转水平分割</p> 
  <p>4、触发更新</p> 
  <p>5、抑制计时</p> 
  <p>实际中较常使用的是定义最大值、触发更新、抑制计时。</p> 
  <p>2、链路状态路由算法(Link State Routing)[2]</p> 
  <p>链路状态路由算法需要每个路由器保存一份最新的关于整个网络的拓扑结构数据库。</p> 
  <p>算法描述：</p> 
  <p>1、每个路由器与邻机会话。</p> 
  <p>2、每个路由器构建一个“链路状态包(Link-State Packets)”，包含邻机名字及费用。</p> 
  <p>3、LSP被传送到所有别的路由器，每个路由器都有其他路由器最新的LSP所有路由器都会根据搜集到的信息建立全网的拓扑数据库(L-S图)。</p> 
  <p>4、每个路由器计算出到每个目的地址的路由，建立路由表。</p> 
  <p><img src="https://images2.imgbox.com/63/6d/c2pQiUYb_o.png" alt="08f186bb74c262cd2da79f37dbe70ef4.png"></p> 
  <p>图表4 LSR泛洪法示意图</p> 
  <p>(同样的，路由器A在接收到路由器C的LSP后,同样会通过洪泛法转发来自路由器C的LSP)</p> 
  <p>计算路由的方法：</p> 
  <p>1、每个路由器根据其最新的链路状态包(LSP)构建链路状态数据库。</p> 
  <p>2、PATH由ID、路径代价、转发方向构成。</p> 
  <p>3、TENT由ID、路径代价、转发方向形式(可能的最佳路径)，当路径被证实是最佳的后，该节点将从TENT移到PATH中。</p> 
  <p>4、转发数据库，包括ID、转发方向。</p> 
  <p>每台路由器使用数据库构建一个完整的拓扑图并计算通向每个目的网络的最佳路径。就像拥有了地图一样，路由器现在拥有关于拓扑中所有目的地以及通向各个目的地的路由的详图。所有的路由器将会有共同的拓扑图或拓扑树，但是每一个路由器独立确定到达拓扑内每一个网络的最佳路径。</p> 
  <p>3、优化链路状态路由算法(OptimizedLink State Routing,OLSR)</p> 
  <p>在链路状态算法中，所有相邻的节点都会转发状态包。这样在相邻节点较多的情况下，泛洪开销较大；如果我们选择部分特定的节点泛洪转发数据包，使得网络中所有路由器同样可以收到数据包，可以大大减少泛洪开销，这就是OLSR算法的基本思想。</p> 
  <p>OLSR中的关键概念是多点转播(MPRs)，MPRs是在广播洪泛的过程中挑选的转发广播的节点。传统的链路状态协议每个节点都转发它收到信息的第一份拷贝，同它相比，OLSR很大程度上减少了转发的信息。在OLSR协议中，链路状态信息都是由被挑选为MPRs的节点产生的，这样减少了在网络中洪泛的控制信息，实现了第二步优化。第三步优化是MPR节点只选择在MPR或者MPR选择者之间传递链接状态信息。因此，同传统LS协议相比，在网络中分布着部分链路状态信息，这些信息将用于路由计算。</p> 
  <p>MPR的选择分为两步：</p> 
  <p>1、首先选择能够覆盖「孤立二跳邻居节点」的一跳邻居节点。这里孤立二跳邻居节点是指仅通过一个邻居节点同目标节点相连的二跳邻居节点；</p> 
  <p>2、在余下的一跳邻居节点中，按照覆盖二跳邻居节点的数量从高到低依次选择，直到覆盖所有的二跳邻居节点。</p> 
  <p><img src="https://images2.imgbox.com/df/9b/VryXiAxD_o.png" alt="908210ea7a2e3cf1e2d7857cecd0f61b.png"></p> 
  <p>图表5 MPR选择算法</p> 
  <p>以图表5为例，首先二跳邻居节点为1、2、3、4、5、6、7，孤立二跳邻居节点为1、5，其对应的一跳节点为A、E,将A和E加入MPR列表中，此时1、2、3、5均被覆盖；在剩余的一跳节点中，将覆盖最多二跳节点的B加入MPR，然后是E，最后是G，在G加入MPR后，所有的二跳邻居节点都被MPR覆盖，此时MPR即为我们选择的MPR全集。</p> 
  <p>MPR表会通过Hello信息同步给下一跳邻居节点。这样每个节点能够建立本地的MPR Selector表，此表表明节点自己应该转发来自哪些节点的广播消息。</p> 
  <p>网络节点可能会经常性的撤销旧节点、增加新节点，网络拓扑结构也会因此改变，在OLSR算法中通过MPR节点周期性地泛洪拓扑控制(Topology Control,TC)消息来实现网络拓扑结构的维护。OLSR算法相比于LSR算法减少了泛洪开销，但也需要TC消息维护拓扑结构，增加了网络中的控制开销，并且固定的泛洪周期还会造成网络带宽的浪费。</p> 
  <p>为此，文献[3]提出了一种基于优化链路状态路由的低开销的拓扑维护算法。通过减少MPR节点的个数从而减少了TC消息产生的数量和转发次数；同时通过对比上一次发送周期的MPR选择集的变动情况，在不变量和删减量中选择较小的和新增量一起组成TC消息进行发送，最后根据网络拓扑的变化情况动态地调整TC消息的发送周期。仿真结果表明，该算法能有效降低网络的控制开销和端到端时延，提升网络的吞吐量。</p> 
  <h5>参考文献</h5> 
  <p>[1]王宏宇,李晗静．距离向量路由选择算法浅析[J]．智能计算机与应用,2003,000(003):16-17</p> 
  <p>[2]黄劲荣,李振坤,林穗．浅析两种分布式路由选择算法[J]．现代计算机(专业版),2004,000(011):81-83</p> 
  <p>[3]任智，周舟，吴本源，陈加林．基于优化链路状态路由的低开销拓扑维护算法[J]．计算机工程.https://doi.org/10.19678/j.issn.1000-3428.0059016</p> 
 </div> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e7a4f79358f215b75ca8f07f3af0b7e7/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">PyCharm中PyQt的使用方法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f9c7b58cf11fa13a59a3ee442c2dca4a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">无迹卡尔曼滤波_卡尔曼滤波家族</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>