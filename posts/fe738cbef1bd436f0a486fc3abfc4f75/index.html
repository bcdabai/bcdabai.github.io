<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>MFC多线程互锁 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="MFC多线程互锁" />
<meta property="og:description" content="CreateEvent跟CreateMutex的比较： 区别1， CreateEvent跟CreateMutex，你第一个问题关键在于后者内置了一个计数器，比如：假若同一线程连续申请2次互斥量，那么计数器为2，若需要释放互斥量就需要ReleaseMutex（）2次，而前者没有。 区别2， Event是一个线程通知另一个线程用的，是单向的。一方接收，其它方可以发送。一般用在单纯的同步上，就是一个操作要等待另一个操作完成时用的，双方地位并不平等。 Mutex是用于资源控制用的，对于同一个资源，一次只能有一人可以对资源进行访问。双方的地位是平等的。 Mutex比Event复杂一点，可以用Mutex实现Event的功能 区别3， MUTEX其实是你进临界区之前的 CreateMutex的使用： HANDLE CreateMutex( LPSECURITY_ATTRIBUTESlpMutexAttributes, // 指向安全属性的指针 BOOLbInitialOwner, // 初始化互斥对象的所有者 LPCTSTRlpName // 指向互斥对象名的指针 ); 5、 A handle to the mutex object indicates success. If the named mutex object existed before the function call, the function returns a handle to the existing object and GetLastError returns ERROR_ALREADY_EXISTS. Otherwise, the caller created the mutex. NULL indicates failure. To get extended error information, call GetLastError." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/fe738cbef1bd436f0a486fc3abfc4f75/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2015-11-01T20:49:27+08:00" />
<meta property="article:modified_time" content="2015-11-01T20:49:27+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">MFC多线程互锁</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <span style="font-size:24px; background-color:rgb(255,0,0)">CreateEvent跟CreateMutex的比较：</span> 
<br> 区别1， 
<br>   
<br> CreateEvent跟CreateMutex，你第一个问题关键在于后者内置了一个计数器，比如：假若同一线程连续申请2次互斥量，那么计数器为2，若需要释放互斥量就需要ReleaseMutex（）2次，而前者没有。 
<span style="white-space:pre"> </span>  
<br> 区别2， 
<br>   
<br> Event是一个线程通知另一个线程用的，是单向的。一方接收，其它方可以发送。一般用在单纯的同步上，就是一个操作要等待另一个操作完成时用的，双方地位并不平等。 
<br> Mutex是用于资源控制用的，对于同一个资源，一次只能有一人可以对资源进行访问。双方的地位是平等的。 
<br> Mutex比Event复杂一点，可以用Mutex实现Event的功能 
<span style="white-space:pre"> </span>  
<br> 区别3， 
<br>   
<br> MUTEX其实是你进临界区之前的 
<span style="white-space:pre"> </span>   
<br> 
<span style="white-space:pre"></span>  
<br> 
<span style="font-size:24px; background-color:rgb(255,0,0)">CreateMutex的使用：</span> 
<br> HANDLE CreateMutex( 
<br> LPSECURITY_ATTRIBUTESlpMutexAttributes, // 指向安全属性的指针 
<br> BOOLbInitialOwner, // 初始化互斥对象的所有者 
<br> LPCTSTRlpName // 指向互斥对象名的指针 
<br> ); 
<br> 5、 
<br> A handle to the mutex object indicates success. If the named mutex object existed before the function call, the function returns a handle to the existing object and GetLastError returns ERROR_ALREADY_EXISTS. Otherwise, the caller created the mutex. NULL indicates failure. To get extended error information, call GetLastError. 
<br> #include "stdafx.h" 
<br> #include "windows.h" 
<br>   int main(int argc, char* argv[]) 
<br>       {     HANDLE m_hMutex = CreateMutex(NULL,TRUE,"cplusplus_me"); 
<br>              DWORD dwRet = GetLastError();   
<br>                     if (m_hMutex)  
<br>                           {          
<br>                               if (ERROR_ALREADY_EXISTS == dwRet)    
<br>                                   {      printf("程序已经在运行中了,程序退出!\n");        
<br>                                          CloseHandle(m_hMutex); 
<br>                                          return 0;          
<br>                                    }  
<br>                            } 
<br>                    else    { 
<br>                              printf("创建互斥量错误,程序退出!\n");                                                       CloseHandle(m_hMutex) ; 
<br>                                return 0;      
<br>                               }  
<br>        while(1) 
<br>             {         printf("cplusplus_me\n");     } 
<br>       CloseHandle(m_hMutex);   
<br>        return 0;  
<br>      }  
<br> 
<br> 
<br> 搭配使用的WaitForMultipleObjects： 
<br> DWORD WINAPI WaitForMultipleObjects( 
<br>   __in      DWORD nCount, 
<br>   __in      const HANDLE* lpHandles, 
<br>   __in      BOOL bWaitAll, 
<br>   __in      DWORD dwMilliseconds 
<br> ); 
<br> The WaitForMultipleObjects function can specify handles of any of the following object types in the lpHandles array: 
<br> ·         Change notification  
<br> ·         Console input  
<br> ·         Event  
<br> ·         Memory resource notification  
<br> ·         Mutex  
<br> ·         Process  
<br> ·         Semaphore  
<br> ·         Thread  
<br> ·         Waitable timer  
<br> 
<br> 
<br> 
<br> 
<br> 
<br> 
<br> 
<br> 
<br> 
<br> 
<br> 
<br> 
<span style="font-size:24px; background-color:rgb(255,0,0)"><br> 例子2：（MUTEX对于同一个资源，一次只能有一人可以对资源进行访问）<br> 这个例子使用了 WaitForSingleObject的方法，下面将用WaitForMultipleObjects </span> 
<br> #include &lt;iostream&gt; 
<br> #include &lt;afx.h&gt; 
<br> #include &lt;process.h&gt; 
<br> using namespace std; 
<br> HANDLE          hUp; 
<br> CRITICAL_SECTION g_data; 
<br> int arr[10]; 
<br> HANDLE hMutex; //使用手动重置为无信号状态，初始化时有信号状态 
<br> UINT __stdcall   Add(LPVOID lParam) 
<br> { 
<br>     DWORD dReturn = WaitForSingleObject(hMutex,INFINITE); 
<br>     for (int i = 0; i&lt;10;i++ ) 
<br>     { 
<br>        arr[i]=i;//0-9 
<br>     } 
<br>     for (int i = 0;i &lt; 10; i++) 
<br>     { 
<br>        cout&lt;&lt;arr[i]&lt;&lt;" "; 
<br>     } 
<br>     cout&lt;&lt;endl; 
<br>     ReleaseMutex(hMutex); 
<br>     return 1; 
<br> } 
<br> UINT __stdcall   Add2(LPVOID lParam) 
<br> { 
<br>     DWORD dReturn = WaitForSingleObject(hMutex,INFINITE); 
<br>     for (int i = 0; i&lt;100 ;i++) 
<br>     { 
<br>        arr [i] = i+100;//10`1 
<br>     } 
<br>     for (int i = 0;i &lt; 10; i++) 
<br>     { 
<br>        cout&lt;&lt;arr[i]&lt;&lt;" "; 
<br>     } 
<br>     cout&lt;&lt;endl; 
<br>     ReleaseMutex(hMutex); 
<br>     return 1; 
<br> } 
<br> int main() 
<br> { 
<br>     hMutex = CreateMutex(NULL,FALSE,""); 
<br>     hUp=(HANDLE)_beginthreadex(NULL, 0, Add, NULL, NULL, 0); 
<br>     hUp=(HANDLE)_beginthreadex(NULL, 0, Add2, NULL, NULL, 0); 
<br>     Sleep(5000); 
<br> } 
<br> 
<br> 
<br> 
<br> 
<br> 
<br> 
<br>   
<br> 
<br> 
<br> 
<br> 
<br> 
<span style="font-size:24px; background-color:rgb(255,0,0)">例字3：（CreateEvent 一般用在单纯的同步上，就是一个操作要等待另一个操作完成时用的）（330有关）<br> Waiting for Multiple Objects</span> 
<br> The following example uses the CreateEvent function to create two event objects and the CreateThread function to create a thread. It then uses the WaitForMultipleObjects function to wait for the thread to set the state of one of the objects to signaled using the SetEvent function. 
<br> For an example that waits for a single object, see Using Mutex Objects. 
<br> 
<br> 
<br> 
<br> 
<br> #include &lt;windows.h&gt; 
<br> #include &lt;stdio.h&gt; 
<br> HANDLE ghEvents[2]; 
<br> DWORD WINAPI ThreadProc( LPVOID ); 
<br> void main() 
<br> { 
<br>     HANDLE hThread;  
<br>     DWORD i, dwEvent, dwThreadID;  
<br> 
<br> 
<br> 
<br> 
<br>     // Create two event objects 
<br>     for (i = 0; i &lt; 2; i++)  
<br>     {  
<br>         ghEvents[i] = CreateEvent(  
<br>             NULL,   // default security attributes 
<br>             FALSE,  // auto-reset event object 
<br>             FALSE,  // initial state is nonsignaled 
<br>             NULL);  // unnamed object 
<br>         if (ghEvents[i] == NULL)  
<br>         {  
<br>             printf("CreateEvent error: %d\n", GetLastError() );  
<br>             ExitProcess(0);  
<br>         }  
<br>     }  
<br> 
<br> 
<br>     // Create a thread 
<br>     hThread = CreateThread(  
<br>                  NULL,         // default security attributes 
<br>                  0,            // default stack size 
<br>                  (LPTHREAD_START_ROUTINE) ThreadProc,  
<br>                  NULL,         // no thread function arguments 
<br>                  0,            // default creation flags 
<br>                  &amp;dwThreadID); // receive thread identifier 
<br>     if( hThread == NULL ) 
<br>     { 
<br>         printf("CreateThread error: %d\n", GetLastError()); 
<br>         return; 
<br>     } 
<br> 
<br> 
<br>     // Wait for the thread to signal one of the event objects 
<br>     dwEvent = WaitForMultipleObjects(  
<br>         2,           // number of objects in array 
<br>         ghEvents,     // array of objects 
<br>         FALSE,       // wait for any object 
<br>         5000);       // five-second wait 
<br> 
<br> 
<br>     // The return value indicates which event is signaled 
<br>     switch (dwEvent)  
<br>     {  
<br>         // ghEvents[0] was signaled 
<br>         case WAIT_OBJECT_0 + 0:  
<br>             // TODO: Perform tasks required by this event 
<br>             printf("First event was signaled.\n"); 
<br>             break;  
<br>             // ghEvents[1] was signaled 
<br>         case WAIT_OBJECT_0 + 1:  
<br>             // TODO: Perform tasks required by this event 
<br>             printf("Second event was signaled.\n"); 
<br>             break;  
<br>         case WAIT_TIMEOUT: 
<br>             printf("Wait timed out.\n"); 
<br>             break; 
<br>         // Return value is invalid. 
<br>         default:  
<br>             printf("Wait error: %d\n", GetLastError());  
<br>             ExitProcess(0);  
<br>     } 
<br> // Close event handles 
<br>     for (i = 0; i &lt; 2; i++)  
<br>         CloseHandle(ghEvents[i]);     
<br> } 
<br> 
<br> 
<br> 
<br> 
<br> DWORD WINAPI ThreadProc( LPVOID lpParam ) 
<br> { 
<br>     // Set one event to the signaled state 
<br>     if ( !SetEvent(ghEvents[0]) )     （330中的使用方法） 
<br>     { 
<br>         printf("SetEvent failed (%d)\n", GetLastError()); 
<br>         return -1; 
<br>     } 
<br>     return 1; 
<br> } 
<br> 
<br> 
<br> 
<br>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/88fec444c0d14b82e46252e3932538f9/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">MOOC PTA 08-图8 How Long Does It Take</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b677e5f68776cfbfaaa3244c3f299168/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">win7打印机共享问题</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>