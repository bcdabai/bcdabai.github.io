<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【ChatGPT 01】ChatGPT基础科普 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【ChatGPT 01】ChatGPT基础科普" />
<meta property="og:description" content="1. 从图灵测试到ChatGPT 1950年，艾伦•图灵(Alan Turing)发表论文**《计算机器与智能》（ Computing Machinery and Intelligence），提出并尝试回答“机器能否思考”这一关键问题。在论文中，图灵提出了“模仿游戏”（即图灵测试**）的概念，用来检测机器智能水平。图灵测试的核心思想是，如果一个人（代号C）使用测试对象皆理解的语言去询问两个他不能看见的对象任意一串问题，其中一个是正常思维的人（代号B），另一个是机器（代号A）。如果经过若干询问以后，C不能得出实质的区别来分辨A与B的不同，则此机器A通过图灵测试。
1956年，人工智能正式成为了一个科学上的概念，而后涌现了很多新的研究目标与方向。虽然，图灵测试只是一个启发性的思想实验，而非可以具体执行的判断方法，但他却通过这个假设，阐明了“智能”判断的模糊性与主观性。从此图灵测试成为了 自然语言处理（Natural Language Processing，NLP） 任务的一个重要评测标准。图灵测试提供了一个客观和直观的方式来评估机器是否具有智能，即通过让机器与人类进行对话来判断其智能水平。这种方式可以避免对智能本质的哲学争论，也可以避免对智能具体表现形式的技术细节。 因此，很多自然语言处理任务都可以用图灵测试来进行评测，例如对话系统、问答系统、文本生成等。
自然语言处理（Natural Language Processing，NLP）是计算机科学，人工智能，语言学关注计算机和人类（自然）语言之间的相互作用的领域。它研究能实现人与计算机之间用自然语言进行有效通信的各种理论和方法。自然语言处理包括很多不同的任务，如分词、词性标注、句法分析、语义分析、信息抽取、文本分类、文本摘要、机器翻译、问答系统、对话系统等。
图灵测试与自然语言处理任务有着密切而复杂的关系，可以从以下两个方面来概括：
一方面，图灵测试是自然语言处理任务的一个重要驱动力。图灵测试提出了一个具有挑战性和吸引力的目标，即让机器能够用自然语言与人类进行流畅、智能、多样化的对话。 为了达到这个目标，自然语言处理领域不断地发展和创新各种技术和方法，以提高机器对自然语言的理解和生成能力。例如，为了让机器能够回答用户提出的问题，就需要研究问答系统这一自然语言处理任务；为了让机器能够根据用户提供的信息生成合适的文本，就需要研究文本生成这一自然语言处理任务；为了让机器能够适应不同领域和场景的对话，就需要研究领域适应和情境感知这一自然语言处理任务等等。另一方面，图灵测试是自然语言处理任务的一个重要目标。图灵测试提出了一个具有前瞻性和理想性的愿景，即让机器能够达到与人类相同或者超越人类的智能水平。 这个愿景激发了很多自然语言处理领域的研究者和开发者，使他们不断地探索和创新，以期实现真正意义上的自然语言理解和生成。例如，为了让机器能够理解用户提出的问题，就需要研究语义分析、知识表示、逻辑推理；为了让机器能够生成符合用户需求的文本，就需要研究文本规划、文本风格、文本评价；为了让机器能够与用户建立信任和情感的联系，就需要研究情感分析、情感生成、情感对话等等。 自然语言处理与人工智能发展历史有着密切而复杂的关系。它们相互促进、相互影响、相互依存、相互目标。自然语言处理在人工智能发展历史上有很多里程碑式的成果，比如：
1954年，IBM实现了世界上第一个机器翻译系统，将俄语翻译成英语。1966年，约瑟夫·韦伊岑鲍姆开发了ELIZA，一种模拟心理治疗师的对话系统。1972年，特里·温诺格拉德开发了SHRDLU，一种能够理解和生成自然语言的程序，用于控制一个虚拟的机器人在一个虚拟的世界中进行操作。1988年，杰拉尔德·萨斯曼和詹姆斯·马丁创建了Text Retrieval Conference（TREC），一个旨在推动信息检索和自然语言处理技术发展的国际评测活动。2011年，苹果公司推出了Siri，一种基于自然语言处理技术的智能个人助理。同年，IBM的Watson战胜了《危险边缘》节目的冠军选手，展示了自然语言处理技术在问答领域的强大能力。2013年，谷歌公司推出了Word2Vec，一种基于神经网络的词向量表示方法，开启了自然语言处理领域的深度学习时代。2016年，Facebook发布了FastText的文本分类算法，它可以在处理大规模文本分类任务时取得很好的效果。2017年，Google发布了一篇很可能是AI历史上最重要的一篇论文《Attention is all you need》，在论文中作者提出了Transformer——一个具有多头注意力机制的模型，在文本特征提取方面取得了优异的效果。2018年，Google发布了BERT预训练模型，它在多项NLP任务上取得了最佳效果，引领自然语言处理进入了预训练时代。2020年，OpenAI发布的GPT-3模型有多达1750亿的参数，可以在提供少量样本或不提供样本的前提下完成大多数NLP任务。 以上这些能力成果依赖于自然语言处理技术（NLP）的不断发展。NLP领域涉及到的技术非常广泛，但其中最基础的就是——词嵌入（也叫词向量，Word Embedding），以及与此相关的文本表征技术。它本质上是找到一种编码方式，实现从自然语言中到数学空间的映射。
我们为什么需要词向量呢？当我对计算机说出“我爱你。”的时候，计算机无法真正理解我说了什么。要想让计算机理解我说的话，必须要对“我爱你。”这句话进行编码（Encoding）——比如：我们可以让数字“1”代表“我”，数字“2”代表“爱”，数字“3”代表“你”，数字“0”代表“句号”。经过编码之后，计算机才能理解这句话然后再进行计算和处理。词向量就是以单词为为单位进行编码，那么如何进行编码才是最优的方式呢？从1940年代开始，人们就希望寻找解决这个问题的模型和方法，下面选择最经典的词袋模型和神经网络概率模型，做一些简单一点的介绍。
词袋模型（Bag of Words,BOW）：从名字来看，词袋模型就像是一个大袋子，把所有的词都装进来。文本中的每个单词都看作是独立的，忽略单词之间的顺序和语法，只关注单词出现的次数。在词袋模型中，每个文本可以表示为一个向量，向量的每个维度对应一个单词，维度的值表示该单词在文本中出现的次数。神经概率语言模型（Neural Probabilistic Language Model，NPLM）：它可以通过学习大量的文本数据来预测下一个单词或字符的概率。其中，最早的神经网络语言模型是由Yoshua Bengio等人于2003年发表的《A Neural Probabilistic Language Model》提出的，它在得到语言模型的同时也产生了副产品词向量。 早期的词向量都是静态的，一旦训练完就固定不变了。随着NLP技术的不断发展，词向量技术逐渐演变成基于语言模型的动态表征。语言模型不仅可以表征词，还可以表征任意文本。
时间来到了2022年，终于轮到我们的主角要隆重登场了。2022年11月30日OpenAI发布了一款真正的智能聊天机器人ChatGPT，一经发布立刻就点燃了AI圈。仅仅五天就达到了100万用户。OpenAI不得不紧急扩容，用户发现ChatGPT不仅仅只会插科打诨和人类聊天，它还能写论文，讲笑话，编段子，生成演讲稿，写请假条，模仿导师写推荐信，甚至帮你写代码，写营销策划案等等。拥有了ChatGPT，就像你身边配备了一个功能强大的秘书。到了2023年1月，大量用户开始涌入，仅仅两个月的时间ChatGPT成为了史上最快达到1亿用户的应用。
无论是ChatGPT，还是其他后来的模仿者，它们其实都是语言模型，准确来说——大语言模型。使用时，无论是调用API还是开源项目，总有一些参数可能需要调整。对大部分内行人士来说应该都不成问题，但对外行就有点玄乎了。基于此，本文将简要介绍ChatGPT相关技术基本原理，行文将站在外行人角度，尝试将内容尽量平民化。虽然不能深入细节，但知晓原理足以很好使用了。
本文共分为四个部分：
LM：这是ChatGPT的基石的基石，是一个最基本的概念，绕不开，逃不过，没办法。Transformer：这是ChatGPT的基石，准确来说它的一部分是基石。GPT：本体，从GPT-1，一直到现在的GPT-4，按OpenAI自己的说法，模型还是那个模型，只是它长大了，变胖了，不过更好看了。关于这点，大家基本都没想到。现在好了，攀不上了。RLHF：ChatGPT神兵利器，有此利刃，ChatGPT才是那个ChatGPT，不然就只能是GPT-3。 1. LM LM，Language Model，语言模型，简单来说就是利用自然语言构建的模型。这个自然语言就是人常说的话，或者记录的文字等等，只要是人生产出来的文字，都可以看做语言。你现在看到的文字也是。模型就是根据特定输入，通过一定计算输出相应结果的一个东西，可以把它当做人的大脑，输入就是你的耳、眼听或看到的文字，输出就是嘴巴说出来或手写出来的文字。总结一下，语言模型就是利用自然语言文本构建的，根据输入的文字，输出相应文字的模型。
具体是怎么做的呢，方法有很多种，比如我写好一个模板：「XX喜欢YY」，如果XX=我，YY=你，那就是我喜欢你，反过来就是你喜欢我。我们这里重点要说的是概率语言模型，它的核心是概率，准确来说是下一个词的概率。这种语言模型的过程是通过已经有的词预测接下来的词。我们举个简单的例子，比如你只告诉模型：「我喜欢你」这句话，当你输入「我」的时候，它就知道你接下来要说「喜欢」了。为什么？因为它脑子里就只有这四个字，你没告诉它其他的呀。
好，接下来，我们要升级了。假设你给了模型很多很多句话，多到现在网上能找到的资料都给了它。这时候你再输入「我」，我敢打赌它大概不会说「喜欢」了。为什么？简单，见多了世面，眼里怎么可能只有喜欢你三个字。但因为我们考虑的是最大概率，很有可能它每次都会输出同样的话。对，没错，如果每次都只选择下个最大概率的词，你就是会得到同样的话。这种方法叫做Greedy Search（中文叫贪心搜索），很贪，很短视！所以，语言模型都会在这个地方做一些策略，让模型每一步多看几个可能的词，而不是就看那最高的一个，这样继续往下找的时候，你会发现到下一步时，刚刚最大概率的词，如果加上这一步的词，它的路径（两步概率乘积）概率可能没有刚刚小一点概率的词的路径概率大。举个例子，请看下面这幅图：
（图1：如何预测下一个词）
先看第一步，如果只选概率最大的那个词，那就变成「我想」了，但是别急，我们给「喜欢」一点机会，同时考虑它们两个。再往下看一步，最大概率的都是你，我们也选两个，最后有这么几句（以及我们附上它们的概率）：
「我喜欢你」概率：0.3×0.8=0.24「我喜欢吃」概率：0.3×0.1=0.03「我想你」概率：0.4×0.5=0.2「我想去」概率：0.4×0.3=0.12 多看一步大不一样！看看概率最大的成谁了，久违了，再说一句「我喜欢你」。上面这种方法叫做Beam Search（中文叫集束搜索），简单来说就是一步多看几个词，看最终句子（比如生成到句号、感叹号或其他停止符号）的概率。刚刚我们的例子中，num_beams=2（只看了2个），看的越多，约不容易生成固定的文本。
好了，其实在最开始的语言模型中，大家基本就到这里，上面介绍这两种也叫解码策略。当时更多被研究的还是模型本身，我们经历了从简单模型到复杂模型到巨复杂模型的变迁过程。简单模型就是把一句话切成一个个词，然后统计概率，这类模型叫做Ngram语言模型，是最简单的语言模型，**这里的N表示每次用到的上下文长度。**还是举个例子，看下面这句话：「我喜欢在深夜的星空下伴随着月亮轻轻地想你」。常用的N=2或3，等于2的叫Bi-Gram，等于3的叫Tri-Gram：
Bi-Gram：我/喜欢 喜欢/在 在/深夜 深夜/的 的/星空 星空/下……Tri-Gram：我/喜欢/在 喜欢/在/深夜 在/深夜/的 深夜/的/星空 的/星空/下…… 前者下一个词是根据上一个词来的，后者是根据上两个词来的，就是这个区别。这里有个小知识需要说明一下，实际中我们往往不叫一个词为「词」，而是「Token」，你可以将其理解为一小块，可以是一个字，也可以是两个字的词，或三个字的词，取决于你怎么Token化。也就是说，给定一个句子时，我有多种Token化方式，可以分词，也可以分字，英文现在都是分子词。比如单词Elvégezhetitek，Token化后变成了：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/33a8e9ec79efa4959a583a1e984d36d9/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-11-01T17:52:46+08:00" />
<meta property="article:modified_time" content="2023-11-01T17:52:46+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【ChatGPT 01】ChatGPT基础科普</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="1_ChatGPT_0"></a>1. 从图灵测试到ChatGPT</h2> 
<p><u><strong>1950年</strong></u>，艾伦•图灵(Alan Turing)发表论文**《计算机器与智能》<strong>（ Computing Machinery and Intelligence），提出并尝试回答“机器能否思考”这一关键问题。在论文中，图灵提出了“模仿游戏”（即</strong>图灵测试**）的概念，用来检测机器智能水平。<strong>图灵测试的核心思想是，如果一个人（代号C）使用测试对象皆理解的语言去询问两个他不能看见的对象任意一串问题，其中一个是正常思维的人（代号B），另一个是机器（代号A）。如果经过若干询问以后，C不能得出实质的区别来分辨A与B的不同，则此机器A通过图灵测试。</strong></p> 
<p><img src="https://images2.imgbox.com/bd/50/P9GzpQwi_o.png" alt="在这里插入图片描述"></p> 
<p><u><strong>1956年</strong></u>，人工智能正式成为了一个科学上的概念，而后涌现了很多新的研究目标与方向。虽然，图灵测试只是一个启发性的思想实验，而非可以具体执行的判断方法，但他却通过这个假设，阐明了“智能”判断的模糊性与主观性。从此图灵测试成为了 <strong>自然语言处理（Natural Language Processing，NLP）</strong> 任务的一个重要评测标准。<strong>图灵测试提供了一个客观和直观的方式来评估机器是否具有智能，即通过让机器与人类进行对话来判断其智能水平。这种方式可以避免对智能本质的哲学争论，也可以避免对智能具体表现形式的技术细节。</strong> 因此，很多自然语言处理任务都可以用图灵测试来进行评测，例如对话系统、问答系统、文本生成等。</p> 
<p>  <em>自然语言处理（Natural Language Processing，NLP）是计算机科学，人工智能，语言学关注计算机和人类（自然）语言之间的相互作用的领域。它研究能实现人与计算机之间用自然语言进行有效通信的各种理论和方法。自然语言处理包括很多不同的任务，如分词、词性标注、句法分析、语义分析、信息抽取、文本分类、文本摘要、机器翻译、问答系统、对话系统等。</em></p> 
<p>  图灵测试与自然语言处理任务有着密切而复杂的关系，可以从以下两个方面来概括：</p> 
<ul><li>一方面，图灵测试是自然语言处理任务的一个重要驱动力。图灵测试提出了一个具有挑战性和吸引力的目标，<strong>即让机器能够用自然语言与人类进行流畅、智能、多样化的对话。</strong> 为了达到这个目标，自然语言处理领域不断地发展和创新各种技术和方法，以提高机器对自然语言的理解和生成能力。例如，为了让机器能够回答用户提出的问题，就需要研究问答系统这一自然语言处理任务；为了让机器能够根据用户提供的信息生成合适的文本，就需要研究文本生成这一自然语言处理任务；为了让机器能够适应不同领域和场景的对话，就需要研究领域适应和情境感知这一自然语言处理任务等等。</li><li>另一方面，图灵测试是自然语言处理任务的一个重要目标。图灵测试提出了一个具有前瞻性和理想性的愿景，<strong>即让机器能够达到与人类相同或者超越人类的智能水平。</strong> 这个愿景激发了很多自然语言处理领域的研究者和开发者，使他们不断地探索和创新，以期实现真正意义上的自然语言理解和生成。例如，为了让机器能够理解用户提出的问题，就需要研究语义分析、知识表示、逻辑推理；为了让机器能够生成符合用户需求的文本，就需要研究文本规划、文本风格、文本评价；为了让机器能够与用户建立信任和情感的联系，就需要研究情感分析、情感生成、情感对话等等。</li></ul> 
<p>  自然语言处理与人工智能发展历史有着密切而复杂的关系。它们相互促进、相互影响、相互依存、相互目标。自然语言处理在人工智能发展历史上有很多里程碑式的成果，比如：</p> 
<ul><li>1954年，IBM实现了世界上第一个机器翻译系统，将俄语翻译成英语。</li><li>1966年，约瑟夫·韦伊岑鲍姆开发了ELIZA，一种模拟心理治疗师的对话系统。</li><li>1972年，特里·温诺格拉德开发了SHRDLU，一种能够理解和生成自然语言的程序，用于控制一个虚拟的机器人在一个虚拟的世界中进行操作。</li><li>1988年，杰拉尔德·萨斯曼和詹姆斯·马丁创建了Text Retrieval Conference（TREC），一个旨在推动信息检索和自然语言处理技术发展的国际评测活动。</li><li>2011年，苹果公司推出了Siri，一种基于自然语言处理技术的智能个人助理。同年，IBM的Watson战胜了《危险边缘》节目的冠军选手，展示了自然语言处理技术在问答领域的强大能力。</li><li>2013年，谷歌公司推出了Word2Vec，一种基于神经网络的词向量表示方法，开启了自然语言处理领域的深度学习时代。</li><li>2016年，Facebook发布了FastText的文本分类算法，它可以在处理大规模文本分类任务时取得很好的效果。</li><li>2017年，Google发布了一篇很可能是AI历史上最重要的一篇论文《Attention is all you need》，在论文中作者提出了Transformer——一个具有多头注意力机制的模型，在文本特征提取方面取得了优异的效果。</li><li>2018年，Google发布了BERT预训练模型，它在多项NLP任务上取得了最佳效果，引领自然语言处理进入了预训练时代。</li><li>2020年，OpenAI发布的GPT-3模型有多达1750亿的参数，可以在提供少量样本或不提供样本的前提下完成大多数NLP任务。</li></ul> 
<p>  以上这些能力成果依赖于自然语言处理技术（NLP）的不断发展。NLP领域涉及到的技术非常广泛，但其中最基础的就是——<strong>词嵌入（也叫词向量，Word Embedding），以及与此相关的文本表征技术。它本质上是找到一种编码方式，实现从自然语言中到数学空间的映射。</strong></p> 
<p>  我们为什么需要词向量呢？当我对计算机说出“我爱你。”的时候，计算机无法真正理解我说了什么。要想让计算机理解我说的话，必须要对“我爱你。”这句话进行编码（Encoding）——比如：我们可以让数字“1”代表“我”，数字“2”代表“爱”，数字“3”代表“你”，数字“0”代表“句号”。经过编码之后，计算机才能理解这句话然后再进行计算和处理。词向量就是以单词为为单位进行编码，那么如何进行编码才是最优的方式呢？从1940年代开始，人们就希望寻找解决这个问题的模型和方法，下面选择最经典的词袋模型和神经网络概率模型，做一些简单一点的介绍。</p> 
<ul><li><strong>词袋模型（Bag of Words,BOW）</strong>：从名字来看，词袋模型就像是一个大袋子，把所有的词都装进来。文本中的每个单词都看作是独立的，忽略单词之间的顺序和语法，只关注单词出现的次数。在词袋模型中，每个文本可以表示为一个向量，向量的每个维度对应一个单词，维度的值表示该单词在文本中出现的次数。</li><li><strong>神经概率语言模型（Neural Probabilistic Language Model，NPLM）</strong>：它可以通过学习大量的文本数据来预测下一个单词或字符的概率。其中，最早的神经网络语言模型是由Yoshua Bengio等人于2003年发表的《A Neural Probabilistic Language Model》提出的，它在得到语言模型的同时也产生了副产品词向量。</li></ul> 
<p>  早期的词向量都是静态的，一旦训练完就固定不变了。随着NLP技术的不断发展，词向量技术逐渐演变成基于语言模型的动态表征。<u>语言模型不仅可以表征词，还可以表征任意文本。</u></p> 
<p>  时间来到了2022年，终于轮到我们的主角要隆重登场了。2022年11月30日OpenAI发布了一款真正的智能聊天机器人ChatGPT，一经发布立刻就点燃了AI圈。仅仅五天就达到了100万用户。OpenAI不得不紧急扩容，用户发现ChatGPT不仅仅只会插科打诨和人类聊天，它还能写论文，讲笑话，编段子，生成演讲稿，写请假条，模仿导师写推荐信，甚至帮你写代码，写营销策划案等等。拥有了ChatGPT，就像你身边配备了一个功能强大的秘书。到了2023年1月，大量用户开始涌入，仅仅两个月的时间ChatGPT成为了史上最快达到1亿用户的应用。</p> 
<p>  无论是ChatGPT，还是其他后来的模仿者，它们其实都是语言模型，准确来说——大语言模型。使用时，无论是调用API还是开源项目，总有一些参数可能需要调整。对大部分内行人士来说应该都不成问题，但对外行就有点玄乎了。基于此，本文将简要介绍ChatGPT相关技术基本原理，行文将站在外行人角度，尝试将内容尽量平民化。虽然不能深入细节，但知晓原理足以很好使用了。</p> 
<p>本文共分为四个部分：</p> 
<ul><li>LM：这是ChatGPT的基石的基石，是一个最基本的概念，绕不开，逃不过，没办法。</li><li>Transformer：这是ChatGPT的基石，准确来说它的一部分是基石。</li><li>GPT：本体，从GPT-1，一直到现在的GPT-4，按OpenAI自己的说法，模型还是那个模型，只是它长大了，变胖了，不过更好看了。关于这点，大家基本都没想到。现在好了，攀不上了。</li><li>RLHF：ChatGPT神兵利器，有此利刃，ChatGPT才是那个ChatGPT，不然就只能是GPT-3。</li></ul> 
<h3><a id="1_LM_50"></a>1. LM</h3> 
<p>  LM，Language Model，语言模型，简单来说就是利用自然语言构建的模型。这个自然语言就是人常说的话，或者记录的文字等等，只要是人生产出来的文字，都可以看做语言。你现在看到的文字也是。模型就是根据特定输入，通过一定计算输出相应结果的一个东西，可以把它当做人的大脑，输入就是你的耳、眼听或看到的文字，输出就是嘴巴说出来或手写出来的文字。总结一下，语言模型就是利用自然语言文本构建的，根据输入的文字，输出相应文字的模型。</p> 
<p>  具体是怎么做的呢，方法有很多种，比如我写好一个模板：「XX喜欢YY」，如果XX=我，YY=你，那就是我喜欢你，反过来就是你喜欢我。我们这里重点要说的是概率语言模型，它的核心是概率，准确来说是下一个词的概率。这种语言模型的过程是通过已经有的词预测接下来的词。我们举个简单的例子，比如你只告诉模型：「我喜欢你」这句话，当你输入「我」的时候，它就知道你接下来要说「喜欢」了。为什么？因为它脑子里就只有这四个字，你没告诉它其他的呀。</p> 
<p>  好，接下来，我们要升级了。假设你给了模型很多很多句话，多到现在网上能找到的资料都给了它。这时候你再输入「我」，我敢打赌它大概不会说「喜欢」了。为什么？简单，见多了世面，眼里怎么可能只有喜欢你三个字。但因为我们考虑的是最大概率，很有可能它每次都会输出同样的话。对，没错，如果每次都只选择下个最大概率的词，你就是会得到同样的话。这种方法叫做Greedy Search（中文叫贪心搜索），很贪，很短视！所以，语言模型都会在这个地方做一些策略，让模型每一步多看几个可能的词，而不是就看那最高的一个，这样继续往下找的时候，你会发现到下一步时，刚刚最大概率的词，如果加上这一步的词，它的路径（两步概率乘积）概率可能没有刚刚小一点概率的词的路径概率大。举个例子，请看下面这幅图：</p> 
<p><img src="https://images2.imgbox.com/84/d8/EprqY82l_o.png" alt="在这里插入图片描述"></p> 
<p align="center">（图1：如何预测下一个词）</p> 
<p> </p> 
<p>  先看第一步，如果只选概率最大的那个词，那就变成「我想」了，但是别急，我们给「喜欢」一点机会，同时考虑它们两个。再往下看一步，最大概率的都是你，我们也选两个，最后有这么几句（以及我们附上它们的概率）：</p> 
<ul><li>「我喜欢你」概率：0.3×0.8=0.24</li><li>「我喜欢吃」概率：0.3×0.1=0.03</li><li>「我想你」概率：0.4×0.5=0.2</li><li>「我想去」概率：0.4×0.3=0.12</li></ul> 
<p>  多看一步大不一样！看看概率最大的成谁了，久违了，再说一句「我喜欢你」。上面这种方法叫做<strong>Beam Search（中文叫集束搜索）</strong>，简单来说就是一步多看几个词，看最终句子（比如生成到句号、感叹号或其他停止符号）的概率。刚刚我们的例子中，num_beams=2（只看了2个），看的越多，约不容易生成固定的文本。</p> 
<p>  好了，其实在最开始的语言模型中，大家基本就到这里，上面介绍这两种也叫<strong>解码策略</strong>。当时更多被研究的还是模型本身，我们经历了从简单模型到复杂模型到巨复杂模型的变迁过程。简单模型就是把一句话切成一个个词，然后统计概率，这类模型叫做<strong>Ngram语言模型</strong>，是最简单的语言模型，**这里的N表示每次用到的上下文长度。**还是举个例子，看下面这句话：「我喜欢在深夜的星空下伴随着月亮轻轻地想你」。常用的N=2或3，等于2的叫Bi-Gram，等于3的叫Tri-Gram：</p> 
<ul><li>Bi-Gram：我/喜欢 喜欢/在 在/深夜 深夜/的 的/星空 星空/下……</li><li>Tri-Gram：我/喜欢/在 喜欢/在/深夜 在/深夜/的 深夜/的/星空 的/星空/下……</li></ul> 
<p>  前者下一个词是根据上一个词来的，后者是根据上两个词来的，就是这个区别。这里有个小知识需要说明一下，实际中我们往往不叫一个词为「词」，而是「Token」，你可以将其理解为一小块，可以是一个字，也可以是两个字的词，或三个字的词，取决于你怎么Token化。也就是说，给定一个句子时，我有多种Token化方式，可以分词，也可以分字，英文现在都是分子词。比如单词Elvégezhetitek，Token化后变成了：</p> 
<pre><code class="prism language-python"><span class="token punctuation">[</span><span class="token string">'El'</span><span class="token punctuation">,</span> <span class="token string">'##vé'</span><span class="token punctuation">,</span> <span class="token string">'##ge'</span><span class="token punctuation">,</span> <span class="token string">'##zhet'</span><span class="token punctuation">,</span> <span class="token string">'##ite'</span><span class="token punctuation">,</span> <span class="token string">'##k'</span><span class="token punctuation">]</span>
</code></pre> 
<p>  中文现在基本都是字+词的方式。我们不直接解释为啥这么做，但是可以想一下完全的字或词的效果，拿英文举例更直观。如果只是用26个英文字母，虽然词表很小（加上各种符号可能就100来个），但粒度太细，每个Token几乎完全没法表示语义；如果用词，这个粒度又有点太大，尤其英文还有不同时态，其实它们意思差不多，只是后面不一样。所以子词就应运而生——它把一个词拆成一定大小的语义单位，每个单位既可以表示一定含义，又能灵活组合。中文稍微简单一些，就是字+词，字就是一个字能独立表示意义，比如「是」、「有」、「爱」；词是这个词拆开就不太对劲了，比如「长城」、「情比金坚」。当然，中文你非要搞成一个一个字也不是不可以。我们主要还是从效果上来看。</p> 
<p>  Ngram模型有个致命缺陷——它的表示是离散的，稍微解释一下，在计算机中，只能用1和0表示某个词。假设词表大小为50000，刚刚在Bi-Gram中，「我喜欢」这个Gram就是49999个0和1个1组成的稀疏向量。这种表示方法使用起来有很多缺点，关于这部分内容，后面的《相似匹配Embedding》部分会展开讲解。对，Embedding就是一种稠密表示方法，简单来说，一个Token（后面就都说Token了）是很多个小数（一般可以是任意多个，专业称呼为Embedding的维度，根据所用的模型和设定的参数来确定），一般数字越多，模型越大，表示能力越强。你说我就喜欢用一个小模型，搞一个很大的维度，那我只能说效果可能要让你失望了，911在乡村土路上可能跑不过拖拉机。</p> 
<p>  接下来，我们就假设每个词是一个一维向量，简单解释一下在这种设定下怎么预测下一个Token。其实还是算概率，但这次和刚刚有点不一样了，<strong>刚刚离散的那个就是统计出来有多少次除以总词数就是出现概率。</strong> 但是稠密向量要稍微换个方式，也就是说，给你一个d维的向量，你最后要输出一个长度为N的向量，N是词表大小，N中每一个值都是一个概率值，表示Token的概率，加起来为1。写成简单的计算表达式如下：</p> 
<pre><code class="prism language-python">X <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0.001</span><span class="token punctuation">,</span> <span class="token number">0.002</span><span class="token punctuation">,</span> <span class="token number">0.0052</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token number">0.0341</span><span class="token punctuation">]</span> <span class="token comment"># d维，加起来和1没关系，大小是1×d</span>
Y <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0.1</span><span class="token punctuation">,</span> <span class="token number">0.5</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token number">0.005</span><span class="token punctuation">,</span> <span class="token number">0.3</span><span class="token punctuation">]</span> <span class="token comment"># N个，加起来=1，大小是1×N</span>
W·X <span class="token operator">=</span> Y  <span class="token comment"># W自然可以是 d×N 维的矩阵</span>
</code></pre> 
<p>上面的W就是模型的参数，其实X也可以看作是参数自动学习到。因为我们知道了输入和输出的大小，所以中间其实可以经过任意随意的计算，总之就是各种张量（三维以上数组）运算，只要保证最后的形式不变就行。这中间的各种计算就意味着各种不同的模型。</p> 
<p>  在深度学习的初期，最著名的语言模型是<strong>RNN</strong>，Recurrent Neural<br> Network，中文叫循环神经网络。RNN 模型与其他神经网络不同的地方在于，它的节点之间存在循环连接，<strong>这使得它能够记住之前的信息，并将它们应用于当前的输入。</strong> 这种记忆能力使得 RNN 在处理时间序列数据时特别有用，例如预测未来的时间序列数据、自然语言处理等。通俗地说，RNN 就像一个具有记忆功能的人，可以根据之前的经验和知识对当前的情况做出反应，并预测未来的发展趋势。如下图所示：</p> 
<p><img src="https://images2.imgbox.com/a1/48/qKkesexb_o.png" alt="在这里插入图片描述"></p> 
<p align="center">（图2：RNN，来自：https://colah.github.io/posts/2015-08-Understanding-LSTMs/）</p> 
<p> </p> 
<p>  右边是左边的展开，A就是参数，X是输入，h就是输出，由于自然语言是Token by Token的，所以就组成了一个序列。那这个参数怎么学习呢？这就要稍微解释一下学习过程，请看下面的图：<br> <img src="https://images2.imgbox.com/cc/34/fs2EVqVD_o.png" alt="在这里插入图片描述"></p> 
<p align="center">（图3：语言模型输入输出）</p> 
<p> </p> 
<p>  第一行就是X，第二行就是Y，SOS表示Start of Sentence，EOS就不多解释了。注意，上面的h并不是那个输出的概率，而是hidden state，如果需要概率，可以将h再做一个张量运算，归一化到整个词表即可。简单的演示一下代码：</p> 
<pre><code class="prism language-python"><span class="token keyword">import</span> torch<span class="token punctuation">.</span>nn <span class="token keyword">as</span> nn

rnn <span class="token operator">=</span> nn<span class="token punctuation">.</span>RNN<span class="token punctuation">(</span><span class="token number">32</span><span class="token punctuation">,</span> <span class="token number">64</span><span class="token punctuation">)</span>
<span class="token builtin">input</span> <span class="token operator">=</span> torch<span class="token punctuation">.</span>randn<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">32</span><span class="token punctuation">)</span>
h0 <span class="token operator">=</span> torch<span class="token punctuation">.</span>randn<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">64</span><span class="token punctuation">)</span>
output<span class="token punctuation">,</span> hn  <span class="token operator">=</span> rnn<span class="token punctuation">(</span><span class="token builtin">input</span><span class="token punctuation">,</span> h0<span class="token punctuation">)</span>
output<span class="token punctuation">.</span>shape<span class="token punctuation">,</span> hn<span class="token punctuation">.</span>shape
<span class="token comment"># (torch.Size([4, 64]), torch.Size([1, 64]))</span>
</code></pre> 
<p>  上面<code>nn.RNN</code>就是RNN模型，输入是一个4×32的向量，换句话说，4个Token，维度d=32，h0就是初始化的输出，也就是<code>output</code>4个里面的第一个，这里<code>output</code>的四个64维的向量就分别表示4个输出，<code>hn</code>就是最后一个Token的输出，也可以看成是整个句子的表示。如果要输出词的概率，需要先扩充到词表大小，再进行归一化：</p> 
<pre><code class="prism language-python">wo <span class="token operator">=</span> torch<span class="token punctuation">.</span>randn<span class="token punctuation">(</span><span class="token number">64</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span> <span class="token comment"># 假设词表大小N=1000</span>
logits <span class="token operator">=</span> output @ wo  <span class="token comment"># 4×1000</span>
probs <span class="token operator">=</span> nn<span class="token punctuation">.</span>Softmax<span class="token punctuation">(</span>dim<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">(</span>logits<span class="token punctuation">)</span> <span class="token comment"># 4×1000，每一行概率和为1</span>
</code></pre> 
<p>  这里的<code>probs</code>每一行就是词表大小的概率分布，和为1，意思是这个Token到词表每个Token的概率。</p> 
<p>  因为我们知道接下来的Token是啥（就是上面图里的第二行Y），那我这里得到最大概率的那个Token如果正好是这个Token，说明预测对了，参数就不用怎么调整；反之，模型就会调整前面的参数（上面<code>RNN</code>、<code>h0</code>、<code>input</code>的参数和下面的<code>wo</code>）。你可能会疑惑为啥<code>input</code>也是参数，其实上面的<code>input</code>我们偷了懒，本来的参数是1000×32的大向量，4个是那四个Token对应位置的那一行向量。这个1000×32的向量其实就是词向量（每个词一行），开始时随机初始化，然后通过训练调整参数。</p> 
<p>  训练完成后，这些参数就不变了，然后就可以用和上面同样的步骤来预测了，也就是给定一个Token预测下一个Token。如果是Greedy Search，每次你给定同样Token时，生成的就一样。其余的就和前面讲的接上了。</p> 
<p>  好了，语言模型就介绍到这里，上面的代码看不懂没关系，能get到意思就行，这里面细节非常多，但大概意思已经到位了。你只需要大概了解每个Token是怎么表示、怎么训练和预测出来的就行。</p> 
<blockquote> 
 <ol><li>rnn = nn.RNN(32, 64): 创建了一个 RNN 模型，该 RNN 接受输入大小为 32，输出大小为 64。这里输入的维度是 32，表示输入数据的特征维度，输出的维度是 64，表示 RNN 层的隐藏状态大小。</li><li>input = torch.randn(4, 32): 生成一个形状为 (4, 32) 的张量，其中 4 表示序列长度，32 是输入特征的维度。这个输入数据将作为 RNN 模型的输入。</li><li>h0 = torch.randn(1, 64): 生成一个形状为 (1, 64) 的张量，表示 RNN 的初始隐藏状态。</li><li>output, hn = rnn(input, h0): 将输入数据和初始隐藏状态传递给 RNN 模型。output 是 RNN 模型的输出张量，hn 是模型在序列结束时的隐藏状态。</li><li>wo = torch.randn(64, 1000): 创建一个权重张量，假设这个权重用于将 RNN 输出的隐藏状态映射到词表大小（N=1000）的输出空间。</li><li>logits = output @ wo: 执行矩阵乘法操作，将 RNN 输出的结果乘以权重矩阵 wo，得到一个 (4, 1000) 大小的张量 logits，表示每个样本对应 1000 个词的预测分数。</li><li>probs = nn.Softmax(dim=1)(logits): 对 logits 进行 Softmax 操作，计算每个样本中每个词的概率。dim=1 表示沿着每一行计算 Softmax，保证每行的概率和为1。</li></ol> 
</blockquote> 
<h3><a id="2_Transformer_146"></a>2. Transformer</h3> 
<p>  接下来出场的是Transformer，一个刚开始在NLP领域，后来横跨到语音和图像领域，并最终统一几乎所有模态的架构。这是Google2017年发的一篇论文，标题叫《Attention Is All You Need》，其最重要的核心就是提出来的Self-Attention机制，中文也叫自注意力。<strong>简单来说，就是在语言模型建模过程中，把注意力放在那些重要的Token上。</strong> 想来，Google在发表论文之初也没有料想到今天吧。</p> 
<p>  Transformer是一种Encoder-Decoder架构，简单来说就是先把输入映射到Encoder，这里大家可以把Encoder先想象成上面介绍的RNN，Decoder也可以想象成RNN。这样，左边负责编码，右边则负责解码。这里面不同的是，左边因为我们是知道数据的，所以建模时可以同时利用当前Token的历史Token和未来（前面的）Token；但解码时，因为是一个Token一个Token输出来的，所以只能根据历史Token以及Encoder的Token表示进行建模，而不能利用未来的Token。</p> 
<p>  Transformer的这种架构从更普遍的角度来看，其实是Seq2Seq架构，大家别慌，这简单来说就是序列到序列模型，也就是输入是一个文本序列，输出是另一个文本序列。翻译就是个很好的例子，我们看下面这个来自Google的GNMT（Google Neutral Machine Translation）的经典图片：</p> 
<p align="center">（图4：GNMT图示，来自GNMT GitHub：https://github.com/belvo/Google-Neural-Machine-Translation-GNMT-）</p> 
<p> </p> 
<p>  刚刚已经说了，Encoder和Decoder可以采用RNN，最终就是Encoder所有Token最终输出一个向量，作为整句话的表示。说到这里，整句话又怎么表示呢？刚刚上面我们也提到过，如果RNN这种结构，可以把最后一个Token的输出作为整个句子的表示。当然了，很符合直觉地，你也可以取每个Token向量的平均值，或第一个和最后一个的平均值，或后面N个的平均值。这些都可以，问题不大，不过一般取平均的情况比较多，效果要好一些。除了平均值，也可以求和、取最大值等，我们就不多深入讨论了。现在重点来了，看Decoder的过程，仔细看，<strong>其实它在生成每一个Token时都用到了Encoder每一个Token的信息，以及它已经生成的Token的信息。</strong> <strong>前面这种关注Encoder中Token的信息的机制就是Attention（注意力机制）。</strong> 直观点解释，当生成Knowledge时，「知识」两个字会被赋予更多权重，其他也是类似。</p> 
<p>  让我们带着上面的记忆，看一下Transformer的结构，如下图所示：</p> 
<p><img src="https://images2.imgbox.com/c9/4a/szngJvuh_o.jpg" alt=""></p> 
<p align="center">（图5：Transformer，来自Transformer论文）</p> 
<p> </p> 
<p>  这个图更多的是体现了内部结构。左边是Encoder的一个Block（一共N个），右边是Decoder的一个Block（一共N个），简单起见，我们可以假设N=1，那左边这个结构就是一个Encoder，右边的就是Decoder。也可以把它们就想象成一个RNN，这样有助于从宏观上把握。现在，想象完了，我们回到现实，Transformer 用到的东西和RNN并没有关系，通过上图也可以看出来，它主要用了两个模块：<strong>Multi-Head Attention和Feed Forward</strong>。对于前者，我们不妨回顾一下GNMT的Attention，它是Decoder中的Token和Encoder中每一个Token的重要性权重。Multi-Head Attention中用到一个东西叫SelfAttention，和刚刚说的Attention非常类似，只不过<strong>它是自己的每一个Token和自己的每一个Token的重要性权重。</strong> 简单来说，就是“一句话到底哪里重要”。这玩意儿可以说是非常精髓了，无论是ChatGPT，还是其他非文本的模型，几乎都用到了它，可以说是真正的一统江湖。Multi-Head是啥意思呢，简单来说，就是把刚刚的这种自己注意自己重复Multi次（Multi个Head），每个注意到的信息不一样，这样就可以捕获到更多信息。比如我们前面提过的这句话：「我喜欢在深夜的星空下伴随着月亮轻轻地想你」，有的Head「我」注意到「喜欢」，有的Head「我」注意到「深夜」，有的Head「我」注意到「想你」……这样看起来是不是更加Make Sense。对于Feed Forward，大家可以把它当做「记忆层」，大模型的大部分知识都存在这里面，Multi-Head Attention则根据不同权重的注意提取知识。</p> 
<p>  实际中，大多数NLP任务其实并不是Seq2Seq的，最常见的主要包括这么几种<u>：句子级别分类、Token级别分类（也叫序列标注）、相似度匹配和生成</u>；而前三种应用最为广泛。这时候Encoder和Decoder就可以拆开用了。左边的Encoder在把句子表示成一个向量时，可以利用上下文信息，也就是说，可以把它看作是双向的；右边的Decoder不能看到未来的Token，一般只利用上文，是单向的。虽然它们都可以用来完成刚刚提到的几个任务，但从效果上来说，Encoder更加适合非生成类任务，Decoder更加适合生成类任务。在NLP领域，一般也会把它们分别叫做NLU（Natural Language Understanding，自然语言理解）任务和NLG（Natural Language Generation，自然语言生成）任务。</p> 
<p>  首先介绍NLU任务。句子级别分类是给定一个句子，输出一个类别。因为句子可以表示为一个向量，经过张量运算，自然可以映射到每个类的概率分布。这和前面语言模型提到过的搞法没有本质上的区别，只不过语言模型的类别是整个词表大小，而分类的类别是看具体任务的，有二分类、多分类、多标签分类等等。Token级别的分类是给定一个句子，要给其中每个Token输出一个类别。这个和语言模型就更像了，只不过把下一个Token换成是对应的类别，比如命名实体识别就是把句子中的实体（人名、地名、作品等你关注的词，一般是名词）给提取出来。它们的类别一般是类似，如果以人名（PER）举例的话，类似这样：B-PER表示开始、I-PER表示中间。举个例子：「刘亦菲好看」，此时，Token是字，对应的类别为「B-PER、I-PER、I-PER、O、O」，O表示Other。注意，对于分类任务，类别我们一般也叫它标签。相似匹配任务一般是给定两个句子，输出是否相似，其实也可以看作是特殊的分类问题。</p> 
<p>  接下来介绍NLG任务。除了生成外，常见的任务还有文本摘要、机器翻译、改写纠错等。这里Seq2Seq的结构就比较常见了，体现了一种先理解再输出的感觉。而纯生成类任务，比如写诗、写歌词、写小说几乎都是Decoder结构。这一类任务稍微麻烦一些的是自动评测，除生成的其他任务还好，一般都会提供参考答案（reference），可以看模型输出的和参考之间重叠程度或相似程度。但纯生成任务就有点麻烦，这个好不好有时候其实很难衡量。不过针对有具体目标的（如任务机器人对话生成），还是可以设计一些是否完成任务、达到目标之类的评测方法。但对于没有具体目标的（比如闲聊），这评测起来就见仁见智了，很多时候还是靠人工过一遍。</p> 
<p>  Transformer这个架构基于Seq2Seq，可以同时处理NLU和NLG任务，而且这种Self Attention机制的特征提取能力很强。这就使得NLP取得了阶段性的突破，深度学习开始进入了微调模型时代。大概的做法就是拿着一个开源的预训练模型，然后在自己的数据上微调一下，让它能够搞定特定的任务。这个开源的预训练模型往往就是个语言模型，从大量数据语料上，使用我们前面讲的语言模型的训练方法训练而来。NLU领域的第一个工作是Google的BERT，相信不少人即便不是这个行业的也大概听过。BERT就是用了Transformer的Encoder架构，有12个Block（看上面那个图，这每一个Block也可以叫一层），1亿多参数，它不预测下一个Token，而是随机把15%的Token盖住，然后利用其他没盖住的Token来预测盖住的Token。其实和根据上文预测下一个Token是类似的，不同的是可以利用下文信息。NLG领域的第一个工作是OpenAI的GPT，用的是Transformer的Decoder架构，参数和BERT差不多。它们都发表于2018年，然后分别走上了两条不同的路。</p> 
<h3><a id="3_GPT_178"></a>3. GPT</h3> 
<p>  GPT，Generative Pre-trained Transformer，没错了，就是ChatGPT的那个GPT，中文叫「生成式预训练Transformer」。生成式的意思就是类似语言模型那样，Token by Token生成文本，也就是上面提到的Decoder。预训练刚刚也提过了，就是在大量语料上训练的语言模型。GPT模型从1到4，一共经历了5个版本，中间有个ChatGPT是3.5版，接下来我们分别介绍它们的基本思想。</p> 
<p>  GPT-1和BERT一样，走的是下游任务微调套路，也就是固定住预训练模型不动，然后在不同下游任务上微调一个模型，如下图所示：</p> 
<p><img src="https://images2.imgbox.com/20/a1/wERVrrZL_o.png" alt="在这里插入图片描述"></p> 
<p align="center">（图6：GPT基本结构，来自GPT论文）</p> 
<p> </p> 
<p>  关于左边，我们上面已经介绍过了，用的就是Transformer的架构（GPT中是Decoder），具体里面的子模块可以不用关注。重点看看右边，这里有一个值得注意的地方，就是针对不同的任务输入，都拼接成文本序列，然后丢给Transformer Decoder再通过一个Linear+SoftMax输出结果。Linear是一种最基础的网络结构，SoftMax我们前面介绍过，主要用来把输出映射到概率分布（和为1）。这种拼接输入的方法在当时那个大模型时代非常流行的，紧跟其后的BERT也是类似的方式。这样统一的处理方法能够减少不同任务对模型的改动。反正不管什么任务，都想方设法搞成一个序列就行。</p> 
<p>  GPT这篇文章还有几个点在当时看起来可能没啥感觉，但现在回看却有点意思（就像乔布斯说的dot）。第一个是预训练层数和任务表现的关系，如左下图所示；第二个是训练参数数量和模型性能关系。</p> 
<p><img src="https://images2.imgbox.com/6c/37/wI7s04ED_o.png" alt="在这里插入图片描述"></p> 
<p align="center">（图7：左图是GPT参数量与效果图，右图是Zero-Shot能力，来自GPT论文）</p> 
<p> </p> 
<p>  上图可以得出两个基本结论：<br> 第一，预训练模型中的每一层都包含用于解决目标任务的有用功能，说明多层有更多能力；<br> 第二，随着参数的增加，Zero-Shot获得更好的性能。简单总结来看就是，模型大了不仅能学到更多知识，有助于解决下游任务，还表现出了Zero-Shot能力。</p> 
<blockquote> 
 <p>Zero-Shot是指直接给模型任务输入让它输出任务结果；Few-Shot是给模型提供一些示例，然后再给出任务，让它给出输出结果。</p> 
</blockquote> 
<p>  好了，有了上面的结论，很自然会怎么样？是不是想看看更多层（更多参数）的表现如何？于是半年多后GPT-2来了，参数量从GPT的110M增加到了1.5B，十倍于前者。更有意思的是，在GPT论文的<a href="https://openai.com/research/language-unsupervised" rel="nofollow">博客</a>中有一个「未来工作」，位于第一个的就是扩大规模，还有两个分别是提升微调和更好地理解为什么生成式预训练能提升理解（NLU）能力。</p> 
<p>  GPT发表于2018年6月，GPT-2发表于2019年2月，就是前者的升级版：一个是扩大规模，再就是Zero-Shot。如果说前者是观察到了这个现象，那后者就是进一步研究这个现象。请看下面这张图：</p> 
<p><img src="https://images2.imgbox.com/9e/6a/34hwcr2W_o.png" alt="在这里插入图片描述"></p> 
<p align="center">（图8：参数量和Zero-Shot表现，来自GPT-2论文）</p> 
<p> </p> 
<p>  纵坐标是不同任务的评估指标，横坐标是参数量，效果一目了然。进一步验证了前面的想法，那下一步要做的就是继续扩大规模……不过且慢，在此之前我们不妨看一下GPT-2中的Token生成策略，也就是生成下一个Token时的方法。前面第一部分我们提到过比较优秀的Beam Search，不过它有两个比较明显的问题，第一是生成的内容容易重复；第二是高质量的文本和高概率并不一定相关，人更加喜欢有「不一样」的内容，而不是完全可预测的，比如张爱玲说过「孤独的人有他们自己的泥沼」，这种独一无二的文字用高概率的词大概率是得不到的。简单来看，这两个问题其实可以归结为一个点：生成的内容确定性太大。</p> 
<p>  现在，我们介绍一种基于采样的方法，简单点来说，就是基于已有的上下文随机选择下一个Token。不过随机也有问题，那就是可能生成不连贯的文本（很容易理解对吧）。这里有个Trick可以缓解这个问题——进一步增加高概率词的可能性，降低低概率词的可能性。这样就不太容易随机到很低概率（很可能不连贯）的生成。具体的做法是用过一个<code>temperature</code>的参数调整输出的概率分布，这个参数值越大，分布就看起来越平滑，也就是高概率和低概率的差距拉小了（对输出不那么确定）；当然越小的话，高概率和低概率的差距更明显了（对输出比较确定）。如果趋近于0，那就和Greedy Search一样了。这在深度学习中是一种比较常见的方法，感兴趣的读者可以进一步读一下这个StackOverflow的<a href="https://stackoverflow.com/questions/58764619/why-should-we-use-temperature-in-softmax/63471046#63471046" rel="nofollow">解释</a>。</p> 
<p>  除了刚刚的Trick，这篇<a href="https://arxiv.org/pdf/1805.04833.pdf" rel="nofollow">论文</a>在2018年介绍了一种新的采样方案，很简单但实际很有效果，就是GPT-2里使用到的Top-K采样。简单来说，就是在选择下一个Token时，在Top-K个里面选（Top-K=0时就是所有词表范围）。这个方法不错，不过还有个小问题，就是Top-K个其实是一种硬截断，根本不管第K个概率是高还是低。极端情况下，如果某个词的概率到了0.99，K稍微大一点就必然会囊括进来一些很低概率的词。这会导致不连贯。</p> 
<p>于是，2020年的这篇<a href="https://arxiv.org/pdf/1904.09751.pdf" rel="nofollow">论文</a>提出了另外一种采样方案：Top-P，GPT-2里也有这个策略。这种策略是在累计概率超过P的词里进行选择。这样，对于概率分布比较均匀的情况，可选的词就会多一些（可能要几十个词的概率和才会超过P）；对于概率分布不均匀的情况，可选的词就少一些（可能2-3个词的概率就超过了P）。</p> 
<p>  Top-P看起来更加优雅一些，两者也可以结合使用，不过大部分时候当我们需要调的时候，调一个就好，包括前面的tempreture参数。如果要调多个，请确保理解每个参数的作用。最后，需要说明的是，任何一种采样策略都不能100%保证每一次生成的效果都很好，也没办法避免生成重复的话（可以考虑使用类似后处理的方法缓解）。也没有一种策略是在任何场景下都适用的，需要根据实际情况灵活选择。</p> 
<p>  GPT-3是2020年7月发表的，在当时也是个大新闻，因为它的参数量已经达到了其他任何模型在当时望尘莫及的量级：175B，是GPT-2的100多倍。而且，没有开源。伸手党有点尴尬。GPT-3是觉得既然有Zero-Shot能力，那能不能不微调呢，碰到一个任务就微调这多麻烦。你看看人类，只要几个例子（Few-Shot）和一些简单的说明就可以处理任务了是不是。怎么办？GPT-2不是进一步确认了Zero-Shot能力了吗，上，继续上，加大参数量，于是就有了175B的GPT-3。也就是说，各种任务来吧，我不调参数，顶多就要几个例子（下一步连这个也不要了），我就能给你搞定它。其实现在回头看，这篇论文是具有里程碑意义的，因为它从根本上触动了原有的范式，而且是革命式地触动。关于这点，我之前写过一篇文章：<a href="https://yam.gift/2023/01/20/NLP/2023-01-20-GPT3/" rel="nofollow">GPT-3 和它的 In-Context Learning | Yam</a>，感兴趣的读者可以进一步阅读。可惜当时没读出来，现在回忆，还是因为175B在当时看起来太大了，而且也太贵了（几百万美元呢），效果再好又能咋样，玩儿不起啊。这不光是小部分人没意识到，可能是除了OpenAI团队之外的整个世界都没意识到。先看下面这个图：</p> 
<p><img src="https://images2.imgbox.com/7b/71/Ia0fa0O8_o.jpg" alt=""></p> 
<p align="center">（图9：X-Shot在不同参数量级的表现，来自GPT-3论文）</p> 
<p> </p> 
<p>这张图可以提供几个信息：</p> 
<ul><li>X-Shot在不同量级差别巨大，大模型就是有超能力。</li><li>大模型下，One-Shot效果明显大幅度提升；增加Prompt会进一步大幅度提升。</li><li>Few-Shot的边际收益在递减。大概8-Shot以下时，Prompt作用明显，但从One-Shot到8-Shot，Prompt的作用也在递减。超过10-Shot时，Prompt基本没作用了。</li></ul> 
<p>  总而言之，大模型具有In-Context能力，这种能力使得它不需要针对不同任务再进行适应性训练（微调），它用的就是它自己本身的理解力。这本来应该很让人震惊（甚至有一丢丢惊恐），不过大家可能都先被它的价格和规模震惊到了。接下来，我们再直观感受一下利用这种In-Context能力完成任务的方式，如下图所示：</p> 
<p><img src="https://images2.imgbox.com/c9/f2/n9v74iiU_o.jpg" alt=""></p> 
<p align="center">（图10：如何使用In-Context能力完成任务，来自GPT-3论文）</p> 
<p> </p> 
<p>  看起来一点都不复杂，你只要按照它的格式把输入构建好放进去就可以了。这也是本项目之所以存在的一个很重要的原因——AI已经平民化了，现在你只要有手（可能以后没手也行），通过使用LLM（Large Language Model）就可以做出AI应用了。</p> 
<p>  最后值得一提的是GPT-3中的展望（他们真的是沿着「展望」在往前推进，而不是写一下就完事了）。在论文的“局限”小节中，他们提出了GPT-3目前的一些问题，其中有两点要特别指出，因为它们是下一代InstructGPT（也是ChatGPT的姐妹版）以及更高级版本的方向。</p> 
<ul><li>自监督训练（就是开始语言模型的方法）范式已到极限，新的方法迫在眉睫。未来的方向包括：从人类中学习目标函数、强化学习微调或多模态。</li><li>不确定Few-Shot是不是在推理时学习到新的任务，还是识别出来了在训练时学到的任务。最终，甚至不清楚人类从零开始学习与从之前的样本中学习分别学到什么。准确理解Few-Shot的工作原理是一个未来的方向。</li></ul> 
<p>  第一点在下一节就会提到，主要说说第二点。这里说的意思是，当我们给出一些示例时（Few-Shot），我们还无法精准确定是在推理时「学习」到新任务的处理方法（这种情况下，如果没有示例就没有能力；这里的「学习」要打引号，因为它不调整参数），还是在训练时已经具备了这个能力，示例只是让它「回想」起之前学的。这里有点绕，拿人来举例（可能不太恰当，希望能说明问题），比如说你在读到一首诗时，自己也诗兴大发写了一句。你说这句诗是因为你读到这首诗时「领悟」到的，还是你本来就有这个积累（记忆），现在只是因为读这首诗而被勾了出来？你看，这涉及到大脑、思维、意识等领域知识，而人类至今还没有搞清楚它们的原理，所以我们现在还不知道答案。</p> 
<h3><a id="4_RLHF_258"></a>4. RLHF</h3> 
<p>  RLHF，Reinforcement Learning from Human Feedback，从人类反馈中学习，听起来怎么平平无奇。确实，它的思想非常朴素简单，但却有着不可忽视的效果。刚刚我们已经提到了，GPT-3说未来要找新的方法，这其中就包括从人类中学习、强化学习微调、多模态等。时至今日，从InstructGPT到ChatGPT，再到GPT-4，它一步一步在实现这些新的方法。这里有一点需要提醒，这些方向并不是一开始就清晰地摆在那里的，中间还是有非常多的探索和阶段性成果（既有他们自己的研究，也有其他从业人员的研究）。千万不要看到结果觉得平平无奇，尤其是作为非行业人士（特别是有些媒体），这中间的艰难探索永远值得尊敬。另外，有时候即便知道了方法，要做出来，还做出效果来，这也是非常有难度的。而且本文由于科普性质，只能介绍一丢丢内容，虽然整体结构比较完整，但总体还是比较浅显（所以标题是「一点所以然」）。总的来说，要做出来很有难度，不过我们只是用的话，如前面所言，有手就行。</p> 
<p>  好了，言归正传，RLHF被人熟知应该主要是源自OpenAI的InstructGPT这篇论文，当然更大范围的熟知就是ChatGPT的发布。因为后者没有论文，也没有开源，所以我们也只能拿InstructGPT的管窥一窥ChatGPT的豹。当然，如果按照ChatGPT<a href="https://openai.com/blog/chatgpt" rel="nofollow">官方页面</a>的说法，这个「管」可能还比较粗。如果用简单的语言来描述InstructGPT，其实就是用强化学习的算法微调一个根据人类反馈改进的语言模型。重要的是，它调出了效果——1.3B的InstructGPT堪比175B的GPT-3，如下图所示：</p> 
<p><img src="https://images2.imgbox.com/30/d0/iJimKnRP_o.png" alt="外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传"></p> 
<p align="center">（图11：不同策略不同模型效果对比，来自InstructGPT论文）</p> 
<p> </p> 
<p>  上面一共五根线，我们稍微解释一下，上面两根（PPO）的，就是InstructGPT设置下的结果；中间那根SFT可以理解成GPT-3+微调，理论上来说（实际也是这样）微调后的效果要好于Few-Shot，更好于Zero-Shot；下面两根是GPT-3的结果。当然，这个评测方式可能有一点值得商酌。</p> 
<p>  好了，现在咱们看看它是如何做的，RLHF在其中又是起了什么作用，如何起作用的。还是那张被到处张贴的图，如果要统计引用率，我感觉这张图绝对不低。</p> 
<p><img src="https://images2.imgbox.com/77/da/X3ZTMvPP_o.png" alt="外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传"></p> 
<p align="center">（图12：InstructGPT工作流程，来自InstructGPT论文）</p> 
<p> </p> 
<p>  这张图比较直观的展示了InstructGPT的整个流程。共三个步骤：</p> 
<ul><li>Step1：SFT，Supervised Fine-Tuning，有监督微调。顾名思义，它是在有监督（有标注）数据上微调训练得到的。这里的监督数据其实就是输入Prompt，输出相应的回复，只不过这里的回复是人工编写的。这个工作要求比一般标注要高，其实算是一种创作了。</li><li>Step2：RM，Reward Model，奖励模型。具体来说，一个Prompt丢给前一步的SFT，输出若干个（4-9个）回复，由标注人员对这些回复进行排序。然后从4-9个中每次取2个，因为是有序的，就可以用来训练这个奖励模型，让模型学习到这个好坏评价。这一步非常关键，它就是所谓的Human Feedback，引导下一步模型的进化方向。</li><li>Step3：RL，Reinforcement Learning，强化学习，使用PPO策略进行训练。PPO，Proximal Policy Optimization，近端策略优化，是一种强化学习优化方法，它背后的主要思想是避免每次太大的更新，提高训练的稳定性。具体过程如下：首先需要初始化一个语言模型，然后丢给它一个Prompt，它生成一个回复，上一步的RM给这个回复一个打分，这个打分回传给模型更新参数。这里的这个模型在强化学习视角下就是一个策略。这一步有个很重要的动作，就是更新模型时会考虑模型每一个Token的输出和第一步SFT输出之间的差异性，要让它俩尽量相似。这是为了缓解强化学习可能的过度优化。</li></ul> 
<p>  就这样？对，就这样，RLHF都表现在上面了，效果大家都知道了。虽然ChatGPT没有发表相关论文，但我们基本都相信它也是基于类似的思路实现的。当然，这里面细节非常多，即便知道了这个思路，也不一定能复现出来。这在深度学习时代很正常，里面的各种小设计、小细节实在是太多了。当它们堆积到一定量时，造成的差别是很难一下子弥补的，如果别人不告诉你，那你只能自己慢慢做实验去验证。</p> 
<p>  下面，我们强行解释一波RLHF是如何起作用的，为什么它现在能成为一个基本的范式。其实，强化学习用在NLP领域一直以来都有研究，正好笔者本人也由于一些原因一直关注在关注文本生成，以及强化学习在文本生成方面的研究。这里可能有两个难点：一个是训练的稳定性；另一个就是奖励函数的设计。前者，有PPO策略和与SFT的差异衡量，得到不小的改进。后者，如果从客观角度考虑设计一个规则就不那么容易了。我也曾设想过很多类似的方法，比如加入一些语法规则限制，甚至是类似最省力法则这样的规则。</p> 
<blockquote> 
 <p>最省力法则：齐夫在《Human Behavior and the Principle of Least Effort： an introduction to human ecology》一书中提出的，简单来说就是语言具有惰性，会朝着使用较少的词语表达尽可能多的语义这个方向进行演化。</p> 
</blockquote> 
<p>  InstructGPT使用了人类反馈直接作为「规则」，也就是把这种「规则」给隐式化，当做黑盒。我们只管结果好坏，至于中间有什么规则，有多少种规则，怎么起作用，统统不关心。这是和深度学习类似的思路，相比而言，自己之前的想法可能有些Naive了，毕竟语言学本身也是有不少争议没有搞清楚，比如语言能力是不是人生来具有的能力？InstructGPT的做法更加简单、直接，而且有效。</p> 
<p>  剩下要解决的就是怎么衡量「好坏」，毕竟最终总是要个结果的，既然要结果就要有标准。读者不妨思考一下，如果换做你，会如何设计一些指标来衡量两段输出内容的好坏。这一步看似容易，其实特别不容易，因为指标的设计会影响到模型的学习方向，最终就会影响到效果。因为这个输出的好坏衡量标准就太多了，虽然看起来是对给出的几个结果进行排序（上面的第二步），但其实这个过程中间隐藏了大量人类的认知，<strong>模型训练过程其实就是和第二步这个衡量过程对齐的过程</strong>。所以，如果第二步指标没设计好，第三步就是白费力气。尤其是对于InstructGPT这样针对几乎所有任务的设计，衡量就更加不容易。试举一例，比如一个摘要任务，我们可能最关注的是能否准确概括原文信息，而一个生成任务可能就关注流畅性和前后逻辑一致性。InstructGPT里面有10种任务，要分别针对每种任务去搞指标那就比较麻烦了，而且效果还不一定好，因为这些指标并不一定都是一个方向。还有就是，万一又有了一个新任务，难道要再去设计一套指标，全部重新训练一遍模型？</p> 
<p>  我们看看InstructGPT是怎么设计衡量指标的，我觉得这是InstructGPT这篇论文最宝贵的地方，也是最值得我们思考和实践的地方。为此，笔者早早就专门花时间仔细研读了相关的资料，并写了一篇专门介绍其标注的文章：<a href="https://yam.gift/2023/02/19/NLP/2023-02-19-ChatGPT-Labeling/" rel="nofollow">ChatGPT 标注指南：任务、数据与规范 | Yam</a>，感兴趣的读者可以进一步阅读。不过这方面的报道和研究好像比较少。</p> 
<p>  不多说了，我们继续。首先，InstructGPT用了三个大的通用指标：有帮助、真实性和无害性，有点类似阿西莫夫的机器人三定律。也就是说，我不管你是什么任务，你都得朝着这三个方向靠。这个想法真值得点赞。现在我们看到这个结果了，自然感觉好像没什么，但要是事先不知道要去设计出来，大部分人还是很容易陷入被任务影响的境地。其实OpenAI团队在In-Context Learning上的坚持也是一样，这个我们前面在讲GPT一节时已经提到过了。别人告诉你那个结果时，你可能觉得好像不觉得有什么，甚至很多研究机构、研究人员都有想过。但在有效果之前，笃信一条罕有人走的路，且一直坚定不移地走下去，这是很不容易的。</p> 
<p>  有了刚刚的三大指导方针，接下来就是细化，使其具有可操作性。比如，对于第一条有帮助性，InstructGPT给了下面一些属于「有帮助」行为的示例：</p> 
<ul><li>用清晰的语言写作。</li><li>回答他们想问的问题，即使问错了。</li><li>对国际性敏感（比如 “football” 不应该指美式足球，“总统” 不一定指美国总统）。</li><li>如果指令（Instruction）太困惑，要求澄清并解释指令为什么困惑。</li><li>不给出过长或冗长的答案，或重复问题中的信息。</li><li>不要在给定的内容之外假设无关的额外上下文（除非是关于世界的事实），除非这是任务的隐含部分。比如，要求 “礼貌地回复这封电子邮件：{email body}”，输出不应该假设 “我这次不能来，但下周末有空”。但如果被要求 “给苏格拉底写一封电子邮件”，那么可以放心地使用该假设。</li></ul> 
<p>  我相信实际上这个列表可能很长，有很多项会在实际标注过程中被依次添加进去，直到能覆盖绝大多数情况为止，即对于大部分要标注的数据，根据提供的细则很容易就判断出来是否「有帮助」。现在不妨停下来再思考一下，如果一开始就奔着这些细则设计奖励规则——只是想想就觉得不太现实。其他两个指标也有一些示例，我们这里不再赘述，感兴趣的读者可以阅读这段前面的那篇文章，以及它后面的参考资料（有些文档在论文里并没有被提及）。</p> 
<p>  有了细则还没完，接下来要解决的是前面提到的，指标之间的冲突权衡问题。因为这是个比较任务（比较哪个输出好），当涉及多个指标时，一定会出现一个结果A指标好于另一个结果，但B指标却可能相反的情况。指标越多这个就越复杂（好在只有三个）。对此，InstructGPT也给出了指导方针：</p> 
<ul><li>对大部分任务，无害和真实比有帮助更加重要。</li><li>然而，如果（a）一个输出比另一个有帮助很多；（b）该输出只是稍微不那么真实 / 无害；（c）该任务似乎不属于「高风险领域」（如贷款申请、医疗、法律咨询等）。这时候更有帮助的得分更高。</li><li>当选择同样有帮助但以不同方式不真实 / 有害时，问自己：哪个输出更可能对用户（在现实世界中受任务影响最大的人）造成伤害？这个输出应该排名较低。如果任务中不清楚这点，则将这些输出标记为并列。</li></ul> 
<p>  对于边界Case的总体指导原则是：<strong>你更愿意从试图帮助你完成此任务的客户助理那里收到哪种输出</strong>？这是一种设身处地的原则，把自己假想为任务提出者，然后问自己期望得到哪种输出。</p> 
<p>  现在看看这些是不是也觉得这一步没那么容易了，它们虽然看起来没那么「技术性」，但要很好地完成却需要优秀的设计能力、宏观把控能力和细节感知力。我更加相信这些细则是自底向上逐步构建起来的，而不是一开始就设想好的。它一定是在实践中不断遇到疑惑，然后经过仔细分析权衡后逐步加入一条条规则，最终逐步构建起来的一整套系统方案。个人觉得这一套东西可能是比数据还要珍贵的财产，它所产生的壁垒只能用时间不断实践来堆积。</p> 
<p>  InstructGPT/ChatGPT相比GPT-3有更强的Zero-Shot能力，Few-Shot很多时候已经不太用的着了，但是Prompt还是需要的，由此还催生了一个新的行当——Prompt工程。不过据OpenAI的CEO<a href="https://www.youtube.com/watch?v=WHoWGNQRXb0" rel="nofollow">所言</a>，过几年Prompt工程也不需要了（可能生成图片时还要一点点），我们要做的就是直接通过自然语言和AI进行交互。我们无法判断他说的会不会真的实现，但有一点可以肯定，AI的门槛必定会进一步降低，过几年可能一个初中生都能通过已有的一些服务创造出不错的AI应用。</p> 
<h3><a id="5_LLM_321"></a>5. LLM</h3> 
<p>  我们正在经历并进入一个新的时代，LLM作为一个外部「最强大脑」未来一定会非常容易被每个人获取，至于用来做什么，Depends Your Imagination。无论哪个行业，相信这都是一个令人振奋的信号，笔者本人就经常激动到夜不能寐。对于这种大变革，我们能做什么呢，我不知道，未来太多可能，但我相信最好的办法就是拥抱它。让我们HuggingLLM，一起创造时代、创造未来。我们相信世界必将会因此而变得更美好。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5b87b507f153e0723a2b3fd61fd2361c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">关于使用PyQt6与PySide6的出现：DLL load failed while importing QtCore: 找不到指定的程序。</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/fd0875e43e5988a19724a5c7337d5d93/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">字段属性（MySQL和Navicat版本比较）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>