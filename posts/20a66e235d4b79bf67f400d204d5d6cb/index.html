<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>牛客网刷题(纯java题型 1~30题) - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="牛客网刷题(纯java题型 1~30题)" />
<meta property="og:description" content="应该是先extend,然后implement
class test extends A implements B { public static void main(String[] args) { } } 复制代码 java中四类八种基本数据类型 整数类型:byte,short,int,long
浮点类型: float,double
逻辑型: boolean
字符类型: char 浏览器根据html中指定的编码格式对参数进行编码,Tomcat根据指定的格式对参数进行解码 ，所以getParameter得到的参数的编码是由客户端和web容器配置共同决定的 重载,指的是@overload
重写,指的是@override
重写override是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。即外壳不变，核心重写！
重载overload,是用在同一函数体中,方法名称不变,方法签名改变 构造函数是不可以使用final修饰的,所以我觉得构造函数不可以是内联函数 (不知道这么说是否正确) 所谓的内联函数,就是函数在被调用的地方直接展开,编译器在调用的时候不用像一般函数那样,参数压栈,返回时参数出栈以及资源释放等,这样提高了程序执行速度,对应java语言中也有一个关键字final来知名那个函数式内联的.内联部已订好,当被指定为内联的方法体很大的时候,展开的开销可能就已经超过了普通函数调用的时间,引入内联反而降低了性能,因此在选择这个关键字的时候需要慎重,不过,在以后高版本的JVM中,在处理内敛的时候做出了优化,他会根据方法的规模来决定是否展开调用 构造函数可以是内联函数 构造函数可以设置默认的参数 构造函数在定义类对象的时候自动执行 FileInputStream,从文件中以字节流读取
FileReader,从文件中以字符流读取
FileWriter,向文件中,写入字符 接口中的变量,默认是public static final
接口中的方法,默认是public abstract Collection类型的集合只能装入Object类型的数据,题中传入的是0,但是会自动装箱为Integer
JVM形成对象后会放入堆中,listlist1和listlist2都指向堆中的同一个对象
instanceof是用来判断对象的类型,也就是对象属于哪个类的实例,因为指向的是同一个对象,所以都为Integer对象,也就是都为true Super super = new Sub(); // 向上转型不需要向值类型转换
Sub sub = (Sub)new Super(); // 向下转型必须要强制类型转换
这道题考察的是多态,对于多态,可以总结为:
1,父类引用指向子类对象
2,父类引用只能调用父类的field和method,不能调用子类的field和method,会报错
3,上面说只能调用父类中的field和method,如果子类中的method覆盖了父类中的method,那么使用父类的引用,调用的将是子类中重写的method,而不是父类中的method; 如果子类field与父类field重名,使用父类的引用,调用field的话,调用的是父类中的field的值
3,子类&#34;覆盖&#34;父类的变量不会报错 getDeclaredMethods(): Returns an array containing {@code Method} objects reflecting all the declared methods of the class or interface represented by this {@code Class} object, including public, protected, default (package) access, and private methods, but excluding inherited methods." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/20a66e235d4b79bf67f400d204d5d6cb/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-07-08T15:02:40+08:00" />
<meta property="article:modified_time" content="2018-07-08T15:02:40+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">牛客网刷题(纯java题型 1~30题)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div class="article-content"> 
 <p></p> 
 <figure> 
  <figcaption></figcaption> 
 </figure> 
 <p></p> 
 <p>应该是先extend,然后implement</p> 
 <pre><code class="hljs bash copyable">class <span class="hljs-built_in">test</span> extends A implements B {
    public static void main(String[] args) {
    }
}
<span class="copy-code-btn">复制代码</span></code></pre> 
 <p></p> 
 <figure> 
  <figcaption></figcaption> 
 </figure> 
  java中四类八种基本数据类型 
 <br> 
 整数类型:byte,short,int,long<br> 浮点类型: float,double<br> 逻辑型: boolean<br> 字符类型: char  
 <p></p> 
 <p></p> 
 <figure> 
  <figcaption></figcaption> 
 </figure>    
 浏览器根据html中指定的编码格式对参数进行编码,Tomcat根据指定的格式对参数进行解码 ，所以getParameter得到的参数的编码是由客户端和web容器配置共同决定的  
 <p></p> 
 <p></p> 
 <figure> 
  <figcaption></figcaption> 
 </figure> 
 重载,指的是@overload<br> 重写,指的是@override<br> 重写override是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。即外壳不变，核心重写！<br> 重载overload,是用在同一函数体中,方法名称不变,方法签名改变 
 <p></p> 
 <h5 class="heading">构造函数是不可以使用final修饰的,所以我觉得构造函数不可以是内联函数 (不知道这么说是否正确)</h5> 
 所谓的内联函数,就是函数在被调用的地方直接展开,编译器在调用的时候不用像一般函数那样,参数压栈,返回时参数出栈以及资源释放等,这样提高了程序执行速度,对应java语言中也有一个关键字final来知名那个函数式内联的.内联部已订好,当被指定为内联的方法体很大的时候,展开的开销可能就已经超过了普通函数调用的时间,引入内联反而降低了性能,因此在选择这个关键字的时候需要慎重,不过,在以后高版本的JVM中,在处理内敛的时候做出了优化,他会根据方法的规模来决定是否展开调用  
  
 <font color="#0000FF">构造函数可以是内联函数 构造函数可以设置默认的参数 构造函数在定义类对象的时候自动执行 </font> 
 <p></p> 
 <figure> 
  <figcaption></figcaption> 
 </figure> 
  FileInputStream,从文件中以字节流读取<br> FileReader,从文件中以字符流读取<br> FileWriter,向文件中,写入字符  
 <p></p> 
 <p></p> 
 <figure> 
  <figcaption></figcaption> 
 </figure> 
  接口中的变量,默认是public static final<br> 接口中的方法,默认是public abstract  
 <p></p> 
 <p></p> 
 <figure> 
  <figcaption></figcaption> 
 </figure> 
  Collection类型的集合只能装入Object类型的数据,题中传入的是0,但是会自动装箱为Integer<br> JVM形成对象后会放入堆中,listlist1和listlist2都指向堆中的同一个对象<br> instanceof是用来判断对象的类型,也就是对象属于哪个类的实例,因为指向的是同一个对象,所以都为Integer对象,也就是都为true  
 <p></p> 
 <p></p> 
 <figure> 
  <figcaption></figcaption> 
 </figure> 
 <p></p> 
 <p></p> 
 <figure> 
  <figcaption></figcaption> 
 </figure> 
  Super super = new Sub(); // 向上转型不需要向值类型转换<br> Sub sub = (Sub)new Super(); // 向下转型必须要强制类型转换<br> 这道题考察的是多态,对于多态,可以总结为:<br> 1,父类引用指向子类对象<br> 2,父类引用只能调用父类的field和method,不能调用子类的field和method,会报错<br> 3,上面说只能调用父类中的field和method,如果子类中的method覆盖了父类中的method,那么使用父类的引用,调用的将是子类中重写的method,而不是父类中的method; 如果子类field与父类field重名,使用父类的引用,调用field的话,调用的是父类中的field的值<br> 3,子类"覆盖"父类的变量不会报错  
 <p></p> 
 <p></p> 
 <figure> 
  <figcaption></figcaption> 
 </figure> 
 <p></p> 
 <p></p> 
 <figure> 
  <figcaption></figcaption> 
 </figure> 
 <p></p> 
 <p></p> 
 <figure> 
  <figcaption></figcaption> 
 </figure> 
 <p></p> 
 <p></p> 
 <figure> 
  <figcaption></figcaption> 
 </figure> 
 <p></p> 
 <p></p> 
 <figure> 
  <figcaption></figcaption> 
 </figure> 
 <p></p> 
  getDeclaredMethods():  
 <p>Returns an array containing {@code Method} objects reflecting all the declared methods of the class or interface represented by this {@code Class} object, including public, protected, default (package) access, and private methods, but excluding inherited methods. 翻译:返回类的所有声明的方法,包括这个类/接口中的方法(public,private,protected,default),但是不包括这个类所继承的超类中的方法 getMethods():<br> Returns an array containing {@code Method} objects reflecting all the public methods of the class or interface represented by this {@code Class} object, including those declared by the class or interface and those inherited from superclasses and superinterfaces.<br> 翻译:返回这个类/接口中的所有public方法,包括这个类/接口的超类/父接口中的public方法<br> 同理: getDeclaredMethods() 和 getFields()</p> 
 <p></p> 
 <figure> 
  <figcaption></figcaption> 
 </figure> 
  补充知识: public class ArrayList<br> extends AbstractList<br> implements List,<br> RandomAccess, 说明ArrayList支持随机访问<br> Cloneable, 说明ArrayList支持克隆<br> java.io.Serializable 说明ArrayList支持序列化 
 <p></p> 
 <p>ArrayList的动态扩容机制:<br></p> 
 <p></p> 
 <figure> 
  <figcaption></figcaption> 
 </figure> 
 <p></p> 
 <p></p> 
 <figure> 
  <figcaption></figcaption> 
 </figure> 
 <p></p> 
 <p></p> 
 <figure> 
  <figcaption></figcaption> 
 </figure> 
 <p></p> 
  ArrayList扩容机制总结:  
 <p>如果是通过无参构造器ArrayList()构造,那么初始大小为0,然后,随着add元素,不断的扩容,新容量 = 旧容量的 * 1.5<br> 例如: 先是size=0 的Arraylist,然后add,扩容为DEFAULT_SIZE = 10 ,然后添加第11个元素的时候,是扩容为15个,添加到16个元素的时候,扩容到22个</p> 
 <p>如果是通过ArrayList(initialSize),则会直接指定数组的大小,不需要扩容</p> 
 <p></p> 
 <figure> 
  <figcaption></figcaption> 
 </figure> 
 <p></p> 
 <p></p> 
 <figure> 
  <figcaption></figcaption> 
 </figure> 
 <p></p> 
 <p style="text-indent:2em;">  ConcurrentHashMap使用segment来分段和管理锁 static class Segment extends ReentrantLock impliments Serializable{ </p> 
 <p>}<br> public class ReentrantLock implements Lock,Serializable</p> 
   
 <p>interface Lock</p> 
 <p></p> 
 <figure> 
  <figcaption></figcaption> 
 </figure> 
  public class HashMap<br> extends AbstractMap<br> implements Map,Cloneable,Serializable  
 <p></p> 
 <p style="text-indent:2em;">  </p> 
 <p>public static List asList( T ... a) {<!-- --><br> return new ArrayList(a);<br> }<br> private static class ArrayList{<!-- --><br> //这个ArrayList为Arrays的内部类<br> } </p> 
 <p></p> 
 <figure> 
  <figcaption></figcaption> 
 </figure> 
 <p></p> 
 <p></p> 
 <figure> 
  <figcaption></figcaption> 
 </figure> 
 <p></p> 
  SimpleDateFormat 是线程不安全的  
 <p></p> 
 <figure> 
  <figcaption></figcaption> 
 </figure> 
  使用JDBC的完整流程:<br> 加载JDBC驱动程序<br> 提供链接URL<br> 创建数据库连接<br> 创建一个Statement<br> 执行SQL语句 处理<br> 关闭JDBC连接  
 <p></p> 
 <p></p> 
 <figure> 
  <figcaption></figcaption> 
 </figure> 
  经过验证,以Stream结尾的都是字节流byte,以Reader,Writer结尾的都是字符流<br> 需要注意的:<br> InputStreamReader:<br> An InputStreamReader is a bridge from byte streams to character streams: It reads bytes and decodes them into characters using a specified {@link java.nio.charset.Charset charset}. The charset that it uses may be specified by name or may be given explicitly, or the platform's default charset may be accepted.<br> InputStreamReader 是字节流通向字符流的桥梁：它使用指定的 charset 读取字节并将其解码为字符。它使用的字符集可以由名称指定或显式给定，或者可以接受平台默认的字符集。<br> OutputStreamReader:<br> An OutputStreamWriter is a bridge from character streams to byte streams:Characters written to it are encoded into bytes using a specified {@link java.nio.charset.Charset charset}. OutputStreamWriter 是字符流通向字节流的桥梁：可使用指定的 charset 将要写入流中的字符编码成字节。它使用的字符集可以由名称指定或显式给定，否则将接受平台默认的字符集。  
 <p></p> 
 <p></p> 
 <figure> 
  <figcaption></figcaption> 
 </figure> 
  考察Statement与PreparedStatement的使用与区别:<br> interface Statement extends Wrapper,AutoCloseable<br> interface PreparedStatement extends Statement<br> Statement是一个接口,用于为一条SQL语句生成执行计划,如果需要执行10条SQL语句,则需要生成十次执行计划<br> PreparedStatement继承自Statement,具有Statement的全部功能,主要用来解决使用Statement多次执行同一SQL语句的效率问题,PreparedStatement使用的是数据库支持预编译的功能,预先将SQL语句进行编译,多次执行同一条SQL语句的时候,只需要将编译好的SQL语句直接执行就可以,提高了效率,同时可以防止SQL注入,提高了安全性<br> 构造PreparedStatement的时候需要传入SQL语句,进行预编译,excute的时候,excute里面不传入SQL<br> 构造Statement的时候不需要传入SQL语句,excute的时候需要传入SQL语句  
 <p></p> 
 <p></p> 
 <figure> 
  <figcaption></figcaption> 
 </figure> 
  Object 类中wait(),notify(),notifyAll()方法的区别:<br> 1)wait() notify(), notifyAll() public final native void wait() throws InterruptedException ;<br> public final native void notify();<br> public final native void notifyAll();<br> 都是native方法,都为final方法, 无法被override<br> 2) 调用某个对象的wait()方法,能够让当前线程阻塞,前提是当前线程必须拥有此对象作为锁,而且obj.wait()方法必须位于synchronized(obj)中 3) 调用某个对象的notify()能够唤醒一个正在等待这个对象的线程,如果有多个县城都在等待此对象,则从中唤醒一个<br> 4) 调用notifyAll()能够唤醒所有正在等待这个对象的monitor的线程<br> 为什么这三个不是Thread中的方法,而是Object类中的方法?<br> 当然由于Thread也是Object,所以Thread也可以调用此方法<br> 原因: 由于每一个对象都可以拥有锁,所以让当前线程等待某个对象的锁,当然需要通过这个对象来操作了,而不是用当前线程来操作,因为当前线程可能会等待多个锁,如果通过线程来操作,就很复杂<br> 上面已经提到,如果条用某个对象的wait()方法,当前线程必须拥有这个对象的锁,因此调用wait()方法必须在synchronized块或者synchronized方法中进行<br> 调用某个对象的wait()方法,相当于让当前线程交出此对象的锁,然后进入等待状态,等待后续再次获得此对象的锁(Thread中的sleep方法使当前线程暂停一段时间,从而让其他线程有机会继续执行,但是在这期间sleep不是访对象锁)<br> notify()方法能够唤醒一个正在等待该对象的锁的线程,如果有多个线程,只能唤醒其中的一个,具体唤醒那个线程不确定<br> 调用对象的notify()方法,当前线程也必须用用这个对象的synchronized,因此调用notify()方法必须在synchronized()中执行<br> Condition是在jdk 1.5中出现的,用来替代传统的Object的wait,notify()和notifyAll(),实现线程间的通信,使用Contion的await(),singal()这种方式来实现线程的协作更加安全和高效,阻塞队列使用的是Condition来模拟线程间的协作<br> Condition是一个接口<br> public interface Condition { await();<br> signal();<br> signalAll();<br> } Condition依赖于Lock接口,生成一个Condition的基本代码是lock.newCondition();<br> 调用Condition的await()和signal()方法,必须都在lock.lock()的保护之内<br> wait()对应于await();<br> notify()对应于signal;<br> notifyAll()对应于signalAll();<br> 
 <p></p> 
 <p></p> 
 <figure> 
  <figcaption></figcaption> 
 </figure> 
 <p></p> 
 <p></p> 
 <figure> 
  <figcaption></figcaption> 
 </figure> 
  ThreadLocal里面可以放一个值 ThreadLocal类用于创建一个线程本地变量<br> Thread中有一个成员变量ThreadLocals,该变量的类型是ThreadLocalMap,也就是一个Map,他的键是threadLocal,值为变量的副本.通过ThreadLocal的get()方法可以获取到该线程变量对应的value<br> 
 <p></p> 
 <p></p> 
 <figure> 
  <figcaption></figcaption> 
 </figure> 
 <p></p> 
 <p></p> 
 <figure> 
  <figcaption></figcaption> 
 </figure> 
 <p></p> 
 <p></p> 
 <figure> 
  <figcaption></figcaption> 
 </figure> 
  不论是静态内部类,还是非静态内部类,都是外部类的一个属性,所以,对于非静态内部类,需要使用InstanceObject().new InnerClass(),对于静态内部类,可以使用new OuterClass.staticInnerClass()的方式来进行创建<br> 无论是静态内部类,还是非静态内部类,都需要使用OuterClass.innerClassName来进行引用 
 <p></p> 
</div> 
<p>转载于:https://juejin.im/post/5b40c827f265da0f6012f11b</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/455315a8a458b7a7020070e46d02cf87/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Internal server error 500 问题解决思路</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e5700f2cefdc56d45dd4a11680dfcab1/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">PQ(product quantization) 算法---(一)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>