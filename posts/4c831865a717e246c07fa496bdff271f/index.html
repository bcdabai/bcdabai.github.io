<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Dockerfile创建镜像 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Dockerfile创建镜像" />
<meta property="og:description" content="一、Docker镜像的创建 创建镜像有三种方法，分别为【基于已有镜像创建】、【基于本地模板创建】以及【基于Dockerfile创建】。
1.1 基于现有镜像创建 （1）首先启动一个镜像，在容器里做修改 docker run -it centos:7 /bin/bash #启动容器 ​ yum install -y epel-release #安装epel源 yum install -y nginx #安装nginx yum install net-tools #安装tools工具 nginx #启动服务 netstat -natp |grep 80 #查看端口是否开启 ​ docker ps -a #查看容器ID ​ （2）然后将修改后的容器提交为新的镜像，需要使用该容器的ID号创建新镜像 docker commit -m &#34;new nginx&#34; -a &#34;yuji&#34; c7f4bc905c29 nginx:centos #常用选项: -m 指定说明信息; -a 指定作者信息; -p 生成过程中停止容器的运行。 c7f4bc905c29 原容器ID。 nginx:centos 生成新的镜像名称。 ​ docker images #查看生成的新镜像 docker run -itd nginx:centos bash #使用新的镜像创建容器 docker ps -a #查看容器状态 docker exec -it ae8e40e434fe bash #进入容器 nginx #启动nginx服务 netstat -natp |grep 80 #查看80端口是否开启 1." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/4c831865a717e246c07fa496bdff271f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-06-12T08:18:32+08:00" />
<meta property="article:modified_time" content="2023-06-12T08:18:32+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Dockerfile创建镜像</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>一、Docker镜像的创建</h2> 
<p>创建镜像有三种方法，分别为【基于已有镜像创建】、【基于本地模板创建】以及【基于Dockerfile创建】。</p> 
<h3>1.1 基于现有镜像创建</h3> 
<pre><code class="hljs"> （1）首先启动一个镜像，在容器里做修改
 docker run -it centos:7 /bin/bash     #启动容器
 ​
 yum install -y epel-release  #安装epel源
 yum install -y nginx         #安装nginx
 yum install net-tools        #安装tools工具
 nginx                        #启动服务
 netstat -natp |grep 80       #查看端口是否开启
 ​
 docker ps -a   #查看容器ID
 ​
 （2）然后将修改后的容器提交为新的镜像，需要使用该容器的ID号创建新镜像
 docker commit -m "new nginx" -a "yuji" c7f4bc905c29 nginx:centos
 #常用选项:
 -m 指定说明信息;
 -a 指定作者信息;
 -p 生成过程中停止容器的运行。
 c7f4bc905c29  原容器ID。
 nginx:centos  生成新的镜像名称。
 ​
 docker images    #查看生成的新镜像
 docker run -itd nginx:centos bash          #使用新的镜像创建容器
 docker ps -a                                #查看容器状态
 docker exec -it ae8e40e434fe bash           #进入容器
 nginx                                       #启动nginx服务
 netstat -natp |grep 80                      #查看80端口是否开启
</code></pre> 
<h3>1.2 基于本地模板创建</h3> 
<p>通过导入操作系统模板文件可以生成镜像，模板可以从OPENVZ 开源项目下载，下载地址为：<a href="https://link.juejin.cn/?target=http%3A%2F%2Fopenvz.org%2F" rel="nofollow" title="openvz.org/">openvz.org/</a> Download/template/precreated</p> 
<pre><code class="hljs"> #模板里面就是使用docker export 命令导出的容器文件
 ​
 #下载模板
 wget http://download.openvz.org/template/precreated/debian-7.0-x86-minimal.tar.gz
 ​
 #导入为镜像，两种方法
 cat debian-7.0-x86-minimal.tar.gz | docker import - debian:test  #方法一
  
 docker import debian-7.0-x86-minimal.tar.gz -- debian:test  #方法二
 ​
 #查看镜像
 docker images
 ​
 #使用导入的镜像创建容器
 docker run -itd debian:test bash
 docker ps -a
</code></pre> 
<h3>1.3 基于Dockerfile 创建</h3> 
<h4>1.3.1 联合文件系统(UnionFS )</h4> 
<p><strong>UnionFS(联合文件系统)：</strong> Union文件系统(UnionFS)是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下。AUFS、overlayFS 及Devicemapper 都是一种UnionFS 。</p> 
<p>Union文件系统是Docker镜像的基础。镜像可以通过分层来进行继承，基于基础镜像(没有父镜像)，可以制作各种具体的应用镜像。</p> 
<p><strong>特性：</strong> 一次同时加载多个文件系统，但从外面看起来，只能看到一一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录。</p> 
<p>我们下载的时候看到的一层层的就是联合文件系统。</p> 
<p><img alt="" src="https://images2.imgbox.com/8d/ce/PoFICUda_o.png"></p> 
<p> </p> 
<h4>1.3.2 镜像加载原理</h4> 
<p>Docker的镜像实际上由一层一层的文件系统组成，这种层级的文件系统就是UnionFS。</p> 
<p>bootfs主要包含bootloader和kernel，bootloader主 要是引导加载kernel，Linux刚启 动时会加载bootfs文件系统。</p> 
<p>在Docker镜像的最底层是bootfs，这一层 与我们典型的Linux/Unix系统是一样的， 包含boot加载器和内核。当boot加载完成之 后整个内核就都在内存中了，此时内存的使用权已由bootfs转交给内核，此时系统也会卸载bootfs。</p> 
<p>rootfs，在bootfs之 上。包含的就是典型Linux系统中的/dev、/proc、/bin、/etc等标准目录和文件。rootfs就是各种不同的操作系统发行版，比如Ubuntu, Centos等。</p> 
<ul><li>bootfs就是内核引导器（引导加载内核）和内核。</li><li>rootfs是n多个基础镜像（提供基础操作环境）和应用镜像叠加在一起的只读层。</li><li>运行的容器实例会在rootfs之上添加一个可读可写层。</li></ul> 
<p><img alt="" src="https://images2.imgbox.com/8c/cb/qPfTUAaa_o.png"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/fc/de/VzY1BCNB_o.png"> </p> 
<p> </p> 
<h4>1.3.3 为什么Docker里的centos的大小才200M？</h4> 
<p>因为对于精简的OS，rootfs可以很小， 只需要包含最基本的命令、工具和程序库就可以了，因为底层直接用宿主机的kernel，自己只需要提供rootfs就可以了。由此可见对于不同的linux发行版，bootfs基本是一 致的， rootfs会 有差别，因此不同的发行版可以公用bootfs。</p> 
<p>大部分镜像是通用的，但如果专门基于某个版本创建的镜像，在其他版本的操作系统中运行可能会有问题。</p> 
<h4>1.3.4 Dockerfile</h4> 
<p>Docker镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数(如匿名卷、环境变量、用户等)。镜像不包含任何动态数据，其内容在构建之后也不会被改变</p> 
<p>镜像的定制实际上就是定制每一层所添加的配置、文件。如果我们可以把每一层修改 安装、构建、操作的命令都写入一个脚本， 用这个脚本来构建、定制镜像，那么镜像构建透明性的问题、体积的问题就都会解决。这个脚本就是Dockerfile。</p> 
<p>我们需要定制首己额外的需求时，只需在Docketlle上添加或者修改指令，重新生成image 即可，省去了敲命令的麻烦。就是描述该层应当如何构建。有了Dockerfile，当我们需要定制自己额外的需求时，只需在Dockerfile上添加或者修改指令，重新生成image即可，省去了敲命令的麻烦。</p> 
<p>除了手动生成Docker镜像之外，可以使用bockerfile自动生成镜像。Dockerfile 是由多条的指令组成的文件，其中每条指令对应Linux中的一条命令，Docker程序将读取Dockerfile中的指令生成指定镜像。</p> 
<p><strong>Dockerfile结构大致分为四个部分：基础镜像信息、维护者信息、镜像操作指令和容器启动时执行指令。Dockerfile每行支持一 条指令， 每条指令可携带多个参数，支持使用以“#“号开头的注释。</strong></p> 
<h4>1.3.5 Docker镜像结构的分层</h4> 
<p>镜像不是一个单一的文件，而是有多层构成。容器其实是在镜像的最上面加了一层读写层，在运行容器里做的任何文件改动，都会写到这个读写层。如果删除了容器，也就删除了其最上面的读写层，文件改动也就丢失了。Docker使用存储驱动管理镜像每层内容及可读写层的容器层。</p> 
<p>（1）Dockerfile中的每个指令都会创建一个新的镜像层；</p> 
<p>（2）镜像层将被缓存和复用；</p> 
<p>（3）当Dockerfile的指令修改了，复制的文件变化了，或者构建镜像时指定的变量不同了，对应的镜像层缓存就会失效；</p> 
<p>（4）某一层的镜像缓存失效，它之后的镜像层缓存都会失效；</p> 
<p>（5）镜像层是不可变的，如果在某一层中添加一个文件，然后在下一层中删除它，则镜像中依然会包含该文件，只是这个文件在Docker 容器中不可见了。</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/b3/07/o4NLfOV2_o.png"></p> 
<p><strong>bootfs：</strong> bootfs加载器+内核，容器都是共享内核的，所以都有相同的bootfs。</p> 
<p><strong>rootfs只读层：</strong> rootfs可以有多层，对外表现看起来就是一个整体。</p> 
<p>使用镜像运行一个容器实例时，就会在rootfs只读层上挂载一层可读可写层。</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/8a/08/gtp4gajY_o.png"> </p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/78/9c/ca8F3SqC_o.jpg"> </p> 
<h2>二、Dockerfile 操作命令的指令</h2> 
<p><strong>Dockerﬁle简介：</strong></p> 
<p>Dockerﬁle其实就是我们用来构建Docker镜像的源码，当然这不是所谓的编程源码，而是一些命令的组合，只要理解它的逻辑和语法格式，就可以编写Dockerﬁle了。</p> 
<p>简单点说，Dockerﬁle的作用：它可以让用户个性化定制Docker镜像。因为工作环境中的需求各式各样，网络上的镜像很难满足实际的需求。</p> 
<p><strong>Dockerﬁle常见命令：</strong></p> 
<table><thead><tr><th><strong>命令</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td>FROM image_name:tag</td><td>声明基础镜像</td></tr><tr><td>MAINTAINER user_name</td><td>声明镜像的作者</td></tr><tr><td>ENV key value</td><td>设置环境变量 (可以写多条)</td></tr><tr><td>RUN command</td><td>编译镜像时运行的脚本(可以写多条)</td></tr><tr><td>CMD</td><td>设置容器的启动命令</td></tr><tr><td>ENTRYPOINT</td><td>设置容器的入口程序</td></tr><tr><td>ADD source_dir/ﬁle dest_dir/ﬁle</td><td>将宿主机的文件复制到镜像内，如果是一个压缩文件，将会在复制后自动解压。支持URL路径下载源文件，但下载方式不能自动解压。</td></tr><tr><td>COPY source_dir/ﬁle dest_dir/ﬁle</td><td>和ADD相似，将宿主机的文件复制到镜像内，但是如果有压缩文件并不能解压。不支持URL路径下载。</td></tr><tr><td>WORKDIR path_dir</td><td>设置工作目录</td></tr><tr><td>ARG</td><td>设置编译镜像时加入的参数</td></tr><tr><td>VOLUMN</td><td>设置容器的挂载卷</td></tr></tbody></table> 
<h3>2.1 FROM 镜像</h3> 
<p>指定新镜像所基于的基础镜像，第一条指令必须为FROM指令，每创建一-个镜像就需要一条FROM指令。</p> 
<h3>2.2 MAINTAINER 名字</h3> 
<p>说明新镜像的维护人信息</p> 
<h3>2.3 RUN 命令</h3> 
<p>在所基于的镜像上执行命令，并提交到新的镜像中.</p> 
<p>尽量减少run命令的条数。</p> 
<ul><li>当命令较长时，可以使用 \ 来换行；</li><li>多条命令可以使用 ; 或 &amp;&amp; 合并成一条命令，减少镜像的层数。</li></ul> 
<h3>2.4 ENTRYPOINT</h3> 
<p><code>ENTRYPOINT ["要运行的程序"，"参数1"，"参数2"]</code></p> 
<p><strong>设定容器启动时第一个运行的命令及其参数。</strong></p> 
<p>可以通过使用命令 <code>docker run --entrypoint</code> 来覆盖镜像中的ENTRYPOINT指令的内容。</p> 
<pre><code class="hljs"> 两种格式：
 ​
 exec格式（数值格式）：ENTRYPOINT [“命令”，“选项”，“参数”]
 ​
 shell格式：ENTRYPOINT 命令 选项 参数</code></pre> 
<p>前面四个命令就可以创建成一个粗略的镜像。 </p> 
<h3>2.5 CMD</h3> 
<p><code>CMD ["要运行的程序"，"参数1"，"参数2"]</code></p> 
<p><strong>启动容器时默认执行的命令或者脚本</strong>，Dockerfile只能有一条CMD命令。如果指定多条命令，只执行最后一 条命令。</p> 
<p>如果在docker run时指定了命令或者镜像中有ENTRYPOINT，那么CMD就会被覆盖。</p> 
<p>CMD 可以为ENTRYPOINT 指令提供默认参数。</p> 
<pre><code class="hljs"> 两种格式：
 ​
 exec形式：CMD [“要运行的程序”，“参数1”, “参数2”]
 ​
 shell形式: CMD 命令 参数1 参数2</code></pre> 
<p><strong>ENTRYPOINT和CMD共存的情形：</strong> ENTRYPOIN指定命令，CMD传参</p> 
<p><strong>容器运行时的优先级：</strong></p> 
<p>docker run --entrypoint &gt; Dockerfile ENTRYPOINT &gt; docker run命令&gt; Dockerfile CMD</p> 
<h4>ENTRYPOINT和CMD的区别：</h4> 
<ol><li>ENTRYPOINT设定容器启动时第一个运行的命令；CMD是启动容器时默认执行的命令，如果指定多条CMD命令，只执行最后一 条命令。</li></ol> 
<ol><li>如果在docker run时指定了命令或者镜像中有ENTRYPOINT，那么CMD就会被覆盖，并且会将CMD中的命令作为参数传给ENTRYPOINT。</li></ol> 
<ol><li>CMD可以为ENTRYPOINT进行传参。</li></ol> 
<h3>2.6 EXPOSE 端口号</h3> 
<p>指定新镜像加载到Docker 时要开启的端口。</p> 
<p>用于暴露端口，否则即使做了端口映射，外部也找不到。</p> 
<h3>2.7 ENV</h3> 
<p><code>ENV 环境变量 变量值</code></p> 
<p>设置一个环境变量的值，会被后面的RUN使用。</p> 
<h3>2.8 ADD</h3> 
<p><code>ADD 源文件/目录 目标文件/目录</code></p> 
<p>将源文件复制到镜像的指定路径中，源文件要与 Dockerfile 位于相同目录中，或者是一个URL。（URL路径，在线路径）</p> 
<p><strong>注意事项：</strong></p> 
<p>1、  如果源路径是个文件，且目标路径是以 / 结尾， 则docker会把目标路径当作一个目录，会把源文件拷贝到该目录下。  如果目标路径不存在，则会自动创建目标路径。  ​  </p> 
<p>2、  如果源路径是个文件，且目标路径是不以/结尾，则docker会把目标路径当作一个文件。  如果目标路径不存在，会以目标路径为名创建一个文件，内容同源文件。  如果目标文件是个存在的文件，会用源文件覆盖它，当然只是内容覆盖，文件名还是目标文件名。  如果目标文件实际是个存在的目录，则会源文件拷贝到该目录下。注意， 这种情况下，最好显示的以/结尾，以避免混淆。</p> 
<p>3、  如果源路径是个目录，且目标路径不存在，则docker会自动以目标路径创建一个目录，把源路径目录下的文件拷贝进来。  如果目标路径是个已经存在的目录，则docker 会把源路径目录下的文件拷贝到该目录下。  ​  </p> 
<p>4、  如果源文件是个归档文件，则docker会自动帮解压。（解压后复制源目录到镜像中的目录）  URL下载和解压特性不能一起使用。任何压缩文件通过URL拷贝，都不会自动解压。  （不支持下载和解压一起使用，下载就不会解压。即只解压本地压缩包，不会解压下载的压缩包）</p> 
<ul><li><strong>ADD 的优点：</strong> 在执行 &lt;源文件&gt; 为 tar 压缩文件的话，压缩格式为 gzip、bzip2 以及 xz 的情况下，会自动复制并解压到 &lt;目标路径&gt;。</li><li><strong>ADD 的缺点：</strong> 在不解压的前提下，无法复制 tar 压缩文件。会令镜像构建缓存失效，从而可能会令镜像构建变得比较缓慢。具体是否使用，可以根据是否需要自动解压来决定。</li></ul> 
<h3>2.9 COPY</h3> 
<p><code>COPY 源文件/目录 目标文件/目录</code></p> 
<p>只复制本地主机上的文件/目录复制到目标地点，源文件/目录要与Dockerfile在相同的目录中。</p> 
<p></p> 
<p><strong>ADD和COPY比较：</strong></p> 
<p><strong>1、共同点：</strong></p> 
<p>ADD和COPY都可以复制本地文件到镜像中。</p> 
<p><strong>2、区别：</strong></p> 
<p>ADD：如果是一个压缩文件，ADD会在复制后自动解压。且支持URL路径下载源文件，但URL下载和解压特性不能一起使用，任何压缩文件通过URL拷贝，都不会自动解压。</p> 
<p>COPY：如果是压缩文件，COPY并不能解压。且COPY只能复制本地文件，不支持URL路径拷贝。</p> 
<h3>2.10 VOLUME ["目录"]</h3> 
<p>在容器中创建一个挂载点（即创建数据卷）。</p> 
<h3>2.11 USER 用户名/UID</h3> 
<p>指定运行容器时的用户。（用于切换用户）</p> 
<h3>2.12 WORKDIR 路径</h3> 
<p>为后续的RUN、CMD、ENTRYPOINT 指定工作目录。（用于切换容器中的目录）</p> 
<p>CMD 可以为ENTRYPOINT 指令提供默认参数。</p> 
<pre><code class="hljs"> workdir /opt  #切换镜像层
 ​
 run cd /opt   #会添加镜像层</code></pre> 
<h3>2.13 ONBUILD 命令</h3> 
<p>指定所生成的镜像作为一个基础镜像时所要运行的命令。</p> 
<p>当在一个Dockerfile文件中加上ONBUILD指令，该指令对利用该Dockerfile构建镜像（比如为A镜像）不会产生实质性影响。</p> 
<p>但是当编写一个新的Dockerfile文件来基于A镜像构建一个镜像 （比如为B镜像）时，这时构造A镜像的Dockerfile文件中的ONBUILD指令就生效了，在构建B镜像的过程中，首先会执行ONBUILD指令指定的指令，然后才会执行其它指令。</p> 
<p>（即加私货，这个命令不是给我用的，是给其他镜像用的）</p> 
<h3>2.14 ARG</h3> 
<p>设置编译镜像时加入的参数。</p> 
<p>ARG指令，可以引用在docker build构建镜像时指定的参数，即达到引用参数的效果。</p> 
<p><strong>使用ENV指令定义的环境变量始终会覆盖同名的ARG指令。</strong></p> 
<pre><code class="hljs"> ARG CONT_IMG_VER      #Dockfile中指定变量名 
 ​
 ENV CONT_IMG_VER=v1.0.0 
 ​
 RUN echo $CONT_IMG_VER  #AEG和ENV定义的变量名，不要重复，不然最后echo的是ENV定义的值
 ​
 docker build --build-arg CONT_IMG_VER=v2.0 .     #构建镜像时传入变量值
 ​
 #因为ARG和ENV定义的变量名重复了，ENV指令定义的环境变量始终会覆盖同名的ARG指令，所以最后输出的是ENV定义的值。
</code></pre> 
<h3>2.15 创建镜像</h3> 
<p>编写完成Dockerfile之后，可以通过 <code>docker build</code> 命令来创建镜像。</p> 
<p>基本的格式为 <code>docker build [选项] 路径</code>，该命令将读取指定路径下（包括子目录）的Dockerfile，并将该路径下所有内容发送给Docker服务端，由服务端来创建镜像。因此一般建议放置Dockerfile的目录为空目录。</p> 
<p>另外，可以通过.dockerignore文件（每一行添加一条匹配模式）来让Docker忽略路径下的目录和文件。</p> 
<p>要指定镜像的标签信息，可以通过-t选项</p> 
<p><strong>在编写Dockerfile 时，有严格的格式需要遵循：</strong></p> 
<ul><li>第一行必须使用FROM指令指明所基于的镜像名称；</li><li>之后使用MAINTAINER 指令说明维护该镜像的用户信息；</li><li>然后是镜像操作相关指令，如RUN指令/EXPOSE/ADD/ENV/ARG等等。每运行一条指令，都会给基础镜像添加新的一层。（多条命令可以使用 ; 或 &amp;&amp; 合并成一条命令，减少镜像的层数）</li><li>最后使用CMD或者ENTRYPOINT指令指定启动容器时要运行的命令操作。</li></ul> 
<h2></h2> 
<h2>三、Dockerfile案例实战</h2> 
<h3>3.1 构建Apache镜像</h3> 
<pre><code class="hljs"> #（1）建立工作目录
 mkdir /opt/apache
 cd /opt/apache
 ​
 #（2）准备Dockerfile文件
 vim Dockerfile
 #基于的基础镜像
 FROM centos:7
 #维护镜像的用户信息
 MAINTAINER this is apache image &lt;zy&gt;
 #镜像操作指令安装apache软件
 RUN yum -y install httpd
 #开启80端口
 EXPOSE 80
 #复制网站首页文件
 ADD index.html /var/www/html/
 #指定启动容器时第一个运行的命令，前台运行apache
 //方法一:
 #将执行脚本复制到镜像中
 ADD run.sh /run.sh
 RUN chmod 755 /run.sh
 #启动容器时执行脚本
 CMD ["/run.sh"]
 ​
 //方法二:
 ENTRYPOINT ["/usr/sbin/apachectl"]
 CMD ["-D", "FOREGROUND"]     #FOREGROUND前台运行
 #默认情况下apache是在后台运行需要-D指定FOREGROUND表示前台运行否则执行完第一条命令会停止镜像
 ​
 ​
 #（3）准备执行脚本。使用方法一的情况下需要准备执行脚本，使用方法二可跳过此步骤。
 vim run.sh
 #!/bin/bash
 #清理httpd的缓存
 rm -rf /run/httpd/*
 #指定为前台运行
 /usr/sbin/apachectl -D FOREGROUND
 #因为Docker容器仅在它的1号进程(PID为1)运行时，会保持运行。如果1号进程退出了，Docker容器也就退出了。
 ​
 #（4）准备网站页面
 echo "this is apache web" &gt; index.html
 ​
 #（5）生成镜像（构建镜像）
 docker build -t httpd:centos .   #注意别忘了末尾有"."
 ​
 #（6）使用新镜像运行容器
 docker run -d -p 1314:80 httpd:centos   #指定映射端口1314
 ​
 #使用宿主机IP和1314端口，测试网页访问
 http://192.168.126.27:1314/
</code></pre> 
<h2></h2> 
<h2>总结：</h2> 
<h3>1、如何把镜像体积给缩小？</h3> 
<ol><li>基础镜像尽量使用轻量级最小化的镜像。</li><li>Dockerfile中尽量把RUN指令合并在一起，减少镜像的层数（因为每一个RUN指令就是一个镜像层）。</li><li>多级构建（拿Dockerfile构建好的镜像再构建一次）。FROM 镜像 AS 别名    COPY --FROM 别名</li><li>构建镜像时最后添加清空系统或应用程序的缓存的命令</li></ol> 
<h3>2、使用Dockerfile构建镜像分为几个步骤？</h3> 
<p>Dockerfile结构大致分为四个部分：基础镜像信息（用from指定）、维护者信息（maintainer、镜像操作指令和容器启动时执行指令。</p> 
<ol><li>第一行必须使用FROM指令指明所基于的镜像名称；</li><li>之后使用MAINTAINER 指令说明维护该镜像的用户信息；</li><li>然后是镜像操作相关指令，如RUN指令/EXPOSE/ADD/ENV/ARG等等。每运行一条指令，都会给基础镜像添加新的一层。（多条命令可以使用 ; 或 &amp;&amp; 合并成一条命令，减少镜像的层数）</li><li>最后使用CMD或者ENTRYPOINT指令指定启动容器时要运行的命令操作。</li></ol>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/db13b89dbd60892c3b9c5e6aeaf8631c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Java NIO学习笔记（堆外内存之 DirectByteBuffer 详解）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3939fa8a534dc10a3c657870ae1a8202/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Beyond Compare4 提示错误“这个授权密钥已被吊销”的解决办法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>