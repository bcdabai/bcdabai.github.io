<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【C语言进阶】最常用的库函数大全——从入门到精通 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【C语言进阶】最常用的库函数大全——从入门到精通" />
<meta property="og:description" content="目录 前言：
一.字符串函数
1.strlen——求字符串长度
strlen
2.长度不受限制的字符串函数
a.strcpy——字符串拷贝
strcpy
b.strcat——追加字符串
strcat
c.strcmp——字符串比较
strcmp
3.长度受限制的字符串函数——strncpy,strncat,strncmp
为什么会出现这些函数呢？
strncpy函数：
strncpy
strncat函数
strncat
strncmp函数：
strncmp
4.字符串查找
a.strstr——判断是否为子字符串
strstr
b.strtok——一个奇怪的函数
strtok
c.strerror——错误信息查找
strerror
perror
上面是字符串相关的函数，下面是一些字符分类的函数：
​编辑 字符转换函数：
二.内存函数
1.内存拷贝函数
a.memcpy
b.memmove
2.内存填充函数——memset
3.内存比较函数——memcmp
总结：
博客主页：张栩睿的博客主页
欢迎关注：点赞&#43;收藏&#43;留言
系列专栏：c语言学习
家人们写博客真的很花时间的，你们的点赞和关注对我真的很重要，希望各位路过的朋友们能多多点赞并关注我，我会随时互关的，欢迎你们的私信提问，也期待你们的转发！
希望大家关注我，你们将会看到更多精彩的内容！！！
前言： C语言中对字符和字符串的处理很是频繁，但是C语言本身是没有字符串类型的，字符串通常放在 常量字符串 中或者 字符数组中。 字符串常量 适用于那些对它不做修改的字符串函数。
以下的函数都需要引用头文件&lt;string.h&gt;
一.字符串函数 1.strlen——求字符串长度 strlen 函数原型：
函数作用：
字符串以&#39;\0&#39;作为结束标志，strlen函数返回值是在字符串中&#39;\0&#39;前面出现的字符个数（不包含&#39;\0&#39;）参数是一个字符指针变量参数指向的字符串必须要以&#39;\0&#39;结束，否则计算出的长度是随机值注意函数的返回值为size_t，是无符号的 函数注意事项：
因为返回值是size_t，所以就要避免出现下图这样的代码：strlen（“abc”）算出的结果是3， strlen(&#34;abcde&#34;)算出的结果是5，可能想着3-5得到-2，实际上并不是这样的，这里算出的3和5都是无符号整型，算出的-2也是一个无符号整型，-2在内存中以补码的形式存储，从无符号整型的视角看去，这串补码就表示一个很大的正数。
3种模拟的方法：
递归：
递归 int my_strlen1(const char* str) { assert(str !" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/ecc21ffc0dd865e95ab09fad7219b5e0/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-01-26T09:24:11+08:00" />
<meta property="article:modified_time" content="2023-01-26T09:24:11+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【C语言进阶】最常用的库函数大全——从入门到精通</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3 id="%E4%B8%80.%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0(%E4%BD%BF%E7%94%A8%E9%83%BD%E9%9C%80%E8%A6%81%E5%8C%85%E5%90%ABstring.h)1.strlen%E2%80%94%E2%80%94%E6%B1%82%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%95%BF%E5%BA%A62.%E9%95%BF%E5%BA%A6%E4%B8%8D%E5%8F%97%E9%99%90%E5%88%B6%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0a.strcpy%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%B7%E8%B4%9Db.strcat%E2%80%94%E2%80%94%E8%BF%BD%E5%8A%A0%E5%AD%97%E7%AC%A6%E4%B8%B2c.strcmp%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%AF%94%E8%BE%833.%E9%95%BF%E5%BA%A6%E5%8F%97%E9%99%90%E5%88%B6%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0%E2%80%94%E2%80%94strncopy%2Cstrncat%2Cstrncmp4.%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9F%A5%E6%89%BEa.strstr%E2%80%94%E2%80%94%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E4%B8%BA%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2b.strtok%E2%80%94%E2%80%94%E4%B8%80%E4%B8%AA%E5%A5%87%E6%80%AA%E7%9A%84%E5%87%BD%E6%95%B0c.%E9%94%99%E8%AF%AF%E4%BF%A1%E6%81%AF%E6%9F%A5%E6%89%BE%E2%80%94%E2%80%94strerror%E4%BA%8C.%E5%86%85%E5%AD%98%E5%87%BD%E6%95%B0%EF%BC%88%E4%B9%9F%E9%9C%80%E8%A6%81%E5%8C%85%E5%90%ABstring.h%EF%BC%891.%E5%86%85%E5%AD%98%E6%8B%B7%E8%B4%9D%E5%87%BD%E6%95%B0%E2%80%94%E2%80%94-toc" style="margin-left:40px;"><strong>目录</strong></h3> 
<p id="%E5%89%8D%E8%A8%80%EF%BC%9A-toc" style="margin-left:0px;"><a href="#%E5%89%8D%E8%A8%80%EF%BC%9A" rel="nofollow">前言：</a></p> 
<p id="%E4%B8%80.%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0-toc" style="margin-left:0px;"><a href="#%E4%B8%80.%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0" rel="nofollow">一.字符串函数</a></p> 
<p id="1.strlen%E2%80%94%E2%80%94%E6%B1%82%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%95%BF%E5%BA%A6-toc" style="margin-left:40px;"><a href="#1.strlen%E2%80%94%E2%80%94%E6%B1%82%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%95%BF%E5%BA%A6" rel="nofollow">1.strlen——求字符串长度</a></p> 
<p id="strlen-toc" style="margin-left:80px;"><a href="#strlen" rel="nofollow">strlen</a></p> 
<p id="2.%E9%95%BF%E5%BA%A6%E4%B8%8D%E5%8F%97%E9%99%90%E5%88%B6%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0-toc" style="margin-left:0px;"><a href="#2.%E9%95%BF%E5%BA%A6%E4%B8%8D%E5%8F%97%E9%99%90%E5%88%B6%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0" rel="nofollow">2.长度不受限制的字符串函数</a></p> 
<p id="a.strcpy%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%B7%E8%B4%9D-toc" style="margin-left:80px;"><a href="#a.strcpy%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%B7%E8%B4%9D" rel="nofollow">a.strcpy——字符串拷贝</a></p> 
<p id="strcpy-toc" style="margin-left:80px;"><a href="#strcpy" rel="nofollow">strcpy</a></p> 
<p id="%C2%A0b.strcat%E2%80%94%E2%80%94%E8%BF%BD%E5%8A%A0%E5%AD%97%E7%AC%A6%E4%B8%B2-toc" style="margin-left:80px;"><a href="#%C2%A0b.strcat%E2%80%94%E2%80%94%E8%BF%BD%E5%8A%A0%E5%AD%97%E7%AC%A6%E4%B8%B2" rel="nofollow"> b.strcat——追加字符串</a></p> 
<p id="strcat-toc" style="margin-left:80px;"><a href="#strcat" rel="nofollow">strcat</a></p> 
<p id="%C2%A0c.strcmp%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%AF%94%E8%BE%83-toc" style="margin-left:80px;"><a href="#%C2%A0c.strcmp%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%AF%94%E8%BE%83" rel="nofollow"> c.strcmp——字符串比较</a></p> 
<p id="strcmp-toc" style="margin-left:80px;"><a href="#strcmp" rel="nofollow">strcmp</a></p> 
<p id="3.%E9%95%BF%E5%BA%A6%E5%8F%97%E9%99%90%E5%88%B6%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0%E2%80%94%E2%80%94strncpy%2Cstrncat%2Cstrncmp-toc" style="margin-left:0px;"><a href="#3.%E9%95%BF%E5%BA%A6%E5%8F%97%E9%99%90%E5%88%B6%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0%E2%80%94%E2%80%94strncpy%2Cstrncat%2Cstrncmp" rel="nofollow">3.长度受限制的字符串函数——strncpy,strncat,strncmp</a></p> 
<p id="%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%87%BA%E7%8E%B0%E8%BF%99%E4%BA%9B%E5%87%BD%E6%95%B0%E5%91%A2%EF%BC%9F-toc" style="margin-left:80px;"><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%87%BA%E7%8E%B0%E8%BF%99%E4%BA%9B%E5%87%BD%E6%95%B0%E5%91%A2%EF%BC%9F" rel="nofollow">为什么会出现这些函数呢？</a></p> 
<p id="strncpy%E5%87%BD%E6%95%B0%EF%BC%9A-toc" style="margin-left:40px;"><a href="#strncpy%E5%87%BD%E6%95%B0%EF%BC%9A" rel="nofollow">strncpy函数：</a></p> 
<p id="strncpy-toc" style="margin-left:80px;"><a href="#strncpy" rel="nofollow">strncpy</a></p> 
<p id="strncat%E5%87%BD%E6%95%B0-toc" style="margin-left:40px;"><a href="#strncat%E5%87%BD%E6%95%B0" rel="nofollow">strncat函数</a></p> 
<p id="strncat-toc" style="margin-left:80px;"><a href="#strncat" rel="nofollow">strncat</a></p> 
<p id="strncmp%E5%87%BD%E6%95%B0%EF%BC%9A-toc" style="margin-left:40px;"><a href="#strncmp%E5%87%BD%E6%95%B0%EF%BC%9A" rel="nofollow">strncmp函数：</a></p> 
<p id="strncmp-toc" style="margin-left:80px;"><a href="#strncmp" rel="nofollow">strncmp</a></p> 
<p id="4.%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9F%A5%E6%89%BE-toc" style="margin-left:0px;"><a href="#4.%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9F%A5%E6%89%BE" rel="nofollow">4.字符串查找</a></p> 
<p id="a.strstr%E2%80%94%E2%80%94%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E4%B8%BA%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2-toc" style="margin-left:40px;"><a href="#a.strstr%E2%80%94%E2%80%94%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E4%B8%BA%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2" rel="nofollow">a.strstr——判断是否为子字符串</a></p> 
<p id="strstr-toc" style="margin-left:40px;"><a href="#strstr" rel="nofollow">strstr</a></p> 
<p id="b.strtok%E2%80%94%E2%80%94%E4%B8%80%E4%B8%AA%E5%A5%87%E6%80%AA%E7%9A%84%E5%87%BD%E6%95%B0-toc" style="margin-left:40px;"><a href="#b.strtok%E2%80%94%E2%80%94%E4%B8%80%E4%B8%AA%E5%A5%87%E6%80%AA%E7%9A%84%E5%87%BD%E6%95%B0" rel="nofollow">b.strtok——一个奇怪的函数</a></p> 
<p id="strtok-toc" style="margin-left:40px;"><a href="#strtok" rel="nofollow">strtok</a></p> 
<p id="c.strerror%E2%80%94%E2%80%94%E9%94%99%E8%AF%AF%E4%BF%A1%E6%81%AF%E6%9F%A5%E6%89%BE-toc" style="margin-left:40px;"><a href="#c.strerror%E2%80%94%E2%80%94%E9%94%99%E8%AF%AF%E4%BF%A1%E6%81%AF%E6%9F%A5%E6%89%BE" rel="nofollow">c.strerror——错误信息查找</a></p> 
<p id="strerror-toc" style="margin-left:40px;"><a href="#strerror" rel="nofollow">strerror</a></p> 
<p id="perror-toc" style="margin-left:40px;"><a href="#perror" rel="nofollow">perror</a></p> 
<p id="%E4%B8%8A%E9%9D%A2%E6%98%AF%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%85%B3%E7%9A%84%E5%87%BD%E6%95%B0%EF%BC%8C%E4%B8%8B%E9%9D%A2%E6%98%AF%E4%B8%80%E4%BA%9B%E5%AD%97%E7%AC%A6%E5%88%86%E7%B1%BB%E7%9A%84%E5%87%BD%E6%95%B0%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%E4%B8%8A%E9%9D%A2%E6%98%AF%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%85%B3%E7%9A%84%E5%87%BD%E6%95%B0%EF%BC%8C%E4%B8%8B%E9%9D%A2%E6%98%AF%E4%B8%80%E4%BA%9B%E5%AD%97%E7%AC%A6%E5%88%86%E7%B1%BB%E7%9A%84%E5%87%BD%E6%95%B0%EF%BC%9A" rel="nofollow">上面是字符串相关的函数，下面是一些字符分类的函数：</a></p> 
<p id="%E2%80%8B%E7%BC%96%E8%BE%91%C2%A0%E5%AD%97%E7%AC%A6%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%E2%80%8B%E7%BC%96%E8%BE%91%C2%A0%E5%AD%97%E7%AC%A6%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0%EF%BC%9A" rel="nofollow">​编辑 字符转换函数：</a></p> 
<p id="%E4%BA%8C.%E5%86%85%E5%AD%98%E5%87%BD%E6%95%B0-toc" style="margin-left:0px;"><a href="#%E4%BA%8C.%E5%86%85%E5%AD%98%E5%87%BD%E6%95%B0" rel="nofollow">二.内存函数</a></p> 
<p id="1.%E5%86%85%E5%AD%98%E6%8B%B7%E8%B4%9D%E5%87%BD%E6%95%B0-toc" style="margin-left:40px;"><a href="#1.%E5%86%85%E5%AD%98%E6%8B%B7%E8%B4%9D%E5%87%BD%E6%95%B0" rel="nofollow">1.内存拷贝函数</a></p> 
<p id="a.memcpy-toc" style="margin-left:40px;"><a href="#a.memcpy" rel="nofollow">a.memcpy</a></p> 
<p id="b.memmove-toc" style="margin-left:40px;"><a href="#b.memmove" rel="nofollow">b.memmove</a></p> 
<p id="2.%E5%86%85%E5%AD%98%E5%A1%AB%E5%85%85%E5%87%BD%E6%95%B0%E2%80%94%E2%80%94memset-toc" style="margin-left:0px;"><a href="#2.%E5%86%85%E5%AD%98%E5%A1%AB%E5%85%85%E5%87%BD%E6%95%B0%E2%80%94%E2%80%94memset" rel="nofollow">2.内存填充函数——memset</a></p> 
<p id="3.%E5%86%85%E5%AD%98%E6%AF%94%E8%BE%83%E5%87%BD%E6%95%B0%E2%80%94%E2%80%94memcmp-toc" style="margin-left:0px;"><a href="#3.%E5%86%85%E5%AD%98%E6%AF%94%E8%BE%83%E5%87%BD%E6%95%B0%E2%80%94%E2%80%94memcmp" rel="nofollow">3.内存比较函数——memcmp</a></p> 
<p id="%E6%80%BB%E7%BB%93%EF%BC%9A-toc" style="margin-left:0px;"><a href="#%E6%80%BB%E7%BB%93%EF%BC%9A" rel="nofollow">总结：</a></p> 
<h3 id="3.%E5%86%85%E5%AD%98%E6%AF%94%E8%BE%83%E5%87%BD%E6%95%B0%E2%80%94%E2%80%94memcmp" style="margin-left:40px;"></h3> 
<hr> 
<blockquote> 
 <p>博客主页：<a href="https://blog.csdn.net/qq_74310471?spm=1000.2115.3001.5343" title="张栩睿的博客主页">张栩睿的博客主页</a></p> 
 <p>欢迎关注：点赞+收藏+留言</p> 
 <p>系列专栏：<a href="https://blog.csdn.net/qq_74310471/category_12157207.html?spm=1001.2014.3001.5482" title="c语言学习">c语言学习</a></p> 
 <p><strong>        家人们写博客真的很花时间的，你们的点赞和关注对我真的很重要，希望各位路过的朋友们能多多点赞并关注我，我会随时互关的，欢迎你们的私信提问，也期待你们的转发！</strong></p> 
 <p>       <strong> 希望大家</strong><em><strong>关注我，</strong></em><strong>你们将会看到更多精彩的内容！！！</strong></p> 
</blockquote> 
<h2 id="%E5%89%8D%E8%A8%80%EF%BC%9A">前言：</h2> 
<p>        C语言中对字符和字符串的处理很是频繁，但是C语言本身是没有字符串类型的，字符串通常放在 常量字符串 中或者 字符数组中。 字符串常量 适用于那些对它不做修改的字符串函数。</p> 
<p><span style="color:#fe2c24;"><strong>以下的函数都需要引用头文件&lt;string.h&gt;</strong></span></p> 
<h2 id="%E4%B8%80.%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0"><a href="#%E4%B8%80.%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0%28%E4%BD%BF%E7%94%A8%E9%83%BD%E9%9C%80%E8%A6%81%E5%8C%85%E5%90%ABstring.h%291.strlen%E2%80%94%E2%80%94%E6%B1%82%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%95%BF%E5%BA%A62.%E9%95%BF%E5%BA%A6%E4%B8%8D%E5%8F%97%E9%99%90%E5%88%B6%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0a.strcpy%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%B7%E8%B4%9Db.strcat%E2%80%94%E2%80%94%E8%BF%BD%E5%8A%A0%E5%AD%97%E7%AC%A6%E4%B8%B2c.strcmp%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%AF%94%E8%BE%833.%E9%95%BF%E5%BA%A6%E5%8F%97%E9%99%90%E5%88%B6%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0%E2%80%94%E2%80%94strncopy%2Cstrncat%2Cstrncmp4.%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9F%A5%E6%89%BEa.strstr%E2%80%94%E2%80%94%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E4%B8%BA%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2b.strtok%E2%80%94%E2%80%94%E4%B8%80%E4%B8%AA%E5%A5%87%E6%80%AA%E7%9A%84%E5%87%BD%E6%95%B0c.%E9%94%99%E8%AF%AF%E4%BF%A1%E6%81%AF%E6%9F%A5%E6%89%BE%E2%80%94%E2%80%94strerror%E4%BA%8C.%E5%86%85%E5%AD%98%E5%87%BD%E6%95%B0%EF%BC%88%E4%B9%9F%E9%9C%80%E8%A6%81%E5%8C%85%E5%90%ABstring.h%EF%BC%891.%E5%86%85%E5%AD%98%E6%8B%B7%E8%B4%9D%E5%87%BD%E6%95%B0%E2%80%94%E2%80%94" rel="nofollow">一.字符串函数</a></h2> 
<h3 id="1.strlen%E2%80%94%E2%80%94%E6%B1%82%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%95%BF%E5%BA%A6"><a href="#%E4%B8%80.%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0%28%E4%BD%BF%E7%94%A8%E9%83%BD%E9%9C%80%E8%A6%81%E5%8C%85%E5%90%ABstring.h%291.strlen%E2%80%94%E2%80%94%E6%B1%82%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%95%BF%E5%BA%A62.%E9%95%BF%E5%BA%A6%E4%B8%8D%E5%8F%97%E9%99%90%E5%88%B6%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0a.strcpy%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%B7%E8%B4%9Db.strcat%E2%80%94%E2%80%94%E8%BF%BD%E5%8A%A0%E5%AD%97%E7%AC%A6%E4%B8%B2c.strcmp%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%AF%94%E8%BE%833.%E9%95%BF%E5%BA%A6%E5%8F%97%E9%99%90%E5%88%B6%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0%E2%80%94%E2%80%94strncopy%2Cstrncat%2Cstrncmp4.%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9F%A5%E6%89%BEa.strstr%E2%80%94%E2%80%94%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E4%B8%BA%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2b.strtok%E2%80%94%E2%80%94%E4%B8%80%E4%B8%AA%E5%A5%87%E6%80%AA%E7%9A%84%E5%87%BD%E6%95%B0c.%E9%94%99%E8%AF%AF%E4%BF%A1%E6%81%AF%E6%9F%A5%E6%89%BE%E2%80%94%E2%80%94strerror%E4%BA%8C.%E5%86%85%E5%AD%98%E5%87%BD%E6%95%B0%EF%BC%88%E4%B9%9F%E9%9C%80%E8%A6%81%E5%8C%85%E5%90%ABstring.h%EF%BC%891.%E5%86%85%E5%AD%98%E6%8B%B7%E8%B4%9D%E5%87%BD%E6%95%B0%E2%80%94%E2%80%94" rel="nofollow">1.strlen——求字符串长度</a></h3> 
<h4 id="strlen"><a href="https://legacy.cplusplus.com/reference/cstring/strlen/?kw=strlen" rel="nofollow" title="strlen">strlen</a></h4> 
<p><strong>函数原型：</strong></p> 
<p><img alt="" height="48" src="https://images2.imgbox.com/ec/25/vZNfurTs_o.png" width="693"></p> 
<p><strong> 函数作用：</strong></p> 
<ul><li>字符串以<code>'\0'</code>作为结束标志，<code>strlen</code>函数返回值是在<strong>字符串中<code>'\0'</code>前面出现的字符个数</strong>（不包含<code>'\0'</code>）</li><li>参数是一个<strong>字符指针变量</strong></li><li>参数指向的字符串必须要以<strong><code>'\0'</code></strong>结束，否则计算出的长度是<strong>随机值</strong></li><li>注意函数的返回值为<code>size_t</code>，是无符号的</li></ul> 
<p><span style="color:#fe2c24;"><strong>函数注意事项：</strong></span></p> 
<p>        因为返回值是size_t，所以就要避免出现下图这样的代码：strlen（“abc”）算出的结果是3， strlen("abcde")算出的结果是5，可能想着3-5得到-2，实际上并不是这样的，这里算出的3和5都是无符号整型，算出的-2也是一个无符号整型，-2在内存中以补码的形式存储，从无符号整型的视角看去，这串补码就表示一个很大的正数。<br><img alt="" height="476" src="https://images2.imgbox.com/18/e1/pYj2Bzzh_o.png" width="1072"></p> 
<p><strong>3种模拟的方法：</strong></p> 
<p><strong>递归：</strong></p> 
<pre><code>递归
int my_strlen1(const char* str)
{
	assert(str != NULL);
	if (*str != '\0')
		return 1 + my_strlen(str + 1);
	else
		return 0;
}</code></pre> 
<p><strong>指针-指针 </strong></p> 
<pre><code>指针-指针
int my_strlen2(const char* str)
{
	const char* start = str;
	assert(str != NULL);
	while (*str)
	{
		str++;
	}
	return str - start;</code></pre> 
<p><strong>递推 </strong></p> 
<pre><code>int my_strlen(const char* str)
{
	assert(str != NULL);
	int count = 0;
	while (*str != '\0')
	{
		count++;
		str++;
	}
	return count;
}</code></pre> 
<h2 id="2.%E9%95%BF%E5%BA%A6%E4%B8%8D%E5%8F%97%E9%99%90%E5%88%B6%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0"><a href="#%E4%B8%80.%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0%28%E4%BD%BF%E7%94%A8%E9%83%BD%E9%9C%80%E8%A6%81%E5%8C%85%E5%90%ABstring.h%291.strlen%E2%80%94%E2%80%94%E6%B1%82%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%95%BF%E5%BA%A62.%E9%95%BF%E5%BA%A6%E4%B8%8D%E5%8F%97%E9%99%90%E5%88%B6%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0a.strcpy%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%B7%E8%B4%9Db.strcat%E2%80%94%E2%80%94%E8%BF%BD%E5%8A%A0%E5%AD%97%E7%AC%A6%E4%B8%B2c.strcmp%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%AF%94%E8%BE%833.%E9%95%BF%E5%BA%A6%E5%8F%97%E9%99%90%E5%88%B6%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0%E2%80%94%E2%80%94strncopy%2Cstrncat%2Cstrncmp4.%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9F%A5%E6%89%BEa.strstr%E2%80%94%E2%80%94%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E4%B8%BA%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2b.strtok%E2%80%94%E2%80%94%E4%B8%80%E4%B8%AA%E5%A5%87%E6%80%AA%E7%9A%84%E5%87%BD%E6%95%B0c.%E9%94%99%E8%AF%AF%E4%BF%A1%E6%81%AF%E6%9F%A5%E6%89%BE%E2%80%94%E2%80%94strerror%E4%BA%8C.%E5%86%85%E5%AD%98%E5%87%BD%E6%95%B0%EF%BC%88%E4%B9%9F%E9%9C%80%E8%A6%81%E5%8C%85%E5%90%ABstring.h%EF%BC%891.%E5%86%85%E5%AD%98%E6%8B%B7%E8%B4%9D%E5%87%BD%E6%95%B0%E2%80%94%E2%80%94" rel="nofollow">2.长度不受限制的字符串函数</a></h2> 
<h4 id="a.strcpy%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%B7%E8%B4%9D"><a href="#%E4%B8%80.%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0%28%E4%BD%BF%E7%94%A8%E9%83%BD%E9%9C%80%E8%A6%81%E5%8C%85%E5%90%ABstring.h%291.strlen%E2%80%94%E2%80%94%E6%B1%82%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%95%BF%E5%BA%A62.%E9%95%BF%E5%BA%A6%E4%B8%8D%E5%8F%97%E9%99%90%E5%88%B6%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0a.strcpy%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%B7%E8%B4%9Db.strcat%E2%80%94%E2%80%94%E8%BF%BD%E5%8A%A0%E5%AD%97%E7%AC%A6%E4%B8%B2c.strcmp%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%AF%94%E8%BE%833.%E9%95%BF%E5%BA%A6%E5%8F%97%E9%99%90%E5%88%B6%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0%E2%80%94%E2%80%94strncopy%2Cstrncat%2Cstrncmp4.%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9F%A5%E6%89%BEa.strstr%E2%80%94%E2%80%94%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E4%B8%BA%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2b.strtok%E2%80%94%E2%80%94%E4%B8%80%E4%B8%AA%E5%A5%87%E6%80%AA%E7%9A%84%E5%87%BD%E6%95%B0c.%E9%94%99%E8%AF%AF%E4%BF%A1%E6%81%AF%E6%9F%A5%E6%89%BE%E2%80%94%E2%80%94strerror%E4%BA%8C.%E5%86%85%E5%AD%98%E5%87%BD%E6%95%B0%EF%BC%88%E4%B9%9F%E9%9C%80%E8%A6%81%E5%8C%85%E5%90%ABstring.h%EF%BC%891.%E5%86%85%E5%AD%98%E6%8B%B7%E8%B4%9D%E5%87%BD%E6%95%B0%E2%80%94%E2%80%94" rel="nofollow">a.strcpy——字符串拷贝</a></h4> 
<h4 id="strcpy"><a href="https://legacy.cplusplus.com/reference/cstring/strcpy/?kw=strcpy" rel="nofollow" title="strcpy">strcpy</a></h4> 
<p><strong>函数原型:</strong></p> 
<p><img alt="" height="146" src="https://images2.imgbox.com/4f/54/Jw64sXJ6_o.png" width="628"></p> 
<p> <strong>函数作用：</strong></p> 
<blockquote> 
 <p><strong>字符串拷贝函数，把源字符串拷贝到目标空间</strong></p> 
</blockquote> 
<p><strong>注意事项：</strong></p> 
<p>函数有两个参数，source指向待拷贝的字符串，也叫做源字符串。destination是目标空间的地址<br><strong>源字符串必须以’\0’结束</strong></p> 
<p>目标空间必须足够大，<strong>以确保能存放源字符串</strong>，否则会出现非法访问</p> 
<p><span style="color:#511b78;"><strong>特殊情况：</strong></span><br> 会把源字符串中的 ‘\0’ 也拷贝到目标空间</p> 
<p><img alt="" height="272" src="https://images2.imgbox.com/55/d6/Akjn63u2_o.png" width="729"><br> 目标空间必须可变，例如把源字符串拷贝到一<span style="color:#0d0016;">个</span><strong><span style="color:#fe2c24;">字符串常量</span></strong>里面是<strong>不可取的</strong></p> 
<p><img alt="" height="272" src="https://images2.imgbox.com/bf/e5/XIhrThX7_o.png" width="732"></p> 
<p></p> 
<p><strong>模拟实现：</strong></p> 
<pre><code>char* my_strcpy(char* destination, const char* source)
{
	assert(destination &amp;&amp; source);
	char* ret = destination;
	while (*destination++ = *source++)
	{
		;
	}
	return ret;
}</code></pre> 
<h4 id="%C2%A0b.strcat%E2%80%94%E2%80%94%E8%BF%BD%E5%8A%A0%E5%AD%97%E7%AC%A6%E4%B8%B2"> <a href="#%E4%B8%80.%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0%28%E4%BD%BF%E7%94%A8%E9%83%BD%E9%9C%80%E8%A6%81%E5%8C%85%E5%90%ABstring.h%291.strlen%E2%80%94%E2%80%94%E6%B1%82%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%95%BF%E5%BA%A62.%E9%95%BF%E5%BA%A6%E4%B8%8D%E5%8F%97%E9%99%90%E5%88%B6%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0a.strcpy%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%B7%E8%B4%9Db.strcat%E2%80%94%E2%80%94%E8%BF%BD%E5%8A%A0%E5%AD%97%E7%AC%A6%E4%B8%B2c.strcmp%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%AF%94%E8%BE%833.%E9%95%BF%E5%BA%A6%E5%8F%97%E9%99%90%E5%88%B6%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0%E2%80%94%E2%80%94strncopy%2Cstrncat%2Cstrncmp4.%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9F%A5%E6%89%BEa.strstr%E2%80%94%E2%80%94%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E4%B8%BA%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2b.strtok%E2%80%94%E2%80%94%E4%B8%80%E4%B8%AA%E5%A5%87%E6%80%AA%E7%9A%84%E5%87%BD%E6%95%B0c.%E9%94%99%E8%AF%AF%E4%BF%A1%E6%81%AF%E6%9F%A5%E6%89%BE%E2%80%94%E2%80%94strerror%E4%BA%8C.%E5%86%85%E5%AD%98%E5%87%BD%E6%95%B0%EF%BC%88%E4%B9%9F%E9%9C%80%E8%A6%81%E5%8C%85%E5%90%ABstring.h%EF%BC%891.%E5%86%85%E5%AD%98%E6%8B%B7%E8%B4%9D%E5%87%BD%E6%95%B0%E2%80%94%E2%80%94" rel="nofollow">b.strcat——追加字符串</a></h4> 
<h4 id="strcat"><a href="https://legacy.cplusplus.com/reference/cstring/strcat/?kw=strcat" rel="nofollow" title="strcat">strcat</a></h4> 
<p><strong>函数原型</strong>：</p> 
<p><img alt="" height="111" src="https://images2.imgbox.com/75/ea/nlHwVvTI_o.png" width="619"></p> 
<p> <strong>函数作用：</strong></p> 
<blockquote> 
 <p><strong>        字符串追加函数，将源字符串追加到目标字符串后面，目标中的终止字符’\0’会被源字符串的第一个字符覆盖</strong></p> 
</blockquote> 
<p><img alt="" height="239" src="https://images2.imgbox.com/48/b2/wZ244Eb3_o.png" width="1022"></p> 
<p><strong>注意事项：</strong></p> 
<p>函数有两个参数，其中source指向要追加的字符串，也叫做源字符串，destination是目标空间的地址<br> 目标空间中必须要有'\0'，作为追加的起始地址<br> 源字符串中也必须要有'\0'作为追加的结束标志<br> 目标空间必须足够大，能容纳下源字符串的内容<br> 目标空间必须可修改</p> 
<p>以上与strcpy类似，但是有一点很特殊：<br><strong><span style="color:#333333;">自己给自己追加会陷入死循环！</span></strong></p> 
<p><span style="color:#333333;">同学们先看看模拟实现的代码可以知道，该函数本质是将\0覆盖了，再最后追加\0，但是自己改自己会把\0覆盖不见，最后造成死循环。</span></p> 
<p><span style="color:#333333;"><strong>模拟实现：</strong></span></p> 
<pre><code>char* my_strcat(char* destination, const char* source)
{
	assert(destination &amp;&amp; source);
	char* ret = destination;
	while (*destination)
	{
		ret++;
	}
	while (*destination++ = *source++)
	{
		;
	}
	return ret;
}</code></pre> 
<h4 id="%C2%A0c.strcmp%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%AF%94%E8%BE%83"> <a href="#%E4%B8%80.%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0%28%E4%BD%BF%E7%94%A8%E9%83%BD%E9%9C%80%E8%A6%81%E5%8C%85%E5%90%ABstring.h%291.strlen%E2%80%94%E2%80%94%E6%B1%82%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%95%BF%E5%BA%A62.%E9%95%BF%E5%BA%A6%E4%B8%8D%E5%8F%97%E9%99%90%E5%88%B6%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0a.strcpy%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%B7%E8%B4%9Db.strcat%E2%80%94%E2%80%94%E8%BF%BD%E5%8A%A0%E5%AD%97%E7%AC%A6%E4%B8%B2c.strcmp%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%AF%94%E8%BE%833.%E9%95%BF%E5%BA%A6%E5%8F%97%E9%99%90%E5%88%B6%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0%E2%80%94%E2%80%94strncopy%2Cstrncat%2Cstrncmp4.%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9F%A5%E6%89%BEa.strstr%E2%80%94%E2%80%94%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E4%B8%BA%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2b.strtok%E2%80%94%E2%80%94%E4%B8%80%E4%B8%AA%E5%A5%87%E6%80%AA%E7%9A%84%E5%87%BD%E6%95%B0c.%E9%94%99%E8%AF%AF%E4%BF%A1%E6%81%AF%E6%9F%A5%E6%89%BE%E2%80%94%E2%80%94strerror%E4%BA%8C.%E5%86%85%E5%AD%98%E5%87%BD%E6%95%B0%EF%BC%88%E4%B9%9F%E9%9C%80%E8%A6%81%E5%8C%85%E5%90%ABstring.h%EF%BC%891.%E5%86%85%E5%AD%98%E6%8B%B7%E8%B4%9D%E5%87%BD%E6%95%B0%E2%80%94%E2%80%94" rel="nofollow">c.strcmp——字符串比较</a></h4> 
<h4 id="strcmp"><a href="https://legacy.cplusplus.com/reference/cstring/strcmp/?kw=strcmp" rel="nofollow" title="strcmp">strcmp</a></h4> 
<p><strong>函数原型：</strong></p> 
<p><img alt="" height="43" src="https://images2.imgbox.com/3e/bb/0A8QyURl_o.png" width="699"></p> 
<p> <strong>函数作用：</strong></p> 
<blockquote> 
 <p>        根据相同位置的ASCII值进行大小的比较。并不是比字符串长度</p> 
</blockquote> 
<p><strong>注意事项：</strong></p> 
<p>第一个字符串大于第二个字符串，则返回大于0的数字</p> 
<p>第一个字符串等于第二个字符串，则返回0</p> 
<p>第一个字符串小于第二个字符串，则返回小于0的数字</p> 
<p><strong>该函数是按字典序来比较的。</strong></p> 
<p><img alt="" height="285" src="https://images2.imgbox.com/2f/d8/8V0ylMGi_o.png" width="871"></p> 
<p> <strong>模拟实现：</strong></p> 
<pre><code>int my_strcmp(const char* str1, const char* str2)
{
	assert(str1 &amp;&amp; str2);
	while (*str1 == *str2)//如果相等就进去，两个指针加加，但是可能会出现两个字符串相等的情况，两个指针都指向'\0'，此时比较就结束了
	{
		if (*str1 == '\0')
		{
			return 0;
		}
		str1++;
		str2++;
	}
	if (*str1 &gt; *str2)
	{
		return 1;
	}
	else
	{
		return -1;
	}
}</code></pre> 
<h2 id="3.%E9%95%BF%E5%BA%A6%E5%8F%97%E9%99%90%E5%88%B6%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0%E2%80%94%E2%80%94strncpy%2Cstrncat%2Cstrncmp"><a href="#%E4%B8%80.%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0%28%E4%BD%BF%E7%94%A8%E9%83%BD%E9%9C%80%E8%A6%81%E5%8C%85%E5%90%ABstring.h%291.strlen%E2%80%94%E2%80%94%E6%B1%82%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%95%BF%E5%BA%A62.%E9%95%BF%E5%BA%A6%E4%B8%8D%E5%8F%97%E9%99%90%E5%88%B6%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0a.strcpy%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%B7%E8%B4%9Db.strcat%E2%80%94%E2%80%94%E8%BF%BD%E5%8A%A0%E5%AD%97%E7%AC%A6%E4%B8%B2c.strcmp%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%AF%94%E8%BE%833.%E9%95%BF%E5%BA%A6%E5%8F%97%E9%99%90%E5%88%B6%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0%E2%80%94%E2%80%94strncopy%2Cstrncat%2Cstrncmp4.%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9F%A5%E6%89%BEa.strstr%E2%80%94%E2%80%94%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E4%B8%BA%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2b.strtok%E2%80%94%E2%80%94%E4%B8%80%E4%B8%AA%E5%A5%87%E6%80%AA%E7%9A%84%E5%87%BD%E6%95%B0c.%E9%94%99%E8%AF%AF%E4%BF%A1%E6%81%AF%E6%9F%A5%E6%89%BE%E2%80%94%E2%80%94strerror%E4%BA%8C.%E5%86%85%E5%AD%98%E5%87%BD%E6%95%B0%EF%BC%88%E4%B9%9F%E9%9C%80%E8%A6%81%E5%8C%85%E5%90%ABstring.h%EF%BC%891.%E5%86%85%E5%AD%98%E6%8B%B7%E8%B4%9D%E5%87%BD%E6%95%B0%E2%80%94%E2%80%94" rel="nofollow">3.长度受限制的字符串函数——strncpy,strncat,strncmp</a></h2> 
<h4 id="%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%87%BA%E7%8E%B0%E8%BF%99%E4%BA%9B%E5%87%BD%E6%95%B0%E5%91%A2%EF%BC%9F">为什么会出现这些函数呢？</h4> 
<blockquote> 
 <p><strong>        前面三个函数压根不关心到底拷贝，追加，比较了几个字符。它们只关心是否找到了\0，一旦找到了\0就会停止。这样的话如果目标空间不够大，会造成越界。这些特点就会让人们决定它是不安全的，并且我们之前发现如果自己给自己追加会出现死循环的现象，因为这些缺点，下面介绍较安全的函数。</strong></p> 
</blockquote> 
<h3 id="strncpy%E5%87%BD%E6%95%B0%EF%BC%9A">strncpy函数：</h3> 
<h4 id="strncpy"><a href="https://legacy.cplusplus.com/reference/cstring/strncpy/?kw=strncpy" rel="nofollow" title="strncpy">strncpy</a></h4> 
<p><strong>函数原型：</strong></p> 
<p><img alt="" height="172" src="https://images2.imgbox.com/74/2b/7bwjA2My_o.png" width="730"></p> 
<p><strong> 函数作用：</strong></p> 
<blockquote> 
 <p><strong>长度受限的字符串拷贝</strong></p> 
</blockquote> 
<p><strong>注意事项：</strong></p> 
<ul><li>拷贝num个字符从源字符串到目标空间。</li><li>如果源字符串的长度小于num，则拷贝完源字符串之后，在目标的后边追加0，直到num个。</li></ul> 
<p><strong>模拟实现：</strong></p> 
<pre><code>char* my_strncpy(char* dest, const char* src, int num)
{
	assert(dest &amp;&amp; src);
	char* ret = dest;
	while (num)
	{
		if (*src == '\0')//此时说明src指针已经指向了待拷贝字符串的结束标志'\0'处，src指针就不用再++了
		{
			*dest = '\0';
			dest++;
		}
		else
		{
			*dest = *src;
			dest++;
			src++;
		}
		num--;
	}
	return ret;
}</code></pre> 
<h3 id="strncat%E5%87%BD%E6%95%B0">strncat函数</h3> 
<h4 id="strncat"><a href="https://legacy.cplusplus.com/reference/cstring/strncat/?kw=strncat" rel="nofollow" title="strncat">strncat</a></h4> 
<p><strong>函数原型：</strong></p> 
<p><img alt="" height="136" src="https://images2.imgbox.com/3b/ba/63Room6X_o.png" width="735"></p> 
<p><strong>注意事项：</strong></p> 
<ul><li>从源字符串的第一个字符开始往后数num个字符追加到目标空间的后面，外加一个终止字符。</li><li>如果源字符串的长度小于 num，则仅复制终止字符之前的内容。</li></ul> 
<p><strong>模拟实现：</strong></p> 
<pre><code>char* my_strncat(char* dest, const char* src, int sz)
{
	assert(dest &amp;&amp; src);
	char* ret = dest;
	//找目标空间的\0
	while (*dest != '\0')
	{
		dest++;
	}
	//追加
	while (sz)
	{
		*dest++ = *src++;
		sz--;
	}
	*dest = '\0';
	return ret;
}
</code></pre> 
<h3 id="strncmp%E5%87%BD%E6%95%B0%EF%BC%9A">strncmp函数：</h3> 
<h4 id="strncmp"><a href="https://legacy.cplusplus.com/reference/cstring/strncmp/?kw=strncmp" rel="nofollow" title="strncmp">strncmp</a></h4> 
<p> <strong>函数原型：</strong></p> 
<p> <img alt="" height="127" src="https://images2.imgbox.com/8d/79/xqwDYTbw_o.png" width="635"></p> 
<p><strong> 模拟实现：</strong></p> 
<pre><code>int my_strncmp(const char* str1, const char* str2, int sz)
{
	assert(str1 &amp;&amp; str2);
	while (sz)
	{
		if (*str1 &lt; *str2)
		{
			return -1;
		}
		else if (*str1 &gt; *str2)
		{
			return 1;
		}
		else if(*str1 == '\0'||*str2 =='\0')//当有一个为'\0'，说明比较就可以结束了
		{
			if (*str1 == '\0' &amp;&amp; *str2 == '\0')//如果二者都是'\0'，说明两个字符串相等
			{
				return 0;
			}
			else if(*str1 =='\0')//如果str1为'\0'，说明str1小，str2大
			{
				return -1;
			}
			else//如果src为'\0'，说明str1大，str2小
			{
				return 1;
			}
		}
		sz--;
		str1++;
		str2++;
	}
}
</code></pre> 
<h2 id="4.%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9F%A5%E6%89%BE"><strong><a href="#%E4%B8%80.%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0%28%E4%BD%BF%E7%94%A8%E9%83%BD%E9%9C%80%E8%A6%81%E5%8C%85%E5%90%ABstring.h%291.strlen%E2%80%94%E2%80%94%E6%B1%82%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%95%BF%E5%BA%A62.%E9%95%BF%E5%BA%A6%E4%B8%8D%E5%8F%97%E9%99%90%E5%88%B6%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0a.strcpy%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%B7%E8%B4%9Db.strcat%E2%80%94%E2%80%94%E8%BF%BD%E5%8A%A0%E5%AD%97%E7%AC%A6%E4%B8%B2c.strcmp%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%AF%94%E8%BE%833.%E9%95%BF%E5%BA%A6%E5%8F%97%E9%99%90%E5%88%B6%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0%E2%80%94%E2%80%94strncopy%2Cstrncat%2Cstrncmp4.%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9F%A5%E6%89%BEa.strstr%E2%80%94%E2%80%94%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E4%B8%BA%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2b.strtok%E2%80%94%E2%80%94%E4%B8%80%E4%B8%AA%E5%A5%87%E6%80%AA%E7%9A%84%E5%87%BD%E6%95%B0c.%E9%94%99%E8%AF%AF%E4%BF%A1%E6%81%AF%E6%9F%A5%E6%89%BE%E2%80%94%E2%80%94strerror%E4%BA%8C.%E5%86%85%E5%AD%98%E5%87%BD%E6%95%B0%EF%BC%88%E4%B9%9F%E9%9C%80%E8%A6%81%E5%8C%85%E5%90%ABstring.h%EF%BC%891.%E5%86%85%E5%AD%98%E6%8B%B7%E8%B4%9D%E5%87%BD%E6%95%B0%E2%80%94%E2%80%94" rel="nofollow">4.字符串查找</a></strong></h2> 
<h3 id="a.strstr%E2%80%94%E2%80%94%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E4%B8%BA%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2" style="margin-left:40px;"><a href="#%E4%B8%80.%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0%28%E4%BD%BF%E7%94%A8%E9%83%BD%E9%9C%80%E8%A6%81%E5%8C%85%E5%90%ABstring.h%291.strlen%E2%80%94%E2%80%94%E6%B1%82%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%95%BF%E5%BA%A62.%E9%95%BF%E5%BA%A6%E4%B8%8D%E5%8F%97%E9%99%90%E5%88%B6%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0a.strcpy%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%B7%E8%B4%9Db.strcat%E2%80%94%E2%80%94%E8%BF%BD%E5%8A%A0%E5%AD%97%E7%AC%A6%E4%B8%B2c.strcmp%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%AF%94%E8%BE%833.%E9%95%BF%E5%BA%A6%E5%8F%97%E9%99%90%E5%88%B6%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0%E2%80%94%E2%80%94strncopy%2Cstrncat%2Cstrncmp4.%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9F%A5%E6%89%BEa.strstr%E2%80%94%E2%80%94%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E4%B8%BA%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2b.strtok%E2%80%94%E2%80%94%E4%B8%80%E4%B8%AA%E5%A5%87%E6%80%AA%E7%9A%84%E5%87%BD%E6%95%B0c.%E9%94%99%E8%AF%AF%E4%BF%A1%E6%81%AF%E6%9F%A5%E6%89%BE%E2%80%94%E2%80%94strerror%E4%BA%8C.%E5%86%85%E5%AD%98%E5%87%BD%E6%95%B0%EF%BC%88%E4%B9%9F%E9%9C%80%E8%A6%81%E5%8C%85%E5%90%ABstring.h%EF%BC%891.%E5%86%85%E5%AD%98%E6%8B%B7%E8%B4%9D%E5%87%BD%E6%95%B0%E2%80%94%E2%80%94" rel="nofollow">a.strstr——判断是否为子字符串</a></h3> 
<h3 id="strstr"><a href="https://legacy.cplusplus.com/reference/cstring/strstr/?kw=strstr" rel="nofollow" title="strstr">strstr</a></h3> 
<p><strong>函数原型：</strong></p> 
<p><img alt="" height="69" src="https://images2.imgbox.com/57/01/PgbAohQy_o.png" width="867"></p> 
<p> <strong>函数作用：</strong></p> 
<blockquote> 
 <p>        判断是否为子字符串</p> 
</blockquote> 
<p> <img alt="" height="380" src="https://images2.imgbox.com/2a/c6/i5jG6avz_o.png" width="1047"></p> 
<p><strong>注意事项：</strong></p> 
<ul><li>在str1指向的字符串中查找str2指向的字符串</li><li>返回一个<strong>指向str1中第一次出现的str2的指针</strong></li><li>如果 str2 不是 str1 的一部分，则<strong>返回一个空指针NULL</strong></li><li>匹配过程不包括终止空字符，但它到此为止</li></ul> 
<p><strong>BF算法(暴力枚举)模拟函数实现：</strong></p> 
<pre><code>char* my_strstr(const char* str1, const char* str2)
{
	assert(str1 &amp;&amp; str2);
	if (*str2 == '\0')
	{
		return (char*)str1;
	}
	const char* s1 = NULL;
	const char* s2 = NULL;
	const char* cp = str1;

	while (*cp)
	{
		s1 = cp;
		s2 = str2;
		while (*s1 !='\0' &amp;&amp; *s2!='\0' &amp;&amp; *s1 == *s2)
		{
			s1++;
			s2++;
		}
		if (*s2 == '\0')
		{
			return (char*)cp;
		}
		cp++;
	}

	return NULL;
}</code></pre> 
<p><strong>KMP算法模拟实现：</strong></p> 
<pre><code>void Getnext(char* next, char* str2)
{
	next[0] = -1;
	next[1] = 0;
	int k = 0;
	int i = 2;
	while (i &lt;= strlen(str2))
	{
		if (str2[k] == str2[i-1])
			next[i] = k + 1;
		else if (str2[i] != str2[0])
			next[k] = 0;
		else if (str2[i] == str2[0])
			next[k] = 1;
		k++;
		i++;
	}
}
char* KMP(const char* str1, const char* str2)
{
	assert(str1 &amp;&amp; str2);
	int* next = (int*)malloc(sizeof(int) * strlen(str2));
	assert(next);
	Getnext(next, str2);
	int i = 0;
	int j = 0;
	while (i &lt; strlen(str1) &amp;&amp; j &lt; strlen(str2))
	{
		if (j==-1||str1[i] == str2[j])
		{
			i++;
			j++;
		}
		else
		{
			j = next[j];
		}
	}
	free(next);
	if (i == strlen(str2))
		return &amp;str1[i - j];
	return NULL;
}</code></pre> 
<p>关于KMP算法可以通过这两篇博客来了解：</p> 
<p><a class="link-info" href="http://t.csdn.cn/HoQqe" rel="nofollow" title="一篇文章弄懂KMP算法">一篇文章弄懂KMP算法</a></p> 
<p><a class="link-info" href="http://t.csdn.cn/8R6vc" rel="nofollow" title="关于next数组">关于next数组</a></p> 
<h3 id="b.strtok%E2%80%94%E2%80%94%E4%B8%80%E4%B8%AA%E5%A5%87%E6%80%AA%E7%9A%84%E5%87%BD%E6%95%B0" style="margin-left:40px;"><a href="#%E4%B8%80.%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0%28%E4%BD%BF%E7%94%A8%E9%83%BD%E9%9C%80%E8%A6%81%E5%8C%85%E5%90%ABstring.h%291.strlen%E2%80%94%E2%80%94%E6%B1%82%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%95%BF%E5%BA%A62.%E9%95%BF%E5%BA%A6%E4%B8%8D%E5%8F%97%E9%99%90%E5%88%B6%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0a.strcpy%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%B7%E8%B4%9Db.strcat%E2%80%94%E2%80%94%E8%BF%BD%E5%8A%A0%E5%AD%97%E7%AC%A6%E4%B8%B2c.strcmp%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%AF%94%E8%BE%833.%E9%95%BF%E5%BA%A6%E5%8F%97%E9%99%90%E5%88%B6%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0%E2%80%94%E2%80%94strncopy%2Cstrncat%2Cstrncmp4.%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9F%A5%E6%89%BEa.strstr%E2%80%94%E2%80%94%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E4%B8%BA%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2b.strtok%E2%80%94%E2%80%94%E4%B8%80%E4%B8%AA%E5%A5%87%E6%80%AA%E7%9A%84%E5%87%BD%E6%95%B0c.%E9%94%99%E8%AF%AF%E4%BF%A1%E6%81%AF%E6%9F%A5%E6%89%BE%E2%80%94%E2%80%94strerror%E4%BA%8C.%E5%86%85%E5%AD%98%E5%87%BD%E6%95%B0%EF%BC%88%E4%B9%9F%E9%9C%80%E8%A6%81%E5%8C%85%E5%90%ABstring.h%EF%BC%891.%E5%86%85%E5%AD%98%E6%8B%B7%E8%B4%9D%E5%87%BD%E6%95%B0%E2%80%94%E2%80%94" rel="nofollow">b.strtok——一个奇怪的函数</a></h3> 
<h3 id="strtok"><a href="https://legacy.cplusplus.com/reference/cstring/strtok/?kw=strtok" rel="nofollow" title="strtok">strtok</a></h3> 
<p><strong>函数原型：</strong></p> 
<p><img alt="" height="95" src="https://images2.imgbox.com/54/9a/YIb7NaB9_o.png" width="750"></p> 
<p><strong>作用：</strong></p> 
<blockquote> 
 <p>通过分隔符分割字符串</p> 
</blockquote> 
<p><strong> 注意事项：</strong></p> 
<p>1.sep参数是个字符串，定义了用作分隔符的字符集合第一个参数指定一个字符串，它包含了0个或者多个由sep字符串中一个或者多个分隔符分割的标记。</p> 
<p>2.strtok函数找到str中的下一个标记，并将其用 \0 结尾，返回一个指向这个标记的指针。（注：strtok函数会改变被操作的字符串，所以在使用strtok函数切分的字符串一般都是临时拷贝的内容并且可修改。）<br> 3. strtok函数的第一个参数不为 NULL ，函数将找到str中第一个标记，strtok函数将保存它在字符串中的位置。<br> 4.strtok函数的第一个参数为 NULL ，函数将在同一个字符串中被保存的位置开始，查找下一个标记。<br> 5.如果字符串中不存在更多的标记，则返回 NULL 指针。</p> 
<p>这个函数很奇怪，让我举个栗子：</p> 
<blockquote> 
 <p><strong>用来分割字符串。一个例子，例如我的邮箱是xxxxx@163.com。这个邮箱起始由三部分组成，一个是xxxxxx，一个是163，一个是com。我现在想把这三部分分开。</strong></p> 
</blockquote> 
<p><img alt="" height="287" src="https://images2.imgbox.com/df/d2/E10sLrlz_o.png" width="1028"></p> 
<p><img alt="" height="118" src="https://images2.imgbox.com/e6/3c/qYe2CgCu_o.png" width="306"></p> 
<p><img alt="" height="420" src="https://images2.imgbox.com/a5/58/36i2uIRi_o.png" width="1037"></p> 
<p> <img alt="" height="117" src="https://images2.imgbox.com/5e/63/FjK5msPW_o.png" width="311"></p> 
<p> 当然，我们可以用for循环简写：</p> 
<p><img alt="" height="406" src="https://images2.imgbox.com/a1/1f/7Z1vrB8V_o.png" width="907"></p> 
<p>该函数模拟较复杂，我们就先不模拟了。 </p> 
<p></p> 
<h3 id="c.strerror%E2%80%94%E2%80%94%E9%94%99%E8%AF%AF%E4%BF%A1%E6%81%AF%E6%9F%A5%E6%89%BE" style="margin-left:40px;"><a href="#%E4%B8%80.%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0%28%E4%BD%BF%E7%94%A8%E9%83%BD%E9%9C%80%E8%A6%81%E5%8C%85%E5%90%ABstring.h%291.strlen%E2%80%94%E2%80%94%E6%B1%82%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%95%BF%E5%BA%A62.%E9%95%BF%E5%BA%A6%E4%B8%8D%E5%8F%97%E9%99%90%E5%88%B6%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0a.strcpy%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%B7%E8%B4%9Db.strcat%E2%80%94%E2%80%94%E8%BF%BD%E5%8A%A0%E5%AD%97%E7%AC%A6%E4%B8%B2c.strcmp%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%AF%94%E8%BE%833.%E9%95%BF%E5%BA%A6%E5%8F%97%E9%99%90%E5%88%B6%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0%E2%80%94%E2%80%94strncopy%2Cstrncat%2Cstrncmp4.%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9F%A5%E6%89%BEa.strstr%E2%80%94%E2%80%94%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E4%B8%BA%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2b.strtok%E2%80%94%E2%80%94%E4%B8%80%E4%B8%AA%E5%A5%87%E6%80%AA%E7%9A%84%E5%87%BD%E6%95%B0c.%E9%94%99%E8%AF%AF%E4%BF%A1%E6%81%AF%E6%9F%A5%E6%89%BE%E2%80%94%E2%80%94strerror%E4%BA%8C.%E5%86%85%E5%AD%98%E5%87%BD%E6%95%B0%EF%BC%88%E4%B9%9F%E9%9C%80%E8%A6%81%E5%8C%85%E5%90%ABstring.h%EF%BC%891.%E5%86%85%E5%AD%98%E6%8B%B7%E8%B4%9D%E5%87%BD%E6%95%B0%E2%80%94%E2%80%94" rel="nofollow">c.strerror——错误信息查找</a></h3> 
<h3 id="strerror"><a href="https://legacy.cplusplus.com/reference/cstring/strerror/?kw=strerror" rel="nofollow" title="strerror">strerror</a></h3> 
<p><strong>函数原型：</strong></p> 
<p><img alt="" height="102" src="https://images2.imgbox.com/1f/fd/qMTHsqkc_o.png" width="722"></p> 
<p><strong>作用：</strong></p> 
<blockquote> 
 <p><strong>把错误码转换成错误信息</strong> </p> 
</blockquote> 
<p><strong>注意事项：</strong></p> 
<ul><li>C语言的库函数在运行的时候，如果发生错误，就会把错误码存在一个变量中，这个变量是：errno</li><li>返回的指针指向静态分配的字符串（错误信息字符串）</li></ul> 
<p><strong>一些栗子：</strong></p> 
<p><img alt="" height="284" src="https://images2.imgbox.com/4b/0e/mOe3SdeU_o.png" width="798"></p> 
<p><strong> 用法：</strong></p> 
<pre><code>int main()
{
	//打开文件
	FILE* pf = fopen("test.c", "r");
	if (pf == NULL)
	{
		printf("%s\n", strerror(errno));//需要包含头文件#include&lt;errno.h&gt;
		return 1;
	}
	//读文件
	//关闭文件
	fclose(pf);
	return 0;
}
//打开失败时屏幕显示：
No such file or directory
</code></pre> 
<p>        关于这里的errno，C语言的库函数在运行的时候，如果发生错误，就会将错误码存在一个变量中，这个变量是：errno，错误码是一些数字：1 2 3 4 5，我们需要讲错误码翻译成错误消息。</p> 
<p><strong>perror函数：</strong></p> 
<h3 id="perror"><a href="https://legacy.cplusplus.com/reference/cstdio/perror/?kw=perror" rel="nofollow" title="perror">perror</a></h3> 
<p><strong>实际上就是printf和strerror的结合！</strong></p> 
<p><img alt="" height="455" src="https://images2.imgbox.com/fd/0b/Ghh9DuPn_o.png" width="1042"></p> 
<h3 id="%E4%B8%8A%E9%9D%A2%E6%98%AF%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%85%B3%E7%9A%84%E5%87%BD%E6%95%B0%EF%BC%8C%E4%B8%8B%E9%9D%A2%E6%98%AF%E4%B8%80%E4%BA%9B%E5%AD%97%E7%AC%A6%E5%88%86%E7%B1%BB%E7%9A%84%E5%87%BD%E6%95%B0%EF%BC%9A">上面是字符串相关的函数，下面是一些字符分类的函数：</h3> 
<h3 id="%E2%80%8B%E7%BC%96%E8%BE%91%C2%A0%E5%AD%97%E7%AC%A6%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0%EF%BC%9A"><img alt="" height="700" src="https://images2.imgbox.com/42/7e/2lIyIFmr_o.png" width="1033"> 字符转换函数：</h3> 
<p><br><a href="https://legacy.cplusplus.com/reference/cctype/tolower/?kw=tolower" rel="nofollow" title="tolower">tolower</a>：<strong>将大写字母转换为小写字母</strong><br> int tolower ( int c );<br><a href="https://legacy.cplusplus.com/reference/cctype/toupper/?kw=toupper" rel="nofollow" title="toupper">toupper</a>：<strong>将小写字母转换成大写字母</strong><br> int toupper ( int c );</p> 
<p>        这些函数我就不一一讲解了，家人们有兴趣的话可以去官网了解一下哦！</p> 
<h2 id="%E4%BA%8C.%E5%86%85%E5%AD%98%E5%87%BD%E6%95%B0"><strong><a href="#%E4%B8%80.%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0%28%E4%BD%BF%E7%94%A8%E9%83%BD%E9%9C%80%E8%A6%81%E5%8C%85%E5%90%ABstring.h%291.strlen%E2%80%94%E2%80%94%E6%B1%82%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%95%BF%E5%BA%A62.%E9%95%BF%E5%BA%A6%E4%B8%8D%E5%8F%97%E9%99%90%E5%88%B6%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0a.strcpy%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%B7%E8%B4%9Db.strcat%E2%80%94%E2%80%94%E8%BF%BD%E5%8A%A0%E5%AD%97%E7%AC%A6%E4%B8%B2c.strcmp%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%AF%94%E8%BE%833.%E9%95%BF%E5%BA%A6%E5%8F%97%E9%99%90%E5%88%B6%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0%E2%80%94%E2%80%94strncopy%2Cstrncat%2Cstrncmp4.%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9F%A5%E6%89%BEa.strstr%E2%80%94%E2%80%94%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E4%B8%BA%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2b.strtok%E2%80%94%E2%80%94%E4%B8%80%E4%B8%AA%E5%A5%87%E6%80%AA%E7%9A%84%E5%87%BD%E6%95%B0c.%E9%94%99%E8%AF%AF%E4%BF%A1%E6%81%AF%E6%9F%A5%E6%89%BE%E2%80%94%E2%80%94strerror%E4%BA%8C.%E5%86%85%E5%AD%98%E5%87%BD%E6%95%B0%EF%BC%88%E4%B9%9F%E9%9C%80%E8%A6%81%E5%8C%85%E5%90%ABstring.h%EF%BC%891.%E5%86%85%E5%AD%98%E6%8B%B7%E8%B4%9D%E5%87%BD%E6%95%B0%E2%80%94%E2%80%94" rel="nofollow">二.内存函数</a></strong></h2> 
<p>        上面我们介绍了处理字符串的函数，但是对于其他类型，我们该如何处理呢？通过下面的内存函数的介绍，相信你会有所感悟！</p> 
<h3 id="1.%E5%86%85%E5%AD%98%E6%8B%B7%E8%B4%9D%E5%87%BD%E6%95%B0"><a href="#%E4%B8%80.%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0%28%E4%BD%BF%E7%94%A8%E9%83%BD%E9%9C%80%E8%A6%81%E5%8C%85%E5%90%ABstring.h%291.strlen%E2%80%94%E2%80%94%E6%B1%82%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%95%BF%E5%BA%A62.%E9%95%BF%E5%BA%A6%E4%B8%8D%E5%8F%97%E9%99%90%E5%88%B6%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0a.strcpy%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%B7%E8%B4%9Db.strcat%E2%80%94%E2%80%94%E8%BF%BD%E5%8A%A0%E5%AD%97%E7%AC%A6%E4%B8%B2c.strcmp%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%AF%94%E8%BE%833.%E9%95%BF%E5%BA%A6%E5%8F%97%E9%99%90%E5%88%B6%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0%E2%80%94%E2%80%94strncopy%2Cstrncat%2Cstrncmp4.%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9F%A5%E6%89%BEa.strstr%E2%80%94%E2%80%94%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E4%B8%BA%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2b.strtok%E2%80%94%E2%80%94%E4%B8%80%E4%B8%AA%E5%A5%87%E6%80%AA%E7%9A%84%E5%87%BD%E6%95%B0c.%E9%94%99%E8%AF%AF%E4%BF%A1%E6%81%AF%E6%9F%A5%E6%89%BE%E2%80%94%E2%80%94strerror%E4%BA%8C.%E5%86%85%E5%AD%98%E5%87%BD%E6%95%B0%EF%BC%88%E4%B9%9F%E9%9C%80%E8%A6%81%E5%8C%85%E5%90%ABstring.h%EF%BC%891.%E5%86%85%E5%AD%98%E6%8B%B7%E8%B4%9D%E5%87%BD%E6%95%B0%E2%80%94%E2%80%94" rel="nofollow">1.内存拷贝函数</a></h3> 
<h3 id="a.memcpy"><a href="#a.memmove" rel="nofollow">a</a><a href="#b.memcpy2.%E5%86%85%E5%AD%98%E5%A1%AB%E5%85%85%E5%87%BD%E6%95%B0%E2%80%94%E2%80%94memset3.%E5%86%85%E5%AD%98%E6%AF%94%E8%BE%83%E5%87%BD%E6%95%B0%E2%80%94%E2%80%94memcmp" rel="nofollow">.memcpy</a></h3> 
<p><strong>函数原型：</strong></p> 
<p><img alt="" height="151" src="https://images2.imgbox.com/7c/b2/fEncK2vE_o.png" width="770"></p> 
<p></p> 
<p><strong>注意事项：</strong><br>  这里的destination指向要在其中赋值内容的目标数组，source指向要复制的数据源，num是要复制的字节数，注意这里前两个指针的的类型还有函数返回值都是void*，这是因为，memcpy这个函数是内存拷贝函数，它有可能拷贝整型，浮点型，结构体等等各种类型的数据……虽然返回类型是void*，但他也是必不可少的，void*也表示一个地址，用户可以把它强制转换成自己需要的类型去使用。</p> 
<p><img alt="" height="297" src="https://images2.imgbox.com/62/ac/CUX68jvK_o.png" width="1062"></p> 
<p><img alt="" height="171" src="https://images2.imgbox.com/66/13/gqDUoiH7_o.png" width="1053"> <strong>函数的模拟实现：</strong></p> 
<pre><code>void* my_memcpy(void* dest, const void* src, size_t num)
{
	void* ret = dest;
	assert(dest &amp;&amp; src);
	//前-&gt;后
	while (num--)
	{
		*(char*)dest = *(char*)src;
		dest = (char*)dest + 1;
		src = (char*)src + 1;
	}
	return ret;
}</code></pre> 
<blockquote> 
 <p><strong> 注意：这里对于(char*)dest不能++或--，因为虽然强制转化类型，但是他的类型实质是没有改变的。</strong></p> 
</blockquote> 
<p><strong>然而，这个函数存在缺陷，就是当对于自己拷贝并且有重叠部分时，会出现bug</strong></p> 
<blockquote> 
 <p><strong>        如果我们只在一个字符串里操作就会出现问题。例如我想把arr1里的1，2，3，4，5拷贝到3，4，5，6，7上就，理论上arr1[]应该变为1，2，1，2，3，4，5，8，9。</strong></p> 
</blockquote> 
<p><strong>但是实际上：</strong></p> 
<p><img alt="" height="152" src="https://images2.imgbox.com/61/0e/Nuosrn5H_o.png" width="882"></p> 
<p>为了修改这个bug，大佬们又写出了memmove函数！</p> 
<h3 id="b.memmove"><a href="#b.memcpy2.%E5%86%85%E5%AD%98%E5%A1%AB%E5%85%85%E5%87%BD%E6%95%B0%E2%80%94%E2%80%94memset3.%E5%86%85%E5%AD%98%E6%AF%94%E8%BE%83%E5%87%BD%E6%95%B0%E2%80%94%E2%80%94memcmp" rel="nofollow">b</a><a href="#a.memmove" rel="nofollow">.memmove</a></h3> 
<p>函数原型和memcpy一样，作用也是一样的，不同的就是可以拷贝自己，并且重叠不会出bug！</p> 
<p>为什么之前的模拟实现会出现这个bug呢？</p> 
<p><img alt="" height="425" src="https://images2.imgbox.com/b9/3d/akfg3MYu_o.png" width="1024"></p> 
<p>原因是：当1拷贝到3上时，原来的3已经被1替换，当2拷贝到4上的时候，原来的4已将被2替换。所以当拷贝arr[2]到arr[4]上的时候，原本arr[2]里面存放的3已将被1替换了，同理，所以才得出了不符合我们预期的结果。那如何解决这个问题呢？先来分析这个问题产生的原因，这是因为源空间与目标空间之间有重叠，这里的arr[2]、arr[3]、arr[4]既是源空间也是目标空间，当拷贝1和2的时候把源空间中开没有拷贝的3和4就给覆盖了，此时源空间arr[2]和arr[3]里面存的就不再是3和4了，而是1和2，所以此时拷贝arr[2]和arr[3]里面的数据，其实拷贝的就是1和2。为了解决这个问题，我们可以从后往前拷贝，此时就不会出现这样的问题</p> 
<p>但是，我们从后往前拷贝就可以解决这个问题吗？答案是当然不是，比如：</p> 
<p><img alt="" height="357" src="https://images2.imgbox.com/74/a9/mHFWL5vW_o.png" width="672"></p> 
<p>所以我们需要分类讨论：</p> 
<p><img alt="" height="488" src="https://images2.imgbox.com/9a/84/0e8v4XSC_o.png" width="965"><strong> 模拟实现：</strong></p> 
<pre><code>void* my_memmove(void* dest, const void*src, size_t num)
{
	void* ret = dest;
	assert(dest &amp;&amp; src);
	if (dest &lt; src)
	{
		//前--&gt;后
		while (num--)
		{
			*(char*)dest = *(char*)src;
			dest = (char*)dest + 1;
			src = (char*)src + 1;
		}
	}
	else
	{
		//后-&gt;前
		while (num--)
		{
		 	*((char*)dest+num) = *((char*)src + num);
		}
	}

	return ret;
}</code></pre> 
<h2 id="2.%E5%86%85%E5%AD%98%E5%A1%AB%E5%85%85%E5%87%BD%E6%95%B0%E2%80%94%E2%80%94memset"><a href="#b.memcpy2.%E5%86%85%E5%AD%98%E5%A1%AB%E5%85%85%E5%87%BD%E6%95%B0%E2%80%94%E2%80%94memset3.%E5%86%85%E5%AD%98%E6%AF%94%E8%BE%83%E5%87%BD%E6%95%B0%E2%80%94%E2%80%94memcmp" rel="nofollow">2.内存填充函数——memset</a></h2> 
<p><img alt="" height="168" src="https://images2.imgbox.com/ba/92/mSOMDTYq_o.png" width="1082"><strong> 函数作用：</strong></p> 
<blockquote> 
 <p><strong>内存设置</strong> </p> 
</blockquote> 
<p><strong>注意事项：</strong></p> 
<ul><li>以字节为单位来设置内存中的数据，把从ptr开始往后的num个字节设置成value</li><li>形参value也可以是字符，字符其实也是整型，因为字符在内存中存的是其ASCII</li><li>value如果是整数的话，需要注意它的取值范围，因为一个字节最大可以存储255，超过255就会发生截断</li><li>由于这个函数是一个字节一个字节的改变，所以有些初始化是不成立的，比如对于整形数组初始化为1是不可能实现的，因为每个字节都变成01，一个整形事实上是一个很大的数字。所以对于整形数组初始化，一般都是初始化为0或-1.当然对于字符，不必担心，他本身也是一个字符一个字符改变的！</li></ul> 
<p><img alt="" height="190" src="https://images2.imgbox.com/83/05/sMYqwWzA_o.png" width="987"></p> 
<p></p> 
<h2><a href="#b.memcpy2.%E5%86%85%E5%AD%98%E5%A1%AB%E5%85%85%E5%87%BD%E6%95%B0%E2%80%94%E2%80%94memset3.%E5%86%85%E5%AD%98%E6%AF%94%E8%BE%83%E5%87%BD%E6%95%B0%E2%80%94%E2%80%94memcmp" rel="nofollow">3.内存比较函数——memcmp</a></h2> 
<p><strong>函数原型：</strong></p> 
<p><img alt="" height="130" src="https://images2.imgbox.com/82/19/6UVObORX_o.png" width="626"></p> 
<p><strong> 注意事项：</strong></p> 
<ul><li>比较从ptr1和ptr2指针开始的num个字节</li><li>两个内存块中不匹配的第一个字节在 ptr1 中的值低于 ptr2 中的值返回一个小于零的数子，相等返回零，两个内存块中不匹配的第一个字节在 ptr1 中的值大于在 ptr2 中的值返回一个大于零的数子</li></ul> 
<h2 id="%E6%80%BB%E7%BB%93%EF%BC%9A">总结：</h2> 
<p>本文通过函数使用的介绍来初步学习，函数的模拟实现来深刻理解了库函数的使用。辛苦各位小伙伴们动动小手，三连走一波<strong> </strong>最后，本文仍有许多不足之处，欢迎各位认真读完文章的小伙伴们随时私信交流、批评指正！</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c92087ace4f1293ba04d210146b0cba0/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">批量拉取/git pull 指定文件夹下面所有 Git 项目的最新代码</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8042dab6dc5af6e0cec7cbc34cc9b8e8/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Thymeleaf介绍</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>