<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>socket实现视频通话-WebRTC - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="socket实现视频通话-WebRTC" />
<meta property="og:description" content="最近喜欢研究视频流，所以思考了双向通信socket，接下来我们就一起来看看本地如何实现双向视频通讯的功能吧~
客户端获取视频流
首先思考如何获取视频流呢？
其实跟录音的功能差不多，都是查询电脑上是否有媒体设备，如果有录音和录像的设备，首先就需要授权，然后将视频流通过socket传输给服务端。
获取媒体设备
const stream = await navigator.mediaDevices.getUserMedia({ audio: true, video: true }) 因为是打视频的功能，那A客户端本身也希望看到A的摄像头，所以我们直接将其赋值给一个video标签，就能看到图像了.
&lt;p&gt;这是A页面&lt;/p&gt; &lt;div class=&#34;local-stream-page&#34;&gt; &lt;video autoplay controls muted id=&#34;elA&#34;&gt;&lt;/video&gt; &lt;button onclick=&#34;onStart()&#34;&gt;打视频给B页面&lt;/button&gt; &lt;/div&gt; &lt;script&gt; try { const stream = await navigator.mediaDevices.getUserMedia({ audio: true, video: true }) if (videoElA) { videoElA.srcObject = stream // 在 video 标签上播放媒体流 } peerInit(stream) // 初始化连接 } catch (error) { console.log(&#39;error：&#39;, error) } &lt;/script&gt; 然后就是重要部分了，我们需要用到WebRTC的API
RTCPeerConnection
RTCPeerConnection是WebRTC API中的一个对象，用于建立和管理两个或多个用户之间的实时通信。它允许通过互联网进行音频和视频通话，以及共享数据流。
RTCPeerConnection对象提供了一系列的方法和事件，用于配置、管理和控制媒体流的传输。它支持使用不同的技术，如ICE（Interactive Connectivity Establishment）和STUN（Session Traversal Utilities for NAT）来解决网络地址转换（NAT）问题，以便在防火墙后面的不同设备之间建立连接。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/36967e1251499d6fd534ce5e7f81b36d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-20T15:46:46+08:00" />
<meta property="article:modified_time" content="2024-01-20T15:46:46+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">socket实现视频通话-WebRTC</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>最近喜欢研究视频流，所以思考了双向通信socket，接下来我们就一起来看看本地如何实现双向视频通讯的功能吧~</p> 
<p>客户端获取视频流</p> 
<p>首先思考如何获取视频流呢？</p> 
<p>其实跟录音的功能差不多，都是查询电脑上是否有媒体设备，如果有录音和录像的设备，首先就需要授权，然后将视频流通过socket传输给服务端。</p> 
<p>获取媒体设备<br>  </p> 
<pre><code>const stream = await navigator.mediaDevices.getUserMedia({
  audio: true,
  video: true
})</code></pre> 
<p>因为是打视频的功能，那A客户端本身也希望看到A的摄像头，所以我们直接将其赋值给一个video标签，就能看到图像了.</p> 
<pre><code>&lt;p&gt;这是A页面&lt;/p&gt;

&lt;div class="local-stream-page"&gt;
  &lt;video autoplay controls muted id="elA"&gt;&lt;/video&gt;
  &lt;button onclick="onStart()"&gt;打视频给B页面&lt;/button&gt;
&lt;/div&gt;

&lt;script&gt;

  try {
    const stream = await navigator.mediaDevices.getUserMedia({
      audio: true,
      video: true
    })
    if (videoElA) {
      videoElA.srcObject = stream // 在 video 标签上播放媒体流
    }
    peerInit(stream) // 初始化连接
  } catch (error) {
    console.log('error：', error)
  }

&lt;/script&gt;</code></pre> 
<p>然后就是重要部分了，我们需要用到WebRTC的API</p> 
<p>RTCPeerConnection</p> 
<p>RTCPeerConnection是WebRTC API中的一个对象，用于建立和管理两个或多个用户之间的实时通信。它允许通过互联网进行音频和视频通话，以及共享数据流。</p> 
<p>RTCPeerConnection对象提供了一系列的方法和事件，用于配置、管理和控制媒体流的传输。它支持使用不同的技术，如ICE（Interactive Connectivity Establishment）和STUN（Session Traversal Utilities for NAT）来解决网络地址转换（NAT）问题，以便在防火墙后面的不同设备之间建立连接。</p> 
<p>使用RTCPeerConnection对象，您可以创建媒体流并将其发送到其他设备，也可以接收来自其他设备的媒体流。它还支持使用SDP（Session Description Protocol）描述媒体会话的配置，以及通过ICE和STUN协议协商和转发媒体数据包的路由。<br>  </p> 
<pre><code>const peerInit = stream =&gt; {
  // 1. 创建连接实例
  peerA = new RTCPeerConnection()
  // 2. 添加视频流轨道
  stream.getTracks().forEach(track =&gt; {
    peerA.addTrack(track, stream)
  })


  // peerA 端
  peerA.onicecandidate = event =&gt; {
    if (event.candidate) {
      socketA.send(JSON.stringify({ type: 'candid', data: event.candidate })) // socketA发送数据
    }
  }
  // 检测连接状态
  peerA.onconnectionstatechange = event =&gt; {
    if (peerA.connectionState === 'connected') {
      console.log('对等连接成功！')
    }
  }

  // 互换sdp认证
  transSDP()
}</code></pre> 
<p>到这里我们发送数据部分就是这样子啦，但是还不行，因为两者通视频，还需要SDP认证，什么是SDP认证呢？</p> 
<p>SDP（Session Description Protocol）认证是指通过在SDP协议中添加特定的信息来验证身份或其他属性的方法。SDP协议是一种用于描述多媒体会话的信息协议，它包含了音频、视频等媒体的编码格式、分辨率、网络地址等信息，用于在通话双方之间建立和维护媒体连接。</p> 
<p>在SDP认证中，通过在SDP协议中添加特定的信息，如用户名、会议ID等，双方可以互相验证身份。此外，还可以通过在SDP协议中包含数字签名或加密信息等技术来增强认证的安全性。</p> 
<p>SDP认证通常用于多媒体通信、视频会议等应用场景中，以确保通信的安全性和可信度。在SDP认证中，需要使用相应的协议或算法来验证SDP信息的来源和完整性，以确认身份或其他属性的合法性。</p> 
<p><strong>【免费分享】音视频学习资料包、大厂面试题、技术视频和学习路线图，资料包括（C/C++，Linux，FFmpeg webRTC rtmp hls rtsp ffplay srs 等等）有需要的可以点击788280672加群免费领取~</strong></p> 
<p></p> 
<p class="img-center"><img alt="" height="603" src="https://images2.imgbox.com/e1/11/AZbhrhWM_o.png" width="595"></p> 
<p>互换SDP认证<br>  </p> 
<pre><code>// peerA 端
const transSDP = async () =&gt; {
 
  let offer = await peerA.createOffer()
  // 向 peerB 传输 offer
  socketA.send(JSON.stringify({ type: 'offer', data: offer }))
  // 接收 peerB 传来的 answer
  socketA.onmessage = async evt =&gt; {
    
    let reader = new FileReader()
    reader.readAsText(evt.data, 'utf-8')
    reader.onload = async function() {
      let { type, data } = JSON.parse(reader.result)
      console.log(JSON.parse(reader.result), 111)
      if (type == 'answer') {
        await peerA.setLocalDescription(offer)
        await peerA.setRemoteDescription(data)
      }
    }
    
  }
}</code></pre> 
<p>这就是A客户端的全部代码啦~</p> 
<p>放心,全部代码文章末尾会给到.</p> 
<h3>node服务端socket传输</h3> 
<p>接下来我们来看看服务端是如何处理的.对了,这里必须说一下,两个socket之间的通信,必须要靠服务端管理,所以这就是为什么一定要学node的原因</p> 
<pre><code>const WebSocket = require('ws');

// 创建一个 WebSocket 服务器，监听 8080 端口
const wss = new WebSocket.Server({ port: 8000 });

// 当有客户端连接时，创建一个 WebSocket 并将其添加到客户端列表中
wss.on('connection', function connection(ws) {
  console.log('Client connected');

  // 当客户端发送消息时，将消息发送给所有客户端
  ws.on('message', function incoming(message) {
    console.log('Received message:', message.toString('utf8')); // 接受的对象，客户端发送的是字符串,Buffer

    // 将消息发送给所有客户端
    wss.clients.forEach(function each(client) {
      if (client !== ws &amp;&amp; client.readyState === WebSocket.OPEN) {
        client.send(message); // 客户端接受的是blob格式数据
      }
    });
  });

  // 当客户端断开连接时，将其从客户端列表中删除
  ws.on('close', function close() {
    console.log('Client disconnected');
  });
});</code></pre> 
<p>服务端用到了ws依赖, 如何区分两个不同的socket客户端, 特别是在同一个服务器下,同一个端口,不同的页面下,我发现必须要给两个socket一个唯一的标识才能做到,所以这期就先出功能,后面再继续补一下ws的源码学习.</p> 
<p>不过这里要区分清楚,这是将当前的client客户端发送给处理自己以外的,其他所以socket客户端,发送消息这里,就是一对多的关系哦.</p> 
<p>客户端接受视频流<br><br> 服务端处理完了,就进行下一个客户端如何接受视频流</p> 
<p>刚刚的sdp认证,肯定不止止A页面的事情,都说了是认证,那肯定通信双方需要知晓.</p> 
<p>这里有一个顺序问题<br> 1.首先是A页面创建offer---<a href="https://link.zhihu.com/?target=https%3A//link.juejin.cn/%3Ftarget%3Dhttps%253A%252F%252Fdeveloper.mozilla.org%252Fzh-CN%252Fdocs%252FWeb%252FAPI%252FRTCPeerConnection%252FcreateOffer" rel="nofollow" title="createOffer">createOffer</a><br> 2.然后是B页面设置远程描述---<a href="https://link.zhihu.com/?target=https%3A//link.juejin.cn/%3Ftarget%3Dhttps%253A%252F%252Fdeveloper.mozilla.org%252Fzh-CN%252Fdocs%252FWeb%252FAPI%252FRTCPeerConnection%252FsetRemoteDescription" rel="nofollow" title="setRemoteDescription">setRemoteDescription</a><br> 3.B页面生成发送到A页面的answer---createAnswer<br> 4.B页面设置本地描述---setLocalDescription<br> 5.A页面设置本地描述---setLocalDescription(传参是A页面的offer)<br> 6.A页面设备远程描述--setRemoteDescription(传参是B页面的answer)<br> 只要这上面6步都正常执行,B页面才能接收到A页面的视频流和音频流<br>  </p> 
<pre><code>const transSDP = async () =&gt; {
  // 1. 创建 offer
  let offer = await peerA.createOffer()
  await peerB.setRemoteDescription(offer)
  // 2. 创建 answer
  let answer = await peerB.createAnswer()
  await peerB.setLocalDescription(answer)
  // 3. 发送端设置 SDP
  await peerA.setLocalDescription(offer)
  await peerA.setRemoteDescription(answer)
}</code></pre> 
<p>加上socket之后就是这样</p> 
<p>不过既然是socket了,所以数据上要做转换处理,接收到的是blob数据</p> 
<p></p> 
<p class="img-center"><img alt="" height="284" src="https://images2.imgbox.com/87/c7/V0YT7oR7_o.png" width="568"></p> 
<p></p> 
<pre><code>// B接收A的消息
// peerB 端，接收 peerA 传来的 offer
socketB.onmessage = evt =&gt; {
  // console.log(evt.data)
  handleBlobToText(evt.data)
}

const handleBlobToText = (blob) =&gt; {
  let reader = new FileReader()
  reader.readAsText(blob, 'utf-8') // 接收到的是blob数据，先转成文本
  reader.onload = async function() {
    console.log(reader.result)
    let { type, data } = JSON.parse(reader.result) // 文本转对象
    console.log(JSON.parse(reader.result))
    if (type == 'offer') {
      await peerB.setRemoteDescription(data)
      console.log('2.然后是B页面设置远程描述', new Date().getTime())
      let answer = await peerB.createAnswer()
      console.log('3.B页面生成发送到A页面的answer', new Date().getTime())
      await peerB.setLocalDescription(answer)
      console.log('4.B页面设置本地描述', new Date().getTime())
      // 向 peerA 传输 answer
      socketB.send(JSON.stringify({ type: 'answer', data: answer }))
    }
    if (type == 'candid') {
      peerB.addIceCandidate(data)
    }
  }
}

socketB.onerror = function() {
  console.log('WebSocket error. Ready state:', socketB.readyState);
};</code></pre> 
<p></p> 
<p class="img-center"><img alt="" height="404" src="https://images2.imgbox.com/db/92/fj3WlgsT_o.png" width="720"></p> 
<p>根据时间戳,就能发现这六步的顺序.</p> 
<p>将接收到的视频流渲染到B页面的video标签中,这就能接受的A页面的视频流了.</p> 
<pre><code>const socketB = new WebSocket('ws://localhost:8000');

const peerB = new RTCPeerConnection()
const videoElB = document.getElementById('elB')

// 监听数据传来
peerB.ontrack = async event =&gt; {
  const [remoteStream] = event.streams
  videoElB.srcObject = remoteStream
}</code></pre> 
<h3>效果</h3> 
<p>这就是两个页面视频通讯的结果如下：</p> 
<p></p> 
<p class="img-center"><img alt="" height="300" src="https://images2.imgbox.com/65/24/6BulTfu0_o.png" width="720"></p> 
<p>全部源码已经上传在GitHub上啦~</p> 
<p><a href="https://link.zhihu.com/?target=https%3A//link.juejin.cn/%3Ftarget%3Dhttps%253A%252F%252Fgithub.com%252F0522skylar%252FwebRTC-video" rel="nofollow" title="github.com/0522skylar/…">github.com/0522skylar/…</a></p> 
<p></p> 
<p>原文链接 <a href="https://link.zhihu.com/?target=https%3A//juejin.cn/post/7319319374045364224%3FsearchId%3D20240119162534983D346AF359623C8178" rel="nofollow" title="socket实现视频通话-WebRTC - 掘金">socket实现视频通话-WebRTC - 掘金</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2121711b4f02383937ff1b36c469cdf9/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【Java】数据库连接池--Druid</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9081cdb5327c82df94c0297d12d36bf4/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">C语言从入门到实战——文件操作</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>