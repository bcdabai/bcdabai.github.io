<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>学C&#43;&#43;从Cmake学起 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="学C&#43;&#43;从Cmake学起" />
<meta property="og:description" content="文章目录 1.构建系统make2.构建系统CMake3.CMake的常见命令行调用4.CMakeLists.txt常见语法5.为什么需要库library?6.CMake 中的静态库与动态库（1）add_library（2）动态库的符号隐藏方式（3）position-independent code (PIC) 编译动态库 .so（4）生成动态库的 SO-NAME（5）include_directories，link_directories，link_libraries和target_link_libraries解析（6）–no-copy-dt-needed-entries问题 7.为什么 C&#43;&#43; 需要声明8.为什么需要头文件？9.CMake 中的子模块（1）子模块的头文件如何处理（2）总结 11.目标的一些其他选项12.第三方库 - 作为纯头文件引入13.第三方库 - 作为子模块引入14.CMake - 引用系统中预安装的第三方库15.安装第三方库 - 包管理器（1） arch的pacman（2）ubuntu apt-get（3）vcpkg（4）CMake 添加第三方库依赖方式git submodule、 find_library、FetchContent、CPM等 1.构建系统make 2.构建系统CMake 为了解决make的以上问题，跨平台的Cmake应运而生只需要写一份CmakeLists.txt，它就能在调用时生成当前系统所支持的构建系统CMake可以自动检测源文件和头文件之间的依赖关系，导出到Makefile里面CMake具有相对高级的语法，内置的函数能够处理configure,install等常见需求CMake可以自动检测当前的编译器，需要添加哪些flag，必须OpenMP，只需要在CMakeLists,txt中指明target_link_libraries(a.out OpenMP::OpenMP_CXX)即可 3.CMake的常见命令行调用 生成构建文件Makefile 表示输出makefile文件的目录 表示试用clang&#43;&#43;作为编译器 cmake -Bbuild -DCMAKE_CXX_COMPILER=clang&#43;&#43; cmake -Bbuild -DCMAKE_CXX_COMPILER=clang&#43;&#43; -DCMAKE_CXX_STANDARD=17 构建可执行文件，编译 cd build;make 或者make -C build，优点是：跨平台 或者cmake --build build 4.CMakeLists.txt常见语法 add_executable(输出的可执行文件 输入的多个源文件) add_executable(a.out main.cpp hello.cpp) add_library(test STATIC source1.cpp source2.cpp) # 生成静态库 libtest.a add_library(test SHARED source1.cpp source2.cpp) # 生成动态库 libtest." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/7264a04758fabc6190e3c2fdf842b98e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-02-13T11:05:58+08:00" />
<meta property="article:modified_time" content="2023-02-13T11:05:58+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">学C&#43;&#43;从Cmake学起</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><ul><li><a href="#1make_1" rel="nofollow">1.构建系统make</a></li><li><a href="#2CMake_5" rel="nofollow">2.构建系统CMake</a></li><li><a href="#3CMake_12" rel="nofollow">3.CMake的常见命令行调用</a></li><li><a href="#4CMakeListstxt_25" rel="nofollow">4.CMakeLists.txt常见语法</a></li><li><a href="#5library_39" rel="nofollow">5.为什么需要库library?</a></li><li><a href="#6CMake__58" rel="nofollow">6.CMake 中的静态库与动态库</a></li><li><ul><li><a href="#1add_library_59" rel="nofollow">（1）add_library</a></li><li><a href="#2_86" rel="nofollow">（2）动态库的符号隐藏方式</a></li><li><a href="#3positionindependent_code_PIC__so_164" rel="nofollow">（3）position-independent code (PIC) 编译动态库 .so</a></li><li><a href="#4_SONAME_186" rel="nofollow">（4）生成动态库的 SO-NAME</a></li><li><a href="#5include_directorieslink_directorieslink_librariestarget_link_libraries_250" rel="nofollow">（5）include_directories，link_directories，link_libraries和target_link_libraries解析</a></li><li><a href="#6nocopydtneededentries_275" rel="nofollow">（6）–no-copy-dt-needed-entries问题</a></li></ul> 
   </li><li><a href="#7_C__379" rel="nofollow">7.为什么 C++ 需要声明</a></li><li><a href="#8_394" rel="nofollow">8.为什么需要头文件？</a></li><li><a href="#9CMake__420" rel="nofollow">9.CMake 中的子模块</a></li><li><ul><li><a href="#1_429" rel="nofollow">（1）子模块的头文件如何处理</a></li><li><a href="#2_444" rel="nofollow">（2）总结</a></li></ul> 
   </li><li><a href="#11_486" rel="nofollow">11.目标的一些其他选项</a></li><li><a href="#12___506" rel="nofollow">12.第三方库 - 作为纯头文件引入</a></li><li><a href="#13___524" rel="nofollow">13.第三方库 - 作为子模块引入</a></li><li><a href="#14CMake___549" rel="nofollow">14.CMake - 引用系统中预安装的第三方库</a></li><li><a href="#15___583" rel="nofollow">15.安装第三方库 - 包管理器</a></li><li><ul><li><a href="#1_archpacman_584" rel="nofollow">（1） arch的pacman</a></li><li><a href="#2ubuntu_aptget_591" rel="nofollow">（2）ubuntu apt-get</a></li><li><a href="#3vcpkg_594" rel="nofollow">（3）vcpkg</a></li><li><a href="#4CMake_git_submodule_find_libraryFetchContentCPM_620" rel="nofollow">（4）CMake 添加第三方库依赖方式git submodule、 find_library、FetchContent、CPM等</a></li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h3><a id="1make_1"></a>1.构建系统make</h3> 
<h3><a id="2CMake_5"></a>2.构建系统CMake</h3> 
<ul><li>为了解决make的以上问题，跨平台的Cmake应运而生</li><li>只需要写一份CmakeLists.txt，它就能在调用时生成当前系统所支持的构建系统</li><li>CMake可以自动检测源文件和头文件之间的依赖关系，导出到Makefile里面</li><li>CMake具有相对高级的语法，内置的函数能够处理configure,install等常见需求</li><li>CMake可以自动检测当前的编译器，需要添加哪些flag，必须OpenMP，只需要在CMakeLists,txt中指明target_link_libraries(a.out OpenMP::OpenMP_CXX)即可</li></ul> 
<h3><a id="3CMake_12"></a>3.CMake的常见命令行调用</h3> 
<pre><code class="prism language-bash">生成构建文件Makefile
表示输出makefile文件的目录
表示试用clang++作为编译器
cmake <span class="token parameter variable">-Bbuild</span>  <span class="token parameter variable">-DCMAKE_CXX_COMPILER</span><span class="token operator">=</span>clang++
cmake <span class="token parameter variable">-Bbuild</span>  <span class="token parameter variable">-DCMAKE_CXX_COMPILER</span><span class="token operator">=</span>clang++ <span class="token parameter variable">-DCMAKE_CXX_STANDARD</span><span class="token operator">=</span><span class="token number">17</span>

构建可执行文件，编译
<span class="token builtin class-name">cd</span> build<span class="token punctuation">;</span><span class="token function">make</span>
或者make <span class="token parameter variable">-C</span> build，优点是：跨平台
或者cmake <span class="token parameter variable">--build</span> build
</code></pre> 
<h3><a id="4CMakeListstxt_25"></a>4.CMakeLists.txt常见语法</h3> 
<pre><code class="prism language-bash">add_executable<span class="token punctuation">(</span>输出的可执行文件 输入的多个源文件<span class="token punctuation">)</span>
add_executable<span class="token punctuation">(</span>a.out main.cpp hello.cpp<span class="token punctuation">)</span>

add_library<span class="token punctuation">(</span>test STATIC source1.cpp source2.cpp<span class="token punctuation">)</span>  <span class="token comment"># 生成静态库 libtest.a</span>
add_library<span class="token punctuation">(</span>test SHARED source1.cpp source2.cpp<span class="token punctuation">)</span>  <span class="token comment"># 生成动态库 libtest.so</span>

创建库以后，要在某个可执行文件中使用该库，只需要：
target_link_libraries<span class="token punctuation">(</span>myexec PUBLIC <span class="token builtin class-name">test</span><span class="token punctuation">)</span>  <span class="token comment"># 为 myexec 链接刚刚制作的库 libtest.a</span>

</code></pre> 
<h3><a id="5library_39"></a>5.为什么需要库library?</h3> 
<p>有时候我们会有多个可执行文件，他们之间用到的某些功能是相同的，我们想把这些共用的功能做成一个库，方便大家一起共享.</p> 
<ul><li>静态库和动态库都是多个.o文件的打包</li><li>库中的函数可以被可执行文件调用，也可以被其他库文件调用。</li><li>库文件又分为静态库文件和动态库文件。</li><li>其中静态库相当于直接把代码插入到生成的可执行文件中，会导致体积变大，但是只需要一个文件即可运行.</li><li><strong>而动态库则只在生成的可执行文件中生成“插桩”函数</strong>，当可执行文件被加载时会读取指定目录中的.dll文件，加载到内存中空闲的位置，并且替换相应的“ 插桩”指向的地址为加载后的地址，<strong>这个过程称为重定向。</strong><br> 这样以后函数被调用就会跳转到动态加载的地址去。<br> <img src="https://images2.imgbox.com/61/fb/MwBApFGD_o.png" alt="在这里插入图片描述"></li><li>eg：以course/01/05/hello.cpp为例：objdump -D ./build/a.out |less<br> 插装函数puts如下，可跳转到libc.so库中，<strong>plt就是插装函数</strong><img src="https://images2.imgbox.com/5e/35/n2u3qvhm_o.png" alt="在这里插入图片描述"></li></ul> 
<p>Windows:</p> 
<ul><li>可执行文件同目录，其次是环境变量%PATH%</li></ul> 
<p>Linux:</p> 
<ul><li>ELF格式可执行文件的RPATH，其次是/usr/lib等</li></ul> 
<h3><a id="6CMake__58"></a>6.CMake 中的静态库与动态库</h3> 
<h4><a id="1add_library_59"></a>（1）add_library</h4> 
<p>CMake 除了 add_executable 可以生成可执行文件外，还可以通过 add_library 生成库文件。</p> 
<pre><code class="prism language-bash">add_library 的语法与 add_executable 大致相同，除了他需要指定是动态库还是静态库：
add_library<span class="token punctuation">(</span>test STATIC source1.cpp source2.cpp<span class="token punctuation">)</span>  <span class="token comment"># 生成静态库 libtest.a</span>
add_library<span class="token punctuation">(</span>test SHARED source1.cpp source2.cpp<span class="token punctuation">)</span>  <span class="token comment"># 生成动态库 libtest.so</span>
</code></pre> 
<ul><li>动态库有很多坑，特别是 Windows 环境下，初学者自己创建库时，建议使用静态库。</li><li>创建库以后，要在某个可执行文件中使用该库，只需要：</li></ul> 
<pre><code class="prism language-bash">target_link_libraries<span class="token punctuation">(</span>myexec PUBLIC <span class="token builtin class-name">test</span><span class="token punctuation">)</span>  <span class="token comment"># 为 myexec 链接刚刚制作的库 libtest.a</span>
其中 PUBLIC 的含义稍后会说明（CMake 中有很多这样的大写修饰符）
</code></pre> 
<ul><li>eg：course/01/06<br> 动态库必须在可执行文件的同目录或者系统目录下，可执行程序才能运行；<br> <img src="https://images2.imgbox.com/2b/29/7uwgA2kk_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/46/aa/swoh0iq4_o.png" alt="在这里插入图片描述"><br> 静态库则无所谓，静态库是将实现hello()直接放在a.out中，它不需要动态查找，但是可执行文件会变大<br> objdump -D ./build/a.out |less<br> <img src="https://images2.imgbox.com/88/be/TRT2eQhl_o.png" alt="在这里插入图片描述"></li></ul> 
<h4><a id="2_86"></a>（2）动态库的符号隐藏方式</h4> 
<ul><li>ref：<a href="http://blog.guorongfei.com/2018/04/11/symbol-visibility/" rel="nofollow">一种跨平台的C/C++动态库的符号隐藏方式</a>|</li></ul> 
<p>什么是符号隐藏？</p> 
<ul><li><strong>在同一个文件中</strong>，如果有一些函数我们并不想要让外部访问，我们通常会添加 static 修饰符，把它设置为内部链接属性。</li><li><strong>但是通常库</strong>不太可能是单文件组成，这些文件中有些是做接口给外部使用，有些则单纯的只是库的内部实现。对于外部使用者来说，内部实现的这些符号没有实际的作用，理论上我们完全可以像对待文件内部符号一样把它们统统隐藏掉。</li></ul> 
<p>符号隐藏的作用</p> 
<blockquote> 
 <p>安全，去掉不必要的符号，可以增加逆向破解的难度。<br> 压缩空间，符号实际上是放在 dll 中的，去掉这些符号可以缩减 dll 的大小<br> 性能，符号隐藏掉意味着它不会参与到动态链接过程，编译器可以有更大的优化空间，可能会产生更好的性能。</p> 
</blockquote> 
<p>做法：</p> 
<pre><code class="prism language-cpp"><span class="token function">set_target_properties</span><span class="token punctuation">(</span>mylib
    PROPERTIES CXX_VISIBILITY_PRESET hidden
<span class="token punctuation">)</span>

<span class="token operator">or</span>
<span class="token function">set</span><span class="token punctuation">(</span>CMAKE_CXX_VISIBILITY_PRESET hidden<span class="token punctuation">)</span>
</code></pre> 
<p>然后将公开的接口设置__attribute__ ((visibility (“default”)))即可</p> 
<ul><li>mylib.h</li></ul> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">pragma</span> <span class="token expression">once</span></span>

<span class="token keyword">void</span> <span class="token function">__attribute__</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">visibility</span><span class="token punctuation">(</span><span class="token string">"default"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token function">say_hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>通常会定义宏来协助处理这一部分内容</p> 
<ul><li>下面是来自GCC WIKI的一个模板</li></ul> 
<pre><code class="prism language-cpp"><span class="token comment">// Generic helper definitions for shared library support</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression">defined _WIN32 <span class="token operator">||</span> defined __CYGWIN__</span></span>
  <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">FOX_HELPER_DLL_IMPORT</span> <span class="token expression"><span class="token function">__declspec</span><span class="token punctuation">(</span>dllimport<span class="token punctuation">)</span></span></span>
  <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">FOX_HELPER_DLL_EXPORT</span> <span class="token expression"><span class="token function">__declspec</span><span class="token punctuation">(</span>dllexport<span class="token punctuation">)</span></span></span>
  <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">FOX_HELPER_DLL_LOCAL</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span></span>
  <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression">__GNUC__ <span class="token operator">&gt;=</span> <span class="token number">4</span></span></span>
    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">FOX_HELPER_DLL_IMPORT</span> <span class="token expression"><span class="token function">__attribute__</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">visibility</span> <span class="token punctuation">(</span></span><span class="token string">"default"</span><span class="token expression"><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span></span>
    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">FOX_HELPER_DLL_EXPORT</span> <span class="token expression"><span class="token function">__attribute__</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">visibility</span> <span class="token punctuation">(</span></span><span class="token string">"default"</span><span class="token expression"><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span></span>
    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">FOX_HELPER_DLL_LOCAL</span>  <span class="token expression"><span class="token function">__attribute__</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">visibility</span> <span class="token punctuation">(</span></span><span class="token string">"hidden"</span><span class="token expression"><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span></span>
  <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span></span>
    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">FOX_HELPER_DLL_IMPORT</span></span>
    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">FOX_HELPER_DLL_EXPORT</span></span>
    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">FOX_HELPER_DLL_LOCAL</span></span>
  <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>

<span class="token comment">// Now we use the generic helper definitions above to define FOX_API and FOX_LOCAL.</span>
<span class="token comment">// FOX_API is used for the public API symbols. It either DLL imports or DLL exports (or does nothing for static build)</span>
<span class="token comment">// FOX_LOCAL is used for non-api symbols.</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">FOX_DLL </span><span class="token comment">// defined if FOX is compiled as a DLL</span></span>
  <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">FOX_DLL_EXPORTS </span><span class="token comment">// defined if we are building the FOX DLL (instead of using it)</span></span>
    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">FOX_API</span> <span class="token expression">FOX_HELPER_DLL_EXPORT</span></span>
  <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span></span>
    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">FOX_API</span> <span class="token expression">FOX_HELPER_DLL_IMPORT</span></span>
  <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span> <span class="token comment">// FOX_DLL_EXPORTS</span></span>
  <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">FOX_LOCAL</span> <span class="token expression">FOX_HELPER_DLL_LOCAL</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span> <span class="token comment">// FOX_DLL is not defined: this means FOX is a static lib.</span></span>
  <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">FX_API</span></span>
  <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">FOX_LOCAL</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span> <span class="token comment">// FOX_DLL</span></span>
</code></pre> 
<p>使用方法：</p> 
<ul><li>在编译动态库的时候，设置FOX_DLL和FOX_DLL_EXPORTS这两个宏</li></ul> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">FOX_API</span> Fox <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<h4><a id="3positionindependent_code_PIC__so_164"></a>（3）position-independent code (PIC) 编译动态库 .so</h4> 
<ul><li>ref：<a href="https://blog.csdn.net/zhizhengguan/article/details/115323750?spm=1001.2101.3001.6650.16&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-16-115323750-blog-87967389.pc_relevant_aa&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-16-115323750-blog-87967389.pc_relevant_aa">cmake：POSITION_INDEPENDENT_CODE</a></li></ul> 
<p>position-independent code (PIC)：</p> 
<ul><li>用于生成位置无关代码。位置无关代码，可以理解为代码无绝对跳转，跳转都为相对跳转。<strong>生成动态库时，需要加上-fPIC选项。</strong></li></ul> 
<p>有-fPIC选项好处：</p> 
<blockquote> 
 <p>1）添加 -fPIC 选项实现真正意义上的多个进程共享 .so 库。多个进程引用同一个 -fPIC 动态库时，可以共用内存。这一个库在不同进程中的虚拟地址不同，操作系统会把它们映射到同一块物理内存上。<br> 2）不添加 -fPIC 选项，加载 .so 库时，需要对代码段引用的数据对象重定位，重定位会修改代码段的内容，造成每个使用这个 .so 文件代码段的进程在内核里都会生成这个 .so 文件代码段的 copy，每个 copy 都不一样，取决于这个 .so 文件代码段和数据段内存映射的位置。不添加 -fPIC 选项，消耗内存，编译的.so文件的优点是加载速度快。</p> 
</blockquote> 
<p>用法：</p> 
<pre><code class="prism language-cpp"><span class="token function">add_library</span><span class="token punctuation">(</span>mylib SHARED ##<span class="token punctuation">.</span>cc）
<span class="token function">set_target_properties</span><span class="token punctuation">(</span>mylib PROPERTIES POSITION_INDEPENDENT_CODE ON<span class="token punctuation">)</span>

其他：若编译成静态库，也不会报错：
<span class="token function">add_library</span><span class="token punctuation">(</span>mylib STATIC ##<span class="token punctuation">.</span>cc）
<span class="token function">set_target_properties</span><span class="token punctuation">(</span>mylib PROPERTIES POSITION_INDEPENDENT_CODE ON<span class="token punctuation">)</span>
</code></pre> 
<h4><a id="4_SONAME_186"></a>（4）生成动态库的 SO-NAME</h4> 
<ul><li>ref：<a href="https://zhuanlan.zhihu.com/p/365882107" rel="nofollow">cmake：生成动态库的 SO-NAM</a><br> 静态库没有SO-NAME</li></ul> 
<p>Linux共享库的文件命名规则必须如下：</p> 
<blockquote> 
 <p>libname.so.x.y.z<br> 最前面使用前缀lib，中间为库的名字，后缀为.so，后面跟着 3 个数字组成的版本号。"x"表示**主版本号，"y"表示次版本号，"z"表示发布版本号。各版本号含义如下：</p> 
</blockquote> 
<blockquote> 
 <p>主版本号表示库的重大升级，不同主版本号的库之间是不兼容的；</p> 
</blockquote> 
<blockquote> 
 <p>次版本号表示库的增量升级，即增加一些新的接口符号，且保持原有符号不变；</p> 
</blockquote> 
<blockquote> 
 <p>发布版本号表示库的一些错误修正、性能的改进等，并不增加任何新的接口，也不对接口进行更改。相同主、次版本号，不同发布版本号的库之间完全兼容，依赖于某个发布版号的程序可以在任何一个其他发布版本号中正常运行，而无需做任何修改。</p> 
</blockquote> 
<p><strong>现在的 Linux 中也存在不少不遵守上述规定的"顽固份子"，比如最基本的 C 语言库——Glibc。</strong></p> 
<p>SO-NAME作用：</p> 
<ul><li>这个“SO-NAME“即共享库的文件名去掉次版本号和发布版本号，保留主版本号的名称。<strong>比如 libfoo.so.2.6.1 的 SO-NAME 为 libfoo.so.2</strong></li><li>建立以 SO-NAME 为名字的软链接的目的是使得所有依赖某个共享库的模块，在编译、链接和运行时，都使用共享库的 SO-NAME，而不是使用详细的版本号。</li></ul> 
<p>用法：</p> 
<ul><li>这里主要使用的是 set_target_properties()命令及其 PROPERTIES 中的 VERSION 和 SOVERSION 参数。其中 VERSION指定库的完整版本号，SOVERSION 指定库的 SONAME。</li></ul> 
<pre><code class="prism language-cpp"><span class="token function">project</span><span class="token punctuation">(</span>test<span class="token punctuation">)</span>
<span class="token function">cmake_minimum_required</span><span class="token punctuation">(</span>VERSION <span class="token number">3.16</span><span class="token punctuation">)</span>

<span class="token function">add_library</span><span class="token punctuation">(</span>mylib SHARED $<span class="token punctuation">{<!-- --></span>CMAKE_CURRENT_SOURCE_DIR<span class="token punctuation">}</span><span class="token operator">/</span>lib<span class="token operator">/</span>mylib<span class="token punctuation">.</span>cpp<span class="token punctuation">)</span>
<span class="token function">target_include_directories</span><span class="token punctuation">(</span>mylib PUBLIC $<span class="token punctuation">{<!-- --></span>CMAKE_CURRENT_SOURCE_DIR<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token function">set_target_properties</span><span class="token punctuation">(</span>xx
    PROPERTIES CXX_VISIBILITY_PRESET hidden
<span class="token punctuation">)</span>

<span class="token function">set_target_properties</span><span class="token punctuation">(</span>mylib PROPERTIES POSITION_INDEPENDENT_CODE ON<span class="token punctuation">)</span>

<span class="token function">set_target_properties</span><span class="token punctuation">(</span>mylib PROPERTIES VERSION <span class="token number">1.0</span><span class="token punctuation">.</span><span class="token number">0</span> SOVERSION <span class="token number">1</span><span class="token punctuation">)</span>
</code></pre> 
<p>测试：</p> 
<pre><code class="prism language-bash">
wangji@script-wang:~/code/test/my_course/course/11/03_library/04$ ll build/
total <span class="token number">96</span>
drwxr-xr-x <span class="token number">3</span> wangji wangji  <span class="token number">4096</span> Feb <span class="token number">13</span> <span class="token number">10</span>:11 ./
drwxr-xr-x <span class="token number">5</span> wangji wangji  <span class="token number">4096</span> Feb <span class="token number">13</span> <span class="token number">10</span>:10 <span class="token punctuation">..</span>/
-rw-r--r-- <span class="token number">1</span> wangji wangji <span class="token number">14172</span> Feb <span class="token number">13</span> <span class="token number">10</span>:11 CMakeCache.txt
drwxr-xr-x <span class="token number">8</span> wangji wangji  <span class="token number">4096</span> Feb <span class="token number">13</span> <span class="token number">10</span>:11 CMakeFiles/
-rw-r--r-- <span class="token number">1</span> wangji wangji  <span class="token number">9698</span> Feb <span class="token number">13</span> <span class="token number">10</span>:11 Makefile
-rw-r--r-- <span class="token number">1</span> wangji wangji  <span class="token number">2740</span> Feb <span class="token number">13</span> <span class="token number">10</span>:11 cmake_install.cmake
lrwxrwxrwx <span class="token number">1</span> wangji wangji    <span class="token number">13</span> Feb <span class="token number">13</span> <span class="token number">10</span>:11 libmylib.so -<span class="token operator">&gt;</span> libmylib.so.1*
lrwxrwxrwx <span class="token number">1</span> wangji wangji    <span class="token number">17</span> Feb <span class="token number">13</span> <span class="token number">10</span>:11 libmylib.so.1 -<span class="token operator">&gt;</span> libmylib.so.1.0.0*

wangji@script-wang:~/code/test/my_course/course/11/03_library/04$ ldd build/main 
        linux-vdso.so.1 <span class="token punctuation">(</span>0x00007ffc7ffb5000<span class="token punctuation">)</span>
        libmylib.so.1 <span class="token operator">=</span><span class="token operator">&gt;</span> /home/wangji/code/test/my_course/course/11/03_library/04/build/libmylib.so.1 <span class="token punctuation">(</span>0x00007f8aeca92000<span class="token punctuation">)</span>
        libc.so.6 <span class="token operator">=</span><span class="token operator">&gt;</span> /lib/x86_64-linux-gnu/libc.so.6 <span class="token punctuation">(</span>0x00007f8aec888000<span class="token punctuation">)</span>
        /lib64/ld-linux-x86-64.so.2 <span class="token punctuation">(</span>0x00007f8aeca9e000<span class="token punctuation">)</span>
</code></pre> 
<h4><a id="5include_directorieslink_directorieslink_librariestarget_link_libraries_250"></a>（5）include_directories，link_directories，link_libraries和target_link_libraries解析</h4> 
<p>INCLUDE_DIRECTORIES（添加头文件目录）</p> 
<blockquote> 
 <p>它相当于g++选项中的-I参数的作用，也相当于环境变量中增加路径到CPLUS_INCLUDE_PATH变量的作用<br> 比如：include_directories(“/opt/MATLAB/R2012a/extern/include”)<br> export CPLUS_INCLUDE_PATH=$CPLUS_INCLUDE_PATH:$MATLAB/extern/include</p> 
</blockquote> 
<p>LINK_DIRECTORIES（添加需要链接的库文件目录）</p> 
<blockquote> 
 <p>link_directories(directory1 directory2 …)<br> 它相当于g++命令的-L选项的作用，也相当于环境变量中增加LD_LIBRARY_PATH的路径的作用。<br> LINK_DIRECTORIES(“/opt/MATLAB/R2012a/bin/glnxa64”)<br> export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/opt/MATLAB/R2012a/bin/glnxa64</p> 
</blockquote> 
<p>LINK_LIBRARIES（添加需要链接的库文件路径，注意这里是库的全路径）</p> 
<blockquote> 
 <p>LINK_LIBRARIES(“/opt/MATLAB/R2012a/bin/glnxa64/libmx.so”)</p> 
</blockquote> 
<p>TARGET_LINK_LIBRARIES （设置要链接的库文件的名称）</p> 
<blockquote> 
 <p>TARGET_LINK_LIBRARIES(myProject hello)，连接libhello.so库</p> 
</blockquote> 
<h4><a id="6nocopydtneededentries_275"></a>（6）–no-copy-dt-needed-entries问题</h4> 
<ul><li>ref：<a href="https://blog.csdn.net/kl1125290220/article/details/103081969">Linux动态库依赖其它动态库的问题</a></li></ul> 
<p>DSO missing from command line问题：</p> 
<ul><li>前置条件</li></ul> 
<blockquote> 
 <p>libA.so在编译过程中显式的链接了libB.so<br> 可执行文件中使用了libB.so的函数<br> binuntils版本 ≥ 2.22</p> 
</blockquote> 
<ul><li>eg：仅供参考，下面的代码写法不符合C++的写法规范<br> libB.so</li></ul> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">funB1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>

    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"in funB1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">funB2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>

    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"in funB2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>


</code></pre> 
<p>编译libB.so:</p> 
<ul><li>该库中只有一个函数funA1，该函数在内部调用了libB中的funB1函数。且该函数会被可执行文件调用。</li></ul> 
<pre><code class="prism language-bash">$ gcc libB.cpp <span class="token parameter variable">-fPIC</span> <span class="token parameter variable">-shared</span> <span class="token parameter variable">-o</span> libB.so
</code></pre> 
<p>libA.so的源码：</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">funB1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">funA1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>

    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"in funA1 \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">funB1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>编译libA.so:</p> 
<pre><code class="prism language-cpp">$ gcc libA<span class="token punctuation">.</span>cpp <span class="token operator">-</span>fPIC <span class="token operator">-</span>shared <span class="token operator">-</span>o libA<span class="token punctuation">.</span>so <span class="token operator">-</span>Wl<span class="token punctuation">,</span><span class="token operator">-</span>rpath<span class="token operator">=</span><span class="token punctuation">.</span><span class="token operator">/</span> <span class="token operator">-</span>L<span class="token punctuation">.</span><span class="token operator">/</span> <span class="token operator">-</span>lB
</code></pre> 
<p>main.cpp</p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token function">funA1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">funB2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>

    <span class="token function">funA1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">funB2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>编译main.cpp</p> 
<pre><code class="prism language-bash">gcc main.cpp -L./ <span class="token parameter variable">-lA</span>
/usr/bin/ld: /tmp/ccDQXTKy.o: undefined reference to symbol <span class="token string">'_Z5funB2v'</span>
.//libB.so: error adding symbols: DSO missing from <span class="token builtin class-name">command</span> line
collect2: error: ld returned <span class="token number">1</span> <span class="token builtin class-name">exit</span> status

$ ldd libA.so
linux-vdso.so.1 <span class="token operator">=</span><span class="token operator">&gt;</span>  <span class="token punctuation">(</span>0x00007ffd09def000<span class="token punctuation">)</span>
	libB.so <span class="token operator">=</span><span class="token operator">&gt;</span> ./libB.so <span class="token punctuation">(</span>0x00007fc513d7d000<span class="token punctuation">)</span>
	libc.so.6 <span class="token operator">=</span><span class="token operator">&gt;</span> /lib/x86_64-linux-gnu/libc.so.6 <span class="token punctuation">(</span>0x00007fc5139b3000<span class="token punctuation">)</span>
	/lib64/ld-linux-x86-64.so.2 <span class="token punctuation">(</span>0x00007fc514181000<span class="token punctuation">)</span>

这里已经显示链接了libB.so，但是编译器要我们显式的链接libB.so？
</code></pre> 
<p>这是binutils在2.22版本以后，默认把–no-copy-dt-needed-entries这个选项打开了。当打开了这个选项的时候，编译器在链接的时候是不会递归的去获取依赖动态库的依赖项的，于是就会出现上述的问题。</p> 
<pre><code class="prism language-bash">$ gcc main.cpp -L./ -Wl,--copy-dt-needed-entries <span class="token parameter variable">-lA</span>
</code></pre> 
<p>Cmake用法：</p> 
<pre><code class="prism language-bash">cmake使用方法“set<span class="token punctuation">(</span>CMAKE_EXE_LINKER_FLAGS “-Wl,–copy-dt-needed-entries”<span class="token punctuation">)</span>
</code></pre> 
<h3><a id="7_C__379"></a>7.为什么 C++ 需要声明</h3> 
<p>在多文件编译章中，说到了需要在 main.cpp 声明 hello() 才能引用。为什么？</p> 
<ul><li>因为需要知道函数的<strong>参数和返回值类型：这样才能支持重载，隐式类型转换等特性。</strong><br> 例如 show(3)，如果声明了 void show(float x)，那么编译器知道把 3 转换成 3.0f 才能调用。</li><li>让编译器知道 hello 这个名字是一个函数，不是一个变量或者类的名字：这样当我写下 hello() 的时候，他知道我是想调用 hello 这个函数，而不是创建一个叫 hello 的类的对象。</li></ul> 
<p><strong>其实，C++ 是一种强烈依赖上下文信息的编程语言，</strong></p> 
<ul><li>举个例子：<br> vector &lt; MyClass &gt; a; // 声明一个由 MyClass 组成的数组<br> 如果编译器不知道 vector 是个模板类，那他完全可以把 vector 看做一个变量名，把 &lt; 解释为小于号，从而理解成判断‘vector’这个变量的值是否小于‘MyClass’这个变量的值。<br> 正因如此，我们常常可以在 C++ 代码中看见这样的写法：typename decay::type<br> 因为 T 是不确定的，导致编译器无法确定 decay 的 type 是一个类型，还是一个值。<br> <strong>因此用 typename 修饰来让编译器确信这是一个类型名……</strong></li><li>eg：course/01/06<br> <img src="https://images2.imgbox.com/66/c7/znS5s9XJ_o.png" alt="在这里插入图片描述"></li></ul> 
<h3><a id="8_394"></a>8.为什么需要头文件？</h3> 
<p>问题：如果能只写一遍，然后自动插入到需要使用hello()的地方</p> 
<ul><li>问题如下所示：<br> <img src="https://images2.imgbox.com/78/1f/ARfa9myq_o.png" alt="在这里插入图片描述"></li></ul> 
<p><strong>头文件 - 批量插入几行代码的硬核方式</strong></p> 
<ul><li>把 hello() 的声明放到单独一个文件 hello.h 里，然后在需要用到 hello() 这个声明的地方，打上一个记号，#include “hello.h”。</li><li><strong>这个编译前替换的步骤逐渐变成编译器的了一部分，称为预处理阶段，#define 定义的宏也是这个阶段处理的。</strong></li><li>此外，在实现的文件 hello.cpp 中导入声明的文件 hello.h 是个好习惯，可以保证当 hello.cpp 被修改时，比如改成 hello(int)，编译器能够发现 hello.h 声明的 hello() 和定义的 hello(int) 不一样，<strong>避免“沉默的错误”。（对支持重载的 C++ 不奏效）</strong></li><li>示例图如下：</li><li>eg：course/01/07<br> <img src="https://images2.imgbox.com/6d/b6/ykLNo4Ij_o.png" alt="在这里插入图片描述"></li></ul> 
<p>递归地使用头文件</p> 
<ul><li>在 C++ 中常常用到很多的类，和函数一样，类的声明也会被放到头文件中。</li><li>有时候我们的函数声明需要使用到某些类，就需要用到声明了该类的头文件，像这样递归地 #include 即可：</li><li>course/01/08<br> <img src="https://images2.imgbox.com/18/f7/iVCKZGVW_o.png" alt="在这里插入图片描述"></li><li>解决如果多个头文件都引用了 MyClass.h，那么 MyClass 会被重复定义两遍的方法：<br> 在头文件前面加上一行：#pragma once，这样当预处理器第二次读到同一个文件时，就会自动跳过</li><li>eg：course/01/09<br> <img src="https://images2.imgbox.com/a0/7f/1UepK7Wj_o.png" alt="在这里插入图片描述"></li></ul> 
<h3><a id="9CMake__420"></a>9.CMake 中的子模块</h3> 
<p>复杂的工程中，我们需要划分子模块，通常一个库一个目录，比如：</p> 
<ul><li>这里我们把 hellolib 库的东西移到 hellolib 文件夹下了，里面的 CMakeLists.txt 定义了 hellolib 的生成规则。</li><li>要在根目录使用他，可以用 CMake 的 add_subdirectory 添加子目录，子目录也包含一个 CMakeLists.txt，<strong>其中定义的库在 add_subdirectory 之后就可以在外面使用。</strong></li><li>子目录的 CMakeLists.txt 里路径名（比如 hello.cpp）都是相对路径</li><li>eg：course/01/10<br> <img src="https://images2.imgbox.com/66/f8/dAqTG7sv_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/7c/f8/g9xiJMhr_o.png" alt="在这里插入图片描述"></li></ul> 
<h4><a id="1_429"></a>（1）子模块的头文件如何处理</h4> 
<p>因为 hello.h 被移到了 hellolib 子文件夹里，因此 main.cpp 里也要改成</p> 
<ul><li>eg：course/01/10<br> <img src="https://images2.imgbox.com/94/f3/LpggHRdc_o.png" alt="在这里插入图片描述"></li><li>如果要避免修改代码，我们可以通过 target_include_directories 指定a.out 的头文件搜索目录：(其中第一个 hellolib 是库名，第二个是目录)</li></ul> 
<pre><code class="prism language-bash">add_executable<span class="token punctuation">(</span>a.out main.cpp<span class="token punctuation">)</span>
target_link_libraries<span class="token punctuation">(</span>a.out PUBLIC hellolib<span class="token punctuation">)</span>
target_include_directories<span class="token punctuation">(</span>a.out PUBLIC hellolib<span class="token punctuation">)</span>
</code></pre> 
<ul><li>这样甚至可以用 &lt;hello.h&gt; 来引用这个头文件了，<strong>因为通过 target_include_directories 指定的路径会被视为与系统路径等价：</strong><br> <img src="https://images2.imgbox.com/00/02/DksFXyTS_o.png" alt="在这里插入图片描述"></li></ul> 
<h4><a id="2_444"></a>（2）总结</h4> 
<ul><li>eg：course/01/10/main.cpp</li></ul> 
<pre><code class="prism language-bash"><span class="token comment">#include &lt;cstdio&gt;</span>

//方式1
<span class="token comment">#include "hellolib/hello.h"</span>

//方式2
//<span class="token comment">#include "hello.h"  or #include &lt;hello.h&gt;</span>
//CMake中增加<span class="token comment"># target_include_directories(a.out PUBLIC hellolib)</span>

int <span class="token function-name function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    hello<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token builtin class-name">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<ul><li>如果另一个 b.out 也需要用 hellolib 这个库，难道也得再指定一遍搜索路径吗？<br> 不需要，<strong>其实我们只需要定义 hellolib 的头文件搜索路径，引用他的可执行文件 CMake 会自动添加这个路径：</strong></li><li>eg：course/01/11<br> my_course/course/01/11/hellolib/CMakeLists.txt</li></ul> 
<pre><code class="prism language-bash">add_library<span class="token punctuation">(</span>hellolib STATIC hello.cpp<span class="token punctuation">)</span>
target_include_directories<span class="token punctuation">(</span>hellolib PUBLIC <span class="token builtin class-name">.</span><span class="token punctuation">)</span>
</code></pre> 
<p>my_course/course/01/11/CMakeLists.txt</p> 
<pre><code class="prism language-bash">cmake_minimum_required<span class="token punctuation">(</span>VERSION <span class="token number">3.12</span><span class="token punctuation">)</span>
project<span class="token punctuation">(</span>hellocmake LANGUAGES CXX<span class="token punctuation">)</span>

add_subdirectory<span class="token punctuation">(</span>hellolib<span class="token punctuation">)</span>

add_executable<span class="token punctuation">(</span>a.out main.cpp<span class="token punctuation">)</span>
target_link_libraries<span class="token punctuation">(</span>a.out PUBLIC hellolib<span class="token punctuation">)</span>
</code></pre> 
<ul><li>此外，如果不希望让引用 hellolib 的可执行文件自动添加这个路径，把 PUBLIC 改成 PRIVATE 即可。<br> <strong>这就是他们的用途：决定一个属性要不要在被 link 的时候传播（传染病，去传染别人）。</strong></li></ul> 
<h3><a id="11_486"></a>11.目标的一些其他选项</h3> 
<p>除了头文件搜索目录以外，还有这些选项，PUBLIC 和 PRIVATE 对他们同理：</p> 
<pre><code class="prism language-bash">target_include_directories<span class="token punctuation">(</span>myapp PUBLIC /usr/include/eigen3<span class="token punctuation">)</span>  <span class="token comment"># 添加头文件搜索目录</span>
target_link_libraries<span class="token punctuation">(</span>myapp PUBLIC hellolib<span class="token punctuation">)</span>                               <span class="token comment"># 添加要链接的库</span>
target_add_definitions<span class="token punctuation">(</span>myapp PUBLIC <span class="token assign-left variable">MY_MACRO</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>             <span class="token comment"># 添加一个宏定义，等价于#define MY_MACRO 1</span>
target_add_definitions<span class="token punctuation">(</span>myapp PUBLIC <span class="token parameter variable">-DMY_MACRO</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>         <span class="token comment"># 与 MY_MACRO=1 等价</span>
target_compile_options<span class="token punctuation">(</span>myapp PUBLIC -fopenmp<span class="token punctuation">)</span>                     <span class="token comment"># 添加编译器命令行选项</span>
target_sources<span class="token punctuation">(</span>myapp PUBLIC hello.cpp other.cpp<span class="token punctuation">)</span>                    <span class="token comment"># 添加要编译的源文件</span>
</code></pre> 
<p>以及可以通过下列指令（不推荐使用），把选项加到所有接下来的目标去：</p> 
<pre><code class="prism language-bash">include_directories<span class="token punctuation">(</span>/opt/cuda/include<span class="token punctuation">)</span>     <span class="token comment"># 给所有的目标添加头文件搜索目录</span>
link_directories<span class="token punctuation">(</span>/opt/cuda<span class="token punctuation">)</span>                       <span class="token comment"># 给所有的目标添加库文件的搜索路径</span>
add_definitions<span class="token punctuation">(</span>MY_MACRO<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>             <span class="token comment">#给所有的目标添加一个宏定义</span>
add_compile_options<span class="token punctuation">(</span>-fopenmp<span class="token punctuation">)</span>             <span class="token comment">#给所有的目标添加编译器命令行选项</span>
</code></pre> 
<ul><li>补充：<a href="https://www.cnblogs.com/xbook-ben/p/10790092.html" rel="nofollow">#if和#ifdef的区别</a></li></ul> 
<h3><a id="12___506"></a>12.第三方库 - 作为纯头文件引入</h3> 
<p>有时候我们不满足于 C++ 标准库的功能，难免会用到一些第三方库。</p> 
<ul><li>最友好的一类库莫过于纯头文件库了，这里是一些好用的 header-only 库：</li></ul> 
<pre><code class="prism language-bash">nothings/stb - 大名鼎鼎的 stb_image 系列，涵盖图像，声音，字体等，只需单头文件！
Neargye/magic_enum - 枚举类型的反射，如枚举转字符串等（实现方式很巧妙）
g-truc/glm - 模仿 GLSL 语法的数学矢量/矩阵库（附带一些常用函数，随机数生成等）
Tencent/rapidjson - 单纯的 JSON 库，甚至没依赖 STL（可定制性高，工程美学经典）
ericniebler/range-v3 - C++20 ranges 库就是受到他启发（完全是头文件组成）
fmtlib/fmt - 格式化库，提供 std::format 的替代品（需要 -DFMT_HEADER_ONLY）
gabime/spdlog - 能适配控制台，安卓等多后端的日志库（和 <span class="token function">fmt</span> 冲突！）
</code></pre> 
<ul><li>用法：只需要把他们的 include 目录或头文件下载下来，然后 include_directories(spdlog/include) 即可。</li><li>缺点：函数直接实现在头文件里，没有提前编译，从而需要重复编译同样内容，编译时间长。</li><li>eg：course/01/12<br> <img src="https://images2.imgbox.com/50/3e/qd0JVQkF_o.png" alt="在这里插入图片描述"></li></ul> 
<h3><a id="13___524"></a>13.第三方库 - 作为子模块引入</h3> 
<p>第二友好的方式则是作为 CMake 子模块引入，也就是通过 add_subdirectory。</p> 
<ul><li>方法就是把那个项目（以fmt为例）的源码放到你工程的根目录：</li><li>这些库能够很好地支持作为子模块引入：</li></ul> 
<pre><code class="prism language-bash">fmtlib/fmt - 格式化库，提供 std::format 的替代品
gabime/spdlog - 能适配控制台，安卓等多后端的日志库
ericniebler/range-v3 - C++20 ranges 库就是受到他启发
g-truc/glm - 模仿 GLSL 语法的数学矢量/矩阵库
abseil/abseil-cpp - 旨在补充标准库没有的常用功能
bombela/backward-cpp - 实现了 C++ 的堆栈回溯便于调试
google/googletest - 谷歌单元测试框架
google/benchmark - 谷歌性能评估框架
glfw/glfw - OpenGL 窗口和上下文管理
libigl/libigl - 各种图形学算法大合集

</code></pre> 
<ul><li>eg：course/01/13<br> <img src="https://images2.imgbox.com/5a/a9/h8dOqVQ8_o.png" alt="在这里插入图片描述"><br> fmt - 使用这个神奇的格式化库<br> <img src="https://images2.imgbox.com/21/ab/TWJC5lcy_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/97/7c/OzxHqfxa_o.png" alt="在这里插入图片描述"></li></ul> 
<h3><a id="14CMake___549"></a>14.CMake - 引用系统中预安装的第三方库</h3> 
<p>可以通过 find_package 命令寻找系统中的包/库：</p> 
<pre><code class="prism language-bash">find_package<span class="token punctuation">(</span>fmt REQUIRED<span class="token punctuation">)</span>
target_link_libraries<span class="token punctuation">(</span>myexec PUBLIC fmt::fmt<span class="token punctuation">)</span>
</code></pre> 
<ul><li>为什么是 fmt::fmt 而不是简单的 fmt？</li></ul> 
<pre><code class="prism language-bash">现代 CMake 认为一个包 <span class="token punctuation">(</span>package<span class="token punctuation">)</span> 可以提供多个库，又称组件 <span class="token punctuation">(</span>components<span class="token punctuation">)</span>，比如 TBB 这个包，就包含了 tbb, tbbmalloc, tbbmalloc_proxy 这三个组件。

因此为避免冲突，每个包都享有一个独立的名字空间，以 :: 的分割（和 C++ 还挺像的）。
你可以指定要用哪几个组件：
find_package<span class="token punctuation">(</span>TBB REQUIRED COMPONENTS tbb tbbmalloc REQUIRED<span class="token punctuation">)</span>
target_link_libraries<span class="token punctuation">(</span>myexec PUBLIC TBB::tbb TBB::tbbmalloc<span class="token punctuation">)</span>

</code></pre> 
<ul><li>常用 package 列表</li></ul> 
<pre><code class="prism language-bash">fmt::fmt
spdlog::spdlog
range-v3::range-v3
TBB::tbb
OpenVDB::openvdb
Boost::iostreams
Eigen3::Eigen
OpenMP::OpenMP_CXX
</code></pre> 
<ul><li>不同的包之间常常有着依赖关系，而包管理器的作者为 find_package 编写的脚本（例如/usr/lib/cmake/TBB/TBBConfig.cmake）能够自动查找所有依赖，并利用刚刚提到的 PUBLIC PRIVATE 正确处理依赖项，比如如果你引用了 OpenVDB::openvdb 那么 TBB::tbb 也会被自动引用。</li><li><a href="https://cmake.org/cmake/help/latest/module/FindBLAS.html" rel="nofollow">其他包的引用格式和文档参考</a></li></ul> 
<h3><a id="15___583"></a>15.安装第三方库 - 包管理器</h3> 
<h4><a id="1_archpacman_584"></a>（1） arch的pacman</h4> 
<p>Linux 可以用系统自带的包管理器（如 apt）安装 C++ 包。</p> 
<pre><code class="prism language-bash">pacman <span class="token parameter variable">-S</span> <span class="token function">fmt</span>
</code></pre> 
<h4><a id="2ubuntu_aptget_591"></a>（2）ubuntu apt-get</h4> 
<ul><li>ref：<a href="https://blog.csdn.net/u011436427/article/details/125329971?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522167625478316800215051107%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=167625478316800215051107&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-1-125329971-null-null.article_score_rank_blog&amp;utm_term=ubuntu&amp;spm=1018.2226.3001.4450">6.配置ubuntu国内镜像下载源的方法</a></li></ul> 
<h4><a id="3vcpkg_594"></a>（3）vcpkg</h4> 
<ul><li>Windows 则没有自带的包管理器。因此可以用跨平台的 vcpkg：https://github.com/microsoft/vcpkg</li><li>使用方法：下载 vcpkg 的源码，放到你的项目根目录，像这样：<br> <img src="https://images2.imgbox.com/c3/27/jlsitHaN_o.png" alt="在这里插入图片描述"></li><li> 
  <ul><li>eg：course/01/14，<a href="https://gitee.com/jackboosy/vcpkg#%E5%B0%86-vcpkg-%E4%BD%9C%E4%B8%BA%E4%B8%80%E4%B8%AA%E5%AD%90%E6%A8%A1%E5%9D%97" rel="nofollow">对应的gittee链接</a></li></ul> </li><li> 
  <ul><li>用 git clone --depth=1 的好处是限制 clone 的深度，不会下载 Git 协作的历史记录，这样可以大大加快克隆的速度 depth用于指定克隆深度，为1即表示只克隆最近一次commit</li></ul> </li><li>./vcpkg install fmt:x64-linux，可以使用./vcpkg install fmt:linux提前看看要下载什么系统的。要不然会全下载下来</li></ul> 
<pre><code class="prism language-bash"><span class="token builtin class-name">set</span> <span class="token parameter variable">-e</span>

<span class="token function">git</span> clone https://github.com/microsoft/vcpkg.git <span class="token parameter variable">--depth</span><span class="token operator">=</span><span class="token number">1</span>

<span class="token function">rm</span> <span class="token parameter variable">-rf</span> build
cmake <span class="token parameter variable">-B</span> build <span class="token parameter variable">-DCMAKE_TOOLCHAIN_FILE</span><span class="token operator">=</span><span class="token string">"<span class="token environment constant">$PWD</span>/vcpkg/scripts/buildsystems/vcpkg.cmake"</span>
cmake <span class="token parameter variable">--build</span> build <span class="token parameter variable">--target</span> a.out

<span class="token builtin class-name">cd</span> <span class="token function">vcpkg</span>
<span class="token function">sh</span> bootstrap-vcpkg.sh
./vcpkg <span class="token function">install</span> fmt:x64-linux
<span class="token builtin class-name">cd</span> <span class="token punctuation">..</span>

build/a.out
</code></pre> 
<p>-ref：<a href="https://zhuanlan.zhihu.com/p/390410760" rel="nofollow">VCPKG 特性 - Versioning</a></p> 
<h4><a id="4CMake_git_submodule_find_libraryFetchContentCPM_620"></a>（4）CMake 添加第三方库依赖方式git submodule、 find_library、FetchContent、CPM等</h4> 
<ul><li>ref：<a href="https://www.jianshu.com/p/f181b5bd0a63" rel="nofollow">C++工程：总结 CMake 添加第三方库依赖方式git submodule、 find_library、FetchContent、CPM等</a>，<a href="https://blog.csdn.net/zym326975/article/details/106118063">CMake学习笔记05–ExternalProject_Add模块</a>，<a href="https://www.jianshu.com/p/f93ac0bb3ce2" rel="nofollow">CMake项目中集成gtest使用ExternalProject_Add</a></li></ul> 
<p>以jsoncpp 为例，介绍几种引入第三方库的方式</p> 
<p>（1）方法1：代码依赖</p> 
<blockquote> 
 <p>这种方式是把第三方库的完整代码直接添加到我们的项目中，当做项目代码的一部分进行编译，这种方式会把第三方代码和我们的代码混在一起，<strong>并不推荐使用</strong>。首先我们需要到 jsoncpp 下载需要的头文件和实现代码，放到项目当中。</p> 
</blockquote> 
<ul><li><a href="https://github.com/Jiwangreal/cpp-cmake-example/tree/master/includes_full_code">demo</a></li></ul> 
<pre><code class="prism language-bash">工程文件目录
├── CMakeLists.txt
├── jsoncpp
│   ├── include
│   │   └── json
│   │       ├── autolink.h
│   │       ├── config.h
│   │       ├── features.h
│   │       ├── forwards.h
│   │       ├── json.h
│   │       ├── reader.h
│   │       ├── value.h
│   │       └── writer.h
│   ├── json_batchallocator.h
│   ├── json_internalarray.inl
│   ├── json_internalmap.inl
│   ├── json_reader.cpp
│   ├── json_value.cpp
│   ├── json_valueiterator.inl
│   └── json_writer.cpp
└── main.cpp


CMakeLists.txt
cmake_minimum_required<span class="token punctuation">(</span>VERSION <span class="token number">3.17</span><span class="token punctuation">)</span>
project<span class="token punctuation">(</span>includes_full_code<span class="token punctuation">)</span>
set<span class="token punctuation">(</span>CMAKE_CXX_STANDARD <span class="token number">14</span><span class="token punctuation">)</span>
<span class="token comment"># 包含头文件</span>
include_directories<span class="token punctuation">(</span>./jsoncpp/include<span class="token punctuation">)</span>
set<span class="token punctuation">(</span>jsoncpp jsoncpp/json_reader.cpp jsoncpp/json_writer.cpp jsoncpp/json_value.cpp<span class="token punctuation">)</span>
<span class="token comment"># 添加可执行代码</span>
add_executable<span class="token punctuation">(</span>includes_full_code main.cpp <span class="token variable">${jsoncpp}</span><span class="token punctuation">)</span>

main.cpp
<span class="token comment">#include &lt;iostream&gt;</span>
<span class="token comment">#include "json/json.h"</span>
int <span class="token function-name function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    Json::Value json<span class="token punctuation">;</span>
    json<span class="token punctuation">[</span><span class="token string">"name"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"Wiki"</span><span class="token punctuation">;</span>
    json<span class="token punctuation">[</span><span class="token string">"age"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">18</span><span class="token punctuation">;</span>
    std::cout <span class="token operator">&lt;&lt;</span> json.toStyledString<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std::endl<span class="token punctuation">;</span>
    <span class="token builtin class-name">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>（2）方法2：优化代码依赖</p> 
<ul><li>jsoncpp文件夹多了一个 CMakeLists.txt 文件</li><li><a href="https://github.com/taoweiji/cpp-cmake-example/tree/master/subdirectory">subdirectory_example</a></li></ul> 
<pre><code class="prism language-bash">├── CMakeLists.txt
├── jsoncpp
│   ├── CMakeLists.txt
│   ├── include
│   │   └── json
│   │       ├── autolink.h
│   │       ├── config.h
│   │       ├── features.h
│   │       ├── forwards.h
│   │       ├── json.h
│   │       ├── reader.h
│   │       ├── value.h
│   │       └── writer.h
│   ├── json_batchallocator.h
│   ├── json_internalarray.inl
│   ├── json_internalmap.inl
│   ├── json_reader.cpp
│   ├── json_value.cpp
│   ├── json_valueiterator.inl
│   └── json_writer.cpp
└── main.cpp

jsoncpp/CMakeLists.txt
cmake_minimum_required<span class="token punctuation">(</span>VERSION <span class="token number">3.17</span><span class="token punctuation">)</span>
project<span class="token punctuation">(</span>jsoncpp<span class="token punctuation">)</span>
add_library<span class="token punctuation">(</span><span class="token variable">${PROJECT_NAME}</span> json_reader.cpp json_value.cpp json_writer.cpp<span class="token punctuation">)</span>
target_include_directories<span class="token punctuation">(</span><span class="token variable">${PROJECT_NAME}</span> PUBLIC <span class="token variable">${PROJECT_SOURCE_DIR}</span>/include<span class="token punctuation">)</span>

CMakeLists.txt
cmake_minimum_required<span class="token punctuation">(</span>VERSION <span class="token number">3.17</span><span class="token punctuation">)</span>
project<span class="token punctuation">(</span>multi_cmakelists<span class="token punctuation">)</span>
<span class="token comment"># 添加子工程</span>
add_subdirectory<span class="token punctuation">(</span>jsoncpp<span class="token punctuation">)</span>
add_executable<span class="token punctuation">(</span><span class="token variable">${PROJECT_NAME}</span> main.cpp<span class="token punctuation">)</span>
<span class="token comment"># 链接子工程</span>
target_link_libraries<span class="token punctuation">(</span><span class="token variable">${PROJECT_NAME}</span> jsoncpp<span class="token punctuation">)</span>
</code></pre> 
<p>（3）find_library：编译库方式引入</p> 
<ul><li><font color="#FF000">最佳方式:这里只需要导入jsoncpp的头文件和.a文件。用户可以编写脚本下载jsoncpp的头文件和库文件，然后使用include_directories、link_directories或者target_include_directories,target_link_directories()引入即可。</font></li><li><a href="https://github.com/Jiwangreal/cpp-cmake-example/tree/master/find_library">demo</a></li></ul> 
<pre><code class="prism language-bash">├── CMakeLists.txt
├── jsoncpp
│   ├── include
│   │   └── json
│   │       ├── autolink.h
│   │       ├── config.h
│   │       ├── features.h
│   │       ├── forwards.h
│   │       ├── json.h
│   │       ├── reader.h
│   │       ├── value.h
│   │       └── writer.h
│   └── libjsoncpp.a
└── main.cpp

cmake_minimum_required<span class="token punctuation">(</span>VERSION <span class="token number">3.17</span><span class="token punctuation">)</span>
project<span class="token punctuation">(</span>find_library_example<span class="token punctuation">)</span>
include_directories<span class="token punctuation">(</span>jsoncpp/include<span class="token punctuation">)</span>
add_executable<span class="token punctuation">(</span><span class="token variable">${PROJECT_NAME}</span> main.cpp<span class="token punctuation">)</span>
find_library<span class="token punctuation">(</span>jsoncpp_lib NAMES jsoncpp PATHS ./jsoncpp<span class="token punctuation">)</span>
target_link_libraries<span class="token punctuation">(</span><span class="token variable">${PROJECT_NAME}</span> <span class="token variable">${jsoncpp_lib}</span><span class="token punctuation">)</span>
</code></pre> 
<p>（4）FetchContent</p> 
<ul><li>不建议使用：建议通过压缩包的方式引入，因为直接引入git仓库可能会很慢。</li><li>相关的还有：<a href="https://blog.csdn.net/zym326975/article/details/106118063">ExternalProject_Add</a>：eg：<a href="https://www.jianshu.com/p/f93ac0bb3ce2" rel="nofollow">使用CMake项目中集成gtest</a>，太麻烦了，建议直接写脚本处理，不要使用CMake处理</li><li><a href="https://github.com/Jiwangreal/cpp-cmake-example/tree/master/fetch_content">demo</a></li></ul> 
<pre><code class="prism language-cpp">工程文件目录
├── CMakeLists<span class="token punctuation">.</span>txt
└── main<span class="token punctuation">.</span>cpp

CMakeLists<span class="token punctuation">.</span>txt
<span class="token function">cmake_minimum_required</span><span class="token punctuation">(</span>VERSION <span class="token number">3.17</span><span class="token punctuation">)</span>
<span class="token function">project</span><span class="token punctuation">(</span>fetch_content_example<span class="token punctuation">)</span>
<span class="token function">include</span><span class="token punctuation">(</span>FetchContent<span class="token punctuation">)</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token expression"><span class="token function">FetchContent_Declare</span><span class="token punctuation">(</span>jsoncpp</span></span>
<span class="token macro property"><span class="token directive-hash">#</span>        <span class="token expression">GIT_REPOSITORY https<span class="token operator">:</span></span><span class="token comment">//github.com/open-source-parsers/jsoncpp.git</span></span>
<span class="token macro property"><span class="token directive-hash">#</span>        <span class="token expression">GIT_TAG <span class="token number">1.9</span><span class="token punctuation">.</span><span class="token number">4</span><span class="token punctuation">)</span></span></span>
# 建议使用压缩包的方式依赖，下载速度更快
<span class="token function">FetchContent_Declare</span><span class="token punctuation">(</span>jsoncpp
        URL https<span class="token operator">:</span><span class="token comment">//github.com/open-source-parsers/jsoncpp/archive/1.9.4.tar.gz)</span>
<span class="token function">FetchContent_MakeAvailable</span><span class="token punctuation">(</span>jsoncpp<span class="token punctuation">)</span>
<span class="token function">add_executable</span><span class="token punctuation">(</span>$<span class="token punctuation">{<!-- --></span>PROJECT_NAME<span class="token punctuation">}</span> main<span class="token punctuation">.</span>cpp<span class="token punctuation">)</span>
<span class="token function">target_link_libraries</span><span class="token punctuation">(</span>$<span class="token punctuation">{<!-- --></span>PROJECT_NAME<span class="token punctuation">}</span> jsoncpp_lib<span class="token punctuation">)</span>

</code></pre> 
<p>（5） CPM</p> 
<ul><li>不建议使用：</li><li><a href="https://github.com/Jiwangreal/cpp-cmake-example/tree/master/cpm">demo</a></li></ul> 
<pre><code class="prism language-cpp">工程文件目录
├── CMakeLists<span class="token punctuation">.</span>txt
├── cmake
│   ├── CPM<span class="token punctuation">.</span>cmake
│   ├── get_cpm<span class="token punctuation">.</span>cmake
│   └── testing<span class="token punctuation">.</span>cmake
└── main<span class="token punctuation">.</span>cpp

CMakeLists<span class="token punctuation">.</span>txt
<span class="token function">cmake_minimum_required</span><span class="token punctuation">(</span>VERSION <span class="token number">3.17</span><span class="token punctuation">)</span>
<span class="token function">project</span><span class="token punctuation">(</span>cpm_example<span class="token punctuation">)</span>
<span class="token function">list</span><span class="token punctuation">(</span>APPEND CMAKE_MODULE_PATH $<span class="token punctuation">{<!-- --></span>CMAKE_SOURCE_DIR<span class="token punctuation">}</span><span class="token operator">/</span>cmake<span class="token operator">/</span><span class="token punctuation">)</span>
<span class="token function">include</span><span class="token punctuation">(</span>CPM<span class="token punctuation">)</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token expression"><span class="token function">CPMAddPackage</span><span class="token punctuation">(</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span>        <span class="token expression">GIT_REPOSITORY https<span class="token operator">:</span></span><span class="token comment">//github.com/open-source-parsers/jsoncpp.git</span></span>
<span class="token macro property"><span class="token directive-hash">#</span>        <span class="token expression">GIT_TAG <span class="token number">1.9</span><span class="token punctuation">.</span><span class="token number">4</span><span class="token punctuation">)</span></span></span>
# 建议使用压缩包的方式依赖，下载速度更快
<span class="token function">CPMAddPackage</span><span class="token punctuation">(</span>
        NAME jsoncpp
        URL https<span class="token operator">:</span><span class="token comment">//github.com/open-source-parsers/jsoncpp/archive/1.9.4.tar.gz)</span>

<span class="token function">add_executable</span><span class="token punctuation">(</span>$<span class="token punctuation">{<!-- --></span>PROJECT_NAME<span class="token punctuation">}</span> main<span class="token punctuation">.</span>cpp<span class="token punctuation">)</span>
<span class="token function">target_link_libraries</span><span class="token punctuation">(</span>$<span class="token punctuation">{<!-- --></span>PROJECT_NAME<span class="token punctuation">}</span> jsoncpp_lib<span class="token punctuation">)</span>
</code></pre> 
<p>（6）find_package</p> 
<ul><li>自行写一个脚本，将其安装到某个目录下</li><li><a href="https://github.com/Jiwangreal/cpp-cmake-example/tree/master/find_package">demo</a></li></ul> 
<pre><code class="prism language-bash"><span class="token comment"># 拉取代码</span>
<span class="token function">git</span> clone https://github.com/open-source-parsers/jsoncpp
<span class="token builtin class-name">cd</span> jsoncpp
<span class="token function">mkdir</span> <span class="token parameter variable">-p</span> build/debug
<span class="token builtin class-name">cd</span> build/debug
<span class="token comment"># 生成Makefile</span>
cmake <span class="token parameter variable">-DCMAKE_BUILD_TYPE</span><span class="token operator">=</span>release <span class="token parameter variable">-DBUILD_STATIC_LIBS</span><span class="token operator">=</span>OFF <span class="token parameter variable">-DBUILD_SHARED_LIBS</span><span class="token operator">=</span>ON <span class="token parameter variable">-DARCHIVE_INSTALL_DIR</span><span class="token operator">=</span>. <span class="token parameter variable">-DCMAKE_INSTALL_INCLUDEDIR</span><span class="token operator">=</span>include <span class="token parameter variable">-G</span> <span class="token string">"Unix Makefiles"</span> <span class="token punctuation">..</span>/<span class="token punctuation">..</span>
<span class="token comment"># 安装</span>
<span class="token function">make</span> <span class="token operator">&amp;&amp;</span> <span class="token function">make</span> <span class="token function">install</span>
</code></pre> 
<p>CMakeLists.txt</p> 
<pre><code class="prism language-bash">cmake_minimum_required<span class="token punctuation">(</span>VERSION <span class="token number">3.17</span><span class="token punctuation">)</span>
project<span class="token punctuation">(</span>find_package_example<span class="token punctuation">)</span>
find_package<span class="token punctuation">(</span>jsoncpp REQUIRED<span class="token punctuation">)</span>
add_executable<span class="token punctuation">(</span><span class="token variable">${PROJECT_NAME}</span> main.cpp<span class="token punctuation">)</span>
target_link_libraries<span class="token punctuation">(</span><span class="token variable">${PROJECT_NAME}</span> jsoncpp_lib<span class="token punctuation">)</span>
</code></pre> 
<p>（7）git submodule</p> 
<ul><li> <p>ref：<a href="https://blog.csdn.net/u011436427/article/details/125141206?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522167625622416782425176565%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=167625622416782425176565&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-1-125141206-null-null.article_score_rank_blog&amp;utm_term=submodule&amp;spm=1018.2226.3001.4450">git submodules</a></p> </li><li> <p>参考：<a href="https://www.bilibili.com/video/BV1fa411r7zp/?spm_id_from=333.788&amp;vd_source=32de30d5fa72b146ca37e82aa5fc5934" rel="nofollow">学C++从Cmake学起</a>，<a href="https://github.com/parallel101/course">PPT和源码地址</a></p> </li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5dad1b9eb5dd89c98826113b515bd9a0/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">uniapp开发H5使用JSEncrypt加密</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1272216e25e8dac122d366641835bbe0/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">深度学习刷 SOTA 有哪些 trick？</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>