<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据挖掘十大经典算法 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="数据挖掘十大经典算法" />
<meta property="og:description" content="十大经典算法 1）C4.5 决策树是一种依托决策而建立起来的一种树。是一种预测模型，代表的是一种对象属性与对象值之间的一种映射关系。每一个节点代表一个对象，树中的每一个分叉路径代表某个可能的属性值，而每一个叶子节点则对应从根节点到该叶子节点所经历的路径所代表的对象的值。决策树可以有单一输出，也可以有多个输出。 C4.5是一种分类决策树算法，核心算法是ID3算法，是对其的改进。 ID3（Iterative Dichotomiser 3）算法的原理是越是小型的决策树越优于大的决策树，引入信息论中的信息增益来作为判别因素的度量，也就是以信息熵的下降速度作为选取测试属性的标准，所选的测试属性是从根节点到当前节点的路径上尚未被考虑的具有最高信息增益的属性。然后继续这个过程，直到生成的决策树能够完美分类训练样例。 信息熵可以表示信息的价值。也就是衡量信息价值高低的标准。 变量的不确定性越大，熵也就越大，把它搞清楚所需要的信息量也就越大。 一个系统越是有序，信息熵就越低；反之，一个系统越是混乱，信息熵就越高。所以，信息熵也可以说是系统 有序化程度的一个度量。 C4.5继承了ID3算法的有点，并在以下一方面对ID3进行了改进： 1）用信息增益率来选择属性，克服了用信息增益选择属性时偏向选择取值多的属性的不足； 2）在树构造过程中进行剪枝； 3）能够完成对连续属性的离散化处理； 4）能够对不完整数据进行处理。 核心思想： 以信息增益率为衡量标准实现对数据归纳分类 优点：产生的分类规则易于理解，准确率较高； 缺点：在构造树的过程中，需要对数据集进行多次的顺序扫描和排序，因而导致算法的低效。 应用领域： 临床决策、生产制造、文档分析、生物信息学、空间数据建模等 2）K-means算法 K-means是一个聚类算法。把n个对象根据它们的属性分成k个类，k&lt;n。与处理混合正态分布的最大期望算法相似，都是试图找到数据中自然聚类的中心。它假设对象属性来自于空间向量，并且目标是使各个群组内部的均方误差总和最小。 步骤： 选择K个点作为初始质心 repeat 将每个点指派到最近的质心，形成K个簇 重新计算每个簇的质心 until 簇不发生变化或达到最大迭代次数 时间复杂度：O(tKmn)，其中，t为迭代次数，K为簇的数目，m为记录数，n为维数 空间复杂度：O((m&#43;K)n)，其中，K为簇的数目，m为记录数，n为维数 目标函数一般为最小化对象到其簇质心的距离的平方和 K-means算法试图找到使平凡误差准则函数最小的簇。 如何确定k呢？ 大致提供几种方法： 1）与层次聚类结合： 首先采用层次凝聚算法决定结果粗的数目，并找到一个初始聚类，然后用迭代重定位来改进该聚类。 2）稳定性方法：对一个数据集进行2次重采样产生2个数据子集，再用相同的 聚类算法对2个数据子集进行聚类，产生2个具有k个聚类的聚类结果，计算2个聚类结果的相似度的分布情况。2个聚类结果具有高的相似度说明k个聚类反映了稳定的聚类结构，其相似度可以用来估计聚类个数。采用次方法试探多个k，找到合适的k值。 3）系统演化方法： 将一个数据集视为伪热力学系统，当数据集被划分为K个聚类时称系统处于状态K。系统由初始状态K=1出发，经过分裂过程和合并过程，系统将演化到它的稳定平衡状态Ki，其所对应的聚类结构决定了最优类数Ki。系统演化方法能提供关于所有聚类之间的相对边界距离或可分程度，它适用于明显分离的聚类结构和轻微重叠的聚类结构。 核心思想： 输入聚类个数k，以及包含n个数据对象的数据库，输出满足方差最小标准的k个聚类 优点： 当潜在的簇形状是凸面的，簇与簇之间区别较明显，且簇大小相近时，其聚类结果较理想。前面提到，该算法时间复杂度为O(tKmn)，与样本数量线性相关，所以，对于处理大数据集合，该算法非常高效，且伸缩性较好。 缺点： 要事先确定簇数K和对初始聚类中心敏感外，经常以局部最优结束，同时对“噪声”和孤立点敏感，并且该方法不适于发现非凸面形状的簇或大小差别很大的簇。 应用领域： 图片分割，分析商品相似度进而归类商品，分析公司的客户分类以使用不同的商业策略 3）支持向量机SVM SVM是一种监督式学习的方法，它广泛的应用于统计分类以及回归分析中。支持向量机将向量映射到一个更高维的空间里，在这个空间里建立有一个最大间隔超平面。在分开数据的超平面的两边建有两个相互平行的超平面。分隔超平面使两个平行超平面的距离最大化。假定平行超平面间的距离或差距越大，分类器的总误差越小。 核心思想： 建立一个最优决策超平面，使得该平面两侧距离平面最近的两类样本之间的距离最大化，从而对分类问题提供良好的泛化能力 优点： 更好的泛化能力，解决非线性问题的同时避免维度灾难，可找到全局最优 缺点： 运算效率低，计算时占用资源过大 应用领域： 遥感图像分类，污水处理过程运行状态监控等 4）Apriori算法 Apriori算法是一种最有影响的挖掘布尔关联规则频繁项集的算法。其核心是基于两阶段频集思想的递推算法。该关联规则在分类上属于单维、单层、布尔关联规则。在这里，所有支持度大于最小支持度的项集称为频繁项集，简称频集。 其核心思想是通过候选集生成和情节的向下封闭检测两个阶段来挖掘频繁项集。 使用一种称作逐层搜索的迭代方法，“K-1项集”用于搜索“K项集”。 首先，找出频繁“1项集”的集合，该集合记作L1。L1用于找频繁“2项集”的集合L2，而L2用于找L3。如此下去，直到不能找到“K项集”。找每个Lk都需要一次数据库扫描。 挖掘步骤： 1.依据支持度找出所有频繁项集（频度） 2.依据置信度产生关联规则（强度） 支持度： P(A ∩ B) ，既有 A 又有 B 的概率 置信度：P(B|A)，在A发生的事件中同时发生B的概率 p(AB)/P(A) 例如购物篮分析：牛奶 ⇒ 面包 核心思想： 基于两阶段频集思想挖掘关联规则的算法 算法优点： 简单、易理解、数据要求低 算法缺点： I/O负载大，产生过多的候选项目集 应用领域： 消费市场价格分析，入侵检测，移动通信领域 5）最大期望算法（EM） 在统计计算中，最大期望（EM，Expectation–Maximization）算法是在概率（probabilistic）模型中寻找参数最大似然估计的算法，其中概率模型依赖于无法观测的隐藏变量（Latent Variabl）。最大期望经常用在机器学习和计算机视觉的数据集聚（Data Clustering）领域。 核心思想： 通过E步骤和M步骤使得期望最大化 算法优点： 简单稳定 算法缺点： 迭代速度慢，次数多，容易陷入局部最优 应用领域： 参数估计，计算机视觉的数据集聚 6）Pagerank Pagerank是Google算法的重要内容。根据网站的外部链接和内部链接的数量和质量俩衡量网站的价值。PageRank背后的概念是，每个到页面的链接都是对该页面的一次投票，被链接的越多，就意味着被其他网站投票越多。这个就是所谓的“链接流行度”——衡量多少人愿意将他们的网站和你的网站挂钩。PageRank这个概念引自 学术中一篇论文的被引述的频度——即被别人引述的次数越多，一般判断这篇论文的权威性就越高。 核心思想： 基于从许多优质的网页链接过来的网页，必定还是优质网页的回归关系，来判定所有网页的重要性 算法优点： 完全独立于查询，只依赖于网页链接结构，可以离线计算 算法缺点： 忽略了网页搜索的时效性；旧网页排序很高，存在时间长，积累了大量的in-links，拥有最新资讯的新网页排名却很低，因为它们几乎没有in-links 应用领域：页面排序 7）Adaboost Adaboost是一种迭代算法，其核心思想是针对同一个训练集训练不同的分类器(弱分类器)，然后把这些弱分类器集合起来，构成一个更强的最终分类器 (强分类器)。其算法本身是通过改变数据分布来实现的，它根据每次训练集之中每个样本的分类是否正确，以及上次的总体分类的准确率，来确定每个样本的权 值。将修改过权值的新数据集送给下层分类器进行训练，最后将每次训练得到的分类器最后融合起来，作为最后的决策分类器。 核心思想： 针对同一个训练集训练不同的分类器(弱分类器)，然后把这些弱分类器集合起来，构成一个更强的最终分类器(强分类器) 算法优点： 高精度，简单无需做特征筛选，不会过度拟合 算法缺点： 训练时间过长，执行效果依赖于弱分类器的选择 应用领域： 广泛应用于人脸检测、目标识别等领域 8）KNN K最近邻(k-Nearest Neighbor，KNN)分类算法，是一个理论上比较成熟的方法，也是最简单的机器学习算法之一。该方法的思路是：如果一个样本在特征空间中的k个最相似(即特征空间中最邻近)的样本中的大多数属于某一个类别，则该样本也属于这个类别。 核心思想： 如果一个样本在特征空间中的k个最相似(即特征空间中最邻近)的样本中的大多数属于某一个类别，则该样本也属于这个类别 算法优点： 简单，无需估计参数，无需训练，适合于多分类问题 算法缺点： 计算量较大；可解释性较差，无法给出决策树那样的规则 应用领域： 客户流失预测、欺诈侦测等（更适合于稀有事件的分类问题） 9）朴素贝叶斯 在众多的分类模型中，应用最为广泛的两种分类模型是决策树模型(Decision Tree Model)和朴素贝叶斯模型（Naive Bayesian Model，NBC）。朴素贝叶斯模型发源于古典数学理论，有着坚实的数学基础，以及稳定的分类效率。同时，NBC模型所需估计的参数很少，对缺失数据不太敏感，算法也比较简单。理论上，NBC模型与其他分类方法相比具有最小的误差率。但是实际上并非总是如此，这是因为NBC模型假设属性之间相互独立，这个假设在实际应用中往往是不成立的，这给NBC模型的正确分类带来了一定影响。在属 性个数比较多或者属性之间相关性较大时，NBC模型的分类效率比不上决策树模型。而在属性相关性较小时，NBC模型的性能最为良好。 核心思想： 通过某对象的先验概率，利用贝叶斯公式计算出其后验概率，即该对象属于某一类的概率，选择具有最大后验概率的类作为该对象所属的类 算法优点： 算法简单，所需估计的参数很少，对缺失数据不太敏感 算法缺点： 属性个数比较多或者属性之间相关性较大时，分类效率下降 应用领域： 垃圾邮件过滤，文本分类 10）CART：分类与回归树 CART, Classification and Regression Trees。在分类树下面有两个关键的思想。第一个是关于递归地划分自变量空间的想法；第二个想法是用验证数据进行剪枝。算法采用一种二分递归分割的技术，将当前的样本集分为两个子样本集，使得生成的的每个非叶子节点都有两个分支。因此，CART算法生成的决策树是结构简洁的二叉树。 核心思想： 以基于最小距离的尼基指数估计函数为衡量标准对数据进行递归分类 算法优点： 抽取规则简便且易于理解；面对存在缺失值、变量数多等问题时非常稳健 算法缺点： 要求被选择的属性只能产生两个子节点；类别过多时，错误可能增加的较快 应用领域： 信息失真识别，电信业潜在客户识别，预测贷款风险等等 CART与C4." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/3d146b569d41c83f4e12a0cca252a678/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2017-09-25T15:19:14+08:00" />
<meta property="article:modified_time" content="2017-09-25T15:19:14+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据挖掘十大经典算法</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div>
  十大经典算法 
</div> 
<div> 
 <strong>1）C4.5</strong> 
</div> 
<div>
  决策树是一种依托决策而建立起来的一种树。是一种预测模型，代表的是一种对象属性与对象值之间的一种映射关系。每一个节点代表一个对象，树中的每一个分叉路径代表某个可能的属性值，而每一个叶子节点则对应从根节点到该叶子节点所经历的路径所代表的对象的值。决策树可以有单一输出，也可以有多个输出。 
</div> 
<div>
  C4.5是一种分类决策树算法，核心算法是ID3算法，是对其的改进。 
</div> 
<div>
  ID3（Iterative Dichotomiser 3）算法的原理是越是小型的决策树越优于大的决策树，引入信息论中的信息增益来作为判别因素的度量，也就是以信息熵的下降速度作为选取测试属性的标准，所选的测试属性是从根节点到当前节点的路径上尚未被考虑的具有最高信息增益的属性。然后继续这个过程，直到生成的决策树能够完美分类训练样例。 
</div> 
<div> 
 <br> 
</div> 
<div>
  信息熵可以表示信息的价值。也就是衡量信息价值高低的标准。 
</div> 
<div>
  变量的不确定性越大，熵也就越大，把它搞清楚所需要的信息量也就越大。 
</div> 
<div>
  一个系统越是有序，信息熵就越低；反之，一个系统越是混乱，信息熵就越高。所以，信息熵也可以说是系统 
 <a target="_blank" href="http://baike.baidu.com/view/2434917.htm" rel="nofollow noopener noreferrer"><span style="color:rgb(0,0,0)">有序化</span></a>程度的一个度量。 
</div> 
<div> 
 <br> 
</div> 
<div>
  C4.5继承了ID3算法的有点，并在以下一方面对ID3进行了改进： 
</div> 
<div>
  1）用信息增益率来选择属性，克服了用信息增益选择属性时偏向选择取值多的属性的不足； 
</div> 
<div>
  2）在树构造过程中进行剪枝； 
</div> 
<div>
  3）能够完成对连续属性的离散化处理； 
</div> 
<div>
  4）能够对不完整数据进行处理。 
</div> 
<div> 
 <br> 
</div> 
<div> 
 <span style="color:rgb(51,51,51)">核心思想：</span> 
 <span style="color:rgb(51,51,51)"> 以信息增益率为衡量标准实现对数据归纳分类</span> 
</div> 
<div>
  优点：产生的分类规则易于理解，准确率较高； 
</div> 
<div>
  缺点：在构造树的过程中，需要对数据集进行多次的顺序扫描和排序，因而导致算法的低效。 
</div> 
<div> 
 <span style="color:rgb(51,51,51)">应用领域：</span> 
 <span style="color:rgb(51,51,51)"> 临床决策、生产制造、文档分析、生物信息学、空间数据建模等</span> 
</div> 
<div> 
 <br> 
</div> 
<div> 
 <strong>2）K-means算法</strong> 
</div> 
<div>
  K-means是一个聚类算法。把n个对象根据它们的属性分成k个类，k&lt;n。与处理混合正态分布的最大期望算法相似，都是试图找到数据中自然聚类的中心。它假设对象属性来自于空间向量，并且目标是使各个群组内部的均方误差总和最小。 
</div> 
<div>
  步骤： 
</div> 
<div> 
 <ol start="1" style="color:rgb(92,92,92)"><li style="color:inherit"><span style="color:black">选择K个点作为初始质心  </span></li><li><span style="color:black">repeat  </span></li><li style="color:inherit"><span style="color:black">    将每个点指派到最近的质心，形成K个簇  </span></li><li><span style="color:black">    重新计算每个簇的质心  </span></li><li style="color:inherit"><span style="color:black">until 簇不发生变化或达到最大迭代次数  </span></li></ol> 
</div> 
<div> 
 <span style="color:rgb(51,51,51)">时间复杂度：O(tKmn)，其中，t为迭代次数，K为簇的数目，m为记录数，n为维数</span> 
</div> 
<div> 
 <div style="color:rgb(51,51,51)">
   空间复杂度：O((m+K)n)，其中，K为簇的数目，m为记录数，n为维数 
 </div> 
</div> 
<div> 
 <span style="color:rgb(51,51,51)">目标函数一般为最小化对象到其簇质心的距离的平方和</span> 
</div> 
<div> 
 <span style="color:rgb(51,51,51)">K-means算法试图找到使平凡误差准则函数最小的簇。</span> 
</div> 
<div> 
 <br> 
</div> 
<div>
  如何确定k呢？ 
</div> 
<div>
  大致提供几种方法： 
</div> 
<div>
  1）与层次聚类结合： 
 <span style="color:rgb(51,51,51)">首先采用层次凝聚算法决定结果粗的数目，并找到一个初始聚类，然后用迭代重定位来改进该聚类。</span> 
</div> 
<div>
  2）稳定性方法：对一个数据集进行2次重采样产生2个数据子集，再用相同的 
 <span style="color:rgb(51,51,51)">聚类算法对2个数据子集进行聚类，产生2个具有k个聚类的聚类结果，计算2个聚类结果的相似度的分布情况。2个聚类结果具有高的相似度说明k个聚类反映了稳定的聚类结构，其相似度可以用来估计聚类个数。采用次方法试探多个k，找到合适的k值。</span> 
</div> 
<div> 
 <span style="color:rgb(51,51,51)">3）系统演化方法：</span> 
 <span style="color:rgb(51,51,51)">将一个数据集视为伪热力学系统，当数据集被划分为K个聚类时称系统处于状态K。系统由初始状态K=1出发，经过分裂过程和合并过程，系统将演化到它的稳定平衡状态Ki，其所对应的聚类结构决定了最优类数Ki。系统演化方法能提供关于所有聚类之间的相对边界距离或可分程度，它适用于明显分离的聚类结构和轻微重叠的聚类结构。</span> 
</div> 
<div> 
 <br> 
</div> 
<div> 
 <span style="color:rgb(51,51,51)">核心思想：</span> 
 <span style="color:rgb(51,51,51)"> 输入聚类个数k，以及包含n个数据对象的数据库，输出满足方差最小标准的k个聚类</span> 
</div> 
<div>
  优点： 
 <span style="color:rgb(51,51,51)">当潜在的簇形状是凸面的，簇与簇之间区别较明显，且簇大小相近时，其聚类结果较理想。前面提到，该算法时间复杂度为O(tKmn)，与样本数量线性相关，所以，对于处理大数据集合，该算法非常高效，且伸缩性较好。</span> 
</div> 
<div> 
 <span style="color:rgb(51,51,51)">缺点：</span> 
 <span style="color:rgb(51,51,51)">要事先确定簇数K和对初始聚类中心敏感外，经常以局部最优结束，同时对“噪声”和孤立点敏感，并且该方法不适于发现非凸面形状的簇或大小差别很大的簇。</span> 
</div> 
<div> 
 <span style="color:rgb(51,51,51)">应用领域：</span> 
 <span style="color:rgb(51,51,51)"> 图片分割，分析商品相似度进而归类商品，分析公司的客户分类以使用不同的商业策略</span> 
</div> 
<div> 
 <span style="color:rgb(51,51,51)"><br> </span> 
</div> 
<div> 
 <span style="color:rgb(51,51,51)"><strong>3）支持向量机SVM</strong></span> 
</div> 
<div> 
 <span style="color:rgb(51,51,51)">SVM是一种监督式学习的方法，它广泛的应用于统计分类以及回归分析中。支持向量机将向量映射到一个更高维的空间里，在这个空间里建立有一个最大间隔超平面。在分开数据的超平面的两边建有两个相互平行的超平面。分隔超平面使两个平行超平面的距离最大化。</span>假定平行超平面间的距离或差距越大，分类器的总误差越小。 
</div> 
<div> 
 <span style="color:rgb(51,51,51)"><br> </span> 
</div> 
<div> 
 <span style="color:rgb(51,51,51)">核心思想：</span> 
 <span style="color:rgb(51,51,51)"> 建立一个最优决策超平面，使得该平面两侧距离平面最近的两类样本之间的距离最大化，从而对分类问题提供良好的泛化能力</span> 
</div> 
<div> 
 <span style="color:rgb(51,51,51)">优点： 更好的泛化能力，解决非线性问题的同时避免维度灾难，可找到全局最优</span> 
</div> 
<div> 
 <span style="color:rgb(51,51,51)">缺点： 运算效率低，计算时占用资源过大</span> 
</div> 
<div> 
 <span style="color:rgb(51,51,51)">应用领域：</span> 
 <span style="color:rgb(51,51,51)"> 遥感图像分类，污水处理过程运行状态监控等</span> 
</div> 
<div> 
 <br> 
</div> 
<div> 
 <strong>4）Apriori算法</strong> 
</div> 
<div>
  Apriori算法是一种最有影响的挖掘布尔关联规则频繁项集的算法。其核心是基于两阶段频集思想的递推算法。该关联规则在分类上属于单维、单层、布尔关联规则。在这里，所有支持度大于最小支持度的项集称为频繁项集，简称频集。 
</div> 
<div> 
 <span style="color:rgb(51,51,51)">其核心思想是通过候选集生成和情节的向下封闭检测两个阶段来挖掘频繁项集。</span> 
</div> 
<div> 
 <br> 
</div> 
<div>
  使用一种称作逐层搜索的迭代方法，“K-1项集”用于搜索“K项集”。 
</div> 
<div> 
 <div style="color:rgb(51,51,51)"> 
  <div> 
   <span style="color:rgb(0,0,0)">首先，找出频繁“1项集”的集合，该集合记作L1。L1用于找频繁“2项集”的集合L2，而L2用于找L3。如此下去，直到不能找到“K项集”。找每个Lk都需要一次<a target="_blank" title="MySQL知识库" href="http://lib.csdn.net/base/mysql" rel="nofollow noopener noreferrer"><span style="color:rgb(0,0,0)">数据库</span></a>扫描。</span> 
  </div> 
  <div> 
   <br> 
  </div> 
 </div> 
</div> 
<div>
  挖掘步骤： 
</div> 
<div> 
 <span style="color:rgb(51,51,51)">1.依据支持度找出所有频繁项集（频度）</span> 
</div> 
<div> 
 <div> 
  <span style="color:rgb(51,51,51)">2.依据置信度产生关联规则（强度）</span> 
 </div> 
 <div> 
  <span style="color:rgb(51,51,51)">支持度：</span> 
  <span style="color:rgb(51,51,51)">P(A </span> 
  <span style="color:rgb(51,51,51)">∩ </span> 
  <span style="color:rgb(51,51,51)">B)</span> 
  <span style="color:rgb(51,51,51)">，既有</span> 
  <span style="color:rgb(51,51,51)">A</span> 
  <span style="color:rgb(51,51,51)">又有</span> 
  <span style="color:rgb(51,51,51)">B</span> 
  <span style="color:rgb(51,51,51)">的概率</span> 
 </div> 
 <div> 
  <div> 
   <span style="color:rgb(51,51,51)">置信度：P(B|A)，在A发生的事件中同时发生B的概率 p(AB)/P(A)     例如购物篮分析：牛奶 ⇒ 面包</span> 
  </div> 
  <div> 
   <span style="color:rgb(51,51,51)"><br> </span> 
  </div> 
  <div> 
   <span style="color:rgb(51,51,51)">核心思想：</span> 
   <span style="color:rgb(51,51,51)"> 基于两阶段频集思想挖掘关联规则的算法</span> 
  </div> 
  <div> 
   <span style="color:rgb(51,51,51)">算法优点： 简单、易理解、数据要求低</span> 
  </div> 
  <div> 
   <span style="color:rgb(51,51,51)">算法缺点： I/O负载大，产生过多的候选项目集</span> 
  </div> 
  <div> 
   <span style="color:rgb(51,51,51)">应用领域：</span> 
   <span style="color:rgb(51,51,51)"> 消费市场价格分析，入侵检测，移动通信领域</span> 
  </div> 
  <div> 
   <span style="color:rgb(51,51,51)"><br> </span> 
  </div> 
  <div> 
   <span style="color:rgb(51,51,51)"><strong>5）最大期望算法（EM）</strong></span> 
  </div> 
  <div>
    在统计计算中，最大期望（EM，Expectation–Maximization）算法是在概率（probabilistic）模型中寻找参数最大似然估计的算法，其中概率模型依赖于无法观测的隐藏变量（Latent Variabl）。最大期望经常用在机器学习和计算机视觉的数据集聚（Data Clustering）领域。 
  </div> 
  <div> 
   <br> 
  </div> 
 </div> 
 <div> 
  <span style="color:rgb(51,51,51)">核心思想： 通过E步骤和M步骤使得期望最大化</span> 
 </div> 
 <div> 
  <span style="color:rgb(51,51,51)">算法优点： 简单稳定</span> 
 </div> 
 <div> 
  <span style="color:rgb(51,51,51)">算法缺点： 迭代速度慢，次数多，容易陷入局部最优</span> 
 </div> 
 <div> 
  <span style="color:rgb(51,51,51)">应用领域：</span> 
  <span style="color:rgb(51,51,51)"> 参数估计，计算机视觉的数据集聚</span> 
 </div> 
 <div> 
  <span style="color:rgb(51,51,51)"><br> </span> 
 </div> 
 <div> 
  <span style="color:rgb(51,51,51)"><strong>6）Pagerank</strong></span> 
 </div> 
 <div> 
  <span style="color:rgb(51,51,51)">Pagerank是Google算法的重要内容。</span>根据网站的外部链接和内部链接的数量和质量俩衡量网站的价值。PageRank背后的概念是，每个到页面的链接都是对该页面的一次投票，被链接的越多，就意味着被其他网站投票越多。这个就是所谓的“链接流行度”——衡量多少人愿意将他们的网站和你的网站挂钩。PageRank这个概念引自 学术中一篇论文的被引述的频度——即被别人引述的次数越多，一般判断这篇论文的权威性就越高。 
 </div> 
 <div> 
  <br> 
 </div> 
 <div> 
  <span style="color:rgb(51,51,51)">核心思想： 基于从许多优质的网页链接过来的网页，必定还是优质网页的回归关系，来判定所有网页的重要性</span> 
 </div> 
 <div> 
  <span style="color:rgb(51,51,51)">算法优点： 完全独立于查询，只依赖于网页链接结构，可以离线计算</span> 
 </div> 
 <div> 
  <span style="color:rgb(51,51,51)">算法缺点： 忽略了网页搜索的时效性；旧网页排序很高，存在时间长，积累了大量的in-links，拥有最新资讯的新网页排名却很低，因为它们几乎没有in-links</span> 
 </div> 
 <div> 
  <span style="color:rgb(51,51,51)">应用领域：页面排序</span> 
 </div> 
</div> 
<div> 
 <br> 
</div> 
<div> 
 <strong>7）Adaboost</strong> 
</div> 
<div>
  Adaboost是一种迭代算法，其核心思想是针对同一个训练集训练不同的分类器(弱分类器)，然后把这些弱分类器集合起来，构成一个更强的最终分类器 (强分类器)。其算法本身是通过改变数据分布来实现的，它根据每次训练集之中每个样本的分类是否正确，以及上次的总体分类的准确率，来确定每个样本的权 值。将修改过权值的新数据集送给下层分类器进行训练，最后将每次训练得到的分类器最后融合起来，作为最后的决策分类器。 
</div> 
<div> 
 <span style="color:rgb(51,51,51)"><br> </span> 
</div> 
<div> 
 <span style="color:rgb(51,51,51)">核心思想： 针对同一个训练集训练不同的分类器(弱分类器)，然后把这些弱分类器集合起来，构成一个更强的最终分类器(强分类器)</span> 
</div> 
<div> 
 <span style="color:rgb(51,51,51)">算法优点： 高精度，简单无需做特征筛选，不会过度拟合</span> 
</div> 
<div> 
 <span style="color:rgb(51,51,51)">算法缺点： 训练时间过长，执行效果依赖于弱分类器的选择</span> 
</div> 
<div> 
 <span style="color:rgb(51,51,51)">应用领域： 广泛应用于人脸检测、目标识别等领域</span> 
</div> 
<div> 
 <br> 
</div> 
<div> 
 <strong>8）KNN</strong> 
</div> 
<div> 
 <div align="justify">
   K最近邻(k-Nearest Neighbor，KNN)分类算法，是一个理论上比较成熟的方法，也是最简单的机器学习算法之一。该方法的思路是：如果一个样本在特征空间中的k个最相似(即特征空间中最邻近)的样本中的大多数属于某一个类别，则该样本也属于这个类别。 
 </div> 
</div> 
<div> 
 <span style="color:rgb(51,51,51)"><br> </span> 
</div> 
<div> 
 <span style="color:rgb(51,51,51)">核心思想： 如果一个样本在特征空间中的k个最相似(即特征空间中最邻近)的样本中的大多数属于某一个类别，则该样本也属于这个类别</span> 
</div> 
<div> 
 <span style="color:rgb(51,51,51)">算法优点： 简单，无需估计参数，无需训练，适合于多分类问题</span> 
</div> 
<div> 
 <span style="color:rgb(51,51,51)">算法缺点： 计算量较大；可解释性较差，无法给出决策树那样的规则</span> 
</div> 
<div> 
 <span style="color:rgb(51,51,51)">应用领域： 客户流失预测、欺诈侦测等（更适合于稀有事件的分类问题）</span> 
</div> 
<div> 
 <br> 
</div> 
<div> 
 <strong>9）朴素贝叶斯</strong> 
</div> 
<div>
  在众多的分类模型中，应用最为广泛的两种分类模型是决策树模型(Decision Tree Model)和朴素贝叶斯模型（Naive Bayesian Model，NBC）。朴素贝叶斯模型发源于古典数学理论，有着坚实的数学基础，以及稳定的分类效率。同时，NBC模型所需估计的参数很少，对缺失数据不太敏感，算法也比较简单。理论上，NBC模型与其他分类方法相比具有最小的误差率。但是实际上并非总是如此，这是因为NBC模型假设属性之间相互独立，这个假设在实际应用中往往是不成立的，这给NBC模型的正确分类带来了一定影响。在属 性个数比较多或者属性之间相关性较大时，NBC模型的分类效率比不上决策树模型。而在属性相关性较小时，NBC模型的性能最为良好。 
</div> 
<div> 
 <span style="color:rgb(51,51,51)"><br> </span> 
</div> 
<div> 
 <span style="color:rgb(51,51,51)">核心思想： 通过某对象的先验概率，利用贝叶斯公式计算出其后验概率，即该对象属于某一类的概率，选择具有最大后验概率的类作为该对象所属的类</span> 
</div> 
<div> 
 <span style="color:rgb(51,51,51)">算法优点： 算法简单，所需估计的参数很少，对缺失数据不太敏感</span> 
</div> 
<div> 
 <span style="color:rgb(51,51,51)">算法缺点： 属性个数比较多或者属性之间相关性较大时，分类效率下降</span> 
</div> 
<div> 
 <span style="color:rgb(51,51,51)">应用领域： 垃圾邮件过滤，文本分类</span> 
</div> 
<div> 
 <span style="color:rgb(51,51,51)"><br> </span> 
</div> 
<div> 
 <span style="color:rgb(51,51,51)"><strong>10）CART：分类与回归树</strong></span> 
</div> 
<div>
  CART, Classification and Regression Trees。在分类树下面有两个关键的思想。第一个是关于递归地划分自变量空间的想法；第二个想法是用验证数据进行剪枝。算法采用一种二分递归分割的技术，将当前的样本集分为两个子样本集，使得生成的的每个非叶子节点都有两个分支。因此，CART算法生成的决策树是结构简洁的二叉树。 
</div> 
<div> 
 <span style="color:rgb(51,51,51)"><br> </span> 
</div> 
<div> 
 <span style="color:rgb(51,51,51)">核心思想： 以基于最小距离的尼基指数估计函数为衡量标准对数据进行递归分类</span> 
</div> 
<div> 
 <span style="color:rgb(51,51,51)">算法优点： 抽取规则简便且易于理解；面对存在缺失值、变量数多等问题时非常稳健</span> 
</div> 
<div> 
 <span style="color:rgb(51,51,51)">算法缺点： 要求被选择的属性只能产生两个子节点；类别过多时，错误可能增加的较快</span> 
</div> 
<div> 
 <span style="color:rgb(51,51,51)">应用领域： 信息失真识别，电信业潜在客户识别，预测贷款风险等等</span> 
</div> 
<div> 
 <br> 
</div> 
<div>
  CART与C4.5的不同之处是节点在分裂时使用GINI指数。GINI指标主要是度量数据划分或训练数据集D的不纯度为主，系数值的属性作为测试属性，GINI值越小，表明样本的纯净度越高（即该样本只属于同一类的概率越高）。选择该属性产生最小的GINI指标的子集作为它的分裂子集。 
</div> 
<div> 
 <br> 
</div> 
<div> 
 <div> 
  <p>CART_classification(DataSet,featureList, alpha,)：</p> 
  <div> 
   <div>
     创建根节点R 
   </div> 
  </div> 
  <div> 
   <div>
     如果当前DataSet中的数据的类别相同，则标记R的类别标记为该类 
   </div> 
  </div> 
  <div> 
   <div>
     如果决策树高度大于alpha，则不再分解，标记R的类别classify(DataSet) 
   </div> 
  </div> 
  <p>递归情况：</p> 
  <div> 
   <div>
     标记R的类别classify(DataSet) 
   </div> 
  </div> 
  <div>
    从featureList中选择属性F（选择Gini(DataSet,F)最小的属性划分，连续属性参考C4.5的离散化过程(以Gini最小作为划分标准)） 
  </div> 
  <div>
    根据F，将DataSet做二元划分DS_L和DS_R： 
  </div> 
  <div>
    如果DS_L或DS_R为空，则不再分解 
  </div> 
  <div>
    如果DS_L和DS_R都不为空，节点 
  </div> 
  <div>
        C_L= CART_classification(DS_L,featureList, alpha); 
  </div> 
  <div>
        C_R= CART_classification(DS_RfeatureList, alpha) 
  </div> 
  <div>
    将节点C_L和C_R添加为R的左右子节点 
  </div> 
 </div> 
 <div> 
  <br> 
 </div> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b4184d0f9826a9dabca43ce31e8b3167/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">LSD(Line Segment Detector)直线提取算法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/cb8f2365701549d180c4f024f13446b1/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">压测tps很低并且呈下降趋势，原因解析</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>