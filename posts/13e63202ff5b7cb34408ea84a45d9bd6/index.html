<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Spring Security前置知识3--Cookie与Web Storage - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Spring Security前置知识3--Cookie与Web Storage" />
<meta property="og:description" content="文章目录 一、概述二、Cookie产生背景三、Cookie值在哪里设置四、Cookie有哪些属性五、Cookie存储在哪里六、Cookie如何传到后台七、后台如何处理Cookie八、Cookie存储空间与数量的限制九、Web本地存储(Web Storage)1、Web Storage的产生2、Web Storage简单介绍3、Web Storage的问题4、LocalStorage用于存储Jwt Token 一、概述 在Session篇说过为了维持Http请求有状态化，需要有“会话”的概念，服务端信息&#43;客户端信息共同协作维持会话。
其中Cookie是会话在客户端的载体，Session是会话在服务器端的载体。客户端会话存储在浏览器中。服务器端会话存储在Web中间件中。
二、Cookie产生背景 单论Cookie的产生，网上查是早于Session，当时只是想在浏览器端保存一些网站的设置信息，所以起了这么个名字。理论上登录才是第一需要解决的问题。。。
三、Cookie值在哪里设置 Cookie的内容由服务器端产生，通过构建Cookie对象，调用Response的setCookie方法设置。或者直接通过Response的addHeader方法来设置，通过Response Header传递给浏览器端。
Cookie cookie = new Cookie(&#34;test&#34;, &#34;11&#34;); cookie.setPath(&#34;/&#34;); cookie.setHttpOnly(true); response.addCookie(cookie); // response.addHeader(&#34;Set-Cookie&#34;, &#34;uid=1123456; Path=/; HttpOnly&#34;); Cookie也可以在前台通过js设置，一般用于后台不方便设置的时候，如我们在ajax访问中希望在返回结果后增加Cookie。
document.cookie=&#34;name=&#34;&#43;value; 四、Cookie有哪些属性 Cookie主要属性是一个键值对name和value，还有其它的附属控制属性。
我们可以查看Java中Cookie的源码
private String name; private String value; private String comment; private String domain; private int maxAge = -1; private String path; private boolean secure; private int version = 0; private boolean isHttpOnly = false; public Cookie(String name, String value) { // 构造函数逻辑 } 属性说明：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/13e63202ff5b7cb34408ea84a45d9bd6/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-03-28T22:20:01+08:00" />
<meta property="article:modified_time" content="2019-03-28T22:20:01+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Spring Security前置知识3--Cookie与Web Storage</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#_1" rel="nofollow">一、概述</a></li><li><a href="#Cookie_5" rel="nofollow">二、Cookie产生背景</a></li><li><a href="#Cookie_8" rel="nofollow">三、Cookie值在哪里设置</a></li><li><a href="#Cookie_21" rel="nofollow">四、Cookie有哪些属性</a></li><li><a href="#Cookie_88" rel="nofollow">五、Cookie存储在哪里</a></li><li><a href="#Cookie_97" rel="nofollow">六、Cookie如何传到后台</a></li><li><a href="#Cookie_99" rel="nofollow">七、后台如何处理Cookie</a></li><li><a href="#Cookie_102" rel="nofollow">八、Cookie存储空间与数量的限制</a></li><li><a href="#WebWeb_Storage_104" rel="nofollow">九、Web本地存储(Web Storage)</a></li><li><ul><li><a href="#1Web_Storage_106" rel="nofollow">1、Web Storage的产生</a></li><li><a href="#2Web_Storage_111" rel="nofollow">2、Web Storage简单介绍</a></li><li><a href="#3Web_Storage_118" rel="nofollow">3、Web Storage的问题</a></li><li><a href="#4LocalStorageJwt_Token_122" rel="nofollow">4、LocalStorage用于存储Jwt Token</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="_1"></a>一、概述</h2> 
<p>  在Session篇说过为了维持Http请求有状态化，需要有“会话”的概念，服务端信息+客户端信息共同协作维持会话。<br>   其中Cookie是会话在客户端的载体，Session是会话在服务器端的载体。客户端会话存储在浏览器中。服务器端会话存储在Web中间件中。</p> 
<h2><a id="Cookie_5"></a>二、Cookie产生背景</h2> 
<p>  单论Cookie的产生，网上查是早于Session，当时只是想在浏览器端保存一些网站的设置信息，所以起了这么个名字。理论上登录才是第一需要解决的问题。。。</p> 
<h2><a id="Cookie_8"></a>三、Cookie值在哪里设置</h2> 
<p>  Cookie的内容由服务器端产生，通过构建Cookie对象，调用Response的setCookie方法设置。或者直接通过Response的addHeader方法来设置，通过Response Header传递给浏览器端。</p> 
<pre><code>Cookie cookie = new Cookie("test", "11");
cookie.setPath("/");
cookie.setHttpOnly(true);
response.addCookie(cookie);
// response.addHeader("Set-Cookie", "uid=1123456; Path=/; HttpOnly");
</code></pre> 
<p>  Cookie也可以在前台通过js设置，一般用于后台不方便设置的时候，如我们在ajax访问中希望在返回结果后增加Cookie。</p> 
<pre><code>document.cookie="name="+value;  
</code></pre> 
<h2><a id="Cookie_21"></a>四、Cookie有哪些属性</h2> 
<p>Cookie主要属性是一个键值对name和value，还有其它的附属控制属性。<br> 我们可以查看Java中Cookie的源码</p> 
<pre><code>private String name;
private String value;
private String comment;
private String domain;
private int maxAge = -1;
private String path;
private boolean secure;
private int version = 0;
private boolean isHttpOnly = false;

public Cookie(String name, String value) {
    // 构造函数逻辑
}
</code></pre> 
<p><strong>属性说明：</strong></p> 
<ol><li>name和value是必填字段 ，所以Java只提供了一个需要name和value的两参数构造函数。其它的字段事实上除了comment都不会为空。</li><li>comment 注释，可选。</li><li>domain表示cookie的域。<br> <strong>默认值</strong><br> 默认情况下，会自动截取域名作为domain的值，如http://siteA.abc.com/test/index.html会取siteA.abc.com。<br> 如果有需要，我们也可以可以手动设置domain的值，但是只能设置为上级域名且非顶级域名。<br>   如果在js中尝试设置进行错误的值，会有特别清楚的报错。下图我们尝试修改pan.baidu.com的域，第一个提示设置的域并不是实际域名的后缀，也就是上级域。第二个不能设置为顶级域。也就是只能设置为自己家的上级域。<br> <img src="https://images2.imgbox.com/3c/29/99MOT2b8_o.png" alt="在这里插入图片描述"><br>   如果在java中尝试设置进行错误的值，经过实验，除非格式错误会提示“java.lang.IllegalArgumentException: An invalid domain [.abc.com] was specified for this cookie”，否则并不会提示报错，但是cookie并不能设置成功。</li></ol> 
<p><strong>跨域的一种情况</strong><br>   假设某个公司有两个站点，<a href="http://siteA.abc.com" rel="nofollow">siteA.abc.com</a>,<a href="http://siteB.abc.com" rel="nofollow">siteB.abc.com</a>，如果想要相互访问，如siteA中有个Cookie希望能被siteB访问到，<a href="http://xn--sitesiteB-jp6n572jnvhe6wvfb802du76i.abc.com" rel="nofollow">无法显式将site设为siteB.abc.com</a>。<br> 可以都将domain设置为父级域名，<a href="http://xn--abc-c88d926tlppumi.com" rel="nofollow">都设置为abc.com</a>。这在使用单点登录时作为一种简单的处理跨域请求的方法。</p> 
<ol start="4"><li>path<br> <strong>默认值</strong><br> 默认情况下，会截取请求的domain到最后一个斜杠前的路径，作为path，如http://siteA.abc.com/test/a/index.html会取/test/ a/。<br> 如果有需要，我们可以手动设置path。<br> domain和path合成为一个整体路径，表示什么样的请求能够访问Cookie。<br> 如果path设为test/a，则test/a/路径下的所有子路径都可以访问该Cookie。而test/下的其它路径则无法访问该Cookie。<br> 注意：<br> 如果你的Cookie是整站都要使用的，而当前response路径并不是根路径，需要使用setPath("/")手动设置为根路径。</li></ol> 
<p>  domain和path的默认值设置逻辑，在java.net包的CookieManager.java下，描述了如何按照RFC 2965文档标准进行的值设置逻辑。<br>   但是我debug并不会走这里，也没在java代码中找到哪里设置了这俩的默认值，我甚至怀疑这个值是浏览器最终判定与设定的。。。如果有人找到设置默认值的地方，请告诉我。</p> 
<ol start="5"><li> <p>maxAge<br> 默认值为-1<br> 表示Cookie的过期时间，如果Cookie设置了过期时间，Cookie会存储在硬盘中。如果设置Cookie为-1（默认值）或者0，Cookie会在浏览会话结束后删除。<br> 浏览会话结束的意思是浏览器完全关闭</p> </li><li> <p>不是页面关闭，即使将当前网站的所有页面关掉，设置为maxAge -1的Cookie仍然存活。</p> </li><li> <p>假设浏览器能开启多个，需要浏览器完全关闭，多个只是表现形式而已，事实上只有一个实例开启着。</p> </li><li> <p>version<br> 默认值为0。<br> 设置Cookie的版本，Cookie Version 0版本中，空格，方括号，圆括号，等于号（=），逗号，双引号，斜杠，问号，@符号，冒号，分号等“特殊”字符都不能作为Cookie的value。新的Cookie Version 1的版本可以使用这些字符，但是尚未被所有浏览器支持，主要是这个改变貌似。。。并没有多么必要。</p> </li><li> <p>secure<br> 默认值为false<br> 如果设置为true，表示只有https的请求才会去查询这个cookie，否则http和https都可以访问到cookie。如果你修改了请求的方式，可能cookie就查询不到了。<br> Cookie存储的时候，相同domain内，会按照协议分成两个大组， http和https，以https://开头的请求，只会取https组里面的Cookie。<br> 我们会在CA篇中详细讲到https。</p> </li><li> <p>httpOnly<br> 默认值为false<br> 如果设置为true，意味着只能从ServletRequest中获取Cookie，无法通过JavaScript获取Cookie，是防止XSS攻击的一种手段。</p> </li></ol> 
<h2><a id="Cookie_88"></a>五、Cookie存储在哪里</h2> 
<p>  Cookie存储在浏览器端，不同的浏览器存储位置不一样 ，无法跨浏览器使用。<br> 浏览器会先按照domain分组，domain内部按协议分组，组内按path分树的方式保存Cookie。这样最方便查询。<br>   在chrome浏览器中，可以通过设置（chrome://settings/）-&gt;高级-&gt;内容设置-&gt;Cookie-&gt;查看所有 Cookie 和网站数据来查看和单独删除某个网站的Cookie。<br> <img src="https://images2.imgbox.com/2e/f8/hVykbyBV_o.png" alt="在这里插入图片描述"><br>   这里面脚本可访问就是httpOnly，到期时间就是maxAge</p> 
<p>  在清除浏览器缓存时，如果选择了清除Cookie，那么将会清除掉保存的网站设置，网站账号密码，和当前登录有关的数据JSESSION_ID、JWT、或者其它Token<br> <img src="https://images2.imgbox.com/5e/a9/5LQcxuaY_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="Cookie_97"></a>六、Cookie如何传到后台</h2> 
<p>  浏览器发送任何请求的时候，会根据当前请求的domain和path去cookie里面匹配，将匹配到的cookie带在Request Header中去请求数据。</p> 
<h2><a id="Cookie_99"></a>七、后台如何处理Cookie</h2> 
<p>  后台通过HttpServletRequest的getCookies()方法获取Cookie[]数组，我们需要通过getName来进行匹配，找到我们想用的Cookie。<br>   传到后台的Cookie中domain和path都为空，只要是浏览器自动带着的，就是浏览器根据当前request的url筛选后的，我们直接使用即可，domain和path没有意义。</p> 
<h2><a id="Cookie_102"></a>八、Cookie存储空间与数量的限制</h2> 
<p>  Cookie存储有大小与数量的限制，不同浏览器实现不同，大约是每个域名下4k的空间与50个Cookie。</p> 
<h2><a id="WebWeb_Storage_104"></a>九、Web本地存储(Web Storage)</h2> 
<p>  Web Storage由于和Cookie的可比性很强，并且内容很简单，我们放到一起说下。</p> 
<h3><a id="1Web_Storage_106"></a>1、Web Storage的产生</h3> 
<p>  Cookie的特性，导致了另外一种（两种）Web端存储的产生。</p> 
<ol><li>最主要原因是Cookie每次请求必须带着所有Cookies数据，假设需要按条件来决定什么时候该获取什么数据，Cookie不提供这种自由性。</li><li>Cookie可以被禁用或者手动清除，会造成数据丢失。</li><li>Cookie有限的空间和数量限制。假设有很多的数据需要临时存储，比如很多网页游戏，手机端H5 App都有离线的功能，等能连接网络的时候，再将数据同步上去。这个时候使用Cookie，无论是空间还是数量都无法满足要求。</li></ol> 
<h3><a id="2Web_Storage_111"></a>2、Web Storage简单介绍</h3> 
<p>  为了解决Web端存储的问题，H5推出了Web Storage。<br>   有两种Web Storage，LocalStorage和SessionStorage。这两种的唯一区别就是SessionStorage会在浏览器会话结束后清空，这和maxAge为-1的Cookie效果相同。而LocalStorage永久存储，只能通过编程手段删除（当然这并不绝对，并不能阻止你找到LocalStorage的本地存储位置，去删掉）。<br>   Web Storage通过键值对保存，键值都为String类型，如果你想在键/值中存储复杂对象，需要使用JSON.stringify或者JSON.parse进行序列化与反序列化。<br>   Web Storage通过同源策略访问，这一点和Cookie差别比较大，Cookie依靠domain和path，如果不限制secure，将能取到http和https的。Web Storage依靠同源，也就是协议+domain+端口。<br>   Web Storage能够存储5M的数据，并不限制数据条数，足够保存很多应用的离线数据。</p> 
<h3><a id="3Web_Storage_118"></a>3、Web Storage的问题</h3> 
<p>  Web Storage被设计为Web端的存储介质，作为存储比Cookie有很多优势。但是毕竟只是Web端存储，数据安全性无法保证。这包括两个方面：1、数据并不是绝对不会被删除；2、数据以明文显示，很好获取。<br>   所以WebStorage只是作为辅助存储的手段，应用在如离线数据等非敏感数据的本地缓存。</p> 
<h3><a id="4LocalStorageJwt_Token_122"></a>4、LocalStorage用于存储Jwt Token</h3> 
<p>  我们会在Jwt篇横向比较Jwt Token在Web端的存储方式，LocalStorage配合Authorization Header，会是保存Jwt Token的最佳实践。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/828c8f1972662df6bfbb550f2d9f3810/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">proxmox中的好用qm命令,救命就用它了!解决locked的问题</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/7b93dde6fb4781249a74a456831f5ccb/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">vue-grid-layout组件的改装--暴露布局方法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>