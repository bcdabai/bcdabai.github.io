<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>浅谈linux缓冲区的认识！ - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="浅谈linux缓冲区的认识！" />
<meta property="og:description" content="今天来为大家分享一波关于缓冲区的知识！那么既然我们要谈缓冲区，那么就得从是什么？为什么？有什么作用这几个方面来谈论一下缓冲区！然后再通过一些代码来更加深刻的理解缓冲区的知识！
引言： 是什么？ 从最简单的理解方面来，我们可以将缓冲区理解成一块内存！那么这块内存是从哪里来的呢？在linux中一般我们所说的缓冲区都是由C提供的语言级别的缓冲区！
干什么的？ 那么缓冲区的作用主要是用来干什么的呢？可以从我们生活中的例子来理解！假设你的朋友小张下个月就要过生日了，你要送他一个生日礼物！但是你们两个距离很远！一个在西藏，一个在海南！如果让你自行将生日礼物送给他，那么无疑将会浪费你的很多成本！但是现实中存在快递站，只需要你下楼将礼物交付给快递站，然后由快递站代替你送过去即可！那么在本例子内，快递站的作用就是一个缓冲区的作用！
为什么要存在缓冲区？ 根据上面提到的例子，很容易理解，因为有了快递站的存在，使我们方便了很多！所以类似于此，缓冲区存在的意义就是为了提高效率，减少我们的成本！
下面通过一段代码来证明一下缓冲区确实存在！
我们用户通常写程序在屏幕上打印一段文字的时候！其中就利用到了缓冲区！例如下面这个例子！
运行这段程序之后，显示屏上并没没有立刻打印出“hello linux”，这是为什么呢？根据我们所了解到的知识，程序是自上向下运行的，运行到sleep的时候，printf语句一定是执行过了，但是为什么没有打印出结果呢？根据此例子可以充分的证明缓冲区的存在！！既然证明了缓冲区的存在，那么我们将来一步一步的进行分析缓冲区的相关知识1
那么从系统角度来将该如何理解的呢？
从操作系统角度上来看！用户输入一段指令，该指令并没有直接传递到内核文件内存中！而是将用户输入的指令存放到了C提供的语言级别的缓冲区内！然后在C语言的缓冲区中经过刷新之后！再传递到内核结构中的文件缓冲区中！最后系统会定期的将内存的数据刷新到磁盘中！此阶段也可以称之为刷新！在此，我们提到了两个缓冲区，一个是用户层的C语言提供的语言级别的缓冲区，一个是内核结构中的内核文件缓冲区！一般我们所考虑的都是C语言提供的语言级别的缓冲区！
缓冲区的一些特性： 根据缓冲区能够存储一定的数据可以推出：缓冲区一定存在着刷新的方式！
1.无缓冲（立即刷新！）
2.行缓冲（行刷新！）
一般对于显示器文件，都是基于行缓冲的模式！
3.全缓冲（存放满然后进行刷新！）
对于磁盘文件，都是基于全缓冲的方式！
那么根据以上的特征，缓冲区也会有着特殊的情况！
1.强制刷新！
2.进程退出后，会自动进行刷新！（无论是否满足刷新的条件！）
实例：充分理解缓冲区 下面通过一段代码来充分理解缓冲区中的行缓冲和全缓冲！
上面代码运行过后，每行代码都打印了出来！这是为什么呢？刚才不是还说是存在缓冲区的么？其实不难理解，因为每段代码都有了\n换行符，强制让缓冲区内的数据进行刷新！所以数据都原样的打印了出来！！
那么将上面的代码经过简单的修改就会出现另外一种结果！
经过上面代码简单的修改，我们发现C函数的调用都打印了两次，而是用系统调用的write确只调用了一次！这是为什么呢？其实很简单！
我们可以看出，我们将输出结果由原来的行缓冲转化成了全缓冲（因为将结果打印到了log.txt文本文件中，文本文档默认为全缓冲的刷新方式！）所以只有当将缓冲区填满的时候，才会进行刷新！才能打印到显示屏中！又因为调用了fork函数，创建了新的子进程！根据fork的特性会继承父进程的代码和数据块！因为此时代码仍然在缓冲区内！所以子进程也会继承这些相同的代码和数据块！然后当一个进程结束后，就会发生写时拷贝！这是因为当一个进程退出的时候，一般都会对缓冲区的数据进行刷新，那么算不算清空或写入的操作呢？答案是肯定的！当时算！所以就会发生写时拷贝！所以可以推出，一旦一个进程退出，那么就会发生写时拷贝！
根据上图结果看出，系统调用write只打印了一次！从这里可以推出：write没用使用C语言的缓冲区！因为C语言的一些函数，大多都是对系统调用的封装！大多都是因为封装的原因！而导致他们使用C提供的缓冲区！而系统调用处于内核级别，在用户级别的下面，直接将数据写入到内核文件系统中！所以不使用C提供的缓冲区！
实例中的主要知识点： 1.当我们直接向显示器打印的时候，显示器文件的刷新方式是行刷新！而是我们的代码输出的所有字符串，都有\n，fork之前，数据已经全部被刷新！包括systemcall！
2.重定向到log.txt之后，本质是向磁盘文件中写入(而不再是显示器里面！），我们系统对于数据的刷新方式已经由行刷新转化到了全刷新的方式！变成了全缓冲！
3.全缓冲意味着缓冲区变大，实际写入的简单数据，不足以将缓冲区填满！fork执行的时候，数据依然在缓冲区内部！
4.我们目前所谈的缓冲区，是和操作系统没有关系的！只能和C语言本身有关！！
5.C/C&#43;&#43;提供的缓冲区，里面保存的一定是用户的数据！其属于当前进程运行的数据！但是如果当把数据交付给OS,这些数据就属于OS了，不再属于该进程了！
6.当进程退出的时候，一般会进行刷新缓冲区，即使我们的数据没有满足刷新条件！
证明缓冲区的存在以及其在内核中的结构！ 既然我们都讲了这么多关于缓冲区的知识了，那么我们确实已经知道了缓冲区真实存在！那么能否让我看一看其到底是什么样子的呢？
通过以上函数，我们可以发现，大多的输入输出操作，以及文件的操作都用到了FILE该结构体！那么该结构体之中我们之前知道其包含了文件描述符fd，那么其是否介意再包含一个缓冲区的成员变量呢?答案是当然不介意的啦！
我们可以通过对FILE的观察来看一下缓冲区的真实存在！
我们通过grep指令来查看FILE的路径！然后在FILE内部继续进行查找，最后看到FILE内部有我们熟悉的文件描述符_fileno,以及我们今天所讲的缓冲区的内容！
至此，本文关于缓冲区的介绍到此为止，希望读完本篇文章，能对读者有一定的收获！" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/e8ec31e120b08cb92b80139f5a8ca037/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-09T00:03:35+08:00" />
<meta property="article:modified_time" content="2023-12-09T00:03:35+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">浅谈linux缓冲区的认识！</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>今天来为大家分享一波关于缓冲区的知识！那么既然我们要谈缓冲区，那么就得从是什么？为什么？有什么作用这几个方面来谈论一下缓冲区！然后再通过一些代码来更加深刻的理解缓冲区的知识！</p> 
<h2><strong>引言：</strong></h2> 
<h3>是什么？</h3> 
<p>从最简单的理解方面来，我们可以将缓冲区理解成一块内存！那么这块内存是从哪里来的呢？在linux中一般我们所说的缓冲区都是由C提供的语言级别的缓冲区！</p> 
<h3>干什么的？</h3> 
<p>那么缓冲区的作用主要是用来干什么的呢？可以从我们生活中的例子来理解！假设你的朋友小张下个月就要过生日了，你要送他一个生日礼物！但是你们两个距离很远！一个在西藏，一个在海南！如果让你自行将生日礼物送给他，那么无疑将会浪费你的很多成本！但是现实中存在快递站，只需要你下楼将礼物交付给快递站，然后由快递站代替你送过去即可！那么在本例子内，快递站的作用就是一个缓冲区的作用！</p> 
<hr> 
<h3>为什么要存在缓冲区？</h3> 
<p>根据上面提到的例子，很容易理解，因为有了快递站的存在，使我们方便了很多！所以类似于此，缓冲区存在的意义就是为了提高效率，减少我们的成本！</p> 
<hr> 
<p></p> 
<p>下面通过一段代码来证明一下缓冲区确实存在！</p> 
<p>我们用户通常写程序在屏幕上打印一段文字的时候！其中就利用到了缓冲区！例如下面这个例子！</p> 
<p><img alt="" height="269" src="https://images2.imgbox.com/45/4b/fsmJkvZl_o.png" width="566"></p> 
<p>运行这段程序之后，显示屏上并没没有立刻打印出“hello linux”，这是为什么呢？根据我们所了解到的知识，程序是自上向下运行的，运行到sleep的时候，printf语句一定是执行过了，但是为什么没有打印出结果呢？根据此例子可以充分的<span style="color:#fe2c24;"><strong>证明缓冲区的存在</strong></span>！！既然证明了缓冲区的存在，那么我们将来一步一步的进行分析缓冲区的相关知识1</p> 
<p>那么从系统角度来将该如何理解的呢？</p> 
<p>从操作系统角度上来看！用户输入一段指令，该指令并没有直接传递到内核文件内存中！而是将用户输入的指令存放到了C提供的语言级别的缓冲区内！然后在C语言的缓冲区中经过刷新之后！再传递到内核结构中的文件缓冲区中！最后系统会定期的将内存的数据刷新到磁盘中！此阶段也可以称之为刷新！在此，我们提到了两个缓冲区，一个是用户层的C语言提供的语言级别的缓冲区，一个是内核结构中的内核文件缓冲区！一般我们所考虑的都是C语言提供的语言级别的缓冲区！</p> 
<hr> 
<h3>缓冲区的一些特性：</h3> 
<p>根据缓冲区能够存储一定的数据可以推出：缓冲区一定存在着刷新的方式！</p> 
<p>1.无缓冲（立即刷新！）</p> 
<p>2.行缓冲（行刷新！）</p> 
<p><span style="color:#fe2c24;"><strong>一般对于显示器文件，都是基于行缓冲的模式！</strong></span></p> 
<p>3.全缓冲（存放满然后进行刷新！）</p> 
<p><span style="color:#fe2c24;"><strong>对于磁盘文件，都是基于全缓冲的方式！</strong></span></p> 
<hr> 
<p>那么根据以上的特征，缓冲区也会有着特殊的情况！</p> 
<p>1.强制刷新！</p> 
<p>2.进程退出后，会自动进行刷新！（无论是否满足刷新的条件！）</p> 
<hr> 
<h2>实例：充分理解缓冲区</h2> 
<p>下面通过一段代码来充分理解缓冲区中的行缓冲和全缓冲！</p> 
<p><img alt="" height="423" src="https://images2.imgbox.com/5d/d9/V7w1Wkeu_o.png" width="713"></p> 
<p><img alt="" height="136" src="https://images2.imgbox.com/c7/ab/V3C9icJ1_o.png" width="648"></p> 
<p>上面代码运行过后，每行代码都打印了出来！这是为什么呢？刚才不是还说是存在缓冲区的么？其实不难理解，因为每段代码都有了\n换行符，强制让缓冲区内的数据进行刷新！所以数据都原样的打印了出来！！</p> 
<p>那么将上面的代码经过简单的修改就会出现另外一种结果！</p> 
<p><img alt="" height="472" src="https://images2.imgbox.com/11/88/YtMtwfLj_o.png" width="796"></p> 
<p><img alt="" height="247" src="https://images2.imgbox.com/42/72/C6TFNgnL_o.png" width="781"></p> 
<p>经过上面代码简单的修改，我们发现C函数的调用都打印了两次，而是用系统调用的write确只调用了一次！这是为什么呢？其实很简单！</p> 
<p>我们可以看出，我们将输出结果由原来的行缓冲转化成了全缓冲（因为将结果打印到了log.txt文本文件中，文本文档默认为全缓冲的刷新方式！）所以只有当将缓冲区填满的时候，才会进行刷新！才能打印到显示屏中！又因为调用了fork函数，创建了新的子进程！根据fork的特性会继承父进程的代码和数据块！因为此时代码仍然在缓冲区内！所以子进程也会继承这些相同的代码和数据块！然后当一个进程结束后，就会发生写时拷贝！这是因为当一个进程退出的时候，一般都会对缓冲区的数据进行刷新，那么算不算清空或写入的操作呢？答案是肯定的！当时算！所以就会发生写时拷贝！所以可以推出，一旦一个进程退出，那么就会发生写时拷贝！</p> 
<p>根据上图结果看出，系统调用write只打印了一次！从这里可以推出：write没用使用C语言的缓冲区！因为C语言的一些函数，大多都是对系统调用的封装！大多都是因为封装的原因！而导致他们使用C提供的缓冲区！而系统调用处于内核级别，在用户级别的下面，直接将数据写入到内核文件系统中！所以不使用C提供的缓冲区！</p> 
<h2>实例中的主要知识点：</h2> 
<p>1.当我们直接向显示器打印的时候，显示器文件的刷新方式是行刷新！而是我们的代码输出的所有字符串，都有\n，fork之前，数据已经全部被刷新！包括systemcall！</p> 
<p>2.重定向到log.txt之后，本质是向磁盘文件中写入(而不再是显示器里面！），我们系统对于数据的刷新方式已经由行刷新转化到了全刷新的方式！变成了全缓冲！</p> 
<p>3.全缓冲意味着缓冲区变大，实际写入的简单数据，不足以将缓冲区填满！fork执行的时候，数据依然在缓冲区内部！</p> 
<p>4.我们目前所谈的缓冲区，是和操作系统没有关系的！只能和C语言本身有关！！</p> 
<p>5.C/C++提供的缓冲区，里面保存的一定是用户的数据！其属于当前进程运行的数据！但是如果当把数据交付给OS,这些数据就属于OS了，不再属于该进程了！</p> 
<p>6.当进程退出的时候，一般会进行刷新缓冲区，即使我们的数据没有满足刷新条件！</p> 
<hr> 
<h2>证明缓冲区的存在以及其在内核中的结构！</h2> 
<p>既然我们都讲了这么多关于缓冲区的知识了，那么我们确实已经知道了缓冲区真实存在！那么能否让我看一看其到底是什么样子的呢？</p> 
<p><img alt="" height="408" src="https://images2.imgbox.com/03/ed/wYpGyqMP_o.png" width="549"></p> 
<p>通过以上函数，我们可以发现，大多的输入输出操作，以及文件的操作都用到了FILE该结构体！那么该结构体之中我们之前知道其包含了文件描述符fd，那么其是否介意再包含一个缓冲区的成员变量呢?答案是当然不介意的啦！</p> 
<p>我们可以通过对FILE的观察来看一下缓冲区的真实存在！</p> 
<p><img alt="" height="84" src="https://images2.imgbox.com/76/f0/saOj8vR3_o.png" width="1200"></p> 
<p><img alt="" height="656" src="https://images2.imgbox.com/6d/38/gGhrLYZz_o.png" width="974"></p> 
<p>我们通过grep指令来查看FILE的路径！然后在FILE内部继续进行查找，最后看到FILE内部有我们熟悉的文件描述符_fileno,以及我们今天所讲的缓冲区的内容！</p> 
<hr> 
<p></p> 
<p>至此，本文关于缓冲区的介绍到此为止，希望读完本篇文章，能对读者有一定的收获！</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/1ffb445b284e30419cdcd07cace15911/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Visual Studio Code 1.85 发布，浮动窗口</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/84e14fb4496e7c980d15fb6ab2f319fc/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">.net6 SqlSugar配置及增删改查（webapi项目）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>