<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Linux下Centos7 gcc/g&#43;&#43;、动态库/静态库（动态/静态链接） - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Linux下Centos7 gcc/g&#43;&#43;、动态库/静态库（动态/静态链接）" />
<meta property="og:description" content="1.gcc/g&#43;&#43; gcc是对c语言代码进行编译链接，而g&#43;&#43;是对c&#43;&#43;代码进行编译链接，接下来我们只对gcc进行讲解，g&#43;&#43;的使用方法跟gcc是一样的。
编译链接的四个步骤:
1:预处理
2:编译
3:汇编
4:链接
注：这些在后面都会着重讲解
1.1gcc -o 我们先在Date.c 源文件里面写一些c语言代码，我们知道，c语言代码需要编译链接翻译为计算机能识别的二进制指令才能执行。而gcc就是Linux环境下用来对c语言代码编译链接的指令.
gcc 源文件 -o 生成指定的文件名
gcc Date.c -o date.aout
注：这里会一步到位，直接会生成一个可执行程序，接下来我们再一步一步分析具体细节
1.2gcc -E （预处理）(.i) 预处理：头文件展开、去注释、宏替换、条件编译
-E:当程序进行翻译时，预处理阶段执行完就停下来
gcc Date.c -o date.aout -E
头文件展开：#include&lt;stdio.h&gt;这个文件里面有很多函数的声明和typedef的内容，头文展开会将stdio.h这个文件中所有的内容复制一份到我们的date.i文件中。
去注释：会将我们注释的内容替换为空格。
1.3gcc -S (编译)(.s) 编译：将c语言写的内容翻译为汇编语言
-S:当程序进行翻译时，编译阶段执行完就停下来
gcc Date.c -o date.s -S
1.4gcc -c （汇编）(.o) 汇编：将汇编语言翻译为二进制语言。
-c:当程序进行翻译时，编译阶段执行完就停下来
gcc Date.c -o date.o -c
1.5gcc -o (链接) 当我们不带-E、-S、-c这些选项时，直接-o，gcc就会一步到位从预处理阶段到编译，再到汇编，最后到链接！！！
在我们上面写的c语言代码中，我们并没有写printf函数的具体实现，而在&lt;stdio.h&gt;这个文件中也只有printf函数的声明而没有其具体实现的定义，那么我们再使用printf这个函数的时候怎么去调用这个函数呢？
在Linux Centos7 环境下，系统把这些函数的具体实现都放在了一个名为libc.so.6的库文件中了，路径为/usr/lib/libc.so.6，当我们调用printf函数时，会去libc.so.6库文件中去寻找printf实现的实现方法，最终成功调用。
我们可以使用ldd &#43; 可执行程序 来查看该可执行程序依赖了那些库文件
2.动态库/静态库 2.1.再谈链接 链接的时候，我们是怎么去库文件中寻找函数具体实现的方法的呢？
有两种情况，一种是我们得到函数的地址，在生成可执行程序时根据地址去调用这个函数，另一种则是我们得到这个函数的整体实现过程，在生成可执行程序时将函数实现的代码加载进来。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/77d8ce5e17728a87d9f4c2e6f216c8b9/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-11-20T19:54:54+08:00" />
<meta property="article:modified_time" content="2023-11-20T19:54:54+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Linux下Centos7 gcc/g&#43;&#43;、动态库/静态库（动态/静态链接）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2 style="background-color:transparent;">1.gcc/g++</h2> 
<p>gcc是对c语言代码进行编译链接，而g++是对c++代码进行编译链接，接下来我们只对gcc进行讲解，g++的使用方法跟gcc是一样的。</p> 
<blockquote> 
 <p>编译链接的四个步骤:</p> 
 <p>1:预处理</p> 
 <p>2:编译</p> 
 <p>3:汇编</p> 
 <p>4:链接</p> 
 <p><span style="color:#fe2c24;"><strong>注：这些在后面都会着重讲解</strong></span></p> 
</blockquote> 
<h3 style="background-color:transparent;">1.1gcc -o </h3> 
<p><img alt="" height="455" src="https://images2.imgbox.com/1e/7a/RdflmVUd_o.png" width="584"></p> 
<p>我们先在Date.c 源文件里面写一些c语言代码，我们知道，c语言代码需要编译链接翻译为计算机能识别的二进制指令才能执行。而gcc就是Linux环境下用来对c语言代码编译链接的指令.</p> 
<blockquote> 
 <p>gcc 源文件 -o 生成指定的文件名</p> 
 <p>gcc Date.c -o date.aout</p> 
</blockquote> 
<p><img alt="" height="391" src="https://images2.imgbox.com/07/6c/gr9wRYYZ_o.png" width="754"></p> 
<p><span style="color:#fe2c24;"><strong>注：这里会一步到位，直接会生成一个可执行程序，接下来我们再一步一步分析具体细节</strong></span></p> 
<h3 style="background-color:transparent;">1.2gcc -E （预处理）(.i)</h3> 
<blockquote> 
 <p>预处理：头文件展开、去注释、宏替换、条件编译</p> 
</blockquote> 
<blockquote> 
 <p><span style="color:#fe2c24;"><strong>-E:当程序进行翻译时，预处理阶段执行完就停下来</strong></span></p> 
 <p>gcc Date.c -o date.aout -E</p> 
</blockquote> 
<p><img alt="" height="180" src="https://images2.imgbox.com/9b/1e/6ExeqGQY_o.png" width="673"></p> 
<p><img alt="" height="905" src="https://images2.imgbox.com/39/8c/fIYuiJl2_o.png" width="1200"></p> 
<blockquote> 
 <p>头文件展开：#include&lt;stdio.h&gt;这个文件里面有很多函数的声明和typedef的内容，头文展开会将stdio.h这个文件中所有的内容复制一份到我们的date.i文件中。</p> 
 <p>去注释：会将我们注释的内容替换为空格。</p> 
</blockquote> 
<h3 style="background-color:transparent;">1.3gcc -S (编译)(.s)</h3> 
<blockquote> 
 <p>编译：将c语言写的内容翻译为汇编语言</p> 
</blockquote> 
<blockquote> 
 <p><span style="color:#fe2c24;"><strong>-S:当程序进行翻译时，编译阶段执行完就停下来</strong></span></p> 
 <p>gcc Date.c -o date.s -S</p> 
</blockquote> 
<p><img alt="" height="219" src="https://images2.imgbox.com/c4/c4/nG9VIUiN_o.png" width="855"></p> 
<p><img alt="" height="834" src="https://images2.imgbox.com/c7/24/SfpkTp68_o.png" width="1091"></p> 
<h3 style="background-color:transparent;">1.4gcc -c （汇编）(.o)</h3> 
<blockquote> 
 <p>汇编：将汇编语言翻译为二进制语言。</p> 
</blockquote> 
<blockquote> 
 <p><span style="color:#fe2c24;"><strong>-c:当程序进行翻译时，编译阶段执行完就停下来</strong></span></p> 
 <p>gcc Date.c -o date.o -c</p> 
</blockquote> 
<p><img alt="" height="265" src="https://images2.imgbox.com/a3/32/kdpE0s6E_o.png" width="843"></p> 
<h3>1.5gcc -o (链接)</h3> 
<p><span style="color:#fe2c24;"><strong>当我们不带-E、-S、-c这些选项时，直接-o，gcc就会一步到位从预处理阶段到编译，再到汇编，最后到链接！！！</strong></span></p> 
<blockquote> 
 <p>在我们上面写的c语言代码中，我们并没有写printf函数的具体实现，而在&lt;stdio.h&gt;这个文件中也只有printf函数的声明而没有其具体实现的定义，那么我们再使用printf这个函数的时候怎么去调用这个函数呢？</p> 
</blockquote> 
<blockquote> 
 <p>在Linux Centos7 环境下，系统把这些函数的具体实现都放在了一个名为<strong><span style="color:#fe2c24;">libc.so.6</span></strong>的<span style="color:#fe2c24;"><strong>库文件</strong></span>中了，路径为/usr/lib/libc.so.6，当我们调用printf函数时，会去libc.so.6库文件中去寻找printf实现的实现方法，最终成功调用。</p> 
</blockquote> 
<p>我们可以使用ldd + 可执行程序 来查看该可执行程序依赖了那些库文件</p> 
<p><img alt="" height="400" src="https://images2.imgbox.com/ce/d5/PIMamJF5_o.png" width="988"></p> 
<h2>2.动态库/静态库 </h2> 
<h3>2.1.再谈链接</h3> 
<p>链接的时候，我们是怎么去库文件中寻找函数具体实现的方法的呢？</p> 
<p>有两种情况，一种是我们得到函数的地址，在生成可执行程序时根据地址去调用这个函数，另一种则是我们得到这个函数的整体实现过程，在生成可执行程序时将函数实现的代码加载进来。</p> 
<p>根据链接方式的不同，库文件也就分成了两种：动态库/静态库，动态库使用动态链接，静态库使用静态链接。</p> 
<h3>2.2动态库</h3> 
<div> 
 <span style="color:#777777;">动态库在程序执行时由运行时链接文件加载库，通俗来说就是调用这个函数的地址，可执行程序中并不包含此函数的具体实现方法，减小了可执行程序的大小。</span> 
</div> 
<blockquote> 
 <div> 
  <span style="color:#fe2c24;"><strong>注：gcc在编译时默认使用动态库！！！</strong></span> 
 </div> 
 <div> 
  <span style="color:#777777;"><strong>优点：比较节省资源（磁盘、内存、网络等资源），不会出现太多重复代码</strong></span> 
 </div> 
 <div> 
  <strong><span style="color:#777777;">缺点：太过于依赖库，一旦库缺失，所有使用该库的程序都不能运行！！！</span></strong> 
 </div> 
</blockquote> 
<div> 
 <img alt="" height="276" src="https://images2.imgbox.com/99/a5/cPISKaFR_o.png" width="1200"> 
</div> 
<h3>2.3静态库</h3> 
<div> 
 <span style="color:#777777;">静态库是指编译链接时</span> 
 <span style="color:#777777;">,</span> 
 <span style="color:#777777;">把库文件的代码全部加入到可执行文件中，因此生成的可执行程序占用的空间比较大，但是运行时也就不依赖库了。</span> 
</div> 
<blockquote> 
 <div> 
  <strong><span style="color:#777777;">优点：不依赖库，同类型平台中可以直接运行使用。</span></strong> 
 </div> 
 <div> 
  <strong><span style="color:#777777;">缺点：可执行程序占用空间比较大，比较浪费资源（磁盘、内存、网络等资源）</span></strong> 
 </div> 
</blockquote> 
<p>gcc编译时使用-static选项可以在链接时使用静态链接的方式链接静态可。</p> 
<blockquote> 
 <p>gcc -o mybin-static test.c -static</p> 
</blockquote> 
<h3><img alt="" height="144" src="https://images2.imgbox.com/be/2b/dp2xBC9C_o.png" width="990"></h3> 
<p>但是我们直接执行的话会出现问题，这里的原因是因为我们的系统中没用静态库，导致静态链接失败。我们可以使用yum命令下载c/c++的静态库，在root用户下执行，或者使用sudo命令。如果不清楚yum命令的可以看我这一篇博客<a href="http://t.csdnimg.cn/M1JLr" rel="nofollow" title="http://t.csdnimg.cn/M1JLr">http://t.csdnimg.cn/M1JLr</a></p> 
<blockquote> 
 <p>sudo yum install -y glibc-static libstdc++-static</p> 
</blockquote> 
<p>安装好静态库之后 我们再进行一次编译gcc -o mybin-static test.c -static</p> 
<p><img alt="" height="275" src="https://images2.imgbox.com/81/65/ecYPnC8b_o.png" width="1081"></p> 
<p>由图可知，静态链接静态库生成的可执行程序比动态链接动态库生成的可执行程序要大得多</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/38a9a9a98242040aa4047e646d5ee374/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">深信服技术认证“SCSA-S”划重点：渗透测试工具使用</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/cf1310250cdfdd0d3da972d8d3207399/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">网络的七层概念</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>