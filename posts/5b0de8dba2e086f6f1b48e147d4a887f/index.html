<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>deque用法详解 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="deque用法详解" />
<meta property="og:description" content="“无意中发现了一个巨牛的人工智能教程，忍不住分享一下给大家。教程不仅是零基础，通俗易懂，而且非常风趣幽默，像看小说一样！觉得太牛了，所以分享给大家。点这里可以跳转到教程。” deque函数： deque容器为一个给定类型的元素进行线性处理，像向量一样，它能够快速地随机访问任一个元素，并且能够高效地插入和删除容器的尾部元素。但它又与vector不同，deque支持高效插入和删除容器的头部元素，因此也叫做双端队列。deque类常用的函数如下。
(1) 构造函数
deque():创建一个空deque
deque(int nSize):创建一个deque,元素个数为nSize
deque(int nSize,const T&amp; t):创建一个deque,元素个数为nSize,且值均为t
deque(const deque &amp;):复制构造函数
(2) 增加函数
void push_front(const T&amp; x):双端队列头部增加一个元素X
void push_back(const T&amp; x):双端队列尾部增加一个元素x
iterator insert(iterator it,const T&amp; x):双端队列中某一元素前增加一个元素x
void insert(iterator it,int n,const T&amp; x):双端队列中某一元素前增加n个相同的元素x
void insert(iterator it,const_iterator first,const_iteratorlast):双端队列中某一元素前插入另一个相同类型向量的[forst,last)间的数据
(3) 删除函数
Iterator erase(iterator it):删除双端队列中的某一个元素
Iterator erase(iterator first,iterator last):删除双端队列中[first,last）中的元素
void pop_front():删除双端队列中最前一个元素
void pop_back():删除双端队列中最后一个元素
void clear():清空双端队列中最后一个元素
(4) 遍历函数
reference at(int pos):返回pos位置元素的引用
reference front():返回首元素的引用
reference back():返回尾元素的引用
iterator begin():返回向量头指针，指向第一个元素
iterator end():返回指向向量中最后一个元素下一个元素的指针（不包含在向量中）
reverse_iterator rbegin():反向迭代器，指向最后一个元素" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/5b0de8dba2e086f6f1b48e147d4a887f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-04-13T09:15:38+08:00" />
<meta property="article:modified_time" content="2018-04-13T09:15:38+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">deque用法详解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h4>“无意中发现了一个巨牛的人工智能教程，忍不住分享一下给大家。教程不仅是零基础，通俗易懂，而且非常风趣幽默，像看小说一样！觉得太牛了，所以分享给大家。<a href="https://www.cbedai.net/u011630575" rel="nofollow">点这里可以跳转到教程</a>。”</h4> 
<h2>deque函数：</h2> 
<p>      deque容器为一个给定<strong><span style="color:#cc0000;">类型</span></strong>的元素进行<span style="color:#cc0000;"><strong>线性处理</strong></span>，像向量一样，它<strong><span style="color:#cc0000;">能够快速地随机访问任一个元素</span></strong>，并且能够高效地<strong><span style="color:#cc0000;">插入和删除</span></strong>容器的尾部元素。但它又与vector不同，<strong><span style="color:#cc0000;">deque支持高效插入和删除容器的头部元素</span></strong>，因此也叫做<strong><span style="color:#cc0000;">双端队列</span></strong>。deque类常用的函数如下。</p> 
<p>(1)    构造函数</p> 
<p>deque():创建一个空deque</p> 
<p>deque(int nSize):<strong>创建一个deque,元素个数为nSize</strong></p> 
<p>deque(int nSize,const T&amp; t):创建一个deque,元素个数为nSize,且值均为t</p> 
<p>deque(const deque &amp;):复制构造函数</p> 
<p>(2)    增加函数</p> 
<p>void <span style="color:#cc0000;"><strong>push_front(const T&amp; x):双端队列头部增加一个元素X</strong></span></p> 
<p>void <strong><span style="color:#cc0000;">push_back(const T&amp; x):双端队列尾部增加一个元素x</span></strong></p> 
<p>iterator <span style="color:#cc0000;"><strong>insert</strong></span>(iterator it,const T&amp; x):双端队列中<strong><span style="color:#cc0000;">某一元素前</span></strong>增加一个元素x</p> 
<p>void <span style="color:#cc0000;"><strong>insert</strong></span>(iterator it,int n,const T&amp; x):双端队列中<strong><span style="color:#cc0000;">某一元素前</span></strong>增加n个相同的元素x</p> 
<p>void <span style="color:#cc0000;"><strong>insert</strong></span>(iterator it,const_iterator first,const_iteratorlast):双端队列中<strong><span style="color:#cc0000;">某一元素前</span></strong>插入另一个相同类型向量的[forst,last)间的数据</p> 
<p>(3)    删除函数</p> 
<p>Iterator <span style="color:#990000;"><strong>erase</strong></span>(iterator it):删除双端队列中的<strong><span style="color:#cc0000;">某一个元素</span></strong></p> 
<p>Iterator <span style="color:#cc0000;"><strong>erase</strong></span>(iterator first,iterator last):删除双端队列中[first,last）中的元素</p> 
<p>void pop_front():删除双端队列中<strong><span style="color:#cc0000;">最前一个元素</span></strong></p> 
<p>void pop_back():删除双端队列中<strong><span style="color:#cc0000;">最后一个元素</span></strong></p> 
<p>void clear():清空双端队列中最后一个元素</p> 
<p>(4)    遍历函数</p> 
<p>reference at(int pos):返回pos位置元素的引用</p> 
<p>reference <strong>front</strong>():返回<strong><span style="color:#cc0000;">首元素的引用</span></strong></p> 
<p>reference <strong>back</strong>():返回<strong><span style="color:#cc0000;">尾元素的引用</span></strong></p> 
<p>iterator <strong><span style="color:#cc0000;">begin</span></strong>():返回向量头指针，指向第一个元素</p> 
<p>iterator <strong><span style="color:#cc0000;">end</span></strong>():返回指向向量中最后一个元素下一个元素的指针（不包含在向量中）</p> 
<p>reverse_iterator <strong>rbegin</strong>():反向迭代器，指向最后一个元素</p> 
<p>reverse_iterator rend():反向迭代器，指向第一个元素的前一个元素</p> 
<p>(5)    判断函数</p> 
<p>bool empty() const:向量是否为空，若true,则向量中无元素</p> 
<p>(6)    大小函数</p> 
<p>Int<strong> size()</strong> const:返回向量中元素的个数</p> 
<p>int <strong>max_size() </strong>const:返回最大可允许的双端对了元素数量值</p> 
<p>(7)    其他函数</p> 
<p>void swap(deque&amp;):交换两个同类型向量的数据</p> 
<p>void assign(int n,const T&amp; x):向量中第n个元素的值设置为x</p> 
<p> </p> 
<h2>操作示例：</h2> 
<p><strong>[cpp]</strong> <a class="ViewSource" href="https://blog.csdn.net/longshengguoji/article/details/8519812#">view plain</a> <a class="CopyToClipboard" href="https://blog.csdn.net/longshengguoji/article/details/8519812#">copy</a></p> 
<ol><li><span style="color:#000000;"><span style="color:#008200;">// deque.cpp : 定义控制台应用程序的入口点。</span>  </span></li><li><span style="color:#000000;"><span style="color:#008200;">//</span>  </span></li><li><span style="color:#000000;">  </span></li><li><span style="color:#000000;"><span style="color:#808080;">#include "stdafx.h"</span>  </span></li><li><span style="color:#000000;"><span style="color:#808080;">#include&lt;iostream&gt;</span>  </span></li><li><span style="color:#000000;"><span style="color:#808080;">#include&lt;deque&gt;</span>  </span></li><li><span style="color:#000000;">  </span></li><li><span style="color:#000000;"><strong>using</strong> <strong>namespace</strong> std;  </span></li><li><span style="color:#000000;"><strong>int</strong> _tmain(<strong>int</strong> argc, _TCHAR* argv[])  </span></li><li><span style="color:#000000;">{  </span></li><li><span style="color:#000000;">    deque&lt;<strong>int</strong>&gt; d;  </span></li><li><span style="color:#000000;">    d.push_back( 10 );  </span></li><li><span style="color:#000000;">    d.push_back(20);  </span></li><li><span style="color:#000000;">    d.push_back(30);  </span></li><li><span style="color:#000000;">    cout&lt;&lt;<span style="color:#0000ff;">"原始双端队列："</span>&lt;&lt;endl;  </span></li><li><span style="color:#000000;">    <strong>for</strong>(<strong>int</strong> i = 0; i &lt; d.size(); i++)  </span></li><li><span style="color:#000000;">    {  </span></li><li><span style="color:#000000;">        cout&lt;&lt;d.at(i)&lt;&lt;<span style="color:#0000ff;">"\t"</span>;  </span></li><li><span style="color:#000000;">    }  </span></li><li><span style="color:#000000;">    cout&lt;&lt;endl;  </span></li><li><span style="color:#000000;">    d.push_front(5);  </span></li><li><span style="color:#000000;">    d.push_front(3);  </span></li><li><span style="color:#000000;">    d.push_front(1);  </span></li><li><span style="color:#000000;">  </span></li><li><span style="color:#000000;">    cout&lt;&lt;<span style="color:#0000ff;">"after push_front(5.3.1):"</span>&lt;&lt;endl;  </span></li><li><span style="color:#000000;">    <strong>for</strong>(<strong>int</strong> i = 0;i &lt; d.size();i++)  </span></li><li><span style="color:#000000;">    {  </span></li><li><span style="color:#000000;">        cout&lt;&lt;d.at(i)&lt;&lt;<span style="color:#0000ff;">"\t"</span>;  </span></li><li><span style="color:#000000;">    }  </span></li><li><span style="color:#000000;">    cout&lt;&lt;endl;  </span></li><li><span style="color:#000000;">    d.pop_front();  </span></li><li><span style="color:#000000;">    d.pop_front();  </span></li><li><span style="color:#000000;">    cout&lt;&lt;<span style="color:#0000ff;">"after pop_front() two times:"</span>&lt;&lt;endl;  </span></li><li><span style="color:#000000;">    <strong>for</strong>(<strong>int</strong> i = 0;i &lt; d.size();i++)  </span></li><li><span style="color:#000000;">    {  </span></li><li><span style="color:#000000;">        cout&lt;&lt;d.at(i)&lt;&lt;<span style="color:#0000ff;">"\t"</span>;  </span></li><li><span style="color:#000000;">    }  </span></li><li><span style="color:#000000;">    cout&lt;&lt;endl;  </span></li><li><span style="color:#000000;">    <strong>return</strong> 0;  </span></li><li><span style="color:#000000;">}  </span></li></ol> 
<p><br> 程序运行结果如下所示：</p> 
<p><img alt="" class="has" src="https://images2.imgbox.com/15/b1/Cooobmo1_o.png"></p> 
<p>2.deque与vector内存分配比较：</p> 
<p><strong>[cpp]</strong> <a class="ViewSource" href="https://blog.csdn.net/longshengguoji/article/details/8519812#">view plain</a> <a class="CopyToClipboard" href="https://blog.csdn.net/longshengguoji/article/details/8519812#">copy</a></p> 
<ol><li><span style="color:#000000;"><span style="color:#008200;">// deque.cpp : 定义控制台应用程序的入口点。</span>  </span></li><li><span style="color:#000000;"><span style="color:#008200;">//</span>  </span></li><li><span style="color:#000000;">  </span></li><li><span style="color:#000000;"><span style="color:#808080;">#include "stdafx.h"</span>  </span></li><li><span style="color:#000000;"><span style="color:#808080;">#include&lt;iostream&gt;</span>  </span></li><li><span style="color:#000000;"><span style="color:#808080;">#include&lt;deque&gt;</span>  </span></li><li><span style="color:#000000;"><span style="color:#808080;">#include&lt;vector&gt;</span>  </span></li><li><span style="color:#000000;">  </span></li><li><span style="color:#000000;"><strong>using</strong> <strong>namespace</strong> std;  </span></li><li><span style="color:#000000;"><strong>int</strong> _tmain(<strong>int</strong> argc, _TCHAR* argv[])  </span></li><li><span style="color:#000000;">{  </span></li><li><span style="color:#000000;">    vector&lt;<strong>int</strong>&gt;v(2);  </span></li><li><span style="color:#000000;">    v[0]=10;  </span></li><li><span style="color:#000000;">    <strong>int</strong> *p = &amp;v[0];  </span></li><li><span style="color:#000000;">    cout&lt;&lt;<span style="color:#0000ff;">"vector第一个元素迭代指针*p="</span>&lt;&lt;*p&lt;&lt;endl;  </span></li><li><span style="color:#000000;">    v.push_back(20);  </span></li><li><span style="color:#000000;">    cout&lt;&lt;<span style="color:#0000ff;">"vector容量变化后原vector第1个元素迭代指针*p="</span>&lt;&lt;*p&lt;&lt;endl;  </span></li><li><span style="color:#000000;">  </span></li><li><span style="color:#000000;">    deque&lt;<strong>int</strong>&gt; d(2);  </span></li><li><span style="color:#000000;">    d[0]=10;  </span></li><li><span style="color:#000000;">    <strong>int</strong> *q = &amp;d[0];  </span></li><li><span style="color:#000000;">    cout&lt;&lt;<span style="color:#0000ff;">"deque第一个元素迭代指针*q="</span>&lt;&lt;*q&lt;&lt;endl;  </span></li><li><span style="color:#000000;">    d.push_back(20);  </span></li><li><span style="color:#000000;">    cout&lt;&lt;<span style="color:#0000ff;">"deque容量变化后第一个元素迭代器指针*q="</span>&lt;&lt;*q&lt;&lt;endl;  </span></li><li><span style="color:#000000;">}  </span></li></ol> 
<p><br> 程序运行结果如下图所示</p> 
<p><img alt="" class="has" src="https://images2.imgbox.com/01/ff/CY7a6eWA_o.png"></p> 
<p>该段程序的功能是：deque、vector初始化后大小为2，第一个元素都为10，当通过push_back函数分别给两个容器增加一个元素后，从结果发现原先保持的指针元素值对vector容器前后发生了变化，而对deque容器前后没有发生变化。原因为，在建立vector容器时，一般来说伴随这建立空间-&gt;填充数据-&gt;重建更大空间-&gt;复制原空间数据-&gt;删除原空间-&gt;添加新数据，如此反复，保证vector始终是一块独立的连续内存空间；在建立deque容器时，一般便随着建立空间-&gt;建立数据-&gt;建立新空间-&gt;填充新数据，如此反复，没有原空间数据的复制和删除过程，是由多个连续的内存空间组成的。</p> 
<p> </p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/01117c447b1f2d7570c157129c8f0233/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">线性判别分析(LDA)和python实现（多分类问题）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/97edba398732644fdbb1d5026e7228a3/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">尚未备份数据库 &amp;quot;***&amp;quot; 的日志尾部。如果该日志包含您不希望丢失的工作，请使用 BACKUP LOG WITH NORECOVERY 备份该日志。请使用 RE</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>