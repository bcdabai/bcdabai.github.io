<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>void指针的用法 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="void指针的用法" />
<meta property="og:description" content="指针有两个属性:指向变量/对象的地址和长度 但是指针只存储地址,长度则取决于指针的类型 编译器根据指针的类型从指针指向的地址向后寻址 指针类型不同则寻址范围也不同,比如: int*从指定地址向后寻找4字节作为变量的存储单元 double*从指定地址向后寻找8字节作为变量的存储单元 1.void指针是一种特别的指针 void *vp //说它特别是因为它没有类型 //或者说这个类型不能判断出指向对象的长度 2.任何指针都可以赋值给void指针 type *p; vp=p; //不需转换 //只获得变量/对象地址而不获得大小 3.void指针赋值给其他类型的指针时都要进行转换 type *p=(type*)vp; //转换类型也就是获得指向变量/对象大小 转:http://icoding.spaces.live.com/blog/cns!209684E38D520BA6!130.entry 4.void指针不能复引用 *vp//错误 因为void指针只知道,指向变量/对象的起始地址 而不知道指向变量/对象的大小(占几个字节)所以无法正确引用 5.void指针不能参与指针运算,除非进行转换 (type*)vp&#43;&#43;; //vp==vp&#43;sizeof(type)
#include&lt;iostream&gt;
#include&lt;stdlib.h&gt;
#include&lt;string&gt;
using namespace std;
typedef struct tag_st { char id[10];
float fa[2];
}ST; //我在程序里面这样使用的 int main()
{
ST * P=(ST *)malloc(sizeof(ST));
strcpy(P-&gt;id,&#34;hello!&#34;);
P-&gt;fa[0]=1.1;
P-&gt;fa[1]=2.1;
ST * Q=(ST *)malloc(sizeof(ST));
strcpy(Q-&gt;id,&#34;world!&#34;);
Q-&gt;fa[0]=3.1;
Q-&gt;fa[1]=4.1;
void ** plink=(void **)P;
*((ST *)(plink)) = * Q; //plink要先强制转换一下,目的是为了让它先知道要覆盖的大小." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/6de9a151bab5b9ee1723830a28b9f39b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2014-03-06T11:31:54+08:00" />
<meta property="article:modified_time" content="2014-03-06T11:31:54+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">void指针的用法</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div class="Blog_wz1" style="word-wrap:break-word"> 
 <div> 
  <p><span style="font-size:14px">指针有两个属性:指向变量/对象的<span style="color:#ff0000; line-height:1.3em">地址</span>和<span style="color:#ff0000; line-height:1.3em">长度</span> </span><span style="font-size:14px"><br> 但是指针只存储地址,长度则取决于指针的类型 <br> 编译器根据指针的类型从指针指向的地址向后寻址 <br> 指针类型不同则寻址范围也不同,比如: <br> int*从指定地址向后寻找4字节作为变量的存储单元 <br> double*从指定地址向后寻找8字节作为变量的存储单元 <br> <br> 1.void指针是一种特别的指针 <br>    void *vp <br>    //说它特别是因为它没有类型 <br>    //或者说这个类型不能判断出指向对象的长度 <br> <br> 2.任何指针都可以赋值给void指针 <br>    type *p; <br>    vp=p; <br>    //不需转换 <br>    //只获得变量/对象地址而不获得大小 <br> <br> 3.void指针赋值给其他类型的指针时都要进行转换 <br>    type *p=(type*)vp; <br>    //转换类型也就是获得指向变量/对象大小 <br> 转:http://icoding.spaces.live.com/blog/cns!209684E38D520BA6!130.entry <br> <br> 4.void指针不能复引用 <br>    *vp//错误 <br>    因为void指针只知道,指向变量/对象的起始地址 <br>    而不知道指向变量/对象的大小(占几个字节)所以无法正确引用 <br> <br> 5.void指针不能参与指针运算,除非进行转换 <br>    (type*)vp++; <br>    //vp==vp+sizeof(type)<br> <br> <br> <br> #include&lt;iostream&gt;<br> #include&lt;stdlib.h&gt;<br> #include&lt;string&gt;<br> using namespace std;<br> typedef struct tag_st <br> { <br> char id[10];<br> float fa[2];<br> }ST; <br> //我在程序里面这样使用的 <br> int main()<br> {<!-- --><br> ST * P=(ST *)malloc(sizeof(ST));<br> strcpy(P-&gt;id,"hello!");<br> P-&gt;fa[0]=1.1;<br> P-&gt;fa[1]=2.1;<br> <br> ST * Q=(ST *)malloc(sizeof(ST));<br> strcpy(Q-&gt;id,"world!");<br> Q-&gt;fa[0]=3.1;<br> Q-&gt;fa[1]=4.1;<br> void ** plink=(void **)P;<br> *((ST *)(plink)) = * Q; //<span style="color:#ff0000; line-height:1.3em">plink要先强制转换一下,目的是为了让它先知道要覆盖的大小.</span><br>                          //<span style="color:#ff0000; line-height:1.3em">P的内容竟然给Q的内容覆盖掉了.</span><br> cout&lt;&lt;P-&gt;id&lt;&lt;" "&lt;&lt;P-&gt;fa[0]&lt;&lt;" "&lt;&lt;P-&gt;fa[1]&lt;&lt;endl;<br> return 0;<br> } </span></p> 
 </div> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e7d41d66cd709eeac104d4f0c942f2a4/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">c语言运算符优先级</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/cc671e4f839566aa641f205054c09879/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">使用RAR解压Jar文件</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>