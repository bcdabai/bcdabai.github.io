<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>redis - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="redis" />
<meta property="og:description" content="Redis
概念：
redis是一个开源免费的，遵守BSD协议，是一个高性能的KV数据库
内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。
非关型数据库
支持5种数据类型
string（字符串）
set:添加一条String数据
get:获取一条String数据
mset:添加多条String数据
mget:获取多条String数据
hash（哈希）
hset :添加一条hash类型数据
hget :获取一条hash类型数据
hmset :添加多条hash类型数据
hmget :获取多条hash类型数据
hgetAll :获取指定所有hash类型数据
hdel :删除指定hash类型数据(一条或多条)
list（列表）
lpush :左添加(头)list类型数据
rpush :右添加(尾)类型数据
lrange : 获取list类型数据start起始下标 end结束下标 包含关系
llen :获取条数
lrem :删除列表中几个指定list类型数据
set集合
sadd:添加set类型数据
smembers :获取set类型数据
scard :获取条数
srem :删除数据
sorted set（有序集合）
sorted set是通过分数值来进行排序的，分数值越大，越靠后。
zadd :添加sorted set类型数据
zadd需要将Float或者Double类型分数值参数，放置在值参数之前
zrange :获取sorted set类型数据
zcard :获取条数
zrem :删除数据
优点
容易理解
使用方便，通用的sql语言
易于维护，丰富的完整性
缺点
磁盘I/O是并发的瓶颈
海量数据查询效率低
横向扩展困难" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/86a1b907d54bf7010394bf316e183e67/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-09-09T19:44:45+08:00" />
<meta property="article:modified_time" content="2021-09-09T19:44:45+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">redis</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>Redis<br>   <strong>  概念：</strong><br>         redis是一个开源免费的，遵守BSD协议，是一个高性能的KV数据库<br>         内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。<br>         非关型数据库</p> 
<p><br>    <strong> 支持5种数据类型</strong><br>      <strong>   string（字符串）</strong><br>             set:添加一条String数据<br>             get:获取一条String数据<br>             mset:添加多条String数据<br>             mget:获取多条String数据<br>        <strong> hash（哈希）</strong><br>             hset :添加一条hash类型数据<br>             hget :获取一条hash类型数据<br>             hmset :添加多条hash类型数据<br>             hmget :获取多条hash类型数据<br>             hgetAll :获取指定所有hash类型数据<br>             hdel :删除指定hash类型数据(一条或多条)<br>        <strong> list（列表）</strong><br>             lpush :左添加(头)list类型数据<br>             rpush :右添加(尾)类型数据<br>             lrange : 获取list类型数据start起始下标 end结束下标 包含关系<br>             llen :获取条数<br>             lrem :删除列表中几个指定list类型数据<br>        <strong> set集合</strong><br>             sadd:添加set类型数据<br>             smembers :获取set类型数据<br>             scard :获取条数<br>             srem :删除数据<br>        <strong> sorted set（有序集合）</strong><br>             sorted set是通过分数值来进行排序的，分数值越大，越靠后。<br>             zadd :添加sorted set类型数据<br>                 zadd需要将Float或者Double类型分数值参数，放置在值参数之前<br>             zrange :获取sorted set类型数据<br>             zcard :获取条数<br>             zrem :删除数据</p> 
<p><br>     优点<br>         容易理解<br>         使用方便，通用的sql语言<br>         易于维护，丰富的完整性<br>     缺点<br>         磁盘I/O是并发的瓶颈<br>         海量数据查询效率低<br>         横向扩展困难<br>         多表的关联查询以及复杂的数据分析类型的复杂sql查询</p> 
<p><br>     <strong>使用redis好处</strong><br>         1.速度快，因为数据存在内存中，类似于hashmap<br>         2.支持丰富数据类型<br>         3.支持事务，操作都是原子性，所谓的原子性就是对数据的更改要么全部执行，要么全部不执行<br>         4。丰富的特征：可用于缓存，消息，按key设置过期时间，过期后会自动删除</p> 
<p><br>   <strong>  redis持久化机制</strong><br>         <strong>RDB（快照）</strong><br>             是指用数据集快照的方式半持久化模式)记录 redis 数据库的所有键值对,在某个时间点将数据写入一个临时文件，持久化结束后，用这个临时文件替换上次持久化的文件，达到数据恢复<br>             优点<br>                 1.只有一个文件dump.rdb,方便持久化<br>                 2.容灾性好，一个文件可以保存到安全的磁盘<br>                 3.性能最大化，fork子进程来完成写操作，让主进程继续处理命令，所以是IO最大化<br>             缺点<br>                 数据安全性底<br>                     RDB 是间隔一段时间进行持久化，如果持久化之间 redis 发生故障，会发生数据丢失。所以这种方式更适合数据要求不严谨的时候</p> 
<p><br>      <strong>   AOP（日志）</strong><br>             是指所有的命令行记录以 redis 命令请求协议的格式完全持久化存储)保存为 aof 文件。<br>             优点<br>                 数据安全，aof 持久化可以配置 appendfsync 属性，有 always，每进行一次命令操作就记录到 aof 文件中一次。<br>                 通过 append 模式写文件，即使中途服务器宕机，可以通过 redis-check-aof工具解决数据一致性问题。<br>                 AOF 机制的 rewrite 模式。AOF 文件没被 rewrite 之前（文件过大时会对命令进行合并重写），可以删除其中的某些命令（比如误操作的 flushall）)<br>             缺点<br>                 1.AOP文件比RDB文件大，且恢复速度慢<br>                 2.数据集大的时候，比RDB启动效率底</p> 
<p><br>   <strong>  怎么理解 Redis 事务？</strong><br>         （1）事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。<br>         （2）事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。</p> 
<p><br>    <strong> Key的过期淘汰机制</strong><br>         1.定期删除<br>         2.惰性删除<br>         3.内存淘汰机制<br>             内存快要满了的时候，对一下快要过期的数据提前进行删除</p> 
<p><br>  <strong>   缓存击穿</strong><br>         有人拿抢扫射，但是被扫的人穿了防弹衣，但是防弹衣有一个洞，那个人就一直往洞里扫<br>         缓存击穿是一个热点的Key，有大并发集中对其进行访问，突然间这个Key失效了，导致大并发全部打在数据库上，导致数据库压力剧增。. 这种现象就叫做缓存击穿<br>         高并发的情况下，某个热门key突然过期，导致大量请求在Redis未找到缓<br>         存数据，进而全部去访问DB请求数据，引起DB压力瞬间增大<br>         解决方案<br>             1.redis中的数据不设置过期时间<br>                 可以把不存在的key也设置缓存，并设置过期时间<br>             2.加一个互斥锁</p> 
<p><br>   <strong>  缓存穿透</strong><br>         查询缓存和DB中都不存在的数据<br>         我们使用Redis大部分情况都是通过Key查询对应的值，假如发送的请求传进来的key是不存在Redis中的，那么就查不到缓存，查不到缓存就会去数据库查询。假如有大量这样的请求，这些请求像“穿透”了缓存一样直接打在数据库上，这种现象就叫做缓存穿透。<br>         解决方案<br>             1.互斥锁<br>             2.异步更新<br>             3.提供一个能迅速判断请求是否有效的拦截机制</p> 
<p><br>   <strong>  缓存雪崩</strong><br>         当某一个时刻出现大规模的缓存失效的情况，那么就会导致大量的请求直接打在数据库上面，导致数据库压力巨大，如果在高并发的情况下，可能瞬间就会导致数据库宕机。这时候如果运维马上又重启数据库，马上又会有新的流量把数据库打死<br>         解决方案<br>             1.在原有的失效时间上加上一个随机值<br>                 这样就避免了艺文采用相同的过期时间导致雪崩<br>             2.使用熔断机制<br>             3.提高数据库的容灾能力，可以使用分库分表，读写分离的车略<br>             4.为了防止Redis宕机导致缓存雪崩的问题，可以搭建Redis集群，提高Redis的容灾性。<br>             5.双缓存<br>             6.互斥锁<br>             7.设置热点数据永不过期</p> 
<p></p> 
<p></p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ee90f579251d2c2bccd52257f135c225/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">vue vite特点与优缺点</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/488875dab933e98c54648701672227b7/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">在浏览器地址栏输入地址按下回车后...</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>