<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>vue生命周期、vue请求、动画 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="vue生命周期、vue请求、动画" />
<meta property="og:description" content="一、生命周期 1.定义：从Vue实例创建、运行、到销毁期间，总是伴随着各种各样的事件，这些事件，统称为生命周期！
2.vue生命周期钩子函数：每个 Vue 实例在被创建时都要经过一系列的初始化过程——例如，需要设置数据监听、编译模板、将实例挂载到 DOM 并在数据变化时更新 DOM 等。同时在这个过程中也会运行一些叫做生命周期钩子的函数，这给了用户在不同阶段添加自己的代码的机会。
生命周期函数=生命周期事件=生命周期钩子
3、vue生命周期
（1）创建前：beforeCreate（）{}
初始化尚未完成，data数据、methods方法都未挂载在vue实例上（一般用于页面重定向）
（2）创建后：created（）{}
第一个能够操作data数据的生命周期（一般用于接口请求&#43;数据初始化）
（3）挂载前：beforeMount（）{}
虚拟DOM挂载前，此时页面元素尚未更新
（4）挂载后：mounted（）{}
虚拟dom元素挂载后，如果需要操作dom，可以在此生命周期执行
（5）更新前：beforeUpdate（）{}
（6）更新后：updated（）{}
beforeUpdate和updated在页面初次渲染时并不执行，在更新时执行，故可执行0次或多次
（7）销毁前：beforeDestroy（）{}
一般用于清除计时器
（8）销毁后：destroyed（）{}
附：debugger 加入断点
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&#34;UTF-8&#34;&gt; &lt;meta name=&#34;viewport&#34; content=&#34;width=device-width, initial-scale=1.0&#34;&gt; &lt;meta http-equiv=&#34;X-UA-Compatible&#34; content=&#34;ie=edge&#34;&gt; &lt;title&gt;&lt;/title&gt; &lt;script src=&#34;../lib/vue-2.4.0.js&#34;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&#39;app&#39;&gt; &lt;div&gt; {{msg}}&lt;/div&gt; &lt;input type=&#34;text&#34; v-model=&#34;msg&#34;&gt; &lt;/div&gt; &lt;script&gt; const vm = new Vue({ el: &#39;#app&#39;, data: { msg:&#39;hello word!&#39; }, methods: { }, // 初始化尚未完成，data数据，metheds方法都未挂在在vue实例上 // 一般用于页面重定向 beforeCreate(){ console." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/7a9770ac6a46b3a4b0f620eb8df839f5/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-09-23T09:34:04+08:00" />
<meta property="article:modified_time" content="2022-09-23T09:34:04+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">vue生命周期、vue请求、动画</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2 id="%E4%B8%80%E3%80%81%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">一、生命周期</h2> 
<p><strong>1.定义</strong>：从Vue实例创建、运行、到销毁期间，总是伴随着各种各样的事件，这些事件，统称为<u>生命周期</u>！<br><strong>2.vue生命周期钩子函数</strong>：每个 Vue 实例在被创建时都要经过一系列的初始化过程——例如，需要设置数据监听、编译模板、将实例挂载到 DOM 并在数据变化时更新 DOM 等。同时在这个过程中也会运行一些叫做生命周期钩子的函数，这给了用户在不同阶段添加自己的代码的机会。</p> 
<p><span style="color:#956fe7;"><strong>生命周期函数=生命周期事件=生命周期钩子</strong></span></p> 
<p><strong>3、vue生命周期</strong><br> （1）创建前：beforeCreate（）{}<br>         初始化尚未完成，data数据、methods方法都未挂载在vue实例上（一般用于页面重定向）<br> （2）创建后：created（）{}<br>         第一个能够操作data数据的生命周期（一般用于接口请求+数据初始化）<br> （3）挂载前：beforeMount（）{}<br>         虚拟DOM挂载前，此时页面元素尚未更新<br> （4）挂载后：mounted（）{}</p> 
<p>        虚拟dom元素挂载后，如果需要操作dom，可以在此生命周期执行</p> 
<p>（5）更新前：beforeUpdate（）{}</p> 
<p>（6）更新后：updated（）{}<br><strong><span style="color:#fe2c24;">        beforeUpdate和updated在页面初次渲染时并不执行，在更新时执行，故可执行0次或多次</span></strong><br> （7）销毁前：beforeDestroy（）{}<br>         一般用于清除计时器</p> 
<p>（8）销毁后：destroyed（）{}<br>         附：debugger 加入断点</p> 
<blockquote> 
 <pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;meta charset="UTF-8"&gt;
  &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
  &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt;
  &lt;title&gt;&lt;/title&gt;
  &lt;script src="../lib/vue-2.4.0.js"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;div id='app'&gt;
    &lt;div&gt; {<!-- -->{msg}}&lt;/div&gt;
    &lt;input type="text" v-model="msg"&gt;
  &lt;/div&gt;


  &lt;script&gt;
  const vm = new Vue({
    el: '#app',
    data: {
      msg:'hello word!'
    },
    methods: {
    },
    // 初始化尚未完成，data数据，metheds方法都未挂在在vue实例上
    // 一般用于页面重定向
    beforeCreate(){
      console.log(1);
    },
    // 第一个能操作data数据的生命周期，
    // 一般用于接口请求+数据初始化
    created(){
      console.log(2);
    },
    // 虚拟dom挂载前，此时页面元素尚未更新
    beforeMount(){
      console.log(3);
    },
    // dom元素挂载后，如果需要操作dom，可以在此生命周期执行
    mounted(){
      console.log(4);
    },
    // 在页面初次渲染时并不执行，在更新时执行，故可执行0次或多次
    beforeUpdate(){
      console.log(5);
    },
    updated(){
      console.log(6);
    },
  })
  &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre> 
 <p></p> 
</blockquote> 
<h2>二、vue-resource的使用</h2> 
<p>直接在页面中，<u>通过script标签，引入vue-resource的脚本文件</u>；<br><strong><span style="color:#fe2c24;">注意：引用的先后顺序是 - 先引用Vue的脚本文件，再引用vue-resource的脚本文件</span></strong></p> 
<p>1.get请求<br> this.$http.get('http://yapi.shangyuninfo.com/mock/36/web02/category').then(res =&gt; {<!-- --><br>   console.log(res.body);<br> })</p> 
<blockquote> 
 <pre><code class="language-javascript">//get请求
      this.$http.get(this.baseurl+'/weChat/applet/course/banner/list?number=4').then(res=&gt;{
        console.log(res);
        this.imgSrc = res.data.data[0].imgUrlPc
        this.imgList = res.data.data
      })</code></pre> 
</blockquote> 
<p>2.post请求<br> this.$http.post(url, {categoryId: 'zs' }, { emulateJSON: true }).then(res =&gt; {<!-- --><br>   console.log(res.body);<br> });</p> 
<blockquote> 
 <pre><code class="language-javascript">//post请求
      this.$http.post(this.baseurl+"/weChat/applet/course/list/type",{type:'free',pageSize:10,pageNum:1},{ emulateJSON: true }).then(res=&gt;{
        console.log(res);
        this.courseList = res.data.rows
      })</code></pre> 
 <p></p> 
</blockquote> 
<h2>三、axios的使用</h2> 
<p><strong>Vue.js 2.0 版本推荐使用 axios 来完成 ajax 请求。</strong><br><u>Axios 是一个基于 Promise 的 HTTP 库，可以用在浏览器和 node.js 中。</u><br> 安装方法：<br> （1）使用 cdn:<br> &lt;script src="https://cdn.staticfile.org/axios/0.18.0/axios.min.js"&gt;&lt;/script&gt;<br> （2）使用 npm:<br> npm install axios</p> 
<h4>1.get请求</h4> 
<blockquote> 
 <pre><code class="language-javascript">//axios的get请求
      axios.get("http://1.117.81.216:8086/weChat/applet/course/banner/list?number=4").then(res=&gt;{
        console.log(res);
        }
      )</code></pre> 
 <p></p> 
</blockquote> 
<h4>2.post请求</h4> 
<p>（1）如果数据是form-url类型<br> let formurl = new URLSearchParams()<br> formurl .append('key','value')<br> formurl .append('key','value')...</p> 
<blockquote> 
 <pre><code class="language-javascript">let formurl = new URLSearchParams()
formurl .append('key','value')
formurl .append('key','value')
axios.post(this.baseurl+'/weChat/applet/course/list/type',formurl)</code></pre> 
 <p></p> 
</blockquote> 
<p>（2）如果数据是form-data类型<br> let formdata = new FromData()<br> formdata .append('key','value')<br> formdata .append('key','value')...</p> 
<blockquote> 
 <pre><code class="language-javascript">let formdata = new FromData()
formdata .append('key','value')
formdata .append('key','value')
axios.post(this.baseurl+'/weChat/applet/course/list/type',formdata )</code></pre> 
 <p></p> 
</blockquote> 
<p>（3）如果数据是JSON类型</p> 
<blockquote> 
 <pre><code class="language-javascript">axios.post(this.baseurl+"/weChat/applet/subject/list",{enable:1}).then(res=&gt;{
    console.log(res);
})</code></pre> 
 <p></p> 
</blockquote> 
<blockquote> 
 <p>当swiper中的轮播图初始化与请求同时进行时：应把轮播图的渲染写到请求成功后的执行语句中，且要利用<strong><span style="color:#fe2c24;">$nextTick</span></strong>方法（在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。）</p> 
 <pre><code class="language-javascript">// 在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。
            this.$nextTick(() =&gt; {
              var mySwiper = new Swiper('.swiper-container', {
                direction: 'horizontal', // 垂直切换选项
                loop: true, // 循环模式选项

                // 如果需要分页器
                pagination: {
                  el: '.swiper-pagination',
                },

                // 如果需要前进后退按钮
                navigation: {
                  nextEl: '.swiper-button-next',
                  prevEl: '.swiper-button-prev',
                },

                // 如果需要滚动条
                scrollbar: {
                  el: '.swiper-scrollbar',
                },
              })
            })</code></pre> 
 <p></p> 
</blockquote> 
<h2>四、vue中的动画</h2> 
<h4><strong>（一）使用<span style="color:#fe2c24;">transition</span>标签</strong></h4> 
<blockquote> 
 <pre><code class="language-html">  &lt;div id='app'&gt;
    &lt;button @click="flag = !flag"&gt;点击&lt;/button&gt;
    &lt;transition&gt;
      &lt;div class="box" v-show="flag"&gt; {<!-- -->{msg}}&lt;/div&gt;
    &lt;/transition&gt;
    &lt;transition name="animateA"&gt;
      &lt;div class="box" v-show="flag"&gt; {<!-- -->{msg}}&lt;/div&gt;
  &lt;/transition&gt;
  &lt;/div&gt;</code></pre> 
 <p></p> 
</blockquote> 
<p>（1）入场<br> v-enter<br> v-enter-to<br> v-enter-active</p> 
<p>（2）退场<br> v-leave<br> v-leave-to<br> v-leave-active<br> 以上六项写在style标签（css）中</p> 
<blockquote> 
 <pre><code class="language-html">&lt;style&gt;
    .v-enter {
      transform: translateX(-300px);
    }
    .v-enter-to {
      transform: translateX(0px);
    }
    .v-enter-active {
      transition: all 3s;
    }
    .v-leave {
      transform: translateX(0px);
    }
    .v-leave-to {
      transform: translateX(300px);
    }
    .v-leave-active {
      transition: all 3s;
    }
  &lt;/style&gt;</code></pre> 
 <p>        </p> 
</blockquote> 
<p> 若要控制不同的<strong><span style="color:#fe2c24;">transition标签</span></strong><span style="color:#0d0016;">只需要给对应的加上name属性，再将css中原来v的位置替换成所写的name的值即可</span></p> 
<blockquote> 
 <pre><code class="language-html">  &lt;style&gt;
    .animateA-enter {
      transform: translateX(300px);
    }
    .animateA-enter-to {
      transform: translateX(0px);
    }
    .animateA-enter-active {
      transition: all 3s;
    }
    .animateA-leave {
      transform: translateX(0px);
    }
    .animateA-leave-to {
      transform: translateX(-300px);
    }
    .animateA-leave-active {
      transition: all 3s;
    }
  &lt;/style&gt;</code></pre> 
 <p></p> 
</blockquote> 
<h4>（二）使用第三方动画库</h4> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>1.导入动画类库：</strong></strong></p> 
<p>&lt;link rel="stylesheet" type="text/css" href="./lib/animate.css"&gt;</p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>2.定义 transition 及属性：</strong></strong></p> 
<p>&lt;transition</p> 
<p>enter-active-class="fadeInRight"<br>   leave-active-class="fadeOutRight"<br>   :duration="{ enter: 500, leave: 800 }"&gt;<br> &lt;div class="animated" v-show="isshow"&gt;动画哦&lt;/div&gt;<br> &lt;/transition&gt;</p> 
<h4>（三）使用动画钩子函数</h4> 
<p><strong>1.</strong><strong>定义 transition 组件以及三个钩子函数：</strong></p> 
<blockquote> 
 <pre><code class="language-html">&lt;div id="app"&gt;
  &lt;input type="button" value="切换动画" @click="isshow = !isshow"&gt;
  &lt;transition
  @before-enter="beforeEnter"
  @enter="enter"
  @after-enter="afterEnter"&gt;
    &lt;div v-if="isshow" class="show"&gt;OK&lt;/div&gt;
  &lt;/transition&gt;
&lt;/div&gt;</code></pre> 
 <p></p> 
</blockquote> 
<p><strong><strong>2.定义三个 methods 钩子方法：</strong></strong></p> 
<blockquote> 
 <pre><code class="language-javascript">methods: {
      beforeEnter(el) { // 动画进入之前的回调
        el.style.transform = 'translateX(500px)';
      },
      enter(el, done) { // 动画进入完成时候的回调
        el.offsetWidth;
        el.style.transform = 'translateX(0px)';
        done();
      },
      afterEnter(el) { // 动画进入完成之后的回调
        this.isshow = !this.isshow;
      }
}</code></pre> 
 <p></p> 
</blockquote> 
<p><strong> 3.<strong>定义动画过渡时长和样式：</strong></strong></p> 
<blockquote> 
 <pre><code class="language-html">.show{
transition: all 0.4s ease;
}</code></pre> 
 <p></p> 
</blockquote> 
<h4> （四） v-for的列表过渡</h4> 
<p><span style="color:#fe2c24;"><strong>列表使用&lt;transition-group&gt;标签</strong></span></p> 
<p><span style="color:#fe2c24;"><strong>tag属性 </strong></span><strong><span style="color:#0d0016;">规定transition标签内渲染后默认添加的列表外围的标签</span></strong></p> 
<p><strong> 1</strong>.<strong><strong>定义过渡样式：</strong></strong></p> 
<blockquote> 
 <pre><code class="language-html">&lt;style&gt;
  .list-enter,
  .list-leave-to {
    opacity: 0;
    transform: translateY(10px);
  }
​
  .list-enter-active,
  .list-leave-active {
    transition: all 0.3s ease;
  }
&lt;/style&gt;</code></pre> 
 <p></p> 
</blockquote> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>2.定义DOM结构，其中，需要使用 transition-group 组件把v-for循环的列表包裹起来：</strong></strong></p> 
<blockquote> 
 <pre><code class="language-html">&lt;div id="app"&gt;
  &lt;input type="text" v-model="txt" @keyup.enter="add"&gt;
  &lt;transition-group tag="ul" name="list"&gt;
    &lt;li v-for="(item, i) in list" :key="i"&gt;{<!-- -->{item}}&lt;/li&gt;
  &lt;/transition-group&gt;
&lt;/div&gt;</code></pre> 
 <p></p> 
</blockquote> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>3.定义 VM中的结构：</strong></strong></p> 
<blockquote> 
 <pre><code class="language-javascript">  // 创建 Vue 实例，得到 ViewModel
  var vm = new Vue({
    el: '#app',
    data: {
      txt: '',
      list: [1, 2, 3, 4]
    },
    methods: {
      add() {
        this.list.push(this.txt);
        this.txt = '';
      }
    }
  });</code></pre> 
 <p></p> 
</blockquote> 
<h4>（五）列表的排序过渡</h4> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>v-move 和 v-leave-active 结合使用，能够让列表的过渡更加平缓柔和：</strong></strong></p> 
<blockquote> 
 <pre><code class="language-html">.v-move{
transition: all 0.8s ease;
}
.v-leave-active{
position: absolute;
}</code></pre> 
 <p></p> 
</blockquote> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5487f8973e126c87706c43522eec1466/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Kali2022.3 vulhub靶场安装过程记录</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/748ed4af95fb4703458cdf2853da2251/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">23.STM32 I2C实验</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>