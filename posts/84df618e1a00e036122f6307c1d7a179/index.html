<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C 语言实现面向对象编程 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C 语言实现面向对象编程" />
<meta property="og:description" content="C 语言实现面向对象编程 1、引言 面向对象编程（OOP）并不是一种特定的语言或者工具，它只是一种设计方法、设计思想。它表现出来的三个最基本的特性就是封装、继承与多态。很多面向对象的编程语言已经包含这三个特性了，例如 Smalltalk、C&#43;&#43;、Java。但是你也可以用几乎所有的编程语言来实现面向对象编程，例如 ANSI-C。要记住，面向对象是一种思想，一种方法，不要太拘泥于编程语言。
2、封装 封装就是把数据和方法打包到一个类里面。其实C语言编程者应该都已经接触过了，C 标准库 中的 fopen(), fclose(), fread(), fwrite()等函数的操作对象就是 FILE。数据内容就是 FILE，数据的读写操作就是 fread()、fwrite()，fopen() 类比于构造函数，fclose() 就是析构函数。这个看起来似乎很好理解，那下面我们实现一下基本的封装特性。
#ifndef SHAPE_H #define SHAPE_H #include &lt;stdint.h&gt; // Shape 的属性 typedef struct { int16_t x; int16_t y; } Shape; // Shape 的操作函数，接口函数 void Shape_ctor(Shape * const me, int16_t x, int16_t y); void Shape_moveBy(Shape * const me, int16_t dx, int16_t dy); int16_t Shape_getX(Shape const * const me); int16_t Shape_getY(Shape const * const me); #endif /* SHAPE_H */ 这是 Shape 类的声明，非常简单，很好理解。一般会把声明放到头文件里面 “Shape." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/84df618e1a00e036122f6307c1d7a179/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-08-14T18:36:38+08:00" />
<meta property="article:modified_time" content="2018-08-14T18:36:38+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C 语言实现面向对象编程</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2 id="c-语言实现面向对象编程">C 语言实现面向对象编程</h2> 
<hr> 
<h3 id="1引言">1、引言</h3> 
<p>面向对象编程（OOP）并不是一种特定的语言或者工具，它只是一种设计方法、设计思想。它表现出来的三个最基本的特性就是封装、继承与多态。很多面向对象的编程语言已经包含这三个特性了，例如 Smalltalk、C++、Java。但是你也可以用几乎所有的编程语言来实现面向对象编程，例如 ANSI-C。要记住，面向对象是一种思想，一种方法，不要太拘泥于编程语言。</p> 
<h3 id="2封装">2、封装</h3> 
<p>封装就是把数据和方法打包到一个类里面。其实C语言编程者应该都已经接触过了，C 标准库 <br> 中的 fopen(), fclose(), fread(), fwrite()等函数的操作对象就是 FILE。数据内容就是 FILE，数据的读写操作就是 fread()、fwrite()，fopen() 类比于构造函数，fclose() 就是析构函数。这个看起来似乎很好理解，那下面我们实现一下基本的封装特性。</p> 
<pre class="prettyprint"><code class=" hljs vala"><span class="hljs-preprocessor">#ifndef SHAPE_H</span>
<span class="hljs-preprocessor">#define SHAPE_H</span>

<span class="hljs-preprocessor">#include &lt;stdint.h&gt;</span>

<span class="hljs-comment">// Shape 的属性</span>
typedef <span class="hljs-keyword">struct</span> {
    int16_t x; 
    int16_t y; 
} Shape;

<span class="hljs-comment">// Shape 的操作函数，接口函数</span>
<span class="hljs-keyword">void</span> Shape_ctor(Shape * <span class="hljs-keyword">const</span> me, int16_t x, int16_t y);
<span class="hljs-keyword">void</span> Shape_moveBy(Shape * <span class="hljs-keyword">const</span> me, int16_t dx, int16_t dy);
int16_t Shape_getX(Shape <span class="hljs-keyword">const</span> * <span class="hljs-keyword">const</span> me);
int16_t Shape_getY(Shape <span class="hljs-keyword">const</span> * <span class="hljs-keyword">const</span> me);

<span class="hljs-preprocessor">#endif /* SHAPE_H */</span></code></pre> 
<p>这是 Shape 类的声明，非常简单，很好理解。一般会把声明放到头文件里面 “Shape.h”。</p> 
<p>来看下 Shape 类相关的定义，当然是在 “Shape.c” 里面。</p> 
<pre class="prettyprint"><code class=" hljs vala"><span class="hljs-preprocessor">#include "shape.h"</span>

<span class="hljs-comment">// 构造函数</span>
<span class="hljs-keyword">void</span> Shape_ctor(Shape * <span class="hljs-keyword">const</span> me, int16_t x, int16_t y)
{
    me-&gt;x = x;
    me-&gt;y = y;
}

<span class="hljs-keyword">void</span> Shape_moveBy(Shape * <span class="hljs-keyword">const</span> me, int16_t dx, int16_t dy) 
{
    me-&gt;x += dx;
    me-&gt;y += dy;
}

<span class="hljs-comment">// 获取属性值函数</span>
int16_t Shape_getX(Shape <span class="hljs-keyword">const</span> * <span class="hljs-keyword">const</span> me) 
{
    <span class="hljs-keyword">return</span> me-&gt;x;
}
int16_t Shape_getY(Shape <span class="hljs-keyword">const</span> * <span class="hljs-keyword">const</span> me) 
{
    <span class="hljs-keyword">return</span> me-&gt;y;
}</code></pre> 
<p>再看下 main.c</p> 
<pre class="prettyprint"><code class=" hljs scss"><span class="hljs-id">#include</span> "shape<span class="hljs-class">.h</span>"  <span class="hljs-comment">/* Shape class interface */</span>
<span class="hljs-id">#include</span> &lt;stdio<span class="hljs-class">.h</span>&gt;  <span class="hljs-comment">/* for printf() */</span>

int <span class="hljs-function">main()</span> 
{
    Shape s1, s2; <span class="hljs-comment">/* multiple instances of Shape */</span>

    <span class="hljs-function">Shape_ctor(&amp;s1, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>)</span>;
    <span class="hljs-function">Shape_ctor(&amp;s2, -<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)</span>;

    <span class="hljs-function">printf(<span class="hljs-string">"Shape s1(x=%d,y=%d)\n"</span>, <span class="hljs-function">Shape_getX(&amp;s1)</span>, <span class="hljs-function">Shape_getY(&amp;s1)</span>)</span>;
    <span class="hljs-function">printf(<span class="hljs-string">"Shape s2(x=%d,y=%d)\n"</span>, <span class="hljs-function">Shape_getX(&amp;s2)</span>, <span class="hljs-function">Shape_getY(&amp;s2)</span>)</span>;

    <span class="hljs-function">Shape_moveBy(&amp;s1, <span class="hljs-number">2</span>, -<span class="hljs-number">4</span>)</span>;
    <span class="hljs-function">Shape_moveBy(&amp;s2, <span class="hljs-number">1</span>, -<span class="hljs-number">2</span>)</span>;

    <span class="hljs-function">printf(<span class="hljs-string">"Shape s1(x=%d,y=%d)\n"</span>, <span class="hljs-function">Shape_getX(&amp;s1)</span>, <span class="hljs-function">Shape_getY(&amp;s1)</span>)</span>;
    <span class="hljs-function">printf(<span class="hljs-string">"Shape s2(x=%d,y=%d)\n"</span>, <span class="hljs-function">Shape_getX(&amp;s2)</span>, <span class="hljs-function">Shape_getY(&amp;s2)</span>)</span>;

    return 0;
}</code></pre> 
<p>编译之后，看看执行结果：</p> 
<pre class="prettyprint"><code class=" hljs scss">Shape <span class="hljs-function">s1(x=<span class="hljs-number">0</span>,y=<span class="hljs-number">1</span>)</span>
Shape <span class="hljs-function">s2(x=-<span class="hljs-number">1</span>,y=<span class="hljs-number">2</span>)</span>
Shape <span class="hljs-function">s1(x=<span class="hljs-number">2</span>,y=-<span class="hljs-number">3</span>)</span>
Shape <span class="hljs-function">s2(x=<span class="hljs-number">0</span>,y=<span class="hljs-number">0</span>)</span></code></pre> 
<p>整个例子，非常简单，非常好理解。以后写代码时候，要多去想想标准库的文件IO操作，这样也有意识的去培养面向对象编程的思维。</p> 
<h3 id="3继承">3、继承</h3> 
<p>继承就是基于现有的一个类去定义一个新类，这样有助于重用代码，更好的组织代码。在 C 语言里面，去实现单继承也非常简单，只要把基类放到继承类的第一个数据成员的位置就行了。</p> 
<p>例如，我们现在要创建一个 Rectangle 类，我们只要继承 Shape 类已经存在的属性和操作，再添加不同于 Shape 的属性和操作到 Rectangle 中。</p> 
<p>下面是 Rectangle 的声明与定义：</p> 
<pre class="prettyprint"><code class=" hljs vala"><span class="hljs-preprocessor">#ifndef RECT_H</span>
<span class="hljs-preprocessor">#define RECT_H</span>

<span class="hljs-preprocessor">#include "shape.h" // 基类接口</span>

<span class="hljs-comment">// 矩形的属性</span>
typedef <span class="hljs-keyword">struct</span> {
    Shape super; <span class="hljs-comment">// 继承 Shape</span>

    <span class="hljs-comment">// 自己的属性</span>
    uint16_t width;
    uint16_t height;
} Rectangle;

<span class="hljs-comment">// 构造函数</span>
<span class="hljs-keyword">void</span> Rectangle_ctor(Rectangle * <span class="hljs-keyword">const</span> me, int16_t x, int16_t y,
                    uint16_t width, uint16_t height);

<span class="hljs-preprocessor">#endif /* RECT_H */</span></code></pre> 
<pre class="prettyprint"><code class=" hljs lasso"><span class="hljs-variable">#include</span> <span class="hljs-string">"rect.h"</span>

<span class="hljs-comment">// 构造函数</span>
<span class="hljs-literal">void</span> Rectangle_ctor(Rectangle <span class="hljs-subst">*</span> const me, int16_t x, int16_t y,
                    uint16_t width, uint16_t height)
{
    <span class="hljs-comment">/* first call superclass’ ctor */</span>
    Shape_ctor(<span class="hljs-subst">&amp;</span>me<span class="hljs-subst">-&gt;</span>super, x, y);

    <span class="hljs-comment">/* next, you initialize the attributes added by this subclass... */</span>
    me<span class="hljs-subst">-&gt;</span>width <span class="hljs-subst">=</span> width;
    me<span class="hljs-subst">-&gt;</span>height <span class="hljs-subst">=</span> height;
}</code></pre> 
<p>我们来看一下 Rectangle 的继承关系和内存布局</p> 
<p><img src="https://images2.imgbox.com/0a/5d/z5BCmWKt_o.png" alt="内存布局" title=""> <br> 因为有这样的内存布局，所以你可以很安全的传一个指向 Rectangle 对象的指针到一个期望传入 Shape 对象的指针的函数中，就是一个函数的参数是 “Shape *”，你可以传入 “Rectangle *”，并且这是非常安全的。这样的话，基类的所有属性和方法都可以被继承类继承！</p> 
<pre class="prettyprint"><code class=" hljs avrasm"><span class="hljs-preprocessor">#include "rect.h"  </span>
<span class="hljs-preprocessor">#include &lt;stdio.h&gt; </span>

int main() 
{
    Rectangle <span class="hljs-built_in">r1</span>, <span class="hljs-built_in">r2</span><span class="hljs-comment">;</span>

    // 实例化对象
    Rectangle_ctor(&amp;<span class="hljs-built_in">r1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">10</span>, <span class="hljs-number">15</span>)<span class="hljs-comment">;</span>
    Rectangle_ctor(&amp;<span class="hljs-built_in">r2</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>)<span class="hljs-comment">;</span>

    printf(<span class="hljs-string">"Rect r1(x=%d,y=%d,width=%d,height=%d)\n"</span>,
           Shape_getX(&amp;<span class="hljs-built_in">r1</span><span class="hljs-preprocessor">.super</span>), Shape_getY(&amp;<span class="hljs-built_in">r1</span><span class="hljs-preprocessor">.super</span>),
           <span class="hljs-built_in">r1</span><span class="hljs-preprocessor">.width</span>, <span class="hljs-built_in">r1</span><span class="hljs-preprocessor">.height</span>)<span class="hljs-comment">;</span>
    printf(<span class="hljs-string">"Rect r2(x=%d,y=%d,width=%d,height=%d)\n"</span>,
           Shape_getX(&amp;<span class="hljs-built_in">r2</span><span class="hljs-preprocessor">.super</span>), Shape_getY(&amp;<span class="hljs-built_in">r2</span><span class="hljs-preprocessor">.super</span>),
           <span class="hljs-built_in">r2</span><span class="hljs-preprocessor">.width</span>, <span class="hljs-built_in">r2</span><span class="hljs-preprocessor">.height</span>)<span class="hljs-comment">;</span>

    // 注意，这里有两种方式，一是强转类型，二是直接使用成员地址
    Shape_moveBy((Shape *)&amp;<span class="hljs-built_in">r1</span>, -<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<span class="hljs-comment">;</span>
    Shape_moveBy(&amp;<span class="hljs-built_in">r2</span><span class="hljs-preprocessor">.super</span>, <span class="hljs-number">2</span>, -<span class="hljs-number">1</span>)<span class="hljs-comment">;</span>

    printf(<span class="hljs-string">"Rect r1(x=%d,y=%d,width=%d,height=%d)\n"</span>,
           Shape_getX(&amp;<span class="hljs-built_in">r1</span><span class="hljs-preprocessor">.super</span>), Shape_getY(&amp;<span class="hljs-built_in">r1</span><span class="hljs-preprocessor">.super</span>),
           <span class="hljs-built_in">r1</span><span class="hljs-preprocessor">.width</span>, <span class="hljs-built_in">r1</span><span class="hljs-preprocessor">.height</span>)<span class="hljs-comment">;</span>
    printf(<span class="hljs-string">"Rect r2(x=%d,y=%d,width=%d,height=%d)\n"</span>,
           Shape_getX(&amp;<span class="hljs-built_in">r2</span><span class="hljs-preprocessor">.super</span>), Shape_getY(&amp;<span class="hljs-built_in">r2</span><span class="hljs-preprocessor">.super</span>),
           <span class="hljs-built_in">r2</span><span class="hljs-preprocessor">.width</span>, <span class="hljs-built_in">r2</span><span class="hljs-preprocessor">.height</span>)<span class="hljs-comment">;</span>

    return <span class="hljs-number">0</span><span class="hljs-comment">;</span>
}</code></pre> 
<p>输出结果：</p> 
<pre class="prettyprint"><code class=" hljs avrasm">Rect <span class="hljs-built_in">r1</span>(<span class="hljs-built_in">x</span>=<span class="hljs-number">0</span>,<span class="hljs-built_in">y</span>=<span class="hljs-number">2</span>,width=<span class="hljs-number">10</span>,height=<span class="hljs-number">15</span>)
Rect <span class="hljs-built_in">r2</span>(<span class="hljs-built_in">x</span>=-<span class="hljs-number">1</span>,<span class="hljs-built_in">y</span>=<span class="hljs-number">3</span>,width=<span class="hljs-number">5</span>,height=<span class="hljs-number">8</span>)
Rect <span class="hljs-built_in">r1</span>(<span class="hljs-built_in">x</span>=-<span class="hljs-number">2</span>,<span class="hljs-built_in">y</span>=<span class="hljs-number">5</span>,width=<span class="hljs-number">10</span>,height=<span class="hljs-number">15</span>)
Rect <span class="hljs-built_in">r2</span>(<span class="hljs-built_in">x</span>=<span class="hljs-number">1</span>,<span class="hljs-built_in">y</span>=<span class="hljs-number">2</span>,width=<span class="hljs-number">5</span>,height=<span class="hljs-number">8</span>)</code></pre> 
<h3 id="4多态">4、多态</h3> 
<p>C++ 语言实现多态就是使用虚函数。在 C 语言里面，也可以实现多态。 <br> 现在，我们又要增加一个圆形，并且在 Shape 要扩展功能，我们要增加 area() 和 draw() 函数。但是 Shape 相当于抽象类，不知道怎么去计算自己的面积，更不知道怎么去画出来自己。而且，矩形和圆形的面积计算方式和几何图像也是不一样的。</p> 
<p>下面让我们重新声明一下 Shape 类</p> 
<pre class="prettyprint"><code class=" hljs vala"><span class="hljs-preprocessor">#ifndef SHAPE_H</span>
<span class="hljs-preprocessor">#define SHAPE_H</span>

<span class="hljs-preprocessor">#include &lt;stdint.h&gt;</span>

<span class="hljs-keyword">struct</span> ShapeVtbl;
<span class="hljs-comment">// Shape 的属性</span>
typedef <span class="hljs-keyword">struct</span> {
    <span class="hljs-keyword">struct</span> ShapeVtbl <span class="hljs-keyword">const</span> *vptr;
    int16_t x; 
    int16_t y; 
} Shape;

<span class="hljs-comment">// Shape 的虚表</span>
<span class="hljs-keyword">struct</span> ShapeVtbl {
    uint32_t (*area)(Shape <span class="hljs-keyword">const</span> * <span class="hljs-keyword">const</span> me);
    <span class="hljs-keyword">void</span> (*draw)(Shape <span class="hljs-keyword">const</span> * <span class="hljs-keyword">const</span> me);
};

<span class="hljs-comment">// Shape 的操作函数，接口函数</span>
<span class="hljs-keyword">void</span> Shape_ctor(Shape * <span class="hljs-keyword">const</span> me, int16_t x, int16_t y);
<span class="hljs-keyword">void</span> Shape_moveBy(Shape * <span class="hljs-keyword">const</span> me, int16_t dx, int16_t dy);
int16_t Shape_getX(Shape <span class="hljs-keyword">const</span> * <span class="hljs-keyword">const</span> me);
int16_t Shape_getY(Shape <span class="hljs-keyword">const</span> * <span class="hljs-keyword">const</span> me);

<span class="hljs-keyword">static</span> inline uint32_t Shape_area(Shape <span class="hljs-keyword">const</span> * <span class="hljs-keyword">const</span> me) 
{
    <span class="hljs-keyword">return</span> (*me-&gt;vptr-&gt;area)(me);
}

<span class="hljs-keyword">static</span> inline <span class="hljs-keyword">void</span> Shape_draw(Shape <span class="hljs-keyword">const</span> * <span class="hljs-keyword">const</span> me)
{
    (*me-&gt;vptr-&gt;draw)(me);
}


Shape <span class="hljs-keyword">const</span> *largestShape(Shape <span class="hljs-keyword">const</span> *shapes[], uint32_t nShapes);
<span class="hljs-keyword">void</span> drawAllShapes(Shape <span class="hljs-keyword">const</span> *shapes[], uint32_t nShapes);

<span class="hljs-preprocessor">#endif /* SHAPE_H */</span></code></pre> 
<p>看下加上虚函数之后的类关系图 <br> <img src="https://images2.imgbox.com/f6/3e/8Wz1ZDSj_o.png" alt="虚函数类图" title=""></p> 
<h4 id="41-虚表和虚指针">4.1 虚表和虚指针</h4> 
<p>虚表（Virtual Table）是这个类所有虚函数的函数指针的集合。</p> 
<p>虚指针（Virtual Pointer）是一个指向虚表的指针。这个虚指针必须存在于每个对象实例中，会被所有子类继承。</p> 
<p>在《Inside The C++ Object Model》的第一章内容中，有这些介绍。</p> 
<h4 id="42-在构造函数中设置vptr">4.2 在构造函数中设置vptr</h4> 
<p>在每一个对象实例中，vptr 必须被初始化指向其 vtbl。最好的初始化位置就是在类的构造函数中。事实上，在构造函数中，C++ 编译器隐式的创建了一个初始化的vptr。在 C 语言里面， 我们必须显示的初始化vptr。</p> 
<p>下面就展示一下，在 Shape 的构造函数里面，如何去初始化这个 vptr。</p> 
<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-preprocessor">#include "shape.h"</span>
<span class="hljs-preprocessor">#include &lt;assert.h&gt;</span>

<span class="hljs-comment">// Shape 的虚函数</span>
<span class="hljs-keyword">static</span> uint32_t Shape_area_(Shape <span class="hljs-keyword">const</span> * <span class="hljs-keyword">const</span> me);
<span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> Shape_draw_(Shape <span class="hljs-keyword">const</span> * <span class="hljs-keyword">const</span> me);

<span class="hljs-comment">// 构造函数</span>
<span class="hljs-keyword">void</span> Shape_ctor(Shape * <span class="hljs-keyword">const</span> me, int16_t x, int16_t y) 
{
    <span class="hljs-comment">// Shape 类的虚表</span>
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">struct</span> ShapeVtbl <span class="hljs-keyword">const</span> vtbl = 
    { 
       &amp;Shape_area_,
       &amp;Shape_draw_
    };
    me-&gt;vptr = &amp;vtbl; 
    me-&gt;x = x;
    me-&gt;y = y;
}


<span class="hljs-keyword">void</span> Shape_moveBy(Shape * <span class="hljs-keyword">const</span> me, int16_t dx, int16_t dy)
{
    me-&gt;x += dx;
    me-&gt;y += dy;
}


int16_t Shape_getX(Shape <span class="hljs-keyword">const</span> * <span class="hljs-keyword">const</span> me) 
{
    <span class="hljs-keyword">return</span> me-&gt;x;
}
int16_t Shape_getY(Shape <span class="hljs-keyword">const</span> * <span class="hljs-keyword">const</span> me) 
{
    <span class="hljs-keyword">return</span> me-&gt;y;
}

<span class="hljs-comment">// Shape 类的虚函数实现</span>
<span class="hljs-keyword">static</span> uint32_t Shape_area_(Shape <span class="hljs-keyword">const</span> * <span class="hljs-keyword">const</span> me) 
{
    assert(<span class="hljs-number">0</span>); <span class="hljs-comment">// 类似纯虚函数</span>
    <span class="hljs-keyword">return</span> <span class="hljs-number">0U</span>; <span class="hljs-comment">// 避免警告</span>
}

<span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> Shape_draw_(Shape <span class="hljs-keyword">const</span> * <span class="hljs-keyword">const</span> me) 
{
    assert(<span class="hljs-number">0</span>); <span class="hljs-comment">// 纯虚函数不能被调用</span>
}


Shape <span class="hljs-keyword">const</span> *largestShape(Shape <span class="hljs-keyword">const</span> *shapes[], uint32_t nShapes) 
{
    Shape <span class="hljs-keyword">const</span> *s = (Shape *)<span class="hljs-number">0</span>;
    uint32_t max = <span class="hljs-number">0U</span>;
    uint32_t i;
    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0U</span>; i &lt; nShapes; ++i) 
    {
        uint32_t area = Shape_area(shapes[i]);<span class="hljs-comment">// 虚函数调用</span>
        <span class="hljs-keyword">if</span> (area &gt; max) 
        {
            max = area;
            s = shapes[i];
        }
    }
    <span class="hljs-keyword">return</span> s;
}


<span class="hljs-keyword">void</span> drawAllShapes(Shape <span class="hljs-keyword">const</span> *shapes[], uint32_t nShapes) 
{
    uint32_t i;
    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0U</span>; i &lt; nShapes; ++i) 
    {
        Shape_draw(shapes[i]); <span class="hljs-comment">// 虚函数调用</span>
    }
}</code></pre> 
<p>注释比较清晰，这里不再多做解释。</p> 
<h4 id="43-继承-vtbl-和-重载-vptr">4.3 继承 vtbl 和 重载 vptr</h4> 
<p>上面已经提到过，基类包含 vptr，子类会自动继承。但是，vptr 需要被子类的虚表重新赋值。并且，这也必须发生在子类的构造函数中。下面是 Rectangle 的构造函数。</p> 
<pre class="prettyprint"><code class=" hljs vala"><span class="hljs-preprocessor">#include "rect.h"  </span>
<span class="hljs-preprocessor">#include &lt;stdio.h&gt; </span>

<span class="hljs-comment">// Rectangle 虚函数</span>
<span class="hljs-keyword">static</span> uint32_t Rectangle_area_(Shape <span class="hljs-keyword">const</span> * <span class="hljs-keyword">const</span> me);
<span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> Rectangle_draw_(Shape <span class="hljs-keyword">const</span> * <span class="hljs-keyword">const</span> me);

<span class="hljs-comment">// 构造函数</span>
<span class="hljs-keyword">void</span> Rectangle_ctor(Rectangle * <span class="hljs-keyword">const</span> me, int16_t x, int16_t y,
                    uint16_t width, uint16_t height)
{
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">struct</span> ShapeVtbl <span class="hljs-keyword">const</span> vtbl = 
    {
        &amp;Rectangle_area_,
        &amp;Rectangle_draw_
    };
    Shape_ctor(&amp;me-&gt;super, x, y); <span class="hljs-comment">// 调用基类的构造函数</span>
    me-&gt;super.vptr = &amp;vtbl;           <span class="hljs-comment">// 重载 vptr</span>
    me-&gt;width = width;
    me-&gt;height = height;
}

<span class="hljs-comment">// Rectangle's 虚函数实现</span>
<span class="hljs-keyword">static</span> uint32_t Rectangle_area_(Shape <span class="hljs-keyword">const</span> * <span class="hljs-keyword">const</span> me) 
{
    Rectangle <span class="hljs-keyword">const</span> * <span class="hljs-keyword">const</span> me_ = (Rectangle <span class="hljs-keyword">const</span> *)me; <span class="hljs-comment">//显示的转换</span>
    <span class="hljs-keyword">return</span> (uint32_t)me_-&gt;width * (uint32_t)me_-&gt;height;
}

<span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> Rectangle_draw_(Shape <span class="hljs-keyword">const</span> * <span class="hljs-keyword">const</span> me) 
{
    Rectangle <span class="hljs-keyword">const</span> * <span class="hljs-keyword">const</span> me_ = (Rectangle <span class="hljs-keyword">const</span> *)me; <span class="hljs-comment">//显示的转换</span>
    printf(<span class="hljs-string">"Rectangle_draw_(x=%d,y=%d,width=%d,height=%d)\n"</span>,
           Shape_getX(me), Shape_getY(me), me_-&gt;width, me_-&gt;height);
}
</code></pre> 
<h4 id="44-虚函数调用">4.4 虚函数调用</h4> 
<p>有了前面虚表（Virtual Tables）和虚指针（Virtual Pointers）的基础实现，虚拟调用（后期绑定）就可以用下面代码实现了。</p> 
<pre class="prettyprint"><code class="language-C++ hljs vbscript">uint32_t Shape_area(Shape <span class="hljs-keyword">const</span> * <span class="hljs-keyword">const</span> <span class="hljs-keyword">me</span>)
{
    return (*<span class="hljs-keyword">me</span>-&gt;vptr-&gt;area)(<span class="hljs-keyword">me</span>);
}</code></pre> 
<p>这个函数可以放到.c文件里面，但是会带来一个缺点就是每个虚拟调用都有额外的调用开销。为了避免这个缺点，如果编译器支持内联函数（C99）。我们可以把定义放到头文件里面，类似下面：</p> 
<pre class="prettyprint"><code class=" hljs objectivec"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> uint32_t Shape_area(Shape <span class="hljs-keyword">const</span> * <span class="hljs-keyword">const</span> me) 
{
    <span class="hljs-keyword">return</span> (*me-&gt;vptr-&gt;area)(me);
}</code></pre> 
<p>如果是老一点的编译器（C89），我们可以用宏函数来实现，类似下面这样：</p> 
<pre class="prettyprint"><code class=" hljs lasso"><span class="hljs-variable">#define</span> Shape_area(me_) ((<span class="hljs-subst">*</span>(me_)<span class="hljs-subst">-&gt;</span>vptr<span class="hljs-subst">-&gt;</span>area)((me_)))</code></pre> 
<p>看一下例子中的调用机制： <br> <img src="https://images2.imgbox.com/d7/14/hSyC76gm_o.png" alt="虚拟调用机制" title=""></p> 
<h4 id="45-mainc">4.5 main.c</h4> 
<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-preprocessor">#include "rect.h"  </span>
<span class="hljs-preprocessor">#include "circle.h" </span>
<span class="hljs-preprocessor">#include &lt;stdio.h&gt; </span>

<span class="hljs-keyword">int</span> main() 
{
    Rectangle r1, r2; 
    Circle    c1, c2; 
    Shape <span class="hljs-keyword">const</span> *shapes[] = 
    { 
        &amp;c1.super,
        &amp;r2.super,
        &amp;c2.super,
        &amp;r1.super
    };
    Shape <span class="hljs-keyword">const</span> *s;

    <span class="hljs-comment">// 实例化矩形对象</span>
    Rectangle_ctor(&amp;r1, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">10</span>, <span class="hljs-number">15</span>);
    Rectangle_ctor(&amp;r2, -<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>);

    <span class="hljs-comment">// 实例化圆形对象</span>
    Circle_ctor(&amp;c1, <span class="hljs-number">1</span>, -<span class="hljs-number">2</span>, <span class="hljs-number">12</span>);
    Circle_ctor(&amp;c2, <span class="hljs-number">1</span>, -<span class="hljs-number">3</span>, <span class="hljs-number">6</span>);

    s = largestShape(shapes, <span class="hljs-keyword">sizeof</span>(shapes)/<span class="hljs-keyword">sizeof</span>(shapes[<span class="hljs-number">0</span>]));
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"largetsShape s(x=%d,y=%d)\n"</span>, Shape_getX(s), Shape_getY(s));

    drawAllShapes(shapes, <span class="hljs-keyword">sizeof</span>(shapes)/<span class="hljs-keyword">sizeof</span>(shapes[<span class="hljs-number">0</span>]));

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre> 
<p>输出结果：</p> 
<pre class="prettyprint"><code class=" hljs scss">largetsShape <span class="hljs-function">s(x=<span class="hljs-number">1</span>,y=-<span class="hljs-number">2</span>)</span>
<span class="hljs-function">Circle_draw_(x=<span class="hljs-number">1</span>,y=-<span class="hljs-number">2</span>,rad=<span class="hljs-number">12</span>)</span>
<span class="hljs-function">Rectangle_draw_(x=-<span class="hljs-number">1</span>,y=<span class="hljs-number">3</span>,width=<span class="hljs-number">5</span>,height=<span class="hljs-number">8</span>)</span>
<span class="hljs-function">Circle_draw_(x=<span class="hljs-number">1</span>,y=-<span class="hljs-number">3</span>,rad=<span class="hljs-number">6</span>)</span>
<span class="hljs-function">Rectangle_draw_(x=<span class="hljs-number">0</span>,y=<span class="hljs-number">2</span>,width=<span class="hljs-number">10</span>,height=<span class="hljs-number">15</span>)</span></code></pre> 
<h3 id="5总结">5、总结</h3> 
<p>还是那句话，面向对象编程是一种方法，并不局限于某一种编程语言。用 C 语言实现封装、单继承，理解和实现起来比较简单，多态反而会稍微复杂一点，如果打算广泛的使用多态，还是推荐转到 C++ 语言上，毕竟这层复杂性被这个语言给封装了，你只需要简单的使用就行了。但并不代表，C 语言实现不了多态这个特性。</p> 
<p>用 C 语言实现面向对象编程，简直太 Skr 了!</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f5cf49e8b0b8e5517e39df63acf40fc5/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">laravel 目录添加n个app应用</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8b2d873b01458d7938c99847a80c2fa3/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Eureka--2、第一个Eureka程序，Eureka Client的自启动原理和简要过程</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>