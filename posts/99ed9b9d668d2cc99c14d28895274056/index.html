<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>logback 日志脱敏 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="logback 日志脱敏" />
<meta property="og:description" content="最近在研究如何使用logback实现日志脱敏的工作，网上各种查，各种找，终于找到了解决的办法。其实原理知道，就是想找一个最简便的方法而已。那今天咱们就来聊聊如何用Logback创建自定义格式转换符来实现日志脱敏**
脱敏类文件
配置文件
脱敏类文件
数据脱敏是指对某些敏感信息通过脱敏规则进行数据的变形，实现敏感隐私数据的可靠保护。 —— [ 百度百科 ]
本文使用最简单的脱敏方式进行数据脱敏打印，规则如下：
| 参数 | 脱敏前 | 脱敏后 |
| ——– | ——– | ——– |
| 姓名 | 李丽丽 | 李** |
| 手机号 | 13898701234 | 138****1234 |
| 身份证号 | 111111111111115762 | **************5762 |
| 银行卡号 | 6222600890987671234 | 6222600********1234 |
具体代码
首先定义类：SensitiveDataConverter 继承父类：MessageConverter
import ch.qos.logback.classic.pattern.MessageConverter;
import ch.qos.logback.classic.spi.ILoggingEvent;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
/**
* 敏感信息脱敏处理
* @author AAA" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/99ed9b9d668d2cc99c14d28895274056/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-03-05T13:53:55+08:00" />
<meta property="article:modified_time" content="2019-03-05T13:53:55+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">logback 日志脱敏</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>最近在研究如何使用logback实现日志脱敏的工作，网上各种查，各种找，终于找到了解决的办法。其实原理知道，就是想找一个最简便的方法而已。那今天咱们就来聊聊如何用Logback创建自定义格式转换符来实现日志脱敏**</p> 
<p>脱敏类文件<br> 配置文件<br> 脱敏类文件<br> 数据脱敏是指对某些敏感信息通过脱敏规则进行数据的变形，实现敏感隐私数据的可靠保护。 —— [ 百度百科 ]</p> 
<p>本文使用最简单的脱敏方式进行数据脱敏打印，规则如下：</p> 
<p>| 参数 | 脱敏前 | 脱敏后 |</p> 
<p>| ——– | ——– | ——– |</p> 
<p>| 姓名 | 李丽丽 | 李** |</p> 
<p>| 手机号 | 13898701234 | 138****1234 |</p> 
<p>| 身份证号 | 111111111111115762 | **************5762 |</p> 
<p>| 银行卡号 | 6222600890987671234 | 6222600********1234 |</p> 
<p>具体代码<br> 首先定义类：SensitiveDataConverter 继承父类：MessageConverter</p> 
<p><br> import ch.qos.logback.classic.pattern.MessageConverter;<br> import ch.qos.logback.classic.spi.ILoggingEvent;</p> 
<p>import java.util.regex.Matcher;<br> import java.util.regex.Pattern;</p> 
<p>/**<br>  * 敏感信息脱敏处理<br>  * @author AAA<br>  */<br> public class SensitiveDataConverter extends MessageConverter {<!-- --></p> 
<p>    @Override<br>     public String convert(ILoggingEvent event){<!-- --><br>         // 获取原始日志<br>         String oriLogMsg = event.getFormattedMessage();</p> 
<p>        // 获取脱敏后的日志<br>         String afterLogMsg = invokeMsg(oriLogMsg);<br>         return afterLogMsg;<br>     }</p> 
<p>    /**<br>      * 日志脱敏开关<br>      */<br>     private static String converterCanRun = "true";<br>     /**<br>      * 日志脱敏关键字<br>      */<br>     private static String sensitiveDataKeys = "idcard,realname,bankcard,mobile"; </p> 
<p>    /**<br>      * 处理日志字符串，返回脱敏后的字符串<br>      * @param msg<br>      * @return<br>      */<br>     public String invokeMsg(final String oriMsg){<!-- --><br>         String tempMsg = oriMsg;<br>         if("true".equals(converterCanRun)){<!-- --><br>             // 处理字符串<br>             if(sensitiveDataKeys != null &amp;&amp; sensitiveDataKeys.length() &gt; 0){<!-- --><br>                 String[] keysArray = sensitiveDataKeys.split(",");<br>                 for(String key: keysArray){<!-- --><br>                     int index= -1; <br>                     do{<!-- --><br>                         index = tempMsg.indexOf(key, index+1);<br>                         if(index != -1){ <br>                             // 判断key是否为单词字符<br>                             if(isWordChar(tempMsg, key, index)){<!-- --><br>                                 continue;<br>                             }<br>                             // 寻找值的开始位置<br>                             int valueStart = getValueStartIndex(tempMsg, index + key.length());</p> 
<p>                            // 查找值的结束位置（逗号，分号）........................<br>                             int valueEnd = getValuEndEIndex(tempMsg, valueStart);</p> 
<p>                            // 对获取的值进行脱敏 <br>                             String subStr = tempMsg.substring(valueStart, valueEnd);<br>                             subStr = tuomin(subStr, key);<br>                             ///<br>                             tempMsg = tempMsg.substring(0,valueStart) + subStr + tempMsg.substring(valueEnd);<br>                         }<br>                     }while(index != -1);<br>                 }<br>             }<br>         }<br>         return tempMsg;<br>     }</p> 
<p><br>     private static Pattern pattern = Pattern.compile("[0-9a-zA-Z]");<br>     /**<br>      * 判断从字符串msg获取的key值是否为单词 ， index为key在msg中的索引值<br>      * @return<br>      */<br>     private boolean isWordChar(String msg, String key, int index){<!-- --></p> 
<p>        // 必须确定key是一个单词............................<br>         if(index != 0){ // 判断key前面一个字符<br>             char preCh = msg.charAt(index-1);<br>             Matcher match = pattern.matcher(preCh + "");<br>             if(match.matches()){<!-- --><br>                 return true;<br>             }<br>         }<br>         // 判断key后面一个字符<br>         char nextCh = msg.charAt(index + key.length());<br>         Matcher match = pattern.matcher(nextCh + "");<br>         if(match.matches()){<!-- --><br>             return true;<br>         }<br>         return false;<br>     }</p> 
<p>    public static void main(String[] args) {<!-- --><br>         String tempMsg = "{sign=f88898b2677e62f1ad54b9e330c0a27e, idcard=130333198901192762, realname=%E5%BE%90%E5%BD%A6%E5%A8%9C, key=c5d34d4c3c71cc45c88f32b4f13da887, mobile=13210141605, bankcard=6226430106137525}";<br>         String tempMsg1 = "{\"reason\":\"成功 \",\"result\":{\"jobid\":\"JH2131171027170837443588J6\",\"realname\":\"李哪娜\",\"bankcard\":\"6226430106137525\",\"idcard\":\"130333198901192762\",\"mobile\":\"13210141605\",\"res\":\"1\",\"message\":\"验证成功\"},\"error_code\":0}";<br>         SensitiveDataConverter sc = new SensitiveDataConverter();<br>         System.out.println(sc.invokeMsg(tempMsg));<br>         System.out.println(sc.invokeMsg(tempMsg1));<br>     }</p> 
<p>    /**<br>      * 获取value值的开始位置<br>      * @param msg 要查找的字符串<br>      * @param valueStart 查找的开始位置<br>      * @return<br>      */<br>     private int getValueStartIndex(String msg, int valueStart ){<!-- --><br>         // 寻找值的开始位置.................................<br>         do{<!-- --><br>             char ch = msg.charAt(valueStart);<br>             if(ch == ':' || ch == '='){ // key与 value的分隔符<br>                 valueStart ++;<br>                 ch = msg.charAt(valueStart);<br>                 if(ch == '"'){<!-- --><br>                     valueStart ++;<br>                 }<br>                 break;    // 找到值的开始位置<br>             }else{<!-- --><br>                 valueStart ++;<br>             }<br>         }while(true);<br>         return valueStart;<br>     }</p> 
<p>    /**<br>      * 获取value值的结束位置<br>      * @return<br>      */<br>     private int getValuEndEIndex(String msg,int valueEnd){<!-- --><br>         do{<!-- --><br>             if(valueEnd == msg.length()){<!-- --><br>                 break;<br>             }<br>             char ch = msg.charAt(valueEnd);</p> 
<p>            if(ch == '"'){ // 引号时，判断下一个值是结束，分号还是逗号决定是否为值的结束<br>                 if(valueEnd+1 == msg.length()){<!-- --><br>                     break;<br>                 }<br>                 char nextCh = msg.charAt(valueEnd+1);<br>                 if(nextCh ==';' || nextCh == ','){<!-- --><br>                     // 去掉前面的 \  处理这种形式的数据<br>                     while(valueEnd&gt;0 ){<!-- --><br>                         char preCh = msg.charAt(valueEnd-1);<br>                         if(preCh != '\\'){<!-- --><br>                             break;<br>                         }<br>                         valueEnd--;<br>                     }<br>                     break;<br>                 }else{<!-- --><br>                     valueEnd ++;<br>                 }<br>             }else if (ch ==';' || ch == ',' || ch == '}'){<!-- --><br>                 break;<br>             }else{<!-- --><br>                 valueEnd ++;<br>             }</p> 
<p>        }while(true);<br>         return valueEnd;<br>     }</p> 
<p>    private String tuomin(String submsg, String key){<!-- --><br>         // idcard：身份证号, realname：姓名, bankcard：银行卡号, mobile：手机号<br>         if("idcard".equals(key)){<!-- --><br>             return SensitiveInfoUtils.idCardNum(submsg);<br>         }<br>         if("realname".equals(key)){<!-- --><br>             return SensitiveInfoUtils.chineseName(submsg);<br>         }<br>         if("bankcard".equals(key)){<!-- --><br>             return SensitiveInfoUtils.bankCard(submsg);<br>         }<br>         if("mobile".equals(key)){<!-- --><br>             return SensitiveInfoUtils.mobilePhone(submsg);<br>         }<br>         return "";<br>     }<br> }</p> 
<p>import org.apache.commons.lang.StringUtils;</p> 
<p>public class SensitiveInfoUtils {<!-- --></p> 
<p>    /**<br>      * [姓名] 只显示第一个汉字，其他隐藏为星号&lt;例子：李**&gt;<br>      * <br>      * @param fullName<br>      * @return<br>      */<br>     public static String chineseName(String fullName) {<!-- --><br>         if (StringUtils.isBlank(fullName)) {<!-- --><br>             return "";<br>         }<br>         String name = StringUtils.left(fullName, 1);<br>         return StringUtils.rightPad(name, StringUtils.length(fullName), "*");<br>     }</p> 
<p>    /**<br>      * [身份证号] 显示最后四位，其他隐藏。共计18位或者15位。&lt;例子：*************5762&gt;<br>      * <br>      * @param idCardNum<br>      * @return<br>      */<br>     public static String idCardNum(String idCardNum) {<!-- --><br>         if (StringUtils.isBlank(idCardNum)) {<!-- --><br>             return "";<br>         }<br>         String num = StringUtils.right(idCardNum, 4);<br>         return StringUtils.leftPad(num, StringUtils.length(idCardNum), "*");<br>     }</p> 
<p>    /**<br>      * [手机号码] 前三位，后四位，其他隐藏&lt;例子:138******1234&gt;<br>      * <br>      * @param num<br>      * @return<br>      */<br>     public static String mobilePhone(String num) {<!-- --><br>         if (StringUtils.isBlank(num)) {<!-- --><br>             return "";<br>         }<br>         return StringUtils.left(num, 3).concat(StringUtils.removeStart(StringUtils.leftPad(StringUtils.right(num, 4),StringUtils.length(num), "*"), "***"));<br>     }</p> 
<p>    /**<br>      * [银行卡号] 前六位，后四位，其他用星号隐藏每位1个星号&lt;例子:6222600**********1234&gt;<br>      * <br>      * @param cardNum<br>      * @return<br>      */<br>     public static String bankCard(String cardNum) {<!-- --><br>         if (StringUtils.isBlank(cardNum)) {<!-- --><br>             return "";<br>         }<br>         return StringUtils.left(cardNum, 6).concat(StringUtils.removeStart(StringUtils.leftPad(StringUtils.right(cardNum, 4), StringUtils.length(cardNum), "*"), "******"));<br>     }<br> }<br> 配置文件<br> 代码部分完成之后，我们需要在locback.xml配置文件中增加一行配置：</p> 
<p>&lt;conversionRule conversionWord="msg" converterClass="com.api.filter.SensitiveDataConverter"&gt; &lt;/conversionRule&gt;<br> 1<br> 详细如下:</p> 
<p>&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br> &lt;configuration&gt;<br>     &lt;!-- Logback默认配置的采用的步骤 --&gt;<br>     &lt;!-- 1. 尝试在 classpath 下查找文件 logback-test.xml； --&gt;<br>     &lt;!-- 2. 如果文件不存在，则查找文件 logback.xml； --&gt;<br>     &lt;!-- 3. 如果两个文件都不存在，logback 用 BasicConfigurator 自动对自己进行配置，这会导致记录输出到控制台。 --&gt;</p> 
<p>    &lt;!-- 本机环境中只会加载该配置文件，部署服务器时请删除本文件 --&gt;</p> 
<p>    &lt;conversionRule conversionWord="msg" converterClass="com.api.filter.SensitiveDataConverter"&gt; &lt;/conversionRule&gt;<br>     &lt;!-- 输出控制台 --&gt;<br>     &lt;appender name="console" class="ch.qos.logback.core.ConsoleAppender"&gt;<br>         &lt;target&gt;System.out&lt;/target&gt;<br>         &lt;encoder&gt;<br>             &lt;Pattern&gt;&lt;![CDATA[ [%-5level] [%d{yyyy-MM-dd HH:mm:ss.SSS}] [%t] [%logger.%method:%line] -- %msg%n ]]&gt;&lt;/Pattern&gt;<br>         &lt;/encoder&gt;<br>     &lt;/appender&gt; </p> 
<p>    &lt;!-- 时间滚动输出日志 --&gt;<br>     &lt;appender name="file—info" class="ch.qos.logback.core.rolling.RollingFileAppender"&gt;<br>         &lt;file&gt;D:/logs/aaaa.log&lt;/file&gt;<br>         &lt;filter class="ch.qos.logback.classic.filter.LevelFilter"&gt;<br>             &lt;level&gt;INFO&lt;/level&gt;<br>         &lt;/filter&gt;<br>         &lt;rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy"&gt;<br>             &lt;fileNamePattern&gt;D:/logs/aaaa.%d{yyyy-MM-dd}.log&lt;/fileNamePattern&gt;<br>         &lt;/rollingPolicy&gt;<br>         &lt;encoder&gt;<br>             &lt;pattern&gt;&lt;![CDATA[ [%-5level] [%d{yyyy-MM-dd HH:mm:ss.SSS}] [%t] [%logger.%method:%line] -- %msg%n ]]&gt;&lt;/pattern&gt;<br>         &lt;/encoder&gt;<br>     &lt;/appender&gt;</p> 
<p>    &lt;logger name="dfpay-auto" additivity="false"&gt;<br>         &lt;appender-ref ref="INFO_FILE" /&gt;<br>     &lt;/logger&gt;</p> 
<p>    &lt;root level="INFO"&gt;<br>         &lt;appender-ref ref="console" /&gt;<br>     &lt;/root&gt;<br> &lt;/configuration&gt;<br> 然后就可以运行代码，输出结果：</p> 
<p>{sign=f88898b2677e62f1ad54b9e330c0a27e, idcard=*********2762, realname=%*********************, key=c5d34d4c3c71cc45c88f32b4f13da887, mobile=132****1605, bankcard=622643******7525} <br> {“reason”:”成功 “,”result”:{“jobid”:”JH2131171027170837443588J6”,”realname”:”李**”,”bankcard”:”622643******7525”,”idcard”:”**************2762”,”mobile”:”132****1605”,”res”:”1”,”message”:”验证成功”},”error_code”:0}</p> 
<p>目录：</p> 
<p>脱敏类文件<br> 具体代码<br> 配置文件<br> 结束语<br> 结束语<br> 代码很简单，说白了就是利用logback的Converter，自定义日志格式转换符，然后继承ClassicConverter就可以了 ，当然了还有其他的实现方式，这里就不多写了。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/64ea7412c674078049943ec84dfefc88/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">vue 路由跳转，导致页面样式错乱，刷新又好了的情况</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/286faea0b4e3a91d8371c2cd1b84800a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">H.264的profile与level概念解释。</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>