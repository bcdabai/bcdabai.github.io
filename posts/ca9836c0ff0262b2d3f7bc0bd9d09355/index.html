<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>P1605 迷宫( C语言版  DFS&#43;回溯 ) - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="P1605 迷宫( C语言版  DFS&#43;回溯 )" />
<meta property="og:description" content="题目背景 迷宫 【问题描述】
给定一个N*M方格的迷宫，迷宫里有T处障碍，障碍处不可通过。给定起点坐标和
终点坐标，问: 每个方格最多经过1次，有多少种从起点坐标到终点坐标的方案。在迷宫
中移动有上下左右四种方式，每次只能移动一个方格。数据保证起点上没有障碍。
输入样例 输出样例
【数据规模】
1≤N,M≤5
题目描述 输入输出格式 输入格式：
【输入】
第一行N、M和T，N为行，M为列，T为障碍总数。第二行起点坐标SX,SY，终点
坐标FX,FY。接下来T行，每行为障碍点的坐标。
输出格式：
【输出】
给定起点坐标和终点坐标，问每个方格最多经过1次，从起点坐标到终点坐标的方
案总数。
样例输入 2 2 1
1 1 2 2
1 2 样例输出 1 解题思路 这个题也是迷宫问题的一个变形，因为数据规模比较小，所以DFS搜索也能解决问题，这个也是DFS入门的比较经典的题型，这个题也可以用BFS做，如果有时间就写一个。就是从起点开始，下一个位置不断不断的尝试，直到找到，如果这个路走不通，就返回到上一步换个方向找，这就是回溯，大概思路就是这样，如果有不懂的欢迎留言，我随时回答你。 #include &lt;stdio.h&gt; int a[6][6]; // 记录障碍 int b[6][6]; //标记数组 记录自己走过的格子 防止重复走 int c[4][2]={{0,-1},{-1,0},{0,1},{1,0}};//方向数组 int n,m,t; int sx,sy,fx,fy; int sum; void DFS(int x ,int y){ int i,mx,my; if(x==fx&amp;&amp; y==fy) &#43;&#43;sum; //满足条 for(i=0;i&lt;4;i&#43;&#43;){ mx=x&#43;c[i][0]; my=y&#43;c[i][1]; if(mx&lt;1||mx&gt;n ||my&lt;1||my&gt;m || a[mx][my]==-1 || b[mx][my]) continue;//判断下一个点十分满足条件 b[mx][my]=1; //标记改点 DFS(mx,my);//找下一个满足条件的点 b[mx][my]=0;//回溯到上一个点的位置进行寻找 } } int main(){ int i,jx,jy; sum=0; scanf(&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/ca9836c0ff0262b2d3f7bc0bd9d09355/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-03-10T10:04:15+08:00" />
<meta property="article:modified_time" content="2019-03-10T10:04:15+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">P1605 迷宫( C语言版  DFS&#43;回溯 )</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>题目背景</h3> 
<p>迷宫 【问题描述】</p> 
<p>给定一个N*M方格的迷宫，迷宫里有T处障碍，障碍处不可通过。给定起点坐标和</p> 
<p>终点坐标，问: 每个方格最多经过1次，有多少种从起点坐标到终点坐标的方案。在迷宫</p> 
<p>中移动有上下左右四种方式，每次只能移动一个方格。数据保证起点上没有障碍。</p> 
<p>输入样例 输出样例</p> 
<p>【数据规模】</p> 
<p>1≤N,M≤5</p> 
<h3>题目描述</h3> 
<h3>输入输出格式</h3> 
<p><strong>输入格式：</strong></p> 
<p> </p> 
<p>【输入】</p> 
<p>第一行N、M和T，N为行，M为列，T为障碍总数。第二行起点坐标SX,SY，终点</p> 
<p>坐标FX,FY。接下来T行，每行为障碍点的坐标。</p> 
<p> </p> 
<p><strong>输出格式：</strong></p> 
<p> </p> 
<p>【输出】</p> 
<p>给定起点坐标和终点坐标，问每个方格最多经过1次，从起点坐标到终点坐标的方</p> 
<p>案总数。</p> 
<h4>样例输入</h4> 
<blockquote> 
 <p>2 2 1<br> 1 1 2 2<br> 1 2 </p> 
</blockquote> 
<h4>样例输出 </h4> 
<blockquote> 
 <p>1 </p> 
</blockquote> 
<h3>解题思路 </h3> 
<h4>这个题也是迷宫问题的一个变形，因为数据规模比较小，所以DFS搜索也能解决问题，这个也是DFS入门的比较经典的题型，这个题也可以用BFS做，如果有时间就写一个。就是从起点开始，下一个位置不断不断的尝试，直到找到，如果这个路走不通，就返回到上一步换个方向找，这就是回溯，大概思路就是这样，如果有不懂的欢迎留言，我随时回答你。</h4> 
<pre class="has"><code class="language-cpp">#include &lt;stdio.h&gt;
int a[6][6]; // 记录障碍 
int b[6][6]; //标记数组 记录自己走过的格子 防止重复走 
int c[4][2]={<!-- -->{0,-1},{-1,0},{0,1},{1,0}};//方向数组 
int n,m,t;
int sx,sy,fx,fy;
int sum;
void DFS(int x ,int y){
	int i,mx,my;
	if(x==fx&amp;&amp; y==fy) ++sum; //满足条 
	for(i=0;i&lt;4;i++){
		mx=x+c[i][0];
		my=y+c[i][1];
		if(mx&lt;1||mx&gt;n ||my&lt;1||my&gt;m || a[mx][my]==-1 || b[mx][my]) continue;//判断下一个点十分满足条件 
		b[mx][my]=1; //标记改点 
		DFS(mx,my);//找下一个满足条件的点 
		b[mx][my]=0;//回溯到上一个点的位置进行寻找 
	}
} 
int main(){
	int i,jx,jy;
	sum=0;
	scanf("%d %d %d",&amp;n,&amp;m,&amp;t);
	scanf("%d %d %d %d",&amp;sx,&amp;sy,&amp;fx,&amp;fy);
	for(i=0;i&lt;t;i++)
	{
		scanf("%d %d",&amp;jx,&amp;jy);
		a[jx][jy]=-1;
	}
	b[sx][sy]=1;//标记起始位置 
	DFS(sx ,sy);
	printf("%d",sum);
	return 0;
} </code></pre> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ab7b012e5a4b7d2857ea9c9df21b96fb/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">opkg update失败问题解决</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/dcea206dc163c0913384ff80d0c88e2c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">5. 卡特兰数（Catalan）公式、证明、代码、典例.</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>