<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Boost Graph Library 快速入门 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Boost Graph Library 快速入门" />
<meta property="og:description" content="Boost Graph Library 快速入门 图领域的数据结构和算法在某些方面比容器更为复杂，图算法在图中移动有着众多的路线，而STL使用的抽象迭代器接口不能有效的支持这些。作为替换，我们为图提供了一个的抽象的结构，其与容器迭代器的目的类似（尽管迭代器扮演着更大的角色）。图1 描述了STL 和BGL 之间的对比。
图1: The analogy between the STL and the BGL.
图由一系列顶点vertices，以及连接顶点的边edges组成. 如图2描述了一个拥有5个顶点和11条边的有向图directed graph. 离开一个顶的边称为该点的out-edges。边 {(0,1),(0,2),(0,3),(0,4)} 都是节点0的out-edges ,进入一个顶点的边称为该点的in-edges , 边{(0,4),(2,4),(3,4)} 是节点0的in-edges 图2 一个有向图例子
在后面的章节中，我们使用BGL构造上图并展示各种操作。全部的代码可以在examples/quick_tour.cpp 中找到，下面每个章节都是这个例子文件的一个片断。
构造一个图 在这个例子中，我们将使用BGL邻接表adjacency_list 类来示范BGL接口中的主要概念。adjacency_list类提供了典型邻接表数据结构的一个泛型版本。 adjacency_list 是一个拥有6个模板参数的模板类。但我们只使用了前3个参数，剩余的3个使用默认参数。头两个模板参数(vecS, vecS)分别用来描述离开顶点的out-edges边和图中顶点的集合所使用的数据结构(阅读 Choosing the Edgelist and VertexList 章节可以获得更多关于平衡不同数据结构的信息)。 第三个参数, 使用bidirectionalS表示选择一个可访问出、入边的有向图，其中directedS 为选择一个仅提供出边的有向图；undirectedS 表示选择一个无向图。
一旦我们选定了图的类型，我们可以创建一个图2所示的图。声明一个图对象，使用 MutableGraph 接口中的add_edge() 函数来填充边，在这个例子中我们简单的使用 pairs 数组edge_array来建立边在这个例子中我们简单的使用 pairs 数组edge_array来建立边。
#include &lt;iostream&gt; // for std::cout #include &lt;utility&gt; // for std::pair #include &lt;algorithm&gt; // for std::for_each #include &lt;boost/graph/graph_traits." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/3b5e194ae838a3b09f0f375de113df6c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-06-28T08:27:41+08:00" />
<meta property="article:modified_time" content="2018-06-28T08:27:41+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Boost Graph Library 快速入门</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><img alt="" class="has" src="https://images2.imgbox.com/2b/16/KMAcs5F2_o.jpg"></p> 
<p> </p> 
<h2><a name="t0"></a>Boost Graph Library 快速入门</h2> 
<p> </p> 
<p><span style="color:#333333;">     图领域的数据结构和算法在某些方面比容器更为复杂，<strong>图算法</strong>在图中移动有着众多的路线，而<strong>STL使用的抽象迭代器接口</strong>不能有效的支持这些。作为替换，我们为图提供了一个的抽象的结构，其与容器迭代器的目的类似（尽管迭代器扮演着更大的角色）。图1 描述了<strong>STL 和BGL 之间的对比。</strong></span></p> 
<p> </p> 
<p><span style="color:#333333;">               图1: The analogy between the STL and the BGL.</span></p> 
<p> </p> 
<p>       <img alt="" class="has" src="https://images2.imgbox.com/9c/12/xfBn2SUi_o.png"></p> 
<p><br><span style="color:#333333;">    图由一系列<strong>顶点vertices</strong>，以及连接顶点的<strong>边edges</strong>组成. 如图2描述了一个拥有5个顶点和11条边的有向图directed graph. 离开一个顶的边称为该点的<strong>out-edges</strong>。边 {(0,1),(0,2),(0,3),(0,4)} 都是节点0的out-edges ,进入一个顶点的边称为该点的<strong>in-edges </strong>, 边{(0,4),(2,4),(3,4)} 是节点0的in-edges  </span></p> 
<p> </p> 
<p>                  图2 一个有向图例子</p> 
<p>                     <img alt="" class="has" src="https://images2.imgbox.com/e9/21/D4Flhnn7_o.png"></p> 
<p> </p> 
<p>在后面的章节中，我们使用BGL构造上图并展示各种操作。全部的代码可以在<a href="http://www.boost.org/libs/graph/example/quick_tour.cpp" rel="nofollow">examples/quick_tour.cpp</a>  中找到，下面每个章节都是这个例子文件的一个片断。</p> 
<p> </p> 
<h3><a name="t1"></a>构造一个图</h3> 
<p><span style="color:#333333;">     在这个例子中，我们将使用BGL邻接表</span><a href="http://www.boost.org/libs/graph/doc/adjacency_list.html" rel="nofollow">adjacency_list</a><span style="color:#333333;"> 类来示范BGL接口中的主要概念。adjacency_list类提供了典型</span><span style="color:#333333;">邻接表数据结构</span><span style="color:#333333;">的一个泛型版本。 adjacency_list 是一个拥有</span><span style="color:#333333;">6个模板参数</span><span style="color:#333333;">的模板类。但我们只使用了前3个参数，剩余的3个使用默认参数。头两个模板参数<strong>(vecS, vecS)</strong>分别用来描述</span><span style="color:#ff0000;"><strong>离开顶点的out-edges边</strong></span><span style="color:#333333;">和</span><strong><span style="color:#cc0000;">图中顶点的集合</span></strong><span style="color:#333333;">所使用的数据结构(阅读 Choosing the Edgelist and VertexList 章节可以获得更多关于平衡不同数据结构的信息)。 第三个参数, 使用</span><span style="color:#333333;">bidirectionalS</span><span style="color:#333333;">表示选择一个可访问</span><strong><span style="color:#cc0000;">出、入边的有向图</span></strong><span style="color:#333333;">，其中<strong>directedS</strong> 为选择一个仅提供出边的有向图；<strong>undirectedS</strong> 表示选择一个无向图。</span></p> 
<p><span style="color:#333333;">    一旦我们选定了图的类型，我们可以创建一个图2所示的图。声明一个图对象，使用 </span><a href="http://www.boost.org/libs/graph/doc/MutableGraph.html" rel="nofollow">MutableGraph</a><span style="color:#333333;"> 接口中的</span><strong>add_edge</strong><span style="color:#333333;">() 函数来填充边，在这个例子中我们简单的</span><span style="color:#cc0000;">使用 <strong>pairs</strong> 数组<strong>edge_array</strong>来建立边</span><span style="color:#333333;">在这个例子中我们简单的使用 pairs 数组edge_array来建立边。</span></p> 
<pre class="has"><code class="language-cpp">#include &lt;iostream&gt; // for std::cout
#include &lt;utility&gt; // for std::pair
#include &lt;algorithm&gt; // for std::for_each
#include &lt;boost/graph/graph_traits.hpp&gt;
#include &lt;boost/graph/adjacency_list.hpp&gt;
#include &lt;boost/graph/dijkstra_shortest_paths.hpp&gt;
using namespace boost;

int main(int,char*[])
{
    typedef adjacency_list&lt;vecS, vecS, bidirectionalS&gt; Graph;
    // Make convenient labels for the vertices
    enum { A, B, C, D, E, N }; //代表 0 ，1，2，3，4 顶点,其中N为顶点数
    const int num_vertices = N;//N的值是5
    const char* name = "ABCDE";
    //图中的边
    typedef std::pair&lt;int, int&gt; Edge;
    Edge edge_array[] = { Edge(A,B), Edge(A,D), Edge(C,A), Edge(D,C),
                            Edge(C,E), Edge(B,D), Edge(D,E) };
    const int num_edges = sizeof(edge_array)/sizeof(edge_array[0]);
    // 创建一个拥有5个顶点的图对象
    Graph g(num_vertices);
    // 给图对象添加边
    for (int i = 0; i &lt; num_edges; ++i)
      add_edge(edge_array[i].first, edge_array[i].second, g);//其中first表示第一个顶点，second表示第二个顶点，两个顶点连接
   return 0;
}</code></pre> 
<h3> </h3> 
<p>    我们可以使用<strong>图的edge iterator constructor 构造函数</strong>来代替为<span style="color:#cc0000;"><strong>每个边调用add_edge()函数</strong></span>，这种方法</p> 
<p>更具代表性比add_edge()更有效率，<strong>edge_array 指针可以被视为迭代器，</strong>所以我们可以传递<strong><span style="color:#cc0000;">数组开始和结束的指针给图构造函数</span></strong></p> 
<p>Graph g(edge_array, edge_array + sizeof(edge_array) / sizeof(Edge), num_vertices);</p> 
<p>其中edge_array是边集合。同样可以使用 MutableGraph 接口的<strong><span style="color:#cc0000;">add_vertex</span></strong>()和<strong><span style="color:#ff0000;">remove_vertex</span></strong>() 来为图添加和删除顶点，</p> 
<p>而不是一开始就创建一个拥有一定数目顶点的图。</p> 
<h3><a name="t2"></a>访问顶点集合</h3> 
<p><span style="color:#333333;">    现在我们创建了一个图，我们可以使用图接口访问图数据，首先我们可以通过</span><a href="http://www.boost.org/libs/graph/doc/VertexListGraph.html" rel="nofollow">VertexListGraph</a><span style="color:#333333;"> 接口的</span><a href="http://www.boost.org/libs/graph/doc/VertexListGraph.html#sec:vertices" rel="nofollow">vertices()</a><span style="color:#333333;"> 函数来访问图中所有的顶点。</span><span style="color:#333333;"><strong>这个函数返回一个顶点迭代器的std::pair 类型（第一个迭代器指向顶点的开始，第二个迭代器指向顶点的结束）。</strong></span><strong>提领一个顶点迭代器放回一个顶点对象。顶点迭代器的类型可由graph_traits 类取得</strong><span style="color:#333333;">，值得注意的是不同的图类型可能有不同的顶点迭代器类型，这也是为什么我们需要</span><strong><span style="color:#cc0000;">graph_traits 类</span></strong><span style="color:#333333;">的原因。</span><span style="color:#990000;"><strong>给定一个图类型，graph_traits类能提供该图的vertex_iterator类型</strong></span><span style="color:#333333;">，下面的例子打印了</span><span style="color:#cc0000;"><strong>图中每个顶点的索引。所有的顶点和边属性，以及索引，可以通过property_map 对象访问。</strong>property_map 类可用来获得指定属性(通过指定BGL预定义的vertex_index_t来取得索引)的property_map 类型，通过调用函数get(vertex_index, g) 来获得图当前的property_map对象。</span></p> 
<p> </p> 
<pre class="has"><code class="language-cpp">int main(int,char*[])
{
    ......//省略上面代码
    //获得顶点索引的 property map 
    typedef property_map&lt;Graph, vertex_index_t&gt;::type IndexMap;
    IndexMap index = get(vertex_index, g);
 
    std::cout &lt;&lt; "vertices(g) = ";
    typedef graph_traits&lt;Graph&gt;::vertex_iterator vertex_iter;
    std::pair&lt;vertex_iter, vertex_iter&gt; vp;
    for (vp = vertices(g); vp.first != vp.second; ++vp.first)
            std::cout &lt;&lt; index[*vp.first] &lt;&lt; " ";
    std::cout &lt;&lt; std::endl;

    return 0;
}</code></pre> 
<p><span style="color:#333333;">输出结果: </span><br><span style="color:#333333;">vertices(g) = 0 1 2 3 4</span></p> 
<h3><a name="t3"></a>访问边集合</h3> 
<p><span style="color:#333333;">   一个图的边集合可以使用</span><a href="http://www.boost.org/libs/graph/doc/EdgeListGraph.html" rel="nofollow">EdgeListGraph</a><span style="color:#333333;">接口中的 </span><a href="http://www.boost.org/libs/graph/doc/EdgeListGraph.html#sec:edges" rel="nofollow">edges()</a><span style="color:#333333;">函数访问。与vertices() 函数类似，这个函数也返回一对迭代器，但在这里的迭代器是</span><span style="color:#333333;"><strong>边迭代器edge iterators</strong></span><span style="color:#333333;">。</span><span style="color:#cc0000;"><strong>提领边迭代器可以获得一个边对象，调用source()和target()函数可以取得边连接的两个顶点。</strong></span><span style="color:#333333;">这次我们使用tie()辅助函数，而不是为迭代器声明</span><span style="color:#333333;">一个pair类型</span><span style="color:#333333;">，</span><span style="color:#cc0000;"><strong>这个便利的函数可以用来分开std::pair 到两个分离的变量，这里是ei 和 ei_end，这样比创建一个std::pair 类型方便。</strong></span><span style="color:#333333;">这也是我们为BGL选择的方法。</span></p> 
<p> </p> 
<pre class="has"><code class="language-cpp">int main(int,char*[])
{
    .......//省略上文代码
    //获得顶点索引的 property map 
    typedef property_map&lt;Graph, vertex_index_t&gt;::type IndexMap;
    IndexMap index = get(vertex_index, g);

    std::cout &lt;&lt; "edges(g) = ";
    graph_traits&lt;Graph&gt;::edge_iterator ei, ei_end;
    for (tie(ei, ei_end) = edges(g); ei != ei_end; ++ei)
       std::cout &lt;&lt; "(" &lt;&lt; index[source(*ei, g)]&lt;&lt; "," &lt;&lt; index[target(*ei, g)] &lt;&lt; ") ";
    std::cout &lt;&lt; std::endl;

  return 0;
}</code></pre> 
<p>输出结果:<br> edges(g) = (0,1) (0,2) (0,3) (0,4) (2,0) (2,4) (3,0)(3,1) (3,4) (4,0) (4,1)</p> 
<h3><a name="t4"></a>邻接结构</h3> 
<p><span style="color:#333333;">     在下面的例子中我们通过观察一个特殊的顶点来</span><strong><span style="color:#cc0000;">展示图的邻接结构</span></strong><span style="color:#333333;">，我们将看到<strong>顶点的 </strong></span><span style="color:#333333;"><strong>in-edges， out-edges </strong></span><span style="color:#333333;"><strong>以及他的邻接点adjacent vertices</strong>。我们将这些封装到一个"exercise vertex" 函数对象，并针对图的每个顶点调用它。为了示范BGL同STL协作的能力, 我们使用STL的for_each() 函数迭代每个顶点并调用此函数。</span><br><span style="color:#333333;">int main(int,char*[])</span><br><span style="color:#333333;">{<!-- --></span><br><span style="color:#333333;">    std::for_each(vertices(g).first, vertices(g).second, exercise_vertex&lt;Graph&gt;(g));</span><br><span style="color:#333333;">    return 0;</span><br><span style="color:#333333;">}</span><br><span style="color:#333333;"> </span><span style="color:#333333;">  </span><span style="color:#333333;">  当我们访问每个顶点的信息时需要使用到</span><strong><span style="color:#cc0000;">图对象，所以我们把exercise_vertex写成一个函数对象而不是函数</span></strong><span style="color:#333333;">，在std::for_each()执行期间，使用函数对象可以给我们</span><span style="color:#333333;"><strong>提供了一个位置来保持对图对象的引</strong></span><span style="color:#333333;"><strong>用</strong></span><span style="color:#333333;">。为了能够处理不同的图对象，我们将此函数对象模板化。这里是exercise_vertex 函数对象的开始</span><br><span style="color:#333333;">template &lt;class Graph&gt; struct exercise_vertex </span><br><span style="color:#333333;">{<!-- --></span><br><span style="color:#333333;">    exercise_vertex(Graph&amp; g_) : g(g_) {}</span><br><span style="color:#333333;">    Graph&amp; g;</span><br><span style="color:#333333;">};</span></p> 
<h4><a name="t5"></a>顶点描述符</h4> 
<p><span style="color:#333333;">   在撰写</span><strong><span style="color:#cc0000;">函数对象operator()方法</span></strong><span style="color:#333333;">时，我们首先要知道的是图中</span><strong>顶点对象的类型</strong><span style="color:#333333;">。顶点类型用来声明operator()中的参数。确切的说，我们实际上并不处理顶点对象，而是使用顶点描述符</span><strong>vertex_descriptors</strong><span style="color:#333333;">。许多图结构（如邻接表adjacency lists）并不需要存储顶点对象，而另一些存储(例如 pointer-linked graphs)，这些不同将被顶点描述符对象的黑箱操作所隐藏。</span><strong><span style="color:#cc0000;">顶点描述符由图类型提供</span></strong><span style="color:#333333;">，在后面章节将介绍通过</span><span style="color:#cc0000;"><strong>对操作符调用函数</strong><strong>out_edges(), in_edges(), adjacent_vertices()和property_map</strong><strong>来访问图信息</strong></span><span style="color:#333333;">。顶点描述符类型可以通过graph_traits类获得,下面语句中的typename 关键字是必须的，因为在范围操作符::左边(graph_traits&lt;Graph&gt;类型)由模板参数（Graph类型）确定。下面是我们定义的函数对象</span><br><span style="color:#333333;">template &lt;class Graph&gt; struct exercise_vertex</span><br><span style="color:#333333;">{<!-- --></span><br><span style="color:#333333;">    typedef typename graph_traits&lt;Graph&gt;::vertex_descriptor Vertex;</span><br><span style="color:#333333;">    void operator()(const Vertex&amp; v) const</span><br><span style="color:#333333;">    {<!-- --></span><br><span style="color:#333333;">    }</span><br><span style="color:#333333;">};</span></p> 
<h4><a name="t6"></a>Out-Edges, In-Edges, 和Edge 描述符</h4> 
<p><span style="color:#333333;">    可以通过</span><a href="http://www.boost.org/libs/graph/doc/IncidenceGraph.html" rel="nofollow">IncidenceGraph</a><span style="color:#333333;">接口中的</span><a href="http://www.boost.org/libs/graph/doc/IncidenceGraph.html#sec:out-edges" rel="nofollow">out_edges()</a><span style="color:#333333;">函数来访问一个顶点的</span><strong>out-edges</strong><span style="color:#333333;">, 这个函数需要两个参数：</span><strong><span style="color:#cc0000;">第一个参数是顶点，第二个是图对象。</span></strong><span style="color:#333333;">函数返回一对迭代器，来提供对一个顶点所有out-edges的访问（与vertices()函数返回pair对象类似）。这些迭代器称为out-edge iterators， 提领这些迭代器将返回一个边描述符对象，<strong>边描述符</strong>跟顶点描述符扮演类似性质的角色，也是图类型提供的黑盒，后面的代码片断按source-target顺序打印了顶点v对应的每个out-edge边上的两个点。</span><br><span style="color:#333333;">template &lt;class Graph&gt; struct exercise_vertex </span><br><span style="color:#333333;">{<!-- --></span><br><span style="color:#333333;">    void operator()(const Vertex&amp; v) const</span><br><span style="color:#333333;">    {<!-- --></span><br><span style="color:#333333;">         //...... </span><br><span style="color:#333333;">        typedef graph_traits&lt;Graph&gt; GraphTraits;</span><br><span style="color:#333333;">        typename property_map&lt;Graph, vertex_index_t&gt;::type </span><br><span style="color:#333333;">        index = get(vertex_index, g);</span><br><br><span style="color:#333333;">        std::cout &lt;&lt; "out-edges: ";</span><br><span style="color:#333333;">        typename GraphTraits::out_edge_iterator out_i, out_end;</span><br><span style="color:#333333;">        typename GraphTraits::edge_descriptor e;</span><br><span style="color:#333333;">        for (tie(out_i, out_end) = out_edges(v, g);out_i != out_end; ++out_i) </span><br><span style="color:#333333;">        {<!-- --></span><br><span style="color:#333333;">            e = *out_i;</span><br><span style="color:#333333;">            Vertex src = source(e, g), targ = target(e, g);</span><br><span style="color:#333333;">            std::cout &lt;&lt; "(" &lt;&lt; index[src] &lt;&lt; "," &lt;&lt; index[targ] &lt;&lt; ") ";</span><br><span style="color:#333333;">        }</span><br><span style="color:#333333;">        std::cout &lt;&lt; std::endl;</span><br><span style="color:#333333;">    }</span><br><span style="color:#333333;">};</span><br><span style="color:#333333;">对于顶点0 输出结果是: </span><br><span style="color:#333333;">out-edges: (0,1) (0,2) (0,3) (0,4)</span></p> 
<p><span style="color:#333333;">     </span><a href="http://www.boost.org/libs/graph/doc/BidirectionalGraph.html#sec:in-edges" rel="nofollow">in_edges()</a><span style="color:#333333;">  函数位于</span><a href="http://www.boost.org/libs/graph/doc/BidirectionalGraph.html" rel="nofollow">BidirectionalGraph</a><span style="color:#333333;">接口中，此函数可以通过</span><strong><span style="color:#cc0000;">in-edge迭代器访问一个顶点所有的in-edges</span></strong><span style="color:#333333;">。 只有当邻接表的Directed(第三个)模板参数设为bidirectionalS 才能使用此函数。而指定bidirectionalS代替directedS时将会花费更多的空间。</span><br><span style="color:#333333;">template &lt;class Graph&gt; struct exercise_vertex </span><br><span style="color:#333333;">{<!-- --></span><br><span style="color:#333333;">    void operator()(const Vertex&amp; v) const</span><br><span style="color:#333333;">    {<!-- --></span><br><span style="color:#333333;">        //....... 省略与上面重复代码</span><br><span style="color:#333333;">        std::cout &lt;&lt; "in-edges: ";</span><br><span style="color:#333333;">        typedef typename graph_traits&lt;Graph&gt; GraphTraits;</span><br><span style="color:#333333;">        typename GraphTraits::in_edge_iterator in_i, in_end;</span><br><span style="color:#333333;">        for (tie(in_i, in_end) = in_edges(v,g); in_i != in_end; ++in_i) </span><br><span style="color:#333333;">        {<!-- --></span><br><span style="color:#333333;">            e = *in_i;</span><br><span style="color:#333333;">            Vertex src = source(e, g), targ = target(e, g);</span><br><span style="color:#333333;">            std::cout &lt;&lt; "(" &lt;&lt; index[src] &lt;&lt; "," &lt;&lt; index[targ] &lt;&lt; ") ";</span><br><span style="color:#333333;">        }</span><br><span style="color:#333333;">        std::cout &lt;&lt; std::endl;</span><br><span style="color:#333333;">    }</span><br><span style="color:#333333;">};</span><br><span style="color:#333333;">对于顶点 0 输出是: </span><br><span style="color:#333333;">in-edges: (2,0) (3,0) (4,0)</span></p> 
<h4><a name="t7"></a>邻接点</h4> 
<p>   当给出一个顶点的所有的out-edges边时，这些边上的目标点对于源点邻接。<strong>有时一个算法不需要关注一个图的边，而是仅关心顶点</strong>。因此图形接口AdjacencyGraph 提供了<strong>adjacent_vertices()函数来直接访问邻接点</strong>。此函数返回一对adjacency iterators ，提领一个邻接点迭代器将会得到领接顶点的顶点描述符。<br> template &lt;class Graph&gt; struct exercise_vertex <br> {<!-- --><br>     void operator()(Vertex v) const<br>     {<!-- --><br>         //.......<br>         std::cout &lt;&lt; "adjacent vertices: ";<br>         typename graph_traits&lt;Graph&gt;::adjacency_iterator ai;<br>         typename graph_traits&lt;Graph&gt;::adjacency_iterator ai_end;<br>         for (tie(ai, ai_end) = adjacent_vertices(v, g);ai != ai_end; ++ai)<br>                std::cout &lt;&lt; index[*ai] &lt;&lt; " ";<br>         std::cout &lt;&lt; std::endl;<br>     }<br> };</p> 
<h3><a name="t8"></a>给你的图添加一些颜色</h3> 
<p><span style="color:#333333;">   BGL实现尽可能灵活地适应</span><strong><span style="color:#cc0000;">图的附加属性</span></strong><span style="color:#333333;">，举个例子，属性如边的权重存在于在图对象的整个生命周期都，因此让图对象管理这个属性的存储将会带来很多便利；另外，<strong>属性如顶点颜色</strong>只在某个算法的运行期内需要，将此</span><span style="color:#cc0000;">属性和图对象分开存储</span><span style="color:#333333;">将会更好。<strong>第一种属性称为内在存储属性，而第二种称为外在存储属性。</strong>BGL 在图算法中为两种属性提供了一致的访问接口property_map，此接口在章节</span><a href="http://www.boost.org/libs/graph/doc/property_map.html" rel="nofollow">Property Map Concepts</a><span style="color:#333333;">中有详细描述。另外，</span><a href="http://www.boost.org/libs/graph/doc/PropertyGraph.html" rel="nofollow">PropertyGraph</a><span style="color:#333333;"> 配接器也为获得一个内在存储属性的property map 对象定义了接口</span><br><br><span style="color:#333333;">    BGL 邻接表类允许用户通过设置图对象模版参数来指定内在存储属性，如何实现这些在</span>Internal Properties<span style="color:#333333;"> 章节有详细论述。外在存储属性有多种创建方法，尽管他们基本上作为<strong>分离参数传递给图算法</strong>。一个简单存储外在属性的办法是通过顶点或边的索引来创建一个索引数组。如邻接表中的VertexList模版参数指定为vecS，每个顶点的索引将会自动建立。通过指定vertex_index_t作为模版参数的property map对象来访问这些索引。每个边虽不能自动建立索引。但是可以通过使用属性机制把索引和边联系起来，来索引其他的外在存储属性。</span></p> 
<p>   在下面的例子中，我们创建一个图并执行dijkstra_shortest_paths()算法，完整的源代码在例子examples/dijkstra-example.cpp中。<strong>Dijkstra 算法用来计算从起始顶点到其他顶点的最短路径</strong>。Dijkstra 算法要求设置每个边的权重和每个顶点的距离，这里我们<strong>把权重做为一个内在属性，距离作为外在属性。</strong>对于权重属性，我们创建属性类并指定int 作为权重类型，edge_weight_t 作为属性标记(一个BGL预定义的属性标记)。此权重属性类将作为邻接表adjacency_list 的一个模版参数</p> 
<p>   选择listS或者vecS类型取决于我要在邻接表中使用的数据结构(可以看 Choosing the Edgelist and VertexList章节)。<strong>directedS 类型</strong>指定图为有向图（相对的是无向图）。后面的代码展示了一个图类型的声明和初始化，以及带权重属性的边如何传递给（使用迭代器作为参数的）图构造函数（要求随机迭代器）<br> typedef adjacency_list&lt;listS, vecS, directedS, <br> no_property, property&lt;edge_weight_t, int&gt; &gt; Graph;<br> typedef graph_traits&lt;Graph&gt;::vertex_descriptor Vertex;<br> typedef std::pair&lt;int,int&gt; E;<br><br> const int num_nodes = 5;<br> E edges[] = { E(0,2), <br> E(1,1), E(1,3), E(1,4),<br> E(2,1), E(2,3), <br> E(3,4),<br> E(4,0), E(4,1) };<br> int weights[] = { 1, 2, 1, 2, 7, 3, 1, 1, 1};<br> Graph G(edges + sizeof(edges) / sizeof(E), weights, num_nodes);</p> 
<p>   对于外部距离属性，我们使用std::vector 来存储， BGL 算法视随机迭代器为<strong>property_maps</strong>。所以我们能够传递<strong>距离数组vector迭代器到Dijkstra's 算法</strong>。紧接上面的例子，下面的代码创建了一个distance vector, 然后调用Dijkstra's 算法(内部使用了权重属性)，输出结果:<br> // vector for storing distance property<br> std::vector&lt;int&gt; d(num_vertices(G));<br> // get the first vertex<br> Vertex s = *(vertices(G).first);<br> // invoke variant 2 of Dijkstra's algorithm<br> dijkstra_shortest_paths(G, s, distance_map(&amp;d[0]));<br><br> std::cout &lt;&lt; "distances from start vertex:" &lt;&lt; std::endl;<br> graph_traits&lt;Graph&gt;::vertex_iterator vi;<br> for(vi = vertices(G).first; vi != vertices(G).second; ++vi)<br> std::cout &lt;&lt; "distance(" &lt;&lt; index(*vi) &lt;&lt; ") = " <br> &lt;&lt; d[*vi] &lt;&lt; std::endl;<br> std::cout &lt;&lt; std::endl;<br><br> 结果是:<br> distances from start vertex:<br> distance(0) = 0<br> distance(1) = 6<br> distance(2) = 1<br> distance(3) = 4<br> distance(4) = 5</p> 
<h3><a name="t9"></a>使用Visitors扩充图算法</h3> 
<p>   通常一个库中的算法能够满足你大部分的需求，但事无绝对，例如在前面的章节中，我们使用Dijkstra's 算法来计算到每个顶点的最短路径，但可能我们想记录路径最短的树，可以通过在记录最短路径树中记录每个节点的前驱来实现。<br>     当然我们最好能够避免重写Dijkstra's 算法，并且只增加记录前辈节点的额外需求<a href="https://blog.csdn.net/delphihero/article/details/752765#%E6%B3%A8%E6%84%8F">[1]</a>，在STL中，可以使用仿函数作为算法的可选参数来提供这种伸缩性。在BGL中，visitors 扮演着类似的角色。Visitor 类似stl仿函数。仿函数只有一个执行函数，但Visitor 拥有更多的方法，每个方法将在明确定义的算法点被调用。Visitor 函数在Visitor Concepts章节有详细说明。BGL 为通常的任务提供了几种visitor，包括记录前驱节点的visitor。作为扩充BGL的一种方法鼓励用户写自己的visitor。这里我们将迅速浏览实现和使用前驱记录，由于我们使用dijkstra_shortest_paths()算法，所以我们创建的visitor也必须是一个Dijkstra Visitor。record_predecessors visitor 的泛函性分成两部分。我们使用一个property map来存储和访问前驱属性。前驱 visitor 只负责记录前驱节点。为了实现这些，我们创建一个使用模版参数的record_predecessors类。由于这个visitor将在一个visitor方法中被填充，我们从一个提供空方法的dijkstra_visitor类继承。predecessor_recorder 类的构造函数将接受一个property map 对象，并把他保存在数据成员中。</p> 
<p>template &lt;class PredecessorMap&gt;<br> class record_predecessors : public dijkstra_visitor&lt;&gt;<br> {<!-- --><br> public:<br> record_predecessors(PredecessorMap p)<br> : m_predecessor(p) { }<br><br> template &lt;class Edge, class Graph&gt;<br> void edge_relaxed(Edge e, Graph&amp; g) {<!-- --><br> // set the parent of the target(e) to source(e)<br> put(m_predecessor, target(e, g), source(e, g));<br> }<br> protected:<br> PredecessorMap m_predecessor;<br> };<br>     记录前驱节点的工作十分简单，当Dijkstra's algorithm算法释放一个边的时候（添加他到最短路径树中） 我们记录源顶点作为目标顶点的前驱。稍后，如果边再次释放前驱属性将被新的前驱重写，这里我们使用put() 函数在property map中记录前驱。Visitor的edge_filter将告诉算法什么时候调用explore()方法。我们希望边在最短路径树中被通知，所以我们指定tree_edge_tag标记。最后，我们创建一个辅助函数来更方便的创建predecessor visitors，所有的BGL visitor 都有一个类似的辅助函数。  <br> template &lt;class PredecessorMap&gt; record_predecessors&lt;PredecessorMap&gt;<br> make_predecessor_recorder(PredecessorMap p) <br> {<!-- --><br>     return record_predecessors&lt;PredecessorMap&gt;(p);<br> }<br>    现在我们准备在Dijkstra's 算法中使用record_predecessors。BGL 的Dijkstra's 算法配备了一个vistitors句柄，所以我们只需要传入我们新的visitor即可。 在这个例子中我们只需要使用1个visitor，尽管BGL在算法中配置了多visitors句柄参数？？(参见Visitor Concepts章).<br> using std::vector;<br> using std::cout;<br> using std::endl;<br> vector&lt;Vertex&gt; p(num_vertices(G)); //the predecessor 数组<br> dijkstra_shortest_paths(G, s, distance_map(&amp;d[0]). <br> visitor(make_predecessor_recorder(&amp;p[0])));<br><br> cout &lt;&lt; "parents in the tree of shortest paths:" &lt;&lt; endl;<br> for(vi = vertices(G).first; vi != vertices(G).second; ++vi) {<!-- --><br> cout &lt;&lt; "parent(" &lt;&lt; *vi;<br> if (p[*vi] == Vertex())<br> cout &lt;&lt; ") = no parent" &lt;&lt; endl; <br> else <br> cout &lt;&lt; ") = " &lt;&lt; p[*vi] &lt;&lt; endl;<br> }<br> 输出结果: <br> parents in the tree of shortest paths:<br> parent(0) = no parent<br> parent(1) = 4<br> parent(2) = 0<br> parent(3) = 2<br> parent(4) = 3</p> 
<p><a name="%E6%B3%A8%E6%84%8F"></a>注意:<br> 新版本Dijkstra's algorithm包括了一个用来记录前驱的指定参数，所以前驱visitor 并不需要。但上面仍不失为一个好的例子。</p> 
<p> </p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8c939f79f3c58106fdf16917a1e716f9/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">程序员们，只需三步，教你搭建一个区块链程序 | 经典好文</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/2abd06ebca4bac3be874d6e65eca3fc0/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">linux初学者的学习路径</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>