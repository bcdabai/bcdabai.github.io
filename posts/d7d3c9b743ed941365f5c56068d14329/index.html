<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Zookeeper集群搭建，四字命令监控，Leader选举原理以及数据如何同步 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Zookeeper集群搭建，四字命令监控，Leader选举原理以及数据如何同步" />
<meta property="og:description" content="Java学习&#43;面试指南：https://javaxiaobear.cn
1、集群角色 Leader： 领导者。 事务请求（写操作）的唯一调度者和处理者，保证集群事务处理的顺序性；集群内部各个服务器的调度者。对于create、setData、delete等有写操作的请求，则要统一转发给leader处理，leader需要决定编号、执行操作，这个过程称为事务。
Follower: 跟随者 处理客户端非事务（读操作）请求（可以直接响应），转发事务请求给Leader；参与集群Leader选举投票。
Observer: 观察者 对于非事务请求可以独立处理（读操作），对于事务性请求会转发给leader处理。Observer节点接收来自leader的inform信息，更新自己的本地存储，不参与提交和选举投票。通常在不影响集群事务处理能力的前提下提升集群的非事务处理能力。
Observer应用场景：
提升集群的读性能。因为Observer和不参与提交和选举的投票过程，所以可以通过往集群里面添加observer节点来提高整个集群的读性能。
跨数据中心部署。 比如需要部署一个北京和香港两地都可以使用的zookeeper集群服务，并且要求北京和香港客户的读请求延迟都很低。解决方案就是把香港的节点都设置为observer。
2、集群架构 leader节点可以处理读写请求，follower只可以处理读请求。follower在接到写请求时会把写请求转发给leader来处理。
Zookeeper数据一致性保证：
全局可线性化(Linearizable )写入∶先到达leader的写请求会被先处理，leader决定写请求的执行顺序。
客户端FIFO顺序∶来自给定客户端的请求按照发送顺序执行。
3、三节点Zookeeper集群搭建 环境准备：三台虚拟机
192.168.65.156 192.168.65.190 192.168.65.200 条件有限也可以在一台虚拟机上搭建zookeeper伪集群
1) 修改zoo.cfg配置，添加server节点配置
# 修改数据存储目录 dataDir=/data/zookeeper #三台虚拟机 zoo.cfg 文件末尾添加配置 server.1=192.168.65.156:2888:3888 server.2=192.168.65.190:2888:3888 server.3=192.168.65.200:2888:3888 server.A=B:C:D
A 是一个数字，表示这个是第几号服务器； 集群模式下配置一个文件 myid，这个文件在 dataDir 目录下，这个文件里面有一个数据 就是 A 的值，Zookeeper 启动时读取此文件，拿到里面的数据与 zoo.cfg 里面的配置信息比较从而判断到底是哪个server。
B 是这个服务器的地址；
C 是这个服务器Follower与集群中的Leader服务器交换信息的端口；
D 是万一集群中的Leader服务器挂了，需要一个端口来重新进行选举，选出一个新的Leader，而这个端口就是用来执行选举时服务器相互通信的端口。
2）创建 myid 文件，配置服务器编号
在dataDir对应目录下创建 myid 文件，内容为对应ip的zookeeper服务器编号
cd /data/zookeeper # 在文件中添加与 server 对应的编号（注意：上下不要有空行，左右不要有空格） vim myid 3）启动zookeeper server集群" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/d7d3c9b743ed941365f5c56068d14329/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-22T14:19:36+08:00" />
<meta property="article:modified_time" content="2023-12-22T14:19:36+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Zookeeper集群搭建，四字命令监控，Leader选举原理以及数据如何同步</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-dracula">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>Java学习+面试指南：https://javaxiaobear.cn</p> 
<h3><a id="1_1"></a>1、集群角色</h3> 
<ul><li>Leader： 领导者。</li></ul> 
<p>事务请求（写操作）的唯一调度者和处理者，保证集群事务处理的顺序性；集群内部各个服务器的调度者。对于create、setData、delete等有写操作的请求，则要统一转发给leader处理，leader需要决定编号、执行操作，这个过程称为事务。</p> 
<ul><li>Follower: 跟随者</li></ul> 
<p>处理客户端非事务（读操作）请求（可以直接响应），转发事务请求给Leader；参与集群Leader选举投票。</p> 
<ul><li>Observer: 观察者</li></ul> 
<p>对于非事务请求可以独立处理（读操作），对于事务性请求会转发给leader处理。Observer节点接收来自leader的inform信息，更新自己的本地存储，不参与提交和选举投票。通常在不影响集群事务处理能力的前提下提升集群的非事务处理能力。</p> 
<p>Observer应用场景：</p> 
<ul><li> <p>提升集群的读性能。因为Observer和不参与提交和选举的投票过程，所以可以通过往集群里面添加observer节点来提高整个集群的读性能。</p> </li><li> <p>跨数据中心部署。 比如需要部署一个北京和香港两地都可以使用的zookeeper集群服务，并且要求北京和香港客户的读请求延迟都很低。解决方案就是把香港的节点都设置为observer。</p> </li></ul> 
<h3><a id="2_21"></a>2、集群架构</h3> 
<p><img src="https://images2.imgbox.com/36/d7/hK5QBCI4_o.png" alt="image-20231215161411987"></p> 
<p>leader节点可以处理读写请求，follower只可以处理读请求。follower在接到写请求时会把写请求转发给leader来处理。</p> 
<p>Zookeeper数据一致性保证：</p> 
<ul><li> <p>全局可线性化(Linearizable )写入∶先到达leader的写请求会被先处理，leader决定写请求的执行顺序。</p> </li><li> <p>客户端FIFO顺序∶来自给定客户端的请求按照发送顺序执行。</p> </li></ul> 
<h3><a id="3Zookeeper_33"></a>3、三节点Zookeeper集群搭建</h3> 
<p>环境准备：三台虚拟机</p> 
<pre><code>192.168.65.156
192.168.65.190
192.168.65.200
</code></pre> 
<p>条件有限也可以在一台虚拟机上搭建zookeeper伪集群</p> 
<p><strong>1) 修改zoo.cfg配置，添加server节点配置</strong></p> 
<pre><code># 修改数据存储目录
dataDir=/data/zookeeper
 
#三台虚拟机 zoo.cfg 文件末尾添加配置
server.1=192.168.65.156:2888:3888
server.2=192.168.65.190:2888:3888
server.3=192.168.65.200:2888:3888
</code></pre> 
<p>server.A=B:C:D</p> 
<p>A 是一个数字，表示这个是第几号服务器； 集群模式下配置一个文件 myid，这个文件在 dataDir 目录下，这个文件里面有一个数据 就是 A 的值，Zookeeper 启动时读取此文件，拿到里面的数据与 zoo.cfg 里面的配置信息比较从而判断到底是哪个server。</p> 
<p>B 是这个服务器的地址；</p> 
<p>C 是这个服务器Follower与集群中的Leader服务器交换信息的端口；</p> 
<p>D 是万一集群中的Leader服务器挂了，需要一个端口来重新进行选举，选出一个新的Leader，而这个端口就是用来执行选举时服务器相互通信的端口。</p> 
<p><strong>2）创建 myid 文件，配置服务器编号</strong></p> 
<p>在dataDir对应目录下创建 myid 文件，内容为对应ip的zookeeper服务器编号</p> 
<pre><code>cd /data/zookeeper
# 在文件中添加与 server 对应的编号（注意：上下不要有空行，左右不要有空格）
vim myid
</code></pre> 
<p><img src="https://images2.imgbox.com/14/73/PYDrw74G_o.png" alt="image-20231215162055188"></p> 
<p><strong>3）启动zookeeper server集群</strong></p> 
<p>启动前需要关闭防火墙(生产环境需要打开对应端口)</p> 
<pre><code># 分别启动三个节点的zookeeper server
bin/zkServer.sh start
# 查看集群状态
bin/zkServer.sh status
</code></pre> 
<p><img src="https://images2.imgbox.com/34/06/s4mEoFw2_o.png" alt="image-20231215162108403"></p> 
<h3><a id="4Zookeeper_92"></a>4、Zookeeper四字命令</h3> 
<p>用户可以使用<strong>Zookeeper四字命令</strong>获取 zookeeper 服务的当前状态及相关信息</p> 
<p>zookeeper 支持某些特定的四字命令与其交互，用户获取 zookeeper 服务的当前状态及相关信息，用户在客户端可以通过 telenet 或者 nc（netcat） 向 zookeeper 提交相应的命令。</p> 
<p>安装 nc 命令：</p> 
<pre><code># centos
yum install nc                
</code></pre> 
<p>四字命令格式：</p> 
<pre><code>echo [command] | nc [ip] [port]
</code></pre> 
<p>ZooKeeper 常用四字命令主要如下：</p> 
<table><thead><tr><th>四字命令</th><th>功能描述</th></tr></thead><tbody><tr><td>conf</td><td>3.3.0版本引入的。打印出服务相关配置的详细信息。</td></tr><tr><td>cons</td><td>3.3.0版本引入的。列出所有连接到这台服务器的客户端全部连接/会话详细信息。包括"接受/发送"的包数量、会话id、操作延迟、最后的操作执行等等信息。</td></tr><tr><td>crst</td><td>3.3.0版本引入的。重置所有连接的连接和会话统计信息。</td></tr><tr><td>dump</td><td>列出那些比较重要的会话和临时节点。这个命令只能在leader节点上有用。</td></tr><tr><td>envi</td><td>打印出服务环境的详细信息。</td></tr><tr><td>reqs</td><td>列出未经处理的请求</td></tr><tr><td>ruok</td><td>测试服务是否处于正确状态。如果确实如此，那么服务返回"imok"，否则不做任何相应。</td></tr><tr><td>stat</td><td>输出关于性能和连接的客户端的列表。</td></tr><tr><td>srst</td><td>重置服务器的统计。</td></tr><tr><td>srvr</td><td>3.3.0版本引入的。列出连接服务器的详细信息</td></tr><tr><td>wchs</td><td>3.3.0版本引入的。列出服务器watch的详细信息。</td></tr><tr><td>wchc</td><td>3.3.0版本引入的。通过session列出服务器watch的详细信息，它的输出是一个与watch相关的会话的列表。</td></tr><tr><td>wchp</td><td>3.3.0版本引入的。通过路径列出服务器watch的详细信息。它输出一个与session相关的路径。</td></tr><tr><td>mntr</td><td>3.4.0版本引入的。输出可用于检测集群健康状态的变量列表</td></tr></tbody></table> 
<p>https://zookeeper.apache.org/doc/current/zookeeperAdmin.html#sc_4lw</p> 
<p><strong>开启四字命令</strong></p> 
<p>方法1： 在zoo.cfg 文件里加入配置项让这些指令放行</p> 
<pre><code>#开启四字命令
4lw.commands.whitelist=*
</code></pre> 
<p>方法2：在zk的启动脚本zkServer.sh中新增放行指令</p> 
<pre><code>#添加ＶＭ环境变量-Dzookeeper.4lw.commands.whitelist=*
ZOOMAIN="-Dzookeeper.4lw.commands.whitelist=* ${ZOOMAIN}"
</code></pre> 
<p><strong>stat 命令</strong></p> 
<p>stat 命令用于查看 zk 的状态信息，实例如下：</p> 
<pre><code>$ echo stat | nc 192.168.65.156 2181
</code></pre> 
<h3><a id="5Zookeeper_Leader__162"></a>5、Zookeeper Leader 选举原理</h3> 
<p>zookeeper 的 leader 选举存在两个阶段，一个是服务器启动时 leader 选举，另一个是运行过程中 leader 服务器宕机。</p> 
<p>在分析选举原理前，先介绍几个重要的参数：</p> 
<ul><li> <p>服务器 ID(myid)：编号越大在选举算法中权重越大</p> </li><li> <p>事务 ID(zxid)：值越大说明数据越新，权重越大</p> </li><li> <p>逻辑时钟(epoch-logicalclock)：同一轮投票过程中的逻辑时钟值是相同的，每投完一次值会增加</p> </li></ul> 
<p>选举状态：</p> 
<ul><li> <p>LOOKING: 竞选状态</p> </li><li> <p>FOLLOWING: 随从状态，同步 leader 状态，参与投票</p> </li><li> <p>OBSERVING: 观察状态，同步 leader 状态，不参与投票</p> </li><li> <p>LEADING: 领导者状态</p> </li></ul> 
<h4><a id="1_leader__184"></a>1、服务器启动时的 leader 选举</h4> 
<p>每个节点启动的时候都 LOOKING 观望状态，接下来就开始进行选举主流程。这里选取三台机器组成的集群为例。第一台服务器 server1启动时，无法进行 leader 选举，当第二台服务器 server2 启动时，两台机器可以相互通信，进入 leader 选举过程。</p> 
<ol><li> <p>每台 server 发出一个投票，由于是初始情况，server1 和 server2 都将自己作为 leader 服务器进行投票，每次投票包含所推举的服务器myid、zxid、epoch，使用（myid，zxid）表示，此时 server1 投票为（1,0），server2 投票为（2,0），然后将各自投票发送给集群中其他机器。</p> </li><li> <p>接收来自各个服务器的投票。集群中的每个服务器收到投票后，首先判断该投票的有效性，如检查是否是本轮投票（epoch）、是否来自 LOOKING 状态的服务器。</p> </li><li> <p>分别处理投票。针对每一次投票，服务器都需要将其他服务器的投票和自己的投票进行对比，对比规则如下：</p> 
  <ol><li>优先比较 epoch</li><li>检查 zxid，zxid 比较大的服务器优先作为 leader</li><li>果 zxid 相同，那么就比较 myid，myid 较大的服务器作为 leader 服务器</li></ol> </li><li> <p>统计投票。每次投票后，服务器统计投票信息，判断是都有过半机器接收到相同的投票信息。server1、server2 都统计出集群中有两台机器接受了（2,0）的投票信息，此时已经选出了 server2 为 leader 节点。</p> </li><li> <p>改变服务器状态。一旦确定了 leader，每个服务器响应更新自己的状态，如果是 follower，那么就变更为 FOLLOWING，如果是 Leader，变更为 LEADING。此时 server3继续启动，直接加入变更自己为 FOLLOWING。</p> </li></ol> 
<img src="https://images2.imgbox.com/51/15/GAqYFJkG_o.png" alt="image-20231215162331686"> 
<h4><a id="2_leader__201"></a>2、运行过程中的 leader 选举</h4> 
<p>当集群中 leader 服务器出现宕机或者不可用情况时，整个集群无法对外提供服务，进入新一轮的 leader 选举。</p> 
<ol><li>变更状态。leader 挂后，其他非 Oberver服务器将自身服务器状态变更为 LOOKING。</li><li>每个 server 发出一个投票。在运行期间，每个服务器上 zxid 可能不同。</li><li>处理投票。规则同启动过程。</li><li>统计投票。与启动过程相同。</li><li>改变服务器状态。与启动过程相同。</li></ol> 
<h3><a id="6Zookeeper__213"></a>6、Zookeeper 数据同步流程</h3> 
<p>在 Zookeeper 中，主要依赖 ZAB 协议来实现分布式数据一致性。</p> 
<p>ZAB 协议分为两部分：</p> 
<ul><li> <p>消息广播</p> </li><li> <p>崩溃恢复</p> </li></ul> 
<h4><a id="1_223"></a>1、消息广播</h4> 
<p>Zookeeper 使用单一的主进程 Leader 来接收和处理客户端所有事务请求，并采用 ZAB 协议的原子广播协议，将事务请求以 Proposal 提议广播到所有 Follower 节点，当集群中有过半的Follower 服务器进行正确的 ACK 反馈，那么Leader就会再次向所有的 Follower 服务器发送commit 消息，将此次提案进行提交。这个过程可以简称为 2pc 事务提交，整个流程可以参考下图，注意 Observer 节点只负责同步 Leader 数据，不参与 2PC 数据同步过程。</p> 
<p><img src="https://images2.imgbox.com/00/65/QsJvzhe7_o.png" alt="image-20231215164128483"></p> 
<h4><a id="2_229"></a>2、崩溃恢复</h4> 
<p>在正常情况消息下广播能运行良好，但是一旦 Leader 服务器出现崩溃，或者由于网络原理导致 Leader 服务器失去了与过半 Follower 的通信，那么就会进入崩溃恢复模式，需要选举出一个新的 Leader 服务器。在这个过程中可能会出现两种数据不一致性的隐患，需要 ZAB 协议的特性进行避免。</p> 
<ul><li> <p>Leader 服务器将消息 commit 发出后，立即崩溃</p> </li><li> <p>Leader 服务器刚提出 proposal 后，立即崩溃</p> </li></ul> 
<p>ZAB 协议的恢复模式使用了以下策略：</p> 
<ul><li> <p>选举 zxid 最大的节点作为新的 leader</p> </li><li> <p>新 leader 将事务日志中尚未提交的消息进行处理</p> </li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/62ac0c7bee2b28af769d405a9ca63248/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Node.js实现导出图片至Excel</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c86784f55576965b1e621531e093e4cd/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">信息光学·苏显渝 第二版 | 习题 | 第一章 线性系统分析</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>