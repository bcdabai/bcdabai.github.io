<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>NWERC 2015 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="NWERC 2015" />
<meta property="og:description" content="2015-2016 Northwestern European Regional Contest (NWERC 2015) F H没做
似乎只有 B 题有点意思
D：数论分块枚举所有上取整区间，只需要对于所有下取整的区间，取在右端点处的上取整的值即可。这些值是所有上取整区间的左端点。
B 题意：有 n 个区间，分成 p 组，每组的权值是所有区间交的长度，交不能是 0 。求权值和最大。保证有解。 \(n,p \le 200\)
key：思路，dp
对于每一组，限制区间交的长度的区间至多是 2 个（认为 {[1,3],[2,4],[2,3]} 只有 [2,3] 限制）。考虑一个分组方案，定义这种区间是好的，其他区间（即不限制它所在组的权值）是坏的。
显然为了使权值最大，每个区间都趋向于成为坏的。
限制该组权值的区间只有 1 个。此时其他区间一定都包含它。限制该组权值的区间有 2 个。取其中一个为 a，那么 a 一定不包含任何其它区间，因为如果它包含其它区间，那么它可以分配到它包含的某个区间所对应的组，成为一个坏的，此时会使答案更大。 所以对于一个包含其它区间的区间，它要么被分配到它包含的某个区间的组内（此时不影响答案），要么单独成为一组（成为第一类），所以可以按这个性质进行分类。
具体地说，先把给定的 n 个区间划分为两类：如果该区间不包含任何其它区间，分到 A 类。否则分到 B 类。
A 类中的区间没有包含关系，所以排序后的分组一定是一段段区间，这个可以 DP （甚至因为决策单调性可以做到 \(O(n^2)\)）
B 类中的区间要么单独成组，要么不影响答案，所以只需要排序取长度前若干大即可。
#include&lt;bits/stdc&#43;&#43;.h&gt; using namespace std; typedef long long LL; typedef long double LD; typedef pair&lt;int,int&gt; pii; typedef pair&lt;LL,int&gt; pli; const int SZ = 1e6 &#43; 10; const int INF = 1e9 &#43; 10; const int mod = 1e9 &#43; 7; const LD eps = 1e-8; LL read() { LL n = 0; char a = getchar(); bool flag = 0; while(a &gt; &#39;9&#39; || a &lt; &#39;0&#39;) { if(a == &#39;-&#39;) flag = 1; a = getchar(); } while(a &lt;= &#39;9&#39; &amp;&amp; a &gt;= &#39;0&#39;) { n = n * 10 &#43; a - &#39;0&#39;,a = getchar(); } if(flag) n = -n; return n; } struct haha { int l,r; }a[SZ]; bool cmplen(haha a,haha b) { return a." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/b582441658e1f4b84cbf27512fb01a44/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-08-14T02:29:00+08:00" />
<meta property="article:modified_time" content="2019-08-14T02:29:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">NWERC 2015</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown"> 
 <h3 id="northwestern-european-regional-contest-nwerc-2015"><a href="https://codeforces.com/gym/101485" rel="nofollow">2015-2016 Northwestern European Regional Contest (NWERC 2015)</a></h3> 
 <p>F H没做</p> 
 <p>似乎只有 B 题有点意思</p> 
 <p>D：数论分块枚举所有上取整区间，只需要对于所有下取整的区间，取在右端点处的上取整的值即可。这些值是所有上取整区间的左端点。</p> 
 <h4 id="b">B</h4> 
 <p>题意：有 n 个区间，分成 p 组，每组的权值是所有区间交的长度，交不能是 0 。求权值和最大。保证有解。 <span class="math inline">\(n,p \le 200\)</span></p> 
 <p>key：思路，dp</p> 
 <p>对于每一组，限制区间交的长度的区间至多是 2 个（认为 {[1,3],[2,4],[2,3]} 只有 [2,3] 限制）。考虑一个分组方案，定义这种区间是好的，其他区间（即不限制它所在组的权值）是坏的。</p> 
 <p>显然为了使权值最大，每个区间都趋向于成为坏的。</p> 
 <ol><li>限制该组权值的区间只有 1 个。此时其他区间一定都包含它。</li><li>限制该组权值的区间有 2 个。取其中一个为 a，那么 a 一定不包含任何其它区间，因为如果它包含其它区间，那么它可以分配到它包含的某个区间所对应的组，成为一个坏的，此时会使答案更大。</li></ol> 
 <p>所以对于一个包含其它区间的区间，它要么被分配到它包含的某个区间的组内（此时不影响答案），要么单独成为一组（成为第一类），所以可以按这个性质进行分类。</p> 
 <p>具体地说，先把给定的 n 个区间划分为两类：如果该区间不包含任何其它区间，分到 A 类。否则分到 B 类。</p> 
 <p>A 类中的区间没有包含关系，所以排序后的分组一定是一段段区间，这个可以 DP （甚至因为决策单调性可以做到 <span class="math inline">\(O(n^2)\)</span>）</p> 
 <p>B 类中的区间要么单独成组，要么不影响答案，所以只需要排序取长度前若干大即可。</p> 
 <pre><code class="language-cpp"><code>#include&lt;bits/stdc++.h&gt;
using namespace std;

typedef long long LL;
typedef long double LD;
typedef pair&lt;int,int&gt; pii;
typedef pair&lt;LL,int&gt; pli;
const int SZ = 1e6 + 10;
const int INF = 1e9 + 10;
const int mod = 1e9 + 7;
const LD eps = 1e-8;

LL read() {
    LL n = 0;
    char a = getchar();
    bool flag = 0;
    while(a &gt; '9' || a &lt; '0') { if(a == '-') flag = 1; a = getchar(); }
    while(a &lt;= '9' &amp;&amp; a &gt;= '0') { n = n * 10 + a - '0',a = getchar(); }
    if(flag) n = -n;
    return n;
}

struct haha {
    int l,r;
}a[SZ];

bool cmplen(haha a,haha b) { return a.r-a.l &lt; b.r-b.l; }
bool cmplen2(haha a,haha b) { return a.r-a.l &gt; b.r-b.l; }
bool cmpl(haha a,haha b) { return a.l &lt; b.l; }

vector&lt;haha&gt; A,B;
/// A: 没包含任何

int f[210][210];

int main() {
    int n = read(),p = read();
    for(int i = 1;i &lt;= n;i ++) {
        a[i].l = read();
        a[i].r = read();
    }
    sort(a+1,a+1+n,cmplen);
    for(int i = 1;i &lt;= n;i ++) {
        bool flag = 0;
        for(haha p : A) {
            if(a[i].l &lt;= p.l &amp;&amp; p.r &lt;= a[i].r) {
                flag = 1; break;
            }
        }
        if(!flag) A.push_back(a[i]);
        else B.push_back(a[i]);
    }
    sort(A.begin(),A.end(),cmpl);
    for(int i = 0;i &lt;= A.size();i ++)
        for(int j = 0;j &lt;= p;j ++)
            f[i][j] = -INF;
    f[0][0] = 0;
    for(int k = 1;k &lt;= p;k ++) {
        for(int i = 1;i &lt;= A.size();i ++) {
            int l = A[i-1].l;
            int r = A[i-1].r;
            for(int j = i-1;j &gt;= 0;j --) {
                if(l&gt;=r) break;
                f[i][k] = max(f[i][k],f[j][k-1] + r-l);
                if(j) l = max(l,A[j-1].l),r = min(r,A[j-1].r);
            }
        }
    }
    sort(B.begin(),B.end(),cmplen2);
    LL ans = f[A.size()][p],sum = 0;
    for(int i = 0;i &lt; min((int)B.size(),p);i ++) {
        sum += B[i].r-B[i].l;
        ans = max(ans,sum+f[A.size()][p-i-1]);
    }
    cout &lt;&lt; ans &lt;&lt; endl;
}
</code></code></pre> 
</div> 
<p>转载于:https://www.cnblogs.com/dqsssss/p/11349572.html</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2a805213b404553880911d9179cb333a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">LeetCode每日一题——T8. 字符串转换整数 (atoi) （中）：正则表达式</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/43fe7744b74b1df4c57f4816663f6bd6/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">java.nio.ByteBuffer详解</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>