<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>前端框架react----生命周期 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="前端框架react----生命周期" />
<meta property="og:description" content="目录
前言
一、什么是组件的生命周期呢？
二、挂在阶段
1、constructor（props）
2、static getDerivedStateFromProps(props, state)
3、render()
4、componentDidMount()
5、componentWillMount()
三、更新阶段
1、shouldComponentUpdate(nextProps, nextState)
2、getSnapshotBeforeUpdate(prevProps, prevState)
3、componentDidUpdate(prevProps, prevState, snapshot)
4、UNSAFE_componentWillUpdate(nextProps, nextState) 旧
5、UNSAFE_componentWillReceiveProps(nextProps) 旧
四、卸载阶段
1、componentWillUnmount()
总结
前言 前面两篇文章简单地介绍了 React 中的 JSX 语法、状态组件、绑定事件、设置 state 等基本操作，这篇文章将继续通过一些实例介绍 React 中的基础知识点生命周期。
文章开始之前我们来认识两张图:
旧版本：
新版本：
一、什么是组件的生命周期呢？ 1、组件从创建到死亡它会经历一些特定的阶段。
2、React组件中包含一系列钩子函数（生命周期回调函数），会在特定的时刻调用。
3、我们在定义组件时，会在特定的生命周期回调函数中，做待定的工作。
简单来说：一个组件从创建到最后消亡所经历的各种状态，就是一个组件的生命周期
从组件被创建，到组件挂载到页面上运行，再到页面关闭组件被卸载，这三个阶段总是伴随着组件各种各样的事件，那么这些事件，统称为组件的生命周期函数
在React中，我们可以将其生命周期分为三个阶段：
挂载阶段
更新阶段
卸载阶段
不同阶段将对应不同的钩子函数来处理组件的状态。
二、挂在阶段 首先是挂载阶段，当组件实例被创建并插入DOM中时，将依次调用以下生命周期函数
constructor
static getSerivedStateFromProps
render
componentDidMount
1、constructor（props） 在React组件挂载之前，会调用它的构造函数，在这个函数中我们可以拿到组件传递的props，通常，在React中，构造函数仅用于以下两种情况：
通过给this.state赋值对象来初始化内部state
为事件处理函数绑定实例
注意： 在 constructor() 函数中不要调用 setState() 方法
避免将 props 的值复制给 state" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/b22497dde4c0ab8519ca2c373adbd30d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-08-23T08:32:44+08:00" />
<meta property="article:modified_time" content="2021-08-23T08:32:44+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">前端框架react----生命周期</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="-toc" style="margin-left:0px;"></p> 
<p id="%E5%89%8D%E8%A8%80-toc" style="margin-left:0px;"><a href="#%E5%89%8D%E8%A8%80" rel="nofollow">前言</a></p> 
<p id="%E4%B8%80%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E7%BB%84%E4%BB%B6%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%91%A2%EF%BC%9F-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E7%BB%84%E4%BB%B6%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%91%A2%EF%BC%9F" rel="nofollow">一、什么是组件的生命周期呢？</a></p> 
<p id="%E4%BA%8C%E3%80%81%E6%8C%82%E5%9C%A8%E9%98%B6%E6%AE%B5-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81%E6%8C%82%E5%9C%A8%E9%98%B6%E6%AE%B5" rel="nofollow">二、挂在阶段</a></p> 
<p id="1%E3%80%81constructor%EF%BC%88props%EF%BC%89-toc" style="margin-left:40px;"><a href="#1%E3%80%81constructor%EF%BC%88props%EF%BC%89" rel="nofollow">1、constructor（props）</a></p> 
<p id="2%E3%80%81static%20getDerivedStateFromProps(props%2C%20state)-toc" style="margin-left:40px;"><a href="#2%E3%80%81static%20getDerivedStateFromProps%28props%2C%20state%29" rel="nofollow">2、static getDerivedStateFromProps(props, state)</a></p> 
<p id="3%E3%80%81render()-toc" style="margin-left:40px;"><a href="#3%E3%80%81render%28%29" rel="nofollow">3、render()</a></p> 
<p id="constructor-toc" style="margin-left:40px;"><a href="#constructor" rel="nofollow">4、componentDidMount()</a></p> 
<p id="5%E3%80%81componentWillMount()-toc" style="margin-left:0px;"><a href="#5%E3%80%81componentWillMount%28%29" rel="nofollow">5、componentWillMount()</a></p> 
<p id="%E4%B8%89%E3%80%81%E6%9B%B4%E6%96%B0%E9%98%B6%E6%AE%B5-toc" style="margin-left:0px;"><a href="#%E4%B8%89%E3%80%81%E6%9B%B4%E6%96%B0%E9%98%B6%E6%AE%B5" rel="nofollow">三、更新阶段</a></p> 
<p id="1%E3%80%81shouldComponentUpdate(nextProps%2C%20nextState)-toc" style="margin-left:40px;"><a href="#1%E3%80%81shouldComponentUpdate%28nextProps%2C%20nextState%29" rel="nofollow">1、shouldComponentUpdate(nextProps, nextState)</a></p> 
<p id="2%E3%80%81getSnapshotBeforeUpdate(prevProps%2C%20prevState)-toc" style="margin-left:40px;"><a href="#2%E3%80%81getSnapshotBeforeUpdate%28prevProps%2C%20prevState%29" rel="nofollow">2、getSnapshotBeforeUpdate(prevProps, prevState)</a></p> 
<p id="3%E3%80%81componentDidUpdate(prevProps%2C%20prevState%2C%20snapshot)-toc" style="margin-left:40px;"><a href="#3%E3%80%81componentDidUpdate%28prevProps%2C%20prevState%2C%20snapshot%29" rel="nofollow">3、componentDidUpdate(prevProps, prevState, snapshot)</a></p> 
<p id="4%E3%80%81UNSAFE_componentWillUpdate(nextProps%2C%20nextState)%20%E6%97%A7-toc" style="margin-left:0px;"><a href="#4%E3%80%81UNSAFE_componentWillUpdate%28nextProps%2C%20nextState%29%20%E6%97%A7" rel="nofollow">4、UNSAFE_componentWillUpdate(nextProps, nextState) 旧</a></p> 
<p id="5%E3%80%81UNSAFE_componentWillReceiveProps(nextProps)%20%E6%97%A7-toc" style="margin-left:0px;"><a href="#5%E3%80%81UNSAFE_componentWillReceiveProps%28nextProps%29%20%E6%97%A7" rel="nofollow">5、UNSAFE_componentWillReceiveProps(nextProps) 旧</a></p> 
<p id="%E5%9B%9B%E3%80%81%E5%8D%B8%E8%BD%BD%E9%98%B6%E6%AE%B5-toc" style="margin-left:0px;"><a href="#%E5%9B%9B%E3%80%81%E5%8D%B8%E8%BD%BD%E9%98%B6%E6%AE%B5" rel="nofollow">四、卸载阶段</a></p> 
<p id="1%E3%80%81componentWillUnmount()-toc" style="margin-left:40px;"><a href="#1%E3%80%81componentWillUnmount%28%29" rel="nofollow">1、componentWillUnmount()</a></p> 
<p id="%C2%A0%E6%80%BB%E7%BB%93-toc" style="margin-left:0px;"><a href="#%C2%A0%E6%80%BB%E7%BB%93" rel="nofollow"> 总结</a></p> 
<hr id="hr-toc"> 
<h2 id="%E5%89%8D%E8%A8%80">前言</h2> 
<p>前面两篇文章简单地介绍了 <code>React</code> 中的 <code>JSX</code> 语法、状态组件、绑定事件、设置 <code>state</code> 等基本操作，这篇文章将继续通过一些实例介绍 <code>React</code> 中的基础知识点生命周期。</p> 
<p>文章开始之前我们来认识两张图:</p> 
<p>旧版本：</p> 
<p><img alt="" height="852" src="https://images2.imgbox.com/1b/e4/bFVL5DB2_o.png" width="1152"></p> 
<p>新版本：</p> 
<p><img alt="" height="672" src="https://images2.imgbox.com/4f/18/YPb6piOk_o.png" width="1200"></p> 
<p></p> 
<h2 id="%E4%B8%80%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E7%BB%84%E4%BB%B6%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%91%A2%EF%BC%9F">一、什么是组件的生命周期呢？</h2> 
<p>1、组件从创建到死亡它会经历一些特定的阶段。</p> 
<p>2、React组件中包含一系列钩子函数（生命周期回调函数），会在特定的时刻调用。</p> 
<p>3、我们在定义组件时，会在特定的生命周期回调函数中，做待定的工作。</p> 
<blockquote> 
 <p>简单来说：一个组件从创建到最后消亡所经历的各种状态，就是一个组件的生命周期</p> 
</blockquote> 
<blockquote> 
 <p>从组件被创建，到组件挂载到页面上运行，再到页面关闭组件被卸载，这三个阶段总是伴随着组件各种各样的事件，那么这些事件，统称为组件的生命周期函数</p> 
</blockquote> 
<p>在React中，我们可以将其生命周期分为三个阶段：</p> 
<ul><li> <p>挂载阶段</p> </li><li> <p>更新阶段</p> </li><li> <p>卸载阶段</p> </li></ul> 
<p>不同阶段将对应不同的钩子函数来处理组件的状态。</p> 
<h2 id="%E4%BA%8C%E3%80%81%E6%8C%82%E5%9C%A8%E9%98%B6%E6%AE%B5">二、挂在阶段</h2> 
<p>首先是挂载阶段，当组件实例被创建并插入DOM中时，将依次调用以下生命周期函数</p> 
<ul><li> <p><code>constructor</code></p> </li><li> <p><code>static getSerivedStateFromProps</code></p> </li><li> <p><code>render</code></p> </li><li> <p><code>componentDidMount</code></p> </li></ul> 
<h3 id="1%E3%80%81constructor%EF%BC%88props%EF%BC%89">1、constructor（props）</h3> 
<p>在React组件<span style="color:#fe2c24;">挂载之前</span>，会调用它的构造函数，在这个函数中我们可以拿到组件传递的props，通常，在React中，构造函数仅用于以下两种情况：</p> 
<p>        通过给this.state赋值对象来初始化内部state</p> 
<p>        为事件处理函数绑定实例</p> 
<p>注意：     </p> 
<ul><li> <p>在 <code>constructor()</code> 函数中不要调用 <code>setState()</code> 方法</p> </li><li> <p>避免将 <code>props</code> 的值复制给 <code>state</code></p> </li></ul> 
<p>---在 <code>constructor()</code> 函数中不要调用 <code>setState()</code> 方法。如果你的组件需要使用内部 state，请直接在构造函数中为 <code>this.state</code> 赋值初始 state：</p> 
<pre><code class="language-javascript">constructor(props) {
  super(props);
  // 不要在这里调用 this.setState()
  this.state = { counter: 0 };
  this.handleClick = this.handleClick.bind(this);
}</code></pre> 
<p>只能在构造函数中直接为 <code>this.state</code> 赋值。如需在其他方法中赋值，你应使用 <code>this.setState()</code> 替代。</p> 
<p>---避免将 props 的值复制给 state！这是一个常见的错误：</p> 
<pre><code class="language-javascript">constructor(props) {
 super(props);
 // 不要这样做
 this.state = { color: props.color };
}</code></pre> 
<p>如此做毫无必要（你可以直接使用 <code>this.props.color</code>），同时还产生了 bug（更新 prop 中的 <code>color</code> 时，并不会影响 state）。</p> 
<p>只有在你刻意忽略 prop 更新的情况下使用，此时，应将 prop 重命名为 <code>initialColor</code> 或 <code>defaultColor</code>。必要时，你可以修改它的key，以强制“重置”其内部 state。</p> 
<h3 id="2%E3%80%81static%20getDerivedStateFromProps(props%2C%20state)">2、static getDerivedStateFromProps(props, state)</h3> 
<p><code>getDerivedStateFromProps</code> 会在<span style="color:#fe2c24;">调用 <code>render</code> 方法之前调用</span>，并且在初始挂载及后续更新时都会被调用。它应返回一个对象来更新 <code>state</code>，如果返回 <code>null</code> 则不更新任何内容</p> 
<p>在这个函数中，我们可以拿到组件传递的 <code>props</code> 和 <code>state</code>，它存在最重要的目的就是：<strong>让组件在 <code>props</code> 变化时更新 <code>state</code></strong></p> 
<p>比如说，这样：</p> 
<pre><code class="language-javascript">static getDerivedStateFromProps(props, state) {
    console.warn('组件生命周期：getDerivedStateFromProps')
    if (props.age !== state.age) {
        return {
            age: props.age
        }
    }
    return null
}</code></pre> 
<p>使用该生命周期函数需要注意的地方：</p> 
<ul><li> <p>该函数会在 <code>render</code> 方法之前调用，会调用<strong>多次</strong></p> </li><li> <p>必须有返回值，返回一个对象来更新 <code>state</code> 或者返回 <code>null</code> 不更新 <code>state</code></p> </li></ul> 
<h3 id="3%E3%80%81render()">3、render()</h3> 
<p>        render()方法是class组件中唯一必须实现的方法</p> 
<p>使用该函数需要注意的地方：</p> 
<ul><li> <p>必须有返回值，可以有多种类型，如果不需要返回任何结构，可以直接返回 <code>null</code></p> </li><li> <p><code>render()</code> 函数应该为纯函数，意味着在不修改组件state的情况下，每次调用都会返回相同的结果，并且它不会直接与浏览器交互。</p> </li><li> <p>不能在函数中调用this.setState()方法</p> </li><li> <p>该函数会调用多次</p> </li><li> <p>如需与浏览器进行交互，请在 <code>componentDidMount()</code> 或其他生命周期方法中执行你的操作。保持 <code>render()</code> 为纯函数，可以使组件更容易思考。</p> </li></ul> 
<blockquote> 
 <p>如果 <code>shouldComponentUpdate()</code> 返回 false，则不会调用 <code>render()</code>。</p> 
</blockquote> 
<h3 id="constructor">4、componentDidMount()</h3> 
<blockquote> 
 <p><code>componentDidMount()</code> 会在组件挂载后（插入 <code>DOM</code> 树中）立即调用。依赖于 <code>DOM</code> 节点的初始化应该放在这里。如需通过网络请求获取数据，此处是实例化请求的好地方</p> 
</blockquote> 
<p>在该函数中常有的操作：</p> 
<ul><li> <p>操作 <code>DOM</code></p> </li><li> <p>进行 <code>ajax</code> 操作来完成数据的交互</p> </li><li> <p>使用 <code>setState()</code> 来修改 <code>state</code></p> </li></ul> 
<h2 id="5%E3%80%81componentWillMount()">5、<code>componentWillMount()</code></h2> 
<p>这个周期函数在上面第一张生命周期图中出现，在最新版本的生命周期中已经除去，在react17之前也叫UNSAFE_componentWillMount()。</p> 
<p>它的特点：</p> 
<ul><li> <p><code>UNSAFE_componentWillMount()</code> 在挂载之前被调用。</p> </li><li> <p>它在 <code>render()</code> 之前调用,在此方法中同步调用 <code>setState()</code> 不会触发额外渲染</p> </li><li> <p>与现有的新生命周期不能同时使用，只会调用一次</p> </li></ul> 
<h2 id="%E4%B8%89%E3%80%81%E6%9B%B4%E6%96%B0%E9%98%B6%E6%AE%B5">三、更新阶段</h2> 
<blockquote> 
 <p>当组件的 <code>props</code> 或 <code>state</code> 发生变化时会触发更新</p> 
</blockquote> 
<p>更新阶段会依次触发以下生命周期函数：</p> 
<ul><li> <p><code>static getDerivedStateFromProps()</code></p> </li><li> <p><code>shouldComponentUpdate()</code></p> </li><li> <p><code>render()</code></p> </li><li> <p><code>getSnapshotBeforeUpdate()</code></p> </li><li> <p><code>componentDidUpdate()</code></p> </li></ul> 
<p>在生命周期函数执行阶段，有一些钩子函数是多次触发，比如更新阶段的 <code>static getDerivedStateFromProps()</code> 与 <code>render()</code> 函数也会在挂载阶段触发。</p> 
<h3 id="1%E3%80%81shouldComponentUpdate(nextProps%2C%20nextState)">1、shouldComponentUpdate(nextProps, nextState)</h3> 
<p>        当props或state发生变化时，shouldComponentUpdate()会在渲染执行之前被调用，根据shouldComponentUpdate()的返回值，判断React组件的输出是否受当前state或props更改的影响。默认行为是state每次发生变化都会重新渲染。</p> 
<p>使用该函数需要注意的地方：</p> 
<ul><li> <p>在组件首次渲染的时候是不会调用这个生命周期函数的</p> </li><li> <p>在该函数中我们可以通过 <code>this.state</code> 和 <code>this.props</code> 拿到更新之前的 <code>state</code> 与 <code>props</code> 的值；通过 <code>nextProps</code> 与 <code>nextState</code> 拿到 <code>props</code> 与 <code>state</code> 更新之后的值</p> </li><li> <p>该函数必须提供一个返回值，<code>true</code> 或者 <code>false</code>。 默认返回 <code>true</code></p> </li><li> <p>最好不要企图依靠此方法来阻止渲染 ( 返回 <code>false</code> )</p> </li></ul> 
<h3 id="2%E3%80%81getSnapshotBeforeUpdate(prevProps%2C%20prevState)">2、getSnapshotBeforeUpdate(prevProps, prevState)</h3> 
<blockquote> 
 <p><code>getSnapshotBeforeUpdate()</code> 在最近一次渲染输出（提交到 <code>DOM</code> 节点）之前调用</p> 
</blockquote> 
<p>简单来说，这个函数会在 <code>componentDidUpdate()</code> 函数执行之前调用，一般会用于一些UI的处理 需要注意的点：</p> 
<ul><li> <p>在这个函数中我们可以拿到组件更新之前的 <code>props</code> 与 <code>state</code> 的值</p> </li><li> <p>必须与 <code>componentDidUpdate()</code> 一起使用</p> </li><li> <p>必须提供返回值 <code>snapshot</code> 的值( 在<code>componentDidUpdate()</code>中接收 )或 <code>null</code></p> </li></ul> 
<h3 id="3%E3%80%81componentDidUpdate(prevProps%2C%20prevState%2C%20snapshot)"><code>3、</code>componentDidUpdate(prevProps, prevState, snapshot)</h3> 
<blockquote> 
 <p><code>componentDidUpdate()</code> 会在更新后会被立即调用。首次渲染不会执行此方法</p> 
</blockquote> 
<p>使用该函数需要注意的点：</p> 
<ul><li> <p>当组件更新后，可以在此处对 <code>DOM</code> 进行操作</p> </li><li> <p>可以选择在此处进行网络请求</p> </li><li> <p>可以直接调用 <code>setState()</code>，但是必须将它包裹在一个条件语句中</p> </li><li> <p>如果 <code>shouldComponentUpdate()</code> 返回值为 <code>false</code>，则不会调用 <code>componentDidUpdate()</code></p> </li><li> <p>在该函数中可以拿到 更新之前的 <code>state</code> 与 <code>props</code> 值，也可以拿到 <code>getSnapshotBeforeUpdate()</code> 传递过来的值,如果并没有传递值，则第三个参数的值为 <code>undefined</code></p> </li></ul> 
<h2 id="4%E3%80%81UNSAFE_componentWillUpdate(nextProps%2C%20nextState)%20%E6%97%A7">4、UNSAFE_componentWillUpdate(nextProps, nextState) 旧</h2> 
<blockquote> 
 <p>此生命周期之前名为 <code>componentWillUpdate</code>。该名称将继续使用至 <code>React 17</code></p> 
</blockquote> 
<p>使用该函数需要注意的地方：</p> 
<ul><li> <p>当组件收到新的 <code>props</code> 或 <code>state</code> 时，会在渲染之前调用 <code>UNSAFE_componentWillUpdate()</code></p> </li><li> <p>不能此方法中调用 <code>this.setState()</code></p> </li><li> <p>如果 <code>shouldComponentUpdate()</code> 返回 <code>false</code>，则不会调用 <code>UNSAFE_componentWillUpdate()</code></p> </li><li> <p>不要与新的生命周期一起使用(会出现警告)</p> </li></ul> 
<p></p> 
<h2 id="5%E3%80%81UNSAFE_componentWillReceiveProps(nextProps)%20%E6%97%A7">5、UNSAFE_componentWillReceiveProps(nextProps) 旧</h2> 
<p></p> 
<blockquote> 
 <p>此生命周期之前名为 <code>componentWillReceiveProps</code>。该名称将继续使用至 <code>React 17</code></p> 
</blockquote> 
<blockquote> 
 <p><code>UNSAFE_componentWillReceiveProps()</code> 会在已挂载的组件接收新的 <code>props</code> 之前被调用</p> 
</blockquote> 
<p>使用该函数需要注意的地方：</p> 
<ul><li> <p><code>React</code> 不会针对初始 <code>props</code> 调用 <code>UNSAFE_componentWillReceiveProps()</code>，只会在组件的 <code>props</code> 更新时调用此方法</p> </li><li> <p>调用 <code>this.setState()</code> 通常不会触发 <code>UNSAFE_componentWillReceiveProps()</code></p> </li><li> <p>不要与新的生命周期函数一起使用</p> </li></ul> 
<h2 id="%E5%9B%9B%E3%80%81%E5%8D%B8%E8%BD%BD%E9%98%B6%E6%AE%B5">四、卸载阶段</h2> 
<p><code>React</code> 在卸载阶段只有一个生命周期函数</p> 
<h3 id="1%E3%80%81componentWillUnmount()">1、componentWillUnmount()</h3> 
<blockquote> 
 <p>componentWillUnmount() 会在组件卸载及销毁之前直接调用</p> 
</blockquote> 
<p>使用该函数的注意点：</p> 
<ul><li> <p>可以在该函数中执行必要的清理工作，比如 定时器</p> </li><li> <p><code>componentWillUnmount()</code> 中不应调用 <code>setState()</code>，因为该组件将永远不会重新渲染</p> </li></ul> 
<p>下面就是一个基本完整的 <code>React</code> 组件从挂载到 子组件卸载的完整过程</p> 
<p><img alt="" height="558" src="https://images2.imgbox.com/df/64/YeUk9mRG_o.png" width="1192"></p> 
<h2 id="%C2%A0%E6%80%BB%E7%BB%93"> 总结</h2> 
<p>一个组件从开始挂载到最终卸载生命周期(主要)</p> 
<table><thead><tr><th>生命周期</th><th>调用次数</th><th>是否可以使用 setState</th></tr></thead><tbody><tr><td><code>constructor()</code></td><td>1</td><td>否</td></tr><tr><td><code>render()</code></td><td>&gt;= 1</td><td>否</td></tr><tr><td><code>componentDidMount()</code></td><td>1</td><td>是</td></tr><tr><td><code>componentDidUpdate()</code></td><td>&gt;=1</td><td>是(必须被包裹在一个条件语件里)</td></tr><tr><td><code>componentWillUnmount()</code></td><td>1</td><td>否</td></tr></tbody></table> 
<ul><li> <p><code>React</code> 中必须实现的生命周期只有 <code>render</code></p> </li><li> <p>在 <code>constructor</code> 中进行 <code>state</code> 的初始化与事件绑定</p> </li><li> <p>在 <code>componentDidMount</code> 与 <code>componentDidUpdate</code> 中进行一些 <code>DOM</code> 操作和数据交互，使用 <code>setState</code></p> </li><li> <p>在 <code>componentWillUnmount</code> 中处理一些清理工作</p> </li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ba3d2aca81e3f56385d30d8afeefba05/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">USB Map 解决 AX200 蓝牙不出现的问题-黑苹果 Big Sur 11.5.2-TUF B550M PLUS WI-FI</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/7dadfcd1655d6fbe7fc2b67544efa7b4/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【命令行问题】`complete:13: command not found: compdef `</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>