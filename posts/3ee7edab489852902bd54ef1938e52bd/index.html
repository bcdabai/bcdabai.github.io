<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Python装饰器详解 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Python装饰器详解" />
<meta property="og:description" content="一、基础语法 1.1 函数装饰器 Python装饰器（Decorator）是一种特殊的函数，其可以装饰其他的函数或类。所谓装饰，其实就是将其他的函数或类作为参数传入，在原有基础上添加一些新逻辑或者属性后，将这个新的函数或类返回的过程。
我们首先来看函数装饰器，这里给出一个例子。
# 一个简易的示例装饰器 def myDecorator(func): def wrapper(*args, **kwargs): print(&#34;这里是添加的装饰器逻辑&#34;) return func(*args, **kwargs) return wrapper # 被装饰函数 def example(): print(&#34;这里是被装饰的函数&#34;) # 装饰过程 example = mydecorator(example) # 调用被装饰后的函数 example() # 调用结果 # &gt;&gt; 这里是添加的装饰器逻辑 # &gt;&gt; 这里是被装饰的函数 上面这段代码中，我们首先定义了一个装饰器函数，该函数以其他函数为形参，并返回一个新的函数对象。（请注意，在Python中函数本身就是一等对象，即可以被当作形参传递、当作返回值返回，也可以被存储在数据结构中）
在装饰过程中，example这一变量被装饰器返回的新函数对象所替代。 因此在之后的调用中，结果里显示了装饰器导入的打印逻辑。这就是函数装饰器的原理。
1.2 @Wrapper语法糖 上面的代码和大家之前了解的装饰器画风可能不太一致。
事实上，装饰器本身只是函数的一种用法，而Python为了方便大家应用这种技巧，提供了一种语法糖，来快速应用装饰器函数。
# 使用@wrapper装饰器语法来快速应用装饰器函数 @myDecorator def example(): print(&#34;这里是被装饰的函数&#34;) 这段代码与1.1中的装饰过程是等价的，程序员使用@mydecorator语法时，等价于使用example = mydecorator(example)对example函数进行装饰。也就是说，被装饰的函数对象会作为参数传入装饰器函数，因此，请确保你的装饰器函数拥有合适数量的形参以接收被装饰函数对象。
从语法上讲，@后面可以连接任何赋值表达式，最简单的情况就是我们直接给出装饰器函数名。如果是其他类型的表达式，也只需确保表达式的返回值是一个可调用的函数对象即可（这一点为后面的含参装饰器提供了支持）。
1.3 类装饰器 之前讲到，类与函数都可以通过装饰器进行装饰。装饰函数实际就是返回一个新函数对象，对于类而言道理相同，就是返回一个新的类对象而已。请注意这里的类对象不是指类的实例，而是指类类型对象（对，这个类对象的类型就是type）。可以简单的理解为重新给出了被装饰类的定义。对一个类的装饰包括但不限于添加新的方法与属性，当然也可以覆盖或重写原类型的方法与属性。下面给一个简单的示例：
# 定义类装饰器 def myDecorator(cls): class Wrapper: def __init__(self, *args, **kwargs): self." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/3ee7edab489852902bd54ef1938e52bd/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-11-30T12:52:39+08:00" />
<meta property="article:modified_time" content="2023-11-30T12:52:39+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Python装饰器详解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-dracula">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="_0"></a>一、基础语法</h2> 
<h3><a id="11__1"></a>1.1 函数装饰器</h3> 
<p>Python装饰器（Decorator）是一种特殊的函数，其<strong>可以装饰其他的函数或类</strong>。所谓装饰，其实就是将其他的函数或类作为参数传入，在原有基础上添加一些新逻辑或者属性后，将这个新的函数或类返回的过程。<br> 我们首先来看函数装饰器，这里给出一个例子。</p> 
<pre><code class="prism language-python"><span class="token comment"># 一个简易的示例装饰器</span>
<span class="token keyword">def</span> <span class="token function">myDecorator</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">:</span>
	<span class="token keyword">def</span> <span class="token function">wrapper</span><span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>
		<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"这里是添加的装饰器逻辑"</span><span class="token punctuation">)</span>
		<span class="token keyword">return</span> func<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span>
	<span class="token keyword">return</span> wrapper

<span class="token comment"># 被装饰函数</span>
<span class="token keyword">def</span> <span class="token function">example</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
	<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"这里是被装饰的函数"</span><span class="token punctuation">)</span>
	
<span class="token comment"># 装饰过程</span>
example <span class="token operator">=</span> mydecorator<span class="token punctuation">(</span>example<span class="token punctuation">)</span>

<span class="token comment"># 调用被装饰后的函数</span>
example<span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment"># 调用结果</span>
<span class="token comment"># &gt;&gt; 这里是添加的装饰器逻辑</span>
<span class="token comment"># &gt;&gt; 这里是被装饰的函数</span>
</code></pre> 
<p>上面这段代码中，我们首先定义了一个装饰器函数，<strong>该函数以其他函数为形参，并返回一个新的函数对象。</strong>（请注意，在Python中函数本身就是一等对象，即可以被当作形参传递、当作返回值返回，也可以被存储在数据结构中）<br> <strong>在装饰过程中，<code>example</code>这一变量被装饰器返回的新函数对象所替代。</strong> 因此在之后的调用中，结果里显示了装饰器导入的打印逻辑。这就是函数装饰器的原理。</p> 
<h3><a id="12_Wrapper_28"></a>1.2 @Wrapper语法糖</h3> 
<p>上面的代码和大家之前了解的装饰器画风可能不太一致。<br> 事实上，装饰器本身只是函数的一种用法，而Python为了方便大家应用这种技巧，提供了一种语法糖，来快速应用装饰器函数。</p> 
<pre><code class="prism language-python"><span class="token comment"># 使用@wrapper装饰器语法来快速应用装饰器函数</span>
<span class="token decorator annotation punctuation">@myDecorator</span>
<span class="token keyword">def</span> <span class="token function">example</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
	<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"这里是被装饰的函数"</span><span class="token punctuation">)</span>
</code></pre> 
<p>这段代码与1.1中的装饰过程是<strong>等价的</strong>，程序员使用<code>@mydecorator</code>语法时，等价于使用<code>example = mydecorator(example)</code>对<code>example</code>函数进行装饰。也就是说，被装饰的函数对象会作为参数传入装饰器函数，因此，请确保你的装饰器函数拥有合适数量的形参以接收被装饰函数对象。<br> 从语法上讲，<code>@</code>后面可以连接<strong>任何赋值表达式</strong>，最简单的情况就是我们直接给出装饰器函数名。如果是其他类型的表达式，也只需确保表达式的返回值是一个<strong>可调用</strong>的函数对象即可（这一点为后面的含参装饰器提供了支持）。</p> 
<h3><a id="13__39"></a>1.3 类装饰器</h3> 
<p>之前讲到，类与函数都可以通过装饰器进行装饰。装饰函数实际就是返回一个新函数对象，对于类而言道理相同，就是返回一个新的类对象而已。请注意这里的类对象不是指类的实例，而是指类类型对象（对，这个类对象的类型就是<code>type</code>）。可以简单的理解为重新给出了被装饰类的定义。对一个类的装饰包括但不限于添加新的方法与属性，当然也可以覆盖或重写原类型的方法与属性。下面给一个简单的示例：</p> 
<pre><code class="prism language-python"><span class="token comment"># 定义类装饰器</span>
<span class="token keyword">def</span> <span class="token function">myDecorator</span><span class="token punctuation">(</span>cls<span class="token punctuation">)</span><span class="token punctuation">:</span>
	<span class="token keyword">class</span> <span class="token class-name">Wrapper</span><span class="token punctuation">:</span>
		<span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> <span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>
			self<span class="token punctuation">.</span>instance <span class="token operator">=</span> cls<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span>
			self<span class="token punctuation">.</span>newAttr <span class="token operator">=</span> <span class="token string">"这是装饰器添加的新属性"</span>
		<span class="token keyword">def</span> <span class="token function">__getattr__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">:</span>
			<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"__getattr__方法经过了调用"</span><span class="token punctuation">)</span>
			<span class="token keyword">return</span> <span class="token builtin">getattr</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>instance<span class="token punctuation">,</span> name<span class="token punctuation">)</span>
		<span class="token keyword">def</span> <span class="token function">newfunc</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
			<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"这是装饰器添加的新方法"</span><span class="token punctuation">)</span>
	<span class="token keyword">return</span> Wrapper

<span class="token comment"># 使用上述装饰器对一个类进行装饰</span>
<span class="token decorator annotation punctuation">@myDecorator</span>
<span class="token keyword">class</span> <span class="token class-name">Example</span><span class="token punctuation">:</span>
	<span class="token keyword">def</span> <span class="token function">oldfunc</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
		<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"这里是oldfunc"</span><span class="token punctuation">)</span>

<span class="token comment"># 调用原类型方法</span>
<span class="token punctuation">(</span>e <span class="token operator">:=</span> Example<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>oldfunc<span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment"># 调用结果</span>
<span class="token comment"># &gt;&gt; __getattr__方法经过了调用</span>
<span class="token comment"># &gt;&gt; 这里是oldfunc</span>
</code></pre> 
<p>可以看到，<strong>这个装饰后的类在实例化时，会创建原类型的实例作为属性</strong>，只有通过原类型实例我们能够访问原类型的属性与方法。这个过程用到了<code>__getattr__</code>魔术方法，其作用是当无法直接获取到对象方法或属性时，会采用该方法对目标属性或方法进行查找。<br> 正常来说，在对<code>Example</code>进行装饰后，<code>Example</code>实际上是被<code>Wrapper</code>类型所替代，如果直接采用<code>(e := Example()).oldfunc()</code>去调用装饰前<code>Example</code>的<code>oldfunc</code>方法是不会成功的，因为<code>Wrapper</code>类中并不包含<code>Example</code>类的属性与方法。<br> 想要获取原类型的属性与方法可以通过<code>getattr()</code>方法完成（作用是通过一个类型的实例获取其属性与方法，而区别于之前提到的魔术方法<code>__getattr__</code>）。<br> 然而，装饰器的精髓就在于<strong>装饰</strong>二字，无论我们怎么修饰原类型，它都应该具备自己原本的属性与方法，修饰后类型的外观与原类型不能有显著差别。因此可以借助<code>__getattr__</code>方法包装<code>getattr(instance, name)</code>方法，这样我们就可以通过装饰后类型的实例，对原类型属性方法进行直接访问，<strong>使用体验也几乎无差别</strong>。</p> 
<h2><a id="_73"></a>二、进阶用法</h2> 
<h3><a id="21__74"></a>2.1 含参装饰器</h3> 
<p>如果一个装饰器从它被定义的那刻起，它的装饰行为就不可更改，那么会在很多场景上给开发者带来困扰。因为这意味着，如果开发者只想对装饰器的装饰行为进行微调，却要重新定义一个新的装饰器。幸运的是，我们可以通过一些技巧来<strong>为装饰器指定特定参数</strong>，<strong>以此来改变装饰器的行为</strong>。下面是一个示例：</p> 
<pre><code class="prism language-python"><span class="token comment"># 一个简单的含参装饰器</span>
<span class="token keyword">def</span> <span class="token function">myDecorator</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">:</span>	<span class="token comment"># 套壳，接受参数</span>
	<span class="token keyword">def</span> <span class="token function">realDecorator</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment"># 这一层才是真正的装饰器函数</span>
		<span class="token keyword">def</span> <span class="token function">wrapper</span><span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>
			<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"</span><span class="token interpolation"><span class="token punctuation">{<!-- --></span>name<span class="token punctuation">}</span></span><span class="token string">定制装饰器"</span></span><span class="token punctuation">)</span>
			<span class="token keyword">return</span> func<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span>
		<span class="token keyword">return</span> wrapper
	<span class="token keyword">return</span> realDecorator

<span class="token comment"># 装饰过程</span>
<span class="token decorator annotation punctuation">@myDecorator</span><span class="token punctuation">(</span>name<span class="token operator">=</span><span class="token string">"China"</span><span class="token punctuation">)</span>  
<span class="token keyword">def</span> <span class="token function">example1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
	<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"示例函数1"</span><span class="token punctuation">)</span>

<span class="token decorator annotation punctuation">@myDecorator</span><span class="token punctuation">(</span>name<span class="token operator">=</span><span class="token string">"WuHan"</span><span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">example2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
	<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"示例函数2"</span><span class="token punctuation">)</span>

<span class="token comment"># 调用装饰后函数</span>
example1<span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment"># 调用结果</span>
<span class="token operator">&gt;&gt;</span> China定制装饰器
<span class="token operator">&gt;&gt;</span> 示例函数<span class="token number">1</span>
<span class="token operator">&gt;&gt;</span> WuHan定制装饰器
<span class="token operator">&gt;&gt;</span> 示例函数<span class="token number">2</span>
</code></pre> 
<p>之前提过，<code>@</code>装饰器语法糖中，<code>@</code>不光可以跟简单的函数名，也可以跟赋值表达式，只要确保这个表达式的返回值是一个合法装饰器函数即可。含参装饰器便是运用了这一技巧，<strong><code>@myDecorator(name="WuHan")</code>实际上是对<code>myDecorator</code>函数的带参调用</strong>，而<code>myDecorator</code>返回的正是真正的装饰器函数<code>realDecorator</code>，外层这一套壳起到了处理自定义参数的效果。</p> 
<h3><a id="22__105"></a>2.2 装饰器堆叠</h3> 
<p>装饰器可以堆叠使用，一个函数可以被无数个装饰器装饰。下图是一个被两个装饰器进行装饰的函数，<strong>请思考一下两个装饰器作用的顺序</strong>。</p> 
<pre><code class="prism language-python"><span class="token comment"># 装饰器1</span>
<span class="token keyword">def</span> <span class="token function">deco1</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">:</span>
	<span class="token keyword">def</span> <span class="token function">wrapper</span><span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>
		<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"deco1开始"</span><span class="token punctuation">)</span>
		result <span class="token operator">=</span> func<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span>
		<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"deco1结束"</span><span class="token punctuation">)</span>
		<span class="token keyword">return</span> result
	<span class="token keyword">return</span> wrapper

<span class="token comment"># 装饰器2</span>
<span class="token keyword">def</span> <span class="token function">deco2</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">:</span>
	<span class="token keyword">def</span> <span class="token function">wrapper</span><span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>
		<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"deco2开始"</span><span class="token punctuation">)</span>
		result <span class="token operator">=</span> func<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span>
		<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"deco2结束"</span><span class="token punctuation">)</span>
		<span class="token keyword">return</span> result
	<span class="token keyword">return</span> wrapper
	
<span class="token decorator annotation punctuation">@deco1</span>
<span class="token decorator annotation punctuation">@deco2</span>
<span class="token keyword">def</span> <span class="token function">example</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
	<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"被装饰函数！"</span><span class="token punctuation">)</span>

<span class="token comment"># 调用</span>
example<span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment"># 调用结果</span>
<span class="token comment"># &gt;&gt;deco1开始</span>
<span class="token comment"># &gt;&gt;deco2开始</span>
<span class="token comment"># &gt;&gt;被装饰函数！</span>
<span class="token comment"># &gt;&gt;deco2结束</span>
<span class="token comment"># &gt;&gt;deco1结束</span>
</code></pre> 
<p>不难看出，<strong>离目标函数近的装饰器会先进行装饰</strong>。这个其实很好理解，只需要想一下装饰器的原理，以及上述装饰器装饰过程的等价形式即可：</p> 
<pre><code class="prism language-python"><span class="token comment"># 等价形式，deco2先作用于example，deco1作用域装饰后的example</span>
example <span class="token operator">=</span> deco1<span class="token punctuation">(</span>deco2<span class="token punctuation">(</span>example<span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre> 
<h3><a id="23__147"></a>2.3 装饰器类</h3> 
<p>看到这里，需要对之前的一个概念作出纠正。装饰器只能是函数吗？其实不然。只要是<strong>可调用</strong>对象即可。而这个可调用的特性来自于Python对象的魔术方法<code>__call__()</code>，当我们调用一个可调用对象时，实际上就是执行的<code>__call__</code>。对于函数对象而言，<code>__call__</code>中的内容就是函数体代码。而对于自定义类来说，我们也可以通过定义它的<code>__call__</code>方法来使其成为一个可调用对象。</p> 
<pre><code class="prism language-python"><span class="token keyword">class</span> <span class="token class-name">MyDecorator</span><span class="token punctuation">:</span>
	<span class="token keyword">def</span> <span class="token function">__call__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> func<span class="token punctuation">)</span><span class="token punctuation">:</span>
		<span class="token keyword">def</span> <span class="token function">wrapper</span><span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>
			<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"装饰器逻辑"</span><span class="token punctuation">)</span>
			<span class="token keyword">return</span> func<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span>
		<span class="token keyword">return</span> wrapper

<span class="token decorator annotation punctuation">@MyDecorator</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">example</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
	<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"被装饰函数"</span><span class="token punctuation">)</span>
</code></pre> 
<p>请注意，<code>__call__</code>方法使得一个类的实例可以被调用，而并非类型本身被调用，因此这里<code>@</code>后跟的应该是<code>MyDecorator</code>的一个实例，即<code>MyDecorator()</code>。<br> 换个角度，不光装饰器本身可以是可调用类，里面的wrapper函数你要是愿意，也可以换成可调用类，<strong>用可调用类来替换被装饰的函数类型</strong>，这完全可行。</p> 
<pre><code class="prism language-python"><span class="token keyword">def</span> <span class="token function">myDecorator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">class</span> <span class="token class-name">Wrapper</span><span class="token punctuation">:</span>
        <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> func<span class="token punctuation">)</span><span class="token punctuation">:</span>
            self<span class="token punctuation">.</span>func <span class="token operator">=</span> func

        <span class="token keyword">def</span> <span class="token function">__call__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> <span class="token operator">*</span>agrs<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"装饰器逻辑"</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> self<span class="token punctuation">.</span>func<span class="token punctuation">(</span><span class="token operator">*</span>agrs<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span>
    <span class="token keyword">return</span> Wrapper

<span class="token decorator annotation punctuation">@myDecorator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 
<span class="token keyword">def</span> <span class="token function">example</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"被装饰函数"</span><span class="token punctuation">)</span>
</code></pre> 
<p>请注意这种写法下<code>@</code>后面需要调用myDecorator函数，以返回Wrapper类。这里的<strong>装饰过程实际上就是Wrapper类的实例化过程</strong>，以func作为构造函数参数，得到的实例将用于替换原来的example函数。</p> 
<h3><a id="24__179"></a>2.4 保留被装饰对象的元数据</h3> 
<p>最后来聊聊装饰这种行为的<code>副作用</code>。在最开始讲的函数装饰器场景下，无论你是用的哪种装饰方法，你的被装饰函数都不再是原来的那个对象了。这产生的后果就是，原函数的元数据会全部丢失。函数对象常用的元数据这里列了一些。</p> 
<table><thead><tr><th>元数据属性名</th><th>描述</th></tr></thead><tbody><tr><td>__name__</td><td>函数名称</td></tr><tr><td>__doc__</td><td>函数文档字符串，也就是大家在函数下面写的以一对三个双引号包裹起来的注释字符串，会被Pycharm等IDE读作函数文档</td></tr><tr><td>__module__</td><td>函数所在模块名</td></tr><tr><td>__annotations__</td><td>函数形参、返回值的类型注解</td></tr><tr><td>__code__</td><td>函数的字节码对象</td></tr><tr><td>__defaults__</td><td>函数默认参数信息</td></tr></tbody></table> 
<p>请仔细看，下面给出一个未被装饰的函数。</p> 
<pre><code class="prism language-python"><span class="token keyword">def</span> <span class="token function">example</span><span class="token punctuation">(</span>num<span class="token punctuation">:</span> <span class="token builtin">int</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">int</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">"""
    return the number + 1
    :param num: an int number
    :return: num + 1
    """</span>
    <span class="token keyword">return</span> num <span class="token operator">+</span> <span class="token number">1</span>
</code></pre> 
<p>我们打印一下它的元数据信息。</p> 
<pre><code class="prism language-python"><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"__name__:  </span><span class="token interpolation"><span class="token punctuation">{<!-- --></span>example<span class="token punctuation">.</span>__name__<span class="token punctuation">}</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"__doc__: </span><span class="token interpolation"><span class="token punctuation">{<!-- --></span>example<span class="token punctuation">.</span>__doc__<span class="token punctuation">}</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"__annotations__: </span><span class="token interpolation"><span class="token punctuation">{<!-- --></span>example<span class="token punctuation">.</span>__annotations__<span class="token punctuation">}</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"__code__: </span><span class="token interpolation"><span class="token punctuation">{<!-- --></span>example<span class="token punctuation">.</span>__code__<span class="token punctuation">}</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"__defaults__: </span><span class="token interpolation"><span class="token punctuation">{<!-- --></span>example<span class="token punctuation">.</span>__defaults__<span class="token punctuation">}</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/8c/8f/A3ASZblQ_o.png" alt="未被装饰函数的元数据信息打印"><br> 现在我们将该函数用下面的装饰器函数进行装饰一下。</p> 
<pre><code class="prism language-python"><span class="token keyword">def</span> <span class="token function">decorator</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">:</span>
	<span class="token keyword">def</span> <span class="token function">wrapper</span><span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>
		<span class="token keyword">return</span> func<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span>
	<span class="token keyword">return</span> wrapper
</code></pre> 
<p>再打印一下元数据。<br> <img src="https://images2.imgbox.com/9d/6d/kdX2acru_o.png" alt="装饰后函数的元数据信息打印"><br> 可以看到“一切都变了”，因为现在虽然你使用的是<code>example</code>这个变量，但是这个变量存储的并不是原函数的引用，而是一个装饰器中wrapper函数对象的引用。这种特性与<strong>装饰</strong>的理念并不相符，因为这种装饰行为没有很好地保持被装饰对象的外观。元数据最大的作用就是提高代码的可读性，其中的默认参数、类型注解、函数文档等信息对于程序员的开发十分有帮助。<strong>理想状态下，被装饰函数的关键元数据不应该发生改变。</strong><br> 要做到这一点，简单粗暴地，可以在返回<code>wrapper</code>对象之前将<code>wrapper</code>的元数据修改为原函数的版本。但是更<strong>优雅的做法是使用Python内置包<code>functools</code>中的<code>wraps</code>方法</strong>，来对装饰器函数进行额外装饰，下面是一个示例。</p> 
<pre><code class="prism language-python"><span class="token keyword">from</span> functools <span class="token keyword">import</span> wraps
<span class="token comment"># 可以保存原函数元数据的装饰器</span>
<span class="token keyword">def</span> <span class="token function">decorator</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">:</span>
	<span class="token decorator annotation punctuation">@wraps</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span>
	<span class="token keyword">def</span> <span class="token function">wrapper</span><span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>
		<span class="token keyword">return</span> func<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span>
	<span class="token keyword">return</span> wrapper
</code></pre> 
<p>通过<code>wraps</code>对装饰器返回的函数对象类型进行装饰，可以将原函数的元数据进行完整载入，以避免装饰行为对目标函数元数据的影响。对原理感兴趣的可以去看看<a href="https://docs.python.org/3/library/functools.html#functools.wraps" rel="nofollow">文档</a>，这里不展开描述。</p> 
<p>以上就是本篇文章的全部内容，希望对你能有帮助。</p> 
<p>在下水平有限，如有不当，烦请不吝赐教。</p> 
<h2><a id="_234"></a>参考文档</h2> 
<p><a href="https://docs.python.org/3/reference/compound_stmts.html#function" rel="nofollow">1. Python函数定义Reference文档</a><br> <a href="https://docs.python.org/3/glossary.html#term-decorator" rel="nofollow">2. Python装饰器文档</a><br> <a href="https://docs.python.org/3/reference/compound_stmts.html#class" rel="nofollow">3. Python类定义文档</a><br> <a href="https://docs.python.org/3/library/functools.html#functools.wraps" rel="nofollow">4. Python内置方法 functools.wraps文档</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/1411fdc054447f6c7bdf1dc306b0dbb6/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">fastadmin的弹出窗口，如何调整尺寸？</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/2f79c0fbc22e6c28888e60970b9be0b5/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">ant-design-vue。下拉框a-select设置样式不显示的</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>