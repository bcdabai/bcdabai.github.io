<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>IOC概念和原理 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="IOC概念和原理" />
<meta property="og:description" content="目录
1.什么是IOC
2.IOC的底层原理
3.IOC过程
4.IOC总结
​​​​​​​
1.什么是IOC IOC即为控制反转，把对象的创建和对象之间的调用过程，交给Spring管理。不需要像se阶段一样new对象。
使用IOC的目的：为了降低耦合度。所谓耦合度就是某模块（类）与其它模块（类）之间的关联、感知和依赖的程度，是衡量代码独立性的一个指标，也是软件工程设计及编码质量评价的一个标准。
2.IOC的底层原理 假如有以上俩个类，传统创建对象我们需要在UesrService类中调用uesrDao中add方法需要先在UesrService中new uesrDao的对象，再调用方法。
传统创建对象致命问题：耦合度高，关联过于紧密，牵一发动全身。
为了降低耦合度，解决方案如下文。
建一个工厂类
通过工厂的设计模式，在UserFactory中返回创建的对象，对象在工厂中得到。这个过程只是降低了UserService和UserDao的耦合度，没有降低到最大限度。此时需要ioc。
3.IOC过程 1.配置xml文件，配置要创建的对象
&lt;bean id=&#34;名字&#34; class=&#34;路径&#34;&gt;&lt;/bean&gt; 2.假如有上service类和dao类，创建工厂类
class UserFactory { public static UserDao getDao() { String classValue=class属性值; //通过xml解析得到class的值 //通过反射得到对象 Calss clazz=class.forName(classValue); return (UserDao)clazz.newInstance(); //调用newInstance方法此时返回的也是UserDao对象 } } 此时只要修改xml的配置文件，就可以通过工厂返回对象。耦合度进一步降低。
用Spring框架就是简化代码，把耦合度降低。
4.IOC总结 1.IOC本质是个容器，本质上是对象工厂，通过读取配置文件，再通过它用反射来完成。
2.Spring提供的IOC容器的俩种实现方式（俩个接口）：
public class Spring5Test { @Test public void test(){ //加载spring配置文件，ApplicationContext 在加载配置文件时就会创建对象，BeanFactory在下面获取创建对象的时候才会创建对象 ApplicationContext context =new ClassPathXmlApplicationContext(&#34;bean1.xml&#34;); //获取配置创建的对象，BeanFactory在此时才会创建对象 User user=context.getBean(&#34;user&#34;,User.class); user.add(); } } 1.BeanFactory：IOC容器基本实现方式，Spring内部使用接口，一般不提供开发人员使用。
特点：加载配置文件，不会去创建对象。在获取或使用对象时才创建对象。
2.ApplicationContext：可以理解成BeanFactory子接口，比BeanFactory更加强大。面向开发人员。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/dda94d0848cbc24114a7809673021700/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-10-03T22:21:52+08:00" />
<meta property="article:modified_time" content="2021-10-03T22:21:52+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">IOC概念和原理</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="-toc" style="margin-left:0px;"></p> 
<p id="1.%E4%BB%80%E4%B9%88%E6%98%AFIOC-toc" style="margin-left:0px;"><a href="#1.%E4%BB%80%E4%B9%88%E6%98%AFIOC" rel="nofollow" title="1.什么是IOC">1.什么是IOC</a></p> 
<p id="2.IOC%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86-toc" style="margin-left:0px;"><a href="#2.IOC%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86" rel="nofollow" title="2.IOC的底层原理">2.IOC的底层原理</a></p> 
<p id="3.IOC%E8%BF%87%E7%A8%8B-toc" style="margin-left:0px;"><a href="#3.IOC%E8%BF%87%E7%A8%8B" rel="nofollow" title="3.IOC过程">3.IOC过程</a></p> 
<p id="4.IOC%E6%80%BB%E7%BB%93-toc" style="margin-left:0px;"><a href="#4.IOC%E6%80%BB%E7%BB%93" rel="nofollow" title="4.IOC总结">4.IOC总结</a></p> 
<hr id="hr-toc"> 
<p>​​​​​​​</p> 
<h2 id="1.%E4%BB%80%E4%B9%88%E6%98%AFIOC"><strong>1.什么是IOC</strong></h2> 
<p> </p> 
<p><br> IOC即为<strong>控制反转</strong>，把对象的创建和对象之间的调用过程，交给Spring管理。不需要像se阶段一样new对象。<br> 使用IOC的目的：<strong>为了降低耦合度</strong>。所谓耦合度就是某模块（类）与其它模块（类）之间的关联、感知和依赖的程度，是衡量代码独立性的一个指标，也是软件工程设计及编码质量评价的一个标准。</p> 
<h2 id="2.IOC%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><br><strong>2.IOC的底层原理</strong></h2> 
<p></p> 
<p><img alt="" src="https://images2.imgbox.com/34/c2/NUHeKCd0_o.png"></p> 
<p></p> 
<p>假如有以上俩个类，传统创建对象我们需要在UesrService类中调用uesrDao中add方法需要先在UesrService中new uesrDao的对象，再调用方法。</p> 
<p><strong>传统创建对象致命问题：耦合度高，关联过于紧密，牵一发动全身。</strong></p> 
<p></p> 
<p>为了降低耦合度，解决方案如下文。</p> 
<p></p> 
<p>建一个工厂类</p> 
<p><img alt="" src="https://images2.imgbox.com/90/d4/RgWUwTo2_o.png"></p> 
<p> <strong>通过工厂的设计模式，在UserFactory中返回创建的对象，对象在工厂中得到。这个过程只是降低了UserService和UserDao的耦合度，没有降低到最大限度。此时需要ioc。</strong></p> 
<p></p> 
<h2 id="3.IOC%E8%BF%87%E7%A8%8B"><strong>3.IOC过程</strong></h2> 
<p><strong>1.配置xml文件，配置要创建的对象</strong></p> 
<pre><code>&lt;bean id="名字" class="路径"&gt;&lt;/bean&gt;</code></pre> 
<p></p> 
<p>2.假如有上service类和dao类，<strong>创建工厂类</strong></p> 
<pre><code>class UserFactory {
public static UserDao getDao() {
String classValue=class属性值;      //通过xml解析得到class的值
 
//通过反射得到对象
 
Calss clazz=class.forName(classValue);
 
return  (UserDao)clazz.newInstance();   //调用newInstance方法此时返回的也是UserDao对象
}
}</code></pre> 
<p><br>  </p> 
<p><strong>此时只要修改xml的配置文件，就可以通过工厂返回对象。耦合度进一步降低。</strong></p> 
<p><strong>用Spring框架就是简化代码，把耦合度降低。</strong></p> 
<h2 id="4.IOC%E6%80%BB%E7%BB%93"><strong>4.IOC总结</strong></h2> 
<p><strong>1.IOC本质是个容器，本质上是对象工厂，通过读取配置文件，再通过它用反射来完成。</strong></p> 
<p><strong>2.Spring提供的IOC容器的俩种实现方式（俩个接口）：</strong></p> 
<pre><code>public class Spring5Test {
    @Test
    public  void test(){
 
        //加载spring配置文件，ApplicationContext 在加载配置文件时就会创建对象，BeanFactory在下面获取创建对象的时候才会创建对象
        ApplicationContext context =new ClassPathXmlApplicationContext("bean1.xml");
 
        //获取配置创建的对象，BeanFactory在此时才会创建对象
        User user=context.getBean("user",User.class);
 
        user.add();
    }
 
}</code></pre> 
<p><strong>1.BeanFactory</strong>：IOC容器基本实现方式，Spring内部使用接口，一般不提供开发人员使用。</p> 
<p>特点：加载配置文件，不会去创建对象。在获取或使用对象时才创建对象。</p> 
<p><strong>2.ApplicationContext</strong>：可以理解成BeanFactory子接口，比BeanFactory更加强大。面向开发人员。</p> 
<p>特点：加载配置文件，就会去创建对象。一般使用第二种。</p> 
<p><strong>3.ApplicationContext实现类</strong><br><img alt="" src="https://images2.imgbox.com/7c/48/DRRX9q7a_o.png"></p> 
<p> <img alt="" src="https://images2.imgbox.com/0c/d5/nbw9J6yF_o.png"></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/816181835736028b693ec29598da4712/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">ThreadLocal从变量副本的角度解决多线程并发安全问题</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/58bb53a6d7acdd5ff8ce5bb20a8e72d4/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【c语言进阶】如此清晰的指针讲解让你再也不怕学不会指针了，硬核指针讲解。</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>