<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>面试官问：你熟悉哪些HashMap的封装扩展类？ - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="面试官问：你熟悉哪些HashMap的封装扩展类？" />
<meta property="og:description" content="我习惯了无所谓，却不是真的什么都不在乎。 请关注：源码猎人
目录
简介
LinkedHashMap 源码解读
LinkedHashMap属性
LinkedHashMap构造函数
LinkedHashMap 方法
LinkedHashMap 内部类
LinkedHashMap.Entry,v&gt;
HashSet 类源码解读
HashSet 属性
HashSet 构造函数
HashSet 方法
LinkedHashSet 类源码解读
LinkedHashSet 构造函数
常见面试题
简介 LinkedHashMap、HashSet、LinkedHashSet都扩展了HashMap。它们是HashMap的二次封装，LinkedHashMap加入了一个单独链表存所有数据，并且完整保留HashMap结构。 HashSet 实际上只用到了HashMap的键，值为常量；LinkedHashSet 继承HashSet，并且和LinkedHashMap一样内部维护一个链表。
LinkedHashMap 源码解读 public class LinkedHashMap&lt;K,V&gt; extends HashMap&lt;K,V&gt; implements Map&lt;K,V&gt; LinkedHashMap属性 // 链表头结点 transient LinkedHashMap.Entry&lt;K,V&gt; head; // 链表尾结点 transient LinkedHashMap.Entry&lt;K,V&gt; tail; // LRU算法相关 false 基于插入顺序，true 基于访问顺序 final boolean accessOrder; LinkedHashMap构造函数 public LinkedHashMap(int initialCapacity, float loadFactor) { super(initialCapacity, loadFactor); // 默认使用插入顺序 accessOrder = false; } public LinkedHashMap(int initialCapacity) { super(initialCapacity); // 默认使用插入顺序 accessOrder = false; } public LinkedHashMap() { super(); // 默认使用插入顺序 accessOrder = false; } public LinkedHashMap(Map&lt;?" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/c5bef70d0416c88217d597ac6e793c18/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-06-16T22:05:47+08:00" />
<meta property="article:modified_time" content="2020-06-16T22:05:47+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">面试官问：你熟悉哪些HashMap的封装扩展类？</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><img alt="" src="https://images2.imgbox.com/ba/11/LgeM8jGV_o.png"></p> 
<p><em>我习惯了无所谓，却不是真的什么都不在乎。                 请关注：源码猎人</em></p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E7%AE%80%E4%BB%8B-toc" style="margin-left:0px;"><a href="#%E7%AE%80%E4%BB%8B" rel="nofollow">简介</a></p> 
<p id="LinkedHashMap%20%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-toc" style="margin-left:0px;"><a href="#LinkedHashMap%20%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB" rel="nofollow">LinkedHashMap 源码解读</a></p> 
<p id="LinkedHashMap%E5%B1%9E%E6%80%A7-toc" style="margin-left:40px;"><a href="#LinkedHashMap%E5%B1%9E%E6%80%A7" rel="nofollow">LinkedHashMap属性</a></p> 
<p id="LinkedHashMap%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-toc" style="margin-left:40px;"><a href="#LinkedHashMap%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0" rel="nofollow">LinkedHashMap构造函数</a></p> 
<p id="LinkedHashMap%20%E6%96%B9%E6%B3%95-toc" style="margin-left:40px;"><a href="#LinkedHashMap%20%E6%96%B9%E6%B3%95" rel="nofollow">LinkedHashMap 方法</a></p> 
<p id="LinkedHashMap%20%E5%86%85%E9%83%A8%E7%B1%BB-toc" style="margin-left:40px;"><a href="#LinkedHashMap%20%E5%86%85%E9%83%A8%E7%B1%BB" rel="nofollow">LinkedHashMap 内部类</a></p> 
<p id="LinkedHashMap.Entry%3CK%2CV%3E-toc" style="margin-left:80px;"><a href="#LinkedHashMap.Entry%3CK%2CV%3E" rel="nofollow">LinkedHashMap.Entry,v&gt;</a></p> 
<p id="HashSet%20%E7%B1%BB%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-toc" style="margin-left:0px;"><a href="#HashSet%20%E7%B1%BB%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB" rel="nofollow">HashSet 类源码解读</a></p> 
<p id="HashSet%20%E5%B1%9E%E6%80%A7-toc" style="margin-left:40px;"><a href="#HashSet%20%E5%B1%9E%E6%80%A7" rel="nofollow">HashSet 属性</a></p> 
<p id="HashSet%20%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-toc" style="margin-left:40px;"><a href="#HashSet%20%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0" rel="nofollow">HashSet 构造函数</a></p> 
<p id="HashSet%20%E6%96%B9%E6%B3%95-toc" style="margin-left:40px;"><a href="#HashSet%20%E6%96%B9%E6%B3%95" rel="nofollow">HashSet 方法</a></p> 
<p id="LinkedHashSet%20%E7%B1%BB%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-toc" style="margin-left:0px;"><a href="#LinkedHashSet%20%E7%B1%BB%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB" rel="nofollow">LinkedHashSet 类源码解读</a></p> 
<p id="LinkedHashSet%20%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-toc" style="margin-left:40px;"><a href="#LinkedHashSet%20%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0" rel="nofollow">LinkedHashSet 构造函数</a></p> 
<p id="%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98-toc" style="margin-left:0px;"><a href="#%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98" rel="nofollow">常见面试题</a></p> 
<hr id="hr-toc"> 
<h2 id="%E7%AE%80%E4%BB%8B">简介</h2> 
<p>LinkedHashMap、HashSet、LinkedHashSet都扩展了HashMap。它们是HashMap的二次封装，LinkedHashMap加入了一个单独链表存所有数据，并且完整保留HashMap结构。 HashSet 实际上只用到了HashMap的键，值为常量；LinkedHashSet 继承HashSet，并且和LinkedHashMap一样内部维护一个链表。</p> 
<h2 id="LinkedHashMap%20%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB">LinkedHashMap 源码解读</h2> 
<pre><code class="language-java">public class LinkedHashMap&lt;K,V&gt; extends HashMap&lt;K,V&gt; implements Map&lt;K,V&gt;</code></pre> 
<h3 id="LinkedHashMap%E5%B1%9E%E6%80%A7"><strong>LinkedHashMap属性</strong></h3> 
<pre><code class="language-java">// 链表头结点
transient LinkedHashMap.Entry&lt;K,V&gt; head;
// 链表尾结点
transient LinkedHashMap.Entry&lt;K,V&gt; tail;
// LRU算法相关  false 基于插入顺序，true 基于访问顺序 
final boolean accessOrder;</code></pre> 
<h3 id="LinkedHashMap%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><strong>LinkedHashMap构造函数</strong></h3> 
<pre><code class="language-java">public LinkedHashMap(int initialCapacity, float loadFactor) {
    super(initialCapacity, loadFactor);
    // 默认使用插入顺序
    accessOrder = false;
}
public LinkedHashMap(int initialCapacity) {
    super(initialCapacity);
    // 默认使用插入顺序
    accessOrder = false;
}
public LinkedHashMap() {
    super();
    // 默认使用插入顺序
    accessOrder = false;
}
public LinkedHashMap(Map&lt;? extends K, ? extends V&gt; m) {
    super();
    accessOrder = false;
    // 默认使用插入顺序
    putMapEntries(m, false);
}
public LinkedHashMap(int initialCapacity,
                     float loadFactor,
                     boolean accessOrder) {
    super(initialCapacity, loadFactor);
    // 自定义顺序
    this.accessOrder = accessOrder;
}</code></pre> 
<p>从构造函数中可以看出，LinkedHashMap几乎完全使用HashMap的构造方法初始化（参照HashMap类篇），至于初始长度和加载因子也是延用HashMap，LinkedHashMap类自身只关注链表结构，数字加链表结构交给父类去维护</p> 
<h3 id="LinkedHashMap%20%E6%96%B9%E6%B3%95">LinkedHashMap 方法</h3> 
<p><strong>根据键取值</strong></p> 
<pre><code class="language-java">public V get(Object key) {
    Node&lt;K,V&gt; e;
    if ((e = getNode(hash(key), key)) == null)
        return null;
    if (accessOrder)
        afterNodeAccess(e);
    return e.value;
}</code></pre> 
<p>实际上就是调用HashMap的getNode方法， afterNodeAccess(e)方法只是为了维护顺序，除了这个方法LinkedHashMap没有添加删除方法，那么他是怎么维护链表结构的呢？是否还记得在HashMap篇有几个方法要放在LinkedHashMap讲</p> 
<pre><code class="language-java">void afterNodeAccess(Node&lt;K,V&gt; p) { }
void afterNodeInsertion(boolean evict) { }
void afterNodeRemoval(Node&lt;K,V&gt; p) { }</code></pre> 
<p>这几个方法出现在HashMap元素增加或减少之后，就是为了给hashMap子类使用</p> 
<p><strong>父类元素变动后方法</strong></p> 
<pre><code class="language-java">// HashMap删除节点后
void afterNodeRemoval(Node&lt;K,V&gt; e) {
    LinkedHashMap.Entry&lt;K,V&gt; p =
            (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;
    p.before = p.after = null;
    if (b == null)
        // 如果是头节点，则把头节的下一个节点设为头节点
        head = a;
    else
        // 否则，把前一个节点的下一个节点指向当前下一个节点
        b.after = a;
    if (a == null)
        // 如果是尾节点，设置当前节点前一个节点为尾节点
        tail = b;
    else
        // 否则把后面节点的前面执行当前节点的前面
        a.before = b;
}</code></pre> 
<p>HashMap删除元素成功后会调用此方法afterNodeRemoval</p> 
<pre><code class="language-java">// 插入成功删除头节点
void afterNodeInsertion(boolean evict) { // possibly remove eldest
    LinkedHashMap.Entry&lt;K,V&gt; first;
    if (evict &amp;&amp; (first = head) != null &amp;&amp; removeEldestEntry(first)) {
        K key = first.key;
        removeNode(hash(key), key, null, false, true);
    }
}</code></pre> 
<p>afterNodeInsertion方法是在哈希表中插入了一个新节点时调用的，它会把链表的头节点删除掉，删除的方式是通过调用HashMap的removeNode方法。我们要使用此功能必须重写removeEldestEntry方法</p> 
<pre><code class="language-java">// accessOrder为true时将节点移到最后
void afterNodeAccess(Node&lt;K,V&gt; e) { // move node to last
    LinkedHashMap.Entry&lt;K,V&gt; last;
    if (accessOrder &amp;&amp; (last = tail) != e) {
        LinkedHashMap.Entry&lt;K,V&gt; p =
                (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;
        p.after = null;
        if (b == null)
            head = a;
        else
            b.after = a;
        if (a != null)
            a.before = b;
        else
            last = b;
        if (last == null)
            head = p;
        else {
            p.before = last;
            last.after = p;
        }
        tail = p;
        ++modCount;
    }
}</code></pre> 
<p>当accessOrder设置为true时，把当前节点e移至链表的尾部，在HashMap的putVal方法中，会调用此方法</p> 
<h3 id="LinkedHashMap%20%E5%86%85%E9%83%A8%E7%B1%BB">LinkedHashMap 内部类</h3> 
<h4 id="LinkedHashMap.Entry%3CK%2CV%3E"><strong>LinkedHashMap.Entry&lt;K,V&gt;</strong></h4> 
<pre><code class="language-java">static class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; {
    // 前一个结点，后一个节点
    Entry&lt;K,V&gt; before, after;
    Entry(int hash, K key, V value, Node&lt;K,V&gt; next) {
        super(hash, key, value, next);
    }
}</code></pre> 
<p>此内部类在HashMap中也用到，HashMap的TreeNode就是继承此类（是不是很绕）</p> 
<h2 id="HashSet%20%E7%B1%BB%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB"><strong>HashSet 类源码解读</strong></h2> 
<pre><code class="language-java">public class HashSet&lt;E&gt; extends AbstractSet&lt;E&gt;
        implements Set&lt;E&gt;, Cloneable, java.io.Serializable</code></pre> 
<p>跟ArraryList相比没有实现RandomAccess接口，接下来看成员变量和构造函数</p> 
<h3 id="HashSet%20%E5%B1%9E%E6%80%A7"><strong>HashSet 属性</strong></h3> 
<pre><code class="language-java">// 底层是HashMap实现的   
private transient HashMap&lt;E,Object&gt; map;
// PRESENT是一个假的value值，帮助用HashMap实现HashSet。
private static final Object PRESENT = new Object();</code></pre> 
<h3 id="HashSet%20%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><strong>HashSet 构造函数</strong></h3> 
<pre><code class="language-java">public HashSet() {
    map = new HashMap&lt;&gt;();
}
public HashSet(Collection&lt;? extends E&gt; c) {
    map = new HashMap&lt;&gt;(Math.max((int) (c.size()/.75f) + 1, 16));
    addAll(c);
}
public HashSet(int initialCapacity, float loadFactor) {
    map = new HashMap&lt;&gt;(initialCapacity, loadFactor);
}
public HashSet(int initialCapacity) {
    map = new HashMap&lt;&gt;(initialCapacity);
}
public HashSet(Collection&lt;? extends E&gt; c) {
    map = new HashMap&lt;&gt;(Math.max((int) (c.size()/.75f) + 1, 16));
    addAll(c);
}</code></pre> 
<p>通过构造函数可以看出HashSet的初始化时内部构建了一个HashMap对象</p> 
<pre><code class="language-java">HashSet(int initialCapacity, float loadFactor, boolean dummy) {
    map = new LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);
}</code></pre> 
<p>此构造函数安全级别为默认，只有自己或同包子类可以调用。HashSet并没有调用它，它是给子类使用的，跟上面构造函数唯一的区别就是内部Map换成LinkedHashMap&lt;&gt;对象</p> 
<h3 id="HashSet%20%E6%96%B9%E6%B3%95"><strong>HashSet 方法</strong></h3> 
<pre><code class="language-java">// 获取长度
public int size() {
    return map.size();
}
// 是否为空
public boolean isEmpty() {
    return map.isEmpty();
}
// 是否包含
public boolean contains(Object o) {
    return map.containsKey(o);
}
// 添加元素
public boolean add(E e) {
    // 添加元素时，元素为键，值为固定常量存入Map
    return map.put(e, PRESENT)==null;
}
// 删除元素
public boolean remove(Object o) {
    return map.remove(o)==PRESENT;
}
// 清空
public void clear() {
    map.clear();
}</code></pre> 
<blockquote> 
 <p>HashSet只是用了HashMap的key，而值是一个固定的常量，所以HashMap的key拥有哪些特性HashSet就拥有哪些特性。</p> 
</blockquote> 
<h2 id="LinkedHashSet%20%E7%B1%BB%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB"><strong>LinkedHashSet 类源码解读</strong></h2> 
<pre><code class="language-java">public class LinkedHashSet&lt;E&gt; extends HashSet&lt;E&gt;
        implements Set&lt;E&gt;, Cloneable, java.io.Serializable</code></pre> 
<p>LinkedHashSet完成继承HashSet，内部只有构造函数</p> 
<h3 id="LinkedHashSet%20%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><strong>LinkedHashSet 构造函数</strong></h3> 
<pre><code class="language-java">public LinkedHashSet(int initialCapacity, float loadFactor) {
    super(initialCapacity, loadFactor, true);
}
public LinkedHashSet(int initialCapacity) {
    super(initialCapacity, .75f, true);
}
public LinkedHashSet() {
    super(16, .75f, true);
}
public LinkedHashSet(Collection&lt;? extends E&gt; c) {
    super(Math.max(2*c.size(), 11), .75f, true);
    addAll(c);
}</code></pre> 
<p>LinkedHashSet 所有构造函数都调用HashSet的HashSet(int initialCapacity, float loadFactor, boolean dummy)构造函数，内部使用LinkedHashMap对象</p> 
<h2 id="%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98">常见面试题</h2> 
<p><strong>1.说一下LinkedHashMap的数据结构</strong></p> 
<p>LinkedHashMap继承自HashMap，并维持了一个双向链表。插入节点时，将节点追加到双向链表尾部，从而实现按照插入顺序的有序访问。也可以在初始化LinkedHashMap对象时设定为按照访问顺序排序，此时每当访问一个节点，afternodeaccess方法就会将该节点放到双向链表的尾部，从而实现按照访问顺序的有序遍历访问。</p> 
<p><strong>2、请说说HashSet原理</strong></p> 
<p>HashSet在存元素时，会调用对象的hashCode方法计算出存储位置，然后和该位置上所有的元素进行equals比较，<br> 如果该位置没有其他元素或者比较的结果都为false就存进去，否则就不存。这样的原理注定了元素是按照哈希值来找存储位置，所有无序，而且可以保证无重复元素，我们在往HashSet集合存储元素时，对象应该正确重写Object类的hashCode和equals方法<br> 正因为这样的原理，HashSet集合是非常高效的。</p> 
<p><strong>3、为什么HashMap中String、Integer这样的包装类适合作为K？</strong></p> 
<p>String、Integer等包装类的特性能够保证Hash值的不可更改性和计算准确性，能够有效的减少Hash碰撞的几率</p> 
<ul><li>都是final类型，即不可变性，保证key的不可更改性，不会存在获取hash值不同的情况</li><li>内部已重写了<code>equals()</code>、<code>hashCode()</code>等方法，遵守了HashMap内部的规范（不清楚可以去上面看看putValue的过程），不容易出现Hash值计算错误的情况</li></ul> 
<p>如果Object作为键，那么需要重写<code>hashCode()</code>和<code>equals()</code>方法</p> 
<ul><li>重写<code>hashCode()</code>是因为需要计算存储数据的存储位置，需要注意不要试图从散列码计算中排除掉一个对象的关键部分来提高性能，这样虽然能更快但可能会导致更多的Hash碰撞</li><li>重写<code>equals()</code>方法，需要遵守自反性、对称性、传递性、一致性以及对于任何非null的引用值x，x.equals(null)必须返回false的这几个特性，目的是为了保证key在哈希表中的唯一性</li></ul> 
<p><strong>4、HashMap 和 LinkedHashMap 有什么区别？</strong></p> 
<ul><li>LinkedHashMap 拥有与 HashMap 相同的底层哈希表结构，即数组 + 单链表 + 红黑树，也拥有相同的扩容机制。</li><li>LinkedHashMap 相比 HashMap 的拉链式存储结构，内部额外通过 Entry 维护了一个双向链表。</li><li>HashMap 元素的遍历顺序不一定与元素的插入顺序相同，而 LinkedHashMap 则通过遍历双向链表来获取元素，所以遍历顺序在一定条件下等于插入顺序。</li></ul> 
<p><strong>5、ArrayList 与 LinkedList 有什么区别 ?</strong></p> 
<ul><li>存储结构上 ArrayList 底层使用数组进行元素的存储，LinkedList 使用双向链表作为存储结构。</li><li>两者均与允许存储 null 也允许存储重复元素。</li><li>在性能上 ArrayList 在存储大量元素时候的增删效率 平均低于 LinkedList，因为 ArrayList 在增删的是需要拷贝元素到新的数组，而 LinkedList 只需要将节点前后指针指向改变。</li><li>在根据角标获取元素的时间效率上ArrayList优于 LinkedList，因为数组本身有存储连续，有 index 角标，而 LinkedList 存储元素离散，需要遍历链表。</li><li>不要使用 for 循环去遍历 LinkedList 因为效率很低。</li><li>两者都是线程不安全的，都可以使用 Collections.synchronizedList(List&lt;E&gt; list) 方法生成一个线程安全的 List。</li></ul> 
<p> </p> 
<p><img alt="" src="https://images2.imgbox.com/e2/e7/FurdmFyD_o.png"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/fc725db3dbe00a5c0f00005c8610bdc1/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">习题8-5 使用函数实现字符串部分复制 (20分)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3aa9533c2062c9f528c0aaae7ad5c2e6/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">STM32CubeMX学习笔记五 《GPIO 外部中断》</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>