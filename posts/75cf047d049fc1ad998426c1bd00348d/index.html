<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>线性方程组求解 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="线性方程组求解" />
<meta property="og:description" content="初来乍到，多多指教！
问题：
线性方程组求解
输入是N（N&lt;256）元线性方程组Ax=B，输出是方程组的解，也可能无解
或有多组解。可以用高斯消去法求解，也可以采用其它方法。
1.高斯消元：通过增广矩阵将系数与常数集中放在一起，利用增广矩阵性质
将矩形变为\形，再倒着依次求出相关变量值
2.矩形变\形：通过依次以1~n行为操作对象，将此行以下的行首系数与此行首系数比较，化同，做差即为消去系数少一个变量的方程，如此，最后形成的方阵便是\形
3.从后回代求解：在矩阵变\形时，对每行行首系数化为一，若此行为第i&#43;1行，则第i行第i&#43;1列未知量就是此行行首未知量，因为行首系数为1，则第i行方程减去第i&#43;1行方程的a[i][i&#43;1]倍（第i行第i&#43;1列未知量的系数）即得到第i行行首未知量，如此循环得到所有变量。
4.解的判定：高斯消元后，若是标准的\形，有唯一解；若消元后的行数小于n行（元的个数）且没有出现0=常数（矛盾）的情况，则有多解，若出现0=常数的情况，则无解。
附上源代码
#include&lt;iostream&gt;
#include &lt;cmath&gt;
#include&lt;iomanip&gt;
using namespace std;
const int N = 260;
const double eps = 1e-6;//double精度
double a[N][N];
int n,i,j;
int work(int x)
{
//矩形变\形
//每循环一次重新定义一次，这样可以同时记录有几行，可以与原行数进行比较，进而判断解的情况
int c=0, r=0;//c表示在枚举哪一列，r表示在枚举哪一行
//高斯消元
for (; c &lt; x; c&#43;&#43;)
{
int maxr = r;
for (i = r; i &lt; x; i&#43;&#43;)//列不变，行变，找到对应系数绝对值最大的交换，减小误差
{
if (fabs(a[i][c]) &gt; fabs(a[maxr][c]))//定位到当前列主元的最大系数所在行 maxr = i;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/75cf047d049fc1ad998426c1bd00348d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-02-24T23:46:49+08:00" />
<meta property="article:modified_time" content="2023-02-24T23:46:49+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">线性方程组求解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div class="kdocs-document"> 
 <p style="text-align:null;">初来乍到，多多指教！</p> 
 <p style="text-align:null;"><span class="kdocs-bold" style="font-weight:bold;"><span class="kdocs-italic" style="font-style:italic;">问题：</span></span></p> 
 <p style="text-indent:1.4em;padding-left:1.4em;text-align:left;"><span class="kdocs-fontSize" style="font-size:13pt;"><span class="kdocs-bold" style="font-weight:bold;">线性方程组求解</span></span></p> 
 <p style="text-indent:1.4em;padding-left:1.4em;text-align:left;">输入是N（N&lt;256）元线性方程组Ax=B，输出是方程组的解，也可能无解</p> 
 <p style="text-indent:1.4em;padding-left:1.4em;text-align:null;">或有多组解。可以用高斯消去法求解，也可以采用其它方法。</p> 
 <p style="text-align:null;"><span class="kdocs-bold" style="font-weight:bold;">1.高斯消元</span>：通过增广矩阵将系数与常数集中放在一起，利用增广矩阵性质</p> 
 <p style="text-align:null;">将矩形变为\形，再倒着依次求出相关变量值</p> 
 <p style="text-align:null;"><span class="kdocs-bold" style="font-weight:bold;">2.矩形变\形</span>：通过依次以1~n行为操作对象，将此行以下的行首系数与此行首系数比较，化同，做差即为消去系数少一个变量的方程，如此，最后形成的方阵便是\形</p> 
 <p style="text-align:null;"><span class="kdocs-bold" style="font-weight:bold;">3.从后回代求解</span>：在矩阵变\形时，对每行行首系数化为一，若此行为第i+1行，则第i行第i+1列未知量就是此行行首未知量，因为行首系数为1，则第i行方程减去第i+1行方程的a[i][i+1]倍（第i行第i+1列未知量的系数）即得到第i行行首未知量，如此循环得到所有变量。</p> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:1224px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:32.598038%;height:0;"> 
    <img src="https://images2.imgbox.com/cc/fc/Kveyc1DQ_o.png" style="margin-left:;display:block;width:1224px;margin-top:-32.598038%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style=""><span class="kdocs-bold" style="font-weight:bold;">4.解的判定：</span>高斯消元后，若是标准的\形，有唯一解；若消元后的行数小于n行（元的个数）且没有出现0=常数（矛盾）的情况，则有多解，若出现0=常数的情况，则无解。</p> 
 <p style=""><span class="kdocs-color" style="background-color:#FBF5B3;">附上源代码</span></p> 
 <p style=""></p> 
 <p style="">#include&lt;iostream&gt;</p> 
 <p style="">#include &lt;cmath&gt;</p> 
 <p style="">#include&lt;iomanip&gt;</p> 
 <p style="">using namespace std;</p> 
 <p style="">const int N = 260;</p> 
 <p style="">const double eps = 1e-6;//double精度</p> 
 <p style="">double a[N][N];</p> 
 <p style="">int n,i,j;</p> 
 <p style="">int work(int x)</p> 
 <p style="">{<!-- --></p> 
 <p style="">//矩形变\形</p> 
 <p style="">//每循环一次重新定义一次，这样可以同时记录有几行，可以与原行数进行比较，进而判断解的情况</p> 
 <p style="">int c=0, r=0;//c表示在枚举哪一列，r表示在枚举哪一行</p> 
 <p style="">//高斯消元</p> 
 <p style="">for (; c &lt; x; c++)</p> 
 <p style="">{<!-- --></p> 
 <p style="">int maxr = r;</p> 
 <p style="">for (i = r; i &lt; x; i++)//列不变，行变，找到对应系数绝对值最大的交换，减小误差</p> 
 <p style="">{<!-- --></p> 
 <p style="">if (fabs(a[i][c]) &gt; fabs(a[maxr][c]))//定位到当前列主元的最大系数所在行 </p> 
 <p style="">maxr = i;</p> 
 <p style="">}</p> 
 <p style="">if (fabs(a[maxr][c]) &lt; eps) continue;//是造成r&lt;n无解的一个原因</p> 
 <p style="">for (i = c; i &lt;= x; i++)swap(a[maxr][i], a[r][i]);//交换这两行 </p> 
 <p style="">for (i = x; i &gt;= c; i--)a[r][i] /= a[r][c];//这一行同除，行首系数化一 便于下边a[i][n]得出的就是Xi的值</p> 
 <p style="">for ( i = r + 1; i &lt; x; i++)</p> 
 <p style="">{<!-- --></p> 
 <p style="">if (fabs(a[i][c]) &gt; eps)</p> 
 <p style="">{<!-- --></p> 
 <p style="">for (j = x; j &gt;= c; j--)</p> 
 <p style="">a[i][j] -= a[r][j] * a[i][c];//对第r行同扩大a[i][c]倍，与第i行相加减，消去列下面的系数 </p> 
 <p style="">}</p> 
 <p style="">}</p> 
 <p style="">r++;</p> 
 <p style="">}</p> 
 <p style="">if (r==x)</p> 
 <p style="">{<!-- --></p> 
 <p style="">for (i = x- 1; i &gt;=0; i--)//向后回代求解</p> 
 <p style="">{<!-- --></p> 
 <p style="">for (j = i + 1; j &lt; x; j++)</p> 
 <p style="">{//+n-x 是恢复最初的行列计数，避免对应错未知量</p> 
 <p style="">a[i][x] -= a[i][j] * a[j][x];//之前已经把每行行首系数变为1</p> 
 <p style="">a[i + n - x][n] = a[i][x];</p> 
 <p style="">}</p> 
 <p style="">}</p> 
 <p style="">a[n - 1][n] = a[x - 1][x];//注意点！！！！！！！！！！！</p> 
 <p style="">}</p> 
 <p style="">if (r &lt; x)</p> 
 <p style="">{<!-- --></p> 
 <p style="">for ( i = r; i &lt; x; i++)</p> 
 <p style="">{<!-- --></p> 
 <p style="">if (fabs(a[i][x]) &gt; eps)//即存在0=常数（不为零）的情况</p> 
 <p style="">return 2;//无解</p> 
 <p style="">}</p> 
 <p style="">//有无穷多组解</p> 
 <p style="">for (i = 0; i &lt;x; i++)</p> 
 <p style="">for (int j = 0; j &lt;x-r; j++)</p> 
 <p style="">{<!-- --></p> 
 <p style="">a[i][j] = 0;//把这一项系数设为零</p> 
 <p style="">}</p> 
 <p style="">int r0=0, c0=0,j0=0;</p> 
 <p style="">for (j = 0; j &lt;= x; j++)</p> 
 <p style="">if (fabs(a[0][j]) &gt;= eps) </p> 
 <p style="">{ </p> 
 <p style="">j0 = j; </p> 
 <p style="">break;</p> 
 <p style="">}//这是个注意点！！！！！！！！！</p> 
 <p style="">//重置矩阵</p> 
 <p style="">for (i = 0; i &lt;x; i++)</p> 
 <p style="">for (j=j0; j &lt;= x; j++)</p> 
 <p style="">{<!-- --></p> 
 <p style="">if (j != x)</p> 
 <p style="">a[r0][c0++] = a[i][j];</p> 
 <p style="">else</p> 
 <p style="">{//换行</p> 
 <p style="">a[r0][r] = a[i][j];</p> 
 <p style="">r0++; c0 =0;//使等号对齐</p> 
 <p style="">}</p> 
 <p style="">}</p> 
 <p style="">for ( i = 0; i &lt; x - r; i++)//这也是注意点！！！！位置</p> 
 <p style="">for ( j = 0; j &lt; x - r; j++)</p> 
 <p style="">{<!-- --></p> 
 <p style="">a[i+n-x][x+n-x] = 0;//把这一项自由变量设为零</p> 
 <p style="">}</p> 
 <p style="">work(r);//继续消元</p> 
 <p style="">return 1;//打印出来的是特解</p> 
 <p style="">}</p> 
 <p style="">return 0;//有唯一解</p> 
 <p style="">}</p> 
 <p style="">int main()</p> 
 <p style="">{<!-- --></p> 
 <p style="">cin &gt;&gt; n;</p> 
 <p style="">for (i = 0; i &lt; n; i++)</p> 
 <p style="">{<!-- --></p> 
 <p style="">for (j = 0; j &lt; n + 1; j++)</p> 
 <p style="">{<!-- --></p> 
 <p style="">cin &gt;&gt; a[i][j];</p> 
 <p style="">}</p> 
 <p style="">}</p> 
 <p style="">int t = work(n);</p> 
 <p style="">if (t ==0)//有唯一解</p> 
 <p style="">{<!-- --></p> 
 <p style="">for ( i = 0; i &lt; n; i++)</p> 
 <p style="">cout &lt;&lt;"x"&lt;&lt;i+1&lt;&lt;"="&lt;&lt; fixed &lt;&lt; setprecision(2) &lt;&lt; a[i][n] &lt;&lt; endl;</p> 
 <p style="">}</p> 
 <p style="">else if (t == 1)//有多解，打印特解</p> 
 <p style="">{<!-- --></p> 
 <p style="">for (i = 0; i &lt; n; i++)</p> 
 <p style="">cout &lt;&lt; "x" &lt;&lt; i + 1 &lt;&lt; "=" &lt;&lt; fixed &lt;&lt; setprecision(2) &lt;&lt; a[i][n] &lt;&lt; endl;</p> 
 <p style="">}</p> 
 <p style="">else cout&lt;&lt;"-1";//无解</p> 
 <p style="">return 0;</p> 
 <p style="">}</p> 
 <p style=""><span class="kdocs-color" style="background-color:#FBF5B3;"><span class="kdocs-bold" style="font-weight:bold;">设计过程遇到的问题及解决方案：</span></span></p> 
 <ol start="1"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;text-align:null;"><p>在设置的精度为1e-6下，我发现在解决有些线性方程组案例时，所得到的解总是与正确答案有些偏差</p></li></ol> 
 <p style="text-indent:1.4em;padding-left:1.4em;text-align:null;"><span class="kdocs-bold" style="font-weight:bold;">解决法案</span></p> 
 <p style="text-indent:1.4em;padding-left:1.4em;text-align:null;">搜索csdn发现此类问题主要是因为计算过程除法的使用（计算机除法会保留成小数），因此在程序中添加寻找所操作列系数绝对值最大值，将最大值的一行换到操作行。这样做的目的是在消元时尽量扩大倍数，用乘法。</p> 
 <p style="text-align:null;"><span class="kdocs-bold" style="font-weight:bold;">2.</span></p> 
 <p style="text-indent:1.4em;padding-left:1.4em;text-align:null;">在最初的设计中</p> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:409px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:29.828852%;height:0;"> 
    <img src="https://images2.imgbox.com/a4/56/CgRryZVX_o.png" style="margin-left:;display:block;width:409px;margin-top:-29.828852%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style=""></p> 
 <p style="text-indent:1.4em;padding-left:1.4em;text-align:null;">对于这种原来元个数（4）大于方程个数（3）的可以求出特解；</p> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:316px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:39.240505%;height:0;"> 
    <img src="https://images2.imgbox.com/07/ca/ImOyoZh7_o.png" style="margin-left:;display:block;width:316px;margin-top:-39.240505%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style=""></p> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:433px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:62.124714%;height:0;"> 
    <img src="https://images2.imgbox.com/af/45/hUJqPzXI_o.png" style="margin-left:;display:block;width:433px;margin-top:-62.124714%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style=""></p> 
 <p style="text-indent:1.4em;padding-left:1.4em;text-align:null;">但对于下列这种原来元个数等于方程个数，通过</p> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:316px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:39.240505%;height:0;"> 
    <img src="https://images2.imgbox.com/25/3d/alzWLmdm_o.png" style="margin-left:;display:block;width:316px;margin-top:-39.240505%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:354px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:62.146893%;height:0;"> 
    <img src="https://images2.imgbox.com/b5/ad/TEO4P0FZ_o.png" style="margin-left:;display:block;width:354px;margin-top:-62.146893%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style="text-align:null;">变换得到的多解情况，求不出来特解。</p> 
 <p style="text-align:null;"><span class="kdocs-bold" style="font-weight:bold;">解决法案 </span></p> 
 <p style="text-align:null;">我认为这两种情况的本质差别是：<span class="kdocs-bold" style="font-weight:bold;">前者</span>是矩形变为\形的特例，将\形截取了一部分，程序将最后几个未知量当作0（特解），从而求出前几个未知量；</p> 
 <p style="text-align:null;"><span class="kdocs-bold" style="font-weight:bold;">后者</span>通过高斯消元操作后，打乱了\形，无法求出未知量。</p> 
 <p style="text-align:null;">于是尝试将打乱的\形规整化，采取将前几个自由变量手动置零，再进行高斯消元化为\形，</p> 
 <p style="text-align:null;"><span class="kdocs-color" style="background-color:#FBF5B3;">代码如下：</span></p> 
 <p style="">//求特解，把前n-r个未知数全设为零,与上面方法相同，r变为r0，n（是行的临界时）变为r</p> 
 <p style="">//有无穷多组解</p> 
 <p style="">for (i = 0; i &lt;x; i++)</p> 
 <p style="">for (int j = 0; j &lt;x-r; j++)</p> 
 <p style="">{<!-- --></p> 
 <p style="">a[i][j] = 0;//把这一项系数设为零</p> 
 <p style="">}</p> 
 <p style="">int r0=0, c0=0,j0=0;</p> 
 <p style="">for (j = 0; j &lt;= x; j++)</p> 
 <p style="">if (fabs(a[0][j]) &gt;= eps) </p> 
 <p style="">{ </p> 
 <p style="">j0 = j; </p> 
 <p style="">break;</p> 
 <p style="">}//这是个注意点！！！！！！！！！</p> 
 <p style="">//重置矩阵</p> 
 <p style="">for (i = 0; i &lt;x; i++)</p> 
 <p style="">for (j=j0; j &lt;= x; j++)</p> 
 <p style="">{<!-- --></p> 
 <p style="">if (j != x)</p> 
 <p style="">a[r0][c0++] = a[i][j];</p> 
 <p style="">else</p> 
 <p style="">{//换行</p> 
 <p style="">a[r0][r] = a[i][j];</p> 
 <p style="">r0++; c0 =0;//使等号对齐</p> 
 <p style="">}</p> 
 <p style="">}</p> 
 <p style="">for ( i = 0; i &lt; x - r; i++)//这也是注意点！！！！位置</p> 
 <p style="">for ( j = 0; j &lt; x - r; j++)</p> 
 <p style="">{<!-- --></p> 
 <p style="">a[i+n-x][x+n-x] = 0;//把这一项自由变量设为零</p> 
 <p style="">}</p> 
 <p style="">work(r);//继续消元</p> 
 <p style="">return 1;//打印出来的是特解</p> 
 <p style="">}</p> 
 <p style=""><span class="kdocs-bold" style="font-weight:bold;">3.</span>继第二个问题的解决方案得出后，在设计过程中我又遇到了如何在设置变量时，使再次进行高斯消元时既能再次比较行数判断解的情况，又能不改变最初的未知量序号（因为重新定义行和列时，未知量的求解实质上是求消元后的系数值，若改变行和列，就会改变未知量与原系数的关系）</p> 
 <p style=""><span class="kdocs-bold" style="font-weight:bold;">解决法案</span></p> 
 <p style="text-align:null;">在每次重新定义行和列后，再次求解时，对系数还原；</p> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:810px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:52.592594%;height:0;"> 
    <img src="https://images2.imgbox.com/59/0d/6l9w1tT0_o.png" style="margin-left:;display:block;width:810px;margin-top:-52.592594%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style="text-indent:1.4em;text-align:null;">同时注意不要漏掉最后一个的还原</p> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:730px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:14.79452%;height:0;"> 
    <img src="https://images2.imgbox.com/5f/42/AXMT05J8_o.png" style="margin-left:;display:block;width:730px;margin-top:-14.79452%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style=""></p> 
 <p style=""></p> 
 <p style="">个人见解，不足之处多多体谅！</p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/eecf04573bd516710680561b2b05f38b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">3DMAX 卸载方法，完美彻底卸载清除干净3DMAX各种残留注册表和文件【转载】</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/fe4e68a7e9d65e3724b0f10251ad89be/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">深入浅出，全方位剖析 ES6 的 class 类及其继承机制</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>