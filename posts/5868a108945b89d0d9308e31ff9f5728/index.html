<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>初学Springboot(二) - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="初学Springboot(二)" />
<meta property="og:description" content="这回来讲一下Springboot一个常用依赖以及全局配置文件的使用
本次讲到的点： 1.热部署 2.全局配置文件(properties,yaml,yml) 2.1执行优先级以及格式 3.自定义全局配置文件 热部署 热部署只需要三步走
一.在pom.xml引入依赖(这个热部署依赖代码尽量记住，以后面试可能会考到)
&lt;!-- 热部署--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;/dependency&gt; 二,勾选自动生成项目选项
这里打开Settings也可以采用快捷键Ctrl&#43;Alt&#43;s，
三.Ctrl&#43;Alt&#43;Shift&#43;/ 打开Maintenance面板
这里打勾后缀为running选项
我们在进行搜索的时候可以直接在键盘输入run会自动搜索出来这个选项
这样我们的热部署就设置完成了
热部署的好处
1.不用手动重新启动启动类，更加便捷
2.对后台代码修改时，可以时刻更新，不用重新启动服务器，只需要刷新页面
其实就是在我们进行代码修改时，项目会重新再次启动一次启动类，实时更新网页
全局配置文件properties以及yaml以及yml 我们项目中，全局配置文件起到的作用有很多，比如
1.绑定各种数据库
2.改端口号,虚拟路径
3.进行查看开源项目中，也可以先看全局配置文件，将其中的用户信息改成本地的，比如数据库密码以及用户名
4.springboot能够自动加载配置文件
个人见解:其实yaml和yml一样格式的，后缀名不同而已
我们先来说说properties
代码例子
#修改地址 server.address=80 #修改端口号 server.port=8443 #连接数据库地址 spring.datasource.driver-class-name=com.mysql.jdbc.Driver spring.config.additional-location= spring.config.location= spring.config.name=application 我们来试试修改端口号(我们默认是8080)
端口号已经发生改变
接下来我们试试在全局配置中设置对象类型信息
继续在properties中添加
#对象类型 person.id=1 person.name=lisi person.hobby=play,read,sleep person.family=father,mother person.map.k1=v1 person.map.k2=v2 person.pet.type=dog person.pet.name=piti 然后创建对应的一个实体类Person
我们创建一个domain文件夹用于存放实体类
在其中创建Person实体类
这里说一个小技巧:
我们使用的如果是idea开发，我们在写了对应的属性后 键盘按下Alt&#43;Insert ,可以自动生成get跟set方法还有tosring
这里要提一点，我们这边的实体类目前不需要Consturctor
@Component //生成当前类的实体类对象存到IOC容器中 @ConfigurationProperties(prefix = &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/5868a108945b89d0d9308e31ff9f5728/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-03-11T22:50:05+08:00" />
<meta property="article:modified_time" content="2021-03-11T22:50:05+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">初学Springboot(二)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>这回来讲一下Springboot<strong>一个常用依赖</strong>以及<strong>全局配置文件</strong>的使用</p> 
<h3><a id="_1"></a>本次讲到的点：</h3> 
<h4><a id="1_2"></a>1.热部署</h4> 
<h4><a id="2propertiesyamlyml_3"></a>2.全局配置文件(properties,yaml,yml)</h4> 
<h6><a id="21_4"></a>2.1执行优先级以及格式</h6> 
<h4><a id="3_5"></a>3.自定义全局配置文件</h4> 
<h2><a id="_6"></a></h2> 
<h3><a id="_7"></a>热部署</h3> 
<p>热部署只需要三步走<br> 一.在pom.xml引入依赖(这个热部署依赖代码尽量记住，以后面试可能会考到)</p> 
<pre><code>&lt;!--        热部署--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;
        &lt;/dependency&gt;
</code></pre> 
<p>二,勾选自动生成项目选项<br> 这里打开Settings也可以采用快捷键Ctrl+Alt+s，<br> <img src="https://images2.imgbox.com/1b/3f/6TaNFxWY_o.png" alt="在这里插入图片描述"><br> 三.Ctrl+Alt+Shift+/ 打开Maintenance面板<br> <img src="https://images2.imgbox.com/1b/00/FjDmqUM4_o.png" alt="在这里插入图片描述"><br> 这里打勾后缀为running选项<br> 我们在进行搜索的时候可以直接在键盘输入run会自动搜索出来这个选项<br> 这样我们的热部署就设置完成了<br> <strong>热部署的好处</strong><br> 1.不用手动重新启动启动类，更加便捷<br> 2.对后台代码修改时，可以时刻更新，不用重新启动服务器，只需要刷新页面<br> <strong>其实就是在我们进行代码修改时，项目会重新再次启动一次启动类，实时更新网页</strong></p> 
<h3><a id="propertiesyamlyml_31"></a>全局配置文件properties以及yaml以及yml</h3> 
<p>我们项目中，全局配置文件起到的作用有很多，比如<br> <strong>1.绑定各种数据库<br> 2.改端口号,虚拟路径<br> 3.进行查看开源项目中，也可以先看全局配置文件，将其中的用户信息改成本地的，比如数据库密码以及用户名<br> 4.springboot能够自动加载配置文件</strong><br> <strong>个人见解</strong>:其实yaml和yml一样格式的，后缀名不同而已<br> 我们先来说说properties<br> 代码例子</p> 
<pre><code>#修改地址
server.address=80
#修改端口号
server.port=8443
#连接数据库地址
spring.datasource.driver-class-name=com.mysql.jdbc.Driver
spring.config.additional-location= 
spring.config.location= 
spring.config.name=application
</code></pre> 
<p>我们来试试修改端口号(我们默认是8080)<br> <img src="https://images2.imgbox.com/87/17/sruJRto0_o.png" alt="在这里插入图片描述"><br> 端口号已经发生改变<img src="https://images2.imgbox.com/9c/fc/bz0er1zN_o.png" alt="在这里插入图片描述"><br> 接下来我们试试在全局配置中设置对象类型信息<br> 继续在properties中添加</p> 
<pre><code>#对象类型
person.id=1
person.name=lisi
person.hobby=play,read,sleep
person.family=father,mother
person.map.k1=v1
person.map.k2=v2
person.pet.type=dog
person.pet.name=piti
</code></pre> 
<p>然后创建对应的一个实体类Person<br> 我们创建一个domain文件夹用于存放实体类<br> 在其中创建Person实体类<br> <strong>这里说一个小技巧</strong>:<br> 我们使用的如果是idea开发，我们在写了对应的属性后 键盘按下<strong>Alt+Insert</strong> ,可以自动生成get跟set方法还有tosring<br> 这里要提一点，我们这边的实体类目前不需要Consturctor</p> 
<pre><code>@Component //生成当前类的实体类对象存到IOC容器中
@ConfigurationProperties(prefix = "person")//将配置文件中的前缀为person的每个属性的值映射到当前类中是变量上
public class Person {
    private int id;//id
    private String name;//姓名
    private List hobby;//爱好
    private String[] family;//家庭成员
    private Map map;
    private Pet pet;//宠物

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public List getHobby() {
        return hobby;
    }

    public void setHobby(List hobby) {
        this.hobby = hobby;
    }

    public String[] getFamily() {
        return family;
    }

    public void setFamily(String[] family) {
        this.family = family;
    }

    public Map getMap() {
        return map;
    }

    public void setMap(Map map) {
        this.map = map;
    }

    public Pet getPet() {
        return pet;
    }

    public void setPet(Pet pet) {
        this.pet = pet;
    }


    @Override
    public String toString() {
        return "person{" +
                "id=" + id +
                ", name='" + name + '\'' +
                ", hobby=" + hobby +
                ", family=" + Arrays.toString(family) +
                ", map=" + map +
                ", pet=" + pet +
                '}';
    }
}

</code></pre> 
<p>@Component //生成当前类的实体类对象存到IOC容器中<br> @ConfigurationProperties(prefix = “person”)//将配置文件中的前缀为person的每个属性的值映射到当前类中是变量上</p> 
<p><strong>这两个注解要注意一定要加，不然项目扫描不到这个类就起不了作用</strong><br> 接下来在测试类中进行控制台打印</p> 
<pre><code>@Autowired
   private Person person;
   public void contextLoads() {
        System.out.println(person.toString());
}
</code></pre> 
<p><img src="https://images2.imgbox.com/b6/60/L0Z8apqn_o.png" alt="在这里插入图片描述"><br> 控制台可以看到该数据说明成功了<br> 有的人会发现pet=null<br> 是因为pet也得创建对应的实体类</p> 
<pre><code>public class Pet {
    private String type;//宠物类型
    private String name;//宠物名字

    public String getType() {
        return type;
    }

    public void setType(String type) {
        this.type = type;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }


    @Override
    public String toString() {
        return "Pet{" +
                "type='" + type + '\'' +
                ", name='" + name + '\'' +
                '}';
    }
}


</code></pre> 
<p>刚刚我们是使用@ConfigurationProperties注入属性的方式<br> 现在说一下第二种方式</p> 
<h5><a id="Value_203"></a>@Value注入属性（单个简易）</h5> 
<p><strong>直接获取关键配置文件里面的定义属性</strong></p> 
<p><strong>可以不用实体类的set方法注入</strong></p> 
<p>直接在测试方法中调用</p> 
<pre><code>@Value("${person.name}")
    private  String name;
    @Test
    public void contextLoads() {
    System.out.println(name);}
</code></pre> 
<p><img src="https://images2.imgbox.com/42/15/jIyUhKaL_o.png" alt="在这里插入图片描述"><br> <strong>记住注解格式</strong><br> @Value("${person.name}") 记得要双引号 要对应全局配置文件中所写的</p> 
<p>对比</p> 
<table><thead><tr><th><strong>对比点</strong></th><th><strong>@ConfigurationProperties</strong></th><th><strong>@Value</strong></th></tr></thead><tbody><tr><td>底层框架</td><td>Spring Boot</td><td>Spring</td></tr><tr><td>功能</td><td>批量注入配置文件中的属性</td><td>单个注入</td></tr><tr><td>SpEL表达式</td><td>不支持</td><td>支持</td></tr><tr><td>属性setXX()方法</td><td>需要</td><td>不需要</td></tr><tr><td>复杂类型属性注入</td><td>支持</td><td>不支持</td></tr><tr><td>松散绑定</td><td>支持</td><td>不支持</td></tr><tr><td>JSR303数据校验</td><td>支持</td><td>不支持</td></tr></tbody></table> 
<p>总结一句话:<br> @ConfigurationProperties适合批量复杂属性注入<br> @Value适合简单属性注入</p> 
<p>接下来讲一下yaml<br> 这里需要介绍一下yaml<br> <strong>1.YAML文件格式是Spring Boot支持的一种JSON超集文件格式。</strong><br> 2.相较于传统的Properties配置文件，YAML文件以数据为核心，是一种更为直观且容易被电脑识别的数据序列化格式。<br> <strong>3.yaml的数据更加结构化，更少混淆，具有分层配置数据</strong><br> 4.application.yaml文件的工作原理和application.properties一样。</p> 
<p>yaml的格式为</p> 
<pre><code>#key:（空格）value
server:
    port: 8081
    path: /hello
</code></pre> 
<p>我们创建yaml直接在全局配置文件夹中右键<br> <img src="https://images2.imgbox.com/a8/2b/CZCUejxX_o.png" alt="在这里插入图片描述"><br> 文件名为<strong>application.yaml</strong><br> 一定要application，不然识别不出来yaml<br> <img src="https://images2.imgbox.com/47/27/pZtkOuvv_o.png" alt="在这里插入图片描述"><br> 当我们看见这个图标，说明创建成功了<br> 然后打开yaml文件开始试试</p> 
<pre><code>#当value值为普通数据类型值的配置
server:
  port: 8082
  servlet:
    context-path: /hello


</code></pre> 
<p>记得要层级分层，注意格式<br> 试一下运行启动类<br> <img src="https://images2.imgbox.com/13/5b/Sly7Dcoz_o.png" alt="在这里插入图片描述"><br> 这里会发现，明明写的端口号是8082为什么会变成8081<br> 这是因为，当全局配置文件中有多个配置文件时，执行顺序不同，且先执行的会被后者覆盖<br> <strong>加载顺序为yml-yaml-properties</strong></p> 
<p><strong>如果同时有两个核心配置文件，后面的会覆盖前面的</strong><br> 这时候我们去先把propertis的端口号设置去掉重新运行启动类<br> <img src="https://images2.imgbox.com/8f/67/bU0a2rFR_o.png" alt="在这里插入图片描述"><br> 这样就成功运行了<br> 接下来说一下yaml跟properties属性书写不同的地方<br> 这里有两种写法</p> 
<pre><code>#当value为数组或单列集合
hobby:
  - play
  - read
  - sleep
#方式2
#hobby1: [play,read,sleep]

#当value值为map的时候
map:
  k1:v1
  k2:v2
#方式2
#map1: {k1:v1,k2:v2}

#对实体类对象person进行属性配置
people:
  name: wahaha
person:
  id: 3
  name: lisi
  hobby: [sing,read,sleep]
  family: [father,mother]
  map: {k1:v1,k2:v2}
  pet: {type: cat,name: tom}
</code></pre> 
<p><strong>空格！空格！记得打空格</strong>冒号后面空格<br> 如果不确定，你可以看一下字体是否有加粗了，如果格式正确是加粗的</p> 
<p>记得写的属性别重复<br> 如果出现控制台打印为null，记得看一下属性格式对不对<br> <strong>注意，配置map与实体类属性，都用{ A:A1 ,B:B1}</strong></p> 
<h4><a id="propertis_316"></a>实体类同上面propertis的实体类一样</h4> 
<h3><a id="properties_317"></a>自定义properties文件</h3> 
<p>@PropertySource（自己配置核心配置）<br> <strong>这里涉及到的注解</strong></p> 
<pre><code>@Configuration//指定当前类为配置类 也可以使用@component注解代替
@PropertySource("classpath:test.properties")//指定自定义配置文件的位置和名称
@EnableConfigurationProperties(Myproperties.class)//开启配置类的属性注入功能
@ConfigurationProperties(prefix = "test")
</code></pre> 
<p>@PropertySource：指定自定义配置文件的位置和名称<br> @Configuration ：自定义配置类，Spring容器组件</p> 
<p>首先，创建一个自定义全局配置文件-new一个file<br> <img src="https://images2.imgbox.com/4f/0c/7Gv6m0jj_o.png" alt="在这里插入图片描述"><br> 在配置文件中我们试一下定义属性</p> 
<pre><code>#对实体类对象MyProperties进行属性配置
test.id=100
test.name=test
</code></pre> 
<p>比如考试考了一百分<br> 接下来创建实体类Myproperties</p> 
<pre><code>
@Configuration//指定当前类为配置类 也可以使用@component注解代替
@PropertySource("classpath:test.properties")//指定自定义配置文件的位置和名称
@EnableConfigurationProperties(Myproperties.class)//开启配置类的属性注入功能
@ConfigurationProperties(prefix = "test")
public class Myproperties {
    private int id;
    private String name;

    @Override
    public String toString() {
        return "Myproperties{" +
                "id=" + id +
                ", name='" + name + '\'' +
                '}';
    }

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}

</code></pre> 
<p>再在测试类进行测试</p> 
<pre><code>@Autowired
    private Myproperties myproperties;
     @Test
    public void contextLoads() {
    System.out.println(myproperties);
</code></pre> 
<p><img src="https://images2.imgbox.com/9d/9d/KmXNDOSy_o.png" alt="在这里插入图片描述"><br> 即为创建成功</p> 
<h3><a id="_388"></a>问题解决:</h3> 
<p>1.解决打印乱码问题<br> <img src="https://images2.imgbox.com/a6/cf/jbtGSWPW_o.png" alt="在这里插入图片描述"><br> 2.启动类记得放在根目录外面，这样才能扫描到子级目录以及同级目录的类<br> 3.关键注解记得有</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f6c189ed88af8e32296c29393007d9fe/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">php拼接where in,php  – 为PostgreSQL中的WHERE IN子句绑定多个行和列</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3938dacb132c0a6604e95638c3e78754/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">php fpm socket 权限,解决因php-fpm socket权限错误导致nginx 502错误的一个问题</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>