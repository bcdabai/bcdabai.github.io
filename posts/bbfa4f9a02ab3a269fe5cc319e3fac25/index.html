<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>缓存使用的几种方式以及优缺点 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="缓存使用的几种方式以及优缺点" />
<meta property="og:description" content="原文地址 mp.weixin.qq.com
本文翻译自英文，原文标题是 Cacheing Strategies and How to Choose the Right One，同事推荐看的，觉得总结的不错，鉴于很多同学都懒得看英文的，所以皮皮就用蹩脚的水平试着翻译一波，如何觉得还凑合，记得点个 “在看”，-。
缓存是提高系统性能的最简单方法之一。相对而言，数据库（or NoSQL 数据库）的速度比较慢，而速度却往往又是制胜的关键。
如果使用得当，缓存可以减少相应时间、减少数据库负载以及节省成本。本文罗列了几种缓存策略，选择正确的一种会有很大的不同。缓存策略取决于数据和数据访问模式。换句话说，数据是如何写和读的。例如:
系统是写多读少的吗？(例如基于时间的日志)
数据是否是只写入一次并被读取多次?(例如用户配置文件)
返回的数据总是惟一的吗?(例如搜索查询)
选择正确的缓存策略是提高性能的关键。让我们快速了解一下各种缓存策略。
第一种：Cache-Aside 这可能是最常用的缓存方法。缓存位于一边，应用程序直接与缓存和数据库对话。
简要解释一下:
应用程序首先检查缓存。
如果在缓存中找到，表示已经命中缓存。数据被读取并返回给应用程序。
如果在缓存中没有找到，则未命中缓存。应用程序必须做一些额外的工作，它需要查询数据库来读取数据，将数据返回给客户端，然后还要将数据存储在缓存中，这样对相同数据的后续读取可以命中缓存。
Cache-aside 策略特别适合读多的应用场景。使用 Cache-aside 的系统对缓存失效具有一定的弹性。如果缓存集群宕机，系统仍然可以通过直接访问数据库进行操作。(不过，如果缓存在峰值负载期间下降，这也没有多大帮助。响应时间可能会变得很糟糕，最糟糕的情况是，数据库可能会停止工作。)
另一个优点在于缓存中的数据模型可以与数据库中的数据模型不同。例如，多个查询产生的响应可以存储在某个请求 id 上。
当使用 cache-aside 时，最常见的写策略是直接将数据写到数据库中。当这种情况发生时，缓存可能与数据库不一致。为了解决这个问题，开发人员通常会引入 TTL，并继续提供陈旧的数据，直到 TTL 过期。如果必须保证数据的新鲜度，开发人员要么使缓存条目无效，要么使用适当的写策略，我们将在后面讨论。
第二种：Read-Though Cache Read-though 策略下的缓存与数据库保持一致。当缓存丢失时，它从数据库加载相应的数据，填充缓存并将其返回给应用程序（参考下图）。
cache-aside 和 read-through 策略都是延迟加载数据的，也就是说，只在第一次读取数据时才加载数据。
虽然 read-through 和 cache-aside 非常相似，但至少有两个关键区别:
在 cache-aside 中，应用程序负责从数据库中获取数据并填充缓存。在 read-through 中，此逻辑通常由库或独立缓存提供程序支持。
与 cache-aside 不同，read-through cache 中的数据模型不能与数据库中的数据模型不同。
当多次请求相同的数据时，read-through 缓存最适合于读量较大的工作负载。例如，一个新闻故事。缺点是，当第一次请求数据时，它总是导致缓存丢失，并导致额外的数据加载到缓存的代价。开发人员通过手动发出查询来 “预热” 或“预热”缓存来处理这个问题。就像 cache-aside 一样，数据也可能在缓存和数据库之间变得不一致，而解决方案就在写策略中，我们将在接下来看到这一点。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/bbfa4f9a02ab3a269fe5cc319e3fac25/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-05-12T20:15:36+08:00" />
<meta property="article:modified_time" content="2022-05-12T20:15:36+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">缓存使用的几种方式以及优缺点</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <blockquote> 
 <p>原文地址 <a href="https://mp.weixin.qq.com/s/7I4kzTq9TQbPREUjrXvW6A" rel="nofollow">mp.weixin.qq.com</a></p> 
</blockquote> 
<p>本文翻译自英文，原文标题是 Cacheing Strategies and How to Choose the Right One，同事推荐看的，觉得总结的不错，鉴于很多同学都懒得看英文的，所以皮皮就用蹩脚的水平试着翻译一波，如何觉得还凑合，记得点个 “在看”，<sup>-</sup>。</p> 
<p>缓存是提高系统性能的最简单方法之一。相对而言，数据库（or NoSQL 数据库）的速度比较慢，而速度却往往又是制胜的关键。</p> 
<p><img src="https://images2.imgbox.com/aa/f4/zzEbrlBS_o.png" alt=""></p> 
<p>如果使用得当，缓存可以减少相应时间、减少数据库负载以及节省成本。本文罗列了几种缓存策略，选择正确的一种会有很大的不同。缓存策略取决于数据和数据访问模式。换句话说，数据是如何写和读的。例如:</p> 
<ul><li> <p>系统是写多读少的吗？(例如基于时间的日志)</p> </li><li> <p>数据是否是只写入一次并被读取多次?(例如用户配置文件)</p> </li><li> <p>返回的数据总是惟一的吗?(例如搜索查询)</p> </li></ul> 
<p>选择正确的缓存策略是提高性能的关键。让我们快速了解一下各种缓存策略。</p> 
<h3><a id="CacheAside_19"></a>第一种：Cache-Aside</h3> 
<p>这可能是最常用的缓存方法。缓存位于一边，应用程序直接与缓存和数据库对话。</p> 
<p><img src="https://images2.imgbox.com/41/d0/xkRUNvmM_o.png" alt=""></p> 
<p>简要解释一下:</p> 
<ol><li> <p>应用程序首先检查缓存。</p> </li><li> <p>如果在缓存中找到，表示已经命中缓存。数据被读取并返回给应用程序。</p> </li><li> <p>如果在缓存中没有找到，则未命中缓存。应用程序必须做一些额外的工作，它需要查询数据库来读取数据，将数据返回给客户端，然后还要将数据存储在缓存中，这样对相同数据的后续读取可以命中缓存。</p> </li></ol> 
<p>Cache-aside 策略特别适合读多的应用场景。使用 Cache-aside 的系统对缓存失效具有一定的弹性。如果缓存集群宕机，系统仍然可以通过直接访问数据库进行操作。(不过，如果缓存在峰值负载期间下降，这也没有多大帮助。响应时间可能会变得很糟糕，最糟糕的情况是，数据库可能会停止工作。)</p> 
<p>另一个优点在于缓存中的数据模型可以与数据库中的数据模型不同。例如，多个查询产生的响应可以存储在某个请求 id 上。</p> 
<p>当使用 cache-aside 时，最常见的写策略是直接将数据写到数据库中。当这种情况发生时，缓存可能与数据库不一致。为了解决这个问题，开发人员通常会引入 TTL，并继续提供陈旧的数据，直到 TTL 过期。如果必须保证数据的新鲜度，开发人员要么使缓存条目无效，要么使用适当的写策略，我们将在后面讨论。</p> 
<h3><a id="ReadThough_Cache_41"></a>第二种：Read-Though Cache</h3> 
<p>Read-though 策略下的缓存与数据库保持一致。当缓存丢失时，它从数据库加载相应的数据，填充缓存并将其返回给应用程序（参考下图）。</p> 
<p><img src="https://images2.imgbox.com/d5/2d/2a6LVD0K_o.png" alt=""></p> 
<p>cache-aside 和 read-through 策略都是延迟加载数据的，也就是说，只在第一次读取数据时才加载数据。</p> 
<p>虽然 read-through 和 cache-aside 非常相似，但至少有两个关键区别:</p> 
<ol><li> <p>在 cache-aside 中，应用程序负责从数据库中获取数据并填充缓存。在 read-through 中，此逻辑通常由库或独立缓存提供程序支持。</p> </li><li> <p>与 cache-aside 不同，read-through cache 中的数据模型不能与数据库中的数据模型不同。</p> </li></ol> 
<p>当多次请求相同的数据时，read-through 缓存最适合于读量较大的工作负载。例如，一个新闻故事。缺点是，当第一次请求数据时，它总是导致缓存丢失，并导致额外的数据加载到缓存的代价。开发人员通过手动发出查询来 “预热” 或“预热”缓存来处理这个问题。就像 cache-aside 一样，数据也可能在缓存和数据库之间变得不一致，而解决方案就在写策略中，我们将在接下来看到这一点。</p> 
<h3><a id="WriteThrough_Cache_59"></a>第三种：Write-Through Cache</h3> 
<p>在这种写策略中，首先将数据写入缓存，然后写入数据库。缓存与数据库保持一致，写操作总是通过缓存到达主数据库。</p> 
<p><img src="https://images2.imgbox.com/2d/2f/r5ri9sKw_o.png" alt=""></p> 
<p>在这种写策略中，首先将数据写入缓存，然后写入数据库。缓存与数据库保持一致，写操作总是通过缓存到达主数据库。</p> 
<p>就其本身而言，write-through 缓存似乎没有多大作用，实际上，它们引入了额外的写延迟，因为数据先写到缓存，然后写到主数据库。但是，当与 read-through 结合使用时，我们获得了 read-through 的所有好处，还获得了数据一致性保证，使我们不必使用缓存失效技术。</p> 
<p>DynamoDB Accelerator (DAX) 是 write-through / read-through cache 的一个很好的例子。它与 DynamoDB 和应用程序内联。对 DynamoDB 的读写可以通过 DAX 完成。(附注：如果您计划使用 DAX，请确保熟悉它的数据一致性模型以及它如何与 DynamoDB 交互。)</p> 
<h3><a id="_WriteAround_72"></a>第四种 Write-Around</h3> 
<p>这种策略下，数据直接写入数据库，只有读取的数据才能进入缓存。Write-around 可以与 read-through 结合使用，并在数据只写一次、读取次数较少或从不读的情况下提供良好的性能。例如，实时日志或聊天室消息。同样，这个模式也可以与 cache-aside 组合使用。</p> 
<h3><a id="_WriteBack_77"></a>第五种 Write-Back</h3> 
<p>这种策略下，应用程序将数据写入缓存，缓存会立即确认，并在延迟一段时间后将数据写入数据库。有时这种策略也被称为 write-behind。</p> 
<p><img src="https://images2.imgbox.com/19/e2/uTl18XPu_o.png" alt=""></p> 
<p>Write-back 缓存提高了写性能，对于写工作量大的工作负载非常有用。当与 read-through 相结合的时候，它对于混合工作负载非常有效，最近更新和访问的数据总是在缓存中可用。它对数据库故障具有很大程度上的弹性，可以容忍一些数据库的宕机。如果支持批处理或合并，则可以减少对数据库的总体写操作，这将减少负载并降低成本。</p> 
<p>一些开发人员使用 Redis 时，同时采用了 cache-aside 和 write-back 两种策略，以便更好地吸收峰值负载期间的峰值。主要缺点是，如果缓存失效，数据可能会永久丢失。大多数关系数据库存储引擎 (例如 InnoDB) 的内部都默认启用了回写缓存。查询首先写入内存，最后刷新到磁盘。</p> 
<h3><a id="_88"></a>总结</h3> 
<p>在本文中，我们探讨了不同的缓存策略及其优缺点。在实践中，请仔细评估您的目标，理解数据访问 (读 / 写) 模式，并选择最佳策略或组合策略。</p> 
<p>如果你选错了怎么办? 一个与你的目标或访问模式不匹配的? 您可能会引入额外的延迟，或者至少没有看到全部的好处。例如，如果在实际应该使用 write-around/read-through 时选择 write-through/read-through(访问写入数据的频率较低)，那么缓存中就会有无用的垃圾。可以说，如果缓存足够大，它可能没问题。但在许多实际的高吞吐量系统中，当内存永远不够大并且需要考虑服务器成本时，正确的策略很重要。</p> 
<p>您在项目中使用的是哪种缓存策略呢？</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/1f65ca782cbe5258156d89a26c44b7c9/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">高性能 Go 语言发行版优化与落地实践 （Go 内存管理及优化、编译器优化）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c4b7e826bfe437ab64ec78bda93eddd5/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">IPv6 SLAAC原理详解及配置</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>