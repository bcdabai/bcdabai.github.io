<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【Flink入门（5）】Flink的时间语义与Watermark - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【Flink入门（5）】Flink的时间语义与Watermark" />
<meta property="og:description" content="【时间】2022.06.07 周二
【题目】【Flink入门（5）】Flink的时间语义与Watermark
本专栏是尚硅谷Flink课程的笔记与思维导图。
目录
引言
一、时间（Time）语义
三种时间语义
二、Watermark（水位线）
2.1 概述
乱序数据的影响
2.2 特点
2.3 Watermark相关知识
1）向下游传递
2）在stream中引入（代码）
3）设置合适的WaterMark延时时间 4）窗口起始点计算
2.4 Flink处理迟到数据的3层保障
总思维导图
引言 flink中有3种时间语义，这里主要讲EvenTime事件时间，从数据的时间戳中提取，属于事件创建（数据产生）的时间，区别于数据到达时间（Ingestion Time）和处理时间（Processing Time）。 Watermark（水位线）是一种处理乱序数据的机制，相当于扩宽window窗口以处理迟到数据。 一、时间（Time）语义 三种时间语义 二、Watermark（水位线） 2.1 概述 乱序数据的影响 2.2 特点 WaterMark的作用是延迟关闭前一个窗口的时间，以处理迟到的数据：
2.3 Watermark相关知识 1）向下游传递 上游Task的watermark广播给下游Task，下游Task取最小WM：
2）在stream中引入（代码） 例子：
public class WindowTest3_EventTimeWindow { public static void main(String[] args) throws Exception { StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment(); // Flink1.12.X 已经默认就是使用EventTime了，所以不需要这行代码 // env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime); env.getConfig().setAutoWatermarkInterval(100); // socket文本流 DataStream&lt;String&gt; inputStream = env." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/113eabf9789435018b3a9fba98ad2f36/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-06-07T20:01:16+08:00" />
<meta property="article:modified_time" content="2022-06-07T20:01:16+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【Flink入门（5）】Flink的时间语义与Watermark</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>【时间】2022.06.07 周二</p> 
<p>【题目】【Flink入门（5）】Flink的时间语义与Watermark</p> 
<blockquote> 
 <p>本专栏是<a href="https://www.bilibili.com/video/BV1qy4y1q728" rel="nofollow" title="尚硅谷Flink课程">尚硅谷Flink课程</a>的笔记与思维导图。</p> 
</blockquote> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E5%BC%95%E8%A8%80-toc" style="margin-left:0px;"><a href="#%E5%BC%95%E8%A8%80" rel="nofollow">引言</a></p> 
<p id="%E4%B8%80%E3%80%81%E6%97%B6%E9%97%B4%EF%BC%88Time%EF%BC%89%E8%AF%AD%E4%B9%89-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%E6%97%B6%E9%97%B4%EF%BC%88Time%EF%BC%89%E8%AF%AD%E4%B9%89" rel="nofollow">一、时间（Time）语义</a></p> 
<p id="%C2%A0%E4%B8%89%E7%A7%8D%E6%97%B6%E9%97%B4%E8%AF%AD%E4%B9%89-toc" style="margin-left:40px;"><a href="#%C2%A0%E4%B8%89%E7%A7%8D%E6%97%B6%E9%97%B4%E8%AF%AD%E4%B9%89" rel="nofollow"> 三种时间语义</a></p> 
<p id="%E4%BA%8C%E3%80%81Watermark%EF%BC%88%E6%B0%B4%E4%BD%8D%E7%BA%BF%EF%BC%89-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81Watermark%EF%BC%88%E6%B0%B4%E4%BD%8D%E7%BA%BF%EF%BC%89" rel="nofollow">二、Watermark（水位线）</a></p> 
<p id="2.1%20%E6%A6%82%E8%BF%B0-toc" style="margin-left:40px;"><a href="#2.1%20%E6%A6%82%E8%BF%B0" rel="nofollow">2.1 概述</a></p> 
<p id="%E4%B9%B1%E5%BA%8F%E6%95%B0%E6%8D%AE%E7%9A%84%E5%BD%B1%E5%93%8D-toc" style="margin-left:80px;"><a href="#%E4%B9%B1%E5%BA%8F%E6%95%B0%E6%8D%AE%E7%9A%84%E5%BD%B1%E5%93%8D" rel="nofollow">乱序数据的影响</a></p> 
<p id="2.2%20%E7%89%B9%E7%82%B9-toc" style="margin-left:40px;"><a href="#2.2%20%E7%89%B9%E7%82%B9" rel="nofollow">2.2 特点</a></p> 
<p id="2.3%C2%A0Watermark%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86-toc" style="margin-left:40px;"><a href="#2.3%C2%A0Watermark%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86" rel="nofollow">2.3 Watermark相关知识</a></p> 
<p id="1%EF%BC%89%E5%90%91%E4%B8%8B%E6%B8%B8%E4%BC%A0%E9%80%92-toc" style="margin-left:80px;"><a href="#1%EF%BC%89%E5%90%91%E4%B8%8B%E6%B8%B8%E4%BC%A0%E9%80%92" rel="nofollow">1）向下游传递</a></p> 
<p id="2%EF%BC%89%E5%9C%A8stream%E4%B8%AD%E5%BC%95%E5%85%A5%EF%BC%88%E4%BB%A3%E7%A0%81%EF%BC%89-toc" style="margin-left:80px;"><a href="#2%EF%BC%89%E5%9C%A8stream%E4%B8%AD%E5%BC%95%E5%85%A5%EF%BC%88%E4%BB%A3%E7%A0%81%EF%BC%89" rel="nofollow">2）在stream中引入（代码）</a></p> 
<p id="3%EF%BC%89%E8%AE%BE%E7%BD%AE%E5%90%88%E9%80%82%E7%9A%84WaterMark%E5%BB%B6%E6%97%B6%E6%97%B6%E9%97%B4%C2%A0-toc" style="margin-left:80px;"><a href="#3%EF%BC%89%E8%AE%BE%E7%BD%AE%E5%90%88%E9%80%82%E7%9A%84WaterMark%E5%BB%B6%E6%97%B6%E6%97%B6%E9%97%B4%C2%A0" rel="nofollow">3）设置合适的WaterMark延时时间 </a></p> 
<p id="4%EF%BC%89%E7%AA%97%E5%8F%A3%E8%B5%B7%E5%A7%8B%E7%82%B9%E8%AE%A1%E7%AE%97-toc" style="margin-left:80px;"><a href="#4%EF%BC%89%E7%AA%97%E5%8F%A3%E8%B5%B7%E5%A7%8B%E7%82%B9%E8%AE%A1%E7%AE%97" rel="nofollow">4）窗口起始点计算</a></p> 
<p id="2.4%20Flink%E5%A4%84%E7%90%86%E8%BF%9F%E5%88%B0%E6%95%B0%E6%8D%AE%E7%9A%843%E5%B1%82%E4%BF%9D%E9%9A%9C-toc" style="margin-left:40px;"><a href="#2.4%20Flink%E5%A4%84%E7%90%86%E8%BF%9F%E5%88%B0%E6%95%B0%E6%8D%AE%E7%9A%843%E5%B1%82%E4%BF%9D%E9%9A%9C" rel="nofollow">2.4 Flink处理迟到数据的3层保障</a></p> 
<p id="%E6%80%BB%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE-toc" style="margin-left:0px;"><a href="#%E6%80%BB%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE" rel="nofollow">总思维导图</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E5%BC%95%E8%A8%80">引言</h2> 
<ol><li>flink中有3种时间语义，这里主要讲EvenTime事件时间，从数据的时间戳中提取，属于事件创建（数据产生）的时间，区别于数据到达时间（Ingestion Time）和处理时间（Processing Time）。 </li><li>Watermark（水位线）是一种处理乱序数据的机制，相当于扩宽window窗口以处理迟到数据。</li></ol> 
<p></p> 
<h2 id="%E4%B8%80%E3%80%81%E6%97%B6%E9%97%B4%EF%BC%88Time%EF%BC%89%E8%AF%AD%E4%B9%89">一、时间（Time）语义</h2> 
<p><img alt="" height="824" src="https://images2.imgbox.com/60/d1/v5cQqdJq_o.png" width="1200"></p> 
<h3 id="%C2%A0%E4%B8%89%E7%A7%8D%E6%97%B6%E9%97%B4%E8%AF%AD%E4%B9%89"> 三种时间语义</h3> 
<h3 id="%E2%80%8B%E7%BC%96%E8%BE%91"><img alt="" height="907" src="https://images2.imgbox.com/27/de/A5Mt393I_o.png" width="1200"></h3> 
<h2 id="%E4%BA%8C%E3%80%81Watermark%EF%BC%88%E6%B0%B4%E4%BD%8D%E7%BA%BF%EF%BC%89">二、Watermark（水位线）</h2> 
<h3 id="2.1%20%E6%A6%82%E8%BF%B0">2.1 概述</h3> 
<p><img alt="" height="450" src="https://images2.imgbox.com/9a/7f/3Lt6OkwF_o.png" width="1200"></p> 
<p></p> 
<h4 id="%E4%B9%B1%E5%BA%8F%E6%95%B0%E6%8D%AE%E7%9A%84%E5%BD%B1%E5%93%8D">乱序数据的影响</h4> 
<p><img alt="" height="1002" src="https://images2.imgbox.com/39/0e/EZq9rwAj_o.png" width="1200"></p> 
<h3 id="2.2%20%E7%89%B9%E7%82%B9">2.2 特点</h3> 
<p></p> 
<p> <img alt="" height="576" src="https://images2.imgbox.com/df/1b/ZeSUtHKj_o.png" width="1200"></p> 
<p>WaterMark的作用是延迟关闭前一个窗口的时间，以处理迟到的数据：</p> 
<p></p> 
<p><img alt="" height="1136" src="https://images2.imgbox.com/58/84/jMh0Gg09_o.png" width="1200"></p> 
<p></p> 
<h3 id="2.3%C2%A0Watermark%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86">2.3 Watermark相关知识</h3> 
<h4 id="1%EF%BC%89%E5%90%91%E4%B8%8B%E6%B8%B8%E4%BC%A0%E9%80%92">1）向下游传递</h4> 
<p>上游Task的watermark<strong><span style="color:#fe2c24;">广播</span></strong>给下游Task，下游Task取最小WM：</p> 
<p><img alt="" height="775" src="https://images2.imgbox.com/a1/cb/YuTSLimz_o.png" width="1200"></p> 
<h4 id="2%EF%BC%89%E5%9C%A8stream%E4%B8%AD%E5%BC%95%E5%85%A5%EF%BC%88%E4%BB%A3%E7%A0%81%EF%BC%89">2）在stream中引入（代码）</h4> 
<p><img alt="" height="637" src="https://images2.imgbox.com/92/bc/ipwhC1tH_o.png" width="1200"></p> 
<p> 例子：</p> 
<pre><code class="language-java">public class WindowTest3_EventTimeWindow {
  public static void main(String[] args) throws Exception {
    StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();

    // Flink1.12.X 已经默认就是使用EventTime了，所以不需要这行代码
    //        env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime);
    env.getConfig().setAutoWatermarkInterval(100);

    // socket文本流
    DataStream&lt;String&gt; inputStream = env.socketTextStream("localhost", 7777);

    // 转换成SensorReading类型，分配时间戳和watermark
    DataStream&lt;SensorReading&gt; dataStream = inputStream.map(line -&gt; {
      String[] fields = line.split(",");
      return new SensorReading(fields[0], new Long(fields[1]), new Double(fields[2]));
    })
      //              
      // 旧版 (新版官方推荐用assignTimestampsAndWatermarks(WatermarkStrategy) )
      // 升序数据（不乱序）设置事件时间和watermark
      //.assignTimestampsAndWatermarks(new AscendingTimestampExtractor&lt;SensorReading&gt;() {
      //  @Override
      //  public long extractAscendingTimestamp(SensorReading element) {
      //    return element.getTimestamp() * 1000L;
      //  }
      //})
      
      // 旧版 (新版官方推荐用assignTimestampsAndWatermarks(WatermarkStrategy) )
      // 乱序数据设置时间戳和watermark
      .assignTimestampsAndWatermarks(new BoundedOutOfOrdernessTimestampExtractor&lt;SensorReading&gt;(Time.seconds(2)) {//需要传入参数：乱序程度
        @Override
        public long extractTimestamp(SensorReading element) {
          return element.getTimestamp() * 1000L; //毫秒
        }
      });

    OutputTag&lt;SensorReading&gt; outputTag = new OutputTag&lt;SensorReading&gt;("late") {
    };

    // 基于事件时间的开窗聚合，统计15秒内温度的最小值
    SingleOutputStreamOperator&lt;SensorReading&gt; minTempStream = dataStream.keyBy("id")
      .timeWindow(Time.seconds(15))
      .allowedLateness(Time.minutes(1))
      .sideOutputLateData(outputTag)
      .minBy("temperature");

    minTempStream.print("minTemp");
    minTempStream.getSideOutput(outputTag).print("late");

    env.execute();
  }
}</code></pre> 
<h4 id="3%EF%BC%89%E8%AE%BE%E7%BD%AE%E5%90%88%E9%80%82%E7%9A%84WaterMark%E5%BB%B6%E6%97%B6%E6%97%B6%E9%97%B4%C2%A0">3）设置合适的WaterMark延时时间 </h4> 
<p><img alt="" height="573" src="https://images2.imgbox.com/af/e5/7dXGFJ57_o.png" width="1200"></p> 
<h4 id="4%EF%BC%89%E7%AA%97%E5%8F%A3%E8%B5%B7%E5%A7%8B%E7%82%B9%E8%AE%A1%E7%AE%97">4）窗口起始点计算</h4> 
<p><img alt="" height="247" src="https://images2.imgbox.com/f7/85/hHfo7Xnc_o.png" width="1200"></p> 
<p>其中offset是时区偏移量。</p> 
<p><img alt="" height="341" src="https://images2.imgbox.com/3e/89/IRD7dk4d_o.png" width="1200"></p> 
<p></p> 
<h3 id="2.4%20Flink%E5%A4%84%E7%90%86%E8%BF%9F%E5%88%B0%E6%95%B0%E6%8D%AE%E7%9A%843%E5%B1%82%E4%BF%9D%E9%9A%9C">2.4 Flink处理迟到数据的3层保障</h3> 
<p><img alt="" height="432" src="https://images2.imgbox.com/9e/bd/FCKeYW7Y_o.png" width="1200"></p> 
<p>例子：</p> 
<p></p> 
<pre><code class="language-java">public class WindowTest3_EventTimeWindow {
  public static void main(String[] args) throws Exception {
    StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();

    env.setParallelism(1);

    env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime);
    env.getConfig().setAutoWatermarkInterval(100);

    // socket文本流
    DataStream&lt;String&gt; inputStream = env.socketTextStream("localhost", 7777);

    // 转换成SensorReading类型，分配时间戳和watermark
    DataStream&lt;SensorReading&gt; dataStream = inputStream.map(line -&gt; {
      String[] fields = line.split(",");
      return new SensorReading(fields[0], new Long(fields[1]), new Double(fields[2]));
    })
      
      // 乱序数据设置时间戳和watermark
      .assignTimestampsAndWatermarks(new BoundedOutOfOrdernessTimestampExtractor&lt;SensorReading&gt;(Time.seconds(2)) {
        @Override
        public long extractTimestamp(SensorReading element) {
          return element.getTimestamp() * 1000L;
        }
      });

    OutputTag&lt;SensorReading&gt; outputTag = new OutputTag&lt;SensorReading&gt;("late") {
    };

    // 基于事件时间的开窗聚合，统计15秒内温度的最小值
    SingleOutputStreamOperator&lt;SensorReading&gt; minTempStream = dataStream.keyBy("id")
      .timeWindow(Time.seconds(15)) //时间窗口大小15s
      .allowedLateness(Time.minutes(1))//允许延时1m，这是基于处理时间的（即窗口执行时间），窗口操作后，在1min内，每来一个迟到数据，就输出一个结果。
      .sideOutputLateData(outputTag)//测输出流
      .minBy("temperature");

    minTempStream.print("minTemp");
    minTempStream.getSideOutput(outputTag).print("late");

    env.execute();
  }
}</code></pre> 
<h2 id="%E6%80%BB%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE">总思维导图</h2> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/71/29/lYjHgFKL_o.png"></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e394522f5e57091576403a80a4525ec4/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">贝叶斯优化基础方法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a8d543414fa6ef17698b5ce10b59af33/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">如何查看Linux负载</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>