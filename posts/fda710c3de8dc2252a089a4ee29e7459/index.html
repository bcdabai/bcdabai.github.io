<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【TCP 重传、滑动窗口、流量控制、拥塞控制】 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【TCP 重传、滑动窗口、流量控制、拥塞控制】" />
<meta property="og:description" content="文章目录 重传机制超时重传快速重传SACK方法Duplicate SACK 滑动窗口流量控制那操作系统的缓冲区，是如何影响发送窗口和接收窗口的呢？窗口关闭 拥塞控制慢启动拥塞避免拥塞发生快速恢复 重传机制 TCP 实现可靠传输的方式之一，是通过序列号与确认应答。常见的重传机制： 超时重传快速重传SACKD-SACK 超时重传 重传机制的其中一个方式，就是在发送数据时，设定一个定时器，当超过指定的时间后，没有收到对方的 ACK 确认应答报文，就会重发该数据TCP 会在以下两种情况发生超时重传： 数据包丢失确认应答丢失 超时时间应该设置为多少呢？
RTT指的是数据发送时刻到接收到确认的时刻的差值，也就是包的往返时间。RTO指超时重传时间,两种超时时间不同的情况： 当超时时间 RTO 较大时，重发就慢，丢了老半天才重发，没有效率，性能差；当超时时间 RTO 较小时，会导致可能并没有丢就重发，于是重发的就快，会增加网络拥塞，导致更多的超时，更多的超时导致更多的重发。 因此超时重传时间 RTO 的值应该略大于报文往返 RTT 的值。
超时重传问题?
「报文往返 RTT 的值」是经常变化的，因为我们的网络也是时常变化的。也就因为「报文往返 RTT 的值」 是经常波动变化的，所以「超时重传时间 RTO 的值」应该是一个动态变化的值。每当遇到一次超时重传的时候，都会将下一次超时时间间隔设为先前值的两倍。两次超时，就说明网络环境超时触发重传存在的问题是，超时周期可能相对较长差，不宜频繁反复发送。 快速重传 它不以时间为驱动，而是以数据驱动重传。快速重传的工作方式是当收到三个相同的 ACK 报文时，会在定时器过期之前，重传丢失的报文段。 快速重传流程
第一份 Seq1 先送到了，于是就 Ack 回 2；结果 Seq2 因为某些原因没收到，Seq3 到达了，于是还是 Ack 回 2；后面的 Seq4 和 Seq5 都到了，但还是 Ack 回 2，因为 Seq2 还是没有收到；发送端收到了三个 Ack = 2 的确认，知道了 Seq2 还没有收到，就会在定时器过期之前，重传丢失的 Seq2。最后，收到了 Seq2，此时因为 Seq3，Seq4，Seq5 都收到了，于是 Ack 回 6 。 快速重传问题" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/fda710c3de8dc2252a089a4ee29e7459/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-05-06T22:45:35+08:00" />
<meta property="article:modified_time" content="2023-05-06T22:45:35+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【TCP 重传、滑动窗口、流量控制、拥塞控制】</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><ul><li><a href="#_2" rel="nofollow">重传机制</a></li><li><ul><li><a href="#_11" rel="nofollow">超时重传</a></li><li><a href="#_31" rel="nofollow">快速重传</a></li><li><a href="#SACK_48" rel="nofollow">SACK方法</a></li><li><a href="#Duplicate_SACK_54" rel="nofollow">Duplicate SACK</a></li></ul> 
   </li><li><a href="#_75" rel="nofollow">滑动窗口</a></li><li><a href="#_121" rel="nofollow">流量控制</a></li><li><ul><li><a href="#_129" rel="nofollow">那操作系统的缓冲区，是如何影响发送窗口和接收窗口的呢？</a></li><li><a href="#_137" rel="nofollow">窗口关闭</a></li></ul> 
   </li><li><a href="#_152" rel="nofollow">拥塞控制</a></li><li><ul><li><a href="#_178" rel="nofollow">慢启动</a></li><li><a href="#_193" rel="nofollow">拥塞避免</a></li><li><a href="#_203" rel="nofollow">拥塞发生</a></li><li><a href="#_224" rel="nofollow">快速恢复</a></li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h3><a id="_2"></a>重传机制</h3> 
<ul><li>TCP 实现可靠传输的方式之一，是通过序列号与确认应答。</li><li>常见的重传机制： 
  <ul><li>超时重传</li><li>快速重传</li><li>SACK</li><li>D-SACK</li></ul> </li></ul> 
<h4><a id="_11"></a>超时重传</h4> 
<ul><li><code>重传机制的其中一个方式，就是在发送数据时，设定一个定时器，当超过指定的时间后，没有收到对方的 ACK 确认应答报文，就会重发该数据</code></li><li>TCP 会在以下两种情况发生超时重传： 
  <ul><li>数据包丢失</li><li>确认应答丢失</li></ul> </li></ul> 
<blockquote> 
 <p>超时时间应该设置为多少呢？</p> 
</blockquote> 
<ul><li>RTT指的是数据发送时刻到接收到确认的时刻的差值，也就是包的往返时间。</li><li>RTO指超时重传时间,两种超时时间不同的情况： 
  <ul><li>当超时时间 RTO 较大时，重发就慢，丢了老半天才重发，没有效率，性能差；</li><li>当超时时间 RTO 较小时，会导致可能并没有丢就重发，于是重发的就快，会增加网络拥塞，导致更多的超时，更多的超时导致更多的重发。</li></ul> </li><li><code>因此超时重传时间 RTO 的值应该略大于报文往返 RTT 的值。</code><br> <img src="https://images2.imgbox.com/6a/17/yIQb67SQ_o.png" alt="在这里插入图片描述"></li></ul> 
<blockquote> 
 <p>超时重传问题?</p> 
</blockquote> 
<ul><li>「报文往返 RTT 的值」是经常变化的，因为我们的网络也是时常变化的。也就因为「报文往返 RTT 的值」 是经常波动变化的，所以<code>「超时重传时间 RTO 的值」应该是一个动态变化</code>的值。</li><li><code>每当遇到一次超时重传的时候，都会将下一次超时时间间隔设为先前值的两倍。两次超时，就说明网络环境</code></li><li>超时触发重传存在的问题是，<code>超时周期可能相对较长差</code>，不宜频繁反复发送。</li></ul> 
<h4><a id="_31"></a>快速重传</h4> 
<ul><li>它<code>不以时间为驱动，而是以数据驱动重传。</code></li><li>快速重传的工作方式是当收到<code>三个相同的 ACK 报文时</code>，会在定时器过期之前，重传丢失的报文段。</li></ul> 
<blockquote> 
 <p><code>快速重传流程</code></p> 
 <ul><li>第一份 Seq1 先送到了，于是就 Ack 回 2；</li><li>结果 Seq2 因为某些原因没收到，Seq3 到达了，于是还是 Ack 回 2；</li><li>后面的 Seq4 和 Seq5 都到了，但还是 Ack 回 2，因为 Seq2 还是没有收到；</li><li>发送端收到了三个 Ack = 2 的确认，知道了 Seq2 还没有收到，就会在定时器过期之前，重传丢失的 Seq2。</li><li>最后，收到了 Seq2，此时因为 Seq3，Seq4，Seq5 都收到了，于是 Ack 回 6 。<img src="https://images2.imgbox.com/da/3b/3CwOMVR1_o.png" alt="在这里插入图片描述"></li></ul> 
</blockquote> 
<blockquote> 
 <p>快速重传问题</p> 
</blockquote> 
<ul><li>快速重传机制只解决了一个问题，就是超时时间的问题,另一个问题是重传的时候，是<code>重传一个，还是重传所有的问题。</code></li><li>假设发送方发了 6 个数据，编号的顺序是 Seq1 ~ Seq6 ，但是 Seq2、Seq3 都丢失了，那么接收方在收到 Seq4、Seq5、Seq6 时，都是回复 ACK2 给发送方，但是发送方并不清楚这连续的 ACK2 是接收方收到哪个报文而回复的， 那是选择重传 Seq2 一个报文，还是重传 Seq2 之后已发送的所有报文呢（Seq2、Seq3、 Seq4、Seq5、 Seq6） 呢？</li></ul> 
<h4><a id="SACK_48"></a>SACK方法</h4> 
<ul><li>SACK（ Selective Acknowledgment）， <code>选择性确认</code>。</li><li>需要在 TCP 头部「选项」字段里加一个 SACK 的东西，<code>它可以将已收到的数据的信息发送给「发送方」</code>，这样发送方就可以知道哪些数据收到了，哪些数据没收到，知道了这些信息，就可以<code>只重传丢失的数据。</code></li></ul> 
<blockquote> 
 <ul><li>如下图，发送方收到了三次同样的 ACK 确认报文，于是就会触发快速重发机制，通过 SACK 信息发现只有 200~299 这段数据丢失，则重发时，就只选择了这个 TCP 段进行重复。<br> <img src="https://images2.imgbox.com/c1/81/hBBawhy6_o.png" alt="在这里插入图片描述"></li></ul> 
</blockquote> 
<h4><a id="Duplicate_SACK_54"></a>Duplicate SACK</h4> 
<ul><li>使用了 SACK 来告诉「发送方」有哪些数据被重复接收了。</li><li>D-SACK 有这么几个好处： 
  <ul><li>可以让「发送方」知道，是发出去的包丢了，还是接收方回应的 ACK 包丢了;</li><li>可以知道是不是「发送方」的数据包被网络延迟了;</li><li>可以知道网络中是不是把「发送方」的数据包给复制了;</li></ul> </li></ul> 
<blockquote> 
 <p>ACK 丢包<img src="https://images2.imgbox.com/eb/df/2PtHSB7R_o.png" alt="在这里插入图片描述"></p> 
 <ul><li>[接收方」发给「发送方」的两个 ACK 确认应答都丢失了，所以发送方超时后，重传第一个数据包（3000 ~ 3499）</li><li>于是「接收方」发现数据是重复收到的，于是回了一个 SACK = 3000~3500，告诉「发送方」 3000~3500 的数据早已被接收了，因为 ACK 都到了 4000 了，已经意味着 4000 之前的所有数据都已收到，所以这个 SACK 就代表着 D-SACK。</li><li>这样「发送方」就知道了，数据没有丢，是「接收方」的 ACK 确认报文丢了。</li></ul> 
</blockquote> 
<blockquote> 
 <p>网络延迟<br> <img src="https://images2.imgbox.com/08/09/UFUIPMW3_o.png" alt="在这里插入图片描述"></p> 
 <ul><li>数据包（1000~1499） 被网络延迟了，导致「发送方」没有收到 Ack 1500 的确认报文。</li><li>而后面报文到达的三个相同的 ACK 确认报文，就触发了快速重传机制，但是在重传后，被延迟的数据包（1000~1499）又到了「接收方」；</li><li><code>所以「接收方」回了一个 SACK=1000~1500，因为 ACK 已经到了 3000，所以这个 SACK 是 D-SACK，表示收到了重复的包。</code></li><li>这样发送方就知道快速重传触发的原因不是发出去的包丢了，也不是因为回应的 ACK 包丢了，而是因为网络延迟了。</li></ul> 
</blockquote> 
<h3><a id="_75"></a>滑动窗口</h3> 
<ul><li>TCP 是每发送一个数据，都要进行一次确认应答。当上一个数据包收到了应答了， 再发送下一个。效率比较低,而且有一个缺点:<code>数据包的往返时间越长，通信的效率就越低。</code></li></ul> 
<blockquote> 
 <p>引入滑动窗口原因</p> 
 <ul><li>指定窗口大小，窗口大小就是指无需等待确认应答，而可以继续发送数据的最大值。</li><li>窗口的实现实际上是操作系统开辟的一个缓存空间，发送方主机在等到确认应答返回之前，必须在缓冲区中保留已发送的数据。如果按期收到确认应答，此时数据就可以从缓存区清除。</li><li><code>中途若有 ACK 丢失，可以通过「下一个确认应答进行确认」</code>(只要发送方收到了 ACK 700 确认应答，就意味着 700 之前的所有数据「接收方」都收到了。)<br> <img src="https://images2.imgbox.com/c2/66/ESDYoV6Z_o.png" alt="在这里插入图片描述"></li></ul> 
</blockquote> 
<blockquote> 
 <p>窗口大小由哪一方决定？</p> 
</blockquote> 
<ul><li>TCP 头里有一个字段叫 <code>Window</code>，也就是窗口大小。</li><li><code>这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。</code></li><li><code>通常窗口的大小是由接收方的窗口大小来决定的。</code>发送方发送的数据大小不能超过接收方的窗口大小，否则接收方就无法正常接收到数据。</li></ul> 
<blockquote> 
 <p>发送方滑动窗口</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/31/19/H9GmVBuV_o.png" alt="在这里插入图片描述"></p> 
<ul><li>当发送方把数据「全部」都一下发送出去后，可用窗口的大小就为 0 了，表明可用窗口耗尽，在没收到 ACK 确认之前是无法继续发送数据了。</li><li>当收到之前发送的数据 32~36 字节的 ACK 确认应答后，如果发送窗口的大小没有变化，则<code>滑动窗口往右边移动 5 个字节，因为有 5 个字节的数据被应答确认</code>，接下来 52~56 字节又变成了可用窗口，那么后续也就可以发送 52~56 这 5 个字节的数据了。</li></ul> 
<p><img src="https://images2.imgbox.com/eb/dd/cmnCVcqv_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>程序如何表示这四部分?</p> 
</blockquote> 
<ul><li>TCP 滑动窗口方案使用三个指针来跟踪在四个传输类别中的每一个类别中的字节。其中两个指针是绝对指针（指特定的序列号），一个是相对指针（需要做偏移）。</li></ul> 
<p><img src="https://images2.imgbox.com/a8/55/KzaYuRlL_o.png" alt="在这里插入图片描述"></p> 
<ul><li><code>SND.WND</code>：表示发送窗口的大小（大小是由接收方指定的）；</li><li><code>SND.UNA</code>（Send Unacknoleged）：是一个绝对指针，它指向的是已发送但未收到确认的第一个字节的序列号，也就是 #2 的第一个字节。</li><li><code>SND.NXT</code>：也是一个绝对指针，它指向未发送但可发送范围的第一个字节的序列号，也就是 #3 的第一个字节。</li><li>指向 #4 的第一个字节是个相对指针，它需要 SND.UNA 指针加上 SND.WND 大小的偏移量，就可以指向 #4 的第一个字节了。</li></ul> 
<p>那么可用窗口大小的计算就可以是：</p> 
<ul><li><code>可用窗口大小 = SND.WND -（SND.NXT - SND.UNA）</code></li></ul> 
<blockquote> 
 <p>接收方滑动窗口</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/e9/58/xh6jaFZT_o.png" alt="在这里插入图片描述"></p> 
<ul><li><code>RCV.WND</code>：表示接收窗口的大小，它会通告给发送方。</li><li><code>RCV.NXT</code>：是一个指针，它指向期望从发送方发送来的下一个数据字节的序列号，也就是 #3 的第一个字节。</li><li>指向 #4 的第一个字节是个相对指针，它需要 RCV.NXT 指针加上 RCV.WND 大小的偏移量，就可以指向 #4 的第一个字节了。</li></ul> 
<p><code>注意:接收窗口的大小是约等于发送窗口的大小的。但是滑动窗口并不是一成不变的,需要根据发送方的发送快慢和接收方的处理快慢决定窗口的大小</code></p> 
<h3><a id="_121"></a>流量控制</h3> 
<ul><li>TCP 提供一种机制可以让「发送方」根据「接收方」的实际接收能力控制发送的数据量，这就是所谓的流量控制。</li></ul> 
<blockquote> 
 <p>操作系统缓冲区与滑动窗口的关系?</p> 
</blockquote> 
<ul><li>假定了发送窗口和接收窗口是不变的，但是实际上，发送窗口和接收窗口中所存放的字节数，都是放在操作系统内存缓冲区中的，而操作系统的缓冲区，会<code>被操作系统调整</code>。</li><li>当应用进程没办法及时读取缓冲区的内容时，也会对我们的缓冲区造成影响。</li></ul> 
<h4><a id="_129"></a>那操作系统的缓冲区，是如何影响发送窗口和接收窗口的呢？</h4> 
<blockquote> 
 <ul><li> <p><code>当应用程序没有及时读取缓存时，发送窗口和接收窗口的变化:</code></p> 
   <ul><li>后窗口都收缩为 0 了，也就是发生了窗口关闭。当发送方可用窗口变为 0 时，发送方实际上会定时发送窗口探测报文，以便知道接收方的窗口是否发生了改变</li></ul> </li><li> <p><code>当服务端系统资源非常紧张的时候，操作系统可能会直接减少了接收缓冲区大小,这时应用程序又无法及时读取缓存数据，会出现数据包丢失的现象</code></p> 
   <ul><li>如果发生了先减少缓存，再收缩窗口，就会出现丢包的现象。</li><li>为了防止这种情况发生，TCP 规定是不允许同时减少缓存又收缩窗口的，而是采用先收缩窗口，过段时间再减少缓存，这样就可以避免了丢包情况</li></ul> </li></ul> 
</blockquote> 
<h4><a id="_137"></a>窗口关闭</h4> 
<p>接收方，接收到数据后，进行响应，会发送给发送方自己的窗口大小，当发送方下次发送时，就会知道发送多少的数据，这就是流量控制。</p> 
<ul><li>如果窗口大小为 0 时，就会阻止发送方给接收方传递数据，直到窗口变为非 0 为止，这就是窗口关闭。</li></ul> 
<blockquote> 
 <p>窗口关闭带来的危险</p> 
 <ul><li>接收方向发送方通告窗口大小时，是通过 ACK 报文来通告的。当发生窗口关闭时，接收方处理完数据后，会向发送方通告一个窗口非 0 的 ACK 报文，如果这个通告窗口的 ACK 报文在网络中丢失了，双方就会死锁<br> <img src="https://images2.imgbox.com/87/3f/3h52yy2W_o.png" alt="在这里插入图片描述"></li></ul> 
</blockquote> 
<blockquote> 
 <p>TCP如何解决死锁？</p> 
 <ul><li>TCP 为每个连接设有一个持续定时器，<code>只要 TCP 连接一方收到对方的零窗口通知，就启动持续计时器。</code></li><li>如果持续计时器超时，就会发送<code>窗口探测 ( Window probe ) 报文</code>，而对方在确认这个探测报文时，给出自己现在的接收窗口大小。 
   <ul><li>如果接收窗口仍然为 0，那么收到这个报文的一方就会重新启动持续计时器；</li><li>如果接收窗口不是 0，那么死锁的局面就可以被打破了。</li></ul> </li><li><code>窗口探测的次数一般为 3 次</code>，每次大约 30-60 秒。<code>如果 3 次过后接收窗口还是 0 的话，有的 TCP 实现就会发 RST 报文来中断连接。</code></li></ul> 
</blockquote> 
<h3><a id="_152"></a>拥塞控制</h3> 
<blockquote> 
 <p>为什么要有拥塞控制呀，不是有流量控制了吗？</p> 
</blockquote> 
<ul><li><code>流量控制是避免「发送方」的数据填满「接收方」的缓存</code>，但是并不知道网络的中发生了什么。</li><li>在网络出现拥堵时，如果继续发送大量数据包，可能会导致数据包时延、丢失等，这时 TCP 就会重传数据，但是一重传就会导致网络的负担更重，于是会导致更大的延迟以及更多的丢包，这个情况就会进入恶性循环被不断地放大…</li><li><code>拥塞控制，控制的目的就是避免「发送方」的数据填满整个网络。</code></li></ul> 
<blockquote> 
 <p>什么是拥塞窗口？和发送窗口有什么关系呢？</p> 
</blockquote> 
<ul><li>拥塞窗口 cwnd是发送方维护的一个的状态变量，它会根据网络的拥塞程度动态变化的。</li><li>发送窗口 swnd 和接收窗口 rwnd 是约等于的关系，由于加入了拥塞窗口后，此时发送窗口的值是swnd = min(cwnd, rwnd)，也就是拥塞窗口和接收窗口中的最小值。</li><li>拥塞窗口 cwnd 变化的规则： 
  <ul><li>只要网络中没有出现拥塞，cwnd 就会增大；</li><li>但网络中出现了拥塞，cwnd 就减少；</li></ul> </li></ul> 
<blockquote> 
 <p>那么怎么知道当前网络是否出现了拥塞呢？</p> 
</blockquote> 
<ul><li>只要「发送方」没有在规定时间内接收到 ACK 应答报文，也就是发生了超时重传，就会认为网络出现了拥塞。</li></ul> 
<blockquote> 
 <p>拥塞控制有哪些控制算法？</p> 
</blockquote> 
<ul><li>慢启动</li><li>拥塞避免</li><li>拥塞发生</li><li>快速恢复</li></ul> 
<h4><a id="_178"></a>慢启动</h4> 
<ul><li>慢启动的算法：<code>当发送方每收到一个 ACK，拥塞窗口 cwnd 的大小就会加 1</code>。</li></ul> 
<blockquote> 
 <p>例子</p> 
 <ul><li>连接建立完成后，一开始初始化 cwnd = 1，表示可以传一个 MSS 大小的数据。</li><li>当收到一个 ACK 确认应答后，cwnd 增加 1，于是一次能够发送 2 个</li><li>当收到 2 个的 ACK 确认应答后， cwnd 增加 2，于是就可以比之前多发2 个，所以这一次能够发送 4 个</li><li>当这 4 个的 ACK 确认到来的时候，每个确认 cwnd 增加 1， 4 个确认 cwnd 增加 4，于是就可以比之前多发 4 个，所以这一次能够发送 8 个。<br> <img src="https://images2.imgbox.com/98/fc/0PwvMZVc_o.png" alt="在这里插入图片描述"></li></ul> 
</blockquote> 
<blockquote> 
 <p>那慢启动涨到什么时候是个头呢？</p> 
</blockquote> 
<ul><li>慢启动门限 ssthresh （slow start threshold）状态变量。 
  <ul><li>当 cwnd &lt; ssthresh 时，使用慢启动算法。</li><li>当 cwnd &gt;= ssthresh 时，就会使用「拥塞避免算法」。</li></ul> </li></ul> 
<h4><a id="_193"></a>拥塞避免</h4> 
<ul><li>进入拥塞避免算法后，它的规则是：<code>每当收到一个 ACK 时，cwnd 增加 1/cwnd。</code></li></ul> 
<blockquote> 
 <p>例子</p> 
 <ul><li>现假定 ssthresh 为 8： 
   <ul><li>当 8 个 ACK 应答确认到来时，每个确认增加 1/8，8 个 ACK 确认 cwnd 一共增加 1，于是这一次能够发送 9 个 MSS 大小的数据，变成了线性增长。<br> <img src="https://images2.imgbox.com/9a/39/oj6QRBgs_o.png" alt="在这里插入图片描述"></li></ul> </li><li>这么一直增长着后，网络就会慢慢进入了拥塞的状况了，于是就会出现丢包现象，这时就需要对丢失的数据包进行重传。</li><li><code>当触发了重传机制，也就进入了「拥塞发生算法」</code>。</li></ul> 
</blockquote> 
<h4><a id="_203"></a>拥塞发生</h4> 
<p>当网络出现拥塞，也就是会发生数据包重传，重传机制主要有两种：</p> 
<ul><li>超时重传</li><li>快速重传</li></ul> 
<blockquote> 
 <p>发生超时重传的拥塞发生算法</p> 
</blockquote> 
<ul><li>当发生了「超时重传」，则就会使用拥塞发生算法。</li><li>ssthresh 和 cwnd 的值会发生变化： 
  <ul><li>ssthresh 设为 cwnd/2，</li><li>cwnd 重置为 1 （是恢复为 cwnd 初始化值，我这里假定 cwnd 初始化值 1）<br> <img src="https://images2.imgbox.com/61/c6/OX2uBkzl_o.png" alt="在这里插入图片描述"></li></ul> </li><li>接着，就重新开始慢启动，慢启动是会突然减少数据流的。这真是一旦「超时重传」，马上回到解放前。但是这种方式太激进了，反应也很强烈，会造成网络卡顿。</li></ul> 
<blockquote> 
 <p>发生快速重传的拥塞发生算法</p> 
</blockquote> 
<ul><li>快速重传算法：当接收方发现丢了一个中间包的时候，发送三次前一个包的 ACK，于是发送端就会快速地重传，不必等待超时再重传。</li><li>TCP 认为这种情况不严重，因为大部分没丢，只丢了一小部分，则 ssthresh 和 cwnd 变化如下： 
  <ul><li>cwnd = cwnd/2 ，也就是设置为原来的一半;</li><li>ssthresh = cwnd;</li><li>进入快速恢复算法</li></ul> </li></ul> 
<h4><a id="_224"></a>快速恢复</h4> 
<ul><li> <p>快速恢复算法是认为，你还能收到 3 个重复 ACK 说明网络也不那么糟糕，所以没有必要像 RTO 超时那么强烈。</p> </li><li> <p>进入快速恢复之前，cwnd 和 ssthresh 已被更新了：</p> 
  <ul><li>cwnd = cwnd/2 ，也就是设置为原来的一半;</li><li>ssthresh = cwnd;</li></ul> </li><li> <p><code>进入快速恢复算法如下</code>：</p> 
  <ul><li>拥塞窗口 cwnd = ssthresh + 3 （ 3 的意思是确认有 3 个数据包被收到了）；</li><li>重传丢失的数据包；</li><li>如果再收到重复的 ACK，那么 cwnd 增加 1；</li><li>如果收到新数据的 ACK 后，把 cwnd 设置为第一步中的 ssthresh 的值，原因是该 ACK 确认了新的数据，说明从 duplicated ACK 时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，也即再次进入拥塞避免状态；<br> <img src="https://images2.imgbox.com/a9/e6/WtD9ItvM_o.png" alt="在这里插入图片描述"></li></ul> </li></ul> 
<blockquote> 
 <p>快速恢复算法过程中，为什么收到新的数据后，cwnd 设置回了 ssthresh ？</p> 
 <ol><li>在快速恢复的过程中，首先 ssthresh = cwnd/2，然后 cwnd = ssthresh + 3，表示网络可能出现了阻塞，所以需要减小 cwnd 以避免，加 3 代表快速重传时已经确认接收到了 3 个重复的数据包；</li><li>随后继续重传丢失的数据包，如果再收到重复的 ACK，那么 cwnd 增加 1。加 1 代表每个收到的重复的 ACK 包，都已经离开了网络。这个过程的目的是尽快将丢失的数据包发给目标。</li><li>如果收到新数据的 ACK 后，把 cwnd 设置为第一步中的 ssthresh 的值，恢复过程结束。</li></ol> 
 <ul><li><code>首先，快速恢复是拥塞发生后慢启动的优化，其首要目的仍然是降低 cwnd 来减缓拥塞，所以必然会出现 cwnd 从大到小的改变。</code></li><li><code>其次，过程2（cwnd逐渐加1）的存在是为了尽快将丢失的数据包发给目标，从而解决拥塞的根本问题（三次相同的 ACK 导致的快速重传），所以这一过程中 cwnd 反而是逐渐增大的。</code></li></ul> 
</blockquote> 
<p>文章参考<a href="https://www.xiaolincoding.com/" rel="nofollow">https://www.xiaolincoding.com/</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5f0f59ed06cfd124ec04292176fb04e2/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">C# Winform 中使用 Webview2</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/dc77698a03e8a6bb94874c7e0c214688/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">mac中JAVA环境变量配置步骤</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>