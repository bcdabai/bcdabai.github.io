<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>一篇吃透布隆过滤器（Bloom Filter）及其使用场景 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="一篇吃透布隆过滤器（Bloom Filter）及其使用场景" />
<meta property="og:description" content="目录
1、什么是布隆过滤器
2、布隆过滤器的原理
2.1 布隆过滤器的数据结构
2.2 布隆过滤器的检索和插入原理
2.3 布隆过滤器元素的修改和删除
3、布隆过滤器的使用场景
3.1 Redis通过布隆过滤器防止缓存穿透
3.2 RocketMQ通过布隆过滤器防止消息重复消费
4、布隆过滤器优缺点
4.1 优点：
4.2 缺点：
1、什么是布隆过滤器 以下定义来自百度百科：
布隆过滤器（Bloom Filter）是1970年由布隆提出的。它实际上是一个很长的二进制向量和一系列随机映射函数。布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都比一般的算法要好的多，缺点是有一定的误识别率和删除困难。
从上述定义我们可以得到以下关键信息：
布隆过滤器是由很长的二进制向量（即可以理解成很长的0、1数组）与一系列随机映射函数（Hash函数）构成。布隆过滤器的作用是检索一个元素是否存在我们的集合之中。优点是空间效率和查询时间都比一般的算法要好的多；缺点是有一定的误识别率和删除困难。 (*^▽^*)OK，那我们就根据这个定义得到的信息来详细的讲解我们的布隆过滤器。请大家耐心观看~
注意！接下来的原理我们都会基于定义来逐句解释和讲解布隆过滤器，请大家记住上述三点关键信息。
2、布隆过滤器的原理 2.1 布隆过滤器的数据结构 我们从定义总结的关键信息可知：布隆过滤器是由很长的二进制向量（即可以理解成很长的0、1数组）与一系列随机映射函数（Hash函数）构成。因此我们可以将布隆过滤器理解成下图这种很长的一个二进制数组：
正是由于布隆过滤器的数据结构仅需要存储“0”或“1”，因此所占用内存极少，这也是布隆过滤器的一大优点。 2.2 布隆过滤器的检索和插入原理 从上图布隆过滤器的数据结构图和定义的关键信息我们可以知道：布隆过滤器实际上是个很长的二进制数组，作用是检索一个元素是否存在我们的集合之中。那么布隆过滤器是如何通过上述数据结构判断一个元素是否存在我们的集合之中的呢？
这里就需要用到我们定义中提到的“一系列随机映射函数（Hash函数）”了。
首先我们需要知道什么是Hash函数？这里我们给出Hash函数的一个简要的说明：
简单来说Hash函数就是把输入值通过特定方式（hash函数） 处理后 生成一个值，这个值等同于存放数据的地址。
比如我们当前的Hash函数是 y=x²&amp;（len-1），这里y是指最终在布隆过滤器的数据结构（二进制数组）中存放的下标位置，x指我们传入的值，len指数组的长度。那么如果当数组长度为100（举个例子，实际上数组长度是很长的），传入的值为5，则我们通过Hash函数得到的下标为25。那么此时我们便将下标25的值从0标为1。这就是插入（增加）数据的原理。
插入（增加）数据流程图如下：
那么，当我们下次再输入这个值的时候，我们会得到当前数组对应下标的值为1，说明我们有这个数字！这是不是就是检索的原理了！
检索流程图如下：
当然，这里有基础的同学肯定会发现我们上述说的过程虽然很简单，但是存在很大的问题：
①存在Hash冲突导致误判：
首先我们先对Hash冲突作一个简要说明：
根据key（键值）即经过一个Hash函数F(key)得到的结果的作为地址去存放当前的value值，但是却发现算出来的地址上已经被占用了，这就是所谓的hash冲突。
我们基于上述例子继续讲，在经过上述流程后，我们数组下标为25的值是1。此时我们传入一个值25，那么通过我们上述举例的Hash算法计算后得到的数组下标值也为25，那么此时布隆过滤器是不是就会认为值25是存在的！但是实际上是因为5和25经过Hash映射后得到同一个地址，导致了误判！
当然，这么简单的问题伟大的“布隆先生”肯定不会犯如此“低级”的错误，因此解决方法就和我们上述定义中的关键字“一系列Hash函数”有关了。
我们通过“一系列的Hash函数”，比如Hash函数①y=x²&amp;（len-1）②y=(2*x)&amp;(len-1) ③y=(x&#43;x²)&amp;(len-1) 这三个Hash函数一起来决定某个元素是否存在我们的集合中。
也就是检索流程变为：将key值传入一系列Hash函数得到对应的一系列数组地址（索引下标），注意这里一般来说有几个Hash函数就会得到几个地址，然后去判断这几个索引下标对应的值是否均为1，是的话则说明存在，否则不存在。
上述才是布隆过滤器检索元素是否存在的真正流程，检索元素流程图因此对应变化如下： 插入元素流程变为：根据一系列Hash函数得到一系列地址，将对应地址下标值改为1，流程图如下：
当然，我们从布隆过滤器定义中提到的缺点可以知道：布隆过滤器会有一定误判率。说明即使是在一系列Hash函数下，依然会有巧合：“一个不存在的元素，对应的一系列映射后的地址的值为1，即出现误判”。这也是无法避免的事情，毕竟如果数据量很大的话，很难防止有一定量的、不存在的“幸运儿”能通过布隆过滤器的筛选。
当然，我们在使用布隆过滤器的时候能通过设置两个参数：①预期数据量 ②误判率期望值。我们可以通过设置“误判率期望值”来达到我们能接受的误判率。
当然！大家别异想天开：“哎呀，那我设置0不就行了吗？”这肯定是不可能的，而且设置的误判率越低，数据量越大，占用内存则越大，运行时间则越慢！这也很好理解：数据量越大肯定占用越多内存空间，误判率越低则说明要越多的Hash函数来进行运算，则运行时间越慢，一个key对应的地址也多了，肯定占用越多内存空间。
2.3 布隆过滤器元素的修改和删除 我们从定义可以知道：我们想要修改或删除一个元素时，同时去保证布隆过滤器不受影响是几乎不可能的。
为什么这样说呢，由于我们在插入元素时，不同的值可能经过一系列Hash函数后得到的一系列地址，总有可能两个或多个值经过某个Hash函数映射后得到其中一个地址会一样，此时数组中对应的下标肯定为1，当我们删除或修改某个元素后，我们如果想将其原来对应地址的值从1改为0后，无法确定这个地址是否也对应其他值，如果贸然修改，可能会导致其他原本存在的值在检索时返回不存在的情况！这种情况是极其危险的，可能会导致数据的“逻辑丢失”。
因此我们这里不讨论修改和删除的情况。因为布隆过滤器对元素的删除不太支持，目前有一些变形的特定布隆过滤器支持元素的删除。
3、布隆过滤器的使用场景 3.1 Redis通过布隆过滤器防止缓存穿透 首先我们需要知道什么是缓存穿透，这里我们给出缓存穿透的定义。当然大家也可以去我主页看我关于Redis缓存写的文章：点我！！！传送门！！！" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/cce4fc60ba8c4a7d34930fbef045a70d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-05-16T00:49:54+08:00" />
<meta property="article:modified_time" content="2023-05-16T00:49:54+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">一篇吃透布隆过滤器（Bloom Filter）及其使用场景</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8-toc" style="margin-left:0px;"><a href="#1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8" rel="nofollow">1、什么是布隆过滤器</a></p> 
<p id="2%E3%80%81%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E7%9A%84%E5%8E%9F%E7%90%86-toc" style="margin-left:0px;"><a href="#2%E3%80%81%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E7%9A%84%E5%8E%9F%E7%90%86" rel="nofollow">2、布隆过滤器的原理</a></p> 
<p id="2.1%20%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-toc" style="margin-left:40px;"><a href="#2.1%20%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84" rel="nofollow">2.1 布隆过滤器的数据结构</a></p> 
<p id="2.2%20%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E7%9A%84%E6%A3%80%E7%B4%A2%E5%92%8C%E6%8F%92%E5%85%A5%E5%8E%9F%E7%90%86-toc" style="margin-left:40px;"><a href="#2.2%20%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E7%9A%84%E6%A3%80%E7%B4%A2%E5%92%8C%E6%8F%92%E5%85%A5%E5%8E%9F%E7%90%86" rel="nofollow">2.2 布隆过滤器的检索和插入原理</a></p> 
<p id="2.3%20%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E5%85%83%E7%B4%A0%E7%9A%84%E4%BF%AE%E6%94%B9%E5%92%8C%E5%88%A0%E9%99%A4-toc" style="margin-left:40px;"><a href="#2.3%20%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E5%85%83%E7%B4%A0%E7%9A%84%E4%BF%AE%E6%94%B9%E5%92%8C%E5%88%A0%E9%99%A4" rel="nofollow">2.3 布隆过滤器元素的修改和删除</a></p> 
<p id="3%E3%80%81%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-toc" style="margin-left:0px;"><a href="#3%E3%80%81%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF" rel="nofollow">3、布隆过滤器的使用场景</a></p> 
<p id="3.1%20Redis%E9%80%9A%E8%BF%87%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E9%98%B2%E6%AD%A2%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F-toc" style="margin-left:40px;"><a href="#3.1%20Redis%E9%80%9A%E8%BF%87%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E9%98%B2%E6%AD%A2%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F" rel="nofollow">3.1 Redis通过布隆过滤器防止缓存穿透</a></p> 
<p id="3.2%20RocketMQ%E9%80%9A%E8%BF%87%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E9%98%B2%E6%AD%A2%E6%B6%88%E6%81%AF%E9%87%8D%E5%A4%8D%E6%B6%88%E8%B4%B9-toc" style="margin-left:40px;"><a href="#3.2%20RocketMQ%E9%80%9A%E8%BF%87%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E9%98%B2%E6%AD%A2%E6%B6%88%E6%81%AF%E9%87%8D%E5%A4%8D%E6%B6%88%E8%B4%B9" rel="nofollow">3.2 RocketMQ通过布隆过滤器防止消息重复消费</a></p> 
<p id="4%E3%80%81%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E4%BC%98%E7%BC%BA%E7%82%B9-toc" style="margin-left:0px;"><a href="#4%E3%80%81%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E4%BC%98%E7%BC%BA%E7%82%B9" rel="nofollow">4、布隆过滤器优缺点</a></p> 
<p id="4.1%20%E4%BC%98%E7%82%B9%EF%BC%9A-toc" style="margin-left:40px;"><a href="#4.1%20%E4%BC%98%E7%82%B9%EF%BC%9A" rel="nofollow">4.1 优点：</a></p> 
<p id="4.2%C2%A0%E7%BC%BA%E7%82%B9%EF%BC%9A-toc" style="margin-left:40px;"><a href="#4.2%C2%A0%E7%BC%BA%E7%82%B9%EF%BC%9A" rel="nofollow">4.2 缺点：</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2>1、什么是布隆过滤器</h2> 
<p>以下定义来自百度百科：</p> 
<blockquote> 
 <p>布隆过滤器（Bloom Filter）是1970年由布隆提出的。它实际上是一个很长的<a href="https://baike.baidu.com/item/%E4%BA%8C%E8%BF%9B%E5%88%B6/361457?fromModule=lemma_inlink" rel="nofollow" title="二进制">二进制</a>向量和一系列随机映射函数。布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都比一般的算法要好的多，缺点是有一定的误识别率和删除困难。</p> 
</blockquote> 
<p>从上述定义我们可以得到以下关键信息：</p> 
<ol><li>布隆过滤器是由很长的二进制向量（即可以理解成很长的0、1数组）与一系列随机映射函数（Hash函数）构成。</li><li>布隆过滤器的作用是检索一个元素是否存在我们的集合之中。</li><li>优点是空间效率和查询时间都比一般的算法要好的多；缺点是有一定的误识别率和删除困难。</li></ol> 
<p>(*^▽^*)OK，那我们就根据这个定义得到的信息来详细的讲解我们的布隆过滤器。请大家耐心观看~</p> 
<p><strong>注意！接下来的原理我们都会基于定义来逐句解释和讲解布隆过滤器，请大家记住上述三点关键信息。</strong></p> 
<h2 id="2%E3%80%81%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E7%9A%84%E5%8E%9F%E7%90%86">2、布隆过滤器的原理</h2> 
<h3 id="2.1%20%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">2.1 布隆过滤器的数据结构</h3> 
<p>我们从定义总结的关键信息可知：<strong>布隆过滤器是由很长的二进制向量（即可以理解成很长的0、1数组）与一系列随机映射函数（Hash函数）构成</strong>。因此我们可以将布隆过滤器理解成下图这种很长的一个二进制数组：</p> 
<p><img alt="" height="157" src="https://images2.imgbox.com/e0/5e/AcuH0XsV_o.png" width="1200"></p> 
<p>正是由于布隆过滤器的数据结构仅需要存储“0”或“1”，因此所占用内存极少，这也是布隆过滤器的一大优点。 </p> 
<h3 id="2.2%20%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E7%9A%84%E6%A3%80%E7%B4%A2%E5%92%8C%E6%8F%92%E5%85%A5%E5%8E%9F%E7%90%86">2.2 布隆过滤器的检索和插入原理</h3> 
<p>从上图布隆过滤器的数据结构图和定义的关键信息我们可以知道：布隆过滤器实际上是个很长的二进制数组，作用是检索一个元素是否存在我们的集合之中。那么布隆过滤器是如何通过上述数据结构判断一个元素是否存在我们的集合之中的呢？</p> 
<p>这里就需要用到我们定义中提到的“一系列<strong>随机映射函数（Hash函数）</strong>”了。</p> 
<p>首先我们需要知道什么是Hash函数？这里我们给出Hash函数的一个简要的说明：</p> 
<blockquote> 
 <p>简单来说Hash函数就是把输入值通过特定方式（hash函数） 处理后 生成一个值，这个值等同于存放数据的地址。</p> 
</blockquote> 
<p>比如我们当前的Hash函数是 y=x²&amp;（len-1），这里y是指最终在布隆过滤器的数据结构（二进制数组）中存放的下标位置，x指我们传入的值，len指数组的长度。那么如果当数组长度为100（举个例子，实际上数组长度是很长的），传入的值为5，则我们通过Hash函数得到的下标为25。那么此时我们便将下标25的值从0标为1。这就是插入（增加）数据的原理。</p> 
<p>插入（增加）数据流程图如下：</p> 
<p><img alt="" height="554" src="https://images2.imgbox.com/16/73/FvnnQ0aU_o.png" width="1200"></p> 
<p>那么，当我们下次再输入这个值的时候，我们会得到当前数组对应下标的值为1，说明我们有这个数字！这是不是就是检索的原理了！</p> 
<p>检索流程图如下：</p> 
<p><img alt="" height="507" src="https://images2.imgbox.com/5c/f6/X03J6JUf_o.png" width="1200"></p> 
<p>当然，这里有基础的同学肯定会发现我们上述说的过程虽然很简单，但是存在很大的问题：</p> 
<p><strong>①存在Hash冲突导致误判：</strong></p> 
<p>首先我们先对Hash冲突作一个简要说明：</p> 
<blockquote> 
 <p><strong>根据key（键值）即经过一个Hash函数F(key)得到的结果的作为地址去存放当前的value值，但是却发现算出来的地址上已经被占用了，这就是所谓的hash冲突。</strong></p> 
</blockquote> 
<p>我们基于上述例子继续讲，在经过上述流程后，我们数组下标为25的值是1。此时我们传入一个值25，那么通过我们上述举例的Hash算法计算后得到的数组下标值也为25，那么此时布隆过滤器是不是就会认为值25是存在的！但是实际上是<strong>因为5和25经过Hash映射后得到同一个地址，导致了误判</strong>！</p> 
<p>当然，这么简单的问题伟大的“布隆先生”肯定不会犯如此“低级”的错误，因此解决方法就和我们上述定义中的关键字“<span style="color:#fe2c24;">一系列</span><strong>Hash函数</strong>”有关了。</p> 
<p>我们通过“一系列的Hash函数”，比如Hash函数①y=x²&amp;（len-1）②y=(2*x)&amp;(len-1) ③y=(x+x²)&amp;(len-1) 这三个Hash函数一起来决定某个元素是否存在我们的集合中。</p> 
<p>也就是检索流程变为：<strong>将key值传入一系列Hash函数得到对应的一系列数组地址（索引下标），注意这里一般来说有几个Hash函数就会得到几个地址，然后去判断这几个索引下标对应的值是否<span style="color:#fe2c24;">均为1</span>，是的话则说明存在，否则不存在。</strong></p> 
<p>上述才是布隆过滤器检索元素是否存在的真正流程，检索元素流程图因此对应变化如下： </p> 
<p><img alt="" height="669" src="https://images2.imgbox.com/15/4e/ljIZBMQp_o.png" width="1200"></p> 
<p>插入元素流程变为：根据一系列Hash函数得到一系列地址，将对应地址下标值改为1，流程图如下：</p> 
<p><img alt="" height="758" src="https://images2.imgbox.com/8e/e0/UKnmu2nM_o.png" width="1200"></p> 
<p>当然，我们从布隆过滤器定义中提到的缺点可以知道：<strong>布隆过滤器会有一定误判率。说明即使是在一系列Hash函数下，依然会有巧合：“一个不存在的元素，对应的一系列映射后的地址的值为1，即出现误判”</strong>。这也是无法避免的事情，毕竟如果数据量很大的话，很难防止有一定量的、不存在的“幸运儿”能通过布隆过滤器的筛选。</p> 
<p>当然，我们在使用布隆过滤器的时候能通过设置两个参数：①预期数据量 ②误判率期望值。我们可以通过设置“误判率期望值”来达到我们能接受的误判率。</p> 
<p>当然！大家别异想天开：“哎呀，那我设置0不就行了吗？”这肯定是不可能的，而且设置的误判率越低，数据量越大，占用内存则越大，运行时间则越慢！这也很好理解：<strong>数据量越大肯定占用越多内存空间，误判率越低则说明要越多的Hash函数来进行运算，则运行时间越慢，一个key对应的地址也多了，肯定占用越多内存空间。</strong></p> 
<h3 id="2.3%20%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E5%85%83%E7%B4%A0%E7%9A%84%E4%BF%AE%E6%94%B9%E5%92%8C%E5%88%A0%E9%99%A4">2.3 布隆过滤器元素的修改和删除</h3> 
<p>我们从定义可以知道：我们想要修改或删除一个元素时，同时去保证布隆过滤器不受影响是几乎不可能的。</p> 
<p>为什么这样说呢，<strong>由于我们在插入元素时，不同的值可能经过一系列Hash函数后得到的一系列地址，总有可能两个或多个值经过某个Hash函数映射后得到其中一个地址会一样，此时数组中对应的下标肯定为1，当我们删除或修改某个元素后，我们如果想将其原来对应地址的值从1改为0后，<span style="color:#ed7976;">无法确定这个地址是否也对应其他值</span>，如果贸然修改，可能会导致其他原本存在的值在检索时返回不存在的情况！</strong>这种情况是极其危险的，可能会导致数据的“逻辑丢失”。</p> 
<p>因此我们这里不讨论修改和删除的情况。因为布隆过滤器对元素的删除不太支持，目前有一些变形的特定布隆过滤器支持元素的删除。</p> 
<h2 id="3%E3%80%81%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF">3、布隆过滤器的使用场景</h2> 
<h3 id="3.1%20Redis%E9%80%9A%E8%BF%87%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E9%98%B2%E6%AD%A2%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F">3.1 Redis通过布隆过滤器防止缓存穿透</h3> 
<p>首先我们需要知道什么是缓存穿透，这里我们给出缓存穿透的定义。当然大家也可以去我主页看我关于Redis缓存写的文章：<a class="link-info" href="https://blog.csdn.net/weixin_64366370/article/details/128619005?spm=1001.2014.3001.5502" title="点我！！！传送门！！！">点我！！！传送门！！！</a></p> 
<blockquote> 
 <p>Redis缓存穿透指访问一个缓存和数据库中都不存在的key，由于这个key在缓存中不存在，则会到数据库中查询，数据库中也不存在该key，无法将数据添加到缓存中，所以每次都会访问数据库导致数据库压力增大。</p> 
</blockquote> 
<p>我们可以在访问Redis之前使用布隆过滤器来对请求的key进行过滤， 可以大大减少那些恶意攻击。当然，会存在一定误判率，但是使用布隆过滤器后，“不法分子”肯定对我们服务器就没那么容易进行恶意攻击了。</p> 
<h3 id="3.2%20RocketMQ%E9%80%9A%E8%BF%87%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E9%98%B2%E6%AD%A2%E6%B6%88%E6%81%AF%E9%87%8D%E5%A4%8D%E6%B6%88%E8%B4%B9">3.2 RocketMQ通过布隆过滤器防止消息重复消费</h3> 
<p>为了防止RocketMQ消息重复消费，我们发送消息时可以对每个消息设置唯一的key，然后在消费者处利用布隆过滤器对消息的key检索，如果存在则说明消息已经消费过，不消费。不存在则进行消费，然后插入布隆过滤器。</p> 
<p>当然，上面两个例子仅仅是举的例子，布隆过滤器能使用的地方很多，只要但凡涉及“数据过滤”均可以考虑使用“布隆过滤器”来实现。</p> 
<h2 id="4%E3%80%81%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E4%BC%98%E7%BC%BA%E7%82%B9">4、布隆过滤器优缺点</h2> 
<h3 id="4.1%20%E4%BC%98%E7%82%B9%EF%BC%9A">4.1 优点：</h3> 
<ul><li>时间复杂度低，增加和查询元素的时间复杂为O(N)，（N为哈希函数的个数，通常情况比较小）</li><li>保密性强，布隆过滤器不存储元素本身</li><li>存储空间小，如果允许存在一定的误判，布隆过滤器是非常节省空间的（相比其他数据结构如Set、Map集合）</li></ul> 
<h3 id="4.2%C2%A0%E7%BC%BA%E7%82%B9%EF%BC%9A">4.2 <strong>缺点：</strong></h3> 
<ul><li>有点一定的误判率，但是可以通过调整参数来降低</li><li>无法获取元素本身</li><li>很难删除元素</li></ul> 
<p>以上是布隆过滤器的介绍，大家一键三连就是对我最大的支持！谢谢大家！</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c864bea107bf2fa40b5a0fe4d1a70879/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Nordic NRF24L01&#43;与NRF52832通信两个问题(地址设短、数据左移)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9059d800989983b1a4ff0fc5c11f0e30/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">npm install时 cannot read properties of null的问题</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>