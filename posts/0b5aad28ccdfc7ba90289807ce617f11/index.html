<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>请求分页系统中的置换算法(FIFO、LRU、Optimal) - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="请求分页系统中的置换算法(FIFO、LRU、Optimal)" />
<meta property="og:description" content="操作系统实验导航 实验一：银行家算法 https://blog.csdn.net/weixin_46291251/article/details/115384510
实验二：多级队列调度和多级反馈队列调度算法 https://blog.csdn.net/weixin_46291251/article/details/115530582
实验三：动态分区式内存管理 https://blog.csdn.net/weixin_46291251/article/details/115772341
实验四：Linux下多进程通信 https://blog.csdn.net/weixin_46291251/article/details/116274665
实验五：进程通信的三种方式 https://blog.csdn.net/weixin_46291251/article/details/116301250
实验六：Linux文件系统实验 https://blog.csdn.net/weixin_46291251/article/details/116423798
实验七：自制简单U盘引导程序 https://blog.csdn.net/weixin_46291251/article/details/116427629
实验八：磁盘调度算法 https://blog.csdn.net/weixin_46291251/article/details/116431907
实验九：请求分页系统中的置换算法 https://blog.csdn.net/weixin_46291251/article/details/116443021
学习笔记：操作系统复习笔记 https://blog.csdn.net/weixin_46291251/article/details/117086851
背景 先进先出（FIFO）页面置换算法
该算法总是淘汰最新进入内存的页面，即选择在内存中驻留时间最久的页面予以淘汰。该算法实现简单，只需把一个进程已调入内存的页面，按先后次序链接成一个队列，并设置一个指针，称为替换指针，使它总是指向最老的页面。最近最久未使用（LRU）页面置换算法
最近最久未使用（LRU）页面置换算法，是根据页面调入内存后的使用情况进行决策的。由于无法预测各页面将来的使用情况，只能利用“最近的过去”作为“最近的将来”的近似， 因此，LRU 置换算法是选择最近最久未使用的页面予以淘汰。该算法赋予每个页面一个访问字段，用来记录一个页面自上次被访问以来所经历的时间 t，当需淘汰一个页面时，选择现有页面中其 t 值最大的，即最近最久未使用的页面予以淘汰。最佳（Optimal）页面置换算法
该算法选择的被淘汰页面，将是以后永远不使用的，或许是在最长（未来）时间内不再被访问的页面。采用该算法，通常可保证获得最低的缺页率。但由于人们目前还无法预知一个进程在内存的若干个页面中，哪一个页面是未来最长时间内不再被访问的，因而该算法是无法实现的，但可以利用该算法去评价其他算法。 题目描述：请求分页系统中的置换算法 1.通过如下方法产生一指令序列，共 320 条指令。 A. 在[1，32k-2]的指令地址之间随机选取一起点M,访问 M；B. 顺序访问M&#43;1；C. 在[0，M-1]中随机选取M1，访问 M1；D. 顺序访问M1&#43;1；E. 在[M1&#43;2，32k-2]中随机选取M2，访问 M2；F. 顺序访问M2&#43;1；G. 重复 A—F，直到执行 320 次指令。H.指令序列变换成页地址流设：（1）页面大小为 1K；（2）用户虚存容量为 32K。 2. 计算并输出下述各种算法在不同内存页块(页块个数范围:8-32)下的命中率。 A. 先进先出（FIFO）页面置换算法B. 最近最久未使用（LRU）页面置换算法C. 最佳（Optimal）页面置换算法 提示： A.命中率=1-页面失效次数/页地址流长度B.本实验中，页地址流长度为 320，页面失效次数为每次访问相应指令时，该指令所对应的页不在内存的次数。 算法设计 整体设计 设置全局变量保存指令的个数和指令数组，在make_instruct()函数中生成随机数填充这个数组。
内存这里用链表来组织，表示如下：
struct node { int instruct = 0; int time = 0; node* next = NULL; }; instruct表示指令号，time在不同算法中有具体含义。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/0b5aad28ccdfc7ba90289807ce617f11/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-03-15T00:18:55+08:00" />
<meta property="article:modified_time" content="2022-03-15T00:18:55+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">请求分页系统中的置换算法(FIFO、LRU、Optimal)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><kbd> <mark>操作系统实验导航</mark> </kbd><br> <mark>实验一：银行家算法</mark><a href="https://blog.csdn.net/weixin_46291251/article/details/115384510"> https://blog.csdn.net/weixin_46291251/article/details/115384510</a><br> <mark>实验二：多级队列调度和多级反馈队列调度算法</mark><a href="https://blog.csdn.net/weixin_46291251/article/details/115530582"> https://blog.csdn.net/weixin_46291251/article/details/115530582</a><br> <mark>实验三：动态分区式内存管理</mark><a href="https://blog.csdn.net/weixin_46291251/article/details/115772341"> https://blog.csdn.net/weixin_46291251/article/details/115772341</a><br> <mark>实验四：Linux下多进程通信</mark> <a href="https://blog.csdn.net/weixin_46291251/article/details/116274665">https://blog.csdn.net/weixin_46291251/article/details/116274665</a><br> <mark>实验五：进程通信的三种方式</mark><a href="https://blog.csdn.net/weixin_46291251/article/details/116301250"> https://blog.csdn.net/weixin_46291251/article/details/116301250</a><br> <mark>实验六：Linux文件系统实验</mark><a href="https://blog.csdn.net/weixin_46291251/article/details/116423798"> https://blog.csdn.net/weixin_46291251/article/details/116423798</a><br> <mark>实验七：自制简单U盘引导程序</mark><a href="https://blog.csdn.net/weixin_46291251/article/details/116427629"> https://blog.csdn.net/weixin_46291251/article/details/116427629</a><br> <mark>实验八：磁盘调度算法</mark><a href="https://blog.csdn.net/weixin_46291251/article/details/116431907"> https://blog.csdn.net/weixin_46291251/article/details/116431907</a><br> <mark>实验九：请求分页系统中的置换算法</mark> <a href="https://blog.csdn.net/weixin_46291251/article/details/116443021">https://blog.csdn.net/weixin_46291251/article/details/116443021</a><br> <mark>学习笔记：操作系统复习笔记</mark><a href="https://blog.csdn.net/weixin_46291251/article/details/117086851"> https://blog.csdn.net/weixin_46291251/article/details/117086851</a></p> 
<h3><a id="_15"></a>背景</h3> 
<ol><li>先进先出（FIFO）页面置换算法<br> 该算法总是淘汰最新进入内存的页面，即选择在内存中驻留时间最久的页面予以淘汰。该算法实现简单，只需把一个进程已调入内存的页面，按先后次序链接成一个队列，并设置一个指针，称为替换指针，使它总是指向最老的页面。</li><li>最近最久未使用（LRU）页面置换算法<br> 最近最久未使用（LRU）页面置换算法，是根据页面调入内存后的使用情况进行决策的。由于无法预测各页面将来的使用情况，只能利用“最近的过去”作为“最近的将来”的近似， 因此，LRU 置换算法是选择最近最久未使用的页面予以淘汰。该算法赋予每个页面一个访问字段，用来记录一个页面自上次被访问以来所经历的时间 t，当需淘汰一个页面时，选择现有页面中其 t 值最大的，即最近最久未使用的页面予以淘汰。</li><li>最佳（Optimal）页面置换算法<br> 该算法选择的被淘汰页面，将是以后永远不使用的，或许是在最长（未来）时间内不再被访问的页面。采用该算法，通常可保证获得最低的缺页率。但由于人们目前还无法预知一个进程在内存的若干个页面中，哪一个页面是未来最长时间内不再被访问的，因而该算法是无法实现的，但可以利用该算法去评价其他算法。</li></ol> 
<h3><a id="_22"></a>题目描述：请求分页系统中的置换算法</h3> 
<h5><a id="1_320__24"></a>1.通过如下方法产生一指令序列，共 320 条指令。</h5> 
<ul><li>A. 在[1，32k-2]的指令地址之间随机选取一起点M,访问 M；</li><li>B. 顺序访问M+1；</li><li>C. 在[0，M-1]中随机选取M1，访问 M1；</li><li>D. 顺序访问M1+1；</li><li>E. 在[M1+2，32k-2]中随机选取M2，访问 M2；</li><li>F. 顺序访问M2+1；</li><li>G. 重复 A—F，直到执行 320 次指令。</li><li>H.指令序列变换成页地址流设：（1）页面大小为 1K；（2）用户虚存容量为 32K。</li></ul> 
<h5><a id="2_832_33"></a>2. 计算并输出下述各种算法在不同内存页块(页块个数范围:8-32)下的命中率。</h5> 
<ul><li>A. 先进先出（FIFO）页面置换算法</li><li>B. 最近最久未使用（LRU）页面置换算法</li><li>C. 最佳（Optimal）页面置换算法</li></ul> 
<h5><a id="_37"></a>提示：</h5> 
<ul><li>A.命中率=1-页面失效次数/页地址流长度</li><li>B.本实验中，页地址流长度为 320，页面失效次数为每次访问相应指令时，该指令所对应的页不在内存的次数。</li></ul> 
<h3><a id="_40"></a>算法设计</h3> 
<h5><a id="_41"></a>整体设计</h5> 
<p>设置全局变量保存指令的个数和指令数组，在<code>make_instruct()</code>函数中生成随机数填充这个数组。<br> 内存这里用链表来组织，表示如下：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">struct</span> node <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> instruct <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> time <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    node<span class="token operator">*</span> next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>instruct表示指令号，time在不同算法中有具体含义。<br> 三种算法对于三个函数，每个函数都是如：<code>double f(int a);</code>的格式，其中参数表示当前内存块大小（8-32），返回值是命中率。<br> 主函数只需对不同的内存块大小调用三个函数并输出结果即可。</p> 
<h5><a id="_56"></a>产生指令序列</h5> 
<p>首先写一个函数生成给定范围内的一个随机数，由于需要连续获得多个随机数，这里先在main函数srand一个种子，然后不断调用函数即可。</p> 
<pre><code class="prism language-cpp"><span class="token function">srand</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">rand</span><span class="token punctuation">(</span><span class="token keyword">int</span> min<span class="token punctuation">,</span> <span class="token keyword">int</span> max<span class="token punctuation">)</span><span class="token comment">//产生指定范围[min,max]的随机数。</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> <span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token punctuation">(</span>max <span class="token operator">-</span> min <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> min<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>构造指令序列，只需要简单的按照题目要求一步步做并且循环即可，注意这里只在循环开始处有一次判断，而每次循环会产生6个指令，所以这里将指令数组开大了一点，省去了多次判断。<br> <code>const int instruct_num = 320; int instruct_arr[instruct_num + 6];</code><br> 另外，为了输出结果的美观用<code>cout &lt;&lt; setw(8)</code>设置输出的宽度以对齐。</p> 
<pre><code class="prism language-cpp">
<span class="token keyword">void</span> <span class="token function">make_instruct</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token comment">//产生指令序列</span>
    <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;</span> instruct_num<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> M <span class="token operator">=</span> <span class="token function">rand</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        instruct_arr<span class="token punctuation">[</span>n<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> M<span class="token punctuation">;</span>
        instruct_arr<span class="token punctuation">[</span>n<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> M <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> M1 <span class="token operator">=</span> <span class="token function">rand</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> M <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        instruct_arr<span class="token punctuation">[</span>n<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> M1<span class="token punctuation">;</span>
        instruct_arr<span class="token punctuation">[</span>n<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> M1 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> M2 <span class="token operator">=</span> <span class="token function">rand</span><span class="token punctuation">(</span>M1 <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        instruct_arr<span class="token punctuation">[</span>n<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> M2<span class="token punctuation">;</span>
        instruct_arr<span class="token punctuation">[</span>n<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> M2 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h5><a id="FIFO_87"></a>先进先出（FIFO）</h5> 
<p>这是最基础的，以下的算法都继承这种思想，只是用于淘汰的策略有所变化。<br> 首先新建两个节点<code>Head</code>和<code>Tail</code>Head为头节点，其数据域<code>Head-&gt;instruct</code>表示当前内存中实际有多少被占用，其next指向第一块被占用的内存。Tail为尾指针，指向内存的尾部。<br> 算法首先是一层循环，遍历所有的（320个）指令。对于每个指令判断是否在内存中，若在则<code>hit</code>置为1。如果在内存中则不做任何操作，不在则要让<code>failure_times</code>加一，然后判断内存是否被占满，若未被占满则直接加入链表，若被占用则要淘汰当前队列中的一个指令，并将当前指令插入内存的合适位置。<br> 这里用到的淘汰算法：先进先出，即找到最先进来的即可，这里我是每次插入到链表尾，故链表头是最先进来的，所以每次都删除链表头后面的第一个指令并将新指令加到链表尾即可，注意每次更新Tail的位置。</p> 
<h5><a id="LRU_93"></a>最近最久未使用（LRU）</h5> 
<p>这里只介绍与FIFO不同之处。</p> 
<ul><li>设立一个变量<code>clock</code>表示时钟，初始值为999，主循环一次clock就减1.</li><li>如果当前指令在内存中则将其时间刷新为当前的时钟。</li><li>淘汰算法：遍历内存队列找到time最大的，将其替换为新的节点即可，新加入的节点time为当前时钟clock</li></ul> 
<h5><a id="Optimal_99"></a>最佳（Optimal）</h5> 
<ul><li>淘汰算法：每次遍历内存队列，对于每个指令，再次遍历全部指令集，找到将来还要多久这条指令会再被执行（下一个出现的位置减去当前位置）。</li></ul> 
<h3><a id="_101"></a>代码实现</h3> 
<pre><code class="prism language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;time.h&gt;</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iomanip&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">const</span> <span class="token keyword">int</span> instruct_num <span class="token operator">=</span> <span class="token number">320</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> instruct_arr<span class="token punctuation">[</span>instruct_num <span class="token operator">+</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> node <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> instruct <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> time <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    node<span class="token operator">*</span> next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">rand</span><span class="token punctuation">(</span><span class="token keyword">int</span> min<span class="token punctuation">,</span> <span class="token keyword">int</span> max<span class="token punctuation">)</span><span class="token comment">//产生指定范围[min,max]的随机数。</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> <span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token punctuation">(</span>max <span class="token operator">-</span> min <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> min<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">make_instruct</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token comment">//产生指令序列</span>
    <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;</span> instruct_num<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> M <span class="token operator">=</span> <span class="token function">rand</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        instruct_arr<span class="token punctuation">[</span>n<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> M<span class="token punctuation">;</span>
        instruct_arr<span class="token punctuation">[</span>n<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> M <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> M1 <span class="token operator">=</span> <span class="token function">rand</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> M <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        instruct_arr<span class="token punctuation">[</span>n<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> M1<span class="token punctuation">;</span>
        instruct_arr<span class="token punctuation">[</span>n<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> M1 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> M2 <span class="token operator">=</span> <span class="token function">rand</span><span class="token punctuation">(</span>M1 <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        instruct_arr<span class="token punctuation">[</span>n<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> M2<span class="token punctuation">;</span>
        instruct_arr<span class="token punctuation">[</span>n<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> M2 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">double</span> <span class="token function">C_FIFO</span><span class="token punctuation">(</span><span class="token keyword">int</span> block_size<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> failure_times <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    node<span class="token operator">*</span> Head <span class="token operator">=</span> <span class="token keyword">new</span> node<span class="token punctuation">;</span>
    node<span class="token operator">*</span> Tail <span class="token operator">=</span> Head<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> instruct_num<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> cur_instruct <span class="token operator">=</span> instruct_arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> hit <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
       
        <span class="token keyword">for</span> <span class="token punctuation">(</span>node<span class="token operator">*</span> p <span class="token operator">=</span> Head<span class="token operator">-</span><span class="token operator">&gt;</span>next<span class="token punctuation">;</span> p <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> p <span class="token operator">=</span> p<span class="token operator">-</span><span class="token operator">&gt;</span>next<span class="token punctuation">)</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token operator">-</span><span class="token operator">&gt;</span>instruct <span class="token operator">==</span> cur_instruct<span class="token punctuation">)</span>
                hit <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>hit<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            failure_times<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>Head<span class="token operator">-</span><span class="token operator">&gt;</span>instruct <span class="token operator">&gt;=</span> block_size<span class="token punctuation">)</span> <span class="token comment">//内存已满</span>
                Head<span class="token operator">-</span><span class="token operator">&gt;</span>next <span class="token operator">=</span> Head<span class="token operator">-</span><span class="token operator">&gt;</span>next<span class="token operator">-</span><span class="token operator">&gt;</span>next<span class="token punctuation">;</span>                       
            <span class="token keyword">else</span> 
                Head<span class="token operator">-</span><span class="token operator">&gt;</span>instruct<span class="token operator">++</span><span class="token punctuation">;</span>             
            
            Tail<span class="token operator">-</span><span class="token operator">&gt;</span>next <span class="token operator">=</span> <span class="token keyword">new</span> node<span class="token punctuation">;</span>
            Tail <span class="token operator">=</span> Tail<span class="token operator">-</span><span class="token operator">&gt;</span>next<span class="token punctuation">;</span>
            Tail<span class="token operator">-</span><span class="token operator">&gt;</span>instruct <span class="token operator">=</span> cur_instruct<span class="token punctuation">;</span>
            Tail<span class="token operator">-</span><span class="token operator">&gt;</span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> <span class="token number">1.0</span> <span class="token operator">-</span> <span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span>failure_times <span class="token operator">/</span> instruct_num<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">double</span> <span class="token function">C_LRU</span><span class="token punctuation">(</span><span class="token keyword">int</span> block_size<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> failure_times <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    node<span class="token operator">*</span> Head <span class="token operator">=</span> <span class="token keyword">new</span> node<span class="token punctuation">;</span>
    node<span class="token operator">*</span> Tail <span class="token operator">=</span> Head<span class="token punctuation">;</span>
    <span class="token keyword">int</span> clock <span class="token operator">=</span> <span class="token number">999</span><span class="token punctuation">;</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> instruct_num<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        clock<span class="token operator">--</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> cur_instruct <span class="token operator">=</span> instruct_arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> hit <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>node<span class="token operator">*</span> p <span class="token operator">=</span> Head<span class="token operator">-</span><span class="token operator">&gt;</span>next<span class="token punctuation">;</span> p <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> p <span class="token operator">=</span> p<span class="token operator">-</span><span class="token operator">&gt;</span>next<span class="token punctuation">)</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token operator">-</span><span class="token operator">&gt;</span>instruct <span class="token operator">==</span> cur_instruct<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                hit <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
                p<span class="token operator">-</span><span class="token operator">&gt;</span>time <span class="token operator">=</span> clock<span class="token punctuation">;</span><span class="token comment">//刷新时钟</span>
            <span class="token punctuation">}</span>
       
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>hit<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            failure_times<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>Head<span class="token operator">-</span><span class="token operator">&gt;</span>instruct <span class="token operator">&gt;=</span> block_size<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">//内存已满</span>
                node<span class="token operator">*</span> t <span class="token operator">=</span> <span class="token keyword">new</span> node<span class="token punctuation">;</span> t<span class="token operator">-</span><span class="token operator">&gt;</span>time <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
                <span class="token keyword">for</span> <span class="token punctuation">(</span>node<span class="token operator">*</span> p <span class="token operator">=</span> Head<span class="token operator">-</span><span class="token operator">&gt;</span>next<span class="token punctuation">;</span> p <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> p <span class="token operator">=</span> p<span class="token operator">-</span><span class="token operator">&gt;</span>next<span class="token punctuation">)</span><span class="token comment">//遍历找到最久未使用的</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token operator">-</span><span class="token operator">&gt;</span>time <span class="token operator">&gt;</span> t<span class="token operator">-</span><span class="token operator">&gt;</span>time<span class="token punctuation">)</span>
                        t <span class="token operator">=</span> p<span class="token punctuation">;</span>
                
                t<span class="token operator">-</span><span class="token operator">&gt;</span>instruct <span class="token operator">=</span> cur_instruct<span class="token punctuation">;</span>
                t<span class="token operator">-</span><span class="token operator">&gt;</span>time <span class="token operator">=</span> clock<span class="token punctuation">;</span>
      
            <span class="token punctuation">}</span>
            <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
                Head<span class="token operator">-</span><span class="token operator">&gt;</span>instruct<span class="token operator">++</span><span class="token punctuation">;</span>
                Tail<span class="token operator">-</span><span class="token operator">&gt;</span>next <span class="token operator">=</span> <span class="token keyword">new</span> node<span class="token punctuation">;</span>
                Tail <span class="token operator">=</span> Tail<span class="token operator">-</span><span class="token operator">&gt;</span>next<span class="token punctuation">;</span>
                Tail<span class="token operator">-</span><span class="token operator">&gt;</span>instruct <span class="token operator">=</span> cur_instruct<span class="token punctuation">;</span>
                Tail<span class="token operator">-</span><span class="token operator">&gt;</span>time <span class="token operator">=</span> clock<span class="token punctuation">;</span>
                Tail<span class="token operator">-</span><span class="token operator">&gt;</span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token number">1.0</span> <span class="token operator">-</span> <span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span>failure_times <span class="token operator">/</span> instruct_num<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">double</span> <span class="token function">C_Optimal</span><span class="token punctuation">(</span><span class="token keyword">int</span> block_size<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> failure_times <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    node<span class="token operator">*</span> Head <span class="token operator">=</span> <span class="token keyword">new</span> node<span class="token punctuation">;</span>
    node<span class="token operator">*</span> Tail <span class="token operator">=</span> Head<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> instruct_num<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> cur_instruct <span class="token operator">=</span> instruct_arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> hit <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

        <span class="token keyword">for</span> <span class="token punctuation">(</span>node<span class="token operator">*</span> p <span class="token operator">=</span> Head<span class="token operator">-</span><span class="token operator">&gt;</span>next<span class="token punctuation">;</span> p <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> p <span class="token operator">=</span> p<span class="token operator">-</span><span class="token operator">&gt;</span>next<span class="token punctuation">)</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token operator">-</span><span class="token operator">&gt;</span>instruct <span class="token operator">==</span> cur_instruct<span class="token punctuation">)</span>
                hit <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>hit<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            failure_times<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>Head<span class="token operator">-</span><span class="token operator">&gt;</span>instruct <span class="token operator">&gt;=</span> block_size<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">//内存已满</span>
                <span class="token comment">//找到每个请求还有多久会被用到</span>
                <span class="token keyword">for</span> <span class="token punctuation">(</span>node<span class="token operator">*</span> p <span class="token operator">=</span> Head<span class="token operator">-</span><span class="token operator">&gt;</span>next<span class="token punctuation">;</span> p <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> p <span class="token operator">=</span> p<span class="token operator">-</span><span class="token operator">&gt;</span>next<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                    p<span class="token operator">-</span><span class="token operator">&gt;</span>time <span class="token operator">=</span> <span class="token number">999</span><span class="token punctuation">;</span>
                    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> instruct_num<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>
                        <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token operator">-</span><span class="token operator">&gt;</span>instruct <span class="token operator">==</span> instruct_arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                            p<span class="token operator">-</span><span class="token operator">&gt;</span>time <span class="token operator">=</span> j <span class="token operator">-</span> i<span class="token punctuation">;</span>
                            <span class="token keyword">break</span><span class="token punctuation">;</span>
                        <span class="token punctuation">}</span>                 
                <span class="token punctuation">}</span>
                <span class="token comment">//找到最久不被用到的淘汰</span>
                node<span class="token operator">*</span> t <span class="token operator">=</span> <span class="token keyword">new</span> node<span class="token punctuation">;</span> t<span class="token operator">-</span><span class="token operator">&gt;</span>time <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
                <span class="token keyword">for</span> <span class="token punctuation">(</span>node<span class="token operator">*</span> p <span class="token operator">=</span> Head<span class="token operator">-</span><span class="token operator">&gt;</span>next<span class="token punctuation">;</span> p <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> p <span class="token operator">=</span> p<span class="token operator">-</span><span class="token operator">&gt;</span>next<span class="token punctuation">)</span><span class="token comment">//遍历找到最久未使用的</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token operator">-</span><span class="token operator">&gt;</span>time <span class="token operator">&gt;</span> t<span class="token operator">-</span><span class="token operator">&gt;</span>time<span class="token punctuation">)</span>
                        t <span class="token operator">=</span> p<span class="token punctuation">;</span>

                t<span class="token operator">-</span><span class="token operator">&gt;</span>instruct <span class="token operator">=</span> cur_instruct<span class="token punctuation">;</span>

            <span class="token punctuation">}</span>
            <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
                Head<span class="token operator">-</span><span class="token operator">&gt;</span>instruct<span class="token operator">++</span><span class="token punctuation">;</span>
                Tail<span class="token operator">-</span><span class="token operator">&gt;</span>next <span class="token operator">=</span> <span class="token keyword">new</span> node<span class="token punctuation">;</span>
                Tail <span class="token operator">=</span> Tail<span class="token operator">-</span><span class="token operator">&gt;</span>next<span class="token punctuation">;</span>
                Tail<span class="token operator">-</span><span class="token operator">&gt;</span>instruct <span class="token operator">=</span> cur_instruct<span class="token punctuation">;</span>
                Tail<span class="token operator">-</span><span class="token operator">&gt;</span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>        
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token number">1.0</span> <span class="token operator">-</span> <span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span>failure_times <span class="token operator">/</span> instruct_num<span class="token punctuation">;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token function">srand</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">make_instruct</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"指令序列为："</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>i<span class="token operator">++</span> <span class="token operator">&lt;</span> instruct_num<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        cout <span class="token operator">&lt;&lt;</span> instruct_arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"\t"</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">%</span> <span class="token number">20</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>cout <span class="token operator">&lt;&lt;</span> endl <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"SIZE\t\t"</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"FIFO\t\t"</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"LRU\t\t"</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"Optimal"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> disk_block_size <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span> disk_block_size <span class="token operator">&lt;=</span> <span class="token number">32</span><span class="token punctuation">;</span> disk_block_size<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>

        cout <span class="token operator">&lt;&lt;</span> disk_block_size <span class="token operator">&lt;&lt;</span> <span class="token string">"\t"</span><span class="token punctuation">;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token function">setw</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token function">C_FIFO</span><span class="token punctuation">(</span>disk_block_size<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"\t"</span><span class="token punctuation">;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token function">setw</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token function">C_LRU</span><span class="token punctuation">(</span>disk_block_size<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"\t"</span><span class="token punctuation">;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token function">setw</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token function">C_Optimal</span><span class="token punctuation">(</span>disk_block_size<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"\t"</span><span class="token punctuation">;</span>
        cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="_271"></a>运行结果</h3> 
<p><img src="https://images2.imgbox.com/58/c6/RxjogH2o_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/40/ad/o0UQAEB0_o.png" alt="在这里插入图片描述"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b50173652412259b54c82baf814b365a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">磁盘调度算法（先来先服务、最短寻道优先以及电梯调度算法）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/97013786f6cace150b0e99dd03dab3cd/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">操作系统复习笔记</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>