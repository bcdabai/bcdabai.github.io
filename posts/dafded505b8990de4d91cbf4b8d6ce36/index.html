<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>选择排序和堆排序 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="选择排序和堆排序" />
<meta property="og:description" content="目录
1.基本思想：
2.直接选择排序:
3.堆排序
1.基本思想： 每一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完 。 2.直接选择排序: 在元素集合array[i]--array[n-1] 中选择关键码最大 ( 小 ) 的数据元素 若它不是这组元素中的最后一个( 第一个 ) 元素，则将它与这组元素中的最后一个（第一个）元素交换 在剩余的array[i]--array[n-2]（ array[i&#43;1]--array[n-1] ）集合中，重复上述步骤，直到集合剩余 1 个元素 直接选择排序的特性总结： 1. 直接选择排序思考非常好理解，但是效率不是很好。实际中很少使用 2. 时间复杂度： O(N^2) 3. 空间复杂度： O(1) 4. 稳定性：不稳定 注意： 以下讲解全是建立在升序基础上。 直接选择排序的 核心思想是遍历数组将最小和最大的值分别储存到mini和maxi中，再将mini与begin交换，maxi与end交换，这只是单趟分析。 单趟代码： int mini = begin, maxi = begin; for (int i = begin &#43; 1; i &lt;= end; &#43;&#43;i) { if (a[i] &lt; a[mini]) { mini = i; } if (a[i] &gt; a[maxi]) { maxi = i; } } Swap(&amp;a[begin], &amp;a[mini]); Swap(&amp;a[end], &amp;a[maxi]); 接着就是一步一步缩小需要便利的数组长度，知道begin不在小于end，排序就完成了。 int begin = 0, end = n - 1; while (begin &lt; end) { int mini = begin, maxi = begin; for (int i = begin &#43; 1; i &lt;= end; &#43;&#43;i) { if (a[i] &lt; a[mini]) { mini = i; } if (a[i] &gt; a[maxi]) { maxi = i; } } Swap(&amp;a[begin], &amp;a[mini]); Swap(&amp;a[end], &amp;a[maxi]); &#43;&#43;begin; --end; } 注意： 在直接插入排序中有一个 大坑，就是当Swap完了begin和mini处的数据后， 若maxi数据位于begin处，则会导致下一步Swap end与maxi时，将begin处的最小数据放入到end中了，造成了不可逆的影响（因为end会减减），使得最小数据放到最后出永不能改变。 所以，我们 需要在Swapbegin和mini后做出判断： Swap(&amp;a[begin], &amp;a[mini]); if (maxi == begin) { maxi = mini; } Swap(&amp;a[end], &amp;a[maxi]); 这样就能避免上述大坑。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/dafded505b8990de4d91cbf4b8d6ce36/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-07T21:56:26+08:00" />
<meta property="article:modified_time" content="2023-12-07T21:56:26+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">选择排序和堆排序</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="-toc" style="margin-left:80px;"></p> 
<p id="1.%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3%EF%BC%9A-toc" style="margin-left:80px;"><a href="#1.%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3%EF%BC%9A" rel="nofollow">1.基本思想：</a></p> 
<p id="2.%E7%9B%B4%E6%8E%A5%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%3A-toc" style="margin-left:80px;"><a href="#2.%E7%9B%B4%E6%8E%A5%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%3A" rel="nofollow">2.直接选择排序:</a></p> 
<p id="3.%E5%A0%86%E6%8E%92%E5%BA%8F-toc" style="margin-left:80px;"><a href="#3.%E5%A0%86%E6%8E%92%E5%BA%8F" rel="nofollow">3.堆排序</a></p> 
<p></p> 
<h4 id="1.%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3%EF%BC%9A"><span style="color:#777777;"><strong>1.</strong></span><span style="color:#777777;"><strong>基本思想：</strong></span></h4> 
<div> 
 <span style="color:#777777;">每一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完 。 </span> 
</div> 
<div></div> 
<h4 id="2.%E7%9B%B4%E6%8E%A5%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%3A"><span style="color:#777777;"><strong>2.</strong></span><span style="color:#777777;"><strong>直接选择排序</strong></span><span style="color:#777777;"><strong>: </strong></span></h4> 
<div> 
 <span style="color:#777777;">        在元素集合array[i]--array[n-1]</span> 
 <span style="color:#777777;">中选择关键码最大</span> 
 <span style="color:#777777;">(</span> 
 <span style="color:#777777;">小</span> 
 <span style="color:#777777;">)</span> 
 <span style="color:#777777;">的数据元素 </span> 
</div> 
<div></div> 
<div> 
 <span style="color:#777777;">        若它不是这组元素中的最后一个(</span> 
 <span style="color:#777777;">第一个</span> 
 <span style="color:#777777;">)</span> 
 <span style="color:#777777;">元素，则将它与这组元素中的最后一个（第一个）元素交换</span> 
</div> 
<div></div> 
<div> 
 <span style="color:#777777;">        在剩余的array[i]--array[n-2]（</span> 
 <span style="color:#777777;">array[i+1]--array[n-1]</span> 
 <span style="color:#777777;">）集合中，重复上述步骤，直到集合剩余</span> 
 <span style="color:#777777;">1</span> 
 <span style="color:#777777;">个元素 </span> 
</div> 
<div></div> 
<div> 
 <div> 
  <span style="color:#777777;"><strong>直接选择排序的特性总结： </strong></span> 
 </div> 
 <div></div> 
 <blockquote> 
  <div> 
   <span style="color:#777777;">        1. 直接选择排序思考非常好理解，但是效率不是很好。实际中很少使用 </span> 
  </div> 
  <div> 
   <span style="color:#777777;">        2. 时间复杂度：</span> 
   <span style="color:#777777;">O(N^2) </span> 
  </div> 
  <div> 
   <span style="color:#777777;">        3. 空间复杂度：</span> 
   <span style="color:#777777;">O(1) </span> 
  </div> 
  <div> 
   <span style="color:#777777;">        4. 稳定性：不稳定 </span> 
  </div> 
 </blockquote> 
 <blockquote> 
  <div> 
   <span style="color:#777777;">注意：</span> 
  </div> 
  <div></div> 
  <div>
    以下讲解全是建立在升序基础上。 
  </div> 
 </blockquote> 
 <div></div> 
 <div>
   直接选择排序的 
  <span style="color:#0d0016;"><strong>核心思想</strong></span>是遍历数组将最小和最大的值分别储存到mini和maxi中，再将mini与begin交换，maxi与end交换，这只是单趟分析。 
 </div> 
 <div></div> 
 <div>
   单趟代码： 
 </div> 
 <div></div> 
 <div> 
  <pre><code class="language-cpp">        int mini = begin, maxi = begin;
		for (int i = begin + 1; i &lt;= end; ++i)
		{
			if (a[i] &lt; a[mini])
			{
				mini = i;
			}

			if (a[i] &gt; a[maxi])
			{
				maxi = i;
			}
		}

		Swap(&amp;a[begin], &amp;a[mini]);

		Swap(&amp;a[end], &amp;a[maxi]);</code></pre> 
 </div> 
 <div></div> 
 <div>
   接着就是一步一步缩小需要便利的数组长度，知道begin不在小于end，排序就完成了。 
 </div> 
 <div></div> 
 <div> 
  <pre><code class="language-cpp">    int begin = 0, end = n - 1;

	while (begin &lt; end)
	{
		int mini = begin, maxi = begin;
		for (int i = begin + 1; i &lt;= end; ++i)
		{
			if (a[i] &lt; a[mini])
			{
				mini = i;
			}

			if (a[i] &gt; a[maxi])
			{
				maxi = i;
			}
		}

		Swap(&amp;a[begin], &amp;a[mini]);

		Swap(&amp;a[end], &amp;a[maxi]);

		++begin;
		--end;
	}</code></pre> 
 </div> 
 <div> 
  <span style="color:#0d0016;"><strong>注意</strong></span>： 
 </div> 
 <div></div> 
 <div>
   在直接插入排序中有一个 
  <span style="color:#0d0016;"><strong>大坑</strong></span>，就是当Swap完了begin和mini处的数据后， 
  <span style="color:#0d0016;"><strong>若maxi数据位于begin处，则会导致下一步Swap  end与maxi时，将begin处的最小数据放入到end中了</strong></span>，造成了不可逆的影响（因为end会减减），使得最小数据放到最后出永不能改变。 
 </div> 
 <div></div> 
 <div>
   所以，我们 需要在Swapbegin和mini后做出判断： 
  <br>   
 </div> 
 <div> 
  <pre><code class="language-cpp">	    Swap(&amp;a[begin], &amp;a[mini]);
		if (maxi == begin)
		{
			maxi = mini;
		}

		Swap(&amp;a[end], &amp;a[maxi]);</code></pre> 
  <p>这样就能避免上述大坑。</p> 
  <p>完整直接插入排序：<br>  </p> 
  <pre><code class="language-cpp">void SelectSort(int* a, int n)
{
	int begin = 0, end = n - 1;

	while (begin &lt; end)
	{
		int mini = begin, maxi = begin;
		for (int i = begin + 1; i &lt;= end; ++i)
		{
			if (a[i] &lt; a[mini])
			{
				mini = i;
			}

			if (a[i] &gt; a[maxi])
			{
				maxi = i;
			}
		}

		Swap(&amp;a[begin], &amp;a[mini]);
		if (maxi == begin)
		{
			maxi = mini;
		}

		Swap(&amp;a[end], &amp;a[maxi]);

		++begin;
		--end;
	}
}</code></pre> 
  <h4 id="3.%E5%A0%86%E6%8E%92%E5%BA%8F">3.堆排序</h4> 
  <blockquote> 
   <p>堆排序的<span style="color:#0d0016;"><strong>核心思想</strong></span>就在于建堆时的讲究：</p> 
   <p></p> 
   <p>        升序建大堆；</p> 
   <p>        降序排小堆。</p> 
  </blockquote> 
  <p>因为我们要利用交换思想方便讲最大的数据一个个的调整到最后位置（建完之后的堆不是有序的），<span style="color:#0d0016;"><strong>每次Swap最大的值和end位置的值之后，通过向下调整，就可以将次大的值调整到根部</strong></span>，接着就进入了Swap和向下调整的循环。</p> 
  <p>完整堆排序：</p> 
  <pre><code class="language-cpp">// 升序
void HeapSort(int* a, int n)
{
	// O(N)
	// 建大堆
	for (int i = (n - 1 - 1) / 2; i &gt;= 0; --i)
	{
		AdjustDown(a, n, i);
	}

	// O(N*logN)
	int end = n - 1;
	while (end &gt; 0)
	{
		Swap(&amp;a[0], &amp;a[end]);
		AdjustDown(a, end, 0);
		--end;
	}
}</code></pre> 
  <p>AdjustDown：</p> 
  <pre><code class="language-cpp">void AdjustDown(int* a, int size, int parent)
{
	int child = parent * 2 + 1;

	while (child &lt; size)
	{
		// 假设左孩子小，如果解设错了，更新一下
		if (child + 1 &lt; size &amp;&amp; a[child + 1] &gt; a[child])
		{
			++child;
		}

		if (a[child] &gt; a[parent])
		{
			Swap(&amp;a[child], &amp;a[parent]);
			parent = child;
			child = parent * 2 + 1;
		}
		else
		{
			break;
		}
	}
}</code></pre> 
  <p>详细堆排序见：</p> 
  <p><a class="link-info" href="http://t.csdnimg.cn/7bz1s" rel="nofollow" title="链接">链接</a></p> 
 </div> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6aae05d9157411c2c5bd1dfd41698550/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">C&#43;&#43; 路漫漫其修远兮</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a6d5f95cf1723cfcfb075597e4c697ee/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">头歌：电商精准营销—数据预处理概述</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>