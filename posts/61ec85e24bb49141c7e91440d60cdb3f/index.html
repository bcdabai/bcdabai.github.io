<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Spring Boot全局异常处理，包括404等异常 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Spring Boot全局异常处理，包括404等异常" />
<meta property="og:description" content="目录
全局异常处理实现方式
1.ErrorController方式
1.1.实现ErrorController接口
1.2.继承BasicErrorController类
2.@ControllerAdvice加上@ExceptionHandler方式
2.1.简单实现：
2.2.继承ResponseEntityExceptionHandler
2.3.实现ResponseBodyAdvice接口
3.HandlerExceptionResolver
3.1.ExceptionHandlerExceptionResolver
3.2.DefaultHandlerExceptionResolver
3.3.ResponseStatusExceptionResolver
3.4.自定义异常解析器
4.ResponseStatusException
注意：
附录：
Spring、Spring MVC、Spring Boot的全局异常处理/统一异常处理方式有很多种。
Spring Boot默认展示的是Whitelabel Error Page页面
全局异常处理实现方式 1.ErrorController方式 这种方式可以处理所有的异常信息，包括第2种方式捕获不到的400、401等等，可以拦截跳转到/error的异常，见另一篇博文Spring Boot项目跳转到/error接口_lzhfdxhxm的博客-CSDN博客
1.1.实现ErrorController接口 1.2.继承BasicErrorController类 @Controller public class MyErrorController extends BasicErrorController { private static Log log = LogFactory.getLog(MyErrorController.class); public MyErrorController(ServerProperties serverProperties) { super(new DefaultErrorAttributes(), serverProperties.getError()); } /** * 覆盖默认的Json响应 */ @Override public ResponseEntity&lt;Map&lt;String, Object&gt;&gt; error(HttpServletRequest request) { // 获取原始的错误信息 Map&lt;String, Object&gt; body = getErrorAttributes(request, isIncludeStackTrace(request, MediaType." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/61ec85e24bb49141c7e91440d60cdb3f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-09-01T15:30:49+08:00" />
<meta property="article:modified_time" content="2021-09-01T15:30:49+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Spring Boot全局异常处理，包括404等异常</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F-toc" style="margin-left:0px;"><a href="#%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F" rel="nofollow" title="全局异常处理实现方式">全局异常处理实现方式</a></p> 
<p id="1.ErrorController%E6%96%B9%E5%BC%8F-toc" style="margin-left:40px;"><a href="#1.ErrorController%E6%96%B9%E5%BC%8F" rel="nofollow" title="1.ErrorController方式">1.ErrorController方式</a></p> 
<p id="1.1.%E5%AE%9E%E7%8E%B0ErrorController%E6%8E%A5%E5%8F%A3-toc" style="margin-left:80px;"><a href="#1.1.%E5%AE%9E%E7%8E%B0ErrorController%E6%8E%A5%E5%8F%A3" rel="nofollow" title="1.1.实现ErrorController接口">1.1.实现ErrorController接口</a></p> 
<p id="1.2.%E7%BB%A7%E6%89%BFBasicErrorController%E7%B1%BB-toc" style="margin-left:80px;"><a href="#1.2.%E7%BB%A7%E6%89%BFBasicErrorController%E7%B1%BB" rel="nofollow" title="1.2.继承BasicErrorController类">1.2.继承BasicErrorController类</a></p> 
<p id="1.%40ControllerAdvice%E5%8A%A0%E4%B8%8A%40ExceptionHandler%E6%96%B9%E5%BC%8F-toc" style="margin-left:40px;"><a href="#1.%40ControllerAdvice%E5%8A%A0%E4%B8%8A%40ExceptionHandler%E6%96%B9%E5%BC%8F" rel="nofollow" title="2.@ControllerAdvice加上@ExceptionHandler方式">2.@ControllerAdvice加上@ExceptionHandler方式</a></p> 
<p id="1.%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0%EF%BC%9A-toc" style="margin-left:80px;"><a href="#1.%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0%EF%BC%9A" rel="nofollow" title="2.1.简单实现：">2.1.简单实现：</a></p> 
<p id="2.%E7%BB%A7%E6%89%BFResponseEntityExceptionHandler-toc" style="margin-left:80px;"><a href="#2.%E7%BB%A7%E6%89%BFResponseEntityExceptionHandler" rel="nofollow" title="2.2.继承ResponseEntityExceptionHandler">2.2.继承ResponseEntityExceptionHandler</a></p> 
<p id="3.%E5%AE%9E%E7%8E%B0ResponseBodyAdvice%E6%8E%A5%E5%8F%A3-toc" style="margin-left:80px;"><a href="#3.%E5%AE%9E%E7%8E%B0ResponseBodyAdvice%E6%8E%A5%E5%8F%A3" rel="nofollow" title="2.3.实现ResponseBodyAdvice接口">2.3.实现ResponseBodyAdvice接口</a></p> 
<p id="3.HandlerExceptionResolver-toc" style="margin-left:40px;"><a href="#3.HandlerExceptionResolver" rel="nofollow" title="3.HandlerExceptionResolver">3.HandlerExceptionResolver</a></p> 
<p id="3.1.ExceptionHandlerExceptionResolver-toc" style="margin-left:80px;"><a href="#3.1.ExceptionHandlerExceptionResolver" rel="nofollow" title="3.1.ExceptionHandlerExceptionResolver">3.1.ExceptionHandlerExceptionResolver</a></p> 
<p id="3.2.DefaultHandlerExceptionResolver-toc" style="margin-left:80px;"><a href="#3.2.DefaultHandlerExceptionResolver" rel="nofollow" title="3.2.DefaultHandlerExceptionResolver">3.2.DefaultHandlerExceptionResolver</a></p> 
<p id="3.3.ResponseStatusExceptionResolver-toc" style="margin-left:80px;"><a href="#3.3.ResponseStatusExceptionResolver" rel="nofollow" title="3.3.ResponseStatusExceptionResolver">3.3.ResponseStatusExceptionResolver</a></p> 
<p id="3.4.%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8%E8%A7%A3%E6%9E%90%E5%99%A8-toc" style="margin-left:80px;"><a href="#3.4.%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8%E8%A7%A3%E6%9E%90%E5%99%A8" rel="nofollow" title="3.4.自定义异常解析器">3.4.自定义异常解析器</a></p> 
<p id="4.ResponseStatusException-toc" style="margin-left:40px;"><a href="#4.ResponseStatusException" rel="nofollow" title="4.ResponseStatusException">4.ResponseStatusException</a></p> 
<p id="%E6%B3%A8%E6%84%8F%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%E6%B3%A8%E6%84%8F%EF%BC%9A" rel="nofollow" title="注意：">注意：</a></p> 
<p id="%E9%99%84%E5%BD%95%EF%BC%9A-toc" style="margin-left:0px;"><a href="#%E9%99%84%E5%BD%95%EF%BC%9A" rel="nofollow" title="附录：">附录：</a></p> 
<hr id="hr-toc"> 
<p>Spring、Spring MVC、Spring Boot的全局异常处理/统一异常处理方式有很多种。</p> 
<p>Spring Boot默认展示的是Whitelabel Error Page页面</p> 
<h2 id="%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F">全局异常处理实现方式</h2> 
<h3 id="1.ErrorController%E6%96%B9%E5%BC%8F">1.ErrorController方式</h3> 
<p>这种方式可以处理所有的异常信息，包括第2种方式捕获不到的400、401等等，可以拦截跳转到/error的异常，见另一篇博文<a href="https://blog.csdn.net/lzhfdxhxm/article/details/120019136" title="Spring Boot项目跳转到/error接口_lzhfdxhxm的博客-CSDN博客">Spring Boot项目跳转到/error接口_lzhfdxhxm的博客-CSDN博客</a></p> 
<h4 id="1.1.%E5%AE%9E%E7%8E%B0ErrorController%E6%8E%A5%E5%8F%A3">1.1.实现ErrorController接口</h4> 
<h4 id="1.2.%E7%BB%A7%E6%89%BFBasicErrorController%E7%B1%BB">1.2.继承BasicErrorController类</h4> 
<pre><code class="language-java">@Controller
public class MyErrorController extends BasicErrorController {
 
    private static Log log = LogFactory.getLog(MyErrorController.class);
 
    public MyErrorController(ServerProperties serverProperties) {
        super(new DefaultErrorAttributes(), serverProperties.getError());
    }
 
    /**
     * 覆盖默认的Json响应
     */
    @Override
    public ResponseEntity&lt;Map&lt;String, Object&gt;&gt; error(HttpServletRequest request) {
		// 获取原始的错误信息
        Map&lt;String, Object&gt; body = getErrorAttributes(request, isIncludeStackTrace(request, MediaType.ALL));
        HttpStatus status = getStatus(request);
 
        
        Map&lt;String, Object&gt; result = new HashMap&lt;&gt;();
        String code = null;
        String message = null;
        Object data = null;
        
		// 设置自定义的错误信息，或者从ThreadLocal等获取错误信息
		
        result.put("code", code);
        result.put("message", message);
        result.put("data", data);
        cleanAllCache();
        return new ResponseEntity&lt;Map&lt;String, Object&gt;&gt;(result, status);
    }
 
 
}</code></pre> 
<h3><img alt="" height="828" src="https://images2.imgbox.com/2b/e8/eYll6x24_o.png" width="1187"></h3> 
<p> </p> 
<h3 id="1.%40ControllerAdvice%E5%8A%A0%E4%B8%8A%40ExceptionHandler%E6%96%B9%E5%BC%8F">2.@ControllerAdvice加上@ExceptionHandler方式</h3> 
<p>        可以处理的<strong>异常范围</strong>：进入controller之后的异常。在进入controller之前，比如执行filter过滤器时，是无法处理的，典型情况就是4xx异常，所以需要和其它全局异常来<strong>共同处理</strong>，比如第1种ErrorController。如果使用的是继承ResponseEntityExceptionHandler方式，那么ErrorController的处理结果也可能被beforeBodyWrite()拦截。</p> 
<h4 id="1.%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0%EF%BC%9A">2.1.简单实现：</h4> 
<pre><code class="language-java">@ControllerAdvice
public class ResponseResultAdvice{

	private static Log log =LogFactory.getLog(ResponseResultAdvice.class);
	
	@ResponseBody
	@ExceptionHandler({ Exception.class })
	public ResponseResult&lt;?&gt; handleException(Exception e) {
		ResponseResult&lt;?&gt; responseResult = new ResponseResult&lt;&gt;();
		
		// 设置返回提示、打印日志、清除缓存、执行拦截器里配置的异常等等
		log.error("catch exception,", e);
			
		
		return ResponseResult;
	}	
}
</code></pre> 
<pre><code class="language-java">public class ResponseResult&lt;T&gt; implements Serializable {
    private static final long serialVersionUID = -4594298719566683755L;
    /**
	 * 状态码
	 */
	protected String code;
	
	/**
	 * 返回信息
	 */
	protected String message;
    
	/**
	 * 返回报文体
	 */
	private T data;

	/**
	 * 分页对象。有页对象不为null
	 */
	private Page page;
// 省略

}</code></pre> 
<h4 id="2.%E7%BB%A7%E6%89%BFResponseEntityExceptionHandler">2.2.继承ResponseEntityExceptionHandler</h4> 
<p>可以像官方这样：</p> 
<pre><code class="language-java">@ControllerAdvice(basePackageClasses = SomeController.class)
public class MyControllerAdvice extends ResponseEntityExceptionHandler {

    @ResponseBody
    @ExceptionHandler(MyException.class)
    public ResponseEntity&lt;?&gt; handleControllerException(HttpServletRequest request, Throwable ex) {
        HttpStatus status = getStatus(request);
        return new ResponseEntity&lt;&gt;(new MyErrorBody(status.value(), ex.getMessage()), status);
    }

    private HttpStatus getStatus(HttpServletRequest request) {
        Integer code = (Integer) request.getAttribute(RequestDispatcher.ERROR_STATUS_CODE);
        HttpStatus status = HttpStatus.resolve(code);
        return (status != null) ? status : HttpStatus.INTERNAL_SERVER_ERROR;
    }

}</code></pre> 
<h4 id="3.%E5%AE%9E%E7%8E%B0ResponseBodyAdvice%E6%8E%A5%E5%8F%A3">2.3.实现ResponseBodyAdvice接口</h4> 
<blockquote> 
 <p>通过beforeBodyWrite()来对返回结果进行一些统一处理，</p> 
 <p>通过@ControllerAdvice加上@ExceptionHandler来对异常进行统一处理</p> 
 <p>注意：如果有捕获到异常，那么会<strong>先</strong>执行<strong>handleException</strong>()，<strong>后</strong>执行<strong>beforeBodyWrite</strong>()</p> 
</blockquote> 
<pre>ResponseBodyAdvice源码：
</pre> 
<pre><code class="language-java">
/**
 * Allows customizing the response after the execution of an {@code @ResponseBody}
 * or a {@code ResponseEntity} controller method but before the body is written
 * with an {@code HttpMessageConverter}.
 *
 * &lt;p&gt;Implementations may be registered directly with
 * {@code RequestMappingHandlerAdapter} and {@code ExceptionHandlerExceptionResolver}
 * or more likely annotated with {@code @ControllerAdvice} in which case they
 * will be auto-detected by both.
 *
 * @author Rossen Stoyanchev
 * @since 4.1
 */
public interface ResponseBodyAdvice&lt;T&gt; {

}</code></pre> 
<pre><code class="language-java">
@ControllerAdvice
public class WebResponseBodyAdvice implements ResponseBodyAdvice&lt;Object&gt; {

    private static Log log = LogFactory.getLog(WebResponseBodyAdvice.class);
	
    /**
     * 对指定情况进行返回数据处理beforeBodyWrite
     */
    @Override
    public boolean supports(MethodParameter returnType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; converterType) {
        return true;
    }

    /**
     * 包装controller return数据类型为ResponseDTO对象以及返回token
     */
    @Override
    public Object beforeBodyWrite(Object body, MethodParameter returnType,
                                  MediaType selectedContentType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; selectedConverterType,
                                  ServerHttpRequest request, ServerHttpResponse response) {
        if (log.isDebugEnabled()) {
            log.debug("进入response拦截器，" + "body：" + body + "，MethodParameter：" + returnType + "，MediaType：" + selectedContentType + "，HttpMessageConverter：" + selectedConverterType);
        }

        if (!(body instanceof ResponseResult)) {
            return body;
        }
		
		// 对body进行处理，比如token刷新、返回code、message、data设置等等
        
		JSONObject jsonStr = (JSONObject) JSONObject.toJSON(body);
		if(log.isDebugEnabled()) {
			log.debug(body.getClass()+"转换结果："+jsonStr.toJSONString());
		}
        return jsonStr;
    }

    @ResponseBody
	@ExceptionHandler({ Exception.class })
	public ResponseResult&lt;?&gt; handleException(Exception e) {
		ResponseResult&lt;?&gt; responseResult = new ResponseResult&lt;&gt;();
		
		// 设置返回提示、打印日志、清除缓存、执行拦截器里配置的异常等等
		log.error("catch exception,", e);
			
		
		return ResponseResult;
	}
}
</code></pre> 
<p>注意：在使用ResponseBodyAdvice里的beforeBodyWrite的来包装返回数据的时候，要特别注意<strong>返回类型转换</strong>的问题。参考附录里的2</p> 
<pre><code>java.lang.ClassCastException: org.phan.message.Response cannot be cast to java.lang.String
</code></pre> 
<pre><code class="language-java">@Configuration
public class CustomerWebMvcConfig implements WebMvcConfigurer {
 
	@Override
	public void configureMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) {
		// TODO Auto-generated method stub
		// WebMvcConfigurer.super.configureMessageConverters(converters);
		converters.add(gsonJsonHttpMessageConverter());// Gson和FastJson取其一，我这取Gson
		// converters.add(fastJsonHttpMessageConverter());
	}
	
	@Bean
	public GsonHttpMessageConverter gsonJsonHttpMessageConverter() {
		// 使用Gson
		return new GsonHttpMessageConverter();// Gson转换json的Converter
	}
 
	@Bean
	public FastJsonHttpMessageConverter fastJsonHttpMessageConverter() {
		// 使用fastJson
		return new FastJsonHttpMessageConverter();// FastJson转换json的Converter
	}
 
}</code></pre> 
<h3 id="3.HandlerExceptionResolver">3.HandlerExceptionResolver</h3> 
<p>主要作用是更改返回的ModelAndView指向的页面，如果想改变返回数据的值，那么可以通过自定义的HandlerExceptionResolver修改response里的数据。</p> 
<p>整体上来说，这个主要是给MVC模式使用的，不是非常适合现在的REST模式。</p> 
<pre><code class="language-java">public interface HandlerExceptionResolver {

	/**
	 * Try to resolve the given exception that got thrown during handler execution,
	 * returning a {@link ModelAndView} that represents a specific error page if appropriate.
	 * &lt;p&gt;The returned {@code ModelAndView} may be {@linkplain ModelAndView#isEmpty() empty}
	 * to indicate that the exception has been resolved successfully but that no view
	 * should be rendered, for instance by setting a status code.
	 * @param request current HTTP request
	 * @param response current HTTP response
	 * @param handler the executed handler, or {@code null} if none chosen at the
	 * time of the exception (for example, if multipart resolution failed)
	 * @param ex the exception that got thrown during handler execution
	 * @return a corresponding {@code ModelAndView} to forward to,
	 * or {@code null} for default processing in the resolution chain
	 */
	@Nullable
	ModelAndView resolveException(
			HttpServletRequest request, HttpServletResponse response, @Nullable Object handler, Exception ex);

}</code></pre> 
<p>以下是几个默认的和自定义的异常解析器</p> 
<h4 id="3.1.ExceptionHandlerExceptionResolver">3.1.ExceptionHandlerExceptionResolver</h4> 
<p>这个是Spring 3.1引入的，在DispatcherServlet里默认使用的。</p> 
<p>是<strong>@ExceptionHandler</strong>默认使用的异常解析器</p> 
<h4 id="3.2.DefaultHandlerExceptionResolver">3.2.<strong><em>DefaultHandlerExceptionResolver</em></strong></h4> 
<p>这个是Spring 3.0引入的，在DispatcherServlet里默认使用的。</p> 
<p>用于处理HTTP Status Code对应的异常的，比如400,401等4xx、5xx异常</p> 
<h4 id="3.3.ResponseStatusExceptionResolver">3.3.<strong><em>ResponseStatusExceptionResolver</em></strong></h4> 
<pre><code class="language-java">@ResponseStatus(value = HttpStatus.NOT_FOUND)
public class MyResourceNotFoundException extends RuntimeException {
    public MyResourceNotFoundException() {
        super();
    }
    public MyResourceNotFoundException(String message, Throwable cause) {
        super(message, cause);
    }
    public MyResourceNotFoundException(String message) {
        super(message);
    }
    public MyResourceNotFoundException(Throwable cause) {
        super(cause);
    }
}</code></pre> 
<p>是<strong>@ResponseStatus</strong>默认使用的异常解析器。可以参考附录3</p> 
<h4 id="3.4.%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8%E8%A7%A3%E6%9E%90%E5%99%A8">3.4.自定义异常解析器</h4> 
<p>目前大多数的系统，实现Spring REST Service规范，是要求返回JSON或XML格式的数据，而不是页面，这样的话，使用Spring默认的HandlerExceptionResolver就无法实现我们的需求，需要自定义解析器。</p> 
<p>自定义例子1：</p> 
<pre><code class="language-java">@Component
public class RestResponseStatusExceptionResolver extends AbstractHandlerExceptionResolver {

    @Override
    protected ModelAndView doResolveException(
      HttpServletRequest request, 
      HttpServletResponse response, 
      Object handler, 
      Exception ex) {
        try {
            if (ex instanceof IllegalArgumentException) {
                return handleIllegalArgument(
                  (IllegalArgumentException) ex, response, handler);
            }
            ...
        } catch (Exception handlerException) {
            logger.warn("Handling of [" + ex.getClass().getName() + "] 
              resulted in Exception", handlerException);
        }
        return null;
    }

    private ModelAndView 
      handleIllegalArgument(IllegalArgumentException ex, HttpServletResponse response) 
      throws IOException {
        response.sendError(HttpServletResponse.SC_CONFLICT);
        String accept = request.getHeader(HttpHeaders.ACCEPT);
        ...
        return new ModelAndView();
    }
}</code></pre> 
<p>自定义例子2</p> 
<pre><code class="language-java">/**
 * 
 * 类名称 : SgccExceptionResolver. &lt;br&gt;
 * 功能描述 : 全局异常拦截器，可在此做异常信息的判断及输出. &lt;br&gt;
 */
public class SgccExceptionResolver implements HandlerExceptionResolver {
​
    private Logger logger = Logger.getLogger(this.getClass());
​
    public ModelAndView resolveException(HttpServletRequest request, HttpServletResponse response, Object handler,
            Exception ex) {
        logger.info("==============Exception Start 000000=============");
        if (ex instanceof BaseException) {
            logger.debug(ex, ex);
        }else {
            logger.error(ex, ex);
        }
        logger.info("==============Exception End 000000=============");
        if (NetworkUtil.isAjax(request)) {
            String msg = null;
            String code = null;
            String detail = null;
            if (ex instanceof BaseException) {
                msg = ((BaseException) ex).getErrorMsg();
                code = ((BaseException) ex).getErrorCode();
                detail = ((BaseException) ex).getMsgDetail();
            }else {
                FSTErrorCode fc = FSTErrorCode.SYS_ERROR_000000;
                msg = fc.getErrorMsg();
                code = fc.getErrorCode();
                detail = fc.getMsgDetail();
            }
            try {
                Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();
                map.put("msg", msg);
                map.put("code", code);
                map.put("detail", detail);
                JSONObject json = JSONObject.fromObject(map);
                response.setContentType("text/html;charset=utf-8");
                response.getWriter().print(json);
            }catch (IOException e) {
                e.printStackTrace();
            }
            return null;
        }else {
            ModelAndView mv = new ModelAndView();
            mv.setViewName("error/error");
            mv.addObject("exception", ex.toString().replaceAll("\n", "&lt;br/&gt;"));
            return mv;
        }
    }    
    
}</code></pre> 
<h3 id="4.ResponseStatusException">4.<strong><em>ResponseStatusException</em></strong></h3> 
<p>可以抛出<strong><em>ResponseStatusException</em></strong>异常，和<strong>@ResponseStatus</strong>一起使用</p> 
<pre><code class="language-java">@GetMapping(value = "/{id}")
public Foo findById(@PathVariable("id") Long id, HttpServletResponse response) {
    try {
        Foo resourceById = RestPreconditions.checkFound(service.findOne(id));

        eventPublisher.publishEvent(new SingleResourceRetrievedEvent(this, response));
        return resourceById;
     }
    catch (MyResourceNotFoundException exc) {
         throw new ResponseStatusException(
           HttpStatus.NOT_FOUND, "Foo Not Found", exc);
    }
}</code></pre> 
<p></p> 
<h3 id="%E6%B3%A8%E6%84%8F%EF%BC%9A">注意：</h3> 
<p>        在使用全局异常处理的时候，如果多种方式一起使用，那么要注意是否重复处理了，以及处理的顺序、范围。</p> 
<p>        ErrorController方式和@ControllerAdvice加上@ExceptionHandler方式一起使用的话，@ExceptionHandler处理不到的异常，由ErrorController处理</p> 
<p></p> 
<h2 id="%E9%99%84%E5%BD%95%EF%BC%9A">附录：</h2> 
<p>        1.Spring Boot 官方文档异常处理章节：<a href="https://docs.spring.io/spring-boot/docs/2.5.4/reference/htmlsingle/#features.developing-web-applications.spring-mvc.error-handling" rel="nofollow" title="Spring Boot Reference Documentation">Spring Boot Reference Documentation</a></p> 
<p>        2.ResponseBodyAdvice里Response转换异常问题 </p> 
<p><a href="https://blog.csdn.net/educast/article/details/82863570" title="使用 ResponseBodyAdvice 拦截Controller方法默认返回参数，统一处理返回值/响应体_记事本-CSDN博客_responsebodyadvice">使用 ResponseBodyAdvice 拦截Controller方法默认返回参数，统一处理返回值/响应体_记事本-CSDN博客_responsebodyadvice</a>  这篇文章里的评论</p> 
<p><a href="https://stackoverflow.com/questions/44121648/controlleradvice-responsebodyadvice-failed-to-enclose-a-string-response" rel="nofollow" title="rest - ControllerAdvice ResponseBodyAdvice failed to enclose a String response - Stack Overflow">rest - ControllerAdvice ResponseBodyAdvice failed to enclose a String response - Stack Overflow</a></p> 
<p>        3.<a href="https://blog.csdn.net/ITWANGBOIT/article/details/103718926" title="@ResponseStatus的作用_ITWANGBOIT的博客-CSDN博客">@ResponseStatus的作用_ITWANGBOIT的博客-CSDN博客</a></p> 
<p>        4.<a href="https://www.baeldung.com/exception-handling-for-rest-with-spring" rel="nofollow" title="Error Handling for REST with Spring | Baeldung">Error Handling for REST with Spring | Baeldung</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6ad423d833235b11ac119477ec3f820d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">21点游戏A计算方法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5937dabd54c971f8da03e628cdeca1b1/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">单片机找工作好找吗？不懂英语怎么学会单片机？</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>