<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【408】计算机学科专业基础 - 数据结构 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【408】计算机学科专业基础 - 数据结构" />
<meta property="og:description" content="数据结构知识 绪论 数据结构在学什么 如何用程序代码把现实世界的问题信息化
如何用计算机高效地处理这些信息从而创造价值
数据结构的基本概念 什么是数据： 数据是信息的载体，是描述客观事物属性的数、字符及所有能输入到计算机中并被计算机程序识别和处理的符号的集合。数据是计算机程序加工的原料。
现代计算机处理的数据： 现代计算机——经常处理非数值型问题
对于非数值型的问题：
我们关心每个个体的具体信息
我们还关心个体之间的关系
数据元素： 数据元素是数据的基本单位，通常作为一个整体进行考虑和处理。
数据项： 一个数据元素可由若干数据项组成，数据项是构成数据元素的不可分割的最小单位。
数据对象： 数据对象是具有相同性质的数据元素的集合，是数据的一个子集
数据结构： 数据结构是相互之间存在一种或多种特定关系的数据元素的集合。
数据结构这门课着重关注的是数据元素之间的关系，和对这些数据元素的操作，而不关心具体的数据项内容。
数据结构的三要素 三要素： 逻辑结构
集合结构，各个元素同属一个集合，别无其他关系
线性结构，一对一，顺序关系
树状结构，一对多
图状结构，多对多
数据的运算，针对某种逻辑结构，结合实际需求，定义基本运算（增删改查）
物理结构（储存结构），如何用计算机实现这种数据结构
顺序存储：把逻辑上相邻的元素存储在物理位置上也相邻的储存单元中，元素之间的关系由储存单元的邻接关系来体现
链式存储：把逻辑上相邻的元素存储在物理位置上可以不相邻，借助指示元素存储地址的指针来表示元素之间的逻辑关系。
索引存储：在储存元素信息的同时，还简历附加的索引表。索引表中的每项成为索引项，索引项的一般形式是（关键字，地址）
散列存储：根据元素的关键字直接计算出该元素的存储地址，又称哈希存储
总结： 若采用顺序存储，则各个数据元素在物理上必须是连续的；若采用非顺序存储则各个数据元素在物理上可以是离散的
数据的数据结构会影响存储空间分配的方便程度
数据的存储结构会影响对数据运算的速度
运算的定义是针对逻辑结构的，指出运算的功能
运算的实现是针对存储结构的，指出运算的具体步骤
数据类型： 数据类型是一个值的集合和定义在此集合上的一组操作的总称
原子类型：其值不可再分的数据类型（bool、int等）
结构类型：其值可以再分解为若干分量的数据类型（struct等）
抽象数据类型（ADT）： 是抽象数据组织及其相关的操作，定义了一个ADT就是在定义一种数据结构
算法的基本概念 什么是算法： 程序=数据结构&#43;算法
算法（Algorithm）是对特定问题求解步骤的一种描述，它是指令的有限序列，其中的每条指令表示一个或多个操作
算法的特征： 算法必须拥有以下特性，否则不能被称为算法：
有穷性：一个算法必须总在执行有穷步之后结束，且每一步都可在有穷时间内完成。
确定性：算法中每条指令必须有确切的含义，对于相同的输入只能得出相同的输出。
可行性：算法中描述的操作都可以通过已经实现的基本运算执行有限次来实现。
输入：一个算法有零个或多个输入，这些输入取自于某个特定的对象的集合。
输出：一个算法有一个或多个输出，这些输出是与输入有着某种特定关系的量。
好算法的特质： 正确性：算法应能够正确地解决求解问题。
可读性：算法应具有良好的可读性，以帮助人们理解。
健壮性：输入非法数据时，算法能适当地做出反应或进行处理，而不会产生莫名其妙的输出结果。
高效率：
花的时间少：时间复杂度低
低存储量需求：费内存，空间复杂度低
算法的时间复杂度 定义： 事前预估算法时间开销T(n)与问题规模n的关系（T表示“time”） 规则： 加法规则：T(n) = T1(n) &#43; T2(n) = O(f(n)) &#43; O(g(n)) = O(max(f(n), g(n))) （多项相加，只保留最高阶的项，且系数变为1）" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/0f07ae903c9c10b6fff2c5f5d04e59ae/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-11-12T22:21:13+08:00" />
<meta property="article:modified_time" content="2023-11-12T22:21:13+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【408】计算机学科专业基础 - 数据结构</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="_0"></a>数据结构知识</h3> 
<h4><a id="_1"></a>绪论</h4> 
<h5><a id="_3"></a>数据结构在学什么</h5> 
<ul><li> <p>如何用程序代码把现实世界的问题信息化</p> </li><li> <p>如何用计算机高效地处理这些信息从而创造价值</p> </li></ul> 
<h5><a id="_9"></a>数据结构的基本概念</h5> 
<h6><a id="_11"></a>什么是数据：</h6> 
<p>数据是信息的载体，是描述客观事物属性的数、字符及所有能输入到计算机中并被计算机程序识别和处理的符号的集合。数据是计算机程序加工的原料。</p> 
<h6><a id="_15"></a>现代计算机处理的数据：</h6> 
<ul><li> <p>现代计算机——经常处理非数值型问题</p> </li><li> <p>对于非数值型的问题：</p> 
  <ul><li> <p>我们关心每个个体的具体信息</p> </li><li> <p>我们还关心个体之间的关系</p> </li></ul> </li></ul> 
<h6><a id="_25"></a>数据元素：</h6> 
<p>数据元素是数据的基本单位，通常作为一个整体进行考虑和处理。</p> 
<h6><a id="_29"></a>数据项：</h6> 
<p>一个数据元素可由若干数据项组成，数据项是构成数据元素的不可分割的最小单位。</p> 
<h6><a id="_33"></a>数据对象：</h6> 
<p>数据对象是具有相同性质的数据元素的集合，是数据的一个子集</p> 
<h6><a id="_37"></a>数据结构：</h6> 
<ul><li> <p>数据结构是相互之间存在一种或多种特定关系的数据元素的集合。</p> </li><li> <p>数据结构这门课着重关注的是数据元素之间的关系，和对这些数据元素的操作，而不关心具体的数据项内容。</p> </li></ul> 
<h5><a id="_43"></a>数据结构的三要素</h5> 
<h6><a id="_45"></a>三要素：</h6> 
<ul><li> <p>逻辑结构</p> 
  <ul><li> <p>集合结构，各个元素同属一个集合，别无其他关系</p> </li><li> <p>线性结构，一对一，顺序关系</p> </li><li> <p>树状结构，一对多</p> </li><li> <p>图状结构，多对多</p> </li></ul> </li><li> <p>数据的运算，针对某种逻辑结构，结合实际需求，定义基本运算（增删改查）</p> </li><li> <p>物理结构（储存结构），如何用计算机实现这种数据结构</p> 
  <ul><li> <p>顺序存储：把逻辑上相邻的元素存储在物理位置上也相邻的储存单元中，元素之间的关系由储存单元的邻接关系来体现</p> </li><li> <p>链式存储：把逻辑上相邻的元素存储在物理位置上可以不相邻，借助指示元素存储地址的指针来表示元素之间的逻辑关系。</p> </li><li> <p>索引存储：在储存元素信息的同时，还简历附加的索引表。索引表中的每项成为索引项，索引项的一般形式是（关键字，地址）</p> </li><li> <p>散列存储：根据元素的关键字直接计算出该元素的存储地址，又称哈希存储</p> </li></ul> </li></ul> 
<h6><a id="_69"></a>总结：</h6> 
<ul><li> <p>若采用顺序存储，则各个数据元素在物理上必须是连续的；若采用非顺序存储则各个数据元素在物理上可以是离散的</p> </li><li> <p>数据的数据结构会影响存储空间分配的方便程度</p> </li><li> <p>数据的存储结构会影响对数据运算的速度</p> </li><li> <p>运算的定义是针对逻辑结构的，指出运算的功能</p> </li><li> <p>运算的实现是针对存储结构的，指出运算的具体步骤</p> </li></ul> 
<h6><a id="_81"></a>数据类型：</h6> 
<p>数据类型是一个值的集合和定义在此集合上的一组操作的总称</p> 
<ul><li> <p>原子类型：其值不可再分的数据类型（bool、int等）</p> </li><li> <p>结构类型：其值可以再分解为若干分量的数据类型（struct等）</p> </li></ul> 
<h6><a id="ADT_89"></a>抽象数据类型（ADT）：</h6> 
<p>是抽象数据组织及其相关的操作，定义了一个ADT就是在定义一种数据结构</p> 
<h5><a id="_93"></a>算法的基本概念</h5> 
<h6><a id="_95"></a>什么是算法：</h6> 
<ul><li> <p>程序=数据结构+算法</p> </li><li> <p>算法（Algorithm）是对特定问题求解步骤的一种描述，它是指令的有限序列，其中的每条指令表示一个或多个操作</p> </li></ul> 
<h6><a id="_101"></a>算法的特征：</h6> 
<ul><li> <p>算法必须拥有以下特性，否则不能被称为算法：</p> </li><li> <p>有穷性：一个算法必须总在执行有穷步之后结束，且每一步都可在有穷时间内完成。</p> </li><li> <p>确定性：算法中每条指令必须有确切的含义，对于相同的输入只能得出相同的输出。</p> </li><li> <p>可行性：算法中描述的操作都可以通过已经实现的基本运算执行有限次来实现。</p> </li><li> <p>输入：一个算法有零个或多个输入，这些输入取自于某个特定的对象的集合。</p> </li><li> <p>输出：一个算法有一个或多个输出，这些输出是与输入有着某种特定关系的量。</p> </li></ul> 
<h6><a id="_115"></a>好算法的特质：</h6> 
<ul><li> <p>正确性：算法应能够正确地解决求解问题。</p> </li><li> <p>可读性：算法应具有良好的可读性，以帮助人们理解。</p> </li><li> <p>健壮性：输入非法数据时，算法能适当地做出反应或进行处理，而不会产生莫名其妙的输出结果。</p> </li><li> <p>高效率：</p> </li><li> <p>花的时间少：时间复杂度低</p> </li><li> <p>低存储量需求：费内存，空间复杂度低</p> </li></ul> 
<h5><a id="_129"></a>算法的时间复杂度</h5> 
<h6><a id="_TnnTtime_131"></a>定义： 事前预估算法时间开销T(n)与问题规模n的关系（T表示“time”）</h6> 
<h6><a id="_133"></a>规则：</h6> 
<ul><li> <p>加法规则：T(n) = T1(n) + T2(n) = O(f(n)) + O(g(n)) = O(max(f(n), g(n))) （多项相加，只保留最高阶的项，且系数变为1）</p> </li><li> <p>乘法规则：T(n) = T1(n)×T2(n) = O(f(n))×O(g(n)) = O(f(n)×g(n))（多项相乘，都保留 ）</p> </li><li> <p>算法好坏：O(1) &lt; O(log2n) &lt; O(n) &lt; O(nlog2n) &lt; O(n^2) &lt; O(n^3) &lt; O(2^n) &lt; O(n!) &lt; O(n^n)（口诀：常对幂指阶）</p> </li><li> <p>数量级仅需考虑循环内，最深层嵌套的部分</p> </li><li> <p>最坏时间复杂度：最坏情况下算法的时间复杂度</p> </li><li> <p>平均时间复杂度：所有输入示例等概率出现的情况下，算法的期望运行时间</p> </li><li> <p>最好时间复杂度：最好情况下算法的时间复杂度</p> </li><li> <p>一般只考虑最坏和平均复杂度</p> </li></ul> 
<h5><a id="_151"></a>算法的空间复杂度</h5> 
<h6><a id="Snn_153"></a>定义：空间开销（内存开销，S(n)）与问题规模n之间的关系</h6> 
<h6><a id="__155"></a>算法原地工作： 算法所需内存空间为常量</h6> 
<h6><a id="_157"></a>规则：</h6> 
<ul><li> <p>只需关注存储空间大小与问题规模相关的变量</p> </li><li> <p>加法规则、乘法规则、算法好坏判定与时间复杂度一样</p> </li><li> <p>递归调用的大多数情况：空间复杂度=递归调用的深度</p> </li></ul> 
<h4><a id="_165"></a>线性表</h4> 
<h5><a id="_167"></a>线性表的定义和基本操作</h5> 
<h6><a id="_169"></a>定义：</h6> 
<ul><li> <p>线性表(Linear List)是具有相同数据类型的n（n≥0）个数据元素的有限序列，其中n为表长，当n = 0时线性表是一个空表</p> </li><li> <p>若用L命名线性表，则其一般表示为L = (a1, a2, … , ai, ai+1, … , an)</p> </li><li> <p>a1是表头元素</p> </li><li> <p>an是表尾元素</p> </li><li> <p>除第一个元素外，每个元素有且仅有一个直接前驱</p> </li><li> <p>除最后一个元素外，每个元素有且仅有一个直接后继</p> </li></ul> 
<h6><a id="_183"></a>基本操作：</h6> 
<ul><li> <p>InitList(&amp;L)：初始化表。构造一个空的线性表L，分配内存空间。</p> </li><li> <p>DestroyList(&amp;L)：销毁操作。销毁线性表，并释放线性表L所占用的内存空间。</p> </li><li> <p>ListInsert(&amp;L,i,e)：插入操作。在表L中的第i个位置上插入指定元素e。</p> </li><li> <p>ListDelete(&amp;L,i,&amp;e)：删除操作。删除表L中第i个位置的元素，并用e返回删除元素的值。</p> </li><li> <p>LocateElem(L,e)：按值查找操作。在表L中查找具有给定关键字值的元素。</p> </li><li> <p>GetElem(L,i)：按位查找操作。获取表L中第i个位置的元素的值。</p> </li><li> <p>Length(L)：求表长。返回线性表L的长度，即L中数据元素的个数。</p> </li><li> <p>PrintList(L)：输出操作。按前后顺序输出线性表L的所有元素值。</p> </li><li> <p>Empty(L)：判空操作。若L为空表，则返回true，否则返回false。</p> </li><li> <p>什么时候要传入参数的引用“&amp;”： 对参数的修改结果需要“带回来”，是引用类型而不是值类型</p> </li></ul> 
<h5><a id="_205"></a>顺序表的定义</h5> 
<h6><a id="_207"></a>定义：</h6> 
<p>用顺序存储的方式实现线性表顺序存储，把逻辑上相邻的元素存储在物理位置上也相邻的存储单元中，元素之间的关系由存储单元的邻接关系来体现。</p> 
<h6><a id="_211"></a>如何知道一个数据元素大小：</h6> 
<p>C语言sizeof(ElemType)</p> 
<h6><a id="_215"></a>顺序表的实现-静态分配：</h6> 
<p><img src="https://images2.imgbox.com/03/75/8DAMxFn4_o.png" alt="img"></p> 
<p><img src="https://images2.imgbox.com/48/6e/Hm93tFbI_o.png" alt="img"></p> 
<h6><a id="_221"></a>如果“数组”存满了怎么办：</h6> 
<p>可以放弃治疗，顺序表的表长刚开始确定后就无法更改（存储空间是静态的），同时如果提前初始化太多的空间而不用，又会造成资源的浪费，因此动态分配应运而生。</p> 
<h6><a id="_225"></a>动态申请和释放内存空间：</h6> 
<ul><li> <p>C：malloc、free函数</p> 
  <ul><li> <p>L.data = (ElemType *) malloc (sizeof(ElemType) * InitSize);</p> </li><li> <p>malloc函数返回一个指针， 空间需要强制转型为你定义的数据元素类型指针</p> </li><li> <p>malloc函数的参数，指明要分配多大的连续内存空间</p> </li></ul> </li><li> <p>C++： new、delete关键字</p> </li></ul> 
<h6><a id="_237"></a>顺序表的实现-动态分配：</h6> 
<p><img src="https://images2.imgbox.com/1d/67/qQ4sXl2U_o.png" alt="img"></p> 
<h6><a id="_241"></a>顺序表的实现：</h6> 
<ul><li> <p>随机访问，即可以在O(1)时间内找到第i个元素。</p> </li><li> <p>存储密度高，每个结点只存储数据元素</p> </li><li> <p>拓展容量不方便（即便采用动态分配的方式实现，拓展长度的时间复杂度也比较高）</p> </li><li> <p>插入、删除操作不方便，需要移动大量元素</p> </li></ul> 
<h5><a id="_251"></a>顺序表的插入、删除</h5> 
<h6><a id="_253"></a>顺序表的基本操作-插入：</h6> 
<p><img src="https://images2.imgbox.com/c6/b1/BGT004HT_o.png" alt="img"></p> 
<p>增加i的合法性判断：</p> 
<p><img src="https://images2.imgbox.com/5d/8e/kUeC3iVO_o.png" alt="img"></p> 
<h6><a id="_261"></a>顺序表的基本操作-删除：</h6> 
<p><img src="https://images2.imgbox.com/34/ca/Om2NXTyr_o.png" alt="img"></p> 
<h6><a id="_265"></a>插入和删除的时间复杂度：</h6> 
<ul><li> <p>最好时间复杂度= O(1)</p> </li><li> <p>最坏时间复杂度= O(n)</p> </li><li> <p>平均时间复杂度= O(n)</p> </li></ul> 
<h5><a id="_273"></a>顺序表的查找</h5> 
<h6><a id="_275"></a>顺序表的按位查找：</h6> 
<p><img src="https://images2.imgbox.com/48/af/nGuT5dYi_o.png" alt="img"></p> 
<ul><li> <p>正是如此，在初始化顺序表时候malloc需要强制转换为与数据元素的数据类型相对应的指针</p> </li><li> <p>时间复杂度= O(1)</p> </li><li> <p>随机存取：由于顺序表的各个数据元素在内存中连续存放，因此可以根据起始地址和数据元素大小立即找到第i个元素，</p> </li></ul> 
<h6><a id="_285"></a>顺序表的按值查找：</h6> 
<p><img src="https://images2.imgbox.com/8c/ba/tkxlvubi_o.png" alt="img"></p> 
<ul><li> <p>结构类型的数据元素也能用 == 比较吗：不能！（C++可以用 == 的重载来实现）</p> </li><li> <p>更好的办法：定义一个函数</p> </li><li> <p>依次对比各个分量来判断两个结构体是否相等</p> </li><li> <p>最好时间复杂度= O(1)</p> </li><li> <p>最坏时间复杂度= O(n)</p> </li><li> <p>平均时间复杂度= O(n)</p> </li></ul> 
<h5><a id="_301"></a>单链表的定义</h5> 
<h6><a id="_303"></a>顺序表：</h6> 
<ul><li> <p>每个结点中只存放数据元素</p> </li><li> <p>优点：可随机存取，存储密度高</p> </li><li> <p>缺点：要求大片连续空间，改变容量不方便</p> </li></ul> 
<h6><a id="_311"></a>单链表：</h6> 
<ul><li> <p>每个结点除了存放数据元素外，还要存储指向下一个结点的指针</p> </li><li> <p>优点：不要求大片连续空间，改变容量方便</p> </li><li> <p>缺点：不可随机存取，要耗费一定空间存放指针</p> </li></ul> 
<h6><a id="_319"></a>定义一个单链表：</h6> 
<ul><li> <p>typedef关键字：数据类型重命名</p> 
  <ul><li> <p>typedef &lt;数据类型&gt; &lt;别名&gt;</p> </li><li> <p>typedef struct LNode LNode;</p> </li><li> <p>之后可以用LNode代替struct LNode</p> </li></ul> </li></ul> 
<p><img src="https://images2.imgbox.com/1e/f4/FqRpQNu6_o.png" alt="img"></p> 
<p><img src="https://images2.imgbox.com/30/99/QhhZ0kJn_o.png" alt="img"></p> 
<h6><a id="_333"></a>不带头结点的单链表：</h6> 
<p><img src="https://images2.imgbox.com/29/ed/YgTlzYcd_o.png" alt="img"></p> 
<h6><a id="_337"></a>带头结点的单链表：</h6> 
<p><img src="https://images2.imgbox.com/ba/7b/4T8NGQdX_o.png" alt="img"></p> 
<h6><a id="_341"></a>区别：</h6> 
<ul><li> <p>不带头结点，写代码更麻烦</p> </li><li> <p>对第一个数据结点和后续数据结点的处理需要用不同的代码逻辑</p> </li><li> <p>对空表和非空表的处理需要用不同的代码逻辑</p> </li><li> <p>我们一般使用的都是带头结点的单链表</p> </li></ul> 
<h5><a id="_351"></a>单链表的插入、删除</h5> 
<h6><a id="_353"></a>按位序插入（带头结点）：</h6> 
<p>ListInsert(&amp;L,i,e)：</p> 
<ul><li> <p>插入操作，在表L中的第i个位置上插入指定元素e</p> </li><li> <p>找到第i-1个结点，将新结点插入其后</p> </li><li> <p>若带有头结点，插入更加方便，头结点可以看作“第0个”结点，直接做上面的操作即可</p> </li></ul> 
<p><img src="https://images2.imgbox.com/3b/34/oGAGWnbh_o.png" alt="img"></p> 
<ul><li> <p>若i插在表中则与插在表头一样进行操作，可以插入成功</p> </li><li> <p>若i插在表尾则s-&gt;next为NULL（在表的定义时规定的），可以插入成功</p> </li><li> <p>若i插在表外（i&gt;Lengh）则p指针指向NULL（While循环一直指向p-&gt;next），不能插入成功</p> </li><li> <p>最好时间复杂度= O(1)</p> </li><li> <p>最坏时间复杂度= O(n)</p> </li><li> <p>平均时间复杂度= O(n)</p> </li></ul> 
<h6><a id="_377"></a>按位序插入（不带头结点）：</h6> 
<p>ListInsert(&amp;L,i,e)：</p> 
<ul><li> <p>插入操作，在表L中的第i个位置上插入指定元素e</p> </li><li> <p>不存在“第0个”结点，因此i=1时需要特殊处理</p> </li><li> <p>找到第i-1个结点，将新结点插入其后</p> </li></ul> 
<p><img src="https://images2.imgbox.com/d9/14/TyUKMUlG_o.png" alt="img"></p> 
<ul><li> <p>若i!=1则处理方法和带头结点一模一样</p> </li><li> <p>值得注意的是int j =1而非带头结点的0（带头结点的头结点为第0个结点）</p> </li><li> <p>结论：不带头结点写代码更不方便，推荐用带头结点</p> </li></ul> 
<h6><a id="_395"></a>指定结点的后插操作：</h6> 
<p><img src="https://images2.imgbox.com/66/c4/qsvXBT77_o.png" alt="img"></p> 
<ul><li> <p>这一段代码是按位序插入中插入的那一部分代码</p> </li><li> <p>也可以直接调用InsertNextNode来执行</p> </li><li> <p>封装代码，以此提高代码复用性，让代码更容易维护</p> </li></ul> 
<h6><a id="_405"></a>指定结点的前插操作：</h6> 
<ul><li> <p>因为仅知道指定结点的信息和后继结点的指向，因此无法直接获取到前驱结点</p> </li><li> <p>方法1：获取头结点然后再一步步找到指定结点的前驱</p> </li><li> <p>方法2：将新结点先连上指定结点p的后继，接着指定结点p连上新结点s，将p中元素复制到s中，将p中元素覆盖为要插入的元素e</p> </li></ul> 
<p><img src="https://images2.imgbox.com/26/c9/rWTcCYic_o.png" alt="img"></p> 
<p>（方法1）</p> 
<p><img src="https://images2.imgbox.com/1d/1c/1PJDa1q9_o.png" alt="img"></p> 
<p>（方法2）</p> 
<h6><a id="_421"></a>按位序删除（带头结点）：</h6> 
<p>ListDelete(&amp;L,i,&amp;e)：</p> 
<ul><li> <p>删除操作，删除表L中第i个位置的元素，并用e返回删除元素的值。</p> </li><li> <p>找到第i-1个结点，将其指针指向第i+1个结点，并释放第i个结点</p> </li></ul> 
<p><img src="https://images2.imgbox.com/79/a4/HYlrT0WO_o.png" alt="img"></p> 
<h6><a id="_431"></a>指定结点的删除：</h6> 
<ul><li> <p>删除结点p，需要修改其前驱结点的next指针，和指定结点的前插操作一样</p> </li><li> <p>方法1：传入头指针，循环寻找p的前驱结点</p> </li><li> <p>方法2：偷天换日，类似于结点前插的实现</p> </li></ul> 
<p><img src="https://images2.imgbox.com/0c/c3/9SDQBhvw_o.png" alt="img"></p> 
<p>（方法2）</p> 
<p>如果要删除的结点p是最后一个结点：</p> 
<ul><li> <p>只能从表头开始依次寻找p的前驱，时间复杂度O(n)</p> </li><li> <p>这就体现了单链表的局限性：无法逆向检索，有时候不太方便</p> </li></ul> 
<p><img src="https://images2.imgbox.com/7b/7e/V2XEIfgQ_o.png" alt="img"></p> 
<h5><a id="_451"></a>单链表的查找</h5> 
<h6><a id="_453"></a>按位查找：</h6> 
<ul><li> <p>GetElem(L,i)：按位查找操作。获取表L中第i个位置的元素的值。</p> </li><li> <p>实际上单链表的插入中找到i-1部分就是按位查找i-1个结点，如下图</p> </li></ul> 
<p><img src="https://images2.imgbox.com/04/06/r1GmTqvp_o.png" alt="img"></p> 
<ul><li>因此查找第i个结点如下图</li></ul> 
<p><img src="https://images2.imgbox.com/b4/5b/VHHWThUd_o.png" alt="img"></p> 
<ul><li> <p>如果i=0则直接不满足j&lt;i则指针p直接返回头结点L</p> </li><li> <p>如果i超界则当时p指向了NULL，指针p返回NULL</p> </li><li> <p>平均时间复杂度：O(n)</p> </li></ul> 
<h6><a id="_471"></a>按值查找：</h6> 
<ul><li>LocateElem(L,e)：按值查找操作。在表L中查找具有给定关键字值的元素。</li></ul> 
<p><img src="https://images2.imgbox.com/59/6a/atAFdZQa_o.png" alt="img"></p> 
<ul><li> <p>能找到的情况：p指向了e值对应的元素，返回该元素</p> </li><li> <p>不能找到的情况：p指向了NULL，指针p返回NULL</p> </li><li> <p>平均时间复杂度：O(n)</p> </li></ul> 
<h6><a id="_483"></a>求表的长度：</h6> 
<p><img src="https://images2.imgbox.com/4a/b9/yINgcGpL_o.png" alt="img"></p> 
<p>平均时间复杂度：O(n)</p> 
<h5><a id="_489"></a>单链表的建立</h5> 
<h6><a id="_491"></a>尾插法：</h6> 
<ul><li> <p>每次插入元素都插入到单链表的表尾</p> </li><li> <p>方法1：套用之前学过的位序插入，每次都要从头开始往后面遍历，时间复杂度为O(n^2)</p> </li></ul> 
<p><img src="https://images2.imgbox.com/f2/09/wCsn1kNn_o.png" alt="img"></p> 
<ul><li>方法2：增加一个尾指针r，每次插入都让r指向新的表尾结点，时间复杂度为O(n)</li></ul> 
<p><img src="https://images2.imgbox.com/8f/1a/a23oZqD5_o.png" alt="img"></p> 
<h6><a id="_503"></a>头插法：</h6> 
<ul><li> <p>每次插入元素都插入到单链表的表头</p> </li><li> <p>头插法和之前学过的单链表后插操作是一样的，可以直接套用</p> </li><li> <p>L-&gt;next=NULL;可以防止野指针</p> </li></ul> 
<p><img src="https://images2.imgbox.com/e1/84/nqMYhEo1_o.png" alt="img"></p> 
<h6><a id="_513"></a>总结：</h6> 
<ul><li> <p>头插法、尾插法：核心就是初始化操作、指定结点的后插操作</p> </li><li> <p>注意设置一个指向表尾结点的指针</p> </li><li> <p>头插法的重要应用：链表的逆置</p> </li></ul> 
<h5><a id="_521"></a>双链表</h5> 
<h6><a id="_523"></a>为什么要要使用双链表：</h6> 
<ul><li> <p>单链表：无法逆向检索，有时候不太方便</p> </li><li> <p>双链表：可进可退，但是存储密度更低一丢丢</p> </li></ul> 
<p><img src="https://images2.imgbox.com/2d/08/FkvCcSJ9_o.png" alt="img"></p> 
<h6><a id="_531"></a>双链表的初始化（带头结点）：</h6> 
<p><img src="https://images2.imgbox.com/f4/7d/0DLvvbzn_o.png" alt="img"></p> 
<h6><a id="_535"></a>双链表的插入：</h6> 
<p><img src="https://images2.imgbox.com/a1/35/nE4dQUUi_o.png" alt="img"></p> 
<ul><li> <p>小心如果p结点为最后一个结点产生的空指针问题，因此循环链表应运而生（详见后面的循环链表插入删除）</p> </li><li> <p>注意指针的修改顺序</p> </li></ul> 
<h6><a id="_543"></a>双链表的删除：</h6> 
<p><img src="https://images2.imgbox.com/26/f7/xJe5PpRm_o.png" alt="img"></p> 
<h6><a id="_547"></a>双链表的遍历：</h6> 
<p><img src="https://images2.imgbox.com/1c/26/q6nyEc1I_o.png" alt="img"></p> 
<h5><a id="_551"></a>循环链表</h5> 
<h6><a id="_553"></a>循环单链表与单链表的区别：</h6> 
<p>单链表：</p> 
<ul><li> <p>表尾结点的next指针指向NULL</p> </li><li> <p>从一个结点出发只能找到后续的各个结点</p> </li></ul> 
<p>循环单链表：</p> 
<ul><li> <p>表尾结点的next指针指向头结点</p> </li><li> <p>从一个结点出发可以找到其他任何一个结点</p> </li></ul> 
<h6><a id="_567"></a>循环单链表初始化：</h6> 
<p><img src="https://images2.imgbox.com/6a/e2/a98VxxyJ_o.png" alt="img"></p> 
<ul><li> <p>从头结点找到尾部，时间复杂度为O(n)</p> </li><li> <p>如果需要频繁的访问表头、表尾，可以让L指向表尾元素（插入、删除时可能需要修改L）</p> </li><li> <p>从尾部找到头部，时间复杂度为O(1)</p> </li></ul> 
<h6><a id="_577"></a>循环双链表与双链表的区别：</h6> 
<p>双链表：</p> 
<ul><li> <p>表头结点的prior指向NULL</p> </li><li> <p>表尾结点的next指向NULL</p> </li></ul> 
<p>循环双链表：</p> 
<ul><li> <p>表头结点的prior指向表尾结点</p> </li><li> <p>表尾结点的next指向头结点</p> </li></ul> 
<h6><a id="_591"></a>循环双链表的初始化：</h6> 
<p><img src="https://images2.imgbox.com/e0/64/ptEqSRMo_o.png" alt="img"></p> 
<h6><a id="_595"></a>循环链表的插入：</h6> 
<ul><li> <p>对于双链表来说如果p结点为最后一个结点，因为next结点为null，p-&gt;next-&gt;prior=s会产生的空指针问题</p> </li><li> <p>循环链表规避因为最后结点的next结点为头结点因此不会发生问题</p> </li></ul> 
<p><img src="https://images2.imgbox.com/2b/09/YWy5cLVr_o.png" alt="img"></p> 
<h6><a id="_603"></a>循环链表的删除：</h6> 
<p>与循环链表的插入相同。</p> 
<p><img src="https://images2.imgbox.com/1d/6a/ylpDrjwr_o.png" alt="img"></p> 
<h6><a id="_609"></a>注意点：</h6> 
<p>写代码时候注意以下几点，以此规避错误：</p> 
<ul><li> <p>如何判空</p> </li><li> <p>如何判断结点p是否是表尾/表头元素（后向/前向遍历的实现核心）</p> </li><li> <p>如何在表头、表中、表尾插入/删除一个结点</p> </li></ul> 
<h5><a id="_619"></a>静态链表</h5> 
<h6><a id="_621"></a>什么是静态链表：</h6> 
<ul><li> <p>分配一整片连续的内存空间，各个结点集中安置</p> </li><li> <p>每个结点由两部分组成：data（数据元素）和next（游标）</p> </li><li> <p>0号结点充当“头结点”，不具体存放数据</p> </li><li> <p>游标为-1表示已经到达表尾</p> </li><li> <p>游标充当“指针”，表示下个结点的存放位置，下面举一个例子：</p> </li><li> <p>每个数据元素4B，每个游标4B（每个结点共8B），设起始地址为addr，e1的存放地址为addr + 8*2（游标值）</p> </li></ul> 
<h6><a id="_635"></a>定义静态链表：</h6> 
<p>方法1：</p> 
<p><img src="https://images2.imgbox.com/bc/19/AtrhNprj_o.png" alt="img"></p> 
<p>方法2：</p> 
<p><img src="https://images2.imgbox.com/05/36/ALDPLuze_o.png" alt="img"></p> 
<h6><a id="_645"></a>基本操作：</h6> 
<p>初始化：</p> 
<ul><li> <p>把a[0]的next设为-1</p> </li><li> <p>把其他结点的next设为一个特殊值用来表示结点空闲，如-2</p> </li></ul> 
<p>插入位序为i的结点：</p> 
<ul><li> <p>找到一个空的结点，存入数据元素（设为一个特殊值用来表示结点空闲，如-2）</p> </li><li> <p>从头结点出发找到位序为i-1的结点</p> </li><li> <p>修改新结点的next</p> </li><li> <p>修改i-1号结点的next</p> </li></ul> 
<p>删除某个结点：</p> 
<ul><li> <p>从头结点出发找到前驱结点</p> </li><li> <p>修改前驱结点的游标</p> </li><li> <p>被删除结点next设为-2</p> </li></ul> 
<h6><a id="_671"></a>总结：</h6> 
<ul><li> <p>静态链表：用数组的方式实现的链表</p> </li><li> <p>优点：增、删操作不需要大量移动元素</p> </li><li> <p>缺点：不能随机存取，只能从头结点开始依次往后查找；容量固定不可变</p> </li><li> <p>适用场景：①不支持指针的低级语言；②数据元素数量固定不变的场景（如操作系统的文件分配表FAT）</p> </li></ul> 
<h5><a id="_681"></a>顺序表和链表的比较</h5> 
<h6><a id="_683"></a>逻辑结构：</h6> 
<p>都属于线性表，都是线性结构</p> 
<h6><a id="_687"></a>存储结构：</h6> 
<p>顺序表：</p> 
<ul><li> <p>优点：支持随机存取、存储密度高</p> </li><li> <p>缺点：大片连续空间分配不方便，改变容量不方便</p> </li></ul> 
<p>链表：</p> 
<ul><li> <p>优点：离散的小空间分配方便，改变容量方便</p> </li><li> <p>缺点：不可随机存取，存储密度低</p> </li></ul> 
<h6><a id="_701"></a>基本操作：</h6> 
<p>顺序表：</p> 
<ul><li> <p>创建</p> 
  <ul><li> <p>需要预分配大片连续空间。</p> </li><li> <p>若分配空间过小，则之后不方便拓展容量；</p> </li><li> <p>若分配空间过大，则浪费内存资源</p> </li><li> <p>静态分配：静态数组实现，容量不可改变</p> </li><li> <p>动态分配：动态数组（malloc、free）实现，容量可以改变但需要移动大量元素，时间代价高</p> </li></ul> </li><li> <p>销毁</p> 
  <ul><li> <p>修改Length = 0</p> </li><li> <p>静态分配：静态数组，系统自动回收空间</p> </li><li> <p>动态分配：动态数组（malloc、free），需要手动free</p> </li></ul> </li><li> <p>增删</p> 
  <ul><li> <p>插入/删除元素要将后续元素都后移/前移</p> </li><li> <p>时间复杂度O(n)，时间开销主要来自移动元素</p> </li><li> <p>若数据元素很大，则移动的时间代价很高</p> </li></ul> </li><li> <p>查</p> 
  <ul><li> <p>按位查找：O(1)</p> </li><li> <p>按值查找：O(n)若表内元素有序，可在O(log2n)时间内找到</p> </li></ul> </li></ul> 
<p>链表：</p> 
<ul><li> <p>创建</p> 
  <ul><li>只需分配一个头结点（也可以不要头结点，只声明一个头指针），之后方便拓展</li></ul> </li><li> <p>销毁</p> 
  <ul><li>依次删除各个结点（free）</li></ul> </li><li> <p>增删</p> 
  <ul><li> <p>插入/删除元素只需修改指针即可</p> </li><li> <p>时间复杂度O(n)，时间开销主要来自查找目标元素</p> </li><li> <p>查找元素的时间代价更低</p> </li></ul> </li><li> <p>查</p> 
  <ul><li> <p>按位查找：O(n)</p> </li><li> <p>按值查找：O(n)</p> </li></ul> </li></ul> 
<h6><a id="_763"></a>用哪个：</h6> 
<ul><li> <p>表长难以预估、经常要增加/删除元素——链表</p> </li><li> <p>表长可预估、查询（搜索）操作较多——顺序表</p> </li></ul> 
<h6><a id="_769"></a>开放式问题的解题思路：</h6> 
<p>问题： 请描述顺序表和链表的bla bla bla…实现线性表时，用顺序表还是链表好？</p> 
<p>答案：</p> 
<ul><li> <p>顺序表和链表的逻辑结构都是线性结构，都属于线性表。</p> </li><li> <p>但是二者的存储结构不同，顺序表采用顺序存储…(特点，带来的优点缺点)；链表采用链式存储…（特点、导致的优缺点）。</p> </li><li> <p>由于采用不同的存储方式实现，因此基本操作的实现效率也不同。</p> </li><li> <p>当初始化时…；当插入一个数据元素时…；当删除一个数据元素时…；当查找一个数据元素时…</p> </li></ul> 
<h4><a id="_783"></a>栈和队列</h4> 
<h5><a id="_785"></a>栈的基本概念</h5> 
<h6><a id="_787"></a>栈的定义：</h6> 
<ul><li> <p>栈（Stack）是只允许在一端进行插入或删除操作的线性表</p> </li><li> <p>逻辑结构：与普通线性表相同</p> </li><li> <p>数据的运算：插入、删除操作有区别</p> </li><li> <p>栈顶：允许插入和删除的一端，对应元素被称为栈顶元素</p> </li><li> <p>栈底：不允许插入和删除的一端，对应元素被称为栈底元素</p> </li><li> <p>特点：后进先出Last In First Out（LIFO）</p> </li></ul> 
<h6><a id="_801"></a>栈的基本操作：</h6> 
<ul><li> <p>InitStack(&amp;S)：初始化栈。构造一个空栈S，分配内存空间。</p> </li><li> <p>DestroyStack(&amp;S)：销毁栈。销毁并释放栈S所占用的内存空间。</p> </li><li> <p>Push(&amp;S,x)：进栈，若栈S未满，则将x加入使之成为新栈顶。</p> </li><li> <p>Pop(&amp;S,&amp;x)：出栈，若栈S非空，则弹出栈顶元素，并用x返回。</p> </li><li> <p>GetTop(S, &amp;x)：读栈顶元素。若栈S非空，则用x返回栈顶元素</p> </li><li> <p>StackEmpty(S)：判断一个栈S是否为空。若S为空，则返回true，否则返回false。</p> </li></ul> 
<h6><a id="_815"></a>出栈顺序数量：</h6> 
<ul><li>n个不同元素进栈，出栈元素不同排列的个数为</li></ul> 
<p><img src="https://images2.imgbox.com/96/48/C5SGiIC3_o.png" alt="img"></p> 
<ul><li>上述公式称为卡特兰（Catalan）数，可采用数学归纳法证明</li></ul> 
<h5><a id="_823"></a>栈的顺序存储结构</h5> 
<h6><a id="_825"></a>顺序栈的定义和初始化：</h6> 
<p><img src="https://images2.imgbox.com/7b/75/DkUawYoB_o.png" alt="img"></p> 
<h6><a id="_829"></a>进栈操作：</h6> 
<p><img src="https://images2.imgbox.com/68/26/jzgJod1k_o.png" alt="img"></p> 
<h6><a id="_833"></a>出栈操作：</h6> 
<p><img src="https://images2.imgbox.com/06/a5/PJFHng5e_o.png" alt="img"></p> 
<h6><a id="_837"></a>读取栈顶元素：</h6> 
<p><img src="https://images2.imgbox.com/ea/28/UgjHFS97_o.png" alt="img"></p> 
<p>注意：也可以让栈顶指针top先指向0，每次进栈S.top++，出栈–S.top</p> 
<h6><a id="_843"></a>共享栈：</h6> 
<ul><li> <p>使用静态数组要求提前规定好栈的大小，容易造成内存资源的浪费因此共享栈应运而生</p> </li><li> <p>两个栈共享同一片空间，0、1号栈朝着同一方向进栈</p> </li><li> <p>栈满的条件：top0 + 1 == top1</p> </li></ul> 
<p><img src="https://images2.imgbox.com/9d/f6/QpfHp3gp_o.png" alt="img"></p> 
<p><img src="https://images2.imgbox.com/34/0d/HGI1KlOt_o.png" alt="img"></p> 
<h5><a id="_855"></a>栈的链式存储结构</h5> 
<h6><a id="_857"></a>栈的链式存储实质：</h6> 
<ul><li> <p>进栈：头插法建立单链表，也就是对头结点的后插操作</p> </li><li> <p>出栈：单链表的删除操作，对头结点的“后删”操作</p> </li><li> <p>推荐使用不带头结点的链栈</p> </li><li> <p>创销增删查的操作参考链表</p> </li></ul> 
<h6><a id="_867"></a>链栈的定义：</h6> 
<p><img src="https://images2.imgbox.com/7b/12/gBAkPygs_o.png" alt="img"></p> 
<h5><a id="_871"></a>队列的基本概念</h5> 
<h6><a id="_873"></a>队列的定义：</h6> 
<ul><li> <p>栈（Stack）是只允许在一端进行插入或删除操作的操作受限的线性表</p> </li><li> <p>队列（Queue）是只允许在一端进行插入，在另一端删除的线性表</p> </li><li> <p>队头：允许删除的一端，对应的元素被称为队头元素</p> </li><li> <p>队尾：允许插入的一端，对应的元素被称为队尾元素</p> </li><li> <p>队列的特点：先进先出First In First Out（FIFO）</p> </li></ul> 
<h6><a id="_885"></a>队列的基本操作：</h6> 
<ul><li> <p>InitQueue(&amp;Q)：初始化队列，构造一个空队列Q。</p> </li><li> <p>DestroyQueue(&amp;Q)：销毁队列。销毁并释放队列Q所占用的内存空间。</p> </li><li> <p>EnQueue(&amp;Q,x)：入队，若队列Q未满，将x加入，使之成为新的队尾。</p> </li><li> <p>DeQueue(&amp;Q,&amp;x)：出队，若队列Q非空，删除队头元素，并用x返回。</p> </li><li> <p>GetHead(Q,&amp;x)：读队头元素，若队列Q非空，则将队头元素赋值给x。</p> </li><li> <p>QueueEmpty(Q)：判队列空，若队列Q为空返回true，否则返回false。</p> </li></ul> 
<h5><a id="_899"></a>队列的顺序存储结构</h5> 
<h6><a id="_901"></a>队列的定义和初始化：</h6> 
<p><img src="https://images2.imgbox.com/0b/d7/80BEWBM0_o.png" alt="img"></p> 
<h6><a id="_905"></a>入队操作：</h6> 
<p><img src="https://images2.imgbox.com/a9/80/hjo8BUix_o.png" alt="img"></p> 
<ul><li> <p>通过取余操作，只要队列不满，就可以一直利用之前已经出队了的空间，逻辑上实现了循环队列的操作</p> </li><li> <p>于是，队列已满的条件：队尾指针的再下一个位置是队头，即(Q.rear+1)%MaxSize==Q.front</p> </li><li> <p>代价：牺牲了一个存储单元，因为如果rear和front相同，与判空的条件相同了</p> </li></ul> 
<h6><a id="_915"></a>出队操作：</h6> 
<p><img src="https://images2.imgbox.com/b3/7c/rhB9tJtB_o.png" alt="img"></p> 
<p>实际上获取队头元素的值就是出队操作去掉队头指针后移的代码</p> 
<h6><a id="_921"></a>判断队列已满/已空：</h6> 
<p>方案1：</p> 
<ul><li> <p>使用前面讲的牺牲一个存储空间的方式来解决</p> </li><li> <p>初始化时rear=front=0</p> </li><li> <p>队列元素个数：(rear+MaxSize-front)%MaxSize</p> </li><li> <p>队列已满的条件：队尾指针的再下一个位置是队头，即(Q.rear+1)%MaxSize==Q.front</p> </li><li> <p>队空条件：Q.rear==Q.front</p> </li></ul> 
<p>方案2：</p> 
<ul><li> <p>不牺牲一个存储空间，在结构体中多建立一个变量size</p> </li><li> <p>初始化时rear=front=0；size = 0;</p> </li><li> <p>队列元素个数= size</p> </li><li> <p>插入成功size++；删除成功size–;</p> </li><li> <p>此时队满条件：size==MaxSize</p> </li><li> <p>队空条件：size == 0;</p> </li></ul> 
<p>方案3：</p> 
<ul><li> <p>不牺牲一个存储空间，在结构体中多建立一个变量tag</p> </li><li> <p>初始化时rear=front=0；tag = 0;</p> </li><li> <p>因为只有删除操作，才可能导致队空，只有插入操作，才可能导致队满因此</p> </li><li> <p>每次删除操作成功时，都令tag=0；</p> </li><li> <p>每次插入操作成功时，都令tag=1；</p> </li><li> <p>队满条件：front==rear &amp;&amp; tag == 1</p> </li><li> <p>队空条件：front==rear &amp;&amp; tag == 0</p> </li><li> <p>队列元素个数：(rear+MaxSize-front)%MaxSize</p> </li></ul> 
<h5><a id="_967"></a>队列的链式存储结构</h5> 
<h6><a id="_969"></a>初始化（带头结点）：</h6> 
<p><img src="https://images2.imgbox.com/75/90/PuzXtZ1b_o.png" alt="img"></p> 
<h6><a id="_973"></a>初始化（不带头结点）：</h6> 
<p><img src="https://images2.imgbox.com/35/9d/AU4VYJbE_o.png" alt="img"></p> 
<h6><a id="_977"></a>入队（带头结点）：</h6> 
<p><img src="https://images2.imgbox.com/12/21/b1qPM4Mq_o.png" alt="img"></p> 
<h6><a id="_981"></a>入队（不带头结点）：</h6> 
<p><img src="https://images2.imgbox.com/d5/7d/UYA7Ymzm_o.png" alt="img"></p> 
<h6><a id="_985"></a>出队（带头结点）：</h6> 
<p><img src="https://images2.imgbox.com/16/7a/dges64uP_o.png" alt="img"></p> 
<h6><a id="_989"></a>出队（不带头结点）：</h6> 
<p><img src="https://images2.imgbox.com/25/a5/FJpRqciB_o.png" alt="img"></p> 
<h6><a id="_993"></a>队列满的条件：</h6> 
<ul><li> <p>顺序存储：预分配的空间耗尽时队满</p> </li><li> <p>链式存储：一般不会队满，除非内存不足</p> </li><li> <p>因此一般不用考虑队满</p> </li></ul> 
<h5><a id="_1001"></a>双端队列</h5> 
<h6><a id="_1003"></a>定义：</h6> 
<ul><li> <p>双端队列：只允许从两端插入、两端删除的线性表</p> </li><li> <p>输入受限的双端队列：只允许从一端插入、两端删除的线性表</p> </li><li> <p>输出受限的双端队列：只允许从两端插入、一端删除的线性表</p> </li><li> <p>不管是怎么样的双端队列实际都是栈和队列的变种</p> </li></ul> 
<h6><a id="_1013"></a>考点：</h6> 
<ul><li> <p>判断输出序列合法性</p> </li><li> <p>在栈中合法的输出序列，在双端队列中必定合法</p> </li></ul> 
<h5><a id="_1019"></a>栈在括号匹配中的应用</h5> 
<h6><a id="_1021"></a>括号匹配问题：</h6> 
<p><img src="https://images2.imgbox.com/53/54/hSIK7Xmc_o.png" alt="img"></p> 
<ul><li> <p>若有括号无法被匹配则出现编译错误</p> </li><li> <p>遇到左括号就入栈</p> </li><li> <p>遇到右括号，就“消耗”一个左括号</p> </li></ul> 
<h6><a id="_1031"></a>代码实现：</h6> 
<p><img src="https://images2.imgbox.com/5f/5a/JnaTn7Xq_o.png" alt="img"></p> 
<h5><a id="_1035"></a>栈在表达式求值中的应用</h5> 
<h6><a id="_1037"></a>算数表达式：</h6> 
<ul><li> <p>由三个部分组成：操作数、运算符、界限符</p> </li><li> <p>我们平时写的算术表达式都是中缀表达式</p> </li><li> <p>如何可以不用界限符也能无歧义地表达运算顺序</p> </li><li> <p>Reverse Polish notation（逆波兰表达式=后缀表达式）</p> </li><li> <p>Polish notation（波兰表达式=前缀表达式）</p> </li></ul> 
<h6><a id="_1049"></a>中缀、后缀、前缀表达式：</h6> 
<p><img src="https://images2.imgbox.com/c8/3f/iT5EPpHH_o.png" alt="img"></p> 
<h6><a id="_1053"></a>中缀转后缀的方法（手算）：</h6> 
<ul><li> <p>确定中缀表达式中各个运算符的运算顺序</p> </li><li> <p>选择下一个运算符，按照「左操作数右操作数运算符」的方式组合成一个新的操作数</p> </li><li> <p>如果还有运算符没被处理，就继续第二步</p> </li><li> <p>注意：运算顺序不唯一，因此对应的后缀表达式也不唯一</p> </li><li> <p>“左优先”原则：只要左边的运算符能先计算，就优先算左边的，保证手算和机算是一致的</p> </li></ul> 
<p><img src="https://images2.imgbox.com/69/98/rfvkEdEJ_o.png" alt="img"></p> 
<h6><a id="_1067"></a>中缀表达式转后缀表达式（机算，用栈实现）：</h6> 
<ul><li> <p>初始化一个栈，用于保存暂时还不能确定运算顺序的运算符。</p> </li><li> <p>从左到右处理各个元素，直到末尾。可能遇到三种情况：</p> 
  <ul><li> <p>遇到操作数。直接加入后缀表达式。</p> </li><li> <p>遇到界限符。遇到“(”直接入栈；遇到“)”则依次弹出栈内运算符并加入后缀表达式，直到弹出“(”为止。注意：“(”不加入后缀表达式。</p> </li><li> <p>遇到运算符。依次弹出栈中优先级高于或等于当前运算符的所有运算符，并加入后缀表达式，若碰到“(”或栈空则停止。之后再把当前运算符入栈。</p> </li></ul> </li><li> <p>按上述方法处理完所有字符后，将栈中剩余运算符依次弹出，并加入后缀表达式。</p> </li></ul> 
<h6><a id="_1081"></a>后缀表达式的计算（手算）：</h6> 
<ul><li> <p>从左往右扫描，每遇到一个运算符，就让运算符前面最近的两个操作数执行对应运算，合体为一个操作数</p> </li><li> <p>注意：两个操作数的左右顺序</p> </li><li> <p>特点：最后出现的操作数先被运算，LIFO（后进先出），可以使用栈来完成这个步骤</p> </li><li> <p>“左优先”原则：只要左边的运算符能先计算，就优先算左边的</p> </li></ul> 
<h6><a id="_1091"></a>后缀表达式的计算（机算，用栈实现）：</h6> 
<ul><li> <p>从左往右扫描下一个元素，直到处理完所有元素</p> </li><li> <p>若扫描到操作数则压入栈，并回到第一步；否则执行第三步</p> </li><li> <p>若扫描到运算符，则弹出两个栈顶元素，执行相应运算，运算结果压回栈顶，回到第一步</p> </li><li> <p>注意：先出栈的是“右操作数”</p> </li><li> <p>若表达式合法，则最后栈中只会留下一个元素，就是最终结果</p> </li><li> <p>后缀表达式适用于基于栈的编程语言（stack-orientedprogramming language），如：Forth、PostScript</p> </li></ul> 
<h6><a id="_1105"></a>中缀表达式转前缀表达式（手算）：</h6> 
<ul><li> <p>确定中缀表达式中各个运算符的运算顺序</p> </li><li> <p>选择下一个运算符，按照「运算符左操作数右操作数」的方式组合成一个新的操作数</p> </li><li> <p>如果还有运算符没被处理，就继续第二步</p> </li><li> <p>“右优先”原则：只要右边的运算符能先计算，就优先算右边的</p> </li></ul> 
<h6><a id="_1115"></a>中缀表达式的计算（机算，用栈实现）：</h6> 
<ul><li> <p>中缀表达式的计算=中缀转后缀+后缀表达式求值，两个算法的结合</p> </li><li> <p>用栈实现中缀表达式的计算：</p> 
  <ul><li> <p>初始化两个栈，操作数栈和运算符栈</p> </li><li> <p>若扫描到操作数，压入操作数栈</p> </li><li> <p>若扫描到运算符或界限符，则按照“中缀转后缀”相同的逻辑压入运算符栈（期间也会弹出运算符，每当弹出一个运算符时，就需要再弹出两个操作数栈的栈顶元素并执行相应运算，运算结果再压回操作数栈）</p> </li></ul> </li></ul> 
<h5><a id="_1127"></a>栈在递归中的应用</h5> 
<h6><a id="_1129"></a>函数调用的特点：</h6> 
<ul><li> <p>最后被调用的函数最先执行结束（LIFO）</p> </li><li> <p>函数调用时，需要用一个栈（函数调用栈）存储，里面包含以下信息：</p> 
  <ul><li> <p>调用返回地址</p> </li><li> <p>实参</p> </li><li> <p>局部变量</p> </li></ul> </li><li> <p>适合用“递归”算法解决：可以把原始问题转换为属性相同，但规模较小的问题</p> </li></ul> 
<h6><a id="_1143"></a>栈在递归中的应用：</h6> 
<ul><li> <p>计算正整数的阶乘n!</p> </li><li> <p>求斐波那契数列</p> </li><li> <p>…</p> </li></ul> 
<h6><a id="_1151"></a>栈在递归中过程：</h6> 
<ul><li> <p>递归调用时，函数调用栈可称为“递归工作栈”</p> </li><li> <p>每进入一层递归，就将递归调用所需信息压入栈顶</p> </li><li> <p>每退出一层递归，就从栈顶弹出相应信息</p> </li><li> <p>缺点：</p> 
  <ul><li> <p>太多层递归可能会导致栈溢出</p> </li><li> <p>可能包含很多重复计算</p> </li></ul> </li></ul> 
<h5><a id="_1165"></a>队列的应用</h5> 
<ul><li> <p>树的层次遍历</p> </li><li> <p>图的广度优先遍历</p> </li><li> <p>操作系统中的应用</p> 
  <ul><li> <p>多个进程争抢着使用有限的系统资源时，FCFS（First Come First Service，先来先服务）是一种常用策略。可以用队列实现</p> </li><li> <p>CPU资源的分配</p> </li><li> <p>打印数据缓冲区</p> </li></ul> </li></ul> 
<h5><a id="_1179"></a>特殊矩阵的压缩储存</h5> 
<h6><a id="_1181"></a>一维数组的存储结构：</h6> 
<ul><li> <p>起始地址：LOC</p> </li><li> <p>各数组元素大小相同，且物理上连续存放。</p> </li><li> <p>数组元素a[i]的存放地址= LOC + i * sizeof(ElemType)</p> </li></ul> 
<h6><a id="_1189"></a>二维数组的存储结构：</h6> 
<ul><li> <p>分为行优先和列优先，本质就是把二维的逻辑视角转换为内存中的一维储存</p> </li><li> <p>M行N列的二维数组b[M][N]中，若按行优先存储，则b[i][j]的存储地址= LOC + (i*N + j) * sizeof(ElemType)</p> </li><li> <p>M行N列的二维数组b[M][N]中，若按列优先存储，则b[i][j]的存储地址= LOC + ( j*M+ i ) * sizeof(ElemType)</p> </li><li> <p>二维数组也有随机存储的特性</p> </li></ul> 
<h6><a id="_1199"></a>普通矩阵的存储：</h6> 
<ul><li> <p>可用二维数组存储</p> </li><li> <p>注意：描述矩阵元素时，行、列号通常从1开始；而描述数组时通常下标从0开始</p> </li><li> <p>某些特殊矩阵可以压缩存储空间（比如对称矩阵）</p> </li></ul> 
<h6><a id="_1207"></a>对称矩阵的压缩存储：</h6> 
<ul><li> <p>若n阶方阵中任意一个元素ai,j都有ai,j = aj,i则该矩阵为对称矩阵</p> </li><li> <p>普通存储：n*n二维数组</p> </li><li> <p>压缩存储策略：只存储主对角线+下三角区（或主对角线+上三角区），按行优先原则将各元素存入一维数组中</p> </li><li> <p>数组大小应为多少：(1+n)*n/2</p> </li><li> <p>站在程序员的角度，对称矩阵压缩存储后怎样才能方便使用：可以实现一个“映射”函数矩阵下标-&gt;一维数组下标</p> </li><li> <p>按行优先的原则，ai,j是第几个元素：</p> </li></ul> 
<p><img src="https://images2.imgbox.com/f3/59/DmkDHvcM_o.png" alt="img"></p> 
<h6><a id="_1223"></a>三角矩阵的压缩存储：</h6> 
<ul><li> <p>下三角矩阵：除了主对角线和下三角区，其余的元素都相同</p> </li><li> <p>上三角矩阵：除了主对角线和上三角区，其余的元素都相同</p> </li><li> <p>压缩存储策略：按行优先原则将橙色区元素存入一维数组中，并在最后一个位置存储常量c</p> </li><li> <p>下三角矩阵，按行优先的原则，ai,j是第几个元素：</p> </li></ul> 
<p><img src="https://images2.imgbox.com/79/d3/yD16uI2W_o.png" alt="img"></p> 
<ul><li>上三角矩阵，按行优先的原则，ai,j是第几个元素：</li></ul> 
<p><img src="https://images2.imgbox.com/0d/57/il1CetXx_o.png" alt="img"></p> 
<h6><a id="_1239"></a>三对角矩阵的压缩存储：</h6> 
<ul><li> <p>三对角矩阵，又称带状矩阵：当|i - j|&gt;1时，有ai,j = 0 （1≤ i, j ≤n）</p> </li><li> <p>压缩存储策略：按行优先（或列优先）原则，只存储带状部分</p> </li><li> <p>按行优先的原则，ai,j是第几个元素：</p> </li></ul> 
<p><img src="https://images2.imgbox.com/54/94/FEEnyHj9_o.png" alt="img"></p> 
<p><img src="https://images2.imgbox.com/2e/e1/4i5hts0W_o.png" alt="img"></p> 
<h6><a id="_1251"></a>稀疏矩阵的压缩存储：</h6> 
<ul><li> <p>稀疏矩阵：非零元素远远少于矩阵元素的个数</p> </li><li> <p>压缩存储策略1：顺序存储——三元组&lt;i（行），j（列），v（值）&gt;，失去了数组随机存储的特性</p> </li><li> <p>压缩存储策略2：链式存储，十字链表法</p> </li></ul> 
<p><img src="https://images2.imgbox.com/c0/ae/eTAQ9YnN_o.png" alt="img"></p> 
<h4><a id="_1261"></a>串</h4> 
<h5><a id="_1263"></a>串的定义和基本操作</h5> 
<h6><a id="_1265"></a>定义：</h6> 
<ul><li> <p>串，即字符串（String）是由零个或多个字符组成的有限序列。一般记为S = ‘a1a2······an’ （n ≥0）</p> </li><li> <p>其中，S是串名，单引号括起来的字符序列是串的值；ai可以是字母、数字或其他字符；串中字符的个数n称为串的长度。n = 0时的串称为空串（用∅表示）。</p> </li><li> <p>有的地方用双引号（如Java、C），有的地方用单引号（如Python）</p> </li><li> <p>例如：S=”HelloWorld!”T=‘iPhone 11 Pro Max?’</p> </li><li> <p>子串：串中任意个连续的字符组成的子序列。Eg：’iPhone’，’Pro M’是串T的子串</p> </li><li> <p>主串：包含子串的串。Eg：T是子串’iPhone’的主串</p> </li><li> <p>字符在主串中的位置：字符在串中的序号。Eg：’1’在T中的位置是8(第一次出现)</p> </li><li> <p>子串在主串中的位置：子串的第一个字符在主串中的位置。Eg：’11 Pro’在T中的位置为8</p> </li><li> <p>每个空格字符占1B，不是空串</p> </li><li> <p>串的位序从1开始而不是从0开始</p> </li><li> <p>串是一种特殊的线性表，数据元素之间呈线性关系</p> </li><li> <p>串的数据对象限定为字符集（如中文字符、英文字符、数字字符、标点字符等）</p> </li><li> <p>串的基本操作，如增删改查等通常以子串为操作对象，因为人类的语言通常要多个字符组成的序列才有现实意义</p> </li></ul> 
<h6><a id="_1293"></a>串的基本操作：</h6> 
<ul><li> <p>假设有串T=“”，S=”iPhone 11 Pro Max?”，W=“Pro”</p> </li><li> <p>StrAssign(&amp;T,chars)：赋值操作。把串T赋值为chars。</p> </li><li> <p>StrCopy(&amp;T,S)：复制操作。由串S复制得到串T。</p> </li><li> <p>StrEmpty(S)：判空操作。若S为空串，则返回TRUE，否则返回FALSE。</p> </li><li> <p>StrLength(S)：求串长。返回串S的元素个数。</p> </li><li> <p>ClearString(&amp;S)：清空操作。将S清为空串。</p> </li><li> <p>DestroyString(&amp;S)：销毁串。将串S销毁（回收存储空间）。</p> </li><li> <p>Concat(&amp;T,S1,S2)：串联接。用T返回由S1和S2联接而成的新串</p> </li><li> <p>SubString(&amp;Sub,S,pos,len)：求子串。用Sub返回串S的第pos个字符起长度为len的子串。</p> </li><li> <p>Index(S,T)：定位操作。若主串S中存在与串T值相同的子串，则返回它在主串S中第一次出现的位置；否则函数值为0。</p> </li><li> <p>StrCompare(S,T)：比较操作。若S&gt;T，则返回值&gt;0；若S=T，则返回值=0；若S&lt;T，则返回值&lt;0。</p> 
  <ul><li> <p>从第一个字符开始往后依次对比，先出现更大字符的串就更大</p> </li><li> <p>长串的前缀与短串相同时，长串更大</p> </li><li> <p>只有两个串完全相同时，才相等</p> </li></ul> </li></ul> 
<h6><a id="_1323"></a>字符集编码：</h6> 
<ul><li> <p>任何数据存到计算机中一定是二进制数。</p> </li><li> <p>需要确定一个字符和二进制数的对应规则这就是“编码”</p> </li><li> <p>“字符集”：英文字符，ASCII字符集，中英文，Unicode字符集</p> </li><li> <p>基于同一个字符集，可以有多种编码方案，如：UTF-8，UTF-16</p> </li><li> <p>注：采用不同的编码方式，每个字符所占空间不同，考研中只需默认每个字符占1B即可</p> </li></ul> 
<h5><a id="_1335"></a>串的储存结构</h5> 
<h6><a id="_1337"></a>顺序存储：</h6> 
<p><img src="https://images2.imgbox.com/dd/19/KkvzrV8e_o.png" alt="img"></p> 
<ul><li> <p>方案一：一个数组来储存字符，一个int变量length储存实际长度</p> </li><li> <p>方案二：数组的ch[0]来充当length，优点：字符的位序和数组下标相同</p> </li><li> <p>方案三：没有Length变量，以字符’\0’表示结尾（对应ASCII码的0），缺点：获取字符串长度需要遍历，时间复杂度高</p> </li><li> <p>方案四：数组的ch[0]废弃不用，从看开始储存字符，外加一个int变量length储存实际长度</p> </li></ul> 
<h6><a id="_1349"></a>链式存储：</h6> 
<p><img src="https://images2.imgbox.com/51/6d/UGV24Xsk_o.png" alt="img"></p> 
<p>推荐使用第二种方式，存储密度较高，ch数组未必一定是4个字符，也可以比4多</p> 
<h6><a id="_1355"></a>基本操作的实现（使用第四种方案）：</h6> 
<p><img src="https://images2.imgbox.com/d9/4a/WuFsXYLY_o.png" alt="img"></p> 
<p><img src="https://images2.imgbox.com/84/fd/F9wMnHI6_o.png" alt="img"></p> 
<p><img src="https://images2.imgbox.com/50/69/inq0yHk3_o.png" alt="img"></p> 
<h5><a id="_1363"></a>朴素模式匹配算法</h5> 
<h6><a id="_1365"></a>字符串模式匹配：</h6> 
<ul><li> <p>在主串中找到与模式串相同的子串，并返回其所在位置。</p> </li><li> <p>子串：主串的一部分，一定存在</p> </li><li> <p>模式串：不一定能在主串中找到</p> </li><li> <p>要掌握朴素模式匹配算法、KMP算法两种方法</p> </li></ul> 
<h6><a id="_1375"></a>朴素模式匹配算法（两种实现方法）：</h6> 
<ul><li> <p>将主串中所有长度为m的子串依次与模式串对比，直到找到一个完全匹配的子串，或所有的子串都不匹配为止。</p> </li><li> <p>主串长度为n，模式串长度为 m，最多对比 n-m+1 个子串</p> </li><li> <p>上节讲的index定位操作就是朴素模式匹配算法中其中一种实现方法</p> </li><li> <p>也可以使用两个指针i和j来进行匹配。若当前子串匹配失败，则主串指针 i 指向下一个子串的第一个位置，模式串指针 j 回到模式串的第一个位置，即i = i - j + 2; j = 1;</p> </li><li> <p>若 j &gt; T.length，则当前子串匹配成功，返回当前子串第一个字符的位置即i - T.length</p> </li></ul> 
<p><img src="https://images2.imgbox.com/00/d1/3yck50sf_o.png" alt="img"></p> 
<ul><li>设主串长度为 n，模式串长度为 m，则最坏时间复杂度 = O(n*m)，最好时间复杂度 = O(n)</li></ul> 
<h5><a id="KMP_1391"></a>KMP算法的概念</h5> 
<ul><li> <p>由D.E.Knuth，J.H.Morris和V.R.Pratt提出，因此称为 KMP算法</p> </li><li> <p>是对朴素模式匹配算法的优化</p> </li><li> <p>优化的原理就是减少了i指针的回溯，通过已经计算好的next指针，提高算法的整体运行效率</p> </li><li> <p>next数组记录了当第几个元素匹配失败时候，j的取值例如：</p> 
  <ul><li> <p>对于模式串 T = ‘abaabc’</p> </li><li> <p>当第6个元素匹配失败时，可令主串指针 i 不变，模式串指针 j=3</p> </li><li> <p>当第5个元素匹配失败时，可令主串指针 i 不变，模式串指针 j=2</p> </li><li> <p>当第4个元素匹配失败时，可令主串指针 i 不变，模式串指针 j=2</p> </li><li> <p>当第3个元素匹配失败时，可令主串指针 i 不变，模式串指针 j=1</p> </li><li> <p>当第2个元素匹配失败时，可令主串指针 i 不变，模式串指针 j=1</p> </li><li> <p>当第1个元素匹配失败时，匹配下一个相邻子串，令 j=0, i++, j++</p> </li></ul> </li><li> <p>next数组只和短短的模式串有关，和长长的主串无关（重要）</p> </li><li> <p>之所以只和模式串有关，是因为如果在哪里匹配失败，同时说明在这之前的部分主串和模式串是相同的</p> </li><li> <p>KMP算法，最坏时间复杂度 O(m+n)，其中，求 next 数组时间复杂度 O(m)，模式匹配过程最坏时间复杂度 O(n)</p> </li><li> <p>KMP算法精髓：利用好已经匹配过的模式串的信息</p> </li></ul> 
<p><img src="https://images2.imgbox.com/2e/15/mmMzMkyL_o.png" alt="img"></p> 
<ul><li> <p>步骤：</p> 
  <ul><li>根据模式串T，求出 next 数组</li></ul> </li><li> <p>利用next数组进行匹配（主串指针不回溯）</p> </li></ul> 
<p><img src="https://images2.imgbox.com/0e/3e/lI2Xz35c_o.png" alt="img"></p> 
<h5><a id="KMPnext_1433"></a>KMP算法之求next数组</h5> 
<h6><a id="next_1435"></a>next数组的作用：</h6> 
<p>当模式串的第 j 个字符失配时，从模式串的第 next[j] 的继续往后匹配</p> 
<h6><a id="next_1439"></a>next数组的求法：</h6> 
<ul><li> <p>任何模式串都一样，第1个字符不匹配时，只能匹配下一个子串，因此next[1]都无脑写 0（if(j==0) {i++; j++;}）</p> </li><li> <p>任何模式串都一样，第2个字符不匹配时，应尝试匹配模式串的第1个字符，因此next[2]都无脑写 1</p> </li><li> <p>每一个模式串不一样，对于第3个字符及之后的字符串，在不匹配的位置前边，划一根美丽的分界线模式串一步一步往后退，直到分界线之前“能对上”，此时 j 指向哪儿，next数组值就是多少</p> </li></ul> 
<h5><a id="KMPnextval_1447"></a>KMP算法之求nextval数组</h5> 
<h6><a id="_1449"></a>定义：</h6> 
<p>nextval数组是对next数组的优化，用nextval替代next数组，减少了无意义的对比</p> 
<h6><a id="nextval_1453"></a>nextval数组的求法：</h6> 
<ul><li> <p>先根据上面的方法算出next数组</p> </li><li> <p>先令nextval[1]=0</p> </li><li> <p>再根据下面代码算出后面的nextval数组</p> </li></ul> 
<p>for(int j = 2; j &lt;= T.length; j++)<br> {<!-- --><br> //让第next值个元素的值和当前元素比较<br> if(T.ch[next[j]] == T.ch[j])<br> {<!-- --><br> //若相等则让第next值个元素的nextval值复制给当前元素的nextval值<br> nextval[j] = nextval[next[j]];<br> }<br> else<br> {<!-- --><br> //若不等则让当前元素的next值赋值给当前元素的nextval值<br> nextval[j] = next[j];<br> }<br> }</p> 
<h4><a id="_1476"></a>树</h4> 
<h5><a id="_1478"></a>树的定义和基本术语</h5> 
<h6><a id="_1480"></a>空树：</h6> 
<p>结点数为0的树</p> 
<h6><a id="_1484"></a>非空树的特性：</h6> 
<ul><li> <p>有且仅有一个根结点</p> </li><li> <p>没有后继的结点称为“叶子结点”（或终端结点）</p> </li><li> <p>有后继的结点称为“分支结点”（或非终端结点）</p> </li><li> <p>除了根结点外，任何一个结点都有且仅有一个前驱</p> </li><li> <p>每个结点可以有0个或多个后继</p> </li></ul> 
<h6><a id="_1496"></a>树的定义：</h6> 
<ul><li> <p>树是n（n≥0）个结点的有限集合，n = 0时，称为空树，这是一种特殊情况。</p> </li><li> <p>在任意一棵非空树中应满足：</p> 
  <ul><li> <p>有且仅有一个特定的称为根的结点。</p> </li><li> <p>当n &gt; 1时，其余结点可分为m（m &gt; 0）个互不相交的有限集合T1, T2,…, Tm，其中每个集合本身又是一棵树，并且称为根结点的子树。</p> </li></ul> </li></ul> 
<h6><a id="_1506"></a>结点之间的关系描述：</h6> 
<ul><li> <p>什么是祖先结点？比自己深度低的结点</p> </li><li> <p>什么是子孙结点？比自己深度高的结点</p> </li><li> <p>什么是双亲结点（父结点）？自己的根结点</p> </li><li> <p>什么是孩子结点？自己作为根结点的儿子</p> </li><li> <p>什么是兄弟结点？与自己拥有相同父结点结点</p> </li><li> <p>什么是堂兄弟结点？与自己同一层的结点</p> </li><li> <p>什么是两个结点之间的路径？能从上往下前往的两个结点被称为有路径</p> </li><li> <p>什么是路径长度？经过几条边</p> </li></ul> 
<h6><a id="_1524"></a>结点、树的属性描述：</h6> 
<ul><li> <p>结点的层次（深度）：从上往下数，默认从1开始</p> </li><li> <p>结点的高度：从下往上数</p> </li><li> <p>树的高度（深度）：总共多少层</p> </li><li> <p>结点的度：有几个孩子（分支）</p> </li><li> <p>树的度：各结点的度的最大值</p> </li></ul> 
<h6><a id="_1536"></a>有序数和无序树：</h6> 
<ul><li> <p>有序树：逻辑上看，树中结点的各子树从左至右是有次序的，不能互换</p> </li><li> <p>无序树：逻辑上看，树中结点的各子树从左至右是无次序的，可以互换</p> </li><li> <p>是否是什么，具体看你用树存什么，是否需要用结点的左右位置反映某些逻辑关系</p> </li></ul> 
<h6><a id="_1544"></a>树和森林：</h6> 
<ul><li> <p>森林是m（m≥0）棵互不相交的树的集合</p> </li><li> <p>考点：树和森林的相互转换</p> </li></ul> 
<h5><a id="_1550"></a>树的性质</h5> 
<ul><li> <p>树的总结点数=树的总度数+1</p> </li><li> <p>度数为m的树和m叉树的区别</p> </li></ul> 
<p><img src="https://images2.imgbox.com/2d/67/qq0xKehY_o.png" alt="img"></p> 
<ul><li> <p>度为m的树第i 层至多有m^i-1 个结点（i≥1）</p> </li><li> <p>m叉树第i 层至多有m^i-1 个结点（i≥1）</p> </li><li> <p>高度为h的m叉树至多有((m^h)-1)/m-1个结点</p> </li><li> <p>高度为h的m叉树至少有h 个结点</p> </li><li> <p>高度为h、度为m的树至少有h+m-1 个结点</p> </li><li> <p>具有n个结点的m叉树的最小高度为logm(n(m - 1) + 1)</p> </li><li> <p>高度最小的情况：所有结点都有m个孩子</p> </li></ul> 
<h5><a id="_1572"></a>二叉树的定义和基本术语</h5> 
<h6><a id="_1574"></a>定义：</h6> 
<ul><li> <p>二叉树是n（n≥0）个结点的有限集合</p> 
  <ul><li> <p>或者为空二叉树，即n = 0。</p> </li><li> <p>或者由一个根结点和两个互不相交的被称为根的左子树和右子树组成。左子树和右子树又分别是一棵二叉树。</p> </li></ul> </li><li> <p>特点：</p> 
  <ul><li> <p>每个结点至多只有两棵子树</p> </li><li> <p>左右子树不能颠倒（二叉树是有序树）</p> </li></ul> </li></ul> 
<h6><a id="_1588"></a>二叉树的五种状态：</h6> 
<ul><li> <p>空二叉树</p> </li><li> <p>只有左子树</p> </li><li> <p>只有右子树</p> </li><li> <p>只有根结点</p> </li><li> <p>左右子树都有</p> </li></ul> 
<h6><a id="_1600"></a>几个特殊的二叉树：</h6> 
<ul><li> <p>满二叉树：一棵高度为h，且含有2^h - 1个结点的二叉树</p> 
  <ul><li> <p>特点：</p> 
    <ul><li> <p>只有最后一层有叶子结点</p> </li><li> <p>不存在度为1 的结点</p> </li><li> <p>按层序从1 开始编号，结点i 的左孩子为2i，右孩子为2i+1；结点i 的父结点为𝑖/2 （如果有的话）</p> </li></ul> </li></ul> </li><li> <p>完全二叉树：当且仅当其每个结点都与高度为h的满二叉树中编号为1～n的结点一一对应时，称为完全二叉树</p> 
  <ul><li> <p>特点：</p> 
    <ul><li> <p>只有最后两层可能有叶子结点</p> </li><li> <p>最多只有一个度为1的结点</p> </li><li> <p>按层序从1 开始编号，结点i 的左孩子为2i，右孩子为2i+1；结点i 的父结点为𝑖/2 （如果有的话）</p> </li><li> <p>i≤ n/2 为分支结点， i&gt; n/2 为叶子结点</p> </li><li> <p>如果某结点只有一个孩子，那么一定是左孩子</p> </li></ul> </li></ul> </li><li> <p>是满二叉树一定是完全二叉树，是完全二叉树不一定是满二叉树</p> </li><li> <p>二叉排序树：一棵二叉树或者是空二叉树，或者是具有如下性质的二叉树：</p> 
  <ul><li> <p>左子树上所有结点的关键字均小于根结点的关键字</p> </li><li> <p>右子树上所有结点的关键字均大于根结点的关键字</p> </li><li> <p>左子树和右子树又各是一棵二叉排序树</p> </li></ul> </li><li> <p>二叉排序树可用于元素的排序、搜索</p> </li><li> <p>平衡二叉树：树上任一结点的左子树和右子树的深度之差不超过1。</p> 
  <ul><li> <p>平衡二叉树能有更高的搜索效率</p> </li><li> <p>又宽又胖的树</p> </li></ul> </li></ul> 
<h5><a id="_1644"></a>各种二叉树的性质</h5> 
<h6><a id="_1646"></a>二叉树的性质：</h6> 
<ul><li> <p>设非空二叉树中度为0、1和2的结点个数分别为n0、n1和n2，则n0 = n2 + 1（叶子结点比二分支结点多一个）</p> </li><li> <p>二叉树第i 层至多有2^(i-1)个结点（i≥1）</p> </li><li> <p>高度为h的2叉树至多有(2^h)-1个结点（满二叉树）</p> </li></ul> 
<h6><a id="_1654"></a>完全二叉树的性质：</h6> 
<ul><li> <p>具有n个（n&gt;0）结点的完全二叉树的高度h为log2(n + 1) 或[log2n] + 1</p> </li><li> <p>对于完全二叉树，可以由的结点数n 推出度为0、1和2的结点个数为n0、n1和n2（突破点：完全二叉树最多只会有一个度为1的结点）</p> </li></ul> 
<h5><a id="_1660"></a>二叉树的储存结构</h5> 
<h6><a id="_1662"></a>顺序存储：</h6> 
<p><img src="https://images2.imgbox.com/00/fa/mrVj3Ueo_o.png" alt="img"></p> 
<p>常用的基本操作：</p> 
<ul><li> <p>i的左孩子：2i</p> </li><li> <p>i的右孩子：2i+1</p> </li><li> <p>i的父结点：⌊i/2⌋</p> </li><li> <p>i所在的层次：⌈log2(n+1)⌉或者⌊log2n⌋+1</p> </li></ul> 
<p>若完全二叉树中共有n个结点，则：</p> 
<ul><li> <p>判断i是否有左孩子：2i ≤ n ?</p> </li><li> <p>判断i是否有右孩子：2i+1 ≤ n ?</p> </li><li> <p>判断i是否是叶子/分支结点：i &gt; ⌊n/2⌋ ?</p> </li></ul> 
<p>储存非完全二叉树：</p> 
<p><img src="https://images2.imgbox.com/fb/2c/llLBhRr3_o.png" alt="img"></p> 
<h6><a id="_1688"></a>二叉树的链式存储：</h6> 
<p>定义和初始化：</p> 
<p><img src="https://images2.imgbox.com/9e/b5/hRiOrjfH_o.png" alt="img"></p> 
<ul><li> <p>这样的方法可以很简单的找到p结点的左右孩子，但是只能通过从根开始遍历查找找到结点p的父结点</p> </li><li> <p>可以通过多定一个父结点的指针来方便的查找父结点（三叉链表）</p> </li></ul> 
<p><img src="https://images2.imgbox.com/61/1b/3SSdhzgU_o.png" alt="img"></p> 
<ul><li>n个结点的二叉链表共有n+1 个空链域（可以用来构建线索二叉树）</li></ul> 
<h5><a id="_1702"></a>二叉树的先中后序遍历</h5> 
<h6><a id="_1704"></a>遍历：</h6> 
<ul><li> <p>遍历：按照某种次序把所有结点都访问一遍</p> </li><li> <p>层序遍历：基于树的层次特性确定的次序规则</p> </li><li> <p>先/中/后序遍历：基于树的递归特性确定的次序规则</p> </li></ul> 
<h6><a id="_1712"></a>二叉树的遍历：</h6> 
<ul><li> <p>二叉树的递归特性：</p> 
  <ul><li> <p>要么是个空二叉树</p> </li><li> <p>要么就是由“根结点+左子树+右子树”组成的二叉树</p> </li></ul> </li><li> <p>先序遍历：根左右（NLR）</p> </li><li> <p>中序遍历：左根右（LNR）</p> </li><li> <p>后序遍历：左右根（LRN）</p> </li></ul> 
<p><img src="https://images2.imgbox.com/a1/9d/96faeQ4f_o.png" alt="img"></p> 
<h6><a id="_1728"></a>先序遍历（代码）：</h6> 
<p><img src="https://images2.imgbox.com/8f/c1/FcvsFEIK_o.png" alt="img"></p> 
<h6><a id="_1732"></a>中序遍历（代码）：</h6> 
<p><img src="https://images2.imgbox.com/8b/88/AZbrfRq3_o.png" alt="img"></p> 
<h6><a id="_1736"></a>后序遍历（代码）：</h6> 
<p><img src="https://images2.imgbox.com/46/5b/To50PIgw_o.png" alt="img"></p> 
<h6><a id="_1740"></a>二叉树遍历总结：</h6> 
<ul><li> <p>空间复杂度为O(h)，h为树的高度</p> </li><li> <p>每个结点都会被路过3次</p> </li></ul> 
<h6><a id="_1746"></a>求树的深度：</h6> 
<p><img src="https://images2.imgbox.com/bc/0a/kFCqK5NF_o.png" alt="img"></p> 
<ul><li> <p>是后序遍历的变种</p> </li><li> <p>先后访问左右儿子，得出对应深度返回左右儿子深度更高的那个就是树的深度</p> </li></ul> 
<h5><a id="_1754"></a>二叉树的层序遍历</h5> 
<h6><a id="_1756"></a>层序遍历：</h6> 
<p>基于树的层次特性确定的次序规则</p> 
<h6><a id="_1760"></a>算法思想：</h6> 
<ul><li> <p>初始化一个辅助队列</p> </li><li> <p>根结点入队</p> </li><li> <p>若队列非空，则队头结点出队，访问该结点，并将其左、右孩子插入队尾（如果有的话）</p> </li><li> <p>重复第三步直至队列为空</p> </li></ul> 
<h6><a id="_1770"></a>代码实现：</h6> 
<p><img src="https://images2.imgbox.com/6a/bd/solOYjHj_o.png" alt="img"></p> 
<h5><a id="_1774"></a>由遍历序列构造二叉树</h5> 
<h6><a id="_1776"></a>结论：</h6> 
<ul><li> <p>一个前/中/后/层序遍历序列可能对应多种二叉树形态</p> </li><li> <p>只有至少同时拥有两种遍历序列才能确定二叉树的形态</p> </li><li> <p>结论：前序、后序、层序序列的两两组合无法唯一确定一科二叉树</p> </li></ul> 
<h6><a id="_1784"></a>通过两种遍历序列确定二叉树：</h6> 
<p>前序+中序：</p> 
<p><img src="https://images2.imgbox.com/b4/7d/jg0QvXqj_o.png" alt="img"></p> 
<p>中序+后序：</p> 
<p><img src="https://images2.imgbox.com/ca/40/nFGMRQZY_o.png" alt="img"></p> 
<p>层序+中序：</p> 
<p><img src="https://images2.imgbox.com/39/66/EeUXFAUs_o.png" alt="img"></p> 
<h5><a id="_1798"></a>线索二叉树的概念</h5> 
<h6><a id="_1800"></a>中序遍历的问题：</h6> 
<ul><li> <p>如何找到指定结点p在q 中序遍历序列中的前驱？</p> </li><li> <p>如何找到p的中序后继？</p> </li><li> <p>能否从一个指定结点开始中序遍历？</p> </li><li> <p>完成上述需求的思路：</p> 
  <ul><li> <p>从根结点出发，重新进行一次中序遍历，指针q记录当前访问的结点，指针pre记录上一个被访问的结点</p> </li><li> <p>当q == p时，pre为前驱</p> </li><li> <p>当pre == p时，q为后继</p> </li></ul> </li><li> <p>缺点：找前驱、后继很不方便； 操作必须从根开始</p> </li></ul> 
<h6><a id="_1818"></a>中序线索二叉树：</h6> 
<p><img src="https://images2.imgbox.com/4c/4e/mEJxsc41_o.png" alt="img"></p> 
<h6><a id="_1822"></a>线索二叉树的存储结构：</h6> 
<p><img src="https://images2.imgbox.com/d9/af/HjCC6uWc_o.png" alt="img"></p> 
<p>先/中/后序线索二叉树同理</p> 
<h6><a id="_1828"></a>三种线索二叉树的对比：</h6> 
<p><img src="https://images2.imgbox.com/c0/aa/7T8ziC9B_o.png" alt="img"></p> 
<h5><a id="_1832"></a>二叉树的线索化</h5> 
<h6><a id="_1834"></a>通过头结点找到中序前驱：</h6> 
<p><img src="https://images2.imgbox.com/4f/db/1vv88oin_o.png" alt="img"></p> 
<h6><a id="_1838"></a>中序二叉树线索化：</h6> 
<p><img src="https://images2.imgbox.com/48/93/LAaC9j03_o.png" alt="img"></p> 
<p><img src="https://images2.imgbox.com/b8/94/P34majjB_o.png" alt="img"></p> 
<h6><a id="_1844"></a>先序二叉树线索化：</h6> 
<p><img src="https://images2.imgbox.com/43/ad/hazjHOPj_o.png" alt="img"></p> 
<p><img src="https://images2.imgbox.com/73/2d/FHFA8beV_o.png" alt="img"></p> 
<ul><li> <p>由于先序遍历先遍历根结点然后再遍历左结点，若左孩子为空，通过线索化后会指回前驱结点（他的根结点）</p> </li><li> <p>这时在此访问左孩子时候会又访问回根结点，因此需要增加一个判断来确定左孩子不是真正的左孩子而是线索化后的前驱结点</p> </li><li> <p>因此PreThread函数需要优化为：</p> </li></ul> 
<p><img src="https://images2.imgbox.com/1b/85/JbShrrh8_o.png" alt="img"></p> 
<h6><a id="_1858"></a>后序二叉树线索化：</h6> 
<p><img src="https://images2.imgbox.com/ba/97/Nlz3WAtt_o.png" alt="img"></p> 
<h5><a id="_1862"></a>在线索二叉树中找前驱后驱</h5> 
<h6><a id="_1864"></a>中序线索二叉树找中序前驱后继：</h6> 
<ul><li> <p>在中序线索二叉树中找到指定结点*p的中序后继next</p> 
  <ul><li> <p>若p-&gt;rtag == 1，则next = p-&gt;rchild</p> </li><li> <p>若p-&gt;rtag == 0，说明p必定有右孩子，next = （p的右子树中最左下的结点）</p> </li></ul> </li></ul> 
<p><img src="https://images2.imgbox.com/a9/72/UjRwWmBj_o.png" alt="img"></p> 
<ul><li> <p>在中序线索二叉树中找到指定结点*p的中序前驱pre</p> 
  <ul><li> <p>若p-&gt;ltag == 1，则pre = p-&gt;lchild</p> </li><li> <p>若p-&gt;ltag == 0，说明p必定有左孩子，pre = （p的左子树中最右下的结点）</p> </li></ul> </li></ul> 
<p><img src="https://images2.imgbox.com/42/1b/GCBMQsuj_o.png" alt="img"></p> 
<h6><a id="_1882"></a>先序线索二叉树找先序前驱后继：</h6> 
<ul><li> <p>在先序线索二叉树中找到指定结点*p的先序后继next</p> 
  <ul><li> <p>若p-&gt;rtag == 1，则next = p-&gt;rchild</p> </li><li> <p>若p-&gt;rtag == 0，说明p必定有右孩子</p> 
    <ul><li> <p>若p有左孩子，则先序后继为左孩子</p> </li><li> <p>若p没有左孩子，则先序后继为右孩子</p> </li></ul> </li></ul> </li><li> <p>在先序线索二叉树中找到指定结点*p的先序前驱pre</p> 
  <ul><li> <p>若p-&gt;ltag == 1，则pre = p-&gt;lchild</p> </li><li> <p>若p-&gt;ltag == 0，说明p必定有左孩子</p> 
    <ul><li> <p>先序遍历中，左右子树中的结点只可能是根的后继，不可能是前驱</p> </li><li> <p>方法1：用土办法从头开始先序遍历</p> </li><li> <p>方法2：可以改用三叉链表以找到父结点</p> </li></ul> </li></ul> </li></ul> 
<p><img src="https://images2.imgbox.com/e5/1b/sbujNcEE_o.png" alt="img"></p> 
<h6><a id="_1908"></a>后序线索二叉树找后序前驱后继：</h6> 
<ul><li> <p>在后序线索二叉树中找到指定结点*p的后序前驱pre</p> 
  <ul><li> <p>若p-&gt;ltag == 1，则pre = p-&gt;lchild</p> </li><li> <p>若p-&gt;ltag == 0，说明p必有左孩子</p> 
    <ul><li> <p>若p有右孩子，则后序前驱为右孩子</p> </li><li> <p>若p没有右孩子，则后序前驱为左孩子</p> </li></ul> </li></ul> </li><li> <p>在后序线索二叉树中找到指定结点*p的后序后继next</p> 
  <ul><li> <p>若p-&gt;rtag == 1，则next = p-&gt;rchild</p> </li><li> <p>若p-&gt;rtag == 0，说明p必定有右孩子</p> 
    <ul><li> <p>后序遍历中，左右子树中的结点只可能是根的前驱，不可能是后继</p> </li><li> <p>方法1：用土办法从头开始先序遍历</p> </li><li> <p>方法2：可以改用三叉链表以找到父结点</p> </li></ul> </li></ul> </li></ul> 
<p><img src="https://images2.imgbox.com/7a/d9/EAJ1BTv5_o.png" alt="img"></p> 
<h5><a id="_1934"></a>树的储存结构</h5> 
<h6><a id="_1936"></a>双亲表示法（顺序存储）：</h6> 
<ul><li> <p>每个结点中保存指向双亲的“指针”，data，parrent</p> </li><li> <p>根结点固定存储在0，-1表示没有双亲</p> </li></ul> 
<p><img src="https://images2.imgbox.com/c3/c8/9h0214xR_o.png" alt="img"></p> 
<ul><li> <p>新增数据元素，无需按逻辑上的次序存储，只需说明新增元素的data，parrent即可</p> </li><li> <p>删除数据元素</p> 
  <ul><li> <p>方案1：把要删除的数据元素data设为空，parent设为-1</p> </li><li> <p>方案2：将数组尾部的数据元素覆盖要删除的数据元素</p> </li></ul> </li><li> <p>查询数据元素</p> 
  <ul><li> <p>优点：查指定结点的双亲很方便</p> </li><li> <p>缺点：查指定结点的孩子只能从头遍历</p> </li></ul> </li></ul> 
<h6><a id="_1958"></a>孩子表示法（顺序+链式存储）：</h6> 
<p><img src="https://images2.imgbox.com/a2/3a/VywTvOhl_o.png" alt="img"></p> 
<h6><a id="_1962"></a>孩子兄弟表示法（链式存储）：</h6> 
<p><img src="https://images2.imgbox.com/aa/0c/ETH3ctab_o.png" alt="img"></p> 
<p>规则：</p> 
<ul><li> <p>左指针指向第一个孩子</p> </li><li> <p>右指针指向自己的第一个兄弟</p> </li></ul> 
<h6><a id="_1972"></a>森林和二叉树的转换：</h6> 
<ul><li> <p>本质：用二叉链表存储森林</p> </li><li> <p>规则：</p> 
  <ul><li> <p>各个树的根结点视为兄弟关系</p> </li><li> <p>左指针指向第一个孩子</p> </li><li> <p>右指针指向自己的第一个兄弟</p> </li></ul> </li></ul> 
<h5><a id="_1984"></a>树和森林的遍历</h5> 
<h6><a id="_1986"></a>树的先根遍历：</h6> 
<ul><li> <p>先根遍历：若树非空，先访问根结点，再依次对每棵子树进行先根遍历。</p> </li><li> <p>树的先根遍历序列与这棵树相应二叉树的先序序列相同。</p> </li></ul> 
<p><img src="https://images2.imgbox.com/cd/1d/mSjDuKWD_o.png" alt="img"></p> 
<h6><a id="_1994"></a>树的后根遍历：</h6> 
<ul><li> <p>后根遍历：若树非空，先依次对每棵子树进行后根遍历，最后再访问根结点</p> </li><li> <p>树的后根遍历序列与这棵树相应二叉树的中序序列相同</p> </li><li> <p>也被称为深度优先遍历</p> </li></ul> 
<p><img src="https://images2.imgbox.com/39/6d/XV1HdEsE_o.png" alt="img"></p> 
<h6><a id="_2004"></a>树的层次遍历：</h6> 
<ul><li> <p>用队列实现，又被称为广度优先遍历</p> </li><li> <p>步骤</p> 
  <ul><li> <p>若树非空，则根结点入队</p> </li><li> <p>若队列非空，队头元素出队并访问，同时将该元素的孩子依次入队</p> </li><li> <p>重复第二步直到队列为空</p> </li></ul> </li></ul> 
<h6><a id="_2016"></a>森林的先序遍历：</h6> 
<ul><li> <p>若森林为非空，则按如下规则进行遍历：</p> 
  <ul><li> <p>访问森林中第一棵树的根结点。</p> </li><li> <p>先序遍历第一棵树中根结点的子树森林。</p> </li><li> <p>先序遍历除去第一棵树之后剩余的树构成的森林。</p> </li></ul> </li><li> <p>效果等同于依次对各个树进行先根遍历</p> </li><li> <p>用孩子兄弟表示法转换为二叉树，效果等同于依次对二叉树的先序遍历</p> </li></ul> 
<h6><a id="_2030"></a>森林的中序遍历：</h6> 
<ul><li> <p>若森林为非空，则按如下规则进行遍历：</p> 
  <ul><li> <p>中序遍历森林中第一棵树的根结点的子树森林。</p> </li><li> <p>访问第一棵树的根结点。</p> </li><li> <p>中序遍历除去第一棵树之后剩余的树构成的森林。</p> </li></ul> </li><li> <p>效果等同于依次对各个树进行后根遍历</p> </li><li> <p>用孩子兄弟表示法转换为二叉树，效果等同于依次对二叉树的中序遍历</p> </li></ul> 
<h5><a id="BST_2044"></a>二叉排序树（BST）</h5> 
<h6><a id="_2046"></a>定义：</h6> 
<ul><li> <p>二叉排序树，又称二叉查找树（BST，Binary Search Tree）</p> </li><li> <p>一棵二叉树或者是空二叉树，或者是具有如下性质的二叉树：</p> 
  <ul><li> <p>左子树上所有结点的关键字均小于根结点的关键字</p> </li><li> <p>右子树上所有结点的关键字均大于根结点的关键字</p> </li><li> <p>左子树和右子树又各是一棵二叉排序树</p> </li></ul> </li><li> <p>即左子树结点值&lt; 根结点值&lt; 右子树结点值</p> </li><li> <p>进行中序遍历，可以得到一个递增的有序序列</p> </li><li> <p>二叉排序树可用于元素的有序组织、搜索</p> </li></ul> 
<h6><a id="BST_2064"></a>BST的查找：</h6> 
<ul><li> <p>若树非空，目标值与根结点的值比较：</p> 
  <ul><li> <p>若相等，则查找成功</p> </li><li> <p>若小于根结点，则在左子树上查找，否则在右子树上查找。</p> </li><li> <p>查找成功，返回结点指针；</p> </li><li> <p>查找失败返回NULL</p> </li></ul> </li><li> <p>递归实现的最坏空间复杂度为O(h),普通实现的最坏空间复杂度为O(1)</p> </li></ul> 
<p><img src="https://images2.imgbox.com/e0/20/NGAjLRKD_o.png" alt="img"></p> 
<p><img src="https://images2.imgbox.com/4f/3f/gvIteVLT_o.png" alt="img"></p> 
<p><img src="https://images2.imgbox.com/47/8c/217r4X5K_o.png" alt="img"></p> 
<h6><a id="BST_2084"></a>BST的插入：</h6> 
<ul><li> <p>若原二叉排序树为空，则直接插入结点；</p> </li><li> <p>否则，若关键字k小于根结点值，则插入到左子树，若关键字k大于根结点值，则插入到右子树</p> </li><li> <p>递归实现的最坏空间复杂度为O(h)</p> </li></ul> 
<p><img src="https://images2.imgbox.com/b7/1b/ywNj4Zcn_o.png" alt="img"></p> 
<h6><a id="_2094"></a>二叉排序树的构造：</h6> 
<p><img src="https://images2.imgbox.com/fb/83/X7AIgtCz_o.png" alt="img"></p> 
<p>注意：不同的关键字序列可能得到同款二叉排序树，也可能得到不同款二叉排序树</p> 
<h6><a id="_2100"></a>二叉排序树的删除：</h6> 
<ul><li> <p>先搜索找到目标结点：</p> 
  <ul><li> <p>若被删除结点z是叶结点，则直接删除，不会破坏二叉排序树的性质。</p> </li><li> <p>若结点z只有一棵左子树或右子树，则让z的子树成为z父结点的子树，替代z的位置。</p> </li><li> <p>若结点z有左、右两棵子树，则令z的直接后继（或直接前驱）替代z，然后从二叉排序树中删去这个直接后继（或直接前驱），这样就转换成了第一或第二种情况。</p> 
    <ul><li> <p>z的后继：z的右子树中最左下结点，是右子树最小的结点（该结点一定没有左子树）</p> </li><li> <p>z的前驱：z的左子树中最右下结点，是左子树中最大的结点（该结点一定没有右子树）</p> </li></ul> </li></ul> </li></ul> 
<h6><a id="_2114"></a>查找效率分析：</h6> 
<ul><li> <p>查找长度：在查找运算中，需要对比关键字的次数称为查找长度，反映了查找操作时间复杂度</p> </li><li> <p>查找成功的平均查找长度ASL（Average Search Length）：（各层（层数*层结点个数）相加）/总结点个数</p> </li><li> <p>最坏情况：每个结点只有一个分支，树高h=结点数n。平均查找长度=O(n)</p> </li><li> <p>最好情况：n个结点的二叉树最小高度为(log2n)+ 1。平均查找长度= O(log2n)</p> </li></ul> 
<h5><a id="AVL_2124"></a>平衡二叉树（AVL）</h5> 
<h6><a id="_2126"></a>定义：</h6> 
<ul><li> <p>平衡二叉树（Balanced Binary Tree），简称平衡树（AVL树）——树上任一结点的左子树和右子树的高度之差不超过1</p> </li><li> <p>结点的平衡因子=左子树高-右子树高</p> </li><li> <p>平衡二叉树结点的平衡因子的值只可能是−1、0或1</p> </li><li> <p>只要有任一结点的平衡因子绝对值大于1，就不是平衡二叉树</p> </li></ul> 
<h6><a id="_2136"></a>平衡二叉树的插入：</h6> 
<ul><li> <p>在二叉排序树中插入新结点后，如何保持平衡？</p> 
  <ul><li> <p>查找路径上的所有结点都有可能受到影响</p> </li><li> <p>从插入点往回找到第一个不平衡结点，调整以该结点为根的子树</p> </li><li> <p>每次调整的对象都是“最小不平衡子树”</p> </li><li> <p>在插入操作中，只要将最小不平衡子树调整平衡，则其他祖先结点都会恢复平衡</p> </li><li> <p>插入操作导致“最小不平衡子树”高度+1，经过调整后高度恢复</p> </li></ul> </li><li> <p>调整最小不平衡子树</p> </li></ul> 
<p><img src="https://images2.imgbox.com/d8/e0/A9CnLKiw_o.png" alt="img"></p> 
<h6><a id="_2154"></a>调整最小不平衡子树：</h6> 
<ul><li> <p>只有假设所有子树的高度都是H才能保证出现最小不平衡子树恒定</p> </li><li> <p>目标：</p> 
  <ul><li> <p>恢复平衡</p> </li><li> <p>保持二叉排序树特性</p> </li></ul> </li><li> <p>二叉排序树的特性：左子树结点值&lt; 根结点值&lt; 右子树结点值</p> </li><li> <p>LL平衡旋转（右单旋转）</p> 
  <ul><li> <p>由于在结点A的左孩子（L）的左子树（L）上插入了新结点，A的平衡因子由1增至2，导致以A为根的子树失去平衡，需要一次向右的旋转操作</p> </li><li> <p>将A的左孩子B向右上旋转代替A成为根结点，将A结点向右下旋转成为B的右子树的根结点，而B的原右子树则作为A结点的左子树</p> </li></ul> </li></ul> 
<p><img src="https://images2.imgbox.com/9b/69/FyfkNwcK_o.png" alt="img"></p> 
<ul><li> <p>RR平衡旋转（左单旋转）</p> 
  <ul><li> <p>由于在结点A的右孩子（R）的右子树（R）上插入了新结点，A的平衡因子由-1减至-2，导致以A为根的子树失去平衡，需要一次向左的旋转操作</p> </li><li> <p>将A的右孩子B向左上旋转代替A成为根结点，将A结点向左下旋转成为B的左子树的根结点，而B的原左子树则作为A结点的右子树</p> </li></ul> </li></ul> 
<p><img src="https://images2.imgbox.com/82/28/JUix03Ca_o.png" alt="img"></p> 
<ul><li>右旋和左旋的代码实现思路</li></ul> 
<p><img src="https://images2.imgbox.com/21/86/rjpijTGW_o.png" alt="img"></p> 
<ul><li> <p>LR平衡旋转（先左后右双旋转）</p> 
  <ul><li> <p>由于在A的左孩子（L）的右子树（R）上插入新结点，A的平衡因子由1增至2，导致以A为根的子树失去平衡，需要进行两次旋转操作，先左旋转后右旋转</p> </li><li> <p>先将A结点的左孩子B的右子树的根结点C向左上旋转提升到B结点的位置，然后再把该C结点向右上旋转提升到A结点的位置</p> </li></ul> </li></ul> 
<p><img src="https://images2.imgbox.com/ee/1e/0irrkj66_o.png" alt="img"></p> 
<p><img src="https://images2.imgbox.com/27/07/Dc971V7c_o.png" alt="img"></p> 
<ul><li> <p>RL平衡旋转（先右后左双旋转）</p> 
  <ul><li> <p>由于在A的右孩子（R）的左子树（L）上插入新结点，A的平衡因子由-1减至-2，导致以A为根的子树失去平衡，需要进行两次旋转操作，先右旋转后左旋转</p> </li><li> <p>先将A结点的右孩子B的左子树的根结点C向右上旋转提升到B结点的位置，然后再把该C结点向左上旋转提升到A结点的位置</p> </li></ul> </li></ul> 
<p><img src="https://images2.imgbox.com/f4/f0/pAURwx8i_o.png" alt="img"></p> 
<p><img src="https://images2.imgbox.com/f8/3f/DO0haKTH_o.png" alt="img"></p> 
<h6><a id="_2206"></a>查找效率分析：</h6> 
<ul><li> <p>若树高为h，则最坏情况下，查找一个关键字最多需要对比h次，即查找操作的时间复杂度不可能超过O(h)</p> </li><li> <p>平衡二叉树——树上任一结点的左子树和右子树的高度之差不超过1</p> </li><li> <p>假设以nh表示深度为h的平衡树中含有的最少结点数。</p> </li><li> <p>则有n0 = 0, n1 = 1, n2 = 2，并且有nh = n(h−1) + n(h−2) + 1</p> </li><li> <p>可以证明含有n个结点的平衡二叉树的最大深度为O(log2n) ，平衡二叉树的平均查找长度为O(log2n)</p> </li></ul> 
<h5><a id="_2218"></a>哈夫曼树</h5> 
<h6><a id="_2220"></a>带权路径长度：</h6> 
<ul><li> <p>结点的权：有某种现实含义的数值（如：表示结点的重要性等）</p> </li><li> <p>结点的带权路径长度：从树的根到该结点的路径长度（经过的边数）与该结点上权值的乘积</p> </li><li> <p>树的带权路径长度：树中所有叶结点的带权路径长度之和（WPL, Weighted Path Length）</p> </li></ul> 
<h6><a id="_2228"></a>哈夫曼树的定义：</h6> 
<p>在含有n个带权叶结点的二叉树中，其中带权路径长度（WPL）最小的二叉树称为哈夫曼树，也称最优二叉树</p> 
<p><img src="https://images2.imgbox.com/fa/69/KkbuQcpn_o.png" alt="img"></p> 
<h6><a id="_2234"></a>哈夫曼树的构造：</h6> 
<ul><li> <p>给定n个权值分别为w1, w2,…, wn的结点，构造哈夫曼树的算法描述如下：</p> 
  <ul><li> <p>将这n个结点分别作为n棵仅含一个结点的二叉树，构成森林F。</p> </li><li> <p>构造一个新结点，从F中选取两棵根结点权值最小的树作为新结点的左、右子树，并且将新结点的权值置为左、右子树上根结点的权值之和。</p> </li><li> <p>从F中删除刚才选出的两棵树，同时将新得到的树加入F中。</p> </li><li> <p>重复步骤2和3，直至F中只剩下一棵树为止。</p> </li></ul> </li><li> <p>每个初始结点最终都成为叶结点，且权值越小的结点到根结点的路径长度越大</p> </li><li> <p>哈夫曼树的结点总数为2n − 1</p> </li><li> <p>哈夫曼树中不存在度为1的结点。</p> </li><li> <p>哈夫曼树并不唯一，但WPL必然相同且为最优</p> </li></ul> 
<p><img src="https://images2.imgbox.com/a9/1a/7iSglTpz_o.png" alt="img"></p> 
<h6><a id="_2256"></a>哈夫曼编码：</h6> 
<ul><li> <p>固定长度编码：每个字符用相等长度的二进制位表示</p> </li><li> <p>可变长度编码：允许对不同字符用不等长的二进制位表示</p> </li><li> <p>若没有一个编码是另一个编码的前缀，则称这样的编码为前缀编码，如果没有前缀编码容易出现歧义</p> </li><li> <p>由哈夫曼树得到哈夫曼编码：字符集中的每个字符作为一个叶子结点，各个字符出现的频度作为结点的权值，根据之前介绍的方法构造哈夫曼树</p> </li></ul> 
<h5><a id="_2266"></a>并查集</h5> 
<h6><a id="_2268"></a>定义：</h6> 
<p>并查集（Disjoint Set）是逻辑结构集合的一种具体实现，只进行“并”和“查”两种基本操作</p> 
<h6><a id="_2272"></a>并查集的基本操作：</h6> 
<ul><li> <p>Find：查操作，确定一个指定元素所属集合</p> </li><li> <p>Union：并操作，将两个不相交的集合合并为一个</p> </li></ul> 
<h6><a id="_2278"></a>初始化：</h6> 
<p><img src="https://images2.imgbox.com/94/b0/H7xvu7G9_o.png" alt="img"></p> 
<p>S[]实际上就是树的双亲表示法，里面的值就是自己对应根结点的下标</p> 
<h6><a id="_2284"></a>并、查：</h6> 
<p><img src="https://images2.imgbox.com/d4/74/Cgi7FZJQ_o.png" alt="img"></p> 
<h6><a id="_2288"></a>时间复杂度分析：</h6> 
<ul><li> <p>Find操作最坏时间复杂度O(n)</p> </li><li> <p>Union操作时间复杂度O(1)</p> </li></ul> 
<h6><a id="Union_2294"></a>Union操作的优化：</h6> 
<ul><li> <p>在每次Union操作构建树的时候，尽量让树不长高</p> </li><li> <p>用根结点的绝对值表示树的结点总数（根结点从-1改成-（树的总结点））</p> </li><li> <p>Union操纵，让小树合并到大树</p> </li><li> <p>该方法构造的树高不超过[log2n]+1</p> </li><li> <p>Find最坏时间复杂度变为O(log2n)</p> </li></ul> 
<p><img src="https://images2.imgbox.com/72/b5/bZYxS9Tj_o.png" alt="img"></p> 
<h5><a id="_2308"></a>并查集的压缩路径</h5> 
<ul><li> <p>核心想法就是让树越来越“矮”</p> </li><li> <p>Find操作先找到根结点，再将查找路径上所有结点都挂到根结点下</p> </li></ul> 
<p><img src="https://images2.imgbox.com/b7/a0/f7OwU4JQ_o.png" alt="img"></p> 
<ul><li> <p>这样的操纵可以让树的告诉不超过O(α(n))</p> </li><li> <p>O(α(n))是一个增长很缓慢的函数，对于常见的n值，O(α(n))通常&lt;=4</p> </li><li> <p>因此优化后的并查集Find、Union操作时间开销都很低</p> </li></ul> 
<h4><a id="_2322"></a>图</h4> 
<h5><a id="_2324"></a>图的基本概念</h5> 
<h6><a id="_2326"></a>定义：</h6> 
<ul><li> <p>图G由顶点集V和边集E组成，记为G = (V, E)，其中V(G)表示图G中顶点的有限非空集；</p> </li><li> <p>E(G)表示图G中顶点之间的关系（边）集合。</p> </li><li> <p>若V = {v1, v2, … , vn}，则用|V|表示图G中顶点的个数，也称图G的阶，E = {(u, v) | u∈V, v∈V}，用|E|表示图G中边的条数。</p> </li><li> <p>注意：线性表可以是空表，树可以是空树，但图不可以是空，即V一定是非空集</p> </li></ul> 
<h6><a id="_2336"></a>无向图、有向图：</h6> 
<p>无向图：</p> 
<ul><li> <p>若E是无向边（简称$）的有限集合时，则图G为无向图。</p> </li><li> <p>边是顶点的无序对，记为(v, w)或(w, v)，因为(v, w) = (w, v)，其中v、w是顶点。可以说顶点w和顶点v互为邻接点。</p> </li><li> <p>边(v, w)依附于顶点w和v，或者说边(v, w)和顶点v、w相关联。</p> </li></ul> 
<p>有向图：</p> 
<ul><li> <p>若E是有向边（也称!）的有限集合时，则图G为有向图。</p> </li><li> <p>弧是顶点的有序对，记为&lt;v, w&gt;，其中v、w是顶点，v称为弧尾，w称为弧头，&lt;v, w&gt;称为从顶点v到顶点w的弧，也称v邻接到w，或w邻接自v。</p> </li><li> <p>注意：&lt;v, w&gt; ≠ &lt;w, v&gt;</p> </li></ul> 
<h6><a id="_2354"></a>简单图、多重图：</h6> 
<p>数据结构课程只探讨“简单图”</p> 
<p>简单图：</p> 
<ul><li> <p>不存在重复边</p> </li><li> <p>不存在顶点到自身的边</p> </li></ul> 
<p>多重图：</p> 
<ul><li>图G中某两个结点之间的边数多于一条又允许顶点通过同一条边和自己关联，则G为多重图</li></ul> 
<h6><a id="_2368"></a>顶点的度、入度、出度：</h6> 
<ul><li> <p>对于无向图：</p> 
  <ul><li> <p>顶点v的度是指依附于该顶点的边的条数，记为TD(v)。</p> </li><li> <p>在具有n个顶点、e条边的无向图中，无向图的全部顶点的度的和等于边数的2倍</p> </li></ul> </li><li> <p>对于有向图：</p> 
  <ul><li> <p>入度是以顶点v为终点的有向边的数目，记为ID(v)；</p> </li><li> <p>出度是以顶点v为起点的有向边的数目，记为OD(v)。</p> </li><li> <p>顶点v的度等于其入度和出度之和，即TD(v) = ID(v) + OD(v)。</p> </li></ul> </li></ul> 
<h6><a id="_2384"></a>顶点-顶点的关系描述：</h6> 
<ul><li> <p>路径：顶点vp到顶点vq之间的一条路径是指顶点序列，</p> </li><li> <p>回路：第一个顶点和最后一个顶点相同的路径称为回路或环</p> </li><li> <p>简单路径：在路径序列中，顶点不重复出现的路径称为简单路径。</p> </li><li> <p>简单回路：除第一个顶点和最后一个顶点外，其余顶点不重复出现的回路称为简单回路。</p> </li><li> <p>路径长度：路径上边的数目</p> </li><li> <p>点到点的距离：从顶点u出发到顶点v的最短路径若存在，则此路径的长度称为从u到v的距离。若从u到v根本不存在路径，则记该距离为无穷（∞）。</p> </li><li> <p>无向图中，若从顶点v到顶点w有路径存在，则称v和w是连通的</p> </li><li> <p>有向图中，若从顶点v到顶点w和从顶点w到顶点v之间都有路径，则称这两个顶点是强连通的</p> </li></ul> 
<h6><a id="_2402"></a>连通图、强连通图：</h6> 
<ul><li> <p>若图G中任意两个顶点都是连通的，则称图G为连通图，否则称为非连通图。</p> </li><li> <p>对于n个顶点的无向图G，</p> 
  <ul><li> <p>若G是连通图，则最少有n-1条边</p> </li><li> <p>若G是非连通图，则最多可能有</p> </li></ul> </li></ul> 
<p><img src="https://images2.imgbox.com/01/b1/ZztEnTMP_o.png" alt="img"></p> 
<p>​ 条边</p> 
<ul><li> <p>若图中任何一对顶点都是强连通的，则称此图为强连通图。</p> </li><li> <p>对于n个顶点的有向图G，</p> </li><li> <p>若G是强连通图，则最少有n条边（形成回路）</p> </li></ul> 
<h6><a id="_2422"></a>研究图的局部——子图：</h6> 
<ul><li> <p>设有两个图G = (V, E)和G¢ = (V’, E’)，若V¢是V的子集，且E’是E的子集，则称G’是G的子图</p> </li><li> <p>若有满足V(G’) = V(G)的子图G’，则称其为G的生成子图</p> </li><li> <p>注意：并非任意挑几个点、几条边都能构成子图</p> </li></ul> 
<h6><a id="_2430"></a>连通分量：</h6> 
<ul><li> <p>无向图中的极大联通子图称为连通分量</p> </li><li> <p>子图必须连通，且包含尽可能多的顶点和边</p> </li></ul> 
<h6><a id="_2436"></a>强连通分量：</h6> 
<ul><li> <p>有向图中的极大强联通子图成为有向图的强连通分量</p> </li><li> <p>子图必须强连通，同时保留尽可能多的边</p> </li></ul> 
<h6><a id="_2442"></a>生成树：</h6> 
<ul><li> <p>连通图的生成树是包含图中全部顶点的一个极小连通子图</p> </li><li> <p>边尽可能的少，但要保持连通</p> </li><li> <p>若图中顶点数为n，则它的生成树含有n-1条边。对生成树而言，若砍去它的一条边，则会变成非连通图，若加上一条边则会形成一个回路。</p> </li></ul> 
<h6><a id="_2450"></a>生成森林：</h6> 
<p>在非连通图中，连通分量的生成树构成了非连通图的生成森林。</p> 
<h6><a id="_2454"></a>边的权、带权图/网：</h6> 
<ul><li> <p>边的权：在一个图中，每条边都可以标上具有某种含义的数值，该数值称为该边的权值。</p> </li><li> <p>带权图/网——边上带有权值的图称为带权图，也称网。</p> </li><li> <p>带权路径长度——当图是带权图时，一条路径上所有边的权值之和，称为该路径的带权路径长度</p> </li></ul> 
<h6><a id="_2462"></a>几种特殊形态的图：</h6> 
<ul><li> <p>无向完全图：无向图中任意两个顶点之间都存在边</p> </li><li> <p>有向完全图：有向图中任意两个顶点之间都存在方向相反的两条弧</p> </li><li> <p>边数很少的图称为稀疏图</p> </li><li> <p>反之称为稠密图</p> </li><li> <p>没有绝对的界限，一般来说|E| &lt; |V|log|V|时，可以将G视为稀疏图</p> </li><li> <p>树：不存在回路，且连通的无向图</p> </li><li> <p>有向树：一个顶点的入度为0、其余顶点的入度均为1的有向图，称为有向树</p> 
  <ul><li> <p>n个顶点的树，必有n-1条边。</p> </li><li> <p>n个顶点的图，若|E|&gt;n-1，则一定有回路</p> </li></ul> </li></ul> 
<h5><a id="_2482"></a>邻接矩阵法</h5> 
<h6><a id="_2484"></a>定义：</h6> 
<p><img src="https://images2.imgbox.com/84/f5/MNDHO0K1_o.png" alt="img"></p> 
<p><img src="https://images2.imgbox.com/d2/7a/6gwpMMbm_o.png" alt="img"></p> 
<ul><li> <p>无向图：</p> 
  <ul><li>第i个结点的度=第i行（或第i列）的非零元素个数</li></ul> </li><li> <p>有向图：</p> 
  <ul><li> <p>第i个结点的出度=第i行的非零元素个数</p> </li><li> <p>第i个结点的入度=第i列的非零元素个数</p> </li><li> <p>第i个结点的度=第i行、第i列的非零元素个数之和</p> </li></ul> </li><li> <p>邻接矩阵法求顶点的度/出度/入度的时间复杂度为O(|V|)</p> </li></ul> 
<h6><a id="_2504"></a>邻接矩阵法存储带权图（网）：</h6> 
<p><img src="https://images2.imgbox.com/fb/3d/1DNtI5mC_o.png" alt="img"></p> 
<h6><a id="_2508"></a>邻接矩阵法的性能分析：</h6> 
<ul><li> <p>空间复杂度：O(|V|^2) ——只和顶点数相关，和实际的边数无关</p> </li><li> <p>适合用于存储稠密图</p> </li><li> <p>无向图的邻接矩阵是对称矩阵，可以压缩存储（只存储上三角区/下三角区）</p> </li></ul> 
<h6><a id="_2516"></a>邻接矩阵法的性质：</h6> 
<p><img src="https://images2.imgbox.com/9e/98/b9RiFfZ3_o.png" alt="img"></p> 
<h6><a id="_2520"></a>邻接表法</h6> 
<h6><a id="_2522"></a>为什么要使用邻接表：</h6> 
<ul><li> <p>邻接矩阵是使用数组实现的顺序存储，空间复杂度高，不适合存储稀疏图</p> </li><li> <p>邻接表是顺序+链式存储</p> </li></ul> 
<h6><a id="_2528"></a>定义：</h6> 
<p><img src="https://images2.imgbox.com/4e/09/Mxb44eeA_o.png" alt="img"></p> 
<ul><li> <p>其实这和树的孩子表示法是类似的，孩子表示法：顺序存储各个结点，每个结点中保存孩子链表头指针</p> </li><li> <p>边结点的数量是2|E|，整体空间复杂度为O(|V| + 2|E|)</p> </li><li> <p>边结点的数量是|E|，整体空间复杂度为O(|V| + |E|)</p> </li><li> <p>只要确定了顶点编号，图的邻接矩阵表示方式唯一，图的邻接表表示方式并不唯一</p> </li></ul> 
<h6><a id="_2540"></a>邻接矩阵和邻接表的对比：</h6> 
<p><img src="https://images2.imgbox.com/cd/6e/JAFDr3TB_o.png" alt="img"></p> 
<h5><a id="_2544"></a>十字链表、邻接多重表</h5> 
<h6><a id="_2546"></a>关系：</h6> 
<ul><li> <p>十字链表储存有向图</p> </li><li> <p>邻接多重表储存无向图</p> </li></ul> 
<h6><a id="_2552"></a>十字链表存储有向图：</h6> 
<p><img src="https://images2.imgbox.com/4a/83/Us9LSDJO_o.png" alt="img"></p> 
<ul><li> <p>空间复杂度：O(|V|+|E|)</p> </li><li> <p>如何找到指定顶点的所有出边？顺着绿色线路找</p> </li><li> <p>如何找到指定顶点的所有入边？顺着橙色线路找</p> </li></ul> 
<h6><a id="_2562"></a>邻接矩阵、邻接表存储无向图：</h6> 
<ul><li> <p>邻接表每条边对应两份冗余信息，删除顶点、删除边等操作时间复杂度高</p> </li><li> <p>临接矩阵空间复杂度高O(|V|2)</p> </li></ul> 
<h6><a id="_2568"></a>临接多重表储存无向图：</h6> 
<p><img src="https://images2.imgbox.com/d5/db/lZ0yuB4A_o.png" alt="img"></p> 
<ul><li> <p>空间复杂度：O(|V|+|E|)</p> </li><li> <p>删除边、删除结点等操作很方便，只需要让各指针指向下一个对应的指向即可</p> </li></ul> 
<h6><a id="_2576"></a>总结：</h6> 
<p><img src="https://images2.imgbox.com/f6/c9/nmjDi018_o.png" alt="img"></p> 
<h5><a id="_2580"></a>图的基本操作</h5> 
<ul><li> <p>Adjacent(G,x,y)：判断图G是否存在边&lt;x, y&gt;或(x, y)。</p> </li><li> <p>Neighbors(G,x)：列出图G中与结点x邻接的边。</p> </li><li> <p>InsertVertex(G,x)：在图G中插入顶点x。</p> </li><li> <p>DeleteVertex(G,x)：从图G中删除顶点x。</p> </li><li> <p>AddEdge(G,x,y)：若无向边(x, y)或有向边&lt;x, y&gt;不存在，则向图G中添加该边。</p> </li><li> <p>RemoveEdge(G,x,y)：若无向边(x, y)或有向边&lt;x, y&gt;存在，则从图G中删除该边。</p> </li><li> <p>FirstNeighbor(G,x)：求图G中顶点x的第一个邻接点，若有则返回顶点号。若x没有邻接点或图中不存在x，则返回-1。</p> </li><li> <p>NextNeighbor(G,x,y)：假设图G中顶点y是顶点x的一个邻接点，返回除y之外顶点x的下一个邻接点的顶点号，若y是x的最后一个邻接点，则返回-1。</p> </li><li> <p>Get_edge_value(G,x,y)：获取图G中边(x, y)或&lt;x, y&gt;对应的权值。</p> </li><li> <p>Set_edge_value(G,x,y,v)：设置图G中边(x, y)或&lt;x, y&gt;对应的权值为v。</p> </li><li> <p>注意：上面的操作都只针对邻接矩阵和邻接表</p> </li></ul> 
<h5><a id="BFS_2604"></a>图的广度优先遍历（BFS）</h5> 
<h6><a id="_2606"></a>树和图的广度优先遍历：</h6> 
<ul><li> <p>树的广度优先遍历：通过根结点，可以找到下一层的结点2，3，4.通过234又可以找到再下一层的结点5678</p> 
  <ul><li> <p>若树非空，则根结点入队</p> </li><li> <p>若队列非空，队头元素出队并访问，同时将该元素的孩字依次入队</p> </li><li> <p>重复第二步直到队列为空</p> </li></ul> </li><li> <p>图的广度优先遍历类似于树的广度优先遍历（层序遍历）</p> </li><li> <p>区别：</p> 
  <ul><li> <p>树不存在“回路”，搜索相邻的结点时，不可能搜到已经访问过的结点</p> </li><li> <p>图搜索相邻的顶点时，有可能搜到已经访问过的顶点</p> </li></ul> </li></ul> 
<h6><a id="_2624"></a>代码实现：</h6> 
<ul><li> <p>找到与一个顶点相邻的所有顶点</p> 
  <ul><li> <p>FirstNeighbor(G,x)：求图G中顶点x的第一个邻接点，若有则返回顶点号。若x没有邻接点或图中不存在x，则返回-1。</p> </li><li> <p>NextNeighbor(G,x,y)：假设图G中顶点y是顶点x的一个邻接点，返回除y之外顶点x的下一个邻接点的顶点号，若y是x的最后一个邻接点，则返回-1。</p> </li><li> <p>使用上面两个基本操作</p> </li></ul> </li><li> <p>标记哪些顶点被访问过</p> 
  <ul><li> <p><img src="https://images2.imgbox.com/99/98/s0NCIGGm_o.png" alt="img"></p> </li><li> <p>都初始化为false</p> </li></ul> </li><li> <p>需要一个辅助队列</p> </li></ul> 
<p><img src="https://images2.imgbox.com/88/9b/zUvx2G7o_o.png" alt="img"></p> 
<p><img src="https://images2.imgbox.com/b3/06/etLSNuHl_o.png" alt="img"></p> 
<h6><a id="_2646"></a>遍历序列的可变性：</h6> 
<ul><li> <p>同一个图的邻接矩阵表示方式唯一，因此广度优先遍历序列唯一</p> </li><li> <p>同一个图邻接表表示方式不唯一，因此广度优先遍历序列不唯一</p> </li></ul> 
<h6><a id="_2652"></a>算法存在的问题和解决方案：</h6> 
<p>如果是非连通图，则无法遍历完所有结点</p> 
<p><img src="https://images2.imgbox.com/98/2c/9tnlwYNY_o.png" alt="img"></p> 
<ul><li> <p>空间复杂度：最坏情况，辅助队列大小为 O(|V|)</p> </li><li> <p>邻接矩阵存储的图：</p> 
  <ul><li> <p>访问 |V| 个顶点需要O(|V|)的时间</p> </li><li> <p>查找每个顶点的邻接点都需要O(|V|)的时间，而总共有|V|个顶点</p> </li><li> <p>时间复杂度= O(|V|^2)</p> </li></ul> </li><li> <p>邻接表存储的图：</p> 
  <ul><li> <p>访问 |V| 个顶点需要O(|V|)的时间</p> </li><li> <p>查找各个顶点的邻接点共需要O(|E|)的时间</p> </li><li> <p>时间复杂度= O(|V|+|E|)</p> </li></ul> </li></ul> 
<h6><a id="_2676"></a>广度优先生成树：</h6> 
<p><img src="https://images2.imgbox.com/b0/dd/WXygP8NV_o.png" alt="img"></p> 
<ul><li> <p>广度优先生成树由广度优先遍历过程确定。</p> </li><li> <p>由于邻接表的表示方式不唯一，因此基于邻接表的广度优先生成树也不唯一</p> </li><li> <p>对非连通图的广度优先遍历，可得到广度优先生成森林</p> </li></ul> 
<h5><a id="DFS_2686"></a>图的深度优先遍历（DFS）</h5> 
<h6><a id="_2688"></a>树和图的深度优先遍历：</h6> 
<ul><li> <p>树的深度优先遍历（先根、后根）：</p> 
  <ul><li> <p>从根结点出发，能往更深处走就尽量往深处走。</p> </li><li> <p>每当访问一个结点的时候，要检查是否还有与当前结点相邻的且没有被访问过的结点，如果有的话就往下一层钻。</p> </li></ul> </li><li> <p>图的深度优先遍历类似于树的先根遍历。</p> </li><li> <p>图的深度优先遍历是递归实现的，广度优先办理是队列实现的</p> </li></ul> 
<h6><a id="_2700"></a>图的深度优先遍历：</h6> 
<p><img src="https://images2.imgbox.com/be/73/q1W652Lg_o.png" alt="img"></p> 
<h6><a id="_2704"></a>算法存在的问题和解决方案：</h6> 
<p>如果是非连通图，则无法遍历完所有结点</p> 
<p><img src="https://images2.imgbox.com/1c/c1/A9gSrvCu_o.png" alt="img"></p> 
<h6><a id="_2710"></a>复杂度分析：</h6> 
<ul><li> <p>空间复杂度：</p> 
  <ul><li> <p>来自函数调用栈，最坏情况，递归深度为O(|V|)</p> </li><li> <p>最好情况，O(1)</p> </li></ul> </li><li> <p>时间复杂度：</p> 
  <ul><li> <p>时间复杂度=访问各结点所需时间+探索各条边所需时间</p> </li><li> <p>邻接矩阵存储的图：</p> 
    <ul><li> <p>访问 |V| 个顶点需要O(|V|)的时间</p> </li><li> <p>查找每个顶点的邻接点都需要O(|V|)的时间，而总共有|V|个顶点</p> </li><li> <p>时间复杂度= O(|V|^2)</p> </li></ul> </li></ul> </li><li> <p>邻接表存储的图：</p> 
  <ul><li> <p>访问 |V| 个顶点需要O(|V|)的时间</p> </li><li> <p>查找各个顶点的邻接点共需要O(|E|)的时间</p> </li><li> <p>时间复杂度= O(|V|+|E|)</p> </li></ul> </li></ul> 
<h6><a id="_2738"></a>深度优先序列：</h6> 
<p><img src="https://images2.imgbox.com/c4/28/qgB073pz_o.png" alt="img"></p> 
<ul><li> <p>和图的邻接表是一个原理，树中各个孩子结点在邻接表中出现的顺序是可变的</p> </li><li> <p>因此如果采用这种数据结构存储树，那么可能会有不同的遍历序列</p> </li></ul> 
<h6><a id="_2746"></a>深度优先生成树：</h6> 
<ul><li> <p>同一个图的邻接矩阵表示方式唯一，因此深度优先遍历序列唯一，深度优先生成树也唯一</p> </li><li> <p>同一个图邻接表表示方式不唯一，因此深度优先遍历序列不唯一，深度优先生成树也不唯一</p> </li><li> <p>对无向图进行BFS/DFS遍历</p> </li></ul> 
<h6><a id="_2754"></a>图的遍历与图的连通性：</h6> 
<ul><li> <p>调用BFS/DFS函数的次数=连通分量数</p> </li><li> <p>对于连通图，只需调用1次 BFS/DFS</p> </li><li> <p>对有向图进行BFS/DFS遍历</p> </li><li> <p>调用BFS/DFS函数的次数要具体问题具体分析，若起始顶点到其他各顶点都有路径，则只需调用1次BFS/DFS 函数</p> </li><li> <p>对于强连通图，从任一结点出发都只需调用1次 BFS/DFS</p> </li></ul> 
<h5><a id="_2766"></a>最小生成树</h5> 
<h6><a id="_2768"></a>生成树：</h6> 
<ul><li> <p>连通图的生成树是包含图中全部顶点的一个极小连通子图。</p> </li><li> <p>若图中顶点数为n，则它的生成树含有n-1条边。对生成树而言，若砍去它的一条边，则会变成非连通图，若加上一条边则会形成一个回路</p> </li></ul> 
<h6><a id="_2774"></a>最小生成树（最小代价树）：</h6> 
<ul><li> <p>对于一个带权连通无向图G = (V, E)，生成树不同，每棵树的权（即树中所有边上的权值之和）也可能不同</p> </li><li> <p>设R为G的所有生成树的集合，若T为R中边的权值之和最小的生成树，则T称为G的最小生成树（Minimum-Spanning-Tree, MST）</p> </li><li> <p>最小生成树可能有多个，但边的权值之和总是唯一且最小的</p> </li><li> <p>最小生成树的边数 = 顶点数 - 1</p> </li><li> <p>砍掉一条则不连通，增加一条边则会出现回路</p> </li><li> <p>如果一个连通图本身就是一棵树，则其最小生成树就是它本身</p> </li><li> <p>只有连通图才有生成树，非连通图只有生成森林</p> </li></ul> 
<h6><a id="Prim__2790"></a>Prim 算法（普里姆）：</h6> 
<p>算法思想：</p> 
<ul><li> <p>从某一个顶点开始构建生成树；</p> </li><li> <p>每次将代价最小的新顶点纳入生成树，直到所有顶点都纳入为止。</p> </li><li> <p>时间复杂度：O(|V|^2)，适合用于边稠密图</p> </li></ul> 
<p>数据结构：</p> 
<p><img src="https://images2.imgbox.com/17/fa/XWih96P7_o.png" alt="img"></p> 
<p>实现步骤：</p> 
<ul><li> <p>从V0开始，总共需要 n-1 轮处理</p> </li><li> <p>循环遍历所有个结点，找到lowCost最低的，且还没加入树的顶点，isJoin对应结点标记为true</p> </li><li> <p>再次循环遍历，更新还没加入的各个顶点的lowCost值</p> </li><li> <p>重复上面步骤，直到所有结点都加入树，生成的树即为最小生成树</p> </li></ul> 
<h6><a id="Kruskal__2814"></a>Kruskal 算法（克鲁斯卡尔）</h6> 
<h6><a id="_2816"></a>算法思想：</h6> 
<ul><li> <p>每次选择一条权值最小的边，使这条边的两头连通（原本已经连通的就不选）</p> </li><li> <p>直到所有结点都连通</p> </li><li> <p>时间复杂度：O( |E|log2|E| )，适合用于边稀疏图</p> </li></ul> 
<p>数据结构：</p> 
<p><img src="https://images2.imgbox.com/5c/18/7hjcigTI_o.png" alt="img"></p> 
<p>让各条边按照权值顺序排序</p> 
<p>实现步骤：</p> 
<ul><li> <p>共执行 e 轮，每轮判断两个顶点是否属于同一集合</p> </li><li> <p>检查第e条边的两个顶点是否连通（是否属于同一个集合）</p> </li><li> <p>若不联通则连起来</p> </li><li> <p>若联通则不操作</p> </li><li> <p>重复上面的步骤直到所有边都被遍历过</p> </li></ul> 
<h5><a id="BFS_2842"></a>最短路径问题之BFS算法</h5> 
<h6><a id="_2844"></a>介绍：</h6> 
<ul><li> <p>无权图可以视为一种特殊的带权图，只是每条边的权值都为1</p> </li><li> <p>BFS一般只适用于无权图的最短路径问题</p> </li></ul> 
<h6><a id="_2850"></a>代码实现：</h6> 
<p><img src="https://images2.imgbox.com/be/c2/j0rVVro6_o.png" alt="img"></p> 
<ul><li> <p>d数组表示u到各个结点的最短路径</p> </li><li> <p>path数组表示该结点回到u结点的最短前驱结点</p> </li><li> <p>由此生成的生成树同时也反应了起点到任意结点的距离</p> </li></ul> 
<h5><a id="Dijkstra_2860"></a>最短路径问题之Dijkstra算法</h5> 
<h6><a id="BFS_2862"></a>BFS算法的局限性：</h6> 
<ul><li> <p>带权路径长度——当图是带权图时，一条路径上所有边的权值之和，称为该路径的带权路径长度</p> </li><li> <p>BFS算法求单源最短路径只适用于无权图，或所有边的权值都相同的图</p> </li></ul> 
<h6><a id="_2868"></a>算法思想：</h6> 
<p><img src="https://images2.imgbox.com/1a/e4/sIGFS7wt_o.png" alt="img"></p> 
<ul><li> <p>初始：从V0开始，初始化三个数组信息</p> </li><li> <p>循环遍历所有结点，找到还没确定最短路径，且dist 最小的顶点Vi，令final[i]=ture。</p> </li><li> <p>检查所有邻接自 Vi 的顶点，若其 final 值为false，则更新 dist 和 path 信息</p> </li><li> <p>重复上述步骤，知道所有结点的final都标记为true</p> </li></ul> 
<p>代码实现思路：</p> 
<ul><li> <p>初始：</p> 
  <ul><li>若从V0开始，令 final[0]=ture; dist[0]=0; path[0]=-1。</li></ul> </li><li> <p>n-1轮处理</p> 
  <ul><li> <p>循环遍历所有顶点，找到还没确定最短路径，且dist 最小的顶点Vi，令final[i]=ture。</p> </li><li> <p>并检查所有邻接自Vi 的顶点，对于邻接自Vi 的顶点 Vj ，若 final[j]==false 且 dist[i]+arcsi &lt; dist[j]，则令 dist[j]=dist[i]+arcsi; path[j]=i。</p> </li><li> <p>注：arcsi表示Vi 到Vj 的弧的权值</p> </li></ul> </li><li> <p>时间复杂度：O(n2)即O(|V|2)</p> </li></ul> 
<h6><a id="_2896"></a>用于负权值带权图：</h6> 
<p>Dijkstra 算法不适用于有负权值的带权图</p> 
<h5><a id="Floyd_2900"></a>最短路径问题之Floyd算法</h5> 
<h6><a id="_2902"></a>算法思想：</h6> 
<ul><li> <p>Floyd算法：求出每一对顶点之间的最短路径</p> </li><li> <p>使用动态规划思想，将问题的求解分为多个阶段</p> </li><li> <p>对于n个顶点的图G，求任意一对顶点 Vi —&gt; Vj 之间的最短路径可分为如下几个阶段：</p> 
  <ul><li> <p>初始：不允许在其他顶点中转，最短路径是？</p> </li><li> <p>0：若允许在 V0 中转，最短路径是？</p> </li><li> <p>1：若允许在 V0、V1 中转，最短路径是？</p> </li><li> <p>2：若允许在 V0、V1、V2 中转，最短路径是？</p> </li><li> <p>…</p> </li><li> <p>n-1：若允许在 V0、V1、V2 …… Vn-1 中转，最短路径是？</p> </li></ul> </li></ul> 
<h6><a id="_2922"></a>实现步骤：</h6> 
<p><img src="https://images2.imgbox.com/f3/e6/nnqiLLwe_o.png" alt="img"></p> 
<p><img src="https://images2.imgbox.com/b1/ec/17fW9j9U_o.png" alt="img"></p> 
<p><img src="https://images2.imgbox.com/bd/4f/Ymwac9Km_o.png" alt="img"></p> 
<p><img src="https://images2.imgbox.com/56/64/L8wmSQwK_o.png" alt="img"></p> 
<p><img src="https://images2.imgbox.com/9d/3b/kEYV0Riy_o.png" alt="img"></p> 
<h6><a id="_2938"></a>代码实现：</h6> 
<p><img src="https://images2.imgbox.com/3e/3a/ioLztPgb_o.png" alt="img"></p> 
<h6><a id="_2942"></a>注意点：</h6> 
<ul><li> <p>Floyd算法可以用于负权图</p> </li><li> <p>Floyd 算法不能解决带有“负权回路”的图（有负权值的边组成回路），这种图有可能没有最短路径（每走一圈路径越小）</p> </li></ul> 
<h6><a id="_2948"></a>总结：</h6> 
<p><img src="https://images2.imgbox.com/f3/c4/E4JXWR4J_o.png" alt="img"></p> 
<h5><a id="DAG_2952"></a>有向无环图（DAG图）的描述表达式</h5> 
<h6><a id="_2954"></a>定义：</h6> 
<p>若一个有向图中不存在环，则称为有向无环图，简称DAG图（Directed Acyclic Graph）</p> 
<h6><a id="_2958"></a>例子：</h6> 
<p>转换前：</p> 
<p><img src="https://images2.imgbox.com/74/f5/6Ihw7AnO_o.png" alt="img"></p> 
<p>转换后：</p> 
<p><img src="https://images2.imgbox.com/32/67/blHfPEAD_o.png" alt="img"></p> 
<h6><a id="_2968"></a>解题方法：</h6> 
<ul><li> <p>把各个操作数不重复地排成一排</p> </li><li> <p>标出各个运算符的生效顺序（先后顺序有点出入无所谓）</p> </li><li> <p>按顺序加入运算符，注意“分层”</p> </li><li> <p>从底向上逐层检查同层的运算符是否可以合体</p> </li></ul> 
<h5><a id="_2978"></a>拓扑排序</h5> 
<h6><a id="AOV_2980"></a>AOV网：</h6> 
<ul><li> <p>AOV网(Activity On Vertex NetWork，用顶点表示活动的网)</p> </li><li> <p>用DAG图（有向无环图）表示一个工程。顶点表示活动，有向边&lt;Vi, Vj&gt;表示活动Vi必须先于活动Vj进行</p> </li></ul> 
<h6><a id="_2986"></a>拓扑排序：</h6> 
<ul><li> <p>拓扑排序：在图论中，由一个有向无环图的顶点组成的序列，当且仅当满足下列条件时，称为该图的一个拓扑排序：</p> 
  <ul><li> <p>每个顶点出现且只出现一次。</p> </li><li> <p>若顶点A在序列中排在顶点B的前面，则在图中不存在从顶点B到顶点A的路径。</p> </li></ul> </li><li> <p>或定义为：</p> 
  <ul><li>拓扑排序是对有向无环图的顶点的一种排序，它使得若存在一条从顶点A到顶点B的路径，则在排序中顶点B出现在顶点A的后面。</li></ul> </li><li> <p>每个AOV网都有一个或多个拓扑排序序列。</p> </li><li> <p>简单来说拓扑排序就是找到做事的先后顺序</p> </li><li> <p>拓扑排序的实现：</p> 
  <ul><li> <p>从AOV网中选择一个没有前驱（入度为0）的顶点并输出。</p> </li><li> <p>从网中删除该顶点和所有以它为起点的有向边。</p> </li><li> <p>重复前面的步骤直到当前的AOV网为空或当前网中不存在无前驱的顶点为止。</p> </li></ul> </li></ul> 
<h6><a id="_3010"></a>代码实现：</h6> 
<p><img src="https://images2.imgbox.com/73/7e/xrmDbd8F_o.png" alt="img"></p> 
<p><img src="https://images2.imgbox.com/7d/ae/rlV0uzXa_o.png" alt="img"></p> 
<ul><li> <p>时间复杂度：O(|V|+|E|)</p> </li><li> <p>若采用邻接矩阵，则需O(|V|^2)</p> </li></ul> 
<h6><a id="_3020"></a>逆拓扑排序：</h6> 
<ul><li> <p>对一个AOV网，如果采用下列步骤进行排序，则称之为逆拓扑排序：</p> 
  <ul><li> <p>从AOV网中选择一个没有后继（出度为0）的顶点并输出。</p> </li><li> <p>从网中删除该顶点和所有以它为终点的有向边。</p> </li><li> <p>重复上面步骤直到当前的AOV网为空。</p> </li></ul> </li><li> <p>用邻接表实现会更简单一些</p> </li><li> <p>使用逆邻接表：邻接表的顶点对应储存的信息是指向该顶点的边的信息</p> </li><li> <p>使用深度优先算法实现逆拓扑排序，顶点输出的序列就是逆拓扑排序序列</p> </li></ul> 
<p><img src="https://images2.imgbox.com/84/af/oI4TAeX7_o.png" alt="img"></p> 
<ul><li>DFS实现逆拓扑排序：在顶点退栈前输出</li></ul> 
<h5><a id="_3040"></a>关键路径</h5> 
<h6><a id="AOE_3042"></a>AOE网：</h6> 
<ul><li> <p>在带权有向图中，以顶点表示事件，以有向边表示活动，以边上的权值表示完成该活动的开销（如完成活动所需的时间）</p> </li><li> <p>称之为用边表示活动的网络，简称AOE网 (Activity On Edge NetWork)</p> </li><li> <p>AOE网具有以下两个性质：</p> 
  <ul><li> <p>只有在某顶点所代表的事件发生后，从该顶点出发的各有向边所代表的活动才能开始；</p> </li><li> <p>只有在进入某顶点的各有向边所代表的活动都已结束时，该顶点所代表的事件才能发生。</p> </li><li> <p>另外，有些活动是可以并行进行的</p> </li></ul> </li></ul> 
<p><img src="https://images2.imgbox.com/2b/50/ysn92O15_o.png" alt="img"></p> 
<h6><a id="_3058"></a>关键路径：</h6> 
<ul><li> <p>从源点到汇点的有向路径可能有多条，所有路径中，具有最大路径长度的路径称为关键路径，而把关键路径上的活动称为关键活动</p> </li><li> <p>完成整个工程的最短时间就是关键路径的长度，若关键活动不能按时完成，则整个工程的完成时间就会延长</p> </li><li> <p>事件vk的最早发生时间ve(k)：决定了所有从vk开始的活动能够开工的最早时间</p> </li><li> <p>活动ai的最早开始时间e(i)：指该活动弧的起点所表示的事件的最早发生时间</p> </li><li> <p>事件vk的最迟发生时间vl(k)：它是指在不推迟整个工程完成的前提下，该事件最迟必须发生的时间。</p> </li><li> <p>活动ai的最迟开始时间l(i)：它是指该活动弧的终点所表示事件的最迟发生时间与该活动所需时间之差。</p> </li><li> <p>活动ai的时间余量d(i)=l(i)-e(i)，表示在不增加完成整个工程所需总时间的情况下，活动ai可以拖延的时间</p> </li><li> <p>若一个活动的时间余量为零，则说明该活动必须要如期完成，d(i)=0即l(i) = e(i)的活动ai是关键活动，</p> </li><li> <p>由关键活动组成的路径就是关键路径</p> </li></ul> 
<h6><a id="_3078"></a>求关键路径的步骤：</h6> 
<ul><li> <p>求所有事件的最早发生时间 ve( )</p> 
  <ul><li> <p>按拓扑排序序列，依次求各个顶点的 ve(k):</p> </li><li> <p>ve(源点) = 0</p> </li><li> <p>ve(k) = Max{ve(j) + Weight(vj, vk)}, vj为vk 的任意前驱</p> </li></ul> </li><li> <p>求所有事件的最迟发生时间 vl( )</p> 
  <ul><li> <p>按逆拓扑排序序列，依次求各个顶点的 vl(k):</p> </li><li> <p>vl(汇点) = ve(汇点)</p> </li><li> <p>vl(k) = Min{vl(j) - Weight(vk, vj)} , vj为vk的任意后继</p> </li></ul> </li><li> <p>求所有活动的最早发生时间 e( )</p> 
  <ul><li>若边&lt;vk, vj&gt;表示活动ai，则有e(i) = ve(k)</li></ul> </li><li> <p>求所有活动的最迟发生时间 l( )</p> 
  <ul><li>若边&lt;vk, vj&gt;表示活动ai，则有l(i) = vl(j) - Weight(vk, vj)</li></ul> </li><li> <p>求所有活动的时间余量 d( )</p> 
  <ul><li>d(i) = l(i) - e(i)</li></ul> </li><li> <p>d(i)=0的活动就是关键活动, 由关键活动可得关键路径</p> </li></ul> 
<h6><a id="_3110"></a>关键活动、关键路径的特性：</h6> 
<ul><li> <p>若关键活动耗时增加，则整个工程的工期将增长</p> </li><li> <p>缩短关键活动的时间，可以缩短整个工程的工期</p> </li><li> <p>当缩短到一定程度时，关键活动可能会变成非关键活动</p> </li><li> <p>可能有多条关键路径，只提高一条关键路径上的关键活动速度并不能缩短整个工程的工期，只有加快那些包括在所有关键路径上的关键活动才能达到缩短工期的目的。</p> </li></ul> 
<h4><a id="_3120"></a>查找</h4> 
<h5><a id="_3122"></a>查找的基本概念</h5> 
<ul><li> <p>查找： 在数据集合中寻找满足某种条件的数据元素的过程称为查找</p> </li><li> <p>查找表（查找结构）：用于查找的数据集合称为查找表，它由同一类型的数据元素（或记录）组成</p> </li><li> <p>关键字： 数据元素中唯一标识该元素的某个数据项的值，使用基于关键字的查找，查找结果应该是唯一的。</p> </li></ul> 
<h6><a id="_3130"></a>对查找表的常见操作：</h6> 
<ul><li> <p>查找符合条件的数据元素</p> 
  <ul><li> <p>静态查找表</p> </li><li> <p>仅关注查找速度即可</p> </li></ul> </li><li> <p>插入、删除某个数据元素</p> 
  <ul><li> <p>动态查找表</p> </li><li> <p>除了查找速度，也要关注插/删操作是否方便实现</p> </li></ul> </li></ul> 
<h6><a id="_3144"></a>查找算法的评价指标：</h6> 
<ul><li> <p>查找长度：在查找运算中，需要对比关键字的次数称为查找长度</p> </li><li> <p>平均查找长度（ASL, Average Search Length ）：所有查找过程中进行关键字的比较次数的平均值</p> </li><li> <p>ASL的数量级反应了查找算法的时间复杂度</p> </li><li> <p>评价一个查找算法的效率时，通常考虑查找成功、查找失败两种情况的ASL</p> </li></ul> 
<p><img src="https://images2.imgbox.com/7c/fd/ZQ7oDCPF_o.png" alt="img"></p> 
<h5><a id="_3156"></a>顺序查找</h5> 
<h6><a id="_3158"></a>定义：</h6> 
<p>顺序查找，又叫“线性查找”，通常用于线性表。</p> 
<p>算法思想：从头到尾依次往后找</p> 
<h6><a id="_3164"></a>顺序查找的实现：</h6> 
<p><img src="https://images2.imgbox.com/05/f9/srLwxITR_o.png" alt="img"></p> 
<h6><a id="_3168"></a>顺序查找的实现（哨兵）：</h6> 
<p><img src="https://images2.imgbox.com/a4/e7/XJYwo7tC_o.png" alt="img"></p> 
<p>优点：无需判断是否越界，效率更高</p> 
<p><img src="https://images2.imgbox.com/52/f0/P1iFlhRt_o.png" alt="img"></p> 
<h6><a id="_3176"></a>顺序查找的优化（对有序表）：</h6> 
<p><img src="https://images2.imgbox.com/a1/49/EFI22d3D_o.png" alt="img"></p> 
<h6><a id="ASL_3180"></a>用查找判定树分析ASL：</h6> 
<ul><li> <p>一个成功结点的查找长度 = 自身所在层数</p> </li><li> <p>一个失败结点的查找长度 = 其父结点所在层数</p> </li><li> <p>默认情况下，各种失败情况或成功情况都等概率发生</p> </li></ul> 
<h6><a id="_3188"></a>顺序查找的优化（被查概率不相等）：</h6> 
<p><img src="https://images2.imgbox.com/0d/42/itSI3qpc_o.png" alt="img"></p> 
<h5><a id="_3192"></a>折半查找</h5> 
<h6><a id="_3194"></a>算法思想：</h6> 
<p>折半查找，又称“二分查找”，仅适用于有序的顺序表。</p> 
<p>查找成功：</p> 
<p>注意：下面的mid向下取整</p> 
<p><img src="https://images2.imgbox.com/1e/79/R9tRuE74_o.png" alt="img"></p> 
<p><img src="https://images2.imgbox.com/ca/c9/nLv6d2MD_o.png" alt="img"></p> 
<p><img src="https://images2.imgbox.com/ec/83/yaRNgbmB_o.png" alt="img"></p> 
<p><img src="https://images2.imgbox.com/55/d1/4e3FSBQV_o.png" alt="img"></p> 
<p>查找失败：</p> 
<p><img src="https://images2.imgbox.com/c4/f2/ybulpjXh_o.png" alt="img"></p> 
<h6><a id="_3218"></a>代码实现：</h6> 
<p><img src="https://images2.imgbox.com/eb/56/clnWTS7M_o.png" alt="img"></p> 
<h6><a id="_3222"></a>查找效率分析：</h6> 
<p><img src="https://images2.imgbox.com/ed/19/bMw4FE0k_o.png" alt="img"></p> 
<h6><a id="_3226"></a>折半查找判定树的构造：</h6> 
<ul><li> <p>如果当前low和high之间有偶数个元素，则 mid 分隔后，左半部分比右半部分少一个元素</p> </li><li> <p>如果当前low和high之间有奇数个元素，则 mid 分隔后，左右两部分元素个数相等</p> </li><li> <p>折半查找的判定树中,mid = [(low + high)/2]则对于任何一个结点，必有：右树结点数-左子树结点数=0或1</p> </li><li> <p>折半查找的判定树一定是平衡二叉树</p> </li><li> <p>折半查找的判定树中，只有最下面一层是不满的因此，元素个数为n时树高h = [log2(n + 1)]</p> </li><li> <p>判定树结点关键字：左&lt;中&lt;右，满足二叉排序树的定义</p> </li><li> <p>失败结点：n+1个（等于成功结点的空链域数量）</p> </li><li> <p>折半查找的时间复杂度 = O(log2n)</p> </li></ul> 
<h5><a id="_3244"></a>分块查找</h5> 
<h6><a id="_3246"></a>算法思想：</h6> 
<p><img src="https://images2.imgbox.com/ca/62/22emqjbz_o.png" alt="img"></p> 
<ul><li> <p>特点：块内无序、块间有序</p> </li><li> <p>分块查找，又称索引顺序查找，算法过程如下：</p> 
  <ul><li> <p>在索引表中确定待查记录所属的分块（可顺序、可折半）</p> </li><li> <p>在块内顺序查找</p> </li></ul> </li></ul> 
<h6><a id="_3258"></a>用折半查找查索引：</h6> 
<p>若查找目标与索引表值相同：</p> 
<p><img src="https://images2.imgbox.com/81/67/BxAxWPrC_o.png" alt="img"></p> 
<p>若查找目标与索引值不同：</p> 
<p><img src="https://images2.imgbox.com/61/fd/7sLh1HSx_o.png" alt="img"></p> 
<ul><li> <p>若索引表中不包含目标关键字，则折半查找索引表最终停在 low&gt;high，要在low所指分块中查找</p> </li><li> <p>原因：最终low左边一定小于目标关键字，high右边一定大于目标关键字。而分块存储的索引表中保存的是各个分块的最大关键字</p> </li></ul> 
<p>查找失败的例子：</p> 
<p><img src="https://images2.imgbox.com/6a/d9/xeGO6mSC_o.png" alt="img"></p> 
<h6><a id="_3276"></a>查找效率分析：</h6> 
<p><img src="https://images2.imgbox.com/96/f4/NZh1nzon_o.png" alt="img"></p> 
<p><img src="https://images2.imgbox.com/a2/ca/yr6kz8ql_o.png" alt="img"></p> 
<h5><a id="B_3282"></a>B树</h5> 
<h6><a id="m_3284"></a>m叉查找树：</h6> 
<ul><li> <p>实际上就是二叉查找树的拓展，结点多少有多少个分叉就是多少叉查找树</p> </li><li> <p>每个结点关键字的查找可以用顺序查找也可以用折半查找</p> </li></ul> 
<p><img src="https://images2.imgbox.com/74/80/bQWw4Joe_o.png" alt="img"></p> 
<h6><a id="_3292"></a>如何保证查找效率：</h6> 
<ul><li> <p>若每个结点内关键字太少，导致树变高，要查更多层结点，效率低</p> 
  <ul><li> <p>策略：m叉查找树中，规定除了根结点外，任何结点至少有⌈m/2⌉个分叉，即至少含有⌈m/2⌉ − 1 个关键字</p> </li><li> <p>为什么不能保证根结点至少有⌈m/2⌉个分叉：如果整个树只有1个元素，根结点只能有两个分叉</p> </li></ul> </li><li> <p>不够“平衡”，树会很高，要查很多层结点</p> 
  <ul><li>策略：m叉查找树中，规定对于任何一个结点，其所有子树的高度都要相同。</li></ul> </li></ul> 
<h6><a id="B_3304"></a>B树的定义：</h6> 
<ul><li> <p>B树，又称多路平衡查找树，B树中所有结点的孩子个数的最大值称为B树的阶，通常用m表示。一棵m阶B树或为空树，或为满足如下特性的m叉树：</p> 
  <ul><li> <p>树中每个结点至多有m棵子树，即至多含有m-1个关键字。</p> </li><li> <p>若根结点不是终端结点，则至少有两棵子树。</p> </li><li> <p>除根结点外的所有非叶结点至少有⌈m/2⌉棵子树，即至少含有 ⌈m/2⌉-1个关键字。</p> </li><li> <p>所有非叶结点的结构如下：</p> 
    <ul><li> <p><img src="https://images2.imgbox.com/ac/9e/IMCnq6WZ_o.png" alt="img"></p> </li><li> <p>其中，Ki（i = 1, 2,…, n）为结点的关键字，且满足K1 &lt; K2 &lt;…&lt; Kn；Pi（i = 0, 1,…, n）为指向子树根结点的指针，且指针Pi-1所指子树中所有结点的关键字均小于Ki，Pi所指子树中所有结点的关键字均大于Ki，n（⌈m/2⌉- 1≤n≤m - 1）为结点中关键字的个数。</p> </li></ul> </li></ul> </li><li> <p>所有的叶结点都出现在同一层次上，并且不带信息（可以视为外部结点或类似于折半查找判定树的查找失败结点，实际上这些结点不存在，指向这些结点的指针为空）。</p> </li></ul> 
<h6><a id="B_3322"></a>B树的高度：</h6> 
<p><img src="https://images2.imgbox.com/e6/1f/51SMpqtY_o.png" alt="img"></p> 
<p><img src="https://images2.imgbox.com/50/de/MPCWceVi_o.png" alt="img"></p> 
<p>最大高度的另一种推导方法：</p> 
<p><img src="https://images2.imgbox.com/0d/99/ZvOEaW95_o.png" alt="img"></p> 
<h5><a id="B_3332"></a>B树的插入删除</h5> 
<h6><a id="B_3334"></a>B树的插入：</h6> 
<ul><li> <p>新元素一定是插入到最底层“终端结点”，用“查找”来确定插入位置</p> </li><li> <p>在插入key后，若导致原结点关键字数超过上限，则从中间位置（⌈m/2⌉）将其中的关键字分为两部分</p> </li><li> <p>左部分包含的关键字放在原结点中，右部分包含的关键字放到新结点中，中间位置（⌈m/2⌉）的结点插入原结点的父结点</p> </li><li> <p>若此时导致其父结点的关键字个数也超过了上限，则继续进行这种分裂操作，直至这个过程传到根结点为止，进而导致B树高度增1。</p> </li></ul> 
<h6><a id="B_3344"></a>B树的删除：</h6> 
<ul><li> <p>若被删除关键字在终端结点，则直接删除该关键字（要注意结点关键字个数是否低于下限 ⌈m/2⌉ − 1）</p> </li><li> <p>若被删除关键字在非终端结点，则用直接前驱或直接后继来替代被删除的关键字</p> 
  <ul><li> <p>直接前驱：当前关键字左侧指针所指子树中“最右下”的元素</p> </li><li> <p>直接后继：当前关键字右侧指针所指子树中“最左下”的元素</p> </li></ul> </li><li> <p>若被删除关键字所在结点删除前的关键字个数低于下限，且与此结点右（或左）兄弟结点的关键字个数还很宽裕，则需要调整该结点、右（或左）兄弟结点及其双亲结点（父子换位法）</p> 
  <ul><li> <p>当右兄弟很宽裕时，用当前结点的后继（比当前结点大一位）、后继的后继（比当前结点大两位）来填补空缺</p> </li><li> <p>当左兄弟很宽裕时，用当前结点的前驱（比当前结点小一位）、前驱的前驱（比当前结点小两位）来填补空缺</p> </li></ul> </li><li> <p>若被删除关键字所在结点删除前的关键字个数低于下限，且此时与该结点相邻的左、右兄弟结点的关键字个数均=⌈m/2⌉ − 1，则将关键字删除后与左（或右）兄弟结点及双亲结点中的关键字进行合并</p> </li></ul> 
<h5><a id="B_3362"></a>B+树</h5> 
<h6><a id="_3364"></a>定义和性质：</h6> 
<p><img src="https://images2.imgbox.com/1a/ac/7kAXvzwe_o.png" alt="img"></p> 
<p>一棵m阶的B+树需满足下列条件：</p> 
<ul><li> <p>每个分支结点最多有m棵子树（孩子结点）。</p> </li><li> <p>非叶根结点至少有两棵子树，其他每个分支结点至少有⌈m/2⌉棵子树。</p> 
  <ul><li>可以理解为：要追求“绝对平衡”，即所有子树高度要相同</li></ul> </li><li> <p>结点的子树个数与关键字个数相等。</p> </li><li> <p>所有叶结点包含全部关键字及指向相应记录的指针，叶结点中将关键字按大小顺序排列，并且相邻叶结点按大小顺序相互链接起来。</p> </li><li> <p>所有分支结点中仅包含它的各个子结点中关键字的最大值及指向其子结点的指针。</p> </li></ul> 
<h6><a id="B_3382"></a>B+树的查找：</h6> 
<p>B+树中，无论查找成功与否，最终一定都要走到最下面一层结点，因为只有叶子结点才有关键字对应的记录</p> 
<h6><a id="BB_3386"></a>B+树和B树区别：</h6> 
<p><img src="https://images2.imgbox.com/0b/e5/6bSYTRnI_o.png" alt="img"></p> 
<ul><li> <p>典型应用：关系型数据库的“索引”（如MySQL）</p> </li><li> <p>在B+树中，非叶结点不含有该关键字对应记录的存储地址。</p> </li><li> <p>可以使一个磁盘块可以包含更多个关键字，使得B+树的阶更大，树高更矮，读磁盘次数更少，查找更快</p> </li></ul> 
<h5><a id="_3396"></a>散列（哈希）查找</h5> 
<h6><a id="_3398"></a>定义：</h6> 
<ul><li> <p>散列表（Hash Table），又称哈希表</p> </li><li> <p>是一种数据结构，特点是：数据元素的关键字与其存储地址直接相关</p> </li><li> <p>通过哈希函数建立关键字和存储地址的联系</p> </li><li> <p>若不同的关键字通过散列函数映射到同一个值，则称它们为“同义词”</p> </li><li> <p>通过散列函数确定的位置已经存放了其他元素，则称这种情况为“冲突”</p> </li></ul> 
<h6><a id="_3410"></a>处理冲突的方法——拉链法：</h6> 
<p><img src="https://images2.imgbox.com/af/7f/ksfszNkI_o.png" alt="img"></p> 
<p><img src="https://images2.imgbox.com/75/13/4Wore42w_o.png" alt="img"></p> 
<p><img src="https://images2.imgbox.com/59/4a/xS6nMsni_o.png" alt="img"></p> 
<ul><li> <p>用拉链法（又称链接法、链地址法）处理“冲突”：把所有“同义词”存储在一个链表中</p> </li><li> <p>最理想情况：散列查找时间复杂度可到达O(1)</p> </li><li> <p>“冲突”越多，查找效率越低</p> </li><li> <p>实际上就是顺序表和链表的结合结合两者优点，比如顺序表的随机存取，然后用链表的解决冲突问题，又规避了顺序表的一系列缺点</p> </li><li> <p>在插入新元素时，保持关键字有序，可微微提高查找效率</p> </li></ul> 
<h6><a id="_3428"></a>常见的散列函数：</h6> 
<ul><li> <p>散列函数的设计目的：</p> 
  <ul><li> <p>让不同关键字的冲突尽可能的少</p> </li><li> <p>散列查找是典型的“用空间换时间”的算法，只要散列函数设计的合理，则散列表越长，冲突的概率越低。</p> </li></ul> </li><li> <p>除留余数法：H(key) = key % p</p> 
  <ul><li> <p>散列表表长为m，取一个不大于m但最接近或等于m的质数p</p> </li><li> <p>质数又称素数。指除了1和此整数自身外,不能被其他自然数整除的数</p> </li><li> <p>用质数取模，分布更均匀，冲突更少。参见《数论》</p> </li><li> <p>注意：散列函数的设计要结合实际的关键字分布特点来考虑，不要教条化</p> </li></ul> </li><li> <p>直接定址法 ： H(key) = key 或 H(key) = a*key + b</p> 
  <ul><li> <p>其中，a和b是常数。这种方法计算最简单，且不会产生冲突。它适合关键字的分布基本连续的情况，若关键字分布不连续，空位较多，则会造成存储空间的浪费。</p> </li><li> <p>例如：存储同一个班级的学生信息</p> </li></ul> </li><li> <p>数字分析法：选取数码分布较为均匀的若干位作为散列地址</p> 
  <ul><li> <p>设关键字是r进制数（如十进制数），而r个数码在各位上出现的频率不一定相同，可能在某些位上分布均匀一些，每种数码出现的机会均等；</p> </li><li> <p>而在某些位上分布不均匀，只有某几种数码经常出现，此时可选取数码分布较为均匀的若干位作为散列地址。这种方法适合于已知的关键字集合，若更换了关键字，则需要重新构造新的散列函数。</p> </li><li> <p>例如：以“手机号码”作为关键字设计散列函数</p> </li></ul> </li><li> <p>平方取中法：取关键字的平方值的中间几位作为散列地址。</p> 
  <ul><li> <p>具体取多少位要视实际情况而定。</p> </li><li> <p>这种方法得到的散列地址与关键字的每位都有关系，因此使得散列地址分布比较均匀，适用于关键字的每位取值都不够均匀或均小于散列地址所需的位数。</p> </li><li> <p>例如：要存储整个学校的学生信息，以“身份证号”作为关键字设计散列函数</p> </li></ul> </li></ul> 
<h6><a id="_3468"></a>处理冲突的方法——开放定址法：</h6> 
<ul><li> <p>所谓开放定址法，是指可存放新表项的空闲地址既向它的同义词表项开放，又向它的非同义词表项开放。其数学递推公式为：</p> 
  <ul><li> <p>Hi = (H(key) + di) % m</p> </li><li> <p>i = 0, 1, 2,…, k（k≤m - 1），m表示散列表表长；di为增量序列；</p> </li><li> <p>i 可理解为“第i次发生冲突”</p> </li></ul> </li><li> <p>线性探测法</p> 
  <ul><li> <p>di = 0, 1, 2, 3, …, m-1；即发生冲突时，每次往后探测相邻的下一个单元是否为空，为空则可以插入数值</p> </li><li> <p>查找也是类似，先通过公式得到Hi再依次往后查找，若遇到空的位置则说明查找失败，所以越早遇到空位置，就可以越早确定查找失败</p> </li><li> <p>删除结点不能简单地将被删结点的空间置为空，否则将截断在它之后填入散列表的同义词结点的查找路径，可以做一个“删除标记”，进行逻辑删除</p> </li><li> <p>线性探测法由于冲突后再探测一定是放在某个连续的位置，很容易造成同义词、非同义词的“聚集（堆积）”现象，严重影响查找效率</p> </li></ul> </li><li> <p>平方探测法</p> 
  <ul><li> <p>当di = 0^2, 1^2, -1^2, 2^2, -2^2, …, k^2, -k^2时，称为平方探测法，又称二次探测法，其中k≤m/2</p> </li><li> <p>比起线性探测法更不易产生“聚集（堆积）”问题</p> </li><li> <p>注意：负数的模运算，(-3)%27 = 24，而不是3</p> </li><li> <p>模运算的规则：a MOD m == (a+km) MOD m , 其中，k为任意整数</p> </li><li> <p>散列表长度m必须是一个可以表示成4j + 3的素数，才能探测到所有位置</p> </li></ul> </li><li> <p>伪随机序列法</p> 
  <ul><li>di 是一个伪随机序列，如 di= 0, 5, 24, 11, …</li></ul> </li></ul> 
<h6><a id="_3504"></a>处理冲突的方法——再散列法：</h6> 
<ul><li> <p>除了原始的散列函数 H(key) 之外，多准备几个散列函数</p> </li><li> <p>当散列函数冲突时，用下一个散列函数计算一个新地址，直到不冲突为止：</p> </li><li> <p>Hi = RHi(Key)</p> </li><li> <p>i=1,2,3….,k</p> </li></ul> 
<h4><a id="_3514"></a>排序</h4> 
<h5><a id="_3516"></a>排序的基本概念</h5> 
<h6><a id="_3518"></a>定义：</h6> 
<ul><li> <p>排序（Sort），就是重新排列表中的元素，使表中的元素满足按关键字有序的过程。</p> </li><li> <p>输入：n个记录R1, R2,…, Rn，对应的关键字为k1, k2,…, kn。</p> </li><li> <p>输出：输入序列的一个重排R1ʹ, R2ʹ,…, Rnʹ，使得有k1ʹ≤k2ʹ≤…≤knʹ（也可递减）</p> </li></ul> 
<h6><a id="_3526"></a>排序算法的评价指标：</h6> 
<ul><li> <p>时间复杂度</p> </li><li> <p>空间复杂度</p> </li><li> <p>算法的稳定性：</p> 
  <ul><li> <p>若待排序表中有两个元素Ri和Rj，其对应的关键字相同即keyi = keyj，且在排序前Ri在Rj的前面</p> </li><li> <p>若使用某一排序算法排序后，Ri仍然在Rj的前面</p> </li><li> <p>则称这个排序算法是稳定的，否则称排序算法是不稳定的。</p> </li></ul> </li></ul> 
<h6><a id="_3540"></a>排序算法的分类：</h6> 
<ul><li> <p>内部排序：数据都在内存中，关注如何使算法时、空复杂度更低</p> </li><li> <p>外部排序：数据太多，无法全部放入内存，还要关注如何使读/写磁盘次数更少</p> </li></ul> 
<h5><a id="_3546"></a>插入排序</h5> 
<h6><a id="_3548"></a>算法思想：</h6> 
<p>每次将一个待排序的记录按其关键字大小插入到前面已排好序的子序列中，直到全部记录插入完成。</p> 
<h6><a id="_3552"></a>代码实现：</h6> 
<p><img src="https://images2.imgbox.com/ee/dd/2H2CM0Qj_o.png" alt="img"></p> 
<p><img src="https://images2.imgbox.com/c3/a7/aHWyOjkS_o.png" alt="img"></p> 
<h6><a id="_3558"></a>算法效率分析：</h6> 
<ul><li> <p>空间复杂度：O(1)</p> </li><li> <p>时间复杂度：主要来自对比关键字、移动元素，若有 n 个元素，则需要 n-1 趟处理</p> 
  <ul><li> <p>最好时间复杂度：O(n) 共n-1趟处理，每一趟只需要对比关键字1次，不用移动元素</p> </li><li> <p>最坏时间复杂度：O(n^2) 共n-1趟处理，每一趟都需要从尾移到到头（全部逆序）</p> </li></ul> </li><li> <p>算法稳定性：稳定</p> </li></ul> 
<h6><a id="_3570"></a>优化——折半插入排序：</h6> 
<p>思路：</p> 
<ul><li> <p>先用折半查找找到应该插入的位置，再移动元素</p> </li><li> <p>当 low&gt;high 时折半查找停止，应将 [low, i-1] 内的元素全部右移，并将 A[0] 复制到 low 所指位置</p> </li><li> <p>当 A[mid]==A[0] 时，为了保证算法的“稳定性”，应继续在 mid 所指位置右边寻找插入位置</p> </li></ul> 
<p>代码实现：</p> 
<p><img src="https://images2.imgbox.com/25/f2/ktNDOccj_o.png" alt="img"></p> 
<p>比起“直接插入排序”，比较关键字的次数减少了，但是移动元素的次数没变，整体来看时间复杂度依然是O(n^2)</p> 
<h6><a id="_3586"></a>对链表进行插入排序：</h6> 
<ul><li> <p>使用链表不需要对序列进行依次友谊，移动元素的次数变少了</p> </li><li> <p>但是关键字对比的次数依然是O(n^2) 数量级，整体来看时间复杂度依然是O(n^2)</p> </li></ul> 
<h5><a id="_3592"></a>希尔排序</h5> 
<h6><a id="_3594"></a>算法思想：</h6> 
<ul><li> <p>先追求表中元素部分有序，再逐渐逼近全局有序</p> </li><li> <p>先将待排序表分割成若干形如 L[i, i + d, i + 2d,…, i + kd] 的“特殊”子表，对各个子表分别进行直接插入排序。缩小增量d，重复上述过程，直到d=1为止。</p> </li></ul> 
<p><img src="https://images2.imgbox.com/6f/61/8u6DDQWR_o.png" alt="img"></p> 
<h6><a id="_3602"></a>代码实现：</h6> 
<p><img src="https://images2.imgbox.com/91/8f/LJUhSRwr_o.png" alt="img"></p> 
<h6><a id="_3606"></a>算法性能分析：</h6> 
<ul><li> <p>空间复杂度：O(1)</p> </li><li> <p>时间复杂度：</p> 
  <ul><li> <p>和增量序列 d1, d2, d3… 的选择有关，目前无法用数学手段证明确切的时间复杂度</p> </li><li> <p>最坏时间复杂度为 O(n<sup>2)，当n在某个范围内时，可达O(n</sup>1.3)</p> </li></ul> </li><li> <p>稳定性：不稳定</p> </li><li> <p>适用性：仅适用于顺序表，不适用于链表</p> </li></ul> 
<h5><a id="_3620"></a>冒泡排序</h5> 
<h6><a id="_3622"></a>交换排序分类：</h6> 
<ul><li> <p>冒泡排序</p> </li><li> <p>选择排序</p> </li></ul> 
<h6><a id="_3628"></a>算法思想：</h6> 
<ul><li> <p>从后往前（或从前往后）两两比较相邻元素的值，若为逆序（即A[i-1]&gt;A[i]），则交换它们，直到序列比较完</p> </li><li> <p>这样过程称为“一趟”冒泡排序</p> </li><li> <p>第n趟结束后，最小的n个元素会“冒”到最前边</p> </li><li> <p>若某一趟排序没有发生“交换”，说明此时已经整体有序。</p> </li><li> <p>可以从后往前冒泡，也可以冲前往后冒泡</p> </li></ul> 
<h6><a id="_3640"></a>代码实现：</h6> 
<p><img src="https://images2.imgbox.com/25/50/hhdwcJw3_o.png" alt="img"></p> 
<p><img src="https://images2.imgbox.com/f8/31/WAM5hjYa_o.png" alt="img"></p> 
<h6><a id="_3646"></a>算法性能分析：</h6> 
<ul><li> <p>空间复杂度：O(1)</p> </li><li> <p>时间复杂度：</p> 
  <ul><li> <p>最好情况（有序）：O(n)</p> </li><li> <p>最坏情况（逆序）：O(n^2)</p> </li><li> <p>平均情况：O(n^2)</p> </li></ul> </li><li> <p>稳定性：稳定</p> </li><li> <p>适用性：顺序表、链表都可以</p> </li></ul> 
<h5><a id="_3662"></a>快速排序</h5> 
<h6><a id="_3664"></a>算法思想：</h6> 
<ul><li> <p>在待排序表L[1…n]中任取一个元素pivot作为枢轴（或基准，通常取⾸元素）</p> </li><li> <p>通过一趟排序将待排序表划分为独立的两部分L[1…k-1]和L[k+1…n]</p> </li><li> <p>使得L[1…k-1]中的所有元素小于pivot，L[k+1…n]中的所有元素大于等于pivot</p> </li><li> <p>则pivot放在了其最终位置L(k)上，这个过程称为一次“划分”</p> </li><li> <p>然后分别递归地对两个子表重复上述过程，直至每部分内只有一个元素或空为止，即所有元素放在了其最终位置上</p> </li></ul> 
<h6><a id="_3676"></a>代码实现：</h6> 
<p><img src="https://images2.imgbox.com/b9/df/TcpuDet1_o.png" alt="img"></p> 
<p><img src="https://images2.imgbox.com/40/f2/fGeEtaxK_o.png" alt="img"></p> 
<h6><a id="_3682"></a>算法性能分析：</h6> 
<p><img src="https://images2.imgbox.com/c9/04/E99ZJPjG_o.png" alt="img"></p> 
<ul><li> <p>n个结点的二叉树</p> 
  <ul><li> <p>最小高度 = ⌊log2n⌋ + 1</p> </li><li> <p>最大高度 = n</p> </li></ul> </li><li> <p>时间复杂度=O(n*递归层数)</p> 
  <ul><li> <p>最好时间复杂度=O(nlog2n)</p> 
    <ul><li>每次选的枢轴元素都能将序列划分成均匀的两部分</li></ul> </li><li> <p>最坏时间复杂度=O(n^2)</p> 
    <ul><li>若序列原本就有序或逆序，则时、空复杂度最高（可优化，尽量选择可以把数据中分的枢轴元素。）</li></ul> </li></ul> </li><li> <p>空间复杂度=O(递归层数)</p> 
  <ul><li> <p>最好空间复杂度=O(log2n)</p> </li><li> <p>最坏空间复杂度=O(n)</p> </li></ul> </li><li> <p>若每一次选中的“枢轴”将待排序序列划分为很不均匀的两个部分，则会导致递归深度增加，算法效率变低</p> </li><li> <p>若初始序列有序或逆序，则快速排序的性能最差（因为每次选择的都是最靠边的元素）</p> </li><li> <p>快速排序算法优化思路：尽量选择可以把数据中分的枢轴元素。</p> 
  <ul><li> <p>选头、中、尾三个位置的元素，取中间值作为枢轴元素；</p> </li><li> <p>随机选一个元素作为枢轴元素</p> </li></ul> </li><li> <p>快速排序是所有内部排序算法中平均性能最优的排序算法</p> </li><li> <p>稳定性：不稳定</p> </li></ul> 
<h5><a id="_3722"></a>简单选择排序</h5> 
<h6><a id="_3724"></a>选择排序分类：</h6> 
<ul><li> <p>简单选择排序</p> </li><li> <p>堆排序</p> </li></ul> 
<h6><a id="_3730"></a>算法思想：</h6> 
<p>每一趟在待排序元素中选取关键字最小（或最大）的元素（每一趟待排序序列长度-1）加入有序子序列（每一趟有序序列长度+1）</p> 
<h6><a id="_3734"></a>代码实现：</h6> 
<p><img src="https://images2.imgbox.com/1b/1a/XnLxEArC_o.png" alt="img"></p> 
<p><img src="https://images2.imgbox.com/ff/90/hNE0jrcp_o.png" alt="img"></p> 
<h6><a id="_3740"></a>算法性能分析：</h6> 
<ul><li> <p>无论有序、逆序、还是乱序，一定需要 n-1 趟处理</p> </li><li> <p>总共需要对比关键字 (n-1)+(n-2)+…+1=[n(n-1)]/2次</p> </li><li> <p>元素交换次数 &lt; n-1</p> </li><li> <p>空间复杂度：O(1)</p> </li><li> <p>时间复杂度=O(n^2)</p> </li><li> <p>稳定性：不稳定</p> </li><li> <p>适用性：既可以用于顺序表，也可用于链表</p> </li></ul> 
<h5><a id="_3756"></a>堆排序</h5> 
<h6><a id="_3758"></a>堆的定义：</h6> 
<ul><li> <p>若n个关键字序列L[1…n] 满足下面某一条性质，则称为堆（Heap）：</p> 
  <ul><li> <p>若满足：L(i)≥L(2i)且L(i)≥L(2i+1) （1 ≤ i ≤n/2 ）则为大根堆（大顶堆）</p> 
    <ul><li>即完全二叉树中，任意根≥左、右</li></ul> </li><li> <p>若满足：L(i)≤L(2i)且L(i)≤L(2i+1) （1 ≤ i ≤n/2 ）则为小根堆（小顶堆）</p> 
    <ul><li>即完全二叉树中，任意根≤左、右</li></ul> </li></ul> </li></ul> 
<h6><a id="_3770"></a>建立大根堆：</h6> 
<ul><li> <p>把所有非终端结点都检查一遍，是否满足大根堆的要求，如果不满足，则进行调整</p> 
  <ul><li> <p>在顺序存储的完全二叉树中，非终端结点编号 i≤⌊n/2⌋</p> </li><li> <p>检查当前结点是否满足 根≥左、右，若不满足，将当前结点与更大的一个孩子互换</p> 
    <ul><li> <p>i的左孩子：2i</p> </li><li> <p>i的右孩子：2i+1</p> </li><li> <p>i的父结点：⌊i/2⌋</p> </li></ul> </li></ul> </li><li> <p>若元素互换破坏了下一级的堆，则采用相同的方法继续往下调整（小元素不断“下坠”）</p> </li></ul> 
<p>建立大根堆（代码）：</p> 
<p><img src="https://images2.imgbox.com/9e/a4/FFZpDAEV_o.png" alt="img"></p> 
<h6><a id="_3790"></a>基于大根堆进行排序：</h6> 
<ul><li> <p>选择排序：每一趟在待排序元素中选取关键字最大的元素加入有序子序列</p> </li><li> <p>堆排序每一趟完成以下工作：</p> 
  <ul><li> <p>将堆顶元素（就是最大的元素）加入有序子序列（与待排序序列中的最后一个元素交换）</p> </li><li> <p>并将待排序元素序列再次调整为大根堆（小元素不断“下坠”）</p> </li></ul> </li><li> <p>注意：大根堆获得的排序序列是递增序列，小跟堆相反，获得的是递减序列</p> </li></ul> 
<h6><a id="_3802"></a>代码实现（大根堆排序）：</h6> 
<p><img src="https://images2.imgbox.com/6f/df/8DK5nC7g_o.png" alt="img"></p> 
<p><img src="https://images2.imgbox.com/fc/33/gOASbO0r_o.png" alt="img"></p> 
<p><img src="https://images2.imgbox.com/4a/75/kfhd6nfC_o.png" alt="img"></p> 
<h6><a id="_3810"></a>堆排序的效率分析：</h6> 
<ul><li> <p>建堆的过程，关键字对比次数不超过4n，建堆时间复杂度=O(n)</p> </li><li> <p>堆排序的时间复杂度 =O(n) + O(nlog2n) = O(nlog2n)</p> </li><li> <p>堆排序的空间复杂度 =O(1)</p> </li><li> <p>稳定性：不稳定</p> </li></ul> 
<h5><a id="_3820"></a>堆的插入删除</h5> 
<h6><a id="_3822"></a>基本操作：</h6> 
<ul><li> <p>i的左孩子：2i</p> </li><li> <p>i的右孩子：2i+1</p> </li><li> <p>i的父结点：⌊i/2⌋</p> </li></ul> 
<h6><a id="_3830"></a>在堆中插入新元素：</h6> 
<ul><li> <p>对于小根堆，新元素放到表尾，与父节点对比，若新元素比父节点更小，则将二者互换。</p> </li><li> <p>新元素就这样一路“上升”，直到无法继续上升为止</p> </li></ul> 
<h6><a id="_3836"></a>在堆中删除元素：</h6> 
<ul><li> <p>被删除的元素用堆底元素替代</p> </li><li> <p>然后让该元素不断“下坠”，直到无法下坠为止</p> </li></ul> 
<h6><a id="_3842"></a>关键字对比次数：</h6> 
<ul><li> <p>每次“上升”调整只需对比关键字1次</p> </li><li> <p>每次“下坠”调整可能需要对比关键字2次，也可能只需对比1次</p> </li></ul> 
<h5><a id="_3848"></a>归并排序</h5> 
<h6><a id="_3850"></a>算法思想：</h6> 
<ul><li> <p>把两个或多个已经有序的序列合并成一个</p> </li><li> <p>对于两个有序序列，将i、j指针指向序列的表头，选择更小的一个放入k所指的位置</p> </li><li> <p>k++，i/j指向更小元素的指针++</p> </li><li> <p>只剩一个子表未合并时，可以将该表的剩余元素全部加到总表</p> </li><li> <p>m路归并：每选出一个小的元素，需要对比关键字m-1次</p> </li><li> <p>核心操作：把数组内的两个有序序列归并为一个</p> </li></ul> 
<p><img src="https://images2.imgbox.com/3b/d0/HPl76HmH_o.png" alt="img"></p> 
<h6><a id="_3866"></a>代码实现：</h6> 
<p><img src="https://images2.imgbox.com/88/9d/xEyFwpRP_o.png" alt="img"></p> 
<p><img src="https://images2.imgbox.com/78/63/UTTF3rcr_o.png" alt="img"></p> 
<p><img src="https://images2.imgbox.com/ef/a0/8FYociyc_o.png" alt="img"></p> 
<ul><li> <p>low是数组中第一个有序序列的开始</p> </li><li> <p>mid是数组中第一个有序序列的结尾</p> </li><li> <p>high是数组中第二个有序序列的结尾</p> </li><li> <p>辅助数组B临时存放这两段有序序列</p> </li></ul> 
<h6><a id="_3882"></a>算法效率分析：</h6> 
<ul><li> <p>2路归并的“归并树”形态上就是一棵倒立的二叉树</p> </li><li> <p>二叉树的第h层最多有2 ^ (h-1)个结点，若树高为h，则应满足n &lt;= 2 ^ (h-1)，即h − 1 = ⌈log2n⌉</p> </li><li> <p>n个元素进行2路归并排序，归并趟数=⌈log2n⌉</p> </li><li> <p>每趟归并时间复杂度为O(n)，则算法时间复杂度O(nlog2n)</p> </li><li> <p>空间复杂度=O(n)，来自于辅助数组B</p> </li><li> <p>稳定性：稳定</p> </li></ul> 
<h5><a id="_3896"></a>基数排序</h5> 
<h6><a id="_3898"></a>算法思想：</h6> 
<p><img src="https://images2.imgbox.com/18/8a/lCj5khFo_o.png" alt="img"></p> 
<p><img src="https://images2.imgbox.com/c2/b6/3WGAemTG_o.png" alt="img"></p> 
<p>基数排序得到递减序列的过程如下：</p> 
<ul><li> <p>初始化： 设置 r 个空队列，Qr-1, Qr-2,…, Q0</p> </li><li> <p>按照各个 关键字位 权重递增的次序（个、十、百），对 d 个关键字位分别做“分配”和“收集”</p> </li><li> <p>分配：顺序扫描各个元素，若当前处理的关键字位=x，则将元素插入 Qx 队尾</p> </li><li> <p>收集：把 Qr-1, Qr-2,…, Q0 各个队列中的结点依次出队并链接</p> </li></ul> 
<p>基数排序得到递增序列的过程如下：</p> 
<ul><li> <p>初始化： 设置 r 个空队列，Q0, Q1,…, Qr−1</p> </li><li> <p>按照各个 关键字位 权重递增的次序（个、十、百），对 d 个关键字位分别做“分配”和“收集”</p> </li><li> <p>分配：顺序扫描各个元素，若当前处理的关键字位=x，则将元素插入 Qx 队尾</p> </li><li> <p>收集：把 Q0, Q1,…, Qr−1 各个队列中的结点依次出队并链接</p> </li></ul> 
<h6><a id="_3924"></a>算法效率分析：</h6> 
<ul><li> <p>需要r个辅助队列，空间复杂度 = O®</p> </li><li> <p>一趟分配O(n)，一趟收集O®，总共 d 趟分配、收集，总的时间复杂度=O(d(n+r)）</p> </li><li> <p>稳定性：稳定</p> </li></ul> 
<h6><a id="_3932"></a>基数排序的应用：</h6> 
<ul><li> <p>例如：</p> 
  <ul><li> <p>某学校有10000名学生，将学生信息按照年龄递减排序</p> </li><li> <p>给十亿人的身份证号排序</p> </li></ul> </li><li> <p>基数排序擅长解决的问题：</p> 
  <ul><li> <p>数据元素的关键字可以方便地拆分为 d 组，且 d 较小</p> </li><li> <p>每组关键字的取值范围不大，即 r 较小</p> </li><li> <p>数据元素个数 n 较大</p> </li></ul> </li></ul> 
<h5><a id="_3948"></a>外部排序</h5> 
<h6><a id="_3950"></a>外存、内存的数据交换：</h6> 
<ul><li> <p>外存：</p> 
  <ul><li> <p>操作系统以“块”为单位对磁盘存储空间进行管理</p> </li><li> <p>如：每块大小 1KB各个磁盘块内存放着各种各样的数据</p> </li></ul> </li><li> <p>内存：</p> 
  <ul><li> <p>磁盘的读/写以“块”为单位</p> </li><li> <p>数据读入内存后才能被修改</p> </li><li> <p>修改完了还要写回磁盘</p> </li></ul> </li></ul> 
<h6><a id="_3966"></a>外部排序原理：</h6> 
<ul><li> <p>数据元素太多，无法一次全部读入内存进行排序</p> </li><li> <p>使用“归并排序”的方法，最少只需在内存或只能怪分配3块大小的缓冲区即可对任意一个大文件进行排序</p> </li><li> <p>”归并排序“要求各个子序列有序，每次读入两个块的内容，进行内部排序后写回磁盘</p> </li></ul> 
<p>构造初始“归并段”：</p> 
<p><img src="https://images2.imgbox.com/81/d7/J9LfJUmq_o.png" alt="img"></p> 
<p>若有N个记录，内存工作区可以容纳L个记录，则初始归并段数量=r=N/L</p> 
<p>第一趟归并：</p> 
<p><img src="https://images2.imgbox.com/5f/37/9zh4hKT6_o.png" alt="img"></p> 
<p>第二趟归并：</p> 
<p><img src="https://images2.imgbox.com/20/3d/cCJP1Vpu_o.png" alt="img"></p> 
<p>第三趟归并：</p> 
<p><img src="https://images2.imgbox.com/ad/80/HEDofhu7_o.png" alt="img"></p> 
<h6><a id="_3992"></a>时间开销分析：</h6> 
<p>外部排序时间开销=读写外存的时间+内部排序所需时间+内部归并所需时间</p> 
<h6><a id="_3996"></a>优化思路：</h6> 
<ul><li> <p>多路归并</p> 
  <ul><li> <p>采用多路归并可以减少归并趟数，从而减少磁盘I/O(读写)次数</p> </li><li> <p>对 r 个初始归并段，做k路归并，则归并树可用 k 叉树表示，若树高为h，则归并趟数 = h-1 = ⌈logkr⌉</p> </li><li> <p>推导：k叉树第h层最多有k^(h−1) 个结点，则r ≤ kh−1， (h-1)最小 = ⌈logkr⌉</p> </li><li> <p>k越大，r越小，归并趟数越少，读写磁盘次数越少</p> </li><li> <p>多路归并带来的负面影响：</p> 
    <ul><li> <p>k路归并时，需要开辟k个输入缓冲区，内存开销增加</p> </li><li> <p>每挑选一个关键字需要对比关键字（k-1）次，内部归并所需时间增加（可使用败者树优化）</p> </li></ul> </li><li> <p>减少初始归并段数量</p> 
    <ul><li>生成初始归并段的“内存工作区”越大，初始归并段越长</li></ul> </li></ul> </li></ul> 
<h5><a id="_4018"></a>败者树</h5> 
<h6><a id="_4020"></a>定义：</h6> 
<ul><li> <p>可视为一棵完全二叉树（多了一个头头）</p> </li><li> <p>k个叶结点分别是当前参加比较的元素，非叶子结点用来记忆左右子树中的“失败者”，而让胜者往上继续进行比较，一直到根结点。</p> </li><li> <p>即失败者留在这一回合，胜利者进入下一回合比拼</p> </li></ul> 
<h6><a id="_4028"></a>败者树在多路平衡归并中的应用：</h6> 
<p><img src="https://images2.imgbox.com/15/e8/JFxTogNU_o.png" alt="img"></p> 
<p><img src="https://images2.imgbox.com/04/d9/fVmGRm3o_o.png" alt="img"></p> 
<h6><a id="_4034"></a>败者树的存储结构：</h6> 
<p><img src="https://images2.imgbox.com/8c/99/l5EY9f49_o.png" alt="img"></p> 
<h5><a id="_4038"></a>置换-选择排序</h5> 
<ul><li> <p>使用置换-选择排序，可以让每个初始归并段的长度超过内存工作区大小的限制</p> </li><li> <p>设初始待排文件为FI，初始归并段输出文件为FO，内存工作区为WA，FO和WA的初始状态为空，WA可容纳w个记录。</p> </li><li> <p>置换-选择算法的步骤如下：</p> 
  <ul><li> <p>从FI输入w个记录到工作区WA。</p> </li><li> <p>从WA中选出其中关键字取最小值的记录，记为MINIMAX记录。</p> </li><li> <p>将MINIMAX记录输出到FO中去。</p> </li><li> <p>若FI不空，则从FI输入下一个记录到WA中。</p> </li><li> <p>从WA中所有关键字比MINIMAX记录的关键字大的记录中选出最小关键字记录，作为新的MINIMAX记录。</p> </li><li> <p>重复3）～5），直至在WA中选不出新的MINIMAX记录为止，由此得到一个初始归并段，输出一个归并段的结束标志到FO中去。</p> </li><li> <p>重复2）～6），直至WA为空。由此得到全部初始归并段。</p> </li></ul> </li></ul> 
<h5><a id="_4060"></a>最佳归并树</h5> 
<h6><a id="_4062"></a>引子：</h6> 
<ul><li> <p>归并过程中磁盘I/O次数=归并树的WPL*2</p> </li><li> <p>因此要让磁盘I/O次数最小，就要使归并树的WPL最小即构建一个哈夫曼树</p> </li></ul> 
<h6><a id="m_4068"></a>m叉最佳归并树的构造：</h6> 
<p><img src="https://images2.imgbox.com/8b/cb/7t8TJg7T_o.png" alt="img"></p> 
<p><img src="https://images2.imgbox.com/62/66/tDqFapZj_o.png" alt="img"></p> 
<ul><li> <p>注意：对于k叉归并，若初始归并段的数量无法构成严格的k叉归并树</p> </li><li> <p>则需要补充几个长度为0的“虚段”，再进行k叉哈夫曼树的构造</p> </li></ul> 
<h6><a id="_4078"></a>增加虚段的数量：</h6> 
<ul><li> <p>若（初始归并段数量 -1）% （k-1）= 0，说明刚好可以构成严格k叉树，此时不需要添加虚段</p> </li><li> <p>若（初始归并段数量 -1）% （k-1）= u ≠ 0，则需要补充 (k-1) - u 个虚段</p> </li></ul> 
<hr> 
<h3><a id="_4087"></a>数据结构算法</h3> 
<h4><a id="1_4088"></a>1.数组</h4> 
<h5><a id="11_4089"></a>1.1.将一个数组前后翻转</h5> 
<p><img src="https://images2.imgbox.com/38/62/GDCqNTe8_o.png" alt="img"></p> 
<pre><code class="prism language-c++">bool Delete_Min(int A[], n, &amp;min) {
    if (!n) return false;    //数组长度为0，返回false
    int temp = INT_MAX, m;    //INT_MAX为int类型的最大值
    for (int i = 0; i &lt; n; i++) {    //遍历数组，找到数组当前的最小元素
        if (A[i] &lt; temp) {
            temp = A[i];    //更新数组最小值
            m = i;    //记录数组下标
        }
    }
    min = temp;    //min保存最小值
    A[m] = A[n - 1];    //m用数组中最后一个元素替换
    return true;
}
</code></pre> 
<h5><a id="12x_4109"></a>1.2.删除数组中值为x的元素</h5> 
<p><img src="https://images2.imgbox.com/28/a3/C504rY5u_o.png" alt="img"></p> 
<pre><code class="prism language-c++">int DeleteX(int A[], x, n){
    int i = 0, j = 0;
    for (i = 0; i &lt; n; i++) {
        if (A[i] != x) {    //当前元素的值不为x
            A[j] = A[i];    //将其保存到数组下标为j的元素中
            j++;
        }
    }
    n = j;    
    return n;    //返回删除x后的数组元素个数
}
</code></pre> 
<h5><a id="13_4127"></a>1.3.将两个有序数组合并成一个有序数组</h5> 
<p><img src="https://images2.imgbox.com/d0/2c/Y3Xdh9Zq_o.png" alt="img"></p> 
<pre><code class="prism language-c++">int* Merge(int A[], B[], lenA, lenB) {
    int *C = (int*)malloc((lenA + lenB) * sizeof(int));
    int a = 0, b = 0, c = 0;
    for (c = 0; a &lt; lenA &amp;&amp; b &lt; lenB; c++) {    //选择两个数组中的较小值放入数组C中
        if (A[a] &lt;= B[b]) C[c] = A[a++];
        else C[c] = B[b++];
    }
    while (a &lt; lenA) C[c++] = A[a++];    //将剩余数组放入C中
    while (b &lt; lenB) C[c++] = B[b++];
    return C;
}
</code></pre> 
<h5><a id="14_4145"></a>1.4.真题</h5> 
<p><img src="https://images2.imgbox.com/f5/a3/HMtQev37_o.png" alt="img"></p> 
<pre><code class="prism language-c++">void ans(int A[], n, p){
    int B[n], i, j;
    for (i = 0, j = p; j &lt; n; i++, j++) B[i] = A[j];    //数组后部分前移
    for (j = 0; j &lt; p; i++, j++) B[i] = A[j];    //数组前部分后移
    for (i = 0; i &lt; n; i++) cout &lt;&lt; B[i];    //输出循环前移后的数组
}
</code></pre> 
<p><img src="https://images2.imgbox.com/ee/1a/21i8rI6y_o.png" alt="img"></p> 
<pre><code class="prism language-c++">int res(int A[], int B[], int n){
    int i, j, k, mid;
    for (i = 0, j = 0, k = 0; k &lt; n; k++){
        if (A[i] &lt;= B[j]) {    //当前A数组的元素小，保存A[i]
            mid = A[i];
            i++;    
        } else {    //当前B数组的元素小，保存B[j]
            mid = B[j];
            j++;
        }
    }
    return mid;
}
</code></pre> 
<pre><code class="prism language-c++">void Qsort(int A[], L, R){
    if (L &gt;= R) return;    //当前数组区间&lt;= 1，返回
    随机选择数组中一个元素和A[L]交换    //快速排序优化，使得基准元素的选取随机
    int key = A[L], i = L, j = R;    //选择A[L]作为基准元素，i和j分别为左右指针
    while(i &lt; j) {
        while (i &lt; j &amp;&amp; key &lt; A[j]) j--;
        while (i &lt; j &amp;&amp; A[i] &lt;= key) i++;
        if (i &lt; j) swap(A[i], A[j]);    //交换A[i]和A[j]
    }
    swap(A[i], A[L]);
    Qsort(A, L, i - 1);    //递归排序左区间
    Qsort(A, i + 1, R);    //递归排序右区间
}
 
int ans(int A[], int B[], int n) {
    int C[2n], i, j;
    for (i = 0; i &lt; n; i++) C[i] = A[i];    //复制数组A和数组B的元素
    for (j = 0; j &lt; n; i++, j++) C[i] = B[j];
    Qsort(C, 0, 2n - 1);    //对数组C进行快速排序
    return C[n - 1];    //返回中位数
}
</code></pre> 
<p><img src="https://images2.imgbox.com/26/9b/CE3fabwW_o.png" alt="img"></p> 
<p><img src="https://images2.imgbox.com/32/f1/o7a53tbY_o.png" alt="img"></p> 
<pre><code class="prism language-C++">int ans(int A[], n){
    int count[n];
    for (int i = 0; i &lt; n; i++) count[i] = 0;    //初始化count数组
    //遍历A数组，其元素的值作为count数组下标的元素+1，表示该元素在A数组中出现次数
    for (int i = 0; i &lt; n; i++) count[A[i]]++;   
    for (int i = 0; i &lt; n; i++) {    //当前元素出现次数符合主元素定义
        if (count[i] &gt; n / 2) return i;    //返回i，即该元素的值
    }
    return -1;    //没有元素符合主元素定义
}
</code></pre> 
<p><img src="https://images2.imgbox.com/aa/f9/qD87wKQW_o.png" alt="img"></p> 
<pre><code class="prism language-c++">int ans(int A[], n) {
    bool B[n + 2];    //B用来标记数组中出现的正整数
    for (int i = 0; i &lt; n; i++) B[i] = false;    //初始化B数组
    int count = 0;
    for (int i = 0; i &lt; n; i++) {
        if (A[i] &gt; 0 &amp;&amp; A[i] &lt;= n){    //当前数组元素为正，并且在数组B的下标范围内
            count = A[i];
            B[count] = true;
        }   
    }
    for (int i = 1; i &lt; n; i++) {
        if (B[i] == false) return i;    //返回数组B中第一个false的元素下标
    }
}
</code></pre> 
<pre><code class="prism language-c++">void Qsort(int A[], L, R) {
	if (L &gt;= R) return;	//数组区间&lt;= 1，返回
	随机选择数组中一元素和A[L]交换;//快排优化，使得基准元素的选取随机
	int key = A[L], i = L, j = R;	//A[L]为基准元素，ij为左右指针
	while (i &lt; j) {
		while (i &lt; j &amp;&amp; key &lt; A[j]) j--;
		while (i &lt; j &amp;&amp; A[i] &lt;= key) i++;
		if (i &lt; j) Swap(A[i], A[j]);	//交换A[i]和A[j]
	}
	Swap(A[L], A[i]);
	Qsort(A, L, i - 1);	//递归排序左区间
	Qsort(A, i + 1, R);	//递归排序右区间
}
 
int ans(int A[], n) {
	Qsort(A, 0, n - 1);	//快速排序
	int i = 0;
	while (A[i] &lt;= 0) i++;	//找到数组中第一个大于0的元素
	if (n == i) return 1;	//数组中没有元素大于0，返回1
	else {
		if (A[i] != 1) return 1;	//第一个整数不是1，则返回1
		else {    //第一个整数为1，找到数组中正整数第一个间断点
			int j = i + 1;
			while (j &lt; n) {
                if (a[j] == a[j - 1]) j++;    //相邻元素相等
                else if (a[j] == a[j - 1] + 1) j++;    //相邻元素是连续数
                else return A[j - 1] + 1;    //相邻元素是间断点
            }//while
		}//else
	}//else
}
</code></pre> 
<p><img src="https://images2.imgbox.com/47/5a/PVUX4MUX_o.png" alt="img"></p> 
<pre><code class="prism language-c++">int Dis(int a, b, c){
    int res = abs(a - b) + abs(a - c) + abs(b - c);    //计算绝对值
    return res;
}
 
int Ans(int A[], int B[], int C[], int n1, int n2, int n3){
    int min = INT_MAX, i, j, k, temp;    //min取整型的最大值
    for (int i = 0; i &lt; n1; i++) {    //循环遍历数组A
        for (int j = 0; j &lt; n2; j++) {    //循环遍历数组B
            for (int k = 0; k &lt; n3; k++) {    //循环遍历数组C
                temp = Dis(A[i], B[j], C[k]);
                if (temp &lt; min) min = temp;    //当前元素之间的距离更小，更新最小距离
            }//for
        }//for
    }//for
    return min;    //返回最小距离
}
</code></pre> 
<h4><a id="2_4292"></a>2.链表</h4> 
<h5><a id="21_4294"></a>2.1.链表的数据结构定义</h5> 
<h6><a id="211_4296"></a>2.1.1.单链表</h6> 
<pre><code class="prism language-C++">typedef struct LNode {
    struct LNode *next;
    int data;
}LNode, *LinkList;
</code></pre> 
<h6><a id="212_4305"></a>2.1.2.双链表</h6> 
<pre><code class="prism language-C++">typedef struct LNode {
    struct LNode *prior, *next;
    int data;
}LNode, *LinkList;
</code></pre> 
<h5><a id="22_4314"></a>2.2.链表的操作</h5> 
<h6><a id="221_4316"></a>2.2.1.头插法（插入到链表头）</h6> 
<pre><code class="prism language-c++">void HeadInsert(LinkList &amp;L, int key) {
    LNode *p = (LNode*)malloc(sizeof(LNode));
    p-&gt;data = key;
    p-&gt;next = L-&gt;next;
    L-&gt;next = q;
}
</code></pre> 
<h6><a id="222_4327"></a>2.2.2.尾插法（插入到链表尾）</h6> 
<pre><code class="prism language-C++">void TailInsert(LinkList &amp;L, int key) {
    LNode *q = (LNode*)malloc(sizeof(LNode);
    q-&gt;data = key;
    q-&gt;next = NULL;
    LNode *p = L-&gt;next, *pre = L;
    while (!p) {
        pre = p;
        p = p-&gt;next;
    }
    pre-&gt;next = q;
}
</code></pre> 
<h6><a id="223_4343"></a>2.2.3.链表逆置（头插法实现）</h6> 
<pre><code class="prism language-c++">void Reverse(LinkList &amp;L) {
    LNode *p = L-&gt;next, *q = NULL;
    L-&gt;next = NULL;    //将L表断开
    while (!p) {
        q = p-&gt;next;    //q指向p的下一个结点
        p-&gt;next = L-&gt;next;    //头插法
        L-&gt;next = p;
        p = q;
    }
}
</code></pre> 
<h6><a id="224_4358"></a>2.2.4.链表的遍历</h6> 
<pre><code class="prism language-c++">LNode *p = L-&gt;next;
while (!p) {
    visit(p);
    p = p-&gt;next;
}
</code></pre> 
<h6><a id="225_4368"></a>2.2.5.链表的删除</h6> 
<pre><code class="prism language-c++">void Delete(LinkList &amp;L, int &amp;key) {
    LNode *p = L-&gt;next, *pre = L;
    移动p和pre到指定结点    //pre指向p的前驱结点
    key = p-&gt;data;    //key保存p的data领
    pre-&gt;next = p-&gt;next;    //pre的next指针指向p的后继节点
    free(p);
}
</code></pre> 
<h5><a id="23_4380"></a>2.3.链表算法题</h5> 
<h6><a id="231x_4382"></a>2.3.1.删除值为x的结点</h6> 
<pre><code class="prism language-C++">void DeleteX(LinkList &amp;L, int x){
    LNode *p = L-&gt;next, *pre = L;
    while (p) {
        if (p-&gt;data == x) {    //当前元素值为x
            pre-&gt;next = p-&gt;next;
            free(p);
            p = pre-&gt;next;
        } else {    //当前元素值非x，p和pre向后移动
            p = p-&gt;next;
            pre = pre-&gt;next;
        }
    }
}
</code></pre> 
<h6><a id="232_4400"></a>2.3.2.单链表就地逆置</h6> 
<p><img src="https://images2.imgbox.com/2b/0c/5Mia1XkM_o.png" alt="img"></p> 
<pre><code class="prism language-C++">void reverse(LinkList &amp;L){
    LNode *p = L-&gt;next, *q;
    L-&gt;next = NULL;    //断链
    while (p) {
        q = p-&gt;next;    //q指向p的下一个结点
        p-&gt;next = L-&gt;next;    //头插法
        L-&gt;next = p;
        p = q;
    }
}
</code></pre> 
<h6><a id="233_4417"></a>2.3.3.将链表排序</h6> 
<p><img src="https://images2.imgbox.com/bf/dc/YfO5bOum_o.png" alt="img"></p> 
<pre><code class="prism language-C++">LNode *Sort(LinkList L) {
	LNode* p = (LNode*)malloc(sizeof(Lnode));
	p-&gt;next = NULL;
	LNode* t = L-&gt;next, * tpre = L, *min, *minpre, *r = p;
	int m = INT_MAX;
	while (t) {
		while (t) {    //遍历链表
			if (t-&gt;data &lt; m) {	//更新最小值结点
				min = t;
				minpre = tpre;
				m = t-&gt;data;
			}//if
            tpre = t;
            t = t-&gt;next;
		}//while
		minpre-&gt;next = min-&gt;next;	//将min从L中删除
		r-&gt;next = min;	//将min插入p
		r = min;	//r后移
		m = INT_MAX;	//重新初始化
		t = L-&gt;next;
		tpre = L;
	}//while
	r-&gt;next = NULL;
	return p;
}
</code></pre> 
<h6><a id="234_4449"></a>2.3.4.拆分链表</h6> 
<p><img src="https://images2.imgbox.com/b2/7d/NzYb6VMC_o.png" alt="img"></p> 
<pre><code class="prism language-C++">LNode* (LinkList &amp;L) {
    LNode *p = (LNode*)malloc(sizeof(LNode);
    p-&gt;next = NULL;    //p为新链的头结点
    LNode *q = L-&gt;next, *t = NULL, *r = L;
    r-&gt;next = NULL;    //r结点始终指向L的最后一个结点
    while (q) {
        t = q-&gt;next;
        r-&gt;next = q;    //奇数结点尾插法
        r = q;
        q = t;
        t = q-&gt;next;
        q-&gt;next = p-&gt;next;    //偶数节点头插法
        p-&gt;next = q;
        q = t;
    }
    r-&gt;next = NULL;    //将r的next指针置空
    return p;
}
</code></pre> 
<h6><a id="235_4474"></a>2.3.5.删除链表中的重复元素</h6> 
<p><img src="https://images2.imgbox.com/ba/f2/ezjLRvfb_o.png" alt="img"></p> 
<pre><code class="prism language-c++">void Delete(LinkList &amp;L) {
    LNode *p = L-&gt;next;
    while (p) {
        LNode *post = p-&gt;next;    //post指向p的下一个结点
        while (post &amp;&amp; post-&gt;data == p-&gt;data) {    //post存在并且值和p相等时
            LNode *temp = post;    //temp指向post
            post = post-&gt;next;    //post向后移动
            p-&gt;next = post;    //将p的下一个结点修改为post
            free(temp);
        }
        p = p-&gt;next;
    }
}
</code></pre> 
<h6><a id="236_4494"></a>2.3.6.将两个递增链表合并成一个递减链表</h6> 
<p><img src="https://images2.imgbox.com/cf/ca/AbrAOMKm_o.png" alt="img"></p> 
<pre><code class="prism language-C++">void Merge(LinkList &amp;L1, LinkList L2) {
    LNode *p = L1-&gt;next, *q = L2-&gt;next, *temp;
    L1-&gt;next = NULL;    //L1断链
    while (p &amp;&amp; q) {
        if (p-&gt;data &lt;= q-&gt;data) {    //当前p指向的元素更小
            temp = p-&gt;next;    //temp指向p的下一个结点
            p-&gt;next = L1-&gt;next;    //将p用头插法插入L1
            L1-&gt;next = p;
            p = temp;    //p指向temp
        } else {    //当前q指向的元素更小
            temp = q-&gt;next;
            q-&gt;next = L1-&gt;next;
            L1-&gt;next = q;
            q = temp;
        }
    }//while
    while (p) {    //将剩余节点插入L1
        temp = p-&gt;next;
        p-&gt;next = L1-&gt;next;
        L1-&gt;next = p;
        p = temp;
    }
    while (q) {
        temp = q-&gt;next;
        q-&gt;next = L1-&gt;next;
        L1-&gt;next = q;
        q = temp;
    }
    return;
}
</code></pre> 
<h6><a id="237_4531"></a>2.3.7.将两个递增链表合并为一个递增链表</h6> 
<pre><code class="prism language-C++">LNode *Merge(LinkList L1, LinkList L2) {
    LNode *p = L1-&gt;next, *q = L2-&gt;next, *r, *temp;
    LNode *L = (LNode*)malloc(sizeof(LNode));
    L-&gt;next = NULL;
    r = L;
    while (p &amp;&amp; q) {
        if (p-&gt;data &lt;= q-&gt;data) {    //当前p指向的结点小于等于q
            temp = p-&gt;next;
            r-&gt;next = p;    //p尾插法插入L中
            r = p;
            p = temp;
        } else {
            temp = q-&gt;next;
            r-&gt;next = q;
            r = q;
            q = temp;
        }
    }
    while (p) {    //插入剩余结点
        temp = p-&gt;next;
        r-&gt;next = p;
        r = p;
        p = temp;
    }
    while (q) {
        temp = q-&gt;next;
        r-&gt;next = q;
        r = q;
        q = temp;
    }
    r-&gt;next = NULL;    //将r的next指针置空
    return L;
}
</code></pre> 
<h6><a id="238_4569"></a>2.3.8.判断链表是否对称</h6> 
<p><img src="https://images2.imgbox.com/c1/c3/JTgUnvGq_o.png" alt="img"></p> 
<pre><code class="prism language-c++">bool ans(LinkList L) {
	LNode* post = L-&gt;prior, * pre = L-&gt;next;    //前后指针
    //表中元素为奇数时，终止条件为两者移动到同一结点
    //表中元素为偶数时，终止条件为两者后指针的next指向前指针
	while (post != pre &amp;&amp; post-&gt;next != pre) {    
		if (post-&gt;data != pre-&gt;data) return false;    //前后指针的指针域不相等
		pre = pre-&gt;next;    //前指针前移
		post = post-&gt;prior;    //后指针后移
	}
    //表对称
	return true;
}
</code></pre> 
<pre><code class="prism language-C++">bool ans(LinkList L) {
	LNode* p = L-&gt;next;
	int len = 0;    //记录表中的元素个数
	while (p != L) {
		p = p-&gt;next;
		len++;
	}
	int a = (int*)malloc(len * sizeof(int));    //定义跟链表结点个数相等的长度的数组
	len = 0;
	p = L-&gt;next
	while (p != L) {    //遍历链表，用数组保存链表中每个结点的值
		a[len] = p-&gt;next;
		p = p-&gt;next;
	}
    //遍历数组，前后指针指向元素的值不相等，返回false
	for (int i = 0, j = len - 1; i &lt; j; i++, j--) {
		if (a[i] != a[j]) return false;
	}
	return true;
}
</code></pre> 
<h6><a id="239_4611"></a>2.3.9.依次输出链表中结点值最小的元素</h6> 
<p><img src="https://images2.imgbox.com/a7/ba/C8SNAF6R_o.png" alt="img"></p> 
<pre><code class="prism language-c++">void DeleteMin(LinkList &amp;L) {
    LNode *p = L-&gt;next, *ppre = L-&gt;next, *min, *minpre;
    while (L-&gt;next != L) {
        p = L-&gt;next;
        ppre = L;
        int tempMin = INT_MAX;    //当前最小值
        while (p != L) {
            if (p-&gt;data &lt; tempMin) {    //当前结点值更小，更新最小结点
                min = p;
                minpre = ppre;
            }    //p向后移动
            ppre = p;
            p = p-&gt;next;
        }
        cout &lt;&lt; min-&gt;data;    //输出最小结点的值
        minpre-&gt;next = min-&gt;next;    //删除min结点
        free(min);
    }//while
    free(L);    //删除头结点
}
</code></pre> 
<h6><a id="2310_4638"></a>2.3.10.真题</h6> 
<p><img src="https://images2.imgbox.com/4a/c2/V6DKn2hZ_o.png" alt="img"></p> 
<pre><code class="prism language-c++">void ans(LinkList L, int k){
    LNode *p = L-&gt;link, *q = L-&gt;link;
    for (int i = 0; i &lt; k; i++) p = p-&gt;link;    //p指针向后移动k个结点
    while (p) {
        p = p-&gt;link;
        q = q-&gt;link;
    }
    cout &lt;&lt; q-&gt;data;
}
</code></pre> 
<p><img src="https://images2.imgbox.com/bf/99/4Jede7Yw_o.png" alt="img"></p> 
<pre><code class="prism language-C++">void ans(LinkList str1, LinkList str2) {
	LNode *p = str1-&gt;next, *q = str2-&gt;next;
	int len1 = 0, len2 = 0;
	while (p) {    //遍历str1，得到str1的长度
		len1++;
		p = p-&gt;next;
	}
	while (q) {    //遍历str2，得到str2的长度
		len2++;
		q = q-&gt;next;
	}
	int len = abs(len1 - len2);    //得到两表长度之差
	p = str1-&gt;next;    //重置pq指向第一个结点
	q = str2-&gt;next;
	if (len1 &gt;= len2) {    //长表向前移动，使得两表剩余元素相等
		for (int i = 0; i &lt; len; i++) p = p-&gt;next;
	}
	else {
		for (int i = 0; i &lt; len; i++) q = q-&gt;next;
	}
	while (p) {    //遍历剩余结点，找到两者指向的第一个共同结点
		if (p == q) return p;
		p = p-&gt;next;
		q = q-&gt;next;
	}
	return NULL;    //两者没有共同后缀
}
</code></pre> 
<p><img src="https://images2.imgbox.com/c1/57/cjenziXv_o.png" alt="img"></p> 
<pre><code class="prism language-c++">void ans(LinkList &amp;L){
    bool A[n + 1];    //长度为n + 1的数组，用来标记该数是否出现过
    for (int i = 0; i &lt; n + 1; i++) A[i] = false;    //初始化A数组
    LNode *p = head-&gt;next, *pre = head;
    while (p) {
        int t = abs(p-&gt;data);    //取当前结点值的绝对值
        if (A[t]) {    //该值出现过，删除该结点
            LNode *r = p-&gt;next;
            pre-&gt;next = r;
            free(p);
            p = r;
        } else {    //该值没有出现过，在数组A中标记该值，p和pre向后移动
            A[t] = true;
            pre = p;
            p = p-&gt;next;
        }
    }//while
}
</code></pre> 
<p><img src="https://images2.imgbox.com/63/e8/dvaIsalK_o.png" alt="img"></p> 
<pre><code class="prism language-c++">void ans(NODE *L) {
	NODE* p = L-&gt;next, *f = L-&gt;next, *s = L-&gt;next, *q, *t;
	while (f-&gt;next-&gt;next &amp;&amp; f-&gt;next) {	//找到前半链的最后一个结点
		f = f-&gt;next-&gt;next;    //快指针移动两个结点
		s = s-&gt;next;    //慢指针移动一个结点
	}
	q = s-&gt;next;	//q指向后半链的第一个结点
	s-&gt;next = NULL;	//前半链后半链断开
	LNode* post = (NODE*)malloc(sizeof(NODE));
	post-&gt;next = NULL;
	while (q) {	//后半链逆置
		t = q-&gt;next;
		q-&gt;next = post-&gt;next;
		post-&gt;next = q;
		q = t;
	}
	q = post-&gt;next;	//q指向逆置后的后半链的第一个结点
	while (q) {
		r = q-&gt;next;	//r指向后半链的下一个结点
		t = p-&gt;next;	//t指向前半链下一个插入位置
		q-&gt;next = p-&gt;next;
		p-&gt;next = q;
		q = r;	//重置pq
		p = t;
	}
}
</code></pre> 
<h4><a id="3_4740"></a>3.栈</h4> 
<h5><a id="31_4742"></a>3.1.栈的数据结构定义</h5> 
<h6><a id="311_4744"></a>3.1.1.顺序栈</h6> 
<pre><code class="prism language-c++">#define MAXSIZE 100
 
typedef struct Stack {
    int data[MAXSIZE];
    int top = -1;
}Stack;
</code></pre> 
<h6><a id="312_4755"></a>3.1.2.链栈</h6> 
<pre><code class="prism language-c++">typedef struct LStack {
    int data;
    struct LStack *next;
}SNode, *LStack;
</code></pre> 
<h5><a id="32_4764"></a>3.2.顺序栈的操作</h5> 
<h6><a id="321_4766"></a>3.2.1.栈的初始化</h6> 
<pre><code class="prism language-C++">void InitStack (Stack &amp;S) {
    S.top = -1;
}
</code></pre> 
<h6><a id="322_4774"></a>3.2.2.入栈</h6> 
<pre><code class="prism language-C++">bool Push(Stack &amp;S, int key) {
    if (S.top == MAXSIZE - 1) return false;    //栈满
    S.data[++top] = key;
    return true;
}
</code></pre> 
<h6><a id="323_4784"></a>3.2.3.出栈</h6> 
<pre><code class="prism language-c++">bool Pop (Stack &amp;S, int &amp;key) {
    if (S.top == -1) return false;    //栈空
    key = S.data[top--];
    return true;
}
</code></pre> 
<h6><a id="324_4794"></a>3.2.4.判断栈空</h6> 
<pre><code class="prism language-C++">bool IsEmpty (Stack S) {
    if (S.top == -1) return true;
    else return false;
}
</code></pre> 
<h5><a id="33_4803"></a>3.3.链栈的基本操作</h5> 
<h6><a id="331_4805"></a>3.3.1.初始化</h6> 
<pre><code class="prism language-C++">void InitStack (LStack &amp;S) {
    SNode *s = (SNode*)malloc(Sizeof(SNode));
    S-&gt;next = NULL;
}
</code></pre> 
<h6><a id="332_4814"></a>3.3.2.入栈</h6> 
<pre><code class="prism language-C++">void Push (LStack &amp;S, int key) {
    SNode *p = (SNode*)malloc(sizeof(SNode));
    p-&gt;data = key;
    p-&gt;next = S-&gt;next;    //头插法
    S-&gt;next = p;
}
</code></pre> 
<h6><a id="333_4825"></a>3.3.3.出栈</h6> 
<pre><code class="prism language-C++">bool Pop (LStack &amp;S, int &amp;key) {
    if (S-&gt;next == NULL) return false;    //栈空
    SNode *p = S-&gt;next;
    key = p-&gt;data;    //key保存栈顶元素的值
    S-&gt;next = p-&gt;next;
    free(p);
}
</code></pre> 
<h6><a id="334_4837"></a>3.3.4.判断栈空</h6> 
<pre><code class="prism language-C++">bool IsEmpty(LStack &amp;S) {
    if (S-&gt;next == NULL) return true;
    else return false;
}
</code></pre> 
<h4><a id="4_4846"></a>4.队列</h4> 
<h5><a id="41_4848"></a>4.1.队列的数据结构定义</h5> 
<h6><a id="411_4850"></a>4.1.1.顺序队列</h6> 
<pre><code class="prism language-C++">#define MAXSIZE 100
typedef struct Queue {
    int data[MAXSIZE];
    int front, rear;
}Queue;
</code></pre> 
<h6><a id="412_4860"></a>4.1.2.链式队列</h6> 
<pre><code class="prism language-C++">typedef struct LNode{
    struct LNode *next;
    int data;
}LNode;
 
typedef struct Queue{
    LNode *front, *rear;
}Queue;
</code></pre> 
<h5><a id="42_4873"></a>4.2.顺序队列的基本操作</h5> 
<h6><a id="421_4875"></a>4.2.1.初始化</h6> 
<pre><code class="prism language-c++">void InitQueue(Queue &amp;Q){
    Q.front = Q.rear = 0;
}
</code></pre> 
<h6><a id="422_4883"></a>4.2.2.入队</h6> 
<pre><code class="prism language-C++">bool EnQueue(Queue &amp;Q, int key){
    if (Q.front == (Q.rear + 1) % MAXSIZE) return false;    //队满
    Q.data[rear] = key;
    Q.rear = (Q.rear + 1) % MAXSIZE;
    return true;
}
</code></pre> 
<h6><a id="423_4894"></a>4.2.3.出队</h6> 
<pre><code class="prism language-C++">bool DeQueue(Queue &amp;Q, int &amp;key){
    if (Q.rear == Q.front) return false;    //队空
    key = Q.front;
    Q.front = (Q.front + 1) % MAXSIZE;
    return true;
}
</code></pre> 
<h6><a id="424_4905"></a>4.2.4.判断队空</h6> 
<pre><code class="prism language-C++">bool IsEmpty(Queue Q){
    if (Q.front == Q.rear) return true;
    else return false;
}
</code></pre> 
<h5><a id="43_4914"></a>4.3.链式队列的基本操作</h5> 
<h6><a id="431_4916"></a>4.3.1.初始化</h6> 
<pre><code class="prism language-C++">void InitQueue(Queue &amp;Q){
    Q.front = Q.rear = (LNode*)maloc(sizeof(LNode));
    Q.front-&gt;next = NULL;
}
</code></pre> 
<h6><a id="432_4925"></a>4.3.2.入队</h6> 
<pre><code class="prism language-C++">void Queue(Queue &amp;Q, int key){
    LNode *p = (LNode*)malloc(sizeof(LNode));    //申明一个新结点
    p-&gt;data = key;
    p-&gt;next = NULL;
    Q.rear-&gt;next = p;    //尾插法插入到rear后
    Q.rear = p;    //更新rear
}
</code></pre> 
<h6><a id="433_4937"></a>4.3.3.出队</h6> 
<pre><code class="prism language-C++">bool DeQueue(Queue &amp;Q, int &amp;key){
    if (Q.front == Q.rear) return false;    //队空
    LNode *p = Q.front-&gt;next;
    key = p-&gt;data;    //保存队首元素的数据
    Q.front-&gt;next = p-&gt;next;
    if (Q.rear == p) Q.rear = Q.front;    //队列中只有一个元素
    free(p);
    return true;
}
</code></pre> 
<h6><a id="434_4951"></a>4.3.4.判断队空</h6> 
<pre><code class="prism language-C++">bool IsEmpty(Queue Q){
    if (Q.rear == Q.front) return true;
    else return false;
}
</code></pre> 
<h4><a id="5_4960"></a>5.树</h4> 
<h5><a id="51_4962"></a>5.1.树的数据结构定义</h5> 
<h6><a id="511_4964"></a>5.1.1.二叉树的链式存储</h6> 
<pre><code class="prism language-C++">typedef struct BiTree{
    sturct BiTree *lchild, *rchild;    //左右孩子指针
    int value;    //结点数据
}BiTNode, *BiTree;
</code></pre> 
<h6><a id="512_4973"></a>5.1.2.二叉树的顺序存储</h6> 
<pre><code class="prism language-C++">#define MAXSIZE 100
 
typedef struct TreeNode{
    int value;    //结点数据
    bool IsEmpty;    //该结点是否存在
}TreeNode;
 
void InitTree(TreeNode T[], int len){
    for (int i = 0; i &lt; len; i++) T[i].IsEmpty = true;    //将该结点初始化为空结点
}
 
 
int main(){
    TreeNode T[MAXSIZE];    //申明一个长度为MAXSIZE的TreeNode数组
    InitTree(T);    //初始化树
    ...
}
</code></pre> 
<h6><a id="513_4995"></a>5.1.3.双亲表示法</h6> 
<pre><code class="prism language-c++">#define MAXSIZE 100    //树中最多结点数
 
typedef struct TreeNode{
    int data;    //结点数据
    int parent;    //该结点的双亲结点在数组的下标
}TreeNode;
 
typedef struct Tree{
    TreeNode T[MAXSIZE];    //长度为MAXSIZE的TreeNode类型的数组
    int treeNum;    //结点数
}Tree;
</code></pre> 
<p><img src="https://images2.imgbox.com/ed/51/Jt2TMCVW_o.png" alt="img"></p> 
<p><img src="https://images2.imgbox.com/62/91/In0fDijg_o.png" alt="img"></p> 
<h6><a id="514_5015"></a>5.1.4.孩子表示法</h6> 
<pre><code class="prism language-C++">#define MAXSIZE 100
 
//孩子结点
typedef struct Child{
    int index;    //该结点的编号
    struct Child *next;    //指向该结点的下一个孩子结点的指针
}Child;
 
//结点信息
typedef struct TreeNode{
    Child *firstTNode;    //指向该结点的第一个孩子结点的指针
    int data;    //该结点数据
}TreeNode;
 
TreeNode T[MAXSIZE];    //定义一个长度为MAXSIZE的树
</code></pre> 
<p><img src="https://images2.imgbox.com/f8/d1/xNSqTRYr_o.png" alt="img"></p> 
<h6><a id="515_5037"></a>5.1.5.孩子兄弟表示法</h6> 
<pre><code class="prism language-C++">#define MAXSIZE 100
 
typedef struct CSNode{
    struct CSNode *firstChild, *nextSibling;    //指向第一个孩子和右兄弟节点
    int data;    //该结点数据
}CSNode;
</code></pre> 
<p><img src="https://images2.imgbox.com/89/ff/SN7ODF8T_o.png" alt="img"></p> 
<p><img src="https://images2.imgbox.com/a5/a2/ds82VPZQ_o.png" alt="img"></p> 
<h6><a id="516_5052"></a>5.1.6.线索二叉树</h6> 
<pre><code class="prism language-C++">typedef struct ThreadNode{
    struct ThreadNode *lchild, *rchild;    //左右孩子指针
    int ltag, rtag;    //左右线索标志
    int data;    //结点数据    
}ThreadNode, *ThreadTree;
</code></pre> 
<h5><a id="52_5062"></a>5.2.二叉树的基本操作</h5> 
<h6><a id="521_5064"></a>5.2.1.先序遍历</h6> 
<pre><code class="prism language-C++">void PreOrder(BiTree T){
    if (T) {
        visit(T);
        PreOrder(T-&gt;lchild);
        PreOrder(T-&gt;rchild);
    }
}
</code></pre> 
<h6><a id="522_5076"></a>5.2.2.中序遍历</h6> 
<pre><code class="prism language-C++">void InOrder(BiTree T){
    if (T) {
        InOrder(T-&gt;lchild);
        visit(T);
        InOrder(T-&gt;rchild);
    }
}
</code></pre> 
<h6><a id="523_5088"></a>5.2.3.后序遍历</h6> 
<pre><code class="prism language-C++">void PostOrder(BiTree T){
    if (T) {
        PostOrder(T-&gt;lchild);
        PostOrder(T-&gt;rchild);
        visit(T);
    }
}
</code></pre> 
<pre><code class="prism language-C++">typedef struct Stack{
    BiTNode *Node[MAXSIZE];
    int top;
}Stack;
 
void PostOrder(BiTree T){
    Stack S;
    InitStack(S);
    BiTNode *p, *pre;
    while (p || !IsEmpty(S)）{
        if (p) {    //往左下走到尽头
            Push(p);    //p入栈
            p = p-&gt;lchild;    //进入其左子树
        } else {
            GetTop(S, p);    //查看栈顶元素
            //栈顶元素的右孩子存在，并且不是上一个访问的结点
            if (p-&gt;rchild &amp;&amp; p-&gt;rchild != pre) {
                p = p-&gt;rchild;    //进入栈顶元素的右子树
                Push(p);    //该结点入栈
                p = p-&gt;lchild;    //进入该结点左子树
            } else {    //栈顶元素的右孩子被访问过
                Pop(S, p);    //弹出栈顶元素
                visit(p);    //访问该结点
                pre = p;    //用pre标记该结点
                p = NULL;    //将p置空
            }//if
                
        }//if
    }//whil
}
</code></pre> 
<h6><a id="524_5133"></a>5.2.4.层次遍历</h6> 
<pre><code class="prism language-C++">void LevelOrder(BiTree T){
    InitQueue(Q);
    EnQueue(Q, T);
    BiTNode *p;
    while (!IsEmpty(Q)) {
        DeQueue(Q, p);
        visit(p);
        if (p-&gt;lchild) EnQueue(Q, p-&gt;lchild);
        if (p-&gt;rchild) EnQueue(Q, p-&gt;rchild);
    }
}
</code></pre> 
<h5><a id="53_5149"></a>5.3.并查集</h5> 
<h6><a id="531_5151"></a>5.3.1.并查集的定义和初始化</h6> 
<pre><code class="prism language-C++">#define MAXSIZE 100
int UFSet[MAXSIZE];    //并查集通过数组表示
 
void InitSet(int S[]){
    for(int i = 0; i &lt; MAXSIZE; i++) S[i] = -1;
}
</code></pre> 
<h6><a id="532FIND_5162"></a>5.3.2.FIND操作</h6> 
<pre><code class="prism language-C++">//FIND操作用于查找该结点的所属集合
int Find(int S[], int x) {
    while (S[x] &gt;= 0) x = S[x];    //递归寻找直到该结点的值为负数（该树的根节点）
    return x;
}
</code></pre> 
<h6><a id="533UNION_5172"></a>5.3.3.UNION操作</h6> 
<pre><code class="prism language-C++">void Union(int S[], root1, root2) {
    //要求root1和root2是不同的集合
    if (root1 == root2) return;
    //将root2合并到root1中
    S[root2] = root1;
}
</code></pre> 
<h6><a id="534FIND_5183"></a>5.3.4.FIND优化——压缩路径</h6> 
<pre><code class="prism language-c++">//先找到根节点，然后进行压缩路径
int Find(int S[], x) {
    int root = x;
    while (S[root] &gt;= 0) root = S[root];    //循环找到当前结点的根节点
    while (x != root) {    //循环直到x指向根节点
        int temp = S[x];    //用temp保存x的父结点
        S[x] = root;    //将结点x的父节点修改为根节点
        x = temp;    //x更新为原父节点
    }
}
</code></pre> 
<h6><a id="535UNION_5198"></a>5.3.5.UNION优化——小树合并大树</h6> 
<pre><code class="prism language-c++">//数组中根节点的值为其集合中结点的总数
void Union(int S[], root1, root2){
    if (root1 == root2) return;
    if (root1 &lt;= root2) {    //root1的结点数更多或者二者相等
        S[root1] += S[root2];    //更新root1的结点数为root1和root2的总和
        S[root2] = root1;    //将root2合并到root1中
    } else {    //root2的结点数更多
        S[root2] += S[root1];
        S[root1] = root2;
    }
}
</code></pre> 
<h5><a id="54_5214"></a>5.4.二叉树算法题</h5> 
<h6><a id="541_5216"></a>5.4.1.计算二叉树中双分支结点的个数</h6> 
<p><img src="https://images2.imgbox.com/9d/a6/gPIGZS8L_o.png" alt="img"></p> 
<pre><code class="prism language-c++">int count = 0;    //双分支结点个数
 
void PreOrder(BiTree T){
    if (T) {
        //当前结点的左右孩子都存在，count++
        if (T-&gt;lchild &amp;&amp; T-&gt;rchild) count++;
        if (T-&gt;lchild) PreOrder(T-&gt;lchild);    //递归遍历左子树
        if (T-&gt;rchild) Preorder(T-&gt;rchild);    //递归遍历右子树
}
 
void ans(BiTree T) {
    PreOrder(T);    //先序遍历该树
    cout &lt;&lt; count;    //输出双分支结点个数
}
</code></pre> 
<h6><a id="542_5237"></a>5.4.2.交换二叉树中所有左右子树</h6> 
<p><img src="https://images2.imgbox.com/ab/3a/DOsPIVL3_o.png" alt="img"></p> 
<pre><code class="prism language-c++">void PostOrder(BiTree &amp;T){
    if (T) {
        PostOrder(T-&gt;lchild);
        PostOrder(T-&gt;rchild);
        BiTNode *t = T-&gt;lchild;
        T-&gt;lchild = T-&gt;rchild;
        T-&gt;rchild = t;
    }
}
 
void ans(BiTree &amp;T){
    Post(Order(T));
    return;
}
</code></pre> 
<h6><a id="543k_5258"></a>5.4.3.求先序遍历第k个元素</h6> 
<p><img src="https://images2.imgbox.com/88/5d/mazW3eGj_o.png" alt="img"></p> 
<pre><code class="prism language-C++">int t = 0;
int res = 0;
 
void PreOrder(BiTree T) {
    if (T) {
        t--;
        if (t == 0) res = T-&gt;data;    //第k个结点，用res保存当前结点的值
        PreOrder(T-&gt;lchild);    //递归访问左子树
        PreOrder(T-&gt;rchild);    //递归访问右子树
    }
}
 
void ans(BiTree T, int k) {
    t = k;
    PreOrder(T);
    cout &lt;&lt; res;    //输出第k个结点的值
}
</code></pre> 
<h6><a id="544x_5282"></a>5.4.4.删去值为x的子树</h6> 
<p><img src="https://images2.imgbox.com/b6/6d/xXzwo9Xf_o.png" alt="img"></p> 
<pre><code class="prism language-c++">int k;
 
void Delete(BiTree &amp;T){    //后序遍历的方式删除结点
    if (T) {
        DeleteX(T-&gt;lchild);
        DeleteX(T-&gt;rchild);
        free(T);
    }
}
 
void PreOrder(BiTree &amp;T) {
    if (T) {
        BiTNode *t;
        if (T-&gt;lchild-&gt;data == k) {    //左子树的值为x，删除左子树
            t = T-&gt;lchild;
            T-&gt;lchild = NULL;
            Delete(t);
        }
        if (T-&gt;rchild-&gt;data == k) {    //右子树的值为x，删除右子树
            t = t-&gt;rchild;
            T-&gt;rchild = NULL;
            Delete(t);
        }
        if (T-&gt;lchild) PreOrder(T-&gt;lchild);    //递归遍历左子树
        if (T-&gt;rchild) PreOrder(T-&gt;rchild);    //递归遍历右子树
    }//if
} 
 
 
void ans(BiTree &amp;T, int x){
    k = x;
    if (T-&gt;data == x) {    //根节点的值为x，删除整个树并返回
        Delete(T);
        return;
    } else PreOrder(T);    //先序遍历x
}
</code></pre> 
<pre><code class="prism language-c++">void Delete(BiTree &amp;T) {    //后序遍历，并删除结点
    if (T) {
        Delete(T-&gt;lchild);
        Delete(T-&gt;rchild);
        free(T);
    }
}
 
void LevelOrder(BiTree &amp;T, int x){
    if (T-&gt;data == x) {    //根节点的值为x，删除整个树，并返回
        Delete(T);
        return;
    }
    Queue Q;
    InitQueue(Q);    //初始化队列
    BiTNode *p = T;
    EnQueue(Q, p);    //根节点入队
    while (!IsEmpty(Q)) {
        DeQueue(Q, p);
        if (p-&gt;lchild) {
            if (p-&gt;lchild-&gt;data == x) {
                BiTNode *q = p-&gt;lchild;
                p-&gt;lchild = NULL;    //左孩子指针置空
                Delete(q);    //以q为根节点的子树
            } else EnQueue(Q, p);
        }
        if (p-&gt;rchild) { {}
            if (p-&gt;rchild-&gt;data == x) {
                BiTNode *q = p-&gt;rchild;
                p-&gt;rchild = NULL;
                Delete(q);
            } else EnQueue(Q, p);
        }
    }//while
}
</code></pre> 
<h6><a id="545_5363"></a>5.4.5.查找二叉树中两个结点的公共祖先结点</h6> 
<p><img src="https://images2.imgbox.com/d7/19/pEoAm3qD_o.png" alt="img"></p> 
<pre><code class="prism language-C++">BiTNode *ans(BiTree ROOT, BiTNode *p, BiTNode *q) {
	Stack S, Sp, Sq;	//Sp和Sq分别用来保存p和q的祖先结点
	S.top = -1;	//初始化队列
	BiTNode* t = ROOT, *pre = NULL;
	while (t || S.top &gt;= 0) {
		if (t) {	//t结点非空
			S.data[++S.top] = t;	//t结点入队
			t = t-&gt;lchild;	//进入t的左子树
		}
		else {	//t结点为空
			t = S.data[S.top];	//查看栈顶元素
            //t的右子树存在，并且上一个访问的并不是其右子树
			if (t-&gt;rchild &amp;&amp; t-&gt;rchild != pre) {	
				t = t-&gt;rchild;	//进入右子树
				S.data[++S.top] = t;	//入栈该结点
				t = t-&gt;rchild;	//进入左子树
			}
			else {	//右子树不存在，或者存在但是上一个访问的是右子树
				S.top--;	//出栈该结点，并访问
				if (t == p) {	//当前结点为p，保存栈中内容，即其所有祖先结点
					for (int i = 0; i &lt; S.top; i++) Sp.data[i] = S.data[i];
					Sp.top = S.top;
				}
				if (t == q) {	//当前结点为q，保存栈中内容，即其所有祖先结点
					for (int i = 0; i &lt; S.top; i++) Sq.data[i] = S.data[i];
					Sq.top = S.top;
				}
			}//if
		}//if
	}//while
    //自栈顶到栈顶分别遍历Sp和Sq找到最接近栈顶的相同祖先结点
	for (int i = Sp.top; i &gt;= 0; i--) {	
		for (int j = Sq.top; i &gt;= 0; j--) {
			if (Sp.data[i] == Sq.data[j]) return Sp.data[i];
		}
	}
	return NULL;	//无相同祖先顶点
}
</code></pre> 
<h6><a id="546_5408"></a>5.4.6.求二叉树的宽度</h6> 
<p><img src="https://images2.imgbox.com/75/d0/bBcvSCPN_o.png" alt="img"></p> 
<pre><code class="prism language-c++">typedef struct Queue{
    BiTNode *data[MAXSIZE];    //足够大的数组
    int front, rear;
}Queue;
 
int ans(BiTree T){
    if (!T) return 0;    //空树，返回0
    BiTNode *p = T;
    Queue Q;
    InitQueue(Q);    //初始化队列
    EnQueue(Q, p);    //将p入队
    //rear指向当前层的最后一个结点，count记录当前层的结点数，max记录最大结点数
    int last = Q.rear, count = 0, max = INT_MIN;    
    while (!IsEmpty(Q) {
        DeQueue(Q, p);
        count++;    //结点数+1
        if (p-&gt;lchild) EnQueue(Q, p-&gt;lchild);    //p的左子树存在，左子树入队
        if (p-&gt;rchild) EnQueue(Q, p-&gt;rchild);    //p的右孩子存在，右孩子入队
        if (last == Q.front) {    //当前结点是本层的最后一个节点
            last = Q.rear;    //last指向下一层的最后一个结点
            if (count &gt; max) max = temp;    //更新最大结点数
            count = 0;    //结点数归零
        }
    }//while
    return max;
}
</code></pre> 
<pre><code class="prism language-c++">typedef struct Queue {	//足够大的非循环数组
	BiTNode *data[MAXSIZE];	//结点数组，保存每个结点
	int level[MAXSIZE];	//层数数组，记录每个结点的层数
	int front, rear;	//头尾指针
}Queue;
 
int ans(BiTree T) {
	BiTNode* p = T;
	Queue Q;
	Q.rear = Q.front = 0;	//初始化队列
	if (T) {
		Q.data[Q.rear] = T;	//根节点入队
		Q.level[Q.rear] = 1;
		Q.rear++;
		while (Q.front &lt; Q.rear) {
			p = Q.data[Q.front];	//出队队首元素
			int level = Q.level[Q.front];	//保存当前结点的层数
			Q.front++;
			if (p-&gt;lchild) {	//左孩子入队
				Q.data[Q.rear] = p-&gt;lchild;
				Q.level[Q.rear] = level + 1;
				Q.rear++;
			}
			if (p-&gt;rchild) {	//右孩子入队
				Q.data[Q.rear] = p-&gt;rchild;
				Q.level[Q.rear] = level + 1;
				Q.rear++;
			}
		}//while
		int max = INT_MIN, i = 0, level = 1;
		while (i &lt;= Q.rear) {
			int count = 0;	//记录当前层的结点数
			while (i &lt;= Q.rear &amp;&amp; level == Q.level[i]) {
				count++;
				i++;
			}
			if (count &gt; max) max = count;	//更新每层的最大结点数
			level = Q.level[i];	//更新层数，while循环结束时，i指向下一层的第一个结点
		}//while
		return max;	//返回最大结点数
	}
	else return 0;	//空树，返回0
}
</code></pre> 
<h6><a id="547_5487"></a>5.4.7.求二叉树的高度</h6> 
<pre><code class="prism language-c++">int Get_Heigh(BiTree T) {
	int front = 0, rear = 0;	//前后指针
	BiTNode* p = T;
	BiTNode *data[MAXSIZE];	//足够大的队列，元素是二叉树结点
	data[rear++] = p;	//根节点入队
	int last = rear, level = 0;	//rear标记本层最后一个结点, level记录当前层数
	while (front &lt; rear) {	//循环直到队空
		p = data[front++];	//出队队首结点
		if (p-&gt;lchild) data[Q.rear++] = p-&gt;lchild;	//左右孩子入队
		if (p-&gt;rchild) data[Q.rear++] = p-&gt;rchild;
		if (last == front) {	//当前结点为本层的最后一个结点
			last = rear;	//标记下层的最后一个结点
			level++;	//层数+1
		}
	}//while
	return level;
}
</code></pre> 
<pre><code class="prism language-c++">int Get_High(BiTree T){
    if (!T) return 0;    //空树返回0
    else {
        int hl = Get_High(T-&gt;lchild);    //递归求左右子树高度
        int hr = Get_High(T-&gt;rchild);
        int maxH = max(hl, hr) + 1;    //树高等于左右子树更高的那个+1
        return maxH;
    }
}
</code></pre> 
<h6><a id="548_5521"></a>5.4.8.排序二叉树的判定</h6> 
<pre><code class="prism language-c++">int pre = INT_MIN;	//标记上一个结点的值，初始值为INT类型的最小值
 
int JudgeBST(BiTree T) {
	if (!T) return 1;	//空树，是排序二叉树
	else {
		int l = JudgeBST(T-&gt;lchild);	//判断左子树
        //当前值小于等于pre的值，或左子树不满足排序二叉树定义，返回0
		if (T-&gt;data &lt;= pre|| l == 0) return 0;
		pre = T-&gt;data;	//更新pre为当前结点值
		int r = JudgeBST(T-&gt;rchild);	//判断右子树
		return r;
	}
}
</code></pre> 
<pre><code class="prism language-c++">int A[n];	//足够大的数组，保存每个节点的值
int count = 0;	//记录结点个数
 
void InOrder(BiTree T) {
	if (T) {
		InOrder(T-&gt;lchild);	
		A[count++] = T-&gt;data;	//记录当前结点值，并且count+1
		InOrder(T-&gt;rchild);
	}
}
 
bool ans(BiTree T) {
	if (!T) return true;	//空树为排序二叉树
	else if (!T-&gt;lchild &amp;&amp; !T-&gt;rchild) return true;	//只有根节点，是排序二叉树
	else {
		InOrder(T);	//中序遍历二叉树，并且记录每个结点的值
		for (int i = 0; i &lt; count - 1; i++) {
			if (A[i] &gt;= A[i + 1]) return false;	//非排序二叉树
		}
		return true;	//排序二叉树
	}
}
</code></pre> 
<h6><a id="549_5564"></a>5.4.9.平衡二叉树的判定</h6> 
<pre><code class="prism language-c++">int Get_Height(BiTree T) {
	if (!T) return 0;
	else {
		int hl = Get_Height(T-&gt;lchild);	//递归求左子树高度
		int hr = Get_Height(T-&gt;rchild);	//递归求右子树高度
		int maxH = max(hl, hr) + 1;	//树高为左右子树更高的那个 + 1
		return maxH;	
	}
}
 
bool JudgeBalance(BiTree T) {
	if (!T) return true;	//空树为平衡二叉树
	else {
		int hl = Get_Height(T-&gt;lchild);	//左子树高度
		int hr = Get_Height(T-&gt;rchild);	//右子树高度
		//当前结点的左右平衡因子小于等于1，递归判断其左右子树是否满足平衡二叉树
		if (abs(hl - hr) &lt;= 1) {
            return JudgeBalance(T-&gt;lchild) &amp;&amp; JudgeBalance(T-&gt;rchild);
        }
		//当前节点左右平衡因子大于1，则已不满足平衡二叉树，无需判断左右子树，返回false
		else return false;
	}
}
</code></pre> 
<h6><a id="5410_5592"></a>5.4.10.完全二叉树的判定</h6> 
<p>①采用层次遍历的思想，与一般层次遍历的区别是空结点也能入队</p> 
<p>②当出队元素为空时（设该结点为P），进入内层循环（即③），逐一出队并检查该结点是否为空。</p> 
<p>③若队中剩余元素有不为空的结点，则说明P之后还有结点（这个结点可能是与P同层，或是P的下一层）即不满足完全二叉树的定义；若队中剩余元素皆为空结点，说明P是该树的最后一个结点（最底层的最右结点），满足完全二叉树的定义</p> 
<pre><code class="prism language-c++">bool JudgeComplete(BiTree T) {
	BiTNode* data[MAXSIZE];	//足够大的队列
	int front = 0, rear = 0;	//头尾指针
	BiTNode* p = T;	
	data[rear++] = T;	//根节点入队
	while (front &lt; rear) {	//循环直到队空
		p = data[front++];	//出队队首元素
		if (p) {	//p结点存在，入队左右孩子
			data[rear++] = p-&gt;lchild;
			data[rear++] = p-&gt;rchild;
		}
		else {	//p结点不存在，出队剩余元素
			while (front &lt; rear) {
				p = data[front++];
				if (p) return false;	//当前元素为非空，则为非完全二叉树
			}
		}
	}
	return true;
}
</code></pre> 
<h6><a id="5411_5623"></a>5.4.11.真题</h6> 
<p><img src="https://images2.imgbox.com/b8/ef/FYwJ5UCk_o.png" alt="img"></p> 
<pre><code class="prism language-c++">int WPL = 0;
 
void InOrder(BiTree T, int deep){
    if (T) {
        if (!T-&gt;left &amp;&amp; !T-&gt;right) {    //叶子结点
            WPL = WPL + T.weight * deep;    //更新WPL
        }
        if (T-&gt;left) InOrder(T-&gt;left, deep + 1);
        if (T-&gt;right) InOrder(T-&gt;right, deep + 1);
    }
}
 
int ans(BiTree T){
    InOrder(T, 0);
    return WPL;
}
</code></pre> 
<pre><code class="prism language-c++">int Get_WPL(BiTree root) {
	BiTNode* data[MAXSIZE];	//足够大的非循环数组
	BiTNode* p = root;
	int f = 0, r = 0, level = 0, WPL = 0, last = 0;	
	data[r++] = p;	//根节点入队
	last = r;	//last标记本层的最后一个元素
	while (f &lt; r) {
		p = data[f++];	//队首元素出队
        //该结点为叶子结点，计算WPL
		if (!p-&gt;lchild &amp;&amp; !p-&gt;rchild) WPL = WPL + level * p-&gt;weight;
		if (p-&gt;lchild) data[r++] = p-&gt;left;	//左右孩子入队
		if (p-&gt;rchild) data[r++] = p-&gt;right;
		if (last == f) {	//该结点为本层的最后一个结点
			last = r;	//更新last和level
			level++;
		}
	}
    return WPL;
}
</code></pre> 
<p><img src="https://images2.imgbox.com/7e/7b/pXNK7Kwl_o.png" alt="img"></p> 
<pre><code class="prism language-C++">void InOrder(BiTree T, int deep){
    if (T) {
        if (deep &gt; 1 &amp;&amp; (T-&gt;lchild || T-&gt;rchild)) cout &lt;&lt; '(';    //分支节点打印左括号
        if (T-&gt;lchild) InOrder(T-&gt;lchild, deep + 1);
        cout &lt;&lt; T-&gt;data;
        if (T-&gt;rchild) InOrder(T-&gt;rchild, deep + 1);
        if (deep &gt; 1 &amp;&amp; (T-&gt;lchild || T-&gt;rchild)) cout &lt;&lt; ')';    //分支节点打印右括号
    }
}
 
void ans(BiTree T){
    InOrder(T, 1);
}
</code></pre> 
<h4><a id="6_5686"></a>6.图</h4> 
<h5><a id="61_5688"></a>6.1.图的数据结构定义</h5> 
<h6><a id="611_5690"></a>6.1.1.邻接矩阵</h6> 
<pre><code class="prism language-c++">#define MAXVEX 100
typedef struct Graph {
    int data[MAXVEX];    //一维数组，存放顶点数据
    int edge[MAXVEX][MAXVEX];    //二维数组，存放边数据（权值）
    int vexNum, edgeNum;    //顶点总数和边总数
}Graph;
</code></pre> 
<h6><a id="612_5701"></a>6.1.2.邻接表</h6> 
<pre><code class="prism language-c++">#define MAXVEX 100
typedef struct edgeNode {    //边
    struct edgeNode *next;    //指向下一条邻接边的指针
    int weight;    //该邻接边权值
    int adjVex;    //该邻接边指向的顶点编号
}edgeNode;
 
typedef struct vexNode {    //顶点
    edgeNode *firstEdge;    ///指向该顶点的第一条邻接边
    int vexData;    //该顶点数据
}vexNode;
 
typedef struct Graph {    //图
    int vexNum, edgeNum;    //顶点数，边数
    vexNode vex[MAXVEX];    //vexNode类型的一维数组vex
}Graph;
</code></pre> 
<h5><a id="62_5722"></a>6.2.图的遍历</h5> 
<h6><a id="621_5724"></a>6.2.1.深度优先遍历</h6> 
<pre><code class="prism language-c++">#define MAXVEX 100
bool visited[MAXVEX];    //visited数组记录该顶点是否被访问过
 
void DFSTraverse (Graph G) {
    for (int i = 0; i &lt; G.vexNum; i++) {
        visited[i] = false;    //初始化visited数组
    }
    for (int i = 0; i &lt; G.vexNum; i++) {
        if (!visited[i]) DFS (G, i);    //当前顶点未被访问过，则访问
    }
}
 
void DFS (Graph G, int v) {
    visit (v);    //访问顶点v（具体操作）
    visited[v] = true;    //更新visited数组
    for (int w = FirstNeighbor (G, v); w &gt;= 0; w = NextNeighbor (G, v, w)){
        if (!visited[w]) DFS(G, w);    //递归调用DFS
    }
}
</code></pre> 
<h6><a id="622_5748"></a>6.2.2.广度优先遍历</h6> 
<pre><code class="prism language-c++">#define MAXVEX 100
Queue Q;
bool visited[MAXVEX];
 
void BFSTraverse (Graph G) {
    for (int i = 0; i &lt; G.vexNum; i++) {    //初始化visited数组
        visited[i] = false;    
    }
    InitQueue Q;    //初始化队列Q
    for (int i = 0; i &lt; G.vexNum; i++) {    //遍历图
        if (!visited[i]) BFS(G, i);
    }
}
 
void BFS (Graph G, int v) {
    visit(v);    //访问该顶点（具体操作）
    visited[v] = true;    //更新visited数组
    EnQueue(Q, v);    //将v结点入队
    int w;
    while(!IsEmpty(Q)) {
        DeQueue(Q, v);    //队首元素出队
        for (w = FirstNeighbor(G, v); w &gt;= 0; w = NextNeighbor(G, v, w)) {
            if (!visited[w]) {    //顶点未被访问过
                visit(w);
                visited[w] = true;
                EnQueue(Q, w);
            }
        }//for
    }//while
}
</code></pre> 
<h5><a id="63_5783"></a>6.3.单源最短路径</h5> 
<pre><code class="prism language-c++">#define MAXVEX 100
bool visited[MAXVEX];
int dis[MAXVEX];
Queue Q;
 
void Min_Dis (Graph G, int v) {
    for (int i = 0; i &lt; G.vexNum; i++) {    //初始化visited数组和dis数组
        visited[i] = false;
        dis[i] = INT_MAX;
    }
    visited[v] = true;
    dis[v] = 0;
    InitQueue(Q);
    EnQueue(Q, v);
    int w;
    while (!IsEmpty(Q)) {
        DeQueue(Q, v);
        for (w = FisrtNeighbor(G, v); w &gt;= 0; w = NextNeighbor(G, v, w) {
            if (!visited[w]) {
                visited[w] = true;
                dis[w] = dis[v] + 1;
            }
        }//for
    }//while
}
</code></pre> 
<h5><a id="64_5813"></a>6.4.真题</h5> 
<p><img src="https://images2.imgbox.com/a1/ec/VlijkjHp_o.png" alt="img"></p> 
<pre><code class="prism language-c++">int IsExistEL(MGraph G){
    int count = 0;    //记录该图中度为奇数的顶点个数
    int i, j;
    for (i = 0; i &lt; G.numVertices; i++){    //行遍历邻接矩阵
        int degree = 0;
        for (j = 0; j &lt; G.numVertices; j++){    //列遍历当前行
            if (Edge[i][j] &gt; 0) degree++;    //当前数组元素不为0，则度+1
        }
        if (degree % 2) count++;    //当前顶点的度为奇数，count++
    }
    if (count == 0 || count == 2) return 1;    //奇数顶点个数为0或者2，有EL路径
    else return 0;    //奇数顶点个数不为0或者2，没有EL路径
}
</code></pre> 
<h4><a id="7_5833"></a>7.快速排序</h4> 
<pre><code class="prism language-c++">void QSort(int A[], L, R) {    //快速排序
    if (L &gt;= R) return;    //当前数组长度 &lt;= 1，返回
    随机选择数组中一元素和A[L]互换    //快排优化，使得基准元素的选取随机
    int key = A[L], i = L, j = R;
    while (i &lt; j) {
        while (i &lt; j &amp;&amp; key &lt; A[j]) j--;
        while (i &lt; j &amp;&amp; A[i] &lt;= key) i++;
        if (i &lt; j) swap (A[i], A[j]);    //交换A[i]和A[j]
    }
    swap (A[i], A[L]);
    Qsort (A, L, i - 1);    //递归处理左区间
    Qsort (A, i + 1, R);    //递归处理右区间
}
</code></pre> 
<h4><a id="8_5851"></a>8.折半查找</h4> 
<pre><code class="prism language-C++">int Binary_Search (int A, L, R, key) {
    int mid;
    while (L &lt; R) {    //L &gt;= R时，范围错误
        mid = (L + R) / 2;    //选择中间数，向下取整
        if (key &lt;= A[mid]) R = mid;    //更新范围
        else L = mid + 1;
    }
    if (A[mid] == key) return mid;    //查找成功，返回数组下标
    else return -1;    //查找失败，返回-1
}
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b7102e2c6b1ad22f58364f7543ebbe96/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">轻松绕过Funcaptcha检测——Ezcaptcha！</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/245c365d4ee0315a898972001fdf71e6/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">计算机系统基础知识（一）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>