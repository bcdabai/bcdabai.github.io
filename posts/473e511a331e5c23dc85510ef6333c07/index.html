<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>jvm与非jvm语言优劣_引入新的JVM语言Concurnas - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="jvm与非jvm语言优劣_引入新的JVM语言Concurnas" />
<meta property="og:description" content="jvm与非jvm语言优劣
什么是Concurnas，它与众不同的地方是什么？ Concurnas是一种新的通用开源JVM编程语言，旨在用于构建并发，分布式和并行系统。 Concurnas很容易学习； 它提供了令人难以置信的性能以及用于构建现代企业级计算机软​​件的许多功能。 Concurnas与现有编程语言的不同之处在于，它提供了一种独特的，简化的执行并发，分布式和并行计算的方式。 这些计算形式是现代软件工程中最具挑战性的一些形式，但是使用Concurnas可以使它们变得容易。 利用Concurnas来构建软件，使开发人员能够轻松可靠地实现当今多核计算机提供的全部计算能力，从而使他们能够编写更好的软件并提高生产率。 在本文中，我们将了解Concurnas的一些关键功能，这些功能通过构建供金融公司使用的交易应用程序的关键组件而使其独一无二。 Concurnas的主要目标 创建Concurnas时要牢记五个主要目标： 提供动态类型语言的语法以及强类型编译语言的类型安全性和性能。 具有可选类型和可选的简洁程度，并具有编译时错误检查功能。 通过提供一种编程模型，可以简化并发编程，该模型对于非软件工程师而言比传统的线程和锁模型更为直观。 为了使研究人员和从业人员都能够提高工作效率，使想法可以从理想化一直到使用相同语言和相同代码进行生产。 结合并支持软件工程的现代趋势，包括无效安全性，特征，模式匹配和对依赖注入，分布式计算和GPU计算的一流公民支持。 通过支持领域特定语言的实现并通过将其他语言嵌入到Concurnas代码中来促进将来的编程语言开发。 Concurnas简介 基本语法 让我们首先从一些基本语法开始。 Concurnas是一种类型推断语言，具有可选类型： myInt = 99myDouble double = 99.9 //here we choose to be explicit about the type of myDoublemyString = &#34;hello &#34; &#43; &#34; world!&#34;//inferred as a Stringval cannotReassign = 3.2fcannotReassign = 7.6 //not ok, compilation erroranArray = [1 2 3 4 5 6 7 8 9 10]aList = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]aMatrix = [1 2 3 ; 4 5 6 ; 7 8 9] 导入代码 由于Concurnas在JVM上运行并且与Java兼容，因此我们可以访问现有的大型库库，这些库可用于Java，JDK，当然还有我们所运营的企业已经在任何版本中创建的任何软件。 JVM语言（例如Scala，Kotlin等）。 我们可以通过熟悉的机制导入代码： from java." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/473e511a331e5c23dc85510ef6333c07/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-07-10T16:17:31+08:00" />
<meta property="article:modified_time" content="2020-07-10T16:17:31+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">jvm与非jvm语言优劣_引入新的JVM语言Concurnas</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div class="text" style="font-size: 16px;"> 
 <p>jvm与非jvm语言优劣</p> 
 <h3>什么是Concurnas，它与众不同的地方是什么？</h3> 
 <p> <a href="http://concurnas.com/" rel="noopener noreferrer noopener noreferrer" target="_blank">Concurnas</a>是一种新的通用开源JVM编程语言，旨在用于构建并发，分布式和并行系统。 Concurnas很容易学习； 它提供了令人难以置信的性能以及用于构建现代企业级计算机软​​件的许多功能。 Concurnas与现有编程语言的不同之处在于，它提供了一种独特的，简化的执行并发，分布式和并行计算的方式。 这些计算形式是现代软件工程中最具挑战性的一些形式，但是使用Concurnas可以使它们变得容易。 </p> 
 <p> 利用Concurnas来构建软件，使开发人员能够轻松可靠地实现当今多核计算机提供的全部计算能力，从而使他们能够编写更好的软件并提高生产率。 在本文中，我们将了解Concurnas的一些关键功能，这些功能通过构建供金融公司使用的交易应用程序的关键组件而使其独一无二。 </p> 
 <h3>Concurnas的主要目标</h3> 
 <p> 创建Concurnas时要牢记五个主要目标： </p> 
 <ul><li> 提供动态类型语言的语法以及强类型编译语言的类型安全性和性能。 具有可选类型和可选的简洁程度，并具有编译时错误检查功能。 </li><li> 通过提供一种编程模型，可以简化并发编程，该模型对于非软件工程师而言比传统的线程和锁模型更为直观。 </li><li> 为了使研究人员和从业人员都能够提高工作效率，使想法可以从理想化一直到使用相同语言和相同代码进行生产。 </li><li> 结合并支持软件工程的现代趋势，包括无效安全性，特征，模式匹配和对依赖注入，分布式计算和GPU计算的一流公民支持。 </li><li> 通过支持领域特定语言的实现并通过将其他语言嵌入到Concurnas代码中来促进将来的编程语言开发。 </li></ul> 
  
 <h3>Concurnas简介</h3> 
 <h4>基本语法</h4> 
 <p> 让我们首先从一些基本语法开始。 Concurnas是一种类型推断语言，具有可选类型： </p> 
 <pre class="has"><code class="notranslate brush: jscript; class-name: concurnas-code-v2; title: ; notranslate" title="">myInt = 99
myDouble double = 99.9 //here we choose to be explicit about the type of myDouble
myString = "hello " + " world!"//inferred as a String

val cannotReassign = 3.2f
cannotReassign = 7.6 //not ok, compilation error

anArray = [1 2 3 4 5 6 7 8 9 10]
aList = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

aMatrix = [1 2 3 ; 4 5 6 ; 7 8 9]</code></pre> 
 <h4>导入代码</h4> 
 <p> 由于Concurnas在JVM上运行并且与Java兼容，因此我们可以访问现有的大型库库，这些库可用于Java，JDK，当然还有我们所运营的企业已经在任何版本中创建的任何软件。 JVM语言（例如Scala，Kotlin等）。 我们可以通过熟悉的机制导入代码： </p> 
 <pre class="has"><code class="notranslate brush: jscript; class-name: concurnas-code-v2; title: ; notranslate" title="">from java.util import List
import java.util.Set</code></pre> 
 <h4>功能</h4> 
 <p> 现在让我们介绍功能。 Concurnas是一种可选的简洁语言，这意味着可以以不同的详细程度实现相同的功能，以适合目标受众阅读代码。 因此，以下三个实现在功能上是相同的： </p> 
 <pre class="has"><code class="notranslate brush: jscript; class-name: concurnas-code-v2; title: ; notranslate" title="">def plus(a int, b int) int{//the most verbose form
	return a + b
}

def plus(a int, b int) {//return type inferred as int
	a + b//implicit return
}

def plus(a int, b int) =&gt; a + b
//=&gt; may be used where the function body consists of one line of code</code></pre> 
 <p> 这是一个简单的函数，我们将在本文稍后使用： </p> 
 <pre class="has"><code class="notranslate brush: jscript; class-name: concurnas-code-v2; title: ; notranslate" title="">def print(fmtString String, args Object...){//args is a vararg
	System.out.println(String.format(fmtString, args))
}</code></pre> 
 <p> Concurnas中函数的参数可以声明为vararg参数，也就是说，可以将可变数量的参数传递给它们。 因此，以下对我们的<code>print</code>功能的调用均完全有效： </p> 
 <pre class="has"><code class="notranslate brush: jscript; class-name: concurnas-code-v2; title: ; notranslate" title="">print("hello world!") //prints: hello world!
print("hello world! %s %s %s", 1, 2, 3) //prints: hello world! 1 2 3</code></pre> 
 <h4>并发模型</h4> 
 <p> Concurnas真正脱颖而出的地方在于其并发模型。 Concurnas不会将线程公开给程序员，而是具有类似于线程的“隔离”，它们是代码的隔离单元，在运行时，通过多路复用到Concurnas所在的机器的基础硬件上，可以同时执行代码运行。 创建隔离时，我们仅受操作机器的内存量的限制。 我们可以通过附加的代码或函数调用的模块与爆炸运营商建立一个分离： <code>!</code> ： </p> 
 <pre class="has"><code class="notranslate brush: jscript; class-name: concurnas-code-v2; title: ; notranslate" title="">m1 String: = {"hello "}!//isolate with explicit returned type String:
m2 = {"world!"}!//spawned isolate with implicit returned type String:
msg = m1 + m2
print(msg) //outputs: hello world!</code></pre> 
 <p> 上面，仅当创建<code>m1</code>和<code>m2</code>的隔离已完成并发执行并将其结果值写入其各自的变量时，才计算<code>msg</code> 。 隔离不允许彼此之间共享状态，除非通过称为“ refs”的特殊类型。 ref只是普通类型，后面加上冒号<code>:</code> 。 例如，在上面我们看到了生成的隔离株返回<code>String:</code>类型的值。 引用可以由不确定性在不确定的基础上同时更新。 </p> 
 <h5>还请参见： </h5> 
 <p> 引用具有一个特殊功能，即可以监视它们的更改，然后我们可以编写代码以对这些更改做出React，这在Concurnas中通过<code>onchange</code>和<code>every</code>语句来实现。 <code>onchange</code>和<code>every</code>语句都可能返回值，这些值本身就是引用，因为<code>onchange</code>和<code>every</code>语句都在各自的专用隔离符内运行： </p> 
 <pre class="has"><code class="notranslate brush: jscript; class-name: concurnas-code-v2; title: ; notranslate" title="">a int: = 10
b int: = 10
//^two refs

oc1 := onchange(a, b){
	plus(a, b)
}

ev1 := every(a, b){
	plus(a, b)
}

oc2 &lt;- plus(a, b)//shorthand for onchange
ev2 &lt;= plus(a, b)//shorthand for every

//... other code

a = 50//we change the value of a

await(ev2;ev2 == 60)//wait for ev2 to be reactively set to 60
//carry on with execution...</code></pre> 
 <p> 当任何一个受监视的ref更改时， <code>onchange</code>语句将执行在其块中定义的代码。 <code>every</code>语句以相同的方式操作，但是会在每次监视的ref（包括初始值）更新时触发其代码以执行。 因此，当参考<code>a</code>以上更新，变量<code>oc1</code> ， <code>ev1</code> ， <code>oc2</code>和<code>ev2</code>将与总和更新<code>a</code>和<code>b</code> ，用<code>ev1</code>和<code>ev2</code>具有预先保持的初始总和<code>a</code>和<code>b</code> 。 </p> 
 <h3>建立应用程式</h3> 
 <p> 现在我们已经有了基础知识，让我们开始将它们放到应用程序中。 假设我们正在为典型的投资银行或对冲基金开发金融交易系统。 我们希望快速建立一个React性系统，以从市场上打上带有时间戳的，标有时间戳的资产价格，并在价格满足特定条件时执行操作。 构建这样一个系统的最自然的方法是作为一个React式系统，它将利用该语言的一些特殊的并发相关特性。 </p> 
 <h4>创建一个功能</h4> 
 <p> 首先，我们创建一个函数以输出一些可重复性一致的伪随机时间序列数据，以用于开发和测试： </p> 
 <pre class="has"><code class="notranslate brush: jscript; class-name: concurnas-code-v2; title: ; notranslate" title="">from java.util import Random
from java.time import LocalDateTime

class TSPoint(-dateTime LocalDateTime, -price double){
//class with two fields having implicit getter functions automatically defined by prefixing them with -
	override toString() =&gt; String.format("TSPoint(%S, %.2f)", dateTime, price)
}

def createData(seed = 1337){//seed is an optional parameter with a default value
	rnd = new Random(seed)
	startTime = LocalDateTime.\of(2020, 1, 1, 0, 0)//midnight 1st jan 2020
	price = 100.
	
	def rnd2dp(x double) =&gt; Math.round(x*100)/100. //nested function
	
	ret = list()
	for(sOffset in 0 to 60*60*24){//'x to y' - an integer range from 'x' to 'y'
		time = startTime.plusSeconds(sOffset)
		ret.add(TSPoint(time, price))
		price += rnd2dp(rnd.nextGaussian()*0.01)
	}

	ret
}</code></pre> 
 <p> 在上方，我们首先定义了<code>TSPoint</code>类， <code>TSPoint</code>的实例对象用于表示与可交易资产相关的时间序列的各个点。 让我们检查一下我们的函数是否输出了合理的测试数据范围： </p> 
 <pre class="has"><code class="notranslate brush: jscript; class-name: concurnas-code-v2; title: ; notranslate" title="">timeseries = createData()//call our function with default random seed
prices = t.price for t in timeseries//list comprehension

min = max Double? = null//max and max may be null
for(price in prices){
	if(min == null or price &lt; min){ min = price }elif(max == null or price &gt; max){
		max = price
	}
}

print("min: %.2f max: %.2f", min, max)
//outputs: min: 96.80 max: 101.81</code></pre> 
 <p> 当使用默认的随机种子调用函数时，我们可以看到它会输出合理的日内数据范围： <code>"min: 96.80 max: 101.81"</code> 。 </p> 
 <h4>可空类型</h4> 
 <p> 现在是时候介绍Concurnas对可空类型的支持了。 与编程语言的现代趋势保持一致，Concurnas（如Kotlin和Swift）是一种空值安全的语言，也就是说，如果变量具有空值的能力，则必须将其明确声明为空值，否则假定为非null。 无法为非null类型分配null值，而是必须通过在类型后面附加问号<code>?</code>来将该类型显式声明为可空值<code>?</code> ： </p> 
 <pre class="has"><code class="notranslate brush: jscript; class-name: concurnas-code-v2; title: ; notranslate" title="">aString String
aString = null //this is a compile time error, aString cannot be null

nullable String?
nullable = null //this is ok

len = nullable.length()//this is a compile time error as nullable might be null</code></pre> 
 <p> 我们在上面看到，对<code>nullable.length()</code>的调用会导致编译时错误，因为<code>nullable</code>可能为null，这将导致<code>length()</code>的函数调用引发可怕的<code>NullPointerException</code> 。 然而，在我们的帮助下，Concurnas提供了许多运算符，这些运算符使使用可空类型的变量（例如我们的<code>nullable</code>变量）更安全。 它们如下： </p> 
 <pre class="has"><code class="notranslate brush: jscript; class-name: concurnas-code-v2; title: ; notranslate" title="">len1 Integer? = nullable?.length()      //1. the safe call dot operator
len2 int = (nullable?: "oops").length() //2. the elvis operator
len3 int = nullable??.length()          //3. the non null assertion operator</code></pre> 
 <p> 这些运算符的行为如下： </p> 
 <ol><li> 如果点的左侧是解析为null的可为null的类型，则安全调用点运算符将返回null（并因此为可为null的类型）。 </li><li> Elvis运算符类似于安全呼叫运算符，不同之处在于，当左侧为空时，将返回运算符右侧的指定值，而不是返回null（在上面的示例中为<code>"oops"</code> ）。 </li><li> 非null断言运算符将禁用null保护，并且如果其左手解析为null，则只会抛出异常。 </li></ol> 
 <p> Concurnas还能够推断可为空类型的可为空范围。 对于我们断言可空变量不为空的区域（例如，在分支if语句中），我们可以使用该变量，就好像它不可为空： </p> 
 <pre class="has"><code class="notranslate brush: jscript; class-name: concurnas-code-v2; title: ; notranslate" title="">def returnsNullable() String? =&gt; null

nullabeVar String? = returnsNullable()

len int = if( nullabeVar &lt;&gt; null ){
	nullabeVar.length()//ok because nullabeVar cannot be null here!
}else{
	-1
}

print(len)//prints: -1</code></pre> 
 <p> 这种对可空类型的支持共同帮助我们编写了更可靠，更安全的程序。 </p> 
 <h4>触发交易操作</h4> 
 <p> 现在，我们将继续构建我们的交易系统，我们希望在跟踪资产达到一定价格后立即触发交易操作。 当资产的价格高于<code>101.71</code>时，我们可以使用<code>onchange</code>块触发此过程： </p> 
 <pre class="has"><code class="notranslate brush: jscript; class-name: concurnas-code-v2; title: ; notranslate" title="">lastTick TSPoint://our asset timeseries

onchange(lastTick){
	if(lastTick.price &gt; 101.71){
		//perform trade here...
		return
	}
}</code></pre> 
 <p> 请注意，上面在<code>onchange</code>块内使用了<code>return</code> ，这确保了在满足交易条件时，关联交易操作仅执行一次，此后<code>onchange</code>块终止。 如果没有<code>return</code>语句，则只要满足交易条件，就将触发<code>onchange</code>块，直到<code>lastTick</code>超出范围。 </p> 
 <h4>创建一个参考</h4> 
 <p> 我们可以按照先前的模式轻松地执行其他有趣的事情，例如，我们可以创建ref， <code>lowhigh</code>的滚动高/低价格的<code>lowhigh</code> ，如下所示： </p> 
 <pre class="has"><code class="notranslate brush: jscript; class-name: concurnas-code-v2; title: ; notranslate" title="">lowhigh (TSPoint, TSPoint)://lowhigh is a tuple type

onchange(lastTick){
	if(not lowhigh:isSet()){//using : allows us to call methods on refs themselves
		lowhigh = (lastTick, lastTick)
	}
	else{
		(prevlow, prevHigh) = lowhigh//tuple decomposition
		
		if(lastTick.price &lt; prevlow.price){ lowhigh = (lastTick, prevHigh) }elif(lastTick.price &gt; prevHigh.price){
			lowhigh = (prevlow, lastTick)
		}
	}
}</code></pre> 
 <h4>建立一个面向对象的系统</h4> 
 <p> 现在我们已经准备好交易系统的交易和信息组件，我们准备使用它们来构建面向对象的系统。 为此，我们将利用Concurnas内置的依赖注入（DI）支持。 DI是一种现代软件工程技术，其使用使推理，测试和重用面向对象的软件组件变得更加容易。 在Concurnas中，以对象提供者的形式为DI提供了头等公民身份支持，它们负责创建提供的类实例的图并将依赖项注入到所提供的类实例中。 用法是可选的，但可以为大型项目带来好处： </p> 
 <pre class="has"><code class="notranslate brush: jscript; class-name: concurnas-code-v2; title: ; notranslate" title="">trait OrderManager{	def doTrade(onTick TSPoint) void }
trait InfoFeed{ def display(lowhigh (TSPoint, TSPoint):) }

inject class TradingSystem(ordManager OrderManager, infoFeed InfoFeed){
//'classes' marked as inject may have their dependencies injected
	def watch(){
		tickStream TSPoint:
	
		lowhigh (TSPoint, TSPoint):
	
		onchange(tickStream){
			if(not lowhigh:isSet()){
				lowhigh = (tickStream, tickStream)
			}
			else{
				(prevlow, prevHigh) = lowhigh
				
				if(tickStream.price &lt; prevlow.price){ lowhigh = (tickStream, prevHigh) }elif(tickStream.price &gt; prevHigh.price){
					lowhigh = (prevlow, tickStream)
				}
			}
		}
		infoFeed.display(lowhigh:)//appending : indicates pass-by-ref semantics
		
		onchange(tickStream){
			if(tickStream.price &gt; 101.71){
				ordManager.doTrade(tickStream)
				return
			}
		}
		tickStream:
	}
}

actor TestOrderManager ~ OrderManager{
	result TSPoint:
	def doTrade(onTick TSPoint) void {
		result = onTick
	}
	
	def assertResult(expected String){
		assert result.toString() == expected
	}
}

actor TestInfoFeed ~ InfoFeed{
	result (TSPoint, TSPoint):
	def display(lowhigh (TSPoint, TSPoint):) void{
		result := lowhigh//:= assigns the ref itself instead of the refs value
	}
	
	def assertResult(expected String){
		await(result ; (""+result) == expected)
	}
}


provider TSProviderTests{//this object provider performs dependency injection into instance objects of type `TradingSystem`
	provide TradingSystem
	single provide OrderManager =&gt; TestOrderManager()
	single provide InfoFeed =&gt; TestInfoFeed()
}


//create our provider and create a TradingSystem instance:
tsProvi = new TSProviderTests()
ts = tsProvi.TradingSystem()

//Populate the tickStream with our test data
tickStream := ts.watch()
for(tick in createData()){
	tickStream = tick
}

//extract tests and check results are as expected...
testOrdMng = tsProvi.OrderManager() as TestOrderManager
testInfoFeed = tsProvi.InfoFeed() as TestInfoFeed

//validation:
testOrdMng.assertResult("TSPoint(2020-01-01T04:06:18, 101.71)")
testInfoFeed.assertResult("(TSPoint(2020-01-01T19:59:10, 96.80), TSPoint(2020-01-01T10:10:05, 101.81))")

print('All tests passed!')</code></pre> 
 <p> 上面介绍了Concurnas的另外两个有趣的特征，特征和演员。 Concurnas中的特征受Scala中的特征启发，但是在这里，我们只是像接口（如在Java之类的语言中所见）那样使用它们，因为它们指定了具体实现类必须提供的方法。 Concurnas中的Actor是特殊的类，其实例对象可以在不同的隔离对象之间共享，因为Actor具有自己的并发控制，从而避免了多个隔离对象同时与之交互而对其内部状态进行不确定的更改。 </p> 
 <h5>还请参见： </h5> 
 <p> 当然，使用传统的编程语言从头开始构建诸如上述的React式系统将是一件漫长的事情。 从上面的Concurnas可以看出，这是一个简单的操作。 </p> 
 <h4>领域特定语言（DSL）</h4> 
 <p> Concurnas的另一个不错的功能是它对域特定语言（DSL）的支持。 表达式列表是使实现DSL变得容易的一项功能。 表达式列表从本质上使我们能够跳过方法调用周围的点和括号。 这导致一种更自然的算法表达方式。 我们可以在示例交易系统中使用它。 以下是完全有效的Concurnas代码： </p> 
 <pre class="has"><code class="notranslate brush: jscript; class-name: concurnas-code-v2; title: ; notranslate" title="">order = buy 10e6 when GT 101.71</code></pre> 
 <p> 通过创建我们的订单API启用此功能，如下所示： </p> 
 <pre class="has"><code class="notranslate brush: jscript; class-name: concurnas-code-v2; title: ; notranslate" title="">enum BuySell{BUY, SELL}

def buy(amount double) =&gt; Order(BuySell.BUY, amount)
def sell(amount double) =&gt; Order(BuySell.SELL, amount)

open class Trigger(price double)
class GT(price double) &lt; Trigger(price)
class LT(price double) &lt; Trigger(price) class Order(direction BuySell, amount Double){ trg Trigger? def when(trg Trigger) =&gt; this.trg = trg; this
}

order = buy 10e6 when GT 101.71</code></pre> 
 <p> 此外，尽管此处未介绍，但Concurnas支持运算符重载和扩展功能。 </p> 
 <h3>GPU计算支持</h3> 
 <p> 现在让我们简要地看一下Concurnas内置的对GPU计算的支持。 </p> 
 <p> 可以将GPU视为海量数据并行计算设备，非常适合在大型数据集上执行面向数学的运算。 如今，典型的高端CPU（例如AMD Ryzen Threadripper 3990X）可能具有多达64个内核–为我们提供多达64个并发计算实例，而同类GPU（例如NVIDIA Titan RTX）却具有4608！ 现代计算机中的所有图形卡都具有GPU，实际上我们所有人都可以使用超级计算机。 在GPU上实施的算法通常比其CPU实施快100倍（或更多！）。 此外，从硬件和功耗的角度在GPU上执行此计算时，其相对成本远远低于其CPU。 </p> 
 <p> 但是有一个陷阱……GPU算法具有相对深奥的实现，必须理解底层GPU硬件的细微差别才能获得最佳性能。 传统上，必须具备C / C ++知识。 对于Concurnas，情况有所不同。 </p> 
 <p> Concurnas对GPU计算具有一流的公民支持，这意味着该支持直接内置于该语言本身中，以使开发人员能够利用GPU的强大功能。 因此，我们可以编写惯用的Concurnas代码，并在编译时一步就完成语法和语义检查，从而大大简化了构建过程，并且无需学习C / C ++或依赖于对代码进行运行时检查。 </p> 
 <p> GPU算法在称为<code>gpukernel</code>入口点中实现。 让我们看一个简单的矩阵乘法算法（线性代数的核心组件，它在机器学习和金融中被大量使用）： </p> 
 <pre class="has"><code class="notranslate brush: jscript; class-name: concurnas-code-v2; title: ; notranslate" title="">gpukernel 2 matMult(wA int, wB int, global in matA float[2], global in matB float[2], global out result float[2]) {
	globalRow = get_global_id(0) // Row ID
	globalCol = get_global_id(1) // Col ID

	rescell = 0f;
	for (k = 0; k &lt; wA; ++k) {//matrices are flattened to vectors on the gpu...
		rescell += matA[globalCol * wA + k] * matB[k * wB + globalRow];
	} 
	// Write element to output matrix
	result[globalCol * wA + globalRow] = rescell;
}</code></pre> 
 <p> 此GPU内核提供了一个简洁但幼稚的实现。 例如，可以通过使用本地内存来优化代码以显着提高性能。 就目前而言，这已经足够了。 我们可以将其与传统的基于CPU的矩阵乘法算法进行比较，如下所示： </p> 
 <pre class="has"><code class="notranslate brush: jscript; class-name: concurnas-code-v2; title: ; notranslate" title="">def matMultCPU(A float[2], B float[2]) { 
	n = A[0].length
	m = A.length
	p = B[0].length
	result = new float[m][p]
 
	for(i = 0;i &lt; m;i++){
		for(j = 0;j &lt; p;j++){
			for(k = 0;k &lt; n;k++){
				result[i][j] += A[i][k] * B[k][j]
			}
		}
	}
	result
}</code></pre> 
 <p> 在GPU和CPU实现中，核心矩阵乘法算法是相同的。 但是，存在一些差异：GPU内核本身是在我们的GPU上并行执行的，唯一的区别在于这些单独的并行执行是<code>get_global_id</code>调用返回的值–这些用于识别实例应从数据集中的哪些数据定位。 此外，需要将返回值传递到GPU内核中。 </p> 
 <p> 现在我们已经创建了我们的GPU内核，我们可以在GPU上执行它了。 这比基于标准CPU的计算要复杂得多，因为我们正在建立一条异步管道，将数据复制到GPU，内核执行，从GPU复制结果并最终进行清理。 幸运的是，Concurnas利用并发的ref模型来简化此过程，这还使我们受益匪浅：让我们的GPU保持繁忙（从而最大化吞吐量），并发使用多个GPU，并在执行GPU的同时进行其他基于CPU的工作： </p> 
 <pre class="has"><code class="notranslate brush: jscript; class-name: concurnas-code-v2; title: ; notranslate" title="">def compareMulti(){
	//we wish to perform the following on the GPU: matA * matB
	//matA and matB are both matrices of type float
	matA = [1f 2 3 ; 4f 5 6; 7f 8 9]
	matB = [2f 6 6; 3f 5 2; 7f 4 3]

	//use the first gpu available
	gps = gpus.GPU()
	deviceGrp = gps.getGPUDevices()[0]
	device = deviceGrp.devices[0]

	//allocate memory on gpu
	inGPU1 = device.makeOffHeapArrayIn(float[2].class, 3, 3)
	inGPU2 = device.makeOffHeapArrayIn(float[2].class, 3, 3)
	result = device.makeOffHeapArrayOut(float[2].class, 3, 3)
	
	//asynchronously copy input matrix from RAM to GPU
	c1 := inGPU1.writeToBuffer(matA)
	c2 := inGPU2.writeToBuffer(matB)
	
	//create an executable kernel reference: inst
	inst = matMult(3, 3, inGPU1, inGPU2, result)

	//asynchronously execute with 3*3 =&gt; 9 'threads'
	//if c1 and c2 have not already completed, wait for them
	compute := device.exe(inst, [3 3], c1, c2)

	//copy result matrix from GPU to RAM
	//if compute has not already completed, wait for it
	ret = result.readFromBuffer(compute)
	
	//cleanup
	del inGPU1, inGPU2, result
	del c1, c2, compute
	del deviceGrp, device
	del inst
	
	//print the result
	print('result via GPU: ' + ret)
	print('result via CPU: ' + matMultCPU(matA, matB))
	//prints:
	//result via GPU: [29.0 28.0 19.0 ; 65.0 73.0 52.0 ; 101.0 118.0 85.0]
	//result via CPU: [29.0 28.0 19.0 ; 65.0 73.0 52.0 ; 101.0 118.0 85.0]
}</code></pre> 
 <h3>总结思想</h3> 
 <p> 至此我们的文章到此结束。 我们已经研究了Concurnas的许多方面，这些方面使其具有独特性，尽管现代程序员还有很多其他有趣的功能，例如对分布式计算，时间计算，向量化，语言扩展，堆外内存管理， lambda和模式匹配仅举几例。 </p> 
 <p> <em>请访问<a href="http://concurnas.com/" rel="noopener noreferrer noopener noreferrer" target="_blank">Concurnas网站，</a>或直接进入<a href="https://github.com/Concurnas/Concurnas" target="_blank" rel="noopener noreferrer noopener noreferrer">GitHub存储库</a> 。</em> </p> 
 <blockquote> 
  <p>翻译自: <a href="https://jaxenter.com/introducing-new-jvm-lanaguage-concurnas-167915.html" rel="nofollow">https://jaxenter.com/introducing-new-jvm-lanaguage-concurnas-167915.html</a></p> 
 </blockquote> 
 <p>jvm与非jvm语言优劣</p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7785f071c904658d4f5d45307e1b520d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">java1!&#43;2!&#43;3!_到Java辉煌的25年！</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b226831282310b959ef4fcc06b786904/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Python使用中常见问题总结（五）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>