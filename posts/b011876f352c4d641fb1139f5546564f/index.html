<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java校招面试题复习 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Java校招面试题复习" />
<meta property="og:description" content="文章目录 JAVA 基础知识点（一）什么是J2EE？JVM？JRE？JDK？（二）面向对象的三大特性什么是继承？什么是封装？什么是多态？java为什么不支持多继承？ Java 中覆盖和重载是什么意思？重定向和转发的区别。抽象类和接口的区别有哪些？Java 和 C&#43;&#43; 的区别：&amp;与&amp;&amp;的区别：IN和EXISTS的区别 Java 中常见集合1）说说常见的集合有哪些吧？2）HashMap 和 Hashtable 的区别有哪些？（必问）3）HashMap 的底层实现你知道吗？4）ConcurrentHashMap 和 Hashtable 的区别？（必问）5）HashMap 的长度为什么是 2 的幂次方？6）List 和 Set 的区别是啥？7）List、Set 和 Map 的初始容量和加载因子8）Comparable 接口和 Comparator 接口有什么区别？9）Java 集合的快速失败机制 “fail-fast” 高并发编程-JUC 包1）多线程和单线程的区别和联系：2）如何指定多个线程的执行顺序？3）线程和进程的区别：（必考）4）多线程产生死锁的 4 个必要条件？5）sleep( ) 和 wait( n)、wait( ) 的区别：6）synchronized 关键字：7）volatile 关键字8）ThreadLocal（线程局部变量）关键字：9）Atomic 关键字：10）线程池有了解吗？（必考） JVM 内存管理1）JVM 内存划分：2）类似-Xms、-Xmn 这些参数的含义：3）垃圾回收算法有哪些？4）root 搜索算法中，哪些可以作为 root？GC是什么？为什么要有GC？5）GC（垃圾回收机制） 什么时候开始？6）内存泄漏和内存溢出7） 解释内存中的栈(stack)、堆(heap)和方法区(method area)的用法。9）Java 中会存在内存泄漏吗，请简单描述。 Java 8 相关知识点数据库知识点1）MySQL 和 MongoDB 的区别有哪些？如何选择？3）听说过事务吗？（必考）4）事务的并发问题有哪几种？5）数据库中的锁有哪几种？6）事务的隔离级别有哪几种？7）数据库的索引有什么作用？（必考） 底层数据结构是什么，为什么使用这种数据结构？8）数据库中 Where、group by、having 关键字：处理上百万条的数据库如何提高处理查询速度 MVC 框架相关知识点Spring 知识点1）Spring 的 IOC 和 AOP 有了解吗？2）AOP 的实现方式有哪几种？如何选择？（必考）Spring创建对象的三种方式IoC和DI的区别IoC容器装配Bean两种方法 什么是AOP ？BeanFactory和FactoryBean的区别？什么是EL、OGNL、spEL？动态代理和静态代理区别？REQUIRED、REQUIRES_NEW、NESTED 区分 Mybatis 知识点Spring MVCSpring MVC 的核心控制器是什么？消息处理流程有哪些？ Spring Boot 异常Error和Exception有什么区别？try{}里有一个return语句，那么紧跟在这个try后的finally{}里的代码会不会被执行，什么时候被执行，在return前还是后?" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/b011876f352c4d641fb1139f5546564f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-09-14T16:46:49+08:00" />
<meta property="article:modified_time" content="2019-09-14T16:46:49+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java校招面试题复习</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#JAVA__2" rel="nofollow">JAVA 基础知识点</a></li><li><ul><li><a href="#J2EEJVMJREJDK_3" rel="nofollow">（一）什么是J2EE？JVM？JRE？JDK？</a></li><li><a href="#_9" rel="nofollow">（二）面向对象的三大特性</a></li><li><ul><li><a href="#_11" rel="nofollow">什么是继承？</a></li><li><a href="#_18" rel="nofollow">什么是封装？</a></li><li><a href="#_23" rel="nofollow">什么是多态？</a></li><li><a href="#java_30" rel="nofollow">java为什么不支持多继承？</a></li></ul> 
   </li><li><a href="#Java__33" rel="nofollow">Java 中覆盖和重载是什么意思？</a></li><li><a href="#_59" rel="nofollow">重定向和转发的区别。</a></li><li><a href="#_65" rel="nofollow">抽象类和接口的区别有哪些？</a></li><li><a href="#Java__C__76" rel="nofollow">Java 和 C++ 的区别：</a></li><li><a href="#_81" rel="nofollow">&amp;与&amp;&amp;的区别：</a></li><li><a href="#INEXISTS_83" rel="nofollow">IN和EXISTS的区别</a></li></ul> 
  </li><li><a href="#Java__87" rel="nofollow">Java 中常见集合</a></li><li><ul><li><a href="#1_90" rel="nofollow">1）说说常见的集合有哪些吧？</a></li><li><a href="#2HashMap__Hashtable__98" rel="nofollow">2）HashMap 和 Hashtable 的区别有哪些？（必问）</a></li><li><a href="#3HashMap__102" rel="nofollow">3）HashMap 的底层实现你知道吗？</a></li><li><a href="#4ConcurrentHashMap__Hashtable__105" rel="nofollow">4）ConcurrentHashMap 和 Hashtable 的区别？（必问）</a></li><li><a href="#5HashMap__2__113" rel="nofollow">5）HashMap 的长度为什么是 2 的幂次方？</a></li><li><a href="#6List__Set__120" rel="nofollow">6）List 和 Set 的区别是啥？</a></li><li><a href="#7ListSet__Map__124" rel="nofollow">7）List、Set 和 Map 的初始容量和加载因子</a></li><li><a href="#8Comparable__Comparator__133" rel="nofollow">8）Comparable 接口和 Comparator 接口有什么区别？</a></li><li><a href="#9Java__failfast_137" rel="nofollow">9）Java 集合的快速失败机制 “fail-fast”</a></li></ul> 
  </li><li><a href="#JUC__149" rel="nofollow">高并发编程-JUC 包</a></li><li><ul><li><a href="#1_151" rel="nofollow">1）多线程和单线程的区别和联系：</a></li><li><a href="#2_157" rel="nofollow">2）如何指定多个线程的执行顺序？</a></li><li><a href="#3_162" rel="nofollow">3）线程和进程的区别：（必考）</a></li><li><a href="#4_4__169" rel="nofollow">4）多线程产生死锁的 4 个必要条件？</a></li><li><a href="#5sleep___wait_nwait___179" rel="nofollow">5）sleep( ) 和 wait( n)、wait( ) 的区别：</a></li><li><a href="#6synchronized__183" rel="nofollow">6）synchronized 关键字：</a></li><li><a href="#7volatile__191" rel="nofollow">7）volatile 关键字</a></li><li><a href="#8ThreadLocal_199" rel="nofollow">8）ThreadLocal（线程局部变量）关键字：</a></li><li><a href="#9Atomic__208" rel="nofollow">9）Atomic 关键字：</a></li><li><a href="#10_211" rel="nofollow">10）线程池有了解吗？（必考）</a></li></ul> 
  </li><li><a href="#JVM__220" rel="nofollow">JVM 内存管理</a></li><li><ul><li><a href="#1JVM__225" rel="nofollow">1）JVM 内存划分：</a></li><li><a href="#2XmsXmn__232" rel="nofollow">2）类似-Xms、-Xmn 这些参数的含义：</a></li><li><a href="#3_245" rel="nofollow">3）垃圾回收算法有哪些？</a></li><li><a href="#4root__root_257" rel="nofollow">4）root 搜索算法中，哪些可以作为 root？</a></li><li><a href="#GCGC_265" rel="nofollow">GC是什么？为什么要有GC？</a></li><li><a href="#5GC__273" rel="nofollow">5）GC（垃圾回收机制） 什么时候开始？</a></li><li><a href="#6_280" rel="nofollow">6）内存泄漏和内存溢出</a></li><li><a href="#7_stackheapmethod_area_285" rel="nofollow">7） 解释内存中的栈(stack)、堆(heap)和方法区(method area)的用法。</a></li><li><a href="#9Java__292" rel="nofollow">9）Java 中会存在内存泄漏吗，请简单描述。</a></li></ul> 
  </li><li><a href="#Java_8__294" rel="nofollow">Java 8 相关知识点</a></li><li><a href="#_320" rel="nofollow">数据库知识点</a></li><li><ul><li><a href="#1MySQL__MongoDB__321" rel="nofollow">1）MySQL 和 MongoDB 的区别有哪些？如何选择？</a></li><li><a href="#3_346" rel="nofollow">3）听说过事务吗？（必考）</a></li><li><a href="#4_354" rel="nofollow">4）事务的并发问题有哪几种？</a></li><li><a href="#5_362" rel="nofollow">5）数据库中的锁有哪几种？</a></li><li><a href="#6_365" rel="nofollow">6）事务的隔离级别有哪几种？</a></li><li><a href="#7__376" rel="nofollow">7）数据库的索引有什么作用？（必考） 底层数据结构是什么，为什么使用这种数据结构？</a></li><li><a href="#8_Wheregroup_byhaving__413" rel="nofollow">8）数据库中 Where、group by、having 关键字：</a></li><li><a href="#_429" rel="nofollow">处理上百万条的数据库如何提高处理查询速度</a></li></ul> 
  </li><li><a href="#MVC__450" rel="nofollow">MVC 框架相关知识点</a></li><li><a href="#Spring__457" rel="nofollow">Spring 知识点</a></li><li><ul><li><a href="#1Spring__IOC__AOP__459" rel="nofollow">1）Spring 的 IOC 和 AOP 有了解吗？</a></li><li><a href="#2AOP__464" rel="nofollow">2）AOP 的实现方式有哪几种？如何选择？（必考）</a></li><li><a href="#Spring_481" rel="nofollow">Spring创建对象的三种方式</a></li><li><ul><li><a href="#IoCDI_485" rel="nofollow">IoC和DI的区别</a></li><li><a href="#IoCBean_488" rel="nofollow">IoC容器装配Bean两种方法</a></li></ul> 
   </li><li><a href="#AOP__540" rel="nofollow">什么是AOP ？</a></li><li><ul><li><a href="#BeanFactoryFactoryBean_547" rel="nofollow">BeanFactory和FactoryBean的区别？</a></li><li><a href="#ELOGNLspEL_551" rel="nofollow">什么是EL、OGNL、spEL？</a></li><li><a href="#_556" rel="nofollow">动态代理和静态代理区别？</a></li><li><a href="#REQUIREDREQUIRES_NEWNESTED__560" rel="nofollow">REQUIRED、REQUIRES_NEW、NESTED 区分</a></li></ul> 
   </li><li><a href="#Mybatis__564" rel="nofollow">Mybatis 知识点</a></li><li><a href="#Spring_MVC_572" rel="nofollow">Spring MVC</a></li><li><ul><li><a href="#Spring_MVC__573" rel="nofollow">Spring MVC 的核心控制器是什么？消息处理流程有哪些？</a></li></ul> 
   </li><li><a href="#Spring_Boot_576" rel="nofollow">Spring Boot</a></li></ul> 
  </li><li><a href="#_577" rel="nofollow">异常</a></li><li><ul><li><a href="#ErrorException_578" rel="nofollow">Error和Exception有什么区别？</a></li><li><a href="#tryreturntryfinallyreturn_580" rel="nofollow">try{}里有一个return语句，那么紧跟在这个try后的finally{}里的代码会不会被执行，什么时候被执行，在return前还是后?</a></li><li><a href="#Javathrowsthrowtrycatchfinally_582" rel="nofollow">Java语言如何进行异常处理，关键字：throws、throw、try、catch、finally分别如何使用？</a></li><li><a href="#_584" rel="nofollow">运行时异常与受检异常有何异同？</a></li><li><a href="#_594" rel="nofollow">列出一些你常见的运行时异常？</a></li></ul> 
  </li><li><a href="#Linux__602" rel="nofollow">Linux 常见命令</a></li><li><ul><li><a href="#1grepsed__awk__603" rel="nofollow">1）grep、sed 以及 awk 命令</a></li><li><a href="#2_604" rel="nofollow">2）文件和目录</a></li><li><a href="#3touchcp_Inmvrm_612" rel="nofollow">3）处理文件方面的命令有：touch、cp、 In、mv、rm、</a></li><li><a href="#4mkdir_614" rel="nofollow">4）处理目录方面的命令：mkdir</a></li><li><a href="#5filecatmorelesstailhead_616" rel="nofollow">5）查看文件内容：file、cat、more、less、tail、head</a></li><li><a href="#6pstop_618" rel="nofollow">6）监测程序命令：ps、top</a></li><li><a href="#7ps__top__630" rel="nofollow">7）ps 和 top 命令的区别：</a></li><li><a href="#8__637" rel="nofollow">8） 压缩数据</a></li><li><a href="#9kill_PID__kill_all_641" rel="nofollow">9）结束进程：kill PID 或者 kill all</a></li></ul> 
  </li><li><a href="#_642" rel="nofollow">网络协议相关</a></li><li><ul><li><a href="#1_643" rel="nofollow">1）三次握手、四次挥手示意图：</a></li><li><a href="#2_657" rel="nofollow">2）滑动窗口机制</a></li><li><a href="#3_663" rel="nofollow">3）拥塞避免机制</a></li><li><a href="#4wwwxxxcom__675" rel="nofollow">4）浏览器中输入：“www.xxx.com” 之后都发生了什么？请详细阐述。</a></li><li><a href="#5_HTTP__690" rel="nofollow">5）常见 HTTP 状态码</a></li><li><a href="#6TCP__UDP__702" rel="nofollow">6）TCP 和 UDP 的区别：</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="JAVA__2"></a>JAVA 基础知识点</h2> 
<h3><a id="J2EEJVMJREJDK_3"></a>（一）什么是J2EE？JVM？JRE？JDK？</h3> 
<p>（1）J2EE：是为开发企业环境下的应用程序提供的一套解决方案，该技术体系中包含的技术如Servlet、Jsp等，主要针对Web应用程序开发。<br> （2）JVM：JVM是java虚拟机(JVM Java Virtual Machine)，java程序需要运行在虚拟机上，不同平台有自己的虚拟机，因此java语言可以跨平台。<br> （3）JRE：包括Java虚拟机(JVM Java Virtual Machine)和Java程序所需的核心类库等如果想要运行一个开发好的Java程序，计算机中只需要安装JRE即可。JRE:JVM+类库。<br> （4）JDK：JDK是提供给Java开发人员使用的，其中包含了java的开发工具，也包括了JRE。所以安装了JDK，就不用在单独安装JRE了。其中的开发工具：编译工具(javac.exe) 打包工具(jar.exe)等。JDK:JRE+JAVA的开发工具。</p> 
<h3><a id="_9"></a>（二）面向对象的三大特性</h3> 
<p><strong>继承、封装、多态</strong></p> 
<h4><a id="_11"></a>什么是继承？</h4> 
<p>①继承是面向对象程序设计能够提高软件开发效率的重要原因之一。<br> ②继承是具有传递性的，就像现实中孙子不仅长得像爸爸而且还像他爷爷。<br> ③继承来的属性和方法是隐式的，也就是在本类里面是看不见的。<br> ④一个类只能有一个父类，也就是类只能是单继承。<br> ⑤一个接口可以有多个父类，也就是接口可以是多继承。<br> 实际项目开发中，一个类继承于另一个类，那么前者就是后者的子类，反则反之。</p> 
<h4><a id="_18"></a>什么是封装？</h4> 
<p>对象数据和操作该对象的指令都是对象自身的一部分，能够实现尽可能对外部隐藏数据。<br> 实际项目开发中，使用封装最多的就是实体类，常常和JavaBean（类必须是具体的和公共的，并且具有无参数的构造器）一起使用。<br> 那么，实体类有那些东西呢？<br> 答：私有的成员变量、无参数的构造器、有参数的构造器、setter和getters方法、重写tostring方法、重写hashCode和equals方法。</p> 
<h4><a id="_23"></a>什么是多态？</h4> 
<p>①多态就是对象拥有多种形态：引用多态和方法多态。<br> ②引用多态：父类的引用可以指向本类对象、父类的引用可以指向子类的对象。<br> ③方法多态：创建本类对象时，调用的方法为本类的方法；创建子类对象时，调用的方法为子类重写的方法或者继承的方法。<br> ④存在多态的必要条件：继承、重写。<br> ⑤多态的作用是消除类型之间的耦合关系。<br> 在实际项目开发中，A类继承B类，如果在A类中不重写B类的方法的时候，输出的仍旧是B类方法里面的信息（B b=new A()）；如果在A类中重写B类的方法的时候，输出的是A类方法里面的信息（B b=new A()）。</p> 
<h4><a id="java_30"></a>java为什么不支持多继承？</h4> 
<p>1.若子类继承的父类中拥有相同的成员变量，子类在引用该变量时将无法判别使用哪个父类的成员变量。<br> 2.若一个子类继承的多个父类拥有相同方法，同时子类并未覆盖该方法（若覆盖，则直接使用子类中该方法），那么调用该方法时将无法确定调用哪个父类的方法。</p> 
<h3><a id="Java__33"></a>Java 中覆盖和重载是什么意思？</h3> 
<p>解析：覆盖和重载是比较重要的基础知识点，并且容易混淆，所以面试中常见。<br> 答：覆盖（Overide）是指子类对父类方法的一种重写，只能比父类抛出更少的异常，访问权限不能比父类的小。<br> 被覆盖的方法不能是 private 的，否则只是在子类中重新定义了一个方法；</p> 
<p>重载（Overload）表示同一个类中可以有多个名称相同的方法，但这些方法的参数列表各不相同。</p> 
<p>面试官： 那么构成重载的条件有哪些？</p> 
<p>答：参数类型不同、参数个数不同、参数顺序不同。</p> 
<p>面试官： 函数的返回值不同可以构成重载吗？为什么？</p> 
<p>答：不可以，因为 Java 中调用函数并不需要强制赋值。举例如下：<br> 如下两个方法：</p> 
<pre><code>void f(){}
int f(){ return 1;}
</code></pre> 
<p>只要编译器可以根据语境明确判断出语义，比如在 int x = f();中，那么的确可以据此区分重载方法。不过， 有时你并不关心方法的返回值，你想要的是方法调用的其他效果 （这常被称为 “为了副作用而调用”），这时你可能会调用方法而忽略其返回值，所以如果像下面的调用：</p> 
<pre><code>fun();
</code></pre> 
<p>此时 Java 如何才能判断调用的是哪一个 f() 呢？别人如何理解这种代码呢？所以，根据方法返回值来区分重载方法是行不通的。</p> 
<h3><a id="_59"></a>重定向和转发的区别。</h3> 
<p>1、重定向是两次请求，转发是一次请求，因此转发的速度要快于重定向<br> 2、重定向之后地址栏上的地址会发生变化，变化成第二次请求的地址，转发之后地址栏上的地址不会变化，还是第一次请求的地址<br> 3、转发是服务器行为，重定向是客户端行为。重定向时浏览器上的网址改变 ,转发是浏览器上的网址不变<br> 4、重定向是两次request，转发只有一次请求<br> 5、重定向时的网址可以是任何网址，转发的网址必须是本站点的网址</p> 
<h3><a id="_65"></a>抽象类和接口的区别有哪些？</h3> 
<p>答：<br> 抽象类中可以没有抽象方法；接口中的方法必须是抽象方法；<br> 抽象类中可以有普通的成员变量；接口中的变量必须是 static final 类型的，必须被初始化 , 接口中只有常量，没有变量。<br> 抽象类只能单继承，接口可以继承多个父接口；<br> Java8 中接口中会有 default 方法，即方法可以被实现。</p> 
<p>面试官：抽象类和接口如何选择？<br> 答：<br> 如果要创建不带任何方法定义和成员变量的基类，那么就应该选择接口而不是抽象类。<br> 如果知道某个类应该是基类，那么第一个选择的应该是让它成为一个接口，只有在必须要有方法定义和成员变量的时候，才应该选择抽象类。因为抽象类中允许存在一个或多个被具体实现的方法，只要方法没有被全部实现该类就仍是抽象类。</p> 
<h3><a id="Java__C__76"></a>Java 和 C++ 的区别：</h3> 
<p>答：都是面向对象的语言，都支持封装、继承和多态；<br> 指针：Java 不提供指针来直接访问内存，程序更加安全；<br> 继承： Java 的类是单继承的，C++ 支持多重继承； Java 通过一个类实现多个接口来实现 C++ 中的多重继承； Java 中类不可以多继承，但是！！！接口可以多继承；<br> 内存： Java 有自动内存管理机制，不需要程序员手动释放无用内存。</p> 
<h3><a id="_81"></a>&amp;与&amp;&amp;的区别：</h3> 
<p>&amp;运算符有两种用法：(1)按位与；(2)逻辑与。&amp;&amp;运算符是短路与运算。逻辑与跟短路与的差别是非常巨大的，虽然二者都要求运算符左右两端的布尔值都是true整个表达式的值才是true。&amp;&amp;之所以称为短路运算是因为，如果&amp;&amp;左边的表达式的值是false，右边的表达式会被直接短路掉，不会进行运算。</p> 
<h3><a id="INEXISTS_83"></a>IN和EXISTS的区别</h3> 
<p>IN先执行子查询，EXISTS先执行主查询。IN不对NULL进行处理。in 是把外表和内表作hash 连接，而exists是对外表作loop循环，每次loop循环再对内表进行查询。一直以来认为exists比in效率高的说法是不准确的。<br> not in 和not exists<br> 如果查询语句使用了not in 那么内外表都进行全表扫描，没有用到索引；而not extsts 的子查询依然能用到表上的索引。所以无论那个表大，用not exists都比not in要快。</p> 
<h2><a id="Java__87"></a>Java 中常见集合</h2> 
<p>集合这方面的考察相当多，这部分是面试中必考的知识点。</p> 
<h3><a id="1_90"></a>1）说说常见的集合有哪些吧？</h3> 
<p>答：Map 接口和 Collection 接口是所有集合框架的父接口：</p> 
<p>Collection 接口的子接口包括：Set 接口和 List 接口；<br> Map 接口的实现类主要有：HashMap、TreeMap、Hashtable、ConcurrentHashMap 以及 Properties 等；<br> Set 接口的实现类主要有：HashSet、TreeSet、LinkedHashSet 等；<br> List 接口的实现类主要有：ArrayList、LinkedList、Stack 以及 Vector 等。</p> 
<h3><a id="2HashMap__Hashtable__98"></a>2）HashMap 和 Hashtable 的区别有哪些？（必问）</h3> 
<p>答：<br> HashMap 没有考虑同步，是线程不安全的；Hashtable 使用了 synchronized 关键字，是线程安全的；<br> 前者允许 null 作为 Key；后者不允许 null 作为 Key。</p> 
<h3><a id="3HashMap__102"></a>3）HashMap 的底层实现你知道吗？</h3> 
<p>答：在 Java8 之前，其底层实现是数组 + 链表实现，Java8 使用了数组 + 链表 + 红黑树实现。此时你可以简单的在纸上画图分析：<br> <img src="https://images2.imgbox.com/c0/95/Gk8bsD0L_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="4ConcurrentHashMap__Hashtable__105"></a>4）ConcurrentHashMap 和 Hashtable 的区别？（必问）</h3> 
<p>答：ConcurrentHashMap 结合了 HashMap 和 HashTable 二者的优势。HashMap 没有考虑同步，hashtable 考虑了同步的问题。但是 hashtable 在每次同步执行时都要锁住整个结构。 ConcurrentHashMap 锁的方式是稍微细粒度的。 ConcurrentHashMap 将 hash 表分为 16 个桶（默认值），诸如 get,put,remove 等常用操作只锁当前需要用到的桶。</p> 
<p>面试官：ConcurrentHashMap 的具体实现知道吗？<br> 答：<br> 该类包含两个静态内部类 HashEntry 和 Segment；前者用来封装映射表的键值对，后者用来充当锁的角色；<br> Segment 是一种可重入的锁 ReentrantLock，每个 Segment 守护一个 HashEntry 数组里得元素，当对 HashEntry 数组的数据进行修改时，必须首先获得对应的 Segment 锁。</p> 
<h3><a id="5HashMap__2__113"></a>5）HashMap 的长度为什么是 2 的幂次方？</h3> 
<p>答：<br> 通过将 Key 的 hash 值与 length-1 进行 &amp; 运算，实现了当前 Key 的定位，2 的幂次方可以减少冲突（碰撞）的次数，提高 HashMap 查询效率；<br> 如果 length 为 2 的次幂 则 length-1 转化为二进制必定是 11111……的形式，在于 h 的二进制与操作效率会非常的快，而且空间不浪费；<br> 如果 length 不是 2 的次幂，比如 length 为 15，则 length-1 为 14，对应的二进制为 1110，在于 h 与操作，最后一位都为 0，而 0001，0011，0101，1001，1011，0111，1101 这几个位置永远都不能存放元素了，空间浪费相当大。<br> 更糟的是这种情况中，数组可以使用的位置比数组长度小了很多，这意味着进一步增加了碰撞的几率，减慢了查询的效率！这样就会造成空间的浪费。</p> 
<h3><a id="6List__Set__120"></a>6）List 和 Set 的区别是啥？</h3> 
<p>答：List 元素是有序的，可以重复；Set 元素是无序的，不可以重复。</p> 
<h3><a id="7ListSet__Map__124"></a>7）List、Set 和 Map 的初始容量和加载因子</h3> 
<p>答：</p> 
<ol><li>List<br> ArrayList 的初始容量是 10；加载因子为 0.5； 扩容增量：原容量的 0.5 倍 +1；一次扩容后长度为 16。<br> Vector 初始容量为 10，加载因子是 1。扩容增量：原容量的 1 倍，如 Vector 的容量为 10，一次扩容后是容量为 20。</li><li>Set<br> HashSet，初始容量为 16，加载因子为 0.75； 扩容增量：原容量的 1 倍； 如 HashSet 的容量为 16，一次扩容后容量为 32</li><li>Map<br> HashMap，初始容量 16，加载因子为 0.75； 扩容增量：原容量的 1 倍； 如 HashMap 的容量为 16，一次扩容后容量为 32</li></ol> 
<h3><a id="8Comparable__Comparator__133"></a>8）Comparable 接口和 Comparator 接口有什么区别？</h3> 
<p>答：<br> 前者简单，但是如果需要重新定义比较类型时，需要修改源代码。<br> 后者不需要修改源代码，自定义一个比较器，实现自定义的比较方法。</p> 
<h3><a id="9Java__failfast_137"></a>9）Java 集合的快速失败机制 “fail-fast”</h3> 
<p>答：它是 java 集合的一种错误检测机制，当多个线程对集合进行结构上的改变的操作时，有可能会产生 fail-fast 机制。<br> 例如 ：假设存在两个线程（线程 1、线程 2），线程 1 通过 Iterator 在遍历集合 A 中的元素，在某个时候线程 2 修改了集合 A 的结构（是结构上面的修改，而不是简单的修改集合元素的内容），那么这个时候程序就会抛出 ConcurrentModificationException 异常，从而产生 fail-fast 机制。</p> 
<p>原因： 迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount 变量。集合在被遍历期间如果内容发生变化，就会改变 modCount 的值。</p> 
<p>每当迭代器使用 hashNext()/next() 遍历下一个元素之前，都会检测 modCount 变量是否为 expectedmodCount 值，是的话就返回遍历；否则抛出异常，终止遍历。</p> 
<p>解决办法：</p> 
<p>在遍历过程中，所有涉及到改变 modCount 值得地方全部加上 synchronized；<br> 使用 CopyOnWriteArrayList 来替换 ArrayList。</p> 
<h2><a id="JUC__149"></a>高并发编程-JUC 包</h2> 
<p>在 Java 5.0 提供了 java.util.concurrent（简称 JUC ）包，在此包中增加了在并发编程中很常用的实用工具类，用于定义类似于线程的自定义子系统，包括线程池、异步 IO 和轻量级任务框架。</p> 
<h3><a id="1_151"></a>1）多线程和单线程的区别和联系：</h3> 
<p>答：<br> 在单核 CPU 中，将 CPU 分为很小的时间片，在每一时刻只能有一个线程在执行，是一种微观上轮流占用 CPU 的机制。<br> 多线程会存在线程上下文切换，会导致程序执行速度变慢，即采用一个拥有两个线程的进程执行所需要的时间比一个线程的进程执行两次所需要的时间要多一些。<br> 结论：即采用多线程不会提高程序的执行速度，反而会降低速度，但是对于用户来说，可以减少用户的响应时间。</p> 
<h3><a id="2_157"></a>2）如何指定多个线程的执行顺序？</h3> 
<p>解析：面试官会给你举个例子，如何让 10 个线程按照顺序打印 0123456789？（写代码实现）<br> 答：<br> 设定一个 orderNum，每个线程执行结束之后，更新 orderNum，指明下一个要执行的线程。并且唤醒所有的等待线程。<br> 在每一个线程的开始，要 while 判断 orderNum 是否等于自己的要求值！！不是，则 wait，是则执行本线程。</p> 
<h3><a id="3_162"></a>3）线程和进程的区别：（必考）</h3> 
<p>答：<br> 进程是一个 “执行中的程序”，是系统进行资源分配和调度的一个独立单位；<br> 线程是进程的一个实体，一个进程中拥有多个线程，线程之间共享地址空间和其它资源（所以通信和同步等操作线程比进程更加容易）；<br> 线程上下文的切换比进程上下文切换要快很多。<br> （1）进程切换时，涉及到当前进程的 CPU 环境的保存和新被调度运行进程的 CPU 环境的设置。<br> （2）线程切换仅需要保存和设置少量的寄存器内容，不涉及存储管理方面的操作。</p> 
<h3><a id="4_4__169"></a>4）多线程产生死锁的 4 个必要条件？</h3> 
<p>答：<br> 互斥条件：一个资源每次只能被一个线程使用；<br> 请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放；<br> 不剥夺条件：进程已经获得的资源，在未使用完之前，不能强行剥夺；<br> 循环等待条件：若干线程之间形成一种头尾相接的循环等待资源关系。<br> 面试官：如何避免死锁？（经常接着问这个问题哦~）<br> 答：指定获取锁的顺序，举例如下：<br> 比如某个线程只有获得 A 锁和 B 锁才能对某资源进行操作，在多线程条件下，如何避免死锁？<br> 获得锁的顺序是一定的，比如规定，只有获得 A 锁的线程才有资格获取 B 锁，按顺序获取锁就可以避免死锁！！！</p> 
<h3><a id="5sleep___wait_nwait___179"></a>5）sleep( ) 和 wait( n)、wait( ) 的区别：</h3> 
<p>答：<br> sleep 方法：是 Thread 类的静态方法，当前线程将睡眠 n 毫秒，线程进入阻塞状态。当睡眠时间到了，会解除阻塞，进行可运行状态，等待 CPU 的到来。睡眠不释放锁（如果有的话）；<br> wait 方法：是 Object 的方法，必须与 synchronized 关键字一起使用，线程进入阻塞状态，当 notify 或者 notifyall 被调用后，会解除阻塞。但是，只有重新占用互斥锁之后才会进入可运行状态。睡眠时，释放互斥锁。</p> 
<h3><a id="6synchronized__183"></a>6）synchronized 关键字：</h3> 
<p>答：底层实现：<br> 进入时，执行 monitorenter，将计数器 +1，释放锁 monitorexit 时，计数器-1；<br> 当一个线程判断到计数器为 0 时，则当前锁空闲，可以占用；反之，当前线程进入等待状态。<br> 含义：（monitor 机制）<br> Synchronized 是在加锁，加对象锁。对象锁是一种重量锁（monitor），synchronized 的锁机制会根据线程竞争情况在运行时会有偏向锁（单一线程）、轻量锁（多个线程访问 synchronized 区域）、对象锁（重量锁，多个线程存在竞争的情况）、自旋锁等。<br> 该关键字是一个几种锁的封装。</p> 
<h3><a id="7volatile__191"></a>7）volatile 关键字</h3> 
<p>答：该关键字可以保证可见性不保证原子性。<br> 功能：<br> 主内存和工作内存，直接与主内存产生交互，进行读写操作，保证可见性；<br> 禁止 JVM 进行的指令重排序。<br> 解析：关于指令重排序的问题，可以查阅 DCL 双检锁失效相关资料。</p> 
<h3><a id="8ThreadLocal_199"></a>8）ThreadLocal（线程局部变量）关键字：</h3> 
<p>答：当使用 ThreadLocal 维护变量时，其为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立的改变自己的副本，而不会影响其他线程对应的副本。</p> 
<p>ThreadLocal 内部实现机制：</p> 
<p>每个线程内部都会维护一个类似 HashMap 的对象，称为 ThreadLocalMap，里边会包含若干了 Entry（K-V 键值对），相应的线程被称为这些 Entry 的属主线程；<br> Entry 的 Key 是一个 ThreadLocal 实例，Value 是一个线程特有对象。Entry 的作用即是：为其属主线程建立起一个 ThreadLocal 实例与一个线程特有对象之间的对应关系；<br> Entry 对 Key 的引用是弱引用；Entry 对 Value 的引用是强引用。<br> <img src="https://images2.imgbox.com/8a/43/kEwSFiBy_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="9Atomic__208"></a>9）Atomic 关键字：</h3> 
<p>答：可以使基本数据类型以原子的方式实现自增自减等操作。参考我的博客：concurrent.atomic 包下的类 AtomicInteger 的使用。</p> 
<h3><a id="10_211"></a>10）线程池有了解吗？（必考）</h3> 
<p>答：java.util.concurrent.ThreadPoolExecutor 类就是一个线程池。客户端调用 ThreadPoolExecutor.submit(Runnable task) 提交任务，线程池内部维护的工作者线程的数量就是该线程池的线程池大小，有 3 种形态：</p> 
<p>当前线程池大小 ：表示线程池中实际工作者线程的数量；<br> 最大线程池大小 （maxinumPoolSize）：表示线程池中允许存在的工作者线程的数量上限；<br> 核心线程大小 （corePoolSize ）：表示一个不大于最大线程池大小的工作者线程数量上限。<br> 如果运行的线程少于 corePoolSize，则 Executor 始终首选添加新的线程，而不进行排队；<br> 如果运行的线程等于或者多于 corePoolSize，则 Executor 始终首选将请求加入队列，而不是添加新线程；<br> 如果无法将请求加入队列，即队列已经满了，则创建新的线程，除非创建此线程超出 maxinumPoolSize， 在这种情况下，任务将被拒绝。</p> 
<h2><a id="JVM__220"></a>JVM 内存管理</h2> 
<p>既然是 Java 开发面试，那么对 JVM 的考察当然也是必须的，面试官一般会问你对 JVM 有了解吗？</p> 
<p>我通常都会把我所了解的都说一遍，包括：JVM 内存划分、JVM 垃圾回收的含义，有哪些 GC 算法，年轻代和老年代各自的特点统统阐述一遍。</p> 
<h3><a id="1JVM__225"></a>1）JVM 内存划分：</h3> 
<p>方法区（线程共享）：常量、静态变量、JIT(即时编译器) 编译后的代码也都在方法区；<br> 堆内存（线程共享）：垃圾回收的主要场所；<br> 程序计数器： 当前线程执行的字节码的位置指示器；<br> 虚拟机栈（栈内存）：保存局部变量、基本数据类型变量以及堆内存中某个对象的引用变量；<br> 本地方法栈 ：为 JVM 提供使用 native 方法的服务。</p> 
<h3><a id="2XmsXmn__232"></a>2）类似-Xms、-Xmn 这些参数的含义：</h3> 
<p>答：<br> 堆内存分配：<br> JVM 初始分配的内存由-Xms 指定，默认是物理内存的 1/64；<br> JVM 最大分配的内存由-Xmx 指定，默认是物理内存的 1/4；<br> 默认空余堆内存小于 40% 时，JVM 就会增大堆直到-Xmx 的最大限制；空余堆内存大于 70% 时，JVM 会减少堆直到 -Xms 的最小限制；<br> 因此服务器一般设置-Xms、-Xmx 相等以避免在每次 GC 后调整堆的大小。对象的堆内存由称为垃圾回收器的自动内存管理系统回收。<br> 非堆内存分配：</p> 
<p>JVM 使用-XX:PermSize 设置非堆内存初始值，默认是物理内存的 1/64；<br> 由 XX:MaxPermSize 设置最大非堆内存的大小，默认是物理内存的 1/4；<br> -Xmn2G：设置年轻代大小为 2G；<br> -XX:SurvivorRatio，设置年轻代中 Eden 区与 Survivor 区的比值。</p> 
<h3><a id="3_245"></a>3）垃圾回收算法有哪些？</h3> 
<p>答：<br> 引用计数 ：原理是此对象有一个引用，即增加一个计数，删除一个引用则减少一个计数。垃圾回收时，只用收集计数为 0 的对象。此算法最致命的是无法处理循环引用的问题；<br> 标记-清除 ：此算法执行分两阶段。第一阶段从引用根节点开始标记所有被引用的对象，第二阶段遍历整个堆，把未标记的对象清除；<br> 此算法需要暂停整个应用，同时，会产生内存碎片；</p> 
<p>复制算法 ：此算法把内存空间划为两个相等的区域，每次只使用其中一个区域。垃圾回收时，遍历当前使用区域，把正在使用中的对象复制到另外一个区域中；<br> 此算法每次只处理正在使用中的对象，因此复制成本比较小，同时复制过去以后还能进行相应的内存整理，不会出现 “碎片” 问题。当然，此算法的缺点也是很明显的，就是需要两倍内存空间；</p> 
<p>标记-整理 ：此算法结合了 “标记-清除” 和 “复制” 两个算法的优点。也是分两阶段，第一阶段从根节点开始标记所有被引用对象，第二阶段遍历整个堆，把清除未标记对象并且把存活对象 “压缩” 到堆的其中一块，按顺序排放。<br> 此算法避免了 “标记-清除” 的碎片问题，同时也避免了 “复制” 算法的空间问题。</p> 
<h3><a id="4root__root_257"></a>4）root 搜索算法中，哪些可以作为 root？</h3> 
<p>答：<br> 被启动类（bootstrap 加载器）加载的类和创建的对象；<br> JavaStack 中的引用的对象 (栈内存中引用的对象)；<br> 方法区中静态引用指向的对象；<br> 方法区中常量引用指向的对象；<br> Native 方法中 JNI 引用的对象。</p> 
<h3><a id="GCGC_265"></a>GC是什么？为什么要有GC？</h3> 
<p>答：GC是垃圾收集的意思，内存处理是编程人员容易出现问题的地方，忘记或者错误的内存回收会导致程序或系统的不稳定甚至崩溃，Java提供的GC功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的，Java语言没有提供释放已分配内存的显式操作方法。Java程序员不用担心内存管理，因为垃圾收集器会自动进行管理。要请求垃圾收集，可以调用下面的方法之一：System.gc() 或Runtime.getRuntime().gc() ，但JVM可以屏蔽掉显式的垃圾回收调用。<br> 垃圾回收可以有效的防止内存泄露，有效的使用可以使用的内存。垃圾回收器通常是作为一个单独的低优先级的线程运行，不可预知的情况下对内存堆中已经死亡的或者长时间没有使用的对象进行清除和回收，程序员不能实时的调用垃圾回收器对某个对象或所有对象进行垃圾回收。在Java诞生初期，垃圾回收是Java最大的亮点之一，因为服务器端的编程需要有效的防止内存泄露问题，然而时过境迁，如今Java的垃圾回收机制已经成为被诟病的东西。移动智能终端用户通常觉得iOS的系统比Android系统有更好的用户体验，其中一个深层次的原因就在于Android系统中垃圾回收的不可预知性。<br> 补充：垃圾回收机制有很多种，包括：分代复制垃圾回收、标记垃圾回收、增量垃圾回收等方式。标准的Java进程既有栈又有堆。栈保存了原始型局部变量，堆保存了要创建的对象。Java平台对堆内存回收和再利用的基本算法被称为标记和清除，但是Java对其进行了改进，采用“分代式垃圾收集”。这种方法会根据Java对象的生命周期将堆内存划分为不同的区域，在垃圾收集过程中，可能会将对象移动到不同区域：</p> 
<p>伊甸园（Eden）：这是对象最初诞生的区域，并且对大多数对象来说，这里是它们唯一存在过的区域。<br> 幸存者乐园（Survivor）：从伊甸园幸存下来的对象会被挪到这里。<br> 终身颐养园（Tenured）：这是足够老的幸存对象的归宿。年轻代收集（Minor-GC）过程是不会触及这个地方的。当年轻代收集不能把对象放进终身颐养园时，就会触发一次完全收集（Major-GC），这里可能还会牵扯到压缩，以便为大对象腾出足够的空间。</p> 
<h3><a id="5GC__273"></a>5）GC（垃圾回收机制） 什么时候开始？</h3> 
<p>答：GC 经常发生的区域是堆区，堆区还可以细分为新生代、老年代，新生代还分为一个 Eden 区和两个 Survivor 区。<br> 对象优先在 Eden 中分配，当 Eden 中没有足够空间时，虚拟机将发生一次 Minor GC，因为 Java 大多数对象都是朝生夕灭，所以 Minor GC 非常频繁，而且速度也很快；<br> Full GC，发生在老年代的 GC，当老年代没有足够的空间时即发生 Full GC，发生 Full GC 一般都会有一次 Minor GC。<br> 大对象直接进入老年代，如很长的字符串数组，虚拟机提供一个；XX:PretenureSizeThreadhold 参数，令大于这个参数值的对象直接在老年代中分配，避免在 Eden 区和两个 Survivor 区发生大量的内存拷贝；</p> 
<p>发生 Minor GC 时，虚拟机会检测之前每次晋升到老年代的平均大小是否大于老年代的剩余空间大小，如果大于，则进行一次 Full GC，如果小于，则查看 HandlePromotionFailure 设置是否允许担保失败，如果允许，那只会进行一次 Minor GC，如果不允许，则改为进行一次 Full GC。</p> 
<h3><a id="6_280"></a>6）内存泄漏和内存溢出</h3> 
<p>答：<br> 概念：内存溢出指的是内存不够用了；<br> 内存泄漏是指对象可达，但是没用了。即本该被 GC 回收的对象并没有被回收；内存泄露是导致内存溢出的原因之一；内存泄露积累起来将导致内存溢出。<br> 内存泄漏的原因分析：长生命周期的对象引用短生命周期的对象；没有将无用对象置为 null。</p> 
<h3><a id="7_stackheapmethod_area_285"></a>7） 解释内存中的栈(stack)、堆(heap)和方法区(method area)的用法。</h3> 
<p>答：通常我们定义一个基本数据类型的变量，一个对象的引用，还有就是函数调用的现场保存都使用JVM中的栈空间；而通过new关键字和构造器创建的对象则放在堆空间，堆是垃圾收集器管理的主要区域，由于现在的垃圾收集器都采用分代收集算法，所以堆空间还可以细分为新生代和老生代，再具体一点可以分为Eden、Survivor（又可分为From Survivor和To Survivor）、Tenured；方法区和堆都是各个线程共享的内存区域，用于存储已经被JVM加载的类信息、常量、静态变量、JIT编译器编译后的代码等数据；程序中的字面量（literal）如直接书写的100、"hello"和常量都是放在常量池中，常量池是方法区的一部分，。栈空间操作起来最快但是栈很小，通常大量的对象都是放在堆空间，栈和堆的大小都可以通过JVM的启动参数来进行调整，栈空间用光了会引发StackOverflowError，而堆和常量池空间不足则会引发OutOfMemoryError。</p> 
<pre><code>String str = new String("hello");
</code></pre> 
<p>上面的语句中变量str放在栈上，用new创建出来的字符串对象放在堆上，而"hello"这个字面量是放在方法区的。</p> 
<h3><a id="9Java__292"></a>9）Java 中会存在内存泄漏吗，请简单描述。</h3> 
<p>理论上Java因为有垃圾回收机制（GC）不会存在内存泄露问题（这也是Java被广泛使用于服务器端编程的一个重要原因）；然而在实际开发中，可能会存在无用但可达的对象，这些对象不能被GC回收，因此也会导致内存泄露的发生。例如Hibernate的Session（一级缓存）中的对象属于持久态，垃圾回收器是不会回收这些对象的，然而这些对象中可能存在无用的垃圾对象，如果不及时关闭（close）或清空（flush）一级缓存就可能导致内存泄露。</p> 
<h2><a id="Java_8__294"></a>Java 8 相关知识点</h2> 
<p>关于 Java8 中新知识点，面试官会让你说说 Java8 你了解多少，下边主要阐述我所了解，并且在面试中回答的 Java8 新增知识点。</p> 
<p>1）HashMap 的底层实现有变化：HashMap 是数组 + 链表 + 红黑树（JDK1.8 增加了红黑树部分）实现。</p> 
<p>2）JVM 内存管理方面，由元空间代替了永久代。</p> 
<p>区别：</p> 
<p>元空间并不在虚拟机中，而是使用本地内存；<br> 默认情况下，元空间的大小仅受本地内存限制；<br> 也可以通过-XX：MetaspaceSize 指定元空间大小。<br> 3）Lambda 表达式（也称为闭包），允许我们将函数当成参数传递给某个方法，或者把代码本身当做数据处理。</p> 
<p>4）函数式接口：指的是只有一个函数的接口，java.lang.Runnable 和 java.util.concurrent.Callable 就是函数式接口的例子；java8 提供了一个特殊的注解 @Functionallnterface 来标明该接口是一个函数式接口。</p> 
<p>5）引入重复注解：Java 8 中使用 @Repeatable 注解定义重复注解。</p> 
<p>6）接口中可以实现方法 default 方法。</p> 
<p>7） 注解的使用场景拓宽： 注解几乎可以使用在任何元素上：局部变量、接口类型、超类和接口实现类，甚至可以用在函数的异常定义上。</p> 
<p>8） 新的包 java.time 包</p> 
<p>包含了所有关于日期、时间、时区、持续时间和时钟操作的类；<br> 这些类都是不可变的、线程安全的。</p> 
<h2><a id="_320"></a>数据库知识点</h2> 
<h3><a id="1MySQL__MongoDB__321"></a>1）MySQL 和 MongoDB 的区别有哪些？如何选择？</h3> 
<p>MySQL是关系型数据库。</p> 
<p>优势：在不同的引擎上有不同 的存储方式。查询语句是使用传统的sql语句，拥有较为成熟的体系，成熟度很高。开源数据库的份额在不断增加，mysql的份额页在持续增长。</p> 
<p>缺点：在海量数据处理的时候效率会显著变慢。</p> 
<p>Mongodb是非关系型数据库(nosql ),属于文档型数据库。文档是mongoDB中数据的基本单元，类似关系数据库的行，多个键值对有序地放置在一起便是文档，语法有点类似javascript面向对象的查询语言，它是一个面向集合的，模式自由的文档型数据库。<br> 存储方式：虚拟内存+持久化。<br> 查询语句：是独特的Mongodb的查询方式。<br> 适合场景：事件的记录，内容管理或者博客平台等等。<br> 架构特点：可以通过副本集，以及分片来实现高可用。<br> 数据处理：数据是存储在硬盘上的，只不过需要经常读取的数据会被加载到内存中，将数据存储在物理内存中，从而达到高速读写。<br> 成熟度与广泛度：新兴数据库，成熟度较低，Nosql数据库中最为接近关系型数据库，比较完善的DB之一，适用人群不断在增长。</p> 
<p>优点：快速！在适量级的内存的Mongodb的性能是非常迅速的，它将热数据存储在物理内存中，使得热数据的读写变得十分快。高扩展性，存储的数据格式是json格式！</p> 
<p>缺点：不支持事务，而且开发文档不是很完全，完善。</p> 
<p>Mysql和Mongodb主要应用场景</p> 
<p>1.如果需要将mongodb作为后端db来代替mysql使用，即这里mysql与mongodb 属于平行级别，那么，这样的使用可能有以下几种情况的考量： (1)mongodb所负责部分以文档形式存储，能够有较好的代码亲和性，json格式的直接写入方便。(如日志之类) (2)从datamodels设计阶段就将原子性考虑于其中，无需事务之类的辅助。开发用如nodejs之类的语言来进行开发，对开发比较方便。 (3)mongodb本身的failover机制，无需使用如MHA之类的方式实现。</p> 
<p>2.将mongodb作为类似redis ，memcache来做缓存db，为mysql提供服务，或是后端日志收集分析。 考虑到mongodb属于nosql型数据库，sql语句与数据结构不如mysql那么亲和 ，也会有很多时候将mongodb做为辅助mysql而使用的类redis memcache 之类的缓存db来使用。 亦或是仅作日志收集分析。</p> 
<h3><a id="3_346"></a>3）听说过事务吗？（必考）</h3> 
<p>答：作为单个逻辑工作单元执行的一系列操作，满足四大特性：</p> 
<p>原子性（Atomicity）：事务作为一个整体被执行 ，要么全部执行，要么全部不执行；<br> 一致性（Consistency）：保证数据库状态从一个一致状态转变为另一个一致状态；<br> 隔离性（Isolation）：多个事务并发执行时，一个事务的执行不应影响其他事务的执行；<br> 持久性（Durability）：一个事务一旦提交，对数据库的修改应该永久保存。</p> 
<h3><a id="4_354"></a>4）事务的并发问题有哪几种？</h3> 
<p>①脏读：是指一个事务读到另一个事务未提交的数据</p> 
<p>②不可重复读：在一个事务中，两次查询到的结果不一致(针对 update 操作)</p> 
<p>③虚读(幻读)：在一个事务中，两次查询到的结果不一致(针对 insert 操作)</p> 
<h3><a id="5_362"></a>5）数据库中的锁有哪几种？</h3> 
<p>答：独占锁、排他锁以及更新锁。</p> 
<h3><a id="6_365"></a>6）事务的隔离级别有哪几种？</h3> 
<p>①读未提交（Read uncommitted）：最低级别，上述情况都不能避免</p> 
<p>②读已提交（Read committed）：可避免 脏读 发生。Oracle默认隔离级别</p> 
<p>③可重复读（Repeatable read）：可避免 脏读、不可重复读 发生。Mysql默认隔离级别</p> 
<p>④串行化（Serializable）：可避免 脏读、不可重复读、虚读 发生</p> 
<h3><a id="7__376"></a>7）数据库的索引有什么作用？（必考） 底层数据结构是什么，为什么使用这种数据结构？</h3> 
<p>答：索引 是对数据库表中一列或多列的值进行排序的一种结构，使用索引可快速访问数据库表中的特定信息；<br> 底层数据结构是 B+ 树；<br> 从结构上来看，索引好比是一棵B+树，假设学生表里只有学生ID和姓名两列，该学生表里有1000个学生，学号分别从1到1000，如果针对ID建立索引，大致的结构如下图所示<br> <img src="https://images2.imgbox.com/2c/ff/IZlLSQm8_o.png" alt="在这里插入图片描述"><br> 当然，在实际的数据库系统中，索引要比这个复杂得多，但从这个图里，我们能大致看出索引的工作原理。索引建好后，如果我们要查找ID为111的学生，则数据库系统就会走索引，从图2.1中我们可以看到，根据根节点的指引，会 找到第二层从左往右第二个数据块，以此类推，会在第四层里得到ID为111的物理地址，然后直接从硬盘里找数据。 反过来，如果没有建索引，数据库系统可能就要从一个大的范围里逐一定位查找，效率就没这么高了。 索引的好处大家已经看到了，那么为了得到这个“查询效率高”的好处，我们要付出了什么样的代价呢？</p> 
<pre><code>   1  索引需要占硬盘空间，这是空间方面的代价。

   2  一旦插入新的数据，就需要重新建索引，这是时间上的代价。
</code></pre> 
<p>如果出现一些不好的SQL语句，那么索引就白建了。下面通过一些具体的例子来看索引的正确用法。</p> 
<pre><code>  ①语句一：select name from 商品表。不会用到索引，因为没有where语句。

  ②语句二：select * from 商品表 where name = ‘Java书’，会用到索引，如果项目里经常用到name来查询，且商品表的数据量很大，而name值的重复率又不高，那么建议建索引。

  ③语句三：select * from 商品表 where name like ‘Java%’  这是个模糊查询，会用到索引，请大家记住，用like进行模糊查询时，如果第一个就是模糊的匹配符，比如where name like ‘%java’，那么在查询时不会走索引。在其他情况下，不论用了多少个%，也不论%的位置，只要不出现在第一个位置，那么都能用到索引。
</code></pre> 
<p>学生成绩表里有两个字段：姓名和成绩。现在对成绩这个整数类型的字段建索引。</p> 
<pre><code>    ①第一种情况，当数字型字段遇到非等值操作符时，无法用到索引。比如：

    select name from 学生成绩表 where 成绩&gt;95 , 一旦出现大于符号，就不能用到索引，为了用到索引，我们应该改一下SQL语句里的where从句：where 成绩 in (96,97,98,99,100)

    ② 第二种情况，如果对索引字段进行了某种左值操作，那么无法用到索引。

     能用到索引的写法：select name from 学生成绩表 where 成绩 = 60

     不能用到索引的写法：select name from 学生成绩表 where 成绩+40 = 100

    ③ 第三种情况，如果对索引字段进行了函数操作，那么无法用到索引。

    比如SQL语句：select * from 商品表 where substr(name) = ‘J’，我们希望查询商品名首字母是J的记录，可一旦针对name使用函数，即使name字段上有索引，也无法用到。
</code></pre> 
<h3><a id="8_Wheregroup_byhaving__413"></a>8）数据库中 Where、group by、having 关键字：</h3> 
<p>答： 关键字作用：</p> 
<p>where 子句用来筛选 from 子句中指定的操作所产生的的行；<br> group by 子句用来分组 where 子句的输出；<br> having 子句用来从分组的结果中筛选行；<br> having 和 where 的区别：</p> 
<p>语法类似，where 搜索条件在进行分组操作之前应用；having 搜索条件在进行分组操作之后应用；<br> having 可以包含聚合函数 sum、avg、max 等；<br> having 子句限制的是组，而不是行。<br> 当同时含有 where 子句、group by 子句 、having 子句及聚集函数时，执行顺序如下：</p> 
<p>执行 where 子句查找符合条件的数据；<br> 使用 group by 子句对数据进行分组；对 group by 子句形成的组运行聚集函数计算每一组的值；最后用 having 子句去掉不符合条件的组。</p> 
<h3><a id="_429"></a>处理上百万条的数据库如何提高处理查询速度</h3> 
<p>1、对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。</p> 
<p>2、应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描。</p> 
<p>3、应尽量避免在 where 子句中使用!=或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描。</p> 
<p>4、应尽量避免在 where 子句中使用 or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描。</p> 
<p>5、可以使用redis缓存经常查询的数据。</p> 
<p>6、应尽量避免在 where 子句中对字段进行表达式操作。</p> 
<p>7、应尽量避免在where子句中对字段进行函数操作。</p> 
<p>8、尽量避免大事务操作，提高系统并发能力。</p> 
<p>9、尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理。</p> 
<p>10、提高服务器的物理性能。</p> 
<h2><a id="MVC__450"></a>MVC 框架相关知识点</h2> 
<p>JavaWeb 开发经典的 3 层框架：Web 层、Service 层（业务逻辑层）和 Dao 层（数据访问层）</p> 
<p>Web 层：包含 JSP 和 Servlet 等与 Web 相关的内容；<br> 业务层：只关心业务逻辑；<br> 数据层：封装了对数据库的访问细节。</p> 
<h2><a id="Spring__457"></a>Spring 知识点</h2> 
<h3><a id="1Spring__IOC__AOP__459"></a>1）Spring 的 IOC 和 AOP 有了解吗？</h3> 
<p>答：<br> IOC：控制反转，（解耦合）将对象间的依赖关系交给 Spring 容器，使用配置文件来创建所依赖的对象，由主动创建对象改为了被动方式；<br> AOP：面向切面编程，将功能代码从业务逻辑代码中分离出来。</p> 
<h3><a id="2AOP__464"></a>2）AOP 的实现方式有哪几种？如何选择？（必考）</h3> 
<p>答：JDK 动态代理实现和 cglib 实现。<br> 选择：<br> 如果目标对象实现了接口，默认情况下会采用 JDK 的动态代理实现 AOP，也可以强制使用 cglib 实现 AOP；<br> 如果目标对象没有实现接口，必须采用 cglib 库，Spring 会自动在 JDK 动态代理和 cglib 之间转换。<br> 扩展：JDK 动态代理如何实现？（加分点）</p> 
<p>答：JDK 动态代理，只能对实现了接口的类生成代理，而不是针对类，该目标类型实现的接口都将被代理。原理是通过在运行期间创建一个接口的实现类来完成对目标对象的代理。</p> 
<p>定义一个实现接口 InvocationHandler 的类；<br> 通过构造函数，注入被代理类；<br> 实现 invoke（ Object proxy, Method method, Object[] args）方法；<br> 在主函数中获得被代理类的类加载器；<br> 使用 Proxy.newProxyInstance( ) 产生一个代理对象；<br> 通过代理对象调用各种方法。<br> 解析：关于 IOC 和 AOP 的详细阐述，请各位参阅我的博客：Spring 核心 AOP（面向切面编程）总结，Spring 框架学习—控制反转（IOC）</p> 
<h3><a id="Spring_481"></a>Spring创建对象的三种方式</h3> 
<p>1.通过构造方法创建<br> 2.实例工厂<br> 3.静态工厂</p> 
<h4><a id="IoCDI_485"></a>IoC和DI的区别</h4> 
<p>1.IoC（反转控制）： 将对象创建权利交给Spring工厂进行管理。<br> 2.DI：依赖注入。是指spring框架在创建bean对象时，动态的将依赖对象注入到bean组件中，（2种）：构造器注入 <code>&lt;constructor-arg&gt;</code> 、 属性setter注入 <code>&lt;property&gt;</code></p> 
<h4><a id="IoCBean_488"></a>IoC容器装配Bean两种方法</h4> 
<p>1.基于XML配置方式<br> 第一种方式 无参数构造器<br> 第二种方式 静态工厂方法<br> 第三种方式 实例工厂方法<br> xml做法 ：<code>&lt;bean id=”customerService” class=”…” /&gt;</code>，用<code>&lt;bean&gt;</code>的方式创建对象<br> 2.基于注解配置方式<br> 引入 <code>@Component</code> 注解 如果放置到类的上面，相当于在spring容器中定义<code>&lt;bean id=”” class=””&gt;</code>，</p> 
<pre><code>/**
 * @Component注解放置到类上
 * 相当于spring容器中定义：&lt;bean id="customerService" class="com.igeek.ioc.CustomerService"&gt;
 * 其中id属性默认bean的名字是类名的小写
 * ——————————————————————————————————————————————————————
 * @Component(value="customer")//自定义bean的名字
 * 相当于spring容器中定义：&lt;bean id="customer" class="com.igeek.ioc.CustomerService"&gt;
 * ——————————————————————————————————————————————————————
 */
@Component(value="customer")
public class CustomerService {
	
	//保存业务方法
	public void save(){
		System.out.println("CustomerService业务层被调用了。。。");
	}

}
</code></pre> 
<p>配置注解开启和注解Bean的扫描。</p> 
<pre><code>&lt;!-- 配置注解扫描 
			context:component-scan:专门扫描含有@Component注解的类，自动将其作为bean
			base-package：要扫描包的路径,包含子包,com.igeek.ioc表示子包下的所有类定义注解都有效
			注解扫描配置的时候，会自动开启注解功能
	--&gt;
	&lt;context:component-scan base-package="com.igeek.ioc"/&gt;
</code></pre> 
<p>实际开发中，使用的是@Component三个衍生注解（“子注解”）<br> 子注解的作用：有分层的意义（分层注解）。</p> 
<pre><code>Spring3.0为我们引入了组件自动扫描机制，它可以在类路径底下寻找标注了@Component、@Service、@Controller、@Repository注解的类，并把这些类纳入进spring容器中管理。
除了@Component外，Spring提供了3个功能基本和@Component等效的注解
功能介绍
@Service用于标注业务层组件、（如Service层）
@Controller用于标注控制层组件（如struts中的action层）
@Repository用于标注数据访问组件，（如DAO层组件）。
而@Component泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注。
</code></pre> 
<h3><a id="AOP__540"></a>什么是AOP ？</h3> 
<p>OP (Aspect Oriented Programing) 称为：<strong>面向切面编程</strong>，它是一种编程思想。<br> AOP采取<strong>横向抽取</strong>机制，取代了传统纵向继承体系重复性代码的编写方式（例如性能监视、事务管理、安全检查、缓存、日志记录等）。<br> 什么是OCP：即开闭原则。<br> <img src="https://images2.imgbox.com/4d/29/xPUCNccW_o.png" alt="在这里插入图片描述"><br> AOP 思想： 基于代理思想，对原来目标对象，创建代理对象，在不修改原对象代码情况下，通过代理对象，调用增强功能的代码，从而对原有业务方法进行增强 ！<br> 切面：需要代理一些方法和增强代码 。</p> 
<h4><a id="BeanFactoryFactoryBean_547"></a>BeanFactory和FactoryBean的区别？</h4> 
<p>BeanFactory：是一个工厂（其实是构建了一个spring上下文的环境，容器），用来管理和获取很多Bean对象，例如：加载applicationContext.xml文件。<br> FactoryBean：是一个Bean生成工具，是用来获取一种类型对象的Bean，它是构造Bean实例的一种方式。</p> 
<h4><a id="ELOGNLspEL_551"></a>什么是EL、OGNL、spEL？</h4> 
<p>EL：操作servlet相关的一些对象和相关的值，${request.name}<br> OGNL：主要操作struts2值栈,&lt;s:property value=”#request.name”&gt;<br> spEL：操作bean相关的</p> 
<h4><a id="_556"></a>动态代理和静态代理区别？</h4> 
<p>动态代理：在虚拟机内部，运行的时候，动态生成代理类(运行时生成，runtime生成) ，并不是真正存在的类， 一般格式：Proxy<span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          （ 
         
        
          P 
         
        
          r 
         
        
          o 
         
        
          x 
         
        
          y 
         
        
       
         （Proxy 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.87777em; vertical-align: -0.19444em;"></span><span class="mord cjk_fallback">（</span><span class="mord mathdefault" style="margin-right: 0.13889em;">P</span><span class="mord mathdefault" style="margin-right: 0.02778em;">r</span><span class="mord mathdefault">o</span><span class="mord mathdefault">x</span><span class="mord mathdefault" style="margin-right: 0.03588em;">y</span></span></span></span></span></span>Customer）<br> 静态代理：实际存在代理类 （例如：struts2 Action的代理类 ActionProxy，struts2的拦截器）</p> 
<h4><a id="REQUIREDREQUIRES_NEWNESTED__560"></a>REQUIRED、REQUIRES_NEW、NESTED 区分</h4> 
<p>REQUIRED：只有一个事务(默认，推荐)<br> REQUIRES_NEW：存在两个事务 ，如果事务存在，挂起事务，重新又开启了一个新的事务<br> NESTED 嵌套事务，事务可以设置保存点，回滚到保存点 ，选择提交或者回滚</p> 
<h3><a id="Mybatis__564"></a>Mybatis 知识点</h3> 
<p>关于 MyBatis 主要考察占位符#和 $ 的区别，区别如下：</p> 
<p>符号将传入的数据都当做一个字符串，会对自动传入的数据加一个双引号；<br> $ 符号将传入的数据直接显示生成 SQL 中；<br> 符号存在预编译的过程，，对问号赋值，防止 SQL 注入；<br> $ 符号是直译的方式，一般用在 order by ${列名}语句中；<br> 能用#号就不要用 $ 符号。</p> 
<h3><a id="Spring_MVC_572"></a>Spring MVC</h3> 
<h4><a id="Spring_MVC__573"></a>Spring MVC 的核心控制器是什么？消息处理流程有哪些？</h4> 
<p>答：核心控制器为 DispatcherServlet。消息流程如下：<br> <img src="https://images2.imgbox.com/17/7d/W4zgMqzL_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="Spring_Boot_576"></a>Spring Boot</h3> 
<h2><a id="_577"></a>异常</h2> 
<h3><a id="ErrorException_578"></a>Error和Exception有什么区别？</h3> 
<p>Error表示系统级的错误和程序不必处理的异常，是恢复不是不可能但很困难的情况下的一种严重问题；比如内存溢出，不可能指望程序能处理这样的情况；Exception表示需要捕捉或者需要程序进行处理的异常，是一种设计或实现问题；也就是说，它表示如果程序运行正常，从不会发生的情况。</p> 
<h3><a id="tryreturntryfinallyreturn_580"></a>try{}里有一个return语句，那么紧跟在这个try后的finally{}里的代码会不会被执行，什么时候被执行，在return前还是后?</h3> 
<p>会执行，在方法返回前执行。</p> 
<h3><a id="Javathrowsthrowtrycatchfinally_582"></a>Java语言如何进行异常处理，关键字：throws、throw、try、catch、finally分别如何使用？</h3> 
<p>答：Java通过面向对象的方法进行异常处理，把各种不同的异常进行分类，并提供了良好的接口。在Java中，每个异常都是一个对象，它是Throwable类或其子类的实例。当一个方法出现异常后便抛出一个异常对象，该对象中包含有异常信息，调用这个对象的方法可以捕获到这个异常并可以对其进行处理。Java的异常处理是通过5个关键词来实现的：try、catch、throw、throws和finally。一般情况下是用try来执行一段程序，如果系统会抛出（throw）一个异常对象，可以通过它的类型来捕获（catch）它，或通过总是执行代码块（finally）来处理；try用来指定一块预防所有异常的程序；catch子句紧跟在try块后面，用来指定你想要捕获的异常的类型；throw语句用来明确地抛出一个异常；throws用来声明一个方法可能抛出的各种异常（当然声明异常时允许无病呻吟）；finally为确保一段代码不管发生什么异常状况都要被执行；try语句可以嵌套，每当遇到一个try语句，异常的结构就会被放入异常栈中，直到所有的try语句都完成。如果下一级的try语句没有对某种异常进行处理，异常栈就会执行出栈操作，直到遇到有处理这种异常的try语句或者最终将异常抛给JVM。</p> 
<h3><a id="_584"></a>运行时异常与受检异常有何异同？</h3> 
<p>答：异常表示程序运行过程中可能出现的非正常状态，运行时异常表示虚拟机的通常操作中可能遇到的异常，是一种常见运行错误，只要程序设计得没有问题通常就不会发生。受检异常跟程序运行的上下文环境有关，即使程序设计无误，仍然可能因使用的问题而引发。Java编译器要求方法必须声明抛出可能发生的受检异常，但是并不要求必须声明抛出未被捕获的运行时异常。异常和继承一样，是面向对象程序设计中经常被滥用的东西，在Effective Java中对异常的使用给出了以下指导原则：</p> 
<p>不要将异常处理用于正常的控制流（设计良好的API不应该强迫它的调用者为了正常的控制流而使用异常）<br> 对可以恢复的情况使用受检异常，对编程错误使用运行时异常<br> 避免不必要的使用受检异常（可以通过一些状态检测手段来避免异常的发生）<br> 优先使用标准的异常<br> 每个方法抛出的异常都要有文档<br> 保持异常的原子性<br> 不要在catch中忽略掉捕获到的异常</p> 
<h3><a id="_594"></a>列出一些你常见的运行时异常？</h3> 
<p>ArithmeticException（算术异常）<br> ClassCastException （类转换异常）<br> IllegalArgumentException （非法参数异常）<br> IndexOutOfBoundsException （下标越界异常）<br> NullPointerException （空指针异常）<br> SecurityException （安全异常）</p> 
<h2><a id="Linux__602"></a>Linux 常见命令</h2> 
<h3><a id="1grepsed__awk__603"></a>1）grep、sed 以及 awk 命令</h3> 
<h3><a id="2_604"></a>2）文件和目录</h3> 
<p>ls 显示当前目录下的文件和目录：</p> 
<p>ls -F 可以区分文件和目录；<br> ls -a 可以把隐藏文件和普通文件一起显示出来；<br> ls -R 可以递归显示子目录中的文件和目录；<br> ls -l 显示长列表；<br> ls -l test 过滤器，查看某个特定文件信息。可以只查看 test 文件的信息。</p> 
<h3><a id="3touchcp_Inmvrm_612"></a>3）处理文件方面的命令有：touch、cp、 In、mv、rm、</h3> 
<h3><a id="4mkdir_614"></a>4）处理目录方面的命令：mkdir</h3> 
<h3><a id="5filecatmorelesstailhead_616"></a>5）查看文件内容：file、cat、more、less、tail、head</h3> 
<h3><a id="6pstop_618"></a>6）监测程序命令：ps、top</h3> 
<p>eg. 找出进程名中包括 java 的所有进程：ps -ef | grep java</p> 
<p>top 命令 实时监测进程</p> 
<p>top 命令输出的第一部分：显示系统的概括。</p> 
<p>第一行显示了当前时间、系统的运行时间、登录的用户数和系统的平均负载（平均负载有 3 个值：最近 1min 5min 15min）；<br> 第二行显示了进程的概要信息，有多少进程处于运行、休眠、停止或者僵化状态；<br> 第三行是 CPU 的概要信息；<br> 第四行是系统内存的状态。</p> 
<h3><a id="7ps__top__630"></a>7）ps 和 top 命令的区别：</h3> 
<p>ps 看到的是命令执行瞬间的进程信息 , 而 top 可以持续的监视；<br> ps 只是查看进程 , 而 top 还可以监视系统性能 , 如平均负载 ,cpu 和内存的消耗；<br> 另外 top 还可以操作进程 , 如改变优先级 (命令 r) 和关闭进程 (命令 k)；<br> ps 主要是查看进程的，关注点在于查看需要查看的进程；<br> top 主要看 cpu, 内存使用情况，及占用资源最多的进程由高到低排序，关注点在于资源占用情况。</p> 
<h3><a id="8__637"></a>8） 压缩数据</h3> 
<p>tar -xvf 文件名；<br> tar -zxvf 文件名；<br> tar -cvzf 文件名。</p> 
<h3><a id="9kill_PID__kill_all_641"></a>9）结束进程：kill PID 或者 kill all</h3> 
<h2><a id="_642"></a>网络协议相关</h2> 
<h3><a id="1_643"></a>1）三次握手、四次挥手示意图：</h3> 
<p><img src="https://images2.imgbox.com/90/d0/PlEqzfFt_o.png" alt="在这里插入图片描述"><br> 总共有四种状态：主动建立连接、主动断开连接、被动建立连和被动断开连接</p> 
<p>两两组合还是 4 种组合：</p> 
<p>主动建立连接、主动断开连接会经历的状态：<br> SYNC_SENT——ESTABLISHED—-FIN_WAIT_1—-FIN_WAIT_2—-TIME_WAIT<br> 主动建立连接、被动断开连接会经历的状态：<br> SYNC_SENT——ESTABLISHED—-CLOSE_WAIT—-LAST_ACK<br> 被动建立连接、主动断开连接会经历的状态：<br> LISTEN—-SYN_RCVD—-ESTABLISHED—-FIN_WAIT_1—-FIN_WAIT_2—-TIME_WAIT<br> 被动建立连接、被动断开连接会经历的状态：<br> LISTEN—-SYN_RCVD—-ESTABLISHED—-CLOSE_WAIT—-LAST_ACK</p> 
<h3><a id="2_657"></a>2）滑动窗口机制</h3> 
<p>由发送方和接收方在三次握手阶段，互相将自己的最大可接收的数据量告诉对方。也就是自己的数据接收缓冲池的大小。这样对方可以根据已发送的数据量来计算是否可以接着发送。</p> 
<p>在处理过程中，当接收缓冲池的大小发生变化时，要给对方发送更新窗口大小的通知。</p> 
<h3><a id="3_663"></a>3）拥塞避免机制</h3> 
<p>拥塞：对资源的需求超过了可用的资源。若网络中许多资源同时供应不足，网络的性能就要明显变坏，整个网络的吞吐量随之负荷的增大而下降。</p> 
<p>拥塞控制：防止过多的数据注入到网络中，使得网络中的路由器或链路不致过载。</p> 
<p>拥塞控制方法：</p> 
<p>慢开始 + 拥塞避免；<br> 快重传 + 快恢复。<br> <img src="https://images2.imgbox.com/8c/b6/TuMoCEnG_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/f0/26/MbHWEuDb_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="4wwwxxxcom__675"></a>4）浏览器中输入：“www.xxx.com” 之后都发生了什么？请详细阐述。</h3> 
<p>解析：经典的网络协议问题。<br> 答：<br> 由域名→IP 地址<br> 寻找 IP 地址的过程依次经过了浏览器缓存、系统缓存、hosts 文件、路由器缓存、 递归搜索根域名服务器。<br> 建立 TCP/IP 连接（三次握手具体过程）<br> 由浏览器发送一个 HTTP 请求<br> 经过路由器的转发，通过服务器的防火墙，该 HTTP 请求到达了服务器<br> 服务器处理该 HTTP 请求，返回一个 HTML 文件<br> 浏览器解析该 HTML 文件，并且显示在浏览器端<br> 这里需要注意：<br> HTTP 协议是一种基于 TCP/IP 的应用层协议，进行 HTTP 数据请求必须先建立 TCP/IP 连接<br> 可以这样理解：HTTP 是轿车，提供了封装或者显示数据的具体形式；Socket 是发动机，提供了网络通信的能力。<br> 两个计算机之间的交流无非是两个端口之间的数据通信 , 具体的数据会以什么样的形式展现是以不同的应用层协议来定义的。</p> 
<h3><a id="5_HTTP__690"></a>5）常见 HTTP 状态码</h3> 
<p>1xx（临时响应）<br> 2xx（成功）<br> 3xx（重定向）：表示要完成请求需要进一步操作<br> 4xx（错误）：表示请求可能出错，妨碍了服务器的处理<br> 5xx（服务器错误）：表示服务器在尝试处理请求时发生内部错误<br> 常见状态码：<br> 200（成功）<br> 304（未修改）：自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容<br> 401（未授权）：请求要求身份验证<br> 403（禁止）：服务器拒绝请求<br> 404（未找到）：服务器找不到请求的网页</p> 
<h3><a id="6TCP__UDP__702"></a>6）TCP 和 UDP 的区别：</h3> 
<p>答：<br> 回答发送数据前是否存在建立连接的过程；<br> ＴＣＰ过确认机制，丢包可以重发，保证数据的正确性；ＵＤＰ不保证正确性，只是单纯的负责发送数据包；<br> UDP 是面向报文的。发送方的 UDP 对应用程序交下来的报文，在添加首部后就向下交付给 IP 层。既不拆分，也不合并，而是保留这些报文的边界，因 此，应用程序需要选择合适的报文大小；<br> UDP 的头部，只有 8 个字节，相对于 TCP 头部的 20 个字节信息包的额外开销很小。<br> 限于篇幅，更多网络协议相关知识，请参阅我的博客：TCP/IP 协议面试常问知识点，倾心总结</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/44c001b741ac343b59da5f16a137c4b2/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">STM32CubeIDE使用总结（三）——debug调试程序</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0e92df10083bcfcf22e10b8a867e7799/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">ES集群搭建及Kibana安装、操作</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>