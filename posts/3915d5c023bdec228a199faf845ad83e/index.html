<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>R语言：商业数据分析实例（2）【k-means, t-test】 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="R语言：商业数据分析实例（2）【k-means, t-test】" />
<meta property="og:description" content="适用于初学者。内容包括k-mean和t-test的使用。
使用到的数据：链接：https://pan.baidu.com/s/1yhzQSdquizLayXamM0wygg 提取码：3b7i
前言：k-means实现 k-means算法，是一种最广泛使用的聚类算法。k-means以k作为参数，把数据分为k个组，通过迭代计算过程，将各个分组内的所有数据样本的均值作为该类的中心点，使得组内数据具有较高的相似度，而组间的相似度最低。（引用自：张丹(Conan)）
k-means工作原理：
初始化数据，选择k个对象作为中心点。遍历整个数据集，计算每个点与每个中心点的距离，将它分配给距离中心最近的组。重新计算每个组的平均值，作为新的聚类中心。上面2-3步，过程不断重复，直到函数收敛，不再新的分组情况出现。 案例简介 用到的数据共4张表（cvs格式），为2003-2019年美国纽约市房地产交易数据。
NYC_HISTORICAL包含：交易ID，社区ID，地址，建筑类型，时间，价格，面积等；
BOROUGH包含：BOROUGH_ID和BOROUG名称；
BUILDING_CLASS包含：建筑ID和建筑类型等；
NEIGHBORHOOD 包含：街道ID和BOROUGH_ID等；
本案例需要根据ID整合数据，从中提取目标信息。
本章目标 任务1：使用以下KPI执行k-means聚类。描述所选社区所属的聚类。
自2009年以来，住宅物业的价格中值自2009年以来，住宅物业的销售数量自2009年以来，住宅物业的价格标准差自2009年以来，住宅地产的每平方米价格 任务2：选择另一个社区（如 ID：31），并检验以下假设：从2009年开始，社区（ ID：29）的平均住宅物业价格大于所选的另外一个社区
开始：载入所需的包，并设置工作地址
library(lubridate) #year() library(tidyverse) #csv2 library(factoextra) library(cluster) setwd(&#34;C:/Users/10098/Desktop/AD571/571，A34&#34;) 读取所有csv文件。第四个NYC_HISTORICAL较大（150M），且用分号隔开，故用csv2读取
BOROUGH &lt;- read.csv(&#34;BOROUGH.csv&#34;, header=TRUE) BUILDING_CLASS &lt;- read.csv(&#34;BUILDING_CLASS.csv&#34;, header=TRUE) NEIGHBORHOOD &lt;- read.csv(&#34;NEIGHBORHOOD.csv&#34;, header=TRUE) NYC_HISTORICAL &lt;- read_csv2(&#34;NYC_HISTORICAL.csv&#34;) 将各表数据整合
NYC_HISTORICAL &lt;- mutate(NYC_HISTORICAL, Y = year(SALE_DATE)) NEIGHBORHOOD = left_join(NEIGHBORHOOD,BOROUGH, by = &#39;BOROUGH_ID&#39;) df &lt;- NYC_HISTORICAL %&gt;% left_join(BUILDING_CLASS, by = c(&#39;BUILDING_CLASS_FINAL_ROLL&#39;=&#39;BUILDING_CODE_ID&#39;)) %&gt;% left_join(NEIGHBORHOOD, by = &#39;NEIGHBORHOOD_ID&#39;) %&gt;% select(NEIGHBORHOOD_ID, SALE_DATE,SALE_PRICE,GROSS_SQUARE_FEET,TYPE,SALE_ID,Y) %&gt;% filter(TYPE == &#39;RESIDENTIAL&#39;) %&gt;% group_by(NEIGHBORHOOD_ID) %&gt;% subset(Y&gt;=2009) %&gt;% subset(GROSS_SQUARE_FEET !" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/3915d5c023bdec228a199faf845ad83e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-05-09T05:02:13+08:00" />
<meta property="article:modified_time" content="2022-05-09T05:02:13+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">R语言：商业数据分析实例（2）【k-means, t-test】</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>适用于初学者。内容包括k-mean和t-test的使用。</p> 
<p>使用到的数据：链接：<strong>https://pan.baidu.com/s/1yhzQSdquizLayXamM0wygg</strong> <br> 提取码：<strong>3b7i</strong></p> 
<p></p> 
<h3><strong>前言：k-means实现</strong></h3> 
<p>k-means算法，是一种最广泛使用的聚类算法。k-means以k作为参数，把数据分为k个组，通过迭代计算过程，将各个分组内的所有数据样本的均值作为该类的中心点，使得组内数据具有较高的相似度，而组间的相似度最低。（引用自：张丹(Conan)）</p> 
<p>k-means工作原理：</p> 
<ol><li>初始化数据，选择k个对象作为中心点。</li><li>遍历整个数据集，计算每个点与每个中心点的距离，将它分配给距离中心最近的组。</li><li>重新计算每个组的平均值，作为新的聚类中心。</li><li>上面2-3步，过程不断重复，直到函数收敛，不再新的分组情况出现。</li></ol> 
<h3 style="margin-left:.0001pt;text-align:justify;"></h3> 
<h3 style="margin-left:.0001pt;text-align:justify;">案例简介</h3> 
<p style="margin-left:.0001pt;text-align:justify;">用到的数据共4张表（cvs格式），为2003-2019年美国纽约市房地产交易数据。</p> 
<p style="margin-left:.0001pt;text-align:justify;">        NYC_HISTORICAL包含：交易ID，社区ID，地址，建筑类型，时间，价格，面积等；</p> 
<p style="margin-left:.0001pt;text-align:justify;">        BOROUGH包含：BOROUGH_ID和BOROUG名称；</p> 
<p style="margin-left:.0001pt;text-align:justify;">        BUILDING_CLASS包含：建筑ID和建筑类型等；</p> 
<p style="margin-left:.0001pt;text-align:justify;">        NEIGHBORHOOD 包含：街道ID和BOROUGH_ID等；</p> 
<p style="margin-left:.0001pt;text-align:justify;">本案例需要根据ID整合数据，从中提取目标信息。</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<h3><strong>本章目标</strong></h3> 
<p><strong>任务1：</strong>使用以下KPI执行k-means聚类。描述所选社区所属的聚类。</p> 
<ul><li>自2009年以来，住宅物业的价格中值</li><li>自2009年以来，住宅物业的销售数量</li><li>自2009年以来，住宅物业的价格标准差</li><li>自2009年以来，住宅地产的每平方米价格</li></ul> 
<p><strong>任务2：</strong>选择另一个社区（如 ID：31），并检验以下假设：从2009年开始，社区（ ID：29）的平均住宅物业价格大于所选的另外一个社区</p> 
<p></p> 
<p>开始：载入所需的包，并设置工作地址</p> 
<pre><code class="language-R">library(lubridate)    #year()
library(tidyverse)    #csv2
library(factoextra)
library(cluster)
setwd("C:/Users/10098/Desktop/AD571/571，A34")</code></pre> 
<p>读取所有csv文件。第四个NYC_HISTORICAL较大（150M），且用分号隔开，故用csv2读取</p> 
<pre><code class="language-R">BOROUGH        &lt;- read.csv("BOROUGH.csv", header=TRUE)
BUILDING_CLASS &lt;- read.csv("BUILDING_CLASS.csv", header=TRUE)
NEIGHBORHOOD   &lt;- read.csv("NEIGHBORHOOD.csv", header=TRUE)
NYC_HISTORICAL &lt;- read_csv2("NYC_HISTORICAL.csv")   </code></pre> 
<p>将各表数据整合</p> 
<pre><code class="language-R">NYC_HISTORICAL &lt;- mutate(NYC_HISTORICAL, Y = year(SALE_DATE))
NEIGHBORHOOD = left_join(NEIGHBORHOOD,BOROUGH,  by = 'BOROUGH_ID')  
df &lt;- NYC_HISTORICAL %&gt;%
  left_join(BUILDING_CLASS, by = c('BUILDING_CLASS_FINAL_ROLL'='BUILDING_CODE_ID')) %&gt;%
  left_join(NEIGHBORHOOD, by = 'NEIGHBORHOOD_ID')  %&gt;%
  select(NEIGHBORHOOD_ID, SALE_DATE,SALE_PRICE,GROSS_SQUARE_FEET,TYPE,SALE_ID,Y) %&gt;%
  filter(TYPE == 'RESIDENTIAL')  %&gt;%
  group_by(NEIGHBORHOOD_ID)   %&gt;% 
  subset(Y&gt;=2009)  %&gt;%
  subset(GROSS_SQUARE_FEET != 0) %&gt;% 
  na.omit()</code></pre> 
<p>取出所需KPI ，并重新命名一下列名</p> 
<pre><code class="language-R">median_sale_price  &lt;- summarize(df, median(SALE_PRICE))                        #KPI1
number_of_sales    &lt;- count(df, NEIGHBORHOOD_ID)                               #KPI2
standard_deviation &lt;- summarize(df, sd(SALE_PRICE))                            #KPI3
AVEPRICE_price     &lt;- summarize(df, sum(SALE_PRICE) / sum(GROSS_SQUARE_FEET))  #KPI4

df_2 &lt;- median_sale_price   %&gt;%
  full_join(number_of_sales,    by = 'NEIGHBORHOOD_ID')   %&gt;%
  full_join(standard_deviation, by = 'NEIGHBORHOOD_ID')   %&gt;%
  full_join(AVEPRICE_price,     by = 'NEIGHBORHOOD_ID')   

colnames(df_2) &lt;- c('ID','median', 'amount', 'sd', 'AVEPRICE_price')
</code></pre> 
<p>做kmeans之前先做scale(），它使数据框的列居中和缩放（也就是每个值减去均值除标准差）</p> 
<p><strong>为什么要scale(）？</strong></p> 
<p style="margin-left:0;text-align:justify;">KNN、K-means和SVM 等距离算法受特征范围的影响大。这些算法使用数据点之间的距离来确定相似性。如果不缩放，变量具有不同的尺度，算法可能对具有更高量级的变量赋予更高的权重，进而影响算法的性能</p> 
<pre><code class="language-R">scale_df &lt;- scale(df_2[,-1]) # 此处scale时不用包括第一列‘ID’</code></pre> 
<h3></h3> 
<h3><strong>开始kmeans</strong>，因为会随机取点，可以设置seed保证每次结果不变。</h3> 
<p>设定不同的center数量做了4次（因为我们不知道分成几个聚类好）</p> 
<pre><code class="language-R">set.seed(123)
k2 &lt;- kmeans(scale_df, center = 2, nstart = 25)
k3 &lt;- kmeans(scale_df, center = 3, nstart = 25)
k4 &lt;- kmeans(scale_df, center = 4, nstart = 25)
k5 &lt;- kmeans(scale_df, center = 5, nstart = 25)</code></pre> 
<p>利用fviz_cluster画图看一下（fviz_cluster：基于ggplot2的分区方法的优雅可视化，包括kmeans）</p> 
<pre><code class="language-R">p2 &lt;- fviz_cluster(k2, data = scale_df) + ggtitle("k=2")
p3 &lt;- fviz_cluster(k3, data = scale_df) + ggtitle("k=3")
p4 &lt;- fviz_cluster(k4, data = scale_df) + ggtitle("k=4")
p5 &lt;- fviz_cluster(k5, data = scale_df) + ggtitle("k=5")</code></pre> 
<p>单独运行（如p2）即可出图，这个为了好看，将4张图放在一起查看</p> 
<pre><code class="language-R">library(gridExtra)
grid.arrange(p2, p3, p4, p5, nrow = 2)    #把4张图放在一张画布上便于查看</code></pre> 
<p>效果如下： </p> 
<p class="img-center"><img alt="" height="390" src="https://images2.imgbox.com/6e/6d/goujaT9z_o.png" width="451"></p> 
<p>可以看到，这里133社区单独成了一个聚类（由于随机，每个人的结果可能不同）。</p> 
<p>这是因为k-means使用的是欧根距离，容易受到异常值的影响。可以用进阶的PAM改进。</p> 
<p>（PAM是对k-means的一种改进算法，能降低异常值对于聚类效果的影响）【以后介绍】</p> 
<p></p> 
<h3><strong>如何确定center数量？</strong></h3> 
<p>上面做了4种情况，但如何确定center数量？不幸的是，这个问题没有明确答案。聚类的最佳数量某种程度上是主观的，取决于用于测量相似性的方法和用于划分的参数。（kassambara）</p> 
<p>实际操作中，具体情况还是要根据business goal去设定个数。</p> 
<p> 这里介绍3种方法：</p> 
<p></p> 
<p><strong>1.肘法（Elbow method）</strong></p> 
<p>即使得集群内总变化 [或集群内总平方和 (WSS )] 尽量小。</p> 
<pre><code class="language-R">f1 &lt;- fviz_nbclust(scale_df, kmeans, method = "wss", nstart = 25) </code></pre> 
<p>图如下： </p> 
<p class="img-center"><img alt="" height="363" src="https://images2.imgbox.com/5e/0b/vDiHhC2g_o.png" width="365"></p> 
<p>我们看到随着k的变大， WSS越来越小，经验上说4比较好（因为在4已经明显下降，之后的比较平缓，也就是k增大带来的效果越来越不明显）。这个方法之所以叫肘法也源于此。</p> 
<p></p> 
<p><strong>2.平均轮廓法（Average silhouette method）</strong></p> 
<p>计算平均轮廓宽度。较高的平均轮廓宽度表示良好的聚类。</p> 
<pre><code class="language-R">f2 &lt;- fviz_nbclust(scale_df, kmeans, method = "silhouette", nstart = 25)</code></pre> 
<p class="img-center"><img alt="" height="386" src="https://images2.imgbox.com/03/3b/PPIjLayo_o.png" width="382"></p> 
<p> 显然该方法建议我们使用2</p> 
<p></p> 
<h4 style="margin-left:0px;"><span style="background-color:#ffffff;"><span style="color:#303030;">3.差距统计法（</span></span>Gap statistic method<span style="background-color:#ffffff;"><span style="color:#303030;">）</span></span></h4> 
<p style="margin-left:0;"><span style="background-color:#ffffff;"><span style="color:#0d0016;">由<a href="http://web.stanford.edu/~hastie/Papers/gap.pdf" rel="nofollow" title="R. Tibshirani、G. Walther 和 T. Hastie 发表（斯坦福大学，2001 年">R. Tibshirani、G. Walther 和 T. Hastie 发表（斯坦福大学，2001 年</a>）。该方法可以应用于任何聚类方法。</span></span><span style="color:#0d0016;"><span style="background-color:#ffffff;">其将不同 k 值的集群内变化的总和与其在数据的空参考分布下的预期值进行比较。最佳聚类的估计值将是使间隙统计量最大化的值。</span></span></p> 
<pre><code class="language-R">f3 &lt;- fviz_nbclust(scale_df, kmeans, nstart = 25,  method = "gap_stat", nboot = 50)</code></pre> 
<p class="img-center"><img alt="" height="352" src="https://images2.imgbox.com/3b/d1/X13Bq4Kb_o.png" width="350"></p> 
<p>该方法建议我们使用1。 （部分是因为之前提到的异常值导致的）</p> 
<p>如果是一般情况图如下：</p> 
<p class="img-center"><img alt="" height="243" src="https://images2.imgbox.com/d4/79/IvAimis7_o.png" width="277"></p> 
<p></p> 
<p>注：如果想同时显示上述三张表，可使用 grid.arrange(f1, f2, f3, nrow = 3) </p> 
<p></p> 
<h3><strong>分析</strong></h3> 
<p>按照上述3个方法，选择聚类数（这里选了4）。将聚类属性合并到数据集，计算4个KPI在不用聚类下的均值</p> 
<pre><code class="language-R">df_3  &lt;- mutate(df_2[,-1], cluster=k4$cluster)   #（将所属聚类放入数据）

cluster_mean &lt;- df_3 %&gt;%
                group_by(cluster) %&gt;%
                summarise_all("mean")</code></pre> 
<p class="img-center"><img alt="" height="119" src="https://images2.imgbox.com/9d/11/2AgyYs3M_o.png" width="529"></p> 
<h3></h3> 
<h3>t-test</h3> 
<p>选择另一个社区（如 ID：31），并检验以下假设：从2009年开始，社区（ ID：29）的平均住宅物业价格大于所选的另外一个社区。</p> 
<p>先筛选出两个社区的数据（可以自制函数取代下面冗杂的方法）</p> 
<pre><code class="language-R">df_29 &lt;- NYC_HISTORICAL %&gt;%
  left_join(BUILDING_CLASS, by = c('BUILDING_CLASS_FINAL_ROLL' = 'BUILDING_CODE_ID'))  %&gt;%
  left_join(NEIGHBORHOOD, by = 'NEIGHBORHOOD_ID')  %&gt;%
  select(NEIGHBORHOOD_ID, SALE_DATE,SALE_PRICE,GROSS_SQUARE_FEET,TYPE,SALE_ID,Y) %&gt;%
  filter(NEIGHBORHOOD_ID =='29') %&gt;%
  filter(TYPE == 'RESIDENTIAL')  %&gt;%
  subset(Y&gt;=2009)  %&gt;%
  subset(GROSS_SQUARE_FEET != 0) %&gt;% 
  group_by(Y)   %&gt;%
  na.omit() 

df_31 &lt;- NYC_HISTORICAL %&gt;%
  left_join(BUILDING_CLASS, by = c('BUILDING_CLASS_FINAL_ROLL' = 'BUILDING_CODE_ID'))  %&gt;%
  left_join(NEIGHBORHOOD, by = 'NEIGHBORHOOD_ID')  %&gt;%
  select(NEIGHBORHOOD_ID, SALE_DATE,SALE_PRICE,GROSS_SQUARE_FEET,TYPE,SALE_ID,Y) %&gt;%
  filter(NEIGHBORHOOD_ID =='31') %&gt;%
  filter(TYPE == 'RESIDENTIAL')  %&gt;%
  subset(Y&gt;=2009)  %&gt;%
  subset(GROSS_SQUARE_FEET != 0) %&gt;% 
  group_by(Y)   %&gt;%
  na.omit() </code></pre> 
<p>进行t-test</p> 
<pre><code>X &lt;- df_29$SALE_PRICE   # 29
Y &lt;- df_31$SALE_PRICE   # 31
t.test(X,Y,alternative = "greater", mu = 0, paired = FALSE, conf.level = .95) </code></pre> 
<p class="img-center"><img alt="" height="159" src="https://images2.imgbox.com/12/ce/N2zhhEhW_o.png" width="513"></p> 
<p>p = 0.1105 &gt; 0.05,  否定原假设(X&gt;Y为假)，则X&gt;Y为真，即X&gt;Y。</p> 
<p></p> 
<p>大功告成！</p> 
<p></p> 
<p></p> 
<p>案例源于波士顿大学，感谢教授Tara Kelly</p> 
<p><strong>Reference：</strong><br> http://blog.fens.me/r-cluster-kmeans/<br> http://www.sthda.com/english/articles/29-cluster-validation-essentials/96-determiningthe-optimal-number-of-clusters-3-must-know-methods/</p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/1e587599022bfc12b530328b2325d845/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Argo workflow 入门</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9266ee768ecf4ac76b2cccce35bdf23b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">JAVA中的多线程之定时器&amp;&amp;一些面试题</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>