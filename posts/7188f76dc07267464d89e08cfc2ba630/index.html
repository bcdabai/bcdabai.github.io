<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>[Android 基础] -- 深入理解 Android Build 系统 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="[Android 基础] -- 深入理解 Android Build 系统" />
<meta property="og:description" content="概述：
Android Build 系统是用来编译 Android 系统、Android SDK 以及相关文档的一套框架。在 Android 系统中，Android 的源码中包含了许许多多的模块。不同产商的不同设备对于 Android 系统的定制都是不一样的。如何将这些模块统一管理起来，如何能够在不同的操作系统上进行编译，如何在编译时能够支持面向不同的硬件设备，不同的编译类型，且还要提供面向各个厂商的定制扩展，Android 系统如何解决这些问题呢？这就是我们不得不谈的 Android Build 系统。
Android 源码目录结构：
Linux 系统的make命令 在讲解 Android 编译系统之前，我们首先需要了解 Linux 系统的 make 命令。在 Linux 系统中，我们可以通过 make 命令来编译代码。Make 命令在执行的时候，默认会在当前目录找到一个 Makefile 文件，然后根据 Makefile 文件中的指令来对代码进行编译。如 gcc，Linux 系统中的 shell 命令 cp、rm 等等。
看到这里，有的小伙伴可能会说，在 Linux 系统中， shell 和 make 命令有什么区别呢？
make 命令事实也是通过 shell 命令来完成任务的，但是它的神奇之处是可以帮我们处理好文件之间的依赖关系。例如有一个文件T，它依赖于另外一个文件 D，要求只有当文件 D 的内容发生变化，才重新生成文件T。
Make 命令是怎么知道两个文件之间存在依赖关系，以及当被依赖文件发生变化时如何处理目标文件的呢？答案就是在前面提到的 Makefile 文件。Makefile 文件实际上是一个脚本文件，就像普通的 shell 脚本文件一样，只不过它遵循的是 Makefile 语法。Makefile 文件最基础的功能就是描述文件之间的依赖关系，以及怎么处理这些依赖关系。
Android Build 系统核心 Android Build 系统是 Android 系统的一部分，主要用来编译 Android 系统，Android SDK 以及相关文档。该系统主要由 Make 文件，Shell 脚本以及 Python 脚本组成。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/7188f76dc07267464d89e08cfc2ba630/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-05-17T15:23:51+08:00" />
<meta property="article:modified_time" content="2020-05-17T15:23:51+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">[Android 基础] -- 深入理解 Android Build 系统</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>概述：</p> 
<p style="text-indent:33px;">Android Build 系统是用来编译 Android 系统、Android SDK 以及相关文档的一套框架。在 Android 系统中，Android 的源码中包含了许许多多的模块。不同产商的不同设备对于 Android 系统的定制都是不一样的。如何将这些模块统一管理起来，如何能够在不同的操作系统上进行编译，如何在编译时能够支持面向不同的硬件设备，不同的编译类型，且还要提供面向各个厂商的定制扩展，Android 系统如何解决这些问题呢？这就是我们不得不谈的 Android Build 系统。</p> 
<p style="text-indent:33px;">Android 源码目录结构：</p> 
<h3><img alt="" height="605" src="https://images2.imgbox.com/bb/af/ftE8qgba_o.png" width="274"></h3> 
<h3><br> Linux 系统的make命令</h3> 
<p style="text-indent:33px;">在讲解 Android 编译系统之前，我们首先需要了解 Linux 系统的 make 命令。在 Linux 系统中，我们可以通过 make 命令来编译代码。Make 命令在执行的时候，默认会在当前目录找到一个 Makefile 文件，然后根据 Makefile 文件中的指令来对代码进行编译。如 gcc，Linux 系统中的 shell 命令 cp、rm 等等。</p> 
<p style="text-indent:33px;">看到这里，有的小伙伴可能会说，在 Linux 系统中， shell 和 make 命令有什么区别呢？</p> 
<p style="text-indent:33px;">make 命令事实也是通过 shell 命令来完成任务的，但是它的神奇之处是可以帮我们处理好文件之间的依赖关系。例如有一个文件T，它依赖于另外一个文件 D，要求只有当文件 D 的内容发生变化，才重新生成文件T。</p> 
<p style="text-indent:33px;">Make 命令是怎么知道两个文件之间存在依赖关系，以及当被依赖文件发生变化时如何处理目标文件的呢？答案就是在前面提到的 Makefile 文件。Makefile 文件实际上是一个脚本文件，就像普通的 shell 脚本文件一样，只不过它遵循的是 Makefile 语法。Makefile 文件最基础的功能就是描述文件之间的依赖关系，以及怎么处理这些依赖关系。</p> 
<h3>Android Build 系统核心</h3> 
<p style="text-indent:33px;">Android Build 系统是 Android 系统的一部分，主要用来编译 Android 系统，Android SDK 以及相关文档。该系统主要由 Make 文件，Shell 脚本以及 Python 脚本组成。</p> 
<p>Android build 分类：</p> 
<ul><li> build/core 目录下的文件，这是 Android Build 的系统框架核心；</li><li>device 目录下的文件，存放的是具体的产品配置文件；</li><li>各个模块的编译文件：Android.mk，位于模块的源文件目录下。</li></ul> 
<h3>Android Build 系统核心</h3> 
<p style="text-indent:33px;">Android Build 系统核心在目录 build/core，这个目录中有 mk 文件、shell 脚本和 per 脚本，它们构成 Android Build 系统的基础和架构。</p> 
<p style="text-indent:33px;">在核心的 build/core 里，系统主要干了三件事情：</p> 
<p style="text-indent:33px;"><img alt="" height="167" src="https://images2.imgbox.com/4a/82/wEilNlEt_o.png" width="620"></p> 
<p>常用命令：</p> 
<blockquote> 
 <p>source build / envsetup.sh</p> 
 <p>lunch</p> 
 <p>make</p> 
</blockquote> 
<h4>envsetup.sh</h4> 
<p><img alt="" height="254" src="https://images2.imgbox.com/c3/c5/KdoLyV9d_o.png" width="616"></p> 
<p style="text-indent:33px;">执行 Android 系统的编译，必须先执行 envsetup.sh 脚本，这个脚本会建立 Android 的编译环境。其具体执行的是建立 shell 命令以及调用 add_lunch_combo 命令，这个命令将调用该命令的所传递的参数存放到一个全局的数组变量 LUNCH_MENU_CHOICES 中。</p> 
<p style="text-indent:33px;">envsetup.sh 脚本中定义的常用 shell 命令：</p> 
<table border="1" cellpadding="1" cellspacing="1"><tbody><tr><td style="width:177px;">命令</td><td>说明</td></tr><tr><td style="width:177px;">contact-button</td><td>指定当前编译的产品</td></tr><tr><td style="width:177px;">croot</td><td>快速切换到源码的根目录，方便开始编译</td></tr><tr><td style="width:177px;">m</td><td>编译整个源码，但不用将当前的目录切换到源码的根目录</td></tr><tr><td style="width:177px;">mm</td><td>编译当前目录下的所有模块，但是不编译他们的依赖项</td></tr><tr><td style="width:177px;">mmm</td><td>编译指定目录下的所有模块，但是不编译他们的依赖项</td></tr><tr><td style="width:177px;">cgrep</td><td>对系统中所有的 C/C++ 文件执行 grep 命令</td></tr><tr><td style="width:177px;">sgrep</td><td>对系统中所有的源文件执行 grep 命令</td></tr></tbody></table> 
<p> </p> 
<h3>编译 Android 系统</h3> 
<p style="text-indent:33px;">Android 系统的编译环境目前只支持 Ubuntu 以及 Mac OS 两种操作系统。在编译 Android 系统之前我们需要先获取完整的 Android 源码。打开控制台之后转到 Android 源码的根目录，然后执行如下命令：</p> 
<blockquote> 
 <p style="text-indent:33px;">source build/envsetup.sh</p> 
 <p style="text-indent:33px;">lunch full-eng</p> 
 <p style="text-indent:33px;">make -j8</p> 
</blockquote> 
<p style="text-indent:33px;">关于这几条命令的意思，我们上面提过。</p> 
<p style="text-indent:33px;">第一步命令 “source build/envsetup.sh” 引入了 build/envsetup.sh 脚本，该脚本的作用是初始化编译环境，并引入一些辅助的 Shell 函数；</p> 
<p style="text-indent:33px;">第二步命令 “lunch full-eng” 是调用 lunch 函数，并指定参数为 “full-eng”。lunch 函数的参数用来指定此次编译的目标设备以及编译类型。</p> 
<p style="text-indent:33px;">第三步命令 “make -j8” 才真正开始执行编译。make 的参数 “-j” 制定了同时编译的 Job 数量，这是个整数，该值通常是编译主机 CPU 支持的并发线程总数的 1 倍或 2 倍。完整的编译时间依赖于编译主机的配置。</p> 
<p style="text-indent:33px;"> </p> 
<h3>Build 结果</h3> 
<p style="text-indent:33px;">Build 的产物中最重要的是三个镜像文件，它们都位于 /out/target/product// 目录下：</p> 
<ul><li>system.img：包含了 Android OS 的系统文件，库，可执行文件以及预置的应用程序，将被挂载为根分区。</li><li>ramdisk.img：在启动时将被 Linux 内核挂载为只读分区，它包含了 /init 文件和一些配置文件。它用来挂载其他系统镜像并启动 init 进程。</li><li>userdata.img：将被挂载为 /data，包含了应用程序相关的数据以及和用户相关的数据。</li></ul> 
<h3>Make 文件</h3> 
<p style="text-indent:33px;">整个 Build 系统的入口文件是源码树根目录下名称为 “Makefile” 的文件，当在源代码根目录上调用 make 命令时，make 命令首先将读取该文件。</p> 
<p style="text-indent:33px;">Makefile 文件的内容只有一行：“include build/core/main.mk”。该行代码的作用很明显：包含 build/core/main.mk 文件。在 main.mk 文件中又会包含其他的文件，其他文件中又会包含更多的文件，这样就引入了整个 Build 系统。</p> 
<p style="text-indent:33px;">在整个 Build 系统中，Make 文件间的关系是相当复杂的。看一张 make 文件主要的关系图：</p> 
<p style="text-indent:33px;"><img alt="" height="396" src="https://images2.imgbox.com/c8/21/CdRFGYvw_o.png" width="572"></p> 
<p> </p> 
<p style="text-indent:33px;">Make 常用文件：</p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:638px;"><tbody><tr><td style="width:172px;">文件名</td><td>说明</td></tr><tr><td style="width:172px;">main.mk</td><td> <p>主要的 make 文件，该文件中首先对编译环境进行检查，同时引入其他的 Make 文件。另外，该文件中还定义了几个最主要的 Make 目标，例如 droid ，sdk， 等（参见后文 “Make 目标说明” ）。</p> </td></tr><tr><td style="width:172px;">help.mk</td><td> <p>包含了名称为 help 的 Make 目标的定义，该目标将列出主要的 Make 目标及其说明。</p> </td></tr><tr><td style="width:172px;">envsetup.mk</td><td>配置 Build 系统需要的环境变量，例如：TARGET_PRODUCT，TARGET_BUILD_VARIANT，HOST_OS，HOST_ARCH 等。当前编译的主机平台信息（例如操作系统，CPU 类型等信息）就是在这个文件中确定的。另外，该文件中还指定了各种编译结果的输出路径。</td></tr><tr><td style="width:172px;">pathmap.mk</td><td>将许多头文件的路径通过名值的方式定义为映射表，并提供 include-path-for 函数来获取</td></tr><tr><td style="width:172px;">combo/select.mk</td><td> <p>根据当前编译器的平台选择平台相关的 Make 文件。</p> </td></tr><tr><td style="width:172px;">dumpvar.mk</td><td> <p>在 Build 开始之前，显示此次 Build 的配置信息。</p> </td></tr><tr><td style="width:172px;">config.mk</td><td>整个 Build 系统的配置文件，最重要的 Make 文件之一。该文件中主要包含以下内容：定义了许多的常量来负责不同类型模块的编译。定义编译器参数以及常见文件后缀，例如 .zip，.jar，.apk。根据 BoardConfig.mk 文件，配置产品相关的参数。设置一些常用工具的路径，例如 flex，e2fsck，dx。</td></tr><tr><td style="width:172px;">definitions.mk</td><td>最重要的 Make 文件之一，在其中定义了大量的函数。这些函数都是 Build 系统的其他文件将用到的。例如：my-dri，all-subdir-makefiles，find-subdir-files，sign-package 等，关于这些函数的说明请参见每个函数的代码注释。</td></tr><tr><td style="width:172px;">distdir.mk</td><td>针对 dist 目标的定义。dist 目标用来拷贝文件到指定路径。</td></tr><tr><td style="width:172px;">dex_preopt.mk</td><td> <p>针对启动 jar 包的预先优化。</p> </td></tr><tr><td style="width:172px;">pdk_config.mk</td><td>顾名思义，针对 pdk（Platform Developement Kit）的配置文件。</td></tr><tr><td style="width:172px;">post_clean.mk</td><td>在前一次 Build 的基础上检查当前 Build 的配置，并执行必要清理工作。</td></tr><tr><td style="width:172px;">legacy_prebuilts.mk</td><td>该文件中只定义了 GRANDFATHERED_ALL_PREBUILT 变量。</td></tr><tr><td style="width:172px;">Makefile</td><td>被 main.mk 包含，该文件中的内容是辅助 main.mk 的一些额外内容。</td></tr></tbody></table> 
<p style="text-indent:33px;">Android 源码中包含了许多的模块，模块的类型有很多种，例如：Java库，C/C++ 库，APK 应用，已经可执行文件等。并且，Java 或者 C/C++ 库可以分为静态的或者动态的，库或可执行文件即可能是针对设备（本文的“设备”指的是 Android 系统将被安装的设备，例如某个信号的手机或平板）的也可能是针对主机（本文的“主机”指的是开发 Android 系统机器，例如装有 Ubuntu 操作系统的 PC 机或装有 MacOS 的 iMac 或 Macbook）的。不同类型的模块的编译步骤和方法是不一样，为了能够一致且方便的执行各种类型模块的编译，在 config.mk 中定义了许多的常量，这其中的每个常量描述了一种类型模块的编译方式。常见的有：</p> 
<ul><li>BUILD_HOST_STATIC_LIBRARY</li><li>BUILD_HOST_SHARED_LIBRARY</li><li>BUILD_STATIC_LIBRARY</li><li>BUILD_SHARED_LIBRARY</li><li>BUILD_EXECUTABLE</li><li>BUILD_BUILD_HOST_EXECUTABLE</li><li>BUILD_PACKAGE</li><li>BUILD_PREBUILT</li><li>BUILD_MULTI_PREBUILT</li><li>BUILD_HOST_PREBUILT</li><li>BUILD_JAVA_LIBRARY</li><li>BUILD_STATIC_JAVA_LIBRARY</li><li>BUILD_HOST_JAVA_LIBRARY</li></ul> 
<p style="text-indent:33px;">不同类型的模块的编译过程会有一些相同的步骤，例如：编译一个 Java 库和编译一个 APK 文件都需要定义如何编译 Java 文件。为了减少代码冗余，需要将共同的代码复用起来，复用的方式是将共同代码放到专门的文件中，然后在其他文件中包含这些文件的方式来实现的。模块的编译方式定义文件包含关系：</p> 
<p style="text-indent:33px;"><img alt="" height="477" src="https://images2.imgbox.com/ac/00/afuzzgLQ_o.png" width="572"></p> 
<h4>Make 编译镜像</h4> 
<p style="text-indent:33px;"><strong>make/make droid </strong></p> 
<p style="text-indent:33px;">如果在源码树的根目录直接调用 “make” 命令而不指定任何目标，则会选择默认目标：“driod”（在 main.mk 中定义）。因此，这和执行 “make droid” 效果是一样的。droid 目标将编译出整个系统的镜像。从源代码到编译出系统镜像，整个编译过程非常复杂。这个过程并不是在 droid 一个目标中定义的，而是 droid 目标会依赖许多其他的目标，这些目标的互相配合导致了整个系统的编译。那么需要编译出系统镜像，需要哪些依赖呢？</p> 
<p><img alt="" height="392" src="https://images2.imgbox.com/cb/ce/D2AvqdiW_o.png" width="572"></p> 
<p style="text-indent:33px;">droid 所依赖的其他 Make 目标说明：</p> 
<table border="1" cellpadding="1" cellspacing="1"><tbody><tr><td style="width:200px;">名称</td><td>说明</td></tr><tr><td style="width:200px;">apps_only</td><td>该目标将编译出当前配置下不包含 user，userdebug，eng 标签（关于标签，请参见后文 “添加新的模块”）的应用程序。</td></tr><tr><td style="width:200px;">droidcore</td><td>该目标仅仅是所依赖的几个目标的组合，其本身不做更多的处理。</td></tr><tr><td style="width:200px;">dist_files</td><td>该目标用来拷贝文件到 /out/dist 目录。</td></tr><tr><td style="width:200px;">files</td><td>该目标仅仅是所依赖的几个目标的组合，其本身不做跟多的处理。</td></tr><tr><td style="width:200px;">prebuilt</td><td>该目标依赖于（ALL_PREBUILT），（ALL_PREBUILT）的作用就是处理所有已编译好的文件。</td></tr><tr><td style="width:200px;">$(modules_to_install)</td><td>modules_to_install 变量包好了当前配置下所有会被安装的模块（一个模块是否会被安装依赖于该产品的配置文件，模块的标签等信息），因此该目标将导致所有会被安装的模块的编译。</td></tr><tr><td style="width:200px;">$(modules_to_check)</td><td> <p>该目标用来确保我们定义的构建模块是没用冗余的。</p> </td></tr><tr><td style="width:200px;">$(INSTALLED_ANDROID_INFO_TXT_TARGET)</td><td>该目标会生成一个关于当前 Build 配置的设备信息的文件，该文件的生成路径是：out/target/product/android-info.txt。</td></tr><tr><td style="width:200px;">systemimage</td><td>生成 system.img。</td></tr></tbody></table> 
<p style="text-indent:33px;">Build 系统中抱哈的其他的一些 Make 目标：</p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:575px;"><tbody><tr><td style="width:204px;">Make 目标说明</td><td>说明</td></tr><tr><td style="width:204px;">make clean</td><td>执行清理，等同于：rm -rf out/</td></tr><tr><td style="width:204px;">make sdk</td><td>编译出 Android 的 SDK</td></tr><tr><td style="width:204px;">Make 目标说明</td><td>说明</td></tr><tr><td style="width:204px;">make clean-sdk</td><td>清理 SDK 的编译产物</td></tr><tr><td style="width:204px;">make update-api</td><td>更新 API。在 framework API 改动之后，需要首先执行该命令来更新 API，公开的 API 记录在 framworks/base/api 目录下。</td></tr><tr><td style="width:204px;">make dist</td><td>执行 Build，并将 MAKECMDGOALS 变量定义的输出文件拷贝到 /out/dist 目录。</td></tr><tr><td style="width:204px;">make all</td><td>编译所有内容，不管当前产品的定义宏是否会包含。</td></tr><tr><td style="width:204px;">make help</td><td>帮助信息</td></tr><tr><td style="width:204px;">make snod</td><td>从已经编译出的包快速重建系统镜像</td></tr><tr><td style="width:204px;">make libandroid_runtime</td><td>编译所有 JNI framework 内容</td></tr><tr><td style="width:204px;">make  framework</td><td>编译所有 Java  framework 内容</td></tr><tr><td style="width:204px;">make services</td><td>编译系统服务和相关内容</td></tr><tr><td style="width:204px;">make</td><td>编译一个指定的模块，local_target 为模块的名称</td></tr><tr><td style="width:204px;">make clean-</td><td>清理一个指定模块的编译结果</td></tr><tr><td style="width:204px;">make dump-products</td><td>显示所有产品的编译配置信息，例如：产品名，产品支持的地区语言，产品中会包含的模块等信息</td></tr><tr><td style="width:204px;">make PRODUCT-xxx-yyy</td><td>编译某个指定的产品</td></tr><tr><td style="width:204px;">make bootimage</td><td>生成 boot.img</td></tr></tbody></table> 
<h4>定制 Build 系统中内容</h4> 
<p style="text-indent:33px;">当我们要开发一款新的 Andorid 产品的时候，我们首先就需要在 Build 系统中添加对于该产品的定义。在 Android Build 系统中对产品定义的文件通常位于 device 目录下，device 目录下可以公司名以及产品名分为二级目录，然后加入到系统中，如以前小米等基于 Android 深度定制的系统。通常，对于一个产品的定义通常至少会包括四个文件：</p> 
<ul><li>AndroidProducts.mk；</li><li>产品版本定义文件；</li><li>BoardConfig.mk；</li><li>verndorsetup.sh；</li></ul> 
<h4>AndroidProducts.mk：</h4> 
<p style="text-indent:33px;">该文件只需要定义一个变量，名称为 "PRODUCT_MAKEFILES"。</p> 
<pre><code>PRODUCT_MAKEFILES := \
    $(LOCAL_DIR)/full_string.mk \
    $(LOCAL_DIR)/stringray_emu.mk \
    $(LOCAL_DIR)/generic_stringray.mk
</code></pre> 
<h4>产品版本定义文件：</h4> 
<p style="text-indent:33px;">该文件中包含了对于特定产品版本的定义。该文件可能不止一个，因为同一个产品可能会有多种版本。通常情况下我们并不需要定义所有这些变量。Build 系统的已经预先定义好了一些组合，它们都位于 /build/target/product 下，每个文件定义了一个组合，我们只要集成这些预置的定义，然后再覆盖自己想要的变量定义即可。</p> 
<pre><code># 继承 full_base.mk 文件中的定义
$(call inherit-product, $(SRC_TARGET_DIR)/product/full_base.mk)
#覆盖其中已经定义的一些变量
PRODUCT_NAME := full_lt26
PRODUCT_DEIVCE := lt26
PRODUCT_BRAND := Android
PRODUCT_MODEL := Full Android on LT26</code></pre> 
<h4>BoardConfig.mk：</h4> 
<p style="text-indent:33px;">该文件用来配置硬件主板，它其中定义的都是设备底层的硬件特性。例如：该设备的主板相关信息，WiFi 相关信息，还有 BootLoader，内核，radioimage 等信息。</p> 
<h4>vendorsetup.sh：</h4> 
<p style="text-indent:33px;">该文件中作用是通过 add_lunch_combo 函数在 lunch 函数中添加一个菜单选项。该函数的参数是产品名称加上编译类型，中间以 "-" 连接，例如：</p> 
<blockquote> 
 <p style="text-indent:33px;">add_lunch_combo full_lt26-userdebug</p> 
</blockquote> 
<p style="text-indent:33px;">/build/envsetup.sh 会扫描所有 device 和 vendor 二级目录下的名称为 "vendorsetup.sh" 文件，并根据其中的内容来确定 lunch 函数的菜单选项。在配置了以上的文件之后，便可以编译出我们新添加的设备的系统镜像了。我们可以使用命令：</p> 
<blockquote> 
 <p style="text-indent:33px;">source build/envsetup.sh</p> 
</blockquote> 
<p style="text-indent:33px;">来查看 Build 系统已经引入了刚刚添加的 vendorsetup.sh 文件。</p> 
<h4>添加新模块在源码树中</h4> 
<p style="text-indent:33px;">一个模块的所有文件通常都位于同一个文件夹中。为了将当前模块添加到整个 Build 系统中，每个模块都需要一个专门的 Make 文件，该文件的名称为 "Android.mk"。Build 系统会扫描名称为 "Android.mk" 的文件，并根据该文件中内容编译出相应的产物。</p> 
<blockquote> 
 <p style="text-indent:33px;">注：在 Android Build 系统中，编译是以模块（而不是文件）作为单位的，每个模块都有一个唯一的名称，一个模块的依赖对象只能是另外一个模块，而不能是其他类型的对象。</p> 
</blockquote> 
<p style="text-indent:33px;">对于已经编译好的库使用 BUILD_PREBUILT 或 BUILD_MULTI_PREBUILT。例如：当编译某个 Java 库需要依赖一些 Jar 包时，并不能直接指定 Jar 包的路径作为依赖，而必须先将这些 Jar 包定义为一个模块，然后在编译 Java 库的时候通过模块的名称来依赖这些 Jar 包。那么怎么编写 Android.mk 文件呢？Android.mk 文件通常以以下两行代码作为开头：</p> 
<pre><code>LOCAL_PATH := $(call my-dir) //设置单枪模块的编译路径为当前文件夹路径
    include $(CLEAR_VARS) //清理编译环境中用到的变量</code></pre> 
<p style="text-indent:33px;">为了方便模块的编译，Build 系统设置了很多的编译环境变量。要编译一个模块，只要在编译之前根据需要设置这些变量然后执行编译即可。常见的如：</p> 
<blockquote> 
 <ul><li>LOCAL_SRC_FILES：当前模块包含的所有源代码文件。</li><li>LOCAL_MODULE：当前模块的名称，这个名称应当是唯一的，模块间的依赖关系就是通过这个名称来引用的。</li><li>LOCAL_C_INCLUDES：C 或 C++ 语言需要的头文件的路径。</li><li>LOCAL_STATIC_LIBRARIES：当前模块在静态链接时需要的库的名称。</li><li>LOCAL_SHARED_LIBRARIES：当前模块在运行时依赖的动态库的名称。</li><li>LOCAL_CFLAGS：提供给 C/C++ 编译器的额外的编译参数。</li><li>LOCAL_JAVA_LIBRARIES：当前模块依赖的 Java 共享库。</li><li>LOCAL_STATIC_JAVA_LIBRARIES：当前模块依赖的 Java 静态库。</li><li>LOCAL_PACKAGE_NAME：当前 APK 应用的名称。</li><li>LOCAL_CERTIFICATE：签署当前应用的证书名称。</li><li>LOCAL_MODULE_TAGS：当前模块所包含的标签，一个模块可以包含多个标签。</li></ul> 
</blockquote> 
<p style="text-indent:33px;">标签的值可能是 debug，eng，user，development 或者 optional。其中，optional 是默认标签。<strong>标签是提供给编译类型使用的，不同的编译类型会安装包含不同标签的模块</strong>。编译类型说明：</p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:695px;"><tbody><tr><td style="width:172px;">名称</td><td>说明</td></tr><tr><td style="width:172px;">eng</td><td>默认类型，该编译类型适用于开发阶段。当选择这种类型时，编译结果将：安装包含 eng，debug，user，development 标签的模块；安装所有没有标签的非 APK 模块；安装所有产品定义文件中指定的 APK 模块。</td></tr><tr><td style="width:172px;">user</td><td> <p>该编译类型适合用于最终发布阶段。当选择这种类型时，编译结果将：安装所有带有 user 标签的模块；安装所有没有标签的非 APK 模块；安装所有产品定义文件中指定的 APK 模块，APK 模块的标签将被忽略。</p> </td></tr><tr><td style="width:172px;">userdebug</td><td>该编译类型适合用于 debug 阶段。该类型和 user 一样，除了：会安装包含 debug 标签的模块，编译出的系统具有 root 访问权限。</td></tr></tbody></table> 
<p style="text-indent:33px;">根据上表各种类型模块的编译方式，要执行编译，只需要引入表3 中对应的 Make 文件即可。例如，要编译一个 APK 文件，只需要在 Android.mk 文件中，加入 “include $(BUILD_PACKAGE)”。除此以外，Build 系统中还定义了一些便捷的函数以便在 Android.mk 中使用，包括：</p> 
<ul><li>$(call my-dir)：获取当前文件夹路径。</li><li>$(call all-java-files-under)：获取指定目录下的所有 Java 语言文件。</li><li>$(call all-c-files-under)：获取指定目录下的所有 C 语言文件。</li><li>$(call all-laidl-files-under)：获取指定目录下的所有 AIDL 文件。</li><li>$(call all-makefile-under)：获取指定目录下的所有 Make 文件。</li></ul> 
<pre><code>LOCAL_PATH := $(call my-dir)
include $(CLEAR_VARS)
#获取所有子目录中的 Java 文件
LOCAL_SRC_FILES := $(call all-subdir-java-files)
#当前模块依赖的静态 Java 库，如果有多个以空格分隔
LOCAL_STATIC_JAVA_LIBRARIES := static-library
#当前模块的名称
LOCAL_PACKAGE_NAME := LocalPackage
#编译 APK 文件
include $(BUILD_PACKAGE)</code></pre> 
<p style="text-indent:33px;">编译一个 Java 的静态库：</p> 
<pre><code>LOCAL_PATH := $(call my-dir)
include $(CLEAR_VARS)

#获取所有子目录中的 Java 文件
LOCAL_SRC_FILES := $(call all-subdir-java-files)

#当前模块依赖的动态 Java 库名称
LOCAL_JAVA_LIBRARIES := android.test.runner

#当前模块的名称
LOCAL_MODULE := sample

#将当前模块编译成一个静态的 Java 库
include $(BUILD_STATIC_JAVA_LIBRARY)</code></pre> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/03b00acf9dc8f28eb909a396ec532a89/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">区间DP-----------------凸多边形的划分</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e36964858370bf66b2d92f336ac496a2/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Spring源码分析五 ：bean的获取③ - getSingleton</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>