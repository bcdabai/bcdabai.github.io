<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>连续子数组的最大和 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="连续子数组的最大和" />
<meta property="og:description" content="一、需求 输入一个整型数组，数组中的一个或连续多个整数组成一个子数组； 求所有子数组的和的最大值，且时间复杂度为O(n)。
示例1: 输入: nums = [-2,1,-3,4,-1,2,1,-5,4] 输出: 6 解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。 二、暴力法 2.1 思路分析
当然了，暴力法不符合题意，但是也是最先想到的，既然想到了，那就把它实现出来吧；具体注释写在代码上； 2.2 代码实现
class Solution { public int maxSubArray(int[] nums) { int res = Integer.MIN_VALUE; for(int i = 0; i &lt; nums.length; i&#43;&#43;) { //这里直接将非正数略过 if(nums[i] &lt;= 0) continue; int temp = 0; for(int j = i; j &lt; nums.length; j&#43;&#43;) { temp &#43;= nums[j]; if(res &lt; temp) res = temp; } } //sort默认升序排序，当数组中元素值全为零或负数时，需返回最大值 Arrays." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/568a8a40f6a274d48954f2e001b6af8e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-10-29T20:06:43+08:00" />
<meta property="article:modified_time" content="2020-10-29T20:06:43+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">连续子数组的最大和</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h4>一、需求</h4> 
<ul><li>输入一个整型数组，数组中的一个或连续多个整数组成一个子数组；</li><li> <p>求所有子数组的和的最大值，且时间复杂度为O(n)。</p> </li></ul> 
<pre><code>示例1:

输入: nums = [-2,1,-3,4,-1,2,1,-5,4]
输出: 6
解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</code></pre> 
<h4>二、暴力法</h4> 
<p><strong>2.1  思路分析</strong></p> 
<ol><li>当然了，暴力法不符合题意，但是也是最先想到的，既然想到了，那就把它实现出来吧；</li><li>具体注释写在代码上；</li></ol> 
<p><strong>2.2  代码实现</strong></p> 
<pre><code class="language-java">class Solution {
    public int maxSubArray(int[] nums) {
        int res = Integer.MIN_VALUE;
        for(int i = 0; i &lt; nums.length; i++) {
            //这里直接将非正数略过
            if(nums[i] &lt;= 0) continue;
            int temp = 0;
            for(int j = i; j &lt; nums.length; j++) {
                temp += nums[j];
                if(res &lt; temp) res = temp;
            }
        }
        //sort默认升序排序，当数组中元素值全为零或负数时，需返回最大值
        Arrays.sort(nums);
        return Math.max(nums[nums.length-1],res);
    }
}</code></pre> 
<p><strong>2.3  复杂度分析</strong></p> 
<ul><li>时间复杂度为O(N^2)，其中N为数组元素的个数；</li><li>空间复杂度为O(1)；</li></ul> 
<h4>三、动态规划法1</h4> 
<p><strong>3,1  思路分析</strong></p> 
<ol><li>题目求的是连续子数组的最大和，看到涉及最大/最小值，尝试利用动态规划来解决；</li><li>既然是动态规划，那么就要定义状态，找状态方程以及给定状态初值；</li><li><strong>定义状态：</strong>dp[i]表示以nums[i]为结尾的连续子数组的最大和；</li><li><strong>状态方程：</strong>①dp[i-1] &lt;= 0时，dp[i] = nums[i]，即起负(或无)作用就略过；②dp[i] &gt; 0时，dp[i] = dp[i-1] + nums[i]；</li><li><strong>状态初值：</strong>dp[0] = nums[0]，即以nums[0]为结尾的连续子数组的最大和；</li><li><strong>返回值：</strong>返回dp数组中的最大值即可；</li></ol> 
<p><strong>3.2  代码实现</strong></p> 
<pre><code class="language-java">class Solution {
    public int maxSubArray(int[] nums) {
        int i;
        int[] dp = new int[nums.length];
        dp[0] = nums[0];
        for(i = 1; i &lt; nums.length; i++) {
            if(dp[i-1] &lt;= 0) {
                dp[i] = nums[i];
            } else {
                dp[i] = dp[i-1] + nums[i];
            }
        }
        Arrays.sort(dp);
        return dp[dp.length-1];
    }
}</code></pre> 
<p><strong>3.3  复杂度分析</strong></p> 
<ul><li>时间复杂度为O(NlogN)，其中N为数组元素的个数；</li><li>空间复杂度为O(N)；</li></ul> 
<h4>四、动态规划法2</h4> 
<p><strong>4.1  思路分析</strong></p> 
<ol><li>上面的时间复杂度为O(NlogN)，不符合题目要求的O(N)，因此需要进一步优化；</li><li>因为dp[i]只与dp[i-1]与nums[i]相关，因此考虑用数组nums作为dp列表，这样避免了申请空间；</li><li>上面的算法是求出了dp[0]~dp[nums.length-1]很多个值，这一次我们每求出一个就比较一次，最后只剩下一个最值；</li></ol> 
<p><strong>4.2  代码实现</strong></p> 
<pre><code class="language-java">class Solution {
    public int maxSubArray(int[] nums) {
        //假定当前最大值的nums[0]
        int res = nums[0];
        for(int i = 1; i &lt; nums.length; i++) {
            //nums[i]&gt;0则加，否则nums[i]保持不变
            nums[i] += Math.max(nums[i-1],0);
            //每求一次nums[i]，更新一次最值
            res = Math.max(res,nums[i]);
        }
        return res;
    }
}</code></pre> 
<p><strong>4.3  复杂度分析</strong></p> 
<ul><li>时间复杂度为O(N)，N为数组元素的个数；</li><li>空间复杂度为O(1)，使用常数大小的额外空间；</li></ul> 
<h4>五、动态规划法3</h4> 
<p><strong>5.1  思路分析</strong></p> 
<ol><li>上面的代码已符合题目要求了，但是还可以继续优化，因为上面修改了原数组；</li><li>根据上面的思想，我们定义两个变量，一个pre用来表示dp[i-1]，一个cur用来代替被修改的数组元素；</li></ol> 
<p><strong>5.2  代码实现</strong></p> 
<pre><code class="language-java">class Solution {
    public int maxSubArray(int[] nums) {
        int res = nums[0];
        int pre = nums[0];
        int cur = 0;
        for(int i = 1; i &lt; nums.length; i++) {
            //更新cur，相当于更新dp[i]
            cur = nums[i] + Math.max(pre,0);
            //更新最大值
            res = Math.max(res,cur);
            //更新dp[i-1]，使用pre来记录
            pre = cur; 
        }
        return res;
    }
}</code></pre> 
<p><strong>5.3  复杂度分析</strong></p> 
<ul><li>时间复杂度为O(N)，N为数组中的元素个数；</li><li>空间复杂度为O(1)，使用常数大小的额外空间；</li></ul> 
<h4>六、学习地址</h4> 
<p>作者：jyd</p> 
<p>链接：<a href="https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/solution/mian-shi-ti-42-lian-xu-zi-shu-zu-de-zui-da-he-do-2/" rel="nofollow">https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/solution/mian-shi-ti-42-lian-xu-zi-shu-zu-de-zui-da-he-do-2/</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/94154af350c0c7b38452052c0fb9e02e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">elementUI自定义主题配色</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ffeea17d090975cd75de9bd18896fa81/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">python在线编辑random-使用Python脚本生成随机IP的简单方法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>