<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>stm32 BootLoader之检查栈顶地址是否合法 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="stm32 BootLoader之检查栈顶地址是否合法" />
<meta property="og:description" content="在stm32 IAP例程中，跳转到APP区的时候，都会检查栈顶地址是否合法，以及reset地址是否正确等信息，那么这些判断具体依据什么原理？？？
以stm32H743为例说明↓↓↓↓
检查栈顶是否合法代码如下： #define STM32_APP_BASE	0x08020000	// APP flash start address void iap_jumpapp(void) { // 检查栈顶是否合法，，确保栈顶落在0x24000000-0x24FFFFFF 之间，刚好在stm32h7的RAM范围内 if (((*(uint32_t*)(STM32_APP_BASE)) &amp; 0xff000000 ) == 0x24000000 ) { // 检查reset入口是否正确 if (((*(uint32_t*)(STM32_APP_BASE &#43; 4)) &amp; 0x0fff0000 ) == 0x08020000 ) { JumpToApp = (pfunction)((*(uint32_t*)(STM32_APP_BASE &#43; 4))); MSR_MSP(*(uint32_t*)STM32_APP_BASE); JumpToApp(); } } else { ... } } 栈顶地址 和 reset入口地址具体是什么？？？ 从startup_stm32h743xx.s中可以看出，程序第一个地址存放的是__initial_sp，紧接着第二个地址存放的是Reset_Handler；这两个正是所谓的栈顶地址 reset 入口
__Vectors DCD __initial_sp ; Top of Stack DCD Reset_Handler ; Reset Handler DCD NMI_Handler ; NMI Handler DCD HardFault_Handler ; Hard Fault Handler DCD MemManage_Handler ; MPU Fault Handler DCD BusFault_Handler ; Bus Fault Handler DCD UsageFault_Handler ; Usage Fault Handler DCD 0 ; Reserved DCD 0 ; Reserved DCD 0 ; Reserved 代码说明备注__initial_sp栈顶地址程序占用的最大RAM地址，占用RAM大小=RW-data &#43; ZI-dataReset_Handlerreset入口程序上电后，第一个运行的函数地址 结合map文件和bin文件进行分析 生成map文件中，__initial_sp = 0x2400f2a8 ." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/6aeadf4fa40fd233a2cb858bc9439935/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-07-15T09:04:33+08:00" />
<meta property="article:modified_time" content="2021-07-15T09:04:33+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">stm32 BootLoader之检查栈顶地址是否合法</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <blockquote> 
 <p>在stm32 IAP例程中，跳转到APP区的时候，都会检查栈顶地址是否合法，以及reset地址是否正确等信息，那么这些判断具体依据什么原理？？？<br> 以stm32H743为例说明↓↓↓↓</p> 
</blockquote> 
<h5><a id="_3"></a>检查栈顶是否合法代码如下：</h5> 
<pre><code>#define STM32_APP_BASE		0x08020000		// APP flash start address

void iap_jumpapp(void)
{
    // 检查栈顶是否合法，，确保栈顶落在0x24000000-0x24FFFFFF 之间，刚好在stm32h7的RAM范围内
	if (((*(uint32_t*)(STM32_APP_BASE)) &amp; 0xff000000 ) == 0x24000000 ) {
        
        // 检查reset入口是否正确
		if (((*(uint32_t*)(STM32_APP_BASE + 4)) &amp; 0x0fff0000 ) == 0x08020000 ) {

			JumpToApp = (pfunction)((*(uint32_t*)(STM32_APP_BASE + 4)));
			MSR_MSP(*(uint32_t*)STM32_APP_BASE);

			JumpToApp();
		}
	} else {
		...
	}
}
</code></pre> 
<h5><a id="__reset_25"></a>栈顶地址 和 reset入口地址具体是什么？？？</h5> 
<p>从startup_stm32h743xx.s中可以看出，程序第一个地址存放的是__initial_sp，紧接着第二个地址存放的是Reset_Handler；这两个正是所谓的栈顶地址 reset 入口</p> 
<pre><code>__Vectors       DCD     __initial_sp                      ; Top of Stack
                DCD     Reset_Handler                     ; Reset Handler
                DCD     NMI_Handler                       ; NMI Handler
                DCD     HardFault_Handler                 ; Hard Fault Handler
                DCD     MemManage_Handler                 ; MPU Fault Handler
                DCD     BusFault_Handler                  ; Bus Fault Handler
                DCD     UsageFault_Handler                ; Usage Fault Handler
                DCD     0                                 ; Reserved
                DCD     0                                 ; Reserved
                DCD     0                                 ; Reserved
</code></pre> 
<table><thead><tr><th>代码</th><th>说明</th><th>备注</th></tr></thead><tbody><tr><td>__initial_sp</td><td>栈顶地址</td><td>程序占用的最大RAM地址，占用RAM大小=RW-data + ZI-data</td></tr><tr><td>Reset_Handler</td><td>reset入口</td><td>程序上电后，第一个运行的函数地址</td></tr></tbody></table> 
<h5><a id="mapbin_48"></a>结合map文件和bin文件进行分析</h5> 
<ul><li>生成map文件中，__initial_sp = 0x2400f2a8</li></ul> 
<pre><code>    ...
    HEAP                                     0x2400c2a8   Section     4096  startup_stm32h743xx.o(HEAP)
    Heap_Mem                                 0x2400c2a8   Data        4096  startup_stm32h743xx.o(HEAP)
    STACK                                    0x2400d2a8   Section     8192  startup_stm32h743xx.o(STACK)
    Stack_Mem                                0x2400d2a8   Data        8192  startup_stm32h743xx.o(STACK)
    __initial_sp                             0x2400f2a8   Data           0  startup_stm32h743xx.o(STACK)

    Global Symbols
    ...
</code></pre> 
<blockquote> 
 <p>另外，从中可以看出<br> 堆栈Stack范围 0x2400d2a8 - 0x2400f2a8 占用8K<br> Heap范围 0x2400c2a8 - 0x2400d2a8 占用4K<br> 和startup_stm32h743xx.s中的定义对应</p> 
 <pre><code>Stack_Size		EQU     0x2000       ;;0x400

                AREA    STACK, NOINIT, READWRITE, ALIGN=3
Stack_Mem       SPACE   Stack_Size
__initial_sp


; &lt;h&gt; Heap Configuration
;   &lt;o&gt;  Heap Size (in Bytes) &lt;0x0-0xFFFFFFFF:8&gt;
; &lt;/h&gt;

Heap_Size      EQU     0x1000        ;;0x200

                AREA    HEAP, NOINIT, READWRITE, ALIGN=3
__heap_base
Heap_Mem        SPACE   Heap_Size
__heap_limit

                PRESERVE8
                THUMB
</code></pre> 
</blockquote> 
<ul><li>map文件中，Reset_Handler = 0x0802038d</li></ul> 
<pre><code>    Reset_Handler                            0x0802038d   Thumb Code     8  startup_stm32h743xx.o(.text)
</code></pre> 
<p>生成bin文件中<br> 第一个数据 a8 f2 00 24 即 0x2400f2a8 (__initial_sp)<br> 第二个数据 8d 03 02 08 即 0x0802038d (Reset_Handler)</p> 
<pre><code>a8 f2 00 24 8d 03 02 08 31 60 02 08 f1 59 02 08
15 60 02 08 25 0f 02 08 89 87 02 08 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 09 65 02 08
41 12 02 08 00 00 00 00 c5 61 02 08 5d 65 02 08
a7 03 02 08 a7 03 02 08 a7 03 02 08 a7 03 02 08
a7 03 02 08 a7 03 02 08 a7 03 02 08 a7 03 02 08
a7 03 02 08 a7 03 02 08 a7 03 02 08 61 0f 02 08
6d 0f 02 08 a7 03 02 08 a7 03 02 08 a7 03 02 08
a7 03 02 08 a7 03 02 08 a7 03 02 08 a7 03 02 08
a7 03 02 08 a7 03 02 08 a7 03 02 08 a7 03 02 08

</code></pre> 
<p>所以跳转的时候，直接跳转到0x0802038d地址即可！</p> 
<blockquote> 
 <p>生成bin文件user run命令：<br> fromelf.exe --bin -o “$L@L.bin” “#L”</p> 
</blockquote> 
<hr> 
<h5><a id="_120"></a>所以</h5> 
<pre><code>(*(uint32_t*)(STM32_APP_BASE) 即 __initial_sp

(*(uint32_t*)(STM32_APP_BASE+4) 即 Reset_Handler
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a42452f7add5dcb983a8c887b44592d3/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">计算机存储单位</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/390887670531bd1bedd2474396096025/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">sql 字段值字符转化</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>