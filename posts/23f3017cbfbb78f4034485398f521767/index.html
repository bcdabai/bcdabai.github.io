<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>[数据结构]顺序表 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="[数据结构]顺序表" />
<meta property="og:description" content="1、顺序表的概念及结构 1.1 线性表 线性表（ linear list ）是n个具有相同特性的数据元素的有限序列。 线性表是⼀种在实际中广泛使用的数据结构，常见的线性表：顺序表、链表、栈、队列、字符串... 线性表在逻辑上是线性结构，也就说是连续的⼀条直线。但是在物理结构上并不⼀定是连续的， 线性表在物理上存储时，通常以数组和链式结构的形式存储。 案例：蔬菜分为绿叶类、⽠类、菌菇类。线性表指的是具有部分相同特性的⼀类数据结构的集合 2、顺序表分类 2.1顺序表和数组的区别 顺序表的底层结构是数组，对数组的封装，实现了常用的增删改查等接⼝ 2.2顺序表分类 1.静态顺序表: 概念：使用定长数组存储元素
代码示例：
typrdef int SLDataType; #define N 8 typedef struct SeqList { SLDataType a[N];//定长数组 int size; //有效数据个数 }SL; 这就是一个静态顺序表，它又一定的缺陷。
容易出现：空间给少了不够用，给多了造成空间浪费 2.动态顺序表 它的特点是：按需申请
3.动态顺序表的实现 我们首先创建相应的头文件和程序文件
我们现在头文件中，引用头文件，定义所需要的结构体和函数
#include&lt;stdio.h&gt; #include&lt;assert.h&gt; #include&lt;stdlib.h&gt; typedef int SLDataType; typedef struct SeqList { SLDataType* arr; //存储数据的底层结构 int capacity; //记录顺序表的空间大小 int size; //记录顺序表当前有效的数据个数 }SL; //初始化： void SLInit(SL* ps); //销毁 void SLDestroy(SL* ps); //顺序表的头部 / 尾部插入 void SLPushFront(SL* ps, SLDataType x); void SLPushBack(SL* ps, SLDataType x); //顺序表的头部 / 尾部删除 void SLPopBack(SL* ps); void SLPopFront(SL* ps); //打印 void SLPrint(SL* ps); //删除指定位置的值 void SLInsert(SL* ps, int pos, SLDataType x); void SLErase(SL* ps, int pos); 我们先定义一个动态顺序表" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/23f3017cbfbb78f4034485398f521767/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-22T20:33:19+08:00" />
<meta property="article:modified_time" content="2024-01-22T20:33:19+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">[数据结构]顺序表</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2><span style="color:#1f2329;">1、顺序表的概念及结构</span></h2> 
<h3><span style="color:#1f2329;">1.1 线性表</span></h3> 
<p></p> 
<blockquote> 
 <div> 
  <span style="color:#646a73;">线性表（</span> 
  <span style="color:#646a73;">linear list</span> 
  <span style="color:#646a73;">）是n个具有相同特性的数据元素的有限序列。 线性表是⼀种在实际中广泛使用的数据结构，常见的线性表：顺序表、链表、栈、队列、字符串... </span> 
 </div> 
 <div> 
  <span style="color:#646a73;">线性表在逻辑上是线性结构，也就说是连续的⼀条直线。但是在物理结构上并不⼀定是连续的， 线性表在物理上存储时，通常以数组和链式结构的形式存储。 </span> 
 </div> 
 <div> 
  <span style="color:#646a73;">案例：蔬菜分为绿叶类、⽠类、菌菇类。线性表指的是具有部分相同特性的⼀类数据结构的集合 </span> 
 </div> 
</blockquote> 
<div> 
 <h2><span style="color:#1f2329;">2、顺序表分类 </span></h2> 
 <h3><span style="color:#0d0016;">2.1顺序表和数组的区别 </span></h3> 
 <div> 
  <span style="color:#1f2329;">顺序表的底层结构是数组，对数组的封装，实现了常用的增删改查等接⼝</span> 
 </div> 
</div> 
<h3><span style="color:#0d0016;">2.2顺序表分类</span><span style="color:#1f2329;"> </span></h3> 
<h4><span style="color:#0d0016;">1.静态顺序表:</span></h4> 
<p><span style="color:#0d0016;">概念：使用定长数组存储元素</span></p> 
<p>代码示例：</p> 
<pre><code class="language-cpp">typrdef int SLDataType;
#define N 8
typedef struct SeqList
{
    SLDataType a[N];//定长数组
    int size;       //有效数据个数
}SL;
</code></pre> 
<p>这就是一个静态顺序表，它又一定的缺陷。</p> 
<div> 
 <span style="color:#646a73;">容易出现：空间给少了不够用，给多了造成空间浪费</span> 
</div> 
<div></div> 
<div></div> 
<div></div> 
<div></div> 
<h4><span style="color:#0d0016;">2.动态顺序表</span></h4> 
<p>它的特点是：按需申请</p> 
<p></p> 
<p></p> 
<h2>3.动态顺序表的实现</h2> 
<p>我们首先创建相应的头文件和程序文件</p> 
<p><img alt="" height="48" src="https://images2.imgbox.com/1e/50/GEZ9Xbxj_o.png" width="484"></p> 
<p>我们现在头文件中，引用头文件，定义所需要的结构体和函数</p> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
#include&lt;assert.h&gt;
#include&lt;stdlib.h&gt;
typedef int SLDataType;

typedef struct SeqList
{
	SLDataType* arr; //存储数据的底层结构
	int capacity;    //记录顺序表的空间大小
	int size;        //记录顺序表当前有效的数据个数
}SL;
//初始化：
void SLInit(SL* ps);
//销毁
void SLDestroy(SL* ps);
//顺序表的头部 / 尾部插入
void SLPushFront(SL* ps, SLDataType x);
void SLPushBack(SL* ps, SLDataType x);
//顺序表的头部 / 尾部删除 
void SLPopBack(SL* ps);
void SLPopFront(SL* ps);

//打印
void SLPrint(SL* ps);
//删除指定位置的值
void SLInsert(SL* ps, int pos, SLDataType x);
void SLErase(SL* ps, int pos);

</code></pre> 
<p>我们先定义一个动态顺序表</p> 
<p><img alt="" height="203" src="https://images2.imgbox.com/bd/65/W9OFx79F_o.png" width="630"><img alt="" height="57" src="https://images2.imgbox.com/60/58/tOqFGWZA_o.png" width="760">注意：这行代码是为了设定我们的数据类型</p> 
<h5 style="background-color:transparent;">1.初始化</h5> 
<p>接下来我们要初始化我们的顺序表。所以我们定义了这个函数</p> 
<p><img alt="" height="96" src="https://images2.imgbox.com/35/37/WUIW9sTS_o.png" width="491"></p> 
<p>接着我们去源文件写完这个函数，让指针指向NULL大小设定为0完成初始化</p> 
<pre><code class="language-cpp">void SLInit(SL* ps) 
{
	ps-&gt;arr = NULL;
	ps-&gt;size = ps-&gt;capacity = 0;
}</code></pre> 
<p>写完了初始化我们可以开始写功能</p> 
<p>首先就是头插和尾插</p> 
<p><img alt="" height="102" src="https://images2.imgbox.com/36/bb/8x9c6o51_o.png" width="893"></p> 
<p>我们接着完善</p> 
<p></p> 
<p></p> 
<h5>2.头插</h5> 
<p>我们先来写头插函数</p> 
<blockquote> 
 <p>void SLPushFront(SL* ps, SLDataType x)</p> 
</blockquote> 
<p>首先我们来思考以下问题，一个数组如何头插，以及目前的内存大小能否插入新的数据</p> 
<p>假设足够：</p> 
<p><img alt="" height="281" src="https://images2.imgbox.com/21/57/6VsBtheF_o.png" width="834"></p> 
<p>数组头插，我们一般将数组的各个元素后移一位然后将数组arr[0]赋值成我们要插入的数据</p> 
<pre><code class="language-cpp">void SLPushFront(SL* ps, SLDataType x)
{
	assert(ps);
for (int i = ps-&gt;size; i &gt; 0; i--) //i = 1
	{
		ps-&gt;arr[i] = ps-&gt;arr[i - 1]; //ps-&gt;arr[1] = ps-&gt;arr[0]
	}
	ps-&gt;arr[0] = x;
	ps-&gt;size++;
}
</code></pre> 
<p>我们不难写出这个函数但是它对吗？</p> 
<p>显然存在一定的问题，我们前面的条件是设置在空间充足的情况下，如果空间不足的话，我们该怎么办呢？</p> 
<p>当然是扩容啦！！！</p> 
<p>所以我们再写一个检查空间是否充足的函数，如果不足顺便扩容。</p> 
<p></p> 
<p>那么，既然说到扩容，我们应该怎样扩容呢？</p> 
<p>我这里有三种扩容方式：</p> 
<blockquote> 
 <p>1.一次扩容一个空间</p> 
 <p>2.一次扩容多个大小的空间</p> 
 <p>3.成倍的增加空间（1.5倍，2倍）</p> 
</blockquote> 
<p></p> 
<p>这里我推荐第三种方法。</p> 
<p>理由：</p> 
<blockquote> 
 <p>        第一种一次扩容一个空间，好处是不会造成空间的浪费，缺点是如果我们输入大量数据时，它需要多次开辟，导致程序效率低下。</p> 
 <p>        第二种一次开辟多个空间，有效解决了第一种导致程序小路低下的问题，但是，它也有相应的问题，我们不能确定一次开辟多大的空间合适，如果开辟小了，一样也会和第一种一样多次扩容，影响程序效率，但如果一下周四开辟空间过大，也会导致空间被浪费。</p> 
</blockquote> 
<p></p> 
<p>我们先定义函数：</p> 
<pre><code class="language-cpp">void SLCheckCapacity(SL* ps)</code></pre> 
<p>接着判断是否需要扩容，然后扩容空间，但是由于我们初始化直接是NULL所以这里我再加上一个三目操作符，总体代码如下：</p> 
<pre><code class="language-cpp">void SLCheckCapacity(SL* ps)
{
	if (ps-&gt;size == ps-&gt;capacity)
	{
		int newCapacity = ps-&gt;capacity == 0 ? 4 : 2 * ps-&gt;capacity;
		SLDataType* tmp = (SLDataType*)realloc(ps-&gt;arr, newCapacity * sizeof(SLDataType));
		if (tmp == NULL) {
			perror("realloc fail!");
			exit(1);
		}
		//扩容成功
		ps-&gt;arr = tmp;
		ps-&gt;capacity = newCapacity;
	}
}</code></pre> 
<p>这里我设置了tmp变量是为了防止扩容失败。这里我选择的就是扩容原来的两倍。</p> 
<p></p> 
<p>接下来我们按照上面的思路把头插完善</p> 
<pre><code class="language-cpp">void SLPushFront(SL* ps, SLDataType x)
{
	assert(ps);
	SLCheckCapacity(ps);
	for (int i = ps-&gt;size; i &gt; 0; i--) //i = 1
	{
		ps-&gt;arr[i] = ps-&gt;arr[i - 1]; //ps-&gt;arr[1] = ps-&gt;arr[0]
	}
	ps-&gt;arr[0] = x;
	ps-&gt;size++;
}</code></pre> 
<p></p> 
<p></p> 
<h5>3.尾插</h5> 
<p>做完了头插，我们可以来试试尾插，数组中尾插是神简单的，如图：</p> 
<p><img alt="" height="297" src="https://images2.imgbox.com/7e/ea/ThKJIGqH_o.png" width="816"></p> 
<p>如果空间充足，我们可以直接再尾部插入我们的数据然后吧size++，不够的话先扩容然后再执行</p> 
<pre><code class="language-cpp">void SLPushBack(SL * ps, SLDataType x)
{
		assert(ps);
		SLCheckCapacity(ps);
		ps-&gt;arr[ps-&gt;size++] = x;
}</code></pre> 
<p>这样头插和尾插就完成了</p> 
<p></p> 
<h5>4.头删</h5> 
<p>完成了插入那么我们还需要完成删除，删除相比较插入它有什么不同？删除不需要太在意空间。</p> 
<p>现在我们先来完成头删。</p> 
<p>在数组中我们怎么完成头删的呢？如图</p> 
<p><img alt="" height="257" src="https://images2.imgbox.com/98/73/WqlEHNRJ_o.png" width="710">我们一般是把每个数向前移动一位，数组有效长度-1，及size--;</p> 
<p>代码示例：</p> 
<pre><code class="language-cpp">void SLPopFront(SL* ps)
{
	assert(ps);
	assert(ps-&gt;size);
	for (int i = 0; i &lt; ps-&gt;size - 1; i++)
	{
		ps-&gt;arr[i] = ps-&gt;arr[i + 1];
	}
	ps-&gt;size--;
}</code></pre> 
<p>注意：我们要确保ps和ps-&gt;size不为NULL</p> 
<p></p> 
<h5>5.尾删</h5> 
<p>这个操作实现起来其实非常简单，我们可以直接size--;</p> 
<p>代码示例：</p> 
<pre><code class="language-cpp">void SLPopBack(SL* ps)
{
	
	assert(ps);
	assert(ps-&gt;size);   
	ps-&gt;size--;
	
}</code></pre> 
<p></p> 
<p></p> 
<p>完成这些，那么我要上难度了，删除指定位置的值/插入指定位置的值</p> 
<p></p> 
<p></p> 
<h5 style="background-color:transparent;">6.删除指定位置的值</h5> 
<p>具体思路，就是遍历去寻找所需数值，然后并将该数值之后的数据的下标前移，siza--如图：</p> 
<p><img alt="" height="261" src="https://images2.imgbox.com/63/36/TSEkMEMp_o.png" width="742"></p> 
<p></p> 
<p>代码示例：</p> 
<pre><code class="language-cpp">void SLErase(SL* ps, int pos) {
	assert(ps);
	assert(pos &gt;= 0 &amp;&amp; pos &lt; ps-&gt;size);

	//pos以后的数据往前挪动一位
	for (int i = pos; i &lt; ps-&gt;size - 1; i++)
	{
		ps-&gt;arr[i] = ps-&gt;arr[i + 1];//ps-&gt;arr[i-2] = ps-&gt;arr[i-1];
	}
	ps-&gt;size--;
}
</code></pre> 
<p></p> 
<p></p> 
<h5>7.在指定位置插入值</h5> 
<p>思路，找到数值将该数值及其后的向后移动一位。size++</p> 
<p>如图：</p> 
<p><img alt="" height="213" src="https://images2.imgbox.com/19/7e/axrRV18M_o.png" width="660"></p> 
<p>代码示例：</p> 
<pre><code class="language-cpp">void SLInsert(SL* ps, int pos, SLDataType x) {
	assert(ps);
	assert(pos &gt;= 0 &amp;&amp; pos &lt;= ps-&gt;size);

	SLCheckCapacity(ps);

	//pos及之后的数据往后挪动一位，pos空出来
	for (int i = ps-&gt;size; i &gt; pos; i--)
	{
		ps-&gt;arr[i] = ps-&gt;arr[i - 1]; //ps-&gt;arr[pos+1] = ps-&gt;arr[pos]
	}
	ps-&gt;arr[pos] = x;
	ps-&gt;size++;
}</code></pre> 
<p><span style="color:#fe2c24;">注：这是插入，要检查空间是否足够</span></p> 
<p></p> 
<p></p> 
<h5><span style="color:#0d0016;">8.打印</span></h5> 
<p><span style="color:#0d0016;">完成这些我们可以来尝试打印我们的顺序表，类似打印数组。</span></p> 
<p><span style="color:#0d0016;">代码示例：</span></p> 
<pre><code class="language-cpp">void SLPrint(SL* ps) 
{
	for (int i = 0; i &lt; ps-&gt;size; i++)
	{
		printf("%d ", ps-&gt;arr[i]);
	}
	printf("\n");
} </code></pre> 
<p></p> 
<p></p> 
<h5>9.销毁顺序表</h5> 
<p>在我们之前讲过动态内存开辟，最后要再释放。</p> 
<p>代码示例：</p> 
<pre><code class="language-cpp">void SLDestroy(SL* ps) 
{
	assert(ps);

	if (ps-&gt;arr) {
		free(ps-&gt;arr);
	}
	ps-&gt;arr = NULL;
	ps-&gt;size = ps-&gt;capacity = 0;
}</code></pre> 
<p>最后来展示程序代码：</p> 
<pre><code class="language-cpp">#include"SeqList.h"
void SLInit(SL* ps) 
{
	ps-&gt;arr = NULL;
	ps-&gt;size = ps-&gt;capacity = 0;
}
void SLDestroy(SL* ps)
{
	assert(ps);

	if (ps-&gt;arr) {
		free(ps-&gt;arr);
	}
	ps-&gt;arr = NULL;
	ps-&gt;size = ps-&gt;capacity = 0;
}
void SLCheckCapacity(SL* ps)
{
	if (ps-&gt;size == ps-&gt;capacity)
	{
		int newCapacity = ps-&gt;capacity == 0 ? 4 : 2 * ps-&gt;capacity;
		SLDataType* tmp = (SLDataType*)realloc(ps-&gt;arr, newCapacity * sizeof(SLDataType));
		if (tmp == NULL) {
			perror("realloc fail!");
			exit(1);
		}
		//扩容成功
		ps-&gt;arr = tmp;
		ps-&gt;capacity = newCapacity;
	}
}
void SLPushBack(SL * ps, SLDataType x)
{
		assert(ps);
		SLCheckCapacity(ps);
		ps-&gt;arr[ps-&gt;size++] = x;
}
void SLPushFront(SL* ps, SLDataType x)
{
	assert(ps);
	SLCheckCapacity(ps);
	for (int i = ps-&gt;size; i &gt; 0; i--) //i = 1
	{
		ps-&gt;arr[i] = ps-&gt;arr[i - 1]; //ps-&gt;arr[1] = ps-&gt;arr[0]
	}
	ps-&gt;arr[0] = x;
	ps-&gt;size++;
}
void SLPopBack(SL* ps)
{
	
	assert(ps);
	assert(ps-&gt;size);   
	ps-&gt;size--;
	
}
void SLPopFront(SL* ps)
{
	assert(ps);
	assert(ps-&gt;size);
	for (int i = 0; i &lt; ps-&gt;size - 1; i++)
	{
		ps-&gt;arr[i] = ps-&gt;arr[i + 1];
	}
	ps-&gt;size--;
}
void SLInsert(SL* ps, int pos, SLDataType x) {
	assert(ps);
	assert(pos &gt;= 0 &amp;&amp; pos &lt;= ps-&gt;size);
	SLCheckCapacity(ps);
	for (int i = ps-&gt;size; i &gt; pos; i--)
	{
		ps-&gt;arr[i] = ps-&gt;arr[i - 1]; //ps-&gt;arr[pos+1] = ps-&gt;arr[pos]
	}
	ps-&gt;arr[pos] = x;
	ps-&gt;size++;
}
void SLErase(SL* ps, int pos) 
{
	assert(ps);
	assert(pos &gt;= 0 &amp;&amp; pos &lt; ps-&gt;size);
	for (int i = pos; i &lt; ps-&gt;size - 1; i++)
	{
		ps-&gt;arr[i] = ps-&gt;arr[i + 1];
	}
	ps-&gt;size--;
}
void SLPrint(SL* ps) 
{
	for (int i = 0; i &lt; ps-&gt;size; i++)
	{
		printf("%d ", ps-&gt;arr[i]);
	}
	printf("\n");
} 
void SLDestroy(SL* ps) 
{
	assert(ps);

	if (ps-&gt;arr) {
		free(ps-&gt;arr);
	}
	ps-&gt;arr = NULL;
	ps-&gt;size = ps-&gt;capacity = 0;
}
//指定位置之前插入数据
void SLInsert(SL* ps, int pos, SLDataType x) {
	assert(ps);
	assert(pos &gt;= 0 &amp;&amp; pos &lt;= ps-&gt;size);

	SLCheckCapacity(ps);

	//pos及之后的数据往后挪动一位，pos空出来
	for (int i = ps-&gt;size; i &gt; pos; i--)
	{
		ps-&gt;arr[i] = ps-&gt;arr[i - 1]; //ps-&gt;arr[pos+1] = ps-&gt;arr[pos]
	}
	ps-&gt;arr[pos] = x;
	ps-&gt;size++;
}
//删除指定位置数据
void SLErase(SL* ps, int pos) {
	assert(ps);
	assert(pos &gt;= 0 &amp;&amp; pos &lt; ps-&gt;size);

	//pos以后的数据往前挪动一位
	for (int i = pos; i &lt; ps-&gt;size - 1; i++)
	{
		ps-&gt;arr[i] = ps-&gt;arr[i + 1];//ps-&gt;arr[i-2] = ps-&gt;arr[i-1];
	}
	ps-&gt;size--;
}
</code></pre> 
<p>这样一个循序表完成了，你可以用设计的函数来进行操作。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a8cf9014e64f000ee17cc2ec3dba8721/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">QT获取本机网络信息</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5c985e50d7698535cdea12c2944c823e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">接口自动化测试：pytest基础讲解</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>