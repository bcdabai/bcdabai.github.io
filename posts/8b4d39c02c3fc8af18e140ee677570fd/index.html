<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java引用（强引用和弱引用） - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Java引用（强引用和弱引用）" />
<meta property="og:description" content=" 引用 一、概述 众所周知，Java中是由JVM负责内存的分配和回收，它的优点是使用方便，程序员不
用再像使用c那样操心内存，但同时也是它的缺点，不够灵活。为了解决内存操作不灵活这
个问题，可以采用弱引用等方法。
在JDK1.2以前的版本中，当一个对象不被任何变量引用，那么程序就无法再使用这个
对象。也就是说，只有对象处于可触及状态，程序才能使用它。这就像在日常生活中，从商
店购买了某样物品后，如果有用，就一直保留它，否则就把它扔到垃圾箱，由清洁工人收走。
但有时候情况并不这么简单，你可能会遇到类似以鸡肋一样的物品，食之无味，弃之可惜。
这种物品现在已经无用了，保留它会占空间，但是立刻扔掉它也不划算，因为也许将
来还会派用场。对于这样的可有可无的物品，一种折衷的处理办法是：如果家里空间足够，
就先把它保留在家里，如果家里空间不够，即使把家里所有的垃圾清除，还是无法容纳那些
必不可少的生活用品，那么再扔掉这些可有可无的物品。从JDK1.2版本开始便有了对象的
引用的机制，从而使程序能更加灵活的控制对象的生命周期
二、强引用(StrongReference) 它类似于必不可少的生活用品，垃圾回收器绝不会回收它。当内存空间不足，Java虚
似机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用
的对象来解决内存不足问题。强引用是使用最普遍的引用，以前我们使用的大部分引用实际
上都是强引用。例如：
只要此引用存在没有被释放（没有使student=null),垃圾回收器永远不会回收。只有
当这个引用被释放之后，垃圾回收器才可能回收，这也是我们经常所用到的编码形式。
三、弱引用（WeakReference） 如果一个对象只具有弱引用，那就类似于可有可无的生活用品。在垃圾回收器线程扫描
它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与
否，都会回收它的内存，（不过，由于垃圾回收器是一个优先级很低的线程，因此不一定
会马上发现那些只具有弱引用的对象)如：
当需要获得weakStudent引用的Student时，可以使用
如果此方法返回的为空(null)，那么说明weakStudent指向的对象student已经被回收了。
例如我们常用的在内部类的Handler中使用的Activity弱引用，防止内存泄漏：
*(谨慎入坑) *（谨慎入坑）
static class CountdownTimeHandler extends Handler{ final WeakReference&lt;MainActivity&gt; weakReference; CountdownTimeHandler(WeakReference&lt;MainActivity&gt; weakReference) { this.weakReference = weakReference; } @Override public void handleMessage(@NonNull Message msg) { super.handleMessage(msg); MainActivity activity = weakReference.get(); } } } " />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/8b4d39c02c3fc8af18e140ee677570fd/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-07-08T19:54:31+08:00" />
<meta property="article:modified_time" content="2022-07-08T19:54:31+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java引用（强引用和弱引用）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3 id="CVTfM">引用</h3> 
<h4 id="fI0xQ">一、概述</h4> 
<p id="ud98a7874">众所周知，Java中是由JVM负责内存的分配和回收，它的优点是使用方便，程序员不</p> 
<p id="ua32e6e35">用再像使用c那样操心内存，但同时也是它的缺点，不够灵活。为了解决内存操作不灵活这</p> 
<p id="uf2cca2eb">个问题，可以采用弱引用等方法。</p> 
<p id="ufdeb3ce6">在JDK1.2以前的版本中，当一个对象不被任何变量引用，那么程序就无法再使用这个</p> 
<p id="ua0e41a80">对象。也就是说，只有对象处于可触及状态，程序才能使用它。这就像在日常生活中，从商</p> 
<p id="u6a83b517">店购买了某样物品后，如果有用，就一直保留它，否则就把它扔到垃圾箱，由清洁工人收走。</p> 
<p id="uaacdde12">但有时候情况并不这么简单，你可能会遇到类似以鸡肋一样的物品，食之无味，弃之可惜。</p> 
<p id="ue3f33ab3">这种物品现在已经无用了，保留它会占空间，但是立刻扔掉它也不划算，因为也许将</p> 
<p id="ueac6ef5d">来还会派用场。对于这样的可有可无的物品，一种折衷的处理办法是：如果家里空间足够，</p> 
<p id="u0b917e39">就先把它保留在家里，如果家里空间不够，即使把家里所有的垃圾清除，还是无法容纳那些</p> 
<p id="u116d31c7">必不可少的生活用品，那么再扔掉这些可有可无的物品。从JDK1.2版本开始便有了对象的</p> 
<p id="u67b6ce90">引用的机制，从而使程序能更加灵活的控制对象的生命周期</p> 
<p id="u21638319"></p> 
<h4 id="HOoML">二、强引用(StrongReference)</h4> 
<p id="u0c725683">它类似于必不可少的生活用品，垃圾回收器绝不会回收它。当内存空间不足，Java虚</p> 
<p id="u5e933936">似机宁愿抛出<em>OutOfMemoryError</em>错误，使程序异常终止，也不会靠随意回收具有强引用</p> 
<p id="u7d169e58">的对象来解决内存不足问题。强引用是使用最普遍的引用，以前我们使用的大部分引用实际</p> 
<p id="udc72681b">上都是强引用。例如：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/b4/7e/vT93NUKx_o.png"></p> 
<p id="u16a55a67"></p> 
<p id="u0f6fcda7">只要此引用存在没有被释放（没有使student=null),垃圾回收器永远不会回收。只有</p> 
<p id="u125422f7">当这个引用被释放之后，垃圾回收器才可能回收，这也是我们经常所用到的编码形式。</p> 
<p id="uf6f9ccf1"></p> 
<h3 id="ltqbK">三、弱引用（WeakReference）</h3> 
<p id="uf139ccaa">如果一个对象只具有弱引用，那就类似于可有可无的生活用品。在垃圾回收器线程扫描</p> 
<p id="ue4f0169d">它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与</p> 
<p id="u72456484">否，都会回收它的内存，（不过，由于垃圾回收器是一个优先级很低的线程，因此不一定</p> 
<p id="ua0f52beb">会马上发现那些只具有弱引用的对象)如：</p> 
<p id="u6f1617f5"></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/1d/01/lsME1prK_o.png"></p> 
<p id="u424df476"></p> 
<p id="ufcc00ade">当需要获得weakStudent引用的Student时，可以使用</p> 
<p id="uac504eca"></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/eb/bb/oVQrT6Yt_o.png"></p> 
<p id="u561437b2"></p> 
<p id="u2e61112a">如果此方法返回的为空(null)，那么说明weakStudent指向的对象student已经被回收了。</p> 
<p id="u9abcd23a"></p> 
<p id="udbd1805f">例如我们常用的在内部类的Handler中使用的Activity弱引用，防止内存泄漏：</p> 
<p><em>*(谨慎入坑) *（谨慎入坑）</em></p> 
<pre><code class="language-java">    static class CountdownTimeHandler extends Handler{
        final WeakReference&lt;MainActivity&gt; weakReference;

        CountdownTimeHandler(WeakReference&lt;MainActivity&gt; weakReference) {
            this.weakReference = weakReference;
        }

        @Override
        public void handleMessage(@NonNull Message msg) {
            super.handleMessage(msg);
            MainActivity activity = weakReference.get();
            }
        }
    }</code></pre> 
<p id="u18ae7591"></p> 
<p id="u790ac0fe"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/aab5ee4953a64252e56b8bef8cba3961/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Python抓取全国旅游景点以及小吃数据，想做旅游攻略？Python助你事半功倍。</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/12e260cfb89206bca6cd7c1f512e009f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">递归的实践——反转链表</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>