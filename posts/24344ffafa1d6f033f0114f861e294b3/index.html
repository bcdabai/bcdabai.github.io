<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Feign:熔断,@FeignClient注解参数简介,优化 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Feign:熔断,@FeignClient注解参数简介,优化" />
<meta property="og:description" content="相对于RestTemplate来说更加易懂 ，操作方面更加动态化。代码如下：
@GetMapping(&#34;/buy/{id}&#34;) public Product order() { Product product = restTemplate.getForObject(&#34;http://shop-serviceproduct/product/1&#34;,Product.class); return product; } 由代码可知，我们是使用拼接字符串的方式构造URL的，该URL只有一个参数。但是，在现实中，URL 中往往含有多个参数。
Feign简介 相关依赖:
&lt;!--springcloud整合的openFeign--&gt; &lt;dependency&gt;
&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
&lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;
&lt;/dependency&gt;
Feign是Netflflix开发的声明式，模板化的HTTP客户端。
SpringCloud中，使用Feign非常简单——创建一个接口，并在接口上添加@FeignClient注解。
在消费者的微服务启动类上加上@EnableFeignClients注解开启Spring Cloud Feign的支持功能。
package com.zb; import com.zb.service.impl.TestServiceImpl; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.cloud.openfeign.EnableFeignClients; import org.springframework.context.ConfigurableApplicationContext; /** * 启动类 */ @EnableFeignClients @SpringBootApplication public class UserApplication { public static void main(String[] args) { SpringApplication.run(UserApplication.class, } } Feign本身不直接支持负载均衡策略，而是通过集成Ribbon来实现负载均衡。因此，Feign可以使用Ribbon支持的各种负载均衡策略，包括轮询、随机、权重、最佳可用等。
服务熔断 SpringCloud Fegin默认已为Feign整合了hystrix，所以添加Feign依赖后就不用在添加hystrix。
yml配置开启熔断
feign: hystrix: enabled: true package com." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/24344ffafa1d6f033f0114f861e294b3/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-11-03T17:19:31+08:00" />
<meta property="article:modified_time" content="2023-11-03T17:19:31+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Feign:熔断,@FeignClient注解参数简介,优化</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p> 相对于RestTemplate来说更加易懂 ，操作方面更加动态化。代码如下：</p> 
 <pre><code class="language-java">@GetMapping("/buy/{id}")
public Product order() {
      Product product = restTemplate.getForObject("http://shop-serviceproduct/product/1",Product.class);
      return product;
}</code></pre> 
 <p>由代码可知，我们是使用拼接字符串的方式构造URL的，该URL只有一个参数。但是，在现实中，URL 中往往含有多个参数。</p> 
</blockquote> 
<h4><strong>Feign简介</strong></h4> 
<p>相关依赖:</p> 
<blockquote> 
 <p>&lt;!--springcloud整合的openFeign--&gt;        <br>         &lt;dependency&gt;</p> 
 <p>            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</p> 
 <p>            &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;</p> 
 <p>        &lt;/dependency&gt;</p> 
</blockquote> 
<p>Feign是Netflflix开发的声明式，模板化的HTTP客户端。<br> SpringCloud中，使用Feign非常简单——创建一个接口，并在接口上添加<span style="color:#fe2c24;">@FeignClient</span><span style="color:#555555;">注解。<br> 在消费者的微服务启动类上加上</span><span style="color:#fe2c24;"><strong>@EnableFeignClients</strong></span>注解开启Spring Cloud Feign的支持功能。</p> 
<pre><code class="language-java">package com.zb;

import com.zb.service.impl.TestServiceImpl;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.openfeign.EnableFeignClients;
import org.springframework.context.ConfigurableApplicationContext;

/**
* 启动类
*/
@EnableFeignClients
@SpringBootApplication
public class UserApplication {
    public static void main(String[] args) {
        SpringApplication.run(UserApplication.class, 
    }
}
</code></pre> 
<p style="margin-left:.0001pt;text-align:left;">Feign本身不直接支持<span style="color:#fe2c24;"><strong>负载均衡</strong></span>策略，而是通过集成Ribbon来实现负载均衡。因此，Feign可以使用Ribbon支持的各种负载均衡策略，包括轮询、随机、权重、最佳可用等。<img alt="" height="134" src="https://images2.imgbox.com/43/8d/NiWhxyoU_o.png" width="614"></p> 
<h3></h3> 
<h3><strong>服务熔断</strong></h3> 
<p><br><span style="color:#000000;">SpringCloud Fegin默认已为Feign整合了hystrix，所以添加Feign依赖后就不用在添加hystrix。<br> yml配置开启熔断</span></p> 
<pre><code class="language-java">feign:
  hystrix:
    enabled: true</code></pre> 
<pre><code class="language-java">package com.zb.client;

import com.zb.entity.User;
import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestParam;

/**   
* feign接口
*/
@FeignClient(value = "user-server",fallback = UserFeignClientImpl .class)
public interface UserFeignClient {

    @GetMapping("/user/all")
    String all(@RequestParam("name")User user);

}
</code></pre> 
<pre><code class="language-java">package com.zb.client.impl;

import com.zb.client.UserFeignClient;
import com.zb.entity.User;
import org.springframework.stereotype.Component;

/**
* 熔断方法
*/
@Component
public class UserFeignClientImpl implements UserFeignClient {

    @Override
    public String all(User user) {
        return "异常!";
    }
}
</code></pre> 
<h3><strong>@FeignClient 注解</strong></h3> 
<p>  注解中参数</p> 
<pre><code class="language-java">//
// Source code recreated from a .class file by IntelliJ IDEA
// (powered by FernFlower decompiler)
//

package org.springframework.cloud.openfeign;

import java.lang.annotation.Documented;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
import org.springframework.core.annotation.AliasFor;

@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface FeignClient {
    @AliasFor("name")
    String value() default "";

    /** @deprecated */
    @Deprecated
    String serviceId() default "";

    String contextId() default "";

    @AliasFor("value")
    String name() default "";

    String qualifier() default "";

    String url() default "";

    boolean decode404() default false;

    Class&lt;?&gt;[] configuration() default {};

    Class&lt;?&gt; fallback() default void.class;

    Class&lt;?&gt; fallbackFactory() default void.class;

    String path() default "";

    boolean primary() default true;
}
</code></pre> 
<h4>参数介绍</h4> 
<ol><li>value 与 name 两者都可指定提供者服务名称。@FeignClient("user-server")默认指定服务名称。 <pre><code class="language-java">@FeignClient(value = "user")

@FeignClient(name = "user")

@FeignClient("user")</code></pre> </li><li>fallback 与  fallbackFactory<br> fallback 定义容错的处理类,当调用远程接口失败或超时时，会调用对应容错方法<br> fallbackFactory是可以捕获到Feign接口所有发生的异常，并且同样可以实现fallback相关接口来进行自定义回滚代码或者日志记录等等。还可以减少重复的代码 <pre><code class="language-java">@FeignClient(value = 'user', fallback = UserFeignClientImpl.class)

@FeignClient(value = 'user', fallbackFactory = UserFallbackFactory.class)</code></pre> </li><li> <p>path这个参数完全不影响Feign接口的使用。</p> <pre><code class="language-java">@FeignClient(value = 'user',path = '/user')
</code></pre> <p>定义当前FeignClient的统一前缀</p> </li><li> <p>primary 默认值为true。可以将本类转化成Bean的</p> </li><li>url: 用于调试，可以手动指定@FeignClient调用的地址 <pre><code class="language-java">@FeignClient(value = 'user',url = "http://localhost:9090/pay/create")
</code></pre> </li><li>decode404 : 默认false，当发生http 404错误时，如果该字段位true，会调用decoder进行解码，否则抛出FeignException。 <pre><code class="language-java">@FeignClient(value = "user-server",decode404 = true)</code></pre> </li><li>configuration: Feign配置类，可以自定义Feign的Encoder、Decoder、LogLevel、ContractcontextId:可以位服务名相同的feign接口设定别名来解决同名问题  <pre><code class="language-java">// 第一个feign接口
@FeignClient(value = "user",contextId = "aa")
// 第二个feign接口
@FeignClient(value = "user",contextId = "bb")</code></pre> </li></ol> 
<h3>Feign性能优化</h3> 
<p> 主要包括：</p> 
<ol><li>使用带连接池的http请求替代默认的URLConnection</li><li>日志级别，用打印最少的（basic或者none）</li></ol> 
<h4 style="margin-left:.0001pt;text-align:left;">1.使用日志 与 超时问题</h4> 
<p style="margin-left:.0001pt;text-align:left;">Feign中本身已经集成了Ribbon依赖和自动配置，因此我们不需要额外引入依赖，也不需要再注册 RestTemplate 对象。负载均衡底层用的就是Ribbon，所以这里的请求超时配置其实就是配置Ribbon，当出现请求超时会出现以下报错。<img alt="" height="102" src="https://images2.imgbox.com/3c/ce/9ubYzdV7_o.png" width="954"></p> 
<pre><code class="language-java">feign:
  client:
    config:
      default:  #指定feignclients对应的名称 如果指定的是default 表示全局所有的client 的超时时间设置
        connectTimeout: 10000 #连接超时时间
        readTimeout: 10000  #读取超时时间
        loggerLevel: basic #设置日志记录级别

spring:
  main:
    #声明spring框架是否允许定义重名的bean对象覆盖原有的bean(默认是false）
    allow-bean-definition-overriding: true</code></pre> 
<ol><li>FULL：记录基本信息以及请求和响应头信息、请求和响应体信息</li><li>NONE：没有日志记录</li><li>BASIC：记录请求方法、URL以及响应状态代码和执行时间</li><li>HEADERS：记录基本信息以及请求和响应头信息</li></ol> 
<p><span style="color:#fe2c24;"><strong>注意 ：当开启日志配置之后，feign超时问题不会出现报错情况。</strong></span></p> 
<h4>2.使用<a href="https://so.csdn.net/so/search?q=%E8%BF%9E%E6%8E%A5%E6%B1%A0&amp;spm=1001.2101.3001.7020" title="连接池">连接池</a></h4> 
<p>HTTP连接需要经过三次握手，四次挥手的过程，这是很耗费性能的；所以HTTP连接池帮助我们节省了这一步。<br>         同时Feign的HTTP客户端支持三种框架：<br>         HttpURLConnection、HttpClient、OkHttp；默认是HttpURLConnection</p> 
<ol><li>pom.xml中引入Apache的HttpClient依赖 <pre><code class="language-java">&lt;dependency&gt;
    &lt;groupId&gt;io.github.openfeign&lt;/groupId&gt;
    &lt;artifactId&gt;feign-httpclient&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre> </li><li>配置连接池<br> 在yml文件中添加如下配置：(连接池引入之后默认是开启的,配合可以不写) <pre><code class="language-java">feign:
  client:
    config:
      default:
        loggerLevel: BASIC
  httpclient:
    enabled: true #开启feign对httpClient的支持
    max-connections: 200 #最大的连接数
    max-connections-per-route: 50 #每个路径的最大连接数
</code></pre> </li></ol> 
<h3>3.gzip压缩</h3> 
<p>Gzip 是GNUzip的缩写，最早用于UNIX系统的文件压缩。gzip压缩比率在3到10倍左右，可以大大节省服务器的网络带宽。而在实际应用中，并不是对所有文件进行压缩，通常只是压缩静态文件。</p> 
<pre><code class="language-java">
server:
  compression:
    enabled: true #开启压缩</code></pre> 
<h4 style="margin-left:0px;"><span style="color:#4f4f4f;"><span style="background-color:#ffffff;">Gzip解压缩代码实现</span></span></h4> 
<p style="margin-left:0;"><span style="color:#ff9900;"><span style="background-color:#ffffff;"><strong>        1.运行虚拟机<br>         2.在Idea的Maven中打包代码<br>         3.将打包文件拖入虚拟机中<br>         4.执行jar包</strong></span></span></p> 
<h4>客户端和服务器之间通信支持gzip图<img alt="" height="601" src="https://images2.imgbox.com/4f/97/W7LwnmNH_o.png" width="1004"></h4> 
<h4>常见问题</h4> 
<p>Feign 的 maven 依赖报红，或者主启动类上@EnableFeignClients不识别，一直报红，或者 feign 接口注入到控制器报红。<br> 可能的原因及处理方案：<br>         1.maven 包没有成功导入，或者 maven 包下载不完整，可以先clean在compile一下删掉依赖包后重新下载导入。<br>         2.版本冲突，可以在 maven 包导入时指定版本号，尝试其他可用的版本。</p> 
<h3><strong>面试题</strong></h3> 
<p><strong>1.Feign与RestTemplate之间有什么区别？</strong><br> Feign和RestTemplate都用于进行HTTP请求，但它们有一些区别：<br>     Feign：<br>         Feign是声明性的HTTP客户端，通过接口和注解来定义服务调用。<br>         Feign自动生成HTTP请求代码，开发者只需定义接口和方法。<br>         集成了Ribbon和Hystrix，支持负载均衡和服务降级。<br>         更具有声明性和简洁性，适用于微服务架构中的服务调用。<br>     RestTemplate：<br>         RestTemplate是经典的HTTP客户端，需要手动编写HTTP请求代码。<br>         开发者需要构建HTTP请求、处理请求和响应、处理异常等。<br>         可以用于调用任何HTTP服务，不仅限于微服务架构。<br>         更灵活，适用于需要更多控制的场景。<br>     选择使用Feign还是RestTemplate取决于项目的需求和开发团队的偏好。在微服务架构中，Feign通常更受欢迎，因为它提供了更高级别的抽象和更简洁的代码。</p> 
<p><span style="color:#0d0016;">2.使用</span><span style="color:#fe2c24;">Feign</span><span style="color:#0d0016;">时怎样传递Header的参数？</span></p> 
<pre><code class="language-java">// 1.通过 @RequestHeader(name = "name") 来传递
@FeignClient(name = "xxx-service-name")
public interface XxxFeignClient {
 
    @RequestMapping(value = "/user/info")
    String userTicket(@RequestHeader(name = "token") String token);
}</code></pre> 
<p>这种方式的缺点和明显，就是如果传递多个Header参数，则需要在接口方法定义的时候都添加进去，显得比较繁琐。<br><strong>第二种方式</strong>，就是通过定义一个配置类实现RequestInterceptor接口，然后将这个配置类添加进@<a href="https://so.csdn.net/so/search?q=FeignClient&amp;spm=1001.2101.3001.7020" title="FeignClient">FeignClient</a>注解中即可，代码示例如下：</p> 
<pre><code class="language-java">@Configuration
public class HeaderConfiguration implements RequestInterceptor {
    
    @Override
    public void apply(RequestTemplate requestTemplate) {
        ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();
        HttpServletRequest request = attributes.getRequest();
 
        Enumeration headerNames = request.getHeaderNames();
 
        if (headerNames != null) {
            // 循环取所有header，将header的内容都放入requestTemplate
            while (headerNames.hasMoreElements()) {
                String name = headerNames.nextElement();
                String values = request.getHeader(name);
                requestTemplate.header(name, values);
            }
        }
    }
}</code></pre> 
<pre><code class="language-java">// 然后将自定义的配置类配置到Feign中，实现该Feign中接口Header参数的传递
@FeignClient(value = "user-server", configuration = HeaderConfiguration.class)
public interface UserFeignClient {
 
    @RequestMapping(value = "/user/info")
    String userInfo();
}</code></pre> 
<p><br><span style="color:#0d0016;">        </span></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/905c36ac2f2dce0e56e2d14c09bcc130/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">20231103配置cv180zb的编译环境【填坑篇】</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1de0b2335800440d5fb44d5135189b82/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">js获取日期的农历时间</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>