<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java 阻塞线程用法 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Java 阻塞线程用法" />
<meta property="og:description" content="CountDownLatch
首先先说明CountDownLatch辅助类
CountDownLatch，一个同步辅助类，在完成一组正在其他线程中执行的操作之前，它允许一个或多个线程一直等待。 主要方法 public CountDownLatch(int count);//构造方法参数指定了计数的次数 public void countDown();//当前线程调用此方法，则计数减一1 public void await() throws InterruptedException//调用此方法会一直阻塞当前线程，直到计时器的值为0 列子：
public class CountDownLatchDemo { final static SimpleDateFormat sdf=new SimpleDateFormat(&#34;yyyy-MM-dd HH:mm:ss&#34;); public static void main(String[] args) throws InterruptedException { CountDownLatch latch=new CountDownLatch(2);//两个工人的协作 Worker worker1=new Worker(&#34;zhang san&#34;, 5000, latch); Worker worker2=new Worker(&#34;li si&#34;, 8000, latch); worker1.start();// worker2.start();// latch.await();//等待所有工人完成工作 System.out.println(&#34;all work done at &#34;&#43;sdf.format(new Date())); } static class Worker extends Thread{ String workerName; int workTime; CountDownLatch latch; public Worker(String workerName ,int workTime ,CountDownLatch latch){ this." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/8956f21caa74741e665929ec4a33096d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2017-03-28T21:25:07+08:00" />
<meta property="article:modified_time" content="2017-03-28T21:25:07+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java 阻塞线程用法</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><strong>CountDownLatch</strong></p> 
<p>首先先说明CountDownLatch辅助类</p> 
<p>CountDownLatch，一个同步辅助类，在完成一组正在其他线程中执行的操作之前，它允许一个或多个线程一直等待。 <br> 主要方法 <br> public CountDownLatch(int count);//构造方法参数指定了计数的次数 <br> public void countDown();//当前线程调用此方法，则计数减一1 <br> public void await() throws InterruptedException//调用此方法会一直阻塞当前线程，直到计时器的值为0 <br> 列子：</p> 
<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> CountDownLatchDemo {
    final <span class="hljs-keyword">static</span> SimpleDateFormat sdf=<span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">"yyyy-MM-dd HH:mm:ss"</span>);
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(String[] args) throws InterruptedException {
        CountDownLatch latch=<span class="hljs-keyword">new</span> CountDownLatch(<span class="hljs-number">2</span>);<span class="hljs-comment">//两个工人的协作</span>
        Worker worker1=<span class="hljs-keyword">new</span> Worker(<span class="hljs-string">"zhang san"</span>, <span class="hljs-number">5000</span>, latch);
        Worker worker2=<span class="hljs-keyword">new</span> Worker(<span class="hljs-string">"li si"</span>, <span class="hljs-number">8000</span>, latch);
        worker1.start();<span class="hljs-comment">//</span>
        worker2.start();<span class="hljs-comment">//</span>
        latch.<span class="hljs-keyword">await</span>();<span class="hljs-comment">//等待所有工人完成工作</span>
        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"all work done at "</span>+sdf.format(<span class="hljs-keyword">new</span> Date()));
    }


    <span class="hljs-keyword">static</span> class Worker extends Thread{
        String workerName; 
        <span class="hljs-keyword">int</span> workTime;
        CountDownLatch latch;
        <span class="hljs-keyword">public</span> <span class="hljs-title">Worker</span>(String workerName ,<span class="hljs-keyword">int</span> workTime ,CountDownLatch latch){
             <span class="hljs-keyword">this</span>.workerName=workerName;
             <span class="hljs-keyword">this</span>.workTime=workTime;
             <span class="hljs-keyword">this</span>.latch=latch;
        }
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span>(){
            System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"Worker "</span>+workerName+<span class="hljs-string">" do work begin at "</span>+sdf.format(<span class="hljs-keyword">new</span> Date()));
            doWork();<span class="hljs-comment">//工作了</span>
            System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"Worker "</span>+workerName+<span class="hljs-string">" do work complete at "</span>+sdf.format(<span class="hljs-keyword">new</span> Date()));
            latch.countDown();<span class="hljs-comment">//工人完成工作，计数器减一</span>

        }

        <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doWork</span>(){
            <span class="hljs-keyword">try</span> {
                Thread.sleep(workTime);
            } <span class="hljs-keyword">catch</span> (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }


}


输出：
Worker zhang san <span class="hljs-keyword">do</span> work begin at <span class="hljs-number">2011</span>-<span class="hljs-number">04</span>-<span class="hljs-number">14</span> <span class="hljs-number">11</span>:<span class="hljs-number">05</span>:<span class="hljs-number">11</span>
Worker li si <span class="hljs-keyword">do</span> work begin at <span class="hljs-number">2011</span>-<span class="hljs-number">04</span>-<span class="hljs-number">14</span> <span class="hljs-number">11</span>:<span class="hljs-number">05</span>:<span class="hljs-number">11</span>
Worker zhang san <span class="hljs-keyword">do</span> work complete at <span class="hljs-number">2011</span>-<span class="hljs-number">04</span>-<span class="hljs-number">14</span> <span class="hljs-number">11</span>:<span class="hljs-number">05</span>:<span class="hljs-number">16</span>
Worker li si <span class="hljs-keyword">do</span> work complete at <span class="hljs-number">2011</span>-<span class="hljs-number">04</span>-<span class="hljs-number">14</span> <span class="hljs-number">11</span>:<span class="hljs-number">05</span>:<span class="hljs-number">19</span>
all work done at <span class="hljs-number">2011</span>-<span class="hljs-number">04</span>-<span class="hljs-number">14</span> <span class="hljs-number">11</span>:<span class="hljs-number">05</span>:<span class="hljs-number">19</span></code></pre> 
<p><strong>并发队列ConcurrentLinkedQueue和阻塞队列LinkedBlockingQueue用法</strong></p> 
<p>在Java多线程应用中，队列的使用率很高，多数生产消费模型的首选数据结构就是队列(先进先出)。Java提供的线程安全的Queue可以分为阻塞队列和非阻塞队列，其中阻塞队列的典型例子是BlockingQueue，非阻塞队列的典型例子是ConcurrentLinkedQueue，在实际应用中要根据实际需要选用阻塞队列或者非阻塞队列。</p> 
<p>注：什么叫线程安全？这个首先要明确。线程安全就是说多线程访问同一代码，不会产生不确定的结果。</p> 
<p>并行和并发区别</p> 
<p>1、并行是指两者同时执行一件事，比如赛跑，两个人都在不停的往前跑； <br> 2、并发是指资源有限的情况下，两者交替轮流使用资源，比如一段路(单核CPU资源)同时只能过一个人，A走一段后，让给B，B用完继续给A ，交替使用，目的是提高效率</p> 
<p>LinkedBlockingQueue <br> 由于LinkedBlockingQueue实现是线程安全的，实现了先进先出等特性，是作为生产者消费者的首选，LinkedBlockingQueue 可以指定容量，也可以不指定，不指定的话，默认最大是Integer.MAX_VALUE，其中主要用到put和take方法，put方法在队列满的时候会阻塞直到有队列成员被消费，take方法在队列空的时候会阻塞，直到有队列成员被放进来。</p> 
<pre class="prettyprint"><code class=" hljs java"><span class="hljs-keyword">package</span> cn.thread;

<span class="hljs-keyword">import</span> java.util.concurrent.BlockingQueue;
<span class="hljs-keyword">import</span> java.util.concurrent.ExecutorService;
<span class="hljs-keyword">import</span> java.util.concurrent.Executors;
<span class="hljs-keyword">import</span> java.util.concurrent.LinkedBlockingQueue;

<span class="hljs-javadoc">/**
 * 多线程模拟实现生产者／消费者模型
 *  
 *<span class="hljs-javadoctag"> @author</span> 林计钦
 *<span class="hljs-javadoctag"> @version</span> 1.0 2013-7-25 下午05:23:11
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BlockingQueueTest2</span> {<!-- --></span>
    <span class="hljs-javadoc">/**
     * 
     * 定义装苹果的篮子
     * 
     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Basket</span> {<!-- --></span>
        <span class="hljs-comment">// 篮子，能够容纳3个苹果</span>
        BlockingQueue&lt;String&gt; basket = <span class="hljs-keyword">new</span> LinkedBlockingQueue&lt;String&gt;(<span class="hljs-number">3</span>);

        <span class="hljs-comment">// 生产苹果，放入篮子</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">produce</span>() <span class="hljs-keyword">throws</span> InterruptedException {
            <span class="hljs-comment">// put方法放入一个苹果，若basket满了，等到basket有位置</span>
            basket.put(<span class="hljs-string">"An apple"</span>);
        }

        <span class="hljs-comment">// 消费苹果，从篮子中取走</span>
        <span class="hljs-keyword">public</span> String <span class="hljs-title">consume</span>() <span class="hljs-keyword">throws</span> InterruptedException {
            <span class="hljs-comment">// take方法取出一个苹果，若basket为空，等到basket有苹果为止(获取并移除此队列的头部)</span>
            <span class="hljs-keyword">return</span> basket.take();
        }
    }

    <span class="hljs-comment">// 定义苹果生产者</span>
    class Producer implements Runnable {
        <span class="hljs-keyword">private</span> String instance;
        <span class="hljs-keyword">private</span> Basket basket;

        <span class="hljs-keyword">public</span> <span class="hljs-title">Producer</span>(String instance, Basket basket) {
            <span class="hljs-keyword">this</span>.instance = instance;
            <span class="hljs-keyword">this</span>.basket = basket;
        }

        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span>() {
            <span class="hljs-keyword">try</span> {
                <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) {
                    <span class="hljs-comment">// 生产苹果</span>
                    System.out.println(<span class="hljs-string">"生产者准备生产苹果："</span> + instance);
                    basket.produce();
                    System.out.println(<span class="hljs-string">"!生产者生产苹果完毕："</span> + instance);
                    <span class="hljs-comment">// 休眠300ms</span>
                    Thread.sleep(<span class="hljs-number">300</span>);
                }
            } <span class="hljs-keyword">catch</span> (InterruptedException ex) {
                System.out.println(<span class="hljs-string">"Producer Interrupted"</span>);
            }
        }
    }

    <span class="hljs-comment">// 定义苹果消费者</span>
    class Consumer implements Runnable {
        <span class="hljs-keyword">private</span> String instance;
        <span class="hljs-keyword">private</span> Basket basket;

        <span class="hljs-keyword">public</span> <span class="hljs-title">Consumer</span>(String instance, Basket basket) {
            <span class="hljs-keyword">this</span>.instance = instance;
            <span class="hljs-keyword">this</span>.basket = basket;
        }

        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span>() {
            <span class="hljs-keyword">try</span> {
                <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) {
                    <span class="hljs-comment">// 消费苹果</span>
                    System.out.println(<span class="hljs-string">"消费者准备消费苹果："</span> + instance);
                    System.out.println(basket.consume());
                    System.out.println(<span class="hljs-string">"!消费者消费苹果完毕："</span> + instance);
                    <span class="hljs-comment">// 休眠1000ms</span>
                    Thread.sleep(<span class="hljs-number">1000</span>);
                }
            } <span class="hljs-keyword">catch</span> (InterruptedException ex) {
                System.out.println(<span class="hljs-string">"Consumer Interrupted"</span>);
            }
        }
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(String[] args) {
        BlockingQueueTest2 test = <span class="hljs-keyword">new</span> BlockingQueueTest2();

        <span class="hljs-comment">// 建立一个装苹果的篮子</span>
        Basket basket = test.<span class="hljs-keyword">new</span> Basket();

        ExecutorService service = Executors.newCachedThreadPool();
        Producer producer = test.<span class="hljs-keyword">new</span> Producer(<span class="hljs-string">"生产者001"</span>, basket);
        Producer producer2 = test.<span class="hljs-keyword">new</span> Producer(<span class="hljs-string">"生产者002"</span>, basket);
        Consumer consumer = test.<span class="hljs-keyword">new</span> Consumer(<span class="hljs-string">"消费者001"</span>, basket);
        service.submit(producer);
        service.submit(producer2);
        service.submit(consumer);
        <span class="hljs-comment">// 程序运行5s后，所有任务停止</span>
<span class="hljs-comment">//        try {<!-- --></span>
<span class="hljs-comment">//            Thread.sleep(1000 * 5);</span>
<span class="hljs-comment">//        } catch (InterruptedException e) {<!-- --></span>
<span class="hljs-comment">//            e.printStackTrace();</span>
<span class="hljs-comment">//        }</span>
<span class="hljs-comment">//        service.shutdownNow();</span>
    }

}</code></pre> 
<p>ConcurrentLinkedQueue <br> ConcurrentLinkedQueue是Queue的一个安全实现．Queue中元素按FIFO原则进行排序．采用CAS操作，来保证元素的一致性。 <br> LinkedBlockingQueue是一个线程安全的阻塞队列，它实现了BlockingQueue接口，BlockingQueue接口继承自java.util.Queue接口，并在这个接口的基础上增加了take和put方法，这两个方法正是队列操作的阻塞版本。</p> 
<pre class="prettyprint"><code class=" hljs java"><span class="hljs-keyword">package</span> cn.thread;

<span class="hljs-keyword">import</span> java.util.concurrent.ConcurrentLinkedQueue;
<span class="hljs-keyword">import</span> java.util.concurrent.CountDownLatch;
<span class="hljs-keyword">import</span> java.util.concurrent.ExecutorService;
<span class="hljs-keyword">import</span> java.util.concurrent.Executors;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcurrentLinkedQueueTest</span> {<!-- --></span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ConcurrentLinkedQueue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> ConcurrentLinkedQueue&lt;Integer&gt;();
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> count = <span class="hljs-number">2</span>; <span class="hljs-comment">// 线程个数</span>
    <span class="hljs-comment">//CountDownLatch，一个同步辅助类，在完成一组正在其他线程中执行的操作之前，它允许一个或多个线程一直等待。</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> CountDownLatch latch = <span class="hljs-keyword">new</span> CountDownLatch(count);

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(String[] args) <span class="hljs-keyword">throws</span> InterruptedException {
        <span class="hljs-keyword">long</span> timeStart = System.currentTimeMillis();
        ExecutorService es = Executors.newFixedThreadPool(<span class="hljs-number">4</span>);
        ConcurrentLinkedQueueTest.offer();
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; count; i++) {
            es.submit(<span class="hljs-keyword">new</span> Poll());
        }
        latch.await(); <span class="hljs-comment">//使得主线程(main)阻塞直到latch.countDown()为零才继续执行</span>
        System.out.println(<span class="hljs-string">"cost time "</span> + (System.currentTimeMillis() - timeStart) + <span class="hljs-string">"ms"</span>);
        es.shutdown();
    }

    <span class="hljs-javadoc">/**
     * 生产
     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">offer</span>() {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100000</span>; i++) {
            queue.offer(i);
        }
    }


    <span class="hljs-javadoc">/**
     * 消费
     *  
     *<span class="hljs-javadoctag"> @author</span> 林计钦
     *<span class="hljs-javadoctag"> @version</span> 1.0 2013-7-25 下午05:32:56
     */</span>
    <span class="hljs-keyword">static</span> class Poll implements Runnable {
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span>() {
            <span class="hljs-comment">// while (queue.size()&gt;0) {<!-- --></span>
            <span class="hljs-keyword">while</span> (!queue.isEmpty()) {
                System.out.println(queue.poll());
            }
            latch.countDown();
        }
    }
}</code></pre> 
<p>运行结果： <br> costtime 2360ms</p> 
<p>改用while (queue.size()&gt;0)后 <br> 运行结果： <br> cost time 46422ms</p> 
<p>结果居然相差那么大，看了下ConcurrentLinkedQueue的API原来.size()是要遍历一遍集合的，难怪那么慢，所以尽量要避免用size而改用isEmpty().</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/72c38df4cf2c1488007062ccf5245eee/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">android HierarchyViewer查看视图层级关系</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d0b6692d9bdc070d42df0f4b564f5a69/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Spring&#43;SpringMVC&#43;MyBatis&#43;easyUI整合优化篇（一）Java语言中System.out.print与Log的比较</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>