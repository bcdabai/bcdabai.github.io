<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>HTTP 响应行 成功类型响应码 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="HTTP 响应行 成功类型响应码" />
<meta property="og:description" content="返回结果的 HTTP 状态码 HTTP 状态码负责表示客户端 HTTP 请求的返回结果、标记服务器端的处理是否正常、通知出现的错误等工作。让我们通过学习，好好了解一下状态码的工作机制。
状态码告知从服务器端返回的请求结果 状态码的职责是当客户端向服务器端发送请求时，描述返回的请求结果。借助状态码，用户可以知道服务器端是正常处理了请求，还是出现了错误。
图：响应的状态码可描述请求的处理结果
状态码如 200 OK，以 3 位数字和原因短语组成。
数字中的第一位指定了响应类别，后两位无分类。响应类别有以下 5 种。
表 4-1：状态码的类别 类别原因短语
1XXInformational（信息性状态码）接收的请求正在处理2XXSuccess（成功状态码）请求正常处理完毕3XXRedirection（重定向状态码）需要进行附加操作以完成请求 4XXClient Error（客户端错误状态码）服务器无法处理请求5XXServer Error（服务器错误状态码）服务器处理请求出错 只要遵守状态码类别的定义，即使改变 RFC2616 中定义的状态码，或服务器端自行创建状态码都没问题。
仅记录在 RFC2616 上的 HTTP 状态码就达 40 种，若再加上 WebDAV（Web-based Distributed Authoring and Versioning，基于万维网的分布式创作和版本控制）（RFC4918、5842） 和附加 HTTP 状态码（RFC6585）等扩展，数量就达 60 余种。别看种类繁多，实际上经常使用的大概只有 14 种。接下来，我们就介绍一下这些具有代表性的 14 个状态码。 2XX 成功 2XX 的响应结果表明请求被正常处理了。
200 OK
表示从客户端发来的请求在服务器端被正常处理了。
在响应报文内，随状态码一起返回的信息会因方法的不同而发生改变。比如，使用 GET 方法时，对应请求资源的实体会作为响应返回；而使用 HEAD 方法时，对应请求资源的实体首部不随报文主体作为响应返回（即在响应中只返回首部，不会返回实体的主体部分）。
204 No Content
该状态码代表服务器接收的请求已成功处理，但在返回的响应报文中不含实体的主体部分。另外，也不允许返回任何实体的主体。比如，当从浏览器发出请求处理后，返回 204 响应，那么浏览器显示的页面不发生更新。
一般在只需要从客户端往服务器发送信息，而对客户端不需要发送新信息内容的情况下使用
curl --location --request POST &#39;http://121." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/b4fb6bf107e834164dfc2465a78a6d4b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-01-28T10:00:48+08:00" />
<meta property="article:modified_time" content="2023-01-28T10:00:48+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">HTTP 响应行 成功类型响应码</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>返回结果的 HTTP 状态码</h3> 
<hr> 
<h4></h4> 
<p>HTTP 状态码负责表示客户端 HTTP 请求的返回结果、<span style="background-color:#a2e043;">标记服务器端的处理是否正常、通知出现的错误等工作</span>。让我们通过学习，好好了解一下状态码的工作机制。<br>  </p> 
<p></p> 
<p></p> 
<h3>状态码告知从服务器端返回的请求结果</h3> 
<hr> 
<p>状态码的职责是当客户端向服务器端发送请求时，<span style="background-color:#956fe7;">描述返回的请求结果</span>。<span style="background-color:#fe2c24;">借助状态码，用户可以知道服务器端是正常处理了请求，还是出现了错误。</span></p> 
<p class="img-center"><img alt="" height="303" src="https://images2.imgbox.com/33/11/Mpgw2jVk_o.png" width="575"></p> 
<p>                                         <strong> 图：响应的状态码可描述请求的处理结果</strong></p> 
<p>状态码如 200 OK，以 3 位数字和原因短语组成。</p> 
<p>数字中的第一位指定了响应类别，后两位无分类。响应类别有以下 5 种。</p> 
<p>表 4-1：状态码的类别  类别原因短语</p> 
<ul><li>1XXInformational（信息性状态码）接收的请求正在处理</li><li>2XXSuccess（成功状态码）请求正常处理完毕</li><li>3XXRedirection（重定向状态码）<span style="background-color:#38d8f0;">需要进行附加操作以完成请求 </span></li><li>4XXClient Error（客户端错误状态码）服务器无法处理请求</li><li>5XXServer Error（服务器错误状态码）服务器处理请求出错</li></ul> 
<p>只要遵守状态码类别的定义，即使改变 RFC2616 中定义的状态码，或服务器端自行创建状态码都没问题。</p> 
<p>仅记录在 RFC2616 上的 HTTP 状态码就达 40 种，若再加上 WebDAV（Web-based Distributed Authoring and Versioning，基于万维网的分布式创作和版本控制）（RFC4918、5842） 和附加 HTTP 状态码（RFC6585）等扩展，数量就达 60 余种。别看种类繁多，<span style="background-color:#ffd900;">实际上经常使用的大概只有 14 种。</span>接下来，我们就介绍一下这些具有代表性的 14 个状态码。  </p> 
<p></p> 
<p></p> 
<p></p> 
<h3>2XX 成功</h3> 
<hr> 
<p>2XX 的响应结果表明请求被正常处理了。</p> 
<p><strong>200 OK</strong></p> 
<p class="img-center"><img alt="" height="189" src="https://images2.imgbox.com/93/4e/zCCG8j1e_o.png" width="550"></p> 
<p>表示从客户端发来的请求在服务器端被正常处理了。</p> 
<p>在响应报文内，<span style="background-color:#956fe7;">随状态码一起返回的信息会因方法的不同而发生改变</span>。<span style="background-color:#fe2c24;">比如，使用 GET 方法时，对应请求资源的实体会作为响应返回</span>；<span style="background-color:#fe2c24;">而使用 HEAD 方法时，对应请求资源的实体首部不随报文主体作为响应返回</span>（<span style="background-color:#fe2c24;">即在响应中只返回首部，不会返回实体的主体部分</span>）。</p> 
<p class="img-center"><img alt="" height="1031" src="https://images2.imgbox.com/d0/c6/MKMRQL8G_o.png" width="1200"></p> 
<p class="img-center"><img alt="" height="1031" src="https://images2.imgbox.com/93/93/DQnYAiO5_o.png" width="1200"></p> 
<p> <strong>204 No Content</strong></p> 
<p class="img-center"><img alt="" height="215" src="https://images2.imgbox.com/9f/4e/Ed5otjcd_o.png" width="514"></p> 
<p>该状态码代表服务器接收的请求已成功处理，<span style="background-color:#a2e043;">但在返回的响应报文中不含实体的主体部分。另外，也不允许返回任何实体的主体。</span>比如，当从浏览器发出请求处理后，<span style="background-color:#956fe7;">返回 204 响应，那么浏览器显示的页面不发生更新。</span></p> 
<p>一般在只需要从客户端往服务器发送信息，而对客户端不需要发送新信息内容的情况下使用</p> 
<p class="img-center"><img alt="" height="1031" src="https://images2.imgbox.com/1e/c1/J1wPtaWb_o.png" width="1200"></p> 
<p class="img-center"><img alt="" height="1031" src="https://images2.imgbox.com/0d/43/MAWaZkrT_o.png" width="1200"></p> 
<pre><code>curl --location --request POST 'http://121.40.102.116:9000/api/qualityprofiles/add_project?language=java&amp;qualityProfile=myjava&amp;project=test1' \
--header 'Authorization: Basic YWRtaW46MTIzNDU2'</code></pre> 
<p class="img-center"><img alt="" height="866" src="https://images2.imgbox.com/6e/b1/fIthIacG_o.png" width="1200"></p> 
<p><img alt="" src="https://images2.imgbox.com/3a/63/1YPwbXpc_o.png"><strong>206 Partial Content</strong></p> 
<p class="img-center"><img alt="" height="196" src="https://images2.imgbox.com/49/ea/vLa45HF2_o.png" width="536"></p> 
<p>该状态码表示客户端进行了范围请求，而服务器成功执行了这部分的 GET 请求。响应报文中包含<span style="background-color:#4da8ee;">由 Content-Range 指定范围的实体内容。 </span> </p> 
<p></p> 
<p></p> 
<p></p> 
<h3>3XX 重定向</h3> 
<hr> 
<p>3XX 响应结果表明浏览器需要执行某些特殊的处理以正确处理请求。</p> 
<p><strong>301 Moved Permanently</strong></p> 
<p class="img-center"><img alt="" height="194" src="https://images2.imgbox.com/58/d6/j7kfQ1gz_o.png" width="541"></p> 
<p>永久性重定向。该状态码表示请求的资源已被分配了新的 URI，<span style="background-color:#38d8f0;">以后应使用资源现在所指的URI。</span>也就是说，如果已经把资源对应的 URI 保存为书签了，这时应该按 Location 首部字段提示的 URI 重新保存。</p> 
<p>像下方给出的请求 URI，当指定资源路径的最后忘记添加斜杠“/”，就会产生 301 状态码。<br> http://example.com/sample</p> 
<p><strong>302 Found</strong></p> 
<p class="img-center"><img alt="" height="240" src="https://images2.imgbox.com/2a/dc/PkUXSUZ5_o.png" width="538"></p> 
<p><span style="background-color:#956fe7;">临时性重定向。该状态码表示请求的资源已被分配了新的 URI，希望用户（本次）能使用新的 URI 访问。</span></p> 
<p>和 301 Moved Permanently 状态码相似，但 302 状态码代表的资源不是被永久移动，只是临时性质的。换句话说，已移动的资源对应的 URI 将来还有可能发生改变。比如，用户把 URI 保存成书签，<span style="background-color:#a2e043;">但不会像 301 状态码出现时那样去更新书签，而是仍旧保留返回 302 状态码的页面对应的 URI。</span></p> 
<p><strong>303 See Other</strong><br><img alt="" height="275" src="https://images2.imgbox.com/d9/da/zoDcp9d7_o.png" width="587"></p> 
<p>该状态码表示由于请求对应的资源存在着另一个 URI，应使用 GET 方法定向获取请求的资源。<br> 303 状态码和 302 Found 状态码有着相同的功能，但 303 状态码明确表示客户端应当采用 GET 方法获取资源，这点与 302 状态码有区别。</p> 
<p>比如，当使用 POST 方法访问 CGI 程序，其执行后的处理结果是希望客户端能以 GET 方法重定向到另一个 URI 上去时，返回 303 状态码。虽然 302 Found 状态码也可以实现相同的功能，但这里使用 303 状态码是最理想的。</p> 
<p>本书采用的是 HTTP/1.1，而许多 HTTP/1.1 版以前的浏览器不能正确理解 303 状态码。虽然 RFC 1945 和 RFC 2068 规范不允许客户端在重定向时改变请求的方法，但是很多现存的浏览器将 302 响应视为 303 响应，并且使用 GET 方式访问在 Location 中规定的 URI，而无视原先请求的方法。所以作者说这里使用 303 是最理想的。</p> 
<p>——译者注<br> 当 301、302、303 响应状态码返回时，几乎所有的浏览器都会把 POST 改成 GET，并删除请求报文内的主体，之后请求会自动再次发送。<br> 301、302 标准是禁止将 POST 方法改变成 GET 方法的，但实际使用时大家都会这么做。</p> 
<p><strong>307 Temporary Redirect</strong><br> 临时重定向。该状态码与 302 Found 有着相同的含义。尽管 302 标准禁止 POST 变换成 GET，但实际使用时大家并不遵守。</p> 
<p>307 会遵照浏览器标准，不会从 POST 变成 GET。但是，对于处理响应时的行为，每种浏览器有可能出现不同的情况。</p> 
<p></p> 
<p>前面介绍了请求行的格式，这里将介绍HTTP响应当中的第一个组成部分，响应行。</p> 
<p>响应行中的<span style="background-color:#ff9900;">响应码分为两类，一种是100，200，300系列表示成功类型的响应码，还有400和500类型错误的响应码。</span></p> 
<p></p> 
<p></p> 
<p></p> 
<h3>HTTP常见的错误码</h3> 
<hr> 
<ul><li id="a946b504b58c0c4c9de27eee06b123e1">1xx : 服务已收到请求，请求者继续执行操作。</li><li id="7396440ec1793d78da5ed79a2b4401f9"><strong>2xx：请求成功，常见（201）</strong></li><li>3xx：请求成功，页面发生重定向（301）</li></ul> 
<p></p> 
<p></p> 
<h3>HTTP响应行</h3> 
<hr> 
<p class="img-center"><img alt="" height="670" src="https://images2.imgbox.com/a3/d6/CUNfwDW6_o.png" width="1003"></p> 
<p>图中第一部分就是响应行， 上面是完整的HTTP响应，第一行就是我们的响应行。</p> 
<p>在响应行，第一部分是HTTP协议版本，接下来是响应码和描述信息。</p> 
<p></p> 
<p></p> 
<p></p> 
<h3><span style="color:#2f5597;">响应码分类：1xx  请求已收到，需要进一步处理</span></h3> 
<hr> 
<p class="img-center"><img alt="" height="473" src="https://images2.imgbox.com/ad/2d/ZppnVU9B_o.png" width="1178"></p> 
<p>响应码定义了许多的规范，这些规范可以指导我们的服务器去设计，但并不是所有的都遵循响应码中的规范，有些服务器可以定义新的响应码不在这些规范当中的。</p> 
<p>1xx系列，<span style="background-color:#a2e043;">表示请求被服务器接收到了，但是服务器需要做进一步的处理才能完成这个操作。</span></p> 
<p>100 continue：<span style="background-color:#ff9900;">客户端在上传一个大的文件的时候，先告诉服务器，让服务器做好准备，比如常见的迅雷下载工具。</span><span style="color:#000000;">由客户端发起请求中携带 Expect: 100-continue 头部触发，服务器回100 continue表示可以传递大文件了。</span></p> 
<div> 
 <span style="color:#000000;">101 Switch Protocols：协议升级使用，要保证HTTP 1.1协议广为使用，客户端支持更高的协议如websocket或者HTTP 2.0的时候，会在请求当中加上upgrade的头部，表示希望升级到websocket或者HTTP 2.0协议，如果服务器支持，那么返回101 Switch Protocols。</span> 
</div> 
<div></div> 
<div> 
 <span style="color:#000000;">102 Processing：返回102 processing可以告诉客户端，<span style="background-color:#4da8ee;">服务器已经收到了，但是这个请求需要很长时间才能完成</span></span> 
</div> 
<p></p> 
<p></p> 
<p></p> 
<h3><span style="color:#2f5597;">响应码分类： 2xx（一） </span></h3> 
<hr> 
<p class="img-center"><img alt="" height="448" src="https://images2.imgbox.com/e0/7b/a28mQMxq_o.png" width="1026"></p> 
<p>2xx表示成功处理的请求。</p> 
<div> 
 <span style="color:#000000;">201 Created: 有新资源在服务器端被成功创建。<span style="background-color:#ff9900;">通常是我们创建了一个新的文件，比如使用put方法上传了文件，返回201表示资源在服务器端创建了。</span></span> 
</div> 
<div></div> 
<div> 
 <span style="color:#000000;">202 Accepted:<span style="background-color:#38d8f0;">异步和有些请求需要很长时间的处理，先给客户端返回202 Accepted，由异步的任务继续去处理这个任务。</span></span> 
</div> 
<div></div> 
<p></p> 
<p></p> 
<p></p> 
<div> 
 <h3><span style="color:#2f5597;">响应码分类： 2xx（二）</span></h3> 
 <hr> 
 <p><span style="color:#000000;">• 204 No Content：成功执行了请求且不携带响应包体，并暗示客户端无需更新当前的页面视图。（常见于put post等方法，上传了一些资源，但是返回告诉其不需要刷新ui等）</span></p> 
</div> 
<div></div> 
<div> 
 <span style="color:#000000;">• </span> 
 <span style="color:#000000;">205 Reset Content：成功执行了请求且不携带响应包体，同时指明客户端需要更新当前页面视图。 </span> 
</div> 
<div></div> 
<div> 
 <span style="color:#000000;"><span style="background-color:#ffd900;">• </span></span> 
 <span style="color:#000000;"><span style="background-color:#ffd900;">206 Partial Content：使用 range 协议时返回部分响应内容时的响应码（断点续传都会使用range协议，只返回一部分内容的时候就会返回206响应码）</span></span> 
</div> 
<div></div> 
<div> 
 <span style="color:#000000;">• </span> 
 <span style="color:#000000;">207 Multi-Status：RFC4918 ，在 WEBDAV 协议中以 XML 返回多个资源 </span> 
</div> 
<div> 
 <span style="color:#000000;">的状态。 </span> 
</div> 
<div></div> 
<div> 
 <span style="color:#000000;">• </span> 
 <span style="color:#000000;">208 Already Reported：RFC5842 ，为避免相同集合下资源在207响应码下重复上报，使用 208 可以使用父集合的响应码。</span> 
</div> 
<p></p> 
<p></p> 
<p></p> 
<div> 
 <h3><span style="color:#2f5597;">响应码分类： 3xx（一）</span></h3> 
 <hr> 
 <p><span style="color:#000000;">• 3xx：<span style="background-color:#a2e043;">重定向使用 Location 指向的资源或者缓存中的资源</span>。在 RFC2068中规定客户端重定向次数不应超过 5 次，以防止死循环。 </span></p> 
 <p><span style="color:#000000;">• 300 Multiple Choices：资源有多种表述，通过 300 返回给客户端后由其自行选择访问哪一种表述。由于缺乏明确的细节，300 很少使用。 </span></p> 
 <p><span style="color:#000000;"><span style="background-color:#ff9900;">• 301 Moved Permanently：资源永久性的重定向到另一个 URI 中。（使得浏览器对永久的重定向直接缓存）</span></span></p> 
</div> 
<div></div> 
<div> 
 <span style="color:#000000;">• 302 Found：资源临时的重定向到另一个 URI 中。</span> 
</div> 
<div></div> 
<div> 
 <span style="color:#000000;">• 303 See Other：重定向到其他资源，常用于 POST/PUT 等方法的响应中。 </span> 
</div> 
<p></p> 
<p><span style="color:#000000;">• 304 Not Modified：当客户端拥有可能过期的缓存时，会携带缓存的标识etag、时间等信息询问服务器缓存是否仍可复用，而304是告诉客户端可以复用缓存。（减少网络传输的数据量）</span></p> 
<div> 
 <span style="color:#000000;">• </span> 
 <span style="color:#000000;">307 Temporary Redirect：类似302，但明确重定向后请求方法必须与原请求方法相同，不得变。 </span> 
</div> 
<div></div> 
<div> 
 <span style="color:#000000;">• </span> 
 <span style="color:#000000;">308 Permanent Redirect：类似301，但明确重定向后请求方法必须与原请求方法相同，不得改变。</span> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/59fab23397d6c25769a2e4be2509fca6/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【漏洞复现】MS17-010漏洞（永恒之蓝）复现</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/faeb35b8b60fba1d31260cb03fd12e90/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">[多媒体] 关于H264的 profile 和 level</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>