<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>枚举类型:enum ,File路径 ,IO流 :字节流 字符流,文件拷贝 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="枚举类型:enum ,File路径 ,IO流 :字节流 字符流,文件拷贝" />
<meta property="og:description" content="枚举类型 : 描述一种事物的所有情况|所有可能|所有实例
1.通过enum关键字定义枚举类型
2.枚举的成员,字段都作为当前枚举类型的实例存在,默认被public static final修饰
3.定义的枚举类型都会隐式的继承自java.lang.Enum 这是所有Java语言枚举类型的公共基类。
4.在枚举类型中构造器默认私有
public class Class001_Enum { public static void main(String[] args) { System.out.println(WeekDays.SUN); //使用枚举类型的实例 WeekDays sun = WeekDays.SUN; System.out.println(sun.getName()); //name() 获取枚举类型实例的字段名 System.out.println(sun.name()); //获取枚举对象在枚举类的字段列表中的索引值 System.out.println(sun.ordinal()); //values() 获取当前枚举类型的所有实例 WeekDays[] arr = sun.values(); System.out.println(Arrays.toString(arr)); sun = WeekDays.MON; //switch()中jdk5新增对枚举的支持 switch (sun){ case MON: System.out.println(&#34;星期一&#34;); break; case TUES: System.out.println(&#34;星期二&#34;); break; case SUN: System.out.println(&#34;星期天&#34;); break; } } } //一周的中的天数 周1~周7 enum WeekDays{ //枚举字段|当前枚举类型的实例 MON,TUES,SUN(&#34;星期天&#34;); // public static final WeekDay MON = new WeekDay(); //成员变量 private String name; //构造器 private WeekDays(){} private WeekDays(String name){ this." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/41ca79a15ec61df94bd25045c86c7504/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-07-16T19:23:47+08:00" />
<meta property="article:modified_time" content="2021-07-16T19:23:47+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">枚举类型:enum ,File路径 ,IO流 :字节流 字符流,文件拷贝</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ff0000;">枚举类型 : 描述一种事物的所有情况|所有可能|所有实例</span><br><br>     1.通过enum关键字定义枚举类型<br>    <span style="color:#ff0000;"> 2.枚举的成员,字段都作为当前枚举类型的实例存在,默认被public static final修饰</span><br>     3.定义的枚举类型都会隐式的继承自java.lang.Enum 这是所有Java语言枚举类型的公共基类。<br>     4.在枚举类型中构造器默认私有</p> 
<pre>public class Class001_Enum {
    public static void main(String[] args) {
        System.out.println(WeekDays.SUN);

        //使用枚举类型的实例
        WeekDays sun = WeekDays.SUN;

        System.out.println(sun.getName());

        //name() 获取枚举类型实例的字段名
        System.out.println(sun.name());
        //获取枚举对象在枚举类的字段列表中的索引值
        System.out.println(sun.ordinal());

        //values() 获取当前枚举类型的所有实例
        WeekDays[] arr = sun.values();
        System.out.println(Arrays.toString(arr));

        sun = WeekDays.MON;
        //switch()中jdk5新增对枚举的支持
        switch (sun){
            case MON:
                System.out.println("星期一");
                break;
            case TUES:
                System.out.println("星期二");
                break;
            case SUN:
                System.out.println("星期天");
                break;
        }
    }
}

//一周的中的天数 周1~周7
enum WeekDays{
    //枚举字段|当前枚举类型的实例
    MON,TUES,SUN("星期天");
    // public static final WeekDay MON = new WeekDay();

    //成员变量
    private String name;

    //构造器
    private WeekDays(){}
    private WeekDays(String name){
        this.name = name;
    }

    //成员方法
    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}</pre> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">File 路径或者文件的抽象的表现形式<br> 注意:<br>     java中路径的分隔符可以使用: \\ / //</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<pre>public class Class001_File {
    public static void main(String[] args) throws IOException {
        <span style="color:#a2e043;">//File(String pathname) 通过将给定的路径名字符串转换为抽象路径名来创建新的 File实例。</span>
        File file1 = new File("D:\\test.txt");
        File file2 = new File("D:\\AAA");
        File file3 = new File("D:/");
        <span style="color:#a2e043;">//File(File parent, String child) 从父抽象路径名和子路径名字符串创建新的 File实例。</span>
        File file4 = new File(file3,"test.txt");

        <span style="color:#a2e043;">//File(String parent, String child) 从父路径名字符串和子路径名字符串创建新的 File实例。</span>
        File file5 = new File("D://AAA","BBB");

        File file6 = new File("D://haha.txt");

        System.out.println(file1);
        System.out.println(file2);
        System.out.println(file4);

        System.out.println(file1.equals(file4));
        System.out.println(file2.equals(file5));
        System.out.println(file5);

        <span style="color:#a2e043;">//常用方法
        //boolean canWrite() 测试应用程序是否可以修改此抽象路径名表示的文件。
        //boolean exists() 测试此抽象路径名表示的文件或目录是否存在。
        //boolean setReadOnly() 标记此抽象路径名指定的文件或目录，以便仅允许读取操作。</span>
        if(file1.exists()){
            System.out.println("只读状态设置: "+file1.setReadOnly());
            System.out.println("判断文件file1是否可以编写 "+file1.canWrite());
        }

        <span style="color:#a2e043;">//boolean createNewFile() 当且仅当具有此名称的文件尚不存在时，以原子方式创建由此抽象路径名命名的新空文件。</span>
        if(!file6.exists()){
            System.out.println(file6.createNewFile());
        }

       <span style="color:#a2e043;"> //boolean </span><span style="color:#fe2c24;">delete() 删除</span><span style="color:#a2e043;">此抽象路径名表示的文件或目录。  空文件夹才可以删除</span>
        System.out.println(file6.delete());
        System.out.println(file2.delete());

        <span style="color:#a2e043;">//File getAbsoluteFile() 返回此抽象路径名的绝对形式。
        //String getAbsolutePath() 返回此抽象路径名的绝对路径名字符串。</span>
        System.out.println(file1.getAbsolutePath());
        System.out.println(file1.getAbsoluteFile());

        //默认相对于当前项目下
        File file = new File("test.txt");
        System.out.println(file);
        System.out.println(file.getAbsolutePath()); 
        System.out.println(file.getAbsoluteFile());

        <span style="color:#a2e043;">//long getFreeSpace() 通过此抽象路径名返回分区 named中未分配的字节数。</span>
        System.out.println(file3.getFreeSpace());
        <span style="color:#a2e043;">//long getTotalSpace() 通过此抽象路径名返回分区 named的大小。</span>

        <span style="color:#a2e043;">//String getName() 返回此抽象路径名表示的文件或目录的名称。</span>
        System.out.println(file1.getName());
        System.out.println(file5.getName());

       <span style="color:#a2e043;"> //String getParent() 返回此抽象路径名父项的路径名字符串，如果此路径名未指定父目录，则返回 null 。
        //File getParentFile() 返回此抽象路径名父项的抽象路径名，如果此路径名未指定父目录，则返回 null 。</span>
        System.out.println(file1.getParent());
        System.out.println(file1.getParentFile());
        System.out.println(file5.getParent());
        System.out.println(file5.getParentFile());

        /*
       <span style="color:#a2e043;"> boolean isAbsolute() 测试此抽象路径名是否为绝对路径。
        boolean isDirectory() 测试此抽象路径名表示的文件是否为目录。
        boolean isFile() 测试此抽象路径名表示的文件是否为普通文件。</span>
         */
        System.out.println(file1.isFile());
        System.out.println(file1.isDirectory());
        System.out.println(file1.isAbsolute());

       <span style="color:#a2e043;"> //long lastModified() 返回上次修改此抽象路径名表示的文件的时间。</span>
        System.out.println(file1.lastModified());
        System.out.println(new SimpleDateFormat("yyyy/MM/dd HH:mm:ss").format(new Date(file1.lastModified())));

       <span style="color:#a2e043;"> //long length() 返回此抽象路径名表示的文件的长度。</span>
        System.out.println(file1.length());

        <span style="color:#a2e043;">//String[] list() 返回一个字符串数组，用于命名此抽象路径名表示的目录中的文件和目录。
        //File[] listFiles() 返回一个抽象路径名数组，表示此抽象路径名表示的目录中的文件。</span>
        File src = new File("D://DDD");
        System.out.println(Arrays.toString(src.list()));
        File[] files = src.listFiles();
        for(File f:files){
            System.out.println(f);
        }

        File file8 = new File("D://haha");
        File file9 = new File("D://hehe/heihei/hengheng.txt");
        <span style="color:#a2e043;">//boole9n mkdir() 创建此抽象路径名指定的目录。   </span><span style="color:#fe2c24;">一层</span>
        System.out.println(file8.mkdir());
       <span style="color:#a2e043;"> //boolean mkdirs() 创建此抽象路径名指定的目录，包括任何必需但不存在的父目录。</span>   <span style="color:#fe2c24;">多层</span>
        System.out.println(file9.getParentFile().mkdirs());

       <span style="color:#a2e043;"> //boolean renameTo(File dest) 重命名此抽象路径名表示的文件。</span>
        File file10 = new File("D://test2.txt");
        System.out.println(file1.renameTo(file10));
    }
}
</pre> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">前提需求: <span style="color:#fe2c24;">读写文件内部的内容,上传,下载</span><br><span style="color:#fe2c24;">IO流<br>     流: 管道  数据以先入先出的方式进行流动<br><br> 数据源--数据--&gt;目的地</span><br><br> io包: 一系列io相关类  File...<br><br><span style="color:#fe2c24;">流的分类:</span><br>     <span style="color:#fe2c24;">按照流向分:<br>         输入流<br>         输出流<br>         (以大脑为中心,以程序为中心,明确数据源和目的地,能够确定输入还是输出)<br>     按照操作单元分;<br>         字节流 : 万能流,任意内容都能转为字节<br>         字符流 : 只能传输纯文本的内容<br>     按照功能分:<br>         节点流 : 真实做读入写出的流<br>         功能流 : 增强节点流的功能,加强性能</span><br><br>    <span style="color:#ffd900;"> 分类之间是相辅相成的</span><br><br>  字节流:<br>     <span style="color:#a2e043;">字节输入流 InputStream<br>         文件字节输入流 FileInputStream</span><br>             功能: 节点流    流向分:输入流     操作单元:字节流<br>             功能: 读入read()   关闭close</p> 
<pre>//FileInputStream(File file) 通过打开与实际文件的连接来创建 FileInputStream ，该文件由文件系统中的 File对象 file命名。
File src = new File("D://test2.txt"); //数据源
//创建流
InputStream is = new FileInputStream(src);
//读入数据 int read() 从此输入流中读取一个字节的数据。  读到文件末尾返回-1
int num = is.read();
//处理数据
System.out.println((char)num);
System.out.println((char)(is.read()));
System.out.println((char)(is.read()));
System.out.println(is.read());
//关闭流
is.close();
</pre> 
<p style="margin-left:.0001pt;text-align:justify;">  </p> 
<p style="margin-left:.0001pt;text-align:justify;">  <span style="color:#ff0000;">read() 从此输入流中读取一个字节的数据。  读到文件末尾返回-1</span><br><span style="color:#ff0000;">   每次读取一个字节,重复通过循环读入,可以简化代码结构</span><br>  */<br> public class Class002_IO {<!-- --><br>     public static void main(String[] args) throws IOException {<!-- --><br>         //创建流<br>         //FileInputStream (String name) 通过打开与实际文件的连接来创建 FileInputStream ，该文件由文件系统中的路径名 name命名。<br>         InputStream is = new FileInputStream("D://test2.txt");<br>         //读入数据<br>         int num = -1;<br>         while((num=is.read())!=-1){<!-- --><br>             //处理数据<br>             System.out.println((char)num);<br>         }<br>         //关闭流<br>         is.close();<br>     }<br> }</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">/*<br>    <span style="color:#ff0000;">read()  每次读取一个字节,重复通过循环读入,效率较低</span><br><span style="color:#ff0000;">   int read(byte[] b)  每次读入一个字节数组的数据,重复循环读入</span><br><span style="color:#ff0000;">    返回值: 返回读入到字节数组中数据的个数 ,没有读到返回-1</span><br>  */<br> public class Class003_IO {<!-- --><br>     public static void main(String[] args) throws IOException {<!-- --><br>         //1.构建流<br>         InputStream is = new FileInputStream("D://test2.txt");<br><br>         //2.准备卡车--&gt;字节数组<br>         byte[] car = new byte[1024];<br><br>         //3.读入<br>         int len = -1;<br>         while((len=is.read(car))!=-1){<!-- --><br>             //4.处理数据<br>             System.out.println(new String(car,0,len));;<br>         }<br><br>         //5.关闭<br>         is.close();<br>     }<br> }</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#fe2c24;">public byte[] readAllBytes() throws IOException</span><br>  从输入流中读取所有剩余字节。 此方法将阻塞，直到读取了所有剩余字节并检测到流结束，或者抛出异常。 此方法不会关闭输入流。<br>  当此流到达流的末尾时，此方法的进一步调用将返回空字节数组。<br><br>  请注意，此方法适用于方便将所有字节读入字节数组的简单情况。 它不用于读取包含大量数据的输入流。<br>         起始版本: java9</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">public class Class004_IO {<!-- --><br>     public static void main(String[] args) throws IOException {<!-- --><br>         //1.构建流<br>         InputStream is = new FileInputStream("D://test2.txt");<br><br>         //2.读入所有数据<br>         byte[] arr = is.readAllBytes();<br>         //3.处理数据<br>         System.out.println(new String(arr));<br><br>         //4.关闭<br>         is.close();<br>     }<br> }</p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#a2e043;">字节输出流<br>  </span><span style="color:#fe2c24;">OutputStream</span><span style="color:#a2e043;"> 此抽象类是表示输出字节流的所有类的超类。<br>  </span><span style="color:#fe2c24;">FileOutputStream</span><span style="color:#a2e043;"> : 文件输出流,将数据写出到指定文件中</span><br><br>  注意:<br>      如果目的地文件不存在,系统会自动创建<br>      输出流如果目的地文件存在,内容默认覆盖,设置追加</p> 
<pre>//1.定义输出流
//FileOutputStream(String name)
//FileOutputStream(File file)
//FileOutputStream(File file, boolean append) 创建文件输出流以写入由指定的 File对象表示的文件。
//FileOutputStream(String name, boolean append) 创建文件输出流以写入具有指定名称的文件。
OutputStream os = new FileOutputStream("D://test.txt",true);

//2.准备数据
byte[] car = "你好就好,要过的没我好!!!!".getBytes();

//3.写出
//write(int b) 将指定的字节写入此文件输出流。
//void write(byte[] b) 将指定字节数组中的 b.length字节写入此文件输出流。
//void write(byte[] b, int off, int len) 将从偏移量 off开始的指定字节数组中的 len字节写入此文件输出流。
os.write(97);
os.write(car);

//4.刷出
os.flush();

//5.关闭
os.close();</pre> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ff0000;">文件拷贝</span><br><span style="color:#ff0000;"> 数据源--&gt; 读入---&gt; 程序 --&gt; 写出 --&gt; 目的地</span><br><br><span style="color:#a2e043;"> 步骤:<br>      1.创建流(输入 输出)<br>      2.准备小汽车 字节数组<br>      3.读入--&gt;写出<br>      4.刷出<br>      5.关闭(后打开的先关闭)</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">//1.创建流(输入 输出)<br> //作用域提升,为了能够在finally中使用<br> InputStream is = null;<br> OutputStream os = null;<br> try {<!-- --><br>     is = new FileInputStream("D://test.txt");<br>     os = new FileOutputStream("D://dest.txt");<br>     //2.准备小汽车 字节数组<br>     byte[] car = new byte[1024];<br>     //3.读入--&gt;写出<br>     int len = -1; //记录每次读入到字节数组中数据的个数<br>     while((len=is.read(car))!=-1){<!-- --><br>         //读入多少字节数据写出多少字节数据<br>         os.write(car,0,len);<br>     }<br>     //4.刷出<br>     os.flush();<br> } catch (FileNotFoundException e) {<!-- --><br>     e.printStackTrace();<br> } catch (IOException e) {<!-- --><br>     e.printStackTrace();<br> } finally {<!-- --><br>     //5.关闭(后打开的先关闭)<br>     //预防空指针异常出现<br>     if(os!=null){<!-- --><br>         try {<!-- --><br>             os.close();<br>         } catch (IOException e) {<!-- --><br>             e.printStackTrace();<br>         }<br>     }<br>     if(is!=null){<!-- --><br>         try {<!-- --><br>             is.close();<br>         } catch (IOException e) {<!-- --><br>             e.printStackTrace();<br>         }<br>     }<br> }</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#fe2c24;">字符输入流  : 只能读写纯文本数据</span><br>     <span style="color:#fe2c24;">输入流 : Reader 字符输入流的父类<br>         FileReader 文件字符输入流</span><br>            <span style="color:#a2e043;"> read()<br>             read(char[])<br>             close()</span><br>     </p> 
<p style="margin-left:.0001pt;text-align:justify;">//1.创建流<br> //FileReader(String fileName)<br> //FileReader(File file)<br> Reader rd = new FileReader("D://test.txt");<br><br> //2.读入<br> //char ch = (char)(rd.read());<br> //小汽车<br> char[] car = new char[1024];<br><br> //循环读入<br> int len = -1;<br> while((len = rd.read(car))!=-1){<!-- --><br>     //3.处理数据<br>     System.out.println(new String(car,0,len));<br> }<br><br> //4.关闭<br> rd.close();</p> 
<pre><span style="color:#fe2c24;">输出流 : Writer 字符输出流抽象父类
 FileWriter 文件字符输出流</span>
     <span style="color:#a2e043;">write()
     flush()
     close()</span></pre> 
<pre>//1.创建流
//FileWriter(File file)
//FileWriter(String fileName)
//FileWriter(File file, boolean append)
//FileWriter(String fileName, boolean append)
Writer rt = new FileWriter("D://test.txt",true);

//2.准备数据
String msg = "今天也要加油鸭!!!";

//3.写出
rt.write(msg);

//4.刷出
rt.flush();

//5.关闭
rt.close();</pre> 
<pre><span style="color:#a2e043;">字符流实现文件拷贝
 注意: 只能为纯文本文件</span></pre> 
<pre>public class Class003_IO {
    public static void main(String[] args){
        //1.创建流
        Reader rd = null;
        Writer rt = null;
        try {
            rd= new FileReader("D://test.txt");
            rt = new FileWriter("D://hehe.txt");
            //2.读入,写出
            char[] car = new char[1024];
            int len = -1;
            while((len = rd.read(car))!=-1){
                rt.write(car,0,len);
            }

            //3.刷出
            rt.flush();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            //4.关闭
            if(rt!=null){
                try {
                    rt.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            if(rd!=null){
                try {
                    rd.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}
</pre> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/93f27ab3a4442c3742b12894c148b563/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">git解决本地分支合并test分支冲突的问题</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/fb718f7a0013c38b7fc1a1202e30a740/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">uniapp view 水平居中</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>