<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【性能优化】EFCore性能优化(一)-IEnumerable和IQueryable - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【性能优化】EFCore性能优化(一)-IEnumerable和IQueryable" />
<meta property="og:description" content="阅读本文你的收获 了解EF Core在使用上应该要注意的地方学习EF Core的优化技术，如禁用跟踪、IQueryable接口等 一、问题描述 Entity Framework Core（以下简称EF）是微软自家出品的大型O/RM框架，使用EF Core，我们可以在C#中用操作对象的方式来访问和操作数据库，它可以帮助我们把对C#对象的增删改查，转换成对应的关系型数据库的SQL语句，同时可以把从数据库返回的数据转换成C#的对象，并可以对对象的状态进行跟踪，只要状态发生改变，它就可以帮助我们生成对应的update、insert或者delete的SQL命令。使用EF可以大大提高程序员的开发效率。
但是使用EF的时候，也有不少要注意的地方。比如说EF操作数据库的性能肯定没有直接用ADO.NET操作SQL语句的性能高；另外，如果使用不当，则会导致内存占用过高，系统性能下降的问题等等。
如果你的系统对性能要求很高，我们就必须知道怎么去规避这些问题，在使用EF Core作为ORM时，你必须要注意以下几个方面：
IEnumerable和IQueryable两种接口要充分理解，区别使用EF默认自带实体跟踪机制，只读查询用非跟踪式查询可以提高效率。用AsNoTracking方法。EF对批量操作的支持不太高效，所以像批量添加、删除、修改等操作的执行效率，要注意分析与改进。对于一些复杂查询，EF帮我们生成的SQL语句有时是低效的，这时可以让EF直接执行原生SQL语句，或者改用ADO.NET方式去执行。（关于这一点，请参考 EFCore基础之如何执行原生SQL语句 ） 今天先来学习一下IEnumerable和IQueryable接口。
二、理解IEnumerable和IQueryable接口 LINQ标准查询运算符是依靠一组 扩展方法 来实现的。而这些扩展方法分别在System.Linq.Enumerable和System.Linq.Queryable这两个静态类中定义。比如：Where()、Select()、Count()、Any()等方法。
以Where扩展方法为例，在System.Linq.Enumerable类中，是这样定义的，它操作的是IEnumerable&lt; TSource &gt; 类型的集合数据，参数是Func&lt; T, bool &gt;委托类型。
public static IEnumerable&lt;TSource&gt; Where&lt;TSource&gt;(this IEnumerable&lt;TSource&gt; source, Func&lt;TSource, bool&gt; predicate); 在System.Linq.Queryable类中，Where扩展方法是这样定义的，它操作的是IQueryable&lt; TSource &gt;类型的数据，参数一个Expression&lt; T,bool &gt;表达式树类型。
public static IQueryable&lt;TSource&gt; Where&lt;TSource&gt;(this IQueryable&lt;TSource&gt; source, Expression&lt;Func&lt;TSource, bool&gt;&gt; predicate); 事实上，IEnumerable是可枚举接口，集合类型如List、Dictionary等都是继承了该接口，它还有一个泛型的版本IEnumerable&lt; T &gt;, 实现了该接口的对象都是集合对象，可以使用foreach接口进行遍历。
对于IEnumerable接口的LINQ扩展方法，可以实现在内存中对这些集合对象进行LINQ查询。使用IEnumerable的例子：
List&lt;Department&gt; data = new List&lt;Department&gt;(); //实例化一个空集合 data.Add(new Department { Id=Guid.NewGuid(), DepName=&#34;部门1&#34; }); data.Add(new Department { Id=Guid." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/6d91ef69f032a664695f6b2b415b3d1b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-25T21:51:58+08:00" />
<meta property="article:modified_time" content="2023-12-25T21:51:58+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【性能优化】EFCore性能优化(一)-IEnumerable和IQueryable</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="_0"></a>阅读本文你的收获</h3> 
<ol><li>了解EF Core在使用上应该要注意的地方</li><li>学习EF Core的优化技术，如禁用跟踪、IQueryable接口等</li></ol> 
<hr> 
<h3><a id="_5"></a>一、问题描述</h3> 
<p>Entity Framework Core（以下简称EF）是微软自家出品的大型O/RM框架，使用EF Core，我们可以在C#中用操作对象的方式来访问和操作数据库，它可以帮助我们把对C#对象的增删改查，转换成对应的关系型数据库的SQL语句，同时可以把从数据库返回的数据转换成C#的对象，并可以对对象的状态进行跟踪，只要状态发生改变，它就可以帮助我们生成对应的update、insert或者delete的SQL命令。使用EF可以大大提高程序员的开发效率。</p> 
<p>但是使用EF的时候，也有不少要注意的地方。比如说EF操作数据库的性能肯定没有直接用ADO.NET操作SQL语句的性能高；另外，如果使用不当，则会导致内存占用过高，系统性能下降的问题等等。</p> 
<p>如果你的系统对性能要求很高，我们就必须知道怎么去规避这些问题，在使用EF Core作为ORM时，你必须要注意以下几个方面：</p> 
<ul><li>IEnumerable和IQueryable两种接口要充分理解，区别使用</li><li>EF默认自带实体跟踪机制，只读查询用非跟踪式查询可以提高效率。用AsNoTracking方法。</li><li>EF对批量操作的支持不太高效，所以像批量添加、删除、修改等操作的执行效率，要注意分析与改进。</li><li>对于一些复杂查询，EF帮我们生成的SQL语句有时是低效的，这时可以让EF直接执行原生SQL语句，或者改用ADO.NET方式去执行。（关于这一点，请参考 <a href="https://blog.csdn.net/ousetuhou/article/details/135036776?spm=1001.2014.3001.5502">EFCore基础之如何执行原生SQL语句</a> ）</li></ul> 
<p>今天先来学习一下IEnumerable和IQueryable接口。</p> 
<h3><a id="IEnumerableIQueryable_18"></a>二、理解IEnumerable和IQueryable接口</h3> 
<p>LINQ标准查询运算符是依靠一组 <abbr title="msdn是这样规定扩展方法的：“扩展方法被定义为静态方法，但它们是通过实例方法语法进行调用的。 它们的第一个参数指定该方法作用于哪个类型，并且该参数以 this 修饰符为前缀。”">扩展方法</abbr> 来实现的。而这些扩展方法分别在System.Linq.Enumerable和System.Linq.Queryable这两个静态类中定义。比如：Where()、Select()、Count()、Any()等方法。</p> 
<p>以Where扩展方法为例，在System.Linq.Enumerable类中，是这样定义的，它操作的是IEnumerable&lt; TSource &gt; 类型的集合数据，参数是Func&lt; T, bool &gt;委托类型。</p> 
<pre><code class="prism language-csharp"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name">IEnumerable<span class="token punctuation">&lt;</span>TSource<span class="token punctuation">&gt;</span></span> <span class="token generic-method"><span class="token function">Where</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>TSource<span class="token punctuation">&gt;</span></span></span><span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token class-name">IEnumerable<span class="token punctuation">&lt;</span>TSource<span class="token punctuation">&gt;</span></span> source<span class="token punctuation">,</span> 
         <span class="token class-name">Func<span class="token punctuation">&lt;</span>TSource<span class="token punctuation">,</span> <span class="token keyword">bool</span><span class="token punctuation">&gt;</span></span> predicate<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>在System.Linq.Queryable类中，Where扩展方法是这样定义的，它操作的是IQueryable&lt; TSource &gt;类型的数据，参数一个Expression&lt; T,bool &gt;表达式树类型。</p> 
<pre><code class="prism language-csharp"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name">IQueryable<span class="token punctuation">&lt;</span>TSource<span class="token punctuation">&gt;</span></span> <span class="token generic-method"><span class="token function">Where</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>TSource<span class="token punctuation">&gt;</span></span></span><span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token class-name">IQueryable<span class="token punctuation">&lt;</span>TSource<span class="token punctuation">&gt;</span></span> source<span class="token punctuation">,</span>
        <span class="token class-name">Expression<span class="token punctuation">&lt;</span>Func<span class="token punctuation">&lt;</span>TSource<span class="token punctuation">,</span> <span class="token keyword">bool</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> predicate<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>事实上，<strong>IEnumerable是可枚举接口</strong>，集合类型如List、Dictionary等都是继承了该接口，它还有一个泛型的版本IEnumerable&lt; T &gt;, 实现了该接口的对象都是集合对象，可以使用foreach接口进行遍历。</p> 
<p><strong>对于IEnumerable接口的LINQ扩展方法，可以实现在内存中对这些集合对象进行LINQ查询</strong>。使用IEnumerable的例子：</p> 
<pre><code class="prism language-csharp"><span class="token class-name">List<span class="token punctuation">&lt;</span>Department<span class="token punctuation">&gt;</span></span> data <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">List<span class="token punctuation">&lt;</span>Department<span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//实例化一个空集合</span>
data<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token constructor-invocation class-name">Department</span> <span class="token punctuation">{<!-- --></span> Id<span class="token operator">=</span>Guid<span class="token punctuation">.</span><span class="token function">NewGuid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> DepName<span class="token operator">=</span><span class="token string">"部门1"</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
data<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token constructor-invocation class-name">Department</span> <span class="token punctuation">{<!-- --></span> Id<span class="token operator">=</span>Guid<span class="token punctuation">.</span><span class="token function">NewGuid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> DepName<span class="token operator">=</span><span class="token string">"部门2"</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//对集合做一个LINQ查询，是在内存中操作的</span>
<span class="token class-name">IEnumerable<span class="token punctuation">&lt;</span>Department<span class="token punctuation">&gt;</span></span>  result <span class="token operator">=</span> data<span class="token punctuation">.</span><span class="token function">Where</span><span class="token punctuation">(</span>x <span class="token operator">=&gt;</span> x<span class="token punctuation">.</span>DepName<span class="token punctuation">.</span><span class="token function">Contains</span><span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//result是一个可枚举对象，所以可以用foreach进行遍历</span>
<span class="token keyword">foreach</span> <span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">var</span></span> item <span class="token keyword">in</span> result<span class="token punctuation">)</span> 
<span class="token punctuation">{<!-- --></span>
	Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token interpolation-string"><span class="token string">$"</span><span class="token interpolation"><span class="token punctuation">{<!-- --></span><span class="token expression language-csharp">item<span class="token punctuation">.</span>Id</span><span class="token punctuation">}</span></span><span class="token string">数据是：</span><span class="token interpolation"><span class="token punctuation">{<!-- --></span><span class="token expression language-csharp">item<span class="token punctuation">.</span>DepName</span><span class="token punctuation">}</span></span><span class="token string">"</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>IQueryable继承了IEnumerable，IQueryable是可查询接口</strong>，采用这个接口去调用LINQ的扩展方法，则可以根据用户指定的条件表达式生成对应的带筛选条件的SQL语句，但是<strong>并没有立即执行SQL语句，所以可以继续对这个可查询的对象拼接各种筛选条件、排序、分组等操作，等到执行ToList、Count等方法的时候，Linq to SQL引擎会把表达式树转化成相应的SQL在数据库服务器上执行，再将结果加载到内存中来。这也是Linq的<code>延迟加载</code>核心思想所在，在很复杂的操作下可能比较慢了，时间换空间</strong> 以下是使用IQueryable的例子：</p> 
<pre><code class="prism language-csharp"><span class="token comment">/// &lt;summary&gt;</span>
<span class="token comment">/// 获取车辆分页列表</span>
<span class="token comment">/// &lt;/summary&gt;</span>
<span class="token comment">/// &lt;param name="input"&gt;&lt;/param&gt;</span>
<span class="token comment">/// &lt;returns&gt;&lt;/returns&gt;</span>
<span class="token keyword">public</span> <span class="token keyword">async</span> <span class="token return-type class-name">Task<span class="token punctuation">&lt;</span>PageResponseDto<span class="token punctuation">&lt;</span>VehicleProductDto<span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> <span class="token function">GetListAsync</span><span class="token punctuation">(</span><span class="token class-name">QueryVehicleProductDto</span> input<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token comment">//虽然用了where方法，但是并没有立即执行SQL语句</span>
    <span class="token class-name">IQueryable<span class="token punctuation">&lt;</span>VehicleProductInfo<span class="token punctuation">&gt;</span></span> query <span class="token operator">=</span> <span class="token keyword">from</span> vendor <span class="token keyword">in</span> _vehicleProductRepository<span class="token punctuation">.</span>Table
                                                <span class="token keyword">where</span> <span class="token punctuation">(</span><span class="token keyword">string</span><span class="token punctuation">.</span><span class="token function">IsNullOrEmpty</span><span class="token punctuation">(</span>input<span class="token punctuation">.</span>ItemBrand<span class="token punctuation">)</span> <span class="token operator">||</span> vendor<span class="token punctuation">.</span>ItemBrand<span class="token punctuation">.</span><span class="token function">Contains</span><span class="token punctuation">(</span>input<span class="token punctuation">.</span>ItemBrand<span class="token punctuation">)</span><span class="token punctuation">)</span>
                                                <span class="token keyword">orderby</span> vendor<span class="token punctuation">.</span>ItemBrand
                                                <span class="token keyword">select</span> vendor<span class="token punctuation">;</span>

    <span class="token class-name">PageResponseDto<span class="token punctuation">&lt;</span>VehicleProductDto<span class="token punctuation">&gt;</span></span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">//执行分页查询</span>
    <span class="token class-name">List<span class="token punctuation">&lt;</span>VehicleProductInfo<span class="token punctuation">&gt;</span></span> pageList <span class="token operator">=</span> <span class="token keyword">await</span> query
                                        <span class="token punctuation">.</span><span class="token function">Skip</span><span class="token punctuation">(</span><span class="token punctuation">(</span>input<span class="token punctuation">.</span>PageIndex <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> input<span class="token punctuation">.</span>PageSize<span class="token punctuation">)</span> 
                                        <span class="token punctuation">.</span><span class="token function">Take</span><span class="token punctuation">(</span>input<span class="token punctuation">.</span>PageSize<span class="token punctuation">)</span> <span class="token comment">//继续拼接 分页的参数，但不执行SQL语句</span>
                                        <span class="token punctuation">.</span><span class="token function">ToListAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">//调用ToList方法则执行SQL语句</span>

    result<span class="token punctuation">.</span>PagedList <span class="token operator">=</span> pageList<span class="token punctuation">.</span><span class="token generic-method"><span class="token function">MapToList</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>VehicleProductDto<span class="token punctuation">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//通过AutoMapper转换成VehicleProductDto</span>
    result<span class="token punctuation">.</span>TotalCount <span class="token operator">=</span> query<span class="token punctuation">.</span><span class="token function">Count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                         <span class="token comment">//调用Count方法则执行SQL语句</span>

    <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="_83"></a>三、两者的比较总结</h3> 
<p>在应用到IEnumberable 和IQueryable两个接口时，代码往往很相似，从而造成了很多困惑，然后从上面分析可以看出，两者还是有很大的区别的，各自都有自己特定的使用场景。</p> 
<p>下面是IEnumberable和IQueryable的对比：</p> 
<table><thead><tr><th>项目</th><th align="left">IEnumerable接口</th><th align="left">IQueryable接口</th></tr></thead><tbody><tr><td>命名空间</td><td align="left">System.Collections</td><td align="left">System.Linq</td></tr><tr><td>继承于</td><td align="left">没有基类接口</td><td align="left">继承于IEnumerable</td></tr><tr><td>延迟执行</td><td align="left">支持</td><td align="left">支持</td></tr><tr><td>延迟加载</td><td align="left">不支持</td><td align="left">支持</td></tr><tr><td>工作流程</td><td align="left">把查询的数据加载在内存中，然后再筛选数据，因此这个操作比较占用内存，运行慢</td><td align="left">当从数据库中查询数据，IQueryable在服务器端根据所有的filter条件执行查询操作，因此该操作需要更少的工作而运行快</td></tr><tr><td>适用于</td><td align="left">LINQ to Object 和LINQ to XML查询</td><td align="left">LINQ to SQL查询.</td></tr><tr><td>使用场合</td><td align="left">遍历内存中的数据集合(如List，Array等)</td><td align="left">当查询非内存中的数据集合(如远程数据库，service等)</td></tr></tbody></table> 
<p><code>错误案例演示</code></p> 
<pre><code class="prism language-csharp"><span class="token comment">//根据输入条件，获取用户分页列表</span>
<span class="token keyword">public</span> <span class="token return-type class-name">PageResponseModel<span class="token punctuation">&lt;</span>User<span class="token punctuation">&gt;</span></span> <span class="token function">GetUserList</span><span class="token punctuation">(</span><span class="token class-name">UserPageRequestDto</span> input<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">using</span> <span class="token class-name">MyDbContext</span> db <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">MyDbContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//过早地ToList了，加载全部数据进内存</span>
    <span class="token class-name"><span class="token keyword">var</span></span> query <span class="token operator">=</span> db<span class="token punctuation">.</span><span class="token generic-method"><span class="token function">Set</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>User<span class="token punctuation">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">AsQueryable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ToList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//拼接查询条件</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">string</span><span class="token punctuation">.</span><span class="token function">IsNullOrEmpty</span><span class="token punctuation">(</span>input<span class="token punctuation">.</span>Name<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        query <span class="token operator">=</span> query<span class="token punctuation">.</span><span class="token function">Where</span><span class="token punctuation">(</span>x <span class="token operator">=&gt;</span> x<span class="token punctuation">.</span>UName<span class="token punctuation">.</span><span class="token function">StartsWith</span><span class="token punctuation">(</span>input<span class="token punctuation">.</span>Name<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ToList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token class-name">PageResponseModel<span class="token punctuation">&lt;</span>User<span class="token punctuation">&gt;</span></span> pageList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    pageList<span class="token punctuation">.</span>TotalCount <span class="token operator">=</span> query<span class="token punctuation">.</span><span class="token function">Count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    pageList<span class="token punctuation">.</span>PageList <span class="token operator">=</span> query<span class="token punctuation">.</span><span class="token function">OrderBy</span><span class="token punctuation">(</span>x<span class="token operator">=&gt;</span>x<span class="token punctuation">.</span>CreateTime<span class="token punctuation">)</span>
                       <span class="token punctuation">.</span><span class="token function">Skip</span><span class="token punctuation">(</span><span class="token punctuation">(</span>input<span class="token punctuation">.</span>PageIndex<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">*</span>input<span class="token punctuation">.</span>PageSize<span class="token punctuation">)</span>
                       <span class="token punctuation">.</span><span class="token function">Take</span><span class="token punctuation">(</span>input<span class="token punctuation">.</span>PageSize<span class="token punctuation">)</span>
                       <span class="token punctuation">.</span><span class="token function">ToList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> pageList<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>以上案例中，因为所有对于IEnumerable的过滤、排序、分组、聚合等操作，都是在内存中进行的，所以在EF Core中使用LINQ查询的时候，如果你不加任何的筛选条件，马上ToList()，然后再进行排序，分组、筛选的话，那也就是说把所有的数据不管用不用得到，都从数据库加载到内存中，只是在内存中进行过滤和排序操作，这样做虽然性能很高，但很消耗内存。属于用“空间换时间”，所以要谨慎使用。</p> 
<h3><a id="_126"></a>小结</h3> 
<p>说了这么多，这两者怎么区分使用呢？——操作本地数据源用IEnumerable，操作远程数据源用IQueryable。IQueryable是负责生成SQL语句的，但并不马上执行，可以继续拼接各种的条件到SQL语句中之后再去服务器上执行，占用内存空间小，但是如果查询很复杂，就会比较慢。<br> IEnumerable是对任意类型的集合都能操作的，不限于是数据库还是一般的数组还是List集合，因为在内存中操作，所以性能高，但是如果你把数据库中的数据全加载进内存来处理，那会很耗内存，导致严重问题。</p> 
<hr> 
<p>如果本文对你有帮助的话，请点赞+评论+关注，或者转发给需要的朋友。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/01a38da9bd56b62f34c609d365c71b57/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">虚拟机安装centos7系统步骤</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1e0ee70574a6fb43e962448df7488d76/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">ValueError: Expected more than 1 value per channel when training, got input size torch.Size([1, 512,</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>