<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>ARMv7和ARMv8的区别 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="ARMv7和ARMv8的区别" />
<meta property="og:description" content="记录一些关键的变化:
对工程师来说Armv8-A有什么新东西？ Armv8-A架构引入了许多变化，可以设计出可实现的性能更高的处理器。
因为pc端逐渐对arm架构的偏爱,大的内存和寻址空间就很有必要,原始的32bit只能支持4gb内存
大的物理地址
这使处理器能够访问超过4GB的物理内存。
64位虚拟寻址
这使虚拟内存越过4GB限制的。 这对使用内存映射文件I / O或稀疏寻址的现代桌面和服务器软件很重要。
自动信号事件
这使得高效，高性能的自旋锁成为可能。
更大的寄存器文件
有31个64位通用寄存器，这提高了性能并减少了堆栈的使用。
高效的64位立即生成
文字池的需求较少。
较大的PC相对寻址范围
在共享库和位置无关的可执行程序中的有效的数据寻址范围是&#43;/- 4GB。
额外的16KB和64KB转换粒度
这降低了转换后备缓冲区（TLB）不命中率和页面访问的深度。
新的异常模型
这降低了OS和hypervisor 程序的复杂度
高效的缓存管理
用户空间缓存操作提高了动态代码生成效率。 快速数据缓存clear 操作使用数据缓存清零指令清除。
硬件加速密码技术
提供比软件加密更好的3倍到10倍速度性能。 这对于由于太小而不能有效转载到硬件加速器的细粒度解密和加密很有用，例如https。
加载-获取，存储-释放的指令
专为C &#43;&#43; 11，C11，Java内存模型而设计。 它们通过消除显式的内存屏障指令来提高线程安全代码的性能。
NEON双精度浮点高级SIMD
这使得SIMD矢量化可以应用于更广泛的算法集合，例如科学计算，高性能计算（HPC）和超级计算机。
工作模式 在不同的处理器模式中,有不同的硬件访问权限 privilege level.
主要有两个 privilege level
a) non-privilege : 其中只有User模式属于non-privilege level，其它均是privilege level。
安全起见，大多数时候，软件都运行在User mode。一旦需要其它操作，则需要切换到相应的privilege模式下。这是最原始、最朴素的 l安全思想，当然，只防君子，不防小人。
b)privilege:除了user模式外,都是特权模式,不同的模式,都有自己的寄存器—&gt;让模式切换中更加高效
armv7之前:参考arm9 armv7之前处理器可以工作在7种工作模式（称作processor mode):
用户模式(Usr)：用于正常执行程序；
快速中断模式(FIQ)：用于高速数据传输；
外部中断模式(IRQ)：用于通常的中断处理；
管理模式(svc)：操作系统使用的保护模式；
数据访问终止模式(abt)：当数据或指令预取终止时进入该模式，可用于虚拟存储以及存储保护；
系统模式(sys)：运行具有特权的操作系统任务；
未定义指令中止模式(und)：当未定义的指令执行时进入该模式，可用于支持硬件；
armv7-a实现 armv7和之前一样,不同的是将privilege level命名了，称作PL0和PL1,后来出现了PL2，用于虚拟化扩展（Virtualization Extension）。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/befbf07ae171d57ce5762cbe126d4e6e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-01-01T16:57:34+08:00" />
<meta property="article:modified_time" content="2022-01-01T16:57:34+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">ARMv7和ARMv8的区别</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atelier-sulphurpool-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>记录一些关键的变化:</p> 
<h4><a id="Armv8A_1"></a>对工程师来说Armv8-A有什么新东西？</h4> 
<p>Armv8-A架构引入了许多变化，可以设计出可实现的性能更高的处理器。<br> 因为pc端逐渐对arm架构的偏爱,大的内存和寻址空间就很有必要,原始的32bit只能支持4gb内存</p> 
<p>大的物理地址<br> 这使处理器能够访问超过4GB的物理内存。<br> 64位虚拟寻址<br> 这使虚拟内存越过4GB限制的。 这对使用内存映射文件I / O或稀疏寻址的现代桌面和服务器软件很重要。<br> 自动信号事件<br> 这使得高效，高性能的自旋锁成为可能。<br> 更大的寄存器文件<br> 有31个64位通用寄存器，这提高了性能并减少了堆栈的使用。<br> 高效的64位立即生成<br> 文字池的需求较少。<br> 较大的PC相对寻址范围<br> 在共享库和位置无关的可执行程序中的有效的数据寻址范围是+/- 4GB。<br> 额外的16KB和64KB转换粒度<br> 这降低了转换后备缓冲区（TLB）不命中率和页面访问的深度。<br> 新的异常模型<br> 这降低了OS和hypervisor 程序的复杂度<br> 高效的缓存管理<br> 用户空间缓存操作提高了动态代码生成效率。 快速数据缓存clear 操作使用数据缓存清零指令清除。<br> 硬件加速密码技术<br> 提供比软件加密更好的3倍到10倍速度性能。 这对于由于太小而不能有效转载到硬件加速器的细粒度解密和加密很有用，例如https。<br> 加载-获取，存储-释放的指令<br> 专为C ++ 11，C11，Java内存模型而设计。 它们通过消除显式的内存屏障指令来提高线程安全代码的性能。<br> NEON双精度浮点高级SIMD<br> 这使得SIMD矢量化可以应用于更广泛的算法集合，例如科学计算，高性能计算（HPC）和超级计算机。</p> 
<h4><a id="_31"></a>工作模式</h4> 
<p>在不同的处理器模式中,有不同的硬件访问权限 privilege level.<br> 主要有两个 privilege level<br> a) non-privilege : 其中只有User模式属于non-privilege level，其它均是privilege level。<br> 安全起见，大多数时候，软件都运行在User mode。一旦需要其它操作，则需要切换到相应的privilege模式下。这是最原始、最朴素的 l安全思想，当然，只防君子，不防小人。<br> b)privilege:除了user模式外,都是特权模式,不同的模式,都有自己的寄存器—&gt;让模式切换中更加高效</p> 
<h5><a id="armv7arm9_37"></a>armv7之前:参考arm9</h5> 
<p>armv7之前处理器可以工作在7种工作模式（称作processor mode):</p> 
<p>用户模式(Usr)：用于正常执行程序；<br> 快速中断模式(FIQ)：用于高速数据传输；<br> 外部中断模式(IRQ)：用于通常的中断处理；<br> 管理模式(svc)：操作系统使用的保护模式；<br> 数据访问终止模式(abt)：当数据或指令预取终止时进入该模式，可用于虚拟存储以及存储保护；<br> 系统模式(sys)：运行具有特权的操作系统任务；<br> 未定义指令中止模式(und)：当未定义的指令执行时进入该模式，可用于支持硬件；</p> 
<h5><a id="armv7a_47"></a>armv7-a实现</h5> 
<p>armv7和之前一样,不同的是将privilege level命名了，称作PL0和PL1,后来出现了PL2，用于虚拟化扩展（Virtualization Extension）。<br> 另外，增加了一个模式：Monitor用于security扩展（为支持建立可信赖的执行环境（trust execution environment, TEE）而引入等扩展。）变成8种模式，即增加了Monitor。</p> 
<h5><a id="armv8a_50"></a>armv8-a实现</h5> 
<p>ARMv8-a的设计者觉得之前的设计有些啰嗦,rocessor mode(工作模式)的概念淡化,取而代之的是4个固定的Exception level<br> EL0是user模式<br> EL1是<strong>内核</strong>（EL0的user和EL1是6种模式合起来是32位ARM的7种工作模式）<br> EL2是HYP(虚拟化扩展)<br> EL3是Monitor（用于安全/非安全世界的切换）<br> <img src="https://images2.imgbox.com/56/c8/9d3raCgN_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-bash"><span class="token number">1</span><span class="token punctuation">)</span>AArch64中，已经没有User、SVC、ABT等处理器模式的概念，但ARMv8需要向前兼容，在AArch32中，就把这些处理器模式map到了4个Exception level。
<span class="token number">2</span><span class="token punctuation">)</span>Application位于特权等级最低的EL0，Linux kernel 位于EL1，提供虚拟化支持的Hypervisor位于EL2（可以不实现），提供Security支持的Seurity Monitor位于EL3（可以不实现）。
<span class="token number">3</span><span class="token punctuation">)</span>只有在异常发生时（或者异常处理返回时），才能切换Exception level（这也是Exception level的命名原因，为了处理异常）。当异常发生时，有两种选择，停留在当前的EL，或者跳转到更高的EL，EL不能降级。同样，异常处理返回时，也有两种选择，停留在当前EL，或者调到更低的EL
</code></pre> 
<h4><a id="_64"></a>内存管理</h4> 
<p><img src="https://images2.imgbox.com/83/cb/CEtRmkHY_o.png" alt="在这里插入图片描述"><br> 支持48bit虚拟地址和物理地址,所以寻址空间是—&gt;144000GB，这样可以简化硬件，可以只支持到4级页表；<br> 支持4K和64K页<br> 提供了两种基地址，分别是内核空间和用户空间<br> 用户空间虚拟地址到物理地址的转换需要经过两个阶段，分别是VA-&gt;IPA,IPA-&gt;PA</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e52df7608473af4c183b2dc4c0f00a35/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">yolov5踩坑记录（1）No module named ‘utils‘</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/89e9fd180d8b2d2f995b0b2c7865a34b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">在navicat中创建表格</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>