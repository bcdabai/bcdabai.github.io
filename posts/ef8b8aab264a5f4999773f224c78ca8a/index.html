<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>关于android中postDelayed方法的讲解 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="关于android中postDelayed方法的讲解" />
<meta property="og:description" content="这是一种可以创建多线程消息的函数
使用方法：
1，首先创建一个Handler对象
Handler handler=new Handler();
2，然后创建一个Runnable对象
Runnable runnable=new Runnable(){
@Override
public void run() {
// TODO Auto-generated method stub
//要做的事情，这里再次调用此Runnable对象，以实现每两秒实现一次的定时器操作
handler.postDelayed(this, 2000);
} };
3，使用PostDelayed方法，两秒后调用此Runnable对象
handler.postDelayed(runnable, 2000);
实际上也就实现了一个2s的一个定时器
4，如果想要关闭此定时器，可以这样操作
handler.removeCallbacks(runnable);
当然，你也可以做一个闹钟提醒延时的函数试试，比如，先用MediaPlayer播放闹钟声音，
如果不想起，被停止播放之后，下次就5分钟后再播放，再被停止的话，下次就4分钟后播放，
………………
只要更改延时的时间就可以实现了，用一个static对象的话会比较容易操作。
是可以异步效果，但Runnable的执行是在Handler对象所在的线程
如果其所在的线程是UI线程的话，Runnable中还是不能执行耗时操作，不然会ANR
前几天我们自己的设备很卡，卡到跳转界面都需要不到1秒的时间，我就把跳转的动作放在Runnable里边，外边加上弹出进度提示框
注：举例说明
public class XXX extends Activity
{
@Override
public void onCreate(Bundle savedInstanceState)
{
super.onCreate(savedInstanceState);
requestWindowFeature(Window.FEATURE_NO_TITLE);
setContentView(R.layout.loading); // 显示第1屏
Handler handler = new Handler();
handler.postDelayed(new splashhandler(), 2000); // 延迟2秒，再运行splashhandler的run()
}
class splashhandler implements Runnable" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/ef8b8aab264a5f4999773f224c78ca8a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-06-17T13:50:58+08:00" />
<meta property="article:modified_time" content="2019-06-17T13:50:58+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">关于android中postDelayed方法的讲解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>这是一种可以创建多线程消息的函数<br> 使用方法：<br><strong>1，首先创建一个Handler对象</strong></p> 
<p>Handler handler=new Handler();</p> 
<p> </p> 
<p><strong>2，然后创建一个Runnable对象</strong><br> Runnable runnable=new Runnable(){<!-- --><br>    @Override<br>    public void run() {<!-- --><br>     // TODO Auto-generated method stub<br>     //要做的事情，这里再次调用此Runnable对象，以实现每两秒实现一次的定时器操作<br>     handler.postDelayed(this, 2000);<br>    } </p> 
<p>};</p> 
<p> </p> 
<p><strong>3，使用PostDelayed方法，两秒后调用此Runnable对象</strong><br> handler.postDelayed(runnable, 2000);</p> 
<p>实际上也就实现了一个2s的一个定时器</p> 
<p> </p> 
<p><strong>4，如果想要关闭此定时器，可以这样操作</strong><br> handler.removeCallbacks(runnable);<br><br> 当然，你也可以做一个闹钟提醒延时的函数试试，比如，先用MediaPlayer播放闹钟声音，<br> 如果不想起，被停止播放之后，下次就5分钟后再播放，再被停止的话，下次就4分钟后播放，<br> ………………<br> 只要更改延时的时间就可以实现了，用一个static对象的话会比较容易操作。<br><br> 是可以异步效果，但Runnable的执行是在Handler对象所在的线程<br> 如果其所在的线程是UI线程的话，Runnable中还是不能执行耗时操作，不然会ANR<br> 前几天我们自己的设备很卡，卡到跳转界面都需要不到1秒的时间，我就把跳转的动作放在Runnable里边，外边加上弹出进度提示框</p> 
<p> </p> 
<p><strong>注：举例说明</strong></p> 
<p>public class XXX extends Activity</p> 
<p>{<!-- --><br>     @Override<br>     public void onCreate(Bundle savedInstanceState)</p> 
<p>    {<!-- --><br>         super.onCreate(savedInstanceState);<br>         requestWindowFeature(Window.FEATURE_NO_TITLE);<br>         <strong>setContentView(R.layout.loading); // 显示第1屏</strong><br>         Handler handler = new Handler();<br>        <strong> handler.postDelayed(new splashhandler(), 2000); // 延迟2秒，再运行splashhandler的run()</strong><br>     }<br><br>     class splashhandler implements Runnable</p> 
<p>     {<!-- --><br>         public void run()</p> 
<p>       {<!-- --><br><strong>            startActivity(new Intent(getApplication(),  SecondActivity.class)); // 显示第2屏<br>             XXX.this.finish();   // 结束第1屏</strong><br>         }<br>     }<br> }</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b90e7770a464d18694354548c3b84545/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">输入一个整数n和n个整数，输出这n个整数的最大值。</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/17a796420fa1046a02f66a47e8697245/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">生成假的规则单号？</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>