<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>java GC and PhantomReference - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="java GC and PhantomReference" />
<meta property="og:description" content="Java中一共有4种类型的引用:StrongReference、SoftReference、WeakReference以及PhantomReference (幽灵引用), 这 4 种类型的引用与Java GC有着密切的关系, 让我们逐一来看它们的定义和使用场景。
1. Strong Reference
StrongReference 是 Java 的默认引用实现,它会尽可能长时间的存活于 JVM 内， 当没有任何对象指向它时Java GC 执行后将会被回收
@Test public void strongReference() { Object referent = new Object(); /** * 通过赋值创建 StrongReference */ Object strongReference = referent; assertSame(referent, strongReference); referent = null; System.gc(); /** * StrongReference 在 GC 后不会被回收 */ assertNotNull(strongReference); } @Test public void strongReference() { Object referent = new Object(); /** * 通过赋值创建 StrongReference */ Object strongReference = referent; assertSame(referent, strongReference); referent = null; System." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/c8ea72d33b1a4188a98a44d97c61201a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2011-08-01T10:01:21+08:00" />
<meta property="article:modified_time" content="2011-08-01T10:01:21+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">java GC and PhantomReference</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>Java中一共有4种类型的引用:StrongReference、SoftReference、WeakReference以及PhantomReference (幽灵引用), 这 4 种类型的引用与Java GC有着密切的关系, 让我们逐一来看它们的定义和使用场景。</p> 
<p><br> </p> 
<p>1. Strong Reference</p> 
<p>StrongReference 是 Java 的默认引用实现,它会尽可能长时间的存活于 JVM 内， 当没有任何对象指向它时Java GC 执行后将会被回收</p> 
<pre> 
 <ol class="dp-xml"><li class="alt">@Test  </li><li>public void strongReference() {   </li><li class="alt">Object <span class="attribute"><span style="color:#ff0000">referent</span></span> = <span class="attribute-value"><span style="color:#0000ff">new</span></span> Object();   </li><li>   </li><li class="alt">/**  </li><li> * 通过赋值创建 StrongReference   </li><li class="alt"> */  </li><li>Object <span class="attribute"><span style="color:#ff0000">strongReference</span></span> = <span class="attribute-value"><span style="color:#0000ff">referent</span></span>;   </li><li class="alt">   </li><li>assertSame(referent, strongReference);   </li><li class="alt">   </li><li><span class="attribute"><span style="color:#ff0000">referent</span></span> = <span class="attribute-value"><span style="color:#0000ff">null</span></span>;   </li><li class="alt">System.gc();   </li><li>   </li><li class="alt">/**  </li><li> * StrongReference 在 GC 后不会被回收  </li><li class="alt"> */  </li><li>assertNotNull(strongReference);   </li><li class="alt">}   </li><li> </li><li class="alt"> @Test  </li><li> public void strongReference() {  </li><li class="alt">  Object <span class="attribute"><span style="color:#ff0000">referent</span></span> = <span class="attribute-value"><span style="color:#0000ff">new</span></span> Object();  </li><li>    </li><li class="alt">  /**  </li><li>   * 通过赋值创建 StrongReference   </li><li class="alt">   */  </li><li>  Object <span class="attribute"><span style="color:#ff0000">strongReference</span></span> = <span class="attribute-value"><span style="color:#0000ff">referent</span></span>;  </li><li class="alt">    </li><li>  assertSame(referent, strongReference);  </li><li class="alt">    </li><li>  <span class="attribute"><span style="color:#ff0000">referent</span></span> = <span class="attribute-value"><span style="color:#0000ff">null</span></span>;  </li><li class="alt">  System.gc();  </li><li>    </li><li class="alt">  /**  </li><li>   * StrongReference 在 GC 后不会被回收  </li><li class="alt">   */  </li><li>  assertNotNull(strongReference);  </li><li class="alt"> } </li></ol></pre> 
<p>2. WeakReference &amp; WeakHashMap</p> 
<p>WeakReference， 顾名思义,是一个弱引用,当所引用的对象在 JVM 内不再有强引用时, Java GC 后 weak reference 将会被自动回收</p> 
<pre> 
 <ol class="dp-xml"><li class="alt">@Test  </li><li>public void weakReference() {   </li><li class="alt">Object <span class="attribute"><span style="color:#ff0000">referent</span></span> = <span class="attribute-value"><span style="color:#0000ff">new</span></span> Object();   </li><li>WeakReference<strong><span style="color:#006699"><span class="tag">&lt;</span><span class="tag-name">Object</span><span class="tag">&gt;</span></span></strong> <span class="attribute"><span style="color:#ff0000">weakRerference</span></span> = <span class="attribute-value"><span style="color:#0000ff">new</span></span> WeakReference<strong><span style="color:#006699"><span class="tag">&lt;</span><span class="tag-name">Object</span><span class="tag">&gt;</span></span></strong>(referent);   </li><li class="alt"> </li><li>assertSame(referent, weakRerference.get());   </li><li class="alt">   </li><li><span class="attribute"><span style="color:#ff0000">referent</span></span> = <span class="attribute-value"><span style="color:#0000ff">null</span></span>;   </li><li class="alt">System.gc();   </li><li>   </li><li class="alt">/**  </li><li> * 一旦没有指向 referent 的强引用, weak reference 在 GC 后会被自动回收  </li><li class="alt"> */  </li><li>assertNull(weakRerference.get());   </li><li class="alt">}   </li><li> </li><li class="alt"> @Test  </li><li> public void weakReference() {  </li><li class="alt">  Object <span class="attribute"><span style="color:#ff0000">referent</span></span> = <span class="attribute-value"><span style="color:#0000ff">new</span></span> Object();  </li><li>  WeakReference<strong><span style="color:#006699"><span class="tag">&lt;</span><span class="tag-name">Object</span><span class="tag">&gt;</span></span></strong> <span class="attribute"><span style="color:#ff0000">weakRerference</span></span> = <span class="attribute-value"><span style="color:#0000ff">new</span></span> WeakReference<strong><span style="color:#006699"><span class="tag">&lt;</span><span class="tag-name">Object</span><span class="tag">&gt;</span></span></strong>(referent);  </li><li class="alt">   </li><li>  assertSame(referent, weakRerference.get());  </li><li class="alt">    </li><li>  <span class="attribute"><span style="color:#ff0000">referent</span></span> = <span class="attribute-value"><span style="color:#0000ff">null</span></span>;  </li><li class="alt">  System.gc();  </li><li>    </li><li class="alt">  /**  </li><li>   * 一旦没有指向 referent 的强引用, weak reference 在 GC 后会被自动回收  </li><li class="alt">   */  </li><li>  assertNull(weakRerference.get());  </li><li class="alt"> } </li></ol></pre> 
<p>WeakHashMap 使用 WeakReference 作为 key， 一旦没有指向 key 的强引用, WeakHashMap 在Java GC 后将自动删除相关的 entry</p> 
<pre> 
 <ol class="dp-xml"><li class="alt">@Test  </li><li>public void weakHashMap() throws InterruptedException {   </li><li class="alt">Map<strong><span style="color:#006699"><span class="tag">&lt;</span><span class="tag-name">Object</span></span></strong>, Object<span class="tag"><strong><span style="color:#006699">&gt;</span></strong></span> <span class="attribute"><span style="color:#ff0000">weakHashMap</span></span> = <span class="attribute-value"><span style="color:#0000ff">new</span></span> WeakHashMap<strong><span style="color:#006699"><span class="tag">&lt;</span><span class="tag-name">Object</span></span></strong>, Object<span class="tag"><strong><span style="color:#006699">&gt;</span></strong></span>();   </li><li>Object <span class="attribute"><span style="color:#ff0000">key</span></span> = <span class="attribute-value"><span style="color:#0000ff">new</span></span> Object();   </li><li class="alt">Object <span class="attribute"><span style="color:#ff0000">value</span></span> = <span class="attribute-value"><span style="color:#0000ff">new</span></span> Object();   </li><li>weakHashMap.put(key, value);   </li><li class="alt"> </li><li>assertTrue(weakHashMap.containsValue(value));   </li><li class="alt">   </li><li><span class="attribute"><span style="color:#ff0000">key</span></span> = <span class="attribute-value"><span style="color:#0000ff">null</span></span>;   </li><li class="alt">System.gc();   </li><li>   </li><li class="alt">/**  </li><li> * 等待无效 entries 进入 ReferenceQueue 以便下一次调用 getTable 时被清理  </li><li class="alt"> */  </li><li>Thread.sleep(1000);   </li><li class="alt">   </li><li>/**  </li><li class="alt"> * 一旦没有指向 key 的强引用, WeakHashMap 在 GC 后将自动删除相关的 entry  </li><li> */  </li><li class="alt">assertFalse(weakHashMap.containsValue(value));   </li><li>}   </li><li class="alt"> </li><li> @Test  </li><li class="alt"> public void weakHashMap() throws InterruptedException {  </li><li>  Map<strong><span style="color:#006699"><span class="tag">&lt;</span><span class="tag-name">Object</span></span></strong>, Object<span class="tag"><strong><span style="color:#006699">&gt;</span></strong></span> <span class="attribute"><span style="color:#ff0000">weakHashMap</span></span> = <span class="attribute-value"><span style="color:#0000ff">new</span></span> WeakHashMap<strong><span style="color:#006699"><span class="tag">&lt;</span><span class="tag-name">Object</span></span></strong>, Object<span class="tag"><strong><span style="color:#006699">&gt;</span></strong></span>();  </li><li class="alt">  Object <span class="attribute"><span style="color:#ff0000">key</span></span> = <span class="attribute-value"><span style="color:#0000ff">new</span></span> Object();  </li><li>  Object <span class="attribute"><span style="color:#ff0000">value</span></span> = <span class="attribute-value"><span style="color:#0000ff">new</span></span> Object();  </li><li class="alt">  weakHashMap.put(key, value);  </li><li>   </li><li class="alt">  assertTrue(weakHashMap.containsValue(value));  </li><li>    </li><li class="alt">  <span class="attribute"><span style="color:#ff0000">key</span></span> = <span class="attribute-value"><span style="color:#0000ff">null</span></span>;  </li><li>  System.gc();  </li><li class="alt">    </li><li>  /**  </li><li class="alt">   * 等待无效 entries 进入 ReferenceQueue 以便下一次调用 getTable 时被清理  </li><li>   */  </li><li class="alt">  Thread.sleep(1000);  </li><li>    </li><li class="alt">  /**  </li><li>   * 一旦没有指向 key 的强引用, WeakHashMap 在 GC 后将自动删除相关的 entry  </li><li class="alt">   */  </li><li>  assertFalse(weakHashMap.containsValue(value));  </li><li class="alt"> } </li></ol></pre> 
<p>3. SoftReference</p> 
<p>SoftReference 于 WeakReference 的特性基本一致， 最大的区别在于 SoftReference 会尽可能长的保留引用直到 JVM 内存不足时才会被回收(虚拟机保证), 这一特性使得 SoftReference 非常适合缓存应用</p> 
<pre> 
 <ol class="dp-xml"><li class="alt">@Test  </li><li>public void softReference() {   </li><li class="alt">Object <span class="attribute"><span style="color:#ff0000">referent</span></span> = <span class="attribute-value"><span style="color:#0000ff">new</span></span> Object();   </li><li>SoftReference<strong><span style="color:#006699"><span class="tag">&lt;</span><span class="tag-name">Object</span><span class="tag">&gt;</span></span></strong> <span class="attribute"><span style="color:#ff0000">softRerference</span></span> = <span class="attribute-value"><span style="color:#0000ff">new</span></span> SoftReference<strong><span style="color:#006699"><span class="tag">&lt;</span><span class="tag-name">Object</span><span class="tag">&gt;</span></span></strong>(referent);   </li><li class="alt"> </li><li>assertNotNull(softRerference.get());   </li><li class="alt">   </li><li><span class="attribute"><span style="color:#ff0000">referent</span></span> = <span class="attribute-value"><span style="color:#0000ff">null</span></span>;   </li><li class="alt">System.gc();   </li><li>   </li><li class="alt">/**  </li><li> *soft references 只有在 jvm OutOfMemory 之前才会被回收, 所以它非常适合缓存应用  </li><li class="alt"> */  </li><li>assertNotNull(softRerference.get());   </li><li class="alt">}   </li><li> </li><li class="alt"> @Test  </li><li> public void softReference() {  </li><li class="alt">  Object <span class="attribute"><span style="color:#ff0000">referent</span></span> = <span class="attribute-value"><span style="color:#0000ff">new</span></span> Object();  </li><li>  SoftReference<strong><span style="color:#006699"><span class="tag">&lt;</span><span class="tag-name">Object</span><span class="tag">&gt;</span></span></strong> <span class="attribute"><span style="color:#ff0000">softRerference</span></span> = <span class="attribute-value"><span style="color:#0000ff">new</span></span> SoftReference<strong><span style="color:#006699"><span class="tag">&lt;</span><span class="tag-name">Object</span><span class="tag">&gt;</span></span></strong>(referent);  </li><li class="alt">   </li><li>  assertNotNull(softRerference.get());  </li><li class="alt">    </li><li>  <span class="attribute"><span style="color:#ff0000">referent</span></span> = <span class="attribute-value"><span style="color:#0000ff">null</span></span>;  </li><li class="alt">  System.gc();  </li><li>    </li><li class="alt">  /**  </li><li>   *soft references 只有在 jvm OutOfMemory 之前才会被回收, 所以它非常适合缓存应用  </li><li class="alt">   */  </li><li>  assertNotNull(softRerference.get());  </li><li class="alt"> } </li></ol></pre> 
<p>4. PhantomReference</p> 
<p>作为本文主角， Phantom Reference(幽灵引用) 与 WeakReference 和 SoftReference 有很大的不同,因为它的 get() 方法永远返回 null, 这也正是它名字的由来</p> 
<pre> 
 <ol class="dp-xml"><li class="alt">@Test  </li><li>public void phantomReferenceAlwaysNull() {   </li><li class="alt">Object <span class="attribute"><span style="color:#ff0000">referent</span></span> = <span class="attribute-value"><span style="color:#0000ff">new</span></span> Object();   </li><li>PhantomReference<strong><span style="color:#006699"><span class="tag">&lt;</span><span class="tag-name">Object</span><span class="tag">&gt;</span></span></strong> <span class="attribute"><span style="color:#ff0000">phantomReference</span></span> = <span class="attribute-value"><span style="color:#0000ff">new</span></span> PhantomReference<strong><span style="color:#006699"><span class="tag">&lt;</span><span class="tag-name">Object</span><span class="tag">&gt;</span></span></strong>(referent, new ReferenceQueue<strong><span style="color:#006699"><span class="tag">&lt;</span><span class="tag-name">Object</span><span class="tag">&gt;</span></span></strong>());   </li><li class="alt">   </li><li>/**  </li><li class="alt"> * phantom reference 的 get 方法永远返回 null   </li><li> */  </li><li class="alt">assertNull(phantomReference.get());   </li><li>}   </li><li class="alt"> </li><li> @Test  </li><li class="alt"> public void phantomReferenceAlwaysNull() {  </li><li>  Object <span class="attribute"><span style="color:#ff0000">referent</span></span> = <span class="attribute-value"><span style="color:#0000ff">new</span></span> Object();  </li><li class="alt">  PhantomReference<strong><span style="color:#006699"><span class="tag">&lt;</span><span class="tag-name">Object</span><span class="tag">&gt;</span></span></strong> <span class="attribute"><span style="color:#ff0000">phantomReference</span></span> = <span class="attribute-value"><span style="color:#0000ff">new</span></span> PhantomReference<strong><span style="color:#006699"><span class="tag">&lt;</span><span class="tag-name">Object</span><span class="tag">&gt;</span></span></strong>(referent, new ReferenceQueue<strong><span style="color:#006699"><span class="tag">&lt;</span><span class="tag-name">Object</span><span class="tag">&gt;</span></span></strong>());  </li><li>    </li><li class="alt">  /**  </li><li>   * phantom reference 的 get 方法永远返回 null   </li><li class="alt">   */  </li><li>  assertNull(phantomReference.get());  </li><li class="alt"> } </li></ol></pre> 
<p>诸位可能要问, 一个永远返回 null 的 reference 要来何用,请注意构造 PhantomReference 时的第二个参数 ReferenceQueue(事实上 WeakReference &amp; SoftReference 也可以有这个参数)，<br> PhantomReference 唯一的用处就是跟踪 referent何时被 enqueue 到 ReferenceQueue 中.</p> 
<p>5. RererenceQueue</p> 
<p>当一个 WeakReference 开始返回 null 时， 它所指向的对象已经准备被回收， 这时可以做一些合适的清理工作. 将一个 ReferenceQueue 传给一个 Reference 的构造函数， 当对象被回收时， 虚拟机会自动将这个对象插入到 ReferenceQueue 中， WeakHashMap 就是利用 ReferenceQueue 来清除 key 已经没有强引用的 entries.</p> 
<pre> 
 <ol class="dp-xml"><li class="alt">@Test  </li><li>public void referenceQueue() throws InterruptedException {   </li><li class="alt">Object <span class="attribute"><span style="color:#ff0000">referent</span></span> = <span class="attribute-value"><span style="color:#0000ff">new</span></span> Object();  </li><li>ReferenceQueue<strong><span style="color:#006699"><span class="tag">&lt;</span><span class="tag-name">Object</span><span class="tag">&gt;</span></span></strong> <span class="attribute"><span style="color:#ff0000">referenceQueue</span></span> = <span class="attribute-value"><span style="color:#0000ff">new</span></span> ReferenceQueue<strong><span style="color:#006699"><span class="tag">&lt;</span><span class="tag-name">Object</span><span class="tag">&gt;</span></span></strong>();   </li><li class="alt">WeakReference<strong><span style="color:#006699"><span class="tag">&lt;</span><span class="tag-name">Object</span><span class="tag">&gt;</span></span></strong> <span class="attribute"><span style="color:#ff0000">weakReference</span></span> = <span class="attribute-value"><span style="color:#0000ff">new</span></span> WeakReference<strong><span style="color:#006699"><span class="tag">&lt;</span><span class="tag-name">Object</span><span class="tag">&gt;</span></span></strong>(referent, referenceQueue);   </li><li>   </li><li class="alt">assertFalse(weakReference.isEnqueued());   </li><li>Reference<span class="tag"><strong><span style="color:#006699">&lt;?</span></strong></span> <span class="tag-name"><strong><span style="color:#006699">extends</span></strong></span> Object<span class="tag"><strong><span style="color:#006699">&gt;</span></strong></span> <span class="attribute"><span style="color:#ff0000">polled</span></span> = <span class="attribute-value"><span style="color:#0000ff">referenceQueue</span></span>.poll();   </li><li class="alt">assertNull(polled);   </li><li>   </li><li class="alt"><span class="attribute"><span style="color:#ff0000">referent</span></span> = <span class="attribute-value"><span style="color:#0000ff">null</span></span>;   </li><li>System.gc();   </li><li class="alt"> </li><li>assertTrue(weakReference.isEnqueued());   </li><li class="alt">Reference<span class="tag"><strong><span style="color:#006699">&lt;?</span></strong></span> <span class="tag-name"><strong><span style="color:#006699">extends</span></strong></span> Object<span class="tag"><strong><span style="color:#006699">&gt;</span></strong></span> <span class="attribute"><span style="color:#ff0000">removed</span></span> = <span class="attribute-value"><span style="color:#0000ff">referenceQueue</span></span>.remove();   </li><li>assertNotNull(removed);   </li><li class="alt">}  </li><li> </li><li class="alt"> @Test  </li><li> public void referenceQueue() throws InterruptedException {  </li><li class="alt">  Object <span class="attribute"><span style="color:#ff0000">referent</span></span> = <span class="attribute-value"><span style="color:#0000ff">new</span></span> Object();    </li><li>  ReferenceQueue<strong><span style="color:#006699"><span class="tag">&lt;</span><span class="tag-name">Object</span><span class="tag">&gt;</span></span></strong> <span class="attribute"><span style="color:#ff0000">referenceQueue</span></span> = <span class="attribute-value"><span style="color:#0000ff">new</span></span> ReferenceQueue<strong><span style="color:#006699"><span class="tag">&lt;</span><span class="tag-name">Object</span><span class="tag">&gt;</span></span></strong>();  </li><li class="alt">  WeakReference<strong><span style="color:#006699"><span class="tag">&lt;</span><span class="tag-name">Object</span><span class="tag">&gt;</span></span></strong> <span class="attribute"><span style="color:#ff0000">weakReference</span></span> = <span class="attribute-value"><span style="color:#0000ff">new</span></span> WeakReference<strong><span style="color:#006699"><span class="tag">&lt;</span><span class="tag-name">Object</span><span class="tag">&gt;</span></span></strong>(referent, referenceQueue);  </li><li>    </li><li class="alt">  assertFalse(weakReference.isEnqueued());  </li><li>  Reference<span class="tag"><strong><span style="color:#006699">&lt;?</span></strong></span> <span class="tag-name"><strong><span style="color:#006699">extends</span></strong></span> Object<span class="tag"><strong><span style="color:#006699">&gt;</span></strong></span> <span class="attribute"><span style="color:#ff0000">polled</span></span> = <span class="attribute-value"><span style="color:#0000ff">referenceQueue</span></span>.poll();  </li><li class="alt">  assertNull(polled);  </li><li>    </li><li class="alt">  <span class="attribute"><span style="color:#ff0000">referent</span></span> = <span class="attribute-value"><span style="color:#0000ff">null</span></span>;  </li><li>  System.gc();  </li><li class="alt"> </li><li>  assertTrue(weakReference.isEnqueued());  </li><li class="alt">  Reference<span class="tag"><strong><span style="color:#006699">&lt;?</span></strong></span> <span class="tag-name"><strong><span style="color:#006699">extends</span></strong></span> Object<span class="tag"><strong><span style="color:#006699">&gt;</span></strong></span> <span class="attribute"><span style="color:#ff0000">removed</span></span> = <span class="attribute-value"><span style="color:#0000ff">referenceQueue</span></span>.remove();  </li><li>  assertNotNull(removed);  </li><li class="alt"> } </li></ol></pre> 
<p><br> 6.PhantomReferencevs WeakReference</p> 
<p>PhantomReference有两个好处， 其一， 它可以让我们准确地知道对象何时被从内存中删除， 这个特性可以被用于一些特殊的需求中(例如 Distributed GC，XWork 和 google-guice 中也使用 PhantomReference 做了一些清理性工作). </p> 
<p>其二， 它可以避免 finalization 带来的一些根本性问题, 上文提到 PhantomReference 的唯一作用就是跟踪 referent 何时被 enqueue 到 ReferenceQueue 中,但是 WeakReference 也有对应的功能, 两者的区别到底在哪呢 ?<br> 这就要说到 Object 的 finalize 方法, 此方法将在 gc 执行前被调用, 如果某个对象重载了 finalize 方法并故意在方法内创建本身的强引用,这将导致这一轮的 GC 无法回收这个对象并有可能<br> 引起任意次 GC， 最后的结果就是明明 JVM 内有很多 Garbage 却 OutOfMemory， 使用 PhantomReference 就可以避免这个问题， 因为 PhantomReference 是在 finalize 方法执行后回收的，也就意味着此时已经不可能拿到原来的引用,也就不会出现上述问题,当然这是一个很极端的例子, 一般不会出现. </p> 
<p>7. 对比 </p> 
<p><span style="font-family:'tiresias pcfont z'; font-size:16px; color:#421f00"></span></p> 
<table class="standard" border="0"><thead><tr><th colspan="5" style="padding-bottom:5px; background-color:#95cbff; padding-left:5px; padding-right:5px; display:table-cell; font-family:calibri,'bitstream vera sans','segoe ui',arial,helvetica,sans-serif; color:#000000; font-size:1.08em; font-weight:bold; padding-top:5px"> Soft vs Weak vs Phantom References</th></tr><tr><th style="padding-bottom:5px; background-color:#95cbff; padding-left:5px; padding-right:5px; display:table-cell; font-family:calibri,'bitstream vera sans','segoe ui',arial,helvetica,sans-serif; color:#000000; font-size:1.08em; font-weight:bold; padding-top:5px"> Type</th><th style="padding-bottom:5px; background-color:#95cbff; padding-left:5px; padding-right:5px; display:table-cell; font-family:calibri,'bitstream vera sans','segoe ui',arial,helvetica,sans-serif; color:#000000; font-size:1.08em; font-weight:bold; padding-top:5px"> Purpose</th><th style="padding-bottom:5px; background-color:#95cbff; padding-left:5px; padding-right:5px; display:table-cell; font-family:calibri,'bitstream vera sans','segoe ui',arial,helvetica,sans-serif; color:#000000; font-size:1.08em; font-weight:bold; padding-top:5px"> Use</th><th style="padding-bottom:5px; background-color:#95cbff; padding-left:5px; padding-right:5px; display:table-cell; font-family:calibri,'bitstream vera sans','segoe ui',arial,helvetica,sans-serif; color:#000000; font-size:1.08em; font-weight:bold; padding-top:5px"> When GCed</th><th style="padding-bottom:5px; background-color:#95cbff; padding-left:5px; padding-right:5px; display:table-cell; font-family:calibri,'bitstream vera sans','segoe ui',arial,helvetica,sans-serif; color:#000000; font-size:1.08em; font-weight:bold; padding-top:5px"> Implementing Class</th></tr></thead><tbody><tr><td style="padding-bottom:5px; line-height:1.2em; padding-left:5px; padding-right:5px; font-size:1em; padding-top:5px"> Strong Reference</td><td style="padding-bottom:5px; line-height:1.2em; padding-left:5px; padding-right:5px; font-size:1em; padding-top:5px"> An ordinary reference. Keeps objects alive as long as they are referenced.</td><td style="padding-bottom:5px; line-height:1.2em; padding-left:5px; padding-right:5px; font-size:1em; padding-top:5px"> normal reference.</td><td style="padding-bottom:5px; line-height:1.2em; padding-left:5px; padding-right:5px; font-size:1em; padding-top:5px"> Any object not pointed to can be reclaimed.</td><td style="padding-bottom:5px; line-height:1.2em; padding-left:5px; padding-right:5px; font-size:1em; padding-top:5px"> default</td></tr><tr><td style="padding-bottom:5px; line-height:1.2em; padding-left:5px; padding-right:5px; font-size:1em; padding-top:5px"> Soft Reference</td><td style="padding-bottom:5px; line-height:1.2em; padding-left:5px; padding-right:5px; font-size:1em; padding-top:5px"> Keeps objects alive provided there’s enough memory.</td><td style="padding-bottom:5px; line-height:1.2em; padding-left:5px; padding-right:5px; font-size:1em; padding-top:5px"> to keep objects alive even after clients have removed their references (memory-sensitive caches), in case clients start asking for them again by key.</td><td style="padding-bottom:5px; line-height:1.2em; padding-left:5px; padding-right:5px; font-size:1em; padding-top:5px"> After a first gc pass, the JVM decides it still needs to reclaim more space.</td><td style="padding-bottom:5px; line-height:1.2em; padding-left:5px; padding-right:5px; font-size:1em; padding-top:5px"> <span class="package">java.lang.ref.</span><span style="font-family:Consolas,'Bitstream Vera Sans Mono','Lucida Console','Lucida Sans','Lucida Sans Unicode',Courier,'Courier New','Segoe UI',Arial,monospace; color:#653510; background-color:transparent">SoftReference</span></td></tr><tr><td style="padding-bottom:5px; line-height:1.2em; padding-left:5px; padding-right:5px; font-size:1em; padding-top:5px"> Weak Reference</td><td style="padding-bottom:5px; line-height:1.2em; padding-left:5px; padding-right:5px; font-size:1em; padding-top:5px"> Keeps objects alive only while they’re in use (reachable) by clients.</td><td style="padding-bottom:5px; line-height:1.2em; padding-left:5px; padding-right:5px; font-size:1em; padding-top:5px"> Containers that automatically delete objects no longer in use.</td><td style="padding-bottom:5px; line-height:1.2em; padding-left:5px; padding-right:5px; font-size:1em; padding-top:5px"> After gc determines the object is only weakly reachable</td><td style="padding-bottom:5px; line-height:1.2em; padding-left:5px; padding-right:5px; font-size:1em; padding-top:5px"> <span class="package">java.lang.ref.</span><span style="font-family:Consolas,'Bitstream Vera Sans Mono','Lucida Console','Lucida Sans','Lucida Sans Unicode',Courier,'Courier New','Segoe UI',Arial,monospace; color:#653510; background-color:transparent">WeakReference</span> <br> <span class="package">java.util.</span><span style="font-family:Consolas,'Bitstream Vera Sans Mono','Lucida Console','Lucida Sans','Lucida Sans Unicode',Courier,'Courier New','Segoe UI',Arial,monospace; color:#653510; background-color:transparent">WeakHashMap</span></td></tr><tr><td style="padding-bottom:5px; line-height:1.2em; padding-left:5px; padding-right:5px; font-size:1em; padding-top:5px"> Phantom Reference</td><td style="padding-bottom:5px; line-height:1.2em; padding-left:5px; padding-right:5px; font-size:1em; padding-top:5px"> Lets you clean up after finalization but before the space is reclaimed (replaces or augments the use of<span class="method">finalize</span>())</td><td style="padding-bottom:5px; line-height:1.2em; padding-left:5px; padding-right:5px; font-size:1em; padding-top:5px"> Special clean up processing</td><td style="padding-bottom:5px; line-height:1.2em; padding-left:5px; padding-right:5px; font-size:1em; padding-top:5px"> After finalization.</td><td style="padding-bottom:5px; line-height:1.2em; padding-left:5px; padding-right:5px; font-size:1em; padding-top:5px"> <span class="package">java.lang.ref.</span><span style="font-family:Consolas,'Bitstream Vera Sans Mono','Lucida Console','Lucida Sans','Lucida Sans Unicode',Courier,'Courier New','Segoe UI',Arial,monospace; color:#653510; background-color:transparent">PhantomReference<br> </span></td></tr></tbody></table> 
<p><br> </p> 
<p><strong>8. Java GC小结<br> </strong> 一般的应用程序不会涉及到 Reference 编程， 但是了解这些知识会对理解Java GC 的工作原理以及性能调优有一定帮助, 在实现一些基础性设施比如缓存时也可能会用到， 希望本文能有所帮助.</p> 
<br>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/29721cf88ae5070685b5705532acd11a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">2011最新QQ大盗使用教程</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3db8185214c6dcb41be944effa7d0011/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">LCD 基本知识</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>