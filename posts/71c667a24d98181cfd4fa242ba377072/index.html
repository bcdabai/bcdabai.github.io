<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>中文NLP工具介绍 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="中文NLP工具介绍" />
<meta property="og:description" content="https://blog.csdn.net/KnightTen/article/details/89138602
中文 NLP 工具总结
KnightTen 2019-04-09 11:00:44 3419 收藏 10
展开
文章目录
中文 NLP 工具总结
1. Jieba 分词
1.1 简介
1.2 模型原理
1.3 安装
1.4 使用
1.5 分词评测
2. pyltp——哈工大
2.1 简介
2.2 模型原理
2.2.1 分词
2.2.2 词性标注
2.2.3 依存分析
2.3 安装
2.4 使用
2.4.1 分词
2.4.2 词性标注
2.4.3 依存分析
2.4.4 分词、词性标注和依存分析的整合
2.5 分词评测
3. thulca——清华
3.1 简介
3.2 模型原理
3.3 安装
3.4 使用
3.5 分词评测
4. NLPIR —— 中科院" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/71c667a24d98181cfd4fa242ba377072/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-05-22T08:45:36+08:00" />
<meta property="article:modified_time" content="2020-05-22T08:45:36+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">中文NLP工具介绍</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>https://blog.csdn.net/KnightTen/article/details/89138602</p> 
<p>中文 NLP 工具总结<br> KnightTen 2019-04-09 11:00:44 3419 收藏 10<br> 展开</p> 
<p>文章目录</p> 
<p>    中文 NLP 工具总结<br>         1. Jieba 分词<br>             1.1 简介<br>             1.2 模型原理<br>             1.3 安装<br>             1.4 使用<br>             1.5 分词评测<br>         2. pyltp——哈工大<br>             2.1 简介<br>             2.2 模型原理<br>                 2.2.1 分词<br>                 2.2.2 词性标注<br>                 2.2.3 依存分析<br>             2.3 安装<br>             2.4 使用<br>                 2.4.1 分词<br>                 2.4.2 词性标注<br>                 2.4.3 依存分析<br>                 2.4.4 分词、词性标注和依存分析的整合<br>             2.5 分词评测<br>         3. thulca——清华<br>             3.1 简介<br>             3.2 模型原理<br>             3.3 安装<br>             3.4 使用<br>             3.5 分词评测<br>         4. NLPIR —— 中科院<br>             4.1 简介<br>             4.2 模型原理<br>             4.3 安装<br>             4.4 使用<br>             4.5 分词评测<br>         5. Zpar —— 新加坡科技大学<br>             5.1 简介<br>             5.2 模型原理<br>             5.3 安装<br>             5.4 使用<br>                 5.4.1 训练<br>                 5.4.2 使用训练的模型进行分词<br>             5.5 分词评测<br>         6. CoreNLP —— 斯坦福大学<br>             6.1 简介<br>             6.2 模型原理<br>             6.3——6.4 安装与使用<br>             6.5 分词评测<br>         7. Hanlp —— 开源库<br>             7.1 简介<br>             7.2 模型原理<br>             7.3 安装<br>             7.4 使用<br>             7.5 分词评测<br>         8. 对比总结<br>             8.1 分词对比<br>             8.2 各个工具的词性标注体系<br>             8.3 各个工具所支持的功能<br>         9. 附录</p> 
<p>中文 NLP 工具总结</p> 
<p>前言： 最近由于实验室研究需要，需要调研一下目前已有的中文 NLP 工具，于是在调研完了之后就写了这篇总结，如果哪里有错误还请指出。<br> 1. Jieba 分词<br> 1.1 简介</p> 
<p>官网介绍：“结巴”中文分词：做最好的 Python 中文分词组件</p> 
<p>但是不是最好的呢？详情见最后的横向对比。</p> 
<p>GitHub地址：https://github.com/fxsjy/jieba<br> 1.2 模型原理</p> 
<p>    基于前缀词典实现高效的词图扫描，生成句子中汉字所有可能成词情况所构成的有向无环图 (DAG)<br>     采用了动态规划查找最大概率路径, 找出基于词频的最大切分组合<br>     对于未登录词，采用了基于汉字成词能力的 HMM 模型，使用了 Viterbi 算法</p> 
<p>1.3 安装</p> 
<p>安装方式很简单，只要一个命令即可：</p> 
<p>pip install jieba<br> #或者<br> pip3 install jieba</p> 
<p>    1<br>     2<br>     3</p> 
<p>1.4 使用</p> 
<p># encoding=utf-8<br> import jieba</p> 
<p>seg_list = jieba.cut("我来到北京清华大学", cut_all=True)<br> print("Full Mode: " + "/ ".join(seg_list))  # 全模式</p> 
<p>seg_list = jieba.cut("我来到北京清华大学", cut_all=False)<br> print("Default Mode: " + "/ ".join(seg_list))  # 精确模式</p> 
<p>seg_list = jieba.cut("他来到了网易杭研大厦")  # 默认是精确模式<br> print(", ".join(seg_list))</p> 
<p>seg_list = jieba.cut_for_search("小明硕士毕业于中国科学院计算所，后在日本京都大学深造")  # 搜索引擎模式<br> print(", ".join(seg_list))</p> 
<p>    1<br>     2<br>     3<br>     4<br>     5<br>     6<br>     7<br>     8<br>     9<br>     10<br>     11<br>     12<br>     13<br>     14</p> 
<p>输出：</p> 
<p>【全模式】: 我/ 来到/ 北京/ 清华/ 清华大学/ 华大/ 大学</p> 
<p>【精确模式】: 我/ 来到/ 北京/ 清华大学</p> 
<p>【新词识别】：他, 来到, 了, 网易, 杭研, 大厦    (此处，“杭研”并没有在词典中，但是也被Viterbi算法识别出来了)</p> 
<p>【搜索引擎模式】： 小明, 硕士, 毕业, 于, 中国, 科学, 学院, 科学院, 中国科学院, 计算, 计算所, 后, 在, 日本, 京都, 大学, 日本京都大学, 深造</p> 
<p>    1<br>     2<br>     3<br>     4<br>     5<br>     6<br>     7</p> 
<p>1.5 分词评测<br>     ctb6     msra     pku<br> jieba     80.79     81.45     81.82<br> 2. pyltp——哈工大<br> 2.1 简介</p> 
<p>pyltp 是 LTP 的 Python 封装，提供了分词，词性标注，命名实体识别，依存句法分析，语义角色标注的功能。</p> 
<p>官网：https://ltp.readthedocs.io/zh_CN/latest/begin.html</p> 
<p>官方pyltp介绍：https://pyltp.readthedocs.io/zh_CN/develop/api.html</p> 
<p>标注体系等详细介绍：http://www.ltp-cloud.com/intro</p> 
<p>GitHub 主页：https://github.com/HIT-SCIR/pyltp<br> 2.2 模型原理<br> 2.2.1 分词</p> 
<p>基于字的序列标注，对于输入句子的字序列，模型给句子中的每个字标注一个标识词边界的标记，通过机器学习算法框架从标注数据中学习参数。<br> 2.2.2 词性标注</p> 
<p>与分词模块相同，将词性标注任务建模为基于词的序列标注问题。对于输入句子的词序列，模型给句子中的每个词标注一个标识词边界的标记。<br> 2.2.3 依存分析</p> 
<p>依存句法分析模块的主要算法依据神经网络依存句法分析算法，Chen and Manning (2014)。同时加入丰富的全局特征和聚类特征。在模型训练时，我们也参考了Yoav等人关于dynamic oracle的工作。<br> 2.3 安装</p> 
<p>    安装 pyltp 的包</p> 
<p>pip install pyltp</p> 
<p>    1</p> 
<p>    下载模型文件：https://pan.baidu.com/share/link?shareid=1988562907&amp;uk=2738088569#list/path=%2F</p> 
<p>目前最新的模型是 3.4.0 ，解压之……<br> pyltp目录<br> 2.4 使用<br> 2.4.1 分词</p> 
<p># -*- coding: utf-8 -*-<br> import os<br> LTP_DATA_DIR = '/home/username/pyltp/ltp_model'  # ltp模型目录的路径<br> cws_model_path = os.path.join(LTP_DATA_DIR, 'cws.model')  # 分词模型路径，模型名称为`cws.model`</p> 
<p>from pyltp import Segmentor<br> segmentor = Segmentor()  # 初始化实例<br> segmentor.load(cws_model_path)  # 加载模型<br> words = segmentor.segment('元芳你怎么看')  # 分词<br> print(list(words))<br> for word in list(words):<br>     print(word)<br> segmentor.release()  # 释放模型</p> 
<p>    1<br>     2<br>     3<br>     4<br>     5<br>     6<br>     7<br>     8<br>     9<br>     10<br>     11<br>     12<br>     13</p> 
<p>输出：</p> 
<p>['元芳', '你', '怎么', '看']<br> 元芳<br> 你<br> 怎么<br> 看</p> 
<p>    1<br>     2<br>     3<br>     4<br>     5</p> 
<p>2.4.2 词性标注</p> 
<p># -*- coding: utf-8 -*-<br> import os<br> LTP_DATA_DIR = '/home/knight/pyltp/ltp_model'  # ltp模型目录的路径<br> pos_model_path = os.path.join(LTP_DATA_DIR, 'pos.model')  # 词性标注模型路径，模型名称为`pos.model`</p> 
<p>from pyltp import Postagger<br> postagger = Postagger() # 初始化实例<br> postagger.load(pos_model_path)  # 加载模型</p> 
<p>words = ['元芳', '你', '怎么', '看']  # 分词结果<br> postags = postagger.postag(words)  # 词性标注</p> 
<p>print('\t'.join(postags))<br> postagger.release()  # 释放模型</p> 
<p>    1<br>     2<br>     3<br>     4<br>     5<br>     6<br>     7<br>     8<br>     9<br>     10<br>     11<br>     12<br>     13<br>     14</p> 
<p>输出：</p> 
<p>nh    r    r    v</p> 
<p>    1</p> 
<p>2.4.3 依存分析</p> 
<p># -*- coding: utf-8 -*-<br> import os<br> LTP_DATA_DIR = '/home/username/pyltp/ltp_model'  # ltp模型目录的路径<br> par_model_path = os.path.join(LTP_DATA_DIR, 'parser.model')  # 依存句法分析模型路径，模型名称为`parser.model`</p> 
<p>from pyltp import Parser<br> parser = Parser() # 初始化实例<br> parser.load(par_model_path)  # 加载模型</p> 
<p>words = ['元芳', '你', '怎么', '看']<br> postags = ['nh', 'r', 'r', 'v']<br> arcs = parser.parse(words, postags)  # 句法分析</p> 
<p>print("\t".join("%d:%s" % (arc.head, arc.relation) for arc in arcs))<br> parser.release()  # 释放模型</p> 
<p>    1<br>     2<br>     3<br>     4<br>     5<br>     6<br>     7<br>     8<br>     9<br>     10<br>     11<br>     12<br>     13<br>     14<br>     15</p> 
<p>输出：</p> 
<p>4:SBV    4:SBV    4:ADV    0:HED</p> 
<p>    1</p> 
<p>2.4.4 分词、词性标注和依存分析的整合</p> 
<p># -*- coding: utf-8 -*-<br> import os<br> LTP_DATA_DIR = '/home/username/pyltp/ltp_model'  # ltp模型目录的路径<br> cws_model_path = os.path.join(LTP_DATA_DIR, 'cws.model')  # 分词模型路径，模型名称为`cws.model`</p> 
<p>pos_model_path = os.path.join(LTP_DATA_DIR, 'pos.model')  # 词性标注模型路径，模型名称为`pos.model`</p> 
<p>parse_model_path = os.path.join(LTP_DATA_DIR, 'parser.model')  # 词性标注模型路径，模型名称为`parser.model`</p> 
<p>from pyltp import Segmentor, Postagger, Parser</p> 
<p>class PyltpTool:</p> 
<p>    def __init__(self, filname, corpus_name):<br>         self.filname = filname<br>         self.corpus_name = corpus_name<br>         self.segmentor = Segmentor()  # 初始化实例<br>         self.segmentor.load(cws_model_path)  # 加载模型<br>         self.postagger = Postagger()<br>         self.postagger.load(pos_model_path)<br>         self.parser = Parser()<br>         self.parser.load(parse_model_path)<br>         self.raw_data = []<br>         self.seg_sentences= []<br>         self.pos_tags = []<br>         self.deps = []</p> 
<p>    def read_data_from_file(self):<br>         with open(self.filname, encoding='utf-8') as f_obj:<br>             data = f_obj.readlines()<br>             for row in data:<br>                 self.raw_data.append(row.rstrip())<br>         print(self.raw_data)</p> 
<p>    def get_seg_sentences(self):<br>         for sentence in self.raw_data:<br>             seg_sentence = self.segmentor.segment(sentence)<br>             self.seg_sentences.append(list(seg_sentence))<br>         print(self.seg_sentences)<br>         self.write_to_file(self.seg_sentences, "pyltp_" + self.corpus_name + "_seg_sentences.txt")</p> 
<p>    def get_pos_tags(self):<br>         for seg_sentence in self.seg_sentences:<br>             pos_tag = self.postagger.postag(seg_sentence)<br>             self.pos_tags.append(list(pos_tag))<br>         print(self.pos_tags)<br>         self.write_to_file(self.pos_tags, "pyltp_" + self.corpus_name + "_pos_tags.txt")</p> 
<p>    def get_deps(self):<br>         index = 0<br>         while index &lt; len(self.pos_tags):<br>             dep = self.parser.parse(self.seg_sentences[index], self.pos_tags[index])<br>             dep_list = [str(dep_info.head) for dep_info in dep]<br>             self.deps.append(dep_list)<br>             index += 1<br>         print(self.deps)<br>         self.write_to_file(self.deps, "pyltp_" + self.corpus_name + "_deps.txt")</p> 
<p>    def write_to_file(self, data, filename):<br>         with open(filename, 'w', encoding='utf-8') as f_obj:<br>             for row in data:<br>                 for char in row:<br>                     f_obj.write(char + " ")<br>                 f_obj.write('\n')<br>             <br>     def realease(self):<br>         self.segmentor.release()<br>         self.postagger.release()<br>         self.parser.release()</p> 
<p>#输入存放一行一行句子的文件，分别输出分词、词性标注和依存分析三个文件。<br> ctb6_pyltp_tool = PyltpTool("raw_ctb6_test.txt", "ctb6")<br> ctb6_pyltp_tool.read_data_from_file()<br> ctb6_pyltp_tool.get_seg_sentences()<br> ctb6_pyltp_tool.get_pos_tags()<br> ctb6_pyltp_tool.get_deps()<br> ctb6_pyltp_tool.realease()</p> 
<p>    1<br>     2<br>     3<br>     4<br>     5<br>     6<br>     7<br>     8<br>     9<br>     10<br>     11<br>     12<br>     13<br>     14<br>     15<br>     16<br>     17<br>     18<br>     19<br>     20<br>     21<br>     22<br>     23<br>     24<br>     25<br>     26<br>     27<br>     28<br>     29<br>     30<br>     31<br>     32<br>     33<br>     34<br>     35<br>     36<br>     37<br>     38<br>     39<br>     40<br>     41<br>     42<br>     43<br>     44<br>     45<br>     46<br>     47<br>     48<br>     49<br>     50<br>     51<br>     52<br>     53<br>     54<br>     55<br>     56<br>     57<br>     58<br>     59<br>     60<br>     61<br>     62<br>     63<br>     64<br>     65<br>     66<br>     67<br>     68<br>     69<br>     70<br>     71<br>     72<br>     73<br>     74<br>     75<br>     76<br>     77</p> 
<p>2.5 分词评测<br>     ctb6     msra     pku<br> pyltp     91.81     88.34     95.32<br> 3. thulca——清华<br> 3.1 简介</p> 
<p>THULAC（THU Lexical Analyzer for Chinese）由清华大学自然语言处理与社会人文计算实验室研制推出的一套中文词法分析工具包，具有中文分词和词性标注功能。THULAC具有如下几个特点：</p> 
<p>    能力强。利用我们集成的目前世界上规模最大的人工分词和词性标注中文语料库（约含5800万字）训练而成，模型标注能力强大。<br>     准确率高。该工具包在标准数据集Chinese Treebank（CTB5）上分词的F1值可达97.3％，词性标注的F1值可达到92.9％，与该数据集上最好方法效果相当。<br>     速度较快。同时进行分词和词性标注速度为300KB/s，每秒可处理约15万字。只进行分词速度可达到1.3MB/s。</p> 
<p>官网：http://thulac.thunlp.org/</p> 
<p>GitHub地址：https://github.com/thunlp/THULAC-Python<br> 3.2 模型原理</p> 
<p>看官方介绍应该是基于概率语言模型的。<br> 3.3 安装</p> 
<p>sudo pip install thulac</p> 
<p>    1</p> 
<p>3.4 使用</p> 
<p># encoding=utf-8<br> import thulac  </p> 
<p>thu1 = thulac.thulac(seg_only=True)  #默认模式<br> thu1.cut_f("raw_ctb6_test.txt", "thulca_ctb6_seg_sentences.txt")<br> thu1.cut_f("raw_msra_test.txt", "thulca_msra_seg_sentences.txt")<br> thu1.cut_f("raw_pku_test.txt", "thulca_pku_seg_sentences.txt")</p> 
<p>    1<br>     2<br>     3<br>     4<br>     5<br>     6<br>     7</p> 
<p>3.5 分词评测<br>     ctb6     msra     pku<br> thulca     88.94     85.56     92.28<br> 4. NLPIR —— 中科院<br> 4.1 简介</p> 
<p>主要功能包括中文分词；英文分词；词性标注；命名实体识别；新词识别；关键词提取；支持用户专业词典与微博分析。NLPIR系统支持多种编码、多种操作系统、多种开发语言与平台。</p> 
<p>官网：http://ictclas.nlpir.org/</p> 
<p>GitHub地址：https://github.com/NLPIR-team/NLPIR<br> 4.2 模型原理</p> 
<p>主要也是基于概率语言模型，详情可以见 \NLPIR-master\NLPIR\paper 这目录下的 paper<br> 4.3 安装</p> 
<p>GitHub 上面有给出 SVN 的安装方法，但一直都没下载成功，后来通过把那个项目克隆到码云，从码云下载压缩包才下载成功，所以这里直接把我下载好的压缩包上传到百度云了，直接贴贴出来：</p> 
<p>链接：https://pan.baidu.com/s/1cpiTd_QAxTtYTNuy09dWxg<br> 提取码：8r3x</p> 
<p>下载解压即可。<br> 4.4 使用</p> 
<p>目前我只用了它的分词，打开目录：D:\NLPIR-master\NLPIR\NLPIR-Parser\bin-win64 下的 NLPIR-Parser.exe的可执行文件</p> 
<p>在这里插入图片描述<br> 4.5 分词评测<br>     ctb6     msra     pku<br> NLPIR     87.30     88.76     93.11<br> 5. Zpar —— 新加坡科技大学<br> 5.1 简介</p> 
<p>这是一款新加坡科技大学开发的中文分词工具，C++编写，效率很高，并且支持自己训练模型</p> 
<p>GitHub地址：https://github.com/frcchang/zpar<br> 5.2 模型原理</p> 
<p>对于该模型原理的资料比较少，只知道也是基于概率语言模型的。<br> 5.3 安装</p> 
<p>直接克隆 GitHub 的代码进行编译安装</p> 
<p>git clone https://github.com/frcchang/zpar.git</p> 
<p>    1</p> 
<p>之后依次执行：</p> 
<p>make zpar.zh</p> 
<p>make zpar</p> 
<p>make postagger</p> 
<p>make depparser</p> 
<p>make conparser</p> 
<p>make segmentor</p> 
<p>make chinese.postagger</p> 
<p>make chinese.depparser</p> 
<p>make chinese.conparser</p> 
<p>    1<br>     2<br>     3<br>     4<br>     5<br>     6<br>     7<br>     8<br>     9<br>     10<br>     11<br>     12<br>     13<br>     14<br>     15<br>     16<br>     17</p> 
<p>5.4 使用</p> 
<p>源码里面没有模型，因此模型需要自己训练或者去下载</p> 
<p>模型下载：https://github.com/frcchang/zpar/releases</p> 
<p>因为模型文件有点大，所以一直没能下载下来，因此就用自己下的一些语料自己训练了一下。<br> 5.4.1 训练</p> 
<p>进入到路径：/zpar/dist/segmentor ，可以看到 segmentor 和 train 文件， train 是用来训练模型，segmentor 是用训练好的模型来进行分词的。</p> 
<p>./train [train-file] [model-name] [number of iterations]    #训练的参数</p> 
<p>#msr_training.utf8是训练的分词文件， msra_model是训练后的模型名字，4 表示迭代次数，&amp; 表示放在后台进行训练<br> ./train msr_training.utf8 msra_model 4 &amp;    </p> 
<p>    1<br>     2<br>     3<br>     4</p> 
<p>等执行结束后，我们就获得了一个模型文件：msra_model</p> 
<p>之后再加载这个模型文件进行分词<br> 5.4.2 使用训练的模型进行分词</p> 
<p>./segmentor [model-name] [input-file] [output-file]    #分词的参数</p> 
<p>#用刚才训练好的模型文件对 msr_test.utf8 里面的每句话进行分词，并输出到 msr_result.txt<br> ./segmentor msra_model msr_test.utf8 msr_result.txt</p> 
<p>    1<br>     2<br>     3<br>     4</p> 
<p>5.5 分词评测<br>     ctb6     msra     pku<br> Zpar     95.48     96.56     93.57</p> 
<p>**注：**由于下载不到官方提供的模型，因此分别用 ctb6 、 msra 和 pku 的训练集来训练三个模型，然后再分别用各自的测试集测试，才得出以上结果。<br> 6. CoreNLP —— 斯坦福大学<br> 6.1 简介</p> 
<p>斯坦福大学这个工具可以支持多种语言的 NLP 任务，具体介绍看官网。</p> 
<p>官网：https://stanfordnlp.github.io/CoreNLP/<br> 6.2 模型原理</p> 
<p>现在最新的模型大多采用神经网络了。<br> 6.3——6.4 安装与使用</p> 
<p>详情看简书的这篇文章，讲得很清楚了。</p> 
<p>https://www.jianshu.com/p/77c29af0c574</p> 
<p>在这里我就讲一个里面没有讲到的功能：如果要对分好的词进行词性标注怎么弄？</p> 
<p>修改配置文件既可以：</p> 
<p>在配置文件 StanfordCoreNLP-chinese.properties 注释掉 tokenize.language = zh ，写上 tokenize.language = Whitespace</p> 
<p># Pipeline options - lemma is no-op for Chinese but currently needed because coref demands it (bad old requirements system)<br> #annotators = tokenize, ssplit, pos, lemma, ner, parse, coref<br> annotators = tokenize, ssplit, pos, parse<br> #tokenize.language = zh<br> tokenize.language = Whitespace</p> 
<p>    1<br>     2<br>     3<br>     4<br>     5</p> 
<p>6.5 分词评测<br>     ctb6     msra     pku<br> CoreNLP     96.75     83.99     89.71<br> 7. Hanlp —— 开源库<br> 7.1 简介</p> 
<p>HanLP是由一系列模型与算法组成的Java工具包，目标是普及自然语言处理在生产环境中的应用。不仅仅是分词，而是提供词法分析、句法分析、语义理解等完备的功能。HanLP具备功能完善、性能高效、架构清晰、语料时新、可自定义的特点。</p> 
<p>HanLP完全开源，包括词典。不依赖其他jar，底层采用了一系列高速的数据结构，如双数组Trie树、DAWG、AhoCorasickDoubleArrayTrie等，这些基础件都是开源的。官方模型训练自2014人民日报语料库，您也可以使用内置的工具训练自己的模型。</p> 
<p>通过工具类HanLP您可以一句话调用所有功能，文档详细，开箱即用。底层算法经过精心优化，极速分词模式下可达2,000万字/秒，内存仅需120MB。在IO方面，词典加载速度极快，只需500 ms即可快速启动。HanLP经过多次重构，欢迎二次开发。</p> 
<p>官网：http://hanlp.linrunsoft.com/</p> 
<p>GitHub主页：https://github.com/hankcs/HanLP<br> 7.2 模型原理</p> 
<p>最新的模型已经转用神经网络实现了，但同样是用 java 实现，效率没有斯坦福的 CoreNLP 高。<br> 7.3 安装</p> 
<p>    下载工程代码压缩包：https://github.com/hankcs/HanLP/releases，下载后用 idea 打开（我是用IDEA打开的，不知道 eclipse 可不可以）</p> 
<p>    下载模型文件：https://github.com/hankcs/HanLP/releases ，根据里面提供的网盘地址下载最新模型文件</p> 
<p>    解压模型文件，把里面的文件拷到 \HanLP-master\data\model 路径下。</p> 
<p>7.4 使用</p> 
<p>可以直接使用 HanLP/src/test/java/com/hankcs/demo/ 里面的代码</p> 
<p>/*<br>  * &lt;summary&gt;&lt;/summary&gt;<br>  * &lt;author&gt;He Han&lt;/author&gt;<br>  * &lt;email&gt;hankcs.cn@gmail.com&lt;/email&gt;<br>  * &lt;create-date&gt;2014/12/7 20:14&lt;/create-date&gt;<br>  *<br>  * &lt;copyright file="DemoPosTagging.java" company="上海林原信息科技有限公司"&gt;<br>  * Copyright (c) 2003-2014, 上海林原信息科技有限公司. All Right Reserved, http://www.linrunsoft.com/<br>  * This source is subject to the LinrunSpace License. Please contact 上海林原信息科技有限公司 to get more information.<br>  * &lt;/copyright&gt;<br>  */<br> package com.hankcs.demo;</p> 
<p>import com.hankcs.hanlp.HanLP;<br> import com.hankcs.hanlp.corpus.dependency.CoNll.CoNLLSentence;<br> import com.hankcs.hanlp.corpus.dependency.CoNll.CoNLLWord;<br> import com.hankcs.hanlp.dependency.IDependencyParser;<br> import com.hankcs.hanlp.dependency.perceptron.parser.KBeamArcEagerDependencyParser;<br> import com.hankcs.hanlp.utility.TestUtility;</p> 
<p>import java.io.IOException;</p> 
<p>/**<br>  * 依存句法分析（神经网络句法模型需要-Xms1g -Xmx1g -Xmn512m）<br>  *<br>  * @author hankcs<br>  */<br> public class DemoDependencyParser extends TestUtility<br> {<!-- --><br>     public static void main(String[] args) throws IOException, ClassNotFoundException<br>     {<!-- --><br>         //CoNLLSentence sentence = HanLP.parseDependency("徐先生还具体帮助他确定了把画雄鹰、松鼠和麻雀作为主攻目标。");<br>         //也可以用基于ArcEager转移系统的依存句法分析器<br>         IDependencyParser parser = new KBeamArcEagerDependencyParser();<br>         CoNLLSentence sentence = parser.parse("徐先生还具体帮助他确定了把画雄鹰、松鼠和麻雀作为主攻目标。");<br>         System.out.println(sentence);<br>         // 可以方便地遍历它<br>         for (CoNLLWord word : sentence)<br>         {<!-- --><br>             System.out.printf("%s --(%s)--&gt; %s\n", word.LEMMA, word.DEPREL, word.HEAD.LEMMA);<br>         }<br>         // 也可以直接拿到数组，任意顺序或逆序遍历<br>         CoNLLWord[] wordArray = sentence.getWordArray();<br>         for (int i = wordArray.length - 1; i &gt;= 0; i--)<br>         {<!-- --><br>             CoNLLWord word = wordArray[i];<br>             System.out.printf("%s --(%s)--&gt; %s\n", word.LEMMA, word.DEPREL, word.HEAD.LEMMA);<br>         }<br>         // 还可以直接遍历子树，从某棵子树的某个节点一路遍历到虚根<br>         CoNLLWord head = wordArray[12];<br>         while ((head = head.HEAD) != null)<br>         {<!-- --><br>             if (head == CoNLLWord.ROOT) System.out.println(head.LEMMA);<br>             else System.out.printf("%s --(%s)--&gt; ", head.LEMMA, head.DEPREL);<br>         }<br>     }<br> }</p> 
<p>    1<br>     2<br>     3<br>     4<br>     5<br>     6<br>     7<br>     8<br>     9<br>     10<br>     11<br>     12<br>     13<br>     14<br>     15<br>     16<br>     17<br>     18<br>     19<br>     20<br>     21<br>     22<br>     23<br>     24<br>     25<br>     26<br>     27<br>     28<br>     29<br>     30<br>     31<br>     32<br>     33<br>     34<br>     35<br>     36<br>     37<br>     38<br>     39<br>     40<br>     41<br>     42<br>     43<br>     44<br>     45<br>     46<br>     47<br>     48<br>     49<br>     50<br>     51<br>     52<br>     53<br>     54<br>     55<br>     56<br>     57</p> 
<p>注：这里建议使用基于ArcEager转移系统的依存句法分析器，准确率更高！<br> 7.5 分词评测<br>     ctb6     msra     pku<br> Hanlp     93.83     88.71     91.29<br> 8. 对比总结<br> 8.1 分词对比<br>     ctb6     msra     pku     平均<br> jieba     80.79     81.45     81.82     81.35<br> pyltp     91.81     88.34     95.32     91.82<br> thulca     88.94     85.56     92.28     88.93<br> NLPIR     87.30     88.76     93.11     89.72<br> CoreNLP     96.75     83.99     89.71     90.15<br> Hanlp     93.83     88.71     91.29     91.28</p> 
<p>从结果可知：</p> 
<p>在 CTB6 数据集上面，CoreNLP 表现是最好的；</p> 
<p>在 msra 数据集上，NLPIR 变现是最好的；</p> 
<p>在 pku 数据集上， pyltp 表现是最好的。</p> 
<p>而 jieba 在三个数据集中的表现都是最差的。</p> 
<p>整体表现 pyltp 和 Hanlp 表现相对较好，而 jieba 依旧是最差的。</p> 
<p>综合准确率和分词速度，我认为 pyltp 是目前最优秀的分词工具了。</p> 
<p>另外：</p> 
<p>这次没有具体测速度，但是从目前比较直观的感受看，jieba 应该是最快的，其次是 pyltp 、thulca 和NLPIR，而CoreNLP 和 Hanlp 的速度比较慢，其中 Hanlp 的速度最慢。<br> 8.2 各个工具的词性标注体系<br>     词性标注体系<br> pyltp     863词性标注集：http://www.ltp-cloud.com/intro<br> thulac     自己的标注集：http://thulac.thunlp.org/#词性解释<br> NLPIR     北大标准：https://blog.csdn.net/kevin_darkelf/article/details/39520881/<br> Zpar     好像是CTB，但是由于没有下载到官方模型，所以不得而知<br> CoreNLP     CTB 标注集<br> Hanlp     最新的模型也是 CTB 标注集<br> 8.3 各个工具所支持的功能<br>     分词     词性标注     依存句法分析     命名实体识别     语义角色标注     语义依存分析     新词发现     关键词短语提取     自动摘要     文本分类聚类     拼音简繁     情感分析<br> Jieba     √                                             <br> Pyltp     √     √     √     √     √     √                         <br> thulac     √     √                                         <br> NLPIR     √     √     √     √             √     √     √     √         √<br> Zpar     √     √     √                                     <br> CoreNLP     √     √     √     √                                 <br> Hanlp     √     √     √     √             √     √     √     √     √     <br> 9. 附录</p> 
<p>语料库下载：http://sighan.cs.uchicago.edu/bakeoff2005/<br>  </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d4d1ef490e51c37351e3b9b5f63a33c9/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">TensorFlow 2.x调试错误解决：_SymbolicException: Inputs to eager execution function cannot be Keras symbolic</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b1c19db89644f09f97d0c9544e29d4fc/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Nmap常用参数</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>