<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>hibernate的查询条件lt_Hibernate Criteria按条件查询(Query By Criteria, QBC) - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="hibernate的查询条件lt_Hibernate Criteria按条件查询(Query By Criteria, QBC)" />
<meta property="og:description" content="org.hibernate.Criteria接口表示特定持久类的一个查询。
Criteria 代表一次查询
Criterion 代表一个查询条件。
Restrictions 产生查询条件的工具类。
Criterion 是Criteria的查询条件。Criteria提供了add(Criterion criterion)方法来
1：添加查询条件。
Session是Criteria实例的工厂。
Criteria criteria = sess.createCriteria(News.class);
Listnews = criteria.list();
2：限制结果集内容
一个单独的查询条件是org.hibernate.criterion.Criterion接口的一个实例。org.hibernate.criterion.Restrictions类 定义了获得某些内置Criterion类型的工厂方法。Criterion的实例可以通过Restrictions工具类来创建
Listnews = sess.createCriteria(News.class)
.add( Restrictions.like(&#34;title&#34;, &#34;%fendou%&#34;) )
.add( Restrictions.between(&#34;id&#34;,2,8) )
.list();
Restrictions 提供了大量的静态
方法，如 eq(等于)、ge(大于等于)、between等来方法的创建Criterion查询条件 ，通过往该实例的add(Criteria)方法来增加查询条件形成一个查询条件集合。
HQL运算符
QBC运算符
含义
=
Restrictions.eq()
等于
&lt;&gt;
Restrictions.not(Exprission.eq())
不等于
&gt;
Restrictions.gt()
大于
&gt;=
Restrictions.ge()
大于等于
&lt;
Restrictions.lt()
小于
&lt;=
Restrictions.le()
小于等于
is null
Restrictions.isnull()
等于空值
is not null
Restrictions.isNotNull()
非空值
like" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/fd4b2e8c266dde556b555ce9b9bb70af/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-12-24T19:57:25+08:00" />
<meta property="article:modified_time" content="2020-12-24T19:57:25+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">hibernate的查询条件lt_Hibernate Criteria按条件查询(Query By Criteria, QBC)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div style="font-size:16px;"> 
 <p>org.hibernate.Criteria接口表示特定持久类的一个查询。</p> 
 <p>Criteria 代表一次查询</p> 
 <p>Criterion 代表一个查询条件。</p> 
 <p>Restrictions 产生查询条件的工具类。</p> 
 <p>Criterion 是Criteria的查询条件。Criteria提供了add(Criterion criterion)方法来</p> 
 <p>1：添加查询条件。</p> 
 <p>Session是Criteria实例的工厂。</p> 
 <p>Criteria criteria = sess.createCriteria(News.class);</p> 
 <p>Listnews = criteria.list();</p> 
 <p>2：限制结果集内容</p> 
 <p>一个单独的查询条件是org.hibernate.criterion.Criterion接口的一个实例。org.hibernate.criterion.Restrictions类 定义了获得某些内置Criterion类型的工厂方法。Criterion的实例可以通过Restrictions工具类来创建</p> 
 <p>Listnews = sess.createCriteria(News.class)</p> 
 <p>.add( Restrictions.like("title", "%fendou%") )</p> 
 <p>.add( Restrictions.between("id",2,8) )</p> 
 <p>.list();</p> 
 <p>Restrictions 提供了大量的静态</p> 
 <p>方法，如 eq(等于)、ge(大于等于)、between等来方法的创建Criterion查询条件 ，通过往该实例的add(Criteria)方法来增加查询条件形成一个查询条件集合。</p> 
 <p>HQL运算符</p> 
 <p>QBC运算符</p> 
 <p>含义</p> 
 <p>=</p> 
 <p>Restrictions.eq()</p> 
 <p>等于</p> 
 <p>&lt;&gt;</p> 
 <p>Restrictions.not(Exprission.eq())</p> 
 <p>不等于</p> 
 <p>&gt;</p> 
 <p>Restrictions.gt()</p> 
 <p>大于</p> 
 <p>&gt;=</p> 
 <p>Restrictions.ge()</p> 
 <p>大于等于</p> 
 <p>&lt;</p> 
 <p>Restrictions.lt()</p> 
 <p>小于</p> 
 <p>&lt;=</p> 
 <p>Restrictions.le()</p> 
 <p>小于等于</p> 
 <p>is null</p> 
 <p>Restrictions.isnull()</p> 
 <p>等于空值</p> 
 <p>is not null</p> 
 <p>Restrictions.isNotNull()</p> 
 <p>非空值</p> 
 <p>like</p> 
 <p>Restrictions.like()</p> 
 <p>字符串模式匹配</p> 
 <p>and</p> 
 <p>Restrictions.and()</p> 
 <p>逻辑与</p> 
 <p>and</p> 
 <p>Restrictions.conjunction()</p> 
 <p>逻辑与</p> 
 <p>or</p> 
 <p>Restrictions.or()</p> 
 <p>逻辑或</p> 
 <p>or</p> 
 <p>Restrictions.disjunction()</p> 
 <p>逻辑或</p> 
 <p>not</p> 
 <p>Restrictions.not()</p> 
 <p>逻辑非</p> 
 <p>in(列表)</p> 
 <p>Restrictions.in()</p> 
 <p>等于列表中的某一个值</p> 
 <p>not in(列表)</p> 
 <p>Restrictions.not(Restrictions.in())</p> 
 <p>不等于列表中任意一个值</p> 
 <p>between x and y</p> 
 <p>Restrictions.between()</p> 
 <p>闭区间xy中的任意值</p> 
 <p>not between x and y</p> 
 <p>Restrictions.not(Restrictions..between())</p> 
 <p>小于值X或者大于值y</p> 
 <p>3：结果集排序与分页</p> 
 <p>可以使用org.hibernate.criterion.Order来为查询结果排序</p> 
 <p>Listnews = sess.createCriteria(News.class)</p> 
 <p>.add( Restrictions.like("title", "%F%")</p> 
 <p>.addOrder( Order.desc("id") )</p> 
 <p>.setFirstResult(0)</p> 
 <p>.setMaxResults(20)</p> 
 <p>.list();</p> 
 <p>4:使用createCriteria()非常容易的在互相关联的实体间建立约束</p> 
 <p>Criteriac=session.createCriteria(News.class);</p> 
 <p>news=c.add(Restrictions.in("id", new Long []{2l,4l}))</p> 
 <p>.add(Restrictions.like("title", "%今日%"))</p> 
 <p>.createCriteria("category")</p> 
 <p>.add(Restrictions.eq("id", 2))</p> 
 <p>.addOrder(Order.desc("id"))</p> 
 <p>.list();</p> 
 <p>5：投影(Projections)</p> 
 <p>org.hibernate.criterion.Projections是Projection的实例工厂。我们通过调用setProjection()应用投影到一个查询。</p> 
 <p>session=HibernateUtil.getSession();</p> 
 <p>Criteria c=session.createCriteria(News.class);</p> 
 <p>c.setProjection( Projections.projectionList()</p> 
 <p>.add( Projections.property("title"))</p> 
 <p>.add( Projections.property("category")));</p> 
 <p>news=c.list();</p> 
 <p>for(int i=0;i</p> 
 <p>Object[] obj=(Object[])news.get(i);</p> 
 <p>System.out.println(obj[0]+"***"+obj[1]);</p> 
 <p>}</p> 
 <p>6：查询示例(Query ByExample, QBE)</p> 
 <p>org.hibernate.criterion.Example类允许你通过一个给定实例 构建一个条件查询(主要用于模糊查询)</p> 
 <p>List news=new ArrayList();</p> 
 <p>News exn=new News();</p> 
 <p>exn.setTitle("%今日%");</p> 
 <p>Example example=Example.create(exn);</p> 
 <p>example.enableLike();</p> 
 <p>Session session=HibernateUtil.getSession();</p> 
 <p>Criteria c=session.createCriteria(News.class);</p> 
 <p>c.add(example);</p> 
 <p>news=c.list();</p> 
 <p>Hibernate中的原生SQL(Native SQL)查询</p> 
 <p>Hibernate3允许你使用手写的sql来完成所有的create,update,delete,和load操作(包括存储过程)</p> 
 <p>1：SQL查询是通过SQLQuery接口来控制的，它是通过调用Session.createSQLQuery()方法来获得</p> 
 <p>session=HibernateUtil.getSession();</p> 
 <p>news=session.createSQLQuery("select * from news_news n")</p> 
 <p>.addEntity(News.class).list();</p> 
 <p>addEntity()方法将SQL表的实体类联系起来，并且确定查询结果集的返回值形态。</p> 
 <p>2：原生的SQL查询可能返回一个简单的标量值或者一个标量和实体的结合体</p> 
 <p>session=HibernateUtil.getSession();</p> 
 <p>max=(Long)session.createSQLQuery("select max(n.n_id) as maxid from news_news n")</p> 
 <p>.addScalar("maxid",Hibernate.LONG)</p> 
 <p>.uniqueResult();</p> 
 <p>3：命名SQL查询</p> 
 <p>可以在映射文档中定义查询的名字,然后就可以象调用一个命名的HQL查询一样直接调用命名SQL查询.在这种情况下,我们不 需要调用addEntity()方法.</p> 
 <p>在po类的xml文件中命名一个sql</p> 
 <p>select * from news_news n</p> 
 <p>实现类调用：</p> 
 <p>news=session.getNamedQuery("sqlallnews")</p> 
 <p>4：使用存储过程来查询</p> 
 <p>Hibernate 3引入了对存储过程查询的支持.存储过程必须返回一个结果集</p> 
 <p>如下面存储过程例子：</p> 
 <p>CREATE OR REPLACE FUNCTION selectAllnews</p> 
 <p>RETURN SYS_REFCURSOR</p> 
 <p>AS</p> 
 <p>st_cursor SYS_REFCURSOR;</p> 
 <p>BEGIN</p> 
 <p>OPEN st_cursor FOR</p> 
 <p>SELECT *</p> 
 <p>FROM news_news;</p> 
 <p>RETURN st_cursor;</p> 
 <p>END;</p> 
 <p>在Hibernate里要要使用这个查询,你需要通过命名查询来映射它.</p> 
 <p>{ ? = call selectAllnews () }</p> 
 <p>news=session.getNamedQuery("callselectAllnews")</p> 
 <p>.list();</p> 
 <p>对存储过程进行的查询无法使用setFirstResult()/setMaxResults()进行分页</p> 
 <p>Hibernate过滤数据</p> 
 <p>Hibernate3 提供了一种创新的方式来处理具有“显性(visibility)”规则的数据，那就是使用Hibernate filter。Hibernate filter是全局有效的、具有名字、可以带参数的过滤器， 对于某个特定的Hibernate session您可以选择是否启用(或禁用)某个过滤器。过滤器条件相当于定义一个 非常类似于类和各种集合上的“where”属性的约束子句</p> 
 <p>1：定义一个过滤器</p> 
 <p>节点之内的节点</p> 
 <p>2：定义好之后，就可以在某个类中要使用的属性下使用这个过滤器：</p> 
 <p>3：Session中默认是不启用过滤器的，必须通过Session.enabledFilter()方法显式的启用。 该方法返回被启用的Filter的实例</p> 
 <p>session.enableFilter("newsCategoryfilter ").setParameter("catid", 1);</p> 
 <p>String hql="from News";</p> 
 <p>Query query=session.createQuery(hql);</p> 
 <p>query.setFirstResult(0);</p> 
 <p>query.setMaxResults(5);</p> 
 <p>news=query.list();</p> 
 <p>通过使用过滤器可以定义常用的筛选规则，如果是临时的还是使用常规的查询比较好。</p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f45606cebab52f5f7c03a2e3038779fd/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">nginx 某个地址转发_nginx根据项目名实现内网地址转发</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c3489f39cefb72f2eec51bc5fb7d986c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">python中3and5为什么输出是5_为什么在Python 3.5中，round（4.5）== 4和round（5.5）== 6？...</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>