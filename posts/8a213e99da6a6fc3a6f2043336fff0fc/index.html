<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>推荐系统方法梳理 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="推荐系统方法梳理" />
<meta property="og:description" content="文章目录 推荐系统流程步骤1：召回基于内容的召回(Content-based)协同过滤(Collaborative Filtering)User-CFItem-CF MF(Model-CF)DSSM双塔模型(Deep Structured Semantic Models)倒排索引召回多路召回 粗排LR(Logistic Regression)树模型 精排特征交叉流派pairwise&amp;listwise 重排 推荐系统流程 召回：从千百万量级的全量内容中挑选出用户可能感兴趣的几百/几千条内容，主要包括热门内容召回、基于内容的召回、基于用户行为的召回（CF、MF、双塔DSSM、graph embedding）、倒排索引、强化学习(for内容冷启动)等。
粗排/精排：利用模型对召回内容进行打分，取top k进入重排。主要包括LR、特征交叉流派（FM家族）、行为序列流派（DIN、DIEN/DSIN、BST等）、其他流派（pairwise、listwise）。
重排：按照业务策略对内容顺序进一步调整，形成最终的推荐list返回给用户。主要包括listwise、多样性算法（MMR、DPP）、强化学习等。
步骤1：召回 基于内容的召回(Content-based) 抽取内容的semantic features（如电影名称、导演、主演、类别等），对内容进行embedding，向用户推荐semantic embedding相似的内容。
Problem：用户冷启动问题
协同过滤(Collaborative Filtering) User-CF 计算用户间的相似度（这里的特征向量为用户给不同商品的评分），推荐相似的用户喜欢的item。
Item-CF 计算商品之间的相似度（这里的特征向量为商品被各个用户的评分），推荐相似的item。
MF(Model-CF) 利用matrix factorization对用户-商品矩阵进行分解，从而得到新的用户、商品的特征表示向量，并用这些向量来计算用户/商品之间的相似度，进行推荐。
DSSM双塔模型(Deep Structured Semantic Models) 论文：Sampling-Bias-Corrected Neural Modeling for Large Corpus Item Recommendations
简单讲就是user和item分别用DNN做embedding，最终使用cosine计算相似度进行推荐。在工业界非常常用。
倒排索引召回 倒排索引最初是搜索领域的方法，通过记录包含关键词key的文章document（以及出现的位置、权重等），在用户对关键词进行搜索时，直接通过索引找到对应文章。复杂度由O(n)变为O(1)。
由于实际应用中，使用属性值来查找记录，而非用记录查找值，因此被称为“倒排”。
对于搜索引擎，关键词由用户主动输入；而对于推荐系统，关键词需要系统生成。生成策略包括根据用户画像等进行内容召回、根据热度等进行策略召回。
用户画像示例如下：
多路召回 使用多种召回策略同时召回，再进行加权平均等方式得到最终的召回item。
可以结合上述策略的优点。
粗排 LR(Logistic Regression) LR 模型是 CTR 预估领域早期最成功的模型.
LR 使用 “线性模型 &#43; 人工特征组合引入非线性” 特征，对item的分数进行预测。
LR 模型具有训练快、上线快、可解释性强、容易上规模等优点，目前仍然有不少实际系统采取这种粗排模式。
树模型 GBDT、XGB、LightGBM、GDBT&#43;LR等。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/8a213e99da6a6fc3a6f2043336fff0fc/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-08-16T12:37:36+08:00" />
<meta property="article:modified_time" content="2022-08-16T12:37:36+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">推荐系统方法梳理</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#_1" rel="nofollow">推荐系统流程</a></li><li><a href="#1_6" rel="nofollow">步骤1：召回</a></li><li><ul><li><a href="#Contentbased_7" rel="nofollow">基于内容的召回(Content-based)</a></li><li><a href="#Collaborative_Filtering_10" rel="nofollow">协同过滤(Collaborative Filtering)</a></li><li><ul><li><a href="#UserCF_11" rel="nofollow">User-CF</a></li><li><a href="#ItemCF_15" rel="nofollow">Item-CF</a></li></ul> 
   </li><li><a href="#MFModelCF_18" rel="nofollow">MF(Model-CF)</a></li><li><a href="#DSSMDeep_Structured_Semantic_Models_21" rel="nofollow">DSSM双塔模型(Deep Structured Semantic Models)</a></li><li><a href="#_27" rel="nofollow">倒排索引召回</a></li><li><a href="#_35" rel="nofollow">多路召回</a></li></ul> 
  </li><li><a href="#_38" rel="nofollow">粗排</a></li><li><ul><li><a href="#LRLogistic_Regression_39" rel="nofollow">LR(Logistic Regression)</a></li><li><a href="#_44" rel="nofollow">树模型</a></li></ul> 
  </li><li><a href="#_47" rel="nofollow">精排</a></li><li><ul><li><a href="#_48" rel="nofollow">特征交叉流派</a></li><li><a href="#pairwiselistwise_55" rel="nofollow">pairwise&amp;listwise</a></li></ul> 
  </li><li><a href="#_94" rel="nofollow">重排</a></li></ul> 
</div> 
<p></p> 
<h2><a id="_1"></a>推荐系统流程</h2> 
<p><img src="https://images2.imgbox.com/83/70/8lrN2hDP_o.png" alt="在这里插入图片描述"><br> <strong>召回</strong>：从千百万量级的全量内容中挑选出用户可能感兴趣的几百/几千条内容，主要包括热门内容召回、基于内容的召回、基于用户行为的召回（CF、MF、双塔DSSM、graph embedding）、倒排索引、强化学习(for内容冷启动)等。<br> <strong>粗排/精排</strong>：利用模型对召回内容进行打分，取top k进入重排。主要包括LR、特征交叉流派（FM家族）、行为序列流派（DIN、DIEN/DSIN、BST等）、其他流派（pairwise、listwise）。<br> <strong>重排</strong>：按照业务策略对内容顺序进一步调整，形成最终的推荐list返回给用户。主要包括listwise、多样性算法（MMR、DPP）、强化学习等。</p> 
<h2><a id="1_6"></a>步骤1：召回</h2> 
<h3><a id="Contentbased_7"></a>基于内容的召回(Content-based)</h3> 
<p>抽取内容的<strong>semantic</strong> features（如电影名称、导演、主演、类别等），对内容进行embedding，向用户推荐semantic embedding相似的内容。<br> Problem：用户冷启动问题</p> 
<h3><a id="Collaborative_Filtering_10"></a>协同过滤(Collaborative Filtering)</h3> 
<h4><a id="UserCF_11"></a>User-CF</h4> 
<p>计算用户间的相似度（这里的特征向量为<strong>用户给不同商品的评分</strong>），推荐<strong>相似的用户</strong>喜欢的item。<br> <img src="https://images2.imgbox.com/5f/c2/hzx1st3q_o.png" alt="在这里插入图片描述" width="600"></p> 
<h4><a id="ItemCF_15"></a>Item-CF</h4> 
<p>计算商品之间的相似度（这里的特征向量为<strong>商品被各个用户的评分</strong>），推荐<strong>相似的item</strong>。<br> <img src="https://images2.imgbox.com/71/c8/nxHAbcQN_o.png" alt="在这里插入图片描述" width="600"></p> 
<h3><a id="MFModelCF_18"></a>MF(Model-CF)</h3> 
<p>利用matrix factorization对用户-商品矩阵进行分解，从而得到新的用户、商品的<strong>特征表示向量</strong>，并用这些向量来计算<strong>用户/商品之间的相似度</strong>，进行推荐。<br> <img src="https://images2.imgbox.com/7f/3e/OwGOLdVf_o.png" alt="在这里插入图片描述" width="600"></p> 
<h3><a id="DSSMDeep_Structured_Semantic_Models_21"></a>DSSM双塔模型(Deep Structured Semantic Models)</h3> 
<blockquote> 
 <p>论文：Sampling-Bias-Corrected Neural Modeling for Large Corpus Item Recommendations</p> 
</blockquote> 
<p>简单讲就是user和item分别用DNN做embedding，最终使用cosine计算相似度进行推荐。在工业界非常常用。<br> <img src="https://images2.imgbox.com/f6/c4/BAKRh0AG_o.png" alt="在这里插入图片描述" width="600"></p> 
<h3><a id="_27"></a>倒排索引召回</h3> 
<p>倒排索引最初是搜索领域的方法，通过记录包含关键词key的文章document（以及出现的位置、权重等），在用户对关键词进行搜索时，直接通过索引找到对应文章。复杂度由O(n)变为O(1)。<br> 由于实际应用中，使用属性值来查找记录，而非用记录查找值，因此被称为“倒排”。<br> <img src="https://images2.imgbox.com/b2/91/8AFz6CPl_o.jpg" alt="在这里插入图片描述" width="600"><br> 对于搜索引擎，关键词由用户主动输入；而对于推荐系统，关键词需要系统生成。生成策略包括根据用户画像等进行<strong>内容召回</strong>、根据热度等进行<strong>策略召回</strong>。<br> 用户画像示例如下：<br> <img src="https://images2.imgbox.com/0c/1f/TZXutyGu_o.jpg" alt="在这里插入图片描述" width="600"></p> 
<h3><a id="_35"></a>多路召回</h3> 
<p>使用多种召回策略同时召回，再进行加权平均等方式得到最终的召回item。<br> 可以结合上述策略的优点。</p> 
<h2><a id="_38"></a>粗排</h2> 
<h3><a id="LRLogistic_Regression_39"></a>LR(Logistic Regression)</h3> 
<p>LR 模型是 CTR 预估领域早期最成功的模型.<br> LR 使用 “<strong>线性模型 + 人工特征组合引入非线性</strong>” 特征，对<strong>item的分数</strong>进行预测。<br> LR 模型具有训练快、上线快、可解释性强、容易上规模等优点，<strong>目前仍然有不少实际系统采取这种粗排模式</strong>。<br> <img src="https://images2.imgbox.com/82/da/iMyGmnhU_o.jpg" alt="在这里插入图片描述" width="500"></p> 
<h3><a id="_44"></a>树模型</h3> 
<p>GBDT、XGB、LightGBM、GDBT+LR等。</p> 
<h2><a id="_47"></a>精排</h2> 
<h3><a id="_48"></a>特征交叉流派</h3> 
<p>FM实现了二阶特征组合自动化；<br> 接下来引入深度学习，wide&amp;deep、DeepFM、xDeepFM(CIN)、Deep&amp;Cross(Cross)向显式特征组合的方向发展。</p> 
<p><strong>tricks:</strong></p> 
<ul><li>实验证明，二阶特征交叉有效，三阶部分有效，四阶及以上特征交叉基本没有作用。</li><li>深度学习实现了高阶特征组合自动化，但速度慢、可解释性差。</li></ul> 
<h3><a id="pairwiselistwise_55"></a>pairwise&amp;listwise</h3> 
<p>前面介绍的方法主要是pointwise维度的，即对每个item单独打分。<br> 设query为<em><strong>q</strong></em>，文档为<em><strong>c</strong></em>，预测得分为<em><strong>h(q,c)</strong></em>，实际得分为标签<em><strong>y</strong></em>。pointwise直接最小化<em>h(q,c)<em>和</em>y</em>之间的差距构造损失函数。</p> 
<p>这种方法存在以下缺点：</p> 
<ol><li>pointwise追求的是文章的精确打分，没有考虑到文章之间的关联性，而推荐追求的是相对排序；</li><li>pointwise为了追求整体loss最小化，导致优化结果被对应文章多的query所支配，而推荐追求每个query处于同等地位；</li><li>实际推荐情景中，top k之间的顺序远比末尾若干内容的顺序重要，pointwise的损失函数没有考虑相对位置信息，会无意间过于注重不重要的文章排序。</li></ol> 
<p><strong>pairwise</strong><br> Pairwise通过近似为分类问题解决排序问题。<br> pairwise通过计算<em><strong>h(q,c1)-h(q,c2)</strong></em> 构造损失函数，标签<em><strong>y</strong></em>表示h(q,c1)-h(q,c2)&gt;0或&lt;0。<br> 输入样本为“标签-文档对”。学习一个二分类器，对输入的一对文档对AB，根据A相关性是否比B好，二分类器给出分类标签1或0。<br> 对所有文档对进行分类，就可以得到一组偏序关系，从而构造文档全集的排序关系。<br> 该类方法通过<strong>降低排序中的逆序文档对的个数来降低排序错误</strong>，从而达到优化排序结果的目的。</p> 
<p>例如：三个文档 A、B 、 C，完美排序是 “B&gt;C&gt;A”。pairwise通过学习 “B&gt;C”、“B&gt;A” 和 “C&gt;A” 来重构 “B&gt;C&gt;A”。</p> 
<p>代表算法：基于 SVM 的 Ranking SVM 算法、基于神经网络的 RankNet 算法和基于 Boosting 的 RankBoost 算法。</p> 
<p>pairwise存在问题：</p> 
<ol><li>pairwise使用的两两排序的损失函数还是不能真正代表整体排序的损失函数，甚至可能出现负相关；</li><li>doc pair的数量是doc的二次，query对应文章数量不平衡的问题被进一步放大；</li><li>pairwise依然没有考虑文档在整体排序列表的出现顺序，导致排序结果依然受到不重要的文档影响；</li><li>pairwise会对噪声数据更敏感。如果一个文章对预测错误，与这两个文档相关的排序都将受到影响。</li></ol> 
<p><strong>listwise</strong><br> Listwise方法是直接优化排序列表。<br> 输入为单条样本为一个query和它对应的所有候选item。<br> 计算<em><strong>S= softmax(h(q,c1),h(q,c2)…h(q,cn))</strong></em>，其标签<em><strong>Y=(y1,y2…yn)</strong></em> 表示各候选文档的实际得分排序。最小化S和Y之间的KL散度得到最优排序。</p> 
<p>代表算法：AdaRank，SoftRank，<strong>LambdaMART</strong>、 ListNet、ListMLE、BoltzRank等。</p> 
<p>listwise存在问题：</p> 
<ol><li>训练复杂度较高；</li><li>位置信息在listwise中也没有在loss中得到充分利用，可以在 ListNet 和 ListMLE 的 loss 中考虑引入位置折扣因子。</li></ol> 
<p>出于时延考虑，目前大多数推荐系统仍然采用pointwise方法进行精排。</p> 
<h2><a id="_94"></a>重排</h2> 
<p>重排作为离用户最近的一个步骤，涉及打散、多样性等过程，需要充分考虑用户体验，避免用户抵触。<br> <strong>打散</strong><br> 对同类目、同作者、相似封面图的item进行打散，可以有效防止用户疲劳和系统过度个性化，同时有利于探索和捕捉用户的潜在兴趣，对用户体验和长期目标都很关键。<br> <strong>多样性</strong><br> 可以从user和item两个角度评估，比如平均每个用户的曝光一二级类目数，曝光item同属一个类目的概率等。可以从类目、作者、标签等多个维度进行数据分析和评价。</p> 
<p>此外，由于粗排和精排考虑到时延，主要采用pointwise方法；而重排的量级较小，可以采用<strong>pairwise和listwise</strong>提升排序的准确性和有效性。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d568d526a32dddd6588b9bebcf2b11de/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">OSError: [WinError 1455] 解决方案</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/52a20596927f812b3dbffc1e320d885e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">cv2、PIL、matplotlib 读取图片的区别和联系</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>