<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>操作系统之调度算法（学习笔记） - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="操作系统之调度算法（学习笔记）" />
<meta property="og:description" content="计算机操作系统之调度算法 要点知识回顾 先来先服务算法（FCFS）算法思想优缺点例题 短作业优先算法（SJF）算法思想优缺点例题1例题2 高响应比优先调度算法（HRRN）前言算法思想优缺点例题 要点知识回顾 周转时间：从作业被提交给系统开始，到作业完成为止的这段时间间隔称为作业周转时间。（周转时间=作业完成时间-作业提交时间）平均周转时间：作业周转总时间 / 作业个数（平均周转时间=（作业1周转时间&#43;作业2周转时间&#43;……作业n周转时间）/n）服务时间：进程在CPU中运行的时间带权周转时间：周转时间 / 服务时间平均带权周转时间：带权周转总时间 / 作业个数（平均带权周转时间=（作业1带权周转时间&#43;作业2带权周转时间……&#43;作业n带权周转时间）/n） 先来先服务算法（FCFS） 算法思想 先来先服务算法指的是按照作业/进程到达的先后顺序进行服务的，主要从“公平”的角度考虑。用于作业调度时，考虑的是哪个作业先到达后备队列；用于进程调度时，考虑的是哪个进程先到达就绪队列，是非抢占式算法，不会导致饥饿（某进程/作业长时间得不到服务）
优缺点 优点：
公平、算法实现简单缺点：
排在长作业（进程）后面的短作业需要等待很长时间，带权周转时间很大，对短作业来说用户体验不好，即FCFS算法对长作业有利，对短作业不利 例题 各进程到达就绪队列的时间，需要的运行时间如下表所示。使用先来先服务调度算法，计算各进程的等待时间，平均等待时间，周转时间，平均周转时间，带权周转时间，平均带权周转时间。
进程到达时间运行时间P107P224P341P454 先来先服务算法即是按到达的先后顺序调度。所以调度顺序为P1-&gt;P2-&gt;P3-&gt;P4
周转时间=完成时间-到达时间
P1=7-0=7; P2=11-2=9; P3=12-4=8; P4=16-5=11;
带权周转时间=周转时间/运行时间
P1=7/7=1;P2=9/4=2.25;P3=8/1=8;P4=11/4=2.75;
等待时间=周转时间-运行时间
P2=7-7=0;P2=9-4=5;P3=8-1=7;P4=11-4=7;
平均周转时间=作业总周转时间/作业个数
平均周转时间=（7&#43;9&#43;8&#43;11）/4=8.75
平均带权周转时间=总带权周转时间/作业个数
平均带权周转时间=(1&#43;2.25&#43;8&#43;2.75)/4=3.5
平均等待时间=总等待时间/作业个数
平均等待时间=（0&#43;5&#43;7&#43;7）/4=4.75
ps:本例题中的进程都是纯计算型的进程，一个进程到达后要么在等待，要么在运行，如果是又有计算又有I/O操作的进程，其等待时间就是周转时间-运行时间-I/O操作的时间
短作业优先算法（SJF） 算法思想 短作业优先算法追求最少的平均等待时间，最少的平均周转时间，最少的平均带权周转时间，即让最短的作业/进程得到服务（最短为服务时间最短），既可用于作业调度，也可用于进程调度。用于进程调度时称为“短进程优先”（SPF）算法。SJF和SPF是非抢占式得算法，但是也有抢占式的版本——最短剩余时间优先法。会产生“饥饿”现象（如果源源不断的有短作业/进程到来），可能使长作业/进程长时间得不到服务，产生“饥饿”现象。如果一直得不到服务，则称为“饿死”。
优缺点 优点
“最短的”平均等待时间，平均周转时间缺点
不公平。对短作业有利，对长作业不利。可能产生饥饿现象。另外，作业/进程的运行时间是用户提供的，并不一定真实，不一定能做到真正的短作业优先 例题1 各进程到达就绪队列的时间，需要的运行时间如下表所示。使用非抢占式的短作业优先调度算法，计算各进程的等待时间，平均等待时间，周转时间，平均周转时间，带权周转时间，平均带权周转时间。
进程到达时间运行时间P107P224P341P454 短作业/进程优先调度算法：每次调度时选择当前已到达且运行时间最短的作业/进程。
调度顺序为：P1-&gt;P3-&gt;P2-&gt;P4
周转时间=完成时间-到达时间
P1=7-0=7; P3=8-4=4; P2=12-2=10; P4=16-5=11;
带权周转时间=周转时间/运行时间
P1=7/7=1;P3=4/1=4.25;P2=10/4=2.5;P4=11/4=2.75;
等待时间=周转时间-运行时间
P1=7-7=0;P3=4-1=3;P2=10-4=6;P4=11-4=7;
平均周转时间=作业总周转时间/作业个数
平均周转时间=（7&#43;4&#43;10&#43;11）/4=8
平均带权周转时间=总带权周转时间/作业个数
平均带权周转时间=(1&#43;4&#43;2.5&#43;2.75)/4=2.56
平均等待时间=总等待时间/作业个数
平均等待时间=（0&#43;3&#43;6&#43;7）/4=4
对比FCFS算法的结果，显然SPF算法的平均等待/周转/带权周转时间都要更低
例题2 各进程到达就绪队列的时间，需要的运行时间如下表所示。使用抢占式的短作业优先调度算法，计算各进程的等待时间，平均等待时间，周转时间，平均周转时间，带权周转时间，平均带权周转时间。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/dc5aa4a1fe07af64a4460692fa3be0ef/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-03-23T13:20:56+08:00" />
<meta property="article:modified_time" content="2023-03-23T13:20:56+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">操作系统之调度算法（学习笔记）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>计算机操作系统之调度算法</h4> 
 <ul><li><ul><li><a href="#_1" rel="nofollow">要点知识回顾</a></li></ul> 
  </li><li><a href="#FCFS_7" rel="nofollow">先来先服务算法（FCFS）</a></li><li><ul><li><ul><li><ul><li><a href="#_8" rel="nofollow">算法思想</a></li><li><a href="#_10" rel="nofollow">优缺点</a></li><li><a href="#_15" rel="nofollow">例题</a></li></ul> 
   </li></ul> 
   </li><li><a href="#SJF_40" rel="nofollow">短作业优先算法（SJF）</a></li><li><ul><li><ul><li><a href="#_41" rel="nofollow">算法思想</a></li><li><a href="#_44" rel="nofollow">优缺点</a></li><li><a href="#1_50" rel="nofollow">例题1</a></li><li><a href="#2_76" rel="nofollow">例题2</a></li></ul> 
    </li><li><a href="#HRRN_101" rel="nofollow">高响应比优先调度算法（HRRN）</a></li><li><ul><li><a href="#_102" rel="nofollow">前言</a></li><li><a href="#_107" rel="nofollow">算法思想</a></li><li><a href="#_112" rel="nofollow">优缺点</a></li><li><a href="#_120" rel="nofollow">例题</a></li></ul> 
   </li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h3><a id="_1"></a>要点知识回顾</h3> 
<ul><li><strong>周转时间</strong>：从作业被提交给系统开始，到作业完成为止的这段时间间隔称为作业周转时间。（<mark>周转时间=作业完成时间-作业提交时间</mark>）</li><li><strong>平均周转时间</strong>：作业周转总时间 / 作业个数（<mark>平均周转时间=（作业1周转时间+作业2周转时间+……作业n周转时间）/n</mark>）</li><li><strong>服务时间</strong>：进程在CPU中运行的时间</li><li><strong>带权周转时间</strong>：周转时间 / 服务时间</li><li><strong>平均带权周转时间</strong>：带权周转总时间 / 作业个数（<mark>平均带权周转时间=（作业1带权周转时间+作业2带权周转时间……+作业n带权周转时间）/n</mark>）</li></ul> 
<h2><a id="FCFS_7"></a>先来先服务算法（FCFS）</h2> 
<h5><a id="_8"></a>算法思想</h5> 
<blockquote> 
 <p>先来先服务算法指的是按照作业/进程到达的<strong>先后顺序</strong>进行服务的，主要从“公平”的角度考虑。用于作业调度时，考虑的是哪个作业<strong>先</strong>到达后备队列；用于进程调度时，考虑的是哪个进程<strong>先</strong>到达就绪队列，是<strong>非抢占式算法</strong>，<strong>不会</strong>导致饥饿（某进程/作业长时间得不到服务）</p> 
</blockquote> 
<h5><a id="_10"></a>优缺点</h5> 
<blockquote> 
 <ul><li><strong>优点</strong>：<br> 公平、算法实现简单</li><li><strong>缺点</strong>：<br> 排在长作业（进程）后面的短作业需要等待很长时间，带权周转时间很大，对短作业来说用户体验不好，即FCFS算法对长作业有利，对短作业不利</li></ul> 
</blockquote> 
<h5><a id="_15"></a>例题</h5> 
<p>各进程到达就绪队列的时间，需要的运行时间如下表所示。使用先来先服务调度算法，计算各进程的等待时间，平均等待时间，周转时间，平均周转时间，带权周转时间，平均带权周转时间。</p> 
<table><thead><tr><th>进程</th><th>到达时间</th><th>运行时间</th></tr></thead><tbody><tr><td>P1</td><td>0</td><td>7</td></tr><tr><td>P2</td><td>2</td><td>4</td></tr><tr><td>P3</td><td>4</td><td>1</td></tr><tr><td>P4</td><td>5</td><td>4</td></tr></tbody></table> 
<p>先来先服务算法即是按到达的先后顺序调度。所以调度顺序为P1-&gt;P2-&gt;P3-&gt;P4<br> <img src="https://images2.imgbox.com/cc/5f/r7cwEX9O_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p><mark>周转时间</mark>=完成时间-到达时间<br> <strong>P1</strong>=7-0=7; <strong>P2</strong>=11-2=9; <strong>P3</strong>=12-4=8; <strong>P4</strong>=16-5=11;<br> <mark>带权周转时间</mark>=周转时间/运行时间<br> <strong>P1</strong>=7/7=1;<strong>P2</strong>=9/4=2.25;<strong>P3</strong>=8/1=8;<strong>P4</strong>=11/4=2.75;<br> <mark>等待时间</mark>=周转时间-运行时间<br> <strong>P2</strong>=7-7=0;<strong>P2</strong>=9-4=5;<strong>P3</strong>=8-1=7;<strong>P4</strong>=11-4=7;<br> <mark>平均周转时间</mark>=作业总周转时间/作业个数<br> 平均周转时间=（7+9+8+11）/4=8.75<br> <mark>平均带权周转时间</mark>=总带权周转时间/作业个数<br> 平均带权周转时间=(1+2.25+8+2.75)/4=3.5<br> <mark>平均等待时间</mark>=总等待时间/作业个数<br> 平均等待时间=（0+5+7+7）/4=4.75</p> 
</blockquote> 
<p><strong>ps:本例题中的进程都是纯计算型的进程，一个进程到达后要么在等待，要么在运行，如果是又有计算又有I/O操作的进程，其等待时间就是周转时间-运行时间-I/O操作的时间</strong></p> 
<h3><a id="SJF_40"></a>短作业优先算法（SJF）</h3> 
<h5><a id="_41"></a>算法思想</h5> 
<blockquote> 
 <p>短作业优先算法追求最少的平均等待时间，最少的平均周转时间，最少的平均带权周转时间，即<strong>让最短的作业/进程得到服务</strong>（最短为服务时间最短），既可用于作业调度，也可用于进程调度。用于进程调度时称为“短进程优先”（SPF）算法。<strong>SJF和SPF是非抢占式得算法，但是也有抢占式的版本</strong>——最短剩余时间优先法。<strong>会产生“饥饿”现象</strong>（如果源源不断的有短作业/进程到来），可能使长作业/进程长时间得不到服务，产生“饥饿”现象。如果一直得不到服务，则称为“饿死”。</p> 
</blockquote> 
<h5><a id="_44"></a>优缺点</h5> 
<blockquote> 
 <ul><li>优点<br> “最短的”平均等待时间，平均周转时间</li><li>缺点<br> 不公平。对短作业有利，对长作业不利。可能产生饥饿现象。另外，作业/进程的运行时间是用户提供的，并不一定真实，不一定能做到真正的短作业优先</li></ul> 
</blockquote> 
<h5><a id="1_50"></a>例题1</h5> 
<p>各进程到达就绪队列的时间，需要的运行时间如下表所示。使用<mark>非抢占式的短作业优先调度算法</mark>，计算各进程的等待时间，平均等待时间，周转时间，平均周转时间，带权周转时间，平均带权周转时间。</p> 
<table><thead><tr><th>进程</th><th>到达时间</th><th>运行时间</th></tr></thead><tbody><tr><td>P1</td><td>0</td><td>7</td></tr><tr><td>P2</td><td>2</td><td>4</td></tr><tr><td>P3</td><td>4</td><td>1</td></tr><tr><td>P4</td><td>5</td><td>4</td></tr></tbody></table> 
<p>短作业/进程优先调度算法：每次调度时选择当前已到达且运行时间最短的作业/进程。<br> 调度顺序为：P1-&gt;P3-&gt;P2-&gt;P4<br> <img src="https://images2.imgbox.com/35/7a/mFqopJFC_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p><mark>周转时间</mark>=完成时间-到达时间<br> <strong>P1</strong>=7-0=7; <strong>P3</strong>=8-4=4; <strong>P2</strong>=12-2=10; <strong>P4</strong>=16-5=11;<br> <mark>带权周转时间</mark>=周转时间/运行时间<br> <strong>P1</strong>=7/7=1;<strong>P3</strong>=4/1=4.25;<strong>P2</strong>=10/4=2.5;<strong>P4</strong>=11/4=2.75;<br> <mark>等待时间</mark>=周转时间-运行时间<br> <strong>P1</strong>=7-7=0;<strong>P3</strong>=4-1=3;<strong>P2</strong>=10-4=6;<strong>P4</strong>=11-4=7;<br> <mark>平均周转时间</mark>=作业总周转时间/作业个数<br> 平均周转时间=（7+4+10+11）/4=8<br> <mark>平均带权周转时间</mark>=总带权周转时间/作业个数<br> 平均带权周转时间=(1+4+2.5+2.75)/4=2.56<br> <mark>平均等待时间</mark>=总等待时间/作业个数<br> 平均等待时间=（0+3+6+7）/4=4</p> 
</blockquote> 
<p><strong>对比FCFS算法的结果，显然SPF算法的平均等待/周转/带权周转时间都要更低</strong></p> 
<h5><a id="2_76"></a>例题2</h5> 
<p>各进程到达就绪队列的时间，需要的运行时间如下表所示。使用<mark>抢占式的短作业优先调度算法</mark>，计算各进程的等待时间，平均等待时间，周转时间，平均周转时间，带权周转时间，平均带权周转时间。</p> 
<table><thead><tr><th>进程</th><th>到达时间</th><th>运行时间</th></tr></thead><tbody><tr><td>P1</td><td>0</td><td>7</td></tr><tr><td>P2</td><td>2</td><td>4</td></tr><tr><td>P3</td><td>4</td><td>1</td></tr><tr><td>P4</td><td>5</td><td>4</td></tr></tbody></table> 
<p>最短剩余时间优先算法：每当有进程加入就绪队列改变时就需要调度，如果新到达的进程剩余时间比当前运行的进程剩余时间更短，则有新进程抢占处理机，当前运行进程重新回到就绪队列。另外，当一个进程完成是也需要调度。<br> <img src="https://images2.imgbox.com/39/ca/rkxQhFT5_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p><mark>周转时间</mark>=完成时间-到达时间<br> <strong>P1</strong>=16-0=16; <strong>P2</strong>=7-2=5; <strong>P3</strong>=5-4=1; <strong>P4</strong>=11-5=6;<br> <mark>带权周转时间</mark>=周转时间/运行时间<br> <strong>P1</strong>=16/7=2.28;<strong>P2</strong>=5/4=1.25;<strong>P3</strong>=1/1=1;<strong>P4</strong>=6/4=1.5;<br> <mark>等待时间</mark>=周转时间-运行时间<br> <strong>P1</strong>=16-7=9;<strong>P2</strong>=5-4=1;<strong>P3</strong>=1-1=0;<strong>P4</strong>=6-4=2;<br> <mark>平均周转时间</mark>=作业总周转时间/作业个数<br> 平均周转时间=（16+5+1+6）/4=7<br> <mark>平均带权周转时间</mark>=总带权周转时间/作业个数<br> 平均带权周转时间=(2.28+1.25+1+1.5)/4=1.50<br> <mark>平均等待时间</mark>=总等待时间/作业个数<br> 平均等待时间=（9+1+0+2）/4=3</p> 
</blockquote> 
<p><strong>PS:对比非抢占式的短作业优先算法，显然抢占式的这几个指标要更低</strong></p> 
<h4><a id="HRRN_101"></a>高响应比优先调度算法（HRRN）</h4> 
<h5><a id="_102"></a>前言</h5> 
<p><strong>FCFS算法</strong>在每次调度的时候选择一个等待时间最长的作业（进程）为其服务，但是没有考虑到作业的运行时间，因此导致了对短作业不友好的问题。<br> <strong>SJF算法</strong>是选择一个执行时间最短的作业为其服务。但是又完全不考虑各个作业的等待时间，因此导致了对长作业不友好的问题，甚至还会造成饥饿问题<br> <strong>高响应比优先调度算法</strong>既考虑到各个作业的等待时间，也兼顾了运行时间</p> 
<h5><a id="_107"></a>算法思想</h5> 
<p>要综合考虑作业/进程的等待时间和要求服务的时间。在每次调度时先计算各个作业/进程的响应比，选择响应比最高的作业/进程为其服务<br> <span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          响应比 
         
        
          = 
         
         
          
          
            等待时间 
           
          
            + 
           
          
            要求服务时间 
           
          
         
           要求服务时间 
          
         
        
          （响应比 
         
        
          &gt; 
         
        
          = 
         
        
          1 
         
        
          ） 
         
        
       
         响应比= \frac{等待时间+要求服务时间}{要求服务时间}（响应比&gt;=1） 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord cjk_fallback">响应比</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 2.0463em; vertical-align: -0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.3603em;"><span class="" style="top: -2.314em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord cjk_fallback">要求服务时间</span></span></span><span class="" style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span class="" style="top: -3.677em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord cjk_fallback">等待时间</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mord cjk_fallback">要求服务时间</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.686em;"><span class=""></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord cjk_fallback">（响应比</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">&gt;=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord">1</span><span class="mord cjk_fallback">）</span></span></span></span></span></span></p> 
<p>既可用于作业调度，也可用于进程调度。属于<strong>非抢占式</strong>的算法。因此只有当前运行的作业/进程主动放弃处理机时，才需要调度，才需要计算响应比。不会导致饥饿。</p> 
<h5><a id="_112"></a>优缺点</h5> 
<p><strong>优点</strong><br> <strong>综合考虑了等待时间和运行时间</strong>(要求服务时间)<br> 等待时间相同时，要求服务时间短的优先(SJF 的优点)<br> 要求服务时间相同时，等待时间长的优先(FCFS 的优点)<br> 对于长作业来说，随着等待时间越来越久，其响应比也会越来越大，从而避免了长作业饥饿的问题<br> <strong>缺点</strong><br> 由于做响应比计算故增加了系统开销</p> 
<h5><a id="_120"></a>例题</h5> 
<p>各进程到达就绪队列的时间、需要的运行时间如下表所示。使用<strong>高响应比优先调度算法</strong>，计算各进程的等待时间、平均等待时间、周转时间、平均周转时间、带权周转时间、平均带权周转时间。</p> 
<table><thead><tr><th>进程</th><th>到达时间</th><th>运行时间</th></tr></thead><tbody><tr><td>P1</td><td>0</td><td>7</td></tr><tr><td>P2</td><td>2</td><td>4</td></tr><tr><td>P3</td><td>4</td><td>1</td></tr><tr><td>P4</td><td>5</td><td>4</td></tr></tbody></table> 
<p>高响应比优先算法:非抢占式的调度算法，只有当前运行的进程主动放弃CPU时(正常/异常完成，或主动阻塞)，才需要进行调度，调度时计算所有就绪进程的响应比，选响应比最高的进程上处理机。<br> <img src="https://images2.imgbox.com/a2/35/BTWAL8WT_o.png" alt="在这里插入图片描述"><br> 0时刻:只有P到达就绪队列，<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          P 
         
        
          1 
         
        
       
      
        P_1 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8333em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.1389em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3011em;"><span class="" style="top: -2.55em; margin-left: -0.1389em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>上处理机<br> 7时刻(<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          P 
         
        
          1 
         
        
       
      
        P_1 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8333em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.1389em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3011em;"><span class="" style="top: -2.55em; margin-left: -0.1389em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>主动放弃CPU):就绪队列中有<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          P 
         
        
          2 
         
        
       
      
        P_2 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8333em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.1389em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3011em;"><span class="" style="top: -2.55em; margin-left: -0.1389em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>(响应比=(5+4)/4=2.25)、<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          P 
         
        
          3 
         
        
       
      
        P_3 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8333em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.1389em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3011em;"><span class="" style="top: -2.55em; margin-left: -0.1389em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>(响应比=(3+1)/1=3)、<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          P 
         
        
          4 
         
        
       
      
        P_4 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8333em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.1389em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3011em;"><span class="" style="top: -2.55em; margin-left: -0.1389em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>(响应比=(2+4)/4=1.5),<br> 8时刻(<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          P 
         
        
          3 
         
        
       
      
        P_3 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8333em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.1389em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3011em;"><span class="" style="top: -2.55em; margin-left: -0.1389em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>完成):<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          P 
         
        
          2 
         
        
       
      
        P_2 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8333em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.1389em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3011em;"><span class="" style="top: -2.55em; margin-left: -0.1389em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>(2.5)、<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          P 
         
        
          4 
         
        
       
      
        P_4 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8333em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.1389em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3011em;"><span class="" style="top: -2.55em; margin-left: -0.1389em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>(1.75)<br> 12时刻(<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          P 
         
        
          2 
         
        
       
      
        P_2 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8333em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.1389em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3011em;"><span class="" style="top: -2.55em; margin-left: -0.1389em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>完成):就绪队列中只剩下<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          P 
         
        
          4 
         
        
       
      
        P_4 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8333em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.1389em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3011em;"><span class="" style="top: -2.55em; margin-left: -0.1389em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ac6bc160cd6dfb6ff99b975b7728d00b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">linux服务器监控之万能命令、进程追踪、监控工具与分析、定时任务</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/85d62c1890be43179881c9c6435207cb/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Android ConstraintLayout使TextView与ImageView在一行显示</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>