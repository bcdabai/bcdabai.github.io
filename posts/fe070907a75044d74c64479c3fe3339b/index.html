<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>LeetCode-Python 链表专题（思路&#43;代码） - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="LeetCode-Python 链表专题（思路&#43;代码）" />
<meta property="og:description" content="文章目录 Leetcode 2. 两数相加Leetcode 24. 两两交换链表中的节点Leetcode 21. 合并两个有序链表Leetcode 206:反转链表Leetcode 25. K 个一组翻转链表Leetcode 141. 环形链表Leetcode 160. 相交链表Leetcode 143. 重排链表Leetcode237. 删除链表中的节点Leetcode19. 删除链表的倒数第 N 个结点Leetcode61. 旋转链表Leetcode234. 回文链表Leetcode445. 两数相加 IILeetcode23. 合并 K 个升序链表Leetcode148. 排序链表Leetcode146. LRU 缓存 Leetcode 2. 两数相加 给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。
请你将两个数相加，并以相同形式返回一个表示和的链表。
你可以假设除了数字 0 之外，这两个数都不会以 0 开头。
示例 1：
输入：l1 = [2,4,3], l2 = [5,6,4] 输出：[7,0,8] 解释：342 &#43; 465 = 807. 示例 2：
输入：l1 = [0], l2 = [0] 输出：[0] 示例 3：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/fe070907a75044d74c64479c3fe3339b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-03-28T10:46:43+08:00" />
<meta property="article:modified_time" content="2023-03-28T10:46:43+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">LeetCode-Python 链表专题（思路&#43;代码）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><ul><li><a href="#Leetcode_2__3" rel="nofollow">Leetcode 2. 两数相加</a></li><li><a href="#Leetcode_24__71" rel="nofollow">Leetcode 24. 两两交换链表中的节点</a></li><li><a href="#Leetcode_21__146" rel="nofollow">Leetcode 21. 合并两个有序链表</a></li><li><a href="#Leetcode_206_205" rel="nofollow">Leetcode 206:反转链表</a></li><li><a href="#Leetcode_25_K__313" rel="nofollow">Leetcode 25. K 个一组翻转链表</a></li><li><a href="#Leetcode_141__410" rel="nofollow">Leetcode 141. 环形链表</a></li><li><a href="#Leetcode_160__547" rel="nofollow">Leetcode 160. 相交链表</a></li><li><a href="#Leetcode_143__643" rel="nofollow">Leetcode 143. 重排链表</a></li><li><a href="#Leetcode237__716" rel="nofollow">Leetcode237. 删除链表中的节点</a></li><li><a href="#Leetcode19__N__774" rel="nofollow">Leetcode19. 删除链表的倒数第 N 个结点</a></li><li><a href="#Leetcode61__864" rel="nofollow">Leetcode61. 旋转链表</a></li><li><a href="#Leetcode234__930" rel="nofollow">Leetcode234. 回文链表</a></li><li><a href="#Leetcode445__II_994" rel="nofollow">Leetcode445. 两数相加 II</a></li><li><a href="#Leetcode23__K__1056" rel="nofollow">Leetcode23. 合并 K 个升序链表</a></li><li><a href="#Leetcode148__1140" rel="nofollow">Leetcode148. 排序链表</a></li><li><a href="#Leetcode146_LRU__1213" rel="nofollow">Leetcode146. LRU 缓存</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<hr> 
<h3><a id="Leetcode_2__3"></a>Leetcode 2. 两数相加</h3> 
<p>给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。</p> 
<p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p> 
<p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p> 
<p><img src="https://images2.imgbox.com/fb/10/fiWxMWl9_o.png" alt="在这里插入图片描述"></p> 
<p>示例 1：</p> 
<pre><code>输入：l1 = [2,4,3], l2 = [5,6,4]
输出：[7,0,8]
解释：342 + 465 = 807.
</code></pre> 
<p>示例 2：</p> 
<pre><code>输入：l1 = [0], l2 = [0]
输出：[0]
</code></pre> 
<p>示例 3：</p> 
<pre><code>输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]
输出：[8,9,9,9,0,0,0,1]
</code></pre> 
<p>来源：力扣（LeetCode）<br> 链接：https://leetcode-cn.com/problems/add-two-numbers<br> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。<br> 思路：<br> 先判断一下哪个链表长，然后用交换的方法确保一定是l1更长。<br> 然后把l2的值加到l1上，全部加完之后遍历l1处理进位，记得处理最后一位需要进1的特殊情况。</p> 
<pre><code class="prism language-python"><span class="token keyword">class</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token builtin">object</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>val <span class="token operator">=</span> x
        self<span class="token punctuation">.</span><span class="token builtin">next</span> <span class="token operator">=</span> <span class="token boolean">None</span>


<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token comment"># @return a ListNode</span>
    <span class="token keyword">def</span> <span class="token function">addTwoNumbers</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> l1<span class="token punctuation">,</span> l2<span class="token punctuation">)</span><span class="token punctuation">:</span>
        head <span class="token operator">=</span> ListNode<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
        l <span class="token operator">=</span> head
        carry <span class="token operator">=</span> <span class="token number">0</span>
        <span class="token keyword">while</span> l1 <span class="token keyword">or</span> l2 <span class="token keyword">or</span> carry<span class="token punctuation">:</span>
            <span class="token builtin">sum</span><span class="token punctuation">,</span> carry <span class="token operator">=</span> carry<span class="token punctuation">,</span> <span class="token number">0</span>
            <span class="token keyword">if</span> l1<span class="token punctuation">:</span>
                <span class="token builtin">sum</span> <span class="token operator">+=</span> l1<span class="token punctuation">.</span>val
                l1 <span class="token operator">=</span> l1<span class="token punctuation">.</span><span class="token builtin">next</span>
            <span class="token keyword">if</span> l2<span class="token punctuation">:</span>
                <span class="token builtin">sum</span> <span class="token operator">+=</span> l2<span class="token punctuation">.</span>val
                l2 <span class="token operator">=</span> l2<span class="token punctuation">.</span><span class="token builtin">next</span>
            <span class="token keyword">if</span> <span class="token builtin">sum</span> <span class="token operator">&gt;</span> <span class="token number">9</span><span class="token punctuation">:</span>
                carry <span class="token operator">=</span> <span class="token number">1</span>
                <span class="token builtin">sum</span> <span class="token operator">-=</span> <span class="token number">10</span>
            l<span class="token punctuation">.</span><span class="token builtin">next</span> <span class="token operator">=</span> ListNode<span class="token punctuation">(</span><span class="token builtin">sum</span><span class="token punctuation">)</span>
            l <span class="token operator">=</span> l<span class="token punctuation">.</span><span class="token builtin">next</span>
        <span class="token keyword">return</span> head<span class="token punctuation">.</span><span class="token builtin">next</span>


<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>
    a<span class="token punctuation">,</span> a<span class="token punctuation">.</span><span class="token builtin">next</span><span class="token punctuation">,</span> a<span class="token punctuation">.</span><span class="token builtin">next</span><span class="token punctuation">.</span><span class="token builtin">next</span> <span class="token operator">=</span> ListNode<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> ListNode<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span> ListNode<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>
    b<span class="token punctuation">,</span> b<span class="token punctuation">.</span><span class="token builtin">next</span><span class="token punctuation">,</span> b<span class="token punctuation">.</span><span class="token builtin">next</span><span class="token punctuation">.</span><span class="token builtin">next</span> <span class="token operator">=</span> ListNode<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">,</span> ListNode<span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">,</span> ListNode<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span>
    result <span class="token operator">=</span> Solution<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>addTwoNumbers<span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"{0} -&gt; {1} -&gt; {2}"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>result<span class="token punctuation">.</span>val<span class="token punctuation">,</span> result<span class="token punctuation">.</span><span class="token builtin">next</span><span class="token punctuation">.</span>val<span class="token punctuation">,</span> result<span class="token punctuation">.</span><span class="token builtin">next</span><span class="token punctuation">.</span><span class="token builtin">next</span><span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">)</span>

</code></pre> 
<h3><a id="Leetcode_24__71"></a>Leetcode 24. 两两交换链表中的节点</h3> 
<p>给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。</p> 
<p><img src="https://images2.imgbox.com/5d/c1/izEScku8_o.png" alt="在这里插入图片描述"></p> 
<p>示例 1：</p> 
<pre><code>输入：head = [1,2,3,4]
输出：[2,1,4,3]
</code></pre> 
<p>示例 2：</p> 
<pre><code>输入：head = []
输出：[]
</code></pre> 
<p>示例 3：</p> 
<pre><code>输入：head = [1]
输出：[1]
</code></pre> 
<p>来源：力扣（LeetCode）<br> 链接：https://leetcode-cn.com/problems/swap-nodes-in-pairs<br> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p> 
<p>解题思路</p> 
<p>我们首先需要建立pre、node1、node2和lat四个指针即可。</p> 
<pre><code>pre   node1  node2   lat
 h  -&gt;  1  -&gt;  2  -&gt;  3  -&gt;  4
</code></pre> 
<p>然后pre-&gt;next=node2;node2.next=node1;node1.next=lat</p> 
<pre><code>     -----------
     |         |
h    1 &lt;- 2 -&gt; 3 -&gt; 4
|         |
-----------
</code></pre> 
<p>接着更新四个指针即可。</p> 
<pre><code class="prism language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">swapPairs</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token triple-quoted-string string">"""
        :type head: ListNode
        :rtype: ListNode
        """</span>
        h <span class="token operator">=</span> ListNode<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
        h<span class="token punctuation">.</span><span class="token builtin">next</span> <span class="token operator">=</span> head
        pre <span class="token operator">=</span> h
        <span class="token keyword">while</span> pre<span class="token punctuation">.</span><span class="token builtin">next</span> <span class="token operator">!=</span> <span class="token boolean">None</span> <span class="token keyword">and</span> pre<span class="token punctuation">.</span><span class="token builtin">next</span><span class="token punctuation">.</span><span class="token builtin">next</span> <span class="token operator">!=</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
            node1 <span class="token operator">=</span> pre<span class="token punctuation">.</span><span class="token builtin">next</span>
            node2 <span class="token operator">=</span> node1<span class="token punctuation">.</span><span class="token builtin">next</span>
            lat <span class="token operator">=</span> node2<span class="token punctuation">.</span><span class="token builtin">next</span>

            pre<span class="token punctuation">.</span><span class="token builtin">next</span> <span class="token operator">=</span> node2            
            node2<span class="token punctuation">.</span><span class="token builtin">next</span> <span class="token operator">=</span> node1
            node1<span class="token punctuation">.</span><span class="token builtin">next</span> <span class="token operator">=</span> lat
            
            pre <span class="token operator">=</span> node1

        <span class="token keyword">return</span> h<span class="token punctuation">.</span><span class="token builtin">next</span>




</code></pre> 
<h3><a id="Leetcode_21__146"></a>Leetcode 21. 合并两个有序链表</h3> 
<p>将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</p> 
<p><img src="https://images2.imgbox.com/0f/0b/lYnDnlMX_o.png" alt="在这里插入图片描述"></p> 
<p>示例 1：</p> 
<pre><code>输入：l1 = [1,2,4], l2 = [1,3,4]
输出：[1,1,2,3,4,4]
</code></pre> 
<p>示例 2：</p> 
<pre><code>输入：l1 = [], l2 = []
输出：[]
</code></pre> 
<p>示例 3：</p> 
<pre><code>输入：l1 = [], l2 = [0]
输出：[0]
</code></pre> 
<p>来源：力扣（LeetCode）<br> 链接：https://leetcode-cn.com/problems/merge-two-sorted-lists<br> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p> 
<pre><code class="prism language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">mergeTwoLists</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> l1<span class="token punctuation">:</span> ListNode<span class="token punctuation">,</span> l2<span class="token punctuation">:</span> ListNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> ListNode<span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> l1<span class="token punctuation">:</span> 
            <span class="token keyword">return</span> l2  <span class="token comment"># 终止条件，直到两个链表都空</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> l2<span class="token punctuation">:</span> 
            <span class="token keyword">return</span> l1
        <span class="token keyword">if</span> l1<span class="token punctuation">.</span>val <span class="token operator">&lt;=</span> l2<span class="token punctuation">.</span>val<span class="token punctuation">:</span>  <span class="token comment"># 递归调用</span>
            l1<span class="token punctuation">.</span><span class="token builtin">next</span> <span class="token operator">=</span> self<span class="token punctuation">.</span>mergeTwoLists<span class="token punctuation">(</span>l1<span class="token punctuation">.</span><span class="token builtin">next</span><span class="token punctuation">,</span>l2<span class="token punctuation">)</span>
            <span class="token keyword">return</span> l1
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            l2<span class="token punctuation">.</span><span class="token builtin">next</span> <span class="token operator">=</span> self<span class="token punctuation">.</span>mergeTwoLists<span class="token punctuation">(</span>l1<span class="token punctuation">,</span>l2<span class="token punctuation">.</span><span class="token builtin">next</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> l2

</code></pre> 
<pre><code class="prism language-python"><span class="token comment"># Definition for singly-linked list.</span>
<span class="token comment"># class ListNode:</span>
<span class="token comment">#     def __init__(self, x):</span>
<span class="token comment">#         self.val = x</span>
<span class="token comment">#         self.next = None</span>

<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">mergeTwoLists</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> l1<span class="token punctuation">:</span> ListNode<span class="token punctuation">,</span> l2<span class="token punctuation">:</span> ListNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> ListNode<span class="token punctuation">:</span>
        <span class="token keyword">if</span> l1 <span class="token keyword">and</span> l2<span class="token punctuation">:</span>
            <span class="token keyword">if</span> l1<span class="token punctuation">.</span>val <span class="token operator">&gt;</span> l2<span class="token punctuation">.</span>val<span class="token punctuation">:</span> 
                l1<span class="token punctuation">,</span> l2 <span class="token operator">=</span> l2<span class="token punctuation">,</span> l1
            l1<span class="token punctuation">.</span><span class="token builtin">next</span> <span class="token operator">=</span> self<span class="token punctuation">.</span>mergeTwoLists<span class="token punctuation">(</span>l1<span class="token punctuation">.</span><span class="token builtin">next</span><span class="token punctuation">,</span> l2<span class="token punctuation">)</span>
        <span class="token keyword">return</span> l1 <span class="token keyword">or</span> l2


</code></pre> 
<h3><a id="Leetcode_206_205"></a>Leetcode 206:反转链表</h3> 
<p>给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。</p> 
<p><img src="https://images2.imgbox.com/c4/42/xxb3x6X1_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/47/13/GxBmjS0A_o.png" alt="在这里插入图片描述"></p> 
<p>示例 1：</p> 
<pre><code>输入：head = [1,2,3,4,5]
输出：[5,4,3,2,1]
</code></pre> 
<p>示例 2：</p> 
<pre><code>输入：head = [1,2]
输出：[2,1]
</code></pre> 
<p>示例 3：</p> 
<pre><code>输入：head = []
输出：[]
</code></pre> 
<p>来源：力扣（LeetCode）<br> 链接：https://leetcode-cn.com/problems/reverse-linked-list<br> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p> 
<p>解题思路：</p> 
<p>要将链表 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; Null 反转为 4 -&gt; 3 -&gt; 2 -&gt; 1 -&gt; Null ，需要一个 cur 指针表示当前遍历到的节点；一个 pre 指针表示当前节点的前驱节点；在循环中还需要一个中间变量 temp 来保存当前节点的后驱节点。<br> 算法流程：</p> 
<pre><code>首先 pre 指针指向 Null，cur 指针指向 head；

当 cur != Null，执行循环。

    先将 cur.next 保存在 temp 中防止链表丢失：temp = cur.next

    接着把 cur.next 指向前驱节点 pre：cur.next = pre

    然后将 pre 往后移一位也就是移到当前 cur 的位置：pre = cur

    最后把 cur 也往后移一位也就是 temp 的位置：cur = temp

当 cur == Null，结束循环，返回 pre。
</code></pre> 
<p><img src="https://images2.imgbox.com/5f/6e/bpEnF1YD_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">reverseList</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token triple-quoted-string string">"""
        :type head: ListNode
        :rtype: ListNode
        """</span>
        pre <span class="token operator">=</span> <span class="token boolean">None</span>
        cur <span class="token operator">=</span> head

        <span class="token keyword">while</span> cur <span class="token operator">!=</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
            temp<span class="token operator">=</span> cur<span class="token punctuation">.</span><span class="token builtin">next</span>
            cur<span class="token punctuation">.</span><span class="token builtin">next</span> <span class="token operator">=</span> pre
            pre <span class="token operator">=</span> cur
            cur <span class="token operator">=</span> temp

        <span class="token keyword">return</span> pre

</code></pre> 
<p>使用递归就更简单了，我们知道reverseList(head)返回输入的链表反转后的head，那么如果reverseList(head.next)的话</p> 
<pre><code>head
  1-&gt;2&lt;-3&lt;-4&lt;-5
              |
             node
</code></pre> 
<p>我们此时只需要head.next.next=head，也就是先建立一个双向连接</p> 
<pre><code>head
  1-&gt;2&lt;-3&lt;-4&lt;-5
   &lt;-         |
             node
</code></pre> 
<p>然后再head.next=None，返回node即可。</p> 
<pre><code>      head
  null&lt;-1&lt;-2&lt;-3&lt;-4&lt;-5
                    |
                   node
</code></pre> 
<pre><code class="prism language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">reverseList</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token triple-quoted-string string">"""
        :type head: ListNode
        :rtype: ListNode
        """</span>
        <span class="token keyword">if</span> head <span class="token operator">==</span> <span class="token boolean">None</span> <span class="token keyword">or</span> head<span class="token punctuation">.</span><span class="token builtin">next</span> <span class="token operator">==</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> head
        node <span class="token operator">=</span> self<span class="token punctuation">.</span>reverseList<span class="token punctuation">(</span>head<span class="token punctuation">.</span><span class="token builtin">next</span><span class="token punctuation">)</span>
        head<span class="token punctuation">.</span><span class="token builtin">next</span><span class="token punctuation">.</span><span class="token builtin">next</span> <span class="token operator">=</span> head
        head<span class="token punctuation">.</span><span class="token builtin">next</span> <span class="token operator">=</span> <span class="token boolean">None</span>
        <span class="token keyword">return</span> node

</code></pre> 
<h3><a id="Leetcode_25_K__313"></a>Leetcode 25. K 个一组翻转链表</h3> 
<p>给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。</p> 
<p>k 是一个正整数，它的值小于或等于链表的长度。</p> 
<p>如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。</p> 
<p>进阶：</p> 
<pre><code>你可以设计一个只使用常数额外空间的算法来解决此问题吗？
你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。
</code></pre> 
<p>示例 1：<br> <img src="https://images2.imgbox.com/85/67/senrZW3g_o.png" alt="在这里插入图片描述"></p> 
<pre><code>输入：head = [1,2,3,4,5], k = 2
输出：[2,1,4,3,5]
</code></pre> 
<p>示例 2：<br> <img src="https://images2.imgbox.com/2d/85/ZaoDJQhr_o.png" alt="在这里插入图片描述"></p> 
<pre><code>输入：head = [1,2,3,4,5], k = 3
输出：[3,2,1,4,5]
</code></pre> 
<p>示例 3：</p> 
<pre><code>输入：head = [1,2,3,4,5], k = 1
输出：[1,2,3,4,5]
</code></pre> 
<p>示例 4：</p> 
<pre><code>输入：head = [1], k = 1
输出：[1]
</code></pre> 
<p>来源：力扣（LeetCode）<br> 链接：https://leetcode-cn.com/problems/reverse-nodes-in-k-group<br> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。<br> 思路：</p> 
<pre><code>所有涉及链表翻转的题目都可以由下述代码中的reverseMN(M, N)进行实现，注意这里的M, N是节点。该函数的目的是返回 M -&gt; ... -&gt; N 链表反转后的首尾节点。
以下是一些相关题目：
    206.反转链表      
    25.反转第m到第n个节点
    92.每K个一组翻转链表
    143.重排链表
</code></pre> 
<p>只需将每个场景下的 M, N 界定清晰就够了</p> 
<pre><code class="prism language-python"><span class="token comment"># Definition for singly-linked list.</span>
<span class="token comment"># class ListNode:</span>
<span class="token comment">#     def __init__(self, val=0, next=None):</span>
<span class="token comment">#         self.val = val</span>
<span class="token comment">#         self.next = next</span>
<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">reverseKGroup</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> ListNode<span class="token punctuation">,</span> k<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> ListNode<span class="token punctuation">:</span>
        
        <span class="token keyword">def</span> <span class="token function">reverseMN</span><span class="token punctuation">(</span>M<span class="token punctuation">,</span> N<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token comment"># M节点到N节点 翻转后返回首尾节点</span>
            tail <span class="token operator">=</span> <span class="token boolean">None</span>
            cur <span class="token operator">=</span> M
            <span class="token keyword">while</span> cur <span class="token operator">!=</span> N<span class="token punctuation">:</span>
                temp <span class="token operator">=</span> cur<span class="token punctuation">.</span><span class="token builtin">next</span>
                cur<span class="token punctuation">.</span><span class="token builtin">next</span> <span class="token operator">=</span> tail
                tail <span class="token operator">=</span> cur 
                cur <span class="token operator">=</span> temp
            cur<span class="token punctuation">.</span><span class="token builtin">next</span> <span class="token operator">=</span> tail
            <span class="token keyword">return</span> N<span class="token punctuation">,</span> M

        static_dummy <span class="token operator">=</span> ListNode<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
        static_dummy<span class="token punctuation">.</span><span class="token builtin">next</span> <span class="token operator">=</span> head
        movable_dummy <span class="token operator">=</span> static_dummy
        start <span class="token operator">=</span> head

        <span class="token keyword">while</span> start<span class="token punctuation">:</span>
            temp_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
            <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">:</span>
                <span class="token keyword">if</span> start<span class="token punctuation">:</span>
                    temp_list<span class="token punctuation">.</span>append<span class="token punctuation">(</span>start<span class="token punctuation">)</span>
                    start <span class="token operator">=</span> start<span class="token punctuation">.</span><span class="token builtin">next</span>
                <span class="token keyword">else</span><span class="token punctuation">:</span>
                    <span class="token keyword">break</span>
            <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>temp_list<span class="token punctuation">)</span> <span class="token operator">==</span> k<span class="token punctuation">:</span>
                cur_head<span class="token punctuation">,</span> cur_tail <span class="token operator">=</span> reverseMN<span class="token punctuation">(</span>temp_list<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> temp_list<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
                movable_dummy<span class="token punctuation">.</span><span class="token builtin">next</span> <span class="token operator">=</span> cur_head
                movable_dummy <span class="token operator">=</span> cur_tail
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                movable_dummy<span class="token punctuation">.</span><span class="token builtin">next</span> <span class="token operator">=</span> temp_list<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
                movable_dummy <span class="token operator">=</span> temp_list<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>
        <span class="token keyword">return</span> static_dummy<span class="token punctuation">.</span><span class="token builtin">next</span>
  
</code></pre> 
<h3><a id="Leetcode_141__410"></a>Leetcode 141. 环形链表</h3> 
<p>给你一个链表的头节点 head ，判断链表中是否有环。</p> 
<p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：pos 不作为参数进行传递 。仅仅是为了标识链表的实际情况。</p> 
<p>如果链表中存在环 ，则返回 true 。 否则，返回 false 。</p> 
<p>示例 1：<br> <img src="https://images2.imgbox.com/71/96/Q4mb7LLa_o.png" alt="在这里插入图片描述"></p> 
<pre><code>输入：head = [3,2,0,-4], pos = 1
输出：true
解释：链表中有一个环，其尾部连接到第二个节点。
</code></pre> 
<p>示例 2：<br> <img src="https://images2.imgbox.com/56/a1/2Husjlco_o.png" alt="在这里插入图片描述"></p> 
<pre><code>输入：head = [1,2], pos = 0
输出：true
解释：链表中有一个环，其尾部连接到第一个节点。
</code></pre> 
<p>示例 3：<br> <img src="https://images2.imgbox.com/95/8a/F6hIoB9d_o.png" alt="在这里插入图片描述"></p> 
<pre><code>输入：head = [1], pos = -1
输出：false
解释：链表中没有环。
</code></pre> 
<p>来源：力扣（LeetCode）<br> 链接：https://leetcode-cn.com/problems/linked-list-cycle<br> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p> 
<p>解题思路</p> 
<pre><code>首先 头结点为空 则一定没环
定义一个慢节点 每次走一步
定义一个快节点 每次走两步
由于快节点将比慢节点更快到达尾部 所以循环条件只用设定快节点的
若是单节点链表 默认无环 循环中j.next != None 将筛选出单节点链表
若链表有两个节点 j移动一次后 就到了链表尾为空的地方 j != None 则让循环停止
链表有三个节点时 j移动一次 到达链表最尾元素 通过j,next!= None停止循环

所以循环条件定为 while j!= None and j.next != None 即可
</code></pre> 
<pre><code class="prism language-python"><span class="token comment"># Definition for singly-linked list.</span>
<span class="token comment"># class ListNode:</span>
<span class="token comment">#     def __init__(self, x):</span>
<span class="token comment">#         self.val = x</span>
<span class="token comment">#         self.next = None</span>

<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">hasCycle</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>ListNode<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">bool</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> head <span class="token operator">==</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token boolean">False</span>

        i <span class="token operator">=</span> head
        j <span class="token operator">=</span> head
 
        <span class="token keyword">while</span> j<span class="token operator">!=</span> <span class="token boolean">None</span> <span class="token keyword">and</span> j<span class="token punctuation">.</span><span class="token builtin">next</span> <span class="token operator">!=</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
            i <span class="token operator">=</span> i<span class="token punctuation">.</span><span class="token builtin">next</span>
            j <span class="token operator">=</span> j<span class="token punctuation">.</span><span class="token builtin">next</span><span class="token punctuation">.</span><span class="token builtin">next</span>

            <span class="token keyword">if</span> i <span class="token operator">==</span> j<span class="token punctuation">:</span>
                <span class="token keyword">return</span> <span class="token boolean">True</span>

            <span class="token comment"># if j == None:</span>
            <span class="token comment">#     return False</span>

        <span class="token keyword">return</span> <span class="token boolean">False</span>


</code></pre> 
<p>hash表<br> 思路</p> 
<pre><code>使用hash表记录已经访问过的节点
</code></pre> 
<pre><code class="prism language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
	    <span class="token keyword">def</span> <span class="token function">hasCycle</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> ListNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">bool</span><span class="token punctuation">:</span>
	        <span class="token comment"># 1. python map</span>
	        m <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
	        <span class="token keyword">while</span> head<span class="token punctuation">:</span>
	            <span class="token keyword">if</span> m<span class="token punctuation">.</span>get<span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">:</span>
	                <span class="token keyword">return</span> <span class="token boolean">True</span>
	            m<span class="token punctuation">[</span>head<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>
	            head <span class="token operator">=</span> head<span class="token punctuation">.</span><span class="token builtin">next</span>
	        <span class="token keyword">return</span> <span class="token boolean">False</span>
</code></pre> 
<p>链表计数（空间复杂度O(1)）<br> 思路<br> 链表中最多10000个节点，超过10000就是有环</p> 
<pre><code class="prism language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
	    <span class="token keyword">def</span> <span class="token function">hasCycle</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> ListNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">bool</span><span class="token punctuation">:</span>
	        <span class="token comment"># 3. 计数 10000</span>
	        count <span class="token operator">=</span> <span class="token number">0</span>
	        <span class="token keyword">while</span> head <span class="token keyword">and</span> count <span class="token operator">&lt;=</span> <span class="token number">10000</span><span class="token punctuation">:</span>
	            count<span class="token punctuation">,</span> head <span class="token operator">=</span> count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> head<span class="token punctuation">.</span><span class="token builtin">next</span>
	        <span class="token keyword">return</span> count <span class="token operator">&gt;</span> <span class="token number">10000</span>
</code></pre> 
<p>链表反转（空间复杂度O(1)，变更原链表结构）<br> 思路</p> 
<p>按顺序反转链表，由于环之前的部分已经反转，最后会返回到head节点<br> 空间复杂度为O(1)，但是</p> 
<pre><code class="prism language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
	    <span class="token keyword">def</span> <span class="token function">hasCycle</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> ListNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">bool</span><span class="token punctuation">:</span>
	        <span class="token comment"># 4. 列表倒置</span>
	        <span class="token keyword">if</span> <span class="token keyword">not</span> head <span class="token keyword">or</span> <span class="token keyword">not</span> head<span class="token punctuation">.</span><span class="token builtin">next</span><span class="token punctuation">:</span>
	            <span class="token keyword">return</span> <span class="token boolean">False</span>
	        p<span class="token punctuation">,</span> q <span class="token operator">=</span> <span class="token boolean">None</span><span class="token punctuation">,</span> head
	        <span class="token keyword">while</span> q<span class="token punctuation">:</span>
	            u<span class="token punctuation">,</span> p<span class="token punctuation">,</span> q <span class="token operator">=</span> p<span class="token punctuation">,</span> q<span class="token punctuation">,</span> q<span class="token punctuation">.</span><span class="token builtin">next</span>
	            p<span class="token punctuation">.</span><span class="token builtin">next</span> <span class="token operator">=</span> u
	        <span class="token keyword">return</span> head <span class="token operator">==</span> p
</code></pre> 
<h3><a id="Leetcode_160__547"></a>Leetcode 160. 相交链表</h3> 
<p>给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。</p> 
<p>图示两个链表在节点 c1 开始相交：<br> <img src="https://images2.imgbox.com/db/08/pR4i7UnZ_o.png" alt="在这里插入图片描述"></p> 
<p>题目数据 保证 整个链式结构中不存在环。</p> 
<p>注意，函数返回结果后，链表必须 保持其原始结构 。</p> 
<p>自定义评测：</p> 
<p>评测系统 的输入如下（你设计的程序 不适用 此输入）：</p> 
<pre><code>intersectVal - 相交的起始节点的值。如果不存在相交节点，这一值为 0
listA - 第一个链表
listB - 第二个链表
skipA - 在 listA 中（从头节点开始）跳到交叉节点的节点数
skipB - 在 listB 中（从头节点开始）跳到交叉节点的节点数
</code></pre> 
<p>评测系统将根据这些输入创建链式数据结构，并将两个头节点 headA 和 headB 传递给你的程序。如果程序能够正确返回相交节点，那么你的解决方案将被 视作正确答案 。</p> 
<p>示例 1：<br> <img src="https://images2.imgbox.com/51/98/rlz0E6Bs_o.png" alt="在这里插入图片描述"></p> 
<pre><code>输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3
输出：Intersected at '8'
解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。
从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,6,1,8,4,5]。
在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。
</code></pre> 
<p>示例 2：<br> <img src="https://images2.imgbox.com/a7/97/V8EwaSy8_o.png" alt="在这里插入图片描述"></p> 
<pre><code>输入：intersectVal = 2, listA = [1,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1
输出：Intersected at '2'
解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。
从各自的表头开始算起，链表 A 为 [1,9,1,2,4]，链表 B 为 [3,2,4]。
在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。
</code></pre> 
<p>示例 3：<br> <img src="https://images2.imgbox.com/bf/2c/ZQ7ZYxcy_o.png" alt="在这里插入图片描述"></p> 
<pre><code>输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2
输出：null
解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。
由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。
这两个链表不相交，因此返回 null 。
</code></pre> 
<p>来源：力扣（LeetCode）<br> 链接：https://leetcode-cn.com/problems/intersection-of-two-linked-lists<br> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。<br> 解题思路：</p> 
<p>设「第一个公共节点」为 node ，「链表 headA」的节点数量为 aaa ，「链表 headB」的节点数量为 bbb ，「两链表的公共尾部」的节点数量为 ccc ，则有：</p> 
<pre><code>头节点 headA 到 node 前，共有 a−ca - ca−c 个节点；
头节点 headB 到 node 前，共有 b−cb - cb−c 个节点；
</code></pre> 
<p><img src="https://images2.imgbox.com/e8/2b/l3I3Efia_o.png" alt="在这里插入图片描述"><br> 考虑构建两个节点指针 A​ , B 分别指向两链表头节点 headA , headB ，做如下操作：</p> 
<pre><code>指针 A 先遍历完链表 headA ，再开始遍历链表 headB ，当走到 node 时，共走步数为：
</code></pre> 
<p>a+(b−c)a + (b - c) a+(b−c)</p> 
<pre><code>指针 B 先遍历完链表 headB ，再开始遍历链表 headA ，当走到 node 时，共走步数为：
</code></pre> 
<p>b+(a−c)b + (a - c) b+(a−c)</p> 
<p>如下式所示，此时指针 A , B 重合，并有两种情况：</p> 
<p>a+(b−c)=b+(a−c)a + (b - c) = b + (a - c) a+(b−c)=b+(a−c)</p> 
<pre><code>若两链表 有 公共尾部 (即 c&gt;0c &gt; 0c&gt;0 ) ：指针 A , B 同时指向「第一个公共节点」node 。
若两链表 无 公共尾部 (即 c=0c = 0c=0 ) ：指针 A , B 同时指向 nullnullnull 。
</code></pre> 
<p>因此返回 A 即可。</p> 
<pre><code>如下图所示，为 a=5a = 5a=5 , b=3b = 3b=3 , c=2c = 2c=2 示例的算法执行过程。
</code></pre> 
<p><img src="https://images2.imgbox.com/15/99/q0m78amH_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">getIntersectionNode</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> headA<span class="token punctuation">:</span> ListNode<span class="token punctuation">,</span> headB<span class="token punctuation">:</span> ListNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> ListNode<span class="token punctuation">:</span>
        A<span class="token punctuation">,</span> B <span class="token operator">=</span> headA<span class="token punctuation">,</span> headB
        <span class="token keyword">while</span> A <span class="token operator">!=</span> B<span class="token punctuation">:</span>
            A <span class="token operator">=</span> A<span class="token punctuation">.</span><span class="token builtin">next</span> <span class="token keyword">if</span> A <span class="token keyword">else</span> headB
            B <span class="token operator">=</span> B<span class="token punctuation">.</span><span class="token builtin">next</span> <span class="token keyword">if</span> B <span class="token keyword">else</span> headA
        <span class="token keyword">return</span> A

</code></pre> 
<h3><a id="Leetcode_143__643"></a>Leetcode 143. 重排链表</h3> 
<p>给定一个单链表 L 的头节点 head ，单链表 L 表示为：</p> 
<p>L0 → L1 → … → Ln - 1 → Ln</p> 
<p>请将其重新排列后变为：</p> 
<p>L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → …</p> 
<p>不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p> 
<p>示例 1：<br> <img src="https://images2.imgbox.com/af/78/JKObIhnG_o.png" alt="在这里插入图片描述"></p> 
<pre><code>输入：head = [1,2,3,4]
输出：[1,4,2,3]
</code></pre> 
<p>示例 2：<br> <img src="https://images2.imgbox.com/0d/fe/8XIVXAn7_o.png" alt="在这里插入图片描述"></p> 
<pre><code>输入：head = [1,2,3,4,5]
输出：[1,5,2,4,3]
</code></pre> 
<p>来源：力扣（LeetCode）<br> 链接：https://leetcode-cn.com/problems/reorder-list<br> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p> 
<pre><code class="prism language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">reorderList</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> ListNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token boolean">None</span><span class="token punctuation">:</span>       
        <span class="token keyword">if</span> <span class="token keyword">not</span> head <span class="token keyword">or</span> <span class="token keyword">not</span> head<span class="token punctuation">.</span><span class="token builtin">next</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> head
        <span class="token comment"># 用快慢指针把链表一分为二，前半部分长度 &gt;= 后半部分长度</span>
        <span class="token comment"># first 为前半部分的头部，second 为后半部分的头部</span>
        first <span class="token operator">=</span> low <span class="token operator">=</span> fast <span class="token operator">=</span> head
        <span class="token keyword">while</span> fast<span class="token punctuation">.</span><span class="token builtin">next</span> <span class="token keyword">and</span> fast<span class="token punctuation">.</span><span class="token builtin">next</span><span class="token punctuation">.</span><span class="token builtin">next</span><span class="token punctuation">:</span>
            fast<span class="token punctuation">,</span> low <span class="token operator">=</span> fast<span class="token punctuation">.</span><span class="token builtin">next</span><span class="token punctuation">.</span><span class="token builtin">next</span><span class="token punctuation">,</span> low<span class="token punctuation">.</span><span class="token builtin">next</span>
        second<span class="token punctuation">,</span> node<span class="token punctuation">,</span> low<span class="token punctuation">.</span><span class="token builtin">next</span><span class="token punctuation">,</span> second<span class="token punctuation">.</span><span class="token builtin">next</span> <span class="token operator">=</span> low<span class="token punctuation">.</span><span class="token builtin">next</span><span class="token punctuation">,</span> low<span class="token punctuation">.</span><span class="token builtin">next</span><span class="token punctuation">.</span><span class="token builtin">next</span><span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">,</span> <span class="token boolean">None</span>
        <span class="token comment"># 后半部分逆序</span>
        <span class="token keyword">while</span> node<span class="token punctuation">:</span>
            node<span class="token punctuation">.</span><span class="token builtin">next</span><span class="token punctuation">,</span> second<span class="token punctuation">,</span> node <span class="token operator">=</span> second<span class="token punctuation">,</span> node<span class="token punctuation">,</span> node<span class="token punctuation">.</span><span class="token builtin">next</span>
        <span class="token comment"># 前后部分交替链接</span>
        <span class="token keyword">while</span> second<span class="token punctuation">:</span>
            first<span class="token punctuation">.</span><span class="token builtin">next</span><span class="token punctuation">,</span> second<span class="token punctuation">.</span><span class="token builtin">next</span><span class="token punctuation">,</span> first<span class="token punctuation">,</span> second <span class="token operator">=</span> second<span class="token punctuation">,</span> first<span class="token punctuation">.</span><span class="token builtin">next</span><span class="token punctuation">,</span> first<span class="token punctuation">.</span><span class="token builtin">next</span><span class="token punctuation">,</span> second<span class="token punctuation">.</span><span class="token builtin">next</span>

</code></pre> 
<pre><code class="prism language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">reorderList</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> ListNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> head<span class="token punctuation">:</span><span class="token keyword">return</span>
        <span class="token comment"># 找到中点</span>
        slow<span class="token punctuation">,</span>fast <span class="token operator">=</span> head<span class="token punctuation">,</span>head
        <span class="token keyword">while</span> fast <span class="token keyword">and</span> fast<span class="token punctuation">.</span><span class="token builtin">next</span><span class="token punctuation">:</span>
            slow <span class="token operator">=</span> slow<span class="token punctuation">.</span><span class="token builtin">next</span>
            fast <span class="token operator">=</span> fast<span class="token punctuation">.</span><span class="token builtin">next</span><span class="token punctuation">.</span><span class="token builtin">next</span>
        <span class="token comment"># 翻转后半</span>
        pre<span class="token punctuation">,</span>cur <span class="token operator">=</span> <span class="token boolean">None</span><span class="token punctuation">,</span>slow<span class="token punctuation">.</span><span class="token builtin">next</span>
        slow<span class="token punctuation">.</span><span class="token builtin">next</span> <span class="token operator">=</span> <span class="token boolean">None</span> 
        <span class="token keyword">while</span> cur<span class="token punctuation">:</span>
            nxt <span class="token operator">=</span> cur<span class="token punctuation">.</span><span class="token builtin">next</span>
            cur<span class="token punctuation">.</span><span class="token builtin">next</span> <span class="token operator">=</span> pre
            pre<span class="token punctuation">,</span>cur <span class="token operator">=</span> cur<span class="token punctuation">,</span>nxt
        <span class="token comment"># 交替合并</span>
        p<span class="token punctuation">,</span>q <span class="token operator">=</span> head<span class="token punctuation">,</span>pre
        <span class="token keyword">while</span> q<span class="token punctuation">:</span>
            nxt <span class="token operator">=</span> p<span class="token punctuation">.</span><span class="token builtin">next</span>
            p<span class="token punctuation">.</span><span class="token builtin">next</span> <span class="token operator">=</span> q
            p<span class="token punctuation">,</span>q <span class="token operator">=</span> q<span class="token punctuation">,</span>nxt

</code></pre> 
<h3><a id="Leetcode237__716"></a>Leetcode237. 删除链表中的节点</h3> 
<p>有一个单链表的 head，我们想删除它其中的一个节点 node。</p> 
<p>给你一个需要删除的节点 node 。你将 无法访问 第一个节点 head。</p> 
<p>链表的所有值都是 唯一的，并且保证给定的节点 node 不是链表中的最后一个节点。</p> 
<p>删除给定的节点。注意，删除节点并不是指从内存中删除它。这里的意思是：</p> 
<pre><code>给定节点的值不应该存在于链表中。
链表中的节点数应该减少 1。
node 前面的所有值顺序相同。
node 后面的所有值顺序相同。
</code></pre> 
<p>自定义测试：</p> 
<pre><code>对于输入，你应该提供整个链表 head 和要给出的节点 node。node 不应该是链表的最后一个节点，而应该是链表中的一个实际节点。
我们将构建链表，并将节点传递给你的函数。
输出将是调用你函数后的整个链表。
</code></pre> 
<p>示例 1：</p> 
<pre><code>输入：head = [4,5,1,9], node = 5
输出：[4,1,9]
</code></pre> 
<p>解释：指定链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9</p> 
<p>示例 2：</p> 
<pre><code>输入：head = [4,5,1,9], node = 1
输出：[4,5,9]
</code></pre> 
<p>解释：指定链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9</p> 
<p>提示：</p> 
<pre><code>链表中节点的数目范围是 [2, 1000]
-1000 &lt;= Node.val &lt;= 1000
链表中每个节点的值都是 唯一 的
需要删除的节点 node 是 链表中的节点 ，且 不是末尾节点
</code></pre> 
<p>来源：力扣（LeetCode）<br> 链接：https://leetcode.cn/problems/delete-node-in-a-linked-list<br> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p> 
<pre><code class="prism language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">deleteNode</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token triple-quoted-string string">"""
        :type node: ListNode
        :rtype: void Do not return anything, modify node in-place instead.
        """</span>
        node<span class="token punctuation">.</span>val <span class="token operator">=</span> node<span class="token punctuation">.</span><span class="token builtin">next</span><span class="token punctuation">.</span>val
        node<span class="token punctuation">.</span><span class="token builtin">next</span> <span class="token operator">=</span> node<span class="token punctuation">.</span><span class="token builtin">next</span><span class="token punctuation">.</span><span class="token builtin">next</span>
</code></pre> 
<h3><a id="Leetcode19__N__774"></a>Leetcode19. 删除链表的倒数第 N 个结点</h3> 
<p>给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。</p> 
<p>示例 1：</p> 
<pre><code>输入：head = [1,2,3,4,5], n = 2
输出：[1,2,3,5]
</code></pre> 
<p>示例 2：</p> 
<pre><code>输入：head = [1], n = 1
输出：[]
</code></pre> 
<p>示例 3：</p> 
<pre><code>输入：head = [1,2], n = 1
输出：[1]
</code></pre> 
<p>提示：</p> 
<pre><code>链表中结点的数目为 sz
1 &lt;= sz &lt;= 30
0 &lt;= Node.val &lt;= 100
1 &lt;= n &lt;= sz
</code></pre> 
<p>来源：力扣（LeetCode）<br> 链接：https://leetcode.cn/problems/remove-nth-node-from-end-of-list<br> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。<br> 思路与算法</p> 
<p>一种容易想到的方法是，我们首先从头节点开始对链表进行一次遍历，得到链表的长度 LL。随后我们再从头节点开始对链表进行一次遍历，当遍历到第 L−n+1L−n+1 个节点时，它就是我们需要删除的节点。</p> 
<pre><code>为了与题目中的 nn 保持一致，节点的编号从 11 开始，头节点为编号 11 的节点。
</code></pre> 
<p>为了方便删除操作，我们可以从哑节点开始遍历 L−n+1L−n+1 个节点。当遍历到第 L−n+1L−n+1 个节点时，它的下一个节点就是我们需要删除的节点，这样我们只需要修改一次指针，就能完成删除操作。</p> 
<pre><code class="prism language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">removeNthFromEnd</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> ListNode<span class="token punctuation">,</span> n<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> ListNode<span class="token punctuation">:</span>
        <span class="token keyword">def</span> <span class="token function">getLength</span><span class="token punctuation">(</span>head<span class="token punctuation">:</span> ListNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">int</span><span class="token punctuation">:</span>
            length <span class="token operator">=</span> <span class="token number">0</span>
            <span class="token keyword">while</span> head<span class="token punctuation">:</span>
                length <span class="token operator">+=</span> <span class="token number">1</span>
                head <span class="token operator">=</span> head<span class="token punctuation">.</span><span class="token builtin">next</span>
            <span class="token keyword">return</span> length
        
        dummy <span class="token operator">=</span> ListNode<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> head<span class="token punctuation">)</span>
        length <span class="token operator">=</span> getLength<span class="token punctuation">(</span>head<span class="token punctuation">)</span>
        cur <span class="token operator">=</span> dummy
        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> length <span class="token operator">-</span> n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            cur <span class="token operator">=</span> cur<span class="token punctuation">.</span><span class="token builtin">next</span>
        cur<span class="token punctuation">.</span><span class="token builtin">next</span> <span class="token operator">=</span> cur<span class="token punctuation">.</span><span class="token builtin">next</span><span class="token punctuation">.</span><span class="token builtin">next</span>
        <span class="token keyword">return</span> dummy<span class="token punctuation">.</span><span class="token builtin">next</span>
</code></pre> 
<p>双指针</p> 
<p>思路与算法</p> 
<p>我们也可以在不预处理出链表的长度，以及使用常数空间的前提下解决本题。</p> 
<p>由于我们需要找到倒数第 nn 个节点，因此我们可以使用两个指针 firstfirst 和 secondsecond 同时对链表进行遍历，并且 firstfirst 比 secondsecond 超前 nn 个节点。当 firstfirst 遍历到链表的末尾时，secondsecond 就恰好处于倒数第 nn 个节点。</p> 
<p>具体地，初始时 firstfirst 和 secondsecond 均指向头节点。我们首先使用 firstfirst 对链表进行遍历，遍历的次数为 nn。此时，firstfirst 和 secondsecond 之间间隔了 n−1n−1 个节点，即 firstfirst 比 secondsecond 超前了 nn 个节点。</p> 
<p>在这之后，我们同时使用 firstfirst 和 secondsecond 对链表进行遍历。当 firstfirst 遍历到链表的末尾（即 firstfirst 为空指针）时，secondsecond 恰好指向倒数第 nn 个节点。</p> 
<p>根据方法一和方法二，如果我们能够得到的是倒数第 nn 个节点的前驱节点而不是倒数第 nn 个节点的话，删除操作会更加方便。因此我们可以考虑在初始时将 secondsecond 指向哑节点，其余的操作步骤不变。这样一来，当 firstfirst 遍历到链表的末尾时，secondsecond 的下一个节点就是我们需要删除的节点。</p> 
<pre><code class="prism language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">removeNthFromEnd</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> ListNode<span class="token punctuation">,</span> n<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> ListNode<span class="token punctuation">:</span>
        dummy <span class="token operator">=</span> ListNode<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> head<span class="token punctuation">)</span>
        first <span class="token operator">=</span> head
        second <span class="token operator">=</span> dummy
        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>
            first <span class="token operator">=</span> first<span class="token punctuation">.</span><span class="token builtin">next</span>

        <span class="token keyword">while</span> first<span class="token punctuation">:</span>
            first <span class="token operator">=</span> first<span class="token punctuation">.</span><span class="token builtin">next</span>
            second <span class="token operator">=</span> second<span class="token punctuation">.</span><span class="token builtin">next</span>
        
        second<span class="token punctuation">.</span><span class="token builtin">next</span> <span class="token operator">=</span> second<span class="token punctuation">.</span><span class="token builtin">next</span><span class="token punctuation">.</span><span class="token builtin">next</span>
        <span class="token keyword">return</span> dummy<span class="token punctuation">.</span><span class="token builtin">next</span>
</code></pre> 
<h3><a id="Leetcode61__864"></a>Leetcode61. 旋转链表</h3> 
<p>给你一个链表的头节点 head ，旋转链表，将链表每个节点向右移动 k 个位置。</p> 
<p>示例 1：</p> 
<pre><code>输入：head = [1,2,3,4,5], k = 2
输出：[4,5,1,2,3]
</code></pre> 
<p>示例 2：</p> 
<pre><code>输入：head = [0,1,2], k = 4
输出：[2,0,1]
</code></pre> 
<p>提示：</p> 
<pre><code>链表中节点的数目在范围 [0, 500] 内
-100 &lt;= Node.val &lt;= 100
0 &lt;= k &lt;= 2 * 109
</code></pre> 
<p>来源：力扣（LeetCode）<br> 链接：https://leetcode.cn/problems/rotate-list<br> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p> 
<p>思路及算法</p> 
<p>记给定链表的长度为 nn，注意到当向右移动的次数 k≥nk≥n 时，我们仅需要向右移动 k mod nkmodn 次即可。因为每 nn 次移动都会让链表变为原状。这样我们可以知道，新链表的最后一个节点为原链表的第 (n−1)−(k mod n)(n−1)−(kmodn) 个节点（从 00 开始计数）。</p> 
<p>这样，我们可以先将给定的链表连接成环，然后将指定位置断开。</p> 
<p>具体代码中，我们首先计算出链表的长度 nn，并找到该链表的末尾节点，将其与头节点相连。这样就得到了闭合为环的链表。然后我们找到新链表的最后一个节点（即原链表的第 (n−1)−(k mod n)(n−1)−(kmodn) 个节点），将当前闭合为环的链表断开，即可得到我们所需要的结果。</p> 
<p>特别地，当链表长度不大于 11，或者 kk 为 nn 的倍数时，新链表将与原链表相同，我们无需进行任何处理。</p> 
<p><img src="https://images2.imgbox.com/9d/aa/VMDs81ID_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">rotateRight</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> ListNode<span class="token punctuation">,</span> k<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> ListNode<span class="token punctuation">:</span>
        <span class="token keyword">if</span> k <span class="token operator">==</span> <span class="token number">0</span> <span class="token keyword">or</span> <span class="token keyword">not</span> head <span class="token keyword">or</span> <span class="token keyword">not</span> head<span class="token punctuation">.</span><span class="token builtin">next</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> head
        
        n <span class="token operator">=</span> <span class="token number">1</span>
        cur <span class="token operator">=</span> head
        <span class="token keyword">while</span> cur<span class="token punctuation">.</span><span class="token builtin">next</span><span class="token punctuation">:</span>
            cur <span class="token operator">=</span> cur<span class="token punctuation">.</span><span class="token builtin">next</span>
            n <span class="token operator">+=</span> <span class="token number">1</span>
        
        <span class="token keyword">if</span> <span class="token punctuation">(</span>add <span class="token operator">:=</span> n <span class="token operator">-</span> k <span class="token operator">%</span> n<span class="token punctuation">)</span> <span class="token operator">==</span> n<span class="token punctuation">:</span>
            <span class="token keyword">return</span> head
        
        cur<span class="token punctuation">.</span><span class="token builtin">next</span> <span class="token operator">=</span> head
        <span class="token keyword">while</span> add<span class="token punctuation">:</span>
            cur <span class="token operator">=</span> cur<span class="token punctuation">.</span><span class="token builtin">next</span>
            add <span class="token operator">-=</span> <span class="token number">1</span>
        
        ret <span class="token operator">=</span> cur<span class="token punctuation">.</span><span class="token builtin">next</span>
        cur<span class="token punctuation">.</span><span class="token builtin">next</span> <span class="token operator">=</span> <span class="token boolean">None</span>
        <span class="token keyword">return</span> ret
</code></pre> 
<h3><a id="Leetcode234__930"></a>Leetcode234. 回文链表</h3> 
<p>给你一个单链表的头节点 head ，请你判断该链表是否为回文链表。如果是，返回 true ；否则，返回 false 。</p> 
<p>示例 1：</p> 
<pre><code>输入：head = [1,2,2,1]
输出：true
</code></pre> 
<p>示例 2：</p> 
<pre><code>输入：head = [1,2]
输出：false
</code></pre> 
<p>提示：</p> 
<pre><code>链表中节点数目在范围[1, 105] 内
0 &lt;= Node.val &lt;= 9
</code></pre> 
<p>来源：力扣（LeetCode）<br> 链接：https://leetcode.cn/problems/palindrome-linked-list<br> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p> 
<p>思路</p> 
<p>如果你还不太熟悉链表，下面有关于列表的概要讲述。</p> 
<p>有两种常用的列表实现，分别为数组列表和链表。如果我们想在列表中存储值，它们是如何实现的呢？</p> 
<pre><code>数组列表底层是使用数组存储值，我们可以通过索引在 O(1)O(1) 的时间访问列表任何位置的值，这是由基于内存寻址的方式。
链表存储的是称为节点的对象，每个节点保存一个值和指向下一个节点的指针。访问某个特定索引的节点需要 O(n)O(n) 的时间，因为要通过指针获取到下一个位置的节点。
</code></pre> 
<p>确定数组列表是否回文很简单，我们可以使用双指针法来比较两端的元素，并向中间移动。一个指针从起点向中间移动，另一个指针从终点向中间移动。这需要 O(n)O(n) 的时间，因为访问每个元素的时间是 O(1)O(1)，而有 nn 个元素要访问。</p> 
<p>然而同样的方法在链表上操作并不简单，因为不论是正向访问还是反向访问都不是 O(1)O(1)。而将链表的值复制到数组列表中是 O(n)O(n)，因此最简单的方法就是将链表的值复制到数组列表中，再使用双指针法判断。</p> 
<p>算法</p> 
<p>一共为两个步骤：</p> 
<pre><code>复制链表值到数组列表中。
使用双指针法判断是否为回文。
</code></pre> 
<p>第一步，我们需要遍历链表将值复制到数组列表中。我们用 currentNode 指向当前节点。每次迭代向数组添加 currentNode.val，并更新 currentNode = currentNode.next，当 currentNode = null 时停止循环。</p> 
<p>执行第二步的最佳方法取决于你使用的语言。在 Python 中，很容易构造一个列表的反向副本，也很容易比较两个列表。而在其他语言中，就没有那么简单。因此最好使用双指针法来检查是否为回文。我们在起点放置一个指针，在结尾放置一个指针，每一次迭代判断两个指针指向的元素是否相同，若不同，返回 false；相同则将两个指针向内移动，并继续判断，直到两个指针相遇。</p> 
<p>在编码的过程中，注意我们比较的是节点值的大小，而不是节点本身。正确的比较方式是：node_1.val == node_2.val，而 node_1 == node_2 是错误的。</p> 
<pre><code class="prism language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">isPalindrome</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> ListNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">bool</span><span class="token punctuation">:</span>
        vals <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        current_node <span class="token operator">=</span> head
        <span class="token keyword">while</span> current_node <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
            vals<span class="token punctuation">.</span>append<span class="token punctuation">(</span>current_node<span class="token punctuation">.</span>val<span class="token punctuation">)</span>
            current_node <span class="token operator">=</span> current_node<span class="token punctuation">.</span><span class="token builtin">next</span>
        <span class="token keyword">return</span> vals <span class="token operator">==</span> vals<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>

</code></pre> 
<h3><a id="Leetcode445__II_994"></a>Leetcode445. 两数相加 II</h3> 
<p>给你两个 非空 链表来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。</p> 
<p>你可以假设除了数字 0 之外，这两个数字都不会以零开头。</p> 
<p>示例1：</p> 
<p>输入：l1 = [7,2,4,3], l2 = [5,6,4]<br> 输出：[7,8,0,7]</p> 
<p>示例2：</p> 
<pre><code>输入：l1 = [2,4,3], l2 = [5,6,4]
输出：[8,0,7]
</code></pre> 
<p>示例3：</p> 
<pre><code>输入：l1 = [0], l2 = [0]
输出：[0]
</code></pre> 
<p>提示：</p> 
<pre><code>链表的长度范围为 [1, 100]
0 &lt;= node.val &lt;= 9
输入数据保证链表代表的数字无前导 0
</code></pre> 
<p>来源：力扣（LeetCode）<br> 链接：https://leetcode.cn/problems/add-two-numbers-ii<br> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。<br> 思路与算法</p> 
<p>本题的主要难点在于链表中数位的顺序与我们做加法的顺序是相反的，为了逆序处理所有数位，我们可以使用栈：把所有数字压入栈中，再依次取出相加。计算过程中需要注意进位的情况。</p> 
<pre><code class="prism language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">addTwoNumbers</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> l1<span class="token punctuation">:</span> ListNode<span class="token punctuation">,</span> l2<span class="token punctuation">:</span> ListNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> ListNode<span class="token punctuation">:</span>
        s1<span class="token punctuation">,</span> s2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        <span class="token keyword">while</span> l1<span class="token punctuation">:</span>
            s1<span class="token punctuation">.</span>append<span class="token punctuation">(</span>l1<span class="token punctuation">.</span>val<span class="token punctuation">)</span>
            l1 <span class="token operator">=</span> l1<span class="token punctuation">.</span><span class="token builtin">next</span>
        <span class="token keyword">while</span> l2<span class="token punctuation">:</span>
            s2<span class="token punctuation">.</span>append<span class="token punctuation">(</span>l2<span class="token punctuation">.</span>val<span class="token punctuation">)</span>
            l2 <span class="token operator">=</span> l2<span class="token punctuation">.</span><span class="token builtin">next</span>
        ans <span class="token operator">=</span> <span class="token boolean">None</span>
        carry <span class="token operator">=</span> <span class="token number">0</span>
        <span class="token keyword">while</span> s1 <span class="token keyword">or</span> s2 <span class="token keyword">or</span> carry <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">:</span>
            a <span class="token operator">=</span> <span class="token number">0</span> <span class="token keyword">if</span> <span class="token keyword">not</span> s1 <span class="token keyword">else</span> s1<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>
            b <span class="token operator">=</span> <span class="token number">0</span> <span class="token keyword">if</span> <span class="token keyword">not</span> s2 <span class="token keyword">else</span> s2<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>
            cur <span class="token operator">=</span> a <span class="token operator">+</span> b <span class="token operator">+</span> carry
            carry <span class="token operator">=</span> cur <span class="token operator">//</span> <span class="token number">10</span>
            cur <span class="token operator">%=</span> <span class="token number">10</span>
            curnode <span class="token operator">=</span> ListNode<span class="token punctuation">(</span>cur<span class="token punctuation">)</span>
            curnode<span class="token punctuation">.</span><span class="token builtin">next</span> <span class="token operator">=</span> ans
            ans <span class="token operator">=</span> curnode
        <span class="token keyword">return</span> ans
</code></pre> 
<h3><a id="Leetcode23__K__1056"></a>Leetcode23. 合并 K 个升序链表</h3> 
<p>给你一个链表数组，每个链表都已经按升序排列。</p> 
<p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p> 
<p>示例 1：</p> 
<pre><code>输入：lists = [[1,4,5],[1,3,4],[2,6]]
输出：[1,1,2,3,4,4,5,6]
解释：链表数组如下：
[
  1-&gt;4-&gt;5,
  1-&gt;3-&gt;4,
  2-&gt;6
]
将它们合并到一个有序链表中得到。
1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6
</code></pre> 
<p>示例 2：</p> 
<pre><code>输入：lists = []
输出：[]
</code></pre> 
<p>示例 3：</p> 
<pre><code>输入：lists = [[]]
输出：[]
</code></pre> 
<p>提示：</p> 
<pre><code>k == lists.length
0 &lt;= k &lt;= 10^4
0 &lt;= lists[i].length &lt;= 500
-10^4 &lt;= lists[i][j] &lt;= 10^4
lists[i] 按 升序 排列
lists[i].length 的总和不超过 10^4
</code></pre> 
<p>来源：力扣（LeetCode）<br> 链接：https://leetcode.cn/problems/merge-k-sorted-lists<br> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。<br> 在介绍k个有序链表的合并前需要简单介绍下两个链表的有序合并（leetcode21）方法。如果不考虑时间复杂性与空间复杂性实现的方法比较简单，这里要求时间复性为O(n)O(n)，空间复杂性为O(1)O(1)。以示例中的前两个链表为例来说明相关过程。<br> 首先，需要定义一个head链表头来作为最终结果链表的表头。</p> 
<p><img src="https://images2.imgbox.com/5e/42/ReLNzjhp_o.png" alt="image.png"></p> 
<p>对比两个链表的当前节点的值，取小的作为head的next。先选择当前的l1加入到head链表中，然后l1跳到下一个节点。<br> <img src="https://images2.imgbox.com/0c/24/lctaxXlB_o.png" alt="image.png"></p> 
<p>再比较当前的L1与l2值的大小。<br> <img src="https://images2.imgbox.com/cd/4c/NT44oZg3_o.png" alt="image.png"></p> 
<p>重复整个过程真到最后：<br> <img src="https://images2.imgbox.com/f2/10/j7fqDFLa_o.png" alt="image.png"></p> 
<pre><code class="prism language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token comment">#合并两个链表leetcode 21</span>
    <span class="token keyword">def</span> <span class="token function">merge2Lists</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>list1<span class="token punctuation">,</span>list2<span class="token punctuation">)</span><span class="token punctuation">:</span>
        head<span class="token operator">=</span>ListNode<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
        curr_list<span class="token operator">=</span>head
        <span class="token keyword">while</span> list1 <span class="token keyword">and</span> list2<span class="token punctuation">:</span>
            <span class="token keyword">if</span> list1<span class="token punctuation">.</span>val<span class="token operator">&lt;</span>list2<span class="token punctuation">.</span>val<span class="token punctuation">:</span>
                curr_list<span class="token punctuation">.</span><span class="token builtin">next</span><span class="token operator">=</span>list1
                list1<span class="token operator">=</span>list1<span class="token punctuation">.</span><span class="token builtin">next</span>
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                curr_list<span class="token punctuation">.</span><span class="token builtin">next</span><span class="token operator">=</span>list2
                list2<span class="token operator">=</span>list2<span class="token punctuation">.</span><span class="token builtin">next</span>
            curr_list<span class="token operator">=</span>curr_list<span class="token punctuation">.</span><span class="token builtin">next</span>
        <span class="token keyword">if</span> list1<span class="token punctuation">:</span>
            curr_list<span class="token punctuation">.</span><span class="token builtin">next</span><span class="token operator">=</span>list1
        <span class="token keyword">if</span> list2<span class="token punctuation">:</span>
            curr_list<span class="token punctuation">.</span><span class="token builtin">next</span><span class="token operator">=</span>list2
        <span class="token keyword">return</span> head<span class="token punctuation">.</span><span class="token builtin">next</span>
</code></pre> 
<h3><a id="Leetcode148__1140"></a>Leetcode148. 排序链表</h3> 
<p>给你链表的头结点 head ，请将其按 升序 排列并返回 排序后的链表 。</p> 
<p>示例 1：<br> <img src="https://images2.imgbox.com/7e/7e/XajcIHLp_o.png" alt="在这里插入图片描述"></p> 
<pre><code>输入：head = [4,2,1,3]
输出：[1,2,3,4]
</code></pre> 
<p>示例 2：<br> <img src="https://images2.imgbox.com/d7/92/IgIIFnCF_o.png" alt="在这里插入图片描述"></p> 
<pre><code>输入：head = [-1,5,3,4,0]
输出：[-1,0,3,4,5]
</code></pre> 
<p>示例 3：</p> 
<pre><code>输入：head = []
输出：[]
</code></pre> 
<p>来源：力扣（LeetCode）<br> 链接：https://leetcode.cn/problems/sort-list<br> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。<br> 归并排序（递归法）</p> 
<pre><code>题目要求时间空间复杂度分别为 O(nlogn)O(nlogn) 和 O(1)O(1)，根据时间复杂度我们自然想到二分法，从而联想到归并排序；

对数组做归并排序的空间复杂度为 O(n)O(n)，分别由新开辟数组 O(n)O(n) 和递归函数调用 O(logn)O(logn) 组成，而根据链表特性：
    数组额外空间：链表可以通过修改引用来更改节点顺序，无需像数组一样开辟额外空间；
    递归额外空间：递归调用函数将带来 O(logn)O(logn) 的空间复杂度，因此若希望达到 O(1)O(1) 空间复杂度，则不能使用递归。

通过递归实现链表归并排序，有以下两个环节：
    分割 cut 环节： 找到当前链表 中点，并从 中点 将链表断开（以便在下次递归 cut 时，链表片段拥有正确边界）；
        我们使用 fast,slow 快慢双指针法，奇数个节点找到中点，偶数个节点找到中心左边的节点。
        找到中点 slow 后，执行 slow.next = None 将链表切断。
        递归分割时，输入当前链表左端点 head 和中心节点 slow 的下一个节点 tmp(因为链表是从 slow 切断的)。
        cut 递归终止条件： 当 head.next == None 时，说明只有一个节点了，直接返回此节点。
    合并 merge 环节： 将两个排序链表合并，转化为一个排序链表。
        双指针法合并，建立辅助 ListNode h 作为头部。
        设置两指针 left, right 分别指向两链表头部，比较两指针处节点值大小，由小到大加入合并链表头部，指针交替前进，直至添加完两个链表。
        返回辅助ListNode h 作为头部的下个节点 h.next。
        时间复杂度 O(l + r)，l, r 分别代表两个链表长度。
    当题目输入的 head == None 时，直接返回 None。
</code></pre> 
<p><img src="https://images2.imgbox.com/fa/12/I7uRXWlO_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">sortList</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> ListNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> ListNode<span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> head <span class="token keyword">or</span> <span class="token keyword">not</span> head<span class="token punctuation">.</span><span class="token builtin">next</span><span class="token punctuation">:</span> <span class="token keyword">return</span> head <span class="token comment"># termination.</span>
        <span class="token comment"># cut the LinkedList at the mid index.</span>
        slow<span class="token punctuation">,</span> fast <span class="token operator">=</span> head<span class="token punctuation">,</span> head<span class="token punctuation">.</span><span class="token builtin">next</span>
        <span class="token keyword">while</span> fast <span class="token keyword">and</span> fast<span class="token punctuation">.</span><span class="token builtin">next</span><span class="token punctuation">:</span>
            fast<span class="token punctuation">,</span> slow <span class="token operator">=</span> fast<span class="token punctuation">.</span><span class="token builtin">next</span><span class="token punctuation">.</span><span class="token builtin">next</span><span class="token punctuation">,</span> slow<span class="token punctuation">.</span><span class="token builtin">next</span>
        mid<span class="token punctuation">,</span> slow<span class="token punctuation">.</span><span class="token builtin">next</span> <span class="token operator">=</span> slow<span class="token punctuation">.</span><span class="token builtin">next</span><span class="token punctuation">,</span> <span class="token boolean">None</span> <span class="token comment"># save and cut.</span>
        <span class="token comment"># recursive for cutting.</span>
        left<span class="token punctuation">,</span> right <span class="token operator">=</span> self<span class="token punctuation">.</span>sortList<span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>sortList<span class="token punctuation">(</span>mid<span class="token punctuation">)</span>
        <span class="token comment"># merge `left` and `right` linked list and return it.</span>
        h <span class="token operator">=</span> res <span class="token operator">=</span> ListNode<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token keyword">while</span> left <span class="token keyword">and</span> right<span class="token punctuation">:</span>
            <span class="token keyword">if</span> left<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> right<span class="token punctuation">.</span>val<span class="token punctuation">:</span> h<span class="token punctuation">.</span><span class="token builtin">next</span><span class="token punctuation">,</span> left <span class="token operator">=</span> left<span class="token punctuation">,</span> left<span class="token punctuation">.</span><span class="token builtin">next</span>
            <span class="token keyword">else</span><span class="token punctuation">:</span> h<span class="token punctuation">.</span><span class="token builtin">next</span><span class="token punctuation">,</span> right <span class="token operator">=</span> right<span class="token punctuation">,</span> right<span class="token punctuation">.</span><span class="token builtin">next</span>
            h <span class="token operator">=</span> h<span class="token punctuation">.</span><span class="token builtin">next</span>
        h<span class="token punctuation">.</span><span class="token builtin">next</span> <span class="token operator">=</span> left <span class="token keyword">if</span> left <span class="token keyword">else</span> right
        <span class="token keyword">return</span> res<span class="token punctuation">.</span><span class="token builtin">next</span>



</code></pre> 
<h3><a id="Leetcode146_LRU__1213"></a>Leetcode146. LRU 缓存</h3> 
<p>请你设计并实现一个满足 LRU (最近最少使用) 缓存 约束的数据结构。<br> 实现 LRUCache 类：</p> 
<pre><code>LRUCache(int capacity) 以 正整数 作为容量 capacity 初始化 LRU 缓存
int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。
void put(int key, int value) 如果关键字 key 已经存在，则变更其数据值 value ；如果不存在，则向缓存中插入该组 key-value 。如果插入操作导致关键字数量超过 capacity ，则应该 逐出 最久未使用的关键字。
</code></pre> 
<p>函数 get 和 put 必须以 O(1) 的平均时间复杂度运行。</p> 
<p>示例：</p> 
<pre><code>输入
["LRUCache", "put", "put", "get", "put", "get", "put", "get", "get", "get"]
[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]
输出
[null, null, null, 1, null, -1, null, -1, 3, 4]
</code></pre> 
<p>解释</p> 
<pre><code>LRUCache lRUCache = new LRUCache(2);
lRUCache.put(1, 1); // 缓存是 {1=1}
lRUCache.put(2, 2); // 缓存是 {1=1, 2=2}
lRUCache.get(1);    // 返回 1
lRUCache.put(3, 3); // 该操作会使得关键字 2 作废，缓存是 {1=1, 3=3}
lRUCache.get(2);    // 返回 -1 (未找到)
lRUCache.put(4, 4); // 该操作会使得关键字 1 作废，缓存是 {4=4, 3=3}
lRUCache.get(1);    // 返回 -1 (未找到)
lRUCache.get(3);    // 返回 3
lRUCache.get(4);    // 返回 4
</code></pre> 
<p>来源：力扣（LeetCode）<br> 链接：https://leetcode.cn/problems/lru-cache<br> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。<br> 哈希表 + 双向链表</p> 
<p>算法</p> 
<p>LRU 缓存机制可以通过哈希表辅以双向链表实现，我们用一个哈希表和一个双向链表维护所有在缓存中的键值对。</p> 
<pre><code>双向链表按照被使用的顺序存储了这些键值对，靠近头部的键值对是最近使用的，而靠近尾部的键值对是最久未使用的。

哈希表即为普通的哈希映射（HashMap），通过缓存数据的键映射到其在双向链表中的位置。
</code></pre> 
<p>这样以来，我们首先使用哈希表进行定位，找出缓存项在双向链表中的位置，随后将其移动到双向链表的头部，即可在 O(1)O(1) 的时间内完成 get 或者 put 操作。具体的方法如下：</p> 
<pre><code>对于 get 操作，首先判断 key 是否存在：

    如果 key 不存在，则返回 −1−1；

    如果 key 存在，则 key 对应的节点是最近被使用的节点。通过哈希表定位到该节点在双向链表中的位置，并将其移动到双向链表的头部，最后返回该节点的值。

对于 put 操作，首先判断 key 是否存在：

    如果 key 不存在，使用 key 和 value 创建一个新的节点，在双向链表的头部添加该节点，并将 key 和该节点添加进哈希表中。然后判断双向链表的节点数是否超出容量，如果超出容量，则删除双向链表的尾部节点，并删除哈希表中对应的项；

    如果 key 存在，则与 get 操作类似，先通过哈希表定位，再将对应的节点的值更新为 value，并将该节点移到双向链表的头部。
</code></pre> 
<p>上述各项操作中，访问哈希表的时间复杂度为 O(1)O(1)，在双向链表的头部添加节点、在双向链表的尾部删除节点的复杂度也为 O(1)O(1)。而将一个节点移到双向链表的头部，可以分成「删除该节点」和「在双向链表的头部添加节点」两步操作，都可以在 O(1)O(1) 时间内完成。</p> 
<p>小贴士</p> 
<p>在双向链表的实现中，使用一个伪头部（dummy head）和伪尾部（dummy tail）标记界限，这样在添加节点和删除节点的时候就不需要检查相邻的节点是否存在。</p> 
<p><img src="https://images2.imgbox.com/90/8a/COEiq7Sz_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-python"><span class="token keyword">class</span> <span class="token class-name">DLinkedNode</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> key<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> value<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>key <span class="token operator">=</span> key
        self<span class="token punctuation">.</span>value <span class="token operator">=</span> value
        self<span class="token punctuation">.</span>prev <span class="token operator">=</span> <span class="token boolean">None</span>
        self<span class="token punctuation">.</span><span class="token builtin">next</span> <span class="token operator">=</span> <span class="token boolean">None</span>


<span class="token keyword">class</span> <span class="token class-name">LRUCache</span><span class="token punctuation">:</span>

    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> capacity<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>cache <span class="token operator">=</span> <span class="token builtin">dict</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token comment"># 使用伪头部和伪尾部节点    </span>
        self<span class="token punctuation">.</span>head <span class="token operator">=</span> DLinkedNode<span class="token punctuation">(</span><span class="token punctuation">)</span>
        self<span class="token punctuation">.</span>tail <span class="token operator">=</span> DLinkedNode<span class="token punctuation">(</span><span class="token punctuation">)</span>
        self<span class="token punctuation">.</span>head<span class="token punctuation">.</span><span class="token builtin">next</span> <span class="token operator">=</span> self<span class="token punctuation">.</span>tail
        self<span class="token punctuation">.</span>tail<span class="token punctuation">.</span>prev <span class="token operator">=</span> self<span class="token punctuation">.</span>head
        self<span class="token punctuation">.</span>capacity <span class="token operator">=</span> capacity
        self<span class="token punctuation">.</span>size <span class="token operator">=</span> <span class="token number">0</span>

    <span class="token keyword">def</span> <span class="token function">get</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> key<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">int</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> key <span class="token keyword">not</span> <span class="token keyword">in</span> self<span class="token punctuation">.</span>cache<span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>
        <span class="token comment"># 如果 key 存在，先通过哈希表定位，再移到头部</span>
        node <span class="token operator">=</span> self<span class="token punctuation">.</span>cache<span class="token punctuation">[</span>key<span class="token punctuation">]</span>
        self<span class="token punctuation">.</span>moveToHead<span class="token punctuation">(</span>node<span class="token punctuation">)</span>
        <span class="token keyword">return</span> node<span class="token punctuation">.</span>value

    <span class="token keyword">def</span> <span class="token function">put</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> key<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">,</span> value<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> key <span class="token keyword">not</span> <span class="token keyword">in</span> self<span class="token punctuation">.</span>cache<span class="token punctuation">:</span>
            <span class="token comment"># 如果 key 不存在，创建一个新的节点</span>
            node <span class="token operator">=</span> DLinkedNode<span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span>
            <span class="token comment"># 添加进哈希表</span>
            self<span class="token punctuation">.</span>cache<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> node
            <span class="token comment"># 添加至双向链表的头部</span>
            self<span class="token punctuation">.</span>addToHead<span class="token punctuation">(</span>node<span class="token punctuation">)</span>
            self<span class="token punctuation">.</span>size <span class="token operator">+=</span> <span class="token number">1</span>
            <span class="token keyword">if</span> self<span class="token punctuation">.</span>size <span class="token operator">&gt;</span> self<span class="token punctuation">.</span>capacity<span class="token punctuation">:</span>
                <span class="token comment"># 如果超出容量，删除双向链表的尾部节点</span>
                removed <span class="token operator">=</span> self<span class="token punctuation">.</span>removeTail<span class="token punctuation">(</span><span class="token punctuation">)</span>
                <span class="token comment"># 删除哈希表中对应的项</span>
                self<span class="token punctuation">.</span>cache<span class="token punctuation">.</span>pop<span class="token punctuation">(</span>removed<span class="token punctuation">.</span>key<span class="token punctuation">)</span>
                self<span class="token punctuation">.</span>size <span class="token operator">-=</span> <span class="token number">1</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            <span class="token comment"># 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部</span>
            node <span class="token operator">=</span> self<span class="token punctuation">.</span>cache<span class="token punctuation">[</span>key<span class="token punctuation">]</span>
            node<span class="token punctuation">.</span>value <span class="token operator">=</span> value
            self<span class="token punctuation">.</span>moveToHead<span class="token punctuation">(</span>node<span class="token punctuation">)</span>
    
    <span class="token keyword">def</span> <span class="token function">addToHead</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">:</span>
        node<span class="token punctuation">.</span>prev <span class="token operator">=</span> self<span class="token punctuation">.</span>head
        node<span class="token punctuation">.</span><span class="token builtin">next</span> <span class="token operator">=</span> self<span class="token punctuation">.</span>head<span class="token punctuation">.</span><span class="token builtin">next</span>
        self<span class="token punctuation">.</span>head<span class="token punctuation">.</span><span class="token builtin">next</span><span class="token punctuation">.</span>prev <span class="token operator">=</span> node
        self<span class="token punctuation">.</span>head<span class="token punctuation">.</span><span class="token builtin">next</span> <span class="token operator">=</span> node
    
    <span class="token keyword">def</span> <span class="token function">removeNode</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">:</span>
        node<span class="token punctuation">.</span>prev<span class="token punctuation">.</span><span class="token builtin">next</span> <span class="token operator">=</span> node<span class="token punctuation">.</span><span class="token builtin">next</span>
        node<span class="token punctuation">.</span><span class="token builtin">next</span><span class="token punctuation">.</span>prev <span class="token operator">=</span> node<span class="token punctuation">.</span>prev

    <span class="token keyword">def</span> <span class="token function">moveToHead</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>removeNode<span class="token punctuation">(</span>node<span class="token punctuation">)</span>
        self<span class="token punctuation">.</span>addToHead<span class="token punctuation">(</span>node<span class="token punctuation">)</span>

    <span class="token keyword">def</span> <span class="token function">removeTail</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        node <span class="token operator">=</span> self<span class="token punctuation">.</span>tail<span class="token punctuation">.</span>prev
        self<span class="token punctuation">.</span>removeNode<span class="token punctuation">(</span>node<span class="token punctuation">)</span>
        <span class="token keyword">return</span> node


</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/17eb30177c05b175e1ad5980034b3313/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">知名开源技术大佬自曝：因找不到工作被迫送外卖，如今转行当出纳，一度穷到连瓶可乐都不舍得买！...</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/bb520d7c6a36741bf290c107e44850c4/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">记录关于PageHelper插件不生效的问题</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>