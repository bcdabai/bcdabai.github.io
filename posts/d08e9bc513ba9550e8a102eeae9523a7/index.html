<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>2019年3月份 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="2019年3月份" />
<meta property="og:description" content="3月12日
JDK包含了JRE。如果要运行JAVA程序，需要JRE，如果要编写JAVA程序，需要JDK。
==与equals的区别。对于基本数据类型来说，不能使用equals方法。==方法比较的是它们的值是否相等。对于引用数据类型来说，==比较的是内存地址是否相同。而equals比较的就是两个对象是否相等。如果没有重写hashcode与equals方法，那么会使用父类Object类的equals方法，比较的仍然是内存地址。如果重写了equals方法，那么比较的方法就按照重写后的equals方法。
hashcode相同。equals相同么？不对。比如在JDK1.7版本的HashMap。HashMap底层使用的是“数组&#43;链表”的数据结构。使用链地址法解决哈希冲突。链地址法的表现就在于相同的hash值的键值对组成一个链表，每一个键值对都有它后一个键值对的引用。这样一个一个挂上去，形成一个链表。
基本数据类型：byte short char int float double boolean long
String str=new String(&#34;i&#34;)创建了几个对象。先在方法区中的常量池创建了一个&#34;i&#34;字符串，然后再在堆内存中创建一个字符串对象。
new StringBuilder(&#34;abcdefgh&#34;).reverse().toString()；
说出String类型的常用方法。 subString，toUpperCase，toLowerCase，length()，jon()，indexOf
抽象类与接口的区别。一个类只能继承一个抽象类，但是可以实现多个接口。接口中的所有方法与变量都是public类型的，而抽象类不是。然后再扯一波多态，最后说一说一个方法上的参数是抽象类与接口的好处。体现了多态的扩展性与灵活性。
Collection是集合框架顶层容器，而Collections是集合框架的工具类。
Collections.emptyList()；（返回不可变的）。
Collections.sort()；根据自然排序规则排序
任何集合框架的描述，都离不开口诀：&#34;序重步&#34;。
3月13日
HashMap 和 Hashtable 有什么区别？
HashMap线程不安全。Hashtable线程安全。
HashMap允许key和value为null，而Hashtable不允许。
一般情况在多线程情况下，不使用Hashtable，取而代之的是ConcurrentHashMap。
说一下 HashMap 的实现原理
HashMap是Map接口的实现。通过put方法存放键值对。使用get方法获取键值对。
在put方法的源码中，首先计算出key的hash值。再通过相关的hash算法算出它在内部数组中的索引。然后查看这个索引上有没有其它值。如果有其它元素的话，说明这发生了hash冲突。在JDK1.7版本里面的处理办法是使用链地址法解决hash冲突。
首先把这组键值对封装成一个节点。节点对象维护了前一个节点的引用与后一个节点的引用。我们会把当前的这组键值对的内存地址告诉前一个节点。这样会在内存中形成一组相同hash值的链表。哈希表中的每个位置永远只保存一个最新加进来的键值对，其他键值对是一个挂一个，这样挂上去的。
影响HashMap的两个参数是“初始容量”和“加载因子&#34;。加载因子是是哈希表在扩容之前可以达到多满的一种尺度。如果加载因子设置过大，那么hash冲突的机会变大，每个链表的长度很长。内存利用率变大，但是长链表导致查询时间变长。加载因子过小，链表长度会变小，查询时间变少，但是内存的空间利用率会变小。
说一下 HashSet的实现原理
HashSet内部其实就是一个HashMap。如果说HashMap的元素是一组键值对，那么HashSet的元素就是键值对的键。 ArrayList 和 LinkedList 的区别是什么？ 一般我比较集合我会从集合是否有序，元素是否可以重复，是不是同步的集合。
ArrayList和LinkedList都是List接口的实现，都是有序的，可以重复的，不同步的。
主要区别在于内部的实现。ArrayList的内部使用的是数组的实现方式。而LinkedList使用的是链表的实现方式。
ArrayList是数组实现，所以查询速度很快，增删慢。
LinkedList是链表实现，查询慢，增删快。
因为他们都是java.util包下的，所以都是不同步的集合，具有快速失败的特性。
快速失败是指，在遍历集合的时候，修改集合将会导致异常的发生。
数组与集合切换
Arrays.asList(...T);
Collection.toArray(T[ ] array);
HashMap与TreeMap的区别
HashMap与TreeMap都是Map接口的实现，存放的是键值对。
HashMap使用的是hash表结构，所以无序。TreeMap使用的是二叉树结构，所以有序。
HashMap与TreeMap中元素都不能重复。
HashMap与TreeMap都是线程不安全的。他们在Java.util包下，所以具有快速失败的特性。
快速失败是指，在遍历集合的时候，修改集合将会导致异常的发生。
ArrayList与Vector的区别
都是有序的，可以重复的。ArrayList不同步，而Vector是同步的。
扩容方面：AraryList每次扩容50%，而Vector扩容一倍。
性能方面：ArrayList的性能由于Vector。
ArrayList与数组的区别" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/d08e9bc513ba9550e8a102eeae9523a7/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-03-12T09:35:51+08:00" />
<meta property="article:modified_time" content="2019-03-12T09:35:51+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">2019年3月份</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p> <strong>3月12日</strong></p> 
<p><strong>   </strong>     JDK包含了JRE。如果要运行JAVA程序，需要JRE，如果要编写JAVA程序，需要JDK。</p> 
<p>        ==与equals的区别。对于基本数据类型来说，不能使用equals方法。==方法比较的是它们的值是否相等。对于引用数据类型来说，==比较的是内存地址是否相同。而equals比较的就是两个对象是否相等。如果没有重写hashcode与equals方法，那么会使用父类Object类的equals方法，比较的仍然是内存地址。如果重写了equals方法，那么比较的方法就按照重写后的equals方法。</p> 
<p>         hashcode相同。equals相同么？不对。比如在JDK1.7版本的HashMap。HashMap底层使用的是“数组+链表”的数据结构。使用链地址法解决哈希冲突。链地址法的表现就在于<span style="color:#f33b45;">相同的hash值的键值对组成一个链表，每一个键值对都有它后一个键值对的引用。这样一个一个挂上去，形成一个链表。</span></p> 
<p>         基本数据类型：byte short char int float double boolean long</p> 
<p>         String str=new String("i")创建了几个对象。先在方法区中的常量池创建了一个"i"字符串，然后再在堆内存中创建一个字符串对象。</p> 
<p>         new StringBuilder("abcdefgh").reverse().toString()；</p> 
<p>         说出String类型的常用方法。  subString，toUpperCase，toLowerCase，length()，jon()，indexOf</p> 
<p>         抽象类与接口的区别。一个类只能继承一个抽象类，但是可以实现多个接口。接口中的所有方法与变量都是public类型的，而抽象类不是。然后再扯一波多态，最后说一说一个方法上的参数是抽象类与接口的好处。体现了多态的扩展性与灵活性。</p> 
<p>         Collection是集合框架顶层容器，而Collections是集合框架的工具类。</p> 
<p>         Collections.emptyList()；（返回不可变的）。</p> 
<p>         Collections.sort()；根据自然排序规则排序</p> 
<p>         任何集合框架的描述，都离不开口诀："序重步"。</p> 
<p><strong>3月13日</strong></p> 
<p><strong>        HashMap 和 Hashtable 有什么区别？</strong></p> 
<p>            HashMap线程不安全。Hashtable线程安全。</p> 
<p>            HashMap允许key和value为null，而Hashtable不允许。</p> 
<p>            一般情况在多线程情况下，不使用Hashtable，取而代之的是ConcurrentHashMap。</p> 
<p>       <strong>说一下 HashMap 的实现原理</strong></p> 
<p>             HashMap是Map接口的实现。通过put方法存放键值对。使用get方法获取键值对。</p> 
<p>             在put方法的源码中，首先计算出key的hash值。再通过相关的hash算法算出它在内部数组中的索引。然后查看这个索引上有没有其它值。如果有其它元素的话，说明这发生了hash冲突。在JDK1.7版本里面的处理办法是使用链地址法解决hash冲突。</p> 
<p>             首先把这组键值对封装成一个节点。节点对象维护了前一个节点的引用与后一个节点的引用。我们会把当前的这组键值对的内存地址告诉前一个节点。这样会在内存中形成一组相同hash值的链表。哈希表中的每个位置永远只保存一个最新加进来的键值对，其他键值对是一个挂一个，这样挂上去的。</p> 
<p>             影响HashMap的两个参数是“初始容量”和“加载因子"。加载因子是是哈希表在扩容之前可以达到多满的一种尺度。如果加载因子设置过大，那么hash冲突的机会变大，每个链表的长度很长。内存利用率变大，但是长链表导致查询时间变长。加载因子过小，链表长度会变小，查询时间变少，但是内存的空间利用率会变小。</p> 
<p>        <strong>说一下 HashSet的实现原理</strong></p> 
<p><strong>              </strong>HashSet内部其实就是一个HashMap。如果说HashMap的元素是一组键值对，那么HashSet的元素就是键值对的键。 </p> 
<p>        <strong>ArrayList 和 LinkedList 的区别是什么？       </strong></p> 
<p><strong>        </strong>       一般我比较集合我会从集合是否有序，元素是否可以重复，是不是同步的集合。</p> 
<p>                ArrayList和LinkedList都是List接口的实现，都是有序的，可以重复的，不同步的。</p> 
<p>                主要区别在于内部的实现。ArrayList的内部使用的是数组的实现方式。而LinkedList使用的是链表的实现方式。</p> 
<p>                ArrayList是数组实现，所以查询速度很快，增删慢。</p> 
<p>                LinkedList是链表实现，查询慢，增删快。</p> 
<p>                因为他们都是java.util包下的，所以都是不同步的集合，具有快速失败的特性。</p> 
<p>                快速失败是指，在遍历集合的时候，修改集合将会导致异常的发生。</p> 
<p><strong>          数组与集合切换</strong></p> 
<p>                  Arrays.asList(...T);</p> 
<p>                  Collection.toArray(T[ ] array);</p> 
<p><strong>           HashMap与TreeMap的区别</strong></p> 
<p>                   HashMap与TreeMap都是Map接口的实现，存放的是键值对。</p> 
<p>                   HashMap使用的是hash表结构，所以无序。TreeMap使用的是二叉树结构，所以有序。</p> 
<p>                   HashMap与TreeMap中元素都不能重复。</p> 
<p>                   HashMap与TreeMap都是线程不安全的。他们在Java.util包下，所以具有快速失败的特性。</p> 
<p>                   快速失败是指，在遍历集合的时候，修改集合将会导致异常的发生。</p> 
<p><strong>            ArrayList与Vector的区别</strong></p> 
<p>                    都是有序的，可以重复的。ArrayList不同步，而Vector是同步的。</p> 
<p>                    扩容方面：AraryList每次扩容50%，而Vector扩容一倍。</p> 
<p>                    性能方面：ArrayList的性能由于Vector。</p> 
<p><strong>             ArrayList与数组的区别</strong></p> 
<p>                     ArrayList可以扩容，但是数组不能扩容，数组长度是固定的。</p> 
<p>                     ArrayList只能存储对象，数组可以存储基本数据类型和对象。</p> 
<p><strong>             说说几个线程安全的集合</strong></p> 
<p>                    Vector  Hashtable Stack ConcurrentHashMap</p> 
<p><strong>3月14日</strong></p> 
<p><strong>              迭代器Iterator是什么？怎么用？特点呢？</strong></p> 
<p><strong>                     </strong> 迭代器Iterator用来遍历Collection集合的接口。 </p> 
<p>                      集合先通过iterator()方法获取到这个集合的迭代器实例，然后可以通过迭代器实例的next()方法获取集合的元素。 </p> 
<pre class="has"><code class="language-java">List&lt;String&gt; list = new ArrayList&lt;&gt;();
Iterator&lt;String&gt; it = list. iterator();
while(it. hasNext()){
  String obj = it. next();
  System. out. println(obj);
}</code></pre> 
<p>                      迭代器的特点是在遍历过程中，如果修改了集合的元素，那么就会抛出异常，这就是快速失败。</p> 
<p>             <strong>  Iterator 和 ListIterator 有什么区别？</strong></p> 
<p>                       Iterator接口可以用来遍历set和list集合。而ListIterator接口只能遍历List集合。</p> 
<p>                       Iterator接口只能单向遍历，而ListIterator可以双向遍历。</p> 
<p>                       Iterator接口不允许在遍历集合的时候修改元素，而ListIterator可以。</p> 
<pre class="has"><code class="language-java">              ListIterator&lt;String&gt; it = list.listIterator();
		while(it.hasNext()){
			String str = it.next();
			System.out.println(str);//abc
			if(str.equals("c")){
				it.add("d"); //如果写list.add(“d”),抛 java.util.ConcurrentModificationException
                         
			}
		}</code></pre> 
<p><strong>                    如何让一个集合不可修改</strong></p> 
<p>                           Collections.unmodifableCollection(Collection c)；返回的是一个只读集合，任何对此集合的修改都会抛出异常。</p> 
<p>                   <strong> 并行和并发有什么区别？</strong></p> 
<p>                             并行是指多个处理器同时处理多个任务。</p> 
<p>                             并发是指一个处理器处理多个任务，按照CPU时间片来轮流处理任务。</p> 
<p>                    <strong> 线程和进程的区别？</strong></p> 
<p><strong>                              </strong>进程：正在执行的程序。进程是OS分配资源的最小单位。<br>                               线程：正在执行的程序的子任务。线程是程序执行的最小单位。</p> 
<p>        <strong>              守护线程</strong></p> 
<p>                              守护线程是运行在后台的一种特殊进程，其作用就是对其它线程提供服务。</p> 
<p>                              特点是 如果程序中没有非守护线程了，那么守护线程就自动销毁了。</p> 
<p>                              典型的守护线程就是垃圾回收线程。守护线程的</p> 
<p><strong>                      创建线程的三种方式</strong></p> 
<p>                              继承Thread类</p> 
<p>                              实现Runnable接口</p> 
<p>                              实现Callable接口</p> 
<p><strong>                      Callable接口与Runnable接口的区别</strong><br>                              实现Callable接口的任务方法是call()方法，可以有返回值并且可以抛出异常。</p> 
<pre class="has"><code class="language-java">V call() throws Exception;</code></pre> 
<p>                             实现Runnable接口的任务是run()方法，不能有返回值并且不能抛出异常。</p> 
<pre class="has"><code class="language-java">    public abstract void run();</code></pre> 
<p>                         <strong>线程的状态</strong></p> 
<p><strong>               </strong>                开始结束两种，睡眠两种，运行两种</p> 
<p style="text-align:center;"><img alt="" class="has" height="369" src="https://images2.imgbox.com/e7/c2/raO6yoJy_o.png" width="547"></p> 
<p><strong>3月15日</strong> </p> 
<p>             <strong> sleep() 和 wait() 有什么区别？</strong></p> 
<p>                      sleep方法不释放同步锁，而wait()方法释放同步锁。</p> 
<p>                      sleep方法是睡眠一定的时间后，自动恢复。而wait()方法需要同步锁对象调用notify()或者notifyAll()方法。</p> 
<p>                       调用sleep方法后，线程的状态是TIMED_WATING ， 而调用wait()方法后，线程的状态是WAITING</p> 
<p>             <strong> notify()和 notifyAll()有什么区别？</strong></p> 
<p>                        notify()随机唤醒一个线程。而notifyAll()唤醒的所有线程。</p> 
<p>                        在多消费者生产者问题中。使用notifyAll为了避免出现连续唤醒同类，所导致假死的状况，保证能够唤醒异类。</p> 
<p>             <strong>  生产者消费者</strong></p> 
<p>                        伪代码：<br>                         生产者 if(有产品){lock.wait} 生产 lock.notify  如果有产品，我就休息。不然进行生产，并通知消费者消费。<br>                         消费者 if(没产品){lock.wait} 消费 lock.notify  如果没有产品，我就等待。不然的话就消费，消费完就通知生产。</p> 
<p><strong>               线程的 run() 和 start() 有什么区别？</strong></p> 
<p>                        run()方法只是线程对象的一个普通方法，线程对象调用run()方法，程序中并没有创建新线程，程序仍然顺序执行。</p> 
<p>                        start()方法创建了一个新线程，这个新线程与主线程并发执行。</p> 
<p><strong>               如何创建线程池</strong></p> 
<p>                         Excutors.newFixedThreadPool(int nThreads)；</p> 
<p>               <strong> 线程池中 submit() 和 execute() 方法有什么区别？</strong></p> 
<p>                         execute()方法执行的是实现了Runnable接口的任务，没有返回值。（PS:你执行就完事了）</p> 
<p>                         submit()执行的是Runnable接口和Callable接口的任务，并返回一个表示任务结果的的Future对象。调用Future对象的get方法，可以获取任务的返回结果。如果任务还没执行完毕，那么调用get()方法将会一直阻塞到任务结束。</p> 
<p><strong>                有过保证线程安全的经验么</strong><br>                          锁方面可以使用自动锁Synchronized，手动锁Lock锁。</p> 
<p>                         集合框架下面，可以使用concurrent包下面的集合。比如ConcurrentHashMap替换HashMap，如果是多线程的情况。  </p> 
<p>                         性能方面，如果是多线程的情况，需要使用StringBuffer替换掉StringBuilder。</p> 
<p><strong>                  锁升级的原理</strong></p> 
<p><strong>                         </strong> 锁的状态有4种，级别从低到高依次是： 无锁状态 、 偏向锁状态 、 轻量级锁状态 、 重量级锁状态</p> 
<p>                        （1）偏向锁：如果一个线程获得了锁，那么锁就会进入偏向模式。当这个线程再次请求锁的时候，无需在做任何同步操作。这样就节省了大量有关锁申请的操作，从而提高了程序的性能。</p> 
<p>                         （2）轻量级锁：如果锁被其它线程抢夺了，也就是偏向锁失败。轻量级锁的目标是允许多个线程获取锁，但是不能出竞争。</p> 
<p>                         （3）如果线程通过自旋手段也没有获取到同步锁，那么这把锁就会膨胀为重量级锁。</p> 
<p>                        偏向锁的优点：适合一个线程的多线程情况。</p> 
<p>                        轻量级锁：响应速度快。当然了，自旋也会消耗CPU。</p> 
<p>                        重量级锁：吞吐量大，能执行多个任务。因为不自旋了，所以不消耗CPU资源。</p> 
<p>            <strong>     什么是死锁？ </strong></p> 
<p><strong> </strong>                        两个线程，互相都需要对方的资源，但是都不释放已经获取到的资源，所以就产生了一种僵局。这种情况就会产生死锁。 </p> 
<p>            <strong>     如何排查死锁?</strong></p> 
<p><strong>               </strong>           使用JPS命令。</p> 
<p><strong>                 如何减少死锁？</strong></p> 
<p><strong>   </strong>                        如果项目是手动锁Lock锁的话，那么尽量使用tryLock方法，这样如果获取不到同步锁，那么会自动放弃这个方法。</p> 
<p>                          使用Concurrent包下的集合框架。</p> 
<p>                           尽量减少多个方法使用同一把锁。还有就是使用同步代码块替换掉同步方法。</p> 
<p>                 <strong>synchronized 和 Lock（ReentrantLock） 有什么区别？</strong></p> 
<p>                           synchronzied锁可以用于同步方法和同步代码块。而Lock锁只能用在同步代码块上。</p> 
<p>                           synchronized锁是自动锁，自动获取锁和释放锁。而Lock锁是手动锁，需要手动获取锁与释放锁。如果不使用lock.unlock()方法，那么即使出现异常，Lock锁也不会释放同步锁。</p> 
<p>                            Lock锁的tryLock方法，可以知道是不是已经获取到同步锁，而synchronized锁却办不到。</p> 
<p><strong>                  说一下 atomic 的原理(CAS)？</strong></p> 
<p>                            原子操作类的实现原理其实很简单，就是一个死循环。它的机制是比较交换CAS操作。</p> 
<p>                            它先把当前线程中的值与主存中的值进行比较，如果比较一致，那么就修改主存中的值。</p> 
<p>                            如果不一致，那么就获取最新的值，然后重复上述操作，直到成功。</p> 
<pre class="has"><code class="language-java">public final int incrementAndGet(){
        for(;;){
            int current = get();
            int next = current + 1;
            if(compareAndSet(current,next)){
                return next;
            }
        }
    }
</code></pre> 
<p><strong>                 什么是反射？</strong></p> 
<p>                             反射可以理解为对类的解剖。它把类的所有信息细分，分割为构造函数，成员变量，成员函数等。将它们统统视为对象处理。所以，得到了一个类的字节码，就能够操作这个类的任意属于与方法。</p> 
<p>                 <strong>动态代理是什么？</strong></p> 
<p><strong>                             </strong>动态代理是运行时动态生成代理类。它其实就是按照我们JAVA指令，在运行的时候，自动生成的一个类。一般用于执行一些公共的事情，比如 事务安全日志缓存等。</p> 
<p>                             动态代理通常分为JDK动态代理与Cglib动态代理。JDK动态代理的局限性就是只能代理接口实现类。而Cglib动态代理的局限性是不能代理final修饰的类。</p> 
<p>                              我为公司编写过AOP风格的动态代理，使用的是Cglib动态代理。我在每个Controller的方法上面都增加了一个注解。切面中扫描这个注解，将其作为一个切点。最后织入通知，将当前是谁操作的，操作了哪个方法记录的数据库中。这个过程其实就是一个AOP + Cglib动态代理。为Controller增加了日志的代理。</p> 
<p><strong>                  深拷贝和浅拷贝区别是什么？</strong></p> 
<p>                                浅克隆是指，复制一份对象，基本数据类型的值不变，引用数据类型的对象地址给这个克隆对象。</p> 
<p>                                深克隆是指，复制一份对象，对于引用数据类型，重新创建一个新的对象给这个克隆对象。</p> 
<p>                                Object类中已经提供了clone()的方法。所以每个对象都会有clone()方法。但是这个是浅克隆的。一般先实现Clonable接口，然后重写clone()方法。</p> 
<p>                                 为什么使用克隆？因为效率高，Object 的 clone() 方法是一个native方法。</p> 
<p><strong>                 JSP 和 servlet 有什么区别？</strong></p> 
<p><strong>                         </strong>         JSP本质上是一个Servlet。JSP一种用于页面的特殊Java代码，而Servlet就是纯粹的Java代码，用于处理用户的URL请求<strong>。</strong></p> 
<p>     <strong>            JSP 有 9 大内置对象：</strong></p> 
<p>                                  request、resposne、session、application</p> 
<p>                                  page、pageContext、config、exception、out</p> 
<p>                                  page当前JSP对象,PageContext相当于一个JSP环境的容器、config是相关配置，exception是异常，out是输出流。</p> 
<p><strong>                  说说JSP的4种作用域</strong></p> 
<p>                                   page范围属性：跳转到其它页面就不能访问了</p> 
<p>                                   request范围属性：只在一次跳转中有效。只要URL不变，也就是说是服务器内部转发，那么request域容器内的数据都能拿到。</p> 
<p>                                   session范围属性：只要不关闭浏览器，在同一次会话中都能拿到容器中数据。</p> 
<p><span style="color:#ff0000;">                                   </span>application范围属性：只要服务器不关闭，存放在application域容器里面的数据都不会消失。</p> 
<p><strong>                 说一下Session的原理：</strong></p> 
<p>                                   <a href="https://blog.csdn.net/yanluandai1985/article/details/87074795">理解Session与Cookie</a></p> 
<p><span style="color:#ff0000;">                                   </span>session 的工作原理是客户端登录完成之后，服务器会创建对应的 session，session 创建完之后，会把 session 的 id 发送给客户端，客户端再存储到浏览器中。这样客户端每次访问服务器时，都会带着 sessionid，服务器拿到 sessionid 之后，在内存找到与之对应的 session 这样就可以正常工作了。</p> 
<p>                  <strong>Cookie的基本理解（购物卡）</strong></p> 
<p><span style="color:#ff0000;">                                   </span>Session与Cookie都是一种记录客户状态的机制。</p> 
<p><span style="color:#ff0000;">                                   </span>当一个用户访问服务器的时候，服务器会把一些<span style="color:#f33b45;">键值对</span>返回给客户端浏览器，并加上一些限制条件。在这个条件限制下，当用户符合条件并且在下次访问服务器的时候，会把这些键值对数据又完整的带给服务器。就好比我去某个超市，超市给了我一张购物卡。在下次我去超市的时候，超市就能快速的识别我的身份等信息。</p> 
<p>   <strong>                 客户端禁用Cookie怎么办？</strong></p> 
<p>                                   可以使用URL重写，也就是把session id附加在URL路径的后面。</p> 
<p>                  <strong> Session生命周期问题</strong></p> 
<p>                                   调用 request对象的 request.getSession()方法的时候会创建一个Session对象。 </p> 
<p>                                   当Session过期或者调用session.invalidate()方法的时候，Session对象被回收。</p> 
<p>                  <strong> 关闭浏览器问题</strong></p> 
<p>                                   关闭浏览器不会立即销毁session。因为session存放在服务器端。</p> 
<p>                                   关闭浏览器只会让保存在客户端的Cookie失效。</p> 
<p><strong>                    Cookie和Session的区别</strong></p> 
<p>                                    作用域不同：Cookie作用在客户端，而Session作用域服务器端。</p> 
<p>                                    存储:Cookie最多能存储4KB的数据，而Session理论上是服务器的内存大小。</p> 
<p>                                    从安全性的角度来考虑：Cookie保存的键值对由Http请求头传输，可以直接在浏览器上查看到，不安全。</p> 
<p>                    <strong>如何避免 SQL 注入？</strong></p> 
<p><strong>                                    </strong>1.MyBatis中，可以使用<span style="color:#f33b45;">参数占位符</span>可以使用#{}替代${}。</p> 
<p>                                    2.对用户的输入用正则表达式，过滤掉一些可能的SQL注入的特殊字符。</p> 
<p>                                    3.如果是Jdbc的话，使用preparedStatement替换掉Statement。</p> 
<p><strong> </strong>                    <strong>try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？</strong></p> 
<p>                                    finally 一定会执行，即使是 catch 中 return 了，catch 中的 return 会等 finally 中的代码执行完之后，才会执行。</p> 
<p><strong>                     重定向与转发的区别</strong></p> 
<p><strong>  </strong>                                  而转发的URL不会变，重定向的URL将会发生改变</p> 
<p>                                    转发是服务器内部转发，所以request里面的数据可共享。而重定向则是重新创建了一个request，所以数据丢失。</p> 
<p><strong>                     简述 tcp 和 udp的区别？</strong></p> 
<p>                                   tcp协议要求建立三次握手以后，才能进行数据传输。而upd只管发送，不管接收。</p> 
<p><strong>                    get 和 post 请求有哪些区别？</strong></p> 
<p>                                  get请求会把参数放在URL里，post不会。</p> 
<p>                                  get请求不安全，post请求安全。</p> 
<p>                                  get请求携带的参数在请求头上，有限制，而post请求是把数据存放在请求体里面，理论上无限制。</p> 
<p>                                  get请求浏览器会缓存数据，修改成post请求就不会缓存数据了。</p> 
<p><strong>3月25日</strong> </p> 
<p><strong>                    说一下你熟悉的设计模式？</strong></p> 
<p><strong>                                </strong> 最数据的莫过于单例模式。要求掌握 懒汉式，以及内存分配。</p> 
<p>                                 <a href="https://blog.csdn.net/yanluandai1985/article/details/79782728">https://blog.csdn.net/yanluandai1985/article/details/79782728</a></p> 
<p>                                 模版设计模式（插件自动生成）</p> 
<p>                                 策略设计模式（插件替换，2019年国务院的减税政策，比如有小孩，有养老、有租房的人都可以）</p> 
<p>                                 观察者设计模式（消息队列，发送消息）</p> 
<p>                                 工厂设计模式（减税政策，与策略设计模式一起使用，构造函数接收用户传递的数据）</p> 
<p>                     <strong>解释一下什么是 aop</strong></p> 
<p>                                  aop是面向切面编程。通过我们的Java指令，在程序运行期间，生成一个AOP代理类，一般用于日志安全事务缓存。我以前为公司的Controller类做过日志的代理。是基于Cglib的动态代理。在每一个Controller类上的方法加上注解。然后编写一个切面，专门用来扫描这个注解。最后织入前置通知，记录下是谁操作了这个方法，用户的IP地址是什么，将其插入到数据库。</p> 
<p>                     <strong>解释一下什么是 ioc？</strong></p> 
<p>                                  ioc一般在中文中解释为 控制反转，也称为依赖注入。它将对象的 创建与依赖关系写到了配置文件中，在成程序运行过程中动态的注入进去，实现了各组件之间的松耦合。</p> 
<p>                     <strong>spring 的 bean 有哪些scope[作用域]</strong></p> 
<p><strong>                                   </strong>1、singleton:单例。【默认】<br>                                    2、prototype:原型，每次创建一个新对象</p> 
<p>                      <strong>spring 的 bean 是线程安全的吗？</strong></p> 
<p>                                   Spring的Bean的常用的作用域有两种。默认是单例模式的，所有线程都共享一个单例实例Bean，因此会存在线程安全问题。不过我们一般用的Controller、Service、Dao这些类，都是用来查询的。他们是无状态的，也就是说，一般不会用来保存数据。所以可以姑且认为线程安全。</p> 
<p>                                   另外一种作用域是原型作用域，就是每次请求都会创建一个实例。这样的话，各个线程都会有自己的实例数据，就不会存在线程安全问题。</p> 
<p>                      <strong>spring 事务实现方式有哪些？</strong></p> 
<p><strong>                                   </strong> 实际遇到的声明式事务。在Spring的配置文件中增加一行关于事务管理器的配置，然后在Service的实现类上增加一个注解就好了。</p> 
<p>                      <strong>说一下 spring mvc 运行流程？</strong></p> 
<p><strong>                                    </strong>首先把请求发送到前端控制器DispatcherServlet。前端控制器将会找到处理此请求的Controller。</p> 
<p>                                    Controller调用相关业务逻辑，处理完毕后，返回一个ModelAndView。</p> 
<p>                                    视图解析器将会解析这个ModelAndView，并返回一个视图。视图渲染后呈现给客户。</p> 
<p>                      <strong>@RequestMapping 的作用是什么？</strong></p> 
<p><strong>                                     </strong>如果配置在类上，用于窄化请求。</p> 
<p>                                     如果配置在方法上，用于接收指定的Http请求，然后调用这个方法处理。</p> 
<p>                     <strong> @Autowired 的作用是什么？</strong></p> 
<p>                                      从Spring容器中获取到这个类型的一个Bean，赋值给被配置的字段。</p> 
<p><strong>3月29日</strong> </p> 
<p>                      <strong>数据库中count(1)和count(*)的区别</strong></p> 
<p>                                      count(*) 返回表中所有存在行的总数包括null,然而count(1) 返回的是去除null以外的所有行的总数。有默认值的也会被记录</p> 
<p>                                      最后总结三条经验，(这个也是好久之前在网上看到的，不过本人亲自测试过)</p> 
<p>                                      1.任何情况下select count(*) from table 最优选择</p> 
<p>                                      2.减少select count(*) from table where condition = ? 这样的查询</p> 
<p>                                      3.杜绝select count(colunm) from table</p> 
<p>                      <strong>SpringBoot是什么，有什么有优点？</strong></p> 
<p>                                       SpringBoot是为Spring服务的，它发展了Spring而不是替代了Spring。使用SpringBoot可以快速搭建一个例如SSM的框架，没有传统的SSM的复杂配置。主要优势在于方便快捷。而且各个组件厂商也积极的开发出可以集成到SpringBoot的组件，比如Mybatis，RabbitMQ，Redis。</p> 
<p>                                       SpringBoot的核心思想是约定优于配置。另外一个特色就是使用了大量的注解，让Java类才替代繁琐的配置文件。</p> 
<p><strong>                      Spring boot 配置文件有哪几种类型？它们有什么区别？</strong> </p> 
<p>                                        配置文件主要有两种写法，一种是.properties的写法，一种是.yml的写法。</p> 
<p>                                        主要区别就是书写风格不同。另外， yml 格式不支持 @PropertySource 注解导入。而prpperties写法可以使用@Value注解从配置文件中获取数据。</p> 
<p><strong>                      jpa 和 hibernate 有什么区别？</strong></p> 
<p>                                        jpa 全称 Java Persistence API，是 Java 持久化接口规范，hibernate 属于 jpa 的具体实现。</p> 
<p>                                        JPA最大的好处就是可以少写很多SQL语句，简单的增删改查JPA都已经实现，直接调用即可。</p> 
<p><strong>                      SpringCloud的主要功能</strong></p> 
<p><strong>                         </strong>               服务发现、负载均衡、断路器、配置中心、消息总线 。</p> 
<p>                       <strong>断路器的作用</strong></p> 
<p><strong>                         </strong>               如果单个服务器节点出现问题，可能会导致依赖此微服务的节点系统均出现请求失败，这样循环下去可能会影响全局系统。断路打开后，可用避免连锁故障，熔断方法可以直接返回一个固定值。</p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0c23378b43f0148f3c62a23e6ce9daaf/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">JavaScript中Number的数值范围以及判断</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e03b85e3aa638cf2bbeef5f1247046ac/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">python使用UDP协议进行远程桌面共享</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>