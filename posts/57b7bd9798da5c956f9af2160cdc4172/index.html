<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java基础之（八）方法覆盖 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Java基础之（八）方法覆盖" />
<meta property="og:description" content="子类从父类中继承方法，有时子类需要修改父类中定义的方法的实现，这称作方法覆盖。比如下面这个例子：
class Person { String name; int age; void introduce(){ System.out.println(&#34;我的姓名是：&#34; &#43; name&#43;&#34;,我的年龄是&#34;&#43; age); } } class Student extends Person { String address; void introduce(){ System.out.println(&#34;我的姓名是&#34;&#43; name &#43; &#34;,我的年龄是&#34;&#43; age); System.out.println(&#34;我的家在&#34;&#43; address); } } class Test{ public static void main(String args[]){ Student s = new Student(); s.name = &#34;张三&#34;; s.age = 20; s.address = &#34;北京&#34;; s.introduce(); } } introduce()方法在Person类中定义，在Student类中修改。并且这两个方法定义（返回值类型、方法名、参数列表）相同，只不过方法体不一样，这样的两个方法的关系我们称之为方法覆盖，有的书上也称之为方法重写/复写。
1.语法特征 在具有父子关系的两个类中父类和子类中各有一个函数，这两个函数的定义完全相同 输出结果： 我的姓名是张三，我的年龄是20 我的家在北京 2.super调用成员方法 在上面的代码中我们能够发现重复代码:
System.out.println(&#34;我的姓名是&#34;&#43; name &#43; &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/57b7bd9798da5c956f9af2160cdc4172/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2016-07-19T20:58:20+08:00" />
<meta property="article:modified_time" content="2016-07-19T20:58:20+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java基础之（八）方法覆盖</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>子类从父类中继承方法，有时子类需要修改父类中定义的方法的实现，这称作方法覆盖。比如下面这个例子：</p> 
<pre class="prettyprint"><code class=" hljs vala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> {<!-- --></span>
    String  name;
    <span class="hljs-keyword">int</span> age;

    <span class="hljs-keyword">void</span> introduce(){
        System.out.println(<span class="hljs-string">"我的姓名是："</span> + name+<span class="hljs-string">",我的年龄是"</span>+ age);
    }

}</code></pre> 
<pre class="prettyprint"><code class=" hljs axapta"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-inheritance"><span class="hljs-keyword">extends</span></span> <span class="hljs-title">Person</span> {<!-- --></span>

    String address;

    <span class="hljs-keyword">void</span> introduce(){
        System.out.println(<span class="hljs-string">"我的姓名是"</span>+ name + <span class="hljs-string">",我的年龄是"</span>+ age);
        System.out.println(<span class="hljs-string">"我的家在"</span>+ address);
    }   
}</code></pre> 
<pre class="prettyprint"><code class=" hljs cs">class Test{
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(String args[]){
    Student s = <span class="hljs-keyword">new</span> Student();
    s.name = <span class="hljs-string">"张三"</span>;
    s.age = <span class="hljs-number">20</span>;
    s.address = <span class="hljs-string">"北京"</span>;   
    s.introduce();
    }
}</code></pre> 
<p>introduce()方法在Person类中定义，在Student类中修改。并且这两个方法定义（返回值类型、方法名、参数列表）相同，只不过方法体不一样，这样的两个方法的关系我们称之为方法覆盖，有的书上也称之为方法重写/复写。</p> 
<h3 id="1语法特征">1.语法特征</h3> 
<ol><li>在具有父子关系的两个类中</li><li>父类和子类中各有一个函数，这两个函数的定义完全相同</li></ol> 
<pre class="prettyprint"><code class=" hljs ">输出结果：
我的姓名是张三，我的年龄是20
我的家在北京</code></pre> 
<h3 id="2super调用成员方法">2.super调用成员方法</h3> 
<p>在上面的代码中我们能够发现重复代码:</p> 
<pre class="prettyprint"><code class=" hljs avrasm">System<span class="hljs-preprocessor">.out</span><span class="hljs-preprocessor">.println</span>(<span class="hljs-string">"我的姓名是"</span>+ name + <span class="hljs-string">",我的年龄是"</span>+ age)<span class="hljs-comment">;</span></code></pre> 
<p>怎么解决这个问题，这时候可以用super关键字：</p> 
<pre class="prettyprint"><code class=" hljs d"><span class="hljs-keyword">void</span> introduce(){
        <span class="hljs-keyword">super</span>.introduce();
        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"我的家在"</span>+ address);
    }   
}</code></pre> 
<p>3.覆盖的注意事项</p> 
<ul><li>仅当方法是可访问时，它才能被覆盖。这样，因为私有方法在它的类本身以外是不能访问的，所以它不能被覆盖。如果子类中定义的方法在父类中是私有的，那么这两个方法完全没有关系。比如： </li></ul> 
<pre class="prettyprint"><code class=" hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> {<!-- --></span>

<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">introduce</span>() {…}

}

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span> {<!-- --></span>

<span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">introduce</span>() {…} <span class="hljs-comment">//编译错误，子类方法缩小了父类方法的访问权限</span>

}</code></pre> 
<ul><li>与实例方法一样，静态方法也能被继承。但是，静态方法不能被覆盖。如果父类中定义的静态方法在子类中被重新定义，那么定义在父类中的静态方法将被隐藏。可以使用语法：父类名.静态方法名调用隐藏的静态方法。比如：</li></ul> 
<pre class="prettyprint"><code class=" hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> {<!-- --></span>

<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">introduce</span>() { }

}

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span> {<!-- --></span>

<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">introduce</span>() { } <span class="hljs-comment">//编译出错</span>

}</code></pre> 
<h3 id="super调用成员变量">Super调用成员变量</h3> 
<p>如果子类定义了和父类同名的成员变量，则会发生子类变量隐藏父类变量的情形。在正常情况下，子类中定义的方法直接访问该变量默认会访问到子类中定义的变量，无法访问到父类中被隐藏的变量。 <br> 在子类定义的实例方法中可以通过super来调用父类中被隐藏的变量，如下代码所示：</p> 
<pre class="prettyprint"><code class=" hljs java">class BaseClass{
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> a = <span class="hljs-number">5</span>;
}

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SubClass</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BaseClass</span>{<!-- --></span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> a = <span class="hljs-number">7</span>;

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">accessOwner</span>(){
        System.out.println(a);
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">accessBase</span>(){
        <span class="hljs-comment">//通过super来限定访问从父类继承得到的a变量</span>
        System.out.println(<span class="hljs-keyword">super</span>.a);
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(String[] args){
        SubClass sc = <span class="hljs-keyword">new</span> SubClass();
        <span class="hljs-comment">//输出7</span>
        sc.accessOwner();
        <span class="hljs-comment">//输出5</span>
        sc.accessBase();
    }
}</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b33c7807042184003cfc95c9c3f40a24/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">不能修改“System Roots”钥匙串 要更改根证书是否会被信任，请在“钥匙串访问”中打开它，然后修改它的信任设置</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/225e6c0eacffe8ef203f2cb5766faf44/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">JDK, JRE和JVM的区别与联系</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>