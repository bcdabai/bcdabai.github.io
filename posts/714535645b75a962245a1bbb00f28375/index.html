<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【C&#43;&#43;高阶数据结构】B树、B&#43;树、B*树 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【C&#43;&#43;高阶数据结构】B树、B&#43;树、B*树" />
<meta property="og:description" content="🏆个人主页：企鹅不叫的博客
​ 🌈专栏
C语言初阶和进阶C项目Leetcode刷题初阶数据结构与算法C&#43;&#43;初阶和进阶《深入理解计算机操作系统》《高质量C/C&#43;&#43;编程》Linux ⭐️ 博主码云gitee链接：代码仓库地址
⚡若有帮助可以【关注&#43;点赞&#43;收藏】，大家一起进步！
💙系列文章💙 【C&#43;&#43;高阶数据结构】并查集
【C&#43;&#43;高阶数据结构】图
【C&#43;&#43;高阶数据结构】LRU
文章目录 💙系列文章💙💎一、概念🏆1.优点🏆2.B树规则 💎二、B树插入🏆1.插入过程🏆2.代码实现 💎三、B&#43;树🏆1.概念🏆2.分裂过程 💎四、B*树🏆1.概念 💎五、B树系类应用🏆1.MyISAM🏆2.InnoDB 💎一、概念 🏆1.优点 B树适合外查找，当数据量很大，无法一次全部都放进内存的话，那就只能存在磁盘上，B树本质是一个多叉搜索树。
从树的根开始读取的话，我们需要读取树的高度次磁盘IO，多次进行磁盘读取，就会非常缓慢。每次要读取新的数据，要去定位这个过程是非常缓慢。
在平衡搜索树的基础上寻找优化方法
1.压缩高度，二叉变多插
2.一个结点里面存多行的值，也就是一个结点里面有多个关键字以及映射的值
🏆2.B树规则 一棵m阶(m&gt;2)的B树，是一棵平衡的M路平衡搜索树，可以是空树或者满足一下性质：
根节点至少有两个孩子每个分支节点都包含k-1个关键字和k个孩子，其中ceil(m/2) ≤ k ≤ m ceil是向上取整函数每个叶子节点都包含k-1个关键字，其中 ceil(m/2) ≤ k ≤ m所有的叶子节点都在同一层每个节点中的关键字从小到大排列，节点当中k-1个元素正好是k个孩子包含的元素的值域划分每个结点的结构为：（n，A0，K1，A1，K2，A2，… ，Kn，An）其中，Ki(1≤i≤n)为关键字，且Ki&lt;Ki&#43;1(1≤i≤n-1)。Ai(0≤i≤n)为指向子树根结点的指针。且Ai所指子树所有结点中的关键字均小于Ki&#43;1。n为结点中关键字的个数，满足ceil(m/2)-1≤n≤m-1。 假设现在我们的m是10
按照上面的规则，也就是说我们
最少需要4个关键字和5个孩子
最多需要9个关键字和10个孩子
这个节点中的关键字按照从小到大的顺序进行排列
（n，A0，K1，A1，K2，A2，… ，Kn，An）
K1&lt;K2&lt;K3&lt;…&lt;Kn
A0节点中的值&lt;K1&lt;A1节点中的值&lt;K2&lt;……也就是说，如果比K1小，我们就在A0节点中继续寻找，如果比K2小比K1大，我们就在A1节点中进行查找。
B树本质是一个多叉搜索树。
💎二、B树插入 🏆1.插入过程 假设M=3。
也就是最少存1个关键字，最多两个关键字，最少2个孩子，最多3个孩子
这里是我们的数据：{53, 139, 75, 49, 145, 36, 101}
首先我们将53，139和75插入
（我们这里多开一个空间，便于我们的插入。否则我们的第m个元素插入的时候，也就是我们刚刚好越界的时候，我们就不知道插入在哪里，我们可能还要分情况进行讨论，这样就非常麻烦。多开辟一个空间的话，我们就可以先将这第M个元素先插进去，然后再进行分裂操作，就省去了分类讨论）
关键字的数量等于M，那就是满了，满了就分裂，分裂出一个兄弟（兄弟里面最初始没有值），然后分一半的值给兄弟
插入49，145
再插入36的时候，我们左边的结点1就满了，我们又需要进行分裂
49是我们的中位数。
所以我们将49放入我们的父节点中
（我们的关键字要比我们孩子的数量少一个。现在我们有三个孩子和两个关键字）
最右边的子树满了，进行持续分裂
B树天然平衡" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/714535645b75a962245a1bbb00f28375/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-01-06T19:50:57+08:00" />
<meta property="article:modified_time" content="2023-01-06T19:50:57+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【C&#43;&#43;高阶数据结构】B树、B&#43;树、B*树</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <blockquote> 
 <p>🏆<strong>个人主页</strong>：<a href="https://blog.csdn.net/YQ20210216?spm=1000.2115.3001.5343">企鹅不叫的博客</a></p> 
 <p>​ 🌈<strong>专栏</strong></p> 
 <ul><li><a href="https://blog.csdn.net/yq20210216/category_11417182.html?spm=1001.2014.3001.5482">C语言初阶和进阶</a></li><li><a href="https://blog.csdn.net/yq20210216/category_11679165.html">C项目</a></li><li><a href="https://blog.csdn.net/yq20210216/category_11666534.html?spm=1001.2014.3001.5482">Leetcode刷题</a></li><li><a href="https://blog.csdn.net/yq20210216/category_11665095.html?spm=1001.2014.3001.5482">初阶数据结构与算法</a></li><li><a href="https://blog.csdn.net/yq20210216/category_11728338.html?spm=1001.2014.3001.5482">C++初阶和进阶</a></li><li><a href="https://blog.csdn.net/yq20210216/category_11795108.html?spm=1001.2014.3001.5482">《深入理解计算机操作系统》</a></li><li><a href="https://blog.csdn.net/yq20210216/category_11795123.html?spm=1001.2014.3001.5482">《高质量C/C++编程》</a></li><li><a href="https://blog.csdn.net/yq20210216/category_11818303.html?spm=1001.2014.3001.5482">Linux</a></li></ul> 
 <p>⭐️ <strong>博主码云gitee链接：</strong><a href="https://gitee.com/royal-never-give-up" rel="nofollow">代码仓库地址</a></p> 
 <p>⚡若有帮助可以【<font color="#DC143C">关注</font>+<font color="#FFA500">点赞</font>+<font color="#45b97c">收藏</font>】，大家一起进步！</p> 
</blockquote> 
<h2><a id="_17"></a>💙系列文章💙</h2> 
<p><a href="https://blog.csdn.net/YQ20210216/article/details/128436878?csdn_share_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%22128436878%22%2C%22source%22%3A%22YQ20210216%22%7D">【C++高阶数据结构】并查集</a></p> 
<p><a href="https://blog.csdn.net/YQ20210216/article/details/128552858?csdn_share_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%22128552858%22%2C%22source%22%3A%22YQ20210216%22%7D">【C++高阶数据结构】图</a></p> 
<p><a href="https://blog.csdn.net/YQ20210216/article/details/128565806?csdn_share_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%22128565806%22%2C%22source%22%3A%22YQ20210216%22%7D">【C++高阶数据结构】LRU</a></p> 
<hr> 
<p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#_17" rel="nofollow">💙系列文章💙</a></li><li><a href="#_30" rel="nofollow">💎一、概念</a></li><li><ul><li><a href="#1_32" rel="nofollow">🏆1.优点</a></li><li><a href="#2B_44" rel="nofollow">🏆2.B树规则</a></li></ul> 
  </li><li><a href="#B_67" rel="nofollow">💎二、B树插入</a></li><li><ul><li><a href="#1_69" rel="nofollow">🏆1.插入过程</a></li><li><a href="#2_125" rel="nofollow">🏆2.代码实现</a></li></ul> 
  </li><li><a href="#B_349" rel="nofollow">💎三、B+树</a></li><li><ul><li><a href="#1_351" rel="nofollow">🏆1.概念</a></li><li><a href="#2_367" rel="nofollow">🏆2.分裂过程</a></li></ul> 
  </li><li><a href="#B_406" rel="nofollow">💎四、B*树</a></li><li><ul><li><a href="#1_408" rel="nofollow">🏆1.概念</a></li></ul> 
  </li><li><a href="#B_417" rel="nofollow">💎五、B树系类应用</a></li><li><ul><li><a href="#1MyISAM_432" rel="nofollow">🏆1.MyISAM</a></li><li><a href="#2InnoDB_440" rel="nofollow">🏆2.InnoDB</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<hr> 
<h2><a id="_30"></a>💎一、概念</h2> 
<h3><a id="1_32"></a>🏆1.优点</h3> 
<blockquote> 
 <p>B树适合外查找，当数据量很大，无法一次全部都放进内存的话，那就只能存在磁盘上，B树本质是一个多叉搜索树。</p> 
 <p><img src="https://images2.imgbox.com/68/58/dcB2M50d_o.png" alt="在这里插入图片描述"></p> 
 <p>从树的根开始读取的话，我们需要读取树的高度次磁盘IO，多次进行磁盘读取，就会非常缓慢。每次要读取新的数据，要去定位这个过程是非常缓慢。</p> 
 <p>在平衡搜索树的基础上寻找优化方法<br> 1.压缩高度，二叉变多插<br> 2.一个结点里面存多行的值，也就是一个结点里面有多个关键字以及映射的值</p> 
</blockquote> 
<h3><a id="2B_44"></a>🏆2.B树规则</h3> 
<blockquote> 
 <p>一棵m阶(m&gt;2)的B树，是一棵平衡的M路平衡搜索树，可以是空树或者满足一下性质：</p> 
 <ol><li>根节点至少有两个孩子</li><li>每个分支节点都包含k-1个关键字和k个孩子，其中ceil(m/2) ≤ k ≤ m ceil是向上取整函数</li><li>每个叶子节点都包含k-1个关键字，其中 ceil(m/2) ≤ k ≤ m</li><li>所有的叶子节点都在同一层</li><li>每个节点中的关键字从小到大排列，节点当中k-1个元素正好是k个孩子包含的元素的值域划分</li><li>每个结点的结构为：（n，A0，K1，A1，K2，A2，… ，Kn，An）其中，Ki(1≤i≤n)为关键字，且Ki&lt;Ki+1(1≤i≤n-1)。Ai(0≤i≤n)为指向子树根结点的指针。且Ai所指子树所有结点中的关键字均小于Ki+1。n为结点中关键字的个数，满足ceil(m/2)-1≤n≤m-1。</li></ol> 
 <p>假设现在我们的m是10<br> 按照上面的规则，也就是说我们<br> 最少需要4个关键字和5个孩子<br> 最多需要9个关键字和10个孩子</p> 
 <p>这个节点中的关键字按照从小到大的顺序进行排列<br> （n，A0，K1，A1，K2，A2，… ，Kn，An）<br> K1&lt;K2&lt;K3&lt;…&lt;Kn<br> A0节点中的值&lt;K1&lt;A1节点中的值&lt;K2&lt;……也就是说，如果比K1小，我们就在A0节点中继续寻找，如果比K2小比K1大，我们就在A1节点中进行查找。</p> 
 <p>B树本质是一个多叉搜索树。</p> 
</blockquote> 
<h2><a id="B_67"></a>💎二、B树插入</h2> 
<h3><a id="1_69"></a>🏆1.插入过程</h3> 
<blockquote> 
 <p>假设M=3。<br> 也就是最少存1个关键字，最多两个关键字，最少2个孩子，最多3个孩子<br> 这里是我们的数据：<strong>{53, 139, 75, 49, 145, 36, 101}</strong></p> 
 <p>首先我们将53，139和75插入<br> （我们这里多开一个空间，便于我们的插入。否则我们的第m个元素插入的时候，也就是我们刚刚好越界的时候，我们就不知道插入在哪里，我们可能还要分情况进行讨论，这样就非常麻烦。多开辟一个空间的话，我们就可以先将这第M个元素先插进去，然后再进行分裂操作，就省去了分类讨论）</p> 
 <p><img src="https://images2.imgbox.com/6b/22/ANdhruTM_o.png" alt="在这里插入图片描述"></p> 
 <p>关键字的数量等于M，那就是满了，满了就分裂，分裂出一个兄弟（兄弟里面最初始没有值），然后分一半的值给兄弟</p> 
 <p><img src="https://images2.imgbox.com/e8/e3/kM5X5DTL_o.png" alt="在这里插入图片描述"></p> 
 <p>插入49，145</p> 
 <p><img src="https://images2.imgbox.com/95/15/sO4TsWqI_o.png" alt="在这里插入图片描述"></p> 
 <p>再插入36的时候，我们左边的结点1就满了，我们又需要进行分裂</p> 
 <p><img src="https://images2.imgbox.com/f6/db/xhSCZSek_o.png" alt="在这里插入图片描述"></p> 
 <p>49是我们的中位数。<br> 所以我们将49放入我们的父节点中<br> （我们的关键字要比我们孩子的数量少一个。现在我们有三个孩子和两个关键字）</p> 
 <p><img src="https://images2.imgbox.com/6d/02/LrK0lucB_o.png" alt="在这里插入图片描述"></p> 
 <p><img src="https://images2.imgbox.com/d3/84/uRa2pjJo_o.png" alt="在这里插入图片描述"></p> 
 <p>最右边的子树满了，进行持续分裂</p> 
 <p><img src="https://images2.imgbox.com/e7/13/VaqDEdGO_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<blockquote> 
 <p>B树天然平衡<br> 因为它是向右和向上生长的<br> 新插入的结点一定是在叶子插入的。叶子没有孩子，所以不会影响孩子和关键字的关系（孩子比关键字多一个）<br> 叶子结点满了，就分裂出一个兄弟，提取中位数，向父亲插入一个值和一个孩子。<br> 根节点分裂才会增加一层。</p> 
</blockquote> 
<blockquote> 
 <p>假设M=1024，那么一个4层的M路的B树可以存多少个值呢？<br> 如果这棵树是全满的情况下<br> 第一层1023个关键字，1024个孩子<br> 第二层10241023个关键字（上一层的每一个孩子也就是这一层的每一个结点都有1023个关键字），10241024个孩子<br> 第三层102410241023个关键字（上一层的每一个孩子也就是这一层的每一个结点都有1023个关键字），102410241024个孩子<br> 第三层1024102410241023个关键字（上一层的每一个孩子也就是这一层的每一个结点都有1023个关键字），1024102410241024个孩子</p> 
 <p>最差的情况，最空的情况：<br> 第一层只有1个关键字，2个孩子<br> 第二层有2 * 512个关键字，大概1000个关键字，1000个孩子<br> 第三层大概1000 * 512个关键字，1000 * 512个孩子<br> 第四层大概50w * 512个关键字，约等于2.5亿个关键字</p> 
</blockquote> 
<h3><a id="2_125"></a>🏆2.代码实现</h3> 
<blockquote> 
 <pre><code class="prism language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">K</span><span class="token punctuation">,</span> size_t M<span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">BTreeNode</span> <span class="token punctuation">{<!-- --></span>

    <span class="token comment">// 原本key是M-1个大小空间</span>
    <span class="token comment">// 原本孩子是M个大小空间</span>
    <span class="token comment">// 为了方便插入以后再分裂，多给一个空间</span>
    K _keys<span class="token punctuation">[</span>M<span class="token punctuation">]</span><span class="token punctuation">;</span>
    BTreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> M<span class="token operator">&gt;</span><span class="token operator">*</span> _subs<span class="token punctuation">[</span>M <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    BTreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> M<span class="token operator">&gt;</span><span class="token operator">*</span> _parent<span class="token punctuation">;</span>
    size_t _n<span class="token punctuation">;</span> <span class="token comment">// 记录实际存储关键字</span>

    <span class="token comment">//初始化构造函数</span>
    <span class="token function">BTreeNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> M<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            _keys<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">K</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//缺省值</span>
            _subs<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        _subs<span class="token punctuation">[</span>M<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
        _parent <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
        _n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 数据是存在磁盘，K是磁盘地址，是M路的搜索树，我们的M是不确定的</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">K</span><span class="token punctuation">,</span> size_t M<span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">BTree</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">typedef</span> BTreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> M<span class="token operator">&gt;</span> Node<span class="token punctuation">;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token comment">//返回这个节点和下标</span>
    pair<span class="token operator">&lt;</span>Node<span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">Find</span><span class="token punctuation">(</span><span class="token keyword">const</span> K<span class="token operator">&amp;</span> key<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        Node<span class="token operator">*</span> parent <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
        Node<span class="token operator">*</span> cur <span class="token operator">=</span> _root<span class="token punctuation">;</span>

        <span class="token keyword">while</span> <span class="token punctuation">(</span>cur<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">// 在一个节点查找</span>
            size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> cur<span class="token operator">-&gt;</span>_n<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">&lt;</span> cur<span class="token operator">-&gt;</span>_keys<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                    <span class="token keyword">break</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">&gt;</span> cur<span class="token operator">-&gt;</span>_keys<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                    <span class="token operator">++</span>i<span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                <span class="token comment">//找到了就返回这个节点</span>
                <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
                    <span class="token keyword">return</span> <span class="token function">make_pair</span><span class="token punctuation">(</span>cur<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>

            <span class="token comment">// 往孩子去跳</span>
            <span class="token comment">// 在往下一层跳之前先将当前的结点给parent</span>
            parent <span class="token operator">=</span> cur<span class="token punctuation">;</span>
            cur <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>_subs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment">//找不到</span>
        <span class="token keyword">return</span> <span class="token function">make_pair</span><span class="token punctuation">(</span>parent<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">void</span> <span class="token function">InsertKey</span><span class="token punctuation">(</span>Node<span class="token operator">*</span> node<span class="token punctuation">,</span> <span class="token keyword">const</span> K<span class="token operator">&amp;</span> key<span class="token punctuation">,</span> Node<span class="token operator">*</span> child<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> end <span class="token operator">=</span> node<span class="token operator">-&gt;</span>_n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>end <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">&lt;</span> node<span class="token operator">-&gt;</span>_keys<span class="token punctuation">[</span>end<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token comment">// 挪动key和他的右孩子</span>
                node<span class="token operator">-&gt;</span>_keys<span class="token punctuation">[</span>end <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> node<span class="token operator">-&gt;</span>_keys<span class="token punctuation">[</span>end<span class="token punctuation">]</span><span class="token punctuation">;</span>
                node<span class="token operator">-&gt;</span>_subs<span class="token punctuation">[</span>end <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> node<span class="token operator">-&gt;</span>_subs<span class="token punctuation">[</span>end <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
                <span class="token operator">--</span>end<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>

        node<span class="token operator">-&gt;</span>_keys<span class="token punctuation">[</span>end <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> key<span class="token punctuation">;</span>
        node<span class="token operator">-&gt;</span>_subs<span class="token punctuation">[</span>end <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> child<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>child<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            child<span class="token operator">-&gt;</span>_parent <span class="token operator">=</span> node<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        node<span class="token operator">-&gt;</span>_n<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">//插入</span>
    <span class="token keyword">bool</span> <span class="token function">Insert</span><span class="token punctuation">(</span><span class="token keyword">const</span> K<span class="token operator">&amp;</span> key<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">//第一次插入</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>_root <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">//如果我们整颗树一个结点都没有</span>
            _root <span class="token operator">=</span> <span class="token keyword">new</span> Node<span class="token punctuation">;</span>
            <span class="token comment">//将我们的第一个关键字传入</span>
            _root<span class="token operator">-&gt;</span>_keys<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> key<span class="token punctuation">;</span>
            _root<span class="token operator">-&gt;</span>_n<span class="token operator">++</span><span class="token punctuation">;</span>

            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment">// key已经存在，不允许插入</span>
        pair<span class="token operator">&lt;</span>Node<span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&gt;</span> ret <span class="token operator">=</span> <span class="token function">Find</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>ret<span class="token punctuation">.</span>second <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment">// 如果没有找到，find顺便带回了要插入的那个叶子节点</span>

        <span class="token comment">// 循环每次往cur插入 newkey和child</span>
        Node<span class="token operator">*</span> parent <span class="token operator">=</span> ret<span class="token punctuation">.</span>first<span class="token punctuation">;</span>
        K newKey <span class="token operator">=</span> key<span class="token punctuation">;</span>
        Node<span class="token operator">*</span> child <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token function">InsertKey</span><span class="token punctuation">(</span>parent<span class="token punctuation">,</span> newKey<span class="token punctuation">,</span> child<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 满了就要分裂</span>
            <span class="token comment">// 没有满，插入就结束</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>parent<span class="token operator">-&gt;</span>_n <span class="token operator">&lt;</span> M<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
                size_t mid <span class="token operator">=</span> M <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>
                <span class="token comment">// 分裂一半[mid+1, M-1]给兄弟</span>
                Node<span class="token operator">*</span> brother <span class="token operator">=</span> <span class="token keyword">new</span> Node<span class="token punctuation">;</span>
                size_t j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
                size_t i <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> M <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                    <span class="token comment">// 分裂拷贝key和key的左孩子</span>
                    brother<span class="token operator">-&gt;</span>_keys<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> parent<span class="token operator">-&gt;</span>_keys<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
                    brother<span class="token operator">-&gt;</span>_subs<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> parent<span class="token operator">-&gt;</span>_subs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>parent<span class="token operator">-&gt;</span>_subs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                        parent<span class="token operator">-&gt;</span>_subs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-&gt;</span>_parent <span class="token operator">=</span> brother<span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                    <span class="token operator">++</span>j<span class="token punctuation">;</span>

                    <span class="token comment">// 拷走重置一下方便观察</span>
                    parent<span class="token operator">-&gt;</span>_keys<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">K</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    parent<span class="token operator">-&gt;</span>_subs<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>

                <span class="token comment">// 还有最后一个右孩子拷给</span>
                brother<span class="token operator">-&gt;</span>_subs<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> parent<span class="token operator">-&gt;</span>_subs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>parent<span class="token operator">-&gt;</span>_subs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                    parent<span class="token operator">-&gt;</span>_subs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-&gt;</span>_parent <span class="token operator">=</span> brother<span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                parent<span class="token operator">-&gt;</span>_subs<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>

                brother<span class="token operator">-&gt;</span>_n <span class="token operator">=</span> j<span class="token punctuation">;</span>
                parent<span class="token operator">-&gt;</span>_n <span class="token operator">-=</span> <span class="token punctuation">(</span>brother<span class="token operator">-&gt;</span>_n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

                K midKey <span class="token operator">=</span> parent<span class="token operator">-&gt;</span>_keys<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">;</span>
                parent<span class="token operator">-&gt;</span>_keys<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">K</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>


                <span class="token comment">// 说明刚刚分裂是根节点</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>parent<span class="token operator">-&gt;</span>_parent <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                    <span class="token comment">//创建一个新的父节点</span>
                    _root <span class="token operator">=</span> <span class="token keyword">new</span> Node<span class="token punctuation">;</span>
                    _root<span class="token operator">-&gt;</span>_keys<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> midKey<span class="token punctuation">;</span>
                    _root<span class="token operator">-&gt;</span>_subs<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> parent<span class="token punctuation">;</span>
                    _root<span class="token operator">-&gt;</span>_subs<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> brother<span class="token punctuation">;</span>
                    _root<span class="token operator">-&gt;</span>_n <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>

                    parent<span class="token operator">-&gt;</span>_parent <span class="token operator">=</span> _root<span class="token punctuation">;</span>
                    brother<span class="token operator">-&gt;</span>_parent <span class="token operator">=</span> _root<span class="token punctuation">;</span>
                    <span class="token keyword">break</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
                    <span class="token comment">// 转换成往parent-&gt;parent 去插入parent-&gt;[mid] 和 brother</span>
                    newKey <span class="token operator">=</span> midKey<span class="token punctuation">;</span>

                    child <span class="token operator">=</span> brother<span class="token punctuation">;</span>
                    parent <span class="token operator">=</span> parent<span class="token operator">-&gt;</span>_parent<span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">void</span> <span class="token function">_InOrder</span><span class="token punctuation">(</span>Node<span class="token operator">*</span> cur<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>cur <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span><span class="token punctuation">;</span>

        <span class="token comment">// 左 根  左 根  ...  右</span>
        size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> cur<span class="token operator">-&gt;</span>_n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token function">_InOrder</span><span class="token punctuation">(</span>cur<span class="token operator">-&gt;</span>_subs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 左子树</span>
            cout <span class="token operator">&lt;&lt;</span> cur<span class="token operator">-&gt;</span>_keys<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span> <span class="token comment">// 根</span>
        <span class="token punctuation">}</span>

        <span class="token function">_InOrder</span><span class="token punctuation">(</span>cur<span class="token operator">-&gt;</span>_subs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 最后的那个右子树</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">void</span> <span class="token function">InOrder</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token function">_InOrder</span><span class="token punctuation">(</span>_root<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token keyword">private</span><span class="token operator">:</span>
    Node<span class="token operator">*</span> _root <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">TestBtree</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span> <span class="token number">53</span><span class="token punctuation">,</span> <span class="token number">139</span><span class="token punctuation">,</span> <span class="token number">75</span><span class="token punctuation">,</span> <span class="token number">49</span><span class="token punctuation">,</span> <span class="token number">145</span><span class="token punctuation">,</span> <span class="token number">36</span><span class="token punctuation">,</span> <span class="token number">101</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
    BTree<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token operator">&gt;</span> t<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> e <span class="token operator">:</span> a<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        t<span class="token punctuation">.</span><span class="token function">Insert</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    t<span class="token punctuation">.</span><span class="token function">InOrder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
 <p>时间复杂度：</p> 
 <p>第一层：M<br> 第二层：M * M<br> 第三层：M * M * M<br> 第四层：M * M * M * M</p> 
 <p>N=M+M2 +M3 +M4 +……+Mh<br> h约等于<br> <span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           l 
          
         
           o 
          
         
           g 
          
          
          
            M 
           
          
            N 
           
          
         
        
          log{M}^{N} 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1.0858em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.0197em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right: 0.0359em;">g</span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right: 0.109em;">M</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.8913em;"><span class="" style="top: -3.113em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right: 0.109em;">N</span></span></span></span></span></span></span></span></span></span></span></span></span></span></p> 
</blockquote> 
<h2><a id="B_349"></a>💎三、B+树</h2> 
<h3><a id="1_351"></a>🏆1.概念</h3> 
<blockquote> 
 <p>1.分支节点的子树指针与关键字个数相同。（就相当于是取消掉了原先B树每个结点的最左边的那个孩子）<br> 2.分支节点的子树指针p[i]指向关键字值大小在[k[i]，k[i+1])区间之间<br> 3.所有叶子节点增加一个链接指针链接在一起<br> 4.所有关键字及其映射数据都在叶子节点出现】</p> 
 <p>5.节点的关键字数量是[1, M]，非根节点关键字数量为[M/2,M]</p> 
 <p>6.分支节点跟叶子结点有重复的值，分支节点存的是叶子结点的索引<br> 7.父亲中存的是孩子结点中的最小值做索引<br> 8.分支节点可以只存key，叶子结点存key/value<br> <img src="https://images2.imgbox.com/d5/e0/1rcPnQIK_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<h3><a id="2_367"></a>🏆2.分裂过程</h3> 
<blockquote> 
 <p>假设这是一棵M == 3的B+树，然后我们B+树要插入的数据是<br> {53,139,75,49,145,36,101,150,155};</p> 
 <p>1.依次插入53 139 75</p> 
 <p><img src="https://images2.imgbox.com/3f/63/Ews5G4xq_o.png" alt="在这里插入图片描述"></p> 
 <p>2.插入19时发生裂变</p> 
 <p><img src="https://images2.imgbox.com/31/46/Zf36XL43_o.png" alt="在这里插入图片描述"></p> 
 <p><img src="https://images2.imgbox.com/3c/27/TXI2Wk9g_o.png" alt="在这里插入图片描述"></p> 
 <p>3.插入146和36</p> 
 <p><img src="https://images2.imgbox.com/c8/54/l7QghTbx_o.png" alt="在这里插入图片描述"></p> 
 <p>4.插入101的时候发生第二次分裂</p> 
 <p><img src="https://images2.imgbox.com/dd/15/1BJ3oVPy_o.png" alt=" ["></p> 
 <p><img src="https://images2.imgbox.com/db/81/OfVb8dtr_o.png" alt="在这里插入图片描述"></p> 
 <p>5.插入150，插入155的时候发生连续的两次分裂</p> 
 <p><img src="https://images2.imgbox.com/0c/bf/RT6nkkM3_o.png" alt="在这里插入图片描述"></p> 
 <p><img src="https://images2.imgbox.com/43/d9/oDRQfzuu_o.png" alt="在这里插入图片描述"></p> 
 <p><img src="https://images2.imgbox.com/b6/66/7QURhtEY_o.png" alt="在这里插入图片描述"></p> 
 <p>B+树的插入过程根B树是基本类似的，区别在于第一次插入的时候需要插入两层节点，一层做分支，一层做根，后面一样往叶子去插入，插入满了以后，分一半给兄弟，转换成往父亲插入一个key和一个孩子，孩子就是兄弟，key为兄弟结点的第一个最小值的key</p> 
</blockquote> 
<blockquote> 
 <p>总结：<br> 1.简化孩子比关键字多一个的规则，变成相等。<br> 2.所有值都在叶子上，方便便利查找所有值。</p> 
</blockquote> 
<h2><a id="B_406"></a>💎四、B*树</h2> 
<h3><a id="1_408"></a>🏆1.概念</h3> 
<blockquote> 
 <p><img src="https://images2.imgbox.com/8f/78/oItkmo0Q_o.png" alt="在这里插入图片描述"></p> 
 <ul><li>B树定义了非叶子结点关键字个数至少为(2/3)*M，即块的最低使用率为2/3(代替B+树的1/2);</li><li>B*树的分裂:当一个结点满时，如果它的下一个兄弟结点未满，那么将一部分数据移到兄弟结点中，再在原结点插入关键字，最后修改父结点中兄弟结点的关键字(因为兄弟结点的关键字范围改变了)。</li><li>如果兄弟也满了，则在原结点与兄弟结点之间增加新结点，并各复制1/3的数据到新结点，最后在父结点增加新结点的指针。 所以，B * 树分配新结点的概率比B＋树要低，空间使用率更高。</li><li>B*树主要就是节省空间。</li></ul> 
</blockquote> 
<h2><a id="B_417"></a>💎五、B树系类应用</h2> 
<blockquote> 
 <p>B树系列优点：</p> 
 <p>在内存中做内查找的话和哈希、平衡搜索树对比，单纯论树的高度，搜索效率而言，B树更好</p> 
 <p>B树系列缺点：</p> 
 <p>1.空间利用率低，消耗高<br> 2.插入和删除数据、分裂和合并节点，那么必然挪动数据。<br> 3.虽然高度更低，但是在内存中而言，跟哈希和平衡搜索树还是在一个量级的<br> 结论：实质上B树系列在内存中体现不出优势。</p> 
 <p>B树系列的应用：数据库中的引擎MyISAM或者InnoDB</p> 
</blockquote> 
<h3><a id="1MyISAM_432"></a>🏆1.MyISAM</h3> 
<blockquote> 
 <p>MyISAM引擎是MySQL5.5.8版本之前默认的存储引擎，不支持事务，支持全文检索，使用B+Tree作为索引结构，叶节点的data域存放的是数据记录的地址</p> 
 <p><img src="https://images2.imgbox.com/e5/55/0fORi7Hk_o.png" alt="在这里插入图片描述"></p> 
 <p>yISAM中索引检索的算法为首先按 照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为 地址，读取相应数据记录。</p> 
</blockquote> 
<h3><a id="2InnoDB_440"></a>🏆2.InnoDB</h3> 
<blockquote> 
 <p>InnoDB存储引擎支持事务，InnoDB支持B+树索引、全文索引、哈希索引。InnoDB索引，表数据文件本身就是按B+Tree组织的一个索 引结构，这棵树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。</p> 
 <p><img src="https://images2.imgbox.com/72/92/B5tb5h0g_o.png" alt="在这里插入图片描述"></p> 
 <p>先用name,name对应主键id，再用主键id再去搜索一次，也就是说他用索引查找需要查找两次</p> 
</blockquote> 
<blockquote> 
 <p>B树节点数据都在磁盘文件中。访问节点都是IO行为，只是他们会热数据缓存到Cache中</p> 
</blockquote> 
<hr>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ad4fbee9722ffd1e2d33cf3de4ac17e2/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">社区发现系列02-算法介绍</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/12ea64a9cb003937b7471b8a191d4118/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">el-input输入校验不能为空格，不能输入全部为空的内容</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>