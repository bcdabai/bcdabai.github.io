<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【LLM】基于LLM的agent应用（上） - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【LLM】基于LLM的agent应用（上）" />
<meta property="og:description" content="note 在未来，Agent 还会具备更多的可扩展的空间。 就 Observation 而言，Agent 可以从通过文本输入来观察来理解世界到听觉和视觉的集成；就 Action 而言，Agent 在具身智能的应用场景下，对各种器械进行驱动和操作。 Agent 是以核心智能模型来驱动的，一个可以具备能力从思考开始，最终做到完整输出的智能性结构。Agent 的发展很符合第一性原理，从最先的 Prompt，后面有人在写完的 Prompt 后面加通用的规划器。 文章目录 note零、相关概念介绍一、人类与AI协同的三种模式二、Generative Agents三、一篇agent综述四、微软的AutoGen 框架五、agent和function call六、chatglm3-6b的agent应用1. chatglm3的特点2. ChatGLM3 对话格式（1）规定整体结构对话头 （2）样例场景多轮对话工具调用代码执行 附：体系Reference 零、相关概念介绍 【狭义】openai定义的agent：Lilian Weng研究员指出agent应具有技能调用（Tool use）、记忆（Memory）和规划（Planning）能力 推荐阅读：Marvin Minsky 的两本著作：《心智社会》和《情感机器》。Lilian Weng 文章：https://lilianweng.github.io/posts/2023-06-23-agent 【广义】agent：以下几种能力：Agent 的基础能力，包括常识推理、逻辑性等，来源于大模型提供的基础智能。所以我们对 Agent 这一层能力的设计，本质上都是对模型的优化。如果要改进 Agent 在这一方面的能力，通常需要更换或优化底层模型。Agent 的角色扮演、情感理解和身份相关能力，与其记忆和拟人化角色设定的 Prompt 工程紧密相关。这部分称为“角色管理”，涉及到如何让 Agent 理解并扮演特定的角色或身份。Agent 的技能调用能力，如编程、查询、绘图等，依赖于 Agent 之上的插件。OpenAI 的“Function calling”机制是一个经典的实现方 式，允许 Agent 调用外部的功能和资源。Agent 的复杂思维能力，在基础智能之上，大模型通过人们构建的思维链、思维树等方式，学会更高层的思维方式。这种方法教会模型特定的模式或思维方式，从而提高其处理复杂问题的能力。 COT（Chain of Thoughts）：思维链，一种模拟人类逻辑和推理过程的推理框架，能够帮助大语言模型解决复杂的算术、常识及字符推理等任务。TOT（Tree of Thoughts）：思维树，一种模拟人类逻辑和推理过程的推理框架，允许语言模型通过考虑多种不同的推理路径和自我评估选择来进行深思熟虑的决策，以及在必要时向前看或回溯以做出全局选择。Autonomy Agent：理想状态下能够在没有外部干预的情况下自主作出决策和执行任务的AI系统。Multi-Agent：多个AI代理共同工作，相互协作或竞争以完成复杂任务的系统。RAG：检索增强生成（Retrieval Augmented Generation），通过在生成响应之前从知识源检索相关信息来增强LLM的能力，适合需要查询数据库、文档或其他结构化/非结构化数据存储库的应用程序。 一、人类与AI协同的三种模式 二、Generative Agents 《Generative Agents: Interactive Simulacra of Human Behavior》" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/df162ceee7db9c94386605d79cdba948/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-11-19T18:19:51+08:00" />
<meta property="article:modified_time" content="2023-11-19T18:19:51+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【LLM】基于LLM的agent应用（上）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-dracula">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="note_0"></a>note</h2> 
<ul><li>在未来，Agent 还会具备更多的可扩展的空间。 
  <ul><li>就 Observation 而言，Agent 可以从通过文本输入来观察来理解世界到听觉和视觉的集成；</li><li>就 Action 而言，Agent 在具身智能的应用场景下，对各种器械进行驱动和操作。</li></ul> </li><li>Agent 是以核心智能模型来驱动的，一个可以具备能力从思考开始，最终做到完整输出的智能性结构。Agent 的发展很符合第一性原理，从最先的 Prompt，后面有人在写完的 Prompt 后面加通用的规划器。</li></ul> 
<p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#note_0" rel="nofollow">note</a></li><li><a href="#_9" rel="nofollow">零、相关概念介绍</a></li><li><a href="#AI_28" rel="nofollow">一、人类与AI协同的三种模式</a></li><li><a href="#Generative_Agents_31" rel="nofollow">二、Generative Agents</a></li><li><a href="#agent_39" rel="nofollow">三、一篇agent综述</a></li><li><a href="#AutoGen__44" rel="nofollow">四、微软的AutoGen 框架</a></li><li><a href="#agentfunction_call_58" rel="nofollow">五、agent和function call</a></li><li><a href="#chatglm36bagent_65" rel="nofollow">六、chatglm3-6b的agent应用</a></li><li><ul><li><a href="#1_chatglm3_66" rel="nofollow">1. chatglm3的特点</a></li><li><a href="#2_ChatGLM3__72" rel="nofollow">2. ChatGLM3 对话格式</a></li><li><ul><li><a href="#1_75" rel="nofollow">（1）规定</a></li><li><ul><li><a href="#_76" rel="nofollow">整体结构</a></li><li><a href="#_87" rel="nofollow">对话头</a></li></ul> 
    </li><li><a href="#2_101" rel="nofollow">（2）样例场景</a></li><li><ul><li><a href="#_102" rel="nofollow">多轮对话</a></li><li><a href="#_113" rel="nofollow">工具调用</a></li><li><a href="#_148" rel="nofollow">代码执行</a></li></ul> 
   </li></ul> 
  </li></ul> 
  </li><li><a href="#_272" rel="nofollow">附：体系</a></li><li><a href="#Reference_276" rel="nofollow">Reference</a></li></ul> 
</div> 
<p></p> 
<h2><a id="_9"></a>零、相关概念介绍</h2> 
<p><img src="https://images2.imgbox.com/9d/9c/aoo2jiiw_o.png" alt="在这里插入图片描述"></p> 
<ul><li>【狭义】openai定义的agent：Lilian Weng研究员指出agent应具有技能调用（Tool use）、记忆（Memory）和规划（Planning）能力 
  <ul><li>推荐阅读：Marvin Minsky 的两本著作：《心智社会》和《情感机器》。Lilian Weng 文章：https://lilianweng.github.io/posts/2023-06-23-agent</li></ul> </li><li>【广义】agent：以下几种能力：</li><li>Agent 的基础能力，包括常识推理、逻辑性等，来源于大模型提供的基础智能。所以我们对 Agent 这一层能力的设计，本质上都是对模型的优化。如果要改进 Agent 在这一方面的能力，通常需要更换或优化底层模型。</li><li>Agent 的角色扮演、情感理解和身份相关能力，与其记忆和拟人化角色设定的 Prompt 工程紧密相关。这部分称为“角色管理”，涉及到如何让 Agent 理解并扮演特定的角色或身份。</li><li>Agent 的技能调用能力，如编程、查询、绘图等，依赖于 Agent 之上的插件。OpenAI 的“Function calling”机制是一个经典的实现方 式，允许 Agent 调用外部的功能和资源。</li><li>Agent 的复杂思维能力，在基础智能之上，大模型通过人们构建的思维链、思维树等方式，学会更高层的思维方式。这种方法教会模型特定的模式或思维方式，从而提高其处理复杂问题的能力。</li></ul> 
<p><img src="https://images2.imgbox.com/9a/cb/DuYXdOUo_o.png" alt="在这里插入图片描述" width="600"></p> 
<ul><li>COT（Chain of Thoughts）：思维链，一种模拟人类逻辑和推理过程的推理框架，能够帮助大语言模型解决复杂的算术、常识及字符推理等任务。</li><li>TOT（Tree of Thoughts）：思维树，一种模拟人类逻辑和推理过程的推理框架，允许语言模型通过考虑多种不同的推理路径和自我评估选择来进行深思熟虑的决策，以及在必要时向前看或回溯以做出全局选择。</li><li>Autonomy Agent：理想状态下能够在没有外部干预的情况下自主作出决策和执行任务的AI系统。</li><li>Multi-Agent：多个AI代理共同工作，相互协作或竞争以完成复杂任务的系统。</li><li>RAG：检索增强生成（Retrieval Augmented Generation），通过在生成响应之前从知识源检索相关信息来增强LLM的能力，适合需要查询数据库、文档或其他结构化/非结构化数据存储库的应用程序。</li></ul> 
<h2><a id="AI_28"></a>一、人类与AI协同的三种模式</h2> 
<p><img src="https://images2.imgbox.com/88/57/8sOMwAAU_o.png" alt="在这里插入图片描述" width="730"></p> 
<h2><a id="Generative_Agents_31"></a>二、Generative Agents</h2> 
<p>《Generative Agents: Interactive Simulacra of Human Behavior》<br> 25个agent进行交互，模拟人类行为。<br> <img src="https://images2.imgbox.com/4e/e7/nUmUzGLP_o.png" alt="在这里插入图片描述"></p> 
<p>参考：<br> [1] <a href="https://mp.weixin.qq.com/s/KPJZCMfcBQj3nbxwbfTWrA" rel="nofollow">《Generative Agents: Interactive Simulacra of Human Behavior》中文阅读</a><br> [2] https://arxiv.org/pdf/2304.03442.pdf</p> 
<h2><a id="agent_39"></a>三、一篇agent综述</h2> 
<p>A Survey on LLM-based Autonomous Agents<br> 链接：https://github.com/Paitesanshi/LLM-Agent-Survey</p> 
<p><img src="https://images2.imgbox.com/26/9a/60Z46onk_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="AutoGen__44"></a>四、微软的AutoGen 框架</h2> 
<p><a href="https://www.zhihu.com/question/624287948/answer/3231248467" rel="nofollow">微软推出 AutoGen 框架，有哪些你喜欢的功能？</a></p> 
<blockquote> 
 <p>9 月 29 日消息，微软近日发布了名为 AutoGen 的全新工具，帮助开发者创建基于大语言模型的复杂应用程序。<br> 微软表示开发者创建此类复杂应用程序，通常需要具备设计、实施和优化工作流程的专业知识，而本次推出 AutoGen 工具可以帮助开发者自动执行相关工作流程，简化搭建、优化等流程并实现自动化。</p> 
</blockquote> 
<p>微软表示 AutoGen 可以用于定义代理交互行为。开发人员可以使用自然语言和计算机代码为不同的应用程序编写灵活的对话模式。通过自动化多个 LLM 代理之间的聊天，开发人员可以轻松地让他们自主或根据人工反馈共同执行任务，包括需要通过代码使用工具的任务。</p> 
<p>AutoGen 工具的主要功能：</p> 
<ul><li>AutoGen 提供多代理会话框架作为高级抽象。使用此框架，可以方便地构建 LLM 工作流程。</li><li>AutoGen 提供一系列工作系统，涵盖来自各个领域和复杂性的广泛应用。</li><li>AutoGen 支持增强型 LLM 推理 API，可用于提高推理性能并降低成本。</li></ul> 
<h2><a id="agentfunction_call_58"></a>五、agent和function call</h2> 
<p>gpt中的function call可以让开发者在调用 GPT-4 和 GPT-3.5-turbo 模型时，描述函数并让模型智能地输出一个包含调用这些函数所需参数的 JSON 对象。这种功能可以更可靠地将 GPT 的能力与外部工具和 API 进行连接，从而实现以下应用：</p> 
<ul><li>创建聊天机器人：开发者可以通过调用外部工具，如 ChatGPT 插件，回答问题，或者将查询「北京的天气如何？」转换为调用 getCurrentWeather(location: string) 的函数。</li><li>将自然语言转换为 API 调用或数据库查询：例如，将查询「这个月我的前十个客户是谁？」转换为调用 get_customers_by_revenue(start_date, end_date, limit) 的内部 API 调用，或者将查询「上个月 Acme 公司下了多少订单？」转换为使用 sql_query(query)的 SQL 查询。</li><li>从文本中提取结构化数据：开发者可以定义一个名为 extract_people_data(people) 的函数，以提取在维基百科文章中提到的所有人物。</li></ul> 
<h2><a id="chatglm36bagent_65"></a>六、chatglm3-6b的agent应用</h2> 
<h3><a id="1_chatglm3_66"></a>1. chatglm3的特点</h3> 
<p>特点：</p> 
<ul><li>更强大的基础模型： ChatGLM3-6B 的基础模型 ChatGLM3-6B-Base 采用了更多样的训练数据、更充分的训练步数和更合理的训练策略。在语义、数学、推理、代码、知识等不同角度的数据集上测评显示，ChatGLM3-6B-Base 具有在 10B 以下的预训练模型中最强的性能。</li><li>更完整的功能支持： ChatGLM3-6B 采用了全新设计的 Prompt 格式，除正常的多轮对话外。同时原生支持工具调用（Function Call）、代码执行（Code Interpreter）和 Agent 任务等复杂场景。</li><li>全新的 Agent 智能体能力：<br> ChatGLM3 本次集成了自研的 AgentTuning 技术，激活了模型智能体能力，尤其在智能规划和执行方面，相比于ChatGLM二代提升 1000% ；开启国产大模型原生支持工具调用、代码执行、游戏、数据库操作、知识图谱搜索与推理、操作系统等复杂场景。</li></ul> 
<h3><a id="2_ChatGLM3__72"></a>2. ChatGLM3 对话格式</h3> 
<p>为了避免用户输入的注入攻击，以及统一 Code Interpreter，Tool &amp; Agent 等任务的输入，ChatGLM3 采用了全新的对话格式。</p> 
<h4><a id="1_75"></a>（1）规定</h4> 
<h5><a id="_76"></a>整体结构</h5> 
<p>ChatGLM3 对话的格式由若干对话组成，其中每个对话包含对话头和内容，一个典型的多轮对话结构如下</p> 
<pre><code class="prism language-text">&lt;|system|&gt;
You are ChatGLM3, a large language model trained by Zhipu.AI. Follow the user's instructions carefully. Respond using markdown.
&lt;|user|&gt;
Hello
&lt;|assistant|&gt;
Hello, I'm ChatGLM3. What can I assist you today?
</code></pre> 
<h5><a id="_87"></a>对话头</h5> 
<p>对话头占完整的一行，格式为</p> 
<pre><code class="prism language-text">&lt;|role|&gt;{metadata}
</code></pre> 
<p>其中 <code>&lt;|role|&gt;</code> 部分使用 special token 表示，无法从文本形式被 tokenizer 编码以防止注入。metadata 部分采用纯文本表示，为可选内容。</p> 
<ul><li><code>&lt;|system|&gt;</code>：系统信息，设计上可穿插于对话中，<strong>但目前规定仅可以出现在开头</strong></li><li><code>&lt;|user|&gt;</code>：用户 
  <ul><li>不会连续出现多个来自 <code>&lt;|user|&gt;</code> 的信息</li></ul> </li><li><code>&lt;|assistant|&gt;</code>：AI 助手 
  <ul><li>在出现之前必须有一个来自 <code>&lt;|user|&gt;</code> 的信息</li></ul> </li><li><code>&lt;|observation|&gt;</code>：外部的返回结果 
  <ul><li>必须在 <code>&lt;|assistant|&gt;</code> 的信息之后</li></ul> </li></ul> 
<h4><a id="2_101"></a>（2）样例场景</h4> 
<h5><a id="_102"></a>多轮对话</h5> 
<ul><li>有且仅有 <code>&lt;|user|&gt;</code>、<code>&lt;|assistant|&gt;</code>、<code>&lt;|system|&gt;</code> 三种 role</li></ul> 
<pre><code class="prism language-text">&lt;|system|&gt;
You are ChatGLM3, a large language model trained by Zhipu.AI. Follow the user's instructions carefully. Respond using markdown.
&lt;|user|&gt;
Hello
&lt;|assistant|&gt;
Hello, I'm ChatGLM3. What can I assist you today?
</code></pre> 
<h5><a id="_113"></a>工具调用</h5> 
<pre><code>&lt;|system|&gt;
Answer the following questions as best as you can. You have access to the following tools:
[
    {
        "name": "get_current_weather",
        "description": "Get the current weather in a given location",
        "parameters": {
            "type": "object",
            "properties": {
                "location": {
                    "type": "string",
                    "description": "The city and state, e.g. San Francisco, CA",
                },
                "unit": {"type": "string"},
            },
            "required": ["location"],
        },
    }
]
&lt;|user|&gt;
今天北京的天气怎么样？
&lt;|assistant|&gt;
好的，让我们来查看今天的天气
&lt;|assistant|&gt;get_current_weather
```python
tool_call(location="beijing", unit="celsius")
```
&lt;|observation|&gt;
{"temperature": 22}
&lt;|assistant|&gt;
根据查询结果，今天北京的气温为 22 摄氏度。
</code></pre> 
<h5><a id="_148"></a>代码执行</h5> 
<ul><li>有 <code>&lt;|user|&gt;</code>、<code>&lt;|assistant|&gt;</code>、<code>&lt;|system|&gt;</code>、<code>&lt;|observation|&gt;</code> 四种 role。其中 <code>&lt;|assistant|&gt;</code> 的 metadata 只有 interpreter。</li></ul> 
<pre><code class="prism language-text">&lt;|system|&gt;
你是一位智能AI助手，你叫ChatGLM3，你连接着一台电脑，但请注意不能联网。在使用Python解决任务时，你可以运行代码并得到结果，如果运行结果有错误，你需要尽可能对代码进行改进。你可以处理用户上传到电脑上的文件，文件默认存储路径是/mnt/data/。
&lt;|user|&gt;
#File: /mnt/data/metadata.jsonl
#Size: 35380
#File uploaded
文件中是否存在缺失值或异常值？
&lt;|assistant|&gt;
首先，我将读取您提供的文件，并查看其内容以确定是否存在缺失值或异常值。

我们从加载文件开始：
&lt;|assistant|&gt;interpreter
```python
import json

# Load the uploaded file
data = []
with open("/mnt/data/metadata.jsonl", 'r') as file:
    for line in file:
        data.append(json.loads(line))

# Display the first few records to get a sense of the data
data[:5]
```
&lt;|observation|&gt;
```result
[{'file_name': 'aceinthehole.png',
  'name': 'Ace in the Hole',
  'type': 'survivor',
  'description': 'Lady Luck always seems to be throwing something good your way.'},
 {'file_name': 'adrenaline.png',
  'name': 'Adrenaline',
  'type': 'survivor',
  'description': 'You are fuelled by unexpected energy when on the verge of escape.'},
 {'file_name': 'aftercare.png',
  'name': 'Aftercare',
  'type': 'survivor',
  'description': "Unlocks potential in one's aura reading ability."},
 {'file_name': 'agitation.png',
  'name': 'Agitation',
  'type': 'killer',
  'description': 'You get excited in anticipation of hooking your prey.'},
 {'file_name': 'alert.png',
  'name': 'Alert',
  'type': 'survivor',
  'description': 'Your acute senses are on high alert.'}]
```
&lt;|assistant|&gt;
该文件看起来包含有关某些条目的元数据，每个条目有以下字段：

- `file_name`: 文件名称
- `name`: 名称
- `type`: 类型（例如 "survivor" 或 "killer"）
- `description`: 描述

接下来，我将检查这些字段是否存在缺失值。
&lt;|assistant|&gt;interpreter
```python
# Check for missing values in each column
missing_values = {key: sum(1 for item in data if key not in item) for key in data[0].keys()}

missing_values
```
&lt;|observation|&gt;
```result
{'file_name': 0, 'name': 0, 'type': 0, 'description': 0}
```
&lt;|assistant|&gt;
每个字段都没有缺失值。这意味着每个条目都完整。

接下来，我们可以检查是否存在任何潜在的异常值。这通常需要更深入的分析和对数据的了解，但我可以从一些基本的统计和分布开始进行检查。为了这样做，我们可以查看“type”字段的值分布，看看是否有任何意外的类别。
&lt;|assistant|&gt;interpreter
```python
# Check the distribution of values in the 'type' column
type_distribution = {key: sum(1 for item in data if item['type'] == key) for key in set(item['type'] for item in data)}

type_distribution
```
&lt;|observation|&gt;
```result
{'survivor': 116, 'killer': 103}
```
&lt;|assistant|&gt;
“type”字段有两个值：“survivor”和“killer”。其中，“survivor”有116个条目，而“killer”有103个条目。

从这个初步的检查中，我们没有发现任何明显的异常值。

如果您有任何特定的标准或其他字段需要检查，我可以为您提供更详细的分析。您还希望我检查什么呢？
&lt;|user|&gt;
帮我画一个爱心
&lt;|assistant|&gt;interpreter
```python
import numpy as np
import matplotlib.pyplot as plt

# 爱心形状的参数方程
def heart(t):
    x = 16 * np.sin(t) ** 3
    y = 13 * np.cos(t) - 5 * np.cos(2 * t) - 2 * np.cos(3 * t) - np.cos(4 * t)
    return x, y

t = np.linspace(0, 2 * np.pi, 1000)
x, y = heart(t)

plt.figure(figsize=(6, 6))
plt.plot(x, y, color='red')
plt.axis('equal')
plt.axis('off')
plt.show()
```
&lt;|observation|&gt;
```result
【image】
```
&lt;|assistant|&gt;
这是一个爱心形状。我使用了参数方程来描述这个形状，并使用matplotlib进行了绘制。如果您有任何其他需求或问题，请随时告诉我。
&lt;|user|&gt;  # End
</code></pre> 
<p>在下一篇-【LLM】基于LLM的agent应用（下），将给出代码实践~</p> 
<h2><a id="_272"></a>附：体系</h2> 
<p><img src="https://images2.imgbox.com/74/1b/ZoRYnyn9_o.png" alt="在这里插入图片描述" width="400"></p> 
<h2><a id="Reference_276"></a>Reference</h2> 
<p>[1] <a href="https://mp.weixin.qq.com/s/win-zVjQJe8K2wiU574SaQ" rel="nofollow">当MLG邂逅AI，Copilot模式将成就「Growth Automation」时代</a><br> [2] <a href="https://mp.weixin.qq.com/s/cmBc_9hIIzMQa6P6QAYq_g" rel="nofollow">大模型下半场，关于Agent的几个疑问</a><br> [3] <a href="https://mp.weixin.qq.com/s/5Qmund0hN88qi0X3JzTEfQ" rel="nofollow">LLM-Native产品的变与不变</a><br> [4] <a href="https://mp.weixin.qq.com/s/YI7FX62yRV4-1qA8O3sH4g" rel="nofollow">聊聊我对AI Agents技术的一些看法.小夕</a><br> [5] Agent = LLM+Planning+Feedback+Tool use<br> [6] <a href="https://mp.weixin.qq.com/s/wUuAHsiZJmpCPn_3uvT4Aw" rel="nofollow">ChatGLM团队发布AI Agent能力评测工具AgentBench：GPT-4一骑绝尘，开源模型表现非常糟糕</a><br> [7] <a href="https://mp.weixin.qq.com/s/h6LkRp3xpFfAA3ml6l3olA" rel="nofollow">从 GPTs 聊到 Agent、LLMOps 以及开源的新机会.质朴发言</a><br> [8] chatglm3.0发布，对应的权重，部署代码管上：<br> 模型：https://huggingface.co/THUDM/chatglm3-6b-base<br> 模型：https://huggingface.co/THUDM/chatglm3-6b<br> [9] chatglm 32k版本：https://huggingface.co/THUDM/chatglm3-6b-32k<br> [10] 低成本部署：https://github.com/THUDM/ChatGLM3/blob/main/DEPLOYMENT.md<br> 工具调用：https://github.com/THUDM/ChatGLM3/blob/main/tool_using/README.md<br> github:https://github.com/THUDM/ChatGLM3<br> [11] <a href="https://mp.weixin.qq.com/s/JoTodw9ZWDQ38wYsddINyA" rel="nofollow">智谱AI推出第三代基座大模型</a><br> [12] https://modelscope.cn/models/ZhipuAI/chatglm3-6b/summary<br> [13] <a href="https://baijiahao.baidu.com/s?id=1713134735309899776&amp;wfr=spider&amp;for=pc" rel="nofollow">北大校友“炼丹”分享：OpenAI如何训练千亿级模型？</a><br> [14] 大模型工具调用(function call)原理及实现：https://zhuanlan.zhihu.com/p/663770472<br> [15] <a href="https://mp.weixin.qq.com/s/sncO5gRMisIDxmDJEAeT1g" rel="nofollow">万字解析 AI Agent：如何重构千亿美金市场，掀起软件生产革命？</a><br> [16] <a href="https://mp.weixin.qq.com/s/FQFhSp7CGUXRqRliRG8v3Q" rel="nofollow">Langchain-Chatchat项目：5.1-ChatGLM3-6B工具调用</a><br> [17] <a href="https://mp.weixin.qq.com/s/wUMq5aVGr3LJ5zybHqScGQ" rel="nofollow">智谱ChatGLM3魔搭最佳实践教程</a><br> [18] <a href="https://mp.weixin.qq.com/s/LUXzgzxbs4KNVIuizCenjw" rel="nofollow">ChatGLM3 的工具调用（FunctionCalling）实现原理</a><br> [19] XAgent：地址：🔗 https://github.com/OpenBMB/XAgent<br> 案例展示地址：🔗 https://x-agent.net/<br> 博客地址：🔗 https://blog.x-agent.net<br> [20] <a href="https://sspai.com/post/81986?utm_source=wechat&amp;utm_medium=social" rel="nofollow">Function Call： Chat 应用的插件基石与交互技术的变革黎明</a><br> [21] https://platform.openai.com/docs/guides/function-calling<br> [22] <a href="https://microsoft.github.io/autogen/docs/Examples/AgentChat/" rel="nofollow">Automated Multi Agent Chat</a><br> [23] <a href="https://zhuanlan.zhihu.com/p/662538702" rel="nofollow">从第一性原理看大模型Agent技术</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e31d54ca4d73c9fde32c6c8c09abb041/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">LangChain 3使用Agent访问Wikipedia和llm-math计算狗的平均年龄</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d76d9a3c3bba12afcfe548b9b9445d85/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">java中@RequestParam的用法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>