<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Qt 事件系统 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Qt 事件系统" />
<meta property="og:description" content="Qt 事件系统 分类： QT 2011-08-14 02:05 1529人阅读 评论(1) 收藏 举报 qt events application function system 目录(?)[&#43;]
Qt是事件驱动的, 程序每个动作都是由某个事件所触发。 Qt事件的类型很多，我们可以通过查看Qt的 manual中的Event System 和 QEvent 来获得各个事件的详细信息。
为了完整起见，一份Qt4.6的事件列表附在本文后面。
事件来源 Spontaneous events(自发事件) 从系统得到的消息,比如鼠标按键,键盘按键等。Qt事件循环的时候读取这些事件，转化为QEvent后依次处理 Posted events 有Qt或应用程序产生，放入消息队列QCoreApplication::postEvent() Sent events 由Qt或应用程序产生，不放入队列，直接被派发和处理QCoreApplication::sendEvent() 比如考虑重绘事件处理函数 paintEvent()，3种事件都能使得该函数被调用：
当窗口被其他窗口覆盖后，再次重新显示时，系统将产生 spontaneous 事件来请求重绘当我们调用 update() 时，产生的是 Posted 事件当我们调用 repaint() 时，产生的是 Sent 事件 事件派发 事件循环 while (!exit_was_called) { while (!posted_event_queue_is_empty) { process_next_posted_event(); } while (!spontaneous_event_queue_is_empty) { process_next_spontaneous_event(); } while (!posted_event_queue_is_empty) { process_next_posted_event(); } } 先处理Qt事件队列中的事件，直至为空再处理系统消息队列中的消息，直至为空在处理系统消息的时候会产生新的Qt事件，需要对其再次进行处理 不通过事件循环 sendEvent的事件派发不通过事件循环。QApplication::sendEvent()是通过调用QApplication::notify()，直接进入了事件的派发和处理环节，是同步的。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/f51caa139fe93e2db00b15ce5f2ee4d1/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2014-09-17T02:06:44+08:00" />
<meta property="article:modified_time" content="2014-09-17T02:06:44+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Qt 事件系统</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div class="article_title" style="margin:5px 0px; font-size:20px; line-height:30px; font-family:'Microsoft YaHei'"> 
 <span class="ico ico_type_Original" style="display:inline-block; width:19px; height:19px; margin:0px 2px 0px 0px; vertical-align:middle"></span>  
 <h2 style="margin:0px; padding:0px; display:inline; font-weight:normal; font-size:20px; vertical-align:middle"> <span class="link_title"><a target="_blank" href="http://blog.csdn.net/zerokkqq/article/details/6685389" style="color:rgb(0,0,0); text-decoration:none" rel="noopener noreferrer">Qt 事件系统</a></span></h2> 
</div> 
<div class="article_manage" style="padding:5px 0px; color:rgb(153,153,153); line-height:24px; font-family:Arial; text-align:right"> 
 <span class="link_categories" style="margin:0px 5px; float:left">分类： <a target="_blank" href="http://blog.csdn.net/zerokkqq/article/category/798031" style="color:rgb(51,102,153); text-decoration:none" rel="noopener noreferrer">QT</a></span> 
 <span class="link_postdate" style="margin:0px 5px 0px 0px">2011-08-14 02:05</span>  
 <span class="link_view" title="阅读次数" style="margin:0px 5px; padding:0px 0px 0px 14px">1529人阅读</span>  
 <span class="link_comments" title="评论次数" style="margin:0px 5px; padding:0px 0px 0px 14px"><a target="_blank" href="http://blog.csdn.net/zerokkqq/article/details/6685389#comments" style="color:rgb(51,102,153); text-decoration:none" rel="noopener noreferrer">评论</a>(1)</span>  
 <span class="link_collect" style="margin:0px 5px"><a target="_blank" title="收藏" style="color:rgb(51,102,153)">收藏</a></span>  
 <span class="link_report" style="margin:0px 5px"><a target="_blank" href="http://blog.csdn.net/zerokkqq/article/details/6685389#report" title="举报" style="color:rgb(51,102,153); text-decoration:none" rel="noopener noreferrer">举报</a></span> 
</div> 
<div class="tag2box" style="margin:10px 0px; color:rgb(51,51,51); font-family:Arial,Console,Verdana,'Courier New'"> 
 <a target="_blank" href="http://www.csdn.net/tag/qt" style="color:rgb(51,102,153); text-decoration:none; display:inline-block; padding:4px 10px; line-height:12px; margin-right:10px; border:1px solid rgb(238,238,238); background-color:rgb(238,238,238)" rel="noopener noreferrer">qt</a> 
 <a target="_blank" href="http://www.csdn.net/tag/events" style="color:rgb(51,102,153); text-decoration:none; display:inline-block; padding:4px 10px; line-height:12px; margin-right:10px; border:1px solid rgb(238,238,238); background-color:rgb(238,238,238)" rel="noopener noreferrer">events</a> 
 <a target="_blank" href="http://www.csdn.net/tag/application" style="color:rgb(51,102,153); text-decoration:none; display:inline-block; padding:4px 10px; line-height:12px; margin-right:10px; border:1px solid rgb(238,238,238); background-color:rgb(238,238,238)" rel="noopener noreferrer">application</a> 
 <a target="_blank" href="http://www.csdn.net/tag/function" style="color:rgb(51,102,153); text-decoration:none; display:inline-block; padding:4px 10px; line-height:12px; margin-right:10px; border:1px solid rgb(238,238,238); background-color:rgb(238,238,238)" rel="noopener noreferrer">function</a> 
 <a target="_blank" href="http://www.csdn.net/tag/system" style="color:rgb(51,102,153); text-decoration:none; display:inline-block; padding:4px 10px; line-height:12px; margin-right:10px; border:1px solid rgb(238,238,238); background-color:rgb(238,238,238)" rel="noopener noreferrer">system</a> 
</div> 
<div style="color:rgb(51,51,51); font-family:Arial,Console,Verdana,'Courier New'; clear:both"> 
</div> 
<div style="color:rgb(51,51,51); font-family:Arial,Console,Verdana,'Courier New'; border:1px solid rgb(204,204,204); float:left; min-width:200px; padding:4px 10px; background:rgb(238,238,238)"> 
 <p style="text-align:right; margin-top:0px; margin-bottom:0px"><span style="float:left">目录<a target="_blank" href="http://blog.csdn.net/zerokkqq/article/details/6685389#" title="系统根据文章中H1到H6标签自动生成文章目录" style="color:rgb(51,102,153); text-decoration:none" rel="noopener noreferrer">(?)</a></span><a target="_blank" href="http://blog.csdn.net/zerokkqq/article/details/6685389#" title="展开" style="color:rgb(51,102,153); text-decoration:none" rel="noopener noreferrer">[+]</a></p> 
</div> 
<div style="color:rgb(51,51,51); font-family:Arial,Console,Verdana,'Courier New'; clear:both"> 
</div> 
<div id="article_content" class="article_content" style="margin:20px 0px 0px; font-size:14px; line-height:26px; font-family:Arial; color:rgb(51,51,51)"> 
 <div id="blog_text" class="cnt"> 
  <p class="line874">Qt是事件驱动的, 程序每个动作都是由某个事件所触发。 Qt事件的类型很多，我们可以通过查看Qt的 manual中的Event System 和 QEvent 来获得各个事件的详细信息。</p> 
  <p class="line874">为了完整起见，一份Qt4.6的事件列表附在本文后面。</p> 
  <h3 style="margin:0px; padding:0px 0px 0.3em; border-bottom-width:3px; border-bottom-style:solid; border-bottom-color:maroon"> <a target="_blank" name="t0" style="color:rgb(51,102,153)"></a>事件来源</h3> 
  <ul><li>Spontaneous events(自发事件) 
    <ul><li>从系统得到的消息,比如鼠标按键,键盘按键等。Qt事件循环的时候读取这些事件，转化为QEvent后依次处理</li></ul> </li><li>Posted events 
    <ul><li>有Qt或应用程序产生，放入消息队列</li><li>QCoreApplication::postEvent()</li></ul> </li><li>Sent events 
    <ul><li>由Qt或应用程序产生，不放入队列，直接被派发和处理</li><li>QCoreApplication::sendEvent()</li></ul> </li></ul> 
  <p class="line874">比如考虑重绘事件处理函数 paintEvent()，3种事件都能使得该函数被调用：</p> 
  <ul><li>当窗口被其他窗口覆盖后，再次重新显示时，系统将产生 spontaneous 事件来请求重绘</li><li>当我们调用 update() 时，产生的是 Posted 事件</li><li>当我们调用 repaint() 时，产生的是 Sent 事件</li></ul> 
  <h3 style="margin:0px; padding:0px 0px 0.3em; border-bottom-width:3px; border-bottom-style:solid; border-bottom-color:maroon"> <a target="_blank" name="t1" style="color:rgb(51,102,153)"></a>事件派发</h3> 
  <h4 style="margin:0px; padding:0px 0px 0.3em; border-bottom-width:3px; border-bottom-style:solid; border-bottom-color:maroon"> <a target="_blank" name="t2" style="color:rgb(51,102,153)"></a>事件循环</h4> 
  <div class="highlight cpp"> 
   <div class="codearea" dir="ltr" style="margin:0.5em 0px; padding:0px; border:1pt solid rgb(174,189,204); color:black; background-color:rgb(243,245,247)"> 
    <pre dir="ltr" style="white-space:pre-wrap; word-wrap:break-word; padding:10pt; border:1pt none rgb(192,192,192); margin-top:0px; margin-bottom:0px; background-color:rgb(240,236,230)"><span class="line">    <span style="color:rgb(160,0,0)">while</span> (!exit_was_called) {<!-- --></span>
<span class="line">        <span style="color:rgb(160,0,0)">while</span> (!posted_event_queue_is_empty) {<!-- --></span>
<span class="line">            process_next_posted_event();</span>
<span class="line">        }</span>
<span class="line">        <span style="color:rgb(160,0,0)">while</span> (!spontaneous_event_queue_is_empty) {<!-- --></span>
<span class="line">            process_next_spontaneous_event();</span>
<span class="line">        }</span>
<span class="line">        <span style="color:rgb(160,0,0)">while</span> (!posted_event_queue_is_empty) {<!-- --></span>
<span class="line">            process_next_posted_event();</span>
<span class="line">        }</span>
<span class="line">    }</span></pre> 
   </div> 
  </div> 
  <ul><li>先处理Qt事件队列中的事件，直至为空</li><li>再处理系统消息队列中的消息，直至为空</li><li>在处理系统消息的时候会产生新的Qt事件，需要对其再次进行处理</li></ul> 
  <h4 style="margin:0px; padding:0px 0px 0.3em; border-bottom-width:3px; border-bottom-style:solid; border-bottom-color:maroon"> <a target="_blank" name="t3" style="color:rgb(51,102,153)"></a>不通过事件循环</h4> 
  <p class="line874">sendEvent的事件派发不通过事件循环。QApplication::sendEvent()是通过调用QApplication::notify()，直接进入了事件的派发和处理环节，是同步的。</p> 
  <h4 style="margin:0px; padding:0px 0px 0.3em; border-bottom-width:3px; border-bottom-style:solid; border-bottom-color:maroon"> <a target="_blank" name="t4" style="color:rgb(51,102,153)"></a>sendEvent与postEvent的使用</h4> 
  <ul><li>两个函数都是接受一个 QObject * 和一个 QEvent * 作为参数。</li><li>postEvent 的 event 必须分配在 heep 上。用完后会被Qt自动删除</li><li>sendEvent 的 event 必须分配在 stack 上。</li></ul> 
  <p class="line874">例子(发送X按键事件到mainWin)：</p> 
  <pre style="white-space:pre-wrap; word-wrap:break-word; padding:0.5em; border:1pt solid rgb(192,192,192); background-color:rgb(240,236,230)">QApplication::postEvent(mainWin, new QKeyEvent(QEvent::KeyPress, Key_X, 'X', 0));</pre> 
  <p class="line874"></p> 
  <pre style="white-space:pre-wrap; word-wrap:break-word; padding:0.5em; border:1pt solid rgb(192,192,192); background-color:rgb(240,236,230)">QKeyEvent event(QEvent::KeyPress, Key_X, 'X', 0);
QApplication::sendEvent(mainWin, &amp;event);</pre> 
  <p class="line874"></p> 
  <h4 style="margin:0px; padding:0px 0px 0.3em; border-bottom-width:3px; border-bottom-style:solid; border-bottom-color:maroon"> <a target="_blank" name="t5" style="color:rgb(51,102,153)"></a>notify</h4> 
  <p class="line874">所有的事件都最终通过 notify 派发到相应的对象中。</p> 
  <pre style="white-space:pre-wrap; word-wrap:break-word; padding:0.5em; border:1pt solid rgb(192,192,192); background-color:rgb(240,236,230)">bool QCoreApplication::notify ( QObject * receiver, QEvent * event )</pre> 
  <h3 style="margin:0px; padding:0px 0px 0.3em; border-bottom-width:3px; border-bottom-style:solid; border-bottom-color:maroon"> <a target="_blank" name="t6" style="color:rgb(51,102,153)"></a>事件过滤</h3> 
  <p class="line874">看看notify()调用的内部函数notify_helper()的源码部分:</p> 
  <ul><li>先通过 Applicaton 安装的过滤器</li><li>如果未被过滤，再通过 receiver 安装的过滤器</li><li> <p class="line862" style="margin-top:0.25em; margin-bottom:0.25em">如果仍未被过滤，才调用 receiver-&gt;event() 函数进行派发</p> </li></ul> 
  <div class="highlight cpp"> 
   <div class="codearea" dir="ltr" style="margin:0.5em 0px; padding:0px; border:1pt solid rgb(174,189,204); color:black; background-color:rgb(243,245,247)"> 
    <pre dir="ltr" style="white-space:pre-wrap; word-wrap:break-word; padding:10pt; border:1pt none rgb(192,192,192); margin-top:0px; margin-bottom:0px; background-color:rgb(240,236,230)"><span class="line"><span style="color:rgb(8,0,0)">/*!\internal</span></span>

<span class="line"><span style="color:rgb(8,0,0)">  Helper function called by notify()</span></span>
<span class="line"><span style="color:rgb(8,0,0)"> */</span></span>
<span class="line"><span style="color:rgb(160,0,0)">bool</span> QCoreApplicationPrivate::notify_helper(QObject *receiver, QEvent * event)</span>
<span class="line">{<!-- --></span>
<span class="line">    <span style="color:rgb(8,0,0)">// send to all application event filters</span></span>
<span class="line">    <span style="color:rgb(160,0,0)">if</span> (sendThroughApplicationEventFilters(receiver, event))</span>
<span class="line">        <span style="color:rgb(160,0,0)">return</span> <span style="color:rgb(8,8,0)"><strong>true</strong></span>;</span>
<span class="line">    <span style="color:rgb(8,0,0)">// send to all receiver event filters</span></span>
<span class="line">    <span style="color:rgb(160,0,0)">if</span> (sendThroughObjectEventFilters(receiver, event))</span>
<span class="line">        <span style="color:rgb(160,0,0)">return</span> <span style="color:rgb(8,8,0)"><strong>true</strong></span>;</span>
<span class="line">    <span style="color:rgb(8,0,0)">// deliver the event</span></span>
<span class="line">    <span style="color:rgb(160,0,0)">return</span> receiver-&gt;event(event);</span>
<span class="line">}</span></pre> 
   </div> 
  </div> 
  <p class="line862">事件在传递到对象之前(调用obj-&gt;event()函数之前)，要先能通过 Applicaton 和 obj 安装的过滤器，那么过滤器是怎么安装的：</p> 
  <ul><li>首先QObject中有一个类型为QObjectList的成员变量,名字为eventFilters</li><li>当某个QObject安装了事件过滤器之后, 它会将filterObj的指针保存在eventFilters中</li></ul> 
  <p class="line867"></p> 
  <pre style="white-space:pre-wrap; word-wrap:break-word; padding:0.5em; border:1pt solid rgb(192,192,192); background-color:rgb(240,236,230)">monitoredObj-&gt;installEventFilter(filterObj);</pre> 
  <ul><li>在事件到达QObject::event()函数之前，会先查看该对象的eventFilters列表, 如果非空, 就先调用列表中对象的eventFilter()函数.</li></ul> 
  <p class="line867"></p> 
  <pre style="white-space:pre-wrap; word-wrap:break-word; padding:0.5em; border:1pt solid rgb(192,192,192); background-color:rgb(240,236,230)">bool QObject::eventFilter ( QObject * watched, QEvent * event )</pre> 
  <ul><li>事件过滤器函数eventFilter()返回值是bool型 
    <ul><li>如果返回true, 则表示该事件已经被处理完毕, Qt将直接返回, 进行下一事件的处理</li><li>如果返回false, 事件将接着被送往剩下的事件过滤器或是目标对象进行处理</li></ul> </li></ul> 
  <p class="line874">对于 QCoreApplication ，由于也是QObject 派生类，安装过滤器方式与前述相同。</p> 
  <h3 style="margin:0px; padding:0px 0px 0.3em; border-bottom-width:3px; border-bottom-style:solid; border-bottom-color:maroon"> <a target="_blank" name="t7" style="color:rgb(51,102,153)"></a>事件转发</h3> 
  <p class="line874">对于某些类别的事件, 如果在整个事件的派发过程结束后还没有被处理, 那么这个事件将会向上转发给它的父widget, 直到最顶层窗口.</p> 
  <p class="line874">如何判断一个事件是否被处理了呢? (有两个层次)</p> 
  <ul><li>QApplication::notify(), QObject::eventFilter(), QObject::event() 通过返回bool值来表示是否已处理. “真”表示已经处理, “假”表示事件需要继续传递</li><li>另一种是调用QEvent::ignore() 或 QEvent::accept() 对事件进行标识，accept表示事件被处理</li></ul> 
  <p class="line874">为清楚起见，贴一点Qt的源码（来自 QApplication::notify()）:</p> 
  <div class="highlight cpp"> 
   <div dir="ltr" class="codearea" style="margin:0.5em 0px; padding:0px; border:1pt solid rgb(174,189,204); color:black; background-color:rgb(243,245,247)"> 
    <pre dir="ltr" style="white-space:pre-wrap; word-wrap:break-word; padding:10pt; border:1pt none rgb(192,192,192); margin-top:0px; margin-bottom:0px; background-color:rgb(240,236,230)"><span class="line">    <span style="color:rgb(160,0,0)">case</span> QEvent::ToolTip:</span>
<span class="line">    <span style="color:rgb(160,0,0)">case</span> QEvent::WhatsThis:</span>
<span class="line">    <span style="color:rgb(160,0,0)">case</span> QEvent::QueryWhatsThis:</span>
<span class="line">        {<!-- --></span>
<span class="line">            QWidget* w = <span style="color:rgb(160,0,0)">static_cast</span>&lt;QWidget *&gt;(receiver);</span>
<span class="line">            QHelpEvent *help = <span style="color:rgb(160,0,0)">static_cast</span>&lt;QHelpEvent*&gt;(e);</span>
<span class="line">            QPoint relpos = help-&gt;pos();</span>
<span class="line">            <span style="color:rgb(160,0,0)">bool</span> eventAccepted = help-&gt;isAccepted();</span>
<span class="line">            <span style="color:rgb(160,0,0)">while</span> (w) {<!-- --></span>
<span class="line">                QHelpEvent he(help-&gt;type(), relpos, help-&gt;globalPos());</span>
<span class="line">                he.spont = e-&gt;spontaneous();</span>
<span class="line">                res = d-&gt;notify_helper(w, w == receiver ? help : &amp;he);</span>
<span class="line">                e-&gt;spont = <span style="color:rgb(8,8,0)"><strong>false</strong></span>;</span>
<span class="line">                eventAccepted = (w == receiver ? help : &amp;he)-&gt;isAccepted();</span>
<span class="line">                <span style="color:rgb(160,0,0)">if</span> ((res &amp;&amp; eventAccepted) || w-&gt;isWindow())</span>
<span class="line">                    <span style="color:rgb(160,0,0)">break</span>;</span>

<span class="line">                relpos += w-&gt;pos();</span>
<span class="line">                w = w-&gt;parentWidget();</span>
<span class="line">            }</span>
<span class="line">            help-&gt;setAccepted(eventAccepted);</span>
<span class="line">        }</span>
<span class="line">        <span style="color:rgb(160,0,0)">break</span>;</span></pre> 
   </div> 
  </div> 
  <p class="line862">这儿显示了对 WhatsThis 事件的处理：先派发给 w，如果事件被accepted 或已经是顶级窗口，则停止；否则获取w的父对象，继续派发。</p> 
  <h3 style="margin:0px; padding:0px 0px 0.3em; border-bottom-width:3px; border-bottom-style:solid; border-bottom-color:maroon"> <a target="_blank" name="t8" style="color:rgb(51,102,153)"></a>事件处理</h3> 
  <ul><li>重新实现一个特定的事件handler</li></ul> 
  <p class="line874">QObject与QWidget提供了许多特定的事件handlers，分别对应于不同的事件类型。（如paintEvent()对应paint事件）</p> 
  <ul><li>重新实现QObject::event()</li></ul> 
  <p class="line874">event()函数是所有对象事件的入口，QObject和QWidget中缺省的实现是简单地把事件推入特定的事件handlers。</p> 
  <ul><li>在QObject安装上事件过滤器</li></ul> 
  <p class="line874">事件过滤器是一个对象，它接收别的对象的事件，在这些事件到达指定目标之间。</p> 
  <ul><li>在aApp上安装一个事件过滤器，它会监视程序中发送到所有对象的所有事件</li><li>重新实现QApplication:notify(),Qt的事件循环与sendEvent()调用这个函数来分发事件，通过重写它，你可以在别人之前看到事件。</li></ul> 
  <h3 style="margin:0px; padding:0px 0px 0.3em; border-bottom-width:3px; border-bottom-style:solid; border-bottom-color:maroon"> <a target="_blank" name="t9" style="color:rgb(51,102,153)"></a>事件列表</h3> 
  <p class="line874">Qt4.6的事件列表：</p> 
  <ul><li>QAccessibleEvent</li><li>QActionEvent</li><li>QChildEvent</li><li>QCloseEvent</li><li>QCustomEvent</li><li>QDragLeaveEvent</li><li>QDropEvent 
    <ul><li>QDragMoveEvent 
      <ul><li>QDragEnterEvent</li></ul> </li></ul> </li><li>QDynamicPropertyChangeEvent</li><li>QFileOpenEvent</li><li>QFocusEvent</li><li>QGestureEvent</li><li>QGraphicsSceneEvent 
    <ul><li>QGraphicsSceneContextMenuEvent</li><li>QGraphicsSceneDragDropEvent</li><li>QGraphicsSceneHelpEvent</li><li>QGraphicsSceneHoverEvent</li><li>QGraphicsSceneMouseEvent</li><li>QGraphicsSceneMoveEvent</li><li>QGraphicsSceneResizeEvent</li><li>QGraphicsSceneWheelEvent.</li></ul> </li><li>QHelpEvent</li><li>QHideEvent</li><li>QHoverEvent</li><li>QIconDragEvent</li><li>QInputEvent 
    <ul><li>QContextMenuEvent</li><li>QKeyEvent</li><li>QMouseEvent</li><li>QTabletEvent</li><li>QTouchEvent</li><li>QWheelEvent</li></ul> </li><li>QInputMethodEvent</li><li>QMoveEvent</li><li>QPaintEvent</li><li>QResizeEvent</li><li>QShortcutEvent</li><li>QShowEvent</li><li>QStatusTipEvent</li><li>QTimerEvent</li><li>QWhatsThisClickedEvent</li><li>QWindowStateChangeEvent</li></ul> 
 </div> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2daabedcda82b8e30f535c9988ec9eea/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">QT对话框中show和exec的区别</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/dcf1a6fa881fa9b9b11628cb471db5b8/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">UK EU 码对照表，USA EURO SIZE码对照表,国外衣服码对照表</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>