<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Angular 8 组件 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Angular 8 组件" />
<meta property="og:description" content="创建一个组件 独立模板 ng g c user-list 内联模板 ng g c user-list -it 显示值 插值法
{{}} 绑定值 从数据流向划分为 3 种：
数据源 -&gt; Template {{expression}}[target]=“expression”bind-target=“expression” Template -&gt; 数据源 (target)=“statement”on-target=“statement” Template &lt;-&gt; 数据源 [(target)]=“expression”bindon-target=“expression” 绑定理解的误区
&lt;button [disabled]=“isUnchanged”&gt;Save
这并不是将 isUnchanged 的值绑定到了 button 的 disabled attribute 上，而是设置在 该 DOM 元素的 property disabled 上。
HTML attribute 与 DOM property 的对比
HTML attribute 用来初始化 DOM propertyattribute 一旦设置则不可修改，property 可以修改attribute 可以理解为初始值，property 理解为当前值attribute 与 property 并不是完全对应的 模板绑定是通过 property 和 event 来工作的，而不是 attribte" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/5af4d8dd8015135c6f2863edda40b15a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-04-29T22:40:25+08:00" />
<meta property="article:modified_time" content="2019-04-29T22:40:25+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Angular 8 组件</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="_0"></a>创建一个组件</h3> 
<ol><li>独立模板</li></ol> 
<pre><code>ng g c user-list
</code></pre> 
<ol start="2"><li>内联模板</li></ol> 
<pre><code>ng g c user-list -it
</code></pre> 
<h3><a id="_14"></a>显示值</h3> 
<p>插值法</p> 
<pre><code>{<!-- -->{}}
</code></pre> 
<h3><a id="_22"></a>绑定值</h3> 
<p>从数据流向划分为 <strong>3</strong> 种：</p> 
<ol><li>数据源 -&gt; Template</li></ol> 
<ul><li>{<!-- -->{expression}}</li><li>[target]=“expression”</li><li>bind-target=“expression”</li></ul> 
<ol start="2"><li>Template -&gt; 数据源</li></ol> 
<ul><li>(target)=“statement”</li><li>on-target=“statement”</li></ul> 
<ol start="3"><li>Template &lt;-&gt; 数据源</li></ol> 
<ul><li>[(target)]=“expression”</li><li>bindon-target=“expression”</li></ul> 
<blockquote> 
 <p>绑定理解的误区</p> 
 <p>&lt;button [disabled]=“isUnchanged”&gt;Save</p> 
 <p>这并不是将 isUnchanged 的值绑定到了 button 的 disabled attribute 上，而是设置在 该 DOM 元素的 property disabled 上。</p> 
</blockquote> 
<blockquote> 
 <p>HTML attribute 与 DOM property 的对比</p> 
 <ol><li>HTML attribute 用来初始化 DOM property</li><li>attribute 一旦设置则不可修改，property 可以修改</li><li>attribute 可以理解为初始值，property 理解为当前值</li><li>attribute 与 property 并不是完全对应的</li></ol> 
</blockquote> 
<p><code>模板绑定是通过 property 和 event 来工作的，而不是 attribte</code></p> 
<h3><a id="_57"></a>绑定目标</h3> 
<p>绑定的目标可以是 property、event、property+event(双向)</p> 
<blockquote> 
 <p><a rel="nofollow">绑定目标汇总表</a></p> 
</blockquote> 
<h4><a id="property_63"></a>属性绑定（property）</h4> 
<ol><li> <p><code>[property]</code> 形式<br> &lt;img [src]=“url”&gt;</p> </li><li> <p><code>bind-property</code> 形式<br> </p> </li></ol> 
<blockquote> 
 <p>不应该绑定一个会修改其他任何值的表达式（属性、函数），这可能会导致意料之外的问题</p> 
</blockquote> 
<blockquote> 
 <p>[hero]=“currentHero” 与 hero=“currentHero” 是不同的</p> 
 <ul><li>[hero]= 将 currentHero 表达式 绑定到 hero property</li><li>hero= 将 currentHero 字面值 赋予 hero attribute</li></ul> 
</blockquote> 
<blockquote> 
 <p>在绑定字符串类型值的时候 src="{<!-- -->{url}}" 等价于 [src]=“url”</p> 
</blockquote> 
<h4><a id="attribute__80"></a>attribute 绑定</h4> 
<p>也写特殊的元素的 DOM 中并没有 property 可供绑定，例如 </p> 
<p>元素 td 只有 colspan attribute，而没有其对应的 property，这时候就只能使用 attribute bind。</p> 
<p>使用 <code>attr.</code> 绑定 attribute，例如：</p> 
<pre><code>&lt;td [attr.colspan]="1 + 1"&gt;&lt;/td&gt;
</code></pre> 
<h4><a id="css__92"></a>css 绑定</h4> 
<ol><li>指定类名</li></ol> 
<p>[class.myClass]=“expression”，表达式为真，添加类，反之移除。</p> 
<ol start="2"><li>覆盖 attribute</li></ol> 
<p>[class]=“expression” 表达式应该返回一个包含类名的字符串。</p> 
<ol start="3"><li>NgClass</li></ol> 
<p>[ngClass]="{ ‘myClass1’: true, ‘myClass2’: isClass2 }"</p> 
<h4><a id="style__106"></a>style 绑定</h4> 
<ol><li>stye.style-property</li></ol> 
<p>&lt;span [style.color]=“fontColor”&gt;字体颜色</p> 
<ol start="2"><li>NgStyle</li></ol> 
<p>[ngStyle]="{ ‘font-color’: ‘#333’, ‘font-weight’: ‘700’ }"</p> 
<h3><a id="event__116"></a>event 绑定</h3> 
<ol><li>(event)</li></ol> 
<p>&lt;button (click)=“onClick()”&gt;click</p> 
<ol start="2"><li>on-event</li></ol> 
<p>&lt;button (click)=“onClick()”&gt;click</p> 
<h4><a id="event_126"></a>$event</h4> 
<p>通常，在 angular 中，通过 <code>$event事件对象</code> 传递事件信息 ，例如这样：</p> 
<pre><code>&lt;input [value]="name" (input)="name=$event.target.value"&gt;
</code></pre> 
<p>这其实就相当于一个 <code>双向绑定</code> 啦。</p> 
<h4><a id="EventEmitter_136"></a>EventEmitter</h4> 
<p>通过 EventEmitter 可以自定义事件，例如：</p> 
<p>假设我们有一个对话框组件，他有 ok 和 cancel 两个按钮：</p> 
<p>app-dialog</p> 
<pre><code>// html...

&lt;button (click)="ok()"&gt;&lt;/button&gt;
&lt;button (click)="cancel()"&gt;&lt;/button&gt;

// ts...
@Output('onConfirm') confirmEvent = new EventEmitter&lt;any&gt;();
@Output('onCancel') cancelEvent = new EventEmitter&lt;any&gt;();

public ok():void {
  this.confirmEvent.emit("确认");
}

public cancel():void {
  this.cancelEvent.emit("取消");
}
</code></pre> 
<p>调用方</p> 
<pre><code>&lt;app-dialog (onConfirm)="func1($event)" (onCancel)="func2($event)"&gt;&lt;/app-dialog&gt;
</code></pre> 
<blockquote> 
 <p>$event 就是 emit 传递过来的值</p> 
</blockquote> 
<h3><a id="_171"></a>双向绑定</h3> 
<p>使用 <code>ngModel</code> 指令需要 <code>FormsModule</code>，所以需要提前将 FormsModule 添加到 imports 当中。</p> 
<p>双向绑定就是 属性绑定与事件绑定 同时修饰同一个 property，至少 bey 是这么理解的。</p> 
<p>假设我们有一个组件，他接受一个叫做 value 的 property，并且对外提供了一个 value 的 change 事件，那么可以这么写到：</p> 
<pre><code>&lt;app-value [value]="myvalue" (onValueChange)="myvalue=$event"&gt;
</code></pre> 
<p>angular 觉得这样写挺麻烦的，于是搞了一个 <code>语法糖</code>，结果语句就变成了这样：</p> 
<pre><code>&lt;app-value [(value)]="myvalue"&gt;
</code></pre> 
<h3><a id="_189"></a>指令</h3> 
<p>指令分为两种： <strong>属性型指令</strong> 和 <strong>结构型指令</strong>。</p> 
<h4><a id="_192"></a>内置属性型指令</h4> 
<p>属性型指令一般用来处理 property、attribute、event。例如：NgClass、NgStyle、NgModel。</p> 
<blockquote> 
 <p>ngModel 指令通过自己的输入属性 ngModel 和输出属性 ngModelChange 实现双向绑定，简化之后的 <code>语法糖</code> 就是 [(ngModel)]。</p> 
</blockquote> 
<h4><a id="_197"></a>内置结构型指令</h4> 
<p>结构型指令通常会改变 DOM 结构；例如 NgIf、NgSwitch、NgForOf</p> 
<blockquote> 
 <p>*ngIf 与 [style.hidden] 是不同的，这与 Vue 的 v-if 与 v-show 类似。*ngIf 会从 DOM 移除元素，而 [style.hidden] 仅仅隐藏元素。</p> 
</blockquote> 
<p><strong>1. 微语法</strong></p> 
<p>模板输入变量</p> 
<p>*ngFor=“let hero of heroes” [hero]=“hero”，let 关键字创建了一个叫做 hero 的 <strong>模板输入变量</strong>。他的作用域包括宿主元素和其子元素。</p> 
<p>*<em>2. <em>ngFor 索引</em></em></p> 
<p>*ngFor=“let hero of heroes; let i=index”</p> 
<p>*<em>3. <em>ngFor trackBy</em></em></p> 
<p>trackBy 用来告诉 *ngFor 如何避免不应该的性能消耗（避免重复的渲染没有变化的项）</p> 
<p>使用 trackBy 需要告诉他需要追踪的值，例如：</p> 
<pre><code>&lt;div *ngFor="let hero of heroes; trackBy: trackByHeroes"&gt;
  ({<!-- -->{hero.id}}) {<!-- -->{hero.name}}
&lt;/div&gt;

//...

trackByHeroes(index: number, hero: Hero): number { return hero.id; }
</code></pre> 
<p>只要 id 没有发生变化，DOM 就不会重复劳动。</p> 
<p><strong>4. NgSwitch</strong></p> 
<p>实际上 NgSwitch 包括 3 个指令：</p> 
<ul><li>NgSwitch</li><li>NgSwitchCase</li><li>NgSwitchDefault</li></ul> 
<p>用法：</p> 
<pre><code>&lt;div [ngSwitch]="currentHero.emotion"&gt;
  &lt;app-happy-hero    *ngSwitchCase="'happy'"    [hero]="currentHero"&gt;&lt;/app-happy-hero&gt;
  &lt;app-sad-hero      *ngSwitchCase="'sad'"      [hero]="currentHero"&gt;&lt;/app-sad-hero&gt;
  &lt;app-confused-hero *ngSwitchCase="'confused'" [hero]="currentHero"&gt;&lt;/app-confused-hero&gt;
  &lt;app-unknown-hero  *ngSwitchDefault           [hero]="currentHero"&gt;&lt;/app-unknown-hero&gt;
&lt;/div&gt;
</code></pre> 
<p>NgSwitch 是一个 属性指令，他只修改了行为，没有修改结构，所以不需要 *****</p> 
<p><strong>5. 模板引用变量</strong></p> 
<p>语法：</p> 
<pre><code>#var
或
ref-var
</code></pre> 
<p>模板引用变量通常用来引用模板中的某个 <code>DOM</code> 或 <code>Angular组件</code> 或 <code>指令</code> 或 <code>Web Component</code>。</p> 
<blockquote> 
 <p>模板引用变量的作用域是本模板全局。</p> 
</blockquote> 
<ol><li>引用 input 元素</li></ol> 
<pre><code>&lt;input #phone placeholder="phone number"&gt;
</code></pre> 
<ol start="2"><li>引用 ngForm 指令</li></ol> 
<pre><code>&lt;form (ngSubmit)="onSubmit(heroForm)" #heroForm="ngForm"&gt;
  &lt;div class="form-group"&gt;
    &lt;label for="name"&gt;Name
      &lt;input class="form-control" name="name" required [(ngModel)]="hero.name"&gt;
    &lt;/label&gt;
  &lt;/div&gt;
  &lt;button type="submit" [disabled]="!heroForm.form.valid"&gt;Submit&lt;/button&gt;
&lt;/form&gt;
&lt;div [hidden]="!heroForm.form.valid"&gt;
  {<!-- -->{submitMessage}}
&lt;/div&gt;
</code></pre> 
<table><thead><tr><th>对比</th><th>模板引用变量</th><th>模板输入变量</th></tr></thead><tbody><tr><td>声明方式</td><td>#var/ref-var</td><td>let var</td></tr><tr><td>作用域</td><td>整个模板</td><td>宿主、子元素</td></tr></tbody></table> 
<h3><a id="_285"></a>输入输出属性</h3> 
<p><strong>1. 输入属性</strong></p> 
<p>带有 <code>@Input</code> 装饰器的 <strong>可设置属性</strong>，一般用于 <strong>属性绑定</strong>。</p> 
<p>@Input(‘width’)，本组件接受一个叫做 width 的属性绑定。例如： <code>&lt;app-component [width]="width"&gt;&lt;/app-component&gt;</code></p> 
<p><strong>2. 输出属性</strong></p> 
<p>带有 <code>@Output</code> 装饰器的 <strong>可观察对象</strong> 属性，一般用于 <strong>输出事件</strong>。</p> 
<p>@Output(‘onClick’) clicks = new EventEmitter();</p> 
<p>对外提供一个可供绑定的名为 <code>onClick</code> 的事件，该事件的参数是一个 <code>string</code>。</p> 
<h3><a id="_301"></a>模板表达式操作符</h3> 
<p><strong>1. 管道操作符(|)</strong></p> 
<p>管道是一个函数，适合在模板表达式中，处理包括：数据显示格式、过滤、排序这样的操作；该函数接受一个输入值，返回结果。</p> 
<p>一般用法</p> 
<pre><code>&lt;div&gt;Hello {<!-- -->{world | uppercase}}&lt;/div&gt;
</code></pre> 
<p>管道函数可以是连续的使用：</p> 
<pre><code>&lt;div&gt;Hello {<!-- -->{wORld | lowercase | uppercase}}&lt;/div&gt;
</code></pre> 
<p>传参：</p> 
<pre><code>&lt;div&gt;Birthdate: {<!-- -->{currentHero?.birthdate | date:'longDate'}}&lt;/div&gt;
</code></pre> 
<p><strong>2. 安全导航操作符(?.)</strong></p> 
<p>观看该案例：</p> 
<pre><code>&lt;span&gt;{<!-- -->{person.name}}&lt;/span&gt;
</code></pre> 
<p>当 person 为 undefined 时，该代码会报错。修改为如下后不会报错：</p> 
<pre><code>&lt;span&gt;{<!-- -->{person?.name}}&lt;/span&gt;
</code></pre> 
<p><strong>3. 非空断言操作符(!)</strong></p> 
<p><code>{<!-- -->{person!.name}}</code> 只有在开启了 TypeScript 严格空值检查时，才会用到。</p> 
<h3><a id="_any_341"></a>类型转换函数 $any</h3> 
<p>当表达式无法检测出某个对象包含指定的字段（属性）时，可以使用 $any 让其不进行 TypeScript 的类型编译。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ec5ddeb6b9f8fc2c823389ad01d78892/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">移动端解决软键盘弹出时底部fixed定位被顶上去的问题（vue和jQuery）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/847278f97bbc6c64fba35808b403fcaf/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Windows 下VsCode 使用Bsah终端</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>