<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>递归的实践——反转链表 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="递归的实践——反转链表" />
<meta property="og:description" content="一、递归的思想 1、确定递归函数的功能：必须确定该函数是做什么的，这也是写程序的第一步。
2、寻找零号问题（Base case）：即找出递归结束的条件。找到最终的那个问题后，它能够直接给出结果，不必再往下走了。
3、拆解，找出函数的等价关系式：每一层的问题都应该比上一层的小，不断缩小问题的 size，才能从大到小到 base case；
二、题目 反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。
说明:
1 ≤ m ≤ n ≤ 链表长度。
示例:
输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4
输出: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL
三、思路分析 为了方便说明一个问题，这里以链表1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;NULL, m = 3, n = 5为例进行分析如何用递归思想求解该题目。
在这里head指向的结点1，不用关注其后的所有结点时如何将m=3与n=5之间的部分反转的，它只需要知道反转后的结果就可以。也就是说，在这里递推公式reverseBetween的含义是：将拿到的链表反转，然后返回反转后的链表的头结点。
这样就可以初步写出如下的代码：
ListNode* reverseBetween(ListNode* head, int m, int n) { ListNode* between = reverseBetween(head-&gt;next, m-1,n-1); } 接着要做的就是，将递推公式reverseBetween返回的结果，挂在head之后，即head.next=between。
这时，代码可以进一步完善，如下所示：
ListNode* reverseBetween(ListNode* head, int m, int n) { ListNode* between = reverseBetween(head-&gt;next, m-1,n-1); head-&gt;next = between; return head; } 递推公式的部分已经完成了，接着要明确的就是递归终止条件。在这里原问题是反转链表：1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;NULL, m = 3, n = 5之间的部分。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/12e260cfb89206bca6cd7c1f512e009f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-07-08T20:03:37+08:00" />
<meta property="article:modified_time" content="2022-07-08T20:03:37+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">递归的实践——反转链表</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h4>一、递归的思想</h4> 
<p>1、确定递归函数的功能：必须确定该函数是做什么的，这也是写程序的第一步。</p> 
<p>2、寻找零号问题（Base case）：即找出递归结束的条件。找到最终的那个问题后，它能够直接给出结果，不必再往下走了。</p> 
<p>3、拆解，找出函数的等价关系式：每一层的问题都应该比上一层的小，不断缩小问题的 size，才能从大到小到 base case；<br><img alt="" height="705" src="https://images2.imgbox.com/4e/15/jXZOWLeF_o.png" width="1080"></p> 
<p></p> 
<h4>二、题目</h4> 
<p>反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。<br> 说明:<br> 1 ≤ m ≤ n ≤ 链表长度。<br> 示例:<br> 输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4<br> 输出: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL</p> 
<h4>三、思路分析</h4> 
<p>为了方便说明一个问题，这里以链表1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;NULL, m = 3, n = 5为例进行分析如何用递归思想求解该题目。</p> 
<p><img alt="" height="229" src="https://images2.imgbox.com/b2/d0/opxsbgcm_o.png" width="661"></p> 
<p>在这里head指向的结点1，不用关注其后的所有结点时如何将m=3与n=5之间的部分反转的，它只需要知道反转后的结果就可以。也就是说，在这里递推公式reverseBetween的含义是：将拿到的链表反转，然后返回反转后的链表的头结点。</p> 
<p><img alt="" height="186" src="https://images2.imgbox.com/60/33/XVABTeFh_o.png" width="674"></p> 
<p></p> 
<p>这样就可以初步写出如下的代码：</p> 
<pre><code class="language-cpp">ListNode* reverseBetween(ListNode* head, int m, int n) {
    ListNode* between = reverseBetween(head-&gt;next, m-1,n-1);
}</code></pre> 
<p>接着要做的就是，将递推公式reverseBetween返回的结果，挂在head之后，即head.next=between。</p> 
<p><img alt="" height="297" src="https://images2.imgbox.com/e9/ee/ilUqyEQ1_o.png" width="675"></p> 
<p>这时，代码可以进一步完善，如下所示：</p> 
<pre><code class="language-cpp">ListNode* reverseBetween(ListNode* head, int m, int n) {
    ListNode* between = reverseBetween(head-&gt;next, m-1,n-1);
    head-&gt;next = between;
    return head;
}


</code></pre> 
<p>递推公式的部分已经完成了，接着要明确的就是递归终止条件。在这里原问题是反转链表：1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;NULL, m = 3, n = 5之间的部分。</p> 
<p>更小的子问题是反转链表：2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;NULL, m = 2, n = 4之间的部分。</p> 
<p>在进一步是反转链表：3-&gt;4-&gt;5-&gt;6-&gt;NULL, m = 1, n = 3之间的部分。但是，这时这个子问题和上一个子问题还是可以用相同思路求解的同一个子问题吗？</p> 
<p><img alt="" height="345" src="https://images2.imgbox.com/ed/63/vpSCYGbm_o.png" width="694"></p> 
<p>可以 看出，不是！！！</p> 
<p>原因在于对于子问题：2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;NULL, m = 2, n = 4来说，它只需要将其之后的所有结点反转之后的结点挂在自己之后就可以了。但是，对于问题3-&gt;4-&gt;5-&gt;6-&gt;NULL, m = 1, n = 3来说，结点3本身也是需要反转的。</p> 
<p>对于如何用递归思想反转3-&gt;4-&gt;5-&gt;6-&gt;NULL, m = 1, n = 3一会儿再说。到这里，递归终止条件就明了了，即m=1时停止，代码如下：</p> 
<pre><code class="language-cpp">ListNode* reverseBetween(ListNode* head, int m, int n) {
    if (m == 1) {
        return 待补充
    }

    ListNode* between = reverseBetween(head-&gt;next, m-1,n-1);
    head-&gt;next = between;
    return head;
}

</code></pre> 
<p> 接着我们看下如何用递归思想反转3-&gt;4-&gt;5-&gt;6-&gt;NULL, m = 1, n = 3，即如何反转链表的前n个结点。</p> 
<p><img alt="" height="244" src="https://images2.imgbox.com/5a/e6/5XFlsJVe_o.png" width="632"></p> 
<p></p> 
<p>这里，递推公式reverseTopN的含义是反转链表的前n个结点并返回被反转的链表的头结点。因此，其需要的参数有两个，一是待反转的链表的头结点，二是反转前几个结点，即n</p> 
<p>对于链表4-&gt;5-&gt;6-&gt;NULL, n = 2来说，经过递推公式reverseTopN处理之后，结果如下图所示：</p> 
<p><img alt="" height="443" src="https://images2.imgbox.com/04/43/5zarxOUe_o.png" width="846"></p> 
<p>至此，对于反转链表的前n个结点，可以初步写出如下的代码：</p> 
<pre><code class="language-cpp">ListNode* reverseTopN(ListNode* head, int n) {
    ListNode* newHead = reverseTopN(head-&gt;next, n-1);
}</code></pre> 
<p>写过反转链表递归的，我们知道，head指向的结点3也是需要反转的，即head-&gt;next-&gt;next=head。但是，我们发现在完成这一步操作后，结点6没法在和其它结点产生联系了。</p> 
<p><img alt="" height="323" src="https://images2.imgbox.com/d0/4f/YN6Hc7iY_o.png" width="596"></p> 
<p> 这个问题怎么解决呢？我们可以用topNSuccessor这个变量，指向第n个结点之后的结点。</p> 
<p>这时，在反转结点3，即head-&gt;next-&gt;next=head之后，我们可以将topNSuccessor指向的结点挂在head指向的结点之后，即head-&gt;next=topNSuccessor。</p> 
<p><img alt="" height="309" src="https://images2.imgbox.com/c0/74/LwLHb6cl_o.png" width="555"></p> 
<p>head-&gt;next-&gt;next=head</p> 
<p><img alt="" height="322" src="https://images2.imgbox.com/fd/e7/mgfGBCG7_o.png" width="572"></p> 
<p> 最后，反转从位置 m 到 n 的链表的递归实现完整代码如下：</p> 
<pre><code class="language-cpp">
ListNode* reverseBetween(ListNode* head, int m, int n) {
    if (m == 1) {
        return reverseTopN(head, n);
    }

    ListNode* between = reverseBetween(head-&gt;next, m-1,n-1);
    head-&gt;next = between;
    return head;
}

ListNode* topNSuccessor = nullptr;

ListNode* reverseTopN(ListNode* head, int n) {
    if (n == 1) {
        topNSuccessor = head-&gt;next;
        return head;
    }

    ListNode* newHead = reverseTopN(head-&gt;next, n-1);
    head-&gt;next-&gt;next = head;
    head-&gt;next = topNSuccessor;
    return newHead;
}


</code></pre> 
<h4 id="四最后总结">四、最后总结</h4> 
<p>递归的思想相对迭代思想，稍微有点难以理解，处理的技巧是：不要跳进递归，而是利用明确的定义来实现算法逻辑。处理看起来比较困难的问题，可以尝试化整为零，把一些简单的解法进行修改，解决困难的问题</p> 
<p> 参考：<br><a href="https://leetcode.cn/problems/reverse-linked-list-ii/solution/yi-bu-yi-bu-jiao-ni-ru-he-yong-di-gui-si-lowt/" rel="nofollow" title="力扣">力扣</a></p> 
<p> <a href="https://labuladong.github.io/algo/2/18/18/" rel="nofollow" title="递归魔法：反转单链表 :: labuladong的算法小抄">递归魔法：反转单链表 :: labuladong的算法小抄</a></p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8b4d39c02c3fc8af18e140ee677570fd/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Java引用（强引用和弱引用）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1a999de1b1f6e59b009291d6dcd56122/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">微信背后的产品观，确实厉害！</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>