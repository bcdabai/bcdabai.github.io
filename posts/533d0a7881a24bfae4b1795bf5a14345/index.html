<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>基础算法 - 常见算法模板题（最简洁写法）【上】 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="基础算法 - 常见算法模板题（最简洁写法）【上】" />
<meta property="og:description" content="目录
快速排序
第k个数
归并排序
逆序对的数量
二分查找
数的范围
浮点数二分 高精度
高精度加法
高精度减法
高精度乘法（高精度x低精度）
高精度除法
前缀和与差分
前缀和
子矩阵的和
差分
差分矩阵
快速排序 思路：
确认分界点：x=q[(l&#43;r)/2]调整范围，使得在x左边的数小于x，右边的数大于x递归处理左右两端 #include &lt;iostream&gt; using namespace std; const int N = 1000010; int q[N]; void quick_sort(int q[],int l,int r) { if(l&gt;=r) return ; int i=l-1,j=r&#43;1,x=q[l&#43;r&gt;&gt;1]; while(i&lt;j) { do i&#43;&#43;; while(q[i]&lt;x); //碰到大于x的停止 do j--; while(q[j]&gt;x); //碰到小于x的停止 if(i&lt;j) swap(q[i],q[j]); } //最终使得在x左边的数小于x，右边的数大于x quick_sort(q,l,j); //对左区间进行处理 quick_sort(q,j&#43;1,r); } int main() { int n; scanf(&#34;%d&#34;, &amp;n); for (int i = 0; i &lt; n; i &#43;&#43; ) scanf(&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/533d0a7881a24bfae4b1795bf5a14345/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-09-14T17:06:02+08:00" />
<meta property="article:modified_time" content="2022-09-14T17:06:02+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">基础算法 - 常见算法模板题（最简洁写法）【上】</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F-toc" style="margin-left:0px;"><a href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F" rel="nofollow">快速排序</a></p> 
<p id="%E7%AC%ACk%E4%B8%AA%E6%95%B0-toc" style="margin-left:40px;"><a href="#%E7%AC%ACk%E4%B8%AA%E6%95%B0" rel="nofollow">第k个数</a></p> 
<p id="%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F-toc" style="margin-left:0px;"><a href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F" rel="nofollow">归并排序</a></p> 
<p id="%E9%80%86%E5%BA%8F%E5%AF%B9%E7%9A%84%E6%95%B0%E9%87%8F-toc" style="margin-left:40px;"><a href="#%E9%80%86%E5%BA%8F%E5%AF%B9%E7%9A%84%E6%95%B0%E9%87%8F" rel="nofollow">逆序对的数量</a></p> 
<p id="%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE" rel="nofollow">二分查找</a></p> 
<p id="%E6%95%B0%E7%9A%84%E8%8C%83%E5%9B%B4-toc" style="margin-left:40px;"><a href="#%E6%95%B0%E7%9A%84%E8%8C%83%E5%9B%B4" rel="nofollow">数的范围</a></p> 
<p id="%E6%B5%AE%E7%82%B9%E6%95%B0%E4%BA%8C%E5%88%86%C2%A0-toc" style="margin-left:40px;"><a href="#%E6%B5%AE%E7%82%B9%E6%95%B0%E4%BA%8C%E5%88%86%C2%A0" rel="nofollow">浮点数二分 </a></p> 
<p id="%E9%AB%98%E7%B2%BE%E5%BA%A6-toc" style="margin-left:0px;"><a href="#%E9%AB%98%E7%B2%BE%E5%BA%A6" rel="nofollow">高精度</a></p> 
<p id="%E9%AB%98%E7%B2%BE%E5%BA%A6%E5%8A%A0%E6%B3%95-toc" style="margin-left:40px;"><a href="#%E9%AB%98%E7%B2%BE%E5%BA%A6%E5%8A%A0%E6%B3%95" rel="nofollow">高精度加法</a></p> 
<p id="%E9%AB%98%E7%B2%BE%E5%BA%A6%E5%87%8F%E6%B3%95-toc" style="margin-left:40px;"><a href="#%E9%AB%98%E7%B2%BE%E5%BA%A6%E5%87%8F%E6%B3%95" rel="nofollow">高精度减法</a></p> 
<p id="%E9%AB%98%E7%B2%BE%E5%BA%A6%E4%B9%98%E6%B3%95%EF%BC%88%E9%AB%98%E7%B2%BE%E5%BA%A6x%E4%BD%8E%E7%B2%BE%E5%BA%A6%EF%BC%89-toc" style="margin-left:40px;"><a href="#%E9%AB%98%E7%B2%BE%E5%BA%A6%E4%B9%98%E6%B3%95%EF%BC%88%E9%AB%98%E7%B2%BE%E5%BA%A6x%E4%BD%8E%E7%B2%BE%E5%BA%A6%EF%BC%89" rel="nofollow">高精度乘法（高精度x低精度）</a></p> 
<p id="%E9%AB%98%E7%B2%BE%E5%BA%A6%E9%99%A4%E6%B3%95-toc" style="margin-left:40px;"><a href="#%E9%AB%98%E7%B2%BE%E5%BA%A6%E9%99%A4%E6%B3%95" rel="nofollow">高精度除法</a></p> 
<p id="%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86-toc" style="margin-left:0px;"><a href="#%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86" rel="nofollow">前缀和与差分</a></p> 
<p id="%E5%89%8D%E7%BC%80%E5%92%8C-toc" style="margin-left:40px;"><a href="#%E5%89%8D%E7%BC%80%E5%92%8C" rel="nofollow">前缀和</a></p> 
<p id="%E5%AD%90%E7%9F%A9%E9%98%B5%E7%9A%84%E5%92%8C-toc" style="margin-left:40px;"><a href="#%E5%AD%90%E7%9F%A9%E9%98%B5%E7%9A%84%E5%92%8C" rel="nofollow">子矩阵的和</a></p> 
<p id="%E5%B7%AE%E5%88%86-toc" style="margin-left:40px;"><a href="#%E5%B7%AE%E5%88%86" rel="nofollow">差分</a></p> 
<p id="%E5%B7%AE%E5%88%86%E7%9F%A9%E9%98%B5-toc" style="margin-left:40px;"><a href="#%E5%B7%AE%E5%88%86%E7%9F%A9%E9%98%B5" rel="nofollow">差分矩阵</a></p> 
<hr id="hr-toc"> 
<p></p> 
<p></p> 
<h2 id="%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><br> 快速排序</h2> 
<p><img alt="" height="931" src="https://images2.imgbox.com/e8/9d/6MzJA66z_o.png" width="1135"></p> 
<p>思路：</p> 
<ol><li>确认分界点：x=q[(l+r)/2]</li><li>调整范围，使得在x左边的数小于x，右边的数大于x</li><li>递归处理左右两端</li></ol> 
<pre><code class="language-cpp">#include &lt;iostream&gt;

using namespace std;

const int N = 1000010;

int q[N];

void quick_sort(int q[],int l,int r)
{
    if(l&gt;=r) return ;
    
    int i=l-1,j=r+1,x=q[l+r&gt;&gt;1];
    while(i&lt;j)
    {
        do i++; while(q[i]&lt;x);  //碰到大于x的停止
        do j--; while(q[j]&gt;x);  //碰到小于x的停止
        if(i&lt;j) swap(q[i],q[j]);
        
    }   //最终使得在x左边的数小于x，右边的数大于x
    
    quick_sort(q,l,j);  //对左区间进行处理
    quick_sort(q,j+1,r);
}

int main()
{
    int n;
    scanf("%d", &amp;n);

    for (int i = 0; i &lt; n; i ++ ) scanf("%d", &amp;q[i]);

    quick_sort(q, 0, n - 1);

    for (int i = 0; i &lt; n; i ++ ) printf("%d ", q[i]);

    return 0;
}
</code></pre> 
<p></p> 
<p></p> 
<h3 id="%E7%AC%ACk%E4%B8%AA%E6%95%B0">第k个数</h3> 
<p><img alt="" height="752" src="https://images2.imgbox.com/12/31/oRk3X6pH_o.png" width="1163"></p> 
<p></p> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;
int n,a[1000001],k;

void qsort(int a[],int l,int r)
{
    if(l&gt;=r) return ;
	int i=l-1,j=r+1,x=a[l+r&gt;&gt;1];
	while(i&lt;j)
	{
	    do i++; while(a[i]&lt;x);
	    do j--; while(a[j]&gt;x);
	    if(i&lt;j) swap(a[i],a[j]);
	}
	qsort(a,l,j);
	qsort(a,j+1,r);
}
int main()
{
    cin&gt;&gt;n&gt;&gt;k;
    for(int i=0;i&lt;n;i++) cin&gt;&gt;a[i];
    qsort(a,0,n-1);
    cout&lt;&lt;a[k-1]&lt;&lt;" ";
}</code></pre> 
<p></p> 
<h2 id="%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F">归并排序</h2> 
<p><img alt="" height="861" src="https://images2.imgbox.com/13/b3/HVqAStmB_o.png" width="834"></p> 
<p></p> 
<p><img alt="" src="https://images2.imgbox.com/7b/6b/gRPvajgT_o.jpg"></p> 
<p> 思路：</p> 
<ol><li>递归均分如图区间</li><li>对每层区间数值按照从小到大顺序存入tmp（可能是奇数无法均分，需要将剩余直接着存入）</li><li> 将该层tmp中排好序的数值放入原来的q中</li><li>回溯到上一层，重复2,3操作，直到最顶层的left&gt;=right，排序完成</li></ol> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;
const int N = 1000010;
int n;
int q[N], tmp[N];

void merge_sort(int q[], int l, int r)
{
	if (l &gt;= r) return;
	int mid = l + r &gt;&gt; 1;
	merge_sort(q, l, mid), merge_sort(q, mid + 1, r);//递归均分区间
	
	int k = 0, i = l, j = mid + 1;
	while (i &lt;= mid &amp;&amp; j &lt;= r)
		if (q[i] &lt;= q[j]) tmp[k++] = q[i++];//按照从小到大顺序存入tmp
		else tmp[k++] = q[j++];
		
	while (i &lt;= mid) tmp[k++] = q[i++];     //将剩余的接着存入
	while (j &lt;= r) tmp[k++] = q[j++];

	for (i = l, j = 0; i &lt;= r; i++, j++) q[i] = tmp[j];//把排好的数放回q
}
int main()
{
	scanf("%d", &amp;n);
	for (int i = 0; i &lt; n; i++) scanf("%d", &amp;q[i]);

	merge_sort(q, 0, n - 1);

	for (int i = 0; i &lt; n; i++) printf("%d ", q[i]);
	
	return 0;
}</code></pre> 
<p></p> 
<p></p> 
<h3 id="%E9%80%86%E5%BA%8F%E5%AF%B9%E7%9A%84%E6%95%B0%E9%87%8F">逆序对的数量</h3> 
<p><img alt="" height="860" src="https://images2.imgbox.com/64/10/HJnqMnLd_o.png" width="1200"></p> 
<p></p> 
<p><img alt="" height="219" src="https://images2.imgbox.com/e8/a0/CEZ8K19g_o.png" width="655"></p> 
<p>- 归并排序合并过程中计算逆序对数量<br> - 若 a[i] &gt; a[j]，则a[i] 和它后面的元素都大于 a[j]，a[i] 构成逆序对数量：res += mid - i + 1; </p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;

using namespace std;

typedef long long LL;

const int N = 1e5 + 10;

int a[N], tmp[N];

LL merge_sort(int q[],int l,int r)
{
    if(l&gt;=r) return 0;
    int mid =l+r &gt;&gt;1;
    LL res=merge_sort(q,l,mid)+merge_sort(q,mid+1,r);
    
    int k=0,i=l,j=mid+1;
    while(i&lt;=mid &amp;&amp; j&lt;=r)
    {
        if(q[i]&lt;=q[j]) tmp[k++]=q[i++];
        else
        {
            res+=mid-i+1;
            tmp[k++]=q[j++];
        }
    }
    while(i&lt;=mid) tmp[k++]=q[i++];
    while(j&lt;=r) tmp[k++]=q[j++];
    
    for(i=l,j=0;i&lt;=r;i++,j++) q[i]=tmp[j];
    return res;
}

int main()
{
    int n;
    scanf("%d", &amp;n);
    for (int i = 0; i &lt; n; i ++ ) scanf("%d", &amp;a[i]);

    cout &lt;&lt; merge_sort(a, 0, n - 1) &lt;&lt; endl;

    return 0;
}

</code></pre> 
<p></p> 
<p></p> 
<h2 id="%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE">二分查找</h2> 
<p>二分模板</p> 
<pre><code class="language-cpp">//区间[l，r]被划分成[l,mid]和[mid + 1，r]时使用:
int bsearch_1(int 1, int r)
{
	while (l &lt; r) 
	{
		int mid = l + r &gt;&gt; 1;
		if (check(mid)) r = mid; 	//判断mid是否满足性质
		else l = mid + 1;
	}
	return l;
}
 
//区间[l,r]被划分成[l，mid - 1]和[mid, r]时使用:
int bsearch_2(int l, int r)
{
	while (l &lt; r) 
	{
		int mid = l + r + 1 &gt;&gt; 1;
		if (check(mid)) l = mid; 
		else r = mid - 1;
	}
	return l;
}
 </code></pre> 
<p>记忆口诀：有减必有加</p> 
<p></p> 
<p></p> 
<h3 id="%E6%95%B0%E7%9A%84%E8%8C%83%E5%9B%B4">数的范围</h3> 
<p><img alt="" height="1088" src="https://images2.imgbox.com/97/6f/60hc7U3r_o.png" width="968"></p> 
<p> 思路：</p> 
<ol><li>利用二分，保证每次缩小范围时所求值都在范围中</li><li>一个需要找到&gt;=x的第一个数，另一个需要找到&lt;=x的最后一个数</li></ol> 
<pre><code class="language-cpp">​
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
using namespace std;
const int N = 1e5 + 10;
int q[N];

int SL(int l, int r, int x) {
  while (l &lt; r) {
    int mid = l + r &gt;&gt; 1;
    if (q[mid] &gt;= x) r = mid;
    else l = mid + 1 ;
  }
  return l;
}

int SR (int l, int r, int x) {
  while (l &lt; r) {
    int mid = l + r + 1 &gt;&gt; 1;
    if(q[mid] &lt;= x) l = mid;
    else r = mid - 1;
  }
  return r;
}

int main() { int n,m;
    scanf ("%d%d",&amp;n,&amp;m);
    for(int i=0;i&lt;n;++i) scanf ("%d",&amp;q[i]);
    while ( m-- ) {
        int x;
        scanf ("%d",&amp;x);
        int l = SL(0, n - 1, x);//查找左边界 并返回下标l
        if (q[l]!=x) cout &lt;&lt;"-1 -1"&lt;&lt;endl;//如果找不到  返回-1 -1
        else {
            cout &lt;&lt; l &lt;&lt; ' '; //如果找到了  输出左下标
            cout &lt;&lt; SR(0, n - 1, x) &lt;&lt; endl; //输出右下标
        }
    }
    return 0;
}


​</code></pre> 
<p></p> 
<p></p> 
<p></p> 
<h3 id="%E6%B5%AE%E7%82%B9%E6%95%B0%E4%BA%8C%E5%88%86%C2%A0">浮点数二分 </h3> 
<p><img alt="" height="685" src="https://images2.imgbox.com/06/99/15pKkrlw_o.png" width="649"></p> 
<p>思路：</p> 
<p>因为完全不必考虑 m=(l+r)/2;导致精度丢失的问题，所以可以直接缩范围</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/0a/2e/AScJOiZX_o.jpg"></p> 
<p>（借用大佬笔记） </p> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;
int main()
{
    double l=-100000,r=100000;    //数据结果必在其之间，不用思考
    double n,m;
    cin&gt;&gt;n;
    while(r-l&gt;1e-8)    //精确到为1e-6，所以至少要多精确两位
    {
        m=(l+r)/2;
        if(m*m*m&gt;=n) r=m;    //立方根n在mid的左边，缩右边界
        else l=m;
    }
    printf("%.6f",m);
   return 0;
}</code></pre> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<h2 id="%E9%AB%98%E7%B2%BE%E5%BA%A6">高精度</h2> 
<p></p> 
<h3 id="%E9%AB%98%E7%B2%BE%E5%BA%A6%E5%8A%A0%E6%B3%95">高精度加法</h3> 
<p><img alt="" height="530" src="https://images2.imgbox.com/e4/10/pTcZTMbT_o.png" width="447"></p> 
<p>思路：</p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/c7/3b/H8YHaKpo_o.jpg" width="1200"></p> 
<p></p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

const int N = 100010;
int A[N], B[N], C[N];

int Add(int a[], int b[], int c[], int cnt) {

    int t = 0;//t表示进位

    for (int i=1; i&lt;=cnt; i++) {
        t += a[i] + b[i];//进位加上a和b第i位上的数
        c[i] = t % 10;//c的值就是进位的个位数
        t /= 10;//把t的个位数去掉只剩下十位数，即只剩下这个位置的进位
    }
    if (t) c[++cnt] = 1;//如果t==1，表示还有一个进位，要补上

    return cnt;
}

int main() {

    string a, b;
    cin &gt;&gt; a &gt;&gt; b;  


    //A和B倒着放进int数组，因为有进位，倒着放容易处理
    int cnt1 = 0;
    for (int i=a.size()-1; i&gt;=0; i--)
        A[++cnt1] = a[i] - '0';

    int cnt2 = 0;
    for (int i=b.size()-1; i&gt;=0; i--)
        B[++cnt2] = b[i] - '0';

    int tot = Add(A, B, C, max(cnt1, cnt2));

    //因为A和B是倒着放的，所以C也要倒着输出
    for (int i=tot; i&gt;=1; i--)
        cout &lt;&lt; C[i];
}

</code></pre> 
<p></p> 
<p></p> 
<h3 id="%E9%AB%98%E7%B2%BE%E5%BA%A6%E5%87%8F%E6%B3%95">高精度减法</h3> 
<p><img alt="" height="687" src="https://images2.imgbox.com/84/c4/FPEf32Gk_o.png" width="800"></p> 
<p> 模拟手算减法</p> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
#include&lt;string&gt;
using namespace std;
 string a,b;
bool cmp(vector&lt;int&gt;&amp;A,vector&lt;int&gt;&amp;B)
{
    if(A.size()!=B.size()) return A.size()&gt;B.size();
    
    for(int i=A.size()-1;i&gt;=0;i--)
        if(A[i]!=B[i]) return A[i]&gt;B[i];
    
        
    return true;    //A==B
}


vector&lt;int&gt; sub(vector&lt;int&gt;&amp;A,vector&lt;int&gt;&amp;B)
{
    vector&lt;int&gt; C;
    for(int i=0,t=0;i&lt;A.size();i++)
    {
        t=A[i]-t;   //借位
        if(i&lt;B.size()) t-=B[i]; //两数相减
        C.push_back((t+10)%10); //如果t&gt;0,入t;如果t&lt;0,入(t+10)%10
        if(t&lt;0) t=1;
        else t=0;
    }
    
    while(C.size()&gt;1 &amp;&amp; C.back()==0) C.pop_back();
    return C;
}


int main()
{
    vector&lt;int&gt; A,B;
   
    cin&gt;&gt;a&gt;&gt;b;
    for(int i=a.size()-1;i&gt;=0;i--) A.push_back(a[i]-'0');
    for(int i=b.size()-1;i&gt;=0;i--) B.push_back(b[i]-'0');
    
    vector&lt;int&gt; C;
    
    if(cmp(A,B)) C=sub(A,B);
    else C=sub(B,A),cout&lt;&lt;"-";
    
    for(int i=C.size()-1;i&gt;=0;i--) cout&lt;&lt;C[i];
    cout&lt;&lt;endl;
    
    return 0;
}</code></pre> 
<p></p> 
<p></p> 
<h3 id="%E9%AB%98%E7%B2%BE%E5%BA%A6%E4%B9%98%E6%B3%95%EF%BC%88%E9%AB%98%E7%B2%BE%E5%BA%A6x%E4%BD%8E%E7%B2%BE%E5%BA%A6%EF%BC%89">高精度乘法（高精度x低精度）</h3> 
<p><img alt="" height="421" src="https://images2.imgbox.com/7b/09/EcmTv4Rg_o.png" width="432"></p> 
<p></p> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;vector&gt;
using namespace std;

vector&lt;int&gt; mul(vector&lt;int&gt;&amp; A,int b)
{
    vector&lt;int&gt; C;
    int t=0;
    for(int i=0;i&lt;A.size();i++)
    {
        t+=A[i]*b;
        C.push_back(t%10);
        t/=10;
    }
    
    while(t)
    {
        C.push_back(t%10);
        t/=10;
    }
    while(C.size()&gt;1&amp;&amp;C.back()==0) C.pop_back();
    return C;
}

int main()
{
    string a;
    int b;
    cin&gt;&gt;a&gt;&gt;b;
    
    vector&lt;int&gt; A;
    for(int i=a.size()-1;i&gt;=0;i--) A.push_back(a[i]-'0');
   
    vector&lt;int&gt; C=mul(A,b);
    
    for(int i=C.size()-1;i&gt;=0;i--) cout&lt;&lt;C[i];
    return 0;
}</code></pre> 
<p></p> 
<p></p> 
<p></p> 
<h3 id="%E9%AB%98%E7%B2%BE%E5%BA%A6%E9%99%A4%E6%B3%95">高精度除法</h3> 
<p><img alt="" height="405" src="https://images2.imgbox.com/c2/37/wgXIS8Oe_o.png" width="416"></p> 
<p></p> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
using namespace std;


vector&lt;int&gt; div(vector&lt;int&gt;&amp;A,int b,int&amp;r)
{
    vector&lt;int&gt; C;
    for(int i=A.size()-1;i&gt;=0;i--)
    {
        r=r*10+A[i];
        C.push_back(r/b);
        r%=b;
    }
    reverse(C.begin(),C.end());
    while(C.size()&gt;1&amp;&amp; C.back()==0) C.pop_back();
    return C;
}

int main()
{
    string a;
    vector&lt;int&gt; A;
    int B;
    cin&gt;&gt;a&gt;&gt;B;
    for(int i=a.size()-1;i&gt;=0;i--) A.push_back(a[i]-'0');
    
    int r=0;
    auto C=div(A,B,r);
    
    for(int i=C.size()-1;i&gt;=0;i--) cout&lt;&lt;C[i];
    cout&lt;&lt;endl&lt;&lt;r;
    return 0;
}</code></pre> 
<p></p> 
<p></p> 
<p></p> 
<h2 id="%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86">前缀和与差分</h2> 
<p></p> 
<h3 id="%E5%89%8D%E7%BC%80%E5%92%8C">前缀和</h3> 
<p><img alt="" height="754" src="https://images2.imgbox.com/09/db/9O5PBWRW_o.png" width="494"></p> 
<blockquote> 
 <p>思路：</p> 
 <p>给出ai的值时算出前n项和的值</p> 
 <p>只需要 s[r]-s[l-1] 即可求出 l 到 r 之间的值</p> 
</blockquote> 
<blockquote> 
 <p> 技巧：</p> 
 <pre><code class="language-cpp">ios::sync_with_stdio(false);</code></pre> 
 <p>作用:提高cin和cout的速度</p> 
 <p> 副作用：不能使用scanf和printf</p> 
</blockquote> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;
const int N=1e6+10;

int n,m;
int a[N],s[N];

int main()
{
    ios::sync_with_stdio(false);
    
    cin&gt;&gt;n&gt;&gt;m;
    for(int i=1;i&lt;=n;i++)
    {
        cin&gt;&gt;a[i];
        s[i]=s[i-1]+a[i];
    }
    while(m--)
    {
        int l,r;
        cin&gt;&gt;l&gt;&gt;r;
        cout&lt;&lt;s[r]-s[l-1]&lt;&lt;endl;
    }
    return 0;
}</code></pre> 
<p></p> 
<p></p> 
<p></p> 
<h3 id="%E5%AD%90%E7%9F%A9%E9%98%B5%E7%9A%84%E5%92%8C">子矩阵的和</h3> 
<p><img alt="" height="1115" src="https://images2.imgbox.com/67/14/vH9SXANj_o.png" width="1092"></p> 
<p> 思路：</p> 
<p><img alt="" height="359" src="https://images2.imgbox.com/1a/d5/ZbkS8uGd_o.png" width="434"></p> 
<p></p> 
<p>S[i,j]即为所有数的的和为：S[i,j]=S[i,j−1]+S[i−1,j]−S[i−1,j−1]+a[i,j]</p> 
<p> <img alt="" height="125" src="https://images2.imgbox.com/76/a0/cBY9bKoC_o.png" width="493"></p> 
<p></p> 
<p> (x1,y1),(x2,y2)这一子矩阵中的所有数之和为：S[x2,y2]−S[x1−1,y2]−S[x2,y1−1]+S[x1−1,y1−1]</p> 
<p></p> 
<pre><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;

using namespace std;

const int N = 1010;

int n, m, q;
int a[N][N], s[N][N];

int main()
{
    cin&gt;&gt;n&gt;&gt;m&gt;&gt;q;
    for(int i=1;i&lt;=n;i++)
        for(int j=1;j&lt;=m;j++)
        {
            cin&gt;&gt;a[i][j];
            s[i][j]=s[i-1][j]+s[i][j-1]-s[i-1][j-1]+a[i][j];
        }
        
    while(q--)
    {
        int x1,x2,y1,y2;
        cin&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2;
        cout&lt;&lt;s[x2][y2]-s[x1-1][y2]-s[x2][y1-1]+s[x1-1][y1-1]&lt;&lt;endl;
    }
    return 0;
}</code></pre> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<h3 id="%E5%B7%AE%E5%88%86">差分</h3> 
<p><img alt="" height="467" src="https://images2.imgbox.com/4c/18/rQCmrfWl_o.png" width="438"></p> 
<p> 思路：</p> 
<blockquote> 
 <p>首先给定一个原数组a：a[1], a[2], a[3],,,,,, a[n];</p> 
 <p>然后我们构造一个数组b ： b[1] ,b[2] , b[3],,,,,, b[i];</p> 
 <p>使得 a[i] = b[1] + b[2 ]+ b[3] +,,,,,, + b[i]</p> 
 <p></p> 
 <p>a数组是b数组的前缀和数组，比如对b数组的b[i]的修改，会影响到a数组中从a[i]及往后的每一个数。</p> 
 <p>首先让差分b数组中的 b[l] + c ,a数组变成 a[l] + c ,a[l+1] + c,,,,,, a[n] + c;</p> 
 <p>然后我们打个补丁，b[r+1] - c, a数组变成 a[r+1] - c,a[r+2] - c,,,,,,,a[n] - c;</p> 
 <p><img alt="" src="https://images2.imgbox.com/f3/3d/uhd6cHF8_o.png"></p> 
 <p>核心操作：对差分数组b做 b[l] + = c, b[r+1] - = c（时间复杂度为O(1) ）</p> 
 <p> <img alt="" src="https://images2.imgbox.com/1d/9b/1IKkVu6c_o.png"></p> 
 <p></p> 
 <p> a[i]为b[i]前缀和的实现</p> 
 <p>令a[i]=a[i-1]+b[i]; ---&gt; b[i]=a[i]-a[i-1];</p> 
 <p>即：</p> 
 <p>a[0 ]= 0;</p> 
 <p>b[1] = a[1] - a[0];</p> 
 <p>b[2] = a[2] - a[1];</p> 
 <p>b[3] =a [3] - a[2];</p> 
 <p>........</p> 
 <p>b[n] = a[n] - a[n-1];</p> 
</blockquote> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;
const int N = 1e5 + 10;
int a[N], b[N];
int main()
{
    int n, m;
    scanf("%d%d", &amp;n, &amp;m);
    for (int i = 1; i &lt;= n; i++)
    {
        scanf("%d", &amp;a[i]);
        b[i] = a[i] - a[i - 1];      //由前缀和公式，构建差分数组
    }
    int l, r, c;
    while (m--)
    {
        scanf("%d%d%d", &amp;l, &amp;r, &amp;c);
        b[l] += c;     //将序列中[l, r]之间的每个数都加上c
        b[r + 1] -= c;
    }
    for (int i = 1; i &lt;= n; i++)
    {
        a[i] = b[i] + a[i - 1];    //更新a[i],前缀和运算
        printf("%d ", a[i]);
    }
    return 0;
}</code></pre> 
<p></p> 
<p></p> 
<p></p> 
<h3 id="%E5%B7%AE%E5%88%86%E7%9F%A9%E9%98%B5">差分矩阵</h3> 
<p><img alt="" height="830" src="https://images2.imgbox.com/5f/27/puc8d8aK_o.png" width="738"></p> 
<p> 思路：</p> 
<p><strong><code>a[][]</code>数组是<code>b[][]</code>数组的前缀和数组（b[i][j]改变影响a[i][j]之后的所以值）</strong>，那么<code>b[][]</code>是<code>a[][]</code>的差分数组，我们去<strong>构造差分数组： <code>b[i][j]</code></strong>，使得<code>a</code>数组中<code>a[i][j]</code>是<code>b</code>数组左上角<code>(1,1)</code>到右下角<code>(i,j)</code>所包围矩形元素的和</p> 
<blockquote> 
 <p>先看核心操作：<strong><span style="color:#fe2c24;">在范围(x1,y1)到(x2,y2)的方形数组中加c</span></strong></p> 
 <p><strong><code>b[x1][y1] + = c</code>;</strong></p> 
 <p><strong><code>b[x1,][y2+1] - = c</code>;</strong></p> 
 <p><strong><code>b[x2+1][y1] - = c</code>;</strong></p> 
 <p><strong><code>b[x2+1][y2+1] + = c</code>;</strong></p> 
 <p><img alt="在这里插入图片描述" src="https://images2.imgbox.com/94/d2/vmnB4r1i_o.png"></p> 
 <p> （假设有b差分数组）</p> 
</blockquote> 
<p>完成上述操作需要构造差分数组b:</p> 
<pre><code class="language-cpp">  void insert(int x1,int y1,int x2,int y2,int c)
  {     //对b数组执行插入操作，等价于对a数组中的(x1,y1)到(x2,y2)之间的元素都加上了c
      b[x1][y1]+=c;
      b[x2+1][y1]-=c;
      b[x1][y2+1]-=c;
      b[x2+1][y2+1]+=c;
  }

  for(int i=1;i&lt;=n;i++)
  {
      for(int j=1;j&lt;=m;j++)
      {
          insert(i,j,i,j,a[i][j]);    //构建差分数组
      }
  }</code></pre> 
<p>差分这样构建的原因：首先假设a,b都为空数组，也就是全部为0的情况，那么我们也可以说，b数组是a数组的差分数组！因为a[i][j] = b[1][1]+…b[i][j],因为都是0，所有情况满足！在这时a数组其实不为空，我们把a数组中的值看作（0+a[i][j]）那么a数组的值变了，变成了a[i][j],这时如果b数组要想成为a数组的差分数组，值也要变为a[i][j],所以我们把b[i][j]变为a[i][j]，这样就能满足b数组是a数组的差分数组。也就相当于想b数组中插入a[i][j].</p> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
using namespace std;
const int N = 1e3 + 10;
int a[N][N], b[N][N];
void insert(int x1, int y1, int x2, int y2, int c)
{
    b[x1][y1] += c;
    b[x2 + 1][y1] -= c;
    b[x1][y2 + 1] -= c;
    b[x2 + 1][y2 + 1] += c;
}
int main()
{
    int n, m, q;
    cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;
    for (int i = 1; i &lt;= n; i++)
        for (int j = 1; j &lt;= m; j++)
            cin &gt;&gt; a[i][j];
    for (int i = 1; i &lt;= n; i++)
    {
        for (int j = 1; j &lt;= m; j++)
        {
            insert(i, j, i, j, a[i][j]);      //构建差分数组
        }
    }
    while (q--)
    {
        int x1, y1, x2, y2, c;
        cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2 &gt;&gt; c;
        insert(x1, y1, x2, y2, c);
    }
    for (int i = 1; i &lt;= n; i++)
    {
        for (int j = 1; j &lt;= m; j++)
        {
            b[i][j] += b[i - 1][j] + b[i][j - 1] - b[i - 1][j - 1];  //二维前缀和
        }
    }
    for (int i = 1; i &lt;= n; i++)
    {
        for (int j = 1; j &lt;= m; j++)
        {
            printf("%d ", b[i][j]);
        }
        printf("\n");
    }
    return 0;
}
</code></pre> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3c92c8c5dff0493ddd35c9097ff2a8bb/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">linux统计日志文件中IP出现的次数，显示次数最多的前十，grep，cat，sort，uniq，head，cut，awk</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/cf80e6d76fd1ee9181cd3ddbbcb896f9/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">JWT工具类</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>