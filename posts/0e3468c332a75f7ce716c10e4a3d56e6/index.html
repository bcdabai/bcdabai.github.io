<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>计算机网络自顶向下方法 第三章 作业习题答案 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="计算机网络自顶向下方法 第三章 作业习题答案" />
<meta property="og:description" content="https://github.com/jzplp/Computer-Network-A-Top-Down-Approach-Answer
P1
设主机A的telnet会话端口号为x，主机B的telnet会话端口号为y
a. 源端口号：x，目的端口号：23
b. 源端口号：y，目的端口号：23
c. 源端口号：23，目的端口号：x
d. 源端口号：23，目的端口号：y
e. 可能相同
f. 不可能相同
P2
服务器到客户A:
源端口号:80, 目的端口号:26145, 源IP:B, 目的IP:A
服务器到客户C，会话1:
源端口号:80, 目的端口号:7532, 源IP:B, 目的IP:C
服务器到客户C，会话2:
源端口号:80, 目的端口号:26145, 源IP:B, 目的IP:C
P3
01010011&#43;01100110=10111001
10111001&#43;01110100=00101110
反码为 11010001
使用反码对接收方非常方便，只需将所有数据包含校验码加起来，计算和为全1即可。
如果不是全1则说明出现了差错。
1比特的差错肯定可以检查出，2比特的差错存在检测不出的情况。
P4
a. 00111110
b. 10111111
c. 两个字节的最后一位变化: 01011101 01100100
P5
接收方不能完全确认没有比特差错，如P4c题目所示，出现多个差错时存在检测不出的情况
P6
发送方发送序号0的报文，进入等待ACK0状态。接收方收到，并且回复ACK，进入等待状态1。 回复的ACK受损了。此时发送方重传报文0，接收方收到报文0，认为序号不对，回复NAK。 发送方收到NAK，发送方重传报文0，接收方依然认为序号不对，回复NAK。
产生死锁。
P7
因为ACK和确认序号已经可以完整的标识这个分组，而且ACK的缺失会导致重传，因此最终ACK可以确保到达。
P8
与rdt2.2的接收方相同
P9
数据分组发生篡改时：
正在上传…重新上传取消
确认分组发生篡改时：
正在上传…重新上传取消
P10
如果不使用NAK，则协议正如rdt3.0所示。
如果使用NAK，则协议如下：
正在上传…重新上传取消
接收方与rdt2.1接收方相同" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/0e3468c332a75f7ce716c10e4a3d56e6/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-04-21T01:48:40+08:00" />
<meta property="article:modified_time" content="2020-04-21T01:48:40+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">计算机网络自顶向下方法 第三章 作业习题答案</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><a href="https://github.com/jzplp/Computer-Network-A-Top-Down-Approach-Answer">https://github.com/jzplp/Computer-Network-A-Top-Down-Approach-Answer</a></p> 
<ul><li> <p><strong>P1</strong><br> 设主机A的telnet会话端口号为x，主机B的telnet会话端口号为y<br> a. 源端口号：x，目的端口号：23<br> b. 源端口号：y，目的端口号：23<br> c. 源端口号：23，目的端口号：x<br> d. 源端口号：23，目的端口号：y<br> e. 可能相同<br> f. 不可能相同</p> </li><li> <p><strong>P2</strong><br> 服务器到客户A:<br> 源端口号:80, 目的端口号:26145, 源IP:B, 目的IP:A<br> 服务器到客户C，会话1:<br> 源端口号:80, 目的端口号:7532, 源IP:B, 目的IP:C<br> 服务器到客户C，会话2:<br> 源端口号:80, 目的端口号:26145, 源IP:B, 目的IP:C</p> </li><li> <p><strong>P3</strong><br> 01010011+01100110=10111001<br> 10111001+01110100=00101110<br> 反码为 11010001<br> 使用反码对接收方非常方便，只需将所有数据包含校验码加起来，计算和为全1即可。<br> 如果不是全1则说明出现了差错。<br> 1比特的差错肯定可以检查出，2比特的差错存在检测不出的情况。</p> </li><li> <p><strong>P4</strong><br> a. 00111110<br> b. 10111111<br> c. 两个字节的最后一位变化: 01011101 01100100</p> </li><li> <p><strong>P5</strong><br> 接收方不能完全确认没有比特差错，如P4c题目所示，出现多个差错时存在检测不出的情况</p> </li><li> <p><strong>P6</strong><br> 发送方发送序号0的报文，进入等待ACK0状态。接收方收到，并且回复ACK，进入等待状态1。 回复的ACK受损了。此时发送方重传报文0，接收方收到报文0，认为序号不对，回复NAK。 发送方收到NAK，发送方重传报文0，接收方依然认为序号不对，回复NAK。<br> 产生死锁。</p> </li><li> <p><strong>P7</strong><br> 因为ACK和确认序号已经可以完整的标识这个分组，而且ACK的缺失会导致重传，因此最终ACK可以确保到达。</p> </li><li> <p><strong>P8</strong><br> 与rdt2.2的接收方相同</p> </li><li> <p><strong>P9</strong><br> 数据分组发生篡改时：<br><span class="img-upload-box" id="pFvjw69k"><img class="preview" src="https://images2.imgbox.com/7c/91/lgJ0Xv3i_o.png" alt="pic1.png"><span class="info-box"><img class="img-loading" src="https://images2.imgbox.com/47/0e/X9ifGpUQ_o.gif" alt="uploading.4e448015.gif"><span class="operate-box"><span class="upload-msg">正在上传…</span><a class="btn btn-redo">重新上传</a><a class="btn btn-cancle">取消</a></span></span></span><a href="https://github.com/jzplp/Computer-Network-A-Top-Down-Approach-Answer/blob/master/Chapter-3/PA-P9/pic1.png"><img alt="Image text" src="https://images2.imgbox.com/ef/f7/UsJB8UbA_o.png"></a><br> 确认分组发生篡改时：<br><span class="img-upload-box" id="MAxmn96Y"><img class="preview" src="https://images2.imgbox.com/ed/fa/BLALVP86_o.png" alt="pic2.png"><span class="info-box"><img class="img-loading" src="https://images2.imgbox.com/bd/a7/sDyCLnW5_o.gif" alt="uploading.4e448015.gif"><span class="operate-box"><span class="upload-msg">正在上传…</span><a class="btn btn-redo">重新上传</a><a class="btn btn-cancle">取消</a></span></span></span><a href="https://github.com/jzplp/Computer-Network-A-Top-Down-Approach-Answer/blob/master/Chapter-3/PA-P9/pic2.png"><img alt="Image text" src="https://images2.imgbox.com/a2/3f/ndDELqSu_o.png"></a></p> </li><li> <p><strong>P10</strong><br> 如果不使用NAK，则协议正如rdt3.0所示。<br> 如果使用NAK，则协议如下：<br><span class="img-upload-box" id="J6HPUNyn"><img class="preview" src="https://images2.imgbox.com/ba/01/QwTJAIUb_o.png" alt="pic1.png"><span class="info-box"><img class="img-loading" src="https://images2.imgbox.com/c1/ad/WHLwARMe_o.gif" alt="uploading.4e448015.gif"><span class="operate-box"><span class="upload-msg">正在上传…</span><a class="btn btn-redo">重新上传</a><a class="btn btn-cancle">取消</a></span></span></span><a href="https://github.com/jzplp/Computer-Network-A-Top-Down-Approach-Answer/blob/master/Chapter-3/PA-P10/pic1.png"><img alt="Image text" src="https://images2.imgbox.com/5b/6c/081JJ9ct_o.png"></a><br> 接收方与rdt2.1接收方相同</p> </li><li> <p><strong>P11</strong></p> </li></ul> 
<ol><li>在等待来自下层的1中删除<br> 会正常工作。因为上一步状态转换时已经生成了sndpkt</li><li>在等待来自下层的0中删除<br> 在第一次进入时，会工作不正常。此时sndpkt还没有生成，如果接收了一个校验错误的报文，那么无法返回一个分组。</li></ol> 
<ul><li><strong>P12</strong><br> 如果定时器正常，那么协议可以正常运行。<br> 如果定时器过早超时：</li></ul> 
<ol><li>发送1报文。</li><li>首先超时，重传1次。</li><li>收到ACK报文，发送2报文。</li><li>收到上一个ACK报文，重传1次。</li><li>超时，重传2次。</li><li>收到ACK报文，发送3报文。</li><li>收到上一个ACK报文，重传1次。</li><li>收到上一个ACK报文，重传2次。</li><li>超时，重传3次。</li><li>收到ACK报文，发送4报文。<br> ....<br> 对于第n个分组，重传n次。</li></ol> 
<ul><li> <p><strong>P13</strong><br> 无法工作的一个例子： <span class="img-upload-box" id="UoAP4nIb"><img class="preview" src="https://images2.imgbox.com/42/3e/wbsj53SL_o.png" alt="pic1.png"><span class="info-box"><img class="img-loading" src="https://images2.imgbox.com/a3/aa/uWjKUqFw_o.gif" alt="uploading.4e448015.gif"><span class="operate-box"><span class="upload-msg">正在上传…</span><a class="btn btn-redo">重新上传</a><a class="btn btn-cancle">取消</a></span></span></span><a href="https://github.com/jzplp/Computer-Network-A-Top-Down-Approach-Answer/blob/master/Chapter-3/PA-P13/pic1.png"><img alt="Image text" src="https://images2.imgbox.com/86/a9/IgpWdQei_o.png"></a><br> 中间两个报文没有被接收方正确接收就继续发送下面的报文了。</p> </li><li> <p><strong>P14</strong></p> </li></ul> 
<ol><li>不合适。因为发送端如果接收不到数据，无法判定是丢包还是正确接收了。</li><li>不存在丢包的情况下，采用停等协议不适合使用只用NAK的协议。因为发送方必须等待最长的RTT时间，才能确认接收方已经收到。因此相比于ACK协议，时间的花费会更长。<br> 不存在丢包的情况下，如果采用流水线协议，那么发送方发送的报文如果损坏，接收方无法判断其序号，无法发送NAK报文，发送方会认为这个报文已经正确接收。因此发生错误。<br> 如果存在少量丢包的情况下，那么只用NAK的协议就更不如使用ACK的协议了</li></ol> 
<ul><li> <p><strong>P15</strong><br> L/R = 15 * 8000 / 109 = 0.012<br> U = X(L/R) / (RTT + L/R) = 0.9<br> X ~= 2251</p> </li><li> <p><strong>P16</strong><br> 可以增加信道利用率，因为发送方接收到大量的ACK，便认为发送的报文已经被正确接收了，然后继续发送后续报文。<br> 问题：如果发生丢包，损坏等现象，那么接收到的数据是不完整的。</p> </li><li> <p><strong>P17</strong><br><span class="img-upload-box" id="A3jJCbED"><img class="preview" src="https://images2.imgbox.com/08/70/susgSLAW_o.png" alt="pic1.png"><span class="info-box"><img class="img-loading" src="https://images2.imgbox.com/14/a7/6e3it2bF_o.gif" alt="uploading.4e448015.gif"><span class="operate-box"><span class="upload-msg">正在上传…</span><a class="btn btn-redo">重新上传</a><a class="btn btn-cancle">取消</a></span></span></span><a href="https://github.com/jzplp/Computer-Network-A-Top-Down-Approach-Answer/blob/master/Chapter-3/PA-P17/pic1.png"><img alt="Image text" src="https://images2.imgbox.com/76/05/29zfXWth_o.png"></a><br><span class="img-upload-box" id="ntSXEr1r"><img class="preview" src="https://images2.imgbox.com/f2/07/wv5td4ta_o.png" alt="pic2.png"><span class="info-box"><img class="img-loading" src="https://images2.imgbox.com/09/04/y267mc9N_o.gif" alt="uploading.4e448015.gif"><span class="operate-box"><span class="upload-msg">正在上传…</span><a class="btn btn-redo">重新上传</a><a class="btn btn-cancle">取消</a></span></span></span><a href="https://github.com/jzplp/Computer-Network-A-Top-Down-Approach-Answer/blob/master/Chapter-3/PA-P17/pic2.png"><img alt="Image text" src="https://images2.imgbox.com/62/c9/eifFkrjk_o.png"></a></p> </li><li> <p><strong>P18</strong><br> 报文格式:与SR协议相同<br><span class="img-upload-box" id="POhHje3r"><img class="preview" src="https://images2.imgbox.com/42/5c/frrVzV8P_o.png" alt="pic1.png"><span class="info-box"><img class="img-loading" src="https://images2.imgbox.com/64/46/lIwX8Ty2_o.gif" alt="uploading.4e448015.gif"><span class="operate-box"><span class="upload-msg">正在上传…</span><a class="btn btn-redo">重新上传</a><a class="btn btn-cancle">取消</a></span></span></span><a href="https://github.com/jzplp/Computer-Network-A-Top-Down-Approach-Answer/blob/master/Chapter-3/PA-P18/pic1.png"><img alt="Image text" src="https://images2.imgbox.com/14/78/B6zQTIhB_o.png"></a><br><span class="img-upload-box" id="GrsrPAop"><img class="preview" src="https://images2.imgbox.com/d8/15/hx6TJCaX_o.png" alt="pic2.png"><span class="info-box"><img class="img-loading" src="https://images2.imgbox.com/b3/df/gLn5CIwt_o.gif" alt="uploading.4e448015.gif"><span class="operate-box"><span class="upload-msg">正在上传…</span><a class="btn btn-redo">重新上传</a><a class="btn btn-cancle">取消</a></span></span></span><a href="https://github.com/jzplp/Computer-Network-A-Top-Down-Approach-Answer/blob/master/Chapter-3/PA-P18/pic2.png"><img alt="Image text" src="https://images2.imgbox.com/19/11/pKpbWp0c_o.png"></a><br><span class="img-upload-box" id="zQTJX1gx"><img class="preview" src="https://images2.imgbox.com/17/c5/GUA5GHrp_o.png" alt="pic3.png"><span class="info-box"><img class="img-loading" src="https://images2.imgbox.com/5a/8c/zIs8mRm3_o.gif" alt="uploading.4e448015.gif"><span class="operate-box"><span class="upload-msg">正在上传…</span><a class="btn btn-redo">重新上传</a><a class="btn btn-cancle">取消</a></span></span></span><a href="https://github.com/jzplp/Computer-Network-A-Top-Down-Approach-Answer/blob/master/Chapter-3/PA-P18/pic3.png"><img alt="Image text" src="https://images2.imgbox.com/60/16/qLlfzgml_o.png"></a></p> </li><li> <p><strong>P19</strong><br> 报文格式与rdt3.0相比，增加了一个指示ACK报文的来源字段，值为B或C<br><span class="img-upload-box" id="4RIQBbcY"><img class="preview" src="https://images2.imgbox.com/b9/a5/zdjyaqtr_o.png" alt="pic1.png"><span class="info-box"><img class="img-loading" src="https://images2.imgbox.com/ab/45/oSjmdaIV_o.gif" alt="uploading.4e448015.gif"><span class="operate-box"><span class="upload-msg">正在上传…</span><a class="btn btn-redo">重新上传</a><a class="btn btn-cancle">取消</a></span></span></span><a href="https://github.com/jzplp/Computer-Network-A-Top-Down-Approach-Answer/blob/master/Chapter-3/PA-P19/pic1.png"><img alt="Image text" src="https://images2.imgbox.com/83/7e/lZbRs0VA_o.png"></a><br><span class="img-upload-box" id="9N1ZRFjH"><img class="preview" src="https://images2.imgbox.com/d1/ee/YaFKATh6_o.png" alt="pic2.png"><span class="info-box"><img class="img-loading" src="https://images2.imgbox.com/10/89/TzmTDOUj_o.gif" alt="uploading.4e448015.gif"><span class="operate-box"><span class="upload-msg">正在上传…</span><a class="btn btn-redo">重新上传</a><a class="btn btn-cancle">取消</a></span></span></span><a href="https://github.com/jzplp/Computer-Network-A-Top-Down-Approach-Answer/blob/master/Chapter-3/PA-P19/pic2.png"><img alt="Image text" src="https://images2.imgbox.com/94/76/nrVZ3KIi_o.png"></a></p> </li><li> <p><strong>P20</strong><br> 报文格式与rdt3.0相比，增加了一个指示数据报文的来源字段，值为A或B<br><span class="img-upload-box" id="lUvf6pSR"><img class="preview" src="https://images2.imgbox.com/cb/c2/slzp77t1_o.png" alt="pic1.png"><span class="info-box"><img class="img-loading" src="https://images2.imgbox.com/f4/c6/vREben1c_o.gif" alt="uploading.4e448015.gif"><span class="operate-box"><span class="upload-msg">正在上传…</span><a class="btn btn-redo">重新上传</a><a class="btn btn-cancle">取消</a></span></span></span><a href="https://github.com/jzplp/Computer-Network-A-Top-Down-Approach-Answer/blob/master/Chapter-3/PA-P20/pic1.png"><img alt="Image text" src="https://images2.imgbox.com/2d/a4/6wNtXJOV_o.png"></a><br><span class="img-upload-box" id="ZjL1D2Mb"><img class="preview" src="https://images2.imgbox.com/49/ac/s2CGRO32_o.png" alt="pic2.png"><span class="info-box"><img class="img-loading" src="https://images2.imgbox.com/e0/00/CvJe6Too_o.gif" alt="uploading.4e448015.gif"><span class="operate-box"><span class="upload-msg">正在上传…</span><a class="btn btn-redo">重新上传</a><a class="btn btn-cancle">取消</a></span></span></span><a href="https://github.com/jzplp/Computer-Network-A-Top-Down-Approach-Answer/blob/master/Chapter-3/PA-P20/pic2.png"><img alt="Image text" src="https://images2.imgbox.com/92/50/AnoECsOo_o.png"></a></p> </li><li> <p><strong>P21</strong><br><span class="img-upload-box" id="4SPeZa7m"><img class="preview" src="https://images2.imgbox.com/bb/c0/dSwY4kB5_o.png" alt="pic1.png"><span class="info-box"><img class="img-loading" src="https://images2.imgbox.com/77/30/1rJwcjj7_o.gif" alt="uploading.4e448015.gif"><span class="operate-box"><span class="upload-msg">转存失败</span><a class="btn btn-redo">重新上传</a><a class="btn btn-cancle">取消</a></span></span></span><a href="https://github.com/jzplp/Computer-Network-A-Top-Down-Approach-Answer/blob/master/Chapter-3/PA-P21/pic1.png"><img alt="Image text" src="https://images2.imgbox.com/d5/8f/y1kAdSro_o.png"></a><br><span class="img-upload-box" id="3cdKOPLG"><img class="preview" src="https://images2.imgbox.com/a6/c7/cnv4KpoR_o.png" alt="pic2.png"><span class="info-box"><img class="img-loading" src="https://images2.imgbox.com/03/ea/2MYKDtv1_o.gif" alt="uploading.4e448015.gif"><span class="operate-box"><span class="upload-msg">转存失败</span><a class="btn btn-redo">重新上传</a><a class="btn btn-cancle">取消</a></span></span></span><a href="https://github.com/jzplp/Computer-Network-A-Top-Down-Approach-Answer/blob/master/Chapter-3/PA-P21/pic2.png"><img alt="Image text" src="https://images2.imgbox.com/68/e4/Hbl8UeV8_o.png"></a></p> </li><li> <p><strong>P22</strong><br> a.<br> k-4, k-3, k-2, k-1, k, k+1, k+2, k+3<br> k-4, k-3, k-2, k-1的极端情况：<br> 此时发送端发送了k-4, k-3, k-2, k-1的报文，接收方收到，但是ACK报文接收方还没有收到。 k, k+1, k+2, k+3的极端情况：<br> 发送方发送了k, k+1, k+2, k+3报文，接收方还没有收到。<br> b.<br> k-5, k-4, k-3, k-2, k-1<br> k-4, k-3, k-2, k-1, k的极端情况：<br> 发送方发送k-5，接收方收到并且返回ACK(k-5)。发送方收到之前就超时，重发k-5。 发送方收到ACK(k-5)， 发送k-4, k-3, k-2, k-1。<br> 接收方收到重发k-5，返回ACK(k-5)。收到k-4, k-3, k-2, k-1，返回ACK(k-4)，ACK(k-3)，ACK(k-2)，ACK(k-1)</p> </li><li> <p><strong>P23</strong><br> 如果报文在信道中不会重新排序：<br> 对于GBN协议，发送方窗口最大为k-1。<br> 如果窗口为k，就会出现书中图3-27的情况，如果窗口的所有报文的ACK丢失，都被重传，接收方会认为是新报文。<br> 对于SR协议，发送方窗口最大为k/2。<br> 如果大于k-2。就会出现书中图3-27的情况，如果窗口的所有报文的ACK丢失，都被重传。接收方会认为是新报文。</p> </li><li> <p><strong>P24</strong><br> a. 正确<br> 假设窗口为0,1，发送方发送0，1后，接收方回复ACK0,1。但是发送方收到ACK0和1之前，就进行了超时重传，发送0，1。<br> 发送方收到ACK0和1。窗口变为2，3。接收方收到重传的0，1，重新回复ACK0,1。此时发送方收到了ACK0，1，在发送方窗口之外。<br> b. 正确<br> 假设窗口为0,1，发送方发送0，1后，接收方回复ACK0,1。但是发送方收到ACK1之前，就进行了超时重传，发送1。<br> 发送方收到ACK1。窗口变为2，3。接收方收到重传的1，重新回复ACK1。此时发送方收到了ACK1，在发送方窗口之外。<br> c. 正确<br> d. 正确</p> </li><li> <p><strong>P25</strong><br> a. UDP不会对报文进行分片，而TCP会进行分片。<br> b. UDP没有拥塞控制和流量控制，可以自己调整发送速度。</p> </li><li> <p><strong>P26</strong><br> a. 如果序号不重复利用，最多232字节。但是TCP的序号是可以重复利用的。<br> b. 报文数 232 / 536 ~= 8,012,999<br> (232 + 66 * 8,012,999) * 8 / 155 * 10242 ~= 237s</p> </li><li> <p><strong>P27</strong><br> a. 序号 207 源端口号 302 目的端口号 80<br> b. 确认号 207 源端口号 80 目的端口号 302<br> c. 确认号 247<br> d.<br><span class="img-upload-box" id="HnTXmX2V"><img class="preview" src="https://images2.imgbox.com/2c/33/C4mie2Jb_o.png" alt="pic1.png"><span class="info-box"><img class="img-loading" src="https://images2.imgbox.com/6d/57/ofR0BlWL_o.gif" alt="uploading.4e448015.gif"><span class="operate-box"><span class="upload-msg">转存失败</span><a class="btn btn-redo">重新上传</a><a class="btn btn-cancle">取消</a></span></span></span><a href="https://github.com/jzplp/Computer-Network-A-Top-Down-Approach-Answer/blob/master/Chapter-3/PA-P27/pic1.png"><img alt="Image text" src="https://images2.imgbox.com/01/20/7tNhBQ5a_o.png"></a></p> </li><li> <p><strong>P28</strong><br> 发送方维护一个接收窗口来实现流量控制，接收方提供给发送方指示接收方缓存还有多少可用空间。<br> 在实际的运行中，一开始接收方缓存为空，接收窗口很大。发送方发送许多数据。但是接收方读取速度较慢，因此缓存逐渐变满，接收窗口越来越小。<br> 发送方的速率逐渐下降，最后与接收方读取数据的速率相同。</p> </li><li> <p><strong>P29</strong><br> a. 因为使用这种特殊的序号使得服务器不用记忆初始序号，不用为连接保存状态信息。<br> b. 如果攻击者不知道生成cookie的函数，那么就不能成功创建一个全开或者半开连接。<br> c. 是可以使得服务器产生全开连接的。</p> </li><li> <p><strong>P30</strong><br> a. 当初始数据被发送到套接字的速率大时，时延高会导致丢包率过大，从而减小吞吐量。<br> 如果路由器缓存长度增加，速度不变，那么报文在路由器缓存中的时间边长，如果时间超过固定的超时值，那么路由器就会转发不必要的分组副本，从而降低吞吐量。<br> b. 路由器缓存更多的报文，可以出现更少的丢包情况，有助于增加吞吐量。</p> </li><li> <p><strong>P31</strong><br> 我认为书上翻译错误，应该是给出了5个样本之前的初值。</p> </li></ul> 
<table><thead><tr><th> </th><th>初值</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th></tr></thead><tbody><tr><td>SampleRTT</td><td>/</td><td>106</td><td>120</td><td>140</td><td>90</td><td>115</td></tr><tr><td>EstimatedRTT</td><td>100</td><td>100.75</td><td>103.16</td><td>107.77</td><td>105.55</td><td>106.73</td></tr><tr><td>DevRTT</td><td>5</td><td>5.06</td><td>8.00</td><td>14.06</td><td>14.43</td><td>12.89</td></tr><tr><td>TimeoutInterval</td><td>120</td><td>120.99</td><td>135.16</td><td>164.01</td><td>163.27</td><td>158.29</td></tr></tbody></table> 
<ul><li><strong>P32</strong><br> a.<br> EstimatedRTT1 = 0.9 * EstimatedRTT0 + 0.1 * SampleRTT1<br> EstimatedRTT2 = 0.92 * EstimatedRTT0 + 0.1 * 0.9 * SampleRTT1 + 0.1 * SampleRTT2<br> EstimatedRTT3 = 0.93 * EstimatedRTT0 + 0.1 * 0.92 * SampleRTT1 + 0.1 * 0.9 * SampleRTT2 + 0.1 * SampleRTT3<br> EstimatedRTT4 = 0.94 * EstimatedRTT0 + 0.1 * 0.93 * SampleRTT1 + 0.1 * 0.92 * SampleRTT2 + 0.1 * 0.9 * SampleRTT3 + 0.1 * SampleRTT4<br> b.<br><span class="img-upload-box" id="yt51i9X4"><img class="preview" src="https://images2.imgbox.com/58/33/zEslO7GG_o.gif" alt="pic1.gif"><span class="info-box"><img class="img-loading" src="https://images2.imgbox.com/2e/1d/iKVhZgpN_o.gif" alt="uploading.4e448015.gif"><span class="operate-box"><span class="upload-msg">转存失败</span><a class="btn btn-redo">重新上传</a><a class="btn btn-cancle">取消</a></span></span></span><a href="https://github.com/jzplp/Computer-Network-A-Top-Down-Approach-Answer/blob/master/Chapter-3/PA-P32/pic1.gif"><img alt="Image text" src="https://images2.imgbox.com/f9/72/JKOsGoHk_o.gif"></a></li></ul> 
<p>c. 当n趋于无穷时，离n越近的EstimatedRT的影响越大。</p> 
<ul><li> <p><strong>P33</strong><br> TCP估计正常时间的RTT，对于重传报文，可能并不是因为丢失而是单纯超时，如果重传报文发送后初始报文的ACK立即抵达，那么求得的RTT会比真实的RTT小很多。</p> </li><li> <p><strong>P34</strong><br> 两者之差是在网络传送中还未到达的字节数，包括损坏的，丢失的等等。</p> </li><li> <p><strong>P35</strong><br> 假设TCP接收方丢弃失序的报文段的场合：<br> 在生成ACK的时间，y等于LastByteRcvd，当ACK报文传回发送方的时候，因为可能有新的报文到达接收方，所以y &lt;= LastByteRcvd</p> </li><li> <p><strong>P36</strong><br> 如果收到一个冗余ACK旧快速重传，那么两个连续发送的报文，在反序到达时，就会发生重传情况。也就是说协议不允许非序到达报文。<br> 因此这种设计是不良的。</p> </li><li> <p><strong>P37</strong><br> a.<br> GBN协议：发送报文段9次，ACK8次<br> SR协议：发送报文段6次，ACK5次<br> TCP协议：发送报文段6次，ACK5次<br> b. TCP协议时间最短</p> </li><li> <p><strong>P38</strong><br> 正确。</p> </li><li> <p><strong>P39</strong><br> 对于图3-46b，λout不能超过R/3。如果λ'in超过R/2，因为超过网络所能提供的速率，因此必然会发生更严重的丢包现象，因此λout反而会降低。<br> 对于图3-46c，如果假定平均转发两次是固定值，那么如果λ'in超过R/2，λout能超过R/4。但是在实际情况中，如果λ'in超过R/2，丢包现象会增加，因此平均转发会超过两次，λout会小于R/4。</p> </li><li> <p><strong>P40</strong><br> a. 慢启动的时间为：1-6，23-26<br> b. 拥塞避免的时间为：6-16，17-22<br> c. 根据3个冗余ACK检测出来的<br> d. 根据超时检测出来的<br> e. 32<br> f. 21<br> g. 14<br> h. 7<br> i. 窗口长度为1，ssthresh为4<br> j. 窗口长度为4，ssthresh为21<br> k. 令j的假设成立，也就是16轮回时发生了快速重传，但是没有快速恢复的情况，与图中的折线不同。一共发送了52个分组。</p> </li><li> <p><strong>P41</strong><br><span class="img-upload-box" id="jtMAOKt9"><img class="preview" src="https://images2.imgbox.com/bc/c7/5B86uLIC_o.png" alt="pic1.png"><span class="info-box"><img class="img-loading" src="https://images2.imgbox.com/6f/0c/XiIDFZ8a_o.gif" alt="uploading.4e448015.gif"><span class="operate-box"><span class="upload-msg">转存失败</span><a class="btn btn-redo">重新上传</a><a class="btn btn-cancle">取消</a></span></span></span><a href="https://github.com/jzplp/Computer-Network-A-Top-Down-Approach-Answer/blob/master/Chapter-3/PA-P41/pic1.png"><img alt="Image text" src="https://images2.imgbox.com/76/5e/uPgU28Qc_o.png"></a><br> 如图所示，吞吐量将在B和C来回变动，不能收敛于平衡。</p> </li><li> <p><strong>P42</strong><br> 拥塞是解决的当前接收窗口很大，但是发送速率却不能很大的情况，这种情况超时时间加倍并不能解决。</p> </li><li> <p><strong>P43</strong><br> 如果不会发生丢失和定时器超时，那么拥塞控制便无法解决此类问题。可以使用类似流量控制的方法，控制发送方已发送未确认的字节数量小于接收缓存，且小于等于链路传输速率R的要求。比如小于等于R*RTT。</p> </li><li> <p><strong>P44</strong><br> a. 6RTT<br> b. 平均吞吐量8.5MSS</p> </li><li> <p><strong>P45</strong><br> a.<br> 假设是拥塞避免状态。一个周期发送的数据量从W/2变为W。<br><span class="img-upload-box" id="S8CPbzot"><img class="preview" src="https://images2.imgbox.com/cd/a0/XZSig6eP_o.gif" alt="pic1.gif"><span class="info-box"><img class="img-loading" src="https://images2.imgbox.com/ac/cf/Ve1aBci1_o.gif" alt="uploading.4e448015.gif"><span class="operate-box"><span class="upload-msg">转存失败</span><a class="btn btn-redo">重新上传</a><a class="btn btn-cancle">取消</a></span></span></span><a href="https://github.com/jzplp/Computer-Network-A-Top-Down-Approach-Answer/blob/master/Chapter-3/PA-P45/pic1.gif"><img alt="Image text" src="https://images2.imgbox.com/2c/e3/typ0cpx9_o.gif"></a><br> b.<br><span class="img-upload-box" id="nXI6m6dA"><img class="preview" src="https://images2.imgbox.com/15/6a/o3Wj3s93_o.gif" alt="pic2.gif"><span class="info-box"><img class="img-loading" src="https://images2.imgbox.com/4c/a7/BHda5EHN_o.gif" alt="uploading.4e448015.gif"><span class="operate-box"><span class="upload-msg">转存失败</span><a class="btn btn-redo">重新上传</a><a class="btn btn-cancle">取消</a></span></span></span><a href="https://github.com/jzplp/Computer-Network-A-Top-Down-Approach-Answer/blob/master/Chapter-3/PA-P45/pic2.gif"><img alt="Image text" src="https://images2.imgbox.com/23/55/t6gdN7Fp_o.gif"></a></p> </li><li> <p><strong>P46</strong><br> a.<br> 1个RTT发送的字节数为10M * 150ms = 1.5Mb<br> 窗口长度最大为1.5Mb / (1500 * 8) = 125<br> b.<br> 平均窗口为长度最大为 0.75 * 125 ~= 93<br> 平均吞吐量 93 * 1500 * 8 / 150ms = 7.44Mbps<br> c.<br> 不考虑慢启动状态，即直接从W/2开始拥塞避免状态，窗口从62到125，经历63个RTT，9.45s</p> </li><li> <p><strong>P47</strong><br> 不会做</p> </li><li> <p><strong>P48</strong><br> a.<br> 1个RTT发送的字节数为10G * 150ms = 1.5Gb<br> 窗口长度最大为1.5Gb / (1500 * 8) = 125K<br> b.<br> 平均窗口为长度最大为 0.75 * 125K ~= 93K<br> 平均吞吐量 93K * 1500 * 8 / 150ms = 7.44Gbps<br> c.<br> 不考虑慢启动状态，即直接从W/2开始拥塞避免状态，窗口从62.5K到125K，经历62.5K个RTT，9375s<br> 解决方案</p> </li></ul> 
<ol><li>超时时，ssthresh的值可以不设为W/2，而是设为更大的数字。</li><li>拥塞避免状态一个RTT可以不仅增加一个窗口，而是增加更多窗口</li></ol> 
<ul><li> <p><strong>P49</strong><br> 设平均吞吐量为W平均<br> T = W/2， W平均 = 0.75 * (W * RTT / MSS) / RTT = 0.75W / MSS<br> T = W平均 * MSS / 0.75</p> </li><li> <p><strong>P50</strong><br> a.<br> 在t0，C1的速率为10/50ms = 200，C1的速率为10/100ms = 100，远远超过链路速率，因此他们都要减半<br> 又注意到，假设C1和C2的拥塞窗口为1，他们的速率为20和10，正好与链路速率相等，因此C1和C2会一直减半到1。<br> b.<br> 考虑到一旦C1和C2的拥塞窗口超过1，那么就会发生丢包而减半，因此C1和C2的拥塞窗口都稳定为1。<br> 此时C1的带宽为20报文/s，C2的带宽为10报文/s，不能共享相同的带宽</p> </li><li> <p><strong>P51</strong><br> a.</p> </li></ul> 
<table><thead><tr><th>时间</th><th>RTT数</th><th>C1窗口</th><th>C1速率</th><th>C2窗口</th><th>C2速率</th><th>是否拥塞</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>15</td><td>150</td><td>10</td><td>100</td><td>是</td></tr><tr><td>100ms</td><td>1</td><td>7</td><td>70</td><td>5</td><td>50</td><td>是</td></tr><tr><td>200ms</td><td>2</td><td>3</td><td>30</td><td>2</td><td>20</td><td>是</td></tr><tr><td>300ms</td><td>3</td><td>1</td><td>10</td><td>1</td><td>10</td><td>否</td></tr><tr><td>400ms</td><td>4</td><td>2</td><td>20</td><td>2</td><td>20</td><td>是</td></tr><tr><td>500ms</td><td>5</td><td>1</td><td>10</td><td>1</td><td>10</td><td>否</td></tr></tbody></table> 
<p>因此，两者的拥塞窗口长度还是1。<br> b.<br> 两条连接共享相同的带宽<br> c.<br> 两条连接是同步的，看a的表格即可得。<br> d.<br> 这种同步可能不能改善利用率，试想如下的窗口长度：</p> 
<table><thead><tr><th>C1窗口</th><th>C1速率</th><th>C2窗口</th><th>C2速率</th><th>是否拥塞</th></tr></thead><tbody><tr><td>2</td><td>20</td><td>1</td><td>10</td><td>否</td></tr></tbody></table> 
<p>如果能稳定这种状态，可以使得当遇到拥塞时一方减半，另一方不减半，那么可以改善利用率。</p> 
<ul><li> <p><strong>P52</strong><br> RTT 0时，窗口长度W/2<br> RTT 1时，窗口长度W/2 + α* W/2 = (1 + α)W/2<br> RTT 2时，窗口长度(1 + α)W/2 + α(1 + α)W/2 = (1 + α)2W/2<br> RTT 3时，窗口长度(1 + α)2W/2 + α(1 + α)2W/2 = (1 + α)3W/2<br> ...... RTT n时，窗口长度((1 + α)nW/2<br> 设n时达到W，此时((1 + α)nW/2 = W<br> n = log2(1 + α)<br> 因此，当log2(1 + α) * RTT时到达W，与吞吐量无关</p> </li><li> <p><strong>P53</strong><br><span class="img-upload-box" id="uALkS5aS"><img class="preview" src="https://images2.imgbox.com/df/d0/sUlADK7B_o.gif" alt="pic1.gif"><span class="info-box"><img class="img-loading" src="https://images2.imgbox.com/4c/92/WV0lqw9k_o.gif" alt="uploading.4e448015.gif"><span class="operate-box"><span class="upload-msg">转存失败</span><a class="btn btn-redo">重新上传</a><a class="btn btn-cancle">取消</a></span></span></span><a href="https://github.com/jzplp/Computer-Network-A-Top-Down-Approach-Answer/blob/master/Chapter-3/PA-P53/pic1.gif"><img alt="Image text" src="https://images2.imgbox.com/d5/b2/eJg6PjwZ_o.gif"></a></p> </li><li> <p><strong>P54</strong><br> 优点是安全，保险。<br> 缺点是t1时刻因为发送方有大量数据要发送，因此拥塞窗口较小，但经过一段时间的空闲，可能链路中并不拥塞了（或者更加拥塞了），因此直接使用他们的值会有无法最大利用链路的问题。<br> 可以在t2时刻使用慢启动，重新计算cwnd和ssthresh值。</p> </li><li> <p><strong>P55</strong><br> a. 服务器将向Y发送响应<br> b. 可以确认，因为SYNACK是发送给Y的，X并不知道ACK应该发送什么。</p> </li><li> <p><strong>P56</strong><br> a.</p> </li></ul> 
<table><thead><tr><th>时间</th><th>活动</th><th>窗口大小</th><th>剩余窗口大小</th></tr></thead><tbody><tr><td>0</td><td>发送SYN</td><td>0</td><td>0</td></tr><tr><td>RTT</td><td>接收SYNACK</td><td>0</td><td>0</td></tr><tr><td>1RTT + S/R</td><td>服务器发送数据报文1</td><td>1</td><td>0</td></tr><tr><td>2RTT + S/R</td><td>服务器接收ACK1，准备发送数据报文2</td><td>2</td><td>2</td></tr><tr><td>2RTT + 2S/R</td><td>服务器发送数据报文2</td><td>2</td><td>1</td></tr><tr><td>2RTT + 3S/R</td><td>服务器发送数据报文3</td><td>2</td><td>0</td></tr><tr><td>3RTT + 2S/R</td><td>服务器接收到ACK2，准备发送数据报文4</td><td>3</td><td>2</td></tr><tr><td>3RTT + 3S/R</td><td>服务器发送数据报文4，同时接收到ACK3</td><td>4</td><td>3</td></tr><tr><td>3RTT + 4S/R</td><td>服务器发送数据报文5</td><td>4</td><td>2</td></tr></tbody></table> 
<p>后面一直剩余窗口大小一直大于0，因此一直不停发送报文，发送的同时也接收ACK。发送所有报文后，再等待一个RTT时间，即传送完成。<br> 最后时间为 3RTT + 4S/R + RTT + 10S/R = 4RTT + 14S/R</p> 
<p>b.</p> 
<table><thead><tr><th>时间</th><th>活动</th><th>窗口大小</th><th>剩余窗口大小</th></tr></thead><tbody><tr><td>0</td><td>发送SYN</td><td>0</td><td>0</td></tr><tr><td>RTT</td><td>接收SYNACK</td><td>0</td><td>0</td></tr><tr><td>1RTT + S/R</td><td>服务器发送数据报文1</td><td>1</td><td>0</td></tr><tr><td>2RTT + S/R</td><td>服务器接收ACK1，准备发送数据报文2</td><td>2</td><td>2</td></tr><tr><td>2RTT + 2S/R</td><td>服务器发送数据报文2</td><td>2</td><td>1</td></tr><tr><td>2RTT + 3S/R</td><td>服务器发送数据报文3</td><td>2</td><td>0</td></tr><tr><td>3RTT + 2S/R</td><td>服务器接收到ACK2，准备发送数据报文4</td><td>3</td><td>2</td></tr><tr><td>3RTT + 3S/R</td><td>服务器发送数据报文4，同时接收到ACK3</td><td>4</td><td>3</td></tr><tr><td>3RTT + 4S/R</td><td>服务器发送数据报文5</td><td>4</td><td>2</td></tr><tr><td>3RTT + 5S/R</td><td>服务器发送数据报文6</td><td>4</td><td>1</td></tr><tr><td>3RTT + 6S/R</td><td>服务器发送数据报文7</td><td>4</td><td>0</td></tr><tr><td>4RTT + 3S/R</td><td>服务器接收到ACK4，准备发送数据报文8</td><td>5</td><td>2</td></tr><tr><td>4RTT + 4S/R</td><td>服务器发送数据报文8，同时接收到ACK5</td><td>6</td><td>3</td></tr><tr><td>4RTT + 5S/R</td><td>服务器发送数据报文9，同时接收到ACK6</td><td>7</td><td>4</td></tr><tr><td>4RTT + 6S/R</td><td>服务器发送数据报文10，同时接收到ACK7</td><td>8</td><td>5</td></tr></tbody></table> 
<p>此时剩余窗口为5，服务器只需一直发送所有报文，再等待一个RTT即可。<br> 最后时间为 4RTT + 6S/R + RTT + 5S/R = 5RTT + 11S/R</p> 
<p>c.</p> 
<table><thead><tr><th>时间</th><th>活动</th><th>窗口大小</th><th>剩余窗口大小</th></tr></thead><tbody><tr><td>0</td><td>发送SYN</td><td>0</td><td>0</td></tr><tr><td>RTT</td><td>接收SYNACK</td><td>0</td><td>0</td></tr><tr><td>1RTT + S/R</td><td>服务器发送数据报文1</td><td>1</td><td>0</td></tr><tr><td>2RTT + S/R</td><td>服务器接收ACK1，准备发送数据报文2</td><td>2</td><td>2</td></tr><tr><td>2RTT + 2S/R</td><td>服务器发送数据报文2，准备发送数据报文3</td><td>2</td><td>1</td></tr><tr><td>3RTT + 2S/R</td><td>服务器接收ACK2</td><td>3</td><td>2</td></tr><tr><td>2RTT + 3S/R</td><td>服务器发送数据报文3，准备发送数据报文4</td><td>3</td><td>2</td></tr><tr><td>3RTT + 3S/R</td><td>服务器接收ACK3</td><td>4</td><td>3</td></tr><tr><td>2RTT + 4S/R</td><td>服务器发送数据报文4，准备发送数据报文5</td><td>4</td><td>3</td></tr></tbody></table> 
<p>由于发送时间大于RTT，因此发送下一个之前，ACK已经收到。服务器只需一直发送所有报文，再等待一个RTT即可。<br> 最后时间为 2RTT + 4S/R + RTT + 11S/R = 3RTT + 15S/R</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/28e2cfe15ce75a833639801f3477a448/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">mysql的lpad函数</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/30ba43b30b2943e5557618fa09d92840/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">winform在设置控件enabled=false后，无法更改控件字体颜色的问题</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>