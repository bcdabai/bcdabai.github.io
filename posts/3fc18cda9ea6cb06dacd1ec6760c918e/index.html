<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>探究eFuse：硬件保障与系统安全的核心 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="探究eFuse：硬件保障与系统安全的核心" />
<meta property="og:description" content="探究eFuse：硬件保障与系统安全的核心 图1： 编程熔断的 eFuse
eFUSE的全名是&#34;Electrically Programmable Read-Only Memory Fuse&#34;，它是一种电可编程只读存储器。
eFUSE是一种用于存储固定信息的存储器，它的主要特点是一旦编程后就无法再进行擦除或修改，类似于传统的只读存储器（ROM）的功能。
作为系统工程师，虽然不会对eFuse 这块做深入的开发，更多的还是依赖芯片厂商自己的实现，然后取出自己的数据，但是通过对 eFuse 大致的了解，能够对整机的一些概念紧密联系起来，让知识图谱更全面。
目前手机行业内，出厂都会做熔丝处理，熔丝之后，不能进行随意刷机，非熔丝设备一般属于开发设备，用来内部自定义刷机。
熔丝过程中，有一个步骤就是写入设备ID信息， 熔丝设备通常具有唯一的设备ID，可以用防止软件篡改和仿冒，一些商业化行为的唯一标记等。
这些标识通常是在制造过程中预先烧录到eFUSE中的，用于识别每个设备的唯一性，Bootloader可以读取eFUSE中的这些标识，并在设备启动时使用它们来进行身份验证。
eFuse不是软件上的分区 eFUSE（熔断保护）通常是硬件特性，而不是预置的软件特性，eFUSE是一种一次性可编程的硬件存储器，用于存储固定的数据或配置信息，例如设备序列号、密钥、硬件配置等。
eFUSE在手机或其他设备的主板上实现，并由硬件厂商预置一些不可更改的数据。这些数据通常在制造过程中被烧录到eFUSE中，并且无法在后续的使用中被修改。因此，eFUSE中存储的信息是设备固有的、不可更改的。
在 Android 系统中，eFUSE通常被用于存储一些重要的设备信息和安全相关的数据，例如设备唯一标识、安全密钥、加密相关信息等。这些数据的安全性和不可篡改性是系统的重要保障，因此通常会将它们存储在eFUSE中，以防止被非法篡改或泄漏。
由于eFUSE的特性，它一般不受 Android 系统软件的影响，也不是可编程的软件特性。因此，Google 原生 Android 系统上的eFUSE通常是由设备硬件厂商预置和配置的，与 Android 系统软件无关。
BootLoader 实现读取 eFUSE 在Bootloader中扮演着重要的角色，用于存储关键的设备信息和安全配置，帮助确保设备的启动过程和运行环境的安全性。它是Android设备等嵌入式系统中重要的安全保障措施之一。
Android bootloader 是一个引导加载程序，它位于 Android 设备的存储芯片中，负责启动设备并加载操作系统。它是设备上的第一个软件程序，负责执行一系列初始化任务和配置操作，以确保设备能够正确启动。
目前 bootloader 不属于 AOSP 内标准的模块，一般是芯片厂商在维护，目录结构也不统一，对于 eFuse 的读取模块也在 lk 内， 高通的 bsp 模块一般是独立编译，MTK和展讯所在的目录也不太一样，常见的有这些目录结构：
bsp/bootloader/lkkernel/lk/ eFuse 存在 BootLoader 中的功能有：
安全启动验证
Bootloader是在设备启动时运行的第一个软件程序，负责初始化硬件和加载操作系统，在安全启动流程中，Bootloader通常会检查 eFUSE 中的安全配置信息，例如是否启用了 Secure Boot（安全启动）功能。
如果eFUSE中的安全标志被设置为启用，Bootloader会执行相应的安全验证流程，以确保设备启动的固件和操作系统是经过验证的，从而防止未经授权的固件加载。
设备唯一标识
Bootloader可能会使用eFUSE中存储的设备唯一标识（Device ID）作为设备的身份认证信息。
这些标识通常是在制造过程中预先烧录到eFUSE中的，用于识别每个设备的唯一性。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/3fc18cda9ea6cb06dacd1ec6760c918e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-08-01T14:12:32+08:00" />
<meta property="article:modified_time" content="2023-08-01T14:12:32+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">探究eFuse：硬件保障与系统安全的核心</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="eFuse_0"></a>探究eFuse：硬件保障与系统安全的核心</h2> 
<blockquote> 
 <p><img src="https://images2.imgbox.com/03/98/BTqUaE52_o.png" alt="image"></p> 
</blockquote> 
<p>图1： 编程熔断的 eFuse</p> 
<p>eFUSE的全名是"Electrically Programmable Read-Only Memory Fuse"，它是一种电可编程只读存储器。<br> eFUSE是一种用于存储固定信息的存储器，它的主要特点是一旦编程后就<strong>无法再进行擦除或修改</strong>，类似于传统的只读存储器（ROM）的功能。</p> 
<p>作为系统工程师，虽然不会对eFuse 这块做深入的开发，更多的还是依赖芯片厂商自己的实现，然后取出自己的数据，但是通过对 eFuse 大致的了解，能够对整机的一些概念紧密联系起来，让知识图谱更全面。</p> 
<p>目前手机行业内，出厂都会做<strong>熔丝</strong>处理，熔丝之后，不能进行随意刷机，非熔丝设备一般属于开发设备，用来内部自定义刷机。<br> 熔丝过程中，有一个步骤就是写入设备ID信息， 熔丝设备通常具有唯一的设备ID，可以用防止软件篡改和仿冒，一些商业化行为的唯一标记等。<br> 这些标识通常是在制造过程中预先烧录到eFUSE中的，用于识别每个设备的唯一性，Bootloader可以读取eFUSE中的这些标识，并在设备启动时使用它们来进行身份验证。</p> 
<h3><a id="eFuse_14"></a>eFuse不是软件上的分区</h3> 
<p>eFUSE（熔断保护）通常是<strong>硬件特性</strong>，而不是预置的软件特性，eFUSE是一种一次性可编程的硬件存储器，用于存储固定的数据或配置信息，例如设备序列号、密钥、硬件配置等。<br> eFUSE在手机或其他设备的主板上实现，并由硬件厂商预置一些不可更改的数据。这些数据通常在制造过程中被烧录到eFUSE中，并且无法在后续的使用中被修改。因此，eFUSE中存储的信息是设备固有的、不可更改的。<br> 在 Android 系统中，eFUSE通常被用于存储一些重要的设备信息和安全相关的数据，例如设备唯一标识、安全密钥、加密相关信息等。这些数据的安全性和不可篡改性是系统的重要保障，因此通常会将它们存储在eFUSE中，以防止被非法篡改或泄漏。<br> 由于eFUSE的特性，它一般不受 Android 系统软件的影响，也不是可编程的软件特性。因此，Google 原生 Android 系统上的eFUSE通常是由设备硬件厂商预置和配置的，与 Android 系统软件无关。</p> 
<h3><a id="BootLoader__20"></a>BootLoader 实现读取</h3> 
<p>eFUSE 在Bootloader中扮演着重要的角色，用于存储关键的设备信息和安全配置，帮助确保设备的启动过程和运行环境的安全性。它是Android设备等嵌入式系统中重要的安全保障措施之一。</p> 
<p>Android bootloader 是一个引导加载程序，它位于 Android 设备的存储芯片中，负责启动设备并加载操作系统。它是设备上的第一个软件程序，负责执行一系列初始化任务和配置操作，以确保设备能够正确启动。<br> 目前 bootloader 不属于 AOSP 内标准的模块，一般是芯片厂商在维护，目录结构也不统一，对于 eFuse 的读取模块也在 lk 内， 高通的 bsp 模块一般是独立编译，MTK和展讯所在的目录也不太一样，常见的有这些目录结构：</p> 
<ul><li>bsp/bootloader/lk</li><li>kernel/lk/</li></ul> 
<p>eFuse 存在 BootLoader 中的功能有：</p> 
<ol><li> <p>安全启动验证<br> Bootloader是在设备启动时运行的第一个软件程序，负责初始化硬件和加载操作系统，在安全启动流程中，Bootloader通常会检查 eFUSE 中的安全配置信息，例如是否启用了 Secure Boot（安全启动）功能。<br> 如果eFUSE中的安全标志被设置为启用，Bootloader会执行相应的安全验证流程，以确保设备启动的固件和操作系统是经过验证的，从而防止未经授权的固件加载。</p> </li><li> <p>设备唯一标识<br> Bootloader可能会使用eFUSE中存储的设备唯一标识（Device ID）作为设备的身份认证信息。<br> 这些标识通常是在制造过程中预先烧录到eFUSE中的，用于识别每个设备的唯一性。<br> Bootloader可以读取eFUSE中的这些标识，并在设备启动时使用它们来进行身份验证。</p> </li><li> <p>安全密钥存储<br> 某些Bootloader可能会使用eFUSE来存储安全密钥，例如用于加密和解密数据的密钥。这些密钥通常是在制造过程中预先烧录到eFUSE中的，以确保密钥的安全性和不可篡改性。</p> </li><li> <p>防止硬件修改<br> Bootloader可能会使用eFUSE来检查设备硬件的配置和状态，以确保硬件没有被修改或篡改。通过读取eFUSE中存储的硬件配置信息，Bootloader可以识别任何不合法的硬件修改，从而确保设备的完整性和安全性。</p> </li></ol> 
<h3><a id="eFuse__NVRAM__45"></a>eFuse 和 NVRAM 的区别</h3> 
<p>eFUSE（Electrically Programmable Read-Only Memory Fuse）和 NVRAM（Non-Volatile Random Access Memory）</p> 
<ul><li> <p>eFUSE（电可编程只读存储器）：</p> 
  <ul><li>特性：eFUSE是一种只读存储器，一旦编程后就无法再进行擦除或修改。它是一次性可编程的，一旦被烧录，存储的数据将变为永久性的。</li><li>用途：eFUSE通常用于存储一些重要的设备信息和安全相关的数据，例如设备唯一标识、安全密钥、硬件配置等。这些数据的安全性和不可篡改性是系统的重要保障。</li><li>编程：eFUSE通常在制造过程中被烧录，由硬件厂商预置一些不可更改的数据。它一般不受软件的影响，也不是可编程的软件特性。</li></ul> </li><li> <p>NVRAM（非易失性随机存取存储器）：</p> 
  <ul><li>特性：NVRAM是一种随机访问存储器，它可以读取和写入数据，并且数据在断电后仍然保持不变，具有非易失性特性。</li><li>用途：NVRAM通常用于存储一些配置信息、用户设置、操作系统状态等需要持久化保存的数据。</li><li>编程：NVRAM中的数据通常由操作系统或应用程序进行读取和写入，可以在运行时进行修改和更新。</li></ul> </li></ul> 
<p>在手机行业中， eFuse 涉及到的开发一般是工具开发工程师在处理，兼容不同芯片，将设备ID等基础功能兼容好，NVRAM的开发更多是涉及到软件工程师，根据实际的需求来读写数据。</p> 
<p>比如常见的电子保卡，WIFI、MAC等一些格式化需要保留的信息等，后续文章在针对性来讲解。</p> 
<p><img src="https://images2.imgbox.com/4e/b9/9F0jqx0F_o.png" alt="image"></p> 
<p>MTK的刷机设备上通过 <strong>Download Only</strong> 以及 Android设备自带的恢复出厂设置就不会将 NVRAM 存储的数据清除， 但是 <strong>Format ALL+Download(格式化刷机)</strong> 就会将NVRAM数据清除。</p> 
<p>eFuse 一般就是一次写入，比如设备ID， NVRAM是根据实际的需求，由软件工程师来进行读写。</p> 
<h3><a id="_69"></a>熔丝工具</h3> 
<p>熔丝工具（Fuse Programming Tool）是用于编程eFuse的特定工具，其原理主要涉及以下方面：</p> 
<ul><li>接口和通信<br> 熔丝工具需要与目标设备建立通信，并通过特定的接口与设备进行数据传输。通常，熔丝工具使用USB、JTAG、SWD（Serial Wire Debug）等接口与目标设备进行连接。</li><li>认证和权限<br> 为了确保对eFuse的编程是安全可靠的，熔丝工具通常需要进行认证和权限验证。这可以防止未经授权的访问者对设备的eFuse进行编程。</li><li>操作命令<br> 熔丝工具通过发送特定的操作命令到目标设备来控制eFuse的编程。这些命令可能包括读取eFuse的状态、擦除eFuse、编程eFuse等。</li><li>保护机制<br> 为了防止误操作或恶意篡改，熔丝工具可能会实现一些保护机制，如写保护功能、编程次数限制等。</li><li>错误处理<br> 熔丝工具需要能够处理可能出现的错误情况，如通信错误、设备响应超时、编程失败等，以保证编程的准确性和稳定性。</li></ul> 
<p>熔丝工具原理可能因厂商、芯片型号和设备特性而异， 因此，在使用熔丝工具时，需要严格按照厂商提供的文档和指导进行操作，避免因错误的操作而导致设备损坏或数据丢失，<br> 此外，由于eFuse是一次性编程的，一旦编程完成，其中的信息将无法修改或擦除，因此操作时必须谨慎。</p> 
<p>所以对于工具工程师而言，这里面核心的工作任务就是兼容不同芯片，保证熔丝的稳定。</p> 
<p>一般涉及到 eFuse 写入的稳定性问题，一般都是芯片厂内部的逻辑，对于手机厂商而言，如果遇到设备ID失败，异常的问题，就会被归类为影响整机的严重问题。</p> 
<h3><a id="_89"></a>安全问题</h3> 
<p>任天堂的 Switch 掌机通过 eFuse 来防止设备降级， 在用户升级系统时，机器会熔断一定数量 eFuse ，而用户试图降级系统时会校验版本和熔丝的数量，如果不匹配就无法刷入系统。<br> 软破解的任天堂的Switch，就是通过外接锡纸的形式然后进入到一个大气层系统，然后在进入到Switch原始的系统， 对于设备的破解而言，一般都是推荐用户在离线的模式下进行，一个是防止软件上的数据更新导致的异常行为被发现，一个是设备升级版本之后，会对 eFuse进行熔断到当前的系统版本，如果熔断到最新版本后，可能就没法在刷入三方系统。</p> 
<p>eFuse 是可以通过电子显微镜看见熔断的情况，见图一。</p> 
<blockquote> 
 <p>在大型安全SOC芯片中, eFuse 是一种重要的非易失性存储单元,由熔丝结构构成,通过熔丝可以在芯片上编程并存储信息.常常用于存储安全相关的内容，比如密钥、密码等信息，<br> 因此对于芯片的安全系统非常重要。但是由于工艺尺寸的突飞猛进，efuse作为一种较为脆弱的电路单元，常常在使用过程中由于静电或者其他原因造成efuse损坏，造成整个芯片和系统无法工作，只能整机报废,从而导致大量的浪费。</p> 
</blockquote> 
<h3><a id="eFuse__98"></a>eFuse 读取</h3> 
<p>对于设备ID而言，一般是通过在 BootLoader 内部读取 eFuse存储位中的信息得到设备ID，可以写入到属性，然后Android 系统进入后，就可以通过读取属性得到唯一的设备ID。<br> 大部分的情况而言，设备ID的异常问题，是出现在 BootLoader 的读取里面，需要手机厂商自行去解决。</p> 
<p>例如，在某些系统中，eFuse 可能被配置为存储一个 32 位的整数值。读取该 eFuse 后，得到的数据可能是一个 32 位的二进制数，或以十六进制表示的 8 位数（4 字节）。</p> 
<p>比如通过芯片厂商提供的接口，能够获取到32位的整数值，然后需要转换记录到本地, 比如<code>fdt32_to_cpu</code> 函数的实现：</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdint.h&gt;</span></span>

<span class="token keyword">uint32_t</span> <span class="token function">fdt32_to_cpu</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">uint32_t</span> <span class="token operator">*</span>val<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
<span class="token comment">// 假设系统为小端字节序（Little-Endian）</span>
<span class="token keyword">uint32_t</span> result<span class="token punctuation">;</span>
<span class="token keyword">uint8_t</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">uint8_t</span> <span class="token operator">*</span><span class="token punctuation">)</span>val<span class="token punctuation">;</span>

    result <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">uint32_t</span><span class="token punctuation">)</span>p<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    result <span class="token operator">|=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">uint32_t</span><span class="token punctuation">)</span>p<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    result <span class="token operator">|=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">uint32_t</span><span class="token punctuation">)</span>p<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    result <span class="token operator">|=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">uint32_t</span><span class="token punctuation">)</span>p<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token number">24</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>fdt32_to_cpu 函数接受一个指向 FDT 中存储 32 位整数的指针 val，然后按照小端字节序将这个 32 位整数值转换为 CPU 的本地字节序，并将转换后的值返回。</p> 
<p>本文只是从软件开发的角度，简单梳理一下eFuse 涉及到的模块以及基本概念，本文也在持续的更新中，如果你需要得到最新的更新，请访问: <a href="https://www.toscl.com/android_efuse/" rel="nofollow">探究eFuse：硬件保障与系统安全的核心</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/72335e8be2056f64c109a5335196cc8f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">河北中洺科技BEV语义数据标注工具打开图片流程：</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/817823fc3c383327e7fee528879a5d08/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Java Zip压缩：简化文件和文件夹的压缩操作</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>