<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>浪花 - 主页性能优化 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="浪花 - 主页性能优化" />
<meta property="og:description" content="目录
一、缓存
1. 为什么用缓存？
2. 缓存的实现方式
3. Redis
4. 使用 Spring Data Redis 中操作 Redis
5. 自定义 RedisTemplate（配置）
6. 主页推荐用户查询使用缓存
7. 对比查询速度
8. 缓存预热
二、定时任务
1. Spring Scheduler
2. 其他
一、缓存 1. 为什么用缓存？ 数据量大查询慢，用缓存先读取部分数据保存到读写性能更快的介质中（比如内存） 2. 缓存的实现方式 分布式缓存：Redis、Memcache 等单机缓存：Ehcache、Caffeine（Java 内存缓存，高性能）、Google Guava单机缓存的缺点：数据不一致 3. Redis Remote Dictionary Server（远程词典服务器）基于内存的高性能 NoSQL 数据库key - value 存储系统Redis 的数据结构：String、Set、Map、Hash、SortedSet 4. 使用 Spring Data Redis 中操作 Redis Spring Data：通用数据访问框架，定义了一组增删改查的框架，包括对操作各种数据库的集成使用步骤参考：浪花 - 单机登录升级为分布式 Session 登录-CSDN博客 SpringDataRedis 快速入门
引入 spring-boot-starter-data-redis 依赖application.yml 配置 Redis 信息注入 RedisTemplate 调用方法操作 Redis 数据库调用 redisTemplate 中的 API 获取操作指定数据类型的对象 optForValue()String Redis Template 手动序列化将数据存入 Redis取出数据手动反序列化 /** * Redis 操作测试 * @author 乐小鑫 * @version 1." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/d2516a7b00daf5a1eb3a55d4b061d9e4/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-20T21:18:35+08:00" />
<meta property="article:modified_time" content="2024-01-20T21:18:35+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">浪花 - 主页性能优化</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80%E3%80%81%E7%BC%93%E5%AD%98-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%E7%BC%93%E5%AD%98" rel="nofollow">一、缓存</a></p> 
<p id="1.%20%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8%E7%BC%93%E5%AD%98%EF%BC%9F-toc" style="margin-left:40px;"><a href="#1.%20%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8%E7%BC%93%E5%AD%98%EF%BC%9F" rel="nofollow">1. 为什么用缓存？</a></p> 
<p id="2.%20%E7%BC%93%E5%AD%98%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F-toc" style="margin-left:40px;"><a href="#2.%20%E7%BC%93%E5%AD%98%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F" rel="nofollow">2. 缓存的实现方式</a></p> 
<p id="3.%20Redis-toc" style="margin-left:40px;"><a href="#3.%20Redis" rel="nofollow">3. Redis</a></p> 
<p id="4.%20%E4%BD%BF%E7%94%A8%C2%A0Spring%20Data%20Redis%20%E4%B8%AD%E6%93%8D%E4%BD%9C%20Redis-toc" style="margin-left:40px;"><a href="#4.%20%E4%BD%BF%E7%94%A8%C2%A0Spring%20Data%20Redis%20%E4%B8%AD%E6%93%8D%E4%BD%9C%20Redis" rel="nofollow">4. 使用 Spring Data Redis 中操作 Redis</a></p> 
<p id="5.%20%E8%87%AA%E5%AE%9A%E4%B9%89%20RedisTemplate%EF%BC%88%E9%85%8D%E7%BD%AE%EF%BC%89-toc" style="margin-left:40px;"><a href="#5.%20%E8%87%AA%E5%AE%9A%E4%B9%89%20RedisTemplate%EF%BC%88%E9%85%8D%E7%BD%AE%EF%BC%89" rel="nofollow">5. 自定义 RedisTemplate（配置）</a></p> 
<p id="%C2%A06.%20%E4%B8%BB%E9%A1%B5%E6%8E%A8%E8%8D%90%E7%94%A8%E6%88%B7%E6%9F%A5%E8%AF%A2%E4%BD%BF%E7%94%A8%E7%BC%93%E5%AD%98-toc" style="margin-left:40px;"><a href="#%C2%A06.%20%E4%B8%BB%E9%A1%B5%E6%8E%A8%E8%8D%90%E7%94%A8%E6%88%B7%E6%9F%A5%E8%AF%A2%E4%BD%BF%E7%94%A8%E7%BC%93%E5%AD%98" rel="nofollow"> 6. 主页推荐用户查询使用缓存</a></p> 
<p id="%C2%A07.%20%E5%AF%B9%E6%AF%94%E6%9F%A5%E8%AF%A2%E9%80%9F%E5%BA%A6-toc" style="margin-left:40px;"><a href="#%C2%A07.%20%E5%AF%B9%E6%AF%94%E6%9F%A5%E8%AF%A2%E9%80%9F%E5%BA%A6" rel="nofollow"> 7. 对比查询速度</a></p> 
<p id="%C2%A08.%20%E7%BC%93%E5%AD%98%E9%A2%84%E7%83%AD-toc" style="margin-left:40px;"><a href="#%C2%A08.%20%E7%BC%93%E5%AD%98%E9%A2%84%E7%83%AD" rel="nofollow"> 8. 缓存预热</a></p> 
<p id="%E4%BA%8C%E3%80%81%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1" rel="nofollow">二、定时任务</a></p> 
<p id="1.%20Spring%20Scheduler-toc" style="margin-left:40px;"><a href="#1.%20Spring%20Scheduler" rel="nofollow">1. Spring Scheduler</a></p> 
<p id="2.%20%E5%85%B6%E4%BB%96-toc" style="margin-left:40px;"><a href="#2.%20%E5%85%B6%E4%BB%96" rel="nofollow">2. 其他</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 style="background-color:transparent;">一、缓存</h2> 
<h3 id="1.%20%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8%E7%BC%93%E5%AD%98%EF%BC%9F">1. 为什么用缓存？</h3> 
<ul><li>数据量大查询慢，用缓存先读取部分数据保存到读写性能更快的介质中（比如内存）</li></ul> 
<h3 id="2.%20%E7%BC%93%E5%AD%98%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F">2. 缓存的实现方式</h3> 
<ul><li>分布式缓存：Redis、Memcache 等</li><li>单机缓存：Ehcache、Caffeine（Java 内存缓存，高性能）、Google Guava</li><li>单机缓存的缺点：数据不一致</li></ul> 
<h3 id="3.%20Redis">3. Redis</h3> 
<ul><li>Remote Dictionary Server（远程词典服务器）</li><li>基于内存的高性能 NoSQL 数据库</li><li>key - value 存储系统</li><li>Redis 的数据结构：String、Set、Map、Hash、SortedSet</li></ul> 
<h3 id="4.%20%E4%BD%BF%E7%94%A8%C2%A0Spring%20Data%20Redis%20%E4%B8%AD%E6%93%8D%E4%BD%9C%20Redis">4. 使用 Spring Data Redis 中操作 Redis</h3> 
<ul><li>Spring Data：通用数据访问框架，定义了一组增删改查的框架，包括对操作各种数据库的集成</li><li>使用步骤参考：<a href="https://blog.csdn.net/m0_74059961/article/details/135645382?spm=1001.2014.3001.5501" title="浪花 - 单机登录升级为分布式 Session 登录-CSDN博客">浪花 - 单机登录升级为分布式 Session 登录-CSDN博客</a></li><li> <p><strong>SpringDataRedis 快速入门</strong></p> 
  <ul><li>引入 spring-boot-starter-data-redis 依赖</li><li>application.yml 配置 Redis 信息</li><li>注入 RedisTemplate 
    <ul><li>调用方法操作 Redis 数据库</li><li>调用 redisTemplate 中的 API 获取操作指定数据类型的对象 optForValue()</li></ul></li></ul></li><li>String Redis Template 
  <ul><li>手动序列化</li><li>将数据存入 Redis</li><li>取出数据</li><li>手动反序列化</li></ul></li></ul> 
<pre><code class="language-java">/**
 * Redis 操作测试
 * @author 乐小鑫
 * @version 1.0
 */
@SpringBootTest
public class RedisTest {

    @Resource
    private RedisTemplate redisTemplate;

    @Test
    void test() {
        ValueOperations valueOperations = redisTemplate.opsForValue();
        // 增
        valueOperations.set("ghostString", "dog");
        valueOperations.set("ghostInt", 1);
        valueOperations.set("ghostDouble", 2.0);
        User user = new User();
        user.setId(1L);
        user.setUsername("ghost");
        valueOperations.set("ghostUser", user);
        // 查
        Object ghost = valueOperations.get("ghostString");
        Assertions.assertTrue("dog".equals((String) ghost));
        ghost = valueOperations.get("ghostInt");
        Assertions.assertTrue(1 == (Integer) ghost);
        ghost = valueOperations.get("ghostDouble");
        Assertions.assertTrue(2.0 == (Double) ghost);
        System.out.println(valueOperations.get("ghostUser"));
        valueOperations.set("ghostString", "dog");
        redisTemplate.delete("ghostString");
    }
}
</code></pre> 
<h3 id="5.%20%E8%87%AA%E5%AE%9A%E4%B9%89%20RedisTemplate%EF%BC%88%E9%85%8D%E7%BD%AE%EF%BC%89">5. 自定义 RedisTemplate（配置）</h3> 
<ul><li>原生提供的序列化器存储对象时序列化有问题，自定义 RedisTemplate 实现存储 String 类型的 key</li></ul> 
<pre><code class="language-java">/**
 * RedisTemplate 配置
 * @author 乐小鑫
 * @version 1.0
 */
@Configuration
public class RedisTemplateConfig {
    @Bean
    public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory connectionFactory) {
        RedisTemplate&lt;String, Object&gt; redisTemplate = new RedisTemplate&lt;&gt;();
        redisTemplate.setConnectionFactory(connectionFactory);
        redisTemplate.setKeySerializer(RedisSerializer.string());
        return redisTemplate;
    }
}
</code></pre> 
<p class="img-center"><img alt="" height="330" src="https://images2.imgbox.com/20/ea/iREqcukZ_o.png" width="651"></p> 
<h3 id="%C2%A06.%20%E4%B8%BB%E9%A1%B5%E6%8E%A8%E8%8D%90%E7%94%A8%E6%88%B7%E6%9F%A5%E8%AF%A2%E4%BD%BF%E7%94%A8%E7%BC%93%E5%AD%98">6. 主页推荐用户查询使用缓存</h3> 
<ul><li>不同用户看到的推荐列表不同</li><li>设计缓存 key 
  <ul><li>在每个键前面加上<strong>系统 / 模块 / 业务 / 功能 </strong>的前缀，以区分不同业务的缓存</li><li>Redis 内存不能无限增加，一定要设置过期时间！！如果快到限制值了，会开启 Redis 的自动淘汰机制，可能会把重要数据清除掉</li></ul></li></ul> 
<blockquote> 
 <p>直接使用单层的 key 作为键可能会对其他业务产生影响，例如以 username 为 key，其他业务可能也用 username 为 key，用的是同一台 Redis 服务器时会影响其他业务的数据。</p> 
 <p>设计缓存首先的原则是<strong>不要和其他 key 发生冲突</strong></p> 
</blockquote> 
<ul><li>推荐用户时先查询缓存中是否有已经缓存好的用户 
  <ul><li>有缓存：直接返回缓存中的数据</li><li>无缓存：先查询数据库，将数据库中的缓存<strong>写入 Redis</strong>，再返回数据</li><li>注意<strong>缓存穿透</strong>：数据库中没有要查询的数据，但是客户端一直不停发送请求查询数据，缓存中没有，查询就会打到数据库，不停查询缓存中都没有数据，就会不停执行数据库的查询，占用数据库资源，可能会把数据库搞崩</li><li><strong>解决缓存穿透：缓存空值，</strong>即如果数据库中没有数据，就向 Redis 中缓存一个空值，下次再来查询，查询打到 Redis，发现有一个空值就会直接空值，不再查询数据库</li></ul></li></ul> 
<pre><code class="language-java">
    /**
     * 用户推荐
     * @param request
     * @return 用户列表
     */
    @GetMapping("/recommend")
    public BaseResponse&lt;Page&lt;User&gt;&gt; recommendUsers(long pageSize, long pageNum, HttpServletRequest request) {
        log.info("推荐用户列表");
        ValueOperations valueOperations = redisTemplate.opsForValue();
        User loginUser = userService.getLoginUser(request);
        String key = String.format("langhua:user:recommend:%s", loginUser.getId());
        Page&lt;User&gt; userPage = (Page&lt;User&gt;) valueOperations.get(key);
        // 查缓存，有直接返回缓存数据
        if (userPage != null) {
            return ResultUtils.success(userPage);
        }
        // 没有缓存数据，才查询数据库
        QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;();
        userPage = userService.page(new Page&lt;&gt;((pageNum - 1) * pageSize, pageSize), queryWrapper);// 查询所有用户
        // 将查询出来的数据写入缓存
        try {
            valueOperations.set(key,userPage);
        } catch (Exception e) {
            log.error("redis key set error", e);
        }
        return ResultUtils.success(userPage);
    }</code></pre> 
<p class="img-center"><img alt="" height="332" src="https://images2.imgbox.com/63/1c/yEAq6LMI_o.png" width="654"></p> 
<p class="img-center"><img alt="" height="353" src="https://images2.imgbox.com/64/0c/pymBeA22_o.png" width="665"></p> 
<h3 id="%C2%A07.%20%E5%AF%B9%E6%AF%94%E6%9F%A5%E8%AF%A2%E9%80%9F%E5%BA%A6">7. 对比查询速度</h3> 
<ul><li>第一次查询：缓存中没有数据，请求打到数据库，<strong>1.13 秒</strong></li></ul> 
<p class="img-center"><img alt="" height="299" src="https://images2.imgbox.com/fd/5f/JzDdKt10_o.png" width="653"></p> 
<ul><li>后续查询：缓存中已经缓存了用户列表数据，直接返回缓存数据，<strong>26.85 毫秒，性能优化显著</strong></li></ul> 
<p class="img-center"><img alt="" height="296" src="https://images2.imgbox.com/3e/43/9PMC2aW0_o.png" width="647"></p> 
<h3 id="%C2%A08.%20%E7%BC%93%E5%AD%98%E9%A2%84%E7%83%AD">8. 缓存预热</h3> 
<ul><li>为什么要缓存预热？</li></ul> 
<blockquote> 
 <p>场景分析：当缓存里没有数据时，第一个用户进来需要查询数据库才能看到响应数据，页面响应时间较久，对有些用户不友好</p> 
 <p>解决方案：在所有用户进入之前预先缓存好数据，程序员自己加载缓存，而不是等到用户进入再触发</p> 
</blockquote> 
<ul><li>优点：每个用户来访问响应都很快，提升用户体验</li><li>缺点 
  <ul><li>增加开发成本</li><li>预热时机需要谨慎选择：预热的时机太早可能会缓存到错误数据或老数据</li><li>需要占用额外空间</li></ul></li></ul> 
<blockquote> 
 <p>注意❗在分析一个技术的优缺点时，要从整个项目从 0 到 1 的整个软件生命周期去考虑（需求分析开始到项目部署上线和维护）</p> 
</blockquote> 
<ul><li>缓存预热的实现 
  <ul><li>定时任务</li><li>手动触发</li></ul></li></ul> 
<h2 id="%E4%BA%8C%E3%80%81%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1" style="background-color:transparent;">二、定时任务</h2> 
<blockquote> 
 <p>使用定时任务，每天刷新所有用户的推荐列表（缓存预热）</p> 
 <ol><li>缓存预热的意义（新增数据少、总数据量大）</li><li>缓存占用空间不能太大，需要给其他缓存预留空间</li><li>缓存数据的周期（根据业务需求来选择）</li></ol> 
</blockquote> 
<h3 id="1.%20Spring%20Scheduler">1. Spring Scheduler</h3> 
<ul><li>SpringBoot 默认已经整合，直接使用即可</li><li>使用步骤 
  <ul><li>主类（程序入口）添加注解开启定时任务支持：@EnableScheduling</li><li>要定时执行的方法添加 @Scheduled 注解</li><li>通过 cron 表达式指定定时任务执行周期：<a href="https://cron.qqe2.com/" rel="nofollow" title="在线Cron表达式生成器 (qqe2.com)">在线Cron表达式生成器 (qqe2.com)</a></li><li> 运行项目等待定时任务执行</li></ul></li></ul> 
<pre><code class="language-java">/**
 * 缓存预热定时任务
 * @author 乐小鑫
 * @version 1.0
 */
@Component
@Slf4j
public class PreCacheUser {

    @Resource
    private RedisTemplate redisTemplate;

    @Resource
    private UserService userService;

    List&lt;Long&gt; mainUserList = Arrays.asList(3L);// 重要用户列表，为该列表的用户开启缓存预热

    @Scheduled(cron = "0 5 21 ? * * ")
    public void doPreCacheUser() {
        // 查出用户存到 Redis 中
        for (Long userId : mainUserList) {
            QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;();
            Page&lt;User&gt; userPage = userService.page(new Page&lt;&gt;(1, 20), queryWrapper);// 查询所有用户
            String key = String.format("langhua:user:recommend:%s", userId);
            ValueOperations valueOperations = redisTemplate.opsForValue();
            // 将查询出来的数据写入缓存
            try {
                valueOperations.set(key,userPage,30000, TimeUnit.MILLISECONDS);
            } catch (Exception e) {
                log.error("redis key set error", e);
            }
        }
    }
}
</code></pre> 
<ul><li>定时任务添加缓存成功✔ </li></ul> 
<p class="img-center"><img alt="" height="339" src="https://images2.imgbox.com/00/be/dIJcUj3x_o.png" width="668"></p> 
<h3 id="2.%20%E5%85%B6%E4%BB%96">2. 其他</h3> 
<ul><li>Quartz：独立于 Spring 的定时任务框架</li><li>XXL-Job 等分布式任务调度平台</li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/be88185b7a58ca7ca47c6b8ab0ce0874/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">linux的vsftpd服务（基础小白必学）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/721e70d282d73e81f02ba631add95cf0/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">数据结构之二叉树的性质与存储结构</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>