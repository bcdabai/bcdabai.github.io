<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>超硬核！一篇文章彻底搞懂【二叉树】及的前序、中序、后序三种遍历 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="超硬核！一篇文章彻底搞懂【二叉树】及的前序、中序、后序三种遍历" />
<meta property="og:description" content="树的概念与特性 1 树的概念 树是类似于链表的线性结构，但又是一种典型的非线性的结构；树具有很强的层级性，相比于线性结构，其时间复杂度更低，效率更高；读者可以联系，生活中看见的树； 2 树的术语 先看一张树的图片如下，去除图中的箭头和相关术语，树就是一种非线性的层级结构； 树的相关术语如下：
根节点： 没有父节点的节点，上图 A节点；兄弟节点：具有相同的父节点的孩子节点；比如 F,G互为兄弟节点；叶子节点：没有孩子节点的节点；比如D,F,G,I,J；祖先节点与孙节点：如果存在根节点A到节点 J 的路径，并且存在节点E出现在该路径上，则称E是节点 J 的祖先节点，J是 E 的孙节点；A B E H 都可以算是 J 的祖先节点；节点大小：节点的大小是指节点拥护的孙节点个数，包括自身； 比如E 节点大小为4；节点的深度：指根节点到节点的路径长度 ； 比如 (A-B-D ), 两个 链，即D节点的深度为2；节点的高度：指节点到最深节点的 路径长度；比如 (E - H -J), 两个链, 即E节点的高度为2；树的层级：具有相同深度的集合称为树的层级；比如 B和C ； 又比如 D,E,F,G树的高度和深度： 树的深度指所有节点中深度的最大值，树的高度指所有节点中高度的最大值；树的高度等于树的深度 3 树的类型 二叉树： 如果一棵树中每个节点有0个或者1个或者2个节点，则称该树为二叉树；故空树也是二叉树；
严格二叉树: 树的每个节点都有左孩子右孩子或者没有孩子；
斜树：斜树的每个节点只有一个孩子；若斜树的每个节点都只有左孩子则称为左斜树，若斜树的每个节点只有右孩子则称为右斜树； 满二叉树：所有的父节点都存在左孩子和右孩子，并且所有的叶子结点都在同一层上，则称该类树为满二叉树 完全二叉树：对于一棵具有n个节点的二叉树按照层级编号，同时，左右孩子按照先左孩子后右孩子编号，如果编号为i的节点与同样深度的满二叉树中编号为i的节点在二叉树中的位置完全相同，则这棵二叉树称为完全二叉树；故满二叉树一定是完全二叉树，反之不成立 2.4满二叉树的性质 满叉树的节点个数: 假设满二叉树层级为k，根据 数学归纳法和等比数列求和公式可得 2^0 &#43; 2^1 &#43;…&#43; 2^k = 2^(k&#43;1) - 1; 推导过程如下图；
满二叉树的叶子节点个数：根据满二叉树的结构可知，第k层就是叶子节点所在的层，故叶子节点个数为 2^k个" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/6a7f8685316508287242ccae57f1f37a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-04-15T10:00:39+08:00" />
<meta property="article:modified_time" content="2020-04-15T10:00:39+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">超硬核！一篇文章彻底搞懂【二叉树】及的前序、中序、后序三种遍历</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="_0"></a>树的概念与特性</h2> 
<h3><a id="1__2"></a>1 树的概念</h3> 
<ul><li>树是类似于链表的线性结构，但又是一种典型的非线性的结构；树具有很强的层级性，相比于线性结构，其时间复杂度更低，效率更高；读者可以联系，生活中看见的树；</li></ul> 
<h3><a id="2__6"></a>2 树的术语</h3> 
<ul><li>先看一张树的图片如下，去除图中的箭头和相关术语，<strong>树就是一种非线性的层级结构</strong>；</li></ul> 
<p><img src="https://images2.imgbox.com/a5/7d/VAaYPosD_o.png" alt="在这里插入图片描述"><br> <strong>树的相关术语如下：</strong></p> 
<ul><li><strong>根节点</strong>： 没有父节点的节点，上图 A节点；</li><li><strong>兄弟节点</strong>：具有相同的父节点的孩子节点；比如 F,G互为兄弟节点；</li><li><strong>叶子节点</strong>：<code>没有孩子节点的节点</code>；比如D,F,G,I,J；</li><li><strong>祖先节点与孙节点</strong>：如果存在根节点A到节点 J 的路径，并且存在节点E出现在该路径上，则称E是节点 J 的祖先节点，J是 E 的孙节点；A B E H 都可以算是 J 的祖先节点；</li><li><strong>节点大小</strong>：节点的大小是指节点<code>拥护的孙节点个数</code>，包括自身； 比如E 节点大小为4；</li><li><strong>节点的深度</strong>：指根节点到节点的<code>路径长度</code> ； 比如 (A-B-D ), 两个 链，即D节点的深度为2；</li><li><strong>节点的高度</strong>：指节点到最深节点的 <code>路径长度</code>；比如 (E - H -J), 两个链, 即E节点的高度为2；</li><li><strong>树的层级</strong>：具有相同深度的集合称为树的层级；比如 B和C ； 又比如 D,E,F,G</li><li><strong>树的高度和深度</strong>： 树的深度指所有节点中深度的最大值，树的高度指所有节点中高度的最大值；<code>树的高度等于树的深度</code></li></ul> 
<h3><a id="3__25"></a>3 树的类型</h3> 
<ul><li> <p>二叉树： 如果一棵树中每个节点有0个或者1个或者2个节点，则称该树为二叉树；故空树也是二叉树；</p> </li><li> <p>严格二叉树: 树的每个节点都有左孩子右孩子或者没有孩子；</p> </li></ul> 
<p><img src="https://images2.imgbox.com/ad/e8/gQNfKhKM_o.png" alt="在这里插入图片描述"></p> 
<ul><li>斜树：斜树的每个节点只有一个孩子；若斜树的每个节点都只有左孩子则称为左斜树，若斜树的每个节点只有右孩子则称为右斜树；</li></ul> 
<p><img src="https://images2.imgbox.com/e4/99/rYUaICe0_o.png" alt="在这里插入图片描述"></p> 
<ul><li>满二叉树：所有的父节点都存在左孩子和右孩子，并且所有的叶子结点都在同一层上，则称该类树为满二叉树</li></ul> 
<p><img src="https://images2.imgbox.com/07/1f/xEAZypR7_o.png" alt="在这里插入图片描述"></p> 
<ul><li>完全二叉树：对于一棵具有n个节点的二叉树<strong>按照层级编号</strong>，同时，<strong>左右孩子按照先左孩子后右孩子编号</strong>，如果编号为i的节点<strong>与</strong>同样深度的满二叉树中编号为i的节点在<strong>二叉树中的位置完全相同</strong>，则这棵二叉树称为完全二叉树；故满二叉树一定是完全二叉树，反之不成立</li></ul> 
<p><img src="https://images2.imgbox.com/ff/26/jF1QCC60_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="24_59"></a>2.4满二叉树的性质</h3> 
<ul><li> <p>满叉树的节点个数: 假设满二叉树层级为k，根据 数学归纳法和等比数列求和公式可得 2^0 + 2^1 +…+ 2^k = 2^(k+1) - 1; 推导过程如下图；</p> </li><li> <p>满二叉树的叶子节点个数：根据满二叉树的结构可知，第k层就是叶子节点所在的层，故叶子节点个数为 2^k个</p> </li></ul> 
<p><img src="https://images2.imgbox.com/d8/ac/M7DTL44B_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="_69"></a>二叉树的实现</h2> 
<h3><a id="_71"></a>二叉树的结构</h3> 
<ul><li>根据二叉树的结构可知，每个节点都可以假设有左孩子和右孩子，则可以对应为 左指针和右指针，并且每个节点上都可以存储值；故经过面向对象的编程思想进行抽象后的类如下</li></ul> 
<pre><code class="prism language-java"><span class="token comment">/**
 * &lt;p&gt;二叉树的结构 &lt;/p&gt;
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TreeNode</span> <span class="token punctuation">{<!-- --></span>

    <span class="token comment">// 左孩子</span>
    <span class="token keyword">private</span> TreeNode leftNode<span class="token punctuation">;</span>
    <span class="token comment">// 右孩子</span>
    <span class="token keyword">private</span> TreeNode rightNode<span class="token punctuation">;</span>
    <span class="token comment">// 存储值</span>
    <span class="token keyword">private</span> Object value<span class="token punctuation">;</span>
    <span class="token comment">// 构造方法</span>
    <span class="token function">TreeNode</span><span class="token punctuation">(</span>Object value<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
   <span class="token comment">// 省略 set get </span>
<span class="token punctuation">}</span>   
</code></pre> 
<ul><li>现在需要实现以下的一颗满二叉树;</li></ul> 
<p><img src="https://images2.imgbox.com/1d/80/4vOlXH8D_o.png" alt="在这里插入图片描述"></p> 
<p><strong>思路如下：</strong></p> 
<ul><li>首先根节点储存1；然后分别储存 左孩子2，右孩子3；</li><li>其次左孩子节点作为父节点，然后分别储存 左孩子4，右孩子5；</li><li>最后右孩子节点作为父节点然后分别储存 左孩子6，右孩子7；</li><li>代码实现如下：</li></ul> 
<pre><code class="prism language-java"> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 初始化树</span>
        TreeNode tree <span class="token operator">=</span> <span class="token function">initTree</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> TreeNode <span class="token function">initTree</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 创建7个节点</span>
        TreeNode treeNode1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        TreeNode treeNode2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        TreeNode treeNode3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        TreeNode treeNode4 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        TreeNode treeNode5 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        TreeNode treeNode6 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        TreeNode treeNode7 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 根据上面思路对节点进行组装</span>
        <span class="token comment">// 组装根节点</span>
        treeNode1<span class="token punctuation">.</span><span class="token function">setLeftNode</span><span class="token punctuation">(</span>treeNode2<span class="token punctuation">)</span><span class="token punctuation">;</span>
        treeNode1<span class="token punctuation">.</span><span class="token function">setRightNode</span><span class="token punctuation">(</span>treeNode3<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 组装左孩子</span>
        treeNode2<span class="token punctuation">.</span><span class="token function">setLeftNode</span><span class="token punctuation">(</span>treeNode4<span class="token punctuation">)</span><span class="token punctuation">;</span>
        treeNode2<span class="token punctuation">.</span><span class="token function">setRightNode</span><span class="token punctuation">(</span>treeNode5<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 组装右孩子</span>
        treeNode3<span class="token punctuation">.</span><span class="token function">setLeftNode</span><span class="token punctuation">(</span>treeNode6<span class="token punctuation">)</span><span class="token punctuation">;</span>
        treeNode3<span class="token punctuation">.</span><span class="token function">setRightNode</span><span class="token punctuation">(</span>treeNode7<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> treeNode1<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

</code></pre> 
<h3><a id="_138"></a>二叉树的遍历与实现</h3> 
<ul><li>二叉树的遍历分为前序遍历，中序遍历，后续遍历；假设 当前节点 为C (Current Node), 左节点为L ,右节点为R；</li></ul> 
<pre><code class="prism language-java">前序遍历：C<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">&gt;</span>L<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">&gt;</span>R
中序遍历：L<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">&gt;</span>C<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">&gt;</span>R
后续遍历：R<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">&gt;</span>C<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">&gt;</span>L
</code></pre> 
<h5><a id="_148"></a>先序遍历的实现</h5> 
<p><strong>思路 ：</strong></p> 
<ul><li>首先访问当前节点；</li><li>其次访问左节点；</li><li>最后访问后节点；</li><li>回到 前图 前序遍历CLR就是 1，2，4，5，3，6，7；</li></ul> 
<pre><code class="prism language-java"> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 初始化树</span>
        TreeNode tree <span class="token operator">=</span> <span class="token function">initTree</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 调用先序遍历</span>
        <span class="token function">preOrderTree</span><span class="token punctuation">(</span>tree<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">/**
     * &lt;p&gt; 先序遍历&lt;/p&gt;
     * @Param [rootNode]
     * @Return void
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">preOrderTree</span><span class="token punctuation">(</span>TreeNode rootNode<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>rootNode<span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token comment">// 值</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>rootNode<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 左孩子</span>
            <span class="token function">preOrderTree</span><span class="token punctuation">(</span>rootNode<span class="token punctuation">.</span><span class="token function">getLeftNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 右孩子</span>
            <span class="token function">preOrderTree</span><span class="token punctuation">(</span>rootNode<span class="token punctuation">.</span><span class="token function">getRightNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

    <span class="token punctuation">}</span>
</code></pre> 
<ul><li>输出</li></ul> 
<pre><code class="prism language-java"><span class="token number">1</span>
<span class="token number">2</span>
<span class="token number">4</span>
<span class="token number">5</span>
<span class="token number">3</span>
<span class="token number">6</span>
<span class="token number">7</span>
</code></pre> 
<ul><li>先序遍历实现为线性实现，时间复杂度为O(n)</li></ul> 
<h5><a id="_195"></a>中序遍历的实现</h5> 
<p><strong>思路 ：</strong></p> 
<ul><li>首先访问左节点</li><li>其次访问当前节点</li><li>最后访问右节点</li><li>回到 前图中序遍历的结果是 4，2，5，1， 6，3，7</li></ul> 
<pre><code class="prism language-java"> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 初始化树</span>
        TreeNode tree <span class="token operator">=</span> <span class="token function">initTree</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 调用中序遍历</span>
        <span class="token function">middleOrderTree</span><span class="token punctuation">(</span>tree<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">/**
     * &lt;p&gt; 中序遍历&lt;/p&gt;
     * @Param [rootNode]
     * @Return void
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">middleOrderTree</span><span class="token punctuation">(</span>TreeNode rootNode<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>rootNode<span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token comment">// 左孩子</span>
            <span class="token function">middleOrderTree</span><span class="token punctuation">(</span>rootNode<span class="token punctuation">.</span><span class="token function">getLeftNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 值</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>rootNode<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 右孩子</span>
            <span class="token function">middleOrderTree</span><span class="token punctuation">(</span>rootNode<span class="token punctuation">.</span><span class="token function">getRightNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

    <span class="token punctuation">}</span>
</code></pre> 
<ul><li>输出</li></ul> 
<pre><code class="prism language-java"><span class="token number">4</span>
<span class="token number">2</span>
<span class="token number">5</span>
<span class="token number">1</span>
<span class="token number">6</span>
<span class="token number">3</span>
<span class="token number">7</span>
</code></pre> 
<ul><li>中序遍历实现为线性实现，时间复杂度为O(n)</li></ul> 
<h5><a id="_242"></a>后续遍历的实现</h5> 
<p><strong>思路：</strong></p> 
<ul><li>首先访问左节点</li><li>其次访问右节点</li><li>最后访问当前节点</li><li>回到 前图中序遍历的结果是 4，5，2，6， 7，3，1</li></ul> 
<pre><code class="prism language-java"> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 初始化树</span>
        TreeNode tree <span class="token operator">=</span> <span class="token function">initTree</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 调用后续遍历</span>
        <span class="token function">postOrderTree</span><span class="token punctuation">(</span>tree<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/**
     * &lt;p&gt;后续遍历 &lt;/p&gt;
     * @Param [rootNode]
     * @Return void
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">postOrderTree</span><span class="token punctuation">(</span>TreeNode rootNode<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>rootNode<span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token comment">// 左孩子</span>
            <span class="token function">postOrderTree</span><span class="token punctuation">(</span>rootNode<span class="token punctuation">.</span><span class="token function">getLeftNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 右孩子</span>
            <span class="token function">postOrderTree</span><span class="token punctuation">(</span>rootNode<span class="token punctuation">.</span><span class="token function">getRightNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 值</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>rootNode<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

    <span class="token punctuation">}</span>
</code></pre> 
<ul><li>输出</li></ul> 
<pre><code class="prism language-java"><span class="token number">4</span>
<span class="token number">5</span>
<span class="token number">2</span>
<span class="token number">6</span>
<span class="token number">7</span>
<span class="token number">3</span>
<span class="token number">1</span>
</code></pre> 
<ul><li>后序遍历实现为线性实现，时间复杂度为O(n)</li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/fa65e45d9f1e388b14709c2d74f863a2/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">无迹卡尔曼滤波 (Unscented Kalman Filter)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/625a6e1c3bd9bf79a8ca4aea260bb08e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">MySql面试题（总结最全面的面试题！！！）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>