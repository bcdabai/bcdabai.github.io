<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Linux 系统基础知识 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Linux 系统基础知识" />
<meta property="og:description" content="温故而知新，可以为师矣。好久没有再次系统学习 Linux 相关的知识了，总结回顾一下，为了更好的前进。
一、环境搭建 环境的配置，是我们学习的基础。环境配置会用到的工具及环境：
(1) Inteelij IDEA 2019 &#43; BashSupport插件 (2) Ubuntu 18.04（用的腾讯云服务器） (3) Git Bash 1.全局配置bash解释器 2.配置bash shell 脚本运行解释器 二、Linux 文件 【GitHub示例】
1. Linux 内核的四种功能 （1）内存管理 默认情况下，运行在Linux系统上的每个进程都有各自的内存页面；进程不能访问其他进程正在使用的内存页面。 内核维护着自己的内存区域 用户进程不能访问内核进程的内存 可以创建一些共享内存页面，多个进程可在同一块共用内存区域进行读取和写入操作；内核负责维护和管理这块共用内存区域并控制每个进程访问这块共享区域。 内核的系统内存管理主要是对1.物理内存和虚拟内存（交换空间）2.共享内存的管理 （2）软件程序管理 内核创建第一个进程（init进程）来启动系统上所有其他进程 内核启动时，将init加载到虚拟内存中。内核在启动任何其他进程时，都会在虚拟内存中给新进程分配一块专有区域来存储该进程用到的数据和代码 系统开机自动启动的进程通常位于专门的文件 /etc/inittab 或 /etc/init.d目录中 运行级决定init进程运行/etc/inittab文件 或者 /etc/rcX.d目录中定义好的某些特定类型的进程。 （3）硬件管理 Linux系统将硬件设备（需要在内核代码中加入其驱动程序代码）当成特殊的文件，称为设备文件，分三种： 字符型 块 网络 （4）文件系统管理 Linux内核支持多种不同类型的文件系统来从硬盘中读取或写入数据。 内核必须在编译时就加入对所有可能用到的文件系统的支持。 Linux内核采用虚拟文件系统（VFS）作为和每个文件系统交互的标准接口。 Linux的文件管理系统为： ext4文件管理系统 文件管理系统：Fat文件管理系统 Windows的文件管理系统：NTFS文件管理系统 【GitHub示例】
#!/usr/bin/env bash # @File : ${NAME} # @Time : 2019/9/9 7:55 # @Author : Crisimple # @Github : https://crisimple." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/269ec8427c688564beb8261e22c4b3d9/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-09-29T17:49:07+08:00" />
<meta property="article:modified_time" content="2019-09-29T17:49:07+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Linux 系统基础知识</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>  温故而知新，可以为师矣。好久没有再次系统学习 Linux 相关的知识了，总结回顾一下，为了更好的前进。</p> 
<h2><a id="_2"></a>一、环境搭建</h2> 
<p>  环境的配置，是我们学习的基础。环境配置会用到的工具及环境：</p> 
<pre><code>(1) Inteelij IDEA 2019 + BashSupport插件
(2) Ubuntu 18.04（用的腾讯云服务器）
(3) Git Bash
</code></pre> 
<h3><a id="1bash_11"></a>1.全局配置bash解释器</h3> 
<p><img src="https://images2.imgbox.com/b8/3c/3nTe7LEJ_o.png" alt="全局配置bash解释器"></p> 
<h3><a id="2bash_shell__14"></a>2.配置bash shell 脚本运行解释器</h3> 
<p><img src="https://images2.imgbox.com/d5/c9/EX2BZjTs_o.png" alt="IntelliJ IDEA 配置运行 bash shell脚本"></p> 
<h2><a id="Linux__17"></a>二、Linux 文件</h2> 
<p>【<strong><a href="https://github.com/Crisimple/Linux/commit/0ebc135473c370d8b4b097f6dc799e9bb0d8f864">GitHub示例</a></strong>】</p> 
<h3><a id="1_Linux__19"></a>1. Linux 内核的四种功能</h3> 
<pre><code>（1）内存管理
        默认情况下，运行在Linux系统上的每个进程都有各自的内存页面；进程不能访问其他进程正在使用的内存页面。
        内核维护着自己的内存区域
        用户进程不能访问内核进程的内存
        可以创建一些共享内存页面，多个进程可在同一块共用内存区域进行读取和写入操作；内核负责维护和管理这块共用内存区域并控制每个进程访问这块共享区域。
        内核的系统内存管理主要是对1.物理内存和虚拟内存（交换空间）2.共享内存的管理
（2）软件程序管理
        内核创建第一个进程（init进程）来启动系统上所有其他进程
        内核启动时，将init加载到虚拟内存中。内核在启动任何其他进程时，都会在虚拟内存中给新进程分配一块专有区域来存储该进程用到的数据和代码
        系统开机自动启动的进程通常位于专门的文件 /etc/inittab 或 /etc/init.d目录中
        运行级决定init进程运行/etc/inittab文件 或者 /etc/rcX.d目录中定义好的某些特定类型的进程。
（3）硬件管理
        Linux系统将硬件设备（需要在内核代码中加入其驱动程序代码）当成特殊的文件，称为设备文件，分三种：
            字符型
            块
            网络
（4）文件系统管理
        Linux内核支持多种不同类型的文件系统来从硬盘中读取或写入数据。
        内核必须在编译时就加入对所有可能用到的文件系统的支持。
        Linux内核采用虚拟文件系统（VFS）作为和每个文件系统交互的标准接口。
        Linux的文件管理系统为：
            ext4文件管理系统
            文件管理系统：Fat文件管理系统
            Windows的文件管理系统：NTFS文件管理系统
</code></pre> 
<p>【<strong><a href="https://github.com/Crisimple/Linux/commit/e0ab09535c68601b3dd83cb8955dc9a432579c15">GitHub示例</a></strong>】</p> 
<pre><code class="prism language-bash"><span class="token comment">#!/usr/bin/env bash</span>
<span class="token comment"># @File    :   ${NAME}</span>
<span class="token comment"># @Time    :   2019/9/9 7:55</span>
<span class="token comment"># @Author  :   Crisimple</span>
<span class="token comment"># @Github :    https://crisimple.github.io/</span>
<span class="token comment"># @Contact :   Crisimple@foxmail.com</span>
<span class="token comment"># @License :   (C)Copyright 2017-2019, Micro-Circle</span>
<span class="token comment"># @Desc    :   None</span>


<span class="token comment"># Linux 内核的四种功能</span>

<span class="token comment"># （1）内存管理</span>
<span class="token comment"># 查看虚拟内存的当前状态</span>
<span class="token function">cat</span> /proc/meminfo
<span class="token comment"># 查看当前系统版本</span>
<span class="token function">cat</span> /etc/issue


<span class="token comment"># （2）软件程序管理</span>
<span class="token comment"># Linux内核创建第一个进程，称之为初始进程，该进程可在系统上启动所有其他进程（在Linux系统上正在运行的程序）</span>
<span class="token function">cat</span> /etc/inittabs   <span class="token comment">#进程表</span>
<span class="token comment"># 查看Linux系统中当前运行的进程</span>
<span class="token comment"># PS，是Linux系统命令之一，是在Linux中是查看进程的命令。ps查看正处于Running的进程，ps aux查看所有的进程。</span>
<span class="token comment"># 参数如下:</span>
<span class="token comment">#       -e 显示所有进程。</span>
<span class="token comment">#       -f 全格式。</span>
<span class="token comment">#       -h 不显示标题。</span>
<span class="token comment">#       -l 长格式。</span>
<span class="token comment">#       -w 宽输出。</span>
<span class="token comment">#       a 显示终端上的所有进程，包括其他用户的进程。</span>
<span class="token comment">#       r 只显示正在运行的进程。</span>
<span class="token comment">#       x 显示没有控制终端的进程。</span>
<span class="token comment">#       --help 显示帮助信息。</span>
<span class="token comment">#       --version 显示该命令的版本信息。</span>
<span class="token function">ps</span> -ax  <span class="token comment"># 查看全部进程</span>
<span class="token function">ps</span> -ef  <span class="token comment"># 查看全格式的全部进程</span>
<span class="token function">ps</span> -ef <span class="token operator">|</span> <span class="token function">grep</span> <span class="token string">"进程名"</span> <span class="token comment"># 查看并筛选 跟进程名有关的进程，该进程名可以是进程的全部或者部分</span>

<span class="token comment"># （3）硬件管理</span>

<span class="token comment"># （4）文件系统管理</span>

</code></pre> 
<h3><a id="2__bash_93"></a>2. 文件处理相关 bash</h3> 
<h4><a id="21__shell_95"></a>2.1 启动 shell</h4> 
<pre><code class="prism language-bash"><span class="token comment"># (1) 查看系统用户账号组成列表，不同位分别代表：</span>
<span class="token comment">#      用户名、用户密码、用户的系统用户ID编号、用户的系统组ID编号、用户全名、用户的默认主目录、用户的默认shell程序</span>
<span class="token function">cat</span> /etc/passwd

<span class="token comment"># (2) 修改用户启动项 --- shell 启动时加载项的配置文件</span>
<span class="token comment"># sudo vi /etc/bash.bashrc</span>
<span class="token comment">#       可自定义启动项：如环境的提示语类【echo -e "\t\t ************* WELCOME CRISIMPLE TO BACK HOME ***************"】</span>
<span class="token function">cat</span> /etc/bash.bashrc

<span class="token comment"># (3) 自定义 bash 命令提示符 --- shell 启动后 bash 显示配置文件</span>
<span class="token comment"># sudo vi ~/.bashrc</span>
<span class="token comment"># export PS1="Crisimple@129.28.170.125:~$"</span>
<span class="token function">cat</span> ~/.bashrc
</code></pre> 
<h4><a id="22_Linux__112"></a>2.2 Linux 文件系统</h4> 
<pre><code class="prism language-bash"><span class="token comment">#   /       --- 虚拟目录的根目录</span>
<span class="token comment">#   /bin    --- 二进制目录，存储许多 GUN 用户级别的实用程序</span>
<span class="token comment">#   /boot   --- 引导目录，存储引导文件</span>
<span class="token comment">#   /dev    --- 设备目录，Linux 在该目录中创建设备节点</span>
<span class="token comment">#   /home   --- 主目录，Linux 在该目录中创建用户目录</span>
<span class="token comment">#   /lib    --- 库目录，存储系统和应用程序库文件</span>
<span class="token comment">#   /media  --- 媒体目录，可移动设备媒体常用的挂在点</span>
<span class="token comment">#   /mnt    --- 挂载目录，另一个可移动设备媒体常用的挂在点</span>
<span class="token comment">#   /opt    --- 可选目录，常用于存储可选软件包</span>
<span class="token comment">#   /root   --- 根目录</span>
<span class="token comment">#   /sbin   --- 系统二进制目录，存储许多 GUN 管理级别的实用程序</span>
<span class="token comment">#   /temp   --- 临时文件，可以在目录中创建或销毁临时工作文件</span>
<span class="token comment">#   /usr    --- 用户安装软件的目录</span>
<span class="token comment">#   /var    --- 可变目录，用于经常更改的文件，如日志文件</span>

</code></pre> 
<h4><a id="23__131"></a>2.3 文件过滤输出显示</h4> 
<pre><code class="prism language-bash"><span class="token function">ls</span> -l --time<span class="token operator">=</span>atime file_name        <span class="token comment"># 查看文件的访问时间</span>
<span class="token function">ls</span> -l file_*                        <span class="token comment"># 【*代表零个或多个字符】查看文件名开头为 file_ 的所有文件</span>
<span class="token function">ls</span> -l file_?                        <span class="token comment"># 【?代表一个字符】查看文件名开头为 file_ 的所有文件</span>
<span class="token function">ls</span> -l file_<span class="token punctuation">[</span>ai<span class="token punctuation">]</span>pt                   <span class="token comment"># 文件扩展[]中的a和i字符都匹配</span>
<span class="token function">ls</span> -l file_<span class="token punctuation">[</span>a-i<span class="token punctuation">]</span>pt                   <span class="token comment"># 文件扩展[]中的a-i字符都匹配</span>
<span class="token function">ls</span> -F                               <span class="token comment"># 查看区分文件和目录</span>
<span class="token function">ls</span> -a                               <span class="token comment"># 显示所有文件和目录，包括隐藏文件和目录</span>
<span class="token function">ls</span> -FR                              <span class="token comment"># 显示文件和文件的递归项</span>
<span class="token function">ls</span> -l
<span class="token comment"># 显示长列表</span>
<span class="token comment">#   文件类型【目录：d；文件：-；字符型文件：c；或块设备：b】</span>
<span class="token comment">#   文件权限</span>
<span class="token comment">#   文件的硬链接总数</span>
<span class="token comment">#   文件属主的用户名</span>
<span class="token comment">#   文件属主的组名</span>
<span class="token comment">#   文件的大小（以直接为单位）</span>
<span class="token comment">#   文件的上次修改时间</span>
<span class="token comment">#   文件名或目录名</span>
</code></pre> 
<h4><a id="24__153"></a>2.4 处理文件</h4> 
<pre><code class="prism language-bash"><span class="token comment"># (1) 创建文件</span>
<span class="token function">touch</span> create_file
<span class="token comment"># (2) 复制文件</span>
<span class="token function">cp</span> create_file copy_create_file
<span class="token function">cp</span> -i source_file copy_create_file
<span class="token comment"># (3) 链接文件</span>
    <span class="token comment"># ·符号链接---两个通过符号链接在一起的文件，彼此的内容并不相同，也就是两个文件</span>
    <span class="token function">ln</span> -s create_file copy_create_file
    <span class="token comment"># ·硬链接---会创建独立的虚拟文件，其中包含了原始文件的信息及位置。但是它们从根本上而言是同一个文件。</span>
    <span class="token function">ln</span> create_file copy_create_file
<span class="token comment"># (4) 重命名文件 --- inode编号和时间戳保持不变</span>
<span class="token function">mv</span> create_file mv_create_file
<span class="token function">ls</span> -il mv_create_file
<span class="token comment"># (5) 删除文件</span>
<span class="token function">rm</span> -i mv_create_file
<span class="token function">ls</span> -l mv_create_file
<span class="token function">mkdir</span> create_floder
<span class="token function">rm</span> -i rf create_floder

</code></pre> 
<h4><a id="25__176"></a>2.5 处理目录</h4> 
<pre><code class="prism language-bash"><span class="token comment"># （1）创建目录</span>
<span class="token comment">#       创建但目录</span>
        <span class="token function">mkdir</span> create_floder_two
        <span class="token function">ls</span> -ld create_floder_two
<span class="token comment">#       创建多个目录和子目录</span>
        <span class="token function">mkdir</span> -p test1/test2/test3
        <span class="token function">ls</span> -R test1
<span class="token comment"># (2) 删除目录</span>
<span class="token function">touch</span> new_dir/my_file
<span class="token function">ls</span> -li new_dir/
<span class="token function">rm</span> -i new_dir/my_file
<span class="token function">ls</span> -ld new_dir
<span class="token function">rm</span> -rf new_dir/my_file
<span class="token function">ls</span> -ld new_dir
</code></pre> 
<h4><a id="26__194"></a>2.6 查看文件内容</h4> 
<pre><code class="prism language-bash"><span class="token comment"># (1) 查看文件类型</span>
<span class="token function">touch</span> new_file
<span class="token function">file</span> new_file
<span class="token function">mkdir</span> new_dir
<span class="token function">file</span> new_dir
<span class="token comment"># (2) 查看整个文件</span>
    <span class="token function">cat</span> new_file
    <span class="token comment"># -n 参数给所有行加上行号</span>
    <span class="token function">cat</span> -n new_file
    <span class="token comment"># -b 参数只给有文本的行加上行号</span>
    <span class="token function">cat</span> -b new_file
    <span class="token comment"># 不然制表符出现使用参数 —T</span>
    <span class="token comment"># -T参数会用^I字符组合去替换文中的所有制表符。</span>
    <span class="token function">cat</span> -T new_file
    <span class="token comment"># 分页文件查看</span>
    <span class="token function">more</span> /etc/bashrc.bash
    <span class="token comment"># 分屏显示文件查看</span>
    <span class="token function">less</span> /etc/bashrc.bash
<span class="token comment"># (3) 查看部分文件</span>
    <span class="token comment"># tail 显示文件最后几行的内容，默认情况下显示文件末尾的10行</span>
    <span class="token function">tail</span> new_file
    <span class="token comment"># tail -n 参数控制显示文件的第多少行的显示</span>
    <span class="token function">tail</span> -2 new_file
    <span class="token comment"># tail -f 实时监测系统日志</span>
    <span class="token function">tail</span> -f new_file.log
    <span class="token comment"># ---------------------------</span>
    <span class="token comment"># tail 显示文件前几行的内容，默认情况下显示文件开始的10行</span>
    <span class="token function">head</span> new_file
    <span class="token comment"># head -n 参数控制显示文件的第多少行的显示</span>
    <span class="token function">head</span> -2 new_file
</code></pre> 
<hr> 
<h2><a id="Bash_shell_229"></a>三、Bash shell</h2> 
<p>  shell命令有常用的三种风格形式：</p> 
<pre><code>（1）Unix 类型参数，前面有一短划线（-A	显示所有进程）
（2）BSD 类型参数，前面没有有短划线（T	显示与该终端的相关的所有进程）
（3）GNU长参数，前面有双短划线（--forest  在层次结构清单中显示进程，以显示父进程）
</code></pre> 
<p>【<strong><a href="https://github.com/Crisimple/Linux/commit/1361dceaad86dc7fc7087f0377caab3b4761247e">GitHub示例</a></strong>】</p> 
<h3><a id="1_237"></a>1.监测程序</h3> 
<h4><a id="11__238"></a>1.1 探测进程</h4> 
<pre><code class="prism language-bash"><span class="token comment"># 显示进程之间的层次信息</span>
<span class="token function">ps</span> --forest
<span class="token comment"># 显示系统上的进程，并扩展输出</span>
<span class="token function">ps</span> -ef
<span class="token comment"># 显示帮助信息</span>
<span class="token function">ps</span> --help
<span class="token comment"># 显示调试信息</span>
<span class="token function">ps</span> --info
<span class="token comment"># 显示 ps 程序的版本</span>
<span class="token function">ps</span> --version
<span class="token comment"># 显示所有进程并进行过滤显示</span>
<span class="token function">ps</span> -aux <span class="token operator">|</span> <span class="token function">grep</span> PID
<span class="token comment"># 长格式输出，长格式输出的各参数的含义</span>
<span class="token function">ps</span> -l
<span class="token comment">#       F：内核分配给进程的系统标记</span>
<span class="token comment">#       S：进程状态【O-正在进行；S-休眠；R-可运行，正在等待；Z-进程僵化；T-停止】</span>
<span class="token comment">#       PRI：进程的优先级（越大的数字代表越低的优先级）</span>
<span class="token comment">#       NI：谦让度值用来参与决定优先级</span>
<span class="token comment">#       ADDR：进程的内存地址</span>
<span class="token comment">#       SZ：假如进程被换出，所需交换空间的大致大小</span>
<span class="token comment">#       WCHAN：进程休眠的内核函数的地址</span>
</code></pre> 
<h4><a id="12__262"></a>1.2 实时监测进程</h4> 
<pre><code class="prism language-bash"><span class="token comment"># 显示实时进程的概要信息</span>
<span class="token function">top</span>
<span class="token comment">#   top 输出列表字段信息含义</span>
<span class="token comment">#   PID：进程的ID</span>
<span class="token comment">#   USER：进程属主的名字</span>
<span class="token comment">#   PR：进程的优先级</span>
<span class="token comment">#   NI：进程的谦让度值</span>
<span class="token comment">#   VIRT：进程占用的虚拟内存的总量</span>
<span class="token comment">#   RES：进程占用的物理内存总量</span>
<span class="token comment">#   SHR：进程和其他进程共享的内存总量</span>
<span class="token comment">#   S：进程的状态【D-休眠状态；R-运行状态；S-休眠状态；T-停止状态；Z-僵化状态】</span>
<span class="token comment">#   %CPU：进程使用的CPU时间比例</span>
<span class="token comment">#   %MEM：进程使用的内存占可用内存的比例</span>
<span class="token comment">#   TIME+：自进程启动到目前为止的CPU时间总量</span>
<span class="token comment">#   COMMAND：进程所对应的命令行名称，也就是启动的程序名</span>
    <span class="token comment"># 在 top 实时监测可使用的命令</span>
    t       <span class="token comment"># 切换到 cpu 信息行显示</span>
    o       <span class="token comment"># 更改信息列的显示顺序</span>
    k       <span class="token comment"># 杀死特定的进程</span>
    q       <span class="token comment"># 退出 top 命令</span>
</code></pre> 
<h4><a id="13__286"></a>1.3 结束进程</h4> 
<p>  Linux进程信号：</p> 
<table><thead><tr><th>信号</th><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>HUG</td><td>挂起</td></tr><tr><td>2</td><td>INT</td><td>中断</td></tr><tr><td>3</td><td>QUIT</td><td>结束运行</td></tr><tr><td>9</td><td>KILL</td><td>无条件终止</td></tr><tr><td>11</td><td>SEGV</td><td>段错误</td></tr><tr><td>15</td><td>TERM</td><td>尽可能终止</td></tr><tr><td>17</td><td>STOP</td><td>无条件停止运行，但不终止</td></tr><tr><td>18</td><td>TSTP</td><td>停止或暂停，但继续在后台运行</td></tr><tr><td>19</td><td>CONT</td><td>在STOP或TSTP之后恢复执行</td></tr></tbody></table> 
<pre><code class="prism language-bash"><span class="token comment"># kill 命令</span>
<span class="token function">kill</span> PID
<span class="token comment"># 如果要强制终止，-s参数支持指定其他信号（用信号名或信号值）</span>
<span class="token function">kill</span> -s HUP PID
<span class="token comment"># killall 命令</span>
<span class="token function">kill</span> <span class="token string">"进程名(支持通配符，如：http*)"</span>
</code></pre> 
<h3><a id="2_310"></a>2.监测磁盘空间</h3> 
<h4><a id="21__311"></a>2.1 挂载存储媒体</h4> 
<p>  Linux文件系统将所有的磁盘都并入一个虚拟目录下。在使用新的存储媒<br> 体之前，需要把它放到虚拟目录下。这项工作称为挂载（mounting）。</p> 
<pre><code class="prism language-bash"><span class="token comment"># 显示当前系统挂载的设备列表</span>
<span class="token function">mount</span>
<span class="token comment"># type参数指定了磁盘被格式化的文件系统类型(vfat/ntfs/iso9660)</span>
<span class="token function">mount</span> -t <span class="token function">type</span> device directory
<span class="token comment"># mount 挂载参数详解</span>
    <span class="token comment"># -a 挂载/etc/fstab文件中指定的所有文件系统  "</span>
    <span class="token comment"># -f 使mount命令模拟挂载设备，但并不真的挂载 "</span>
    <span class="token comment"># -F 和-a参数一起使用时，会同时挂载所有文件系统 "</span>
    <span class="token comment"># -v 详细模式，将会说明挂载设备的每一步 "</span>
    <span class="token comment"># -I 不启用任何/sbin/mount.filesystem下的文件系统帮助文件 "</span>
    <span class="token comment"># -l 给ext2、ext3或XFS文件系统自动添加文件系统标签 "</span>
    <span class="token comment"># -n 挂载设备，但不注册到/etc/mtab已挂载设备文件中 "</span>
    <span class="token comment"># -p num 进行加密挂载时，从文件描述符num中获得密码短语 "</span>
    <span class="token comment"># -s 忽略该文件系统不支持的挂载选项 "</span>
    <span class="token comment"># -r 将设备挂载为只读的 "</span>
    <span class="token comment"># -w 将设备挂载为可读写的（默认参数） "</span>
    <span class="token comment"># -L label 将设备按指定的label挂载 "</span>
    <span class="token comment"># -U uuid 将设备按指定的uuid挂载 "</span>
    <span class="token comment"># -O 和-a参数一起使用，限制命令只作用到特定的一组文件系统上 "</span>
    <span class="token comment"># -o 给文件系统添加特定的选项 "</span>
<span class="token comment"># umount命令 umount命令支持通过设备文件或者是挂载点来指定要卸载的设备。如果有任何程序正在使用设备上的文件，系统就不会允许你卸载它</span>
<span class="token function">umount</span> <span class="token punctuation">[</span>directory <span class="token operator">|</span> device <span class="token punctuation">]</span>
<span class="token comment"># 如果在卸载设备时，系统提示设备繁忙，无法卸载设备，通常是有进程还在访问该设备或使用该设备上的文件。这时可用lsof命令获得使用它的进程信息，然后在应用中停止使用该设备或停止该进程。</span>
<span class="token function">lsof</span> /path/to/device/node
<span class="token comment"># 或者</span>
<span class="token function">lsof</span> /path/to/mount/point
</code></pre> 
<h4><a id="22__df__343"></a>2.2 使用 df 命令</h4> 
<pre><code class="prism language-bash"><span class="token comment"># 2.2 使用 df 命令</span>
<span class="token comment"># df  --- df命令可以让你很方便地查看所有已挂载</span>
<span class="token function">df</span>
<span class="token comment"># 相关字段的含义：</span>
<span class="token comment">#        设备的设备文件位置；</span>
<span class="token comment">#        能容纳多少个1024字节大小的块；</span>
<span class="token comment">#        已用了多少个1024字节大小的块；</span>
<span class="token comment">#        还有多少个1024字节大小的块可用；</span>
<span class="token comment">#        已用空间所占的比例；</span>
<span class="token comment">#        设备挂载到了哪个挂载点上。</span>
<span class="token comment"># 参数是-h，它会把输出中的磁盘空间按照用户易读的形式显示</span>
<span class="token function">df</span> -h
</code></pre> 
<h4><a id="23__du__359"></a>2.3 使用 du 命令</h4> 
<pre><code class="prism language-bash"><span class="token comment"># 2.3 使用 du 命令</span>
<span class="token comment"># du命令会显示当前目录下所有的文件、目录和子目录的磁盘使用情况，它会以磁盘块为单位来表明每个文件或目录占用了多大存储空间</span>
<span class="token function">du</span>
<span class="token comment"># 相关字段的含义：</span>
<span class="token comment">#        -c：显示所有已列出文件总的大小。</span>
<span class="token comment">#        -h：按用户易读的格式输出大小，即用K替代千字节，用M替代兆字节，用G替代吉字节。</span>
<span class="token comment">#        -s：显示每个输出参数的总计</span>
</code></pre> 
<h3><a id="3_370"></a>3.处理数据文件</h3> 
<pre><code class="prism language-bash"><span class="token comment"># 3.1 排序数据</span>
<span class="token comment"># 对数据进行排序-默认语言的排序规则对文本文件中的数据行排序</span>
<span class="token comment"># -n按值排序；-M按月排序</span>
<span class="token function">sort</span>
<span class="token comment"># -----------------------------------------------------------------------------------------</span>
<span class="token comment"># 3.2 搜索数据</span>
<span class="token comment"># grep [options] pattern [file]；-v反向搜索；-n显示匹配模式的行所在的行号；"</span>
<span class="token comment"># grep 要搜索的内容 目标文件</span>
<span class="token function">grep</span> -h maven ./ --max-depth<span class="token operator">=</span>1
<span class="token comment"># grep命令可以对文件进行搜索</span>
<span class="token function">grep</span> aa file1   <span class="token comment"># 搜索包含 aa 的文本</span>
<span class="token function">grep</span> 1 file1   <span class="token comment"># 搜索包含 t 的文本</span>
<span class="token comment"># 反转搜索</span>
<span class="token function">grep</span> -v t file1
<span class="token comment"># 想要获取与模式匹配的数据所在的行号，可以使用 -n</span>
<span class="token function">grep</span> -n t file1
<span class="token comment"># 如果只需要了解有多少包含匹配模式可以用-c</span>
<span class="token function">grep</span> -c t file1
<span class="token comment"># 如果需要指定多个匹配模式，可以使用-e</span>
<span class="token function">grep</span> -e t file1 -e 1 file1
<span class="token comment"># 查找包含t或f字符的数据</span>
<span class="token function">grep</span> <span class="token punctuation">[</span>tf<span class="token punctuation">]</span> file1
<span class="token comment"># -----------------------------------------------------------------------------------------</span>
<span class="token comment"># 3.3 压缩数据-----压缩工具：gzip(.gz);zip(.zip)"</span>
<span class="token comment">#       gzip: 用来压缩文件"</span>
<span class="token comment">#       gzcat: 用来查看压缩过的文本文件的内容"</span>
<span class="token comment">#       gunzip: 用来解压文件"</span>
<span class="token comment"># bxip2工具</span>
<span class="token comment">#     bxip2：用于压缩文件</span>
<span class="token comment">#     bzcat：用于显示已压缩的的文件内容</span>
<span class="token comment">#     bunzip2：用于解压.bz2文件</span>
<span class="token comment">#     bzip2recover:用于尝试恢复受损的压缩文件</span>
<span class="token comment">#     $bzip2 文件名</span>
<span class="token comment"># gzip工具</span>
<span class="token comment">#     gzip:  用于压缩文件</span>
<span class="token comment">#     gzcat：用于显示已压缩的的文件内容</span>
<span class="token comment">#     gunzip：用于解压文件</span>
<span class="token comment">#     gzip 文件名</span>
<span class="token comment">#     gzip 可以指定多个文件或者使用通配符一次压缩多个文件</span>
<span class="token comment">#     gzip my*</span>
<span class="token comment"># zip工具</span>
<span class="token comment">#  zip：用于创建包含列出文件和目录的压缩文件</span>
<span class="token comment">#  zipcloak：用于创建包含列出文件和目录的压缩加密文件</span>
<span class="token comment">#  zipnote：用于提取zip文件中注释</span>
<span class="token comment">#  z ipsplit：用于将zip文件分割成指定大小的多个小文件</span>
<span class="token comment">#  unzip：用于提取压缩zip文件中的文件和目录</span>
<span class="token comment">#  zip工具的强之处在于能够将文件的整个目录压缩为一个文件</span>
<span class="token comment">#  zip -r testzip test</span>
<span class="token comment"># -----------------------------------------------------------------------------------------</span>
<span class="token comment"># 3.4 归档数据---tar命令【格式：tar function [options] object1 object2 ... 】"</span>
<span class="token comment">#  tar命令含义：</span>
<span class="token comment"># -A --concatenate 将一个已有tar归档文件追加到另一个已有tar归档文件"</span>
<span class="token comment"># -c --create 创建一个新的tar归档文件"</span>
<span class="token comment"># -d --diff 检查归档文件和文件系统的不同之处"</span>
<span class="token comment"># --delete 从已有tar归档文件中删除 -r"</span>
<span class="token comment"># --append 追加文件到已有tar归档文件末尾"</span>
<span class="token comment"># -t --list 列出已有tar归档文件的内容"</span>
<span class="token comment"># -u --update 将比tar归档文件中已有的同名文件新的文件追加到该tar归档文件中"</span>
<span class="token comment"># -x --ext</span>
<span class="token comment"># -C dir 切换到指定目录 "</span>
<span class="token comment"># -f file 输出结果到文件或设备file "</span>
<span class="token comment"># -j 将输出重定向给bzip2命令来压缩内容 "</span>
<span class="token comment"># -p 保留所有文件权限 "</span>
<span class="token comment"># -v 在处理文件时显示文件 "</span>
<span class="token comment"># -z 将输出重定向给gzip命令来压缩内容 "</span>
<span class="token comment">#  tar命令用于将文件归档</span>
<span class="token function">tar</span> <span class="token keyword">function</span> <span class="token punctuation">[</span>options<span class="token punctuation">]</span> object1 object2 <span class="token punctuation">..</span>.
<span class="token comment">#  创建一个名称为test.tar的归档文件，其中包含test1目录和test2目录的内容</span>
<span class="token function">tar</span> -cvf test.tar test1/ test2
<span class="token comment">#  列出文件内容但不解压</span>
<span class="token function">tar</span> -tf test.tar
<span class="token comment">#  解压文件内容</span>
<span class="token function">tar</span> -xvf test.tar
</code></pre> 
<hr> 
<h2><a id="_shell_448"></a>四、理解 shell</h2> 
<p>【<strong><a href="https://github.com/Crisimple/Linux/commit/9d0594bdf17beeaab52c8dc6202ee284ff566c1d">GitHub示例</a></strong>】</p> 
<h3><a id="1_shell_450"></a>1. shell的类型</h3> 
<pre><code class="prism language-bash"><span class="token comment">#!/usr/bin/env bash</span>
<span class="token comment"># @File    :   04_understand_shell.sh</span>
<span class="token comment"># @Time    :   2019/9/14 10:29</span>
<span class="token comment"># @Author  :   Crisimple</span>
<span class="token comment"># @Github :    https://crisimple.github.io/</span>
<span class="token comment"># @Contact :   Crisimple@foxmail.com</span>
<span class="token comment"># @License :   (C)Copyright 2017-2019, Micro-Circle</span>
<span class="token comment"># @Desc    :   None</span>


<span class="token comment"># 1. shell的类型</span>
<span class="token comment"># 查看用户的默认shell程序</span>
<span class="token function">cat</span> /etc/passwd
<span class="token function">ls</span> /bin/bash
<span class="token comment"># 启动bash shell</span>
/bin/bash
<span class="token function">bash</span>
<span class="token keyword">exit</span>
<span class="token comment">#   Shell 的类型</span>
<span class="token comment">#       Ubuntu 的 GUN bash shell</span>
<span class="token comment">#       CentOS 的 tcsh shell</span>
<span class="token comment">#       Debian 的 ash shell</span>
</code></pre> 
<h3><a id="2_shell_476"></a>2. shell的父子关系</h3> 
<p>  在CLI提示符后输入/bin/bash命令或其他等效的bash命令时，会创建一个新的shell程序。这个shell程序被称为子shell（child shell）。子shell也拥有CLI提示符，同样会等待命令输入。子 shell并非真正的多进程处理，因为终端控制着子shell的I/O。</p> 
<pre><code class="prism language-bash"><span class="token function">ps</span> -f
<span class="token function">bash</span>
<span class="token function">bash</span>
<span class="token function">bash</span>
<span class="token comment"># 展示 shell 之间的嵌套结构</span>
<span class="token function">ps</span> --forest
<span class="token comment"># 通过 PPID 列可以显示出是谁的父进程</span>
<span class="token function">ps</span> -f
<span class="token comment"># 退出进程</span>
<span class="token keyword">exit</span>
</code></pre> 
<h4><a id="21__490"></a>2.1 进程列表</h4> 
<pre><code class="prism language-bash"><span class="token comment"># 在一行中指定要一次运行的一系列命令，命令之间用英文分号隔开</span>
 <span class="token function">pwd</span> <span class="token punctuation">;</span> <span class="token function">ls</span> <span class="token punctuation">;</span> <span class="token function">cd</span> /etc <span class="token punctuation">;</span> <span class="token function">pwd</span> <span class="token punctuation">;</span> <span class="token function">cd</span> <span class="token punctuation">;</span> <span class="token function">pwd</span> <span class="token punctuation">;</span> <span class="token function">ls</span>
<span class="token comment"># 实现命令列表实现要将命令放在括号中执行，生成了一个子 shell 来执行对应的命令</span>
<span class="token punctuation">(</span>pwd <span class="token punctuation">;</span> <span class="token function">ls</span> <span class="token punctuation">;</span> <span class="token function">cd</span> /etc <span class="token punctuation">;</span> <span class="token function">pwd</span> <span class="token punctuation">;</span> <span class="token function">cd</span> <span class="token punctuation">;</span> <span class="token function">pwd</span> <span class="token punctuation">;</span> ls<span class="token punctuation">)</span>
<span class="token comment"># 查看 "命令列表" 是否生成了子 shell，使用命令 echo $BASH_SUBSHELL;(如果返回是0，就表明没有子shell；如果返回1或者更大的数字，就表明存在子 shell)</span>
<span class="token punctuation">(</span>pwd<span class="token punctuation">;</span> <span class="token keyword">echo</span> <span class="token variable">$BASH_SUBSHELL</span><span class="token punctuation">)</span>
</code></pre> 
<h4><a id="22__shell__499"></a>2.2 特殊的 shell 用法</h4> 
<p>  在交互式的shell CLI中，还有很多更富有成效的子shell用法。进程列表、协程和管道都利用了子shell。它们都可以有效地在交互式shell中使用。</p> 
<p>  在交互式shell中，一个高效的子shell用法就是使用后台模式。</p> 
<h5><a id="1_503"></a>（1）后台模式</h5> 
<pre><code class="prism language-bash"><span class="token comment"># 会话暂停10s，后台模式等待</span>
<span class="token function">sleep</span> 10<span class="token operator">&amp;</span>
<span class="token comment"># 查看后台作业, -l显示出命令的PID</span>
<span class="token function">jobs</span> -l
</code></pre> 
<h5><a id="2__510"></a>(2) 将进程列表置入后台</h5> 
<pre><code class="prism language-bash"><span class="token punctuation">(</span>sleep 2<span class="token punctuation">;</span> <span class="token keyword">echo</span> <span class="token variable">$BASH_SUBSHELL</span><span class="token punctuation">;</span> <span class="token function">sleep</span> 2<span class="token punctuation">)</span><span class="token operator">&amp;</span>
</code></pre> 
<p>  将进程列表置入后台模式并不是子shell在CLI中仅有的创造性用法。协程就是另一种方法。</p> 
<h5><a id="3__515"></a>(3) 协程</h5> 
<p>  协程可以同时做两件事。它在后台生成一个子shell，并在这个子shell中执行命令。</p> 
<p>  要进行协程处理，得使用 coproc 命令，还有要在子shell中执行的命令。</p> 
<pre><code class="prism language-bash">coproc My_Job <span class="token punctuation">{<!-- --></span>sleep 10<span class="token punctuation">;</span><span class="token punctuation">}</span>
iobs
<span class="token function">ps</span> --forest
</code></pre> 
<h3><a id="3_shell_525"></a>3. shell的内建命令</h3> 
<h4><a id="31__526"></a>3.1 外部命令</h4> 
<p>  外部命令，也被称为文件系统命令，是存在于 bash shell 之外的程序。外部程序通常位于/bin、/usr/bin、/sbin或/usr/sbin/中。</p> 
<p>  当外部命令执行时，会创建出一个子进程，这种操作被称为衍生（forking）；例如：ps</p> 
<pre><code class="prism language-bash"><span class="token function">which</span> <span class="token function">ps</span>
<span class="token function">type</span> -a <span class="token function">ps</span>
<span class="token function">ps</span>
<span class="token function">ps</span> -f
</code></pre> 
<h4><a id="32__537"></a>3.2 内建命令</h4> 
<p>  内建命令和外部命令的区别在于前者不需要使用子进程来执行。它们已经和shell编译成了一体，作为shell工具的组成部分存在。不需要借助外部程序文件来运行。</p> 
<pre><code class="prism language-bash"><span class="token function">type</span> <span class="token function">cd</span>
<span class="token function">type</span> <span class="token keyword">exit</span>
<span class="token comment"># echo 和 pwd 既有内建命令，也有外建命令</span>
<span class="token comment"># which只显示外键命令，type -a 既显示内建命令也显示外键命令</span>
<span class="token function">which</span> <span class="token keyword">echo</span>
<span class="token function">type</span> -a <span class="token keyword">echo</span>
<span class="token function">which</span> <span class="token function">pwd</span>
<span class="token function">type</span> -a <span class="token function">pwd</span>
<span class="token comment"># (1) history命令</span>
<span class="token function">history</span>
<span class="token comment">## !!+回车 --- 显示上一条命令记录</span>
<span class="token comment">## !20 --- 显示编号为20的命令记录</span>
<span class="token comment"># 命令历史记录会被写进 .bash_history</span>
<span class="token function">cat</span> .bsah_histroy
<span class="token comment"># (2) 命令命名</span>
<span class="token comment"># 查看当前可用的别名</span>
<span class="token function">alias</span> -p
<span class="token comment"># 自定义别名</span>
<span class="token function">alias</span> li <span class="token operator">=</span><span class="token string">'ls -li'</span>
</code></pre> 
<hr> 
<h2><a id="_562"></a>五、环境变量</h2> 
<h3><a id="1__563"></a>1. 环境变量</h3> 
<p>  全局环境变量对于shell会话和所有生成的子shell都是可见的。局部变量则只对创建它们的 shell 可见。</p> 
<p>  系统环境变量基本上都使用全大写字母，以区别于普通用户的环境变量。<br> 【<strong><a href="https://github.com/Crisimple/Linux/commit/8b1b5685f7d69ddd9cc50597bdb914285eea2470">GitHub示例</a></strong>】</p> 
<h4><a id="11__568"></a>1.1 全局环境变量</h4> 
<pre><code class="prism language-bash"><span class="token comment"># 1.1 全局环境变量</span>
<span class="token comment"># 查看全局变量</span>
<span class="token function">env</span>
<span class="token function">printenv</span>
<span class="token comment"># 显示个别环境变量的值</span>
<span class="token function">printenv</span> HOME
<span class="token keyword">echo</span> <span class="token variable">$HOME</span>
<span class="token function">ls</span> <span class="token variable">$HOME</span>
<span class="token comment"># 全局环境变量可用于进程的所有子 shell</span>
<span class="token function">bash</span>
<span class="token function">ps</span> -ef
<span class="token keyword">echo</span> <span class="token variable">$HOME</span>
<span class="token keyword">exit</span>
</code></pre> 
<h4><a id="12__585"></a>1.2 局部环境变量</h4> 
<p>  局部环境变量只能在定义它们的进程中可见。在Linux系统并没有一个只显示局部环境变量的命令。set命令会显示为某个特定进程设置的所有环境变量，包括局部变量、全局变量以及用户定义变量。</p> 
<pre><code class="prism language-bash"><span class="token keyword">set</span>
</code></pre> 
<p>  set 命令会显示出全局变量、局部变量以及用户定义变量。它还会按照字母顺序对结果进行排序。env和printenv命令同set命令的区别在于前两个命令不会对变量排序，也不会输出局部变量和用户定义变量。在这种情况下，env和printenv的输出是重复的。</p> 
<h3><a id="2__592"></a>2. 自定义环境变量</h3> 
<h4><a id="21__593"></a>2.1 设置局部用户定义变量</h4> 
<pre><code class="prism language-bash"><span class="token comment"># 2.1 设置局部用户定义变量</span>
<span class="token comment"># 通过等号给环境变量复制，值可以时数字或字符串</span>
my_variable<span class="token operator">=</span><span class="token string">'hello world'</span>
<span class="token keyword">echo</span> <span class="token variable">$my_variable</span>
<span class="token comment"># 设置了局部环境变量后，就能在shell进程的任何地方使用它了。但是，如果生成了另外一个shell，它在子shell中就不可用。</span>
<span class="token function">bash</span>
<span class="token keyword">echo</span> <span class="token variable">$my_variable</span>
<span class="token keyword">exit</span>
<span class="token keyword">echo</span> <span class="token variable">$my_variable</span>
</code></pre> 
<h4><a id="22__606"></a>2.2 设置全局环境变量</h4> 
<pre><code class="prism language-bash"><span class="token comment"># 2.2 设置全局环境变量</span>
<span class="token comment"># 创建全局环境变量的方法先创建一个局部环境变量，然后再把它导出到全局环境中。</span>
my_global_variable<span class="token operator">=</span><span class="token string">'I am Global now'</span>
<span class="token function">bash</span>
<span class="token keyword">echo</span> <span class="token variable">$my_global_variable</span>
<span class="token keyword">exit</span>
<span class="token function">export</span> my_global_variable
<span class="token keyword">echo</span> <span class="token variable">$my_global_variable</span>
<span class="token function">bash</span>
<span class="token keyword">echo</span> <span class="token variable">$my_global_variable</span>
<span class="token keyword">exit</span>
<span class="token keyword">echo</span> <span class="token variable">$my_global_variable</span>
</code></pre> 
<h3><a id="3__622"></a>3. 删除环境变量</h3> 
<pre><code class="prism language-bash"><span class="token comment"># 3. 删除环境变量</span>
<span class="token comment"># 既然可以创建新的环境变量，自然也能删除已经存在的环境变量。可以用unset命令完成这个操作。在unset命令中引用环境变量时，记住不要使用$</span>
<span class="token comment"># 承接2.2中的全局变量赋值</span>
<span class="token keyword">echo</span> <span class="token variable">$my_global_variable</span>
unset my_global_variable
<span class="token keyword">echo</span> <span class="token variable">$my_global_variable</span>
</code></pre> 
<h3><a id="4__shell__632"></a>4. 默认的 shell 环境变量</h3> 
<pre><code class="prism language-bash"><span class="token comment"># CDPATH              冒号分隔的目录列表，作为cd命令的搜索路径</span>
<span class="token comment"># HOME                当前用户的主目录</span>
<span class="token comment"># IFS shell           用来将文本字符串分割成字段的一系列字符</span>
<span class="token comment"># MAIL                当前用户收件箱的文件名（bash shell会检查这个文件，看看有没有新邮件）</span>
<span class="token comment"># MAILPATH            冒号分隔的当前用户收件箱的文件名列表（bash shell会检查列表中的每个文件，看看有没有新邮件）</span>
<span class="token comment"># OPTARG getopts      命令处理的最后一个选项参数值</span>
<span class="token comment"># OPTIND getopts      命令处理的最后一个选项参数的索引号</span>
<span class="token comment"># PATH shell          查找命令的目录列表，由冒号分隔</span>
<span class="token comment"># PS1 shell           命令行界面的主提示符</span>
<span class="token comment"># PS2 shell           命令行界面的次提示符</span>
<span class="token comment"># ...</span>
<span class="token comment"># BASH 						当前shell实例的全路径名 "</span>
<span class="token comment"># BASH_ALIASES 				含有当前已设置别名的关联数组 "</span>
<span class="token comment"># BASH_ARGC 					含有传入子函数或shell脚本的参数总数的数组变量 "</span>
<span class="token comment"># BASH_ARCV 					含有传入子函数或shell脚本的参数的数组变量 "</span>
<span class="token comment"># BASH_CMDS 					关联数组，包含shell执行过的命令的所在位置 "</span>
<span class="token comment"># BASH_COMMAND 				shell正在执行的命令或马上就执行的命令 "</span>
<span class="token comment"># BASH_ENV 					设置了的话，每个bash脚本会在运行前先尝试运行该变量定义的启动文件 "</span>
<span class="token comment"># BASH_EXECUTION_STRING  	使用bash -c选项传递过来的命令 "</span>
<span class="token comment"># BASH_LINENO 				含有当前执行的shell函数的源代码行号的数组变量 "</span>
<span class="token comment"># BASH_REMATCH 				只读数组，在使用正则表达式的比较运算符=~进行肯定匹配（positive match）时， 包含了匹配到的模式和子模式 B "</span>
<span class="token comment"># ASH_SOURCE 				含有当前正在执行的shell函数所在源文件名的数组变量 "</span>
<span class="token comment"># BASH_SUBSHELL 				当前子shell环境的嵌套级别（初始值是0） "</span>
<span class="token comment"># BASH_VERSINFO 				含有当前运行的bash shell的主版本号和次版本号的数组变量 "</span>
<span class="token comment"># BASH_VERSION 				当前运行的bash shell的版本号 "</span>
<span class="token comment"># BASH_XTRACEFD 				若设置成了有效的文件描述符（0、1、2），则'set -x'调试选项生成的跟踪输出 可被重定向。通常用来将跟踪输出到一个文件中 "</span>
<span class="token comment"># BASHOPTS 					当前启用的bash shell选项的列表 "</span>
<span class="token comment"># BASHPID 					当前bash进程的PID COLUMNS 当前bash shell实例所用终端的宽度 "</span>
<span class="token comment"># COMP_CWORD 				COMP_WORDS变量的索引值，后者含有当前光标的位置 "</span>
<span class="token comment"># COMP_LINE 					当前命令行 "</span>
<span class="token comment"># COMP_POINT 				当前光标位置相对于当前命令起始的索引 "</span>
<span class="token comment"># COMP_KEY 					用来调用shell函数补全功能的最后一个键 "</span>
<span class="token comment"># COMP_TYPE 					一个整数值，表示所尝试的补全类型，用以完成shell函数补全 "</span>
<span class="token comment"># COMP_WORDBREAKS 			Readline库中用于单词补全的词分隔字符 "</span>
<span class="token comment"># COMP_WORDS 				含有当前命令行所有单词的数组变量 "</span>
<span class="token comment"># COMPREPLY 					COPROC 含有由shell函数生成的可能填充代码的数组变量 占用未命名的协进程的I/O文件描述符的数组变量 "</span>
<span class="token comment"># DIRSTACK 					含有目录栈当前内容的数组变量 "</span>
<span class="token comment"># EMACS 						设置为't'时，表明emacs shell缓冲区正在工作，而行编辑功能被禁止 "</span>
<span class="token comment"># ENV 						如果设置了该环境变量，在bash shell脚本运行之前会先执行已定义的启动文件（仅 用于当bash shell以POSIX模式被调用时） "</span>
<span class="token comment"># EUID 						当前用户的有效用户ID（数字形式） "</span>
<span class="token comment"># FCEDIT 					供fc命令使用的默认编辑器 "</span>
<span class="token comment"># FIGNORE 					在进行文件名补全时可以忽略后缀名列表，由冒号分隔 "</span>
<span class="token comment"># FUNCNAME 					当前执行的shell函数的名称  "</span>
<span class="token comment"># FUNCNEST 				    当设置成非零值时，表示所允许的最大函数嵌套级数（一旦超出，当前命令即被终止）  "</span>
<span class="token comment"># GLOBIGNORE 				冒号分隔的模式列表，定义了在进行文件名扩展时可以忽略的一组文件名  "</span>
<span class="token comment"># GROUPS 					含有当前用户属组列表的数组变量  "</span>
<span class="token comment"># histchars 				    控制历史记录扩展，最多可有3个字符  "</span>
<span class="token comment"># HISTCMD 				    当前命令在历史记录中的编号  "</span>
<span class="token comment"># HISTCONTROL 			    控制哪些命令留在历史记录列表中  "</span>
<span class="token comment"># HISTFILE 				    保存shell历史记录列表的文件名（默认是.bash_history）  "</span>
<span class="token comment"># HISTFILESIZE 			    HISTTIMEFORMAT 最多在历史文件中存多少行 如果设置了且非空，就用作格式化字符串，以显示bash历史中每条命令的时间戳  "</span>
<span class="token comment"># HISTIGNORE 				由冒号分隔的模式列表，用来决定历史文件中哪些命令会被忽略  "</span>
<span class="token comment"># HISTSIZE 				    最多在历史文件中存多少条命令  "</span>
<span class="token comment"># HOSTFILE 				    shell在补全主机名时读取的文件名称  "</span>
<span class="token comment"># HOSTNAME 				    当前主机的名称  "</span>
<span class="token comment"># HOSTTYPE 				    当前运行bash shell的机器  "</span>
<span class="token comment"># IGNOREEOF 				    shell在退出前必须收到连续的EOF字符的数量（如果这个值不存在，默认是1）  "</span>
<span class="token comment"># INPUTRC 				    Readline初始化文件名（默认是.inputrc）  "</span>
<span class="token comment"># LANG 					    shell的语言环境类别 LC_ALL 定义了一个语言环境类别，能够覆盖LANG变量  "</span>
<span class="token comment"># LC_COLLATE 				设置对字符串排序时用的排序规则  "</span>
<span class="token comment"># LC_CTYPE 				    决定如何解释出现在文件名扩展和模式匹配中的字符  "</span>
<span class="token comment"># LC_MESSAGES 			    在解释前面带有\$的双引号字符串时，该环境变量决定了所采用的语言环境设置  "</span>
<span class="token comment"># LC_NUMERIC 				决定着格式化数字时采用的语言环境设置  "</span>
<span class="token comment"># LINENO 					当前执行的脚本的行号  "</span>
<span class="token comment"># LINES 					    定义了终端上可见的行数  "</span>
<span class="token comment"># MACHTYPE 				    用“CPU?公司?系统”（CPU-company-system）格式定义的系统类型  "</span>
<span class="token comment"># MAPFILE 				    一个数组变量，当mapfile命令未指定数组变量作为参数时，它存储了mapfile所读入的文本  "</span>
<span class="token comment"># MAILCHECK 				    shell查看新邮件的频率（以秒为单位，默认值是60）  "</span>
<span class="token comment"># OLDPWD 					shell之前的工作目录 OPTERR 设置为1时，bash shell会显示getopts命令产生的错误  "</span>
<span class="token comment"># OSTYPE 					定义了shell所在的操作系统  "</span>
<span class="token comment"># PIPESTATUS 				含有前台进程的退出状态列表的数组变量  "</span>
<span class="token comment"># POSIXLY_CORRECT 		    设置了的话，bash会以POSIX模式启动  "</span>
<span class="token comment"># PPID 					    bash shell父进程的PID PROMPT_COMMAND 设置了的话，在命令行主提示符显示之前会执行这条命令  "</span>
<span class="token comment"># PROMPT_DIRTRIM 			用来定义当启用了\w或\W提示符字符串转义时显示的尾部目录名的数量。被删除的 目录名会用一组英文句点替换  "</span>
<span class="token comment"># PS3 					    select命令的提示符   "</span>
<span class="token comment"># PS4 			            如果使用了bash的-x选项，在命令行之前显示的提示信息 "</span>
<span class="token comment"># PWD 			            当前工作目录 RANDOM 返回一个0～32767的随机数（对其的赋值可作为随机数生成器的种子） "</span>
<span class="token comment"># READLINE_LINE 	            当使用bind –x命令时，存储Readline缓冲区的内容 "</span>
<span class="token comment"># READLINE_POINT 	        当使用bind –x命令时，表示Readline缓冲区内容插入点的当前位置 "</span>
<span class="token comment"># REPLY 			            read命令的默认变量 "</span>
<span class="token comment"># SECONDS 		            自从shell启动到现在的秒数（对其赋值将会重置计数器） "</span>
<span class="token comment"># SHELL 			            bash shell的全路径名 SHELLOPTS 已启用bash shell选项列表，列表项之间以冒号分隔 "</span>
<span class="token comment"># SHLVL 			            shell的层级；每次启动一个新bash shell，该值增加1 "</span>
<span class="token comment"># TIMEFORMAT 		        指定了shell的时间显示格式 "</span>
<span class="token comment"># TMOUT 			            select和read命令在没输入的情况下等待多久（以秒为单位）。默认值为0，表示 无限长 TMPDIR 目录名，保存bash shell创建的临时文件 UID 当前用户的真实用户ID "</span>
</code></pre> 
<h3><a id="5__PATH__721"></a>5. 设置 PATH 环境变量</h3> 
<pre><code class="prism language-bsah"># 5. 设置 PATH 环境变量
# PATH中各个目录之间使用冒号分隔的
echo $PATH
PATH=$PATH:/home/ubuntu/Scripts
echo $PATH
</code></pre> 
<h3><a id="6__730"></a>6. 定位系统环境变量</h3> 
<pre><code class="prism language-bash"><span class="token comment"># 6.1 登录 shell</span>
<span class="token comment">#   登录Linux系统时，bash shell会作为登录shell启动。会从5个启动文件里读取命令</span>
<span class="token comment"># /etc/profile                  系统上默认的 bash shell 的主启动文件</span>
<span class="token comment"># $HOME/.bash_profile</span>
<span class="token comment"># $HOME/.bashrc</span>
<span class="token comment"># $HOME/.bash_login</span>
<span class="token comment"># $HOME/.profile</span>
<span class="token comment"># 6.2 交互式 shell 进程</span>
<span class="token comment">#       交互式shell不会访问 /etc/profile 文件，只会检查用户 HOME目录中的 .bashrc文件</span>
<span class="token comment"># 6.3 非交互式 shell 进程</span>
<span class="token comment">#       bash shell提供了BASH_ENV环境变量[printenv BASH_ENV]"</span>
<span class="token comment"># 6.4 环境变量持久化</span>
<span class="token comment">#       在 /etc/profile.d目录中创建一个以 .sh 结尾的文件。把所有新的或修改过的全局环境变量设置放在这个文件中。</span>
<span class="token comment">#       存储个人用户永久性 bash shell 变量的地方 $HOME/.bashrc文件中，从而达到永久化。</span>
</code></pre> 
<h3><a id="7__748"></a>7. 数组变量</h3> 
<pre><code class="prism language-bash"><span class="token comment"># 给某个环境变量设置多个值，可以把值放在括号里，值与值之间用空格分隔</span>
my_test_variable <span class="token operator">=</span> <span class="token punctuation">(</span>one two three four five<span class="token punctuation">)</span>
<span class="token keyword">echo</span> <span class="token variable">$my_test_variable</span>
<span class="token keyword">echo</span> <span class="token variable">${my_test_variable[2]}</span>
<span class="token keyword">echo</span> <span class="token variable">${my_test_variable[*]}</span>
my_test_variable<span class="token punctuation">[</span>2<span class="token punctuation">]</span><span class="token operator">=</span>2
<span class="token keyword">echo</span> <span class="token variable">${my_test_variable[*]}</span>
unset my_test_variable<span class="token punctuation">[</span>2<span class="token punctuation">]</span>
<span class="token keyword">echo</span> <span class="token variable">${my_test_variable[*]}</span>
</code></pre> 
<hr> 
<h2><a id="Linux_761"></a>六、Linux文件权限</h2> 
<p>【<strong><a href="https://github.com/Crisimple/Linux/commit/9968a71d29c82c9d2287dd82d9b8f622c9ccf3cf">GitHub示例</a></strong>】</p> 
<h3><a id="1_Linux_763"></a>1. Linux的安全性</h3> 
<h4><a id="11_etcpasswd_764"></a>1.1 /etc/passwd文件</h4> 
<pre><code class="prism language-bash"><span class="token comment"># (1) /etc/passwd文件  --- 将用户的登录名匹配到对应的UID值</span>
<span class="token function">cat</span> /etc/passwd
<span class="token comment"># mysql:x:113:117:MySQL Server,,,:/nonexistent:/bin/false</span>
<span class="token comment"># 对应字段的含义分别是：</span>
<span class="token comment">#       登录用户名</span>
<span class="token comment">#       用户密码：x --- 代表密码字段</span>
<span class="token comment">#       用户账户的UID形式</span>
<span class="token comment">#       用户组的GID形式</span>
<span class="token comment">#       用户账号的备注</span>
<span class="token comment">#       用户HOME目录的位置</span>
<span class="token comment">#       用户的默认 shell</span>
</code></pre> 
<h4><a id="12_etcshadow___Linux_778"></a>1.2 /etc/shadow文件 — Linux系统密码管理</h4> 
<pre><code class="prism language-bash"><span class="token function">sudo</span> <span class="token function">cat</span> /etc/shadow
<span class="token comment"># mysql:!:18144:0:99999:7:::</span>
<span class="token comment"># 对应字段的含义分别是：</span>
<span class="token comment">#       与/etc/passwd文件中的登录名字段对应的登录名</span>
<span class="token comment">#       加密后的密码</span>
<span class="token comment">#       自上次修改密码后过去的天数密码（自1970年1月1日开始计算）</span>
<span class="token comment">#       多少天后才能更改密码</span>
<span class="token comment">#       多少天后必须更改密码</span>
<span class="token comment">#       密码过期前提前多少天提醒用户更改密码</span>
<span class="token comment">#       密码过期后多少天禁用用户账户</span>
<span class="token comment">#       用户账户被禁用的日期（用自1970年1月1日到当天的天数表示）</span>
<span class="token comment">#       预留字段给将来使用</span>
</code></pre> 
<h4><a id="13_useradd____793"></a>1.3 useradd — 添加新用户</h4> 
<pre><code class="prism language-bash"><span class="token comment"># 系统默认值被设置在/etc/default/useradd文件中。可以使用加入了-D选项的useradd命令查看所用Linux系统中的这些默认值。</span>
/usr/sbin/useradd -D
<span class="token comment"># 对应字段的含义分别是：</span>
<span class="token comment">#       新用户会被添加到GID为100的公共组；</span>
<span class="token comment">#       新用户的HOME目录将会位于/home/loginname；</span>
<span class="token comment">#       新用户账户密码在过期后不会被禁用；</span>
<span class="token comment">#       新用户账户未被设置过期日期；</span>
<span class="token comment">#       新用户账户将bash shell作为默认shell；</span>
<span class="token comment">#       系统会将/etc/skel目录下的内容复制到用户的HOME目录下；</span>
<span class="token comment">#       系统为该用户账户在mail目录下创建一个用于接收邮件的文件</span>
<span class="token comment"># 创建一个新用户账号， 并查看新用户的 HOME 目录</span>
<span class="token function">useradd</span> -m <span class="token function">test</span>
<span class="token function">ls</span> -al /home/test
<span class="token comment"># useradd 命令行参数</span>
<span class="token comment">#       -c comment 			给新用户添加备注</span>
<span class="token comment">#       -d home_dir 		为主目录指定一个名字（如果不想用登录名作为主目录名的话）</span>
<span class="token comment">#       -e expire_date 		用YYYY-MM-DD格式指定一个账户过期的日期</span>
<span class="token comment">#       -f inactive_days 	指定这个账户密码过期后多少天这个账户被禁用；0表示密码一过期就立即禁用，1表示 禁用这个功能</span>
<span class="token comment">#       -g initial_group 	指定用户登录组的GID或组名</span>
<span class="token comment">#       -G group ... 		指定用户除登录组之外所属的一个或多个附加组</span>
<span class="token comment">#       -k 					必须和-m一起使用，将/etc/skel目录的内容复制到用户的HOME目录</span>
<span class="token comment">#       -m 					创建用户的HOME目录</span>
<span class="token comment">#       -M 					不创建用户的HOME目录（当默认设置里要求创建时才使用这个选项）</span>
<span class="token comment">#       -n 					创建一个与用户登录名同名的新组</span>
<span class="token comment">#       -r 		            创建系统账户</span>
<span class="token comment">#       -p 		            passwd 为用户账户指定默认密码</span>
<span class="token comment">#       -s 		            shell 指定默认的登录shell</span>
<span class="token comment">#       -u 		            uid 为账户指定唯一的UID</span>
<span class="token comment"># useradd 更改默认值的参数</span>
<span class="token comment">#       -b default_home 		更改默认的创建用户HOME目录的位置</span>
<span class="token comment">#       -e expiration_date 		更改默认的新账户的过期日期</span>
<span class="token comment">#       -f inactive 			更改默认的新用户从密码过期到账户被禁用的天数</span>
<span class="token comment">#       -g group 				更改默认的组名称或GID</span>
<span class="token comment">#       -s shell 				更改默认的登录shell</span>
</code></pre> 
<h4><a id="14_userdel____830"></a>1.4 userdel — 删除用户</h4> 
<pre><code class="prism language-bash"><span class="token function">sudo</span> /usr/sbin/userdel <span class="token function">test</span>         <span class="token comment"># 从系统中删除用户</span>
<span class="token function">sudo</span> /usr/sbin/userdel -r <span class="token function">test</span>      <span class="token comment"># 删除用户的HOME目录以及邮件目录</span>
</code></pre> 
<h4><a id="15__835"></a>1.5 修改用户信息</h4> 
<pre><code class="prism language-bash"><span class="token comment"># usermod  --- 修改用户</span>
<span class="token comment">#   usermod 命令行参数</span>
<span class="token comment">#       -l      修改用户账户的登录名。</span>
<span class="token comment">#       -L      锁定账户，使用户无法登录。</span>
<span class="token comment">#       -p      修改账户的密码。</span>
<span class="token comment">#       -U      解除锁定，使用户能够登录。</span>
<span class="token comment"># passwd 和 chpasswd --- 修改用户密码</span>
<span class="token function">sudo</span> <span class="token function">passwd</span> -e <span class="token function">test</span>      <span class="token comment"># -e 参数下次登录时修改密码，只有 root 权限用户才有权限改别人的密码</span>
<span class="token function">sudo</span> chpasswd <span class="token operator">&lt;</span> users.txt    <span class="token comment"># 修改大量用户的密码（重定向文件的格式：userid:passwd）</span>
<span class="token comment"># chsh、chfn、chage</span>
<span class="token comment">#   chsh --- chsh命令用来快速修改默认的用户登录shell</span>
<span class="token function">sudo</span> chsh -s /bin/csh <span class="token function">test</span>
<span class="token comment">#   chfn --- 在/etc/passwd文件的备注字段中存储信息的标准方法</span>
<span class="token function">sudo</span> chfn <span class="token function">test</span>
<span class="token comment">#   chage --- 帮助管理用户账号的有效期</span>
<span class="token function">sudo</span> chage -d 10 <span class="token function">test</span>
<span class="token comment">#       -d 设置上次修改密码到现在的天数</span>
<span class="token comment">#       -E 设置密码过期的日期</span>
<span class="token comment">#       -I 设置密码过期到锁定账户的天数</span>
<span class="token comment">#       -m 设置修改密码之间最少要多少天</span>
<span class="token comment">#       -W 设置密码过期前多久开始出现提醒信息</span>
</code></pre> 
<h3><a id="2_Linux_860"></a>2. Linux用户组</h3> 
<p>  组权限允许多个用户对系统中的对象（比如文件、目录或设备等）共享一组共用的权限。</p> 
<h4><a id="21_etcgroup___862"></a>2.1 /etc/group文件 — 系统上每个组的信息</h4> 
<pre><code class="prism language-bash"><span class="token function">grep</span> <span class="token function">test</span> /etc/group
<span class="token comment"># 对应字段的含义分别是：</span>
<span class="token comment">#       组名</span>
<span class="token comment">#       组密码</span>
<span class="token comment">#       GID</span>
<span class="token comment">#       属于组的用户列表</span>
</code></pre> 
<h4><a id="22__871"></a>2.2 创建新组</h4> 
<pre><code class="prism language-bash"><span class="token comment"># 创建新组时，默认没有用户被分配到该组</span>
<span class="token function">sudo</span> /usr/sbin/groupadd test_group
<span class="token function">tail</span> /etc/group
<span class="token comment"># 可以用usermod命令将用户添加到组中; -g 会删除默认组；-G 会保留默认组</span>
<span class="token function">sudo</span> /usr/sbin/usermod -G test_group <span class="token function">test</span>
<span class="token function">tail</span> /etc/group
</code></pre> 
<h4><a id="23__880"></a>2.3 修改组</h4> 
<pre><code class="prism language-bash"><span class="token comment">#   -n      修改组的组名</span>
<span class="token comment">#   -g      修改组的GID</span>
<span class="token function">sudo</span> /usr/sbin/groupmod -n test_group_mod test_group
<span class="token function">tail</span> /etc/group
</code></pre> 
<h3><a id="3__888"></a>3. 文件权限</h3> 
<pre><code class="prism language-bash"><span class="token comment"># 3.1 文件权限符</span>
<span class="token comment">#  第一段字符代表：</span>
<span class="token comment">#        -  代表文件</span>
<span class="token comment">#        d  代表目录</span>
<span class="token comment">#        l  代表链接</span>
<span class="token comment">#        c  代表字符型设备</span>
<span class="token comment">#        b  代表块设备</span>
<span class="token comment">#        n  代表网络设备</span>
<span class="token comment">#  第二段字符代表，每三段代表对应对象的3个安全级别：</span>
<span class="token comment">#        r  代表对象是可读的</span>
<span class="token comment">#        w  代表对象是可写的</span>
<span class="token comment">#        x  代表对象是可执行的</span>
<span class="token comment">#   对象的属主</span>
<span class="token comment">#   对象的属组</span>
<span class="token comment">#   系统其他用户</span>
<span class="token comment"># 3.2 默认文件权限</span>
<span class="token function">touch</span> new_file
<span class="token function">ls</span> -al newfile
<span class="token comment"># umask命令用来设置所创建文件和目录的默认权限</span>
<span class="token function">umask</span>
</code></pre> 
<h3><a id="4__912"></a>4. 更改文件权限</h3> 
<h4><a id="41__913"></a>4.1 改变权限</h4> 
<pre><code class="prism language-bash"><span class="token comment">#   八进制形式权限</span>
<span class="token function">chmod</span> 760 newfile
<span class="token function">ls</span> -al newfile
<span class="token comment">#   符合模式权限</span>
<span class="token comment">#       u --- 用户</span>
<span class="token comment">#       g --- 用户组</span>
<span class="token comment">#       o --- 其他用户</span>
<span class="token comment">#       a --- 代表上面所有</span>
<span class="token comment">#       + --- 现有权限基础上增加权限</span>
<span class="token comment">#       - --- 现有权限基础上移除权限</span>
<span class="token comment">#       = --- 将权限设置成后面的值</span>
<span class="token comment">#       X：如果对象是目录或者它已有执行权限，赋予执行权限</span>
<span class="token comment">#       s：运行时重新设置UID或GID</span>
<span class="token comment">#       t：保留文件或目录</span>
<span class="token comment">#       u：将权限设置为跟属主一样</span>
<span class="token comment">#       g：将权限设置为跟属组一样</span>
<span class="token comment">#       o：将权限设置为跟其他用户一样</span>
<span class="token function">chmod</span> u+x newfile
</code></pre> 
<h4><a id="42__934"></a>4.2 改变所属关系</h4> 
<pre><code class="prism language-bash"><span class="token comment"># chown命令用来改变文件的属主</span>
<span class="token function">sudo</span> <span class="token function">touch</span> newfile
<span class="token function">ls</span> -al newfile
<span class="token function">chown</span> <span class="token function">test</span> newfile
<span class="token function">ls</span> -al newfile
<span class="token comment"># chgrp命令用来改变文件的默认属组。</span>
<span class="token function">sudo</span> <span class="token function">chgrp</span> test_group_mod newfile
<span class="token function">ls</span> -al newfile
</code></pre> 
<h3><a id="5__946"></a>5. 共享文件</h3> 
<p>  Linux系统上共享文件的方法是创建组。创建新文件时，Linux会用你默认的UID和GID给文件分配权限。</p> 
<pre><code class="prism language-bash"><span class="token comment">#   设置用户ID（SUID）：当文件被用户使用时，程序会以文件属主的权限运行。</span>
<span class="token comment">#   设置组ID（SGID）：对文件来说，程序会以文件属组的权限运行；对目录来说，目录中 创建的新文件会以目录的默认属组作为默认属组。</span>
<span class="token comment">#   粘着位：进程结束后文件还驻留（粘着）在内存中。</span>
<span class="token function">sudo</span> <span class="token function">mkdir</span> test_dir
<span class="token function">sudo</span> <span class="token function">chgrp</span> <span class="token function">test</span> test_dir
<span class="token function">ls</span> -al test_dir/
</code></pre> 
<hr> 
<h2><a id="_958"></a>七、管理文件系统</h2> 
<p>【<strong><a href="https://github.com/Crisimple/Linux/commit/e27e3fb2ad91a665c189d6581b5dbe5c74266a7d">GitHub示例</a></strong>】</p> 
<h3><a id="1_Linux__960"></a>1. Linux 文件系统</h3> 
<pre><code class="prism language-bash"><span class="token comment"># 1.1 基本文件系统</span>
<span class="token comment">#       ext文件系统     --- 索引节点系统在每个物理设备中创建一个单独的表来存储文件信息</span>
<span class="token comment">#       ext2文件系统    --- 增加了访问文件的大小；将磁盘分组减少碎片化，提高访问速度</span>
<span class="token comment"># 1.2 日志文件系统</span>
<span class="token comment">#       ext3文件系统    --- 只将索引节点信息写入日志文件，直到数据块都被成功写入存储设备才删除</span>
<span class="token comment">#       ext4文件系统    --- Ubuntu的默认文件系统，。区段在存储设备上按块分配空间，但在索引节点表中只保存起始块的位置</span>
<span class="token comment">#       Reiser文件系统  --- ReiserFS文件系统只支持回写日志模式——只把索引节点表数据写到日志文件</span>
<span class="token comment">#       JSF文件系统     --- JFS文件系统采用的是有序日志方法，即只在日志中保存索引节点表数据，直到真正的文件数据被写进存储设备时才删除它</span>
<span class="token comment">#       XFS文件系统     --- XFS文件系统采用回写模式的日志，XFS文件系统还允许在线调整文件系统的大小</span>
<span class="token comment"># 1.3 写时复制文件系统</span>
<span class="token comment">#       ZFS文件系统</span>
<span class="token comment">#       Btrf文件系统</span>
</code></pre> 
<h3><a id="2__976"></a>2. 操作文件系统</h3> 
<pre><code class="prism language-bash"><span class="token comment"># 2. 操作文件系统</span>
<span class="token comment"># 2.1 fdisk创建分区</span>
<span class="token comment"># fdisk 命令参数的含义：</span>
<span class="token comment">#       a   设置活动分区标志 "</span>
<span class="token comment">#       b   编辑BSD Unix系统用的磁盘标签 "</span>
<span class="token comment">#       c   设置DOS兼容标志 "</span>
<span class="token comment">#       d   删除分区 "</span>
<span class="token comment">#       l   显示可用的分区类型"</span>
<span class="token comment">#       m   显示命令选项"</span>
<span class="token comment">#       n   添加一个新分区"</span>
<span class="token comment">#       o   创建DOS分区表"</span>
<span class="token comment">#       p   显示当前分区表"</span>
<span class="token comment">#       q   退出，不保存更改"</span>
<span class="token comment">#       s   为Sun Unix系统创建一个新磁盘标签"</span>
<span class="token comment">#       t   修改分区的系统ID"</span>
<span class="token comment">#       u   改变使用的存储单位 "</span>
<span class="token comment">#       v   验证分区表 "</span>
<span class="token comment">#       w   将分区表写入磁盘 "</span>
<span class="token comment">#       x   高级功能 "</span>
<span class="token comment"># 2.2 创建文件系统</span>
<span class="token comment">#       mkefs       创建一个ext文件系统</span>
<span class="token comment">#       mke2fs      创建一个ext2文件系统</span>
<span class="token comment">#       mkfs.ext3   创建一个ext3文件系统</span>
<span class="token comment">#       mkfs.ext4   创建一个ext4文件系统</span>
<span class="token comment">#       mkreiserfs  创建一个ReiserFS文件系统</span>
<span class="token comment">#       jfs_mkfs    创建一个JFS文件系统</span>
<span class="token comment">#       mkfs.xfs    创建一个XFS文件系统</span>
<span class="token comment">#       mkfs.zfs    创建一个ZFS文件系统</span>
<span class="token comment">#       mkfs.btrfs  创建一个Btrfs文件系统</span>
<span class="token comment">#       type mkfs.ext4  # 查看某个文件系统是否可用</span>
<span class="token comment">#       mkdir命令（参见第3章）在虚拟目录中创建了挂载点，mount命令将新的硬盘分区添加到挂载点。</span>
<span class="token comment">#       mount命令的-t选项指明了要挂载的文件系统类型（ext4）</span>
<span class="token comment"># 2.3 fsck文件系统的检查与修复</span>
<span class="token comment"># fsck 命令参数的含义：</span>
<span class="token comment">#       -a 如果检测到错误，自动修复文件系统</span>
<span class="token comment">#       -A 检查/etc/fstab文件中列出的所有文件系统</span>
<span class="token comment">#       -C 给支持进度条功能的文件系统显示一个进度条（只有ext2和ext3）</span>
<span class="token comment">#       -N 不进行检查，只显示哪些检查会执行</span>
<span class="token comment">#       -r 出现错误时提示</span>
<span class="token comment">#       -R 使用-A选项时跳过根文件系统</span>
<span class="token comment">#       -s 检查多个文件系统时，依次进行检查</span>
<span class="token comment">#       -t 指定要检查的文件系统类型</span>
<span class="token comment">#       -T 启动时不显示头部信息</span>
<span class="token comment">#       -V 在检查时产生详细输出</span>
<span class="token comment">#       -y 检测到错误时自动修复文件系统</span>
</code></pre> 
<h3><a id="3__1025"></a>3. 逻辑卷管理</h3> 
<pre><code class="prism language-bash"><span class="token comment"># 3. 逻辑卷管理</span>
<span class="token comment"># 3.1 逻辑卷管理布局</span>
<span class="token comment">#       硬盘为物理卷PV；多个物理卷形成卷组VG；整个系统的最后一层是逻辑卷LV</span>
<span class="token comment"># 3.2 Linux 中的 LVM</span>
<span class="token comment">#       快照：Linux LVM允许你在逻辑卷在线的状态下将其复制到另一个设备</span>
<span class="token comment">#       条带化：可跨多个物理硬盘 创建逻辑卷</span>
<span class="token comment">#       镜像：涉及大量数据变动的，镜像是一个实时更新的逻辑卷的完整副本</span>
<span class="token comment"># 3.3 使用Linux LVM</span>
<span class="token comment"># (1) 定义物理卷</span>
<span class="token comment">#       将硬盘上的物理分区转换成Linux LVM使用的物理卷区段，fdisk命令;</span>
<span class="token comment">#       用分区来创建实际的物理卷，pvcreate命令；</span>
<span class="token comment">#       查看创建进度的话，用pvdisplay命令</span>
<span class="token comment"># (2) 创建卷组</span>
<span class="token comment">#       从命令行创建卷组，需要使用vgcreate命令;</span>
<span class="token comment">#       看新创建的卷组的细节，可用vgdisplay命令</span>
<span class="token comment"># (3) 创建逻辑卷</span>
<span class="token comment"># 要创建逻辑卷，使用lvcreate命令，可配合使用的参数的含义：</span>
<span class="token comment">#       -c --chunksize 指定快照逻辑卷的单位大小</span>
<span class="token comment">#       -C --contiguous 设置或重置连续分配策略</span>
<span class="token comment">#       -i --stripes 指定条带数</span>
<span class="token comment">#       -I --stripesize 指定每个条带的大小</span>
<span class="token comment">#       -l --extents 指定分配给新逻辑卷的逻辑区段数，或者要用的逻辑区段的百分比</span>
<span class="token comment">#       -L --size 指定分配给新逻辑卷的硬盘大小</span>
<span class="token comment">#       --minor 指定设备的次设备号</span>
<span class="token comment">#       -m --mirrors 创建逻辑卷镜像</span>
<span class="token comment">#       -M --persistent 让次设备号一直有效</span>
<span class="token comment">#       -n --name 指定新逻辑卷的名称</span>
<span class="token comment">#       -p --permission 为逻辑卷设置读/写权限</span>
<span class="token comment">#       -r --readahead 设置预读扇区数</span>
<span class="token comment">#       -R --regionsize 指定将镜像分成多大的区</span>
<span class="token comment">#       -s snapshot 创建快照逻辑卷</span>
<span class="token comment">#       -Z --zero 将新逻辑卷的前1 KB数据设置为零</span>
<span class="token comment"># (4) 创建文件系统</span>
<span class="token comment"># 运行完lvcreate命令之后，逻辑卷就已经产生了，但它还没有文件系统。你必须使用相应的命令行程序来创建所需要的文件系统。</span>
<span class="token comment"># (5) 修改 LVM</span>
<span class="token comment">#       vgchange 激活和禁用卷组</span>
<span class="token comment">#       vgremove 删除卷组</span>
<span class="token comment">#       vgextend 将物理卷加到卷组中</span>
<span class="token comment">#       vgreduce 从卷组中删除物理卷</span>
<span class="token comment">#       lvextend 增加逻辑卷的大小</span>
<span class="token comment">#       lvreduce 减小逻辑卷的大小</span>
</code></pre> 
<hr> 
<h2><a id="_1071"></a>八、安装软件程序</h2> 
<p>  Linux上能见到的各种包管理系统（package management system，PMS），以及用来进行软件安装、管理和删除的命令行工具。Linux中广泛使用的两种主要的 PMS 基础工具是dpkg和rpm。</p> 
<p>  基于Debian的发行版（如Ubuntu和Linux Mint）使用的是dpkg命令，dpkg会直接和Linux系统上的PMS交互，用来安装、管理和删除软件包。</p> 
<p>  基于Red Hat的发行版（如Fedora、openSUSE及Mandriva）使用的是rpm命令，该命令是其PMS 的底层基础。类似于dpkg命令，rmp命令能够列出已安装包、安装新包和删除已有软件。</p> 
<h3><a id="81_Ubuntu_1077"></a>8.1 Ubuntu</h3> 
<p>  Ubuntu包管理系统源自Debian的包管理系统。。Debian的包文件通常是以”.deb”为后缀名，是预编译的二进制文件，一般不需要二次编译。<br> 【<strong><a href="https://github.com/Crisimple/Linux/commit/712f23cf849477499e29be068ada818b6fd0d5d1">GitHub示例</a></strong>】</p> 
<pre><code class="prism language-bash"><span class="token comment"># 安装软件包</span>
<span class="token function">sudo</span> apt <span class="token function">install</span> package_name1 package_name2
<span class="token comment"># 卸载软件包</span>
<span class="token function">sudo</span> apt remove package_name1 package_name2
<span class="token comment"># 更新包索引，需要将本地的包索引和软件包库（会进行更新）的包信息进行同步。</span>
<span class="token function">sudo</span> apt update
<span class="token comment"># 升级软件包</span>
<span class="token function">sudo</span> apt upgrade
</code></pre> 
<p>   apt-get命令的子命令：</p> 
<table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>update</td><td>更新软件包列表</td></tr><tr><td>upgrade</td><td>升级系统中的所有软件包</td></tr><tr><td>install</td><td>安装软件包</td></tr><tr><td>remove</td><td>卸载软件包</td></tr><tr><td>autoremove</td><td>仅删除不需要再次下载的软件包</td></tr><tr><td>purge</td><td>彻底删除软件包（包括配置文件）</td></tr><tr><td>source</td><td>下载源代码</td></tr><tr><td>build-dep</td><td>自动下载安装编译某个软件所需要的软件包</td></tr><tr><td>dist-upgrade</td><td>升级整个发行版</td></tr><tr><td>dselect-upgrade</td><td>安装dselect的选择进行升级</td></tr><tr><td>clean</td><td>删除本地缓存的所有升级包</td></tr><tr><td>autoclean</td><td>删除本地缓存中无用的软件包</td></tr><tr><td>check</td><td>检查是否存在有问题的依赖关系</td></tr></tbody></table> 
<h3><a id="82_CentOS_1109"></a>8.2 CentOS</h3> 
<pre><code class="prism language-bash"><span class="token comment"># 2. CentOS</span>
<span class="token comment"># 安装</span>
yum <span class="token function">install</span> <span class="token comment"># 全部安装</span>
yum <span class="token function">install</span> package1  <span class="token comment"># 安装指定的安装包package1</span>
yum groupinsall group1  <span class="token comment"># 安装程序组group1</span>
<span class="token comment"># 更新和升级</span>
yum update  <span class="token comment"># 全部更新</span>
yum update package1  <span class="token comment"># 更新指定程序包package1</span>
yum check-update  <span class="token comment"># 检查可更新的程序</span>
yum upgrade package1  <span class="token comment"># 升级指定程序包package1</span>
yum groupupdate group1  <span class="token comment"># 升级程序组group1</span>
<span class="token comment"># 查找和显示</span>
yum info package1  <span class="token comment"># 显示安装包信息package1</span>
yum list  <span class="token comment"># 显示所有已经安装和可以安装的程序包</span>
yum list package1  <span class="token comment"># 显示指定程序包安装情况package1</span>
yum groupinfo group1  <span class="token comment"># 显示程序组group1信息yum search string 根据关键字string查找安装包</span>
<span class="token comment"># 删除程序</span>
yum remove <span class="token operator">|</span> erase package1  <span class="token comment"># 删除程序包package1</span>
yum groupremove group1  <span class="token comment"># 删除程序组group1</span>
yum deplist package1  <span class="token comment"># 查看程序package1依赖情况</span>
<span class="token comment"># 清除缓存</span>
yum clean packages  <span class="token comment"># 清除缓存目录下的软件包</span>
yum clean headers  <span class="token comment"># 清除缓存目录下的 headers</span>
yum clean oldheaders  <span class="token comment"># 清除缓存目录下旧的 headers</span>
yum clean, yum clean all <span class="token punctuation">(</span><span class="token operator">=</span> yum clean packages<span class="token punctuation">;</span> yum clean oldheaders<span class="token punctuation">)</span>  <span class="token comment"># 清除缓存目录下的软件包及旧的headers</span>
<span class="token comment"># 源操作</span>
yum repolist/repolist all  <span class="token comment"># 列出所有源</span>
yum -enablerepo<span class="token operator">=</span>fedora-source <span class="token function">install</span> package1  <span class="token comment"># 从fedora-source源中安装包package1</span>
<span class="token comment"># Yum Shell</span>
yum shll  <span class="token comment"># 进去yum的shell环境</span>
</code></pre> 
<h3><a id="83__1144"></a>8.3 从源码安装</h3> 
<pre><code class="prism language-bash"><span class="token comment"># 3. 源码安装</span>
<span class="token comment"># 解压缩</span>
<span class="token function">tar</span> -zxf test-4.0.2.tar.gz
<span class="token comment"># 进入目录</span>
<span class="token function">cd</span> test-4.0.2
<span class="token comment"># 配置</span>
./configure --prefix<span class="token operator">=</span>/usr/local/test
<span class="token comment"># 编译</span>
<span class="token function">make</span> all
<span class="token comment"># 安装</span>
<span class="token function">make</span> <span class="token function">install</span> <span class="token operator">&amp;&amp;</span> <span class="token function">make</span> install-init <span class="token operator">&amp;&amp;</span> <span class="token function">make</span> install-commandmode <span class="token operator">&amp;&amp;</span> <span class="token function">make</span> install-config
</code></pre> 
<h2><a id="_1159"></a>九、使用编辑器</h2> 
<h3><a id="1_vim_1160"></a>1. vim编辑器</h3> 
<p>【<strong><a href="https://github.com/Crisimple/Linux/commit/cac4df984ea9d939520c7f236084f1e6d3bb9e11">GitHub示例</a></strong>】</p> 
<pre><code class="prism language-bsah">#!/usr/bin/env bash
# @File    :   09_use_editor.sh
# @Time    :   2019/9/15 14:06
# @Author  :   Crisimple
# @Github :    https://crisimple.github.io/
# @Contact :   Crisimple@foxmail.com
# @License :   (C)Copyright 2017-2019, Micro-Circle
# @Desc    :   使用编辑器

# 1. vim编辑器
# 1.1 检查vim软件包
which vim
#   安装 vim
sudo apt install vim

# 1.2 vim基础
# 普通模式：
#   h：左移一个字符
#   j：下移一行（文本中的下一行）
#   k：上移一行（文本中的上一行）
#   l：右移一个字符
#   PageDown（或Ctrl+F）：下翻一屏
#   PageUp（或Ctrl+B）：上翻一屏
#   G：移到缓冲区的后一行
#   num G：移动到缓冲区中的第num行
#   gg：移到缓冲区的第一行
#   q：如果未修改缓冲区数据，退出
#   q!：取消所有对缓冲区数据的修改并退出
#   w filename：将文件保存到另一个文件中
#   wq：将缓冲区数据保存到文件中并退出


# 1.3 编辑数据
# 编辑模式：
#   i 进入文本编辑模式
#   x 删除当前光标所在位置的字符
#   dd 删除当前光标所在行
#   dw 删除当前光标所在位置的单词
#   d$ 删除当前光标所在位置至行尾的内容
#   J 删除当前光标所在行行尾的换行符（拼接行）
#   u 撤销前一编辑命令
#   a 在当前光标后追加数据
#   A 在当前光标所在行行尾追加数据
#   r char 用char替换当前光标所在位置的单个字符
#   R text 用text覆盖当前光标所在位置的数据，直到按下ESC键

# 1.4 复制和粘贴
# yy	复制光标所在的整行
# y{	复制到上一段的开始
# Y 或 y$	复制从光标所在行 行首到行尾的内容
# y}	复制到下一段的开始
# y0	复制从光标前一个字符开始到行首的内容
# y&lt;CR&gt;	复制包括当前行在内的两行内容
# y(	复制到上一句的开始	yw	复制一个单词
# y)	复制到下一句的开始
# p 命令：粘贴命令，粘贴当前缓冲区中的内容。


# 1.5 查找和替换
# :s/old/new/g：一行命令替换所有old。
# :n,ms/old/new/g：替换行号n和m之间所有old。
# :%s/old/new/g：替换整个文件中的所有old。
# :%s/old/new/gc：替换整个文件中的所有old，但在每次出现时提示。‘
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/dbccee6d0992db3208dd4716083373ca/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Python 测试相关</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1063641519f01867a862400d4f965ace/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">安装anaconda和tensorflow(windows)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>