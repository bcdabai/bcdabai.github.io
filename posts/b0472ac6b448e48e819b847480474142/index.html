<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>第三、四章 面向对象 （第三次作业） - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="第三、四章 面向对象 （第三次作业）" />
<meta property="og:description" content="第一次作答 一.单选题（共29题,34.8分） 1下面选项中，类的声明方式正确的是（）
A、public void AA{…}
B、public class Move(){…}
C、public class void number{…}
D、public class Car{…}
正确答案： D
2在java中，以下程序的输出结果是（）
class Point {
int x;
boolean y;
void output() {
System.out.println(x);
System.out.println(y);
}
public static void main(String[] args) {
Point pt =new Point();
pt.output();
}
}
A、运行错误
B、0 ture
C、0 false
D、0 0
正确答案： C
3在Java接口中，下列选项中属于有效的方法声明的是（）
A、public void aMethod();
B、final void aMethod();
C、void aMethod(){}
D、private void aMethod();
正确答案： A
4下列程序的运行结果是" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/b0472ac6b448e48e819b847480474142/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-04-01T21:41:56+08:00" />
<meta property="article:modified_time" content="2023-04-01T21:41:56+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">第三、四章 面向对象 （第三次作业）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="_0"></a>第一次作答</h2> 
<h3><a id="29348_2"></a>一.单选题（共29题,34.8分）</h3> 
<p>1下面选项中，类的声明方式正确的是（）<br> A、public void AA{…}<br> B、public class Move(){…}<br> C、public class void number{…}<br> D、public class Car{…}<br> 正确答案： D</p> 
<p>2在java中，以下程序的输出结果是（）</p> 
<p>class Point {<!-- --><br> int x;<br> boolean y;<br> void output() {<!-- --><br> System.out.println(x);<br> System.out.println(y);<br> }<br> public static void main(String[] args) {<!-- --><br> Point pt =new Point();<br> pt.output();<br> }<br> }<br> A、运行错误<br> B、0 ture<br> C、0 false<br> D、0 0<br> 正确答案： C</p> 
<p>3在Java接口中，下列选项中属于有效的方法声明的是（）<br> A、public void aMethod();<br> B、final void aMethod();<br> C、void aMethod(){}<br> D、private void aMethod();<br> 正确答案： A</p> 
<p>4下列程序的运行结果是<br> class Demo{<!-- --><br> private String name;<br> Demo(String name){this.name = name;}<br> private static void show(){<!-- --><br> System.out.println(name);<br> }<br> public static void main(String[] args){<!-- --><br> Demo d = new Demo(“lisa”);<br> d.show();<br> }<br> }<br> A、输出lisa<br> B、输出null<br> C、输出name<br> D、编译失败，无法从静态上下文中引用非静态变量name<br> 正确答案： D<br> 答案解析：静态不能直接访问非静态。</p> 
<p>5静态方法运行时，在哪个内存区域中（ ）<br> A、栈内存<br> B、堆内存<br> C、方法区<br> D、寄存器<br> 正确答案： A<br> 答案解析：访问运行都在栈内存。</p> 
<p>6下列关于静态方法的描述中，错误的是（ ）<br> A、静态方法指的是被static关键字修饰的方法<br> B、静态方法不占用对象的内存空间，而非静态方法占有对象的内容空间<br> C、静态方法内可以使用this关键字<br> D、静态方法内部只能访问被static修饰的成员<br> 正确答案： C<br> 答案解析：静态方法内部不可以使用this、super等关键字。</p> 
<p>7请阅读下面的程序代码，选择正确的运行结果（ ）<br> class Person{<!-- --><br> void say(){<!-- --><br> System.out.println(“hello”);<br> }<br> }<br> class Example{<!-- --><br> public static void main(String[] args){<!-- --><br> Person p2 = new Person();<br> Person p1 = new Person();<br> p2.say();<br> p1.say();<br> p2=null;<br> p2.say();<br> }<br> }<br> A、输出1个hello<br> B、输出2个hello后会抛出异常<br> C、输出3个hello后会抛出异常<br> D、不会输出hello，直接抛出异常<br> 正确答案： B<br> 答案解析：程序中创建了2个Person对象p1、p2，并分别调用了say()方法输出两个hello，然后将p2对象置为null，使p2对象失去了引用，因此再次使用p2对象调用say()方法时，会抛出异常。</p> 
<p>8下列关键字中，用于创建类的实例对象的是（ ）<br> A、class<br> B、new<br> C、private<br> D、void<br> 正确答案： B<br> 答案解析：Java中使用new关键字创建对象，class用于定义一个类，private是权限修饰符，表示表示只能在本类中访问，void表示无返回值。</p> 
<p>9下列关于面向对象的说法中，错误的是（ ）<br> A、面向对象思想编程，不仅增强代码了复用性，提供了开发效率，而且为程序的修改补充提供了便利。<br> B、面向对象就是分析解决问题所需要的步骤，然后用函数把这些步骤一一实现，使用的时候一个一个依次调用。<br> C、面向对象是把解决的问题按照一定规则划分为多个独立的对象，然后通过调用对象的方法来解决问题。<br> D、面向对象虽然使程序的开发效率提高了，但是程序的处理效率相对面向过程程序要低。<br> 正确答案：<br> 答案解析：面向对象是把解决的问题按照一定规则划分为多个独立的对象，然后通过调用对象的方法来解决问题，具有易维护性、质量高、效率高、易扩展性等特点。</p> 
<p>10下列关于类的继承的描述，正确的是（）。<br> A、一个类可以继承多个父类<br> B、一个类可以具有多个子类<br> C、子类可以使用父类的所有方法<br> D、子类一定比父类有更多的成员方法<br> 正确答案： B<br> 答案解析：A、一个类只能继承一个父类｜C、子类可以使用父类的非私有方法｜D、子类不一定比父类有更多的成员方法。</p> 
<p>11阅读下面代码：<br> class Parent {<!-- --><br> public int count() { // 第1行<br> return 0;<br> }<br> }<br> public class Test extends Parent {<!-- --><br> public float count() { // 第2行<br> return 9; // 第3行<br> }<br> }<br> 编译时，会出现以下（ ）情况。<br> A、编译通过<br> B、在第1行引发编译错误<br> C、在第2行引发编译错误<br> D、在第3行引发编译错误<br> 正确答案： C</p> 
<p>12阅读下面代码：<br> class Parent {<!-- --><br> public void count() {<!-- --><br> System.out.println(10%3);<br> }<br> }<br> public class Child extends Parent{<!-- --><br> public void count() {<!-- --><br> System.out.println(10/3);<br> }<br> public static void main(String args[]) {<!-- --><br> Parent p = new Child();<br> p.count();<br> }<br> }<br> 下列选项中的输出结果正确的是（ ）。<br> A、1<br> B、1.0<br> C、3<br> D、3.3333333333333335<br> 正确答案： C</p> 
<p>13阅读下面代码：<br> public class Test{<!-- --><br> private static final int counter=10;<br> public static void main(String [] args){<!-- --><br> System.out.println(++counter);<br> }<br> }<br> 编译运行Test.java，结果是 （）<br> A、10<br> B、11<br> C、编译错误<br> D、运行时出现异常<br> 正确答案： C<br> 答案解析：final修饰的变量不可以被改变。</p> 
<p>14在Java中，要想让一个类继承另一个类，可以使用以下哪个关键字（）<br> A、inherits<br> B、extends<br> C、implements<br> D、modifies<br> 正确答案： B</p> 
<p>15阅读下面代码：<br> public static void main (String [] args){<!-- --><br> String s;<br> System.out.println(“s=”+s);<br> }<br> 编译运行以上程序，结果是（）<br> A、编译错误<br> B、编译通过，但出现运行时错误<br> C、正常运行，输出s=null<br> D、正常运行，输出s=<br> 正确答案： A</p> 
<p>16阅读下面代码：<br> class Parent {<!-- --><br> public void count() {<!-- --><br> System.out.println(10%3);<br> }<br> }<br> public class Child extends Parent{<!-- --><br> public void count() {<!-- --><br> System.out.println(10/3);<br> }<br> public static void main(String args[]) {<!-- --><br> Parent p = new Child();<br> p.count();<br> }<br> }<br> 下列选项中的输出结果正确的是（ ）。<br> A、1<br> B、1.0<br> C、3<br> D、3.3333333333333335<br> 正确答案： C</p> 
<p>17下列符号中，哪个用于分隔throws关键字抛出的多个异常（）<br> A、；<br> B、，<br> C、&amp;<br> D、|<br> 正确答案： B<br> 答案解析：方法中如果有多个异常，他们之间使用逗号隔开。</p> 
<p>18Java中，如果类C是类B的子类，类B是类A的子类，那么下面描述正确的是（）。<br> A、C可以继承B中的公有成员，同样也可以继承A中的公有成员<br> B、C只继承了B中的成员<br> C、C只继承了A中的成员<br> D、C不能继承A或B中的成员<br> 正确答案： A</p> 
<p>19下面说法中错误的是（）<br> A、静态代码块只在类加载后执行一次,以后再创建对象的时候不执行<br> B、局部代码块的作用是为了限制变量的生命周期<br> C、构造代码块在每创建一次对象就执行一次<br> D、以上都不对<br> 正确答案： D</p> 
<p>20下面程序运行的结果是（ ）<br> class Demo{<!-- --><br> public static void main(String[] args){<!-- --><br> int x = div(1,2);<br> try{<!-- --><br> }catch(Exception e){<!-- --><br> System.out.println(e);<br> }<br> System.out.println(x);<br> }<br> public static int div(int a,int b){<!-- --><br> return a / b ;<br> }<br> }<br> A、输出1<br> B、输出0<br> C、输出0.5<br> D、编译失败<br> 正确答案： B<br> 21下面关于throws作用的描述中，正确的是（ ）<br> A、一个方法只能抛出一个异常信息<br> B、一个方法上使用throws声明一个异常说明这个方法运行时一定会抛出这个异常<br> C、throws可以声明在方法体中用来指定抛出的具体异常<br> D、throws关键字需要写在方法声明的后面<br> 正确答案： D<br> 答案解析：throws关键字需要写在方法声明的后面，throws后面需要声明方法中发生异常的类型，通常将这种做法称为方法声明抛出一个异常。</p> 
<p>22下列程序运行结果是（ ）<br> public class Demo {<!-- --><br> public static void main(String[] args) {<!-- --><br> Object obj=new Father(){<!-- --><br> public void show(){<!-- --><br> System.out.println(“helloworld”);<br> }<br> };<br> obj.show();<br> }<br> }<br> class Father{<!-- --><br> public void show(){<!-- --><br> System.out.println(“hello father”);<br> }<br> }<br> A、hellofather<br> B、helloworld<br> C、无结果<br> D、程序编译报错<br> 正确答案： D<br> 答案解析：父类引用不能调用子类的特有的方法。</p> 
<p>23下列选项中，哪一个类是Object的子类（）<br> A、public final class String{}<br> B、﻿public class Person{}<br> C、public abstrac tAnimal{}<br> D、以上三个类都是Object子类<br> 正确答案： D<br> 答案解析：所有类都是Object子类。</p> 
<p>24下列选项中，不可以被final修饰的是（ ）<br> A、接口<br> B、类<br> C、方法<br> D、变量<br> 正确答案： A<br> 答案解析：final关键字可用于修饰类、变量和方法。</p> 
<p>25final修饰符不可以修饰如下哪个内容（）<br> A、类<br> B、接口<br> C、方法<br> D、变量<br> 正确答案： B<br> 答案解析：final关键字可用于修饰类、变量和方法。</p> 
<p>26final修饰符修饰方法时，不能和以下哪个修饰符共用（）<br> A、public<br> B、static<br> C、abstract<br> D、synchronized<br> 正确答案： C<br> 答案解析：final修饰符不能和abstract修饰符一起使用。</p> 
<p>27现有两个类A、B，以下描述中表示B继承自A的是（）<br> A、class A extends B.class<br> B、class B implements A<br> C、class A implements B<br> D、class B extends A<br> 正确答案： D<br> 答案解析：类的继承 关键字 extends在Java中，类的继承是通过extends关键字表示的，要想描述B继承自A，则正确的写法是class B extends A。</p> 
<p>28如果父类的方法是静态的，则子类的方法被（）修饰才能覆盖父类的静态方法 。<br> A、protected<br> B、static<br> C、private<br> D、final<br> 正确答案： B<br> 答案解析：只有子类的方法为静态时才能重写父类的静态方法。</p> 
<p>29下列关于继承的描述中，错误的是（）<br> A、在Java中，类只支持单继承，不允许多重继承，也就是说一个类只能有一个直接父类<br> B、多个类可以继承一个父类<br> C、在Java中，多层继承是可以的，即一个类的父类可以再去继承另外的父类，例如C类继承自B类，而B类又可以去继承A类，这时，C类也可称作A类的子类<br> D、Java是支持多继承的<br> 正确答案： D<br> 答案解析：Java不支持多继承。</p> 
<h3><a id="11132_344"></a>二.多选题（共11题,13.2分）</h3> 
<p>1下列关于静态代码块的描述中，正确的是（ ）<br> A、静态代码块指的是被static关键字修饰的代码块<br> B、静态代码块随着类的加载而加载<br> C、使用静态代码块可以实现类的初始化<br> D、每次创建对象时，类中的静态代码块都会被执行一次<br> 正确答案： ABC<br> 答案解析：静态代码块中的代码只会给执行一次。</p> 
<p>2下面对static的描述正确的是（）<br> A、静态修饰的成员变量和成员方法随着类的加载而加载<br> B、静态修饰的成员方法可以访问非静态成员变量<br> C、静态修饰的成员可以被整个类对象所共享<br> D、静态修饰的成员变量和成员方法随着类的消失而消失<br> 正确答案： ACD</p> 
<p>3以下关于static关键字的说法正确的是（）<br> A、static关键字可以修饰类<br> B、static关键字可以修饰成员<br> C、static关键字可以修饰所有的变量<br> D、static关键字可以修饰代码块<br> 正确答案： BD</p> 
<p>4在Java中，下面关于抽象类的描述正确的是（）。<br> A、抽象类可以被实例化<br> B、如果一个类中有一个方法被声明为抽象的，那么这个类必须是抽象类<br> C、抽象类中的方法必须都是抽象的<br> D、声明抽象类必须带有关键字abstract<br> 正确答案： BD</p> 
<p>5在Java接口中定义常量，下面语法正确的是（）。<br> A、static int MALE = 1;<br> B、final int MALE = 1;<br> C、int MALE = 1;<br> D、private int MALE = 1;<br> 正确答案： ABC</p> 
<p>6若Animal 是Cat,Dog的父类，则下列选项中，正确的是（）<br> A、Animal animal = new Cat();<br> B、Cat cat = (Cat)new Animal();<br> C、Animal animal = new Dog();<br> D、Cat cat = (Cat)new Dog();<br> 正确答案： AC<br> 答案解析：将子类对象当做父类使用时不需要任何显式地声明，需要注意的是，此时不能通过父类变量去调用子类中某些方法。</p> 
<p>7在Java中，下面关于抽象类的描述正确的是（）。<br> A、抽象类可以被实例化<br> B、如果一个类中有一个方法被声明为抽象的，那么这个类必须是抽象类<br> C、抽象类中的方法必须都是抽象的<br> D、声明抽象类必须带有关键字abstract<br> 正确答案： BD</p> 
<p>8在java中，已定义了两个接口B和C，下面继承语句正确的是（）<br> A、interface A extends B,C<br> B、interface A implements B,C<br> C、class A implements B,C<br> D、class A implements B,implements C<br> 正确答案： AC</p> 
<p>9下列关于throws的描述中，正确的是（ ）<br> A、throws是用来声明一个方法可能抛出的异常信息<br> B、throws语句用在方法声明后面<br> C、方法中没有使用catch处理的异常必须使用throws抛出<br> D、throws关键字对外声明该方法有可能发生的异常，调用者在调用方法时必须在程序中对异常进行处理<br> 正确答案： ABCD<br> 答案解析：针对这种情况，Java中允许在方法的后面使用throws关键字对外声明该方法有可能发生的异常，这样调用者在调用方法时，就明确地知道该方法有异常，并且必须在程序中对异常进行处理，否则编译无法通过。</p> 
<p>10下列关于对象间类型转换的描述中，正确的是（ ）<br> A、类型转换的前提是存在继承关系<br> B、强制类型转换可以实现对象间的类型转换。<br> C、对象之间的类型转换是多态的一种体现<br> D、对象之间的类型转换可以降低代码的耦合度<br> 正确答案： ACD<br> 答案解析：类型转换的定义和作用。</p> 
<p>11以下关于方法重写，说法错误的是（ ）<br> A、方法重写时，子类的函数名与形参列表必须与父类的一致<br> B、方法重写时，子类的返回值类型必须大于或者等于父类的返回值类型<br> C、方法重写时，子类的权限修饰符必须大于或者等于父类的权限修饰符<br> D、方法重写与返回值类型无关<br> 正确答案： BD<br> 答案解析：方法重写时，子类的返回值类型必须小于或者等于父类的返回值类型 。且在子类中重写的方法需要和父类被重写的方法具有相同的方法名、参数列表以及返回值类型。</p> 
<h3><a id="21252_428"></a>三.填空题（共21题,25.2分）</h3> 
<p>1【】是对某一类事物的抽象描述，而对象用于表示现实中该类事物的个体。<br> 正确答案：<br> 第一空：<br> 类</p> 
<p>2被static关键字修饰的成员变量被称为【】，它可以被该类所有的实例对象共享。<br> 正确答案：<br> 第一空：<br> 静态变量</p> 
<p>3如果一个方法没有返回任何值，则该方法的返回值类型为【】。<br> 正确答案：<br> 第一空：<br> void</p> 
<p>4this关键字可以访问一个类的【】变量，解决与局部变量名称冲突的问题。<br> 正确答案：<br> 第一空：<br> 成员</p> 
<p>5构造方法的名称必须和【】保持一致。<br> 正确答案：<br> 第一空：<br> 类名</p> 
<p>答案解析：<br> 在一个类中定义的方法如果同时满足以下三个条件，该方法称为构造方法，具体如下：<br> 1、 方法名与类名相同<br> 2、 在方法名的前面没有返回值类型的声明<br> 3、 在方法中不能使用retur</p> 
<p>6请阅读下面的程序，在空白处填写正确的代码，完成构造方法重载，并为成员变量赋值。<br> public class Person {<!-- --><br> String name;<br> int age;<br> public Person() {<!-- --><br> }<br> public ____(String n, int a) {<!-- --><br> ____ = ____;<br> ____ = ____;<br> }<br> }<br> 正确答案：<br> 第一空：<br> Person<br> 第二空：<br> name<br> 第三空：<br> n<br> 第四空：<br> age<br> 第五空：<br> a<br> 答案解析：<br> 在一个类中可以定义多个构造方法，只要每个构造方法的参数类型或参<br> 数个数不同即可。在创建对象时，可以通过调用不同的构造方法来为不同<br> 的属性进行赋值。</p> 
<p>7构造方法没有返回值类型，因此不能使用【】语句。<br> 正确答案：<br> 第一空：<br> return<br> 答案解析：构造方法没有返回值类型，因此不能使用return语句。</p> 
<p>8请阅读下面的程序，在空白处填写正确的代码，把Person类的所有属性全部封装起来。<br> public class Person{<!-- --><br> _______ String name;<br> public String _______(){<!-- --><br> return name;<br> }<br> public void _______(String n){<!-- --><br> name = n;<br> }<br> }<br> 正确答案：<br> 第一空：<br> private<br> 第二空：<br> getName<br> 第三空：<br> setName<br> 答案解析：所谓类的封装是指在定义一个类时，将类中的属性私有化，即使用private关键字来修饰，私有属性只能在它所在类中被访问，为了能让外界访问私有属性，需要提供一些使用public修饰的公有方法，其中包括用于获取属性值的getXxx方法和设置属性值的setXxx方法。</p> 
<p>9类与对象的关系中，【】用于描述多个对象的共同特征，它是对象的模板。<br> 正确答案：<br> 第一空：<br> 类</p> 
<p>10在Java中，针对类、成员方法和属性提供了四种访问级别，分别是public、【】、【】和【】。<br> 正确答案：<br> 第一空：<br> private<br> 第二空：<br> default<br> 第三空：<br> protected</p> 
<p>11在一个类的内部嵌套定义的类称为【】。<br> 正确答案：<br> 第一空：<br> 内部类</p> 
<p>12在Java语言中，所有的类都直接或间接继承自【】类。<br> 正确答案：<br> 第一空：<br> Object</p> 
<p>13Object类中的equals方法的参数是【】类型的参数。<br> 正确答案：<br> 第一空：<br> Object</p> 
<p>14RuntimeException类及其子类都是【】异常。<br> 正确答案：<br> 第一空：<br> 运行时</p> 
<p>15Java中提供了大量的异常类，这些类都继承自【】类<br> 正确答案：<br> 第一空：<br> java.lang.Throwable</p> 
<p>16在继承关系中，子类会自动继承父类中的方法，但有时在子类中需要对继承的方法进行一些修改，即对父类的方法进行【】。<br> 正确答案：<br> 第一空：<br> 重写</p> 
<p>17throw关键字用于在方法中声明抛出异常的【】。<br> 正确答案：<br> 第一空：<br> 实例对象<br> 答案解析：throw关键字用于在方法中声明抛出异常的实例对象。</p> 
<p>18运行时异常的特点是Java编译器【】（会/不会？）对其进行检查。<br> 正确答案：<br> 第一空：<br> 不会<br> 答案解析：运行时异常的特点是Java编译器不会对其进行检查，也就是说，当程序中出现这类异常时，即使没有使用try…catch语句捕获或使用throws关键字声明抛出，程序也能编译通过。</p> 
<p>19在定义方法时不写方法体，这种不包含方法体的方法为【】方法。<br> 正确答案：<br> 第一空：<br> 抽象<br> 答案解析：Java允许在定义方法时不写方法体，不包含方法体的方法为抽象方法，抽象方法必须使用abstract关键字来修饰。</p> 
<p>20阅读下面的程序，在不new Cat类的情况下,添加代码运行Demo的mian方法后执行Cat的eat()方法。<br> public class Demo {<!-- --><br> public static void main(String[] args) {<!-- --><br> Animal animal = new Cat();<br> ________；<br> cat.eat();<br> }<br> }<br> class Animal{<!-- --><br> public void eat(){<!-- --><br> System.out.println(“animal eat”);<br> }<br> }<br> class Cat extends Animal{<!-- --><br> public void eat(){<!-- --><br> System.out.println(“cat eat”);<br> }<br> }<br> 正确答案：<br> 第一空：<br> Cat cat = (Cat)animal;<br> 答案解析：由子类对象转化得到的父类对象可以强制转换为同类型的子类对象。</p> 
<p>21final修饰的成员变量初始化赋值有两种方式,第一显示初始化赋值,第二【】初始化赋值。<br> 正确答案：<br> 第一空：<br> 构造函数<br> 答案解析：final修饰的成员变量初始化赋值有两种方式,第一显示初始化赋值,第二构造函数初始化赋值。</p> 
<h3><a id="19268_605"></a>四.判断题（共19题,26.8分）</h3> 
<p>1在定义一个类的时候，如果类的成员被private所修饰，该成员不能在类的外部被直接访问。<br> 正确答案：√<br> 答案解析：如果类的成员被private访问控制符修饰，则这个成员只能被该类的其它成员访问，其它类无法直接访问。类的良好封装就是通过private关键字实现的。</p> 
<p>2Bank bank = new Bank(“小梦”, “654321”, 100.0);的作用是将Bank类实例化，并传入参数。<br> 正确答案：√</p> 
<p>3新用户到达银行之后，银行会表示欢迎，所以应该在银行类中定义欢迎方法。欢迎的语句都是一样的，所以此方法可定义为静态方法。<br> 正确答案：√</p> 
<p>4静态代码块不会优先于构造代码块运行。<br> 正确答案：×<br> 答案解析：静态代码块：最早执行，类被载入内存时执行，只执行一次。没有名字、参数和返回值，有关键字static。<br> 构造代码块：执行时间比静态代码块晚，比构造函数早，和构造函数一样，只在对象</p> 
<p>5静态代码块中可以对静态成员变量进行赋值。<br> 正确答案：√<br> 答案解析：静态代码块中可以对静态成员变量进行赋值。</p> 
<p>6构造方法重载后，在构造方法中可以使用this语句进行构造方法之间的调用，在重载的两个构造方法中可以使用this语句相互调用。<br> 正确答案：×<br> 答案解析：构造方法重载，不能在一个类的两个构造方法中使用this互相调用。</p> 
<p>7在Java程序中，定义类必须使用class关键字。<br> 正确答案：√</p> 
<p>8Java中的每个类都至少有一个构造方法，一个类中如果没有定义构造方法，系统会自动为这个类创建一个默认的构造方法。<br> 正确答案：√<br> 答案解析：Java中的每个类都至少有一个构造方法，一个类中如果没有定义构造方法，系统会自动为这个类创建一个默认的构造方法。</p> 
<p>9类中static修饰的变量或方法，可以使用类名或对象的引用变量访问。<br> 正确答案：√</p> 
<p>10Throwable有两个直接子类Error和Exception，其中Error代表程序中产生的异常，Exception代表程序中产生的错误。<br> 正确答案：×</p> 
<p>11Java中被final关键字修饰的变量，不能被重新赋值。<br> 正确答案：√<br> 答案解析：Java中被final关键字修饰的变量，称为常量，他只能被赋值一次。</p> 
<p>12Throwable有两个直接子类Error和Exception，其中Error代表程序中产生的异常，Exception代表程序中产生的错误。<br> 正确答案：×</p> 
<p>13throw关键字后面必须写异常对象。<br> 正确答案：√<br> 答案解析：throw关键字用在方法内部，后面必须写异常对象。</p> 
<p>14JDK中定义了大量的异常类，这些异常类足够我们使用了，所以，我们不需要自己定义异常类。<br> 正确答案：×<br> 答案解析：JDK中定义了大量的异常类，虽然这些异常类可以描述编程时出现的大部分异常情况，但是在程序开发中有时可能需要描述程序中特有的异常情况，所以，我们在开发中还是需要自己定义异常类。</p> 
<p>15在Java中允许用户自定义异常，但自定义的异常类必须继承自Exception或其子类。<br> 正确答案：√<br> 答案解析：在Java中允许用户自定义异常，但自定义的异常类必须继承自Exception或其子类，只有这样，你的类才能被认为是异常体系结构的一部分，是一个异常类。</p> 
<p>16如果一个方法要抛出多个异常，可以使用throws进行声明。<br> 正确答案：√<br> 答案解析：一个方法中可以抛出多个异常，可以使用throws关键字，并且每个异常之间用逗号隔开。</p> 
<p>17Object类的构造方法第一行是super()语句。<br> 正确答案：×<br> 答案解析：Object没有父类，构造方法第一行不是super。</p> 
<p>18被final修饰的成员变量不能被继承。<br> 正确答案：×<br> 答案解析：被final修饰的变量可以被继承，被final修饰的类不能被继承。</p> 
<p>19有如下三个类<br> class A<br> {…}<br> class B extends A<br> {…}<br> class C extends A<br> {…}<br> 因为 B类和C类不存在继承关系 ，因此他们之间不能进行类型转换。<br> 正确答案：√<br> 答案解析：不存在继承关系的对象之间不能进行类型转换。</p> 
<h2><a id="_685"></a>第二次作答</h2> 
<h3><a id="_26312_686"></a>一. 单选题（共26题，31.2分）</h3> 
<ol><li> <p>(单选题)在Java语言中，String类型的成员变量的默认初始值是（ ）<br> A. false<br> B. “”<br> C. 0<br> D. null<br> 正确答案: D<br> 答案解析：String类型属于引用类型，引用类型的默认初始值为null。</p> </li><li> <p>(单选题)在Java中，要想让一个类继承另一个类，可以使用以下哪个关键字（）<br> A. inherits<br> B. extends<br> C. implements<br> D. modifies<br> 正确答案: B</p> </li><li> <p>(单选题)如果类的成员被（ ）访问控制符来修饰，则这个成员只能被该类的其它成员访问，其它类无法直接访问。<br> A. private<br> B. default<br> C. protected<br> D. public<br> 正确答案: A<br> 答案解析：如果类的成员被private访问控制符来修饰，则这个成员只能被该类的其它成员访问，其它类无法直接访问。类的良好封装就是通过private关键字来实现的</p> </li><li> <p>(单选题)静态方法运行时，在哪个内存区域中（ ）<br> A. 栈内存<br> B. 堆内存<br> C. 方法区<br> D. 寄存器<br> 正确答案: A<br> 答案解析：访问运行都在栈内存。</p> </li><li> <p>(单选题)现有两个类A、B，以下描述中表示B继承自A的是（）<br> A. class A extends B.class<br> B. class B implements A<br> C. class A implements B<br> D. class B extends A<br> 正确答案: D<br> 答案解析：类的继承 关键字 extends在Java中，类的继承是通过extends关键字表示的，要想描述B继承自A，则正确的写法是class B extends A。</p> </li><li> <p>(单选题)下面选项中，类的声明方式正确的是（）<br> A. public void AA{…}<br> B. public class Move(){…}<br> C. public class void number{…}<br> D. public class Car{…}<br> 正确答案: D</p> </li><li> <p>(单选题)下列关于类和对象的描述，错误的是（ ）<br> A. 对象是类的实例<br> B. 一个类只能有一个实例化对象<br> C. 类是对象的抽象<br> D. 类用于描述一组对象的共同特征和行为<br> 正确答案: B<br> 答案解析：类是对象的模板，对象是类的实例，一个类可以创建多个对象。</p> </li><li> <p>(单选题)在类的继承关系中，需要遵循以下哪个继承原则（）<br> A. 多重<br> B. 单一<br> C. 双重<br> D. 不能继承<br> 正确答案: B</p> </li><li> <p>(单选题)<br> 阅读下列代码：<br> public class Test{<!-- --><br> int count = 9;<br> public void count1(){<!-- --><br> int count =10;<br> System.out.println(“count1=”+count);<br> }<br> public void count2(){<!-- --><br> System.out.println(“count2=”+count);<br> }<br> public static void main(String args[]){<!-- --><br> Test t=new Test();<br> t.count1();<br> t.count2();<br> }<br> }<br> 编译运行后，输出结果是（）<br> A.count1=9 count2=9<br> B.count1=10 count2=9<br> C. count1=10 count2=10<br> D.count1=9 count2=10<br> 正确答案: B</p> </li><li> <p>(单选题)下列修饰符中，成员内部类被（ ）修饰后，可以被外界访问。<br> A. default<br> B. protected<br> C. public<br> D. private<br> 正确答案: C<br> 答案解析：成员内部类被public修饰后可以被外界访问，如果内部类被声明为私有，外界将无法访问。</p> </li><li> <p>(单选题)关于final修饰成员变量说法正确的是（）<br> A. 被final修饰的成员变量为常量<br> B. 被final修饰的成员变量不能被继承<br> C. 被final修饰的成员变量可以被多次赋值<br> D. final只能在接口中修饰成员变量<br> 正确答案: A<br> 答案解析：被final修饰的变量可以被继承，被final修饰的类不能被继承，被final修饰的变量为常量不能被第二次赋值或改变引用。</p> </li><li> <p>(单选题)在Java接口中，下列选项中属于有效的方法声明的是（）<br> A. public void aMethod();<br> B. final void aMethod();<br> C. void aMethod(){}<br> D. private void aMethod();<br> 正确答案: A</p> </li><li> <p>(单选题)阅读下面代码：<br> public interface Face{<!-- --><br> int counter = 40;<br> }<br> public class Test implements Face{<!-- --><br> private static int counter;<br> public static void main(String[]args){<!-- --><br> System.out.println(++counter);<br> }<br> }<br> Test.java 的编译运行结果是（）。<br> A. 40<br> B. 41<br> C. 0<br> D. 1<br> 正确答案: D</p> </li><li> <p>(单选题)float类型成员变量的默认初始化值是（ ）<br> A. 0<br> B. false<br> C. null<br> D. 0.0F<br> 正确答案: D<br> 答案解析：实例化对象时 ，Java虚拟机会自动为成员变量进行初始化，针对不同类型的成员变量，Java虚拟机会赋予不同的初始值。float类型的默认初始值是0.0F。</p> </li><li> <p>(单选题)阅读下列代码：<br> public class Test {<!-- --><br> int x, y;<br> Test(int x, int y) {<!-- --><br> this.x = x;<br> this.y = y;<br> }<br> public static void main(String[] args) {<!-- --><br> Test pt1, pt2;<br> pt1 = new Test(3, 3);<br> pt2 = new Test(4, 4);<br> System.out.print(pt1.x + pt2.x);<br> }<br> }<br> 上述代码的运行结果为（）<br> A. 6<br> B. 3 4<br> C. 8<br> D. 7<br> 正确答案: D</p> </li><li> <p>(单选题)下列符号中，哪个用于分隔throws关键字抛出的多个异常（）<br> A. ；<br> B. ，<br> C. &amp;<br> D. |<br> 正确答案: B<br> 答案解析：方法中如果有多个异常，他们之间使用逗号隔开。</p> </li><li> <p>(单选题)下列关于面向对象的说法中，错误的是（ ）<br> A. 面向对象思想编程，不仅增强代码了复用性，提供了开发效率，而且为程序的修改补充提供了便利。<br> B. 面向对象就是分析解决问题所需要的步骤，然后用函数把这些步骤一一实现，使用的时候一个一个依次调用。<br> C. 面向对象是把解决的问题按照一定规则划分为多个独立的对象，然后通过调用对象的方法来解决问题。<br> D. 面向对象虽然使程序的开发效率提高了，但是程序的处理效率相对面向过程程序要低。<br> 正确答案: B<br> 答案解析：面向对象是把解决的问题按照一定规则划分为多个独立的对象，然后通过调用对象的方法来解决问题，具有易维护性、质量高、效率高、易扩展性等特点。</p> </li><li> <p>(单选题)关于封装的描述，下面说法错误的是（）。<br> A. 封装将变化隔离<br> B. 封装提高重用性<br> C. 封装提高安全性<br> D. 只有被private修饰才叫做封装<br> 正确答案: D</p> </li><li> <p>(单选题)下列关于构造方法的描述，错误的是（ ）<br> A. 一个类中只能定义一个空参数的构造方法<br> B. 一个类中可以定义多个构造方法<br> C. 如果在一个类中定义有参的构造方法,jvm就不会提供默认的无参构造方法<br> D. 构造方法的作用是用来给属性进行初始化的<br> 正确答案: A<br> 答案解析：在一个类中可以定义多个构造方法，只要每个构造方法的参数类型或参数个数不同即可。</p> </li><li> <p>(单选题)请阅读下面程序<br> public class Test {<!-- --><br> public Test(){<!-- --><br> System.out.println(“构造方法一被调用了”);<br> }<br> public Test(int x){<!-- --><br> this();<br> System.out.println(“构造方法二被调用了”);<br> }<br> public Test(boolean b){<!-- --><br> this(1);<br> System.out.println(“构造方法三被调用了”);<br> }<br> public static void main(String[] args){<!-- --><br> Test test = new Test(true);<br> }<br> }<br> 上面程序的运行结果为（）<br> A.构造方法一、构造方法二和构造方法三都被调用了<br> B. 只有构造方法二和构造方法三被调用了<br> C. 只有构造方法一和构造方法三被调用了<br> D. 只有构造方法三被调用了<br> 正确答案: A<br> 答案解析：在测试类中调用了参数类型为boolean类型的构造方法时，先调用this(1);方法；在this(1);方法中，先调用this();方法；故运行结果为<br> “构造方法一被调用了”<br> “构造方法二被调用了”<br> “构造方法三被调用了”。</p> </li><li> <p>(单选题)class Demo{<!-- --><br> Demo(){<!-- --><br> }<br> }<br> 上述代码中定义了一个Demo类，下列构造方法可以存在于Demo类中的是 （ ）<br> A. public Demo(){}<br> B. private Demo(){}<br> C. Demo(int age,String name)(){}<br> D. Demo(){}<br> 正确答案: C<br> 答案解析：构造方法可以重载。</p> </li><li> <p>(单选题)下列关于静态方法的描述中，错误的是（ ）<br> A. 静态方法指的是被static关键字修饰的方法<br> B. 静态方法不占用对象的内存空间，而非静态方法占有对象的内容空间<br> C. 静态方法内可以使用this关键字<br> D. 静态方法内部只能访问被static修饰的成员<br> 正确答案: C<br> 答案解析：静态方法内部不可以使用this、super等关键字。</p> </li><li> <p>(单选题)请阅读下面的程序代码，选择正确的运行结果（ ）<br> class Person{<!-- --><br> void say(){<!-- --><br> System.out.println(“hello”);<br> }<br> }<br> class Example{<!-- --><br> public static void main(String[] args){<!-- --><br> Person p2 = new Person();<br> Person p1 = new Person();<br> p2.say();<br> p1.say();<br> p2=null;<br> p2.say();<br> }<br> }<br> A. 输出1个hello<br> B. 输出2个hello后会抛出异常<br> C. 输出3个hello后会抛出异常<br> D. 不会输出hello，直接抛出异常<br> 正确答案: B<br> 答案解析：程序中创建了2个Person对象p1、p2，并分别调用了say()方法输出两个hello，然后将p2对象置为null，使p2对象失去了引用，因此再次使用p2对象调用say()方法时，会抛出异常。</p> </li><li> <p>(单选题)在Java中，要想让一个类继承另一个类，可以使用以下哪个关键字（）<br> A. inherits<br> B. extends<br> C. implements<br> D. modifies<br> 正确答案: B</p> </li><li> <p>(单选题)下列程序运行结果是（ ）<br> public class Demo {<!-- --><br> public static void main(String[] args) {<!-- --><br> Demo demo = new Demo();<br> demo.show(new Car() {<!-- --><br> public void run() {<!-- --><br> System.out.println(“demo run”);<br> }<br> });<br> }<br> public void show(Car c) {<!-- --><br> c.run();<br> }<br> }<br> abstract class Car {<!-- --><br> public void run() {<!-- --><br> System.out.println(“car run…”);<br> }<br> }<br> A. car run…<br> B. demo run<br> C. 无结果<br> D. 程序编译报错<br> 正确答案: B<br> 答案解析：使用在show()方法中传入匿名内部类对象，匿名内部类中重写了父类Car中run()方法。</p> </li><li> <p>(单选题)在类的继承关系中，需要遵循以下哪个继承原则（）<br> A. 多重<br> B. 单一<br> C. 双重<br> D. 不能继承<br> 正确答案: B</p> </li></ol> 
<h3><a id="_9108_984"></a>二. 多选题（共9题，10.8分）</h3> 
<ol start="27"><li> <p>(多选题)以下关于static关键字的说法正确的是（）<br> A. static关键字可以修饰类<br> B. static关键字可以修饰成员<br> C. static关键字可以修饰所有的变量<br> D. static关键字可以修饰代码块<br> 正确答案: BD</p> </li><li> <p>(多选题)下面对static的描述正确的是（）<br> A. 静态修饰的成员变量和成员方法随着类的加载而加载<br> B. 静态修饰的成员方法可以访问非静态成员变量<br> C. 静态修饰的成员可以被整个类对象所共享<br> D. 静态修饰的成员变量和成员方法随着类的消失而消失<br> 正确答案: ACD</p> </li><li> <p>(多选题)在java中，已定义了两个接口B和C，下面继承语句正确的是（）<br> A. interface A extends B,C<br> B. interface A implements B,C<br> C. class A implements B,C<br> D. class A implements B,implements C<br> 正确答案: AC</p> </li><li> <p>(多选题)关于super关键字以下说法哪些是正确的（）<br> A. super关键字可以调用父类的构造方法<br> B. super关键字可以调用父类的普通方法<br> C. super与this不能同时存在于同一个构造方法中<br> D. super与this可以同时存在于同一个构造方法中<br> 正确答案: ABC<br> 答案解析：A：super关键字可以调用父类的构造方法 ，正确。B：super关键字可以调用父类的普通方法，正确。C：super与this不能同时存在于同一个构造方法中，正确。D，super与this可以同时存在于同一个构造方法中，错误。</p> </li><li> <p>(多选题)下面对static的描述正确的是（）<br> A. 静态修饰的成员变量和成员方法随着类的加载而加载<br> B. 静态修饰的成员方法可以访问非静态成员变量<br> C. 静态修饰的成员可以被整个类对象所共享<br> D. 静态修饰的成员变量和成员方法随着类的消失而消失<br> 正确答案: ACD</p> </li><li> <p>(多选题)在Java接口中定义常量，下面语法正确的是（）。<br> A. static int MALE = 1;<br> B. final int MALE = 1;<br> C. int MALE = 1;<br> D. private int MALE = 1;<br> 正确答案: ABC</p> </li><li> <p>(多选题)下列关于对象间类型转换的说法中，正确的是（ ）<br> A. 与基本数据类型的相互转换一样，对象的类型转换可通过自动转换或强制转换进行<br> B. 无继承关系的两个类的对象之间试图转换时出现编译错误<br> C. 有继承关系的两个类的对象之间，子类的对象转换为父类的对象，可自动转换也可以强制转换<br> D. 由new语句创建的父类对象不能转换为子类的对象<br> 正确答案: ABCD</p> </li><li> <p>(多选题)Throwable有两个直接子类是？（ ）<br> A. Error<br> B. Exception<br> C. ArithmeticException<br> D. 以上说法都不对<br> 正确答案: AB</p> </li><li> <p>(多选题)在Java接口中定义常量，下面语法正确的是（）。<br> A. static int MALE = 1;<br> B. final int MALE = 1;<br> C. int MALE = 1;<br> D. private int MALE = 1;<br> 正确答案: ABC</p> </li></ol> 
<h3><a id="_23276_1050"></a>三. 填空题（共23题，27.6分）</h3> 
<ol start="36"><li> <p>(填空题)类的封装是指在定义一个类时，将类中的属性私有化，即使用【】关键字来修饰。<br> 正确答案：<br> (1) private</p> </li><li> <p>(填空题)面向对象的三大特征是【】、【】和【】。<br> 正确答案：<br> (1) 封装性<br> (2) 继承性<br> (3) 多态性</p> </li><li> <p>(填空题)请阅读下面的程序，在空白处填写正确的代码，完成构造方法重载，并为成员变量赋值。<br> public class Person {<!-- --><br> String name;<br> int age;<br> public Person() {<!-- --><br> }<br> public ____(String n, int a) {<!-- --><br> ____ = ____;<br> ____ = ____;<br> }<br> }<br> 正确答案：<br> (1) Person<br> (2) name<br> (3) n<br> (4) age<br> (5) a<br> 答案解析：在一个类中可以定义多个构造方法，只要每个构造方法的参数类型或参<br> 数个数不同即可。在创建对象时，可以通过调用不同的构造方法来为不同<br> 的属性进行赋值。</p> </li><li> <p>(填空题)Java中的异常分为两种,一种是【】另外一种是运行时异常。<br> 正确答案：<br> (1) 编译时异常<br> 答案解析：Java中的异常分为两种,一种是编译时异常另外一种是运行时异常。</p> </li><li> <p>(填空题)Object类中的equals方法的参数是【】类型的参数。<br> 正确答案：<br> (1) Object</p> </li><li> <p>(填空题)类与对象的关系中，【】用于描述多个对象的共同特征，它是对象的模板。<br> 正确答案：<br> (1) 类</p> </li><li> <p>(填空题)throw关键字用于在方法中声明抛出异常的【】。<br> 正确答案：<br> (1) 实例对象<br> 答案解析：throw关键字用于在方法中声明抛出异常的实例对象。</p> </li><li> <p>(填空题)所谓类的封装是指在定义一个类时，将类中的属性私有化，即使用【】关键字来修饰。<br> 正确答案：<br> (1) private</p> </li><li> <p>(填空题)int类型的成员变量初始化值为【】。<br> 正确答案：<br> (1) 0<br> 答案解析：int类型的成员变量默认值为0<br> Java虚拟机会自动为成员变量进行初始化，针对不同类型的成员变量，Java虚拟机会赋予不同的初始值，如int类型的成员变量初始值为0，long类型的成员变量初始值为0L。</p> </li><li> <p>(填空题)Java中成员变量用于描述对象的特征，也被称作【】。<br> 正确答案：<br> (1) 属性<br> 答案解析：类中可以定义成员变量和成员方法，其中成员变量用于描述对象的特征，也被称作属性，成员方法用于描述对象的行为，可简称为方法。</p> </li><li> <p>(填空题)请阅读下面的程序，在空白处填写正确的代码， 使getInstance()方法返回一个Person对象.。<br> public class Person{<!-- --><br> public static _______ getInstance(){<!-- --><br> return _____________;<br> }<br> }<br> 正确答案：<br> (1) Person<br> (2) new Person();<br> 答案解析：该方法返回的是一个Person对象，所以返回值类型应该是Person，使用类创建对象时使用“new 类名（）”。</p> </li><li> <p>(填空题)this关键字可以访问一个类的【】变量，解决与局部变量名称冲突的问题。<br> 正确答案：<br> (1) 成员<br> 答案解析：通过this关键字可以明确地去访问一个类的成员变量，解决与局部变量名称冲突问题。</p> </li><li> <p>(填空题)Java中提供了大量的异常类，这些类都继承自【】类。<br> 正确答案：<br> (1) java.lang.Throwable</p> </li><li> <p>(填空题)Java中一个类最多可以继承【】（大写）个类。<br> 正确答案：<br> (1) 一<br> 答案解析：类的单继承在Java中，类只支持单继承，不允许多重继承，也就是说一个类只能有一个直接父类，因此Java中一个类最多可以继承一个类。</p> </li><li> <p>(填空题)自定义异常需要继承【】类。<br> 正确答案：<br> (1) Exception<br> 答案解析：Exception，所有异常超类。</p> </li><li> <p>(填空题)在Java中，针对类、成员方法和属性提供了四种访问级别，分别是public、【】、【】和【】。<br> 正确答案：<br> (1) private<br> (2) default<br> (3) protected</p> </li><li> <p>(填空题)Person p1 = new Person();Person p2 = p1;这两句代码创建了【】个对象。<br> 正确答案：<br> (1) 2</p> </li><li> <p>(填空题)请阅读下面的程序，在空白处填写正确的代码，把Person类的所有属性全部封装起来。<br> public class Person{<!-- --><br> _______ String name;<br> public String _______(){<!-- --><br> return name;<br> }<br> public void _______(String n){<!-- --><br> name = n;<br> }<br> }<br> 正确答案：<br> (1) private<br> (2) getName<br> (3) setName<br> 答案解析：所谓类的封装是指在定义一个类时，将类中的属性私有化，即使用private关键字来修饰，私有属性只能在它所在类中被访问，为了能让外界访问私有属性，需要提供一些使用public修饰的公有方法，其中包括用于获取属性值的getXxx方法和设置属性值的setXxx方法。</p> </li><li> <p>(填空题)在Java语言中，所有的类都直接或间接继承自【】类。<br> 正确答案：<br> (1) Object</p> </li><li> <p>(填空题)在Java中使用【】类型的实例对象表示一个字符串。<br> 正确答案：<br> (1)<br> String</p> </li><li> <p>(填空题)Person p1 = new Person();Person p2 = p1;这两句代码创建了【】个对象。<br> 正确答案：<br> (1) 2</p> </li><li> <p>(填空题)一个类如果要实现一个接口，可以通过关键字【】来实现这个接口。<br> 正确答案：<br> (1) implements<br> 答案解析：接口中的方法都是抽象方法，我们可以定义一个类，并使用implements关键字实现接口中所有的方法。</p> </li><li> <p>(填空题)在垃圾回收机制中，可以通过调用【】方法来通知Java虚拟机立即进行垃圾回收。<br> 正确答案：<br> (1) System.gc()<br> 答案解析：在垃圾回收机制中，除了等待Java虚拟机进行自动垃圾回收，也可以通过调用System.gc()方法来通知Java虚拟机立即进行垃圾回收。</p> </li></ol> 
<h3><a id="_22304_1195"></a>四. 判断题（共22题，30.4分）</h3> 
<ol start="59"><li> <p>(判断题)final修饰的静态方法可以被类名直接调用。<br> 正确答案: 对<br> 答案解析：final修饰静态方法，可以被类名调用。</p> </li><li> <p>(判断题)Error类称为错误类，它表示Java运行时产生的系统内部错误或资源耗尽的错误，是比较严重的，仅靠修改程序本身是不能恢复执行的。<br> 正确答案: 对</p> </li><li> <p>(判断题)私有属性只能在它所在类中被访问，为了能让外界访问私有属性，需要提供一些使用public修饰的公有方法。<br> 正确答案: 对<br> 答案解析：私有属性只能在它所在类中被访问，为了能让外界访问私有属性，需要提供一些使用public修饰的公有方法。</p> </li><li> <p>(判断题)成员内部类,就是将一个类定义在另一个类的成员的位置。<br> 正确答案: 对<br> 答案解析：成员内部类,就是将一个类定义在另一个类的成员的位置。</p> </li><li> <p>(判断题)<br> 有如下三个类<br> class A<br> {…}<br> class B extends A<br> {…}<br> class C extends A<br> {…}<br> 因为 B类和C类不存在继承关系 ，因此他们之间不能进行类型转换。<br> 正确答案: 对<br> 答案解析：不存在继承关系的对象之间不能进行类型转换。</p> </li><li> <p>(判断题)类中static修饰的变量或方法，可以使用类名或对象的引用变量访问。<br> 正确答案: 对</p> </li><li> <p>(判断题)Java中的异常类都继承自java.lang.Throwable类。<br> 正确答案: 对</p> </li><li> <p>(判断题)静态变量只能在静态方法中使用。<br> 正确答案: 错<br> 答案解析：静态变量可以被类直接调用也可以被其他静态和非静态成员调用。<br> 静态变量可以在静态和非静态方法中使用。静态变量被所有实例共享，可以使用“类名.变量名”的形式来访问。</p> </li><li> <p>(判断题)Throwable有两个直接子类Error和Exception，其中Error代表程序中产生的异常，Exception代表程序中产生的错误。<br> 正确答案: 错</p> </li><li> <p>(判断题)在Java中，子类可以覆盖父类中的任意方法。<br> 正确答案: 错<br> 答案解析：子类不能覆盖父类的私有方法和final方法。</p> </li><li> <p>(判断题)在定义一个类的时候，如果类的成员被private所修饰，该成员不能在类的外部被直接访问。<br> 正确答案: 对<br> 答案解析：如果类的成员被private访问控制符修饰，则这个成员只能被该类的其它成员访问，其它类无法直接访问。类的良好封装就是通过private关键字实现的。</p> </li><li> <p>(判断题)static String bankName; 用于定义静态变量银行名称。<br> 正确答案: 对</p> </li><li> <p>(判断题)类中static修饰的变量或方法，可以使用类名或对象的引用变量访问。<br> 正确答案: 对</p> </li><li> <p>(判断题)在Java中，针对类、成员方法和属性提供了四种访问级别，分别是private、static、protected和public。<br> 正确答案: 错<br> 答案解析：在Java中，针对类、成员方法和属性提供了四种访问级别，分别是private、default、protected和public。</p> </li><li> <p>(判断题)如果一个方法的形式参数定义的是父类对象,那么调用这个方法时,可以使用子类对象作为实际参数。<br> 正确答案: 对<br> 答案解析：如果一个方法的形式参数定义的是父类对象,那么调用这个方法时,可以使用子类对象作为实际参数。</p> </li><li> <p>(判断题)如果类中定义了构造方法，则系统不会自动创建默认的构造方法。<br> 正确答案: 对<br> 答案解析：只要定义构造方法，默认的就不存在了<br> 如果类中定义了构造方法，则系统不会自动创建默认的构造方法。</p> </li><li> <p>(判断题)抽象类中的方法只能定义成抽象的方法。<br> 正确答案: 错<br> 答案解析：抽象类可以不包含任何抽象方法。</p> </li><li> <p>(判断题)Java中被final关键字修饰的变量，不能被重新赋值。<br> 正确答案: 对<br> 答案解析：Java中被final关键字修饰的变量，称为常量，他只能被赋值一次。</p> </li><li> <p>(判断题)编译异常如果产生，可以处理，也可以不用处理。<br> 正确答案: 错<br> 答案解析：编译异常如果产生了，要求我们在必须处理，要么捕获，要么抛出。</p> </li><li> <p>(判断题)编译异常如果产生了，要求我们在必须处理，要么捕获，要么抛出。<br> 正确答案: 对<br> 答案解析：编译异常如果产生了，要求我们在必须处理，要么捕获，要么抛出</p> </li><li> <p>(判断题)在静态方法内可以调用非静态方法。<br> 正确答案: 错</p> </li><li> <p>(判断题)抽象类实现接口时，可以不实现接口中的任何方法。<br> 正确答案: 对<br> 答案解析：当一个类实现接口时，如果这个类是抽象类，则实现接口中的部分方法即可(其实也可以不实现)，否则需要实现接口中的所有方法。</p> </li></ol>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/73e5aa388ca032281939d17bf83309d4/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">在docker中配置mysql数据库 并配置远程连接</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/072c8103857c5227cd87ed7da3325736/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">bash脚本编写教程</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>