<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【Kotlin精简】第9章 Kotlin Flow - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【Kotlin精简】第9章 Kotlin Flow" />
<meta property="og:description" content="1 前言 上一章节我们学习了Kotlin的协程【Kotlin精简】第8章 协程，我们知道 协程实质是对线程切换的封装，能更加安全实现异步代码同步化，本质上协程、线程都是服务于并发场景下，其中协程是协作式任务，线程是抢占式任务。默认协程用来处理实时性不高的数据，请求到结果后整个协程就结束了，即它是一锤子买卖。
本章节我们来学习一下依赖Kotlin协程实现的Flow数据流。
2 Flow简介 2.1 Flow是什么 Flow是google官方提供的一套基于Kotlin协程的响应式编程模型，它与RxJava的使用类似，但相比之下Flow使用起来更简单，另外Flow作用在协程内，可以与协程的生命周期绑定，当协程取消时，Flow也会被取消，避免了内存泄漏风险。
Flow是Kotlin提供的一个工具，使用协程封装成生产者-消费者模式。
上游来负责生产、中介进行数据加工（可选）、下游来接收消耗。
官方对数据流三个成员的定义：
上游 - 提供方(生产者)：会生成添加到数据流中的数据。通过协程，数据流还可以异步生成数据。中介 - 数据加工 (可选)：修改发送到数据流的值，或修正数据流本身。下游 - 使用方（消费者）：使用或接收数据流中的值。
在Flow数据流中，api使用emit()生产，collect()消费
2.2 Flow 特性 flow{}构建块中的代码可以使用挂起函数
Flow构建器函数可以不用supend修饰符
流的每次单独收集都是按顺序执行的，除非使用特殊操作符
Flow是一种类似序列的冷流，flow构建器中代码直到流被收集的时候才运行
2.3 冷流热流 flow{}会创建一个数据流，并且这个数据流默认是冷流。下面是冷流和热流的区别：
冷流：当执行订阅的时候，上游发布者才开始发射数据流。订阅者与发布者是一一对应的关系，即当存在多个订阅者时，每个新的订阅者都会重新收到完整的数据。主动需要即是主动收集才会提供发射数据，即有消费collect才会触发热流：不管是否被订阅，上游发布者都会发送数据流到内存中。订阅者与发布者是一对多的关系，当上游发送数据时，多个订阅者都会收到消息。不管你需不需要一上来数据全都发射给你，不管是否消费collect都会触发 3 Flow使用 Flow官方文档可以参考一下，我们这里简单介绍一些Flow常用的流创建方式、操作符等。
Flow流使用步骤：
创建流：flow { ... }、flowOf{ ... }使用操作符修改、加工流数据发射流：collect 3.1 创建流 flow用于创建从顺序调用到发出函数的任意流。flowOf()函数根据一组固定的值创建流。asFlow()扩展函数可以将各种类型的函数转换为流。channelFlow创建从潜在并发调用到send函数的任意流。MutableStateFlow和MutableSharedFlow创建可直接更新的热流。 suspend fun main() { //1.不需要用挂起函数修饰符 flow { for (i in 1..3) { delay(1000)//可以使用挂起函数 emit(i)//发射元素 } }.collect { println(&#34;yvan flow:${it}&#34;) } // yvan flow:1 // yvan flow:2 // yvan flow:3 // 2." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/4a0e3f69b76387f1cd01fcbff3369ba2/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-11-24T16:31:42+08:00" />
<meta property="article:modified_time" content="2023-11-24T16:31:42+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【Kotlin精简】第9章 Kotlin Flow</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="1__0"></a>1 前言</h2> 
<p>上一章节我们学习了Kotlin的协程<a href="https://blog.csdn.net/u010687761/article/details/133237554?spm=1001.2014.3001.5502">【Kotlin精简】第8章 协程</a>，我们知道 <code>协程实质是对线程切换的封装，能更加安全实现异步代码同步化</code>，本质上协程、线程都是服务于并发场景下，其中协程是协作式任务，线程是抢占式任务。默认协程用来处理实时性不高的数据，请求到结果后整个协程就结束了，即它是一锤子买卖。</p> 
<p>本章节我们来学习一下依赖<code>Kotlin协程</code>实现的<code>Flow数据流</code>。</p> 
<h2><a id="2_Flow_4"></a>2 Flow简介</h2> 
<h3><a id="21_Flow_5"></a>2.1 Flow是什么</h3> 
<p><code>Flow</code>是<code>google</code>官方提供的一套基于<code>Kotlin协程</code>的<code>响应式编程模型</code>，它与<code>RxJava</code>的使用类似，但相比之下<code>Flow</code>使用起来更简单，另外<code>Flow</code>作用在<code>协程</code>内，可以与协程的生命周期绑定，当协程取消时，<code>Flow</code>也会被取消，避免了内存泄漏风险。<br> <code>Flow</code>是<code>Kotlin</code>提供的一个工具，使用协程封装成<code>生产者-消费者模式</code>。<br> <strong>上游来负责生产、中介进行数据加工（可选）、下游来接收消耗</strong>。</p> 
<p>官方对数据流三个成员的定义：</p> 
<ol><li><strong>上游 - 提供方(生产者)</strong>：会生成添加到数据流中的数据。通过协程，数据流还可以异步生成数据。</li><li><strong>中介 - 数据加工 (可选)</strong>：修改发送到数据流的值，或修正数据流本身。</li><li><strong>下游 - 使用方（消费者）</strong>：使用或接收数据流中的值。<br> <img src="https://images2.imgbox.com/ce/74/CEMP2rKR_o.png" alt="在这里插入图片描述"><br> 在<code>Flow</code>数据流中，api使用<code>emit()生产</code>，<code>collect()消费</code><br> <img src="https://images2.imgbox.com/b6/56/hcAwh8Hh_o.png" alt="在这里插入图片描述"></li></ol> 
<h3><a id="22_Flow__17"></a>2.2 Flow 特性</h3> 
<p><code>flow{}</code>构建块中的代码可以使用挂起函数<br> <code>Flow</code>构建器函数可以不用<code>supend</code>修饰符<br> 流的每次单独收集都是按顺序执行的，除非使用特殊操作符<br> <code>Flow</code>是一种类似序列的冷流，<code>flow</code>构建器中代码直到流被收集的时候才运行</p> 
<h3><a id="23__22"></a>2.3 冷流热流</h3> 
<p><code>flow{}</code>会创建一个数据流，并且这个数据流默认是冷流。下面是冷流和热流的区别：</p> 
<ol><li><code>冷流</code>：当执行订阅的时候，上游发布者才开始发射数据流。订阅者与发布者是一一对应的关系，即当存在多个订阅者时，每个新的订阅者都会重新收到完整的数据。主动需要即是主动收集才会提供发射数据，即有消费<code>collect</code>才会触发</li><li><code>热流</code>：不管是否被订阅，上游发布者都会发送数据流到内存中。订阅者与发布者是一对多的关系，当上游发送数据时，多个订阅者都会收到消息。不管你需不需要一上来数据全都发射给你，不管是否消费<code>collect</code>都会触发</li></ol> 
<h2><a id="3_Flow_27"></a>3 Flow使用</h2> 
<p><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-flow/" rel="nofollow">Flow官方文档</a>可以参考一下，我们这里简单介绍一些Flow常用的流创建方式、操作符等。</p> 
<p><strong>Flow流使用步骤</strong>：</p> 
<ol><li>创建流：<code>flow { ... }</code>、<code>flowOf{ ... }</code></li><li>使用操作符修改、加工流数据</li><li>发射流：<code>collect</code></li></ol> 
<h3><a id="31__34"></a>3.1 创建流</h3> 
<ol><li><code>flow</code>用于创建从顺序调用到发出函数的任意流。</li><li><code>flowOf()</code>函数根据一组固定的值创建流。</li><li><code>asFlow()</code>扩展函数可以将各种类型的函数转换为流。</li><li><code>channelFlow</code>创建从潜在并发调用到send函数的任意流。</li><li><code>MutableStateFlow</code>和<code>MutableSharedFlow</code>创建可直接更新的热流。</li></ol> 
<pre><code class="prism language-kotlin">
<span class="token keyword">suspend</span> <span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>

    <span class="token comment">//1.不需要用挂起函数修饰符</span>
    flow <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token keyword">in</span> <span class="token number">1</span><span class="token operator">..</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token comment">//可以使用挂起函数</span>
            <span class="token function">emit</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token comment">//发射元素</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">collect</span> <span class="token punctuation">{<!-- --></span>
        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"yvan flow:</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${<!-- --></span><span class="token expression">it</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token comment">//    yvan flow:1</span>
<span class="token comment">//    yvan flow:2</span>
<span class="token comment">//    yvan flow:3</span>

    <span class="token comment">// 2.flowOf 不需要挂起函数修饰符 flowOf自动实现发射元素</span>
    <span class="token function">flowOf</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">collect</span> <span class="token punctuation">{<!-- --></span>
            <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"yvan flowOf:</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${<!-- --></span><span class="token expression">it</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
<span class="token comment">//    yvan flowOf:1</span>
<span class="token comment">//    yvan flowOf:2</span>
<span class="token comment">//    yvan flowOf:3</span>
<span class="token comment">//    yvan flowOf:4</span>
<span class="token comment">//    yvan flowOf:5</span>

    <span class="token comment">// 3.asFlow 不需要挂起函数修饰符 flowOf自动实现发射元素</span>
    <span class="token punctuation">(</span><span class="token number">5</span><span class="token operator">..</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">asFlow</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">collect</span> <span class="token punctuation">{<!-- --></span>
            <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"yvan asFlow:</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${<!-- --></span><span class="token expression">it</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
<span class="token comment">//    yvan asFlow:5</span>
<span class="token comment">//    yvan asFlow:6</span>
<span class="token comment">//    yvan asFlow:7</span>
<span class="token comment">//    yvan asFlow:8</span>
<span class="token comment">//    yvan asFlow:9</span>
<span class="token comment">//    yvan asFlow:10</span>

    <span class="token comment">// 4.从潜在并发调用到send函数的任意流</span>
    channelFlow <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token keyword">in</span> <span class="token number">1</span><span class="token operator">..</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token comment">//可以使用挂起函数</span>
            <span class="token function">send</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token comment">//发射元素</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">{<!-- --></span>
        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"yvan channelFlow:</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${<!-- --></span><span class="token expression">it</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token comment">//    yvan channelFlow:1</span>
<span class="token comment">//    yvan channelFlow:2</span>
<span class="token comment">//    yvan channelFlow:3</span>


    <span class="token comment">// 5.热流SharedFlow的创建</span>
    runBlocking <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">val</span> sharedFlow <span class="token operator">=</span> MutableSharedFlow<span class="token operator">&lt;</span>Int<span class="token operator">&gt;</span><span class="token punctuation">(</span>
            <span class="token comment">// 相当于粘性次数</span>
            replay <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">,</span>
            <span class="token comment">// 接受得慢时候，发送入栈</span>
            extraBufferCapacity <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span>
            onBufferOverflow <span class="token operator">=</span> BufferOverflow<span class="token punctuation">.</span>SUSPEND
        <span class="token punctuation">)</span>

        launch <span class="token punctuation">{<!-- --></span>
            sharedFlow<span class="token punctuation">.</span><span class="token function">collect</span> <span class="token punctuation">{<!-- --></span>
                <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"yvan MutableSharedFlow:</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${<!-- --></span><span class="token expression">it</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>
            <span class="token punctuation">}</span>

        <span class="token punctuation">}</span>
        sharedFlow<span class="token punctuation">.</span><span class="token function">emit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
        sharedFlow<span class="token punctuation">.</span><span class="token function">emit</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token comment">//    yvan MutableSharedFlow:1</span>
<span class="token comment">//    yvan MutableSharedFlow:2</span>

    <span class="token comment">// 6.热流StateFlow的创建</span>
    runBlocking <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">val</span> stateFlow <span class="token operator">=</span> <span class="token function">MutableStateFlow</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
        launch <span class="token punctuation">{<!-- --></span>
            stateFlow<span class="token punctuation">.</span><span class="token function">collect</span> <span class="token punctuation">{<!-- --></span>
                <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"yvan MutableStateFlow:</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${<!-- --></span><span class="token expression">it</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        stateFlow<span class="token punctuation">.</span><span class="token function">emit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
        stateFlow<span class="token punctuation">.</span><span class="token function">emit</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token comment">//    yvan MutableStateFlow:2</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="32__132"></a>3.2 常用操作符</h3> 
<p>除上面3.1创建流前面三种<strong>创建操作符</strong>外，还有<strong>回调操作符</strong>、<strong>变换操作符</strong>、<strong>过滤操作符</strong>、<strong>组合操作符</strong>、<strong>功能性操作符</strong>、<strong>末端操作符</strong>等</p> 
<h4><a id="321__135"></a>3.2.1 创建操作符</h4> 
<p>上面3.1有介绍</p> 
<ol><li><code>flow</code>：创建<code>Flow</code>的操作符。</li><li><code>flowOf</code>：构造一组数据的<code>Flow</code>进行发送。</li><li><code>asFlow</code>：将其他数据转换成<code>Flow</code>，一般是集合向<code>Flow</code>的转换，如<code>listOf(1,2,3).asFlow()</code>。</li><li><code>callbackFlow</code>：将基于回调的 API 转换为<code>Flow</code>数据流</li></ol> 
<h4><a id="322__142"></a>3.2.2 回调操作符</h4> 
<p>我们先来看一个简单的例子</p> 
<pre><code class="prism language-kotlin">   flow <span class="token punctuation">{<!-- --></span>
        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"yvan start emit hello"</span></span><span class="token punctuation">)</span>
        <span class="token function">emit</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"hello"</span></span><span class="token punctuation">)</span> <span class="token comment">//发送数据</span>
        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"yvan start emit world"</span></span><span class="token punctuation">)</span>
        <span class="token function">emit</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"world"</span></span><span class="token punctuation">)</span> <span class="token comment">//发送数据</span>
        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"yvan end emit"</span></span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">flowOn</span><span class="token punctuation">(</span>Dispatchers<span class="token punctuation">.</span>IO<span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">onEmpty</span> <span class="token punctuation">{<!-- --></span> <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"yvan onEmpty"</span></span><span class="token punctuation">)</span> <span class="token punctuation">}</span>
        <span class="token punctuation">.</span><span class="token function">onStart</span> <span class="token punctuation">{<!-- --></span> <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"yvan onStart"</span></span><span class="token punctuation">)</span> <span class="token punctuation">}</span>
        <span class="token punctuation">.</span><span class="token function">onEach</span> <span class="token punctuation">{<!-- --></span> <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"yvan onEach: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">it</span></span><span class="token string">"</span></span><span class="token punctuation">)</span> <span class="token punctuation">}</span>
        <span class="token punctuation">.</span><span class="token function">onCompletion</span> <span class="token punctuation">{<!-- --></span> <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"yvan onCompletion"</span></span><span class="token punctuation">)</span> <span class="token punctuation">}</span>
        <span class="token punctuation">.</span><span class="token function">catch</span> <span class="token punctuation">{<!-- --></span> exception <span class="token operator">-&gt;</span> exception<span class="token punctuation">.</span>message<span class="token operator">?</span><span class="token punctuation">.</span><span class="token function">let</span> <span class="token punctuation">{<!-- --></span> <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"yvan catch exception:</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">it</span></span><span class="token string">"</span></span><span class="token punctuation">)</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span>
        <span class="token punctuation">.</span><span class="token function">collect</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">//接收数据流</span>
            <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"yvan collect: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">it</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
<span class="token comment">//        yvan onStart</span>
<span class="token comment">//        yvan start emit hello</span>
<span class="token comment">//        yvan onEach: hello</span>
<span class="token comment">//        yvan collect: hello</span>
<span class="token comment">//        yvan start emit world</span>
<span class="token comment">//        yvan onEach: world</span>
<span class="token comment">//        yvan collect: world</span>
<span class="token comment">//        yvan end emit</span>
<span class="token comment">//        yvan onCompletion</span>
</code></pre> 
<ol><li><code>onStart</code>：上游<code>flow{}</code>开始发送数据之前执行</li><li><code>onEach</code>：上游向下游发送数据之前调用，每一个上游数据发送后都会经过<code>onEach()</code></li><li><code>onEmpty</code>：当流完成却没有发出任何元素时执行。如<code>emptyFlow().onEmpty {}</code></li><li><code>onCompletion</code>：<code>flow</code>数据流取消或者结束时执行</li><li><code>onSubscription</code>：<code>SharedFlow </code>专用操作符，建立订阅之后回调。和<code>onStart</code>的区别：因为<code>SharedFlow</code>是热流，因此如果在<code>onStart</code>发送数据，下游可能接收不到，因为提前执行了。</li></ol> 
<h4><a id="323__179"></a>3.2.3 变换操作符</h4> 
<ol><li><code>map</code>：对上游发送的数据进行变换，collect最后接收的是变换之后的值</li></ol> 
<pre><code class="prism language-kotlin">    flow <span class="token punctuation">{<!-- --></span>
        <span class="token comment">//发送数据</span>
        <span class="token function">emit</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"hello"</span></span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">map</span> <span class="token punctuation">{<!-- --></span>
        <span class="token string-literal singleline"><span class="token string">"</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">it</span></span><span class="token string"> world"</span></span>
    <span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">collect</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">//接收数据流</span>
        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"yvan collect: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">it</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    
    <span class="token comment">// 输出：yvan collect: hello world</span>
</code></pre> 
<ol start="2"><li><code>mapLatest</code>：类似于collectLatest，当emit发送新值，会取消掉map上一次转换还未完成的值。</li></ol> 
<pre><code class="prism language-kotlin">    flow <span class="token punctuation">{<!-- --></span>
        <span class="token comment">//发送数据</span>
        <span class="token function">repeat</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span>
            <span class="token function">emit</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">mapLatest</span> <span class="token punctuation">{<!-- --></span>
        <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">15</span><span class="token punctuation">)</span>
        it
    <span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">collect</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">//接收数据流</span>
        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"yvan collect: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">it</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    
    <span class="token comment">//输出：yvan collect: 9</span>
</code></pre> 
<ol start="3"><li><code>mapNotNull</code>：仅发送map之后不为空的值。</li></ol> 
<pre><code class="prism language-kotlin"> flow <span class="token punctuation">{<!-- --></span>
        <span class="token comment">//发送数据</span>
        <span class="token function">repeat</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span>
            <span class="token function">emit</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">mapNotNull</span> <span class="token punctuation">{<!-- --></span>
        <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">15</span><span class="token punctuation">)</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>it <span class="token operator">&gt;</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            it
        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{<!-- --></span>
            <span class="token keyword">null</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">collect</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">//接收数据流</span>
        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"yvan collect: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">it</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

	<span class="token comment">//输出：</span>
	<span class="token comment">//yvan collect: 6</span>
	<span class="token comment">//yvan collect: 7</span>
	<span class="token comment">//yvan collect: 8</span>
	<span class="token comment">//yvan collect: 9</span>
</code></pre> 
<ol start="4"><li><code>transform</code>：对发出的值进行变换 。不同于map的是，经过transform之后可以重新发送数据，甚至发送多个数据，因为transform内部又重新构建了flow。</li></ol> 
<pre><code class="prism language-kotlin">    flow <span class="token punctuation">{<!-- --></span>
        <span class="token comment">//发送数据</span>
        <span class="token function">repeat</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span>
            <span class="token function">emit</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">transform</span> <span class="token punctuation">{<!-- --></span>
        <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span>
        <span class="token function">emit</span><span class="token punctuation">(</span>it<span class="token operator">*</span><span class="token number">10</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">collect</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">//接收数据流</span>
        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"yvan collect: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">it</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

	<span class="token comment">//输出：</span>
	<span class="token comment">//yvan collect: 0</span>
	<span class="token comment">//yvan collect: 10</span>
	<span class="token comment">//yvan collect: 20</span>
	<span class="token comment">//yvan collect: 30</span>
	<span class="token comment">//yvan collect: 40</span>
	<span class="token comment">//yvan collect: 50</span>
	<span class="token comment">//yvan collect: 60</span>
	<span class="token comment">//yvan collect: 70</span>
	<span class="token comment">//yvan collect: 80</span>
	<span class="token comment">//yvan collect: 90</span>
</code></pre> 
<ol start="5"><li><code>transformLatest</code>：类似于mapLatest，当有新值发送时，会取消掉之前还未转换完成的值。</li></ol> 
<pre><code class="prism language-kotlin">    flow <span class="token punctuation">{<!-- --></span>
        <span class="token comment">//发送数据</span>
        <span class="token function">repeat</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span>
            <span class="token function">emit</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">transformLatest</span> <span class="token punctuation">{<!-- --></span>
        <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span>
        <span class="token function">emit</span><span class="token punctuation">(</span>it<span class="token operator">*</span><span class="token number">10</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">collect</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">//接收数据流</span>
        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"yvan collect: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">it</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

	<span class="token comment">//输出：</span>
	<span class="token comment">//yvan collect: 90</span>
</code></pre> 
<ol start="6"><li><code>transformWhile</code>：返回值是一个Boolean，当为true时会继续往下执行；反之为false，本次发送的流程会中断。</li></ol> 
<pre><code class="prism language-kotlin">    flow <span class="token punctuation">{<!-- --></span>
        <span class="token comment">//发送数据</span>
        <span class="token function">repeat</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span>
            <span class="token function">emit</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">transformWhile</span> <span class="token punctuation">{<!-- --></span>
        <span class="token function">emit</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span>
        it <span class="token operator">!=</span> <span class="token number">2</span>
    <span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">collect</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">//接收数据流</span>
        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"yvan collect: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">it</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
	<span class="token comment">//输出：</span>
	<span class="token comment">//yvan collect: 0</span>
	<span class="token comment">//yvan collect: 1</span>
	<span class="token comment">//yvan collect: 2</span>

</code></pre> 
<ol start="7"><li><code>asSharedFlow</code>：MutableStateFlow 转换为 StateFlow ，即从可变状态变成不可变状态。</li><li><code>asStateFlow</code>：MutableSharedFlow 转换为 SharedFlow ，即从可变状态变成不可变状态。</li><li><code>receiveAsFlow</code>：Channel 转换为Flow ，上游与下游是一对一的关系。如果有多个下游观察者，可能会轮流收到值。</li><li><code>consumeAsFlow</code>：Channel 转换为Flow ，有多个下游观察者时会crash。</li><li><code>withIndex</code>：将数据包装成IndexedValue类型，内部包含了当前数据的Index。</li><li><code>scan(initial: R, operation: suspend (accumulator: R, value: T) -&gt; R)</code>：把initial初始值和每一步的操作结果发送出去。</li><li><code>produceIn</code>：转换为Channel的 ReceiveChannel</li><li><code>runningFold(initial, operation: (accumulator: R, value: T) -&gt; R)</code>：initial值与前面的流共同计算后返回一个新流，将每步的结果发送出去。</li><li><code>runningReduce</code>：返回一个新流，将每步的结果发送出去，默认没有initial值。</li><li><code>shareIn</code>：flow 转化为热流SharedFlow，后面会详细介绍。</li><li><code>stateIn</code>：flow转化为热流StateFlow，后面会详细介绍。</li></ol> 
<h4><a id="324__330"></a>3.2.4 过滤操作符</h4> 
<ol><li><code>filter</code>：筛选符合条件的值，返回true继续往下执行。</li></ol> 
<pre><code class="prism language-kotlin">    flow <span class="token punctuation">{<!-- --></span>
        <span class="token comment">//发送数据</span>
        <span class="token function">repeat</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span>
            <span class="token function">emit</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">filter</span> <span class="token punctuation">{<!-- --></span>
        it <span class="token operator">&lt;</span> <span class="token number">2</span>
    <span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">collect</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">//接收数据流</span>
        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"yvan collect: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">it</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//输出：</span>
    <span class="token comment">//yvan collect: 0</span>
	<span class="token comment">//yvan collect: 1</span>
</code></pre> 
<ol start="2"><li><code>filterNot</code>：与filter相反，筛选不符合条件的值，返回false继续往下执行。</li><li><code>filterNotNull</code>：筛选不为空的值。</li></ol> 
<pre><code class="prism language-kotlin">    flow <span class="token punctuation">{<!-- --></span>
        <span class="token comment">//发送数据</span>
        <span class="token function">emit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
        <span class="token function">emit</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span>
        <span class="token function">emit</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">filterNotNull</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">//接收数据流</span>
        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"yvan collect: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">it</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 输出：</span>
    <span class="token comment">//yvan collect: 1</span>
	<span class="token comment">//yvan collect: 2</span>
</code></pre> 
<ol start="4"><li><code>filterInstance</code>：筛选对应类型的值，如.filterIsInstance()用来过滤String类型的值</li></ol> 
<pre><code class="prism language-kotlin">    flow <span class="token punctuation">{<!-- --></span>
        <span class="token comment">//发送数据</span>
        <span class="token function">emit</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"1"</span></span><span class="token punctuation">)</span>
        <span class="token function">emit</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span>
        <span class="token function">emit</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">.</span>filterIsInstance<span class="token operator">&lt;</span>String<span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
     <span class="token punctuation">.</span><span class="token function">collect</span> <span class="token punctuation">{<!-- --></span>
		<span class="token comment">//接收数据流</span>
		<span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"yvan collect: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">it</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>
     <span class="token punctuation">}</span>
     <span class="token comment">// 输出:</span>
     <span class="token comment">// yvan collect: 1</span>

</code></pre> 
<ol start="5"><li><code>drop</code>：drop(count: Int)参数为Int类型，意为丢弃掉前count个值。</li></ol> 
<pre><code class="prism language-kotlin">    flow <span class="token punctuation">{<!-- --></span>
        <span class="token comment">//发送数据</span>
        <span class="token function">emit</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"1"</span></span><span class="token punctuation">)</span>
        <span class="token function">emit</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span>
        <span class="token function">emit</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">drop</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">collect</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">//接收数据流</span>
            <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"yvan collect: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">it</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token comment">// 输出：</span>
    <span class="token comment">// yvan collect: null</span>
	<span class="token comment">// yvan collect: 2</span>
    
</code></pre> 
<ol start="6"><li><code>dropWhile</code>：找到第一个不满足条件的值，返回其和其后所有的值。</li></ol> 
<pre><code class="prism language-kotlin">    flow <span class="token punctuation">{<!-- --></span>
        <span class="token comment">//发送数据</span>
        <span class="token function">emit</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"1"</span></span><span class="token punctuation">)</span>
        <span class="token function">emit</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span>
        <span class="token function">emit</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">dropWhile</span> <span class="token punctuation">{<!-- --></span> it <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token punctuation">}</span>
        <span class="token punctuation">.</span><span class="token function">collect</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">//接收数据流</span>
            <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"yvan collect: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">it</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token comment">// 输出：</span>
    <span class="token comment">// yvan collect: null</span>
	<span class="token comment">// yvan collect: 2</span>
</code></pre> 
<ol start="7"><li><code>take</code>：与drop()相反，意为取前n个值。</li><li><code>takeWhile</code>：与dropWhile()相反，找到第一个不满足条件的值，返回其前面所有的值。</li><li><code>debounce</code>：debounce(timeoutMillis: Long)指定时间内只接收最新的值，其他的过滤掉。防抖动，指定数据接收的间隔时间。</li></ol> 
<pre><code class="prism language-kotlin">    flow <span class="token punctuation">{<!-- --></span>
        <span class="token comment">//发送数据</span>
        <span class="token function">emit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
        <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">900</span><span class="token punctuation">)</span>
        <span class="token function">emit</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>
        <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">800</span><span class="token punctuation">)</span>
        <span class="token function">emit</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>
        <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span>
        <span class="token function">emit</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span>
        <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">700</span><span class="token punctuation">)</span>
        <span class="token function">emit</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">debounce</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">collect</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">//接收数据流</span>
            <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"yvan collect: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">it</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>


	<span class="token comment">// 由于1、2、4的时间间隔小于1000所以被过滤，3时间1000，5是最后一个，所以输出是3和5</span>
	<span class="token comment">//输出：</span>
	<span class="token comment">// yvan collect: 3</span>
	<span class="token comment">// yvan collect: 5</span>
	
</code></pre> 
<ol start="11"><li><code>sample</code>：sample(periodMillis: Long)在指定周期内，获取最新发出的值，定时周期接收。如：</li></ol> 
<pre><code class="prism language-kotlin">    flow <span class="token punctuation">{<!-- --></span>
        <span class="token comment">//发送数据</span>
        <span class="token function">emit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
        <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span>
        <span class="token function">emit</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>
        <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span>
        <span class="token function">emit</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>
        <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">)</span>
        <span class="token function">emit</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span>
        <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span>
        <span class="token function">emit</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">sample</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">collect</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">//接收数据流</span>
            <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"yvan collect: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">it</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>

	<span class="token comment">// 输出：</span>
	<span class="token comment">// yvan collect: 3</span>
	<span class="token comment">// yvan collect: 4</span>
</code></pre> 
<ol start="12"><li><code>distinctUntilChangedBy</code>：判断两个连续值是否重复，可以设置是否丢弃重复值。</li></ol> 
<pre><code class="prism language-kotlin">    <span class="token function">flowOf</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">distinctUntilChanged</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span> <span class="token punctuation">{<!-- --></span>
        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"yvan distinctUntilChangedBy = </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">it</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//输出：</span>
    <span class="token comment">//yvan distinctUntilChangedBy = 1</span>
	<span class="token comment">//yvan distinctUntilChangedBy = 2</span>
</code></pre> 
<ol start="13"><li><code>distinctUntilChanged</code>：若连续两个值相同，则跳过后面的值。</li></ol> 
<pre><code class="prism language-kotlin">    <span class="token function">flowOf</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">distinctUntilChanged</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span> <span class="token punctuation">{<!-- --></span>
        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"yvan distinctUntilChanged = </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">it</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//输出：</span>
	<span class="token comment">//yvan distinctUntilChanged = 1</span>
	<span class="token comment">//yvan distinctUntilChanged = 2</span>
	<span class="token comment">//yvan distinctUntilChanged = 1</span>
	<span class="token comment">//yvan distinctUntilChanged = 2</span>
</code></pre> 
<h4><a id="325__504"></a>3.2.5 组合操作符</h4> 
<ol><li><code>combine</code>：组合两个Flow流最新发出的数据，直到两个流都结束为止。扩展：在kotlinx-coroutines-core-jvm中的FlowKt中，可以将更多的flow结合起来返回一个Flow，典型应用场景：多个筛选条件选中后，展示符合条件的数据。如果后续某个筛选条件发生了改变，只需要通过发生改变的Flow的flow.value = newValue重新发送，combine就会自动构建出新的Flow，这样UI层会接收到新的变化条件进行刷新即可。</li></ol> 
<pre><code class="prism language-kotlin">  <span class="token keyword">val</span> flow1 <span class="token operator">=</span> flow <span class="token punctuation">{<!-- --></span>
        <span class="token function">emit</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"A"</span></span><span class="token punctuation">)</span>
        <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span>
        <span class="token function">emit</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"B"</span></span><span class="token punctuation">)</span>

    <span class="token punctuation">}</span>
    <span class="token keyword">val</span> flow2 <span class="token operator">=</span> flow <span class="token punctuation">{<!-- --></span>
        <span class="token function">emit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
        <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span>
        <span class="token function">emit</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    flow1<span class="token punctuation">.</span><span class="token function">combine</span><span class="token punctuation">(</span>flow2<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span> it1<span class="token punctuation">,</span>it2<span class="token operator">-&gt;</span>
        <span class="token keyword">return</span><span class="token label symbol">@combine</span> it1 <span class="token keyword">to</span> it2
    <span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">{<!-- --></span>
        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"yvan </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">it</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//输出：</span>
    <span class="token comment">//yvan (A, 1)</span>
	<span class="token comment">//yvan (A, 2)</span>
	<span class="token comment">//yvan (B, 2)</span>

</code></pre> 
<ol start="2"><li><code>combineTransform</code>： combine + transform操作</li><li><code>merge</code>：listOf(flow1, flow2).merge()，多个流合并为一个流。zip是提供高级函数组合流的数据，而merage则是之间将两个流在一个collect里输出</li></ol> 
<pre><code class="prism language-kotlin">    <span class="token keyword">val</span> flow1 <span class="token operator">=</span> <span class="token function">flowOf</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"A"</span></span><span class="token punctuation">,</span> <span class="token string-literal singleline"><span class="token string">"B"</span></span><span class="token punctuation">,</span> <span class="token string-literal singleline"><span class="token string">"C"</span></span><span class="token punctuation">)</span>
    <span class="token keyword">val</span> flow2 <span class="token operator">=</span> <span class="token function">flowOf</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span>
    <span class="token function">merge</span><span class="token punctuation">(</span>flow1<span class="token punctuation">,</span> flow2<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span> <span class="token punctuation">{<!-- --></span>
        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"yvan </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">it</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//输出：</span>
    <span class="token comment">//yvan A</span>
	<span class="token comment">//yvan B</span>
	<span class="token comment">//yvan C</span>
	<span class="token comment">//yvan 1</span>
	<span class="token comment">//yvan 2</span>
	<span class="token comment">//yvan 3</span>
	<span class="token comment">//yvan 4</span>
</code></pre> 
<ol start="4"><li><code>flattenConcat</code>：以顺序方式将给定的流展开为单个流 。示例如下：</li></ol> 
<pre><code class="prism language-kotlin">    flow <span class="token punctuation">{<!-- --></span>
        <span class="token function">emit</span><span class="token punctuation">(</span><span class="token function">flowOf</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token function">emit</span><span class="token punctuation">(</span><span class="token function">flowOf</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span> <span class="token punctuation">.</span><span class="token function">flattenConcat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span> <span class="token punctuation">{<!-- --></span>
        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"yvan </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">it</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//输出：</span>
	<span class="token comment">//yvan 1</span>
	<span class="token comment">//yvan 2</span>
	<span class="token comment">//yvan 3</span>
	<span class="token comment">//yvan 4</span>
</code></pre> 
<ol start="5"><li><code>flattenMerge</code>：作用和 flattenConcat 一样，将多个flow流按并发后输出，但是可以设置并发收集流的数量。</li></ol> 
<pre><code class="prism language-kotlin">    flow<span class="token punctuation">{<!-- --></span>
        <span class="token function">emit</span><span class="token punctuation">(</span><span class="token function">flowOf</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token function">emit</span><span class="token punctuation">(</span><span class="token function">flowOf</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"A"</span></span><span class="token punctuation">,</span><span class="token string-literal singleline"><span class="token string">"B"</span></span><span class="token punctuation">,</span><span class="token string-literal singleline"><span class="token string">"C"</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">flattenMerge</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">{<!-- --></span>
        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"yvan </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">it</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//输出：</span>
	<span class="token comment">//yvan 1</span>
	<span class="token comment">//yvan A</span>
	<span class="token comment">//yvan B</span>
	<span class="token comment">//yvan C</span>
	<span class="token comment">//yvan 2</span>
	<span class="token comment">//yvan 3</span>
</code></pre> 
<ol start="6"><li><code>flatMapContact</code>：相当于 map + flattenConcat , 通过 map 转成一个流，在通过 flattenConcat发送。</li><li><code>flatMapLatest</code>：当有新值发送时，会取消掉之前还未转换完成的值。</li><li><code>flatMapMerge</code>：相当于map + flattenMerge ，参数concurrency: Int 来限制并发数。</li><li><code>zip</code>：组合两个Flow流最新发出的数据，上游流在同一协程中顺序收集，没有任何缓冲。不同于combine的是，当其中一个流结束时，另外的Flow也会调用cancel，生成的流完成。</li></ol> 
<pre><code class="prism language-kotlin">    <span class="token keyword">val</span> flow <span class="token operator">=</span> <span class="token function">flowOf</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">onEach</span> <span class="token punctuation">{<!-- --></span> <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span> <span class="token punctuation">}</span>
    <span class="token keyword">val</span> flow2 <span class="token operator">=</span> <span class="token function">flowOf</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"a"</span></span><span class="token punctuation">,</span> <span class="token string-literal singleline"><span class="token string">"b"</span></span><span class="token punctuation">,</span> <span class="token string-literal singleline"><span class="token string">"c"</span></span><span class="token punctuation">,</span> <span class="token string-literal singleline"><span class="token string">"d"</span></span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">onEach</span> <span class="token punctuation">{<!-- --></span> <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">150</span><span class="token punctuation">)</span> <span class="token punctuation">}</span>
    <span class="token keyword">val</span> startTime <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 记录开始的时间</span>
    flow<span class="token punctuation">.</span><span class="token function">zip</span><span class="token punctuation">(</span>flow2<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> i<span class="token punctuation">,</span> s <span class="token operator">-&gt;</span> i<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> s <span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">collect</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// Will print "1a 2b 3c"</span>
        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"yvan </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">it</span></span><span class="token string"> 耗时 </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${<!-- --></span><span class="token expression">System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> startTime</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> ms"</span></span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
	<span class="token comment">//输出(flow已经执行完，所以flow2中的d被cancel了)：</span>
	<span class="token comment">//yvan 1a 耗时 156 ms</span>
	<span class="token comment">//yvan 2b 耗时 307 ms</span>
	<span class="token comment">//yvan 3c 耗时 459 ms</span>

	<span class="token comment">//如果换做combine，执行结果如下(组合的是最新发出的数据)：</span>
	<span class="token comment">//yvan 2a 耗时 156 ms</span>
	<span class="token comment">//yvan 3a 耗时 159 ms</span>
	<span class="token comment">//yvan 3b 耗时 311 ms</span>
	<span class="token comment">//yvan 3c 耗时 466 ms</span>
	<span class="token comment">//yvan 3d 耗时 620 ms</span>
	<span class="token comment">//注：上面combine多次执行的结果可能不一致，但每次组合的是最新发出的数据</span>
</code></pre> 
<h4><a id="326__608"></a>3.2.6 功能性操作符</h4> 
<ol><li><code>cancellable</code>：判断当前协程是否被取消 ，如果已取消，则抛出异常</li><li><code>catch</code>：对此操作符之前的流发生的异常进行捕获，对此操作符之后的流无影响。当发生异常时，默认collect{}中lambda将不会再执行。当然，可以自行通过emit()继续发送。</li><li><code>retry</code>：流发生异常时的重试机制。如果是无限重试，直接调用retry()默认方法即可，retry()最终调用的也是retryWhen()方法。</li></ol> 
<pre><code class="prism language-kotlin"><span class="token keyword">public</span> <span class="token keyword">fun</span> <span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> Flow<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token punctuation">.</span><span class="token function">retry</span><span class="token punctuation">(</span>
    retries<span class="token operator">:</span> Int <span class="token operator">=</span> Int<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">,</span> <span class="token comment">//指定重试次数</span>
    predicate<span class="token operator">:</span> <span class="token punctuation">(</span>Throwable<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> Boolean <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span> <span class="token boolean">true</span> <span class="token punctuation">}</span> <span class="token comment">//返回true且满足retries次数要求，继续重试；false停止重试</span>
<span class="token punctuation">)</span><span class="token operator">:</span> Flow<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">require</span><span class="token punctuation">(</span>retries <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token string-literal singleline"><span class="token string">"Expected positive amount of retries, but had </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">retries</span></span><span class="token string">"</span></span> <span class="token punctuation">}</span>
    <span class="token keyword">return</span> retryWhen <span class="token punctuation">{<!-- --></span> cause<span class="token punctuation">,</span> attempt <span class="token operator">-&gt;</span> <span class="token function">predicate</span><span class="token punctuation">(</span>cause<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> attempt <span class="token operator">&lt;</span> retries <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<ol start="4"><li><code>retryWhen</code>：流发生异常时的重试机制。</li></ol> 
<pre><code class="prism language-kotlin"><span class="token keyword">public</span> <span class="token keyword">fun</span> <span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> Flow<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token punctuation">.</span><span class="token function">retryWhen</span><span class="token punctuation">(</span>predicate<span class="token operator">:</span> <span class="token keyword">suspend</span> FlowCollector<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token punctuation">.</span><span class="token punctuation">(</span>cause<span class="token operator">:</span> Throwable<span class="token punctuation">,</span> attempt<span class="token operator">:</span> Long<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> Boolean<span class="token punctuation">)</span><span class="token operator">:</span> Flow<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span> <span class="token operator">..</span><span class="token operator">..</span><span class="token operator">..</span> <span class="token punctuation">}</span>
</code></pre> 
<p>有条件的进行重试 ，lambda 中有两个参数: cause是 异常原因，attempt是当前重试的位置，lambda返回true时继续重试; 反之停止重试。</p> 
<ol start="5"><li><code>buffer</code>：流执行总时间就是所有运算符执行时间之和。如果上下游运算符都比较耗时，可以考虑使用buffer()优化，该运算符会在执行期间为流创建一个单独的协程。</li></ol> 
<pre><code class="prism language-kotlin"><span class="token keyword">public</span> <span class="token keyword">fun</span> <span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> Flow<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token punctuation">.</span><span class="token function">buffer</span><span class="token punctuation">(</span>capacity<span class="token operator">:</span> Int <span class="token operator">=</span> BUFFERED<span class="token punctuation">,</span> onBufferOverflow<span class="token operator">:</span> BufferOverflow <span class="token operator">=</span> BufferOverflow<span class="token punctuation">.</span>SUSPEND<span class="token punctuation">)</span><span class="token operator">:</span> Flow<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token punctuation">{<!-- --></span><span class="token operator">..</span><span class="token operator">..</span><span class="token operator">..</span><span class="token punctuation">}</span>
</code></pre> 
<pre><code class="prism language-kotlin">    <span class="token function">flowOf</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"A"</span></span><span class="token punctuation">,</span> <span class="token string-literal singleline"><span class="token string">"B"</span></span><span class="token punctuation">,</span> <span class="token string-literal singleline"><span class="token string">"C"</span></span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">onEach</span>  <span class="token punctuation">{<!-- --></span> <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"yvan 1</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">it</span></span><span class="token string">"</span></span><span class="token punctuation">)</span> <span class="token punctuation">}</span>
        <span class="token punctuation">.</span><span class="token function">buffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment">// &lt;--------------- buffer between onEach and collect</span>
        <span class="token punctuation">.</span><span class="token function">collect</span> <span class="token punctuation">{<!-- --></span> <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"yvan 2</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">it</span></span><span class="token string">"</span></span><span class="token punctuation">)</span> <span class="token punctuation">}</span>

	<span class="token comment">// 输出：</span>
	<span class="token comment">// yvan 1A</span>
	<span class="token comment">// yvan 1B</span>
	<span class="token comment">// yvan 1C</span>
	<span class="token comment">// yvan 2A</span>
	<span class="token comment">// yvan 2B</span>
	<span class="token comment">// yvan 2C</span>
</code></pre> 
<p>上述代码将在两个协程中执行，其中buffer()以上还是在协程P中执行，而buffer()下面的collect()会在协程Q中执行，数据通过Channel进行传递，从而减少了执行的总时间。</p> 
<ol start="6"><li><code>conflate</code>：仅保留最新值, 内部实现是 buffer(CONFLATED)</li></ol> 
<pre><code class="prism language-kotlin">    <span class="token function">flowOf</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"A"</span></span><span class="token punctuation">,</span> <span class="token string-literal singleline"><span class="token string">"B"</span></span><span class="token punctuation">,</span> <span class="token string-literal singleline"><span class="token string">"C"</span></span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">onEach</span>  <span class="token punctuation">{<!-- --></span> <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"yvan 1</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">it</span></span><span class="token string">"</span></span><span class="token punctuation">)</span> <span class="token punctuation">}</span>
        <span class="token punctuation">.</span><span class="token function">conflate</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment">// &lt;--------------- buffer between onEach and collect</span>
        <span class="token punctuation">.</span><span class="token function">collect</span> <span class="token punctuation">{<!-- --></span> <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"yvan 2</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">it</span></span><span class="token string">"</span></span><span class="token punctuation">)</span> <span class="token punctuation">}</span>
        	<span class="token comment">// 输出：</span>
	<span class="token comment">// yvan 1A</span>
	<span class="token comment">// yvan 1B</span>
	<span class="token comment">// yvan 1C</span>
	<span class="token comment">// yvan 2C</span>
</code></pre> 
<ol start="7"><li><code>flowOn</code>：flowOn 会更改上游数据流的 CoroutineContext，且只会影响flowOn之前（或之上）的任何中间运算符。下游数据流（晚于 flowOn 的中间运算符和使用方）不会受到影响。如果有多个 flowOn 运算符，每个运算符都会更改当前位置的上游数据流。</li></ol> 
<pre><code class="prism language-kotlin">  flow <span class="token punctuation">{<!-- --></span>
        <span class="token comment">//这里的线程应该是跟随创建线程</span>
        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"yvan 1 thread:</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${<!-- --></span><span class="token expression">Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>name</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>
        <span class="token function">emit</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"flowOnTest"</span></span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
        <span class="token punctuation">.</span><span class="token function">flowOn</span><span class="token punctuation">(</span>Dispatchers<span class="token punctuation">.</span>IO<span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">map</span> <span class="token punctuation">{<!-- --></span>
            <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"yvan 2 thread:</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${<!-- --></span><span class="token expression">Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>name</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>
            <span class="token keyword">return</span><span class="token label symbol">@map</span> it
        <span class="token punctuation">}</span>
        <span class="token punctuation">.</span><span class="token function">flowOn</span><span class="token punctuation">(</span>Dispatchers<span class="token punctuation">.</span>Default<span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">collect</span> <span class="token punctuation">{<!-- --></span>
            <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"yvan 3 thread:</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${<!-- --></span><span class="token expression">Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>name</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">  结果:</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">it</span></span><span class="token string"> "</span></span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>

	<span class="token comment">//输出：</span>
	<span class="token comment">//yvan 1 thread:DefaultDispatcher-worker-2</span>
	<span class="token comment">//yvan 2 thread:DefaultDispatcher-worker-1</span>
	<span class="token comment">//yvan 3 thread:DefaultDispatcher-worker-1  结果:flowOnTest </span>
</code></pre> 
<h4><a id="327__690"></a>3.2.7 末端操作符</h4> 
<ol><li><code>collect</code>：数据收集操作符，<code>默认的flow是冷流</code>，即当执行collect时，上游才会被触发执行。</li><li><code>collectIndexed</code>：带下标的收集操作，如collectIndexed{ index, value -&gt; }。</li><li><code>collectLatest</code>：与collect的区别：当新值从上游发出时，如果上个收集还未完成，会取消上个值得收集操作。</li><li><code>toCollection、toList、toSet</code>：将flow{}结果转化为集合。</li></ol> 
<p>注：还有很多操作符没有列出来~</p> 
<h3><a id="33__698"></a>3.3 发射流</h3> 
<p>发射流即上面3.2.7的末端操作符<code>collect</code></p> 
<h2><a id="4__701"></a>4 热流</h2> 
<h3><a id="41_SharedFlow_702"></a>4.1 SharedFlow</h3> 
<p>我们知道<code>flow{}</code>构建的是<code>冷流</code>，而<code>SharedFlow(共享Flow)</code>默认是<code>热流</code>，发送器与收集器是一对多的关系。</p> 
<pre><code class="prism language-kotlin"><span class="token keyword">public</span> <span class="token keyword">fun</span> <span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token function">MutableSharedFlow</span><span class="token punctuation">(</span>
	<span class="token comment">// replay：重播给新订阅者时缓存数据的个数，默认是0。</span>
	<span class="token comment">// 当新订阅者collect时，会先尝试获取上游replay个数据，为0时则不会获取之前的数据。</span>
	<span class="token comment">// replay缓存是针对后续所有的订阅者准备的。</span>
    replay<span class="token operator">:</span> Int <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>
    <span class="token comment">// extraBufferCapacity：除了replay外，缓冲值的数量。</span>
    <span class="token comment">// 当有剩余的缓冲区空间时，Emit不挂起(可选，不能为负，默认为零) 。</span>
    <span class="token comment">// extraBufferCapacity是为上游快速发射器及下游慢速收集器这种场景提供缓冲的，</span>
    <span class="token comment">// 有点类似于线程池中的存储队列。</span>
    <span class="token comment">// 要注意，replay保存的是最新值，而extraBufferCapacity保存的是最先发送的一个或多个值。</span>
    extraBufferCapacity<span class="token operator">:</span> Int <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>
    <span class="token comment">// 配置缓冲区溢出的操作（可选，默认为SUSPEND，暂停尝试发出值），</span>
    <span class="token comment">// 可选值有：SUSPEND-暂停发送、DROP_OLDEST-丢弃队列中最老的、DROP_LATEST-丢弃队列中最新的。</span>
    onBufferOverflow<span class="token operator">:</span> BufferOverflow <span class="token operator">=</span> BufferOverflow<span class="token punctuation">.</span>SUSPEND
<span class="token punctuation">)</span><span class="token operator">:</span> MutableSharedFlow<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span>
</code></pre> 
<p>上面操作符中提到shareIn，其作用是将普通<code>flow</code>转化为<code>SharedFlow</code></p> 
<pre><code class="prism language-kotlin"><span class="token keyword">public</span> <span class="token keyword">fun</span> <span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> Flow<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token punctuation">.</span><span class="token function">shareIn</span><span class="token punctuation">(</span>
	<span class="token comment">// 协程作用域范围</span>
    scope<span class="token operator">:</span> CoroutineScope<span class="token punctuation">,</span>
    <span class="token comment">// 控制共享的开始、结束策略。一共有三种，</span>
    <span class="token comment">// Eagerly：马上开始，在scope作用域结束时终止</span>
    <span class="token comment">// Lazily：当订阅者出现时开始，在scope作用域结束时终止</span>
    <span class="token comment">// WhileSubscribed(stopTimeoutMillis: Long = 0,replayExpirationMillis: Long = Long.MAX_VALUE)：</span>
    <span class="token comment">// 其中stopTimeoutMillis：表示最后一个订阅者结束订阅与停止上游流的时间差，默认值为0（立即停止上游流），replayExpirationMillis：数据重播的超时时间。</span>
    started<span class="token operator">:</span> SharingStarted<span class="token punctuation">,</span>
    <span class="token comment">// 重播给新订阅者的数量</span>
    replay<span class="token operator">:</span> Int <span class="token operator">=</span> <span class="token number">0</span>
<span class="token punctuation">)</span><span class="token operator">:</span> SharedFlow<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> 
</code></pre> 
<p>举例：</p> 
<pre><code class="prism language-kotlin"> <span class="token comment">//ViewModel中 普通flow通过shareIn转化为SharedFlow</span>
 <span class="token keyword">val</span> flowConvertSharedFlow <span class="token keyword">by</span> lazy <span class="token punctuation">{<!-- --></span>
        flow <span class="token punctuation">{<!-- --></span>
            <span class="token function">emit</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"1、flow"</span></span><span class="token punctuation">)</span>
            <span class="token function">emit</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"2、convert"</span></span><span class="token punctuation">)</span>
            <span class="token function">emit</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"3、SharedFlow"</span></span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">shareIn</span><span class="token punctuation">(</span>
        	<span class="token comment">//协程作用域范围</span>
            viewModelScope<span class="token punctuation">,</span> 
            <span class="token comment">//立即开始</span>
            SharingStarted<span class="token punctuation">.</span>Eagerly<span class="token punctuation">,</span> 
            <span class="token comment">//重播给新订阅者的数量</span>
            replay <span class="token operator">=</span> <span class="token number">3</span> 
        <span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">onStart</span> <span class="token punctuation">{<!-- --></span> <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"yvan onStart"</span></span><span class="token punctuation">)</span> <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

 <span class="token comment">//Activity中</span>
 mBtnConvertF<span class="token punctuation">.</span><span class="token function">setOnClickListener</span> <span class="token punctuation">{<!-- --></span>
      <span class="token keyword">val</span> builder<span class="token operator">:</span> StringBuilder <span class="token operator">=</span> <span class="token function">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
      lifecycleScope<span class="token punctuation">.</span><span class="token function">launch</span> <span class="token punctuation">{<!-- --></span>
          mFlowModel<span class="token punctuation">.</span>flowConvertSharedFlow<span class="token punctuation">.</span><span class="token function">collect</span> <span class="token punctuation">{<!-- --></span>
              <span class="token function">println</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span>
              builder<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"\n"</span></span><span class="token punctuation">)</span>
              mTvConvertF<span class="token punctuation">.</span>text <span class="token operator">=</span> builder<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
          <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  	<span class="token comment">//输出：</span>
	<span class="token comment">//yvan onStart</span>
	<span class="token comment">//1、flow</span>
	<span class="token comment">//2、convert</span>
	<span class="token comment">//3、SharedFlow</span>
</code></pre> 
<h3><a id="42_StateFlow_774"></a>4.2 StateFlow</h3> 
<p><code>StateFlow</code>可以认为是一个r<code>eplay为1</code>，且<code>没有缓冲区</code>的<code>SharedFlow</code>，所以新订阅者<code>collect</code>时会先获取一个<code>默认值</code>，构造函数如下：</p> 
<pre><code class="prism language-kotlin"><span class="token comment">//MutableStateFlow构造函数</span>
<span class="token keyword">public</span> <span class="token keyword">fun</span> <span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token function">MutableStateFlow</span><span class="token punctuation">(</span>value<span class="token operator">:</span> T<span class="token punctuation">)</span><span class="token operator">:</span> MutableStateFlow<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token function">StateFlowImpl</span><span class="token punctuation">(</span>value <span class="token operator">?:</span> NULL<span class="token punctuation">)</span>

<span class="token comment">//MutableStateFlow接口继承了MutableSharedFlow接口</span>
<span class="token keyword">public</span> <span class="token keyword">interface</span> MutableStateFlow<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token operator">:</span> StateFlow<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token punctuation">,</span> MutableSharedFlow<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token punctuation">{<!-- --></span>
   <span class="token keyword">public</span> <span class="token keyword">override</span> <span class="token keyword">var</span> value<span class="token operator">:</span> T

   <span class="token keyword">public</span> <span class="token keyword">fun</span> <span class="token function">compareAndSet</span><span class="token punctuation">(</span><span class="token keyword">expect</span><span class="token operator">:</span> T<span class="token punctuation">,</span> update<span class="token operator">:</span> T<span class="token punctuation">)</span><span class="token operator">:</span> Boolean
<span class="token punctuation">}</span>
</code></pre> 
<p><code>StateFlow</code>有自动去重的功能，即如果上游连续发送的<code>value</code>重复时，下游的接收方只会接收第一次的值，后续的重复值不会再接收，可以通过<code>StateFlow.value</code>获取发送的值。</p> 
<p>上面操作符中提到的<code>stateIn</code>作用是将普通<code>flow</code>转化为<code>StateFlow</code></p> 
<pre><code class="prism language-kotlin"><span class="token keyword">public</span> <span class="token keyword">fun</span> <span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> Flow<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token punctuation">.</span><span class="token function">stateIn</span><span class="token punctuation">(</span>
	<span class="token comment">// 协程作用域范围</span>
    scope<span class="token operator">:</span> CoroutineScope<span class="token punctuation">,</span>
    <span class="token comment">// 控制共享的开始、结束策略。一共有三种，</span>
    <span class="token comment">// Eagerly：马上开始，在scope作用域结束时终止</span>
    <span class="token comment">// Lazily：当订阅者出现时开始，在scope作用域结束时终止</span>
    <span class="token comment">// WhileSubscribed(stopTimeoutMillis: Long = 0,replayExpirationMillis: Long = Long.MAX_VALUE)：</span>
    <span class="token comment">// 其中stopTimeoutMillis：表示最后一个订阅者结束订阅与停止上游流的时间差，默认值为0（立即停止上游流），replayExpirationMillis：数据重播的超时时间。</span>
    started<span class="token operator">:</span> SharingStarted<span class="token punctuation">,</span>
    <span class="token comment">// 默认StateFlow的初始值，会发送到下游</span>
    initialValue<span class="token operator">:</span> T
<span class="token punctuation">)</span><span class="token operator">:</span> StateFlow<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">//这里设置的replay是1 及重播给新订阅者的缓存为1</span>
    <span class="token keyword">val</span> config <span class="token operator">=</span> <span class="token function">configureSharing</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token operator">..</span><span class="token operator">..</span><span class="token operator">..</span>
    <span class="token punctuation">}</span>
</code></pre> 
<p>使用举例：</p> 
<pre><code class="prism language-kotlin"> <span class="token comment">//ViewModel中</span>
 <span class="token keyword">val</span> flowConvertStateFlow <span class="token keyword">by</span> lazy <span class="token punctuation">{<!-- --></span>
        flow <span class="token punctuation">{<!-- --></span>
            <span class="token comment">//转化为StateFlow是 emit()可以是0个或1个 或多个，</span>
            <span class="token comment">// 当是多个时，新订阅者collect只会收到最后一个值(replay为1)</span>
            <span class="token function">emit</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"1、flow convert StateFlow"</span></span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
            <span class="token punctuation">.</span><span class="token function">stateIn</span><span class="token punctuation">(</span>
            	<span class="token comment">//协程作用域范围</span>
                viewModelScope<span class="token punctuation">,</span> 
                <span class="token comment">//立即开始</span>
                SharingStarted<span class="token punctuation">.</span>Eagerly<span class="token punctuation">,</span> 
                <span class="token comment">// 默认StateFlow的初始值，会发送到下游</span>
                <span class="token string-literal singleline"><span class="token string">"0、initialValue"</span></span> 
            <span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">onStart</span> <span class="token punctuation">{<!-- --></span> <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"yvan onStart"</span></span><span class="token punctuation">)</span> <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

 <span class="token comment">//Activity中</span>
 mBtnConvertSF<span class="token punctuation">.</span><span class="token function">setOnClickListener</span> <span class="token punctuation">{<!-- --></span>
      lifecycleScope<span class="token punctuation">.</span><span class="token function">launch</span> <span class="token punctuation">{<!-- --></span>
          <span class="token keyword">val</span> builder <span class="token operator">=</span> <span class="token function">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
          mFlowModel<span class="token punctuation">.</span>flowConvertStateFlow<span class="token punctuation">.</span><span class="token function">collect</span> <span class="token punctuation">{<!-- --></span>
              <span class="token function">println</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span>
              builder<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"\n"</span></span><span class="token punctuation">)</span>
              mTvConvertSF<span class="token punctuation">.</span>text <span class="token operator">=</span> builder<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
          <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
	<span class="token comment">//输出：</span>
	<span class="token comment">//yvan onStart</span>
	<span class="token comment">//0、initialValue</span>
	<span class="token comment">//1、flow convert StateFlow</span>
</code></pre> 
<p>注：在UI层使用<code>Lifecycle.repeatOnLifecycle</code> 配合上游的<code>SharingStarted.WhileSubscribed</code>一块使用是一种更安全、性能更好的流收集方式。</p> 
<h3><a id="43_StateFlowLiveData_849"></a>4.3 StateFlow和LiveData的异同点</h3> 
<p>我们知道通过<code>LiveData</code>可以让数据被观察，且具备生命周期感知能力，但<code>LiveData</code>的缺点也很明显：</p> 
<ol><li><code>LiveData</code>的接收只能在主线程；</li><li><code>LiveData</code>发送数据是一次性买卖，不能多次发送；</li><li><code>LiveData</code>发送数据的线程是固定的，不能切换线程，<code>setValue/postValue</code>本质上都是在主线程上发送的。当需要来回切换线程时，<code>LiveData</code>就显得无能为力了。</li></ol> 
<p><code>StateFlow</code> 和 <code>LiveData</code> 具有相似之处。两者都是可观察的数据容器类，并且在应用架构中使用时，两者都遵循相似模式。但两者还是有不同之处的：</p> 
<ol><li><code>StateFlow</code> 需要将<code>初始状态</code>传递给构造函数，而 <code>LiveData</code> 不需要。</li><li>当 <code>View</code> 进入 <code>STOPPED</code> 状态时，<code>LiveData.observe()</code> 会自动取消注册使用方，而从 <code>StateFlow</code> 或任何其他数据流收集数据的操作并不会自动停止。如需实现相同的行为，需要从 <code>Lifecycle.repeatOnLifecycle</code> 块收集数据流。</li></ol> 
<h3><a id="44_StateFlowSharedFlow__Channel_860"></a>4.4 StateFlow、SharedFlow 和 Channel对比</h3> 
<p><code>Flow</code>底层使用的<code>Channel机制</code>实现，<code>StateFlow</code>、<code>SharedFlow</code>都是<code>一对多</code>的关系，如果上游发送者与下游UI层的订阅者是一对一的关系，可以使用<code>Channel</code>来实现，<code>Channel</code>默认是<code>粘性的</code>。</p> 
<p>Channel使用场景：一次性消费场景，比如弹窗，需求是在UI层只弹一次，即使App切到后台再切回来，也不会重复订阅(不会多次弹窗)；</p> 
<p>如果使用<code>SharedFlow/StateFlow</code>，UI层使用的<code>lifecycle.repeatOnLifecycle</code>、<code>Flow.flowWithLifecycle</code>，则在App切换前后台时，UI层会重复订阅，弹窗事件可能会多次执行，不符合要求。</p> 
<p>Channel使用特点：</p> 
<ol><li>每个消息只有一个订阅者可以收到，用于一对一的通信</li><li>第一个订阅者可以收到<code>collect</code>之前的事件，即粘性事件</li></ol> 
<p>Channel使用举例：</p> 
<pre><code class="prism language-kotlin"><span class="token comment">//viewModel中</span>
<span class="token keyword">private</span> <span class="token keyword">val</span> _loadingChannel <span class="token operator">=</span> Channel<span class="token operator">&lt;</span>Boolean<span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">val</span> loadingFlow <span class="token operator">=</span> _loadingChannel<span class="token punctuation">.</span><span class="token function">receiveAsFlow</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token keyword">private</span> <span class="token keyword">suspend</span> <span class="token keyword">fun</span> <span class="token function">loadStart</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    _loadingChannel<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">private</span> <span class="token keyword">suspend</span> <span class="token keyword">fun</span> <span class="token function">loadFinish</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    _loadingChannel<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">//UI层接收Loading信息</span>
 mViewModel<span class="token punctuation">.</span>loadingFlow<span class="token punctuation">.</span><span class="token function">flowWithLifecycle2</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> Lifecycle<span class="token punctuation">.</span>State<span class="token punctuation">.</span>STARTED<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> isShow <span class="token operator">-&gt;</span>
     mStatusViewUtil<span class="token punctuation">.</span><span class="token function">showLoadingView</span><span class="token punctuation">(</span>isShow<span class="token punctuation">)</span>
 <span class="token punctuation">}</span>
</code></pre> 
<h2><a id="5__891"></a>5 扩展</h2> 
<p>在新项目或者新需求中，我们可以直接使用协程来替代之前的多线程场景的使用方式，如可以通过<code>withContext(Dispatchers.IO)</code>在协程中来回切换线程且能在线程执行完毕后自动切回当前线程，避免使用接口回调的方式导致逻辑可读性变差。然而，如果我们是在现有项目中开发或者网络框架就是回调方式使用时，没有办法直接使用协程，但是可以通过<code>suspendCancellableCoroutine</code>或<code>callbackFlow</code>将接口回调转化成协程：</p> 
<p><code>suspendCancellableCoroutine</code>等待单次回调API的结果时挂起协程，并将结果返回给调用者；如果需要返回Flow数据流，可以使用<code>callbackFlow</code>。</p> 
<h3><a id="51_suspendCancellableCoroutine_898"></a>5.1 suspendCancellableCoroutine</h3> 
<p>使用举例：</p> 
<pre><code class="prism language-kotlin">   <span class="token comment">//ViewModel中</span>
    <span class="token comment">/**
     * suspendCancellableCoroutine将回调转化为协程使用
     */</span>
    <span class="token keyword">suspend</span> <span class="token keyword">fun</span> <span class="token function">suspendCancelableData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> String <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
            <span class="token function">getSccInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>e<span class="token operator">:</span> Exception<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token string-literal singleline"><span class="token string">"error: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${<!-- --></span><span class="token expression">e<span class="token punctuation">.</span>message</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">"</span></span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/**
     * suspendCancellableCoroutine将回调转化为协程使用
     */</span>
    <span class="token keyword">private</span> <span class="token keyword">suspend</span> <span class="token keyword">fun</span> <span class="token function">getSccInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> String <span class="token operator">=</span> suspendCancellableCoroutine <span class="token punctuation">{<!-- --></span> continuation <span class="token operator">-&gt;</span>
        <span class="token keyword">val</span> callback <span class="token operator">=</span> <span class="token keyword">object</span> <span class="token operator">:</span> ICallBack <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">onSuccess</span><span class="token punctuation">(</span>sucStr<span class="token operator">:</span> String<span class="token operator">?</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token comment">//1、返回结果 将结果赋值给getSccInfo()挂起函数的返回值</span>
                <span class="token comment">//2、如果调用了continuation.cancel()，resume()的结果将不会返回了，因为协程取消了</span>
                continuation<span class="token punctuation">.</span><span class="token function">resume</span><span class="token punctuation">(</span>sucStr <span class="token operator">?:</span> <span class="token string-literal singleline"><span class="token string">"empty"</span></span><span class="token punctuation">)</span>
            <span class="token punctuation">}</span>

            <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">onError</span><span class="token punctuation">(</span>error<span class="token operator">:</span> Exception<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token comment">//这里会将异常抛给上层 需要上层进行处理</span>
                continuation<span class="token punctuation">.</span><span class="token function">resumeWithException</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        continuation<span class="token punctuation">.</span><span class="token function">invokeOnCancellation</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">//协程取消时调用，可以在这里进行解注册</span>
            <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"invokeOnCancellation"</span></span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>

        <span class="token comment">//模拟网络请求 此时协程被suspendCancellableCoroutine挂起，直到触发回调</span>
        Thread <span class="token punctuation">{<!-- --></span>
            Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span>
            <span class="token comment">//模拟Server返回数据</span>
            callback<span class="token punctuation">.</span><span class="token function">onSuccess</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"getServerInfo"</span></span><span class="token punctuation">)</span>
            <span class="token comment">//模拟抛异常</span>
            <span class="token comment">//callback.onError(IllegalArgumentException("server error"))</span>
        <span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

        <span class="token comment">//模拟取消协程</span>
        <span class="token comment">//continuation.cancel()</span>
    <span class="token punctuation">}</span>

    <span class="token comment">//Activity中</span>
    mBtnScc<span class="token punctuation">.</span><span class="token function">setOnClickListener</span> <span class="token punctuation">{<!-- --></span>
        lifecycleScope<span class="token punctuation">.</span><span class="token function">launch</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">val</span> result <span class="token operator">=</span> mFlowModel<span class="token punctuation">.</span><span class="token function">suspendCancelableData</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token function">println</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

	<span class="token comment">//输出：</span>
	<span class="token comment">// getServerInfo</span>
</code></pre> 
<p><code>suspendCancellableCoroutine</code>声明了作用域，并且传入一个<code>CancellableContinuation</code>参数，它可以调用<code>resume</code>、<code>resumeWithException</code>来处理对应的成功、失败回调，还可以调用<code>cancel()</code>方法取消协程的执行(抛出<code>CancellationException</code>异常，但程序不会崩溃，当然也可以通过<code>catch</code>抓住该异常进行处理)。</p> 
<p>上面例子中，当开始执行时会将<code>suspendCancellableCoroutine</code>作用域内协程挂起，如果成功返回数据，会回调<code>continuation.resume()</code>方法将结果返回；如果出现异常，会回调<code>continuation.resumeWithException()</code>将异常抛到上层。这样整个函数处理完后，上层会从挂起点恢复并继续往下执行。</p> 
<h3><a id="52_callbackFlow_963"></a>5.2 callbackFlow</h3> 
<p><code>callbackFlow</code>相对于<code>suspendCancellableCoroutine</code>，对接口回调封装以后返回的是Flow数据流，后续就可以对数据流进行一系列操作。</p> 
<p><code>callbackFlow</code>中的几个重要方法：</p> 
<ol><li><code>trySend/offer</code>：在接口回调中使用，用于上游发射数据，类似于flow{}中的emit()，kotlin 1.5.0以下使用offer，1.5.0以上推荐使用trySend()</li><li><code>awaitClose</code>：写在最后，这是一个挂起函数, 当 flow 被关闭的时候 block 中的代码会被执行 可以在这里取消接口的注册等。</li></ol> 
<p>使用举例，比如当前有个场景：去某个地方，需要先对目的地进行搜索，再出发到达目的地，假设搜索、到达目的地两个行为都是使用回调来执行的，我们现在使用<code>callbackFlow</code>对他们进行修改：</p> 
<p>ViewModel中，搜索目的地：</p> 
<pre><code class="prism language-kotlin"><span class="token keyword">fun</span> <span class="token function">getSearchCallbackFlow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> Flow<span class="token operator">&lt;</span>Boolean<span class="token operator">&gt;</span> <span class="token operator">=</span> callbackFlow <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">val</span> callback <span class="token operator">=</span> <span class="token keyword">object</span> <span class="token operator">:</span> ICallBack <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">onSuccess</span><span class="token punctuation">(</span>sucStr<span class="token operator">:</span> String<span class="token operator">?</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">//搜索目的地成功</span>
            <span class="token function">trySend</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">onError</span><span class="token punctuation">(</span>error<span class="token operator">:</span> Exception<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">//搜索目的地失败</span>
            <span class="token function">trySend</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//模拟网络请求</span>
    Thread <span class="token punctuation">{<!-- --></span>
        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span>
        <span class="token comment">//模拟Server返回数据</span>
        callback<span class="token punctuation">.</span><span class="token function">onSuccess</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"getServerInfo"</span></span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token comment">//这是一个挂起函数, 当 flow 被关闭的时候 block 中的代码会被执行 可以在这里取消接口的注册等</span>
    awaitClose <span class="token punctuation">{<!-- --></span> <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"awaitClose"</span></span><span class="token punctuation">)</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>ViewModel中，前往目的地：</p> 
<pre><code class="prism language-kotlin"><span class="token keyword">fun</span> <span class="token function">goDesCallbackFlow</span><span class="token punctuation">(</span>isSuc<span class="token operator">:</span> Boolean<span class="token punctuation">)</span><span class="token operator">:</span> Flow<span class="token operator">&lt;</span>String<span class="token operator">?</span><span class="token operator">&gt;</span> <span class="token operator">=</span> callbackFlow <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">val</span> callback <span class="token operator">=</span> <span class="token keyword">object</span> <span class="token operator">:</span> ICallBack <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">onSuccess</span><span class="token punctuation">(</span>sucStr<span class="token operator">:</span> String<span class="token operator">?</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token function">trySend</span><span class="token punctuation">(</span>sucStr<span class="token punctuation">)</span>
            <span class="token punctuation">}</span>

            <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">onError</span><span class="token punctuation">(</span>error<span class="token operator">:</span> Exception<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token function">trySend</span><span class="token punctuation">(</span>error<span class="token punctuation">.</span>message<span class="token punctuation">)</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token comment">//模拟网络请求</span>
        Thread <span class="token punctuation">{<!-- --></span>
            Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>isSuc<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token comment">//到达目的地</span>
                callback<span class="token punctuation">.</span><span class="token function">onSuccess</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"arrive at the destination"</span></span><span class="token punctuation">)</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
                <span class="token comment">//发生了错误</span>
                callback<span class="token punctuation">.</span><span class="token function">onError</span><span class="token punctuation">(</span><span class="token function">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"Not at destination"</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

        awaitClose <span class="token punctuation">{<!-- --></span> <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"awaitClose"</span></span><span class="token punctuation">)</span> <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
Activity中，使用Flow<span class="token punctuation">.</span>flatMapConcat对两者进行整合：

mBtnCallbackFlow<span class="token punctuation">.</span><span class="token function">setOnClickListener</span> <span class="token punctuation">{<!-- --></span>
      lifecycleScope<span class="token punctuation">.</span><span class="token function">launch</span> <span class="token punctuation">{<!-- --></span>
          <span class="token comment">//将两个callbackFlow串联起来 先搜索目的地，然后到达目的地</span>
          mFlowModel<span class="token punctuation">.</span><span class="token function">getSearchCallbackFlow</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
              <span class="token punctuation">.</span><span class="token function">flatMapConcat</span> <span class="token punctuation">{<!-- --></span>
                  mFlowModel<span class="token punctuation">.</span><span class="token function">goDesCallbackFlow</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span>
              <span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">collect</span> <span class="token punctuation">{<!-- --></span>
                  mTvCallbackFlow<span class="token punctuation">.</span>text <span class="token operator">=</span> it <span class="token operator">?:</span> <span class="token string-literal singleline"><span class="token string">"error"</span></span>
              <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

	<span class="token comment">//输出：</span>
	<span class="token comment">// arrive at the destination</span>
</code></pre> 
<p>以下结论摘自官网：<br> 与 <code>flow</code> 构建器不同，<code>callbackFlow</code> 允许通过 <code>send</code> 函数从不同 <code>CoroutineContext</code> 发出值，或者通过 <code>offer/trySend</code> 函数在协程外发出值。<br> 在协程内部，<code>callbackFlow</code> 会使用通道，它在概念上与阻塞队列非常相似。通道都有容量配置，限定了可缓冲元素数的上限。在 <code>callbackFlow</code> 中所创建通道的默认容量为 64 个元素。当您尝试向完整通道添加新元素时，<code>send</code> 会将数据提供方挂起，直到新元素有空间为止，而 <code>offer</code> 不会将相关元素添加到通道中，并会立即返回 <code>false</code>。</p> 
<h2><a id="4__1048"></a>4 总结</h2> 
<p><code>Flow</code> 是 <code>Kotlin</code> 提供的解决复杂异步场景的方案，<code>Flow</code>本质是<code>挂起函数</code>，主要用于构建类似<code>生产者-中介-消费者</code>模型，可对流进行<code>处理</code>、<code>过滤</code>、<code>变换</code>、<code>组合</code>、<code>重试</code>、<code>异常捕获</code>、<code>线程切换</code>等，便于开发者进行流的<code>创建</code>、<code>处理</code>与<code>消费</code>。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2efb1f9b2ce609690cf2a39a216c5470/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">前后端分离项目—通用后台管理系统（Vue &#43; SpringBoot）【二】</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/311bf85e60972ca85eb8e4c8fecf0f3f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">ansible 详解</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>