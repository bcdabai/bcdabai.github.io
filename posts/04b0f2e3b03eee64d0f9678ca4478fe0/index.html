<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>python中应用requests库模拟postman请求携带token，使用get和post方法请求头携带token - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="python中应用requests库模拟postman请求携带token，使用get和post方法请求头携带token" />
<meta property="og:description" content="背景： 实际开发中，Python程序中需要调用后台接口，充当前端，后端规定请求头需要携带token
封装的get和post类: class RequestMethodCarryJson: &#34;&#34;&#34; 定义请求类型 以json方式传递参数 &#34;&#34;&#34; def __init__(self): &#34;&#34;&#34;初始化参数&#34;&#34;&#34; self.data = {} self.files = {} def get(self, url, data, headers): &#34;&#34;&#34; 定义get方法请求 :return: &#34;&#34;&#34; try: return requests.get(url=url, data=data, headers=headers, timeout=60) except TimeoutError: return print(&#39;%s get request timeout!&#39; % url) def getCarryToken(self, url, data, headers): &#34;&#34;&#34; 定义get方法请求 :return: &#34;&#34;&#34; try: return requests.get(url=url, json=data, headers=headers, timeout=60) except TimeoutError: return print(&#39;%s get request timeout!&#39; % url) def post(self, url, data, headers): &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/04b0f2e3b03eee64d0f9678ca4478fe0/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-07-17T09:54:03+08:00" />
<meta property="article:modified_time" content="2023-07-17T09:54:03+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">python中应用requests库模拟postman请求携带token，使用get和post方法请求头携带token</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>背景：</h2> 
<p>实际开发中，<strong><span style="color:#ff9900;">Python程序中需要调用后台接口</span></strong>，充当前端，<strong><span style="color:#fe2c24;">后端规定请求头需要携带token</span></strong></p> 
<h2>封装的get和post类:</h2> 
<pre><code>class RequestMethodCarryJson:
    """
    定义请求类型
    以json方式传递参数
    """

    def __init__(self):

        """初始化参数"""
        self.data = {}
        self.files = {}

    def get(self, url, data, headers):
        """
        定义get方法请求
        :return:
        """
        try:
            return requests.get(url=url, data=data, headers=headers, timeout=60)
        except TimeoutError:
            return print('%s get request timeout!' % url)

    def getCarryToken(self, url, data, headers):
        """
        定义get方法请求
        :return:
        """
        try:
            return requests.get(url=url, json=data, headers=headers, timeout=60)
        except TimeoutError:
            return print('%s get request timeout!' % url)

    def post(self, url, data, headers):
        """
        定义post方法请求
        post携带token，看起来不需要像get那样添加一个getCarryToken特有的识别方法
        :return:
        """
        try:
            return requests.post(url=url, data=json.dumps(data), headers=headers, timeout=60)
        except TimeoutError:
            return print('%s post request timeout!' % url)</code></pre> 
<pre><code>class RequestMethodCarryFormData:
    """
    定义请求类型
    以表单方式form-data传递参数
    """

    def __init__(self):

        """初始化参数"""
        self.data = {}
        self.files = {}

    def get(self, url, data, headers):
        """
        定义get方法请求
        :return:
        """
        try:
            return requests.get(url=url, data=data, headers=headers, timeout=60)
        except TimeoutError:
            return print('%s get request timeout!' % url)

    def getCarryToken(self, url, data, headers):
        """
        定义get方法请求，额外添加token
        :return:
        """
        try:
            return requests.get(url=url, json=data, headers=headers, timeout=60)
        except TimeoutError:
            return print('%s get request timeout!' % url)

    def post(self, url, data, headers):
        """
        定义post方法请求
        这个携带json应该不需要额外改
        :return:
        """
        try:
            return requests.post(url=url, data=data, headers=headers, timeout=60)
        except TimeoutError:
            return print('%s post request timeout!' % url)</code></pre> 
<h2>应用场景：</h2> 
<h3>场景1——get请求时Headers携带token[传递参数以json格式]：</h3> 
<p><img alt="" height="555" src="https://images2.imgbox.com/7c/82/cmyZRuxK_o.png" width="1200"></p> 
<h3><img alt="" height="625" src="https://images2.imgbox.com/80/dd/DpDN94mp_o.png" width="1200"></h3> 
<pre><code>​token="里面填token内容"
test1Info = test1(token)

def test1(token):
    """
    携带token,
    访问平台已经存在的数据库，
    以json格式传递数据
    :param token:
    :return:
    """
    url = "http://127.0.0.1:8088/backup/url1"
    headers = {'Content-Type': 'application/json;charset=utf-8', 'token': token}
    data = dict()
    data["param1"] = "param1"
    data["param2"] = "param2"
    resp = RequestMethodCarryJson().getCarryToken(url, data, headers).json()
    dbInfo = resp["items"]
    return dbInfo</code></pre> 
<h3>场景2——post请求时Headers携带token[传递参数以application/x-www-form-urlencoded(表单)格式]：</h3> 
<p><img alt="" height="473" src="https://images2.imgbox.com/47/3e/mcOYIW9n_o.png" width="1200"></p> 
<p><img alt="" height="473" src="https://images2.imgbox.com/2a/b2/GMXKk4uq_o.png" width="1200"></p> 
<p></p> 
<pre><code>token="里面填token内容"
test2Info = test2(token)

def test2(token):
    url = "http://127.0.0.1:8088/testFormData/json/transfer"
    headers = {'Content-Type': 'application/x-www-form-urlencoded', 'token': token}
    data = dict()
    data["param1"] = "param1"
    """
    这里不接受状态码
    """
    resp = RequestMethodCarryFormData().post(url, data, headers).json()
    info = resp["items"]
    if info == "格式正确":
        return True
    else:
        return False</code></pre> 
<h3>场景3——踩坑后总结成功的代码：</h3> 
<pre><code>    """
    请求头携带token拿取信息：
    1-post-以json格式传递数据，请求头携带token成功
    形如：
    # resp = requests.post(url,json=data,headers=headers).json()
    resp = RequestMethodCarryJson().post(url, data, headers).json()


    2-get-以json格式传递数据，请求头携带token成功
    # resp = requests.get(url,json=data,headers=headers).json()
    resp = RequestMethodCarryJson().getCarryToken(url, data, headers).json()

    :param platformInfo:
    :return:
    """</code></pre> 
<h2>延伸理解：</h2> 
<p><img alt="" height="808" src="https://images2.imgbox.com/3f/a8/wwOTCIVy_o.png" width="617"></p> 
<h2>相关资料参考：</h2> 
<p><a href="https://blog.csdn.net/weixin_41882200/article/details/113861722" title="postman中 form-data、x-www-form-urlencoded的区别_叫我峰兄的博客-CSDN博客">postman中 form-data、x-www-form-urlencoded的区别_叫我峰兄的博客-CSDN博客</a></p> 
<p><a href="https://blog.csdn.net/qq_29720657/article/details/109746558#:~:text=python%20requests%20%E5%B8%A6%E8%AF%B7%E6%B1%82%E5%A4%B4Token%E5%8F%91%E8%B5%B7http%E8%AF%B7%E6%B1%82%201%20%23%20-*-%20coding:%20utf-8,%22currentPage%22:%201,%20%22pageSize%22:%2020,%20%22grade%22:%20%22%22%20%7D%20%E6%9B%B4%E5%A4%9A%E9%A1%B9%E7%9B%AE" title="python requests 带请求头Token发起http请求_python request token_软件测试李同学的博客-CSDN博客">python requests 带请求头Token发起http请求_python request token_软件测试李同学的博客-CSDN博客</a></p> 
<p><a href="https://www.cnblogs.com/ludundun/p/14052097.html" rel="nofollow" title="python发送requests请求时，使用登录的token值，作为下一个接口的请求头信息 - 大海一个人听 - 博客园 (cnblogs.com)">python发送requests请求时，使用登录的token值，作为下一个接口的请求头信息 - 大海一个人听 - 博客园 (cnblogs.com)</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0d95cec80e43872622bcecf8fdd3a5df/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【计算机毕业设计】实验室预约管理系统</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e2e4802d77fe6ef302678801a8889c24/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【网络安全】常见的网路安全设备及功能作用总结</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>