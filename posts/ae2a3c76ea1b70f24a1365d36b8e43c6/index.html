<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>better-scroll.js文档 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="better-scroll.js文档" />
<meta property="og:description" content="文章目录 better-scroll介绍better-scroll 是什么起步滚动原理better-scroll 在 MVVM 框架的应用 安装NPMscript 加载 选项 / 基础startXstartYscrollXscrollYfreeScrolldirectionLockThresholdeventPassthroughclickdblclick(v1.12.0&#43;)tapbouncebounceTimemomentummomentumLimitTimemomentumLimitDistanceswipeTimeswipeBounceTimedecelerationflickLimitTimeflickLimitDistanceresizePollingprobeTypepreventDefaultpreventDefaultExceptionHWCompositinguseTransitionuseTransformbindToWrapperdisableMousedisableTouchobserveDOM(v1.5.3&#43;)autoBlur(v1.7.0&#43;)stopPropagation(v1.9.0&#43;) 选项 / 高级wheelsnapscrollbarpullDownRefreshpullUpLoadmouseWheel(v1.8.0&#43;)zoom(v1.11.0&#43;)infinity(v1.12.0&#43;) 方法 / 通用refresh()scrollTo(x, y, time, easing)scrollBy(x, y, time, easing)scrollToElement(el, time, offsetX, offsetY, easing)stop()enable()disable()destroy()on(type, fn, context)once(type, fn, context)off(type, fn) 方法 / 定制goToPage(x, y, time, easing)next(time, easing)prev(time, easing)getCurrentPage()wheelTo(index)getSelectedIndex()finishPullDown()openPullDown(config) (v1.9.0&#43;)closePullDown() (v1.9.0&#43;)autoPullDownRefresh() (v1.14.0)finishPullUp()openPullUp(config) (v1.9.0&#43;)closePullUp() (v1.9.0&#43;)zoomTo(scale, x, y) (v1.12.0&#43;) 事件beforeScrollStartscrollStartscrollscrollCancelscrollEndtouchEndflickrefreshdestroypullingDownpullingUpzoomStartzoomEnd 属性xymaxScrollXmaxScrollYmovingDirectionXmovingDirectionYdirectionXdirectionYenabledisInTransitionisAnimating better-scroll 介绍 better-scroll 是什么 better-scroll 是一款重点解决移动端（已支持 PC）各种滚动场景需求的插件。它的核心是借鉴的 iscroll 的实现，它的 API 设计基本兼容 iscroll，在 iscroll 的基础上又扩展了一些 feature 以及做了一些性能优化。
better-scroll 是基于原生 JS 实现的，不依赖任何框架。它编译后的代码大小是 63kb，压缩后是 35kb，gzip 后仅有 9kb，是一款非常轻量的 JS lib。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/ae2a3c76ea1b70f24a1365d36b8e43c6/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-04-09T14:15:11+08:00" />
<meta property="article:modified_time" content="2020-04-09T14:15:11+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">better-scroll.js文档</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#betterscroll_1" rel="nofollow">better-scroll</a></li><li><a href="#_4" rel="nofollow">介绍</a></li><li><ul><li><a href="#betterscroll__6" rel="nofollow">better-scroll 是什么</a></li><li><a href="#_9" rel="nofollow">起步</a></li><li><a href="#_33" rel="nofollow">滚动原理</a></li><li><a href="#betterscroll__MVVM__39" rel="nofollow">better-scroll 在 MVVM 框架的应用</a></li></ul> 
  </li><li><a href="#_43" rel="nofollow">安装</a></li><li><ul><li><a href="#NPM_45" rel="nofollow">NPM</a></li><li><a href="#script__59" rel="nofollow">script 加载</a></li></ul> 
  </li><li><a href="#___63" rel="nofollow">选项 / 基础</a></li><li><ul><li><a href="#startX_73" rel="nofollow">startX</a></li><li><a href="#startY_79" rel="nofollow">startY</a></li><li><a href="#scrollX_85" rel="nofollow">scrollX</a></li><li><a href="#scrollY_92" rel="nofollow">scrollY</a></li><li><a href="#freeScroll_99" rel="nofollow">freeScroll</a></li><li><a href="#directionLockThreshold_106" rel="nofollow">directionLockThreshold</a></li><li><a href="#eventPassthrough_113" rel="nofollow">eventPassthrough</a></li><li><a href="#click_121" rel="nofollow">click</a></li><li><a href="#dblclickv1120_127" rel="nofollow">dblclick(v1.12.0+)</a></li><li><a href="#tap_138" rel="nofollow">tap</a></li><li><a href="#bounce_144" rel="nofollow">bounce</a></li><li><a href="#bounceTime_160" rel="nofollow">bounceTime</a></li><li><a href="#momentum_166" rel="nofollow">momentum</a></li><li><a href="#momentumLimitTime_172" rel="nofollow">momentumLimitTime</a></li><li><a href="#momentumLimitDistance_178" rel="nofollow">momentumLimitDistance</a></li><li><a href="#swipeTime_184" rel="nofollow">swipeTime</a></li><li><a href="#swipeBounceTime_190" rel="nofollow">swipeBounceTime</a></li><li><a href="#deceleration_196" rel="nofollow">deceleration</a></li><li><a href="#flickLimitTime_202" rel="nofollow">flickLimitTime</a></li><li><a href="#flickLimitDistance_208" rel="nofollow">flickLimitDistance</a></li><li><a href="#resizePolling_214" rel="nofollow">resizePolling</a></li><li><a href="#probeType_220" rel="nofollow">probeType</a></li><li><a href="#preventDefault_227" rel="nofollow">preventDefault</a></li><li><a href="#preventDefaultException_233" rel="nofollow">preventDefaultException</a></li><li><a href="#HWCompositing_240" rel="nofollow">HWCompositing</a></li><li><a href="#useTransition_247" rel="nofollow">useTransition</a></li><li><a href="#useTransform_254" rel="nofollow">useTransform</a></li><li><a href="#bindToWrapper_261" rel="nofollow">bindToWrapper</a></li><li><a href="#disableMouse_267" rel="nofollow">disableMouse</a></li><li><a href="#disableTouch_273" rel="nofollow">disableTouch</a></li><li><a href="#observeDOMv153_279" rel="nofollow">observeDOM(v1.5.3+)</a></li><li><a href="#autoBlurv170_285" rel="nofollow">autoBlur(v1.7.0+)</a></li><li><a href="#stopPropagationv190_291" rel="nofollow">stopPropagation(v1.9.0+)</a></li></ul> 
  </li><li><a href="#___300" rel="nofollow">选项 / 高级</a></li><li><ul><li><a href="#wheel_303" rel="nofollow">wheel</a></li><li><a href="#snap_321" rel="nofollow">snap</a></li><li><a href="#scrollbar_344" rel="nofollow">scrollbar</a></li><li><a href="#pullDownRefresh_358" rel="nofollow">pullDownRefresh</a></li><li><a href="#pullUpLoad_372" rel="nofollow">pullUpLoad</a></li><li><a href="#mouseWheelv180_385" rel="nofollow">mouseWheel(v1.8.0+)</a></li><li><a href="#zoomv1110_400" rel="nofollow">zoom(v1.11.0+)</a></li><li><a href="#infinityv1120_415" rel="nofollow">infinity(v1.12.0+)</a></li></ul> 
  </li><li><a href="#___443" rel="nofollow">方法 / 通用</a></li><li><ul><li><a href="#refresh_446" rel="nofollow">refresh()</a></li><li><a href="#scrollTox_y_time_easing_452" rel="nofollow">scrollTo(x, y, time, easing)</a></li><li><a href="#scrollByx_y_time_easing_462" rel="nofollow">scrollBy(x, y, time, easing)</a></li><li><a href="#scrollToElementel_time_offsetX_offsetY_easing_472" rel="nofollow">scrollToElement(el, time, offsetX, offsetY, easing)</a></li><li><a href="#stop_483" rel="nofollow">stop()</a></li><li><a href="#enable_489" rel="nofollow">enable()</a></li><li><a href="#disable_495" rel="nofollow">disable()</a></li><li><a href="#destroy_501" rel="nofollow">destroy()</a></li><li><a href="#ontype_fn_context_507" rel="nofollow">on(type, fn, context)</a></li><li><a href="#oncetype_fn_context_525" rel="nofollow">once(type, fn, context)</a></li><li><a href="#offtype_fn_534" rel="nofollow">off(type, fn)</a></li></ul> 
  </li><li><a href="#___559" rel="nofollow">方法 / 定制</a></li><li><ul><li><a href="#goToPagex_y_time_easing_562" rel="nofollow">goToPage(x, y, time, easing)</a></li><li><a href="#nexttime_easing_572" rel="nofollow">next(time, easing)</a></li><li><a href="#prevtime_easing_580" rel="nofollow">prev(time, easing)</a></li><li><a href="#getCurrentPage_588" rel="nofollow">getCurrentPage()</a></li><li><a href="#wheelToindex_594" rel="nofollow">wheelTo(index)</a></li><li><a href="#getSelectedIndex_601" rel="nofollow">getSelectedIndex()</a></li><li><a href="#finishPullDown_607" rel="nofollow">finishPullDown()</a></li><li><a href="#openPullDownconfig_v190_613" rel="nofollow">openPullDown(config) (v1.9.0+)</a></li><li><a href="#closePullDown_v190_620" rel="nofollow">closePullDown() (v1.9.0+)</a></li><li><a href="#autoPullDownRefresh_v1140_626" rel="nofollow">autoPullDownRefresh() (v1.14.0)</a></li><li><a href="#finishPullUp_632" rel="nofollow">finishPullUp()</a></li><li><a href="#openPullUpconfig_v190_638" rel="nofollow">openPullUp(config) (v1.9.0+)</a></li><li><a href="#closePullUp_v190_645" rel="nofollow">closePullUp() (v1.9.0+)</a></li><li><a href="#zoomToscale_x_y_v1120_651" rel="nofollow">zoomTo(scale, x, y) (v1.12.0+)</a></li></ul> 
  </li><li><a href="#_664" rel="nofollow">事件</a></li><li><ul><li><a href="#beforeScrollStart_667" rel="nofollow">beforeScrollStart</a></li><li><a href="#scrollStart_672" rel="nofollow">scrollStart</a></li><li><a href="#scroll_677" rel="nofollow">scroll</a></li><li><a href="#scrollCancel_682" rel="nofollow">scrollCancel</a></li><li><a href="#scrollEnd_687" rel="nofollow">scrollEnd</a></li><li><a href="#touchEnd_692" rel="nofollow">touchEnd</a></li><li><a href="#flick_697" rel="nofollow">flick</a></li><li><a href="#refresh_702" rel="nofollow">refresh</a></li><li><a href="#destroy_707" rel="nofollow">destroy</a></li><li><a href="#pullingDown_712" rel="nofollow">pullingDown</a></li><li><a href="#pullingUp_717" rel="nofollow">pullingUp</a></li><li><a href="#zoomStart_722" rel="nofollow">zoomStart</a></li><li><a href="#zoomEnd_727" rel="nofollow">zoomEnd</a></li></ul> 
  </li><li><a href="#_731" rel="nofollow">属性</a></li><li><ul><li><a href="#x_734" rel="nofollow">x</a></li><li><a href="#y_739" rel="nofollow">y</a></li><li><a href="#maxScrollX_744" rel="nofollow">maxScrollX</a></li><li><a href="#maxScrollY_750" rel="nofollow">maxScrollY</a></li><li><a href="#movingDirectionX_756" rel="nofollow">movingDirectionX</a></li><li><a href="#movingDirectionY_762" rel="nofollow">movingDirectionY</a></li><li><a href="#directionX_768" rel="nofollow">directionX</a></li><li><a href="#directionY_774" rel="nofollow">directionY</a></li><li><a href="#enabled_780" rel="nofollow">enabled</a></li><li><a href="#isInTransition_785" rel="nofollow">isInTransition</a></li><li><a href="#isAnimating_791" rel="nofollow">isAnimating</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="betterscroll_1"></a>better-scroll</h2> 
<p></p> 
<h2><a id="_4"></a>介绍</h2> 
<p></p> 
<h3><a id="betterscroll__6"></a>better-scroll 是什么</h3> 
<p>better-scroll 是一款重点解决移动端（已支持 PC）各种滚动场景需求的插件。它的核心是借鉴的 <a href="https://github.com/cubiq/iscroll">iscroll</a> 的实现，它的 API 设计基本兼容 iscroll，在 iscroll 的基础上又扩展了一些 feature 以及做了一些性能优化。<br>better-scroll 是基于原生 JS 实现的，不依赖任何框架。它编译后的代码大小是 63kb，压缩后是 35kb，gzip 后仅有 9kb，是一款非常轻量的 JS lib。<br> </p> 
<h3><a id="_9"></a>起步</h3> 
<p>学习使用 better-scroll 最好的方式是看它的 demo 代码，我们把代码都放在了 <a href="https://github.com/ustbhuangyi/better-scroll/tree/master/example">example</a> 目录。由于目前最适合移动端开发的前端 mvvm 框架是 <a href="https://github.com/vuejs/vue">Vue</a>，并且 better-scroll 可以很好的和 Vue 配合使用的，所以 demo 我都用 Vue 进行了重写。<br>better-scroll 最常见的应用场景是列表滚动，我们来看一下它的 html 结构</p> 
<pre><code>&lt;div class="wrapper"&gt;
  &lt;ul class="content"&gt;
    &lt;li&gt;...&lt;/li&gt;
    &lt;li&gt;...&lt;/li&gt;
    ...
  &lt;/ul&gt;
  &lt;!-- 这里可以放一些其它的 DOM，但不会影响滚动 --&gt;
&lt;/div&gt;
</code></pre> 
<p>上面的代码中 better-scroll 是作用在外层 wrapper 容器上的，滚动的部分是 content 元素。这里要注意的是，better-scroll 只处理容器（wrapper）的第一个子元素（content）的滚动，其它的元素都会被忽略。<br>最简单的初始化代码如下：</p> 
<pre><code>import BScroll from 'better-scroll'
let wrapper = document.querySelector('.wrapper')
let scroll = new BScroll(wrapper)
</code></pre> 
<p>better-scroll 提供了一个类，实例化的第一个参数是一个原生的 DOM 对象。当然，如果传递的是一个字符串，better-scroll 内部会尝试调用 querySelector 去获取这个 DOM 对象，所以初始化代码也可以是这样：</p> 
<pre><code>import BScroll from 'better-scroll'
let scroll = new BScroll('.wrapper')
</code></pre> 
<p></p> 
<h3><a id="_33"></a>滚动原理</h3> 
<p>很多人已经用过 better-scroll，我收到反馈最多的问题是：</p> 
<blockquote> 
 <p>better-scroll 初始化了， 但是没法滚动。</p> 
</blockquote> 
<p>不能滚动是现象，我们得搞清楚这其中的根本原因。在这之前，我们先来看一下浏览器的滚动原理： 浏览器的滚动条大家都会遇到，当页面内容的高度超过视口高度的时候，会出现纵向滚动条；当页面内容的宽度超过视口宽度的时候，会出现横向滚动条。也就是当我们的视口展示不下内容的时候，会通过滚动条的方式让用户滚动屏幕看到剩余的内容。<br>better-scroll 也是一样的原理，我们可以用一张图更直观的感受一下：<br><img src="https://images2.imgbox.com/94/c7/d9AIDEPE_o.png" alt=""><br>绿色部分为 wrapper，也就是父容器，它会有<strong>固定的高度</strong>。黄色部分为 content，它是父容器的<strong>第一个子元素</strong>，它的高度会随着内容的大小而撑高。那么，当 content 的高度不超过父容器的高度，是不能滚动的，而它一旦超过了父容器的高度，我们就可以滚动内容区了，这就是 better-scroll 的滚动原理。<br> </p> 
<h3><a id="betterscroll__MVVM__39"></a>better-scroll 在 MVVM 框架的应用</h3> 
<p>我之前写过一篇<a href="https://zhuanlan.zhihu.com/p/27407024" rel="nofollow">当 better-scroll 遇见 Vue</a>，也希望大家投稿，分享一下 better-scroll 在其它框架下的使用心得。<br>一款超赞的基于 Vue 实现的组件库 <a href="https://github.com/didi/cube-ui/">cube-ui</a>。<br></p> 
<p></p> 
<h2><a id="_43"></a>安装</h2> 
<p></p> 
<h3><a id="NPM_45"></a>NPM</h3> 
<p>better-scroll 托管在 Npm 上，执行如下命令安装：</p> 
<pre><code>npm install better-scroll --save
</code></pre> 
<p>接下来就可以在代码中引入了，<a href="https://webpack.js.org/" rel="nofollow">webpack</a> 等构建工具都支持从 node_modules 里引入代码：</p> 
<pre><code>import BScroll from 'better-scroll'
</code></pre> 
<p>如果是 ES5 的语法，如下：</p> 
<pre><code>var BScroll = require('better-scroll')
</code></pre> 
<p></p> 
<h3><a id="script__59"></a>script 加载</h3> 
<p>better-scroll 也支持直接用 script 加载的方式，加载后会在 window 上挂载一个 BScroll 的对象。<br>你可以直接用：<code>https://unpkg.com/better-scroll/dist/bscroll.min.js</code> 这个地址。也可以把 dist 目录下的文件拷贝出去发布到自己的 cdn 服务器。<br></p> 
<p></p> 
<h2><a id="___63"></a>选项 / 基础</h2> 
<p>better-scroll 支持很多参数配置，可以在初始化的时候传入第二个参数，比如：</p> 
<pre><code>let scroll = new BScroll('.wrapper',{
    scrollY: true,
    click: true
})
</code></pre> 
<p>这样就实现了一个纵向可点击的滚动效果。better-scroll 支持的参数非常多，可以修改它们去实现更多的 feature。通常你可以不改这些参数（列出不建议修改的参数），better-scroll 已经为你实现了最佳效果，接下来我们来列举 better-scroll 支持的参数。<br> </p> 
<h3><a id="startX_73"></a>startX</h3> 
<ul><li>类型：Number,</li><li>默认值：0</li><li>作用：横轴方向初始化位置。<br> </li></ul> 
<h3><a id="startY_79"></a>startY</h3> 
<ul><li>类型：Number,</li><li>默认值：0</li><li>作用：纵轴方向初始化位置，见 <a href="https://ustbhuangyi.github.io/better-scroll/#/examples/vertical-scroll" rel="nofollow">Demo</a> 。<br> </li></ul> 
<h3><a id="scrollX_85"></a>scrollX</h3> 
<ul><li>类型：Boolean</li><li>默认值: false</li><li>作用：当设置为 true 的时候，可以开启横向滚动。</li><li>备注：当设置 <a href="http://ustbhuangyi.github.io/better-scroll/doc/zh-hans/options.html#eventpassthrough" rel="nofollow">eventPassthrough</a> 为 ‘horizontal’ 的时候，该配置无效。<br> </li></ul> 
<h3><a id="scrollY_92"></a>scrollY</h3> 
<ul><li>类型：Boolean</li><li>默认值：true</li><li>作用：当设置为 true 的时候，可以开启纵向滚动。</li><li>备注：当设置 <a href="http://ustbhuangyi.github.io/better-scroll/doc/zh-hans/options.html#eventpassthrough" rel="nofollow">eventPassthrough</a> 为 ‘vertical’ 的时候，该配置无效。<br> </li></ul> 
<h3><a id="freeScroll_99"></a>freeScroll</h3> 
<ul><li>类型：Boolean</li><li>默认值：false</li><li>作用：有些场景我们需要支持横向和纵向同时滚动，而不仅限制在某个方向，这个时候我们只要设置 <code>freeScroll</code> 为 true 即可。</li><li>备注：当设置 <a href="http://ustbhuangyi.github.io/better-scroll/doc/zh-hans/options.html#eventpassthrough" rel="nofollow">eventPassthrough</a> 不为空的时候，该配置无效。<br> </li></ul> 
<h3><a id="directionLockThreshold_106"></a>directionLockThreshold</h3> 
<ul><li>类型：Number</li><li>默认值：5（不建议修改）</li><li>作用：当我们需要锁定只滚动一个方向的时候，我们在<strong>初始滚动</strong>的时候根据横轴和纵轴滚动的绝对值做差，当差值大于 <code>directionLockThreshold</code> 的时候来决定滚动锁定的方向。</li><li>备注：当设置 <a href="http://ustbhuangyi.github.io/better-scroll/doc/zh-hans/options.html#eventpassthrough" rel="nofollow">eventPassthrough</a> 的时候，<code>directionLockThreshold</code> 设置无效，始终为 0。<br> </li></ul> 
<h3><a id="eventPassthrough_113"></a>eventPassthrough</h3> 
<ul><li>类型： String</li><li>默认值：’’</li><li>可选值：‘vertical’、‘horizontal’</li><li>作用：有时候我们使用 better-scroll 在某个方向模拟滚动的时候，希望在另一个方向保留原生的滚动（比如轮播图，我们希望横向模拟横向滚动，而纵向的滚动还是保留原生滚动，我们可以设置 <code>eventPassthrough</code> 为 vertical；相应的，如果我们希望保留横向的原生滚动，可以设置<code>eventPassthrough</code>为 horizontal）。</li><li>备注：<code>eventPassthrough</code> 的设置会导致其它一些选项配置无效，需要小心使用它。<br> </li></ul> 
<h3><a id="click_121"></a>click</h3> 
<ul><li>类型：Boolean</li><li>默认值：false</li><li>作用：better-scroll 默认会阻止浏览器的原生 click 事件。当设置为 true，better-scroll 会派发一个 click 事件，我们会给派发的 event 参数加一个私有属性 <code>_constructed</code>，值为 true。<br> </li></ul> 
<h3><a id="dblclickv1120_127"></a>dblclick(v1.12.0+)</h3> 
<ul><li>类型：Boolean | Object</li><li>默认值：false</li><li>作用：派发双击点击事件。当配置成 true 的时候，默认 2 次点击的延时为 300 ms，如果配置成对象可以修改 <code>delay</code>。</li></ul> 
<pre><code>dblclick: {
  delay: 300
}
</code></pre> 
<p></p> 
<h3><a id="tap_138"></a>tap</h3> 
<ul><li>类型：Boolean | String</li><li>默认值：false</li><li>作用：因为 better-scroll 会阻止原生的 click 事件，我们可以设置 tap 为 true，它会在区域被点击的时候派发一个 tap 事件，你可以像监听原生事件那样去监听它，如 <code>element.addEventListener('tap', doSomething, false);</code>。如果 tap 设置为字符串, 那么这个字符串就作为自定义事件名称。如 <code>tap: 'myCustomTapEvent'</code>。<br> </li></ul> 
<h3><a id="bounce_144"></a>bounce</h3> 
<ul><li>类型：Boolean | Object</li><li>默认值：true</li><li>作用：当滚动超过边缘的时候会有一小段回弹动画。设置为 true 则开启动画。</li></ul> 
<pre><code>bounce: {
  top: true,
  bottom: true,
  left: true,
  right: true
}
</code></pre> 
<ul><li>自 1.10.0 版本以后，<code>bounce</code> 可以支持关闭某些边的回弹效果，可以设置对应边的 <code>key</code> 为 false 即可。<br> </li></ul> 
<h3><a id="bounceTime_160"></a>bounceTime</h3> 
<ul><li>类型：Number</li><li>默认值：800（单位ms，不建议修改）</li><li>作用：设置回弹动画的动画时长。<br> </li></ul> 
<h3><a id="momentum_166"></a>momentum</h3> 
<ul><li>类型：Boolean</li><li>默认值：true</li><li>作用：当快速在屏幕上滑动一段距离的时候，会根据滑动的距离和时间计算出动量，并生成滚动动画。设置为 true 则开启动画。<br> </li></ul> 
<h3><a id="momentumLimitTime_172"></a>momentumLimitTime</h3> 
<ul><li>类型：Number</li><li>默认值：300（单位ms，不建议修改）</li><li>作用：只有在屏幕上快速滑动的时间小于 <code>momentumLimitTime</code>，才能开启 momentum 动画。<br> </li></ul> 
<h3><a id="momentumLimitDistance_178"></a>momentumLimitDistance</h3> 
<ul><li>类型：Number</li><li>默认值：15（单位px，不建议修改）</li><li>作用：只有在屏幕上快速滑动的距离大于 <code>momentumLimitDistance</code>，才能开启 momentum 动画。<br> </li></ul> 
<h3><a id="swipeTime_184"></a>swipeTime</h3> 
<ul><li>类型：Number</li><li>默认值：2500（单位ms，不建议修改）</li><li>作用：设置 momentum 动画的动画时长。<br> </li></ul> 
<h3><a id="swipeBounceTime_190"></a>swipeBounceTime</h3> 
<ul><li>类型：Number</li><li>默认值：500（单位ms，不建议修改）</li><li>作用：设置当运行 momentum 动画时，超过边缘后的回弹整个动画时间。<br> </li></ul> 
<h3><a id="deceleration_196"></a>deceleration</h3> 
<ul><li>类型：Number</li><li>默认值：0.0015（不建议修改）</li><li>作用：表示 momentum 动画的减速度。<br> </li></ul> 
<h3><a id="flickLimitTime_202"></a>flickLimitTime</h3> 
<ul><li>类型：Number</li><li>默认值：200（单位ms，不建议修改）</li><li>作用：有的时候我们要捕获用户的轻拂动作（短时间滑动一个较短的距离）。只有用户在屏幕上滑动的时间小于 <code>flickLimitTime</code> ，才算一次轻拂。<br> </li></ul> 
<h3><a id="flickLimitDistance_208"></a>flickLimitDistance</h3> 
<ul><li>类型：Number</li><li>默认值：100（单位px，不建议修改）</li><li>作用：只有用户在屏幕上滑动的距离小于 <code>flickLimitDistance</code> ，才算一次轻拂。<br> </li></ul> 
<h3><a id="resizePolling_214"></a>resizePolling</h3> 
<ul><li>类型：Number</li><li>默认值：60（单位ms，不建议修改)</li><li>作用：当窗口的尺寸改变的时候，需要对 better-scroll 做重新计算，为了优化性能，我们对重新计算做了延时。60ms 是一个比较合理的值。<br> </li></ul> 
<h3><a id="probeType_220"></a>probeType</h3> 
<ul><li>类型：Number</li><li>默认值：0</li><li>可选值：1、2、3</li><li>作用：有时候我们需要知道滚动的位置。当 probeType 为 1 的时候，会非实时（屏幕滑动超过一定时间后）派发<a href="http://ustbhuangyi.github.io/better-scroll/doc/zh-hans/events.html#scroll" rel="nofollow">scroll 事件</a>；当 probeType 为 2 的时候，会在屏幕滑动的过程中实时的派发 scroll 事件；当 probeType 为 3 的时候，不仅在屏幕滑动的过程中，而且在 momentum 滚动动画运行过程中实时派发 scroll 事件。如果没有设置该值，其默认值为 0，即不派发 scroll 事件。<br> </li></ul> 
<h3><a id="preventDefault_227"></a>preventDefault</h3> 
<ul><li>类型：Boolean</li><li>默认值：true</li><li>作用：当事件派发后是否阻止浏览器默认行为。这个值应该设为 true，除非你真的知道你在做什么，通常你可能用到的是 <a href="http://ustbhuangyi.github.io/better-scroll/doc/zh-hans/options.html#preventdefaultexception" rel="nofollow">preventDefaultException</a>。<br> </li></ul> 
<h3><a id="preventDefaultException_233"></a>preventDefaultException</h3> 
<ul><li>类型：Object</li><li>默认值：<code>{ tagName: /^(INPUT|TEXTAREA|BUTTON|SELECT)$/}</code></li><li>作用：better-scroll 的实现会阻止原生的滚动，这样也同时阻止了一些原生组件的默认行为。这个时候我们不能对这些元素做 preventDefault，所以我们可以配置 preventDefaultException。默认值 <code>{tagName: /^(INPUT|TEXTAREA|BUTTON|SELECT)$/}</code>表示标签名为 input、textarea、button、select 这些元素的默认行为都不会被阻止。</li><li>备注：这是一个非常有用的配置，它的 key 是 DOM 元素的属性值，value 可以是一个正则表达式。比如我们想配一个 class 名称为 test 的元素，那么配置规则为 <code>{className:/(^|\s)test(\s|$)/}</code>。<br> </li></ul> 
<h3><a id="HWCompositing_240"></a>HWCompositing</h3> 
<ul><li>类型：Boolean</li><li>默认值：true（不建议修改）</li><li>作用：是否开启硬件加速，开启它会在 scroller 上添加 <code>translateZ(0)</code> 来开启硬件加速从而提升动画性能，有很好的滚动效果。</li><li>备注：只有支持硬件加速的浏览器开启才有效果。<br> </li></ul> 
<h3><a id="useTransition_247"></a>useTransition</h3> 
<ul><li>类型：Boolean</li><li>默认值：true（不建议修改）</li><li>作用：是否使用 CSS3 transition 动画。如果设置为 false，则使用 requestAnimationFrame 做动画。</li><li>备注：只有支持 CSS3 的浏览器开启才有效果。<br> </li></ul> 
<h3><a id="useTransform_254"></a>useTransform</h3> 
<ul><li>类型：Boolean</li><li>默认值：true（不建议修改）</li><li>作用：是否使用 CSS3 transform 做位移。如果设置为 false, 则设置元素的 <code>top/left</code> (这种情况需要 scroller 是绝对定位的)。</li><li>备注：只有支持 CSS3 的浏览器开启才有效果。<br> </li></ul> 
<h3><a id="bindToWrapper_261"></a>bindToWrapper</h3> 
<ul><li>类型：Boolean</li><li>默认值：false</li><li>作用：move 事件通常会绑定到 document 上而不是滚动的容器上，当移动的过程中光标或手指离开滚动的容器滚动仍然会继续，这通常是期望的。当然你也可以把 move 事件绑定到滚动的容器上，<code>bindToWrapper</code> 设置为 true 即可，这样一旦移动的过程中光标或手指离开滚动的容器，滚动会立刻停止。<br> </li></ul> 
<h3><a id="disableMouse_267"></a>disableMouse</h3> 
<ul><li>类型：Boolean</li><li>默认值：根据当前浏览器环境计算而来（不建议修改）</li><li>作用：当在移动端环境（支持 touch 事件），disableMouse 会计算为 true，这样就不会监听鼠标相关的事件，而在 PC 环境，disableMouse 会计算为 false，就会监听鼠标相关事件，不建议修改该属性，除非你知道你在做什么。<br> </li></ul> 
<h3><a id="disableTouch_273"></a>disableTouch</h3> 
<ul><li>类型：Boolean</li><li>默认值：根据当前浏览器环境计算而来（不建议修改）</li><li>作用：当在移动端环境（支持 touch 事件），disableTouch 会计算为 false，这样会监听 touch 相关的事件，而在 PC 环境，disableTouch 会计算为 true，就不会监听 touch 相关事件。不建议修改该属性，除非你知道你在做什么。<br> </li></ul> 
<h3><a id="observeDOMv153_279"></a>observeDOM(v1.5.3+)</h3> 
<ul><li>类型：Boolean</li><li>默认值：true</li><li>作用：会检测 scroller 内部 DOM 变化，自动调用 refresh 方法重新计算来保证滚动的正确性。它会额外增加一些性能开销，如果你能明确地知道 scroller 内部 DOM 的变化时机并手动调用 refresh 重新计算，你可以把该选项设置为 false。<br> </li></ul> 
<h3><a id="autoBlurv170_285"></a>autoBlur(v1.7.0+)</h3> 
<ul><li>类型：Boolean</li><li>默认值：true</li><li>作用：在滚动之前会让当前激活的元素（input、textarea）自动失去焦点。<br> </li></ul> 
<h3><a id="stopPropagationv190_291"></a>stopPropagation(v1.9.0+)</h3> 
<ul><li>类型：Boolean</li><li>默认值：false</li><li>作用：是否阻止事件冒泡。多用在嵌套 scroll 的场景。</li></ul> 
<p></p> 
<h2><a id="___300"></a>选项 / 高级</h2> 
<p>better-scroll 还支持一些高级配置，来实现一些特殊的 feature。<br> </p> 
<h3><a id="wheel_303"></a>wheel</h3> 
<ul><li>类型：Boolean | Object</li><li>默认值：false</li><li>作用：这个配置是为了做 Picker 组件用的，默认为 false，如果开启则需要配置一个 Object。</li></ul> 
<pre><code>wheel:{
  selectedIndex: 0,
  rotate: 25,
  adjustTime: 400,
  wheelWrapperClass: 'wheel-scroll',
  wheelItemClass: 'wheel-item',
  wheelDisabledItemClass: 'wheel-disabled-item' // version 1.15.0 支持
}
</code></pre> 
<ul><li>备注：这是一个高级的配置，一般场景不需要配置，具体应用场景可见 <a href="https://ustbhuangyi.github.io/better-scroll/#/examples/picker/zh" rel="nofollow">Picker Demo</a> 。想了解更多的细节可以去看 example 中的 <a href="https://github.com/ustbhuangyi/better-scroll/blob/master/example/components/picker/picker.vue">picker</a> 组件的代码。<br><strong>注意</strong>：<br>1.如果配置为 Object 的时候，<code>wheelWrapperClass</code> 和 <code>wheelItemClass</code> 必须对应于你的实例 <code>better-scroll</code> 的 <code>wrapper</code> 类名和 <code>wrapper</code> 内的子类名。二者的默认值是 “<code>wheel-scroll</code>”/"<code>wheel-item</code>"，如果你不配置或者配置的名称和你对应DOM节点的类名不一致的话会导致一个问题：滚动起来的时候点击一下终止滚动并不会触发 <code>scrollEnd</code> 事件，进而影响诸如城市选择器联动数据的这种组件的结果。<br>2.<code>wheelDisabledItemClass</code> 是用于配置禁止选中某选项的样式类名。better-scroll 实例上的属性 <code>selectedIndex</code> 是表示当前选中项的索引，如果你配置的选项都是禁止选中的状态，那么 <code>selectedIndex</code> 一直保持为 -1。我们是参照 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/select" rel="nofollow">Web select 标签</a> 的交互实现的。<br><br> </li></ul> 
<h3><a id="snap_321"></a>snap</h3> 
<ul><li>类型：Boolean | Object</li><li>默认值：false</li><li>作用：这个配置是为了做 Slide 组件用的，默认为 false，如果开启则需要配置一个 Object，例如：</li></ul> 
<pre><code>snap: {
 loop: false,
 threshold: 0.1,
 stepX: 100,
 stepY: 100,
 easing: {
   style: 'cubic-bezier(0.25, 0.46, 0.45, 0.94)',
   fn: function(t) {
     return t * (2 - t)
   }
 }
}
</code></pre> 
<ul><li>注意：<code>loop</code> 为 true 是为了支持循环轮播，但只有一个元素的时候，<code>loop</code> 为 true 是无效的，也并不会 clone 节点。<code>threshold</code> 表示可滚动到下一个的阈值，<code>easing</code> 表示滚动的缓动函数。</li><li>备注：这是一个高级的配置，一般场景不需要配置，具体应用场景可见 <a href="https://ustbhuangyi.github.io/better-scroll/#/examples/slide/en" rel="nofollow">Slide Demo</a> 。想了解更多的细节可以去看 example 中的 <a href="https://github.com/ustbhuangyi/better-scroll/blob/master/example/components/slide/slide.vue">slide</a> 组件的代码。<br> </li></ul> 
<h3><a id="scrollbar_344"></a>scrollbar</h3> 
<ul><li>类型：Boolean | Object</li><li>默认值：false</li><li>作用：这个配置可以开启滚动条，默认为 false。当设置为 true 或者是一个 Object 的时候，都会开启滚动条，例如：</li></ul> 
<pre><code>scrollbar: {
 fade: true,
 interactive: false // 1.8.0 新增
}
</code></pre> 
<ul><li><code>fade</code> 为 true 表示当滚动停止的时候滚动条是否需要渐隐，<code>interactive</code> 表示滚动条是否可以交互。 见 <a href="https://ustbhuangyi.github.io/better-scroll/#/examples/vertical-scroll/zh" rel="nofollow">Demo</a> 。了解更多的细节可以去看 example 中的 <a href="https://github.com/ustbhuangyi/better-scroll/blob/master/example/components/scroll/scroll.vue">scroll</a> 组件代码。<br> </li></ul> 
<h3><a id="pullDownRefresh_358"></a>pullDownRefresh</h3> 
<ul><li>类型：Boolean | Object</li><li>默认值：false</li><li>作用：这个配置用于做下拉刷新功能，默认为 false。当设置为 true 或者是一个 Object 的时候，可以开启下拉刷新，例如：</li></ul> 
<pre><code>pullDownRefresh: {
  threshold: 50,
  stop: 20
}
</code></pre> 
<ul><li>可以配置顶部下拉的距离（<code>threshold</code>） 来决定刷新时机以及回弹停留的距离（<code>stop</code>）。当下拉刷新数据加载完毕后，需要执行 <a href="http://ustbhuangyi.github.io/better-scroll/doc/zh-hans/api-specific.html#finishpulldown" rel="nofollow"><code>finishPullDown</code></a> 方法。见 <a href="https://ustbhuangyi.github.io/better-scroll/#/examples/vertical-scroll/zh" rel="nofollow">Demo</a> 。 了解更多的细节可以去看 example 中的 <a href="https://github.com/ustbhuangyi/better-scroll/blob/master/example/components/scroll/scroll.vue">scroll</a> 组件代码。<br> </li></ul> 
<h3><a id="pullUpLoad_372"></a>pullUpLoad</h3> 
<ul><li>类型：Boolean | Object</li><li>默认值：false</li><li>作用：这个配置用于做上拉加载功能，默认为 false。当设置为 true 或者是一个 Object 的时候，可以开启上拉加载，例如：</li></ul> 
<pre><code>pullUpLoad: {
  threshold: 50
}
</code></pre> 
<ul><li>可以配置离（<code>threshold</code>）来决定开始加载的时机。当上拉加载数据加载完毕后，需要执行 <a href="http://ustbhuangyi.github.io/better-scroll/doc/zh-hans/api-specific.html#finishpullup" rel="nofollow"><code>finishPullUp</code></a> 方法。见 <a href="https://ustbhuangyi.github.io/better-scroll/#/examples/vertical-scroll/zh" rel="nofollow">Demo</a> 。 了解更多的细节可以去看 example 中的 <a href="https://github.com/ustbhuangyi/better-scroll/blob/master/example/components/scroll/scroll.vue">scroll</a> 组件代码。<br> </li></ul> 
<h3><a id="mouseWheelv180_385"></a>mouseWheel(v1.8.0+)</h3> 
<ul><li>类型：Boolean | Object</li><li>默认值：false</li><li>作用：这个配置用于 PC 端的鼠标滚轮，默认为 false，。当设置为 true 或者是一个 Object 的时候，可以开启鼠标滚轮，例如：</li></ul> 
<pre><code>mouseWheel: {
 speed: 20,
 invert: false,
 easeTime: 300
}
</code></pre> 
<ul><li><code>speed</code> 表示鼠标滚轮滚动的速度，<code>invert</code> 为 true 表示滚轮滚动和时机滚动方向相反，<code>easeTime</code> 表示滚动动画的缓动时长，见<a href="https://ustbhuangyi.github.io/better-scroll/#/examples/free-scroll/zh" rel="nofollow">Demo</a>。<br> </li></ul> 
<h3><a id="zoomv1110_400"></a>zoom(v1.11.0+)</h3> 
<ul><li>类型：Boolean | Object</li><li>默认值：false</li><li>作用：这个配置用于对滚动内容的缩放，默认为 false。当设置为 true 或者是一个 Object 的时候，可以开启缩放，例如：</li></ul> 
<pre><code>zoom: {
 start: 1,
 min: 1,
 max: 4
}
</code></pre> 
<ul><li><code>start</code> 表示开始的缩放比例，<code>min</code> 表示最小缩放比例，<code>max</code> 表示最大缩放比例。<br> </li></ul> 
<h3><a id="infinityv1120_415"></a>infinity(v1.12.0+)</h3> 
<ul><li>类型：Boolean | Object</li><li>默认值：false</li><li>作用：该配置的使用场景是长列表滚动或者是无限滚动，默认为 false。如果开启需要配置成一个对象，实现 3 个函数，例如：</li></ul> 
<pre><code>infinity: {
  fetch(count) {
     // 获取大于 count 数量的数据，该函数是异步的，它需要返回一个 Promise。
     // 成功获取数据后，你需要 resolve 数据数组（也可以 resolve 一个 Promise）。
     // 数组的每一个元素是列表数据，在 render 方法执行的时候会传递这个数据渲染。
     // 如果没有数据的时候，你可以 resolve(false)，来告诉无限滚动列表已经没有更多数据了。
  }
  render(item, div) {
     // 渲染每一个元素节点，item 是数据，div 是包裹元素节点的容器。
     // 该函数需要返回渲染后的 DOM 节点。
  },
  createTombstone() {
    // 返回一个墓碑 DOM 节点。
  }
}
</code></pre> 
<ul><li>具体的示例代码可以<a href="https://github.com/ustbhuangyi/better-scroll/blob/master/example/pages/infinity.vue">参考这里</a>，对应的演示 <a href="https://ustbhuangyi.github.io/better-scroll/#/examples/infinity/zh" rel="nofollow">demo</a>。 infinity 的实现参考了<a href="https://www.jianshu.com/p/4e16b4211d84" rel="nofollow">这篇文章</a>，并在此基础上加入了滚动结束的能力。 注意：除非你有大量的数据渲染需求，否则使用普通的滚动即可。</li></ul> 
<p></p> 
<h2><a id="___443"></a>方法 / 通用</h2> 
<p>better-scroll 提供了很多灵活的 API，当我们基于 better-scroll 去实现一些 feature 的时候，会用到这些 API，了解他们会有助于开发更加复杂的需求。<br> </p> 
<h3><a id="refresh_446"></a>refresh()</h3> 
<ul><li>参数：无</li><li>返回值：无</li><li>作用：重新计算 better-scroll，当 DOM 结构发生变化的时候务必要调用确保滚动的效果正常。<br> </li></ul> 
<h3><a id="scrollTox_y_time_easing_452"></a>scrollTo(x, y, time, easing)</h3> 
<ul><li>参数： 
  <ul><li>{Number} x 横轴坐标（单位 px）</li><li>{Number} y 纵轴坐标（单位 px）</li><li>{Number} time 滚动动画执行的时长（单位 ms）</li><li>{Object} easing 缓动函数，一般不建议修改，如果想修改，参考源码中的 ease.js 里的写法</li></ul> </li><li>返回值：无</li><li>作用：滚动到指定的位置，见 <a href="https://ustbhuangyi.github.io/better-scroll/#/examples/vertical-scroll/zh" rel="nofollow">Demo</a> 。<br> </li></ul> 
<h3><a id="scrollByx_y_time_easing_462"></a>scrollBy(x, y, time, easing)</h3> 
<ul><li>参数： 
  <ul><li>{Number} x 横轴距离（单位 px）</li><li>{Number} y 纵轴距离（单位 px）</li><li>{Number} time 滚动动画执行的时长（单位 ms）</li><li>{Object} easing 缓动函数，一般不建议修改，如果想修改，参考源码中的 ease.js 里的写法</li></ul> </li><li>返回值：无</li><li>作用：相对于当前位置偏移滚动 x,y 的距离。<br> </li></ul> 
<h3><a id="scrollToElementel_time_offsetX_offsetY_easing_472"></a>scrollToElement(el, time, offsetX, offsetY, easing)</h3> 
<ul><li>参数： 
  <ul><li>{DOM | String} el 滚动到的目标元素, 如果是字符串，则内部会尝试调用 querySelector 转换成 DOM 对象。</li><li>{Number} time 滚动动画执行的时长（单位 ms）</li><li>{Number | Boolean} offsetX 相对于目标元素的横轴偏移量，如果设置为 true，则滚到目标元素的中心位置</li><li>{Number | Boolean} offsetY 相对于目标元素的纵轴偏移量，如果设置为 true，则滚到目标元素的中心位置</li><li>{Object} easing 缓动函数，一般不建议修改，如果想修改，参考源码中的 ease.js 里的写法</li></ul> </li><li>返回值：无</li><li>作用：滚动到指定的目标元素。<br> </li></ul> 
<h3><a id="stop_483"></a>stop()</h3> 
<ul><li>参数：无</li><li>返回值：无</li><li>作用：立即停止当前运行的滚动动画。<br> </li></ul> 
<h3><a id="enable_489"></a>enable()</h3> 
<ul><li>参数：无</li><li>返回值：无</li><li>作用：启用 better-scroll, 默认 开启。<br> </li></ul> 
<h3><a id="disable_495"></a>disable()</h3> 
<ul><li>参数：无</li><li>返回值：无</li><li>作用：禁用 better-scroll，DOM 事件（如 touchstart、touchmove、touchend）的回调函数不再响应。<br> </li></ul> 
<h3><a id="destroy_501"></a>destroy()</h3> 
<ul><li>参数：无</li><li>返回值：无</li><li>作用：销毁 better-scroll，解绑事件。<br> </li></ul> 
<h3><a id="ontype_fn_context_507"></a>on(type, fn, context)</h3> 
<ul><li>参数： 
  <ul><li>{String} type 事件名</li><li>{Function} fn 回调函数</li><li>{context} 函数执行的上下文环境，默认是 this</li></ul> </li><li>返回值：无</li><li>作用：监听当前实例上的<a href="http://ustbhuangyi.github.io/better-scroll/doc/zh-hans/events.html" rel="nofollow">自定义事件</a>。如：scroll, scrollEnd, pullingUp, pullingDown等。</li><li>示例：</li></ul> 
<pre><code>import BScroll from 'better-scroll'
let scroll = new BScroll('.wrapper')
function onScroll(pos) {
  console.log(`Now position is x: ${pos.x}, y: ${pos.y}`)
}
scroll.on('scroll', onScroll)
</code></pre> 
<p></p> 
<h3><a id="oncetype_fn_context_525"></a>once(type, fn, context)</h3> 
<ul><li>参数： 
  <ul><li>{String} type 事件名</li><li>{Function} fn 回调函数</li><li>{context} 函数执行的上下文环境，默认是 this</li></ul> </li><li>返回值：无</li><li>作用：监听一个自定义事件，但是只触发一次，在第一次触发之后移除监听器。<br> </li></ul> 
<h3><a id="offtype_fn_534"></a>off(type, fn)</h3> 
<ul><li>参数： 
  <ul><li>{String} type 事件名</li><li>{Function} fn 回调函数</li></ul> </li><li>返回值：无</li><li>作用：移除自定义事件监听器。只会移除这个回调的监听器。</li><li>示例：</li></ul> 
<pre><code>import BScroll from 'better-scroll'
let scroll = new BScroll('.wrapper', {
  pullUpLoad: true
})
function onPullingUp() {
  console.log('pullingup success!')
}
scroll.on('pullingUp', onPullingUp) // 添加pullingup事件回调onPullingUp
...
scroll.off('pullingUp', onPullingUp) // 移除pullingup事件回调onPullingUp
...
</code></pre> 
<br> 
<p></p> 
<h2><a id="___559"></a>方法 / 定制</h2> 
<p>better-scroll 还提供了一些定制的方法，专门用来实现某一个 feature 所用。<br> </p> 
<h3><a id="goToPagex_y_time_easing_562"></a>goToPage(x, y, time, easing)</h3> 
<ul><li>参数 
  <ul><li>{Number} x 横轴的页数</li><li>{Number} y 纵轴的页数</li><li>{Number} time 动画执行的时间</li><li>{Object} easing 缓动函数，一般不建议修改，如果想修改，参考源码中的 ease.js 里的写法</li></ul> </li><li>返回值：无</li><li>作用：当我们做 slide 组件的时候，slide 通常会分成多个页面。调用此方法可以滚动到指定的页面。<br> </li></ul> 
<h3><a id="nexttime_easing_572"></a>next(time, easing)</h3> 
<ul><li>参数： 
  <ul><li>{Number} time 动画执行的时间</li><li>{Object} easing 缓动函数，一般不建议修改，如果想修改，参考源码中的 ease.js 里的写法</li></ul> </li><li>返回值：无</li><li>作用：滚动到下一个页面<br> </li></ul> 
<h3><a id="prevtime_easing_580"></a>prev(time, easing)</h3> 
<ul><li>参数： 
  <ul><li>{Number} time 动画执行的时间</li><li>{Object} easing 缓动函数，一般不建议修改，如果想修改，参考源码中的 ease.js 里的写法</li></ul> </li><li>返回值：无</li><li>作用：滚动到上一个页面<br> </li></ul> 
<h3><a id="getCurrentPage_588"></a>getCurrentPage()</h3> 
<ul><li>参数：无</li><li>返回值：{Object} <code>{ x: posX, y: posY,pageX: x, pageY: y}</code> 其中，x 和 y 表示偏移的坐标值，pageX 和 pageY 表示横轴方向和纵轴方向的页面数。</li><li>作用：获取当前页面的信息。<br> </li></ul> 
<h3><a id="wheelToindex_594"></a>wheelTo(index)</h3> 
<ul><li>参数： 
  <ul><li>{Number} index 索引值</li></ul> </li><li>返回值：无</li><li>作用：当我们做 picker 组件的时候，调用该方法可以滚动到索引对应的位置。<br> </li></ul> 
<h3><a id="getSelectedIndex_601"></a>getSelectedIndex()</h3> 
<ul><li>参数：无</li><li>返回值：{Number} 当前选中的索引值。</li><li>作用：获取当前选中的索引值。<br> </li></ul> 
<h3><a id="finishPullDown_607"></a>finishPullDown()</h3> 
<ul><li>参数：无</li><li>返回值：无</li><li>作用：当下拉刷新数据加载完毕后，需要调用此方法告诉 better-scroll 数据已加载。<br> </li></ul> 
<h3><a id="openPullDownconfig_v190_613"></a>openPullDown(config) (v1.9.0+)</h3> 
<ul><li>参数： 
  <ul><li>{Object} config，参考 <code>pullDownRefresh</code> 的配置，默认为 true。</li></ul> </li><li>返回值：无</li><li>作用：动态开启下拉刷新功能。<br> </li></ul> 
<h3><a id="closePullDown_v190_620"></a>closePullDown() (v1.9.0+)</h3> 
<ul><li>参数：无</li><li>返回值：无</li><li>作用：动态关闭下拉刷新功能。<br> </li></ul> 
<h3><a id="autoPullDownRefresh_v1140_626"></a>autoPullDownRefresh() (v1.14.0)</h3> 
<ul><li>参数：无</li><li>返回值：无</li><li>作用：自动触发下拉刷新。<br> </li></ul> 
<h3><a id="finishPullUp_632"></a>finishPullUp()</h3> 
<ul><li>参数：无</li><li>返回值：无</li><li>作用：当上拉加载数据加载完毕后，需要调用此方法告诉 better-scroll 数据已加载。<br> </li></ul> 
<h3><a id="openPullUpconfig_v190_638"></a>openPullUp(config) (v1.9.0+)</h3> 
<ul><li>参数： 
  <ul><li>{Object} config，参考 <code>pullUpLoad</code> 的配置，默认为 true。</li></ul> </li><li>返回值：无</li><li>作用：动态开启上拉加载功能。<br> </li></ul> 
<h3><a id="closePullUp_v190_645"></a>closePullUp() (v1.9.0+)</h3> 
<ul><li>参数：无</li><li>返回值：无</li><li>作用：动态关闭上拉加载功能。<br> </li></ul> 
<h3><a id="zoomToscale_x_y_v1120_651"></a>zoomTo(scale, x, y) (v1.12.0+)</h3> 
<ul><li>参数: 
  <ul><li><code>{Number} scale</code>, 缩放大小.</li><li><code>{Number} x</code>, 缩放原点的横坐标, 相对于整个文档的左边距。</li><li><code>{Number} y</code>, 缩放原点的纵坐标, 相对于整个文档的上边距。</li></ul> </li><li>返回值: 无</li><li>作用: 将滚动体缩放到指定的大小。</li></ul> 
<br> 
<p></p> 
<h2><a id="_664"></a>事件</h2> 
<p>better-scroll 除了提供了丰富的 API 调用，还提供了一些事件，方便和外部做交互。你可以利用他们实现一些更高级的 feature。<br> </p> 
<h3><a id="beforeScrollStart_667"></a>beforeScrollStart</h3> 
<ul><li>参数：无</li><li>触发时机：滚动开始之前。<br> </li></ul> 
<h3><a id="scrollStart_672"></a>scrollStart</h3> 
<ul><li>参数：无</li><li>触发时机：滚动开始时。<br> </li></ul> 
<h3><a id="scroll_677"></a>scroll</h3> 
<ul><li>参数：{Object} {x, y} 滚动的实时坐标</li><li>触发时机：滚动过程中，具体时机取决于选项中的 <a href="http://ustbhuangyi.github.io/better-scroll/doc/zh-hans/options.html#probetype" rel="nofollow">probeType</a>。<br> </li></ul> 
<h3><a id="scrollCancel_682"></a>scrollCancel</h3> 
<ul><li>参数：无</li><li>触发时机：滚动被取消。<br> </li></ul> 
<h3><a id="scrollEnd_687"></a>scrollEnd</h3> 
<ul><li>参数：{Object} {x, y} 滚动结束的位置坐标</li><li>触发时机：滚动结束。<br> </li></ul> 
<h3><a id="touchEnd_692"></a>touchEnd</h3> 
<ul><li>参数：{Object} {x, y} 位置坐标</li><li>触发时机：鼠标/手指离开。<br> </li></ul> 
<h3><a id="flick_697"></a>flick</h3> 
<ul><li>参数：无</li><li>触发时机：轻拂时。<br> </li></ul> 
<h3><a id="refresh_702"></a>refresh</h3> 
<ul><li>参数: 无</li><li>触发时机：refresh 方法调用完成后。<br> </li></ul> 
<h3><a id="destroy_707"></a>destroy</h3> 
<ul><li>参数：无</li><li>触发时机：destroy 方法调用完成后。<br> </li></ul> 
<h3><a id="pullingDown_712"></a>pullingDown</h3> 
<ul><li>参数：无</li><li>触发时机：在一次下拉刷新的动作后，这个时机一般用来去后端请求数据。<br> </li></ul> 
<h3><a id="pullingUp_717"></a>pullingUp</h3> 
<ul><li>参数：无</li><li>触发时机：在一次上拉加载的动作后，这个时机一般用来去后端请求数据。<br> </li></ul> 
<h3><a id="zoomStart_722"></a>zoomStart</h3> 
<ul><li>参数：无</li><li>触发时机：缩放开始时。<br> </li></ul> 
<h3><a id="zoomEnd_727"></a>zoomEnd</h3> 
<ul><li>参数：无<br> </li></ul> 
<h2><a id="_731"></a>属性</h2> 
<p>有时候我们想基于 better-scroll 做一些扩展，需要对 better-scroll 的一些属性有所了解，下面介绍几个常用属性。<br> </p> 
<h3><a id="x_734"></a>x</h3> 
<ul><li>类型：Number</li><li>作用：scroll 横轴坐标。<br> </li></ul> 
<h3><a id="y_739"></a>y</h3> 
<ul><li>类型：Number</li><li>作用：scroll 纵轴坐标。<br> </li></ul> 
<h3><a id="maxScrollX_744"></a>maxScrollX</h3> 
<ul><li>类型：Number</li><li>作用：scroll 最大横向滚动位置。</li><li>备注：scroll 横向滚动的位置区间是 0 - maxScrollX，并且 maxScrollX 是负值。<br> </li></ul> 
<h3><a id="maxScrollY_750"></a>maxScrollY</h3> 
<ul><li>类型：Number</li><li>作用：scroll 最大纵向滚动位置。</li><li>备注：scroll 纵向滚动的位置区间是 0 - maxScrollY，并且 maxScrollY 是负值。<br> </li></ul> 
<h3><a id="movingDirectionX_756"></a>movingDirectionX</h3> 
<ul><li>类型：Number</li><li>作用：判断 scroll 滑动过程中的方向（左右）。</li><li>备注：-1 表示从左向右滑，1 表示从右向左滑，0 表示没有滑动。<br> </li></ul> 
<h3><a id="movingDirectionY_762"></a>movingDirectionY</h3> 
<ul><li>类型：Number</li><li>作用：判断 scroll 滑动过程中的方向（上下）。</li><li>备注：-1 表示从上往下滑，1 表示从下往上滑，0 表示没有滑动。<br> </li></ul> 
<h3><a id="directionX_768"></a>directionX</h3> 
<ul><li>类型：Number</li><li>作用：判断 scroll 滑动结束后相对于开始滑动位置的方向（左右）。</li><li>备注：-1 表示从左向右滑，1 表示从右向左滑，0 表示没有滑动。<br> </li></ul> 
<h3><a id="directionY_774"></a>directionY</h3> 
<ul><li>类型：Number</li><li>作用：判断 scroll 滑动结束后相对于开始滑动位置的方向（上下）。</li><li>备注：-1 表示从上往下滑，1 表示从下往上滑，0 表示没有滑动。<br> </li></ul> 
<h3><a id="enabled_780"></a>enabled</h3> 
<ul><li>类型：Boolean,</li><li>作用：判断当前 scroll 是否处于启用状态。<br> </li></ul> 
<h3><a id="isInTransition_785"></a>isInTransition</h3> 
<ul><li>类型：Boolean,</li><li>作用：判断当前 scroll 是否处于滚动动画过程中。</li><li>备注：当开启 CSS3 Transition 动画时判断该值。<br> </li></ul> 
<h3><a id="isAnimating_791"></a>isAnimating</h3> 
<ul><li>类型：Boolean,</li><li>作用：判断当前 scroll 是否处于滚动动画过程中。</li><li>备注：当开启 JS Animation 动画时判断该值。</li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/fadbf12a45deefc060e13ca182cbb122/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">数位统计DP-计数问题</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3d725b2da6797a613b5ae7d9a07a125a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">openwrt luci 实现框架</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>