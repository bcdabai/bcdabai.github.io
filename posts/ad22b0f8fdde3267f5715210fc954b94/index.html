<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>HashMap1.7和1.8的区别 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="HashMap1.7和1.8的区别" />
<meta property="og:description" content="HashMap1.7和1.8的区别 1.JDK1.7用的是头插法，而JDK1.8及之后使用的都是尾插法 那么为什么要这样做呢？因为JDK1.7是用单链表进行的纵向延伸，当采用头插法时，再多线程环境下并发扩容的时候，会容易出现环形链表死循环问题。但是在JDK1.8之后使用尾插法，能够避免出现逆序且链表死循环的问题。
2.扩容流程不同： 1.8是扩容前插入键值，连同旧的键值一起转移，一起计算，1.7是扩容后，扩容后进行插入，旧数据转移到新的数组之后，然后再单独计算插入的位置。为什么1.8是插入之后再整体计算扩容，主要是为了减少红黑树和链表来回转换的频率
3.扩容后数据存储位置的计算方式也不一样： 要说清楚这个，先得说说HASHMAP如何求桶的位置
HashMap求桶的位置一共分为三个过程：
1）求key的hashcode 2）将hashcode的高16位和低16位进行异或操作。
至此我们完成了hash方法，求得了该元素的hash值。源码在下方
static final int hash(Object key) { int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16); } 3）(n - 1) &amp; hash ，将hash值与length-1进行与操作，求桶的位置
if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); 无论是JDK7还是JDK8，HashMap的扩容都是每次扩容为原来的两倍，即会产生一个新的数组newtable，我们需要把原来数组中的元素全部放到新的只不过元素求桶的位置的方法不太一样。
在JDK7中就是按照我上述写的三个步骤重新对元素求桶的位置，但是第三步与的值是新的数组的长度-1，也就是newCap-1。
但是JDK8中就不是和newCap，而是直接和oldCap进行与运算，也就是与旧数组的长度（oldCap）进行与操作。下面的是伪代码：
if ((e.hash &amp; oldCap) == 0) { newTab[j] = loHead; }else{ ​ newTab[j &#43; oldCap] = hiHead; } 与oldCap与的结果如果是0，那么就代表当前元素的桶位置不变。 反之，那么扩容后桶的位置就是原位置&#43;原数组长度（oldCap）" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/ad22b0f8fdde3267f5715210fc954b94/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-19T23:38:48+08:00" />
<meta property="article:modified_time" content="2024-01-19T23:38:48+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">HashMap1.7和1.8的区别</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>HashMap1.7和1.8的区别</h3> 
<p></p> 
<h5>1.JDK1.7用的是头插法，而JDK1.8及之后使用的都是尾插法</h5> 
<p>那么为什么要这样做呢？因为JDK1.7是用单链表进行的纵向延伸，当采用头插法时，再多线程环境下并发扩容的时候，会容易出现环形链表死循环问题。但是在JDK1.8之后使用尾插法，能够避免出现逆序且链表死循环的问题。</p> 
<h5>2.扩容流程不同：</h5> 
<p>1.8是扩容前插入键值，连同旧的键值一起转移，一起计算，1.7是扩容后，扩容后进行插入，旧数据转移到新的数组之后，然后再单独计算插入的位置。为什么1.8是插入之后再整体计算扩容，主要是为了减少红黑树和链表来回转换的频率</p> 
<h5>3.扩容后数据存储位置的计算方式也不一样：</h5> 
<p>要说清楚这个，先得说说HASHMAP如何求桶的位置</p> 
<p>HashMap求桶的位置一共分为三个过程：</p> 
<p>1）求key的hashcode 2）将hashcode的高16位和低16位进行异或操作。</p> 
<p>至此我们完成了hash方法，求得了该元素的hash值。源码在下方</p> 
<pre>static final int hash(Object key) {
    int h;
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);
}</pre> 
<p>3）(n - 1) &amp; hash ，将hash值与length-1进行与操作，求桶的位置</p> 
<pre> if ((p = tab[i = (n - 1) &amp; hash]) == null)
            tab[i] = newNode(hash, key, value, null);</pre> 
<p>无论是JDK7还是JDK8，HashMap的扩容都是每次扩容为原来的两倍，即会产生一个新的数组newtable，我们需要把原来数组中的元素全部放到新的只不过元素求桶的位置的方法不太一样。</p> 
<p>在JDK7中就是按照我上述写的三个步骤重新对元素求桶的位置，但是第三步与的值是新的数组的长度-1，也就是newCap-1。</p> 
<p>但是JDK8中就不是和newCap，而是直接和oldCap进行与运算，也就是与旧数组的长度（oldCap）进行与操作。下面的是伪代码：</p> 
<pre>if ((e.hash &amp; oldCap) == 0) {
newTab[j] = loHead;
}else{
​
newTab[j + oldCap] = hiHead;
}</pre> 
<p>与oldCap与的结果如果是0，那么就代表当前元素的桶位置不变。 反之，那么扩容后桶的位置就是原位置+原数组长度（oldCap）</p> 
<h5>4.数据结构不同</h5> 
<p>JDK1.7的时候使用的是数组+ 单链表的数据结构。但是在JDK1.8及之后时，使用的是数组+链表+红黑树的数据结构（当链表的深度达到8的时候，也就是默认阈值，就会自动扩容把链表转成红黑树的数据结构来把时间复杂度从O（n）变成O（logN）提高了效率），小于6的时候，又会转换为链表。为什么是8，容器中节点分布在hash桶中的频率遵循泊松分布，桶的长度超过8的概率非常非常小。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/28be20cd23177f0b91e49019113e313d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【机器学习】强化学习（四）-时序差分学习</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c47c06a96ed23aa4524e3ff18955a557/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Spring注解驱动开发之常用注解案例_告别在XML中配置Bean</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>