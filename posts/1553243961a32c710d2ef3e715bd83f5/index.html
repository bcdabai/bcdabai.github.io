<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>方法练习2 - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="方法练习2" />
<meta property="og:description" content="1. 用户输入一个数，求对应数的阶乘(考虑数据延展性)
/* 1. 求15的阶乘 数据在运行过程中，演变过程，以及数据当前情况和储存数据类型是否能支持 15的阶乘 int 类型结果显然不对 要考虑数据的演变过程 尤其是数据在整个变化过程中，增长性极大 */ /* 封装方法小技巧 1. 一框 找核心代码 2. 二看 上看找参数 找出核心代码块中未定义的变量，在核心代码之外定义，该变量就是方法参数 下看找返回 直接考虑删除核心代码，如果代码可以正常运行，正常编译，当前方法没有返回值，如果 已经不具备正常运行，正常编译情况，当前方法有返回值，注意必要数据的类型 3. 三封装 完成方法声明，剪切核心代码到方法体中，同时根据所需，补充 return 语句。如果没有返回值 无需补充。 正常使用，调用操作 方法分析： 参数: (int num) 返回值类型: double 方法名: factorial 方法声明: public static double factorial(int num) */ class Demo1 { public static void main(String[] args) { int num = 10; double ret = factorial(num); System.out.println(ret); } /** * 计算用户指定数据的阶乘结果 * * @param num 用户指定阶乘所需数据， int 类型 * @return 考虑数据的延展性和后期的拓展情况，返回值类型选择 double 类型 */ public static double factorial (int num) { double ret = 1; for (int i = 1; i &lt;= num; i&#43;&#43;) { ret *= i; }	return ret; } } 2." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcdabai.github.io/posts/1553243961a32c710d2ef3e715bd83f5/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-01-18T22:51:00+08:00" />
<meta property="article:modified_time" content="2022-01-18T22:51:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">方法练习2</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>1. 用户输入一个数，求对应数的阶乘(考虑数据延展性)</p> 
<pre><code class="language-java">/*
1. 求15的阶乘
数据在运行过程中，演变过程，以及数据当前情况和储存数据类型是否能支持
15的阶乘 int 类型结果显然不对

要考虑数据的演变过程
尤其是数据在整个变化过程中，增长性极大
*/ 

/*
封装方法小技巧
	1. 一框 
		找核心代码
	2. 二看
		上看找参数
			找出核心代码块中未定义的变量，在核心代码之外定义，该变量就是方法参数
		下看找返回
			直接考虑删除核心代码，如果代码可以正常运行，正常编译，当前方法没有返回值，如果
			已经不具备正常运行，正常编译情况，当前方法有返回值，注意必要数据的类型
	3. 三封装
		完成方法声明，剪切核心代码到方法体中，同时根据所需，补充 return 语句。如果没有返回值
		无需补充。
		正常使用，调用操作
		
方法分析：
	参数:
		(int num)
	返回值类型:
		double
	方法名:
		factorial

方法声明:
	public static double factorial(int num)
*/
class Demo1 {
	public static void main(String[] args) {
		int num = 10;
		
		double ret = factorial(num);
		System.out.println(ret);
		
	}
	
	/**
	* 计算用户指定数据的阶乘结果
	*
	* @param num 用户指定阶乘所需数据， int 类型
	* @return 考虑数据的延展性和后期的拓展情况，返回值类型选择 double 类型
	*/
	public static double factorial (int num) {
		double ret = 1;
		for (int i = 1; i &lt;= num; i++) {
			ret *= i; 
		}	
		return ret;
	}
}</code></pre> 
<p><br> 2. 完成30位以内的斐波那契数列<br>     1 1 2 3 5 8 13 21 34 55 89 144 ...</p> 
<pre><code class="language-java">class Demo2 {
	public static void main(String[] args) {
		int count = 10;
		fibonacci(count);
	}

    /**
	* 根据用户指定的斐波那契数列的数据个数，展示斐波那契数列
	*
	* @param count 用户指定的数据个数
	*/	
	public static void fibonacci(int count) {
		double num1 = 1;
		double num2 = 1;
		
		System.out.println(num1);
		System.out.println(num2);
		
		for (int i = 1; i &lt;= count; i++) {
			// 保存当前 num2 存储数据
			double temp = num2;
			
			// 计算新数据内容
			num2 += num1;
			
			// 展示新数据情况
			System.out.println(num2);
			
			// num1 赋值为原本 num2 存储数据
			num1 = temp;
		}
	}
}</code></pre> 
<p><br> 3. 分解质因数<br>     例如:<br>         30 ==&gt; 2 * 3 * 5<br>         90 ==&gt; 2 * 3 * 3 * 5<br>         40 ==&gt; 2 * 2 * 2 * 5<br>     核心:<br>         如果当前目标数据可以被某一个素数整除之后，需要再次确认当前素数是否可以继<br>         续整除目标数据<br>         素数作为循环变量</p> 
<pre><code class="language-java">/*
分解质因数
	例如:
		30 ==&gt; 2 * 3 * 5
		90 ==&gt; 2 * 3 * 3 * 5
		40 ==&gt; 2 * 2 * 2 * 5
	核心:
		如果当前目标数据可以被某一个素数整除之后，需要再
		次确认当前素数是否可以继续整除目标数据
		素数作为循环变量
		
		素数/质数：除本身和1之外，不可以被其他整数整除
*/

class Demo3 {
	public static void main(String[] args) {
		int num = 90;
		
		prime(num);
	}
	
	/**
	* 分解用户指定数据对应质因数
	*
	* @param num 用户指定分解使用数据，为 int 类型
	*/
	public static void prime(int num) {
		//for 循环控制分解质因数操作
		for (int i = 2; i &lt;= num; i++) {
			//分解质因数成功
			if (num % i == 0){
				//展示质因数
				System.out.println(i);
				//num 存储数据除以当前质因数
				num /= i;
				
				/*
				考虑到 for 循环第三个条件，不断的累加变量
				如果当前 i 可以整除 num 存储数据，需要二次验证当前 i 对应数据
				是否为 num 目前情况的质因数，【抵消】i++，if 大括号中进行 i--
				*/
				
				i--;
			}
		}
	}
}</code></pre> 
<p><br> 4. <br>    *****<br>    *****<br>    *****<br>    *****<br>    *****</p> 
<pre><code class="language-java">class Demo4 {
	public static void main(String[] args) {
		// 可以利用一个变量，控制循环中核心数据，增强代码的普适性
		int line = 5;
		
		pic1(line);
	}
	
	/**
	* 根据用户指定的行数，展示正方形星星图案
	* 
	* @param line 用户指定的总行数
	*/
	public static void pic1(int line) {
		for (int i = 1; i &lt;= line; i++) {
			// for - j 控制每一行完成的任务 星星个数 ==&gt; 总行数
			for (int j = 1; j &lt;= line; j++) {
				System.out.print("*");
			}
			
			System.out.println(); // 无内容展示，单纯使用 println 换行能力
		}
	}
}</code></pre> 
<p><br> 5.<br>   *<br>   **<br>   ***<br>   ****<br>   *****</p> 
<pre><code class="language-java">class Demo5 {
	public static void main(String[] args) {
		int line = 5;
		
		pic2(line);
	}
	
	/**
	* 根据用户指定的行数，展示一个等边直角三角形
	*
	* @param line 用户指定的总行数
	*/
	public static void pic2(int line) {
		for (int i = 1; i &lt;= line; i++) {
			// for - j 循环。控制每一行的星星个数，每一行星星个数 ==&gt; 循环变量当前 i 存储的数据
			// i 值作为内层循环的执行次数
			for (int j = 1; j &lt;= i; j++) {
				System.out.print("*");
			}
			
			System.out.println();
		}
	}
}</code></pre> 
<p><br> 6.   <br>       *<br>      ***<br>     *****<br>    *******<br>   *********</p> 
<pre><code class="language-java">class Demo6 {
	public static void main(String[] args) {
		int line = 5;
		pic3(line);
		
	}
	
	public static void pic3(int line) {
		// for - i 控制总行数，目前总行数为 5
		for (int i = 1; i &lt;= line; i++) {
			// for - j 控制每一行 空格 个数，总行数 - 当前是第几行
			for (int j = 1; j &lt;= line - i; j++) {
				System.out.print(' ');
			}
			
			// for - k 控制每一行的星星个数，2 * 当前是第几行 - 1
			for (int k = 1; k &lt;= 2 * i - 1; k++) {
				System.out.print('*');
			}
			
			System.out.println();
		}
	}
}</code></pre> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c7f76e35c1c281ec78482c528ad6b7bd/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">R语言入门（3）-内置数据集</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0589783d695a7652213125e17817f0bd/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">查找算法总结</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>