<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a76bf46359a8a57b0e0b0231bbb21368/" rel="bookmark">
			山威导航最短路径
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目
第五章 图
图是一种较线性表和树更为复杂的数据结构，也是日常生活中应用广泛的结构之一。在线性表中，数据元素之间仅仅有线性关系，每个数据元素只有一个直接前驱和一个直接后继；在树形结构中，数据元素之间有着明显的层次关系，并且每一层上的数据元素可能和下一层中多个元素（即其孩子结点）相关，但只能和上一层中的一个元素（即其双亲结点相关）；而在图形结构中，结点之间的关系可以是任意的，图中任意两个数据元素之间都可能相关。由此，图的应用极为广泛，特别是近年来的迅速发展，已渗入到诸如语言学、逻辑学、物理、化学、电讯工程、计算机科学以及数学的其他分支中。
5.2 导航最短路径查询
5.2.1 项目简介
设计一个交通咨询系统，能让旅客咨询从任一个城市顶点到另一个城市顶点之间的最短路径问题。设计分三个部分，一是建立交通网络图的存储结构；二是解决单源最短路径问题；最后再实现两个城市顶点之间的最短路径问题。
最短路径问题的提出随着计算机的普及以及地理信息科学的发展，GIS因其强大的功能得到日益广泛和深入的应用。网络分析作为GIS最主要的功能之一，在电子导航、交通旅游、城市规划以及电力、通讯等各种管网、管线的布局设计中发挥了重要的作用。而网络分析中最基本和关键的问题是最短路径问题。
最短路径不仅仅指一般地理意义上的距离最短，还可以引申到其他的度量，如时间、费用、线路容量等。相应地，最短路径问题就成为最快路径问题、最低费用问题等。由于最短路径问题在实际中常用于汽车导航系统以及各种应急系统等（110报警、119火警以及医疗救护系统），这些系统一般要求计算出到出事地点的最佳路线的时间一般在1s-3s，在行车过程中还需要实时计算出车辆前方的行驶路线，这就决定了最短路径问题的实现应该是高效率的。最优路径问题不仅包括最短路径问题，还有可能涉及到最少时间问题、最少收费（存在收费公路）问题、或者是几个问题的综合，这时将必须考虑道路级别、道路流量、道路穿越代价（如红灯平均等待时间）等诸多因素。但是必须指出的是，一般来说最优路径在距离上应该是最短的，但最短路径在行驶时间和能源消耗的意义上未必是最优的。其实，无论是距离最短、时间最快还是费用最低，它们的核心算法都是最短路径算法。
5.2.2 设计思路
单源最短路径算法的主要代表之一是Dijkstra（迪杰斯特拉）算法。该算法是目前多数系统解决最短路径问题采用的理论基础，在每一步都选择局部最优解，以期望产生一个全局最优解。
Dijksira算法的基本思路是：对于图G=(V,E)，V是包含n个顶点的顶点集，E是包含m条弧的弧集，(v, w)是E中从v到w的弧，c(v, w)是弧(v, w)的非负权值，设s为V中的顶点，t为V中可由s到达的顶点，则求解从s至t的具有最小弧权值和的最短路径搜索过程如下：
(1) 将v中的顶点分为3类：已标记点、未标记点、己扫描点。将s初始化为己标记点，其它顶点为未标记点。为每个顶点v都建立一个权值d和后向顶点指针p，并将d初始化如下：d(v)=0，v=s；d(v)=∞，v≠s。
(2) 重复进行扫描操作：从所有已标记点中选择一个具有最小权值的顶点v并将其设为己扫描点，然后检测每个以v为顶点的弧(v, w)，若满足d(v) + c(v, w) &lt; d(w) 则将顶点v设为已标记点，并令d(w) = d(v) + c(v, w), p(w) = v。
(3) 若终点t被设为已扫描点，则搜索结束。由t开始遍历后向顶点指针P直至起点s，即获得最短路径解。
5.2.3 数据结构
（1）定义一个数组min_dist，它的每个数组元素min_dist[i]表示当前所找到的从始点vi到每个终点vj的最短路径的长度。它的初态为：若从vi到vj有边，则min_dist[j]为边的权值；否则置min_dist[i]为∞。定义一个数组path，其元素path[k]（0≤k≤n-1）用以记录vi到vk最短路径中vk的直接前驱结点序号，如果vi到vk存在边，则path[k]初值为i。定义一个数组W，存储任意两点之间边的权值。
（2）查找min(min_dist[j]，j∈V-S)，设min_dist[k]最小，将k加入S中。修改对于V-S 中的任一点vj，min_dist[j]=min(min_dist[k]+w[k][j], min_dist[j]) 且path[j]=k。
（3）重复上一步，直到V-S为空。
在算法设计时，用一个tag数组来记录某个顶点是否已计算过最短距离，如果tag[k]=0，则vk∈V-S，否则vk∈S。初始值除tag[i]=1以外，所有值均为0。
功能展示：
6号楼到荟园忘记画在图上了 是190m
代码
Form1.cs
using System; using System.Collections; using System.Collections.Generic; using System.ComponentModel; using System.Data; using System.Drawing; using System.Linq; using System.Text; using System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a76bf46359a8a57b0e0b0231bbb21368/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b457b6bd4338337a6f324e96a09d607/" rel="bookmark">
			JS使用 Math.random() 生成随机数的方法汇总（不同范围、类型的随机数）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随机浮点数生成 1. 生成 [ 0, 1 ) 范围内的随机数（大于等于0，小于1） 使用 random() 方法可以返回一个介于 0 ~ 1 之间的伪随机数（包括 0，不包括 1）。
Math.random() 下面是一个测试样例
let random = Math.random(); console.log(random); 2. 生成 [ n, m ) 范围内的随机数（大于等于n，小于m） 这种最简单，因为和 random 的特点保持一致。只需使用如下公式即可：
Math.random()*(m-n)+n 比如下面生成 [10,15) 范围内的随机浮点数。
let random1 = Math.random()*(15-10)+10; let random2 = Math.random()*(15-10)+10; let random3 = Math.random()*(15-10)+10; console.log(random1); console.log(random2); console.log(random3); 3. 生成 [n,m]、(n,m)、(n,m] 范围内的随机数 因为 random 的特点，要取得这几个区间内的浮点数稍微麻烦些，需要借助一些判断才能满足要求。
//取得[n,m]范围随机数 function fullClose(n,m) { let result = Math.random()*(m+1-n)+n; while(result&gt;m) { result = Math.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3b457b6bd4338337a6f324e96a09d607/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29003da5f896c800cfffcd0c1c52c6a2/" rel="bookmark">
			Postman实现接口的加密和解密
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 近期在复习Postman的基础知识，在小破站上跟着百里老师系统复习了一遍，也做了一些笔记，希望可以给大家一点点启发。
1、目前市面上的加密的方式 对称式加密：DES，AES，Base64加密算法
非对称加密：双钥（公钥和私钥，【公钥加密，私钥解密】，【私钥加密，公钥解密】）加密，RSA加密算法 (BEJSON网址可用）
不考虑解密：MD5，SHA1，SHA3
2、Postman如何实现加密和解密 MD5最广泛。以加密密码为例，主要用到了CryptoJS 及 Pre-request Script，CryptoJS 是一个使用 JavaScript 实现的加密算法库，它支持的算法包含：
Base64MD5SHA-1 和 SHA-256AESRabbitMARC4HMAC、HMAC-MD5、HMAC-SHA1、HMAC-SHA256PBKDF2 在 Postman 中有一个 Tab 「 Pre-request Script 」，它能在请求之前做一些预处理
比如，可以使用 CryptoJS 先对变量进行加密，然后设置到变量中，最后在真实请求时使用这个变量
今天的分享就到这里，下期见。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/409c79a86298b26f115be6c0bc983ffd/" rel="bookmark">
			Unity关于MlAgent的安装中出现的问题与解决方案分享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		unity的MLAgent其实已经推出有段时间了，但是奇怪的是在安装的时候明明按照教程一步步来的还是会出现很多教程上没有的问题。
1.第一个问题就是python的版本问题导致后面进行训练是无法连接，我的版本是3.10.x的教程上说3.6.x以上的版本都行，其实不行，3.9.x以上的都不兼容，所以我们需要下载python3.8.x的版本然后在创建虚拟环境时指定用python3.8.x版本的创建，这样就可以解决numpy中的wheel问题。
问题描述：TypeError: CCompiler_spawn() got an unexpected keyword argument 'env' [end of output] note: This error originates from a subprocess, and is likely not a problem with pip. ERROR: Failed building wheel for numpy
Failed to build numpy ERROR: Could not build wheels for numpy, which is required to install pyproject.toml-based projects
创建命令行如下：
py -3.8 -m venv 你的虚拟环境的名字 你的虚拟环境的名字/Scripts/activate python install torch python install mlagents 在创建好了后还需要将protobuf包的版本降低以兼容python版本，降低到3.20.x即可。 最后还要install一个packaging包，然后就可以运行官方给的模板训练了。 mlagents-learn --help 成功运行help命令行后的界面：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/409c79a86298b26f115be6c0bc983ffd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f5a42f01e217c1ac98633d555814c6b/" rel="bookmark">
			【函数】各种函数收集，持续更新~
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 各种函数收集，持续更新~1. 数组对象去重2. 时间转换函数3. 深拷贝4. js精度问题解决（加减乘除）5. toFiexed函数重写6.手机号校验与隐藏手机号中间4位7. 身份证号校验与加密+校验位检测+15位转18位身份证8. 千位符格式化（123,456） 各种函数收集，持续更新~ 1. 数组对象去重 使用reduce,自己看着改
let arr = [ {id: 1, name: '周瑜'}, {id: 3, name: '王昭君'}, {id: 2, name: '亚瑟'}, {id: 1, name: '小乔'}, {id: 2, name: '大桥'}, {id: 3, name: '韩信'} ]; let obj = {} arr = arr.reduce((preVal,curVal) =&gt; { obj[curVal.id] ? "" : obj[curVal.id] = preVal.push(curVal) return preVal },[]) console.log(arr) 2. 时间转换函数 第一个参数是输入的时间，标准格式或时间戳格式都可
第二个参数是输出的样子，要啥写啥样，全部是这样 ‘yyyy-MM-dd hh:mm:ss’
export function formatDate(t, format='yyyy-MM-dd') { if(t==''||t&lt;=0||t==null||t=='null'){ return ''; } if(typeof t == 'string'){ t = t.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6f5a42f01e217c1ac98633d555814c6b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd165f0bc115ebfc33a2d373bf1efd84/" rel="bookmark">
			类加载器（classloader）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：ZeaTalk
链接：https://www.zhihu.com/question/49667892/answer/690161827
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
类加载器（classloader） 先从类加载器说起，凡事先问是什么，首先什么是类加载器？
我们知道，一个 *.java 的代码源文件要执行起来之前，必须通过 javac 构建抽象语法树并编译成字节码，字节码仍然是不能被机器所识别，那么一个 .class 文件要被机器识别并执行的前提就是将字节码转化成机器码加载到内存里，这一转化过程就是类加载的执行过程。
当然，这整个过程细节并非这个问题的讨论重点。
类加载器便是在在这个过程里的加载阶段起作用，负责将 .class 文件字节码提取出来，转化成二进制字节流。
（但是这离成为真正的类还有十万八千里。。。）
一个Java应用中通常存在三个类加载器（Classloader）：
Bootstrap Classloader 启动类加载器：负责加载&lt;JRE&gt;/lib 下的核心类库，此加载器本身内嵌于JVM，在 Java 中找不到具体的引用；Extension Classloader 扩展类加载器：负责加载&lt;JRE&gt;/lib/ext 下的扩展类库；Application Classloader 系统应用类加载器：负责-classpath 指定路径类库加载。 他们三者并非典型的继承关系，而是子指派父为自己的 parent。
（这里有个源码细节，由于启动类加载器是内嵌于 JVM 且无法被引用，因此 Extension Classloader 指派 parent 为 null，即等同于指派启动类加载器为自己的父加载器）
为了有足够灵活性，类加载器也是允许自定义的。这不禁思考，这么多类加载器之间是怎么协调类加载任务的？
这就引出了本文的重点，双亲委派模型。
双亲委派（parents deletation model） 双亲委派模型是什么？
The Java platform uses a delegation model for loading classes. The basic idea is that every class loader has a "parent" class loader.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bd165f0bc115ebfc33a2d373bf1efd84/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04af1776978d0dd045cbb10ed3b1b38c/" rel="bookmark">
			MATLAB的各种疑难杂症和小技巧
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		（￣△￣；）这里是目录 使用技巧如何更改启动后的默认工作路径方法一方法二 AVL Cruise与Simulink联合仿真（通过MATLAB DLL方式）1.AVL Cruise与Simulink联合仿真的不同方式及各自优缺点1.1MATLAB DLL方式1.2MATLAB API方式 2.DLL联合仿真MATLAB配置过程2.1在MATLAB里安装编译器2.2在MATLAB中安装DLL的必要文件并设置编译器 3 AVL Cruise和MATLAB DLL联合仿真时快速生成Simulink模型的方法4.Simulink编译DLL文件5.联合仿真 使用技巧 如何更改启动后的默认工作路径 方法一 打开MATLAB后，点击设置路径：
点击添加文件夹然后选择一个你要加入的路径，例如我这里选择的是桌面：
选中添加的路径后，点击移至顶端再点击保存，重新启动MATLAB后默认工作路径修改完成：
方法二 在你打开MATLAB的地方，右键单击图标，选择属性并打开（如果是开始菜单里的，则要先点击打开文件位置）：
在弹出来的界面中，把起始位置改成你想要改为的默认工作路径后点击确定，再次启动MATLAB即可变为新的工作路径：
AVL Cruise与Simulink联合仿真（通过MATLAB DLL方式） 最近毕业设计需要用到AVL Cruise与Simulink进行联合仿真，分析汽车模型的经济性。下面介绍一下我所知的AVL Cruise与Simulink联合仿真的几种方式，它们各自的优缺点，以及DLL方式联合仿真的具体配置过程。我这里用的MATLAB软件版本是2021a，Cruise软件版本是2019.2，电脑操作系统是Windows11。
1.AVL Cruise与Simulink联合仿真的不同方式及各自优缺点 1.1MATLAB DLL方式 该方式是先把SImulink中建立的模型编译成一个DLL文件，之后把这个文件内嵌到Cruise软件中作为一个模块，并进行仿真的方法。
优点：因为是内嵌到Cruise软件中了，因此运行时不需要调用Simulink，运行速度非常快，且是由Simulink模型编译生成的dll文件，在Cruise软件里看不到具体的模型是如何搭建的，比较保密，不会泄露控制模型信息。
缺点：同样是因为内嵌到Cruise软件中了，因此运行时无法实时查看模型内部的参数，不适用于调试Simulink控制模型，因为改一点模型就需要编译一次dll文件，且无法有效的定位模型中出错的地方。
1.2MATLAB API方式 该方式是Cruise在前台，处于主要地位，联合仿真时打开对应的Simulink模型，由Cruise向Simulink发送必要的参数以及指令，在Simulink中完成计算后把结果返回到Cruise中，继续进行下一步。该方法和DLL方法的优缺点正好反过来了。
优点：可以实时查看Simulink模型中的参数变化，便于调试，更改模型后不需要重新编译dll文件就能进行联合仿真。
缺点：没有内嵌到Cruise模型中，运行时需要实时调用Simulink，因此运行速度极慢无比，且必须要拿到Simulink控制模型源文件才能进行联合仿真，容易泄露信息。
2.DLL联合仿真MATLAB配置过程 2.1在MATLAB里安装编译器 编译dll文件是需要编译器的，我的MATLAB版本没有自带编译器，因此需要外部安装一个，这里我选择了TDM-GCC-64编译器，该安装包我已经上传到了CSDN资源库，可以从这里下载。下载完成后进行安装，这里因为我的电脑操作系统就是64位的，因此安装的版本选择了64位的：
期间安装程序会自动去网上下载必要的安装文件，因为可能是外网，因此下载速度会很慢，如果安装失败，建议换个网络后重新安装。在计算机处右键单击，选择属性按钮：
点击高级系统设置：
在弹出的窗口中选择环境变量：
点击系统变量下的新建按钮：
在弹出框中，变量名处输入MW_MINGW64_LOC，变量值处输入刚刚TDM-GCC-64的安装路径C:\TDM-GCC-64，之后点击确定：
可以看到系统变量里已经有了刚刚加入的环境变量，注意查看此处显示的环境变量名和值是否为MW_MINGW64_LOC和安装目录。 2.2在MATLAB中安装DLL的必要文件并设置编译器 先把MATLAB软件的当前目录展开至Cruise软件安装目录下的AVL\R2019.2\CRUISE\matlab\Install_DLL文件夹，并双击打开Install.m文件，如下图所示：
打开后点击运行按钮，结果如下图所示：
在下方的输入框中输入mex -setup后按回车： 提示如下图所示，代表已经成功的为C语言编译选择了编译器：
3 AVL Cruise和MATLAB DLL联合仿真时快速生成Simulink模型的方法 在Cruise软件里拖入MATLAB DLL模型后，进行数据总线连接，这里输入信号连接了Cockpit里的Velocity信号，输出信号连接了Engine里的Desired Torque信号，如下图所示：
双击MATLAB DLL模块，打开设置菜单，切换到Description of Data Bus选项卡，并点击下方的update按钮：
可以看到这里更新了连接到MATLAB DLL模块的信号，双击每个信号中Unit的空白处，对该信号进行必要的设置，比如设置单位等：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/04af1776978d0dd045cbb10ed3b1b38c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/164bc2fb804d84e6fd84767ecbf9ee20/" rel="bookmark">
			西门子博途软件安装问题汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Q1：操作系统需要使用基于美国联邦信息处理标准(FIPS)的加密算法。该软件使用的某些Microsoft标准算法不符合该标准 A1：典型的操作系统问题。
在 window中打开功能里输入regedit,回车打开注册器。然后进入如下路径HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Lsa\FipsAlgorithmPolicy
将enable设置为0即可。
Q2：C\Program Files\SiemensAutomation\Portal v15\Bin\Siemens.Automation.Portal.exe应用程序无法启动，因为应用程序的并行配置不正确。有关详细信息，请参阅应用程序事件日志,或使用命令行sxstrace.exe工具
A2：开始-运行(输入services.msc)-确定或回车，打开:服务（本地)；我们在服务（本地）窗口找到:Windows Modules Installer服务，查看是否被禁用;如果Windows Modules Installer服务被禁用，我们必须把它更改为启用-手动，重启计算机，再安装应用程序。
A2：如果还是出现上述错误，那就是我们的系统缺少Microsoft Visual C++20XX(运行库)文件。
打开百度搜索，输入Microsoft Visual C++20XX(运行库)，再点击:百度一下；找到：Microsoft Visual C++ 20XX(运行库）下载网址，下载并安装：Microsoft Visual C++ 20XX(运行库)；应用程序并行配置不正确使用命令行sxstrace.exeMicrosoft Visual C++ 20XX(运行库)(XX表示:05、08、10)安装完成后，重启计算机，再安装应用程序。
Q3：找不到许可证“STEP7 Professional” A3：新安装完软件如果出现这种问题，右击管理员运行软件；或者右击——&gt;属性——&gt;兼容性——&gt;以win7兼容性打开。如果是试用期过期，可以直接百度或者购买正版软件。
Q4：Totally Integrated Automation Portal在执行过程中检测到非严重错误 A4：发生这个问题的原因很复杂，官方给出的建议是重装系统或者重装软件，重启或者管理员或者兼容性打开都可能会解决问题，但后期还是又会出现这种故障，建议使用安装包完全修复软件，再不行重装系统。
Q5：Totally Integrated Automation Portal出错，需关闭 A5：发生这个问题的原因很复杂，官方给出的建议是重装系统或者重装软件，重启或者管理员或者兼容性打开都可能会解决问题，但后期还是又会出现这种故障，建议使用安装包完全修复软件，再不行重装系统。
Q6：安装最后提示安装出错，提示请启动Automation License Manager A6：确认系统是否为家庭版系统，如果是，重装系统；
确认Automation License Manger sever是否正常启动，右击我的电脑，点管理，点击服务和应用程序，点击服务，然后打开Automation License Manger sever；
检查安装路径是否出现中文；
可能是因为杀毒软件的问题，重新安装修复几次软件
使用期限已过期，建议安装正版软件或者重新激活软件。
Q7：安装软件过程中提示以安装XXX，需删除原版本 WINCC，TIAPROTAL A7：卸载软件：在控制面板中将发布者为siemens 的全部卸载。注意不一定是开头为siemens，也有可能是第二个。
Q8：先决条件不满足，wincc comfort/advanced vXX sp1 需要 netXX sp1 A8：打开控制面板，如下图操作（需要打开Windows Update）
如果安装失败了，需要用专门工具去安装。 Q9：安装软件时无限重启 A9：删除注册表： HEEY_LOCAL_MACHINE\SYSTEM\CURRENTCONTROLSET\CONTROL\SESSION MANAGE\下
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/164bc2fb804d84e6fd84767ecbf9ee20/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3941fb066d2f885f26b6388df940cec6/" rel="bookmark">
			【AIGC】一起学习prompt提示词（1/4）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本来是参加CSDN提示词的话题活动，但是觉得一次写不完，于是准备写一个系列。 欢迎批评、点赞和关注我。
为了避免大家使用特殊工具，我以国内大模型典范，百度的文心一言（文心一格）作为范例和模板，来说说prompt提示词。
比如你知道文心一言App——“发现”栏目的小应用，是怎么开发的吗？其实你也可以！未来这都是重要的流量入口，想了解提示词的，这是最好的练兵场所！
百度管这些小应用，就叫做提示词。
在活动的引子中，是这么描述本次任务的，“玩转AIGC，优质的Prompt提示词实在是太重要了！同样的问题，换一个问法，就会得到差别迥异的答案。你是怎样和AI进行对话交流的呢？一起来分享你用过的咒语吧！”
这里有个问题，把prompt提示词，仅仅作为搜索引擎的关键词技巧了。当然，实际也确实可以这么理解，这样最简单，不过，prompt可是有个专门的词叫做prompt engineer，这里的学问可大了。而且以文心一言为例，提示词有很多有趣的、甚至不会编程也能参与的玩法。
从今天开始，我就和大家来一起学习和分享，同时告诉他家，这些资源，都在哪里去免费获得和学习。
一、什么是提示词 提示词prompt，就是一段文本或者语句，用于指导机器学习模型生成特定类型、主题和格式的输出。
prompt，一般和token,context的概念一起去理解。
token，就是pieces of words，是输送给机器学习模型的prompt的组成部分。
context，就是模型可以用来生成更准确的相关文本的附加信息。
完美的输出结果，不光是提供一段文字指令就搞定，还可以包括不断训练的上下文。好的提示词，需要体现目标、任务、背景、输出的要求、互动参数几个基本的部分。
这个在绘图的提示词中，最为明显，也好让人理解。最简单的方式，就是把你脑子中的图，描述出来，让机器听懂。技巧和套路也是要有的，比如绘画风格，这里有一个表格，可以参考。
更多的风格，我会在后续专门的绘图提示词章节中，和大家一起来学习整理。
上下文在AIGC模型的产品中，可支持的字节数越来越大，32K，100K，越大就意味着运算能力的增加。
当然，也有一些提示词攻击的方法，这个也很有趣。
想学习更多提示词prompt的基础知识，参数、语法、理念，可以访问百度的创作者服务中心：
创作者服务中心
这里有课程。
可以看到里面的视频播放量还很小，好几个视频，我都抢了个沙发，留作纪念了。
二、百度的文心一言的提示词是怎么定义的 ——关于提示词怎么写更能套出AI的话来
这个确实是有套路的，第一是大模型也不是绝对的智能，发展空间还很大，有时就和搜索引擎是一样的，需要你会搜索，会提炼关键词，否则同样的目标，有的人能搜到结果，有的人就是不行。第二就是大模型经常会误会你说的意思，虽然网上有测评，文心一言已经能够听出画外音了，我觉得那是训练到位了，没有语料的，就不行，比如你问他，如果在东北，对方问“你愁啥”，我怎么回答，你看看她是怎么回复的吧，如果挨打了，不知道大模型管赔不。
具体如何优化prompt，我想用文心一言的一个功能来说明，见下面的章节。具体的一些做法，例如通过提示词，让大模型输出更好的结果的一些更丰富的案例，我们明天说。
这里推荐另一个资源：
就是百度的创建提示词和角色指南
百度安全验证
这个非常有趣，大家都可以创建起来，在文心一言App上，看到你的应用是不是很酷呢！
注意下面的官方提示：
1、如何创建
您可以使用本平台创作提示词与角色，我们对提示词和角色的定义如下：
提示词：指应用大模型所创作出的效率工具，比如“PPT工具、xxx探店文案“等
角色：指互联网世界的虚拟人物，具备丰富的形象、人设与声音，比如”派蒙“等
2、创建能力描述
创意：创作者需赋予：名称、简介、封面和类型与prompt ，我们为创作者提供了不同类型的模版，帮助您快速上手
调试：调试的意义在于验证你的创意效果，你可以通过调试prompt提示词来实现符合自己预期的效果
三、如果创建一个提示词“应用” 这就是我开头说的，发现里面的小提示词应用了。我个人比较喜欢把他们称之为提示词应用，因为毕竟我理解这是通过提示词的设计和训练，形成的帮助用户更好完成某种场景交互的辅助应用。
创建的位置，在这里地址：
文心一言创作者平台
点击新建：
下一步，起一个提示词的名称，就可以创作提示词了。
比如下面的案例：
这里千万不要出现概念上的误解，如上，在文心一言，提示词是一个小应用，需要用prompt来训练，形成一个固定的场景，给用户更好和更有趣的体验。比如，通过你的训练，形成一个“渣男道歉”的应用，帮助用户把输出的内容，都规范好，用户只要输入软妹子的性格，就可以输出道歉用语了。这个应用，会如下图，出现下App的“发现”栏目下。
当然，太离谱的提示词，是审核不过的。可以先模仿，再逐步通过修改来微创新，掌握审核人员的尺度。
亲自动手试试吧！明天我们来接着一起学习，如何用提示词，创建好玩的应用，学习和锻炼提高自己提示词的能力吧！
今天时间的原因，先到这里，下次我们具体来看看提示词应用怎么玩。另外说一下，文心一言的插件、小工具、提示词应用，分别都是什么，如何定位的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa5380c854a66d2a7d8ee6418366693b/" rel="bookmark">
			网页中 URL 的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 网页中 URL 的使用 绝对路径相对路径使用场景 网页中的 URL 主要分为两大类：相对路径与绝对路径。
绝对路径 绝对路径可靠性强，而且相对容易理解，在项目中运用较多
形式特点http://test.com/web直接向目标资源发送请求，容易理解。网站的外链会用到此形式。//test.com/web与页面 URL 的协议拼接形成完整的 URL 再发送请求。大型网站用的比较多。/web与页面 URL 的协议、主机名、端口，拼接形成完整的 URL 再发送请求。中小型网站用的比较多。 相对路径 相对路径在发送请求时，需要与当前页面 URL 路径进行计算，得到完整 URL 后，再发送请求，学习阶段用的较多。
例如当前网页 url 为 http://wwww.test.com/course/h5.html。
形式特点./css/app.csshttp://wwww.test.com/course/css/app.cssjs/app.jshttp://wwww.test.com/course/js/app.js…/img/logo.pnghttp://wwww.test.com/img/logo.png…/…/mp4/show.mp4http://wwww.test.com/mp4/show.mp4, 始终不会跳出 wwww.test.com/ 使用场景 网页中使用 URL 的场景包括但不限于：
a 标签 hreflink 标签 hrefscript 标签 srcimg 标签 src 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30b79e49d01dc787a5203caf45515cf6/" rel="bookmark">
			[Vue 配置] Vite &#43; Vue3 项目配置 Tailwind CSS
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章归档：https://www.yuque.com/u27599042/coding_star/yqzi9olphko9ity1
Tailwind CSS 官网：https://www.tailwindcss.cn/docs/installation/using-postcss
安装 pnpm i -D tailwindcss postcss autoprefixer 生成配置文件 npx tailwindcss init -p 配置 postcss postcss.config.js
export default { plugins: { tailwindcss: {}, autoprefixer: {}, }, } 配置 Tailwind CSS 生效的文件 tailwind.config.js
/** @type {import('tailwindcss').Config} */ export default { // 配置 Tailwind CSS 使用暗黑模式的形式(类名 class="dark") darkMode: 'class', // content:[], 默认为空 // Tailwind CSS 在如下配置的路径中的文件中生效 content: [ "./index.html", "./src/**/*.{vue,js,ts,jsx,tsx}", ], theme: { extend: {}, }, plugins: [], } 在项目中引入 Tailwind CSS src/styles/tailwind.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/30b79e49d01dc787a5203caf45515cf6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00ebc5261d197d340cb05aa28bb730b2/" rel="bookmark">
			linux centos7环境下安装MySQL
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://blog.csdn.net/Weixiaohuai/article/details/98473811
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8bc3d56366f5d8923d09674246c56b2d/" rel="bookmark">
			[Vue 配置] Vite &#43; Vue3 项目配置 src目录别名为 @
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章归档：https://www.yuque.com/u27599042/coding_star/ogu2bhefy1fvahfv
安装 @types/node 安装 @types/node 依赖，使得项目在开发环境下具有 path 模块（前端项目中默认无 path 模块）
pnpm i -D @types/node 配置 src 目录别名 在 vite.config.js 文件中，编写如下配置
import { defineConfig } from 'vite' import vue from '@vitejs/plugin-vue' import path from 'path' // src 目录的绝对路径 const pathSrc = path.resolve(__dirname, './src') // https://vitejs.dev/config/ export default defineConfig({ plugins: [vue()], resolve: { // 配置别名 alias: { // 配置 src 目录的别名为 @ "@": pathSrc, } } }) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0d27d92ca8ae6c21703edaafa24a957/" rel="bookmark">
			【Beyond Compare】大小写对比的设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.点击会话设置
2.把大小写打勾
3.对比效果
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c9ebb805d0f1c633bf03d2d47254da9e/" rel="bookmark">
			Unity&amp;&amp;C#学习笔记-const、readonly、static 与 sealed
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		const与readonly 二者都都将变量声明为只读 ，并且在变量初始化后就不可以改写。
readonly动态常量
动态常量的值则是在运行的那一刻才获得的，编译器编译期间将其标识为只读常量，而不用常量的值代替，这样动态常量不必在声明的时候就初始化，而可以延迟到构造函数中初始化。
切只能在定义时或者构造函数中初始化，其他的地方都不能再修改其值
在类里面可以不初始化值,有默认值
readonly修饰的常量则可以延迟到构造函数初始化；
引用类型readonly只有地址是不变的
readonly常量只能声明在类中； const静态常量 指编译器在编译时候会对常量进行解析，并将常量的值替换成初始化的那个值。没有分配内存
没有分配内存，因为在编译后,在IL代码中嵌入了常里值
const修饰的常量在声明的时候必须初始化；因为编译时就会替代值
const默认是静态的,只能通过类名访问
const常量既可以声明在类中，也可以在函数体中；
小结：
const和readonly都是只读的。
const默认是static的，而且在编译期间已经解析完成。因此const和static readonly只能有类访问，而readonly通过实例访问。
根据所使用的构造函数，readonly 字段可能具有不同的值。
对于每一次编译后的结果，const的值是固定的，而readonly的值是可以在运行的时候才确定值的。
const是静态常量，readonly是动态常量。
const高效，readonly灵活。
实际使用中，常常用static readonly来代替const，以此来平衡const在灵活性上的不足。
Static static，readonly是在运行时计算出其值的，所以还能通过静态构造函数来赋值。
静态类 静态类特点:
1.不能支持实例化,原因是静态类只有一个"副本",说明静态类分配空间时只有一份.
2.静态类中的不能存在实例成员只能存在静态成员.
3..静态类中的构造函数必须是静态的,且不能有修饰符.
4.静态类默认是封闭的所以不能继承
静态类的应用场景一般是封装一些工具类.
sealed 即密封类和密封方法。
用于阻止类被继承或方法被重写。
在方法中使用sealed，只能是在已经被重写的方法中定义sealed，表示这个方法不可以再被重写。
优点
更高的执行效率：如前所述，标记为sealed的类和方法可能会让编译器进行某些优化，从而提高代码执行的效率。
增强封装性：通过使用sealed关键字，你可以保证你的类不会被其他类继承，或者你的方法不会被子类覆盖。这可以让你的代码更加安全，避免未经意的修改破坏了你的类的行为。
减少复杂性：sealed关键字能够限制类的继承层次，降低软件设计的复杂性，并且使得代码更容易理解和维护。
缺点
限制了灵活性：如果一个类被声明为sealed，那么它就不能被继承，这可能限制了代码的复用和类的扩展。某些情况下，你可能需要创建原类的扩展版本，但由于sealed的限制，你无法直接从原类继承。
影响单元测试：基于继承的单元测试方法（例如使用Mock对象）可能会受到sealed类或方法的影响。因为sealed类不能被继承，所以无法创建派生的Mock类进行测试。
原文链接：https://blog.csdn.net/lym940928/article/details/88386224
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c0ff4293e29ce1b9a3552e69cbcbf6a/" rel="bookmark">
			Pytorch的安装，有点繁琐但是很详细，保姆级教程不信你安装不成功（Cuda&#43;Cudnn&#43;Anaconda&#43;Pytorch）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.CUDA的安装
1.cuda安装之前，需要查看本机的gpu版本
2.查看自己电脑是否安装了显卡驱动
3.观察自己电脑是否安装visual studio
2.Cudnn的安装
1.下载cundnn
2.配置环境变量
3.检验cudnn是否安装成功
3.Anacinda的安装
1.anaconda的下载
2.配置环境变量
4.Pytorch的安装
1.conda搭建虚拟环境
2.安装pytorch
3.检验pytorch是否能够成功调用gpu
PyTorch是一个开源的Python机器学习库，它提供了丰富的工具和功能，用于构建深度学习模型。它由Facebook的人工智能研究小组于2016年发布，并迅速成为深度学习领域中最受欢迎的框架之一。
PyTorch的设计目标是提供简单易用的接口，同时保持灵活性和高性能。它基于动态计算图的概念，这意味着模型的计算图是根据实际运行时的数据动态构建的。这种设计使得PyTorch在实验和原型开发方面非常方便，因为用户可以轻松地编写和调试模型，而无需事先定义静态计算图。PyTorch提供了丰富的工具和函数，使得构建深度学习模型变得简单而直观。它的API设计得非常人性化，使得用户可以用几行简洁的代码完成复杂的操作。PyTorch还提供了丰富的预训练模型和模型组件，使得构建各种类型的神经网络变得更加容易。PyTorch支持广泛的硬件设备和平台，包括CPU、GPU和TPU。它的底层实现利用了高性能的数值计算库，如CUDA和cuDNN，以提供快速的计算速度和高效的内存使用。除了强大的建模能力，PyTorch还提供了丰富的工具和库，用于数据加载、数据预处理、可视化和模型部署等任务。它与Python生态系统紧密集成，可以方便地与其他科学计算库（如NumPy和SciPy）进行交互，并与流行的深度学习库（如TensorFlow）进行集成PyTorch还拥有一个庞大而活跃的社区，开发者可以在社区中分享和讨论各种问题、想法和最佳实践。这使得学习和使用PyTorch变得更加容易，同时也能获得及时的支持和反馈。总之，PyTorch是一个强大而灵活的深度学习框架，它提供了简单易用的接口、高性能的计算能力和丰富的工具和库。无论是在学术研究还是工业应用中，PyTorch都是一个理想的选择，能够帮助开发者构建和训练各种复杂的深度学习模型。
接下来让我们开始安装
1.CUDA的安装 1.cuda安装之前，需要查看本机的gpu版本 打开任务管理器 （快捷键ctrl+alt+.） 点击性能 查看gpu版本这里我们是NVIDIA GTX1650,是可以安装cuda的，如果gpu不是NVIDIA版本的，则不能使用cuda，直接跳到步骤四，可以在命令窗口直接安装pytorch。
2.查看自己电脑是否安装了显卡驱动 在桌面右击，打开NVIDIA 控制面板，点击系统信息，我们可以看到自己驱动程序版本，如果没有gpu驱动，建议先安装NVIDIA驱动
点击组件查看支持cuda的版本号，在这支持cuda 11.6.1
3.观察自己电脑是否安装visual studio 在左下角直接搜索visual studio
可以看到并没有安装，如果已经安装接下来步骤将告诉你如何操作。
4.安装cuda
cuda的官方网址为：
kCUDA Toolkit Archive | NVIDIA Developer
选择自己与之匹配的cuda，博主电脑cuda版本是11.6.1，大家根据上方自己查看到的cuda版本进行下载
​点击后情况如下，根据指示和自己的实际情况进行选择
​
下载完成进行安装
选择自定义安装
​
以下三步是cuda安装成功的关键，建议大家不要搞错
​
​
因为我们当前驱动的版本高于他推荐的版本，所以一定要把对号取消。
​
取消后就可以进行安装了。安装完成后得到如下图。
​
为了检验我们cuda是否真正安装成功，我们打开命令行窗口(cmd)，因为cuda安装过程中，已经自动配置好了环境变量，我们在命令行中输入 nvcc -V
nvcc -V 显示如下图，则表示cuda安装成功
​
2.Cudnn的安装 1.下载cundnn 网址Log in | NVIDIA Developer
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9c0ff4293e29ce1b9a3552e69cbcbf6a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6807a8c2c682ee1c84e63dc18fe70cf5/" rel="bookmark">
			用python上传文件到百度网盘（使用百度网盘开放平台sdk）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先上一张上传成功截图
运行代码如下 # !/home/***/anaconda3/bin/python #选择合适的python版本 """ xpan upload include: precreate upload create """ import os import sys BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__))) sys.path.append(BASE_DIR) from pprint import pprint from openapi_client.api import fileupload_api import openapi_client import hashlib def precreate(): """ precreate """ # Enter a context with an instance of the API client with openapi_client.ApiClient() as api_client: # Create an instance of the API class api_instance = fileupload_api.FileuploadApi(api_client) access_token = "***" #填入自己的access_token path = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6807a8c2c682ee1c84e63dc18fe70cf5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dead5aeb8499e634d7012ed9e8386554/" rel="bookmark">
			【QT系列教程】之二创建项目和helloworld案例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、QT创建项目1.1、创建项目1.2、选择创建项目属性1.3、选择路径和项目名称1.4、选择构建项目类型1.5、布局方式1.6、翻译文件，根据自己需求选择1.7、选择套件1.8、项目管理，自行配置1.9、配置完成，系统自动更新配置 二、QT界面介绍2.1、QT布局介绍2.2、QT项目文件介绍 三、写一个项目实例3.1、label修改显示helloworld实例3.2、效果图 一、QT创建项目 1.1、创建项目 1.2、选择创建项目属性 1.3、选择路径和项目名称 1.4、选择构建项目类型 1.5、布局方式 1.6、翻译文件，根据自己需求选择 1.7、选择套件 1.8、项目管理，自行配置 1.9、配置完成，系统自动更新配置 二、QT界面介绍 2.1、QT布局介绍 2.2、QT项目文件介绍 三、写一个项目实例 3.1、label修改显示helloworld实例 3.2、效果图 优良的跨平台特性:
Qt支持下列操作系统: Microsoft Windows 95/98， Microsoft Windows NT， Linux， Solaris， SunOS， HP-UX， Digital UNIX (OSF/1， Tru64)， Irix， FreeBSD， BSD/OS， SCO， AIX， OS390，QNX 等等。
面向对象
Qt 的良好封装机制使得 Qt 的模块化程度非常高，可重用性较好，对于用户开发来说是非常方便的。 Qt 提供了一种称为 signals/slots 的安全类型来替代 callback，这使得各个元件之间的协同工作变得十分简单。
丰富的 API
Qt 包括多达 250 个以上的 C++ 类，还提供基于模板的 collections， serialization， file， I/O device， directory management， date/time 类。甚至还包括正则表达式的处理功能。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dead5aeb8499e634d7012ed9e8386554/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9343d8c952a792d31e0d743fb1558ccf/" rel="bookmark">
			c&#43;&#43;之xml的创建，增删改查
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		c++之xml的创建，增删改查 1.创建写入2.添加3.删除4.修改： 1.创建写入 #include &lt;stdio.h&gt; #include &lt;typeinfo&gt; #include "F:/EDGE/tinyxml/tinyxml.h" #include &lt;iostream&gt; #include &lt;string&gt; #include &lt;Winsock2.h&gt; #pragma comment(lib, "ws2_32.lib") using namespace std; void main() { printf("\n----- XML -----\n"); //新建一个xml文件 // 定义一个TiXmlDocument类指针 TiXmlDocument* tinyXmlDoc = new TiXmlDocument(); // xml的声明(三个属性：版本，编码格式，保留空串即可) TiXmlDeclaration* tinyXmlDeclare = new TiXmlDeclaration("1.0", "utf-8", ""); // 声明头部格式 // 插入文档类中 tinyXmlDoc-&gt;LinkEndChild(tinyXmlDeclare); // 根节点 TiXmlElement* Library = new TiXmlElement("Library"); tinyXmlDoc-&gt;LinkEndChild(Library); // 把根节点插入到文档类中 // 创建Book节点 TiXmlElement* Book = new TiXmlElement("Book"); TiXmlText* bookText = new TiXmlText("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9343d8c952a792d31e0d743fb1558ccf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76717ef61ff245300e877d6d5e57b399/" rel="bookmark">
			安装Ubuntu20.04 LTS双系统时种种疑难杂症的解决方案（持续更新）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言&amp;本人电脑配置介绍 本人装双系统的初衷是想利用自己电脑上的显卡跑yolov5模型，所以计划在我的电脑上安装双系统（并非虚拟机）
配置：联想拯救者Y9000X 64位 Win11
RTX3050ti 512G内存
硬盘：幻隐hsv3000 1TB固态
12th Gen Intel(R) Core(TM) i7-12700H 2.30 GHz
机带RAM：16.0 GB 一、安装Ubuntu的准备工作 1.需要准备一个16GB的u盘作为启动盘，此外想要跑深度学习的同学电脑最好带有nVidia的显卡
2.百度确认你电脑进入BIOS以及UEFI的快捷键（我的分别为F2与F10）
3.调出“我的电脑”以及“文件夹”
右键桌面，点击“个性化”，点击“主题”，在相关设置中点击“桌面图标设置”
出现这个图标即可 二、安装Ubuntu 一、环境准备 注：我的电脑与接下来解决的问题都是基于BIOS为UEFI的，其它情况并没有接触
查看自己的BIOS是什么种类的方法如下
0.查看BIOS win+R输入msinfo32，点击系统消息查看BOSI模式
1.磁盘分区 右键我的电脑点击管理
点击磁盘管理进入磁盘进行分区
个人建议想要安装双系统Ubuntu的话最好预留500GB的大小（正是因为这个事情所以我在不久前又买了一个笔记本，但是他只有集成显卡，怒-3000，后来又买了1TB的固态）
如果你发现你的硬盘也有上述（Bitlocker已加密）的字段时，请立刻跳转到三-二
这是我给Ubuntu分出来的总大小（我们在分区的时候只需要先分出来一个即可） 右键你想选择分盘的硬盘点击压缩
输入想分的大小，注意1GB=1024MB，为了简单计算，我们直接假定1GB=1000MB即可：）
由于E盘我使用过一些，所以可用压缩空间大小仅仅374G，但是如果你发现可用空间大小远远小于你未使用的空间时请按照一下步骤操作（没问题的同学可以跳过进行下一步）
1.直接在下方搜索框搜索“高级系统设置”
2.进入第一个，性能 --设置，再点击
3.取消勾选自动管理所有驱动器的分页文件大小，点击要进行分区的盘，选中‘无分页文件’，点击‘设置’、‘完成‘，再重启。
4.按照上述步骤进行分区，会发现可用的分区大了很多，如果发现还是不可以的话就需要我们去下载分区助手进行操作了（直接百度下载即可），但是！！！！！！！！如果你操作到了此步，无论结果有没有成功请一定要继续按照本步骤操作下去！！！！否则你的电脑很可能会崩掉！！！
5.进入安全模式后按以上操作恢复原来设置（上述第2步的设置要设置回原来的样子）
如果不会进入Windows的安全模式可以按照以下步骤操作（以下皆为百度得到的结果）
有几种不同的方法可以在 Windows 11 上将计算机重新启动到“高级启动”模式，这将允许您在多次选择后选择“安全模式”。
最简单的方法：打开“开始”菜单，然后单击右下角的电源图标。然后，按住键盘上的 Shift 键并单击“重新启动”。
或者，您可以通过设置应用程序开始通往安全模式的漫长道路。首先，通过按 Windows+i 启动设置（或者，您可以通过在开始中搜索找到它。）。当设置打开时，单击侧栏中的“系统”，然后选择“恢复”。找到“高级启动”选项，单击它旁边的“立即重新启动”按钮。Windows 将通过一个弹出对话框进行确认，要求您在重新启动之前保存您的工作。准备好后，单击“立即重新启动”。
之后，Windows 将关闭并重新启动，进入一个标题为“选择一个选项”的蓝色屏幕，并在简短列表中显示几个选项。选择“疑难解答”。在疑难解答中，选择“高级选项”。在高级选项中，选择“启动设置”。在启动设置中，单击“重新启动”。PC 将重新启动进入带有九个编号选项的“启动设置”菜单。按键盘上的“4”键进入安全模式。Windows 最终将启动到安全模式。您的显示器将采用较低的分辨率，Windows 会将您的桌面图像替换为黑色背景，并在角落显示“安全模式”。
二、开始安装Ubuntu20.04LTS 1.下载Ubuntu20.04 1.Ubuntu官网下载Ubuntu官网https://ubuntu.com/
2.国内镜像源下载（官网下载由于是国外网站可能会出现下载慢、进不去网页的状况，所以国内镜像源是常常选择的）镜像源https://mirrors.tuna.tsinghua.edu.cn/
注意我们要下载的是Ubuntu20.04 版本不要搞错了
2.制作引导盘 进入Ubuntu官网，插上你的U盘，在官网中将引导盘烧录到U盘中
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/76717ef61ff245300e877d6d5e57b399/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7f74fd50482013c073399b83d35f319/" rel="bookmark">
			STM32基于毫米波雷达的生命体征检测系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 毫米波雷达模块选择 毫米波雷达我选择的了Seeedstudio企业的淘宝官方店铺，毫米波雷达包含有呼吸心跳检测雷达，人体存在感应雷达，睡眠呼吸等等，其单个模块并非只有单一功能，需要开发者根据原始数据分析解析。
硬件连接示意图 原始数据分析 由于毫米波模块是默认输出的，一直在不停歇的发送数据，所以或者原始数据可通过直接连接USB-TTL或者与STM32连接，串口打开就可以发现串口出现数据啦
在SEEK官网又说明每一位数据的意义，部分数据解析如下 该数据由帧头:0x53 0x59，控制字:0x80，命令字:0x81，长度标识符:0x00 0x01，数据:0x0F， 校验和:1Byte (SUM)，帧结束:0x54 0x43
最终数据解析显示 根据原始数据，我们可通过STM32的DMA将接收到的原始数据单字节的进行解析，逐一的进行判断，部分代码如下：
串口获取原始数据 usart.c
void HAL_UART_MspInit(UART_HandleTypeDef* uartHandle) { GPIO_InitTypeDef GPIO_InitStruct = {0}; if(uartHandle-&gt;Instance==USART1) { /* USER CODE BEGIN USART1_MspInit 0 */ /* USER CODE END USART1_MspInit 0 */ /* USART1 clock enable */ __HAL_RCC_USART1_CLK_ENABLE(); __HAL_RCC_GPIOA_CLK_ENABLE(); /**USART1 GPIO Configuration PA9 ------&gt; USART1_TX PA10 ------&gt; USART1_RX */ GPIO_InitStruct.Pin = GPIO_PIN_9; GPIO_InitStruct.Mode = GPIO_MODE_AF_PP; GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH; HAL_GPIO_Init(GPIOA, &amp;GPIO_InitStruct); GPIO_InitStruct.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f7f74fd50482013c073399b83d35f319/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ea007b9a88f6bb8911d69e61733e7bc/" rel="bookmark">
			多页面与单页面应用的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 单页面，顾名思义只有一个界面。
界面是通过URL来定位的，所以单页面应用从头到尾它的html地址都是不变的，注意哦，是html地址，而不是URL地址，这两者还是有点区别的。html地址是截止到.html的界面地址，比如：http://about.html#setting这个地址中，html地址是http://about.html，而完整的URL是http://about.html#setting。
而多页面应用，顾名思义就是多个界面间的跳转，会伴随着html地址的改变。
在单页面应用中，通常是由一个外部框架和一个一个组件组成的，界面之间的切换其实就是组件的移除和新组建的添加。
在多页面中，则可以看到导航栏中地址的变化，是从一个完整的页面跳转到另一个完整的页面（注意区分页面和界面）。
对比项多页应用模式MPA单页应用模式SPA应用构成由多个完整页面构成一个外壳页面和多个页面片段构成跳转方式页面之间的跳转是从一个页面跳转到另一个页面页面片段之间的跳转是把一个页面片段删除或隐藏，加载另一个页面片段并显示出来。这是片段之间的模拟跳转，并没有开壳页面跳转后公共资源是否重新加载是否URL模式http://xxx/page1.html和http://xxx/page2.htmlhttp://xxx/shell.html#page1和http://xxx/shell.html#page2用户体验页面间切换加载慢，不流畅，用户体验差，特别是在移动设备上页面片段间的切换快，用户体验好，包括在移动设备上能否实现转场动画无法实现容易实现（手机app动效）页面间传递数据依赖URL、cookie或者localstorage，实现麻烦因为在一个页面内，页面间传递数据很容易实现(这里是我补充，父子之间传值，或vuex或storage之类)搜索引擎优化（SEO）可以直接做需要单独方案做，有点麻烦特别适用的范围需要对搜索引擎友好的网站对体验要求高的应用，特别是移动应用开发难度低一些，框架选择容易高一些，需要专门的框架来降低这种模式的开发难度 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f48bae16fa9e010b63fd4cbf1672d6e7/" rel="bookmark">
			STM32F103通过IIC协议实现温湿度（AHT20）的采集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、IIC总线协议 1.1、IIC协议简介 ​ IIC通讯协议(Inter－Integrated Circuit)是由 Phiilps 公司开发的，由于它引脚少，硬件实现简单，可扩展性强，不需要 USART、CAN 等通讯协议的外部收发设备，现在被广泛地使用在系统内多个集成电路(IC)间的通讯。
1.2、IIC协议的物理层和协议层 （1）物理层
I2C是一个支持设备的总线。可连接多个 I2C 通讯设备，支持多个通讯主机及多个通讯从机。对于I2C 总线，只使用两条总线线路，一条双向串行数据线(SDA) ，一条串行时钟线(SCL)。
I2C 通讯设备常用连接方式：
它的物理层有如下特点：
① 它是一个支持设备的总线。“总线”指多个设备共用的信号线。在一个IIC通讯总线中，可连接多个IIC通讯设备，支持多个通讯主机及多个通讯从机。
② 一个IIC总线只使用两条总线线路，一条双向串行数据线(SDA) ，一条串行时钟线 (SCL)。数据线即用来表示数据，时钟线用于数据收发同步。
③ 每个连接到总线的设备都有一个独立的地址，主机可以利用这个地址进行不同设备之间的访问。
④ 总线通过上拉电阻接到电源。当IIC设备空闲时，会输出高阻态，而当所有设备都空闲，都输出高阻态时，由上拉电阻把总线拉成高电平。
⑤ 多个主机同时使用总线时，为了防止数据冲突，会利用仲裁方式决定由哪个设备占用总线。
⑥ 具有三种传输模式：标准模式传输速率为 100kbit/s ，快速模式为 400kbit/s ，高速模式下可达 3.4Mbit/s，但目前大多IIC设备尚不支持高速模式。
⑦ 连接到相同总线的 IC 数量受到总线的最大电容 400pF 限制 。
（2）协议层
主要是定义了通讯的起始和停止信号、数据有效性、响应、仲裁、时钟同步和地址广播等。
通讯的起始和停止信号：
数据有效性：
IIC 使用 SDA 信号线来传输数据，使用 SCL 信号线进行数据同步。SDA 数据线在 SCL 的每个时钟周期传输一位数据。传输时，SCL 为高电平的时候 SDA 表示的数据有效，即此时的 SDA 为高电平时表示数据“1”，为低电平时表示数据“0”。当 SCL 为低电平时，SDA 的数据无效，一般在这个时候 SDA 进行电平切换，为下一次表示数据做好准备。
响应：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f48bae16fa9e010b63fd4cbf1672d6e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53628b12aea394d22ad5be4e89d52484/" rel="bookmark">
			Ubuntu20安装maskrcnn_benchmark（CUDA11.0.2）详细步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、环境说明 Ubuntu环境为20.04：
Linux version 5.15.0-88-generic (buildd@lcy02-amd64-011) (gcc (Ubuntu 9.4.0-1ubuntu1~20.04.2) 9.4.0, GNU ld (GNU Binutils for Ubuntu) 2.34) #98~20.04.1-Ubuntu SMP Mon Oct 9 16:43:45 UTC 2023 gcc、g++为5.3.1版本
gcc version 5.3.1 20160413 (Ubuntu 5.3.1-14ubuntu2) gcc version 5.3.1 20160413 (Ubuntu 5.3.1-14ubuntu2) CUDA版本为11.0，CUDNN版本为8.9.2
nvcc: NVIDIA (R) Cuda compiler driver Copyright (c) 2005-2020 NVIDIA Corporation Built on Thu_Jun_11_22:26:38_PDT_2020 Cuda compilation tools, release 11.0, V11.0.194 Build cuda_11.0_bu.TC445_37.28540450_0 #define CUDNN_MAJOR 8 #define CUDNN_MINOR 9 #define CUDNN_PATCHLEVEL 2 -- #define CUDNN_VERSION (CUDNN_MAJOR * 1000 + CUDNN_MINOR * 100 + CUDNN_PATCHLEVEL) 显卡为3090
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/53628b12aea394d22ad5be4e89d52484/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5dd1024410d70e84556aa807dca1bb0/" rel="bookmark">
			如何使用 Github Action 管理 Issue
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文作者为 360 奇舞团前端开发工程师 Daryl
前言 很多小伙伴打开 github 上的仓库都只使用Code查看代码，或者只是把 github 当成一个代码仓库，但是 github 还提供了很多好用的功能。
其中，GitHub Action就是一个很好用的功能，本文将通过几个管理Issue的示例带大家了解GitHub Action:
什么是 Github Action github 给所有用户都提供了临时可用的虚拟机， 我们通过创建 github action 工作流来使用这个虚拟机. 我们可以使用它来实现自动化部署、自动化测试、代码检查、管理 Issues...
使用步骤 在学习之前还需要准备一些资料:
Github Action文档
官方仓库中有很多可以复用的 Action， 通过uses字段引用就可以直接使用了。
阮一峰的YAML 教程；
也推荐大家使用Vscode GitHub Action插件，这个插件在登录后可以用来做语法校验，还能查看运行过的记录。
除了这些资料之外还有些基础概念需要了解:
事件: 在工作流中可以监听 github 的一些事件， 在事件触发后执行我们定义的工作流;
上下文: github 上下文包含有关工作流运行和触发运行的事件的信息，可以读取环境变量中的大多数 github 上下文数据，并允许我们通过变量访问这些数据。
变量: 变量提供了一种存储和重用非敏感配置信息的方法。 可以将任何配置数据（如编译器标志、用户名或服务器名称）存储为变量。 变量在运行工作流的运行器计算机上插值。 在操作或工作流步骤中运行的命令可以创建、读取和修改变量。
表达式: 可以使用表达式来运算工作流程文件中的变量。
秘钥: 普通变量中存储的信息并不安全，很容易泄露，一些需要保密的信息就可以存储到秘钥中。
如果不想去从头学习yml语法， 可以先了解一些yml的基础用法:
大小写敏感
使用缩进表示层级关系
缩进时不允许使用 Tab 键，只允许使用空格。
缩进的空格数目不重要，只要相同层级的元素左侧对齐即可
下面开始介绍 GitHub Action 的用法 使用 github Action ，第一步需要在项目根目录下创建.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b5dd1024410d70e84556aa807dca1bb0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c9a7ed05bb1a3a64bb8a9c617d58908d/" rel="bookmark">
			Winform / WPF 自定义控件 —— IPV4 地址输入框
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在开始阅读本文之前，如果您有学习创建自定义控件库并在其他项目中引用的需求，请参考：在Visual Studio中创建自定义Winform控件库并在其他解决方案中引用https://blog.csdn.net/YMGogre/article/details/126508042
0、引言 Winform / WPF 框架居然没有自带的 IPV4 输入框控件，虽说可以直接用个 TextBox / MaskedTextBox 充当 IPV4 的地址输入框，但总感觉没那么优雅。也尝试使用过Win32 API 的 IPV4 地址输入框（参考 MSDN 文档），也没有很好用...😕
好吧，自己实现一个好了。
1、效果演示 2、Winform IPV4 输入框 完整源码
3、WPF IPV4 输入框 参考博客
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/696e82c1bda95bd3afbd5996933dcd59/" rel="bookmark">
			windows网络共享网络（Internet连接共享）（ICS：Internet Connection Sharing）可以让某台主机共享笔记本网络（或笔记本手机热点）实现上网（设备网线直连笔记本）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Windows网络共享实现笔记本共享上网详解网络共享基础分类有线共享无线共享 介质 配置网络共享前的准备工作检查硬件需求更新驱动程序检查操作系统 配置Internet连接共享启用ICS功能1. 打开“控制面板”。3. 点击网络和 Internet“网络和共享中心” --&gt; 查看网络状态和任务4. 点击“更改适配器设置”。5. 找到你用于连接互联网的网络适配器，右键点击，选择“属性”。6. 切换到“共享”标签页。7. 勾选“允许其他网络用户通过此计算机的Internet连接来连接”选项。 设置被共享的网络适配器设置共享的网络适配器配置客户端设备（比如我用网线直连笔记本的linux盒子）测试 常见问题及解决方案共享选项灰显网络共享后无法上网性能问题 总结 Windows网络共享实现笔记本共享上网详解 网络共享是一个常见的需求，特别是在没有无线路由器的环境中，使用笔记本的网络共享功能可以让其他设备通过有线或无线连接上网。本文将详细介绍如何通过Windows系统的Internet连接共享（ICS）来实现这一功能。
网络共享基础 在深入了解具体操作之前，首先要了解一些网络共享的基础知识。网络共享允许一台计算机利用其网络连接作为接入点，供其他设备使用。这通常通过两种方式实现：
分类 有线共享 通过网线直接连接两台设备，使得一台设备能够使用另一台设备的网络连接。
无线共享 通过创建Wi-Fi热点，允许其他设备无线连接到提供共享的设备。
介质 在这两种情况下，扮演共享角色的设备通常需要两个网络适配器：一个用于连接到互联网，另一个用于与要共享的设备连接。
配置网络共享前的准备工作 检查硬件需求 要配置网络共享，笔记本电脑需要至少两个网络适配器：一个用于连接到互联网（比如无线适配器连接到Wi-Fi），另一个用于和其他设备连接（比如以太网适配器连接到另一台电脑）。
更新驱动程序 确保所有网络适配器的驱动程序都是最新的。可以通过设备管理器检查并更新驱动程序。
检查操作系统 确认你的操作系统支持网络共享。大多数现代Windows系统版本，如Windows 10和Windows 11，都内置了网络共享功能。
配置Internet连接共享 启用ICS功能 1. 打开“控制面板”。 3. 点击网络和 Internet“网络和共享中心” --&gt; 查看网络状态和任务 4. 点击“更改适配器设置”。 5. 找到你用于连接互联网的网络适配器，右键点击，选择“属性”。 6. 切换到“共享”标签页。 7. 勾选“允许其他网络用户通过此计算机的Internet连接来连接”选项。 设置被共享的网络适配器 在同一个“属性”窗口中，选择“家庭网络连接”或者“家用网络连接”下拉菜单。从列表中选择你想要共享给其他设备的网络适配器。确认修改，并关闭所有窗口。 设置共享的网络适配器 上面我们设置共享的网络适配器为“以太网”：
右键属性：
选择Internet 协议版本 4（TCP/IPv4）：
这边ip可以随便设，但跟被共享网络不能同网段（同网段有点问题），网关的话，有时要设有时不要设，具体我没搞太明白：
配置客户端设备（比如我用网线直连笔记本的linux盒子） 我的盒子网络配置：
ip：192.168.137.158
子网掩码：255.255.255.0
网关：192.168.137.1
dns：8.8.8.8
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/696e82c1bda95bd3afbd5996933dcd59/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c72f146c9360085399b771755a874be6/" rel="bookmark">
			盘点72个ASP.NET Core源码Net爱好者不容错过
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		盘点72个ASP.NET Core源码Net爱好者不容错过
学习知识费力气，收集整理更不易。
知识付费甚欢喜，为咱码农谋福利。
链接：https://pan.baidu.com/s/1nlQLLly_TqGrs5O8eOmZjA?pwd=8888 提取码：8888
项目名称
(Chinese) 物业收费系统，使用 ASP.NET Core MVC 框架
.net core webapi配合swagger以及其他常用功能的单层项目
.NET Core实战项目之CMS系列教程的源码
Asp .Net Core项目中，以服务基地址为标识的HttpClient池管理模块
Asp.Net Core +Dapper + Vue + IView 前后端分离通用权限管理系统、后台框架、信息管理系统基础框架
ASP.NET Core +Vue 小项目：构造自己的在线 Markdown 笔记本
asp.net core 3.0网站项目容器化部署，使用docker-compose编排Nginx容器、MySQL容器、web容器
ASP.Net Core3.0+Blazor ServerSide+SignalR区块链项目演示
asp.net core 3.x项目模板
asp.net core api项目模板
Asp.Net Core Api项目集成Azure AD实现认证授权
ASP.NET Core MVC+ SqlSugerCore 新闻发布系统
ASP.NET CoreWebAPI RESTful 项目模板
asp.net corewebapi项目配置全局路由
ASP.NET Core 帖子项目
asp.net core 微服务项目
asp.net core 快速开发项目模版
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c72f146c9360085399b771755a874be6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/833752a39cd76c47dec880f641d0efc6/" rel="bookmark">
			Center Smoothing Certified Robustness for Networks with Structured Outputs
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Center Smoothing: Certified Robustness for Networks with Structured OutputsSummaryResearch ObjectiveProblem StatementMethodsEvaluationConclusionNotesGaussian Smoothing常用希腊字母霍夫丁不等式（Hoeffding's inequality）1.简述2.霍夫丁不等式2.1.伯努利随机变量特例2.2.一般形式 Center Smoothing: Certified Robustness for Networks with Structured Outputs 中心平滑：经过认证的具有结构化输出的网络的鲁棒性
Summary 写完笔记之后最后填，概述文章的内容，以后查阅笔记的时候先看这一段。
center smooth：对于给定的输入 x x x 与函数 f f f，以及对 x x x 的 l 2 l_2 l2​ 扰动半径 ϵ 1 \epsilon_1 ϵ1​。中心平滑的目的是：在输出空间中计算一个最小半径为 r r r 的包围球，该球的球心为 f ˉ ( x ) \bar{f}(\boldsymbol{x}) fˉ​(x)，这时候的最小包围球包含至少一半的 f ( x + N ( 0 , σ c s 2 I ) ) f\left(\boldsymbol{x}+\mathcal{N}\left(0, \sigma_{c s}^2 I\right)\right) f(x+N(0,σcs2​I))。这时候的 f ˉ \bar{f} fˉ​ 为 f f f 平滑函数， f ˉ ( x ) \bar{f}(\boldsymbol{x}) fˉ​(x)为 f ( x ) f(x) f(x)在点 x x x 的平滑输出结果。整个过程如下表示：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/833752a39cd76c47dec880f641d0efc6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/943b06b4342d5349964834b8795abe4a/" rel="bookmark">
			专题解读｜Graph Fairness代表性工作介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 图上的公平性问题 图在现实世界中无处不在，例如知识图谱，社交网络和生物网络。近年来，图神经网络( graph neural networks，GNNs ) 在图结构数据建模方面表现出了强大的能力。一般地，GNNs采用消息传递机制，通过迭代地聚合邻居节点的表示来更新节点的表示。得到的表示同时保留了节点属性和局部图结构信息，便于各种下游任务，如节点分类和链接预测。尽管GNNs表现优异，但最近的研究表明，GNNs倾向于从训练数据中继承偏见，这可能导致对敏感属性的偏见预测，例如年龄、性别和种族。此外，GNNs的消息传递机制和图结构会放大偏见。例如，在社交网络中，同一种族的节点更有可能相互连接。GNNs的消息传递会使链接节点的表示相似，导致节点表示与种族高度相关，从而产生有偏预测。有偏预测引起了伦理和社会角度的关注，这严重限制了GNNs在高风险决策系统中的应用，如求职者排名和犯罪预测。因此，近年来许多工作致力于解决图上的公平性问题。
2. 相关工作介绍 2.1 Say No to the Discrimination: Learning Fair Graph Neural Networks with Limited Sensitive Attribute Information 论文来源：2021年 ACM International Conference on Web Search and Data Mining（CCF-B）
论文代码：https://github.com/EnyanDai/FairGNN
Motivation 现有公平性的研究主要针对的是独立同分布的数据，由于没有同时考虑节点属性和图结构的偏差，因此无法直接应用于图数据。现有工作很少考虑敏感属性中稀疏标注的实际场景。 研究在敏感属性信息有限的情况下学习公平GNNs的问题
Contribution 研究了有限敏感信息下学习公平GNNs的一个新问题；提出FairGNN，通过预测用户的敏感属性来解决对抗性去偏和公平性约束中敏感属性的不足问题;理论分析表明，即使估计敏感属性，公平性也能达到最优值;在不同数据集上的大量实验证明了FairGNN在保持GNN高准确性的同时消除了歧视的有效性。 Method FairGNN整体框架图
整体框架由四部分组成：一个GNN分类器 f G f_{\mathcal G} fG​，一个基于GCN的敏感属性估计器 f E f_{E} fE​ 以及一个对手 f A f_A fA​ 。对手 f A f_A fA​ 旨在从 f G f_{\mathcal G} fG​学习到的节点表示中预测已知或估计的敏感属性。 f G f_{\mathcal G} fG​ 旨在学习可以欺骗对手 f A f_A fA​ 做出错误预测的公平节点表示。 f E f_{E} fE​ 旨在为敏感属性未知的节点预测其敏感属性。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/943b06b4342d5349964834b8795abe4a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e815540d6b8852c1275e94312b24a5d3/" rel="bookmark">
			VuePress介绍及使用指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果对前端八股文感兴趣，可以留意公重号：码农补给站，总有你要的干货。 VuePress是一个基于Vue.js的静态网站生成工具，它专注于以Markdown为中心的项目文档。VuePress具有简单易用的特性，同时提供了强大的自定义和扩展性。在本文中，我们将介绍VuePress的基本概念，并提供一个简单的使用指南。
vuepress.jpg
什么是VuePress？ 官方文档地址： vuepress.vuejs.org/zh/
github地址：github.com/vuejs/vuepr…
VuePress是一个由Vue.js提供支持的静态网站生成器。它的主要特点包括：
基于Markdown： VuePress以Markdown为中心，使得编写文档变得简单而直观。Vue驱动： VuePress使用Vue.js进行开发，允许用户在Markdown中嵌入Vue组件，从而提供更强大的定制和交互性。默认主题： VuePress提供了一个现代化、响应式的默认主题，适用于各种文档项目。插件系统： VuePress具有灵活的插件系统，允许用户通过插件来扩展和定制网站的功能。 快速使用 虽然VuePress已经发布了v2.0的beta 版本，但是v2.0版本依赖的node版本必须大于 v18.16.0+,在linux上build的时候GLIBC_2.28版本也要2.28，会有一系列问题，所以我们选用的是相对稳定的v1.0版本。v1.0版本依赖的 Node.js (opens new window)&gt;= 8.6。
创建一个vuepress的文件夹 mkdir vuepress cd vuepress 使用你喜欢的包管理器进行初始化(建议使用yarn) 如果本地没用yarn 可先使用以下命令安转yarn
npm install -g yarn 初始化
yarn init # npm init 将 VuePress 安装为本地依赖 yarn add -D vuepress # npm install -D vuepress 注意： 如果你的现有项目依赖了 webpack 3.x，推荐使用 Yarn (opens new window)而不是 npm 来安装 VuePress。因为在这种情形下，npm 会生成错误的依赖树。
创建文档 mkdir docs &amp;&amp; echo '# Hello VuePress' &gt; docs/README.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e815540d6b8852c1275e94312b24a5d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c979f218a9e7f68c7340e3515e2dc00/" rel="bookmark">
			Open X-Embodiment 超大规模开源真实机器人数据集分享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		近期，Google旗下的前沿人工智能企业DeepMind汇集了来自 22 种不同机器人类型的数据，创建了 Open X-Embodiment 数据集并开源了出来。该数据集让他们研发的RT-2 机器人在制造和编程方式上有了重大飞跃。
有分析称，在上述数据集上训练的 RT-2-X 在现实世界机器人技能上的表现提高了 2 倍，而且通过学习新数据RT-2-X 掌握了很多新技能。英伟达高级人工智能科学家Jim Fan甚至公开表示，这个数据集可能是机器人的ImageNet时刻。
谷歌开放了X-具身存储库（robotics-transformer-X.github.io）来存储Open X-Embodiment数据集。这是一个开源存储库，包括用于X-具身机器人学习研究的大规模数据以及预训练模型的检查点。
为助力具身机器人技术研究，提高数据准备效率，OpenDataLab（opendatalab.com）整理并上架了DeepMind公开的Open X-Embodiment数据集，欢迎大家下载与探索。
另外寻星计划正在火热进行中，上传原创数据集领好礼，点击参加→寻找最闪亮的 OpenDataLab 数据之星， We want you !
数据集概述 Open X-Embodiment子数据集信息列表：
https://docs.google.com/spreadsheets/d/1rPBD77tk60AEIGZrGSODwyyzs5FgCU9Uz3h-3_t2A9g/edit?pli=1#gid=0
关键词：
● 21个科研机构
● 22个机器人
● 60个已有数据集的融合
● 527个技能
● 160,266个任务
● 1,402,930条数据（共约3600G）
数据处理：
所有源数据集统一转化为RLDS格式。
对于源数据的不同格式和内容，做了以下处理：
1. 对于存在多视角的数据集，仅选择其中“canonical”的一个视角图像（猜测为比较接近top-down第一人称视角/Proprioception的那一个）。
2. 将图像resize到320×256(width×height)。
3. 将原有的动作（比如joint position）都转换为EE的动作，但是该动作量可能为相对值，也可能为绝对值。在模型输出action tokens∈ [0, 255]\in [0, 255]后根据不同的机器人做不同的de-normalization后再下达具体的控制指令。
数据集特征：
1. 60个数据集中涉及到的机器人有单臂、双臂和四足，Franka占多数。
2. 数据量上，xArm占最大头，主要是language table的数据集体量很大，有44万条；Kuka iiwa主要来自于QT-Opt的贡献；另外就是原来在Everday Robot（现在论文中称为Google Robot）上采集的RT1的数据。
3. 技能上主要还是集中在pick-place上，整体仍呈现长尾分布，尾部有许多如wiping、assembling等难度更高的技能。
4. 主要的场景和被操作物体集中在家庭、厨房场景和家具、食物、餐具等物品。[1]
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0c979f218a9e7f68c7340e3515e2dc00/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b956b212bfeaba886b237f3f6f8892e2/" rel="bookmark">
			centos7防火墙关闭以及清除防火墙规则
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 关闭防火墙 查看防火墙状态 firewall-cmd --state 停止firewall systemctl stop firewalld.service 禁止firewall开机启动 systemctl disable firewalld.service 清除防火墙规则 iptables -F (flush 清除所有的已定规则) iptables -X (delete 删除所有用户“自定义”的链（tables）) iptables -Z （zero 将所有的chain的计数与流量统计都归零） 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b909ddc00904ec0e80a45fc1ed7cfc61/" rel="bookmark">
			输出日期格式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 请用程序实现: 输入年(year)、月(month)、日(day), 按照日期格式输出。
注意: 年、月、日均为整数。
示例输入(使用空格分隔多数据输入): 123 4 5 示例输出: 0123/04/05 #include &lt;stdio.h&gt;
int main () {
int year,month,day;
scanf("%d %d %d",&amp;year,&amp;month,&amp;day);
printf("%04d/%02d/%02d",year,month,day);
} 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3cb0a40ec65de1912ac0190259341f35/" rel="bookmark">
			mysql 主从复制与读写分离
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		主从复制概念
主mysql上的数据，新增，修改库，表，表里的数据，都会同步到mysql上，查不在此类
主从复制是单向的，只能从主复制到从，从数据库无法复制到主数据库器
主从复制的工作过程
1主节点的数据记录发生变化都会记录在二进制日志2Slave节点会在一定时间内对主库的二进制文件进行探测，看其是否发生变化，如果发生变化，从库他会开启一个I/O的线程请求master主库的二进制事件3主库会给每一个I/O的线程启动一个dump，用于发送二进制事件给从库，从库通过I/O线程获取更新，slave_sql负责将更新写入到从库本地，实现主从一至。 Mysql的主从复制的模式
异步复制 异步复制：mysql的默认复制就是异步复制(不管发送结果)，只要执行完之后，客户端提交事务，主mysql会立即把结果返回从服务器，主mysql并不关心mysql是否已经接收，并且处理。
主一旦崩溃，主mysql的事务可能没有传到从mysql，这个时候强行把从服务器提升为主，可能到新的主mysql，数据不完整（很少见，工作当中都是异步复制）
全同步复制全同步复制：主库执行完成一个事务，要等待所有的从库都执行了该事务之后才会返回客户端，因为需要等待所有从库全部执行完成，性能必然下降。（对数据一致性，和数据完整要求很好的场景）半同步复制 半同步复制：介于异步复制和全同步复制之间，主库执行完一个客户端提交的事务之后，至少等待一个从库接收并处理完成之后，才会返回客户端。半同步在一定程度上提高了数据的安全性，也会有一定的延迟。
这个延迟一般是一个tcp/ip的往返时间。(从发送到接收的时间，单位是毫秒)，半同步复制最好在低延时的网络中使用。
这边会有一个专业名词：时间&lt;1ms: round-trip time RTT
mysql主从复制延迟如何解决
硬件方面 主库一般不需要动的太多，从库配置要更好，提升它的随机写能力性能，比如硬盘可以换成固态
升级cpu核数，扩大下内存，尽量使用物理机（不要用云服务器）
网络层面主从服务器都配置在一个局域网内，尽量避免跨网段和跨机房架构方面读写分离，把写入控制在主库，从库负责读，降低从库的压力配置方面mysql配置从配置文件的角度实现性能最大化 追求安全性的双一设置
追求安全性的配置
innodb_flush_log_at_trx_commit=1
1每次提交事务时都会刷新事务日志，以确保持久性，这是最高级别的数据安全性，但是会影响性能，默认就是100就是事务提交时不会立刻刷新，而是每秒刷新一次，可以提性能，但是发生故障会导致数据丢失。22事务提交时，事务日志不会写入硬盘而是保存在系统缓存，也不会进行刷新，提供了一定的安全性能，但要求内存要求比较高Sync_binlog=111也是默认值，每次提交事务之后，直接把二进制日志刷新到磁盘，以确保日志的持久性，但会占用比较高的性能，但是安全性高0会把日志写入到缓存，也不会刷新日志，故障发生也会丢失数据，内存的要求也提高了N每提交了N次事务执行一次刷新到磁盘，提高性能，但是一旦崩溃，数据会大量丢失 追求性能化
sync_binlog=00设置为0表示二进制日志（binary log）写入操作系统缓存，但不进行物理刷新。
这提供了较高的性能，但在系统崩溃或断电时可能会导致未刷新的二进制日志数据的丢失2innodb_flush_log_at_trx_commit=2:
设置为2表示事务提交时将事务日志写入操作系统缓存，但不进行物理刷新。
这提供了一定的性能提升，但在系统崩溃或断电时可能会导致未刷新的事务日志数据的丢失。logs-slave-updates=0:
如果设置为0，表示不将从库的更新写入二进制日志。
这对于避免在主从复制中引入循环复制（circular replication）很有用 增大 innodb_buffer_pool_size
innodb_buffer_pool_size 控制 InnoDB 存储引擎的缓冲池大小。增大这个值可以提高 InnoDB 的性能，
因为更多的数据和索引可以缓存在内存中，减少了对磁盘的访问次数。但要注意，
设置得太大可能导致系统内存不足。
Innodb_buffer_pool_size 300M 500G
Innodb 存储引擎的缓存池大小，设置的s数值越高，可以提高innodb的性能
主从复制的问题
1只能在主库上发生变化，然后同步到从2复制过程是串行化过程，在从库上复制是串行的，主库的并行更新不能再slave从库上并行操作3核心意义：主从复制的设计目的就是为了实现读写分离，也就是在主库上写，在从库上查，读写分离，实现高可用 读写分离概念
1要实现读写分离，必须要先实现主从复制2读写分离：所有的写入操作都在主库，从库只负责读（select）。如果有更新，是从主库复制到从库 为什么要有读写分离
1数据库在写入数据时比较耗时（mysql写1w条数据要3分30秒）2数据库在读的时候，速度很快（读1w条只需要4.96秒）读写分离之后，数据库的写入和读取是分开的，哪怕写入的数据量比较大，但是不影响查询的效率。 什么场景需要读写分离
1数据库不是一定需要读写分离的，只有在某些程序在使用过程中，更新很少，查询较多，这种情况可以考虑读写分离，读和查的需求差不多，也可以考虑读写分离2生产库一般都会做读写分离3测试库一般不管4在工作当中，数据库的读写不会在同一个库中完成。既不安全也不满足高可用，也不能实现高并发。工作中都会做读写分离 Mysql读写分离的原理，如何实现的
根据脚本实现在代码当中实现路由分类，select insert 进行路由分类，这类方法是最多的特点性能好，在代码中就可以实现，不需要额外的硬件设备缺点开发实现的，跟我们无关，如果大型的应用复杂的应用，设计改动的代码非常多 基于中间层代理实现Mysql-proxy：自带的开源项目，基于自带的lua脚本，这些lua脚本不是现成的，要自己写，如果你不熟悉他的内置变量写不出来Atlas360内部自己使用的代理工具，每天的读写请求承载量可以到几十亿条，还支持事务，还支持存储过程Amoeba阿米巴 ：陈思儒，之前在阿里就职，由java开发的一个开源团建，他不支持事务，也不支持存储过程，但是amoeba 还是用的最多的，功能比较强大的软件 出现Slave_IO_Running: NO 原因
1网络问题2My.cnf 配置文件写错了3配置文件 CHANGE master to。。。 要么是文件名错了 ，要么是配置文件错了4防火墙策略问题 主从复制延迟问题
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3cb0a40ec65de1912ac0190259341f35/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d220acba7eb289a09f73fba5c13a75b5/" rel="bookmark">
			安装MinGW并在codeblocks下使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、下载安装MinGW 1.下载MinGw安装器，下载地址 2. 安装 下载下来的知识一个安装器，我们双击安装会帮我们自动下载好相关文件
安装完成后会打开一个安装管理工具，在这个工具中我们选中想要安装的软件包然后安装到本地
选好以后在菜单栏选择 Installation-&gt;Apply changes 就会开始自动安装选中的包，安装好后就会在bin目录下看见安装好的exe可执行文件，也可以把bin文件夹添加到环境变量下
二、在codeblocks下使用 安装好mingw后就可以在设置下编译器设置中的工具链设置中选择mingw使用
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5fe81fda11ea997010ae5f5203a9f889/" rel="bookmark">
			若依分离版——使用Knife4j 自动生成接口文档
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景： 前后端分离程序，如果需要前端开发人员和后端开发人员配合开发，则需要将接口文档并显性给前端人员
解决办法： 使用knife4j替代若依自带的swagger，因为knife4j是在swagger基础上包装的，Knife4j不仅具备友好的界面，而且使用简单，还提供了增强功能如接口测试和Mock数据生成，可大大提高开发人员的工作效率。
效果如下：
具体步骤： 1、ruoyi-admin\pom.xml模块添加整合依赖
&lt;!-- knife4j --&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.xiaoymin&lt;/groupId&gt; &lt;artifactId&gt;knife4j-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.0.3&lt;/version&gt; &lt;/dependency&gt; 2、修改ry-ui\views\tool\swagger\index.vue跳转地址
url: process.env.VUE_APP_BASE_API + "/doc.html", 3. 修改ruoyi-admin/src/main/java/com/ruoyi/web/core/config/SwaggerConfig.java的
createRestApi函数，注释掉.pathMapping(pathMapping); 4.登录系统，访问菜单系统工具/系统接口，出现如下图表示成功。
5. 给SysUser类中的的字段添加 @ApiModelProperty(value = "用户序号", required = false)
/** 用户ID */ @ApiModelProperty(value = "用户序号", required = false) @Excel(name = "用户序号", cellType = ColumnType.NUMERIC, prompt = "用户编号") private Long userId; /** 部门ID */ @ApiModelProperty(value = "部门编号", required = false) @Excel(name = "部门编号", type = Type.IMPORT) private Long deptId; 6.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5fe81fda11ea997010ae5f5203a9f889/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e3cb5df556f9a170767c819046aec6d/" rel="bookmark">
			Shiro快速入门之二
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前言 Shiro快速入门之一 介绍了Shiro三大核心组件，四大核心功能，以及一个简单的Test Demo，接下来两篇我会用一个比较完整的例子来讲述Shiro的认证及授权是怎么做的，本篇侧重于介绍认证的过程
二、Shiro认证例子 1、例子概述 使用SpringBoot+ThymeLeaf+Jpa搭建的例子
ThymeLeaf 是一个和Velocity差不多的模板引擎，如果不是前后端分离的项目，页面可以用SpringBoot官方推荐的ThymeLeaf模板，使用ThymeLeaf还可以解决发送HTML邮件内容拼接的问题，具体可看 从一坨代码说起。
Jpa是Java Persistence API，它需要Provider来提供实现，Hibernate是JPA Provider 最强一个实现。 注：后续会整理一篇介绍一下tk-mybatis、mybatis、jpa的区别。
2、pom.xml 用spring.io快速创建springboot project，然后加入依赖
spring-boot-starter-web
spring-boot-starter-thymeleaf
spring-boot-starter-data-jpa
mysql-connector-java
shiro-spring
3、application.properties 配置数据库连接和ThymeLeaf
spring.jpa.properties.hibernate.hbm2ddl.auto=update
注：该行设置为update，加载时会根据model类自动建立表结构，用jpa做demo这点还是很方便的，不用自己创建表结构。
对于配置文件spring.jpa.properties.hibernate.dialect，要写一个MySQLConfig来设置字符集。
4、实体类 权限类
角色类
用户类
注：创建三个实体类 权限类、角色类、用户类，并设置好关联关系，权限与角色多对多，角色与用户多对多，这样在应用启动后会自动创建5张表。
permission、role、role_permission、user、user_role，但数据库还是需要先创建好的，表是会自动创建。
初始化一条数据到用户表，用于测试。
5、UserService、Dao类 6、MyShiroRealm 自定义的Realm实现，主要实现两个方法一个是认证，一个是授权
上面这段就是认证（登录）的代码，先获取用户登录输入的账号（注：登录的代码subject.login(token);会调用该方法），然后到数据库中根据用户名获取用户对象信息，再用从数据库获取的信息（密码，salt）来构造SimpleAuthenticationInfo对象。
注：授权代码下篇再讲
7、ShiroConfig 注：配置Shiro过滤器，哪些地址不拦截，哪些地址要拦截,需要注意顺序，以及登录页地址，成功或失败后跳转页面地址。
注：将自定义的MyShiroRealm设置到SecurityManager中。
8、UserController
登录认证Controller，调用subject.login(token)进行认证，成功或失败后跳到对应的页面。
login.html
index.html
三、总结 用Shiro写认证代码，第一步要先实现Realm的认证方法，将从数据库查出来的密码，salt设置到AuthenticationInfo对象中，在用户登录时会将输入的用户名密码传给SecurityManger，然后进行比对用户名和密码是否正确。
核心代码，判断realm对象是否支持用户的token。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e7bcb8fc736f122d953e4cdc2b5250c/" rel="bookmark">
			Shiro快速入门之一
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前言 Java有两个出名的安全框架，一个是Apache Shiro，另一个是Spring Security ，相对而言Shiro更简单、控制权限的粒度可粗可细，我们项目中使用的是Shiro。
二、概念 Shiro最主要的功能是验证用户身份和用户访问权限控制，比如判断用户是否分配了一个角色，或判断用户是否有完成某个操作的权限等。它不会去维护用户与权限，这需要我们自己提供接口然后注入给Shiro。
1、三大核心组件 subject 主体，可以是用户也可以是程序，主体要访问系统，系统需要对主体进行认证、授权。
securityManager: 安全管理器，主体进行认证和授权都是通过它进行。
realm 领域,可以理解为DAO，通过它存取认证、授权相关数据。
2、四大核心功能 Authentication 认证即登录，用于用户身份识别。
Authorization 授权即访问控制，判断用户是否有权限去访问受保护的资源。
Cryptography 通过加密算法保护数据安全。
Session Management 会话管理，即用户访问你应用自身携带的数据，甚至可以在非Web程序上使用。
三、最简单例子 1、build.gradle
2、AuthenticationTest.java
Shiro认证过程
1、调用subject.login(token)进行登录，其会委托给SessionManager，调用之前必须通过
SecurityUtils.setSecurityManager进行设置。
2、SecurityManager负责真正身份验证逻辑，它会委托给Authenticator进行身份验证。
3、Authenticator是真正的身份验证者。
DelegatingSubject.java
DefaultSecurityManager.java
AbstractAuthenticator.java
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2124c666d9ea3d9500661fa482fbdf68/" rel="bookmark">
			Session、Token、Jwt三种登录方案介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		新开发一个应用首先要考虑的就是登录怎么去做，登录本身就是判断一下输入的用户名和密码与系统存储的是否一致，但因为Http是无状态协议，用户请求其它接口时是怎么判断该用户已经登录了呢？下面聊一个三种实现方案。
一、传统session方案 这种方案在以前前后端架构不分离的时候采用的，基于客户端Cookie和服务端Session来做，基本流程如下
1、用户登录成功后查询数据库取出用户信息放到Session中。
2、服务端往客户端浏览器写Cookie，Cookie里存放加密的用户名，一般用3DES搞搞就可以，如果是非交易网站，甚至有直接明文或只做一下Base64.
3、用户请求接口时浏览器会把Cookie发送给服务端，服务端拿到这个Cookie解析出用户名，然后根据用户名获取Session里用户对象信息.
4、如果应用部署在多台服务器，需要做Session同步，这里一般有两种做法，一种是通过容器（Tomcat）本身进行Session复制，但存在一个问题，当用户量大的时候，每台服务器重复存放大量的Session对象，会占用大量的内存，另外一种做法是写一个拦截器，用户在A机器登录后会在当前服务器生成Session，然后用户下一个请求被路由到机器B，这时需要做Session的恢复，解析出Cookie中用户名查找到用户数据然后放到Session里去，该用户下次请求如果还是路由到该台机器就不用再查数据库了。
缺点
1、Session存在内存中，用户多会占用大量应用服务器的内存.
2、Cookie安全性，如果Cookie被截获，很容易造成跨站请求伪造脚本攻击.
3、前后端分离的应用无法使用Cookie
PS:十几年前跟着大牛做过这个事情，在整理文章时，花了点时间才慢慢回忆起来。
二、token+redis方案 当前公司的收银系统采用的就是该方案，具体实现流程如下：
1、用户登录成功后生成一个Token，Token的生成依赖于Linux系统的urandom，然后将token和查询出来的用户对象数据存到redis中 token做为key，value存用户对象，并将token返回给客户端，redis设置过期时间12小时。
cat /dev/urandom |od -x | tr -d ' '| head -n 1 2、客户端拿到Token，存到localStorage里，然后写一个通用的请求拦截,在每次请求时http头加上token值。
3、服务端写一个注解NeedLogin，需要登录的接口加上该注解.
4、服务端写一个拦截器，判断请求的方法上有没有加NeedLogin注解，如果没有注解则返回，如果有注解则从Http请求头中把Token拿出来，判断该Token是否存在，存在则认为是处于登录状态的。
5、接口调用时需要根据Token值从Redis中获取用户对象数据
优缺点：服务端可以主动让Token失效，但用户信息存在Redis占用一定空间并且需要一次redis查找(PS：好像不不算什么缺点)，属于中心化方案。
三、Jwt方式 当前公司在线窗帘定制网站采用的是该方案，Jwt即Json Web Token，实现流程和Token方案基本一样，区别在于用户信息保存在Jwt中，客户端每次请求都会把Jwt带过来，服务端从Jwt解析出用户对象数据。
Jwt的组成
header：声明类型及签名算法，做Base64。
playload: 包括注册的声明（签发时间/过期时间/面向的用户）、公共和私有声明，内容也仅只做Base64编码.
sign：base64（header)+base64(playload)+secret
优缺点：该方案跨语言、另外payload可以存放非敏感用户数据以减少数据库或缓存查询、它不需要服务端保存会话信息、应用易于扩展、但服务端无法主动让Jwt失效，因为数据安全性尽可能使用https协议。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5dc93539eec556fc8704974b77895b5/" rel="bookmark">
			基于深度学习的HRNet-YOLO的花卉图像识别系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.研究背景与意义 项目参考AAAI Association for the Advancement of Artificial Intelligence
研究背景与意义
随着计算机视觉技术的快速发展，图像识别已经成为了人工智能领域的一个重要研究方向。图像识别技术在各个领域都有广泛的应用，其中之一就是花卉图像识别。花卉图像识别可以帮助人们快速准确地识别花卉的种类和特征，对于植物学研究、园艺种植、生态环境保护等方面都具有重要的意义。
传统的花卉图像识别方法主要依赖于手工设计的特征提取算法和分类器，这些方法在一定程度上可以实现花卉图像的识别，但是存在着一些问题。首先，手工设计的特征提取算法往往需要人工经验和专业知识，对于不同的花卉种类和特征可能需要不同的特征提取算法，这给算法的设计和实现带来了一定的困难。其次，传统的分类器在处理大规模的花卉图像数据时，往往需要大量的计算资源和时间，无法满足实时性的要求。此外，传统的方法对于花卉图像中的遮挡、光照变化等问题也比较敏感，识别准确率有限。
基于深度学习的图像识别方法在解决上述问题上具有很大的优势。深度学习模型可以自动学习图像的特征表示，不需要手工设计特征提取算法，大大减轻了算法设计的难度。同时，深度学习模型可以通过大规模的训练数据进行训练，可以充分利用计算资源，提高识别的准确率和效率。此外，深度学习模型对于图像中的遮挡、光照变化等问题也具有一定的鲁棒性。
HRNet-YOLO是一种基于深度学习的目标检测算法，它结合了高分辨率网络（HRNet）和You Only Look Once（YOLO）的思想，可以实现对花卉图像中花卉目标的准确检测和识别。HRNet-YOLO具有多尺度特征融合和全局上下文信息的建模能力，可以有效地解决花卉图像中的遮挡、光照变化等问题，提高识别的准确率和鲁棒性。
因此，基于深度学习的HRNet-YOLO的花卉图像识别系统具有重要的研究意义和应用价值。通过研究该系统，可以实现对花卉图像的自动化识别和分类，为植物学研究、园艺种植、生态环境保护等领域提供有力的支持。此外，该系统还可以应用于花卉市场、花卉展览等场景，提供快速准确的花卉识别服务，提升用户体验和商业价值。因此，研究基于深度学习的HRNet-YOLO的花卉图像识别系统具有重要的理论和实践意义。
2.图片演示 3.视频演示 基于深度学习的HRNet-YOLO的花卉图像识别系统_哔哩哔哩_bilibili
4.数据集的采集＆标注和整理 图片的收集 首先，我们需要收集所需的图片。这可以通过不同的方式来实现，例如使用现有的公开数据集FlowerDatasets。
下面是一个简单的方法是使用Python脚本，该脚本读取分类图片文件，然后将其转换为所需的格式。
import os import shutil import random # 指定输入和输出文件夹的路径 input_dir = 'train' output_dir = 'output' # 确保输出文件夹存在 if not os.path.exists(output_dir): os.makedirs(output_dir) # 遍历输入文件夹中的所有子文件夹 for subdir in os.listdir(input_dir): input_subdir_path = os.path.join(input_dir, subdir) # 确保它是一个子文件夹 if os.path.isdir(input_subdir_path): output_subdir_path = os.path.join(output_dir, subdir) # 在输出文件夹中创建同名的子文件夹 if not os.path.exists(output_subdir_path): os.makedirs(output_subdir_path) # 获取所有文件的列表 files = [f for f in os.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f5dc93539eec556fc8704974b77895b5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b69ccf22d51adfb25b009d7d8b744f8f/" rel="bookmark">
			【C&#43;&#43;学习笔记】编译优化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C++在编译时可以添加优化选项，有4个优化级别
-O1：基本优化，删除无用的代码，减少局部变量存储，常量折叠等-O2：包含-O1的所有优化，并增加循环展开、常量折叠、公共子表达式消除等。-O3：包含-O2的所有优化，并增加更多的循环展开、向量化等。-O4：包含-O3的所有优化，并增加更多的数学优化。 综上，编译器的自动化优化技术包括：
常量折叠和传播：编译器可以在编译期间将常量值折叠和传播到代码中，以减少运行时计算开销。循环展开：编译器可以将循环展开，以减少循环控制开销和提高指令级并行度。公共子表达式消除：编译器可以识别并消除重复计算的公共子表达式，以减少计算开销。向量化：编译器可以将数据拆分为向量，并使用SIMD指令执行并行计算，以提高处理器的计算效率。内联展开：编译器可以将函数内联展开，以减少函数调用开销和提高指令级并行度。内存访问优化：编译器可以重新组织数据结构或使用缓存等技术，以减少内存访问开销和提高缓存命中率。 除此之外，程序员也要注意写代码时的技巧，帮助优化代码：
避免冗余计算、减少函数调用（inline）、循环展开、使用合适数据结构和算法
https://mp.weixin.qq.com/s/RSkBAKmo2qWcyq80KkIaYw
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e299d00cbbf6f31af8aaa43e10a921c/" rel="bookmark">
			51单片机 动态、静态数码管显示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.数码管在51上的显示及介绍：
数码管又称作LED数码管，是一种简单、廉价的显示器，是由多个发光二极管封装在一起组成的“8”字型器件；
上面的共阴极连接；下边的共阳极连接；也就是发光二级管的阳极连接在一起，发光二级管的阴极连接在一起；
数码管的引脚连接方式；
一位数码管：
注意：8个引脚对应A B C D E F G DP；分别对应数字“8”的7个位置，所以想要使数码管显示出自己想要的数字，只需让对应位置的灯亮即可；
共阳极是低电平0亮；共阴极是高电平1亮；
四位一体数码管：
类似于我们51单片机上的数码管（4个放在一起的）；
四位一体的数码管有12个引脚；上边的连接方式叫共阴极连接；下边的连接方式叫共阳极连接；
共阴极是高电平1不亮；低电平0亮；（只是四位中让哪个亮，选择其中一个之后在按照1位的高电平1亮，低电平0不亮去设置）
注意：在同一时刻，只能有一个数码管被点亮，即使有多个被点亮，也只显示同一个一位指令；
2.数码管第三个位置显示为6：
首先注意：给到位的输出信号一定是高位对高位；也就是说右边给到信号是1011110 从上到下对应的引脚是一次升高的，转换到LED输出接口P0时，一定是从下往上，高位对应到高位；
第三个灯是LED6（灯的序号排序是从右往左的 8 7 6 5 4 3 2 1）LED 6对应的是74HC138译码器的Y5接口，5转换成二进制位是101；连接芯片的译码器上有P22、P23、P24三个输出接口，来输出二进制位信号；
想让数码管显示出相应的数字，需要按照a b c d e f g dp来控制高低电位；高位对高位；LED显示6；所以是a b c d e f g dp=1 0 1 1 1 1 1 0；高位对高位=0 1 1 1 1 1 0 1；转换成十六进制位输出=0x7D；
#include &lt;REGX52.H&gt; #include &lt;INTRINS.H&gt; void main() { P2_4=1; P2_3=0; P2_2=1; P0=0x7D; while(1) { } } 根据原理图可得：74HC138译码器连接8个LED引脚，有3个输出接口，分别是P2_2; P2_3 ; P2_4;分别接译码器的Y引脚的二进制数，例如：LED6接到译码器上对应Y5；5转换成二进制数为101；分别接到三个输出接口P2_2; P2_3 ; P2_4上，P0对应动态数码管的输出接口，要按照a b c d e f g dp来控制高低电位；高位对高位；LED显示6；所以是a b c d e f g dp=1 0 1 1 1 1 1 0；高位对高位=0 1 1 1 1 1 0 1；转换成十六进制位输出=0x7D；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9e299d00cbbf6f31af8aaa43e10a921c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4be0484ae99cf3b71f492089c6f00df3/" rel="bookmark">
			SpringBoot实现汉字繁体转化成简体功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先，在pom.xml中添加依赖： &lt;!-- Hutool工具类 --&gt; &lt;dependency&gt; &lt;groupId&gt;cn.hutool&lt;/groupId&gt; &lt;artifactId&gt;hutool-all&lt;/artifactId&gt; &lt;version&gt;5.7.10&lt;/version&gt; &lt;/dependency&gt; 在Spring Boot的配置文件application.properties中添加配置： # 设置hutool的字符集为UTF-8 hutool.setting.charset=UTF-8 创建一个Controller类，添加一个将繁体汉字转为简体汉字的方法： @RestController @RequestMapping("/api") public class ConverterController { @PostMapping("/convert") public String convert(@RequestBody String input) { return StrUtil.convertChar(input, CharsetType.TRADITIONAL_CHINESE, CharsetType.SIMPLIFIED_CHINESE); } } 测试转换是否成功，在浏览器或Postman中输入以下地址： http://localhost:8080/api/convert 然后在Body中输入繁体汉字，点击发送即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8ccf50842868ff0211b92d5b5d6ab50/" rel="bookmark">
			goframe v2版本报错redis adapter is not set, missing configuration or adapter register?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		goframe v2版本报错redis adapter is not set, missing configuration or adapter register? 2.3.0版本开始，redis需要像mysql一样，手动导入包
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3980c46a5bb7c003e73b5c937ee19d0/" rel="bookmark">
			教职工信息管理系统设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 绪论
1.1管理信息系统简介
1.1.1管理信息系统的含义
管理信息系统即MIS（Management Information System）在强调管理、强调信息的现代社会中变得越来越普及。MIS是一门新的边缘学科，它跨越了若干个领域如管理系统科学、系统科学、运筹学、统计学科及计算机科学，在这些学科的基础上形成信息收集和加工的方法。从而形成一个纵横交错的系统。它能提供信息，支持企业或组织的运行、管理和决策功能。
1.1.2管理信息系统的发展
管理信息系统起源于20世纪50年代开始的基于计算机的电子数据处理（简称EDP，Electronic Data Processing）。EDP的主要目标提高一个组织内管理工作如计算、统计、制表、报告等工作的效率。此时利用计算机处理管理信息的方式是单项管理，到了20世纪60年代管理信息系统得到了较快的发展，成为实现组织整体目标，系统综合地处理各类管理信息支持各级管理决策的计算机硬件、软件、通信设备、规章制度及有关人员的统一体、其获取信息资源和管理、服务的范围更加广阔；20世纪90年代，人们对MIS的注意力不再只是信息技术的应用，而是为如何合理配置、有效利用信息资源以求得组织目标的实现。至此，MIS的发展经历了一个由技术管理到资源管理的过程。
1.2开发背景简介
1.2.1教育系统教职工信息管理现状
任何的管理首先是对人力资源的管理，学校也是一样。一直以来，学校无论是在教学还是在管理方面都提出了要创新、要全面推进素质教育，学校经常要对学生和教师进行各种数据的统计以供分析使用，然而由于计算量非常大，通过人力去登记、计算、查找，正确率无法保证，而且还会耗费大量的人力和物力；长年累月积攒起来的材料过多，不易保存，也容易丢失和损坏。这就出现了一个矛盾。如何找到一种好的办法既提高准确率，又可以省去大量的人力物力，而且还可以使材料积累起来供以后综合分析使用呢？在当今社会，以高科技为标志的经济飞速发展的今天，选用现代化手段解决上述问题是再适合不过的了!于是，在教育领域建立一系列信息管理系统就显得非常有必要了。
随着信息活动在国民经济中主导地位的确立和信息产业的崛起信息资源管理（Information Resources Management，简称IRM）作为一个专有名词和独立的学科逐渐发展起来。如何积极开发、合理配置和有效利用信息资源，日益成为社会生活中亟待解决的问题。由于计算机和通信技术的高速发展，推广应用计算机进行信息、管理成为推动信息化工作的重要内容，管理信息系统正是应用计算机信息化过程中出现的新生事物。它是一个利用计算机软硬件资源进行电子数据处理的人机系统，它能提供信息，支持企业或组织的运行，具有管理和支持决策的功能利用计算机能把生产经营过程中的巨大数据流收集组织起来。经过处理转换为对各部门不可缺少的数据，经过对这些数据的分析使其变为各级管理人员做出决策具有重要意义的信息。总之，管理信息系统用于管理中可以大大减轻管理人员的工作负担，提高工作效率，使管理更加程序化、科学化。
对一个组织而言，内部管理的好坏直接关系到组织的存在与良好运行，而内部管理中非常重要的一项就是对人的管理，人事档案及教学业务的管理是与人事管理有关的文件记录。一旦工作人员的职位、职称及其他情况发生变化，要及时在档案内补充材料，以确保档案材料基本反映工作人员的工作、生活等各方面的实际情况；同时也要及时对其工作情况进行调整。人事管理往往是繁琐的，因为要管理的对象种类繁多，要对其进行各种各样的管理，工作量大，又容易出错，在人事管理中引入计算机管理信息系统，可以提高工作效率，改善管理情况，使管理工作系统化、科学化、提高整体的管理的水平。
本系统是针对学校教职工管理编写的。在学校，一般管理者已经认识到计算机在管理过程中为可取代的作用，但是应用计算机来进行管理，他们还无法自己实现，这就需要有专门的管理软件来帮助实现。
1.2.2本系统要解决的几个关键问题
(1)采用单位现有软硬件环境及先进的管理系统开发方案，从而达到充分利用单位现有资源提高系统开发水平和应用效果的目的。
(2)系统应符合组织人事管理的规定，满足单位日常人事管理工作需要，并达到操作过程中的直观、方便、实用、安全等要求。
(3)采用模块化程序设计方法，既便于系统功能的各种组合和修改，又便于补充维护。
(4)系统应具备数据库维护功能，及时根据用户要求进行数据的添加、删除、修改、查询和报表打印等。
①教职工基本档案的输入、修改。包括各种教育背景、工作简历、科研情况、教学业务、论文发表、获奖情况等。
②教职工的增加、删除。转出、辞职、退休教职工信息的删除，调入、新增教职工信息的增加。
③查询、统计。按照某种条件，查询、统计符合条件的教职工信息。
④打印输出。对查询、统计的结果打印输出。
⑤保密系统。对系统进行保密设定，可以修改用户名和密码，以防止有人对系统数据进行破坏和窃取，设置管理员和普通用户。
要想解决上面的问题首先需要和使用此软件的管理人员进行全面的沟通，需要了解信息管理的管理内容、管理过程、管理步骤等一系列流程，还要和管理人员交流管理上的一些处理的习惯性问题，要使得软件特别的接近使用者的管理习惯和方式。使管理工作规范化和程序化，促进整体管理水平的提高，高效完成学校教职工管理的日常业务。使人事管理及其相关方面的科学决策，如教学、科研等。
1.2.3教育系统教职工信息管理的特点及解决途径
教职工的工作情况有其独特的行业特点，目前通用人事管理软件和通用信息管理软件均不能完善的解决其信息管理方面的问题，因此需要有针对性的制作定一套工资管理软件。
教职工一般的基本信息，还有教学业务，科研信息，发表论文，获奖情况等等都是和其他行业有着明显的区别，要想解决这个不同就需要专门的信息管理系统，设置不同于其他行业的软件，方便学校使用。
2 系统分析
2.1系统调查
新系统的系统分析与设计工作都要建立在对现行系统调查的基础上。即必须调查清楚信息系统的资源、输入、处理和输出，明确用户需求和目的是明确系统开发的目标和规模。
本人所在单位是一所综合性大学院校，本着从实际情况出发的观点，对该校的院系教职工管理进行了全面的调查。
2.1.1教育系统的各级各类学校有其自身的特点。
长江大学是一所高等综合类学校，在很多方面与一般的普通中小学校不同，学校开设的专业可能几年就要改变或者修改和增加，致使教师所教的科目也有可能变化和调整，从而需要的教师要多元化，可能从事几门课程的讲授。这就需要经常进行人才的流动，如校区间的调整、对外招聘、接收硕士毕业生。人事管理涉及到新人员的加入，老员工的转出、辞职、退休等，员工基本情况变化要随时更新，因此在管理方式上有很大区别，管理的难度上也比一般的普通中小学校要大的多。
2.1.2教育系统正全面推进人事制度改革。
学校每年要进行职称的评定以及评优、评先等情况，需随时查阅职工的相关资料，查询符合条件的人员，进而统计产生相应报表。由于该校的信息管理主要方式是基于文本、表格等纸介质的手工处理，人员多、项目多，所以管理工作量大，容易出错，缺乏系统的、规范的信息管理手段。
2.1.3计算机已经进入各级管理机关。
现在，上级主管部门的有些方面已经实行了计算机管理，所以在很多时候上报材料要求采用电子文档的方式。而每次都将做一些重复的、繁琐的录入工作，以便产生不同的报表，因此工作量大，容易出错，急需系统的、规范的信息管理手段来解决。
2.1.4系统的设计要具有人性化的特点。
（1）界面友好、操作简便。
对于信息管理人员，由于平时接触计算机的机会较少，所以对计算机的操作比较生疏，所以说对于管理信息系统的可操作性一定要强，软件的交互性必须要好，可使使用者，即使在对计算机不很熟悉的情况下也可以很快的接受它，这就需要在对软件进行设计时考虑到用户界面的友好交互性，这一点很重要。在系统的使用过程中，有很大一部分是对基本数据的录入，录入的信息的量也是很大的，所以要求软件的输入设计符合操作人员的思维习惯和操作习惯，在本软件的设计过程中将考虑录入部分完全使用键盘操作，这样将大大提高操作人员的效率。由于录入操作非常的枯燥，所以在背景设计时需要考虑到添加清淡的让使用者心情放松的图案或颜色，这可以使操作者的烦躁心情得以环节，以减小在数据录入过程中误差和错误的出现概率。
（2）功能强大、程序流畅。
在实际管理中，要随时进行各种资料的查询、统计，所以要求软件的功能设计要完成各种操作。同时，在实际管理中是院系的人员在不同的时间，不同的地点进行的承担着各自的职责进行着数据处理和信息交换。上述的数据处理和交换均由计算机软件来执行，所以要求程序始终是流畅的。
（3）一看就懂、拿来就用。
在界面上使用人们平时熟悉的自然语言，而把陌生的计算机语言隐藏起来，达到计算机程序与人的主观意识和思维天衣无缝的吻合，表现了天地人和。使操作者一看就明白。软件还必须简洁明了地提供操作向导和必要的提示，使人事工作者做到拿来就用。
该校希望通过建立教职工信息管理系统，使管理工作规范化和程序化，促进整体管理水平的提高。因此提出系统的设计目标：
①支持实现规范化管理。
②支持组织高效完成信息管理的日常业务，包括：新员工加入时信息档案的建立、老员工转出、辞职退休、科研、教学基本情况变更等。
③支持学校进行信息管理及其相关方面的科学决策，如评优、评先等。
2.2可行性分析
2.2.1经济可行性
学校经常要教师进行各种数据的统计，以供分析使用。由于早期信息管理系统完全采用纯人工方式完成工作，进行报表制作，且上传下递极不方便、快捷，所以耗用工时较多，且效率低下。后来设计一些简单的应用表格，能通过计算机报表，但只是人工去登记、查找、计算大量数据后，人工输入计算机，制成表格，打印出表格上报，所以也会统计差错，输入过程差错，正确率无法保证，而且还会耗费大量的人力和物力；长年累月积攒起来的材料过多，不易保存，也容易丢失和损坏。
目前，市场上“信息管理系统”类的软件开发出产品的比较少，且价格高，单机版价格在万元以上，网络版价格要几万元。一般的学校经费紧张根无法接受这样的价格。而软件的规模太大，有些模块根本用不到，所以购进之后部分功能闲置也构成了浪费。
2.2.2操作可行性
我校信息管理人员具有高学历、高水平、对外来的新事物接受能力快的特点，并且接受过教育系统的计算机等级培训，对Windows有基本的了解，所以，如果开发一套操作简单的教职工信息管理系统，完全可以帮助他们从繁琐的重复性劳动中解脱出来，以提高的工作效率。
2.2.3技术可行性
（1）开发的软件可行性
从目前市场上比较流行的数据库开发、管理软件来看，对于比较简单的中小型数据库，asp.net是在实际应用中较为成功的一种解决方案。并为用户提供了Windows所一贯坚持的非常友好、操作简单的用户界面、完善而强大的数据库操作功能，简洁明了的数据库，进而可对数据库实施操作、维护和权限识别功能。
结合实际情况，可以设计出符合实际需求、易于理解、易于操作、易于维护的数据库和操作系统。对于Visual studio 2005而言，管理这种规模和复杂程度的数据库是游刃有余的。同样对于asp.net来说，无论是查询、统计还是利用数学公式进行趋势预测，都能顺利完成。因此，开发实施本系统，从软件角度看是可行的。
（2）开发的硬件可行性　开发本系统所使用的软件对于计算机硬件有一定的要求，特别是，Visual studio 2005对计算机的内存、主频、外频、外存（主要是硬盘的容量）都有比较高的要求，否则将影响到本系统的正常运行，甚至导致数据计算的失误等比较严重的错误，基本要求是：Microsoft Windows9X或更高版本；80486或更高的微处理器；Microsoft Windows支持的VGA或更高分辨率的显示器；应用程序要求8MB RAM，Visual studio 2005开发环境要求256MB RAM。Visual studio 2005对系统配置的要求较低。因此，从市场上目前流行的硬件水平来看，一般学校已经具备了使用此类软件的基本硬件条件。特别是以计算机为主要专业的大学院校已有现成的软、硬件条件。本系统的开发也是可行的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d3980c46a5bb7c003e73b5c937ee19d0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc5008a2309c5acebd779a439f7f5cab/" rel="bookmark">
			死锁（JAVA）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		死锁在多线程代码中是非常严重的BUG，一旦代码中出现死锁就会导致线程卡死。
当单个线程连续两次对同一个对象进行加锁操作时，如果该锁是不可重入锁就会发生死锁（线程卡死）
两个线程两把锁，如果出现这种情况也是会发生死锁：线程t1已经获取了锁A，线程t2已经获取了锁B，此时t1想要获取锁B，t2想要获取锁A。
Object lock1 = new Object(); Object lock2 = new Object(); Thread t1 = new Thread(()-&gt;{ synchronized(lock1) { try { Thread.sleep(1000); } catch (InterruptedException e) { throw new RuntimeException(e); } synchronized(lock2) { } } }); Thread t2 = new Thread(()-&gt;{ synchronized(lock2) { try { Thread.sleep(1000); } catch (InterruptedException e) { throw new RuntimeException(e); } synchronized(lock1) { } } }); t1.start(); t2.start(); //让主线程等待 2 秒 Thread.sleep(2000); //此时t1和t2两个线程会因为互相争对方的锁，而导致死锁 System.out.println(t1.getState()); System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bc5008a2309c5acebd779a439f7f5cab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4b705b7113c779b7fed6dc33575544a/" rel="bookmark">
			vulfocus靶场轻松搭建（centos7&#43;docker环境）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		搭建过程虽然简单，但也有些坑，经过摸索终于可以正常使用了，特记录下来分享给大家。
一、虚拟机中安装centos7(过程省略)
二、centos7中搭建docker运行环境
１．在Centos7进行安装前，可以使用以下命令查看CentOS版本
cat /etc/redhat-release
２．在 CentOS 7安装docker要求系统为64位、系统内核版本为 3.10 以上
uname -r
３．查看是否已安装docker列表
yum list installed | grep docker
４．安装docker
yum -y install docker
-y表示不询问安装，直到安装成功，安装完后再次查看安装列表
５．启动docker
systemctl start docker
６．查看docker服务状态
systemctl status docker
出现以上，说明docker安装成功！
７．查看docker版本
docker version
８．设置docker开机关机和自启动
开机自启动:
systemctl enable docker
９．配置docker镜像，源：
vi /etc/docker/daemon.json
按ｉ键进入编辑状态
{ "registry-mirrors": ["https://ckib1ecu.mirror.aliyuncs.com"] } 按ESC键退出编辑
输入　：ｗｑ保存退出。
sudo systemctl daemon-reload sudo systemctl restart docker 三、拉取vulfocus镜像
坑１：使用说明文档中方法，会导致安装成功后“一键同步镜像”报错，据说原因是此方式安装的不是最新版数据库。
docker pull vulfocus/vulfocus:latest 正确方法：
docker pull vulfocus/vulfocus:0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d4b705b7113c779b7fed6dc33575544a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4aa0f207af6ceb85d9eefb48e0547ee/" rel="bookmark">
			easyExcel导入导出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
EasyExcel工具类
pom导入依赖
1.相关代码
1.1 EasyExcel导出工具类
1.2CommonListener导入侦听器
1.3CustomMergeStrategy 合并策略(已改)
1.4 DownHandler 下拉处理(已解决大数据问题)
1.5 CustomMerge 合并单元格的注解
1.6 FieldDispose 导入自定义解析注解
1.7 DropDown 下拉注解
1.8 ExcelFieldType自定义数据解析常量
1.9 标题合并
2 .使用方法
2.1 导出导入实体--注解使用
2.2 Controller
2.3 service 调用
2.4 自定义批量方法 EasyExcel工具类 项目中常见的导出 一般使用 EasyExcel/POI，这里简单的列出了easyExcel 的用，easyExcel 使用简单方便，内存占用低，不会导致oom，不过导入导出要求多的话，写解析器也难受，哎本来写了很多的，结果好多找不到，然后暂时又没用到。在这里取出了常用的一些工具类，导出添加下拉框，单元格合并，多sheet导出等。导入则通过注解 解析字典值或校验唯一值，通过自定义的批量方法每500条插入一次
pom导入依赖 &lt;!--excel导入导出--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;easyexcel&lt;/artifactId&gt; &lt;version&gt;2.2.6&lt;/version&gt; &lt;/dependency&gt; 1.相关代码 1.1 EasyExcel导出工具类 /** * Excel相关处理 * @author pw */ public class ExcelUtil { /** * 单个sheet页导出 */ public static void writeExcel(HttpServletResponse response, List&lt;?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a4aa0f207af6ceb85d9eefb48e0547ee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4385af4c2c738b6bc537baf88e61fd28/" rel="bookmark">
			BigDecimal使用的时候需要注意什么？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		BigDecimal只要涉及到浮点数运算都会用到BigDecimal，并且面试的时候经常会问到，那么BigDecimal使用的时候需要注意什么？
目录 1.为什么不能用浮点数表示金额？2.十进制转换二进制3.科学记数法4.IEEE 7545.在线浮点数转换二进制6.原码、反码、补码7.常见面试题面试题1：为什么浮点类型只有在运算的时候会出现丢失精度的问题，而初始化不会呢？面试题2：float和long哪个存放的数据更大，为什么？面试题3：什么情况下需要使用BigDecimal？面试题4：BigDecimal(double)和BigDecimal(String)有什么区别？面试题5：BigDecimal原理？面试题6：BigDecimal是否可变？面试题7：BigDecimal的toString()与toPlainString()面试题8：为什么不能用BigDecimal的equals方法做等值比较？面试题9：浮点数之间不能使用==等值比较？面试题10：BigDecimal转换String精度丢失问题 8.BigDecimal无限小数问题9.BigDecimal运算交换需要注意10.总结 1.为什么不能用浮点数表示金额？ public static void main(String[] args) { double a = 7.22 + 7.0; double b = 0.09 + 0.01; float c = 7.22f + 7.0f; System.out.println(a); System.out.println(b); System.out.println(c); } 运行结果：
丢失精度的原因：因为不是所有的小数都能用二进制表示，所以，为了解决这个问题，IEEE 754提出了一种使用近似值表示小数的方式，并且引入了精度的概念。这就是我们所熟知的浮点数。
所以，浮点数只是近似值，并不是精确值，所以不能用来表示金额，否则会有精度丢失。
2.十进制转换二进制 十进制的小数转换为二进制小数，可以采用乘2取整法，主要是利用小数部分乘2，取整数部分，直至小数点后为0。
下面以十进制的0.625为例，将它转化成二进制：
0.2转化二进制：
0.2*2=0.4,整数位为0 0.4*2=0.8,整数位为0 0.8*2=1.6,整数位为1,去掉整数位得0.6 0.6*2=1.2,整数位为1,去掉整数位得0.2 0.2*2=0.4,整数位为0 0.4*2=0.8.整数位为0 就这样推下去！小数*2整,一直下去就行 这个数整不断 0.0011001 十进制数0.2要用二进制数来表示的话，是一个循环小数，无法精确表达。只能根据精度需要，截取小数点后若干位来表示了。因此就会出现丢失精度的问题。
计算机都是以二进制存储，而二进制都是0110，根本没有小数点，我们在电脑计算器当中，十进制转换二进制的时候小数点根本不让你按，为什么呢？因为无限循环小数根本没法使用二进制来精确表示，那遇到浮点数二进制只有0110的计算机是怎么来表示和存储的呢？这就不得不提一下IEEE 754了。
3.科学记数法 提IEEE 754之前我们先来回忆一下科学计数法，科学记数法是一种记数的方法。科学计数法的精妙之处在于，其将"量级"与"数值"两个信息拆分，让使用者对这两个信息更加明确。
数学常识：
阶乘是指从1到给定整数n的所有正整数的乘积，用数学符号表示为n!。例如，5!=1×2×3×4×5=120。平方是一种乘方运算，比如，a的平方表示a×a，简写成a²，电脑上可用^代替，例如x^2就是x²的意思。指数是指一个数的幂，或者说是一个数乘自身的次数。在数学中，a的指数记为a ^ n，其中a叫做底数，n叫做指数。例如，2^3=2×2×2=8。如果a ^ x =N（a&gt;0，且a≠1），那么数x叫做以a为底N的对数， log ⁡ a N \log_a{N} loga​N 读作以a为底N的对数，其中a叫做对数的底数，N叫做真数。一般的计算器当中的log计算就是计算的指数，然后底数默认为10，输入的时候输入的是真数。因此计算这类对数时，直接点击计算机的“log”键，再打上数字就可以算出来指数。 把一个数表示成a与10的n次幂相乘的形式（1≤|a|&lt;10，a不为分数形式，n为整数），这种记数法叫做科学记数法。 例如：19971400000000=1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4385af4c2c738b6bc537baf88e61fd28/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bac5654b244876c2fe1f2c8a94492274/" rel="bookmark">
			c&#43;&#43;中static静态成员变量和静态成员函数、explcit和隐式类型转换、友元函数（）详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.static静态成员(函数) 1.1概念 声明为 static 的类成员 称为 类的静态成员 ，用 static 修饰的 成员变量 ，称之为 静态成员变量 ；用 static 修饰 的 成员函数 ，称之为 静态成员函数 。 静态成员变量一定要在类外进行初始化 1.2特征 静态成员为所有类对象所共享，不属于某个具体的对象，存放在静态区
静态成员变量必须在类外定义，定义时不添加static关键字，类中只是声明
静态成员变量也不能给缺省值，因为缺省值是给初始化列表的，而初始化列表是初始化某个对象的，静态成员变量是属于整个类的，不属于某一个具体对象。
class A { //静态成员变量在类中声明 public: static int Count1; private: static int Count2; }; //静态成员变量在类外定义并且初始化, //不需要static修饰，但需要类名::的形式指定类域 int A::Count1 = 1;	int A::Count2 = 2; 类静态成员即可用 类名 :: 静态成员 或者 对象 . 静态成员 来访问 静态成员也是类的成员，受 public 、 protected 、 private 访问限定符的限制 class A { public: void abc1() { //A::public静态成员变量可以在类内表示 cout &lt;&lt; A::Count1&lt;&lt;endl; } void abc2() { //A::private静态成员变量可以在类内表示 cout &lt;&lt; A::Count2 &lt;&lt; endl; } //静态成员变量在类中声明 public: static int Count1; private: static int Count2; }; //静态成员变量在类外定义并且初始化, //不需要static修饰，但需要类名::的形式指定类域 int A::Count1 = 1;	int A::Count2 = 2; int main() { A aa; aa.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bac5654b244876c2fe1f2c8a94492274/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ffde938f1f96b59ca3e1b6e27f3ea01d/" rel="bookmark">
			2023高教社杯国赛数学建模C题思路&#43;模型&#43;代码（9.7晚开赛后第一时间更新）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录
1.C题思路模型：9.7晚上比赛开始后，第一时间更新，获取见文末名片
2.竞赛注意事项：包括比赛流程，任务分配，时间把控，论文润色，已经发布在文末名片中
3.常用国赛数学建模算法 3.1 分类问题
3.2 优化问题
4.获取赛题思路模型见此名片
1.C题思路模型：9.7晚上比赛开始后，第一时间更新，获取见文末名片 2.竞赛注意事项：包括比赛流程，任务分配，时间把控，论文润色，已经发布在文末名片中 3.常用国赛数学建模算法 3.1 分类问题 判别分析：
又称“分辨法”，是在分类确定的条件下，根据某一研究对象的各种特征值判别其类型归属问题的一种多变量统计分析方法。
其基本原理是按照一定的判别准则，建立一个或多个判别函数；用研究对象的大量资料确定判别函数中的待定系数，并计算判别指标；据此即可确定某一样本属于何类。当得到一个新的样品数据，要确定该样品属于已知类型中哪一类，这类问题属于判别分析问题。
聚类分析：
聚类分析或聚类是把相似的对象通过静态分类的方法分成不同的组别或者更多的子集，这样让在同一个子集中的成员对象都有相似的一些属性，常见的包括在坐标系中更加短的空间距离等。
聚类分析本身不是某一种特定的算法，而是一个大体上的需要解决的任务。它可以通过不同的算法来实现，这些算法在理解集群的构成以及如何有效地找到它们等方面有很大的不同。
神经网络分类：
BP 神经网络是一种神经网络学习算法。其由输入层、中间层、输出层组成的阶层型神经网络，中间层可扩展为多层。RBF（径向基）神经网络：径向基函数(RBF-Radial Basis Function)神经网络是具有单隐层的三层前馈网络。它模拟了人脑中局部调整、相互覆盖接收域的神经网络结构。感知器神经网络：是一个具有单层计算神经元的神经网络，网络的传递函数是线性阈值单元。主要用来模拟人脑的感知特征。线性神经网络：是比较简单的一种神经网络，由一个或者多个线性神经元构成。采用线性函数作为传递函数，所以输出可以是任意值。自组织神经网络：自组织神经网络包括自组织竞争网络、自组织特征映射网络、学习向量量化等网络结构形式。K近邻算法：　K最近邻分类算法，是一个理论上比较成熟的方法，也是最简单的机器学习算法之一。
3.2 优化问题 线性规划：
研究线性约束条件下线性目标函数的极值问题的数学理论和方法。英文缩写LP。它是运筹学的一个重要分支，广泛应用于军事作战、经济分析、经营管理和工程技术等方面。建模方法：列出约束条件及目标函数；画出约束条件所表示的可行域；在可行域内求目标函数的最优解及最优值。
非线性规划：
非线性规划是具有非线性约束条件或目标函数的数学规划，是运筹学的一个重要分支。非线性规划研究一个 n元实函数在一组等式或不等式的约束条件下的极值问题，且 目标函数和约束条件至少有一个是未知量的非线性函数。目标函数和约束条件都是 线性函数的情形则属于线性规划。
整数规划：
规划中的变量（全部或部分）限制为整数，称为整数规划。若在线性模型中，变量限制为整数，则称为整数线性规划。目前所流行的求解整数规划的方法往往只适用于整数线性规划。一类要求问题的解中的全部或一部分变量为整数的数学规划。从约束条件的构成又可细分为线性，二次和非线性的整数规划。
动态规划：
包括背包问题、生产经营问题、资金管理问题、资源分配问题、最短路径问题和复杂系统可靠性问题等。
动态规划主要用于求解以时间划分阶段的动态过程的优化问题，但是一些与时间无关的静态规划(如线性规划、非线性规划)，只要人为地引进时间因素，把它视为多阶段决策过程，也可以用动态规划方法方便地求解。
多目标规划：
多目标规划是数学规划的一个分支。研究多于一个的目标函数在给定区域上的最优化。任何多目标规划问题，都由两个基本部分组成：
4.获取赛题思路模型见此名片 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7185b7df31a7cf997546e3d12a444947/" rel="bookmark">
			【SWAT水文模型】SWAT水文模型建立及应用第六期：SWAT-CUP参数敏感性分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SWAT CUP的下载及安装参见另一博客-【SWAT水文模型】SWAT-CUP安装及使用。本博客主要介绍SWAT模型参数敏感性分析。
SWAT模型参数敏感性分析（SWAT CUP） 1 原理1.1 Latin-Hypercube（LH）1.2 One-factor-At-a-Time 抽样1.3 LH-OAT 分析 2 率定参数3 敏感性分析3.1 OAT3.2 全局敏感性分析 运行不同目标函数（如R2/NSE/Pbias）参考 地理信息系统（GIS）支持下的 SWAT（Soiland Water Assessent Tool）半分布式水文模型以流域离散化空间参数来描述流域水文变化特性，从物理意义上表达流域内的水文过程，但众多不确定的参数影响了模型的应用效果，因此有必要对参数进行敏感性分析。 基于 DEM 的分布式水文模型由于充分考虑了流域陆面参数在空间上的变异性，同时又能较好地表达流域水文过程的物理意义，已成为径流模拟新的发展方向。与传统的集总式模型相比，建立在物理机制上的分布式水文模型要求输入的参数较多，并且由于水文陆面过程中参数的空间差异性、获取过程中的误差及参数评估的困难使得模型初始参数值的输入具有很大的不确定性，降低了分布式水文模型的运行效率和模拟精度。此外对模型参数敏感性认识的不足也是影响分布式水文模型应用的一个重要因素。
因此需要理解模型中每一个参数对模拟结果的影响，通过对参数的敏感性分析进行参数筛选，减少模型率定参数的数量，提高模型运行时间效率和减少参数的不确定性，为模型的进一步改进提供更加可靠的依据。
1 原理 模型通过自带的LH-OAT (Latin Hypercube One-factor-At-a-Time) 敏感性分析方法和SCE-UA (Shuffled Complex Evolution Algorithm) 自动校准分析方法来率定敏感性参数的取值。
1.1 Latin-Hypercube（LH） 基于蒙特卡洛模型，但基于统计插样方法把每个参数分布划为N个空间，随即抽样，每个空间的被抽到的概率为1/N，参数随机组合，模型运行N次。如对平壤KS值，其取值范围为0100cm/hr。Latin-Hypercube随机采样过程中Ks值将被分为 (0-10)10-20)…、(90-100)共10个取值区间(20-30)模型结果利用多参数线性回归或相关分析方法分析不足: 多元回归分析的前提假设为线性变化，可能导致偏差输出结果的变化并 不总能明确地归因于某一特定输育清参数值的变化 1.2 One-factor-At-a-Time 抽样 运行一次只改变一个参数每次模拟仅改变1个参数的值，这样便于将模拟结果的变化无偏差地归因到该参数的变化上某一特定输入参数值的变化引起的输出结果的灵敏度大小依赖于模型其他参数值的选取 1.3 LH-OAT 分析 参数敏感度分析采用ArcSWAT提供的参数敏感度分析模块进行分析，此模块采用的方法是LH-OAT灵敏度分析方法，该方法对每一抽样点（LH抽样法）进行OAT灵敏度分析，灵敏度最终值是各局部灵敏度之和的平均值，是综合LH抽样法和OAT灵敏度分析的一种新方法，同时兼备两种方法的优点。
采用LH-OAT法可确保所有参数在取值范围内均被取样两者优点，弥补不足每次仅对1个参数进行敏感性分析，将其按固定比例调整大小（如取值范围的5%）其他参数按LatinHypercurbe采样方法随机变化模拟m次，并统计分析对模拟结果的影响，m为取值区间的个数如对n个参数进行敏感性分析，把参数划分为m个空间，模型共需m*(n+1)次模拟 2 率定参数 在ArcSWAT2012版本中将敏感性分析和自动校正都去掉了，只剩下了手动校正。
SWAT模型种与水文过程相关的参数包括土壤参数、土地利用参数、地下水径流参数、融雪径流参数、地表特征参数，这些参数既有流域级的又有子单元级的。
选取以下参数（部分）进行率定：
3 敏感性分析 采用SWAT-CUP中的SUFI-2算法进行敏感性分析。
3.1 OAT OAT属于局部敏感性分析方法，做法是保持其他参数不变，调动单个参数，观察目标函数变化。OAT操作简单，可快速估计参数敏感程度。
3.2 全局敏感性分析 t值表示参数敏感性的大小，其绝对值越大，代表该参数在某一区域越敏感；p值表示该参数敏感性的置信水平，其值越接近0，代表该参数越重要。在p值小于等于0.05的情况下，该参数比较敏感重要；而在p值大于等于0.3的情况下，该参数不敏感。 根据SWAT CUP界面结果：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7185b7df31a7cf997546e3d12a444947/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f63e07cdfa91e6c43ef6c5258030f90c/" rel="bookmark">
			python用pychart库，实现将经纬度信息在地图上显示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python使用pyecharts对给到的经纬度数据进行位置标注，下面是批量更新。给入数据，将地图生成。实验数据在下面附件。
from pyecharts import options as opts from pyecharts.charts import Geo import os folder_path = 'F:\\GPS' file_names = os.listdir(folder_path) for file_name in file_names: geo_chart = Geo() open_path = folder_path+"\\"+file_name geo_chart.add_schema(maptype="china") with open(open_path, "r") as file: lines = [line.strip() for line in file.readlines()] points = [eval(line) for line in lines] for i, point in enumerate(points): geo_chart.add_coordinate(str(i), point[0], point[1]) geo_chart.set_global_opts( title_opts=opts.TitleOpts(title="中国地图标记经纬度点"), visualmap_opts=opts.VisualMapOpts(max_=10), ) for i, point in enumerate(points): geo_chart.add("", [(str(i), 1)]) geo_chart.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f63e07cdfa91e6c43ef6c5258030f90c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4587b958145ff8481852ed4adde14090/" rel="bookmark">
			Kibana使用Watcher监控服务日志并发送飞书报警(Markdown)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Watcher是什么 Kibana Watcher 是 Elasticsearch 的监控和告警工具，它允许你设置和管理告警规则以监控 Elasticsearch 数据和集群的状态。Kibana Watcher 可以监测各种指标和数据，然后在满足特定条件时触发警报。它提供了一种强大的方式来实时监控 Elasticsearch 数据、集群性能、日志和事件，以及其他关键指标。
构造飞书报警内容 创建飞书群聊并添加飞书报警机器人, 获取Webhook地址
构造请求体
{ "msg_type": "interactive", "card": { "header": { "template": "red", "title": { "tag": "plain_text", "content": "接口请求预警(20m)" } }, "config": { "wide_screen_mode": true, "enable_forward": true }, "elements": [ { "tag": "markdown", "content": "**接口:** /lastVersion\n**预警值:** 1000\n**请求次数:** 10000" } ] } } 添加Watcher 入口: Stack Management -&gt; Watcher -&gt; Create
2种方式:
Create threshold alert: 一般用于简单的指标监控, 及Index数量统计
Create advanced watch: 高级预警, 用于创建更复杂和灵活的监控规则。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4587b958145ff8481852ed4adde14090/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/325ee815bdd83fb9696bb654dbbc4173/" rel="bookmark">
			qcustomplot只进行x轴的放大缩小（禁止y轴缩放）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 参考博客：QCustomPlot系列： 实现X轴，Y轴的单独滚轮缩放数据_qcustomplot 缩放-CSDN博客
//设置可移动 ui-&gt;customPlot-&gt;setInteractions(QCP::iRangeDrag | QCP::iRangeZoom | QCP::iSelectLegend | QCP::iMultiSelect|QCP::iSelectPlottables); //x轴设置缩放比例，y轴缩放比例为1，则不进行缩放 ui-&gt;customPlot-&gt;axisRect()-&gt;setRangeZoomFactor(1.2,1); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fcfea4fb6af87069a8a1eca14b4df256/" rel="bookmark">
			UEditor(版本号1.4.3) 在vue中使用导致内存泄漏问题优化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.UE.instants 全局的UE对象，在编辑器创建的时候会在UE.instants对象里面新增内容，但是在组件销毁是并没有删除创建时新增的内容，会导致内存泄漏问题
2.UE.$EDITORUI全局的$EDITORUI对象，在编辑器创建的时候会在UE.$EDITORUI对象里面新增内容，但是在组件销毁是并没有删除创建时新增的内容，会导致内存泄漏问题
3.UE.$EDITORUI全局的$EDITORUI对象，在编辑器创建的时候会在UE.$EDITORUI对象里面新增内容，但是在组件销毁是并没有删除创建时新增的内容，会导致内存泄漏问题
4.在编辑器创建的时候会在allPopups对象里面新增内容，但是在组件销毁是并没有删除创建时新增的内容，会导致内存泄漏问题
5.销毁时调用时间销毁方法错误，导致时间没有正确销毁
解决办法：
1)修改 Editor.prototype 的 destroy方法
destroy: function () { var me = this, uid = me.uid, mekey = me.key, eid = me.container.id; me.ui.fireEvent('destroy'); var container = me.container.parentNode; var textarea = me.textarea; if (!textarea) { textarea = document.createElement('textarea'); container.parentNode.insertBefore(textarea, container); } else { textarea.style.display = '' } textarea.style.width = me.iframe.offsetWidth + 'px'; textarea.style.height = me.iframe.offsetHeight + 'px'; textarea.value = me.getContent(); textarea.id = me.key; container.innerHTML = ''; domUtils.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fcfea4fb6af87069a8a1eca14b4df256/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/878b520fb8e284dcf8d1ad01675de6da/" rel="bookmark">
			Vue3 &#43; Three.js &#43; gltf-pipeline大型园区场景渲染与3D业务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在非使用unity作为3D渲染方案的前提下，对与目前web开发者比较友好的除了canvas场景需要的2D babylon.js，fabric.js, Three.js是目前针对于jsWeb用户最直接且比较友好的3D引擎方案了。
准备工作：
1.明确需要用的场景方案都有那些，模型需要的加载器是什么
2.模型的场景大小已经相关的交互业务
3.场景的工作环境（浏览器及硬件要求)
step1:
以.glb模型为例
import * as THREE from "three"; import {GLTFLoader} from "three/examples/jsm/loaders/GLTFLoader"; import {OrbitControls} from "three/examples/jsm/controls/OrbitControls"; 以上就是一个场景绘制需要的基本3个要素
模型压缩
由于建模工程师因为场景规模的原因模型在建立时过多了使用了面，导致整个模型的体积很大，一个校区或者大园区为例，建筑加环境要素及周边地形都整体的模型体积已经达到了100M+,这个时候就需要我们在开发前就考虑模型的压缩问题了
DRACO压缩算法
npm install -g gltf-pipeline --input, -i Path to the glTF or glb file.[string] [required] --output, -o Output path of the glTF or glb file. Separate resources will be saved to the same directory. [string] --binary, -b Convert the input glTF to glb. //将输入的glTF转换为glb [boolean] [default: false] --json, -j Convert the input glb to glTF.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/878b520fb8e284dcf8d1ad01675de6da/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fdcd374d1ac52f2843621b1b11b7b6e0/" rel="bookmark">
			拼多多商品详情API接口接入流程如下：
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		拼多多商品详情API接口可以用于获取拼多多商品的具体信息，包括商品ID、商品名称、价格、销量、评价等。以下是使用拼多多商品详情API接口的步骤：
进入拼多多开放平台，注册并登录账号。在开放平台页面中，找到“商品详情”或“商品信息”等相关的API接口，根据需要进行选择。根据接口文档，了解接口的使用规则、请求方式、返回格式等信息。根据接口文档提供的示例代码，进行接口的调用。 拼多多根据ID取商品详情 API 返回值说明 item_get-根据ID取商品详情 API测试工具 pinduoduo.item_get 公共参数
请求地址: https://o0b.cn/anzexi
名称类型必须描述keyString是调用key（必须以GET方式拼接在URL中）secretString是调用密钥api_nameString是API接口名称（包括在请求地址中）[item_search,item_get,item_search_shop等]cacheString否[yes,no]默认yes，将调用缓存的数据，速度比较快result_typeString否[json,jsonu,xml,serialize,var_export]返回数据格式，默认为json，jsonu输出的内容中文可以直接阅读langString否[cn,en,ru]翻译语言，默认cn简体中文versionString否API版本 请求参数
请求参数：num_iid=1620002566
参数说明：num_iid:商品ID ;
请求示例
响应示例
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1c2058ac9a8f472c1f7fa278d3a2a07/" rel="bookmark">
			ros2_control的简单应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 简介插件实现函数介绍代码 调用原理局限性 简介 在利用moveit_setup_assistant配置我们自己机械手后，当运行demo.launch.py时，会实例化一个moveit对象以及一个基于ros2_control的、虚拟的控制对象，从而可以实现一个完整的控制闭环。
此基于ros2_control的虚拟对象，包含了action（server）相关的实例化、关节状态的发布、虚拟伺服电机的驱动及读取。
我们也可以利用ros2_control，将我们自己的机械手与moveit连接起来，从而实现moveit对我们机械手的控制。但是这样做的话，会损失比较多的自由度。假如电机等伺服机构、传感器等硬件是直接接到ros系统所在板子上的话，用ros2_control是挺方便的，但是我的是接在下位机，然后通过串口通讯控制的，使用ros2_control貌似就不太合适了。
不过也简单尝试一下例程，说不定后面有机会用到。
插件实现 这里我还是用我之前的那个【机械手模型】，来进行演示。
关于ros2_control的介绍可以看这里：【ros2_control doc】，我们这里就不继续啰嗦了。
我们只需要知道一点够了：我们只需要对ros2_control的类hardware_interface::SystemInterface进行实例化，其余的moveit_setup_assistant/ros2_control已经帮我们做好了。
对该类进行重写实现时，根据官方文档【Writing a new hardware interface】，我们需要分别重写下面8个函数
hardware_interface::CallbackReturn on_init( const hardware_interface::HardwareInfo &amp; info) override; hardware_interface::CallbackReturn on_configure( const rclcpp_lifecycle::State &amp; previous_state) override; std::vector&lt;hardware_interface::StateInterface&gt; export_state_interfaces() override; std::vector&lt;hardware_interface::CommandInterface&gt; export_command_interfaces() override; hardware_interface::CallbackReturn on_activate( const rclcpp_lifecycle::State &amp; previous_state) override; hardware_interface::CallbackReturn on_deactivate( const rclcpp_lifecycle::State &amp; previous_state) override; hardware_interface::return_type read( const rclcpp::Time &amp; time, const rclcpp::Duration &amp; period) override; hardware_interface::return_type write( const rclcpp::Time &amp; time, const rclcpp::Duration &amp; period) override; 函数介绍 分别介绍一下这几个函数的作用。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d1c2058ac9a8f472c1f7fa278d3a2a07/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/840cba184e0de32172197ea07aa86102/" rel="bookmark">
			C和C&#43;&#43;多平台判断代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.MSVC #ifndef _MSC_VER #endif 2.WINDOWS #if defined(__WINDOWS__) || defined(_WIN32) || defined(WIN32) || defined(_WIN64) || \ defined(WIN64) || defined(__WIN32__) || defined(__TOS_WIN__) #endif 3.Mac #if defined(__MACOSX) || defined(__MACOS_CLASSIC__) || defined(__APPLE__) || defined(__apple__) #endif 4.Linux #if defined(__linux__) || defined(linux) || defined(__linux) || defined(__LINUX__) || \ defined(LINUX) || defined(_LINUX) #endif 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e67fc5a5025b475ff850834fe03f5014/" rel="bookmark">
			BIOS下引导方式无法修改，BOOT MODE选项或者UEFI、LEGACY灰色
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在BIOS设置中，引导方式是决定操作系统启动方式的重要设置。然而，有时用户会遇到一个问题，那就是无法修改BIOS中的引导方式，发现BOOT MODE选项或者UEFI、LEGACY是灰色的无法选择。这可能会让用户感到困惑和无助，因为无法选择正确的引导方式会导致无法正常启动操作系统。本文将为你分享解决这个问题的方法，帮助你解决这个困扰。
联想知识库https://iknow.lenovo.com.cn/detail/183463
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59f4c4103dc2f15c09203392b4b49395/" rel="bookmark">
			Ubuntu 配置国内源
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		配置国内源 因为众所周知的原因，国外的很多网站在国内是访问不了或者访问极慢的，这其中就包括了Ubuntu的官方源。
所以，想要流畅的使用apt安装应用，就需要配置国内源的镜像。
市面上Ubuntu的国内镜像源非常多，比较有代表性的有清华源、中科大源、阿里源、网易源，以下是它们的网址：
清华源：https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/中科大源：http://mirrors.ustc.edu.cn/help/ubuntu.html阿里源：https://developer.aliyun.com/mirror/ubuntu?spm=a2c6h.13651102.0.0.3e221b11xgh2AI网易源：http://mirrors.163.com/.help/ubuntu.html 这里以清华源为例
备份原始源文件。
cp /etc/apt/sources.list /etc/apt/sources.list.bak 访问清华源镜像地址：https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/
选择自己操作系统版本的镜像，复制其内容。
查看系统发行版本：
cat /etc/os-release 编辑源文件，改为复制的内容。
vim /etc/apt/sources.list 更新软件列表，完成换源。
apt update update 是同步 /etc/apt/sources.list 和 /etc/apt/sources.list.d 中列出的源的索引，这样才能获取到最新的软件包。
修复损坏的软件包，尝试卸载出错的包，重新安装正确版本的。
apt-get install -f 更新软件。
apt-get upgrade upgrade 是升级已安装的所有软件包，升级之后的版本就是本地索引里的。
因此，在执行 upgrade 之前一定要先执行 update，这样才能保证所有软件包是最新的。
环境
Ubuntu 22.04.2
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a00020beb8d5bf27f02e304f28e083b7/" rel="bookmark">
			【操作系统面试题（32道）与面试Linux命令大全】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 操作系统面试题引论1.什么是操作系统？2.操作系统主要有哪些功能？ 操作系统结构3.什么是内核？4.什么是用户态和内核态？5.用户态和内核态是如何切换的？ 进程和线程6.并行和并发有什么区别？7.什么是进程上下文切换？8.进程有哪些状态？9.什么是僵尸进程？10.什么是孤儿进程？11.进程有哪些调度算法？12.进程间通信有哪些方式？13.进程和线程的联系和区别？14.线程上下文切换了解吗？15.线程有哪些实现方式？16.线程间如何同步？17.什么是死锁？18.死锁产生有哪些条件？19.如何避免死锁呢？20.活锁和饥饿锁了解吗？ 内存管理21.什么是虚拟内存？22.什么是内存分段？23.什么是内存分页？24.多级页表知道吗？25.什么是块表？26.分页和分段有什么区别？27.什么是交换空间？28.页面置换算法有哪些？ 文件29.硬链接和软链接有什么区别？ IO30.零拷贝了解吗？31.聊聊**阻塞与⾮阻塞** **I/O **、 **同步与异步** **I/O**？32.详细讲一讲I/O多路复用？ 常用的Linux命令1、绝对路径用什么符号表示？当前目录、上层目录用什么表示？主目录用什么表示? 切换目录用什么命令？2、怎么查看当前进程？怎么执行退出？怎么查看当前路径？3、怎么清屏？怎么退出当前命令？怎么查看当前用户 id？查看指定帮助用什么命令？4、ls命令执行什么功能？ 可以带哪些参数，有什么区别？5、查看文件有哪些命令？6、列举几个常用的Linux命令。7、你平时是怎么查看日志的？1)、tail2)、head3)、cat4)、more5)、sed6)、less 8、建立软链接(快捷方式)，以及硬链接的命令9、目录创建用什么命令？创建文件用什么命令？复制文件用什么命令？10、查看文件内容有哪些命令可以使用？11、随意写文件命令？怎么向屏幕输出带空格的字符串，比如”hello world”?12、终端是哪个文件夹下的哪个文件？黑洞文件是哪个文件夹下的哪个命令？13、移动文件用哪个命令？改名用哪个命令？14、复制文件用哪个命令？如果需要连同文件夹一块复制呢？15、删除文件用哪个命令？如果需要连目录及目录下文件一块删除呢？删除空文件夹用什么命令？16、Linux下命令有哪几种可使用的通配符？分别代表什么含义？17、用什么命令对一个文件的内容进行统计？(行号、单词数、字节数)18、Grep命令有什么用？ 如何忽略大小写？ 如何查找不含该串的行?19、Linux中进程有哪几种状态？在ps显示出来的信息中分别用什么符号表示的？20、怎么使一个命令在后台运行?21、利用ps怎么显示所有的进程? 怎么利用ps？22、哪个命令专门用来查看后台任务?23、把后台任务调到前台执行使用什么命令?把停下的后台任务在后台执行起来用什么命令?24、终止进程用什么命令? 带什么参数?25、怎么查看系统支持的所有信号？26、搜索文件用什么命令? 格式是怎么样的?27、查看当前谁在使用该主机用什么命令? 查找自己所在的终端信息用什么命令?28、使用什么命令查看用过的命令列表?29、使用什么命令查看磁盘使用空间？空闲空间呢?30、使用什么命令查看网络是否连通?31、使用什么命令查看IP地址及接口信息？32、查看各类环境变量用什么命令?33、查找命令的可执行文件是去哪查找的? 怎么对其进行设置及添加?34、通过什么命令查找执行命令?35、怎么对命令进行取别名？36、du和df的定义，以及区别？37、如果一个Linux新手想要知道当前系统支持的所有命令的列表，他需要怎么做？38、如果你的助手想要打印出当前的目录栈，你会建议他怎么做？39、你的系统目前有许多正在运行的任务，在不重启机器的条件下，有什么方法可以把所有正在运行的进程移除呢？40、bash shell中的hash命令有什么作用？41、怎样一页一页地查看一个大文件的内容呢？42、数据字典属于哪一个用户的？43、怎样查看一个linux命令的概要与用法？假设你在/bin 目录中偶然看到一个你从没见过的的命令，怎样才能知道它的作用和用法呢？44、使用哪一个命令可以查看自己文件系统的磁盘空间配额呢？ 操作系统面试题 引论 1.什么是操作系统？ 可以这么说，操作系统是一种运行在内核态的软件。
它是应用程序和硬件之间的媒介，向应用程序提供硬件的抽象，以及管理硬件资源。
2.操作系统主要有哪些功能？ 操作系统最主要的功能：
处理器（CPU）管理：CPU的管理和分配，主要指的是进程管理。内存管理：内存的分配和管理，主要利用了虚拟内存的方式。外存管理：外存（磁盘等）的分配和管理，将外存以文件的形式提供出去。I/O管理：对输入/输出设备的统一管理。 除此之外，还有保证自身正常运行的健壮性管理，防止非法操作和入侵的安全性管理。
操作系统结构 3.什么是内核？ 可以这么说，内核是一个计算机程序，它是操作系统的核心，提供了操作系统最核心的能力，可以控制操作系统中所有的内容
4.什么是用户态和内核态？ 内核具有很⾼的权限，可以控制 cpu、内存、硬盘等硬件，出于权限控制的考虑，因此⼤多数操作系统，把内存分成了两个区域：
内核空间，这个内存空间只有内核程序可以访问；⽤户空间，这个内存空间专⻔给应⽤程序使⽤，权限比较小； ⽤户空间的代码只能访问⼀个局部的内存空间，⽽内核空间的代码可以访问所有内存空间。因此，当程序使⽤⽤户空间时，我们常说该程序在⽤户态执⾏，⽽当程序使用内核空间时，程序则在内核态执⾏。
5.用户态和内核态是如何切换的？ 应⽤程序如果需要进⼊内核空间，就需要通过系统调⽤，来进入内核态：
内核程序执⾏在内核态，⽤户程序执⾏在⽤户态。当应⽤程序使⽤系统调⽤时，会产⽣⼀个中断。发⽣中断后， CPU 会中断当前在执⾏的⽤户程序，转⽽跳转到中断处理程序，也就是开始执⾏内核程序。内核处理完后，主动触发中断，把 CPU 执⾏权限交回给⽤户程序，回到⽤户态继续⼯作。
进程和线程 6.并行和并发有什么区别？ 并发就是在一段时间内，多个任务都会被处理；但在某一时刻，只有一个任务在执行。单核处理器做到的并发，其实是利用时间片的轮转，例如有两个进程A和B，A运行一个时间片之后，切换到B，B运行一个时间片之后又切换到A。因为切换速度足够快，所以宏观上表现为在一段时间内能同时运行多个程序。
并行就是在同一时刻，有多个任务在执行。这个需要多核处理器才能完成，在微观上就能同时执行多条指令，不同的程序被放到不同的处理器上运行，这个是物理上的多个进程同时进行。
7.什么是进程上下文切换？ 对于单核单线程 CPU 而言，在某一时刻只能执行一条 CPU 指令。上下文切换 (Context Switch) 是一种将 CPU 资源从一个进程分配给另一个进程的机制。从用户角度看，计算机能够并行运行多个进程，这恰恰是操作系统通过快速上下文切换造成的结果。在切换的过程中，操作系统需要先存储当前进程的状态 (包括内存空间的指针，当前执行完的指令等等)，再读入下一个进程的状态，然后执行此进程。
8.进程有哪些状态？ 当一个进程开始运行时，它可能会经历下面这几种状态：
上图中各个状态的意义：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a00020beb8d5bf27f02e304f28e083b7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f4a55fa0794617f00d5af59498a08400/" rel="bookmark">
			Linux中_银河麒麟V4.0.2_使用中_遇到问题_及解决_记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux中_银河麒麟V4.0.2_使用中_遇到问题_及解决_记录 1、银河麒麟 V4.0.2 使用，桌面太大了，必须要使用滑动条往下拉才能看到最底下的任务栏？2、tcpdump抓包问题：3、linux 中通过tee把程序日志重定向到log.txt文本文件中，有时候重定向到log文件中的日志会缺失程序中最后面结束前的一部分输出日志，这一部分日志是一定会输出的，但是有时候会缺失，日志文件中没有，终端输出也没有？4、问题：ubuntu下安装qt5.9.9后，创建新程序然后编译，报错“-1: error: cannot find -lGL”。 1、银河麒麟 V4.0.2 使用，桌面太大了，必须要使用滑动条往下拉才能看到最底下的任务栏？ 可以尝试以下解决方案： 1、调整分辨率：右键点击桌面空白处，选择“显示设置”或者类似的选项（具体名称可能会有所不同）。在显示设置中，尝试调整屏幕分辨率为更低的选项，以适应您的可视范围。 2、调整显示缩放比例：在系统设置中找到“显示”或“外观”选项，尝试调整显示缩放比例。减小缩放比例可以使整个桌面缩小，适应屏幕。 3、调整桌面图标大小：在桌面上右键点击，选择“更改桌面背景”或“桌面设置”，找到关于图标大小的选项，尝试减小图标大小以适应屏幕。 4、使用多个桌面：有些操作系统可以支持多个桌面，您可以尝试将一些不常用的图标或文件放在其他桌面上，以减少主桌面的拥挤感。 5、安装第三方桌面管理工具：您可以考虑安装一些第三方的桌面管理工具，这些工具往往提供各种自定义选项，可以帮助您更好地管理和布局桌面空间。 2、tcpdump抓包问题： 1、tcpdump: ehth0:You dont have permission to captue on that device(socket: operation not pemitted) tcpdump:ehth0:您没有在该设备上进行captue的权限（套接字：操作未完成） 解决： 需要sudo 权限来执行。 2、tcpdump: pcapsender: no such file or directory。 tcpdump:papsender_1_1_1_2023/07/12/_15:05:38.pcap:没有这样的文件或目录 解决： linux文件命名中一般是不能使用 / 跟 : 。 将 / 换成 - ，: 换成 - 。就好了可以了。 3、linux 中通过tee把程序日志重定向到log.txt文本文件中，有时候重定向到log文件中的日志会缺失程序中最后面结束前的一部分输出日志，这一部分日志是一定会输出的，但是有时候会缺失，日志文件中没有，终端输出也没有？ 在Linux中，使用tee命令可以将程序的输出同时输出到终端和文件中。但是，有时候在重定向到文件时，可能会出现缺失最后一部分输出日志的情况。这可能是由于缓冲区的刷新机制导致的。 默认情况下，标准输出（stdout）是带有缓冲区的，当缓冲区被填满或者遇到换行符时，才会将缓冲区的内容刷新到文件中。因此，如果程序在结束前没有输出换行符或者缓冲区没有填满，那么最后一部分输出可能会被丢失。 可以尝试以下方法来解决缺失日志的问题： 1. 可以使用std::endl或者std::flush来手动刷新缓冲区。std::endl会输出一个换行符并刷新缓冲区，而std::flush只会刷新缓冲区而不输出换行符。 刷新操作单独写一行： std::cout &lt;&lt; std::endl; 或： std::cout.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f4a55fa0794617f00d5af59498a08400/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06e560040ad0032768132c9a2eeef106/" rel="bookmark">
			Linux中_网络抓包工具tcpdump_了解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux中_网络抓包工具tcpdump_了解 1、介绍：2、使用介绍：3、常用参数：4、示例： 1、介绍： tcpdump是一个在Unix和Linux系统中常用的命令行网络抓包工具，用于捕获网络流量并分析网络数据包。它可以捕获和显示网络数据包。它可以帮助我们查看网络传输情况，分析网络问题和调试网络应用程序。以下是tcpdump的使用介绍、常用参数和示例。
2、使用介绍： 在命令行中输入tcpdump命令，即可启动tcpdump进行抓包。
tcpdump会默认抓取由所有网络接口进出的数据包，并将其显示在命令行窗口上。
按Ctrl+C可以中断抓包，并显示抓包结果的统计信息。
命令格式：
表达式：
可以使用表达式来过滤要捕获的数据包。表达式可以根据协议、源/目的IP地址、端口号等进行过滤。
tcpdump [选项参数] [expression表达式]
3、常用参数： -i ：指定要监听的网络接口。例如，监听eth0网卡：-i eth0。
any作为接口参数，您可以捕获系统上所有的网络流量数据。
-n：以IP地址而非主机名形式显示数据包，禁用DNS解析，只显示IP地址。
-c ：指定抓包的数据包数量，例如，表示只抓取10个数据包：-c 10。
-s ：设置抓包时的快照长度（以字节为单位）,设置每个数据包要捕获的最大字节数。例如：-s 1500。
-w ：将抓取的数据包保存到文件中，例如：-w capture.pcap。
-r ：从指定文件中读取数据包进行分析。例如：-r packet.pcap
-X：以16进制和ASCII格式显示数据包内容。例如：tcpdump -X
-q：以更简洁的方式显示结果。例如：
：按照指定的协议过滤数据包。例如：tcpdump http
-v 在捕获数据包时显示更多的详细信息。例如：tcpdump -v
src &lt;source_ip&gt;: 按照源IP地址过滤数据包。例如：src 192.168.1.10
仅捕获指定源IP地址的数据包：tcpdump src host 192.168.0.1
dst &lt;destination_ip&gt;: 按照目标IP地址过滤数据包。例如：dst 192.168.1.10
捕获指定目的端口号的数据包：tcpdump dst port 80
and ：按照前后条件同时满足过滤数据包。例如：src 192.168.1.10 and dst port 80
or ：按照前后条件有一个满足就过滤数据包。例如：
-B ：设置数据包的缓冲区大小，单位为字节。示例：tcpdump -B 4096
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/06e560040ad0032768132c9a2eeef106/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09092897764bf5ed0dfbcb0c922e196d/" rel="bookmark">
			一阶倒立摆的ts模糊控制，基于ts模糊模型搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一阶倒立摆的ts模糊控制，基于ts模糊模型搭建，在matla b simulink环境下仿真效果良好。
可外接扰动信号，可做离散控制系统的，也可做连续系统的。
一阶倒立摆的TS模糊控制
近年来，随着科技的不断进步和发展，控制系统在各个领域中得到了广泛的应用。在控制系统中，模糊控制是一种非常重要的控制方法，可以根据输入值和输出值之间的模糊规则进行控制，从而实现对系统的精确控制。在模糊控制中，TS模糊模型是一个比较常见的模型，这个模型可以广泛应用于离散控制系统和连续控制系统中。
本文将介绍一种基于TS模糊模型的一阶倒立摆控制方法，该方法可以在Matlab Simulink环境下进行仿真，具有良好的控制效果和可靠性。同时，该方法还可以进行外接扰动信号控制，既可以用于离散控制系统，也可以用于连续控制系统。
一阶倒立摆控制系统的建立
倒立摆是一种非常经典的控制系统模型，它广泛应用于机器人、航天器等领域中。在这些领域中，倒立摆控制系统需要保持一定的稳定性和精度，以便能够完成预定的任务。在一阶倒立摆系统中，控制器的任务就是控制小车的速度和转角，使得倒立摆保持稳定。在这个过程中，控制器需要根据反馈信号和给定的信号来调整小车的速度和转角，以便使倒立摆保持稳定。
在建立一阶倒立摆控制系统的时候，首先需要建立一个数学模型，这个模型可以描述系统的运动规律和控制规律。在这个模型中，小车的滑动部分可以描述为一个一阶惯性系统，转动的摆杆可以描述为一个一阶惯性系统。在这个模型中，我们需要量化小车的位置和速度状态，以便根据反馈信号和给定信号进行控制。同时，我们还需要定义一个控制器，这个控制器可以根据反馈信号和给定信号进行调整，以便使倒立摆保持稳定。
基于TS模糊模型的控制方法
在控制系统中，模糊控制是一种基于模糊规则的控制方法。在模糊控制中，我们需要定义一组模糊规则，这些规则可以描述系统输入值和输出值之间的关系。在TS模糊控制中，我们使用模糊启发式规则构建了一个模糊控制器，这个控制器可以在实时控制中根据系统反馈信号和给定信号进行调整，以便使倒立摆保持稳定。
在TS模糊控制中，我们将倒立摆控制器的输入和输出都用模糊变量来表示。这些模糊变量可以分为两个部分，一个是输入变量，另一个是输出变量。在输入变量中，我们可以使用Fuzzyfication模块将模糊输入转换为模糊变量。在输出变量中，我们可以使用Defuzzyfication模块将模糊输出转换为标量输出值。同时，我们还需要定义一组模糊规则，这些规则可以描述系统输入值和输出值之间的关系。
在TS模糊控制中，我们需要将系统的状态用模糊变量来建模。在这个过程中，我们需要根据系统的状态对模糊变量进行设定。在倒立摆控制系统中，我们可以将小车的位置和速度状态用模糊变量X和DX来描述，将倒立摆的转角状态用模糊变量T和DT来描述。
在TS模糊控制中，我们需要将控制器的输入和输出都用模糊变量来表示。在控制器的输入端，我们可以使用Fuzzyfication模块将输入变量转换为模糊变量，然后根据输入变量和模糊规则计算模糊输出。在控制器的输出端，我们可以使用Defuzzyfication模块将模糊输出转换为标量输出值，然后将标量输出值作为控制器的输出。
基于TS模糊模型的倒立摆控制仿真与实验结果
在Matlab Simulink环境下，我们可以进行基于TS模糊模型的倒立摆控制仿真。在这个过程中，我们可以通过设置模糊规则、模糊变量和控制器的输入输出来控制倒立摆的运动。同时，我们还可以通过设置扰动信号来测试控制系统的鲁棒性和稳定性。
在实验结果中，我们可以看到，基于TS模糊模型的倒立摆控制方法可以很好地控制倒立摆的运动。同时，该方法还可以抵抗外部扰动信号的影响，具有很好的鲁棒性和稳定性。在实际的控制系统中，该方法可以广泛应用于机器人、航天器等领域中，为系统的控制提供了可靠的保障。
总结：
本文介绍了一种基于TS模糊模型的一阶倒立摆控制方法，该方法可以在Matlab Simulink环境下进行仿真，具有良好的控制效果和可靠性。同时，该方法还可以进行外接扰动信号控制，既可以用于离散控制系统，也可以用于连续控制系统。在实际的控制系统中，该方法可以广泛应用于机器人、航天器等领域中，为系统的控制提供了可靠的保障。
相关代码,程序地址：http://lanzouw.top/649772535589.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41ce5312f85f510023b8b8a1e86c42d5/" rel="bookmark">
			java高并发系列-第2天:并发级别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这是java高并发系列第2篇文章，一个月，咱们一起啃下java高并发，欢迎留言打卡，一起坚持一个月，拿下java高并发。
由于临界区的存在，多线程之间的并发必须受到控制。根据控制并发的策略，我们可以把并发的级别分为阻塞、无饥饿、无障碍、无锁、无等待几种。
阻塞 一个线程是阻塞的，那么在其他线程释放资源之前，当前线程无法继续执行。当我们使用synchronized关键字或者重入锁时，我们得到的就是阻塞的线程。
synchronize关键字和重入锁都试图在执行后续代码前，得到临界区的锁，如果得不到，线程就会被挂起等待，直到占有了所需资源为止。
无饥饿(Starvation-Free) 如果线程之间是有优先级的，那么线程调度的时候总是会倾向于先满足高优先级的线程。也就是说，对于同一个资源的分配，是不公平的！图1.7中显示了非公平锁与公平锁两种情况(五角星表示高优先级线程)。对于非公平锁来说，系统允许高优先级的线程插队。这样有可能导致低优先级线程产生饥饿。但如果锁是公平的，按照先来后到的规则，那么饥饿就不会产生，不管新来的线程优先级多高，要想获得资源，就必须乖乖排队，这样所有的线程都有机会执行。
无障碍(Obstruction-Free) 无障碍是一种最弱的非阻塞调度。两个线程如果无障碍地执行，那么不会因为临界区的问题导致一方被挂起。换言之，大家都可以大摇大摆地进入临界区了。那么大家一起修改共享数据，把数据改坏了怎么办呢？对于无障碍的线程来说，一旦检测到这种情况，它就会立即对自己所做的修改进行回滚，确保数据安全。但如果没有数据竞争发生，那么线程就可以顺利完成自己的工作，走出临界区。
如果说阻塞的控制方式是悲观策略，也就是说，系统认为两个线程之间很有可能发生不幸的冲突，因此以保护共享数据为第一优先级，相对来说，非阻塞的调度就是一种乐观的策略。它认为多个线程之间很有可能不会发生冲突，或者说这种概率不大。因此大家都应该无障碍地执行，但是一旦检测到冲突，就应该进行回滚。
从这个策略中也可以看到，无障碍的多线程程序并不一定能顺畅运行。因为当临界区中存在严重的冲突时，所有的线程可能都会不断地回滚自己的操作，而没有一个线程可以走出临界区。这种情况会影响系统的正常执行。所以，我们可能会非常希望在这一堆线程中，至少可以有一个线程能够在有限的时间内完成自己的操作，而退出临界区。至少这样可以保证系统不会在临界区中进行无限的等待。
一种可行的无障碍实现可以依赖一个"一致性标记"来实现。线程在操作之前，先读取并保存这个标记，在操作完成后，再次读取，检查这个标记是否被更改过，如果两者是一致的，则说明资源访问没有冲突。如果不一致，则说明资源可能在操作过程中与其他线程冲突，需要重试操作。而任何对资源有修改操作的线程，在修改数据前，都需要更新这个一致性标记，表示数据不再安全。
数据库中乐观锁，应该比较熟悉，表中需要一个字段version(版本号)，每次更新数据version+1，更新的时候将版本号作为条件进行更新，根据更新影响的行数判断更新是否成功，伪代码如下：
1.查询数据，此时版本号为w_v
2.打开事务
3.做一些业务操作
4.update t set version = version+1 where id = 记录id and version = w_v;//此行会返回影响的行数c
5.if(c&gt;0){
//提交事务
}else{
//回滚事务
}
多个线程更新同一条数据的时候，数据库会对当前数据加锁，同一时刻只有一个线程可以执行更新语句。
无锁(Lock-Free) 无锁的并行都是无障碍的。在无锁的情况下，所有的线程都能尝试对临界区进行访问，但不同的是，无锁的并发保证必然有一个线程能够在有限步内完成操作离开临界区。
在无锁的调用中，一个典型的特点是可能会包含一个无穷循环。在这个循环中，线程会不断尝试修改共享变量。如果没有冲突，修改成功，那么程序退出，否则继续尝试修改。但无论如何，无锁的并行总能保证有一个线程是可以胜出的，不至于全军覆没。至于临界区中竞争失败的线程，他们必须不断重试，直到自己获胜。如果运气很不好，总是尝试不成功，则会出现类似饥饿的先写，线程会停止。
下面就是一段无锁的示意代码，如果修改不成功，那么循环永远不会停止。
while(!atomicVar.compareAndSet(localVar, localVar+1)){
localVal = atomicVar.get();
}
无等待 无锁只要求有一个线程可以在有限步内完成操作，而无等待则在无锁的基础上更进一步扩展。它要求所有线程都必须在有限步内完成，这样不会引起饥饿问题。如果限制这个步骤的上限，还可以进一步分解为有界无等待和线程数无关的无等待等几种，他们之间的区别只是对循环次数的限制不同。
一种典型的无等待结果就是RCU(Read Copy Update)。它的基本思想是，对数据的读可以不加控制。因此，所有的读线程都是无等待的，它们既不会被锁定等待也不会引起任何冲突。但在写数据的时候，先获取原始数据的副本，接着只修改副本数据(这就是为什么读可以不加控制)，修改完成后，在合适的时机回写数据。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/adde74fa2134cbb140f90d5e7f463b99/" rel="bookmark">
			STM32学习笔记—ADC采集数据常见问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		STM32 ADC 基础内容
STM32内部集成的ADC与型号有关，有16位、12位ADC，内部集成ADC多达4个，通道数多达40个，甚至更多。
1. ADC分辨率
分辨率决定了ADC的转换精度，按理说分辨率越高越好，但价格更贵。
STM32内部集成的ADC最高16位，2的16次方，即65536的分辨率。只有少数STM32才集成16位分辨率的ADC，绝大部分支持12位。
当然，有时出于提高转换速率的考虑，可以软件配置成10 位、 8 位或 6 位的分辨率。
2. ADC采样率
采样率指每秒进行AD转换的次数，STM32的采样率由ADCK时钟，以及分频比决定。
不同型号的STM32，其ADCCLK时钟也有差异，具体可参看芯片对应的手册。
3. ADC通道
STM32的每个ADC有数条复用模拟输入通道，具体通道数因不同系列及型号而异。片内温度传感器、内部参考电压、VBAT还可以与内部模拟通道相连，便于测量和使用。
4. ADC数据对齐
STM32的AD转换后存储数据的对齐方式可通过软件配置成左对齐、右对齐。比如规则组12位分辨率左右对齐如下：
这里数据对齐还与规则组/注入组、分辨率等有关。
5.ADC触发方式
STM32触发ADC转换的方式有很多种，软件触发、外部事件（如定时器事件、 EXTI 中断事件）触发转换。
外部事件触发还分为上升沿和下降沿触发：
STM32 ADC基础内容及配置参数比较多，更多细节请查阅芯片对应的参考手册。
STM32 ADC 参数配置
STM32 ADC配置的参数相对较多，只要理解了ADC的基础内容，再结合STM32CubeMX或官方提供的例程，使用ADC就较容易了。
比如：最基础的单通道配置（默认配置）：
1.STM32CubeMX
2.标准外设库
ADC_InitTypeDef ADC_InitStructure; ADC_CommonInitTypeDef ADC_CommonInitStructure; RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1, ENABLE); ADC_CommonInitStructure.ADC_Mode = ADC_Mode_Independent; ADC_CommonInitStructure.ADC_Prescaler = ADC_Prescaler_Div4; ADC_CommonInitStructure.ADC_DMAAccessMode = ADC_DMAAccessMode_Disabled; ADC_CommonInitStructure.ADC_TwoSamplingDelay = ADC_TwoSamplingDelay_5Cycles; ADC_CommonInit(&amp;ADC_CommonInitStructure); ADC_InitStructure.ADC_Resolution = ADC_Resolution_12b; ADC_InitStructure.ADC_ScanConvMode = DISABLE; ADC_InitStructure.ADC_ContinuousConvMode = DISABLE; ADC_InitStructure.ADC_ExternalTrigConvEdge = ADC_ExternalTrigConvEdge_None; ADC_InitStructure.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/adde74fa2134cbb140f90d5e7f463b99/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f86487447f9039d71176d5c33b928e25/" rel="bookmark">
			idea报错java: 程序包com.alibaba.fastjson不存在，明明存在！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		经常从线上拉下来代码后编译运行时会报这个错误。刷新maven也没用，重新导入项目也没用
发现解决方法如下：
找到当前报错文件的路径。找到iml文件
删除它！然后刷新maven 就好了！！！
记录一下我的解决方法，如果有更好的方法，欢迎评论区留言探讨~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f57bbeca75848407e12b74c2a48c463e/" rel="bookmark">
			力扣第516题 最长回文子序列 c&#43;&#43; 动态规划 附Java代码 注释版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目 516. 最长回文子序列
中等
相关标签
字符串 动态规划
给你一个字符串 s ，找出其中最长的回文子序列，并返回该序列的长度。
子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。
示例 1：
输入：s = "bbbab" 输出：4 解释：一个可能的最长回文子序列为 "bbbb" 。 示例 2：
输入：s = "cbbd" 输出：2 解释：一个可能的最长回文子序列为 "bb" 。 提示：
1 &lt;= s.length &lt;= 1000s 仅由小写英文字母组成 思路和解题方法 首先，我们使用一个二维数组dp来存储子问题的解，其中dp[i][j]表示字符串s在位置i到位置j范围内的最长回文子序列的长度。然后，我们初始化对角线上的值为1，表示单个字符本身就是一个回文子序列。接下来，我们从字符串尾部开始向前遍历，在每个位置i和j之间进行计算。如果s[i]等于s[j]，则s[i:j]范围内的最长回文子序列长度为s[i+1:j-1]范围内的最长回文子序列长度加2；如果s[i]不等于s[j]，则s[i:j]范围内的最长回文子序列长度为s[i+1:j]和s[i:j-1]中的较大值。最终，返回dp[0][s.size() - 1]，即整个字符串的最长回文子序列长度。 打印的dp数组 a b c b a
复杂度 时间复杂度: O(n*n)
时间复杂度是O(n^2)，其中n为输入字符串s的长度。这是因为我们使用了一个二维数组dp来存储子问题的解，然后使用两层嵌套的循环来填充这个数组，每次循环都需要考虑当前字符以及其之前的所有字符，因此时间复杂度为O(n^2)。
空间复杂度 O(n*n)
空间复杂度也是O(n^2)，因为我们使用了一个二维数组dp来存储子问题的解，其大小为n*n。
c++ 代码 class Solution { public: int longestPalindromeSubseq(string s) { // 创建二维数组dp来存储子问题的解，dp[i][j]表示s[i:j]范围内的最长回文子序列长度 vector&lt;vector&lt;int&gt;&gt; dp(s.size(), vector&lt;int&gt;(s.size(), 0)); // 初始化对角线上的值为1，即单个字符本身就是一个回文子序列 for (int i = 0; i &lt; s.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f57bbeca75848407e12b74c2a48c463e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d3b28cd4ad5f14445e351b822cfb152/" rel="bookmark">
			【教3妹学编程-算法题】重新排列后包含指定子字符串的字符串数目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		3妹：1 8得8，2 8=16， 3 8妇女节…
2哥 : 3妹，在干嘛呢
3妹：双11不是过了嘛， 我看看我这个双十一买了多少钱， 省了多少钱。
2哥 : 我可是一分钱没买。
3妹：我买了不少东西， 衣服、包包、化妆器……， 接下来的一个月只能吃土了， 还要2哥救助~
2哥：你没有用花呗或信用卡吗， 把支付方式重新排列一下， 用最晚还款的那种信用卡，这样就可以暂时不用吃土啦。
3妹：可是后面还是要还信用卡啊。
2哥 : 傻啊你， 后面就发工资了啊， 不就缓解了
3妹：咦，有道理啊
2哥：说到重新排列支付方式，我今天看天一个重新排列的题目，我们来做一下吧~
题目： 给你一个整数 n 。
如果一个字符串 s 只包含小写英文字母，且 将 s 的字符重新排列后，新字符串包含 子字符串 “leet” ，那么我们称字符串 s 是一个 好 字符串。
比方说：
字符串 “lteer” 是好字符串，因为重新排列后可以得到 “leetr” 。
“letl” 不是好字符串，因为无法重新排列并得到子字符串 “leet” 。
请你返回长度为 n 的好字符串 总 数目。
由于答案可能很大，将答案对 109 + 7 取余 后返回。
子字符串 是一个字符串中一段连续的字符序列。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0d3b28cd4ad5f14445e351b822cfb152/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/245c365d4ee0315a898972001fdf71e6/" rel="bookmark">
			计算机系统基础知识（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、嵌入式计算机系统概述 定义：嵌入式系统以应用为中心、以计算机技术为基础，软硬件可剪裁，适应应用系统对功能、可靠性、成本、体积、功耗严格要求的专用计算机系统。其硬件是物理装置，软件则是程序、数据和相关文档。
1.计算机硬件 主要分为5大部件：运算器、控制器、存储器、输入设备和输出设备。其中运算器和控制器如今集成为一体，统称为中央处理单元（Central Processing Unit），即CPU。
运算器是对数据进行加工处理的部件，主要实现算数与逻辑运算，其核心是算数逻辑单元（Arithmetic and Logical Unit，ALU），运算器包含若干通用寄存器，如累加器（ACC）、乘商寄存器（MQ）、操作数寄存器（X）等。运算器内还有程序状态字寄存器（PSW，也称标志寄存器），用于存放一些状态信息。
控制器主要功能是从主存中取出指令并进行分析，以控制各部件有条不紊的完成指令功能。控制器由程序计数器（PC）、指令寄存器（IR）和控制单元（CU）组成。PC存放欲执行指令地址，IR存放当前指令，并指令中的操作码OP（IR）送至CU，用以分析指令并发出各种微操作命令序列。
存储器又分为主存（Main Memory，MM）和外存。主存又由地址寄存器（MAR）、数据寄存器（MDR）和存储体组成，主存具有掉电易失性，其速度快、容量小，一般用于临时存放计算机运行时所需的程序、数据及运算结果。外存容量大、速度慢，可用于长期保存信息。
输入设备：鼠标、键盘等输入信息或命令给主机的设备。
输出设备：显示器、打印机等主机输出给用户的设备。
冯·诺伊曼结构 2.计算机软件 计算机软件是指管理、运行、维护及应用计算机系统开发的程序及相关文档的集合。通常可将计算机软件分为系统软件、中间件和应用软件。
系统软件的主要功能是管理计算机系统的硬件和软件资源，常见的系统软件如操作系统。
应用软件则用于解决应用领域的具体问题，例如聊天、视频等软件。
中间件是一类独立的系统软件或服务程序，常用来管理计算资源和网络通讯，提供通信处理、数据存取、事务处理、Web服务、安全、跨平台等服务。
3.计算机分类 从不同角度可对计算机进行不同的分类，个人移动设备、桌面计算机、服务器(提供大规模和可靠的文件及计算服务)、集群/仓库计算机（将桌面计算机或服务器联网，分布式计算）、超级计算机和嵌入式计算机是其中一种分类方式。
二、数据表示 1.进制计数制及转换 需了解的名词：
基数：即逢几进一。
权：基数的i次方
形式表示符：二进制（B）、八进制（O）、十进制（D）、十六进制（H）
2.数值型数据的表示 (1)原码表示 对于一个n位二进制，其最高位表示符号位，其余n-1位表示数值的绝对值。其真值0有正零和负零两种表示方式，0000 0000和1000 0000。
(2)反码表示 正数的反码与原码同，负数的反码则是原码的符号位不变，其余各位取反，例如-3的真值是-0000 0111，其原码为1000 0111，其反码为1111 1000。
(3)补码表示 正数的补码与原码同，负数的原码为其反码+1，同样以-3为例，其反码为1111 1000，其补码为1111 1001，相较于反码，末位加一。在补码中，0有唯一编码：0000 0000。
(4)移码表示 移码表示法是在数值上增加一个偏移量表示的，常用于表示浮点数的阶码。对于数值的移码表示，只需将其补码的符号位取反即可，故移码中0也有唯一编码：1000 0000。
(5)定点数与浮点数 定点数即小数点位置固定不变，通常有定点小数和定点整数两种约定方式。
机器字长为n时各种码制表示的带符号数的范围如下： 码制定点整数定点小数原码反码补码移码 对于浮点数，其小数点的位置并不固定，因此可以表示更大范围的数。为了提高浮点数表示精度，需要对浮点数进行规格化，其尾数的最高有效位应该为1，浮点数的表示格式如下： 阶符阶码数符尾数 (6)工业标准IEEE754 该标准的表示形式如下：
SPM 其中，S为数的符号位，0正1负；P为指数，用移码表示（偏移值为，p为阶码的位数）；M为尾数，用原码表示。
例:176.0625=10110000.0001，对其规格化为X1.01100000001，对于IEEE754标准，其尾数最高位会被隐藏，故符号为0，阶码为7+127（偏移）=134=10000110，尾数为01100000001000000000000，故0 10000110 01100000001000000000000为标准下的单精度浮点数。
对于阶码全0或全1，有不同的涵义：
不同形式的IEEE754浮点数格式也不同：
3.其他数据的表示 （1）十进制与字符的编码表示 8421码：它是一种有权码，设其各位数值为b3,b2,b1,b0，其权值从高到低依次为8，4，2，1，它表示的十进制为8b3+4b2+2b1+b0，如8-&gt;1000。
余3码：它是一直无权码，是在8421码上加3（0011）形成的。
格雷码：编码规则为相邻两个代码之间只有1位不同，例：1-&gt;0001，2-&gt;0011，3-&gt;0010。
（2） ASCII码 ASCII采用7个二进制位，是国际通用的信息交换标志代码。代码太多，有兴趣可以自己去网上查，这里不再赘述。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/245c365d4ee0315a898972001fdf71e6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f07ae903c9c10b6fff2c5f5d04e59ae/" rel="bookmark">
			【408】计算机学科专业基础 - 数据结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据结构知识 绪论 数据结构在学什么 如何用程序代码把现实世界的问题信息化
如何用计算机高效地处理这些信息从而创造价值
数据结构的基本概念 什么是数据： 数据是信息的载体，是描述客观事物属性的数、字符及所有能输入到计算机中并被计算机程序识别和处理的符号的集合。数据是计算机程序加工的原料。
现代计算机处理的数据： 现代计算机——经常处理非数值型问题
对于非数值型的问题：
我们关心每个个体的具体信息
我们还关心个体之间的关系
数据元素： 数据元素是数据的基本单位，通常作为一个整体进行考虑和处理。
数据项： 一个数据元素可由若干数据项组成，数据项是构成数据元素的不可分割的最小单位。
数据对象： 数据对象是具有相同性质的数据元素的集合，是数据的一个子集
数据结构： 数据结构是相互之间存在一种或多种特定关系的数据元素的集合。
数据结构这门课着重关注的是数据元素之间的关系，和对这些数据元素的操作，而不关心具体的数据项内容。
数据结构的三要素 三要素： 逻辑结构
集合结构，各个元素同属一个集合，别无其他关系
线性结构，一对一，顺序关系
树状结构，一对多
图状结构，多对多
数据的运算，针对某种逻辑结构，结合实际需求，定义基本运算（增删改查）
物理结构（储存结构），如何用计算机实现这种数据结构
顺序存储：把逻辑上相邻的元素存储在物理位置上也相邻的储存单元中，元素之间的关系由储存单元的邻接关系来体现
链式存储：把逻辑上相邻的元素存储在物理位置上可以不相邻，借助指示元素存储地址的指针来表示元素之间的逻辑关系。
索引存储：在储存元素信息的同时，还简历附加的索引表。索引表中的每项成为索引项，索引项的一般形式是（关键字，地址）
散列存储：根据元素的关键字直接计算出该元素的存储地址，又称哈希存储
总结： 若采用顺序存储，则各个数据元素在物理上必须是连续的；若采用非顺序存储则各个数据元素在物理上可以是离散的
数据的数据结构会影响存储空间分配的方便程度
数据的存储结构会影响对数据运算的速度
运算的定义是针对逻辑结构的，指出运算的功能
运算的实现是针对存储结构的，指出运算的具体步骤
数据类型： 数据类型是一个值的集合和定义在此集合上的一组操作的总称
原子类型：其值不可再分的数据类型（bool、int等）
结构类型：其值可以再分解为若干分量的数据类型（struct等）
抽象数据类型（ADT）： 是抽象数据组织及其相关的操作，定义了一个ADT就是在定义一种数据结构
算法的基本概念 什么是算法： 程序=数据结构+算法
算法（Algorithm）是对特定问题求解步骤的一种描述，它是指令的有限序列，其中的每条指令表示一个或多个操作
算法的特征： 算法必须拥有以下特性，否则不能被称为算法：
有穷性：一个算法必须总在执行有穷步之后结束，且每一步都可在有穷时间内完成。
确定性：算法中每条指令必须有确切的含义，对于相同的输入只能得出相同的输出。
可行性：算法中描述的操作都可以通过已经实现的基本运算执行有限次来实现。
输入：一个算法有零个或多个输入，这些输入取自于某个特定的对象的集合。
输出：一个算法有一个或多个输出，这些输出是与输入有着某种特定关系的量。
好算法的特质： 正确性：算法应能够正确地解决求解问题。
可读性：算法应具有良好的可读性，以帮助人们理解。
健壮性：输入非法数据时，算法能适当地做出反应或进行处理，而不会产生莫名其妙的输出结果。
高效率：
花的时间少：时间复杂度低
低存储量需求：费内存，空间复杂度低
算法的时间复杂度 定义： 事前预估算法时间开销T(n)与问题规模n的关系（T表示“time”） 规则： 加法规则：T(n) = T1(n) + T2(n) = O(f(n)) + O(g(n)) = O(max(f(n), g(n))) （多项相加，只保留最高阶的项，且系数变为1）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0f07ae903c9c10b6fff2c5f5d04e59ae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7102e2c6b1ad22f58364f7543ebbe96/" rel="bookmark">
			轻松绕过Funcaptcha检测——Ezcaptcha！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，今天我们将为您介绍一个令人兴奋的在线服务 ——EzCaptcha，这个网站可以帮助您更轻松地解决注册Outlook等网站时遇到的验证码问题。
FunCAPTCHA 简介 首先，让我们先来了解一下FunCAPTCHA。它是由谷歌开发的一种验证码技术，可能对很多人来说还很陌生。FunCAPTCHA的验证形式如下所示：
通常情况下，我们需要点击验证码上的小框，以触发验证过程。验证码经常以选择图像中的特定物体数量来进行验证。例如，您可能会看到如下的验证任务：
在这些验证任务中，您需要使用箭头点击图像，直到右侧的图像中的物体数量与左侧图像相匹配，然后再点击“提交”按钮。有时，您可能需要完成多次类似的验证任务，才能成功注册。
虽然看起来简单，但如果尝试使用API来绕过FunCAPTCHA，需要对FunCAPTCHA的内部机制有深入的理解，以及复杂的机器学习模型，才能稳定地绕过验证。
EzCaptcha的解决方案 现在，让我们向您介绍EzCaptcha，这是一个旨在帮助您轻松应对FunCAPTCHA和其他验证码的在线服务。EzCaptcha为您提供了一种简单而高效的方法，通过其API获取验证码的token，从而使您能够快速且大量地通过验证码验证。
EzCaptcha的使用步骤 首先，您需要在EzCaptcha网站上进行注册。请访问他们的官方网站：https://www.ez-captcha.com/#/home，并创建一个账户。在您注册后，您将获得一个ClientKey，这是您的账户密钥，务必妥善保存。
接下来，您可以查看EzCaptcha的官方文档：https://ezcaptcha.atlassian.net/wiki/spaces/IS/pages/425998/createTask。文档中详细介绍了如何使用EzCaptcha的API。
这里我们将需要传入这么几个参数：
type
websiteURL
websiteKey
以outlook为例子主要包括以下步骤：
首先根据以上ezcaptcha的使用文档，我们已经判断出outlook使用Funcaptcha的参数，这样我们就可以POST这样一个内容给服务器
{
"clientKey": "r60f4b494631479a9486d67f84069f61234778",
"task": {
"websiteURL": "https://signup.live.com/signup2",
"websiteKey": "B7D8911C-5CC8-A9A3-35B0-554ACEE604DA",
"type": "FuncaptchaTaskProxyless"
}
}
然后服务器就会返回类似这样的相应：
{
"errorId": 0,
"taskId": "fd8a3af5-339b-47c7-aa10-9badf20cad7f"
}
下一步则是需要post一个获取结果的代码：
{
"clientKey": "r60f4b494631479a9486d67f84069f61234778",
"taskId": "fd8a3af5-339b-47c7-aa10-9badf20cad7f"
}
然后我们就会得到一个返回的结果：
{
"errorId": 0,
"solution": {
"token": "646178c32b93d67c9.7168511505|r=eu-west-1|meta=7|meta_height=325|metabgclr=%23ffffff|metaiconclr=%23757575|mainbgclr=%23ffffff|maintxtclr=%231B1B1B|guitextcolor=%23747474|pk=B7D8911C-5CC8-A9A3-35B0-554ACEE604DA|at=40|ht=1|ag=101|cdn_url=https%3A%2F%2Fclient-api.arkoselabs.com%2Fcdn%2Ffc|lurl=https%3A%2F%2Faudio-eu-west-1.arkoselabs.com|surl=https%3A%2F%2Fclient-api.arkoselabs.com|smurl=https%3A%2F%2Fclient-api.arkoselabs.com%2Fcdn%2Ffc%2Fassets%2Fstyle-manager"
},
"status": "ready"
}
如此我们便得到了结果
EzCaptcha的优势 EzCaptcha提供的验证码服务是付费的，但相对成本较低。每次验证码验证可能只需支付少量点数，成本非常实惠。此外，随着您在EzCaptcha上的使用频率增加，您将获得更多的奖励点数，甚至可以升级为VIP用户。此外，EzCaptcha还提供邀请奖励计划，让您更容易降低成本。
总结 EzCaptcha是一个非常有趣且实用的在线服务，可以帮助您轻松应对FunCAPTCHA等验证码，使您能够更快速地注册Outlook等网站。如果您经常需要处理验证码，EzCaptcha可能是您的最佳选择。不要错过这个令人兴奋的工具，立即访问他们的网站：https://www.ez-captcha.com/。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16425d59e018ff4e3cf88270848f2486/" rel="bookmark">
			[Game]C/C&#43;&#43; &amp; easyx 贪吃蛇小游戏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 Result showC CodeC++ Code Result show C show:
Test play link
C++ show:
Test play link
C Code #include &lt;graphics.h&gt; #include &lt;conio.h&gt; #include &lt;time.h&gt; #include &lt;cstdio&gt; //每走一步蛇的长度都会增加，需要检查 #define MAX_BODY_LENGTH 100 // 贪吃蛇最大长度 #define CELL_SIZE 20 // 每个格子的大小 #define BOARD_WIDTH 25 // 游戏界面宽度（格子数） #define BOARD_HEIGHT 25 // 游戏界面高度（格子数） // 贪吃蛇的方向枚举类型 enum Direction { UP, DOWN, LEFT, RIGHT }; // 定义贪吃蛇的结构体 struct Snake { int x[MAX_BODY_LENGTH]; // 每个身体节的横坐标 int y[MAX_BODY_LENGTH]; // 每个身体节的纵坐标 int length; // 身体长度 Direction dir; // 移动方向 }; // 定义游戏界面的结构体 struct Board { int width; // 界面宽度（格子数） int height; // 界面高度（格子数） int score; // 得分 bool is_over; // 是否结束 Snake snake; // 贪吃蛇 int food_x; // 食物横坐标 int food_y; // 食物纵坐标 }; // 初始化游戏界面 void init_board(Board&amp; board) { board.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/16425d59e018ff4e3cf88270848f2486/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb1cfce7560b4df98dcdfaae2ce15ff9/" rel="bookmark">
			Nginx：如何实现一个域名访问多个项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 背景介绍 最近在多个项目部署中遇到这样一个问题，一个域名如何实现多个项目的访问。因为不想自己单独去申请域名证书和域名配置，便想到了这个方案，结合Nginx的location功能实现了自己的需求，便记录下来。示例中是以项目演示，其他的语言类似同样的方式进行部署。例如node的项目，可以在location中做一个验证，然后使用porxy_pass反向代理模块实现。
2. location模块的匹配介绍 "="前缀指令匹配，如果匹配成功，则停止其他匹配。
普通字符串指令匹配，顺序是从长到短，匹配成功的location如果使用^~，则停止其他匹配（正则匹配）。
正则表达式指令匹配，按照配置文件里的顺序，成功就停止其他匹配。
如果第三步中有匹配成功，则使用该结果，否则使用第二步结果。
2.1. 注意点 匹配的顺序是先匹配普通字符串，然后再匹配正则表达式。另外普通字符串匹配顺序是根据配置中字符长度从长到短，也就是说使用普通字符串配置的location顺序是无关紧要的，反正最后nginx会根据配置的长短来进行匹配，但是需要注意的是正则表达式按照配置文件里的顺序测试。找到第一个匹配的正则表达式将停止搜索。
一般情况下，匹配成功了普通字符串location后还会进行正则表达式location匹配。有两种方法改变这种行为，其一就是使用“=”前缀，这时执行的是严格匹配，并且匹配成功后立即停止其他匹配，同时处理这个请求；另外一种就是使用“^~”前缀，如果把这个前缀用于一个常规字符串那么告诉nginx如果路径匹配那么不测试正则表达式。
location = /uri =开头表示精确匹配，只有完全匹配上才能生效。
location ^~ /uri ^~开头对URL路径进行前缀匹配，并且在正则之前。
location ~ pattern ~开头表示区分大小写的正则匹配。
location ~* pattern ~*开头表示不区分大小写的正则匹配。
location /uri 不带任何修饰符，也表示前缀匹配，但是在正则匹配之后。
location / 通用匹配，任何未匹配到其它location的请求都会匹配到，相当于switch中的default。
3. 配置实例 server { listen 80; server_name hqxg365.com; #charset koi8-r; #access_log logs/host.access.log main; location / { root D:/setup/nginx-1.20.1/html/beian/hqxg365; index index.html index.htm; } # 域名+项目1名称 location ^~ /a1/ { alias D:/setup/nginx-1.20.1/html/beian/hqxg365/a1/; index index.html index.htm; } # 域名+项目2名称 location ^~ /a2/ { alias D:/setup/nginx-1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cb1cfce7560b4df98dcdfaae2ce15ff9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32fda188249a068bf5949b0150d58fe8/" rel="bookmark">
			BuuCTF刷题记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		[FBCTF2019]RCEService 1 这题很有意思啊
需要我们传一个cmd为json格式的那就随便传传
先看看当前目录存在哪些文件
尝试一下读取文件cat发现失败了，不知道啥原因，发现cat，nl等命令都无法执行
怀疑有preg_match函数匹配，先用回车符%0A绕过试试
嘿嘿绕过去了并没发现flag，但是看到了cat命令并没有在usr目录下而是在根目录的bin目录下
直接用bin目录下的cat查看当前目录的index.php
成功拿到源码，其实也无所谓了直接rce就行了
[Zer0pts2020]Can you guess it? 题目描述：
&lt;?php include 'config.php'; // FLAG is defined in config.php if (preg_match('/config\.php\/*$/i', $_SERVER['PHP_SELF'])) { exit("I don't know what you are thinking, but I won't let you read it :)"); } if (isset($_GET['source'])) { highlight_file(basename($_SERVER['PHP_SELF'])); exit(); } $secret = bin2hex(random_bytes(64)); if (isset($_POST['guess'])) { $guess = (string) $_POST['guess']; if (hash_equals($secret, $guess)) { $message = 'Congratulations! The flag is: ' .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/32fda188249a068bf5949b0150d58fe8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39a0f05588024c3aae818db72ca24fce/" rel="bookmark">
			我的2023一名云安全专员年度工作分解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ee9e63048330e9a8a83a561abc753c2/" rel="bookmark">
			数据结构与算法 | 第四章：字符串
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文参考网课为 数据结构与算法 1 第四章字符串，主讲人 张铭 、王腾蛟 、赵海燕 、宋国杰 、邹磊 、黄群。
本文使用IDE为 Clion，开发环境 C++14。
更新：2023 / 11 / 12
数据结构与算法 | 第四章：字符串 字符串概念字符串字符字符编码子串 抽象数据类型存储与实现顺序存储C / C++的标准字符串标准串运算字符串长度字符串寻找字符 C++的字符串类 String字符串类运算构造算子赋值算子提取子串 模式匹配概念应用分类精确匹配单选模式朴素匹配算法KMP 算法 近似匹配 参考链接 字符串 概念 字符串 字符串 是一类简单的由 字符（ char）构成的线性结构的 线性表。
字符串 简称 串，为零个或多个 字符 / 符号 构成的有限序列。
n (&gt;=0) 个 字符 的有限序列，一般记作 S C0C1…Cn-1。
S 为串名C0C1…Cn-1为串值。Ci中i位置上的 字符 / 符号n 为字符串长度。长度为零的串，不包含任何字符内容。理论上，一个字符串的长度可以为任意的有限长度，实际上： 定长
具有固定的最大长度，所用内存量始终如一变长
根据实际需要伸缩，以提高内存空间利用率 字符 字符 的取值依赖于字符集。常用的字符集包括：
由 {0, 1} 所构成的二进制字符集由4个字符组成的生物信息的DNA字符集由26个字符和标点符号等组成的英语语言由6763个常用汉字和682个全角非汉字符号等所构成的简体中文标准字符集GB2312适用于跨语言、跨平台的通用字符集USC（ Universal Character Set ） 这些 字符 在计算机里是如何存储和运算呢？这就需要 字符编码 来建立 字符集 与计算机数字系统之间的对应关系。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6ee9e63048330e9a8a83a561abc753c2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f2d1d89879b9bf054336279b689a491/" rel="bookmark">
			简单理解Vue2的响应式原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用Vue作为前端开发技术栈的同学，在使用Vue时都会有一些好奇：为啥我们的响应式变量要在data中定义？Vue是如何监听到变化，实现响应式的？这次我们就来探究一下，Vue2的响应式原理。
对象的响应式 修改属性描述实现响应式 首先我们来实现基础的响应式，即监听data数据的变化。我的代码中提供了较详细的注释。
// 判断是否属于object function isObject(obj) { // 注意 null的typeof 也是 'object' return typeof obj === "object" &amp;&amp; obj != null; } // 为入参提供响应式逻辑 export function observer(obj) { // 不是object 原样返回 if (!isObject(obj)) return obj; // 遍历对象，为每个属性增加响应性 for (const key in obj) { defineReactive(obj, key, obj[key]); } } // 存储真正的属性值 const _obj = {}; // 为每个属性增加响应性 function defineReactive(obj, key, value) { _obj[key] = value; Object.defineProperty(obj, key, { // 取值 get() { console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9f2d1d89879b9bf054336279b689a491/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/834e806675245ebc4b73b7da672521be/" rel="bookmark">
			Acwing - 算法基础课 - 笔记（动态规划 · 二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 动态规划（二）线性DP数字三角形最长上升子序列最长上升子序列II最长公共子序列最短编辑距离编辑距离 区间DP石子合并 计数类DP整数划分 动态规划（二） 今天是讲线性DP和区间DP
线性DP 状态转移方程呈现出一种线性的递推形式的DP，我们将其称为线性DP。
DP问题的时间复杂度怎么算？一般是状态的数量乘以状态转移的计算量
DP问题，是基础算法中比较难的部分，因为它不像其他算法，有个代码模板可以用于记忆。DP问题更偏向于数学问题，它没有一套代码模板，但是有一种思考方式。遇到DP问题，通常我们可以从2个方面进行思考：
状态表示 考虑是一维还是二维（f[i] 或者 f[i][j]）考虑这个状态表示的是哪些集合考虑f[i][j]的值，代表的是这个集合的什么属性 状态计算（状态转移方程） DP问题最难的点就在于状态转移（对集合进行划分），即需要自己去想，某个状态，如何从其他的状态转移过来。这个没有固定套路，只能多练，形成经验。DP问题通常都是从实际问题抽象来的，针对某一种DP问题，只要尝试并发现某种状态转移的方式是可行的，是能求出最终解的，那么形成经验后，再遇到该类DP问题，便能更快的解决。 下面通过具体例题，对DP问题的解题过程进行讲解。
数字三角形 题目链接
题目描述：从顶部出发，在每一结点可以选择移动到其左下方的结点或移动至其右下方的结点，一直走到底层，要求找出一条路径，使路径上的数字的和最大。
分析：
三角形一共有n层，在第i层，共有i个数字，可以用a[i][j]来表示三角形中的第i行的第j列（其中j &lt;= i），对于某个位置[i,j]，设状态f[i][j]表示的集合是：从顶点到该点的全部路径；而f[i][j]的值，表示的是这个集合的什么属性呢？容易想到，自然是表示到达该点的全部路径中，数字和最大的那一条路径的数字和。
状态的表示思考完了，接下来是状态计算。由于每个点，都只能从其左上方的点，或右上方的点走过来。所以，我们可以对f[i][j]表示的集合进行划分，划分为2个子集合：从左上方的点过来的路径，从右上方的点过来的路径。
那么f[i][j] = max(f[i - 1][j - 1], f[i - 1][j]) + a[i][j]
这就是状态转移方程了（注意对每一层的第一个点和最后一个点，需要做一下特判，或者不用做特判，初始化f[i][j]时，多初始化一些位置即可）
根据这个思路，写成代码如下
#include &lt;iostream&gt; const int N = 510; int a[N][N]; // 存储三角形 int f[N][N]; // 存储状态 int n; int main() { scanf("%d", &amp;n); for(int i = 1; i &lt;= n; i++) { for(int j = 1; j &lt;= i; j++) scanf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/834e806675245ebc4b73b7da672521be/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/361211d90b3a613f9d2656a8e207096a/" rel="bookmark">
			单片机CC2530通用I/O端口（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
I/O 端口的基础知识
一、配置功能寄存器（PxSEL）
二、配置方向寄存器（PxDIR）
三、配置工作模式寄存器（PxINP）
I/O 端口的应用
（一）流水灯
main.c
sys_init.c
sys_init.h
运行结果
（二）按键 1.按键与高低电平（灯的亮灭）
2.按键消抖
（1）按键抖动
（2）按键消抖
（3）软件消抖
（三）按键控制一个LED灯的亮灭
main.c
sys_init.c
sys_init.h
运行结果：
I/O 端口的基础知识 CC2530有40个引脚，21个可编程I/O引脚，其中P0、P1各有8个，P2有5个。
I/O 端口配置寄存器分别为：功能寄存器（PxSEL）、方向寄存器（PxDIR）、工作模式寄存器（PxINP），x表示0，1，2。
例如：如把P2所有端口改成输入。
解题：改成输入，从1到0，与非关系。P2DIR &amp;= ~0xFF。
一、配置功能寄存器（PxSEL） 例如：要求将P0.4改成通用 I/O 口。
解题：外设改成通用，又是一个置零过程，与非关系。
1111 1111这是初始过程，1110 1111这是将P0.4置零。因为4，前面有0，1，2，3(按下标来算，类似数组)，所以从后往前数第五个，1该成0。把前半段和后半段分成两个部分，每个部分与初始不同的位，按2的该位下标次方求和，分别填在 0x _ _ 的后两位上。
0+0+0+2.^0=1 0+0+0+0=0
所以，P0SEL &amp;= ~ 0x10。
例2：将P0.4和P0.5设置成外设的 I/O 口。
解题： 0000 0000（初始）0011 0000（设成外设）0-&gt;1 =&gt; 或 0+0+2.^0+2.^1=3 0+0+0+0=0
所以，P0SEL |= 0x30。
二、配置方向寄存器（PxDIR） 例1：将P0.4和P0.5改成输入。
改输入=&gt;置零=&gt; 与非
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/361211d90b3a613f9d2656a8e207096a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c16d01a36f92413028e225cafeb8097/" rel="bookmark">
			基于javaweb&#43;mysql的jsp&#43;servlet在线商城购物商城服装商城(前台、后台)(java&#43;jsp&#43;servlet&#43;mysql)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于javaweb+mysql的jsp+servlet在线商城购物商城服装商城(前台、后台)(java+jsp+servlet+mysql)
私信源码获取及调试交流
运行环境
Java≥8、MySQL≥5.7、Tomcat≥8
开发工具
eclipse/idea/myeclipse/sts等均可配置运行
适用
课程设计，大作业，毕业设计，项目练习，学习演示等
功能说明
在线商城，实现了商城的基本功能
如分类展示商品信息、搜索商品信息、用户注册登录、添加商品到购物车、提交订单、个人中心查看订单、留言板留言等
管理员登录后台后可以查看管理用户信息、商品分类信息、商品信息、新闻信息、留言信息、订单信息等。
商城模板通用，可修改为任意商城，如手机商城、鲜花商城等等
后台管理员
前台用户
技术框架
CSS JavaScript JSP Servlet JDBC MySQL
基于javaweb+mysql的JSP+Servlet在线商城购物商城服装商城(前台、后台)(java+jsp+servlet+mysql)
Files fs = su.getFiles();//获得所有文件 File f = fs.getFile(0);//获得上传的文件 String fname = f.getFileName();//获得文件名 try { su.save("images/product");//保存图片到指定位置 } catch (SmartUploadException e) { e.printStackTrace(); } Request req1 = su.getRequest(); String pname = req1.getParameter("productName"); String id = req1.getParameter("parentId"); String price = req1.getParameter("productPrice"); String desc = req1.getParameter("productDesc"); String stock = req1.getParameter("productStock"); EASYBUY_PRODUCT p = null; if(price!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3c16d01a36f92413028e225cafeb8097/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0327ebc14b3502bf71d0ffd321f3d2c4/" rel="bookmark">
			Matplotlib绘图一网打尽【持续更新ing】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2 绘制扇形图 绘制一个展示男女乘客比例的扇形图
得出男女的具体数字
sex_per = df["Sex"].value_counts() sex_per # 把画图的包导入进来 import matplotlib.pyplot as plt # 这种绘图方式主要用于有多个子图以及复杂的图形布局的时候。 fig,ax = plt.subplots() # plt.subplots() 会创建一个新的图形（figure）和对应的轴（axes）对象。 # 这个函数返回一个元组，第一个元素是图（figure），第二个元素是轴（axes）。 # fig 是用来设置图形的一些全局属性，比如标题、坐标轴范围等。 # ax 是一个包含两个轴的子图对象，可以用于绘制图形。 ax.pie(sex_per, labels=sex_per.index) # # 第一个参数是，绘图的数据 # 第二个参数是图中的标签,这句话亦可 ax.pie(sex_per, labels=["male","female"]) ax.set_title("Pie Chart") plt.show() # 用于在用户界面中打开一个窗口来显示绘制的图形。 # 如果你在绘图过程中省略了plt.show()，那么图形可能不会以预期的方式显示出来。 # 这是因为plt.show()会触发图形的渲染和显示过程。 # 在一些情况下，例如在Jupyter Notebook或IPython中，plt.show()可能不是必需的， # 因为图形会自动显示。但在其他环境中，例如在脚本或Python交互式解释器中，使用plt.show()是必要的，否则图形将不会显示。 # 因此，虽然plt.show()不是绝对必需的，但在绘图过程中通常建议使用它以确保图形正确显示。 # 没有多个子图的时候直接用plt绘图即可 plt.pie(sex_per, labels=sex_per.index) ax.set_title("Pie Chart") plt.show() 3 绘制散点图 绘制一个展示票价 Fare, 与乘客年龄和性别的散点图
# 票价与年龄 的散点图 # 用ax绘图，把横纵坐标的数据输入进去 plt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0327ebc14b3502bf71d0ffd321f3d2c4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb88653b6f3c8961270aef40bf77fea4/" rel="bookmark">
			基于javaweb&#43;mysql的jsp&#43;servlet校园论坛校园bbs(管理员、用户)(java&#43;jsp&#43;servlet&#43;mysql)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于javaweb+mysql的jsp+servlet校园论坛校园bbs(管理员、用户)(java+jsp+servlet+mysql)
私信源码获取及调试交流
运行环境
Java≥8、MySQL≥5.7、Tomcat≥8
开发工具
eclipse/idea/myeclipse/sts等均可配置运行
适用
课程设计，大作业，毕业设计，项目练习，学习演示等
功能说明
管理员：登录、注册、发贴、回复、用户管理、帖子管理等
用户：登录、注册、发贴、回复
用户
管理员
技术框架
CSS JavaScript jQuery JSP Servlet JDBC MySQL
基于javaweb+mysql的JSP+Servlet校园论坛校园BBS(管理员、用户)(java+jsp+servlet+mysql)
public void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { int fid = Integer.parseInt(request.getParameter("fid")); BbsServiceInf service = new BbsServiceImpl(); //查询所有的回复 ForumEntity forum = service.findReplyList(fid); request.setAttribute("forum", forum); request.getRequestDispatcher("page/tourist/replyinfo.jsp").forward(request, response); } } @SuppressWarnings("serial") public class UPdeleteReplyByIdServlet extends HttpServlet { public void service(HttpServletRequest request,HttpServletResponse response) throws ServletException,IOException{ String replyid=request.getParameter("rid"); int rid=Integer.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fb88653b6f3c8961270aef40bf77fea4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f0cdb2d8a42371a45da05ffe74534dc/" rel="bookmark">
			基于javaweb&#43;mysql的jsp&#43;servlet个人博客系统(java&#43;jsp&#43;servlet&#43;mysql)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于javaweb+mysql的jsp+servlet个人博客系统(java+jsp+servlet+mysql)
私信源码获取及调试交流
运行环境
Java≥8、MySQL≥5.7、Tomcat≥8
开发工具
eclipse/idea/myeclipse/sts等均可配置运行
适用
课程设计，大作业，毕业设计，项目练习，学习演示等
功能说明
技术框架
JSP Servlet MySQL
基于javaweb+mysql的JSP+Servlet个人博客系统(java+jsp+servlet+mysql)
/** * @see HttpServlet#HttpServlet() */ public UserArticleServlet() { super(); // TODO Auto-generated constructor stub } /** * @see HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response) */ protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { String method = request.getParameter("method"); if("list".equals(method)){ listUserArticle(request,response); } if("add".equals(method)){ addArticle(request,response); } if("showPage".equals(method)){ listUserPageArticle(request,response); } if("get".equals(method)){ getArticle(request,response); } if("update".equals(method)){ updateArticle(request,response); } if("del".equals(method)){ delArticle(request,response); } if("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2f0cdb2d8a42371a45da05ffe74534dc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c98c1f04ab72a9fcc71366d9d67b00d/" rel="bookmark">
			CAA的VS Studio安装及2019、2017专业版密钥
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、官网下载VS Studio二、勾选如下安装信息三、更改软件安装位置四、重启后，将VS拖到桌面创建快捷方式五、进入VS Studio六、VS 17专业版密钥七、VS 19专业版密钥八、加装MFC组件 一、官网下载VS Studio 官网下载地址：
https://visualstudio.microsoft.com/zh-hans/downloads/
下载对应版本后，以VS Studio2017为例：
二、勾选如下安装信息 使用C++的桌面开发
通用Windows平台开发
VS Studio 扩展开发
三、更改软件安装位置 四、重启后，将VS拖到桌面创建快捷方式 五、进入VS Studio 六、VS 17专业版密钥 KBJFW-NXHK6-W4WJM-CRMQB-G3CDH
七、VS 19专业版密钥 NYWVH-HT4XC-R2WYW-9Y3CM-X4V3Y
八、加装MFC组件 1、打开vs，依此点击文件-&gt;新建-&gt;项目，在弹出的窗口中查看是否有MFC选项，如下图。如果没有点击左下角“打开VisualStudio安装程序”
2、进入控制面板，在“程序”中找到vs 2017程序，右键点击“更改”，再在打开的安装程序中点击“使用c++的桌面开发工具”然后勾选mfc
3、安装完成后，重启vs
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af0f150f16a1011fe474d493d88b3758/" rel="bookmark">
			【SWAT水文模型】SWAT水文模型建立及应用第七期：SWAT模型检验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SWAT水文模型检验 方式1：参数带回至ArcSWAT方式1.1：文件替换方式1.2：手动修改方式1.3： 方式2：于SWAT CUP中确定检验期结果方式2.1：率定期径流数据验证方式2.2：率定期+检验期径流数据验证 总结参考MATLAB工具包 参考 方式1：参数带回至ArcSWAT 方式1.1：文件替换 将率定完的文件夹（名称为XXX.Sufi2.Swatcup）中所有文件（除文件夹外），复制到ArcSWAT的工作空间下的Scenario下的Default下的TxtInOut，替换掉里面的文件。
注意事项：mdb数据库行数
方式1.2：手动修改 推荐在ArcSWAT中【Manual Calibration】中进行模型验证，不要在SWAT CUP中运行。
步骤1： 打开Manual Calibration，选择参数与变化方式。
如果是r，表示百分比变化，例如r参数=0.1，则在swat中选择Multiply By (1+r)，参数增加10%的意思。如果为v，直接在swat中repalce填上v的值即可。
步骤2： 然后选择相应的HRU即可。 步骤3： 如果参数不在ArcSWAT的【Manual Calibration】里面，就在数据库中修改，但是要点击【rewrite input】。
参数修改完毕后，重新运行SWAT并进行模拟。
【说明】更新了参数后，再运行，会出现新的情景，新情景的参数是刚更改的参数；但是如果不运行，需要再需改参数，只需要将当前的情景设置为default sim即可，刚修正的参数就会不会更新。
方式1.3： 在SWAT CUP中得到率定后参数（Bestsim），需将其带回到SWAT中修改参数并进行模拟。
具体步骤如下：
在SWAT CUP中定义好需要传递给SWAT的参数，如农业管理措施、土地利用类型等。
打开SWAT运行文件夹，并修改其中的control文件。在控制文件中找到包含SWAT CUP参数的行，将其修改为类似于以下格式的代码：
$Parameter General Common SWATCUP
在修改后的control文件中，找到包含SWAT CUP的命令行，将其修改为以下格式：
swatcup.exe -i mymodel.in -o mymodel.out -p myparam.prm -s -l
其中，mymodel.in是SWAT的模型文件名，mymodel.out是输出文件名，myparam.prm是包含SWAT CUP参数的参数文件名。
运行SWAT CUP，按照提示依次输入参数文件名，输出文件名以及SWAT运行文件夹的路径等。
SWAT CUP会自动将参数文件中的参数值写入到SWAT的模型文件中，然后启动SWAT运行。
通过这样的流程，就可以将SWAT CUP参数成功地带回到SWAT中，实现对模型的修改和调整。
model.in文件（位于SWAT-CUP文件中的IN File中）
方式2：于SWAT CUP中确定检验期结果 方式2.1：率定期径流数据验证 在SWAT CUP中进行Validation时，只需要改变“Observed_rch.txt”“SUFI2_extract_rch.def”“Observed.txt”三个文件，将径流数据改为验证期的数据（率定期的数据删掉，重新编号；验证期的数据不可以过长），模拟年份也改为验证期的年份，然后Calibration。其他的数据和参数不用改，SWAT CUP可记住率定参数和率定期的数据。（以与校准运行相同的仿真次数执行迭代）
验证时，将率定好后的参数保持不变，改变模拟开始年份，将率定期观测数据替换为验证期观测数据后再次运行率定程序即可。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/af0f150f16a1011fe474d493d88b3758/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a888377cb629aa7cb160be160ae67299/" rel="bookmark">
			Quartus使用步骤及联合Modelsim仿真教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#使用记录#
对于Quartus的安装步骤这里不再进行讲解，modelsim的安装步骤后续文章会进行讲解，这里也就不过多说明。言归正传，现在来开始我们的使用教程：
一、工程创建 1、首先点击打开Quartus软件，博主这里使用的是22版本的，其他版本的步骤也基本一样。
2、我们可以看到如下界面，点击新建工程
3、首先点击浏览，选择工程文件存放位置，然后修改工程名称，然后点击下方NEXT继续下一步
4、这不用管它直接默认选择空工程，然后点击NEXT
5、这里是添加文件，因为我们没有需要添加的，所以也不需要管，点击NEXT进入下一步就行
6、这里首先点击选择你需要的芯片的芯片包，然后再输入对应的芯片，最后在下面即可看到芯片，然后点击NEXT进入下一步
7、这里点击选择仿真方式以及编写程序使用的语言，选择完成点击NEXT进入下一步
8、点击Finish，工程创建就完成了
二、简单代码编写及下载 1、点击左上角File--&gt;New新建，出现如下界面，选择你的文件类型，原理图输入就选择Block Diagram/Schematic File，我们这里使用代码输入，并且是Verilog HDL语言，所以选择Verilog HDL File然后点击OK。
2、再出现的界面输入代码，这里是一个测试代码，可以复制使用：
module example( input clk, input rst_n, input data, output pos_edge, //上升沿 output neg_edge, //下降沿 output data_edge, //数据边沿 output reg [1:0] D ); //设置两个寄存器，实现前后电平状态的寄存 //相当于对dat_i 打两拍 always @(posedge clk or negedge rst_n)begin if(rst_n == 1'b0)begin D &lt;= 2'b00; end else begin D &lt;= {D[0], data}; //D[1]表示前一状态，D[0]表示后一状态（新数据） end end //组合逻辑进行边沿检测 assign pos_edge = ~D[1] &amp; D[0]; assign neg_edge = D[1] &amp; ~D[0]; assign data_edge = pos_edge | neg_edge; endmodule 3、点击如下按钮编译程序
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a888377cb629aa7cb160be160ae67299/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ddaf3d47863f0eef24cd0a06a6fcaf52/" rel="bookmark">
			分布式事务（二）seata
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Seata核心组件 TC (Transaction Coordinator) - 事务协调者：维护全局和分支事务的状态，协调全局事务提交或回滚。
TM (Transaction Manager) - 事务管理器：定义全局事务的范围、开始全局事务、提交或回滚全局事务。
RM (Resource Manager) - 资源管理器：管理分支事务处理的资源，与TC交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚。
举例：
A服务调用B服务，B服务调用C服务。
此时TM定义全局事务管理的服务是A服务，B服务和C服务是RM。TC就是Seata客户端了。
二、XA模式 1、简介 定义：强一致性分阶段事务模式，牺牲了一定的可用性，无业务侵入。
XA 规范 是 X/Open 组织定义的分布式事务处理（DTP，Distributed Transaction Processing）标准，XA 规范 描述了全局的TM与局部的RM之间的接口，几乎所有主流的数据库都对 XA 规范 提供了支持。
XA模式是一个强一致性的分阶段事务模式，当各个分支事务完成之后，不提交。等各个分支事务将自己的事务执行状态报告给TC，由TC决定是分支事务的提交还是回滚。
这种处理方式保证了数据的一致性，但是每个事务的执行需要等待别的事物执行结果，性能不好。
2、两段式提交 两段式提交：
第一个阶段，所有的分支事务全部执行，但不提交，同时将分支事务的执行情况汇总交给一个协调者。
第二个阶段就是协调者根据各个分支事务的执行情况来给各个分支事务发指令，是一起commit提交还是回滚。
3、XA模式原理 XA执行流程：
第一步：
1.1 事务发起者TM在Seata的客户端TC创建一个全局事务，此时会获取得到一个全局事务Id。
1.2 调用各个分支事务，同时将这个全局事务Id传递过去，这样每个分支事务都获得这个全局事务Id了。
1.3 各个分支事务注册到根据这个全局事务Id注册到seata的客户端TC，这样各个分支事务都注册到了TC的全局事务Id里面了。
1.4 各个分支事务开始执行，执行完成之后不提交。
1.5 各个分支事务将执行结果报告给TC
第二步：
2.1 TM事务发起方 通知TC端开始执行事务。
2.2 TC端根据各个分支事务执行情况，通知各个事务提交/回滚。
2.3 各个分支 事务开始执行 提交/回滚。
1）RM一阶段的工作： 注册分支事务到TC 执行分支业务sql但不提交 报告执行状态到TC。
2）TC二阶段的工作： TC检测各分支事务执行状态 如果都成功，通知所有RM提交事务 如果有失败，通知所有RM回滚事务。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ddaf3d47863f0eef24cd0a06a6fcaf52/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e33d2bbaf0df9c5fbb559865db5e0f1a/" rel="bookmark">
			基于javaweb&#43;mysql的jsp&#43;servlet聊天室(java&#43;jsp&#43;servlet&#43;mysql)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于javaweb+mysql的jsp+servlet聊天室(java+jsp+servlet+mysql)
私信获取源码及调试交流
运行环境
Java≥8、MySQL≥5.7、Tomcat≥8
开发工具
eclipse/idea/myeclipse/sts等均可配置运行
适用
课程设计，大作业，毕业设计，项目练习，学习演示等
功能说明
登录、注册、退出、聊天
技术框架
CSS+JavaScript+ajax+jsp Servlet jdbc MySQL
基于javaweb+mysql的JSP+Servlet聊天室(java+jsp+servlet+mysql)
/** * 用户注册的Servlet类 */ public class RegServlet extends HttpServlet { private static final long serialVersionUID = 5280356329609002908L; public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { // 获取用户名 String username = request.getParameter("username"); // 获取密码 String password = request.getParameter("password"); // 获取性别 String sex = request.getParameter("sex"); // 获取头像 String photo = request.getParameter("photo"); // 获取联系电话 String tel = request.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e33d2bbaf0df9c5fbb559865db5e0f1a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0ca1c5e2ff0201550a998e99f8a5923/" rel="bookmark">
			2023-2024 数据科学与大数据专业毕业设计选题推荐汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
大数据选题
选题迷茫
选题的重要性
更多选题指导
最后 前言 大四是整个大学期间最忙碌的时光,一边要忙着准备考研,考公,考教资或者实习为毕业后面临的就业升学做准备,一边要为毕业设计耗费大量精力。大四的同学马上要开始毕业设计,对选题有疑问可以问学长哦（见文末）!
以下整理了适合不同方向的计算机专业的毕业设计选题
🚀对毕设有任何疑问都可以问学长哦!
更多选题指导:
最新最全计算机专业毕设选题精选推荐汇总
大家好,这里是海浪学长毕设选题专场,本次分享的是
🎯 2024（20届）数据科学与大数据专业毕业设计选题合集
大数据选题 数据科学与大数据专业毕业设计可供选择的有大数据处理与分析，数据可视化与可视分析，数据挖掘与机器学习，预测与预测建模，数据隐私与安全等方向。下面的选题示例提供了广泛的研究领域和技术方向，供数据科学与大数据专业的同学作为毕业设计选题参考。对选题有疑问可以问学长哦！
基于Python的学生网购数据可视化系统 基于Python的智能档案管理系统 基于python的学生奖学金评定系统 基于大数据的个性化图书推荐系统 基于用户兴趣的音乐智能推荐系统 基于Python的动漫电影推荐系统设计 基于大数据的学生课堂行为分析系统 基于大数据的灾情预警信息发布系统 基于Python的豆瓣影视评论的数据采集与分析 基于python的招聘网站数据可视化分析系统 基于大数据挖掘的智能评测和辅导系统 基于大数据的图书馆个性化服务研究 基于Python的高考志愿辅助填报系统 基于阿里巴巴大数据的购物行为分析 基于疾控大数据的可视化分析与应用 智联招聘数据分析与可视化系统设计 基于大数据的景区快捷酒店运营系统 旅游酒店大数据分析平台的设计与实现 大数据背景下数据分析服务的市场分析 大数据技术背景下舆情收集与监测分析 基于社交软件的高校校园网络舆情分析 基于大数据的二次元社交网站体验设计 基于消费者购物记录的商品推荐去重方案 基于知识图谱的微博数据可视化管理研究 基于大数据的徽州古建筑群游客热度研究 大数据技术在商业分析中的实践应用研究 基于广播电视受众大数据的分析方法研究 基于互联网大数据的事件智能抓取和画像 基于大数据的定制旅游网站创新设计研究 基于华为大数据平台的电商网站建设优化 基于无线网络的智慧公交停靠系统方案设计 基于运营商大数据的终端产品运营系统设计 基于大数据的大学生就业创业指导系统探究 基于大数据的生鲜农产品配送监测预警系统 基于大数据的电子商务个性化商品推荐方法 基于大数据技术的高校图书馆服务优化研究 基于大数据技术的航天数据可视化系统设计 健康中国——基于大数据的可视化分析平台 面向城市大数据的分布式并行获取方法研究 基于物联网的校园疫情监控系统设计与实现 大数据背景下的Java知识地图构建研究 基于大数据的多群体用户画像构建系统设计 基于Python的数据脱敏与可视化分析 网络评价对水产品线上销量影响的实证分析 基于Web数据挖掘的网站知识获取及应用 基于大数据分析的钓鱼网站监测研究与应用 购物网站基于大数据的个性化广告推送分析 基于超星LSP系统的教参资源数据库设计 基于三大招聘网站数据词频统计分析的结果 基于大数据的高校学生分析与服务平台的研究 基于Spark的电商智能推荐云平台的研究 基于大数据的图书管理系统移动端APP研究 基于微服务的疫情可视化分析系统设计与实现 基于Python的反反爬虫技术分析与应用 基于Hadoop的网站大数据分析系统设计 基于大数据的2020年中医药网络舆情研究 基于大数据技术的房产中介信息管理系统设计 基于大数据分析的人才在线自动测评系统设计 基于大数据挖掘的职业院校官方网站安全对策 基于大数据分析的数码产品价格预测网站设计 基于大数据的在线学习内容个性化精准推荐分析 基于大数据的旅游信息智慧服务云平台构建研究 基于网络爬虫的招聘信息可视化系统设计与实现 基于网络文本大数据的商洛市康养旅游市场分析 大数据视域下贵州茶叶销售数据分析及策略研究 基于python的微信公众号关注者数据分析 基于大数据的高校信息网用户行为分析系统研究 利用Python实现知识标引系统开发与应用 基于Python平台的金融数据分析技术研究 基于大数据与网络态势感知的网站安全管理研究 基于铁路出行数据的旅客常住地智能识别算法研究 基于大数据和机器学习的大学生选课推荐模型研究 基于大数据技术的房价数据采集及可视化分析应用 基于Scrapy的电商数据分析系统设计与实现 基于Python的Moodle平台数据可视化 基于大数据分析的新疆智慧旅游网站的设计与实现 基于大数据分析的天津广播音视频 网站优化改造 基于大数据的高校官方网站信息安全防护预警机制 基于云平台与一卡通大数据的图书推荐的研究与应用 基于 Python 的招聘数据采集与可视化平台 基于51Job网站求职招聘信息的大数据爬虫分析 基于大数据时代下电子商务个性化推荐的研究与应用 基于Hadoop平台的大数据可视化分析实现与应用 基于大数据的西藏热门景点数据分析及可视化应用研究 造血干细胞移植术后随访系统的设计与数据可视化实现 基于Python的求职信息采集分析系统设计与实现 基于大数据挖掘技术的机动车驾驶人智能培训系统的研究 大数据时代基于CMS的高校网站群平台特点分析与研究 大数据环境下基于高校图书馆网站的数据可视化揭示实践 基于大数据的东南亚地区"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d0ca1c5e2ff0201550a998e99f8a5923/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e71cc902a6240b0751c764f759db598/" rel="bookmark">
			风车IM即时通讯源码&#43;搭建教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		UI 就和 QQ 差不多，功能也基本一致
宝塔环境
Nginx 1.20
Tomcat 8
MySQL 8.0
Redis 7
账号 admin
密码 123456
源码获取请自行百度：一生相随博客
一生相随博客致力于分享全网优质资源，包括网站源码、游戏源码、主题模板、插件、电脑软件、手机软件、技术教程等等，欢迎收藏网站链接
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/057d2c357fd2789ec3a97f18235c89d5/" rel="bookmark">
			react&#43;星火大模型，构建上下文ai问答页面（可扩展）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 最近写的开源项目核心功能跑通了，前两天突发奇想。关于项目可否介入大模型来辅助用户使用平台，就跑去研究了最近比较活火的国内大模型–讯飞星火大模型。
大模型api获取 控制台登录 地址：https://console.xfyun.cn/app/myapp
新建应用后点进去：
获取api地址和其key 左侧选用大模型版本，右侧圈起来的地方就是咱api要调用的数据了
如果没有正常的token或key可能没有实名认证，需要先实名认证下！
下面有关于web的调用接口，这是咱们后面要调用的api接口地址：
技术栈 react hooks + TypeScript + semi-ui（组件库，可选）
下载工具包：
npm i crypto-js base-64 -d
实现 api和key都获取到了，咱就直接开始上代码操作吧！
目录 utils（工具类） 以下工具类getWebsocketUrl方法，负责构建api的URL地址，具体原因可以查阅对应的官方文档说明
import * as base64 from 'base-64'; import CryptoJs from 'crypto-js'; import { requestObj } from '../config'; export const getWebsocketUrl = () =&gt; { return new Promise&lt;string&gt;((resovle, reject) =&gt; { let url = 'ws://spark-api.xf-yun.com/v1.1/chat'; let host = 'spark-api.xf-yun.com'; let apiKeyName = 'api_key'; // let date = new Date().
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/057d2c357fd2789ec3a97f18235c89d5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80005dd129ce1aa1cf218ed54d221465/" rel="bookmark">
			js实现定时刷新，并设置定时器上限
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		定时器
在js中，有两种定时器：
倒计时定时器
倒计时定时器，也叫延时定时器或一次性定时器
功能：倒计时多长时间后执行某个动作
语法：setTimeout(function, timeout);
返回值：int类型，当前定时器是页面的第几个定时器，就返回几
执行频率：只执行一次 var timer2 = setTimeout (function(){ console.log("倒计时定时器执行了"); // 2秒后执行，仅执行一次 }, 2000); 间隔定时器
间隔定时器，也叫反复性定时器或间歇性定时器
功能：每间隔多长时间就执行某个动作
语法：setInterval(function, timeout);
返回值：int类型，当前定时器是页面的第几个定时器，就返回几
执行频率：只要不关闭，会一直执行 var timer2 = setInterval(function(){ console.log("间隔定时器执行了"); // 每隔2秒执行一次 }, 2000); 实践应用
在PC端扫码支付的时候，可以通过倒计时定时器和间隔定时器来实现对订单支付状态的感知。比起通过websocket双向通信，更简单，几行代码就可以搞定 // 倒计时定时器，假设支付订单失效时间是5分钟，那么设置一个倒计时定时器，从发起支付后开始倒时间，超过5分钟后，支付失败，跳转到订单明细页面 setTimeout(function () { window.location.href = '订单明细页面'; }, 300000); // 间隔定时器，每间隔2秒查询一次订单支付状态，若订单支付成功，跳转到订单明细页面 setInterval(function() { $.ajax({ url: '查询订单支付状态', type: 'get', dataType: 'json', data: {order_id: order_id}, success: function (data) { if (data === 1) { window.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/80005dd129ce1aa1cf218ed54d221465/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5302c884a3b25ae09c47bf186df86ac/" rel="bookmark">
			JVM虚拟机：垃圾回收器之Parallel Old(老年代)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 本文重点 本文将学习老年代的另外一种垃圾回收器Parallel Old(PO)，这是一种用于老年代的并行化垃圾回收器，它使用标记整理算法进行垃圾回收。
历史 在1.6之前，新生代使用Parallel Scavenge只能搭配老年代的Serial Old收集器，而现在可以搭配了Parallel old（而且默认就是这个）
配置 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87ef3587b94761adb89e5ee49c9aa544/" rel="bookmark">
			线程安全（JAVA）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		线程安全对于我们编写多线程代码是非常重要的。
什么是线程安全？ 在我们平时的代码中有些代码在单线程程序中可以正常执行，但如果同样的代码放在在多个线程中执行就会引发BUG，而这种现象我们一般称为 “线程安全问题” 或 “线程不安全”。
例如：使用两个线程对 count 变量进行自增操作，每个线程10000次。
private static int count; public static void main(String[] args) throws InterruptedException { Thread t1 = new Thread(()-&gt;{ for (int i = 0; i &lt; 10000; i++) { count++; } }); Thread t2 = new Thread(()-&gt;{ for (int i = 0; i &lt; 10000; i++) { count++; } }); t1.start(); t2.start(); t1.join(); t2.join(); System.out.println(count); } 结果可以看到和我们预期的并不相同，而且当我们多运行几次后，每次的结果还都不相同，这就是一个典型的 线程安全问题
为什么会出现上述情况呢？
自增操作本质上其实分为三步：
– 从内存把数据读到 CPU
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/87ef3587b94761adb89e5ee49c9aa544/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/941eba379f51e8ffb3c30ab68c4a68de/" rel="bookmark">
			Kernel Pwn 入门 (1)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		与用户态程序的pwn不同，Kernel Pwn针对于内核态的漏洞进行，门槛也较用户态pwn更高些。本文分享笔者近来初学Kernel Pwn的经验与教训。
Kernel pwn的环境搭建与基础知识介绍参考这里，笔者认为是一个很好的kernel pwn入门教程系列，本文提到的搭建环境、题目分析等都可以找到，本文也主要参考这个系列的文章编写，若阅读本文存在任何疑问请移步上面的链接。
CTF题目下载地址：github
git clone https://github.com/ctf-wiki/ctf-challenges（内含3道kernel pwn入门题）
搭建环境需要注意的问题 笔者的kernel pwn环境在ubuntu 20.04上搭建，与参考文档保持一致。之前使用Kali安装，环境没问题，但题目做不了，rootfs.cpio无法解压。无奈只能在ubuntu上重装一次。建议使用ubuntu 20.04搭建此环境，否则可能产生意想不到且在网上都很难找到解决方法的问题。运行一个kernel需要打开CPU虚拟化，对于ubuntu 20.04虚拟机，则是打开这两个选项（必须关闭虚拟机才能够勾选）：
经验与教训 在一般的pwn中，我们只能跟着题目程序的意思来，各种配各种凑只为执行一次system("/bin/sh")；而在Kernel pwn中，我们需要跟着LKM的意思来，在内核中各种配各种凑只为执行一次commit_creds(prepare_kernel_cred(NULL))。从这个角度上看，两种形式的pwn在根本上并没有区别。一般题目中都是在自定义的LKM上下文章，所以我们需要重点关注。
另外，根据笔者对两个入门kernel pwn题的初步分析，两道题的cpio文件实际上是经过gzip压缩的，在做题时最好首先file一下确认文件类型，如果不是cpio文件则在本地调试时则应按照原先的打包方式打包回去，否则可能会出现无法启动等问题。有的题目会给出打包文件系统的shell文件，需要重点关注。（搞了两个小时才知道，我说怎么自己打包的cpio比题目给的大这么多） 如果题目给的内核跑不动，可以尝试将boot.sh中申请的内存改大些（即qemu的-m选项后面，如果64M跑不动就改成128M试试）。
在入门测试时，经常会遇到内核启动不了，一直在重启的情况，将控制台强行叉掉后再开启可能会显示：qemu-system-x86_64: -s: Failed to find an available port: Address already in use。这是因为强制关闭后，qemu占用的端口还未被清除。解决方法：使用lsof -i tcp:&lt;port&gt;命令查看指定端口的占用情况，在start.sh中看到了qemu后的-s选项说明默认端口为1234。此时即输入lsof -i tcp:1234，找到占用的pid将其kill即可：kill &lt;pid&gt;
明确了我们需要做什么，再去看题目就不会一脸懵了。
Kernel pwn首杀——强网杯2018 Core（ROP法） 这是一道经典的Kernel pwn入门题。
etc/init.d/rcS文件或根目录下的init文件是内核刚刚开始运行时就会执行的文件，题目中一般进行初始化内核环境搭建工作，必须仔细阅读。
在init文件中，我们发现insmod /core.ko这个语句，加载了一个core.ko，这个就是自定义的LKM。另外，通过cat /proc/kallsyms &gt; /tmp/kallsyms可知，我们可以获取到所有内核函数的符号表，这样我们可以轻松地找到commit_cred函数的地址，又由于boot.sh中并未开启内核的KPTI保护，因此虽然开启了KASLR，但这些内核函数我们可以直接访问。
所以，我们的第一步是遍历/tmp/kallsyms文件找到commit_creds和prepare_kernel_cred两个函数的地址，这一步很简单，会C语言的应该都没有问题。不过为了能够让代码看上去更加简洁，我们使用fscanf函数。该函数从某一个文件标识符中读取字符流并将其转换为我们设定的格式化字符串中的数据。在原理上和scanf函数相似，不过scanf是接受控制台输入的字符。值得注意的是，fscanf函数使用空格分割每一个参数。通过打印/tmp/kallsyms文件我们可以发现，该文件由很多行组成，每一行都有3个值，分别为地址、类型和函数名，中间以空格分开。因此我们可使用fscanf(fd,"%llx%s%s", ...)来进行逐行读取。同时，充分利用其返回值。fscanf的返回值是成功读取参数的个数，因此当文件读取到末尾时，fscanf由于遇到了EOF，因此返回值为0。我们利用此返回值将fscanf语句写到while循环的条件中，就可以实现文件读取结束后自动退出循环。代码如下（这里的printf打印加入了颜色）：
unsigned long long commit_creds = 0, prepare_kernel_cred = 0;	// address of to key function // This function is used to get the addresses of two key functions from /tmp/kallsyms void get_function_address(){ FILE* sym_table = fopen("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/941eba379f51e8ffb3c30ab68c4a68de/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cfc6d0ae6b3cf1f212b227ba93875f1e/" rel="bookmark">
			#react使用01#
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#react-redux是什么#
redux是一个独立专门用于做状态管理的JS库(不是react插件库)
它可以用在react、angular、vue等项目中，但基本与react配合使用
作用：集中式管理react应用中多个组件共享的状态
简单的说：react-redux 是基于 redux二次封装的库，提供了hooks相关的api。
#react-redux的api方法#
1:useDispatch 提供 dispatch(action) 方法更新 state,使用场景
import { connect, useDispatch, useSelector } from 'react-redux';
通过传递函数的使用方式
// action
export const updateNum = (payload) =&gt; {
return {
type: 'aaa',
payload
}
}
dispatch(updateNum('需要传递的值'))
直接修改状态：
dispatch({type: '', data: {}})
#useStore()和 useSelecter()区别#
通过useStore()获取的 getState() 只会获得当前时刻的 redux state，之后state 更新并不会导致这个方法被再次调用。
useSelecter()获取 getState()会重新渲染。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/44/">«</a>
	<span class="pagination__item pagination__item--current">45/321</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/46/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>