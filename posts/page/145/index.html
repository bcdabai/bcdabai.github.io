<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96618a50d19029af565974df13b33962/" rel="bookmark">
			RESTful API 设计规范
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		路径 路径又称为端点，表示API的具体地址。在路径的设计中，需遵守下列约定：
命名必须全部小写资源（resource）的命名必须是名词，并且必须是复数形式如果要使用连字符，建议使用‘-’而不是‘_’，‘_’字符可能会在某些浏览器或屏幕中被部分遮挡或完全隐藏易读 命名必须全部小写和易读都无需解释，可以理解为规定，那么为什么命名必须是名词且需要复数形式呢？这是因为在RESTful中，主语是资源，资源肯定是名词，不能是动词。其次，一个资源往往对应数据库中一张表，表就是实体的集合，因此需要是复数形式。
下面是一些反例：
api.example.com/getUserapi.example.com/addUser 下面是一些正例：
api.example.com/zoosapi.example.com/zoos/animal… HTTP动词 对于如何操作资源，有相应的HTTP动词对应，常见的动词有如下五个（括号里表示SQL对应的命令）：
GET（SELECT）：从服务器取出资源（一项或多项）POST（CREATE）：在服务器新建一个资源PUT（UPDATE）：在服务器更新资源（客户端提供改变后的完整资源）PATCH（UPDATE）：在服务器更新资源（客户端提供改变的属性）DELETE（DELETE）：从服务器删除资源 示例：
HTTP动词路径表述GET/zoos获取所有动物园信息POST/zoos新建一个动物园GET/zoos/ID获取指定动物园的信息PUT/zoos/ID更新指定动物园的信息（前端提供该动物园的全部信息）PATCH/zoos/ID更新某个指定动物园的信息（提供该动物园改动部分的信息）DELETE/zoos/ID删除某个动物园GET/zoos/ID/animals获取某个动物园里面的所有动物信息 参考文献：
RESTful API 设计规范 - 掘金 (juejin.cn)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de2425f729a9dbbc6ca26b7d6a35e6c6/" rel="bookmark">
			记一个laravel问题Script @php artisan package:discover handling the post-autoload-dump event returned with
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.简介 更新了 composer.json，然后安装依赖，报错
2.解决 一般这都是因为某个ServiceProvider没有安装引起的
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e5e5802d09989f91ec114432d40bb81/" rel="bookmark">
			JAVA对接海康威视开发文档
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		日前根据公司需求需要对接海康威视的硬件设备信息。因此特地研究了其开发文档。
萤石开发文档：https://open.ys7.com/help/82
根据业务需求；报警设备安装到所需地址；有人按报警后我们系统会接受该报警消息；可以远程对该报警设备进行操作，比如一键消警。
首先到萤石平台注册开发账号（https://open.ys7.com/cn/s/index）
其次，会得到账号的一些私钥等信息。
然后调用萤石文档提供的获取token接口；可以获取token 信息；每次生成的token有效期是七天。根据自己业务需求可以进行token保存处理。
最后就是利用token进行获取设备信息等操作。
private static Logger logger= LoggerFactory.getLogger(DeviceInfoApi.class); /** * 网关设备信息获取 * @param apiMap * @return */ public static String getDeviceInfoList(String token,String url,String pageStart,String pageSize) throws Exception { Map&lt;String, String&gt; map= new HashMap&lt;&gt;(); map.put("accessToken",token); //分页默认0 map.put("pageStart",pageStart); //分页大小，默认为10，最大为50：50无效；设置为50返回数据仍为10 map.put("pageSize",pageSize); String jsonStr = HttpClientUtil.doPost(url,map); return jsonStr; } /** * * 获取网关设备明细信息 * @return * */ public static String getGatWayDeviceDetail(String token,String url,String deviceSerial){ String message=null; Map&lt;String, String&gt; param=new HashMap&lt;&gt;(); param.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5e5e5802d09989f91ec114432d40bb81/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/009682e7390f88e6053c8a5c554f3d6b/" rel="bookmark">
			Python 程序设计练习1.2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		从键盘输入三个数到a,b,c中，按公式值输出
在同一行依次输入三个值a,b,c，用空格分开，输出 b*b-4*a*c的值
输入格式:
在一行中输入三个数。
输出格式:
在一行中输出公式值。
输入样例:
在这里给出一组输入。例如：
1 7 3
输出样例:
在这里给出相应的输出。例如：
37
方法一
a,b,c=map(int,input().split()) z=b*b-4*a*c print(z) split()：拆分字符串。通过指定分隔符对字符串进行切片，并返回分割后的字符串列表（list）；
map()函数会根据提供的函数对指定序列做映射。
方法二
a,b,c=input().split() a,b,c=eval(a),eval(b),eval(c) z=b*b-4*a*c print(z) split()：拆分字符串。通过指定分隔符对字符串进行切片，并返回分割后的字符串列表（list）；
eval() 函数用来执行一个字符串表达式，并返回表达式的值。相比较上面那种方法麻烦了一些，本文章仅供学习参考，本人也在学习中，不足之处望批评指出。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e50b7a4c90b32e4a9f9bbaeb7ad6a993/" rel="bookmark">
			Nginx配置Https
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前置条件：
在配置https之前请确保下面的步骤已经完成
服务器已经安装nginx并且通过http可以正常访问
不会安装nginx的可以参考下这篇文章：Linux安装nginx（超详细）
拥有ssl证书，没有的可以去阿里购买或者免费申请一年
如果以上条件都满足了，接下来开始配置https
第一步：Nginx的ssl模块安装
在配置ssl证书之前，要确保你的nginx已经安装了ssl模块，一般情况下自己安装的nginx都是不存在ssl模块的。
这里先检查下自己是否存在ssl模块：
进入到你的nginx安装目录下面，我的目录是在（/usr/local/nginx），如果你的nginx安装步骤和上面的文章一致的话，那你的目录和我应该是一致的
进入到目录的sbin目录下，输入
#注意这里是大写的V，小写的只显示版本号 ./nginx -V 如果出现 (configure arguments: --with-http_ssl_module), 则已安装（下面的步骤可以跳过，直接进行第五步）。
一般情况下都是不存在ssl模块的，接下来进入到你的解压缩后的nginx目录，注意这里不是nginx安装目录，是解压缩后的目录，我的是在（/root/nginx），进入目录后，输入
./configure --prefix=/usr/local/nginx --with-http_stub_status_module --with-http_ssl_module 接下来执行
make #切记不要执行make install，否则会重新安装nginx 上述操作执行完成以后，你的目录下会出现objs文件夹，文件夹内存在nginx文件，如图：
接下来使用新的nginx文件替换掉之前安装目录sbin下的nginx，注意这里的替换的时候可以先将之前的文件备份下，停掉nginx服务
./nginx -s stop #停止nginx服务 #替换之前的nginx cp /root/nginx/objs/nginx /usr/local/nginx/sbin 成功之后，进入到nginx安装目录下，查看ssl时候成功
#注意这里是大写的V，小写的只显示版本号 ./nginx -V #可以看到这里出现了configure arguments: --with-http_ssl_module 证明已经安装成功 提示：这里替换后在执行 -V命令如果提示权限不足，先给这个nginx文件提升下权限 我是用的是finalshell连接工具，直接右键就可以修改权限了，当然，也可以通过指令修改，如下：
chmod 111 nginx 第二步：配置ssl证书
解压缩下载好的证书（证书一般是pem文件和key文件，这里名字可以随便改）
将下载好的证书上上传到服务器，我将证书放在了root目录下的card文件夹
#在root目录下创建card文件夹 cd /root mkdir card 第三步：进行nginx.conf配置 进入nginx.conf文件下
cd /usr/locla/nginx/conf #修改nginx.conf文件 vim nginx.conf 打开之后文件内容如图
可以将没用的东西都删除掉，删除的时候注意，括号要对应起来。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e50b7a4c90b32e4a9f9bbaeb7ad6a993/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed3986328b32793e44f5e5483cb1f45c/" rel="bookmark">
			js元素获取（增删改查）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		获取元素 获取父元素(离子元素最近的父亲) 子元素.parentNode 获取子元素 获取全部子元素
parentNode.childNodes(标准，若要获得元素节点 需要专门处理 很麻烦)parentNode.children(非标准、兼容性有要求 推荐使用)
获取第一个和最后一个子元素 获取第一个
parentNode.firstElementChild 获取最后一个
parentNode.lastElementChild 实际开发写法
parentNode.children[0] 获取兄弟节点 node.nextElementSibling(返回下一个兄弟节点)node.previousElementSibling(返回上一个兄弟节点) 创建节点 Document.createElement(‘tagName’) 5.添加节点
node.appendChild(child) 后面追加元素 Node （父级） child（子级）
Node.inserBefore(child,指定元素) ol.insertBefore(lili, ol.children[0])
页面中要添加一个元素
首先要 1.创建一个元素 2.然后添加！
6.删除节点
Node.removeChild(child)
ol.removeChild(ol.children[0])
this.disabled = true;//禁用条件
7.复制节点
Node.cloneNode()
括号里面 如果为空或者为false 是浅拷贝，不复制里面内容
如果括号里为true 则是深拷贝 复制里面的内容
三种动态创建元素区别 Document.write() 在文本中写入一个标签 （用的较少） 创建元素 1.直接将内容写入页面的内容流，但是文档执行完毕，会导致页面重绘，重新开启新的页面
Element.innerHTML 创建元素Document.createElement() InnerHTML和createElement(‘a’)区别
区别在于执行时间不同
拼接字符串用的时间较长
innerHTML是讲内容写入某个DOM节点，不会导致页面全部重绘InnerHTML 创建多个元素效率更高（不要拼接字符串，采取数组形式拼接），结构稍微复杂 采用数组的形式
3.createElement()创建多个元素效率稍低一点点但是结构更清晰
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b7ec2d7e2ca91bd08e9a5b8d6f0624f/" rel="bookmark">
			springboot集成sharding-jdbc
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		sharding-jdbc是当当开源的第三方分库分表插件，目前属于Apache顶级开源项目shardingsphere的一部分，官网Apache ShardingSphere ， sharding-jdbc支持垂直分库，水平分库，垂直分表，水平分表，今天的实验是使用MySQL做主备，主库写，改，删，备库只做查询。
在windows下面实验
第一步：mysql主备设置 安装mysql MySQL Server 5.5 用来做主库
copy一份 MySQL Server 5.5_slave1 用来做备库
mysql主库配置my.ini
#主库设置
[mysqld]
#开启日志
log-bin=mysql-bin
#设置服务id
server-id=1
#设置需要同步的数据
binlog-do-db=study
#屏蔽系统库同步
binlog-ignore-db=mysql
binlog-ignore-db=information_schema
binlog-ignore-db=performance_schema
#从库设置
[mysqld]
#开启日志
log-bin=mysql-bin
#设置服务id
server-id=2
#设置需要同步的数据
binlog-do-db=study.%
#屏蔽系统库同步
binlog-ignore-db=mysql.%
binlog-ignore-db=information_schema.%
binlog-ignore-db=performance_schema.%
设置好了以后，ctrl+alt+del先停止之前的mysqld.exe，再双击重启主和备库。
通过客户端dbvisualizer连上主库master
--授权主备复制专用账号db_sync
GRANT REPLICATION SLAVE ON *.* TO 'db_sync'@'%' IDENTIFIED BY 'db_sync';
--刷新权限
FLUSH PRIVILEGES;
--mysql.user里面已经创建db_sync
select * from mysql.user;
--查看主库状态
SHOW MASTER STATUS;
--通过dbvisualizer登录备库slave，设置master
--停止同步
STOP SLAVE;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3b7ec2d7e2ca91bd08e9a5b8d6f0624f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/770e59be9e9110f3e577fae7b1c42015/" rel="bookmark">
			CentOS7 安装 Logstash8.3.2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下载 解压
wget https://artifacts.elastic.co/downloads/logstash/logstash-8.3.2-linux-x86_64.tar.gz tar -xzvf logstash-8.3.2-linux-x86_64.tar.gz 运行指定 conf
./bin/logstash -f logToEs.conf 后台启动 nohup ./bin/logstash -f log_to_es.conf &gt;/dev/null &amp;; 输入插件（input plugins）用于从给定的源系统中提取或接收数据。
Logstash 参考指南中提供了支持的输入插件列表：Input plugins | Logstash Reference [8.3] | Elastic
过滤器插件（filter plugin）用于对传入事件应用转换和丰富。
Logstash 参考指南中提供了支持的过滤器插件列表：https://www.elastic.co/guide/en/logstash/current/filterplugins.html
输出插件（output plugin）用于将数据加载或发送到给定的目标系统。
Logstash 参考指南中提供了支持的输出插件列表：Output plugins | Logstash Reference [8.3] | Elastic
配置输出
input { beats { port =&gt; 18001 type =&gt; beats_log } } filter { geoip { source =&gt; "clientip" target =&gt; "clientgeo" } } output { stdout {} elasticsearch { # es的ip和端口 hosts =&gt; ["
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/770e59be9e9110f3e577fae7b1c42015/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/365531221f26ab8191f1b012d45348c5/" rel="bookmark">
			linux c sqlite 数据库 使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		linux c sqlite 使用
biometric-authenticationd.c
sqlite3 *bio_sto_connect_db() { sqlite3 *db = NULL; int ret = -1; bool need_create = false; ret = access(DB_PATH, F_OK); if (ret != 0) { need_create = true; ret = access(DB_DIR, F_OK); if (ret != 0) { internal_create_dir(DB_DIR); } /* 创建数据库 */ ret = sqlite3_open_v2(DB_PATH, &amp;db, SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE, NULL); if (ret != SQLITE_OK) { bio_print_error(_("sqlite3 prepare err: %s\n"), sqlite3_errmsg(db)); return NULL; } sqlite3_close_v2(db); /* 设置默认权限：0600（只允许root用户读写） */ ret = chmod(DB_PATH, S_IRUSR | S_IWUSR); if (ret !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/365531221f26ab8191f1b012d45348c5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b37f3cd69e400dcf797aec0b9d9859dc/" rel="bookmark">
			【前端知识之CSS】flex弹性布局和grid网格布局
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 本系列主要整理前端面试中需要掌握的知识点。本节介绍flex弹性布局和grid网格布局。
文章目录 前言一、flex弹性布局1、flex弹性布局是什么2、容器的属性3、成员的属性 二、grid网格布局1、grid布局是什么2、容器的属性3、项目属性 一、flex弹性布局 1、flex弹性布局是什么 对父盒子设置成弹性布局，他的所有子元素自动成为容器成员，称为flex项目item。容器中默认存在两条轴，主轴和交叉轴，呈90度关系。项目默认沿主轴排列，通过flex-direction来决定主轴的方向。每个轴都有自己的起点和终点。
2、容器的属性 容器属性名称属性意义属性可能的值flex-direction决定item排列方向row,row-reverse,column,column-reversejustify-contentitem在主轴上的对齐方式flex-start,flex-end,center,space-between,space-aroundflex-wrap排列不下时，item如何换行nowrap,wrap,wrap-reversealign-content侧轴上子元素的排列方式(多行)flex-start,flex-end,center,space-between,space-around,stretchalign-items侧轴上子元素的排列方式(单行)flex-start,flex-end,center,space-between,space-around,stretchflex-flow复合属性相当于同时设置了flex-direction和flex-wrap flex-direction：决定主轴的方向 .container { flex-direction: row | row-reverse | column | column-reverse; } （1）row（默认）：主轴为水平方向，起点在左端；
（2）row-reverse：主轴为水平方向，起点在右端；
（3）column：主轴为垂直方向，起点在上沿；
（4）column-reverse：主轴为垂直方向，起点在下沿。
2. justify-content：在主轴上的对齐方式
.box { justify-content: flex-start | flex-end | center | space-between | space-around; } （1）flex-start（默认值）：左对齐
（2）flex-end：右对齐
（3）center：居中
（4）space-between：两端对齐，项目之间的间隔都相等
（5）space-around：两个项目两侧间隔相等
3. flex-wrap：排列不下时，item如何换行。
（1）nowrap（默认值）：不换行
（2）wrap：换行，第一行在下方
（3）wrap-reverse：换行，第一行在上方
align-content ：侧轴上子元素的排列方式(多行)，如果项目只有一根轴线，该属性不起作用。
（1）flex-start：与交叉轴的起点对齐
（2）flex-end：与交叉轴的终点对齐
（3）center：与交叉轴的中点对齐
（4）space-between：与交叉轴两端对齐，轴线之间的间隔平均分布
（5）space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍
（6）stretch（默认值）：轴线占满整个交叉轴
align-items：定义项目在交叉轴上如何对齐
（1）lex-start：交叉轴的起点对齐
（2）flex-end：交叉轴的终点对齐
（3）center：交叉轴的中点对齐
（4）baseline: 项目的第一行文字的基线对齐
（5）stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度
3、成员的属性 成员属性名称属性意义属性可能的值order定义item的排列顺序整数，默认为0，越小越靠前flex-grow当有多余空间时，item的放大比例默认为0，即有多余空间时也不放大flex-shrink当空间不足时，item的缩小比例默认为1，即空间不足时缩小flex-basis项目在主轴上占据的空间长度值，默认为autoflexgrow,shrink,basis的简写默认值为0 1 autoalign-self单个item独特的对齐方式同align-items，可覆盖align-items属性 二、grid网格布局 1、grid布局是什么 grid布局是一个二维布局，由纵横相交的两组网格线形成的框架性布局结构，能够同时处理行与列。它擅长将一个页面划分为几个主要区域，以及定义这些区域的大小、位置、层次等关系。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b37f3cd69e400dcf797aec0b9d9859dc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2cca86eb42aec8e0f391016cbccfa5d8/" rel="bookmark">
			uni-app 使用 jsencrypt
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文使用的是 cli脚手架创建的 vue3+vite+ts 框架，其他框架可能会有很大的不同，请谨慎参考。
1.为什么不用jsencrypt依赖 使用jsencrypt依赖的时候会发现，h5下面运行正常，app、小程序报错，报错的原因为没有 window这个对象。
2.解决办法 参考了这篇文章，对其代码进行了兼容vite的小修改，由于代码太长放在文章最后了
使用
import JSEncryptWX from './jsencrypt.js' // 密钥对生成 http://web.chacuo.net/netrsakeypair const publicKey = '秘钥' const privateKey = '秘钥' // 加密 export function encrypt (txt: string): string { let cryptFirst = new JSEncryptWX() cryptFirst.setPublicKey(publicKey) return cryptFirst.encrypt(txt) || '' } // 解密 export function decrypt (txt: string): string { let cryptFirst = new JSEncryptWX() cryptFirst.setPrivateKey(privateKey) return cryptFirst.decrypt(txt) || '' } 如果提示ts不允许引用js的报错，需要在tsconfig.json中的【compilerOptions】中添加
"allowJs": true jsencrypt.js
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2cca86eb42aec8e0f391016cbccfa5d8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa3e9de28590233cde8e2323511b66d7/" rel="bookmark">
			TortoiseSVN Error : Previous operation has not finished； run ‘cleanup‘ if it was interrupted异常解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		TortoiseSVN Error : Previous operation has not finished; run ‘cleanup’ if it was interrupted异常解决办法 在本地修改后，准备通过TortoiseSVN提交，发现报错。异常出现的主要原因是我删除了其中一个文件夹，但没有update更新的原因。
完整报错
Error : Previous operation has not finished; run ‘cleanup’ if it was interrupted.
Error : Please execute the ‘Cleanup’ command.
解决方法
执行 clean up 命令。我们右键打开 svn 的右键折叠菜单，打开 Clean up 窗口。 2. 按下图操作
中文版本
3 之后重新尝试右键点击 SVN Commit... 看是否成功提交。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a93f882888cc127f6e67bd0cf38faa9a/" rel="bookmark">
			JAVA创建对象全过程详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		java世界里面对象无处不在，拿在创建对象的时候都经过哪些步骤？
总结下来大概分为这几步。
对象创建的过程(new 对象的时候) 判断类有没有被加载如果没有(就开始加载类(就是类的加载过程))初始化 ：就是给一些变量进行初始化。设置对象头(比较难理解)。 执行方法: 对对象进行赋值,和执行构造方法。 在第二步类的加载过程：
加载.class文件的时候 window系统下调用底层的应该jvm.dll文件创建java虚拟机去创建一个引导类加载器(C++实现的) 此时java虚拟机已经创建 此时会调用java实现的类加载器启动 加载loadClass方法加载真正的磁盘文件上面的字节码文件,再去发起调用main()方法,,此时程序就启动了
类加载到使用整个过程有如下几步： 加载 &gt;&gt; 验证 &gt;&gt; 准备 &gt;&gt; 解析 &gt;&gt; 初始化 &gt;&gt; 使用 &gt;&gt; 卸载
1、加载：在硬盘上查找并通过IO读入字节码文件，使用到类时才会加载，例如调用 类的main()方法，new对象等等
2、验证：校验字节码文件的正确性
3、准备：给类的静态变量分配内存，并赋予默认值 比如Boolean类型默认 false 这些默认值是java虚拟机自己规定的,如果是加final修饰直接就会变成常量 直接赋值了
4、解析：将符号引用替换为直接引用，就是会将该阶段会把一些静态方法(符号引用，比如 main()方法)替换为指向数据所存内存的指针或句柄等(直接引用)，这是所谓的静态链 接过程(类加载期间完成)，动态链接是在程序运行期间完成的将符号引用替换为直接 引用，下节课会讲到动态链接(在类加载的时候可能不会加载 只有程序运行到这里才会去加载)
5、初始化：对类的静态变量初始化为指定的值，执行静态代码块
第一次记录一下
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ecee91cacb1d42339f051b1f219a58e6/" rel="bookmark">
			oracle数据库plsqldev导出表、表结构的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：plsqldev导出表、表结构的几种方式
文章目录 oracle导出数据的方式1、plsqldev工具导出导入1.1 plsqldev导出数据1、1 Tools--&gt;export tables导出2.1 导出表结构：也可以在plsql-&gt;tool-&gt;ExportUser Objects..中进行操作 2、plsqldev导入数据2、1 Tools--&gt;Import tables oracle导出数据的方式 1、plsqldev工具导出导入 1.1 plsqldev导出数据 1、1 Tools–&gt;export tables导出 结果如下：
prompt PL/SQL Developer import file prompt Created on 2022Äê7ÔÂ15ÈÕ by Administrator set feedback off set define off prompt Disabling triggers for EMP... alter table EMP disable all triggers; prompt Deleting EMP... delete from EMP; commit; prompt Loading EMP... insert into EMP (empno, ename, job, mgr, hiredate, sal, comm, deptno) values (7369, 'SMITH', 'CLERK', 7902, to_date('17-12-1980', 'dd-mm-yyyy'), 800, null, 20); insert into EMP (empno, ename, job, mgr, hiredate, sal, comm, deptno) values (7499, 'ALLEN', 'SALESMAN', 7698, to_date('20-02-1981', 'dd-mm-yyyy'), 1600, 300, 30); insert into EMP (empno, ename, job, mgr, hiredate, sal, comm, deptno) values (7521, 'WARD', 'SALESMAN', 7698, to_date('22-02-1981', 'dd-mm-yyyy'), 1250, 500, 30); insert into EMP (empno, ename, job, mgr, hiredate, sal, comm, deptno) values (7566, 'JONES', 'MANAGER', 7839, to_date('02-04-1981', 'dd-mm-yyyy'), 2975, null, 20); insert into EMP (empno, ename, job, mgr, hiredate, sal, comm, deptno) values (7654, 'MARTIN', 'SALESMAN', 7698, to_date('28-09-1981', 'dd-mm-yyyy'), 1250, 1400, 30); insert into EMP (empno, ename, job, mgr, hiredate, sal, comm, deptno) values (7698, 'BLAKE', 'MANAGER', 7839, to_date('01-05-1981', 'dd-mm-yyyy'), 2850, null, 30); insert into EMP (empno, ename, job, mgr, hiredate, sal, comm, deptno) values (7782, 'CLARK', 'MANAGER', 7839, to_date('09-06-1981', 'dd-mm-yyyy'), 2450, null, 10); insert into EMP (empno, ename, job, mgr, hiredate, sal, comm, deptno) values (7788, 'SCOTT', 'ANALYST', 7566, to_date('19-04-1987', 'dd-mm-yyyy'), 3000, null, 20); insert into EMP (empno, ename, job, mgr, hiredate, sal, comm, deptno) values (7839, 'KING', 'PRESIDENT', null, to_date('17-11-1981', 'dd-mm-yyyy'), 5000, null, 10); insert into EMP (empno, ename, job, mgr, hiredate, sal, comm, deptno) values (7844, 'TURNER', 'SALESMAN', 7698, to_date('08-09-1981', 'dd-mm-yyyy'), 1500, 0, 30); insert into EMP (empno, ename, job, mgr, hiredate, sal, comm, deptno) values (7876, 'ADAMS', 'CLERK', 7788, to_date('23-05-1987', 'dd-mm-yyyy'), 1100, null, 20); insert into EMP (empno, ename, job, mgr, hiredate, sal, comm, deptno) values (7900, 'JAMES', 'CLERK', 7698, to_date('03-12-1981', 'dd-mm-yyyy'), 950, null, 30); insert into EMP (empno, ename, job, mgr, hiredate, sal, comm, deptno) values (7902, 'FORD', 'ANALYST', 7566, to_date('03-12-1981', 'dd-mm-yyyy'), 3000, null, 20); insert into EMP (empno, ename, job, mgr, hiredate, sal, comm, deptno) values (7934, 'MILLER', 'CLERK', 7782, to_date('23-01-1982', 'dd-mm-yyyy'), 1300, null, 10); commit; prompt 14 records loaded prompt Enabling triggers for EMP.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ecee91cacb1d42339f051b1f219a58e6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/deaf48fa92c3b7e0d283884dd0f9a09c/" rel="bookmark">
			c语言之文件管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.文件存储在磁盘上。常见的磁盘有磁盘C、磁盘D。
二.文件分类：程序文件、数据文件
常见的程序文件:源程序文件(.c文件，编译编写的程序)、目标文件(.obj文件)、可执行文件(.exe文件)
数据文件：程序文件写入数据到A文件，程序文件从B文件读取数据，像A文件、B文件这样的称为数据文件
三.文件名：
文件名有一些不能使用的符号
文件名可以不含后缀名
文件后缀表示文件打开方式
文件路径是文件从盘符到找到文件通过的路径的所有符号的集合
四.关于文件的打开和关闭
@1.文件的打开相关函数
a.头文件:&lt;stdio.h&gt;
b.第一个参数是打开文件的路径（相对路径或者绝对路径），第二个参数是打开的方式，注意是以字符串的形式表示的
c.关于常见的打开文件的方式
在选择"w"的打开方式，这次所写入的数据会完全覆盖原先的数据。
@2.文件的关闭相关函数
a.头文件:&lt;stdio.h&gt;
关于文件的打开和关闭使用操作如下图所示
代码执行前 代码执行后
可以发现新创建了一个text.txt文件 五.文件的顺序函数
1.fgetc()函数
a.头文件:&lt;stdio.h&gt;
b.功能:从文件中读取一个字符
c.使用
2.fputc()函数
a.头文件:&lt;stdio.h&gt;
b.功能:向文件中写入一个字符
c.解析:第一个参数表示写入文件的字符
d.使用:
程序执行前：
程序执行后：
3.fgets()函数
a.头文件:&lt;stdio.h&gt;
b.功能:从文件中读取一行字符
c.解析:第一个表示要存储读取的字符串的地址，第二个参数表示要读取字符串的字符个数
d.使用
4.fputs()函数
a.头文件:&lt;stdio.h&gt;
b.功能:向文件中写入一行数据
c.解析:第一个参数表示写入文件的字符串
d.使用:
程序执行前：
程序执行后：
5.fprintf()函数--格式化输出函数
a.头文件:&lt;stdio.h&gt;
b.功能:向文件中写入一行格式化的数据
c.使用:
程序执行前：
程序执行后： 6.fscanf()函数--格式化输入函数
a.头文件:&lt;stdio.h&gt;
b.功能:从文件中读取格式化的数据
d.使用:
这里少了struct Stu的定义
7.fread()函数 --二进制输入函数
a.头文件:&lt;stdio.h&gt;
b.功能:从文件中读取二进制形式存储的数据
c.解析:第一个参数表示存储以二进制形式存储的数据地址 ，第二个参数表示要读取以二进制数据存储的每个元素的大小，第三个参数表示要读取以二进制数据存储的元素的个数
d.使用:
8.fwrite()函数
a.头文件:&lt;stdio.h&gt;
b.功能:向文件中写入数据转换位二进制
c.解析:第一个参数表示存储以二进制形式存储的数据地址 ，第二个参数表示以二进制数据存储的每个元素的大小，第三个参数表示以二进制数据存储的元素的个数
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/deaf48fa92c3b7e0d283884dd0f9a09c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a1798a733ac824d6b5d1bc44c3030f7c/" rel="bookmark">
			打印万年历
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.从键盘输入年份月份 Scanner input= new Scanner(System.in); System.out.println("请输入年份: "); int year = input.nextInt();//键盘输入年份 Scanner inpt= new Scanner(System.in); System.out.println("请输入月份: "); int month = input.nextInt();//键盘输入月份 2.确定整年天数 确定从1900年至2021年的天数
int zhenNian = 0; for (int i = 1900; i &lt; year; i++) { if (i % 400 == 0 || i % 4 == 0 &amp;&amp; i % 100 != 0) { zhenNian = zhenNian + 366; } else { zhenNian = zhenNian + 365; } } 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a1798a733ac824d6b5d1bc44c3030f7c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce0400b37310bade68e7b2287b64ae99/" rel="bookmark">
			学习-Java继承和多态之方法重载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：文章写完后，目录可以自动生成，如何生成可参考右边的帮助文档
题目：学习-Java继承和多态之方法重载。 本关任务：使用重载方法为 Student 类创建三个构造方法。
代码： Student.java
/** * 任务：使用重载方法为 Student 类创建三个构造方法。 * 类名为：Student */ public class Student { private String name; // 学生的姓名 private String num; // 学生的学号信息 private double grades; // 学生的成绩 // 请在下面的Begin-End之间按照注释中给出的提示编写正确的代码 /********** Begin **********/ // 创建一个有参构造函数，携带一个学生姓名的参数 public Student(String name) { this.name=name; } public Student(String name,String num) { this.name=name; this.num=num; } // 创建一个有参构造函数，携带学生姓名和学生学号信息的参数 public Student(String name,String num,double grades) { this.name=name; this.num=num; this.grades=grades; } // 创建一个有参构造函数，携带学生姓名、学生学号和学生成绩信息的参数 /********** End **********/ public String getName() { return name; } public void setName(String name) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ce0400b37310bade68e7b2287b64ae99/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f206602b03eaa3eb53bb7b4ba8949960/" rel="bookmark">
			跟着代码随想录练算法——二叉树（JS）（上）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		跟着代码随想录练算法——二叉树 [144. 二叉树的前序遍历](https://leetcode.cn/problems/binary-tree-preorder-traversal/)[145. 二叉树的后序遍历](https://leetcode.cn/problems/binary-tree-postorder-traversal/)[94. 二叉树的中序遍历](https://leetcode.cn/problems/binary-tree-inorder-traversal/)[102. 二叉树的层序遍历](https://leetcode.cn/problems/binary-tree-level-order-traversal/)[107. 二叉树的层序遍历 II](https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/)[199. 二叉树的右视图](https://leetcode.cn/problems/binary-tree-right-side-view/)[637. 二叉树的层平均值](https://leetcode.cn/problems/average-of-levels-in-binary-tree/)[429. N 叉树的层序遍历](https://leetcode.cn/problems/n-ary-tree-level-order-traversal/)[589. N 叉树的前序遍历](https://leetcode.cn/problems/n-ary-tree-preorder-traversal/)[590. N 叉树的后序遍历](https://leetcode.cn/problems/n-ary-tree-postorder-traversal/)[515. 在每个树行中找最大值](https://leetcode.cn/problems/find-largest-value-in-each-tree-row/)[116. 填充每个节点的下一个右侧节点指针](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/)[117. 填充每个节点的下一个右侧节点指针 II](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/)[104. 二叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)[111. 二叉树的最小深度](https://leetcode.cn/problems/minimum-depth-of-binary-tree/)[226. 翻转二叉树](https://leetcode.cn/problems/invert-binary-tree/)[101. 对称二叉树](https://leetcode.cn/problems/symmetric-tree/)[559. N 叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-n-ary-tree/)[222. 完全二叉树的节点个数](https://leetcode.cn/problems/count-complete-tree-nodes/)[110. 平衡二叉树](https://leetcode.cn/problems/balanced-binary-tree/)[257. 二叉树的所有路径](https://leetcode.cn/problems/binary-tree-paths/)[100. 相同的树](https://leetcode.cn/problems/same-tree/)[572. 另一棵树的子树](https://leetcode.cn/problems/subtree-of-another-tree/)[404. 左叶子之和](https://leetcode.cn/problems/sum-of-left-leaves/)[513. 找树左下角的值](https://leetcode.cn/problems/find-bottom-left-tree-value/)[112. 路径总和](https://leetcode.cn/problems/path-sum/)[113. 路径总和 II](https://leetcode.cn/problems/path-sum-ii/) 递归遍历
144. 二叉树的前序遍历 /** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f206602b03eaa3eb53bb7b4ba8949960/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30adc5adb430b9214a1c5e6b7a15a75c/" rel="bookmark">
			CAN的过滤器设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CAN节点通过ID过滤可以选择性接收消息，stm32的CAN过滤器有两种模式：列表模式和掩码模式。
（1）列表模式
列表模式只接收符合指定ID的帧，保存指定ID使用2个32位寄存器，分为16位模式和32位模式。
16位列表模式一个ID占16位，一共存4个16位ID，通常用于标准帧，标准帧的ID存入16位的高11位，扩展帧只能存15~17于低3位，另外两位分别存RTR和IDE位，分别表示标准帧(0)/扩展帧(1)，数据帧(0)/遥控帧(1)
32位列表模式一个ID占32位，一共存2个32位ID，通常用于扩展帧，扩展帧的ID存入32位寄存器的高29位，另外3位分别存IDE，RTR和0。
//初始化过滤器------16位列表模式 CAN_FilterInitStruct.CAN_FilterActivation = ENABLE;//使能过滤器 CAN_FilterInitStruct.CAN_FilterFIFOAssignment = CAN_Filter_FIFO0;//安装过滤器到FIFO0 CAN_FilterInitStruct.CAN_FilterMode = CAN_FilterMode_IdList;//过滤器模式 --- 列表 CAN_FilterInitStruct.CAN_FilterNumber = 0;//过滤器0 CAN_FilterInitStruct.CAN_FilterScale = CAN_FilterScale_16bit;//过滤器长度 //提供两个标准帧ID 0x123 , 0x321;提供两个掩码0x7af,0x000 CAN_FilterInitStruct.CAN_FilterIdHigh = 0x123&lt;&lt;5; CAN_FilterInitStruct.CAN_FilterIdLow = 0x321&lt;&lt;5; CAN_FilterInitStruct.CAN_FilterMaskIdHigh = 0x7af&lt;&lt;5; CAN_FilterInitStruct.CAN_FilterMaskIdLow = 0x000; CAN_FilterInit(&amp;CAN_FilterInitStruct); //初始化过滤器------16位掩码模式 CAN_FilterInitStruct.CAN_FilterActivation = ENABLE;//使能过滤器 CAN_FilterInitStruct.CAN_FilterFIFOAssignment = CAN_Filter_FIFO0;//安装过滤器到FIFO0 CAN_FilterInitStruct.CAN_FilterMode = CAN_FilterMode_IdList;//过滤器模式 ---列表 CAN_FilterInitStruct.CAN_FilterNumber = 0;//过滤器0 CAN_FilterInitStruct.CAN_FilterScale = CAN_FilterScale_16bit;//过滤器长度 //提供一个标准帧ID 0x6789abc，0xcba9876 //ID高16位 CAN_FilterInitStruct.CAN_FilterIdHigh = 0x6789abc&gt;&gt;13; //ID低13位放高位，IDE-1 CAN_FilterInitStruct.CAN_FilterIdLow = （0x6789abc&lt;&lt;5）&amp; 0xffff | (0x1)&lt;&lt;2; //ID高16位 CAN_FilterInitStruct.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/30adc5adb430b9214a1c5e6b7a15a75c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ca6321552aa5b6bd4d0f6b354fff561/" rel="bookmark">
			（一）K8S集群部署——master节点部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.集群配置 本次部署使用三台服务器
master：192.168.0.2
node1：192.168.0.4
node2：192.168.0.14
服务器配置均为：CentOS 7.6 64位 8核/16G/100G
2.master部署 介绍一下Docker EE和Docker CE:
Docker EE
Docker EE由公司支持，可在经过认证的操作系统和云提供商中使用，并可运行来自Docker Store的、经过认证的容器和插件。
Docker EE提供三个服务层次：
Basic 包含用于认证基础设施的Docker平台，Docker公司的支持，经过 认证的、来自Docker Store的容器与插件。
Standard 添加高级镜像与容器管理，LDAP/AD用户集成，基于角色的访问控制(Docker Datacenter)。
Advanced 添加Docker安全扫描，连续漏洞监控。
Docker CE
Docker CE是免费的Docker产品的新名称，Docker CE包含了完整的Docker平台，非常适合开发人员和运维团队构建容器APP。
1.设置主机名
hostnamectl set-hostname master 2.yum更换为国内的阿里云yum源
1.进入到yum的源目录下 cd /etc/yum.repos.d/ 2.将原来的CentOS-Base.repo进行备份 mv CentOS-Base.repo CentOS-Base.repo.bak 3.下载替换阿里源 curl -o /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo 5.生成缓存 yum makecache 6.更新 yum -y update 3.安装Docker CE
1.安装所需包 yum install yum-utils device-mapper-persistent-data lvm2 2.新增 Docker 仓库 yum-config-manager \ --add-repo \ https://download.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6ca6321552aa5b6bd4d0f6b354fff561/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0abfc660a33cdcbb2eb0e83f80210043/" rel="bookmark">
			外卖数据库管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		环境 MySQL Community Server 8.0.25 、Python 3.8、Tkinter
需求分析 本程序模拟一个外卖平台系统，该系统由三端构成即用户+商家+配送员。
不同的用户(三类)有不同的ID，姓名可重名。每个用户可以下多个订单，每个订单对应一个配送员，一个订单内可包含多个同一家店铺的商品，每个商家可以同时处理来自多个用户的多个订单。一个配送员可以同时派送多个订单，订单对应的配送员由外卖平台统一分配。
三类用户均可以以自己的账号密码登录对应的系统，可以注册新账号
实现的功能： 用户：登录/注册功能，修改用户信息功能，充值账户余额功能，获取正在营业的店铺菜单功能，点外卖提交订单功能，查询订单功能。商家：登录/注册功能，一键上/下班功能 ，修改商家信息功能，营业额提现功能，商品管理模块包括：查询商品详情、新建商品、修改原有商品、删除商品功能。接单窗口显示已接单未出餐商品，标记餐品为我已出餐功能，查询最近已出餐商品功能。配送员：登录/注册功能，一键上/下班功能 ，修改个人信息功能，工资提现功能，工作窗口显示派送给自己的所有订单，修改订单状态为已完成（点击我已送达）功能，查看最近派送完成的订单功能。 数据库设计 逻辑结构设计 商家：店名，商家号，登录密码，地址，电话，营业额，状态，商品：编号，商品名，价格，商家号，库存骑手：编号，登录密码，姓名，性别，电话，工资，状态，顾客：ID，登录密码，姓名，性别，地址， 电话，余额。订单：订单号，骑手号，顾客ID，状态，备注，配送费，金额，发起时间订单详情：订单号，商品号，数量 关系属性 Store（Sno，Spass，Sname，Saddr，Stel，Smoney，Sstate）Goods（Gno，Sno，Gname，Gprice，Gstock）Customer（Cno，Cpass，Cname，Csex，Caddr，Ctel，Cmoney）Deliverer（Dno，Dpass，Dname，Dsex，Dtel，Dmoney，Dstate）Order（Ono，Dno，Cno，Ostate，Otip，ODelfee，Omoney，Obtime）Purchase（Ono，Gno，Pamount） E-R图 数据表 商店表（store） 主码：Sno自定义完整性：
CHECK (Sstate IN (‘工作’,‘休息’)),
CHECK (Smoney &gt;= 0)
商品表（goods） 主码：Gno外码：FOREIGN KEY (Sno) REFERENCES Store(Sno)
顾客表（Customer） 主码：Cno自定义完整性：
CHECK (Csex IN (‘M’,‘F’)),
CHECK (Cmoney &gt;= 0)
派送员表（deliverer） 主码：Dno自定义完整性：
CHECK (Dsex IN (‘M’,‘F’)),
CHECK (Dstate IN (‘工作’,‘休息’)),
CHECK (Dmoney &gt;= 0)
订单表（orderr） 主码：Ono外码：
FOREIGN KEY (Dno) REFERENCES Deliverer(Dno),
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0abfc660a33cdcbb2eb0e83f80210043/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc91d675b3d3da2f89b665090b3593fb/" rel="bookmark">
			java中 Excel文件解析及超大Excel文件读写
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文主要对Excel中数据的解析和生成进行总结
前言 在应用程序的开发过程中，我们经常要用到Excel进行数据的导入或导出。所以，在通过Java语言实现此类需求时，通常会对Excel文件进行解析或生成。
一、Excel文件解析 1，概述
在应用程序开发过程中，经常需要使用Excel文件来进行数据的导入或导出。所以，在通过Java语言来实现此类需求的时候，往往会面临着Excel文件解析（导入）或生成（导出）。
在Java技术生态圈中，可以进行Excel问价处理的主流技术包括：Apache POI，JXL，Alibaba EasyExcel等。
Apache POI基于DOM方式进行解析，将文件直接加载内存，所以速度较快，适合Excel文件数量不大的应用场景。JXL只支持Excel2003以下版本，所以不太常见。
Alibaba EasyExcel采用逐行读取的解析模式，将每一行的解析结果以观察者模式通知处理（AnalyEventListener），所以比较适合数据体量较大的Excel文件解析。
2， Apache POI
Apache POI使用Java编写的免费开源的跨平台的Java API。Apache POI提供给Java程序对Microso Office 格式档案进行读写功能的API开源类库
HSSF ：提供读写Microsoft Excel格式档案的功能。
XSSF ：提供读写Microsoft Excel 0OXML格式档案的功能。HWPF
HWPF : 提供读写Microsoft Word格式档案的功能。
HSLF : 提供读写Microsoft PowerPoint格式档案的功能。
HDGF : 提供读写Microsoft Visio格式档案的功能。
3， XSSF解析Excel文件
HSSF用于解析旧版本(*.xls) Excel文件， 由于旧版本的Excel文件只能存在65535行数据, 所以目前已经不常用。所以目前主要采用XSSF进行新版本(*.xlsx) Exce文件的解析。
导入下图中的架包：
Workbook (Excel文件)
Workbook接口代表一一个 Excel文件，用于创建或加载(解析)见实现类是XSSFWorkbook。
创建Excel文件：
// 输出流 FileOutputStream fos = new FileOutputStream("c:\\test\\temp.xlsx"); // Excel文件对象 Workbook workbook = new XSSFWorkbook(); // 通过输出流进行写入 workbook.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cc91d675b3d3da2f89b665090b3593fb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17ee00c498eb4ce9f3b5caa976c45851/" rel="bookmark">
			例题 9-27 方块消除（Blocks, UVa10559）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原题链接：https://vjudge.net/problem/UVA-10559
分类：动态规划
备注：多维考虑
dp[i][j][k]表示区间[i,j]块右接上k个与a[j]同色的元素
先将最右边同色的特意挑选出来，得到p ∈ [i, j]中最左边的使得a[p] = a[p+1] = … = a[j]的值，即从右边界j位置往左到p位置是同色的最长段。如果直接将[p,j]消除，则状态转移到d(i, p - 1, 0) + (j - p + 1 +k)^2
如果[i, p - 1]段中仍有与a[j]同色的段，可以找到q满足q&lt;p且a[q] == a[j] &amp;&amp; a[q + 1] != a[q]，考虑将[q+1,p-1]这一段先消除掉，然后让[i,q]和[p,j]拼接起来，则最右边同色段会变长，即与a[j]同色的段有了增长。
这种情况要考虑对q的枚举，状态转移为d(q + 1, p - 1, 0) + d(i, q, j - p + 1 + k)
返回所有状态中最大值即可。
#include &lt;bits/stdc++.h&gt; using namespace std; int t, n, a[205], dp[205][205][205]; int d(int i, int j, int k) { if (i &gt; j) return 0; if (dp[i][j][k]) return dp[i][j][k]; if (i == j) return dp[i][j][k] = (1 + k) * (1 + k); int p = j; while (p &gt; i &amp;&amp; a[p - 1] == a[j]) p--; int ret = d(i, p - 1, 0) + (j - p + k + 1) * (j - p + k + 1); for (int q = p - 1; q &gt;= i; q--) { if (a[q] == a[j] &amp;&amp; a[q] !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/17ee00c498eb4ce9f3b5caa976c45851/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/056d8b210f16f14c328dedcbd9e01f94/" rel="bookmark">
			“ORA-01017（：用户名/口令无效； 登录被拒绝）” ORA-28000： the accout is locked（用户账号被锁）解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		“ORA-01017（：用户名/口令无效; 登录被拒绝）”解决办法 第一种 ORA-01017: invalid username/password; logon denied 分析原因： –1.密码过期或者忘记密码（应该重置密码）
解决方法 – 1.打开CMD命令窗，输入sqlplus / as sysdba
修改密码
SQL&gt;alter user 用户名 identified by 密码
第二种：ORA-28000： the accout is locked 分析原因：用户被锁 解决方法：ALTER USER 用户名 ACCOUNT UNLOCK; 总结：1.遇到第一情况时：cmd 登陆 sqlplus / as sysdba 利用 【alter user 用户名 identified by 密码】命令修改密码即可正常登陆
2.第二种情况（the accout is locked）时，cmd 登陆 sqlplus / as sysdba 利用【ALTER USER 用户名 ACCOUNT UNLOCK;】命令为账号解锁，然后通过【alter user 用户名 identified by 密码】修改密码方可登陆成功
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bfd8be5a4c8469e1f2f5aeb0b7bde9bf/" rel="bookmark">
			CDH6安装教程(亲自测试越坑版)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Hadoop大数据平台 1、Hadoop 发行版 (1) 完全开源的原生的Apache Hadoop
(2) Cloudera与Hortonworks公司的CDH和HDP：在Cloudera和Hortonworks合并后，Cloudera公司推出了新一代的数据平台产品CDP Data Center（以下简称为CDP），从2021年1月31日开始，所有Cloudera软件都需要有效的订阅，并且只能通过付费墙进行访问。也就是说CDH各版本都不能免费获取了。
(3) Ambari + HDP （在Cloudera和Hortonworks合并后，HDP也不能免费使用了）
(4) MapR公司的MapR(已经被HPE收购)
(5) AWS亚马逊的EMR
(6) 国内华为的fusioninsight
(7) 国内星环科技的TDH
CDH (全称:Cloudera’s Distribution Including Apache Hadoop)是由 Cloudera 公司发行的hadoop 软件包，由Cloudera Manager安装监控管理工具和CDH大数据软件包(里面包含了hadoop、hdfs、yarn、hive、spark等许多大数据套件)组成。
2、CM和CDH简介 在安装之前先要梳理一下 CM(Cloudera Manager)和 CDH(Cloudera Distribution Hadoop)的区别：
CDH ​ CDH 是由 Cloudera 公司发行的一套 hadoop 软件包，里面包含了hadoop、hdfs、yarn、hive、spark等等一系列稳定的、版本兼容的大数据套件。
CM ​ CM 也是 Cloudera 公司开发的一套用于管理和监控 CDH 集群的软件，通过 CM 提供的 web 管理页面操作就可以轻松的管理和监控CDH 集群环境。
3、使用CM+CDH的原因 当集群数量有上百台或上千台机器时使用CDH等工具可以快速的安装和扩容
CDH曾经开源免费，从网上可以找到免费的软件安装包
二、安装准备 1、服务器准备 准备好 N 台服务器，我这里用了 3 台机器，分别如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bfd8be5a4c8469e1f2f5aeb0b7bde9bf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53918baf46675ab533f24700a66275ea/" rel="bookmark">
			超详细优化版C语言实现扫雷
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1：对界面进行了优化
2：修复了会出现的一些bug，如下所示
2.1：通过递归实现排查的时候，排查的范围做了缩小，避免深层次的递归
2.2：还有对一些排查的对象进行了重复排查的(类似递归实现斐波那契数列那样)
2.3：对于用户输入的坐标，使用scanf输入的时候，如果出现了误输入，导致程序死循环的情况
2.4：对于用户对一些已经排查过的坐标，进行再次排查，并且误输入，导致程序死循环的情况
这个程序，还是一样的，我分了三个源文件来写
Mine_Clearance_Game.h
#pragma once # include &lt;stdio.h&gt; # include &lt;windows.h&gt; # include &lt;time.h&gt; # include &lt;stdlib.h&gt; #define ROW 9 /*扫雷棋盘显示行*/ #define COL 9 /*扫雷棋盘显示列*/ #define ROWS ROW+2 /*扫雷棋盘实际行*/ #define COLS COL+2 /*扫雷棋盘实际列*/ #define MINE_NUM 10 /*地雷数量*/ /******************控制台函数声明*****************************/ void Gotoxy(int x, int y);/*自定义控制台光标位置*/ void SetWindowSize(void);/*设置控制台窗口标题 大小*/ /******************游戏逻辑函数声明**************************/ void StartGame(void);/*开始游戏*/ void SetMine(char board[][COLS], int row, int col);/*在埋雷棋盘上布置雷*/ void DisplayBoard(char board[][COLS], int row, int col);/*打印扫雷棋盘*/ void ScreenMine(char mine[][COLS], char show[][COLS], int row, int col);/*排查雷*/ static int CalSurroundMineNum(char mine[][COLS], int x, int y);/*统计坐标周边雷数量*/ void ExpandBoard(char mine[ROWS][COLS], char show[ROWS][COLS], int x, int y, int* win);/*递归逐层次排查无雷坐标周边的坐标*/ /******************游戏界面函数声明**************************/ void Menu(void);/*打印游戏开始界面菜单*/ void ShowGameOver(void);/*打印游戏结束画面*/ void ShowSelectError(void);/*选择错误画面*/ void MineBoom(char mine[][COLS], char show[][COLS], int row, int col);/*踩到地雷画面*/ void FindAllMine(char show[][COLS], int row, int col);/*排雷成功画面*/ /***********************************************************/ mine_clearance_game.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/53918baf46675ab533f24700a66275ea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2b01c1d6d3a207611bba99da425fe41/" rel="bookmark">
			springboot&#43;springdata jpa&#43;thymeleaf项目实战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前几天把java实训项目写好了，项目使用的是springboot+spring data jpa+thymeleaf。
对于我这个后端的孩子来说，写前端页面太折磨了。
这个是我们的项目要求，还是很简单的：
下面是properties文件的配置
spring.application.name=teacher # 应用服务 WEB 访问端口 server.port=8080 # THYMELEAF (ThymeleafAutoConfiguration) # 开启模板缓存（默认值： true ） spring.thymeleaf.cache=false # 检查模板是否存在，然后再呈现 spring.thymeleaf.check-template=true # 检查模板位置是否正确（默认值 :true ） spring.thymeleaf.check-template-location=true #Content-Type 的值（默认值： text/html ） spring.thymeleaf.content-type=text/html # 开启 MVC Thymeleaf 视图解析（默认值： true ） spring.thymeleaf.enabled=true # 模板编码 spring.thymeleaf.encoding=UTF-8 # 要被排除在解析之外的视图名称列表，⽤逗号分隔 spring.thymeleaf.excluded-view-names= # 要运⽤于模板之上的模板模式。另⻅ StandardTemplate-ModeHandlers( 默认值： HTML5) spring.thymeleaf.mode=HTML5 # 在构建 URL 时添加到视图名称前的前缀（默认值： classpath:/templates/ ） spring.thymeleaf.prefix=classpath:/templates/ # 在构建 URL 时添加到视图名称后的后缀（默认值： .html ） spring.thymeleaf.suffix=.html spring.datasource.url=jdbc:mysql://localhost:3306/teachers?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=UTC spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver spring.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c2b01c1d6d3a207611bba99da425fe41/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9680ab6755f7d91fb0ccce6c291ec2cb/" rel="bookmark">
			Simscape Multibody 多体动力学仿真教程（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着控制系统复杂性的增加和机器人技术的快速发展，各种复杂的机械系统出现了，如车辆、航天器、机械臂、机器人和人类科学。由于系统自由度的不断提高，越来越多的复杂系统无法用单一模型来建模。因此，开展多体系统建模与仿真研究具有重要意义。另一方面，由于现代精密控制系统的复杂性越来越高，系统内部的组件越多，受控系统的故障概率就越大。在大型复杂系统中，某个子系统一旦发生事故，可能会造成重大的财产损失。
1977年，多体动力学研讨会首次在慕尼黑举行，德国从那时起，关于多体动力学的国际会议层出不穷。近年来，研究人员对多体系统的建模与仿真进行了深入的研究。
多体动力学仿真（MBDS）软件将实际系统分解为刚体、关节、约束、坐标系、驱动器、传感器、输入和其他组件。一个复杂的系统可以用图形组件建模。此外，整个仿真过程包括两个阶段：建模和求解。建模包括两个过程：
首先，物理建模，从几何模型形成物理模型。
第二，数学建模，从物理模型形成数学模型。
解算器是一组求解运动方程的计算算法。解算器的选择取决于问题类型、运动学/动力学、静态平衡、特征值分析等。应选择相应的解算器进行数值计算和求解。它适用于研究相互连接的刚体和/或柔性体在发生大平移或旋转位移时的动力学行为。这些物体的运动是根据施加的载荷和定义的边界条件计算的。
多体动力学仿真（MBDS）不仅可以用于预测可以评估和优化机械系统性能、运动轨迹、碰撞检测、峰值负载等，还可以用于安全性、舒适性等多个方面。用户不仅可以使用通用模块模拟简单的机械系统，还可以使用特定模块快速有效地建模和模拟相关工业应用中的问题。
MBDS在产品开发中的潜力主要体现在以下几个方面原因：
1.减少开发周期和生命周期成本。
制造商通常很难理解真实的系统性能，直到设计过程的最后阶段。机械、电气和其他子系统根据其在系统工程过程中的具体要求进行验证，但完整的系统测试和验证来得晚，导致返工和设计变更，其风险和成本比早期的更高。
图一 防侧倾杆在侧倾运动下的仿真
MBS通过实现早期系统级设计验证，提高了工程效率，降低了产品开发成本。工程师可以评估和管理运动、结构、驱动和控制等学科之间的复杂交互，以更好地优化产品设计，实现性能、安全性和舒适性。除了广泛的分析能力，MBS还针对大规模问题进行了优化，充分利用了高性能计算环境。
MBS的计算时间相对较短。这使其成为一种非常有效的仿真工具，是具有多个自由度的复杂组件的参数研究和优化的最佳选择。
由于计算时间较短，MBS能够及早了解设计参数对系统整体性能的影响。这允许在开发过程的早期阶段做出有根据的设计选择，通过缩短交付周期和显著减少扩展硬件测试的数量来节省成本。
图二 轮胎与地面接触时的作用力
举个例子，有了Adams Car，工程师可以快速构建和测试整车和车辆子系统的功能虚拟原型。在Adams车辆垂直环境中工作，汽车工程团队可以在各种道路条件下执行其车辆设计，执行通常在试验实验室或试验跑道上进行的相同试验，但时间很短。可以满足以下要求：
⚫ 悬架、转向和整车操纵分析
⚫ 易于将控制系统集成到车辆模型中
⚫ 在线框或三维实体中创建或导入零部件几何图形
⚫ 用于定义零件连接性的关节和约束的广泛库
⚫ 通过零件柔性、自动控制系统、接头摩擦和滑动、液压和气动执行器以及参数化设计关系对模型进行优化
⚫ 复杂大运动设计的综合线性和非线性结果
⚫ 全面且易于使用的接触功能支持模态柔性体和刚体几何体之间的任何组合的二维和三维接触
2.易于使用。
与过去十年相比，使用MBS程序的复杂性降低了。随着MBS的发展，它现在不再是为仿真专家或动态分析专家设计的，而是为普通设计工程师设计的。
在MATLAB®Simscape多体程序中，复杂的多体系统可以由表示实体、关节、约束、力元素和传感器的块构建。它为整个机械系统建立并求解运动方程，自动生成的三维动画可用于可视化系统动力学。
图三 在Simscape Multibody中，前悬架由块建模
Simscape Multibody包含一个模块库、模拟和控制接口，用于将Simscape计划与Simulink环境互连，还可以使用Simscape系列产品中的组件将液压、电气、气动和其他物理系统集成到模型中。RecurDyn有一个功能强大、设计直观的GUI。它包含一个用于模型开发、模拟和结果分析的完全集成的环境。模型创建和参数定义的预处理以及分析结果的后处理直接集成到GUI中。GUI中还存在大量定制选项，通过自动化常见任务来提高生产率。
3.更准确，MBDS软件可以模拟“真实世界的物理”。
为了模拟多刚体的动力学行为，需要求解描述系统运动的一系列运动方程。这些方程称为微分代数方程（DAE），是描述运动的微分方程和封装关节约束的代数方程的组合。在线性动力学仿真中，由于多核处理器的存在，求解器具有较高的效率和精度。
利用多体动力学解决方案技术，如ADAMS等MBDS在FEA解决方案所需时间的一小部分内运行非线性动力学。通过模拟计算的载荷和力可以更好地评估它们在整个运动范围和操作环境中的变化，从而提高有限元分析的准确性。
4.可重复性，在现实生活中，使用MBDS软件进行故障测试需要花费大量时间和金钱，因此可以在故障条件下重复模拟和验证。我们有一些好处：
创造稳健的设计。指定部件的故障标准，包括基于时间、负载或温度的条件。对退化的部件行为进行建模，例如齿轮齿磨损或轴承摩擦增加。自动配置模型，以便在故障条件下有效验证设计。
图四 当力超过接头的上限时，两个零件之间的连接断裂
执行预测性维护。生成数据以培训预测性维护算法。在常见和罕见场景下使用虚拟测试验证算法。通过确保以正确的时间间隔进行维护，减少停机时间和设备成本。
尽量减少损失。计算机械部件消耗的功率。验证部件是否在其安全操作区域内运行。模拟特定事件和测试场景集，然后在MATLAB中对结果进行后期处理。
多体动力学仿真软件使设计阶段的更改比物理原型测试所需的速度更快，成本更低。提供更安全的环境，无需担心因仪器故障而丢失数据。在没有物理测试的情况下，可以在所有情况下进行模拟或分析，而不会产生危险。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e69f1e830762bb8424b15a2359ac25a/" rel="bookmark">
			Hive增加文件映射到表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1，打开hadoop的文件系统
2，使用IntelliJ通过JDBC链接到hive，也可以用其它工具
3，创建数据库，创建表，选择拆分规则
create database hivedemo; use hivedemo; drop table users; create table users( id int comment 'ID', name string comment '姓名' ) comment '用户表' row format delimited fields terminated by ','; 4，查看新建表目录
5，上传文件到服务器，通过hadoop 命令推送到新建表的目录下
文件内容如下：
hadoop fs -put file2.txt /user/hive/warehouse/hivedemo.db/users 6，查询hive自动映射的表内容
select * from users; 结果：
更多信息请查看 博客 或者关注公众号：Z技术
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ee6ad93cfc74da8f36247b90912ec09/" rel="bookmark">
			.Net6中使用Nacos做服务和配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、添加api项目并注册到服务中心
nacos服务端需要自己下载安装，请参照官方文档
地址：什么是 Nacos
下载完成后，按照文档提示启动Nacos，在浏览器查看控制台:Nacos本地链接
1.1、根据需要安装nuget
dotnet add package nacos-sdk-csharp dotnet add package nacos-sdk-csharp.AspNetCore dotnet add package nacos-sdk-csharp.Extensions.Configuration dotnet add package nacos-sdk-csharp.YamlParser dotnet add package nacos-sdk-csharp.IniParser 1.2、在program.cs中添加服务
//builder using Nacos.AspNetCore.V2; var builder = WebApplication.CreateBuilder(args); { // Add services to the container. // Learn more about configuring Swagger/OpenAPI at https://aka.ms/aspnetcore/swashbuckle builder.Services.AddEndpointsApiExplorer(); builder.Services.AddSwaggerGen(); builder.Services.AddMvc(option =&gt; { option.EnableEndpointRouting = false; }); // nacos server v1.x or v2.x builder.Services.AddNacosAspNet(builder.Configuration); } //app var app = builder.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0ee6ad93cfc74da8f36247b90912ec09/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b333bd4c5c64cad983114889f9685f72/" rel="bookmark">
			使用IDEA操作git，推送，拉取，创建分支，切换分支，合并分支，处理版本冲突，回滚代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 使用IDEA操作git，推送，拉取，创建分支，合并分支，处理冲突 创建Maven项目 创建码云远程仓库并复制路径 IDEA创建本地仓库 推送 1. 添加暂存区（注意文件的颜色会由红色变成绿色） 2.提交代码到本地仓库 3.提交代码到远程仓库 4.确定后点push 5.刷新码云 拉取代码 1.进入App.java点击编辑，添加代码后保存 2.IDEA拉取代码 IDEA创建分支 1.创建test分支，创建成功后默认是该分支 1.添加代码 2.提交到本地仓库 3.将分支提交到远程仓库 4.查看远程仓库分支，切换分支，查看代码差异 切换分支 1.现在在test分支，点击Checkout切换分支 合并分支，将test分支合并到master分支 1.切换两个分支，代码一致，然后将本地master仓库，推送到远程仓库 处理版本冲突 描述：当你的同事修改了代码提交到了远程仓库，此时你也修改了代码提交到远程仓库（他先提交，你后提交），此时远程仓库的代码与你的代码不一致，就会造成版本冲突 1.修改远程仓库代码和本地代码 2.推送本地代码到远程仓库，会提示版本冲突 3.点击Merge合并代码 1.版本冲突原因：本地和远程版本不一致 方法一：强制合并（不推荐，会把之前提交人的代码删除，强制更新成你的代码） 方法二：将修改的代码先存起来，然后拉取远程仓库代码，最后合并代码提交到远程仓库 1.远程仓库代码 2.将远程仓库拉取到本地 3.点击cunchu是我前面保存的Stach，点击View，双击App 4.将自己写的代码复制到左侧 5.提交到本地仓库 6.更新远程仓库 回滚代码 有时候我们将不需要推送的代码或者错误代码推送到了远程仓库 1.添加测试代码，先保存到本地仓库，然后推送到远程仓库 2.本地先回滚代码 3.观察是否是需要回滚的代码 4.如果是，右击回滚，此时会自动回滚到之前的版本 5.重新保存到本地仓库，然后推送到远程仓库 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b6bdf811b6598ae84ddcff367f615e2/" rel="bookmark">
			C语言详解系列——循环语句详解（3）do while语句的语法结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 do while语句do while语句中的break和continuebreakcontinue do while语句与while语句的不同点简单练习 do while语句 之前的学习中我们已经了解到了while 语句和if语句两种循环语句，今天要向大家介绍的是do while 语句，我们聊一聊他们之间的区别。首先我们先看看do while 语句的语法结构：
do
{
循环语句;
} while(表达式);
还是像之前一样，让我们用do while 语句输出1-10，以下就是do while的基本语法结构和使用方法。
#include&lt;stdio.h&gt; int main() { int i = 0; do { printf("%d ", i); i++; } while (i &lt;= 10); return 0; } do while语句中的break和continue break 在for语句和while语句中我们已经知道了break的作用，在循环语句中遇到break就会永久的跳出循环，那么在do while语句中是否break的作用与前者相同呢？让我们在代码中找寻答案。
#include&lt;stdio.h&gt; int main() { int i = 1; do { if (i == 5) { break; } printf("%d ", i); i++; } while (i &lt;= 10); return 0; } 我们可以看到上面代码的输出结果为1 2 3 4，所以在do while语句中break的作用也是永久跳出循环。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7b6bdf811b6598ae84ddcff367f615e2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1297ed04631c9281041c21da690a2305/" rel="bookmark">
			0716 process finished with exit code 0 解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写完代码之后想要debug 看看是否可以运行成功过程中，出现了Process finished with exit code 0
意思是程序运行成功并且退出
exit code 0 表示程序执行成功，正常退出。exit code 1 表示程序执行过程中遇到了某些问题或者错误，非正常退出 但是在run 代码的时候依旧出现Process finished with exit code 0
没有返回值，查询到的解决方法有以下几个：
1、检查代码输入格式是否正确：
（1）检查代码缩进格式：全部重新缩进一遍
（2）检查代码是否少输入：if --name-- == ''--main--'': (少输入-- -- 也会导致出现Process finished with exit code 0）
2、修改configuration：
run-configuration-script_path :修改为当前代码文件的路径，修改之后再次进行运行
还有别的方法，后期遇到继续补充！！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e798a70349225405353d8066a01fc99/" rel="bookmark">
			Java基础 : CompletableFuture① 基础使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、前言二、介绍三、方法介绍1. 任务创建2. 函数回调3. 函数聚合3.1 AND3.2 OR 4. 结果处理5. 结果获取 一、前言 本文内容参考：CompletableFuture基本使用，建议阅读原文。
本文在个人理解基础上有部分删改，仅用于个人学习记录，限于个人能力本文可能出现错漏，因此再次建议阅读原文 CompletableFuture基本使用。
CompletableFuture 是在阅读 Dubbo 异步调用时接触到的内容，当时一直对 CompletableFuture 进行了简单的学习，碍于时间原因一直没有记录，趁现在有时间对 CompletableFuture 进行更深入的学习并记录。
二、介绍 借 CompletableFuture基本使用 文章中对 CompletableFuture 的介绍 ：
CompletableFuture是什么
CompletableFuture是Java8中提供的Future的扩展功能，简化异步编程的复杂性;引入函数式编程，通过回调的方式处理计算结果，也提供了转换和组合的方法;它实现了Future和CompletionStage接口;借助CompletionStage的方法可以实现链式调用;一个CompletetableFuture就代表了一个任务，可以用then，when等操作来防止阻塞和轮询isDone的现象出现;它可能代表一个明确完成的Future，也有可能代表一个完成阶段（ CompletionStage ），它支持在计算完成以后触发一些函数或执行某些动作; CompletableFuture 结构如下：
CompletableFuture 实现了 Future 和 CompletionStage 两个接口。其中 CompletionStage 是Java8新增得一个接口，代表异步计算过程中的某一个阶段，一个阶段完成以后可能会触发另外一个阶段。目前只有CompletableFuture以及其内部类进行了实现 ：
一个阶段的计算执行可以是一个Function，Consumer或者Runnable。比如：stage.thenApply(x -&gt; square(x)).thenAccept(x -&gt; System.out.print(x)).thenRun(() -&gt; System.out.println())
一个阶段的执行可能是被单个阶段的完成触发，也可能是由多个阶段一起触发
三、方法介绍 下面我们来看 CompletableFuture 提供的方法，图源 ： CompletableFuture基本使用
1. 任务创建 CompletableFuture#supplyAsync ： 创建一个带有返回值的异步任务
// 使用默认的线程池 public static &lt;U&gt; CompletableFuture&lt;U&gt; supplyAsync(Supplier&lt;U&gt; supplier) { return asyncSupplyStage(asyncPool, supplier); } // 使用自定义的线程池 public static &lt;U&gt; CompletableFuture&lt;U&gt; supplyAsync(Supplier&lt;U&gt; supplier, Executor executor) { return asyncSupplyStage(screenExecutor(executor), supplier); } CompletableFuture#runAsync ：创建一个没有返回值的异步任务
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2e798a70349225405353d8066a01fc99/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3dedeed91a61e4d42817a4818520584e/" rel="bookmark">
			Java基础 : CompletableFuture② 代码浅析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、前言1. 基础介绍1.1 基础属性1.2 CAS 操作1.3 Completion 二、代码分析1. CompletableFuture#supplyAsync1.1 CompletableFuture.AsyncSupply1.2 CompletableFuture#postComplete1.2.1 代码分析1.2.2 举例说明1.2.3 总结 2. CompletableFuture#thenApply2.1 CompletableFuture#uniApply2.2 CompletableFuture#push2.3 CompletableFuture.UniApply#tryFire2.3.1 CompletableFuture#postFire 3. CompletableFuture#join3.1 CompletableFuture#waitingGet3.1.1 CompletableFuture.Signaller 的作用 一、前言 在Java基础：CompletableFuture① 基础使用中我们介绍了CompletableFuture 的基础使用，本文来对其代码进行分析，由于个人能力所限并且文章编写时间太长（写了三四个月总被各种事情打断 ），文中所述可能存在理解不到位或者理解错误的情况，如有感谢指正。
1. 基础介绍 CompletableFuture 代表一个执行阶段，一个阶段的执行可能是被单个阶段的完成触发，也可能是由多个阶段一起触发。
以下面的代码为例（为例方便讲解，这里把代码写的比较复杂）
public static void main(String[] args) { final Supplier&lt;String&gt; startSupplier = () -&gt; "start"; final Function&lt;String, String&gt; thenApplyFunction = s -&gt; s + " -&gt; thenApply"; final CompletableFuture&lt;String&gt; supplyAsync = CompletableFuture.supplyAsync(startSupplier); final CompletableFuture&lt;String&gt; thenApply = supplyAsync.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3dedeed91a61e4d42817a4818520584e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93987a0ec7992f723a1c4d1ab6b3dc00/" rel="bookmark">
			JAVA编译出现 错误: 非法字符: ‘\uff1b‘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		出现这种情况，大概率使用了中文字符
解决方案：根据行数提示查看结尾封号「；」 中文字符高亮，英文字符黯淡
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88313ee365970f02fe00f2dfe21efd24/" rel="bookmark">
			在centos系统上离线安装python3
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一般系统都自带python2，但是目前多数新工具都需要python3，但是公司生产环境连不到外网，内部yum源里面也没有自己期望的python3版本，此时，就需要自己徒手安装python3了，本文以3.8.3为例说明。话不多说，步骤来袭：
步骤一、 下载python
在官网上下载tar.xz结尾的对应版本的python源码。
Python Release Python 3.8.3 | Python.org
进入网站拉到最下面，选择XZ compressed source tarball 下载。
步骤二、
在centos上安装gcc编译工具。
yum -y install gcc
将下载的python 源码压缩包放到centos上。
步骤三、复制粘贴就行。
tar -xvJf Python-3.8.3.tar.xz
cd Python-3.8.3
./configure --prefix=/usr/local/python3
make &amp;&amp; make install
ll /usr/local/python3/bin | grep python
ll /bin/ | grep python
cd /bin
ln -s /usr/local/python3/bin/python3.8 /bin/python3
rm -rf /bin/python
ln -s /bin/python3 /bin/python
完结撒花。此时敲 python --version ,就是python3.8.3 版本了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c59e1be135b7941954f6c6b15396892/" rel="bookmark">
			SpringBoot Mongdb 两种时间格式按时间聚合的操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、版本二、CODE1.长整型时间戳2.日期格式 前言 最近在工作中遇到了大量数据的查询，需要按时间进行查询，学习了几种Mongdb 按时间聚合的操作，做总结如下。
一、版本 MongoDB shell version v5.0.2	springboot 2.5.5 maven 依赖
&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-mongodb&lt;/artifactId&gt; &lt;/dependency&gt; 二、CODE 注意：
不同的mongo gui 对命令的识别是有区别 尤其是 单、双引号mongodb 存储的日期类型是0时区长整型需要用 NumberLong() 做包装本文中的数据都是模拟数据 并不完整或合理，也没有进行排序，显示结构仅供参考 1.长整型时间戳 按5分钟聚合数据，mongo 语法实现
db.getCollection("energy-iot-history").aggregate([ {"$match": {"ts" : { "$gte" : 1638198000000}}}, {"$group" : { "_id" : {"$subtract" : ["$ts",{ "$mod" : ["$ts", 5 * 60 * 1000]}]}, "fisrtTime" : {"$first" : "$ts"}, "lastTime" : {"$last" : "$ts"} }} ]); spring boot mongoTemplate 实现，（未调试）基本格式没问题，请自行调试
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5c59e1be135b7941954f6c6b15396892/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/557ccb8f5d0940eca8d473bd9e7bee44/" rel="bookmark">
			Typora Beta版过期解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天打开Typora，提示过期，直接不能用了，卸载重装，还是不行。
The beta version of typora is expired, please download and install a newer version 2022-07-15更新
很遗憾，今天发现方法二不行了，方法一可以，但比较麻烦，就算写批处理文件自动执行但也是不够完美。直接看方法三吧。
解决方法一 修改操作系统时间，往前改几个月，就可以打开Typora了，打开后再把时间改回去。这个方法太麻烦，每次都要修改，虽然网上有人写批处理命令自动修改时间，然后再自动打开Typora，但依然不推荐。
解决方法二 打开目录C:\Users\你的用户名\AppData\Roaming\Typora，删除两个文件profile.data typora.log即可。
也有人写批处理命令并设置开机启动，自动删除这两个文件，但很没必要，不推荐，只需要把自动更新关了就可以了。
如果你看不到AppData这个目录，需要设置把隐藏的文件显示出来。
解决方法三 按Windows+R打开运行窗口，输入regedit，点确定，打开注册表，依次展开计算机\HKEY_CURRENT_USER\Software\Typora，然后在Typora上右键，点权限，选中Administrtors，把权限全部设置为拒绝。
最后，不管是哪个方法，都建议在Typora偏好设置里把自动更新关掉！
最后一个Beta版下载 官方还是很良心的，即便是开始收费了，也依然给出了旧的Beta版下载地址，但如果你是第一次安装，则默认安装到C盘，没有选择安装目录的入口，我这样的强迫症忍不了，这里再给一个最新且可以选择安装目录的Beta版本（0.11.18）下载地址。当然，有需要的，还是建议支持一下最新付费版本。
下载地址：
链接：https://pan.baidu.com/s/1bDRvsMeGjyes_LFX8uw17Q
提取码：5pmh
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f84dee40db60fb6e03fc79fd4d430fe4/" rel="bookmark">
			C# List集合中根据某个字段去重
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对List集合数据去重的方法有很多，在这里对其中一种用到的简便的方法进行记录一下。可以使用List自带的GroupBy方法进行分组，然后使用Select和First方法选取分组数据后的第一个元素，最后将结果ToList()即可。示例代码如下：
using Newtonsoft.Json; using System; using System.Collections.Generic; using System.Linq; using System.Text; namespace ConsoleAppDemo { class Program { private class Product { public int Id { get; set; } public string Name { get; set; } } static void Main(string[] args) { TestDistinct(); Console.ReadLine(); } private static void TestDistinct() { List&lt;Product&gt; productList = new List&lt;Product&gt;(); productList.Add(new Product() { Id = 100, Name = "香蕉" }); productList.Add(new Product() { Id = 101, Name = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f84dee40db60fb6e03fc79fd4d430fe4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/509c6b66d9e62e9f761bcb190d851422/" rel="bookmark">
			SpringMVC快速入门详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SpringMVC快速入门详解 简介快速入门1. 快速实现1.1 导入SpringMVC坐标与Servlet坐标1.2 创建SpringMVC控制器类（等同于Servlet功能）1.3 初始化SpringMVC环境（同Spring环境），设定SpringMVC加载对应的bean1.4 初始化SpringMVC容器，加载SpringMVC环境，并设置SpringMVC技术处理的请求 2. 注解分析2.1 @Controller2.2 @RequestMapping2.3 @ResponseBody 3. 1+N 特点3.1 一次性工作3.2 多次工作 4. Servlet容器启动的配置类解析4.1 createServletApplicationContext()方法4.2 getServletMappings()方法4.3 createRootApplicationContext()方法 5. 工作流程分析5.1 启动服务器初始化过程5.2 单次请求过程 6. Spring和SpringMVC相关bean加载控制7. Servlet容器启动的配置类简化 总结 简介 SpringMVC是一种基于Java实现MVC模型的轻量级Web框架。
具有如下优点：
使用简单，开发便捷（相比于Servlet）。灵活性强。 SpringMVC是一种标签层框架技术。
SpringMVC是用于进行表现层功能开发。
快速入门 1. 快速实现 1.1 导入SpringMVC坐标与Servlet坐标 &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;4.0.1&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.2.20.RELEASE&lt;/version&gt; &lt;/dependency&gt; 需要注意的是spring-webmvc版本5.2.20.RELEASE对应的jdk不能太高，1.8版本的jdk即可，我试了16是不匹配的，会出问题。
1.2 创建SpringMVC控制器类（等同于Servlet功能） @Controller public class UserController { @RequestMapping("/save") @ResponseBody public String save() { System.out.println("springmvc save ..."); return "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/509c6b66d9e62e9f761bcb190d851422/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/afbb8e954713234688bbe59cc63522dd/" rel="bookmark">
			达梦数据库定时备份
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		定时备份前请先配置本地归档和开启 dmap 服务
1.图形化
在管理工具中 右键【代理】-【作业】-【新建作业】
在作业名称和作业描述中填写备份名称和描述
全量备份
选择具体的备份方式
选择备份的时间策略
增量备份
选择具体的备份方式
选择备份的时间策略
删除历史备份
选择具体的备份方式
选择备份的时间策略
日志查看
右击管理工具，选择【代理】-【作业】-【job 名称】，点击【查看历史作业信息】
2.非图形化
创建作业环境
SP_INIT_JOB_SYS(1);
每周六晚上 23：30 定时全库备份
call SP_CREATE_JOB('back_full',1,0,'',0,0,'',0,'back_full'); call SP_JOB_CONFIG_START('back_full'); call SP_ADD_JOB_STEP('back_full', 'back_full', 6, '01000000/opt/dmdbms/data/BAK', 1, 2, 0, 0, NULL, 0); call SP_ADD_JOB_SCHEDULE('back_full', 'back_full', 1, 2, 1, 64, 0, '23:30:00', NULL, '2020-03-27 16:35:56', NULL, ''); call SP_JOB_CONFIG_COMMIT('back_full'); 每周一、周二、周三、周四、周五、周日晚上 23：30 定时增量备份
call SP_CREATE_JOB('backup_inc',1,0,'',0,0,'',0,'backup_inc'); call SP_JOB_CONFIG_START('backup_inc'); call SP_ADD_JOB_STEP('backup_inc', 'backup_inc', 6, '11000000/opt/dmdbms/data/BAK|/opt/dmdbms/data/BAK', 1, 2, 0, 0, NULL, 0); --call SP_ADD_JOB_STEP('backup_inc', 'backup_inc', 6, '11000000/opt/dmdbms/data/BAK|/opt/dmdbms/data/BAK', 1, 2, 0, 0, NULL, 0); call SP_ADD_JOB_SCHEDULE('backup_inc', 'backup_inc', 1, 2, 1, 63, 0, '23:33:00', NULL, '2020-03-27 22:03:58', NULL, ''); call SP_JOB_CONFIG_COMMIT('backup_inc'); 每天 00：00 删除 15 天以前的数据。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/afbb8e954713234688bbe59cc63522dd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6fb27c34dbcc367c095ac7a8fb0be2b5/" rel="bookmark">
			CTF比赛PWN题sgtlibc通用快速解题框架
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CTF比赛PWN题sgtlibc通用快速解题框架 安装 开源地址：https://github.com/serfend/sgtlibc
使用 pip install sgtlibc -U 安装pwn解题框架
示例demo 目前收集了一些栈溢出上的通用解题框架，基本上对于简单题可以做到稍加修改配置即可解题，以实现1分钟得到flag效果。
libc泄露模板 说明 模板可以在github-pwn下载原始文件通常对于栈溢出的题，找到溢出点以后双击其buffer得到栈结构。观察得到r(return address)之前的长度。 将该长度填写到模板中相应位置，通常是 exp()中的b’a’ * [这里写长度]即可。 注意有的题main函数没有符号，导致无法通过 elf.symbols[‘main’]获取的，可以是在ida中找到入口函数地址，复制其值 将 main_addr = elf.symbols['main']改为 main_addr = 0x这里写地址 即可 在libc2.27版本以后，栈溢出需要检查栈是否平衡，可以是在返回地址前面加上一个 payload += [elf.rop['ret']]以解决。有时候题目会有一些输出，需要使用sla(sendlineafter)或ru(receive until)等方式将这些值过滤掉，以得到需要的数据。 模板 以下是一些可以修改一些参数即可立马运行的模板，业内称之为板子，1分钟交flag不是梦。
shellcode_binbash_x86 例题：buuctf start
import sgtlibc import sgtlibc.utils import sgtlibc.utils.shell from sgtlibc.gamebox import * set_config(GameBoxConfig( is_local=True, file='./start', remote='192.168.2.0:8888', auto_load=True, auto_show_rop=True, auto_show_summary=True, auto_start_game=True, auto_load_shell_str=True, auto_show_symbols=True )) s = sgtlibc.Searcher() elf = client.elf pause() read_addr = 0x08048087 # 再次读入 padding = 0x48 - 0x34 # 判断返回地址到输入值的偏移 sa(b':', [b'a' * padding, read_addr]) stack_addr = u00(rc(4)) print(f'stack_addr:{hex(stack_addr)}') shellcode = sgtlibc.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6fb27c34dbcc367c095ac7a8fb0be2b5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1bbdb2e79449160ab776fd53061369d8/" rel="bookmark">
			git报错 error: remote origin already exists.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原因：之前连接过自己（或者别人的）远程仓库 解决办法就是直接把这个链接删了
#1 第一个搜索出来的解决办法 但没解决我的问题
1、先删除远程 Git 仓库
$ git remote rm origin
2、再添加远程 Git 仓库
git remote add origin （这儿跟原来链接的仓库）
#2 第二种解决办法 （也是解决了我的问题的办法）
$ git remote rm origin //删除链接的远程仓库
$ git remote add origin （跟上需要链接的仓库） //重新绑定链接仓库 解决。 参考：
git error: remote origin already exists._努力会有回报呀的博客-CSDN博客
Git 提示fatal: remote origin already exists 错误解决办法_Ricky_Fung的博客-CSDN博客
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c3505db7bb77b10977ea54c5ab2b843/" rel="bookmark">
			总结：gitlab ci
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、介绍 GitLab CI 是 GitLab 为了提升其在软件开发工程中作用，完善 DevOPS 理念所加入的 CI/CD 基础功能。可以便捷的融入软件开发环节中。通过 GitLab CI 可以定义完善的 CI/CD Pipeline。
现在很多公司用gitlab来作为代码仓库、版本控制软件，在加上gitlab的自动化持续集成部署工具ci/cd，它可以在代码提交的同时完成镜像构建、自动化测试、自动化部署等连续的工作，非常方便。
官方文档：`.gitlab-ci.yml` keyword reference | GitLab
二、官方实例代码 gitlab-ci.yml 内容：
stages: - build - test build-code-job: stage: build script: - echo "Check the ruby version, then build some Ruby project files:" - ruby -v - rake test-code-job1: stage: test script: - echo "If the files are built successfully, test some files with one command:" - rake test1 test-code-job2: stage: test script: - echo "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7c3505db7bb77b10977ea54c5ab2b843/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4bdee0099a3d5be439e0719b04392663/" rel="bookmark">
			a-select 获取选中的那个选项
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 a-select 获取选中的那个选项 话不多说，我们直接上代码
html部分 &lt;a-select :options="projectOptions" @change="projectSelect" v-decorator="['projectName']" placeholder="请选择项目名称" /&gt; javascript部分 我的下拉选项是这样的结构 projectOptions: [ value: "", title: "" ] projectSelect(value, option) { let selOption = option.data.props } value： 就是我们每一个option里面的value option.data.props： 就是我们选择的这一个选项的内容 今天的ant design vue 下拉选择组件的小分享就到这啦，我们下次再见~ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f907d2b1de0095b0b55179d8162c80d7/" rel="bookmark">
			欢迎使用淘宝API接口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		欢迎使用淘宝API接口 测试地址
之前做项目的时候用到了淘宝API就上网去查了一些，总结了一些，现在分享给大家，希望对大家有帮助，先对淘宝API做个简介吧：
淘宝OpenAPI（Open application programming interface）是一套REST方式的开放应用程序编程接口。淘宝网根据自己提供的电子商务基础服务，抽象并做成一系列的API接口。通过这些接口，可以让外部用户能够通过程序的方式访问淘宝网的数据和平台。淘宝OpenAPI是淘宝开放平台的重要组成部分，是淘宝开放平台三大方向之一——开放业务的主要形式。淘宝OpenAPI又叫TOP（taobao open platform）（下面简称top）
开发基于openAPI的程序，就是利用淘宝提供的API函数来构造一个URL，通过这个URL去访问淘宝的数据平台，然后服务器会根据你的API返回相应的数据，程序接收到这些数据后再解析并显示出来
item_get - 获得淘宝商品详情 获取Key和secret
什么是 Appkey 和 AppSecret： 首先，大家要到官方主页去申请一个appkey，这个是做什么用的呢？App Key是应用的唯一标识，TOP通过App Key来鉴别应用的身份。AppSecret是TOP给应用分配的密钥，开发者需要妥善保存这个密钥，这个密钥用来保证应用来源的的可靠性，防止被伪造。就是说嘛，想要进门可要先有钥匙啊，所以，appkey就是我们进入openAPI大门的钥匙。
请求参数：num_iid=520813250866&amp;is_promotion=1
参数说明：num_iid:淘宝商品ID
is_promotion:是否获取取促销价
响应示例
{ "item": { "num_iid": "520813250866", "title": "三刃木折叠刀过安检创意迷你钥匙扣钥匙刀军刀随身多功能小刀包邮", "desc_short": "", "price": 25.8, "total_price": 0, "suggestive_price": 0, "orginal_price": "25.80", "nick": "欢乐购客栈", "num": "832", "min_num": 0, "detail_url": "http://item.taobao.com/item.htm?id=520813250866", "pic_url": "//img.alicdn.com/imgextra/i4/2596264565/TB2p30elFXXXXXQXpXXXXXXXXXX_!!2596264565.jpg", "brand": "三刃木", "brandId": "4036703", "rootCatId": "50013886", "cid": "50014822", "favcount": "4824", "fanscount": "1469", "crumbs": [], "created_time": "", "modified_time": "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f907d2b1de0095b0b55179d8162c80d7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6099f3ded054c534db0c8cd052375d31/" rel="bookmark">
			DUBBO 动态发布服务 mock rpc接口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、背景：基于测试需求 测试项目时对于第三方rpc接口需要动态上下线和mock报文
2、方法:
1. 在消费者方使用SPI拓展,自定义一个拓展Cluster实现拦截rpc请求做到mock
2. 消费者无代码入侵，全在提供方实现mock
方法1:
参考地址:GitHub - dsc-cmt/dubbo-easy-mock: 针对Dubbo接口的Mock解决方案
方法2:
如果要实现动态上线一个rpc接口就要使用ServiceConfig类的export 方法
// 服务实现 HellowService hellowService = new HellowServiceImpl(); // 应用配置 ApplicationConfig applicationConfig = new ApplicationConfig(); applicationConfig.setName("test"); // 连接注册中心配置 RegistryConfig registry = new RegistryConfig(); registry.setAddress("zookeeper://192.168.41.77:2181"); // 服务提供者协议配置 ProtocolConfig protocol = new ProtocolConfig(); protocol.setName("dubbo"); protocol.setPort(12345); protocol.setThreads(200); // 服务提供者暴露服务配置 ServiceConfig&lt;HellowService&gt; service = new ServiceConfig&lt;HellowService&gt;(); // 此实例很重，封装了与注册中心的连接，请自行缓存，否则可能造成内存和连接泄漏 service.setApplication(applicationConfig); service.setRegistry(registry); // 多个注册中心可以用setRegistries() service.setProtocol(protocol); // 多个协议可以用setProtocols() service.setInterface(HellowService.class); service.setRef(hellowService); service.setVersion("1.0.0"); // 暴露及注册服务 service.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6099f3ded054c534db0c8cd052375d31/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5785df0743d1ff44deb0e578a12ceaa0/" rel="bookmark">
			通讯软件正常访问网络，但浏览器访问网络不成功，“远程计算机或设备将接受链接”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述 如标题，WX等通信软件可以正常收发信息，已经 通过黑窗口的ping www.baidu.com都正常返回报文，但浏览器却是无法访问网络。
此时点击故障诊断显示远程计算机或设备将接受链接
解决方式 1、使用快捷键win + R或者win调出运行或者搜索，输入inetcpl.cpl
OR
2、再打开的Internet属性中进行配置
i.点击链接，进入链接选项卡
ii.点击局域网设置，进入局域网（LAN）设置
i.将页面中的三个对勾全部取消，然后点击确定
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4abe744cfdac68dd53ebf1266748b4a/" rel="bookmark">
			【尚硅谷Java版】Flink中DataStream API篇之创建执行环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【尚硅谷Java版】Flink中DataStream API篇之创建执行环境 一、基础知识二、创建执行环境 一、基础知识 Flink有非常灵活的分层API设计，核心层就是DataStream/DataSet API。新版已经实现流批一体，DataSet API被弃用，统一使用DataStream API处理流数据和批数据。
DataStream本身是Flink中一个用来表示数据集合的类，Flink代码其实就是基于这种数据类型的处理。一个Flink程序，其实就是对DataStream的各种转换，具体来说，代码基本上都由以下几个部分组成：(1)获取执行环境 execution enviroment (2)读取数据源 source (3)定义基于数据的转换操作 transformations (4)定义计算结果的输出位置 sink (5)触发程序执行 execute。
其中第一部分的获取执行环境和第五部分的触发程序执行，都可以认为是对执行环境的操作，所以我们可以将其精简为下面四个部分：
执行环境 enrironment数据源 source转换操作 transformation输出 sink
二、创建执行环境 flink程序的第一步就是创建执行环境，这是flink程序的基础。
在代码中创建执行环境，就是调用这个类的静态方法，具体有以下三种形式：
getExecutionEnvironment()，会根据当前运行的方式，自行决定该返回什么样的运行环境，不需要做格外的判断，简单高效 StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment(); createLocalEnvironment()，返回一个本地执行环境，可以在调用时传入一个参数，指定默认的并行度，如果不传入就默认并行度就是本地的CPU核心数 StreamExecutionEnvironment localEnv = StreamExecutionEnvironment.createLocalEnvironment (); createRemoteEnvironment()，这个方法返回集群执行环境，需要在调用的时候指定JobManager的主机名和端口号，并指定在集群中运行的jar包 StreamExecutionEnvironment remoteEnv = StreamExecutionEnvironment.createRemoteEnvironment( "host", JobManager主机名 1234, JobManager进程端口号 "path/to/jarFile.jar" 提交到JobManager的Jar包 ); 通过以上三种方式获取到程序执行环境后，我们可以对执行环境进行灵活的设置，比如全局设置的并行度、禁用算子链等。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ddcf74172e3a8a4a79ad069adca44339/" rel="bookmark">
			elementUI给指定日期添加样式，elementUI的cellClassName参数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通过cellClassName参数给指定日期添加样式 cellClassName属性简介cellClassName属性函数返回值日期格式转换1.通过moment转换2.自定义一个方法转换 日期匹配添加指定样式完整代码（moment方式转换日期格式） cellClassName属性简介 elementUI可以通过cellClassName属性达到给某些日期添加样式
属性可查阅文档：
在html中使用这个属性（先忽略其他属性）
&lt;el-date-picker :picker-options="pickerOptions" placeholder="选择日期"&gt; &lt;/el-date-picker&gt; cellClassName属性函数返回值 函数的返回值为当前页面显示的所有日期，每次返回的是单个日期，控制台打印出来time.getTime()得到的结果为：
日期格式转换 因为我需要的日期格式为yyyy-MM-dd，所以需要将日期格式转一下
1.通过moment转换 1.安装moment：
$ npm install moment --save 2.在main.js中全局引入（也可单独在使用的文件中引入，具体看需求）
import moment from "moment" Vue.prototype.$moment = moment; 3.使用
moment(time.getTime()).format('yyyy-MM-DD') 2.自定义一个方法转换 1.自定义方法
getLocalTimes(ns){ var date = new Date(ns); var year = date.getFullYear(); var month = date.getMonth() + 1; var day = date.getDate(); month = month &lt; 10 ? '0'+month : month ; day = day &lt; 10 ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ddcf74172e3a8a4a79ad069adca44339/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce21b5c388d603d6350d1b34dbc6ef57/" rel="bookmark">
			SpringBoot缓存管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、默认缓存管理 Spring框架支持透明地向应用程序添加缓存对缓存进行管理，其管理缓存的核心是将缓存应用于
操作数据的方法，从而减少操作数据的执行次数，同时不会对程序本身造成任何干扰。
Spring Boot继承了Spring框架的缓存管理功能，通过使用@EnableCaching注解开启基于注解的缓存支持，Spring Boot就可以启动缓存管理的自动化配置。
接下来针对Spring Boot支持的默认缓存管理进行讲解
2、基础环境搭建 2.1、准备数据 使用创建的springbootdata的数据库，该数据库有两个表t_article和t_comment
2.2、创建项目,功能编写 （1）在Dependencies依赖选择项中添加SQL模块中的JPA依赖、MySQL依赖和Web模块中的Web依赖
（2）编写数据库表对应的实体类，并使用JPA相关注解配置映射关系
package com.lagou.pojo; import javax.persistence.*; @Entity(name = "t_comment") // 使用这种方式，那么我么在编写原生sql语句的时候就不在需要添加，nativeQuery = true这个属性 /* @Entity @Table(name = "t_comment") 使用这种方式配置映射实体类，当我们编写原生sql语句进行查询时，我们就必须要加上nativeQuery = true这个属性，否则会报错 */ public class Comment { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Integer id; private String content; private String author; @Column(name = "a_id") private Integer aId; @Override public String toString() { return "Comment{" + "id=" + id + "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ce21b5c388d603d6350d1b34dbc6ef57/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be19494372074e2ed14817b716e56f00/" rel="bookmark">
			oracledb_exporter监控Oracle，一个入侵性极低的监控方案。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写在开篇 Oracle怎么做监控？用Zabbix？可以呀，但！本篇讲的内容是基于上次设计的Prometheus主备方案的基础上进行的， 上篇的文章是《重磅！DIY的Prometheus主备方案，全网唯一。生产未上，测试先行。》，顺便再附上该篇文章的链接：https://mp.weixin.qq.com/s?__biz=MzUzMTkyODc4NQ==&amp;mid=2247484954&amp;idx=1&amp;sn=a0aa43c5862d7dd96da64e84ead9adf7&amp;chksm=faba45a4cdcdccb2e0b53b13a24dc6eba1b082af2ae1aa16b592332d5d6b1963671ba381fd87&amp;token=99970325&amp;lang=zh_CN#rd
方案说明 本篇讲的是下图中的红色框部分
红色框部分，是oracledb_exporter的主备方案，结合上次的设计，这个图是完整的监控架构了。
oracledb_exporter的主备方案设计思路是跟Prometheus主备的设计思路大同小异的，架构不管如何设计，都是为了在生产环境上不要存在单点。
环境规划 用途主备角色物理IPVIP接管VIP地址oracledb_exporterMaster192.168.11.20接管192.168.11.200oracledb_exporterBackup192.168.11.21待接管192.168.11.200 安装keepalived 下载keepalived
wget https://www.keepalived.org/software/keepalived-2.2.7.tar.gz 编译和安装
mkdir -p /usr/local/keepalived tar -zxf keepalived-2.2.7.tar.gz cd keepalived-2.2.7 ./configure --prefix=/usr/local/keepalived/ &amp;&amp; make &amp;&amp; make install 配置master和backup的keepalived.conf
配置非抢占模式
master
global_defs { router_id lb01 } vrrp_instance VI_1 { state BACKUP interface ens32 virtual_router_id 80 priority 150 nopreempt advert_int 1 authentication { auth_type PASS auth_pass 1111 } virtual_ipaddress { 192.168.11.200/24 dev ens32 label ens32:1 } } backup
global_defs { router_id lb02 } vrrp_instance VI_1 { state BACKUP interface ens32 virtual_router_id 80 priority 100 nopreempt advert_int 1 authentication { auth_type PASS auth_pass 1111 } virtual_ipaddress { 192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/be19494372074e2ed14817b716e56f00/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/754b546fbf44fd2e400b4e6782caa921/" rel="bookmark">
			WebLogic反序列化之CVE-2015-4852、CVE-2016-0638、CVE-2016-3510
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		WebLogic反序列化之CVE-2015-4852、CVE-2016-0638、CVE-2016-3510 CVE-2015-4852、CVE-2016-0638、CVE-2016-3510这3个CVE常常被拿到一起来讲，因为后2个CVE都是以CVE-2015-4852利用链为基础建立的。
按照我对反序列化利用链的理解，包含2个部分：
承担恶意代码的荷载Class启动荷载Class的启动Class或者启动机制 CVE-2015-4852的荷载Class就是较为熟知的Apache CC利用链，关于CC利用链的分析文章很多，就不在这里写了。放一篇我关于CC1的文章ysoserial gadget Commons-Collections1保姆级分析，核心就是ChainedTransformer、ConstantTransformer、InvokerTransformer。
关于承担恶意代码的荷载Class就到此为止，而怎么启动荷载，就需要先了解WebLogic的T3协议。因为WebLogic通过读取数据包里T3协议格式的序列化数据然后将其反序列化得到Object。
T3协议是WebLogic RMI使用的协议，是JRMP的强化版。
T3协议 WebLogic RMI就是WebLogic对Java RMI的实现，在功能和实现方式上稍有不同。我们来细数一下WebLogic RMI和Java RMI的不同之处。
WebLogic RMI支持集群部署和负载均衡。 因为WebLogic本身就是为分布式系统设计的，因此WebLogic RMI支持集群部署和负载均衡也不难理解了。
WebLogic RMI的服务端会使用字节码生成(Hot Code Generation)功能生成代理对象。 WebLogic的字节码生成功能会自动生成服务端的字节码到内存。不再生成Skeleton骨架对象，也不需要使用UnicastRemoteObject对象。
WebLogic RMI客户端使用动态代理。 在WebLogic RMI客户端中，字节码生成功能会自动为客户端生成代理对象，因此Stub也不再需要。
WebLogic RMI主要使用T3协议（还有基于CORBA的IIOP协议）进行客户端到服务端的数据传输。 T3传输协议是WebLogic的自有协议，它有如下特点：
服务端可以持续追踪监控客户端是否存活（心跳机制），通常心跳的间隔为60秒，服务端在超过240秒未收到心跳即判定与客户端的连接丢失。通过建立一次连接可以将全部数据包传输完成，优化了数据包大小和网络消耗。 关于T3协议我本来想找一下有没有详细的定义，但是百度Google都没有找到，直到看到SeeBug里有篇文章说因为WebLogic闭源的原因就没有T3协议规则这方面的资料。不过网上对应Poc利用部分的T3协议分析倒是有。
具体分析参考漏洞原理和weblogic t3 协议利用与防御
发现每个数据包里不止包含一个序列化魔术头。(0xac 0xed 0x00 0x05)每个序列化数据包前面都有相同的二进制串。(0xfe 0x01 0x00 0x00)每个数据包上面都包含了一个T3协议头。仔细看协议头部分，发现数据包的前4个字节正好对应着数据包长度。以及我们也能发现包长度后面的01代表请求，02代表返回。 这些点说明了T3协议由协议头包裹，且数据包中包含多个序列化的对象。
现在知道了T3协议的格式，那么接下来有2种思路
替换数据包中多个序列化对象任意一个为恶意序列化数据。
weblogic发送的JAVA序列化数据的第一部分与恶意序列化数据进行拼接。
其实在我看来是一个意思，无非是选择替换第几个正常序列化部分。
网上的payload都是直接替换第1个序列化对象，我参考的Poc是这个Weblogic_direct_T3_Rces。
搞清楚怎么在T3协议数据流中加入恶意序列化数据后，接下来就可以说一说服务端是如何反序列化恶意数据并启动CC链。
从数据流到Object Weblogic通过7001端口，获取到流量中T3协议的java反序列化数据。
通过调用栈，可以发现Weblogic最后通过ObjectInputStream读入序列化数据，并在readClassDesc(boolean unshared)方法中拿到类描述符来确定字节流中传递数据的类型，并交给对应的方法进行处理。
//ObjectInputStream.java /** * Reads in and returns (possibly null) class descriptor. Sets passHandle * to class descriptor's assigned handle.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/754b546fbf44fd2e400b4e6782caa921/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/255c0e19a2237f4d681f468f60e7c179/" rel="bookmark">
			高并发内存池(学习tcmalloc)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
高并发内存池
一、项目介绍
二、项目涉及知识和项目环境
三、定长内存池
四、整体框架：
五、ConcurrentAlloc.h
六、ThreadCaChe
七、CentralCache:
八、PageCache:
九、测试以及性能分析：
十、优化方向和优化方法：
十一、结束语
高并发内存池 一、项目介绍 1、当前项目是实现一个高并发的内存池，原型是google的一个开源项目tcmalloc，tcmalloc全称
Thread-Caching Malloc，即线程缓存的malloc，实现了实现了高效的多线程内存管理，用于替代系统的内存分配相关的函数（malloc、free）。
2、tcmalloc的原型项目太大了，细节太多，当前项目的目的是把tcmalloc的框架抽取出来，简化细节实现一个高并发的内存池，并在多线程的情况下和malloc做对比，实现在多线程环境下，申请释放对象比malloc更加高效。
二、项目涉及知识和项目环境 1、知识：C/C++、数据结构（链表、哈希桶）、操作系统内存管理、单例模式、多线程、互斥锁
等等方面。
2、环境：VS2019。
三、定长内存池 1、池化技术：就是程序先向系统申请过量的资源，然后自己管理，以备不时之需。
2、那我们就可以为一个类型的对象创建一个内存池，自己管理，那这样就减少大量的向系统申请释放内存的消耗，从而提高效率。
3、设计思路：
(1)、一次性向内存申请一大块内存，当前项目是16页(一页8192字节)，然后用一个指针变量指向内存起始地址，是char*类型的_memory；还有实时记录剩余字节数：size_t类型的_remainBytes，接下来就是管理释放回来的小内存块，当前项目使用内存的前4/8(根据系统位数)个字节存储下一个小内存块的地址，所以当内存小于4/8字节时，也会分配出去4/8字节，这就是内碎片；然后用void*类型_freeList变量指向第一块内存小块，这样就能将所有的内存块链接起来，形成自由链表。自由链表下有空闲的内存块，优先使用。
(2)、当前项目是为了和malloc对比，那自然申请内存要脱离malloc(new底层也是封装了malloc)，所以当前项目实现windows环境下的系统调用接口：VirtualAlloc和VirtualFree。(Linux使用brk、sbrk以及mmap、ummap，铁子们可以自行查阅，感兴趣也可以搜tpmalloc)
VirtualAlloc和VirtualFree函数原型就不介绍了：直接上代码：
#ifdef _WIN32 #include &lt;windows.h&gt; #else // Linux // #include &lt;unistd.h&gt; --brk // #include &lt;sys/mman.h&gt; --mmap #endif // 规定一页为8K // 直接像系统申请内存，按页申请 inline static void* SystemAlloc(size_t kpage) { #ifdef _WIN32 // MEM_COMMIT | MEM_RESERVE 提交和保留 // PAGE_READWRITE：此区域读写 void* ptr = VirtualAlloc(nullptr, kpage &lt;&lt; PAGE_SHIFT, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE); // 注意：未使用MEM_RESET字段，此函数会默认初始化0 #else // brk // sbrk // mmap #endif if (ptr == nullptr) { // 失败抛异常 throw std::bad_alloc(); } return ptr; } inline static void SystemFree(void* ptr) { #ifdef _WIN32 // MEM_RELEASE 释放指定页,如果指定了这个类型,则dwSize应设置为0, 否则函数会调用失败 VirtualFree(ptr, 0, MEM_RELEASE); #else // brk // sbrk // unmmap #endif 定长对象池类：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/255c0e19a2237f4d681f468f60e7c179/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37b7ccc6b09cf2c54ca53cadf6d6f9e2/" rel="bookmark">
			ES6 —— 任务队列和事件循环
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		任务 在JavaScript中，所有任务可以分为两种，一种是同步任务，一种是异步任务。
同步任务：同步任务是在主线程(这个线程用来解释和执行 JavaScript 代码)上排队执行的任务。
异步任务：不进入主线程、而进入任务队列的任务。只有当主线程上的所有同步任务执行完毕之后，主线程才会读取任务队列，将任务放到执行栈，开始执行任务。（例如：ajax请求、setTimeout等事件调用的回调函数）
任务队列 当遇到计时器(setTimeout)、DOM事件监听或者是网络请求的任务时，JS引擎会将它们直接交给浏览器提供的相应线程去处理，而JS引擎线程继续后面的其他任务，这样便实现了 异步非阻塞。 当任务在相应的子线程上执行完成之后，再调回到主线程上，由JS引擎继续执行。
JavaScript中有两类任务（事件）队列：宏任务队列和微任务队列。 异步任务的队列优先级: 异步宏任务先执行 然后在执行异步微任务
事件循环 JS引擎在执行任务时，同步任务和异步任务是在不同的线程上执行的，同步任务在主线程上先执行，异步任务在子线程上执行，在子线程上执行完之后再调回主线程处理。
先执行第一轮的异步宏任务中的代码，先是同步任务执行，再是异步微任务执行，然后才是下一轮排队的宏任务；而下一轮排队的宏任务执行时，又是先同步任务再微任务，如果有宏任务再让其继续排队，最后再执行下一轮排队的宏任务......之后一直这样循环下去，直到所有任务执行完毕。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/957f14d8e8a5b515fe0d3191381da3f4/" rel="bookmark">
			word中间有条横线怎么删除， 快捷生成的横线如何删除
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何生成这种横线：（切记不要在正式文档尝试以下操作）
续输入3个以上的"-“，然后按一下回车键，就可以画出一条单直线的分隔线；
续输入3个以上的”=“，然后按一下回车键，就可以画出一条双直线的分隔线；连续输入3个以上的”*“，然后按一下回车键，就可以画出一条虚线形的分隔线；连续输入3个以上的”#"，然后按一下回车键，就可以画出一条三线形分隔线。
无法删除的原因分析：
原来，这根线是表格边框。虽然我们没有画边框，但是系统不这么认为，它以为你画了个表格。然后，就出现了我们以为是一条线，然后怎么删都删不了的问题。
如何删除： 解决方案一： 去除所有格式, 适用没有表格，不带任何格式的文件。
以word2019为例，ctrl+a全选，然后右键，选择样式。
在样式里面，选择“清除格式”。然后，这些线就全都没有了。
解决方案二： 找到最初产生这根线的那个回车，把它和附近的回国连同这根线一起删除掉。
注意，一定要是最初的那个。不过如果不是刚刚才产生的线，一般是找不到了
综上，解决方案为：
将横线上面的文字，每次选中一部分清除格式，直到横线消失，切记不可漏掉任何一个空格，空行。（测试成功）
另，若遇到清除的格式太过复杂，恢复困难，则可在清除此部分样式横线并未消失后（证明不是这一部分产生的横线），撤回，恢复该部分样式，继续向上进行该操作。（未测试）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92bc5dc4478459108913bdaacc7a5a90/" rel="bookmark">
			MySql 8 如何开启慢日志
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 查询慢日志是否开启 show VARIABLES like 'slow_query_log%' slow_query_log （ON-开启 OFF-关闭）
slow_query_log_file （慢日志存放地址）
2.开启慢日志 set global slow_query_log='ON' 3. 查询慢日志时间 show VARIABLES like 'long_query_time%'; 4. 修改时间大于10秒记录日志 set global long_query_time=10; 5. 查询日志存放位置 find / -name iZ2vcay9yqsrl588etpwahZ-slow.log 注： iZ2vcay9yqsrl588etpwahZ-slow.log 第一步中 slow_query_log_file 的文件名称
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0f9d3910fe354396bf5fdf872ca29e0/" rel="bookmark">
			LeetCode——32. Longest Valid Parentheses(C&#43;&#43;)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		LeetCode——32. Longest Valid Parentheses(C++)
Given a string containing just the characters ‘(’ and ‘)’, find the length of the longest valid (well-formed) parentheses substring.
Example 1:
Input: s = “(()”
Output: 2
Explanation: The longest valid parentheses substring is “()”.
Example 2:
Input: s = “)()())”
Output: 4
Explanation: The longest valid parentheses substring is “()()”.
Example 3:
Input: s = “”
Output: 0
Constraints:
0 &lt;= s.length &lt;= 3 * 104
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f0f9d3910fe354396bf5fdf872ca29e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5b74dba1b1d86be426488c7e2c457ca/" rel="bookmark">
			Gbase客户端工具无法连接到数据库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		windows端利用客户端工具连接数据库报错：无法连接到服务器 排查方法： 1.检查配置信息是否有误
2.检查数据库服务器防火墙和windows本地的端口是否开放
systemctl stop firewalld.service
telnet ip 端口
3.查看是否gbase用户密码过于简单
4.查看数据库online日志是否有报错信息
5.都不能解决时，建议删除，重新创建。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b43847bd63220c59c9eb78d5a3ae9c8/" rel="bookmark">
			数据结构 第六章 图——MST性质（十分简单的理解！）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MST性质（Minimun Spanning Tree） 书上给出的定义是：假设 N = ( V , E ) N=(V,E) N=(V,E)是一个连通网，U是顶点集V的一个非空子集。若 ( u , v ) (u,v) (u,v)是一条具有最小权值的边，其中 u ∈ U u\in U u∈U， v ∈ V − U v\in V-U v∈V−U，则必存在一棵包含边 ( u , v ) (u,v) (u,v)的最小生成树。
看到这里，相信大多数人都十分苦恼，很难理解它的意思，下面我以自己的理解对其作出解释（这里是利用反证法的相关理解），希望能有所帮助。
首先，这个集合U和V-U是人为地去规定的，相当于是我们用一条线将一棵生成树划分为两个部分，如下图所示（不要怀疑，下图就是一棵生成树）：
在这里该树就是一棵最小生成树。由上图所示，我们用一条虚线将该树划分为了两部分（自己也可以假想划的其他部分，都是行得通的），我们令左边区域为U，右边就自然为V-U了。然后按书上的意思就是分别从U和V-U上找一个顶点，且这两个顶点一定有最小权值。书上这句话的意思就是，将这两个顶点连起来。注意：由于生成树的性质，依照上述连起来后就会形成一个回路，如下图：
只要注意这两个顶点分别属于U和V-U就行了，这里我们取图中2号连线。那么我们连上后，明显地有一条回路。注意书上的这句话 “ 则 必 存 在 一 棵 包 含 边 “则必存在一棵包含边 “则必存在一棵包含边(u,v) 的 最 小 生 成 树 ” 的最小生成树” 的最小生成树”，既然已经包含 ( u , v ) (u,v) (u,v)了，如果就如上图一样，共有8个顶点，8条边了，很明显这是不符合生成树的概念的。既然我们人为地加了一条边（图中2号连线），那么我们也应该人为地删除一条线，且删除的这条线的两个顶点也必须分别属于两个子集U和V-U。那么我们从上图看到，v1，v2正是这样的顶点，删除后如下图：因为我们前面规定了，相当于我们加的这条线一定具有最小权值，所以加的这条边的权值一定大于 ( v 1 , v 2 ) (v1,v2) (v1,v2)的权值，那么，这也就是 包 含 边 包含边 包含边(u,v) 的 最 小 生 成 树 的最小生成树 的最小生成树了。 那么综上所示，做一个小小滴步骤总结：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4b43847bd63220c59c9eb78d5a3ae9c8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b1f378a57c0a3e8c09c9d009f10a2af/" rel="bookmark">
			腾讯面试题：请写一个程序，不用 if，条件表达式，switch 等判断语句，找出两个整数 a,b 中的较大者。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		请写一个程序，不用 if，条件表达式，switch 等判断语句，找出两个整数 a,b 中的较大者。
可以通过两个数之间的差值来进行判断，通过计算得到两个数的差值之后，去判断二进制最高位是0还是1，如果是0就代表正数，1为负数。代码实现如下：
#include&lt;bits/stdc++.h&gt; using namespace std; int main() { int a, b; cin&gt;&gt;a&gt;&gt;b; int c = a - b; char *str[5] = {"a比b大","b比a大"}; c = unsigned(c) &gt;&gt; (sizeof(int) * 8 - 1); cout&lt;&lt;str[c]; return 0; } 我们得到c之后通过二进制向右移动31位得到整数的最高位，这样就可以进行正负号的判断，如果为0意味a大，为1也就是b大。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2bf833b1b03c5413e7fe6465ed5aa3a5/" rel="bookmark">
			windows 修改(pip/conda)镜像源
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言
本文仅介绍了 Windows 环境下的 pip 和 conda 的镜像源修改方法，linux系统请移步主页另一篇博文。
1、什么是镜像源？ 国内的下载资源，国外源pip install或者conda install下载安装程序包会很慢，有时候直接不能想下载。所以需要更换镜像下载源。
2、国内常见的镜像源有哪些？
（1）豆瓣：http://pypi.douban.com/simple/
（2）阿里云 http://mirrors.aliyun.com/pypi/simple/ （3）清华大学：https://pypi.tuna.tsinghua.edu.cn/simple
（4）中国科学技术大学 : https://pypi.mirrors.ustc.edu.cn/simple
（5）华中理工大学 : http://pypi.hustunique.com/simple
（6）山东理工大学 : http://pypi.sdutlinux.org/simple
3、临时使用，方法很简单
例如使用清华源安装numpy,使用实例为 pip install -f https://pypi.tuna.tsinghua.edu.cn/simple，直接将下载资源链接放在后面，conda 同理，如果觉得麻烦就需要在命令行操作以=更换镜像源，这样就不用每次都手动输入下载源。
4、pip 和 conda 的区别是什么？
（1）pip：Python包的通用管理器，在任何环境中安装python包。
（2）conda：与语言无关的跨平台环境管理器，在conda环境中安装任何包
5、pip 的 临时修改镜像源 和 永久修改镜像源 的区别是什么？
（1）临时修改镜像源：在执行某个安装语句后面指定镜像源，只在当条命令有效，后面使用安装语句用的还是之前的镜像源。
（2）永久修改镜像源：通过修改配置文件将管理器的默认镜像源给修改了，之后每次下载都用修改后的镜像源。
6、永久修改：(以清华大学镜像源为例)
打开文件资源管理器，手动全局设置镜像源地址，若你想设置其他镜像源，请用对应的下载地址。
pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple
7.查看更改后的镜像源 pip config list
这里已经可以满足大多数的下载安装了，下面的操作可以省略。
8.永久使用更多下载通道 ①windows下，在user目录中创建一个pip文件夹,如C:\Users\xx\pip，在pip文件夹中新建文件pip.ini,内容如下
9、添加环境变量，将这段字符添加到path中：%HOME%\pip\pip.ini
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2446fd3f89fa175479086e5440958179/" rel="bookmark">
			Not running on Jetty, JSR-356 support unavailable分析与解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Not running on Jetty, JSR-356 support unavailable分析与解决 应用部署后，启动时报错 代码:
[org.eclipse.jetty.websocket.jsr356.server.deploy.WebSocketServerContainerInitializer@d3a9b786] ServletContainerInitializer（位于以下应用程序 [portal-app] 中）在调用 onStartup 方法时发生了以下错误：[javax.servlet.ServletException: Not running on Jetty, JSR-356 support unavailable at org.eclipse.jetty.websocket.jsr356.server.deploy.WebSocketServerContainerInitializer.onStartup(WebSocketServerContainerInitializer.java:183) 无论是在WAS、Liberty或Tomcat等其他应用服务器上面碰到如上错误时，原因是
应用中的websocket包与应用服务器自身带的实现冲突了。
比如，pom.xml中的项目依赖：
&lt;dependency&gt;
&lt;groupid&gt;org.springframework.boot&lt;/groupid&gt;
&lt;artifactid&gt;spring-boot-starter-websocket&lt;/artifactid&gt;
&lt;/dependency&gt;
解决方法：
在打包时将 websocket-*.jar 包排除在外即可。
在pom.xml中可以进行排除
&lt;plugin&gt;
&lt;groupid&gt;org.apache.maven.plugins&lt;/groupid&gt;
&lt;artifactid&gt;maven-war-plugin&lt;/artifactid&gt;
&lt;configuration&gt;
&lt;packagingexcludes&gt;WEB-INF/lib/websocket-*.jar&lt;/packagingexcludes&gt;
&lt;/configuration&gt;
&lt;/plugin&gt;
然后，重新构建打包部署。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4c8f2e22f3498be1b748fc2682e8a2c/" rel="bookmark">
			分布式文件存储系统Minio
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Minio介绍 MinIO基于Apache License 2.0开源协议的对象存储服务。它兼容Amazon S3云存储接口。适合存储非结构化数据，如图片，音频，视频，日志等。对象文件最大可以达到5TB
官网：https://min.io/ 中文 http://minio.org.cn/
1、Minio基础概念 Object:存储到Minio的基本对象，如文件字节流，AnythingBucket:用来存储Object的逻辑空间。每个Bucket之间的数据是相互隔离的。对于客户端而言，就相当于一个存放文件的顶层文件夹。Drive:即存储数据的磁盘，在MinlO启动时，以参数的方式传入。Minio中所有的对象数据都会存储在Drive里Set:即-组Drive的集合，分布式部署根据集群规模自动划分一个或多个Set，每个Set中的Drive分布在不同位置。一个对象存
储在一个Set上。(For example:{1…64} is divided into 4sets each of size16) 一个对象存储在一个Set上一个集群划分为多个Set一个Set包含的Drive数量是固定的，默认由系统根据集群规模自动计算得出一个SET中的Drive尽可能分布在不同的节点上 1.1 纠删码 MiniO 使用纠删码机制来保证高可靠性，使用highwayhash来处理数据损坏(Bit Rot Protection)。关于纠删码，简单来说就是可以通过数学计算，把丢失的数据进行还原，它可以将n份原始数据，增加m份数据，并能通过n+m份中的任意n份数据，还原为原始数据。即如果有任意小于等于m份的数据失效，仍然能通过剩下的数据还原出来。
1.2 存储形式 文件对象上传到Minio，会在对应的数据存储磁盘中，以Bucket名称为目录，文件名称为下一级目录，文件下是part.1（超过10M时候才会有此文件）和xl.meta，前者是编码数据块以及检验块，后者是元数据文件
1.3 存储方案 二、Minio环境搭建 1、单机部署 基于Centos7 安装路径 /usr/local/soft
wget https://dl.min.io/server/minio/release/darwin-amd64/minio chmod +x minio ./minio server /mnt/data 访问 http://192.168.150.129:41922 用户名密码：minioadmin
发现图中有警告：WARNING: Console endpoint is listening on a dynamic port (41922), please use --console-address ":PORT" to choose a static port.
目前启动的时候端口是动态的，只要在启动命令后加上 --console-address ":PORT" ，就变成静态端口
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a4c8f2e22f3498be1b748fc2682e8a2c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab45ac293ddb8e999575d88c4627e680/" rel="bookmark">
			联想小新Win11系统如何将新建标签页设置为Edge浏览器首页
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先我们先打开Edge浏览器，点击右上角 ··· 选择 设置
然后选择 开始、主页和新建标签页 在 Microsoft Edge启动时 选择 打开新建标签页
这是我们再打开 Microsoft Edge浏览器，但是界面依然没有改变，这如何修改呢？
打开联想小新自带的 联想电脑管家 ，选择 安全防护，右下角 浏览器保护，将其 关闭 即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2db2f61cd2d97cc7c17fbe0e07a5fbc/" rel="bookmark">
			git提交 出现 ： fatal: refusing to merge unrelated histories
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 项目场景： 场景：本地文件在变更之后 无法提交到远程仓库并报错 fatal: refusing to merge unrelated histories 我最近因为同一个本地文件做了不同的修改，要提交到不同的仓库会经常提示此问题
原因分析： 问题的分析：因为两个根本不相干的 git 库， 一个是本地库， 一个是远端库， 然后本地要去推送到远端， 远端觉得这个本地库跟自己不相干， 所以告知无法合并
例如：Handler 发送消息有两种方式，分别是 Handler.obtainMessage()和 Handler.sendMessage()，其中 obtainMessage 方式当数据量过大时，由于 MessageQuene 大小也有限，所以当 message 处理不及时时，会造成先传的数据被覆盖，进而导致数据丢失。
解决方案： 具体解决方案：
解决方案一： git clone远程仓库到本地，将需要推送的内容放到该仓库下 ， 然后提交上去 ， 这样算是一次update操作
解决方案二 ： 使用强制命令
git pull origin master --allow-unrelated-historie
后面加上 --allow-unrelated-histories ， 把两段不相干的分支进行强行合；这里可能会进入一个编辑页面，只需要先ESC，然后敲:q! 即可
后面再push就可以了 git push -u origin master
方案二: git pull origin master --allow-unrelated-historie 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1067bd860d139d00dee90a19c8b394c9/" rel="bookmark">
			React造轮子（reacthook实现一套自己的组件库）轮子公开课——第五课【Radio、RadioButton、RadioGroup】组件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、组件库介绍二、Radio、RadioButton、RadioGroup组件流程介绍三、代码详解3.1、Radio.tsx3.2、Radio / index.scss3.3、RadioButton.tsx3.4、RadioButton / index.scss3.5、RadioGroup.tsx3.6、variables.scss 四、效果呈现结语 一、组件库介绍 有兴趣的同学 可以先着手看源码，之前写的一系列开源组件库项目（有帮助的同学也帮忙点个star👍）
名称官网githubtinkerbell-ui(vue2.0)http://tinkerbell.tophttps://github.com/hanbingxu82/tinkerbell-uitinkerbell-ui(vue3.0)—https://github.com/hanbingxu82/tinkerbell-ui-nexttinkerbell-ui(react-hook)—https://github.com/hanbingxu82/tinkerbell-ui-react 二、Radio、RadioButton、RadioGroup组件流程介绍 在一个ui组件库当中其实，表单组件可以称之为重中之重，因为现在基本上pc端大部分开发还是面向的b端，所以基本上表单组件，在每个小模块当中是基本上都可以使用到的，那么关于 radio 组件我相信大家也都很熟悉，因为不免得每个表单中基本都带有着单选框组件，像如下，其实本身html标签的input的type给个radio属性也就是最初始的单选组件
那么我们现在肯定也要捋清楚一个逻辑就是我们怎么去实现这个radio单选框组件呢？其实有两种思路：
1、我们采用一个div去做底层，然后给这个div去设置样式，实现对应的点击事件，触发回显值，对应点击设置高亮等。但是这样也有弊端就是什么，我们外层绑定一个原始的form是无法提交表单值的、再有无法抓取value值、无法使用fieldset进行统一禁用这些，表单的原始功能就无法模拟了。
2、我们采用 input type=“radio” 去做一个底层，当然因为本身也是携带着radio样式的，这样我们只需要改样式即可，然后同样的本身也带有着点击事件默认行为等，我们直接使用默认的一系列方法即可
所以综上所述，我们的 radio 组件底层既采用 input type=“radio” 去实现功能，再有像RadioButton的话，我们也可以做一个简单的组件封装，底层我们还是一样的，就是设置边框以及选中高亮这些实现对应的功能，再有至于RadioGroup的话，总的来说它是用来包裹 Radio 、RadioButton组件的，我们可以直接在这个组件上面设置默认的选中值，以及回传值，以此来实现功能，所以接下来我们总结功能：
Radio:
type: string // type类型 判断颜色
checked: boolean // 是否选中
disabled: boolean // 禁用项
groupValue: any // groupValue 值是否与value值相等 逻辑上来说可传可不传 当时只是为了做判断用的 因为 value 也同样可以给与初始值
value: any // value初始值
label: string // 初始 lable 文本
name?: string // 原生 name 属性
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1067bd860d139d00dee90a19c8b394c9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c0018c3c39468ca4ff03e842b2665b7/" rel="bookmark">
			git执行git push -u origin main 报错 error: src refspec main does not match any
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天想把自己的代码推送到新建的git项目上，发现执行git push -u origin main 命令时候出错
错误产生的原因：Github 工程默认名为了 main
由于受到"Black Lives Matter"运动的影响，GitHub 从今年 10 月 1 日起，在该平台上创建的所有新的源代码仓库将默认被命名为 “main”，而不是原先的"master"。
解决方案：
统一远程和本地的仓库名称：
​ 把本地的 master 仓库名称修改为远端的 main
# 重命名命令： git branch -m 旧名字 新名字 # 实例 git branch -m master main 然后再重新的推送发现推送成功了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/622fe25e4fb20293f426be8c1d184bf0/" rel="bookmark">
			Spring学习之使用 JdbcTemplate 与 NamedParameterJdbcTemplate 连接数据库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在项目工程中，我们一定会使用程序去连接数据库，Spring 中给我们提供了两个特别方便连接数据库的操作： JdbcTemplate 与 NamedParameterJdbcTemplate，如果不用Spring 提供的 JdbcTemplate，必须创建大量的冗余代码(创建连接，关闭连接，处理异常)中的所有DAO数据库的操作方法 - 插入，更新和删除。下面就介绍如果使用。
工程项目结构 数据库操作 CREATE TABLE `customer` ( `ID` int(10) unsigned NOT NULL AUTO_INCREMENT, `NAME` varchar(100) NOT NULL, `AGE` int(10) unsigned NOT NULL, PRIMARY KEY (`CUST_ID`) ) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8; 程序代码 Customer.java 创建一个 model，用于与数据库中的表对应上
package com.wq.spring.customer.model; /** * 创建一个 Customer的model * 用来对应上数据库中的表 * @author wuq * */ public class Customer { private int id; private String name; private int age; public Customer(int id, String name, int age) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/622fe25e4fb20293f426be8c1d184bf0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1621141f4ddc3397d961504017f31d28/" rel="bookmark">
			python基础之--人机大战，编程思维
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import pygame import time #循环里面要sleep一下，不然一会儿就将内存占满了 from pygame.locals import * #检测键盘 import random import sys #退出系统 #动态的项目，先截个静态图来分析：化动为静，化难为易，一个西瓜切成块，再拼接起来 #拿到一个大项目，首先把项目的各个元素分成一个个的对象，确定对象具备的属性，方法，然后再组装成为一个项目 #玩家类： #属性：显示窗口、位置、图片、子弹列表、移动状态 #方法：显示、移动、开火,凡是动作类都搞成方法 class player(): def __init__(self,screen): self.screen=screen#将一个窗口对象作为了属性值 self.x=150 self.y=500 self.img =pygame.image.load("飞机\\hero.gif") self.bullet_list=[] self.ifmoveright=0#0表示不移动，1表示移动 self.ifmoveleft=0 def display(self): self.screen.blit(self.img,(self.x,self.y)) print() for f in self.bullet_list: f.move() f.display() if f.y&lt;=0: self.bullet_list.remove(f) def move(self): if self.ifmoveleft==1 and self.x&gt;=-30: self.x-=20 if self.ifmoveright==1 and self.x&lt;=270: self.x+=20 def fire(self): d=playerzd(self.screen,self.x,self.y) self.bullet_list.append(d) class playerzd(): def __init__(self,screen,x,y): self.screen=screen self.x=x self.y=y self.img=pygame.image.load("飞机\\bullet.png") def display(self): self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1621141f4ddc3397d961504017f31d28/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57da990f4f32be514c7efefddf90107a/" rel="bookmark">
			Swift中WebView的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 创建WKWebView 创建基本流程 let view = WKWebView(frame: CGRect(x: 0, y: 0, width: SCREEN_WIDTH, height: SCREEN_HEIGHT), configuration: addConfig()) view.uiDelegate = self // UI代理 view.navigationDelegate = self // 导航代理 view.allowsBackForwardNavigationGestures = true // 允许左滑返回 其中设置addConfig() func addConfig() -&gt; WKWebViewConfiguration { // 网页配置对象 let config = WKWebViewConfiguration() // 配置对象的偏好设置 let preference = WKPreferences() // preference.minimumFontSize = 15 // 最小字体 preference.javaScriptEnabled = true // 支持JavaScript preference.javaScriptCanOpenWindowsAutomatically = true // javaScript可以打开窗口 config.preferences = preference config.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/57da990f4f32be514c7efefddf90107a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e9e87f6d066ae892e289b6e89b4bb2d/" rel="bookmark">
			linux安装rabbitMq 3.6.5版本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		linux环境CentOS-7-x86_64 安装依赖
yum install build-essential openssl openssl-devel unixODBC unixODBC-devel make gcc gcc-c++ kernel-devel m4 ncurses-devel tk tc xz 安装Erlang
需要到网上下载
erlang-18.3-1.el7.centos.x86_64.rpm
socat-1.7.3.2-5.el7.lux.x86_64.rpm
rabbitmq-server-3.6.5-1.noarch.rpm
资源包已经上传 地址
rabbitMq3.6.5linux安装包-Java文档类资源-CSDN下载
安装RabbitMQ
# 安装erlang rpm -ivh erlang-18.3-1.el7.centos.x86_64.rpm # 安装 socat rpm -ivh socat-1.7.3.2-1.1.el7.x86_64.rpm # 安装 rabbitmq rpm -ivh rabbitmq-server-3.6.5-1.noarch.rpm 安装过程可能会出现如下错误
warning: socat-1.7.3.2-1.1.el7.x86_64.rpm: Header V4 RSA/SHA1 Signature, key ID 87e360b8: NOKEY error: Failed dependencies: tcp_wrappers is needed by socat-1.7.3.2-1.1.el7.x86_64 解决方案使用如下指令
rpm -ivh socat-1.7.3.2-1.1.el7.x86_64.rpm --force --nodeps 在rpm 语句后面加上 --force --nodeps 即原本为 rpm -ivh *.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e9e87f6d066ae892e289b6e89b4bb2d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3861d34d345af44e4ec4c48262719c8d/" rel="bookmark">
			ARKit 表情动画模型命名规范
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Blendshape 曲线名称列表：
Default EyeBlinkLeft EyeLookDownLeft EyeLookInLeft EyeLookOutLeft EyeLookUpLeft EyeSquintLeft EyeWideLeft EyeBlinkRight EyeLookDownRight EyeLookInRight EyeLookOutRight EyeLookUpRight EyeSquintRight EyeWideRight JawForward JawLeft JawRight JawOpen Extra MouthFunnel MouthPucker MouthLeft MouthRight MouthSmileLeft MouthSmileRight MouthFrownLeft MouthFrownRight MouthDimpleLeft MouthDimpleRight MouthStretchLeft MouthStretchRight MouthRollLower MouthRollUpper MouthShrugLower MouthShrugUpper MouthPressLeft MouthPressRight MouthLowerDownLeft MouthLowerDownRight MouthUpperUpLeft MouthUpperUpRight BrowDownLeft BrowDownRight BrowInnerUp BrowOuterUpLeft BrowOuterUpRight CheekPuff CheekSquintLeft CheekSquintRight NoseSneerLeft NoseSneerRight TongueOut 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7fcc25a218d0c394de53b18f6a39b30b/" rel="bookmark">
			python数据分析学习day08：柱状图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 柱状图: 柱状图是一种用矩形柱来表示数据分类的图表。柱状图可以垂直绘制，也可以水平绘制。它的高度与其所表示的数值成正比关系。柱状图显示了不同类别之间的比较关系，图表的水平轴 X 指定被比较的类别，垂直轴 Y 则表示具体的类别值 2. 柱状图的绘制 matplotlib.pyplot.bar(x, height, width: float = 0.8, bottom = None, *, align: str = ‘center’, data = None, **kwargs) x 表示x坐标，数据类型为float类型，一般为np.arange()生成的固定步长列表height 表示柱状图的高度，也就是y坐标值，数据类型为float类型，一般为一个列表，包含生成柱状图的所有y值width 表示柱状图的宽度，取值在0~1之间，默认值为0.8bottom 柱状图的起始位置，也就是y轴的起始坐标，默认值为Nonealign 柱状图的中心位置，“center”，"lege"边缘，默认值为’center’color 柱状图颜色，默认为蓝色alpha 透明度，取值在0~1之间，默认值为1label 标签，设置后需要调用plt.legend()生成edgecolor 边框颜色 (ec)linewidth 边框宽度，浮点数或类数组，默认为None (lw)tick_label：柱子的刻度标签，字符串或字符串列表，默认值为None。linestyle :线条样式 (ls) 2.1 基本的柱状图 import matplotlib.pyplot as plt # x轴数据 x = range(5) # y轴数据 data = [5, 20, 15, 25, 10] # 设置图形标题 plt.title("基本柱状图") # 绘制网格 plt.grid(ls="--", alpha=0.5) # bar绘制图形,x 表示x坐标 data为表示柱状图的高度 plt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7fcc25a218d0c394de53b18f6a39b30b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f4fda3f185bbd518eed3b421922fd1f5/" rel="bookmark">
			云服务器环境搭建及项目运行部分问题汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		conda create xxx 创建新环境
conda activate xxx 激活新环境
conda info --envs 查看已建立的虚拟环境
ctrl + D 后退
vim ~/.bashrc 进入bashrc 文件
source ~/.bashrc 更新文件
esc + a 进入编辑模式
esc + :wq 保存并退出（注意冒号也要）
/*
查看当前已经安装的包：conda list
查看当前已有的环境：conda env list
创建新的虚拟环境： conda create -n env_name python=3.6
在命令行中激活：conda activate env_name 在命令行中退出：conda deactivate
删除虚拟环境：conda remove -n env_name --all
设置国内镜像：conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/
*/
```bash
useradd -m -s /bin/bash xxx
```
* `-m`：在`/home`路径下创建该用户的根目录
* `-s`：指定用户登入后使用的`shell`
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f4fda3f185bbd518eed3b421922fd1f5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e56e29de8dc3e2f733d197ca7f660fb6/" rel="bookmark">
			简单模拟快递单号查询页面展示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		案例分析：
①快递单号输入内容时，上面的大号字体盒子(con)显示（这里面的文字
②同时把快递单号里面的值(value)获取过来赋值给con盒子(innerText)做为内容
③如果快递单号里面内容为空，则隐藏大号字体盒子(con)盒子
④注意：keydown和keypress在文本框里面的特点：他们两个事件触发的时候，文字还
没有落入文本框中。
⑤keyup:事件触发的时候，文字已经落入文本框里面了
⑥当我们失去焦点，就隐藏这个con盒子
⑦当我们获得焦点，并且文本框内容不为空，就显示这个con盒子
&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
&lt;meta charset="UTF-8" /&gt;
&lt;meta http-equiv="X-UA-Compatible" content="IE=edge" /&gt;
&lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt;
&lt;title&gt;Document&lt;/title&gt;
&lt;/head&gt;
&lt;style&gt;
.search {
position: relative;
width: 178px;
margin: 100px;
}
.con {
display: none;
position: absolute;
top: -40px;
border: 1px solid rgba(0, 0, 0, 0.2);
box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
padding: 5px 10px;
font-size: 18px;
line-height: 20px;
color: #333;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e56e29de8dc3e2f733d197ca7f660fb6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dcb2031736efe60d1454e49ac1597857/" rel="bookmark">
			用java的二维数组做一个简易计算优惠小程序（附带源码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		要求：
1、单点: 溜肥肠24元 酱肘子32 米饭3元 2、订单满30打八折
3、优惠价: 溜肥肠18元
4、打八折与优惠价不能同时使用，点这三样，最少多少钱？
思路：
首先定义一个 String 类型的二维数组，用存放数据
然后使用 for 遍历二维数组，输出数组里的数据
接着分别计算打折和优惠的价格
最后利用 if 进行判断，并提示用户最优选
源码：
public class Exercise { public static void main(String[] args){ //溜肥肠原价lfcD，溜肥肠优惠价lfcY，酱肘子jzz，米饭mf int lfcD=24,lfcY=18,jzz=32,mf=3; //原价价格pay1，优惠价格pay2，折后价格pay3 double pay1,pay2,pay3=0.0;//定义 String[][] dingD={{"------安其拉的订单------"},{"溜肥肠","24.00"},{"酱肘子","32.00"},{"米饭","3.00"},{"------------------------"},{"今日优惠菜品溜肥肠","18.00"},{"------------------------"}}; for(int i=0;i&lt;dingD.length;i++){//遍历输出二维数组 for(int j=0;j&lt;dingD[i].length;j++){ System.out.print(dingD[i][j]+"\t"); } System.out.println(); } pay1=lfcD+jzz+mf;//原价订单 System.out.println("该订单原价为"+pay1+"元");//输出 pay2=lfcY+jzz+mf;//优惠订单 System.out.println("优惠价格为"+pay2+"元"); if(pay1&gt;=30){ pay3=pay1*0.8; System.out.println("该订单满30打8折，折后价格为"+pay3+"元"); }//若满30打八折并输出 if(pay3&gt;pay2){ System.out.println("优惠价最划算，最少花"+pay2+"元"); }else{ System.out.println("满30打8折最划算，最少花"+pay3+"元"); } } } 运行结果为：
知识点： 二维数组：数组中的数组
数据类型[][] 数组名=new 数据类型[3][4]; //三行四列
[3]:二维数组中，有3个一维数组
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dcb2031736efe60d1454e49ac1597857/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0745873b430ea88089d95723893fc05/" rel="bookmark">
			Windows server&#43;Apache&#43;Django的生产部署大坑！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Windows+Apache+Django的生产部署大坑！ 今天试图在windows server 2016上利用Apache部署一个Django项目，折腾了一天，记录一下期间遇到的坑；
直接执行httpd.exe服务执行没问题，但是安装为系统服务后就不能正常运行，排查好久找不到原因…… 一、环境： 1、windows server 2016；
2、Apache 2.4.47；（httpd-2.4.47-o111k-x64-vs16）
3、Django 3.2.3
4、数据库Maria DB；
5、python版本：3.8.10
-----------------------------------------------------------------------------
二、Django项目迁移略过…… 1、debug模式项目可以正常运行，端口号8090正常访问；
三、Apache 安装部署和配置都是根据网上指导进行的； 1、httpd.conf文件中增加了以下内容：（配置文件应该没问题，httpd.exe可以正常运行）
# 以下为新增内容 #添加mod_wsgi.so模块,这三行是mod_wsgi-express module-config命令行中显示出来的 LoadFile "c:/python/python38.dll" LoadModule wsgi_module "c:/python/lib/site-packages/mod_wsgi/server/mod_wsgi.cp38-win_amd64.pyd" WSGIPythonHome "c:/python" # WSGIApplicationGroup %{GLOBAL} #指定项目的wsgi.py配置文件路径,这个py文件是在你的Django项目中 WSGIScriptAlias / "D:/web/djweb/djweb/wsgi.py" application-group=%{GLOBAL} #指定项目目录,即你的Django项目路径 WSGIPythonPath "D:/web/djweb" &lt;Directory "D:/web/djweb/djweb"&gt; &lt;Files wsgi.py&gt; Require all granted &lt;/Files&gt; &lt;/Directory&gt; #项目静态文件地址, Django项目中静态文件的路径 Alias /static "D:/web/djweb/djecharts/static" &lt;Directory "D:/web/djweb/djecharts/static"&gt; AllowOverride None Options None Require all granted &lt;/Directory&gt; #项目media地址, 上传图片等文件夹的路径 Alias /media "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f0745873b430ea88089d95723893fc05/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd62c7376fad2b08d2b3e5fe1d0fe130/" rel="bookmark">
			py之基本语法篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、输入输出函数
输出函数
输入函数
二、if函数​​​​​​​
三、循环
1.while循环
2、for循环
四、range()函数
1.遍历普通的数组
2、遍历指定的数组
3.数据步长
五、迭代器与生成器
1、什么是迭代器
2、迭代器的创建与StopIteration函数的生成
3、生成器
总结
一、输入输出函数 输出函数 print('hello world') 输入函数 age = int(input("年龄")) print(age) 二、if函数 if 条件1: 结果1 elif 条件2: 结果2 else: 结果3 一般这种语句写成下面的形式，因为这样更普遍一些 if 条件1: 结果1 elif 条件2: 结果2 elif 条件3: 结果3 elif 条件4: 结果4 像嵌套的话我就不写了，毕竟一般大学第一个启蒙课就是c，学过c的话就很容易去理解这些东西
三、循环 1.while循环 while 判断条件： 执行语句 a = 1; while a &lt; 10: a += 1 print(a) 其实while也可与else在一起用，for也可以
a = 10 while a &gt; 11: print("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cd62c7376fad2b08d2b3e5fe1d0fe130/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5fe879094656e9018dd8a2de2b4b6c04/" rel="bookmark">
			java如何使用代码求两个list集合的差集呢？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转自：
java如何使用代码求两个list集合的差集呢？
下文笔者讲述求list集合的差集的方法简介说明,如下所示:
差集: 用一个集合减去一个集合得到的集合,我们称之为“差集” 实现思路: 使用stream流中的filter方法对集合 进行"不包含关系计算"，从而得到差集(jdk8循环的新特性) 例：
package com.java265.other; import java.io.UnsupportedEncodingException; import java.util.ArrayList; import java.util.List; import java.util.stream.Collectors; public class Test16 { /** * java265.com 示例程序 * * @throws IllegalAccessException * @throws InstantiationException */ public static void main(String[] args) throws InstantiationException, IllegalAccessException { List&lt;String&gt; list1 = new ArrayList&lt;String&gt;(); list1.add("java265.com-1"); list1.add("java265.com-2"); list1.add("java265.com-3"); List&lt;String&gt; list2 = new ArrayList&lt;String&gt;(); list2.add("java265.com-8"); list2.add("java265.com-2"); list2.add("java265.com-9"); System.out.println("======================"); // list1 差集 list1 = list1.stream().filter(e -&gt; { return !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5fe879094656e9018dd8a2de2b4b6c04/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/faa464bd4d6837be97b70573ee966669/" rel="bookmark">
			自定义window用于展示弹框后 设置rootviewcontroller展示其他页面 再返回设置为nil后 界面不响应问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		app使用window自定义了一个弹框，弹框有个入口是可以展示具体某个viewcontroller内容的，通过设置window的rootViewController来实现。当rootViewController设置为nil再次从viewcontroller返回到弹框页面时，整个界面不响应点击事件。通过视图层级对比发现最开始多了个视图（UITransitionView）：
开始时层级：
展示viewcontroller返回后层级：
这个应该是window通过rootviewcontroller展示过内容后，自动生成了这个类似实现动画的一个view。只需要在rootViewController设置为nil时再把之前加在window上的控件bringSubviewToFront即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6da22871f395d6b5d8e9a70a5f0508ac/" rel="bookmark">
			【笔记】js循环遍历对象符合某个值删除指定属性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天在项目中遇到了循环遍历对象找到指定属性，然后该属性的问题。
本来想用delete删除，但是会报错，在网上找了找发现Reflect.deleteProperty(指定对象,要删除的属性)可以删除，所以拿来记录。
deleteDadman() { let datalist = { age:18, name:'蜡笔小新', mothername:'美伢', fathername:'广志', petname:'小白', friend1:'风间', friend2:'妮妮', friend3:'阿呆', badman:'偷小孩的' } for(let key in datalist) { if(key == 'badman') { // delete key这里会报错，不能删除指定key Reflect.deleteProperty(datalist,key) // 能够删除指定key // Reflect.deleteProperty(指定对象,要删除的属性) } } } 不积跬步无以至千里，不积小流无以成江海。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/79f734ae8a1931e8ba0be53321b5b486/" rel="bookmark">
			数据结构 第六章 图——图的遍历
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		6.5 图的遍历 在前面我们知道，树是一种非线性结构，为了方便它在计算机中的存储，对树进行遍历使它线性化。
而图同样也是一种非线性结构，但是图又是一种不同于树的多对多结构，所以在前面我们将其转换为了多个一对多的结构来描述它的存储结构。
图的遍历同树类似，也是从某一个顶点出发，按照某种方法对图中所有顶点访问且仅访问一次。图的遍历算法是求解图的连通性问题、拓扑排序和关键路径等算法的基础。
因为图的任一顶点都可能和其余的顶点相邻接，为了避免同一顶点被访问多次，在遍历图的过程中，必须记下每个已访问过的顶点。
通常有两条遍历的图的路径：深度优先搜索和广度优先搜索。
6.5.1 深度优先搜索 1. 深度优先搜索遍历的过程 深度优先搜索（Depth First Search，DFS）遍历类似于树的先序遍历。我们也可以理解一下深度的概念，也就是树中深度的概念，但这需要图要有跟树相似的形状。何谓深度优先？就是从某个顶点一直往下，先不管与它处于同一层次的其它顶点。
对于一个连通图，深度优先搜索遍历的过程如下：
从图中某个顶点 v v v出发，访问顶点 v v v找到刚访问过的顶点的第一个未被访问的邻接点，接着访问该邻接点；然后以该邻接点为新的顶点，重复上述步骤，直到刚访问过的顶点没有未被访问的邻接点。经过了第二步后，由 v v v的第一个未被访问的邻接点延伸的后面的顶点都被访问了（但不确定这条延伸链上每个顶点的其它邻接点是否被访问），此时还停留在“最下面”的那个顶点，这时我们需要返回到前一个访问过的且仍有未被访问的邻接点的顶点。若停留顶点的前面一个顶点的邻接点都被访问过，则继续“向上”回溯。重复步骤（2）和（3），直至图中所有顶点都被访问过，搜索结束。 下面举一个例子，来说明该搜索方法，如下图：
如果我们要遍历该图，按照上述的步骤进行，那么即：
从顶点 v 1 v_{1} v1​出发，访问 v 1 v_{1} v1​（也可从其它任一顶点出发）选择 v 1 v_{1} v1​未被访问的第一个邻接点 v 2 v_{2} v2​（也可以是 v 3 v_{3} v3​），访问 v 2 v_{2} v2​。又以 v 2 v_{2} v2​为新顶点，那么这条延伸链则为： v 1 → v 2 → v 4 → v 8 → v 5 v_{1}\rightarrow v_{2}\rightarrow v_{4}\rightarrow v_{8}\rightarrow v_{5} v1​→v2​→v4​→v8​→v5​，因为 v 5 v_{5} v5​的邻接点都已被访问过，最后停留在 v 5 v_{5} v5​。此时我们需要回溯，找到前面顶点的未被访问过的邻接点。 v 5 → v 8 v_5\rightarrow v_{8} v5​→v8​, v 8 → v 4 v_{8}\rightarrow v_{4} v8​→v4​, v 4 → v 2 v_{4}\rightarrow v_{2} v4​→v2​，都没有找到未被访问的邻接点，最后 v 2 → v 1 v_{2}\rightarrow v_{1} v2​→v1​， v 1 v_{1} v1​有未被访问的邻接点，搜索又从 v 1 → v 3 v_{1}\rightarrow v_{3} v1​→v3​，继续进行下去。最后，我们得到的访问序列为： v 1 → v 2 → v 4 → v 8 → v 5 → v 3 → v 6 → v 7 v_{1}\rightarrow v_{2}\rightarrow v_{4}\rightarrow v_{8}\rightarrow v_{5}\rightarrow v_{3}\rightarrow v_{6}\rightarrow v_{7} v1​→v2​→v4​→v8​→v5​→v3​→v6​→v7​。 因为我们遍历是求解图的连通性问题，若访问结束没有未被访问的结点，则是连通图；若有，则是非连通图。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/79f734ae8a1931e8ba0be53321b5b486/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0637d98cf7074d1abce6c59cdbe1b2c5/" rel="bookmark">
			windows环境和linux环境MD5加密不一致
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.md5加密时由于环境编码不一致导致（因为Linux是UTF-8，而windows是gb2312或者GBK）
2.解决方案
原先代码
public static String MD5Encode(String origin) { String resultString = null; try { resultString = new String(origin); MessageDigest md = MessageDigest.getInstance("MD5"); resultString = byteArrayToHexString(md.digest(resultString.getBytes())); } catch (Exception ex) { } return resultString.toUpperCase(); } 改后代码
public static String MD5Encode(String origin) { String resultString = null; try { resultString = new String(origin); MessageDigest md = MessageDigest.getInstance("MD5"); resultString = byteArrayToHexString(md.digest(resultString.getBytes("UTF-8"))); } catch (Exception ex) { } return resultString.toUpperCase(); } 即，把resultString.getBytes() 变为 resultString.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0637d98cf7074d1abce6c59cdbe1b2c5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5bd58c0d9c6259b706fbd8a0b6929029/" rel="bookmark">
			数据结构 第六章 图——图的定义和存储类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在线性表中，数据元素之间仅有线性关系，每个数据元素只有一个直接前趋和直接后继；在树型结构中，数据元素之间有着明显的层次关系，并且每一层中的数据元素可能和下一层的多个元素相关，但只能和上一层的一个元素相关。而在图结构中，结点之间的关系可以是任意的，图中任意两个数据元素之间都可能相关。
6.1 图的定义和基本术语 6.1.1 图的定义 图（graph）G由两个集合V和E组成，其中V是顶点（vertex）的有穷非空集合，E是图中边的有穷集合。E(G)可以为空，但为空时G只有顶点而没有边。
下图就是一个无向图的例子。
通过观察，我们可以看到上述图中的边并没有方向，所以我们把这类图叫做无向图，而 ( x , y ) (x,y) (x,y)表示从顶点x到顶点y的一条边，例如上图中的 ( v 1 , v 2 ) (v1,v2) (v1,v2)，就表示一条边。同样，由于它的边没有方向，因此 ( v 2 , v 1 ) (v2,v1) (v2,v1)与 ( v 1 , v 2 ) (v1,v2) (v1,v2)是一样的。
既然对于图来说，有无向图的说法，那么就一定会有有向图的说法，下图就是一个有向图的例子。
为了跟无向图区别，有向图中一条边（有向图中的边也叫弧）由 &lt; x , y &gt; &lt;x,y&gt; &lt;x,y&gt;来表示，其中，x是有向边的始点（弧尾），y是有向边的终点（弧头）。
在了解了图的两种类型后，下面介绍图的基本术语
6.1.2 图的基本术语 对于一个图，我们用n表示图中顶点数目，用e表示边的数目。
子图：假设有两个图 G = ( V , E ) G=(V,E) G=(V,E)和 G ′ = ( V ′ , E ′ ) G^{'}=(V^{'},E^{'}) G′=(V′,E′)，如果 V ′ ⊆ V V^{'}\subseteq V V′⊆V且 E ′ ⊆ E E^{'}\subseteq E E′⊆E，则称 G ′ G^{'} G′为G的子图，例如：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5bd58c0d9c6259b706fbd8a0b6929029/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de17ff946f9c5db2644100385a285747/" rel="bookmark">
			C#中await/async用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 引言 官方文档：https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/concepts/async
看微软的官方文档看的头大，比较晦涩的，反正我是啃不动，这里通俗的解释一下c# 中的await/async
2 await/async是什么 说白了await/async就是一个语法糖，单纯使用await/async并不会创建一个线程，创建线程的这个操作由是线程池决定的。
那么我们为啥还要使用await/async呢？
答：为了更好的编写异步操作，也就是识别性更高
3 错误的调用异步方法 3.1 方法上只添加async，但内部未使用Task.Run 可以看到，单纯在方法上添加async，是不会执行异步的。
想要异步，还需要在方法内部使用Task.Run或者创建线程。
3.2 方法内部未处理返回值 可以看到，CalculateSum方法内部的Task.Run，并没有阻塞，也就是我们并没得到异步线程计算后c的值。
如果我们在方法上加async呢？结果是一致的。
4 使用await等待Task.Run的结果 我们在原有的Task.Run前面加await，发现报错
所以我们需要这么做，在CalculateSum方法上添加async关键词，这时候又报错了。
因为我们是有返回值的，异步方法的返回值只能是void，Task，或者Task&lt; T &gt;,我们添加返回值Task&lt; int &gt;
5 如何调用我们写的异步方法 经过上面的错误操作后，这时我们的异步方法已经写好了，如下
Console.WriteLine("start"); CalculateSum(1, 2); CalculateSum(1, 2); CalculateSum(1, 2); CalculateSum(1, 2); Console.WriteLine("end"); Console.ReadKey(); public static class MThread { public static async Task&lt;int&gt; CalculateSum(int a, int b) { int c = 0; await Task.Run(() =&gt; { Console.WriteLine(Thread.CurrentThread.ManagedThreadId+":start"); Thread.Sleep(1000 * 3); Console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/de17ff946f9c5db2644100385a285747/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4d12518b975b7db46f22688f42e6b9d/" rel="bookmark">
			Vue3 京东到家项目实战第二篇（商家详情页面及购物车完整逻辑开发） 进阶式掌握vue3完整知识体系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
封装axios请求💙
商家详情页面的实现 💜 页面样式实现
页面防抖
省略号表示多余内容
通过 watchEffect 巧妙的进行代码拆分
底部购物车样式开发❤️ 购物车数据联动 💚 同步改变选中数字与金额
根据购物车选中状态实现计算金额
清空购物车功能
本地存储保存购物车数据
个人主页：小杰学前端
Vue3 京东到家项目实战第一篇：京东到家（首页及登录功能开发）
项目源码在文章最后哦🙋🙋🙋
封装axios请求 💨 在第一篇中我们的附近店铺是写死的数据，我们把它通过接口请求过来。 在 util 下的 request.js 中我们还需要写一个 get 请求来获取附近店铺的数据，那我们创建一个 axios 实例对象，在里面配置参数，这样就不需要在每个请求里都设置 baseURL 了。
const instance = axios.create({ baseURL: 'https://www.fastmock.site/mock/ae8e9031947a302fed5f92425995aa19/jd', timeout: 10000 }) 这样我们把原来的 post 进行一下封装：
export const post = (url, data = {}) =&gt; { return new Promise((resolve, reject) =&gt; { instance.post(url, data, { headers: { 'Content-Type': 'application/json' } }).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e4d12518b975b7db46f22688f42e6b9d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b01e49a9246eca832d8d53147db3d01/" rel="bookmark">
			GDB 的简单用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.显示信息 -i(info) -p(print) -x(examine) -内存 1.x/显示数量.显示类型.显示长度（help x 查看 类型 长度）+ *地址 2.x/显示数量.显示类型.显示长度 + $寄存器 3.p + *地址：打印此地址处存的值 (p/类型 也可改变要显示的值的输出类型[ 二进制 十进制 十六进制等 ]) 4.p + **地址：打印此地址中存的地址中存的值(*此处表示类似于指针中的*) 5.p + $寄存器：打印寄存器中存的值 6.i proc m(vvmap)：查看内存信息 7.x + 函数名 -栈 1.bt(info stack)：查看栈中调用的函数 2.stack + n：查看当前栈函数的栈中的情况(默认显示10行 n为显示的行数) 3.i(info) f：查看当前栈的详细情况() 4.frame n：查看第n(从0开始)层栈中的栈函数 -寄存器 1.i reg(register)：查看寄存器信息 2.i all-registers：查看所有寄存器信息 3.x 或 p + $寄存器：查看特定寄存器内的信息 -运行信息 i program(进程号 程序运行处的地址 停止原因) -设置自动显示变量 1.display/格式 + 地址(或变量$xxx) 2.i display：查看自动显示信息 3.d display + 号：删除自动显示点 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6b01e49a9246eca832d8d53147db3d01/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6dde88bef8be89e316622cc1c17d75cb/" rel="bookmark">
			linux系统维护篇：firewall-cmd中放开、禁止、转发命令保姆级手把手教你用附带一个策略管理工具脚本让你丝般顺滑的放心操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		预警：所有永久策略更改后，请执行重载命令使其生效，如下：
firewall-cmd --reload
设置public的策略后，配置文件路径：/etc/firewalld/zones/public.xml 注意做好备份
1、查询端口放开策略 1.查询指定端口是否放开 [root@localhost /home]# firewall-cmd --query-port=9191/tcp 2.列出所有放开的端口
[root@localhost /home]# firewall-cmd --list-port 3.列出所有放开的服务
[root@localhost /home]# firewall-cmd --list-service 4.查看所有策略
#列出所有策略 [root@localhost /home]# firewall-cmd --list-all #列出区域是公共的所有策略 [root@localhost /home]# firewall-cmd --list-all --zone public 2、添加端口放开策略 2.1、所有来源均可访问 1.开放指定端口
例：所有来源均可访问9191端口的tcp包
[root@localhost /home]# firewall-cmd --zone=public --add-port=9191/tcp --permanent [root@localhost /home]# firewall-cmd --reload 2.删除开放的端口
[root@localhost /home]# firewall-cmd --zone=public --remove-port=9191/tcp --permanent [root@localhost /home]# firewall-cmd --reload 3.开放指定服务
例：所有来源均可访问sshd服务的tcp包
[root@localhost /home]# firewall-cmd --zone=public --add-service=ssh/tcp --permanent [root@localhost /home]# firewall-cmd --reload 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6dde88bef8be89e316622cc1c17d75cb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/773e2f6ab321e4c197ff8a9c884b1563/" rel="bookmark">
			如何添加打印机到电脑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先你要知道打印机的ip
可以先打印测试页
找到控制面板——点击设备与打印机
左上角选择添加打印机
选择 我所需的打印机未列出
点击add aprinter usinga …
然后下一页
输入你的打印机的ip地址 和端口号 点击下一步
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5ce1c70643d5d6d385ead14cf8e33e3/" rel="bookmark">
			01-初识Vue
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 初识Vue2. Hello World!3. Counter定时计数器 1. 初识Vue Vue 是一套适合初学者学习的渐进式前端框架，适用面很广，上手很容易。知识储备：HTML、CSS、JS。学习版本：Vue3编辑器：VSCode 2. Hello World! 创建新文件夹，通过 VSCode 打开。
创建文件 index.html
在VSCode中，输入 ! 即可实现搭建HTML5的骨架
引入 Vue，添加 script 标签，将 Vue 地址添加到属性 src 中
&lt;script src="https://unpkg.com/vue@next"&gt;&lt;/script&gt; 下面开始编写 Hello World!
在 body 标签内部，创建根节点：
&lt;div id="root"&gt;&lt;/div&gt; 另外再创建 script 标签对，编写如下代码：
&lt;script&gt; Vue.createApp({ template: '&lt;div&gt;Hello World!&lt;/div&gt;' }).mount('#root') &lt;/script&gt; .mount('#root') 表示将 Vue 创建的元素挂载到内容区的 id 为 root 的元素上面；
template 表示要替换的内容（模板）；
因此，经过替换之后，body 下的内容实际为：
&lt;div id="root"&gt; &lt;div&gt;Hello World!&lt;/div&gt; &lt;/div&gt; 显示在界面上如图所示
完整代码如下：
&lt;!DOCTYPE html&gt; &lt;html lang="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a5ce1c70643d5d6d385ead14cf8e33e3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c991bef5050d72cbe70f8b920ba49252/" rel="bookmark">
			SonarQube最全使用教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Sonar简介 Sonar是一个用于代码质量管理的开源平台，用于管理源代码的质量，可以从七个维度检测代码质量
通过插件形式，可以支持包括java,C#,C/C++,PL/SQL,Cobol,JavaScrip,Groovy等等二十几种编程语言的代码质量管理与检测
糟糕的复杂度分布 文件、类、方法等，如果复杂度过高将难以改变，这会使得开发人员难以理解它们， 且如果没有自动化的单元测试，对于程序中的任何组件的改变都将可能导致需要全面的回归测试
重复 显然程序中包含大量复制粘贴的代码是质量低下的 ， sonar可以展示源码中重复严重的地方
缺乏单元测试 sonar可以很方便地统计并展示单元测试覆盖率
没有代码标准 sonar可以通过PMD,CheckStyle,Findbugs等等代码规则检测工具规范代码编写
没有足够的或者过多的注释 没有注释将使代码可读性变差，特别是当不可避免地出现人员变动时，程序的可读性将大幅下降，而过多的注释又会使得开发人员将精力过多地花费在阅读注释上，亦违背初衷
潜在的bug sonar可以通过PMD,CheckStyle,Findbugs等等代码规则检测工具检测出潜在的bug
糟糕的设计（原文Spaghetti Design，意大利面式设计） 通过sonar可以找出循环，展示包与包、类与类之间的相互依赖关系，可以检测自定义的架构规则；
通过sonar可以管理第三方的jar包可以利用LCOM4检测单个任务规则的应用情况 ，检测耦合
Sonar 组成 Sonar 集成过程 开发人员在他们的ide中使用SonarLint运行分析本地代码。开发人员将他们的代码提交到代码管理平台中（SVN，GIT等）持续集成工具自动触发构建，调用SonarScanner对项目代码进行扫描分析分析报告发送到SonarQube Server中进行加工SonarQube Server 加工并且保存分析报告到SonarQube Database中，通过UI显示分析报告 centos安装sonarqube7.7 1、准备 SonarQube版本：sonarqube-7.7.0.zip，官网地址：https://www.sonarqube.org/downloads/
jdk版本：jdk-1.8.0_linux-x64_bin.tar.gz（注：sonarqube从7.9起，不再支持jdk11以下版本）
数据库：mysql5.6-5.7（sonarqube从7.8起，不再支持mysql）（功能验证也可以SonarQube内置的数据库，这样就不需要改数据库配置
2、安装jdk1.8 详见：linux安装jdk8
3、解压SonarQube yum install -y zip unzip // 安装解压工具 unzip /home/data/soft/sonarqube/sonarqube-7.7.zip 4、修改 /home/data/soft/sonarqube/sonarqube-7.7/conf/sonar.properties 文件，更改数据连接配置 sonar.jdbc.url=jdbc:mysql://192.168.1.165:3306/sonar?useUnicode=true&amp;characterEncoding=utf8&amp;rewriteBatchedStatements=true&amp;useConfigs=maxPerformance&amp;useSSL=false sonar.jdbc.username=root sonar.jdbc.password=root 5、创建SonarQube启动用户（SonarQube内置了elasticsearch，elasticsearch不允许使用root用户启动） useradd sonar passwd sonar 7、设置系统参数（elasticsearch启动需要设置一些参数） 详细见：elasticsearch启动常见错误
未设置这些参数在$SONARQUBE_HOME/logs/es.log中出现以下错误：
8、赋予启动用户执行权限 chown -R sonar:sonar /home/data/soft/sonarqube/sonarqube-7.7 9、登陆启动用户，启动程序 su - sonar // 以sonarqube用户登陆 cd /usr/local/sonarqube-7.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c991bef5050d72cbe70f8b920ba49252/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/22b93fd580a00c700ed9cdf723cdd36c/" rel="bookmark">
			【Vue】基本结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一个vue组件主要包括3个部分：界面展示代码template、业务实现代码script、界面布局代码style &lt;template&gt; &lt;div class="class_1"&gt; &lt;h2&gt;{{msg}}&lt;/h2&gt; 这是一个fry VueComponentTest &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name: 'FryTest', data () { return { msg: 'Welcome to Your Vue.js App' } } } &lt;/script&gt; &lt;style scoped&gt; .class_1{ color: red; } &lt;/style&gt; vue中的el属性 类型：string | Element
限制：只在用 new 创建实例时生效。
详细：
提供一个在页面上已存在的 DOM 元素作为 Vue 实例的挂载目标。可以是 CSS 选择器，也可以是一个 HTMLElement 实例。
在实例挂载之后，元素可以用 vm.$el 访问。
如果在实例化时存在这个选项，实例将立即进入编译过程，否则，需要显式调用 vm.$mount() 手动开启编译。
提供的元素只能作为挂载点。不同于 Vue 1.x，所有的挂载元素会被 Vue 生成的 DOM 替换。因此不推荐挂载 root 实例到 或者 上。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/22b93fd580a00c700ed9cdf723cdd36c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/076305204d7a73366549bfdfaccdb7f4/" rel="bookmark">
			C语言-矩阵转置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		描述 KiKi有一个矩阵，他想知道转置后的矩阵（将矩阵的行列互换得到的新矩阵称为转置矩阵），请编程帮他解答。
输入描述： 第一行包含两个整数n和m，表示一个矩阵包含n行m列，用空格分隔。 (1≤n≤10,1≤m≤10)
从2到n+1行，每行输入m个整数（范围-231~231-1），用空格分隔，共输入n*m个数，表示第一个矩阵中的元素。
输出描述： 输出m行n列，为矩阵转置后的结果。每个数后面有一个空格。
#include&lt;stdio.h&gt; int main() { int n = 0; int m = 0; scanf_s("%d %d", &amp;n, &amp;m); int arr[10][10] = { 0 }; int i = 0; int j = 0; for (i = 0;i &lt; n;i++) { for (j = 0;j &lt; m;j++) { scanf("%d",&amp;arr[i][j]); } } for (i = 0;i &lt; m;i++) { for (j = 0;j &lt; n;j++) { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/076305204d7a73366549bfdfaccdb7f4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4895190dc14bc49a4517be0f5c9c69d/" rel="bookmark">
			【JS】url传参中文乱码的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、escape 和 unescape escape()不能直接用于URL编码，它的真正作用是返回一个字符的Unicode编码值。
采用unicode字符集对指定的字符串除0-255以外进行编码。所有的空格符、标点符号、特殊字符以及更多有联系非ASCII字符都将被转化成%xx格式的字符编码（xx等于该字符在字符集表里面的编码的16进制数字）。比如，空格符对应的编码是%20。
escape不编码字符有69个：*，+，-，.，/，@，_，0-9，a-z，A-Z。
escape()函数用于js对字符串进行编码，不常用。
//跳转页 location.href = './test.html?'+escape('name=张三&amp;age=18') //接收页 var str = unescape(location.search.substr(1)); //url显示 'test.html?name%3D%u5F20%u4E09%26age%3D18' 注意：使用此方法时，不能对整个url进行编码，仅可对传参进行编码，因为会对 “?”等进行编码，导致路径错误，所以一般不用该方法。
2、encodeURI 和 decodeURI 把URI字符串采用UTF-8编码格式转化成escape各式的字符串。
encodeURI不编码字符有82个：!，#，$，&amp;，'，(，)，*，+，,，-，.，/，:，;，=，?，@，_，~，0-9，a-z，A-Z
encodeURI()用于整个url编码
//跳转页 location.href = encodeURI('./test.html?name=张三&amp;age=18'); //接收页 var str = decodeURI(location.search.substr(1)); //url显示 'test.html?name=张三&amp;age=18' 3、encodeURIComponent 和 decodeURIComponent 与encodeURI()的不同的是，“; / ? : @ &amp; = + $ , #”，这些在encodeURI()中不被编码的符号，在encodeURIComponent()中统统会被编码。至于具体的编码方法，两者是一样。把URI字符串采用UTF-8编码格式转化成escape格式的字符串。
//跳转页 location.href = './test.html?'+encodeURIComponent('name=张三&amp;age=18'); //接收页 var str = decodeURIComponent(location.search.substr(1)); //url显示 'test.html?name%3D张三%26age%3D18' 注意：使用此方法时，不能对整个url进行编码，仅可对传参进行编码，因为会对 “?”等进行编码，导致路径错误，所以一般不用该方法。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8e7aecbfcf78e8e7be85d7c9344f1e3/" rel="bookmark">
			线段树详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 线段树概念2. 线段树的普通形式3. 线段树中的“懒操作”4. 线段树之动态开点 1. 线段树概念 线段树（segment tree）是一种基于分治思想的二叉树，它的每个节点都对应一个[L , R ]区间，叶子节点对应的区间L =R 。每一个非叶子节点[L , R ]其左子节点的区间都为[L , (L +R )/2]，右子节点的区间都为[(L +R )/2+1, R ]。[1, 10]区间的线段树如下图所示
线段树的存储方式：
线段树除了最后一层，其他层构成一颗满二叉树，因此采用顺序存储方式，用一个数组tree[]存储节点。若一个节点的存储下标为k ，则其左子节点的下标为2k ，其右子节点的下标为2k +1
注意：这里使用2k 2k+1作为访问左右孩子，是有空间消耗的，一般而言只有一棵树是完全二叉才可以使用2k 2k+1表示左右孩子，从下图中可以看到，区间[6,6]如果想要被2k进行访问，实际上区间[3,3] [4,4] [5,5]也需要创建相应的空叶子节点
简单来说，如果区间内的元素个数为 2 k 2^k 2k， 则构造出来的线段树是一棵完全二叉树，否则构造出来的树和上图一样，去掉最后一层后才是满二叉树，此时如果还需要利用完全二叉树的性质，就需要把最后一层不存在的叶子节点也创建出来
元素个数 n = 2 k n=2^k n=2k：
第0层 2 0 = 1 2^0=1 20=1
第1层 2 1 = 2 2^1=2 21=2
第2层 2 2 = 4. 2^2=4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d8e7aecbfcf78e8e7be85d7c9344f1e3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77b0dc6924f57d86ee5c21e32b7e9a8b/" rel="bookmark">
			牛客网刷题记录 || 第一番
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🛒本文收录于专栏：【牛客网刷题记录】
📢专栏目的是对于刷题过程的记录，题型的列举和讲解，会持续输出，欢迎免费订阅！！
这是牛客网刷题记录专栏第一篇博文，先给大家简单介绍一下牛客网，牛客网是一个集笔面试系统、题库、课程教育、社群交流、招聘内推于一体的优质网站，牛客网题库中包含几万道题目，注重通过边学边练的模式揽获编程人员的喜爱
牛客网干净整洁的界面，人性化的布局，高质量的题库题解，丰富的大厂面试题，让我想把它分享给大家，推荐大家来牛客网刷题，链接我就放在这了有需要自取👉点击开始刷题
小Tips：注册完之后，不用填信息直接点X，开启刷题之旅~
目录 C语言入门🔥1.复制部分字符串👌描述👌代码👌题解 🔥2.牛牛的排序👌描述👌代码👌题解 C++入门🔥3.输出水仙花数👌描述👌代码👌题解 🔥4.计算小球走过的路程和反弹高度👌描述👌代码👌题解 C语言入门 🔥1.复制部分字符串 👌描述 键盘输入一个长度为len（1 &lt;= len &lt; 30）的字符串，再输入一个正整数 m（1 &lt;= m &lt;= len），将此字符串中从第 m 个字符开始的剩余全部字符复制成为另一个字符串，并将这个新字符串输出。要求用指针处理字符串
输入描述：
键盘输入一个长度为len（1 &lt;= len &lt; 30）的字符串，再输入一个正整数 m（1 &lt;= m &lt;= len）
输出描述：
输出复制的新字符串
示例1：
输入：helloworld 6 输出：world 👌代码 #include &lt;iostream&gt; using namespace std; int main() { char str[30] = { 0 }; cin.getline(str, sizeof(str)); int m; cin &gt;&gt; m; // write your code here...... char *p = NULL; p = &amp;str[m-1]; cout &lt;&lt; p; return 0; } 👌题解 *p 和p[]一个意思，p是一个char数组的首地址，然后把str[m-1]的地址取出来赋值给p，就可以打印出来m-1后的字符串，很nice
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/77b0dc6924f57d86ee5c21e32b7e9a8b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6abfa045ce3623ecd1828f5354447015/" rel="bookmark">
			神经网络是通过类比什么得到的数学模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		人工神经网络的基础数学模型来自哪里 “纯意念控制”人工神经康复机器人系统2014年6月14日在天津大学和天津市人民医院共同举办的发表会上，由双方共同研制的人工神经康复机器人“神工一号”正式亮相。
人工神经网络是由大量处理单元互联组成的非线性、自适应信息处理系统。它是在现代神经科学研究成果的基础上提出的，试图通过模拟大脑神经网络处理、记忆信息的方式进行信息处理。
基本特征：
（1）非线性 非线性关系是自然界的普遍特性。大脑的智慧就是一种非线性现象。人工神经元处于激活或抑制二种不同的状态，这种行为在数学上表现为一种非线性关系。具有阈值的神经元构成的网络具有更好的性能，可以提高容错性和存储容量。
（2）非局限性 一个神经网络通常由多个神经元广泛连接而成。一个系统的整体行为不仅取决于单个神经元的特征，而且可能主要由单元之间的相互作用、相互连接所决定。通过单元之间的大量连接模拟大脑的非局限性。联想记忆是非局限性的典型例子。
（3）非常定性 人工神经网络具有自适应、自组织、自学习能力。神经网络不但处理的信息可以有各种变化，而且在处理信息的同时，非线性动力系统本身也在不断变化。经常采用迭代过程描写动力系统的演化过程。
人工神经网络，人工神经网络是什么意思 一、 人工神经网络的概念。
人工神经网络（Artificial Neural Network，ANN）简称神经网络(NN)，是基于生物学中神经网络的基本原理，在理解和抽象了人脑结构和外界刺激响应机制后，以网络拓扑知识为理论基础，模拟人脑的神经系统对复杂信息的处理机制的一种数学模型。该模型以并行分布的处理能力、高容错性、智能化和自学习等能力为特征，将信息的加工和存储结合在一起，以其独特的知识表示方式和智能化的自适应学习能力，引起各学科领域的关注。它实际上是一个有大量简单元件相互连接而成的复杂网络，具有高度的非线性，能够进行复杂的逻辑操作和非线性关系实现的系统。
神经网络是一种运算模型，由大量的节点（或称神经元）之间相互联接构成。每个节点代表一种特定的输出函数，称为激活函数（activation function）。每两个节点间的连接都代表一个对于通过该连接信号的加权值，称之为权重（weight），神经网络就是通过这种方式来模拟人类的记忆。网络的输出则取决于网络的结构、网络的连接方式、权重和激活函数。而网络自身通常都是对自然界某种算法或者函数的逼近，也可能是对一种逻辑策略的表达。神经网络的构筑理念是受到生物的神经网络运作启发而产生的。人工神经网络则是把对生物神经网络的认识与数学统计模型相结合，借助数学统计工具来实现。另一方面在人工智能学的人工感知领域，我们通过数学统计学的方法，使神经网络能够具备类似于人的决定能力和简单的判断能力，这种方法是对传统逻辑学演算的进一步延伸。
人工神经网络中，神经元处理单元可表示不同的对象，例如特征、字母、概念，或者一些有意义的抽象模式。网络中处理单元的类型分为三类：输入单元、输出单元和隐单元。输入单元接受外部世界的信号与数据；输出单元实现系统处理结果的输出；隐单元是处在输入和输出单元之间，不能由系统外部观察的单元。神经元间的连接权值反映了单元间的连接强度，信息的表示和处理体现在网络处理单元的连接关系中。人工神经网络是一种非程序化、适应性、大脑风格的信息处理，其本质是通过网络的变换和动力学行为得到一种并行分布式的信息处理功能，并在不同程度和层次上模仿人脑神经系统的信息处理功能。
神经网络，是一种应用类似于大脑神经突触连接结构进行信息处理的数学模型，它是在人类对自身大脑组织结合和思维机制的认识理解基础之上模拟出来的，它是根植于神经科学、数学、思维科学、人工智能、统计学、物理学、计算机科学以及工程科学的一门技术。
二、 人工神经网络的发展。
神经网络的发展有悠久的历史。其发展过程大致可以概括为如下4个阶段。
1. 第一阶段----启蒙时期。
(1)、M-P神经网络模型：20世纪40年代，人们就开始了对神经网络的研究。1943 年，美国心理学家麦克洛奇（Mcculloch）和数学家皮兹（Pitts）提出了M-P模型，此模型比较简单，但是意义重大。在模型中，通过把神经元看作个功能逻辑器件来实现算法，从此开创了神经网络模型的理论研究。
(2)、Hebb规则：1949 年，心理学家赫布（Hebb）出版了《The Organization of Behavior》（行为组织学），他在书中提出了突触连接强度可变的假设。这个假设认为学习过程最终发生在神经元之间的突触部位，突触的连接强度随之突触前后神经元的活动而变化。这一假设发展成为后来神经网络中非常著名的Hebb规则。这一法则告诉人们，神经元之间突触的联系强度是可变的，这种可变性是学习和记忆的基础。Hebb法则为构造有学习功能的神经网络模型奠定了基础。
(3)、感知器模型：1957 年，罗森勃拉特（Rosenblatt）以M-P 模型为基础，提出了感知器（Perceptron）模型。感知器模型具有现代神经网络的基本原则，并且它的结构非常符合神经生理学。这是一个具有连续可调权值矢量的MP神经网络模型，经过训练可以达到对一定的输入矢量模式进行分类和识别的目的，它虽然比较简单，却是第一个真正意义上的神经网络。Rosenblatt 证明了两层感知器能够对输入进行分类，他还提出了带隐层处理元件的三层感知器这一重要的研究方向。Rosenblatt 的神经网络模型包含了一些现代神经计算机的基本原理，从而形成神经网络方法和技术的重大突破。
(4)、ADALINE网络模型： 1959年，美国著名工程师威德罗（B.Widrow）和霍夫（M.Hoff）等人提出了自适应线性元件(Adaptive linear element，简称Adaline)和Widrow-Hoff学习规则（又称最小均方差算法或称δ规则）的神经网络训练方法，并将其应用于实际工程，成为第一个用于解决实际问题的人工神经网络，促进了神经网络的研究应用和发展。ADALINE网络模型是一种连续取值的自适应线性神经元网络模型，可以用于自适应系统。
2. 第二阶段----低潮时期。
人工智能的创始人之一Minsky和Papert对以感知器为代表的网络系统的功能及局限性从数学上做了深入研究，于1969年发表了轰动一时《Perceptrons》一书，指出简单的线性感知器的功能是有限的，它无法解决线性不可分的两类样本的分类问题，如简单的线性感知器不可能实现“异或”的逻辑关系等。这一论断给当时人工神经元网络的研究带来沉重的打击。开始了神经网络发展史上长达10年的低潮期。
(1)、自组织神经网络SOM模型：1972年，芬兰的KohonenT.教授，提出了自组织神经网络SOM(Self-Organizing feature map)。后来的神经网络主要是根据KohonenT.的工作来实现的。SOM网络是一类无导师学习网络，主要用于模式识别﹑语音识别及分类问题。它采用一种“胜者为王”的竞争学习算法，与先前提出的感知器有很大的不同，同时它的学习训练方式是无指导训练，是一种自组织网络。这种学习训练方式往往是在不知道有哪些分类类型存在时，用作提取分类信息的一种训练。
(2)、自适应共振理论ART：1976年，美国Grossberg教授提出了著名的自适应共振理论ART(Adaptive Resonance Theory)，其学习过程具有自组织和自稳定的特征。
3. 第三阶段----复兴时期。
(1)、Hopfield模型：1982年，美国物理学家霍普菲尔德（Hopfield）提出了一种离散神经网络，即离散Hopfield网络，从而有力地推动了神经网络的研究。在网络中，它首次将李雅普诺夫（Lyapunov）函数引入其中，后来的研究学者也将Lyapunov函数称为能量函数。证明了网络的稳定性。1984年，Hopfield 又提出了一种连续神经网络，将网络中神经元的激活函数由离散型改为连续型。1985 年，Hopfield和Tank利用Hopfield神经网络解决了著名的旅行推销商问题（Travelling Salesman Problem）。Hopfield神经网络是一组非线性微分方程。Hopfield的模型不仅对人工神经网络信息存储和提取功能进行了非线性数学概括，提出了动力方程和学习方程，还对网络算法提供了重要公式和参数，使人工神经网络的构造和学习有了理论指导，在Hopfield模型的影响下，大量学者又激发起研究神经网络的热情，积极投身于这一学术领域中。因为Hopfield 神经网络在众多方面具有巨大潜力，所以人们对神经网络的研究十分地重视，更多的人开始了研究神经网络，极大地推动了神经网络的发展。
(2)、Boltzmann机模型：1983年，Kirkpatrick等人认识到模拟退火算法可用于NP完全组合优化问题的求解，这种模拟高温物体退火过程来找寻全局最优解的方法最早由Metropli等人1953年提出的。1984年，Hinton与年轻学者Sejnowski等合作提出了大规模并行网络学习机，并明确提出隐单元的概念，这种学习机后来被称为Boltzmann机。
Hinton和Sejnowsky利用统计物理学的感念和方法，首次提出的多层网络的学习算法，称为Boltzmann 机模型。
(3)、BP神经网络模型：1986年，儒默哈特（D.E.Ru melhart）等人在多层神经网络模型的基础上，提出了多层神经网络权值修正的反向传播学习算法----BP算法（Error Back-Propagation），解决了多层前向神经网络的学习问题，证明了多层神经网络具有很强的学习能力，它可以完成许多学习任务，解决许多实际问题。
(4)、并行分布处理理论：1986年，由Rumelhart和McCkekkand主编的《Parallel Distributed Processing：Exploration in the Microstructures of Cognition》，该书中，他们建立了并行分布处理理论，主要致力于认知的微观研究，同时对具有非线性连续转移函数的多层前馈网络的误差反向传播算法即BP算法进行了详尽的分析，解决了长期以来没有权值调整有效算法的难题。可以求解感知机所不能解决的问题，回答了《Perceptrons》一书中关于神经网络局限性的问题，从实践上证实了人工神经网络有很强的运算能力。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6abfa045ce3623ecd1828f5354447015/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/52c61dfea61d574e780895a28223055f/" rel="bookmark">
			perf进阶-event实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		perf进阶event实践 先导 perf list可以看当前软硬件环境支持的性能事件，由于性能事件过多，当程序运行异常或耗时过长时，往往不清楚查找哪一种事件。下面给出一种选择性能事件的方案：
perf list List of pre-defined events (to be used in -e): branch-misses [Hardware event] bus-cycles [Hardware event] cache-misses [Hardware event] cache-references [Hardware event] cpu-cycles OR cycles [Hardware event] instructions [Hardware event] stalled-cycles-backend OR idle-cycles-backend [Hardware event] stalled-cycles-frontend OR idle-cycles-frontend [Hardware event] alignment-faults [Software event] bpf-output [Software event] context-switches OR cs [Software event] cpu-clock [Software event] cpu-migrations OR migrations [Software event] dummy [Software event] emulation-faults [Software event] major-faults [Software event] minor-faults [Software event] page-faults OR faults [Software event] task-clock [Software event] duration_time [Tool event] L1-dcache-load-misses [Hardware cache event] 示例程序 #include&lt;iostream&gt; #include&lt;cmath&gt; #include&lt;vector&gt; #include&lt;cstdlib&gt; #include&lt;omp.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/52c61dfea61d574e780895a28223055f/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/144/">«</a>
	<span class="pagination__item pagination__item--current">145/321</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/146/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>