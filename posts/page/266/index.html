<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a06251821a0a60ee8fc91aac1ff580c/" rel="bookmark">
			testng&#43;maven&#43;selenium之爬坑记录 - testng.xml is not a valid file和unable to find valid certification path。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题：楼主选择的自动化测试组合是Java+testng+maven+selenium，遇到的坑是
testng.xml is not a valid file和unable to find valid certification path to requested target，
解决方案：1、testng.xml is not a valid file的原因是pom文件中testng.xml的路径不对，修改其路径为你自己的文件所在位置即可
2、unable to find valid certification path to requested target的原因是testng.xml文件中开头是
正确的应该是http，即
这是问题解决后的正确配置供参考
pom文件：
testng.xml文件：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f75b06383ad0de9aad3a23b86606defb/" rel="bookmark">
			输入一行字符，以回车符作为输入结束的标志。统计其中英文字母、数字字符和其他字符的个数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		/思路：用他们的ASCII码进行判断/
#include&lt;stdio.h&gt;
#include&lt;ctype.h&gt;
int main()
{
char num;
int i ;
int count = 0;//统计数字字符的
int j = 0;//统计小写英文字母
int k = 0;//统计大写英文字母
int l = 0;//其他字符
for(i = 0; ;i ++)
{
num = getchar();
if(isdigit(num))//判断是否为数字字符
{
count ++;
}
else if(num &gt;= 65 &amp;&amp; num &lt;= 90)
{
k ++;
}
else if(num &gt;= 97 &amp;&amp; num &lt;= 122)
{
j ++;
}
else { l ++; } if(num == '\n') break; } printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f75b06383ad0de9aad3a23b86606defb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2cba5ad4750f4af34a9a624bef4799e8/" rel="bookmark">
			学习java之利用泛型访问自己定义的类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果有多个类，而且他们其中有一些方法是相同的，我是选择在每个类中都把这些方法实现一遍呢，还是选择泛型。我今天自己花了一点时间看了看泛型，实践了一下。
Holder.java
package regexp; import java.util.Collection; import java.util.Iterator; import java.util.Set; public class Holder&lt;T&gt; { private T a; public Holder(T a) { this.a = a;} public void set(T a) { this.a = a;} public T get() { return a;} public static void main(String[] args) { Holder&lt;A&gt; h1 = new Holder&lt;A&gt;(new A()); A a = h1.get(); a.id = a.score = 1; Holder&lt;B&gt; h2 = new Holder&lt;B&gt;(new B()); B b = h2.get(); b.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2cba5ad4750f4af34a9a624bef4799e8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d138190e687b1fbb8ce8122285e003f0/" rel="bookmark">
			iOS   左右滑动  手势   响应方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. @property (nonatomic, strong) UISwipeGestureRecognizer *leftSwipeGestureRecognizer;
@property (nonatomic, strong) UISwipeGestureRecognizer *rightSwipeGestureRecognizer;
2. @synthesize leftSwipeGestureRecognizer,rightSwipeGestureRecognizer;
3. 在视图控制器里加载这两个手势
self.leftSwipeGestureRecognizer = [[UISwipeGestureRecognizer alloc] initWithTarget:self action:@selector(handleSwipes:)];
self.rightSwipeGestureRecognizer = [[UISwipeGestureRecognizer alloc] initWithTarget:self action:@selector(handleSwipes:)];
self.leftSwipeGestureRecognizer.direction = UISwipeGestureRecognizerDirectionLeft;
self.rightSwipeGestureRecognizer.direction = UISwipeGestureRecognizerDirectionRight;
[self.viewaddGestureRecognizer:self.leftSwipeGestureRecognizer]; [self.viewaddGestureRecognizer:self.rightSwipeGestureRecognizer];
4. - (void)handleSwipes:(UISwipeGestureRecognizer *)sender
{
if (sender.direction == UISwipeGestureRecognizerDirectionLeft) {
//添加要响应的方法
}
if (sender.direction == UISwipeGestureRecognizerDirectionRight) {
//添加要响应的方法
}
}
转载于:https://www.cnblogs.com/someonelikeyou/p/3512268.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bcbb4b296234921f582ef336cadd89b6/" rel="bookmark">
			IOS  长姿势---双击Home键
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这不值得大惊小怪，因为按两次Home键后，苹果只是简单第提供了一个历史任务列表，而不是人们以为的当前任务列表——这在苹果网站上已经说得很清楚了。至于为什么苹果没有能力为用户提供一个“任务管理器”，我们不得而知。不过有人认为，在多任务中使用挂起代替退出，将减少程序再次启动的时间，节省电量的消耗。
转载于:https://www.cnblogs.com/someonelikeyou/p/4153272.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e84bfe8522ef6c1efe6eabcd3e1443e/" rel="bookmark">
			CRP实施方法论
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		几个问题什么是CRP？它是一种技术还是一种方法论？如果它是一种方法论，它与AIM有什么关系或区别？-HAND 也有相应的一套文档，CRP的相关文档在哪里？如果它是一种方法论，它的生命还有多久，换句话说，它在多长时间内可以被继续使用，而不会被新的方法论所取代？Y如果它还有相当长的生命周期，我们能否从哪里得到它的这套知识体系，或者，找不到的话，我们自己整理一套，值得吗？
名词解释下面关于CRP的名词解释，摘自ORACLE AIM 3.0 的用户手册 A75149-01的第G-10页：Conference Room Pilot (CRP): A system test in an environment set up to simulate the future production environment.在ORACLE AIM 3.0 的用户手册 A75150-01的第3-89页，对CRP进行了更为详细的描述：You can perform testing of business alternatives in a formal conference room pilot (CRP) or use a more informal approach as a follow-on to mapping activities. In either case, you must test around any identified functionality gaps because it is likely that no final alternative has been designed or built to bridge those gaps.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7e84bfe8522ef6c1efe6eabcd3e1443e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/353abfb49d2e19af2aa80ea42d268adf/" rel="bookmark">
			AODV协议概述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AODV是由Nokia研究中心的Charles E.Perkins和加利福尼亚大学Santa Barbara的Elizabeth M.Belding-Roryer以及Cincinnati大学Samir R.Das等共同开发，已经被 IETF MANET工作组于2003年7月正式公布为自组网路由协议的RFc标准。
AODV实质上就是DSR和DSDV的综合，它借用了DSR中路由发现和路由维护的基础程序，及DSDV的逐跳(Hop-by-HoP)路由、目的节点序列号和路由维护阶段的周期更新机制，以DSDV为基础，结合DSR中的按需路由思想并加以改进。
AODV在每个中间节点隐式保存了路由请求和应答的结果，并利用扩展环搜索的办法来限制搜索发现过的目的节点的范围。AODV支持组播功能，支持Qos，而且AODV中可以使用IP地址，实现同Internet连接，但是不支持单向信道。和DSDV保存完整的路由表不同的是，AODV通过建立基于按需路由来减少路由广播的次数，这是AODV对DSDV的重要改进。和DSR相比，AODV的好处在于源路由并不需要包括在每一个数据分组中，这样会使路由协议的开销有所降低。AODV是一个纯粹的按需路由系统，那些不在路径内的节点不保存路由信息，也不参与路由表的交换。AODv协议可以实现在移动终端间动态的、自发的路由，使移动终端很快获得通向所需目的的路由，同时又不用维护当前没有使用的路由信息，并且还能很快对断链的拓扑变化做出反应。AODV的操作是无环路的，在避免了通常Bellman-ford算法的无穷计数问题的同时，还提供了很快的收敛速度。AODv的路由表中每个项都使用了目的序列号(Destination Sequence Number)。目的序列号是目的节点创建，并在发给发起节点的路由信息中使用的。使用目的序列号可以避免环路的发生。
AODV 使用 3 种消息作为控制信息 :RouteRequest(RREQ) ， RouteReply(RREP) 和 RouteError(RERR) 。这些消息都在 UDP 上使用 654 端口号。 当源节点需要和目的节点通信时，如果在路由表中已经存在了对应的路由时， AODV 不会进行任何操作。当源节点需要和新的目的通信时，它就会发起路由发现过程，通过广播 RREQ 信息来查找相应路由。当这个 RREQ 到达目的节点本身，或者是一个拥有足够新的到目的节点路由的中间节点时，路由就可以确定了。所谓 “ 足够新 ” 就是通过目的序列号来判断的。目的节点或中间节点通过原路返回一个 RREP 信息来向源节点确定路由的可用性。在维护路由表的过程中，当路由不再被使用时，节点就会从路由表中删除相应的项。同时，节点会监视一个活动路由 (activeroute ，有限跳的，可用于数据转发的路由表 ) 中，下一跳节点的状况。当发现有链路断开的情况时，节点就会使用 RERR 通知上游的节点，而上游的节点就会使用该 RERR 分组拷贝通知更上游的节点。在 RERR 消息中，指明了由于断链而导致无法达到目的节点。每个节点都保留了一个 “ 前驱列表 ”(precursor list) 来帮助完成错误报告的功能，这个列表中保存了把自己作为到当前不可达节点的下一跳的相邻节点 ( 可以通过记录 RERR 很容易地获得 ) 。在路由表中，针对每一个表项，需要记录相应的的特征内容。其中，序列号是防止路由环路的关键所在。当发生断链时，通过增加序列号 和度量值 ( 跳数 ) 来使路由表项无效。 ②AODV路由协议的运行方式 (a)AODV 路由发现 AODV 路由协议是一种典型的按需驱动路由协议，该算法可被称为纯粹的需求路由获取系统，那些不在活跃路径上的节点不会维持任何相关路由信息，也不会参与任何周期路由表的交换。此外，节点没有必要去发现和维持到另一节点的路由，除非这两个节点需要进行通信。移动节点间的局部连接性可以通过几种方法得到，其中包括使用局部广播 Hello 消息。这种算法的主要目的是 : 在需要时广播路由发现分组一般的拓扑维护 ; 区别局部连接管理 ( 邻居检测 ) 和一般的拓扑维护 ; 向需要连接信息的邻居移动节点散播拓扑变化信息。 AODV 使用广播路由发现机制，它依赖中间节点动态建立路由表来进行分组的传送。为了维持节点间的最新路由信息， AODV 借鉴了 DSDV 中的序列号的思想，利用这种机制就能有效地防止路由环的形成。当源节点想与另外一个节点通信，而它的路由表中又没有相应的路由信息时，它就会发起路由发现过程。每一个节点维持两个独立的计数器 : 节点序列号计数器和广播标识。源节点通过向自己的邻居广播 RREQ(Route Requests) 分组来发起一次路由发现过程。 (b) 反向路由的建立 在 RREQ 分组中包含了两个序列号 : 源节点序列号和源节点所知道的最新的目的序列号。源节点序列号用于维持到源的反向路由的特性，目的序列号表明了到目的地的最新路由。当 RREQ 分组从一个源节点转发到不同的目的地时，沿途所经过的节点都要自动建立到源节点的反向路由。节点通过记录收到的第一个 RREQ 分组的邻居地址来建立反向路由，这些反向路由将会维持一定时间，一该段时间足够 RREQ 分组在网内转发以及产生的 RREP 分组返回源节点。当 RREQ 分组到达了目的节点，目的节点就会产生 RREP 分组，并利用建立的反向路由来转发 RREP 。 (c) 正向路由的建立 RREQ 分组最终将到达一个节点，该节点可能就是目的节点，或者这个节点有到达目的节点的路由。如果这个中间节点有到达目的的路由项，它就会比较路由项里的目的序列号和 RREQ 分组里的目的序列号的大小来判断自己已有的路由是否是比较新的。如果 RREQ 分组里的目的序列号比路由项中的序列号大，则这个中间节点不能使用己有的路由来响应这个 RREQ 分组，只能是继续广播这个 RREQ 分组。中间节点只有在路由项中的目的序列号不小于 RREQ 中的目的序列号时，才能直接对收到的 RREQ 分组做出响应。如果节点有到目的地的最新路由，而且这个 RREQ 还没有被处理过，这个节点将会沿着建立的反向路由返回 RREP 分组。 在 RREP 转发回源节点的过程中，沿着这条路径上的每一个 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/353abfb49d2e19af2aa80ea42d268adf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b817e7657c85c40dddeb42720584de53/" rel="bookmark">
			Word Ladder
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Given two words (beginWord and endWord), and a dictionary's word list, find the length of shortest transformation sequence from beginWord to endWord, such that:
Only one letter can be changed at a timeEach intermediate word must exist in the word list For example,
Given:
beginWord = "hit"
endWord = "cog"
wordList = ["hot","dot","dog","lot","log"]
As one shortest transformation is "hit" -&gt; "hot" -&gt; "dot" -&gt; "dog" -&gt; "cog",
return its length 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b817e7657c85c40dddeb42720584de53/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/192288a4aba9f6ddafe72eba38d0c969/" rel="bookmark">
			Container With Most Water
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Given n non-negative integers a1, a2, ..., an, where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.
Note: You may not slant the container.
这道题给出了一个序列，要求找出两根线使其和x轴之间的存储的水最多。注意这里最终盛多少水，不需要考虑中间的最低值，只需要考虑两边的边界。
leetcode给出的提示是用two pointer来做，two pointer做了几题，基本是O(n)复杂度，使用贪心策略。
具体采用何种贪心策略，我也做了好几次选择，最终的选择如下：
1.给出l = 0, r = n-1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/192288a4aba9f6ddafe72eba38d0c969/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25764b56cb49024cb30afaac84586dc8/" rel="bookmark">
			Longest Substring Without Repeating Characters
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题意为给出一个字符串，找出其中没有重复字符的最长子序列的长度。brute force的复杂度为O(n^3).依次查找每个子字符串是否含有重复字符，并比较长度。开始看到题目，想用DP解决，在已有目前最长子序列的情况下，比较把当前字符串放入和不放入，哪个子序列长度会更大，但是这种解法的复杂度为O(n^2),也不理想。
一种比较好的解法是贪心策略，维护一个变量maxlen保存目前已有的不重复子序列的最大长度。维护一个sliding window,left为左起点，right为右端点。同时维护一个map,保存窗口中的&lt;char,index&gt;键值对。每次右端点向右移动一格，如果 s[right］不在map中，则窗口中的字符串长度加1，否则说明窗口中已经有和s[right]的重复的元素，要更新left的值，left的值为重复元素的后一个值，此时也要删去重复元素之前的在窗口中的值，对map做更新，这种思路的代码如下：
class Solution(object): def lengthOfLongestSubstring(self, s): """ :type s: str :rtype: int """ length = len(s) left＝maxlen = 0 map = {} for right in xrange(length): if map.has_key(s[right]): index = map[s[right]] for i in xrange(left,index+1): map.pop(s[i]) left = index+1 else: maxlen = max(maxlen,right-left+1) map[s[right]] = right return maxlen 此种解法，虽然left和right都扫了一遍，但是存在多次删map元素的过程，复杂度不能保证为O(n)。一种更优的解法，不删map元素，在取index的时候，同时判断index比不比left大，即在不在窗口中，再采取操作，代码如下：
class Solution(object): def lengthOfLongestSubstring(self, s): """ :type s: str :rtype: int """ length = len(s) maxlen = left = 0 map = {} for right in xrange(length): if map.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/25764b56cb49024cb30afaac84586dc8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0ae1e6d2579daa8de6c4dc178f1e8ed/" rel="bookmark">
			Inorder Successor in BST
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Given a binary search tree and a node in it, find the in-order successor of that node in the BST.
Note: If the given node has no in-order successor in the tree, return null.
要求返回给定二叉搜索树BST的中的一个节点.要求求该节点的后继节点.
BST的特点是: 左节点的值小于等于父节点, 右节点的值大于等于父节点.所以可以利用这个属性来进行搜索.具体方案和算法导论给出的在BST中找特定节点的流程是一样的.
但是需要注意的是因为求的是后续节点.我们实际要求的是比给定节点值大的最小节点.所以每个比给定节点值大的点都可能是.但是我们需要不断缩小搜索范围. 使找到的下一个比节点值大的点的值比之前的candidate要小.
给出这种解法的代码,平均时间复杂度为O(h), h为高度.空间复杂度为O(1).
# Definition for a binary tree node. # class TreeNode(object): # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution(object): def inorderSuccessor(self, root, p): "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e0ae1e6d2579daa8de6c4dc178f1e8ed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/877900cba23ba07da761682206bf1d37/" rel="bookmark">
			Sybase数据库在UNIX和Windows上的实施和管理 内容简介和目录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		继《oracle大型数据库系统在AIX/unix上的实战详解 》出版后，这是我写的另外一本关于大型数据库的技术书籍——SYBASE。Sybase ASE是当前业界著名的大型数据库之一，国内用户群体广泛，国际更是声名不菲。写这本书一是能为大家做点事情，二是挑战自我，自己知识总结一下。
这本书的目录安排如下： 第一篇 系统架构 第1章 认识你的服务器 20 1.1 Sybase ASE时代背景 20 1.2 ASE是关系型数据库 21 1.3 Sybase ASE体系结构 25 1.3.1 ASE的产品构成 25 1.3.2 ASE的内部结构 29 1.3.3 ASE系统版本 39 1.3.4 ASE中的各种数据库 41 1.3.5 ASE选装数据库 44 第2章 Sybase ASE系统构建 46 2.1 Sybase ASE系统的组成 46 2.2 Sybase ASE服务器端构建 49 2.2.1 ASE的安装版本 49 2.2.2 ASE的安装步骤 49 2.2.3 准备安装环境 50 2.3 在UNIX平台上安装ASE 53 2.3.1 ASE For UNIX一般安装过程 53 2.3.2 ASE 12.5/15.0 For AIX安装细节 54 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/877900cba23ba07da761682206bf1d37/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/261573abcda5458969409ebf259807b8/" rel="bookmark">
			解决ubuntu中vi不能正常使用方向键与退格键的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方案一：
问题：
ubuntu中vi在编辑状态下方向键不能用，还有回格键不能删除等我们平时习惯的一些键都不能使用。
解决办法：
可以安装vim full版本，在full版本下键盘正常，安装好后同样使用vi命令。
安装vim：
ubuntu预装的是vim tiny版本，而需要的是vim full版本。执行下面的语句安装vim full版本：
$sudo apt-get remove vim-common
$sudo apt-get install vim
这样就行了，vim是一款优秀的软件，可以在运用中体会到。
方案二：
在vi命令行使用命令“：set nocompatible”，就是设置vi不使用兼容模式。
ubuntu11.10下的VI命令： vi 有三种模式，输入模式，编辑模式，“：”命令模式 vi 进入以后默认是编辑模式 vi 编辑模式默认的快捷键 上下左右分别是 J K H L vi 在编辑模式使用 i 可以进入输入模式 vi 输入模式只能输入英文，默认不能使用上下左右箭头 vi 输入模式用Esc可以返回到编辑模式 vi 编辑模式 Shift + ; 可以进入命令模式 vi 命令模式w保存，q退出 1）对所有用户都有效,解决系统中所用用户的vi中文乱码问题
sudo gedit /etc/vim/vimrc.tiny
加入如下内容：
#该文件的内容显示如下：
" Encoding related
set encoding=UTF-8
set langmenu=zh_CN.UTF-8
language message zh_CN.UTF-8
set fileencodings=ucs-bom,utf-8,cp936,gb18030,big5,euc-jp,euc-kr,latin1
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/261573abcda5458969409ebf259807b8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35a3a848c054168ca21342b32aff6c90/" rel="bookmark">
			C&#43;&#43;的cout高阶格式化操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这篇文章主要讲解如何在C++中使用cout进行高级的格式化输出操作，包括数字的各种计数法（精度）输出，左或右对齐，大小写等等。通过本文，您可以完全脱离scanf/printf，仅使用cout来完成一切需要的格式化输入输出功能（从非性能的角度而言）。更进一步而言，您还可以在&lt;sstream&gt;、&lt;fstream&gt;上使用这些格式化操作，从而代替sprintf和fprintf函数。为方便描述，下文仅以cout为例进行介绍。
一、综述 cout是STL库提供的一个iostream实例，拥有ios_base基类的全部函数和成员数据。进行格式化操作可以直接利用setf/unsetf函数和flags函数。cout维护一个当前的格式状态，setf/unsetf函数是在当前的格式状态上追加或删除指定的格式，而flags则是将当前格式状态全部替换为指定的格式。cout为这个函数提供了如下参数（可选格式）：
ios::dec 以10进制表示整数 ios::hex 以16进制表示整数 ios::oct 以8进制表示整数 ios::showbase 为整数添加一个表示其进制的前缀 ios::internal 在符号位和数值的中间插入需要数量的填充字符以使串两端对齐 ios::left 在串的末尾插入填充字符以使串居左对齐 ios::right 在串的前面插入填充字符以使串居右对齐 ios::boolalpha 将bool类型的值以true或flase表示，而不是1或0 ios::fixed 将符点数按照普通定点格式处理（非科学计数法） ios::scientific 将符点数按照科学计数法处理（带指数域） ios::showpoint 在浮点数表示的小数中强制插入小数点（默认情况是浮点数表示的整数不显示小数点） ios::showpos 强制在正数前添加+号 ios::skipws 忽略前导的空格（主要用于输入流，如cin） ios::unitbuf 在插入（每次输出）操作后清空缓存 ios::uppercase 强制大写字母 以上每一种格式都占用独立的一位，因此可以用“|”（位或）运算符组合使用。调用setf/unsetf或flags设置格式一般按如下方式进行：
? 1 2 cout.setf(ios::right | ios::hex); //设置16进制右对齐 cout.setf(ios::right, ios::adjustfield); //取消其它对齐，设置为右对齐 setf可接受一个或两个参数，一个参数的版本为设置指定的格式，两个参数的版本中，后一个参数指定了删除的格式。三个已定义的组合格式为：
ios::adjustfield 对齐格式的组合位 ios::basefield 进制的组合位 ios::floatfield 浮点表示方式的组合位 设置格式之后，下面所有使用cout进行的输出都会按照指定的格式状态执行。但是如果在一次输出过程中需要混杂多种格式，使用cout的成员函数来处理就显得很不方便了。STL另提供了一套&lt;iomanip&gt;库可以满足这种使用方式。&lt;iomanip&gt;库中将每一种格式的设置和删除都进行了函数级的同名封装，比如fixed函数，就可以将一个ostream的对象作为参数，在内部调用setf函数对其设置ios::fixed格式后再返回原对象。此外&lt;iomanip&gt;还提供了setiosflags、setbase、setfill、setw、setprecision等方便的格式控制函数，下文会逐一进行介绍。大多数示例代码都会使用到&lt;iomanip&gt;，因此默认包含的头文件均为：
? 1 2 #include &lt;iomanip&gt; #include &lt;iostream&gt; 二、缩进 将输出内容按指定的宽度对齐，需要用到ios::right、ios::left、ios::internal和iomanip里的setw。其中setw用于指定要输出内容的对齐宽度。以下两段代码的结果完全相同，前面是一个浮点数-456.98，后面紧跟着一个字符串“The End”以及换行符“endl”。
代码一：
? 1 2 3 4 5 6 7 8 9 10 11 12 #include &lt;iomanip&gt; #include &lt;iostream&gt; using namespace std; int main( void ) { cout.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/35a3a848c054168ca21342b32aff6c90/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7cc07cff0d0ad49df1b6eac5b473c7b2/" rel="bookmark">
			Cuckoo架构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		cuckoo在部署阶段，只在Guest系统里塞了一个agent，这个agent在运行阶段负责与Host端程序进行通信，从Host端接收sample, 整个客户端程序，以及配置文件。
在Host端主要的源文件为：
./lib/cuckoo/core/scheduler.py class AnalysisManager(Thread): def acquire_machine(self): // 获得虚拟机 def build_options(self): //生成.conf配置文件 def launch_analysis(self): //启动分析过程 def process_results(self): //生成分析结果报告 launch_analysis会调用：
agent/agent.py def add_malware(self, data, name): def add_config(self, options): def add_analyzer(self, data): def execute(self): 执行analyser.py，由Host上传到Guest上的分析程序包含如下结构：
. └── windows ├── analyzer.py ├── bin │ └── execsc.exe ├── dll │ ├── cuckoomon_bson.dll │ ├── cuckoomon.dll │ └── cuckoomon_netlog.dll ├── lib │ ├── api │ │ ├── __init__.py │ │ ├── process.py │ │ └── screenshot.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7cc07cff0d0ad49df1b6eac5b473c7b2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6a223b199833d6cfcebefdb5bed8139/" rel="bookmark">
			GDI及Windows的消息机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是GDI？ GDI, Graphics Device Interface
GDI在以下位置已经被微软列为Legacy Graphics，不建议使用来开发应用程序（http://msdn.microsoft.com/zh-CN/library/windows/desktop/hh309470(v=vs.85).aspx）。
但是这里我们需要了解的是GDI的原理，比如为什么能够用它来做出透明的效果。
（事实上这个问题的答案是LayeredWindow是怎么工作的）
GDI就一系列的Windows API函数的集合，负责代表用户程序来进行图像图形的操作。
GDI+：
Windows GDI+ is a class-based API for C/C++ programmers.
Other topic(Windows消息机制：http://msdn.microsoft.com/zh-CN/library/windows/desktop/ff381405(v=vs.85).aspx)
To pass a message to a window, the operating system calls the window procedure registered for that window. (And now you know what the window procedure is for.)
一个窗口程序，需要对外界发生的事件进行一定的响应，比如：
用户按下了某个键 系统的状态发生了改变，应用程序必须做相应的反馈（笔记本电池电量低） 这是通过消息机制完成的。
向一个窗口发送消息，是通过调用那个窗口注册到Windows操作系统的窗口过程函数(Windows Procedure Function)来完成的。
For each thread that creates a window, the operating system creates a queue for window messages.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c6a223b199833d6cfcebefdb5bed8139/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49692ad7b45a84a5e091c34ac24f98f7/" rel="bookmark">
			cssRules为null的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通过link的方式加载css文件，从本地直接打开页面时cssRules为null，可通过import方式引入css解决这个问题
转载于:https://www.cnblogs.com/moonbear/archive/2012/11/17/2775178.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e435672543fdfb9da7f0465332d7907/" rel="bookmark">
			Windows 8 Metro Stype App 学习笔记（五）--文件操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Windows 8 Metro Style App中文件操作都包含在Windows.Storage命名空间中，其中包括StorageFolder,StorageFile,FileIO等类库。
文件对象用StorageFile实现，文件头用StorageFolder实现，下面看下具体的用法及各类库下的属性他方法。
创建文件
? StorageFolder storageFolder=KnownFolders.DocumentsLibrary; StorageFile storageFile=await storageFolder.CreateFileAsync( "sample.txt" ,CreationCollisionOption.ReplaceExisting); KnownFolders提供了系统中常规的文件路径。
CreationCollisionOption提供了创建文件冲突时的操作选项。
FileIO对象负责文件的读/写操作
读取文件
? string fielContent=await FileIO.ReadTextAsync(storageFile); 读取操作包含三种方式：
返回普通文本 ReadTextAsync(storageFile)/ReadTextAsync(storageFile,UnicodeEncoding)(返回指定的文本编码格式)
返回流 ReadBufferAsync(storageFile)
? IBuffer buffer = await FileIO.ReadBufferAsync(storageFile); using (DataReader dataReader = DataReader.FromBuffer(buffer)) { string fileContent = dataReader.ReadString (buffer.Length); } ? 还可通过流读取文件内容 ? using (IRandomAccessStream readStream = await sampleFile.OpenAsync(FileAccessMode.Read)) { using (DataReader dataReader = new DataReader(readStream)) { uint numBytesLoaded = await dataReader.LoadAsync(( uint )readStream.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e435672543fdfb9da7f0465332d7907/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b206c64effc3963d2165965d11ff98a/" rel="bookmark">
			超出长度用...显示的样式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		word-break:keep-all;
white-space:nowrap;
overflow:hidden;
text-overflow:ellipsis;
white-space:nowrap;
转载于:https://www.cnblogs.com/hdjjun/archive/2008/06/17/1223725.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55eaefd395dc2919f01e6ce653e460bd/" rel="bookmark">
			freebsd 在 singel user mode 下强制设置root密码的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在singel user mode下
mount -u /
mount -a
passwd 然后输入密码就可以了。
如果出现让整理硬盘的提示，就整理下硬盘。
转载于:https://www.cnblogs.com/kungfupanda/archive/2010/12/08/1900516.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c17d633c4116aa9c0dac4ea49daa1cf/" rel="bookmark">
			seattle language school &amp; on-line degree
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		http://www.kaplaninternational.com/
https://asuonline.asu.edu/online-degree-programs/
https://asuonline.asu.edu/online-degree-programs/graduate/master-science-engineering-engineering-science-concentration-software
http://www.accreditedonlinecolleges.org/masters-degree/
http://www.mastersdegreeonlineguide.com/
--------------
English Schools in Sammamish, Washington
http://open-site.org/schools/washington-state/english/sammamish/
转载于:https://www.cnblogs.com/kungfupanda/p/4849429.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ca38f9189e98121332779ca67f8a9ba/" rel="bookmark">
			中国科学院大学工程管理与信息技术学院  2014年招收以下八个领域在职工程硕...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		中国科学院大学工程管理与信息技术学院2014年招收以下八个领域在职工程硕士，欢迎广大考生报考。 一、专业领域介绍 招生领域 研究方向 学费 报考条件 学位/证书 学习方式 项目管理 工程管理 IT项目管理 金融管理 大数据项目管理 4.3万 2011年7月31日前获得学士学位或2010年7月31日前获得国民教育序列大学本科毕业证书的在职工程技术或工程管理人员，或从事工程技术与工程管理教学的教师。 1.国务院学位办批准授予的工程硕士学位证书 2.高级职业资格证书/相应领域国际认证证书。 针对北京及周边地区学员，主要利用周末时间上课； 针对外地学生，采用远程与集中面授相结合的方式（集团班）。 软件工程 软件系统分析与设计 软件项目管理 软件测试与质量保证 金融信息工程（ 金融创新） 4万 应届和往届本科毕业生均可报考，专业不限。 电子与通信工程 移动通信与多媒体通信 物联网技术及应用 智能终端与移动安全 图像处理与计算机视觉 集成电路设计 物联网系统（无锡） 3.7万 计算机技术 智能信息系统 大数据技术与应用 计算机安全技术 嵌入式软件 计算机图形学与应用 云计算 控制工程 物联网软件（无锡） 3.7万 注：若国家报考政策有变化，以国家政策规定为准。 二、报考流程 1、预报名：考生登录工程管理与信息技术学院网站，点击“ 网上预报名”，提交个人信息。 2、正式报名：考生请于6月20日--7月10日，登录“中国学位与研究生教育信息网（ www.chinadegrees.cn）”，进行网上正式报名。 3、现场确认：网上报名后，考生应持二代居民身份证于7月11--14日，到各省级学位与研究生教育主管部门指定的现场确认点进行现场确认。报名信息一经签字确认，一律不得更改，由此造成的一切后果由考生自负。 4、准考证下载：考生可于10月16日后登录信息平台下载准考证。 5、2014年在职人员攻读硕士专业学位全国联考（GCT)的考试时间为2014年10月26号上午8:30--11:30。 6、资格审查和复试：考生一般应在每年12月中旬（具体时间另行通知）持下载的资格审查表（需单位盖章）和毕业证、学位证、身份证原件及复印件到我院进行资格审查和复试。 招生咨询 电话：010- 88256547 李老师 010- 88258632 朱老师 010- 88256568 付老师 E-mail： zhaosheng@ucas.ac.cn 转载于:https://www.cnblogs.com/kungfupanda/p/4232623.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e9d53e9ec56642f99f2b3d762a71305/" rel="bookmark">
			谷歌招聘新职员的五大标准
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		How Google Picks New Employees (Hint: It's Not About Your Degree) 谷歌招聘新职员的五大标准 I’ve been having disagreements for years about the usefulness of college degrees as a measure of someone’s ability to be an outstanding employee. Now, don’t get me wrong – I don’t think it’s ever a bad thing to have a degree. I just think people make an assumption about formal education that’s often untrue. They assume that if two people are exactly the same in terms of age, life and job experience and demographics, and one has a college degree and the other doesn’t – that the one who has the degree will be a better employee and have a more successful career.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2e9d53e9ec56642f99f2b3d762a71305/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3a72415d07931e946a204568f1dda1d/" rel="bookmark">
			KKCapture  高清录像软
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		KKCapture是一款免费的高清录像软件。支持各种游戏录制，桌面录制，播放视频录制，操作非常简单。 软件特点 [1] 1. 支持所有游戏录制，包括网络游戏、网页游戏、单机游戏，以及所有3D游戏、2D游戏。 2. 支持窗口模式和全屏模式，还可以 自由选择录制区域。 kkcapture-logo
3. 支持 桌面、播放视频、QQ视频录制。 4. 高清录像，生成文件体积小，输出AVI或MP4格式。 5. 流畅不卡，录像不限时。 6. 视频 截图、帧率显示。 7.生成的文件可用各种播放器直接播放或直接导入各类 视频编辑软件编辑。 转载于:https://www.cnblogs.com/kungfupanda/p/3198266.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d7b496b174820403a8114bc1b7c6e91/" rel="bookmark">
			Cisco交换机设置管理IP
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需要准备一根CONSOLE线和带串行接口的电脑。
（图1）
用CONSOLE线连接好电脑与交换机（交换机的CONSOLE口一般都有表示）。
然后按照图1点“开始→程序→超级终端”会弹出来一个窗口（图2）。
（图2）
在“名称”的地方随意输入个名称然后点“确定”。原来的窗口消失，会弹出来一个窗口（图3）。
（图3）
在“连接时使用”的地方选择“COM1”然后点“确定”。原来的窗口消失，会弹出来一个窗口（图4）。
（图4）
点“还原为默认值”然后点“确定”。原来的窗口消失， 露出后边的窗口（图5）。
它会提示“yes/no”输入“n”按回车就可以进入交换机了。（有时提示一个“yes/no”有时提示两个“yes/no”，都输入“n”按回车即可）
（图6）
依次输入：
enable回车
config t回车
hostname空格，输入你要给交换机起的名字，回车
interface vlan 1 回车
ip address空格，输入你要设置的IP地址然后空格，输入你要设置的子网掩码，回车
no shutdown回车
exit回车
ip default－gateway空格，输入你要设置的默认网关
exit回车
copy run startup-config 回车，然后再回车一次
到这里就全部调完了。
转载于:https://www.cnblogs.com/kungfupanda/p/3140320.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8058abb3ec1649f1c1850994c69796f7/" rel="bookmark">
			信息学奥赛C&#43;&#43;语言：跑步
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 【题目描述】
奶牛最近缺乏锻炼，身体长胖了，影响了产奶量。于是农夫Farmer John 决定要奶牛坚持跑步，以保持标准体型。农夫上网查到了标准体型的公式： 体重 = 身高 - 105，其中体重的单位是公斤，身高的单位是厘米。现在奶牛的身高是X 厘米，体重是Y 公斤，农夫经过计算，发现奶牛的体重太重了，于是为奶牛制定跑步计划，奶牛每减重1 公斤需要跑步C 次。那么奶牛总共需要跑步多少次，才能达到标准体型呢？假设奶牛的身高不会变化。
【输入】
一行，三个正整数，X，Y，C。
【输出】
一个整数，表示为了达到标准体型，奶牛总共需要跑步的次数。
【输入样例】
174 73 6
【输出样例】
24
奶牛身高174 厘米，体重73 公斤。根据标准体型的公式，奶牛的标准体重应该是：174-105=69公斤，所以奶牛超重73 - 69 = 4 公斤。
由于减重1 公斤需要跑步6 次，所以奶牛总共需要跑步4×6=24 次。
代码
#include&lt;cstdio&gt; using namespace std; int main() { long long x,y,c,a,b,n; scanf("%d%d%d",&amp;x,&amp;y,&amp;c); a=x-105; b=y-a; n=b*c; printf("%d",n); return 0; } #include&lt;iostream&gt; using namespace std; int main() { long long x,y,c,a,b,n; cin&gt;&gt;x&gt;&gt;y&gt;&gt;c; a=x-105; b=y-a; n=b*c; cout&lt;&lt;n; return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d8f458a96fc0f9830fae782fb513c6c/" rel="bookmark">
			求里程碑的题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目:蒂莫西驾车从巴黎出发,在公路上匀速行驶.他经过一个里程碑(千米碑),是由三个数码组成的三位数,30分后她又经过一个里程碑,还是那个三个数码组成的新的三位数,又经过了50分钟经过第三个里程碑,竟然还是那三个数码组成的新的三位数,问:蒂莫西的车速?
思路:
首先明确已知的条件,
1.3个数组成的里程碑=&gt;三位数小于1000
2.这3个里程碑都是整数
3.这3个里程碑都是由3个相同数字但是位置不同组合而成
4.这是匀速行驶的汽车=&gt;知道了第一第二的里程碑就可以知道车速从而推出第三个里程碑
5.里程碑之间的时间分别是30分钟和50分钟
首先用第一个里程碑从1开始,利用穷举法,第二个里程碑利用穷举法递增,根据条件3可以快速判断是否满足条件,
当第二个里程碑确定了,就表示车速已经确定,从而第三个里程碑能推测出来,然后在利用条件3判断是否满足条件
public function speed()
{
// 返回比较的数组
$change_array = function ($number){
$tmp = $number + 1000;// 前面补充0
$tmp_num = substr($tmp, 1, 3); // 切去第一个1
$tmp_array = str_split($tmp_num);// 字符串变成数组
sort($tmp_array);// 排序
return $tmp_array;
};
// 第一个公里碑
for ($one = 1; $one &lt; 1000; $one++) {
$one_array = $change_array($one);
// 第二个公里碑
for ($two = $one + 1; $two &lt; ((3000 + 5 * $one) / 8); $two++) {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4d8f458a96fc0f9830fae782fb513c6c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7960a65d08c8c039761b6530acabaeed/" rel="bookmark">
			Westorm使用过程中无vue标签提示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一 检查是否安装vue.js的插件
通过快捷键ctrl + shift + s 快捷键进入设置webstorm的设置页面,在左上方的搜索框输入plugins,再到搜索框输入vue,查看是否安装vue的插件,如无则按下install,进行安装
二 添加设置
如果设置好了,还没有v-if等代码提示,则需要手动添加
在左上方搜索框输入inspections, 再在上方搜索框输入 unkonwn HTMLtag attribute,查看是否勾上,如无则勾选上;
查看左侧的内容的框是否有一下内容,如无则手动添加;点击apply应用即可
click v-text v-html v-once v-if v-show v-else v-for v-on v-bind v-model v-ref v-el v-pre v-cloak v-on:click v-on:keyup.enter v-on:keyup @click @change number debounce transition :is 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d7da03b7afb303f87241efa94a021bf/" rel="bookmark">
			线性表之顺序表初始化、删除、查找和合并（附C&#43;&#43;程序）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、顺序表的基本概念二、顺序表算法2.1.顺序表的结构定义：2.2顺序表的基本运算2.2 有序顺序表的归并算法 在计算机的三大逻辑结构中，线性表是一种典型的线性结构。而顺序表又是一种最基础、最简单的线性表。
一、顺序表的基本概念 1.定义：顺序表是在计算机内存中以数组的形式保存的线性表，线性表的顺序存储是指用一组地址连续的存储单元依次存储线性表中的各个元素、使得线性表中在逻辑结构上相邻的数据元素存储在相邻的物理存储单元中，即通过数据元素物理存储的相邻关系来反映数据元素之间逻辑上的相邻关系，采用顺序存储结构的线性表通常称为顺序表。顺序表是将表中的结点依次存放在计算机内存中一组地址连续的存储单元中。
2.特点：将表中元素一个接一个的存入一组连续的存储单元中，这种存储结构是顺序结构。
采用顺序存储结构的线性表简称为“== 顺序表==”。顺序表的存储特点是：只要确定了起始位置，表中任一元素的地址都通过下列公式得到： L O C ( a i ) = L O C ( a 1 ) + ( i − 1 ) ∗ L 1 ≤ i ≤ n LOC(ai)=LOC(a1)+(i-1)*L 1≤i≤n LOC(ai)=LOC(a1)+(i−1)∗L　1≤i≤n 其中， L L L是元素占用存储单元的长度。
顺序表采用数组来存储线性表的元素，在C/C++语言中，静态数组需要先指定大小，但也可以动态地分配数组的大小（通过指针来引用数组中的元素，称为动态数组），严蔚敏的《数据结构》就是采用这种方式。
二、顺序表算法 2.1.顺序表的结构定义： 设 MaxSize为一个整形常量，如果一个顺序表不会超过100个元素，则可以把 MaxSize定义为100：
#define MaxSize 100 在定义顺序表的顺序存储结构时，需要定义一个数组来存储线性表中的所有元素和定义一个整型变量来存储线性表的长度。假定数组用data[MaxSize]表示，长度整形变量用length表示，并采用结构体的形式表示，则元素类型为通用类型标识符ElemType的线性表的顺序存储类型可描述如下：
//线性表的顺序储存结构 typedef int ElemType;	//定义ElemType为int类型 typedef struct{ ElemType data[MaxSize];	//存放顺序表中的元素 int length;	//存放顺序表当前的长度 }SqList;	//声明顺序表的类型 声明顺序表类型变量：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2d7da03b7afb303f87241efa94a021bf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/935222f4211c81e91a677e6c656e495a/" rel="bookmark">
			nginx中http1.1  KeepAlive 失效
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		KeepAlive介绍和优劣势 定义：HTTP的KeepAlive就是浏览器和服务端之间保持长连接，这个连接是可以复用的。当客户端发送一次请求，收到相应内容后，这个连接会保持一段时间，在该时间内的第二次就不需要再重新建立连接,就可以直接使用这次的连接来发送请求了，极大的提高了访问速度。
优点：Keep-Alive模式更加高效，因为避免了连接建立和释放的开销。，提高访问速度
缺点：长时间的Tcp连接容易导致系统资源无效占用，浪费系统资源。
注意：http 1.0 中默认是关闭的，需要在http头加入”Connection: Keep-Alive”，才能启用 Keep-Alive； http 1.1 中默认启用Keep-Alive，如果加入”Connection: close ”，才会关闭 Keep-Alive
现象 最近优化网站的访问速度，学习了一些关于http的知识，尤其是关于长连接可以提高访问效率，在我们自己的网站上测试了一下，发现我们使用的全部是短连接，即 Response Headers 中的 Connection: 属性是close ，这样就会导致网站访问速度木有那么快，如下图：
原因 对于http1.1的请求，默认是开启 keepalive（长连接） 的，那怎么会出现变成短连接的情况呢？下面介绍一下排查过程
1、首先确定 http 请求是具体的哪个版本，直接查看浏览器请求，如下图：
从上图可知 http 版本确实是 1.1 的
2、查看某个应用所在机器上的 nginx 的配置文件 nginx.conf 的配置，keepalive_timeout 属性根本没有配置 ，如下图：
3、猜想一下，难道是必须配置 keepalive_timeout 属性才能生效吗？将 keepalive_timeout 设置为60s，如下图：
重启nginx之后发现，请求都还是短连接，Response Headers 中的 Connection 仍然是 close的
4、后来咨询运维人员，他们说我们每个机器的上游还有一个总机器控制着nginx的转发，我们就赶紧查看总机器上的 nginx 的 nginx.conf 配置文件，如下图：
我们马上将 keepalive_timeout 的值注释了 或者 修改为 60s 之后，重启 nginx，访问网站，长连接终于生效了，如下图：
总结原因：运维人员在总 nginx 入口配置了 keepalive_timeout = 0 导致长连接失效
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/935222f4211c81e91a677e6c656e495a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5e63a6fa33230aba7570ce6c2bb0494/" rel="bookmark">
			关于头文件包含的一个问题: fatal error: openssl/ssl.h: No such file or directory
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 今天在移植 rtmpdump 库的时候遇到了一个错误：
tmp.c:60:25: fatal error: openssl/ssl.h: No such file or directory 查看源码：
都是尖括号，但并不是说一定要系统环境（PATH）目录下安装了 openssl 库，而是makefile里边的包含路径出了问题：
针对这种 “#include带路径”的情况：#include &lt;openssl/ssl.h&gt;
我们在包含路径时，只需要包含到文件夹openssl的上一级就好了：
XCFLAGS=-I../../3rdinc 而不需要写成：
XCFLAGS=-I../../3rdinc/openssl #--------------------&gt;这样是找不到头文件的 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec2c7b03a86c9db8eda323da24be72ad/" rel="bookmark">
			Ubuntu下VScode编译报错：File not recongnized不可识别的文件格式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、案情还原二、没有后缀的文件1.诞生2.可以通过图形操作打开3.但不能被终端、编译器识别（1）终端（2）编译器如VScode（3）记住它们的样子！！ 问题：
总结：问题就是Linux下文件名 .后缀 你没有打出来。
解决：代码文件加后缀，如main应为main.cpp
一、案情还原 这是一个不会出错的C++代码：
你保存写好的代码（这时你没打后缀.cpp）
你高高兴兴地编译（F5)，结果
提示你的配置文件出错（Open launch.json），经过一番痛苦地探究(%&amp;……#$)，恭喜你一无所获 二、没有后缀的文件 1.诞生 2.可以通过图形操作打开 3.但不能被终端、编译器识别 （1）终端 你只能通过名字来访问，但只要有后缀就出错。
（2）编译器如VScode g++
一个g++编译命令是这样的：
g++ main.cpp -o main 前面的main.cpp代表的你的代码文件，后面的main代表.out形式的文件。总之，就是前面的main.cpp是有后缀的代码文件.
看到了没，你那个没有后缀的文件，这样是找不到，编译失败的。
VScode
同理，编译器的机制其实就是g++命令的封装，自然效果爆炸。所以才会提示file not recognized
改后
ok
（3）记住它们的样子！！ 没有后缀的代码文件在VScode中长这样
有后缀的代码文件在VScode中长这样
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3bcdffb4cc72ee87211c4ae80d6d004a/" rel="bookmark">
			web前端开发常用工具有哪些？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Web前端是一个新兴职业，市场需求大，薪资待遇高，吸引了很多人加入学习。无论是初学小白亦或是自身前端开发人员，好用的软件工具可以帮助他们更好的工作。下面苏州学码思小编为大家介绍一些常用的web前端开发工具。 1、Bootstrap
Bootstrap是快速开发Web应用程序的前端工具包。它是一个CSS和HTML的集合，它使用了新的浏览器技术，给你的Web开发提供了时尚的版式，表单，buttons，表格，网格系统等等。
2、Foundation
Foundation是一个易用、强大而且灵活的框架，用于构建基于任何设备上的Web应用。提供多种Web上的UI组件，如表单、按钮、Tabs等。
3、Cloud9IDE
Cloud9IDE是一个基于Node.JS构建的JavaScript程序开发WebIDE。它拥有一个非常快的文本编辑器，支持为JS，HTML，CSS和这几种的混合代码进行着色显示。Cloud9IDE还为node.js和GoogleChrome集成调试器，可以在IDE中启动、暂停和停止。
4、Notepad++
Notepad++是一款非常有特色的编辑器，是开源软件，可以免费使用。我们开发人员都是必备的。支持的语言:C,C++,Java,C#,XML,HTML,PHP,Javascript!
5、VisualStudioCode
VisualStudioCode是一个运行于OSX，Windows和Linux之上的，针对于编写现代web和云应用的跨平台编辑器。
6、GIMP
GIMP是GNU图像处理程序(GNUImageManipulationProgram)的缩写。包括几乎所有图象处理所需的功能，号称Linux下的PhotoShop。GIMP在Linux系统推出时就风靡了绘图爱好者圈。
7、SecureHeaders
SecureHeaders是Twitter送给Web开发者的一份大礼，作为一款Web安全开发工具，Secureheaders能够自动实施安全相关的header规则，包括内容安全政策(CSP)，防止XSS、HSTS等攻击，防止火绵羊(Firesheep)攻击以及XFO点击劫持等。
8、Fontello
Fontello是个图标字体生成器。这个工具允许用户把这些图标web字体放到自己的项目中。主要特性如下：缩小字形集合，减小字体大小;合并一些字体标记到单个文件中；访问大量专业级的开源图标。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01a6f1545a60434a30ca223ad72167c7/" rel="bookmark">
			LeetCode每日一题——T5. 最长回文子串（中）：中心扩散法、未完待续
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		法一、中心扩散法：以字符串某元素（奇数扩散中心，对应子串长度为奇数）或某两相同元素中间（偶数扩散中心，对应子串长度为偶数）为中心，分别向两端扩散，如果两端元素相同，则继续扩散，不相同则退出，保留当前子串；更换中心元素，直至找到最长回文子串。
class Solution: def longestPalindrome(self, s: str) -&gt; str: s_len = len(s) if s_len == 0: return '' _palindrome_len = 1 _palindrome_str = s[0] for i in range(s_len): palindrome_odd, odd_len = self._center_spread(s, s_len, i, i) palindrome_even, even_len = self._center_spread(s, s_len, i, i+1) # 调用函数，分别以s[i](子串长度为奇数)、s[i]和s[i+1]的中间(长度为偶数)为中心进行扩散，寻找最长回文子串 cur_max_str = palindrome_odd if odd_len &gt; even_len else palindrome_even if len(cur_max_str) &gt; _palindrome_len: _palindrome_len = len(cur_max_str) _palindrome_str = cur_max_str return _palindrome_str def _center_spread(self, s , s_len, left, right):	# 定义寻找最长回文子串函数 l = left r = right while l &gt;= 0 and r &lt; s_len and s[l] == s[r]: l -= 1 r += 1 return s[l+1 : r], r - l - 1 # 注意此处s[l+1 : r]是输出s[l+1], s[l+2], .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/01a6f1545a60434a30ca223ad72167c7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab5a1000e08a929282f013196ff6882a/" rel="bookmark">
			锟斤拷？UTF-8与GBK互转，为什么会乱码？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转自：https://blog.csdn.net/u010234516/article/details/52853214
作为一名程序员，肯定有被乱码困扰的时候，真到了百思不得其解的时候，就会觉得：英文程序员真幸福。
但其实只要明白编码之间的转换规律，其实乱码so easy~
我们知道，计算机存储数据都是2进制，就是0和1，那么这么多的字符就都需要有自己对应的0和1组成的序列，计算机将需要存储的字符转换成它们对应的01序列，然后就可以储存在电脑里了。
比如我们可以定义用8位2进制表示一个字符，“00000000”表示小写字母“a”，“00000001”表示小写字母“b”，那么计算机要存储“ab”的时候，其实在计算机里的存储的是“0000000000000001”，读取的时候先读取前8位，根据对应关系，可以解码出“a”，再读取后8位，又可以解码出“b”，这样就读出了当时写入的“ab”了。而我们定义的这种字符和二进制序列的对应关系，就可以称之为编码。我们如果需要将“ab”发送给别人，因为网络也是基于二进制，所以只要先约定好编码规则，就可以发送“0000000000000001”，然后对方根据约定的编码解码，就可以得到“ab”。现在是互联网的时代，我们经常需要和其他的计算机进行交互，一套编码系统还是比较复杂的，所以大家就需要约定统一的编码，这样的编码是大家都约定好的，就不用再去约定编码规则了~然而，为了满足各种不同的需求，人们还是制定了很多种编码，没有哪一种能全面替代其他编码，所以现在多种编码并存。通常这些编码都被大家所接受和熟知，所以现在不用再通信前商量编码的对应规则和细节，只需要告诉对方，我采用的是什么通用编码，彼此就能愉快地通信了。
所以乱码的本质就是：读取二进制的时候采用的编码和最初将字符转换成二进制时的编码不一致。
ps：编码有动词含义也有名词含义，名词含义就是一套字符和二进制序列之间的转换规则，动词含义是使用这种规则将字符转换成二进制序列。
好了，废话不多，直接上一段代码：
import java.io.UnsupportedEncodingException; public class EncodingTest { public static void main(String[] args) throws UnsupportedEncodingException { String srcString = "我们是中国人"; String utf2GbkString = new String(srcString.getBytes( "UTF-8"), "GBK"); System.out.println( "UTF-8转换成GBK："+utf2GbkString); String utf2Gbk2UtfString = new String(utf2GbkString.getBytes( "GBK"), "UTF-8"); System.out.println( "UTF-8转换成GBK再转成UTF-8："+utf2Gbk2UtfString); } } 因为UTF-8和GBK是两套中文支持较好的编码，所以经常会进行它们之间的转换，这里就以它们举例。
以上代码运行打印出以下内容：
UTF-8转换成GBK：鎴戜滑鏄腑鍥戒汉
UTF-8转换成GBK再转成UTF-8：我们是中国人
我们看到，将"我们是中国人"以UTF-8编码转换成byte数组（byte数组其实就相当于二进制序列了，此过程即编码），再以GBK编码和byte数组创建新的字符串（此过程即以GBK编码去解码byte数组，得到字符串），就产生乱码了。
因为编码采用的UTF-8和解码采用的GBK不是同一种编码，所以最后结果乱码了。
之后再对乱码使用GBK编码，还原到解码前的byte数组，再使用和最初编码时使用的一致的编码UTF-8进行解码，就可得到最初的“我们是中国人”。
这种多余的转换有时候还是很有用的，比如ftp协议只支持ISO-8859-1编码，这个时候如果要传中文，只能先换成ISO-8859-1的乱码，ftp完成后，再转回UTF-8就又可以得到正常的中文了。
怎么样？编码转换是不是so easy？那该来点正经的了：
import java.io.UnsupportedEncodingException; public class EncodingTest { public static void main(String[] args) throws UnsupportedEncodingException { String srcString = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab5a1000e08a929282f013196ff6882a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3bc6717381bb0e5d86e6e8564f4826cb/" rel="bookmark">
			nginx&#43;tomcat 企业级jsp项目部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目实验思路及重点内容（步骤及重难知识点）
1.环境：
主机 功能介绍 ip地址 主要软件
nginx1 nginx高可用节点，同时作为反向代理服务 192.168.200.202 nginx+keepalived
nginx2 nginx高可用节点，同时作为反向代理服务 192.168.200.203 nginx+keepalived
tomcat1 后端jsp网站服务器 192.168.200.204 jdk+tomcat+SL项目
tomcat2 后端jsp网站服务器 192.168.200.205 jdk+tomcat+SL项目
mysql 后端数据系统 192.168.200.206 mysql
2.实施步骤：
步骤 说明
第一步 配置nginx1：Nginx调度器构建、keepalived服务构建
第二步 配置nginx2：Nginx调度器构建、keepalived服务构建
第三步 tomcat1：tomcat安装配置、SLsalesystem项目发布
第四步 tomcat2：tomcat安装配置、SLsalesystem项目发布
第五步 SLsalesystem应用连接mysql数据库
3.重点、难点：
重点一 集群中网站访问处理过程：
1.客户端访问www.linuxfan.cn--&gt;dns域名解析：将www.linuxfan.cn解析为（192.168.200.100和200）；
2.访问nginx：通过keepalived提供VIP（100和200）、Nginx提供80端口响应客户端建立TCP连接；处理网页读取配置项（location{index.jsp;proxy_pass http://tomcat_servers}--&gt;upstream tomcat_servers{server 192.168.200.204:8080和205（tomcat）}）
3.访问tomcat：nginx作为代理服务器访问tomcat的8080建立tcp连接，请求index.jsp网页，读取tomcat配置（ROOT目录或docbase指定目录，找到默认项目，找到index.jsp）,nginx将获取的网页发送客户端浏览器；
4.访问数据库：网页请求访问数据库，tomcat的app数据库配置（webapps/项目/WEB-INF/classes/jdbc.properties）提供访问数据库参数（地址、用户、密码、数据库及其他性能参数），tomcat进程访问数据库并请求数据库，返回给nginx，nginx在返回客户端；
项目技术点：
dns轮询：将www.linuxfan.cn解析为192.168.200.100和192.168.200.200Keepalived双实例确保nginx的高可用和负载均衡，避免备设备闲置，使用track配置监控nginx状态，当nginx故障时关闭keepalived，实现故障自动切换；Nginx的负载均衡和反向代理管理后端tomcat，upstream配置项实现tomcat负载均衡，proxy_pass配置实现反向代理加速；Tomcat服务器上传项目到webapps目录，通过修改项目的JDBC参数连接后端数据库；Mysql数据创建项目数据库、授权并导入项目数据。
重点二 Keepalived双实例：作用：充分利用设备资源，结合DNS轮询提高整体架构的性能，为nginx提供负载均衡；双实例的原理（配置文件）：使用vrrp_instance创建两个实例（V1和V2），对于V1实例nginx1设备为主、nginx2设备为从，对于V2实例nginx1设备为从、nginx2为主；每个实例设置独立的vip接收客户端的访问实现负载均衡和高可用。设备之间互为主备提供网站的高可用。nginx对外提供服务，如果nginx服务故障，keepalived如何知道并完成主备切换？
1）全局配置中设置vrrp_script脚本：
vrrp_script nginx {
script /opt/chk_nginx.sh ##指定脚本路径及名称
interval 2 ##检测的频率
weight -10 ##权重
}
2）实例中调用vrrp_script脚本完成跟踪：
track_script { nginx ##vrrp_script定义的名称
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3bc6717381bb0e5d86e6e8564f4826cb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/684e25d23168863de21a10799afe03a2/" rel="bookmark">
			浅谈sleep、wait、yield、join区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		sleep sleep 方法是属于 Thread 类中的，sleep 过程中线程不会释放锁，只会阻塞线程，让出cpu给其他线程，但是他的监控状态依然保持着，当指定的时间到了又会自动恢复运行状态，可中断，sleep 给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会
示例代码：
/** * 线程sleep测试 * * @author supu * @date 2019-07-01 9:59 **/ public class ThreadSleepTest { private static final Object obj = new Object(); public static void main(String[] args) { Thread t1 = new Thread(new MyThread1()); Thread t2 = new Thread(new MyThread2()); t1.start(); t2.start(); } static class MyThread1 implements Runnable { @Override public void run() { synchronized (obj) { System.out.println("thread1 start"); try { Thread.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/684e25d23168863de21a10799afe03a2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fab4f7cf3db4b6a904e08241d3b43f32/" rel="bookmark">
			Linux中iptables设置详细
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文：http://blog.sina.com.cn/s/blog_6390cb4c0101p96h.html
无论如何，iptables是一个需要特别谨慎设置的东西，万一服务器不在你身边，而你贸然设置导致无法SSH，那就等着被老板骂吧，呵呵。。。
一下内容是为了防止这种情况发生而写的，当然很初级，不过一般服务器也够用了：
1.首先介绍一下指令和相关配置文件
启动指令:service iptables start 重启指令:service iptables restart 关闭指令:service iptables stop 然后是相关配置:/etc/sysconfig/iptables 如何操作该配置呢？ vim /etc/sysconfig/iptables 然后进去修改即可，修改完了怎么办？这里很多人会想到/etc/rc.d/init.d/iptables save指令，但是一旦你这么干了你刚才的修改内容就白做了。。。 具体方法是： 只修改/etc/sysconfig/iptables 使其生效的办法是修改好后先service iptables restart，然后才调用/etc/rc.d/init.d/iptables save， 因为/etc/rc.d/init.d/iptables save会在iptables服务启动时重新加载，要是在重启之前直接先调用了/etc/rc.d/init.d/iptables save那么你 的/etc/sysconfig/iptables 配置就回滚到上次启动服务的配置了，这点必须注意！！！ 2.下面介绍一些指令用法（主要还是man iptables看下相关资料才行）
-A：指定链名 -p：指定协议类型 -d：指定目标地址 --dport：指定目标端口（destination port 目的端口） --sport：指定源端口（source port 源端口） -j：指定动作类型 3.如果我不像修改文件直接打命令可以吗，当然没问题，步骤如下:
例如我给SSH加放行的语句： 添加input记录： iptables -A INPUT -p tcp --dport 22 -j ACCEPT 添加output记录： iptables -A OUTPUT -p tcp --sport 22 -j ACCEPT 最后注意需要再执行一下 /etc/init.d/iptables save，这样这两条语句就保存到刚才那个/etc/sysconfig/iptables 文件中了。 4.接下来说明一下步骤，如果机器不在我身边，我只能SSH进去做iptables规则，那么我必须注意每一步，千万别搞错了，否则就SSH链接不上都有可能！
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fab4f7cf3db4b6a904e08241d3b43f32/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/debdb52fb88759f071e337cdd0102fc2/" rel="bookmark">
			git下载remix-ide代码用node v10版本install各种错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		估计是node v10和remix-ide不兼容，用node v9版本可以安装成功，折腾了我好几天
针对下列remix-ide
git clone https://github.com/ethereum/remix-ide.git git clone https://github.com/ethereum/remix.git # only if you plan to link remix and remix-ide repositories and develop on it. cd remix # only if you plan to link remix and remix-ide repositories and develop on it. npm install # only if you plan to link remix and remix-ide repositories and develop on it. npm run bootstrap # only if you plan to link remix and remix-ide repositories and develop on it.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/debdb52fb88759f071e337cdd0102fc2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10260b136774825b700771ed5746b96b/" rel="bookmark">
			操作系统算法&amp;大题复习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 0x00 进程 生产者/消费者问题
（1）多生产者消费者, 多缓冲区
由于多缓冲区, 多生产者移动in指针, 多消费者移动out指针,所以需要临界区互斥(in,out为临界资源)
（2）单生产者单消费者，多缓冲区
由于单生产者和单消费者, 不会同时修改in和out指针, 所以不用临界区的互斥
（3）多或单生产者消费者, 单缓冲区
由于只有一个缓冲区, 不需要移动指针, 所以不用临界区的互斥
银行家算法
题型：判断状态是否安全，求安全序列，判断Pn进程是否能申请xx资源。
0x01 内存 1. 动态分区分配算法
首次适应：按照地址从低到高的顺序从空闲分区链/表的首地址开始寻找。下次适应：按照地址从低到高的顺序从上一个分区的地址开始寻找。最佳适应：按照空闲分区链/表的容量大小从低到高选择。最坏适应：按照空闲分区链/表的容量大小从高到低选择。 题目如下
2. 页面置换算法
OPT：淘汰未来最久未被使用的页面。LRU：淘汰在驻留集停留时间最长的页面。FIFO：淘汰最先进来的页面。Clock： 题目如下：
0x02 调度 处理器调度算法
FIFO：把处理机分配给最先进入就绪队列的进程。最短进程优先：选出运行时间最短的最短剩余时间：轮转：最高响应比：选择响应比最大的 关于调度算法计算的一些公式：
周转时间 = 完成时间 - 提交时间 =服务时间 + 等待时间 等待时间 = 开始时间 - 提交时间 带权周转时间 = 周转时间 / 服务时间 响应比 = 周转时间 / 运行时间 计算例题：
答案如下：
0x03 磁盘调度 磁盘调度算法
FCFS：按访问磁盘的先后次序进行调度SSTF：选择与当前磁道距离最近的。SCAN：选择与当前磁头运动方向相同且距离最近的，若当前方向无磁道需要访问，则磁头反向运动。CSCAN：与SCAN类似，但磁头只能单方向移动。当磁头移动到最外磁道并访问后，磁头立即返回到最里的预访问的磁道。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84b0ba2aaa77f9dbb68a10530c227c76/" rel="bookmark">
			Python Matplotlib绘制柱状图（bar和barh函数）详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言
本文的文字及图片来源于网络,仅供学习、交流使用,不具有任何商业用途,如有问题请及时联系我们以作处理。
PS：如有需要Python学习资料的小伙伴可以加点击下方链接自行获取
python免费学习资料以及群交流解答点击即可加入
使用 Matplotlib 提供的 bar() 函数来绘制柱状图。与前面介绍的 plot() 函数类似，程序每次调用 bar() 函数时都会生成一组柱状图， 如果希望生成多组柱状图，则可通过多次调用 bar() 函数来实现。
下面程序使用柱状图来展示《C语言基础》和《Java基础》两套教程历年的销量数据。
上面程序中，第 9、10 两行代码用于在数据图上生成两组柱状图，程序设置了这两组柱状图的颜色和透明度。
在使用 bar() 函数绘制柱状图时，默认不会在柱状图上显示具体的数值。为了能在柱状图上显示具体的数值，程序可以调用 text() 函数在数据图上输出文字，如上面程序中第 10 行代码所示。
在使用 text() 函数输出文字时，该函数的前两个参数控制输出文字的 X、Y 坐标，第三个参数则控制输出的内容。其中 va 参数控制文字的垂直对齐方式，ha 参数控制文字的水平对齐方式。
对于上面的程序来说，由于 X 轴数据是一个字符串列表，因此 X 轴实际上是以列表元素的索引作为刻度值的。因此，当程序指定输出文字的 X 坐标为 0 时，表明将该文字输出到第一个条柱处；对于 Y 坐标而言，条柱的数值正好在条柱高度所在处，如果指定 Y 坐标为条柱的数值 +100，就是控制将文字输出到条柱略上一点的位置。
运行上面程序，可以看到如图 1 所示的效果。
图 1 两组柱状图
从图 1 所示的显示效果来看，第二次绘制的性状图完全与第一次绘制的柱状图重叠，这并不是我们期望的结果，我们希望每组数据的条柱能并列显示。
为了实现条柱井列显示的效果，首先分析条柱重叠在一起的原因。使用 Matplotlib 绘制柱状图时同样也需要 X 轴数据，本程序的 X 轴数据是元素为字符串的 list 列表，因此程序实际上使用各字符串的索引作为 X 轴数据。比如 '2011' 字符串位于列表的第一个位置，因此代表该条柱的数据就被绘制在 X 轴的刻度值1处（由于两个柱状图使用了相同的 X 轴数据，因此它们的条柱完全重合在一起）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/84b0ba2aaa77f9dbb68a10530c227c76/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/394c89ec3b4c7c929c21a1a4af4a48d1/" rel="bookmark">
			JDK1.8 HashMap put源码剖析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		==&gt; 学习汇总（持续更新）
==&gt; 从零搭建后端基础设施系列（一）-- 背景介绍
从一个最简单的例子开始剖析hashmap的源码
Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; 10; i++) { map.put(i, i); } 内部都发生了什么？ 跟着put方法进去看看
public V put(K key, V value) { return putVal(hash(key), key, value, false, true); } hash(key)这个方法是干嘛的？ 继续跟着hash(key)进去看看
static final int hash(Object key) { int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16); } 咋一看，看不太懂，(h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)这个的目的是什么？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/394c89ec3b4c7c929c21a1a4af4a48d1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f853ecf8f8ca9f903db49a87e58657a9/" rel="bookmark">
			LeetCode每日一题——T20. 有效的括号（易）：栈、哈希表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 此题用到栈先进后出的特点进行求解，求解思路可参考下列链接，十分巧妙：
官方求解思路
class Solution: def isValid(self, s: str) -&gt; bool: _dict = {'{':'}', '[':']', '(':')'} # 创建hash表，表示左右括号的对应关系 stack = [] for char in s: # 当栈非空，且栈顶元素为左括号，且char为栈顶元素对应的右括号时，删除栈顶元素 if stack and stack[-1] in _dict.keys() and char == _dict[stack[-1]]: # _dict.key 以列表形式返回一个字典所有的键:{, [, ( stack.pop() # 否则将char添加到栈顶 else: stack.append(char) return not stack 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29a6cbd037f6e047efb30dacfaeadee6/" rel="bookmark">
			2018 ICPC南京区域赛 K .Kangaroo Puzzle
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		思路：首先需要明确我们只要每次操作合并两个，那么总能使得最后合并成一个。下面我们给出两个点合并的方法，先任意选择两个点a和b，求出两个点之间的最短路。然后让所有点都按照该路径进行移动。那么最后a点会到达b点，b点会到达c。
下面我们证明 现在的状态不会和原来的状态重合（因为状态总数为有限个，我们只需要证明状态的转移过程中不会产生环即可）
状态的组成可看做两种要素，第一是所有1的相对状态，第二是所有1相对地图的位置。
下面用反证法，假设一个状态可以回到他之前的状态，那么所有1的相对状态不变，所以所有1在转移的过程中不可以撞墙。
其次若想回到原来的绝对位置，那么我们有两种选择，一种是原路返回，一种是所有的1绕一个环，回到原来的状态。（都是在所有1不撞墙的前提下）。而题目说1无环，那么只可能是原路返回。所以我们只要在追赶的过程中不走回头路，那么由于状态数是有限的总能遍历到两点的距离为0的情况。这时两点重合，追及成功。
所有我从别人的博客中学到了随机化的方法，实在是太骚了。。。
坑点：随机化
#include&lt;bits/stdc++.h&gt; using namespace std; typedef long long LL; typedef int lint; lint a[30][30],b[30][30],vis[30][30],c[30][30]; typedef pair&lt;lint,lint&gt; pii; vector&lt;lint&gt; ans,ve; pii dir[4]; lint n,m; bool dfs( lint x,lint y,const pii &amp; b ){ vis[x][y] = 1; if( x == b.first &amp;&amp; y == b.second ){ return true; } for( lint i = 0;i &lt; 4;i++ ){ lint xx = x + dir[i].first; lint yy = y + dir[i].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/29a6cbd037f6e047efb30dacfaeadee6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f2f62bc64b44a6df06a74e1a343a26f/" rel="bookmark">
			[转]彻底解决deepin linux的无线网络问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		链接地址：https://bbs.deepin.org/forum.php?mod=viewthread&amp;tid=153154
转载于:https://www.cnblogs.com/zifeiy/p/11107328.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/985eb079fe43431e36e62762c3a2624e/" rel="bookmark">
			[Err] 1054 - Unknown column  in &#39;where clause&#39; 报错异常
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在我们开发项目 运行的时候，有时候会出现*
[Err] 1054 - Unknown column ‘b.DeviceId’ in ‘where clause’ 这种错误，千万不要慌张。这时候我们首先要想到肯定是sql出现问题。下面我写一下当时我的错误
sql语句：
select a.*,b.Attribute_Value from zz_deviceattribute a left join ZZ_DeviceAttributeRelation b on a.Attribute_Id = b.Attribute_Id where b.DeviceId = '6fac6bc7-eeed-4bf2-83dc-0f7570be8541' order by a.SortCode 数据库字段
大家会注意到 我写的两表关联查询 where后跟的是b.DeviceId 而数据库字段写的是Device_Id 所以能够看的出来是我写的字段与数据库中的字段不匹配所导致的，到这里大家也是恍然大悟了吧。
所以以后在遇到这种情况的时候，千万不要慌张，因为我们首先要想到的是一定sql出现问题。
我希望我写的内容能够帮助到大家 谢谢！！！！！！
欢迎加入qq技术群聊
*
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/275aa875cac41050e16bdfa02b132eb2/" rel="bookmark">
			面试逻辑题(English)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. You have a birthday cake and have exactly 3 cuts to cut it into 8 equal pieces. How do you do it?
The answer: stack the pieces
The “correct” answer is to cut the cake in quarters (4 pieces) using 2 of the cuts, then stack all 4 of the pieces and then split all four of the stacked pieces with the third cut.
2. Microsoft interview Puzzle: Three Ants on Triangle
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/275aa875cac41050e16bdfa02b132eb2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67d7e5858130b0e9b04e586c018461ca/" rel="bookmark">
			win10部署Jenkins(解决初始化卡住问题）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 step1 : 前往Jenkins官网下载Windows安装包 https://jenkins.io/zh/ 一路默认安装即可，记住安装路径
step2 ：
安装完成后会自动跳转到初始化页面，提示等待，一般可能需要几分钟，如果长时间卡着不动。此页面是前往外网的地址加载插件，然后进行初始化。如提示拒绝访问等，就打开任务管理器，找到Jenkins服务，重新启动。
长时间卡着不动，要么是自身网速太慢，要么就是本地电脑的过滤限制了外网连接。这里尝试关闭类似电脑管家之类的杀毒软件。重新在浏览器中输入 localhost:8080 ，成功进入初始化解锁页面。
找到以上路径的文件，用notepad++打开，将密码复制到以上页面，点击继续
step 3 :
此时自动跳转到自定义Jenkins 界面，点击安装推荐的插件，等待全部安装完成。
点击安装推荐的插件可能会遇到报错，重启Jenkins服务，刷新网页。即可进入安装插件页面，继续等待安装完成即可。
step 4 :
插件安装完成后，会跳转到创建管理员用户界面，设置好用户名，密码以及邮箱。点击保存并完成，然后会跳转到实例配置页面，默认即可，点击保存并完成。点击开始使用，会跳转到登录页面，输入账户密码登录。
step 5:
登录后首页后点击创建一个新任务，输入任务名称。然后选择Freestyle project 选项，点击确定。
然后跳转到项目配置界面，输入项目描述，点击保存。会跳转到工作区页面，点击工作区，然后点击执行构建，点击旁边的Build Now，可能会出现报404错误，直接返回页面即可。
此时会显示工作区，在电脑的Jenkins安装目录的workspace 会显示一个以项目命名的文件夹，将本地的项目文件全部复制到该文件夹。然后返回页面的工作区，可以看到刚刚复制的项目文件。
step 6 : 执行项目，选择工作区的配置 -&gt; 构建触发器 -&gt;增加构建步骤，选择Execute Windows batch command
，在弹出的对话框中输入运行python代码的命令，点击保存
回到项目特免点击Build Now 即可看到程序正在运行，点击可查看控制台输出。
程序运行完成之后，回到工作区的报告目录，即可查看测试报告。此时查看的报告页面没有渲染。回到首页，点击Manage Jenkins, 选择Script Console
输入以下代码 System.setProperty("hudson.model.DirectoryBrowserSupport.CSP",""); 再次运行程序，查看最新生成的报告，点击报告文件名称来查看。
step 7 ：设置定时执行程序 配置 -&gt;构建触发器 -&gt; Build periodically 点击右侧问号即可提示设置格式。
Python自动化测试研究院： 560151970 （q群） B站主页：https://space.bilibili.com/403609135 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f246f86410cf5423ad57d0b806a09a95/" rel="bookmark">
			java.util.ConcurrentModificationException异常
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天程序报了一个错误 java.util.ConcurrentModificationException at java.util.AbstractList$Itr.checkForComodification(AbstractList.java:4 44) at java.util.AbstractList$Itr.next(AbstractList.java:417) 程序 if (!Array2.isEmpty()) { Iterator itsarea = Array2.iterator(); while (itsarea.hasNext()) { TDTO dto = new TDTO(); //声明tcirassigndetaildto dto = (TDTO) itsarea.next(); dto.setSt("abc); Array.add(dto); } } 问题在于原来的程序把现在程序中的Array2和Array都写成Array所至. 转载于:https://www.cnblogs.com/521taobao/archive/2012/03/17/2402440.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea00527ed79536a6bf8bb913936c20d6/" rel="bookmark">
			easyui重要使用参考文档说明（转）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考地址：http://www.kqiqi.com/knowledge/web-based/527.html
转载于:https://www.cnblogs.com/alterhu/archive/2012/05/19/2509127.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f9f1be7b27a5f7fdbc3484017a5f774/" rel="bookmark">
			桌面云之深信服VMP管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		桌面云虚拟化平台管理菜单中包含有授权与服务、虚拟机配置、日志与告警、 VMP系统设置、设备升级与维护五个模块的管理入口，可以对桌面云虚拟化平台进行一些系统配置修改和维护
序列号管理中可以查看当前桌面云虚拟化平台的授权状态，并且可以通过修改序列号对其进行授权更改和扩容等操作 回收站中存放着平台删除的虚拟机文件，可以在回收站中对虚拟机进行还原或者是彻底删除操作 告警设置中包含告警条件和后续动作设置，设置告警条件用于勾选和设置平台告警产生的条件，后续动作设置用于设置产生告警后向指定的邮箱发送告警邮件 日志与告警 分为操作日志，告警日志，备份日志
操作日志：记录桌面云集群中执行的各种操作和完成情况 --告警日志：记录桌面云集群中产生的告警，如网口掉线告警
备份日志：记录桌面云集群中的备份操作，如虚拟机的自动备份和手工备份
日志与时间：用于显示和修改VMP的时间及时间同步设置
在日期和时间后面可以自己设置相应的日期和时间，点击获取本地时间则是将 VMP主机的时间和当前登录的电脑时间同步，点击确定则将新的时间设置保存生 效。
时间同步设置：用于设置VMP通过NTP服务器同步时间
用户：用来设置登陆设备的管理员账号和密码等信息。VMP可以设置不同的 管理员帐号，赋予对资源和系统的不同的管理权限。 VMP集群IP配置 多主机集群情况下可以通过设置集群IP对桌面云进行管控。 使用集群IP管理能够避免出现单点故障，管理更加稳定。
系统设置 可调整系统参 数，以适应不同的使用场景。 系统诊断 包含有命令行控制台， 抓包工具和诊断日志
命令行控制台：提供一些简单的主机命令如ping，arp，df查看主机的信息进行问题诊断
抓包工具：对主机的物理网口进行抓 阿伯，并且可以设置过滤条件进行网络诊断
诊断日志：收集指定时间内的虚拟机， 虚拟平台，虚拟存储的诊断日志查看
设备升级 在此处对桌面云虚拟化管理平台进行版本升级操作
磁盘优化 对数据磁盘进行碎片整理与优化，使磁盘处于良好的运行状态，磁盘优化不可与数据平衡计划、虚拟机备份计划、克隆、迁移、模板部署、转换为模板、删除虚拟机、系统升级同时进行。如有冲突，将停止磁盘优化与碎片整理操作。
参考资料：SANGFOR_aDesk_技术白皮书
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10beb56177a922f8676da697f9d55747/" rel="bookmark">
			桌面云之深信服VDC管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.虚拟机管理2.资源管理3.用户授权管理（1）角色授权（2）用户授权管理认证配置本地密码认证配置（1）LDAP认证（2） Radius认证用户管理 虚拟化平台控制器管理：添加桌面云虚拟化平台VMP，使VDC能够与VMP联动
1.虚拟机管理 可以查看已添加的虚拟化平台控制器管理范围内的所有虚拟机运行状态，包括虚拟机开关机状态、虚拟机名称、所属的虚拟化平台、所属的资源、IP地址、CPU、内存和磁盘占用，以及关联的用户等信息，在虚拟机管理列表界面可以查看独享桌面资源列表和对应资源派生的虚拟机，并且可以对虚拟机进行编辑开关机等操作
2.资源管理 资源管理主要是用户定义VDI 内网的可用资源，包括[独享桌面]、[共 享桌面]、[远程应用]和[远程桌面] 资源组：为了更好地对资源进行管理、更符合用户使用习惯，以及VDI 客户端可以更有条理地显示，可以把多个“资源”添加到“资源组”。 在资源列表，点击不同的“资源组”显示出该资源组对应“资源”。
系统默认存在一个资源组，即默认资源组，默认资源组只能修改不能删除，可以新建资源组来进行资源
独享桌面：基于虚拟化技术，在同一物理主机上虚拟出多个Windows 操作系统，且各自独立运行，每个用户拥有自己的桌面环境。用户在该桌面下操作自由，也可以通过策略进行灵活控制
独享桌面资源需要VMP上已经存在有虚拟机模板才可以创建 共享桌面：基于Windows终端服务而发布的桌面环境，所有用户共享同一个操作系统。
共享桌面配置：需要先在共享桌面服务器上安装远程桌面服务以及VDC的 SFRemoteAppServerInstall程序，并在VDC服务器管理中将服务器添加进去，新建共享桌面资源时选择该服务器即可
远程应用：主要用于定义、配置和管理各种基于资源服务器的VDI 内 网资源，用户无需安装应用程序和软件环境，直接通过VDI 来使用内网各种各样的应用程序资源
远程应用配置：需要先在远程应用服务器上安装远程桌面服务以 及SFRemoteAppServerInstall 程序，然后添加服务器到VDC服务器管理中，添加时在远程应用程序列表中添加需要发布的应用
远程桌面：用于定义、配置和管理远程桌面资源。用户无需安装远程桌面软件，便可通过VDI客户端访问特定的远程桌面资源
远程桌面资源配置：将需要添加为远程桌面资源的windows主机远程桌面功能开启，然后再新建远程桌面资源添加IP端口等信息即可
关于VDC资源发布更详细的步骤在以下博客中介绍到
https://blog.csdn.net/csdn10086110/article/details/93393876
3.用户授权管理 桌面云用户授权分为两个部分：
角色授权和用户接入策略
（1）角色授权 角色授权：角色授权是“用户/用户组”和“资源”的中介， SANGFOR VDC正是通过『角色授权』把VDI 登录用户/用户组和VDI 资源“关联”起来的。通过角色可以把多个“用户/用户组”、多个资源进行关联，更加有效管理资源和用户组的权限
（2）用户授权管理 策略组管理：用于配置客户端相关选项、账号控制、安全桌面及远程应用，通过agent下发给接入用户，实现桌面云的高级访问控制
认证配置 认证设置：『认证设置』包含『主要认证』、『辅助认证』和『认证选 项设置』。
『认证设置』主要用于配置认证服务器，以及各种认证的相关选项。
本地密码认证配置 （1）LDAP认证 LDAP认证：SANGFOR VDC 网关支持使用“LDAP 协议”的第三方的服务器作为认证服务器。
『LDAP 认证』就是用于设置LDAP外部认证服务器相应参数的
LDAP服务器配置
（2） Radius认证 添加支持标准 radius认证协议的服务器， 使桌面云接入用户去radius服务器上做认证
用户管理 用户管理：用户管理用于建立VDI 用户和用户组，SANGFOR VDC 用 “组策略”管理和设置具有相同性质的用户。为了管理具有某些共性的用户以及更符合企业内部管理结构，采用分层的用户组管理用户。
用户管理中包含有VDC本地用户以及从LDAP和Radius认证服务器上映射进来的用户，可以方便的进行统一管理
参考资料：SANGFOR_aDesk_技术白皮书
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4f5c95b58b05d1ae6251f2adac18b99/" rel="bookmark">
			elementUI 日期时间选择器el-date-picker开始时间与结束时间约束
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.设置el-date-picker的属性:picker-options
&lt;el-date-picker :picker-options="startDatePicker"&gt;&lt;/el-date-picker&gt; &lt;el-date-picker :picker-options="endDatePicker"&gt;&lt;/el-date-picker&gt; 2.data里设置方法：
data() { return { startDatePicker: this.beginDate(), endDatePicker: this.processDate(), } } 3.书写方法：methods：
// 日期选择约束 beginDate() { const self = this; return { disabledDate(time) { if (self.form.projectEndDate) { //如果结束时间不为空，则小于结束时间 return ( new Date(self.form.projectEndDate).getTime() &lt; time.getTime() ); } else { // return time.getTime() &gt; Date.now()//开始时间不选时，结束时间最大值小于等于当天 } } }; }, processDate() { const self = this; return { disabledDate(time) { if (self.form.projectStartDate) { //如果开始时间不为空，则结束时间大于开始时间 return ( new Date(self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a4f5c95b58b05d1ae6251f2adac18b99/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b28a1af7ea5e12dba9fda842b510bd9/" rel="bookmark">
			windows server 2003 R2密钥
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		windows server 2003 R2 密钥 windows server 2003 R2 32位密钥
序列号: MDGIK PF6YO PD8D ROW-TIKNE
Windows Server 2003 R2 64位密钥
序列号: RYCR6-T7Y6M-2TVHK C2YW3-7TYQ8
W
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bfa003117277fa007aee379dc4556323/" rel="bookmark">
			npm安装remixd失败
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 之前安装remixd各种失败，用这个命令终于装好了
sudo npm install --unsafe-perm=true --allow-root --save-dev grunt 安装nvm对node进行版本控制
curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.11/install.sh | bash 这边测试用的node v7.10.1安装remix-ide
nvm install 7 sudo npm install remix-ide -g 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/847d95a015924b8f7012865b5ebdb99a/" rel="bookmark">
			LinkedBlockingQueue的put，take方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		put操作：在LinkedBlockingQueue 中有putlcok和takelock俩把锁，put操作使用putlock这把锁，利用lockInterruptibly方法加锁，该方法的作用为：如果该线程被标记为中断，可抛出异常。加锁之后，判断count是否等于容量，相等的话条用await()方法线线程加到条件队列中去，直到唤醒，把元素加入到队列，然后判断一下count+1如果还没有达到容量值的话，再次调用notfull的signal方法，因为有可能多个线程阻塞到notfull条件队列中。最后释放锁。
释放完锁之后，如果原来count值为0的话，现在加了一个元素，调用signalNotEmpty方法，执行notEmpty.signal()，值得注意的是此过程得用takelock加锁，原因是防止其他线程消费了。
public void put(E e) throws InterruptedException { // 不允许null元素 if (e == null) throw new NullPointerException(); int c = -1; // 新建一个节点 Node&lt;E&gt; node = new Node&lt;E&gt;(e); final ReentrantLock putLock = this.putLock; final AtomicInteger count = this.count; // 使用put锁加锁 putLock.lockInterruptibly(); try { // 如果队列满了，就阻塞在notFull条件上 // 等待被其它线程唤醒 while (count.get() == capacity) { notFull.await(); } // 队列不满了，就入队 enqueue(node); // 队列长度加1 c = count.getAndIncrement(); // 如果现队列长度如果小于容量 // 就再唤醒一个阻塞在notFull条件上的线程 // 这里为啥要唤醒一下呢？ // 因为可能有很多线程阻塞在notFull这个条件上的 // 而取元素时只有取之前队列是满的才会唤醒notFull // 为什么队列满的才唤醒notFull呢？ // 因为唤醒是需要加putLock的，这是为了减少锁的次数 // 所以，这里索性在放完元素就检测一下，未满就唤醒其它notFull上的线程 // 说白了，这也是锁分离带来的代价 if (c + 1 &lt; capacity) notFull.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/847d95a015924b8f7012865b5ebdb99a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3041464f264fc9b7bcaed024b8c4d3e4/" rel="bookmark">
			nginx.conf中的fastcgi_pass
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基本原理 nginx本身不能处理PHP，它只是个web服务器，当接收到请求后，如果是php请求，则发给php解释器处理，并把结果返回给客户端。
nginx一般是把请求发fastcgi管理进程处理，fascgi管理进程选择cgi子进程处理结果并返回被nginx。
2种连接方式
fastcgi_pass 127.0.0.1:9000;
fastcgi_pass unix:/var/run/php-fpm/php-fpm.sock;
为什么会有2种fastcgi_pass Nginx和PHP-FPM的进程间通信有两种方式,一种是TCP,一种是UNIX Domain Socket.
其中TCP是IP加端口,可以跨服务器.而UNIX Domain Socket不经过网络,只能用于Nginx跟PHP-FPM都在同一服务器的场景.用哪种取决于你的PHP-FPM配置:
方式1:
php-fpm.conf: listen = 127.0.0.1:9000
nginx.conf: fastcgi_pass 127.0.0.1:9000;
方式2:
php-fpm.conf: listen = /tmp/php-fpm.sock
nginx.conf: fastcgi_pass unix:/tmp/php-fpm.sock;
其中php-fpm.sock是一个文件,由php-fpm生成,类型是srw-rw----.
UNIX Domain Socket可用于两个没有亲缘关系的进程,是目前广泛使用的IPC机制,比如X Window服务器和GUI程序之间就是通过UNIX Domain Socket通讯的.这种通信方式是发生在系统内核里而不会在网络里传播.UNIX Domain Socket和长连接都能避免频繁创建TCP短连接而导致TIME_WAIT连接过多的问题.对于进程间通讯的两个程序,UNIX Domain Socket的流程不会走到TCP那层,直接以文件形式,以stream socket通讯.如果是TCP Socket,则需要走到IP层,对于非同一台服务器上,TCP Socket走的就更多了.
socket是神马？摘抄一段描述： Socket 可以被定义描述为两个应用通信通道的端点。一个 Socket 端点可以用 Socket 地址来描述， Socket 地址结构由 IP 地址，端口和使用协议组成（ TCP or UDP ）。http协议可以通过socket实现，socket在传输层上实现。从这个角度来说，socket介于应用层和传输层之间。但是socket作为一种进程通信机制，操作系统分配唯一一个socket号，是依赖于通信协议的，但是这个通信协议不仅仅是 tcp或udp，也可以是其它协议。
在同一台服务器上，用tcp socket与unix domain socket有什么区别？
如图所示，对于进程间通讯的两个程序，unix domain socket的流程不会走到TCP 那层，直接以文件形式，以stream socket通讯。如果是TCP socket,则需要走到IP层。对于非同一台服务器上，TCP socket走的就更多了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3041464f264fc9b7bcaed024b8c4d3e4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/566ea898af1740c2685ecd2582de2f45/" rel="bookmark">
			vue-framework-wz关于not found: * vue-tinymce in ./~/babel-load、--save vue-tinymce\、Cannot GET /
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如上，我在尝试下载使用vue后台框架 vue-framework-wz
遇到了错误，先说我的解决办法：
解决方法 1. 移除/src/views/Tinymce.vue 2. 修改/src/router/index.js 删除或者注释掉如下代码，可以ctrl + F 搜索 ‘ tinymce’
// {path: ‘/tinymce’,name: ‘Tinymce编辑器’,icon:“android-document”,component: _import(‘Tinymce’)},
目的 停用tinemce。
注：tinemce是一个富文本编辑器
缺点 无法使用tinemce
思路 1.之前尝试了npm i … 无效你知道的，不然也不会…
2.看报错信息 * vue-tinymce in ./~/babel-loader/lib!./~/vue-loader/lib/selector.js?type=script&amp;index=0!./src/views/Tinymce.vue To install it, you can run: npm install --save vue-tinymce 根据报错信息知道src/views/Tinymce.vue出了问题，打开
思考可能是引用出错，光删掉下面代码也没啥用，就将整个文件（Tinymce.vue）移出
import { VueTinymce , TinymceSetting } from 'vue-tinymce'; 3.移出Tinymce.vue后 绿了！
DONE Compiled successfully in 89ms 但是！
浏览器没画面！
控制台报错，红了…
transformPath.js:100 Uncaught Error: Cannot find module '.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/566ea898af1740c2685ecd2582de2f45/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b74d541d26d56291bca9daf4e7ca93f/" rel="bookmark">
			IDEA导入主题皮肤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		IDEA的主题很多，有时候自己忘记怎么设置主题 1、下载自己喜欢的主题包
http://www.riaway.com/index.php
我最喜欢的是EasyOnTheEyes，至少眼睛没那么累
2、下载完毕之后打开IDEA，点击菜单栏的File，再点击Import Settings...看图
3、选择你下载的那个jar主题包，然后点击OK重启IDEA
4、重启之后按Ctrl+Alt+S进入设置界面
这里要注意一下的是，图片上的版本为2018.2的17年的版本可能有些不一样，如果没记错的话是Code Style&amp;Code Scheme（可能记混了，如果不对自己找找）
然后选择你之前安装的主题就可以使用的，主题与风格是分开设置的，如果要改到这里找
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/803699aadf7a4b4fd925dc4369812396/" rel="bookmark">
			VisualStudio 配置错误：进程xxx 已退出，返回代码为：0
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		记录一个简单的配置错误：进程xxx 已退出，返回代码为：0。该问题会导致ctrl + F5运行时，前台只能显示一个控制台。
解决办法：工具-&gt;选项-&gt;调试：勾选 “调试停止时自动关闭控制台”
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/22cddd9551b9940b67fba9d603359d64/" rel="bookmark">
			关于ECU升级数据的传输（ISO14229系列之34/36/37服务）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于ECU升级数据的传输（ISO14229系列之34/36/37服务） 1、ECU升级概述2、34服务——请求下载3、36服务——传输数据4、37服务——请求退出传输 1、ECU升级概述 关于ECU升级数据的传输，是通过34（请求下载）、36（传输数据）、37（请求退出传输）这3个服务来完成的。关于升级文件中一个块的传输流程如下（假设正常升级，即没有否定响应的情况）：
诊断仪通过34服务传输该块的起始地址、该块的数据长度信息；进行下载请求；ECU收到34服务的下载请求后，通过74肯定响应报文通知诊断仪，其（诊断仪）接下来的每个数据传输的报文中（36服务）应包含多少数据字节。诊断仪则根据该返回的参数对自身的发送能力进行调整；诊断仪通过36服务传输该块的数据，每个36服务传输的数据量大小由前面提到的ECU返回的74服务中的参数确定；ECU对36服务返回肯定响应；通过36服务依次将该数据进行拆分发送，期间每完成一次36服务的发送，ECU进行肯定响应的回复。直到该块数据全部发送完；诊断仪通过发送37服务进行传输退出的请求；ECU进行肯定响应回复。 升级文件中每个块（即升级数据分成的多个地址不连续的段）的数据传输都会有一个34服务进行传输的请求，并通过参数告知ECU该块数据的存放地址和长度；然后根据该块数据的大小会分成n个36服务进行数据的传输工作；在该块数据都传输完成后，通过一个37服务进行传输退出的请求。即升级文件中的每个块的传输过程，由1个34服务、n个（根据该块数据量大小确定）36服务，1个37服务完成。
接下来，我们对34、36、37服务的请求及肯定响应格式进行详细介绍。
2、34服务——请求下载 （1）、在升级文件每个块进行数据传输前，都会先通过34服务进行下载请求；并将该块数据的存储地址和数据量大小发送给到ECU端。关于该服务的请求格式如下：
dataFormatIdentifier/数据格式标识符，该参数占据1个字节；其中，第7-4位定义了压缩方法；第3-0位定义了加密方法。该字节为0x00时则表示既没有使用压缩方法也没有使用加密方法。0x00外的其他值的定义是由车产自行规定的。addressAndLengthFormatIdentifier/地址与长度格式标识符，该参数也是占据1个字节；其中，第7-4位表示后面参数memoryAddress的字节数；第3-0位表示后面参数memorySize的字节数。memoryAddress/内存地址，该参数的字节长度由addressAndLengthFormatIdentifier这个参数的第7-4位决定；表示该块数据即将要烧录到的内存起始地址；memorySize /内存大小，该参数的字节长度由addressAndLengthFormatIdentifier这个参数的第3-0位决定；表示该块数据的数据量大小； （2）、ECU收到34服务的下载请求后，通过74肯定响应报文通知诊断仪，其接下来的每个数据传输的报文中（36服务）应包含多少数据字节。响应报文的格式如下：
lengthFormatIdentifier/长度格式标识符，该参数占据1个字节；其中，第7-4位表示后面参数maxNumberOfBlockLength所占据的字节数；第3-0位为预留位，一般为0。maxNumberOfBlockLength/数据块长度最大数量，该参数用于ECU返回告知诊断仪在每次36服务进行数据传输时的最大数据量。 （3）、假设有如下34服务报文，通过上面介绍的格式对其进行分析：
10 0B 34 00 44 01 A4 04 30 00 00 00 00 00 00 00 /*流控帧*/ 21 00 00 0D 1B 42 00 00 04 74 20 04 02 00 00 00 根据前面的介绍，我们可以知道，该块数据信息没有采用加密和压缩方法（0x00）；该块数据要存放的地址和数据长度都是用4个字节表示的(0x44)；要存放到的地址是0x01A40400;该块的数据量大小是0xD1B42个字节。ECU通过74服务告知了诊断仪在接下来的数据传输中每次36服务的报文字节数应为0x402个字节（1026 - 2(减去每个36服务时的"36 帧序号" 这两个字节)，即每次传输1K的数据）。
3、36服务——传输数据 （1）在收到ECU返回的74肯定响应后，诊断仪则开始通过36服务进行数据的传输工作，每个36服务传输的数据量大小由ECU返回的74服务中的参数确定。关于36服务的请求格式如下：
blockSequenceCounter，是36服务的帧序号，每个新的36服务时该参数会进行加1；当计到0xFF时则再从0x0开始计数；依次循环，直到该36服务携带的数据被发送完成。（但注意接在34服务后面的第一次36服务的序列是从1开始的）；transferRequestParameterRecord是该36服务携带的要进行传输的数据，该参数的长度（即一个36服务传输的最大数据量）是由ECU的74服务返回的参数maxNumberOfBlockLength确定的。 （2）、在诊断仪每次传输完一个36服务时，ECU应进行肯定响应的回复。响应报文格式如下：
4、37服务——请求退出传输 （1）、通过36服务依次将一个块的数据进行拆分发送，期间每完成一次36服务的发送，ECU进行肯定响应的回复；直到该块数据全部发送完。在该块数据都传输完成后，诊断仪则会通过一个37服务进行传输退出的请求。关于37服务的请求格式如下：
（2）、ECU收到37服务请求后进行响应。肯定响应报文格式如下：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ab901aaeb01ab4d4053b87f4f3cf21a/" rel="bookmark">
			个人学习笔记之ARP攻击原理与实验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 ARP（Address Resolution Protocol，地址解析协议）是一个位于TCP/IP协议栈中的网络层，负责将某个IP地址解析成对应的MAC地址。
协议概述 ARP（AddressResolutionProtocol），即地址解析协议，是根据IP地址解析物理地址的一个TCP/IP协议。主机将包含目标IP地址信息的ARP请求广播到网络中的所有主机，并接收返回消息，以此确定目标IP地址的物理地址；收到返回消息后将该IP地址和物理地址存入本机ARP缓存中并保留一定时间，以便下次请求时直接查询ARP缓存以节约资源。
ARP漏洞 ARP协议存在很多漏洞和不足，给计算机网络造成很大的隐患。首先ARP协议是以广播方式发送ARP请求的，只要是同一个网段内主机都可以收到，这就为攻击者以可乘之机，攻击者可以发送大量的ARP请求包，阻塞正常网络宽带，使局域网中有限的网络资源被无用的广播信息所占用，造成网络拥堵；其次ARP协议没有安全认证机制，因为局域网内主机是建立在信任的基础上的，所以只要主机接收到ARP应答包，都会缓存在ARP表中，这就为ARP欺骗提供了可能。攻击者可以发送错误的IP地址MAC地址的映射关系。
ARP欺骗原理 我们知道主机a和主机b在通信时需要先后建立即建立ARP缓存表（即IP和MAC的映射），因为数据链路层传输数据，不识别IP地址，只能用MAC地址来识别。那么ARP欺骗就是从这里入手的。
主机IP /MAC通信方a192.168.1.1 / MAC 1通信方b192.168.1.2 / MAC 2攻击者c192.168.1.3 / MAC 3 假如局域网内有另一台主机（攻击者主机c),他想窃听ab之间的通信。当a给b传输信息的时候，会先问一下b的MAC地址：IP为192.168.1.2的主机啊 你的MAC地址是多少啊？但是他不知道那个是b,所以信息是以广播的方式发出去的，局域网内所有人都能收到这条信息。
当c是正常用户的时候，他会对比自己的IP 192.168.1.3!=192.168.1.2,就会把这条信息丢弃。b收到信息，对比自己的IP 192.168.1.2=192.168.1.2，b就知道了，这是找我的，所以他会回复信息：我是192.168.1.2啊 我的MAC地址是MAC 2。但是c是攻击方，他收到这个信息的时候，也会发送消息回复：我是192.168.1.2 ，我的MAC地址是MAC 3。
这时候问题来了，a不仅收到b的回复，也收到了c的回复。都说自己是192.168.1.2 一个MAC 2 一个 MAC 3。那么缓存表记录哪一个呢？当然a有自己的判断：他会记录后来的那个信息，替换前一个信息。也就是如果b的信息比c的信息后到，那么就是记录的b的回复信息。（正确的IP-MAC映射。如果b的信息比c的信息先到，那么就是记录的c的回复信息。（被欺骗的IP-MAC映射）
这时候就会出现问题，看谁的信息来的慢，概率就百分之五十。但是事实并不是这样的，ARP缓存表是允许主动更新的，c会不断的给a发送：我是192.168.1.2 我的MAC是MAC 3。总有一个是比b的信息后到，从而覆盖b的信息欺骗成功。同理，c也能给b用同样的方式欺骗成功。这样ab之间的通信都会被c窃听到！
ARP攻击分类 ARP泛洪攻击
通过向网关发送大量ARP报文，导致网关无法正常响应。首先发送大量的ARP请求报文，然后又发送大量虚假的ARP响应报文，从而造成网关部分的CPU利用率上升难以响应正常服务请求，而且网关还会被错误的ARP表充满导致无法更新维护正常ARP表，消耗网络带宽资源。ARP欺骗主机的攻击
ARP欺骗主机的攻击也是ARP众多攻击类型中很常见的一种。攻击者通过ARP欺骗使得局域网内被攻击主机发送给网关的流量信息实际上都发送给攻击者。主机刷新自己的ARP使得在自己的ARP缓存表中对应的MAC为攻击者的MAC，这样一来其他用户要通过网关发送出去的数据流就会发往主机这里，这样就会造成用户的数据外泄。欺骗网关的攻击
欺骗网关就是把别的主机发送给网关的数据通过欺骗网关的形式使得这些数据通过网关发送给攻击者。这种攻击目标选择的不是个人主机而是局域网的网关，这样就会攻击者源源不断的获取局域网内其他用户韵数据．造成数据的泄露，同时用户电脑中病毒的概率也会提升。中间人攻击
中间人攻击是同时欺骗局域网内的主机和网关，局域网中用户的数据和网关的数据会发给同一个攻击者，这样，用户与网关的数据就会泄露。IP地址冲突攻击
通过对局域网中的物理主机进行扫描，扫描出局域网中的物理主机的MAC地址，然后根据物理主机的MAC进行攻击，导致局域网内的主机产生IP地址冲突，影响用户的网络正常使用。 arpspoof用法 arpspoof [-i interface] [-c own|host|both] [-t target] [-r] host 1功能：arpspoof通过伪造arp回复包将局域网中主机A（或者所有主机）的网路包重定向到主机B。
参数：
-i 指定用攻击机的哪个网络接口，可以使用ifconfig命令查看攻击机接口列表。-c own|host|both-t 指定arp攻击的目标。如果不指定，则目标为该局域网内的所有机器。可以指定多个目标，如：arpspoof -i etho -t 192.168.23.8-t 192.168.23.1-r host 希望拦截攻击机和哪个host之间的通信，一般都是网关。 实验 环境
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6ab901aaeb01ab4d4053b87f4f3cf21a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e23606a2c29606670d8596f1af4b934e/" rel="bookmark">
			echarts3实现世界地图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于ecahrts 版本3
需要引入的文件有 echarts.js world.js
详见 world.js
https://download.csdn.net/download/super__code/10676418
效果图
代码
// html 文件 &lt;div id="worldMap" style="width: 1000px;height: 500px;border: 1px solid #ddd;"&gt;&lt;/div&gt; // 引入script 文件 &lt;script src="../assets/plugins/echarts/echarts3.min.js"&gt;&lt;/script&gt; &lt;script src="../assets/plugins/js/world.js"&gt;&lt;/script&gt; &lt;script&gt; // 绘制图表 let worldChart = echarts.init(document.getElementById('worldMap')); // 国家名英文中文对比 let nameComparison = { 'Canada':'加拿大', 'Russia':'俄罗斯', 'China':'中国', 'United States':'美国', // ....其他省略 ，见文章末 }; // 数据 let dataMap = [ {"name": "俄罗斯","value": 10}, {"name": "加拿大","value": 0}, {"name": "中国","value": 5}, {"name": "美国","value": 7} ] let option = { backgroundColor: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e23606a2c29606670d8596f1af4b934e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b96e1150914f5559727c7526312c0aea/" rel="bookmark">
			记录Debug Assertion Failed! Program: C:\windows\system32\mfc140ud.dll
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		记录一个问题
新建的一个 mfc的CFormView工程，在状态栏输出当前鼠标的位置。
像这样，先在视图类窗口获取父窗口（框架类窗口），
转换后用框架类窗口对象去调用这个对象内部的状态栏成员变量m_wndStatusBar 。
然后用setwindowText函数去设置显示的内容。
运行发现，鼠标在子窗口一动，程序就死掉了
调试发现，getparent() 这个函数获得的CMainFrame对应的句柄和咱们的框架窗口的句柄不是一个。
GetParent()-&gt;GetDescendantWindow(AFX_IDW_STATUS_BAR)-&gt;SetWindowText(str);
用这个方法也不行。
为什么？？？？？无从得知。。。有人知道可以留言解惑，万分感谢！！
解决办法：把GetParent() 换成 AfxGetMainWnd()就行了，或者 采用另外的修改状态栏的方法。
一共 有下面几种方法；
((CMainFrame*)AfxGetMainWnd())-&gt;m_wndStatusBar.SetWindowText(str);
((CMainFrame*)GetParent())-&gt;SetMessageText(str);
((CMainFrame*)GetParent())-&gt;GetMessageBar()-&gt;SetWindowText(str);
AfxGetMainWnd()-&gt;GetDescendantWindow(AFX_IDW_STATUS_BAR)-&gt;SetWindowText(str);
——END
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32eac1e0c8bdf01f0ca1457afd9fdd87/" rel="bookmark">
			vue 实现点击切换颜色
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;template v-for="(value,index) in span_object"&gt; &lt;span class="y_color_item1" :key="value.color" :style="{'background':value.color}" @click="setChecked(index)" &gt; &lt;i :class="[ aa == index ? 'el-icon-check' : '']"&gt;&lt;/i&gt; &lt;/span&gt; &lt;/template&gt; setChecked(e){ this.aa = e }, 实现效果：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91051171b6e06e59f7c9bc4940458c28/" rel="bookmark">
			zabbix 计算报错Cannot evaluate function &#34;last()&#34;: item &#34;rzx02:vm.memory.size[free]&#34; does not exist.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、在做zabbix监控测试的时候，计算内存使用率的时候，做完监控项到最新数据那里发现有报错：
原因：1、因为我没有做vm.memory.size[free]这个监控，没有获取到数据，无法进行计算，所以如果用了
100*(last("vm.memory.size[free]")/last("vm.memory.size[total]"))这个公式的话，就要保证zabbix有获取了
这两个参数的数据，所以添加这两个参数的监控项即可。
2、还有一种解决方式
zabbix有一个内置函数，可以计算内存使用率vm.memory.size[pused]
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/284827f6724a54444669c119691995c1/" rel="bookmark">
			django&#43;vue实现注册登录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注册 前台利用vue中的axios进行传值，将获取到的账号密码以form表单的形式发送给后台。
form表单的作用就是采集数据，也就是在前台页面中获取用户输入的值。numberValidateForm：前台定义的表单
$axios使用时需要在main.js中全局注册，.then代表成功后进行的操作，.catch代表失败后进行的操作
submitForm(formName) { let data = new FormData() data.append('username',this.numberValidateForm.name) data.append('password',this.numberValidateForm.pass) this.$axios.post('/api/register/',data).then((res) =&gt; { this.$router.push({ name: "login" }) // 路由跳转 }).catch((res) =&gt; { console.log("error submit!!"); return false; }) } 使用$axios进行跨域验证，首先得设置代理，然后在请求头中加入X-CSRFToken
vue.config.js
代理
proxy: { "/api":{ target:"http://127.0.0.1:8000/", changeOrigin: true // 是否代理 } },//设置代理, main.js
import Axios from 'axios' Vue.prototype.$axios = Axios let getCookie = function (cookie) { let reg = /csrftoken=([\w]+)[;]?/g return reg.exec(cookie)[1] } Axios.interceptors.request.use( function(config) { // 在post请求前统一添加X-CSRFToken的header信息 let cookie = document.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/284827f6724a54444669c119691995c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff644daf41ae2a4b60ea7b6b083adf1b/" rel="bookmark">
			LeetCode每日一题——T1. 两数之和（易）：三种解法：暴力循环、两遍哈希表、一遍哈希表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		要点：enumerate()函数、len()函数、创建空字典：_dict = {}、哈希表用法：_dict.get(值)
# 1、暴力解法：
class Solution: def twoSum(self, nums: List[int], target: int) -&gt; List[int]: for i, m in enumerate(nums):	for j in range(i, len(nums)): if (nums[j] == target - m): return [i, j] # enumerate: 对于一个可迭代的（iterable）/可遍历的对象（如列表、字符串）, 将其组成一个索引序列，利用它可以同时获得索引和值;如上，i是索引，m是值 # 2、两遍哈希表：
class Solution: def twoSum(self, nums: List[int], target: int) -&gt; List[int]: # 定义空字典，用以模拟哈希表 _dict = {} for i, m in enumerate(nums): _dict[m] = i for i, m in enumerate(nums): j = _dict.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ff644daf41ae2a4b60ea7b6b083adf1b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2e75364a06deec33db3ca9af4b1d3b5/" rel="bookmark">
			JS文件相互调用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		title: JS文件相互调用
date: 2019-06-25 17:03:36
tags: [‘JavaScript’, ‘TypeScript’] 我们在写js代码的时候，常常会碰到两个js文件之间相互调用，直接上代码：
messageText.js
//定义数组 var msgArray = [ {name: 'In function',value: '在函数'}, {name: 'was not declared in this scope',value: '没有在此范围内声明'}, ]; //定义常量 var messageText = { a_name : '张三', b_name : '李四', } exports.msgArray = msgArray; exports.messageText = messageText; 在A.js中调用messageText.js
const msg_1 = require("./messageText"); for(var i=0; i &lt; msg_1.msgArray.length; i++) { var message = data1.replace(msg_1.msgArray[i].name, msg_1.msgArray[i].value); data1 = message; } 上面的例子中，我对data1这个字符串做了一个汉化处理，就是将数组中的name替换成value；
如果想要引用B.js中的常量，那么非常简单：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f2e75364a06deec33db3ca9af4b1d3b5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/096409b9669c9dda5c80b6a26ca1a712/" rel="bookmark">
			Elasticsearch与SpringBoot整合笔记  High-level-client-rest方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一. 加入依赖 需要对应ES版本
&lt;!--ElasticSearch 依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.elasticsearch.client&lt;/groupId&gt; &lt;artifactId&gt;elasticsearch-rest-high-level-client&lt;/artifactId&gt; &lt;version&gt;7.1.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.elasticsearch&lt;/groupId&gt; &lt;artifactId&gt;elasticsearch&lt;/artifactId&gt; &lt;version&gt;7.1.1&lt;/version&gt; &lt;/dependency&gt; &lt;!--阿里 fastjson--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.58&lt;/version&gt; &lt;/dependency&gt; &lt;!--lombok--&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/dependency&gt; 二.配置 application.yml es: host: 127.0.0.1 port: 9200 protocol: http @Getter @Setter @AllArgsConstructor @NoArgsConstructor @Configuration public class EsEnvironmentProperties{ @Value("${es.host}") private String host; // ES请求地址 @Value("${es.port}") private int port; //端口 @Value("${es.protocol}") private String protocol; //协议 // 可配置多ES @Bean(name = "restHighLevelClientPre") public RestHighLevelClient getRestHighLevelClientPre() { return new RestHighLevelClient(RestClient .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/096409b9669c9dda5c80b6a26ca1a712/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7b57cb76d594e1028e37fcb25bd7be4/" rel="bookmark">
			xshell5  Xshell6  商业版的破解版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、这里是 xshell5的 下载链接 提取码：qz22 2、这里是 xshell6的 下载链接 提取码：helu
下载之后解压 打开Keygen软件获取注册码 注册码是在安装的时候 填写的序列号 然后安装即可 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62a5671120142fb8ea58eb7fe68afe34/" rel="bookmark">
			lnmp 安装多版本php 并做切换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、这里是lnmp一键安转包 这里我安装php是7.2版本的 然后我的项目的框架只支持php5.6或者5.6以下的版本 然后看到了 lnmp官网有这么一段话 多PHP版本使用教程：
多PHP版本只支持LNMP模式，LNMPA、LAMP模式下不支持！
要使用多PHP先安装多PHP版本，在lnmp1.4源码目录下运行：./install.sh mphp 按提示选择要另外安装的PHP版本，不能多选，只能选一个，要安装多个需要安装完成后再运行前面的安装命令。
已经升级完LNMP管理脚本且已安装好多PHP版本的话，lnmp vhost add 时会在设置完日志名称后提示当前已经存在的PHP版本，按提示的数字选择就可以。
如果已经存在的虚拟主机要更改PHP为指定版本需要修改虚拟主机的配置文件,配置文件为 /usr/local/nginx/conf/vhost/域名.conf ，将里面的include enable-php.conf; 替换为 include enable-php7.1.conf; 前面的7.1为php版本，可以根据自己的需要进行修改，但必须要对应的多php版本已经安装，要不然会提示502错误。
修改后必须要重启nginx，否则无法生效。
然后就按照步步骤来
在lnmp的安装目录下
./install.sh mphp 根据自己的选择选择版本即可 安装完之后我们需要 在我们之前的站点配置文件 修改制定php版本
进入 /usr/local/nginx/conf/vhost 找到我们的对应的站点配置文件 将红色的地方改成我们 安装的php版本文件 include enable-php5.5.conf 代表 php5.5的 前提是我们安装了这个版本 那么版本怎么看呢
在 /usr/local/nginx/conf 路径下 可以看到 这就是我安装的5.5版本的 修改完配置之后 保存之后 重启nginx 或者服务器 即生效 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e362e0bd080582b3dbe0e5ed8664fa8/" rel="bookmark">
			docker  registry.docker-cn.com无法访问
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 有时候我们在pull镜像的时候总是很慢， 这个时候网上的答案是把镜像的地址改成registry.docker-cn.com以提高镜像拉取速度
{ "registry-mirrors": ["http://registry.docker-cn.com"] }
镜像加速 鉴于国内网络问题，后续拉取 Docker 镜像十分缓慢，我们可以需要配置加速器来解决，我使用的是网易的镜像地址：http://hub-mirror.c.163.com。
新版的 Docker 使用 /etc/docker/daemon.json（Linux） 或者 %programdata%\docker\config\daemon.json（Windows） 来配置 Daemon。
请在该配置文件中加入（没有该文件的话，请先建一个）：
{ "registry-mirrors": ["http://hub-mirror.c.163.com"] } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41e1516977b5eaf0866b6c3b20138ed8/" rel="bookmark">
			linux awk命令详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介
awk是一个强大的文本分析工具，相对于grep的查找，sed的编辑，awk在其对数据分析并生成报告时，显得尤为强大。简单来说awk就是把文件逐行的读入，以空格为默认分隔符将每行切片，切开的部分再进行各种分析处理。awk有3个不同版本: awk、nawk和gawk，未作特别说明，一般指gawk，gawk 是 AWK 的 GNU 版本。
awk其名称得自于它的创始人 Alfred Aho 、Peter Weinberger 和 Brian Kernighan 姓氏的首个字母。实际上 AWK 的确拥有自己的语言： AWK 程序设计语言 ， 三位创建者已将它正式定义为“样式扫描和处理语言”。它允许您创建简短的程序，这些程序读取输入文件、为数据排序、处理数据、对输入执行计算以及生成报表，还有无数其他的功能。
使用方法
awk '{pattern + action}' {filenames}
尽管操作可能会很复杂，但语法总是这样，其中 pattern 表示 AWK 在数据中查找的内容，而 action 是在找到匹配内容时所执行的一系列命令。花括号（{}）不需要在程序中始终出现，但它们用于根据特定的模式对一系列指令进行分组。 pattern就是要表示的正则表达式，用斜杠括起来。awk语言的最基本功能是在文件或者字符串中基于指定规则浏览和抽取信息，awk抽取信息后，才能进行其他文本操作。完整的awk脚本通常用来格式化文本文件中的信息。通常，awk是以文件的一行为处理单位的。awk每接收文件的一行，然后执行相应的命令，来处理文本。
调用awk
有三种方式调用awk：
1.命令行方式
awk [-F field-separator] 'commands' input-file(s)
其中，commands 是真正awk命令，[-F域分隔符]是可选的。 input-file(s) 是待处理的文件。
在awk中，文件的每一行中，由域分隔符分开的每一项称为一个域。通常，在不指名-F域分隔符的情况下，默认的域分隔符是空格。
2.shell脚本方式
将所有的awk命令插入一个文件，并使awk程序可执行，然后awk命令解释器作为脚本的首行，一遍通过键入脚本名称来调用。
相当于shell脚本首行的：#!/bin/sh
可以换成：#!/bin/awk
3.将所有的awk命令插入一个单独文件，然后调用：
awk -f awk-script-file input-file(s)
其中，-f选项加载awk-script-file中的awk脚本，input-file(s)跟上面的是一样的。
本章重点介绍命令行方式。
入门实例
假设last -n 5的输出如下：
[root@www ~]# last -n 5 &lt;==仅取出前五行
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/41e1516977b5eaf0866b6c3b20138ed8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75b2f7814c5809f32362f3723d872ba0/" rel="bookmark">
			org.apache.shiro.authz.AuthorizationException: Not authorized to invoke method: public java.lang.Str
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		org.apache.shiro.authz.AuthorizationException: Not authorized to invoke method: public java.lang.String 项目：SpringBoot+shiro+mybatis-plus来说
org.apache.shiro.authz.AuthorizationException: Not authorized to invoke method: public java.lang.String
这个错误真正原因是@Controller这个注解引起的。
遇到问题： 我现在在Controller一个方法返回的是一个页面，但是我这个用户没这个权限，shiro在登录成功之后知道我没有权限访问这个页面，shiro根据没有权限本应该抛出Subject does not have permission [userInfo:del]错误，做为返回的内容，但是@Controller代表返回的是页面，所以应该是Subject does not have permission [userInfo:del]被误以为是页面，抛出这个异常（public java.lang.String），如果换成@RestController 就不会抛出异常，你要知道shiro不是不处理是他处理了，但是问题是返回的内容被我们定义死了，所以抛出来异常。这个错误原因很简单：至于处理方式做统一异常处理，在做一个错误页面进行处理在拦截那里加一个错误处理方式： shiroFilterFactoryBean.setUnauthorizedUrl(“url”);到这里就ok啦
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93e95e689b46aed968cc4b9eeb3ab478/" rel="bookmark">
			java.nio.DirectByteBuffer的分配与回收源码剖析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 直接内存简介直接内存分配剖析直接内存释放剖析Cleaner对象直接内存释放的触发时机 一些最佳实践最好主动地回收直接内存 附加内容：直接内存的读写分析写入直接内存读取直接内存 总结 直接内存简介 java NIO使用直接内存时，可以减少一次堆内内存到对外内存的转换，从而提高效率。在java中，语义上使用DirectByteBuffer对象表示一段直接内存，而本质上DirectByteBuffer对象是位于堆内的，它指向了堆外的一个内存块。直接内存不归jvm管理，所以使用时，需要小心它的回收问题。具体如何本文将详细分析。
以下代码展示了DirectByteBuffer的分配、读写和回收：
public static void main(String[] args) throws Exception { // 分配 ByteBuffer buffer = ByteBuffer.allocateDirect(128); // 写入 buffer.put("写入到直接内存".getBytes(Charset.forName("utf-8"))); // 读取 buffer.flip(); byte[] bytes = new byte[buffer.remaining()]; buffer.get(bytes); System.out.println(new String(bytes, Charset.forName("utf-8"))); System.gc();	// 不是必须 } 以上一小段代码，涉及到了直接内存的分配、使用、回收，涉及到直接内存的各个相关对象的结构关系如下：
请求分配一个大小为capacity的直接内存时，分配返回的结果是一个内存地址address，对应一段内存的起始地址。
分配内存创建DirectByteBuffer对象时，会同时创建一个相关联的Cleaner对象和Deallocator对象，他们的关系如上图所示。Cleaner对象是个虚引用，继承自PhantomReference类，虚引用在其引用的对象被垃圾回收时，被放到一个pending队列，然后由一个引用处理线程处理这个队列、调用Cleaner对象的clean()方法，由clean方法调用Deallocator对象的run()方法，进行堆外内存的释放。
直接内存分配剖析 通常我们调用静态方法ByteBuffer.allocate(int capacity)分配一段直接内存，在allocate方法内部调用DirectByteBuffer的构造器，分配出一段直接内存缓冲，DirectByteBuffer的这个构造器如下：
DirectByteBuffer(int cap) { super(-1, 0, cap, cap); boolean pa = VM.isDirectMemoryPageAligned();	// 获取是否开启内存页对齐选项 int ps = Bits.pageSize();	// 内存页大小 long size = Math.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/93e95e689b46aed968cc4b9eeb3ab478/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bccbb69e12caf8fba8ef9195043fab32/" rel="bookmark">
			linux安装JDK -bash: /home/admin/jdk1.8.0_211/bin/java: /lib/ld-linux.so.2: bad ELF interpreter: 没有那个文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天在安装jdk的时候出现了一个问题：-bash: /home/admin/jdk1.8.0_211/bin/java: /lib/ld-linux.so.2: bad ELF interpreter: 没有那个文件。原因是jdk的版本不对，只要执行：sudo yum install glibc.i686 就可以解决了：
[admin@localhost ~]$ sudo yum install glibc.i686 已加载插件：fastestmirror Determining fastest mirrors * base: mirrors.cn99.com * extras: mirror.jdcloud.com * updates: mirrors.cn99.com base | 3.6 kB 00:00:00 extras | 3.4 kB 00:00:00 updates | 3.4 kB 00:00:00 (1/4): base/7/x86_64/group_gz | 166 kB 00:00:02 (2/4): extras/7/x86_64/primary_db | 205 kB 00:00:03 (3/4): updates/7/x86_64/primary_db | 6.4 MB 00:00:03 (4/4): base/7/x86_64/primary_db | 6.0 MB 00:00:03 正在解决依赖关系 --&gt; 正在检查事务 ---&gt; 软件包 glibc.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bccbb69e12caf8fba8ef9195043fab32/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b237de5a9bde3f58be1f13f572b505c3/" rel="bookmark">
			如何利用SOLIDWORKS快速完成装配
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在用Solidworks进行装配时，除了设计师们最常用到的“配合”命令以外，还有相当多可以提高我们工作效率的操作和技巧用来完成装配工作，其中一些方法，在合适的场合里往往会比“配合”命令来得更加方便快捷，下面就是一些常见的配合技巧。
1. 【快捷配合】
这是比较常见的一种配合方式，尤其是在单独做一两个零件的标准配合时，往往没必要去开配合命令，用这种方法就好了。首先按住Ctrl键，之后分别选中需要配合的两个零件的目标面，就会弹出快捷配合栏，而且软件会进行智能判断，选择最可能的配合类型以虚线方框显示，方便自己确认，当然这时也可以选择配合命令，来使用其他配合类型。
这种操作方法不止对标准配合类型有效，其对一些高级配合的快速识别更加方便，比如“宽度”、“对称”等，可以省去自己分组选择的操作。
2. 【智能配合】
这是一种针对单个零件的配合效率特别高的操作方法。首先按住Alt键，然后选中第一个要配合零件的目标面A（一般为较小的那个零件，而且是可活动的），拖动它，这时会进入半透明的智能配合状态，继续拖动到第二个要配合零件的目标面B（一般为固定的零件），即可智能吸附上去，确认位置后放手，会弹出快捷配合栏，并且软件已经智能选择最恰当的配合类型了，最后打钩确认即可。
3. 【配合参考】
说直观点就是预定义的配合，这种方式对于要制作常用的设计库零件来说非常有必要，能大大提高设计库的使用效率，其实我们Toolbox里的标准件都是做了这种配合参考，所以使用起来很方便，比如单个拖动螺钉到孔上，会自动吸附并配合，所以我们自己制作的设计库零件也能达到这种效果，只要加上“配合参考”即可实现。
4. 【预览窗口】
有时候在一个比较大的装配体上安装比较小的零件时，为了配合它的不同面，需要旋转整个装配体，会显得很麻烦，而且可能由于显卡性能有限，会感觉比较卡顿，或者做着做着，这个小零件突然“消失不见”了？！这样效率就很低下，此时就可以考虑用预览窗口的方式，孤立这个小零件来操作，然后我们可以单独操作它，会很方便、很直观。
5. 【磁力配合】
这是2017版新增的强大功能，在此后的版本中又得到了进一步的增强。这对于有些客户做比较大型的装配体，但配合目标又比较清晰明确的，会显得非常高效，特别是做工厂布局类的话，我们只需前期在一些主要机构上定义连接点，其后插入到装配体时，靠近的连接点会有“磁力”吸引到一起，达成一种特殊的磁力配合，故而得名。在不锁定配合时还可以随时调整方案布局，非常轻松愉快。
6. 【选择透明】
其实大家应该已经发现，在使用新版本的“配合”命令时，默认选择第一个零件时它会自动透明，这样就能很方便地选择被它遮挡的一些小零件了，就这个小小的功能增强，就应该很明显地提升大家的配合体验和工作效率了吧。
以上就是在solidworks软件中进行装配时可以用到的一些小技巧，希望可以帮到大家。
原文整理自网络。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72be961a50d429557bca932fb3dfde8d/" rel="bookmark">
			微信公众号的二次开发（二 自定义菜单的创建）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在上篇《微信公众号的二次开发（一）》我们介绍了微信订阅号的一些坑，
以及微信公众平台开发的一些基本配置。下面我们继续介绍如何通过用户关注等行为。获取用户的openid.
自定义微信公众号菜单 在交互行为之前，首先我们可以从后台自己生成菜单。下面直接贴代码：
import lombok.Data; /** * @ClassName Button * @Description TODO * @Author Administrator * @Date 2019/6/11 10:59 * @Version 1.0 * @description: 菜单项的基类 &lt;/br&gt; **/ @Data public class Button { private String name;//所有一级菜单、二级菜单都共有一个相同的属性，那就是name } import lombok.Data; /** * @ClassName CommonButton * @Description TODO * @Author Administrator * @Date 2019/6/11 13:33 * @Version 1.0 * @description: 子菜单项 :没有子菜单的菜单项，有可能是二级菜单项，也有可能是不含二级菜单的一级菜单。 &lt;/br&gt; **/ @Data public class CommonButton extends Button{ private String type; private String key; private String url; } /** * @ClassName ComplexButton * @Description TODO * @Author Administrator * @Date 2019/6/11 13:34 * @Version 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/72be961a50d429557bca932fb3dfde8d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f137faf8910d54094b9fbf5ef744b653/" rel="bookmark">
			适用于Webstorm的25个最佳Javascript插件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		自从Web上JavaScript主要用于使Netscape浏览器咳嗽的弹出窗口和动画以来，已经过去了很长时间。 如今，JavaScript是开发网站和基于Web的应用程序时最流行的语言，它将在2020年及以后继续统治Web堆栈。 如果您是使用JetBrains IDE（WebStorm或Intellij Ultimate Edition）之一JavaScript开发人员，那么您会很幸运。 JetBrains和社区都提供了许多免费和高级的插件，使您的JS编程更快，更轻松，更有趣。 面临的挑战是找到在Jetbrains IDE上进行JavaScript开发的最佳插件。 谁想坐在那里浏览数百个插件以挑选最好的插件？ 好吧，我愿意！ 为了节省您的时间和麻烦，Codota团队在深层网络中进行了搜索，并收集了WebStorm和Intellij中用于JavaScript开发的最好，最有用的插件 ，并且因为我很好，我什至对列表进行了分类。 别客气。 值得注意的是，并非此列表中的所有插件对于您的日常开发工作都是必需的。 因此，在着急安装所有组件之前，请务必阅读说明并仅安装您认为对您的生产力有真正贡献的插件。 毕竟，众所周知，用不必要的插件加载一个IDE只会减慢它的速度。 寻找一般的IntelliJ插件？ 查看有关最佳IntelliJ插件的博客文章。 常规编码工具和IDE调整 该类别的工具不是JavaScript专有的，但对于在Intellij IDE上以任何语言进行编码的任何开发人员都非常有用并推荐使用。 1. 彩虹括号 这个简洁明了的插件将彩虹括号/彩虹括号添加到基于IntelliJ的IDE中 ，这对嵌套元素总是很有帮助的。 2. Codota （现在支持node.js） 我们自己的Java开发AI助手现在也支持node.js。 因此，如果您希望使用一个从数百万个开源Java和node.js程序中提取的插件以及您的上下文来帮助您更快，更有效地编写代码并减少错误 ？ 我们在这里有一个插件和服务来为您提供。 3. WakaTime 是否曾经在一天结束时保存了您的工作，却不知道您实际上是如何花时间编码的？ 好吧，这个小插件肯定会帮助您了解时间的流逝。 它衡量用不同的编辑器和语言进行不同项目所花费的时间 。 JavaScript工具 使Intellij IDEA适应JavaScript开发并不难，尤其是对于将JS开发特定工具和快捷方式添加到IDE的插件而言。 4. JS工具箱 这个有用的插件是快捷方式，工具和命令的集合，旨在在Intellij IDE上开发JavaScript时节省时间并提高效率 。 5. 资产压缩器 大小很重要，而对于CSS和JS资产，越小越好。 该插件可将那些资产的压缩置于菜单项中并单击 。 6. JSON解析器 JSON Parser是一个轻量级插件，用于在IDE中验证和格式化JSON字符串 ，而无需不断切换到浏览器。 7. Google Chrome JetBrain IDE支持 Chrome浏览器的此扩展程序可让您立即在浏览器中查看对HTML或CSS文件所做的更改，而无需重新加载页面 。 要启用它，您还需要安装其对应版本– JetBrains的LiveEdit 。 框架及其他 JavaScript的主要优势之一是其对不同产品，需求和开发任务的适应性。 JavaScript框架，库和运行时环境具有多种形状，颜色和风格 ，并且每个工具都包含一些必备的Intellij或Webstorm插件。 Node.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f137faf8910d54094b9fbf5ef744b653/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb7f62436f84dc84483fb0a77061039b/" rel="bookmark">
			微信公众号的二次开发（一  订阅号没有获取网页授权的解决方法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 应公司开发需求，最近需要进行公众号的二次开发。经过系列讨论，最后确定为使用订阅号来开发。
因为公众号开发要获取微信用户的基本信息，需要通过用户授权获取code,然后去换取openid,最后在获取用户信息。
同时在获取code时需要配置回调域名。那么问题就来：
？？？ 这时的我就是一脸黑人问号。没有权限怎么办，难道要重新再申请一个服务号，但是服务号并不符合我们业务场景。在经过查阅资料之后，总结下来主要有两种方法来解决这个问题。
一、在微信公众平台配置自动回复。然后在微信开放平台注册网站应用的AppID，大概意思就是 用订阅号借用其他拥有网页授权权限的服务号等。参考文章：https://blog.csdn.net/vbirdbest/article/details/51217478 。（因为要重新申请服务号等 所以没有采用）。
二、在用户关注或者点击菜单等交互行为时。微信服务器将POST消息的XML数据包到开发者填写的URL上。
通过这种交互行为，我们可以在用户关注时就获取到它的FromUserName即OpenId。从而获取用户信息。
微信公众平台开发配置 在进行微信开发之前，要在微信公众平台上 开发的基本配置 服务器配置。
官方文档：https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1421135319
下面贴代码：
@ApiOperation("Used to Verify the Signature of Wechat Public Platform") @RequestMapping(value = "checkSignature", method = RequestMethod.GET) public void checkSignature(@RequestParam("signature") String signature, @RequestParam("timestamp") String timestamp, @RequestParam("nonce") String nonce, @RequestParam("echostr") String echostr, HttpServletResponse response) { try { PrintWriter out = response.getWriter(); // 通过检验signature对请求进行校验，若校验成功则原样返回echostr，表示接入成功，否则接入失败 if (SignUtil.checkSignature(signature, timestamp, nonce)) { out.print(echostr); } out.close(); } catch (IOException e) { e.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bb7f62436f84dc84483fb0a77061039b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f3dd2e56ccc42adc6b5488f2adff470/" rel="bookmark">
			C51串口通讯--学习总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C51串口通讯–学习总结 一、知识顺理 串口通讯分为查询和中断两种方式实现。
查询是在主程序中实现串口通讯，即每执行一次程序，就会发送一次。
串口中断就需要用到中断寄存器了。当触发 SBUF 缓冲器，就会执行。
串口通讯的准备工作：设置串口的工作方式
设置波特率( T1 初值)
启动T1 (编程 TCON 中的 TR1 位。REN 位也要启动，允许接收位)
定时器T1的一定要开，这个是串口的波特率的控制。如果需要用扫定时/计数，就用T0。此时，TCOM 会被设置两次，所以在 TCOM 设定时，需要用上“ |= ”。在定时初始化时“ TCOM|=0X _ _ ”,
在串口通讯初始化时“ TCOM|=0X20 ”,串口通讯的 TCOM 一般为定值。
发送 " SBUF= "接收 " =SBUF " SBUF缓冲器的缓冲区一次只能接收一个字符。
初始化时可以不管TI,RI，这两个默认为0。
查询
查询的方式要在程序开始时进行串口初始化。用查询方式就不需要开中断寄存器，或者说不能开中断寄存器。
在查询通讯编程时：
缓冲区一次只能接收一个字符，所以，若想要讲接受到的 SBUF 在发送给上位机，需要另设一个新的变量，我不知道直接送给 SBUF 会怎么样，但是为了不让程序乱套，我觉得还是新设变量吧（主要是懒，等什么时候来了兴致再去弄吧）。不过我觉得应该是不行的。发送 SBUF 和接收SBUF 虽然名字一样，但是这两个不是同一个寄存器… …呃… …突然觉得可行，甚至想到了“ SBUF=SBUF ”这个荒唐的想法。
while(1) { if(RI)//判断接收是否完成 { num = SBUF;//读SBUF，读出串口接收到的数据 RI = 0;//软件清零接收标志位	temp = num;// SBUF = temp;//写SBUF，把要发送的数据送给发送缓存器 } if(TI)//判断是否发送完成 TI = 0;//清零发送完成标志位 } 上面这段程序执行后，上位机发送一连串字符，51收到的也是一连串字符。而不是一串所发送字符的第一个字符组成的字符串。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2f3dd2e56ccc42adc6b5488f2adff470/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56f372aac0f4944ae0c6a72e4da724a4/" rel="bookmark">
			tensorflow学习七之tensorborader2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import tensorflow as tf import numpy as np import matplotlib.pyplot as plt x_data = np.linspace(-1,1,300)[:,np.newaxis] print(x_data.shape) noise = np.random.normal(0,0.05,x_data.shape) y_data = np.square(x_data) -0.5 + noise def add_layer(input,in_size,out_size,n_layer,activation_function=None): layer_name = 'layer%s' % n_layer with tf.name_scope('layer'): with tf.name_scope('weights'): Weights = tf.Variable(tf.random_normal([in_size,out_size]),name='w') tf.summary.histogram(layer_name +'/weights',Weights) with tf.name_scope('biases'): biases = tf.Variable(tf.zeros([1,out_size]) + 0.1,name='b') tf.summary.histogram(layer_name + '/biases', biases) with tf.name_scope('Wx_plus_b'): Wx_plus_b = tf.matmul(input,Weights) + biases if activation_function is None: outputs = Wx_plus_b else: outputs = activation_function(Wx_plus_b) tf.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/56f372aac0f4944ae0c6a72e4da724a4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4001413afa5e5526ec8d80579ed48e15/" rel="bookmark">
			Tensorboard学习六之Tensorboard的实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import tensorflow as tf import numpy as np import matplotlib.pyplot as plt x_data = np.linspace(-1,1,300)[:,np.newaxis] print(x_data.shape) noise = np.random.normal(0,0.05,x_data.shape) y_data = np.square(x_data) -0.5 + noise def add_layer(input,in_size,out_size,activation_function=None): with tf.name_scope('layer'): with tf.name_scope('weights'): Weights = tf.Variable(tf.random_normal([in_size,out_size]),name='w') with tf.name_scope('biases'): biases = tf.Variable(tf.zeros([1,out_size]) + 0.1,name='b') with tf.name_scope('Wx_plus_b'): Wx_plus_b = tf.matmul(input,Weights) + biases if activation_function is None: outputs = Wx_plus_b else: outputs = activation_function(Wx_plus_b) return outputs with tf.name_scope("inputs"): xs = tf.placeholder(tf.float32,[None,1],name = "x_input") ys = tf.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4001413afa5e5526ec8d80579ed48e15/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/efd3f30e981880bc34bc882cdbec0502/" rel="bookmark">
			【UOJ#61】【UR #5】怎样更有力气（最小生成树）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【UOJ#61】【UR #5】怎样更有力气（最小生成树） 题面 UOJ
题解 最最最暴力的想法是把所有边给处理出来然后跑\(MST\)。
考虑边权的情况，显然离线考虑，把么一天按照\(w_i\)进行排序，显然在这一天的可以连的所有点中，我们能连则连。
考虑把这一天的所有的限制给弄出来（也就是弄出限制的子图）。
如果限制的数量不超过这一天的\(dis(u,v)\)，显然任意两点之间都是可以直接连边的，那么直接连起来就好了。
否则的话我们要找到一个复杂度和限制数量相关的东西来连边，并且因为两点长度小于限制数量，所以可以暴力把路径上的所有点全部弄下来。
找到度数最小的一个点，那么点集被分成了两类：一类与这个点相连，记做集合\(V\)，另外一个与这个点不相邻，所以可以直接与这个点连在一起，记做集合\(U\)。
\(V\)集合中的点如果要连边，要么就是从\(U\)集合连过来的，要么是从\(V\)集合连过来的。
如果是从\(U\)集合连过来，考虑\(y\in V\)，如果\(deg[y]\lt |U|\)，显然至少和一个\(U\)集合中的点无边，所以可以直接连接。否则的话\(O(deg[y])\)的给周围的所有点暴力搞一搞。这样子复杂度是\(O(\sum deg[y])=O(k)\)的。
否则对于\(V\)集合连向\(V\)集合，可以暴力枚举集合中的两个点，因为度数最小的点的度数是根号级别的，所以这里\(O(d^2)=O(k)\)。
#include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstdlib&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; using namespace std; #define ll long long #define MAX 300300 inline int read() { int x=0;bool t=false;char ch=getchar(); while((ch&lt;'0'||ch&gt;'9')&amp;&amp;ch!='-')ch=getchar(); if(ch=='-')t=true,ch=getchar(); while(ch&lt;='9'&amp;&amp;ch&gt;='0')x=x*10+ch-48,ch=getchar(); return t?-x:x; } int n,m,P;ll ans; struct Work{int u,v,w,t;}p[MAX]; bool operator&lt;(Work a,Work b){return a.w&lt;b.w;} struct Limit{int a,b;}; vector&lt;Limit&gt; A[MAX]; vector&lt;int&gt; E[MAX];int dg[MAX]; struct DSU { int f[MAX]; int getf(int x){return x==f[x]?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/efd3f30e981880bc34bc882cdbec0502/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75310dcb01a34b464a799cb502af8236/" rel="bookmark">
			桌面云之深信服VMP平台搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 VMP 虚拟化管理平台（Virtualization Management Platform）1.VMP功能介绍2.VMP 安装2.1 安装准备2.1.1安装材料2.1.2 服务器要求2.1.3 服务器配置(1)在服务器BIOS中关闭节能模式(2)启用加电自动开机(3)配置RAID阵列 2.1.4 制作U盘启动盘 2.2 VMP安装(1) 从U盘引导服务器安装VMP(2) VDS一体机2.2.1 U盘安装VMP的安装步骤 3. VMP平台初始化3.1 组建集群(1) 使用USB key进行授权(2) 添加主机(3) 集群IP 3.2 虚拟存储初始化（1）配置存储数据拷贝数量（2）磁盘用途规划（3）磁盘详细配置（4）确认配置（5）配置存储通信网口（6）存储通信部署方式（7）配置探测ip VMP 虚拟化管理平台（Virtualization Management Platform） 为云桌面提供了可靠的运行平台和完善的管理功能，拥有虚拟机快速部署、资源管理及监控、集群高可用、动态迁移、数据备份及恢复等功能。
1.VMP功能介绍 1.虚拟机搭建：搭建模板虚拟机，跟虚拟机相关配置和管理；
2.虚拟网络桥接：虚拟机跟外部网络通信的所需要的桥接；
3.实体机管理：用于VMP的集群、实体主机和存储相关配置和管理；
4.平台管理：可配置序列号、日期与时间、用户、告警设置、用户体验计划、 日志与告警、虚拟机备份与恢复、系统配置备份与恢复、设备升级、VMP 平台访问参数。
2.VMP 安装 2.1 安装准备 2.1.1安装材料 VMP系统镜像（ISO文件） U盘/刻录光盘 普通PC 需要安装VMP的服务器 注意：如客户使用一体机VDS设备，设备已事先预装VMP，无需手动安装
2.1.2 服务器要求 注意：对于内存，实际安装只需要3.5G。但由于还需要运行VDC、虚拟机建议至少8G内存
2.1.3 服务器配置 (1)在服务器BIOS中关闭节能模式 节能模式无法响应虚拟机突发的资源请求，会造成虚拟机无法及时获得CPU资源，产生虚拟机运行卡顿的问题
路径：Advanced–&gt;Advacned Processor–&gt;CPU Power Management Controls–&gt;选择“Perfomance”（不同厂商的服务器中设置的位置可能略有不同）
(2)启用加电自动开机 如果出现停电等故障，启用加电自动开机，可以确保主机加电后自动启动以恢复VMP运行
(3)配置RAID阵列 主机如有RAID卡，需配置RAID阵列，可以参照RAID厂商的说明文档。建议配置为RAID10
2.1.4 制作U盘启动盘 使用软碟通（ultraiso）刻录工具（也可以使用其他工具）
（在这之前还要检查iso文件的md5值）
2.2 VMP安装 (1) 从U盘引导服务器安装VMP 设置服务器BIOS从U盘启动
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/75310dcb01a34b464a799cb502af8236/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/789149965f145f015676dcda6de91132/" rel="bookmark">
			关于 SQL  Like 的通配符
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先说下LIKE命令都涉及到的通配符：
% 替代一个或多个字符
_ 仅替代一个字符
[charlist] 字符列中的任何单一字符
[^charlist]或者[!charlist] 不在字符列中的任何单一字符
其中搭配以上通配符可以让LIKE命令实现多种技巧：
1、LIKE'Mc%' 将搜索以字母 Mc 开头的所有字符串（如 McBadden）。
2、LIKE'%inger' 将搜索以字母 inger 结尾的所有字符串（如 Ringer、Stringer）。
3、LIKE'%en%' 将搜索在任何位置包含字母 en 的所有字符串（如 Bennet、Green、McBadden）。
4、LIKE'_heryl' 将搜索以字母 heryl 结尾的所有六个字母的名称（如 Cheryl、Sheryl）。
5、LIKE'[CK]ars[eo]n' 将搜索下列字符串：Carsen、Karsen、Carson 和 Karson（如 Carson）。
6、LIKE'[M-Z]inger' 将搜索以字符串 inger 结尾、以从 M 到 Z 的任何单个字母开头的所有名称（如 Ringer）。
7、LIKE'M[^c]%' 将搜索以字母 M 开头，并且第二个字母不是 c 的所有名称（如MacFeather）
QL 中，通配符与 SQL LIKE 操作符一起使用。
不过，MySQL 、SQLite 只支持 % 和 _ 通配符，不支持 [^charlist] 或 [!charlist] 通配符（ MS Access 支持，微软 office 对通配符一直支持良好，但微软有时候的通配符不支持 %，而是 *，具体看对应软件说明）。通配符和正则不是一回事。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/789149965f145f015676dcda6de91132/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e33adc787999f7a8ed5ff8fdaf09c13/" rel="bookmark">
			ArcGIS API for Javascript 高级开发2019
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开发模式 核心模块 esri/core/Accessoresri/core/==Promiseesri/core/Loadableesri/core/Collection Accessor Accessor方法-属性访问 //属性赋值 layer.opacity = 0.5; layer.title = '图层1'; // 对多个属性赋值 layer.set({ opacity: 0.5, title: "图层2" }); // 使用get, set方法访问多层级属性 view.get("map.basemap.title"); view.set("map.basemap.title", "new title"); Accessor方法-属性监听 mapView.watch("scale", (newValue, oldValue, property, object) =&gt; { console.log("scale changed: ${newValue} "); }); mapView.watch("map.basemap.title", (newValue, oldValue, property, object) =&gt; { console.log("new basemap title: ${newValue}"); }); mapView.watch("ready, stationary", (newValue, oldValue, property, object) =&gt; { console.log("property ${property}: ${newValue} "); }); watchUtils.whenTrue(view, "stationary", () =&gt; { console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5e33adc787999f7a8ed5ff8fdaf09c13/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f2715c30294099f975c7d49522741b0/" rel="bookmark">
			C&#43;&#43;中print和printf的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		print与printf的区别 1，print 中不能使用%s ,%d 或%c；
2，print 自动换行，printf 没有自动换行。
转载于:https://www.cnblogs.com/yun-an/p/11070228.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3a882b163ee4ff30a0cf18c3b7c594f/" rel="bookmark">
			java  导出Word（POI）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天给产品原型增加导出excel的功能，使用POI，方法如下：
1. 引用POI库（pom.xml)
&lt;!-- POI --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi&lt;/artifactId&gt; &lt;version&gt;4.1.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi-ooxml&lt;/artifactId&gt; &lt;version&gt;4.1.0&lt;/version&gt; &lt;/dependency&gt; 2. 代码：
生成word文件到指定目录，并返回文件名。
说明，本例并不是直接新建文档，而是从一个文档模板读取，并在它基础上添加行。如果对格式有要求的话，在代码中处理格式那就太折腾了，不如在模板中先把部分格式设置好，提高效率。
本例使用XWPF（.docx格式），HWPF针对 .doc格式，但是只能读不能写，因此不考虑。
import org.apache.poi.xwpf.usermodel.XWPFDocument; import org.apache.poi.xwpf.usermodel.XWPFTable; import org.apache.poi.xwpf.usermodel.XWPFTableRow; //... String[][] data = ...//初始化数据（m行 * nlie)的表格 String fileName = "XXX.docx"; String exportPath = "D:\\export" File file = new File(exportPath + "\\a_word_temp.docx"); //读取模板，比较方便一点 FileInputStream fis = new FileInputStream(file.getAbsolutePath()); XWPFDocument document = new XWPFDocument(fis); XWPFTable table = document.getTables().get(0); //data填充 int colNum = data[0].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e3a882b163ee4ff30a0cf18c3b7c594f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/317cb23357158df9b1ecaea6a9e8b867/" rel="bookmark">
			无法打开虚拟机 Dwin10x64Windows 10 x64.vmx获取该虚拟机的所有权失败主机上的某个应用程序正在使用该虚拟机。配置文件 Dwin10x64Windows 10 x64.vmx。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9146a51ab221d2b595d000891024c008/" rel="bookmark">
			Aspose.Words 破解  操作Word模板 转PDF
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.下载aspose-words-18.8-jdk16-crack.jar 由于Aspose.Words是收费的 无法直接注入到pom.xml文件中下载 所以只用手动在cmd中操作命令键注入 操作命令如下：
mvn install:install-file -DgroupId=com.aspose -DartifactId=aspose-words -Dversion=18.8 -Dpackaging=jar -Dfile=E:/aa/aspose-words-18.8-jdk16-crack.jar
2.添加成功之后 在pom.xml文件中加相应包配置
&lt;dependency&gt; &lt;groupId&gt;com.aspose&lt;/groupId&gt; &lt;artifactId&gt;aspose-words&lt;/artifactId&gt; &lt;version&gt;18.8&lt;/version&gt; &lt;/dependency&gt; 3.将破解文件license.xml放在项目的根目录下 我的路径如下：
4.写一个AsposeWordsUtils工具类 首先对Word转PDF进行操作 public class AsposeWordsUtils { /** * 判断是否有授权文件 如果没有则会认为是试用版，转换的文件会有水印 *@return */ public static boolean getLicense() { boolean result = false; try { InputStream is = AsposeWordsUtils.class.getClassLoader().getResourceAsStream("license.xml"); License aposeLic = new License(); aposeLic.setLicense(is); result = true; } catch (Exception e) { e.printStackTrace(); } return result; } /** * Word转PDF操作 *@param sourcerFile 源文件 *@param targetFile 目标文件 */ public static void doc2pdf(String sourcerFile,String targetFile) { if (!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9146a51ab221d2b595d000891024c008/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3df36ffb968dd470b1d16093f6012dc7/" rel="bookmark">
			Vue常见异常处理技巧
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		常见5中Vue异常报错处理
常见错误 第一种：引用一个不能存在的变量： &lt;div id="app" v-cloak&gt; Hello, {{text}} &lt;/div 上述代码运行后不会抛出错误，但是在控制台会有[Vue warn]消息。
第二种：将变量绑定到一个被计算出来的属性，计算的时候会抛出异常。 &lt;div id="app" v-cloak&gt; Hello, {{text2}} &lt;/div&gt; &lt;script&gt; const app = new Vue({ el:'#app', computed:{ name2() { return x; } } }) &lt;/script&gt; 运行上述代码会在控制台抛出一个[Vue warn]和一个常规的错误，网页白屏。
第三种：执行一个会抛出异常的方法 &lt;div id="app" v-cloak&gt; &lt;button @click="doIt"&gt;Do It&lt;/button&gt; &lt;/div&gt; &lt;script&gt; const app = new Vue({ el:'#app', methods:{ doIt() { return x; } } }) &lt;/script&gt; 这个错误在控制台也[Vue warn]和常规报错。和上一个错误的区别在于，只有你点击了按钮才会触发函数调用，才会报错。
上述这几个错误是Vue常见的异常抛出，但是在官方文档中我们很少能看到有具体的解决方式，有的仅仅只是一个简单的说明
《---------------------
如果在组件渲染时出现运行错误，错误将会被传递至全局 Vue.config.errorHandler 配置函数 (如果已设置)。利用这个钩子函数来配合错误跟踪服务是个不错的主意。比如 Sentry，它为 Vue 提供了官方集成
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3df36ffb968dd470b1d16093f6012dc7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ed861745bff6df59c998f3e85462422/" rel="bookmark">
			CSS改变鼠标样式（图片）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果你想让你的网站看起来更酷炫，可以改变鼠标样式，用你喜欢的图片来代替。
下面就来介绍下步骤方法：
首页把鼠标图标格式转换成.ico格式，大小为32*32
转换格式网址为：https://www.easyicon.net/covert/
然后在CSS样式中增加代码：
*{ cursor:url(../images/shubiao.ico),auto; } 大功告成啦~~~
说明：
图片大小最好是32*32的大小
Css中的cursor属性不仅仅需要将url（）书写正确，还需要填写一个备用样式。 cursor:url(‘图片地址’),备用选项;。 缺一不可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fcbce43862b594be8104bab7ed32e51f/" rel="bookmark">
			系统突然运行慢，线上CPU100%，频繁FullGC排查
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当然，这些问题最终导致的直观现象就是系统运行缓慢，并且有大量的报警。
本文主要针对系统运行缓慢这一问题，提供该问题的排查思路，从而定位出问题的代码点，进而提供解决该问题的思路。
对于线上系统突然产生的运行缓慢问题，如果该问题导致线上系统不可用，那么首先需要做的就是，导出 jstack 和内存信息，然后重启系统，尽快保证系统的可用性。
这种情况可能的原因主要有两种：
代码中某个位置读取数据量较大，导致系统内存耗尽，从而导致 Full GC 次数过多，系统缓慢。
代码中有比较耗 CPU 的操作，导致 CPU 过高，系统运行缓慢。
相对来说，这是出现频率最高的两种线上问题，而且它们会直接导致系统不可用。
另外有几种情况也会导致某个功能运行缓慢，但是不至于导致系统不可用：
代码某个位置有阻塞性的操作，导致该功能调用整体比较耗时，但出现是比较随机的。
某个线程由于某种原因而进入 WAITING 状态，此时该功能整体不可用，但是无法复现。
由于锁使用不当，导致多个线程进入死锁状态，从而导致系统整体比较缓慢。
对于这三种情况，通过查看 CPU 和系统内存情况是无法查看出具体问题的，因为它们相对来说都是具有一定阻塞性操作，CPU 和系统内存使用情况都不高，但是功能却很慢。
下面我们就通过查看系统日志来一步一步甄别上述几种问题。
Full GC 次数过多
相对来说，这种情况是最容易出现的，尤其是新功能上线时。
对于 Full GC 较多的情况，其主要有如下两个特征：
线上多个线程的 CPU 都超过了 100%，通过 jstack 命令可以看到这些线程主要是垃圾回收线程。
通过 jstat 命令监控 GC 情况，可以看到 Full GC 次数非常多，并且次数在不断增加。
首先我们可以使用 top 命令查看系统 CPU 的占用情况，如下是系统 CPU 较高的一个示例：
可以看到，有一个 Java 程序此时 CPU 占用量达到了 98.8%，此时我们可以复制该进程 id9，并且使用如下命令查看该进程的各个线程运行情况：
该进程下的各个线程运行情况如下：
可以看到，在进程为 9 的 Java 程序中各个线程的 CPU 占用情况，接下来我们可以通过 jstack 命令查看线程 id 为 10 的线程为什么耗费 CPU 最高。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fcbce43862b594be8104bab7ed32e51f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dbdf5afa9656b54f3cebb89b822b0761/" rel="bookmark">
			19.React Native动画Animated效果三种动画类型二；
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.介绍
2.Animated.decay()
2.1方法
2.1.1value参数值
2.1.2config参数有以下这些属性：
2.2示例-执行缩放
2.2.1初始化缩放值
2.2.2绑定缩放值
2.2.3定义执行动画类型并调用start()启动
2.2.4完整示例
3.Animated.spring()
3.1方法
3.1.1value参数值：
3.1.2config 参数有以下这些属性：
3.2示例-实现沿着x，y移动
3.2.1初始化x，y轴坐标
3.2.2绑定style的x和y值
3.2.3定义执行动画
3.2.4完整示例
4.Animated.timing()
4.1方法
4.1.1value参数值：
4.1.2config 参数有以下这些属性：
4.2示例-实现沿着x，y移动
4.2.1初始化x，y轴坐标
4.2.2绑定style的x和y值
4.2.3定义执行动画
4.2.4完整示例
5.Animated.View组件style支持的transform属性说明
1.介绍 Animated提供了三种动画类型。每种动画类型都提供了特定的函数曲线，用于控制动画值从初始值变化到最终值的变化过程：
Animated.decay()以指定的初始速度开始变化，然后变化速度越来越慢直至停下。
Animated.spring()提供了一个简单的弹簧物理模型.
Animated.timing()使用easing 函数让数值随时间动起来。
大多数情况下你应该使用timing()。默认情况下，它使用对称的 easeInOut 曲线，将对象逐渐加速到全速，然后通过逐渐减速停止结束。
2.Animated.decay() 推动一个值以一个初始的速度和一个衰减系数逐渐变为 0。
2.1方法 static decay(value, config) 2.1.1value参数值 value:new Animated.Value(0)可以是单个值初始值；
value:new Animated.ValueXY({x:0, y:0})二位向量x和y坐标
2.1.2config参数有以下这些属性： 如果下面的方法参数是二维向量值 ValueXY 而不是单一标量值 Value，则对应的配置参数 config 也应该是二维向量形式{x: ..., y: ...}。
velocity: 初始速度。必填。
deceleration: 衰减系数。默认值 0.997。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dbdf5afa9656b54f3cebb89b822b0761/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/337a0601f39813eda3927e2920add34e/" rel="bookmark">
			Linux系统下一个文件夹的文件复制到另一个文件夹下
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux系统 cp 的用法：
cp 用于复制文件或目录。
参数说明：
-a：此选项通常在复制目录时使用，它保留链接、文件属性，并复制目录下的所有内容。其作用等于dpR参数组合。
-d：复制时保留链接。这里所说的链接相当于Windows系统中的快捷方式。
-f：覆盖已经存在的目标文件而不给出提示。
-i：与-f选项相反，在覆盖目标文件之前给出提示，要求用户确认是否覆盖，回答"y"时目标文件将被覆盖。
-p：除复制文件的内容外，还把修改时间和访问权限也复制到新文件中。
-r：若给出的源文件是一个目录文件，此时将复制该目录下所有的子目录和文件。
-l：不复制文件，只是生成链接文件。
案例1：
cp flags.c flags_checkered.c //复制 flags.c 到flags_checkered.c 文件，当前文件同属于同一目录下 案例2：
cp -r /home/user05/lab07/* /home/user05/lab09 //复制 lab07文件夹下的所有文件到 lab09 文件夹下 案例3：
cp flags.c /home/user05/lab09/flags_revised.c //复制当前文件夹下的 flags.c 文件到 lab09 文件夹下flags_recised.c 文件 等等。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59b13ef383f45f039321e06e361908d3/" rel="bookmark">
			小程序中-获取当前页面的路由(url)以及获取当前页面前一页面的路由
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		微信小程序可以通过 getCurrentPages() 方法获取当前页面的Url地址
也可通过 pages[pages.length - 2].route 获取上级页面的Url地址
注： getCurrentPages()得到的是一个数组，数组的最后一项是当前页面的对象
获取当前页面的Url let pages = getCurrentPages(); let currPage = null; // console.log(pages) 的到一个数组 if (pages.length) { // 获取当前页面的对象（上边所获得的数组中最后一项就是当前页面的对象） currPage = pages[pages.length - 1]; } // 获取当前页面的路由 let route = currPage.route console.log(route) 获取当前页面前一页面的Url let pages = getCurrentPages(); let currPage = null; // console.log(pages) 的到一个数组 if (pages.length) { // 获取当前页面的前以页面的对象 currPage = pages[pages.length - 2]; } // 获取当前页面的前一页面的路由 let route = currPage.route console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/59b13ef383f45f039321e06e361908d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c46c65f0e700fa0e293ff90ff793feee/" rel="bookmark">
			Postgres 数据表文件存储位置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景：前端时间，测试的时候发现数据库所在的服务器磁盘占用量疯狂的增加。就去查看了是什么原因。足够定位到是数据库表的问题。问题来了，以前只知道数据库的表是以文件的形式存在的。其他都不知道，所以花了很多时间来初步了解。
initdb 的时候会指定一个 PGDATA 目录，这就是 PostgresQL 存储数据的地方。典型的位置是在 /postgres/data a 。PGDATA 下面各项存储的内容大概是：
文件或目录名存储内容PG_VERSIONPostgresQL 实例的版本号如 9.3 之类的base每个 database 会在 base 目录下有一个子目录globalPostgres 自己的 meta 数据库存放的地方（全局 DB）pg_xlogWAL(Write Ahead Log 预写式日志）存放的地方其他其他不知道干啥的目录还有好多 base 目录是最重要的一个目录，放的是每一个 database 的数据。base 目录里的每一个数字目录对于一个 database 的 oid， 可以通过 查看 pg_database 这张表查看每一个 数据库的 oid 。
select oid, datname from pg_database ; 可以看到 oid和文件夹的名称是对应的。
每一张表的数据（大部分）又是放在 base/(oid)/(relfilenode) 这个文件里面：
select relname, relowner, relfilenode from pg_class where relowner = 10 ; --或者可以加入表名称的过滤 select relname, relowner, relfilenode from pg_class where relowner = 10 and relname like '%viid%'; 可以知道 pg_statistic 存在 11867 文件中
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c46c65f0e700fa0e293ff90ff793feee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5b88023bbb8ec3f4a7c829e1ae06a86/" rel="bookmark">
			微信小程序跳转外部网站
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以跳转百度为例，点击一个按钮，跳转到百度（百度的网页还是在小程序中打开） wxml:
&lt;view &gt; &lt;button bindtap='to'&gt;点击跳转&lt;/button&gt; &lt;/view&gt; js:
to: function (e) { wx.navigateTo({ url: '/pages/out/out', }) }, 要跳转的百度页面：out.wxml (百度页面)，js,wxss,json略。
&lt;web-view src="https://www.baidu.com/"&gt;&lt;/web-view&gt; 要勾选上开发者工具详情里面，不检验合法域名、业务域名这个选项。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/265/">«</a>
	<span class="pagination__item pagination__item--current">266/321</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/267/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>