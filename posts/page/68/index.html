<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d7dc1f4a7499ef329f5b6c366857a44/" rel="bookmark">
			css鼠标样式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		要改变鼠标样式，你可以使用 CSS 的 cursor 属性。这个属性用于控制鼠标在特定元素上的样式。以下是一些常用的鼠标样式：
默认样式：cursor: auto;
指针样式：cursor: pointer;
文本选择样式：cursor: text;
十字线样式：cursor: crosshair;
缩放样式：cursor: zoom-in; 或 cursor: zoom-out;
禁止样式：cursor: not-allowed;
移动样式：cursor: move;
你可以根据需要将这些样式应用于具体的元素。以下是示例代码：
/* 将鼠标样式设置为指针 */ .button { cursor: pointer; } /* 将鼠标样式设置为文本选择样式 */ .input-field { cursor: text; } 将 .button 元素的鼠标样式设置为指针，并将 .input-field 元素的鼠标样式设置为文本选择样式。
.custom-cursor { cursor: url('path/to/cursor.png'), auto; } 在上面的例子中，我们将 .custom-cursor 类应用到需要变成自定义图片的元素上。通过设置 cursor 属性，我们使用 url(‘path/to/cursor.png’) 指定所需图片的路径，并在图片加载失败时回退到 auto 鼠标样式。
请确保将 path/to/cursor.png 替换为你想要使用的图片的真实路径。此外，记住优化你的图片，使其文件大小尽可能小，以便更好地适应网页加载。
值得注意的是，尽管你可以自定义鼠标样式，但你无法保证在所有浏览器和操作系统中都能正常显示。因此，在使用自定义鼠标样式之前，最好进行测试以确保在你的目标平台上有正确的呈现效果。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05e0d4a8a4f78cb9da9543ed2f59ae11/" rel="bookmark">
			centos7安装kafka3.4
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		查看官网快速入门：https://kafka.apache.org/documentation.html#quickstart
通过快速入门可以明确，需要先安装Java环境，但centos7操作系统默认已安装；同时也可以了解到，kafka不仅可以搭配ZooKeeper使用，还可以搭配Kraft
查看java版本，如下：
本操作系统已有符号要求的java环境，故此略过java安装和更新。
一、安装 1.1 下载kafka最新版本 官网：http://kafka.apache.org/downloads
镜像：https://mirrors.bfsu.edu.cn/apache/kafka/3.4.0/kafka_2.12-3.4.0.tgz --no-check-certificate
1.2 解压 解压命令：tar -zxvf kafka_2.12-3.4.0.tgz
创建日志目录：
cd /var/log
mkdir kafka
cd kafka &amp; mkdir logs
1.3 修改配置文件 进入上个步骤的解压目录，打开配置文件（vi config/server.properties）
#配置kafka的监听端口 listeners=PLAINTEXT://:9092 #配置日志路径 log.dirs=/var/log/kafka/logs #配置zookeeper zookeeper.connect=localhost:2181 #调整日志保存时间为1小时 log.retention.hours=1 备注：如果要远程访问则需要配置advertised.listeners
advertised.listeners=PLAINTEXT://192.168.1.104:9092
1.4 copy到opt目录 \cp -rf kafka_2.12-3.4.0 /opt
二、启动 Kafka依赖ZooKeeper或者Kraft，需先启动依赖环境，本示例配置了ZooKeeper
进入安装路径
cd /opt/kafka_2.12-3.4.0
2.1 启动zookeeper 2.2 启动kafka 使用后台启动方式，保证关闭窗口时，不关闭kafka进程
./bin/kafka-server-start.sh -daemon ./config/server.properties
或者：
nohup ./bin/kafka-server-start.sh ./config/server.properties 1&gt;/var/log/kafka 2&gt;&amp;1 &amp;
启动后查看日志
三、验证 3.1 查看topic .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/05e0d4a8a4f78cb9da9543ed2f59ae11/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0658ba8513330435ce6561d9512ded1/" rel="bookmark">
			Datax 数据同步-使用总结（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1，实时同步？ datax 通常做离线数据同步使用。
目前能想到的方案
利用 linux 的定时任务+时间戳的方式做增量同步。
2，同步速度快不快？ 单表同步速度还是挺快的
但是如果遇到复杂的 sql 查询，其同步效率，依赖于读取数据的 sql 的执行效率
单表使用 querySql，数量 三千五百万数据，全量同步时间
3，writeMode模式选择 总共三种：insert/replace/update
对于导入端是 mysql的话，
insert 就是单纯的插入。不判重。如果遇到主键冲突，就报错提示。
replace，原理类似 mysql 的 replace into 的原理，
update，原理类似 mysql 的on duplicate key update的原理。
总之，在设计目标的表时候，需要增加唯一索引，避免出现数据重复插入的问题。
4, 优化 这个目前还在研究中。。。。
另外，如果不设置splitPk属性，datax 按单通道执行。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/318ee7c028f77d9d06ccf8a1bd01876c/" rel="bookmark">
			bevfusion代码阅读
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		build_from_cfg 这段代码是一个函数，用于根据配置字典构建一个模块对象。函数的参数包括一个配置字典 cfg，一个注册表 registry，和一个可选的默认参数字典 default_args。
函数首先进行参数的类型检查，确保 cfg 是一个字典，registry 是一个 Registry 对象，default_args 是一个字典或者 None。
然后，函数将 cfg 复制给 args，并将 default_args 中的键值对添加到 args 中。
接下来，函数从 args 中弹出键为 'type' 的值，该值指定了要构建的对象类型。如果该值是一个字符串，函数从注册表中获取对应的类对象；如果该值是一个类对象，则直接使用该对象；否则，抛出一个类型错误。
最后，函数使用构建好的类对象和剩余的参数构建一个对象，并返回该对象。
此函数的作用是根据配置字典构建一个模块对象，可以根据需要自定义配置来构建不同的模块。
def build_from_cfg(cfg, registry, default_args=None):
"""Build a module from config dict.
Args:
cfg (dict): Config dict. It should at least contain the key "type".
registry (:obj:`Registry`): The registry to search the type from.
default_args (dict, optional): Default initialization arguments.
Returns:
object: The constructed object.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/318ee7c028f77d9d06ccf8a1bd01876c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6a1bd51a9aeef6edb10b8c3b5bf957f/" rel="bookmark">
			太好了！终于可以离线安装浏览器扩展了~
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		现在基本只用Chrome浏览器，身边很多同事也一样。上次装了一个视频录制扩展，可能是因为扩展文件太大，同步扩展花了好长时间。有时不想把账号登得导出都是，又想使用扩展。所以能下载到.crx文件就很重要。
昨天听说bejson上线了crx下载地址解析功能，于是迫不及待地去体验了一下，一个字“牛鼻”~
话不多说，先上链接：crx下载地址解析 - bejson在线工具
主界面是酱紫的：
第一步 要下载扩展，需要提供 商店链接或扩展ID。商店链接不用多说，访问应用商店，搜索扩展名称，查看扩展详情，然后复制地址栏的地址即可。
对于你已经安装过的扩展，直接进入"管理扩展程序"页面，复制ID会方便不少，已安装的扩展可以快速获得扩展ID，步骤如下图所示：
第二步 访问工具页面，输入扩展ID，然后点击”获取crx下载地址“，此时在输入框的下方会出现蓝色的超链接，点击超链就开始下载crx扩展文件了。超链接域名是“clients2.google.com”，要想成功下载要那啥，应该知道的吧！
第三步 扩展包下载完成后，要怎么安装到另一台电脑上呢！
首先把.crx文件拷贝到另一台电脑，进入”管理扩展程序“页面，将.crx文件拖动到主界面。此时会弹出提示框，点击”添加扩展程序“按钮即可。
如下图所示即安装成功：
常用扩展 分享几款个人常用的扩展。
名称：Awesome 截图和屏幕录制
ID: nlipoenfbbikpbjkfpfillcgkoblgpmj
说明：个人很喜欢它的“整个页面”截图功能，啊，对就是安卓上面的滚动截图功能。
名称：AdGuard 广告拦截器
ID: bgnkhhnnamicmpeenaelnjfhikgbkllg
说明：干掉了一些垃圾广告，世界都清净了。
名称：Bitwarden - 免费密码管理器
ID: nngceckbapebfimnlniiiahkandclblb
说明：开源免费的密码管理器，也有电脑端，装插件是为了收集注册登录各大网站时输入的账号和密码。
名称：Clear Site Data
ID: aihgofjefdlhpnmeakpnjjeajofpcbhj
说明：可以清除单个站点的缓存，之前有写过一篇文章介绍它了。
名称：Easy Window Resize
ID: cfpenpohaapdgnkglcbgjiooipcbcebi
说明：将chrome的窗口大小设置到指定宽高，比如可以快速设置成1280x720 或 1440x900。
名称：Picture-in-Picture Extension (by Google)
ID: hkgfoiooedgoejojocmhlaklaeopbecg
说明：为视频开启画中画功能，开启后即使浏览器最小化，也能看见视频。有时我听chill会用这个功能。
名称：Vue Telescope, Discover Vue.js Websites
ID: neaebjphlfplgdhedjdhcnpjkndddbpd
说明：如果这个网站/网页是vue开发的，图标就会变成彩色的，众所周知b站就是vue开发的，不信你装这个插件试试。
名称：猫抓 - 网页媒体嗅探工具
ID: jfedfbgedapdagkghmgibemcoggfppbb
说明：嗅探一些图片、视频资源，自从学会看开发者工具的网络，这个扩展就用得比较少了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c6a1bd51a9aeef6edb10b8c3b5bf957f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/092f71791b991b924cc056850aea26e4/" rel="bookmark">
			基于VideoReTalking&#43;GFPGAN的AI数字人
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VideoReTalking 是一个新颖的系统，用于根据输入音频编辑真实世界中的说话头部视频，生成具有不同情感的高质量和唇部同步的输出视频。
该系统将此目标分解为三个顺序任务：
具有规范表情的人脸视频生成；音频驱动的唇部同步；用于提高照片真实感的人脸增强。 wav2lip和VideoReTalking超分后效果对比
文章目录 基本原理准备工作创建虚拟环境激活虚拟环境pip安装匹配版本 模型预测对口型必要的数据准备命令行预测参数解释其他使用方法WebUI预测 基本原理 人脸视频生成：使用表情编辑网络修改每一帧的表情，使其与相同的表情模板相匹配，从而生成具有规范表情的视频。音频驱动的唇部同步：将该视频与给定的音频一起输入唇部同步网络，生成唇部同步视频。人脸增强：通过身份感知的人脸增强网络和后处理来提高合成人脸的照片真实感。 所有这些步骤都使用基于ML和DL学习的方法，并且可以在没有任何用户干预的情况下按顺序进行。
准备工作 从github上下载源码，下载完毕之后下载模型 pre-trained models。
模型分这么多种类，将全部模型复制到 checkpoints 中。
创建虚拟环境 切记这个里面有编译的环境在里面，不要移动创建好的虚拟环境，除非你能自己修改源码修改对应的路径文件。
conda create -n VideoReTalking python=3.8 激活虚拟环境 在GIT环境目录下激活，这里是我的路径，修改成你自己的。
conda activate VideoReTalking pip安装匹配版本 确保安装了所有必要的依赖项，可以通过requirements.txt文件进行安装。
这里会有个问题要根据显卡选择torch版本，我的显卡是RTX4090，我选择这个安装命令。
pip install torch==2.0.0+cu118 torchvision==0.15.1+cu118 torchaudio==2.0.1 --index-url https://download.pytorch.org/whl/cu118 pip install -r requirements.txt 其他显卡根据情况自行安装。
pip install torch==1.9.0+cu111 torchvision==0.10.0+cu111 -f https://download.pytorch.org/whl/torch_stable.html pip install -r requirements.txt 模型预测对口型 必要的数据准备 事先还要准备好素材视频和音频文件，这里分别放置原始的图片，音频以及视频文件。
其中音频和视频文件放在项目目录下的./examples/audio和 ./examples/face中即可。
命令行预测 使用预训练模型进行快速推理，可以测试任何说话的人脸视频，无需手动对齐。
\VideoReTalking\python.exe inference.py --face examples/face/1.mp4 --audio examples/audio/1.wav --outfile results/1_1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/092f71791b991b924cc056850aea26e4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f575377b88cb96c5effc29dd0143bb4/" rel="bookmark">
			SQL多表查询的注意点,以及 join on 、where 执行的顺序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、多表查询 where 、 join
①where 实现多表查询
select a.ID ,b.Name from Table1 as a , Table2 as b where a.ID=B.ID 缺点：在上语句中，实际先查询 表a，b 两个表的cross join 【笛卡儿积】，然后通过正确a.ID=b.ID 过滤正常的数据，这是一种低效利用数据库资源。
为了避免创建笛卡儿积，应该使用inner join 可以简写 join 但 left [ outer ] join on 和 right [ outer ] join on 、full join on不能省略
sql 执行的顺序 ： from where group 、having、select 、order
from 表1，表2 就先cross join 交叉连接（笛卡儿积）
---笛卡儿积 select a.ID ,b.Name from Table1 as a , Table2 as b ---### 等价 select a.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7f575377b88cb96c5effc29dd0143bb4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e350aac7b3b87d05d09560179389948b/" rel="bookmark">
			命令行快捷键Mac Iterm2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文:Jump forwards, backwards and delete a word in iTerm2 on Mac OS
iTerm2并不允许你使用 ⌥+← 或 ⌥+→ 来跳过单词。
你也不能使用 ⌥+backspace 来删除整个单词。
下面是在Mac OS上如何配置iTerm2以便能做到这一点的方法。
退格键 首先，你需要将你的左侧 ⌥ 键设置为转义字符。这可以通过前往 iTerm2 &gt; 首选项 &gt; 配置文件 &gt; 键盘 设置。拉出以下的偏好设置面板和选项。
看图中的Left Option键,选择(+Esc)
向前删除整个单词 设置上面Left Option键的转移之后我们就可以通过(Left ⌥ + backspace)组合键向前删除整个单词了
向前单词跳转 同样我们也要设置转移序列,
接下来，点击加号图标添加新的键映射。
按下键命令：⌥+←；从下拉菜单中选择“发送转义序列”；最后输入字符'b'。
向后单词跳转 对于 ⌥+→，重复上述步骤，但这次使用字符'f'。
以下是我的补充:
光标移动 行级移动 ⌃ + a 移动到行首 （ahead）
⌃ + e 移动到行末 （end）
单词级移动 ^ + ←
^ + →
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e350aac7b3b87d05d09560179389948b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f597bbc97847a06b75dca7a84aa173e/" rel="bookmark">
			CryptBot 伪装成破解软件进行传播
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CryptBot 最早在 2019 年被发现，近期再次爆发。最新版本的 CryptBot 已经显著简化，只包含信息窃取的功能，样本大小相比以前小得多。
CryptBot 针对敏感的用户数据，例如浏览器登录信息、加密货币钱包、存储的信用卡信息、密码等信息。收集到的信息会被发送回 C&amp;C
服务器，出售获取经济利益。
破解软件网站 CryptBot
最近通过破解软件网站进行分发，这些网站提供的是常见游戏和其他软件的破解版。攻击者通过这种方式捆绑传播恶意软件，让受害者不知不觉中下载并执行恶意样本。
技术分析 CryptBot 的攻击链条起始于受害者访问失陷的页面下载 SFX 文件，如伪装成最新版本的 Adobe Photoshop。
网页示例
随后，将名为 7ZSfxMod_x86.exe的 SFX 文件下载到机器上。
恶意文件
解压后，名为 7ZipSfx.000的文件夹在 %Temp%目录中创建。其中，数字会随着文件数量与解压次数变化。例如，第二次解压将会创建名为
7ZipSfx.001的文件夹。
文件夹
文件夹中包含四个文件，用于下一阶段的攻击：
aeFdOLFszTz.dll，ntdll.dll 的副本文件
Avevano.gif，BAT 脚本
Carne.gif，混淆的 AutoIT 脚本
Raccontero.exe，AutoIT v3 可执行解释器
如上所示，两个伪装成 GIF 图片的文件都是恶意脚本。不同版本的 CryptBot 还会使用 .MP3 与 .WMV 作为扩展名。
BAT 恶意脚本如下所示。脚本对安全产品（BullGuardCore 和 Panda Cloud
Antivirus）进行扫描，如果存在将会延迟执行以逃避检测。
恶意脚本
如下所示，BAT 恶意脚本解密高度混淆的 AutoIT 脚本 Carne.gif，BAT 还会将 AutoIT 脚本复制到虚拟内存区域运行。
混淆脚本
使用 AutoIT 可执行解释器 Raccontero.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3f597bbc97847a06b75dca7a84aa173e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cdb2b2ba8dc317dc4affae42b27d58a1/" rel="bookmark">
			磁盘性能测试工具DiskSpd
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、DiskSpd工具介绍 https://github.com/microsoft/diskspd/releases 工具下载
https://github.com/Microsoft/diskspd 源码
https://github.com/Microsoft/diskspd/wiki/Command-line-and-parameters 参数
DiskSpd, PowerShell and storage performance: measuring IOPs, throughput and latency for both local disks and SMB file shares | Microsoft Learn
常用参数说明 -b&lt;size&gt; [K|M|G]：表示块大小（以字节、KiB、MiB 或 GiB为单位），默认块大小为 64 KiB。
-c&lt;size&gt;[K|M|G|b]：设置测试中创建使用的示例文件大小。 可以按字节、KiB、MiB、GiB 或块进行设置。
-D&lt;milliseconds&gt;：捕获 IOPS 统计信息（例如标准偏差），时间间隔为毫秒[default=1000,1second]。
-d&lt;seconds&gt;：指定测试的持续时间，不包括冷却或预热时间。 默认值为 10 秒，但对于任何繁重的工作负荷，建议至少使用 60 秒。
-L：度量延迟统计信息。
-o&lt;count&gt;：表示每个线程的每个目标的未完成 I/O 请求数， 也称为队列深度。
-r&lt;align&gt;[K|M|G|b]：随机 I/O 对齐测试，默认值为4K，不加-r为顺序I/O测试。
-Suw：禁用软件和硬件写入缓存（等效于 -Sh）。
-t&lt;count&gt;：表示每个目标的线程数，默认是单线程。
-w&lt;percentage&gt;：指定属于写入请求操作的百分比（不写-w或-w或者-w0 等效于100%读取）。 如：-w25代表有25%的写，75%的读。
二、 随机读写时延测试 -b4k -o1，随机读/写测试，能反映硬盘的时延性能
测试硬盘的随机读时延 diskspd.exe -o1 -b4k –r4k -w0 -d120 -Sh -D -L -c10G D:\tset.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cdb2b2ba8dc317dc4affae42b27d58a1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f501d0dbd2e6260737b91bdcc03e274/" rel="bookmark">
			MINIO安装（centos7）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		步骤1：安装wget 在开始安装MinIO之前，需要安装wget命令行工具。可以使用以下命令在CentOS系统中安装wget：
sudo yum install wget 步骤2：下载MinIO wget https://dl.minio.org.cn/server/minio/release/linux-amd64/minio 将下载的minio复制到安装目录
mkdir /usr/local/minio cp minio /usr/local/minio/ cd /usr/local/minio/ 步骤3：授予MinIO文件可执行权限 在下载MinIO二进制文件之后，需要授予文件可执行权限。可以使用以下命令：
chmod +x minio 测试
新建启动脚本
vim start-minio.sh
export MINIO_ROOT_USER=root export MINIO_ROOT_PASSWORD=12345678 # ./minio server /usr/local/minio/data &gt; /usr/local/minio/minio.log 2&gt;&amp;1 &amp; # 这个使新版的，把后台管理设置为9111端口，api接口和访问默认还是9000 ./minio server --console-address 0.0.0.0:9111 /usr/local/minio/data &gt; /usr/local/minio/minio.log 2&gt;&amp;1 &amp; chmod +x start-minio.sh ./start-minio.sh 访问http://192.168.23.130:9111/login
新建imooc buckets
修改公开权限
文件上传
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61ef87a9770a7b78d489092f32bb9298/" rel="bookmark">
			图像特征匹配-SIFT函数应用【opencv】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 相关函数sift.detectAndComputecv.drawKeypointscv.KeyPointcv2.BFMatcher 相关函数 OpenCV中SIFT（Scale-Invariant Feature Transform）算法的一个重要函数。SIFT算法是一种用于图像特征提取和匹配的经典方法，可以在图像中提取出具有尺度不变性、旋转不变性和部分视角不变性的特征点和特征描述子
sift.detectAndCompute 功能
detectAndCompute函数执行两个主要任务：
（1）检测图像中的关键点（Key Points）。
（2） 计算图像中每个关键点的特征描述子（Feature Descriptors）。输入参数
image: 输入的灰度图像或彩色图像，类型为uint8或float32。
mask（可选）: 可选的掩膜图像，指定哪些区域需要进行特征检测。如果不需要，可以将其设置为None。
kp（可选）: 可选的输入关键点。如果提供关键点，则函数将不再检测关键点，而是直接使用输入的关键点。如果不需要，可以将其设置为None。
descriptors（可选）: 可选的输入特征描述子。如果提供特征描述子，则函数将不再计算特征描述子，而是直接使用输入的描述子。如果不需要，可以将其设置为None。输出结果
kp: 检测到的关键点列表，每个关键点是一个cv2.KeyPoint对象，其中包含关键点的坐标（x、y）、尺度（scale）和方向（angle）等信息。
des: 计算得到的特征描述子，是一个numpy数组，形状为(n, 128)，其中n是关键点的数量，128表示每个特征描述子的维度为128。使用案例 import cv2 # 读取图像 image = cv2.imread("example.jpg", cv2.IMREAD_GRAYSCALE) # 创建SIFT对象 sift = cv2.SIFT_create() # 检测关键点并计算特征描述子 kp, des = sift.detectAndCompute(image, None) # 绘制关键点到图像上 image_with_keypoints = cv2.drawKeypoints(image, kp, None) # 显示结果 cv2.imshow("Image with Keypoints", image_with_keypoints) cv2.waitKey(0) cv2.destroyAllWindows() cv.drawKeypoints cv.drawKeypoints是OpenCV库中的一个函数，用于在图像上绘制特征点。
函数原型 cv.drawKeypoints(image, keypoints, outImage[, color[, flags]]) 参数说明
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/61ef87a9770a7b78d489092f32bb9298/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d8628c1d7eb4fab540506997ac9f489/" rel="bookmark">
			harbor2.8.3安装步骤step by step
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开始 网上找的步骤都有点问题，不能做到step by step成功，所以记录下我的步骤。
包准备 harbor包下载，我下的是离线版
https://github.com/goharbor/harbor/releases
docker-compose 和 docker 自行安装
安装 tar zxvf harbor-offline-installer-v2.8.3.tgz -C /usr/local/ cd /usr/local/harbor/ cp harbor.yml.tmpl harbor.yml vim harbor.yml ## 只用修改hostname和http端口，再把https的内容删除或者注释 hostname: 192.168.7.135 http: port: 1180 保存，退出 ./install.sh 打开浏览器输入192.168.7.135：1180，默认账户admin/Harbor12345，可以在harbor.yml中修改。
在项目里可以看到有library这个默认项目，这样就安装完毕了。 测试 先上传一个包，在本机上操作 [root@localhost harbor]# docker login -u admin -p Harbor12345 http://127.0.0.1:1180 WARNING! Using --password via the CLI is insecure. Use --password-stdin. WARNING! Your password will be stored unencrypted in /root/.docker/config.json. Configure a credential helper to remove this warning.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5d8628c1d7eb4fab540506997ac9f489/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b404462c83488c02f9845f08b137e35c/" rel="bookmark">
			C&#43;&#43;STL中 vector和set容器的用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1：vector容器
什么是vector容器
vector 实现的是一个动态数组，即可以进行元素的插入和删除，在此过程中，vector 会动态调整所占用的内存空间，整个过程无需人工干预。
vector 常被称为向量容器，因为该容器擅长在尾部插入或删除元素，在常量时间内就可以完成，时间复杂度为O(1)；而对于在容器头部或者中部插入或删除元素，则花费时间要长一些（移动元素需要耗费时间），时间复杂度为线性阶O(n)。
创建
vector&lt;类型&gt;名字（初始大小）
vector&lt;int&gt; primes {2, 3, 5, 7, 11, 13, 17, 19};
vector&lt;double&gt; values(20, 1.0);（初始化20个1.0）
int array[]={1,2,3};
vector&lt;int&gt;values(array, array+2);//values 将保存{1,2}
2:set容器
什么是关联容器
此类容器在存储元素值的同时，还会为各元素额外再配备一个值（又称为“键”，其本质也是一个 C++ 基础数据类型或自定义类型的元素），它的功能是在使用关联式容器的过程中，如果已知目标元素的键的值，则直接通过该键就可以找到目标元素，而无需再通过遍历整个容器的方式。
什么是set容器
定义在 &lt;set&gt; 头文件中，使用该容器存储的数据，各个元素键和值完全相同，且各个元素的值不能重复（保证了各元素键的唯一性）。该容器会自动根据各个元素的键（其实也就是元素值）的大小进行升序排序（调用 std::less&lt;T&gt;）。
用法：
set&lt;std::string&gt; myset;
set&lt;std::string&gt; copyset(myset);
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e161060f284661f837610f06a8ce1608/" rel="bookmark">
			基于kafka(3.0版本之前)的日志收集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于kafka(3.0版本之前)的日志收集项目 什么是kafka 简介：
Kafka是由Apache软件基金会开发的一个开源流处理平台，由Scala和Java编写。Kafka是一种高吞吐量的分布式发布订阅消息系统，它可以处理消费者在网站中的所有动作流数据。 这种动作（网页浏览，搜索和其他用户的行动）是在现代网络上的许多社会功能的一个关键因素。 这些数据通常是由于吞吐量的要求而通过处理日志和日志聚合来解决。 对于像Hadoop一样的日志数据和离线分析系统，但又要求实时处理的限制，这是一个可行的解决方案。Kafka的目的是通过Hadoop的并行加载机制来统一线上和离线的消息处理，也是为了通过集群来提供实时的消息。
特性：
1、Kafka是一种高吞吐量的分布式发布订阅消息系统
2、通过O(1)的磁盘数据结构提供消息的持久化，这种结构对于即使数以TB的消息存储也能够保持长时间的稳定性能。
3、高吞吐量 ：即使是非常普通的硬件Kafka也可以支持每秒数百万的消息。
4、支持通过Kafka服务器和消费机集群来分区消息。
5、支持Hadoop并行数据加载。
原理图：
一、kafka搭建流程 1、环境准备 准备四台虚拟机（实验所用，所以将nginx就搭建在kafka服务器上，其中三台搭建kafka集群和nginx集群，一台搭建mysql）
主机IP地址nginx-kafka-1192.168.220.11nginx-kafka-2192.168.220.105nginx-kafka-3192.168.220.106mysql192.168.220.107 配置好dns
[root@nginx-kafka01 ~]# cat /etc/resolv.conf # Generated by NetworkManager nameserver 114.114.114.114 修改主机名，并且在每一台机器上都写好域名解析
# 修改主机名 vim /etc/hosthname hostname -F /etc/hostname # 每一台机器上都写好域名解析 vim /etc/hosts 192.168.220.11 nginx-kafka01 192.168.220.105 nginx-kafka02 192.168.220.109 nginx-kafka03 同步时间，并且关闭防火墙和selinux（每台机都要操作）
[root@nginx-kafka01 ~]# yum -y install chrony # 设置开机自启 disable 关闭开机自启 [root@nginx-kafka01 ~]# systemctl enable chronyd [root@nginx-kafka01 ~]# systemctl start chronyd # 设置时区 [root@nginx-kafka01 ~]# cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime # 永久关闭firewalld [root@nginx-kafka01 ~]# systemctl stop firewalld [root@nginx-kafka01 ~]# systemctl disable firewalld # 永久关闭selinux [root@nginx-kafka01 ~]# vim /etc/selinux/config 使SELINUX=disabled 2、nginx的安装（之前有安装搭建的博客） 3、kafka的安装 1、下载java环境，kafka是由java写的，需要java环境
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e161060f284661f837610f06a8ce1608/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4230c164fbf272699b87f43670f8487c/" rel="bookmark">
			N: 无法安全地用该源进行更新，所以默认禁用该源。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决方法 Ubuntu 的软件源配置文件是 /etc/apt/sources.list
打开这个文件夹，如果没有权限更改，那就使用下面这条命令进行提升权限
sudo chmod 777 /etc/apt/sources.list 你的里面内容可能时这样的，看起来很复杂 ，其实起作用的没几行，大部分都是注释。
把没注释的那几行的内容，后边的https://改为http://
全部更改，然后保存退出，此时再进行更新软件列表就应该没有错误了。
如果你把上边的那个文件里面的内容已经改的面目全非了，但还是不对，不要怕
x86源：
ubuntu | 镜像站使用帮助 | 清华大学开源软件镜像站 | Tsinghua Open Source Mirror
arm64源： ubuntu-ports | 镜像站使用帮助 | 清华大学开源软件镜像站 | Tsinghua Open Source Mirror
然后更新一下软件列表试试 即 在终端运行 sudo apt-get update
同样，它会报这个错，然后安装上面的方式把https://这里的s去掉变成http:// 这样应该就不报错。如果不报错，那就正常用把
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cbfd4dbafdf7ef2aea197977aabce490/" rel="bookmark">
			SpringBoot项目-个人博客系统的实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.博客系统简要分析 一共有6个网页，分别是博客列表页面，博客详情页面，发布博客页面，博客登陆页面，博客更新页面，修改个人信息页面（暂未实现），我们要实现的功能有，实现博客列表的展示页面，博客详情页面的展示功能，用户登录功能，显示用户信息功能，编辑博客功能，发布博客功能，删除博客功能，退出登录功能
我们现在就开始写吧
2.创建springBoot项目 1.创建项目，勾选需要的依赖 2.删除无用的目录及文件 4.创建框架 3.配置文件（选择yml） application.xml
spring: profiles: active: dev logging: file: path: logs/ level: root: info application-dev.xml
spring: datasource: url: jdbc:mysql://127.0.0.1:3306/java_blog_spring?characterEncoding=utf8 username: root password: 111111 driver-class-name: com.mysql.cj.jdbc.Driver mybatis: configuration: # 配置打印 MyBatis 执行的 SQL log-impl: org.apache.ibatis.logging.stdout.StdOutImpl map-underscore-to-camel-case: true #自动驼峰转换 mapper-locations: classpath:mapper/***Mapper.xml application-prod.xml
spring: datasource: url: jdbc:mysql://127.0.0.1:3306/java_blog_spring?characterEncoding=utf8 username: root password: 111111 driver-class-name: com.mysql.cj.jdbc.Driver mybatis: #上线就不用打印mybatis执行日志 configuration: map-underscore-to-camel-case: true #自动驼峰转换 3.数据库准备 这个项目的数据库表比较简单
只有两个表
1.设计表结构 2.建表sql -- 建表SQL create database if not exists `java_blog_spring1` charset utf8mb4; -- 用户表 drop table if exists `java_blog_spring`.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cbfd4dbafdf7ef2aea197977aabce490/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9031de1a2ced855da4661e52678d3cd/" rel="bookmark">
			内核ebpf基础知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概念 BPF（Berkeley Packet Filter），中文翻译为伯克利包过滤器，是类 Unix 系统上数据链路层的一种原始接口，提供原始链路层封包的收发。BPF 在数据包过滤上引入了两大革新：
基于虚拟机 (VM) 设计，可以有效地工作在基于寄存器结构的 CPU 之上。
应用程序使用缓存只复制与过滤数据包相关的数据，不会复制数据包的所有信息。这样可以最大程度地减少BPF 处理的数据。
tcpdump就是采用 BPF 作为底层包过滤技术(libcap)，我们可以在命令后面增加-d来查看tcpdump过滤条件的底层汇编指令。
$ tcpdump -d 'ip and tcp port 8080' (000) ldh [12] (001) jeq #0x800 jt 2	jf 12 (002) ldb [23] (003) jeq #0x6 jt 4	jf 12 (004) ldh [20] (005) jset #0x1fff jt 12	jf 6 (006) ldxb 4*([14]&amp;0xf) (007) ldh [x + 14] (008) jeq #0x1f90 jt 11	jf 9 (009) ldh [x + 16] (010) jeq #0x1f90 jt 11	jf 12 (011) ret #262144 (012) ret #0 什么是 eBPF
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a9031de1a2ced855da4661e52678d3cd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cfe4a322c9054c29e0c8fff34f067bea/" rel="bookmark">
			二分查找【Java算法】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 概念2. 思路3. 代码实现 1. 概念 二分查找又叫折半查找，要求待查找的序列有序，每次取中间位置的值与待查关键字比较，如果待查关键字比中间位置的值小，则在前半部分循环这个查找的过程，反之，在后半部分循环这个查找的过程。直到查到了为止，否则序列中没有待查的关键字。
2. 思路 ① while 循环折半，什么时候停止？在不断折半的过程中，我们的目标区间是不断缩小的，当左边界开始大于右边界的时候就是循环应该停止的时候，在以下代码中，我用 left 表示左边界（初始值为0），right 表示右边界（初始值为数组长度减1）；
② 折半之后有个中间值，我们试图拿它来跟待查找关键字进行比对，因为待查找序列是从大到小排列的，当然是小的在左边大的在右边，通过比较中间值和待查找关键字的大小，我们就进一步缩小了查找的范围。下面我用 mid 作为中间值变量，它的位置为左边界与右边界之和除2；
③ 向右查找，即待查关键字大于中间值。这时候我们的右边界是不需要动的，左边界应是中间中间位置的下一位，即 mid + 1；
④ 向左查找，即待查关键字小于中间值。这时候左边界是不需要动的，右边界应是中间位置的上一位，即 mid - 1；
⑤ 什么情况下查找成功呢？当中间值恰好等于待查关键字的时候，查找成功。 返回 mid + 1；
⑥ 就那么确定你能查到？万一人家这个序列里根本就没有你要的这个数据呢？所以这里我们还要给出一个回应，能查到好说直接就结束程序，如果找到最后了也没找到，自然是要退出 while 循环的，然后给它返回一个 -1，代表我们并没有找到这个值。
3. 代码实现 public class Main { public static void main(String[] args) { int[] arr = {2, 4, 5, 6, 7, 8, 10, 11}; int result = select(arr, 10); System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cfe4a322c9054c29e0c8fff34f067bea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/934021110466c68c19f910ae52b4ab0d/" rel="bookmark">
			基于javaweb&#43;springboot的仓库管理系统设计和实现(java&#43;ssm&#43;springboot&#43;layui)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		主要功能模块
1.用户模块管理：用户登录、用户注册、用户的查询、添加、删除操作、
2.客户信息管理：.客户列表的展示、添加、修改、删除操作、
3.供应商管理：供应商详情列表的查看、添加、删除等操作、
4.退货管理和退货查询
5.公告信息管理：公告信息的查看、添加、修改、删除操作、
6.角色管理：角色查询、添加、删除、
7.系统管理、菜单管理以及权限控制
8.管理员信息管理：管理员信息的查看、修改
给大家截一部分效果图:
主要技术：springboot Java、springmvc mysql layui jquery mybatis
用户信息控制层：
适用
课程设计，大作业，毕业设计，项目练习，学习演示等
/** * 跳转到部门管理 * */ @RequestMapping("toDeptManager") public String toDeptManager() { return "system/dept/deptManager"; } /** * 跳转到部门管理-left * */ @RequestMapping("toDeptLeft") public String toDeptLeft() { return "system/dept/deptLeft"; } queryWrapper.like(StringUtils.isNotBlank(deptVo.getRemark()), "remark", deptVo.getRemark()); queryWrapper.eq(deptVo.getId()!=null, "id", deptVo.getId()).or().eq(deptVo.getId()!=null,"pid", deptVo.getId()); queryWrapper.orderByAsc("ordernum"); this.deptService.page(page, queryWrapper); return new DataGridView(page.getTotal(), page.getRecords()); } /** * 加载最大的排序码 * @param deptVo * @return */ @RequestMapping("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/934021110466c68c19f910ae52b4ab0d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8fe4b9532c5a83f3d9e1216f05c4e9e5/" rel="bookmark">
			记录一下google aab包转apk
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.安装Java环境https://download.oracle.com/java/20/latest/jdk-20_windows-x64_bin.exe
2.bundletool下载地址：https://github.com/google/bundletool/releases
3.将下载的bundletool和已经生成的aab包放同一文件夹
4.运行命令
java -jar bundletool-all-1.15.2.jar build-apks --mode=universal --bundle=C:\aabToapk\20211230.aab --output=aa.apks --ks=C:\aabToapk\sign.jks --ks-pass=pass:**** --ks-key-alias=**** --key-pass=pass:****
5.将生产的aa.apks改为aa.zip解压，就会得到一个名为universal.apk的安装包
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/499a53427288bf7d21865019d4b82572/" rel="bookmark">
			FPGA学习——蜂鸣器实现音乐播放器并播放两只老虎
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、蜂鸣器简介1.1 蜂鸣器分类1.2 PWM 二、C4开发板原理图三、如何产生不同的音调四、代码实现及分析五、总结 一、蜂鸣器简介 1.1 蜂鸣器分类 蜂鸣器一般分为有源蜂鸣器和无源蜂鸣器。二者的区别在于，有源蜂鸣器内部含有振动源和功放电路，只需上电便可发出鸣叫。而无源蜂鸣器内部不含振动源和功放电路，因此我们需要给予其PWM方波，才能驱动无源蜂鸣器正常工作。
1.2 PWM PWM即脉冲脉宽调制，PWM的占空比是指在一个完整的时钟周期内，高电平所占时间占整个时钟周期的比例（50%占空比即高低电平各占一半时钟周期），为方便代码编写，本项目产生的PWM均为50%占空比。
二、C4开发板原理图 博主所用开发板为Cyclone Ⅳ开发板，开发板芯片为：EP4CE6F17C8，由开发板原理图可以看出，本开发板蜂鸣器低电平有效。
三、如何产生不同的音调 我们可以通过给予无源蜂鸣器不同频率的PWM方波信号从而实现不同的音调音符。
相关数据参考可见下图：
举个例子：博主所用开发板晶振为50MHz，而低音Do的频率为262，因此我们需要在一秒内产生50MHz/262次PWM方波信号，此时蜂鸣器变会发出低音Do（如有错误请指正，博主是这样理解的，乐理知识匮乏，请见谅）。
两只老虎的乐谱如下：
四、代码实现及分析 本次项目较为简单，仅有一个蜂鸣器模块。
源码分析：
本次项目首先需要一个音符计数器，用来存放歌曲中的音符数目，由乐谱可知两只老虎共含有34个音符，因此我们需要一个6位宽的计数器用来计数到34（后续发现好像乐谱中间隔比较大的是空拍？各位可以自行调整）除此之外，本次项目需要一个节拍计数器，不过这方面也是乐理知识，博主不太懂，两只老虎好像是一秒四拍，所以我们需要设计一个250ms计数器用来记一拍（也就是一个音符播放的时间）同时我们自然需要一个计数音符频率的计数器。由于不同音符的频率不尽相同，因此我们可以很自然地想到需要引入一个中间信号，通过case第几个音符，给予中间信号不同的频率值。另外由于本项目生成的PWM均为50%占空比，因此需要一个中间信号duty，duty为音符频率的一半，音符频率计数器小于duty时蜂鸣器输出0，否则输出1. module beep ( input wire clk , input wire rst_n , input wire beep_en , output reg beep //输出蜂鸣器 ); //内部参数定义 parameter CYCLE = 26'd50_000_000 ; parameter TIME = 24'd12_500_000 ; parameter NUM = 6'd34 ; parameter DOL = CYCLE/262 , REL = CYCLE/294 , MIL = CYCLE/330 , FAL = CYCLE/349 , SOL = CYCLE/392 , LAL = CYCLE/440 , XIL = CYCLE/494 , DOM = CYCLE/523 , REM = CYCLE/587 , MIM = CYCLE/659 , FAM = CYCLE/698 , SOM = CYCLE/784 , LAM = CYCLE/880 , XIM = CYCLE/988 , DOH = CYCLE/1047 , REH = CYCLE/1175 , MIH = CYCLE/1319 , FAH = CYCLE/1397 , SOH = CYCLE/1568 , LAH = CYCLE/1760 , XIH = CYCLE/1967 ; //内部信号定义 reg [5:0] cnt_num ;//音符个数寄存器 wire add_cnt_num ; wire end_cnt_num ; reg [23:0] cnt_250 ;//一拍时间寄存器 wire add_cnt_250 ; wire end_cnt_250 ; reg [17:0] cnt_frq ;//音符频率寄存器 wire add_cnt_frq ; wire end_cnt_frq ; reg [17:0] frq ;//中间信号，存储音符频率 wire [16:0] duty ;//中间信号，用于比较产生50%PWM //250ms计数器 always @(posedge clk or negedge rst_n) begin if(!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/499a53427288bf7d21865019d4b82572/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb809853712feb8bf778de05c338c7f1/" rel="bookmark">
			【大连理工大学城市学院毕业设计】基于SSM的校园二手商品交易平台设计与实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘 要
调查发现，随着当今时代的快速发展，越来越多的大学生购买力不断增强，使得各类产品的更新换代速度加快，因此就造成了大学校园普遍存在着大量的闲置物品，另外校园人口众多，年龄相仿，而且大学生的平时生活习惯和兴趣爱好在很多方面具有很高的相似性，他们使用的物品也是有着很高的重复相似度。这些物品的更新和废弃不仅浪费了资源，还对环境造成了污染。为了解决这一问题，本文设计并实现了一个基于SSM框架和MySQL数据库的校园二手商品交易平台。该平台采用B/S架构，包括用户管理、商品管理、交易管理、系统管理等模块，同时也提供闲置物品信息和求购信息等服务。
在系统设计和实现过程中，本文注重了系统的安全性和用户体验，采用了多种安全措施和优化策略，如数据加密和防范SQL注入等。通过单元测试、集成测试和性能测试等多种测试方法，本文开发的校园二手商品交易平台具有良好的功能和性能，能够满足用户的需求和期望。尽管本文所开发的平台仍存在一些问题，例如安全性、性能和用户体验等方面需要进一步改进，但本研究为推动校园二手商品交易平台的发展和壮大提供了一定的参考价值和实用意义。未来研究方向在于进一步完善和优化系统的功能和性能，提升系统的安全性和用户体验。总之，本文的研究对于解决校园内闲置物品的问题具有重要的现实意义和学术价值。
关键词：校园二手商品交易；SSM框架；MYSQL数据库
1.4研究内容 本文旨在研究基于SSM框架的校园二手商品交易平台的开发和实现，研究分为三个阶段：前期准备、中期实现和后期测试。
在前期准备阶段，需要对开发语言和使用技术进行详细的对比和研究，确定所采用的技术和实现方案。同时，需要了解用户需求，确认系统的功能，并展示模块图，以此确定数据库实体和实体间的联系。
中期实现阶段基于前期设计，进行系统代码的编写，其中模块命名统一，并在重要部分添加注释。此阶段需通过学习相关知识，并在网络平台进行实践，最终完成代码编写。需要注意的是，在编写代码时应遵循一定的规范和标准，确保代码的可读性和可维护性。
后期测试阶段需要对系统功能和性能等方面进行测试。在功能测试时，需要思考测试方法并进行测试，而性能测试则需要进行情景模拟和实现。校园二手商品交易平台的测试重点在代码和功能部分以及系统恢复性方面，并采用白盒和黑盒测试相结合的方式。测试结果需要及时记录和反馈，并进行问题分析和修复。
综上所述，基于SSM框架的校园二手商品交易平台的开发和实现需要经过前期准备、中期实现和后期测试三个阶段，需要仔细进行技术选型、用户需求分析、系统设计、代码编写和测试等工作，确保系统的稳定性和可靠性。同时，在开发过程中需要遵循规范和标准，保证代码的可读性和可维护性，以便后续的维护和升级。
1.5 论文结构 本文按照章节内容共六章进行了详细的阐述：
第一章为绪论，简要地阐述了选题的研究背景和研究的重要性，并简要分析了校园二手商品交易平台系统的发展过程，并对全文的章节和思想进行了总结。
第二章主要是介绍有关技术，以 Windows 10作为开发平台， 采用SSM框架作为后端框架，前端选用前端用 html语言编写，整体采用了MySQL数据库进行数据处理。这一章介绍了有关技术和为什么要利用这一技术来开发这款校园二手商品交易平台系统。[7]
第三章具体介绍了校园二手商品交易平台系统的需求，主要介绍了校园二手商品交易平台系统的基本需求，并对校园二手商品交易平台系统可行性做了详尽的介绍。
第四章为校园二手商品交易平台系统的设计，具体地介绍了其主要的功能，并提供了相关的数据库。
第五章为本论文的具体实现，本章对各模块的设计思路及实现方法进行了较为详尽的阐述，并提出了相关的设计思路，并给出了相关的软硬件接口。
第六章是系统的测试，在本文中，我们介绍了本课题的测试目的和实现方式，然后对该系统的主要功能进行了深入的分析，并进行了一些测试。
4.2系统结构设计 功能模块划分以用户的需求为主，结合同类软件的功能模块进行划分。基于SSM的闲置商品销售网站的功能模块分为前端和后端，校园二手商品交易平台的系统功能架构图如下图所示。
图4-1 系统功能架构图 5.1 系统功能流程图 根据系统概要设计，分析系统的整个流程。总结得出系统各个用户的本系统的业务功能流程图如图5-1。
图5-1业务功能流程图如图
5.2系统功能实现 5.2.1 系统学生界面 （1）系统首页界面
校园二手商品交易平台，在系统首页可以查看首页、闲置商品信息、求购信息、私下交易二手、私下交易回复、二手交易论坛、留言反馈、个人中心、后台管理、购物车等内容进行详细操作，如图5-2所示。
图5-2系统首页界面图 学生登录页面如图5-7所示，登录时输入错误的用户名或密码会有相应提示。
图 5-7 学生登录界面
（3） 闲置商品信息管理模块 图 5-8闲置商品信息管理界面
5.2.3 游客界面 游客点击留言反馈。进入该管理页面可以发布新的留言信息等操作。如图5-23所示
图 5-23 留言反馈界面
目 录
摘 要 I
Abstract II
第一章 绪论 1
1.1研究背景 1
1.2研究意义 1
1.3国内外研究现状 2
1.3.1国外现状 2
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fb809853712feb8bf778de05c338c7f1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08a68f4afee85279ca844f96087d555a/" rel="bookmark">
			Golang 性能基准测试（Benchmark）详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Golang性能基准测试可以帮助开发人员比较不同的实现方式对性能的影响，以便优化程序，本文就来讲解一下如何使用Golang的性能基准测试功能。
Golang 性能基准测试
Golang 中的性能基准测试是使用标准库 testing 来实现的，编写性能测试代码是很容易的：
创建性能测试文件：在 Go 项目的源代码目录下创建一个新的文件（和被测代码文件在同一个包），以 _test.go 为后缀名。例如，要测试net包中 dial.go 中的方法，在 net 包中创建一个名字为 dial_test.go 文件，和单元测试文件是一样的。
导入 testing 包：在测试文件中导入testing包，以使用相关的的函数和工具。
编写测试函数：在测试文件中，编写一个以 Benchmark 为前缀的函数，后面跟上一个或多个字符或字符组合来标识测试用例的名称（一般使用被测的函数名称），参数必须是 b *testing.B。
编写测试代码：b.N是基准测试框架提供的，表示循环的次数，因为需要反复调用测试代码来评估性能。b.N 的值会以1, 2, 5, 10, 20, 50, …这样的规律递增下去直到运行时间大于1秒钟，由于程序判断运行时间稳定才会停止运行，所以千万不要在loop循环里面使用一个变化的值作为函数的参数。
以 json 格式校验工具https://github.com/luduoxin/json-validator-go 为例，validator包中的 scanner.go 文件中的关键函数 Valid 用于校验给定字符串是否 json 格式，对应的性能测试文件为 scanner_test.go，里面的测试函数为 BenchmarkValid，代码如下：
package validator import "testing" func BenchmarkValid(b *testing.B) { str := `{"foo":"bar"}` b.ResetTimer() for i := 0; i &lt; b.N; i++ { Valid([]byte(str)) } 运行性能测试用例
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/08a68f4afee85279ca844f96087d555a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05fdb2aafe1aef67db07d60acdf16aa8/" rel="bookmark">
			软件为什么要进行性能压力测试？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		软件为什么要进行性能压力测试？随着软件应用的不断增多和复杂度的提高，软件的性能对用户体验和业务成功至关重要。性能问题可能导致软件运行缓慢、崩溃或无响应，给用户带来不便甚至损失。为了确保软件能够在高负载和压力下正常运行，性能压力测试变得至关重要。
性能压力测试是一种测试方法，用于评估软件在实际使用情况下的性能表现。它模拟大量用户同时访问和使用软件，以确定系统在高负载情况下是否能够满足性能需求。以下是为什么软件需要进行性能压力测试的几个重要原因：
用户体验：性能问题直接影响用户体验。当用户在使用软件时，如果遇到卡顿、加载时间过长或响应时间延迟等问题，他们可能会感到不满并选择放弃使用。通过性能压力测试，可以发现并解决软件中潜在的性能瓶颈，确保用户获得流畅、高效的体验。
可靠性和稳定性：性能问题可能导致软件崩溃或无响应，使业务陷入瘫痪。通过性能压力测试，可以确定软件是否能够在高负载和压力下保持可靠性和稳定性。这包括评估数据库的承载能力、服务器的负载均衡、网络带宽的压力等。通过发现并解决性能问题，可以提高软件的稳定性，减少系统崩溃和停机时间。
扩展和容量规划：随着用户数量的增加和业务的发展，软件需要具备扩展性和容量规划。性能压力测试可以帮助确定软件在不同负载下的性能表现，并评估系统是否具备足够的扩展潜力。这有助于制定合理的容量规划策略，避免未来业务增长过程中因为性能问题而造成的损失。
安全性和可靠性：性能问题可能给黑客或恶意用户利用的漏洞留下机会。例如，当软件在高负载下运行时，可能会导致某些安全措施失效或易受攻击。通过性能压力测试，可以识别和修复与安全相关的性能问题，确保软件在各种负载条件下的安全性和可靠性。
成本优化：性能问题往往需要付出巨大的成本来修复。通过在早期阶段进行性能压力测试，可以及时发现和解决性能瓶颈，避免后期修复的高昂成本。此外，优化软件性能还可以降低硬件要求，减少资源使用和运行成本，提高整体的效率。
综上所述，软件进行性能压力测试是确保软件在实际使用情况下能够满足性能需求的重要步骤。通过发现和解决潜在的性能问题，可以提高用户体验、增强软件的可靠性和稳定性，并为业务的持续发展提供支持。同时，性能压力测试也有助于优化成本，减少后期修复的风险和成本。因此，对于任何一个软件项目而言，性能压力测试都是不可或缺的环节。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30061a693c36d9401e03a3a9cbf6ea70/" rel="bookmark">
			js 键盘按键监听，实现快捷键CTRL &#43; S（保存）,CTRL&#43; Y（恢复）,CTRL&#43; Z（回撤）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		添加事件 mounted() { window.addEventListener('keydown', this.handleEvent) }, 注销事件 beforeDestroy() { window.removeEventListener('keydown', this.handleEvent) // 在页面销毁的时候记得解除 }, 监听方法 async handleEvent(event) { switch (event.keyCode) { case 37: console.log('ctrl + ←') break case 38: console.log('ctrl + ↑') break case 39: console.log('ctrl + →') break case 40: console.log('ctrl + ↓') break case 67: console.log('ctrl + c') break case 83: console.log('ctrl + s') event.preventDefault() event.returnValue = false // 阻止直接保存网页 // eslint-disable-next-line no-prototype-builtins if (event.ctrlKey &amp;&amp; event.code === 'KeyS' &amp;&amp; store.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/30061a693c36d9401e03a3a9cbf6ea70/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55576e2e64d4be2d0bf384eac926b5f6/" rel="bookmark">
			CSDN竞赛68期题解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		总结 近几期的题目质量有所提升，数据范围还是一如既往的没给。对于算法题，给定详细的数据范围，规范输入输出，再多给出几个样例以及样例说明，参赛的体验感才会提升。
题目列表 1.小球游戏 题目描述 某台有10个小球的游戏机，其设定的规则如下： 每一轮游戏在开始之前会把编号为0到9的小球依次放入从左到右编号也为0到9的10个位置；游戏开始后会快速对调任意 两个球的位置若干次，并在结束时要求观众写出从左到右的小球编号顺序，写对就得奖。 由于速度很快，所以直接靠观看写对很难。但有个程序员发现这台游戏机其实有一个固定的长度为n的操作序列数据库， 每一轮游戏都是随机取一个起始操作序列编号和一个结束操作序列编号（操作序列编号从1到n）并从起始到结束依次执行 每个操作序列编号对应的操作，而每个操作序列编号对应的操作就是对该次操作指定的两个编号的位置上的小球进行对 调。 现在给出操作序列数据库和每一轮游戏的起始操作序列编号和结束操作序列编号，求每轮游戏结束时从左到右的小球编号 顺序。
分析 前几期才考过的题目，但是貌似没有写过题解。题目比较长但是意思还是很简单的，按照题意直接模拟游戏操作，每轮游戏根据操作序列对原始序列对应位置上的小球进行交换即可。
代码 #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;vector&gt; using namespace std; const int N = 100005; pair&lt;int,int&gt; q[N]; int main() { int n,m; cin&gt;&gt;n&gt;&gt;m; for(int i = 1; i &lt;= n; i++) cin&gt;&gt;q[i].first&gt;&gt;q[i].second; int c,d; vector&lt;int&gt; p(10, 0); for(int i = 0; i &lt; 10; i++) p[i] = i; while(m--) { vector&lt;int&gt; t = p; cin&gt;&gt;c&gt;&gt;d; for(int i = c; i &lt;= d; i++) { swap(t[q[i].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/55576e2e64d4be2d0bf384eac926b5f6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2aa0439e841e6154243230ca651ff7fe/" rel="bookmark">
			Supervisor 自己挂掉 ,是怎么重启自己的
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Supervisor是一个守护进程，负责监控和管理其他进程。如果Supervisor自己挂掉了，它将无法继续监控和管理其他进程。为了确保Supervisor的稳定性和可用性，通常可以使用操作系统提供的一些方法来确保Supervisor在挂掉后能够自动重启。这样，一旦Supervisor挂掉，系统会自动将其重新启动，以便继续监控和管理其他进程。
在Linux系统中，可以使用以下方法来自动重启Supervisor：
使用Systemd：Systemd是Linux系统中的一个初始化系统，可以用来管理系统进程。您可以创建一个Systemd服务单元文件（.service文件），在其中定义Supervisor的配置和启动参数。然后，将该服务单元文件放置在Systemd的服务目录中，并启用该服务。这样，Systemd会负责监控Supervisor进程，并在挂掉后自动重新启动它。
使用Upstart：Upstart是一种旧的Linux初始化系统，可以类似于Systemd来管理进程。如果您的系统使用Upstart，您可以创建一个Upstart配置文件，并将其放置在相应的目录中。Upstart将根据配置自动监控Supervisor并在需要时进行重启。
使用init.d脚本：如果您的Linux系统使用传统的init.d脚本，您可以创建一个Supervisor的启动脚本，并将其放置在init.d目录中。然后，使用系统的服务管理命令（如service或chkconfig）来启用该脚本。系统会在启动时自动运行Supervisor，并在其挂掉时重新启动。
无论您选择使用哪种方法，这些都是确保Supervisor自动重启的常见做法。请注意，不同的Linux发行版可能有不同的初始化系统，因此具体的配置和命令可能会有所差异。在实际操作中，建议查阅您所使用Linux发行版的文档和手册，以获得更详细的配置指导。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91a9bb3f3740fb9c7fe20422cd1f7879/" rel="bookmark">
			安装.NET.Framework 3.5（包括.NET2.0和3.0）失败解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在调试一些硬件，配套的软件打开时提示需要.NET3.5，点击安装后总提示无法完成请求的更改，通过控制面板中的启用或关闭Windows功能也无法安装，经过不断地找方法尝试，最终得已解决，现将方法记录并分享。
电脑是win11的环境，版本是22H2，对于win10我想应该是同样适用的。
1、首先下载一个.NETfx3的镜像文件，此文件是从别处下载的，直接分享（链接：https://pan.baidu.com/s/1erA4yG2T__15_39Du8Lhhw?pwd=8k6t 提取码：8k6t）
2、解压缩之后将文件放到桌面，win+x打开Windows移动中心，选择其中的终端管理员
4、在其中输入以下命令
Dism /online /add-package /packagepath:"C:\Users\10955\Desktop\microsoft-windows-netfx3-ondemand-package~31bf3856ad364e35~amd64~~.cab"
其中双引号中（包括双引号）文件地址，右键点击刚刚放在桌面的文件后复制文件地址，直接粘贴进去，敲击回车，等待安装
中间可能会在某个进度卡一会，总的来说整个过程也就几分钟，成功后的界面如下：
此时可以打开控制面板，在启用或关闭Windows功能中可以看到.NET3.5已经被勾选。
操作成功完成后是一横线，不是对号，下图是因为我在点击前面的+号后，看到里面的项没有被勾选，我就将里面的勾选了，然后点击确定，结果里面的也安装成功了，我不确定我做的这一步是否是需要的，读者可以先不勾选，然后打开你原本提示需要.NET3.5的程序，看看是否能打开，如果不能，再尝试最后这一步。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a08d1429ec1338b48f2b27c1cf05ac1/" rel="bookmark">
			一条命令重启supervisor所有RUNNING状态的进程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 supervisorctl status | grep RUNNING | awk '{print $1}' | xargs -n1 supervisorctl restart 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c366e5f2e5b8ab56d3a71738315af643/" rel="bookmark">
			LeetCode·每日一题·722. 删除注释·模拟
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目 示例 思路 题意 -&gt; 给定一段代码，将代码中的注释删除并返回。
由于注释只有两种类型：
字符串// 表示行注释，表示//和其右侧的其余字符应该被忽略。字符串/* 表示一个块注释，它表示直到下一个（非重叠）出现的*/之间的所有字符都应该被忽略。（阅读顺序为从左到右）非重叠是指，字符串/*/并没有结束块注释，因为注释的结尾与开头相重叠。 那么可以直接模拟，逐行分析源代码。每个字符有两种情况，要么在一个注释内要么不在。因此我们用 in_block 变量来标记状态，该变量为 true 表示在注释内，反之则不在。
假设此刻不在注释块内：
遇到 ‘/*’，则将状态改为在注释块内，继续遍历后面第三个字符。遇到 ‘//’，则直接忽略该行后面的部分。遇到其他字符，将该字符记录到 new_line 中。 假设此刻在注释块内，遇到 ‘*/’，则将状态改为不在注释块内，继续遍历后面第三个字符。 我们用 new_line 记录新的一行，当遍历到每行的末尾时，如果不在注释块内并且 new_line 不为空，就把它放入答案中。
代码注释超级详细
代码 /** * Note: The returned array must be malloced, assume caller calls free(). */ #define MAX_LINE_LEN 80 char ** removeComments(char ** source, int sourceSize, int* returnSize) { char **res = (char **)calloc(sourceSize, sizeof(char *));//保存有效值 char new_line[sourceSize * 100 + 1];//临时数组 int pos = 0, new_line_pos = 0; bool in_block = false; for (int j = 0; j &lt; sourceSize; j++) {//遍历代码 char *line = source[j];//取当前字符串 int line_size = strlen(line); for (int i = 0; i &lt; line_size; i++) {//枚举每一个字符 if (in_block) { //判断注释结束位置 if (i + 1 &lt; line_size &amp;&amp; line[i] == '*' &amp;&amp; line[i + 1] == '/') { in_block = false; i++; } } else { //判断注释开始位置 if (i + 1 &lt; line_size &amp;&amp; line[i] == '/' &amp;&amp; line[i + 1] == '*') { in_block = true; i++; } else if (i + 1 &lt; line_size &amp;&amp; line[i] == '/' &amp;&amp; line[i + 1] == '/') { //行注释，直接跳过当前字符串 break; } else { //有效代码，记录 new_line[new_line_pos++] = line[i]; } } } //存储有效字符串 if (!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c366e5f2e5b8ab56d3a71738315af643/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c671750d52d364ec755c58857dd3cf3/" rel="bookmark">
			Mysql导出(多张表)表结构及表数据 mysqldump用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 命令行下具体用法如下： mysqldump -u用戶名 -p密码 -d 數據库名 表名 脚本名; 1、导出數據库為dbname的表结构（其中用戶名為root,密码為dbpasswd,生成的脚本名為db.sql） mysqldump -uroot -pdbpasswd -d dbname &gt;db.sql; 2、导出數據库為dbname某张表(test)结构 mysqldump -uroot -pdbpasswd -d dbname test&gt;db.sql; 3、导出數據库為dbname所有表结构及表數據（不加-d） mysqldump -uroot -pdbpasswd dbname &gt;db.sql; 4、导出數據库為dbname某张表(test)结构及表數據（不加-d） mysqldump -uroot -pdbpasswd dbname test&gt;db.sql; 5.导出数据中dbname多张表（test1,test2,test3）结构及表数据用用空格隔开 mysqldump -uroot -pdbpasswd dbname test1 test2 test3&gt;db.sql; 导入数据库： (1)将数据表 test_user.sql 导入到test 数据库的test_user 表中 [root@test ~]# mysql -uroot -p test &lt; /www/web/test/test_user.sql (2)source命令不在控制台下，要进入mysql下操作 mysql&gt; use test; mysql&gt;source /www/web/test/test.sql 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/665f8954eadf1e17f9cc8b0a1947f95b/" rel="bookmark">
			Vue学习 之 MacOS 安装 vue-cli
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Vue学习 之 MacOS 安装 vue-clivue-cli 简介vue-cli 安装 Vue学习 之 MacOS 安装 vue-cli vue-cli 简介 vue-cli（Vue Command Line Interface）是Vue.js官方提供的一个脚手架工具，它提供了一些命令，可以帮助我们创建基于Vue.js的项目模板，快速开发Vue.js单页面应用（SPA）。使用vue-cli可以配置构建工具、插件、路由、状态管理等等，可以大大提升开发效率，减少重复操作。
vue-cli 安装 vue-cli 的安装需要先安装 Node.js 和 npm，建议先安装好 Node.js 和 npm 后再进行下面的安装步骤。
在命令行窗口中输入以下命令可以全局安装 vue-cli：
sudo npm install -g vue-cli 回车后需输入密码。
安装完成后可以通过以下命令验证是否安装成功：
vue -V 如果正确显示版本号，则说明安装成功。
完整步骤如下：
➜ ~ sudo npm install -g vue-cli Password: npm WARN deprecated vue-cli@2.9.6: This package has been deprecated in favour of @vue/cli npm WARN deprecated uuid@3.4.0: Please upgrade to version 7 or higher.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/665f8954eadf1e17f9cc8b0a1947f95b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9136e1859a840af2dee1f138f36916cd/" rel="bookmark">
			Docker镜像
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		查看本地容器镜像 docker images docker image list docker image ls 它存放在本地什么位置:/var/lib/docker
image docker image --help
image是一套命令,可以通过帮助查看
远程镜像 Docker Hub
本地没有的镜像去哪里搜索呢? 搜索远程镜像
docker search centos 这个命令搜索的网址: hub.docker.com
下载远程镜像 docker pull mysql[:5.7] # tag可选,tag一般当做版本使用 [root@centos133 ~]# docker pull mysql # 不指定版本,默认下载lates Using default tag: latest latest: Pulling from library/mysql # 这下面每一行都是代表容器的一层,它是一层层下载的 72a69066d2fe: Pull complete 93619dbc5b36: Pull complete 99da31dd6142: Pull complete 626033c43d70: Pull complete 37d5d7efb64e: Pull complete ac563158d721: Pull complete d2ba16033dad: Pull complete 688ba7d5c01a: Pull complete 00e060b6d11d: Pull complete 1c04857f594f: Pull complete 4d7cfa90e6ea: Pull complete e0431212d27d: Pull complete Digest: sha256:e9027fe4d91c0153429607251656806cc784e914937271037f7738bd5b8e7709 Status: Downloaded newer image for mysql:latest docker.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9136e1859a840af2dee1f138f36916cd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40c5d81a1e4a2c8eba0671efa5804ebc/" rel="bookmark">
			【力扣】 12. 整数转罗马数字 模拟
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		力扣 12. 整数转罗马数字
解题思路 当某个位数的某个数不为4或9时，高位对应的字符总是在低位对应的字符前面。只有当该数为4或9时，低位对应的字符在高位前面。	根据这一特性，我们进行分类讨论。 1.当数为4时，则对应的罗马数为 10 ^ 幂次（对应该数位的次数）加上5 * 10 ^ 幂次。 如40，则对应的罗马数为 X（10）L（50）。 2.当数为9时，则对应的罗马数为 10 ^ 幂次（对应该数位的次数）加上5 * 10 ^ 幂次。 如90，则对应的罗马数为 X（10）C（100）。 3.当数为其他时，如果大于5，则先加上 5 * 10 ^ 幂次对应的罗马数，再加上 除5余数个数的 10^幂次对应的罗马数。如8，对应的罗马数为 V（5对应的罗马数）III（3个1对应的罗马数） 实现代码 class Solution { public: string intToRoman(int num) { int quotient = 1; //当前位数的幂次； string resStr = ""; while(num != 0){ int mod = num % 10; string str; if(mod == 9){ str.append(1, GetRoman(quotient)); str.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/40c5d81a1e4a2c8eba0671efa5804ebc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1de58261d9c75d448bfe9db5ad6fe8c/" rel="bookmark">
			（洛谷入门系列，适合洛谷新用户）洛谷功能全解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前注
前言
第一章 进入方式
1.1 基础操作
1.2 两步验证
1.3 安全邮箱和安全手机
第二章 侧栏与主界面介绍
2.1 蓝底白色洛谷标志
2.2 “应用&gt;&gt;”
2.3 题库
2.4 题单
2.5 比赛
2.6 记录
2.7 讨论
2.8 打卡
2.9 跳题及其右侧栏目
2.10 犇犇
第三章 个人中心
3.1 直接点击头像或用户名
3.2 个人设置
3.3 我的收藏
3.4 我的团队
3.5 我的比赛
3.6 我的博客
3.7 我的题库
3.8 锁定&amp;登出
​
第四章 开肝！！！
4.1 开始做题
4.2 特殊介绍-Retome Judge
4.3 题目的题解、提交记录、讨论区、推荐题目
4.4 题单
4.5 比赛
4.6 纪录
后记
前注 本篇文章写作于2022年1月，若洛谷此后有变动，可以私信我，我将找时间修改此文章。更新日志也会列于此处。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d1de58261d9c75d448bfe9db5ad6fe8c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4fc16126812186246619eba840730391/" rel="bookmark">
			python中for..in语法的原理？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天发现了python中一个比较有意思的小设计。
如果要通过中括号[]访问元素，需要重写__get__item()函数，这个应该没什么疑问，测试代码如下：
class Classroom: def __init__(self, students): self.students = students def __getitem__(self, sid): for s in self.students: if s.sid == sid: return s def __len__(self): return len(self.students) class Student: def __init__(self, sid, name): self.sid = sid self.name = name def __repr__(self): return str.format("sid: {}, name: {}", self.sid, self.name) if __name__ == '__main__': class_room = Classroom([Student(12, "小明"), Student(13, "小华")]) print(class_room[12]) 通过中括号加学号的方式，可以获得对应学号的学生，代码顺利执行，没问题。
在我想要用for...in迭代时
if __name__ == '__main__': class_room = Classroom([Student(12, "小明"), Student(13, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4fc16126812186246619eba840730391/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/577e9ee3790d42c36ca85ed10cae71ec/" rel="bookmark">
			Django-admin的基本使用，以及预览显示[object]，自定义显示名问题的处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Django-admin的基本使用，以及预览显示[object]，自定义显示名问题的处理 这里只讲解admin的简单使用,复杂使用请见后续文章 Django-admin是Django本身自带的后台管理工具，可以让开发者方便的通过网页管理数据表，进行相关的数据库增删查改等操作，并且与Django定义的函数等高度依赖。
1. Django-admin使用准备 使用Django-admin需要进行以下几个步骤
1.1 注册admin App 创建Django项目时如果指定了使用Django - admin，则会自动注册该App
setting.py
INSTALLED_APPS = [ "django.contrib.admin", # -&gt; admin App "django.contrib.auth", "django.contrib.contenttypes", "django.contrib.sessions", "django.contrib.messages", "django.contrib.staticfiles", "App01", "my_user", ] 1.2 注册admin路由 默认会自动注册admin的路由，即/admin，当然我们可以自定义更改为其他路由。
from django.contrib import admin from django.urls import path, urlpatterns = [ path("admin/", admin.site.urls), # Django管理员的入口admin.site.urls ] 1.3 迁移数据库,生成相关的Django管理员表 # 生成数据库迁移文件 python ./manage.py makemigrations # 执行迁移 python ./manage.py migrate 生成完毕后,我们可以发现数据库中多了auth相关的表,这些都是Django-admin相关数据表
1.4 创建Django-admin超级管理员用户 python ./manage.py createsuperuser --&gt; 用户名 (leave blank to use '本机计算机用户名'): # 这里输入用户名,不输入则会用计算机用户名命名 电子邮件地址: # 空即可 Password: # 输入密码和确认密码即可 创建完成后,再去查看auth_user表，就会发现已经创建了一个新用户。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/577e9ee3790d42c36ca85ed10cae71ec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41d261591b91353414c7b83165570098/" rel="bookmark">
			单元测试之- mock工具mockito
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		常用的mock工具mockito
在编写单元测试时，需要mock依赖的对象，减少依赖对象对测试的影响，Mocktio是常用的mock工具之一，那么mockito提供了哪些功能呢？
Mock对象的创建和配置：Mockito可以通过简单的语法创建mock对象，并允许你配置mock对象的行为。
Mock对象的验证：Mockito提供了一系列的验证方法，可以帮助你验证mock对象的方法是否被正确调用，以及调用次数、参数等信息是否符合预期。
Stubbing（桩）：Mockito允许你为mock对象的方法设置返回值或者抛出异常，这个过程被称为Stubbing（桩）。
Spy（间谍）：Mockito允许你创建一个实际的对象，但你可以使用Mockito来监控对象的某些行为。
参数匹配器：Mockito提供了多种参数匹配器，可以帮助你验证mock对象方法的调用是否符合预期。例如，any()可以匹配任何参数，eq()可以匹配一个指定的值等。
Annotation支持：Mockito支持在测试中使用注解来简化mock对象的创建和管理，例如@Mock和@Spy。
下面是一些实际例子，通过这些例子可以了解到如何使用Mockito框架来mock方法行为，并进行不同目的的验证，例如验证方法的返回，方法是否被调用过。
除了对返回结果和是否被调用进行测试外，还可以测试执行的方法是否超时，方法执行顺序等。具体例子如下所示：
上面是一个直接mock List class的例子，接下来看看mock一个自定义的class。下面的例子中，OneClass中依赖TwoClass，如果要对OneClass进行测试，那么需要Mock TwoClass这个class。除了直接用Mockito.mock(ClassName.class)进行mock外，还可以使用注解@Mock，@InjectedMock。如下图右图所示：
使用@InjectMocks注解时，Mockito会自动查找并将标记为@Mock的对象注入到被测类中，从而实现依赖注入。当测试类中需要模拟依赖对象的行为时，我们可以使用@Mock来创建这些虚拟对象，并在测试中定义它们的行为和返回值。所以@Mock和@InjectMocks一般配合使用，这样不用手动将依赖的mock对象设置到被测class的构造函数中，或者属性中。除了@Mock和@InjectMocks注解外，在测试class上面，还有@ExtendWith(MockitoExtension.class)。@ExtendWith(MockitoExtension.class)告诉JUnit 5在运行测试时，使用MockitoExtension来扩展测试执行环境，从而支持Mockito相关的功能，例如使用@Mock、@InjectMocks等注解。如果是Junit4，那么使用@RunWith(MockitoJUnitRunner.class)。
需要注意一点：Mockito是基于动态代理的框架，它可以模拟Java接口和普通的类，但对于一些特殊类型的类，例如静态类、final类和私有构造函数的类，Mockito是无法直接进行模拟。如果是3.4.0或者以上版本的mockito，可以mock静态class。对于某些特定情况，还可以引入powermock来进行mock，或者不mock，直接使用真实对象。
PowerMock 是一个用于 Java 开发的扩展测试框架，可以与 Mockito 集成使用。PowerMock 可以用于 Mockito 无法 Mock 的一些场景，例如：
静态方法和私有方法的 Mock
Final 类和 Final 方法的 Mock
构造函数的Mock
静态初始化块的Mock
在使用powermock时，需要注意的是，PowerMock 通过使用 Java Instrumentation API 进行字节码操作来实现上述功能，因此使用 PowerMock 需要引入一些额外的依赖，并且可能会影响测试的性能和稳定性。同时，PowerMock 对代码的修改可能会影响代码的可维护性和可读性，因此需要谨慎使用。在编写单元测试过程中，除了选择合适的工具外，还需要解决好单元测试可测性问题。
单元测试可测性问题
代码中存在过多的依赖：当代码中存在大量的依赖关系时，单元测试变得困难，因为要在测试环境中创建和管理所有依赖的对象和资源。此时可以使用依赖注入、抽象工厂等技术来减少依赖关系，从而提高代码的可测试性。
代码中存在过多的状态：当代码中存在大量的状态时，单元测试也变得困难，因为需要在测试中管理和维护状态。此时可以使用不可变对象、纯函数等技术来减少状态的影响，从而提高代码的可测试性。
代码中存在难以模拟的外部资源：当代码中存在难以模拟的外部资源时，单元测试也变得困难，例如数据库、网络等。此时可以使用测试替身、内存数据库等技术来模拟外部资源，从而提高代码的可测试性。更多mocktio工具使用详情信息可查看官网信息。
前面的例子都是比较单一的例子，下面给出一个完成的demo，来看看如何为里面的class编写单元测试。如下图所示，包含repository，model，service，util四部分，被测代码PersonService中依赖的对象有PersonRequest,Person,SalaryCalculatehe TimeUtil，其中SalaryCalculatehe TimeUtil是静态类。
下面是为PersonalService编写的单元测试，可以看到，因为PersonRequest对象是model是一个请求对象，所以，直接用New的方式创建了PersonRequest。对于静态类，这里使用了mockStatic方法来模拟。单元测试中测试了if逻辑的两种结果。
再来看看依赖数据库的class如何编写单元测试，下面是UserRegistration的代码，代码中调用了userRepository class，Repository会依赖数据哭。
下面是为UserRegistration方法编写的单元测试，也是验证了if逻辑中的两种场景。单元测试中通过@Mock模拟了依赖的UserRepository class。
以上就是单元测试的一些基础知识介绍。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4e44192ccda717b35cc1b9470a9ad7b/" rel="bookmark">
			利用Python爬虫爬取淘宝商品做数据挖掘分析实战篇，超详细教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如需完整代码，加 LiteMango（付费）
项目内容
本案例选择&gt;&gt; 商品类目：沙发；
数量：共100页 4400个商品；
筛选条件：天猫、销量从高到低、价格500元以上。
以下是分析，源码点击文末链接
项目目的
1. 对商品标题进行文本分析 词云可视化
2. 不同关键词word对应的sales的统计分析
3. 商品的价格分布情况分析
4. 商品的销量分布情况分析
5. 不同价格区间的商品的平均销量分布
6. 商品价格对销量的影响分析
7. 商品价格对销售额的影响分析
8. 不同省份或城市的商品数量分布
9.不同省份的商品平均销量分布
注：本项目仅以以上几项分析为例。
项目步骤
1. 数据采集：Python爬取淘宝网商品数据
2. 对数据进行清洗和处理
3. 文本分析：jieba分词、wordcloud可视化
4. 数据柱形图可视化 barh
5. 数据直方图可视化 hist
6. 数据散点图可视化 scatter
7. 数据回归分析可视化 regplot
工具&amp;模块：
工具：本案例代码编辑工具 Anaconda的Spyder
模块：requests、retrying、missingno、jieba、matplotlib、wordcloud、imread、seaborn 等。
原代码和相关文档文末自取
一、爬取数据
因淘宝网是反爬虫的，虽然使用多线程、修改headers参数，但仍然不能保证每次100%爬取，所以 我增加了循环爬取，每次循环爬取未爬取成功的页 直至所有页爬取成功停止。
说明：淘宝商品页为JSON格式 这里使用正则表达式进行解析；
代码如下：
二、数据清洗、处理：
(此步骤也可以在Excel中完成 再读入数据)
代码如下：
说明：根据需求，本案例中只取了 item_loc, raw_title, view_price, view_sales 这4列数据，主要对 标题、区域、价格、销量 进行分析。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d4e44192ccda717b35cc1b9470a9ad7b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43ce80da145c0fc61538b45e2168bcc1/" rel="bookmark">
			python批量修改word文档，替换word文档文字
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前写了一个python脚本，用于姜数据库中的数据批量写入到word模板中，生成很多份报告。
但是模板并不是万能的，有时候会因为某个填充的数据为空导致那句话没有用，需要删掉或者微调。
因此，需要再写一个python文件做一个批量的修改。这里我用到了python中的docx这个库。
doc = docx.Document(‘xxx.docx’) for p in doc.paragraphs: tmp = ‘’ runs = p.runs for i, run in enumerate(runs): if run.text: tmp += run.text if 'xxx' in tmp: run.text = run.text.replace(run.text, tmp) run.text = run.text.replace(‘xxx’, '替换后的字符串') tmp = '' doc.save('xxx.docx') 后来又发现了一个问题，word文本框中的文章是替换不了的，经过检索（百度）可以这样实现文本框内的文字修改：
document = Document('xxx.docx') children = document.element.body.iter() for child in children: if child.tag.endswith('txbx'): for ci in child.iter(): if ci.tag.endswith('main}t'): if '要修改的文字' in ci.text: ci.text = '修改后的文字' document.save('xxx.docx') 参考python修改word文本框中的内容_python改变输入框内容_zwy_0309的博客-CSDN博客
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/43ce80da145c0fc61538b45e2168bcc1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c069ebda59c11526cdd79f09b1451558/" rel="bookmark">
			【C&#43;&#43;】基于多设计模式下的同步&amp;异步日志系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		✍作者：阿润021
📖专栏：C++
文章目录 一、项目介绍二、项目实现准备工作1.日志系统技术实现策略2.相关技术知识补充2.1 不定参函数设计2.2 设计模式 三、日志项目框架设计1.模块划分2.各模块关系图 四、详细代码实现1.实用工具类设计2.日志等级类设计3.日志消息类设计4.日志输出格式化模块5.日志落地模块(简单工厂模式)6.日志器类(Logger)设计（建造者模式）7. 双缓冲区异步任务处理器（AsyncLooper）设计8.异步日志器(AsyncLogger)设计9.单例日志器管理类设计（单例模式）10.日志宏&amp;全局接口设计（代理模式） 五、项目测试参考资料 一、项目介绍 简介
本项目主要实现一个日志系统，它可以根据不同的级别、配置和策略，以同步或异步的方式，将日志信息可靠地写入控制台文件或滚动文件中，同时支持多线程并发写日志和扩展不同的日志落地目标地模式。
开发环境：
• CentOS 7
• vscode/vim
• g++/gdb
• Makefile
核心技术
1.类层次设计：如继承和多态的应用
2.C++11：如多线程、auto、智能指针、右值引⽤等
3. 双缓冲区设计：实现异步日志器
4. 生产消费模型：
5. 多线程：实现并发输出日志
6. 设计模式：单例日志管理器类设计、⼯⼚模式、代理模式、模板等
环境搭建
本项目不依赖其他任何第三⽅库， 只需要安装好CentOS/Ubuntu + vscode/vim环境即可开发。
测试结果展示：
为什么需要日志系统？
• 生产环境的产品为了保证其稳定性及安全性是不允许开发⼈员附加调试器去排查问题， 可以借助日志志系统来打印⼀些日志帮助开发⼈员解决问题
• 上线客户端的产品出现bug无法复现并解决， 可以借助⽇志系统打印⽇志并上传到服务端帮助开发⼈员进⾏分析
• 对于⼀些⾼频操作（如定时器、心跳包）在少量调试次数下可能⽆法触发我们想要的⾏为，通过断点的暂停⽅式，我们不得不重复操作⼏⼗次、上百次甚⾄更多，导致排查问题效率是⾮常低下， 可以借助打印⽇志的⽅式查问题
• 在分布式、多线程/多进程代码中， 出现bug⽐较难以定位， 可以借助⽇志系统打印log帮助定位bug
• 帮助首次接触项目代码的新开发人员理解代码的运⾏流程
二、项目实现准备工作 1.日志系统技术实现策略 日志系统的技术实现主要包括三种类型:
利用printf、std::cout等输出函数将⽇志信息打印到控制台
对于⼤型商业化项目， 为了放便排查问题，我们⼀般会将⽇志输出到⽂件或者是数据库系统⽅便查询和分析日志， 主要分为同步日志和异步日志方式:
1&gt; 同步写日志
2&gt; 异步写日志
同步写日志
同步⽇志是指当输出⽇志时，必须等待⽇志输出语句执⾏完毕后，才能执⾏后⾯的业务逻辑语句，⽇志输出语句与程序的业务逻辑语句将在同⼀个线程运⾏。每次调⽤⼀次打印⽇志API就对应⼀次系统调⽤write写⽇志⽂件。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c069ebda59c11526cdd79f09b1451558/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a9f8e5f7d8a92b1ec22d00518f0d6a2/" rel="bookmark">
			【vue3 $refs和特殊attr：ref 】获取子组件实例 &amp; 规范获取Dom元素；（统称模板引用）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		# ref （内置的特殊attribute） 预期值 string | Function ref 用来给元素或子组件注册引用信息。注册内容会在父组件的 $refs 对象上。如果在普通的 DOM 元素上使用，引用指向的就是那个 DOM 元素；如果用在子组件上，引用就指向组件实例！
关于 ref 的重要说明：在初始化组件时你不能访问 ref 绑定的对应内容 ——它们还不存在！$refs 也是非响应式的，因此你不应该试图用它在模板中做数据绑定。
尽管存在 prop 和事件，但有时你可能仍然需要在 JavaScript 中直接访问子组件。为此，可以使用 ref attribute 为子组件指定引用 ID。见 案例 2 或 3；
注意！由于vue工程项目是单页面应用，由多个组件组成的一个路由页面，也就意味着用原生DOM操作获取标签元素存在获取错误（拿到其他组件的同id、class等元素）的情况；
所以在vue里，采用 $refs + 元素 ref 值绑定来获取DOM元素的作为规范标准最合适。
4 5种场景的代码示例：（没其他的了）
&lt;template&gt; &lt;!-- 1. vm.$refs.p 会是 DOM 节点 --&gt; &lt;p ref="p"&gt;hello&lt;/p&gt; &lt;!-- 2. vm.$refs.child 会是子组件实例 --&gt; &lt;child-component ref="child"&gt;&lt;/child-component&gt; &lt;!-- 3. 当动态绑定时，我们可以将 ref 定义为回调函数，显式地传递元素或组件实例 --&gt; &lt;child-component :ref="(el) =&gt; fnGetEl = el"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8a9f8e5f7d8a92b1ec22d00518f0d6a2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3be68b596ee453a1d14f6de385699e0/" rel="bookmark">
			得到VGG19某个卷积层的输出结果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 from torchvision import models,transforms import torch from PIL import Image from torch import nn preprocess_transform = transforms.Compose([ transforms.Resize((900, 600)), transforms.ToTensor() ]) dev = torch.device("cuda") def load_image(img_path): image = Image.open(img_path).convert('RGB') return preprocess_transform(image).unsqueeze(0).to(dev) model = models.vgg19(pretrained=True) model = model.to(dev) print(model) img_path = 'img/building.png' image = load_image(img_path) # (1,3,600,900) print(image.shape) # outputs = model(image) x = image layers_outputs = [] for l in model.features: x = l(x) if isinstance(l, nn.Conv2d): layers_outputs.append(x) print(layers_outputs) # 想要哪一层拿哪一层 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5fe3da492839adf11dae1d5b792f990/" rel="bookmark">
			Linux 磁盘管理及磁盘分区（主分区、扩展分区、逻辑分区）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1 MBR与磁盘分区
1.1 分区的意义 1.2 MBR分区
1.2 磁盘分区的表示
1.3 磁盘分区结构
2 文件系统
2.1 XFS 2.2 swap
2.3 FAT16、FAT32
2.4 EXT4
2.5 JFS
3 磁盘分区工具
3.1 fdisk
3.2 添加磁盘
3.3 磁盘分区
3.4 blkid
​编辑
3.5 mkfs
4 挂载及永久挂载
4.1 mount
4.2 临时挂载
4.3 永久挂载
1 MBR与磁盘分区 windows 当中是可以不分区的
linux 当中一定要分区 才可以使用硬盘 1.1 分区的意义 优化I/O性能 读写
实现磁盘空间配额限制
提高修复速度
隔离系统和程序
安装多个OS
采用不同文件系统
1.2 MBR分区 MBR 分区最多只能分四个区
MBR位于硬盘第一个物理扇区处 , MBR中包含硬盘的主引导程序和硬盘分区表第一个扇区总共512字节，前446字节是主引导记录，分区表保存在扇区中的第447-512字节中。分区表有4个分区记录区，每个分区记录区占16字节 Linux中将硬盘、分区等设备均表示为文件。
1.2 磁盘分区的表示 Linux内核读取光驱、硬盘等资源时，都是通过“设备文件”的形式进行，因此，将硬盘和分区分别表示为不同的文件。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c5fe3da492839adf11dae1d5b792f990/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f1e81384309268bca4762a01027e874/" rel="bookmark">
			使用docker部署一个jar项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介: 通过docker镜像, docker可以在服务器上运行包含项目所需运行环境的docker容器, 在线仓库里有很多各个软件公司官方发布的镜像, 或者第三方的镜像. 如果我们需要使用docker把我们的应用程序打包成镜像, 别的机器上只要安装了docker, 就可以直接运行镜像, 而不需要再安装应用程序所需要的环境(比如 jre)了.
定制自己的镜像: 更新已有的镜像,再构建新的自定义镜像.
1. 使用docker pull 镜像名:版本从在线docker仓库中拉取一个镜像 docker pull ubuntu:18.04 ​ 使用docker images 可以看到你的镜像: (默认路径: /var/lib/docker/containers)
root@iZbp13tcf8gaqn21r6m8viZ:/var/lib/docker/containers# docker images REPOSITORY TAG IMAGE ID CREATED SIZE lifetrack 1.0 881e666fc6b3 21 minutes ago 1.49GB ubuntu_jdk 1.0 42d9398e7f50 40 minutes ago 1.46GB ubuntu 18.04 8e4ce0a6ce69 3 weeks ago 64.2MB star7th/showdoc latest e169aaaa88e2 3 months ago 389MB 各个选项说明:
REPOSITORY：表示镜像的仓库源
TAG：镜像的标签
IMAGE ID：镜像ID
CREATED：镜像创建时间
SIZE：镜像大小
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5f1e81384309268bca4762a01027e874/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca6275d77f496b2dfe8ae09da74e62b2/" rel="bookmark">
			【mysql】 this is incompatible with sql_mode=only_full_group_by 修改数据库的默认sql-mode，去除 only_full_group_by
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 事件起因环境和工具解决办法临时解决办法永久的解决办法 总结：结束语 事件起因 在重新安装了数据库后，运行之前的一个项目，在首页的查询遇到了这么一个问题，报错信息如下所示：
详细信息如下所示：
xxx on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by
系统异常请稍后再试 ### Error querying database. Cause: java.sql.SQLSyntaxErrorException: Expression #1 of SELECT list is not in GROUP BY clause and contains nonaggregated column 'jiangxi_vr.t.station_id' which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by ### The error may exist in file [D:\desktop\job_project\jiangxi-nanchang\jiangxi-nancang-yidong-vr-backend\target\classes\mapper\pc\BusinessStationMapper.xml] ### The error may involve defaultParameterMap ### The error occurred while setting parameters ### SQL: select t.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ca6275d77f496b2dfe8ae09da74e62b2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71f09ad4cba36efa53ea1db0b4f1b163/" rel="bookmark">
			SeaTunnel 2.3.2 UDF 实现步骤step by step
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开始 官方的文档写的实在是少，走了不少弯路，特此记录下来，供需要的人做个参考吧。
步骤 创建maven工程 注意这里是创建空工程，不是下面那个maven，那个试了半天没成功过。
点create
然后删掉这个main，自己创建一个类，起名qdmxUDF
代码如下：
package org.example; import com.google.auto.service.AutoService; import org.apache.seatunnel.api.table.type.BasicType; import org.apache.seatunnel.api.table.type.SeaTunnelDataType; import org.apache.seatunnel.transform.sql.zeta.ZetaUDF; import java.util.List; @AutoService(ZetaUDF.class) public class qdmxUDF implements ZetaUDF { @Override public String functionName() { return "qdmx"; } @Override public SeaTunnelDataType&lt;?&gt; resultType(List&lt;SeaTunnelDataType&lt;?&gt;&gt; list) { return BasicType.STRING_TYPE; } @Override public Object evaluate(List&lt;Object&gt; list) { String str = list.get(0).toString(); return "b:"+list.get(0).toString(); } } pom.xml内容如下：
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;artifactId&gt;udf3&lt;/artifactId&gt; &lt;version&gt;1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/71f09ad4cba36efa53ea1db0b4f1b163/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8eabd459e65d082327d7ba25f91ec64/" rel="bookmark">
			小朋友都能看懂的《排列和组合》
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这位小朋友请坐好, 今天, 老师要讲的是《排列和组合》 这节课要好好听哦, 你以后的生活中会遇到这一类问题的
排列: 问: A B C, 3选2, 有序, 有几种排列方式?
答: 6种: AB, AC, BA, BC, CA, CB
分析:
3选2: 先3选1, 再2选1, 即 3 x 2
5选3: 先5选1, 再4选1, 再3选1, 即 5 x 4 x 3
n选m: 先n选1, 再n-1选1, …, 再n-m选1, 即 n x (n-1) x … x (n-m)
考试:
问: 100选5
答: 100 x 99 x 98 x 97 x 96
简单吧?
记住, 排列是有序的
组合: 问: A B C, 3选2, 但忽略顺序, 有几种组合方式?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c8eabd459e65d082327d7ba25f91ec64/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70969070f3ddcd164104d390d0c67115/" rel="bookmark">
			本地mvn仓库清理无用jar包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 开发java时间久了，本地的m2仓库就会产生很多过期的jar包，不清理的话比较占空间。
原理 是通过比较同一目录下，对应jar包的版本号的大小，保留最大版本号那个，删除其他的。
脚本 执行脚本见文章顶部
执行方式 查看需要删除的jar包版本
php clearBigVersion.php
打印并删除jar包的历史版本
php clearBigVersion.php del
效果 清理了135G！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ef87d7c8a4c1fd9326efcaabbb4db59/" rel="bookmark">
			修改cuda软链接(实操演示)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1 找到已存在的CUDA软链接2 确认当前软链接真实路径3 删除现有软链接4 创建新的软链接5 验证新的软链接 要修改CUDA的软链接，需要找到已经存在的软链接并重新创建它指向新的目录。
1 找到已存在的CUDA软链接 首先，需要找到之前创建的CUDA软链接。通常，CUDA的默认安装路径是/usr/local/cuda，但是具体路径可能因安装方式而有所不同。可以在终端中运行以下命令找到当前的软链接目录：
ll /usr/local/ 2 确认当前软链接真实路径 realpath /etc/alternatives/cuda 希望把软链接整到cuda10
3 删除现有软链接 如果您希望重新创建软链接而不是修改现有的软链接，可以选择删除当前的软链接。如果不希望删除现有软链接，可跳过此步骤
要删除现有的软链接，可以使用以下命令：
rm /usr/local/cuda # 请注意，此命令会删除整个软链接目录，谨慎执行。 4 创建新的软链接 现在，可以重新创建CUDA的软链接，指向新的目录。假设新CUDA安装位于/path/to/new/cuda，则可以使用以下命令创建新的软链接：
ln -s /path/to/new/cuda /usr/local/cuda 5 验证新的软链接 完成上述步骤后，您可以再次运行以下命令来验证软链接是否已成功更新到新的目录：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d46400cedb8fd91385f2f4c0b9af9e0a/" rel="bookmark">
			矩阵按键行列扫描法与反转扫描法：原理、代码实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		矩阵按键：行列扫描法与反转扫描法
通常情况下，按键按下时会产生低电平信号，按键一般用低电平表示按下状态。
当按键没有被按下时，通常处于高电平状态，这是因为按键连接到电路时，内部的上拉电阻或外部的上拉电阻会将按键未按下的状态拉高为高电平。当按键被按下时，按键内部会导通，使连接到电路的引脚处于低电平状态，从而表示按键被按下。
这种低电平表示按下的设计方式是常见的，因为在数字电路中，低电平通常被认为是逻辑“0”，而高电平被认为是逻辑“1”。通过使用低电平表示按下，可以更容易地进行逻辑判断和控制。当然，也可以根据特定应用的需求，在设计中采用高电平表示按下，只需根据相应的逻辑处理即可。
1、矩阵按键行列扫描法： 原理： 矩阵按键行列扫描法是一种简单直观的按键扫描方法。在矩阵按键行列扫描法中，键盘的按键是通过行和列的交叉连接来构成一个矩阵。每个按键都位于一个行和一个列的交点上。通过轮询扫描的方式，逐个检测按键的状态。当有按键按下时，通过判断对应的行和列，可以确定按下的是哪一个按键。
一般来说：
行扫描，行线为低电平，列线为高电平。（就STC89C5类型的机子来说，一般都是用列扫描，以为行线端口有可能被其他的引脚占用（复用）（B站江协大的教学视频中的51单片机不建议用行扫描））
列扫描，行线为高电平，列线为低电平。
优点： 矩阵按键行列扫描法简单易懂，实现成本较低，适用于较小规模的键盘矩阵。
缺点： 随着键盘规模的增大，扫描效率会降低，因为需要逐一扫描每个按键。
矩阵按键行列扫描法（假设使用GPIO控制引脚）： #include &lt;stdio.h&gt;
#include &lt;stdbool.h&gt;
// 定义行列数量
#define NUM_ROWS 4
#define NUM_COLS 4
// 定义行列引脚
int rows[NUM_ROWS] = {R0, R1, R2, R3}; //数组中为具体引脚
int cols[NUM_COLS] = {C0, C1, C2, C3}; //数组中为具体引脚
// 初始化引脚状态
void setup() {
for (int i = 0; i &lt; NUM_ROWS; i++) {
pinMode(rows[i], OUTPUT); //行配置为输出模式，
digitalWrite(rows[i], LOW); //行初始化电平为低电平
}
for (int i = 0; i &lt; NUM_COLS; i++) {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d46400cedb8fd91385f2f4c0b9af9e0a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb8e5db6a0e7dac146c321b58993941f/" rel="bookmark">
			VIM 常用命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ctags 和 cscope 与vim搭配使用，效果更好
dd : ESC + dd = delete line
yy : ESC + yy = copy line
u : ESC +u = undo r : ESC + crtl + r = redo
对比： ESC + vertical diffsplit + (文件名)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c34e6bc56e115ff54ae70332cc87a929/" rel="bookmark">
			java -jar指定外部配置文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		场景 spingboot项目部署jar时,需要时常修改配置,为了方便,将配置文件放到jar包外
操作步骤 在jar包同级目录下创建config文件夹(位置没有强制要求,为了方便而已)
在jar包同级目录下创建start.bat文件,并编辑内容
@echo off :: 命令窗口标题 title yudibei_performance_test chcp 65001 :: 用 -Dspring.config.location 指定配置文件路径, -Dfile.encoding=utf-8 要放在-jar前面,不会控制台中文乱码 java -Dfile.encoding=utf-8 -jar D:\jar_test\test.jar -Dspring.config.location=D:\jar_test\config pause 直接双击start.bat进行启动
总结 启动jar之前设置参数 -Dspring.config.location 指向外部配置目录即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/833bbd47bebbafaf0c9ab4d3cf60d5d1/" rel="bookmark">
			centos环境minio安装踩坑指南2023年7月30日
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MinIO的安装踩坑指南 环境centos7
1. 安装MinIO官方文档 Binary下载 , 按照官网的路径配置比较快 下载minio wget https://dl.min.io/server/minio/release/linux-amd64/minio 修改minio的权限 chmod +x minio 移动下载的文件 到此文件夹下 sudo mv minio /usr/local/bin/ 2. 创建minio.service 放到/etc/systemd/system/ 目录下 推荐使用MobaXterm操作方便,可视化操作 [Unit] Description=MinIO Documentation=https://min.io/docs/minio/linux/index.html Wants=network-online.target After=network-online.target # 指的是下载的压缩 minio 文件路径 最后一个指的是文件 AssertFileIsExecutable=/usr/local/bin/minio # 添加用户和分组后面会操作无需改动 [Service] WorkingDirectory=/usr/local User=minio-user Group=minio-user # 此文件需要注释掉 不识别此标识 # ProtectProc=invisible #环境配置 需要创建一个minio文件 位置在 /etc/default/ 下 EnvironmentFile=-/etc/default/minio ExecStartPre=/bin/bash -c "if [ -z \"${MINIO_VOLUMES}\" ]; then echo \"Variable MINIO_VOLUMES not set in /etc/default/minio\"; exit 1; fi"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/833bbd47bebbafaf0c9ab4d3cf60d5d1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87d1e2ec3a686783cd3efe039732fb69/" rel="bookmark">
			Linux(二)---------网络命令学习（ifconfig命令）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.ifconfig命令 用于配置网卡ip地址信息，等网络参数信息，或者查看显示网络接口信息，类似于windows的ipconfig命令，还能够临时性的配置ip地址，子网掩码，广播地址，网关信息等。
注意ifconfig命令智能用root 去操作，且可能要单独安装这个命令。
1）运行这个命令之前需要安装一个net- tools,运行如下命令即可 yum install net-tools 2）查看命令的使用手册 ifconfig --help #第一种 man ifconfig #第二种 1.1.1 ifconfig使用案例 1）查看网络地址信息 ifconfig #查看所有的网络接口信息 ifconfig ens33 #查看指定的网络网卡信息 ls /etc/sysconfig/network-scripts/ #查看网络名字 [root@localhost ~]# ifconfig ens33 ens33: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1500 inet 192.168.23.141 netmask 255.255.255.0 broadcast 192.168.23.255 inet6 fe80::faf8:3a99:82b3:dac5 prefixlen 64 scopeid 0x20&lt;link&gt; ether 00:0c:29:ba:3a:30 txqueuelen 1000 (Ethernet) RX packets 2248 bytes 189371 (184.9 KiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 666 bytes 77860 (76.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/87d1e2ec3a686783cd3efe039732fb69/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/356ba4eb191f973ac299f89976bf4cef/" rel="bookmark">
			苍穹外卖-day10
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		苍穹外卖-day10 本项目学自黑马程序员的《苍穹外卖》项目，是瑞吉外卖的Plus版本
功能更多，更加丰富。
结合资料，和自己对学习过程中的一些看法和问题解决情况上传课件笔记
视频：https://www.bilibili.com/video/BV1TP411v7v6/?spm_id_from=333.337.search-card.all.click
资料：关注黑马程序员公众号----&gt;回复：苍穹外卖
一起学习，一起加油
【可以使用ApiFox代替YApi来导入的接口文档】
🙂 🙃 😉 😌 😍 🥰 😘 😗 😙 😚 😋 😛 😝 😜 🤪 🤨 🧐 🤓 😎 🤩 🥳
1、可以学习Spring Task和WebSocket
2、实现来单提醒和用户催单
文章目录 苍穹外卖-day101. Spring Task1.1 介绍1.2 cron表达式1.3 入门案例1.3.1 Spring Task使用步骤1.3.2 代码开发1.3.3 功能测试 2.订单状态定时处理2.1 需求分析2.2 代码开发2.3 功能测试 3. WebSocket3.1 介绍3.2 入门案例3.2.1 案例分析3.2.2 代码开发3.2.3 功能测试 4. 来单提醒4.1 需求分析和设计4.2 代码开发4.3 功能测试4.4 代码提交 5. 客户催单5.1 需求分析和设计5.2 代码开发5.2.1 Controller层5.2.2 Service层接口5.2.3 Service层实现类 5.3 功能测试5.4 代码提交 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/356ba4eb191f973ac299f89976bf4cef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf66e0072ec1ebe70a6460c80ed99d3e/" rel="bookmark">
			Java灵活操作Http请求（hutool）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java中有很多封装http请求的util包，我本人觉得最好用的是htool下面的HttpUtil和HttpRequest。代码很简洁，满足我对http操作的所有需求，嘎嘎好用，推荐给大家！
一、第一个HttpUtil，这个可以用于简单的Get和Post请求 1、GET请求例子：
// 最简单的HTTP请求，可以自动通过header等信息判断编码，不区分HTTP和HTTPS String result1= HttpUtil.get("https://www.baidu.com"); // 当无法识别页面编码的时候，可以自定义请求页面的编码 String result2= HttpUtil.get("https://www.baidu.com", CharsetUtil.CHARSET_UTF_8); //可以单独传入http参数，这样参数会自动做URL编码，拼接在URL中 HashMap&lt;String, Object&gt; paramMap = new HashMap&lt;&gt;(); paramMap.put("city", "北京"); String result3= HttpUtil.get("https://www.baidu.com", paramMap); 2、POST请求例子：
HashMap&lt;String, Object&gt; paramMap = new HashMap&lt;&gt;(); paramMap.put("city", "北京"); String result= HttpUtil.post("https://www.baidu.com", paramMap); 3、下载文件：
String fileUrl = "http://mirrors.sohu.com/centos/8.4.2105/isos/x86_64/CentOS-8.4.2105-x86_64-dvd1.iso"; //将文件下载后保存在E盘，返回结果为下载文件大小 long size = HttpUtil.downloadFile(fileUrl, FileUtil.file("e:/")); System.out.println("Download size: " + size); 二、第二个HttpRequest，这个用于比较复杂的Post请求 1、普通表单请求：
Map&lt;String, Object&gt; body = new HashMap&lt;&gt;(); body.put("username", "username"); body.put("password", "password"); String urlData= HttpRequest.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cf66e0072ec1ebe70a6460c80ed99d3e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c60ab6ce2f3ac8aaa09ad8e4d5d0b913/" rel="bookmark">
			LeetCode·每日一题·822. 翻转卡片游戏·哈希
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：小迅
链接：https://leetcode.cn/problems/card-flipping-game/solutions/2368969/ha-xi-zhu-shi-chao-ji-xiang-xi-by-xun-ge-7ivj/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
题目 思路 根据题意，只要有数字满足 fronts[i]=backs[i]，那么 fronts[i] 绝对不可能是答案，否则 fronts[i] 或者 backs[i] 作为背面的数字可以满足要求，取最小值作为答案。
我们可以先遍历一遍数组，找到满足 fronts[i]=backs[i] 的数字，存入哈希表 hash 中。然后再次遍历数组，找到不在 hash 中的数字，取最小值作为答案。如果所有数字都在 forbidden 中，返回 0
对于hash的实现，可以使用哈希库，当然本题数据规模比较小，可以使用数组哈希，更方便。
代码注释超级详细
代码 int flipgame(int* fronts, int frontsSize, int* backs, int backsSize){ int hash[2001] = {0};//数组哈希 for (int i = 0; i &lt; frontsSize; ++i) { if (fronts[i] == backs[i]) {//加入哈希表 ++hash[fronts[i]]; } } int min = INT_MAX; for (int i = 0; i &lt; frontsSize; ++i) { if (hash[fronts[i]] == 0) {//不在哈希表中的元素 min = fmin(min, fronts[i]);//取最小值 } if (hash[backs[i]] == 0) { min = fmin(min, backs[i]); } } return min == INT_MAX ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c60ab6ce2f3ac8aaa09ad8e4d5d0b913/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/622f0ff872462527a743662dad1d8ffa/" rel="bookmark">
			rt-thread-studio排除构建和添加构建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、排除构建
排除构建后，此文件会直接在资源管理器里消失，但并没有删除源文件，
2、添加构建
先打开导航器
再在导航器里找到文件，选择添加构建
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/becb20ee49e6b12e32e29033be923513/" rel="bookmark">
			给已有的linux系统增加磁盘容量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 给已有的linux系统增加磁盘容量 一、给系统增加磁盘二、fdisk -l新磁盘三、格式化磁盘四、创建组五、查看组的信息六、扩展 一、给系统增加磁盘 [root@localhost ~]# echo "- - -"&gt; /sys/class/scsi_host/host0/scan [root@localhost ~]# echo "- - -"&gt; /sys/class/scsi_host/host1/scan [root@localhost ~]# echo "- - -"&gt; /sys/class/scsi_host/host2/scan 二、fdisk -l新磁盘 sdb1是新硬盘
三、格式化磁盘 mkfs -t xfs /dev/sdb1 四、创建组 pvcreate /dev/vdb1 五、查看组的信息 vgs pvdisplay 六、扩展 vgextend centos /dev/sdb1 lvextend /dev/mapper/centos-root /dev/sdb1 刷新后
xfs_growfs /dev/mapper/centos-root 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a742aa6caefe4543fcd81a2451207d37/" rel="bookmark">
			网页串口 webSerial
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		index.html
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8" /&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; &lt;title&gt;&lt;/title&gt; &lt;script type="text/javascript"&gt; if(isIE() || isFirefox()){ alert('当前浏览器（IE浏览器、火狐浏览器）不支持网页串口！请使用Edge或谷歌浏览器访问！') } else{ window.location.href = "./b.html" } //判断是否为IE浏览器 function isIE(){ if(!!window.ActiveXObject || "ActiveXObject" in window){//ie浏览器不支持 return true; }else{ return false; } } // 判断是否为火狐浏览器 function isFirefox(){ str = navigator.userAgent; if(str.indexOf("Firefox") &gt;= 0){ return true } else{ return false } } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; b.html
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a742aa6caefe4543fcd81a2451207d37/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7574e21f5fcd9f5ef6fe0788e5e2a920/" rel="bookmark">
			项目编译时报错：error adding symbols：DSO missing from command line
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		运行项目时，出现以下报错信息，网上搜了很多资料，总结下来就是，当链接可执行文件时，依赖于libA.so，而libA.so又依赖于libB.so，而且可执行文件中还直接调用了libB.so中的函数，那么此时链接就会出现错误。
自从binutils 2.22版本以后，如果你在程序中使用了你依赖的动态库所依赖的动态库中的函数时，你就必须显式的指定你依赖的动态库所依赖的动态库。
binutils在2.22版本以后，默认把–no-copy-dt-needed-entries这个选项打开了，编译器在链接的时候是不会递归的去获取依赖动态库的依赖项的，于是就会出现上述的问题。
解决办法：使用–copy-dt-needed-entries
1、使用命令编译gcc main.cpp -L./ -Wl,–copy-dt-needed-entries -lA
2、qt项目，在pro文件中加入 QMAKE_LFLAGS += -Wl,–copy-dt-needed-entries，copy前面是两个-，这里显示不出来
3、cmake，可以通过使用set(CMAKE_EXE_LINKER_FLAGS “-Wl,–copy-dt-needed-entries”)将其添加到CMakeLists.txt中。
参考：https://blog.csdn.net/zrq293/article/details/105969423
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd11b9f8b76e850cce1e396bb5119253/" rel="bookmark">
			js获取元素的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		js 获取元素5种的方式 1、标签获取元素
getElementsByTagName()方法返回一个动态的包含所有指定标签名的元素的集合。
语法： document.getElementsByTagName(‘元素的标签名’)[下标];
&lt;body&gt; &lt;p id="demo"&gt;Hello World!&lt;/p&gt; &lt;p id="pro"&gt;Hi Jhon!&lt;/p&gt; &lt;/body&gt; &lt;script&gt; //根据标签改变字体颜色 var tagname = document.getElementsByTagName("p")[0]; tagname.style.color = "skyblue"; &lt;/script&gt; 2、id获取元素 getElementById() 返回一个匹配特定ID的元素 语法： document.getElementById(‘id’); &lt;body&gt; &lt;p id="demo"&gt;Hello World!&lt;/p&gt; &lt;button onclick="change()"&gt;点击改变&lt;/button&gt; &lt;/body&gt; &lt;script&gt; function change() { var element = document.getElementById("demo"); element.style.color = 'green'; } &lt;/script&gt; 3、通过class名字获取页面元素
getElementsByClassName()方法返回一个包含了所有指定类名的子元素的类数组对象，作为nodeList对象。
语法：document.getElementsByClassName(‘类名’)[下标];
&lt;body&gt; &lt;p&gt;hello world&lt;/p&gt; &lt;p class="text"&gt;类名为test&lt;/p&gt; &lt;div class="red text"&gt;第一个div&lt;/div&gt; &lt;div class="red"&gt;第二个div&lt;/div&gt; &lt;/body&gt; &lt;script&gt; //匹配类名的元素集合，不是元素本身 console.log(document.getElementsByClassName("text")); //获取类名为text的第一个元素 console.log(document.getElementsByClassName("text")[0]); //获取包含red text类名的所有元素 console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bd11b9f8b76e850cce1e396bb5119253/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba387733e057605d4d6aeb67063ea448/" rel="bookmark">
			C&#43;&#43;设计模式之过滤器设计模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C++过滤器设计模式 什么是过滤器设计模式 过滤器设计模式是一种行为型设计模式，它允许你在特定的条件下对输入或输出进行过滤，以便实现不同的功能。
该模式有什么优缺点 优点 可扩展性：过滤器设计模式允许您轻松地添加、删除或替换过滤器，从而可以灵活地扩展功能。模块化：过滤器设计模式将过滤器分离出来，使得每个过滤器可以独立地开发和测试，提高了代码的可维护性。可重用性：过滤器设计模式允许您将通用的过滤器抽象出来，以便在不同的场景下重用。 缺点 可能需要多个过滤器的组合：有时候需要将多个过滤器组合起来使用，这可能会导致出现复杂的的数据流图。可能存在性能问题：由于每个过滤器都需要对输入进行处理，因此如果处理过程很耗时，可能会对性能产生影响。 如何使用 下面是一个使用C++实现过滤器设计模式的例子：
#include &lt;iostream&gt; #include &lt;string&gt; #include &lt;vector&gt; // 定义过滤器接口 interface Filter { virtual std::string apply(std::string&amp; input) = 0; }; // 实现一个简单的过滤器 class UpperCaseFilter : public Filter { public: std::string apply(std::string&amp; input) override { return input.toUpperCase(); } }; // 实现一个复杂的过滤器，使用多个子过滤器 class CompositeFilter : public Filter { public: CompositeFilter(std::vector&lt;Filter*&gt;&amp; filters) : filters(filters) {} std::string apply(std::string&amp; input) override { for (auto filter : filters) { input = filter-&gt;apply(input); } return input; } private: std::vector&lt;Filter*&gt; filters; }; // 使用过滤器设计模式的例子 int main() { std::string input = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ba387733e057605d4d6aeb67063ea448/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd0e17e87519271a8a9e83befb45cfd8/" rel="bookmark">
			win10移动热点连不上无法连接 win10移动热点手机连不上
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转发：win10移动热点连不上无法连接 win10移动热点手机连不上-蜜蜂百科
win10移动热点打开后其他电脑和手机连不上，提示连接失败到底怎么回事？
操作方法 确认打开移动热点
点击以太网，选择更改网络适配器设置
找到移动热点网络
右击鼠标选择属性，进入设置菜单，选择IPv4
IPv4是手动设置IP地址，这里改为自动设置。点击确认保存
回到网络设备设置页面，选择以太网网络，右击选择属性
属性菜单页面选择网络共享，允许其他计算机网络通过此网络共享打上勾，下面选择要共享的热点网络，设置好点击保存即可。
这时就可以用手机连接了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8d85d4a2913864e67967e81cdfd6462/" rel="bookmark">
			sqlx使用教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		sqlx简介 sqlx是 Go 的软件包，它在出色的内置database/sql软件包的基础上提供了一组扩展。该库兼容sql原生包，同时又提供了更为强大的、优雅的查询、插入函数。
新建表 DROP TABLE IF EXISTS `people`; CREATE TABLE `people` ( `id` int(11) NOT NULL AUTO_INCREMENT, `name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL, `age` int(11) NULL DEFAULT NULL, PRIMARY KEY (`id`) USING BTREE ) ENGINE = InnoDB AUTO_INCREMENT = 3 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Dynamic; SET FOREIGN_KEY_CHECKS = 1; 连接数据库 下载依赖包
go get "github.com/go-sql-driver/mysql" go get "github.com/jmoiron/sqlx" 连接数据库
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f8d85d4a2913864e67967e81cdfd6462/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb8e680702f14b8db19c3c97ec959290/" rel="bookmark">
			SA-1B数据集转COCO数据集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		主要流程；
1 先把SA-1B数据集的.json文件读进来
2 通过coco自带的api将其RLE格式的segmentation的值转成mask格式
此处科普一下：
RLE: 用来表示目标在图像中的像素位置信息
coco数据集中，RLE格式用一个字典表示，包含两个字段：'size' 和 'counts'。'size' 是一个表示图像大小的列表，包含图像的高度和宽度。'counts' 是一个经过压缩的字节串，表示图像的二进制掩码，通过使用COCO API的函数，你可以将RLE格式解码为标准的Mask格式，也就是一个二维数组。
mask数组：
Mask格式是一种用于表示图像中目标位置的格式。它通常是一个二维数组（矩阵），与原始图像大小相同，其中的元素值为1表示该像素属于目标，值为0表示该像素不属于目标。Mask格式与目标在图像中的像素位置一一对应，因此可以准确地表示目标的形状。
3 将mask数组转成polygon坐标
4 归一化，写入.txt文件
Note：中途可以将其可视化以验证，代码如下
import random import numpy as np import cv2 from pycocotools import mask as coco_mask import json import matplotlib.pyplot as plt import time import os outputpath = '/Users/outputtxt/' def normalize_polygon_coordinates(polygon_coordinates_list,size): normalized_polygon_coordinates_list = [] for polygon_coordinates in polygon_coordinates_list: normalized_polygon = [] for x, y in polygon_coordinates: normalized_x = x / size[1] normalized_y = y / size[0] formatted_x = format(normalized_x, '.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cb8e680702f14b8db19c3c97ec959290/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3a484d8adeed97b832acc766498e0a2/" rel="bookmark">
			【IPTV详解三部曲】IPTV流行为分析篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		IPTV业务类型 IPTV业务主要直播、点播、回放等业务：
直播业务：对实时性有要求，节目源以组播流的方式转发直播业务，以组播流的形式转发既可减小运营商带宽资源浪费，又能实现用户的予取予求，即看CCTV1就取对应的组播流，换台CCTV2就取另一条组播流；点播/回放业务：无实时性要求，只要开通相关业务，就能从存储服务器或者视频源获取单播流，实现电视节目点播和录像回放。 IPTV工作流程 运营商IPTV业务基本普及全国，常见的入户光猫自带千兆上网口和1个iTV专用口，连接方式：
机顶盒工作流程：
报文分析 抓取光猫iTV接口与机顶盒交互报文，我们一起看看每个工作流程对应的数据是什么：
（1）拨号/DHCP方式获取网络参数（本例中机顶盒拿到的IP为23.1.255.254）
或者是通过PPPOE拨号方式获取网络参数
（2）验证IPTV业务开通使用
认证加载： 背后数据交互 （3）http/https加载主菜单内容，进入电视主菜单
界面显示： 背后数据交互： （4）观看电视直播
选中频道观看直播——即机顶盒IGMP report/join组播组，获取直播视频流； 切换频道观看直播——即机顶盒IGMP leave当前组播组，join新组播组，获取新视频流。 （5）电影/综艺点播，直播节目回放：
机顶盒请求服务器相关业务： 服务器下发单播UDP视频流： 更多组网方案可关注微信公众号：网络工程师解决方案与技术
作者：小云君
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d71dc04176a806282ca0d6cdedca283/" rel="bookmark">
			TypeChat源码分析：基于大语言模型的定制化 AI Agent 交互规范
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		TypeChat源码分析：基于大语言模型的定制化 AI Agent 交互规范 本文深入介绍了微软最近发布的 TypeChat 项目，该项目允许开发者定义大语言模型返回的响应结构。通过分析源代码，探讨了 Prompt 的基本概念，为定制化开发互动式 AI Agent 提供便捷的解决方案。
文章着重介绍 TypeChat 的关键要素，例如集成不同的大语言模型、提高灵活性，并调整输出以适应特定场景，这对于在游戏中通过 AI Agent 实现多样交互至关重要。
在 TypeChat 中，先定义好 ChatGPT 的响应类型，即 Schema, 创建将自然语言请求翻译为特定类型的 JSON 对象的工具函数， 将函数列表和问题发送给GPT，
GPT根据函数定义，返回要执行的函数名和参数， 不同于 Function calling， 它使用 Typescript 类型来作为 Schema，要求 ChatGPT 返回符合这个类型定义的数据。
因为最近开发一个基于GPT的AI AGENT的游戏，不同的人在地图通过不断的和chatGPT定义角色的NPC聊天交互，然后从NPC那里得到不同的反馈，得到不一样的体验，对于交互的部分，我觉得 tyeChat 就可以很好的交互上的格式问题。
本文对typeChat 其中比较重要的点进行分析：
大模型对接的地方：目前只是支持了两种大模型，微软自己的Azure的和 OpenAI 的，比如还有很多的大模型如何接入的问题灵活性的拓展：比如说目前 typeChat 对于类型的定义过于严格，可能要耗费大量的token 以及对于不需要那么严格的场景，比如聊天，只需要有几个关键的key是对的就可以了如何优化 基于 SourceCodeTrace 项目推崇的原则，本文代码块引用均有来源，SourceCodeTrace Project 帮助您在博客、文章记录的过程中，引入对应项目以及版本，行号等信息，让后续的读者，通过引用来源，能够进行更加深入的学习，在博客或文章中引入代码块时，尽量提供代码的来源信息。
核心架构 核心就是对话，校验，修复型对话，得到想要的结构。
export function createJsonTranslator&lt;T extends object&gt;(model: TypeChatLanguageModel, schema: string, typeName: string): TypeChatJsonTranslator&lt;T&gt; { const validator = createJsonValidator&lt;T&gt;(schema, typeName); const typeChat: TypeChatJsonTranslator&lt;T&gt; = { model, validator, attemptRepair: true, stripNulls: false, createRequestPrompt, createRepairPrompt, translate }; return typeChat; /src/typechat.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5d71dc04176a806282ca0d6cdedca283/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66df1f366431362dd68a891d47aa1506/" rel="bookmark">
			Java 多态
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		多态 多态基本介绍 方法或对象具有多种形态。是面向对象的三大特征，多态是建立在封装和继承基础之上的。
多态的具体体现 1、方法的多态： 重写和重载就能体现多态。
2、对象的多态：【背下来，记住】
一个对象的编译类型和运行类型可以不一致
编译类型在定义对象时，就已经被确定，不能再改变
运行类型是可以变化的
编译类型看定义时 = 号的左边，运行类型看 = 号的右边
// 可以让父类的引用指向子类的类型。 Animal animal = new Dog(); //animal编译类型是Animal， 运行类型是Dog animal = new Cat(); // animal的运行类型变成了Cat，编译类型仍然为Animal 多态的注意事项和细节讨论 多态的前提是： 1、两个对象(类)存在继承关系。
2、多态的向上转型
3、多态的向下转型
4、类的属性没有重写之说，当调用类的属性时，属性的值为编译类型对应的值,如果在编译类型中没有查到，则去父类中查找属性
package com.encap.poly; public class PolyDetail { public static void main(String[] args) { Animal animal = new Dog(); // 判断运行结果 System.out.println(animal.count); } } class Animal{ int count = 10; } class Dog extends Animal{ int count = 20; } 5、instanceOf比较操作符，用于判断对象的运行类型是否为 XX 类型或 XX类型的子类型
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/66df1f366431362dd68a891d47aa1506/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42f5a3a730839284501fd2236f62b872/" rel="bookmark">
			java 数组的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数组 基本介绍 数组可以存放多个同一类型的数据，数组也是一种数据类型，是引用类型。
即：数组就是一组数据。
数组的使用 1、数组的定义
方法一 -&gt; 单独声明 数据类型[] 数组名 = new 数据类型[大小] 说明：int[] a = new int[5]; //创建一个数组，名字a，存放5个int。没有具体数据，默认值为0 方法一 -&gt; 单独声明 单独声明： new 类型[]{1,2,3,4}; -&gt; new int[]{1,2,3,4,5}; 方法二： -&gt; 先声明，再new int[] a; //先声明 a = new int[5]; // 再new 方法三 静态初始化： 数据类型 数组名[] = {元素值，元素值...} int[] a = {2,3,4,5,6,7} 声明空数组: new int[0] //上面指定数字的，都是赋默认值，只有大括号中的，才是真正的赋值。 // 方式一： int[] x = new int[3]; // 方式二： int[] y; y = new int[3]; // 方式三： int[] z = new int[]{1, 2, 3, 4, 5, 6}; // 方式四： int[] a = {13, 2, 3, 32, 325, 13, 25}; 2、数组的引用
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/42f5a3a730839284501fd2236f62b872/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6d387e4d5be6e1a7d8a83b51a475e9f/" rel="bookmark">
			软考中级信息安全工程师2023下半年报名时间及报名入口官网
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		软考中级信息安全工程师2023下半年考试时间： 2023年下半年软考中级信息安全工程师的考试时间为11月4日、5日。考试时间在全国各地一致，建议考生提前备考。共分两科，第一科基础知识考试具体时间为9:00-11:30；第二科应用技术考试具体时间为2:00-4:30。
软考中级信息安全工程师2023下半年报名时间及入口： 入口：全国计算机技术与软件专业技术资格（水平）考试
海南：8月14日至8月21日
四川：8月14日至8月30日
黑龙江：8月16日至8月22日
吉林：8月16日至8月28日
西藏：8月16日至9月4日
内蒙古：8月17日至8月28日24:00
广西：8月15日8:00至8月24日17:00
广东：8月16日9:00至8月24日17:00
江西：8月15日9点至9月8日17点
甘肃：8月28日9:00至9月6日18:00
安徽：8月15日9:00至8月21日16:00
软考中级信息安全工程师2023下半年报名流程及步骤： 1、进入报名入口
报名人员登录全国计算机技术与软件专业技术资格（水平）考试网上报名平台。
2、注册登录
进入对应报名入口后，会显示考生登录界面，注册过的考生可以直接登录，没有注册过的考生请进行注册。登录成功后，选择立即报名。
3、选择对应地区
选择机构名称，也就是对应地区，于报名有效时间内，进入该地区的报名入口。
4、信息填报
考生进入报名系统后，菜单栏会显示报名的各个流程。考生仔细阅读考生须知以及考试计划后，进行报名。请按系统要求填写报名信息以及个人电子照片，报名信息提交后，等待审核。
5、报名缴费
审核通过后，即可进行缴费；审核未通过，请根据提示修改信息再次提交。考试费用实行网上缴纳，为防止出现“报考人员已付款，但由于技术原因导致网报平台费用未到账”现象，进而导致报名失败，请广大报考人员务必于网上缴费操作完成后，在缴费截止时间前重新登录考试报名平台并查看“缴费状态”。若显示“缴费成功”，即完成报名。
软考中级信息安全工程师2023下半年报名费用： 山东：每人每科68元。
湖南：160元。
湖北：每人140元。
浙江：每人140元。
江苏：140元。
江西：每人每科78元。
福建：136元/生。
安徽：每人每科68元。
山西：130元。
四川：每人每科68元。
重庆：120元。
贵州：每人每科收费标准68元。
云南：100元/人。
陕西：136元（人·两科）。
甘肃：报名费每科68元。
北京：每人每科57元。
广东：每人每科63元收取。
上海：考试报名费每人10元，考务费每科60元。
河北：报名费每人10元，笔试费每人每科53元。
河南：每人每科缴纳考务费65元。
宁夏：报名费每人10元，考务费每人每科50元。
吉林：考务费每人每科18元；考试费每人每科65元。
广西：每人每科68元。
辽宁：考试不收取报名费、考试费（大连除外）。
新疆：报名费每人15元，考试费每人每科40元。
兵团：客观题考试费每科48元，主观题考试费每科58元。
天津：150元。
海南：客观题65元/人·科，主观题68元/人·科。
内蒙古：每人收取报名费20元，每人每科次收取考务费68元。
黑龙江：每人每科68元。
青海：140元。
西藏：85元/科。
香港：150元。
澳门：澳门币900。
如何备考软考中级信息安全工程师？ 考生备考软考中级信息安全工程师至少要预留3到5个月的时间，越早开始备考越好。现在开始备考也来得及。很多考生是在职党，所以在备考的同时还要兼顾工作和家庭。因此，有必要仔细核实每天能够用来学习的时间，然后再制定备考计划。如果每天有两个小时的学习时间，平均来说，需要大约2个月的备考时间才能准备好一门科目。如果每天有三到四个小时的学习时间，平均来说，需要大约一个月的备考时间，压力相对较大一些。当然，还要考虑平时上下班的通勤时间以及加班情况。不建议大家加班加点来学习，因为备考软考考试是一个漫长的过程，科学备考才能持续发展。因此，备考时间应该尽量拉长，夯实基础才能获得好成绩。
下面是我收集的备考资料，需要的点赞+留言，可以分享。【信息安全工程师资料共享】
第一阶段：了解考情 学习目标：通过历年真题分析历年考试相关知识内容的考查频度及分值占比，梳理出核心考点内容。
时间安排：考前6个月
学习要求：
对考试考点内容有个基本的了解；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d6d387e4d5be6e1a7d8a83b51a475e9f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7bc81a29e685ce38ebc67176b732c86b/" rel="bookmark">
			Unet代码实现(PyTorch)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import torch import torch.nn as nn from torch.nn import functional as F # 基本卷积块， 长宽不变，in_channels -&gt; out_channels class Conv(nn.Module): def __init__(self, C_in, C_out): super(Conv, self).__init__() self.layer = nn.Sequential( nn.Conv2d(C_in, C_out, 3, 1, 1), nn.BatchNorm2d(C_out), # 防止过拟合 nn.Dropout(0.3), nn.LeakyReLU(), nn.Conv2d(C_out, C_out, 3, 1, 1), nn.BatchNorm2d(C_out), # 防止过拟合 nn.Dropout(0.4), nn.LeakyReLU(), ) def forward(self, x): return self.layer(x) # 下采样模块，长宽下采样2倍，通道数不变 class DownSampling(nn.Module): def __init__(self, C): super(DownSampling, self).__init__() self.Down = nn.Sequential( # 使用卷积进行2倍的下采样，通道数不变 nn.Conv2d(C, C, 3, 2, 1), nn.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7bc81a29e685ce38ebc67176b732c86b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/393d3255965baacd1202c8b48a7428e5/" rel="bookmark">
			[Asis CTF 2016] b00ks
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		[Asis CTF 2016] b00ks
这道题主要是用到了Off-By-One漏洞，还有利用mmap成立的堆与libc基址间距相等的原理
注意点：
使用的libc最好是2.23版本，因为在libc2.34以后（还是2.35？），__free_hook函数就已经停止利用了，可以利用patchelf来指定可执行文件的libc版本 patchelf --set-interpreter /lib64/ld-2.24.so --set-rpath /home/kali/Desktop/2.24-3ubuntu2.2_amd64 ./b00ks mmap申请的时候尽量往大了申请，我申请的大小是0x21000，结果却并不是mmap开辟空间，而是被存储在了anon_7fd0412c8字段，代表了一个匿名内存映射区域，以下分别是在申请0x21000和0x210000大小时的vmmap情况，当0x210000时才会时mmap申请
本题的exp如下：
from pwn import * import warnings warnings.filterwarnings("ignore") libc = ELF("./libc-2.24.so") def create_book(book_size,book_name,des_size,des): sh.recvuntil("&gt;") sh.sendline("1") sh.sendlineafter("name size: ",str(book_size)) sh.sendlineafter(" chars): ",str(book_name)) sh.sendlineafter("description size: ",str(des_size)) sh.sendlineafter("description: ",str(des)) def createname(name): sh.sendlineafter("name: ",name) def change_name(name): sh.recvuntil("&gt; ") sh.sendline("5") sh.sendlineafter("name: ",payload) def show(id): sh.recvuntil("&gt;") sh.sendline("4") sh.readline() for i in range(id): sh.recvuntil(": ") book_name = sh.readline()[:-1] sh.recvuntil(": ") book_des = sh.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/393d3255965baacd1202c8b48a7428e5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/351ea43cf5155951ed1d1454ecbfb32c/" rel="bookmark">
			湖北师范大学Java实验五
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实验五 类和对象
1.设计一个自动铅笔类AutoPencil，有1个属性boolean penPoint（笔尖是否伸出），有4个函数：
（1）构造函数AotoPencil()，将penPoint置为false
（2）按压操作函数void knock()，将penPoint置反
（3）获取笔尖状态函数 boollean getPenPoint()
（4）main函数
创建对象并对实例对象进行按压操作，显示笔尖的状态。
package diyiti; public class AutoPencil { private boolean penPoint; public AutoPencil() { penPoint=false; } public void knock() { penPoint=!penPoint;	} public Boolean getPenPoint() { return penPoint; } public static void main(String[] args) { // TODO Auto-generated method stub AutoPencil a=new AutoPencil(); a.knock(); System.out.println("笔的状态为："+a.getPenPoint()); } } 2.设计一个汽车类Car，有2个属性车主owner和油量oil，有7个函数：
（1）构造函数Car(String owner,double oil)
（2）构造函数Car(String owner)，油量置为0
（3）加油操作函数void addOil(double oil)
（4）行驶操作函数void drive(int distance)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/351ea43cf5155951ed1d1454ecbfb32c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0bdcd0ea1f1c2eb85621e45549ff6896/" rel="bookmark">
			OKHttp3的使用和详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、概述 OKHttp是处理网络请求的开源框架，Andorid当前最火热的网络框架，Retrofit的底层也是OKHttp，用于替换HttpUrlConnection和Apache HttpClient（API23 6.0已经移除）。
概况起来说OKHttp是一款优秀HTTP框架，它支持GET和POST请求，支持Http的文件上传和下载，支持加载图片，支持下载文件透明的GZIP压缩，支持响应缓存避免重复的网络请求，支持使用连接池来降低响应延迟的问题。
OKHttp的优点：
1.支持HTTP2/SPDY，这使得对同一个主机发出的所有请求都可以共享相同的套接字连接。
2.如果HTTP2/SPDY不可用OkHttp，会使用连接池来复用连接以提高效率。
3.提供了对 GZIP 的默认支持来降低传输内容的大小
4.提供了对 HTTP 响应的缓存机制，可以避免不必要的网络请求
5.当网络出现问题时，OkHttp会自动重试一个主机的多个 IP 地址
二、基本的使用 2.1、配置工程 （1）首先在清单文件AndroidManifest.xml中添加网络权限
&lt;uses-permission android:name="android.permission.INTERNET"/&gt; &lt;uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/&gt; &lt;uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE"/&gt; （2）在build.gradle文件中添加okhttp依赖：
implementation 'com.squareup.okhttp3:okhttp:4.2.0' 2.2、使用步骤： （1）创建OkHttpClient实例
（2）通过Builder辅助类构建Request请求对象
（3）OkHttpClient实例回调请求，得到Call对象
（4）同步/异步执行请求，获取Response对象
2.3、方法详解 （1）创建OkHttpClient实例
//方式一：创建OkHttpClient实例,使用默认构造函数，创建默认配置OkHttpClient(官方建议全局只有一个实例) OkHttpClient okHttpClient = new OkHttpClient(); //方式二：通过new OkHttpClient.Builder() 一步步配置一个OkHttpClient实例 OkHttpClient httpClient = new OkHttpClient.Builder().connectTimeout(13, TimeUnit.SECONDS).build(); //方式三：如果要求使用现有的实例，可以通过newBuilder().build()方法进行构造 OkHttpClient client = okHttpClient.newBuilder().build(); 使用默认构造函数创建OkHttpClient实例，创建默认配置OkHttpClient(官方建议全局只有一个实例)。也可以通过new OkHttpClient.Builder() 一步步配置一个OkHttpClient实例，如果要求使用现有的实例，可以通过newBuilder().build()方法进行构造。
（2）超时设置
我们在创建OkHttpClient实例的时候也会设置相关的属性，通过.Builder().build()的形式设置，比如超时时间设置：
//1.构建OkHttpClient实例 final OkHttpClient okHttpClient = new OkHttpClient.Builder() .connectTimeout(2, TimeUnit.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0bdcd0ea1f1c2eb85621e45549ff6896/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/574c688e135c98f95dca00e63f7047fc/" rel="bookmark">
			原力奖牌获奖用户名单
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		活动地址：https://activity.csdn.net/creatActivity?id=10440
获奖名单如下：
用户ID截止到6月30日原力总分博客地址forever_wj30632云原生之深入解析如何正确计算Kubernetes容器CPU使用率_container_spec_cpu_period_╰つ栺尖篴夢ゞ的博客-CSDN博客hihell24418在CSDN获得【铁粉】的奇技淫巧，拆解定义，为你涨铁粉_梦想橡皮擦的博客-CSDN博客weixin_3970913423537（2023最新）Java毕业设计参考题目1-题目新颖（值得收藏）_java李杨勇的博客-CSDN博客qq_3198813918089粉丝很多铁粉却不到10%，如何收获铁粉？_此星光明的博客-CSDN博客feng840300015771如何快速增长铁粉——亲测有效(纯干货)_红目香薰的博客-CSDN博客zhangrelay14993撰写博客如何获得持续的关注和支持_zhangrelay的博客-CSDN博客qq_3816104014596Python 算法基础篇：斐波那契数列问题的动态规划解法_挣扎的蓝藻的博客-CSDN博客qq_3358951013811如何建立TLS连接？TLS握手失败可能这个原因！_JavaEdge.的博客-CSDN博客frigidwinter13360路径规划 | 蚁群算法图解与分析(附ROS C++/Python/Matlab仿真)_Mr.Winter`的博客-CSDN博客hy59207061612876自然语言处理从入门到应用——LangChain：模型（Models）-[文本嵌入模型Ⅱ]_von Neumann的博客-CSDN博客dream_weave12211程序人生 - 仅一篇讲解如何精准获得优质铁粉？_放羊的牧码的博客-CSDN博客hh86730812211372CSDN中如何获得铁粉（用心篇）_Java Fans的博客-CSDN博客qq_4486682811370CSDN如何获得铁粉?_猫头虎的博客-CSDN博客m0_5231637210999循环码的特点与多项式描述_timerring的博客-CSDN博客qq_3542758910900CSDN铁粉获取秘籍_csdn粉丝购买_共饮一杯无的博客-CSDN博客u01016419010760Emacs之解决emacs与fcitx中文简体切换繁体冲突(第一百零一)_Android系统攻城狮的博客-CSDN博客weixin_5263275510228【数据结构】何为数据结构。_謓泽的博客-CSDN博客yelangkingwuzuhu9914叮咚，这有一封铁粉获取指南待查收_夜郎king的博客-CSDN博客weixin_443684379710【博客历程】比起方法和技巧，我更想谈质量与坚持_白鳯的博客-CSDN博客jackiedyh9509Vue2.x和Vue3.x面试常问知识点-面试题_JackieDYH的博客-CSDN博客xishining9508小明给大家分享几个CSDN涨粉小技巧，期待大家多多涨粉_csdn粉丝_IT技术分享社区的博客-CSDN博客javascript_tsj9505【JAVA进阶】File类、字节流_热爱编程的小白白的博客-CSDN博客qq_447310199362⑩【图神经网络×自监督×时空】视频自监督学习、时间对比图学习、多尺度时间依赖性(长期、短期) 、频域学习_追光者♂的博客-CSDN博客weixin_439707439231论C站如何获得铁粉？过来人给出几点建议_bug菌¹的博客-CSDN博客weixin_436940969063YOLOv3: An Incremental Improvement 全文翻译_迪菲赫尔曼的博客-CSDN博客m0_643367808723涨粉秘籍 | 如何快速涨粉并转化为铁粉？_艾派森的博客-CSDN博客yuan20190350558547袁袁袁袁满的博客_CSDN博客-100天精通Python从入门到就业,Python每日一练,Java领域博主dietime19437983CSDN原力值解析：功能作用、获取方法、积分对应等级关系详解_bluetata的博客-CSDN博客weixin_380934527884如何获得铁粉？_空空star的博客-CSDN博客qq_409859857817CSDN如何获得铁粉_程序媛一枚~的博客-CSDN博客qq_368168487625【智慧交通项目实战】《 OCR车牌检测与识别》（四）：基于Pyqt的项目可视化_ocr车牌识别_GoAI的博客-CSDN博客weixin_438472837609如何获得铁粉（弯道超车的攻略）_鱼找水需要时间的博客-CSDN博客m0_626177197525Linux 远程管理协议_梁辰兴的博客-CSDN博客han12020127473韩曙亮的博客_CSDN博客-错误记录,Android 逆向,Android 性能优化领域博主m0_681112677283【萌新指南】如何获得铁粉？快收下我为你精心定制的涨粉秘籍吧_Want595的博客-CSDN博客rej1777148CSS基础_二哈喇子！的博客-CSDN博客weixin_416357506997最新版本 Stable Diffusion 开源 AI 绘画工具之文本转换（Embedding）以及脚本（Script）高级使用篇_极客飞兔的博客-CSDN博客m0_624368686975Netty概述及Hello word入门_一个风轻云淡的博客-CSDN博客alwaysbefine6836Linux|奇怪的知识|一次性任务at命令的使用_晚风_END的博客-CSDN博客air__heaven6699WAIC2023| AIGC究竟在向善还是向恶而行？_中杯可乐多加冰的博客-CSDN博客xu4415206487【尔嵘】感恩四周年，感谢支持_尔嵘的博客-CSDN博客weixin_519544436333【Polelink北汇信息】CERT如何保证软件信息安全？_Polelink北汇信息的博客-CSDN博客wzk48696287忠诚之源：如何获得铁粉？_旅途中的宽~的博客-CSDN博客diandianxiyu6168【工具推荐】使用D3.js制作网页版网络拓扑图，可拖转可跳转链接_javascript 拓扑图_小雨青年的博客-CSDN博客weixin_444271816123【日常】如何增加粉丝的粘性？_SoftwareDevOps的博客-CSDN博客java_wxid6047【如何获得铁粉】_我是廖志伟的博客-CSDN博客z6099320886015Qt Qml 实现键鼠长时间未操作锁屏_qml屏保_DreamLife.的博客-CSDN博客qq_516250075996如何获取铁粉【活动】_日星月云的博客-CSDN博客weixin_473435445959【陈老板赠书活动 - 09期】- 【向上管理的高手-如何获得铁粉】_陈老老老板的博客-CSDN博客weixin_421825995949一篇文章告诉你如何指数型涨粉_小曾同学.com的博客-CSDN博客m0_614903995889NodeJS 文件操作④_SYFStrive的博客-CSDN博客boysoft20025819Hann Yang的博客_CSDN博客-Python,Go Leetcode,CPP领域博主qq_533170055791如何在CSDN获取更多的铁粉？_csdn粉丝购买_会洗碗的CV工程师的博客-CSDN博客weixin_422508355676哈哥撩编程的博客_CSDN博客-Python全栈白宝书,⑤ - 数据库开发实战篇,网安之路领域博主qq_414641235656MyBatisPlus快速入门（二）MyBatisPlus快速入门体验_Designer 小郑的博客-CSDN博客weixin_532314555430CSDN 的中铁粉是什么？如何获得粉丝与铁粉呢？一篇文章告诉你，干货满满，建议收藏_csdn粉丝购买_黛琳ghz的博客-CSDN博客gfdxx5325【网络编程·应用层】一文详解http协议（超文本传输协议）_蒋灵瑜的笔记本的博客-CSDN博客noamanelson5268自动化测试报告样式HTMLTestRunner、BeautifulReport、HTMLReport、Allure你喜欢哪个？_虫无涯的博客-CSDN博客qq_352301255100如何获取铁粉_德宏大魔王(AI自动回关)的博客-CSDN博客dong__ge4848初级嵌入式软件工程师养成记（学习路线+学习资源+实战项目汇总）_卍一十二画卍的博客-CSDN博客u0113979814786【MySQL】MySQL体系架构_mysql系统架构_逆流°只是风景-bjhxcc的博客-CSDN博客qq_672766054785CSDN铁粉增长秘籍_初阶牛的博客-CSDN博客weixin_627650174770征文 | 吸引铁粉？成为CSDN明星！_wei_shuo的博客-CSDN博客yj112903014735网络豆的博客_CSDN博客-Python,网络,Linux云计算入门到精通领域博主xingyu_qie4675经海路大白狗的博客_CSDN博客-前端面试千题计划,狗哥梦话职场,大学毕业解疑领域博主zhangsama14660【Python】Pytorch（CNN）实现垃圾，宝石，表情，车牌，鸟类，食物等各种分类_ZhangBlossom的博客-CSDN博客guorui_java4604哪 吒的博客_CSDN博客-华为OD机试（JAVA）真题（A卷+B卷）,华为OD机试（JavaScript）真题（A卷+B卷）,搬砖工逆袭Java架构师领域博主qq_420559334594CSDN铁粉获取攻略_默 语的博客-CSDN博客weixin_525330074585如何获得铁粉？__GGBond_的博客-CSDN博客weixin_515459534527【随笔记】如何获得铁粉(仅供参考)_WSKH0929的博客-CSDN博客m0_679063584480HTTP详细教程与讲解_http教程_久绊A的博客-CSDN博客m0_494762414441CSDN如何获得铁粉_花落已飘的博客-CSDN博客weixin_508042994413【涨粉秘籍】如何快速涨粉并转化为铁粉。_以山河作礼。的博客-CSDN博客wisdom_futrue4400我是沐风晓月的博客_CSDN博客-1 - linux基本功-基础命令实战,云原生从入门到精通,5 - 数据库入门到精通篇领域博主qq_214384614396【C/C++ 关键字 存储类说明符 】一文带你了解C/C++ 中extern 外部声明 关键字的使用_泡沫o0的博客-CSDN博客gllll_yu4388CSDN铁粉规则解析——如何赢得铁粉的心_花想云的博客-CSDN博客m0_472561624333海洋.之心的博客_CSDN博客-2023王道数据结构,图神经网络,PyTorch深度学习项目实战100例领域博主long_xu4239【019】C++的指针与函数_Lion Long的博客-CSDN博客liangzc11244225Linux中与命名空间相关的内核数据结构_Leon_George的博客-CSDN博客weixin_594804814170【ChatGPT】一个凭借两百多年历史的公式崛起的巨星_ThundersArk的博客-CSDN博客qq_611160073956【网络】路由器和无线路由器就这么配置_大虾好吃吗的博客-CSDN博客lzl102113453930小刘在C站的博客_CSDN博客-云计算网络技术,MySQL入门到实战,python领域博主lyshark_csdn3855驱动开发：内核实现SSDT挂钩与摘钩_微软安全技术分享的博客-CSDN博客m0_588474513820【Java SE】值传递，看这一篇就够了！_狮子也疯狂的博客-CSDN博客lvoelife3788互联网全栈开发实战的博客_CSDN博客-java,mysql,开发工具领域博主qq_524174363787Python数据采集与分析课程设计【1949-2022中国人口历史数据分析预测】_-北天-的博客-CSDN博客m0_639511423746CSDN如何获取铁粉_csdn买粉丝_冷兮雪的博客-CSDN博客weixin_614377873726Day6 不要二、把字符串转换成整数_北 海的博客-CSDN博客lixiaogang_theanswer3660【0202】PG内核通过捕捉SIGHUP信号，完成config file（postgresql.conf、pg_hba.conf、pg_ident.conf）重加载_内核之道的博客-CSDN博客weixin_434661923512c++中如何以一个字符’i’为准把string字符串中’i’两边的字符分成两个子字符串_、、、、南山小雨、、、、的博客-CSDN博客ligang25851163506CSS新特性，提升开发效率与视觉表现，必读！_奋飛的博客-CSDN博客qq_414854143451React基础入门知识记录_前端.火鸡的博客-CSDN博客qingxu12343429MySQL基础一篇打通，图文并茂_LoneWalker、的博客-CSDN博客qq_531230673282亦世凡华、的博客_CSDN博客-Vue技术栈,React技术栈,JavaScript领域博主qq_430612903213【前端面试知识点】- 大厂面试（三）_拉格朗日(Lagrange)的博客-CSDN博客seawaving3202带你一步步实现低代码开发平台——基于配置信息生成库表和代码_学海无涯，行者无疆的博客-CSDN博客qq_635859493197CSDN如何快速获得粉丝和高质量铁粉_小嗷犬的博客-CSDN博客jhxl_3167几何心凉的博客_CSDN博客-Vue,javaScript,前端小游戏领域博主weixin_448166643156linux中cgroup的简单使用_鹤冲天Pro的博客-CSDN博客m0_733670973129【数据结构】初步了解排序_Yan-英杰的博客-CSDN博客qq_597475943078elementPlus引入_element plus 导入__揽的博客-CSDN博客wlwdecs_dn2998【循环自相关和循环谱系列7】OFDM循环自相关推导分析、时间参数估计原理仿真及某无人机实际图传信号验证(含矩形/非矩形、有无循环前缀等情况)_C0mm_notes的博客-CSDN博客ljsant2983Uni-app学习从0到1开发一个app——(2)windowns环境搭配_疯狂的挖掘机的博客-CSDN博客hdp1347932964【CSDN铁粉】CSDN铁粉增长终极奥义之如何快速破千铁粉_拄杖盲学轻声码的博客-CSDN博客tiger_lin12927k8s控制器之Deployment第四弹之回滚Deployment_linus.lin的博客-CSDN博客qq_547967852890【服务器】Python一行命令搭建HTTP服务器并外网访问 - 内网穿透_小尘要自信的博客-CSDN博客weixin_382441742884架构整洁之道下篇（实现细节）_张云瀚的博客-CSDN博客u0108008042765【云原生-K8s】k8s可视化管理界面安装配置及比较【Kuboard篇】_k8s管理界面_rundreamsFly的博客-CSDN博客sinat_252072952750[ 经验分享 ] CSDN铁粉系统之 —— 什么是铁粉？如何获得铁粉？_削尖的螺丝刀的博客-CSDN博客qq_359955142733Linux进程OOM-kill 监控和规避_开着拖拉机回家的博客-CSDN博客weixin_426360752678谢谢所有可爱的粉丝友友们_一晌小贪欢的博客-CSDN博客weixin_434127622657酷酷的懒虫的博客_CSDN博客-LeetCode,java,C++领域博主qq_422594692608SonarQube社区版安装插件实现扫描多分支_sonarqube 多分支_勤奋的树懒的博客-CSDN博客mrwen23957723832595＜ 每日算法 - JavaScript解析：一文解决 “ 买卖股票 ” 系列算法题 ＞_技术宅小温的博客-CSDN博客qq_375304292559软考高项（四）信息系统管理 ★重点集萃★_Fish_Vast的博客-CSDN博客qq_403791322420如何获得铁粉？_一只小小的土拨鼠的博客-CSDN博客m0_743525712408【CSDN铁粉】（获取铁粉的终极秘诀）_平行线也会相交的博客-CSDN博客hlzdbk2363Mysql事务_郝老三的博客-CSDN博客qq2333253322362技术笔记：默默耕耘，赢得铁粉的秘密策略！_陌北v1的博客-CSDN博客weixin_501538432349如何良好的运营我们的CSDN账号_csdn运营_Loading_create的博客-CSDN博客weixin_541741022288铁粉论 | 如果获得高质量铁粉_万物皆可der的博客-CSDN博客dongjing9912177关于CSDN如何获得铁粉_骇客野人的博客-CSDN博客csh18072664892156我是夜阑的狗的博客_CSDN博客-微信小程序开发教程,基础篇,LeetCode题解（持续更新中）领域博主m0_637742111991Yolov8涨点技巧：MobileViTAttention助力小目标检测，涨点显著，MobileViT移动端轻量通用视觉transformer_AI小怪兽的博客-CSDN博客m0_526919621984MySQL高级篇复盘笔记（一）【存储引擎、索引、SQL优化、视图、触发器、MySQL管理】_Java技术一点通的博客-CSDN博客qq_420769021976如何在竞争激烈的市场环境下打造技术铁粉：CSDN的案例分析_肖申克的陪伴的博客-CSDN博客weixin_500020381974如何获得铁粉？_你才是臭弟弟的博客-CSDN博客qq_580350321964ChatGPT自动生成思维导图_微风撞见云的博客-CSDN博客qq_403320451892【SQL应知应会】分析函数的点点滴滴（二）_爱书不爱输的程序猿的博客-CSDN博客jingduo09091852Node框架 【Egg-企业级框架】之 【内置对象】_忆凡_的博客-CSDN博客rl26988531141783【CSDN快速获得铁粉小经验】厉昱辰的经验分享_厉昱辰的博客-CSDN博客weixin_467039951715Java垃圾回收机制深入理解_java 垃圾回收详解_沐雨风栉的博客-CSDN博客qq_311365131692基于TF-IDF+Tensorflow+PyQt+孪生神经网络的智能聊天机器人（深度学习）含全部Python工程源码及模型+训练数据集_小胡说人工智能的博客-CSDN博客qq_437791491621【程序员面试金典】面试题 08.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/574c688e135c98f95dca00e63f7047fc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d26127d848e103aaeb1b40df0c3a43ec/" rel="bookmark">
			c# 如何操作usb设备
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 C# 中，可以使用 System.IO.Ports 命名空间中的 SerialPort 类来操作串口设备，也可以使用 Windows.Devices.Usb 命名空间中的 UsbDevice 类来操作 USB 设备。
下面以操作 USB 设备为例，介绍如何在 C# 中使用 UsbDevice 类来实现 USB 设备的读写操作。
引用 Windows.Devices.Usb 命名空间
在代码文件中添加以下代码： using Windows.Devices.Usb; 枚举 USB 设备
使用 UsbDevice.GetDeviceSelector 方法获取 USB 设备的筛选器，并使用 DeviceInformation.FindAllAsync 方法获取设备信息列表。然后，可以根据设备信息列表获取 USB 设备对象。 // 获取 USB 设备的筛选器 string deviceSelector = UsbDevice.GetDeviceSelector(vendorId, productId); // 根据筛选器获取设备信息列表 var deviceInformationCollection = await DeviceInformation.FindAllAsync(deviceSelector); // 获取第一个设备的信息 var deviceInformation = deviceInformationCollection[0]; // 根据设备信息打开 USB 设备 var usbDevice = await UsbDevice.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d26127d848e103aaeb1b40df0c3a43ec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/817823fc3c383327e7fee528879a5d08/" rel="bookmark">
			Java Zip压缩：简化文件和文件夹的压缩操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、Zip压缩简介二、压缩文件1. 创建压缩文件2. 压缩多个文件3. 压缩文件夹 三、解压缩文件1、解压缩文件 总结 导言 在Java开发中，经常会遇到需要对文件和文件夹进行压缩和解压缩的需求。Java提供了Zip压缩库，使我们能够轻松地进行文件和文件夹的压缩操作。本文将详细介绍Java中的Zip压缩功能，并提供示例代码来演示其用法。 一、Zip压缩简介 Zip压缩是一种常见的文件压缩格式，它将多个文件和文件夹打包成一个以.zip为后缀的压缩包。压缩后的文件可以减小存储空间和网络传输的大小，并方便地进行传输和共享。Java的Zip压缩库提供了一组API，用于创建、读取和解压缩Zip文件。
二、压缩文件 首先，让我们看一下如何使用Java的Zip压缩库来压缩文件。
1. 创建压缩文件 在进行文件压缩之前，我们需要先创建一个Zip文件。可以使用ZipOutputStream类来创建一个新的Zip文件，并指定文件名。以下是创建压缩文件的示例代码：
import java.io.FileOutputStream; import java.io.IOException; import java.util.zip.ZipEntry; import java.util.zip.ZipOutputStream; public class ZipExample { public static void main(String[] args) { String zipFileName = "example.zip"; try (ZipOutputStream zipOutputStream = new ZipOutputStream(new FileOutputStream(zipFileName))) { // 添加文件到压缩包 String fileToCompress = "file.txt"; addToZipFile(fileToCompress, zipOutputStream); System.out.println("File compressed successfully!"); } catch (IOException e) { e.printStackTrace(); } } private static void addToZipFile(String fileName, ZipOutputStream zipOutputStream) throws IOException { // 创建ZipEntry对象并设置文件名 ZipEntry entry = new ZipEntry(fileName); zipOutputStream.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/817823fc3c383327e7fee528879a5d08/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3fc18cda9ea6cb06dacd1ec6760c918e/" rel="bookmark">
			探究eFuse：硬件保障与系统安全的核心
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		探究eFuse：硬件保障与系统安全的核心 图1： 编程熔断的 eFuse
eFUSE的全名是"Electrically Programmable Read-Only Memory Fuse"，它是一种电可编程只读存储器。
eFUSE是一种用于存储固定信息的存储器，它的主要特点是一旦编程后就无法再进行擦除或修改，类似于传统的只读存储器（ROM）的功能。
作为系统工程师，虽然不会对eFuse 这块做深入的开发，更多的还是依赖芯片厂商自己的实现，然后取出自己的数据，但是通过对 eFuse 大致的了解，能够对整机的一些概念紧密联系起来，让知识图谱更全面。
目前手机行业内，出厂都会做熔丝处理，熔丝之后，不能进行随意刷机，非熔丝设备一般属于开发设备，用来内部自定义刷机。
熔丝过程中，有一个步骤就是写入设备ID信息， 熔丝设备通常具有唯一的设备ID，可以用防止软件篡改和仿冒，一些商业化行为的唯一标记等。
这些标识通常是在制造过程中预先烧录到eFUSE中的，用于识别每个设备的唯一性，Bootloader可以读取eFUSE中的这些标识，并在设备启动时使用它们来进行身份验证。
eFuse不是软件上的分区 eFUSE（熔断保护）通常是硬件特性，而不是预置的软件特性，eFUSE是一种一次性可编程的硬件存储器，用于存储固定的数据或配置信息，例如设备序列号、密钥、硬件配置等。
eFUSE在手机或其他设备的主板上实现，并由硬件厂商预置一些不可更改的数据。这些数据通常在制造过程中被烧录到eFUSE中，并且无法在后续的使用中被修改。因此，eFUSE中存储的信息是设备固有的、不可更改的。
在 Android 系统中，eFUSE通常被用于存储一些重要的设备信息和安全相关的数据，例如设备唯一标识、安全密钥、加密相关信息等。这些数据的安全性和不可篡改性是系统的重要保障，因此通常会将它们存储在eFUSE中，以防止被非法篡改或泄漏。
由于eFUSE的特性，它一般不受 Android 系统软件的影响，也不是可编程的软件特性。因此，Google 原生 Android 系统上的eFUSE通常是由设备硬件厂商预置和配置的，与 Android 系统软件无关。
BootLoader 实现读取 eFUSE 在Bootloader中扮演着重要的角色，用于存储关键的设备信息和安全配置，帮助确保设备的启动过程和运行环境的安全性。它是Android设备等嵌入式系统中重要的安全保障措施之一。
Android bootloader 是一个引导加载程序，它位于 Android 设备的存储芯片中，负责启动设备并加载操作系统。它是设备上的第一个软件程序，负责执行一系列初始化任务和配置操作，以确保设备能够正确启动。
目前 bootloader 不属于 AOSP 内标准的模块，一般是芯片厂商在维护，目录结构也不统一，对于 eFuse 的读取模块也在 lk 内， 高通的 bsp 模块一般是独立编译，MTK和展讯所在的目录也不太一样，常见的有这些目录结构：
bsp/bootloader/lkkernel/lk/ eFuse 存在 BootLoader 中的功能有：
安全启动验证
Bootloader是在设备启动时运行的第一个软件程序，负责初始化硬件和加载操作系统，在安全启动流程中，Bootloader通常会检查 eFUSE 中的安全配置信息，例如是否启用了 Secure Boot（安全启动）功能。
如果eFUSE中的安全标志被设置为启用，Bootloader会执行相应的安全验证流程，以确保设备启动的固件和操作系统是经过验证的，从而防止未经授权的固件加载。
设备唯一标识
Bootloader可能会使用eFUSE中存储的设备唯一标识（Device ID）作为设备的身份认证信息。
这些标识通常是在制造过程中预先烧录到eFUSE中的，用于识别每个设备的唯一性。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3fc18cda9ea6cb06dacd1ec6760c918e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72335e8be2056f64c109a5335196cc8f/" rel="bookmark">
			河北中洺科技BEV语义数据标注工具打开图片流程：
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 使用河北中洺科技数据标注工具打开需要标记的图片分为哪几步？
第一步：打开标注工具，首先选择保存路径。重点：需要新建文件夹作为保存路径
第二步：选定好保存路径后，点击选择文件夹，选择原图所在的文件夹
第三步：打开需要标注的图片后，右侧选择语义分割模式
第四步：标注前务必检查情景标签是否选对
第五步：根据标注规范的要求对图片进行标注
完结 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dab9a13f41b15fc59a37d4e9e8490be2/" rel="bookmark">
			npm ERR! code 1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		新建VUE项目在执行npm install命令时，项目报错 npm ERR! code 1 报错信息
解决办法： 1、删除 node_modules 文件夹
2、删除 package-lock.json 文件（有些文章说删除 node_modules 文件夹就可以，但是我删除后还是一样）
3、执行 npm install 命令
补充：
如果运行时遇到版本问题，执行命令报错 npm ERR! code ERESOLVE，可以执行 npm install --legacy-peer-deps 命令 。
实验命令（不管用）： npm i -g npm
npm cache clean --force
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/940c25adc67366b8f06fa7655c4d515c/" rel="bookmark">
			你真的了解Java中的数组吗？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		你真的了解Java中的数组吗？ 数组是基本上所有语言都会有的一种数据类型，它表示一组相同类型的数据的集合，具有固定的长度，并且在内存中占据连续的空间。在C，C++等语言中，数组的定义简洁清晰，而在Java中确有一些会让人迷惑的特性，往往让初学者发蒙。本文就尝试分析这些特性。
问题一：Java中的数组是对象吗？ 要判断数组是不是对象，那么首先明确什么是对象？在较高的层面上，对象是根据某个类创建出来的一个实例，表示某类事物中一个具体的个体。对象具有各种属性，并且具有一些特定的行为。而在较低的层面上，站在计算机的角度，对象就是堆内存中的一个区域，在这个内存块中封装了一些数据（即类中定义的各个属性值），所以，对象是用来封装数据的。以下为一个Teacher对象在内存中的表示：Teacher tea = new Teacher(“燕姐”,34);
注意：
1）矩形表示一个引用（地址）或一个基本类型的数据，椭圆表示一个对象，多个矩形组合在一块，可组成一个对象。
2）name在对象中只表示一个引用， 也就是一个地址值，它指向一个真实存在的字符串对象。在这里严格区分了引用和对象。
那么在Java中，数组满足以上的条件吗？
在较高的层面上，数组不是某类事物中的一个具体的个体，而是多个个体的集合。那么它应该不是对象。而在计算机的角度，数组也是一个内存块，也封装了一些数据，这样的话也可以称之为对象。以下是一个数组在内存中的表示：int[] arr = {1,2,3,4,5};
这样的话， 数组既可以是对象， 也可以不是对象。至于到底是不是把数组当做对象，全凭Java的设计者决定。
int[] arr = {1,2,3,4,5}; int len = arr.length; //数组中保存一个字段, 表示数组的长度 //以下方法说明数组可以调用方法,java中的数组是对象. //这些方法是Object中的方法,所以可以肯定,数组的最顶层父类也是Object String str = arr.toString(); int[] clone = arr.clone(); 在数组arr上， 可以访问它的属性，也可以调用一些方法。这基本上可以认定，java中的数组也是对象，它具有java中其他对象的一些基本特点：封装了一些数据，可以访问属性，也可以调用方法。所以，在Java中数组是对象。
问题二：Java中数组的类型 Java是一种强类型的语言。既然是对象， 那么就必须属于一个类型，比如根据Person类创建一个对象，这个对象的类型就是Teacher。那么数组的类型是什么呢？看下面的代码：
int\[\] arr = {1, 2, 3, 4, 5}; System.out.println(arr.getClass().getName()); //打印出的数组类的名字为 String[] s = new String[2]; System.out.println(s.getClass().getName()); //打印出的数组类的名字为 [Ljava.lang.String; String[][] ss = new String[2][3]; System.out.println(ss.getClass().getName()); //打印出的数组类的名字为 [[Ljava.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/940c25adc67366b8f06fa7655c4d515c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95d041f1e1532570a1ab1481d4869300/" rel="bookmark">
			git下载太慢
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		git官网下载git太慢
阿里git地址
下载适合自己的版本
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8cfd4902b4902eea12b28ecd68bf2086/" rel="bookmark">
			LeetCode·每日一题·2681. 英雄的力量·脑筋急转弯
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目 示例 思路 代码 static const int MOD = 1e9 + 7; int cmp(const void *a, const void *b) { return *(int *)a - *(int *)b; } int sumOfPower(int* nums, int numsSize){ qsort(nums, numsSize, sizeof(nums[0]), cmp);//排序 long long ans = 0, s = 0; for (int x = 0; x &lt; numsSize; ++x) {// x 作为最大值 ans = (ans + (((long long)nums[x] * (long long)nums[x])) % MOD * (nums[x] + s)) % MOD; // 中间模一次防止溢出 s = (s * 2 + nums[x]) % MOD; // 递推计算下一个 s } return ans; } 作者：小迅 链接：https://leetcode.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8cfd4902b4902eea12b28ecd68bf2086/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2fb13af25843bbef1dae5f9fa9538874/" rel="bookmark">
			Clear Site Data - 可以清除单个站点缓存的浏览器插件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天要分享的是一款Chrome浏览器插件——“Clear Site Data”，顾名思义它可以帮我们单独清除某一个站点的缓存。
插件下载地址（也可以商店里搜索“site data”）：
https://chrome.google.com/webstore/detail/clear-site-data/aihgofjefdlhpnmeakpnjjeajofpcbhj​
安装完成后，点开插件，长这个样子。
正如文章开头说的那样，我们只是想清除单个站点的缓存！首先我们访问对应网站，然后点开插件，此时就会出现清除当前站点的选项，双击“Clear Site Data”即可清除当前站点的所有缓存。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc68d254b983ca2515d297646e5b8864/" rel="bookmark">
			项目nodejs升级至版本16
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、升级nodejs版本 方法一:nodejs卸载安装16版本
方法二：下载nvm来控制版本
nvm的简介、安装、使用（简单明了）_仰.的博客-CSDN博客
nvm最好还是去githubReleases · coreybutler/nvm-windows · GitHub下载最新版本的。
2、解决版本之间的兼容问题 版本兼容问题主要就是node-sass和sass-loader版本兼容问题，我遇到的情况就是使用16.15.1版本不兼容，https://www.cnblogs.com/hhl1011/p/16336459.html 这篇文章是16对应的版本。但是我同事升级至16具体什么版本不知道加上--legacy-peer-deps这个参数是可以成功的。我要升级到16.20.1再加上上面的参数才能成功。
npm install --legacy-peer-deps https://zhuanlan.zhihu.com/p/506596270
3、更换node-sass为sass 如果你使用过 sass ，应该了解多年来 node-sass 一直是 JavaScript 社区里的主流选择，它实际上只是 libsass 在 node 环境下的一个 wrapper， 编译 sass 文件的实际工作是 libsass 完成的。
在使用 node-sass 过程中遇到的很多问题实际上也是 libsass 引发的，libsass 是用 C/C++ 实现的，常见的问题是，在安装 node-sass 的过程中经常会出现安装失败的情况，又或者切换了 Node.js 版本发现 node-sass 需要重新安装才能用，如果你在 docker 中安装 node-sass 还会遇到由于缺少各种依赖导致 node-sass build 失败的情况，又或者在国内由于网络原因导致 node-sass 需要的二进制文件下载不下来而 build 失败。
不使用node-sass更换为sass vue还需要配置
module.exports = { css: { loaderOptions: { sass: { implementation: require('sass'), // This line must in sass option }, }, }, 滑动验证页面
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8954147dcc8f736336cc6e17b0a8b5da/" rel="bookmark">
			Linux系统管理：虚拟机Rocky Linux安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、理论
1.Rocky Linux 2.NetworkManager配置
3.ipaddress 配置文件
4.nmtui 配置 ipaddress
二、实验
1.虚拟机Rocky Linux安装准备阶段
2.安装Rocky Linux
3.进入系统
三、问题
1.网络配置文件权限不够
一、理论 1.Rocky Linux （1）简介
Rocky Linux是一个社区企业操作系统，旨在100%兼容美国顶级企业Linux发行版，因为其下游合作伙伴已经改变了方向。它正在由社区密集开发。Rocky Linux由CentOS项目的创始人Gregory Kurtzer领导。请贡献者使用此站点上提供的通信选项进行联系。
Rocky Linux 是 CentOS 的一个分支，它位于 Red Hat Enterprise Linux（RHEL） 的下游。与 CentOS 一样，它提供了非常适合服务器的稳定版 Linux。它旨在作为 CentOS 的完全兼容替代品。
（2）下载
官网：
Rocky Linux
Rocky Linux官网安装手册文档：
安装 Rocky Linux 9 - Documentation
阿里巴巴开源镜像站：
阿里巴巴开源镜像站-OPSX镜像站-阿里云开发者社区
阿里巴巴Rocky Linux镜像源链接：
rockylinux镜像_rockylinux下载地址_rockylinux安装教程-阿里巴巴开源镜像站
2.NetworkManager配置 (1)网络配置
从 Rocky Linux 9 开始，网络配置发生了很多变化。其中一个主要变化是从网络脚本（仍然可以安装但实际上已弃用）转向使用网络管理器和密钥文件，而不是基于文件ifcfg。NetworkManager从 9 开始，优先keyfiles于以前的ifcfg文件。由于这是现在的默认设置，因此配置网络的行为现在应该采用默认设置作为正确的做事方式，因为多年来的其他变化意味着最终会弃用和删除旧的实用程序。本指南将尝试引导您完成 Network Manager 的使用以及 Rocky Linux 9 中的最新更改。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8954147dcc8f736336cc6e17b0a8b5da/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/610f58cdc61bb658543c087e9301c8e6/" rel="bookmark">
			java web蚁群算法，利用百度地图动态展示路径，界面漂亮
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在2023年3月份曾经写过一篇博客，介绍图形化蚁群算法的具体实现。博客地址在****可以看到。前端时间应一个朋友的要求，对蚁群算法的实现用java web来进行实现，并且通过百度地图来进行展示最终的最优路径。经过半个月的开发，我完成了java web蚁群算法，并且通过这篇博客与大家分享。目前java web蚁群算法系统功能已经很全面，后续会进一步完善。整个系统界面漂亮，有完整得源码，希望大家可以喜欢。喜欢的帮忙点赞和关注。一起编程、一起进步。
系统主要功能 系统分两个部分，快递员和系统管理员。快递员设置自己的位置，和查看最近路径，并且在地图上进行展示。系统管理员对整个系统进行日常的维护，包括的功能包括：用户管理、位置管理等。整个系统功能模块图如下所示：
蚁群算法简介 蚁群算法是受到对真实蚂蚁群觅食行为研究的启发而提出。生物学研究表明：一群相互协作的蚂蚁能够找到食物和巢穴之间的最短路径,而单只蚂蚁则不能。生物学家经过大量细致观察研究发现,蚂蚁个体之间的行为是相互作用相互影响的。蚂蚁在运动过程中,能够在它所经过的路径上留下一种称之为信息素的物质,而此物质恰恰是蚂蚁个体之间信息传递交流的载体。蚂蚁在运动时能够感知这种物质,并且习惯于追踪此物质爬行,当然爬行过程中还会释放信息素。一条路上的信息素踪迹越浓,其它蚂蚁将以越高的概率跟随爬行此路径,从而该路径上的信息素踪迹会被加强,因此,由大量蚂蚁组成的蚁群的集体行为便表现出一种信息正反馈现象。某一路径上走过的蚂蚁越多,则后来者选择该路径的可能性就越大。蚂蚁个体之间就是通过这种间接的通信机制实现协同搜索最短路径的目标的。假设m只蚂蚁在图的相邻节点间移动，从而协作异步地得到问题的解。每只蚂蚁的一步转移概率由图中的每条边上的两类参数决定：1. 信息素值也称信息素痕迹。2.可见度，即先验值。
2.信息素的更新方式有2种，一是挥发，也就是所有路径上的信息素以一定的比率进行减少，模拟自然蚁群的信息素随时间挥发的过程；二是增强，给评价值“好”(有蚂蚁走过)的边增加信息素。
3.蚂蚁向下一个目标的运动是通过一个随机原则来实现的，也就是运用当前所在节点存储的信息，计算出下一步可达节点的概率，并按此概率实现一步移动，逐此往复，越来越接近最优解。
4.蚂蚁在寻找过程中，或者找到一个解后，会评估该解或解的一部分的优化程度，并把评价信息保存在相关连接的信息素中。
系统框架 开发语言为Java，开发环境Eclipse或者IDEA都可以。数据库采用：MySQL。
本项目是基于MVC的JSP技术进行的Web应用程序开发，其中
1 JSP技术为表示层，包括EL表达式、JSP动作、JSTL标准标签技术
2 Servlet为控制层技术
3JavaBean为开发模型层
4 采用MVC设计模式对各个模块进行开发
5数据库采用mysql数据库
6 采用Tomcat作为Web服务器
7火狐浏览器，360浏览器，Chrome浏览器，IE浏览器做为本次程序的运行浏览器
设置参数 运行本蚁群算法，需要设置一些参数，这些参数是在Java 窗体里面根据需要进行动态的设置。
private Ant[] ants; // 蚂蚁
private int cityNum; // 城市数量
private int[] x; // X坐标矩阵
private int[] y; // Y坐标矩阵
private double[][] distance; // 距离矩阵
private double[][] pheromone; // 信息素矩阵
private int bestLength; // 最佳长度
private int[] bestTour; // 最佳路径
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/610f58cdc61bb658543c087e9301c8e6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6d1e82abb80ca19e0089a657cf50200/" rel="bookmark">
			route命令 路由表 Linux Centos
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		route route命令在Linux中被用于显示和操纵IP路由表。然而，现在大部分Linux发行版都推荐使用ip route命令代替route，因为ip route提供更多的功能和更灵活的控制。
以下是route命令的基本用法：
查看路由表: route -n 这个命令显示当前机器的路由表。-n标志意味着数字形式的网络地址，而不是尝试解析主机名。
添加路由: route add -net 192.168.1.0 netmask 255.255.255.0 gw 192.168.1.1 dev eth0 这个命令添加一个网络路由，将192.168.1.0/24网络的数据包通过192.168.1.1的网关发送，通过eth0接口。
删除路由: route del -net 192.168.1.0 netmask 255.255.255.0 gw 192.168.1.1 这个命令删除上面添加的路由规则。
注意：route命令修改的路由表在重启后会丢失，如果你想永久添加或删除路由，需要将其添加到网络配置文件或者启动脚本中。
尽管route命令依然可以使用，但现代Linux系统中，大多数情况下都推荐使用ip route命令，因为它提供了更多的功能和更好的控制。
例如，你可以使用ip route show来查看路由表，使用ip route add 192.168.1.0/24 via 192.168.1.1 dev eth0来添加路由，使用ip route del 192.168.1.0/24 via 192.168.1.1来删除路由。
另外，ip route命令还支持更多的选项和参数，如源路由，策略路由等，这使得它比route命令更强大、更灵活。
# 修改路由表信息; metric是优先级; 修改的话必须能匹配到才可以修改 ip route change 172.16.193.0 via 0.0.0.0 metric 300 dev veth01 ​ # 删除路由表 ip route del 172.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f6d1e82abb80ca19e0089a657cf50200/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15763043f843df3c3501f135e5c2d3d8/" rel="bookmark">
			K8S群集调度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、调度约束二、Pod 启动典型创建过程三、K8S的调度过程3.1 Predicate（预选策略） 常见的算法使用3.2 常见优先级选项3.3 指定调度节点3.3.1 nodeName指定3.3.2 nodeSelector指定3.3.3 Pod亲和性与反亲和1.节点亲和硬策略示例2.节点亲和软策略示例3.硬限制和软限制结合使用4.使用 Pod 亲和性调度，创建多个 Pod 资源5.反亲和的硬策略6.反亲和的软策略 3.3.4 污点(Taint)1. 打上污点2. 删除污点 3.3.5 容忍(Tolerations)3.3.6 其它注意事项3.3.7 cordon 和 drain 对节点执行维护操作 3.4 Pod启动阶段（相位 phase）3.4.1 phase 的可能状态3.4.2 如何删除 Unknown 状态的 Pod3.4.3 故障排除步骤 四、总结4.1 亲和性4.2 污点4.3 容忍4.4 不可调度4.5 Pod 生命周期的 5 种状态4.6 排障手段 一、调度约束 Kubernetes 是通过 List-Watch 的机制进行每个组件的协作，保持数据同步的，每个组件之间的设计实现了解耦。
用户是通过 kubectl 根据配置文件，向 APIServer 发送命令，在 Node 节点上面建立 Pod 和 Container。
APIServer 经过 API 调用，权限控制，调用资源和存储资源的过程，实际上还没有真正开始部署应用。这里 需要 Controller Manager、Scheduler 和 kubelet 的协助才能完成整个部署过程。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/15763043f843df3c3501f135e5c2d3d8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39dd988bd03c8793f86aa9fff505474c/" rel="bookmark">
			【23物联网国赛样题第一套】蓝色ZigBee节点盒按键长按控制，物联网竞赛今年历年国赛样题真题代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目要求： 程序通电，节点盒的LED1、LED2灯都不亮。长按SW1键不松开，LED1灯亮，LED2灯熄灭。松开SW1键，LED1、LED2亮灯都常亮。将编写好的程序发布到蓝色ZigBee节点盒中。 题目分析： 这是一道基础题，题目并不难，考验选手是否掌握单片机基本IO控制，是否知道按键与灯的引脚，考验按键长短按的逻辑。
编程思路： 我们先正常编写按键的代码，然后在其中按下与松开部分加入灯的效果。这道题说长按，一般按键按下松开时间在0.3s以内，为了题目更直观，我们设置为1s。
代码实现： ※这里使用2022版ZigBee通用工程
/*定义按键与灯的引脚*/ #define Sw1 P1_2 #define Led1 P1_0 #define Led2 P1_1 unsigned int count = 0; /********************* Init初始化与main函数部分， 这边我比较懒写在一起， 初始化只用了DIR， 其他的均为默认 **********************/ /********************MAIN************************/ void main(void) { halBoardInit(); P1DIR = 0X1B; //初始化按键与灯的io P1=0X00;//默认关闭所有灯光 while(1) { if(Sw1 == 0) { while(Sw1==0) { halMcuWaitMs(1); if(++count&gt;999)//这里是确定按键长按后开始亮灯 { Led1 = 1; Led2 = 0; } } if(Sw1 == 1) //松手复位长按变量，并亮灯 { count=0; Led1 = 1; Led2 = 1; } } } } 这道题目相当简单，按照我们学校的水平来说碰到这种题一定要在5min内写完收拾设备，这种题目毫无难度，相当基础。也没什么好说的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f63c51d7a39e03454d6d371b63b118ed/" rel="bookmark">
			【C&#43;&#43;】通讯录管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.系统功能介绍与展示 2.创建项目 3.菜单功能 代码：
//-封装函数显示该界面 如 void showMenu() //-在main函数中调用封装好的函数 #include &lt;iostream&gt; using namespace std; //-菜单界面 void showMenu() { cout &lt;&lt; "***************************" &lt;&lt; endl; cout &lt;&lt; "***** 1、添加联系人 *****" &lt;&lt; endl; cout &lt;&lt; "***** 2、显示联系人 *****" &lt;&lt; endl; cout &lt;&lt; "***** 3、删除联系人 *****" &lt;&lt; endl; cout &lt;&lt; "***** 4、查找联系人 *****" &lt;&lt; endl; cout &lt;&lt; "***** 5、修改联系人 *****" &lt;&lt; endl; cout &lt;&lt; "***** 6、清空联系人 *****" &lt;&lt; endl; cout &lt;&lt; "***** 0、退出通讯录 *****"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f63c51d7a39e03454d6d371b63b118ed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/571b77d656a11d368e2d4545715571ae/" rel="bookmark">
			解决问题：在Linux中找不到wget命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux作为一个广泛使用的操作系统，被广泛用于服务器和开发环境。在Linux上执行命令是日常工作中的常见任务，然而，有时候可能会遇到一些问题。本文将重点解决一个常见问题：在Linux系统中找不到wget命令。我们将通过参考howtouselinux.com上的相关文章来解决这个问题，并提供详细的解决方法和示例。
参考文章：
本文的解决方案参考了howtouselinux.com上的文章，该文章提供了有关找不到wget命令的问题的提示和解决方法。我们将在此基础上进行拓展，以便更全面地解决这个问题。
解决问题的方法：
检查wget是否安装： 首先，我们需要确认是否在系统上安装了wget。执行以下命令检查：
which wget 如果安装了wget，则会显示该命令的路径（例如：/usr/bin/wget）。如果没有安装，你将看到空白输出或没有输出。
安装wget： 如果系统中没有wget，我们可以使用包管理器来安装它。以下是一些常见Linux发行版的包管理器命令：
对于Debian/Ubuntu系统，使用apt：
sudo apt update sudo apt install wget 对于Red Hat/CentOS系统，使用yum：
sudo yum install wget 对于Fedora系统，使用dnf：
sudo dnf install wget 对于其他Linux发行版，请查阅其对应的包管理器命令。
确认wget是否安装成功： 安装完成后，再次运行which wget命令来确认wget是否已成功安装。
使用wget命令： 安装成功后，你可以在终端中直接使用wget命令来下载文件。例如，下载一个示例文件：
wget https://example.com/file.txt wget将下载并保存file.txt文件到当前目录。
总结：
在Linux中找不到wget命令是一个常见的问题，但通过安装wget软件包，我们可以轻松地解决这个问题。wget是一个功能强大的工具，用于从Web上下载文件，并在服务器管理和开发中广泛使用。
如果你想深入学习Linux的相关命令和知识，我们整理了一份Linux学习的PDF文件，供你参考：Linux学习指南。希望对你的Linux学习之路有所帮助！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be7156dd2f134f5f53df06c9361887d1/" rel="bookmark">
			深入了解Linux用户管理：如何列出所有用户
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Linux系统中，用户管理是非常重要的任务之一。了解当前系统上的所有用户是系统管理员和安全专业人员的关键任务之一。本文将介绍如何列出Linux系统中的所有用户，并且提供了实际的解决方案和示例。参考文章Linux Command: List All Users in Linux将为我们提供更多关于此问题的见解。
列出所有用户的方法：
在Linux系统中，有几种方法可以列出所有用户。下面我们将详细介绍每种方法以及它们的优点。
方法一：使用cat命令查看/etc/passwd文件
/etc/passwd文件是一个包含系统上所有用户信息的文本文件。每行代表一个用户，包含用户名、用户ID、组ID、用户描述和家目录等信息。通过使用cat命令，我们可以查看该文件的内容，并从中获取所有用户的信息。
示例：
cat /etc/passwd 优点：这是一个简单直接的方法，不需要额外的工具。
方法二：使用cut命令和/etc/passwd文件
cut命令可以用来从文件中提取特定的字段。在这种方法中，我们可以使用cut命令来提取每行中的用户名字段。
示例：
cut -d: -f1 /etc/passwd 优点：使用cut命令可以更加灵活地选择我们需要的信息。
方法三：使用awk命令和/etc/passwd文件
awk命令是一种用于处理文本文件的强大工具。在这种方法中，我们可以使用awk命令来提取每行中的用户名字段。
示例：
awk -F: '{print $1}' /etc/passwd 优点：awk命令具有强大的文本处理功能，可以更好地满足复杂需求。
方法四：使用getent命令
getent命令用于获取某个数据库中的数据，包括用户数据库。使用getent命令，我们可以直接获取所有用户的信息。
示例：
getent passwd | cut -d: -f1 优点：getent命令可以获取不仅仅是/etc/passwd文件中的用户信息，还包括其他用户数据库的信息。
方法五：使用less命令查看/etc/passwd文件
less命令是一个用于浏览文本文件的分页器。使用less命令，我们可以逐页查看/etc/passwd文件，并浏览其中的所有用户信息。
示例：
less /etc/passwd 优点：less命令提供了方便的分页浏览功能，适用于大型文件。
总结：
本文介绍了在Linux系统中列出所有用户的五种方法，包括使用cat命令、cut命令、awk命令和getent命令。每种方法都有其优点和适用场景。通过了解这些方法，您可以更好地管理系统中的用户，并确保系统的安全性。
如果您想深入学习Linux命令和系统管理知识，我们整理了一份Linux学习的pdf文件，放在下面的路径，可以自提：
Linux Commands for Linux Beginners Cheat Sheet
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b27defa7986d9b79226b31588ce83a1/" rel="bookmark">
			解决SSH连接错误ssh connect to host port 22 No route to host
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SSH（Secure Shell）是在Linux系统中常用的远程连接工具，但有时我们可能会遇到"ssh: connect to host port 22: No route to host"错误，表明无法建立SSH连接。本文将参考并引用howtouselinux.com上的文章，详细介绍如何解决这个问题，并提供解决方法和实例。
解决方法：
检查网络连接：首先，确保你的系统具有正常的网络连接，并能够访问目标主机。尝试使用ping命令测试是否能够与目标主机通信。
ping target_host 如果无法与目标主机通信，可能是网络问题，需要检查网络设置和路由配置。
检查目标主机的SSH服务：确认目标主机的SSH服务是否正常运行，并监听在22端口上。使用telnet命令测试SSH端口是否开放。
telnet target_host 22 如果连接被拒绝或显示"Connection timed out"错误，可能是目标主机的SSH服务未启动或有防火墙阻止了SSH连接。
检查防火墙设置：确保目标主机的防火墙没有阻止SSH连接。如果你有访问权限，可以尝试临时关闭防火墙并重新尝试SSH连接。
sudo systemctl stop firewalld # 停止Firewalld服务（根据你的系统使用适当的命令） ssh user@target_host 示例：
当你尝试使用SSH连接到目标主机时，可能会收到"ssh: connect to host port 22: No route to host"错误。首先，确认你的网络连接正常，目标主机可达。然后，检查目标主机上的SSH服务是否正常运行，并尝试测试SSH端口是否开放。最后，如果你怀疑是防火墙引起的问题，可以暂时关闭防火墙并重新尝试SSH连接。
总结：
"ssh: connect to host port 22: No route to host"错误通常与目标主机的SSH服务、网络连接或防火墙设置有关。通过检查网络连接、目标主机的SSH服务状态、防火墙设置，你应该能够解决这个问题，并成功建立SSH连接。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65b59e781999f72c6907d0721e8ed09d/" rel="bookmark">
			Python解决-力扣001-两数之和
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 在这篇博客中，我们将探讨一个流行的编程问题，称为两数之和问题（Two Sum problem）。给定一个整数数组和一个目标值，我们需要在数组中找到两个不同的元素，使它们的和等于目标值。我们将提供一个使用哈希映射的Python解决方案，并详细解释算法的步骤。
问题描述 给定一个整数数组 nums 和一个整数 target，找到数组中两个不同的元素，使它们的和等于目标值 target。我们可以假设每种输入都只有一个有效答案，并且同一个元素不能重复使用。
方法：使用哈希映射 我们可以使用哈希映射在线性时间内高效地解决两数之和问题。算法的思想是遍历数组，在每一步中检查目标值减去当前元素的差值（即补数）是否存在于哈希映射中。如果存在，说明我们已经找到了和为目标值的两个元素。否则，我们将当前元素及其索引存储在哈希映射中，以便用于后续比较。
Python解决方案 让我们使用Python类来实现解决方案：
class Solution: def twoSum(self, nums, target): num_map = {} # 创建一个空字典来存储元素及其索引 for index, num in enumerate(nums): other = target - num # 计算当前元素的补数 if other in num_map: # 检查补数是否存在于字典中 return [index, num_map[other]] # 返回两个元素的索引 num_map[num] = index # 将当前元素及其索引存储在字典中 示例用法 让我们使用提供的示例测试 twoSum 函数：
solution = Solution() # 示例1 nums1 = [2, 7, 11, 15] target1 = 9 result1 = solution.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/65b59e781999f72c6907d0721e8ed09d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dabc67be5c2c4e05540c12d15794892c/" rel="bookmark">
			JIT 与 C#热更
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JIT与AOT 一般程序运行有两种方式，静态编译与动态编译。 AOT: Ahead Of Time,预先（静态）编译 静态编译的程序，需要在执行之前全部翻译为机器码，运行前会使得程序安装时间相对较长，但程序运行的时候，性能和启动时间将会得到显著的优化，这种类型称为“AOT ”——提前编译。一般是用C/C++ 开发的应用。 JIT : Just-in-time, 动态（即时）编译 边解释边运行，可以根据当前硬件情况实时编译生成最优机器指令，也可以根据当前程序的运行情况生成最优的机器指令序列，但有时候会占用运行的资源，同时编译时间也会增加运行的时间，导致进程卡顿。一般是用 JavaScript 和 Python 的应用等。 所有脚本语言都支持 JIT 模式。但需要注意的是 JIT 和 AOT 指的是程序运行方式，和编程语言并非强关联的，有些语言既可以以 JIT 方式运行也可以以 AOT 方式运行，如 Java 、 Python 。 它们可以在第一次执行时编译成中间字节码、然后在之后执行时可以直接执行字节码，中间字节码并非机器码，在程序执行时仍然需要动态将字节码转为机器码，不过通常我们区分是否为 AOT 的标准就是看代码在执行之前是否需要编译，只要需要编译，无论其编译产物是字节码还是机器码，都属于 AOT 。 JIT 与热更新 为什么使用 Lua 作为热更新语言，不用 C# 热更新本身对于资源热更新是非常容易的，Unity 自带的 AB 包就可以轻松解决，难的是代码热更新，因为 Unity 中的 C# 是编译型语言， Unity 在打包后，会将 C# 编译成一种中间代码，再由 Mono 虚拟机编译成汇编代码供各个平台执行，它打包以后就变成了二进制了，会跟着程序同时启动，就无法进行任何修改了。 LUA 是解释型语言，并不需要事先编译成块，而是运行时动态解释执行的。这样 LUA 就和普通的游戏资源如图片，文本没有区别，因此可以在运行时直接从 WEB 服务器上下载到持久化目录并被其它 LUA 文件调用。 不用 C#热更的原因 准确的说，C# 在安卓上可以实现热更新，但在苹果上却不能。那 C# 为什么不做成解释型语言呢？因为 C# 的定位是一个追求效率且功能强大的编译型语言。在安卓上可以通过 C# 的语言特性 - 反射机制实现动态代码加载从而实现热更新。 具体做法是：将需要频繁更改的逻辑部分独立出来做成 DLL ，在主模块调用这些 DLL ，主模块代码是不修改的，只有作为业务（逻辑）模块的 DLL 部分需要修改。游戏运行时通过反射机制加载这些 DLL 就实现了热更新。 但苹果对反射机制有限制，不能实现这样的热更。为什么限制反射机制？安全起见，不能给程序太强的能力，因为反射机制实在太过强大，会给系统带来安全隐患。 解决：C#热更新 lLRuntime 项目为基于 C# 的平台 ( 例如 Unity) 提供了一个纯以实现， 快速、防便且可靠的 IL 运行时，使得能够在不支持 JIT 的硬件环境 ( 如iOS)能够实现代码的热更新。 编译原理：它把代码分为两个 dll 文件，启动的时候只启动一个，另一个 dll 通过反射启动，在没启动第二个热更的 dll ，将第一个 dll 文件替换掉。来达到一个热更的效果。 关于JIT
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dabc67be5c2c4e05540c12d15794892c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6998821409593d04f8a20aef6a22593a/" rel="bookmark">
			浅谈Vue3 computed计算属性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是computed 官方给出的解释：接受一个 getter 函数，返回一个只读的响应式 ref 对象。该 ref 通过 .value 暴露 getter 函数的返回值。它也可以接受一个带有 get 和 set 函数的对象来创建一个可写的 ref 对象
// 只读 function computed&lt;T&gt;( getter: () =&gt; T, debuggerOptions?: DebuggerOptions ): Readonly&lt;Ref&lt;Readonly&lt;T&gt;&gt;&gt; // 可写的 function computed&lt;T&gt;( options: { get: () =&gt; T set: (value: T) =&gt; void }, debuggerOptions?: DebuggerOptions ): Ref&lt;T&gt; 从代码上看这么解释毫无破绽，甚至于说人尽可知。但是很少有人知道computed或者想了解其真正有用的几大特性
computed实用特性 1. 依赖追踪
import { reactive, computed } from 'vue' const state = reactive({ s1: 1, s2: 2 }) const info = computed(() =&gt; { return state.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6998821409593d04f8a20aef6a22593a/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/67/">«</a>
	<span class="pagination__item pagination__item--current">68/321</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/69/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>