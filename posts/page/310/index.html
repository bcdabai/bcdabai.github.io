<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca387aef25cae5257c507cfffedc3391/" rel="bookmark">
			ffmpeg码率控制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.VBR与CBR的含义和区别 VBR是动态码率。CBR是静态码率。
VBR（Variable Bitrate）动态比特率。也就是没有固定的比特率，压缩软件在压缩时根据音频数据即时确定使用什么比特率，这是以质量为前提兼顾文件大小的方式。 VBR也称为动态比特率编码，使用这个方式时，你可以选择从最差音质/最大压缩比到最好音质／最低压缩比之间的种种过渡级数，在MP3文件编码之时，程序 会尝试保持所选定的整个文件的品质，将选择适合音乐文件的不同部分的比特率来编码。主要优点是可以让整首歌都能大致达到我们的品质要求，缺点是编码时无法 估计压缩出来的文件大小。
CBR（Constants Bit Rate）即固定码率，就是静态（恒定）比特率的意思，CBR是一种固定采样率的压缩方式。优点是压缩快，能被大多数软件和设备支持，缺点是占用空间相对大，效果不十分理想，现已逐步被VBR的方式取代。
固定码率是一个用来形容通信服务质量（QoS，Quality of Service）的术语。和该词相对应的词是可变码率或可变比特率（英文variable bit rate，缩写VBR）。
当形容编解码器的时候，CBR编码指的是编码器的输出码率（或者解码器的输 入码率）应该是固定制（常数）。当在一个带宽受限的信道中进行多媒体通讯的时候CBR是非常有用的，因为这时候受限的是最高码率，CBR可以更好的易用这 样的信道。但是CBR不适合进行存储，因为CBR将导致没有足够的码率对复杂的内容部分进行编码(从而导致质量下降)，同时在简单的内容部分会浪费一些码 率。
二.ffmpeg设置方法 ffmpeg中CBR（固定码率控制）的设置： c-&gt;bit_rate = br; c-&gt;rc_min_rate =br; c-&gt;rc_max_rate = br; c-&gt;bit_rate_tolerance = br; c-&gt;rc_buffer_size=br; c-&gt;rc_initial_buffer_occupancy = c-&gt;rc_buffer_size*3/4; c-&gt;rc_buffer_aggressivity= (float)1.0; c-&gt;rc_initial_cplx= 0.5; ffmpeg中VBR（可变率控制）的设置：
c-&gt;flags |= CODEC_FLAG_QSCALE; c-&gt;rc_min_rate =min; c-&gt;rc_max_rate = max; c-&gt;bit_rate = br; 三.试用场景 VBR 适合的应用场景是媒体存储，而不是网络传输。
其实实际网络传输中所谓的 CBR 一般都是 ABR（平均比特率），即只要是单位时间内把码率控制在额定码率就可以了，因为编码输出本来就有缓冲可以起到平滑波动的作用。
严格意义上的 CBR 是 每一帧都分配同样的码字，试想一下，如果某一帧所需要的码字本来就很少，而你却一定要给它分配很多码字，那不是浪费么？另一方面，如果某一帧所需要的码字 本来就多，而你却给得很少，那这帧的效果会很差。这样编下来，整体序列质量会忽好忽坏地不停发生跳变，反而对视觉冲击很大；因此 ABR 才是最适合网络传输的方案。 本文出处：http://blog.csdn.net/austinblog/article/details/28426587 转载于:https://www.cnblogs.com/jameszh/p/4237619.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da6e9b534edb7969c3fcbbdd522c4d1c/" rel="bookmark">
			我是如何开会的
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 ﻿﻿ 开会的主要目的不是通报情况，因为书面的Ｅｍａｉｌ或业务简报可以胜任；也不是安排任务，下达命令，因为这些可以单独进行；更不是交流感情，加深印象，塑造自己形象，因为​管理者的形象是潜移默化的结果。　开会的主要目的只有两个：一是统一思想；二是协同动作。只有要吵架的事情才需要开会。（很多企业把情况通报当成开会主要内容，这是错误的，开会的目的就是为解决问题群策群力，所以要形成决议。所以 开会的前提是有问题，需要大家形成共识，并通过开会找到解决办法，并立即执行。）　为什么要统一思想？是因为有对抗的情绪需要熨平：有人对企业的方向有异议，而企业绝对不允许出现八匹马向八个方向狂奔的情况，必须万众一心，如臂使指。　为什么要协同动作？是因为各单位或部门对任务理解有歧义，或者对工作的结转和移交的统一标志有异议，或者对责任分配有看法等等。而企业工作是各个参与方协同才能完成的结果​，不是各人自扫门前雪莫管他人瓦上霜，更不是自己做到今日事今日毕即可，那样就会出现房子还没有砌墙，装窗子的就来把窗子装在天花板上的情况。步骤和次序是需要协同才能实​现的，１＋１＞２的合力，更需要各个单位在规定时间，达到预定空间，完成自己任务，而不是自行其事。　其实极端点说，一家公司的开会效率与执行会议决议的能力决定了企业的竞争力。　就我自己经验，准备会议时间是开会时间的3倍以上。因为我要想清楚开会的目的和内容----会议希望达成的结果。（开会是个成本极高的事情，不能轻易开。一群人什么事情不干，什么价值不创造，这是高成本），我要准备好议题和议程，准备好讨论题纲和希望达成的决议​，以及派生的任务单，还要准备好会议时间控制的办法和要点：何时小结，何时转移议题，对可能的对抗如何处置等等。 同时并把会议议题、议程和时间表，以及爻与会者准备的背景资料和发言内容一起通知他们。 开会绝对不能开成失控的菜市场，也不能一无所得。一般我开会，先要用3分钟说清楚会议的目的，目标，议题的含义和议程，然后按顺序发言（一般议题会在三天前下发与会者，让他们准备发言资料），一般每人5分钟，最多10分钟，每一个议题一讨论一圈（每人都发一次言后），我就立即小结：不同意见的要点，然后诱导大家求同存异，争取达成我希望的​一致意见。　其实开会的关键往往在最后十分钟，这时你必须将初步的会议纪要大纲让所有与会者过目，让大家认可，并且会议一结束就同步发送给与会者。（我是把会议纪要当成推行我的管​理意志的最重要工具，我的会议纪要经常与会议记录相去很远，甚至风马牛不相及，但是又是会议讨论的范畴。很多时候，在开会前我就把会议纪要和会议决议都写好了） 根据会议纪要，就要形成会后贯彻执行的任务单，这点不能有任何糊的争议空间。不然你就很难贯彻你的管理设想。 当然在会议进行中，一定要不预设立场，要鼓励大家发言，群策群力，不要因为某人想法幼稚而吼人，避免扼杀创意。每一位与会者都有表达不同意见的义务，但是一旦决议形成，就​不允许讨价还价，必须不折不扣执行，否则杀无赦。这就是公司的纪律。 会议时间不能太长，我很少开2小时以上的会，一般就一小时。因为40分钟是动脑时间的上限，超过这个时间就会失去注意力。所以一般开会不要超过3个议题。 会议的价值在议后速决，决后速行，决议内容、执行人、执行日期爻清清楚楚纪录明白，根据决议形成行动方案。 会议主持者要预先设想可能的冲突和对抗，想到解决的办法（一般我是事前与这些人沟通，沟通好再开会）。 我的经验是要善于仔细倾听他人发言，知道他没说出来的背后的意思。同时要制造会议的紧张感，没有紧张感就不是会议。 要善于掌握会议重要决策的关键时刻和形成决议的关键时刻。不要任其发展，最后不了了之。控制会议进程往往是一种意志较量。 当下达一个任务给部下就撒手不管，不闻不问，等到年底任务没有完成，杀人偿命，这不是管理，这是职业谋杀。 正常的管理是当我们下达一个任务后，不但要保证他们充分理解任务的含义，知道自己在干什么；还要与部下共同确定任务执行要点和细节，并指导他们完成任务，也即知道怎么干。​ 在日常生活中，我们都知道：当给一个部下从天安门到中关村的任务。然后部下说没问题。我们真的敢相信他能完成任务吗？我们在什么情况下会相信呢？ 显然我们必须知道他的时间预算和相应的交通工具：如果预算半小时，我们就知道不管用什么工具都不可能做到（当然坐直升机例外，但是京城除军事行动外不准飞直升机），这个计​划的执行方案不可行；如果预算八小时，我们也知道这个计划的执行方案很糟糕，埋伏太多。 其次是我们必须知道执行方案的控制要点：例如主要路径的关键点，如果有地安门，北师大，大钟寺之类，我们会觉得八九不离十，如果是门头沟，丰台，涿州之类，我们就知道计划​的执行注定失败。 所以我们给部下下达任务，不但要他保证完成任务，更需要他告诉你他准备怎么完成任务。 举例来讲，我在某连锁零售集团当总裁时，给某业态公司的总经理下达了一年一亿的税后利润任务，那么下面我该做什么呢？我必须每周和她开一次工作会议（会议的重要性与参与人​数成反比），每次2小时。会议内容分为以下三类： 一、计划执行前（要花1天左右时间） 1、评估执行方案可行性 （1）、几个主要指标的判断：计划销售收入是多少（行业的平均税后利润率在3%，所以销售一般正常应该在33亿左右，如果报的过多或过少都有问题，过多说明效率低，管理松​懈；过少则说明作假或打埋伏）；计划销售毛利率是多少（行业平均毛利率在18%，如果报的过高，是在杀鸡取卵，把优质供应商赶走，留下一批癞皮狗；如果报的过低，说明或者​徇私舞弊，或者管理能力低下）；计划客单价是多少（行业客单价一般是70元，太高说明作假，不可行；太低说明商品配置有问题，或者质量差）；人均销售是多少（行业一般是2​00万年人，太高说明剥削员工太狠，迟早出事；太低说明管理太差）；平米销售是多少（一般是3万年平米，报的太高，说明作假；报的太低，说明徇私舞弊，私下出租柜台赚钱）​；流动资金是多少（行业平均年周转率7次，所以需要约五亿流动资金，其中百分之八十是占用供应商货款，所以需要一亿银行贷款流动资金。报的太高，说明管理不行；报的太低，​说明剥削供应商太狠，在竭泽而渔）等等。 （2）、销售的时空分解：我要求分解到周和店（以前在制造业是分解到产品，在海航是分解到航线）。并说清楚分解的理由和依据。 （3）、销售强化手段：一般说来非节假日平均每天销售750万，全年也就27、8亿左右，要想完成33亿，就必须在节假日促销（黄金周可达每天1500万）。所以我要求告​诉我每一个节假日促销的安排：促销的卖点（价格优惠？品项搭配？新品推出？）；促销的宣传方案；促销的商家赞助安排；促销的配送保障等等。总之我要知道怎么完成任务的细节​。 （4）、物流配送能力保障：从货源安排锁定，到采购订货（这是实时的，容易漏定或错定），到物流运输，到商品检验，到上架促销，到退换货，到结算一个流程的安排和保障。 2、优化执行路径 （1）、如何提高全员劳动效率：如何激励（例如奖金安排，工作餐之类生活关怀）？如何排班？如何培训？如何强化应知应会？如何流程化和规范化（例如看板上墙，晨会排班等等​） （2）、如何降低成本：节约计划（水电气，包装废弃物回收等等）；降低退换货；减少冗余人员；集团采购等等。 （3）、如何提高采购质量：供应商认证；检测强化；品项管理；缺货实时响应等等。 （4）、如何促销：海报促销；堆头促销；搭配促销；应季促销；价格促销等等。 3、确认执行要点和控制点 （1）、客单价和来客数：这是最直接的观察运营质量的窗口，每天必须上报。 （2）、缺货率：这是判断商品配置是否合理，采购订货配送是后正常的窗口，每天上报。 （3）、库存周转率：这个是衡量经营效率的核心数据，每周上报，并每月盘点。 （4）、损耗率：这是现场管理的核心数据，每周上报，并随机抽查。 （5）、品项数和品相清单：这是基于对顾客消费偏好和消费心理理解的前提下确定的，是核心竞争力，相当于配方，每月调整一次。 二、计划执行中（每周一次，每次2小时，实际上经常在巡检路上的汽车里面开） 1、检核执行进度和执行质量 （1）、执行进度与计划进度比较：同比，环比。 （2）、不定期巡检结果讨论 （3）、越权和渎职检核清单确认 2、发现执行问题和查找原因 （1）、计划不达成：商品质量或品项？消费者偏好？竞争环境？价格？供应商配合？促销？等等。 （2）、虚假和泡沫：假销售？负毛利销售？乱收费？等等。 （3）、内外勾结徇私舞弊：卖大宗？空库存？假货？柜台出租？等等。 3、调整执行路径和计划指标 （1）、指标调整：可能环境变化，指标过高或过低。我认为计划指标与实际指标出现±20%差距，计划就算失败。 （2）、重点调整：可能由于竞争对手的变化，导致竞争焦点变化，例如从价格竞争变成质量或品项竞争。 （3）、人员调整：把不能力合适或不敬业的人赶出去。 三、计划执行后（需要1天左右） 1、业绩核实和奖惩兑现 （1）、根据年初预算，秋后算账：奖惩的依据 （2）、抽样现场巡查：突然大盘点 （3）、供应商恳谈会：发现采购猫腻的机会 2、经验总结和复盘优化 （1）、失败教训总结 （2）、运营模式优化 （3）、修改运营手册 3、下一阶段任务的准备：确定明年目标任务责任书 （1）、任务指标的讨价还价 （2）、人财物的配置讨价还价 （3）、利益分配的讨价还价 我认为领导一个人作报告的不叫会议，叫大会，是单向的宣达，是一种煽动或灌输，起凝聚力量，鼓舞士气作用，不能多搞，多了就烦了，适得其反。在管理中，真正有价值的会议是​一问一答的交流。 开会不能开成恳谈会，必须给部下有压力，要他说真话，动脑筋，想法解决问题，而不是糊弄你，更不能到年底弄个完不成任务，使你进退两难：不杀吧，对不起完成任务的人，也不​能维护企业秩序；杀吧，没人可用了。结果搞得你威信扫地：不能干活的废材。 所以管理者并不好当，要大处着眼，小处着手。不管细节的管理者都是失败的管理者。细节决定生死。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/641a18d0019f33822056a3f9e76bc866/" rel="bookmark">
			左式堆的实现与详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		左式堆的性质: 像二叉堆那样既有结构性质，又有堆序性质。事实上，和所有使用的堆一样，左式堆具有相同的堆序性质，该性质我们已经看到过。不仅如此，左式堆也是二叉树，左式堆和二叉堆唯一的区别是:左式堆不是理想平衡的,而且事实上是趋于非常不平衡的。
零路径长：(null path length) 假设有个结点x,npl(x)定义为x到一个不具有两个儿子的结点的最短路径的长，因此，具有0个或1个儿子的结点的npl为0，而npl(null) = -1.
左式堆的操作: 由于两个左式堆需要合并，所以用数组就显得不是那么的合适了，因为需要把一个数组拷贝到另一个数组中去，对于大小相同的堆这将花费时间O(N),所以我们最好用链式结构来实现左式堆，而不是像二叉堆那样用数组(vector)去实现。
左式堆的插入: 左式堆的插入只是合并的特殊情形，因为可以把插入看成是单结点堆与一个大的堆的merge。
左式堆的合并: 假设有H1,H2两个堆需要合并，那么,如果这两个堆中有一个堆是空的，那么可以直接返回另外一个堆，否则，为了合并这两个堆，需要先比较他们的根，首先将具有大的根值的堆和具有小的根值的堆的右子堆合并。因为左式堆的子堆也应该是左式堆，所以可以利用递归这一性质来进行合并，递归的流程为:先比较两个堆根结点的大小，取根结点值大的堆和根结点值小的右子堆合并，再比较所取右子堆当前根结点和结点较大堆根结点值的大小，然后依次这样比较下去，直到结点不能再分位置，然后就可以开始执行合并，遇到一个堆为空时返回另外一个堆。然后再将其合并到h1的右子树上(h1假设总是根结点较小的那棵树),就这样下去，直到合并完成。
左式堆的删除(Deletemin):
删除根结点后，执行合并根结点的左子树和右子树的方法即可。
Findmin(返回最小值): 堆如果不为空的话，很明显最小值就是根结点，因为满足堆的性质。
左式堆的代码如下: #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;algorithm&gt; using namespace std; class UnderflowException {}; template&lt;typename Comparable&gt; class LeftistHeap { public: LeftistHeap():root(NULL) {} LeftistHeap(const LeftistHeap &amp;rhs) { *this = rhs; } ~LeftistHeap() { makeEmpty(); } bool isEmpty() const; const Comparable &amp; findMin() const; void insert(const Comparable &amp; x); void deleteMin(); void deleteMin(Comparable &amp; minItem); void makeEmpty(); void merge(LeftistHeap &amp; rhs); const LeftistHeap &amp; operator = (const LeftistHeap &amp; rhs) { if(this !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/641a18d0019f33822056a3f9e76bc866/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1076a95bd30e0b3de1a202cf75c45232/" rel="bookmark">
			自动换行的方法，总有一种适合你的解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		css控制div自动换行
对于div,p等块级元素 正常文字的换行(亚洲文字和非亚洲文字)元素拥有默认的white-space:normal,当定义的宽度之后自动换行
html
&lt;div id="wrap"&gt;正常文字的换行(亚洲文字和非亚洲文字)元素拥有默认的white-space:normal,当定义&lt;/div&gt;
css
#wrap{white-space:normal; width:200px; }
1.（IE浏览器）连续的英文字符和阿拉伯数字,使用word-wrap : break-word ;或者word-break:break-all;实现强制断行
#wrap{word-break:break-all; width:200px;}
或者
#wrap{word-wrap:break-word; width:200px;}
&lt;div id="wrap"&gt;abcdefghijklmnabcdefghijklmnabcdefghijklmn111111111&lt;/div&gt;
效果：可以实现换行
2.（Firefox浏览器）连续的英文字符和阿拉伯数字的断行,Firefox的所有版本的没有解决这个问题,我们只有让超出边界的字符隐藏或者,给容器添加滚动条
#wrap{word-break:break-all; width:200px; overflow:auto;}
&lt;div id="wrap"&gt;abcdefghijklmnabcdefghijklmnabcdefghijklmn111111111&lt;/div&gt;
效果：容器正常，内容隐藏
对于table
1. (IE浏览器)使用 table-layout:fixed;强制table的宽度,多余内容隐藏
&lt;table style="table-layout:fixed" width="200"&gt;
&lt;tr&gt;
&lt;td&gt;abcdefghigklmnopqrstuvwxyz1234567890ssssssssssssss
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
效果：隐藏多余内容
2.(IE浏览器)使用 table-layout:fixed;强制table的宽度,内层td,th采用word-break : break-all;或者word-wrap : break-word ;换行
&lt;table width="200" style="table-layout:fixed;"&gt;
&lt;tr&gt;
&lt;td width="25%" style="word-break : break-all; "&gt;abcdefghigklmnopqrstuvwxyz 1234567890
&lt;/td&gt;
&lt;td style="word-wrap : break-word ;"&gt;abcdefghigklmnopqrstuvwxyz 1234567890
&lt;/td&gt;
&lt;/tr&gt;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1076a95bd30e0b3de1a202cf75c45232/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0dbb28e1ed38c9d399a32cefb6895b5/" rel="bookmark">
			Python脚本报错AttributeError: ‘module’ object has no attribute’xxx’解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python脚本报错AttributeError: ‘module’ object has no attribute’xxx’解决方法 2014年04月30日 ⁄ 测试工具, 软件测试 ⁄ 共 678字 ⁄ 字号 小 中 大 ⁄ 暂无评论 ⁄ 阅读 12,782 次 最近在编写Python脚本过程中遇到一个问题比较奇怪：Python脚本正常的，但执行报错"AttributeError: 'module'object has no attribute 'xxx'"，其实是.pyc文件存在问题。
问题定位：查看import库的源文件，发现源文件存在且没有错误，同时存在源文件的.pyc文件
问题解决方法：删除该库的.pyc文件，重新运行代码；或者找一个可以运行代码的环境，拷贝替换当前机器的.pyc文件即可
示例：
如下Python代码，执行时报错"AttributeError: 'module' object has no attribute 'urlopen'"，更新Python27\Lib\urllib2.pyc文件后，即可正常运行。
1 import urllib2 2 url = "http://www.baidu.com" 3 f = urllib2.urlopen(url, timeout=5).read() 4 print len(f) 附录:
pyc文件介绍
pyc文件，是python编译后的字节码（bytecode）文件。只要你运行了py文件，python编译器就会自动生成一个对应的pyc字节码文件。这个pyc字节码文件，经过python解释器，会生成机器码运行（这也是为什么pyc文件可以跨平台部署，类似于java的跨平台，java中JVM运行的字节码文件）。下次调用直接调用pyc，而不调用py文件。直到你这个py文件有改变。python解释器会检查pyc文件中的生成时间，对比py文件的修改时间，如果py更新，那么就生成新的pyc。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1bda45f766b40a49c32bafa6b1a0e155/" rel="bookmark">
			Linux C编程下没有 itoa()函数的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用ubuntu linux c编程，发现Linux内核中只有atoi()函数，被包含在stdlib.h头文件中，而没有itoa()函数，网上查了有一个实现了itoa()函数的代码
void itoa ( unsigned long val, char *buf, unsigned radix ) { char *p; /* pointer to traverse string */ char *firstdig; /* pointer to first digit */ char temp; /* temp char */ unsigned digval; /* value of digit */ p = buf; firstdig = p; /* save pointer to first digit */ do { digval = (unsigned) (val % radix); val /= radix; /* get next digit */ /* convert to ascii and store */ if (digval &gt; 9) *p++ = (char ) (digval - 10 + 'a '); /* a letter */ else *p++ = (char ) (digval + '0 '); /* a digit */ } while (val &gt; 0); /* We now have the digit of the number in the buffer, but in reverse order.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1bda45f766b40a49c32bafa6b1a0e155/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99eec0d1f9014ed135823ed6f35094a8/" rel="bookmark">
			Material Design设计规范
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下面的内容是在《移动互联网沙龙开年篇》做的一点分享，关于Material Design设计规范相关的。
作为技术开发者需不需要了解设计规范？个人认为非常需要，一个交流的需要，另一就是了解相关的设计才能储备相应地知识，知道UI开发的方向。这问题非常希望读者能留言讨论。
Android的设计风格变迁可以划分到三个时代：
1、无序时代
2、Holo theme
3、Material Design
无序时代 无序时代是没有Android设计规范的。无序时代的Android应用设计主要是参考的iOS的设计规范及其拟物，以及Windows Phone扁平化的MetroUI,当然也有应用自成设计风格。 拟物设计注重实物的阴影材质， 扁平化注重信息的表达。下面两张图是拟物实现和MetroUI。
图一拟物实现 图二MetroUI
Holo Theme 2011年底google发布了Android 4.0 ，也就是通常所说的 ICS，同时也发布了指导性的应用设计规范《Android Design》， Holo theme 也是在Android 4.0才定下来的。虽然在3.0版本就已经有了一部分Holo的身影，但是android 3.X的设备占有率也不高，Holo在3.0算是尝试。《Android Design》只是指导性的规范，国内应用使用的不多。下图是Holo Theme的表现形式。Holo也算是扁平化的设计。 Material Design 什么是 Materail Design Google在I/O 2014上推出了新的设计语言Material Design。Material Design以现实世界的纸墨为隐喻，强调了阴影和层次，用动画效果代表现实的力反馈，试图把物理世界的规则带回电子界面。而就Android 平台而言，Material Design 不像此前的Holo 风格那样深沉，它更加跳动和富有活力。官方给出的解释：
Material design is a comprehensive guide for visual, motion, and interaction design across platforms and devices.
Materail Design的设计原则 Material design有三个设计原则，也是其核心部分：
1、隐喻 2、视觉设计 3、动画 Material is the metaphor（隐喻） 通过构建系统化的动效和空间合理化利用，并将两个理念合二为一，构成了实体隐喻。与众不同的触感是实体的基础，这一灵感来自我们对纸墨的研究。关于隐喻，我把分成了两点：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/99eec0d1f9014ed135823ed6f35094a8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e32162e21d3fbd1eea941a876f3e1925/" rel="bookmark">
			JQuery的AJAX调用（一）——加载传递数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一，load方法异步请求数据 使用load()方法通过Ajax请求加载服务器中的数据，并把返回的数据放置到指定的元素中，它的调用格式为：
load(url,[data],[callback])
参数url为加载服务器地址，可选项data参数为请求时发送的数据，callback参数为数据请求成功后，执行的回调函数。
二，使用getJSON()方法异步加载JSON格式数据 使用getJSON()方法可以通过Ajax异步请求的方式，获取服务器中的数组，并对获取的数据进行解析，显示在页面中，它的调用格式为：
jQuery.getJSON(url,[data],[callback])或$.getJSON(url,[data],[callback])
其中，url参数为请求加载json格式文件的服务器地址，可选项data参数为请求时发送的数据，callback参数为数据请求成功后，执行的回调函数。
三，使用getScript()方法异步加载并执行js文件 使用getScript()方法异步请求并执行服务器中的JavaScript格式的文件，它的调用格式如下所示：
jQuery.getScript(url,[callback])或$.getScript(url,[callback])
参数url为服务器请求地址，可选项callback参数为请求成功后执行的回调函数。
四，使用get()方法以GET方式从服务器获取数据
使用get()方法时，采用GET方式向服务器请求数据，并通过方法中回调函数的参数返回请求的数据，它的调用格式如下：
$.get(url,[callback])
参数url为服务器请求地址，可选项callback参数为请求成功后执行的回调函数。
五，使用post()方法以POST方式从服务器发送数据
与get()方法相比，post()方法多用于以POST方式向服务器发送数据，服务器接收到数据之后，进行处理，并将处理结果返回页面，调用格式如下：
$.post(url,[data],[callback])
参数url为服务器请求地址，可选项data为向服务器请求时发送的数据，可选项callback参数为请求成功后执行的回调函数。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44f50afab1fa66a8d852aca7ea9eee7f/" rel="bookmark">
			C/C&#43;&#43;中字符串分多行书写的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 当字符串太长时，可能需要分多行书写。
方法1：使用反斜杠\
CString str; str.Format("第一行\ 第二行\r\n"); char ch[10]; strcpy(ch, "123\ 456"); 反斜杠\写在需要换行的地方，后面不能有空格。
方法2：使用双引号"" CString str; str.Format("第一行" "第二行\r\n"); char ch[10]; strcpy(ch, "123" "456");由于方法1需要注意空格的问题，所以我更喜欢方法2. 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60ca5844bca7e51c8fa958d3510ed87f/" rel="bookmark">
			device_create详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开始写Linux设备驱动程序的时候，很多时候都是利用mknod命令手动创建设备节点，实际上现在Linux内核为我们提供了一组函数，可以用来在模块加载的时候自动在/dev目录下创建相应设备节点，并在卸载模块时删除该节点。 内核中定义了struct class结构体，顾名思义，一个struct class结构体类型变量对应一个类，内核同时提供了class_create(…)函数，可以用它来创建一个类，这个类存放于sysfs下面，一旦创建好了这个类，再调用device_create(…)函数来在/dev目录下创建相应的设备节点。这样，加载模块的时候，用户空间中的udev会自动响应device_create(…)函数，去/sysfs下寻找对应的类从而创建设备节点。 此外，利用device_create_file函数可以在/sys/class/下创建对应的属性文件，从而通过对该文件的读写实现特定的数据操作。 一、 class_create 二、 device_create 三、 device_create_file 3.1 a.在驱动程序中使用 device_create_file创建属性文件 3.2 b.在用户空间读取属性 四、使用示例 一、class_create 官方说明： /* This is a #define to keep the compiler from merging different * instances of the __key variable */ #define class_create(owner, name) \ ({ \ static struct lock_class_key __key; \ __class_create(owner, name, &amp;__key); \ }) /** * class_create - create a struct class structure * @owner: pointer to the module that is to "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/60ca5844bca7e51c8fa958d3510ed87f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5753bdb4076f8d5a449aeffa19c82090/" rel="bookmark">
			hp-unix操作系统 日志
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		常用日志文件 文件名 文件内容 监测方法 /etc/rc.log 运行记录 用读取文本文件的方法， /var/adm/syslog/syslog.log 一般系统日志 注意提示信息及对应的 /var/adm/sw/*.log 软件安装日志 分析发生的相关问题。 /var/adm/wtmp 用户登录信息 用last 命令查看 /var/adm/btmp 用户登录失败信息 用lastb 命令查看 /var/sam/log/samlog SAM 日志 /var/spool/mqueue/syslog sendmail 日志 /etc/shutdownlog 关机(shutdown)信息 /usr/adm/diag/LOGxxx 用工具查看的日志 /var/adm/nettl.LOG* 网络日志 由HP 工程师负责 /var/adm/crash core dump 文件 由HP 工程师负责 来自 “ ITPUB博客 ” ，链接：http://blog.itpub.net/28869493/viewspace-1391715/，如需转载，请注明出处，否则将追究法律责任。 转载于:http://blog.itpub.net/28869493/viewspace-1391715/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5eda022241d15ef020d0419f4ff50cb6/" rel="bookmark">
			spring beans源码解读之--Bean的注解(annotation)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着spring注解的引入，越来越多的开发者开始使用注解，这篇文章将对注解的机制进行串联式的讲解，不求深入透彻，但求串起spring beans注解的珍珠，展示给大家。
1. spring beans常用的注解：
public @interface Autowired：可以对成员变量、方法和构造函数进行标注，来完成自动装配的工作。
Marks a constructor, field, setter method or config method as to be autowired by Spring's dependency injection facilities. Only one constructor (at max) of any given bean class may carry this annotation, indicating the constructor to autowire when used as a Spring bean. Such a constructor does not have to be public. Fields are injected right after construction of a bean, before any config methods are invoked.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5eda022241d15ef020d0419f4ff50cb6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/559f66dd7a0864fb56c6369c080332da/" rel="bookmark">
			vsftpd：500 OOPS: vsftpd: refusing to run with writable root inside chroot ()错误的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 博主历时三年倾注大量心血创作的《大数据平台架构与原型实现：数据中台建设实战》一书已由知名IT图书品牌电子工业出版社博文视点出版发行，真诚推荐给每一位读者！点击《重磅推荐：建大数据平台太难了！给我发个工程原型吧！》了解图书详情，扫码进入京东购书页面！ 当我们限定了用户不能跳出其主目录之后，使用该用户登录FTP时往往会遇到这个错误：
500 OOPS: vsftpd: refusing to run with writable root inside chroot () 这个问题发生在最新的这是由于下面的更新造成的：
- Add stronger checks for the configuration error of running with a writeable root directory inside a chroot(). This may bite people who carelessly turned on chroot_local_user but such is life. 从2.3.5之后，vsftpd增强了安全检查，如果用户被限定在了其主目录下，则该用户的主目录不能再具有写权限了！如果检查发现还有写权限，就会报该错误。
要修复这个错误，可以用命令chmod a-w /home/user去除用户主目录的写权限，注意把目录替换成你自己的。或者你可以在vsftpd的配置文件中增加下列两项中的一项：
allow_writeable_chroot=YES 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc75ade0bc6a0d4d4e5a77f13551c072/" rel="bookmark">
			Oracle分析函数之ratio_to_report()详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		create table test
(
name varchar(20),
kemu varchar(20),
score number );
insert into test values('testa','yuwen',10);
insert into test values('testa','英语',100);
insert into test values('testb','yuwen',60);
insert into test values('testb','yuwen',120);
insert into test values('testc','yuwen',40);
select name,
score,
ROUND(100*ratio_to_report(score) over(),1) as "占所有科目的百分比",
ROUND(100*ratio_to_report(score) over(partition by kemu),1) as "占各科目的百分比"
from test ;
drop table test;
试想下假设我们没有这个分析函数，实现就有可能如下：
select name,score,
(score/sum(score) over()) as "占所有科目的百分比",
(score/sum(score) over(partition by kemu)) as "占所有科目的百分比"
from test
group by name,score,kemu
order by 2；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fc75ade0bc6a0d4d4e5a77f13551c072/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb08cf8aae5414b5d784db4c2462fa64/" rel="bookmark">
			Oracle分析函数之ROW_NUMBER()详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		语法：ROW_NUMBER() OVER(PARTITION BY COLUMN ORDER BY COLUMN)
简单的说row_number()从1开始，为每一条分组记录返回一个数字，这里的ROW_NUMBER() OVER (ORDER BY xlh DESC) 是先把xlh列降序，再为降序以后的没条xlh记录返回一个序号。 示例： xlh row_num 1700 1 1500 2 1085 3 710 4
row_number() OVER (PARTITION BY COL1 ORDER BY COL2) 表示根据COL1分组，在分组内部根据 COL2排序，而此函数计算的值就表示每组内部排序后的顺序编号（组内连续的唯一的)
实例：
初始化数据
create table employee (empid int ,deptid int ,salary decimal(10,2))
insert into employee values(1,10,5500.00)
insert into employee values(2,10,4500.00)
insert into employee values(3,20,1900.00)
insert into employee values(4,20,4800.00)
insert into employee values(5,40,6500.00)
insert into employee values(6,40,14500.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bb08cf8aae5414b5d784db4c2462fa64/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/136654cd97e714321577d0e9baa18ee6/" rel="bookmark">
			Oracle分析函数之first_value和last_value 分析函数详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		FIRST_VALUE 返回组中数据窗口的第一个值 FIRST_VALUE ( [scalar_expression )OVER ( [ partition_by_clause ] order_by_clause ) LAST_VALUE 返回组中数据窗口的最后一个值 LAST_VALUE ( [scalar_expression )OVER ( [ partition_by_clause order_by_clause ) ORACLE函数：LAST_VALUE,FIRST_VALUE的用法：
1、初始化原始数据： create table test (id number(2), name varchar2(10), salary number(6,2)); insert into test values (1,'Tom',120); insert into test values (2,'Ellen',240); insert into test values (2,'Joe',80); insert into test values (3,'Andy',300); insert into test values (3,'Kary',500); insert into test values (3,'Erick',1300); insert into test values (3,'Hou',40); insert into test values (3,'Mary',200); insert into test values (3,'Secooler',800); commit; select * from test order by ID,name;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/136654cd97e714321577d0e9baa18ee6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43f96337b795b8b2da6d6eb181185a6c/" rel="bookmark">
			济南移动互联网沙龙2015年开年专场
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		时间：2015-01-11 14:00
地点： 济南 山东大学中心校区某报告厅（具体地址待定） 费用：免费 类型： 技术交流
2015年开年专场暨【J+】济南移动互联网沙龙第三期活动崭新呈现，本期活动邀请了华为公司高级软件架构师以及csdn的移动开发专家，从基础的算法巩固到面试技巧再到移动开发相关知识来共同锻造程序人生。 活动的主题可能与你工作无关，但至少可以开拓视野认识更多的同道友人，同时这里还汇聚了优秀的开发者、产品经理和创业公司founder。
活动日程
13:00-14:10 签到
本期主题 1.程序员的自我修养——算法与面试 主讲嘉宾： 付聪，（北京大学软件硕士）华为公司高级软件架构师，曾就职于意法半导体，诺基亚，中国移动等知名企业。经历过芯片业，通信业和互联网行业。 分享内容： 1、 Google，BAT是怎么面试程序员的—关于算法在互联网公司面试中的地位 2、算法为什么这么难—关于算法学习的方法论
3、 教你快速搞定面试中遇到的90%的问题—一些简单实用的规律和技巧
4、成为一名真正的高手—面试之外的算法和程序员的个人修养
15:30-15:50 茶歇交流时间
2.Material Design 主讲嘉宾： 张兴业，移动开发者，山东梧桐树软件有限公司产品总监， csdn认证专家 ，在移动开发方面有多年经验和个人心得，其移动开发博客深受读者好评。 分享内容： 1、 android界面设计历史 无序时代 Holo Theme时代Material Design 2、 Material Design设计原则
什么是 Materail DesignMaterail Design的设计原则 17:00-17:30 抽奖环节，惊喜奖品等你拿！
更多详情请转移
当天讲解内容 ：
《Material Design设计规范》
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b7cd7ba99bb9647a67fac1ffe8bcfa2/" rel="bookmark">
			cms.pod around line 457: Expected text after =item, not a number 的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果在linux下安装openssl，执行config和make之后，在执行make install时如果出现下面的错误
cms.pod around line 457: Expected text after =item, not a number cms.pod around line 461: Expected text after =item, not a number cms.pod around line 465: Expected text after =item, not a number cms.pod around line 470: Expected text after =item, not a number cms.pod around line 474: Expected text after =item, not a number POD document had syntax errors at /usr/bin/pod2man line 69. 则在root权限下，执行rm -f /usr/bin/pod2man 然后重新make install
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4028047ec91df2db25be06bcec7b918b/" rel="bookmark">
			.NET 4.0中的泛型协变和逆变
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随Visual Studio 2010 CTP亮相的C#4和VB10，虽然在支持语言新特性方面走了相当不一样的两条路：C#着重增加后期绑定和与动态语言相容的若干特性，VB10着重简化语言和提高抽象能力；但是两者都增加了一项功能：泛型类型的协变（covariant）和反变（contravariant）。许多人对其了解可能仅限于增加的in/out关键字，而对其诸多特性有所不知。下面我们就对此进行一些详细的解释，帮助大家正确使用该特性。
背景知识：协变和反变 很多人可能不不能很好地理解这些来自于物理和数学的名词。我们无需去了解他们的数学定义，但是至少应该能分清协变和反变。实际上这个词来源于类型和类型之间的绑定。我们从数组开始理解。数组其实就是一种和具体类型之间发生绑定的类型。数组类型Int32[]就对应于Int32这个原本的类型。任何类型T都有其对应的数组类型T[]。那么我们的问题就来了，如果两个类型T和U之间存在一种安全的隐式转换，那么对应的数组类型T[]和U[]之间是否也存在这种转换呢？这就牵扯到了将原本类型上存在的类型转换映射到他们的数组类型上的能力，这种能力就称为“可变性（Variance）”。在.NET世界中，唯一允许可变性的类型转换就是由继承关系带来的“子类引用-&gt;父类引用”转换。举个例子，就是String类型继承自Object类型，所以任何String的引用都可以安全地转换为Object引用。我们发现String[]数组类型的引用也继承了这种转换能力，它可以转换成Object[]数组类型的引用，数组这种与原始类型转换方向相同的可变性就称作协变（covariant）。
由于数组不支持反变性，我们无法用数组的例子来解释反变性，所以我们现在就来看看泛型接口和泛型委托的可变性。假设有这样两个类型：TSub是TParent的子类，显然TSub型引用是可以安全转换为TParent型引用的。如果一个泛型接口IFoo&lt;T&gt;，IFoo&lt;TSub&gt;可以转换为IFoo&lt;TParent&gt;的话，我们称这个过程为协变，而且说这个泛型接口支持对T的协变。而如果一个泛型接口IBar&lt;T&gt;，IBar&lt;TParent&gt;可以转换为T&lt;TSub&gt;的话，我们称这个过程为反变（contravariant），而且说这个接口支持对T的反变。因此很好理解，如果一个可变性和子类到父类转换的方向一样，就称作协变；而如果和子类到父类的转换方向相反，就叫反变性。你记住了吗？
.NET 4.0引入的泛型协变、反变性 刚才我们讲解概念的时候已经用了泛型接口的协变和反变，但在.NET 4.0之前，无论C#还是VB里都不支持泛型的这种可变性。不过它们都支持委托参数类型的协变和反变。由于委托参数类型的可变性理解起来抽象度较高，所以我们这里不准备讨论。已经完全能够理解这些概念的读者自己想必能够自己去理解委托参数类型的可变性。在.NET 4.0之前为什么不允许IFoo&lt;T&gt;进行协变或反变呢？因为对接口来讲，T这个类型参数既可以用于方法参数，也可以用于方法返回值。设想这样的接口
Interface IFoo(Of T)
Sub Method1(ByVal param As T)
Function Method2() As T
End Interface
interface IFoo&lt;T&gt;
{
void Method1(T param);
T Method2();
}
如果我们允许协变，从IFoo&lt;TSub&gt;到IFoo&lt;TParent&gt;转换，那么IFoo.Method1(TSub)就会变成IFoo.Method1(TParent)。我们都知道TParent是不能安全转换成TSub的，所以Method1这个方法就会变得不安全。同样，如果我们允许反变IFoo&lt;TParent&gt;到IFoo&lt;TSub&gt;，则TParent IFoo.Method2()方法就会变成TSub IFoo.Method2()，原本返回的TParent引用未必能够转换成TSub的引用，Method2的调用将是不安全的。有此可见，在没有额外机制的限制下，接口进行协变或反变都是类型不安全的。.NET 4.0改进了什么呢？它允许在类型参数的声明时增加一个额外的描述，以确定这个类型参数的使用范围。我们看到，如果一个类型参数仅仅能用于函数的返回值，那么这个类型参数就对协变相容。而相反，一个类型参数如果仅能用于方法参数，那么这个类型参数就对反变相容。如下所示：
Interface ICo(Of Out T)
Function Method() As T
End Interface
Interface IContra(Of In T)
Sub Method(ByVal param As T)
End Interface
interface ICo&lt;out T&gt;
{
T Method();
}
interface IContra&lt;in T&gt;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4028047ec91df2db25be06bcec7b918b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78df5d07d69fca919e8aa4b457b299c6/" rel="bookmark">
			CSS中的zoom:1的作用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网站建站：莜霓网络
兼容IE6、IE7、IE8浏览器，经常会遇到一些问题，可以使用zoom:1来解决，有如下作用：
触发IE浏览器的haslayout。解决ie下的浮动，margin重叠等一些问题。
比如，本站使用DIV做一行两列显示，HTML代码：
[html] view plain copy &lt;div class="h_mainbox"&gt; &lt;h2&gt;推荐文章&lt;/h2&gt; &lt;ul class="mainlist"&gt; &lt;li&gt;&lt;a href="/html/2009-12-18/21-1907360304171.html" style="color:#0000FF" target="_blank"&gt;每天产生一个日志及日志按大小切割&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="/html/2009-11-12/21-932220455859.html" style="color:#0000FF" target="_blank"&gt;Memcached缓存读取添加与清空&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; CSS代码：
[css] view plain copy .h_mainbox { border:1px solid #dadada; padding:4px 15px; background:url(../mainbox_bg.gif) 0 1px repeat-x; margin-bottom:6px; overflow:hidden } .h_mainbox h2 { font-size:12px; height:30px; line-height:30px; border-bottom:1px solid #ccc; color:#555;} .h_mainbox h2 span { float:right; font-weight:normal;} .h_mainbox ul { padding:6px 0px; background:#fff;} .mainlist {overflow:auto; zoom:1;} .h_mainbox li { width:268px; float:left; height:24px; overflow:hidden; background:url(.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/78df5d07d69fca919e8aa4b457b299c6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa8b2dd07326dc14bd076d65bba3945e/" rel="bookmark">
			C# 学习笔记 combobox 的keypass事件中防止下拉框回弹
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		private void comboBox1_KeyPress(object sender, KeyPressEventArgs e)
{
if(e.KeyChar==13) //按下的enter键
{
if(comboBox1.DroppedDown==fales)
{
comboBox1.DroppedDown=true;
e.handle=ture; /不写这句话下拉菜单会回弹回去，这句话意思是comboBox1的KeyPress事件已经处理结束了，以后所有的键盘按键都不起作用
}
}
}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3941dbfa20a607c32723a6f8c7800a52/" rel="bookmark">
			小米停售、富-士-康关厂：中国派的印度危机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		小米停售、富-士-康关厂：中国派的印度危机
近日，出征海外的中国企业坏消息不断。尤其是在印度市场，小米停售、富-士-康关厂，遭遇专利围剿、代工夹击。被誉为“最能走出去”的中国手机、代工厂商，新一轮海外出征不到一年时间，纷纷受到重大挫折。
这不仅让人想到十多年前，联想、海尔、华为、中兴等中国海外征途的科技企业当初同样备受创伤的时刻。如今，这些接过前辈接力棒的中国企业，为何再度受挫？技术、技术、技术，又一次成为了拦在出征途中的最大绊脚石。
技术核心为最大砝码，中企手中筹码不多
作为小米进军海外市场和实行全球化战略的重要跳板，印度市场的重要性不言而喻。小米自7月份开始在印度市场销售旗下智能手机，虽然没有像国内那样一路狂飙，但起码也算稳扎稳打。孰料爱立信横插一杠，提起专利诉讼，法庭裁定小米侵权并下发禁令，要求小米停止在印度销售和进口手机。
别以为小米服下软，不采用这些专利，或者给爱立信缴纳巨资，就可以被网开一面。要知道，爱立信认为小米侵犯的是标准核心专利组合，智能手机很难完全绕过去。若是想着和爱立信进行专利交叉授权和解，也几乎没有可能——二者并没有业务重合，爱立信并不需要小米的专利。更何况小米成立时间较短，根本没有像样的专利被爱立信看上眼。
富-士-康更郁闷，其早在2006年就来到印度设厂，当时的主要大客户是诺基亚。但随着诺基亚销量的全面下滑及被微软收购，富-士-康印度工厂订单急剧减少，终于到现在坚持不住。代工是富-士-康的支柱，看似不用下大力气进行产品研发，也可以规避市场竞争风险，但代工也让富-士-康抵御“人祸”的能力相对较差。一旦客户减少订单，富-士-康就有可能关门大吉。
从全球范围来看，包含专利等在内的技术核心早已成为推动企业发展最有力的助推剂，也是在残酷竞争中得以存活并胜出的最大砝码。美国的uber之所以能在全球打车市场呼风唤雨，凭借的正是无法被仿制的技术核心。小米和富-士-康在海外市场的实力，归根结底在于小米和富-士-康手中没有相应的技术核心。习惯了国内相对宽松的环境，一旦走向全球市场，弱点立刻被无限放大，失败也就在情理之中。
单纯模式移植受挫，中企仍需深入学习
以小米和富-士-康为代表的中国企业，都有着一个“走出国门，称霸全球”的终极梦想。当然，如果成功，也是我们的民族骄傲。但现实是，小米和富-士-康们一边觊觎全球市场这个金矿，一边却几乎没有丝毫考虑地就将国内模式单纯地移植出去。
正所谓一方水土养一方人，全球市场本来就有太多的变数，不可能靠一个模式就吃遍天下。就连苹果也针对不同的市场，实行有不同的对策。中国大陆市场是一个非常特殊的市场，企业很多习以为常的事情，可能在全球市场就并不通行，甚至会触犯很多未知的警戒线，小米和富-士-康就是最好的例子。
单纯移植国内模式，是出征海外市场的中企新手常犯的毛病。如果不能及时调整，损失也将会越来越大。最终引起连锁反应，引发业界和用户对品牌/模式的怀疑和顾虑，危及国内大本营。在海外市场打拼的时候，中国企业仍然需要深入学习，绝不能因为国内取得的成就就认为自家模式是“万能药”。
海外市场乱撒钱，何时学会吸引投资
此外不得不提的一点是，小米和富-士-康们进军海外市场都是在花自家的钱。甚至小米还向多家银行贷款10亿美元用于海外市场扩张。如果能在海外市场获得成功还好，一旦进展不顺，无疑会给企业本身增加太大负担，甚至有可能成为压垮骆驼最后的那根“稻草”。在海外市场乱撒钱，以“土豪”身份“嫁”出去，还得受海外“婆婆”的气，这又是何苦？
与中国企业开拓海外市场投资不同，国外企业尤其是互联网企业来到中国几乎投入很少。因为他们能够吸引投资，吸引中国投资者手中的巨资，花别人的钱来赚钱。因为这些国外企业都有着先进的管理经验和技术核心，是中国投资者和企业垂涎的。但很显然，外国企业只会将淘汰的技术核心售卖给中国投资者和企业。若是中国投资者和企业将重心放在这方面，弄不好就是赔了夫人又折兵，只是花自家的钱为外国企业做嫁衣。
小米和富-士-康们何时才能凭借自身实力、技术核心等，在海外市场吸引投资？要想做到这一点，目光就一定不能短视。不能只为了赚快钱，而牺牲企业的长远发展。只有真正地打好基础，建立自己的技术核心体系，才能真正在海外市场游刃有余。
当初联想、华为、中兴、海尔等中国企业刚刚走向海外市场的时候，也遇到诸多挫折。但在熟悉规则和玩法之后，进行针对处理，最终混的风生水起。如今小米、富-士-康也遇到同样问题，或许应该停下脚步，先审视自身，革新模式，再考虑下一步拓展的海外区域和范围。
【康斯坦丁/文，作者官方微信公众号：科技新发现（kejxfx）】
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87537faf42d82eb46a8795ff023f1c48/" rel="bookmark">
			iOS不显示状态栏（电池和信号栏）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		//隐藏状态栏 - (BOOL)prefersStatusBarHidden { return YES; } 在viewcontroller里面加入
我的群：
1、
Cocos2D&amp;Unity&amp;Java程序招聘
31068495
2、
PHPer&amp;页游&amp;Mobile&amp;U3D 2D
95303036
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24efb1c4170e5f670cf6b5663f1f2389/" rel="bookmark">
			【c语言】利用指针求三个数的最大数和最小数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		比较费空间的笨方法：
#include&lt;stdio.h&gt;
void main(){
int i,j,k,*m,*n,*q,temp;
printf("请输入三个数:");
scanf("%d,%d,%d",&amp;i,&amp;j,&amp;k);
printf("三个数是:%d,%d,%d\n",i,j,k);
m=&amp;i,n=&amp;j,q=&amp;k;
if(*n&lt;*m){
temp=*n;
*n=*m;
*m=temp;
}
if(*q&lt;*n){
temp=*q;
*q=*n;
*n=temp;
}
if(*q&lt;*m){
temp=*q;
*q=*m;
*m=temp;
}
printf("三个数大小最大数是:%d\n",*q);
}
备注：就是在if表达式里，*q&lt;*n是不需要加括号的。。。。
不用开辟空间的好方法：
#include&lt;stdio.h&gt;
void main(){
int a,b,c,*pmax,*pmin;
printf("input three number:\n");
scanf("%d,%d,%d",&amp;a,&amp;b,&amp;c);
if(a&gt;b){
pmax=&amp;a;
pmin=&amp;b;
}else{
pmax=&amp;b;
pmin=&amp;a;
}
if(c&gt;*pmax)
pmax=&amp;c;
if(c&lt;*pmin)
pmin=&amp;c;
printf("max=%d\nmin=%d\n",*pmax,*pmin);
}
转载于:https://www.cnblogs.com/zhizhuniuniu/p/4175903.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29d00e9727de485787ed2bac7998e409/" rel="bookmark">
			Shell的文件描述符操作，包括标准输入，标准输出，自定义文件描述符
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Abstract: 1) Linux Shell 命令的标准输入、标准输出、标准错误，及其重定位； 2）Linux Shell 操作自定义文件描述符； 文件描述符是与文件相关联的一些整数，他们保持与已打开文件的关联。众所周知的文件描述符是标准输入stdin、标准输出stdout、标准错误stderr，我们可以重定位这些文件描述符关联文件的内容到另外一个文件文件描述符。 1. Linux Shell 命令的标准输入、标准输出、标准错误 当我们在编写 shell 脚本时，我们会非常频繁地操作执行命令的标准输入stdin、标准输出stdout、标准错误stderr。过滤 shell 脚本或者执行命令的输出信息并且把它们重定位到特定的地方，成了我们分析脚本执行情况的必要工作。当我们执行脚本文件或者执行一个 shell 命令的时候，单从终端输出我们很难区分哪些是标准输出，哪些是标准错误。然而，我们把这些信息重定向特定的地方，以便于我们分析脚本文件及 shell 命令的执行情况。 文件描述符是与打开文件或者数据流 相关联的整数， 0、1、2 是系统保留的三个文件描述符，分别对应标准输入、标准输出、标准错误 。 Linux Shell 使用 " &gt; " "&gt;&gt;" 进行对文件描述符进行重定位。 "&gt;" 与 "&gt;&gt;" 的作用是不一样的，前者使用本次输出内容替换原有文件的内容，后者则是把本次输出追加到原文件的后面。 在对文件描述符进行详细分析之前，先执行以下命令，为后面的实验操作准备一些必要的文件： echo -e "\e[42;31m --- Prepare resource file ---\e[0m"; echo "This is example text 1." &gt; temp.txt; echo "This is example text 2." &gt;&gt; temp.txt; cat temp.txt; echo "a1" &gt; a1; echo "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/29d00e9727de485787ed2bac7998e409/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ddbd5e5253c7a27fa86ef7ac276b6a9/" rel="bookmark">
			设置UIView的简单阴影效果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1 UIView *containerView = [[[UIView alloc] initWithFrame:CGRectMake(20, 20, 280, 300)] autorelease]; 2 containerView.backgroundColor = [UIColor clearColor]; 3 containerView.layer.shadowOffset = CGSizeMake(0, 2); 4 containerView.layer.shadowOpacity = 0.80; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7f0b01a9ad0655d87492222c1307336/" rel="bookmark">
			JDBC  参数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 JDBC连接池参数：
jdbc.initialSize=0 //初始化连接
jdbc.maxActive=30 //连接池的最大数据库连接数，设为0表示无限制
jdbc.maxIdle=20 //没有人用连接的时候，最大闲置的连接个数，设置为0时，表示没有限制。
jdbc.maxWait=1000 //超时等待时间以毫秒为单位
jdbc.removeAbandoned=true //是否自动回收超时连接
jdbc.removeAbandonedTimeout=60 //设置被遗弃的连接的超时的时间（以秒数为单位），即当一个连接被遗弃的时间超过设置的时间，则它会自动转换成可利用的连接。默认的超时时间是300秒。
jdbc.logAbandoned = true //是否在自动回收超时连接的时候打印连接的超时错误
jdbc.validationQuery=select 1 from dual //给出一条简单的sql语句进行验证
jdbc.testOnBorrow=true //在取出连接时进行有效验证 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/490a06bcc1df939e3e1824a26e744029/" rel="bookmark">
			Android点击改变按钮颜色的3种效果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		效果：
核心代码：
package com.zhh.android;
import android.app.Activity;
import android.app.ActionBar;
import android.app.Fragment;
import android.os.Bundle;
import android.view.LayoutInflater;
import android.view.Menu;
import android.view.MenuItem;
import android.view.View;
import android.view.ViewGroup;
import android.widget.Button;
import android.os.Build;
public class MainActivity extends Activity {
/**
* 一个按钮的上下颜色变化
* */
private Button btn;
/**
* 4个按钮的变化
* */
private Button b1,b2,b3,b4;
@Override
protected void onCreate(Bundle savedInstanceState) {
super.onCreate(savedInstanceState);
setContentView(R.layout.activity_main);
this.btn = (Button) findViewById(R.id.button1);
b1=(Button) findViewById(R.id.b1);
b2=(Button) findViewById(R.id.b2);
b3=(Button) findViewById(R.id.b3);
b4=(Button) findViewById(R.id.b4);
}
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/490a06bcc1df939e3e1824a26e744029/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/742e93219e837833332363ca0e3f2241/" rel="bookmark">
			SQL编程：判断某个年份是否为闰年
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 declare @year int --set @year =2014 set @year=year(GETDATE());--获取系统当前日期再取出其中的年份 if @year%4=0 and @year%100&lt;&gt;0 or @year%400=0 print cast (@year as char(4))+'是闰年' --输出时必须把int型的year变为字符类型才能和后面的字符相连接，用cast函数 else print cast(@year as char(4))+'不是闰年' 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84fe2f448a80e8337e8e14f464142e89/" rel="bookmark">
			Invalid location of tag 解决办法分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在jsp页面使用标签过程中有时候不注意规则的话，eclipse会提示一些错误，下面针对这些错误提出相应的解决办法：
&lt;form&gt;&lt;/form&gt;标签
1. Invalid location of tag (form)
form 应该写到table外面去，并且form标签里面也不能套form标签。 &lt;style&gt;&lt;/style&gt; 2. Invalid location of tag (style) style应该写在head里面。 &lt;script&gt;&lt;/script&gt; 3. Invalid location of tag (script) script应该写到body，head里面。 4.Attribute name(Name) uses wrong case character 虽说HTML不区分大小写，但是在eclipse里面，大写的话就报错，所以要改成小写吧。
5.JSP文件中的html标签如下,在eclipse环境下提示：Invalid location of tag (div)。
&lt;a id="test1" class="mitem" href="#"&gt;
&lt;img src="../m1.jpg" width="60"&gt;&lt;/img&gt;
&lt;div id="a-in-1" class="a-in"&gt;&lt;div class="a-in-m"&gt;&lt;/div&gt;&lt;div class="a-in-r"&gt;&lt;/div&gt;&lt;/div&gt;
&lt;/a&gt;
现象： 在 firefox3.6 下进入页面，或者进入页面有时界面显示乱套。但在 ie，firefox3.0下都显示正常。
解决办法： 将&lt;a&gt;&lt;/a&gt;标签下的&lt;div&gt;&lt;/div&gt;标签替换为&lt;span&gt;&lt;/span&gt;，如下：
&lt;a id="test1" class="mitem" href="#"&gt;
&lt;img src="../m1.jpg" width="60"&gt;&lt;/img&gt;
&lt;span id="a-in-1" class="a-in"&gt;&lt;span class="a-in-m"&gt;&lt;/span&gt;&lt;span class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/84fe2f448a80e8337e8e14f464142e89/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d20bc3bbfea8d1020dd00492abe58dd6/" rel="bookmark">
			C语言-判断线段是否与矩形范围有交集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文地址:http://blog.csdn.net/hbuxiaoshe/article/details/5833094
判断线段AB是否与矩形范围有交集
这里的矩形指的是边与坐标轴平行的矩形，可用x和y上最大最小值表示。
判断是否相交，先快速排斥，再做跨立，通过向量的叉积判断矩形的四个顶点是否在线段的两侧，是说明有交集。
（如果判断与矩形的边是否有交集的话，可判断线段是否与矩形的每条边是否有交集，线段与线段的交集判断。）
这里在介绍另外一种方法，降维的方法：
例如，有线段AB和矩形MN，如图所示：
通过M和N点的y坐标计算直线AB上的D和C点，B和C点中取y值小的点B，A和D点中取y值大的点D，
最后确定了线段BD在x轴上的投影GH，矩形在x轴上的投影EF，判断EF和GH是否有交集。
C语言代码如下：
/* * 判断区间[x1, x2]和区间[x3, x4](x4可能小于x3)是否有交集，有返回1，无0 */ int IntervalOverlap(double x1, double x2, double x3, double x4) { double t; if (x3 &gt; x4) { t = x3; x3 = x4; x4 = t; } if (x3 &gt; x2 || x4 &lt; x1) return 0; else return 1; } /* * 判断矩形r和线段AB是否有交集，有返回1，无0 */ int RSIntersection(Rectangle r, Point A, Point B) { if (A.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d20bc3bbfea8d1020dd00492abe58dd6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af04d824154e8b78bf2c3869372a816f/" rel="bookmark">
			IPSEC 中的AH,ESP,SPI用途
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		IPSEC的加密通信中包含了两个协议，分别为AH(Authentication header验证包头)，ESP(Encapsulating security payload,封装安全包头)协议。
AH负责执行封包的完整性验证
ESP则是负责执行封包的加密动作。
不管AH包头或是ESP包头，其内都包含有一个SPI字段，而该SPI值就是告知接收端主机要使用IPSEC数据库中的那一把密钥来加密这个封包。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35f7de2f2f51ff791e33624b0f169b77/" rel="bookmark">
			kettle入门(三) 之kettle连接hadoop&amp;hdfs图文详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 引言： 项目最近要引入大数据技术，使用其处理加工日上网话单数据，需要kettle把源系统的文本数据load到hadoop环境中
2 准备工作： 1 首先 要了解支持hadoop的Kettle版本情况，由于kettle资料网上较少，所以最好去官网找,官网的url:
http://wiki.pentaho.com/display/BAD/Configuring+Pentaho+for+your+Hadoop+Distro+and+Version
打开这个url 到页面最下面的底端，如下图：
archive 下面的from PDI 4.3 、 from PDI 4.4 、 from PDI 5.0 即表示支持hadoop的pdi 版本。pdi即pentaho data integration 又称kettle。PDI 4.3 、 PDI 4.4 、 PDI 5.0 即是kettle 4.3 、4.4、 5.0 ,这个版本号 包括比其更高的版本（即kettle 5.0.X ，5.1，5.2也支持hadoop）。
2 其次
不同的kettle版本支持的hadoop版本不一样，以5.1为例子，下面的链接是5.1的支持情况
http://wiki.pentaho.com/display/BAD/Configuring+Pentaho+for+your+Hadoop+Distro+and+Version
下图为链接打开的页面的中间部分：
determine the proper shim for hadoop Distro and version 大概意思是 为hadoop版本选择合适的套件。表格上面的一行：apache、cloudera、hortonworks、intel、mapr指的是发行方。点击他们来选择你 想连接的hadoop的发行方 。上图 以apache hadoop为例：
Version 指版hadoop版本号 ，shim 指kettle提供给该hadoop套件的名称，Download 里面的 included in 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/35f7de2f2f51ff791e33624b0f169b77/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e49801b3a0897fc5ddf0d98ee1454340/" rel="bookmark">
			c&#43;&#43; 实现 http 上传和下载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		代码下载地址: http://download.csdn.net/detail/mtour/8243527
最近写了个程序需要用到http通讯，由于flash空间比较小，没有考虑 libcurl库，用c++封装了一个http类，实现了http 文件上传和下载
#include &lt;stdio.h&gt; #include &lt;unistd.h&gt; #include &lt;string.h&gt; #include &lt;net/if.h&gt; #include &lt;arpa/inet.h&gt; #include &lt;sys/ioctl.h&gt; #include "HttpClient.h" int main() { CHttpClient httpclient; char* pResponse=new char[32*1024]; memset(pResponse,0,32*1024); int nRet=httpclient.ConnectServer("127.0.0.1", 80); if (0!=nRet) { return -1; } nRet=httpclient.HttpGet("/archives/user/10000025/jbox/m6cfaa74922bd00/JssConfig.xml", pResponse); if (0!=nRet) { printf("http get failed\n"); return -1; } printf("------------- split line -------------- \n"); char* pTmp=strstr(pResponse, "\r\n\r\n"); pTmp+=4; printf("%s\n",pTmp); char url[128]="/file/";	httpclient.HttpPostFile(url, "yourfile"); getchar(); //delete [] pResponse; return 0; } 类 接口定义
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e49801b3a0897fc5ddf0d98ee1454340/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89e6e055be99134f4b0e3d5288fb2d76/" rel="bookmark">
			js 正则表达式判断数字和数字范围（总结）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 判断数字的正则表达式：
/^\d+$/　//非负整数（正整数 + 0） /^[0-9]*[1-9][0-9]*$/　//正整数 /^((-\d+)|(0+))$/　//非正整数（负整数 + 0） /^-[0-9]*[1-9][0-9]*$/　//负整数 /^-?\d+$/　//整数 /^\d+(\.\d+)?$/　//非负浮点数（正浮点数 + 0） /^(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*))$/　//正浮点数 /^((-\d+(\.\d+)?)|(0+(\.0+)?))$/　//非正浮点数（负浮点数 + 0） /^(-(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*)))$/　//负浮点数 /^(-?\d+)(\.\d+)?$/　//浮点数 使用例： &lt;html&gt; &lt;head&gt; &lt;title&gt;test&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; var r = /^[0-9]*[1-9][0-9]*$/ ;　//正整数 var t = 3; var s = 3.2; alert("整数:"+r.test(t)); //true alert("小数:"+r.test(s)); //false &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a56fce8c0ae8a0cb79a1741db03650d9/" rel="bookmark">
			Spring学习之SpringMVC框架快速搭建实现用户登录功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于SpringMVC的介绍我就不多说了，网上一搜一大堆，好多大鸟的博客都有详细的描述，之前看的跟开涛学SpringMVC，写的非常好，SpringMVC运行的流程和原理讲的非常的细致在此我引用一下开涛前辈的图片和文字，大家要是想看原文就点击上面的链接。
SpringMVC处理请求的流程图
大家一定要仔细的看，最好是拿张纸，画一画，可比你光看有效果，大家可以与纯MVC模式对比一下，这样理解起来就不是那么的难了。
对上面的图在此细化
在此我们可以看出具体的核心开发步骤：
DispatcherServlet在web.xml中的部署描述，从而拦截请求到Spring Web MVC HandlerMapping的配置，从而将请求映射到处理器 HandlerAdapter的配置，从而支持多种类型的处理器 ViewResolver的配置，从而将逻辑视图名解析为具体视图技术 处理器（页面控制器）的配置，从而进行功能处理 把上面的五个步骤和图一一对应起来，之后的开发就是按照这五个步骤进行的！
后来我想实现一个简单的用户登录验证的例子来验证一下，毕竟实践是验证理论的唯一途径也是学习的最好方式！
没有用到数据库，没有必要，我这里只是学习SpringMVC的运行机制
首先建立一个Web项目取名为SpringLoginDemo
在导入所需要的包，如图：（下面有下载）
接下来做什么呢？看上面的那五个步骤，第一步部署web.xml，从而拦截请求到Spring Web MVC
web.xml
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;web-app version="2.5" xmlns="http://java.sun.com/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"&gt; &lt;display-name&gt;&lt;/display-name&gt;	&lt;welcome-file-list&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;servlet&gt; &lt;servlet-name&gt;Dispatcher&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- Spring配置文件 --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;Dispatcher&lt;/servlet-name&gt; &lt;url-pattern&gt;*.do&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;/web-app&gt; 不要忘记了编写eneity package com.example.entity; public class User { private String username; private String password; public User(String username, String password) { super(); this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a56fce8c0ae8a0cb79a1741db03650d9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ecb4254410402e695541f179749b3f4b/" rel="bookmark">
			PubSubJS的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：zccst 2015-06-10 模块间通信的原理： 发布方，publish("key1"); 订阅方，subscribe("key1", context, fn);多个订阅方形成订阅数组。 当发布方publish时，执行pubsub的方法，把所有订阅key为key1的方法全部执行一遍（数组）。 PubSubJS是用来解决模块间通讯的问题。 比如，在一个列表上部创建了一个新case时，需要在创建成功的时候刷新列表，将新创建的内容显示到列表中。这种情况其实也可以直接调用。 但是再比如，有很多其他模块需要订阅刷新列表，这时优势就显现出来。 github地址： [url]https://github.com/mroderick/PubSubJS[/url] 如果在seajs require('PubSub'); require('topic'); TOPIC是一个对象集合，字符串 订阅： PubSub.subscribe(TOPIC.FEED.FEEDTEMPLATE.CREATE, $.proxy(function(){
this.queryTable();
}, this));
PubSub.subscribe(TOPIC.FEED.FEEDTEMPLATE.MODIFY, $.proxy(function(){
this.queryTable();
}, this));
PubSub.subscribe(TOPIC.FEED.FEEDTEMPLATE.DELETE, $.proxy(function(){
this.queryTable();
}, this));
发布： ajax.post(DELETE_FEED_URL, {
args: {feedId:feedId},
success: jQuery.proxy(function(data, response, xhr){
//重点在这里
PubSub.publish(TOPIC.FEED.FEEDTEMPLATE.DELETE);
}, this),
fail: jQuery.proxy(function(msg, response, xhr){
alert(msg.length !== 0 ? msg.join('\r\n') : "系统繁忙，请稍后重试！");
}, this)
});
取消订阅： destroy: function(){
this.undelegateEvents();
if(this.model){
this.model.unbind();
}
var $el = this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ecb4254410402e695541f179749b3f4b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59ff2bfc7fd92a9a5030202844b2cdec/" rel="bookmark">
			LR接口性能测试：发现奇怪曲线图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、最近在做一个贷后系统的放款接口性能测试，测试完成后，发现在接口在30人的并发下TPS突然下降，当继续加大压力时，TPS反而平缓上升，响应时间一直在变长，曲线图如下：
由上图可知：当并发数在30时，TPS出现像征性的拐点，观察此时的应用服务器资源，和DB服务器的资源 ，内存，CPU使用率非常小，磁盘IO，网络流量基本上很小，当继续加大并发数时，TPS，反而平缓上升，一般情况下：当其它【（硬件，网络），正常情况下，（响应时间变长，吞吐量下降）】时，此时加大压力TPS曲线应是继续下降的，但在这里，反而上升，始终这一现象确定不了原因，在网上搜索此种现象的问题发现很少，问了同行业的其它同事：初步判断为：
1.升的趋势很平缓，响应时间变长了： 某个环节有瓶颈。这么小的TPS很少是因为网络或其它硬件资源引起的。应该把方向放在 资源池上，向线程池的大小，数据库连接池的大小 ，系统内一切涉及到排队的地方，网络，硬件原因可以排除，则剩下的应是资源池上出现问题，线程池，数据库连接池配置上。
2.可能是线程池，数据库连接池配置上的不合理，导致队列等待的时间过长引起的
3.刚开始以为是数据量的变大引起，但经思考，这个可以排除。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3dbe83ff38b17006d31bdd307ee90962/" rel="bookmark">
			svn(一)常用命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 待续... 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e358b19e58446d12b210da6b55f5d3c1/" rel="bookmark">
			APK反破解之四：Android代码动态加载技术
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		标 题: 【原创】APK反破解之四：Android代码动态加载技术 作 者: ZhWeir
时 间: 2011-11-02,19:53:26
链 接: http://bbs.pediy.com/showthread.php?t=142256
转载请注明出处： http://www.blogjava.net/zh-weir/arch...29/362294.html Android类动态加载技术 Android应用开发在一般情况下，常规的开发方式和代码架构就能满足我们的普通需求。但是有些特殊问题，常常引发我们进一步的沉思。我们从沉思中产生顿悟，从而产生新的技术形式。 如何开发一个可以自定义控件的Android应用？就像eclipse一样，可以动态加载插件；如何让Android应用执行服务器上的不可预知的代码？如何对Android应用加密，而只在执行时自解密，从而防止被破解？…… 熟悉Java技术的朋友，可能意识到，我们需要使用类加载器灵活的加载执行的类。这在Java里已经算是一项比较成熟的技术了，但是在Android中，我们大多数人都还非常陌生。 类加载机制 Dalvik虚拟机如同其他Java虚拟机一样，在运行程序时首先需要将对应的类加载到内存中。而在Java标准的虚拟机中，类加载可以从class文件中读取，也可以是其他形式的二进制流。因此，我们常常利用这一点，在程序运行时手动加载Class，从而达到代码动态加载执行的目的。 然而Dalvik虚拟机毕竟不算是标准的Java虚拟机，因此在类加载机制上，它们有相同的地方，也有不同之处。我们必须区别对待。 例如，在使用标准Java虚拟机时，我们经常自定义继承自ClassLoader的类加载器。然后通过defineClass方法来从一个二进制流中加载Class。然而，这在Android里是行不通的，大家就没必要走弯路了。参看源码我们知道，Android中ClassLoader的defineClass方法具体是调用VMClassLoader的defineClass本地静态方法。而这个本地方法除了抛出一个“UnsupportedOperationException”之外，什么都没做，甚至连返回值都为空。 代码: static void Dalvik_java_lang_VMClassLoader_defineClass(const u4* args, JValue* pResult) { Object* loader = (Object*) args[0]; StringObject* nameObj = (StringObject*) args[1]; const u1* data = (const u1*) args[2]; int offset = args[3]; int len = args[4]; Object* pd = (Object*) args[5]; char* name = NULL; name = dvmCreateCstrFromString(nameObj); LOGE("ERROR: defineClass(%p, %s, %p, %d, %d, %p)\n"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e358b19e58446d12b210da6b55f5d3c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce03ed5161d0d9b91ff84e31a08b9bba/" rel="bookmark">
			Android混淆、反编译以及反破解的简单回顾
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		http://vaero.blog.51cto.com/4350852/856014
Android混淆、反编译以及反破解的简单回顾 搜索下，发现文章相关文档好多好多。就简单点，不赘述了== 一、Android混淆 1）概述 新建Android工程，根目录下会有个proguard.cfg。简单的混淆，你只需要在project.properties内加入一行“proguard.config=proguard.cfg”即可。 注意：在签名发布apk时才会混淆，直接Run As在bin目录下的apk是不被混淆的。签名发布：右键工程-&gt;Android Tools-&gt;Export Signed Application Package…
如何生成签名，可以参考《Android 数字签名学习笔记》。
2）外部jar 未混淆过的，只加个类库声明就好。例如，用到“SDK目录\ extras\android\support\v4\ android-support-v4.jar”时，可以在-keep前加如下内容即可： -dontwarn android.support.** -libraryjars lib/android-support-v4.jar 第一行，表示去除警告，第二行是声明jar（jar包拷到工程内了，所以是相对目录==）。 这样混淆后，引用的jar包也会一起被混淆。 如果用的第三方jar包是被混淆过的，或你不想混淆，则用-keep去除即可。例如，之前android-support-v4.jar，如果不需要混淆它的话，可以增加这么一句： -keep class android.support.v4.** { *; } 此时的话，jar包就不会被混淆了^^。 更详细的使用方法，请参看小节3。 3） Proguard 1. 在手册的样例中，有两篇即是讲述Android的，如下： Manual-&gt;Examples-&gt;A simple Android activity&amp;A complete Android application
2. 用法的内容，则在： Manual-&gt; Usage。用于学习或查看各命令都是做什么的用。 中文相关的话，可以参考下述网址，呼呼~ http://www.cnitblog.com/zouzheng/archive/2011/01.html 4）可能问题 4.1）新建工程下没有proguard.cfg 你的环境太老了吧==。 ProGuard是2.2才加的？记得我起初低于2.2的混淆时，要从2.2工程下把proguard.cfg拷过去。当时建2.1的目录下是没proguard.cfg的。 不过现在建立个1.5都是有这个文件的。 二、Android反编译 1）概述 apktool + dex2jar + jd-gui。超链接是主页，不了解的可以看看介绍，再转至Downloads。 具体做什么用的或如何操作，参看小节2。 当然，和之前《 批处理安装&amp;卸载apk》一样，小子懒人一个T^T。又是批处理（没sh的……）： easyTool.bat @echo off title APK反编译[by Join] rem apktool目录 set p_at="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ce03ed5161d0d9b91ff84e31a08b9bba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/510fcc90b8600bf91893afa1d277f6ae/" rel="bookmark">
			火星坐标系，百度坐标系，wgs84坐标系转换算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一 坐标介绍
1 wgs84坐标系：是国际上通用的地理坐标系，也就是我们常说的经度纬度多少多少。比如08年汶川大地震报的经纬度就是基于这个坐标系。而我们常见的一些设备比如gps也是以这个坐标系为参考的。
2 火星坐标系：主要是因为国家安全的原因为了保护一些比较敏感的坐标位置，在大天朝所有获取地图数据的第一个关卡就是国家测绘局，在他们出产的所有地图在wgs84的基础上进行一次加密，也就是所谓的按照一定的坐标偏移算法到另外一个坐标系，这个坐标系是特有的切是变化的，大家习惯性的把他称为火星坐标系。正是因为火星坐标系的存在我们直接拿gps采集的数据在地图上显示始终都有偏差，原因就是因为两个坐标系都不一样造成的。
3 百度坐标系：百度的地图也是买的，他们买来的数据也是火星坐标系的，百度由于其平台非常知名，只要上过网的都知道百度，所以百度有这个能力搞一个自己的坐标系，再加之免费使用，用户多也就自然而然的逐渐让大家习惯了。
二 坐标换算
既然是三种坐标系，而且这些坐标系跟我们程序员息息相关，怎么实现他们的转换，要实现转换就得知道他们的转换算法。这里也是从网上东搜西搜的找到一些转换算法的代码。因为坐标的加密算法是会变化的，这些算法也并不是一定就是准确的，所以使用的时候作为参考吧。
1 WGS84坐标转火星坐标的算法最早成形的版本是https://on4wp7.codeplex.com/SourceControl/changeset/view/21483#353936
using System; namespace Navi { class EvilTransform { const double pi = 3.14159265358979324; // // Krasovsky 1940 // // a = 6378245.0, 1/f = 298.3 // b = a * (1 - f) // ee = (a^2 - b^2) / a^2; const double a = 6378245.0; const double ee = 0.00669342162296594323; // // World Geodetic System ==&gt; Mars Geodetic System public static void transform(double wgLat, double wgLon, out double mgLat, out double mgLon) { if (outOfChina(wgLat, wgLon)) { mgLat = wgLat; mgLon = wgLon; return; } double dLat = transformLat(wgLon - 105.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/510fcc90b8600bf91893afa1d277f6ae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ca40b2afd05615e902b44ee766daf9f/" rel="bookmark">
			两年外包女程序员的真实感受
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天是端午假日的最后一天，明天又要回到工作的岗位上去了，心理有点不想去上班的感觉，由此而发，写了一点自己的心理感受（2012.6.24）。 跻身IT外包行业已有两年半的时间了，从走出大学校门踏入社会门槛的那刻起，便走进了另外一个世界-----IT世界。这个世界说大不大、说小不小。
其实，做IT这个行业并不是我一开始的志愿，因为本身也并非计算机或相关专业，并且对这个行业的知识也不懂，但是那年的经济危机和各种原因吧，导致了我不得不选择了这份工作。现在回想起当初毕业的时候放弃了最后的保送研究生的机会而选择工作。心里也不知是一种什么滋味，可能真的如人所说，打翻了五味瓶的滋味，其中滋味，只有自己才能体会得到吧。但是并没有后悔当初的选择。
起初在工作的时候，什么都不会，那叫一个痛苦啊，工作的环境压力也大。没工作几天就快要熬不下去了。但这毕竟是自己走入社会以来的第一份工作，总要坚持一下吧，至少当时是那么想的。由于自己的技术功底并不好，各种技术也不懂，一切的一切都得重零开始。就这样一步一步的伴着眼泪和汗水坚持到了现在。
在这两年的外包生涯中，感悟到一个道理，自己并不属于自己，有很多的思想也并不能实现。举个例子来说吧，给别人做外包，拿到手的项目是别人分析好的，方案给你选定，尽管你觉得有不合理的地方，你有你的想法，但是也是无济于事，并不能得到别人的采纳。刚开始的时候，也许你还能提出你自己的观点，但结果是并不会被用到。久而久之，即便有了想法，也不想说了。就这样，一天到晚，压抑着自己的情绪。用别人的思路控制着自己的身体去工作。时间长了，疲惫不堪。
对于人事调动这方面就更是让人悲哀了。上几天就有这么个事情，让我感触颇深，内心也深受打击。我们属于A公司。是给B公司做外包。同时给B公司做外包的还有C、D两家公司。我们项目小组中有这四家公司的成员共同组成。一起做项目还是挺开心的。年纪相仿，沟通方便，相处融洽。可是好景不长吧。刚成立的小组不到一年的时间。B公司就开始有了一个新的政策。可能也是新官上任三把火的缘故吧。好嘛，这三把火不打紧，就烧到我们的头上了。B公司说要减少外包人员。裁员比例必须达到一个数字。在这里就不透露了。反正不少吧。各个小组就开始确定淘汰的名单。我们小组比较惨淡啊，被调走的调走，被裁减的裁减，有些人更是受不了这份调动而自动的辞职的。最后就剩下寥寥无几的那么三两个人了。看着很多人的离开。让我内心巨受打击。感觉这里也不是自己的长久之地。枉费我一片工作的热情。这份热情是不是献错地儿了呢。不知道这种无缘由的打击还会有几次。
我不能掌控其他人的思想，但是，我可以掌控我自己的思想和行动。我可以决定我自己的去或者是留。人总要开开心心的生活，无论生活和工作给了你多么大的压力。你只把它们当成动力变好。如果被压得喘不过起来，不开心。那么人生在世也就没有什么值得追寻的了。突然想起了前几天看到的文章，感觉很是激励人。这里分享给大家，希望大家的人生都能够快快乐乐、实现自己的梦想。
再烦，也别忘微笑；再急，也要注意语气； 再苦，也别忘坚持；再累，也要爱自己。 低调做人，你会一次比一次 稳健；高调做事，你会一次比一次优秀。 成功的时候不要忘记过去；失败的时候不要忘记还有未来。 有望得到的要努力，无望得到的不介意，则无论输赢姿态都会好看。
生活不是单行线，一条路走不通，你可以转弯。 泪水和汗水的化学成分相似，但前者只能为你换来同情，后者却可以为你赢的成功。 变老是人生的必修课，变成熟是选修课。 以锻炼为本，学会健康；以修进为本，学会求知； 以进德为本，学会做人；以适应为本，学会生存。 人生四项基本原则：懂得选择，学会放弃，耐得住寂寞，经得起诱惑。 当所有人都低调的时候，你可以高调，但不能跑调。 学会忘记是生活的技术，学会微笑是生活的艺术。 什么是好工作：一不影响生活作息，二不影响家庭团聚，三能养家糊口。 懒惰像生锈一样，比操劳更消耗身体。 让梦想成真的最好办法就是醒来。
哲人无忧，智者常乐。并不是因为所爱的一切他都拥有了，而是所拥有的一切他都爱。 曾几何时，我们都会随着时光的消逝而渐渐老去。但无论何时都应该保持一颗健康快乐的心。为了你自己和身边爱护疼惜你的人们。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24d011e8416143580e6110c45b982d82/" rel="bookmark">
			六款值得推荐的android（安卓）开源框架简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、volley 项目地址 https://github.com/smanikandan14/Volley-demo
(1) JSON，图像等的异步下载；
(2) 网络请求的排序（scheduling）
(3) 网络请求的优先级处理
(4) 缓存
(5) 多级别取消请求
(6) 和Activity和生命周期的联动（Activity结束时同时取消所有网络请求）
2、android-async-http 项目地址：https://github.com/loopj/android-async-http
文档介绍：http://loopj.com/android-async-http/ (1) 在匿名回调中处理请求结果
(2) 在UI线程外进行http请求
(3) 文件断点上传
(4) 智能重试
(5) 默认gzip压缩
(6) 支持解析成Json格式
(7) 可将Cookies持久化到SharedPreferences
3、Afinal框架
项目地址：https://github.com/yangfuhai/afinal
主要有四大模块：
(1) 数据库模块：android中的orm框架，使用了线程池对sqlite进行操作。
(2) 注解模块：android中的ioc框架，完全注解方式就可以进行UI绑定和事件绑定。无需findViewById和setClickListener等。
(3) 网络模块：通过httpclient进行封装http数据请求，支持ajax方式加载，支持下载、上传文件功能。
(4) 图片缓存模块：通过FinalBitmap，imageview加载bitmap的时候无需考虑bitmap加载过程中出现的oom和android容器快速滑动时候出现的图片错位等现象。
FinalBitmap可以配置线程加载线程数量，缓存大小，缓存路径，加载显示动画等。FinalBitmap的内存管理使用lru算法，
没有使用弱引用（android2.3以后google已经不建议使用弱引用，android2.3后强行回收软引用和弱引用，详情查看android官方文档），
更好的管理bitmap内存。FinalBitmap可以自定义下载器，用来扩展其他协议显示网络图片，比如ftp等。同时可以自定义bitmap显示器，
在imageview显示图片的时候播放动画等（默认是渐变动画显示）。
4、xUtils框架
项目地址：https://github.com/wyouflf/xUtils
主要有四大模块：
(1) 数据库模块：android中的orm框架，一行代码就可以进行增删改查；
支持事务，默认关闭；
可通过注解自定义表名，列名，外键，唯一性约束，NOT NULL约束，CHECK约束等（需要混淆的时候请注解表名和列名）；
支持绑定外键，保存实体时外键关联实体自动保存或更新；
自动加载外键关联实体，支持延时加载；
支持链式表达查询，更直观的查询语义，参考下面的介绍或sample中的例子。 (2) 注解模块：android中的ioc框架，完全注解方式就可以进行UI，资源和事件绑定；
新的事件绑定方式，使用混淆工具混淆后仍可正常工作；
目前支持常用的20种事件绑定，参见ViewCommonEventListener类和包com.lidroid.xutils.view.annotation.event。
(3) 网络模块：支持同步，异步方式的请求；
支持大文件上传，上传大文件不会oom；
支持GET，POST，PUT，MOVE，COPY，DELETE，HEAD，OPTIONS，TRACE，CONNECT请求；
下载支持301/302重定向，支持设置是否根据Content-Disposition重命名下载的文件；
返回文本内容的请求(默认只启用了GET请求)支持缓存，可设置默认过期时间和针对当前请求的过期时间。 (4) 图片缓存模块：加载bitmap的时候无需考虑bitmap加载过程中出现的oom和android容器快速滑动时候出现的图片错位等现象；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/24d011e8416143580e6110c45b982d82/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27a8e6c4ed42b6a55c4baab6700900e6/" rel="bookmark">
			C# Control.Invalidate()的理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MSDN： 调用 Invalidate 方法并不强制同步绘制；若要强制同步绘制，请在调用 Invalidate 方法之后调用 Update 方法。在不带参数的情况下调用此方法时，会将整个工作区添加到更新区域。
这句话的意思是如果我在自定义的方法中调用了Invalidate，那么相当于我告诉程序，当前的页面无效，你必须给我重新绘制，但是不是立即重新绘制，而是放置一个WM_PAINT消息到消息队列中，操作系统收到这个消息后才能绘制窗体。
不管怎样，系统肯定会重新绘制调用Invalidate的窗体或者控件对象。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d063bed82237f4f53b83317da1aa46c2/" rel="bookmark">
			unittest模块
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一 相关概念：
*test fixture：表示执行测试的准备工作和清理工作，例如：创建临时和代理数据库、目录等。对应的类：FunctionTestCase。
*test case：最小的测试单元，测试给定输入下的指定相应，unittest模块提供了一个基类，TestCase，用来创建新的test cases。
*test suite：test cases或test suites的集合，用来集成需要一起执行的测试工作。对应类：TestSuite
*test runner：控制测试的执行，并提供测试结果。
二 简单使用：
import unittest class TestData(unittest.TestCase): def setUp(self): pass def tearDown(self): pass def test_get(self): pass if __name__ == '__main__' unittest.main() *执行方式：(1)python xxx.py；(2)python -m unittest xxx yyy zzz *测试类需继承unittest.TestCase；覆盖setUp和tearDown方法，虽然不是必须，但最好提供.
*所有测试方法需要以[Tt]est开头，类的名字没有这个要求。
*可以用如下代码替代unittest.main，下面的控制更细致：
suite = unittest.TestLoader().loadTestsFromTestCase(TestData) unittest.TextTestRunner(verbosity=2).run(suite) (2)python -m unittest的用法：python -m unittest -h
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15e3fa367c19d9e93920db6ca71740a8/" rel="bookmark">
			windows程序设计之绘图基础之点和线的绘制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		图形输出设备和计算机是分开的，利用驱动程序链接起来，是GDI可以调用驱动程序继而调用显示设备，而实现显示。
所有输出设备都需要SetPixel 和 GetPixel。
仅使用SetPixel 和 GetPixel 就可以绘制所有的图形 ，只是效率不高。
windows中MoveTo是运行该函数之前的位置，是两个16位的值加起来得到的值，但是在windows中本身是32位的，而且没有64位的值所以就出现了MoveToEx函数。
MoveToEx最后的指针是返回一个Point类型的指针，是运行该函数之前的位置，如不需要可以设置为NULL。
Ps： 尽管在windows中有32位值 但是从未使用过，一般都是使用16位的值。
Polyline函数数组画线。PolylineTo画线。
绘制完成后设置当前位置设置为最后一根线的终点。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/412e7fcbb80f00747b8b616f662c55aa/" rel="bookmark">
			数据结构第四章知识结构导图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e797743fc4a31c0f2339ae49bacacf91/" rel="bookmark">
			ntp 服务编译安装 及 更改端口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 开源库下载地址: http://download.csdn.net/detail/mtour/8151863
编译方法：
./configure --prefix=/usr/local/ntp/
make make install
更改ntp服务器端口方法
代码中默认端口宏定义是 123， 最近发现公司网络对于小端口的包不做转发，校时总是失败，于是尝试更换端口
ntp.h 中 更改宏定义值
/* * NTP protocol parameters. See section 3.2.6 of the specification. */ #define	NTP_VERSION	((u_char)4) /* current version number */ #define	NTP_OLDVERSION	((u_char)1) /* oldest credible version */ #define	NTP_PORT	11027	/* included for non-unix machines */ 我这里改为 11027 端口，经过测试，能够校时成功了。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dacab6f579102cc71c75a6c948b2db9d/" rel="bookmark">
			Sublime Text 3显示输出控制台（show output panel）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在Ubuntu中使用Sublime Text 3 写Python代码的时候，Build之后会有输出窗口（output panel），使用其他操作（查找、替换）会导致输出窗口隐藏，而且没有找到重新打开的快捷键，于是看了一下Sublime Text中的代码，自定义一个快捷键重新显示输出窗口。
打开Preference-&gt;Key Bindings - User 添加以下一条配置：
{ "keys": ["ctrl+shift+o"], "command": "show_panel", "args": {"panel": "output.exec"} } 显示窗口的命令是show_panel，args中参数panel指定具体的窗口，这里是“output.exec”（为什么是这个名称？是从sublime_text/Packages/Default.sublime-package包中的exec.py文件看到的，这个模块是执行命令的）
我用的Sublime Text 3版本还有一些小bug，在控制台会到执行Cancel Build的时候会有错误：
is_enabled must return a bool Default.exec.ExecCommand.is_enabled
这个也是由于exec.py中ExecCommand的is_enabled方法判断有写问题导致的：
只需要把is_enabled改成如下即可：
def is_enabled(self, kill = False): if kill: return hasattr(self, 'proc') and self.proc is not None and self.proc.poll() else: return True 转载于:https://www.cnblogs.com/wenjunxiao/p/4088089.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d08c13fefacebb36d24eaa3dc68205ed/" rel="bookmark">
			内存分配—new，malloc，calloc
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一。关于内存
1、内存分配方式
内存分配方式有三种：
（1）从静态存储区域分配。内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在
。例如全局变量，static变量。
（2）在栈上创建。在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存
储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。
（3） 从堆上分配，亦称动态内存分配。程序在运行的时候用malloc或new申请任意多少的内存，程序员自
己负责在何时用free或delete释放内存。动态内存的生存期由我们决定，使用非常灵活，但问题也最多。
2.内存使用错误
发生内存错误是件非常麻烦的事情。编译器不能自动发现这些错误，通常是在程序运行时才能捕捉到。
而这些错误大多没有明显的症状，时隐时现，增加了改错的难度。有时用户怒气冲冲地把你找来，程序却没
发生任何问题，你一走，错误又发作了。 常见的内存错误及其对策如下：
* 内存分配未成功，却使用了它。
编程新手常犯这种错误，因为他们没有意识到内存分配会不成功。常用解决办法是，在使用内存之前检查
指针是否为NULL。如果是用malloc或new来申请内存，应该用if(p==NULL) 或if(p!=NULL)进行防错处理。
* 内存分配虽然成功，但是尚未初始化就引用它。
犯这种错误主要有两个起因：一是没有初始化的观念；二是误以为内存的缺省初值全为零，导致引用初值
错误（例如数组）。 内存的缺省初值究竟是什么并没有统一的标准，尽管有些时候为零值，我们宁可信其无不
可信其有。所以无论用何种方式创建数组，都别忘了赋初值，即便是赋零值也不可省略，不要嫌麻烦。
* 内存分配成功并且已经初始化，但操作越过了内存的边界。
例如在使用数组时经常发生下标“多1”或者“少1”的操作。特别是在for循环语句中，循环次数很容易搞
错，导致数组操作越界。
* 忘记了释放内存，造成内存泄露。
含有这种错误的函数每被调用一次就丢失一块内存。刚开始时系统的内存充足，你看不到错误。终有一次
程序突然死掉，系统出现提示：内存耗尽。
动态内存的申请与释放必须配对，程序中malloc与free的使用次数一定要相同，否则肯定有错误
（new/delete同理）。
* 释放了内存却继续使用它。
有三种情况：
（1）程序中的对象调用关系过于复杂，实在难以搞清楚某个对象究竟是否已经释放了内存，此时应该重新
设计数据结构，从根本上解决对象管理的混乱局面。
（2）函数的return语句写错了，注意不要返回指向“栈内存”的“指针”或者“引用”，因为该内存在函
数体结束时被自动销毁。
（3）使用free或delete释放了内存后，没有将指针设置为NULL。导致产生“野指针”。
【规则1】用malloc或new申请内存之后，应该立即检查指针值是否为NULL。防止使用指针值为NULL的内存
【规则2】不要忘记为数组和动态内存赋初值。防止将未被初始化的内存作为右值使用。
【规则3】避免数组或指针的下标越界，特别要当心发生“多1”或者“少1”操作。
【规则4】动态内存的申请与释放必须配对，防止内存泄漏。
【规则5】用free或delete释放了内存之后，立即将指针设置为NULL，防止产生“野指针”。
二. 详解new，malloc，GlobalAlloc
1. new new和delete运算符用于动态分配和撤销内存的运算符
new用法:
1&gt; 开辟单变量地址空间
1)new int; //开辟一个存放数组的存储空间,返回一个指向该存储空间的地址.int *a = new int 即为将一个int类型的地址赋值给整型指针a. 2)int *a = new int(5) 作用同上,但是同时将整数赋值为5
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d08c13fefacebb36d24eaa3dc68205ed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2677ff61ddee4101a715c1b5ddc79b2/" rel="bookmark">
			【二分图|推理&#43;最大匹配】POJ-1043 What&#39;s In A Name?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		What's In A Name? Time Limit: 1000MS Memory Limit: 10000K Description
The FBI is conducting a surveillance of a known criminal hideout which serves as a communication center for a number of men and women of nefarious intent. Using sophisticated decryption software and good old fashion wiretaps, they are able to decode any e-mail messages leaving the site. However, before any arrest warrants can be served, they must match actual names with the user ID's on the messages.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c2677ff61ddee4101a715c1b5ddc79b2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/645f42f4a3af4819a942c68fce8e394c/" rel="bookmark">
			串行通信  现场总线（网络）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		串行通信 串行通信是指使用一条数据线，将数据一位一位地依次传输，每一位数据占据一个固定的时间长度。其只需要少数几条线就可以在系统间交换信息，特别适用于计算机与计算机、计算机与外设之间的远距离通信。发送和接收到的每一个字符实际上都是一次一位的传送的，每一位为1或者为0。
在通信领域内，数据通信中按每次传送的数据位数，通信方式可分为：并行通信和串行通信。在并行通信中，一个字节（8位）数据是在8条并行传输线上同时由源传到目的地。而在串行通信方式中，数据是在单条1位宽的传输线上一位接一位地顺序传送。这样一个字节的数据要分8次由低位到高位按顺序一位位地传送。
串行通信又分为串行同步通信和串行异步通信。
同步通信是一种连续串行传送数据的通信方式，一次通信只传送一帧信息。要求发送时钟和接收时钟保持严格的同步。
异步通信中，在异步通信中有两个比较重要的指标：字符帧格式和波特率。数据通常以字符或者字节为单位组成字符帧传送。字符帧由发送端逐帧发送，通过传输线被接收设备逐帧接收。发送端和接收端可以由各自的时钟来控制数据的发送和接收，这两个时钟源彼此独立，互不同步。接收端检测到传输线上发送过来的低电平逻辑"0"（即字符帧起始位）时，确定发送端已开始发送数据，每当接收端收到字符帧中的停止位时，就知道一帧字符已经发送完毕。
串行异步通信时的数据格式：是计算机通信中最常用的数据信息传输方式。
⑴ 起始位：起始位必须是持续一个比特时间的逻辑“0”电平，标志传送一个字符的开始。
⑵ 数据位：数据位为5-8位，它紧跟在起始位之后，是被传送字符的有效数据位。传送时先传送字符的低位，后传送字符的高位。数据位究竟是几位，可由硬件或软件来设定。
⑶ 奇偶位：奇偶校验位仅占一位，用于进行奇校验或偶校验，也可以不设奇偶位。
⑷ 停止位：停止位为1位、1.5位或2位，可有软件设定。它一定是逻辑“1”电平，标志着传送一个字符的结束。
⑸ 空闲位：空闲位表示线路处于空闲状态，此时线路上为逻辑“1”电平。空闲位可以没有，此时异步传送的效率为最高。
串行异步通信时的数据接收
串行异步通信时，接收方不断地检测或监视串行输入线上的电平变化，当检测到有效起始位出现时，便知道接着是有效字符位的到来，并开始接收有效字符，当检测到停止位时，就知道传输的字符结束了。经过一段随机时间间隔之后，又进行下一个字符的传送过程。 串行通信协议 最被人们熟悉的串行通信技术标准RS-232、RS-422和RS-485。目前EIA-232是 PC机与通信工业中应用最广泛的一种串行接口。此外，USB是英文 Universal Serial Bus 的缩写，是“通用串行总线”。最大特性是支持即插即用和热插拔功能。但是，在工业领域，使用USB接口的产品则甚为少见。在工业领域，人们更要求产品的可靠性和稳定性，目前，EIA标准下的串行通信技术完全可以满足人们对工业设备传输的各种性能要求，而且，这些产品价格非常低廉。相比之下，USB价格较高，并且其即插即用的功能在工业通信中没有优势。因为工业设备一般连接好以后很少进行重复插拔，USB特性的优越性不能很好地被体现出来，也就得不到工业界的普遍认可。因此，在工业领域，EIA标准依然占据统治地位。 总线 总线（Bus）是计算机各种功能部件之间传送信息的公共通信干线，它是由导线组成的传输线束， 按照计算机所传输的信息种类，计算机的总线可以划分为数据总线、地址总线和控制总线，分别用来传输数据、数据地址和控制信号。总线是一种内部结构，它是cpu、内存、输入输出设备传递信息的公用通道，主机的各个部件通过总线相连接，外部设备通过相应的接口电路再与总线相连接，从而形成了计算机硬件系统。在计算机系统中，各个部件之间传送信息的公共通路叫总线，微型计算机是以总线结构来连接各个功能部件的。
如果说主板（Mother Board）是一座城市，那么总线就像是城市里的公共汽车（bus），能按照固定行车路线，传输来回不停运作的比特（bit）。这些线路在同一时间内都仅能负责传输一个比特。因此，必须同时采用多条线路才能传送更多数据，而总线可同时传输的数据数就称为宽度（width），以比特为单位，总线宽度愈大，传输性能就愈佳。总线的带宽（即单位时间内可以传输的总数据数）为：总线带宽 = 频率 x 宽度（Bytes/sec）。当总线空闲（其他器件都以高阻态形式连接在总线上）且一个器件要与目的器件通信时，发起通信的器件驱动总线，发出地址和数据。其他以高阻态形式连接在总线上的器件如果收到（或能够收到）与自己相符的地址信息后，即接收总线上的数据。发送器件完成通信，将总线让出（输出变为高阻态）。
现场总线 （网络 ） 现场总线是指以工厂内的测量和控制机器间的数字通讯为主的网络，也称现场网络。也就是将传感器、各种操作终端和控制器间的通讯及控制器之间的通讯进行特化的网络。这些机器间的主体配线是ON/OFF、接点信号和模拟信号，通过通讯的数字化，使时间分割、多重化、多点化成为可能，从而实现高性能化、高可靠化、保养简便化、节省配线（配线的共享）。它是一种工业数据总线，是自动化领域中底层数据通信网络。
简单说，现场总线就是以数字通信替代了传统4-20mA模拟信号及普通开关量信号的传输，是连接智能现场设备和自动化系统的全数字、双向、多站的通信系统。主要解决工业现场的智能化仪器仪表、控制器、执行机构等现场设备间的数字通信以及这些现场控制设备和高级控制系统（PC上位软件）之间的信息传递问题。
现场总线是当今3C(Computer、Communication、Control)技术发展的结合点，也是过程控制技术、自动化仪表技术和计算机网络技术发展的交汇点，是信息技术、网络技术的发展在控制领域的集中体现，是信息技术、网络技术延伸到现场的必然结果。
根据国际电工委员会(IEC，International Electrotechnical Commission)标准和现场总线基金会(FF，Fieldbus Foundation)的定义，现场总线是连接智能现场设备和自动化系统的数字式、双向传输、多分支结构的通信网络。现场总线技术将专用微处理器置入传统的测量控制仪表，使其都具有数字计算和数字通信能力，成为能独立承担某些检测、控制和通信任务的网络节点。通过普通双绞线把多个测量控制仪表、计算机等作为节点连接成的网络系统;使用公开、规范的通信协议，在位于生产控制现场的多个微机化测控设备之间、以及现场仪表与用作监控、管理的远程计算机之间，实现数据传输与信息共享，形成各种适应实际需要的自动控制系统。
现场总线主要是面向过程控制，除传输数字与模拟信号的直接信息外，还可传输控制信息，网络交换的数据单元是帧(Frame)。与集散控制系统(Distributed Control System，DCS) 相比，现场总线控制系统(Fieldbus Control System，FCS)具有可靠性高以及更好的安全性、互换性和互操作性、开放性、分散性等优点。
综上所述，现场总线是将自动化最底层的现场控制器和现场智能仪表设备互连的实时控制通信网络，它遵循ISO/OSI开放系统互联参考模型的全部或部分通信协议。
特征： (1) 全数字化通信
(2) 开放型的互联网络
(3) 互可操作性与互用性
(4) 现场设备的智能化
(5) 系统结构的高度分散性
(6) 对现场环境的适应性
总线特点： 现场控制设备具有通信功能，便于构成工厂底层控制网络。
通信标准的公开、一致，使系统具备开放性，设备间具有互可操作性。
功能块与结构的规范化使相同功能的设备间具有互换性。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/645f42f4a3af4819a942c68fce8e394c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7987580cfaf95a32ee2a02e5a317be2b/" rel="bookmark">
			Windows下WAMP集成软件无法使用mail()函数的解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		话说在Java Web上一路狂奔的我，近日来一直在自学PHP的路上裸奔，感觉PHP要比JSP简单多了（我说的是入门，哈哈），闲话少叙，解决问题。
先声明下，我用的PHP集成软件是WAMP（本来打算自己配置，配了好几天觉得咱学的是知识，陪着玩意太浪费时间，所以用了集成软件，方便快捷）
今天使用PHP时，发现mail()函数不能用，查了资料终得如下解决方案：
1、下载sendemail.zip 地址：http://download.csdn.net/detail/guanzhiyou_01/8129429
2、解压至wamp文件夹下
3、配置php.ini文件（我的在G:\wamp\bin\apache\apache2.4.9\bin下，你的同理）
编辑php.ini文件找到如下代码：
[mail function] ; For Win32 only. ; http://php.net/smtp ;SMTP = ; http://php.net/smtp-port ;smtp_port = 25 ; For Win32 only. ; http://php.net/sendmail-from ;sendmail_from = you@domain.com ; For Unix only. You may supply arguments as well (default: "sendmail -t -i"). ; http://php.net/sendmail-path ;sendmail_path = 在最后一句“senmail_path = ”加上"G:\wamp\sendmail\sendmail.exe -t -i"（路径自改） 4、
在Apache moudules的ssl_moudule上打勾
修改完成后，服务会自动重启，重启完成后就ok了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91bda530651997955c8d5d4dc0f93a4d/" rel="bookmark">
			使用EA构建C&#43;&#43;项目的UML图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VS自带的“查看类图”功能实在是有些太弱爆了，只能生成继承关系，连比较基本的关联关系也不能生成。下面我们看看如何使用建模工具EA来生成强大的类图。 以下示例以EA 11.0.1106为例示范 1. 新建工程 File -&gt; New Project新建一个工程。在弹出的Model Patterns中，选中Class，点击确定后，按Alt+O打开Project Browser可以看到工程已存在。 2. 导入C++工程 Class Model上点击右键，Code Engineering -&gt; Import Source Directory后，选择项目文件夹与源代码类型后，确认。 3. 查看类图 展开源代码生成的包后，双击类图，即可查看源代码生成的类图。是不是很爽的感觉？ 这时可以根据需要，将类图中不重要的部分删除，留下核心部分，以更方便查看。同时，可以随时点击“Diagram”菜单下的Layout Diagram重拍版面，使布局更合理。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/866e9ed420332542ea26ba479157e179/" rel="bookmark">
			色度抽样（4:2:0）到底是什么意思？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在视频编码的材料中，经常提到色度采样或者色度抽样的概念，而且一般的教材里仅仅说明某些视频编码标准如MPEG4或者H.264编码标准支持某种或者某几种色度取样的编码，有时还贴出几张莫名其妙的图。那色度采样到底是什么意思呢？特别是4:2:0的图总是让人感到费解，下面就详细的介绍。
首先是为什么要有YUV，而不是RGB，采用YUV色彩空间的重要性是它的亮度信号Y和色度信号U、V是分离的。如果只有Y信号分量而没有U、V分量，那么这样表示的图像就是黑白灰度图像。彩色电视采用YUV空间正是为了用亮度信号Y解决彩色电视机与黑白电视机的兼容问题，使黑白电视机也能接收彩色电视信号。
视频一般采用YCbCr的颜色空间，其原理是人类视觉系统对亮度比彩色更敏感，因此可以把亮度信息从彩色信息分离出来，并使之具有更高的清晰度，而稍微降低彩色信息的清晰度，这样就可以在人眼未感觉图像有什么差异的前提下压缩带宽，实现一定的视频压缩。例如在压缩影像中，以4:2:2 Y'CbCr作例，它只需使用比R'G'B'（4:4:4）三分之二的带宽即可传输。
目前主要的采样格式有YCbCr 4:2:0、YCbCr 4:2:2、YCbCr 4:1:1和 YCbCr 4:4:4。问题是，这些符号到底是什么意思呢？视频系统的抽样系统中通常用一个三分比值表示：J:a:b（例如4:2:2），形容一个以J个像素宽及两个像素高的概念上区域，有时候会以四分比值表示（例如4:2:2:4）。依序列出为：
· J：水平抽样参照（概念上区域的宽度）。通常为4。
· a：在J个像素第一行中的色度抽样数目 (Cr, Cb)。
· b：在J个像素第二行中的额外色度抽样数目 (Cr, Cb)。
· Alpha：水平因子（与首数值有关连）。若没有此部分者可忽略，或存在时与J相同。
在比较图像质量时，这三个值之间的比值才是重要的，所以4:4:4可以简化为1:1:1；但是习惯上亮度样本的数量值总为4，其他两个值依此类推。有时抽样率为四分比值，如4:2:2:4。这时第四个值是调制通道的抽样频率比值。事实上，因为在调制应用中非常需要高质量图像，所以这个值在任何情况下都为4，所以采用J:a:b的表示方式更为常见。
其中容易引起误解的是以为J:a:b表示Y：Cr：Cb，那就错了，因为这里Cr和Cb是一个整体，在下图中用一个黑色实心点表示。
四种典型的采样如上图所示。首先明白，三种点各表示什么，空心圆圈是Y采样，但是CrCb是一个整体，大圈套小圈表示具有Y、Cr和Cb的点。
在理解的时候，要先以“行”为单位，以水平方向的四个点为一个单位来看。因为我们总是习惯性以2x2的单位来计算，在毕厚杰的书里就以2x2进行的。貌似这样也行。
在上图中，我们首先看4:1:1的采样，它的意思是在采样的第一行中，每连续四个点，采样一个CrCb（第一个1的含义），在紧邻的第二行中，同样采样一个CrCb(第二个1的含义)。
接着看4:2:2,它的意思是在采样的第一行中，每连续四个点，采样两个CrCb，在紧邻的第二行中采样两个CrCb。
同理4:4:4就很简单了
4:2:0的含义
但是4:2:0的图比较特殊，它表示第一行中，每连续四个点， 采样两个CrCb，在紧邻的第二行中不采样CrCb，但是，要注意，在上图中，里面只有四行，而不是两行，也就说纯黑的点组成的不是两个行，这里只是为了便于表示而单独标记出来，但是，为什么不将第二行黑点与第一行的空心圆合并呢？这一点一直让我不解。但是，看下面的图就明白了。
注意观察这里的4:2:0。从这张图里可以很明显的看到，之所以将CrCb单独列出来，原因是对色差信号Cr和Cb是每行交替传送的。很明显，这样图比较复杂，一般的书籍将其简化成了第一张图的样子，这反而有时让我们难以理解。
3.结合通信传输理论进一步理解取样的含义
～～～～～～～～～～～～～～～～～～～～～～～～～～
招聘：
我们是新浪微博视频平台，负责微博中所有视频文件处理和所有视频业务相关的后端底层接口。我们的技术方向包括视频编解码、分布式文件存储、大规模集群任务调度以及在线高并发后端服务。
我们的常用语言包括Java、Golang、Lua、C。 我们面临的挑战是一线互联网产品的视频上传、播放量，每秒数十万的接口请求量，以及快速增长的业务规模。
岗位的指责：
1. 持续优化微博视频清晰度和流畅度；
2. 负责视频编解码算法水平的持续提升，为画质提升、带宽降低、计算成本降低提供技术支持；
3. 参与建立视频和图像主客观质量评测体系； 3. 参与建立视频和图像主客观质量评测体系；
如果你满足以下要求：欢迎给我发简历：
1.本科及以上学历，计算机、通信、电子信息等相关专业 2.熟悉视频编解码算法者优先；
3.熟悉x265、x264、AV1、ffmpeg等开源库者优先；
4.了解数字图像处理、机器学习的业界发展方向，有深度学习应用经验者优先； 5.要求有较强的沟通表达能力和团队意识； 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca443584410665fe47095806aa3b77a5/" rel="bookmark">
			Objective-C Runtime 运行时之二：成员变量与属性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在前面一篇文章中，我们介绍了Runtime中与类和对象相关的内容，从这章开始，我们将讨论类实现细节相关的内容，主要包括类中成员变量，属性，方法，协议与分类的实现。 本章的主要内容将聚集在Runtime对成员变量与属性的处理。在讨论之前，我们先介绍一个重要的概念：类型编码。
类型编码(Type Encoding) 作为对Runtime的补充，编译器将每个方法的返回值和参数类型编码为一个字符串，并将其与方法的selector关联在一起。这种编码方案在其它情况下也是非常有用的，因此我们可以使用@encode编译器指令来获取它。当给定一个类型时，@encode返回这个类型的字符串编码。这些类型可以是诸如int、指针这样的基本类型，也可以是结构体、类等类型。事实上，任何可以作为sizeof()操作参数的类型都可以用于@encode()。
在Objective-C Runtime Programming Guide中的Type Encoding一节中，列出了Objective-C中所有的类型编码。需要注意的是这些类型很多是与我们用于存档和分发的编码类型是相同的。但有一些不能在存档时使用。
注：Objective-C不支持long double类型。@encode(long double)返回d，与double是一样的。
一个数组的类型编码位于方括号中；其中包含数组元素的个数及元素类型。如以下示例：
float a[] = {1.0, 2.0, 3.0}; NSLog(@"array encoding type: %s", @encode(typeof(a))); 输出是：
2014-10-28 11:44:54.731 RuntimeTest[942:50791] array encoding type: [3f] 其它类型可参考Type Encoding，在此不细说。
另外，还有些编码类型，@encode虽然不会直接返回它们，但它们可以作为协议中声明的方法的类型限定符。可以参考Type Encoding。
对于属性而言，还会有一些特殊的类型编码，以表明属性是只读、拷贝、retain等等，详情可以参考Property Type String。
成员变量、属性 Runtime中关于成员变量和属性的相关数据结构并不多，只有三个，并且都很简单。不过还有个非常实用但可能经常被忽视的特性，即关联对象，我们将在这小节中详细讨论。
基础数据类型 Ivar Ivar是表示实例变量的类型，其实际是一个指向objc_ivar结构体的指针，其定义如下：
typedef struct objc_ivar *Ivar; struct objc_ivar { char *ivar_name OBJC2_UNAVAILABLE; // 变量名 char *ivar_type OBJC2_UNAVAILABLE; // 变量类型 int ivar_offset OBJC2_UNAVAILABLE; // 基地址偏移字节 #ifdef __LP64__ int space OBJC2_UNAVAILABLE; #endif } objc_property_t objc_property_t是表示Objective-C声明的属性的类型，其实际是指向objc_property结构体的指针，其定义如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ca443584410665fe47095806aa3b77a5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2840eda777d29587781953d950f03bf/" rel="bookmark">
			select函数详细用法解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1．表头文件
#include&lt;sys/time.h&gt;
#include&lt;sys/types.h&gt;
#include&lt;unistd.h&gt;
2．函数原型
int select(int n,fd_set * readfds,fd_set * writefds,fd_set * exceptfds,struct timeval * timeout);
3．函数说明
select()用来等待文件描述词状态的改变。参数n代表最大的文件描述词加1，参数readfds、writefds 和exceptfds 称为描述词组，是用来回传该描述词的读，写或例外的状况。底下的宏提供了处理这三种描述词组的方式:
FD_CLR(inr fd,fd_set* set)；用来清除描述词组set中相关fd 的位
FD_ISSET(int fd,fd_set *set)；用来测试描述词组set中相关fd 的位是否为真
FD_SET（int fd,fd_set*set）；用来设置描述词组set中相关fd的位
FD_ZERO（fd_set *set）； 用来清除描述词组set的全部位
4．结构体说明
先说明两个结构体： 1) struct fd_set可以理解为一个集合，这个集合中存放的是文件描述符(filedescriptor)，即文件句柄，这可以是我们所说的普通意义的文件，当然Unix下任何设备、管道、FIFO等都是文件形式，全部包括在内，所以毫无疑问一个socket就是一个文件，socket句柄就是一个文件描述符。 fd_set集合可以通过一些宏由人为来操作，比如 清空集合FD_ZERO(fd_set *)； 将一个给定的文件描述符加入集合之中FD_SET(int ,fd_set*)； 将一个给定的文件描述符从集合中删除FD_CLR(int,fd_set*)； 检查集合中指定的文件描述符是否可以读写FD_ISSET(int ,fd_set* )。一会儿举例说明。 2) struct timeval是一个大家常用的结构，用来代表时间值，有两个成员，一个是秒数，另一个是毫秒数。如下所示：
struct timeval
{
time_t tv_sec;
time_t tv_usec;
};
5. 具体参数说明： 1) int n:是一个整数值，是指集合中所有文件描述符的范围，即所有文件描述符的最大值加1，不能错！在Windows中这个参数的值无所谓，可以设置不正确。 2) fd_set*readfds是指向fd_set结构的指针，这个集合中应该包括文件描述符，我们是要监视这些文件描述符的读变化的，即我们关心是否可以从这些文件中读取数据了，如果这个集合中有一个文件可读，select就会返回一个大于0的值，表示有文件可读，如果没有可读的文件，则根据timeout参数再判断是否超时，若超出timeout的时间，select返回0，若发生错误返回负值。可以传入NULL值，表示不关心任何文件的读变化。 3) fd_set*writefds是指向fd_set结构的指针，这个集合中应该包括文件描述符，我们是要监视这些文件描述符的写变化的，即我们关心是否可以向这些文件中写入数据了，如果这个集合中有一个文件可写，select就会返回一个大于0的值，表示有文件可写，如果没有可写的文件，则根据timeout参数再判断是否超时，若超出timeout的时间，select返回0，若发生错误返回负值。可以传入NULL值，表示不关心任何文件的写变化。 4) fd_set *errorfds同上面两个参数的意图，用来监视文件错误异常。 5)struct timeval *timeout是select的超时时间，这个参数至关重要，它可以使select处于三种状态，第一，若将NULL以形参传入，即不传入时间结构，就是将select置于阻塞状态，一定等到监视文件描述符集合中某个文件描述符发生变化为止；第二，若将时间值设为0秒0毫秒，就变成一个纯粹的非阻塞函数，不管文件描述符是否有变化，都立刻返回继续执行，文件无变化返回0，有变化返回一个正值；第三，timeout的值大于0，这就是等待的超时时间，即select在timeout时间内阻塞，超时时间之内有事件到来就返回了，否则在超时后不管怎样一定返回，返回值同上述。 6．返回值
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b2840eda777d29587781953d950f03bf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/539ff8df7320b77417e00cbda41f79f8/" rel="bookmark">
			数据结构第三章栈和队列知识结构导图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ce1310d12aa767f9ff80554083c9302/" rel="bookmark">
			如何迁移eclipse的配置信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 最简单的方法就是在将eclipse 的workspace目录下的.metadata/.plugins/org.eclipse.core.runtime/.settings/目录复制到新的workspace下。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2dced826873b46330f0eb4771226e19/" rel="bookmark">
			mysql 数据库导入导出方法总结（是时候总结）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		(0)目录
走，是一辈子，不走，也是一辈子（程序猿之路）
Navicat连接mysql出现2003——can't connect to mysql server on localhost(10061)
mysql 数据库导入导出方法总结（是时候总结）
注意：mysqldump 是在 操作系统命令行下运行的。
不是在 mysql 命令行下运行的，进入MySQL目录下的bin文件夹,如：C:\Program Files\MySQL\MySQL Server 5.5\bin&gt;
一般形式：mysqldump -h IP -u 用户名 -p 数据库名 &gt; 导出的文件名 （1）-p 后面不能加password，只能单独输入如1中那样 （2）mysqldump是在cmd下的命令，不能再mysql下面，即不能进入mysql的（即use dpname下，得exit退出mysql下才可以的。）
一：数据库的导出（备份）
0:(备份数据库即导出所有表以及数据 不加-d)
mysqldump -h localhost -u root -p test &gt; G:\arcgisworkspace\zypdoc\test.sql
1：(备份数据库即导出所有表结构)
C:\Program Files\MySQL\MySQL Server 5.5\bin&gt;mysqldump -h localhost -u root -p -d test &gt; G:\arcgisworkspace\zypdoc\test.sql ENTER PASSWORD:******
2 ：(导出某张表的表结构不含数据)
mysqldump -h localhost -u root -p -d test pollution &gt; G:\arcgisworkspace\zypdoc\test.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c2dced826873b46330f0eb4771226e19/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df828d3e00386869a3ab6f3dd3470eb6/" rel="bookmark">
			VC加花指令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		void flower_code() { __asm { jz label; jnz label; //相当于汇编中的db __emit 0e8h; label: mov ax, 8; xor ax, 7; } } 汇编显示如下：
实际的汇编代码：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a41a064102cbe592d848120fbb1ef879/" rel="bookmark">
			Struts2 教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Struts2是什么 Struts2是在WebWork2基础发展而来的。和Struts1一样， Struts2也是基于MVC的web层框架。 那么既然有了Struts1，为何还要Struts2？ Struts2和Struts1虽然都是基于MVC的Web框架，但是它们的实现机制完全不同。 Struts1是基于Servlet的实现，并且Struts1的API过分依赖容器，导致了Action开发、测试都非常繁琐，而Struts2是基于过滤器的实现，API不再依赖容器，测试过程中不必再模拟Web容器环境，开发、测试较Struts1都有很大的进步。 Struts1的Action是单例模式所有请求共享一个ActionServlet，所以线程必须是安全的，而Struts2每个请求都会绑定一个Action，不再有线程安全问题。 Struts2开始支持注解并提供了更为强大的OGNL标签库以及值栈，从类到页面的开发都更加简洁高效。 Struts2和Struts1都是基于MVC的Web层框架，所以，他们工作原理还是一样的，都是对请求进行拦截、分发、处理，之后返回页面，只不过他们的实现机制不同罢了。 因此，Struts2的工作原理就不再过多介绍，下面我们来看如何使用Sturts2搭建一个Web开发环境。 二、Struts2的使用 让我们先用Sturts2 展示一个Helloworld。 1、创建web项目struts2_helloworld，添加Struts2的依赖支持 struts2-core-2.3.8.jar xwork-core-2.3.8.jar commons-lang3-3.1.jar ognl-3.0.6.jar javassist-3.11.0.GA.jar asm-3.3.jar asm-commons-3.3.jar asm-tree-3.3.jar freemarker-2.3.19.jar commons-fileupload-1.2.2.jar commons-io-2.3.jar 2、在web.xml中配置struts2 &lt;filter&gt; &lt;filter- name&gt;struts2&lt;/filter- name&gt; &lt;filter- class&gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&lt;/filter- class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter- name&gt;struts2&lt;/filter- name&gt; &lt; url-pattern&gt;/*&lt;/ url-pattern&gt; &lt;/filter-mapping&gt; 3、创建Struts2配置文件struts.xml &lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;! DOCTYPE struts PUBLIC "-//Apache Software Foundation//DTD Struts Configuration 2.1//EN" "http://struts.apache.org/dtds/struts-2.1.dtd"&gt; &lt;struts&gt; &lt;package name="default" namespace="/" extends="struts-default"&gt; &lt; action name="hello" class="com.boya.struts2.web.HelloAction"&gt; &lt;result&gt; /helloWorld.jsp &lt;/result&gt; &lt;/ action&gt; &lt;/package&gt; &lt;/struts&gt; 注意，与Struts1不同，Struts2的配置文件并不放在WEB-INF目录下，而需要放置在src源码根目录下 4、创建Action类 public class HelloAction { public String execute() { return "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a41a064102cbe592d848120fbb1ef879/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/edb0c32227ec2746ddd7bcdeca9eeb26/" rel="bookmark">
			Spring 教程（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Spring AOP介绍 开发其实就是在不断的重构，抽象重复代码，然后进行封装。从最原始的模块化编程到面向对象编程，代码的封装越来越整齐清晰，但是依然存在重复的代码，而这些重复代码几乎都是与业务逻辑无关的系统逻辑代码。比如在数据操作类中的插入、更新、删除数据等方法中都存在数据库事务的处理，重要业务逻辑方法中都有日志记录的逻辑等等。每个应用系统都存在着这种系统级的重复逻辑代码，而我们并没有更好的方法去将这些代码抽象出来并进行管理。然而AOP的出现弥补了这一缺陷，AOP可以在不改变原有业务逻辑代码的情况下对原有业务进行横切拦截，处理那些重复的系统逻辑。 与Ioc容器一样，AOP也是Spring的核心模块之一。AOP是Aspect-Oriented Programming的简称，现在通常称为面向切面编程。我们学了OOP，面向对象编程，而AOP并非是OOP的替代技术，它只是OOP的一个有益补充。 需要指出的是AOP的应用场合是受限的，它一般只适合于那些具有横切逻辑的应用场合：如性能监测、访问控制、事务管理以及日志记录，它并不适合处理具体的业务逻辑，分散处理业务逻辑会使得逻辑混乱、增加维护成本。 二、如何使用Spring AOP 下面以对用户操作类UserDao的AOP拦截演示Spring AOP的使用。 1、创建Java项目，添加Spring AOP依赖支持 aopalliance-1.0.jar commons-logging-1.1.1.jar spring-aop-3.2.0.RELEASE.jar spring-beans-3.2.0.RELEASE.jar spring-context-3.2.0.RELEASE.jar spring-core-3.2.0.RELEASE.jar spring-expression-3.2.0.RELEASE.jar 2、添加User及UserDao类 User类： public class User { private Integer id; private String name; } UserDao类： public class UserDao { public void save(User user){ System.out.println("save user...."); } public void delete(int id){ System.out.println("delete user...."); } public void update(User user) { System.out.println("update user ...."); } public User query(String name) { System.out.println("getUser ...."); return new User(); } } 3、添加AOP拦截处理 AOP前置通知： public class UserBeforeAdvice implements MethodBeforeAdvice { public void before(Method method, Object[] args, Object target) { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/edb0c32227ec2746ddd7bcdeca9eeb26/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a92eee60e2cb0023bbc832dfc23f88e5/" rel="bookmark">
			Odoo加载翻译后无法登陆 - REINDEX
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Odoo中加载翻译后，有时会出现无法登陆的问题。前台页面错误信息如下， Internal Server Error The server encountered an internal error and was unable to complete your request. Either the server is overloaded or there is an error in the application. 这时需要查看后台的提示信息，如果出现类似下面的信息: bad query: SELECT value FROM ir_translation WHERE lang='zh_CN' AND type in ('view') AND src='Edit Company data' AND res_id=167 AND name='web site' ... QWebException: index " ir_translation_src_hash_idx" contains unexpected zero page at block 30 HINT: Please REINDEX it. 则表明ir_translation表的索引出现了问题；根据提示，重构索引即可解决问题。方法如下: (1)在数据库命令行输入命令: REINDEX INDEX ir_translation_src_hash_idx; (2)也可通过pgAdmin操作，选定ir_translation表的ir_translation_src_hash_idx索引，点击维护，选择"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a92eee60e2cb0023bbc832dfc23f88e5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34c8a0aee2722a11fbc80b38cda625e3/" rel="bookmark">
			Oracle安装介质及补丁集下载地址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		分类： Oracle Oracle9i Database Release 2 Enterprise/Standard/Personal Edition for Windows NT/2000/XP http://download.oracle.com/otn/nt/oracle9i/9201/92010NT_Disk1.zip http://download.oracle.com/otn/nt/oracle9i/9201/92010NT_Disk2.zip http://download.oracle.com/otn/nt/oracle9i/9201/92010NT_Disk3.zip Oracle9i Database Release 2 Enterprise/Standard/Personal/Client Edition for Windows XP 2003/Windows Server 2003 (64-bit) http://download.oracle.com/otn/nt/oracle9i/9202/92021Win64_Disk1.zip http://download.oracle.com/otn/nt/oracle9i/9202/92021Win64_Disk2.zip Oracle9i Database Release 2 Enterprise/Standard Edition for Intel Linux http://download.oracle.com/otn/linux/oracle9i/9204/ship_9204_linux_disk1.cpio.gz http://download.oracle.com/otn/linux/oracle9i/9204/ship_9204_linux_disk2.cpio.gz http://download.oracle.com/otn/linux/oracle9i/9204/ship_9204_linux_disk3.cpio.gz Oracle9i Database Release 2 (9.2.0.4) Enterprise/Standard Edition for Linux x86-64 http://download.oracle.com/otn/linux/oracle9i/9204/amd64_db_9204_Disk1.cpio.gz http://download.oracle.com/otn/linux/oracle9i/9204/amd64_db_9204_Disk2.cpio.gz http://download.oracle.com/otn/linux/oracle9i/9204/amd64_db_9204_Disk3.cpio.gz Oracle9i Database Release 2 Enterprise/Standard Edition for AIX – Based 4.3.3 Systems (64-bit) http://download.oracle.com/otn/aix/oracle9i/9201/server_9201_AIX64_Disk1.cpio.gz http://download.oracle.com/otn/aix/oracle9i/9201/server_9201_AIX64_Disk2.cpio.gz http://download.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/34c8a0aee2722a11fbc80b38cda625e3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fdf69f0a2ce9e935c6a61f6562584317/" rel="bookmark">
			微博进化：内容至上到人本主义
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		微博进化：内容至上到人本主义（转）
文/柳华芳 百度百家首发
北京马拉松，雾霾，我没有去，在微博上看大家的吐槽，尽管数万人自觉为北京净化空气，空气质量似乎变化不大，而微博平台最近几天却发生了不算小的变化--V6版本到来。这是一个PC端微博的版本号，大版本号，变化自然更大一些。
话说微博上市后，pc端除了自媒体平台外，没有太大的改版升级，用户们一直等着微博变化，V6来了，变化是很大的，在视觉交互层面、产品理念层面、页面响应效率等诸多维度都有不小的改进，个人主页则是颠覆性地变革。
每一次互联网产品潮流变革背后都是产品理念和文化的变革，在扁平化、一致化、原质化的设计潮流之下，微博进化是否蕴含着更值得深度思考的思想变革呢？
微博的成功除了恰当的节点之外，很大要归功于新浪媒体化的资源和运营推动力，新浪用自己的核心优势推送微博成为最近十年间真正可以和腾讯PK的社交媒体，即便腾讯微博跟随也以失败而告终，微博的特殊的话题传播优势已经变成独一无二。
微博在官方定义是中国最大的社会化媒体平台，内容至上似乎成了理所当然的事情，新媒体和自媒体基于微博平台的传播力出现了井喷现象，文字、图像、视频等多样化、个性化的内容让微博上出现了很多草根创业成功的案例。
基于内容至上的原则，微博话题进行了升级演变，产品进行了纵向延伸，基于话题也推动了各大品牌和电视节目的微博营销和推广，这是微博的内容至上时期的最火爆场景。中国好声音第一季就是在微博上进行了大量传播设计，实现了网民回归电视屏的奇迹，旧媒体借助微博变成了跨媒体，而正在热播的中国梦之声和即将播出的百万粉丝，则让电视的内容和微博的内容相结合。
如果说内容运营造成了微博的成功，而接下来微博在商业化和大数据方面的努力，让微博产品发生了很多变化，企业微博等变化最大，微博产品上特别是PC端为媒体、企业、政府等开发的企业产品成为这个阶段的最大特色，也是国内唯一一个能让这么多官家入驻的社交化平台（人民网除外，你懂的）。
在微博商业化的目标驱动下，游戏、增值会员服务成长很快，在最近一年微博支付也快速成长，游戏、会员VIP、支付、电商等商业化产品让微博的产品形态发生了一些变化，在微博V6版本推出后，在移动端和PC端的微博信息流将都是卡片化的，商业化产品可以拥有和微博内容产品同样优秀的用户体验。
商业化驱动下的微博场景更加丰富，已经完全超出过去的内容范畴，综合场景越来越接近于现实生活，微博也更加呈现出一个社交网络平台的气质，微博不再只是内容和话题，还有人们的生活、学习、工作、招聘、网购。这些场景让微博用户的交互行为和产品认知也发生了变化，很多用户已经开始习惯微博上的不跳出页面的一站式生活解决方案了。
微博是一个不断在进化的平台，早期大家说他是中国的twitter，但是现在twitter开始抄微博了，前不久twitter也和微博一样，在页面上加入了支付功能，说他是中国的facebook，但微博也没有那么重，微博就是微博，也许微博不再需要用中国的XX这样的表达方式来介绍自己了。
微博V6版本的个人主页除了简约设计，最大的特点是将生活类垂直内容放在左边、信息流放在右边，呈现了出微博要更深入人们生活的强烈意图，电影、点评、相册、文章、音乐等都已经催生了很大的垂直影响力。这些变化让微博的平台气质更加走向人本主义和人文关怀的维度，以人为核心打造V6，而不是以内容为核心，用户对微博个人主页的重视程度和情感认同也在逐步升温。
在过去消费内容的理念下，人是被动的，甚至有时候会被信息淹没掉自己，而微博V6带来的人本回归的风向让用户更容易沉浸于自己的微博生活，可以选择自己所爱，在自己的世界里也可以很精彩。微博信息流里的大世界和个人主页里的小世界相互和谐而生，年轻用户会更加喜欢，无论是喜欢tfboys，还是exo-m，微博上都能找到关联的人、音乐、话题、互动，小世界的精彩是产品人本化的最好归宿。
我不记得微博产品经理用哪个词来表达，我个人比较喜欢“一致化体验”这个词，这个词在苹果mac iphone ipad的体验模式和设计风格趋于统一的大背景下被互联网界格外关注，基于这个维度带来的变化正在给企业的首席产品官带来空前的希望和挑战。
微博V6在信息流中同样启用了体验良好的卡片式设计，同时整体页面更加趋于流线化，这样的设计和移动微博客户端的设计理念也走向统一，这样一致化的体验模式给微博带来的变化也将逐步体现出来。
一致化体验模式下，内容发布者的设计方式、广告主的广告设计、自媒体的内容设计、原生广告的跨终端投放等等都将发生重大变化，相对而言，让他们的工作更加省心一些，一次设计，全渠道可用，所以，一致化体验对于微博的商业化同样意义非凡。
微博V6一致化体验的实施可能引发跟随潮流，接下来应该会有大量网站研究并采用一致化产品设计模式，移动体验风格特别像苹果公司风格、安卓的原质化设计风格都开始从影响移动应用到影响PC WEB，整个互联网的设计潮流也许在一致化体验潮流下已经走向移动驱动PC的时代里。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/470b322302c7d450bbd950771e2f61d9/" rel="bookmark">
			百度地图API多个点聚合时，标注添加的标签label地图刷新就丢失的问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当将自定义的Marker（含有Label）通过MarkerClusterer 管理的时候，当地图发生任何移动、缩放 的时候，Marker 的Label 就会自动消失。 这个问题主要是由于百度的点聚合API&lt;script type="text/javascript" src="http://api.map.baidu.com/library/MarkerClusterer/1.2/src/MarkerClusterer_min.js"&gt;&lt;/script&gt; 的bug造成的。其实诱发这个问题的原因是在于API代码中的map.removeOverlay(marker)，在这句话执行的时候，会自动将marker.label =null； 我们可以在Clusterer 处理的所有地方都先读出来Label，等remove完毕之后再将这个Maker.setLabel 过去就ok了 tmplabel = this._markers[i].getLabel(); this._markers[i].getMap() &amp;&amp; this._map.removeOverlay(this._markers[i]); this._markers[i].setLabel(tmplabel); 修改过的MakerClusterer.js代码： /**
* @fileoverview MarkerClusterer标记聚合器用来解决加载大量点要素到地图上产生覆盖现象的问题，并提高性能。
* 主入口类是&lt;a href="symbols/BMapLib.MarkerClusterer.html"&gt;MarkerClusterer&lt;/a&gt;，
* 基于Baidu Map API 1.2。
*
* @author Baidu Map Api Group * @version 1.2
*/
/** * @namespace BMap的所有library类均放在BMapLib命名空间下
*/
var BMapLib = window.BMapLib = BMapLib || {};
(function(){
/**
* 获取一个扩展的视图范围，把上下左右都扩大一样的像素值。
* @param {Map} map BMap.Map的实例化对象
* @param {BMap.Bounds} bounds BMap.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/470b322302c7d450bbd950771e2f61d9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e3dc34a5e37f5194700a2d3cbfec34c/" rel="bookmark">
			MAC地址格式小结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前一段时间在做网卡驱动的工作，现在产品量产，利用ifconfig eth hw ether在配置mac地址时发现一个问题，
随机配置一个mac地址，发现有的会报出Cannot assign requested address。
错误码是EADDRNOTAVAIL。
driver中实现了专门的set_mac_addr函数，察看该函数，发现原来会检验该mac地址的有效性。
&lt;span style="font-size:14px;"&gt;static inline int is_valid_ether_addr(const u8 *addr) { /* FF:FF:FF:FF:FF:FF is a multicast address so we don't need to * explicitly check for it here. */ return !is_multicast_ether_addr(addr) &amp;&amp; !is_zero_ether_addr(addr); } &lt;/span&gt; 检查不是组播地址也不是全0地址。 组播地址就是第一个字节最低位为1，问题就是在这里。
发现第一个字节最低位为1时该函数就会返回0，driver中的set_mac_addr就会返回EADDRNOTAVAIL错误码。
严格来说mac地址对于每块网卡是固定的，每块网卡被生产出来后，都会有一个全球唯一的编号来标识自己，不会重复，
这个编号就是MAC地址，也就是网卡的物理地址。MAC地址是由48位的二进制数组成，即6个字节。在通信中是用16进制表示的。
前24位是由生产厂家向IEEE标准组织申请的厂家代码，是固定的，但是第一个字节的最低位一定是0，因为网卡的物理地址，一定是单播地址，
在IPv4的环境中，区分单播和组播地址就是校检最低位的二进制数字，0代表单播地址，1代表组播地址。
也就是说第二个数字一定是0、2、4、6、8、A、C、E其中的一个。
所以mac地址虽然可以修改，但是不要乱改，要按照厂商规定来修改，以免重复。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6ba5c900c1bd2142bd5bd2556c3633e/" rel="bookmark">
			Server error!   The server encountered an internal error and was unable to complete your request. Ei
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Server error! The server encountered an internal error and was unable to complete your request. Either the server is overloaded or there was an error in a CGI script.
If you think this is a server error, please contactthe webmaster.
Error 500 127.0.0.1
10/17/14 18:53:58
Apache/2.2.9 (Win32) DAV/2 mod_ssl/2.2.9 OpenSSL/0.9.8i mod_autoindex_color PHP/5.2.6
查看下apache 目錄下 logs 目錄里的error_log Invalid command 'RewriteEngine', perhaps misspelled or defined by a module not included in the server configuration 打开apache的配置文件httpd.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b6ba5c900c1bd2142bd5bd2556c3633e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b8f51e1de1a87dea52566ee3194b4815/" rel="bookmark">
			Count and say
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		每次对上一个s进行分析，
代码：
public class Solution {
public String countAndSay(int n) { if (n &lt;= 0) { return null; } int num = 1; String s = "1"; for (int i = 0; i &lt; n - 1; i++) { StringBuilder sb = new StringBuilder(); for (int j = 0; j &lt; s.length(); j++) { if (j &lt; s.length() - 1 &amp;&amp; s.charAt(j) == s.charAt(j + 1)) { num++; } else { sb.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b8f51e1de1a87dea52566ee3194b4815/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2924b767b5d538a10feac9cd0d6357ef/" rel="bookmark">
			Subsets - leescode
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Given a set of distinct integers, S, return all possible subsets.
Note: Elements in a subset must be in non-descending order.The solution set must not contain duplicate subsets. For example, If S = [1,2,3], a solution is:
[ [3], [1], [2], [1,2,3], [1,3], [2,3], [1,2], [] ] 分析：用result存结果，tmp存每一个子集，若符合条件，则将tmp加入result。为了不出现重复，定义一个int position来表示当前子集的第一个元素的位置，每次添加元素，然后进入递归，再添加元素知道i之后的都添加完，最内层的递归里的循环结束，开始执行remove，（以[ 1，2，3] 为例）先是remove3，则最内层递归调用执行完毕，再跳到上一层，执行remove2，此时上一层的循环第一步完成，接着继续完成循环，i++,所以此时i = 2，不是i=1,所以就是添加3，即 [1, 3]；
举例：[1，2，3]
[1]
[1,2]
[1,2,3]//此处，去掉3最底层递归调用结束，到上一层，再去掉2，此时进入上一层循环的第二个循环，i++后添加的元素是3
[1,3]//见上一行分析
[2]
[2,3]
[3]
[ ]
代码：
public class Solution {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2924b767b5d538a10feac9cd0d6357ef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c5d90c6b40b16695958423f6a46f1d1/" rel="bookmark">
			Subset
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载，源地址：http://blog.csdn.net/u011095253/article/details/9158397
Given a set of distinct integers, S, return all possible subsets.
Note: Elements in a subset must be in non-descending order.The solution set must not contain duplicate subsets. For example, If S = [1,2,3], a solution is:
[ [3], [1], [2], [1,2,3], [1,3], [2,3], [1,2], [] ] 分析：
这道题是要求生成所有子集，那么首先我们有一个能返回所有子集的ArrayList res, 和一个临时变量ArrayList tmp, 当tmp满足一定条件的时候，往res里面添加结果
Subset这道题的条件比较直观，就是每当我们添加了一个元素，都是一个新的子集。那么我们怎么保证不会出现重复集合呢。我们引入一个int pos用来记录此子集的起点在哪，比如当pos = 1的时候就是从第二个元素往后循环添加元素（0 base）,每次当此层用了第i个元素，那么下一层需要传入下一个元素的位置i+1 除此之外，当循环结束要返回上一层dfs的时候我们需要把这一层刚添加元素删去。
比如输入集合为［1，2，3］应当是这么运行，
[]
[1]
[1,2]
[1,2,3] //最底层子循环到头返回删去3，上一层的子循环也到头删去2
//而此时，这一层循环刚到2，删去后还可以添加一个3
[1,3] //删除3，删除1
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5c5d90c6b40b16695958423f6a46f1d1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85f8b048070dbe23380724cc30ff7d46/" rel="bookmark">
			Unique Path 2 - leetcode
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Unique Paths II Follow up for "Unique Paths":
Now consider if some obstacles are added to the grids. How many unique paths would there be?
An obstacle and empty space is marked as 1 and 0 respectively in the grid.
For example, There is one obstacle in the middle of a 3x3 grid as illustrated below.
[ [0,0,0], [0,1,0], [0,0,0] ] The total number of unique paths is 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/85f8b048070dbe23380724cc30ff7d46/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ba2db6dd1b8d6c264631ffcad70ebb0/" rel="bookmark">
			Flatten binary tree to linkedlist - leetcode
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Flatten Binary Tree to Linked List
Given a binary tree, flatten it to a linked list in-place.
For example, Given
1 / \ 2 5 / \ \ 3 4 6 The flattened tree should look like: 1 \ 2 \ 3 \ 4 \ 5 \ 6 分析：问题可以看做是将左子树弄平，加到root和又子树之间。实现细节是：用一个指针p，首先判断左子树是否为空，若为空则p指向p.right,若不为空，再判断p.right 是否为空，若为空则将p.left移到p.right，若不为空，用tempRight ,tempLeft 保存p的左右结点，然后flatten（p.left）,之后将tempLeft加到p.right, 然后while循环找出左子树的最后一个treenode，将tempright再加到那个treenode下面。 代码：
public class Solution {
public void flatten (TreeNode root) {
if (root == null) {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6ba2db6dd1b8d6c264631ffcad70ebb0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d3b09e1a1b7c085075a196392b6df72/" rel="bookmark">
			mac os cmake安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.下载安装程序，地址为
http://www.cmake.org/download/，下载
Unix/Linux Source (has \n line feeds) cmake-3.0.2.tar.gz 2.安装
进入到下载目录，解压缩 tar-zxvf filename
进入到解压之后目录下，可以参考README的说明，执行
sudo ./bootstrap &amp;&amp; sudo make &amp;&amp; sudo make install
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ca7281dedcf34b7e195b0619428ae37/" rel="bookmark">
			java.util.ConcurrentModificationException详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在使用set/map时，一个可爱的小bug：java.util.ConcurrentModificationException
【错误场景1】：set容器，边遍历，边add/remove元素
Set&lt;String&gt; set = new HashSet&lt;String&gt;(); for (int i = 0; i &lt; 10000; i++) { set.add(Integer.toString(i)); } for (String str : set) { //或使用iterator来循环，JDK5.0以上，这样的遍历底层也都是iterator实现。 set.add("xxx"); //报错 // set.remove(str); //报错 } 【错误场景2】：map容器，边遍历，边remove元素 Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(); for (int i = 0; i &lt; 100; i++) { map.put(Integer.toString(i), Integer.toString(i)); } for (String str : map.keySet()) {//或使用iterator来循环 map.remove(str); //报错 } 【错误场景3】list容器，边遍历，边add/remove元素 List&lt;String&gt; list = new ArrayList&lt;String&gt;(); for (int i = 0; i &lt; 100; i++) { list.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3ca7281dedcf34b7e195b0619428ae37/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66abc702dd544f5727c1d27dbfe8d1a7/" rel="bookmark">
			Java equals与hasCode详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以下是关于HashCode的官方文档定义：
[plain] view plain copy hashcode方法返回该对象的哈希码值。支持该方法是为哈希表提供一些优点，例如，java.util.Hashtable 提供的哈希表。 hashCode 的常规协定是： 在 Java 应用程序执行期间，在同一对象上多次调用 hashCode 方法时，必须一致地返回相同的整数，前提是对象上 equals 比较中所用的信息没有被修改。从某一应用程序的一次执行到同一应用程序的另一次执行，该整数无需保持一致。 如果根据 equals(Object) 方法，两个对象是相等的，那么在两个对象中的每个对象上调用 hashCode 方法都必须生成相同的整数结果。 以下情况不 是必需的：如果根据 equals(java.lang.Object) 方法，两个对象不相等，那么在两个对象中的任一对象上调用 hashCode 方法必定会生成不同的整数结果。但是，程序员应该知道，为不相等的对象生成不同整数结果可以提高哈希表的性能。 实际上，由 Object 类定义的 hashCode 方法确实会针对不同的对象返回不同的整数。（这一般是通过将该对象的内部地址转换成一个整数来实现的，但是 JavaTM 编程语言不需要这种实现技巧。） 当equals方法被重写时，通常有必要重写 hashCode 方法，以维护 hashCode 方法的常规协定，该协定声明相等对象必须具有相等的哈希码。 以上这段官方文档的定义，我们可以抽出成以下几个关键点： 1、hashCode的存在主要是用于查找的快捷性，如Hashtable，HashMap等，hashCode是用来在散列存储结构中确定对象的存储地址的；
2、如果两个对象相同，就是适用于equals(java.lang.Object) 方法，那么这两个对象的hashCode一定要相同；
3、如果对象的equals方法被重写，那么对象的hashCode也尽量重写，并且产生hashCode使用的对象，一定要和equals方法中使用的一致，否则就会违反上面提到的第2点；
4、两个对象的hashCode相同，并不一定表示两个对象就相同，也就是不一定适用于equals(java.lang.Object) 方法，只能够说明这两个对象在散列存储结构中，如Hashtable，他们“存放在同一个篮子里”。
再归纳一下就是hashCode是用于查找使用的，而equals是用于比较两个对象的是否相等的。以下这段话是从别人帖子回复拷贝过来的：
[plain] view plain copy 1.hashcode是用来查找的，如果你学过数据结构就应该知道，在查找和排序这一章有 例如内存中有这样的位置 0 1 2 3 4 5 6 7 而我有个类，这个类有个字段叫ID,我要把这个类存放在以上8个位置之一，如果不用hashcode而任意存放，那么当查找时就需要到这八个位置里挨个去找，或者用二分法一类的算法。 但如果用hashcode那就会使效率提高很多。 我们这个类中有个字段叫ID,那么我们就定义我们的hashcode为ID％8，然后把我们的类存放在取得得余数那个位置。比如我们的ID为9，9除8的余数为1，那么我们就把该类存在1这个位置，如果ID是13，求得的余数是5，那么我们就把该类放在5这个位置。这样，以后在查找该类时就可以通过ID除 8求余数直接找到存放的位置了。 2.但是如果两个类有相同的hashcode怎么办那（我们假设上面的类的ID不是唯一的），例如9除以8和17除以8的余数都是1，那么这是不是合法的，回答是：可以这样。那么如何判断呢？在这个时候就需要定义 equals了。 也就是说，我们先通过 hashcode来判断两个类是否存放某个桶里，但这个桶里可能有很多类，那么我们就需要再通过 equals 来在这个桶里找到我们要的类。 那么。重写了equals()，为什么还要重写hashCode()呢？ 想想，你要在一个桶里找东西，你必须先要找到这个桶啊，你不通过重写hashcode()来找到桶，光重写equals()有什么用啊 最后，我们来看一个具体的示例吧，
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/66abc702dd544f5727c1d27dbfe8d1a7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1e6cc369cb23d6deb8e87b02da83ed3/" rel="bookmark">
			通过rtmpdump推送海康视频流到red5服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 现在主流的网络摄像机都支持标准H264视频格式，例如 海康网络摄像机， 通过海康提供的网络SDK可以获取到视频码流。我测试的这款相机，视频编码采用的是H264，音频编码采用的是G711a。 这里，我仅测试了视频。 通过海康SDK获取到视频流为PS流，根据PS协议格式，抽取其中的H264帧数据，SPS PPS 信息。 推送RTMP流采用开源库 rtmpdump， RTMP服务器采用开源RED5。 连接上red5 后 首先 要发送 meta信息，否则通过flash 端无法打开视频流。之后再依次发送视频帧数据即可。效果如下:
与之前拿264视频文件测试不同， 此次测试采用了全新的代码架构，可接入不同的设备，例如 可以扩展大华IPC，USB摄像头等。 协议层也做了分类，方便以后扩展 RTSP流推送，私有格式推送等。
发送视频文件到red5服务器 参考代码在这里下载: http://download.csdn.net/detail/mtour/7652907 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be9cd8b4e5c1dc93bb8fea4c56a91e00/" rel="bookmark">
			cygwin 安装nginx
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		[code="java"] //下载 wget http://nginx.org/download/nginx-1.7.6.tar.gz tar -xzvf nginx-1.7.6.tar.gz http://blog.csdn.net/dyllove98/article/details/8892509 //安装gcc setup-x86_64.exe -q -P make setup-x86_64.exe -q -P gcc-g++ //zlib http://www.zlib.net/ # tar -zxvf zlib-1.2.7.tar.gz # cd zlib-1.2.7 # ./configure # make # make install //pcre http://www.pcre.org/ 手动下载安装 # tar -zxvf pcre-8.21.tar.gz # cd pcre-8.21 # ./configure # make # make install //http://www.openssl.org/source/ //安装 cd nginx-1.7.6 $ ./configure --with-pcre=../pcre-8.36 --with-zlib=../zlib-1.2.8 checking for OS + CYGWIN_NT-6.1 1.7.32(0.274/5/3) x86_64 checking for C compiler .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/be9cd8b4e5c1dc93bb8fea4c56a91e00/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/788fc2854ce4d0bfc61c569059bc7973/" rel="bookmark">
			Linux及Unix调整系统时间和时区的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux及Unix调整系统时间和时区的方法
一、Linux调整时区1) 找到相应的时区文件 ，如调整到亚洲/上海时区：
ln -s /usr/share/zoneinfo/Asia/Shanghai /etc/localtime用这个文件替换当前的/etc/localtime文件。2) 修改/etc/sysconfig/clock文件，修改为：ZONE=”Asia/Shanghai”UTC=falseARC=false
3）通过tzselect调整
# tzselect
Please identify a location so that time zone rules can be set correctly.Please select a continent or ocean 1) Africa 2) Americas 3) Antarctica 4) Arctic Ocean 5) Asia 6) Atlantic Ocean 7) Australia Europe 9) Indian Ocean 10) Pacific Ocean 11) none – I want to specify the time zone using the Posix TZ format. 输入5，亚洲 4) Bahrain 21) Kazakhstan 38) Russia 5) Bangladesh 22) Korea (North) 39) Saudi Arabia 6) Bhutan 23) Korea (South) 40) Singapore 7) Brunei 24) Kuwait 41) Sri Lanka Cambodia 25) Kyrgyzstan 42) Syria 9) China 输入9，中国 Please select one of the following time zone regions 1) east China – Beijing, Guangdong, Shanghai, etc.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/788fc2854ce4d0bfc61c569059bc7973/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae33f30440dd8975b695ea8e2b0f7c03/" rel="bookmark">
			1.VMwareTools的安装，vmware启动的时候，虚拟机黑屏，解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		﻿﻿
1 选中虚拟机，右击，然后点击：安装Vmware-tool(最好是有网络的情况下安装)
2 将Vmware-tool的安装文件拷贝到临时目录下，截图如下：
3 解压VMwareTools-9.6.0-1294478.tar.gz
4 解压后的结果如下：
5 进入vmware-tools-distrib
6 执行vmware-install.pl
7 按照提示一步步执行下去
8 重启虚拟机
9 测试是否安装成功：将一个文件往虚拟机内部拷贝。如果发现可以拷贝，说明安装成功。
如果出现了上图，说明安装成功！
vmware启动的时候，虚拟机黑屏，解决办法：
以管理员身份运行“命令提示符”—&gt; 输入命令：netsh winsock reset —&gt; 运行后重启电脑
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec95e71c2c33329437ed8404cb7657a9/" rel="bookmark">
			NSRange
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		NSRange(location，length) 表示范围，从位置(location)开始长度(length)内的元素,主要用于查找字符串在字符串中所属范围。 location 在字符串中的位置，从0开始。如果未找到需要查找的字符串，location值为-1。
length 查找字符串的长度。如果未找到需要查找的字符串，length值为0。
NSRange range = NSMakeRange(NSUInteger loc, NSUInteger len); 定义一个NSRange类型，NSMakeRange接收俩个参数，1个代表位置，1个代表长度
NSUInteger maxRange = NSMaxRange(NSUInteger loc, NSUInteger len);
定义字符串的最大范围，值为：loc + len;
BOOL b1 = NSLocationInRange(NSUInteger loc, NSRange range);
判断位置是否在限定范围内，!(loc&lt;range.loc)&amp;&amp;(loc-range.loc&lt;range.length)?YES:NO;
BOOL b2 = NSEqualRanges(NSRange range1, NSRange range2)
判断两个range的值是否相等：range1.location == range2.location &amp;&amp; range1.length == range2.length;
NSRange range = NSUnionRange(range1, range2); 将range1和range2的值结合起来，得到一个新值：
range.location = range1.location range.length取值：
(range1.location&gt;range2.location || range1.location&lt;range2.location) &amp;&amp; range1.length&gt;range2.length
range.length = range1.length
range1.location&gt;range2.location &amp;&amp; range1.length&lt;range2.length range.length = range2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ec95e71c2c33329437ed8404cb7657a9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03636a1f3fe63576bbaf7fb659d9e69d/" rel="bookmark">
			【Java】【TIJ】演示Java中main方法从命令行获取参数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们都知道，Java程序可以从命令行接收参数，下面的程序演示了怎么获取命令行参数：
代码如下：
/* *演示main方法从控制台接收字符串 *Thinking in Java Test 2.10 *@author:WolfOfSiberian */ public class TIJ_Test2_10{ public static void main(String args[]){ //判断控制台是否传入参数 if(0 != args.length){ for(int i=0;i&lt;args.length;i++){ System.out.println("args["+i+"]="+args[i]); } } else{ System.out.println("Command Line is Empty!"); } }	} 执行结果：
(从执行结果上看，命令行传入参数时候，使用空格符合来分割各个参数，然后将各个参数存入String数组)
E:\Java SE\Thinking in Java&gt;java TIJ_Test2_10
Command Line is Empty!
E:\Java SE\Thinking in Java&gt;java TIJ_Test2_10 A B C D E
args[0]=A
args[1]=B
args[2]=C
args[3]=D
args[4]=E
E:\Java SE\Thinking in Java&gt;java TIJ_Test2_10 A B C D E aadfa afjad;fja;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/03636a1f3fe63576bbaf7fb659d9e69d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c9094fc371a47d89770d169927a4734/" rel="bookmark">
			淘宝传奇工程师多隆
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这才是阿里“扫地僧”：写了十多年代码的技术大神 多隆（转）
多隆是谁？是阿里巴巴上市前最后一次实质性更新招股书中那三个新增的合伙人之一，关于这个背景详见钛媒体此前报道《阿里上市谜团基本解开，关于估值、股东套现、争议、合伙人》，其中三名新增合伙人分别是：方永新、倪行军（苗人凤）、蔡景现（多隆）。
其中彭蕾在解释为何会是他们三个人入选合伙人时说，“他们三个人的特点就是很傻很天真，多隆写代码可以写到入定的状态”。多隆是淘宝初创团队的三个开发工程师之一。外界似乎从来都没听过多隆这个名字，但在阿里内网上已经贴满了崇拜者送给他的标签，比如“神”或者“大牛中的大牛”。
不过看了阿里巴巴员工 simpx的这篇关于“如何评价阿里云多隆成为阿里巴巴集团合伙人？”的回答，小钛还真是不得不感叹，这在向来武侠风盛行的阿里巴巴，不就是传说中的“扫地僧”吗？有的人比你聪明，还比你努力。
以下文章来自知乎《如何评价阿里云多隆成为阿里巴巴集团合伙人？》，作者 simpx，阿里巴巴员工： 去年 9 月份入职阿里，有幸在多隆组里，跟着多隆做事一年，时间不长，只能粗浅谈谈个人的看法。
多隆
入职阿里前，特地看了置有 @子柳 校长的《淘宝技术这十年》，听到 HR 电话里说我被分到多隆组，当时就激动万分。
多隆在阿里的层级是 P11，相当于副总裁。刚来阿里的时候，我以为专家组，一定是都是高 P 的大团队。哪知道进来发现，多隆下面包括我，仅有 3 个下属，其中一位师兄还长期在北京。每天中午一起吃饭，可以当团建，吃完饭一起散步，就算是 outing 了。
多隆不爱带团队，团队一般沟通成本高、水平参差不齐，而他一个人就能顶一个高效顶尖的团队（所以每次问他问题打断他，我都深深内疚，感觉拖了阿里的后腿）。作为淘宝最早的程序员之一，很多产品早期就是他一个人开发维护的，文件系统 tfs、key-value 系统 tair，cache、搜索、通讯框架等等，引用行颠对他的评价：
在内网的标签上，他被称为神，这不是恭维，在所有工程师眼中，他就是个神。多隆做事一个人能顶一个团队，比如说写一个文件系统，别人很可能是一个项目组，甚至一个公司在做，而他从头到尾都是一个人，在很短的时间内就完成了。从 03 年到 07 年，淘宝搜索引擎就是他一个人在写，一个人在维护，而且这还不是他全部的工作，另外他还做了其他很多事情。
多隆不擅交际，不常分享，也不玩什么社交网络，一般很难在公众场合见到他，只要能不参加的会议、采访，他都不会参加。就算去，他也常常会带上笔记本。据说他也曾经带着笔记本去 outing，在车上写代码。虽然被所有人视为神，但他真的由心底觉得自己是一个凡人，他做的最多的就是默默坐在工位上，对着屏幕上的黑框，写代码、解决问题。
曾经看到一句话，“熟悉滋长轻视”，一旦熟悉了，传奇也会觉得不过如此。但在多隆这里，完全是相反的。越深入了解，越钦佩他的专注、职业。他说过，他的兴趣就是写代码，而他真的是每天上班除了吃饭上厕所，就是写代码，一写就写了十四年。
几个月前他在实现一个复杂的功能，有一天他一来公司，就跟我说“昨晚凌晨四点想到了实现方式，现在来试试看”，他总是想着用各种方式提升性能。
这绝对是一个“比你聪明，还比你努力”的人。
有一次在散步的时候，问他是如何成长为现在这样的大神的。他回答说“就解问题嘛”，从淘宝最开始遇到的简单 PHP 问题，一直到现在尖端的性能难题。十四年的专注加上淘宝的飞速发展，他就这样“简单”的一步一步解问题解成大神。
多隆在技术上真的已经到了“手中无剑，心中有剑”的化境。他解决没有现成答案的问题，就是直接看源码。从程序源码看到 glibc，再一路看到 kernel，直到问题解决。他很热衷于看源码解决问题，经常是今天我们都还不知道怎么办的问题，第二天他说他已经看了 xxx 的源码，改一下哪里哪里就好了。
多隆说他的花名是小宝给他起的，当时淘宝还是一个 PHP 程序的时候，一有问题，小宝就说找总管多隆看看，所以后来都说有问题，找多隆。直到现在，如果遇到有解决不了的问题，还会来找多隆解决。
技术上全面且深入，工作上无与伦比的专注，不推卸责任、不计较个人得失，真正的匠人精神，真的是阿里的一个传奇，完全配得上神的称号。
合伙人
关于多隆成为合伙人，LUCY 的回答如下：
合伙人最看重的就是坚持使命、传承文化。这三位同学都有单纯、专注、坚持和热爱的特质。他们三个人的特点就是很傻很天真。多隆写代码可以写到入定的状态。
我理解的合伙人，除了拥有提名董事的权利，还有就是阿里非常看重的文化和精神传承。作为最早期的员工，多隆伴随公司成长，与公司文化完全契合，在专业方面带领阿里攻克技术难题，个人魅力激励了许许多多的工程师，对公司有担当有贡献。论各方面，多隆成为合伙人都是实至名归。
外一篇：
04年我加入淘宝，多隆是我的师傅，就是负责带新员工熟悉工作环境的老员工。他是一个不太擅长言辞，但很谦逊平和的人。后来我们虽然在工作上合作不多，但每次见到我他也会戏称我“徒弟”。
公司里有些同事发展得很好，我很佩服，但不一定羡慕。而多隆是公司里为数不多的我非常羡慕的同事。羡慕的是他的心态和状态，他从头到尾、自始至终都是一个非常单纯，一心只执着于技术的工程师，从来没见过他执着过非技术的东西。
虽然很多其他同事也热爱技术，也有其他很多技术狂，包括我自己曾经也是。但应该这么说：多隆是爱得最深，最持久，最单纯，最心无旁骛的那一个。
在别人纠结着是不是要转型管理，是不是要转型业务，是不是要发挥更大的影响力，是不是要获得更多的权力，是不是要得到更多的回报时，他却从一直在考虑怎么通过技术改进，把问题解决得更好。
而且幸运的是，阿里给了这些一心只专注于技术的同学们极好的机会，让他们成长为“大牛”甚至“大神”。
阿里的业务一路成长起来，遇到的技术挑战越来越大，需要解决的技术问题也越来越难，复杂性也越来越大，领域也是越来越多。这就给了多隆这样的纯技术人才逐步“打怪升级”的发展机会，而且他也很享受这样的机会。
重要的是，阿里在壮大的过程中，发展出来一套很好的技术人员职业路线，一个技术人才，不需要做管理，只需专注于技术，就一样可以有机会获得更高的岗位层级，更高的收入，完全不输于管理岗位。甚至在某种程度上机会比做管理还要多，因为管理者的位子比技术专家的位子少得多。
多隆在这样的环境下，逐步成长为公司内“神”一般的人物，进而成为合伙人，应该说和他自己的能力、性格、专注分不开的，而且他也是生逢其时，在合适的时间加入了一家合适的公司，这也很重要。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef10c0e8b976aecabd66c33795f06ea3/" rel="bookmark">
			常用网络命令(十七)TcpReplay发包工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 待续... 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4f8e91e04a07a37d7486f5944a2e65b/" rel="bookmark">
			【智能家居篇】嵌入式WIFI与普通WIFI的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载请注明出处：http://blog.csdn.net/Righthek 谢谢！ 既然我们这系列的文章名称为《智能家居篇》，那么我们有必要提出一个与智能家居相关的概念。曾经一次在TI的无线研讨会上，提及这个概念。究竟是TI提出的，还是其他无线厂家提出的，这个就不去深究了。这个概念就是嵌入式WIFI，也有叫WIFI的IoT（全称：Internet of Things）解决方案，那么它和普通的WIFI又有什么区别呢？请继续阅读下文。
1、嵌入式WIFI的来源
我们都知道笔记本、手机、平板电脑等这类产品具有强大的CPU和大容量的存储器进行网络通信数据的处理和存储，因此在使用WIFI时不需要额外的MCU，完全借助其高速处理器和庞大的软件系统。但是对于家电，仪表，LED灯等智能家居产品，因为该类产品的主控芯片可能是成本很低、功能简单的MCU，因此这类产品无法支持普通Wi-Fi的功能。同时，还有一个重要的原因就是普通WIFI的功耗比较高，而嵌入式WIFI在功耗上做了很大的改善，比较适合对功耗要求高的无线家电设备。
基于上述原因，各个无线厂商相继推出了嵌入式WIFI模块。嵌入式WIFI模块的特点是软硬件集成度高，整个嵌入式WIFI模块集成了射频收发器、MAC、WIFI驱动、所有WIFI协议、无线安全协议、一键连接等。总之，一句话：嵌入式WIFI应物联网而生！
下面我们针对嵌入式WIFI与普通WIFI来进行对比，通过下表的对比，我们大致上可以理解到什么是嵌入式WIFI。
2、嵌入式WIFI与普通WIFI的对比
嵌入式WIFI模块
普通WIFI模块
适用范围
无线家电、仪表、智能灯泡等智能家居设备
笔记本、手机、平板电脑等
主控芯片
模块上集成的MCU
x86 CPU、ARM等高速微处理器
接口
UART、SPI、I2C、SDIO
USB、SDIO
功耗
低
高
产品
TI的CC3200系列、MXCHIP系列、ASIX系列、Atheros的HF-LPA系列等
瑞昱RTL81xx系列、威盛VT系列、雷凌RT系列、博通BCM、Marvell、高通Atheros等
开发设计
内置WIFI驱动、MAC、WIFI协议、无线安全协议等，所有的网络软件封装成一个UART或SPI接口的设备，使用简单，只需要往UART或者SPI收发数据即可。从整体软件层面上看，不属于网络设备。
需要在主机添加WIFI驱动、同时需要依赖主机的网络协议栈等软件平台资源，从整体软件层面上看，属于网络设备，使用时需要遵循网络相关的协议。
大致就这样吧！我们先简单了解一下基本概念，后续文章我们再详细深入分析其技术原理。
转载请注明出处：http://blog.csdn.net/Righthek 谢谢！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/980856209d7e2544f94dddba0b154fe8/" rel="bookmark">
			Zoj 3543 Number String(dp)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目链接
Number String Time Limit: 5 Seconds Memory Limit: 65536 KB The signature of a permutation is a string that is computed as follows: for each pair of consecutive elements of the permutation, write down the letter 'I' (increasing) if the second element is greater than the first one, otherwise write down the letter 'D' (decreasing). For example, the signature of the permutation {3,1,2,7,4,6,5} is "DIIDID".
Your task is as follows: You are given a string describing the signature of many possible permutations, find out how many permutations satisfy this signature.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/980856209d7e2544f94dddba0b154fe8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86ad5d2fbca91c445145e65be232b893/" rel="bookmark">
			游戏中的心理学
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		游戏中的心理学
游戏中的心理学（一）：认知失调
游戏业属于服务业，而我们服务的对象就是玩家。我们想要做好一款游戏，除了必要的专业知识，对服务对象的了解程度也非常重要。
笔者最近自学了一点心理学的皮毛，在这里尝试用心理学知识来分析玩家的心理和行为，今天先说说“认知失调理论”。
认知失调会让玩家对体验差的游戏作出“好玩”的评价
“认知失调理论”是最让人诧异的理论，费斯廷格的这个理论是这样的：“当人们陷入一种很荒谬的情况时，他们就会想出一个理由来使这种情况变得合理。”这个看似扯淡的理论竟然被无数实验证明。举个例子，其中最出名的一个论证实验是这样的：
给两组人一个很无聊的任务，其中一组拿到的报酬是20美元；另一组得到的报酬是1美元，低的惊人。完成后他问这两组人，“你们喜欢这个任务吗？”
答案非常出乎意料，拿1美元的那组喜欢这个任务的比率远高于拿20美元的那组，他们是这样回答的：
20美元组：“很无聊，我是为了20美元才做的。”
1美元组“（潜意识活动：我可不是吃力不讨好的家伙，我当然不是为了这1美元。）其实这份工作没那么无聊，挺有趣的，我学到了很多。”
更为常见的“认知失调”也经常出现在我们的工作中，例如：
你不觉得奇怪吗？你做这份没有出头之日的工作，你的才智比你上司高一倍、工作时间长、薪水不高、没有人尊重你的贡献，但你还选择在这里工作。太荒谬了！不，慢着，这当中一定是有原因的，一定是因为我喜欢这份工作。（以上大部分内容引自耶鲁大学心理学导论网络公开课）
上边这两个例子一定让你初步了解了“认知失调理论”，而提这个理论，是因为我觉得它很好地解释了两款产品为什么在用户体验差的情况下还火爆了起来。这两款产品就是去年的卡牌之王《我叫MT》和欧美ARPG大作《永恒战士3》。
这两个从玩法到类型完全不搭界的产品之所以被同时拿出来讨论，是因为它们有一个共同的特点——产品上线运营之初，各种登录不成功、网络连接失败、频繁停机维护。那个时候玩游戏简直就是一种折磨，是一种在摔PAD与不摔PAD之间挣扎的过程。尤其是《永恒战士3》，每当你挑战副本失败后，就一定会掉线，必须关掉APP重新连接七八次后“幸运”的挤进游戏后才能继续玩。
但是从数据来看，这两个游戏在这个时期的留存率都高得变态。（当然，游戏初期的留存数据都会高于今后日常运营时的数据）为什么？
从上边那两个认知失调的例子中，我试着猜测自己的潜意识活动：“我为什么花时间在这个破游戏上？这破网络为了打一次副本要浪费我半个小时，为什么我还要玩它呢？嗯……我想一定是因为它真的很不错！”
就这样，我潜意识里对它做出了好玩的评价，并在3个月的时间里把几乎所有的业余时间都用在它的身上，一直到刷最高BOSS火男刷得我看到它就想吐为止。
公平的说，《永恒战士》是一款打击感非常强、技能效果非常棒的游戏，《我叫MT》更是一款制作精良的产品。但如果不是认知失调理论造成的“好玩”错觉，如果不是“自我跟随现象”（见《怪诞行为学》）造成这个“好玩”的印象被玩家自身不断强化，这两款游戏也许达不到现在的高度。
所以各位同行们，如果游戏刚上线的时候服务器总是挂，不要绝望，合理利用“认知失调理论”，你的游戏还有救。
游戏中的心理学（二）：认知失调也有前提条件
最后有几点说明必须要和大家分享，以免有人试验此招失败来拿我泄愤。
1、你的产品给玩家的第一印象必须过硬。因为如果第一印象很差“聪明而有鉴赏力”的玩家就会想“这个烂游戏宣传写得真假，好在我比较聪明发现的早，果断删除！”就好像追美女的时候她各种拒绝你折磨你，你反而更加爱上她而不能自拔，而如果发现原来是个丑女，恐怕不管是折磨还是温柔，你早就溜之大吉了（MT和永恒战士显示属于美女）。
“这个烂游戏宣传写得真假，好在我比较聪明发现的早，果断删除！”
“我为什么花时间在这个破游戏上？这破网络为了打一次副本要浪费我半个小时，为什么我还要玩它呢？嗯……我想一定是因为它太好玩了吧！”
这两者之间的区别，你懂的！
2、凡事都有个限度，如果实在折磨的太过了，估计再好的理论也会失灵。而失灵的临界点在哪呢？在这里恕我拍个脑袋——我想应该就是经典条件发射（就是摇铃流口水那个）起作用的那个临界点，当玩家看到游戏图标那种等待的焦虑与痛苦就不自觉出现时，估计什么理论都救不了你了。
3、《我叫MT》的经验。不得不承认邢山虎也是个心理学的大师，他开创的一维护就赔偿模式（之前别的游戏也有，但没有比他力度大的）试图把网络问题和获得游戏奖励建立条件反射，成功的弱化了网络问题与焦虑痛苦感的联系。
做为心理学初学者，笔者在此信马由缰一派胡言，让各位见笑了。欢迎各位前辈批评指正，也欢迎圈内的朋友探讨交流，互相学习进步。
什么是基本归因错误？
在本文开始之前，先让我们来思考一个问题：当你在玩一个闯关游戏的时候失败了，你认为会是什么原因？
虚拟摇杆太难用？怪物设计得太难？地图上有BUG？技能设计得太弱？
是的，上边这些都会被常常提及，但而下边这些原因就很少听到了：
我的操作能力太差了。我不能同时兼顾远程和近程怪。我的反应不够快。
而如果你是这个游戏的设计者，当测试用户在你面前倒在怪物的铁蹄之下时，你会怎么想呢？答案恐怕要反过来了。
“这是从哪里找来的傻X用户，这操作也太烂了吧？”
“那么远飞过来的魔法球他瞎吗？干嘛不躲开？”
“BOSS要放技能了，喂，那么明显的释放动作，你不能躲一下吗？”
上边的例子绝非个例，而是一个普遍现象。在心理学上算是个大类，叫做“基本归因错误”，通俗的说就是“人类经常会错误的判断事情发生的原因。”
基本归因错误的直接症状就是，人常把自己的过失归纳为环境因素，而常把别人的过失归结为能力问题。本文开始的例子正是这一现象的体现。
基本归因错误在游戏设计方面有哪些作用呢？笔者试着进行了一些分析。
一、为什么游戏开始都很简单？
除了越南小鸟这种自虐型的游戏之外，基本上所有游戏的设计都秉承着先易后难这一设计思路，超级马里奥、魂斗罗、吞食天地、街头霸王（闯关时）、传奇、魔兽世界、极品飞车、王者之剑、糖果传奇、COC、天天酷跑……各个年代、各种平台、各种游戏类型，无不如此。这种设计思路几乎成为游戏界的定理。但似乎很少有人探究这其中的原理。
恕我大胆猜测一下！先易后难是为了避免基本归因错误！因为当游戏最初体验阶段（可能是10分钟到2个小时，因人因游戏类型而异），如果玩家失败，就如本文开始时提出的那个问题一样，玩家会把原因归结在游戏的设计上，而且玩家不会给你面对面解释和辩论的机会，他们会用离开直接表达自己的观点。
如果仅仅是为行规找一个理论解释，就太委屈基本归因错误了，所以下文会说说基本归因错误的其他用处。
二、让用户爱上游戏
我们设计游戏的时候，最大的愿望就是用户爱上这款游戏。而基本归因错误也许可以帮上忙。
在耶鲁大学心理学导论的公开课上，客座讲师彼得•萨洛维院长介绍了一个实验：
让几组男子戴着耳机看《花花公子》的插页，耳机中播放的是心跳的声音。试验要求男子选出自己最喜欢的女子，最后的结果是男子选出的人选千差万别。这非常符合常理，因为“萝卜白菜各有所爱”，能够登上《花花公子》的，哪个不是倾国倾城？但是，请注意这个但是，每个人所选的，几乎都是耳机中心跳声最快的时候看到那个插画——好吧，看到自己心爱的女人心跳加快，还可以解释得通——但是，又是一个但是，那个心跳不是你自己的，而是工作人员随机调快调慢的……
这就是基本归因错误！现在是不是觉得把心跳声仅仅用在濒死状态的提醒上，是不是有点大材小用了？事实上不仅仅是心跳，包括紧张、掌心出汗、呼吸急促……所有你一见钟情时的感觉体验，都可能导致你误以为爱情降临。
这个错误的威力大到了令人发指的程度，例如一个对美女调查员魅力的评分中，被试者在跑步机上挥汗的一组被试者给出的评分明显高于坐在桌前等待的一组，即使大家都知道自己心跳加快、呼吸急促是因为跑步。被告知即将进行电击试验的一组被试者评分明显高于什么都没有告知的一组，即使他们知道自己的紧张是因为即将进行的电击！
基本归因错误的利器就这样送到你手中了，打算怎么办？制造紧张气氛、用快速的心跳声，这些都是不错的办法，不过爱上游戏和爱上女人（男人）显然不那么完全相同，所以我们首先要搞清楚玩家遇上一款自己喜爱的游戏是什么感觉，然后再想办法刻意制造这种感觉。
关于这一问题的研究目前还很少，笔者也只能是根据自己的经验总结一下：激动、兴奋、爱不释手、想分享给好友、有一种终于找到了的喜悦感。（希望有实力的公司在这方面能够多做研究，而且建议样本尽量低龄化，并尽量在之前很少接触游戏。）
笔者目前正试着在本公司的项目中加入能够产生这些感觉的场景、音效、视频、对话，而实际效果需要产品上线后慢慢观察，在此暂时不过多讨论。
如何让用户爱上游戏？其核心实质就是通过各种方式，让玩家产生他爱上一个游戏时的感觉。如果你愿意在这个方面下些功夫，得到的回报一定会超出你的想象。
三、让用户觉得自己是个天才
儿童游戏设计理念中常常提到，他们对摇色子有着比成人更高的兴趣，并且常错误的认为能够摇到想要的数字是他们的能力。随着年龄的成长，认知能力的增强，这种观点会逐渐消失，但是当面对类似水果机、大鲨鱼这种押注式游戏时，成人也会不自觉的在押对的时候认为是自己的判断能力（或者直觉）在起作用。上述这些，都是很明显的基本归因错误。
我们能够从中得到什么启示呢？现在游戏设计，尤其是网游设计中，融入了大量的赌博要素（赌博本身的心理活动——斯金纳的固定比率强化程式和可变比率强化程式——本文不做讨论，但它确实是建立在对人心理的充分理解之上的，相信各种赌博游戏的设计者们，都是草根心理学大师。）但大多是摇色子、抽卡等纯随机的玩法，对于玩家来说缺少足够的参与度。这样的玩法当获得好的结果时虽然很兴奋，但也只能归因为运气，缺少更多的心理满足。而如果向押注式赌博机的设计者们学习，让玩家在这个过程中能够控制更多的东西，那么玩家在获得好的结果时，就能得到更多的心理满足并认为自己是个天才。
其实玩家押了10个币的香蕉或者西瓜或者BINGO，你获奖的概率乘以你获得的奖励的最终结果都是相同的。玩家其实什么也没有控制，但如果最终灯光停留在你押得BINGO上时，你会有一种巨大的兴奋和自己是个天才的错觉。利用好这个基本归因错误，你可以给用户更好的心理体验，并对应更为丰厚的游戏收入。
这种方式还有另外一个好处，比如玩家进行了20次博彩，其中中一半好结果一半坏结果。如果采用纯随机的方式，那么玩家的感觉差不多就是半好半坏，而如果采用更有参与感的方式，那么玩家会认为6成好4成坏，甚至7成好3成坏。因为当玩家认为自己是个天才时，好的结果会被着重强化，差的结果会被刻意忽略。就像美国选民看新闻，会着重留意与自己观点相同的而刻意忽略与自己观点不同的。现在让我们思考一个问题：在这两种情况下，你觉得哪种方式玩家会更愿意掏腰包呢？
利用基本归因错误来伺候不完美的人类
人类和其他所有动植物一样，并不完美。可能是因为人类显性大脑处理能力有限，很多功能都是在潜意识中执行的，但写入潜意识的功能很多都是在大自然中形成的，和我们现在的生活环境有矛盾和冲突。而作为游戏设计者，如何利用这些矛盾和冲突来增加用户游戏中的乐趣和消费欲望，是我们要仔细研究的课题。
最后我想说的是，基本归因错误可能是中小游戏开发者通向成功的最短路线！
游戏中的心理学（三）：如何突破印象关提升初期留存 关于如何提升游戏的早期留存，可谓是众说纷纭。在众多理论和观点中，史玉柱的”过三关”理论很好的总结了提升早期留存的关键点和策略，今天笔者试着从心理学的角度对史老师三关理论中的印象关做一个比较详细的分析。史老师的印象关强调的是画面的精美、操控的舒适、音效的质量，其中，尤以画面精美为最。史老师的这个观点凝结了他的人生智慧，也暗合心理学的要义，可谓是一语道破天机。
首先我们从“游戏初期画面为什么特别重要”这个方面来分析。在游戏初期，玩家刚刚下载了你的游戏，对游戏处于完全不了解的阶段。在这个阶段，心理学有一个命题“我们需要多长时间认知新物？”一位心理学家讲了一个故事：
我们远古的祖先在东非大草原上结队前行，突然，一种新的动物向它们跑了过来，看体型和动作有点像剑齿虎，但没有那夸张的牙齿，这时远古人类中的一部分靠潜意识迅速做出结论——“它会吃我”，然后撒腿就跑，而另外一部分则在观察和思考，试图了解更多——很不幸，思考者们成了这只老虎的猎物。
在人类几百万年的进化之路上，这样的故事不断发生，直到对新事物认知缓慢的那部分原始人类基因被无情的彻底淘汰。
这个残酷的故事解答了“我们需要多长时间认知新事物”的问题——答案是令人吃惊的短短数秒钟！ 这个神奇的过程是怎样进行的呢？首先我们的大脑里有一个庞大的分类库（其中一部分来自于基因遗传、另外大部分来自后天习得。）然后我们会对遇到的新事物进行归纳，归纳到近似的分类库中并将该库的共性赋予新事物。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/86ad5d2fbca91c445145e65be232b893/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26c7c60c3e15fde05043218ebcb23c82/" rel="bookmark">
			学习笔记：boost lock-free queue
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 #include &lt;boost/thread/thread.hpp&gt; #include &lt;boost/lockfree/queue.hpp&gt; #include &lt;boost/atomic.hpp&gt; #include &lt;boost/lockfree/policies.hpp&gt; boost::lockfree::queue&lt;int, boost::lockfree::fixed_sized&lt;false&gt; &gt; queue(12800); void producer(void) { for (int i = 0; i != 1000000; ++i) { while (!queue.push(1)) ; } } int consumer_count=0; boost::atomic&lt;bool&gt; done (false); void consumer(void) { int value; while (!done) { while (queue.pop(value)) ++consumer_count; } while (queue.pop(value)) ++consumer_count; } &lt;/pre&gt;&lt;pre code_snippet_id="474397" snippet_file_name="blog_20140924_3_4995345" name="code" class="cpp"&gt; 指定使用固定大小的队列 boost::lockfree::fixed_sized&lt;true&gt;
使用动态大小的队列 boost::lockfree::fixed_sized&lt;false&gt; 动态增长的队列，意味着使用动态内存申请，建立freeelist。而malloc等操作显然不是lock-free的。但是一旦申请到足够的内存，这个队列就稳定了，因为queue自己管理内存，不会free释放内存给OS（除非队列本身析构），因此队列在稳定后有足够的“缓冲区”，能抗冲击（短暂的大量生产，而消费暂时不足）。动态增长也有不利因素，在长期的生产大于消费的情况下，使队列越拉越长，不停的申请内存资源，因此系统崩溃。&lt;/span&gt; &lt;span style="font-family: Arial, Helvetica, sans-serif;"&gt;固定大小的队列，一般会直接用数组做内部队列的基本数据结构。当生产大于消费时，短期内队列爆满（因为不申请新内存），生产者在新插入数据时，直接插不进去。硬向里插（死循环，或spin式）的插入，将消耗大量的CPU周期，因此从CPU消耗上拖慢整个系统。&lt;/span&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29b757809e433081e9e2499d9d56543b/" rel="bookmark">
			未知错误，无法打开VisualStudio 2010的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		好久没用VisualStudio 2010了，今天打开准备写段代码，谁知道还未打开，就先弹出了一个“未知错误”，我就纳闷了，一直好好的，怎么就用不了了呢？试着修复了下，还是不行。干脆卸载重装。我信心满满的重新打开VisualStudio 2010，错误依旧，我要崩溃了。只好求助外援了，百度出来了一堆结果。其中有一条我觉得挺不靠谱的。但是反正没有其它办法，就试试呗。方法如下：
原因是QQ浏览器锁定了默认浏览器。2个步骤：
QQ浏览器设置：安全与隐私，取消勾选“开启默认浏览器保护”，点击应用
打开IE浏览器：Internet选项，程序，设为默认值，点击应用
重新打开VS ok了
我没有报什么希望的按照上面的步骤1做了一遍，报着试一试的想法，重新打开了VisualStudio 2010，久违的界面出现了。天哪，还真是QQ浏览器的问题，这个QQ浏览器真是个流氓软件，居然能影响别人的软件的启动。转念一想，这也应当是VisualStudio 2010的Bug，你怎么能因为默认的浏览器的变更，便无法启动和使用呢？不管怎么说，找到了解决问题的方法，希望能够给各位同鞋有所帮助，别再绕弯子了。
另外还有一点收获，遇到问题，先评估下可能解决问题的不同方式的时间成本，首先选择时间成本小的方式尝试，如果解决了，你就用最小的时间代价解决了你的问题；如果还解决不了，再尝试下一种方式，这样的你使用的总是最优的解决方案。但是有时可能事与愿违，评估时间成本较低的方式在实际过程中，可能出现时间超支的可能，这时你就要给这个方案定义一个最大的时间成本值，如果到达这个值，就要果断放弃该方案，不要再继续，否则，你的最优的方案就有可能变为最差的方案。记得，时间是你评估方案的唯一标准，不论何种方式，有效、高效的解决问题，才是我们的目标！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5f7cbe62330603ad6ec6ccbb7dfa025/" rel="bookmark">
			OpenSSL RSA 用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		RSA基本结构 struct
{
int pad;
long version;
const RSA_METHOD *meth;
ENGINE *engine;
BIGNUM *n; n=p*q
BIGNUM *e; 公开的加密指数，经常为65537（ox10001）
BIGNUM *d; 私钥
BIGNUM *p; 大素数p
BIGNUM *q; 大素数q
BIGNUM *dmp1; d mod (p-1)
BIGNUM *dmq1; d mod (q-1)
BIGNUM *iqmp; (inverse of q) mod p
int references;
int flags;
// ...
}RSA；
2．初始化函数
RSA * RSA_new(void);初始化一个RSA结构
void RSA_free(RSA *rsa);释放一个RSA结构
3．RSA私钥产生函数
RSA *RSA_generate_key(int num, unsigned long e,void (*callback)(int,int,void *), void *cb_arg);产生一个模为num位的密钥对，e为公开的加密指数，一般为65537（ox10001），假如后两个参数不为NULL，将有些调用。在产生密钥对之前，一般需要指定随机数种子
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a5f7cbe62330603ad6ec6ccbb7dfa025/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0416572ef6ef37dc2dde553944bcf90/" rel="bookmark">
			产品的思路——来自腾讯张小龙的分享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		产品的思路——来自腾讯张小龙的分享（转）
（2012年某讲座）
简单就是美——从苹果单按钮到微信摇一摇
今天很感谢大家从这么远的地方跑到广州来，对于产品的分享，我个人是挺有兴趣的，我觉得能够探讨一下怎么做产品，本身也是挺有意思的一件事情。
这里先用一个小故事开始讲，这个故事是关于苹果手机的，为什么苹果的手机只有一个按钮？ (台下：我觉得对于用户来说，只有一个按钮不会有太多的干扰，只要从这里开始，其它的菜单都在这里面了，这是我个人的一些想法。)
嘉宾：上次在分享的时候Martin也在，Martin理解的原因是因为这一个按钮很容易坏掉，所以用户要不停的去换新的手机。这个也有一定的道理，因为我上一个苹果手机的按钮就坏掉了，后来没有办法，只好又换了一个，而且换的还是微信的4S，这个还是破例寄过来的，因为他说我们的微信在4S下录视频只能录一秒，我说那还不到4S。
台下：乔布斯是想说我的产品是我来引导用户使用，所以只有一个按钮的时候，你必须照我的操作，你只能按这个按钮来一步步操作。
嘉宾：那两个按钮为什么就不能引导了？
台下：多一个就多一个选择了。
嘉宾：就不给他选择？
台下：对，因为你要照我的思路来操作。之前看了《乔布斯传》，也看过一些，我感觉乔布斯是性格上有一点偏执的，他追求一种极致的简洁，可能跟他的理念有关系。他如果能用一个按钮来实现的话，他绝对不会用两个按钮来实现。
嘉宾：那能不能不用按钮？
台下：其实大部分手机都不用按钮，但是可能这个按钮还是必要的。
嘉宾：最重要的不是回答的正不正确，主要是看有没有一个自己的想法，任何理由都可以的。
台下：简单。
嘉宾：对，简单是一个很好的回答，非常好。这个问题其实没有一个标准答案。
台下：我想补充一下，如果死机的话可能会把手机摔了，这可能是一个发泄的入口。
嘉宾：发泄用的？
台下：如果死机的话你会把它摔了，所以用户要去点。
嘉宾：对，这也是很合理的，因为发泄很重要的。这个没有标准答案，我说的答案也是一个仅供参考的答案，大家不要当真。为什么只有一个按钮？你再看一下为什么是白色的？其实白色的比黑的更酷一些，对不对？白色的其实是苹果最想做的，当时是做不出来，供应商做不到，所以就做了黑的先来应付一下大家，所以做了很久，后来才做出了白色的。你看这个白色的机子，再加上一个按钮，你会想到什么？一个白色的东西加一个按钮在上面，并且一按就会有奇迹发生，并且一按就会有一些事情发生了。
台下：像马桶。
嘉宾：对了。我看过一个故事，苹果的首席设计师叫乔纳森•艾弗，他以前是做马桶设计的。一个设计师设计的经验会延续的，所以你可以想象得到这里面包含了一些历史的经验。我们经常看到一些马桶上面有两个按钮，那个体验就不好了，你每次冲水都不知道该按大的按钮还是按小的按钮。
台下：我每次冲水的时候都两个按钮一起按。
嘉宾：那你是浪费水。这是我开的一个小玩笑，不是一个真实的东西。但是这个玩笑里面其实也是有一些故事，这个故事就是艾弗设计师以前确实是做日用品的设计，当时他的很多积累是来自于工业用品。然后到苹果以后，后来乔布斯回到苹果以后，发现他的设计理念跟乔布斯的很接近，然后才留下来一起来做。
我们现在用的很多是苹果的东西，这里面的很多产品是可以给我们很多启发的。所以对于苹果为什么这么做，它的硬件为什么这样做？软件为什么这样做？其实有很多值得思考的地方。我自己也看了《乔布斯传》这本书，我看了以后觉得它没有把苹果的一些设计思想和精髓写出来，比如说的一些故事。在IPhone发布的时候，他说我们这个产品是领先其它手机5年的，这个5年领先在什么地方？IOS的设计，它的理念是什么？它的哲学是什么？这个其实是很值得去思考的。
这个故事就讲到这里，我们开始今天的正题，先用简单的思维来开始。这句话大家都听了很多，听得已经起老茧了，包括少就是多，为什么少就是多？为什么简单就是美？在这里我也希望大家能参与一下，看哪位同学先来回答一下这个问题？为什么简单就是美？为什么复杂就不美了？有没有哪位同学有勇气按照自己的理解来回答一下？
什么才是简单——从腾讯微信说起
我相信男生都用了，女生用了也不会告诉我们。大家都用了吧？我摇到了一个TINA的三公里以外的。如果大家想加我的话可以一起摇一下，我们可以互加一下。但是深圳的同事，你们在100公里以外就加不到了。我们必须要同时摇，我们数1、2、3，当数到3就同时摇。大家都进入这个界面了吗？1、2、3，摇！因为必须在三秒之内摇，然后我们会看到一个列表，刚好我们摇的人就在这个里面了。我们看到这个列表里面有十几个人，就是我们刚才一起摇的人。基本上是都能捕捉到的。
大家可能已经在讨论这里面的技术问题了，这个是怎么样互相找的。这个技术问题，我相信不是一个问题，对于腾讯的技术来说，这个非常容易就做到了。我这里想说的是，作为一个产品功能，我们为什么要这样做？这个功能非常简单，优秀的开发同事可能一两天就可以开发出来，但是我们怎么样把一个功能做成一种极简的体验，这个难度非常难。
你可能今天看到摇一摇的功能很简单，如果我们做也很容易，问题就在这里，如果我们面对一个功能的时候，我们能做到这个地步，并且是别人还没有这样做过的时候，我们这样做了，这是非常难的。这里是有一些方法可以遵循的，也就是简单是美的方法。我们看一下这里面体现出来什么样简单的特点。
在这个界面里面没有任何的按钮，没有任何的菜单，也没有任何的其它入口。下面多了一个菜单可以拉出来，上一次摇到的人，这个是我们的一个败笔，准备把它给取消掉的。也就是这个界面没有任何的东西，只有一个图案，没有按钮，没有菜单，没有文字介绍。那么这个就像是Iphone的手机或者马桶只有一个按钮是一样的道理，它只有一个图片，然后这个图片只需要用户做一个动作，就是摇一摇的动作。这个动作也非常简单，这是人类有史以来最有启发性的一个动作。我因此而研究过人类的起源，人类为什么会直立行走？因为人类要把手用来抓石头，用来打猎，最后脚就用来做别的东西了，最后就直立行走了。
然后我们内部开发这个功能的时候，我们把它叫做“（录一录）”功能，内部代码叫“录一录”，我们的服务器上开发的代码叫（Lusefor）。这是人类最原始的东西，最原始的东西往往就是体验最好的。前不久我在微博上写过一句话，我们怎么样体现出最原始的东西就是体验最好的。我们回忆一下在Windows的时代，多任务是怎么体现出来的，我们要按“ALT+Tab”键，然后在Iphone里面，我们只要按底下这个按钮按两次就可以了，这个简单很多。在苹果底下，四个指头把它录下来就可以了，它就可以把多任务给切换过来了。我们看到这是一个从复杂到简单的演化过程，实际上ALT+Tab是非常复杂，很不人性化的。所以我们说Windows的体验不好，MICoS的体验好，经常会有人争论，争论到最后，大家要有一个判断依据，依据是什么，哪个东西更人性化或者更简单，或者更原始，它就是好的。我们买一个iPhone或者iPad给一个四岁小孩子用都会用，四岁的小孩体现的是它的原始或者简单，那么它是体验好的，如果要经过学习，它就不好了。
同样的，我们来看这个“摇一摇”的功能，它非常简单，任何一个人都会用，不用做任何的学习。我们会避免在界面里面出现任何的一个文字解释，一旦一个功能需要文字解释，这个功能的设计已经失败了。
我们很喜欢在程序里面加一些TIP，觉得这是一个很好的教育手段。如果你需要有一个TIP去教育用户，证明也很失败，你没有办法通过功能本身让用户一看就知道。那么用户看了这个以后，他会下意识的就摇一下，摇一下以后，这时候要给他一些刺激回馈出来，那么他会听到一个来福枪的声音，我们故意找一个来福枪的声音，这个声音很刺激。我们原来以为只有男生喜欢，后来发现女生也很喜欢，因为它代表了雄性。本来我们给女生设计的是一个“丁丁当当”的声音，后来把它取消了，都做成这个声音了。然后最初的版本摇一摇，后面是一个裸体女人的上半身，那是维纳斯，是艺术。但是我们的很多用户，包括公司内部的同事甚至领导说这个影响会不太好吧？然后我们就把它改成了一朵小花。所以到我们要放弃艺术，要追求一种大众的好的时候，其实损失就更多了。
你会看到这个过程很有意思，先有一个声音，然后有一扇门打开，再合上。然后甚至在打开的时候，如果你想换一个图片的话，你可以把手指伸到这个缝里面去点一下，点一下可以换一个背景图，没有发现吧？
台下：发现了。
嘉宾：还是女生发现了，不是男生发现了。上一次Pony很认真的给我发了一个邮件，说我们摇一摇的功能真的很好，但是我们要防止竞争对手抄袭模仿我们的功能。因为上次我们做了一个查看附近的人，然后竞争对手也做了，并且加了一个小创新在里面，叫做表白功能。这样通过一个小创新来突出，跟我们就不一样了。Pony说为什么我们没有预先把这些该想到的都想进去，让别人想模仿的时候都没有办法再来做一个微创新了。我说微创新是永无止境的，别人总可以加一点东西来跟你不太一样。然后他说这个摇一摇，我们怎么样能够把该做的都做了，而且别人没法在上面来改变一下。我说不用着急了，因为我们这个东西已经做到最简化了，别人没法超越了，我们当时是有这种自信的。这种自信一方面是说我们已经最简化了，因为就像这个手机只有一个按钮一样，除非你做一个没有按钮的手机。这里只有一个动作，甚至连按钮都没有。另外一个原因，我当时在邮件里面解释了，我说这个体验的整个过程是非常严实的，它是一种人类的性的驱动力在完成整个过程的，没有什么吸引你的驱动力比性的驱动力会更加原始，这是弗洛依德说的，不是我说的。所以这也是一个科学，不是一个道德低下的问题。
从这两个角度，一方面是它确实做得很简单，另外一方面它让你很爽，这个爽是来自很深层次的原因。所以我们说我们的竞争对手无法超越，就是这个原因。我不知道你们有没有赞同这一点或者理解到这一点。看起来很简单的一个东西，但是它已经是要有一些方法或者一些思考去达成这种简单的。手机里面可以体现出这种东西出来，因为手机可以认为是手指的一个衍生，是你的第六根指头。所以在手机底下体验是有一个非常有突破的空间，这跟你在电脑上通过鼠标和键盘来交付是不一样的，手机是跟你的身体连在一起的，是很直接的。为什么很多人喜欢汽车，对汽车那么追求？汽车是你的双腿的延伸。那个才是真正的体验。相反的，我们通过鼠标、通过键盘，就像你摸一个女孩子还要隔着衣服一样的。手机是很直接的。
怎么样看待简单是美？我的理解是简单是一种审美观，它不是一种完全非常理性的结论说我们尽可能的做得简陋一点就好了。而是说你脑袋里面是不是有一种观念在这里，但是你看到一个界面，一看它密密麻麻的铺满了按钮，然后你就知道这个东西一点都不美，然后你就说这里不对，你要把它给简化一下。这种审美就很难解释了，我就不多讲了，再往下看。
产品经理应该像上帝一样了解人性普遍规律
我记得看过一句话是说我们喜欢简单，因为上帝创造宇宙的时候，他定下来的规则也非常的简单。这句话好像是开普勒说的，有没有谁记得开普勒定律这些东西？很多物理学家会说我们发现宇宙的规律是很简单的，既然宇宙的规律都这么简单，我为什么要把很多事情搞复杂化？为什么说产品经理是站在上帝身边的人？一个是我想奉承一下产品经理，赞美一下大家，另外一点是说大家很像上帝，上帝是一个什么样的人？上帝是一个建立了简单的规则，然后让这个世界演化。
我这里想表达的是，产品经理和上帝一样，也会俯瞰芸芸众生，知道他们的欲望，然后给他们制定一些规则，让他们按照这个规则来运转。当你做到了这一点，你就会像上帝一样的，你会有上帝的成就感。
首先你要了解他们的欲望，然后你要通过你的产品去满足，并且他们在使用的过程里面是按照你的预期来的，你知道他们会怎么样自己去演化，然后你就在旁边看热闹就行了。
就像我们只做了一个很小的功能摇一摇，然后每天有几千万上亿次摇动在发生。我们知道这耗费了很多能量，所以我们下一步的计划是在摇动的时候做一个能量收集器，能够把摇动产生的动能收集起来用来发电，然后我们把它慈善的捐出去。因为每天浪费了太多的生物能，很多人都在做无用功，其实他又找不到女孩子。我们后台的数据看过这种搭讪的成功率是很低的，但是据无数的男性在那里拼命的摇啊摇，然后还有很多女性在那里摇，你们知道为什么吗？如果你们对女性的心理研究不透彻的话，你就损失了一半的用户。所以我们的产品经理现在都在看一本书叫《女性的起源》，我推荐你们也看一下。我们有一半的用户是女性。
女性为什么会摇呢？其实在座的很多女同学，她们不愿意说而已，有没有哪位女同学敢于说一下？（台下：检验魅力值。）
嘉宾：说得非常对，这里说一个小插曲，可以体现出产品经理对于女性的无知。当时做附件的人总以为我们会让女性用户受到骚扰了，我们很对不起她们，我们会有这种负疚感，我们为了让这个功能用起来，我们真的对不起这些女用户。
然后发布的第二天，我就赶紧给我们的那些女同事说，是不是有很多人骚扰你们，给你们打招呼过来了？然后跟我想的相反，她们说我们每个人都在底下看谁收到的打招呼多一些。
所以我们对我们的用户，每一个人千万不要说对我们的用户很了解了，其实不是这样子的。在座的是不是有这种虚荣心的体现？当然我们的隐私做得非常好，她会收到打招呼，但是她不会被骚扰，这些是我们做得好的地方。
之所以这么说，这里确实是给在座的各位一个很大的奉承和赞美，但是你要做到这一点，你必须要像上帝一样，要知道用户的心理，并且知道用一个什么样的规则去引导他。为什么这么说呢？规则是很简单的，只有简单的规则才可以演化出一个非常复杂的事件出来。所以我经常很不认同说，在很多做产品里面，一开始就做一个复杂的规则出来，最后没有任何演化的空间。我们看到很多的产品，像Twitter之类的产品都非常简单，它的规则简单到你们都瞧不起它，但是这样的东西是最有生命力的。如果谁一上来给我拿一个产品计划的逻辑，我都要花一个小时才能看懂，那一定不是一个好的产品。
我们再回来看，第一点是说乔布斯的理念，当然也不是乔布斯发明的，是之前的一个美国的嬉皮士说的这一句话。我们用另外一个角度来解读它，我在它前面加了一句，意思是我们要让用户保持饥饿，让他们保持愚蠢。看起来是在嘲弄用户，对吗？
但是如果你在做一个产品里面，你没有这种信心说你把握住了用户的需求，你没有办法去控制他的每一步所要做的方向，那你就控制不住这个产品，这个产品就已经在失控之中了。作为产品经理来说，一方面是自身要保持饥渴，保持一个觉得自己很无知的状态。但是对我们的用户来说，我们是要想办法让他们知道他们的饥渴在哪里。
第二点，我们要满足他们的贪嗔痴。
贪嗔痴是什么？
在佛教里面说人的本性是贪嗔痴，佛认为所有的人是瞎子，是无名的，那么睁开了眼的人就看到了光明的人，觉悟了的人就叫佛。
普通的人，他认为有三个基本的约束力，使得人不是佛，而是普通的人，就是贪嗔痴。
贪是贪婪，嗔是嫉妒，痴是执着。
那我们要洞察这一点，是因为我们的产品对用户产生黏性，就是让用户对你的产品产生贪，产生嗔，产生痴。
我们给大家各种钻，钻体现了什么心理？其实都体现了人性的这几个弱点，各种黄钻、绿钻，他会贪，他要升级；他会嗔，他会跟人比较，说你的钻比我的等级高，所以我也要升上去；他会痴，觉得我一定要把所有的钻给收齐。我们这里不是说所有的东西都要去做钻之类的东西，即使是一个体验好的产品，就像苹果的手机，它同样的会对用户产生这样的吸引力，因为这是人性本身的一个共同的弱点。
所以当我们在做一个产品的时候，我们在研究人性，而不是说在研究一个产品的逻辑。
逻辑本身没有什么好研究的，开发的同事可能更懂一些。但最重要的是你的产品为什么是这样子，而不是那样子，最后是对于人性的分析。这个人性不是说我们一些产品需要，我们摇一摇需要有人性，其它产品就不需要了？不是这样的，所有的产品都需要有人性的研究。为什么要有白色的iPhone，为什么iPhone只有两种颜色？你可以对每一个好的产品都提出来问题，那么它背后肯定都是从人性的角度来说的，而不是从别的理由来说的。所以乔布斯曾经说过一句话，记者问他：你们推出新产品的背后是做了很多的用户调研吗？还是别的一些方式来知道我们应该做什么产品？乔布斯说我们不需要去做调研，我们也不需要去看统计数据，但是我们知道用户心里面需要什么样的东西。这个知道并不是说你去问一万个用户，而是你对于人心的洞察或者人在内心里面的一些渴望的洞察，那你就会知道了。
我们经常说什么是产品体验？总结一个字的话，产品体验就是什么？爽，作为两个字来说是好玩。事实上在微信，如果我们问一下用户为什么喜欢用微信？没有一个人会给你说它可以帮我省钱，或者是帮我很方便的发短信，他们反而不会这么说。他们会告诉你这个东西挺好玩的，或者用起来挺爽的。这个会超出你的预期，你们会觉得我们本来是做一个功能，做一个通讯工具，但是用户不是这么看的。用户看的重点和你看到的是不一样的，你在拼命的给他说我帮你解决了通讯问题，用户说其实这不是我关心的。如果出现这种很大层面上的偏差，就很麻烦了。
有一次我在一个聚会里面，这个聚会里面来了好几个女生，我跟这个女生说你们装一个微信吧，她们说装微信干什么？我说装微信可以免费发短信，可以发图片，都省了彩信的钱，还可以直接说话，连打字都不需要了。这几个女孩子没有一个人有兴趣，很奇怪的看着我，我为什么要用这个东西。然后我现场给她们演示了一下，你看我附近有很多美女，我可以跟她们直接打招呼，这些人立马两眼放光，一个个拿出手机让我帮她们装。我当时都很震撼，这两个差别会这么大。我承认我当时对人了解太少了，但是真实的结果就是这样子的。
所以当我们的竞争对手360做了一个“口信”，他们的定位很清晰，因为他们很善于做这种用户的需求把握，觉得越实在的产品，对用户有实惠的产品，用户就会越喜欢。事实上很多产品之前也是这么成功的，所以他们做口信也是按照这个思路，说我帮你省了短信费，可以集成到一起。我看了以后就窃喜，因为我知道这个路是不对的。在很多时候，用户在你这里省一点钱干什么，他会去买一个别的东西，奢侈品什么的，他的钱总是要花掉的，但是他要的是一种很爽的感觉。
所以我们做产品要找到用户心理诉求的本质，这个本质是什么？我们可以简化一下，比如对微博来说，因为这个帖子是当时给微博的同事来讲的，所以用微博来举例。用户上微博干什么？用户上微博的原因是为了炫耀，是因为害怕孤独，不是利群而离群，是用它有追感。前面大家可能明白，后面这个“有追感”会比较难理解。想一下你们在微博上干什么？
台下：自言自语。
嘉宾：很少有人能做到这一点，你写一句话的时候，你脑袋里面想到哪些听众会看到，你会为他们写东西，你会构筑一个自己的形象，你会想我写了这句话以后，别人看了我的形象是不是又朝我想要的方向变了一点。你会看到一个人爱上你了，或者给你发私信了，马上第一时间去看一下，你会很在意。
实际上微博是一个构筑另一个自我的地方，构筑一个自我。就像我们平时在生活里面，通过各种行为来构建一个自我一样的，或者是自我形象。那里面爆出来很多人心的缺陷在里面，一个内心强大的人是不需要写微博的。比如韩寒不写微博，韩寒前两天写了一篇文章，我觉得写得挺好的。他说他为什么不写微博的原因，那篇文章值得看一下。我当时说了一句话，韩寒对于微博的用户心理分析得这么清晰，他要不做互联网产品是中国互联网事业的一大损失。
如果做微博的人对于用户为什么写微博的心理不能够分析得很透彻的话，那我们就是在一个很肤浅的层面来做产品。所以微博是一个很有意思的主题，我们自己写微博的时候，你观察一下自己的动静也发现挺有意思的。自言自语为什么做不到？因为没有人会写日记写那么多，那个才是自言自语，一旦有人群的地方就不是自言自语了，那挺难的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a0416572ef6ef37dc2dde553944bcf90/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dcf1a6fa881fa9b9b11628cb471db5b8/" rel="bookmark">
			UK EU 码对照表，USA EURO SIZE码对照表,国外衣服码对照表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方便大家国外采购，参照图表
USA(US) size 是美国码
Euro(EU) size是欧码
还有个国际码，就是大家常用的 S M L XL XXL Height是身高，下面的数字是英尺
Chest是胸围，单位是英寸，（ps：数字右上角 单引号是英尺(ft)，双引号是英寸(in)。1英尺=30.48 厘米(cm)，1英寸=2.54 厘米(cm) ,1英尺=12英寸）
国际码，美国码，欧码参照表 国际码美国码欧码S3646M3848L4050XL4252XXL4454XXXL4656 Male这张表是男人衣服的测量表
靴子测量表
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f51caa139fe93e2db00b15ce5f2ee4d1/" rel="bookmark">
			Qt 事件系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Qt 事件系统 分类： QT 2011-08-14 02:05 1529人阅读 评论(1) 收藏 举报 qt events application function system 目录(?)[+]
Qt是事件驱动的, 程序每个动作都是由某个事件所触发。 Qt事件的类型很多，我们可以通过查看Qt的 manual中的Event System 和 QEvent 来获得各个事件的详细信息。
为了完整起见，一份Qt4.6的事件列表附在本文后面。
事件来源 Spontaneous events(自发事件) 从系统得到的消息,比如鼠标按键,键盘按键等。Qt事件循环的时候读取这些事件，转化为QEvent后依次处理 Posted events 有Qt或应用程序产生，放入消息队列QCoreApplication::postEvent() Sent events 由Qt或应用程序产生，不放入队列，直接被派发和处理QCoreApplication::sendEvent() 比如考虑重绘事件处理函数 paintEvent()，3种事件都能使得该函数被调用：
当窗口被其他窗口覆盖后，再次重新显示时，系统将产生 spontaneous 事件来请求重绘当我们调用 update() 时，产生的是 Posted 事件当我们调用 repaint() 时，产生的是 Sent 事件 事件派发 事件循环 while (!exit_was_called) { while (!posted_event_queue_is_empty) { process_next_posted_event(); } while (!spontaneous_event_queue_is_empty) { process_next_spontaneous_event(); } while (!posted_event_queue_is_empty) { process_next_posted_event(); } } 先处理Qt事件队列中的事件，直至为空再处理系统消息队列中的消息，直至为空在处理系统消息的时候会产生新的Qt事件，需要对其再次进行处理 不通过事件循环 sendEvent的事件派发不通过事件循环。QApplication::sendEvent()是通过调用QApplication::notify()，直接进入了事件的派发和处理环节，是同步的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f51caa139fe93e2db00b15ce5f2ee4d1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2daabedcda82b8e30f535c9988ec9eea/" rel="bookmark">
			QT对话框中show和exec的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		QT对话框中show和exec的区别 转自：http://hi.baidu.com/wangjuns8/blog/item/24b382460dd1c1338694737d.html
QDialog的显示有两个函数show()和exec()。他们的区别在参考文档上的解释如下：
show(): 显示一个非模式对话框。控制权即刻返回给调用函数。 弹出窗口是否模式对话框，取决于modal属性的值。 （原文：Shows the dialog as a modeless dialog. Control returns immediately to the calling code. The dialog will be modal or modeless according to the value of the modal property. ）
exec(): 显示一个模式对话框，并且锁住程序直到用户关闭该对话框为止。函数返回一个DialogCode结果。 在对话框弹出期间，用户不可以切换同程序下的其它窗口，直到该对话框被关闭。 （原文：Shows the dialog as a modal dialog, blocking until the user closes it. The function returns a DialogCode result. Users cannot interact with any other window in the same application until they close the dialog.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2daabedcda82b8e30f535c9988ec9eea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02067f2730d1f840e13271ee99e87a30/" rel="bookmark">
			[小技巧] ubuntu 12.04中在全局菜单栏的右上角设置时间显示星期和日期
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		默认情况下只显示小时和分钟。
使用dconf-editor 后在 configuration editor的配置界面中进入 com-canonical-indicator-appmenu-datetime，
勾选 show-date 和 show-day后就可以显示星期和日期了。
显示结果如下所示：
参考：
http://askubuntu.com/questions/83597/how-do-i-show-date-next-to-time-in-the-panel-with-gnome-shell
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42b9bb04121fc1e9e60998987f3f13bc/" rel="bookmark">
			PHP 编译问题PEAR package PHP_Archive not installed的解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		php 的编译时需要依赖pear package ，目前的问题错误"PEAR package PHP_Archive not installed"，已经明显报出这个问题。 因此编译使用参数 --without-pear 将pear 屏蔽掉编译安装后，再进行安装；同时因为phar 属于pear的一个库 ，所以不将phar关闭掉，同时还会报这个错误， 同时需要使用 --disable-phar 编译参数. ./configure --without-pear --disable-phar make make install 成功编译安装完成后，再安装pear wget http://pear.php.net/go-pear.phar /usr/local/bin/php go-pear.phar 转载于:https://www.cnblogs.com/tjxwg/p/3967744.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c05804094f7a4717ab2d4e262576ee8/" rel="bookmark">
			tomcat部署项目中包含中文名称文件，报404找不到文件错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		tomcat服务器改为utf8编码 更改server.xml文件
&lt;Connector port=”8080″ protocol=”HTTP/1.1″ connectionTimeout=”20000″ redirectPort=”8443″ URIEncoding=”utf-8″ useBodyEncodingForURI=”true”/&gt;
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf7c6446082bb12f0e30abaaf7da9f18/" rel="bookmark">
			iOS view的圆角和阴影并存
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		UIView *v=[[UIView alloc]initWithFrame:CGRectMake(10, 10, 100, 100)];
v.backgroundColor=[UIColor yellowColor];
//v.layer.masksToBounds=YES;这行去掉
v.layer.cornerRadius=10;
v.layer.shadowColor=[UIColor redColor].CGColor;
v.layer.shadowOffset=CGSizeMake(10, 10);
v.layer.shadowOpacity=0.5;
v.layer.shadowRadius=5;
[self.view addSubview:v];
效果如下
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/309/">«</a>
	<span class="pagination__item pagination__item--current">310/321</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/311/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>