<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b0ba2c11f9e196ed99ea7dbece767b2/" rel="bookmark">
			华为FusionStorage Block、OceanStor 100D、OceanStor pacific的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		华为FusionStorage Block、OceanStor 100D、OceanStor pacific的区别？ 华为块存储到底是叫什么呢？ 有接触过华为块存储产品的小伙伴肯定都有疑惑，在FusionStorage 、FusionStorage Block、OceanStor 100D、OceanStor pacific等等的名词中，到底哪个才是华为块存储产品的名称呢？下面我们就来看看，华为块存储的名称历史：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4706e0dc091c0b6e2927e9bd2f722017/" rel="bookmark">
			html5——前端笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		html 一、html51.1、理解html结构1.2、h1 - h6 (标题标签)1.3、p (段落和换行标签)1.4、br 换行标签1.5、文本格式化1.6、div 和 span 标签1.7、img 图像标签1.8、a 超链接标签1.9、table表格标签1.9.1、表格标签1.9.2、表格结构标签1.9.3、合并单元格 1.10、列表1.10.1、ul无序列表1.10.2、ol有序列表1.10.3、自定义列表 1.11、表单标签1.11.1、form 表单域1.11.2、input 表单元素1.11.3、label 标签1.11.4、select表单元素1.11.5、textarea 表单元素1.11.6、 表单属性1.11.6.1、required 表单不为空1.11.6.2、placeholder 表单提示信息1.11.6.3、autofocus 自动聚焦属性1.11.6.4、autocomplete 自动完成建议1.11.6.5、multiple 可以多选文件提交 1.12、注释和特殊字符1.13、html5新增语义化标签1.14、 video 视频标签1.15、 audio 音频 一、html5 1.1、理解html结构 &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; 最简单的html页面 &lt;/body&gt; &lt;/html&gt; html页面：
&lt;!DOCTYPE&gt;不是一个 HTML 标签，它就是 文档类型声明标签，这句代码的意思是: 当前页面采取的是 HTML5 版本来显示网页
声明位于文档中的最前面的位置，处于 标签之前。 不是一个 HTML 标签，它就是 文档类型声明标签。 lang语言种类,用来定义当前文档显示的语言。
en定义语言为英语zh-CN定义语言为中文 &lt;meta charset=" UTF-8" /&gt;字符集 (Character set)是多个字符的集合。以便计算机能够识别和存储各种文字。
上面语法是必须要写的代码，否则可能引起乱码的情况。一般情况下，统一使用“UTF-8”编码，尽量
统一写成标准的 “UTF-8”，不要写成 “utf8” 或 “UTF8”。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4706e0dc091c0b6e2927e9bd2f722017/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b21895c4c0572db5c2ca9b443f883059/" rel="bookmark">
			【redis13】集群前奏：sentinel模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.哨兵sentinel引入背景 我们现在来思考一个问题：如何实现服务的高可用。我们首先想到至少要满足两个要求：1.服务端能够实现主从自动切换；2.对于客户端来说，如果发生了主从切换，则能够自动连接到最新的master节点。
我们首先想到一个思路：增加一个领导者角色，能够管理redis节点存活状态，而且具备路由功能。比如master节点超过一定时间没有给监控服务器发送心跳报文，就把master标记为下线，然后将某个slave变成master。应用每一次都是从这个监控服务器骂道master的地址。
那问题来了？如果这个监控服务器本身出问题了怎么办？或者网络不同了，链接不到监控服务器了？
那是不是应该再创建一个监控服务器，来监控监控服务器？这个似乎无解了？因此如果采取哨兵sentinel的模式，我们该如何设计就是很重要的问题了。
这篇博客内容还不错，我们直接拿来用啦！
对于sentinel机制，我们的问题可以细分为以下几个方面：
什么是Redis的哨兵模式？哨兵模式的优点是什么？哨兵模式的工作原理是什么？如何配置Redis的哨兵模式？哨兵模式中的故障转移是如何实现的？ 我们先来了解一下哨兵机制实现了以下主要功能，进一步了解这些功能的实现原理。
监控：哨兵节点定期检查Redis主节点和从节点的健康状态。它们发送命令并等待响应，以确保Redis实例正常运行。如果一个节点没有响应，哨兵节点会将其标记为下线。故障检测和转移：当一个哨兵节点检测到主节点下线时，它会将这个信息广播给其他哨兵节点。当大多数哨兵节点都确认主节点下线后，它们会开始选举出一个新的主节点。这个过程称为故障转移，它可以确保Redis集群在主节点故障时仍然能够正常运行。自动故障转移：一旦新的主节点选出，哨兵节点会更新Redis从节点的配置，使它们切换到新的主节点。这个过程是自动进行的，无需人工干预。配置提供和更新：哨兵节点会监控Redis集群的配置，并在需要时提供给客户端。当主节点发生故障转移时，哨兵节点会更新从节点的配置，使它们正确地连接到新的主节点。提供集群信息：哨兵节点可以提供有关Redis集群的信息，如主节点、从节点和哨兵节点的地址和状态。 根据上面的描述，我们可以将哨兵的功能总结为以下几点：
哨兵机制可以提供高可用性和故障转移能力，确保Redis集群在主节点故障时仍然可用。
2. 哨兵机制的原理 2.1 基本过程 哨兵实例之间可以相互发现，要归功于 Redis 提供的 pub/sub 机制，也就是发布/订阅机制。哨兵只要和主库建立起了连接，就可以在主库上发布消息了，比如说发布它自己的连接信息（IP 和端口）。同时，它也可以从主库上订阅消息，获得其他哨兵发布的连接信息。当多个哨兵实例都在主库上做了发布和订阅操作后，它们之间就能知道彼此的 IP 地址和端口。除了哨兵实例，我们自己编写的应用程序也可以通过 Redis 进行消息的发布和订阅。所以，为了区分不同应用的消息，Redis 会以频道的形式，对这些消息进行分门别类的管理。所谓的频道，实际上就是消息的类别。当消息类别相同时，它们就属于同一个频道。反之，就属于不同的频道。只有订阅了同一个频道的应用，才能通过发布的消息进行信息交换。
在主从集群中，主库上有一个名为__sentinel__:hello的频道，不同哨兵就是通过它来相互发现，实现互相通信的。我来举个例子，具体说明一下。在下图中，哨兵 1 把自己的 IP（172.16.19.3）和端口（26579）发布到__sentinel__:hello频道上，哨兵 2 和 3 订阅了该频道。那么此时，哨兵 2 和 3 就可以从这个频道直接获取哨兵 1 的 IP 地址和端口号。然后，哨兵 2、3 可以和哨兵 1 建立网络连接。通过这个方式，哨兵 2 和 3 也可以建立网络连接，这样一来，哨兵集群就形成了。它们相互间可以通过网络连接进行通信，比如说对主库有没有下线这件事儿进行判断和协商。
通过上面的讲解我们可以总结出来如下几点：
1. 哨兵集群的组建步骤
步骤1：启动哨兵节点。步骤2：配置哨兵节点的监控对象。步骤3：哨兵节点之间的通信和协调。 2.哨兵节点的角色和作用
Master节点：负责处理读写请求的主节点。Slave节点：通过复制Master节点的数据实现数据备份和读取。Sentinel节点：监控Redis集群的状态，负责主库下线判定和故障转移。 哨兵是如何知道从库的信息
哨兵向主库发送INFO命令，主库将从库列表发送给从库，哨兵跟从库列表中的从库建立连接，以便监控从库。
2.2. 主库下线的判定 在Redis Sentinel中，主从切换的执行由哨兵集群中的多个哨兵节点共同协作完成。当哨兵集群中的某个哨兵节点检测到主节点下线时，它会向其他哨兵节点发送消息，然后所有哨兵节点共同达成一致，选举出一个新的主节点，并将其他从节点指向新的主节点。选举的过程中，哨兵节点会通过投票和心跳机制来确定新的主节点。选举出的新主节点会广播给所有的客户端，以便它们能够与新的主节点进行通信。所以，主从切换的执行是由所有的哨兵节点共同参与的。 哨兵节点通过心跳机制监控主库的状态。当哨兵节点判定主库下线时，会广播通知其他哨兵节点。哨兵节点通过共识算法，确定主库是否真的下线。 2.3. 哨兵集群选举 当一个哨兵节点检测到主节点下线时，它会向其他哨兵节点发送消息，通知它们主节点已经下线。其他哨兵节点接收到消息后，它们也会检查主节点是否下线。如果它们同意主节点已下线，它们会进入选举过程。在选举过程中，哨兵节点会相互通信，通过投票和心跳机制来决定新的主节点。每个哨兵节点会为自己选举一个优先级最高的候选节点，然后它们会将自己选举的候选节点发送给其他哨兵节点。哨兵节点会根据候选节点的优先级来选出一个新的主节点。如果有多个候选节点具有相同的优先级，那么将根据配置文件中的故障转移超时属性来决定。选举出的新主节点将会广播给所有的客户端，以便它们能够与新的主节点进行通信。 需要注意的是，在选举过程中，哨兵节点需要达成多数派的共识才能选出新的主节点。例如，如果哨兵节点的总数为5，那么至少需要3个哨兵节点同意选举结果才能生效。
这个选举过程确保了在主节点下线的情况下，哨兵集群能够自动选举出一个新的主节点，从而保证了Redis的高可用性。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b21895c4c0572db5c2ca9b443f883059/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/def4be7fd56c4baca8641a5b0cb14637/" rel="bookmark">
			蓝桥杯练习题（十二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		📑前言 本文主要是【算法】——蓝桥杯练习题（十二）的文章，如果有什么需要改进的地方还请大佬指出⛺️
🎬作者简介：大家好，我是听风与他🥇
☁️博客首页：CSDN主页听风与他
🌄每日一句：狠狠沉淀，顶峰相见
目录 📑前言602.迷宫178.全球变暖200.岛屿数量📑文章末尾 602.迷宫 import java.util.LinkedList; import java.util.Queue; import java.util.Scanner; public class Main { static class node{ int x; int y; String path; public node(int x,int y,String path) { this.x = x; this.y = y; this.path = path; } } static int n=30; static int m=50; static char[][] a=new char[n][m]; static char[] direct = {'D','L','R','U'}; static int dir[][] = {{1,0},{0,-1},{0,1},{-1,0}}; static boolean visit[][]=new boolean[n][m]; static String ans; public static void main(String[] args) { // TODO Auto-generated method stub read(); bfs(); } public static void bfs() { LinkedList&lt;node&gt; q = new LinkedList&lt;&gt;(); q.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/def4be7fd56c4baca8641a5b0cb14637/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37a59812e5b9a924c61349d4e50d2c37/" rel="bookmark">
			【AI】深度学习在图像编码中的应用（1）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		视频行业在AI技术的推动下正在经历前所未有的变革，不仅传统的娱乐、媒体、教育等领域得到深度渗透，更在工业、安防、生产办公等垂直市场中开辟出众多新型应用场景。
一、新型视频应用场景 1. 工业制造 关键技术： 计算机视觉：用于检测生产线上的产品质量、定位异常或故障。深度学习：通过训练模型来识别复杂的生产模式，优化制造流程。 场景： 自动化质检：利用AI视频分析自动检测生产线上产品的缺陷，减少人工质检成本。生产过程监控：实时监控生产线，确保流程符合标准，提高生产效率。 例子： 智能制造系统中，摄像头捕捉生产过程的视频流，AI算法分析视频数据来检测装配错误或材料缺陷。 2. 安防 关键技术： 视频分析：实时处理和分析监控视频，识别异常行为或模式。人脸识别与生物识别：用于身份验证和犯罪侦查。 场景： 智能监控：自动识别监控视频中的可疑行为，如入侵、盗窃等。身份验证：在重要场所进行人脸识别，确保安全。 例子： 机场、火车站等交通枢纽使用人脸识别系统来验证旅客身份，提高安全级别。 3. 生产办公 关键技术： 视频会议：提供高清、低延迟的视频通信服务。虚拟现实（VR）与增强现实（AR）：用于远程协作、培训和模拟。 场景： 远程工作：支持员工在家或其他远程地点参与会议和工作。协作与培训：利用VR/AR技术进行模拟训练或实时协作。 例子： 工程师使用AR眼镜接收远程专家的指导，实时解决现场问题。 4. 医疗健康 关键技术： 远程医疗：通过视频进行远程诊断、咨询和手术指导。医学影像分析：利用AI辅助分析X光、MRI等影像数据。 场景： 远程诊疗：患者通过视频与医生沟通，获取专业意见。智能影像诊断：AI系统辅助医生分析影像，提高诊断准确率。 例子： AI辅助影像诊断系统帮助医生快速识别肺部CT扫描中的潜在病变。 5. 智慧城市 关键技术： 视频流分析：处理城市各处的监控视频，提供实时交通流量、人群密度等信息。物联网（IoT）：连接各种传感器和设备，收集城市运行数据。 场景： 智能交通管理：分析交通视频流，优化信号灯控制，减少拥堵。公共安全监控：整合城市监控资源，提高应急响应速度。 例子： 城市交通管理中心利用AI视频分析来预测交通拥堵点，并实时调整交通信号。 随着技术的不断进步，视频行业的应用场景将越来越广泛，不仅提高了各行业的效率和安全性，也为人们的生活带来了更多便利和创新体验。
二、传统和创新 视频的类型多种多样，涵盖了从娱乐到专业应用的各种领域。以下是一些常见的视频类型：
标清视频（SD）：传统的标准清晰度视频，通常分辨率较低，如480p。
高清视频（HD）：分辨率高于标清，如720p、1080p，提供了更清晰的画质。
超高清视频（UHD）：也称为4K（3840x2160像素）或8K（7680x4320像素）视频，提供了极高的分辨率和细腻的画质。
360度视频/VR视频：全景视频，允许观众在任何方向上观看，常用于虚拟现实（VR）体验。
3D视频：通过立体视觉效果，为观众提供深度感知，需要特定的显示设备来观看。
高动态范围视频（HDR）：提供更高的亮度和对比度范围，使画面更加逼真。
实时视频流：常用于直播服务，如新闻直播、体育赛事、游戏直播等。
延时视频/慢动作视频：通过降低帧率来展示快速运动的细节，常用于体育分析和艺术创作。
监控视频：安全摄像头捕捉的视频，通常用于安防和监控目的。
传统编码方式如H.264、MPEG-2等在过去很好地服务了视频行业，但随着技术的发展和新的应用场景的出现，它们开始显现出局限性：
压缩效率：传统编码方式在处理超高清、高帧率视频时压缩效率较低，导致文件体积庞大。编码质量：在追求更高压缩率的同时，可能会损失较多画质细节。编码速度：随着视频分辨率和复杂性的增加，传统编码方式的编码速度变慢。适应性：对于新兴的视频类型（如360度视频、HDR视频），传统编码方式可能不是最优选择。 这时，人工智能（AI）技术在视频处理中发挥了重要作用：
智能编码优化：AI可以通过学习视频内容来优化编码参数，提高压缩效率并保持较高的画质。内容识别与处理：AI算法可以识别视频中的关键内容（如人脸、物体、动作等），并根据这些信息优化编码，例如通过动态调整码率分配来保持重要内容的清晰度。超分辨率技术：利用AI的超分辨率技术，可以将低分辨率视频提升至高分辨率，改善画质。实时分析与处理：在视频流传输过程中，AI可以实时分析视频内容，动态调整编码设置以适应网络条件和设备性能。智能剪辑与合成：AI可以帮助自动化视频剪辑和合成过程，提高视频制作效率。 通过结合AI技术，视频行业能够更有效地应对不断增长的数据量和日益复杂的视频类型，同时提供更好的用户体验和更高的运营效率。
（未完待续）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87414564a1311debc57dd8ed34085435/" rel="bookmark">
			对于随机生成图片接口浏览器走缓存的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前提场景
目前有一个api 他可以随机生成一张图片，我通过v-for循环一个Array渲染出来几个img 并且都调用了该接口，但是每个img都是一样的图片
具体代码如下
&lt;div class="icon-group-box" v-for="item in groupList" :key="item.id"&gt; &lt;img :src="`https://api.likepoems.com/img/pc/`" alt="" srcset=""&gt; &lt;span class="icon-group-name"&gt;{{ item.name }}&lt;/span&gt; &lt;/div&gt; 图片如下所示
解决方法： &lt;div class="icon-group-box" v-for="item in groupList" :key="item.id"&gt; &lt;img :src="`https://api.likepoems.com/img/pc/?random=${Math.random()}`" alt="" srcset=""&gt; &lt;span class="icon-group-name"&gt;{{ item.name }}&lt;/span&gt; &lt;/div&gt; 只需要给api加个query，因为接口后端不会读这个query所以不影响，又因为有了这个query使每个请求接口都不一样也就不会走缓存了
最后说一嘴 有人可能会使用时间戳作为这个query，但是在v-for这个场景下是不实用的，因为v-for循环出来的是同一个时间戳（我已经试验过了），所以才采用的Math.random()
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4682e32e6509a512b1cf647fae417728/" rel="bookmark">
			第五章 漏洞评估 - 《骇客修成秘籍》
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第五章 漏洞评估 作者：Julian Paul Assange
简介 扫描和识别目标的漏洞通常被渗透测试者看做无聊的任务之一。但是，它也是最重要的任务之一。这也应该被当做为你的家庭作业。就像在学校那样，家庭作业和小测验的设计目的是让你熟练通过考试。
漏洞识别需要你做一些作业。你会了解到目标上什么漏洞更易于利用，便于你发送威力更大的攻击。本质上，如果攻击者本身就是考试，那么漏洞识别就是你准备的机会。
Nessus 和 OpenVAS 都可以扫描出目标上相似的漏洞。这些漏洞包括：
Linux 漏洞Windows 漏洞本地安全检查网络服务漏洞 5.1 安装、配置和启动 Nessus 在这个秘籍中，我们会安装、配置和启动 Nessus。为了在我们所选的目标上定位漏洞，Nessus 的漏洞检测有两种版本：家庭版和专业版。
家庭版：家庭版用于非商业/个人用途。以任何原因在专业环境下适用 Nessus 都需要使用专业版。上夜班：专业版用于商业用途。它包括支持和额外特性，例如无线的并发连接数，以及其它。如果你是一个顾问，需要对某个客户执行测试，专业版就是为你准备的。 对于我们的秘籍，我们假定你使用家庭版。
准备 需要满足下列需求：
需要网络连接来完成这个秘籍。Nessus 家庭版的有效许可证。 操作步骤 让我们开始安装、配置和启动 Nessus， 首先打开终端窗口：
打开 Web 浏览器，访问这个网址：。
在屏幕的左侧，Download Nessus的下面，选择Linux并且选择Nessus-5.2.1-debian6_amd64.deb（或新版本）。
将文件下载到本地根目录下。
打开终端窗口
执行下列命令来安装 Nessus：
dpkg -i "Nessus-5.2.1-debian6_i386.deb" 这个命令的输出展示在下面：
Nessus 会安装到/opt/nessus目录下。
一旦安装好了，你就能通过键入下列命令启动 Nessus：
/etc/init.d/nessusd start 在你启动 Nessus 之前，你需要先拥有注册码。你可以从“更多”一节中得到更多信息。
通过执行下列命令，激活你的 Nessus：
/opt/nessus/bin/nessus-fetch --register XXXX-XXXX-XXXX-XXXX- XXXX 这一步中，我们会从http://plugins.nessus.org获取新的插件。
取决于你的网络连接，这可能需要一到两分钟。
现在在终端中键入下列命令：
/opt/nessus/sbin/nessus-adduser 在登录提示框中，输入用户的登录名称。
输入两次密码。
回答 Y（Yes），将用户设置为管理员。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4682e32e6509a512b1cf647fae417728/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73436f524b272bdf29af90eea27e4f69/" rel="bookmark">
			【EFCore仓储模式】介绍一个EFCore的Repository实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		阅读本文你的收获 了解仓储模式及泛型仓储的优点学会封装泛型仓储的一般设计思路学习在ASP.NET Core WebAPI项目中使用EntityFrameworkCore.Data.Repository 本文中的案例是微软EntityFrameworkCore的一个仓储模式实现，这个仓储库不是我自己写的，而是使用了一个老外写的EntityFrameworkCore.Data.Repository，大家可以一起来学习一下，如果你觉得合适，可以直接用在你的项目中，很方便。案例代码下载
一、 什么是仓储模式 仓储（Repository）模式自2004年首次作为领域驱动模型DDD设计的一部分引入，仓储本质上是提供数据的抽象，以便应用程序可以使用具有接口的相似的简单抽象集合。从此集合中CURD是通过一系列直接的方法完成，无需处理连接、命令等问题，使用此种模式可帮助实现松耦合，并保持领域对象的持久性无知。
仓储模式是为了在程序的数据访问层和业务逻辑层之间创建的一个抽象层仓储模式是一种数据访问模式，提供一种更松散耦合的数据访问方法将创建数据访问的逻辑写在单独的类中即仓储仓储负责和业务层进行持久化通信 下图为控制器和仓储协同工作的图例：
二、泛型仓储 仓储（Repository）是存在于工作单元和数据库之间单独分离出来的一层，是对数据访问的封装。其优点是
业务层无需知道具体实现，达到分离关注点；提高对数据库访问的维护，对于仓储的改变，并不改变业务的逻辑； 如果我们采用的ORM框架是EF Core，实现仓储模式的话，那么类图设计一般如下：
通常实现仓储的时候，会使用泛型技术封装增删改查的的通用功能，类型T即为具体要进行增删改查处理的实体类型。
使用泛型仓储（Generic Repository）的好处有以下几点：
更好的可重用性：泛型仓储可以在多个实体类型之间共享和重用，减少了重复的代码编写和维护工作。更好的类型安全性：使用泛型仓储可以在编译时就约束数据的类型，减少了运行时类型错误的可能性。更好的简洁性：泛型仓储可以通过使用通用的方法和接口来简化数据访问的逻辑，提供统一的CRUD（增删改查）操作接口。更好的可测试性：泛型仓储使得数据访问逻辑可以更容易地进行单元测试，因为可以使用模拟或者假数据来代替实际的数据存储。更好的扩展性：泛型仓储可以通过继承或者接口实现来扩展其功能，例如添加自定义的查询方法或者过滤器。 三、基于EF Core实现的泛型仓储案例 开发环境：
操作系统： Windows 10 专业版
平台版本是：.NET 6
开发框架：ASP.NET Core WebApi、Entity Framework Core
开发工具：Visual Studio 2022
数据库： MySQL 5.7+
安装NuGet包 使用的NuGet包主要有：
EntityFrameworkCore.Data.Repository – 一个老外封装好的开源EfCore仓储实现EntityFrameworkCore.Data.UnitOfWork-- 跟以上配套的工作单元Pomelo.EntityFrameworkCore.MySql – MySQL数据库提供程序 简单剖析一下 EntityFrameworkCore.Data.Repository 可以看到，作者定义了泛型仓储接口如下：
public interface IRepository&lt;T&gt; : IRepository, IDisposable, ISyncRepository&lt;T&gt;, ISyncRepository, IQueryFactory&lt;T&gt;, IAsyncRepository&lt;T&gt;, IAsyncRepository where T : class { } IRepository&lt; T &gt;接口分别集继承了 ISyncRepository&lt; T &gt; 和 IAsyncRepository&lt; T &gt;这两个接口，分别是同步仓储方法接口和异步仓储方法接口。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/73436f524b272bdf29af90eea27e4f69/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0653f86250c296bdd87d18286cefd0cb/" rel="bookmark">
			JVM问题分析处理手册
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.前言 各位开发和运维同学，在项目实施落地的过程中，尤其是使用EDAS、DRDS、MQ这些java中间件时，肯定会遇到不少JAVA程序运行和JVM的问题。我结合过去遇到的各种各样的问题和实际处理经验，总结了JAVA问题的处理方式，希望能帮助到大家。
二.问题处理总体概括 如下图所示：
问题处理分为三大类：
1.问题发生后的紧急处理原则
2.问题归类和分析
3.分析排查工具和命令
通常来说，最后的解决方式有两种，第一种是最普遍的，绝大部分的最终问题原因可以定位到代码层面，修改代码后问题解决。
第二种，调整某些JVM参数，缓解问题发生的频率和时间，但是治标不治本，所以本篇分析文档并未涉及JVM参数的优化调整。
三.紧急处理原则 问题发生后，第一时间是快速保留问题现场供后面排查定位，然后尽快恢复服务。保留现场的具体操作：
打印堆栈信息，命令行：jstat -l 'java进程PID'打印内存镜像，命令行：jmap -dump:format=b,file=hprof 'java进程PID'生成core文件，命令行：gcore 'java进程PID'保留gc日志文件保留业务日志文件查看JAVA堆内存运行分配：命令行：jstat -gcutil 'java进程PID' 1000完成以上操作后，尽快重启JAVA进程或回滚，恢复服务。 四.问题归类和分析 当应用系统运行缓慢，页面加载时间变长，后台长时间无影响时，都可以参考以下归类的解决方法。绝大部分的JAVA程序运行时异常都是Full GC、OOM(java.lang.OutOfMemoryError)、线程过多。主要分这么几大类：
持续发生Full GC，但是系统不抛出OOM错误堆内存溢出：java.lang.OutOfMemoryError：Java heap space线程过多：java.lang.OutOfMemoryError：unable to create new native threadJAVA进程退出CPU占用过高 通常来说，可以用一些常用的命令行来打印堆栈、内存使用分配、打印内存镜像文件来分析，比如jstack、jstat、jmap等。但是某些时刻，还是需要引入更高阶的代码级分析工具（比如btrace）才能定位到具体原因。针对每一种问题，我会依据具体的case来详细说明解决方式。
五.分析排查工具和命令 问题排查，除了最重要的解决思路外，合理的运用工具也能达到事半功倍的效果，某些时候用好了工具，甚至能直接定位到导致问题的具体代码。
JDK自带工具 Jstat 实时查看gc的状况，通过jstat -gcutil 可以查看new区、old区等堆空间的内存使用详情，以及gc发生的次数和时间
Jstack 很重要的命令，jstack可以用来查看Java进程里的线程都在干什么，对于应用没反应、响应非常慢等场景都有很大的帮助。几乎所有java问题排查时，我第一选择都是使用jstack命令打印线程信息。
Jmap jmap -dump用于保存堆内存镜像文件，供后续MAT或其他的内存分析工具使用。jmap -histo:live也可以强制执行full gc。
Jinfo 通常我用它来查看Java的启动参数
gcore 我通常会使用gcore命令来保留问题现场，速度非常快。某些时候执行jstack或jmap会报错，加-F也不行，这个时候就可以用gcore命令，gcore javapid 可以生成core文件，可以通过jstack和jmap命令从core文件里导出线程和内存镜像文件。
堆内存分析工具 MAT eclipse官方推出的本地内存分析工具，运行需要大量内存，从使用角度来讲，并不方便。我现在已经很少使用。
ZProfiler 阿里中间件出品的在线堆内存分析工具，链接是：http://zprofiler.alibaba-inc.com，不需要拷贝镜像文件，直接在线分析。
EagleEye-MProf 也是阿里中间件团队推出的，适用于复杂云环境的轻量级java堆内存分析工具，非常好用。在公共云或者专有云的机器上，运行的是客户的机器。由于权限或者网络的关系，我们很难去执行jmap进行heap dump，或者scp上传dump文件。这个工具可以直接在ECS上分析，而不用下载dump文件。
代码跟踪工具 Btrace Java代码动态跟踪神器。少数的问题可以mat后直接看出，而多数会需要再用btrace去动态跟踪。比如排查线程创建过多的场景，通过btrace可以直接定位到哪段代码创建了大量线程。
比较麻烦的就是要自行编写脚本，不过现成的脚本也有不少，可以直接使用。
六.案例分析一：持续出现Full GC 处理原则 如果发现cms gc或full gc后，存活的对象始终很多，这种情况下可以通过jmap -dump来获取下内存dump文件，也可以通过gcore命令生成core文件，再用jmap从core里导出dump文件。然后通过MAT、ZProfile、EagleEye-MProf来分析内存镜像分布。如果还不能定位，最后使用btrace来定位到具体的原因。对于cms gc而言，还有可能会出现promotion failed或concurrent mode failure问题。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0653f86250c296bdd87d18286cefd0cb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a00230ec1eb70a192cc1e9e1b6c93afc/" rel="bookmark">
			Docker版 E5续订的E5调用API续订服务：Microsoft 365 E5 Renew X
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文是基于作者SundayRX提出的E5 调用API续订服务：Microsoft 365 E5 Renew X的基础上提出的Docker版本的E5调用API续订服务。
基础的账号注册等过程见SundayRX的博客：账号注册
更新日志：具体看github链接
【20240115更新】内测：更新了通用版本。支持了多种CPU架构，包括linux/amd64,linux/arm64,linux/arm/v7,linux/arm/v5,linux/arm64/v7。
【20230430更新】收到反馈，已经有部分同学的账号被强制关停。
【20230402更新】增加了邮箱通知功能。
本文主要是让小白轻松部署自己的E5续订服务。
欢迎大家加入tg交流群:链接
优点：
镜像小，仅仅225M，可以轻松部署在任何配置的服务器上，占用资源小。部署方便，真正使用一行命令即可完成部署。邮箱通知每天账号的状态等等。 你需要有：
有Docker的环境，了解Docker的基本命令（没有也没有关系，可以很快学会）。有一个服务器/群晖NAS等。 一些Docker环境安装的教程：
Docker环境搭建：添加链接描述史上最全Docker环境安装指南：Docker安装 部署步骤
运行MS365 E5 Renew X镜像，得到容器。 docker run -d -p 1066:1066 -e TZ=Asia/Shanghai -e sender="by123@163.com" -e pwd="UNxxxxxxxxN" -e receiver="4dddqqq9dd6@qq.com" -e adminpwd="123456" hanhongyong/ms365-e5-renew-x:pubemail 修改-e后面的内容，其中 sender = '123456@163.com’为发送邮件的邮箱。 receiver = '789456@qq.com’为接收邮件的邮箱。其中pwd为发送邮箱的授权码。授权码获取方式为，进入网页版163邮箱，点击设置，点击POP3/SMTP/IMAP，点击授权密码管理，新增授权码即可。 adminpwd为web界面的登录密码。
服务访问：输入ip:1066.
开发相关的命令（与部署无关）： ##构建镜像 docker build -t ms365-e5-renew-x . docker tag ms365-e5-renew-x:latest hanhongyong/ms365-e5-renew-x:latest #上传镜像 docker push hanhongyong/ms365-e5-renew-x:latest #登录dockerhub docker login 制作不易，欢迎Star!!!
GitHub:GitHub
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a00230ec1eb70a192cc1e9e1b6c93afc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12d85f2fa518a9382e4cb09be628a698/" rel="bookmark">
			供应链安全项目in-toto开源框架详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言：in-toto 是一个开源框架，能够以密码学的方式验证构件生产路径上的每个组件和步骤。它可与主流的构建工具、部署工具进行集成。in-toto已经被CNCF技术监督委员会 (Technical Oversight Committee，TOC)接纳为CNCF孵化项目。
1. 背景 由于近年来，全球供应链攻击事件频发，安全问题日益凸显。传统的供应链安全管理方法难以应对日益复杂的威胁环境，因此需要一个更为有效的方法来确保供应链的安全。
2. 简介 intoto提供了一个保护软件供应链的完整性的开源框架，通过验证链中的每个任务都是按计划执行的，仅由授权人员执行，并且构建在传输过程中没有被篡改来完成。
in-toto需要项目所有者创建布局。布局列出了软件供应链的步骤序列，以及授权执行这些步骤的专职人员。当专职人员总共执行一个步骤时，收集有关所用命令和相关文件的信息，并将其存储在链接元数据文件中。因此，链接文件提供了建立连续链所需的证据，该连续链可以根据布局中定义的步骤进行验证。
由项目所有者签名的布局以及由指定功能人员签名的链接作为最终产品的一部分发布，并且可以手动或通过自动工具（例如，包管理器）进行验证。
3. 布局（Layout） 布局由项目所有者创建，要求包含以下内容：
到期日：到期日；自述文件：供应链的可选描述；功能密钥：公钥，用于验证链路元数据签名；签名：使用项目所有者密钥创建的一个或多个布局签名；软件供应链步骤： 对应于专职人员作为软件供应链的一部分执行的步骤。布局中定义的步骤列出了有权限执行步骤的功能人员（通过键id）。步骤需要一个唯一的名称来将它们（在验证时）与专职人员使用in-toto工具执行步骤时创建的链接元数据相关联。此外，步骤必须具有物料和产品规则，这些规则定义了步骤应该操作的文件。检查： 定义验证过程中要运行的命令，还可以列出物料和产品规则。 4. 构件规则 软件供应链通常在一组文件上操作，例如源代码、可执行文件、包等。in-totos可调用这些文件。物料是在执行步骤或检查时使用的工件。同样，产品是执行步骤所产生的工件。
in-toto布局提供了一种简单的规则语言来授权或实施步骤的工件，并将它们链接在一起。这为任何给定的步骤或检查增加了以下保证：
只有项目所有者授权的工件才会被创建、修改或删除；每个定义的创建、修改和删除都被强制执行，并且也限制在其定义的范围内，该范围将后续步骤和检查链接在一起。 软件生产者可通过使用以下任一规则（通常是多个）授权、强制执行和链接物料和产品来适当保护其供应链：
CREATE &lt;pattern&gt; DELETE &lt;pattern&gt; MODIFY &lt;pattern&gt; ALLOW &lt;pattern&gt; DISALLOW &lt;pattern&gt; REQUIRE &lt;file&gt; MATCH &lt;pattern&gt; [IN &lt;source-path-prefix&gt;] WITH (MATERIALS|PRODUCTS) [IN &lt;destination-path-prefix&gt;] FROM &lt;step&gt; Note：默认情况下，in-toto的工件规则允许工件存在，前提是它们没有被明确禁止。因此，建议将DISALLOW*调用作为大多数步骤定义的最终规则。要了解有关不同规则类型、它们的保证以及如何应用它们的更多信息，请参阅https://github.com/in-toto/in-toto。
5. 优势 in-toto 是一个开源的供应链安全管理框架，旨在帮助组织确保其供应链的安全性和透明度，in-toto 框架具有以下优势：
透明度：in-toto 框架通过建立供应商与采购方之间的信任关系，实现供应链各环节的透明度。采购方可以实时了解供应商的安全状况，确保供应链的安全。
自动化：in-toto 框架支持自动化流程，可以快速地识别和管理供应链中的安全风险。通过与现有系统（如ERP系统）集成，可以实现供应链安全数据的自动收集和分析。
灵活性：in-toto 框架适用于各种规模和组织类型的企业，可以根据企业的具体需求进行定制和扩展。此外，in-toto 支持与多种安全标准和规范（如ISO 27001、NIST CSF等）相结合，为企业提供全面的安全管理方案。
持续改进：in-toto 框架通过持续监测和评估供应链的安全状况，推动供应链安全持续改进。企业可以根据评估结果，采取相应的措施加强供应链安全管理，降低安全风险。
开源：in-toto 框架开源，意味着企业可以免费使用和修改源代码，根据自身需求进行定制。这有助于降低企业的安全管理成本，提高供应链安全性。
合规性：in-toto 框架可以帮助企业满足各种法规和政策要求，如欧盟的《通用数据保护条例》（GDPR）、美国的《加州消费者隐私法》（CCPA）等。这有助于降低企业在合规方面的风险。
总之，in-toto 框架作为一种创新性的供应链安全管理工具，可以帮助企业提高供应链安全水平，降低风险，并确保合规性。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/12d85f2fa518a9382e4cb09be628a698/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/011122f4d9f0ea979a0cf2c473d65f97/" rel="bookmark">
			动态规划：完全背包问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本题力扣上没有，是刷的卡码网第52题52. 携带研究材料感兴趣的小伙伴可以去刷一下，是ACM模式。
题目： 题目描述：
小明是一位科学家，他需要参加一场重要的国际科学大会，以展示自己的最新研究成果。他需要带一些研究材料，但是他的行李箱空间有限。这些研究材料包括实验设备、文献资料和实验样本等等，它们各自占据不同的空间，并且具有不同的价值。
小明的行李空间为 N，问小明应该如何抉择，才能携带最大价值的研究材料，每种研究材料可以选择无数次，并且可以重复选择。
输入描述：
第一行包含两个整数，N，V，分别表示研究材料的种类和行李空间
接下来包含 N 行，每行两个整数 wi 和 vi，代表第 i 种研究材料的重量和价值
输出描述：
输出一个整数，表示最大价值。
输入示例：
4 5
1 2
2 4
3 4
4 5
输出示例：
10
提示信息：
第一种材料选择五次，可以达到最大值。
数据范围：
1 &lt;= N &lt;= 10000;
1 &lt;= V &lt;= 10000;
1 &lt;= wi, vi &lt;= 10^9.
思路： 完全背包 有N件物品和一个最多能背重量为W的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。每件物品都有无限个（也就是可以放入背包多次），求解将哪些物品装入背包里物品价值总和最大。
完全背包和01背包问题唯一不同的地方就是，每种物品有无限件。
在下面的讲解中，依然举这个例子：
背包最大重量为4。
物品为：
重量价值物品0115物品1320物品2430 每件商品都有无限个！
问背包能背的物品最大价值是多少？
01背包和完全背包唯一不同就是体现在遍历顺序上，所以本篇博客就不去做动规五部曲了，我们直接针对遍历顺序经行分析！（要先掌握01背包）
01背包问题详细请见动态规划：01背包问题(二)
首先再回顾一下01背包的核心代码：
for i in range(bag_nums): # 遍历每个物品 for j in range(bag_weight, weight[i] - 1, -1): # 从后往前遍历背包重量 dp[j] = max(dp[j], dp[j - weight[i]] + value[i]) # 更新当前背包重量对应的最大价值 我们知道01背包内层循环是从大到小遍历，为了保证每个物品仅被添加一次。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/011122f4d9f0ea979a0cf2c473d65f97/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f10b9586e83eec243d7f72f6e73b281/" rel="bookmark">
			Tailor the Quick Access Toolbar
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Tailor the Quick Access Toolbar Syncfusion Essential Studio WinUI 2023 Volume 4 allows users to customize their quick access toolbar directly through a convenient dialog.
Syncfusion Essential Studio WinUI, available as part of Syncfusion Essential Studio Enterprise, is a comprehensive toolkit for building high performance native Windows desktop applications. It offers tools for crafting modern UI elements like charts, data grids, and ribbon interfaces, alongside powerful editing tools for Word, Excel, and PDF documents.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7f10b9586e83eec243d7f72f6e73b281/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e2c4a8b1c73beaa9573f2b27834d0cc/" rel="bookmark">
			51单片机8*8点阵屏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		8*8点阵屏 8*8点阵屏是一种LED显示屏，它由8行和8列的LED灯组成。每个LED灯的开闭状态都可以独立控制，从而可以显示出数字、字母、符号、图形等信息。
8*8点阵屏的原理是通过行列扫描的方式，控制LED灯的亮灭，从而显示出所需的图案或信息。通过逐行逐列地控制LED的亮灭，就可以在屏幕上显示出任意的数字、字母和图形。
这种点阵屏通常被广泛应用于电子钟表、计时器、温度计、电子游戏等产品中，因为它可以以较小的尺寸显示出丰富的信息，而且功耗较低、制作成本相对较低。
点阵屏理论介绍
8*8点阵屏电路图
如何赋值点亮led灯：要使用动态扫描的方式点亮led灯防止出现同时点亮的情况
74HC595芯片的工作原理
8*8点阵屏原理图
74HC595芯片使用说明
eg1：点阵屏编程实战：点亮第一个点阵
#include &lt;REGX52.H&gt; sbit DIO = P3^4; // 串行数据口 sbit S_CLK = P3^5; //移位寄存器时钟 sbit R_CLK = P3^6; // 输出锁存器时钟 void main(){ // ROW : 0x80 ,COL : 0xfe 通过传入和并出的方式将数据发送出去 unsigned char i,dat; dat = 0xfe; for(i = 0; i&lt;8;i++){ S_CLK = 0; R_CLK = 0; if(dat &amp; 0x01){ DIO = 1; }else{ DIO = 0; } S_CLK = 1;	dat &gt;&gt;= 1; } dat = 0x80; for(i = 0; i&lt;8;i++){ S_CLK = 0; R_CLK = 0; if(dat &amp; 0x01){ DIO = 1; }else{ DIO = 0; } S_CLK = 1;	dat &gt;&gt;= 1; } R_CLK = 1; while(1); } eg2：点阵屏实战：显示汉字--&gt;电 字符
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8e2c4a8b1c73beaa9573f2b27834d0cc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b4f1c5dbc51ec9b6a795b40c643bfa0/" rel="bookmark">
			基于YOLOv8深度学习的102种花卉智能识别系统【python源码&#43;Pyqt5界面&#43;数据集&#43;训练代码】目标检测、深度学习实战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		《博主简介》
小伙伴们好，我是阿旭。专注于人工智能、AIGC、python、计算机视觉相关分享研究。
✌更多学习资源，可关注公-仲-hao:【阿旭算法与机器学习】，共同学习交流~
👍感谢小伙伴们点赞、关注！
《------往期经典推荐------》
一、AI应用软件开发实战专栏【链接】
项目名称项目名称1.【人脸识别与管理系统开发】2.【车牌识别与自动收费管理系统开发】3.【手势识别系统开发】4.【人脸面部活体检测系统开发】5.【图片风格快速迁移软件开发】6.【人脸表表情识别系统】7.【YOLOv8多目标识别与自动标注软件开发】8.【基于YOLOv8深度学习的行人跌倒检测系统】9.【基于YOLOv8深度学习的PCB板缺陷检测系统】10.【基于YOLOv8深度学习的生活垃圾分类目标检测系统】11.【基于YOLOv8深度学习的安全帽目标检测系统】12.【基于YOLOv8深度学习的120种犬类检测与识别系统】13.【基于YOLOv8深度学习的路面坑洞检测系统】14.【基于YOLOv8深度学习的火焰烟雾检测系统】15.【基于YOLOv8深度学习的钢材表面缺陷检测系统】16.【基于YOLOv8深度学习的舰船目标分类检测系统】17.【基于YOLOv8深度学习的西红柿成熟度检测系统】18.【基于YOLOv8深度学习的血细胞检测与计数系统】19.【基于YOLOv8深度学习的吸烟/抽烟行为检测系统】20.【基于YOLOv8深度学习的水稻害虫检测与识别系统】21.【基于YOLOv8深度学习的高精度车辆行人检测与计数系统】22.【基于YOLOv8深度学习的路面标志线检测与识别系统】23.【基于YOLOv8深度学习的智能小麦害虫检测识别系统】24.【基于YOLOv8深度学习的智能玉米害虫检测识别系统】25.【基于YOLOv8深度学习的200种鸟类智能检测与识别系统】26.【基于YOLOv8深度学习的45种交通标志智能检测与识别系统】27.【基于YOLOv8深度学习的人脸面部表情识别系统】28.【基于YOLOv8深度学习的苹果叶片病害智能诊断系统】29.【基于YOLOv8深度学习的智能肺炎诊断系统】30.【基于YOLOv8深度学习的葡萄簇目标检测系统】31.【基于YOLOv8深度学习的100种中草药智能识别系统】 二、机器学习实战专栏【链接】，已更新31期，欢迎关注，持续更新中~~
三、深度学习【Pytorch】专栏【链接】
四、【Stable Diffusion绘画系列】专栏【链接】
《------正文------》
基本功能演示 摘要：花卉智能识别系统可以准确识别102种不同的花卉类别。这项技术极大地简化了花卉识别的过程，提高了识别速度和准确性。此外，该系统也有助于促进花卉数据的收集和分析，在植物学教育和保护生物多样性方面发挥着关键作用。本文基于YOLOv8深度学习框架，通过8189张图片，训练了一个进行花卉的识别模型,可用于识别102种不同的花卉类型,准曲率高达97%。并基于此模型开发了一款带UI界面的花卉智能识别系统，可用于实时识别场景中的花卉类别，更方便进行功能的展示。该系统是基于python与PyQT5开发的，支持图片、批量图片、视频以及摄像头进行识别检测。本文提供了完整的Python代码和使用教程，给感兴趣的小伙伴参考学习，完整的代码资源文件获取方式见文末。
文章目录 基本功能演示前言一、软件核心功能介绍及效果演示软件主要功能（1）图片检测演示（2）视频检测演示（3）摄像头检测演示 二、模型的训练、评估与推理1.YOLOv8的基本原理2. 数据集准备与训练3.模型训练4. 训练结果评估5. 利用模型进行推理 【获取方式】结束语 点击跳转至文末《完整相关文件及源码》获取
前言 花卉智能识别系统基于强大的YOLOv8算法，可以准确识别102种不同的花卉类别。这项技术的发展对于园艺学、生态研究以及花卉爱好者而言都十分重要，它极大地简化了花卉识别的过程，提高了识别速度和准确性。此外，该系统也有助于促进花卉数据的收集和分析，在植物学教育和保护生物多样性方面发挥着关键作用。
花卉智能识别系统的应用场景主要包括：
园艺管理：园林工作者可以使用该系统快速识别园内花卉，高效管理园艺资源，促进植物健康和园林美化。
植物学研究：研究人员通过系统识别花卉品种，加快研究进展，减少人为识别错误，并有助于收集更多的种植分布数据。
生态环境监测：环境保护人员可以使用该系统对自然环境中的花卉进行监测和记录，有助于评估生态系统的多样性。
教育与科普：在教学活动中，该系统可以作为一个互动工具帮助学生和公众认识和学习不同的花卉，提高生物学知识普及。
植物园和博览会：为游客提供即时的植物信息查询服务，增强参观互动体验。
个人使用：花卉爱好者使用该系统可更深入地了解周围的花卉类型，培养植物兴趣。
总结而言，花卉智能识别系统的开发不仅能够推动园艺学的现代化，提供强有力的植物学研究工具，还能够在普及植物知识、生态环境保护等方面发挥显著作用。通过智能化的花卉识别，人们可以更加方便快捷地与自然世界互动，并享受园艺带来的乐趣。这一系统进一步证明了人工智能技术在日常生活中的广泛应用潜力和价值。
博主通过搜集不同花卉的相关数据图片并整理，根据YOLOv8的深度学习技术训练识别模型，并基于python与Pyqt5开发了一款界面简洁的102种花卉智能识别系统，可支持图片、批量图片、视频以及摄像头检测。
软件初始界面如下图所示：
检测结果界面如下：
一、软件核心功能介绍及效果演示 软件主要功能 1. 可进行102种不同花卉的识别;
2. 支持图片、批量图片、视频以及摄像头检测；
3. 界面可实时显示识别结果、置信度、用时等信息;
（1）图片检测演示 单个图片检测操作如下：
点击打开图片按钮，选择需要检测的图片，就会显示检测结果。操作演示如下：
批量图片检测操作如下：
点击打开文件夹按钮，选择需要检测的文件夹【注意是选择文件夹】，可进行批量图片检测，表格中会有所有图片的检测结果信息，点击表格中的指定行，会显示指定行图片的检测结果，双击路径单元格，会看到图片的完整路径。操作演示如下：
（2）视频检测演示 点击打开视频按钮，打开选择需要检测的视频，就会自动显示检测结果。
（3）摄像头检测演示 点击打开摄像头按钮，可以打开摄像头，可以实时进行检测，再次点击摄像头按钮，可关闭摄像头。
二、模型的训练、评估与推理 1.YOLOv8的基本原理 YOLOv8是一种前沿的检测与识别技术，它基于先前YOLO版本在目标检测与识别任务上的成功，进一步提升了性能和灵活性。主要的创新点包括一个新的骨干网络、一个新的 Ancher-Free 检测头和一个新的损失函数，可以在从 CPU 到 GPU 的各种硬件平台上运行。
其主要网络结构如下：
2. 数据集准备与训练 本文使用的花卉数据集共包含8189张图片，分为102个花卉类别。部分数据集及类别信息如下：
图片数据集的存放格式如下，在项目目录中新建datasets目录，同时将分类的图片分为训练集与验证集放入Data目录下。
3.模型训练 数据准备完成后，通过调用train.py文件进行模型训练，epochs参数用于调整训练的轮数，batch参数用于调整训练的批次大小【根据内存大小调整，最小为1】，代码如下：
#coding:utf-8 from ultralytics import YOLO # 加载预训练模型 model = YOLO("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7b4f1c5dbc51ec9b6a795b40c643bfa0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/721e70d282d73e81f02ba631add95cf0/" rel="bookmark">
			数据结构之二叉树的性质与存储结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据结构之二叉树的性质与存储结构 1、二叉树的性质2、二叉树的存储结构 数据结构是程序设计的重要基础，它所讨论的内容和技术对从事软件项目的开发有重要作用。学习数据结构要达到的目标是学会从问题出发，分析和研究计算机加工的数据的特性，以便为应用所涉及的数据选择适当的逻辑结构、存储结构及其相应的操作方法，为提高利用计算机解决问题的效率服务。 数据结构是指数据元素的集合及元素间的相互关系和构造方法。元素之间的相互关系是数据的 逻辑结构，数据元素及元素之间关系的存储称为 存储结构(或物理结构)。数据结构按照逻辑关系的不同分为 线性结构和 非线性结构两大类，其中，非线性结构又可分为树结构和图结构。 树结构是一种非常重要的非线性结构，该结构中的一个数据元素可以有两个或两个以上的直接后继元素，树可以用来描述客观世界中广泛存在的层次结构关系。 二叉树是 n(n≥0)个结点的有限集合，它或者是空树(n=0)，或者是由一个根结点及两棵不相交的且分别称为左、右子树的二叉树所组成。可见，二叉树具有递归性质。 1、二叉树的性质 （1）二叉树第 i 层(i≥1)上最多有 2i-1 个结点。
（2）高度为 k 的二叉树最多有 2k-1 个结点 (k≥1)。
由性质 1，每一层的结点数都取最大值 Σ i = 1 k 2 i − 1 = 2 k − 1 {\huge\Sigma}^k_{i=1}2^{i-1} = 2^k-1 Σi=1k​2i−1=2k−1 即可。
（3）对于任何一棵二叉树，若其终端结点数为 n0，度为2的结点数为 n2，则n0=n2+1。
（4）具有n 个结点的完全二叉树的深度为[log2n]+1。
若深度为 k 的二叉树有 2k-1 个结点，则称其为满二叉树。可以对满二叉树中的结点进行连续编号： 约定编号从根结点起，自上而下、自左至右依次进行。深度为 k、有 n 个结点的二叉树，当且仅当其每一个结点都与深度为 k 的满二叉树中编号从1至n 的结点一一对应时，称之为完全二叉树。满二叉树如下图 (a)所示，高度为 3 的一个完全二叉树如下图 (b) 所示。
在一个高度为 h 的完全二叉树中，除了第 h 层（即最后一层），其余各层都是满的。在第 h 层上的结点必须从左到右依次放置，不能留空。下图 © 所示的二叉树不是完全二叉树，因为 6号结点的左边有空结点。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/721e70d282d73e81f02ba631add95cf0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2516a7b00daf5a1eb3a55d4b061d9e4/" rel="bookmark">
			浪花 - 主页性能优化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、缓存
1. 为什么用缓存？
2. 缓存的实现方式
3. Redis
4. 使用 Spring Data Redis 中操作 Redis
5. 自定义 RedisTemplate（配置）
6. 主页推荐用户查询使用缓存
7. 对比查询速度
8. 缓存预热
二、定时任务
1. Spring Scheduler
2. 其他
一、缓存 1. 为什么用缓存？ 数据量大查询慢，用缓存先读取部分数据保存到读写性能更快的介质中（比如内存） 2. 缓存的实现方式 分布式缓存：Redis、Memcache 等单机缓存：Ehcache、Caffeine（Java 内存缓存，高性能）、Google Guava单机缓存的缺点：数据不一致 3. Redis Remote Dictionary Server（远程词典服务器）基于内存的高性能 NoSQL 数据库key - value 存储系统Redis 的数据结构：String、Set、Map、Hash、SortedSet 4. 使用 Spring Data Redis 中操作 Redis Spring Data：通用数据访问框架，定义了一组增删改查的框架，包括对操作各种数据库的集成使用步骤参考：浪花 - 单机登录升级为分布式 Session 登录-CSDN博客 SpringDataRedis 快速入门
引入 spring-boot-starter-data-redis 依赖application.yml 配置 Redis 信息注入 RedisTemplate 调用方法操作 Redis 数据库调用 redisTemplate 中的 API 获取操作指定数据类型的对象 optForValue()String Redis Template 手动序列化将数据存入 Redis取出数据手动反序列化 /** * Redis 操作测试 * @author 乐小鑫 * @version 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d2516a7b00daf5a1eb3a55d4b061d9e4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be88185b7a58ca7ca47c6b8ab0ce0874/" rel="bookmark">
			linux的vsftpd服务（基础小白必学）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		linux的vsftpd服务 文章目录 linux的vsftpd服务一、FTP介绍二、应用场景三、FTP的权限四、FTP的工作模式五、FTP安装部署六、FTP配置文件6.1）相关文件6.2）主配文件详解 七、FTP客户端访问7.1）文本界面登陆7.2）FTP客户端常用命令 八、基于虚拟用户配置安全的ftp 一、FTP介绍 FTP (File transfer protocol) 是TCP/IP 协议组中的协议之一。他最主要的功能是在服务器与客户端之间进行文件的传输。FTP就是实现两台计算机之间的拷贝，从远程计算机拷贝文件至自己的计算机上，称之为“下载 （download）”文件。将文件从自己计算机中拷贝至远程计算机上，则称之为“上传（upload）”文件。这个古老的协议使用的是明码传输方式，且过去有相当多的安全危机历史。为了更安全的使用 FTP 协议，我们主要介绍较为安全但功能较少的 vsftpd(very secure File transfer protocol ) 这个软件。FTP是一个C/S类型的软件，FTP监听TCP端口号为21，数据端口为20。
二、应用场景 下载服务器：提供对外的下载服务
文件服务器：提供上传和下载服务
三、FTP的权限 FTP 服务器的功能除了单纯的进行文件的传输与管理之外，依据服务器软件的设定架构，它还可以提供几个主要的功能。：
不同等级的用户身份：user, guest, anonymous
FTP 服务器在默认的情况下，依据使用者登录的情况而分为三种不同的身份，分别是：
(1)本地用户：系统中真实存在的用户
(2)来宾, guest；
(3)匿名登录者, anonymous
这三种身份的用户在系统上面的权限差异很大！例如实体用户取得系统的权限比较完整， 所以可以进行比较多的动作；至于匿名登录者，大概我们就仅提供他下载资源的能力而已，并不许匿名者使用太多主机的资源！ 当然，这三种人物因为权限的不同能够使用的【在线命令】自然也就不相同！
四、FTP的工作模式 FTP支持两种模式，一种方式叫做Standard (也就是 PORT方式，主动方式)，一种是 Passive (也就是PASV，被动方式)。 Standard模式 FTP的客户端发送 PORT 命令到FTP服务器。Passive模式FTP的客户端发送 PASV命令到 FTP Server。
下面介绍一个这两种方式的工作原理：
Port模式FTP 客户端首先和FTP服务器的TCP 21端口建立连接，通过这个通道发送命令，客户端需要接收数据的时候在这个通道上发送PORT命令。 PORT命令包含了客户端用什么端口接收数据。在传送数据的时候，服务器端通过自己的TCP 20端口连接至客户端的指定端口发送数据。 FTP server必须和客户端建立一个新的连接用来传送数据。
Passive模式在建立控制通道的时候和Standard模式类似，但建立连接后发送的不是Port命令，而是Pasv命令。FTP服务器收到Pasv命令后，随机打开一个高端端口（端口号大于1024）并且通知客户端在这个端口上传送数据的请求，客户端连接FTP服务器此端口，然后FTP服务器将通过这个端口进行数据的传送，这个时候FTP server不再需要建立一个新的和客户端之间的连接。
很多防火墙在设置的时候都是不允许接受外部发起的连接的，所以许多位于防火墙后或内网的FTP服务器不支持PASV模式，因为客户端无法穿过防火墙打开FTP服务器的高端端口；而许多内网的客户端不能用PORT模式登陆FTP服务器，因为从服务器的TCP 20无法和内部网络的客户端建立一个新的连接，造成无法工作。
五、FTP安装部署 约定：本实验中使用过的机器为centos8.0_x86_64系统，IP地址192.168.11.16/24.请关闭防火墙和SELINUX。
vsftp安装 [root@localhost ~]# dnf -y install vsftpd ftp vsftp开机启动 [root@localhost ~]# systemctl enable vsftpd Created symlink from /etc/systemd/system/multi-user.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/be88185b7a58ca7ca47c6b8ab0ce0874/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9066c7a5f1f1f4304bfcbcf6398d6556/" rel="bookmark">
			Spring成长之路—Spring MVC
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在分享SpringMVC之前，我们先对MVC有个基本的了解。MVC(Model-View-Controller)指的是一种软件思想，它将软件分为三层：模型层、视图层、控制层
模型层即Model：负责处理具体的业务和封装实体类，我们所知的service层、pojo都属于模型层
视图层即view：它是前端的交互页面，也就是用户可以直观看到的东西，例如登录界面，商城界面
控制层即Controller：它负责接收请求的接收和分发，将请求分发给指定的业务逻辑
1、什么是Spring MVC 简单来说，SpringMVC是Spring对MVC设计思想的一种实现，实现的一个用于接收Web请求，响应请求的模块，其简易架构如图所示：
其中，核心组件及其作用如下：
DispatcherServlet：前端控制器，不需要开发，由MVC框架提供
作用：统一处理请求和响应，整个流程控制的中心，由它调用其它组件处理用户的请求，相当于是一个中转站的功能，将请求发给其他组件前必须要经由它
HandlerMapping：处理器映射器，不需要开发，由框架提供
作用：根据请求的url、method等信息查找Handler，即控制器方法
Handler：处理器，需要工程师开发，就是Controller
作用：在DispatcherServlet的控制下Handler对具体的用户请求进行处理
HandlerAdapter：处理器适配器，不需要开发，由框架提供
作用：通过HandlerAdapter对处理器（控制器方法）进行执行
HandlerInterceptor：拦截器, 需要工程师开发
作用：实现请求响应的共性处理
ViewResolver：视图解析器(前缀+viewname+后缀)，不需要工程师开发，由框架提供
作用：进行视图解析，得到相应的视图，例如：ThymeleafView、InternalResourceView、RedirectView
View：视图
作用：将模型数据通过页面展示给用户。
当前端发送一个请求后(请求即一个url路径)，会先到达MVC过滤器，通过过滤器筛选后，通过的请求接下来会来到DispatcherServlet开始请求的分发，在分发之前它会先和HandlerMapping进行交互，HandlerMapping会判断请求路径中url是否有对应的的Controller可以进行处理，如果有，则将该信息返回给DispatcherServlet后由它来调用对应的Controller处理请求，在调用Controller之前，请求还会经过一个HandlerInterceptor拦截器(拦截器功能和过滤器相似)，在拦截器中就可以进行一些控制用户的访问操作；Controller接收请求后调用该请求所对应的Service业务以及数据库，数据库返回数据后再将该返回的数据逐层返回至前端，返回的数据即为服务器的responce(响应)。
2、SpringMVC运行流程详解图：(面试可能会用到) 3、SpringBoot 整合MVC依赖 添加spring-web依赖，该框架提供了Spring MVC依赖支持，由于Spring boot Web的核心是SpringMVC，所以Spring基础框架的所有功能都适用与Spring boot Web，例如组件扫描、自动装配等
&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; 4、SpringMVC——RESTful RestFul是一种以网络为基础构架一种架构风格，是一组架构约束条件和原则，不是标准，不是规范。” 如果一个架构符合REST的约束条件和原则，我们就称它为RESTful架构 REST原则： ①URI代表着一个资源，是一个实体，应该是名词，而不要把具体的动作放在URL中，对资源的操作应该通过HTTP的动词来实现
传统方式操作资源，我们都是例如(修改和删除类似)：
http://localhost:8080/admin/getUser 表示查询操作
http://localhost:8080/admin/addUser 表示新增操作
使用REST风格之后，使用如下命令(修改和删除类似)：
GET http://localhost:8080/admin/user 表示查询操作
POST http://localhost:8080/admin/user 表示新增操作
②使用适合的状态码，而不应该全部都返回状态码 200
常用状态码：
`200 – OK – 一切正常
`201 – OK – 新的资源已经成功创建
`204 – OK – 资源已经成功删除
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9066c7a5f1f1f4304bfcbcf6398d6556/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb0aa1c44fd7eb44059995f8b50536a4/" rel="bookmark">
			[RocketMQ错误]Caused by: org.apache.rocketmq.remoting.exception.RemotingConnectException: connect to ＜
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/096f3a9658c81b99c91488a95ac3a504/" rel="bookmark">
			CSS：backdrop-filter实现毛玻璃的效果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 实现效果
实现代码
/* 关键属性 */ background-color: rgba(255, 255, 255, 0.4); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px); 完整代码
&lt;style&gt; /* 遮罩层 */ .mo-mask { position: fixed; top: 0; bottom: 0; left: 0; right: 0; width: 100%; height: 100%; background-color: #1e80ff; } .mo-dialog { border-radius: 16px; height: 400px; width: 600px; margin: 100px auto; /* 关键属性 */ background-color: rgba(255, 255, 255, 0.4); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px); } &lt;/style&gt; &lt;div class="mo-mask"&gt; &lt;div class="mo-dialog"&gt;&lt;/div&gt; &lt;/div&gt; 参考文章 前端笔记 - 【CSS】 - filter 于 backdrop-filter 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5fd4b207ba91ccf26c92bec49210bfb/" rel="bookmark">
			多头与空头：金融市场中的看涨和看跌
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在金融市场中，多头和空头是两个重要的概念。它们分别代表投资者对于某种金融产品的看涨和看跌态度。多头表示看涨，而空头则表示看跌。下面，我们将更详细地介绍多头和空头的概念，并通过举例来说明。
一、多头（Bull） 多头是指一种市场上希望资产价格上涨的投资策略或投资者。多头支持市场上涨，因为他们相信资产的价格将会上涨。多头投资者购买资产（如股票、货币、商品等），并期望在未来升值后进行出售获利。多头行情通常与买进交易相关联。
以生活中的例子来说明：
假设你是一位投资者，你认为未来猪肉价格将会上涨，并想要从中赚取利润。如果你采取多头策略，你可以通过以下方式来实现投资：
首先，你借钱购买猪肉。然后，你等待市场上涨，等到你预期的价格高点时，就以较高的价格卖出猪肉，从而获得收益。
例如，你在市场上看到猪肉价格目前为每公斤10元，但你预计未来它将上涨到每公斤15元。因此，你花费1000元购买了100公斤猪肉，然后等待市场上涨。当价格上涨到15元时，你将猪肉卖出，获得了500元的利润。
另外，如果一个投资者相信某只股票市场前景良好，并购买该股票，那么如果这只股票价格上涨，投资者将会受益。如果该投资者预计在未来市场上涨，但当前价格过高，他可能会选择通过购买看涨期权来实现收益。这种情况下，投资者仍然会从市场上涨获得收益，但风险更小。
二、空头（Bear） 空头是一种市场上希望资产价格下跌的投资策略或投资者。空头投资者倾向于卖出资产，因为他们相信资产的价格将下跌。空头行情通常与卖出交易相关联。
以生活中的例子来说明：
假设你是一位投资者，你认为未来猪肉价格将会下跌，并想要从中赚取利润。如果你采取空头策略，你可以通过以下方式来实现投资：
首先，你卖出猪肉（即赌价值下降），等待价格下跌后再以更低的价格买入猪肉，从而获得收益。
例如，你在市场上看到猪肉价格目前为每公斤10元，但你认为未来它将下跌到每公斤5元。因此，你从养猪场借来100公斤的猪肉，然后卖出它们，获得了1000元的现金。等到价格下跌到5元时，你再以较低的价格从市场上买入100公斤猪肉，然后将它们归还给养猪场。这样，你就能够获得500元的利润。
另外，如果一个投资者相信某只股票市场前景不佳，并卖出该股票，那么如果这只股票价格下跌，投资者将会受益。如果该投资者预计在未来市场下跌，但当前价格过高，他可能会选择通过购买看跌期权来实现收益。这种情况下，投资者仍然会从市场下跌获得收益，但风险更小。
总结
多头和空头是金融市场中两个重要概念，分别代表看涨和看跌态势。投资者可以根据不同市场变化选择多头或空头策略来获取收益。因此，在进行投资决策时，需要通过深入分析市场情况来判断多头或空头是否适合。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a27493b61144ce46ea31aba07561065/" rel="bookmark">
			MySQL之索引结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		索引概述 索引是帮助MySQL高效获取数据的数据结构（有序）。
在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引。
下图演示有索引和无索引的区别：
备注：上述二叉树索引结构的只是一个示意图，并不是真实的索引结构
优缺点 优势：
1、提高数据检索的效率，降低数据库的I/O成本。
2、通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗。
劣势（基本忽略）：
1、索引列也是要占用空间的（但是现在磁盘很便宜）
2、索引大大提高了查询效率，同时也降低了更新表的速度，如对表进行插入、删除、更新时，效率降低。
索引结构 MYSQL的索引是在存储引擎层实现的，不同的存储引擎有不同的索引结构主要包含以下几种：
索引结构 描述
B+Tree索引最常见的索引类型，大部分引擎都支持B+树索引Hash索引底层数据结构是用哈希表实现的，只有精确匹配索引列的查询才生效，不支持范围查询R-tree（空间索引）空间索引是MYISAM引擎的一个特殊索引类型，用于地理空间数据类型，通常使用比较少Full-text（全文索引）是一种通过建立倒排索引，快速匹配文档的方式 B+Tree索引 二叉树 左边的节点的值比父节点值小，右边节点的值比父节点值大
二叉树缺点：顺序插入时，会形成一个链表，查询性能大大降低。在大多数情况下层级较深检索速度慢。
红黑二叉树（自平衡二叉搜索树） 红黑树是一种高效的自平衡二叉查找树，用于存储有序的数据，并在插入和删除操作时能够快速地进行调整以保持其性质。
B-Tree树（多路平衡查找树） 以一颗最大数（max-degree）为5（5阶）的b-tree为例（每个节点最多存储4个key，5个指针）
注意：树的度数指的是一个节点的子节点个数。
插入：100 65 169 368 900 556 780 35 215 1200 134 888 158 90 1000 88 120 268 250
具体动态变化过程参考网站：https://www.cs.usfca.edu/~galles/visualization/BTree.html
B+Tree树 插入：100 65 169 368 900 556 780 35 215 1200 234 888 158 90 1000 88 120 268 250
动态变化过程参考网站：https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html
相较于B-Tree区别： 1、所有数据都会出现在叶子节点
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8a27493b61144ce46ea31aba07561065/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/884c65808f24447f63045761a8f980a2/" rel="bookmark">
			Android逆向之实战逆向APP
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言逆向目标环境准备 开始逆向之旅抓包寻找解压密码so库逆向解压密码生成函数 总结 前言 Android逆向之指令集和CPU架构
Android逆向之必备前置知识
经过前2篇逆向前置知识的铺垫之后，我们终于要开始逆向实操了。以下操作主要是体现一下逆向的流程以及实操，为了安全考虑，并不会直接给出APP名称。
从目标出发，一步步去完成我们的目标，回头再看，大家就会发现，不过如此罢了。
逆向目标 获取APP中的某个功能，例如点击加载模型，模型会自带一些事件触发逻辑。博主的目的是拿到这部分事件逻辑的代码，参考一下。
例如下图的加载模型。
环境准备 安装有linux系统的电脑，此处以manjaro linux 23.1.0-1为例。安装有某APP的手机，此处以iPhone 13为例。linux系统上安装以下程序。 大家可以看到，安装的程序都是我们前置知识里面提过的，是必不可少的工具。 sudo pacman -Sy binutils python jadx radare2 sudo pip install mitmproxy 确保电脑和手机处于同一个网络，方便抓包操作。 开始逆向之旅 抓包 💻 在终端执行mitmweb命令, 此时会在默认浏览器中打开一个新的标签页，如下所示: 📱 在设置-&gt;无线局域网，点击已经连接的Wifi名称右边的编辑按钮，如下所示: 📱 在进入Wifi编译页之后，滚动到页面最下方，点击配置代理，选择手动，之后在出现的服务器输入框中输入电脑的IP地址,** 端口输入框中填写8080**，点击存储，如下所示: 📱 在默认浏览器中，此处为Safari, 打开 http://mitm.it, 滚动页面到对应平台处，此处为iOS, 按照页面提示的步骤，安装mitmproxy需要的CA证书，如下所示: 📱 打开 某 App，点击一个没有下载过的模型，触发下载，如下所示: 💻 在mitmweb打开的浏览器标签页，分析抓到的包列表，注意到有一个下载zip的请求，猜测是该模型对应的资源文件，如下所示: 💻 在终端执行以下命令，下载zip文件: wget http://cdn3.cooolar.com/model/b/e/5/5c6a65be57f782510b26bdb4/ios_192/5c6a65be57f782510b26bdb4.zip 💻 在终端执行以下命令，解压zip文件: unzip 5c6a65be57f782510b26bdb4.zip 提示需要输入解压密码，如下所示，这似乎进一步证实该zip包就是我们需要的模型资源文件。
接下来我们需要找到该zip包解压需要的密码。
寻找解压密码 💻 下载网址可以自己在网上找，当星网-绿色软件_最新绿色下载软件_免费软件下载网站 - 当星网这个网址可以下载到部分的APK文件。下载某APP的APK, 保存为 magicxx.apk。💻** **终端执行以下命令，解压出APK相应的资源文件和Java源码: 还记得吗，就是我们前置知识中说的jadx反编译工具 jadx -d magicxx magicxx.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/884c65808f24447f63045761a8f980a2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ffaa87f6275ee97fe6ce3b3293af4fc/" rel="bookmark">
			Qt 5.15.2 (MSVC 2019）编译 QWT 6.2.0 : 编译MingW或MSVC遇到的坑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MingW下编译QWt 6.2.0 下载qwt最新版本，用git工具 git clone下载源码
git clone https://git.code.sf.net/p/qwt/git qwt-git
或者使用我下载的 qwt 2.6.0
链接：https://pan.baidu.com/s/1KZI-L10N90TJobeqqPYBqw?pwd=pq1o
提取码：pq1o
下载安装Qt 5.15.2
链接：https://pan.baidu.com/s/1mpcVYjzjL0udYAh0TGjtrA?pwd=2sz5
提取码：2sz5
用Qt 5.15.2 自带的Qt Creator 5.0.2打开qwt.pro文件
编译前的参数修改（网上一找一大把）
打开QMAKE_RPATHDIR *=$${QWT_INSTALL_LIBS}
注释掉src/qwtbuild下的qwtbuild.pri里的CONFIG += debug_and_release
因为你的工程要链接的第三方库肯定是release版本的库了
classinclude下的qwtbuil下的qwtbuild.pri里的 CONFIG += debug_and_release也是要注释掉#
编译MSVC会编译不通过的原因，本质原因应该不是修改一个安装目录就可以了（以后来研究），把qwtconfig.pri下的QWT_INSTALL_PREFIX路径修改成自己Qt安装使用的编译器下的路径里的include里新建自己的qwt头文件目录（qwtbuld.pri和qwtconfig.pro虽然有多个，其实点进去就知道都是同一个，修改一处就都修改了）
编译的顺序是先【执行qmake】，然后开始【构建】
需要选择release版本，在构建里选择Release
qmake完成，及构建完成后，会在构建目录下生成编译文件xx.dll和xx.a文件
将qwt.dll和qwtd.dll放到本地的Qt 5.12.12安装目录的库目录中，这样基于Qt 5.12.12的自己的应用就可以使用qwt开发了，因为安装了qwt库
qwt的编译里还生成了designer.dll，如果将该designer.dll放到本地Qt 5.12.12的安装目录的designer插件中，那么在Qt开发中的designer里可以直接拖动使用qwt控件，那也是非常方便的。
放到本地Qt的designer插件目录中
用Qt Creator新建自己的应用程序，用Qt Designer打开mainwindow.ui
在Qt设计师中左侧控件拉到最下面看到qwt控件，此处你可以兴奋一分钟，将qwt控件拖动到右边，然后保存，然后qmake你的工程，构建并运行，就把qwt安装并运行到了你的个人Qt工程中了
MSVC 下编译QWT 6.2.0 说实话在MingW下载编译qwt是比较智障无难度的，因为Qt的安装过程中会把MingW编译器一起安装了，所以在Qt构建工具中MingW编译器的选择也十分简单，一般不会出错，但是MSVC编译器是随着Visual Studio (VS2022 VS2017)安装的，所以Qt的构建工具中经常是默认的MSVC版本的项目构建是黄色感叹号，没法直接使用其新建Qt MSVC工程，所以如果你的Qt工具里Qt MSVC构建都还没有配置好，然后你用Qt Creator打开qwt.pro去编译MSVC版本的库，会遇到编译问题，所以先解决Qt构建问题。
我安装的是VS2022，所以编译器是MSVC2017，但是Qt构建里默认MSVC2017无法使用，cmake也是无法使用。
我的图片中MSVC2015 64bit编译可以构建那个纯粹是扯淡，因为我清楚我的本机是VS2022 MSVC2017不可能是MSVC2015，即便选择了MSVC2015，最后工程还是带黄色感叹哈，所以在编译器里进行配置这个克隆的方法也是网上一抓一大把，其实原因很明显我就死死咬住我是MSVC2017就不会出错了
如果你选择C++里或C里列出的C++ Complier或C Complier会出问题，因为其实他们是MSVC2005，错得离谱，所以选中一个编译器然后点击右边的克隆
ABI里面选择自定义，然后MSVC2005就可以选择了，肯定是果断选择自己VS对应的编译器，我的是MSVC2017
确定OK之后，在Qt Creator新建项目，选择克隆的编译器的构建就可以创建你本机的MSVC版本Qt项目了。回到编译qwt的MSVC版本，在构建的过程中可以看到是否是真正使用自己的编译器进行构建
像我的构建里是MSVC 64bit，所以qmake和构建就没有再报错。MSVC2017里把qwt的库，放到本地对应目录中
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9ffaa87f6275ee97fe6ce3b3293af4fc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/104c4563153a6f4fc299a462db63f846/" rel="bookmark">
			24岁总结和展望
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这一年，发生了很多事。和导师，论文之间的妥协，对于游戏行业的新的认识和自我职业道路的新的规划，还有就是遇到了小周。
和导师，课题之间的事情我认为一个让我看到这个社会运行规律和人与人之间关系本质的一个预告。无奈但是不得不接受这个规则。
对于游戏行业的认识也让我觉得与其追寻什么华而不实的title与否，不如去实实在在地去追寻自我的实现和喜欢。
遇见小周是一件很机缘巧合地事情，我也很好奇新的故事会怎么发生。
这一年，还遇到了黄老师，一个很好很好的领导。
这一年，静下心来感受寂静的时间的时候少了，到处看看走走的时间少了，探索世界就跟探索内心一样没有多少变化。所以感觉遇到小周是一件很幸运的事情。感觉她既有体验外部世界的动力和好奇心，也给予了我很多自我反思和执行的空间，也期望能一起成长。
新的一年，继续努力吧。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9664775db76b7b93597151025c66b1b9/" rel="bookmark">
			温度采样【通道选通】S9KEAZ128的PTA2和PTA3引脚无法拉高
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、问题记录：由18串温度采样修改成32串温度采样，增加一路adc采样，通过cd4051控制通道选通，代码中增加了相应的代码，发现增加的最后8路温度不能够控制，以24串为例，给温度传感器增加温度，相应的采集的温度信息并没有发生变化。
2、查找问题：
首先对24串的温度传感器加热，但是转出来的温度数据并没有变化，由于温度数据是通过采集的电压数据转换出来的，所以我们需要用万用表测量实际采样的电压，发现采样电压并没有发生变化。
接着我们判断是什么原因导致的电压没有发生变化，通过程序进入到dugger模式，停在相应的通道选通中，判断通道选通是否正常；
最后通过对比24串温度对应的通道选通的引脚的高低电平是否正常，发现引脚的高低电平与实际代码中设置的不一样，通过下述代码，对引脚进行强制拉高，发现PTD2能拉高，PTA2和PTA3无法拉高；
下面是原理图部分，可以发现PTA3和PTA2都是复用IO，都可以作为IIC通信的时钟和数据线，考虑是否代码中占用了这部分IO，经过查看并不是这个原因。
3、问题解决
通过查看网上资料，问题得以解决。主要是由开漏引脚造成的。
3.1问题描述
客户通过软件配置PTA2和PTA3为高电平输出时，使用万用表测量时发现实际电压是低电平；
3.2问题分析
PTA2和PTA3是真实的开漏输出引脚，内部是钳位到VSS的，其他非电源引脚内部钳制在VDD和VSS之间，如下图所示：
3.3解决措施
外部增加一个4.7K的上拉电阻即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b46d8918ff208e13d950d3977e47e5c/" rel="bookmark">
			帮助路人写代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		虽然不是粉丝但作为好心人我相信他看了我这篇博文，会成为我的粉丝
#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt; int main() { int distance, speed; printf("欢迎来到地铁跑酷游戏！\n"); printf("请输入距离（100-500）："); scanf("%d", &amp;distance); if (distance &lt; 100 || distance &gt; 500) { printf("输入的距离无效！\n"); return 0; } printf("请输入速度（1-5）："); scanf("%d", &amp;speed); if (speed &lt; 1 || speed &gt; 5) { printf("输入的速度无效！\n"); return 0; } srand(time(NULL)); // 随机数种子初始化 int obstacle = rand() % 3 + 1; // 随机生成障碍物个数（1-3个） for (int i = 0; i &lt; distance; i++) { if (i &lt; obstacle) { // 遇到障碍物时，游戏结束并输出得分 printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0b46d8918ff208e13d950d3977e47e5c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0cfd4f4c443ad01dcaf4efd685e2cfb/" rel="bookmark">
			产品经理学习-用户运营和用户分层模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录什么是用户运营用户运营三大工作体系用户分层模型-AARRR介绍 什么是用户运营 定义：用户运营就是搭建用户运营体系，围绕用户来做一系列的产品运营机制，提升太湖的活跃和留存，最终让用户进行付费。
例如小红书就是建立了用户运营机制，根据太湖不同的喜好进行精准内容推荐，明星推荐等手段刺激用户的欲望，最后让用户付费。
用户运营是为用户服务，用户运营需要传递产品核心价值给用户，从而用户可以通过产品得到他们想要的东西，为了更好的服务用户，用户运营也要为产品服务，给产品提供优化迭代的需求，从而产品可以赋能用户运营
用户运营工作流程 用户运营工作是测试——优化不断的循环，从不断的测试中提升运营的效果。
运营方法有哪些？
简单来说：活动、精准推荐、积分奖励等都是运营方法
业务逻辑分析 为什么要分析业务？如果不懂业务，懂得运营方法有哪些也不能精准的使用运营手段来实现目标。
先了解企业是靠什么盈利的，比如网易云音乐：
收入来自会员付费+商城+广告
会员付费： 网易云业务逻辑：
如上图：网易云的业务逻辑中平台给消费费用户提供平台音乐资源，消费用户从平台获取资源进行消费，平台给创作用户提供报酬，和成长平台；创作用户产出优质内容消费用户对这部分内容进行评论点赞，反过来创作用户UGC作品的质量反馈也会展示给消费用户。
用户运营三大工作体系 用户分层体系用户生命周期体系用户成长体系 用户分层体系 按照不同用户的价值、用户角色、喜欢等进行划分，通过定义用户角色针对不同用户做不同的运营策略。
用户从第一次接触产品到最后放弃使用产品的时间周期，通过用户生命周期体系，延长用户的生命周期，让用户在产品使用期间贡献更大的价值。
用户成长体系 搭建用户激励通道，设置成长奖励驱动用户成长
做用户分层就是为了针对不同的用户做不同的运营策略
用户分层模型AARRR介绍 Acquisition 获取用户
获取用户，我们怎么触达用
Activation 提高激活
提供活跃度，给用户带来更好的体验
Retention 提高留存
提高留存率，让用户持续使用
Revenue提升收入
获取收入、创造更多价值
Refer 自传播
如何让用户自发传播给别人
小红书如何获取用户： 应用商店 APPstore 、应用宝、华为应用市场
营销事件 策划利用具有新闻价值、社会影响以及名人效应的人或事物。来提升产品的知名度和品牌形象
异业合作 2个或2个以上不同的行业进行合作，实现双赢
站内相互导流 同一个公司不同产品相互导流（支付宝给饿了么引进用户）
老带新 通过老用户传播带来新用户
新媒体 通过新每天的渠道获取客户
如何激活用户 促销（新用户专享、优惠券、限时促销、秒杀） 促销活动，以优惠的价格吸引用户
活动（主题活动） 以主题或专题的形式专门吸引某一类用户
签到 坚持签到获取奖励
新手任务 通过新手任务让用户快速了解并使用产品
精准推荐 针对不同的用户做精准的产品推荐
消息推送 主动将最新的消息推送给用户，让用户通过消息推送使用产品
用户留存的方法： 活动（促销、主题、节假日等） 促销活动、以优惠的价格吸引用户
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f0cfd4f4c443ad01dcaf4efd685e2cfb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fffde3d4db519c6cf577a1d6e4af7cbc/" rel="bookmark">
			14：00面试，14：06就出来了，问的问题有点变态。。。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		从小厂出来，没想到在另一家公司又寄了。
到这家公司开始上班，加班是每天必不可少的，看在钱给的比较多的份上，就不太计较了。没想到5月一纸通知，所有人不准加班，加班费不仅没有了，薪资还要降40%,这下搞的饭都吃不起了。
还在有个朋友内推我去了一家互联网公司，兴冲冲见面试官，没想到一道题把我给问死了：
如果模块请求http改为了https,测试方案应该如何制定，修改?
感觉好简单的题，硬是没有答出来，早知道好好看看一大佬软件测试面试宝典了。
通过大数据总结发现，其实软件测试岗的面试都是差不多的。常问的有下面这几块知识点：
全网首发-涵盖16个技术栈 第一部分，测试理论（测试基础+需求分析+测试模型+测试计划+测试策略+测试案例等等）
第二部分，Linux（ Linux基础+Linux练习题）
第三部分，MySQL（基础知识+查询练习+万年学生表经典面试题汇总+数据库企业真题）
第四部分，Web测试
第五部分，API测试
第六部分，App测试
第七部分，管理工具
第八部分，Python基础（Python基础+编程题+集合+函数+Python特性等等）
第九部分，Selenium相关
第十部分，性能测试
第十一部分，LordRunner相关
第十二部分，计算机网络
第十三部分，组成原理
第十四部分，数据结构与算法
第十五部分，逻辑题
第十六部分，人力资源
软件测试基础 软件测试的步骤是什么?如何录制测试脚本?应该考虑进行如何测试的测试方法怎样估计测试工作量?测试设计的问题当测试过程发生错误时，有哪几种解决办法?测试执行的问题测试评估的目标如何提高测试?C/S模式的优点和缺点B/S模式的优点和缺点… Linux grep和find的区别? grep 都有哪些用法?
查看IP地址?
创建和删除一个多级目录?
在当前用户家目录中查找haha.txt文件?
如何查询出tomcat的进程并杀掉这个进程，写出linux命令?
动态查看日志文件?
查看系統硬盘空间的命令?
查看当前机器listen 的所有端口?
…
Python 统计python源代码文件中代码行数，去除注释，空行，进行输出?
python调用cmd并返回结果?
冒泡排序
1,2,3,4 这4个数字，能组成多少个互不相同的且无重复的三位数，都是多少?
请用 python 打印出 10000 以内的对称数（对称数特点：数字左右对称，如：1,2,11,121,1221 等）
给定一个整数 N，和一个 0-9 的数 K，要求返回 0-N 中数字 K 出现的次数
判断 101-200 之间有多少个素数，并输出所有的素数
一个输入三角形的函数，输入后输出是否能组成三角形，三角形类型，请用等价类- 划分法设计测试用例
…
MySQL 你用的Mysql是哪个引擎，各引擎之间有什么区别?
如何对查询命令进行优化?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fffde3d4db519c6cf577a1d6e4af7cbc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76d66f4344b3ad4d1f3f6c74da24c6de/" rel="bookmark">
			【华为 ICT &amp; HCIA &amp; eNSP 习题汇总】——题目集4
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、（多选）网络中出现故障后，管理员通过排查发现某台路由器的配置被修改了，那么管理员应该采取哪些措施来避免这种状况再次发生？
A、管理员应该通过配置 ACL 来扩展只有管理员能够登录设备
B、管理员应该在路由的管理端口上启用 port-security
C、管理员应该配置 AAA 来对登陆设备的用户进行认证和授权
D、管理员应该配置除管理员之外的所有账户登录设备的权限级别为0
考点：网络安全
解析：（ACD）
通过 ACL 命令可以实现在登录设备的访问控制列表中指定允许管理员登录的IP地址或主机名，并拒绝其他所有用户的登录尝试。所以，选项A正确。可以通过 port-security enable 命令使能端口安全功能，能够在一个端口上限制 MAC 地址的数量，以此来增强设备的安全性。所以，选项B错误，无法避免这种情况发生。通过配置 AAA，可以对登陆设备的用户进行认证，验证用户的身份，并判断其是否为合法用户，同时 AAA 还可以对通过认证的用户进行授权，决定用户可以使用哪些服务。所以，选项C正确。若配置账户登录设备的权限级别为0，则通常表示该账户具有最低的权限级别，即普通用户或访客级别的权限，即该账户只能执行一些基本的操作，而不能进行高级的管理或修改系统设置等操作。所以，选项D正确。
2、（多选）PPP 的 LCP 阶段协商的内容包括以下哪些？
A、MRU
B、认证协议
C、魔术字
D、IP地址
考点：数据链路层
解析：（ABC）
PPP（点对点协议）的LCP（链路控制协议）协商内容主要包括最大接收单元（MRU）、魔术字（Magic Number）、协商验证方式（协议）和异步字符映射，其中协商验证方式包括CHAP、PAP协议。所以，选项ABC正确。
3、VRRP 报文的组播目的地址是（）。
A、224.0.1.18
B、224.0.0.18
C、224.0.0.20
D、224.0.1.20
考点：路由技术原理
解析：（B）
VRRP（虚拟路由器冗余协议）的报文使用组播地址作为目的地址，其目的IP地址是224.0.0.18，该地址由IANA（国际标准时局）标准指定的多点广播地址。
4、（多选）以下 那种NAT 中可以同时使多个私网地址转换为一个公网地址去访问公网？
A、静态 NAT
B、动态 NAT
C、NAPT
D、Easy ip
考点：网络层
解析：（CD）
NAT，即网络地址转换，用于替换数据报文中的IP地址，一般是将私有地址转换为公有地址以实现访问公网的目的。基本 NAT 分为静态 NAT 和动态 NAT，静态中内、外网IP地址映射是固定的。静态NAT和动态 NAT 只能实现一对一的地址转换，无法将多个私网地址映射到一个公网地址的不同端口。所以，选项AB错误而通过 NAPT 技术，可以将多个私有网络连接到公共网络上，而不需要为每个私有网络分配单独的公网 IP 地址。另外，Easy IP 也可以转换多个私网地址到一个公网地址。所以，选项CD正确。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/76d66f4344b3ad4d1f3f6c74da24c6de/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1a48d00f44a1daaf4fe12e08b1b22b8/" rel="bookmark">
			利用 ChatGPT 高效搜索：举一反三的思考方式，高效查找解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 基础思路举一反三全面了解 GO 的 Web 框架系统方案建议 - 让 ChatGPT 推断我的一些微末思考结论 本文只是我的一些尝试，基于 ChatGPT 实现系统化快速搜索某编程语言的特定领域相关包或者基于其他语言类推荐落地方案的尝试。
这篇文章中描述的方式不一定是好方式，但应该会有一定的启示作用吧。让 ChatGPT 为我们的开发效率添砖加瓦。
基础思路 在学习和使用一门新的编程语言的过程中，找到合适的包对于解决特定问题至关重要。
传统上，还是主要依赖搜索引擎和社区资源来寻找这些包，但这个过程往往既耗时又充满挑战。现在，有了 ChatGPT，这一切都有了新的解决方案。
传统的搜索方法通常基于关键词搜索，但这种方法往往返回只是简单列举，我们要从大量不相关的结果找出我们想要的内容，需要花费大量时间去筛选。
ChatGPT 提供了一种更高效的方式：通过与 AI 对话来精确描述我们的需求，从而获得更加精准回答。不过我想说，不要像利用传统的搜索引擎一样利用 ChatGPT，ChatGPT 会思考。但毫无疑问，再聪明的好苗子，也是需要引导的。
举一反三全面了解 GO 的 Web 框架 为了最大化 ChatGPT 的效用，我采用固定句式来描述我的需求，这么做的目标主要是为了引导它思考。
例如，当寻找 Golang 的 web 开发框架时，我不是简单地问 “给我推荐一些 web 开发框架”，而是通过类比的方式地询问，想全访问了解不同情况下使用什么 HTTP 框架。
我知道在使用 Golang 的数据库时，可以直接使用 sql/database + 驱动连接数据库，也可以使用 ORM 方案，如 sqlx 或 GORM。HTTP 一般也是如此，有底层核心层，上层的用户体验较好的框架。
我按这个思考简单组织了一些语言。如下所示：
按我这个句式说下关于 Go 的 xxx 相关内容:
Go 语言中，处理数据库的包通常分为三个主要层次：底层实现、数据库驱动以及上层的 ORM（对象关系映射）框架。首先，底层核心包是 sql/database，它为数据库操作提供了基础的接口和功能。接着，针对不同数据库类型的驱动包各不相同，例如，用于 MySQL 的驱动包是 go-sql-driver/mysql。最后，在更高的层面上，有基于如 sqlbuilder 或 activerecord 模式的实现，Go 语言中的相应包包括 ent 和 gorm，这些包提供了更高级别的数据库操作和抽象。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b1a48d00f44a1daaf4fe12e08b1b22b8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3527985d48fedf234dfb94c1e501c0fd/" rel="bookmark">
			竞赛保研 机器视觉人体跌倒检测系统 - opencv python
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0 前言 🔥 优质竞赛项目系列，今天要分享的是
🚩 机器视觉人体跌倒检测系统
该项目较为新颖，适合作为竞赛课题方向，学长非常推荐！
🥇学长这里给一个题目综合评分(每项满分5分)
难度系数：3分工作量：3分创新点：4分 🧿 更多资料, 项目分享：
https://gitee.com/dancheng-senior/postgraduate
课题背景和意义 在中国，每年在65岁以上老人中，平均每3人中就有1人发生意外跌倒，每年大约有9500位老年人死于旅行途中或跌倒；而平均年龄在65岁至69岁之间的人每200次跌倒中就有一次髋关节骨折。更严重的是，20%到30%的患者会出现中度到严重的并发症，很可能导致残疾。
而在中国，老年人口已经突破2.5亿，按照30%概览推算，每年有7500万人次的老年人摔倒。
1 实现方法 实现方法有两种，一种是基于计算机视觉的，一种是基于惯性传感器器件的。
这次主要还是介绍基于计算机视觉的，想了解或学习基于惯性传感器器件跌倒检测的同学联系学长，学长安排博客。
传统机器视觉算法 传统背景差分法，结合OpenCV中的图像高斯平滑预处理以及腐蚀、膨胀图像形态学处理方法，实现一个更符合实际场景需要的运动目标检测方法。实验效果比较分析表明，该目标检测算法较传统目标检测算法能够提取更加准确和完整的运动目标轮廓。
检测效果如下：
背景差分法利用当前待处理视频帧图像与已经建模好的背景图像进行差分运算，利用阈值处理减少图像中的噪声干扰。优点是计算简单，且可以解决帧间差分法检测空洞的问题，得到的轮廓比较完整；
缺点是对于动态场景的适应能力不强， 对光照变化、 外来无关事物影响比较敏感。
基于机器学习的跌倒检测 人体行为辨识属于模式识别的分类决策的阶段，主要通过提取表征人体运动行为的特征向量，进而对人体的行为进行分析分类，最终用自然语言对其进行描述。有两种比较常见的方法：
（1） 基于模型的方法
基于模板的方法主要以人体模板作为主要的使用依据，可以通过对包含特定行为的视频帧序列进行转换的方法得到人体的模板，然后将被检测的人体行为与已经归类的人体行为模板进行匹配分类，从而得到行为识别的结果。基于模型的方法具有计算简单的优点，一般通过模型之间的距离比较完成人体行为的分类识别。缺点是需要大量足够的训练样本。
（2） 基于聚类的方法
基于聚类的方法把视频帧序列按照某种规则分类，在每一段进行特征的提取组成表示该段的特征矢量，进而通过聚类和相似度量等方法，将其中类别较少的段归为异常。常在处理离线状态下大量数据的异常检测问题时使用基于聚类的行为辨识方法。
SVM简介 支持向量机即常说的 SVM，全称是Support Vector
Machine。支持向量机是建立在统计学的VC维理论与结构化最小风险原理的基础上的，通过将向量映射到一个更高维的空间里，在这个空间建立一个最大间隔超平面，这个超平面被称为最优分类面，是支持向量机方法的理论基础。
SVM跌倒检测原理 我设计了一种运动物体行为辨识中采用基于两级SVM分类器的方法。
第一级SVM分类器用于判决运动物体是否处于非直立（下蹲、跌倒等）状态，提取物体的宽高比、最小包含物体矩形框面积、最小包含物体矩形框周长、运动物体高度等特征进行分类器的训练和分类判决。对于第一级分类器判决为非直立状态的图像帧，将它送入第二级SVM分类器进行分类判决。
第二级SVM分类器用于区分运动物体处于跌倒或其他的非直立状态，提取Zernike矩特征、运动物体的高度、运动物体的宽度、运动物体轮廓面积、运动物体轮廓周长等特征进行分类器的训练和分类判决。如果第二级
SVM 分类器判决为属于跌倒姿势状态类， 系统自动发出报警信息。
算法流程 算法效果 深度学习跌倒检测 介绍一个效果非常不错的网络，使用数据集在该网络下训练后得到的跌倒检测效果粉肠不错。
最终效果 网络原理 最后 🧿 更多资料, 项目分享：
https://gitee.com/dancheng-senior/postgraduate
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed9c9ac0a219d1cfc7f61ad857810fa8/" rel="bookmark">
			【ASP.NET Core 基础知识】--路由和请求处理--Attribute路由
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、介绍 在ASP.NET Core中，路由是将传入的URL请求映射到正确的控制器和操作的方法。Attribute路由是一种基于属性，用于定义路由规则的方式，通过在控制器类和操作方法上应用特定的属性，来定义URL模板。
基本概念：
**路由：**在ASP.NET Core中，路由是将URL请求映射到正确的控制器和操作的过程。路由中间件会按照定义的路由规则，将传入的HTTP请求匹配到正确的路由路径，进而执行对应的控制器和操作方法。**控制器：**控制器是处理HTTP请求的类，其中包含处理请求的操作方法。在ASP.NET Core中，控制器类必须继承自Controller或ControllerBase类。**操作方法：**操作方法是控制器中用于处理HTTP请求的具体实现。通过在控制器类或操作方法上应用特定的属性，可以定义URL模板，从而实现路由匹配。 重要性：
可读性更强：使用属性路由，可以定义更加清晰和易读的路由路径，使得URL更加友好和易于理解。**灵活性更高：**属性路由可以更加灵活地定义路由规则，支持多种路由匹配方式，如默认路由、自定义路由、参数路由等。**可维护性更高：**属性路由的路由规则定义更加集中和清晰，易于维护和管理。同时，由于路由规则定义在控制器类和操作方法上，可以更好地与代码分离，提高代码的可读性和可维护性。**性能更优：**属性路由在路由匹配时，可以利用编译时静态分析，提前解析路由模板，从而提高路由匹配的性能。 二、传统路由和属性路由的比较和选择 传统路由和属性路由（Attribute Routing）是ASP.NET Core中的两种主要路由（Routing）方式。下面是它们的比较和选择：
传统路由（Convention-based Routing）：
传统路由是一种基于约定的路由方式。在传统路由中，我们定义路由规则时，需要指定路由的URL模板以及相应的控制器和操作方法。传统路由是一种静态路由方式，它的路由规则是在应用程序启动时静态定义的。
优点：
简单易用：传统路由的路由规则定义简单明了，易于理解和使用。性能较高：传统路由的路由规则定义是在应用程序启动时静态定义的，因此在路由匹配时具有较高的性能。 缺点：
不够灵活：传统路由的路由规则定义是基于约定的，不够灵活，无法满足一些复杂的路由需求。可读性较差：传统路由的路由规则定义在代码中分散开来，可读性较差。 属性路由（Attribute Routing）：
属性路由是一种基于属性的路由方式。在属性路由中，我们可以在控制器类和操作方法上应用特定的属性来定义路由规则。属性路由是一种动态路由方式，它的路由规则是在运行时动态定义的。
优点：
更加灵活：属性路由的路由规则定义更加灵活，可以满足一些复杂的路由需求。可读性更好：属性路由的路由规则定义在代码中集中起来，可读性更好。可维护性更高：属性路由的路由规则定义更加集中和清晰，易于维护和管理。 缺点：
相对复杂：属性路由的路由规则定义相对复杂，需要一定的学习成本。性能较低：属性路由的路由规则定义是在运行时动态定义的，因此在路由匹配时性能相对较低。 选择：
在选择传统路由和属性路由时，需要根据具体的应用场景和需求来选择。如果应用程序的路由规则比较简单，且性能要求较高，可以选择传统路由；如果应用程序的路由规则比较复杂，且需要更高的可读性和可维护性，可以选择属性路由。同时，在实际开发中，也可以结合使用传统路由和属性路由，以满足不同的路由需求。
三、Attribute路由的基本使用 3.1 在Controller上使用Attribute路由 在ASP.NET Core中，我们可以在控制器类上使用[Route]属性来定义控制器级别的路由规则。以下是一个示例：
[Route("api/[controller]")] public class UsersController : Controller { [HttpGet] public IActionResult Get() { return Ok(); } [HttpGet("{id}")] public IActionResult Get(int id) { return Ok(); } // ... } 在上面的示例中，我们在UsersController类上使用了[Route("api/[controller]")]属性，这表示所有该控制器的操作方法都可以通过“api/users”路径访问。
Tip：这里的[controller]是一个占位符，它会被实际的控制器名称替换。例如，如果你访问api/users路径，[controller]将被替换为Users。
此外，我们还分别在Get和Get(int id)方法上使用了[HttpGet]和[HttpGet("{id}")]属性来定义它们的路由。其中，[HttpGet]表示该方法可以通过HTTP GET请求访问，而[HttpGet("{id}")]表示该方法可以通过具有id参数的HTTP GET请求访问。
通过这种方式，我们可以方便地定义控制器级别的路由规则，从而更好地组织我们的代码和URL。
3.2 在Action上使用Attribute路由 在ASP.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ed9c9ac0a219d1cfc7f61ad857810fa8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80db39455663060b9719015e477bc429/" rel="bookmark">
			交叉编译bluez-5.66
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为了使用蓝牙命令
实际安装路径/home/subomb/intsall
一，实际输入配置命令：
./configure --prefix=/home/subomb/intsall --mandir=/home/subomb/intsall/usr/share/man --sysconfdir=/home/subomb/intsall/etc --localstatedir=/home/subomb/intsall/var -enable-tools -enable-test --enable-experimental --enable-maintainer-mode --disable-udev --enable-library --enable-shared=yes --enable-network --enable-health --enable-cups --enable-threads --enable-pie --enable-deprecated
报错1：configure: error: GLib &gt;=2.28 is required
sudo apt-get install libglib2.0-dev
报错2:configure: error: D-Bus library is required
sudo apt-get install libdbus-1-dev
可能缺其他库：
sudo apt-get install libical-dev
sudo apt-get install libreadline-dev
sudo apt-get install python-docutils
配置成功如下：
二，编译：sudo make -j4进行编译 出现下面的错误：
这里是因为，列数不匹配，要输入对应列数的数值。根据提示，这里不能用auto。要输入具体的数值，所以这里将auto改为10，10。修改方式：
接下来就是如法炮制，将其他地方都进行这样的修改，总共修改的地方有：
monitor/btmon.rst，tools/hciconfig.rst，tools/hciattach.rst，tools/iostest.rst，tools/btattach.rst每个文件中出现1-4处的修改，将auto改为10 10
接着报错：
Exiting due to level-3 (ERROR) system message.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/80db39455663060b9719015e477bc429/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a945122aab67b55f41fabe5288644ec/" rel="bookmark">
			漏洞扫描软件AWVS的介绍和使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Acunetix Web Vulnerability Scanner（AWVS）是用于测试和管理Web应用程序安全性的平台，能够自动扫描互联网或者本地局域网中是否存在漏洞，并报告漏洞。
1. AWVS简介
Acunetix Web Vulnerability Scanner（AWVS）可以扫描任何通过Web浏览器访问和遵循HTTP/HTTPS规则的Web站点。适用于任何中小型和大型企业的内联网、外延网和面向客户、雇员、厂商和其它人员的Web网站。
AWVS可以通过检查SQL注入攻击漏洞、XSS跨站脚本攻击漏洞等漏洞来审核Web应用程序的安全性。
1.1 AWVS功能及特点
自动的客户端脚本分析器，允许对Ajax和Web2.0应用程序进行安全性测试* 业内最先进且深入的SQL注入和跨站脚本测试* 高级渗透测试工具，例如HTPP Editor和HTTP Fuzzer* 可视化宏记录器帮助您轻松测试web表格和受密码保护的区域* 支持含有CAPTHCA的页面，单个开始指令和Two Factor（双因素）验证机制* 丰富的报告功能，包括VISA PCI依从性报告* 高速的多线程扫描器轻松检索成千上万的页面* 智能爬行程序检测web服务器类型和应用程序语言* Acunetix检索并分析网站，包括flash内容，SOAP和AJAX* 端口扫描web服务器并对在服务器上运行的网络服务执行安全检查* 可到处网站漏洞文件#### 1.2 AWVS工作原理
扫描整个网络，通过跟踪站点上的所有链接和robots.txt来实现扫描，扫描后AWVS就会映射出站点的结构并显示每个文件的细节信息。* 在上述的发现阶段或者扫描过程之后，AWVS就会自动地对所发现的每一个页面发动一系列的漏洞攻击，这实质上是模拟一个黑客的攻击过程（用自定义的脚本去探测是否有漏洞） 。WVS分析每一个页面中需要输入数据的地方，进而尝试3所有的输入组合。这是一个自动扫描阶段 。* 在它发现漏洞之后，AWVS就会在“Alerts Node(警告节点)”中报告这些漏洞，每一个警告都包含着漏洞信息和如何修补漏洞的建议。* 在一次扫描完成之后，它会将结果保存为文件以备日后分析以及与以前的扫描相比较，使用报告工具，就可以创建一个专业的报告来总结这次扫描。### 2. AWVS安装
（1）在官网下载awvs安装包，此软件为付费软件试用期14天。目前版本已经迭代到Acunetix WVS13版本
（2）点击安装包执行安装，勾选使用协议，执行下一步
​
编辑
添加图片注释，不超过 140 字（可选）
​
编辑
添加图片注释，不超过 140 字（可选）
（3）填写邮件、密码并执行下一步，这里的邮件及密码会用于以后使用软件的时候进行登录验证
​
编辑
添加图片注释，不超过 140 字（可选）
（4）这一步填写端口号，默认为3443，可以根据自己需求进行修改；询问是否在桌面添加快捷方式，一般选择是，选择后执行下一步
​
编辑
添加图片注释，不超过 140 字（可选）
（5）勾选创建桌面快捷方式，执行下一步完成安装
​
编辑
添加图片注释，不超过 140 字（可选）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0a945122aab67b55f41fabe5288644ec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55b4a9e1a1593e4c9fe49a898e439c84/" rel="bookmark">
			如何成为一名黑客？小白必学的12个基本步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		黑客攻防是一个极具魅力的技术领域，但成为一名黑客毫无疑问也并不容易。你必须拥有对新技术的好奇心和积极的学习态度，具备很深的计算机系统、编程语言和操作系统知识，并乐意不断地去学习和进步。
如果你想成为一名优秀的黑客，下面是10种最重要的基础条件，请认真阅读：
1. 了解黑客的思维方式
我们生活中用到的网站、软件等，都是由程序员编写的代码构成的。
这些代码在设计的过程中，都是基于一种正向的逻辑进行的，为了实现某个目的，完成某个操作的流程或数据传输逻辑。
而黑客的思维是逆向的，他们会去分析目前这个操作流程或数据传输逻辑中，是否存在一些验证不严谨或者隐秘信息被泄露的风险，并加以利用，从而绕过正常的操作逻辑达到未授权访问或操作的能力。
通俗点说，程序员是造房子的，而黑客则是看看房子是不是哪里漏了个风，缺了个口。翻进去为所欲为；有的甚至直接将房子拆了。
2. 学习UNIX/LINUX
笔者为大家挑选了一些适合初学者学习UNIX和Linux操作系统的最佳书籍，这些书不仅能教你学会Linux和UNIX的基础知识，其中包含了大量用于在UNIX环境中进行高级编程的大量代码示例。
《Linux/UNIX系统编程手册》
与许多较老的UNIX书籍不同，这是一本相对较新的Linux书籍，这本书是由Michael Kerrisk编写的，他是Linux手册的维护成员之一，与许多作者一样，他从1987年开始研究UNIX，并从20世纪90年代末开始关注Linux。如果只推荐一本书的话，我会推荐这一本，因为它更全面，它应该是学习UNIX/Linux系统编程的标准书籍。添加微信codingSmart免费领取。
《Linux命令行大全》
《Linux命令行大全》主要介绍Linux命令行的使用，循序渐进，深入浅出，引导读者全面掌握命令行的使用方法。每一个要在Linux中工作的新程序员都应该有一本这本书。
黑客学习资源免费分享 https://zhuanlan.zhihu.com/p/604834208
《UNIX环境高级编程（第3版）》
这是学习UNIX最好的书之一，是由Richard W. Stevens编写的经典，UNIX是有史以来最好的软件之一，它已经有30多年的历史了，而且仍然很强大，只要UNIX仍然存在，这本书就会一直经典。
这本书的优点在于，书中有成千上万的代码示例，并给出了清晰的解释，它还包含了数百个插图和图形，展示了不同的UNIX概念是如何工作的。简而言之，这是任何想学习UNIX并更好地理解它的人必读的UNIX书籍之一。
3. 学习一门编程语言
黑客&amp;网络安全工程师的武器也是代码。想要成为黑客或者网络安全工程师，首先要学会一门黑客需要的编程语言。
对于没有代码经验的小白，下面三项，是安全行业的从业者都最好能掌握的语言，锤炼一下自己编程的功底。
Shell脚本
掌握常用的Linux命令，能编写简单的Shell脚本，处理一些简单的事务。
C语言（C++可选）
C语言没有复杂的特性，是现代编程语言的祖师爷，适合编写底层软件，还能帮助你理解内存、算法、操作系统等计算机知识，建议学一下。
Python
C语言帮助你理解底层，Python则助你编写网络、爬虫、数据处理、图像处理等功能性的软件。是程序员，尤其是黑客们非常钟爱的编程语言，不得不学。
4. 学习了解计算机网络知识 这是另一个必不可少的基础条件，学习网络知识，理解网络的构成。懂得不同类型网络之间的差异之处，清晰的了解TCP/IP和UDP协议。这都是在系统中寻找 漏洞的必不可少的技能。理解局域网、广域网，VPN和防火墙的重要性，精通Wireshark和NMAP这样的网络扫描和数据包分析工具等。
重点学习 OSI、TCP/IP 模型，网络协议，网络设备工作原理等内容，其他内容快速通读；
5. 学习使用黑客常用操作系统 注重安全性的操作系统是黑客最好的朋友，因为它可以帮助他们发现计算机系统或计算机网络中的弱点。
Kali Linux
由 Offensive Security 开发并重写 BackTrack，Kali Linux 发行版在我们用于黑客目的的最佳操作系统列表中名列前茅。这个基于 Debian 的操作系统附带了 600 多个预装的笔测试工具，使您的安全工具箱更加丰富。这些通用工具会定期更新，并适用于 ARM 和 VMware 等不同平台。对于司法鉴定工作，此顶级黑客操作系统具有实时启动功能，该功能为漏洞检测提供了理想的环境。
除此之外还有**Parrot Security OS、 **BackBox、******Samurai Web Testing Framework、**Pentoo Linux、**DEFT Linux、**Caine、**********Network Security Toolkit、**BlackArch Linux、Bugtraq、ArchStrike Linux、Fedora Security Spin等多款操作系统
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/55b4a9e1a1593e4c9fe49a898e439c84/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f6150885fdc9d3a2ebdd81f77c0c5c9/" rel="bookmark">
			大创项目推荐 深度学习验证码识别 - 机器视觉 python opencv
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 0 前言1 项目简介2 验证码识别步骤2.1 灰度处理&amp;二值化2.2 去除边框2.3 图像降噪2.4 字符切割2.5 识别 3 基于tensorflow的验证码识别3.1 数据集3.2 基于tf的神经网络训练代码 4 最后 0 前言 🔥 优质竞赛项目系列，今天要分享的是
🚩 深度学习验证码识别 - 机器视觉 python opencv
该项目较为新颖，适合作为竞赛课题方向，学长非常推荐！
🥇学长这里给一个题目综合评分(每项满分5分)
难度系数：3分工作量：3分创新点：4分 🧿 更多资料, 项目分享：
https://gitee.com/dancheng-senior/postgraduate
1 项目简介 在python爬虫爬取某些网站的验证码的时候可能会遇到验证码识别的问题，现在的验证码大多分为四类：
1、计算验证码
2、滑块验证码
3、识图验证码
4、语音验证码
学长这李主要写的就是识图验证码，识别的是简单的验证码，要想让识别率更高，识别的更加准确就需要花很多的精力去训练自己的字体库。
2 验证码识别步骤 1、灰度处理
2、二值化
3、去除边框（如果有的话）
4、降噪
5、切割字符或者倾斜度矫正
6、训练字体库
7、识别
这6个步骤中前三个步骤是基本的，4或者5可根据实际情况选择是否需要，并不一定切割验证码，识别率就会上升很多有时候还会下降
这篇博客不涉及训练字体库的内容，请自行搜索。同样也不讲解基础的语法。
用到的几个主要的python库： Pillow(python图像处理库)、OpenCV(高级图像处理库)、pytesseract(识别库)
2.1 灰度处理&amp;二值化 灰度处理，就是把彩色的验证码图片转为灰色的图片。
二值化，是将图片处理为只有黑白两色的图片，利于后面的图像处理和识别
在OpenCV中有现成的方法可以进行灰度处理和二值化，处理后的效果：
​
# 自适应阀值二值化 def _get_dynamic_binary_image(filedir, img_name): filename = './out_img/' + img_name.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6f6150885fdc9d3a2ebdd81f77c0c5c9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f7b741d79b484b5ba2f47c4a3c55afd/" rel="bookmark">
			使用Sobel算子把视频转换为只剩边缘部分
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		效果展示 原始视频
修改后的视频
整体代码 import cv2 vc = cv2.VideoCapture('test.mp4') if vc.isOpened(): open, frame = vc.read() else: open = False i = 0 while open: ret, frame = vc.read() if frame is None: break if ret == True: i += 1 # 转换为灰度图 gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY) # 使用Sobel进行边缘处理 sobelx = cv2.Sobel(gray, cv2.CV_64F, 1, 0, ksize=3) sobelx = cv2.convertScaleAbs(sobelx) sobely = cv2.Sobel(gray, cv2.CV_64F, 0, 1, ksize=3) sobely = cv2.convertScaleAbs(sobely) # 合起来 sobelxy = cv2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6f7b741d79b484b5ba2f47c4a3c55afd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/873948a407148f088a0d843f5dfee741/" rel="bookmark">
			数据结构——单链表的查找、求单链表长度、单链表的创建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、单链表的查找 1.按位查找 ==GetElem(L, i): ==按位查找操作，获取表L中第i个位置的元素的值;
平均时间复杂度O（n）
2.按值查找 ==LocateElem(L, e)==:按值查找操作，在表L中查找具有给定关键字值的元素;
二、求单链表的长度 == Length(LinkList L)==：计算单链表中数据结点（不含头结点）的个数，需要从第一个结点看是顺序依次访问表中的每个结点。算法的时间复杂度为O（n）。
三、单链表的创建操作 1.头插法建立单链表（平均时间复杂度O(n)） 思路：每次都将生成的结点插入到链表的表头。 2.尾插法建立单链表（时间复杂度O（n）） 思路：每次将新节点插入到当前链表的表尾，所以必须增加一个尾指针r,使其始终指向当前链表的尾结 点。好处：生成的链表中结点的次序和输入数据的顺序会一致。
3.链表的逆置： 算法思想：逆置链表初始为空，原表中结点从原链表中依次“删除”，再逐个插入逆置链表的表头（即“头插”到逆置链表中），使它成为逆置链表的“新”的第一个结点，如此循环，直至原链表为空；
四、学习心得 单链表的查找
1. 按位查找：这意味着要访问链表中的第k个元素，需要从头结点开始，顺序移动到第k个位置。因为可能需要遍历整个链表，所以平均时间复杂度为O(n)。此操作体现了链表非随机存储的特性，访问特定位置的成本较高。
2. 按值查找：按值查找时，我们需要遍历链表，检查每个节点的值是否与目标值匹配。这同样具有O(n)的时间复杂度。这种查找操作在链表中是线性的，且它更加强调了链表中元素的无序性。
求单链表的长度
单链表长度的计算需要从第一个数据节点出发，顺序访问每个节点，直到链表末尾。这个过程的时间复杂度也是O(n)，因为它涉及到对链表的一次完整遍历。
单链表的创建操作
1. 头插法：创建单链表的头插法是将新节点插入到链表的前端。这种方法创建的链表元素顺序与添加顺序相反。每次插入操作的时间复杂度为O(1)，但建立整个链表的平均时间复杂度为O(n)，因为要插入n个元素。
2. 尾插法：尾插法是将新节点添加到链表的末尾。这保持了元素的添加顺序。若没有维护指向链表最后一个节点的指针，每次插入操作的时间复杂度为O(n)，因为需要找到当前最后一个节点。但如果维护了尾指针，每次插入的时间复杂度为O(1)，整个链表构建的复杂度仍为O(n)。
链表的逆置
链表的逆置是将链表中的元素反向排列。这通常通过重新排列节点的指针来完成，而不是实际移动节点中的数据。链表逆置的时间复杂度是O(n)，因为需要遍历一次链表来重新链接所有的节点。
综合心得
学习单链表的操作不仅让人了解了链表结构本身，还有助于理解数据结构的更广泛原理，例如动态内存管理、指针操作和算法复杂度。链表作为一种基础的数据结构，它的灵活性和动态性使得在进行插入和删除操作时非常高效，特别是在不需要频繁随机访问元素时。同时，链表的操作也强化了对递归和迭代思想的理解，因为很多链表问题可以通过这两种方法来解决。
此外，链表的操作也体现了算法设计中的权衡，比如时间复杂度和空间复杂度的考虑，以及特定场景下算法选择的重要性。例如，尽管链表能够提供快速的插入和删除，它在按索引查找时却不如数组高效。因此，在实践中，选择正确的数据结构对于性能至关重要。
最后，掌握链表的操作也是理解更复杂数据结构如树和图的基础，因为这些结构中都包含了链表的概念。总之，链表不仅是学习数据结构的重要一环，它的概念和操作也贯穿在计算机科学的多个领域中。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/226ea48ee651088fde4bb0ac8aa875ea/" rel="bookmark">
			数据结构——单链表上基本操作的实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.按位序插入（带头结点）： ==ListInsert(&amp;L, i, e): ==在表L中的第i个位置上插入指定元素e = 找到第i-1个结点(前驱结点)，将新结点插入其后；其中头结点可以看作第0个结点，故i=1时也适用。
typedef struct LNode{ ElemType data; struct LNode *next;
}LNode, *LinkList;
//在第i个位置插入元素e（带头结点）
bool ListInsert(LinkList &amp;L, int i, ElemType e){
//判断i的合法性, i是位序号(从1开始) if(i&lt;1)
LNode *p; int j=0;
p = L;
//循环找到第i-1个结点
while(p!=NULL &amp;&amp; j&lt;i-1){ p = p-&gt;next;
j++;
}
if (p==NULL)
return false;
//在第i-1个结点后插入新结点
LNode *s = (LNode *)malloc(sizeof(LNode)); //申请一个结点s-&gt;data = e;
s-&gt;next = p-&gt;next;
p-&gt;next = s; //将结点s连到p后,后两步千万不能颠倒qwq
return true;
}
平均时间复杂度：O(n)
2.按位序插入（不带头结点） ==ListInsert(&amp;L, i, e): ==在表L中的第i个位置上插入指定元素e = 找到第i-1个结点(前驱结点)，将新结点插入其后; 因为不带头结点，所以不存在“第0个”结点，因此！i=1 时，需要特殊处理——插入(删除)第1个元素时，需要更改头指针L;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/226ea48ee651088fde4bb0ac8aa875ea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32bce31d05ba7b6cf64f3a0fa5e99b37/" rel="bookmark">
			数字式温度计的设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		根据前期的设计要求，我们需要设计一个数字式温度测量计，能够实现将温度信号实时转换成实际方便查看的形式输出。
目录
题目要求
设计思路
电路模块
温度传感器电路
A/D转换电路
数码管显示电路
仿真显示
题目要求 以下为题目的设计参考电路，该参考电路是摘自文章《MC14433在数字温度表中的应用》。其主要分为以下几部分：显示数码管、A/D转换芯片、4511芯片和MC1413芯片。显示数码管用来显示具体的温度数值、A/D芯片用来将LM50温度传感器的连续模拟信号转换为数字信号输出、4511芯片用于将A/D芯片输出的信号译码并从数码管输出、MC1413是用来驱动数码管的芯片。
设计思路 由于本次设计是需要设计一个数字温度显示器，我们主要将设计分为两大部分：温度检测部分和数字显示部分。温度显示部分主要是使用传感器将温度信号转换为电压信号，而数字显示部分主要将温度显示部分的模拟信号转换为数字信号并且输入到数码管显示。
电路模块 温度传感器电路 首先是温度传感器模块，温度传感器模块这里我们使用的是LM50模块，这个模块的的温度转换公式是：U=-10t+500(mv)。即温度每升高/降低一摄氏度，那么电压输出就会降低/升高10mv，而当期初始输入为0℃时，其输出为500mv。其电路的连接形式如下左图所示，而当其输入为0℃时，其具体的输出电压数值如下右图所示。
A/D转换电路 A/D转换电路这里，由于我们没有找到MC14433芯片，根据对比，我们选取性能比较相近的三位半A/D转换芯片TC7107芯片，该芯片是一款高性能,低功耗的三位半 A/D 转换器。三位半的意思是其可以外接4个数码管，其中三个分别可以显示数值0-9，而剩下一个可以显示数值0/1。该芯片的引脚接法如下图所示，该图我摘自TC7107的技术说明手册。
首先是OSC1、OSC2和OSC3引脚，这几个引脚主要控制产生振荡信号，即48kHZ的时钟信号，以此实现对A/D芯片的各项功能的协调控制。
其中VIN+、VIN-和ACOM引脚主要是温度传感器电压的输入端，这里需要注意的是将VIN-要与引脚ACOM相连。
引脚VBUFF、CAZ和VINT分别是集成电阻器的大小、自动调零电容器的大小和积分器大小。其中CAZ的大小将影响输入的系统噪声，一般是0.47μF用于200mV，而0.047μF用于2V。而VBUFF是集成的电阻器，当取200mV全量程时为47kΩ、当取2V量程时为470kΩ。它们的具体取值参数如下图所示：
而对于VREF+、VREF-和C+REF分别是控制量程和当存在较大共模电压时的处理处理引脚。一般如果量程为200mV时引脚VREF+和VREF-间电压为100mV，而当量程为2V时引脚VREF+和VREF-间电压为1V，并且该电压还会影响输出的电压的
对于当VREF+和VREF-这两个引脚之间的电压值将确定输入电压变化恒定时，输出电压的变化值，也就是一格刻度的数值，它们的具体转换公式如下所示：
而我们选择的量程是0-2V，所以我们引脚连接的具体方式如下图所示：
数码管显示电路 TC7107含有七段译码器显示驱动器，所以可以驱动外接的4个共阳级7SEG-MPX1-CA数码管进行温度数值显示，四个数码管分别显示符号位、十位和个位、小数位。而由于其内部已经集成了译码电路和驱动电路，所以不用再外接MC1413和4511芯片。
首先第一个数码管用于显示正负号，其只需要外接到特定的的引脚和驱动引脚，即可显示中间一段，该引脚接到A/D引脚POL，结合说明书所示，当该引脚输入电压为大于0时，其表现特点为不亮，而当引脚输入电压小于或等于0时，其表现特点为亮。
其余3个数码管的显示引脚分别外到A/D芯片的Ai～Gi引脚即可，当引脚输入电压小于0时即可实现数码管点亮。值得注意的是个位和小数位之间需要数码管显示一个小数点，为此数码管三的小数显示引脚要接地。
仿真显示 根据上面的电路接法，如果我们就这样就进行仿真的话，发现数码管显示的数值并不等于输入的温度数值。
从上面的仿真结果可以看出，当输入温度为0摄氏度时，其输出的数码管显示为52.4℃，与0℃相差大概50℃。仔细观察不难看出，主要关系是当温度输入为0℃时，LM50电压的输出为500mv。
如果我们在LM50与A/D转换电路之间加上一个减法电路减去50mv后再去仿真，可以看出输出结果是不同的，添加后的仿真结果如下图所示，但是因为没有处理小数点，所以结果会相对来说有一定偏差：
当输入为15℃
当输入为17℃
当输入为-3℃
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6cc62ca0a2ecab9f09d1699562cb7738/" rel="bookmark">
			shell编程-5
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		akw的使用 shell学习第五天1.时间的正则简单使用awk深入学习 awkakw的完整语法来个例子内置变量复杂的例子 练习查找出 /etc/passwd文件里的用户名包含a字符串的用户名，并且输出用户名，统计有多少个这样的用户 小知识点time命令分隔符分两种 shell学习第五天 1.时间的正则 2024年1月1号到1月31号的正则
[root@gh-shell 1-19] cat access.log |egrep "([1-9]|[12][0-9]|3[01])/Jan/2024" 2024年1月19日 9点到21点之间的日志
[root@gh-shell 1-19] cat access.log |egrep "19/Jan/2024:(09|1[0-9]|2[01]):(0[1-9]|[1-5][0-9]):([0-5][0-9])" 计算19/Jan/2024:09:01~59 分钟每分钟的流量
[root@gh-shell 1-19] cat access.log |egrep "19/Jan/2024:09:(0[1-9]|[1-5][0-9]):([0-5][0-9])" '01-59的正则' 0[1-9]|[1-5][0-9] '00~59秒的正则' 19/Jan/2024:09:(0[1-9]|[1-5][0-9]):([0-5][0-9]) 计算19/Jan/2024:00:00~23:59 分钟每分钟的流量
这个实现得需要循环去实现
00点
​ 01~59分
01点
​ 01~59分
02点
​ 01~59分
.
.
.
#!/bin/bash for i in {00..23} do for y in {00..59} do cat /root/access.log |egrep "19/Jan/2024:$i:$y:[0-5][0-9]"|awk -v i=$i -v y=$y 'BEGIN{print i,y}{sum+=$10}END{print sum}' &amp;&gt;&gt;/root/daikuan.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6cc62ca0a2ecab9f09d1699562cb7738/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a9c0152d57be7087727cb18a60008d1/" rel="bookmark">
			201709CSPT4通信网络
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 题目大意：一个有向图有 n n n个点 m m m条边，现在判断每个点的连通性，求能够到达所有n个点的点数量。
#include&lt;bits/stdc++.h&gt; using namespace std; vector&lt;int&gt; G[1010]; int vis[1010],sum[1010]; int ans,n,m; void dfs(int now,int start) { sum[start]++; vis[now]=1; for(int i=0;i&lt;G[now].size();i++) { int v=G[now][i]; if(vis[v]==0) { sum[v]++;dfs(v,start); } }	} int main() {	cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=m;i++) { int u,v; cin&gt;&gt;u&gt;&gt;v; G[u].push_back(v); } memset(sum,0,sizeof(sum)); for(int i=1;i&lt;=n;i++) { memset(vis,0,sizeof(vis)); dfs(i,i); } for(int i=1;i&lt;=n;i++) { if(sum[i]&gt;=n)ans++; //cout&lt;&lt;sum[i]&lt;&lt;" "; } cout&lt;&lt;ans; return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ada559e638f65cfe3054f51d30c2c344/" rel="bookmark">
			【开源】基于JAVA语言的软件学院思政案例库系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、摘要1.1 项目介绍1.2 项目录屏 二、功能模块2.1 系统管理员2.2 普通教师 三、系统展示四、核心代码4.1 查询思政案例4.2 审核思政案例4.3 查询思政课程4.4 思政案例点赞4.5 新增思政案例评语 五、免责说明 一、摘要 1.1 项目介绍 基于JAVA+Vue+SpringBoot+MySQL的软件学院思政案例库系统，包含了新闻资讯、特色专区、院系专区、热门专题、热门课程、思政课程、思政案例、案例点赞、案例打分模块，还包含系统自带的用户管理、部门管理、角色管理、菜单管理、日志管理、数据字典管理、文件管理、图表展示等基础模块，软件学院思政案例库系统基于角色的访问控制，给系统管理员、普通教师使用，可将权限精确到按钮级别，您可以自定义角色并分配权限，系统适合设计精确的权限约束需求。
1.2 项目录屏 二、功能模块 2.1 系统管理员 按照软件工程规范描述管理员端需求，细化用例规约，合理设计数据库，实现管理员端以下功能。
配置系统中各项基础数据，包括教师、课程及用户权限等。设计平台首页，包括新闻资讯、特色专区、院系专区、热点专题、热门课程思政资源等板块。课程思政展示区，包括课程介绍、教学设计、教学视频、教学说课、教学课件、授课教师、课程分享、学习人数统计等。对教师提交的信息进行审核，审核通过后在门户发布，审核不通过的说明原因并允许教师进行修改。对平台中的思政案例按浏览和点赞等数据进行统计和排序展示。 2.2 普通教师 按照软件工程规范描述普通教师端需求，细化用例规约，合理设计数据库，实现普通教师端以下功能。
学习观摩网站平台上所有的思政资源，可以按需求、按类别(人格培养类、家国情怀类、中国自信类、大国工匠类、科技报国类、职业伦理类等）搜索感兴趣的思政案例，对别人发布的资源进行点赞和评分。系统注册和登录。修改个人基本信息.。上传思政案例，对个人的思政资源进行修改再提交及删除等管理操作。查看个人已发布思政资源的浏览量、点赞和评分等数据。 三、系统展示 四、核心代码 4.1 查询思政案例 @RequestMapping(value = "/getByPage", method = RequestMethod.GET) @ApiOperation(value = "查询思政案例") public Result&lt;IPage&lt;ThoCase&gt;&gt; getByPage(@ModelAttribute ThoCase thoCase ,@ModelAttribute PageVo page){ QueryWrapper&lt;ThoCase&gt; qw = new QueryWrapper&lt;&gt;(); User currUser = securityUtil.getCurrUser(); QueryWrapper&lt;User&gt; userQw = new QueryWrapper&lt;&gt;(); userQw.eq("id",currUser.getId()); userQw.inSql("id","SELECT user_id FROM a_user_role WHERE del_flag = 0 AND role_id = '1536606659751841799'"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ada559e638f65cfe3054f51d30c2c344/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e9084b4b62ffb287106f0f633a049d8/" rel="bookmark">
			Voc标签文件转Yolo标签文件程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为了方便，我将代码封装成了桌面程序，GUI部分我就不介绍了，泛泛而谈到时啥都没学会。
一、yolo标签格式 我们看一下yolo标签的格式：
&lt;class index&gt; &lt;x center&gt; &lt;y center&gt; &lt;width&gt; &lt;height&gt; \text{&lt;class index&gt; &lt;x center&gt; &lt;y center&gt; &lt;width&gt; &lt;height&gt;} &lt;class index&gt; &lt;x center&gt; &lt;y center&gt; &lt;width&gt; &lt;height&gt;
上述格式【class_index】是某类别对应的标签索引，为整型；后面4个参数均为比例，而不是实际参数，我们举个例子
1 0.759623 0.749454 0.079443 0.081878
我假设“汽车”这个类别对应的标签索引为1。那么上述例子表示我们标了一个框，这个框的类别索引为1，表示为类别“汽车”。
前两个浮点参数表示这个框的中心坐标分别相对于整个图像宽度和高度的比例，用比例来表示中心点的位置;后两者表示框的宽度和高度分别相对于整个图像的比例，用比例来表达框的大小。
二、载入XML文件 首先我们使用python自带模块【os】来将指定目录（XML文件所在目录）【self.source_path】的所有文件名载入到文件名列表【Files】中。
然后我们使用for训练，遍历文件列表的每一个文件名，如果文件名的扩展名是【.XML】，则表示是标签文件，此时调用Process进行转换
def LoadVocTag(self): Files = os.listdir(self.source_path) # 处理每一个xml文件 for File in Files: if File.endswith('.xml'): self.Process(File) 三、获取类别标签对应类别索引字典 代码中【self.classes_file】表示含有对应关系的txt文件路径，现在我们要把它载入，做成字典。我们看一个类别标签和类别索引的对应关系的txt文件内容：
纸类 1
塑料类 2
金属类 3
衣品类 4
其他 5
上述内容，类别标签和类别索引之间用空格隔开了，因此我们打开文件后，逐行读取内容，然后使用空格进行分割成两段。前段是类别标签，后段时类别索引，类别索引读出来是文本，我们转换成整型后添加到字典就好了。
我相信现在看下面的代码就一目了然了：
def GetTag(self): # 类别字典 class_dict = {} # 打开含有号码和类别对应关系的txt文件 with open(self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1e9084b4b62ffb287106f0f633a049d8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e84daecfa441ad19690ef79e65c7ff1c/" rel="bookmark">
			JVM：Java类加载机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java类加载机制的全过程： 加载、验证、准备、初始化和卸载这五个阶段的顺序是确定的，类型的加载过程必须按照这种顺序按部就班地开始，而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始， 这是为了支持Java语言的运行时绑定特性（也称为动态绑定或晚期绑定）。
1、加载（Loading） ”加载“是”类加载“的一个阶段，再这个阶段Java虚拟机需要完成三件事：
通过一个类的全限定名来获取定义此类的二进制字节流。将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。再堆中生成一个代表这个类的Class对象，作为方法区这个类的各种数据的访问入口。 就是将 java的字节码文件(.Class）文件加载到内存当中，然后在方法区当中根据这个文件构建这个类的类模型，这个类包含了从字节码文件中解析出来的常量池、类方法、等信息。然后再堆中生成这个java.lang.Class对象，用来封装方法区内的类模型的数据结构。反射就是通过这个Class对象提供的接口去访问方法区中的数据模型。（类加载器完成），Class 类的构造方法是私有的，只有 JVM 能够创建。
数组情况有些不同，数组类本身不是通过类加载器完成，而是由Java虚拟机直接再内存中动态构造出来。数组内的元素是通过类的加载器完成的。
2、连接（Linking） 2.1 验证（Verification） 验证是连接阶段的第一步，这一步骤是为了确保Class文件的字节流包含的信息符合规范，确保这些信息再运行后不会危害虚拟机自身安全。
2.1.1、文件格式验证
这提阶段要验证的字节流是否符合Class文件格式规范，并且能被当前版本虚拟机处理，例如是否以魔数0xCAFEBABE开头，主、次版本号是否在当前Java虚拟机接受范围之内等等。只有经过哟了这部分的验证之后字节流才能进入到方法区当中去储存，后面三个验证阶段则是再方法区进行的。
2.1.2、元数据验证（元数据：描述数据的数据。）
这个部分是对字节码描述信息进行语义分析，如这个类是否有父类，这个类的父类是否有继承了不被允许的类、抽象方法是否有实现等等，看看有没有错误。
2.1.3、字节码验证
字节码验证也是验证过程中最为复杂的一个过程。它试图通过对字节码流的分析，判断字节码是否可以被正确地执行。比如：在字节码的执行过程中，是否会跳转到一条不存在的指令。函数的调用是否传递了正确类型的参数。变量的赋值是不是给了正确的数据类型等。
如果一个类型中有方法体的字节码没有通过字节码验证，那它肯定是有问题的；但如果一个方法 体通过了字节码验证，也仍然不能保证它一定就是安全的。即使字节码验证阶段中进行了再大量、再 严密的检查，也依然不能保证这一点。
2.1.4、符号引用验证
最后一个阶段的校验行为发生在虚拟机将符号引用转化为直接引用[3]的时候，这个转化动作将在 连接的第三阶段——解析阶段中发生。符号引用验证可以看作是对类自身以外（常量池中的各种符号 引用）的各类信息进行匹配性校验，通俗来说就是，该类是否缺少或者被禁止访问它依赖的某些外部 类、方法、字段等资源。本阶段通常需要校验下列内容：
符号引用中通过字符串描述的全限定名是否能找到对应的类。在指定类中是否存在符合方法的字段描述符及简单名称所描述的方法和字段。 ....... 就是检查你写的类内依赖的其他类的信息能不能用，会不会找不到或者没有权限等。
2.2 准备（Preparation） 准备阶段是正式为类中定义的变量（静态变量）分配内存并设置类变量的初始值阶段。这些变量所使用的内存再方法区（JKD7即以前用永久代实现，JDK8及以后由元空间实现）。此时这个赋初值并不是我们写的哪些初始化操作，例如 public static int a = 333；，再准备阶段a的值并不是333，而是0，这里的赋初值是赋零值。
注意：
这里不包含基本数据类型的字段用 static final 修饰的情况，因为 final 在编译的时候就会分配了。注意这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到 Java 堆中在这个阶段不会像初始化阶段中那样会有初始化或者代码被执行。 2.3 解析（Resolution） 符号引用 ：符号引用以一组符号来描述所引用的目标，符号可以是任何 形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引 用的目标并不一定是已经加载到虚拟机内存当中的内容。
直接引用 ：直接引用是可以直接指向目标的指针、相对偏移量或者是一个能 间接定位到目标的句柄。直接引用是和虚拟机实现的内存布局直接相关的，同一个符号引用在不同虚 拟机实例上翻译出来的直接引用一般不会相同。
所谓解析就是将符号引用转为直接引用。也就是得到类、字段、方法在内存中的指针或者偏移量。因此，可以说，如果直接引用存在，那么可以肯定系统中存在该类、方法或者字段。但只存在符号引用，不能确定系统中一定存在该结构。
3、初始化（Initialization） 初始化阶段是类加载的最后一个步骤，再之前的加载阶段中处理加载阶段可以用用户子自定义类加载器的方式参与，其他时候都是由JVM自己主导控制的，到了初始化阶段才正式的使用我们自己写的java代码了，再这个阶段有一个执行类构造器方法需要我们去了解：&lt;clinit&gt;()方法，这个给方法并不是我们编写的，而是javac编译器自动生成的。
&lt;clinit&gt;()方法方法是由编译器自动收集类中所有的类变量(static)的赋值动作和静态语句块合并而成的。
那类什么是进行初始化呢（以下情况都是还未被初始化）？
使用new关键字实例化对象的时候。读取或设置一个类型的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）的时候。调用一个类型的静态方法的时候。使用java.lang.reflect包的方法对类型进行反射调用的时候。如果类型没有进行过初始化，则需 要先触发其初始化。当初始化类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先 初始化这个主类。当使用JDK 7新加入的动态语言支持时，如果一个java.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e84daecfa441ad19690ef79e65c7ff1c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e31a1105b0139195a251c76abe266062/" rel="bookmark">
			WebSocket-黑马好客租房
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 网站中的消息功能如何实现？什么是WebSocket？http与websocket的区别httpwebsocket 浏览器支持情况快速入门创建itcast-websocket工程websocket的相关注解说明实现websocket服务测试编写js客户端 SpringBoot整合WebSocket导入依赖编写WebSocketHandler编写配置类编写启动类测试websocket拦截器 网站中的消息功能如何实现？ 思考：像这样的消息功能怎么实现？ 如果网页不刷新，服务端有新消息如何推送到浏览器？
解决方案，采用轮询的方式。即：通过js不断的请求服务器，查看是否有新数据，如果有，就获取到新数据。
这种解决方法是否存在问题呢？
当然是有的，如果服务端一直没有新的数据，那么js也是需要一直的轮询查询数据，这就是一种资源的浪费。
那么，有没有更好的解决方案？ 有！那就是采用WebSocket技术来解决。
什么是WebSocket？ WebSocket 是HTML5一种新的协议。它实现了浏览器与服务器全双工通信(full-duplex)。一开始的握手需要借助HTTP请求完成。 WebSocket是真正实现了全双工通信的服务器向客户端推的互联网技术。 它是一种在单个TCP连接上进行全双工通讯协议。Websocket通信协议与2011年倍IETF定为标准RFC 6455，Websocket API被W3C定为标准。
全双工和单工的区别？
全双工（Full Duplex）是通讯传输的一个术语。通信允许数据在两个方向上同时传输，它在能力上相当于两个单工通信方式的结合。全双工指可以同时（瞬时）进行信号的双向传输（A→B且B→A）。指A→B的同时B→A，是瞬时同步的。单工、半双工（Half Duplex），所谓半双工就是指一个时间段内只有一个动作发生，举个简单例子，一条窄窄的马路，同时只能有一辆车通过，当目前有两辆车对开，这种情况下就只能一辆先过，等到头儿后另一辆再开，这个例子就形象的说明了半双工的原理。早期的对讲机、以及早期集线器等设备都是基于半双工的产品。随着技术的不断进步，半双工会逐渐退出历史舞台。 http与websocket的区别 http http协议是短连接，因为请求之后，都会关闭连接，下次重新请求数据，需要再次打开链接。
websocket WebSocket协议是一种长链接，只需要通过一次请求来初始化链接，然后所有的请求和响应都是通过这个TCP链接进行通讯。
浏览器支持情况 快速入门 创建itcast-websocket工程 pom.xml
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;cn.itcast.websocket&lt;/groupId&gt; &lt;artifactId&gt;itcast-websocket&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;javax&lt;/groupId&gt; &lt;artifactId&gt;javaee-api&lt;/artifactId&gt; &lt;version&gt;7.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;!-- java编译插件 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.2&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;!-- 配置Tomcat插件 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e31a1105b0139195a251c76abe266062/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e294f69e91f5d2a1481d4bf913d0ef32/" rel="bookmark">
			数据分析师必会的SQL命令！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CREATE 创建表、数据库 CREATE DATABASE company; USE在同一个localhost上选择不同的 database # USE 这个database的名字 USE onlytest2 在database中创建一个table
第一行写你要创建的表的名字是什么
从第二行开始，第一个元素是列名，第二个元素是这一列的数据的类型，两个元素之间用空格分割，每一列的描述之间用逗号分割
USE onlytest2; CREATE TABLE stest8( id INT, 规定的类型是整数，你写小数、字符串进去都录入不进去 name VARCHAR(20), # 名字是字符串变量，长度不许超过20个字节 sex ENUM('男','女'), # 只能从男女中选 ruxueriqi DATE, # 类型是时间，年份 birthday DATETIME); # 类型是时间 在MySQL5.0以上VARCHAR(20)表示可以存储20个汉字。
下面是你打算存21个汉字，保存的时候会报错
21个数字，报错 21个字母，报错
ENUM让你只能在后面两个中选一个，除了这两个选项之外，“男”和“女”之外的其他字符串，你想录入都录入不进去 。
DATE和DATETIME的区别如下
DATE就是 年-月-日
DATETIME是在DATE的 年-月-月 的基础上，多了 小时：分钟：秒
将一列设为主键、key自增、一列非空、默认为0
CREATE TABLE stest9( id INT PRIMARY KEY AUTO_INCREMENT, name VARCHAR(20) NOT NULL, grade FLOAT DEFAULT 0, sex ENUM('男','女'), rexueriqi DATE, birthday DATETIME # 切记，最后一列这个 结尾不要加逗号，否则会报错 ); 只要选定了某一列自增，这一列即使你不设定，也是默认设定为非空
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e294f69e91f5d2a1481d4bf913d0ef32/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7948fd98d02eaed17f560a16785014da/" rel="bookmark">
			React16源码: React中的updateClassComponent的源码实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ClassComponent 的更新 1 ） 概述
在 react 中 class component，是一个非常重要的角色它承担了 react 中 更新整个应用的API setStateforceUpdate 在react当中，只有更新了state之后，整个应用才会重新进行渲染在 class component 中, 它的逻辑相对复杂 2 ）源码
在 packages/react-reconciler/src/ReactFiberBeginWork.js
// 这个方法就是更新 ClassComponent 组件的一个过程 function updateClassComponent( current: Fiber | null, workInProgress: Fiber, Component: any, nextProps, renderExpirationTime: ExpirationTime, ) { // Push context providers early to prevent context stack mismatches. // During mounting we don't know the child context yet as the instance doesn't exist. // We will invalidate the child context in finishClassComponent() right after rendering.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7948fd98d02eaed17f560a16785014da/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a59f418e58ed65fa9862ee5547eff39a/" rel="bookmark">
			GPT属于AI，是LLM的一种实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		GPT（Generative Pre-trained Transformer）作为一种创新的语言模型，既属于人工智能（AI）的一部分，也是大规模语言模型（LLM）的一种实现。本文将探讨GPT在AI和LLM领域的重要性和影响。
GPT（Generative Pre-trained Transformer）是一种基于深度学习的语言模型，它的出现标志着AI技术在自然语言处理领域的重要突破。作为AI的一部分，GPT利用大规模的训练数据和深度学习算法，使得计算机能够生成人类类似的文本。
然而，GPT不仅是AI的一部分，它也是LLM的一种实现。LLM是指大规模语言模型，旨在模拟人类的语言能力。GPT通过训练大量的文本数据，学习到了丰富的语言知识和模式，并能够根据输入的上下文生成具有逻辑和连贯性的文本回复。
GPT的实现基于Transformer架构，这是一种基于注意力机制的深度学习模型。通过多层次的神经网络结构，GPT能够从输入的文本中提取上下文信息、语法规则和语义关联，从而生成高质量的文本输出。这种能力使得GPT在对话、写作和编程等任务中表现出了令人惊叹的智能。
GPT的应用领域广泛而多样。例如在Phoncent博客上，GPT可以与用户进行交流，回答问题，提供建议和解决方案。在写作方面，GPT可以辅助创作，提供灵感和内容生成。在编程方面，GPT可以生成代码片段，提供编程指导和解决方案。这些应用使得GPT成为一个强大的工具，为用户提供了便捷、高效的创作和学习环境。
然而，我们要认识到GPT作为AI的一部分，也存在一些挑战和限制。例如，GPT在理解复杂语义、处理歧义和缺乏常识推理等方面仍然存在一定的局限性。此外，GPT的输出也可能受到训练数据的偏见和错误的影响，需要谨慎使用和评估。
综上所述，GPT作为AI的一部分，同时也是LLM的一种实现，为我们展示了语言模型在自然语言处理领域的巨大潜力。它的出现为对话、写作和编程等任务提供了全新的解决方案。我们也要保持对其局限性和挑战的认识，并不断推动AI技术的发展和改进。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09802df1aefa7f6d38a57b700783b45d/" rel="bookmark">
			Jetson Orin Nano使用OpenCV获取视频帧率和帧数的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		测试过程 首先确认下视频的播放时间
使用cv库来获取帧率和帧数，测试代码如下
import cv2 cap = cv2.VideoCapture("xxx.mp4") if not cap.isOpened(): print("Cannot open camera") exit() # get default video FPS fps = cap.get(cv2.CAP_PROP_FPS) # get total number of video frames num_frames = cap.get(cv2.CAP_PROP_FRAME_COUNT) print("fps is %d , sum of frames is %d " % (fps, num_frames)) cap.release() cv2.destroyAllWindows() python3运行结果，30fps，总帧数807
计算验证，fps含义，多少帧frame每秒，视频的时间就等于总帧数/fps，807/30=26.9s，符合我们最开始看到的视频时间
视频讲解 Jetson Orin Nano使用OpenCV获取视频帧率和帧数的方法
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53018dc824788fc2bb8a59596ff63bcf/" rel="bookmark">
			Linux的权限（3）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
文件类型
​d目录文件
-普通文件
l链接文件
b块设备文件
p管道文件
c字符设备文件
文件权限
目录权限
umask
粘滞位
Q1umask权限默认值664/775
Q2"可执行性"权限
Q3"删除"权限
Q4怎么共享一批文件
【1】粘滞位
【2】添加交互人员到所属组
文件类型 Linux通过ls -l 的第一个属性列来区分
window是区分文件类型的：后缀名
Linux不通过后缀区分文件类型！但是并不表示Linux不用后缀名
Linux系统不以文件后缀作为区分文件的类型，并不代表gcc不需要！（Linux系统不等于gcc)
总而言之，Linux不区分文件类型，但是Linux上面的工具可能区分。对Linux文件后缀的态度是可以使用！
d目录文件 -普通文件 文本文件，可执行程序，库等都可以称为普通文件。
l链接文件 b块设备文件 p管道文件 c字符设备文件 显示器的本质是字符设备
文件权限 文件权限：文件的访问控制权限，即哪些用户和组群可以访问文件以及可以执行什么操作。
权限=用户角色（具体的人）+文件权限属性
33为一组分别三个角色：拥有者，所属组，other
这些角色对应两种人：root超级用户，普通用户
33中一个3：第一个字符：是否具有读权限：是r，否-33中一个3：第二个字符：是否具有写权限：是w，否-33中一个3：第三个字符：是否具有可执行权限：是x，否- 目录权限 x权限：进入一个目录r权限：用户能否查看指定目录内的文件信息w权限：决定用户是否能在指定的目录内新建/修改/删除文件文件（目录）=文件内容+文件属性目录就是文件目录的文件内容：就是里面所有文件信息详细数据情况 可执行权限: 如果目录没有可执行权限, 则无法cd到目录中
可读权限: 如果目录没有可读权限, 则无法用ls等命令查看目录中的文件内容
可写权限: 如果目录没有可写权限, 则无法在目录中创建文件, 也无法在目录中删除文件
umask umask
功能：查看或修改文件掩码
新建文件夹默认权限=0666
新建目录默认权限=0777
但实际上你所创建的文件和目录，看到的权限往往不是上面这个值。原因就是创建文件或目录的时候还要受到umask的影响。假设默认权限是mask，则实际创建的出来的文件权限是: mask &amp; ~umask
格式：umask 权限值
说明：将现有的存取权限减去权限掩码后，即可产生建立文件时预设权限。超级用户默认掩码值为0022，普通用户默认为0002。
粘滞位 [root@localhost ~]# chmod +t /home/ # 加上粘滞位 [root@localhost ~]# ls -ld /home/ drwxrwxrwt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/53018dc824788fc2bb8a59596ff63bcf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9081cdb5327c82df94c0297d12d36bf4/" rel="bookmark">
			C语言从入门到实战——文件操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文件操作 前言一、 为什么使用文件二、 什么是文件2.1 程序文件2.2 数据文件2.3 文件名 三、 二进制文件和文本文件四、 文件的打开和关闭4.1 流和标准流4.1.1 流4.1.2 标准流 4.2 文件指针4.3 文件的打开和关闭4.4 文件的路径 五、 文件的顺序读写5.1 顺序读写函数介绍fgetcfputcfgetsfputsfscanffprintffreadfwrite 5.2 对比一组函数sscanfsprintf 5.3标准的数据拷贝 六、 文件的随机读写6.1 fseek6.2 ftell6.3 rewind 七、 文件读取结束的判定fgetcfgets7.1 被错误使用的 feof 八、 文件缓冲区 前言 C语言中的文件操作是通过使用文件指针来实现的。可以使用标准库中的函数来打开、读取、写入和关闭文件。
下面是一些常见的文件操作函数：
打开文件：使用 fopen() 函数来打开文件，该函数接受两个参数，文件名和打开方式。打开方式可以是 "r"（只读模式），"w"（写入模式），"a"（追加模式）等等。函数返回一个文件指针，可以在后续的操作中使用。 FILE *fp; fp = fopen("filename.txt", "r"); 读取文件内容：使用 fscanf() 函数来从文件中读取内容。该函数接受一个文件指针和一个格式字符串作为参数，读取文件中的数据并按照格式字符串的指示将数据存储到相应的变量中。 int num; fscanf(fp, "%d", &amp;num); 写入文件内容：使用 fprintf() 函数来向文件中写入内容。该函数接受一个文件指针和一个格式字符串作为参数，将相应的数据按照格式字符串的指示写入文件。 int num = 10; fprintf(fp, "%d", num); 关闭文件：使用 fclose() 函数来关闭文件，该函数接受一个文件指针作为参数。 fclose(fp); 在进行文件操作时，需要注意以下几点：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9081cdb5327c82df94c0297d12d36bf4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36967e1251499d6fd534ce5e7f81b36d/" rel="bookmark">
			socket实现视频通话-WebRTC
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近喜欢研究视频流，所以思考了双向通信socket，接下来我们就一起来看看本地如何实现双向视频通讯的功能吧~
客户端获取视频流
首先思考如何获取视频流呢？
其实跟录音的功能差不多，都是查询电脑上是否有媒体设备，如果有录音和录像的设备，首先就需要授权，然后将视频流通过socket传输给服务端。
获取媒体设备
const stream = await navigator.mediaDevices.getUserMedia({ audio: true, video: true }) 因为是打视频的功能，那A客户端本身也希望看到A的摄像头，所以我们直接将其赋值给一个video标签，就能看到图像了.
&lt;p&gt;这是A页面&lt;/p&gt; &lt;div class="local-stream-page"&gt; &lt;video autoplay controls muted id="elA"&gt;&lt;/video&gt; &lt;button onclick="onStart()"&gt;打视频给B页面&lt;/button&gt; &lt;/div&gt; &lt;script&gt; try { const stream = await navigator.mediaDevices.getUserMedia({ audio: true, video: true }) if (videoElA) { videoElA.srcObject = stream // 在 video 标签上播放媒体流 } peerInit(stream) // 初始化连接 } catch (error) { console.log('error：', error) } &lt;/script&gt; 然后就是重要部分了，我们需要用到WebRTC的API
RTCPeerConnection
RTCPeerConnection是WebRTC API中的一个对象，用于建立和管理两个或多个用户之间的实时通信。它允许通过互联网进行音频和视频通话，以及共享数据流。
RTCPeerConnection对象提供了一系列的方法和事件，用于配置、管理和控制媒体流的传输。它支持使用不同的技术，如ICE（Interactive Connectivity Establishment）和STUN（Session Traversal Utilities for NAT）来解决网络地址转换（NAT）问题，以便在防火墙后面的不同设备之间建立连接。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/36967e1251499d6fd534ce5e7f81b36d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2121711b4f02383937ff1b36c469cdf9/" rel="bookmark">
			【Java】数据库连接池--Druid
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据库连接池 数据库连接池是一个容器，负责分配、管理数据库连接(Connection)它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个释放空闲时间超过最大空闲时间的数据库连接来避免因为没有释放数据库连接而引起的数据库连接遗漏好处： 资源重用提升系统的响应速度避免数据库连接遗漏 标准接口DataSource 功能：获取连接
Connection getConnection(); 常见的数据库连接池：
DBCPC3P0Druid Druid连接池是阿里巴巴开源的数据库连接池项目，功能强大，性能优秀。
Druid使用步骤 导入jar包 druid-1.1.12.jar定义配置文件加载配置文件获取数据库连接池对象获取连接 driverClassName=com.mysql.jdbc.Driver url=jdbc:mysql:///db1?useSSL=false&amp;useServerPrepStmts=true username=root password=1234 # 初始化连接数量 initialSize=5 # 最大连接数 maxActive=10 # 最大等待时间 maxWait=3000 package Druid; import com.alibaba.druid.pool.DruidDataSourceFactory; import javax.sql.DataSource; import java.io.FileInputStream; import java.sql.Connection; import java.util.Properties; public class DruidDemo { public static void main(String[] args) throws Exception { //1.导入jar包 //2.定义配置文件 //3.加载配置 Properties prop=new Properties(); prop.load(new FileInputStream("C:\\Users\\Hayaizo\\IdeaProjects\\jdbc\\jdbc_test\\src\\druid.properties")); //4.获取连接池对象 DataSource dataSource=DruidDataSourceFactory.createDataSource(prop); //5.获取数据库连接Connection Connection connection = dataSource.getConnection(); System.out.println(connection); } } druid配置详解 属性说明建议值url数据库的jdbc连接地址。一般为连接oracle/mysql。示例如下：mysql : jdbc:mysql://ip:port/dbname?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2121711b4f02383937ff1b36c469cdf9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0506d7f63e4a896818756b28912b827a/" rel="bookmark">
			jvm复习，深入理解java虚拟机一：运行时数据区域
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		程序计数器（Program Counter Register） 它是程序控制流的指示器，简单来说，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器
Java虚拟机栈（Java Virtual Machine Stack）也是线程私有的，它的生命周期 与线程相同。虚拟机栈描述的是Java方法执行的线程内存模型。
本地方法栈（Native Method Stacks）本地方法栈是为虚拟机使用到的本地（Native） 方法服务。
Java堆（Java Heap）是虚拟机所管理的内存中最大的一块。Java堆是被所 有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例。
这里可能会考点面试题，什么垃圾回收器之类的。
方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载 的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。
说到方法区，不得不提一下“永久代”这个概念，尤其是在JDK 8以前，许多Java程序员都习惯在 HotSpot虚拟机上开发、部署程序，很多人都更愿意把方法区称呼为“永久代”（Permanent Generation），或将两者混为一谈。本质上这两者并不是等价的，因为仅仅是当时的HotSpot虚拟机设 计团队选择把收集器的分代设计扩展至方法区，或者说使用永久代来实现方法区而已。
元空间（Metaspace）是 Java 虚拟机中方法区（Method Area）的一种实现。
元空间的引入旨在解决永久代的一些问题，如内存泄漏和溢出。元空间的特点包括：
动态分配： 元空间不再有固定的大小限制，它会根据应用程序的需要进行动态分配和释放内存。
GC（垃圾回收）管理： 类的元数据现在由 JVM 的垃圾回收器进行管理。这意味着当类不再被使用时，相关的元数据可以被垃圾回收器回收。
避免永久代的问题： 元空间的动态性质和垃圾回收的管理有助于避免永久代常见的内存泄漏和溢出问题。
运行时常量池（Runtime Constant Pool）是方法区的一部分。Class文件中除了有类的版本、字 段、方法、接口等描述信息外，还有一项信息是常量池表（Constant Pool Table），用于存放编译期生 成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。
这部分较为简单，我这边就不怎么介绍了，关于垃圾回收器的几种算法，什么类型的垃圾回收器，我下下篇文章可能会写到。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86f81ad5b71f41674e9cfeecbb2b1173/" rel="bookmark">
			Mysql 数据库 DQL 数据查询语言相关sql语句（简单查询，条件查询）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据库中的相关概念 库：数据库，内部存放着所有的表、视图、索引等内容
表：是数据库存储数据的基本单位，由行和列组成
列：又称为字段，是表的基本组成单位，相当于Java类中的属性
行：是表的基本组成单位，具体数据，每行信息是一个整体，由固定字段构成。相当于Java中由类实例化出来的一个又一个的对象
SQL SQL：结构化查询语言，提供了对数据库数据的增删改查操作对应的处理
SQL是一种规范，也是一种国际标准，所有的关系型数据库都支持SQL，不被MySQL独有
特点 不区分大小写
注释：
单行：-- (--空格)
多行：/* */
简单查询 查询所有字段 -- 查询所有列：select * from 表名（*：是通配符，表示所有列） select * from employees 查询部分字段 select 列名1,列名2,... from 表名 也可以通过列出所有字段名的方式查询所有字段
优点：
效率更快
可读性较好
可维护性较高
缺点：
书写繁琐
-- 查询所有字段 SELECT * from employees -- 查询员工id、员工工资 select employee_id,salary from employees -- 列出所有字段名查询所有字段 select employee_id,salary,first_name,last_name,email,phone_number,job_id,commission_pct,manager_id,department_id,hiredate from employees 结果运算 +、-、*、/、%
select 列名 运算符 值 from 表名 -- 查询员工id和工资，及对工资进行加减乘除的运算 select employee_id,salary,salary+100,salary-100,salary*100,salary/100,salary%100 from employees 别名 对查询之后的结果起别名
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/86f81ad5b71f41674e9cfeecbb2b1173/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a19a644faa2a0356eb27f9850967f4d/" rel="bookmark">
			力扣：474. 一和零（动态规划）（01背包）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目： 给你一个二进制字符串数组 strs 和两个整数 m 和 n 。
请你找出并返回 strs 的最大子集的长度，该子集中 最多 有 m 个 0 和 n 个 1 。
如果 x 的所有元素也是 y 的元素，集合 x 是集合 y 的 子集 。
示例 1：
输入：
strs = [“10”, “0001”, “111001”, “1”, “0”], m = 5, n = 3
输出：
4
解释：
最多有 5 个 0 和 3 个 1 的最大子集是 {“10”,“0001”,“1”,“0”} ，因此答案是 4 。
其他满足题意但较小的子集包括 {“0001”,“1”} 和 {“10”,“1”,“0”} 。{“111001”} 不满足题意，因为它含 4个 1 ，大于 n 的值 3 。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1a19a644faa2a0356eb27f9850967f4d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c2c19cac39534d724824a48e47fc2da/" rel="bookmark">
			使用OpenCV从一个矩阵提取子矩阵
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		介绍opencv的两个函数：Range()和Rect()
Range()是用于表示一个范围的类。它的构造函数有两个整数参数，分别表示范围的起始和终止索引。这个范围包括起始索引但不包括终止索引。
cv::Range(int start, int end); /* 在OpenCV中，cv::Range() 主要用于 cv::Mat 的行、列、或通道的选择。例如，你可以使用 cv::Mat 的 rowRange()、colRange()、channel() 等函数，并通过 cv::Range() 指定相应的范围。 */ Rect()是用于表示一个矩形区域的类。它的构造函数有四个整数参数，分别表示矩形的左上角坐标的 x 和 y，以及矩形的宽度和高度。
cv::Rect(int x, int y, int width, int height); /* 在OpenCV中，cv::Rect() 主要用于表示矩阵的子矩阵的区域。例如，你可以使用 cv::Mat 的 rowRange()、colRange() 等函数，并通过 cv::Rect() 指定相应的区域。 */ 下面通过代码演示：
#include &lt;opencv2/opencv.hpp&gt; int main() { // 定义一个转换矩阵T /* T=[R,t 0,1] R为3x3的旋转矩阵，t为1x3的平移矩阵 */ cv::Mat T=(cv::Mat_&lt;double&gt;(4, 4) &lt;&lt; 0.9996238460064014, -0.01649257893348039, -0.02191258395290964,-0.07806970076422, 0.01627794636500941, 0.9998181209081466, -0.009937482872516265, 0.001608557714, 0.02207249323271539, 0.009577052982343131, 0.9997105006443944, -0.00261919831793, 0,0,0,1.000000000000000); std::cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9c2c19cac39534d724824a48e47fc2da/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4983c6382547c22b69670c55ead88de/" rel="bookmark">
			微服务面试题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录
1.Spring cloud五大组件
2.服务注册和发现是什么意思?Spring cloud如何实现服务注册发现
3.负载均衡如何实现
4.什么是服务雪崩?如何解决
5.微服务是怎么监控的
6.限流
7.解释CAP和BASE
8.分布式事务解决方案
9.分布式服务接口幂等性
10.分布式任务调度
1.Spring cloud五大组件 2.服务注册和发现是什么意思?Spring cloud如何实现服务注册发现 3.负载均衡如何实现 4.什么是服务雪崩?如何解决 5.微服务是怎么监控的 6.限流 7.解释CAP和BASE 8.分布式事务解决方案 9.分布式服务接口幂等性 10.分布式任务调度 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d19831eb70cc03ac680da71a53f9347/" rel="bookmark">
			原神官网切换效果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这两天来研究一下原神游戏官网的效果，只是我个人理解。
地址：《原神》官方网站-全新4.3版本「蔷薇与铳枪」上线！ (mihoyo.com)
继续用我之前的模板项目：
等我把这一页写满，会上传原码。 效果很多，我们先看第一个：
1.滚轮切换 先看效果图：
这看起来像什么呢？ 是不是很像轮播图呀，就是把轮播图变成垂直，然后触发滚动方式变成滚轮触发。
好，我现来偷个懒，使用element的走马灯的组件。
&lt;template&gt; &lt;div class="mainrouter" style="padding: 0px;overflow-y: auto;"&gt; &lt;div class="box"&gt; &lt;div style="height: 100%" @mousewheel="rollScroll($event)"&gt; &lt;el-carousel ref="carousel" direction="vertical" :autoplay="false" trigger="click" :loop="false" @mousewheel="rollScroll($event)"&gt; &lt;el-carousel-item v-for="(item, index) in 4" :key="index" class="item"&gt; &lt;div class="font"&gt; &lt;img :src="src[index]" alt=""&gt; &lt;/div&gt; &lt;/el-carousel-item&gt; &lt;/el-carousel&gt; &lt;/div&gt; &lt;el-footer v-if="thiscarousel == 4"&gt; &lt;div style="width: 100%;height:100px;text-align: center;background-color: aliceblue;"&gt; fOOTER &lt;/div&gt; &lt;/el-footer&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script setup&gt; import { ref } from 'vue'; import { onMounted } from 'vue'; const name = 'home'; const timeOut = ref(null); const carousel = ref(null); // 添加对 carousel 的引用 const thiscarousel = ref(1)//标识一下轮播图轮播到第几个了 // 绑定尾部 const footer = ref(false) const rollScroll = (event) =&gt; { const scrollVal = event.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9d19831eb70cc03ac680da71a53f9347/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f8133e3ca97c14870ed0d6f615e3d39/" rel="bookmark">
			Linux指令&amp;权限知识点总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录
周边知识
基础指令思维导图 权限思维导图 周边知识 大多数后端操作系统都是Linux操作系统操作系统是管理软件和硬件的软件Linux是一款操作系统Linux分为技术版本和商业版本Linux的文件是以多叉树的形式构建隐藏文件 . 和 ...可以表示当前路径。可以形成可执行文件，如./a.out..可以回退到上一个路径路径分隔符/【1】树状结构特点是叶子节点只有一个父节点【2】路径具有唯一性【3】可以用路径来标识一个文件绝对路径和相对路径mv 还有重命名的作用Linux底下一切皆文件输出重定向&gt;追加重定向&gt;&gt;输入重定向&lt;管道 |时间戳find命令重点研究🔺打包压缩的益处重点在：方便网络传输和防止文件丢失uname -rshell外壳程序 基础指令思维导图 权限思维导图 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e3e542b5bede7807bae76c6360afca3/" rel="bookmark">
			算法滑动窗口系列-Day8-长度最小的子数组
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、题目链接二、题目描述三、解法一（暴力求解会超时）四、解法二（滑动窗口）五、代码编写 前言 滑动窗口第一题
一、题目链接 长度最小的子数组
二、题目描述 三、解法一（暴力求解会超时） 算法思路：
[从前往后]枚举数组中的任意一个元素，把它当成起始位置。然后从这个「起始位置」开始，然后寻找一段最短的区间，使得这段区间的和[大于等于]目标值。将所有元素作为起始位置所得的结果中，找到「最小值」即可。
class Solution { public: int minSubArrayLen(int target, vector&lt;int&gt;&amp; nums) { // 记录结果 int ret = INT_MAX; int n = nums.size(); // 枚举出所有满足和大于等于 target 的子数组[start, end] // 由于是取到最小，因此枚举的过程中要尽量让数组的长度最小 // 枚举开始位置 for (int start = 0; start &lt; n; start++) { int sum = 0; // 记录从这个位置开始的连续数组的和 // 寻找结束位置 for (int end = start; end &lt; n; end++) { sum += nums[end]; // 将当前位置加上 if (sum &gt;= target) // 当这段区间内的和满足条件时 { // 更新结果，start 开头的最短区间已经找到 ret = min(ret, end - start + 1); break; } } } // 返回最后结果 return ret == INT_MAX ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7e3e542b5bede7807bae76c6360afca3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb217ecf4f353923ab8619cc4f0a1e7b/" rel="bookmark">
			Transformer技术深度剖析：AI语言处理的新纪元
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.Transformer全局概括 Transformer是一种深度学习模型，最初由Vaswani等人在2017年的论文《Attention Is All You Need》中提出。它在自然语言处理（NLP）领域引起了革命，因为它的设计克服了以前模型的一些限制，特别是在处理长距离依赖和并行计算方面。下面是Transformer模型的全面概述：
1.核心概念 注意力机制（Attention Mechanism）：
Transformer的核心是注意力机制，特别是所谓的“自注意力”（Self-Attention）。它允许模型在处理一个单词时同时考虑句子中的其他单词，从而捕获它们之间的上下文关系。 编码器-解码器架构：
原始的Transformer模型包括编码器（Encoder）和解码器（Decoder）。编码器读取输入数据并产生一个上下文表示，解码器则使用这个表示来生成输出数据。 多头注意力（Multi-Head Attention）：
模型对每个单词的注意力分为多个“头”，这样可以让模型在多个子空间中学习信息。这增强了模型对不同位置的敏感性，能够捕获不同类型的上下文信息。 位置编码（Positional Encoding）：
由于Transformer不使用递归或卷积，因此需要另一种方法来理解单词的顺序或位置。位置编码是添加到输入单词的一种编码，提供了单词在序列中的位置信息。 堆叠层：
Transformer中的编码器和解码器都是由多个相同的层堆叠而成。每层包含多头注意力机制和全连接的前馈网络。 2.应用 机器翻译：Transformer模型最初是为了改进机器翻译而设计的，但它迅速被应用于各种NLP任务。文本生成：如GPT系列模型，它们是基于Transformer的架构，专注于生成连贯和相关的文本。文本理解：如BERT和其变体，它们利用Transformer编码器来理解文本，广泛用于问答系统、情感分析等。 3.优势与挑战 优势：
能够捕获长距离依赖。高效的并行处理能力。在多种NLP任务上取得了先进的性能。 挑战：
模型参数通常非常庞大，需要大量的计算资源进行训练。对于输入序列的长度有限制，主要是因为计算复杂度和内存要求。 Transformer模型自推出以来，已成为NLP领域的一项关键技术，推动了包括文本分类、摘要、机器翻译等多个领域的发展。此外，它的核心思想和技术也被应用于计算机视觉和其他机器学习任务中。
2.编码器（Encoder） Transformer编码器的底层实现涉及多个组件和步骤，这些组件共同构成了Transformer编码器的核心功能。
以下是其实现流程的详细介绍：
1. 输入嵌入（Input Embedding） 首先，输入序列（如一句话中的单词或字符）被转换成固定大小的向量。这一步通常使用嵌入层完成，每个唯一的输入单元（如单词）都被映射到高维空间中的一个稠密向量。
2. 位置编码（Positional Encoding） 由于Transformer本身不具备捕捉序列中位置信息的能力，因此需要向输入嵌入中添加位置信息。位置编码是一个与嵌入向量维度相同的向量，它为模型提供了每个单元在序列中的位置信息。位置编码通常使用正弦和余弦函数的组合来生成，并与输入嵌入相加。
3. 多头自注意力（Multi-Head Self-Attention） 在加入了位置信息的嵌入向量之后，接下来是多头自注意力层。这一层让模型能够同时关注输入序列中的多个位置。具体来说，它包括以下步骤：
线性投影：首先，输入向量被线性投影成三组向量，分别是查询（Q），键（K），值（V）。点积注意力：对于每个头，使用缩放的点积注意力计算注意力得分，即通过计算查询和键的点积来确定值的权重。组合头的输出：每个头的输出被拼接起来，并通过另一个线性投影层进行处理。 4. 残差连接和层归一化（Residual Connection and Layer Normalization） 每个子层（如自注意力层）的输出通过一个残差连接添加回输入，并进行层归一化。残差连接有助于避免深层网络中的梯度消失问题，而层归一化则有助于稳定训练过程。
5. 前馈网络（Feed-Forward Network） 每个编码器层还包括一个前馈网络，它对每个位置的向量独立地进行处理。这通常是两个线性变换和一个非线性激活函数（如ReLU）。
6. 再次应用残差连接和层归一化 与自注意力层类似，前馈网络的输出也通过残差连接，然后应用层归一化。
Transformer编码器的每一层都重复上述流程。输入数据流经每一层，逐渐添加更多的上下文信息。通过堆叠多个这样的层，编码器能够捕捉输入数据中的复杂模式和关系。这种架构的关键优点是其能够处理长距离依赖关系，并且由于其并行化的特性，适合于大规模数据处理。
3.位置编码 在Transformer模型中，位置编码（Positional Encoding）是一个关键的组成部分。由于Transformer依赖于自注意力机制，它不像传统的递归神经网络（RNN）或卷积神经网络（CNN）那样自然地处理输入序列中的顺序信息。为了让模型能够理解单词在句子中的顺序，引入了位置编码。
1.为什么需要位置编码 Transformer中的自注意力机制在处理输入时是位置不变的（position-invariant），这意味着如果不添加额外的位置信息，模型就无法知道单词在句子中的顺序。位置编码的目的是为每个单词提供其在序列中位置的信息，从而使Transformer能够利用单词的顺序信息。 2.如何计算位置编码 位置编码是通过数学公式计算得到的，并与每个单词的嵌入向量相加。对于位置pos（一个整数，表示单词在序列中的位置）和维度i（嵌入向量的维度索引），位置编码PE(pos, i)的计算方法如下：
对于偶数索引i：
P E ( p o s , 2 i ) = sin ⁡ ( p o s 1000 0 2 i / d ) PE(pos, 2i) = \sin\left(\frac{pos}{10000^{2i/d}}\right) PE(pos,2i)=sin(100002i/dpos​)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cb217ecf4f353923ab8619cc4f0a1e7b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/972ef2838ae654f0d94ff95289bd2c17/" rel="bookmark">
			力扣：494. 目标和（动态规划）（01背包）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目： 给你一个非负整数数组 nums 和一个整数 target 。
向数组中的每个整数前添加 ‘+’ 或 ‘-’ ，然后串联起所有整数，可以构造一个 表达式
例如，nums = [2, 1] ，可以在 2 之前添加 ‘+’ ，在 1 之前添加 ‘-’ ，然后串联起来得到表达式 “+2-1” 。
返回可以通过上述方法构造的、运算结果等于 target 的不同 表达式 的数目。
示例 1：
输入：
nums = [1,1,1,1,1], target = 3
输出：
5
解释：
一共有 5 种方法让最终目标和为 3 。
-1 + 1 + 1 + 1 + 1 = 3
+1 - 1 + 1 + 1 + 1 = 3
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/972ef2838ae654f0d94ff95289bd2c17/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c4c574ef8186f916be143a5f4ce1bd1/" rel="bookmark">
			laravel8.*集成dingo
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		learnku中的dingo版本为2+，不支持laravel8
实际上dingo已经出到了4+，已经支持laravel9
社区活跃度已经不高了，本人特别讨厌重复造轮子，这里特此记录下
文档地址：https://learnku.com/docs/dingo-api/3.x
github地址：https://github.com/api-ecosystem-for-laravel/dingo-api
首先安装与对应laravel8兼容的dingo3
composer require dingo/api:3.* 配置基础参数config/api.php
'version' =&gt; env('API_VERSION', 'v1'), 'prefix' =&gt; env('API_PREFIX', 'api'), 'auth' =&gt; [ 'jwt' =&gt; 'Dingo\Api\Auth\Provider\JWT', ], 需要注意的地方，我使用的auth是JWT，那么你对应的需要安装JWT
composer require tymon/jwt-auth php artisan jwt:secret 编写路由做测试
$api = app('Dingo\Api\Routing\Router'); $api-&gt;version('v1', function ($api) { $api-&gt;get('/test', function ($api) { return 1; }); }); 访问方式为：http://域名/api/test
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1679bfec2d08a0d0dd3841e7941d0a5/" rel="bookmark">
			基于springboot的党员学习交流平台
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		收藏关注不迷路，源码文章末
文章目录 一、项目介绍二、开发环境三、功能介绍四、核心代码五、效果图六、文章目录 一、项目介绍 党员学习交流平台管理系统按照操作主体分为管理员和用户。管理员的功能包括管理作业，管理党员学习交流平台信息，包括试卷管理，课程，试题管理，作业提交等，可以管理课程。用户的功能包括管理部门以及部门岗位信息，管理试卷信息，培训信息，薪资信息等。该系统采用了Mysql数据库，Java语言，Spring Boot框架等技术进行编程实现。
党员学习交流平台管理系统可以提高党员学习交流平台信息管理问题的解决效率，优化党员学习交流平台信息处理流程，保证党员学习交流平台信息数据的安全，它是一个非常可靠，非常安全的应用程序。
关键词：党员学习交流平台管理系统；Mysql数据库；Java语言
二、开发环境 开发语言：Java
框架：springboot
JDK版本：JDK1.8
服务器：tomcat7
数据库：mysql
数据库工具：Navicat11
开发软件：eclipse/myeclipse/idea
Maven包：Maven
————————————————
三、功能介绍 党员学习交流平台管理系统根据使用权限的角度进行功能分析，并运用用例图来展示各个权限需要操作的功能。
图4.1即为设计的管理员功能结构，管理员权限操作的功能包括管理作业，管理党员学习交流平台信息，包括试卷管理，课程，试题管理，作业提交等，可以管理课程。
图4.1 管理员功能结构
四、核心代码 部分代码：
package com.example.controller; import cn.hutool.core.util.StrUtil; import cn.hutool.crypto.SecureUtil; import com.example.common.Result; import com.example.common.ResultCode; import com.example.entity.Caiwu; import com.example.exception.CustomException; import com.example.service.CaiwuService; import com.example.utils.MapWrapperUtils; import com.example.utils.jwt.JwtUtil; import com.example.vo.CaiwuVo; import org.springframework.beans.BeanUtils; import org.springframework.web.bind.annotation.*; import javax.annotation.Resource; import javax.servlet.http.HttpServletRequest; import java.util.HashMap; import java.util.List; import java.util.Map; @RestController @RequestMapping(value = "/caiwu") public class CaiwuController { @Resource private CaiwuService caiwuService; @PostMapping public Result&lt;Caiwu&gt; add(@RequestBody CaiwuVo caiwu) { caiwuService.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e1679bfec2d08a0d0dd3841e7941d0a5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1c584fcc1ef2c910b6fc2319c33afa8/" rel="bookmark">
			理解Python中super函数的作用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、 在Python中super既是类也是函数 super 在Python中既是类也是函数，具体取决于上下文。在Python 3.x中，super() 函数返回一个特殊的代理对象，这个代理对象可以用来调用父类（超类）的方法。从这个角度来看，我们可以说 super 是一个通过函数调用来获取的特殊类型对象。
Python
class A: def method(self): print("A's method") class B(A): def method(self): super().method() # 这里的super()是一个函数调用，返回一个代理对象 b = B() b.method() # 输出 "A's method" 在这个例子中，super() 是作为函数使用的，用于查找并调用父类的方法。
然而，在更底层的实现上，super 实际上是一个内置类型或类，它定义了如何进行方法查找和调用。当你使用 super().__init__() 或 super().method() 时，实际上是操作了这个特殊类型的实例，并触发了其内部机制来执行相应的父类方法。所以，从这种意义上讲，super 又可以视为一种特殊类型的类。但通常在编程实践中，我们更多地将其视作一个函数，因为它总是通过调用的方式来使用。
super() 函数返回的是一个特殊类型 super 类的实例。这个类的设计主要是为了支持继承机制下的方法查找和调用。当你通过 super() 调用一个方法时，Python会根据Method Resolution Order (MRO)来动态确定应调用哪个父类的方法。
例如，在如下代码中：
Python
class A: def method(self): print("A's method") class B(A): def method(self): super().method() b = B() b.method() # 输出："A's method" 这里 super().
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b1c584fcc1ef2c910b6fc2319c33afa8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9bf543e918abfbf7b3507bafa620c91/" rel="bookmark">
			Linux-ffmpeg
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 安装ffmpeg sudo apt install ffmpeg 录制视频 播放视频 ffplay -f rawvideo -pixel_format yuv420p -video_size 640x480 output.yuv ffmpeg -f rawvideo -pixel_format yuv420p -video_size 640x480 -i output.yuv -c:v rawvideo -pixel_format yuv420p -f sdl "YUV Player" 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26f7ba8310dd2b5539a1cfb7a1b1bf59/" rel="bookmark">
			rust嵌入式之用类函数宏简写状态机定义
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		笔者一向认为，用有限状态自动机来做硬件控制是最好的选择，同时又倾向于用文本定义来定义状态机是更好的做法。所以此次用rust开发嵌入式自然也是如此。
状态机实现起来很简单，关键是用文本来定义状态机，在rust中，自然是用宏来实现。
在折腾的过程中，又是发现各种解说文章铺天盖地的，但真正有用的不多，都是泛泛而谈。所以还是老样子，写篇文章讲一下自己经过痛苦折腾后的实现，希望能帮到需要的兄弟。
目标 我希望实现的状态机的定义是：
//充电控制状态机 stateMachine!{ name: sm_charge; init: charge_close, charge_close; state: charge_close, charge_open, charge_close_wait; event: event_charge_close, event_charge_open, event_charge_timeout; active: charge_close, charge_open, charge_start_timer; trans: charge_close, event_charge_open, charge_open, charge_open; trans: charge_open, event_charge_close, charge_close_wait, charge_start_timer; trans: charge_close_wait, event_charge_timeout, charge_close, charge_close; } 即，用一个宏，以文本的方式完成整个状态机的定义【在init函数之外】，然后在init函数执行初始化时执行：
let smi_charge = sm_charge_init(); 就可以完成全部的初始化的工作。然后就可以将状态机实例smi_charge放入shared中使用了。
状态机的实现非常简单，这不是我们的重点，我们主要展示如何编写一个类函数宏来定义并初始化状态机。
状态机定义了8种语句：
1、name，状态机名字，形式【name:smname;】
2、init，状态机初始设置，形式【init:initstate, initfunc[可选];】
3、state，状态机的状态列表，形式【state:state1, state2, …;】
4、event，状态机的事件列表，形式【event:event1, event2, …;】
5、active，状态机的动作列表，形式【active:active1, active2, …;】
6、trans，状态机的跃迁，形式【trans:from_state, event, to_state, active[可选];】
7、trans_else，状态机的跌落，形式【trans_else:from_state, to_state, active[可选];】
8、force，状态机的强制跃迁，形式【force:event, to_state, active[可选];】
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/26f7ba8310dd2b5539a1cfb7a1b1bf59/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3abc82cd395d4aedcdafe31eed5fee1b/" rel="bookmark">
			Jmeter自动化测试工具从入门到进阶6小时搞定.黑马跟学(三).实战篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Jmeter自动化测试工具从入门到进阶6小时搞定.黑马跟学 三.实战篇 一、 接口测试流程1.1 搭建自动化脚本1.2 完善自动化脚本 二、场景模拟2.1 弱压力测试2.2 高并发2.3 高频率 三、生成图形化测试报告 学习目标 一、 接口测试流程 1、制定测试计划,分配任务
2、从 API 文档中提取接口清单：对 API 文档简化,提高测试效率,接口清单就是对 API 文档简化压缩,主要提取三要素(请求地址、请求方式、请求数据)
3、设计测试用例并参数化覆盖测试用例
4、编写脚本实现，并导入设计的测试数据；自动化接口脚本的设计：每次更新都要保证之前的代码没有受到影响，所以要把最基本的增删改查功能设计一套自动化执行的脚本，每次更新后执行这个脚本文件，查看是否老接口有影响（此时程序已经在执行了，测试的数据不能对现有的数据进行污染）
5、测试结果汇总，BUG提交
我们先看一下接口文档，新增学院信息
参数如下：
1、有效、无效等价类配合边界值
2、特殊情况：中文、英文、空格、空、符号
3、组合情况： 有效：所有值都填写正确的值
有效：除了slogan不填写，其它都写正确值 无效：dep_id不填写 无效：dep_name不填写
无效：master_name不填写 无效：dep_id 重复
测试数据，可以看资料中提供的“新增数据”
JMeter中创建线程组和HTTP信息头管理器
Content-Type application/json;character=utf-8 添加-配置元件-CSV Data Set Config
更改设置如下：
将CSV配置文件中的变量配置到JMeter中
注意线程组中的循环写成永远，要跑到文末最后一个
为了防止数据重复，清空数据库中原始数据
执行JMeter,查看结果如下：会发现有一些HTTP请求变红了
需要逐条和预期结果对比，比如第三条数据，这里T2001N明明已经插入了，再插入成功就是不对的，说明接口对于重复数据没有校验
如果我们需要给请求后增加编号以便查看行数
点击生成，拷贝生成的结果
${__counter(,)} 放到HTTP请求之后
查看结果树效果如下：
最后对错误数据记录-缺陷
1.1 搭建自动化脚本 创建SetUp线程组完成新增
创建TearDown线程组完成删除
这样能最大限度保证测试数据最后被清除
设置线程组即可修改和查询，为了保证线程组按照顺序来执行，独立运行这个√要勾上
增加HTTP信息头和HTTP请求默认值，全局使用
1.2 完善自动化脚本 先禁用其它线程组，只操作新增
执行一次新增，发现新增成功了
现在我们要对新增的这个HTTP请求
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3abc82cd395d4aedcdafe31eed5fee1b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6066055ba7cf591bb4c54845af5f09c8/" rel="bookmark">
			使用AFPN渐近特征金字塔网络优化YOLOv8改进小目标检测效果（不适合新手）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
简单概述
算法概述
优化效果
参考文献
文献地址：paper
废话少说，上demo源码链接：
简单概述 AFPN的核心思想：AFPN主要通过引入渐近的特征融合策略，逐步整合底层、高层和顶层的特征到目标检测过程中。这种融合方式有助于减小不同层次特征间的语义差距，从而提升特征融合效果，使得检测模型能更好地适应不同层次的语义信息​​。
在YOLOv8中应用AFPN：AFPN被应用于两阶段和一阶段的目标检测框架，并在MS-COCO 2017验证和测试数据集上展示了优于其他先进特征金字塔网络的结果​​。
AFPN的代码实现：AFPN的实现涉及多个模块，例如ASFF3用于YOLO AFPN头部，它包含多个卷积层和上采样操作，以及对特征层的加权融合​​。此外，还有如Downsample_x4, ASFF_2, ASFF_3等多个模块，负责不同层次的特征处理和融合​​。
优化效果：AFPN的引入显著提升了YOLOv8在小目标检测方面的性能，解决了多尺度特征融合中非相邻层级间融合效果的弱化问题​​。
算法概述 优化效果 这张图是一个气泡图，用于比较不同的特征金字塔网络（Feature Pyramid Networks，简称FPNs）在目标检测任务中的平均精度（Average Precision，简称AP）和模型参数数量（以百万为单位）。图表详细解读如下：
X轴（Params (M)）：表示模型的参数数量，单位是百万（M）。参数越多，可能意味着模型更复杂，能够捕获更多细节，但也可能导致过拟合，并需要更多的计算资源。Y轴（Average Precision）：这是评价目标检测器在特定数据集（通常是MS COCO数据集）上准确度的一个指标。AP越高，表明模型的检测精度越好。气泡大小：每个气泡的大小通常代表了该模型的一个额外指标，如计算复杂度、速度或其他性能指标。在这张图中，气泡的大小可能表示了模型复杂度的其他方面，但由于缺少图例，具体含义不明。气泡位置和标签： FPN：基础特征金字塔网络，参数较少，但平均精度也较低。PANet：包含路径聚合网络的特征金字塔，参数和精度相对平衡。NAS-FPN：使用神经架构搜索优化的特征金字塔网络，参数较多。BiFPN：双向特征金字塔网络，用于高效的特征融合。CARAFE：一种内容感知的特征金字塔网络。DRFPN：可能指深度残差特征金字塔网络。AFPN（Ours）：标注为“我们的”的渐近特征金字塔网络，表现出在保持参数数量适中的同时获得了较高的平均精度。GraphFPN：可能是一种使用图结构优化特征金字塔的网络，参数最多，平均精度也最高。FPT：图中没有明确说明，但从位置来看，这可能是一种在参数数量和精度之间取得较好平衡的网络。 参考文献 文献地址：paper 论文“AFPN: Asymptotic Feature Pyramid Network for Object Detection”提出了一种新的目标检测网络结构，解决了在目标检测中由于尺度变化带来的问题。AFPN通过一种渐近的方式融合特征，允许在非相邻层级之间进行直接交互，避免了传统金字塔网络在特征传递和融合过程中可能出现的信息丢失或退化问题。研究者们在MS-COCO 2017验证和测试数据集上评估了AFPN，结果显示AFPN在精度和计算效率上优于其他先进的特征金字塔网络。
废话少说，上demo源码链接： https://download.csdn.net/download/qq_42452134/88764386
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3cb5f173c29a5a1e3f599bec4ab9c859/" rel="bookmark">
			《WebKit 技术内幕》之五（1）： HTML解释器和DOM 模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第五章 HTML 解释器和 DOM 模型
1.DOM 模型
1.1 DOM标准
DOM （Document Object Model）的全称是文档对象模型，它可以以一种独立于平台和语言的方式访问和修改一个文档的内容和结构。这里的文档可以是 HTML 文档、XML 文档或者 XHTML 文档。DOM 以面向对象的方式来描述文档，在 HTML 文档中，Web 开发者可以使用 JavaScript 语言来访问、创建、删除或者修改 DOM 结构，其主要目的是动态改变 HTML 文档的结构。
DOM 以面向对象的方式来描述文档（HTML 文档、XML 文档、XHTML 文档）。DOM 定义的是一组与平台、语言无关的接口，该接口允许编程语言动态访问和更改结构化文档。W3C 标准化组织已经定义了 DOM Level 1（1998）、DOM Level 2（2000）、DOM Level 3（2004）、DOM Level 4 等 DOM 接口标准。
使用 DOM 表示的文档被描述成一个树形结构，使用 DOM 的接口可以对 DOM 树结构进行操作。
DOM 结构构成的基本要素是节点：文档节点（整个文档 Document）、元素节点（HTML 中的标记 Tag）、属性节点（标记的属性）、Entity 节点、ProcessingInstruction 节点、CDataSection 节点、注释（Comment）节点。
每一级的版本都对以前的版本进行了补充并伴随新功能的加入，每个版本都对 DOM 的不同部分进行了定义。
1.2 DOM 树
（1） 结构模型
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3cb5f173c29a5a1e3f599bec4ab9c859/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2dc4c5667c2fb67703a362395936e5e7/" rel="bookmark">
			PostgreSQL 是不是大小写敏感
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果你踩过 MySQL 的大坑的话就知道：MySQL 在 Windows 下不区分大小写，但在 Linux 下默认是区分大小写。
如果你稍加不注意就会出现在本机开发的程序运行一切正常，发布到服务器行就出现表名找不到的问题。
这是我们前一个项目遇到的巨大问题，开发是在 Windows 下进行，但是部署是在 Linux 下进行。
例如一个表：tableName 和 tablename，这 2 个表在 Windows 下是一样的，但在 Linux 下就不一样了。
所以我们的程序在 Windows 下查询表 tableName 没有问题，但是如果 Linux 下数据库的表名为 tableName 的话，那么查询就找不到表了。
有过上面经历的话，我们来看看 PostgreSQL
PostgreSQL 是大小写敏感的 在默认情况，PostgreSQL 在存储和比较数据值的时候字符串的值如果是大小写的处理方式是不一样的。
例如： “isharkfly” 和 “iSharkFly” 是不同的值，这个在 PostgreSQL 会影响存储的。
创建表的 SQL 如果我们有一个创建表的 SQL：
create table test.Table_name ( id integer, user_name varchar ); 和
create table test.table_name ( id integer, user_name varchar ); 注意到，上面的 T 是大写的，如果运行上面的 SQL，在数据库上，我们会看到表的名字被转换成小写了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2dc4c5667c2fb67703a362395936e5e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b79e5eac3673cd953bf38fc28f2c1b3b/" rel="bookmark">
			带POE网络变压器与2.5G/5G/10G网络变压器产品特点介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Hqst华轩盛(石门盈盛)电子导读：一起来了解带POE网络变压器与2.5G/5G/10G网络变压器产品特点？
一﹑带POE网络变压器与2.5G/5G/10G网络变压器产品特点介绍
首先、POE网络变压器产品与常规不带POE产品的区别：
带POE网络变压器主要要求是耐电流等级与不带POE产品不一样，要求比较高,POE产品现在有三个协议区分，AF，AT及BT,也就是我们通常说的POE,POE+及POE++；相关特性如下表；
POE产品三个协议区分
其次，材料使用上的区别:
POE网络变压器产品系列所用磁芯要求不一样，常规网络变压器产品UI值基本在4700uH左右；而POE产品则要求在3600uH左右，特性更稳定；
POE网络变压器产品主要是要求耐电流等级比较高，故所要求的铜线特性更高，线径相对较粗，漆包膜厚度等特性方面要更好；
二﹑2.5G及5G/10G网络变压器产品主要特性：
2.1﹑速率2.5G及5G/10G以上网络变压器产品，主要是基于产品的高频特性而区分：
a﹑常规网络变压器产品主要是测试100M之内的高频特性；
b﹑2.5G产品是测试250M以内的高频特性；
小24PIN 贴片 2.5G网络变压器2G52409S
c﹑5G，10G产品主要是测试500M及以上频段的高频特性；
2.2﹑制做工艺及用料的区别
之前做到2.5G及以上产品特性的网络变压器，产品磁芯主要用猪鼻形状的，特性会更稳定一些；现在已更新使用环形磁芯工艺，生产工艺稍微简单些，价格会稍微便宜；相对来说猪鼻特性更优，当然，猪鼻磁芯工艺的价格也会稍微贵一些。
10G万兆猪鼻磁芯工艺的网络变压器G82408S
对带POE网络变压器与2.5G/5G/10G网络变压器产品特点有所了解了吗？
接下来Hqst 盛生将继续给大家分享网络变压器和与之配套的RJ45 网络连接器的相关知识，方便大家认识网络变压器和RJ系列网口产品，不足之处欢迎讨论；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93dc0be895db24079e7f0b69ebc4b85e/" rel="bookmark">
			为Ubuntu系统添加新的普通用户
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.创建一个新的普通用户2.给用户授权3.删除用户4.新增用户添加至ubuntu的sudors文件中5.提高ubuntu下访问github的速度5.1 vscode在线打开github5.1 wsl永久关闭swap功能 6.配置ubuntu国内镜像下载源的方法6.1 如果ping mirrors.tuna.tsinghua.edu.com无法ping通 7.ubuntu包的安装方法问题：Package python3 is not configured yet或者 Package ** is not configured yet或者Errors were encountered while processing 8.Ubuntu中将默认的dash改为bash9.pip很慢10. wsl2安装openssh-server11.wsl2安装docker12.wsl2将默认的NAT方式配置成网桥模式13.谷歌浏览器商店打不开怎么办？14.wsl增加组播路由15.Python默认查找包的环境16.vscode使用wsl插件出现的问题17.WSL2很卡18.vscode常用插件小结19.vim 整合插件20.curl直接下载github release文件21 git submodule问题22 ubuntu支持交叉编译23.Ubuntu 查看cpu个数及核心数23.如何在ubuntu22.04版本上安装libssl1.1?24.boost手册及安装25.WSL2端口映射26.Ubuntu 22.04 Minikube安装配置27.ubuntu 22.04 安装kubectl28.ubuntu22.04安装kOps29.在线生成asicc字符画网站30.连接dl.google.com超时的问题31.clang-tid静态检查工具32.起变量名网站CODELF33.wsl2中pip很慢34.Windows10或者Windows11主机无法PING通的解决方法35. Key is stored in legacy trusted.gpg36.wget --no-check-certificate 问题解决40.Windows设置暗黑主题方案41.pdf翻译42.ubuntu20.04 install/uninstall gcc1143.clang-format配置44.ubuntu 配置命令提示符45.wsl2中安装kali46. 1.创建一个新的普通用户 创建了可以登录的meow用户并使用/bin/bash作为shell。设置密码。为meow用户增加管理员权限。切换登录用户为meow。 $ sudo useradd -m meow -s /bin/bash $ sudo passwd meow $ sudo adduser meow sudo $ su meow 2.给用户授权 查看meow所在的组。设置meow权限为superuser。查看sudoer的文本文件(suders含义)，可以添加meow ALL=(ALL:ALL) ALL为meow设置superuser权限。 $ groups meow $ usermod -aG sudo meow $ visudo visudo默认使用vim而不是nano的方法 在顶部附近的/etc/sudoers文件中添加一行： Defaults editor=/usr/bin/vim 或者
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/93dc0be895db24079e7f0b69ebc4b85e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2fe2d3791d5974af90ce13c2212f38a/" rel="bookmark">
			面试官：Redis除了缓存，还能做什么？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		啧啧，面试官又开始为难人了，Redis做缓存难道不香吗，非要问我还能做什么。当代孔乙己有木有，非要问茴香豆中“茴”字的四种写法。
吐槽完毕，接下来咱们好好研究研究“Redis还能做什么”，争取在下次面试的时候秒他。
1、登录鉴权 用户登录鉴权，以及对应的登录验证码或token到期失效，是系统最为常见的功能之一。而Redis key的超时失效功能，则非常适合于这种业务场景。
对应操作如下：
redis&gt; setex captchalogin|13436669876 60 3456 "OK" redis&gt; get captchalogin|13436669876 "3456" redis&gt; get captchalogin|13436669876 (nil) redis&gt; setex tokencheck|12345 86400 54321 "OK" redis&gt; get tokencheck|12345 "54321" 以上实现场景为：
（1）系统登录场景，用户输入手机号后，点击发送短信验证码，通过Redis存储前缀 + 手机号作为key，验证码作为value，并设置60秒过期时间。
（2）用户在60秒内进行登录验证，则可以从Redis中获取到验证码，验证相同则登录成功，超过60秒则获取不到验证码值，登录失败。
（3）用户登录后生成token，Redis存储前缀 + token作为key，用户ID作为value，并设置为一天过期。
（4）接下来可以通过token进行鉴权，并获取对应的用户ID。
2、计数器 计数器是一种非常常见的业务场景，类似于知乎的帖子点赞、收藏，电商的库存扣减等。
但在高并发场景下，用MySQL数据库去硬扛这种读写压力是比较吃力的，Redis的INCR、DECR、INCRBY、DECRBY相关命令，则恰好解决了这个问题。
我们以知乎点赞场景进行举例：
对应操作如下：
redis&gt; set article1 0 "OK" redis&gt; incr article1 (integer) 1 redis&gt; decr article1 (integer) 0 redis&gt; incrby article1 2 (integer) 2 redis&gt; decrby article1 2 (integer) 0 3、粉丝关注 粉丝关注场景本身还好，但涉及到计算共同粉丝，单方粉丝之类的会比较麻烦，这时就轮到Redis Set数据类型粉墨登场了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c2fe2d3791d5974af90ce13c2212f38a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4941bb68e28645d015c293bd8a9ed525/" rel="bookmark">
			C&#43;&#43;中的指针、引用；左值、右值；左值引用、右值引用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、指针、引用 引用指的是为已经创建的对象重新起一个名字。创建引用的时候，编译器只是将这个别名绑定到引用的对象上。
对象名提供了一种直接访问数据的方式，因为对象名本质上是数据所在的内存地址空间的一个地址映射。
引用提供了一种简介访问数据的方式，可以通过引用访问已经存在的对象的内容，在对数据的读写效果上，与使用原对象名对数据的读写效果是一样的。
指针则提供了另一种间接访问数据的方式：可以把数据的内存地址放到专门存放地址的对象里，然后通过这个对象对数据进行访问，这种专门用来存放地址的对象成为指针对象。
二、左值、右值 在C++中，左值（Lvalue）和右值（Rvalue）是两个重要的概念，用于描述表达式和值的特性。这些概念与C++中的赋值、传递参数、引用等操作密切相关。
左值（Lvalue）：
左值是指可以出现在赋值操作的左边的表达式，即可以被赋值的表达式。通常来说，左值表示一个可标识的、有地址的内存位置，它可以被读取和写入。例如，变量、数组元素、结构体成员等都是左值，因为它们在内存中有位置，可以被赋值。
示例：
int x = 10; // 'x'是一个左值 int arr[5]; // 'arr'是一个左值，'arr[2]'也是一个左值 右值（Rvalue）：
右值是指不能出现在赋值操作的左边的表达式，即不能被赋值的表达式。它们通常是临时的、不具有地址的值。右值可以用于初始化左值，但不能直接修改。
示例：
int y = 20; // '20'是一个右值，'y'是一个左值 int sum = x + y; // 'x + y'中的表达式是一个右值 三、左值引用、右值引用 左值引用就是对左值对象的基本引用，在C++11前，没有右值引用一说，因此我们常说的引用都是只左值引用。
在C++11以后的版本中，右值引用（Rvalue reference）的引入允许我们获取对右值的引用，这有助于实现高效的移动语义。
C++11引入了移动语义和右值引用，使得处理临时对象和资源管理变得更加高效。通过将右值引用绑定到右值，我们可以在转移资源所有权时避免不必要的数据拷贝。
示例：
std::string str1 = "Hello"; std::string str2 = std::move(str1); // 使用std::move将str1的资源所有权转移到str2 总之，左值和右值在C++中是用于描述表达式和值的重要概念，对于理解变量、赋值、引用和移动语义等方面非常关键。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/828378b06fbf1ab24f06c94ecc8352e5/" rel="bookmark">
			深入理解Rust所有权机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、概述二、栈（Stack）与堆（Heap）2.1、栈2.2、堆2.3、性能区别2.4、所有权与堆栈 三、所有权原则3.1、变量作用域3.2、简单介绍String类型 四、变量绑定背后的数据交互4.1、转移所有权4.2、克隆（深拷贝）4.3、拷贝（浅拷贝）4.4、函数传值与返回 团队博客: 汽车电子社区
一、概述 所有的程序都必须和计算机内存打交道，如何从内存中申请空间来存放程序的运行内容，如何在不需要的时候释放这些空间，成了重中之重，也是所有编程语言设计的难点之一。在计算机语言不断演变过程中，出现了三种流派：
1、垃圾回收机制(GC)，在程序运行时不断寻找不再使用的内存，典型代表：Java、Go。
2、手动管理内存的分配和释放, 在程序中，通过函数调用的方式来申请和释放内存，典型代表：C++。
3、通过所有权来管理内存，编译器在编译时会根据一系列规则进行检查。
其中 Rust 选择了第三种，最妙的是，这种检查只发生在编译期，因此对于程序运行期，不会有任何性能上的损失。
二、栈（Stack）与堆（Heap） 栈和堆是编程语言最核心的数据结构，但是在很多语言中，你并不需要深入了解栈与堆。 但对于 Rust 这样的系统编程语言，值是位于栈上还是堆上非常重要, 因为这会影响程序的行为和性能。
栈和堆的核心目标就是为程序在运行时提供可供使用的内存空间。
2.1、栈 栈按照顺序存储值并以相反顺序取出值，这也被称作后进先出。想象一下一叠盘子：当增加更多盘子时，把它们放在盘子堆的顶部，当需要盘子时，再从顶部拿走。不能从中间也不能从底部增加或拿走盘子！
增加数据叫做进栈，移出数据则叫做出栈。
因为上述的实现方式，栈中的所有数据都必须占用已知且固定大小的内存空间，假设数据大小是未知的，那么在取出数据时，你将无法取到你想要的数据。
2.2、堆 与栈不同，对于大小未知或者可能变化的数据，我们需要将它存储在堆上。
当向堆上放入数据时，需要请求一定大小的内存空间。操作系统在堆的某处找到一块足够大的空位，把它标记为已使用，并返回一个表示该位置地址的指针, 该过程被称为在堆上分配内存，有时简称为 “分配”(allocating)。
接着，该指针会被推入栈中，因为指针的大小是已知且固定的，在后续使用过程中，你将通过栈中的指针，来获取数据在堆上的实际内存位置，进而访问该数据。
由上可知，堆是一种缺乏组织的数据结构。想象一下去餐馆就座吃饭: 进入餐馆，告知服务员有几个人，然后服务员找到一个够大的空桌子（堆上分配的内存空间）并领你们过去。如果有人来迟了，他们也可以通过桌号（栈上的指针）来找到你们坐在哪。
2.3、性能区别 **写入方面：**入栈比在堆上分配内存要快，因为入栈时操作系统无需分配新的空间，只需要将新数据放入栈顶即可。相比之下，在堆上分配内存则需要更多的工作，这是因为操作系统必须首先找到一块足够存放数据的内存空间，接着做一些记录为下一次分配做准备。
**加粗样式****读取方面：**得益于 CPU 高速缓存，使得处理器可以减少对内存的访问，高速缓存和内存的访问速度差异在 10 倍以上！栈数据往往可以直接存储在 CPU 高速缓存中，而堆数据只能存储在内存中。访问堆上的数据比访问栈上的数据慢，因为必须先访问栈再通过栈上的指针来访问内存。
因此，处理器处理和分配在栈上数据会比在堆上的数据更加高效。
2.4、所有权与堆栈 当你的代码调用一个函数时，传递给函数的参数（包括可能指向堆上数据的指针和函数的局部变量）依次被压入栈中，当函数调用结束时，这些值将被从栈中按照相反的顺序依次移除。
因为堆上的数据缺乏组织，因此跟踪这些数据何时分配和释放是非常重要的，否则堆上的数据将产生内存泄漏 —— 这些数据将永远无法被回收。这就是 Rust 所有权系统为我们提供的强大保障。
对于其他很多编程语言，你确实无需理解堆栈的原理，但是在 Rust 中，明白堆栈的原理，对于我们理解所有权的工作原理会有很大的帮助。
三、所有权原则 理解了堆栈，接下来看一下关于所有权的规则，首先请谨记以下规则：
1、Rust 中每一个值都被一个变量所拥有，该变量被称为值的所有者。
2、一个值同时只能被一个变量所拥有，或者说一个值只能拥有一个所有者。
3、当所有者(变量)离开作用域范围时，这个值将被丢弃(drop)。
3.1、变量作用域 作用域是一个变量在程序中有效的范围, 假如有这样一个变量：
let s = "hello" 变量 s 绑定到了一个字符串字面值，该字符串字面值是硬编码到程序代码中的。s 变量从声明的点开始直到当前作用域的结束都是有效的：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/828378b06fbf1ab24f06c94ecc8352e5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0eb6b90dfa06630af3051f2f4bff5e25/" rel="bookmark">
			Dubbo源码解析第一期：如何使用Netty4构建RPC
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、背景 早期学习和使用Dubbo的时候（那时候Dubbo还没成为Apache顶级项目），写过一些源码解读，但随着Dubbo发生了翻天覆地的变化，那些文章早已过时，所以现在计划针对最新的Apache Dubbo源码来进行“阅读理解”，希望和大家一起再探Dubbo的实现。由于能力有限，如果文章有错误的地方，欢迎大家留言指正。
本期的主题是Dubbo如何使用Netty4构建RPC来通讯。
二、Server端视角 我们看看作为服务提供方，Apache Dubbo是如何使用Netty4的。
2.1 Netty的线程组 线程组作为Netty的Reactor设计核心组件，在这里自然少不了，我们看到org.apache.dubbo.remoting.transport.netty4.NettyServer中有如下两个方法：
int DEFAULT_IO_THREADS = Math.min(Runtime.getRuntime().availableProcessors() + 1, 32); String IO_THREADS_KEY = "iothreads"; String EVENT_LOOP_BOSS_POOL_NAME = "NettyServerBoss"; String EVENT_LOOP_WORKER_POOL_NAME = "NettyServerWorker"; protected EventLoopGroup createBossGroup() { return NettyEventLoopFactory.eventLoopGroup(1, EVENT_LOOP_BOSS_POOL_NAME); } protected EventLoopGroup createWorkerGroup() { return NettyEventLoopFactory.eventLoopGroup( getUrl().getPositiveParameter(IO_THREADS_KEY, Constants.DEFAULT_IO_THREADS), EVENT_LOOP_WORKER_POOL_NAME); } 分别用来构建Boss线程组和Worker线程组，Boss线程组负责创建连接，连接创建成功后由Worker线程组来负责处理和发送请求。注意Boss线程组只设置了1个线程，而且没有设置修改接口，通常1个也是够用的，如果设置成可配的会更好。而Worker线程组默认值是当前可用核数和32中取最小值，注意，是最小值，不是最大值，意味着如果你单个Provider实例上可用的核超过32，那么一定要设置IO_THREADS_KEY，否则可能无法达到最大吞吐量（特别是IO密集型应用）。上面代码也给出了这两个线程组的线程池的名称，如果不清楚现在跑的是多少，可以jstack命令看下。注意，为了阐述方便，上面的四个属性定义来自org.apache.dubbo.remoting.Constants。
2.1 Netty的ChannelHandler Netty的可扩展性主要来自其核心组件之一ChannelHandler，ChannelHandler能帮助我们解决拆包&amp;粘包、协议编解码、权限校验等RPC常遇到的问题。那我们来看看现在Dubbo的Provider端用到了哪些ChannelHandler，同样，我们看NettyServer#initServerBootstrap方法：
protected void initServerBootstrap(NettyServerHandler nettyServerHandler) { boolean keepalive = getUrl().getParameter(KEEP_ALIVE_KEY, Boolean.FALSE); bootstrap .group(bossGroup, workerGroup) // 根据是否支持EPoll来返回EpollServerSocketChannel或者NioServerSocketChannel .channel(NettyEventLoopFactory.serverSocketChannelClass()) // SO_REUSEADDR设置为true表示允许重用本地地址和端口。如果服务器意外关闭后再次启动，可以立即绑定到之前使用的地址和端口。 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0eb6b90dfa06630af3051f2f4bff5e25/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56640d8d184bbebda51526cd03e94024/" rel="bookmark">
			Beyond Compare 4 代码对比如何重新激活使用30天
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Beyond Compare 4 代码对比如何重新激活使用30天 Beyond Compare 4 是一款强大的文件比较工具，但只有30天的试用期。如果想在试用期结束后继续使用该软件，可以通过修改注册表的方式来实现。具体步骤如下：
1 同时按住“Win”+“R”键，打开运行窗口。 2 在文本框中输入“regedit”，然后点击“确定”。 3 打开注册表删除相关注册信息 打开注册表后，依次点击左侧列的“HKEY_CURRENT_USER”-“Software”-“Scooter Software”-“Beyond Compare 4”。
找到“CacheID”并右键，在弹出选项中点击“删除”。
4 重启Beyond Compare 4软件，30天的评估试用期将被清零，可以重新使用30天。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b78dd8152dd0aa11cf084d9c1c50dfc9/" rel="bookmark">
			Unity导出Android项目踩坑记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 导出的时候需要注意以下地方的配置： 1、buildSetting-&gt; 设置ExportProject 2、buildsetting -&gt;playerSetting -&gt;设置IL2CPP 3、设置ndk edit-&gt;preferences-&gt;external tools-&gt;ndk 如果unity的ndk版本和android项目里的ndk版本不一致会报错，让人很崩溃的
4、支持64位配置 buildsetting -&gt;playerSetting -&gt;勾选arm64 谷歌市场不支持64位arm不让通过审核，单纯的配置ndk：
ndk { abiFilters 'arm64-v8a', 'armeabi-v7a' }是没用的，需要有arm64-v8a的 .so 文件，所以unity导出项目时需要配置64位 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15c480f2bb513f7f84063aba435900c4/" rel="bookmark">
			【SWAT水文模型】SWAT-CUP安装及使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SWAT-CUP安装及使用 1 SWAT CUP安装1.1 SWAT CUP 20191.2 SWAT CUP 2012SWAT CUP左侧工具栏 2 SWAT CUP简介2.1 模拟方法GLUEParaSol：Parameter Solution MethodSUFI2MCMCPSO：粒子群优化算法 3 SWAT校准技巧3.1 水文模型评价指标 参考 SWAT-CUP（Calibration and Uncertainty Programs）是一个公共程序，可以自由使用和复制。该程序将GLUE、ParaSol、SUFI2和MCMC等程序与SWAT连接起来，可以执行SWAT模型的敏感性分析、校准、验证和不确定性分析。
下面介绍一下SWAT CUP的安装与使用。
官网-SWAT-CUP
1 SWAT CUP安装 1.1 SWAT CUP 2019 右击安装包，按照提示步骤一步一步安装即可：
接受许可，如下：
选择文件安装位置，如下：
开始安装，如下：
提示安装完成，如下图：
1.2 SWAT CUP 2012 显示，成功安装
安装完成后，界面如下：
SWAT CUP左侧工具栏 若SWAT CUP 左侧菜单栏不见了，点击菜单栏，选最下面reset all settings，即可。
2 SWAT CUP简介 SWAT-CUP2012是一个公共程序，可以自由使用和复制。该程序将GLUE、ParaSol、SUFI2、MCMC等程序与SWAT连接起来，可以执行SWAT模型的敏感性分析、校准、验证和不确定性分析。
模型的不确定性来源：
模型本身模型的基本假设输入数据的误差分辨率等 2.1 模拟方法 GLUE ParaSol：Parameter Solution Method 模型参数的不确定性
SUFI2 MCMC PSO：粒子群优化算法 3 SWAT校准技巧 Calibration 率定
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/15c480f2bb513f7f84063aba435900c4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b09736e031cd3413ee1a34c88253c222/" rel="bookmark">
			html Canvas粒子文字特效
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		代码有点长，下面是代码：
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;HTML5 Canvas粒子效果文字动画特效DEMO演示&lt;/title&gt; &lt;link rel="stylesheet" href="css/normalize.css"&gt; &lt;link rel="stylesheet" href="css/style.css" media="screen" type="text/css" /&gt; &lt;/head&gt; &lt;body&gt; &lt;div style="text-align:center;clear:both;position:absolute;top:0;left:260px"&gt; &lt;script src="/gg_bd_ad_720x90.js" type="text/javascript"&gt;&lt;/script&gt; &lt;script src="/follow.js" type="text/javascript"&gt;&lt;/script&gt; &lt;/div&gt; &lt;canvas class="canvas"&gt;&lt;/canvas&gt; &lt;div class="help"&gt;?&lt;/div&gt; &lt;div class="ui"&gt; &lt;input class="ui-input" type="text" /&gt; &lt;span class="ui-return"&gt;↵&lt;/span&gt; &lt;/div&gt; &lt;div class="overlay"&gt; &lt;div class="tabs"&gt; &lt;div class="tabs-labels"&gt;&lt;span class="tabs-label"&gt;Commands&lt;/span&gt;&lt;span class="tabs-label"&gt;Info&lt;/span&gt;&lt;span class="tabs-label"&gt;Share&lt;/span&gt;&lt;/div&gt; &lt;div class="tabs-panels"&gt; &lt;ul class="tabs-panel commands"&gt; &lt;li class="commands-item"&gt;&lt;span class="commands-item-title"&gt;Text&lt;/span&gt;&lt;span class="commands-item-info" data-demo="Hello :)"&gt;Type anything&lt;/span&gt;&lt;span class="commands-item-action"&gt;Demo&lt;/span&gt;&lt;/li&gt; &lt;li class="commands-item"&gt;&lt;span class="commands-item-title"&gt;Countdown&lt;/span&gt;&lt;span class="commands-item-info" data-demo="#countdown 10"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b09736e031cd3413ee1a34c88253c222/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33b0d3270ad7223f6efb8593aeba2dcb/" rel="bookmark">
			5G_射频测试_发射机测量（四）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		6.2 Base station output power 用于测量载波发射功率的大小，功率越大小区半径越大但是杂散也会越大
载波功率（用频谱仪测）天线口功率（用功率计测）载波功率是以RBW为单位的filter测量的积分功率不同带宽的多载波测试时分为同样的功率谱密度或者每个再多带宽平衡 6.3.2 RE power control dynamic range 用于测量功率在最大和最小RE（resource element）的信号质量，check EVM的结果
最小setup TM2/最大TM1.1/TM3.1的平均值（遍历每种调制方式），因为在测试EVM时最cover到RE的结果所以一般情况下不会单独测试这个case。
6.3 Output power dynamics the difference between the maximum（TM3.1满PRB） and the minimum transmit power（TM2只有一个PRB）RE的资源快：众坐标是频域 以subcarrier为单位一个PRB有12个subcarrier，横坐标：以时间symbol为单位 带宽越大RE数量越多所以要求不一样（以100M有273个PRB为例：10*Log（273）=24.36dB）
Table 6.3.3.2-1: Total power dynamic range
BS channel Total power dynamic range (dB)
bandwidth (MHz)
15 kHz SCS
30 kHz SCS
60 kHz SCS
20
20.2
17
13.8
50
24.3
21.2
18.1
100
N/A
24.3
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/33b0d3270ad7223f6efb8593aeba2dcb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ae61430aef77c4a290dcbcef2d93cff/" rel="bookmark">
			flutter获取地理定位：geolocator依赖详细用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文使用geolocator插件实现app物理定位功能。
该插件的主要功能有：
获取最后已知位置；获取设备当前位置；获取连续的位置更新；检查设备是否启用了定位服务；计算两个地理坐标之间的距离（米）；计算两个地理坐标之间的方位； 如何安装： 方法一：在pubspec.yaml文件中添加它，10.1.0是当前最新版本号，也可指定特定版本号。
然后在终端运行以下命令：
flutter packages get 方法二：直接在终端运行以下命令获取最新版本geolocator插件
flutter pub add geolocator 配置app环境 ： Android系统 1.在 "android\gradle.properties" 文件中添加以下内容：
android.useAndroidX=true android.enableJetifier=true 2.确保将 "android/app/build.gradle "文件中的 compileSdkVersion 设置为 33(10.1.0版本时要求，不同版本可能要求不一样，具体看原依赖文档)：
android { compileSdkVersion 33 ... } 3.确保将所有 android. 依赖项替换为 AndroidX 对应项（完整列表可在此处找到：迁移到 AndroidX）。
4.打开 "android\app\src\main\AndroidManifest.xml" 文件，将以下两行中的一行添加为&lt;manifest&gt; 标签的直接子代（当这两种权限都配置时，geolocator将使用 ACCESS_FINE_LOCATION）：
&lt;uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" /&gt; &lt;uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION" /&gt; 如果你目标用户用的是Android10或者以上的系统，就需要再添加ACCESS_BACKGROUND_LOCATION这条权限
&lt;uses-permission android:name="android.permission.ACCESS_BACKGROUND_LOCATION" /&gt; IOS系统 打开 "ios\Runner\Info.plist" 文件，添加以下内容。string标签内为描述，可更改以贴合上下文。
&lt;key&gt;NSLocationWhenInUseUsageDescription&lt;/key&gt; &lt;string&gt;This app needs access to location when open.&lt;/string&gt; &lt;key&gt;NSLocationAlwaysUsageDescription&lt;/key&gt; &lt;string&gt;This app needs access to location when in the background.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6ae61430aef77c4a290dcbcef2d93cff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a504b01fd914e9c059528ae97ec8623a/" rel="bookmark">
			如何区分 html 和 html5？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HTML（超文本标记语言）和HTML5在很多方面都存在显著的区别。HTML5是HTML的最新版本，引入了许多新的特性和元素，以支持更丰富的网页内容和更复杂的交互。以下是一些区分HTML和HTML5的关键点：
新特性与元素：HTML5引入了许多新特性和元素，这些在之前的HTML版本中是没有的。例如，音频和视频元素的 &lt;audio&gt; 和 &lt;video&gt;、语义元素如 &lt;header&gt;, &lt;footer&gt;, &lt;article&gt;, &lt;section&gt; 和 &lt;nav&gt;，以及一些输入类型，例如 &lt;input type="email"&gt;, &lt;input type="number"&gt;, 和 &lt;input type="range"&gt; 等。语义化标签：HTML5引入了更多语义化的标签，如 &lt;header&gt;, &lt;footer&gt;, &lt;article&gt;, &lt;section&gt; 和 &lt;nav&gt;。这些标签不仅提供了更清晰的页面结构，还为搜索引擎和辅助技术（如屏幕阅读器）提供了更多的上下文信息。音频和视频：HTML5引入了 &lt;audio&gt; 和 &lt;video&gt; 标签，使得在网页上嵌入音频和视频变得更为简单。不再需要依赖第三方插件，如Flash。画布（Canvas）：HTML5提供了 &lt;canvas&gt; 元素，允许在网页上绘制图形。这为开发者提供了一个强大的工具，可以创建复杂的交互式应用。样式和脚本：HTML5通过分离内容和表现的方式，让CSS和JavaScript扮演了更为重要的角色。更多的功能被移到了CSS和JavaScript中，而不是在HTML元素中。兼容性：尽管HTML5是现代的标准，但并非所有的浏览器都完全支持所有的HTML5特性。因此，为了确保兼容性，开发者可能需要使用一些JavaScript库或工具，如Modernizr，来检测浏览器对HTML5特性的支持情况。文档类型声明：HTML5的文档类型声明更为简洁，只需要写 &lt;!DOCTYPE html&gt;，而之前的HTML版本需要引用一个DTD（文档类型定义）。 总的来说，HTML5是一个更为强大、灵活和现代的版本，提供了许多新特性和工具，让开发者能够创建更复杂、更富交互性的网页和应用。然而，也需要记住的是，尽管大多数现代浏览器都支持HTML5，但一些旧的或非主流的浏览器可能不完全支持所有的特性。因此，在开发过程中，保持对浏览器兼容性的关注是很重要的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10bb96684f1bab0f5709f56df6901009/" rel="bookmark">
			30分钟快速搭建并部署一个免费的个人博客
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 现如今网上有许多完善的博客平台，如博客园、掘金、思否、知乎等。有人会说为什么现在网上有这么多成熟的博客平台，你还要浪费时间搭建一个自己的博客系统呢？首先我相信每一个程序员都会想要拥有一个属于自己的博客系统，其次使用Docsify能够快速构建一个自己的博客文档系统，最后我们可以通过Github Pages免费托管我们的博客系统文档（连域名和服务器都省了）这样的一次难得的实战机会我们又怎么能够错过呢。废话不多说，接下来步入正题。
什么是Docsify？ 一个神奇的文档网站生成器，Docsify 可以快速帮你生成文档网站。不同于 GitBook、Hexo 的地方是它不会生成静态的 .html 文件，所有转换工作都是在运行时。如果你想要开始使用它，只需要创建一个 index.html 就可以开始编写文档。
Docsify的特性 无需构建，写完文档直接发布
容易使用并且轻量 (压缩后 ~21kB)
智能的全文搜索
提供多套主题
丰富的 API
支持 Emoji
兼容 IE11
支持服务端渲染 SSR (示例[1])
Docsify使用配置指南 Docsify使用指南（打造最快捷、最轻量级的个人&amp;团队文档）👉[2]
轻量&amp;完善开箱即用的Docsify模板 Docsify-Guide是一个简洁、完善、开箱即用的Docsify模板基本上可以满足百分之八十多的个人和团队需求，你可以按照文章中的Docsify环境配置教程把运行Docsify所需要的环境配置起来，通过命令即可查看效果（配置环境顺利的话只要十来分钟）有帮助的话别忘了给作者来一个Star支持一下哦🤞。
模板源码地址：github.com/YSGStudyHar…[3]
模板预览地址：ysgstudyhards.github.io/Docsify-Gui…[4]
选择对应的存储库单击设置（Settings） 点击左侧的Pages 选择对应分支的发布源文件夹 保存发布即可访问 个人博客在线预览 Github Pages在线访问地址：ysgstudyhards.github.io/Docsify-Gui…[5]
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5342bfd7b2fbae916eed21f4031ba0c7/" rel="bookmark">
			Spring最常用组件注册注解开发案例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Spring常用组件注册注解开发案例 文章目录 Spring常用组件注册注解开发案例1. 组件注册注解1. @Configuration2.@Bean注解3. @Configuration与@Bean注解使用案例4. ComponentScan注解5. 自定义TypeFilter指定过滤规则 什么是spring注解开发？
就是不再使用Spring的bean.xml文件，纯使用注解的方式开发;
要使用纯注解开发，就需要有一个配置类，配置类==配置文件
spring版本：
&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.1.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; 1. 组件注册注解 1. @Configuration @Configuration:一旦在某个类上标注了此注解，说明此类就是一个配置类
注解的定义如下：
// // Source code recreated from a .class file by IntelliJ IDEA // (powered by Fernflower decompiler) // package org.springframework.context.annotation; import java.lang.annotation.Documented; import java.lang.annotation.ElementType; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Target; import org.springframework.core.annotation.AliasFor; import org.springframework.stereotype.Component; @Target({ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) @Documented @Component public @interface Configuration { @AliasFor( annotation = Component.class ) String value() default "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5342bfd7b2fbae916eed21f4031ba0c7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c47c06a96ed23aa4524e3ff18955a557/" rel="bookmark">
			Spring注解驱动开发之常用注解案例_告别在XML中配置Bean
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Spring注解驱动开发之常用注解案例 文章目录 Spring注解驱动开发之常用注解案例1. 组件注册注解1.1 @Configuration和@Bean注解1.2 自动扫描组件和指定扫描规则1.3 自定义TypeFilter指定过滤规则1.4 @Scope设置组件的作用域1.5 @Lazy注解，bean懒加载注解1.6 @Conditional-按照条件注册bean 2. 给容器中注册组件的方式2.1 包扫描+组件标注注解2.2 @Bean2.3 @Import[快速给容器中导入一个组件]2.3.1 @Import(要导入到容器中的组件)2.3.2 ImportSelector:返回需要导入的组件的全类名数组；2.3.3 ImportBeanDefinitionRegistrar:手动注册bean到容器中 3.使用Spring提供的 FactoryBean（工厂Bean）;3.1 默认获取到的是工厂bean调用getObject创建的对象3.2 要获取工厂Bean本身，要获取工厂Bean本身，我们需要给id前面加一个&amp;,如：&amp;colorFactoryBean 注解驱动开发就是不再使用Spring的bean.xml文件，改为纯使用注解的方式开发
1. 组件注册注解 1.1 @Configuration和@Bean注解 @Configuration
此注解为配置类注解，相当于spring.xml文件，即配置类==配置文件
@Bean
给容器中注册一个Bean;类型为返回值的类型，id默认是用方法名作为id
示例 package com.yuan.annotation.config; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.ComponentScan; import org.springframework.context.annotation.Configuration; import com.yuan.annotation.bean.Person; //配置类==配置文件 @Configuration //告诉Spring这是一个配置类 public class MainConfig { //给容器中注册一个Bean;类型为返回值的类型，id默认是用方法名作为id @Bean("person") public Person personA() { return new Person(1,"张三",33); } } Person类(后续注解配置类中都会以此类举例),Person.java
package com.yuan.annotation.bean; import lombok.AllArgsConstructor; import lombok.Data; import lombok.NoArgsConstructor; import lombok.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c47c06a96ed23aa4524e3ff18955a557/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad22b0f8fdde3267f5715210fc954b94/" rel="bookmark">
			HashMap1.7和1.8的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HashMap1.7和1.8的区别 1.JDK1.7用的是头插法，而JDK1.8及之后使用的都是尾插法 那么为什么要这样做呢？因为JDK1.7是用单链表进行的纵向延伸，当采用头插法时，再多线程环境下并发扩容的时候，会容易出现环形链表死循环问题。但是在JDK1.8之后使用尾插法，能够避免出现逆序且链表死循环的问题。
2.扩容流程不同： 1.8是扩容前插入键值，连同旧的键值一起转移，一起计算，1.7是扩容后，扩容后进行插入，旧数据转移到新的数组之后，然后再单独计算插入的位置。为什么1.8是插入之后再整体计算扩容，主要是为了减少红黑树和链表来回转换的频率
3.扩容后数据存储位置的计算方式也不一样： 要说清楚这个，先得说说HASHMAP如何求桶的位置
HashMap求桶的位置一共分为三个过程：
1）求key的hashcode 2）将hashcode的高16位和低16位进行异或操作。
至此我们完成了hash方法，求得了该元素的hash值。源码在下方
static final int hash(Object key) { int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16); } 3）(n - 1) &amp; hash ，将hash值与length-1进行与操作，求桶的位置
if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); 无论是JDK7还是JDK8，HashMap的扩容都是每次扩容为原来的两倍，即会产生一个新的数组newtable，我们需要把原来数组中的元素全部放到新的只不过元素求桶的位置的方法不太一样。
在JDK7中就是按照我上述写的三个步骤重新对元素求桶的位置，但是第三步与的值是新的数组的长度-1，也就是newCap-1。
但是JDK8中就不是和newCap，而是直接和oldCap进行与运算，也就是与旧数组的长度（oldCap）进行与操作。下面的是伪代码：
if ((e.hash &amp; oldCap) == 0) { newTab[j] = loHead; }else{ ​ newTab[j + oldCap] = hiHead; } 与oldCap与的结果如果是0，那么就代表当前元素的桶位置不变。 反之，那么扩容后桶的位置就是原位置+原数组长度（oldCap）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ad22b0f8fdde3267f5715210fc954b94/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28be20cd23177f0b91e49019113e313d/" rel="bookmark">
			【机器学习】强化学习（四）-时序差分学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		蒙特卡洛算法需要使用完整的片段进行计算，这在有些问题中是不现实的，尤其是对于没有终止状态的问题。时序差分算法对此进行了改进
蒙特卡洛控制和时序差分学习有什么区别？
四、时序差分算法（Temporal Difference Learning, TD 学习）
4.1 时序差分（0）
4.2 Sarsa算法
4.3 Q学习（Q-learning）
4.4 Sarsa和Q-learning有什么区别？
4.5 示例代码
公共类：discrete.py plotting.py
离散环境的类 discrete.py，它继承自 gym 库的 Env 类，用于创建和管理强化学习的环境。它的主要功能是：
定义了环境的基本属性，如状态的数量，动作的数量，状态转移的概率，初始状态的分布，动作的空间，状态的空间等。
定义了环境的基本方法，如设置随机数种子，重置环境，执行一个动作，返回下一个状态，奖励，是否结束和附加信息等。
使用了 numpy 库，gym 库和 categorical_sample 函数来进行数值计算，环境管理和概率采样等操作。
# 导入 numpy 库，用于进行数值计算 import numpy as np # 导入 gym 库，用于创建和管理强化学习的环境 from gym import Env, spaces # 导入 gym 库的 seeding 模块，用于设置随机数种子 from gym.utils import seeding # 导入 gym 库的 toy_text 模块的 categorical_sample 函数，用于从一个概率分布中采样一个类别 from gym.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/28be20cd23177f0b91e49019113e313d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29689f65a0109c4535182bca269d183c/" rel="bookmark">
			【NVIDIA】Jetson Orin Nano系列：安装 Qt6、firefox、jtop、flameshot
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、使用命令安装 sudo apt install qtcreator sudo apt install qt6-* sudo apt install libqt6* sudo apt install qml-qt6 sudo apt install qmlscene-qt6 sudo apt install assistant-qt6 sudo apt install designer-qt6 2、启动 qtcreator
3、常用工具安装 sudo apt install tree	//查看目录树 sudo apt install flameshot // 截图工具 4、安装火狐浏览器 直接使用 sudo apt install firefox 安装时，会使用snap来安装，经常因为网络不好而卡死，下面使用官方的源来安装deb版本的firefox
sudo add-apt-repository ppa:mozillateam/ppa sudo apt update sudo apt install firefox-esr 5、安装jtop 注意：不要使用 sudo apt install 安装 jtop，要使用pip3来安装
sudo pip3 install jetson-stats sudo systemctl restart jtop.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/29689f65a0109c4535182bca269d183c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c0b9a494ed00312941792da58deadda/" rel="bookmark">
			excel 常用函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		求和函数： SUM： 将单个值、单元格引用或区域相加。
案例：=SUM(A1:A5) （结果：A1到A5单元格的值求和）
SUMIF： 对选中范围内符合指定条件的值求和。
案例：=SUMIF(B1:B5, "&gt;50") （结果：B1到B5中大于50的值求和）
SUMIFS： 对多条件单元格快速求和。
案例：=SUMIFS(C1:C5, D1:D5, "Category1", E1:E5, "Condition") （结果：C1到C5中满足多条件的值求和）
求平均函数： AVERAGE： 计算平均值。
案例：=AVERAGE(F1:F5) （结果：计算F1到F5中的平均值）
AVERAGEIF： 计算某个区域内满足条件的所有单元格的平均值。
案例：=AVERAGEIF(G1:G5, "&gt;0") （结果：对G1到G5中大于零的值求平均）
AVERAGEIFS： 求多重条件所有单元格的平均值。
案例：=AVERAGEIFS(H1:H5, I1:I5, "Category1", J1:J5, "Condition") （结果：H1到H5中满足多条件的值求平均）
最大值和最小值函数： MAX： 求最大值。
案例：=MAX(K1:K5) （结果：找出K1到K5中的最大值）
MIN： 求最小值。
案例：=MIN(L1:L5) （结果：找出L1到L5中的最小值）
位置函数： ROW： 确定光标的当前行位置。
案例：=ROW(M2) （结果：返回M2单元格所在的行位置）
COLUMN： 确定光标的当前列位置。
案例：=COLUMN(N3) （结果：返回N3单元格所在的列位置）
取整函数： TRUNC： 将数字的小数部分直接截去。
案例：=TRUNC(15.78) （结果：将15.78的小数部分截去，返回整数15）
四舍五入函数： ROUND： 将数字四舍五入到指定的位数。
案例：=ROUND(17.895, 1) （结果：将17.895四舍五入到一位小数）
随机数函数： RANDBETWEEN： 返回指定范围内的随机整数。
案例：=RANDBETWEEN(1, 100) （结果：生成1到100之间的随机整数）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6c0b9a494ed00312941792da58deadda/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc15acf4d05bdeb58385af6dbdc23137/" rel="bookmark">
			国考省考行测：语句排序2刷题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		国考省考行测：语句排序2刷题 2022找工作是学历、能力和运气的超强结合体!
公务员特招重点就是专业技能，附带行测和申论，而常规国考省考最重要的还是申论和行测，所以大家认真准备吧，我讲一起屡屡申论和行测的重要知识点
遇到寒冬，大厂不招人，可能很多算法学生都得去找开发，测开
测开的话，你就得学数据库，sql，oracle，尤其sql要学，当然，像很多金融企业、安全机构啥的，他们必须要用oracle数据库
这oracle比sql安全，强大多了，所以你需要学习，最重要的，你要是考网络警察公务员，这玩意你不会就别去报名了，耽误时间！
除了技术，申论和行测也得好好准备
文章目录 国考省考行测：语句排序2刷题@[TOC](文章目录) 行测：国考省考行测：语句排序2刷题捆绑分析 行测：国考省考行测：语句排序2刷题 捆绑分析 语意连贯
【1】词语指代不明句，前有明确所指句，借助代词词捆绑
【2】成对出现的关联词分属于2个不同的句子，借助关联词捆绑
【3】总结词、递进词，转折词，并列词出现的句子，前有话题语意一致的句子
eg：王在睡大觉，然而张笑了？？？
这前后没关系啊沃日
eg2：这本书，还有xxx功能，前面还有别的功能介绍，否则没法构成：还这个词
【4】时间词出现，要有先后顺序，过去，后来，如今，远古
年份，1998,2022,3088，年
朝代，历朝历代，清朝，明朝，唐代，元朝
时间，过去，后来，现在，如今，未来，以后，将来
历史事件，文化时间，盘古开天辟地，女娲补天，辛亥革命，改革开放，新中国成立，，，，
【5】空间词，出现，要符合逻辑先后
远近亲属
表里内外
eg：茫茫大海无边际，海水来了，海岸，鱼儿，就像妈妈spa
【6】顶真句，顶针修饰，需要捆绑
xx山，庙，故事，从前，有个太监，xxx
尾部词对头词
顶真
多个就行
捆绑你
【7】难度：语意逻辑要有先后,
拓展：问题要先于对策
引出先于定义
定义先于介绍
xxxx的更迭，迭代，是粉丝经济兴起的土壤，只有xxx，才能发挥粉丝经济的流量价值
有变质，变质的影响和作用
事件排序，单纯给你几件事，没有逻辑词没有时间词，就是事件
eg：一根绳子
一声叹息
一次邂逅
一晌贪欢
一座空城
一次别离
【8】句式一致的句子，语意上没毛病，捆绑
我们的xxx，我们的xxx，我们的xxx也会
不管如何，绑定一起
很长一段时间内，也是过去
直接秒杀答案
3引出创新，然后6说创新
2是引入
3对策，流量需要在前，所以4先于3，直接锁定答案
前他不用看
3引出
虽然但
34是因果逻辑
5需要前面有别的东西
35缺
6接3
4：这具
563必须联系在一起
一方面，另一方面
5是介绍
1是引入
错！！！！
3得先引出音准感
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cc15acf4d05bdeb58385af6dbdc23137/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc434168a597310e6ac8c146cddf2a47/" rel="bookmark">
			1.C语言——基础知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C语言基础知识 ==1.第一个C语言程序====2.注释====3.标识符====4.关键字====5.数据类型====6.变量====7.常量====8.运算符====9.输入输出==输入输出 1.第一个C语言程序 C语言的编程框架
#include &lt;stdio.h&gt; int main() { /* 我的第一个 C 程序 */ printf("Hello, World! \n"); return 0; } 2.注释 单行注释： //第一种写法 /* 单行注释 */ 多行注释： /* 多行注释 多行注释 多行注释 */ 3.标识符 C 标识符是用来标识变量、函数，或任何其他用户自定义项目的名称。
规定：C语言的的标识符由数字，字母，下划线构成，但不能以数字开头。
可以作为标识符的
mohd , zara , abc , move_name , a_123
myname50 , _temp , j , a23b9 , retVal
不可以作为标识符的
12mb , 23_m
4.关键字 具有特殊含义的标识符，C语言已经使用的了，用户自定义标识符时不能再使用。 后续的学习都会慢慢接触这些，现在只需要眼熟即可。
5.数据类型 数据类型就像一个盒子一样，盒子中存放数据，不同的数据要用不同的盒子装。
为了限制变量中所存储的数据（至少是可以兼容的）。
为了限制变量所占空间
先学习基本数据类型，其他的数据类型后续学习
char //字符数据类型
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dc434168a597310e6ac8c146cddf2a47/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bac3bdfb215e99977136b8f73664063b/" rel="bookmark">
			Deepin/Ubuntu_查看磁盘空间大小
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以下是Linux系统（Deepin、Ubuntu）查看磁盘空间大小的代码示例：
使用df命令： df -h 使用du命令查看指定目录的磁盘使用情况： du -sh /path/to/directory 使用lsblk命令： lsblk 使用fdisk命令查看磁盘分区表信息： sudo fdisk -l 请注意，在使用这些命令时，请确保具有适当的权限，比如使用sudo
may the odds be ever in your favor ~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d9899993292334aa1da3b7c0e99d3a1/" rel="bookmark">
			变了！每个做应用开发的都该看看
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、前言
前几天，在经历了一个月的推迟后，OpenAI 在周三正式推出了 GPT Store。借助这一在线商店，OpenAI 用户可以分享定制版 ChatGPT 聊天机器人。
很多人说：GPT Store 的推出，意味着 OpenAI 正式迎来它的 iPhone 时刻。
李彦宏去年年底在极客大会上发表了很多对于 AI 和大模型的观点，李彦宏表示：大模型本身是一个基础底座，类似操作系统，那么最终开发者要依赖为数不多的大模型来开发出各种各样的原生应用。我们需要的是百万量级的 AI 原生应用，而不是 100 个所谓的大模型。
我们普通人的机遇就在于基于人类的使用场景，去针对性的开发更多的 AI 应用来服务客户。
回想一下在 PC 互联网时代，Windows 操作系统基础，软件很多；到了移动互联网时代，安卓和 iOS 是基础系统，基于这个系统开发出了众多好玩的应用。一个应用服务众多的用户，哪个开发者没有赚的盆满钵满呢？
所以，AI 原生应用时代到来了，是我们每个人，尤其是开发者的一个机遇，我们应该把握住。
2、百度智能云千帆 AppBuilder
众所周知，国内想用 GPT还是比较麻烦的，但是，我们也有自己不错的大模型。比如：百度的文心大模型。而且，现在百度还推出了百度智能云千帆 AppBuilder。
通过名字 AppBuilder 我们就知道，百度云千帆 AppBuilder是基于大模型搭建 AI 原生应用的工作台，提供 RAG、Agent、GBI 等应用框架，文档问答、表格问答、对话、创作等应用组件，以及文生图、语音等传统 AI 组件，降低 AI 原生应用的开发门槛，赋能开发者快速实现应用搭建！
AppBuilder 面向不同开发能力的用户和开发场景，分别以低代码态、代码态的产品形态，提供了两层服务：应用组件、应用框架。以提高 AI 原生应用的开发效率，降低开发门槛。
今天想重点给大家介绍一下 AppBuilder 的一个非常强大的功能，对于我们开发者和程序员来讲，绝对很有帮助，很厉害。
绝对堪称 AppBuilder 为我们开发者带来了开发范式的变革。
我们就以桥牌为例：
桥牌，一种纸牌类游戏。典型的一次桥牌比赛需要10局或者25局，每局要算2次得分，每次算得分有5个参数、要做7步判断，因此可能产生2730种场景。面对这些复杂多类的场景，如果不是专业选手，很难完全算出。
规则和玩法看起来很复杂，但是，百度智能云千帆 AppBuilder，无需写代码，就可以1分钟开发出一个桥牌助手。通过基于代码解释器建立的大模型反思机制，让文心大模型生成可用、准确的桥牌计分代码，可以快速帮玩家实现自动计分。
举个例子：
我们创建一个应用，选择应用类型： Agent Builder ，然后填写应用名称。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4d9899993292334aa1da3b7c0e99d3a1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd615bf569244ce9a3398928acff93cd/" rel="bookmark">
			java小项目：简单的收入明细记事本，超级简单（不涉及数据库，通过字符串来记录）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、效果 二、代码 2.1 Acount类
package com.demo1; public class Acount { public static void main(String[] args) { String details = "收支\t账户金额\t收支金额\t说 明\n"; //通过字符串来记录收入明细 int balance = 10000; boolean loopFlag = true;//控制循环结束 while (loopFlag){ System.out.println("\n---------------------记账-----------------\n"); System.out.println(" 1 收支明细"); System.out.println(" 2 登记收入"); System.out.println(" 3 登记支出"); System.out.println(" 4 退 出\n"); System.out.print(" 请选择(1-4)："); char selection = Utility.readMenuSelection();//通过工具类获取用户的选择 switch (selection){ case '1': System.out.println("-----------------当前收支明细记录-----------------"); System.out.println(details); System.out.println("--------------------------------------------------"); break; case '2': System.out.print("本次收入金额："); int amount1 = Utility.readNumber(); System.out.print("本次收入说明："); String desc1 = Utility.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cd615bf569244ce9a3398928acff93cd/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/12/">«</a>
	<span class="pagination__item pagination__item--current">13/321</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/14/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>