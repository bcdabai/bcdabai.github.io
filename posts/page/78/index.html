<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec5769157b901d0bacde45b2b4cf2444/" rel="bookmark">
			微信小程序——个人相册（前端）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		微信小程序——个人相册（前端） 项目效果图 1.项目功能 1）用户管理，信息包括：头像、昵称，功能包括：获取微信用户信息、验证用户是否存在、修改头像、修改昵称
2）上传相片：上传图片
3）照册列表：封面图（轮播图）、照片列表、照片选择、删除照片
4）照片信息：照片信息包括 显示照片、大小（字节）、上传时间
2.项目结构 3.数据库 此项目使用MySQL8.0，创建数据库myphoto，SQL文件我已放在文章顶部。
4.创建项目 小程序项目名：myphoto使用2.30.0版本的基础库以及不启用远程校验准备好appid和appsecret，后端需要用到
5.代码 5.1 项目准备 app.js
// app.js App({ async onLaunch(){ let res=await wx.login(); let code=res.code; wx.request({ url: this.globalData.rootPath+'/account/getUserInfo', data:{code}, success:(result)=&gt;{ let userInfo=result.data; if (userInfo) { this.globalData.userInfo = userInfo; wx.redirectTo({ url: '/pages/index/index', }) } else { wx.redirectTo({ url: '/pages/mine/mine' }); } } }) }, globalData: { rootPath:"http://localhost:8089/myhome_war_exploded",//请修改为自己的服务根路径 userInfo: null, }, }) app.json
{ "entryPagePath": "pages/index/index", "pages": [ "pages/index/index", "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ec5769157b901d0bacde45b2b4cf2444/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd4701d0b834822870c4c9c9a26ba62c/" rel="bookmark">
			Laravel 8 Schema because the name is already in use
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在项目里面用composer install安装依赖时候报的错误：In AppServiceProvider.php line 7: Cannot use Illuminate\Support\Facades\Schema as Schema because the name is already in use。
提供一个解决思路上面的报错信息翻译出来就是：无法将Illuminate\Support\Facades\Schema用作架构，因为该名称已在使用中（大意就是错误的原因就是Schema 这个命名重复了。）找到AppServiceProvider.php文件打开。
果然重复了一行。删除多出的那一行。
重新composer install一下。
搞定。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65cd5d1a16c450183379b319c413c85d/" rel="bookmark">
			远程桌面出现了内部错误有哪些解决方法？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		远程桌面连接出现了内部错误解决方法 在使用Windows自带远程桌面连接时，有时会遇到“远程桌面出现了内部错误”这一问题。许多用户不知道如何解决远程桌面连接出现了内部错误，这里我们整理了五种有效的解决方法，分享出来以供参考。
方法一、重启远程桌面服务 远程桌面内部错误怎么办？比较简单又常见的方法就是在服务管理中重新启动远程桌面服务，然后再尝试进行远程连接。
步骤1. 在键盘上按“Windows + R”键打开运行框输入“services.msc”，再按下回车键打开服务窗口。
步骤2. 找到“Remote Desktop Services”并双击打开它，然后单击“停止”并单击“确定”。
步骤3. 关闭远程桌面服务后，再次打开远程桌面服务，在启动类型中选择“自动”并单击“确定”。
方法二、更改远程桌面设置 远程桌面出现了内部错误您也可以通过更改远程桌面设置来进行解决，具体的操作步骤如下：
步骤1. 打开运行框输入“mstsc”并按下回车键打开远程桌面连接，然后单击左下角的“显示选项”，再选择“高级”选项卡并单击“设置”。
步骤2. 在弹出的RD网关服务器设置窗口中，选择“不使用RD网关服务器”并单击“确定”，然后再进行远程连接。
方法三、远程桌面软件（推荐） 以上方法都可以解决Windows自带远程控制出现内部错误这一问题，若这些方法您都一一尝试之后还是无法解决，您可以考虑使用第三方远程桌面软件进行远程控制，例如：AnyViewer远程桌面软件。当无法解决远程桌面出现了内部错误这一问题时，您可以试试使用AnyViewer远程桌面进行远程控制。
AnyViewer是一款免费的远程桌面，您可以使用它在电脑端或移动设备上远程控制电脑，该软件支持Windows、Windows Server、iOS和Android等系统，您可以使用它随时随地的远程控制另外一台电脑。
步骤1. 到下载中心将软件安装到电脑上，打开AnyViewer远程桌面软件选择“连接”选项并在伙伴ID处输入另外一台电脑的设备ID，再单击“连接”。
步骤2. 在弹出的远程控制方式中选择“向伙伴发送控制请求”并单击“确定”。
步骤3. 然后，另外一台电脑将收到控制请求，再单击“同意”即可实现远程控制。
AnyViewer远程桌面除了通过发送控制请求这种方式外，您还可以通过输入安全码这种方式实现无人值守远程控制电脑。在远程控制期间您还可以进行远程文件传输、发送消息、更改远程桌面分辨率等操作。
总结 在这篇文章中，我们分享了三种远程桌面出现了内部错误的解决方法，希望对您有所帮助。若您觉得解决该问题比较麻烦，可以直接使用方法五进行远程控制，该远程控制方式操作即简单又快速，快来下载体验一下吧！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9cef4952c2a84a9ae5b68d2dabde759/" rel="bookmark">
			【SSO】单点登录方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、单点登录问题 由于Http请求是无状态的请求，服务器无法确认登录信息。当用户登录时，将用户信息存储到Session中，Session将认证的用户信息以Cookie方式返回给客户端。每次用户请求不同的业务系统，都会携带Cookie去请求。保证了不同系统之间访问时，不需要用户重新认证。
如下图所示：当客户端登录商品系统时(①②)，Session会记录用户登录的信息并返回给Cookie。当用户发起支付时(③)，支付系统会请求Session进行认证(④)，Session认证成功后返回认证信息给支付系统(⑤)，支付系统完成支付并返回支付信息给商品系统(⑥)，从而完成整个购买支付流程。
但不同的服务器，session无法共享，导致商品系统和支付系统无法通信！！！cookie无法跨域，存放在商品系统【http://goods.com】下的cookie认证信息无法在请求支付系统【http://pay.com】中使用（域名不同）！！！ 二、Session共享的解决方案 Tomcat集群Session全局复制（集群内每个tomcat的session完全同步）【会影响集群的性能，不建议】。根据请求的IP进行Hash映射到对应的机器上（这就相当于请求的IP一直会访问同一个服务器）【如果服务器宕机了，会丢失了一大部分Session的数据，不建议】把Session数据放在Redis中（使用Redis模拟Session）【建议】独立出来一个认证子系统，将所有的认证信息存放到认证子系统中。 三、cookie跨域问题的解决方案 服务端将Cookie写到客户端后，客户端对Cookie进行解析，将Token解析出来，此后请求都把这个Token带上。多个域名共享Cookie，在写到客户端的时候设置Cookie的domain。将Token保存在SessionStroage中（不依赖Cookie就没有跨域的问题了） 四、单点登录认证系统实现 下面对上图简要描述
（1）用户访问系统1的受保护资源，系统1发现用户未登录，跳转至sso认证中心，并将自己的地址作为参数；
（2）sso认证中心发现用户未登录，将用户引导至登录页面；
（3）用户输入用户名密码提交登录申请；
（4）sso认证中心校验用户信息，创建用户与sso认证中心之间的会话，称为全局会话，同时创建授权令牌；
（5）sso认证中心带着令牌跳转会最初的请求地址（系统1）；
（6）系统1拿到令牌，去sso认证中心校验令牌是否有效；
（7）sso认证中心校验令牌，返回有效，注册系统1；
（8）系统1使用该令牌创建与用户的会话，称为局部会话，返回受保护资源；
（9）用户访问系统2的受保护资源；
（10）系统2发现用户未登录，跳转至sso认证中心，并将自己的地址作为参数；
（11）sso认证中心发现用户已登录，跳转回系统2的地址，并附上令牌；
（12）系统2拿到令牌，去sso认证中心校验令牌是否有效；
（13）sso认证中心校验令牌，返回有效，注册系统2；
（14）系统2使用该令牌创建与用户的局部会话，返回受保护资源。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f005736b02ace03cceb1285b9b3f905/" rel="bookmark">
			【Activiti】原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、核心类 RepositoryService：部署管理流程资源，如bpmn文件、附件等等；RuntimeService：操作运行时的流程；TaskService：流程中任务的信息；HistoryService：流程的历史信息；ManagerService：管理流程引擎的信息。 二、核心表 ACT_GE_*：General，表示通用表。ACT_HI_*：History，保存历史数据，比如执行过的流程实例、变量、任务等等。Activiti默认提供四种历史级别：none（不保存任何历史记录）、activity（保存所有的流程实例、任务、活动信息）、audit（默认级别，保存所有的流程实例、任务、活动、表单属性）、full（最完整的历史记录，详细到日志跟踪）。ACT_ID_*：Identity，保存身份信息，比如用户和组之间的关系。Activiti被集成到某一系统时，这些表可以不用，而直接使用现有系统中的用户或组信息。ACT_RE_*：Repository，保存一些仓库信息，比如流程定义、流程资源(图片或规则等)。ACT_RU_*：Runtime，保存一些流程实例、用户任务、变量等的运行时数据。当流程结束后会立即移除这些数据。 三、使用步骤 （1）编写bpmn文件，画流程图，在application.yml配置文件中【process-definition-location-prefix】标明需要扫描的流程图路径；
（2）创建流程引擎；
（3）获取RepositoryService实例：相当于拿到数据库连接；
（4）使用RepositoryService部署流程：相当于使用RepositoryService操作数据库。此处可设置流程名字、addClassPathResource()绑定流程图、部署流程。
（5）启动流程【RuntimeService】；
（6）创建任务【TaskService】；
（7）根据流程定义处理人等查询，并根据任务ID完成任务：taskService.complete()。
// 1.创建流程引擎 ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine(); // 2.获取RepositoryService实例：相当于拿到数据库连接 RepositoryService repositoryService = processEngine.getRepositoryService(); // 3.使用RepositoryService部署流程：相当于使用RepositoryService操作数据库 Deployment deployment = repositoryService.createDeployment() .name("请假申请流程") // 设置流程的名称 .addClasspathResource("processes/Leave.bpmn") // 设置流程所用到的资源 .addClasspathResource("processes/Leave.png") // 设置流程所用到的图片 .deploy(); // 部署流程，相当于插入操作 // 4.获取RuntimeService，根据流程定义ID启动流程实例 RuntimeService runtimeService = processEngine.getRuntimeService(); ProcessInstance processInstance = runtimeService.startProcessInstanceByKey("myLeave"); // 5.创建TaskService，根据流程key和任务负责人查询此流程（myLeave）下的该负责人（zhangsan）所拥有的任务信息。 TaskService taskService = processEngine.getTaskService(); // 6.获取TaskService，完成任务 TaskService taskService = processEngine.getTaskService(); Task task = taskService.createTaskQuery() .processDefinitionKey("myLeave") .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4f005736b02ace03cceb1285b9b3f905/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86e253701670699a4c493a12e9e99fd5/" rel="bookmark">
			软件测试实验五 自动化测试参考案例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Web自动化测试工具
1. 主流的Web自动化测试工具
1）QTP：是一个商业化的功能测试工具，收费，支持web，桌面自动化测试。
2）Selenium：是一个开源的web自动化测试工具，免费，主要做功能测试。
3）Robot framework：一个基于Python可扩展地关键字驱动的测试自动化框架。
2. 什么是Selenium？
Selenium是一个用于Web应用程序的自动化测试工具；中文的意思（硒）
Selenium是一个基于浏览器的自动化工具，它提供了一种跨平台、跨浏览器的端到端的web自动化解决方案。
Selenium主要包括三部分：
· Selenium IDE：浏览器的一个插件（扩展），它可以进行录制回放，并且可以把录制的操作以多种语言（如JAVA、Python、C#等）的形式导出成测试用例。
· Selenium WebDriver： 提供Web自动化所需的API，主要用作浏览器控制、页面元素选择和调试。不同的浏览器需要不同的WebDriver。
· Selenium Grid： 提供了在不同机器的不同浏览器上运行selenium测试的能力。（分布式测试）
这里的框架主要使用Python结合Selenium WebDriver库进行搭建的。通常，一个典型的自动化测试框架一般包括用例管理模板、自动化执行控制器、报表生成模块、日志模块和邮件发送模块等。
3.Selenium特点
1）开源软件：源代码开放可以根据需要来增加工具的某些功能
2）跨平台：linux、windows、mac
3）支持多种浏览器：Firefox、Chrome、IE、Edge、Opera、Safari等
4）支持多种语言：Python、Java、C#、JavaScript、Ruby、PHP等
5）成熟稳定：目前已经被google、百度、腾讯等公司广泛使用
6）功能强大：能够实现类似商业工具的大部分功能，因为开源性，可实现定制化功能
二、Python3+Selenium3+ Firefox自动化测试 环境搭建
1. Python 开发环境
2. PyCharm编辑器
3. selenium包
4. 浏览器
5. 浏览器驱动 -- 保证能够用程序驱动浏览器，实现自动化测试
6. Selenium IDE浏览器插件
1. Python 开发环境：安装Python解释器
Python是一种面向对象的、解释性的、跨平台的而高级程序设计语言，可以用于自动化测试，一方面、Python易学，模块多，类库丰富，有独立的单元测试框架；另一方面，目前很多的自动化测试框架基本都是支持Python的。
Python的下载与安装：
1）登录Python官网的下载页面Download Python | Python.org，根据自己的操作系统选择下载合适的平台及版本。
2）双击下载的文件进入安装界面、安装完成后关闭安装向导程序。
（1）双击下载好的安装包“python-3.8.10-amd64.exe”
（2）勾选添加到环境中，并选择自定义安装
（3）点击“Next”进入下一步
（4）修改安装路径，并点击“Install”开始安装
（5）点击“Close”完成安装
3）配置Python的环境变量。将Python的安装路径及路径下的script目录添加到path环境变量。
4）验证，进入Python环境。打开命令行窗口输入“python”后回车，如果能看到Python的版本信息，如果可以进入解释器，说明安装成功。退出：exit()。
2. PyCharm编辑器的下载和安装
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/86e253701670699a4c493a12e9e99fd5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8078c12067bc88a29f81bb02b412c176/" rel="bookmark">
			MySQL之存储过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、概述
二、存储过程的优点
三、存储过程的应用
1.创建存储过程
2.调用存储过程
3. 查看存储过程
​四、存储过程的参数
1.输入参数 IN
2.输出参数 OUT
3.输入输出参数 INOUT
五、删除存储过程
六、存储过程的控制语句
1. 条件语句if-then-else ···· end if ​2. 循环语句while ···· end while
一、概述 存储过程是一组为了完成特定功能的SQL语句集合。
存储过程在使用过程中是将常用或者复杂的工作预先使用SQL语句写好并用一个指定的名称存储起来，这个过程经编译和优化后存储在数据库服务器中。当需要使用该存储过程时，只需要调用它即可。存储过程在执行上比传统SQL速度更快、执行效率更高。
二、存储过程的优点 执行一次后，会将生成的二进制代码驻留缓冲区，提高执行效率SQL语句加上控制语句的集合，灵活性高在服务器端存储，客户端调用时，降低网络负载可多次重复被调用，可随时修改，不影响客户端调用可完成所有的数据库操作，也可控制数据库的信息访问权限 三、存储过程的应用 1.创建存储过程 #先临时修改SQL语句结束符 delimiter $$ #创建存储过程 #创建存储过程需要在库中，要先指定存放的库 use hello; create procedure proc1() begin #过程体以关键字 BEGIN 开始 create table hello.test (id int,name varchar(10),age int,hobby varc insert into hello.test values(1,'zhangsan',20,'dancing'); insert into hello.test values(2,'lisi',24,'singing'); select * from hello.test; end$$ #过程体以关键字 END 结束 #将SQL语句结束符改回 ; delimiter ; 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8078c12067bc88a29f81bb02b412c176/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/52b6b007ff7ca8d75e218d0595953ea8/" rel="bookmark">
			MsSqlServer配置管理器TCP/IP属性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		TCP/IP 属性（“IP 地址”选项卡） 使用 “TCP/IP 属性（‘IP 地址’选项卡）” 对话框，可以配置特定 IP 地址的 TCP/IP 协议选项。
只有选中 “IP All” ，才能一次配置所有地址的 “TCP 动态端口” 和 “TCP 端口” 。
更改在重启 SQL Server 后生效。 有关启动和停止 SQL Server Browser 服务的信息，请参阅 启动和停止 SQL Server Browser 服务。
静态端口与动态端口 SQL Server 的默认实例侦听端口 1433 上传入的连接。 可以出于安全原因或客户端应用程序要求更改此端口。 默认情况下，命名实例（包含 SQL Server Express）被配置为侦听动态端口。 若要配置静态端口，请将 “TCP 动态端口” 框保留为空，并在 “TCP 端口” 框中提供一个可用的端口号。 有关打开防火墙中的端口的详细信息，请参阅联机丛书中的“配置 Windows 防火墙以允许 SQL Server 访问”。
动态端口 如果某个 SQL Server 实例已配置为侦听动态端口，则在启动时，该实例将检查操作系统中的可用端口，并为该端口打开一个端点。 传入连接必须指定要连接的端口号。 由于每次启动 SQL Server 时动态端口号都可能会改变，因此 SQL Server 提供 SQL Server Browser 服务来监视端口，并将传入连接指向该实例的当前端口。 使用动态端口会增加通过防火墙连接 SQL Server 的复杂性，因为重新启动 SQL Server 时端口号可能会改变，从而需要更改防火墙设置。 若要避免通过防火墙连接的问题，请将 SQL Server 配置为使用静态端口。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/52b6b007ff7ca8d75e218d0595953ea8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7355da2d7612d8c27182acbf7a5e3307/" rel="bookmark">
			C#中向数组中添加一个元素和向数组中添加另一个数组
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、向数组中任意位置添加一个元素 2、向指定的一维数组中任意位置添加另一个数组
向数组中添加数组元素有两种情况：一是在数组中添加一个元素；二是在数组中添加一个数组。
1、向数组中任意位置添加一个元素 //添加数组元素 using System; using System.Collections.Generic; using System.Linq; using System.Text; namespace AddItem { class Program { /// &lt;summary&gt; /// 增加单个数组元素 /// &lt;/summary&gt; /// &lt;param name="ArrayBorn"&gt;要向其中添加元素的一维数组&lt;/param&gt; /// &lt;param name="Index"&gt;添加索引&lt;/param&gt; /// &lt;param name="Value"&gt;添加值&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; static int[] AddArray(int[] ArrayBorn, int Index, int Value) { if (Index &gt;= (ArrayBorn.Length)) //如果实参索引是否大于数组的长度 Index = ArrayBorn.Length - 1; //则索引值为数组的最大索引(数组末尾) int[] TemArray = new int[ArrayBorn.Length + 1]; //声明一个新的数组 for (int i = 0; i &lt; TemArray.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7355da2d7612d8c27182acbf7a5e3307/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a91a29ca407a4d42d1d8b0ecc6cfa021/" rel="bookmark">
			YOLOv3的配置与模型的建立
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		yolov3.cfg的配置信息：
[net] # Testing #batch=1 #subdivisions=1 # Training batch=16 subdivisions=1 width=416 height=416 channels=3 momentum=0.9 decay=0.0005 angle=0 saturation = 1.5 exposure = 1.5 hue=.1 learning_rate=0.001 burn_in=1000 max_batches = 500200 policy=steps steps=400000,450000 scales=.1,.1 [convolutional] batch_normalize=1 filters=32 size=3 stride=1 pad=1 activation=leaky # Downsample [convolutional] batch_normalize=1 filters=64 size=3 stride=2 pad=1 activation=leaky [convolutional] batch_normalize=1 filters=32 size=1 stride=1 pad=1 activation=leaky [convolutional] batch_normalize=1 filters=64 size=3 stride=1 pad=1 activation=leaky [shortcut] from=-3 activation=linear # Downsample [convolutional] batch_normalize=1 filters=128 size=3 stride=2 pad=1 activation=leaky [convolutional] batch_normalize=1 filters=64 size=1 stride=1 pad=1 activation=leaky [convolutional] batch_normalize=1 filters=128 size=3 stride=1 pad=1 activation=leaky [shortcut] from=-3 activation=linear [convolutional] batch_normalize=1 filters=64 size=1 stride=1 pad=1 activation=leaky [convolutional] batch_normalize=1 filters=128 size=3 stride=1 pad=1 activation=leaky [shortcut] from=-3 activation=linear # Downsample [convolutional] batch_normalize=1 filters=256 size=3 stride=2 pad=1 activation=leaky [convolutional] batch_normalize=1 filters=128 size=1 stride=1 pad=1 activation=leaky [convolutional] batch_normalize=1 filters=256 size=3 stride=1 pad=1 activation=leaky [shortcut] from=-3 activation=linear [convolutional] batch_normalize=1 filters=128 size=1 stride=1 pad=1 activation=leaky [convolutional] batch_normalize=1 filters=256 size=3 stride=1 pad=1 activation=leaky [shortcut] from=-3 activation=linear [convolutional] batch_normalize=1 filters=128 size=1 stride=1 pad=1 activation=leaky [convolutional] batch_normalize=1 filters=256 size=3 stride=1 pad=1 activation=leaky [shortcut] from=-3 activation=linear [convolutional] batch_normalize=1 filters=128 size=1 stride=1 pad=1 activation=leaky [convolutional] batch_normalize=1 filters=256 size=3 stride=1 pad=1 activation=leaky [shortcut] from=-3 activation=linear [convolutional] batch_normalize=1 filters=128 size=1 stride=1 pad=1 activation=leaky [convolutional] batch_normalize=1 filters=256 size=3 stride=1 pad=1 activation=leaky [shortcut] from=-3 activation=linear [convolutional] batch_normalize=1 filters=128 size=1 stride=1 pad=1 activation=leaky [convolutional] batch_normalize=1 filters=256 size=3 stride=1 pad=1 activation=leaky [shortcut] from=-3 activation=linear [convolutional] batch_normalize=1 filters=128 size=1 stride=1 pad=1 activation=leaky [convolutional] batch_normalize=1 filters=256 size=3 stride=1 pad=1 activation=leaky [shortcut] from=-3 activation=linear [convolutional] batch_normalize=1 filters=128 size=1 stride=1 pad=1 activation=leaky [convolutional] batch_normalize=1 filters=256 size=3 stride=1 pad=1 activation=leaky [shortcut] from=-3 activation=linear # Downsample [convolutional] batch_normalize=1 filters=512 size=3 stride=2 pad=1 activation=leaky [convolutional] batch_normalize=1 filters=256 size=1 stride=1 pad=1 activation=leaky [convolutional] batch_normalize=1 filters=512 size=3 stride=1 pad=1 activation=leaky [shortcut] from=-3 activation=linear [convolutional] batch_normalize=1 filters=256 size=1 stride=1 pad=1 activation=leaky [convolutional] batch_normalize=1 filters=512 size=3 stride=1 pad=1 activation=leaky [shortcut] from=-3 activation=linear [convolutional] batch_normalize=1 filters=256 size=1 stride=1 pad=1 activation=leaky [convolutional] batch_normalize=1 filters=512 size=3 stride=1 pad=1 activation=leaky [shortcut] from=-3 activation=linear [convolutional] batch_normalize=1 filters=256 size=1 stride=1 pad=1 activation=leaky [convolutional] batch_normalize=1 filters=512 size=3 stride=1 pad=1 activation=leaky [shortcut] from=-3 activation=linear [convolutional] batch_normalize=1 filters=256 size=1 stride=1 pad=1 activation=leaky [convolutional] batch_normalize=1 filters=512 size=3 stride=1 pad=1 activation=leaky [shortcut] from=-3 activation=linear [convolutional] batch_normalize=1 filters=256 size=1 stride=1 pad=1 activation=leaky [convolutional] batch_normalize=1 filters=512 size=3 stride=1 pad=1 activation=leaky [shortcut] from=-3 activation=linear [convolutional] batch_normalize=1 filters=256 size=1 stride=1 pad=1 activation=leaky [convolutional] batch_normalize=1 filters=512 size=3 stride=1 pad=1 activation=leaky [shortcut] from=-3 activation=linear [convolutional] batch_normalize=1 filters=256 size=1 stride=1 pad=1 activation=leaky [convolutional] batch_normalize=1 filters=512 size=3 stride=1 pad=1 activation=leaky [shortcut] from=-3 activation=linear # Downsample [convolutional] batch_normalize=1 filters=1024 size=3 stride=2 pad=1 activation=leaky [convolutional] batch_normalize=1 filters=512 size=1 stride=1 pad=1 activation=leaky [convolutional] batch_normalize=1 filters=1024 size=3 stride=1 pad=1 activation=leaky [shortcut] from=-3 activation=linear [convolutional] batch_normalize=1 filters=512 size=1 stride=1 pad=1 activation=leaky [convolutional] batch_normalize=1 filters=1024 size=3 stride=1 pad=1 activation=leaky [shortcut] from=-3 activation=linear [convolutional] batch_normalize=1 filters=512 size=1 stride=1 pad=1 activation=leaky [convolutional] batch_normalize=1 filters=1024 size=3 stride=1 pad=1 activation=leaky [shortcut] from=-3 activation=linear [convolutional] batch_normalize=1 filters=512 size=1 stride=1 pad=1 activation=leaky [convolutional] batch_normalize=1 filters=1024 size=3 stride=1 pad=1 activation=leaky [shortcut] from=-3 activation=linear ###################### [convolutional] batch_normalize=1 filters=512 size=1 stride=1 pad=1 activation=leaky [convolutional] batch_normalize=1 size=3 stride=1 pad=1 filters=1024 activation=leaky [convolutional] batch_normalize=1 filters=512 size=1 stride=1 pad=1 activation=leaky [convolutional] batch_normalize=1 size=3 stride=1 pad=1 filters=1024 activation=leaky [convolutional] batch_normalize=1 filters=512 size=1 stride=1 pad=1 activation=leaky [convolutional] batch_normalize=1 size=3 stride=1 pad=1 filters=1024 activation=leaky [convolutional] size=1 stride=1 pad=1 filters=255 activation=linear [yolo] mask = 6,7,8 anchors = 10,13, 16,30, 33,23, 30,61, 62,45, 59,119, 116,90, 156,198, 373,326 classes=80 num=9 jitter=.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a91a29ca407a4d42d1d8b0ecc6cfa021/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60ce0d42a7824e458f43a0073a13193f/" rel="bookmark">
			Yolov5-Face 原理解析及算法解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		YOLOv5-Face 文章目录 YOLOv5-Face1. 为什么人脸检测 = 一般检测？1.1 YOLOv5Face人脸检测1.2 YOLOv5Face Landmark 2.YOLOv5Face的设计目标和主要贡献2.1 设计目标2.2 主要贡献 3. YOLOv5Face架构3.1 模型架构3.1.1 模型示意图3.1.2 CBS模块3.1.3 Head输出3.1.4 stem结构3.1.5 CSP结构3.1.9 SPP结构 3.2 输入端的改进3.3 Landmark回归3.3.1 输出 Landmark3.3.2 Landmark损失函数Wing3.3.3 Wing Loss 3.4 后处理NMS3.4.1 yolov53.4.2 yolov5s-face 4.模型训练4.1 下载源码4.2 下载widerface数据集4.3 运行train2yolo.py和val2yolo.py4.4 train4.4.1 更改训练配置文件4.4.2 训练可视化4.4.3 相关报错 4.5 detect4.6 ONNX导出及TensorRT环境配置4.7 OnnXruntime推理 近年来，CNN在人脸检测方面已经得到广泛的应用。但是许多人脸检测器都是需要使用特别设计的人脸检测器来进行人脸的检测，而YOLOv5的作者则是把人脸检测作为一个一般的目标检测任务来看待的。
YOLOv5Face在YOLOv5的基础上添加了一个 5-Point Landmark Regression Head（关键点回归），并对Landmark Regression Head使用了Wing loss进行约束。YOLOv5Face设计了不同模型尺寸的检测器，从大模型到超小模型，以实现在嵌入式或移动设备上的实时检测。
在WiderFace数据集上的实验结果表明，YOLOv5Face在几乎所有的Easy、Medium和Hard子集上都能达到最先进的性能，超过了特定设计的人脸检测器。
Github地址：https://www.github.com/deepcam-cn/yolov5-face
1. 为什么人脸检测 = 一般检测？ 1.1 YOLOv5Face人脸检测 在YOLOv5Face的方法中是把人脸检测作为一个一般的目标检测任务。与TinaFace想法类似把人脸作为一个目标。正如在TinaFace中所讨论的：
从数据的角度来看，人脸所具有的诸如姿态、尺度、遮挡、光照以及模糊等也会出现在其他的一般检测任务之中；从面部的独特属来看性，如表情和化妆，也可以对应一般检测问题中的形状变化和颜色变化。 1.2 YOLOv5Face Landmark ​ Landmark相对来说是一个特殊的存在，但他们也并不是唯一的。它们只是一个物体的关键点。例如，在车牌检测中，也使用了Landmark。在目标预测模型的Head中添加Landmark回归相对来说是一键简单的事情。那么从人脸检测所面临的挑战来看，多尺度、小人脸、密集场景等在一般的目标检测中都存在。因此，人脸检测完全可以看作一个一般目标检测子任务。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/60ce0d42a7824e458f43a0073a13193f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b678f75274611ecda8e9d4b14304ebab/" rel="bookmark">
			JBoss缓存和数据目录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		work、tmp、log、data目录是JBoss创建的。如果用户没有启动过JBoss服务器，则这些目录不会被创建。
一、work 位置：%JBOSS_HOME%\server\default\work
作用：提供给tomcat编译jsp文件用。
注意：更新项目代码文件时，需要清理work下文件，如：tldCache.ser、SESSIONS.ser。
二、tmp 位置：%JBOSS_HOME%\server\default\tmp
作用：tmp目录被用来提供JBoss服务的临时存储。
三、log 位置：%JBOSS_HOME%\server\default\log
作用：日志文件夹。如果你要修改日志输出目录，可以通过配置conf/log4j.xml实现。
四、data 位置：%JBOSS_HOME%\server\default\data
作用：服务中需要存储内容到文件系统的都会保存到data目录。比如，嵌入的数据库、或者JBossMQ，JBoss内嵌的Hypersonic database的数据也是保存到这里的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/acdb91fe55f5e82d8de748f89361601f/" rel="bookmark">
			Flutter 自定义ICON库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Flutter 自定义ICON库 Flutter提供了一些内置的ICON库，但在实际开发中，可能需要一些自定义的ICON图标。Flutter允许我们使用自定义图标，本文将介绍如何创建和使用自定义ICON库。
创建自定义ICON库 要创建自定义ICON库，我们需要执行以下步骤：
创建一个包含所有自定义图标的文件夹，例如icons。在文件夹icons中创建一个pubspec.yaml文件，并添加以下内容： name: custom_icons fonts: - family: custom_icons fonts: - asset: fonts/custom_icons.ttf 在文件夹icons中创建一个字体文件，例如custom_icons.ttf。可以使用第三方字体生成器来创建字体文件。确保将所有自定义图标添加到字体文件中。在Flutter项目中的pubspec.yaml文件中声明我们的自定义ICON库： dependencies: flutter: sdk: flutter custom_icons: path: icons 在上述步骤中，我们首先定义了自定义ICON库的名称。我们还需要指定字体文件和字体家族。字体家族是指在Flutter应用程序中引用自定义图标时的名称。
要将自定义图标添加到字体文件中，我们可以使用多个工具和应用程序，例如IcoMoon和Fontello。这些应用程序允许我们导入自定义SVG文件并将其转换为字体文件中的矢量图标。
在Flutter应用程序中使用自定义ICON库非常简单。我们需要导入自定义ICON库并在需要显示自定义图标的地方使用Icon小部件。我们可以使用自定义图标的名称来创建IconData对象。
使用自定义ICON库 要在Flutter应用程序中使用自定义ICON库，我们需要执行以下步骤：
导入自定义ICON库： import 'package:custom_icons/custom_icons.dart'; 使用自定义图标： Icon(CustomIcons.my_custom_icon) 在上述示例中，我们使用了自定义ICON库中的my_custom_icon图标。
我们还可以使用自定义图标的其他属性，例如大小和颜色。要更改图标的大小，请使用size属性。要更改图标的颜色，请使用color属性。
这是使用自定义ICON库的基本步骤，希望对你有所帮助。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5505ef260c96bf555e295fd072c9ebc1/" rel="bookmark">
			pycharm安装于配置pyqt5环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、依次使用pip命令下载pyqt包（这里使用的国内下载源，可适当调整） pip install pyqt5 -i https://pypi.douban.com/simple/ pip install pyqt5-tools -i https://pypi.douban.com/simple/ pip install pyqt5designer -i https://pypi.douban.com/simple/
2、下载完成后，找到qtdesigner.exe、pyuic5.exe、pyrcc5.exe三个工具所在的路径 一般在python安装环境下的子目录中，以下是作者的实际路径，可以参考查找。
D:\python3.9\Lib\site-packages\QtDesigner\designer.exe
D:\python3.9\Scripts\pyuic5.exe
D:\python3.9\Scripts\pyrcc5.exe
3、在pycharm中具体添加上述工具 可以参考以下链接，因为文章已经叙述的比较详细，这里不继续详细叙述。
PyCharm+Qt Designer+PyUIC+PyRcc安装配置教程_漫漫进阶路的博客-CSDN博客
4、实际添加效果，如下图所示。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc01db3b35f25c4d4db6ebf3698fd457/" rel="bookmark">
			Node.js——Node环境及nvm版本管理安装及使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 引言一. 初始Node.js二. 选择操作系统和安装包三. Node.js环境安装四. nvm的安装五. Node.js环境执行JS代码 引言 Node.js是一种强大的服务器端开发平台，为构建高性能和可伸缩的应用程序提供了丰富的工具和库。在开始开发之前，你需要正确地安装和设置Node.js，以确保你的开发环境准备就绪。本文将指导你如何在不同操作系统上安装Node.js，并配置你的开发环境。我们还将介绍一些常用的版本管理工具，以及如何创建和运行你的第一个Node.js应用程序。让我们开始吧！
一. 初始Node.js Node.js是一个开源、跨平台的 JavaScript 运行时环境。其中文的官方网址为：Node.js中文官网 注意：浏览器是JavaScript的前端运行环境；Node.js是JavaScript的后端运行环境，所以在Node.js中是无法调用DOM和BOM等浏览器内置的API的：。
Node.js作为一个JavaScript的运行环境，仅仅提供了基础的功能和API。然而，基于Node.js提供的这些基础功能出现了很多强大的工具和框架。所以学会Node.js，可以让前端程序员胜任更多的工作和岗位。比较热门的框架和应用如下：
1）基于 Express 框架，网址为：express网址，可以快速构建Web应用。
2）基于 Electron 框架，网址为：electron网址，可以构建跨平台的桌面应用。
3）基于 restify 框架，网址为：restify网址，可以快速构建API接口项目。
4）读写和操作数据库，创建实用的命令行工具辅助前端开发等。
总结：Node.js可以进行轻量级高性能的Web服务、前后端JavaScript同构开发、便捷高效的前端工程化。
二. 选择操作系统和安装包 首先，你需要选择适合你操作系统的Node.js安装包。Node.js提供了针对不同操作系统的预编译二进制包，包括Windows、Mac和Linux。你可以在Node.js官方网站上找到适合你系统的安装包。
对于Windows用户，你可以下载适用于你系统的MSI安装程序。双击安装程序并按照提示进行安装。
对于Mac用户，你可以下载适用于你系统的.pkg安装程序。双击安装程序并按照提示进行安装。
对于Linux用户，你可以使用包管理工具来安装Node.js。具体的安装方式可以参考Node.js官方文档或你所使用的Linux发行版的文档。
三. Node.js环境安装 如果是通过Node.js来运行JavaScript代码，则计算机上必须安装Node.js环境才可以
长期维护版：：也称LTS，适合追求稳定性的企业级项目。
最新尝鲜版：：也称Current，适合热衷于新特性的用户，但该版本可能存在隐藏的bug或安全性漏洞，因此不推荐企业级项目使用。
安装过程，一直下一步即可，其中安装路径看自己的选择（我一般选择安装在D盘不选择C盘）。安装完成之后为了确保自己是否安装成功可以查看一下自己安装的版本号。打开终端(win + R)输入cmd来打开命令提示符，在终端输入命令 node-v来查看自己安装的Node.js的版本号.
四. nvm的安装 nvm（Node Version Manager）：node.js版本管理器，Nodejs有很多的版本可以通过nvm来切换版本。
官方下载链接： nvm官方下载 选择如下的压缩包进行安装。
只需点击第三个，下载安装包，下载之后点击安装，无需配置就可以使用，十分方便。
简单说明：
nvm-noinstall.zip： 这个是绿色免安装版本，但是使用之前需要配置nvm-setup.zip：这是一个安装包，下载之后点击安装，无需配置就可以使用，方便。Source code(zip)：zip压缩的源码Sourc code(tar.gz)：tar.gz的源码，一般用于*nix系统 安装
第一安装目录：这里没有使用默认的安装目录，修改安装目录为 D:\nvm\ ；读者可自行决定安装目录第二安装目录：添加 node.js 的安装目录这里用 “添加 node.js 的安装目录” 的说法其实不太准确，准确的说法应该是配置 node.js 的安装目录；默认会使用 C:\Program Files\nodejs 目录，C:\Program Files\nodejs 目录也是 node.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cc01db3b35f25c4d4db6ebf3698fd457/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b56102479a76b08b4de447f145887fd0/" rel="bookmark">
			Floyd算法：寻找全局最短路径的利器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Floyd算法：寻找全局最短路径的利器 导言：一、Floyd算法概述：二、Floyd算法的特点：三、Floyd算法的实现步骤：四、应用场景：五、Floyd算法的优点：六、Floyd算法的局限性：结语： 导言： 在图论中，寻找最短路径是一个经典的问题，而Floyd算法则是一种广泛使用的解决方法。本文将介绍Floyd算法的基本概念、应用场景以及实现步骤，以帮助读者了解和应用这一强大的算法。
一、Floyd算法概述： Floyd算法用于寻找图中任意两个顶点之间的最短路径。它采用动态规划的思想，通过逐步迭代更新路径长度，最终求得全局最短路径。相较于其他算法，如Dijkstra算法和Bellman-Ford算法，Floyd算法的特点是可以处理带有负权边的图。
二、Floyd算法的特点： 全局最短路径：Floyd算法能够找到图中任意两点之间的最短路径。动态规划：通过逐步更新路径长度的方式，不断迭代得到最优解。适用范围广：Floyd算法适用于有向图和无向图，并能处理带有负权边的情况。 三、Floyd算法的实现步骤： 构建初始路径矩阵：根据图的邻接矩阵构建一个初始路径矩阵，其中每个元素表示两个顶点之间的初始路径长度。迭代更新路径长度：通过不断更新路径长度矩阵，使用动态规划的思想优化路径，直到求得全局最短路径。输出最短路径矩阵：完成迭代后，最终的路径长度矩阵即为所有顶点之间的最短路径长度。 四、应用场景： Floyd算法在以下问题中有广泛应用：
网络路由：寻找网络中的最短路径，以实现高效的数据传输。公交网络规划：为了使得公交线路更加合理和高效，需要寻找最短的线路连接。DNA序列比对：在生物学中，根据DNA序列的相似性，可以利用Floyd算法找到最短的序列匹配路径。 五、Floyd算法的优点： 适用性广：Floyd算法适用于不同类型的图，包括有向图、无向图和带负权边的图。迭代原理：通过不断的迭代更新路径长度，可以找到全局最短路径。 六、Floyd算法的局限性： 时间复杂度高：Floyd算法的时间复杂度为O(n^3)，在大型图中时间开销较大。空间复杂度高：Floyd算法需要构建路径长度矩阵，因此在存储上需要较大的空间。 结语： Floyd算法是一种强大的寻找全局最短路径的算法，通过动态规划的思想，可以解决各种类型的图论问题。它不仅适用范围广泛，而且相较于其他算法，具有一定的优势。当面临需要解决最短路径问题时，Floyd算法是一个不可忽略的解决方案，能够帮助我们高效地寻找最优解。最重要的是，通过理论的学习和实践的应用，我们可以更好地理解和掌握Floyd算法的优缺点，为问题的解决提供
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d25ac0714646b97a5f9453641e81f6a6/" rel="bookmark">
			Linux配置静态IP-包教包会（纯干货）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如有错误，敬请谅解！
此文章仅为本人学习笔记，仅供参考，如有冒犯，请联系作者删除！！
方法一：图形化操作 1 选用NAT模式 打开虚拟机软件VM主页，如图，点击编辑虚拟机设置,在弹出的对话框内，选择网络适配器，选择NAT模式，点击确定保存即可；
2 查看子网，网关，子网掩码等操作 点击VM主页菜单栏的编辑,点击虚拟网络编辑器，稍等片刻跳出虚拟网络编辑器界面,里面选择NAT模式，该页面下面便可以查看子网、子网掩码；点击页面上的NAT设置，跳转NAT设置页面，在新页面里面，就可以查看到网关、子网、子网掩码；
方法二：命令行模式（推荐） 1.固定IP、打开网络连接 打开安装好的虚拟机，开机，打开终端，在终端输入ifconfig，查看到你的网卡名称；我的是ens33；
2. 查看网卡 所有要的信息都得到了后，所以我们直接在centos的终端命令行编辑网卡配置，指令如下：
[root@node1 ~] vi /etc/sysconfig/network-scripts/ifcfg-ens33 我们能看到: TYPE=Ethernet PROXY_METHOD=none BROWSER_ONLY=no BOOTPROTO=dhcp DEFROUTE=yes IPV4_FAILURE_FATAL=no IPV6INIT=yes IPV6_AUTOCONF=yes IPV6_DEFROUTE=yes IPV6_FAILURE_FATAL=no IPV6_ADDR_GEN_MODE=stable-privacy NAME=ens33 UUID=638db334-1b8c-4ed6-afb7-23a44a8713b1 DEVICE=ens33 ONBOOT=no 3. 修改其中的文件内容： 将ONBOOT=no 改为 ONBOOT=yes 将BOOTPROTO=dhcp 改为 BOOTPROTO=static 并增加如下几行字符 IPADDR=192.168.144.137 NETMASK=255.255.255.0 GATEWAY=192.168.144.2 DNS1=119.29.29.29 或者DNS1=192.168.144.2 ZONE=public 域 ONBOOT设置为yes，表示网卡随着系统一同启动BOOTPROTO用来设置网卡的启动类型，dhcp表示自动获取IP地址，static表示手动设置静态IP地址，一定要改成static，不然每次重启网卡都会重新分配一个ip，而且动态IP优先级高于你后面设置的IPADDR=192.168.144.137IPADDR指定IP地址（取决于前面已自动获取到的地址）NETMASK指定子网掩码GATEWAY指定网关DNS1指定上网用的DNS IP地址119.29.29.29是国内DNSpod公司提供的一个公共，192.168.144.2是本机的DNS，二者都可以。DNS1=119.29.29.29 可选，可写可不写ZONE=public 可选，可写可不写 4. 编辑完后，保存并退出 5. 重启网络服务 systemctl restart network.service 在利用ip addr查看一下ip地址，发现就是我们固定配置的IP，不会随着网络服务重启而变更，说明成功了。
[root@node7 ~]# systemctl restart network.service [root@node7 ~]# ip a 1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group defaul t qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d25ac0714646b97a5f9453641e81f6a6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07f899e3ed114c664027eddf9d9fd459/" rel="bookmark">
			交叉编译设置环境变量——在系统启动时设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、前言 关于交叉编译环境搭建过程可以参考文章：【ARM嵌入式Linux】正点原子I.MX6U-ALPHA的QT交叉编译环境搭建_乘风破浪HH的博客-CSDN博客
文章中，需要使用命令使能系统变量（编译器路径根据实际路径做调整）：source /opt/fsl-imx-x11/4.1.15-2.1.0/environment-setup-cortexa7hf-neon-poky-linux-gnueabi
但是这有个缺点，每次系统重启都需要执行一次上面的命令，比较繁琐，这里介绍如何将该命令在系统启动时自动设置。
2、具体方案 （1）执行命令：sudo vi /etc/profile 打开系统变量配置文件（如果需要输入密码，就先输入），如图所示。在profile文件内容的最后一行加入使能系统变量命令：source /opt/fsl-imx-x11/4.1.15-2.1.0/environment-setup-cortexa7hf-neon-poky-linux-gnueabi（编译器路径根据实际路径做调整），最后，vi切换成命令模式输入：wq保存退出。
（2）执行命令：source /etc/profile重新使能profile文件或者重启系统使得配置生效。
其中，执行source /etc/profile可能会出现命令行颜色改变，可以执行命令：source ~/.bashrc调整一下即可，如图所示。
3、结果 只需执行完一次上述操作之后，后续就不需要每次重启系统执行使能命令了，一劳永逸~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ef58ba076994f6209d812e575bd592c/" rel="bookmark">
			基于NVIDIA Jetson AGX Xavier的移动机器人开发（4）——虚拟环境配置、pytorch安装、yolov5实时推理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【摘要】本篇主要介绍在ARM架构下虚拟环境的配置，以及在虚拟环境中安装pytorch，最终部署yolov5进行实时推理，深度学习相关环境的配置涉及大量坑，只能遇坑填坑，可能还存在大量未知的BUG，不能囊括所有问题。
【本机配置】
JetPack 4.6CUDA 10.2
一、虚拟环境配置 Xavier采用的是ARM架构，无法下载安装 annoconda ，因此需要安装 miniforge 作为 annoconda 的替代品，选择aarch64的linux版本（下载地址）
使用sh Miniforge-xxx-Linux-aarch64.sh进行安装miniforge 使用指令和anconda完全一样
使用conda create -n yolov5 python=3.6 -y指令创建yolov5环境
使用conda activate yolov5激活在创建环境时可能会出现报错
Solving environment: failed with repodata from current_repodata.json, will retry with next repodata source.
大概率是源的问题，可以换源尝试解决，可以多试试各种源，比如：
conda config --prepend channels https://mirrors.ustc.edu.cn/anaconda/pkgs/main/ 二、torch和torchvision安装 首先老生常谈的问题，注意CUDA版本，安装对应版本的torch和torchvision，否则后续bug无穷。本机CUDA版本为10.2，因此安装1.7.0的torch与0.8.1的torchvision使用源码安装 torch ，根据对应的JetPack选择对应版本的torch，本机选择torch1.7（eLinux官网）
执行pip install torch-1.7.0-cp36-cp36m-linux_aarch64.whl安装 torch命令行执行 python import torch验证 torch是否安装成功，然后执行torch.cuda.is_available()函数检查是否为GPU版本在安装torch时可能会出现两个问题：
1）报错from torch._C import *ImportError: libopenblas.so.0: cannot open shared obj，解决方案是安装 libopenblas-dev ，直接使用apt-get安装可能会出现无法定位包的问题，可以通过先安装相关其他包解决，详情见（链接）；
2） 在导入 torch 时报错“非法指令 (核心已转储)”，是 numpy 版本的问题，可以通过降低numpy版本解决使用源码安装 torchvision ，注意版本git clone -b v0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6ef58ba076994f6209d812e575bd592c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9beaff0572a221805b470ebd224f3a7/" rel="bookmark">
			Vue搜索组件，显示热门、近期搜索（结合element ui）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🚀 注重版权，转载请注明原作者和原文链接
🥭 作者：全栈小袁
🍎 原创个人开源博客项目(目前V3.0版本)：https://github.com/yuanprogrammer/xiaoyuanboke
🍉 开源项目觉得还行的话点点star，有什么需要完善或者点子欢迎提issue 小袁有话说 也是好久没有发文章了，之前忙着秋招校招春招，入职后一边忙着工作一边忙着毕业设计，所以CSDN活跃的比较少了
这次呢，打算整理自己今年所学到的以及自己的一些demo，然后一篇一篇发出来和大家分享
今天要分享的是一个Vue的搜索框组件，近期又做了一个新的开源项目（后续会发布），热门搜索框组件是项目的其中一个小组件，分享给大家，先展示下最终的效果图
搜索框说明 本次实现的这个搜索框，是结合了element ui的两个组件
Input 输入框Popover 弹出框 这个是重点，自定义搜索弹框 该组件单独分离封装，直接引入组件就能使用，不需要适配当前页面
因为也是前端的一些比较简单的操作，代码也没什么好教程说明的，直接贴上完整的代码吧。
唯一要说明的地方应该是searchRequest 方法，用于搜索跳转，video/search 路径换成自己项目的搜索结果也就可以了，我这里的历史搜索以及热门搜索都是写死的，你们可以自己换成自己项目的API接口请求
完整代码 创建 SearchInput.vue 文件
&lt;template&gt; &lt;div class="search-item"&gt; &lt;el-popover placement="bottom" width="475" ref="popover" trigger="focus" :visible-arrow="false" style="padding-top: 0" v-model="visible"&gt; &lt;div class="search-content"&gt; &lt;div class="search-his" v-show="historySearch.length &gt; 0"&gt; &lt;div&gt; &lt;span class="title"&gt;搜索历史&lt;/span&gt; &lt;span class="clear" @click="clearHistory"&gt;&lt;i class="el-icon-circle-close"&gt;&lt;/i&gt;清空&lt;/span&gt; &lt;/div&gt; &lt;el-tag v-for="tag in historySearch" :key="tag.name" size="small" closable style="margin-right: 10px; margin-top: 10px; cursor: pointer" @click="handleSearch(tag.name)" :type="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a9beaff0572a221805b470ebd224f3a7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f38ee2ebd7902854783afa7474fa19c5/" rel="bookmark">
			Linux系统管理-MySQL记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux系统管理-MySQL记录 提示：该章节建立在搭建好phpMyAdmin数据库管理套件 并创建了库mydb，表info和Nation上 文章目录 Linux系统管理-MySQL记录前言本章节学习内容 一、本章结构二、安装notepad++及使用步骤1.执行安装程序npp.7.5.9.Installer.x64.exe2.打开notepad++选择程序编码utf83.选择编程语言为php4.编写后运行预览(==若是php，最好是挂到服务器网站根目录测试==)php访问数据库命令11. 建立连接（==PHP5.4以下==）2.打开数据库3.设定操作结果显示字符集(==没这句后果是汉字显示不了==）4.设计操作命令，并将它赋给变量，方便使用。5.执行操作并将结果返回到变量(==是一个集合==）中6.逐个读取变量中记录的各字段值，并在网页中显示结果（==因记录较多，要做个循环==）7.关闭连接8.将上述1-7命令集中起来，加上显示网页标题代码和PHP标识，就构成一个完整的PHP程序。（==假定名为my1.php==)请在notepad++中编辑上述程序内容，然后复制到vi编辑中，存于CentOS中nginx根目录，最后在物理机浏览器中打开它。 php访问数据库命令21. 建立连接（PHP5.5以上方可使用）2.打开数据库?（不用，已包括在连接库命令中）3.设定操作结果显示字符集(没这句后果是汉字显示乱码）4.设计操作命令，并将它赋给变量，方便使用。5.执行操作并将结果返回到变量（是一个集合）中6.逐个读取变量中记录的各字段值，并在网页中显示结果（因记录较多，要做个循环,注意读取函数不是以前的了）7.停止查询操作8.将上述1-7命令集中起来，加上显示网页标题代码和PHP标识，就构成一个完整的PHP程序。（==假定名为my2.php==)请在notepad++中编辑上述程序内容，然后复制到vi编辑中，存于CentOS中nginx根目录，最后在物理机浏览器中打开它。 数据记录维护html网页特效一、表格(table)二、区块(div)三、超链接四、表单(form)1、文本输入框2、单选框3、下拉选择菜单4、提交按钮5、接收表单提交的数据的程序名6、接收程序所用的参数（==在接收程序AddChuLi.php中==）7、返回主程序（==在接收程序AddChuLi.php中==） 最终效果如图：主程序main.php代码如下：删除记录程序DeleteChuLi.php添加程序Add.php添加处理程序AddChuLi.php更新程序Update.php更新处理程序UpdateChuLi.php 总结 前言 提示：学会在LNMP平台中编写自己的表记录管理平台。 熟悉编程软件notepad++使用 本章节学习内容 phpMyAdmin要求工作环境是什么？
如何在上述环境中建立和维护库、表？
如何完成对所有库的备份？如何进行恢复？
一、本章结构 二、安装notepad++及使用步骤 1.执行安装程序npp.7.5.9.Installer.x64.exe 将在桌面生成如下快捷方式：
勾选在桌面建立快捷方式并安装
快捷方式如图：
2.打开notepad++选择程序编码utf8 3.选择编程语言为php 4.编写后运行预览(若是php，最好是挂到服务器网站根目录测试) php访问数据库命令1 1. 建立连接（PHP5.4以下） $db=mysql_connect('localhost','root','123456') or die("error connecting") ; 2.打开数据库 mysql_select_db(mydb); 3.设定操作结果显示字符集(没这句后果是汉字显示不了） mysql_query("set names 'utf8'"); 4.设计操作命令，并将它赋给变量，方便使用。 $sql ="select * from Info"; 5.执行操作并将结果返回到变量(是一个集合）中 $r = mysql_query($sql,$db); 6.逐个读取变量中记录的各字段值，并在网页中显示结果（因记录较多，要做个循环） while($att = mysql_fetch_array($r)) { echo "{$att['Code']} {$att['Name']}&lt;br&gt;"; } 7.关闭连接 mysql_close($db); 8.将上述1-7命令集中起来，加上显示网页标题代码和PHP标识，就构成一个完整的PHP程序。（假定名为my1.php) &lt;h1&gt;XXX(自己名字)首个PHP程序&lt;br&gt;&lt;/h1&gt; &lt;?php … ?&gt; 集合代码如图
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f38ee2ebd7902854783afa7474fa19c5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41b3843da8f6c1d789e89c38c03b5630/" rel="bookmark">
			开源工具PDManer，各种版本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		链接: https://pan.baidu.com/s/1fJeYjxbfQYHpAVQHJzbTJA?pwd=nypr 提取码: nypr --来自百度网盘超级会员v5的分享
mac m1安装出现包损坏：
1、终端窗口输入， sudo xattr -r -d com.apple.quarantine /Applications/PDManer.app
然后回车
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d03bdf728e60ff96eb5dc30985da951/" rel="bookmark">
			..\Output\xx.axf: error: L6002U: Could not open file ..\output\xx.o: No such file or directory 解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		…\Output\xx.axf: error: L6002U: Could not open file …\output\main.o: No such file or directory 解决方法 平台：Keil v5.34 MCU：GD32F103CBT6
问题描述 编译过程出现报错：…\Output\xx.axf: error: L6002U: Could not open file …\output\main.o: No such file or directory
原因分析： 1.说的最多的就是你的工程存在中文路径，这也是百度出来最多的答案，解决方式就是修改路径然后重新编译即可
2.还有一种就是…\output\main.o这里，xx.o这个文件里可能有包含其他错误信息，比如调用的其他文件定义的宏，与其名称不一致
解决方案： 参考上述原因分析
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f9556d3e389b4dcfab09d86f0330e60/" rel="bookmark">
			C51：串口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
串口基本认知
关于电器标准和协议
RS-232
RS-422
RS-485
关于串口的电平
RS232电平
TTL电平
串口通信
串口接线方式
串口编程要素
印象塑造
发送：
串口发送字符串
使用中断请求标志位
接收：
串口点灯
收发并行：中断
接收字符串
避坑：ASSII
原理：字符'a' 是如何从单片机上传到PC的
串口基本认知 串行接口简称串口，也称串行通信接口或串行通讯接口（通常指COM接口），是采用串行通信方
式的扩展接口。串行接口（Serial Interface）是指数据一位一位地顺序传送。其特点是通信线路简
单，只要一对传输线就可以实现双向通信（可以直接利用电话线作为传输线），从而大大降低了成
本，特别适用于远距离通信，但传送速度较慢
是设备间接线通信的一种方式
数据一位一位地顺序传送
双向通信，全双工
传送速度相对较慢
关于电器标准和协议 串行接口按电气标准及协议来分包括RS-232-C、RS-422、RS485等。RS-232-C、RS-422与RS-485
标准只对接口的电气特性做出规定，不涉及接插件、电缆或协议。
RS-232 也称标准串口，最常用的一种[串行通讯接口,比如我们的电脑主机的9针串口 ，最高速率为20kb/s
RS-232是为点对点（即只用一对收、发设备）通讯而设计的，其传送距离最大为约15米。所以RS-232适
合本地设备之间的通信
RS-422 由于接收器采用高输入阻抗和发送驱动器比RS232更强的驱动能力，故允许在相同传输线上连接多个接
收节点，最多可接10个节点。即一个主设备（Master），其余为从设备（Slave），从设备之间不能通
信，所以RS-422支持点对多的双向通信。
RS-422的最大传输距离为1219米，最大传输速率为10Mb/s。平衡双绞线的长度与传输速率成反比
RS-485 是从RS-422基础上发展而来的，无论四线还是二线连接方式总线上可多接到32个设备。
关于串口的电平 经常听说的UART
异步串行是指UART（Universal Asynchronous Receiver/Transmitter），通用异步接收/发送。
UART包含TTL电平的串口和RS232电平的串口
RS232电平 逻辑1为-3~-15V的电压, 逻辑0为3~15V的电压
笔记本通过RS232电平和单片机通信
TTL电平 TTL是Transistor-Transistor Logic，即晶体管-晶体管逻辑的简称，它是计算机处理器控制的设备
内部各部分之间通信的标准技术。TTL电平信号应用广泛，是因为其数据表示采用二进制规定，
+5V等价于逻辑”1”，0V等价于逻辑”0”。
数字电路中，由TTL电子元器件组成电路的电平是个电压范围，规定：
输出高电平&gt;=2.4V，输出低电平&lt;=0.4V；
输入高电平&gt;=2.0V，输入低电平&lt;=0.8V
笔记本电脑通过TTL电平与单片机通信
TX发送线（端口）3.1
RX接收线 (端口）3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9f9556d3e389b4dcfab09d86f0330e60/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c7c253551b2378fe4a63b63bec45cd7/" rel="bookmark">
			共阳数码管静态显示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		/*-----------------------------------------------
内容：通过赋值给P1，让数码管显示特定的字符或者数字
------------------------------------------------*/
#include&lt;reg52.h&gt; //包含头文件，一般情况不需要改动，
//头文件包含特殊功能寄存器的定义
void main (void)
{
P1=0xc0; //二进制 为 1100 0000 参考数码管排列，
//可以得出0对应的段点亮，1对应的段熄灭，结果显示数字"0" while(1)
{
}
}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fba2eedb2ef71d18b935b367cfee07cb/" rel="bookmark">
			【Linux专题_05】Linux统计行数命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Linux统计行数几种常用命令
wc -l：这是最常用的命令，用于统计文件中的行数。它会输出文件的行数以及文件名。 示例：wc -l filename.txt nl：该命令会给文件中的每一行添加行号，并将结果输出到标准输出。通过查看行号的最后一个值，可以得到行数统计。 示例：nl filename.txt | tail -n 1 grep -c：grep命令用于在文件中搜索指定的模式，并输出匹配的行。通过使用-c选项，可以统计匹配的行数。 示例：grep -c "" filename.txt，如果需要统计的话可以输入一些匹配一些不存在的字符，自然就可以准确统计 sed -n '$='：sed命令用于对文件进行文本处理，通过结合-n选项和$=命令，可以统计文件的行数。 示例：sed -n '$=' filename.txt awk 'END {print NR}'：awk是一种用于处理文本的强大工具，通过使用NR变量，可以统计行数。 示例：awk 'END {print NR}' filename.txt 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f2dac66c3cbd0e3cbc00eaac98ab4c9/" rel="bookmark">
			【开发工具专题_02】windows操作系统下载与安装mysql8.0.18教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、进入mysql网站：https://dev.mysql.com/downloads/mysql/
二、将页面拉到最下面选择选择操作系统后，选择要下载的版本点击 Downloads
注：我选择下载的版本是8.0.18的，如果不想要最新的版本也可以选择上面的比较老一点的版本 三、配置环境变量
因为下载的mysql数据库包的格式是zip的，下载完成后直接解压就可以用，但解压后需要进行配置。
首先进行环境变量的配置：右击计算机-&gt;属性-&gt;高级系统设置-&gt;环境变量，选择双击Path，在最后面添加你的mysql bin文件夹的路径
我的目录是：E:\mysql-8.0.18-winx64\bin
四、 E:\mysql-8.0.18-winx64 目录下新建一个my.ini的文件
【注意： my.ini文件中的内容：（注：可以直接复制下面的，涉 及到存放目录的可以根据自己实际情况做更改）】
[mysqld] # 设置3306端口 port=3306 # 设置mysql的安装目录 basedir=E:\\mysql-8.0.18-winx64 # 切记此处一定要用双斜杠\\，单斜杠这里会出错。 # 设置mysql数据库的数据的存放目录 datadir=E:\\mysql-8.0.18-winx64\\Data # 此处同上 # 允许最大连接数 max_connections=200 # 允许连接失败的次数。这是为了防止有人从该主机试图攻击数据库系统 max_connect_errors=10 # 服务端使用的字符集默认为UTF8 character-set-server=utf8 # 创建新表时将使用的默认存储引擎 default-storage-engine=INNODB # 默认使用“mysql_native_password”插件认证 default_authentication_plugin=mysql_native_password [mysql] # 设置mysql客户端默认字符集 default-character-set=utf8 [client] # 设置mysql客户端连接服务端时默认使用的端口 port=3306 default-character-set=utf8 到这里，数据库就配置完成了。接下来就可以启动数据库的服务了
五、启动服务
1、进入mysql的bin目录下 2、然后输入mysqld --initialize --console，等待一会出现几行代码，root@localhost：后面的是随机生成的数据库初始密码，将初始密码记下来后面会用到。 【注：没记住初始密码的话，删掉初始化的 data目录，再执行一遍初始化命令又会重新生成。】 3、初始化完毕后，执行mysqld --install
4、 执行命令net start mysql，启动服务
六、初始密码构成太过于复杂，修改为一个自己简单易记的密码。
第一种方法：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5f2dac66c3cbd0e3cbc00eaac98ab4c9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cefa0f0defb240b10dec9e6ffe5e5465/" rel="bookmark">
			【docker专题_07】vim: command not found解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 前言 今天在公司使用docker部署redis集群的时候，遇到问题，就是有些配置文件需要进行编辑，虽然可以在容器外部拷贝进去，但有时候只是一点点修改，需要在里面修改配置文件，出现vim: command not found，记录下解决方案
1.更新安装源 apt-get update 2.安装vim apt-get install vim 3.注意事项 #若是不先进行更新，会出现以下问题 Reading package lists... Done Building dependency tree Reading state information... Done E: Unable to locate package vim 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e29063f9c33b44cb3bfc90de620e6f6a/" rel="bookmark">
			【Java专题_01】springboot&#43;Shiro&#43;Jwt整合方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SpringBoot+Shiro+Jwt整合 前言 Apache Shiro ：是一个强大且易用的Java安全框架，执行身份认证，授权，密码和会话管理，核心组件：Subject，SecurityManager和Realms；
JWT：JSON Web Token是一种流行的跨域身份验证解决方案，主要是用于客户端与用户端之间信息的传递；
SpringBoot：目前Java主流的一个开发框架，不仅集成Spring框架原有的优秀特性，而且通过简化配置来进一步简化Spring应用的整个搭建和开发过程。
项目下载链接 https://download.csdn.net/download/weixin_40736233/16334422
目录结构 1.pom.xml依赖 &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.3.5.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;/parent&gt; &lt;properties&gt; &lt;!--java_JDK版本--&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;!--maven打包插件--&gt; &lt;maven.plugin.version&gt;3.8.1&lt;/maven.plugin.version&gt; &lt;!--编译编码UTF-8--&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;!--输出报告编码UTF-8--&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;!--shiro版本--&gt; &lt;shiro.version&gt;1.6.0&lt;/shiro.version&gt; &lt;!--jwt版本--&gt; &lt;java-jwt.version&gt;3.11.0&lt;/java-jwt.version&gt; &lt;!--shiro-redis版本--&gt; &lt;shiro-redis.version&gt;3.1.0&lt;/shiro-redis.version&gt; &lt;!--json数据格式处理工具--&gt; &lt;fastjson.version&gt;1.2.75&lt;/fastjson.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!--集成springmvc框架并实现自动配置 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Lombok --&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- json --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.75&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Redis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--JWT--&gt; &lt;dependency&gt; &lt;groupId&gt;com.auth0&lt;/groupId&gt; &lt;artifactId&gt;java-jwt&lt;/artifactId&gt; &lt;version&gt;${java-jwt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e29063f9c33b44cb3bfc90de620e6f6a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c3724f38fba61adc3be30bc8c289877/" rel="bookmark">
			snprintf用法及自己使用过后的小总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		snprintf()可以认为是sprintf()的升级版，但比sprintf()多了一个参数，能够控制要写入的字符串的长度，更加安全，只要稍加留意，不会造成缓冲区的溢出，所以一般我们使用snprintf更多。
一. snprintf函数功能及参数介绍
#include &lt;stdio.h&gt;
int snprintf(char *str, size_t size, char * format [, argument, …]);
功能：将可变参数 “…” 按照format的格式格式化为字符串，然后再将其拷贝至str中。
参数：
str: 最终格式化字符串所存储的buffsize: buff缓存区的长度，这里包括字符串结尾符‘\0’（注意：‘\0’是自动添加的，不管后面的自字符串是否包含’\0’），即可以输出到str的有效字符的大小为：size - 1format: 可变参数，类似于printf中的”%d”格式 返回值：当调用失败时返回值为负数，当调用成功时返回值为格式化后的字符串的总长度（不包括\0），这个字符串有可能被截断（因为有可能buf长度不够放下整个字符串）。
看了这个可能也不清楚到底怎么用，没关系，看下边的例子就明白了：
#include &lt;stdio.h&gt; int main() { int a = 1; char buf[32] = "Nike"; char buf1[32] = {0}; snprintf(buf1, sizeof(buf1)-1, "hello, I am %s. [%d]", buf, a); printf("%s\n", buf1); return 0; } 运行结果：
二. 一些注意点
1. 如果格式化后的字符串长度 &lt; size，则将此字符串全部复制到str中，并给其后添加一个字符串结束符('\0')；
2. 如果格式化后的字符串长度 &gt;= size，则只将其中的(size-1)个字符复制到str中，并给其后添加一个字符串结束符('\0')，返回值为欲写入的字符串长度。（因为snprintf在末尾会自动加个'\0'，得留一个位置给它）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6c3724f38fba61adc3be30bc8c289877/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d4b9a55e4a1ea6b0a440cde6ecdcad4/" rel="bookmark">
			【python桌面应用设计】tkinter库 01. Tkinter程序设计思想和结构（保姆级代码注释）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 实现思路代码实战简单的基础结构示例稍微丰富一点的示例 总结 『python图形化GUI界面设计』分享tkinter库、PyQt5库、wxPython库等相关的新手入门教程，目标是编写python程序时可以给程序一个可视化界面。 欢迎关注 『python桌面应用设计』 系列，持续更新中
欢迎关注 『python桌面应用设计』 系列，持续更新中
实现思路 Tkinter 程序包括以下三个部分，其中只有第二部分是需要我们自己写的，其他两部分是固定的写法
创建主窗口画布，也称 root 窗口（即根窗口）人机交互控件设置，同时编写相应的事件函数通过主循环（mainloop）来显示主窗口 代码实战 简单的基础结构示例 import tkinter as tk root_window =tk.Tk()#1.创建主窗口画布 root_window.title('CSDN——发现你走远了')# 2.人机交互控件设置，设置主窗口的标题名字，后面陆续讲解按钮、标签等等控件 root_window.mainloop()#3.通过主循环（mainloop）显示主窗口，可以先简单理解为 MATLAB库里面的show() 就只有一个主窗口
稍微丰富一点的示例 import tkinter as tk #1.创建主窗口画布 root_window =tk.Tk() #2.人机交互控件设置，窗口大小，放入文本内容。后面陆续讲解按钮、标签等等控件 root_window.geometry('450x300')# 设置窗口大小:宽x高,小细节——这里是长宽之间的连接词是使用 "x"，不能为 "*"。 # 添加文本内,设置字体的前景色和背景色，和字体类型、大小 text=tk.Label(root_window,text="发现你走远了，欢迎道友",bg="red",fg="yellow",font=('Times', 20, 'bold italic')) text.pack()# 将文本内容放置在主窗口内 root_window.title('CSDN——发现你走远了')# 设置主窗口的标题名字 #3.通过主循环（mainloop）显示主窗口，可以先简单理解为 MATLAB库里面的show() root_window.mainloop() 修改了窗口大小和标题，加入了一个text对象
总结 大家喜欢的话，给个👍，点个关注！给大家分享更多有趣好玩的python桌面应用设计知识！
版权声明：
发现你走远了@mzh原创作品，转载必须标注原文链接
Copyright 2022 mzh
Crated：2022-8-1
欢迎关注 『python桌面应用设计』 系列，持续更新中
欢迎关注 『python桌面应用设计』 系列，持续更新中
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4d4b9a55e4a1ea6b0a440cde6ecdcad4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/952e97ee554be133fe016637fcb934b3/" rel="bookmark">
			yolo格式visdrone转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 yolo格式转换1. Visdrone2019格式转换 yolo格式转换 1. Visdrone2019格式转换 数据集下载地址https://aistudio.baidu.com/aistudio/datasetdetail/115729
如果是visdrone数据集，直接使用txt2xml.py去转换，修改annotation和img的路径，运行即可，运行后会在新建的xml文件夹下生成6471个xml文件，我们把xml文件转换为json,json再转成yolo
""" 该脚本用于visdrone数据处理； 将annatations文件夹中的txt标签文件转换为XML文件； txt标签内容为： &lt;bbox_left&gt;,&lt;bbox_top&gt;,&lt;bbox_width&gt;,&lt;bbox_height&gt;,&lt;score&gt;,&lt;object_category&gt;,&lt;truncation&gt;,&lt;occlusion&gt; 类别： ignored regions(0), pedestrian(1), people(2), bicycle(3), car(4), van(5), truck(6), tricycle(7), awning-tricycle(8), bus(9), motor(10), others(11) """ #visdrone转为yolo格式 import os import cv2 import time from xml.dom import minidom name_dict = {'0': 'ignored regions', '1': 'pedestrian', '2': 'people', '3': 'bicycle', '4': 'car', '5': 'van', '6': 'truck', '7': 'tricycle', '8': 'awning-tricycle', '9': 'bus', '10': 'motor', '11': 'others'} def transfer_to_xml(pic, txt, file_name): xml_save_path = 'xml' # 生成的xml文件存储的文件夹 if not os.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/952e97ee554be133fe016637fcb934b3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89e847b222466073b87108c6f719e4f1/" rel="bookmark">
			3.SpringCloud：Nacos配置中心
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Nacos既提供注册中心，也提供配置中心。下面分别以两个例子来说明配置中心的使用。
目录
案例一：配置中心使用
人工在Nacos配置内容
客户端使用
案例二：配置拆分与复用
背景
配置拆分复用说明
对pom.xml增加依赖
删除application.properties，增加bootstrap.properties
启动
调用验证
附1：Nacos config客户端临时暂存目录
附2：Nacos config隔离层次概念
附3：显示写入Nacos config配置中心及监听代码示例
案例一：配置中心使用 人工在Nacos配置内容 在Nacos中人工定义如下
Data ID: firstapp-dev.properties Group : DEFAULT_GROUP 配置格式: Properties 配置内容： weather=sun temperature=20.55 其中Data ID的命令规则为：应用名-环境profile名.文件后缀
应用名（Data ID前缀）：默认为 ${spring.appliction.name}， 也可以使用${spring.cloud.nacos.config.prefix}来配置环境profile名：既${spring.profiles.active}指定的环境。 若不区分环境，则本内容既前面的中划线都可以不用存在。文件后缀：既SpringBoot中配置文件扩展名，也是Nacos中的配置格式。 客户端使用 新建一个project或者module。 在生成的默认pom.xml增加nacos-config和bootstrap依赖。如下
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.7.10&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;firstapp&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;firstapp&lt;/name&gt; &lt;description&gt;firstapp&lt;/description&gt; &lt;properties&gt; &lt;java.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/89e847b222466073b87108c6f719e4f1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06f116a051ef2090fbad067a4f5a8201/" rel="bookmark">
			SPDK 常见协议简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		iSCSI iSCSI（Internet Small Computer System Interface）是一种用于在IP网络上传输SCSI命令和数据的网络存储协议。它将SCSI（Small Computer System Interface）协议封装在TCP/IP协议中，使得计算机系统可以通过标准的IP网络连接到远程存储设备。
iSCSI协议允许将存储设备（如磁盘阵列、存储服务器）映射到计算机系统，使其可以像本地存储设备一样访问和使用。通过iSCSI，远程存储设备被视为本地SCSI设备，可以通过标准的SCSI命令进行读取和写入操作。
iSCSI的工作原理是通过将SCSI命令和数据封装在TCP/IP协议中进行传输。计算机系统上的iSCSI Initiator（发起者）软件将SCSI命令发送到存储设备的iSCSI Target（目标）上，然后通过网络进行传输。存储设备接收并处理这些命令，并将数据返回给计算机系统。
iSCSI具有以下优点：
灵活性：iSCSI可以通过标准的IP网络连接到远程存储设备，消除了对专用存储网络的需求，提供更大的灵活性和可扩展性。
跨平台支持：iSCSI是基于标准的TCP/IP协议，可以在不同的操作系统和硬件平台上使用，实现跨平台的存储共享。
远程访问：iSCSI允许计算机系统通过网络访问远程存储设备，方便实现远程备份、灾难恢复和数据共享等需求。
性能：iSCSI可以提供与本地SCSI设备相近的性能水平，通过优化网络和存储设备的配置，可以实现高速数据传输和低延迟。
iSCSI被广泛应用于企业数据中心、虚拟化环境和云计算等场景，为存储管理和数据共享提供了一种高效、灵活和可扩展的解决方案。
SCSI SCSI（Small Computer System Interface）是一种计算机接口标准，用于连接和通信主机系统与外围设备，例如硬盘驱动器、磁带驱动器、光盘驱动器和打印机等。它是一种并行接口，最初设计用于高性能计算系统和服务器。
SCSI接口提供了一种高度可扩展和灵活的方式，使主机系统能够同时连接多个外围设备。每个设备都有唯一的SCSI地址，主机系统可以通过发送SCSI命令和接收数据来与设备进行通信。
SCSI的特点和优势包括：
高性能：SCSI接口支持高速数据传输，可以实现较快的读写操作和数据传输速度。
多设备连接：SCSI允许主机系统同时连接多个设备，通过独立的SCSI地址进行识别和访问。
灵活性和可扩展性：SCSI接口具有高度可扩展性，可以支持不同类型的外围设备，并通过链路或总线连接进行扩展。
高级功能：SCSI支持许多高级功能和命令集，如并行命令传输（Parallel Command Transport，PCT）、SCSI总线命令（SCSI Bus Command）和SCSI控制命令（SCSI Control Command）等。
广泛应用：SCSI接口广泛应用于服务器、工作站、存储设备、备份设备和专业的音视频制作设备等领域。
然而，随着技术的发展，SCSI接口逐渐被更先进的接口标准如SATA和SAS所取代，这些接口提供更高的速度和更简化的连接方式。尽管如此，SCSI仍然在某些领域和特定应用中得到使用和支持。
linux nbd 在 Linux 系统中，NBD（Network Block Device）是一种网络块设备虚拟化技术，它允许将远程计算机上的块设备映射到本地计算机上，使得本地计算机可以像访问本地块设备一样访问和使用远程块设备。
NBD 使用客户端-服务器模型，在远程计算机上运行 NBD 服务器程序，而本地计算机上运行 NBD 客户端程序。NBD 客户端通过网络连接到 NBD 服务器，并发起块设备的请求和操作。
NBD 技术的工作流程如下：
在远程计算机上启动 NBD 服务器，并将要共享的块设备配置为 NBD 服务器的资源。
在本地计算机上启动 NBD 客户端，并指定要连接的 NBD 服务器的地址和端口号。
NBD 客户端与 NBD 服务器建立网络连接。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/06f116a051ef2090fbad067a4f5a8201/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e51d9ae759bae4f73c895ea334ac977/" rel="bookmark">
			【docker专题_03】docker搭建Flink集群
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.拉取镜像 #默认拉取最新版本 docker pull flink #检查镜像 docker images | grep flink 2.编写flink的yaml文件 注意：云服务器需要设置安全策略放行8081端口，否则访问失败
编写yaml配置文件 docker-compose.yaml version: "1.0" services: jobmanager: image: flink expose: - "6123" ports: - "8081:8081" command: jobmanager environment: - JOB_MANAGER_RPC_ADDRESS=jobmanager taskmanager: image: flink expose: - "6121" - "6122" depends_on: - jobmanager command: taskmanager links: - "jobmanager:jobmanager" environment: - JOB_MANAGER_RPC_ADDRESS=jobmanager #注释： The Web Client is on port 8081 JobManager RPC port 6123 TaskManagers RPC port 6122 TaskManagers Data port 6121 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3e51d9ae759bae4f73c895ea334ac977/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf123ec874287c114d6e1ed27794f48e/" rel="bookmark">
			在linux系统中如何设置定时任务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：
在linux日常运维过程中我们常常需要在指定时间段自动停止或启动某个服务我们不可能人为的手动去执行，这时候我们就可以给对应的任务设置一个定时。后面我就可以将周期性的、规则的工作交给定时任务去完成。
**一次性任务：**顾名思义就是该任务只执行一次，一般用于临时性的工作需求。
**长期性计划任务：**就如何定时任务，就跟我们在自动化测试的过程中每天设置定时巡检任务一样。
设置一次性的任务：
我们设置一下固定时间停止mysql服务。
先看下mysql的运行状态。
设置一次性定时任务停止掉mysql服务。
可以看到任务已经停止啦！
如何查看还未执行或者长期性的定时任务：
la -l
假如定时任务设置多了，如何删除多余的定时任务。根据定时任务前面的编号，我们可以看到上面定时任务的编号为2，我们可以根据2删除对应的定时任务。
如何设置长期计划任务：
我们可以使用crond服务去完成这个操作，linux系统中一般默认就存在该服务，我们可以输入 which crontab来验证该服务是否存在。
但是一般默认都没有启动的状态这里我们只需要将这个服务启动即可。
创建、编辑计划任务的命令为”crontab -e“,查看当前计划任务命令为”crontab -l“,删除某条计划任务的命令为”crontab -r“。
在设置定时任务前我们要先了解时间参数设置的格式，”分、时、日、月、星期“，如果有些时间不需要设置则使用 ”*“ 替代。
字段说明分取值为0-59的整数时取值为0-23的任意整数日取值为1-31的任意整数月取值为1-12的任意整数星期取值为0-7的任意整数，其中0、7均为星期日 这里需要说明的是，我们可以用逗号来表明多个时间段，例如 2，3，4 二月三月四月。也可以用-号表示一段时间周期，例如12-15表示12号到15号执行，。以及用除号（/）表示执行任务的间隔时间例如 /2 每两分钟执行一次。
下面我们举个例子写一个如何设置长期的定时任务吧。
现在有个需求，每个月1号15号凌晨5点清除对应目录的所有日志文件。
这里需要特别特别注意的是设置定时任务时所有的命令都要用绝对路径来写，在使用前可以先用whereis来查一下。
最后需要特别注意的是，我们在配置定时任务时也可以像写shell脚本一样加上#注释，方便我们日后可以知道具体是干什么用的，还有就是配置定时任务时分钟不能用代替一定要写上具体的数字，星期和日不能同时使用，这样会冲突的，这个我相信大家都能理解。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42f2b4b5a7869e6500ec5bd83fcceeb6/" rel="bookmark">
			软件安装和快速上手—VSCode安装和python配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		工欲善其事，必先利其器。选择一款好的IDE对于算法调试和仿真起着重要的作用，VSCode是一款免费开源的现代化轻量级代码编辑器，下面简单介绍该IDE的安装和python配置，并运行一个简单的python代码。
1. 在官网下载VScode
（1）打开官网下载链接：Visual Studio Code - Code Editing. Redefined
（2）选择适配的系统（以Windows64位操作系统为例） ，等待下载完成
注：Insiders是预览版,包含即将发布的新功能和改进,但可能存在潜在的稳定性问题;而Stable是正式版,已经通过了严格的测试和验证。对于新手而言，选择更加稳定的版本，可以避免很多无意义的软件问题，快速进入到软件或算法学习。
（3）以管理员身份打开安装包，开始下载
（4）同意协议
（5）选择安装位置（尽量选择空间大的盘）
（6）设置附加任务（此处勾选如图中的两项，其中添加环境变量可方便后续直接使用）
（7）检查信息，开始安装
（8）安装完成
2. 安装中文插件
（1）初次打开VSCode，界面如下
（2）在拓展“extensions”栏中输入“Chinese”，安装中文插件
（3）等待安装完成，并点击“Change Language and Restart"，重启VSCode
(4) 中文界面设置完成
3. 下载python
（1）进入官方网站：Welcome to Python.org
（2）点击“Downloads”，根据系统选择python版本，此处以Windows系统为准
(3) 以管理员身份运行
(4) 设置安装选项，安装位置建议安在系统盘，且下面的两个选项都勾选（将python添加至系统路径中，可以方便VSCode找到python解释器），最后点击“Install Now”
(5) 安装完成
4. 在VSCode中安装python拓展
5. 选择一个位置新建python文件，取名为“hello.py”，并输入以下代码
print('hello world!') 6. 点击“运行python文件”，在终端中查看打印，若打印成功，则VSCode和python环境被成功搭建
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2cc769b9b7a671a725221bc160bbc289/" rel="bookmark">
			如何解决Keil5编译报错axf：error:L6002U:could not open file？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		小白首次编译项目工程时，遇到了 Target 'XXXX' - Device Family 'Cortex-M3', default ARM-Compiler version 'Unspecified: use latest compiler version 5' is not available.这样的问题。提示默认arm编译器版本'未指定，
通过设置解决，方法如下：
1.点击魔棒工具
2.选择Code Generation目录下ARM Compiler的编译版本
这里选择V6.7之后再次编译，出现如下报错：axf: error: L6002U: Could not open file led_0623\main.o: No such file or directory
网上搜索尝试很多方法无果，最后是将ARM Compiler版本换成V5后编译成功
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa77988a1acbf929c5409144a21b78f1/" rel="bookmark">
			Bresenham直线算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.Bresenham直线算法1.1 算法流程1.2 Bresenham算法实现1.3matlab中应用1.4 算法优势1.5 对比以往方法的改进和优化1.6 算法改进和缺陷 2.国内外研究现状3.个人感想及算法改进 1.Bresenham直线算法 Bresenham直线算法是一种用于将两点之间的线段绘制在屏幕上的算法。它的特点是只用基本的加法、减法和比较操作就可以完成，是一种高效的绘线算法。是计算机图形学领域使用最广泛的直线扫描转换算法，其核心思想是由误差项符号决定下一个像素点取右边的一个点还是右上的一个点。
1.1 算法流程 下面是Bresenham直线算法的流程图：
前提条件k∈[0,1]，直线在x方向上每次增量为，在y方向上每次的增量为。通过一个变量d将y方向上的累计增量记录下来，当d大于1时，标记点m进1，并对变量d进行-1操作使得d的范围永远保持在[0,1]之间。并根据d的范围确定最终的y值，当时，则y保持不变；当时，y加1。
上述已经能够完成y值的判定，但是存在两个问题：k可能为浮点数、d每次需要同0.5这一浮点数比较大小。由于计算机计算整数的效率比浮点数速度快，因此要对上式进行优化改进，主要通过两步换元。
1.2 Bresenham算法实现 具体步骤如下：
输入直线起点 ( x 0 , y 0 ) (x_0, y_0) (x0​,y0​) 和终点 ( x 1 , y 1 ) (x_1, y_1) (x1​,y1​)。计算直线斜率 k = y 1 − y 0 x 1 − x 0 k=\frac{y_1-y_0}{x_1-x_0} k=x1​−x0​y1​−y0​​。如果 ∣ k ∣ &lt; 1 |k|&lt;1 ∣k∣&lt;1，则沿 x x x轴递增来计算每个 x x x值的对应 y y y值；否则，沿 y y y轴递增来计算每个 y y y值的对应 x x x值。对于每个计算的 x x x值或 y y y值，将其四舍五入到最近的整数，并将其作为绘制的坐标。 计算绘制点时，通过检查与当前位置最接近的格子中代表直线的中心的位置来完成。具体来说，在每一步迭代中，使用函数 f ( x , y ) f(x,y) f(x,y)来表示距离直线的理论路径最接近的点的距离:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fa77988a1acbf929c5409144a21b78f1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a44c254b22426e924e40bf00b79dcee7/" rel="bookmark">
			【FreeRTOS】FreeRTOS学习笔记 ---- 堆和栈，第1个FreeRTOS程序，创建任务函数及任务管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🍀作者：阿润菜菜
目录 一、通过故事介绍FreeRTOS1.什么是FreeRTOS？2.FreeRTOS能做什么？ 二、如何使用FreeRTOS？ --- 第1个FreeRTOS程序三、FreeRTOS的堆和栈1.堆和栈的概念2.堆和栈的分配方式3.堆和栈的溢出检测 四、创建任务函数及任务管理 一、通过故事介绍FreeRTOS 假如你是一位母亲是不是会经常遇到这样的情况：你要一边给小孩喂饭，一边加班跟同事微信交流，但是你无法一心多用，只能不停地切换注意力，导致效率低下，还容易出错？
如果你是一个软件开发者，你可能会想：有没有什么办法可以让我像电脑一样，可以同时运行多个任务，而不影响彼此的执行呢？
答案是：有！那就是使用操作系统（OS）。
操作系统是一种软件，它可以管理和调度多个程序或者任务（task）的运行，让它们看起来像是同时执行一样。操作系统可以根据任务的优先级、时间片、事件等因素来决定哪个任务应该先运行，哪个任务应该后运行，或者哪个任务应该暂停或者继续运行。
操作系统有很多种类，例如我们常用的Windows、Linux、Mac OS等，它们被称为通用操作系统（general-purpose OS），因为它们可以运行在各种类型的计算机上，并且支持各种类型的应用程序。
但是在一些专用的电子设备中，例如电梯、汽车、飞机、医疗仪器等，通用操作系统就不太适合了。因为这些设备通常使用的是微控制器（microcontroller）或者小型微处理器（microprocessor），它们的内存和处理能力都很有限。而且这些设备对于实时性（real-time）有很高的要求，也就是说它们必须在规定的时间内完成指定的任务，否则就会造成严重的后果。
例如，在电梯系统中，你按住开门键时如果没有即刻反应，即使只是慢个1秒，也会夹住人。
为了满足这些设备的需求，就出现了一种特殊的操作系统：实时操作系统（real-time operating system，RTOS）。RTOS是一种为实时应用设计的操作系统，它可以在有限的资源下保证任务的及时响应和正确执行。
今天我们要介绍的就是一种开源的、免费的、广泛使用的RTOS：FreeRTOS。
1.什么是FreeRTOS？ FreeRTOS是一个实时操作系统内核（kernel），它可以在多种微控制器和处理器上运行，提供了丰富的任务调度、同步、通信、内存管理等功能。FreeRTOS是开源的，可以免费使用，也可以根据需要进行修改和定制。
那FreeRTOS和Linux的区别是什么？
1.FreeRTOS中没有进程和线程的区分：
FreeRTOS中的任务（Task）和线程（Thread）是相同的概念，每个任务就是一个线程，有着自己的一个程序函数。FreeRTOS可以创建、删除、挂起、恢复、优先级设置等多个任务，任务之间可以通过任务调度器根据优先级进行切换。
2.FreeRTOS和Linux都是操作系统，但是有很多区别，主要有以下几点：
FreeRTOS是一个实时操作系统（RTOS），它要求快速地处理任务，保证实时性和可靠性。Linux是一个通用操作系统（GPOS），它要求提供丰富的功能和服务，保证用户体验和兼容性。FreeRTOS是一个迷你的操作系统内核，只包含了基本的功能，如任务管理、时间管理、信号量、消息队列、内存管理等。Linux是一个完整的操作系统，包含了内核和用户空间，有很多组件和模块，如文件系统、网络协议栈、设备驱动、图形界面、shell等。FreeRTOS可以在资源有限的微控制器中运行，占用的内存和存储空间很小。Linux需要较多的资源，一般运行在处理器性能较强的平台上。FreeRTOS主要用于嵌入式领域，如工业控制、物联网、智能家居等。Linux主要用于桌面、服务器、移动设备等领域。 2.FreeRTOS能做什么？ FreeRTOS可以让你在微控制器或者小型微处理器上实现多任务的并发执行，从而提高你的系统的性能和效率。
FreeRTOS可以让你根据任务的优先级、时间片、事件等因素来灵活地调度任务的运行，从而保证你的系统的实时性和正确性。
FreeRTOS可以让你使用队列、信号量、互斥锁、事件组等机制来实现任务之间的同步和通信，从而保证你的系统的稳定性和可靠性。
FreeRTOS可以让你使用静态或者动态的方式来分配任务的内存空间，从而保证你的系统的灵活性和可扩展性。
FreeRTOS可以让你使用各种工具和方法来检测和调试你的系统，例如栈溢出检测、断言、跟踪分析等，从而保证你的系统的质量和安全性。
二、如何使用FreeRTOS？ — 第1个FreeRTOS程序 要使用FreeRTOS，首先你需要选择一个合适的硬件平台和软件环境，例如微控制器型号、编译器类型、开发板规格等。然后你需要下载FreeRTOS的源代码，并根据你的平台选择相应的移植文件（port file）。移植文件是一些针对不同平台的特殊代码，用来实现一些基本的功能，例如时钟配置、中断处理、任务切换等。接着你需要配置FreeRTOSConfig.h文件，这个文件是一个头文件，用来设置一些FreeRTOS相关的宏定义，例如任务数量、堆大小、调试选项等。最后你就可以开始编写你自己的应用程序了。
要创建一个FreeRTOS程序，首先需要包含FreeRTOS的头文件，并定义一些必要的宏和变量。例如：
#include "FreeRTOS.h" #include "task.h" #define mainDELAY_LOOP_COUNT 100000UL static void prvTask1(void *pvParameters); static void prvTask2(void *pvParameters); 然后需要创建任务，并启动调度器。例如：
int main(void) { xTaskCreate(prvTask1, "Task 1", 1000, NULL, 1, NULL); xTaskCreate(prvTask2, "Task 2", 1000, NULL, 1, NULL); vTaskStartScheduler(); return 0; } 这里创建了两个任务，分别执行prvTask1和prvTask2函数，每个任务分配了1000个字节的栈空间，优先级都为1，没有传递任何参数。然后调用vTaskStartScheduler函数启动调度器，这个函数会创建一个空闲任务，并开始按照优先级和时间片轮转调度各个就绪状态的任务。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a44c254b22426e924e40bf00b79dcee7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85271a0179f6e095c02b0e8b62eaa740/" rel="bookmark">
			VS 与Qt的混合编程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近因为配置了VS2022下qt的环境，所以想要试试vs配合qt混合编程，若是想要将qt当做界面库使用，就需要知道QT的一些基本知识。
程序分为前端和后端，想要界面与数据进行交互，数据分为数据来源以及数据处理，而界面负责显示数据，数据来源可以是很多种，但数据需要经过处理才能提供给前端的界面使用，也就是前后端分离。
举个例子，qt的组件lineedit是个输入框，接收来自用户的输入，接收输入的内容是字符串型，也就是QString,在qt中，一些数据结构，都被QT改边，并且冠上独家姓氏，Q。
字符串QString,可变数组的容器 QVector等,用法与标准的cpp并没有什么区别，就是加了一个Q.
在我们写类的构造的时候，我们会留有一些接口，是因为我们需要将后端的数据取出来，拿来给前端做显示。
比如，你想在界面中显示一串字符串，在qt的环境下，提供控件Label显示文本信息。
我们来看一下Qlabel的手册， 首先label作用是显示文本或者图像，留出来的属性接口可以让你自己去构造属于你自己的label的样式，根据方法函数，让你去添加label的动作。
比如，你只希望构造一个label用于显示文本。
那么你后端传过来的数据应该是一个字符串，使用的类型是QString.
我们从手册中找到这个方法来显示字符串
void setText(const QString &amp;) Rich text
Pass a QString that contains rich text to setText().
如果数据是死的，那么就是label-&gt;setText("hello"),但是如果你需要数据能够变化，那么你需要去改变QString，让它是一个变化的量。
现在我在vs配置的qt环境下，使用编写一个程序。
首先我们来看看项目的布局。
main函数是程序入口，入口需要显示一个窗口，所以main函数的如下：
#include "peo2.h" #include &lt;QtWidgets/QApplication&gt; #include "FILENAME.h" #include&lt;QString&gt; #include&lt;QDebug&gt; #include&lt;string&gt; int main(int argc, char *argv[]) { QApplication a(argc, argv); peo2 w; w.show(); return a.exec(); } 基本使用的是qt自带的类，程序入口是一个实例化一个Peo2类型的一个窗口，并且显示出来。
那么如何创造Peo2类这个类呢，你的需求很重要。
这里使用了ui文件，并没有采用存代码开发.
我们来看一下，封装的接口以及如何构造这个类。
代码部分：
#pragma once #include &lt;QtWidgets/QMainWindow&gt; #include "ui_peo2.h" #pragma execution_character_set("utf-8")// 该指令仅支持VS环境，解决乱码问题 class peo2 : public QMainWindow { Q_OBJECT public: peo2(QWidget *parent = nullptr); ~peo2(); private: Ui::peo2Class ui; }; 在它的构造函数里：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/85271a0179f6e095c02b0e8b62eaa740/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd1bd20a0aa3aeeed909f66e9c01f34f/" rel="bookmark">
			基于Hexo和Butterfly创建个人技术博客，(14) 给博客站点添加Aplayer音乐
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Hexo官司网查看 这里
本章目标：
掌握aplayer音乐插件的用法给博客站点添加音乐功能
一、概述 个人比较倾向网站以简洁为主，并不赞成把网站做成花里虎哨的，比如添加鼠标特效或各种动态的元素。但个人站点的随意性比较大，虽没必要做成全局的音乐播放能力，但还是可以做成单独页或在无关紧的模块添加音乐功能。
笔者在自己的博客上做了一个单独的音乐页、又在个人相册页加了一个简化版本的音乐控件。
笔者使用的是Aplayer+meting2
aplayer ：音乐播放
meting2：包装了aplayer带了播放列表功能
很多教程的集成方法是直接安装上述两个插件包，然后再在页面中引入，其实笔者并不建议这种做法，因为这种方法插件所需要的.js文件会从站点加载，其实笔者更建议直接编码引用各免费CDN的资源，详细如下：
二、添加单独的音乐页 实际效果可点击blog.korg8.com来查看，即网站最下方footer部分的来杯咖啡超链接，效果图如下：
**实现方式：**用hexo new创建一个一个普通页，然后在页面中加入以下代码。
&lt;div id="music-page"&gt; &lt;/div&gt; &lt;script&gt; var userId = "60198"; var userServer = "netease"; var userType = "playlist"; &lt;/script&gt; &lt;link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css"&gt; &lt;script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"&gt;&lt;/script&gt; &lt;script src="https://cdn.jsdelivr.net/npm/meting@2.0.1/dist/Meting.min.js"&gt;&lt;/script&gt; &lt;script&gt; const params = new URLSearchParams(window.location.search); var _param = { getCustomPlayList: function () { const musicPage = document.getElementById("music-page"); const playlistType = params.get("type") || "playlist"; if (params.get("id") &amp;&amp; params.get("server")) { var id = params.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bd1bd20a0aa3aeeed909f66e9c01f34f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/293b755fe506fa4d4b26a3e1891cfd54/" rel="bookmark">
			操作系统第四章练习题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、为什么要配置层次式存储器？
2、可采用哪几种方式将程序装入内存？它们分别适用于何种场合？
3、何谓静态链接？何谓装入时动态链接和运行时的动态链接？
4、何谓装入时动态链接？装入时动态链接方式有何优点？
5、何谓运行时的动态链接？运行时的动态链接方式有何优点？
6、在动态分区分配方式中，应如何将各空闲分区链接成空闲分区链？
7、为什么要引入动态重定位？如何实现？
8、什么是基于顺序搜索的动态分区分配算法？它可分为哪几种？
9、在采用首次适应算法回收内存时，可能出现哪几种情况？应怎样处理这些情况？
10、什么是基于索引搜索的动态分区分配算法？它可分为哪几种？
11、令buddyk(x)表示大小为2k、地址为x的块的伙伴系统地址，试写出buddyk(x)的通用表达式。
12、分区存取管理中常用哪些分配策略？比较它们的优缺点。
13、对文件区管理的目标和对对换空间管理的目标有何不同？
14、为实现对换，系统应具备哪几方面的功能？
15、在以进程为单位进行对换时，每次是否都将整个进程换出？为什么？
16、基于离散分配时所用的基本单位不同，可将离散分配分为哪几种？
17、什么是页面？什么是物理块？页面的大小应如何确定？
18、什么是页表？页表的作用是什么？
19为实现分页存储管理，需要哪些硬件支持？
20、在分页系统中是如何实现地址变换的？
21、具有快表时是如何实现地址变换的？
22、较详细地说明引入分段存储管理是为了满足用户哪几方面的需要。
23、为什么要引入对换？对换可分为哪几种类型？
24、在具有快表的段页式存储管理方式中，如何实现地址变换？
25、为什么说分段系统比分页系统更易于实现信息的共享和保护？
26、何实现分段共享？
27、分页和分段存储管理有何区别？
28、试述分页系统和分段系统的主要区别。
29、试全面比较连续分配和离散分配方式?
第一部分 教材习题（P152）
1、为什么要配置层次式存储器？ 设置多个存储器能够使存储器两头的硬件能并行工作;采用多级存储系统,专门是Cache 技术,是减轻存储器带宽对系统性能影响的最佳结构方案;在微处置机内部设置各类缓冲存储器,减轻对存储器存取的压力。增加CPU中寄放器数量大大减缓对存储器压力。
2、可采用哪几种方式将程序装入内存？它们分别适用于何种场合？ 绝对装入方式，在编译时，如果知道程序将驻留在内存的什么位置，那么编译程序将产生绝对地址的目标代码。
可重定位装入方式，在多道程序环境下，由于编译程序不能预知所编译的目标模块在内存的什么位置，因此目标模块的起始地址通常从0开始，程序中所有其他地址都相对于起始地址计算。
动态运行时装入方式，程序在装入内存中后，允许程序在运行中在内存中移动位置。
3、何谓静态链接？何谓装入时动态链接和运行时的动态链接？ 答: 静态链接:在程序运行之前,先将各目标模块及它们所需的库函数,链接成一个完整的装入模块,以后不再拆开。这种事先进行链接的方式叫静态链接方式。
装入时动态链接:用户源程序编译后所得的一组目标模块,在装入内存时,采用边装入边链接的链接方式。
运行时的动态链接:对某些目标模块的链接,是在程序执行中需要该目标模块时,才对它进行的链接。
4、何谓装入时动态链接？装入时动态链接方式有何优点？ 装入时动态链接是指将用户源程序编译后所得到的一组目标模块,在装入内存时,采用边装入边链接的一种链接方式,即在装入一个目标模块时,若发生一个外部模块调用事件,将引起装入程序去找相应的外部目标模块,把它装入内存中,并修改目标模块中的相对地址。
装入时动态链接方式有以下优点:
1)便于修改和更新 2)便于实现对目标模块的共享
5、何谓运行时的动态链接？运行时的动态链接方式有何优点？ 运行时动态链接是将对某些模块的链接推迟到程序执行时才进行链接,也就是,在执行过程中,当发现一个被调用模块尚未装入内存时,立即由OS去找到该模块并将之装入内存,把它链接到调用者模块上。
优点:凡是在执行过程中未被用过的目标模块,都不会被调入内存和被链接到装入模块上,这样不仅能加快程序的装入过程,而且可节省大量的内存空间。
6、在动态分区分配方式中，应如何将各空闲分区链接成空闲分区链？ 答：为了现实对空闲分区的分配和链接，在每个分区的起始部分，设置一些用于控制分区分配的信息，以及用于链接各分区所用的前向指针，通过前、后向链接指针，可将所有的空闲分区链接成一个双向的链，如图所示（空闲链结构），为了检索方便，在分区尾部重复设置状态位的分区大小表目。当分区被分配出去以后，把状态位由“0”改为“1”，此时，前、后向指针已没有意义。
7、为什么要引入动态重定位？如何实现？ 答：在连续分配方式中，必须把一个系统或用户程序装入一连续的内存空间。如果在系统中只有若干个小的分区，即使它们容量的总和大于要装入的程序，但由于这些分区不相邻接，也无法把该程序装入内存。若想把作业装入，可采用的一种方法是：将内存中的所有作业进行移动，使它们全都相邻接，这样，即可把原来分散的多个小分区拼接成一个大分区，这时就可把作业装入该区。这种通过移动内存中作业的位置，以把原来多全分散的小分区拼接成一个大分区的方法方法，称为“拼接”或“紧凑”见图所示。由于经过紧凑后的某些用户程序在内存中的位置发生了变化，此时若不对程序和数据的地址加以修改（变换），则程序必将无法执行。为此，在每次“紧凑”后，都必须对移动了的程序或数据进行重定位，这也就引入的动态重定位。
8、什么是基于顺序搜索的动态分区分配算法？它可分为哪几种？ 为了实现动态分区式分配，将系统中的空闲分区组织成空闲分区表或空闲分区链。所谓顺序搜索，是指按表或链的组织顺序，检索表或链上记录的空闲分区，去寻找一个最符合算法的、大小能满足要求的分区。 分区存储管理中常采用的分配策略有：首次适应算法、循环首次适应算法、最佳适应算法、最坏适应算法。
9、在采用首次适应算法回收内存时，可能出现哪几种情况？应怎样处理这些情况？ 答: 当进程运行完毕释放内时，系统根据回收区的首址，从空闲区链中找到相应的插入点，此时可能出现以下四种情况之一：
回收区与插入点的前一个空闲分区F1相邻，见图（a）。此时应将回收区与插入点的前一区合并，不必为回收分区分配新表项，而只需修改其前一分区F1的大小。回收区与插入点的后空闲分区F2相邻接，见图（b）。此时也可瘵两分区合并，形成拳的空闲分区，但用回收的首址作为新空闲分区的首址，大小为两者之和。回收区同时与插入点的前、后两个分区相邻接，见图(C)。此时将三个分区合并使用F1的首址，取消F2的表项，大小为三者之和。回收区既不与F1相邻接，也不与F2相邻接。这时应为回收区单独建立一新表项，填写回收区的首址和大小，并根据其首址插入到空闲链中的适当位置。 10、什么是基于索引搜索的动态分区分配算法？它可分为哪几种？ 我们把空闲分区按照某种属性(通常是大小)分类,把每一类都链接起来形成一个链表,建立一个表把每类链表的相关信息写进去以供索引,按照这个数据分配空闲分区的算法叫做基于索引搜索的动态分区分配算法。它分为快速适应算法、伙伴系统、哈希算法。
11、令buddyk(x)表示大小为2k、地址为x的块的伙伴系统地址，试写出buddyk(x)的通用表达式。 12、分区存取管理中常用哪些分配策略？比较它们的优缺点。 固定分区存储管理
其基本思想是将内存划分成若干固定大小的分区,每个分区中最多只能装入一个作业。当作业申请内存时,系统按一定的算法为其选择一个适当的分区,并装入内存运行。由于分区大小是事先固定的,因而可容纳作业的大小受到限制,而且当用户作业的地址空间小于分区的存储空间时,造成存储空间浪费。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/293b755fe506fa4d4b26a3e1891cfd54/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87b5b61fcbd16e5fd0965e714cd2b724/" rel="bookmark">
			【Applied Algebra】有限状态机和模型检测初探
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【Applied Algebra】有限状态机和模型检测初探 摘要:有限状态机(FSM)和模型检测有密切的联系。有限状态机提供了一种用状态转换图来表示系统行为的简单方法。而模型检测是一种针对形式化模型（例如有限状态机）的验证技术，旨在自动验证模型是否满足特定的性质或规范。简而言之，有限状态机充当了模型的角色，而模型检测是针对这些模型的验证技术。
有限状态机 有限状态机（Finite State Machine，简称FSM）是一种计算模型，可以被用于处理许多具有固定状态和转换规则的场景。FSM在以下场景中很常见：
语法分析器和编译器：解析和处理程序代码，根据预定的语法规则识别语言结构。硬件电子系统：电子产品中的低层控制系统往往依赖有限状态机。游戏开发：游戏中的AI、角色状态、关卡流程等都可以使用有限状态机进行管理。通信协议：处理和维护网络上的不同连接和通信状态（如TCP协议）。工作流处理：企业和组织的业务流程中，FSM可以用来描述和处理各种状态的转换。 下面是一个简单的C++实现的有限状态机示例，模拟一个简单的交通信号灯系统：
#include &lt;iostream&gt; #include &lt;map&gt; enum TrafficLightState { Red, Yellow, RedToGreen, Green, YellowToRed }; class TrafficLight { public: TrafficLight() { fsmTable[Red] = RedToGreen; fsmTable[Yellow] = YellowToRed; fsmTable[RedToGreen] = Green; fsmTable[Green] = Yellow; fsmTable[YellowToRed] = Red; currentState = Red; } void nextState() { currentState = fsmTable[currentState]; } void displayState() { switch (currentState) { case Red: std::cout &lt;&lt; "Red" &lt;&lt; std::endl; break; case Yellow: std::cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/87b5b61fcbd16e5fd0965e714cd2b724/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7afe12cfa65ea54159ac847b600d723e/" rel="bookmark">
			10 个 Android Studio 插件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android Material Design Icon Generator - 生成 .xml 矢量格式的 Material Design 图标。
Android Drawable Importer - 将图像资源导入矢量绘图。
Butterknife Zelezny - 帮助使用 Butterknife 进行视图注入。
Android Firebase 工具- 提供与 Firebase 服务（例如 Firebase 数据库、存储、身份验证等）的集成。
Android 语言支持- 添加对 Java、Kotlin、XML 等的语言支持。
CodeGlance - 将代码文件的微型图添加到装订线中。
Material 主题 UI - 添加 Material 主题支持。
GsonFormat - 将 JSON 字符串格式化为 Gson 对象。
CoFigure - 生成 Android XML 属性的 configure() 方法。
翻译编辑器- 编辑 Android strings.xml 文件。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f49126cb2756f4928ac9dd8ed24a47e/" rel="bookmark">
			为自学开发者提供的提示和资源
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		介绍
踏上成为一名自学成才的开发人员的道路既充满挑战，又充满回报。作为一个亲身经历过这段旅程的高潮和低谷的人，我理解随之而来的挣扎和限制。在这篇博文中，我想分享一些宝贵的技巧和资源，这些技巧和资源在整个过程中对我有所帮助。尽管使用有限的资源（例如使用智能手机而不是笔记本电脑或 PC），我还是成功地创建了网络应用程序和个人作品集网站。如果我能做到，你也可以！
拥抱错误：将错误转化为学习机会
编程是一个错误不可避免的领域，但这没关系！遇到的每个错误都是作为开发人员学习和成长的机会。以下是一些拥抱错误的技巧：
不要害怕犯错误。每个人在学习编码时都会犯错误。重要的是从错误中吸取教训并继续前进。
不要把错误当成是针对个人的。错误并不反映你的智力或能力。它们只是学习过程的一部分。
把错误当作学习的机会。当你犯错误时，花点时间去理解为什么会犯错误，以及如何避免将来再犯同样的错误。
利用在线资源
有大量的在线资源可以帮助您学习编码。
充分利用有限的资源
如果您的资源有限，请不要因此而气馁。学习编码的方法还有很多。以下是充分利用有限资源的一些技巧：
使用您的智能手机。有许多适用于智能手机的编码应用程序。这些应用程序是学习编码基础知识的好方法。我个人使用 TrebEdit。
使用免费的在线资源。有许多免费的在线资源可以帮助您学习编码。这些资源是学习更高级主题的好方法。
加入编码社区。在线有许多编码社区。这些社区是获得帮助、向其他开发人员学习和保持积极性的好方法。
启发和鼓励读者
我希望通过分享我的经验和技巧，能够激励您开始成为自学成才的开发人员的旅程。请记住，这段旅程可能充满挑战，但最终是有回报的。拥抱旅程，不断学习，永不放弃。开始编码，让您的热情推动您走向成功！
结论
成为一名自学成才的开发人员是一段令人兴奋且充实的旅程。通过接受错误、利用在线资源并充分利用有限的资源，您可以克服遇到的挑战。请记住，无论您当前的情况如何，您都有能力创建出色的项目。拥抱旅程，不断学习，永不放弃。开始编码，让您的热情驱使您走向成功！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b88ef2e3c348c266d2ae57eddea1a906/" rel="bookmark">
			模糊测试基本介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		模糊测试基本介绍 覆盖率指引的模糊测试方法获得覆盖率的四种追踪方式1：
使用编译器向基本块边缘插桩，可以准确地插桩并易于优化，但需要源码已知。静态二进制重写，不需要源码，仍在研究，因为静态代码插桩准确性难以保证，并且优化能力有限。这些限制条件会影响代码率信息的质量与准确性，以及二进制重写的表现。动态二进制插桩，不需要源码，可以容易、准确插入代码，但是动态翻译二进制的开销可能大到不能接受。硬件辅助追踪，不需要源码，利用内置的硬件追踪扩展，在运行时直接获取控制执行流信息。 侵入式与非侵入式追踪2：
Traces can be generated by trace code that is executed within tasks and/or interrupt service routines, just like application code that is executed on the same CPU. This is the most flexible approach, as both the content and the amount of trace information output can be defined in software. However, this tracing method comes with a significant drawback: It uses resources that are shared with the application software, hence tracing may significantly reduce the amount of memory available for the applications, increase the gross execution times of the applications and, in the case of real-time systems, impair functionality.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b88ef2e3c348c266d2ae57eddea1a906/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2cb3d09fae9df5ccb4f62d8203d3b8af/" rel="bookmark">
			[软件工程导论(第六版)]第6章 详细设计（课后习题详解）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1 假设只有SEQUENCE和DO-WHILE两种控制结构，怎样利用它们完成 IF THEN ELSE操作？2 假设只允许使用SEQUENCE和IF-THEN-ELSE两种控制结构，怎样利用它们完成DO WHILE操作？3 画出下列伪码程序的程序流程图和盒图：4 图给出的程序流程图代表一个非结构化的程序，问：5. 研究下面的伪码程序：6 用Ashcroft-Manna技术可以将非结构化的程序转换为结构化程序，下图是一个转换的例子。7. 某交易所规定给经纪人的手续费计算方法如下：总手续费等于基本手续费加上与交易中的每股价格和股数有关的附加手续费。如果交易总金额少于1000元，则基本手续费为交易金额的8.4%；如果交易总金额在1000元～10000元之间，则基本手续费为交易金额的5%，再加34元；如果交易总金额超过10000元，则基本手续费为交易金额的4%加上134元。当每股售价低于14元时，附加手续费为基本手续费的5%，除非买进、卖出的股数不是100的倍数，在这种情况下附加手续费为基本手续费的9%。当每股售价在14元到25元之间时，附加手续费为基本手续费的2%，除非交易的股数不是100的倍数，在这种情况下附加手续费为基本手续费的6%。当每股售价超过25元时，如果交易的股数零散（即不是100的倍数），则附加手续费为基本手续费的4%，否则附加手续费为基本手续费的1%。8 画出下列伪码程序的流图，计算它的环形复杂度。这个程序的逻辑有什么问题吗？9 把统计空格程序的Jackson图（图6-26）改画为等价的程序流程图和盒图。10 人机对话由操作员信息和系统信息交替组成。假设一段对话总是由操作员信息开始以系统信息结束，用Jackson图描绘这样的人机对话过程。 1 假设只有SEQUENCE和DO-WHILE两种控制结构，怎样利用它们完成 IF THEN ELSE操作？ 答：
转化如下：
K=1 DO WHILE(条件 AND K EQ 1) 程序块1 K=K+1 END DO DO WHILE((NOT 条件)AND K EQ 1) 程序块2 K=K+1 END DO 2 假设只允许使用SEQUENCE和IF-THEN-ELSE两种控制结构，怎样利用它们完成DO WHILE操作？ 答：
转化如下：
label:IF(条件) THEN 程序块 GOTO label ELSE 程序块 END IF 3 画出下列伪码程序的程序流程图和盒图： START IF p THEN WHILE q DO f END DO ELSE BLOCK g n END BLOCK END IF STOP 流程图
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2cb3d09fae9df5ccb4f62d8203d3b8af/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6bf075318285356a1cd985630b9029e7/" rel="bookmark">
			神马搜索移动适配讲解说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当您的网站有PC和移动版本，希望神马收录移动版本时，我们建议：
1. 网站自己做好PC和移动网页的自适配，当用户在移动设备访问PC网页时自动适配到移动网页。
2. 网站做PC和移动网页自适配有困难，可采用在PC版网页标注meta声明的方式。
具体的操作步骤：
1) 在PC网页源码的Meta字段添加PC和移动页面对应关系声明
Meta声明格式为： &lt;meta name="mobile-agent" content="format=[wml|xhtml|html5]; url=对应的移动网页网址"/&gt;
2) 在神马站长工具提交PC和移动网页对应关系。此为非必要步骤，但声明后提交对应关系能帮助神马尽快完成PC和移动页面的转换。
3. 未做自适配和Meta标注声明，可直接在神马站长工具提交页面对应关系。PC和移动页面对应关系可以是pattern级别和url级别，也可两者兼有。
PC url pattern与移动url pattern对应关系
PC url pattern：表示PC版网页pattern，在PC页url基础上，首先确定url中哪些路径或参数是可替换的。然后根据其类型，使用正则匹配符号(\d+)或者(\w+)表示该路径或参数。(\d+)表示纯数字字符串，(\w+)表示数字或字母组成的字符串。
移动url pattern：可以是xhtml/html5/wml版式的手机页pattern。在移动url的基础上，根据可替换参数在对应的PC页pattern中出现的顺序，依次用${1}，${2}，……表示该参数。
示例
1. 确定PC url中的可替换参数或路径，得到其位置序号和类型
PC url：http://www.domain.com/2014/0514/Y5SYZ90.html
从网站url结构来分析，其中2014,0514和Y5SYZ90为动态可替换的路径。除Y5SYZ90为字母和数字混合外，其余均为纯数字。
2. 根据可替换参数或路径得到pc网页pattern。
PC url pattern：http://www.domain.com/(\d+)/(\d+)/(\w+).html
(\d+)表示纯数字字符串，(\w+)表示数字或字母组成的字符串。
3. 比对PC和移动url的结构，根据可替换参数在步骤1中的位置序号，依次用${1}，${2}，……表示替换掉移动url 中的可替换参数或路径，得到移动url pattern。
移动url pattern：http://m.domain.com/${1}/${2}/${3}.html提交文件格式
支持以xml文件提交移动适配数据。xml文件可提交url一对一对应关系以及url pattern级对应关系，提交数据可以是1组或者多组。一个xml文件提交的数据上限是1000组
网站seo优化
标准xml文件格式示例：
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;urlset&gt;
&lt;!--表示www.domain.com 下的一组pattern 或url对应关系--&gt;
&lt;url&gt;
&lt;loc&gt;http://www.domain.com/ &lt;/loc&gt;
&lt;!-- 表示pc站点的网址首页 --&gt;
&lt;data&gt;
&lt;display&gt;
&lt;pc_url_pattern&gt;http://www.domain.com/(\d+)/(\d+)/(\w+).html&lt;/pc_url_pattern&gt;
&lt;!-- 表示该PC页的url pattern--&gt;
&lt;xhtml_url_pattern &gt;http://m.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6bf075318285356a1cd985630b9029e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c9035b1c19cc127a02360af660ec5177/" rel="bookmark">
			百度搜索打击违规落地页体验公告说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		近期，百度搜索发现落地页体验问题有所增加，为保障用户的搜索体验，让提供优质体验的站点得到合理的展现，百度搜索将于6月底采取落地页体验问题管控措施，针对严重落地页体验问题的页面/站点，将限制其在百度搜索结果中的展现。
百度搜索鼓励开发者生产体验优质的页面，当用户在浏览移动落地页时，站点可以为用户提供符合搜索用户浏览体验的页面，保证移动落地页的快速打开，浏览顺畅，整体布局合理、排版精良，避免低质广告页面，功能操作异常等情况出现。
问题说明 1、pc端移动适配 移动搜索结果落地页必须是移动页而不是PC页。
整改措施： （1）设计搭建与PC站形成对应适配关系的移动站，并积极向百度提供移动页面及适配关系。
（2）将PC站点进行自适应改造，以便适应移动浏览器的界面，给用户带来良好视觉体验。
2、页面排版布局 （1）主体内容
首屏主体内容不能少于整体页面的50%，并且主体内容应位于手机屏幕的中心位置。注意排版精良，段落分明。合理使用不同字号区分页面的主次信息，注意调节图片、视频等多媒体资源的位置及尺寸，配合页面整体布局。
（2）落地页体验广告
① 在落地页的任何位置都不允许放置悬浮广告、弹窗广告、遮屏广告、闪动广告、轮播广告等广告形式，不允许遮挡页面主体内容及功能，避免干扰用户正常的浏览体验和搜索需求。
② 落地页的首屏顶部允许嵌入不超过一屏面积10%的优质广告，优质广告是指广告面积和内容合规的前提下，形式上有明确广告标识，样式美观，视觉体验好，且宣传内容不违反法律法规要求，不涉及虚假、欺骗信息，值得信赖。
3、交互功能规范 （1）功能键设置
① 功能位置必须固定，不可抖动或闪烁，与页面其他内容模块（如广告）要有一定间距，不可重叠，避免用户误操作。
② 功能必须简单易用，操作友好便捷，且实际功能与文字描述需完全一致，不可出现诱导信息或引导跳转第三方页面。
③ 功能可设置成嵌入样式也可设置成悬浮样式，一页面上功能按钮面积不可超过一屏面积的10%，不可遮挡用户浏览页面内容或进行其他功能操作。
④ 咨询类功能在当前页只能出现一次，且位置不允许出现在顶部；在用户未主动点击的情况下，咨询的对话窗口不可自动弹出；
seo平台
（2）功能键使用 为保证搜索用户浏览页面的便捷性，页面上下滑动及tab模块切换等操作需顺畅不卡顿。保证搜索用户功能使用友好，操作简易，不能出现繁琐步骤或重复点击等使用不符合预期的情况。
① 功能键：不能出现下载键失效，视频或音频播放键失效，进度条无法正常拖拽，视频横屏播放失败等情况。
② 筛选键：筛选分类错误，有相关结果但无法筛选到相关信息，筛选结果点击后需重新筛选。
③ 搜索定位：搜索功能不能使用；产品覆盖资源但未定位准确内容；产品内容丰富，但未直接定位用户需求信息。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/291ecbd84ef4090569cbb688ad231b24/" rel="bookmark">
			C&#43;&#43;QT入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C++QT 文章目录 C++QT1. QT概述1.1 什么是QT1.2 QT的发展史1.3 支持的平台1.4 QT版本1.5 Qt 的下载与安装1.6 QT的优点1.7 成功案例 2. 创建QT项目2.1 使用向导创建2.2 手动创建2.3 .pro 文件2.4 设置父对象2.5 按钮设置属性2.5.1 按钮设置文本2.5.2 设置移动2.5.3 设置固定大小 2.6 另外一种创建按钮方式2.6.1 构造时创建2.6.2 初始化后设置与构造函数设置的区别 2.7 对象模型（对象树）2.8 Qt窗口坐标体系 3 信号与槽机制3.1 信号与槽3.2 系统自带的信号与槽3.3 常用的信号3.4 自定义槽函数3.5 自定义信号3.6 信号槽拓展3.6 Qt4版本的信号槽写法3.7 Lambda 表达式3.7.1 lambda传参（无参数）3.7.2 lambda 传参（有参数）3.7.3 传值和传址 4. QMainWindow4.1 介绍4.2 工具栏4.3 状态栏4.4 铆接部件4.5 中心部件4.6 资源文件4.7 增加背景图 5. 对话框5.1 基本概念5.2 标准对话框5.2.1 模态对话框5.2.2 非模态对话框 5.3 消息对话框 6.布局管理器6.1 系统布局6.2 利用widget 做布局 7.常用控件7.1 QLabel7.1.1 显示文字（普通文本、html）7.1.2 显示图片7.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/291ecbd84ef4090569cbb688ad231b24/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7bd50957820ba9ad00047ba0cbe2c16e/" rel="bookmark">
			体验PicGo&#43;GitHub&#43;jsDeliver搭建免费图床
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		github设置 github创建仓库 如果不想使用main分支，可以新建分支
github获取个人token 生成一个token用于PicGo访问图床仓库。
访问：https://github.com/settings/tokens
然后点击Generate new token。
注意：
这个token生成后只会显示一次！你要把这个token复制一下存到其他地方以备以后要用。
下载 PicGo 下载地址：https://github.com/Molunerfinn/PicGo
官方文档：https://picgo.github.io/PicGo-Doc/zh/guide
配置PicGo 仓库名的格式是用户名/仓库，比如创建一个叫做cdn_img的仓库，在PicGo里要设定的仓库名就是Sbwillbealier/cdn_img。一般选择main分支(如若选择其他分支，注意文件链接多了一级 /blob)。
如果需要上传到其他分支，需如下配置，此处使用了 jsdelivr 的CDN加速，使用见下一节
PicGo设置 PicGo上传测试 PicGo相册 PigGO配置腾讯云COS jsdelivr A free CDN for open source projects–用于开源项目的免费 CDN
项目地址：https://www.jsdelivr.com/?docs=gh
域名配置方式
// 加载任何Github发布、提交或分支 https://cdn.jsdelivr.net/gh/user/repo@version/file // 加载 jQuery v3.6.4 https://cdn.jsdelivr.net/gh/jquery/jquery@3.6.4/dist/jquery.min.js // 使用版本范围而不是特定版本 https://cdn.jsdelivr.net/gh/jquery/jquery@3.6/dist/jquery.min.js https://cdn.jsdelivr.net/gh/jquery/jquery@3/dist/jquery.min.js // 完全省略版本或分支以获得最新版本 ，不应该在生产中使用它 https://cdn.jsdelivr.net/gh/jquery/jquery/dist/jquery.min.js // 将“.min”添加到任何JS/CSS文件中以获取缩小版本，如果不存在，将为会自动生成 https://cdn.jsdelivr.net/gh/jquery/jquery@3.6.4/src/core.min.js // 在末尾添加"/"以获取资源目录列表 https://cdn.jsdelivr.net/gh/jquery/jquery/ 本文有参考：
免费CDN：jsDelivr+Github 使用方法
【免费稳定图床最佳实践：PicGo+GitHub+jsDeliver 极简教程】
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/417f6eccbeb4376275b44ae97241bdd8/" rel="bookmark">
			如何给Windows电脑重装系统&#43;新系统设置（从检查到实施，看这一篇就够了！）包含BitLocker的备份，镜像的下载，启动盘的制作，安装的流程，驱动的下载，新电脑的设置等各个方面。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何给一个Windows电脑（任意版本）重装win11（此方法Windows10适用）系统？在此之前都需要注意（或检查）什么方面？会出现什么问题以及其解决方法？ 这篇文章会给予读者一个完整的解答。
大家好，我是爱好计算机的初中生一名
由于电脑磁盘内存有限以及最近考试学习的资料以及应用过于杂乱，使我不得不重装系统，为了一片清净的领土。
先问一句，为什么要重装系统？
最简单的答复：是修复电脑各个问题的最最最简单的方法。
好了，进入正题。
第一步：检查+备份 准备材料方案1：U盘
准备材料方案2：云盘（例如百度网盘）
备份方法简单来说就是把需要的文件复制到别处脱离电脑存储起来
换句话说就是保存到U盘或者上传到网盘
基于我的想法，我列了一个表：
密码方面：电脑中存贮的密码，软件的登录密码，网络密码软件方面：记忆电脑下载过或者常用的软件文件方面：把自己的文件复制到U盘里以防万一：备份BitLocker密钥！！！ 先说第一个问题，网络密码（其实也没什么用处） 右键单击任务栏，选择“任务资源管理器”
在其中选择用户-&gt;右键-&gt;选择“管理用户账户”
选择管理你的凭据
记住密码即可。
第二个问题：备份BitLocker（最重要！！！！） 有时候电脑会突然蓝屏，让你输入BitLocker，这时候我们的备份派上用处了。
首先按win键，输入控制面板，然后选择第一个系统与安全。
（注意点击的是荧光笔标注的位置）
选择设备加密
选择所需要的盘并点击“备份恢复密钥”
这里建议选择打印恢复密钥
因为这样可以选择用打印机打印或者打印出PDF保存到U盘
以上就是备份恢复密钥的全部内容 第二步：下载镜像（制作启动盘） 两种方法
使用Windows给出的方案（快捷，简单）使用工具搭配镜像（灵活） 方法一：使用Windows给出的方案 首先进入网站，链接（建议使用我这个，因为自己搜索可能会不小心进入钓鱼网站）
三种选择，
第一种是直接在你的电脑装，
第二种是安装一个软件，给U盘直接制作成启动盘，
第三种是下载一个Windows ISO文件（第二种方法需要）
这里我们选择第二个，创建Windows11安装
直接下载即可
然后插入U盘，双击运行软件。
当然选择接受了
一般来说会自动选择对你电脑推荐的配置，但也可以取消勾选并且自己选择。
选择U盘，别看那8gb，建议至少32gb
选择上就行
不用担心，这玩意很慢很慢的。
下载好后就可以弹出U盘继续下一步了。
方法二：自己创建启动盘 首先来到方法一下载软件的位置链接
选择第三个下载ISO镜像 然后进入这个网站Rufus
下滑
在最新版本那块我选择的第一个（rufus-4.1.exe）
以后会有新的版本，所以读者的版本号不一定和我的一样。
然后下载，开箱即用。
圈3那里的选择就是选择你下载好的ISO镜像文件
然后开始即可，时间比方法一快一些 以上就是创建启动盘的全部内容
第三步：使用BIOS启动，系统重装。 步骤流程如下：
先在关机状态下的电脑插入制作好的启动盘开机，同时狂按自己电脑的启动项对应键进入画面，选择boot from usb 各品牌启动项快捷键
这是各品牌启动项快捷键，如果你电脑的F1~12有额外功能（例如调整音量或者亮度等）需要按Fn的同时按对应的快捷键。
注意要狂按！
之后如果没有什么大问题，那么就会进入这个界面
根据你的需求选择
讲一下基本的按键（个人总结）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/417f6eccbeb4376275b44ae97241bdd8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/deda9211b7e96f09898f15093667a26e/" rel="bookmark">
			解决“Pick up system reserved threshold 500ms because of config missing”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		skywalking启动日志一直刷“Pick up system reserved threshold 500ms because of config missing”
如下图
原因缺少动态的配置项
skywalking支持动态配置的配置项如下
在nacos中的skywalking命名空间添加key value即可解决
重启skywaling启动日志不报warn了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c69a3187822a1aa049abc547908a86da/" rel="bookmark">
			血流动力学与血压(一)--平均动脉压
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		平均动脉压 在血管血流动力学研究中，心血管系统通常被认为是一个简单的液压回路，由泵（心脏）组成，泵（心脏）有节奏地活动（收缩 --&gt; 舒张 --&gt; 收缩 --&gt; 舒张 --&gt; 收缩…），推动液体（血液）进入管子（主动脉），血液不断地进行分流（外周动脉 --&gt; 小动脉 --&gt; 毛细血管）以便能够到达最远的距离（组织）。这个液压回路非常类似于一个简单的电路，通常使用电气模型来验证心血管血液动力学现象，如下图所示。 上图表示了心脏泵血循环和一个简单的电路的相似程度，图(a)表示了一个简单的电路，V1-V2是在电阻两点的电势差，I是流经电阻的电流，R是电阻的阻值。类比于图(a)，图(b)中的 SVR(systemic vascular resistance)表示的的是全身血管阻抗，P1-P2表示的是体循环两个端点之间的血压差， CO(cardiac output)表示的是心输出量。我们都知道欧姆定律，电阻两端的电压等于电阻值乘以流经电阻的电流：
Δ V = I × R \Delta V = I \times R ΔV=I×R
类比于欧姆定律，血压差就等于心输出量CO乘以全身血管阻力SVR：
Δ P = C O × S V R \Delta P = CO \times SVR ΔP=CO×SVR
由于回到心脏的血压很低，我们将压力值视为升主动脉的血压值（P）；因此，上式可以简化为：
P = C O × S V R P = CO \times SVR P=CO×SVR
由于心输出量 (CO) 是通过将每搏输出量 SV(stroke volume)乘以心率 HR(heart rate)得出的，因此该公式可以重写为:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c69a3187822a1aa049abc547908a86da/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6107e641ef6284ff5528ff2a4c1bc6b7/" rel="bookmark">
			Android build.gradle文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、ABI（Application Binary Interface）应用程序二进制接口 其实ABI可以不设置，这样编译时，就会将项目里所有依赖资源包里的so库都打到最终的apk里。 但是，ABI支持多的话，apk也会大，所以一般只支持一种即可。 目前Android 版本，ABI一般配置armeabi-v7a.
注意：
新增so库 新增so库的话，需要在每个在用的文件夹内（armeabi、armeabi-v7a、arm64-v8a ==）放置，否则so库找不到。多个目录，目录下的so库文件数需要相同。 armeabi-v7a 和 armeabi 如果设置支持armeabi-v7a 和 armeabi：如若第三方提供的so只有armeabi，那么armeabi-v7a 内也需要拷贝一份，原因是armeabi-v7a 和 armeabi必须so数一致，且armeabi-v7a支持armeabi hardware does not support ABI设置错误，可能出现硬件不支持的问题，提示：hardware does not support
二、splits 的属性 1、abi 类型：AbiSplitOptions描述：对 abi 进行分包处理，具体我们看下面 AbiSplitOptions 讲解。 2、AbiSplitOptions 类型 2.1 enable 描述：是否开启 abi 分包，默认不开启使用： splits {
abi {
enable true
}
}
效果图如下：
2.2 exclude
描述：排除不需要的架构。
使用： abi {
// 是否开启
enable true
// 排除不必要的架构
exclude 'x86','arm64-v8a'
}
效果图：
2.3 reset
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6107e641ef6284ff5528ff2a4c1bc6b7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f34f26133f3774e8949198ecf0cc9c58/" rel="bookmark">
			【Docker】进入docker下的mysql
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		进入docker下的mysql 首先查看mysql容器的名称 查看当前运行的容器
docker ps 输出所有正在运行的容器，找mysql或端口3306的
CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 95a11cbfab52 mysql:5.7 "docker-entrypoint.s…" 3 days ago Up 3 days 127.0.0.1:3306-&gt;3306/tcp, 33060/tcp aisa_arule3 查看mysql的container的ID是 95a11cbfab52 然后进入
进入容器 docker exec -it 95a11cbfab52 bash 进入容器后，终端前缀显示有变化
root@95a11cbfab52:/# 最后进入mysql mysql -uroot -p # Enter password: 输入正确面后；终端最终出现：
mysql&gt; show databases;
use database;
show tables;
desc rules_total ; – 查询rules_total的表结构
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4371f6ba24669b75087ad288dfbf2143/" rel="bookmark">
			【C&#43;&#43;】-8.2- string〔string类模拟实现〕
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 //模拟实现string类，并完成测试• string类的基本结构• Destructor• Construct〔构造函数〕‹ 无参构造 ›‹ 单参数构造 ›‹ 全缺省参数构造 › 〔拷贝构造〕 • operator= 赋值重载• Element access（operator[]）补充：const 变量的场景• Iterator• Relational Operators（比较大小）• Capacity〔size〕&amp;〔capacity〕&amp;〔empty〕〔reserve〕〔resize〕 • Modify〔push_back〕&amp;〔append〕〔+=〕〔swap〕〔clear〕&amp; 〔c_str〕 • 「insert」在 pos 位置插入字符或字符串• 「erase」从 pos 位置删除 len 个字符注：npos的声明和定义• 「find」• 「流插入&lt;&lt;、流提取&gt;&gt;」‹ 流插入 ›‹ 流提取 › //模拟实现string类，并完成测试 头文件声明：
//anolog_string.h #pragma once #include &lt;iostream&gt; namespace RoundBottle//与库里面的string类做区分 { class string { public: typedef char* iterator; typedef const char* const_iterator; //全缺省构造 string(const char* str = ""); //拷贝构造 string(const string&amp; s); //赋值重载是关于两个已经存在的对象 string&amp; operator=(const string&amp; s); ~string(); / // access char&amp; operator[](size_t index); const char&amp; operator[](size_t index)const; // // iterator iterator begin(); iterator end(); const_iterator begin()const; const_iterator end()const; / // modify void push_back(char c); string&amp; operator+=(char c); void append(const char* str); string&amp; operator+=(const char* str); void clear(); void swap(string&amp; s); const char* c_str()const; / // capacity size_t size()const; size_t capacity()const; bool empty()const; void resize(size_t n, char c = '\0'); void reserve(size_t n); / //relational operators bool operator&lt;(const string&amp; s); bool operator&lt;=(const string&amp; s); bool operator&gt;(const string&amp; s); bool operator&gt;=(const string&amp; s); bool operator==(const string&amp; s); bool operator!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4371f6ba24669b75087ad288dfbf2143/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3c077b779a01174448319222e96e7a6/" rel="bookmark">
			CC2530基础实验：(8)串口通讯-发送字符串控制LED
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
一、实验相关电路图
二、实验相关理论与寄存器
1.并行通信与串行通信
2.URAT
3.同步通信与异步通信
4.外设I/O
5.CC2530 的串口通信模块
6.相关寄存器
三、源码分析
前言 本实验用于学习CC2530芯片：
发送与接收字符串的串口配置与使用通过发送不同的字符来控制LED的状态 本实验是在CC2530基础实验：(6)串口通讯-发送与接收字符串 基础上进行的拓展，这两节理论基本相同
一、实验相关电路图 P0_2、 P0_3 配置为外设功能时： P0_2 为 RX， P0_3 为 TX。USART0 和 USART1 是串行通信接口，它们能够分别运行于异步 UART 模式或者同步 SPI 模式。两个 USART 具有同样的功能，可以设置在单独的 I/O 引脚。更详细的说明请参考数据手册 7.6 和16.1 节。
二、实验相关理论与寄存器 1.并行通信与串行通信 微控制器与外设之间的数据通信，根据连线结构和传送方式的不同，可以分为两种：并行通信和串行通信。
并行通信：指数据的各位同时发送或接收，每个数据位使用单独的一条导线。传输速度快、效率高，但需要的数据线较多，成本高。
串行通信：指数据一位接一位地顺序发送或接收。需要的数据线少，成本低，但传输速度慢，效率低。
2.URAT UART，即通用异步收发传输器（Universal Asynchronous Receiver/Transmitter），是一种异步收发传输器，是电脑硬件的一部分。它将要传输的资料在串行通信与并行通信之间加以转换。作为把并行输入信号转成串行输出信号的芯片，UART通常被集成于其他通讯接口的连结上。我们通常说的串口——UART包含TTL电平和RS-232电平两种，在嵌入式系统里面，单片机的串口一般都是TTL电平。
UART因为有两根线数据线TX和RX，可以以全双工的形式进行发送和接收数据，同一时刻，两条链路的发送器和接收器可以同时传输数据。
3.同步通信与异步通信 同步是指：发送方发出数据后，等接收方发回响应以后才发下一个数据包的通讯方式。
异步是指：发送方发出数据后，不等接收方发回响应，接着发送下个数据包的通讯方式。
其中SPI IIC为同步通信，UART为异步通信，USART为同步&amp;异步通信（STM32有所应用）。 4.外设I/O I/O接口是介于CPU和外设之间的一种缓冲电路，在CPU和外设之间起到速度匹配、信号转换（数据传输）等作用。对于USART 和定时器 I/O，在一个数字 I/O 引脚上选择外设 I/O 功能，需要设置对应的 PxSEL 位为 1。
注意，该外部单元具有两个可以选择的位置对应它们的 I/O 引脚，详情见下表。如果有关于 I/O 映射的冲突设置，可以在这些之间设置优先级（使用 P2SEL.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f3c077b779a01174448319222e96e7a6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07d4f86733a15cbe798b9880bab64cc7/" rel="bookmark">
			HTML面试题：30道含答案和代码示例的练习题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简述HTML的作用和特点。 HTML全称为超文本标记语言，是一种用于创建网页的标准语言。HTML文档通常包含HTML标签和文本内容，标签用于描述文档的结构和内容。HTML具有易于学习、开放标准、可访问性好等特点。
什么是HTML标签？ HTML标签是HTML文档中用于定义元素的代码。标签通常是成对出现的，分别表示起始标签和结束标签，中间包含元素的内容。
请列举几个常用的HTML标签及其作用。 &lt;html&gt;：定义HTML文档的根元素。&lt;head&gt;：定义文档的头部区域，包含文档的元数据。&lt;title&gt;：定义文档的标题，通常出现在浏览器的标题栏中。&lt;body&gt;：定义文档的主体部分，包含文档的内容。&lt;p&gt;：定义段落。&lt;a&gt;：定义超链接。&lt;img&gt;：定义图片。&lt;div&gt;：定义文档中的一个区块。&lt;ul&gt;：定义无序列表。&lt;ol&gt;：定义有序列表。&lt;li&gt;：定义列表中的一个项目。 什么是HTML属性？ HTML属性是用于设置HTML元素的额外信息。属性通常包含一个名称和一个值，用等号将其分隔开。属性通常出现在标签的开始部分，如&lt;img src="example.jpg"&gt;。
请列举几个常用的HTML属性及其作用。 class：定义元素的类名，用于设置元素的样式或JavaScript操作。id：定义元素的唯一标识符，用于在JavaScript中操作元素。style：定义元素的样式，包含CSS属性和值。src：定义元素的资源路径，如图片、音频、视频等。href：定义元素的超链接目标，如链接到另一个页面或下载文件。alt：定义元素的替代文本，用于在无法显示元素时提供说明信息。 如何设置HTML元素的样式？ 可以使用CSS（层叠样式表）来设置HTML元素的样式。CSS可以通过内联样式、嵌入样式表或外部样式表来引入。内联样式直接在元素的style属性中设置，嵌入样式表在&lt;head&gt;标签中使用&lt;style&gt;标签定义，外部样式表则定义在一个独立的CSS文件中，通过&lt;link&gt;标签引入。
如何创建带有超链接的文本？ 可以使用&lt;a&gt;标签来创建带有超链接的文本。&lt;a&gt;标签的href属性定义超链接目标，可以是一个URL、一个锚点或JavaScript代码，例如：
&lt;a href="&lt;http://example.com&gt;"&gt;跳转到Example网站&lt;/a&gt; 如何在HTML中插入图片？ 可以使用&lt;img&gt;标签来插入图片。&lt;img&gt;标签的src属性定义图片的资源路径，alt属性定义图片的替代文本，例如：
&lt;img src="example.jpg" alt="Example图片"&gt; 如何创建HTML表格？ 可以使用&lt;table&gt;、&lt;tr&gt;、&lt;td&gt;等标签来创建HTML表格。&lt;table&gt;标签定义表格，&lt;tr&gt;标签定义行，&lt;td&gt;标签定义单元格，例如：
&lt;table&gt; &lt;tr&gt; &lt;td&gt;第一行，第一列&lt;/td&gt; &lt;td&gt;第一行，第二列&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;第二行，第一列&lt;/td&gt; &lt;td&gt;第二行，第二列&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; 如何创建有序列表和无序列表？ 可以使用&lt;ol&gt;和&lt;ul&gt;标签来创建有序列表和无序列表，&lt;li&gt;标签定义列表中的项目，例如：
&lt;ul&gt; &lt;li&gt;列表项目1&lt;/li&gt; &lt;li&gt;列表项目2&lt;/li&gt; &lt;li&gt;列表项目3&lt;/li&gt; &lt;/ul&gt; &lt;ol&gt; &lt;li&gt;列表项目1&lt;/li&gt; &lt;li&gt;列表项目2&lt;/li&gt; &lt;li&gt;列表项目3&lt;/li&gt; &lt;/ol&gt; 什么是HTML表单？ HTML表单是用于收集用户输入数据的一种元素。表单由多个表单控件组成，如文本框、下拉列表、单选框、复选框等。
如何创建HTML表单？ 可以使用&lt;form&gt;标签来创建HTML表单，&lt;input&gt;、&lt;select&gt;、&lt;textarea&gt;等标签用于定义表单控件，例如：
&lt;form&gt; &lt;label for="username"&gt;用户名：&lt;/label&gt; &lt;input type="text" id="username" name="username"&gt; &lt;label for="password"&gt;密码：&lt;/label&gt; &lt;input type="password" id="password" name="password"&gt; &lt;input type="submit" value="登录"&gt; &lt;/form&gt; 什么是HTML元数据？ HTML元数据是用于描述HTML文档的一类数据。元数据通常包含文档的标题、描述、关键字、作者等信息，可以用于SEO（搜索引擎优化）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/07d4f86733a15cbe798b9880bab64cc7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c9e02a4423dae9c1f251822c0527810/" rel="bookmark">
			jadx反编译工具的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 jadx工具介绍
jadx工具的安装
jadx工具的使用
jadx遇到的问题
jdk和jre的区别
jadx工具介绍 decompile Dalvik bytecode to java classes from APK, dex, aar, aab and zip files将Dalvik 字节码从APK，dex,aar,aab，zip文件里反编译为java类decode AndroidManifest.xml and other resources from resources.arsc解码 AndroidManifest.xml 和其他资源文件从 resources.arsc 下载地址：
GitHub - skylot/jadx: Dex to Java decompiler
jadx工具的安装 JDK 11 or higher must be installed:
git clone https://github.com/skylot/jadx.git cd jadx ./gradlew dist (on Windows, use gradlew.bat instead of ./gradlew)
jadx工具的使用 通过gradlew.bat命令后，会生成exe执行程序，将aar或jar或者apk文件 移到exe即可
jadx遇到的问题 This application requires a Java Runtime Environment 11(64-bit)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6c9e02a4423dae9c1f251822c0527810/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49f10405142b8d690f9a8dd90c44a07e/" rel="bookmark">
			BEVFusion(mit)最强环境安装，部署复现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0.前言 最近在做BEV视图下融合感知的项目，需要对相关工作进行学习。BEVFusion作为一项经典的工作，值得深入探索，论文地址，代码地址。然而由于配置环境比较麻烦，耽误了一些时间。经过几次成功配置之后，有了一些总结，在这里记录下来，供大家参考，也方便自己下次查阅。
首先，要知道这个工程对于电脑配置要求比较高。我目前在3090和3060上都成功了，但是再低一些可能就不太行了，batch_size为1的时候显存占用8-9G。当前我配环境的这台电脑配置是3060显卡，16G内存，12G显存。如果你的电脑配置很低，那还是别麻烦了，或者换更好的配置。
目录如下，如果显卡驱动话cuda都安装好了，直接进入第三步！
0.前言
1.显卡驱动安装
2.cuda安装
3.环境配置
4.数据准备
5.终端训练与测试
6.用pycharm 进行 debug
1.显卡驱动安装 如果你的电脑还没有安装显卡驱动，需要根据系统推荐的进行安装。查看是否有显卡驱动的指令是：
nvidia-smi 如果显示了如下所示的详细信息：
则说明有显卡驱动，可以直接跳到下一步。否则需要先安装显卡驱动，安装步骤如下。
1.注意！在安装NVIDIA驱动以前需要禁止系统自带显卡驱动nouveau：可以先通过指令
lsmod | grep nouveau 查看nouveau驱动的启用情况，如果有输出表示nouveau驱动正在工作，如果没有内容输出则表示已经禁用了nouveau。禁用的方法: 禁用nouveau
2.安装有好几种方法，这里介绍一种比较简单的方法，即在‘软件和更新’里面下载。选中合适的版本，点击应用更改，下载完成之后重启即可，再次用nvidia-smi查看。
本文档的重点不在此，如果想用其他方法，参考：Ubuntu安装显卡驱动详细步骤https://blog.csdn.net/m0_54792870/article/details/112980817?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168733445516782425129780%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=168733445516782425129780&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-3-112980817-null-null.142^v88^control_2,239^v2^insert_chatgpt&amp;utm_term=ubuntu%E5%AE%89%E8%A3%85%20%E6%98%BE%E5%8D%A1%E9%A9%B1%E5%8A%A8&amp;spm=1018.2226.3001.4187
2.cuda安装 cuda的版本需要根据显卡来选择，运行nvidia-smi之后，可以看到显卡支持的最高cuda版本，那么我们安装的cuda版本要小于等于这个上限。但是又不能太低，有的显卡型号比较新，装了太老的cuda反而会出问题。我查到的是11.4，于是安装了cuda11.3，具体步骤如下： （1）首先，进入下面的网址，点击对应版本的cuda。cuda选择官网
（2）在终端中运行生成的两个指令，分别是下载和安装cuda。下载到99%时出现段错误（核心已转储）。参考：安装CUDA段错误（核心已转储）解决方案
（3）安装时注意有几处需要选择，第一处选择continue，第二处输入accept，第三处用空格取消driver，并选择install。这样选择防止再次安装其他版本的显卡驱动导致出问题。
（4）配置环境变量
sudu gedit ~/.bashrc 在后面加上
export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/local/cuda/lib64 export PATH=$PATH:/usr/local/cuda/bin export CUDA_HOME=$CUDA_HOME:/usr/local/cuda 保存之后，记得source一下
source ~/.bashrc 查看cuda是否安装成功
nvcc -V 3.环境配置 下面正式开始配环境啦。
（1）下载安装openmpi，我也不知道这个到底需不需要，安了没有副作用。 wget https://download.open-mpi.org/release/open-mpi/v4.1/openmpi-4.1.4.tar.gz 解压 cd openmpi-4.1.4 ./configure –prefix=/usr/local/openmpi make -j8 sudo make install ~/.bashrc文件里添加环境变量： MPI_HOME=/usr/local/openmpi OMPI_MCA_opal_cuda_support=true export PATH=${MPI_HOME}/bin:$PATH export LD_LIBRARY_PATH=${MPI_HOME}/lib:$LD_LIBRARY_PATH export MANPATH=${MPI_HOME}/share/man:$MANPATH 测试安装是否成功 cd openmpi-x.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/49f10405142b8d690f9a8dd90c44a07e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/afa14abfcb83941a1c84adceb71f1618/" rel="bookmark">
			详解Java锁对象
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、Synchronized 1.1、synchronized特性 1、互斥
synchronized会起到互斥效果，某个线程执行到某个对象的synchronized中时，其他线程如果也执行到同一个对象synchronized就会阻塞等待。
*进入synchronized修饰的代码块，就相当于加锁。
*退出synchronized修饰的代码块，就相当于解锁。
一个线程先上了锁，其他线程只能等待这个线程释放。可以理解为“阻塞等待”
注意：
*上一个线程解锁之后，下一个线程并不是立即就可以获取到锁，而是要靠操作系统来“唤醒”，这也就是操作系统线程调度的一部分。
*假设有A，B，C三个线程线程A先获取到锁，然后B尝试获取锁，然后C再尝试获取锁，此时B和C都在阻塞队列中等待，但是A释放锁之后，虽然B比C先来，但B不一定就能拿到锁，而是和C重新竞争。并部遵循先来后到的原则。
2、刷新内存
synchronized工作过程
(1)获得互斥锁
(2)从主内存拷贝变量的最新副本到工作内存
(3)执行代码
(4)将更改后的共享变量的值刷新到主内存
(5)释放互斥锁
所以synchronized可以保证内存可见性
3、可重入
synchronized同步块对同一条线程来说是可重入的，不会出现自己把自己锁死的现象。
锁死现象：
一个线程没有释放锁，然后又开始尝试获取锁
// 第一次加锁, 加锁成功
lock();
// 第二次加锁, 锁已经被占用, 阻塞等待.
lock();
java中的synchronized是可重入锁，所以不存在上述问题。
代码示例：
public class Exe_03 { private static int num=50000; public static void main(String[] args) throws InterruptedException { Counter04 counter1=new Counter04(); //创建线程完成自增 Thread thread1=new Thread(()-&gt;{ for (int i = 0; i &lt; num; i++) { //自增操作 counter1.increase(); } }); Thread thread2=new Thread(()-&gt;{ for (int i = 0; i &lt; num; i++) { //自增操作 counter1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/afa14abfcb83941a1c84adceb71f1618/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5efa617500b7faa1ec32fd513a02adfc/" rel="bookmark">
			python列表list常用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、
len([1, 2, 3])3长度[1, 2, 3] + [4, 5, 6][1, 2, 3, 4, 5, 6]组合3 in [1, 2, 3]True元素是否存在于列表中 2、
（1）list() 方法用于将元组转换为列表。
（2）append() 方法用于在列表末尾添加新的对象。
（3）extend() 函数用于在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表）。
注意两者的区别
（4）sort() 函数用于对原列表进行排序，如果指定参数，则使用比较函数指定的比较函数。
list.sort(cmp=None, key=None, reverse=False) cmp -- 可选参数, 如果指定了该参数会使用该参数的方法进行排序。key -- 主要是用来进行比较的元素，只有一个参数，具体的函数的参数就是取自于可迭代对象中，指定可迭代对象中的一个元素来进行排序。reverse -- 排序规则，reverse = True 降序， reverse = False 升序（默认）。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af7e3b7acae99ebfd0d0939e3fb908c5/" rel="bookmark">
			java运动会管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、项目介绍
1、主要功能介绍 二、分析与设计
三、问题与分析
四、小结
五、代码
一、项目介绍 1、主要功能介绍 对于管理者：
1、登录系统来发布运动会的项目以及对应项目的比赛规则
2、管理者也可以修改运动会比赛时间和地点，如果管理者需要修改比赛时间或者比赛地点，必须提前一天修改然后再重新发布。
对于用户：
1、 登录系统报名参加运动会的项目，报名志愿者，或者报名裁判。
2、 当用户报名参加运动会项目时，首先要先选择身份，如果是老师则进入老师参赛页面（老师与老师之间比赛），需要登记老师的学院、姓名、参赛项目以及给老师分配参赛号。
3、如果是学生则进入学生参赛页面（学生和学生之间比赛），需要登记学生的学院，专业、班级、姓名、性别、学号、参赛项目以及给学生分配参赛号，同时参赛者可以查看项目的相关信息以及自己的得分和排名。
4、当用户报名裁判时（仅限老师报名），将该用户的信息存入裁判信息文件中。当该用户登录系统之后，可以查阅项目相关信息，可以对选手进行打分（信息存入文件中）、判断选手是否违规、记录参赛选手的成绩（信息存入文件中），根据打分给出运动员的排名。
5、 当用户报名志愿者时，可以查阅项目相关信息。
二、分析与设计 三、问题与分析 1、参赛号分配问题（以学生参赛为例）：
参赛选手的信息录入到同一个文件中，当选手A报名一分钟跳绳比赛的时候，首先检索文件中已有的一分钟跳绳比赛参赛人数，其次为选手A分配参赛号，最后将选手A的个人基本信息和参赛号存入到文件中。
2、人数上限问题：
志愿者人数不超过20人，裁判人数不超过10人，当志愿者或者裁判人数超出系统设定的上限，则给出警告并且超出的部分的信息不再录入文件。
3、多次报名问题
当用户登录系统报名参加比赛时，则该用户将无法报名志愿者和裁判；或者用户报名了志愿者，则将无法报名参加比赛和裁判。
4、登录/注册异常问题：
当用户账号不存在时，系统给出“请先注册”提示；当用户输入的账号和密码不满足8位时，系统给出“填写出错”警告；当用户输入的密码错误时，系统给出“密码输入错误”警告。
5、选手违规记录问题：
当参赛选手在比赛过程中的违规次数达到上限的时候，则直接将该选手的参赛信息从文件中删除，也即是取消比赛资格。
6、裁判登录问题：
当用户A（账号已存在）报名裁判之后，用户A的信息也会被存入裁判信息的文件中，报名结束之后，当A再次登录该系统时，登录成功后系统直接跳转到裁判操作页面。
四、小结 此运动会管理系统相对来说比较的简陋，有些功能和问题还没来得及实现和更改，有需要的友友谨慎拿取！
五、代码 package Game; //问题1：参赛号分配问题 问题2：志愿者人数上限问题 问题3：裁判人数上限问题 //问题4：将所有参赛教职工的信息直接全部录入一个文件当中，读取的时候按照参赛项目进行读取 //问题5：例：当一个人报名志愿者的时候，需要检查这个人是否报了其它的项目（比如裁判） //问题6：当一个人已经报名成功裁判之后，应该有一个裁判登录界面，登陆之后可以直接给运动员们打分 import java.io.*; import java.util.Scanner; public class Game { public static void main(String[] args) throws IOException { Menu(); } public static void Menu() throws IOException {//管理员和用户身份选择 while(true) { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/af7e3b7acae99ebfd0d0939e3fb908c5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6a9363d3d290560bd9ad5e740f5bdbe/" rel="bookmark">
			SIFT算法简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考资料 SIFT文献-David-UBC： 《Distinctive Image Features from Scale-Invariant Keypoints》SIFT算法介绍： SIFT特征详解 - Brook_icv - 博客园 (cnblogs.com) 简介 Scale-invariant feature transform 尺度不变特征变换
SIFT算法不仅只有尺度不变性，当旋转图像，改变图像亮度，移动拍摄位置时，仍可得到较好的检测效果.
特点如下
具有较好的稳定性和不变形，能够适当旋转、尺度缩放、亮度的变化，能在一定程度上不受视角变化、仿射变换、噪声的干扰。区分性好，能够在海量特征数据库中进行快速准确的区分信息进行匹配多属性，就算只有单个物体，也能产生大量特征向量高速性，能够快速的进行特征向量匹配可扩展性，能够与其它形式的特征向量进行联合 主要流程
提取关键点：关键点是一些十分突出的不会因光照、尺度、旋转等因素而消失的点，比如角点、边缘点、暗区域的亮点以及亮区域的暗点。此步骤是搜索所有尺度空间上的图像位置。通过高斯微分函数来识别潜在的具有尺度和旋转不变的兴趣点。特征方向赋值 基于图像局部的梯度方向，分配给每个关键点位置一个或多个方向，后续的所有操作都是对于关键点的方向、尺度和位置进行变换，从而提供这些特征的不变性。特征点描述 在每个特征点周围的邻域内，在选定的尺度上测量图像的局部梯度，这些梯度被变换成一种表示，这种表示允许比较大的局部形状的变形和光照变换。（可选）特征点匹配 关键点提取采用的是图像金字塔，高斯模糊算法构建多分辨率图像，然后用高斯差分定位到极值点，剔除不好的特征点之后得到关键点。
效果如下
特征方向的确定采用的是如下公式，通过特征点的坐标（x,y)与L函数，取得梯度的模值（大小）和方向
然后根据特征方向进行加权得到关键点描述符
后续根据关键点描述符来进行图像匹配（可选），效果如下
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0399c5c3e4adb850b9cac034b1ed7c7c/" rel="bookmark">
			轻松应对SuperRare的Cloudflare验证，穿云API详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SuperRare作为知名的数字艺术品交易平台，采用了Cloudflare反爬虫机制来保护其网站安全。然而，对于一些需要进行数据采集和分析的用户来说，这种验证机制可能成为一道阻碍。在本文中，我们将介绍一种名为穿云API的工具，它可以帮助用户轻松应对SuperRare的Cloudflare验证，实现快速而高效的数据采集。
SuperRare是一个数字艺术品交易平台，许多用户都希望通过采集平台上的数据来进行市场研究、艺术品分析等任务。然而，SuperRare采用了Cloudflare验证机制来保护其网站免受恶意爬虫和攻击。这种验证机制会要求用户进行人机验证，如输入验证码、滑动拼图等，以确认其身份。对于大规模数据采集的用户来说，这种验证过程将变得非常繁琐且耗时。
幸运的是，有一种名为穿云API的工具可以帮助用户轻松应对SuperRare的Cloudflare验证，实现快速而高效的数据采集。穿云API提供了一套强大的功能，使用户能够绕过Cloudflare验证，自动化处理人机验证过程，并以高效的方式获取所需的数据。
首先，穿云API提供了智能请求控制功能，可以模拟用户行为并自动处理Cloudflare验证过程。它能够自动识别和解析验证码，完成滑动拼图等操作，从而绕过验证步骤。这样，用户无需手动干预，就能够快速获取所需的数据，节省了大量的时间和精力。
其次，穿云API支持设置浏览器指纹设备特征，包括Referer、浏览器UA和headless状态等。这些特征可以模拟真实用户的行为，使采集请求更具可信度，减少被识别为爬虫的风险。通过灵活设置这些参数，用户可以根据需要进行定制，提高数据采集的成功率和匿名性。
最后，穿云API还提供了对数据的灵活处理和返回。用户可以通过设定接口地址、请求参数等来获取所需的数据，并对返回结果进行处理和解析。这使得用户可以根据自己的需求，定制化地获取和处理SuperRare平台上的数据，从而更好地支持其后续分析和应用。
综上所述，穿云API为用户提供了一种轻松应对SuperRare的Cloudflare验证的解决方案。通过智能请求控制、浏览器指纹设备特征以及灵活的数据处理功能，用户能够快速、高效地绕过验证，获取所需的数据。这对于需要进行数据采集和分析的用户来说，极大地简化了操作流程，提升了工作效率。
使用穿云API，您可以轻松地绕过Cloudflare反爬虫的机器人验证，即使您需要发送10万个请求，也不必担心被识别为抓取者。
一个穿云API即可突破所有反Anti-bot机器人检查，轻松绕过Cloudflare验证、CAPTCHA验证，WAF，CC防护，并提供了HTTPAPI和Proxy，包括接口地址、请求参数、返回处理；以及设置Referer，浏览器UA和headless状态等各浏览器指纹设备特征。
本文来源于：轻松应对SuperRare的Cloudflare验证，穿云API详解 – 穿云API帮助教程
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27824aadd53cd704a4ffc5dc79dd9084/" rel="bookmark">
			IDEA配置本地Maven详细教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		IDEA配置本地Maven详细教程 一、下载二、安装三、配置环境变量四、IDEA配置Maven 一、下载 官网下载：点击下载
网盘下载：点击下载
二、安装 将下载后的zip文件（免安装版）解压到自己想要放的位置，，我这里放在D盘的software目录下。
注意：为了避免不必要的麻烦，路径不要设置中文和特殊字符。
打开maven文件夹下的conf文件夹，打开并编辑settings.xml
第一处修改，按照如下图所示操作，配置本地仓库路径（该仓库文件夹自己选择位置创建，因为默认仓库是在C盘，C盘空间不够就换到其他盘）
我把本地仓库文件夹放在E盘下
第二处修改：因为maven默认镜像实在国外，可能会出现无法下载或者下载速度慢的情况，能科学上网就另说。所以将镜像改为国内的。这里附上其他镜像源，点击跳转。
注意： Maven的settings.xml文件中可以配置多个镜像（mirror）。镜像的作用是提供一个替代的远程仓库地址，用于加快构建和依赖下载速度，特别是在访问官方远程仓库速度较慢或不稳定时。Maven会按照配置的顺序从上到下查找镜像，如果找到匹配的镜像，则使用该镜像进行下载。因此，将中央仓库镜像配置放在最后，确保在找不到其他镜像时才会使用中央仓库。
编辑完成后，保存即可。
三、配置环境变量 右键此电脑图标-属性-高级系统设置-环境变量
选中path，点击编辑
复制maven安装路径到bin文件夹，如下所示
将路径复制到如下图所示
连点三次确定
验证配置：win+r 输入cmd打开命令行，然后输入mvn -v，出现如下所示即为配置成功
四、IDEA配置Maven 打开IDEA，选择file-settings
打开后，搜索maven
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d90f6034e35ca9a27fc5ee55cc407cbd/" rel="bookmark">
			windows如果快速安装OpenSSL（懒人安装）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		​OpenSSL是一个功能丰富且自包含的开源安全工具箱，提供一系列的开发组件，提供出来的API可供使用。应用程序可以使用这个包来进行安全通信，避免窃听，同时确认另一端连接者的身份。这个包广泛被应用在互联网的网页服务器上。
1. Openssl环境安装
下载地址：Win32/Win64 OpenSSL Installer for Windows - Shining Light Productions
随便下载一个好了，反正都是exe的，建议还是下载和自己电脑匹配的。安装完成之后配置一下环境变量。把openssl安装路径bin的路径（例如 C:\OpenSSL-Win64\bin）加入到操作系统的系统环境变量Path中。
重启电脑（一定要重启哈，别偷懒，国外的软件大多都要重启电脑，这个我有血的教训）
用管理员身份运行DOS就可以进行openssl的操作了。
在命令中输入 openssl version ,验证是否安装成功，出现下图中的版本信息，表示自己安装成功了
2. windows命令行调用openssl：本地成RSA秘钥对(下命令)
openssl genrsa -out rsa_private_key.pem 1024
openssl pkcs8 -topk8 -inform PEM -in rsa_private_key.pem -outform PEM -nocrypt
openssl rsa -in rsa_private_key.pem -pubout -out rsa_public_key.pem
运行完成后在，在执行命令的目录：C:\Users\admin 路径下会生成一个RSA密钥对文件
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58d6726fd2c5c92b4eaf5426cf484801/" rel="bookmark">
			深入解析神经网络（Neural Networks）工作原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1. 神经网络的基本组成部分2. 神经元和激活函数3. 前向传播4. 反向传播5. 神经网络的层次结构6. 神经网络的应用7. 使用Python和TensorFlow库实现简单神经网络 神经网络（Neural Networks）是一种受到生物神经系统启发的人工智能模型，它在计算机科学和机器学习领域发挥着重要的作用。本文将深入解析神经网络的原理和工作原理，包括神经元、前向传播、反向传播以及网络层次结构的构建。 1. 神经网络的基本组成部分 神经网络由许多相互连接的神经元组成，它模拟了生物神经系统中的神经元。每个神经元接收来自其他神经元的输入，并通过激活函数产生输出。神经网络的结构可以分为输入层、隐藏层和输出层。输入层接收外部数据，隐藏层根据输入层的数据进行计算和传递，最后输出层生成最终的结果。
2. 神经元和激活函数 神经元是神经网络的基本单元，它接收来自其他神经元的输入，并通过激活函数产生输出。激活函数引入非线性特性，使得神经网络能够解决复杂的非线性问题。常见的激活函数包括Sigmoid、ReLU、Tanh等，在不同情况下具有不同的优势和适用性。
3. 前向传播 前向传播是神经网络中信息从输入层到输出层的传递过程。每个神经元接收来自前一层神经元的输出，并通过权重和偏置进行加权求和。然后，该值经过激活函数，得到该神经元的输出。这个过程逐层进行，直到输出层生成最终的结果。
4. 反向传播 反向传播是神经网络中的训练算法，用于调整神经元之间的权重和偏置，以使网络能够更好地拟合训练数据。通过计算损失函数的梯度，并将梯度从输出层向输入层传播，从而根据梯度下降算法更新权重和偏置。这个过程反复进行，直到网络的性能达到预期。
5. 神经网络的层次结构 神经网络的层次结构对于网络的性能和功能非常重要。常见的层次结构包括全连接层、卷积层和池化层。全连接层中的神经元与上一层的所有神经元都相连，卷积层用于处理图像等具有空间结构的数据，而池化层用于减小特征图的尺寸和参数数量。
6. 神经网络的应用 神经网络在许多领域都有广泛的应用。被用于图像分类、目标检测、语音识别、自然语言处理等任务。神经网络的强大的非线性建模能力使其能够解决复杂的模式识别和预测问题。
7. 使用Python和TensorFlow库实现简单神经网络 import tensorflow as tf # 构建神经网络模型 model = tf.keras.Sequential([ tf.keras.layers.Dense(64, activation='relu', input_shape=(input_size,)), tf.keras.layers.Dense(64, activation='relu'), tf.keras.layers.Dense(num_classes, activation='softmax') ]) # 编译模型 model.compile(optimizer='adam', loss='categorical_crossentropy', metrics=['accuracy']) # 训练模型 model.fit(x_train, y_train, epochs=10, batch_size=32, validation_data=(x_val, y_val)) # 测试模型 test_loss, test_acc = model.evaluate(x_test, y_test) print('Test accuracy:', test_acc) 代码中，使用TensorFlow库构建了一个简单的神经网络模型，包括输入层、隐藏层和输出层。通过编译模型并调用fit方法进行训练，得到训练好的模型。使用测试数据评估模型的性能。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80525267eeec6c91c6182ce2d5e574c7/" rel="bookmark">
			深入理解朴素贝叶斯（Naive Bayes）模型原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1. 贝叶斯定理2. 朴素贝叶斯算法原理3. 朴素贝叶斯算法的应用4. 朴素贝叶斯算法文本分类应用 朴素贝叶斯（Naive Bayes）是一种常用的分类算法，基于贝叶斯定理和特征条件独立性假设。该算法在自然语言处理、文本分类、垃圾邮件过滤等领域得到广泛应用。
1. 贝叶斯定理 贝叶斯定理是概率论中的一个重要定理，描述了在已知先验概率的情况下，如何根据新的观察结果来更新对事件的概率估计。对于两个事件 A 和 B，贝叶斯定理表示为：
P(A|B) = (P(B|A) * P(A)) / P(B) 其中，P(A|B) 表示在观察到事件 B 发生的条件下事件 A 发生的概率，P(B|A) 表示在事件 A 发生的条件下事件 B 发生的概率，P(A) 和 P(B) 分别表示事件 A 和事件 B 的先验概率。
2. 朴素贝叶斯算法原理 朴素贝叶斯算法基于贝叶斯定理，假设特征之间相互独立。这是一个较强的假设，因此算法被称为“朴素”。朴素贝叶斯算法通过计算给定特征条件下的类别概率，来预测新样本的类别。
具体来说，假设有一个数据集 D，包含 n 个样本 {x1, x2, …, xn}，每个样本包含 m 个特征 {f1, f2, …, fm} 和一个类别标签 {y}。朴素贝叶斯算法的目标是通过计算后验概率 P(y|f1, f2, …, fm) 来预测新样本的类别。根据贝叶斯定理，后验概率表示为：
P(y|f1, f2, ..., fm) = (P(f1, f2, .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/80525267eeec6c91c6182ce2d5e574c7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38192360cb2b8181f4753631dd4eaf9d/" rel="bookmark">
			SpringMVC超详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1 Spring MVC 介绍1.1 MVC模型1.2 Spring MVC 2 Spring MVC处理请求流程2.1 流程介绍2.2 组件介绍 3 SpringMVC的入门案例1. SpringMVC的入门程序1.1 WEB工程结构1.2 创建WEB工程，引入的依赖1.3 配置核心的控制器（配置DispatcherServlet）1.4 编写springmvc.xml的配置文件1.5 编写index.jsp和Controller控制器类1.6 在WEB-INF目录下创建pages文件夹，编写success.jsp的成功页面1.7 Tomcat配置1.8 启动Tomcat1.9 入门案例的执行过程分析 4 请求参数的绑定4.1 请求参数的绑定说明4.1.1 绑定机制4.1.2 支持的数据类型 4.2 基本数据类型和String类型4.3 POJO类型（JavaBean）4.4 集合类型4.5 请求参数中文乱码的解决4.6 自定义类型转换器4.6.1 自定义类型转换器4.6.2 注册自定义类型转换器，在springmvc.xml配置文件中编写配置4.6.3 param.jsp4.6.4 Controller类 4.7 控制器使用原生的ServletAPI对象 5 常用注解5.1 RequestParam注解5.2 RequestBody注解5.3 PathVariable注解5.4 RequestHeader注解5.5 CookieValue注解5.6 ModelAttribute注解5.6.1 出现在方法上5.6.2 基于 Map 的应用场景示例：ModelAttribute 修饰方法带返回值5.6.3 基于 Map 的应用场景示例 ：ModelAttribute 修饰方法不带返回值 5.7 SessionAttributes注解 6 响应数据和结果视图6.1 返回值分类6.1.1 返回字符串6.1.2 返回值是void6.1.3 返回值是ModelAndView对象 6.2 SpringMVC框架提供的转发和重定向6.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/38192360cb2b8181f4753631dd4eaf9d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b00184e4db1715f7039c527984ccd059/" rel="bookmark">
			SQL注入原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 靶场平台 SQL注入靶场平台使用的是sqli。它是一个针对SQL注入的专项联系平台。搭建和安装比较简单，可以自习查询相关教程。
2. SQL注入概括 SQL注入原理：
SQL注入就是指Web应用程序对用户输入数据的合法性没有做校验或校验被绕过，导致前端传入后端的参数是攻击者可控的，并且参数带入数据库查询，攻击者可以通过构造不同的 SQL 语句来实现对数据库的任意操作。
必要条件：1.带入执行的参数能够可控。2.拼接的SQL语句能够带入数据库中，并执行。SQL注入类型：
分为字符型和数字型，判断方式有多种，比如可以利用数字型的方式下对传入的算术表达式进行计算的特征进行判断，比如传递参数?id=1和?id=2-1如果返回的是同一个页面信息，则判断为数字型，否则为字符型。当然也可以用单引号（‘）等特殊字符的方式去判断。如何寻找注入点
对于常规的sql注入一般都是在判断为注入类型后，尝试去寻找注入点，寻找注入点可以采用参数后跟特殊字符，比如：单引号（‘）、双引号（“）、小括号、单引号+括号、双引号+括号等方式，通过给出的回显错误信息反推该SQL查询语句的闭合标识。然后通过拼接order by语句判断字段数，完成sql注入。SQL注入的利用手法：
SQL注入的方式有很多种，比如常见的联合查询sql注入，报错sql注入，布尔盲注、延时注入等手法。对于有错误回显特征页面的可以首先采取联合查询sql注入，如果这个手法失效即考虑报错sql注入。
对于没有错误回显特征的页面考虑使用布尔盲注和延时注入等方式。sql注入想要获取服务器的webshell需要哪些条件？
首要条件是服务器得有写入的操作权限；其次是找到服务器搭载网页服务根目录的绝对路径，它决定了上传的shell脚本将落地在哪里；再者mysq.ini配置文件中得有secure-file-priv=语句存在。 3.靶场实操 第一关 首先判断注入类型，当输入?id=1传入参数时正常显示第一个页面。
而当输入?id=3-2的时候，显示的是第3个页面，这说明它没有进行算术运算，所以他应该是以字符串的形式接受的参数，所以基本判断为字符型注入。当然也可以通过特殊字符的方式判断。
判断注入点：当传入参数为?id=1’时报错，并且给出了报错的位置，而传入参数?id=1则正常，这可能是由于输入的1'与前面的定义好的'完成了闭合，说白了就是它俩成了一对，而导致1后面的`'``成了多余而报错，所以基本判断 这个单引号就是他的注入点，也就是说能让他完成闭合，从而实现能拼接其他语句执行的条件。
尝试闭合，拼接语句查询有列字段。
?id=1’ order by 3 与 ?id=1’ order by 4
当?id=1’ order by 4 的时候报错，所以判断有3个字段。
知道了字段数，下面用联合查询的方式就可以获取数据库的名称等信息。
取非法值让前面的查询语句不显示而显示后面联合查询的语句。
可以判断出他的回显位位2，3这连个位置，所以可以在这两个位置上利用SQL注入的漏洞回显想要的信息。
database（）是数据库内置的函数，用于获取当前数据库的名称。
知道了数据库名称，即可查询该数据库中存在的数据表信息。
?id=15' union select 1,2,group_concat(table_name) from information_schema.tables --+
这里说明一下，group—concat()函数是一个聚合函数他的作用就是将指定列的所有行合并成一个字符串，并用指定的分隔符拼接起来。我们在这查询的是所有的表名。这里注意到一个information_schema.tables这是一个内置库，它里面有很多的表，这些不同的表存放着不同的信息，比如有存放所有表名的tables表，有存放所有字段名的columns表等等。这里查询的是该库下的tables表，后面的 --+这是注释符，为了防止后面的语句对执行的效果造成影响。后面几关涉及到的与这里描述基本一致，所以后续不赘述。
查询user表中的字段信息
?id=15' union select 1,2,group_concat(column_name) from information_schema.columns where table_name="users" --+
第二关 首先判断注入类型，当输入?id=1时正常显示第一个页面。
当输入?id=3-2的时候，显示的也是第1个页面，这说明它对传入的参数进行算术运算，所以基本判断为数字型注入。
判断注入点
因为这一关是一个简单的数字型注入，所以当你输入一个数字的时候，他就接受了这数字并闭合了，这样就可以拼接其他的SQL语句了。判断字段数，查询数据信息。
输入?id=1 order by 3 与 ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b00184e4db1715f7039c527984ccd059/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/343f2b1150e145fa01a25bcf9b2de0c3/" rel="bookmark">
			Python代码示例，可以生成烟花表演效果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		个简单的Python代码示例，可以生成烟花表演效果。您可以根据自己的喜好和需要来修改参数，以获得所需的效果。
import random import time from turtle import * # 设置画布大小和背景颜色 setup(800, 600) bgcolor('black') # 烟花属性设置：数量、大小、速度等 num_sparks = 50 min_size = 10 max_size = 30 speed = 3 def create_spark(x, y): """创建一个烟花""" penup() goto(x, y) pendown() # 随机选择颜色并开始绘制烟花爆炸效果 spark_color = random.choice(['red', 'green', 'blue', 'orange', 'purple']) color(spark_color) size = random.randint(min_size, max_size) # 绘制圆形火球（即爆炸中心） circle(size) # 根据设定值绘制多个火星（即爆炸后散落开来的小点） for i in range(num_sparks): setheading(random.randint(0,360)) forward(random.randint(size,size*2)) hideturtle() while True: # 在屏幕上随机生成位置，并在该位置创建新的“firework”（即一朵新的烟花） x_pos=random.randint(-400,400) y_pos=random.randint(-300,-100) create_spark(x_pos, y_pos) # 等待一段时间后清除画布并重新开始 time.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/343f2b1150e145fa01a25bcf9b2de0c3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05d32ad09d8d49ab61aaf17b79ca4b2d/" rel="bookmark">
			模板文件导出Excel【EasyPoi实战系列】- 第478篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		​历史文章（文章累计470+）
《国内最全的Spring Boot系列之一》
《国内最全的Spring Boot系列之二》
《国内最全的Spring Boot系列之三》
《国内最全的Spring Boot系列之四》
《国内最全的Spring Boot系列之五》
《国内最全的Spring Boot系列之六》
【EasyPoi实战系列】Spring Boot使用EasyPoi动态控制导出的列 - 第471篇
100万数据导出，居然爆炸了OutOfMemoryError？【EasyPoi实战系列】- 第472篇
导出下拉列表的两种小技巧【EasyPoi实战系列】- 第473篇
数据脱敏/换行/枚举的处理【EasyPoi实战系列】- 第474篇
悟纤：师傅，我发现一个挺麻烦的问题。
师傅：怎么说？
悟纤：就是这个很多时候，这个Excel的样式是很复杂的，用代码生成Excel的方式对于处理比较复杂的样式，就有点爱莫能助。
师傅：这个时候，使用模板导出的方式就很有必要了，定义好一个模板，然后使用类似el表达的方式指定单元格的位置，这样样式就可以在模板文件进行编辑了。
悟纤：如果可以这么实现真的是再好不过了，师傅我已经按耐不住了，赶紧带我飞。
师傅：扶好把手，准备启程。
导读
Hi，大家好，我是悟纤。
我就是我，不一样的烟火。我就是我，与众不同的小苹果。
模板是处理复杂Excel的简单方法，复杂的Excel样式，可以用Excel直接编辑，完美的避开了代码编写样式的雷区，同时指令的支持，也提了模板的有效性。
说明：本节的例子的导出实体类是基于前面的章节的实体类进行使用的，所以看的有点蒙圈的小伙伴可以查看前面的文章：
👇🏻👇🏻👇🏻EasyPoi实战系列：
01.《【EasyPoi实战系列】Spring Boot集成EasyPoi - 第467篇》
02.《【EasyPoi实战系列】Spring Boot使用EasyPoi的注解让表格更漂亮以及图片的导出 - 第468篇》
03.《【EasyPoi实战系列】Spring Boot使用EasyPoi实现一对多的导出 - 第469篇》
04.《【EasyPoi实战系列】Spring Boot使用EasyPoi实现多Sheet导出 - 第470篇》
05.《【EasyPoi实战系列】Spring Boot使用EasyPoi动态控制导出的列 - 第471篇》
06.《100万数据导出，居然爆炸了OutOfMemoryError？【EasyPoi实战系列】- 第472篇》
07.《导出下拉列表的两种小技巧【EasyPoi实战系列】- 第473篇》
08.《数据脱敏/换行/枚举的处理【EasyPoi实战系列】- 第474篇》
一、EasyPoi支持的指令
EasyPoi支持的指令以及作用，最主要的就是各种fe的用法：
· 空格分割
· 三目运算 {{test ? obj:obj2}}
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/05d32ad09d8d49ab61aaf17b79ca4b2d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b95a5bcff6393d99c713fa9ad2d47a95/" rel="bookmark">
			图片转为ASCII字符画的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 概述实现方法操作示例 概述 字符画是一系列字符的组合，我们可以把字符看作是比较大块的像素，一个字符能表现一种颜色（暂且这么理解吧），字符的种类越多，可以表现的颜色也越多，图片也会更有层次感。
问题来了，我们是要转换一张彩色的图片，这么多的颜色，要怎么对应到单色的字符画上去？这里就要介绍灰度值的概念了。
灰度值：指黑白图像中点的颜色深度，范围一般从0到255，白色为255，黑色为0，故黑白图片也称灰度图像
我们可以使用灰度值公式将像素的 RGB 值映射到灰度值：
gray ＝ 0.2126 * r + 0.7152 * g + 0.0722 * b 实现方法 from PIL import Image import argparse # 命令行输入参数处理 parser = argparse.ArgumentParser() # 输入文件， 输出文件， 输出字符画宽， 输出字符画高 parser.add_argument('file') parser.add_argument('-o', '--output') # 不同尺寸的图片转ASCII时，需要根据实际情况调整默认宽与高 parser.add_argument('--width', type=int, default=150) parser.add_argument('--height', type=int, default=80) # 获取参数 args = parser.parse_args() IMG = args.file WIDTH = args.width HEIGHT = args.height OUTPUT = args.output ascii_char = list("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b95a5bcff6393d99c713fa9ad2d47a95/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce767b0afe85fc0b624d57db71d843e2/" rel="bookmark">
			算法篇——动态规划 01背包问题 (js版)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		416. 分割等和子集
给你一个 只包含正整数 的 非空 数组 nums 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。
链接：力扣
解题思路：
这道题看似是比较简单的背包问题：
首先可以通过判断数组和是否是偶数，因为如果是奇数是必然不可能拆分成两个数组的，直接返回false；
if(nums.length == 1) return false var sum = 0 // 数组求和 for(var i = 0; i &lt; nums.length; i++) { sum += nums[i] } // 如果相加不是偶数说明不可能拆成相等的两个数组 if(sum % 2 != 0) return false 接着获取sum / 2，也就是target，我们利用一个新的方法：getSum，对元素和它的索引指针进行遍历
// 目标值是当前和的一半 var target = sum / 2 // map 用来遍历元素，可记录元素状态，相比循环更快，防止超时 const map = new Map() 这里也是有两个临界判断的：指针是否会越界，数组中的数据项之和是否会超出 target，否则就是可以拆分的
// 越界 if(i == nums.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ce767b0afe85fc0b624d57db71d843e2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b064bbfeb5ba85683ae3d11a9e58612/" rel="bookmark">
			电脑常用软件，让你的电脑更加便捷的黑科技软件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果安装了以下插件会让你的电脑瞬间变得高逼格，而且会加速你的办公效率
1.仿mac
RocketDock：仿mac笔记本桌面效果，瞬间让你的桌面变的非常简洁，软件的强大我就不在这里介绍了，大家可以上网搜索下载
官方下载地址：Punk Labs
漂亮的桌面使我们的开始的第一步
2.rainmeter
一款非常强大的系统美化工具，能够自定义桌面上的任何内容
官方下载地址：Rainmeter, desktop customization tool
2.Windows资源管理器
Clover ：Windows Explorer 资源管理器的一个扩展，为其增加类似谷歌 Chrome 浏览器的多标签页功能。
官方下载地址：POS System &amp; Credit Card Readers | Clover
windows系统当我们打开本地资源管理时，底部会不停地出现一个图标，有了下边这个神奇，就可以和网页标签页一样来管理本地资源管理了
3.桌面动态壁纸
啊噗啊噗upupoo：定制你的专属动态壁纸，同时还支持桌面整理和底部状态栏透明
官方下载地址：http://www.upupoo.com/动态壁纸-动态壁纸桌面-动态壁纸软件-阿噗阿噗UPUPOO官网
4. 浏览器
谷歌浏览器：因为它可以安装很多好用的插件，所以推荐大家使用，下边都是谷歌浏览器的插件
①标签工具
infinity：基于过去对新标签页的认识，重新定义了新标签页，一个追求极简美学和一站式服务体验。新一代的标签页，一个更好用，更强大的新标签页。
官方下载地址：Infinity新标签页
②滴答清单
③购物党全网比价工具
④右键搜
⑤adblockplus
5.桌面便签：小黄条
6.桌面日历
还在为担心工作中忘记做某些任务吗，这个桌面日历能够提供给你更好的记录，方便快捷，极力推荐
官方下载地址：桌面日历
7.quicker
是一款帮助用户提高对手机使用效率的软件，它可以快速组合各个厂商APP的常用功能，无需单个查找，在需要使用时，一键直达。同时，各种命令可以根据不同的需求，进行自由组合。
官方下载地址：Quicker软件 您的指尖工具箱 - Quicker
8.utools
自由集成丰富插件，快速匹配「场景功能」，用完即走
官方下载地址：uTools官网 - 新一代效率工具平台
9.笔记软件Wolai
官网下载地址：我来 wolai - 不仅仅是未来的云端协作平台与个人笔记
http://www.upupoo.com/http://www.upupoo.com/http://www.upupoo.com/http://www.upupoo.com/http://www.upupoo.com/http://www.upupoo.com/http://www.upupoo.com/http://www.upupoo.com/http://www.upupoo.com/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e1ff34de95c52f66fc0e9fb45e265c4/" rel="bookmark">
			MyBatis 的使用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		观前提示:本篇博客演示使用的 IDEA 版本为2021.3.3版本,使用的是Java8(又名jdk1.8)
前端使用 VSCode(Visual Studio Code1.78.2)
电脑使用的操作系统版本为 Windows 10
目录
Mybatis是什么?
Mybatis 有什么用?
Mybatis 框架交流
Mybatis 项目环境搭建
1. 添加 Mybatis 框架支持
2.设置 Mybatis 配置信息
2.1 建立数据库
2.2 设置数据库连接的相关信息以及 MyBatis 的 xml 保存路径和 xml 命名模式
Mybatis 模式开发
后端开发思路
添加实体类
添加 Mapper 接口
添加 Mapper.xml
添加 Service
添加 Controller
启动项目
单元测试
进入单元测试
Mybatis 动态获取参数
参数占位符 #{} 和 ${}
# 和 $ 的区别
SQL 注入 $ 优点
改、删、增操作
1. 修改密码
2. 删除用户操作
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8e1ff34de95c52f66fc0e9fb45e265c4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c90c9958dd0805e4f51908ad3567d3d/" rel="bookmark">
			学习笔记--模拟退火
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		**模拟退火（Simulated Annealing）**是一种随机搜索算法，用于求解优化问题，特别是组合优化问题。它的名字和灵感来源于物理学中的退火过程，即将物质加热到高温，然后逐渐冷却，以达到低能量状态。
模拟退火算法的工作原理如下：
初始化：选择一个初始解和一个较高的初始“温度”。
迭代搜索：在每次迭代中，根据一定规则生成一个新的解。
接受准则：比较新解和当前解的优劣。如果新解更优，那么通常会接受它。如果新解较差，根据一个概率准则（通常基于Metropolis准则）决定是否接受。这个概率与当前的“温度”和解的优劣差有关。
降温：随着迭代的进行，逐渐降低“温度”，这导致接受较差解的概率下降。
终止：当“温度”降到一个设定的阈值以下，或者达到预定的迭代次数时，算法终止。
模拟退火算法的关键在于它允许在搜索过程中暂时接受较差的解，这有助于跳出局部最优，从而有可能找到全局最优解。同时，通过逐渐降低“温度”，算法逐渐聚焦于搜索空间中的高质量区域。
###在模拟退火中，Metropolis准则如下：
如果新生成的解比当前解更好（即，目标函数值更低），那么总是接受这个新解。
如果新生成的解比当前解更差，那么以一定的概率接受这个新解。这个概率是基于目标函数值的差异和当前的“温度”计算的，具体为 exp(-(新解的目标函数值 - 当前解的目标函数值) / 当前温度)。
接受更差的解的能力是模拟退火算法的一个关键特性，它允许算法有可能跳出局部最优解，并在搜索空间中更广泛地搜索。然而，随着“温度”的降低，接受更差解的概率也逐渐降低，使算法更加倾向于在潜在的最优区域内进行搜索。
还是那个例题。
假设我们要优化函数 f(x) = x^2，在范围 [-10, 10] 内找到使得函数取得最小值的 x。
import math import random # 目标函数 def f(x): return x**2 # 模拟退火算法 def simulated_annealing(): # 参数设置 x = random.uniform(-10, 10) # 初始解 T = 1000 # 初始温度 T_min = 0.01 # 最小温度 alpha = 0.95 # 降温系数 # 主循环 while T &gt; T_min: # 生成新的解 x_new = x + random.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6c90c9958dd0805e4f51908ad3567d3d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba8c0efb534a7fabb8aa3539558753aa/" rel="bookmark">
			前端vscode常用插件（你值得拥有）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		规范JavaScript注释-腾讯云开发者社区-腾讯云 ES7 React/Redux/Styled-components snippets 快速生成react代码片段
AppWorks 包含代码注释，代码重构，等等
Auto Rename Tag 标签自动不全插件
Chinese (Simplified) 中文翻译插件，英语不好的同学下载
Code Runner 代码运行插件
Code Spell Checker 名称命名规范插件
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36f23327e53515ad7b9c5f95989cd4b0/" rel="bookmark">
			docker安装Java运行环境执行宿主机的python脚本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Docker 安装JDK1.8 docker pull openjdk:8-jdk docker run \ -d -it \ -v /root/python/myapp:/myapp \ --name="java8" \ openjdk:8-jdk -d: 后台运行容器，并返回容器ID；-i: 以交互模式运行容器，-t: 为容器重新分配一个伪输入终端；-v:绑定一个卷，让容器能够访问宿主机目录
选择这个镜像是因为这个镜像中自带了python3的环境，既能执行Java代码又能执行python脚本，还是挺方便的。 .py文件 提前准备.py文件放到docker能访问的目录 /root/python/myapp 下
容器内执行 [root@node-1 ~]# docker exec -it java8 /bin/bash root@3ed715dabe03:/# cd /myapp root@3ed715dabe03:/myapp# python3 helloworld.py Hello, World! 启动Java容器直接执行文件 [root@node-1 ~]# docker run \ -v /root/python/myapp:/myapp \ -w /myapp \ --name="java8" \ openjdk:8-jdk \ python3 helloworld.py Hello, World! -w /myapp: 指定容器的 /myapp 目录为工作目录。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd99e85f0d057290b166089d6905dd67/" rel="bookmark">
			Linux设置固定IP
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		编辑网卡配置文件：
（1）进入网卡配置文件所在路径：cd /etc/sysconfig/network-scripts/
（2）使用vi或vim编辑网卡配置文件（代码部分为最初配置，图是设置固定IP后的样子），
TYPE=Ethernet #网络类型，以太网 PROXY_METHOD=none #代理方式：关闭 BROWSER_ONLY=no #只是浏览器：否 BOOTPROTO=dhcp #网卡配置方式：dhcp（自动获取IP），static（设置固定IP，需要添加固定IP参数） DEFROUTE=yes #默认路由：开启 IPV4_FAILURE_FATAL=no #IPV4致命错误检测：不开启 IPV6INIT=yes #自动初始化IPV6：是 IPV6_AUTOCONF=yes #自动配置IPV6：是 IPV6_DEFROUTE=yes #IPV6默认路由：不开启 IPV6_FAILURE_FATAL=no #IPV6致命错误检测：不开启 IPV6_ADDR_GEN_MODE=stable-privacy #IPV6生成“stable-privacy”的模型 NAME=ens33 #网卡别名 UUID=ed92ff4a-6028-4be8-b96d-cf932f31628e #唯一标识码 DEVICE=ens33 #网卡设备名称 ONBOOT=no #网卡设置开机自启（no不自启，yes自启动） 将BOOTPROTO=dhcp改为BOOTPROTO=static
将ONBOOT=no改为ONBOOT=yes
添加固定IP网络配置参数（IP、网关、子网掩码、DNS地址根据实际情况设置）
IPADDR=192.168.20.20
NETMASK=255.255.255.0
GATEWAY=192.168.20.1
DNS1=8.8.8.8
（3）退出网卡编辑页面后，用systemctl restart network或service network restart命令重启网卡。
（4）检查固定IP是否设置成功，使用ip a和ping命令测试
固定IP修改成功 网络连通正常
上述两种情况都正常则表明固定IP设置成功。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f37ca65d28222fc487d14e6342819fe7/" rel="bookmark">
			java虚拟机可以创建多少对象
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 堆空间大小：JVM 的堆空间是用于存储对象的主要内存区域。堆的大小通过 -Xmx 和其他相关参数来配置。如果堆空间足够大，JVM 可以创建更多的对象。（java堆是java运行时内存最重要的部分，几乎所有的对象和数组都是在堆内存中分配空间。java堆分为新生代和老年代。新生代主要存储刚刚产生的对象，如果对象的生命足够长，就把老年对象移入老年代。
新生大分为三级：eden(刚出生)、survivor space0(幸存者0)、survivor space1(幸存者1)。）
可用内存：除了堆空间之外，JVM 还需要使用一些额外的内存来管理对象和运行时数据。可用内存的大小受操作系统和系统配置的限制。如果系统的可用内存较小，JVM 可以创建的对象数量可能受限。
垃圾回收机制：Java 中的垃圾回收机制负责释放不再使用的对象占用的内存。垃圾回收机制的性能和效率会影响 JVM 可以创建的对象数量。如果垃圾回收机制效率低下或频繁触发，可能会导致对象创建速度减慢。
对象大小：每个对象占用的内存空间取决于其字段和对齐方式。较大的对象会占用更多的内存空间。因此，可以创建的对象数量也受到单个对象大小的限制。（）
堆分配参数总结： －Xms：设置java应用程序启动时的初始堆大小 －Xmx：设置java应用程序能获得的最大堆大小 －Xss：设置线程栈的大小 －XX:MinHeapFreeRatio:设置堆空间的最小空间比例。当堆空间的空闲内存小于这个数值时，jvm便会扩展堆空间。 －XX:MaxHeapFreeRatio:设置堆空间的最大空间比例。当堆空间的空闲内存大于这个数值时，jvm便会缩小堆空间。 XX：NewSize : 设置新生代的大小 XX:NewRatio:设置老年代与新生代的比例，即老年代除以新生代大小 XX:SurviorRatio:新生代中eden区与survivior 区的比例 －XX：PermSize:设置永久区的大小 －XX：TargetSurvivorRatio:设置survivior 的使用率。当达到这个空间使用率时，会将对象送入老年代。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a68ada8a7021619b2c08d1d2cb3a312b/" rel="bookmark">
			文本匹配模型实验报告-text2vec
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文本匹配模型实验报告-text2vec 尽管基于BERT的模型在NLP诸多下游任务中取得了成功，直接从BERT导出的句向量表示往往被约束在一个很小的区域内，表现出很高的相似度，因而难以直接用于文本语义匹配。为解决BERT原生句子表示这种“坍缩”现象，Su[21]提出了一种排序Loss的句向量表示模型——CoSENT，
通过在目标领域的监督语料上Fine-tune，使模型生成的句子表示与下游任务的数据分布更加适配。
在句子语义匹配（STS）任务的实验结果显示，同等设置下CoSENT相比此前的Sentence-BERT大幅提升了5%。
1. 背景 句向量表示学习在自然语言处理（NLP）领域占据重要地位，许多NLP任务的成功离不开训练优质的句子表示向量。特别是在文本语义匹配（Semantic Textual Similarity）、文本向量检索（Dense Text Retrieval）等任务上，
模型通过计算两个句子编码后的Embedding在表示空间的相似度来衡量这两个句子语义上的相关程度，从而决定其匹配分数。
尽管基于BERT的模型在诸多NLP任务上取得了不错的性能（通过有监督的Fine-tune），但其自身导出的句向量（不经过Fine-tune，对所有词向量求平均）质量较低，甚至比不上Glove的结果，因而难以反映出两个句子的语义相似度[1][2][3][4]。
我们在研究的过程中进一步分析了BERT导出的句向量所具有的特性，证实了以下两点：
BERT对所有的句子都倾向于编码到一个较小的空间区域内，这使得大多数的句子对都具有较高的相似度分数，即使是那些语义上完全无关的句子对（如下图所示），我们将此称为BERT句子表示的“坍缩（Collapse）”现象。 左：BERT表示空间的坍缩问题（横坐标是人工标注的相似度分数，纵坐标是模型预测的余弦相似度）；右：经过CoSENT方法Fine-tune之后
BERT句向量表示的坍缩和句子中的高频词有关。具体来说，当通过平均词向量的方式计算句向量时，那些高频词的词向量将会主导句向量，使之难以体现其原本的语义。当计算句向量时去除若干高频词时，坍缩现象可以在一定程度上得到缓解（如下图蓝色曲线所示）。 计算句向量时移除Top-K高频词后的性能变化
学习句向量的方案大致上可以分为无监督和有监督两大类，其中有监督句向量比较主流的方案是Facebook提出的InferSent，
而后的Sentence-BERT进一步在BERT上肯定了它的有效性。然而，不管是InferSent还是Sentence-BERT，它们都存在训练和预测不一致的问题，而如果直接优化预测目标cos值，效果往往特别差。
为了解决句向量方案这种训练与预测不一致的问题，分析了直接优化cos值无效的原因，并参考SimCSE的监督方法，分析了CoSENT的rank loss，该loss可以直接优化两个文本比较的cos值。实验显示，CoSENT在第一轮的收敛效果比Sentence-BERT高35%，最终效果上比Sentence-BERT高5%。
2. 研究现状和相关工作 2.1 句子表征学习 句子表征学习是一个很经典的任务，分为以下三类方法：
有监督的句子表征学习方法：早期的工作[5]发现自然语言推理（Natural Language Inference，NLI）任务对语义匹配任务有较大的帮助，训练过程常常融合了两个NLI的数据集SNLI和MNLI，文本表征使用BiLSTM编码器。InferSent模型用了siamese结构，两个句子共用一个encoder，分别得到u和v的文本向量表达，然后用3种计算方式，向量拼接([u,v])，相乘(u * v)，相减(|u-v|)(为了保证对称性取绝对值），来帮助后面的全连接层提取向量间的交互信息，最后跟一个3分类的分类器。Sentence-BERT[1]借鉴了InferSent的框架，只是encoder部分替换成了BERT模型。自监督的Sentence-level预训练：有监督数据标注成本高，研究者们开始寻找无监督的训练方式。BERT提出了NSP的任务，可以算作是一种自监督的句子级预训练目标。尽管之后的工作指出NSP相比于MLM其实没有太大帮助。Cross-Thought[7]、CMLM[8]是两种思想类似的预训练目标，他们把一段文章切成多个短句，然后通过相邻句子的编码去恢复当前句子中被Mask的Token。相比于MLM，额外添加了上下文其他句子的编码对Token恢复的帮助，因此更适合句子级别的训练。SLM[9]通过将原本连贯的若干个短句打乱顺序（通过改变Position Id实现），然后通过预测正确的句子顺序进行自监督预训练。无监督的句子表示迁移：预训练模型现已被普遍使用，然而BERT的NSP任务得到的表示表现更不好，大多数同学也没有资源去进行自监督预训练，因此将预训练模型的表示迁移到任务才是更有效的方式。BERT-flow[2]：CMU&amp;字节AI Lab的工作，通过在BERT之上学习一个可逆的Flow变换，可以将BERT表示空间映射到规范化的标准高斯空间，然后在高斯空间进行相似度匹配。BERT-whitening[10]：苏剑林提出对BERT表征进行白化操作（均值变为0，协方差变为单位矩阵）就能在STS上达到媲美BERT-flow的效果。SimCSE[11]：陈丹琦组在2021年4月份公开的工作，他们同样使用基于对比学习的训练框架，使用Dropout的数据增强方法，在维基百科语料上Fine-tune BERT。 2.2 Sentence-BERT模型 当前有监督的句子表征模型Sentence-BERT，表现出在句向量表示和文本匹配任务上SOTA的效果，证明了其有效性。Sentence-BERT的训练过程是把（u, v, |u - v|）拼接起来后接分类层，而预测过程，是跟普通的句向量模型一样，先计算mean pooling后的句向量，然后拿向量算cos得到相似度值。
Sentence-BERT的训练：
Sentence-BERT的预测：
Sentence-BERT模型为啥有效？ 我们根据消融实验分析：
|u - v|的作用，匹配数据集中，正样本对的文本相似度是远大于负样本对的，对于初始的BERT模型，其正样本对|u - v|差值也是小于负样本对|u - v|差值，可以看出正样本对的u - v分布是一个半径较小的球面附近，
而负样本对的u - v分布在一个较大的球面附近，也就是说，初始模型的u - v本身就有聚类倾向，我们只需要强化这种聚类倾向，使正样本对的u - v更小，负样本对的u - v更大。
BERT-flow和BERT-whitening这类BERT后处理模型，就是用无监督方法强化这种聚类倾向的方法。而监督方法的直接做法是u - v后面接一个全连接层的分类器，但交叉熵的分类器是基于内积计算的，它没法区分两个分布在不同球面的类别，所以这里加上绝对值变成|u - v|，将球面变成锥形，此时就可以用分类器来做分类了。u, v拼接的作用，从BERT-flow的工作可以知道，BERT句向量具备具备丰富的语义信息，但是句向量所在空间受到词频的影响，具备非平滑，各向异性的特点，这种特点导致未经过微调的“BERT+CLS”句向量模型直接应用在语义相似计算任务上的效果甚至不如简单的GloVe句向量，
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a68ada8a7021619b2c08d1d2cb3a312b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8327b534c9e7e2df4099a4196a442343/" rel="bookmark">
			postman｜接口测试 ｜ pre-request script 场景应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		pre-request script 介绍 在过往的工作中，遇到很多测试小伙伴使用 postman 的时候都是直接通过 api 文档的描述请求，检查返回的数据是否正常，很少会用到 pre-request Script 这个功能，甚至也有不少开发的小伙伴也是很少用到这个功能。这个功能类似于 python unittest 里面的 setup 或者是 pytest 里面的 conftest 文件，在执行测试前先执行的函数。
pre-request script 应用 pre-request script 是 postman 执行前的前置条件功能。它能够做到 request 请求前的工作。包括：
对登录验证进行加密或解密
切换环境变量
获取上一个接口的响应值并进行更新
以上都是可以在 pre-request script 功能做的。
postman 执行顺序 首先来讲一下，postman 的执行顺序，其实这个只看一张图就够了。
从 postman 的介绍中，可以知道 postman 执行的顺序会先去到 pre-request script 检查是否有需要执行的前置条件。
pre-request script 场景实践 场景一 : 登录验证加密 现在有一个我们项目中，登录接口是通过 user token 登录的。前端页面需要填写 username 以及 password，再通过 js 进行 MD5 加密处理，最后请求接口验证返回登录状态。
api : /api/login method : post headers : token: user_token Content-Type: application/json 生成 user_token 方式： username&amp;psaaword 大写
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8327b534c9e7e2df4099a4196a442343/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02b6c0e7d9a2db9db55848fe281a1890/" rel="bookmark">
			02、自动化运维工具有很多种，下面介绍几种比较流行的、并且有代表性的工具，和它们之间的对比
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		自动化运维工具有很多种，下面介绍几种比较流行的、并且有代表性的工具，和它们之间的对比。
Puppet
Puppet是自动化配置工具，使用它可以自动化部署和配置各种软件和服务，还能确保它们在运行时保持一致。它包含Puppet Master和Puppet Agent两部分，Puppet Master负责配置、编译和管理所有的配置信息，而Puppet Agent则根据Master的指令自动执行部署工作。
优点：
对于大规模部署，它可以处理数百或数千个服务器。
Puppet拥有很好的扩展性，支持自定义的功能模块。
Puppet使用了Ruby语言，开发者对Protobuf、JSON及自定义二进制文件的解析很熟悉。
缺点：
初学者需要花费更多的时间和精力去理解它的工作原理和使用方式，相比其他工具来说它有一定的学习难度。
Puppet通常为了保证部署的正确性而付出更高的性能代价。
Puppet缺乏实时的监控能力。
Chef
Chef同样也是一款自动化配置工具，使用起来跟Puppet类似，它也分为三部分：workstation、server和node，workstation负责编辑Chef cookbooks并把它们上传到server，node则根据server的指令自动执行工作。
优点：
Chef的中央管理环境易于使用并且比Puppet更加灵活。
Chef是一个基于Ruby语言的开源项目，在社区中有很多实用的可扩展模块，可以帮助你编写复杂的运维任务。
Chef对于初学者来说比Puppet更容易学习和使用。
缺点：
Chef的性能并不是很理想，特别是在处理大量的基础设施时。
相比于Puppet和Ansible，Chef的部署时间更长，需要更多的配置和调整。
Ansible
Ansible是一款轻量级的自动化运维工具，它可以实现应用程序部署、配置管理和任务自动化等工作，并且使用起来非常简单。因为它是无代理的，只需要在一台主机上安装Ansible，就可以通过SSH连接到其他的服务器进行管理。
优点：
Ansible的安装和配置非常简单，只需要在一台主机上安装即可。
Ansible的性能非常好，特别是在处理大量的、低配置的服务器时。
Ansible具有很强的可移植性，可以在Windows、Linux、Unix等多种操作系统上运行。
缺点：
Ansible需要手动管理并维护SSH密钥，这个比较麻烦。
Ansible的扩展性和可定制性不如Puppet和Chef，因为它主要依赖于SSH。
Ansible没有Puppet和Chef那样的中央管理环境，需要手动维护。
SaltStack
SaltStack是一款兼具自动化运维和监控能力的开源软件。与Puppet、Chef、Ansible等工具相比，SaltStack的架构更加分布式，它利用消息总线技术来让Master和Minion之间流动数据，从而实现部署和监控任务。
优点：
SaltStack具有极强的扩展性，可以使用Python或其他脚本语言进行开发扩展。
SaltStack支持事件驱动架构，可以实现更加智能的自动化运维。
SaltStack具有较好的监控和报警功能，可以通过Salt事件总线来自动触发事件响应。
缺点：
SaltStack的学习成本相对较高，需要掌握一些Python知识。
SaltStack在处理中等规模的部署任务时还比较复杂，建议用于处理大规模的环境。
Kubernetes
Kubernetes（简称K8s）是容器编排和容器集群管理的开源软件，也可以看做是一种自动化运维工具。它利用容器来进行应用程序部署、自动伸缩、负载均衡和容错等各种任务。同时，K8s提供了一套灵活的API接口，方便开发者对集群进行管理和监控。
优点：
Kubernetes具有灵活的自动化容器编排能力，能够快速部署容器化应用。
Kubernetes在容器部署、管理、监控、自动伸缩等方面提供了完整的解决方案，满足多种场景需要。
Kubernetes支持多种云平台，如AWS、GCP等。
缺点：
Kubernetes学习曲线比较高，需要熟悉容器技术以及其底层组件和工作原理。
Kubernetes本身较为复杂，需要熟练掌握其API编程接口才能更好地进行自动化操作。
综上所述，每种自动化运维工具都有其优缺点和适用场景，选择适合自己的工具需要根据实际需求和环境来决定。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b244af5d8059f5e049c190afc9cc686a/" rel="bookmark">
			聚类算法（Clustering）原理深入解析与应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1. 聚类算法概述2. 距离度量3. 聚类算法分类4. 常见聚类算法5. 聚类算法的应用领域6. 聚类算法的评估指标7. 聚类算法的优缺点8. 聚类算法的应用 聚类算法是无监督学习中常用的技术，用于将数据集中的对象分成不同的组或簇，使得组内的对象相似度较高，而组间的对象相似度较低。本文将详细解析聚类算法的原理，从距离度量到簇划分准则，全面理解聚类算法的工作原理和应用。 1. 聚类算法概述 聚类算法是一种无监督学习算法，通过计算样本之间的相似性或距离来将数据集中的对象分组成若干簇。聚类算法的目标是使得簇内的对象相似度最大化，而簇间的对象相似度最小化。
2. 距离度量 距离度量是聚类算法的基础，用于计算样本之间的相似性或距离。常用的距离度量方法包括欧氏距离、曼哈顿距离、余弦相似度等。选择适合数据类型和问题需求的距离度量方法对于聚类算法的有效性至关重要。
3. 聚类算法分类 聚类算法可以分为以下几类：
划分式聚类：将数据集划分为互不相交的簇，每个样本只属于一个簇。层次式聚类：通过不断合并或分割簇来构建聚类层次结构。基于密度的聚类：基于密度的聚类算法将簇定义为样本在密度高的区域内的集合。模型式聚类：假设数据集由某些概率分布生成，通过对概率模型进行参数估计来划分簇。 4. 常见聚类算法 本文将介绍以下几种常见的聚类算法：
K-Means算法：将数据集划分为K个簇，通过最小化簇内样本与簇中心的距离来优化聚类结果。层次聚类算法：通过不断合并或分割簇来构建聚类层次结构，常见的方法包括凝聚层次聚类和分裂层次聚类。DBSCAN算法：基于密度的聚类算法，通过定义核心对象和密度直达来划分簇。高斯混合模型（GMM）：模型式聚类算法，假设数据集由多个高斯分布组合而成，通过最大似然估计来划分簇。 5. 聚类算法的应用领域 聚类算法在各个领域都有广泛的应用，包括但不限于以下几个方面：
市场细分：通过聚类算法将消费者划分为不同的市场细分群体，有助于精准营销和产品定位。图像分割：将图像中的像素点划分为不同的区域，有助于图像分析和目标识别。文本聚类：将文本数据划分为不同的主题或类别，有助于信息检索和文本分类。生物信息学：在基因组学和蛋白质分析中，聚类算法用于识别基因或蛋白质的功能和相似性。社交网络分析：将社交网络中的用户划分为不同的群体，有助于社群发现和推荐系统。 6. 聚类算法的评估指标 评估聚类算法的性能是十分重要的，常用的评估指标包括簇内离散度、簇间距离、轮廓系数等。选择合适的评估指标可以帮助我们了解聚类结果的质量并进行算法比较和参数调优。
7. 聚类算法的优缺点 聚类算法优点： 无监督学习：不需要标注的训练数据，适用于无标签数据集。灵活性：适用于各种数据类型和问题领域。可解释性：聚类结果可以帮助我们理解数据的内在结构和关系。 聚类算法缺点： 初始参数敏感：聚类算法对初始参数的选择和数据的初始化敏感。处理大规模数据挑战：在大规模数据集上计算距离矩阵和簇划分可能会面临计算和存储方面的挑战。难以处理高维数据：在高维空间中，距离度量和聚类结果的解释变得困难。 8. 聚类算法的应用 from sklearn.datasets import make_blobs from sklearn.cluster import KMeans # 生成模拟数据 X, _ = make_blobs(n_samples=100, centers=3, random_state=42) # 构建K-Means模型 kmeans = KMeans(n_clusters=3) # 拟合数据 kmeans.fit(X) # 获取聚类结果 labels = kmeans.labels_ centroids = kmeans.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b244af5d8059f5e049c190afc9cc686a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21d35c2b5b70c92282e7e6acd3c86766/" rel="bookmark">
			不错的IT项目管理系统有哪些？对比2023年最受欢迎的8款项目管理工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在当今的工作环境中，项目管理软件已成为提升团队效率、推动项目进度的重要工具。从任务分配到协同合作，从进度追踪到文档共享，一个好用的项目管理工具能大大提高工作效率，简化项目流程。但是，在众多项目管理软件中，我们应该如何选择呢？哪一个才是我们真正需要的呢？在本文中，我们将对比2023年的主要项目管理软件，以帮助您找到答案。
一、项目管理软件系统对比：功能、价格、易用性等 项目管理工具用哪个好？为了回答这个问题，我们对比了9款在国内外都知名的项目管理产品：
研发项目管理平台：PingCode通用型项目管理软件：Worktile开源项目管理系统：Redmine在线项目管理系统：mondayIT项目追踪工具：Jira个人项目管理工具：Notion免费项目管理软件：Trello建筑工程项目管理软件：广联达敏捷项目管理系统：TAPD 1.研发项目管理平台：PingCode 推荐使用：各种规模的产品研发团队、敏捷团队、有国产化诉求等
厂商实力：PingCode 在2021年被36氪评为：国内研发项目管理榜单TOP1；2022年被选入国内年度口碑产品TOP36；知名客户包括小红书、中国联通、北京银行等。
产品功能/适用场景：PingCode 是一款覆盖研发全生命周期的项目管理系统，被广泛用于需求收集、需求管理、需求优先级、产品路线图、迭代管理、项目管理（敏捷/kanban/瀑布）、测试管理、缺陷追踪、项目文档管理、效能度量等领域。集成了github、gitlab、jinkens、企微、飞书等主流工具，并且能够与现有的自研工具打通提供接口。
定价：为25以下团队提供免费版本。付费版本299起。【更多定价策略查看】
优缺点：1.产品开箱即用，简单易上手，不需要像Jira 那样经过好几月的培训，以及专门的系统管理专家配置系统才可使用；2.能够很好的满足国产化需求，比如支持信创、麒麟等，支持私有部署、定制化以及saas等购买方式；缺点在于暂未提供多语言版本；无法满足销售等业务团队的项目管理需求。
【官方地址：https://sc.pingcode.com/w5ovk】
2.通用型项目管理软件：Worktile 推荐使用：中小团队，对多种工具都有需求的团队
厂商实力：Worktile成立于2012年，是一家十年老厂。在通用项目管理领域是国内市场占有率最高的项目管理软件之一。知名客户包括：招商银行、小米、人民网、清华大学、新东方、中国石油等。
产品功能/适用场景：Worktile能够满足各种项目管理需求，所以它被广泛用于电商、市场活动、律所项目、生产制造、行政、财务、设计、工程、教育、科研等几乎包含所有类型的项目。
在功能上，Worktile 是一个工具集合，它具备OKR目标管理、项目管理、项目集管理、项目计划、项目风险、项目成本管理、企业网盘、审批、简报等能力。并且具备强大的自定义能力，能够配置出符合各种项目团队的流程、表单、字段、数据报表，以及具备丰富的模板市场。是一个十分成熟的项目管理工具。
定价：10人以下提供免费版本，付费版本499/年/人起。【价格标准】
优点：Worktile的优点很多，比如1.强大的自定义能力，能配置出符合各种项目团队的流程、表单、字段、数据报表。实现了项目全生命周期的管理，从项目目标、项目立项、项目流程、项目进度到项目成果等；性价比高。一个工具能满足多重需求，避免工具之间割裂，节省成本。
缺点：在一些垂直领域的项目管理深度低于垂直领域产品，比如在软件研发项目领域PingCode可能更加适合，在CRM项目上，Worktile可能能满足中小企业的管理需求，但在大型客户上纷享销客可能会更加合适。
【官方地址：https://sc.pingcode.com/wq3tg】
3.开源项目管理系统：Redmine 推荐使用：强制要求定制化开发的企业，注重安全、体验的企业并不推荐。
厂商实力：国外最知名的开源项目管理产品之一，自2006年发布以来，Redmine在全球范围内广受好评，并拥有庞大的用户群和活跃的社区。
项目管理功能：Redmine提供了丰富的项目管理功能，包括：多项目支持、灵活的角色和权限管理、问题跟踪与任务管理、甘特图和日历视图、文件和文档管理、报告和统计等。
定价：免费开源
优点：易于安装与部署、丰富的插件和扩展、高度定制化、适用于多种场景。
缺点：但不可避免的，企业在使用Redmine这类开源软件的过程中会遇到以下问题：
成本更高：开源软件虽然可以节约一定的开发成本，但却会带来非常高的开发维护成本。我们曾算过一笔账：购买一个在线项目管理系统的成本是约是15万/年（100人团队）；开源项目管理系统二开最少需要一个专门的程序员来开发+长期维护，而一个程序员的薪资至少在20W/年，但二开前期人员投入一定不止1个人。功能有限，系统一直处于“能用”的状态，更新频率低；安全性可能更低：当软件应用程序的源代码公开可用时，其安全性变得更加脆弱。 【官方地址：https://www.redmine.org/】
4.在线项目管理系统：monday 推荐使用：海外企业或者跨国团队，定制化需求较高的企业
厂商实力：Monday.com，成立于2012年，是以色列特拉维夫一家云计算公司。2020年8月4日，胡润研究院发布《2020胡润全球独角兽榜》，Monday.com排名第169位。
产品功能：它为工作管理、客户管理、开发过程管理分别打造了不同的子产品。被广泛用于创意设计、资讯科技、软件开发、行业销售、任务管理、HR、机械制作等行业的项目管理。
定价：Monday.com只为2人及以下团队提供免费版，且功能有限。付费版本8美元/人/年起。
优缺点：1.它易于学习，易于理解；2.集成中心支持与Slack，Dropbox，Teams，Outlook和许多其他应用程序轻松集成；3.该平台可以定制以满足每个用户的个人需求，并提供模板和选项来创建定制的工作流程。4.不在大陆提供服务，所以更适合海外或者是跨国团队使用。
【官方地址：https://monday.com/】
5.IT项目管理工具：Jira 推荐使用：几千人的不差钱大型组织，如果追求简单易用、快速上手、便宜则不推荐。
厂商实力：Atlassian是全球闻名的软件研发项目管理工具厂商，是全球软件研发工具的先驱。
产品功能：JIRA是Atlassian公司出品的项目与事务跟踪工具，被广泛应用于缺陷跟踪、客户服务、需求收集、流程审批、任务跟踪、项目跟踪和敏捷管理等工作领域。
定价：百人团队加上插件的价格通常上百万/年。
优点：Jira的优点很多，比如它默认定义了丰富的字段来记录问题的各种信息，包括Issue Type, Issue summary, Issue Description, priority, assignee,reporter, resolutions等等。它还具有强大的自定义字段功能，自定义字段自带有22种类型可以选择。Jira还拥有一流的功能、安全性、隐私性等。
缺点：JIRA是个商业软件，加上插件的价格通常上百万/年；在中国大陆不支持私有部署；Jira 太复杂，对中小团队，或者短时间内来说反而增加了团队的负担，而不是提高效率等。
【官方地址：https://www.atlassian.com/software/jira】
6.个人项目管理工具：Notion 推荐使用：小团队或个人，有项目、任务、文档等各类需求，且习惯科学上网的。
厂商实力：Notion 是一款「将笔记、知识库和任务管理无缝整合的协作应用」。近几年在国内有非常多推荐者，在百度搜索的搜索指数高达3000。在全球有百万用户。
产品功能：Notion是一款集成了笔记、知识库、数据表格、看板、日历等多种能力于一体的应用程序，它支持个人用户单独使用，也可以与他人进行跨平台协作。Notion可以满足使用者关于记笔记、日程安排、文档管理、团队协作等多种方面的需求
定价：为10人以下提供免费版本，但功能有限。付费版本8美元/人/月起。
优点：Notion最强的地方在于「All-In-One」，一个应用相当于 同时拥有多个应用。支持部分MarkDown语法；非常良好的写作体验；
缺点：没有离线功能，存在数据安全风险。不支持中文，网络有时不稳定，需要科学上网。大而全也意味着有些功能成熟度不如一些专业垂直工具，比如表格不如Excel等。
【官方地址：https://www.notion.so/】
7.免费项目管理软件：Trello 推荐使用：个人、小团队、没有预算的团队。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/21d35c2b5b70c92282e7e6acd3c86766/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c78371da2dea81227e971e7561de9766/" rel="bookmark">
			IntelliJ IDEA 常用设置 主题颜色模式、字体、样式、背景自定义颜色及其背景图片(图文步骤)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 这里已 IntelliJ IDEA 2018.2.8 版本为例（本人已将主题设置成了暗色主题）:
以下所有的操作都需要打开设置 点击 file﹥setting 打开设置 ①设置主题模式颜色（我这里默认是Darcule暗色模式） 点击 Editor﹥Color Scheme﹥Color Scheme Font ②设置字体、样式 主要的操作有主代码字体，字体字号大小，字体行间距，非主代码字体 主要的操作有颜色，斜体，加粗，背景，下划线，删除线，边框 打开颜色面板的设置 ③设置背景颜色、背景图片 背景颜色区别于主题颜色，背景是单独某一块背景颜色的修改 主代码编辑区域的背景颜色的修改 控制台背景颜色的修改 主代码编辑区域的背景图片的修改 如果你的IDEA是比较新的版本，那么自带就有这个功能。 首先，进入IDEA，依次打开 File-&gt;Settings-&gt;Keymap 搜索 Set Background Image ，看是否存在；如果存在，就说明可以直接使用。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0bbd0ccb528f75fe4b76b4420c2fd486/" rel="bookmark">
			java学习路线
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		阶段一：
第一阶段： Java 基础。
第二阶段：数据库。
第三阶段： Java Web。
第四阶段：主流框架。
第五阶段：服务器中间件。
第六阶段：微服务和分布式。
第七阶段：练手项目。
第一阶段： Java 基础
最开始要学习的是 Java 基础，学习了这部分，就会对 Java 语言有一个初步的了解。
这部分主要学习的内容有：基本程序结构，类与对象，接口，泛型，反射，集合，异常与调试， Java 网络编程， Java I/O和多线程。
第二阶段：数据库
MySQL 和 Oracle 都是广受企业欢迎的数据库，其中 MySQL 是目前应用最广泛的开源关系数据库，对于新手或者校招的小伙伴，我们目前只学习 MySQL 就可以了。
这部分主要学习的内容有：数据库的CRUD操作、JDBC API、数据库特性和数据库连接池。
其中，数据库连接池是为了避免频繁地创建和销毁 JDBC 连接，常见连接池包括 C3P0，Druid 和 HikariCP，目前使用最广泛的是HikariCP。
第三阶段： Java Web
学习 Java Web，我们不仅需要掌握后端 Java 技术，还需要学习些前端知识。
前端有三大基础技术 Html、CSS和 Java Script，初学的话，学习这些就可以了。如果想做出更好的交互式效果，可以再学习Vue和React等前端技术。
后端 Java 技术包括 Servlet、Filter、Listener、Session、Cookie、JSP、EL 表达式和 JSTL 等。
其中，像 JSP 这样比较老的技术，目前在各大互联网公司基本不再使用，已经被 Freemark、Thymeleaf 这样的模板引擎所替代，我们只需要了解基本使用即可。
第四阶段：主流框架
这部分我们要学习的主流框架主要有 Spring、Spring MVC 和 MyBatis，俗称 SSM 框架。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0bbd0ccb528f75fe4b76b4420c2fd486/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29504792c02bedb56d48c53c30fa982d/" rel="bookmark">
			关于OMP: Error #15: Initializing libiomp5md.dll, but found libiomp5md.dll already initialized.错误解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述： 这是有关 OpenMP（多线程并行计算库）的错误和提示信息。下面是对这段信息的解释：
OMP: Error #15: Initializing libiomp5md.dll, but found libiomp5md.dll already initialized.：这是一个错误提示，指示在程序中多次链接了 OpenMP 运行时库，因此导致初始化时发生了冲突。废话不多说直接上图片。
解决办法（暴力解决）： 使用环境变量 KMP_DUPLICATE_LIB_OK 来绕过 OpenMP 的错误。请注意，这种解决方法被描述为不安全、不受支持和未记录的，可能会导致程序崩溃或产生不正确的结果。因此，建议仅在无法找到更好解决方案的情况下使用。
要应用这个暴力解决方法，请按照以下步骤操作：
打开终端或命令提示符。
设置环境变量 KMP_DUPLICATE_LIB_OK 的值为 TRUE。在 Windows 上，可以使用以下命令：
set KMP_DUPLICATE_LIB_OK=TRUE 在 macOS/Linux 上，可以使用以下命令：
export KMP_DUPLICATE_LIB_OK=TRUE 通过设置环境变量 KMP_DUPLICATE_LIB_OK=TRUE，程序将继续执行，但请注意这可能会导致程序崩溃或产生不正确的结果。
尽管这是一个可能的解决方法，但强烈建议您尝试找到更好的解决方案，以避免潜在的问题。可能的解决方案包括检查代码中是否有多次链接 OpenMP 运行时库的情况，并确保只有一个链接，或者查看相关库和依赖项的设置是否正确。
解决方法（找到libiomp5md.dll对其进行操作） ： 在anaconda文件中，进行查找找到所有libiomp5md.dll文件
删除..\Anaconda3\Library\bin\libiomp5md.dll 文件，即以\Anaconda3\Library\bin开头的
删除..\Anaconda3\envs\work\Library\bin\libiomp5md.dll，即以\Anaconda3\envs开头的
请注意，对 libiomp5md.dll 文件的操作可能会影响系统或其他相关软件的稳定性和性能。在进行操作之前，建议确保您对此过程有充分的了解，并谨慎行事。（大概率没有问题，大不了删了重新安装anaconda)
至此，Error #15: Initializing libiomp5md.dll, but found libiomp5md.dll already initialized问题大概率解决。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6e73705c41f23a3ed3e5070ab4c4541/" rel="bookmark">
			2023年上半年软考成绩查询时间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		23年上半年软考考后成绩查询、分数线、证书领取相关注意事项 一、软考成绩查询时间 软考考试时间分为上半年和下半年，上半年固定是在五月份下半年固定是在十一月份。
成绩查询时间一般在考试时间后的两个月左右根据历年来看，
根据往年成绩查询时间来看，2022上半年成绩查询时间：7月23日；2021上半年成绩查询时间：7月12日；2019上半年成绩查询时间：6月27日；2018上半年成绩查询时间：7月6日。
2023年上半年软考考试时间是5月27-28日，推测2023年上半年成绩预估7月中旬在官网可以查询；2023年下半年软考时间是11月4-5日。（不过一切还是以官网为主）
二、合格标准公布时间 根据历年软考合格标准公布时间来看，一般在成绩公布后一个月左右会公布合格标准，2023年上半年软考合格标准预计7月底或8月初公布，以下是近年来软考成绩合格标准公布时间。
三、电子证书和编号查询 证书编号及电子文件查询服务要在合格标准公布之后才会开通，一般合格标准公布后半个月左右天会开通查询，软考办证书编号预计在8月上旬可以查询（合格标准公布后1-2个星期），中国人事考试网证书电子文件查询预计在8月底或9月初（合格标准公布后1个月左右）。
注：目前软考全国还没有统一实行电子证书，目前仅广东、浙江、山东实行电子证书，我们在中国计算机技术职业资格网和中国人事考试考试网查询的证书正确来说，应该称为“证书电子文件”，查询验证结果显示为标注“人力资源和社会保障部人事考试中心提供查询结果”字样的电子文件。该电子文件可作为通过该项考试的证明。其他社会机构或个人可通过证书查询验证系统在线验证证书信息真伪。中国计算机技术职业资格网证书查询提供的是证书查询结果，显示证书编号等信息及证书有效提示。
四、纸质证书领取时间 历年的来看的话一般是证书领取时间一般在考后4个月左右开始领取。（各地证书领取具体时间不一样，届时请多留意当地证书领取通知。）
1、证书领取方法：个人领取、代领（个别地区不允许代领）、邮寄（有些地区不提供邮寄），关注官网发布的通知。
2、证书领取材料：身份证原件，部分地区可能还需要携带准考证、成绩单等，请以当地软考办要求为准。
3、证书领取流程：证书领取通知发布——查看通知——根据通知中的要求领取证书。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1616a0c33e7b796ddaeb455b7cac3b73/" rel="bookmark">
			一些WEB测试方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ladys and 乡亲们，long time no see，发个笔记：）
首先，WEB是咋组成的
Web应用程序一般是B/S模式，一个Web应用程序是由完成特定任务的各种Web组件(web components)构成的并通过Web将服务展示给外界，在实际应用中，Web应用程序是由多个Servlet、JSP页面、HTML文件以及图像文件等组成。
然后，主要测试方法如下
测试方法测试类型功能测试链接测试、输入域测试、表单测试、删除测试、搜索测试、数据库测试、cookies测试UI测试导航测试、多媒体测试、控件测试兼容性测试平台测试、浏览器测试安全性测试登录及权限测试、超时限制性能测试压力测试、负载测试等 链接测试
1)测试所有链接是否按指示的那样确实链接到了该链接的页面 2)测试所链接的页面是否存在 3)测试web应用系统上没有孤立的页面 输入域测试
1）对于手机、邮箱、证件号等的输入是否有长度及类型的控制； 2）输入中文、英文、数字、特殊字符（特别注意单引号和反斜杠）及这四类的混合输入，是否会报错； 3）输入空格、空格+数据、数据+空格，是否报错； 4）输入html语言的&lt;head&gt;，是否能正确显示； 5）输入全角、半角的英文、数字、特殊字符等，是否报错； 6）是否有必填项的控制；不输入必填项，是否有友好提示信息； 7）输入超长字段，页面是否被撑开； 8）分别输入大于、等于、小于数据表规定字段长度的数据，是否报错； 9）输入非数据表中规定的数据类型的字符，是否有友好提示信息； 10）在文本框中输入回车键，显示时是否回车换行； 11) 非法的输入或操作应有足够的提示说明。 ## 补充时间输入域测试 1）开始时间&lt;=结束时间，测试分、一个小时、跨时、当天、跨天、跨月、跨年的数据 2）开始时间&gt;/&lt;当前时间，若是针对出生年月搜索，验证大于的情况；若是定时任务时间搜索验证小于的情况 3）只输入开始时间/结束时间 4）开始时间、结束时间都不输入 5）结束时间早于开始时间 6）手动输入时间，注意时间格式验证 7）选择时间后的时间格式验证 表单测试
1）输入框测试 ——长度、数据类型、必填项、特殊字符、中文字符是否乱码、空格、按钮、sql注入以及一些业务相关约束 2）下拉框测试 ——默认值、数据完整性/正确性、第一个/最后一个/中间一个选取、手动输入值模糊匹配、联动选择；业务常见选取的操作 3）图片、视频、excel、txt等文件上传测试 ——大小、尺寸、格式、数量、文件内容规则验证 4）表单提交按钮测试 ——是否支持回车/单击、快速多次点击是否重复提交表单、网络中断（弱网）提交、提交之后是否有提示、提交后内容是否加密、提交是否做权限校验控制、多人针对表单同时操作的场景测试 5）快捷键测试 比如Tab键、Enter键、Ctrl+C、Ctrl+V、backspace等，对不允许做输入的字段(如：下拉选项)，对快捷方式是否也做了限制 6)数据校验测试 使用表单进行用户注册、登陆、信息提交等操作时，验证服务器能正确保存这些数据以及验证后台运行的程序能正确解释和使用这些信息 删除测试
1）没选择数据，点击删除 —是否有友好提示 2）选择一条数据，点击删除 —是否提示删除确认信息，需二次确认 3）删除一条数据后，点击添加 —是否可以添加相同的数据 4）选择批量删除 —是否支持 5）选择全选，点击删除 ----注意是否把所有的数据删除 6）删除一个有关联性的数据，（如删除QQ分组，组下好友会有提示） 7）一直点击删除按钮 —是否有友好提示 8）所有删除数据操作，要注意相应查询页面及其关联界面的数据是否及时更新 搜索测试
1）任单个条件查询：模糊搜索、超长搜索、不存在与之匹配的条件、为空 2）任两个组合查询：确保任两个组合查询的正确性，验证两个组合的所有情况。 3）三个组合查询：不需要测试三个组合的全部级组合。因为前面针对所有单个条件的搜索、两个组合的所有组合进行测试了，那么在这里选择2-3组三种组合进行测试即可。 4）全条件组合查询：确保最大组合的正确性。 5）默认条件查询：补充默认条件查询的用例 6）根据需求或者业务规则选取重点条件组合查询 cookies/session测试
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1616a0c33e7b796ddaeb455b7cac3b73/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6fcaf071e44aed3624e693d944754fae/" rel="bookmark">
			loguru的基本使用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 logguru安装 常用参数sinkrotationFormatlevelcompression Traceback logguru 选择使用这个库的原因是它使用简洁不复杂不像logging这个库一样需要创建Handle等，一个logger搞定所有12
安装 C:\Users\hzdl&gt; pip install loguru 常用参数 from loguru import logger logger.info('just test') logger直接输出内容前，已经提前做了配置，比较友好地输出内容的格式和颜色
2023-05-31 10:06:46.703 | INFO | main::19 - just test
如果要对输出的内容进行其他处理需要使用add方法,下面是python源码对add方法的说明，可以传入很多参数
sink sink可以传递str对象或者Path路径
from loguru import logger logger.add('test.log') logger.info("一个bug") 这样我们的add会自动判断这个字符串是个路径然后目录写入我们的log信息
rotation 这个可以约束日志的最大范围，exp：
“1 MB” “1 GB” “1 month” “2 weeks” “4 days” … …
from loguru import logger ogger.add('run_{time}.log',format='{time}|{level}|{message}',rotation="1 KB") Format key描述time记录日志生成的时间module日志记录的文件的名称name日志记录的文件的名称level日志的级别function日志出错的方法message记录日志的信息line记录日志的行数…常用的也就这么多，其他不常用了 #demo.py 1 from loguru import logger 2 3 logger.add('run.log', 4 format='{time}|{level}|{message}|{line}|{module}|{name}',rotation="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6fcaf071e44aed3624e693d944754fae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d33556f992648ff85a031fc94d2c6e8/" rel="bookmark">
			try语句异常处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 try语句异常的所有基类try语句的标准语法实战代码 try语句 ​ 使用try语句主要是为了进行异常的捕捉处理，异常在python也有几个基类
异常的所有基类 异常名称描述BaseException所有异常的基类SystemExit解释器请求退出KeyboardInterrupt用户中断执行Exception常规错误的基类StopIteration迭代器没有更多的值GeneratorExit生成器发生异常来通知退出StandardError标准异常的基类ArithmeticError数值计算错误的基类FloatingPointError浮点计算错误的基类OverflowError数值运算超出最大限制ZeroDivisionError除零错误AssertionError断言语句错误 try语句的标准语法 #try的标准语句 try: pass except: pass else: print ("try子句没有发生异常执行这里的语句") finally: print ("异常会不会发生都会执行") 实战代码 ##step1 1/0 D:\python\python.exe C:\Users\\demo.py &gt;&gt;&gt;&gt; ZeroDivisionError: division by zero #异常发生，触发ZeroDivisionError的基类异常并说明了原因 ##step2 try: 1/0 except: print ("hha") D:\python\python.exe C:\Users\\demo.py &gt;&gt;&gt;&gt; hha # 捕捉到了异常触发异常打印hha ###################### try: 1/0 except NameError as e: print ("hha",e) D:\python\python.exe C:\Users\\demo.py &gt;&gt;&gt;&gt; ZeroDivisionError: division by zero # 触发了异常，但是异常只会进行捕捉NameError的异常类，所有except语句没有生效 ###################### try: 1/0 except ZeroDivisionError as e: print ("hha",e) D:\python\python.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3d33556f992648ff85a031fc94d2c6e8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7bc567d9818d524304deca41fdef84f0/" rel="bookmark">
			Rust类型转换知多少
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Rust类型转换知多少 Rust类型转换方式大致有三种：
as 语法实现From traittryFrom trait as 语法实现的类型转换只能用于基本类型之前都相互转换，如果基本类型转非基本类型就会编译错误。 From Trait 一般用于非基本类型的转换（比较复杂的转换)，比如String::from 函数
tryFrom 和From trait 很相似，不同点就是tryFrom 返回值是result 类型（包含错误信息)
as 语法类型转换 #[cfg(test)] mod tests { #[test] fn castTest() { let a = 5_f32; let b = a as i8; let c = "jeebble"; let d = c as i32;// compile error println!("{}", b); unsafe { println!("{}",200.0_f32.to_int_unchecked::&lt;i8&gt;()); } } } 实现From Trait 自定义Number类型，实现i32类型转Number
#[derive(Debug)] struct Number{ value: i32, } impl From&lt;i32&gt; for Number { fn from(value: i32) -&gt; Number { Number{value} } } #[cfg(test)] mod tests { use crate::Number; #[test] fn fromAndToTest() { let num =Number::from(5); let it = 5; let num2:Number = it.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7bc567d9818d524304deca41fdef84f0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fad8b35534b971eab240023e927e7791/" rel="bookmark">
			android存储2--初始化.存储service的启动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		android版本：android-11.0.0_r21
http://aospxref.com/android-11.0.0_r21/
android存储初始化分3个阶段：
1）清理环境。因android支持多用户，解锁后登录的可能是另一个用户，需把之前用户执行的一些信息清理干净。《android存储1--初始化.清理环境》已做分析，总结如下：
start primary user
发送START消息、H_BOOT_COMPLETED消息给其他service处理。init用户目录的加密状态
初始化软件加解密的device的用户目录加密状态；对于硬件加密的device，什么事也不做。reset external storage service
umount外部存储、关闭mount service的所有connection。按电源键开机，外部存储还没有挂载，所以不需要卸载任何存储设备，也不需要关闭任何connection。reset vold service
销毁volume、重置disk对象、清空用户、添加用户。开机场景不需要销毁volume、重置disk对象、清空用户。添加用户
在mAddedUsers中记录主用户。 2）启动存储服务（mount、vold、storaged这些service）。
3）挂载emulated存储（这系列文章只分析emulated存储）。
本文分析“启动存储服务”，涉及mount、vold、storaged service的启动流程。
一、存储相关的service 1，service介绍 存储有3个关键service：mount、vold、storaged，通过adb shell "service list"可以看到。
service代码：
service代码路径mount serviceframeworks/base/services/core/java/com/android/server/StorageManagerService.javavold servicesystem/vold 目录
（注意，虽然vold是一个用户态程序，但它的log默认在内核里，需通过dmesg查看）storaged servicesystem/core/storaged 目录 mount service负责mount和umount存储设备或存储卷，提供文件系统的访问接口。它的mount、umount请求下发给native层的vold处理。
vold (Volume Daemon)位于framework和kernel之间，管理存储卷的生命周期、处理mount service的mount和umount请求，以及提供存储卷的管理接口。
vold主要功能：
1）监听内核的存储设备uevent事件，并上报给mount service。
2）处理mount service下发的mount、umount请求。
storaged是一个deamon进程，提供存储相关的统计数据（磁盘使用信息、应用io信息、存储寿命信息等），并通过向应用程序和系统组件提供 API 接口，使它们能够监控和管理存储资源的使用情况。提供的命令如下：
命令输出说明storaged或storaged -s 注册storaged service和storaged_pri service。
系统启动时int进程解析/system/etc/init/storaged.rc，执行storaged命令。
我们在调试的过程中，不需要再执行storaged命令了。
storaged -u
storaged -t 调试时，该命令用的比较多 &lt;uid&gt;/&lt;foreground read bytes&gt; &lt;foreground write bytes&gt; &lt;foreground read chars&gt; &lt;foreground write chars&gt; &lt;background read bytes&gt; &lt;background write bytes&gt; &lt;background read chars&gt; &lt;background write chars&gt; storaged的help信息： -u Dump uid I/O usage to stdout -t Dump task I/O usage to stdout 但是，system/core/storaged/main.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fad8b35534b971eab240023e927e7791/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aae8d260776ce6cc1f9344deaeb53717/" rel="bookmark">
			vue-element文件上传组件el-upload的使用(导入)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		直接贴图上代码el-upload组件action属性为文件要上传的地址,不需要展示已上传的文件的话可以把show-file-list设置为false,headers可以配置上传的请求头信息token,Content-Type等
&lt;div class="btn-listp"&gt; &lt;el-button type="primary" @click="newUser"&gt;新增&lt;/el-button&gt; &lt;el-upload class="upload-demo" :action="exportUrl" :show-file-list="false" :headers="{ 'token':token }" ref="upload" :on-success="importSuccess" multiple &gt; &lt;el-button plain class="btn"&gt;导入&lt;/el-button&gt; &lt;/el-upload&gt; &lt;el-button plain @click="exportExcel"&gt;导出&lt;/el-button&gt; &lt;/div&gt; export default { components:{}, props:{}, data(){ return { exportUrl: "", token: "" } }, methods:{ // 文件上传回调 importSuccess(response, file, fileList) { if (response.status == 200) { this.$message.success("上传完成"); this.$refs.upload.clearFiles(); this.getList(1) } else { this.$refs.upload.clearFiles(); this.$message.error(response.msg); } } }, created(){ this.token = localStorage.getItem("token"); //获取token this.exportUrl = process.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aae8d260776ce6cc1f9344deaeb53717/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a390ecbda40248c03c03d99d86554951/" rel="bookmark">
			没有网络安装vue/cli
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在没有网络的情况下，您可以选择离线安装 Vue CLI，具体步骤如下：
在另一台已经连接网络的电脑上，使用以下命令下载最新版本的 Vue CLI 安装包：
npm pack @vue/cli 在没有网络的电脑上，使用以下命令进行本地安装：
npm install -g /path/to/@vue/cli-x.x.x.tgz 其中 /path/to/ 是你所放置 @vue/cli-x.x.x.tgz 文件的路径。
安装完成后，可以通过以下命令验证是否安装成功：
vue --version 如果成功安装，将会输出 Vue CLI 的版本号。
通过上述步骤，您可以在没有网络的情况下安装 Vue CLI。需要注意的是，由于缺少网络，您可能无法安装 Vue 相关的插件和依赖，因此在后续项目开发中需要特别注意依赖问题，并根据实际情况进行引入和处理。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/77/">«</a>
	<span class="pagination__item pagination__item--current">78/321</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/79/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>