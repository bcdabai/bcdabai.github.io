<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08f0f29bbc8f3865f87f8f7d0280a537/" rel="bookmark">
			latex 学习记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在使用latex写文章，学了一些小技巧，记录一下。
双栏排版如何跨栏显示图片/表格，从这里学的：
正常写图片/表格是\begin{table}或者\begin{figue}
跨栏显示则是在后面加*：\begin{table*}或者\begin{figue*}，end的时候也是加了*的end：\end{table*}或者\end{figue*}
Latex加粗字体\textbf{加粗的文本} 。在表格中加粗字体，但是不让文本变太宽，从这里学的:\pmb{加粗文本}
画表格，学习的这篇，写的很详细。这个也不错，高阶写法
参考文献：
https://www.cnblogs.com/yymn/p/13552511.htmlhttps://zhuanlan.zhihu.com/p/114733612 CVPR匿名模板修改为显示名字:在开头取消匿名模板的选择
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ea4f9bd1fd25da446b8021e8070a32e/" rel="bookmark">
			Windows系统环境变量path详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Windows系统环境变量path详解 大家平时有没有编辑好path变量，可是运行结果却不尽人意的情况，那么希望看完我这篇关于path变量的文章对大家有所帮助，在文章的结尾有参考文档和笔者之前踩过的坑。
语法 在Microsoft官方的文档中，环境变量path的定义和注解是这样子的：
path [[:] [;…][;%PATH%]] path ; 参数和符号的解释如下：
参数说明[:] 指定在命令路径中设置的驱动器和目录。 始终在命令路径中指定的目录之前搜索当前目录。;分隔命令路径中的目录。 如果不带其他参数使用，则 ; 从 PATH 环境变量中清除现有命令路径，Cmd.exe仅在当前目录中搜索。%PATH%将命令路径追加到 PATH 环境变量中列出的现有目录集。 如果包含此参数，Cmd.exe PATH 环境变量中的命令路径值替换它，无需在命令提示符下手动输入这些值。/?在命令提示符下显示帮助。 这些符号对应我们自己电脑中的变量是什么样的呢？
以我自己的电脑举例：
[:] 对应的是windows系统设定的盘符
path 对应的则是盘符下的路径；
如E:\java11\jdk11\bin中 [:]就是对应的E:,而path对应的就是java11\jdk11\bin。
“；”封号的作用，在这个文档中描述的不够清晰，我以我的电脑来描述一下它的作用
没有其他的参数时：
在命令行下运行Tomcat启动文件startup.bat,命令行找不到文件。当我们去除%CATALINA_HOME%\bin中的“;”执行结果却不一样。
​ 这是因为在path环境变量下，检索的顺序不一样。这个留到后面说。
​ 2.有其他参数时：
​ 在Microsoft官方文档里，给我们的例子是
​ path c:\user\taxes;b:\user\invest;b:\bin
​ 表示在路径 c：\user\taxes、 b：\user\invest 和 b：\bin 中搜索外部命令。
​ 在我们的一般配置的环境变量中，比如配置java的jdk和jre环境，就有用到这个；
​ %PATH%的作用说白了就像C中被define定义的常量，java中被final修饰的最终值，只是起到一个替换名字的效果。​ /？的效果如图 path的优先级 上文我们说了Microsoft官方定义的文档，同时还留了一个问题；上述的“；”的两种情况，在没有参数的时候，加不加封号直接影响到执行的结果，这就涉及到path的优先级问题。
我们首先来了path的原理和作用 当我们想要去寻找一个可执行的文件或者外部命令时，系统首先会在当前根目录下去检索寻找，比如我们现在处于“C:\”下，那么当我们键入一个文件时，系统会先在当前的C盘下寻找，如果找不到时，就需要去系统path变量下遍历寻找，如果还是找不到就会去用户path变量下遍历寻找；==但是还是会出现明明定义了path变量或者定义了多个变量但是出现与期望不一样的结果。==这就需要去了解path变量内部遍历顺序。 path变量遍历顺序 一般来说，path变量遍历顺序时从上到下遍历的，但是有个例外，就是变量中结尾有“;”时，如上文说的，当“;”没有和其他参数搭配使用时，系统会从 PATH 环境变量中清除现有命令路径。所以检索时系统会把带有“;”的变量放在最后遍历，当有多个带有封号的变量时，系统会将这些变量放在其他变量遍历完后遍历，顺序依然时从上至下，这也是上述问题的原因。 在%CATALINA_HOME%\bin；变量前放有%MAVEN_HOME%\bin;，
**可是真实的执行顺序是这样吗，检索碰到第一个“;”时，就不会检索了，所以相当于只会检索到%MAVEN_HOME%\bin就会停止，这就是为什么当我们执行Tomat启动文件startup.bat反馈找不到文件的原因。**而当去掉封号后，startup.bat能够顺利执行，是因为，去掉封号后检索的顺序提前到之前去了，系统自然能够在遇到“;”前检索到。
编辑path的注意事项 封号不要随便打，封号过多很有可能导致，找不到指定文件。执行顺序我们是不可改变的，但是我们编辑的习惯可以改变。面对多个相同文件名不同版本的文件，比如jdk；想要随意切换版本，除了做好文件管理外，我们剩下的就是要注意优先级，我们可以通过将想要的版本的变量上移，来达到优先于其他版本检索到目的。现在的许多新版本软件在下载.exe或.iml安装版本时，都会自动配置path变量，比如新版的jdk工具安装时就会在path中配置一个默认的变量，我们需要去管理，而不是放任不管。path变量有时候不能如列表打开，这时候我们需要将首个变量修改为盘符开头格式。 这些注意事项都是笔者曾经踩过的path变量的坑，希望看完文档后对大家有所帮助。
**参考文档：微软官方文档**path | Microsoft Learn learn.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4ea4f9bd1fd25da446b8021e8070a32e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a0ba8642d2b5bb99881937ef68cccea/" rel="bookmark">
			Visual Studio的下载与安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Visual Studio下载安装 官网下载 网址：免费的开发人员软件和服务 - Visual Studio (microsoft.com)
直接下载社区版（Visual Studio Community）
安装相关组件 运行下载完成的Visual Studio Installer
勾选.NET桌面开发、使用C++的桌面开发
以及其他工具集中的Visual Studio 扩展开发
默认安装位置改到D盘（如果C盘空间足够，也可以不用改），点击安装
注册与登录 点击登录，如果没有建议创建账户，方便保存用户配置
直接使用微软账户登录
创建新项目 点击创建新项目
语言选择C++
选择空项目，点击下一步
项目名称和位置可以自定义，勾选将解决方案和项目放在同一目录中，点击创建
右键点击解决方案资源管理器中的源文件，添加新建项
选择C++文件，名称可自定义，点击添加
测试hello world
#include &lt;iostream&gt; using namespace std; int main() { cout &lt;&lt; "Hello, World!"; return 0; } 点击本地Windows调试器或按F5
至此，安装完成
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae41f11a05e49580d0872d4dedc35e35/" rel="bookmark">
			java编程题：输入格式： 输入在第一行给出一个正整数 n（≤10）。随后 n 行，每行通过两个 0 或 1 来描述实际状态。  第 1 个数字为 0 对应“不测”，为 1 对应“测一下”。 第 2 个数字为 0 对应“不是新冠”，为 1 对应“是新冠”。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		你好！这是一道练习使用字符串处理的编程题。
你需要编写一个 Java 程序，按照题目给出的输入格式从输入中读取信息，并输出结论编号。
具体来说，你需要做如下处理：
读取第一行输入，存储到变量 n 中。
循环 n 次，读取每行输入，并将结果存储到变量 status 中。
对于每个 status，使用 if 语句判断它是哪个结论编号，并输出。
示例代码如下：
import java.util.Scanner;public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); // 读取输入并存储到变量 n 中 int n = sc.nextInt(); // 循环 n 次，读取每行输入并输出结论编号 for (int i = 0; i &lt; n; i++) { String status = sc.next(); if (status.equals("10")) { System.out.println(3); } else if (status.equals("01")) { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ae41f11a05e49580d0872d4dedc35e35/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3703cb240008bb6b9131d2a3efa9a995/" rel="bookmark">
			(十) Docker微服务实战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Docker微服务实战 一、IDEA新建一个普通微服务模块二、通过dockerfile发布微服务部署到docker容器2.1、打包模块2.2、编写 Dockerfile以及上传jar包2.3、构建镜像2.4、运行容器 一、IDEA新建一个普通微服务模块 建Module
docker_boot
Pom文件
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.5.6&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.feng&lt;/groupId&gt; &lt;artifactId&gt;docker_boot&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;docker_boot&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!--SpringBoot通用依赖模块--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt; &lt;version&gt;3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3703cb240008bb6b9131d2a3efa9a995/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/958732665e2d79fcfe5ccde8b19bf943/" rel="bookmark">
			算法竞赛常用数据结构（JAVA版）（尽可能使用数组来模拟）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		里面的截图取自acwing算法基础课程截图方便理解 在一般的算法竞赛中一般常用数组来模拟数据结构可以比调库更加节省运行时间不容易被卡时间
链表 本次讲的是用数组来模拟链表：
一个数组来记录值一个数组来记录链表的下一个节点的下标具体信息如下
案例：
package ACWing.DataStructure; //826. 单链表 //本题的注意点k要减一 import java.util.Scanner; ​ /** * @author :chenjie * @date :Created 2022/12/27 16:47 */ public class Link { static int idx=0; static int[]e=new int[100010]; static int[]ne=new int[100010];//记录着下一个节点的下标 static int h; public static void main(String[] args) { Scanner sc=new Scanner(System.in); h=-1; int m=sc.nextInt(); sc.nextLine(); while (m--&gt;0){ String s=sc.next(); if("I".equals(s)){ int k=sc.nextInt(); int x=sc.nextInt(); add(k-1,x); } if("H".equals(s)){ int x=sc.nextInt(); add_head(x); } if("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/958732665e2d79fcfe5ccde8b19bf943/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b79583ea877b9c99ee29e832a0aa4d1/" rel="bookmark">
			Linux | PCIe Hotplug | 概念及工作原理的不完全总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文对 PCIe 热插拔的概念及工作原理进行不完全总结。
更新： 2022 / 12 / 31
Linux | PCIe Hotplug | 概念及工作原理的不完全总结 热插拔组成部件实现代码通知式热插拔 线程中断功耗管理意外移除错误处理整合移除BAR参考链接 参考这里 1’ 2’ 3‘ 4’ 5
1992年初始版本的 PCI 规范并不支持运行时的板卡添加和移除。在20世纪90年代后期到21世纪初期，各种专有的热拔插控制器或者与厂商无关的标准热拔插控制器被构思出来，同时 Linux 通过位于 drivers/pci/hotplug 的驱动开始支持热拔插功能。然而，直到2002年 Linux 才开始支持PCI Express 的热拔插功能，但是具体的形式随时间不断变化。最初，PCI Express 热拔插主要是为服务器的热交换板卡或笔记本的 ExpressCards 设计的，如今，它已经广泛地应用于数据中心 ( 数据中心 NVMe Flash 硬盘需要运行时拔插 ) 和雷电接口。
热插拔 PCIe 热插拔，是指在系统上电运行时，允许插入或拔出 PCIe 设备。拔出时不需要平台提前下电，插入时直接生效，不需要系统重启。这对于服务器实现高可靠性而言是一个必不可少的特性。
热插拔可以分为2种，通知式热插拔 和 暴力热插拔。这两种差异主要体现在拔盘的操作上。
设备插入时， 内核 pciehp 驱动走的都是通知式热插流程，以盘插入时在位信号的变化或者通知按钮的按下作为触发条件。通知式热拔时，需要先通过软件指令，停止业务，移除 pcie 设备，再进行拔盘操作。暴力热拔时，没有任何通知，直接进行拔盘动作。 组成部件 为了 pcie 热插拔功能的实现，PCIe 协议定义了一系列需要实现的组件：
组件目的Indicatorshow the power and attention state of the slot。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b79583ea877b9c99ee29e832a0aa4d1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00acb0198ce2cc6c4321a4660cb7e98a/" rel="bookmark">
			Python 工匠 第六章 循环和可迭代对象
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基础知识 迭代器和可迭代对象 iter() 与 next() &gt;&gt;&gt; iter([1,2,3]) &lt;list_iterator object at 0x0000022FEFEA73A0&gt; &gt;&gt;&gt; iter('abc') &lt;str_iterator object at 0x0000022FEFEA7190&gt; &gt;&gt;&gt; iter(1) Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; TypeError: 'int' object is not iterable 迭代器：帮助我们迭代其他对象的对象
&gt;&gt;&gt; my_list = ['foo', 'bar'] &gt;&gt;&gt; iter_my_list = iter(my_list) &gt;&gt;&gt; iter_my_list &lt;list_iterator object at 0x0000022FEFEA73A0&gt; &gt;&gt;&gt; next(iter_my_list) 'foo' &gt;&gt;&gt; next(iter_my_list) 'bar' &gt;&gt;&gt; next(iter_my_list) Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; StopIteration 此外，对迭代器执行iter()函数，获取迭代器的迭代器对象时，返回的结果一定是迭代器本身。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/00acb0198ce2cc6c4321a4660cb7e98a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/242840c6a1ccd82fb3e411b2a1ca328e/" rel="bookmark">
			基于Alamouti 空间时间分组编码模拟瑞利衰落信道 BPSK 调制并计算误码率附matlab完整代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		✅作者简介：热爱科研的Matlab仿真开发者，修心和技术同步精进，matlab项目合作可私信。
🍎个人主页：Matlab科研工作室
🍊个人信条：格物致知。
更多Matlab仿真内容点击👇
智能优化算法 神经网络预测 雷达通信 无线传感器
信号处理 图像处理 路径规划 元胞自动机 无人机 电力系统
⛄ 内容介绍 基于Alamouti提出的BPSK调制下空时分组码在Rayleigh衰落信道中的码性能原理,推导出高阶(M ary)调制下Rician衰落信道中空时分组码的符号差错率的最小距离球界,并进行计算机仿真分析了两信道下引入空时分组码的多天线系统中发射和接收天线的分集增益,发射天线数量的"地板效应"以及Rician因子K对符号差错性能的影响。
⛄ 完整代码 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% from Krishna Pillai.
%使用 Alamouti 空间时间分组编码以百分比瑞利衰落信道计算 BPSK 调制误码率的脚本
% Script for computing the BER for BPSK modulation in a
% Rayleigh fading channel with Alamouti Space Time Block Coding
% Two transmit antenna, 1 Receive antenna
clear
N = 10^6; % number of bits or symbols
Eb_N0_dB = [0:25]; % multiple Eb/N0 values
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/242840c6a1ccd82fb3e411b2a1ca328e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eebdf6cf361d50f1a1d3575889391f7f/" rel="bookmark">
			Java单元测试对私有方法测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 概述 本文会首先简要说明为什么直接对私有方法测试不是一个好的实践。其次演示如果在必要的情况下如何测试私有方法
2 为什么不应该直接测试私有方法 我们写的单测应该只检查我们的公共方法。首先公有方法的调用者对公有方法内部使用的私有方法是无感知的。其次，好的设计对外接口应该是稳定的，在接口稳定的状态下，改变私有方法的实现不应该影响接口定义，因此也不应该影响我们的测试。
但有时也会遇到必须测试测试私有方法的情况，常见的场景如下：
在私有方法中存在通过公有方法入口测试无法完成行覆盖的“死”代码。私有方法设计不合理，实现太复杂，根本没法通过测试完整覆盖，代码不可测。 因此，当我们觉得需要测试私有方法时，先考虑一下设计是否合理。
3 从私有方法中删除无法覆盖的代码 下面是一段需要测试的代码，公共方法validateAndDouble依赖doubleInteger。
private static Integer doubleInteger(Integer input) { if (input == null) { return null; } return 2 * input; } public static Integer validateAndDouble(Integer input) { if (input == null) { throw new IllegalArgumentException("input should not be null"); } return doubleInteger(input); } 我们写的单测如下
@Test void givenNull_WhenValidateAndDouble_ThenThrows() { assertThrows(IllegalArgumentException.class, () -&gt; validateAndDouble(null)); } @Test void givenANonNullInteger_WhenValidateAndDouble_ThenDoublesIt() { assertEquals(4, validateAndDouble(2)); } 接着通过JaCoCo插件检查覆盖率发现有段代码未覆盖到。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eebdf6cf361d50f1a1d3575889391f7f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4036d3660bbe913673ff49cbe0934cc8/" rel="bookmark">
			docker安装oracle11g
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、拉取镜像(6G多)两种方式二选一 在线拉取(快慢取决于网络)、本地拉取(自己有打包好的镜像) 在线拉取
命令: docker pull registry.cn-hangzhou.aliyuncs.com/helowin/oracle_11g
本地拉取
利用工具把镜像oracle11g.tar.gz上传到linux的root下面(路径根据个人自定义选择,我这里选择是root下面)
个人打包好的镜像: 点击查看 提取码：8888 命令: docker load &lt; /root/oracle11g.tar.gz
2、查看docker 镜像 命令: docker images
3、创建容器 命令: docker run -d --restart=always -v /home/oracle:/data/oracle -p 1521:1521 --name oracle11g registry.cn-hangzhou.aliyuncs.com/helowin/oracle_11g
说明: --restart=always 设置docker自动启动oracle
-v /home/oracle:/data/oracle 挂载表空间到自定义路径(/home的路径内存充足),创建表空间路/data/oracle(根据个人自定义)
-p 映射端口
--name 定义容器名
4、进入镜像配置 命令: docker exec -it oracle11g bash
命令: su root
Password: helowin
给予权限挂载的文件夹 chown -R oracle /data
5、编辑profile文件配置oracle环境变量 命令: vi /etc/profile
按 i 键进入编辑,在文件最后添加下面内容, 按Esc键输入 :wq!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4036d3660bbe913673ff49cbe0934cc8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09f10d0bf953ef3fbfc18c6e482d2c45/" rel="bookmark">
			【Web安全】Ysoserial 简单利用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ysoserial 简单利用 1. Java 反序列化特征2. Ysoserial 流量特征3. Ysoserial 攻击流程3.1 找到序列化接口3.2 漏洞利用3.2.1 常用命令3.2.2 使用案例 4. Ysoserial 攻击原理问题参考 1. Java 反序列化特征 在日志中，特征通常表现为
请求格式 Json、xml、soap、二进制 关键字：rmi、jndi、 响应对应命令执行结果信息 2. Ysoserial 流量特征 3. Ysoserial 攻击流程 项目地址：https://github.com/frohoff/ysoserial
3.1 找到序列化接口 工具逐个探测
例如 shiro，如果有漏洞，则会返回 rememberMe=deleteMe
URLDNS 这个 gadget 一般用于渗透时Java 反序列化漏洞的探测
3.2 漏洞利用 一般会进行反弹 shell 等利用
3.2.1 常用命令 使用 ysoserial，在命令行中输入指定 command ，就会自动执行命令，发起攻击
在使用命令的时候，要先 明确使用哪一个payload
java -jar ysoserial-0.0.6-SNAPSHOT-all.jar [payload] '[command]' java -jar ysoserial-0.0.6-SNAPSHOT-all.jar URLDNS http://xx.xxxxx.ceye.io java -cp ysoserial-0.0.6-SNAPSHOT-all.jar ysoserial.exploit.JRMPListener 1099 CommonsCollections1 'ping -c 2 rce.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/09f10d0bf953ef3fbfc18c6e482d2c45/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fff4ebbb09cd6badf942256bcdfdc1c7/" rel="bookmark">
			mt4 api跟单接口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MT4 API 跟单接口是一种用于连接 MT4 交易平台的编程接口，可以让你通过程序控制 MT4 平台上的交易。它可以用于自动化交易、分析市场数据、执行跟单操作等。
跟单是指根据其他交易员的交易决策来自动执行相同的交易操作的一种交易方式。使用 MT4 API 跟单接口，你可以设置跟单的条件和规则，然后让程序根据这些条件和规则执行跟单操作。
要使用 MT4 API 跟单接口，你需要先下载并安装 MT4 交易平台，然后在你的计算机上安装 MT4 API 库。你还需要具备一定的编程知识，能够使用支持 MT4 API 的编程语言(如 C++、C# 等)开发程序来控制 MT4 平台。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7ad69a0da3c0fa33ed02e5a40dccc16/" rel="bookmark">
			c&#43;&#43; - 第18节 - 哈希
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.unordered系列关联式容器
1.1.unordered_set
1.1.1.unordered_set的介绍
1.1.2.unordered_set的使用
1.2.unordered_map
1.2.1.unordered_map的介绍
1.2.2.unordered_map的使用
1.3.unordered_multiset和unordered_multimap
2.底层结构
2.1.哈希概念
2.2.哈希冲突
2.3.哈希函数
2.4.哈希冲突解决
2.4.1.闭散列
2.4.2 开散列
3.哈希开散列模拟实现STL中的unordered_map与unordered_set
3.1.封装开散列代码，同时实现unordered_map和unordered_set
3.2.开散列哈希表的迭代器
3.3.开散列哈希表容量为素数的优化
3.4.开散列哈希表模拟实现STL中unordered_map和unordered_set的代码
4.哈希的应用
4.1.位图
4.1.1.位图概念
4.1.2.位图的实现
4.1.3.位图的应用
4.2.布隆过滤器
4.2.1.布隆过滤器提出
4.2.2.布隆过滤器概念
4.2.3.布隆过滤器的实现
4.2.4.布隆过滤器删除
4.2.5.布隆过滤器优点
4.2.6.布隆过滤器缺陷
4.2.7.布隆过滤器应用场景
5. 海量数据面试题
5.1.哈希切割
5.2.位图应用
5.3.布隆过滤器
6.分布式存储
1.unordered系列关联式容器 在C++98中，STL提供了底层为红黑树结构的一系列关联式容器，在查询时效率可达到 ，即最差情况下需要比较红黑树的高度次，当树中的节点非常多时，查询效率也不理想。最好的查询是，进行很少的比较次数就能够将元素找到，因此在C++11中，STL又提供了4个unordered系列的关联式容器，这四个容器与红黑树结构的关联式容器使用方式基本类似，只是其底层结构不同，这里只对unordered_map和unordered_set进行介绍，unordered_multimap和unordered_multiset学生可查看文档介绍。 1.1.unordered_set 1.1.1.unordered_set的介绍 unordered_set类的文档介绍：unordered_set - C++ Reference (cplusplus.com)
注：
1. unordered_set是存储key值的关联式容器。 2. 在unordered_set中，key值用于惟一地标识元素。 3. 在内部,unordered_set没有对key按照任何特定的顺序排序, 为了能在常数范围内找到key，unordered_set将相同哈希值的key放在相同的桶中。 4. unordered_set容器通过key访问单个元素要比set快，但它通常在遍历元素子集的范围迭代方面效率较低。 5. 它的迭代器是前向迭代器。 1.1.2.unordered_set的使用 此处只简单演示unordered_set与set的不同，其他接口与set相同，可参考set。
（1）set中的迭代器是双向迭代器，因此set中有begin、end、rbegin、rend函数。unordered_set中的迭代器是单向迭代器，因此unordered_set中有begin、end函数而没有rbegin、rend函数。
（2）set遍历访问的数据是有序的，unordered_set遍历访问的数据是无序的。
（3）set底层是红黑树，其搜索效率为，unordered_set底层是哈希，其搜索效率为O(1)，如下面代码所示
注：rand函数产生的随机数其实是有限制的，c语言rand函数有一个RAND_MAX，其最大只能产生三万多个随机数，因此如果上面的n值很大时，重复的数据是很多的，打印出来的size值（不重复的值）远小于n值。如果想让随机数变得更多可以如下图所示，给rand函数+循环变量i。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b7ad69a0da3c0fa33ed02e5a40dccc16/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4b1dd8c1c2f2d19f8ee1c88ee6791af/" rel="bookmark">
			蓝桥杯寒假集训第二天（分巧克力）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		没有白走的路，每一步都算数🎈🎈🎈
题目描述： 有很多的巧克力块，需要设计一个程序，让手艺师傅切出来的巧克力既满足切出来的巧克力的份数达到客户要求的份数，并且切出来的巧克力块尽可能的大。
输入描述： 第一行：
输入俩个数据，N，K，N代表原来的大巧克力的块数，K表示客户需要得到的块数
第二行：
接下来每行表示每个巧克力的长度和宽度
输出描述： 输出最终师傅切出来的最大长度
样例输入输出： 样例输入:
2 10
5 6
6 5
样例输出：
2
暴力解法 1.出现段错误的原因：x的循环没有循环到最后一个，即min(lmin,rmin)+1
出错原因：
当边长很大的时候，需要的块数相对较小的时候，就有些块是不需要切的，所以这里需要把块的大小给扩大，不应该是min(minl,minr) 。上述的例子，我们输出的不应该是3，还可以是5，6。所以需要设置参数调整一下。
当然这里设置成
lmax = max(L),rmax = max(R)，
x的取值也从1到其中的最大值之后，
自然而然的时间也会增加了。
最后就是超时的问题
超时的解决办法，采用二分去写
尝试用二分的方法去写 暴力法 代码：
import os import sys n,k = map(int,input().split()) L = [] R = [] for i in range(n): a,b = map(int,input().split()) L.append(a) R.append(b) lmax = max(L) rmax = max(R) count = 0 flag = 1 for x in range(1,max(lmax,rmax)+1): count = 0 for i in range(n): count+=(L[i]//x)*(R[i]//x) if count&lt;k: flag = 0 break if flag == 1: print(x) else: print(x-1) ​​​​​​​二分法​​​​​​​ 第一次尝试，二分法出现了计算结果和正确结果相差为一的情况，这是二分法在数据量较大的时候出现结果比正常的结果多了1
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c4b1dd8c1c2f2d19f8ee1c88ee6791af/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d81263f688191638d5449e7b41bd26c/" rel="bookmark">
			gitlab-runner 命令找不到
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在ssh中 命令能正常执行 kubectl， 可在gitlab-runner 却报
kubectl: command not found
经排查（在ci脚本中打印出环境变量 echo $PATH）
原因是gitlab-runner 启动的shell 和 你ssh 启动的shell 应用的环境变量不一样
解决方法：
在gitlab-runner下的 ~/.profile 文件末尾添加对应的环境变量即可
# 添加kubectl的环境变量 export PATH=/home/gitlab-runner/google-cloud-sdk/bin/:$PATH 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b277d364fc48dc949c97f2d4e02b14a9/" rel="bookmark">
			kafka日志清理策略
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简述 Kafka是一个基于日志的流处理平台，一个topic可以有多个分区（partition），分区是复制的基本单元，在单节点上，一个分区的数据文件可以存储在多个磁盘目录中，配置项是：
# A comma separated list of directories under which to store log files log.dirs=/disk1/kafka,/disk2/kafka,/disk3/kafka,/disk4/kafka,/disk5/kafka,/disk6/kafka,/disk7/kafka,/disk8/kafka,/disk9/kafka,/disk10/kafka,/disk11/kafka,/disk12/kafka 每个分区的日志文件存储的时候又会分成一个个的segment，默认日志段（segment）的大小是1GB，segment是日志清理的基本单元，当前正在使用的segment是不会被清理的。
# The maximum size of a log segment file. When this size is reached a new log segment will be created. log.segment.bytes=1073741824 #1GB 日志清理 Kafka提供了日志删除（delete）和日志压缩（compact）两种清理日志的策略，可以通过参数cleanup.policy为每个主题指定不同的清理策略，也可以在代理启动时通过配置项log.cleanup.policy指定日志清理策略，这样该代理上的所有分区日志清理默认使用该配置设置的策略，主题级别的策略设置会覆盖代理级别的配置。
基于时间的删除策略 在server.properity文件中设置如下：
log.retention.hours=48 log.retention.check.interval.ms=300000 log.segment.bytes=1073741824 每个segment的大小为1GB,每5分钟检查一次是否有segment已经查过了48h,如果有将其标记为deleted。
基于文件大小的删除策略 在server.properity文件中设置：
log.retention.bytes(原来写的是log.segment.bytes）参数默认没有指定。
你可以同时指定log.retention.bytes和log.retention.hours来混合指定保留规则。一旦日志的大小超过了log.retention.bytes就清除老的segment，一旦某个segment的保留时间超过了规定的值同样将其清除。
删除逻辑是：首先计算日志段总大小与retention.bytes之间的差值（diff），得到需要删除的日志总大小，然后从第一个日志段开始查找，若diff与该日志段字节之差不小于0，则将该日志段加入到待删除集合中，以此类推，直到diff与查找的日志段大小之差小于0，查找结束，迭代待删除的日志段文件，进行物理删除。
参考资料：
https://mp.weixin.qq.com/s/7f5iUVYtxxZEYRPFybHW5A
https://mp.weixin.qq.com/s/PoON2wPw3xyflhRH1NBd-g
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d23c4f3a6d0c0b3479da2493d4f6637a/" rel="bookmark">
			GitHub Actions入门教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		GitHub Actions入门教程 GitHub Marketplace · Actions to improve your workflow · GitHub
概述 GitHub Actions 是一个持续集成和持续交付(CI/CD)平台，允许您自动化构建、测试和部署流水线。您可以创建工作流来构建和测试存储库中的每个请求，或者将合并的请求部署到生产环境中。
GitHub Actions 组件 Workflows 工作流 工作流是一个可配置的自动化流程，它将运行一个或多个作业。工作流是由签入存储库的 YAML 文件定义的，并且在由 repository 中的事件触发时运行，或者可以手动触发，或者按照定义的时间表运行。
工作流在.github/workflows 目录中定义, 并且存储库可以有多个工作流，每个工作流可以执行不同的任务集。例如，您可以使用一个工作流来构建和测试拉请求，使用另一个工作流在每次创建发行版时部署您的应用程序，还可以使用另一个工作流在每次有人打开新问题时添加标签。
Events 事件 事件是存储库中触发工作流运行的特定活动。例如，活动可以来自 GitHub 创建请求(pull request)、打开问题(open an issue)或向存储库提交(push an commit)。您还可以通过向 REST API 发布或手动触发按计划运行的工作流。
Jobs 作业 作业是工作流中在同一运行程序上执行的一组步骤。每个步骤要么是将要执行的 shell 脚本，要么是将要运行的操作。步骤按顺序执行，并相互依赖。由于每个步骤都在同一个运行程序上执行，因此可以将数据从一个步骤共享到另一个步骤。例如，您可以有一个生成应用程序的步骤，然后有一个测试生成的应用程序的步骤。
Actions 动作 动作是 GitHub Actions 平台的自定义应用程序，它执行复杂但经常重复的任务。使用一个操作来帮助减少在工作流文件中编写的重复代码的数量。操作可以从 GitHub 获取 git 存储库，为构建环境设置正确的工具链，或者为云提供商设置身份验证o
Runners 运行器 运行器是在工作流被触发时运行它们的服务器。每个运行器可以一次运行一个作业。GitHub 提供 Ubuntu Linux、 Microsoft Windows 和 macOS 运行程序来运行您的工作流; 每个工作流运行在一个全新的、新配置的虚拟机中执行。GitHub 还提供了更大的运行器，可以进行更大的配置。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d23c4f3a6d0c0b3479da2493d4f6637a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50b8d3279cae579645486291400c7b45/" rel="bookmark">
			【娱乐大闯关】C语言实现奖牌榜文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、定义奖牌信息结构体二、从本地文件中读取奖牌文件三、显示读取的奖牌榜四、对奖牌榜排序a、交换函数b、排序 五、将排完序的奖牌榜重新存入本地文件中六、主函数完整代码附录执行框图 本程序主要体现对文件的存储的运用！！！
文件相关知识可参考：C语言文件（点击即可进入）
一、定义奖牌信息结构体 typedef struct LS{ char gjm[30]; int jp, yp, tp, jpzs, zpm; }ls; 二、从本地文件中读取奖牌文件 《冬奥会奖牌榜.txt》此文件需要自己放入文件夹中，作为最初文件！！
int Reading(ls* ip,int len){ char buffer[200]; FILE *fp = fopen("冬奥会奖牌榜.txt","r"); // 打开文件 int i=0; if(fp == NULL){ perror("fp"); return -1; } fgets(buffer, 199, fp); for(i=0;i&lt;len;i++){ fscanf(fp,"%s%d%d%d%d%d", ip[i].gjm, &amp;ip[i].jp, &amp;ip[i].yp, &amp;ip[i].tp, &amp;ip[i].jpzs, &amp;ip[i].zpm); if(feof(fp)) break;// 如果文件结束了，也退出循环 } fclose(fp); fp = NULL; return i+1; } 三、显示读取的奖牌榜 void Show(ls* ip,int len){ printf(" %s %s %s %s %s %s\n"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/50b8d3279cae579645486291400c7b45/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ff96e242fac7b9fcbc76782c8bede89/" rel="bookmark">
			【无标题】c语言 scanf
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		c语言scanf输入最好是分开输入；
如果连续输入中间最好不要加逗号，空格这些；
十进制输入%d%d%d中间可以空格
但是%c%c%c不能输入后空格或者回车 空格或者回车也占一个字符。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4b2f9e0bf3f0a56be06fe7016895b3a/" rel="bookmark">
			清空Github仓库方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		正文 学习Git的使用还是应该清楚原理，理解加记忆会更可靠
以下直入主题：
❗注意：新建一个空的本地仓库是不能顺利推送到远程仓库的，因为它们没有历史关系。但你可以先把原仓库的.git目录复制到一个空的文件夹内，然后再按照下面的提示做：
进入空文件夹内，鼠标右键打开Git Bash
执行代码 #查看git仓库状况(工作区文件被删除，等待add操作更新仓库stage区) git status #添加文件(在空工作区执行add命令，完成stage区中的delete操作) git add . #操作备注 git commit -m "仓库已清空" #添加远程仓库(已添加可以跳过) git remote add origin git@github.com:username/repositoryname #推送到远程仓库 git push -u origin master 做最后一步时，从本地仓库向Github远程仓库推送更新时可能会发生这样的错误：
$ git push -u origin master To github.com:code-2023/Java.git ! [rejected] master -&gt; master (fetch first) error: failed to push some refs to 'github.com:code-2023/Java.git' hint: Updates were rejected because the remote contains work that you do hint: not have locally.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d4b2f9e0bf3f0a56be06fe7016895b3a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c9aeeb80d84e0b8344079cacdad4055a/" rel="bookmark">
			朴素贝叶斯分类的python的实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 介绍GaussianNB()参数介绍实例 BernoulliNB()参数介绍实例 MultinomialNB()参数介绍实例 作者：王乐 介绍 sklearn 是 scikit–learn 的简称,是一个基于 Python 的第三方模块。
sklearn 库集成了一些常用的机器学习方法,在进行机器学习任务时,并不需要实现算法,只需要简单的调用 sklearn 库中提供的模块就能完成大多数的机器学习任务。
在sklearn中，一共有3个朴素贝叶斯的分类算法类：
GaussianNB（先验是高斯分布的朴素贝叶斯）；
BernoulliNB（先验为伯努利分布的朴素贝叶斯）；
MultinomialNB（先验是多项式分布的朴素贝叶斯）。
高斯NB用于连续值；多项式NB用于离散的多值；伯努利NB用于离散的二值。
高斯朴素贝叶斯则常用于连续特征的情况下。高斯朴素贝叶斯假设特征满足高斯分布（正态分布）。 如特征为“某地高中生的身高”时，就使用高斯朴素贝叶斯。
实例化模型对象的时候，不需要对高斯朴素贝叶斯类输入任何的参数，可以说是一个非常轻量级的类，操作非常容易。
但过于简单也意味着贝叶斯没有太多的参数可以调整，因此贝叶斯算法的成长空间并不是太大，如果贝叶斯算法的效果不是太理想，我们一般都会考虑换模型。
GaussianNB()参数介绍 GaussianNB(*, priors=None, var_smoothing=1e-09) 参数:
priors : array-like of shape (n_classes,),Prior probabilities of the classes. If specified the priors are not adjusted according to the data.
先验：数组-（n_classes,）每一类的先验概率。如果指定先验概率，则不会根据数据调整先验概率。
var_smoothing : float, default=1e-9
方差平滑：浮点数，默认=1e-9，为了计算稳定性而添加到方差中的所有特征的最大方差部分。
属性：
类别数 class_count_：ndarray of shape (n_classes,)，在每个类中观察到的训练样本数。
类别先验概率 class_prior_：ndarray of shape (n_classes,)，每个类别的先验概率。
类标签 classes_：ndarray of shape (n_classes,)，分类器已知的类标签。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c9aeeb80d84e0b8344079cacdad4055a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d90655de922cd548c4b13e242bd675a/" rel="bookmark">
			项目接口文档
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		状态码 401 未登录 需跳转到登陆页面 403 无权限 用户方面 用户注册 url /user/register post ,body
{ "userName": "admin", "password": "demoData" } 返回体
{ "success": false, "code": 200, "message": "用户名已存在", "data": null } 或者 { "success": true, "code": 200, "message": null, "data": null } 用户查询 条件分页查询
post url: /user/queryUserPage body
入参
{ "size": 10, "current": 1, //查询的页码 从 第一页开始 // 下面的都是可选条件 不选则不用传 "userId": 0, "userName": "demoData", "nickName": "demoData", "password": "demoData", "salt": "demoData", "sex": "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9d90655de922cd548c4b13e242bd675a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c330c21f5c961e6b62e8cee5cf09d684/" rel="bookmark">
			实验室预约系统|基于Springboot&#43;Vue实现学校实验室预约管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者简介：全栈开发工程，从事Java、Python、前端、小程序方面的开发和研究，对大数据应用与开发比较感兴趣，
主要内容：Java项目、前端项目、Python项目、小程序开发、大数据项目、单片机
收藏点赞不迷路 关注作者有好处
文末获取源码 感谢您的关注，请收藏以免忘记，点赞以示鼓励，评论给以建议，爱你哟
项目编号：BS-XX-167
一，项目简介 学校中的实验设备是属于全校师生共用的教学资源。由于学校实验室个数及每门课程相关实验室课时数的有限性，使得实验室不可能像普通教室那样按周次进行固定排课。当前实验教室的排课普遍采用人工预约的方法，这种方式无论在人员联系上还是实验室安排上都很不方便。预约一个教室的周期往往在两周以上，极大地影响了教学进度的安排，并且由于实验室教室的分散性，往往会出现一个教室爆满而另一个闲置的不对称使用情况，在这种情况下，开发一种全校实验室资源共享、合理分配教室资源、远距离操作实验室预约系统就显得尤为必要。
在国外，预约系统早就起源并且早已经扩展开来。基于ASP的高校实验网络管理系统,也可为学生提供一种选修自己喜欢实验的途径。有些系统允许学生通过校园网选修实验,它具有实验预约、查询等功能。
在国内，现在一般是用ASP做实验预约系统。预先查看几个比较典型的实验预约系统:长江大学电子信息学院开发的长江大学电工电子实验预约系统，它是一个实验预约管理系统，提供学生和教师登录预约，教师和学生登录后的功能不一样，教师登录后还可以对学生进行实验管理:学生可以进行实验预约，只是该系统有时候学生预约并不开放，以教师预约为主。这是国内目前功能比较完善的实验预约系统。绍兴文理学院的开放实验网上预约系统预约实现了可选择的实验进行预约和取消预约，可以轻松查看实验室状况，不过此系统封闭性不强，任何注册人员都可以进行预约，这给系统管理带来了负面影响。另外，最近在网上还出现了一个简单的网上实验预约系统，简单实现了预约功能，也是一个纯粹的实验预约系统，用户可以随时进行注册并预约实验，又没有取消预约的功能，而且此系统维护不够，预约得不到管理员的批准与调配。但这也说明预约系统现在在国内比较盛行，大家在勇于攀登，在不断完善实验预约系统的功能。
本系统实现实验室预约。系统共设有用户登录、实验室预约、预约情况查询、管理员管理等四个主要的功能模块，满足了教师/学生进行实验室预约/查询、管理员进行管理等各个方面的需求。它具有网络化、智能化、高性能、低维护、界面友好、操作简单、功能强大、管理方便、平台优秀等一系列的优点，能够完全按照用户的需求，稳定、安全、快速地运行，实现了任意计算机都能进行实验室预约信息的查询，进行实验室预约操作，访问相关信息。从而充分利用了学校现有的资源，促进了教学管理系统的网络化，智能化，顺应了教学管理的发展趋势。
二，环境介绍 语言环境：Java: jdk1.8
数据库：Mysql: mysql5.7
应用服务器：Tomcat: tomcat8.5.31
开发工具：IDEA或eclipse
后台技术：Springboot+Mybatis-plus
前端技术：Node+Vue+ElementUI
三，系统展示 用户登陆
公告栏
公告管理
设备管理
实验室管理
实验结果管理
教师管理
学生管理
预约信息管理
四，核心代码展示 package com.project.labsystem.controller; import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper; import com.baomidou.mybatisplus.extension.plugins.pagination.Page; import com.project.labsystem.entity.AnnouncementTable; import com.project.labsystem.entity.LabTable; import com.project.labsystem.entity.VO.announcementVo; import com.project.labsystem.entity.VO.labVo; import com.project.labsystem.service.LabTableService; import com.project.labsystem.utils.R; import io.swagger.annotations.Api; import io.swagger.annotations.ApiOperation; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.util.StringUtils; import org.springframework.web.bind.annotation.*; import org.springframework.web.multipart.MultipartFile; import java.util.ArrayList; import java.util.List; /** * &lt;p&gt; * 前端控制器 * &lt;/p&gt; * * @author byAuto * @since 2022-10-24 */ @Api(description = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c330c21f5c961e6b62e8cee5cf09d684/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/681417a2002399070ae47d11f2b2fe53/" rel="bookmark">
			#PCIE# PCIe扫盲——链路初始化与训练基础（三）之LTSSM
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这一篇文章来简单地介绍一下链路训练状态机（Link Training and Status State Machine，LTSSM），并简要地介绍各个状态的作用和实现机制。
LTSSM有11个状态（其中又有多个子状态），分别是Detect、Polling、Configuration、Recovery，L0、L0s、L1、L2（L3是可选的）、Hot Reset、Loopback和Disable状态。系统进行复位操作（Cold, Hot or Warm Reset）后，会自动进入Detect状态。
这11个状态又可以被分为以下五个类别：
1、链路训练状态（Link Training State）；
2、重训练状态（Re-Training（Recovery） State）；
3、软件驱动功耗管理状态（Software Driven Power Management State）；
4、活动状态功耗管理状态（Active-State Power Management State，ASPM State）；
5、其他状态（Other State）；
如下图所示：
下面分别简要地介绍一下各个状态：
首先是Detect：
前面说到，系统进行复位操作（Cold, Hot or Warm Reset）后，会自动进入Detect状态。在这个状态中，PCIe设备会去检测自己Link的另一端是否存在其他PCIe设备。换句话说，就是检测有没有其他的PCIe设备与其相连接。如下图所示：
Polling：
在该状态中，PCIe设备会依次发送TS1OS和TS2OS以实现以下目标：
1、位锁定（Bit Lock）；
2、字符锁定（Symbol Lock）；
3、信号极性翻转（Polarity Inversion），如果需要的话；
4、确定各个设备支持的速率（Data Rates）。
如下图所示：
Configuration：
在该状态中，PCIe设备会依次发送TS1OS和TS2OS以实现以下目标：
1、确定链路宽度（Link Width）；
2、分配通道（Lane）号；
3、通道位置翻转（Lane Reversal），如果需要的话；
4、通道对齐（Lane-to-Lane De-skew）。
如下图所示：
L0：
这是链路（Link）的正常状态（Normal and Full-Active State），所有的TLP、DLLP和Ordered Sets都可以被正常的收发。该状态下，速率可以是2.5GT/s或者是5GT/s（如果链路两端设备都支持的话，且经过了Re-Trainning）。
Recovery：
这个状态用于Re-Trainning，因此Re-Trainning可能会改变原有的速率，所以位锁定（Bit Lock）和符号锁定（Symbol Lock）操作都会被重新进行，但是花费的时间要比第一次少很多。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/681417a2002399070ae47d11f2b2fe53/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7ae6f41f2e5444845ff8ae93fab5675/" rel="bookmark">
			SM社区医院健康管理网站
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开发工具(eclipse/idea/vscode等)：eclipse
数据库(sqlite/mysql/sqlserver等)：mysql
功能模块(请用文字描述，至少200字)：使用eclipse作为开发工具，采用Java语言和SSM框架技术综合开发，完成基于SSM的社区医院健康管理平台设计与实现。（1)用户和医疗人员注册、登录及管理;
(2）在线咨询，用户可通过平台选取值某科室值班医师进行在线交流;(3)线下预约，用户可通过平台选取值某科室值班医师进行约;
(4)药品管理，医师可查看单签药品库存和药品信息，管理员可对药品进行更新和管理;(5)处方查看，通过（2）或(3）的用户在缴费完成后可查看处方;
(6）费用支付，用户在就诊完毕后可通过此功能完成缴费。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d432f092730e83f60a558b46a4675cfb/" rel="bookmark">
			Flutter GetX系列教程---国际化配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装 将 GetX 添加到你的 pubspec.yaml 文件中
dependencies: get: ^4.6.5 在需要用到的文件中导入，它将被使用。
import 'package:get/get.dart'; 国际化配置 在我们使用系统自带MaterialApp来实现国际化配置，需要进行很多配置，而且还需要手动去依赖第三方组件，而使用GetX来实现国际化配置，你只需要一行代码即可实现切换，接下来我们看一下具体实现。
translations： 国际化配置文件
locale： 设置默认语言，不设置的话为系统当前语言
fallbackLocale： 配置错误的情况下,使用的语言
main.dart
import 'package:flutter/material.dart'; import 'package:get/get.dart'; import 'package:untitled/Message/MessagesController.dart'; import 'Message/Messages.dart'; void main(){ return runApp(Home()); } class Home extends StatelessWidget { MessagesController messagesController = Get.put(MessagesController()); @override Widget build(BuildContext context) { return GetMaterialApp( translations: Messages(), locale: Locale('zh', 'CN'), //设置默认语言 fallbackLocale: Locale("zh", "CN"), // 在配置错误的情况下,使用的语言 home: Scaffold( appBar: AppBar( title: Text("国际化"), ), body: Center( child: Column( mainAxisAlignment: MainAxisAlignment.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d432f092730e83f60a558b46a4675cfb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a906b685ef999d9c12a66011a2450940/" rel="bookmark">
			前端流程图插件jsPlumb教程附一个简单demo
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1，前言2，API介绍2.1，基本概念2.2，连接两个节点2.3，可拖动节点2.4，给连接加上箭头2.5，增加一个端点2.6，拖动端点连线2.7，限制节点拖动区域2.8，给链接添加点击事件：点击删除连线2.9，指定端点连接2.10，一个端点拖拽出多条连线3，实现代码3.1，先初始化3.2，设置连线和端点的样式**3.3，左侧初始元素开启拖动3.4，在右侧界面放置节点3.5，鼠标进入和移出新节点时显示删除和设置按钮3.6点击删除按钮删除节点3.7，双击删除连线3.8，点击保存按钮3.9，点击删除按钮3.10，页面加载时识别缓存的json节点信息并还原 1，前言 我司要做一个工作流的应用，参考轻流BPM的工作流交互逻辑，看了一下太难了，所以退而求其次，先做成visio这样的拖拽式流程设计。第一次接触jsplumb，文档都是在网上搜的，所以自己就整理一下，结合自己的一些应用，做了一个demo，留待以后有需要。
demo用到的插件有：JsRender.js模板引擎、jquery、jquery-ui、Bootstrap的icon、以及jsplumb.js。
2，API介绍 先简单介绍下jsplumb的一些用法，稍微详细的请移步jsplumb 中文基础教程。
2.1，基本概念 源节点：Souce 目标节点：Target 锚点：Anchor 端点：Endpoint 连接：Connector 2.2，连接两个节点 jsPlumb.ready方法和jquery的ready方法差不多的功能，jsPlumb.connect用于建立连线
&lt;div id="diagramContainer"&gt; &lt;div id="item_left" class="item"&gt;&lt;/div&gt; &lt;div id="item_right" class="item" style="margin-left:50px;"&gt;&lt;/div&gt; &lt;/div&gt; &lt;script src="https://cdn.bootcss.com/jsPlumb/2.6.8/js/jsplumb.min.js"&gt;&lt;/script&gt; &lt;script&gt; jsPlumb.ready(function () { jsPlumb.connect({ source: 'item_left', target: 'item_right', endpoint: 'Dot' }) }) &lt;/script&gt; 2.3，可拖动节点 &lt;div id="diagramContainer"&gt; &lt;div id="item_left" class="item"&gt;&lt;/div&gt; &lt;div id="item_right" class="item" style="left:150px;"&gt;&lt;/div&gt; &lt;/div&gt; &lt;script src="https://cdn.bootcss.com/jsPlumb/2.6.8/js/jsplumb.min.js"&gt;&lt;/script&gt; &lt;script&gt; jsPlumb.ready(function () { jsPlumb.connect({ source: 'item_left', target: 'item_right', endpoint: 'Rectangle' }) jsPlumb.draggable('item_left') jsPlumb.draggable('item_right') }) &lt;/script&gt; 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a906b685ef999d9c12a66011a2450940/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2c00391c1ed4274dda6013e3659648c/" rel="bookmark">
			el-table / u-table 大屏自动滚动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用背景 大屏使用el-table进行数据自动滚动
注意 一次性获取所有数据显示并自动滚动，不再获取分页大屏列表数据滚动的时候，如果数据量少，则可使用el-table组件；如果数据量多，则使用u-table组件，避免卡顿功能：获取数据后列表自动滚动，鼠标移入列表停止滚动，移出则继续滚动 实现步骤 列表代码，这里以u-table为例 &lt;u-table ref="table" :data="tableData" highlight-current-row use-virtual :row-height="35" row-key="id" @cell-mouse-enter="mouseEnter" @cell-mouse-leave="mouseLeave" :height="500px" :key="tableKey"&gt; &lt;u-table-column align="center" prop="no" label="单号" show-overflow-tooltip min-width="120" /&gt; &lt;u-table-column align="center" prop="name" label="名称" show-overflow-tooltip min-width="150" /&gt; &lt;u-table-column align="center" prop="date" label="日期" show-overflow-tooltip min-width="100" /&gt; &lt;u-table-column align="center" prop="status" label="状态" show-overflow-tooltip min-width="80"&gt; &lt;template #default="scope"&gt; &lt;span v-if="scope.row.status === 10" class="status-10"&gt;未接收&lt;/span&gt; &lt;span v-if="scope.row.status === 20" class="status-7"&gt;部分接收&lt;/span&gt; &lt;/template&gt; &lt;/u-table-column&gt; &lt;/u-table&gt; js代码 &lt;script&gt; export default { data() { return { tableData: [], tableKey: +new Date(), scrollTop: 0//table距离顶部距离 }; }, mounted() { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d2c00391c1ed4274dda6013e3659648c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42d0da80506ebd91bcdaac95289c0708/" rel="bookmark">
			现在考系统集成项目管理工程师有用吗？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有用！
现在考系统集成项目管理工程师还是挺有用的哈，虽然它资质评定国务院取消了，但它是由国家人力资源和社会保障部、工业和信息化部领导下的国家级考试，并且是职业资格考试、职称资格考试和水平考试。
系统集成项目管理工程师证书主要作用如下： 1.国企、事业单位评职称 系统集成项目管理工程师属于中级职称证书，是可以评中级职称的。有了职称后，在落户、养老金、薪资待遇等方面都有很多好处的。
2.个税抵扣 系统集成项目管理工程师证书属于职业资格证书，按照规定拿到证书的那一年是可以抵扣个人所得税的。
在备考的友，可以来这里，有ziliao共享，考友互助。
---&lt;&lt;&lt;点击链接加入群聊【软考系统集成项目管理】&gt;&gt;&gt;
3.积分落户 在很多大城市都有积分落户的政策，而系统集成项目管理工程师证书就可以加分，更方便在自己在大城市落户了。以上海为例，中级专业技术类的职业资格证书是可以积100分的，也就是说系统集成项目管理工程师证书在上海可以加100分。
4.证书优势 在相关行业里，很多公司都会要求求职者有相关证书，系统集成项目管理工程师证书也是一样的，有了这个证书，自己在找工作上回有很大的优势。
5.公司资质需要 公司参加相关项目时需要一定的资质，而相关证书就是资质的评判要求之一，所以公司会鼓励员工考相关证书，并给予一定的现金奖励。
更多内容，持续更新中，欢迎一起交流学习~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db567f7c3eb9fc28dc2c425b1186819c/" rel="bookmark">
			让自己成为一个创作者
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写博客三年多，创作不易，以下是自己的一点感悟，大家共勉！
“千万不要把“创作”当成是一件很大的事情，那只是思维方式和行为的转变而已！”
01
—
我有个爱好--打游戏，
特别喜欢宫崎英高的魂系游戏。
在游戏中，只要击杀了超难的BOSS，就会让我觉得很“爽”。
我还有个爱好--写博客，
我发现，写博客，不仅让我在学习上有所收获，
更能给我带来满足感。
当然，两者带来的快乐是有不同的：
打游戏带来的“爽”感，是短暂的，转瞬即逝，
前一分钟还在回味击杀BOSS的快感，
放下游戏手柄的功夫就没了。
写博客带来的满足感，则会更长久，
因为，在学习的时候，需要思考，在写博客的时候，更需要思考，
深度思考留下的“印痕”，
会让我回味，会给我慰藉。
虽然我觉得，喜欢写博客并不比喜欢打游戏来得更高级，
但有时候，打游戏时间长了，我会产生内疚，
感觉自己像是虚度了光阴。
而创作，就有一个明确的目标，
给我的感觉是充实，
如果我输出的观点还能得到读者的反馈，
我还会有些许成就感。
这两种感觉的区别，让我对自己发出了灵魂拷问：
同样让自己快乐的事情，为什么感觉上会有这么大的差异呢？
难道是虚荣心在作怪？
02
—
其实不然！
打游戏这个爱好，我享受它，只是尽兴。
写博客这个爱好，我享受它，那是“创作”。
千万不要把“创作”当成是一件很大的事情，
那只是思维方式和行为的简单转变而已。
比如，我除了爱打游戏，
我还会想：“我是不是应该制作一个通关视频，让更多的人看到它？”
然后，我真的这样去做了。
还比如，我本来就喜欢读书，
并且读了书后，我还会有很多思考，
我会想：“我应该把这些思考都记录下来，形成自己的观点，说不定对别人也有帮助？”
然后，我真的这样去写了。
一旦你试着去构思、取材、加工，输出，
让自己去经历从想到做的整个过程，
你的感觉就完全不一样了，
你成了一个“创作”者，
你像是在“玩“一种更好玩、更有趣、更高级的“游戏”，
自然，你也会”享受“到一种更高层级的快乐。
这让我想到了马斯洛需求层次理论：
也许，生理、安全、归属、爱和尊重都是属于尽兴级的满足，
而自我实现则是“创作“级的快乐了。
03
—
实话实说，我们现在的教育，
它不会教人主动“创作”，
它只不过是为了培训出更多的参与者。
而创作者的思维方式与参与者的思维方式是完全不同的，
作为一位创作者，
需要你具备看待事物的独特视角，
也需要你有更丰富、更细腻的审美感，
更需要你从事物的底层原理去思考问题，
甚至，层次再高一点：
如果你有某种爱好，试着不要只是“玩”，
而是反问自己：我是否能够加入进来，创作一些东西？
为了创作这些东西，我需要哪些能力？
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34c51c9c9d858720c7c944dc553e80a5/" rel="bookmark">
			Thingsboard入门教程：本地环境搭建和源码编译安装，献给thingsboard编译失败的同学，教程不断完善中，文章最后是thingsboard常见编译失败的问题总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于ThingsBoard二次开发的物联网平台推荐：ThingsKit物联网平台，开箱即用的物联网低代码平台，提供N+1+N的产品服务体系，帮助企业快速搭建稳定可靠的物联网系统平台，为企业节省大量时间及人力成本。www.thingskit.com
欢迎加入ThingsBoard技术交流群 群号：69998183
环境安装 开发环境要求：
Jdk 1.8版本
Postgresql 9以上
Node.js
Npm
Maven 3.6以上
Git工具
Idea开发工具
Redis
JDK 下载安装
JDK官方下载地址： https://www.oracle.com/java/technologies/javase-jdk8-downloads.html
JDK版本选择JDK8，我本地环境是Windos10 64位，所以选择jdk-8u221-windows-x64.exe
下载好了之后直接默认安装就行
配置环境变量
步骤1：
在JAVA_HOME中增加JDK的安装地址：C:\Program Files\Java\jdk1.8.0_221
步骤2：
在CLASSPATH中增加JDK的安装地址中的文件：.;%JAVA_HOME%\lib;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar
步骤3：
在Path中增加JDK的地址：%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin;
步骤4
输入以下命令
java -version 如果能出现以下的提示信息，就算安装成功了
安装IDEA 参考：IDEA安装教程
安装Maven 步骤1：下载maven，进入地址：http://maven.apache.org/download.cgi
步骤2：下载到本地
步骤3：配置环境变量
增加MAVEN_HOME，即maven的地址：D:\tb\apache-maven-3.6.1-bin，请注意，如果直接解压，有可能会有两个apache-maven-3.6.1-bin
MAVEN_OPTS，参数是 -Xms128m -Xmx1024m
修改Path，增加Maven的地址%MAVEN_HOME%\bin;
测试Maven安装，打开命令行工具。使用命令mvn -v，如果能出现以下提示，即安装成功
Nodejs安装 步骤1：下载Nodejs安装包，Nodejs官网地址：https://nodejs.org/en/download/
步骤2：安装完成后，使用命令查看Nodejs是否已经安装完成，能出现以下提示说明已经安装成功
安装git 步骤1：下载git安装包，git官网地址是：https://git-scm.com/download/win
步骤2：安装完成后，使用命令行测试git
安装npm全局依赖 步骤1：使用管理员CMD命令行，执行下面命令
#npm 环境读取环境变量包 npm install -g cross-env #webpack打包工具 npm install -g webpack 安装redis Redis安装参考：https://www.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/34c51c9c9d858720c7c944dc553e80a5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b9f3a5347d0ef468aeb7e6d347c5593/" rel="bookmark">
			使用 systemd 配置 reids 服务 加入开机自启
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 使用 systemd 配置 reids 服务 加入开机自启 vim /usr/lib/systemd/system/redis.service [Unit] Description=redis service After=network.target [Service] Type=forking ExecStart=/bin/bash -c '/root/app/redis/redis-4.0.2/src/redis-server /root/app/redis/redis-4.0.2/redis.conf' ExecStop=/bin/bash -c '/root/app/redis/redis-4.0.2/src/redis-cli shutdown' Restart=always [Install] WantedBy=multi-user.target systemctl daemon-reload systemctl start redis.service systemctl status redis.service systemctl enable redis.service 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/517c579a3312e5b301c3a76cb4d4e9c6/" rel="bookmark">
			Qt之软键盘的实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、基于中文汉字数据库1、核心代码2、效果 二、基于谷歌拼音输入引擎1、核心代码2、效果 前言 Qt5.8版本开始推出了基于QML实现的软键盘功能，在此之前，并没有官方版本的软键盘。本篇主要介绍Qt实现软键盘的两种方案，一种基于中文汉字数据库，一种基于谷歌拼音输入引擎。
第一种中文提示有所限制，不够智能，建议使用第二种方案，Qt官方推出的软键盘也是基于谷歌拼音输入引擎实现的。
一、基于中文汉字数据库 这种方式将中文汉字存放在py.db文件中，按照拼音去库中查询匹配的汉字，然后将多个查询结果显示出来。
工程组织结构，如下：
1、核心代码 核心代码如下：
//事件过滤器,用于识别鼠标单击汉字标签处获取对应汉字 bool frmInput::eventFilter(QObject *obj, QEvent *event) { if (event-&gt;type() == QEvent::MouseButtonPress) { QMouseEvent *mouseEvent = static_cast&lt;QMouseEvent *&gt;(event); if (mouseEvent-&gt;button() == Qt::LeftButton) { if (obj == ui-&gt;labCh0) { setChinese(0); } else if (obj == ui-&gt;labCh1) { setChinese(1); } else if (obj == ui-&gt;labCh2) { setChinese(2); } else if (obj == ui-&gt;labCh3) { setChinese(3); } else if (obj == ui-&gt;labCh4) { setChinese(4); } else if (obj == ui-&gt;labCh5) { setChinese(5); } else if (obj == ui-&gt;labCh6) { setChinese(6); } else if (obj == ui-&gt;labCh7) { setChinese(7); } else if (obj == ui-&gt;labCh8) { setChinese(8); } else if (obj == ui-&gt;labCh9) { setChinese(9); } else if (currentEditType !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/517c579a3312e5b301c3a76cb4d4e9c6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/653be47b0eb4a9e7fbb4a1806a4cfc35/" rel="bookmark">
			软件工程毕设选题推荐 40个高质量计算机毕设项目分享【源码&#43;论文】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言 题目1 : 基于SSM的员工/学生宿舍后勤管理系统 &lt;br /&gt; 题目2 : 基于SSM的勤工助学管理系统 &lt;br /&gt; 题目3 : 基于SSM的停车位短租网站&lt;br /&gt; 题目4 : 基于SSM的网上购物商城系统 &lt;br /&gt; 题目5 : 基于ssm在线医疗诊断跟踪系统&lt;br /&gt; 前言 🔥 这两年开始毕业设计和毕业答辩的要求和难度不断提升，传统的java web缺少创新和亮点，往往达不到毕业答辩的要求，这两年不断有学弟学妹告诉学长自己做的java web管理系统达不到老师的要求。
为了大家能够顺利以及最少的精力通过毕设，学长分享5个优质java web毕业设计项目，需要的自取。
题目1 : 基于SSM的员工/学生宿舍后勤管理系统 🥇 题目综合评分(每项满分5分)
难度系数：3分工作量：5分创新点：3分界面美化：5分 🥇 相关技术和工具 :
开发语言：Java框架：ssmJDK版本：JDK1.8服务器：tomcat7数据库：mysql 5.7（一定要5.7版本）数据库工具：Navicat11开发软件：eclipse/myeclipse/ideaMaven包：Maven3.3.9 🥇 功能模块
管理员：首页、个人中心、员工管理、公寓信息管理、公寓户型管理、员工积分管理、系统管理、订单管理员工：首页、个人中心、员工积分管理、我的收藏管理前台首页：首页、公寓信息、通知公告、个人中心、后台管理、在线客服 题目2 : 基于SSM的勤工助学管理系统 🥇 题目综合评分(每项满分5分)
难度系数：3分工作量：5分创新点：3分界面美化：5分 🥇 相关技术和工具 :
开发语言：Java框架：ssmJDK版本：JDK1.8服务器：tomcat7数据库：mysql 5.7（一定要5.7版本）数据库工具：Navicat11开发软件：eclipse/myeclipse/ideaMaven包：Maven3.3.9 🥇 功能模块
管理员：首页、个人中心、学生管理、老师管理、学生考勤管理、老师考勤管理、岗位工作管理、岗位申请管理、申请情况管理、系统管理老师管理台：首页、个人中心、老师考勤管理、岗位工作管理、岗位申请管理、申请情况管理后台：首页、个人中心、学生考勤管理、岗位申请管理、申请情况管理 题目3 : 基于SSM的停车位短租网站
🥇 题目综合评分(每项满分5分)
难度系数：3分工作量：5分创新点：3分界面美化：5分 🥇 相关技术和工具 :
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/653be47b0eb4a9e7fbb4a1806a4cfc35/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e5742d9cad986fd3396eb520dcf371f/" rel="bookmark">
			input框禁止输入空格
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vue 使用 v-model.trim 可以去掉首尾的空格完全不能输入的话，可以使用下面的方法 &lt;input type="text" οnkeyup="this.value=this.value.replace(/\s+/g,'')"&gt; 3.表单中使用，可以使用下面的方法
&lt;Form ref="formItem" :model="formData"&gt; &lt;FormItem prop="qualitative"&gt; &lt;Input type="textarea" maxlength="10" show-word-limit :autosize="{ minRows: 5,maxRows: 5 }" v-model="formData.qualitative" :onkeyup="formData.qualitative = formData.qualitative.replace(/\s+/g,'')"&gt; &lt;/Input&gt; &lt;/FormItem&gt; &lt;/Form&gt; 相关链接：input框 禁止输入空格 - 泽泽生龙 - 博客园
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0517a02944abfc468a6062790a7bf44/" rel="bookmark">
			如何通过Kubectl 重启Pod的六种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家可能都知道 kubectl 其实没有 restart pod 这个命令，这个主要是由于在 k8s 中pod 的管理属于rs 等控制器，并不需要运维手动维护，但有时候，我们修改了configmap 的配置文件后，希望重启pod 加载配置，此时就需要 “重启” Pod。 大家可能都知道 kubectl 其实没有 restart pod 这个命令，这个主要是由于在 k8s 中pod 的管理属于rs 等控制器，并不需要运维手动维护，但有时候，我们修改了configmap 的配置文件后，希望重启pod 加载配置，此时就需要 “重启” Pod。这里说的“重启”是加了引号的，准确地来说，是重建pod，给用户的感觉是重启。
下面介绍六种k8s 里面重启pod的方式
方法一：kubectl rollout restart
这个命令是比较推荐的，通过
kubectl rollout restart deployment -n 便可以重建这个deployment下的 pod，和滚动升级类似，并不会一次性杀死Pod，比较平滑。
方法二：kubectl scale
这种方法相对来说，比较粗放，我们可以先将副本调成 0
kubectl scale deployment -n --replicas=0 然后再改回目的副本数
kubectl scale deployment -n --replicas=10 方法三： kubectl delete pod
这个我就不解释了
kubectl delete pod -n 还是多说一句，此时优雅删除的效果还是有的。再多说一句，直接删 rs 效果也挺好。
方法四：kubectl replace
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c0517a02944abfc468a6062790a7bf44/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc453cf3390238292afbb9688cd0e68c/" rel="bookmark">
			关于tf.keras的模型加载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		加载模型使用model.load_weights函数
model.load_weights(model_path, by_name=True, skip_mismatch=True) by_name=False 的时候按照网络的拓扑结构加载权重
by_name=True 的时候就是按照网络层名称进行加载
skip_mismatch:bool值, 这个只有在by_name=True时才会生效, 当具有相同名字的层的权重个数或形状不一样时,就不加载这些权重.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f253b006989b6f895cf43a32c4ed0e9/" rel="bookmark">
			vue的生命周期、动画
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、vue的生命周期： vue的生命周期：从vue实例创建到销毁之间的各种事件
生命周期函数=生命周期事件=生命周期钩子
主要有八种生命周期：
1.beforeCreate:第一个生命周期，表示实例完全被创建出来之前,会执行它。
beforeCreate() { console.log(this.msg); console.log('beforeCreate'); }, 2.created：第二个生命周期,初始化已经完成，是第一个可以操作data,methods的生命周期
created() { console.log('created'); console.log(this.msg); }, 3.beforeMount：第三个生命周期,挂载的虚拟的DOM，模板已经存在内存中但并没有渲染到页面上
beforeMount() { console.log('beforeMount'); }, 4.mounted：第四个生命周期,挂载的真实的DOM，我们可以内存中的模板已经渲染到了页面上，是实例创建的最后一个生命周期
mounted() { console.log('mounted'); }, 5.beforeUpdate：第五个生命周期,data中的数据更新完成，但页面中的数据依然是旧数据
beforeUpdate() { console.log('beforeUpdate'); }, 6.update：第六个生命周期,data和页面中的数据都是新的
updated() { console.log('updated'); }, 7.beforeDestroy：第七个生命周期,在销毁之前的，会清空所有监听和定时器
beforeDestroy() { console.log('beforeDestroy'); }, 8.beforeDestroy：第八个生命周期,最后一个生命周期，销毁完成
destroyed() { } 二、vue动画 需要使用transition 的封装组件，如：
&lt;transition&gt; &lt;div v-show="flag"&gt; {{msg}} &lt;/div&gt; &lt;/transition&gt; 在进入/离开的过渡中，会有 6 个 class 切换。
1.v-enter：定义进入过渡的开始状态：
.v-enter { transform: translateX(500px); } 2.v-enter-active：定义进入过渡生效时的状态。这个类可以被用来定义进入过渡的过程时间，延迟和曲线函数。：
.v-enter-active { transition: all 2s; } 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0f253b006989b6f895cf43a32c4ed0e9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61d1039849af551a96ee93cd2fd338f1/" rel="bookmark">
			利用OpenCV的函数resize()实现图像的缩放(尺寸变换)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		可以利用OpenCV的函数resize()实现图像的缩放(尺寸变换)。
函数resize()的C++原型如下：
void resize(InputArray src, OutputArray dst, Size dsize, double fx=0, double fy=0, int interpolation=INTER_LINEAR ) 函数resize()的Python原型如下：
dst=cv.resize(src, dsize[, dst[, fx[, fy[, interpolation]]]]) 各参数的意义如下：
src—源图像
dst—目标图像,即输出图像
dsize:输出图像的尺寸，当它为0的时候，由参数fx和fy决定其值，计算公式为：dsize = Size(round(fxsrc.cols), round(fysrc.rows))
fx—水平方向上的缩放比例因子，当它为0的时候，其值由dsize决定，计算公式为：fx=(double)dsize.width/src.cols
fy—竖直方向上的缩放比例因子，当它为0的时候，其值由dsize决定，计算公式为：fy=(double)dsize.height/src.rows
注意：当参数dsize、fx、fy都不为0，且表示的输出图像尺寸不一致时，以参数dsize设置的输出图像尺寸为准。
interpolation—插值方式，在OpenCV4中通常有七种可选的插值方法，默认为“INTER_LINEAR”。七种插值方式如下:
INTER_NEAREST：最近邻插值。INTER_LINEAR：双线性插值（默认值）。INTER_CUBIC：双三次插值。INTER_AREA - 使用像素面积关系重新采样。这可能是图像抽取(decimation)的首选方法，因为它可以获得无莫尔条纹的结果。但是当图像被放大时，它类似于INTER_NEAREST方法。INTER_LANCZOS4—8x8邻域上的Lanczos插值。INTER_LINEAR_EXACT —位精确双线性插值。INTER_MAX—用掩模进行插值。
对于上面的插值方式，具体的数学原理，请大家去查阅相关书籍和文档，这里就不介绍了。
一般来讲，如果要缩小图像，通常用 INTER_AREA会有较好的效果；而放大图像时通常采用INTER_CUBIC和INTER_LINEAR会有比较好的效果，前者的计算速度较慢，后者的速度较快，但前者的效果比后者的效果好。 函数resize()的C++示例代码如下：
代码中用到的图像下载链接：
https://pan.baidu.com/s/1Kr12nBJPqcIlAuyFp78gUw?pwd=e5sx
//出处：昊虹AI笔记网(hhai.cc) //用心记录计算机视觉和AI技术 //博主微信/QQ 2487872782 //QQ群 271891601 //欢迎技术交流与咨询 //OpenCV版本 OpenCV3.0 #include &lt;opencv2/opencv.hpp&gt; #include &lt;iostream&gt; using namespace std; using namespace cv; int main() { cv::Mat srcImage = cv::imread("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/61d1039849af551a96ee93cd2fd338f1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6406b72ac311a8b0483e517d473197a/" rel="bookmark">
			vuex组件传参
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vuex 实现数据的全局共享，响应式更新
每一个Vuex应用的核心就是store (仓库)。"store'基本. 上就是一个容器， 它包含着你的应用中大部分的
状态(state)。Vuex 和单纯的全局对象有以下两点不同:
Vuex的状态存储是响应式的。当Vue组件从store中读取状态的时候，若store中的状态发生变化,那
么相应的组件也会相应地得到高效更新。在任意组件都可以访问 store状态中的数据
import Vuex from ' vuex' Vue.use (Vuex) export default new Vuex. Store({ state: { // 定义(数据) user: { nane: "zeng8", score: 280, } } 使用
名字：{{$store. state .user.name}} 积分: {$store.state.user .score}} 你不能直接改变store中的状态。改变store 中的状态的唯一途径就是 显式地提交(commit) mutation。
mutations: { //改变数据的唯一方式只能在mutations 里面 //建议方法名大写，默认一个岁数是state //第二岁数就是方法调用传入的参数 SET_ SCORE(state , data){ state.score = data; } }， 使用
组件中访问 $store.commit("ADD_ SCORE' ,200) 这样使得我们可以方便地跟踪每-个状态的变化，从而让我们能够实现-些工具帮助我们更好地了解我们的应用。
state - data 数据
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d6406b72ac311a8b0483e517d473197a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54c31735972cd89d4badccb751fa8bc6/" rel="bookmark">
			python 装饰器详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python 装饰器详解 时间:2019-01-14
转自：python 装饰器详解 - 码农教程
本文章向大家介绍python 装饰器详解，主要包括python 装饰器详解使用实例、应用技巧、基本知识点总结和需要注意事项，具有一定的参考价值，需要的朋友可以参考一下。
目录
一、装饰器遵循的原则
1、函数名即‘“变量”
2、高阶函数
3、嵌套函数
4、闭包
二、装饰器介绍
三、装饰器实例
1、从最简单的装饰器做起
2、神奇的@
3、装饰器也想要参数
4、不支持带参数的被装饰函数的装饰器不是好装饰器
5、不支持有返回值的被装饰函数的装饰器不是好装饰器
6、有没有更骚的操作？
四、内置装饰器
五、装饰器的调用顺序
一、装饰器遵循的原则 装饰器，顾名思义就是起装饰的作用，既然是装饰，那么被装饰的对象是啥样就是啥样，不能有丝毫改变。在这里，我们写装饰器就是必须把握不能修改被修饰函数的源代码这条铁律。如何遵循这条铁律，我们还需还需做一些铺垫，必须先要了解四个概念，如下：
1、函数名即‘“变量” 在python中，函数名其实就像是c语言的函数指针，代表的是我们的函数地址，只有解释器获取到这个地址，它才会去执行这块内存的代码。因此，本质上，函数名就和不同变量没什么区别，只不过函数名和普通变量所指代的那块内存的使用方式不同罢了，这些都是底层解释器的机制所决定的，对于程序猿来说，都是透明的，所以，我们可以认为两者是没有区别的。
2、高阶函数 什么是高阶函数其实很简单，把握两个原则就好：
形式参数有函数名返回值有函数名 只要满足这两个原则之一，就可以称之为是高阶函数。翻回头来看，这里出现了我们上面说的函数名，仔细体会一下，我们在这里不就是把其当成实参看待的吗？
3、嵌套函数 什么是嵌套函数其实也非常简单，把握一个原则就好：
在一个函数的函数体中去定义另一个函数 在这里需要强调的是，函数定义时是不会执行函数体的，就和定义变量是不会去读取变量里的内容一样。这一点至关重要，对于我们理解装饰器实现原理非常有帮助。
4、闭包 所谓闭包，就是将组成函数的语句和这些语句的执行环境打包在一起时得到的对象，它的主要作用是封存上下文。这一特性可以巧妙的被用于现有函数的包装，从而为现有函数添加功能，这就是装饰器。
二、装饰器介绍 python装饰器本质上就是一个函数，它可以让其他函数在不需要做任何代码变动的前提下增加额外的功能，装饰器的返回值也是一个函数对象。装饰器函数的外部函数传入我要装饰的函数名字，返回经过修饰后函数的名字；内层函数（闭包）负责修饰被修饰函数。从上面这段描述中我们需要记住装饰器的几点属性，以便后面能更好的理解：
实质： 是一个函数
参数：是你要装饰的函数名（并非函数调用）
返回：是装饰完的函数名（也非函数调用）
作用：为已经存在的对象添加额外的功能
特点：不需要对对象做任何的代码上的变动
装饰器 = 高阶函数 + 函数嵌套 + 闭包
python装饰器有很多经典的应用场景，比如：插入日志、性能测试、事务处理、权限校验等。装饰器是解决这类问题的绝佳设计。并且从引入中的列子中我们也可以归纳出：装饰器最大的作用就是对于我们已经写好的程序，我们可以抽离出一些雷同的代码组建多个特定功能的装饰器，这样我们就可以针对不同的需求去使用特定的装饰器，这时因为源码去除了大量泛化的内容而使得源码具有更加清晰的逻辑。
三、装饰器实例 1、从最简单的装饰器做起 首先明确一下需求，我们有时候会需要在函数调用时打印一个相应的日志，虽然可以通过在所有需要打印日志的函数代码中嵌入打印日志的代码来实现，但这种方法不仅增加了许多重复代码，而且在业务代码中嵌入与业务无关的代码增加了整体的耦合度。因此，我们需要实现一个装饰器，这个装饰器在函数调用时可以打印一个日志记录函数调用行为。
如果我们有以下函数foo，代表具体的业务函数：
def foo(): print('in function foo') 我们设想通过调用foo = deco(foo)实现给函数foo增加打印日志的功能，并且不影响它原有的业务。那么在这种设想下，装饰器deco应该也是一个函数，它接收另一个函数作为输入，并返回一个新的、经过装饰的函数。在Python中，我们可以这么写：
def deco(func): # 接收一个函数作为参数 def new_func(): print(f'[log] run function {func.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/54c31735972cd89d4badccb751fa8bc6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09b2a42bb20d2c279ae1ec8588c0de85/" rel="bookmark">
			Java方法的定义
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		新冠阳了一个星期，幸亏无症状，大家做好防护啊！
Java方法 java方法是语句的集合，它们在一起执行一个功能。
方法是解决一类问题的步骤的聚合方法包含于类或对象中方法在程序中被创建，在其他地方被引用 设计方法的原则：方法的本意是功能块，就是实现某个功能的语句块的集合。我们设计方法的时候，最好保持方法的原子性，就是一个方法只完成1个功能，这样利于我们后期的扩展。
方法的定义 Java的方法类似于其他语言的函数，是一段用来完成特定功能的代码片段，一般情况下，定义一个方法包含以下语法：
方法包含一个方法头和一个方法体。下面是一个方法的所有部分：
修饰符：这是可选的，告诉编译器如何调用该方法。定义了该方法的访问类型。返回值类型：方法可能会返回值。returnValueType是方法返回值的数据类型。有些方法执行所需要的操作，但没有返回值。这种情况下，returnValueType是关键字void。方法名：是方法的实际名称。方法名和参数表共同构成方法签名。方法体：方法体包含具体的语句，定义该方法的功能。参数类型：参数像一个占位符。当方法被调用时，传递值给参数。这个值被称为实参或者变量。参数列表是指方法的参数类型、顺序和参数的个数。参数是可选的，方法可以不包含任何参数。 形式参数：在方法被调用时用于接收外界输入的数据实参：调用方法时实际传给方法的数据 方法调用 调用方法：对象名.方法名（实参列表）
Java支持两种调用方法的形式，根据方法是否返回值来选择
当方法返回一个值的时候，方法调用通常被当做一个值。例如
int larger = max(30,40); 如果方法返回值是void，方法调用一定是一条语句
System.out.println("Hello,kuangshen!"); 方法重载 重载就是在一个类中，有相同的函数名称，但形参不同的函数
方法的重载的规则
方法名称必须相同参数列表不同（个数不同，或类型不同，参数排列顺序不同）方法的返回类型可以相同也可以不相同仅仅返回类型不同不足以成为方法的重载 实现理论：
方法名称相同时，编译器会根据调用方法的参数个数，参数类型去逐个匹配，以选择对应的方法，如果匹配失败，则编译器报错 可变参数 JDK1.5开始，Java支持传递同类型的可变参数给一个方法在方法声明中，在指定参数类型后加一个省略号(…)一个方法中只能指定一个可变参数，它必须是方法的最后一个参数。任何普通的参数必须在它之前声明 递归 A方法调用B方法，我们很容易理解！
递归就是：A方法调用A方法！就是自己调用自己
利用递归可以用简单的程序来解决一些复杂的问题。它通常把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解，递归策略只需要少量的程序就可以描述出解题过程所需要的多次重复计算，大大减少了程序的代码量。递归的能力在于用有限的语句来定义对象的无限集合。
递归结构包含了两个部分：
递归头：什么时候不调用自身的方法。如果没有头，将陷入死循环。递归体：什么时候需要调用自身的方法。 # 写一个计算器，实现加减乘除功能，并且能循环接收新的数据，通过用户交互实现 package Method; import java.util.Scanner; public class JiSuanQi { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); while (true){ System.out.println("按y进入程序，功能如下："+"\n1.加"+"\n2.减"+"\n3.乘"+"\n4.除"+"\n按q退出"); String a = scanner.next(); if (a.equals("y")){ System.out.println("请输入运算方式:"); String choice = scanner.next(); System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/09b2a42bb20d2c279ae1ec8588c0de85/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a2e398b92ea6316bf90b69a97b8de9f/" rel="bookmark">
			使用micropython(ESP8266、ESP32)驱动SES 2.66寸墨水屏显示中文
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由于需要做一些低功耗的东西，所以最近在尝试玩墨水屏。出于成本考虑（没钱的另一种委婉说法）从咸鱼淘到2块便宜的二手SES 2.66寸三色墨水屏，并使用micropython将其驱动起来，并用字库的方法显示中文。
一.屏幕的驱动 1.硬件连线 SES 2.66墨水屏 SES 2.66墨水屏带驱动小板 买到的屏幕是图上这个样子的，带驱动小板 ，驱动小板的作用是提供给MCU标准的SPI操作接口。
墨水屏与ESP8266的连接方式采用推荐的方式，见下图。
连接没问题就可以测试了。
2.屏幕测试 由于micropython没有这个屏幕的现有驱动，因此拿到手后先使用有现成驱动的arduino环境进行测试，确保屏幕和连线没有问题。
（1）直接刷现成固件测试
卖家提供了编译好的现成的固件，直接使用NodeMCU-PyFlasher刷进去，屏幕上就会有测试画面显示，这是最快的测试方法。现成固件（“2.66测试固件”）下载地址见文末。
（2）使用arduino编译固件测试
下面是arduino下驱动的方法。
arduino的安装不在此述，ESP8266开发板的安装网上有很多教程，由于网速实在很慢，所以我采用的是最懒的使用别人打好的方式安装的。使用的包（“8266_package_3.0.1_arduino.cn.exe“）下载地址见文末。
然后就是把微雪的驱动包导进去，导入方法见“墨水屏使用须知(SES2.66三色为例).docx”，下载地址见文末。导入后需要修改或替换SES2.66b的驱动文件（EPD_2in66b.cpp），文中有叙述，照做就是。
最后编译上传，就应该能看到屏幕有反应了。
二、编写micropython驱动 由于要使用micropython来驱动屏幕，而该屏幕的资料很少，因此我必须研究下arduino下面的驱动程序，以编写相应的python驱动程序。
驱动方法还是主要参考两个部分：一是ariduino下那个EDP_2in66b.cpp，二是微雪的驱动包。
1.初始化
（1）BUSY/RESET引脚状态
由于资料不全，所以我实测了一下，SES2.66b的BUSY引脚高电平为忙，低电平为空闲，所以程序中定义：BUSY = const(1) # 0=idle, 1=busy。
RESET引脚是低电平使模块复位。并且，上电后程序拉低RESET引脚使模块复位后，BUSY引脚会一直处于高电平状态（忙），只有在后续写入POWER ON命令后，BUSY引脚才会变为低电平，这有点坑。
（2）SPI总线初始化
ESP8266只有两个SPI通道，0和1。其中0通道为内部FLASH使用，所以只能用SPI 1。
初始化时，如果不带波特率参数，SPI的总线速度会比较高，高到墨水屏不能接受。你可以测试一下这个：
&gt;&gt;&gt; from machine import SPI &gt;&gt;&gt; s=SPI(1) &gt;&gt;&gt; s HSPI(id=1, baudrate=80000000, polarity=0, phase=0) &gt;&gt;&gt; 默认波特率是80000000。所以我们需要把波特率降低些，实测10000000可以正常：
e=EPD(spi=SPI(1,baudrate=10000000),cs=Pin(15),dc=Pin(4),rst=Pin(2),busy=Pin(5)) e.init() （3）初始化命令
直接给出代码吧。
from micropython import const from time import sleep_ms import ustruct import math # Display resolution EPD_WIDTH = const(152) EPD_HEIGHT = const(296) # Display commands PANEL_SETTING = const(0x00) POWER_OFF = const(0x02) POWER_ON = const(0x04) BOOSTER_SOFT_START = const(0x06) DEEP_SLEEP = const(0x07) DATA_START_TRANSMISSION_1 = const(0x10) DISPLAY_REFRESH = const(0x12) DATA_START_TRANSMISSION_2 = const(0x13) VCOM_AND_DATA_INTERVAL_SETTING = const(0x50) TCON_RESOLUTION = const(0x61) VCM_DC_SETTING_REGISTER = const(0x82) UNKNOWN_CMD = const(0x92) # Display orientation ROTATE_0 = const(0) ROTATE_90 = const(1) ROTATE_180 = const(2) ROTATE_270 = const(3) #BUSY = const(0) # 0=busy, 1=idle BUSY = const(1) # 0=idle, 1=busy #rstPin--&gt;low=active #dc------&gt;low=command #cs------&gt;low=active class EPD: def __init__(self,spi,cs,dc,rst,busy): self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2a2e398b92ea6316bf90b69a97b8de9f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ef7fada517599ac7d57023d8db844a1/" rel="bookmark">
			C/C&#43;&#43;程序设计综合实践指导[2021级]
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C/C++程序设计综合实践指导[2021级] 2021级程序设计综合实践指导
一、综合实践要求
综合实践是C语言程序设计、C++到数据结构三门课程的一个综合实践练习，是有别于课程实验的一个独立实践教学环节。综合实践一般在数据结构课程结束后进行，教学时数为2周，其中第1周个人实践(每人选1题)，第2周小组实践(组成2-3人的小组选1题)。具体要求如下：
1、结合实际问题进一步理解和深化课程理论知识，做到理论与实际相结合。
2、能对实际问题进行分析和抽象，并进行算法设计和数据结构设计，具有初步的分析问题和解决问题的能力。
3、了解软件工程的基础理论与方法，初步掌握软件开发过程中的需求分析、系统设计、编码、测试等基本方法和技能。
4、进一步强化编程训练，提高程序设计能力。
5、设计内容要有一定的深度和难度，达到一定工作量，两周代码量不低于1000行。
二、综合实践内容
综合实践的主要工作如下：
1、问题定义与需求分析：根据设计题目的要求，对问题进行分析，确定系统的功能需求和性能需求。
2、数据结构与算法设计：对问题描述中涉及的数据对象定义相应的数据结构，包括逻辑结构、存储定义和主要操作。对主要算法要进行时间和空间复杂度分析。
3、概要设计：采用面向对象方法设计软件结构，定义类及类之间的关系。给出系统的总体解决方案。画出本次设计的功能框图、流程图等。要求系统结构合理、易于实现。
4、详细设计：描述实现过程中所使用的类，数据存储的定义，主要成员函数及其功能等，建议使用UML进行类的描述。
5、编码与测试：用C++编程实现系统，并设计测试用例对系统进行测试，修改程序中的错误，形成格式和风格良好的源程序清单。
6、结果分析：对系统应用效果进行分析，评价系统的先进性、实际应用价值及在在的问题。
7、撰写程序设计综合实践报告。
三、综合实践考核
综合实践考核内容包括个人实践和小组实践两个模块，每个模块又包括实践作品和实践报告两个部分。实践作品包括可正确运行的源程序（刻录成光盘），系统使用说明，主要程序代码（打印附在实践报告内）。 实践报告主要包括系统分析、设计和实现过程，内容如下：
1、问题定义及设计要求；
2、主要实践内容：详细报告中所做的主要工作，包括系统分析、概要设计、数据结构设计、算法设计及模块设计和编程及测试等。
3、总结与体会：写出本次综合实践的主要创新点及存在的问题。
4、参考文献：实践过程中参考的主要书目、文章、或网址，不少于8个。
5、小组实践环节，需要组建2-3人的小组，明确写出小组成员及分工。
综合实践成绩分三部分，实践作品占40％，实践报告占30％，答辩占30％。其中实践作品包括个人实践作品和小组实践作品；实践报告包括个人实践和小组实践两部分，两部分的总结与体会、参考文献统一写在一起。评价因素主要有：
1、知识点覆盖范围及运用能力；
2、数据结构设计与算法设计能力；
3、系统规模（代码行数）；
4、数据存储方式；
5、人机交互（用户体验或评价）
四、时间安排：
第16-17周。第1周个人实践，第2周小组实践。每周具体：
周一：确定选题，查阅文献，确定解决方案。
周二、周三：编写代码实现功能。
周四：修改调试程序，并开始撰写本部分报告。
周五：完成报告，准备本实践部分答辩材料。 第2周周末进行答辩。
源码 https://pan.baidu.com/s/1pq1Nwwo0hlc_J84F93HM4A?pwd=1111
五、第一周个人实践参考题目
1、ATM机存取款管理程序（****） 【问题描述】
模拟银行的自动取款机的使用，实现查询余额、取款、存款、转账、退出系统等功能。不少于10名用户的信息，假设每个用户仅一个账户。
【基本要求】
（1）基于显示器、键盘完成ATM机中基本人机交互。
（2）设计应用程序所需要的类。
（3）将所有交易相关的操作设计成基类，从该基类派生出查询余额、取款、存款、转账等子类。
（4）完成该应用程序的所有功能。
２、个人银行账户管理程序（****） 【问题描述】
某人的活期储蓄账户包括账号，余额，年利率等基本信息，并需要显示账户信息，存款，取款，结算利息等基本操作。
【基本要求】
设计完成以上基本功能的类，并给出相应的测试程序。进一步：
（1）该用户有多个储蓄账户，增加功能能够记录各个账户的总金额，并增加相应的访问函数。
（2）为该用户增加信用账户，注意信用账户与储蓄账户的需求有不同。信用账户的特点是允许透支，每个信用账户也有信用额度，总得透支金额要在这个额度以内。如果向信用账户存钱，不会有利息，但使用信用账户透支则需要支付利息。请重新考虑该程序类的设计与实现。
（3）将用户的账户信息保存至文件中。
３、行文本编辑器（****） 【问题描述】
实现一个英文字符的行文本编辑器，该编辑器根据用户输入的命令可以完成以下功能——
I: input characters.
D: delete a character.
F: move forward a character.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1ef7fada517599ac7d57023d8db844a1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f429747da18a95224a464f954058efb1/" rel="bookmark">
			交换机的初始化配置（思科模拟器）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		连线方法：使用配置线缆，连接交换机的Console端口和计算机的Rs232串口。如下图1-1所示。
1-1 登录交换机：点击PC0切换至"Desktop"选项卡，点击"Terminal"（终端）如下图1-2所示。 1-2 其各项保持默认，点击"OK"就成功登录到此交换机。如下图1-3所示。
1-3 默认模式： 登录到交换机默认是用户模式，我们要进入特权模式然后进行交换机初始化配置。进入特权模式的命令是 enable ，在命令行种输入enable后敲回车进入特权模式（enable可缩写为en）提示符比用户模式多“#” 如下图1-4所示。
Switch&gt; enable /进入特权模式
Switch&gt;# /特权模式
1-4 初始化配置：在特权模式下输入命令 setup 进行初始化配置，询问我们是否要进行初始化配置，我们输入yes。如下图1-5所示
1-5 询问我们是否进入基本管理设置，我们继续输入yes。如下图1-6所示。
1-6 让我们为交换机起一个名字，这里起个S1。如下图1-7所示。
1-7 让后让我们设置将加密的访问密码，这里输入123wszz。如下图1-8所示。
1-8 接着让我们设置启用密码，这里输入456wszz。如下图1-9所示。
1-9 然后让我们设置虚拟终端的密码，这里输入123456wszz。如下图1-10所示。
1-10 然后询问我们是否需要配置SNMP(简单网络管理) 一般不需要 输入no。如下图1-11所示。
1-11 接着让我们在上述端口中选择管理接口名称，交换机默认存在vlan1，所以我们这里选择vlan1进行管理。如下图1-12所示。
1-12 然后询问我们是否要给vlan1配置IP地址，这里不配置 输入no。然后再询问是否要是否要作为群集命令开关启用，依然不 输入no。如下如1-13所示。
1-13 然后出现三个选项，[0]和[1]均是不保存上面的配置，[2]是保存到存储器中并退出，默认选项是[2]。如下图1-14所示。
1-14 到此交换机的初始化配置结束。其过程可以归纳为下：
enable —— setup —— 设置主机名 —— 设置三个密码 —— 输入管理vlan —— 为其配置IP地址（可以不配置） —— [2]保存退出
注：由于小编身份是一名信息技术一类专业的在校中职学生，热爱计算机网络技术，喜欢分享一些自己学过的三脚猫功夫。还希望各路大神多多指教才是。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b4118dfa169920398fc88ecaffccd15/" rel="bookmark">
			poi根据模版生成word（包括导出）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		根据word模版生成新的word直接把流输出 下载
进行改造的作为笔记 记录一下 大佬勿喷！！！
下面展示完整的代码
1.controller层 @RequestMapping(value = "/report",method = RequestMethod.POST) @ApiOperation(value = "生成word",notes = "生成word") @ResponseBody public ResponseVo report(@RequestBody WordReportVo wordReportVo, HttpServletResponse response) throws IOException { dataQdService.report(wordReportVo,response); return new ResponseVo(); } 2.service层 提前把模版设计好放到resources @Override public void report(WordReportVo wordReportVo, HttpServletResponse response) throws IOException { if (StringUtils.isEmpty(wordReportVo.getXmName()) || StringUtils.isEmpty(wordReportVo.getTzdName()) || StringUtils.isEmpty(wordReportVo.getTzdCode()) || StringUtils.isEmpty(wordReportVo.getContent())) { throw new BaseException(CoreErrorCode.REQUIRED_PARAM_EMPTY.getCode()); } InputStream resourceAsStream = DataQdServiceImpl.class.getResourceAsStream("/xxx.docx"); XWPFDocument document = new XWPFDocument(resourceAsStream); Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3b4118dfa169920398fc88ecaffccd15/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e26742e71d50d84fe9deb82128eb711f/" rel="bookmark">
			IPC 之Service 还可以这么理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 IPC 系列文章：
建议按顺序阅读。
Android IPC 之Service 还可以这么理解
Android IPC 之Binder基础
Android IPC 之Binder应用
Android IPC 之AIDL应用(上)
Android IPC 之AIDL应用(下)
Android IPC 之Messenger 原理及应用
Android IPC 之服务端回调
Android IPC 之获取服务(IBinder)
Android Binder 原理换个姿势就顿悟了(图文版)
Android四大组件：Activity、Service、BroadcastReceiver、ContentProvider。它们的作用分别是：
Activity---&gt;配合View展示界面
Service---&gt;长时间在后台运行不与用户直接交互
BroadcastReceiver---&gt;接收广播
ContentProvider---&gt;提供数据给其他模块使用
本篇文章着重分析Service，通过它，你将了解到：
1、Service 开启与停止
2、Service 执行耗时操作
3、Service 与Thread、Manager关系
4、Service 进程间通信初相识
1、Service 开启与停止 先定义一个Service类，名为MyService，继承自Service。
public class MyService extends Service { public MyService() { super(); } @Nullable @Override public IBinder onBind(Intent intent) { //必须重写该方法，该方法为抽象方法 //绑定开启Service会调用该方法 return null; } @Override public void onCreate() { //Service初次创建会调用该方法，我们可以做一些初始化操作, 与onDestroy()相对 super.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e26742e71d50d84fe9deb82128eb711f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54cae3e9946ead8453632a27786b106c/" rel="bookmark">
			Linux-安装软件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、JDK的安装 1.利用FinalShell的上传工具直接将jdk二进制发布包上传到Linux系统中，默认上传到选中目录
2.解压到指定目录：tar -zxvf jdk-8u171-linux-x64.tar.gz -C /usr/local (一半自己安装的软件都安装到这个目录)
3.配置环境变量，打开并编辑 /etc/profile 文件，在末尾行添加上(Shift+G跳转到最后一行)
JAVA_HOME=/usr/local/jdk1.8.0_171
PATH=$JAVA_HOME/bin:$PATH
4.重新加载profile文件，使更改的配置立即生效，命令为：source /etc/profile
5.检查是否安装成功：java -version 2、Tomcat的安装 1.利用FinalShell的上传工具直接将Tomcat二进制发布包上传到Linux系统中。
2.解压安装包，tar -zxvf apache-tomcat-7.0.57.tar.gz -C /usr/local 3.启动tomcat，sh startup.sh ./startup.sh
4.查看是否启动完成：
查看启动日志，more /usr/local/apache-tomcat-7.0.57/logs/catalina.out
tail-50 /usr/local/apache-tomcat-7.0.57/logs/catalina.out
查看进程，ps -ef l grep tomcat
ps命令是linux下非常强大的进程查看命令，通过ps-ef可以查看当前运行的所有进程的详细信息“|”在Linux中称为管道符，可以将前一个命令的结果输出给后一个命令作为输入使用ps命令查看进程时，经常配合管道符和查找命令 grep 一起使用，来查看特定进程
5.停止Tomcat的方式：
运行Tomcat的bin目录中提供的停止服务的脚本文件
sh shutdown.sh ./shutdown.sh
结束Tomcat进程，查看Tomcat进程，获得进程id：ps -ef l grep tomcat
执行命令结束进程： kill -9 进程id
注意: kill命令是Linux提供的用于结束进程的命令，-9表示强制结束
3、防火墙相关命令 1.查看防火墙状态(systemctl status firewalld、firewall-cmd --state)
2.暂时关闭防火墙(systemctl stop firewalld)
3.永久关闭防火墙(systemctl disable firewalld)
4.开启防火墙(systemctl start firewalld)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/54cae3e9946ead8453632a27786b106c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/151549aab85630a6c3c6681328f07fe8/" rel="bookmark">
			【slam14】安装多个opencv版本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.在安装了opencv4的基础上安装opencv3
opencv版本在这[Releases · opencv/opencv · GitHub]，contrib版本在这[GitHub - opencv/opencv_contrib at 3.4.3]
环境依赖项
Ubuntu16.04安装配置opencv3.4.3+opencv_contrib3.4.3_林深时见鹿echo的博客-CSDN博客_ubuntu 安装opencv3
​​​​​​-D WITH_IPP=OFF, OPENCV_NON_FREE=ON
*编译中遇到的问题IPPICV下载失败
参考：源码编译opencv卡在IPPICV: Download: ippicv_2017u3_lnx_intel64_general_20170822.tgz解决办法_eternal_truth的博客-CSDN博客_ippicv
在Github上下载对应需要下载的文件，随便放在哪里，比如直接/home/xxx/opencv下
Github下载： opencv_3rdparty/ippicv_2017u3_lnx_intel64_general_20180518.tgz at ippicv/master_20180518 · opencv/opencv_3rdparty · GitHub先自己手动（百度）下载ippicv 包，不过要在cmake 的最开头加上-D WITH_IPP=OFF （因为已经下载过了，相应的下载关掉即可） ,这样再cmake下就好了
*opencv3所缺少的boostdesc_bgm.i等文件 采用的是源码编译的方式，所以可以查看 build 文件夹下的日志文件 CMakeDownloadLog.txt，在日志文件CMakeDownloadLog.txt中搜索 boostdesc_bgm.i 关键词 (不是在文件夹中搜索)，
发现这个文件下载失败了。日志文件里就有它的下载地址，直接复制其下载地址到网页可以看该到文件的源码，直接拷贝源码并生存同名文件，放在 opencv_contrib/modules/xfeatures2d/src/ 路径下即可。
*/stitching/include/opencv2/stitching/detail/matchers.hpp
fatal error: opencv2/xfeatures2d/cuda.hpp: 没有那个文件或目录
/home/tsingroo/Documents/3rdparty/opencv-3.4.3/modules/stitching/include/opencv2/stitching/detail/matchers.hpp打开，找到# include "opencv2/xfeatures2d/cuda.hpp"语句
改为绝对路径#include "/home/tsingroo/Documents/3rdparty/opencv-3.4.3/opencv_contrib-3.4.3/modules/xfeatures2d/include/opencv2/xfeatures2d/cuda.hpp"
第三步：编译安装 make -j11 make install 第四步：配置环境 sudo vi /etc/ld.so.conf.d/opencv.conf 输入：/home/tsingroo/Documents/package/opencv-3.4.3/lib 第五步：配置bashrc vi ~/.bashrc,在最后添加： #opencv-3.4.3 export PKG_CONFIG_PATH=${PKG_CONFIG_PATH}:/home/tsingroo/Documents/package/opencv-3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/151549aab85630a6c3c6681328f07fe8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf76c5d29b3d5ba357cdd99b9dc265be/" rel="bookmark">
			Ubuntu安装redis服务器并实现远程连接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ubuntu安装redis 官网下载redis服务器的压缩包redis-6.0.16.tar.gz 点击download 6.2.8或任意版本即可。
上传下载的压缩包到服务器或者本地虚拟机 解压压缩包，并安装gcc tar -zxvf redis-6.0.16.tar.gz 解压之后可以看到redis的目录结构：
没有bin目录，而redis的启动启动目录在src目录下，由于redis启动需要gcc环境，因此需要重新编译和和安装一下。
切换到redis的src目录安装gcc
#切换到 redis目录 cd redis/src #解压的目录不一样 # 编译 make # 安装 make install 编译过程中可能会初选error: jemalloc/jemalloc.h: No such file or directory异常
解决办法:依次执行如下命令：
make MALLOC=libc
cd src &amp;&amp; make install
如果最开始没有切换目录那么安装的就是默认目录
切换了目录后启动程序直接在redis的src目录下：
对比之前的src多了很多绿色的文件一部分是启动文件。
在src目录下输入redis-server或./redis-server即可启动redis服务器，当然也可以配置环境变量，全局应用，目录是src而不是bin。
redis的环境变量是到src的。
# 编辑环境变量 sudo vi /etc/profile # 重启环境变量 source /etc/profile 重启环境变量后在任意位置都能启动redis服务器：
redis常见命令和使用 redis的基本使用 redis的启动分为两种方式：前台启动和后台启动。
由于前台启动后，命令行界面不能再执行其他操作，且命令行界面关闭后，redis也会随即关闭，所以不推荐使用。
在次界面无法对redis操作
一般都需要在后台启动redis，后台启动需要修改配置文件redis.conf
找到如图的位置将图中地方的no改为yes
后台启动reids，修改完配置文件后，后台启动redis命令有了变化，需要携带配置文件的参数：
redis-server redis.conf
ps -ef| grep redis该命令用于查找redis服务。
通过这样启动redis后redis服务器就持久化运行了
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cf76c5d29b3d5ba357cdd99b9dc265be/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ed2a246797f20e0c6899e84d8a62ee1/" rel="bookmark">
			用java遍历本地目录所有文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用 Java 遍历本地目录中的所有文件，您可以使用 java.io.File 类。
首先，您需要创建一个 File 对象，并指定要遍历的目录的路径。然后，您可以使用 listFiles() 方法获取该目录中的所有文件。您可以使用 isDirectory() 方法判断文件是否是目录，如果是目录，则可以使用递归的方式遍历该目录中的所有文件。
下面是一个示例代码，该代码使用递归的方式遍历本地目录中的所有文件：
``` import java.io.File;
public class Main { public static void main(String[] args) { // 创建一个 File 对象，指定要遍历的目录的路径 File dir = new File("C:\Users\John\Documents");
// 调用 listFiles 方法获取该目录中的所有文件 File[] files = dir.listFiles(); // 遍历文件数组 for (File file : files) { // 如果文件是目录，则递归调用 listFiles 方法 if (file.isDirectory()) { listFiles(file); } else { // 否则，输出文件的路径 System.out.println(file.getAbsolutePath()); } } } public static void listFiles(File dir) { // 调用 listFiles 方法获取该目录中的所有文件 File[] files = dir.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1ed2a246797f20e0c6899e84d8a62ee1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9282762379db9654514e2874e6423f01/" rel="bookmark">
			报错：虚拟机重启后发现ens33的ip地址失踪，导致xshell连接不上
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		场景：某一次关机后发现某一台节点的发现ens33的ip地址失踪，导致xshell连接不上
分析：对比了下跟其他正常节点的差异，发现右上角有线连接的网络图标不见了，应该是识别不到网卡了解决办法：
①先启动ifconfig ens33 up
②把network的老大NetworkManager也关掉
systemctl stop NetworkManager
systemctl disable NetworkManager
③再重启network
systemctl restart network现在看下ifconfig就正常了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13154c2dcd5fe2adce8636003f349489/" rel="bookmark">
			【Android】Handler机制详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【Android】Handler机制详解 本文是在 Carson带你学Android 作者的异步通信 专栏中Handler的基础上学习整理的kotlin版本，并且Android源码部分也更新至最新。 1.使用Handler消息传递机制的原因 2.相关概念 概念定义作用备注Main Thread应用程序初次启动时会自动开启主线程处理与UI相关的操作与子线程的通信媒介为Handler子线程手动开启的线程执行耗时操作，如加载数据，网络请求以及IO操作与主线程的通信媒介为HandlerMessage线程间通信的基本数据单元存储通信信息/Message Queue数据结构存储Handler发送的Message/Handler线程之间Message的处理者添加Message到Message Queue；处理Looper分发的Message/LooperMessage Queue与Handler之间的通信媒介循环取出Message Queue中的Message并分发给对应的Handler一个线程只能拥有一个Looper；但一个Looper可以与多个线程的Handler绑定；因此提供了线程间通信的能力 3.工作流程 4.使用方式 1.使用 Handler.sendMessage() /** * 方式1：新建Handler子类 */ // 步骤1：自定义Handler子类 &amp; 复写handleMessage（）方法 class mHandler : Handler() { // 通过复写handlerMessage() 从而确定更新UI的操作 override fun handleMessage(msg: Message) { ...// 需执行的UI操作 } } // 步骤2：在主线程中创建Handler实例 private val mhandler = mHandler() // 步骤3：创建所需的消息对象 val msg = Message.obtain() // 实例化消息对象 msg.what = 1 // 消息标识 msg.obj = "tmp" // 消息内容 // 步骤4：在工作线程中 通过Handler发送消息到消息队列中 // 可通过sendMessage() / post() // 多线程可采用AsyncTask、继承Thread类、实现Runnable mHandler.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/13154c2dcd5fe2adce8636003f349489/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e01d92d7509d8c80eb87c7ce98440cc/" rel="bookmark">
			离线使用huggingface bert对文本编码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.到huggingface官网找到想使用的模型
https://huggingface.co/
以‘bert-base-uncased’为例
2.下载以下几个文件放到名为bert-base-uncased的文件夹中
3.使用以下代码获得词编码
from transformers import BertModel,BertTokenizer checkpoint='/data1/xsy/transformers/bert-base-uncased' tokenizer=BertTokenizer.from_pretrained(checkpoint) caption =tokenizer.encode(caption,padding='max_length', max_length=72, truncation=True)#获得id bert = BertModel.from_pretrained(checkpoint) y = bert(caption, return_dict=True).last_hidden_state#获得编码 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c3deceecc70fe328a6e8e57ceb51659/" rel="bookmark">
			大数据之Hadoop
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Hadoop的简介 Apache Hadoop是一款支持数据密集型分布式应用程序并以Apache 2.0许可协议发布的开源软件框架，有助于使用许多电脑组成的网络来解决数据、计算密集型的问题。基于MapReduce计算模型，它为大数据的分布式存储与处理提供了一个软件框架。所有的Hadoop模块都有一个基本假设，即硬件故障是常见情况，应该由框架自动处理。
Apache Hadoop的核心模块分为存储和计算模块，前者被称为Hadoop分布式文件系统（HDFS），后者即MapReduce计算模型。Hadoop框架先将文件分成数据块并分布式地存储在集群的计算节点中，接着将负责计算任务的代码传送给各节点，让其能够并行地处理数据。这种方法有效利用了数据局部性，令各节点分别处理其能够访问的数据。与传统的超级电脑架构相比，这使得数据集的处理速度更快、效率更高。
Hadoop组件 HDFS HDFS分布式存储框架，适合海量数据的存储 HDFS的原理：是一种允许文件通过网络在多台主机上分享的文件系统，可让多机器上的多用户分享文件和存储空间
通透性；让实际上是通过网络来访问文件的动作，由程序与用户看来，就像是访问本地的磁盘一般。
容错；即使系统中有某些节点宕机，整体来说系统仍然可以持续运作而不会有数据损失【通过副本机制实现】。
分布式文件管理系统很多，hdfs只是其中一种，不合适小文件。
HDFS的节点 一、管理节点NameNode NameNode是整个文件系统的管理节点，它维护着整个文件系统的目录树，文件目录的元信息和每个文件对应的数据块列表，接收用户的操作请求。
①维护每个DataNode的心跳，用于查看数据节点是否存活
②用于管理HDFS中所有的文件信息，包括文件的路径、文件的block块信息、文件的大小及其权限
③响应客户端的请求，根据上传或下载返回请求的结果
二、数据节点DataNode DataNode节点提供真实文件数据的存储服务 ①用于存储客户端上传的具体文件，文件上传过程会进行数据的切分，根据block块大小会将文件切分成多块，并且block块会存储在多个DataNode中
②响应客户端的上传请求和下载请求
③检测和管理存储在本节点上的block块信息
Block块为HDFS中基本的存储单位，但并不是最小的存储单位 一个文件的长度大小是size，那么从文件的偏移开始，按照固定的大小，顺序对文件进行划分并编号，划分好的每一个块称为一个block。
BLock块大小： ​ 1.在Hadoop1.X中大小默认为64M
​ 2.在Hadoop2.X中大小默认为128M
为什么BLock块大小为128M？ ​ 问题：
1. 如果一个文件不进行做拆分，对应一个DataNode中存储一个完整的文件，对导致DataNode存取压力过大，由于计算本地化，所以计算压力也会很大，由此需要拆分 2. 如果拆分过大？ 会导致1问题，同时下载速度也会很慢 3. 如果拆分过小？ 对应一个拆分过的文件会特别多，那么对应的元数据信息也会很多，会导致NameNode压力过大，检索数据信息时间会很长 基于以上问题如何设计？ 规定：一个数据的检索时间最长不超过10ms,规定检索时间为BLock数据下载时间的1%为1秒
数据下载时间由网络及磁盘决定，由于磁盘和网络传输时间在100M/s，基于这个理论值得到 block块大小是在128M
设置BLock块大小 hdfs-site.xml中dfs.blocksize属性
副本数 Replication。多副本。默认是三个
设置hdfs-site.xml的dfs.replication属性
副本机制与机架？ 如果当前集群设置副本数为3 那么对应存放位置为在同一个机架中会存放两个份，其他机架中保存一份，可以保证数据的安全。
为什么block块不每个机架存放一份？ 由于后续做数据计算时，会将计算结果进行汇总，如果数据过于分散，那么后续网络传输压力会很大。
三、Secondary NameNode Secondary NameNode是NameNode的备份节点
①由于NameNode需要保存元数据信息，并且元数据信息是放在内存中的
②数据存放在内存中会有安全性问题，需要持久化
③由于NameNode对外请求压力大，并不适合做持久化工作，所以交由Secondary NameNode
HDFS的读写 一、HDFS的读流程 1.首先调用FileSystem对象的open方法，其实是一个DistributedFileSystem的实例
2.DistributedFileSystem通过rpc获得文件的第一个block的locations，同一block按照副本数会返回多个locations，这些locations按照hadoop拓扑结构排序，距离客户端近的排在前面.
3.前两步会返回一个FSDataInputStream对象，该对象会被封装成DFSInputStream对象，DFSInputStream可以方便的管理datanode和namenode数据流。客户端调用read方法，DFSInputStream最会找出离客户端最近的datanode并连接。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8c3deceecc70fe328a6e8e57ceb51659/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a32d871c8b019dd4df75d1afa5a7b6f/" rel="bookmark">
			事实证明,OpenCV中对RGB图像数据的存储顺序是BGR
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		事实证明：OpenCV中对RGB图像数据的存储顺序是BGR。
验证这个事实的例子如下：
我们读入三张纯色图像，分别为纯红、纯绿、纯蓝。
上面三张图的百度网盘下载链接：
https://pan.baidu.com/s/1b0XfTQcGxiXePu1_ZEsUig?pwd=m6ut 然后用下面的代码读入下面三张图，观察变量的数据存储结构：
//出处：昊虹AI笔记网(hhai.cc) //用心记录计算机视觉和AI技术 //博主微信/QQ 2487872782 //QQ群 271891601 //欢迎技术交流与咨询 //OpenCV版本 OpenCV3.0 #include &lt;opencv2/opencv.hpp&gt; #include &lt;iostream&gt; int main() { cv::Mat Red_pic = cv::imread("F:/material/images/2022/2022-10/red.bmp"); //读入纯红色图像 cv::Mat Green_pic = cv::imread("F:/material/images/2022/2022-10/green.bmp"); //读入纯绿色图像 cv::Mat Blue_pic = cv::imread("F:/material/images/2022/2022-10/blue.bmp"); //读入纯蓝色图像 int red_0, red_1, red_2;//分别存储纯红色图像0通道、1通道、2通道的数值 int green_0, green_1, green_2;//分别存储纯绿色图像0通道、1通道、2通道的数值 int blue_0, blue_1, blue_2;//分别存储纯绿色图像0通道、1通道、2通道的数值 red_0 = Red_pic.at&lt;cv::Vec3b&gt;(50, 50)[0]; red_1 = Red_pic.at&lt;cv::Vec3b&gt;(50, 50)[1]; red_2 = Red_pic.at&lt;cv::Vec3b&gt;(50, 50)[2]; green_0 = Green_pic.at&lt;cv::Vec3b&gt;(50, 50)[0]; green_1 = Green_pic.at&lt;cv::Vec3b&gt;(50, 50)[1]; green_2 = Green_pic.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0a32d871c8b019dd4df75d1afa5a7b6f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9af1c88bdf6f942cda25eaa78ee3a406/" rel="bookmark">
			达梦数据库日常使用语句01
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		查看数据库初始化参数等信息 --DM8较新版本直接查询V$OPTION视图： SELECT * FROM V$OPTION; ---通用 SELECT '实例名称' AS 数据库参数名称,INSTANCE_NAME 数据库参数值 FROM V$INSTANCE UNION ALL SELECT '数据库版本', BANNER||'.'||ID_CODE FROM V$VERSION WHERE ROWNUM=1 UNION ALL SELECT '字符集',CASE SF_GET_UNICODE_FLAG() WHEN '0' THEN 'GBK18030' WHEN '1' THEN 'UTF-8' WHEN '2' THEN 'EUC-KR' END UNION ALL SELECT '页大小',CAST(PAGE()/1024 AS VARCHAR) UNION ALL SELECT '簇大小',CAST(SF_GET_EXTENT_SIZE() AS VARCHAR) UNION ALL SELECT '字符串比较大小写敏感',CAST(SF_GET_CASE_SENSITIVE_FLAG() AS VARCHAR) UNION ALL SELECT 'VARCHAR类型是否以字符为单位',VALUE FROM V$PARAMETER WHERE NAME='LENGTH_IN_CHAR' UNION ALL SELECT '空格填充模式',VALUE FROM V$PARAMETER WHERE NAME='BLANK_PAD_MODE' UNION ALL SELECT '数据库模式',MODE$ FROM V$INSTANCE UNION ALL SELECT '数据库端口',VALUE FROM V$PARAMETER WHERE NAME='PORT_NUM' UNION ALL SELECT '归档模式',ARCH_MODE FROM V$DATABASE UNION ALL SELECT '唯一魔数',CAST(PERMANENT_MAGIC AS VARCHAR) UNION ALL SELECT 'LSN',CAST(CUR_LSN AS VARCHAR) FROM V$RLOG ; 查看活动SQL语句执行时间 select datediff(s, last_recv_time, sysdate) exectime, dbms_lob.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9af1c88bdf6f942cda25eaa78ee3a406/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5dc0223b16968491c9877cf351a6193c/" rel="bookmark">
			间隔分区表merge into报错“-2903: 语句块/包/存储函数中的间隔分区不支持自动扩展”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		描述 版本： DM V8 --08134283904-20220804-166351-20005 Pack4
初始化参数： 默认
ini参数： 默认
执行间隔分区表上执行merge into语句报错，信息如下：
同样的语句，在Oracle中执行正常。
测试 创建环境：
DROP TABLE IF EXISTS TAB_P001; DROP TABLE IF EXISTS T1; CREATE TABLE T1 AS select USERNAME,USER_ID,CREATED from dba_users; CREATE TABLE TAB_P001 ( C1 VARCHAR2(96), C2 TIMESTAMP(6) NOT NULL, C3 VARCHAR2(32) NOT NULL, PRIMARY KEY(C3)) PARTITION BY RANGE(C2) INTERVAL(NUMTOYMINTERVAL(1, 'MONTH')) ( PARTITION "P_202201" VALUES LESS THAN( to_date('2022-02-01 00:00:00','yyyy-mm-dd hh24:mi:ss') ), PARTITION "P_202202" VALUES LESS THAN( to_date('2022-03-01 00:00:00','yyyy-mm-dd hh24:mi:ss')) ); MERGE INTO TAB_P001 a USING t1 b on (a.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5dc0223b16968491c9877cf351a6193c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aec3d0fa7d787d6b02370c94a4013e1b/" rel="bookmark">
			C语言零基础项目：2D 赛车游戏，详细思路&#43;源码分享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、简介
二、如何建立一个地图包
三、关于碰撞图的绘制
四、游戏时的说明
五、如何更好地绘制赛场图与碰撞图？
游戏截图
源码下载
一、简介 此游戏是《2D 赛车》的”魔改版“——2.5D 双人赛车！
原作实现了 2D 视角的赛车游戏，但是我觉得不够真实、操纵感不强，故挤出数个周末完成了这个”魔改版“，实现了第一人称的视角。
二、如何建立一个地图包 1. 选择赛车，音乐，地图的素材
2. 在程序的 map 文件夹下建立一个文件夹将这些素材放入
3. 建立 set.ini 文件
详情参考工程下的文件夹 a 和 b
三、关于碰撞图的绘制 碰撞图色彩格式：
黑色（0xFFFFFF）为赛道，减速较小
黄色（0xFFFF00）为沙地，会减速
蓝色（0x0000FF）为冰面，会滑动
红色（0xFF0000）为围栏，无法通过
绿色（0xFFFFFF）为终点线
灰色（0xAAAAAA）为终点线的两端，用于判定方向（对应色值 RGB(170,170,170)）
紫色（0xFF00FF）为玩家 2 起点
白色（0x000000）为玩家 1 起点
注意事项：
终点线最好为宽度为一的直线！
灰色只有两个像素点，分布在终点线的两端点
画碰撞图宁可把道路画粗一点，因为实际游戏中可能会因为碰撞图画的太窄，导致玩家好像在路上但是被卡住了
此外，设置玩家起始位置也要考虑玩家车辆的长度，如果玩家的起始位置离终点线太近，以至于玩家的车尾超过了终点线的话，那么开动车子的时候就会触发一次车子越过终点的判定。
四、游戏时的说明 上/W 向前开
下/S 倒车
左/A 左转
右/D 右转
如果卡在墙里就按住一个方向键加向前直到出去
预设的地图包为 a、b，在工程文件夹下
五、如何更好地绘制赛场图与碰撞图？ 利用 PS 的自由路径和描边，一定要用铅笔。
游戏截图 #include &lt;graphics.h&gt; // 引用图形库头文件 #include &lt;ctime&gt; #include &lt;sstream&gt; #include &lt;fstream&gt; #include &lt;vector&gt; #include &lt;conio.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aec3d0fa7d787d6b02370c94a4013e1b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e723d6b4d6503cc0e1e968c7a07aa4cd/" rel="bookmark">
			Pandas参考手册、常用函数及方法汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、入门与升级宝典 如果个人时间充裕，可以去官网查看文档信息
官网链接：pandas - Python Data Analysis Library
pandas参考文档：pandas documentation — pandas 1.3.3 documentation
二、常用的函数和方法 创建测试对象：
pd.DataFrame(np.random.rand(20,5))：创建20行5列的随机数组成的DataFrame对象pd.Series(my_list)：从可迭代对象my_list创建一个Series对象df.index = pd.date_range('1900/1/30', periods=df.shape[0])：增加一个日期索引 df为某个读入进来的数据帧。
需知：
axis的参数：0（index） 逐行 1 (column) 逐列
1.导入数据
pd.read_csv(filename)：从CSV文件导入数据
pd.read_table(filename)：从限定分隔符的文本文件导入数据
pd.read_excel(filename)：从Excel文件导入数据
pd.read_sql(query, connection_object)：从SQL表/库导入数据
pd.read_json(json_string)：从JSON格式的字符串导入数据
pd.read_html(url)：解析URL、字符串或者HTML文件，抽取其中的tables表格
pd.read_clipboard()：从你的粘贴板获取内容，并传给read_table()
pd.DataFrame(dict)：从字典对象导入数据，Key是列名，Value是数据
pd.ExcelFile(Filename): 从Excel中读取数据，sheet_names查看相应sheet, parse方法解析某个sheet
2.导出数据
df.to_csv(filename)：导出数据到CSV文件df.to_excel(filename)：导出数据到Excel文件df.to_sql(table_name, connection_object)：导出数据到SQL表。注意：dtype可以指定输出字段的格式，如df.to_sql('test',con=engine,dtype={'A':Integer(),'B':DateTime()})df.to_json(filename)：以Json格式导出数据到文本文件writer=pd.ExcelWriter('test.xlsx') ：然后调用df1.to_excel(writer,sheet_name='单位',index=False) 和 writer.save()，将多个数据帧写入同一个工作簿的多个sheet(工作表) 3.查看、检查数据
df.head(n)：查看DataFrame对象的前n行df.tail(n)：查看DataFrame对象的最后n行df.shape()：查看行数和列数df.info()：查看索引、数据类型和内存信息df.columns():查看字段（首行）名称df.describe()：查看数值型列的汇总统计s.value_counts(dropna=False)：查看Series对象的唯一值和计数df.apply(pd.Series.value_counts)：查看DataFrame对象中每一列的唯一值和计数df.isnull().any(): 查看是否有缺失值df[df[column_name].duplicated()]:查看column_name字段数据重复的数据信息df[df[column_name].duplicated()].count():查看column_name字段数据重复的个数df[col1].unique() :查看col1字段的唯一值df[col1].nunique():查看col1字段唯一值个数 4.数据选取
df[col]：根据列名，并以Series的形式返回列df[[col1, col2]]：以DataFrame形式返回多列s.iloc[0]：按位置选取数据s.loc['index_one']：按索引选取数据df.iloc[0,:]：返回第一行df.iloc[0,0]：返回第一列的第一个元素df.loc[0,:] ： 返回第一行（索引为默认的数字时，用法同df.iloc），但需要注意的是loc是按索引,iloc参数只接受数字参数df.ix[[:5],["col1","col2"]] ： 返回字段为col1和col2的前5条数据，可以理解为loc和iloc的结合体。df.at[5,"col1"] ：选择索引名称为5，字段名称为col1的数据df.iat[5,0] ： 选择索引排序为5，字段排序为0的数据data.str.contains("s") ： 数据中含有"s"字符串的数据data.astype(int).isin(list1) ：数据的某条数据的某个字段在列表list1中的数据df[-df[column_name].duplicated()] ：选取column_name字段不重复的数据，支持df[-df.duplicated()]df.loc[df['col_name']==value,:]：选取col_name字段为value的数据df.loc[df['col_name'].isin(value_list),:]：选取col_name字段为value_list中的值的数据 df.loc[~df['col_name'].isin(value_list),:]：选取col_name字段不在value_list中的值的数据df.loc[(df['col_name1'] == value1) &amp; df['col_name2'].isin(value_list)]：选取col_name1等于value1，并且col_name2在value_list中的数据df.loc[(df['col_name1'] == value1) | df['col_name2'].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e723d6b4d6503cc0e1e968c7a07aa4cd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55feb34eebb16ce11771fc1e13d2b88c/" rel="bookmark">
			关于TPS与CPU的性能综合分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 关于TPS与CPU的性能综合分析 1.长时间压测过程中TPS不断下降，CPU使用率不断降低
原因：线程死锁导致
使用jps -l获取线程信息
使用jstack -l {PID} 查看线程死锁或则线程阻塞情况
线程死锁：搜索deadlock关键字进行查找
线程阻塞：搜索blocked关键字进行查找
2.并发数不断增加，TPS上不去，CPU使用率较低
原因：SQL没有创建索引/SQL语句筛选条件不明确、代码中设有同步锁。
优化SQL
去掉同步锁
3.高并发下大量报错
原因解析：常见的原因有短连接导致的端口被完全占用以及线程池最大线程数配置较小及超时时间较短导致。
调优方案：
短连接问题：修改服务节点的tcp_tw_reuse参数为1，释放TIME_WAIT scoket用于新的连接。
线程池问题：修改服务节点中容器的server.xml文件中的配置参数。
# 最大线程数，即服务端可以同时响应处理的最大请求数 maxThreads="200" # Tomcat的最大连接线程数，即超过设定的阈值，Tomcat会关闭不再需要的socket线程 maxSpareThreads="200" # 所有可用线程耗尽时，可放在请求等待队列中的请求数，超过该阈值的请求将不予处理，返回Connection refused错误 acceptCount="200" # 等待超时的阈值，单位为毫秒，设置为0时表示永不超时 connectionTimeout="20000" 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/219e2903f365292b531064e10c2890b8/" rel="bookmark">
			第五篇 《小强升职记》
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、找到时间黑洞，找到职业价值观 “时间黑洞”，顾名思义，它会永无止境地吞噬你的宝贵时间。
超市时间黑洞、电视时间黑洞、网络时间黑洞……这些黑洞共同的特点是提供很多相互关联的信息吸引我们的注意力，使消耗的时间在不知不觉中膨胀。
做事之前有预期，并且追求预期的结果，这就是主动运用时间；否则就是被动运用时间，而时间黑洞，就是被动时间的集合。
时间黑洞不仅将“被动时间”吞噬，还会破坏“主动时间”。所以，要学会记录和分析时间，不给黑洞留下任何机会！利用好“时间日志”避开时间黑洞、找到高效时段。
做一个时间统计表，将自己的工作分为“集中精力工作、无意义浪费时间、真正的休息”三种状态，连续五个工作日，每隔一个小时记录下自己究竟处于哪个状态，从早上8点开始到晚上21点结束。在周六上午统计一下在过去的70个小时中，三种状态所占的时间比例。
记录时间日志的好处：a、提醒你珍惜时间，b、分析自己时间的投入与产出，c、找到你的最高效时间段。
二、学习四象限法则、衣柜整理法 1、四象限法则
四象限法则是由著名管理学家史蒂芬·科维提出的一个时间管理理论，该理论把事情按照重要和紧急程度划分为四个象限：重要而且紧急、重要但不紧急、不重要但紧急、不重要而且不紧急。
要分清事情是重要还是紧急，需要了解自己的职业价值观。搞清楚自己的价值观，进而找到工作中重要的事。要找职业价值观，按照书中测试来做。当然不同年龄价值观可能会变。
处理四象限事务的原则：
第一象限：立即去做。但是要思考真的有那么多重要而且紧急的事情吗？。
第二象限：有计划去做。分解任务，提前制作时间规划表，任务分解后，会有很多步骤，你不用记住，因为你记住太多事会压力大，你用电脑系统记，然后用“下一步做什么”来督促自己。
第三象限：交给别人去做。你要明确自己的责任边界，学会拒绝他人身上的猴子。甩掉自己身上的猴子，或者将猴子放回到他的主人身上。例如回避老板，抛回给下属，婉拒同事，推迟老婆，快速解决家里事。真的要接手，接手的猴子要明确对方的想法和预期，这样自己能够顺利开展工作。
第四象限：尽量别去做。适当放松就好。
要事第一原则，在高效能人士的七个习惯里写过，是个很重要的原则。琐事越做越多，要事越做越少。
2、衣柜整理法
“做事靠系统，不是靠感觉。优秀的人有优秀的系统，普通的人有普通的系统，失败的人没有系统。”书中的这句话说得很有道理。要想有效地管理时间首先要建立一套可行的系统。
若干年前的代码写得不规范，又没有认真写文档，那时候埋下的雷，恰好今天引爆而已，你以为临时突发事件真的是‘临时’而且‘突发’？这是看似偶然的必然事件！临时突发事件是无法避免的，只能是降低其发生的概率。为了降低其概率，我们做事就要靠系统，而不是靠感觉，做事如果没有逻辑性，就可能导致现在做的事，是在为未来埋雷。另外，要做好万全准备，应对突发情况。
而衣柜整理法就是这样一套可行的系统。整理衣柜的五个步骤对应时间管理的五个流程。捕捉、明确意义、组织整理、深思、行动。这种时间管理方法称为“衣柜整理法”，即David Allen的GTD方法。
1）捕捉：清空衣柜
利用纸质便签、电子备忘录等一切工具，将工作事项以及突发、新增事项记录下来，放入“收集篮”，很多突然发生的事情，并不一定要立即去做。
2）明确意义：为衣物分类
明确每一件事情的意义，再决定下一步的行动方案，将事情分成“可以行动”和“不能行动”两种。
“可以行动”的事情包括：
a.2分钟行动（比如：打一个电话是2分钟就可以解决的事情）
b.项目（需要多个步骤，并且需要多部门协调的事情）
c.任务（由多个行动组成是自己要解决的事情，比如制作项目进度计划）
d.指派给别人完成的事情
e.特定时间做的事（比如下周三要交报告）。
“不能行动”的事情包括：
a.垃圾事件（浪费时间、浪费生命的事情）
b.将来某时要做的事情（比如：哪天有空一起去打球）
c.参考资料归档等。
3）组织整理：将分类的衣物重新储存
明确事情的意义后，将工作分入3个清单和1张日程表中。
将来清单：记录未来要做的事，每周翻开来回顾，看看有没有什么事情可以孵化成行动。
行动清单：这是每天的主要清单，完成一项行动后，就划掉一项。
项目清单：记录和项目相关的一切，方便随时补充。
日程表：存放特定时间要做的事情，比如开会、约会等等。
4）深思：对衣物做到心中有数
每天下班和每周这两个时间段对任务清单进行深思，至少会获得三个好处：孵化杂事、产生灵感、提升高度。
每天下班前问自己4个问题：
今天做了些什么？
对哪些比较满意，哪些不满意？
推进了哪些重要的事？
明天的规划是什么？
每周回顾时要5件事情：
整理办公桌或收拾家里的环境；
检视将来清单、行动清单和项目清单，浏览一下看看下一步应该做些什么；
检视日程表，看看下周有哪些会议或约会；
回顾本周收集到的一些资料；
回顾年度目标
5）行动：选择最佳方案来执行
David Allen提出：我们的工作和人生可以划分成6个高度去进行检视和规划,具体如下：
原则（五万英尺）：思考自己的价值观、原则和目标，这是工作的灵魂所在。
愿景（四万英尺）：包含3-5年的工作目标，可以是职位的，也可以是组织能力、协调能力等。
目标（三万英尺）：比愿景更细化的东西，通常是在一年内可以有一个阶段性的成果。
责任范围（两万英尺）：要想把生活中和工作中的每一个角色扮演好，需要执行一些任务，拉近现实与期望的距离。
任务（一万英尺）：要将注意力放在眼前的任务上。
下一步行动（跑道）：将以上所有的任务放入清单，逐一完成。
三、如何战胜拖延，如何要事优先，如何处理临时突发事件 学会臣服
要想告别拖延症，学会高效管理时间，要学会臣服。臣服精力、臣服环境、臣服天性。人的精力是有限的，并且随着持续的工作精力会越来越下降。
人的大脑有两个天性：第一，大脑喜欢做简单的事情；第二，大脑对有时间底线的事产生紧迫感。
所以，可以利用番茄工作法来改变工作节奏，这是对精力的臣服，不和精力直接对抗，而是让精力还没有透支的时候就休息、恢复。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/219e2903f365292b531064e10c2890b8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46f56064a9a948489cc0ec7cca23c1e6/" rel="bookmark">
			easyx图形库-----贴图技巧之透明贴图与位运算（与运算、或运算、异或运算）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
位运算
1.与运算&amp;
2.或运算 |
3.异或运算^
2.图形库颜色位运算与透明贴图实现
相关操作码
透明贴图的实现
我们都知道电脑的系统处理方式都是以二进制去处理的，每一个数据的背后都是二进制数字0跟1表示，那么这一期我就来介绍怎么去利用二进制数字来处理图像，实现透明贴图。
位运算 二进制数的位运算的表示方法有------原码、反码、补码
符号位：正数的符号位为 0 ，负数的符号位为 1
正数的原码=反码=补码
负数的反码是原码除了符号位不变其他按位取反，补码就是反码+1
位运算规律：正数的位运算就是直接利用其原码就行了，而负数（符号位为1）的位运算要用补码才可以进行
结果取值：如果运算结果的符号位为1，那么就要取结果的补码才是最后的结果；如果符号位为0的话，那么就不需要多余的操作，直接就是结果
位运算理解方法：我们可以用数学的方法去理解位运算，令：1为真，0为假
1.与运算&amp; 0&amp;0=0
0&amp;1=0
1&amp;0=0
1&amp;1=1
规律：一真一假结果为假，也就是0
两个都是假的，结果也是假，结果为0
两个都是真的，结果就是真，结果为1
示例：
#include&lt;stdio.h&gt; int main() { printf("%d\n",12&amp;10); printf("%d\n",-7&amp;5); } //输出结果是 第一个是8 第二个1 与运算&amp; 过程如下:
12的二进制数原码是0000 1100 10的二进制数原码是0000 1010
&amp;运算结果是 0000 1000
再转化为十进制得到结果为 8 -7的补码是1111 1001
5的原码是 0000 0101
结果 0000 0001
十进制结果是 1
2.或运算 | 0 | 1=1
1 | 0=1
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/46f56064a9a948489cc0ec7cca23c1e6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5a4af26da46c130da7ed92287d3082a/" rel="bookmark">
			navicat 官网历史版本下载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 navicat下载 navicat 下载前往navicat官网选择官网给的 64位 直接下载右键 这里，复制官网下载的链接地址 navicat使用打开工具手动 navicat 下载 前往navicat官网 前往 Navicat | 产品 进行下载
选择官网给的 64位 直接下载 右键 这里，复制官网下载的链接地址 会得到 https://xxxxx.xxxx.xxx.xx/xxxxxxx/navicat161_mysql_cs_x64.exe 将 161 改为 150 这样获取到的就是15版本 附上官网图片：
navicat使用 先不急着打开navicat 打开工具 Navicat Keygen Patch
上面我们安装的是navicat 15版本，选择对应版本点击Patch，找到navicat 15的应用程序，并选择打开出现提示Products 选择MySQL，点击生成，并复制打开navicat 应用程序，粘贴刚刚复制的码 手动 将request码复制到工具里，点击Generate，就会生成新码，点击复制将复制的码，粘贴过去，点击完成！ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/610e09cd6ada593b303b15723ebf1cf4/" rel="bookmark">
			python--wordcloud库的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.wordcloud库简介
2.wordcloud的基本使用
3.wordcloud使用实例（在图形中生成词云）
1.词云库简介
wordcloud库是python中的一个第三方库，wordcloud直译过来是“词云” 词云：以词语为基本单位，更加直观和艺术的展示文本。
另外词云库需要先自行安装 安装方法：
命令行安装：cmd中执行pip install wordcloud命令 自己去python官网下载whl文件再安装
在编辑器中安装（pycharm可在python package栏搜索wordcloud下载）
2.词云库的基本使用
具体步骤：
配置对象参数加载词云文本 输出词云文件 (1)配置对象参数
import wordcloud '括号里的参数为空则全都采用默认值' w=wordcloud.WordCloud() 常见参数：
width：指定词云对象生成图片的宽度，默认400像素
height：指定词云对象生成图片的高度，默认200像素
min_font_size：指定词云中字体的最小字号，默认4号
max_font_size：指定词云中字体的最大字号，默认根据高度参数自动调节
mask：指定词云形状，默认长方形
(2)加载词云文件
w.generate('dream is possible') '内容可以是一段文本也可以是打开的文件' 加载词云文件通常用generate方法 参数为一段文本或者一个打开的文本文件
(3)输出词云文件
w.to_file('123.png') 把文件保存为图片文件
一段最简单的词云就制作完成了 但是这样子简单的词云并不好看 3.wordcloud使用实例（在图形中生成词云）
要在图形中生成词云 首先需要有一个图形 图形要求尽量简单而且封闭的图形(不然电脑可能识别不出来)
浅浅画个爱心吧：
from turtle import * def love(): for i in range(200): right(1) forward(1) pensize(2) speed(10) color('black','red') begin_fill() left(140) forward(111.65) love() left(120) love() forward(111.65) end_fill() hideturtle() done() 爱心样式：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/610e09cd6ada593b303b15723ebf1cf4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/257dd99b3c5c7d4c17813629227a67bc/" rel="bookmark">
			linux命令查看出口ip公网ip
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		linux命令查看出口ip命令如下
curl cip.cc
截图：
代码示例：
[root@localhost ~]# curl cip.cc
IP : 111.192.150.186
地址 : 中国 北京
运营商 : 联通
数据二 : 北京市 | 联通
数据三 : 中国北京北京市 | 联通
URL : http://www.cip.cc/111.192.150.186
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e96e188b1925f4779734b30049d1fcd/" rel="bookmark">
			2023最新大数据毕设题目推荐100例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 0 前言1 如何选题1.1 选题技巧：如何避坑(重中之重)1.2 为什么这么说呢？1.3 难度把控1.4 题目名称1.5 最后 2 大数据 - 选题推荐2.1 大数据挖掘类2.2 大数据处理、云计算、区块链 毕设选题2.3 大数据+安全类2.4 python大数据 游戏设计、动画设计类2.5 大数据-图像识别算法类 3 最后 0 前言 Hi，大家好，大四的同学马上要开始毕业设计啦，大家做好准备了没！
学长给大家详细整理了最新的 大数据专业 相关选题，对选题有任何疑问，都可以问学长哦~
毕设帮助，开题指导，资料分享：
https://gitee.com/yaa-dc/warehouse-1/blob/master/python/README.md
1 如何选题 如何选题这是大部分同学最关心的事情，选的太难怕做不出，选的太简单又怕答辩没法通过，天临、卢雷这几个持续推高毕业的难度，预计从2023年开始本科毕业答辩难度会上升好几个level ~
1.1 选题技巧：如何避坑(重中之重) 毕设选题实际上对很多同学来说一个大坑， 每年挖坑给自己跳的人太多太多，选题选得好后面的答辩以及论文撰写会轻松很多，选的不好就是一个无穷无尽的折磨。。。。
1.2 为什么这么说呢？ 其实这主要是由于大部分同学对某种具体场景所需要的技术不清晰而导致的，定题的时候想当然的觉得某种功能是很好实现的，但是实际上往往并非如此。
所以，建议对课题实现技术不清晰的同学，最好是找自己的研究生学长或者老师详细的把关机技术以及实现流程理清楚，当然也可以来问我。
1.3 难度把控 (对于只要求顺利毕业的同学)定题不能定的太难，也不能定的太简单。太难了，自己做不出；太简单了，工作量不够，论文也没法写， 甚至进不了答辩。
1.4 题目名称 还有，最近很多同学跟学长反应，自己定的题目总是被老师打回去，这还真不怪老师，我看到你们定的题目也是哭笑不得。。。。。
学长在这里给你们分享一个定题标准，跟着这个标准定题准没错：
“使用了什么算法(技术) + 在什么场景下 + 解决了哪一类问题”
1.5 最后 学长限时开放开题指导，对开题有任何不明白的，对某项技术或算法不理解的，不知道怎么下手毕设的，都可以问学长，学长会根据你的情况提供帮助，希望能帮助到你。
2 大数据 - 选题推荐 👍废话不多说，学长在这给大学分享珍藏已久的选题大全，如果有帮到你请点个赞👍
2.1 大数据挖掘类 基于python的邮件分类系统
文本情感理解技术研究
干细胞分裂与生长跟踪研究
行为活动理解中的弱监督学习研究
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2e96e188b1925f4779734b30049d1fcd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce6092ed136c7ae551a2a5884d96f9e7/" rel="bookmark">
			Kafka Consumer auto.offset.reset 理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先来一下 kafka 官网对于 auto.offset.reset 的解释：
上面的描述挺准确的，但如果没有相关背景会感觉很懵逼。网上也有很多文章讲这个东西并给了很多例子，看了之后总感觉没有理解清楚。
先来看一下怎么查看消费者 group 的 offset 情况：
每个 consumer group 会为每个消费的 partition 保存 offsets，这些 offsets 被保存在 kafka 的内部 topic：__consumer_offsets。
假设有一个 group：demo-consumer-group 和一个 topic：demo-topic，并且只有一个分区，先向其中发送两条消息。
运行 kafka 的管理脚本：
bin/kafka-consumer-groups.sh --describe --bootstrap-server 127.0.0.1:9092 --group demo-consumer-group 重点：下面的描述都是针对一个消费者 group 的，不同消费者 group 的 CURRENT-OFFSET、LOG-END-OFFSET、LAG 将会重新计算。
这个 partition 有两条消息，所以 LOG-END-OFFSET 是 2。
当有消费者 A 来消费这个分区的时候，auto.offset.reset 被设置成 latest，因为还没有正确设置 offset，这个消费者不会消费之前的消息，从 CURRENT-OFFSET 可以看出来。LAG 表示当前消费者还剩多少消息没有消费。
这里有个数据丢失的场景， 当这个消费者 A 收到第三条消息的时候，如果处理失败没有提交 offset，LOG-END-OFFSET 变成了 3，但是 CURRENT-OFFSET 还是未设置。这个时候发生重平衡，消费者 B 被分配到来消费这个分区的消息，消费者 B 也是消费不到第三个消息的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ce6092ed136c7ae551a2a5884d96f9e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/325009ea82104da00d8271fd8c241c1c/" rel="bookmark">
			HTML标签之段落＜p＞、换行＜br＞、水平线＜hr＞
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、段落标签 段落是通过&lt;p&gt;标签（双标签）定义的
&lt;p&gt;这是一个段落&lt;/p&gt; &lt;p&gt;这还是一个段落&lt;/p&gt; 二、换行标签 &lt;br&gt;标签在不产生一个新段落的情况下换行。
&lt;br&gt;是一个空的HTML元素（单标签）。
&lt;p&gt;不产生段落&lt;br&gt;进行换行&lt;/p&gt; 三、水平线 &lt;hr&gt;标签在HTML页面中创建水平线，需要在内容后添加，否则，水平线就在内容上方。
&lt;p&gt;一条水平线&lt;hr&gt;&lt;/p&gt; &lt;hr&gt;属性：
color：设置水平线颜色（如&lt;hr color="red"&gt;）width：设置水平线的长度（&lt;hr width="300px"&gt;）size：设置水平线的高度（&lt;hr size="20px"&gt;）align：设置水平线的对齐方式（默认居中），可取值 left | right。 &lt;p&gt;一条宽200px高20px居右的红色水平线&lt;hr width="200px" align="right" size="20px" color="red"&gt;&lt;/p&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e050eca99c7c4750e9f0f0459729ac59/" rel="bookmark">
			HTML标签之标题＜h1＞~＜h6＞
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 标题（Heading）通过&lt;h1&gt;~&lt;h6&gt;标签进行定义的，其中&lt;h1&gt;定义最大的标题，&lt;h6&gt;定义最小的标题，是双标签。
vscode生成h1~h6的快捷键：h$*6
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;标题标签&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;标题一&lt;/h1&gt; &lt;h2&gt;标题二&lt;/h2&gt; &lt;h3&gt;标题三&lt;/h3&gt; &lt;h4&gt;标题四&lt;/h4&gt; &lt;h5&gt;标题五&lt;/h5&gt; &lt;h6&gt;标题六&lt;/h6&gt; &lt;/body&gt; &lt;/html&gt; 正确使用标题
确保将HTML标题标签只用于标题不要为了生成粗体或大号文本而使用标题正确使用标题有益于SEO&lt;h1&gt;用作标题（最重要），随后是&lt;h2&gt;（次要的 ）等等。 标签属性
标签属性属性值属性值含义alignleft | center | right（默认居左）内容 居左| 居中 | 居右 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca5f7347a005e883f207ccc2fb396f5c/" rel="bookmark">
			Java学习中对于public类的一点探讨
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、在一个源文件中，必须要有public类？
1.探索
2.总结
二、一个java源文件最多一个public类？
三、java应用程序必须要有主类？
四、Java中的应用程序主类比必须为public类？
一、在一个源文件中，必须要有public类？ 1.探索 在一个源文件中必须有一个public，这个可就难到我了，我在做的时候确实是不知道，但是只需要把我上面的程序public删掉就能测试
测试结果
我考虑到可能本身类的前后顺序造成影响，于是将其调换位置
两次均未出现报错，并且能够正常找出最大值。因此在一个源文件中可以没有public类。
那么public到底是什么，它到底有什么用?目前我学到的位置(也许我进度有点慢)都没有讲到这个问题。但随着学习过程这个问题也会得到解决。search了一下:pubic是java访问权限饰词,另外还有protect,frendly,private三个访问权限饰词(公开，保护，友好，私人）。想起来上个学期在写c语言大作业时为了能让c语言主函数能够调用cpp源文件的函数，要在cpp的.h头文件里每个函数前加上extern(外部的)，感觉似乎也是开放了权限，当然我仍然对此保持疑问。
回到题目，第三题的实践证明了可以不用public，这时文件名可以跟任意一个类名相同。而有public时必须得与public类保持一致。那么程序的开始执行的位置(或者说程序的主类)是不是由文件名决定的呢?还是说由main方法位置决定?
我将第三题的源代码的文件名改为Max
报错了,在类Max没有找到主方法。这意味着文件名应该与含有主方法的类名保持一致(此处是错误的，我当时并不知道，后面会推翻)。注意到编译并不会报错，但解释运行会报错。
这时新的问题出现了，我在网络上查询到的资料都说一个java源文件当有public类时文件名与public类保持一致，并且public类最多只能有一个。那么我将类Max改为public而类input则不加修饰词(网上说如果一个class的数据成员和方法都没有任何权限饰词，那么它的缺省访问权限就是friendly，这里input中有public修饰的main方法，那么类input是哪种访问权限呢?)
结果加不加public都是一样的，那么网上的说法错误了吗？我将文件名改回input但仍然保持Max为public而input不加饰词。
在编译时就报错了，类Max是public的，应该在名字叫做Max.java的文件中声明。
说明网上的说法并没有错误。
而都不加public时为什么不报错？是原本就无错误还是不加饰词时将其自动设为public访问权限呢?
由于我不知道如何得知不加饰词时类的访问权限到底是哪一级，这个问题我暂时无法解答。
当我们源文件有多个类时，我发现javac后就会有对应数目的class后缀文件(字节码文件)
字节码文件的名字只与类名有关,在最前面两个类都无public时解释运行出错，会不会是我的操作错误呢?
因为java解释器解释的是字节码文件而不是那个源文件，如果我打java input会不会就不报错呢?
正确的
如果文件名不为类名呢?
也一样没有出错，这就比较让人疑惑了,我在网上看到的都是说可以跟任意类名一致，其实是可以为任何名字
我在类input前面加上public,文件名仍然为test.java。前面实际已经求证过了，这时是会报错的
2.总结 一个源文件可以没有public类，当没有public类时，文件名可以跟任何一个类名保持一致,并无限制，可以随意命名。程序从主方法开始执行。不从主方法执行将会报错，说这个类没有主方法
当源文件有public类时，那么这个public类只能有一个，并且文件名应该与public类名保持一致，并且必须该类可以不含有主方法。
当有public类时，这个类中可以没有main方法，实例就是课本第一章的例子2(此处学习通的图片上传出现问题，我直接用图床的网址
&lt;img src="https://pic.imgdb.cn/item/622beb745baa1a80ab4b1a5e.png"&gt;
该程序是无任何问题的
&lt;img src="https://pic.imgdb.cn/item/622bec965baa1a80ab4b81f5.png"&gt;
二、一个java源文件最多一个public类？ 两个public，javac报错:class Max应该在命名为Max.java的文件中声明，如果将名字改为这个可以想到class input就会报错
三、java应用程序必须要有主类？ 我在网上搜索了java主类是什么，但是看到了不同的答案，有说是主方法所在的类，有说是程序里定义了一个public class 里面有main函数或者程序执行的入口。第二个说法从上面我的测试中就能知道是错误的，一个java源文件可以没有public。
那么第一种说法到底正不正确呢?首先我并没有找到主类的概念，无法从概念入手。但从字面理解，应该是最开始执行的类就像c语言里的主函数。
既然这样，可以想到的是，我们在做一个有多个源文件的项目时，可以只有一个源文件有主类，其它的类都在该主类中调用。那么其它的源文件就没有主类。
四、Java中的应用程序主类比必须为public类？ 在前面的实例中有很多主类不是public类的程序，比如都不是public类，以及课本例子2将主方法放到了class
A而不是public class people。因此第六题是错误的
对于第五题，首先从第七题的代码入手，其刚好是一个没有main方法的程序
&lt;img src="https://pic.imgdb.cn/item/622becdd5baa1a80ab4b9da2.png"&gt;
程序在解释运行时会报错,class Dog内没有主方法。
网上有这样的论述：
任何一个Java Application应用程序必须有且只有一个main方法，它是整个程序的入口方法；任何一个Applet小应用程序要求程序中有且必须有一个类是系统类Applet的子类，即该类头部分以extends Applet结尾。
应用程序的主类当源文件中只有一个类时不必用public修饰，但当有多于一个类时则主类必须用public修饰。小应用程序的主类在任何时候都需要用public来修饰。
原文链接：java程序是由什么组成的？一个程序中必须要有public类吗？java源文件的命名规则是怎样的？_java语言多选题 (3)..._我与我 周旋久的博客-CSDN博客
实际上我在网上看到了很多关于主类必须用public来修饰的论断，可是我的测试则证明java应用程序的主类可以不是public类。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ca5f7347a005e883f207ccc2fb396f5c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e10ed5c234c31ef1789f77796725149c/" rel="bookmark">
			【GreenDAO】使用时遇到的新鲜用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 GreenDAO 先按一种方式排序，再按另一种方式排序
排序可以多次调用，先按照一种方式排序，当按第一种方式排序内容相同时，按照第二种方式排序。
daoSession.contactDao.queryBuilder() .where(ContactModelDao.Properties.UserName.eq("LiMing")) .orderDesc(ContactModelDao.Properties.Age) //先按年龄排序 .orderDesc(ContactModelDao.Properties.Class) //年龄相同按班级排序 .list() 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e453ca89b51ecde230b122971c9bdc64/" rel="bookmark">
			STM32 —— RT-Thread Nano 移植
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 实验环境一、RT-Thread系统概述架构 二、CubeMX 安装 Nano Pack三、Keil MDK安装 RT-Thread四、CubeMX 项目配置五、代码修改六、运行结果七、实验总结 实验环境 KEIL
STM32F103C8T6
杜邦线
mcuisp烧录工具
firetool串口助手
一、RT-Thread系统 概述 它是一个嵌入式实时多线程操作系统，基本属性之一是支持多任务。事实上一个处理器核心在某时刻只能运行一个任务，由于每次对一个任务的执行时间很短、任务与任务之间通过任务调度器进行快速的切换，给人造成多个任务在同一时刻同时运行的错觉。
RT-Threa系统中，任务通过线程实现的，RT-Thread中的线程调度器也就是以上提到的任务调度器。
架构 物联网操作系统是指以操作系统内核(RTOS\Linux等)为基础，包括如文件系统、图形库等较为完整的中间件组件，具备低功耗、安全、通信协议支持和云端连接能力的软件平台。
RT-Thread与其他很多RTOS主要区别之一是：它不仅仅是一个实时内核，还具备丰富的中间层组件，如下图所示。
内核层：RT-Thread内核，是RT-Thread的核心部分，包括了内核系统中对象的实现，例如多线程及其调度、信号量、邮箱、消息队列、内存管理、定时器等；libcpu/BSP(芯片移植相关文件/板级支持包)与硬件密切相关，由外设驱动和CPU移植构成。组件与服务层：组件是基于RT-Thread内核之上的上层软件，例如虚拟文件系统、FinSH命令行界面、网络框架、设备框架等。采用模块化设计，做到组件内部高内聚，组件之间低耦合。RT-Thread软件包：运行于RT-Thread物联网操作系统平台上，面向不同应用领域的通用软件组件，由描述信息、源代码或库文件组成。物联网相关的软件包：Paho MQTT、WebClient、mongoose、WebTerminal 等等。脚本语言相关的软件包：目前支持 JerryScript、MicroPython。多媒体相关的软件包：Openmv、mupdf。工具类软件包：CmBacktrace、EasyFlash、EasyLogger、SystemView。系统相关的软件包：RTGUI、Persimmon UI、lwext4、partition、SQLite 等等。外设库与驱动类软件包：RealTek RTL8710BN SDK。 二、CubeMX 安装 Nano Pack 这里我们可以参考官方的教程：基于 CubeMX 移植 RT-Thread Nano
要获取 RT-Thread Nano 软件包，需要在 CubeMX 中添加
https://www.rt-thread.org/download/cube/RealThread.RT-Thread.pdsc
这里我们需要使用在 CubeMX 中添加硬件包同样的方式来添加我们要使用的 RT-Thread Nano 软件包，过程如下：
打开 CubeMX，从菜单栏 help 进入 Manage embedded software packages 界面，点击 From Url 按钮，进入 User Defined Packs Manager 界面，其次点击 new，填入上述网址，然后点击 check，
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e453ca89b51ecde230b122971c9bdc64/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c62d286a9257856aa24942b6b16220cd/" rel="bookmark">
			【SpringCloud Alibaba】Sentinel持久化结合Nacos
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在前面学习完Sentinel的流控规则以及Nacos时，就是最后的Sentinel持久化了。需要持久化的原因是因为每次启动Sentinel都会使之前配置的规则就清空了，这样每次都要再去设定规则显得非常的麻烦。
思路就是：将流控规则配置进Nacos服务注册中心中，这样每次启动Sentinel无需配置规则就有规则，但前提是启动完Sentinel后要先进入方法才看得到规则，因为Sentinel是懒加载机制。
一、引入依赖 &lt;!--SpringCloud Alibaba Sentinel-datasource-nacos 持久化技术--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.csp&lt;/groupId&gt; &lt;artifactId&gt;sentinel-datasource-nacos&lt;/artifactId&gt; &lt;version&gt;1.8.1&lt;/version&gt; &lt;/dependency&gt; 二、启动类注解 @SpringBootApplication @EnableDiscoveryClient public class CloudAlibabaSentinelService { public static void main(String[] args) { SpringApplication.run(CloudAlibabaSentinelService.class, args); } } 三、改yml server: port: 8401 spring: application: name: cloud-sentinel-service cloud: nacos: discovery: server-addr: localhost:8848 #Nacos服务注册中心地址 sentinel: transport: dashboard: localhost:8080 #配置 dashboard监控平台地址 port: 8719 #默认8719端口 如果被占用就自增直至找到未被占用的端口 datasource: ds1: nacos: server-addr: localhost:8848 dataId: ${spring.application.name} groupId: DEFAULT_GROUP data-type: json rule-type: flow #暴露监控断点 management: endpoint: sentinel: enabled: true endpoints: web: exposure: include: '*' 四、写控制层逻辑 @RestController public class SentinelController { @GetMapping("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c62d286a9257856aa24942b6b16220cd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/337dfc7cddb124f68aca144c470b668c/" rel="bookmark">
			抖音超火圣诞树代码， 源码分享，赶紧试试吧
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		圣诞节到了，今天给大家分享分别用HTML和Python的代码写一颗豪华的圣诞树送给大家吧！
一.HTML版本 豪华动态抖音同款圣诞树
&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Frameset//EN" "http://www.w3.org/TR/html4/frameset.dtd"&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;html53D逼真圣诞树&lt;/title&gt; &lt;meta charset="utf-8" &gt; &lt;style&gt; html, body { width: 100%; height: 100%; margin: 0; padding: 0; border: 0; } div { margin: 0; padding: 0; border: 0; } .nav { position: absolute; top: 0; left: 0; width: 100%; height: 27px; background-color: white; color: black; text-align: center; line-height: 25px; } a { color: black; text-decoration: none; border-bottom: 1px dashed black; } a:hover { border-bottom: 1px solid red; } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/337dfc7cddb124f68aca144c470b668c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d82584a04bc40b13db327538db7ce1e2/" rel="bookmark">
			pip install 安装指定版本的包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		要用 pip 安装指定版本的 Python 包，只需通过 == 操作符 指定 pip install --user annoy==1.15.1
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55b7e85b7a9c8368b3fa2d06d3d6f42c/" rel="bookmark">
			DataFrame增删改
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		01.DataFrame行操作
1.添加行
基本格式：
方法：df.append(other) 说明：向 DataFrame 末尾添加 other 新行数据，返回新的 DataFrame
示例：
（1）加载 scientists.csv 数据集
import pandas as pd scientists = pd.read_csv('./data/scientists.csv') scientists （2）在 scientists 数据末尾添加一行新数据
# 准备新行数据 new_series = pd.Series(['LuoGeng Hua', '1910-11-12', '1985-06-12', 75, 'Mathematician'], index=['Name', 'Born', 'Died', 'Age', 'Occupation']) new_series （3）在 scientists 数据末尾添加一行新数据 # 返回新的 DataFrame scientists.append(new_series, ignore_index=True) 2.修改行
基本格式：
方法1：df.loc[['行标签', ...],['列标签', ...]] 说明：修改行标签对应行的对应列的数据
方法2：df.iloc[['行位置', ...],['列位置', ...]] 说明：修改行位置对应行的对应列的数据
示例1：修改行标签为 4 的行的所有数据 修改之后：
scientists.loc[4] = ['Rachel Carson', '1907-5-27', '1965-4-14', 57, 'Biologist'] scientists 示例2：修改行标签为 4 的行的 Born 和 Age 列的数据
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/55b7e85b7a9c8368b3fa2d06d3d6f42c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ea9f32bc70bcd8e058ae6b3a5f10133/" rel="bookmark">
			java中的new BufferedReader(new InputStreamReader(System.in))
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		流 JAVA /IO 基本小结
通过一行常见的代码讨论：new BufferedReader(new InputStreamReader(System.in))
java的IO是基于流（stream）概念的，什么是流呢，作为初学者，
我是这样理解的，在各个应用之间传送的是BITS，这些BIT可已被认为是流体，可以就认为是水流，那么用来在各个水源之间转移水的工具应该选择什么呢？一般情况下，水管是可以的，所以数据我将数据源比作水源，将流对象比作水管
这样就有了对流的第一步认识，它再也不神秘了。
对于流，我们要研究些什么呢，我们主要是针对应用掌握流的特性，而之后根据流的特性，我们转移不同的数据时，选择不透的流对象，达到我们的目的。
下面让我们从一行常见的代码来分析流吧！
new BufferedReader(new InputStreamReader(System.in))，这是用来从键盘接受一行输入的代码，下面我们从里到外进行分析吧。
System.in的类型是InputStream，它代表的是键盘接受的输入，就是说键盘是数据源；System.in的类型可以归结为节点流、字节流、输入流；接下来是InputStreamReader这个对象是处理流，字符流，输入流；
最外面的是BufferedReader的类型是缓冲处理流、字符流、输入流。是不是有点绕啊，下面我们就从流的分类开始。
流的分类
（重点的通过分类记住这些流的模样）
按照方向分类：
输入流和输出流
流的输入输出都是以应用程序为基准的，这一点一定要注意。
输入流，模样很好记，一般情况下，输入流是带有Input字样或Reader字样的，如FileInputStream和BufferedReader等等，这些都是输入流。
输出流，一般情况下，是带有Output字样或Writer的，如FileOutputStream和FileWriter等等，详细请查查API文档，看看是不是这样。
至于什么时候使用输入流，什么时候使用输出流，我想我们就不必探讨了吧！
按照处理的单位：
字节流和字符流
字节流，一般是带有Stream字样的，如InputStream,FileInputStream等等，这组流处理的最小单位之字节。
字符流，一般是带有Reader或Writer字样的，如InputStreamReader等等，它们处理的最小单位是字符。
按照数据的来源：
节点流和处理流
节点流的数据来源是应用程序、文件、键盘、等等，是非流对象来源，而处理流的数据来源是其他流对象。
流的使用
一.Input和Output
1.stream代表的是任何有能力产出数据的数据源，或是任何有能力接收数据的接收源。
在Java的IO中，所有的stream（包括Input和Out stream）都包括两种类型：
1.1 以字节为导向的stream
以字节为导向的stream，表示以字节为单位从stream中读取或往stream中写入信息。以字节为导向的stream包括下面几种类型：
input　stream：ByteArrayInputStream：把内存中的一个缓冲区作为InputStream使用StringBufferInputStream：把一个String对象作为InputStreamFileInputStream：把一个文件作为InputStream，实现对文件的读取操作PipedInputStream：实现了pipe的概念，主要在线程中使用SequenceInputStream：把多个InputStream合并为一个InputStreamOut　streamByteArrayOutputStream：把信息存入内存中的一个缓冲区中FileOutputStream：把信息存入文件中PipedOutputStream：实现了pipe的概念，主要在线程中使用SequenceOutputStream：把多个OutStream合并为一个OutStream
1.2 以Unicode字符为导向的stream
以Unicode字符为导向的stream，表示以Unicode字符为单位从stream中读取或往stream中写入信息。以Unicode字符为导向的stream包括下面几种类型：Input　StreamCharArrayReader：与ByteArrayInputStream对应StringReader：与StringBufferInputStream对应FileReader：与FileInputStream对应PipedReader：与PipedInputStream对应Out　StreamCharArrayWrite：与ByteArrayOutputStream对应StringWrite：无与之对应的以字节为导向的streamFileWrite：与FileOutputStream对应PipedWrite：与PipedOutputStream对应
以字符为导向的stream基本上对有与之相对应的以字节为导向的stream。两个对应类实现的功能相同，字是在操作时的导向不同。如CharArrayReader：和ByteArrayInputStream的作用都是把内存中的一个缓冲区作为InputStream使用，所不同的是前者每次从内存中读取一个字节的信息，而后者每次从内存中读取一个字符。
1.3 两种不现导向的stream之间的转换
InputStreamReader和OutputStreamReader：把一个以字节为导向的stream转换成一个以字符为导向的stream。 stream添加属性
2.1 “为stream添加属性”的作用
运用上面介绍的Java中操作IO的API，我们就可完成我们想完成的任何操作了。但通过FilterInputStream和FilterOutStream的子类，我们可以为stream添加属性。下面以一个
例子来说明这种功能的作用。
如果我们要往一个文件中写入数据，我们可以这样操作：
FileOutStream fs = new FileOutStream(“test.txt”);
然后就可以通过产生的fs对象调用write()函数来往test.txt文件中写入数据了。但是，如果我们想实现“先把要写入文件的数据先缓存到内存中，再把缓存中的数据写入文件中”的功能时，上面的API就没有一个能满足我们的需求了。但是通过FilterInputStream和FilterOutStream的子类，为FileOutStream添加我们所需要的功能。
2.2 FilterInputStream的各种类型
2.2.1 用于封装以字节为导向的InputStream DataInputStream：从stream中读取基本类型（int、char等）数据。BufferedInputStream：使用缓冲区LineNumberInputStream：会记录input stream内的行数，然后可以调用getLineNumber()和setLineNumber(int)PushbackInputStream：很少用到，一般用于编译器开发
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0ea9f32bc70bcd8e058ae6b3a5f10133/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/083cacdd3d1f29630bae6c5c5f6cbec5/" rel="bookmark">
			社会统一信用认证正则表达式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 [RegularExpression(@"^9[0-9A-HJ-NPQRTUWXY]{1}\d{6}[0-9A-HJ-NPQRTUWXY]{10}$", ErrorMessage = "统一信用代码错误，请查证后填写")] 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d79370e85df8e8014c1b75033323807/" rel="bookmark">
			TPS波动较大如何排查问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		TPS波动较大如何排查问题 *TPS波动较大产生的原因有以下几种：
网络问题，GC问题，程序资源被占用的问题。*
1.网络问题
需要找到对应的网络监控工具，监控网络整体的传输曲线。
2.GC问题
使用命令查看GC的运行运行情况：
jstat -gc PID 300 10 jstat -gcutil PID 300 10 jstat -gc PID 1000 120 &gt;&gt;test.txt jstat -gcutil PID 1000 120 &gt;&gt;/testgc.txt 查看YGC和FGC的波动情况，如果发现有频繁的FGC，可以通过修改JVM的堆内存参数Xmx。
3.程序资源占用
(1)使用命令：top -H -p ${PID}查看进程的线程占用资源情况。
(2)使用命令：printf “%x\n” ${Tid}将线程对应PID转为 16进制数。
(3)使用命令：jstack PID | grep -A 30 "nid=0x+"转换的16进制数"查看线程的堆栈信息，进行代码分析。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32837ed6f8dc21286ff1d8352dd5d9b1/" rel="bookmark">
			linux解除挂载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		永久解除linux服务器磁盘挂载
1、找到文件 etc--&gt;fstab
2、编辑 vim fstab
3、esc进入编辑状态
4、删除dev/vdb1 /home ext3 defaults o o
5、:wq保存并退出
6、reboot 重启生效
7、df -h 查看是否生效
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b5f3987d31e1307785f76fbd98831aa/" rel="bookmark">
			麒麟v10服务器版本 mysql 安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		麒麟v10服务器版本 mysql 安装 参考的文章关于修改用户密码(可能版本不一样，方式不一样) 参考的文章 https://blog.csdn.net/zhajianting/article/details/127790839
关于修改用户密码(可能版本不一样，方式不一样) mysql&gt; ALTER USER USER() IDENTIFIED BY 'root2022!'; 参考资料1
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92869f86898fabf08834eb196172e3be/" rel="bookmark">
			git 如何清空线上仓库所有文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本次内容主要教大家如何清空线上仓库所有文件
把代码拉下来，进入文件夹中将所有代码删除掉，执行git 命令
git add . git commit -m 'feat:删除线上代码' git pull git push 刷新线上仓库页面或者按F5，代码清空完成
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7fb758c6f919fb904c6e219e1ea6f65f/" rel="bookmark">
			Linux sed -i 替换文本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 sed -i 命令详解 # 对每行匹配到的第一个字符串进行替换 sed -i 's/原字符串/新字符串/' ab.txt # 对全局匹配上的所有字符串进行替换 sed -i 's/原字符串/新字符串/g' ab.txt # 删除所有匹配到字符串的行 sed -i '/匹配字符串/d' ab.txt # 特定字符串的行后插入新行 sed -i '/特定字符串/a 新行字符串' ab.txt # 特定字符串的行前插入新行 sed -i '/特定字符串/i 新行字符串' ab.txt # 把匹配行中的某个字符串替换为目标字符串 sed -i '/匹配字符串/s/源字符串/目标字符串/g' ab.txt # 在文件ab.txt中的末行之后，添加bye sed -i '$a bye' ab.txt # 对于文件第3行，把匹配上的所有字符串进行替换 sed -i '3s/原字符串/新字符串/g' ab.txt 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/906d8fc304cce5830509240afc489b22/" rel="bookmark">
			device_create() 创建设备节点，device_del()删除设备节点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0 背景 最近在尝试开发linux设备驱动，虽然可以在命令行下通过mknod命令手动创建设备节点，但是这种操作不符合标准驱动的开发过程，并且linux内核提供了一组函数函数device_create() 和device_del()可以在加载驱动时候自动在/dev目录下创建相应设备节点，并在卸载模块时删除该节点。
1 函数device_create() 函数device_create()用于动态地创建逻辑设备，并对新的逻辑设备类进行相应的初始化，将其与此函数的第一个参数所代表的逻辑类关联起来，然后将此逻辑设备加到Linux内核系统的设备驱动程序模型中。函数能够自动地在/sys/devices/virtual目录下创建新的逻辑设备目录，在/dev目录下创建与逻辑类对应的设备文件。
struct device *device_create(struct class *cls, struct device *parent, dev_t devt, void *drvdata, const char *fmt, ...); 第一个输入参数代表与即将创建的逻辑设备相关的逻辑类。
第二个输入参数代表即将创建的逻辑设备的父设备的指针，子设备与父设备的关系是：当父设备不可用时，子设备不可用，子设备依赖父设备，父设备不依赖子设备。
第三个输入参数是逻辑设备的设备号。
注:设备号需与创建时保持一致，否则即使创建出设备节点，也是无法正常操作。
第四个输入参数是void类型的指针，代表回调函数的输入参数。
第五个输入参数是逻辑设备的设备名，即在目录/sys/devices/virtual/和/dev创建的逻辑设备目录的目录名。
在驱动的初始化函数中使用，在加载驱动时，生成设备节点。
2 函数device_del() 函数device_del()用于从Linux内核系统设备驱动程序模型中移除一个逻辑设备，并删除/sys/devices/virtual目录下对应的设备目录及/dev目录下对应的设备文件。
void device_del(struct device *dev) 函数的输入参数是struct device结构体类型的指针变量，代表即将从Linux内核系统中删除的逻辑设备，此结构体的定义在函数device_create()中。
在驱动的卸载函数中使用，在卸载驱动时，删除设备节点。
3 实例 3.1 驱动源码 #include &lt;linux/init.h&gt; #include &lt;linux/module.h&gt; #include &lt;linux/fs.h&gt; #include &lt;linux/cdev.h&gt; #include &lt;linux/uaccess.h&gt; MODULE_LICENSE("GPL"); MODULE_AUTHOR("zz"); static dev_t devno; #define KMAX_LEN 32 struct class *my_class; struct device *my_device; static int demo_open(struct inode *ind, struct file *fp) { printk("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/906d8fc304cce5830509240afc489b22/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06a76d42a3a4a37b1027930f49f35b8f/" rel="bookmark">
			手写RPC框架(一)服务端与消息编码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文章是在按照《极客兔兔》的教程完成GEERPC框架时的笔记以及一些自己的理解与看法
原文连接
消息编码 使用 encoding/gob 实现消息的编解码(序列化与反序列化)
将请求和响应中的参数和返回值抽象为body
将服务信息如服务名，方法名等其他信息存放在Header中
type Header struct { ServiceMethod string Seq uint64 //requse ID Error string } ServiceMethod是服务名和方法名，通常与 Go 语言中的结构体和方法相映射。Seq是请求的序号，也可以认为是某个请求的 ID，用来区分不同的请求。Error是错误信息，客户端置为空，服务端如果如果发生错误，将错误信息置于 Error 中 消息的decode和encode的方式有很多，例如json,xml,protobuf 包括go特有的gob,所要实现的框架需要可以做到让用户自主选择编码方式。
为了实现不同的Codec实例，先对消息体编解码的接口进行抽象，抽象出Codec
type Codec interface { io.Closer ReadHeader(*Header) error ReadBody(interface{})error Write(*Header,interface{}) error } 将编码类型枚举出来，（此处只列出了god和josn）
//编码类型 type Type string const ( GobType Type ="application/god" JsonType Type ="application/json" //未实现 ) 因为不同的编码类型对应的函数方法也是不同的，为了方便管理，拿go中的map进行管理，在init函数中为不同编码类型注册对应的方法
var NewCodecFuncMap map[Type]NewCodecFunc func init(){ NewCodecFuncMap=make(map[Type]NewCodecFunc) NewCodecFuncMap[GobType]=NewGobCodec //为对应类型注册方法 } 具体实现 因为不同类型的编码方式，写法大致相同，所以在文章中只实现了gob一种
首先需要定义出GobCodec实例
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/06a76d42a3a4a37b1027930f49f35b8f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69530acc7f6608ed96c3c1d757890231/" rel="bookmark">
			insmod 驱动报错，sysfs: cannot create duplicate filename ‘/class/xxx‘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题分析： dmesg 的报错信息是明确的，指在/class/目录下已经存在xxx 的filename了，在加载驱动时，不可再创建同样的名称。
解决思路： 博主是在自己编写的驱动中遇到的此问题，在卸载驱动后再加载时提示的错误信息。
故而思考是由于卸载驱动时，未对/class目录下创建的文件卸载干净导致的。
问题解决： 在驱动的卸载函数中，添加函数 class_destroy(my_class)即可。
myclass 指在驱动初始化函数中创建的struct class 。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14e62f739ce2532e3c4ad245cd68e09c/" rel="bookmark">
			数据结构折半查找代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		好的，这是一个使用折半查找算法在 Python 中查找数组中某个特定元素的示例代码：
def binary_search(arr, target):# 定义左右边界 left = 0 right = len(arr) - 1 # 当左边界小于等于右边界时循环 while left &lt;= right: # 计算中间索引 mid = (left + right) // 2 # 如果找到了目标元素，返回索引 if arr[mid] == target: return mid # 如果目标元素比中间元素小，则在左半部分查找 elif arr[mid] &gt; target: right = mid - 1 # 如果目标元素比中间元素大，则在右半部分查找 else: left = mid + 1 # 如果没有找到目标元素，返回 -1 return -1 # 测试代码 arr = [1, 3, 5, 7, 9] target = 5 index = binary_search(arr, target) print(index) # 输出 2 折半查找是一种在有序数组中查找元素的高效算法。它的基本思想是，每次查找都将要查找的数组分成两半，并根据目标元素与数组中间元素的大小关系，将查找范围缩小一半。这样，每次查找的复杂度就降低了一半，导致总的查找复杂度大大降低。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1422f9b6397184d8856abc17789df3dd/" rel="bookmark">
			高颜值抓包工具Charles，实现Mac和IOS端抓取https请求
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、Charles介绍
二、Charles下载及安装
三、Charles界面视图介绍
四、Charles抓取HTTPS
Hi，大家好。在进行测试的过程中，不可避免的会有程序报错，为了能更快修复掉Bug，我们作为测试人员需要给开发人员提供更准确的报错信息或者接口地址，这个时候就需要用到我们的抓包工具。
常见的抓包工具有Fiddler、Charles，在此之前介绍过Fiddler抓包：Fiddler抓包详解，今天我们介绍Mac端以及IOS端如何使用Charles抓取https。
一、Charles介绍 1、Charles简介
Charles中文名又叫青花瓷，是一款很实用，界面很友好，功能强大的抓包神器，因为它是基于 Java 开发的，所以跨平台，Mac、Linux、Windows下都是可以使用的，并且在Android和iOS设备上通用。
2、Charles原理
当程序连接Charles的代理访问互联网时，Charles可以监控这个程序发送和接收的所有数据。它允许一个开发者查看所有连接互联网的HTTP通信，这些包括request、response和HTTP headers，通过成为电脑或者移动设备的代理截取请求和请求结果达到分析抓包的目的。
3、Charles作用
截取 Http 和 Https 网络封包。支持重发网络请求，方便后端调试。支持修改网络请求参数。支持网络请求的截获并动态修改。支持模拟慢速网络。 二、Charles下载及安装 1、Charles下载
Charles 是收费软件，可以免费试用 30 天。试用期过后，未付费的用户仍然可以继续使用，但是每次使用时间不能超过 30 分钟，并且启动时将会有 10 秒种的延时。因此，该付费方案对广大用户还是相当友好的，即使你长期不付费，也能使用完整的软件功能。
下载地址:
官网：https://www.charlesproxy.com/
绿色版下载（网上有很多相关下载地址）
For Windows：https://www.7down.com/soft/133829.html
For Mac：http://www.xue51.com/mac/2527.html
注意：安装完后，替换”安装路径-&gt;Charles\lib”文件夹下的charles.jar文件成破解版jar文件，如果再次启动未弹出30天试用的提示，说明成功。
2、Charles安装
(1) Mac端安装
进入Charles官网，选择macOS下载：
下载后安装：
(2) PC端安装
进入Charles官网，选择windows下载：
下载后自行安装即可，此处不再详细介绍。
三、Charles界面视图介绍 1、Charles界面视图
Charles在Mac端的界面：
1)在顶部导航是基本设置、代理设置、工具、帮助等；
2)中间位置是请求的接口名字、请求内容、响应内容等；
3)通常常查看请求会使用"Structure"视图和"Sequence"视图；
Structure：按照接口结构来归档汇总；Sequence：按照接口请求顺序来汇总；
请求栏介绍： 请求数据介绍：
2、Charles界面说明
Charles在Mac端的快捷工具：
快捷工具介绍：
四、Charles抓取HTTPS 1、Mac端配置
(1) Charles代理设置
点击导航栏 Proxy -&gt; Proxy Setting ，端口一般设置8888，按照下图设置即可。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1422f9b6397184d8856abc17789df3dd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3a5a476d1ff0b2b59db2bf34246c6ca/" rel="bookmark">
			java中的方法&amp;有返回值的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		java中的方法：
return语句
return语句
return语句用于从当前执行的方法中退出, 返回到调用该方法的语句处继续 执行。
有两种格式:
return 表达式; //将表达式的值返回
return; //不返回任何值，当方法说明中
public class Method { /* main 方法 java程序的入口，启动java的主线程 方法：类似于C语言中的函数，解决某一问题二编写的代码组合 属于类或者对象 目标：定义方法，调用方法 语法格式： [访问权限修饰符(public) 修饰符 返回值类型(int void表示方法没有返回值)] */ public static void main(String[] args) { //打印乘法口诀表 Method.multi(); } //定义一个方法，用来打印乘法口诀表 //static修饰方法属于类，可以直接通过类名调用 //不加static修饰，方法属于对象，需要通过对象调用 public static void multi(){ for (int i = 1; i &lt;= 9; i++) { for(int j = 1;j &lt;= i;j++){ System.out.print(j+"*"+i+"="+(i*j)+" "); } System.out.println(); } } 有返回值的方法：
/* 两位整数加法运算 方法如果有返回值，必须声明返回值类型 */ public int compute(int a,int b){ int c = a + b; return c;//从方法中向调用处返回一个结果 } public void test(){ int a = 10; int b = 5; if(a&gt;b){ System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e3a5a476d1ff0b2b59db2bf34246c6ca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec117076e3d3ea92960bf29c0fccae1c/" rel="bookmark">
			基础（一）C&#43;&#43;语言 第一章 C&#43;&#43;语言入门 1004：字符三角形
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 【题目描述】 给定一个字符，用它构造一个底边长5个字符，高3个字符的等腰字符三角形。
【输入】 输入只有一行，包含一个字符。
【输出】 该字符构成的等腰三角形，底边长5个字符，高3个字符。
【输入样例】 * 【输出样例】 * *** ***** #include &lt;iostream&gt; #include &lt;cstdio&gt; using namespace std; int main() { char x; scanf("%c",&amp;x);//输入给定1个字符，注意"&amp;"不能漏 printf(" %c\n",x); //输出1个字符，先输出2个空格 printf(" %c%c%c\n",x,x,x); printf("%c%c%c%c%c\n",x,x,x,x,x); return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df8f7944792f461e1d0efcf7a7bb0303/" rel="bookmark">
			KMP算法(字符串匹配)(AcWing)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		KMP算法常用于字符串匹配，在匹配介绍KMP算法之前，先介绍如何暴力地匹配字符串
对两个字符串，用两个指针依次比较，代码:
for (int i = 1; i &lt;= n; i ++ ) { bool flag = true; for (int j = 1; j &lt;= m; j ++ ) { if (s[i + j - 1] != p[j]) { flag=false; break; } } } 如果不匹配，相当于将短的那个字符串向右移动一位继续匹配，但这样依次比较的效率是非常低的
而KMP则是利用已经匹配好的字符串这个有效信息来减少重复的匹配
例如有图中，当长串和短串匹配成功了一段区间之后，在图中i和j+1的位置匹配失败了，按照常规思路我们是需要将短串向后移动一个位置继续重新开始匹配，但kmp就是利用好已经匹配好了的信息来减少匹配次数，就是令j=ne[j]，从ne[j]的位置开始匹配，因为在图中我们用黑线画的部分其实是等效的，所以这一部分我们是不需要去匹配的，那么如何求这个ne[j]数组呢
这里要引入一个概念，就是前缀和后缀：
现在思路我们知道了，那么如何用代码来实现呢？
思路：
代码:
for (int i = 2, j = 0; i &lt;= m; i++) { while (j &amp;&amp; str1[i] != str1[j + 1])j = ne[j]; if (str1[j + 1] == str1[i])j++; ne[i] = j; } 接下来来模拟一个样例：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/df8f7944792f461e1d0efcf7a7bb0303/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/22f3a8373371f614ec2d5b89038be90f/" rel="bookmark">
			LeetCode HOT 100 —— 621. 任务调度器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目 给你一个用字符数组 tasks 表示的 CPU
需要执行的任务列表。其中每个字母表示一种不同种类的任务。任务可以以任意顺序执行，并且每个任务都可以在 1 个单位时间内执行完。在任何一个单位时间，CPU 可以完成一个任务，或者处于待命状态。
然而，两个 相同种类 的任务之间必须有长度为整数 n 的冷却时间，因此至少有连续 n 个单位时间内 CPU在执行不同的任务，或者在待命状态。
你需要计算完成所有任务所需要的 最短时间 。
思路 构造题（脑筋急转弯）
先考虑最为简单的情况：假设只有一类任务，除了最后一个任务以外，其余任务在安排后均需要增加 n 个单位的冻结时间。
将任务数记为 m 个，其中前 m−1个任务均要消耗 n+1 的单位时间，最后一个任务仅消耗 1 个单位时间，即所需要的时间为 (n+1) * (m−1)+1。
当存在多个任务时，由于每一类任务都需要被完成，因此本质上最需要考虑的是将数量最大的任务安排掉，其他任务则是间插其中。
假设数量最大的任务数为 max，共有 k个任务数为 max 的任务种类。
实际上，当任务总数不超过 (n+1) * (max⁡−1)+k时，总能将其他任务插到空闲时间中去，不会引入额外的冻结时间（下左图）；而当任务数超过该值时，可以在将其横向添加每个 n+1 块的后面，同时不会引入额外的冻结时间（下右图）：
综上，所需要的最小时间为上述两种情况中的较大值即可：
Math.max⁡(task.length, (n+1) * (max−1) + k)
java代码如下：
class Solution { public int leastInterval(char[] tasks, int n) { int[] cnts = new int[26];//用数组充当哈希表的作用 for (char c : tasks) cnts[c - 'A']++;//将任务中的每个任务存在哈希表中，并统计出现的次数即，任务数 int max = 0, k = 0;//max—数量最多的任务数，k—数量为max的任务种类数，比如A.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/22f3a8373371f614ec2d5b89038be90f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38afe55d8a960f4b56004d18fa480553/" rel="bookmark">
			用C语言如何求四个数中的最大值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在 C 语言中，可以使用如下方法来求四个数中的最大值：
使用 if 语句： int max(int a, int b, int c, int d) { int m = a; if (b &gt; m) m = b; if (c &gt; m) m = c; if (d &gt; m) m = d; return m; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1eff116d129d5467cba33fc76c496c7/" rel="bookmark">
			AcWing算法学习之动态规划(基础)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背包问题 01背包问题 思路：
01背包问题，表示每个物品要么放，要么不放。从集合的角度分析DP问题，状态表示为：选择前i个物品，总体积小于等于j的选法的集合，属性f[i][j]表示价值的最大值。状态计算，因为每个状态可以表示为选择当前的物品，或者不选当前的物品，二者价值取最大值即可，即状态转移方程为:
f [ i ] [ j ] = m a x ( f [ i − 1 ] [ j ] , f [ i − 1 ] [ j − v i ] + w i ) , j ≥ v i f[i][j] = max(f[i - 1][j], f[i - 1][j - v_i]+w_i), j \ge v_i f[i][j]=max(f[i−1][j],f[i−1][j−vi​]+wi​),j≥vi​
朴素代码：
#include&lt;iostream&gt; using namespace std; const int N = 1005; int n, m, v[N], w[N], f[N][N]; int main() { cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; v[i] &gt;&gt; w[i]; for (int i = 1; i &lt;= n; i++) { for (int j = 0; j &lt;= m; j++) { f[i][j] = f[i - 1][j]; if (j &gt;= v[i]) f[i][j] = max(f[i][j], f[i - 1][j - v[i]] + w[i]); } } cout &lt;&lt; f[n][m]; return 0; } 一维优化
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e1eff116d129d5467cba33fc76c496c7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b972fc6157c9333eb6151fa7dfc3762f/" rel="bookmark">
			Java复习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		去年寒假学习过Java，忘记了很多内容，需要复习一下
Java 复习笔记 staticstatic 静态关键字静态成员变量静态成员方法注意事项 static的应用工具类静态代码块单例设计模式饿汉单例模式懒汉单例模式 继承继承特点子类构造器特点 访问权限包权限修饰符 final常量 abstract static static 静态关键字 静态成员变量 静态成员变量：属于类，加载一次，内存中只有一份，可被静态和非静态方法访问
使用方法：
类名.静态成员变量（推荐）对象.静态成员变量 静态成员方法 静态成员方法：属于类，建议用类名访问（也可以用对象访问）
访问方法：
类名.静态成员方法（推荐）对象.静态成员方法 注意事项 静态方法只能访问静态成员，不能访问实例成员实例方法可以访问静态成员，也能访问实例成员静态方法中不能出现this关键字 static的应用 工具类 如实现生成一个验证码，审核邮箱是否正确，获取系统时间等功能，在工具类中写好，开发时就可以直接调用
特点：
工具类内部都是静态方法，每个方法完成一个功能
建议：
对工具类的构造器进行私有化处理，因为工具类不需要创建对象
静态代码块 package com.study.static_code; public class Static_Demo1 { static { System.out.println("静态代码块执行"); } public static void main(String[] args){ } } 特点： 随着类的加载而加载，自动触发且只触发一次，执行顺序在main之前
作用： 可以用于初始化静态资源
单例设计模式 保证系统中，应用该模式的类永远只有一个实例，即只能创建一个对象。如：任务管理器对象
饿汉单例模式 在类加载时创建对象
public class SingleInstance { /* 定义一个静态变量存储一个对象即可 :属于类，与类一起加载一次 */ public static SingleInstance instance = new SingleInstance(); /* 单例必须私有构造器*/ private SingleInstance() {System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b972fc6157c9333eb6151fa7dfc3762f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7c8a26b44527e3117aa226df9939310/" rel="bookmark">
			Hive中的炸裂、窗口函数及示例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、炸裂函数 针对一行数据，输出多行数据，主要用于map，array这种的
根据一个例子来看：
friends 是一个array数组students 是一个mapaddress是一个struct 1）explode函数 explode函数以array类型数据输入，然后对数组中的数据进行迭代，返回多行结果，一行一个数组元素值。
作用于array：
arrayCol ：array字段的名称colName1 ：array字段的别名，随便起 -- 语法是这样 select explode(arrayCol) as colName1 from tablename 举例：
select explode(friends) from teacher 作用于map：
mapcol ：map字段名称key1：key的别名 随便起value1：value的别名 随便起 select explode(mapcol) as (key1,value1) from tablename; 举例：
select explode(students) from teacher 2）posexplode函数 相对于 返回多行结果，一行一个数组元素值。会返回元素在集合中的位置
区别：
posexplode只能用于array，而explode可以用于array，mapposexplode还会返回元素在集合中的位置 select posexplode(friends) from teacher 3）Lateral View 通常与UDTF配合使用，Lateral View可以将UDTF应用到源表的每行数据，将每行数据转换为一行或者多行，并将源表中每行的输出结果与该行连接起来，形成一个虚拟表。
那么，解决的问题到底是什么？
也不用Lateral View ，返回的字段也只能是炸裂的字段，不能进行其他任何操作
sql语法：
⚠️lateral view 一定要在udtf函数的前面⚠️虚拟表别名一定要加，不然会报错 select [col1,col2,col3……] from 表名 lateral view udtf(expression) 虚拟表别名 举例：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a7c8a26b44527e3117aa226df9939310/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/767e718b20ad93dcfd4783167d879253/" rel="bookmark">
			操作系统：文件管理和磁盘存储器管理 期末练习题（附有答案和解析）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文件系统的主要目的是（D）。
A.实现虚拟存储
B.提高外存的读写速度
C.用于存储系统文件
D.实现对文件的按名存取
解析：本题考察文件系统的主要目的。文件系统的主要目的是为了实现对文件的按名存取，也就是使得用户在对文件进行操作时能够根据其文件名进行相关操作。
磁盘与主机之间传递数据的单位是（C）。
A.柱面
B.磁道
C.数据块
D.记录
解析：本题考察磁盘与主机传递数据的单位。磁盘与主机之间进行数据交换的速率较快，因此传递数据的单位是数据块。
对顺序文件做读文件操作时，总是从（A）按顺序读出信息。
A.文件头部向后
B.文件中部开始
C.文件尾部开始
D.当前位置开始
解析：本题考察顺序文件的读写方式。对顺序文件进行读写时，都必须从文件头部向后进行读写。
用户归还文件的使用权，可以调用的文件操作是（C）。
A.建立
B.打开
C.关闭
D.删除
解析：本题考察文件的常用操作。关闭操作执行后，操作系统会从文件表中删除该文件对应的条目，此时用户对文件的使用权被归还。
面向用户的文件组织机构属于©。
A.虚拟结构
B.实际结构
C.逻辑结构
D.物理结构
解析：本题考察逻辑结构的定义。无论是操作系统的哪一部分，逻辑结构都是指用户所能感知到的结构类型，因此面向用户的文件组织机构也属于逻辑结构。
UNIX操作系统中，输入输出设备视为（D）。
A.普通文件
B.目录文件
C.索引文件
D.特殊文件
解析：本题考察UNIX操作系统中的文件系统。UNIX操作系统中，所有设备都被视为特殊的文件，因为UNIX操作系统控制和访问外部设备的方式和访问一个文件的方式都是相同的。
文件系统采用二级文件目录可以（D）。
A.缩短访问存储器的时间
B.实现文件共享
C.节省内存空间
D.解决不同用户间的文件命名冲突
解析：本题考察二级文件目录的作用。二级文件目录中，不同的用户可以使用相同的文件名，由此避免了不同用户间的文件命名冲突。
下列文件的物理结构中，不利于文件长度动态增长的文件物理结构是（A）。
A.顺序(连续)文件
B.链接文件
C.索引文件
D.系统文件
解析：本题考察连续分配文件的特点。连续分配文件支持顺序访问和直接访问，其实现简单且存取速度快，但是不利于文件长度的动态增长。
操作系统为保证未经文件拥有者授权，任何其他用户不能使用该文件所提供的解决方法是（A）。
A.文件保护
B.文件保密
C.文件转储
D.文件共享
解析：本题考察文件保护的概念。文件保护是指保护文件不被破坏或者未经核准的用户修改。
索引式(随机)文件组织的一个主要优点是(D)。
A.不需要链接指针
B.能实现物理块的动态分配
C.回收实现比较简单
D.用户存取方便
解析：本题考察索引分配文件物理结构的优点。索引分配的优点就是支持随机访问，而随机访问是用户存取最方便的访问方式。
由字符序列组成，文件内的信息不再划分结构，这是指（A）。
A.流式文件
B.记录式文件
C.顺序文件
D.有序文件
解析：本题考察流式文件的定义。流式文件就是无结构文件，文件内的信息为字符序列，不划分结构。
文件的存储方法依赖于（ C）。
A.文件的物理结构
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/767e718b20ad93dcfd4783167d879253/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59520ff134c997bc4fccf4a8309533a7/" rel="bookmark">
			tomcat漏洞之任意文件上传（CVE-2017-12615）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录
一、漏洞介绍
二、影响版本
三、原理分析
四、环境搭建
五、利用漏洞上传文件（四个方法）
1、在文件名后面添加斜杠 / 来进行绕过
2、在文件名后面添加 %20 来进行绕过
3、在文件名后面添加 ::$DATA来进行绕过 4、上传哥斯特生产的jsp
六、漏洞修护
声明 此篇文章仅用于研究与学习，请勿在未授权的情况下进行攻击。
一、漏洞介绍 2017年9月19日，Apache Tomcat官方确认并修复了两个高危漏洞，漏洞CVE编号:CVE-2017-12615和CVE-2017-12616,其中远程代码执行漏洞（CVE-2017-12615）。在一定条件下，攻击者可以利用这两个漏洞，通过上传的 JSP 文件 ，可在用户服务器上执行任意代码，从而导致数据泄露或获取服务器权限，存在高安全风险。
二、影响版本 Apache Tomcat 7.0.0 - 7.0.81
三、原理分析 readonly=true表明所注解的方法或类只是读取数据。
readpnly=false表明所注解的方法或类是增加，删除，修改数据。
其中readpnly=false是造成这次漏洞的根本原因。
具体的原理分析可以去B站上搜一下。
四、环境搭建 依次在Ubuntu的终端中输入以下代码进行环境搭建：（我的是Ubuntu，在你的虚拟机输入以下命令即可）
cd / ls cd vulhub cd tomcat cd CVE-2017-12615 docker-compose up -d 做完实验后记得把环境移除
docker-compose down 如下图出现绿色的done，表示环境搭建成功
搭建完成后用自己的虚拟机ip地址加上端口号在Windows操作系统上进行访问tomcat，这里端口号可以在终端输入docker ps进行查看。默认是8080。
五、利用漏洞上传文件（四个方法） 1、在文件名后面添加斜杠 / 来进行绕过 在tomcat页面用bp进行抓包，然后把包放到Repeater里面，在Repeater中把GET改成PUT再添加文件和内容即可。
此时发现我们已经成功上传。
2、在文件名后面添加 %20 来进行绕过 3、在文件名后面添加 ::$DATA来进行绕过 4、上传哥斯特生产的jsp 需要利用哥斯拉木马。
六、漏洞修护 配置readonly值为True或注释参数，禁止使用PUT方法并重启tomcat。 注意：如果禁用PUT方法，对于依赖PUT方法的应用，可能导致业务失效。当然也可以在前端（例如WAF）上阻止PUT和DELETE请求。只能防止攻击者上传JSP。 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/115/">«</a>
	<span class="pagination__item pagination__item--current">116/321</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/117/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>