<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dad86d681c5bcedd347eff9f195f1adc/" rel="bookmark">
			Spring Boot基于注解的Redis缓存实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、添加Spring Data Redis依赖启动器 &lt;!--Spring Data Redis 依赖启动器--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; 二、Redis服务连接配置 #MySQL数据库连接配置 spring.datasource.url=jdbc:mysql://192.168.152.120:3306/springboottest?serverTimezone=UTC spring.datasource.username=root spring.datasource.password=1 #显示使用JPA进行数据库查询的SQL语句 spring.jpa.show-sql=true #redis相关配置 spring.redis.host=192.168.152.120 spring.redis.port=6379 spring.redis.password=1 三、实体类 四、repository package com.uos.cache.repository; import com.uos.cache.domain.Comment; import org.springframework.data.jpa.repository.JpaRepository; import org.springframework.data.jpa.repository.Modifying; import org.springframework.data.jpa.repository.Query; import javax.transaction.Transactional; public interface CommentRepository extends JpaRepository&lt;Comment,Integer&gt; { // 根据评论id修改评论作者 @Transactional @Modifying @Query("UPDATE t_comment c SET c.author= ?1 WHERE c.id = ?2") public int updateComment(String author,Integer id); } 五、service package com.uos.cache.service; import com.uos.cache.domain.Comment; import com.uos.cache.repository.CommentRepository; import org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dad86d681c5bcedd347eff9f195f1adc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6fa7eca994a71be668ca8a61c03e984d/" rel="bookmark">
			用浏览器访问 www.baidu.com 的过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1. 先要解析出 baidu.com 对应的 ip 地址 2. 要先使用 arp 获取默认网关的 mac 地址 3. 组织数据发送给默认网关 (ip 还是 dns 服务器的 ip ，但是 mac 地址是默认网关的 mac 地址 ) 4. 默认网关拥有转发数据的能力，把数据转发给路由器 5. 路由器根据自己的路由协议，来选择一个合适的较快的路径转发数据给目的网关 6. 目的网关 (dns 服务器所在的网关 ) ，把数据转发给 dns 服务器 7. dns 服务器查询解析出 baidu.com 对应的 ip 地址，并原路返回请求这个域名的 client 8. 得到了 baidu.com 对应的 ip 地址之后，会发送 tcp 的 3 次握手，进行连接 9. 使用 http 协议发送请求数据给 web 服务器 10. web 服务器收到数据请求之后，通过查询自己的服务器得到相应的结果，原路返回给浏览器。 11. 浏览器接收到数据之后通过浏览器自己的渲染功能来显示这个网页。 12. 浏览器关闭 tcp 连接，即 4 次挥手结束，完成整个访问过程 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00b9c8a57d1bed9ecd178f2f493a753e/" rel="bookmark">
			将eclipse配置成可迁移，即直接复制就可以使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有时候我们的现用eclipse装了很多插件什么的不想重新安装，而又必须进行迁移、或是将eclipse拷贝给他人使用就需要进行以下操作。
1、打开你的eclipse.ini，看你的.p2目录的位置
2、将.p2目录移动到你的eclipse安装目录下，如：
3、修改几个文件的路径
a、eclipse.ini 将--launcher.library下的.p2路径设置为：.p2/pool/plugins/xxxxx
b、configuration/config.ini ，将reference\:file的reference\:去掉并且将所有带file的路径改为如下
c、configuration\org.eclipse.equinox.simpleconfigurator\bundles.info 将所有文件路径改为如下，全部替换
完成，现在的eclipse就是独立的了，直接拷贝就可以使用，当然该配置的jdk什么的肯定是要配置的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f73e50528e1f3db20e6e8e41e2fede3/" rel="bookmark">
			MySQL分区
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		分区和手动分表对比
mysql的分区操作还比较简单，好处是也不用自己动手建表进行分区，和水平分表有点像
分表分区手动分表 分区多张数据表一张数据表重复数据的风险没有数据重复的风险写入多张表写入一张表没有统一的约束限制强制的约束限制 1、mysql分区简介？ 表分区：分区是根据一定的规则，数据库把一个表分解成多个更小的、更容易管理的部分。就访问数据库应用而言，逻辑上就只有一个表或者一个索引，但实际上这个表可能有N个物理分区对象组成，每个分区都是一个独立的对象，可以独立处理，可以作为表的一部分进行处理。
分区不影响程序员编程：分区对应用来说是完全透明的，不影响应用的业务逻辑。
2、mysql分区注意？ 主键/唯一键：无论哪种分区，要么你分区表上没有主键/唯一键，要么分区表的主键/唯一键都必须包含分区键，也就是说不能使用主键/唯一键字段之外的其它字段分区。
3、分区能做什么 逻辑数据分割提高单一的写和读应用速度提高分区范围读查询的速度分割数据能够有多个不同的物理文件路径高效的保存历史数据一个表上的约束检查不同的主从服务器分区策略，例如master按Hash分区，slave按range分区 MySQL可以对索引进行分区么？
可以：MySQL分区即可以对数据进行分区，也可以对索引进行分区。
4 分区的限制(截止5.1.44版) • 只能对数据表的整型列进行分区，或者数据列可以通过分区函数转化成整型列
• 最大分区数目不能超过1024
• 如果含有唯一索引或者主键，则分区列必须包含在所有的唯一索引或者主键在内
• 不支持外键
• 不支持全文索引（fulltext）
按日期进行分区很非常适合，因为很多日期函数可以用。但是对于字符串来说合适的分区函数不太多 5，什么时候使用分区
• 海量数据表
• 历史表快速的查询，可以采用ARCHIVE+PARTITION的方式。
• 数据表索引大于服务器有效内存
• 对于大表，特别是索引远远大于服务器有效内存时，可以不用索引，此时分区效率会更有效。
6、mysql分区类型？ range分区（常用）：基于一个给定的连续区间范围(区间要求连续并且不能重叠)，把数据分配到不同的分区
list分区：类似于range分区，区别在于list分区是居于枚举出的值列表分区，range是基于给定的连续区间范围分区
hash分区：基于给定的分区个数，把数据分配到不同的分区
key分区：类似于hash分区
7、mysql分区优势？ 更多数据：和单个磁盘或者文件系统分区相比，可以存储更多数据
优化查询：在where子句中包含分区条件时，可以只扫描必要的一个或者多个分区来提高查询效率；同时在涉及sum()和count()这类聚合函数的查询时，可以容易的在每个分区上并行处理，最终只需要汇总所有分区得到的结果
快速删除：对于已经过期或者不需要保存的数据，可以通过删除与这些数据有关的分区来快速删除数据
更大吞吐量：跨多个磁盘来分散数据查询，以获得更大的查询吞吐量
8、分区和水平分表的相似和区别？ 大表的数据分割到多张小表：分区和水平分表功能类似，将一个大表的数据分割到多张小表中去，由于查询不需要全表扫描了，只需要扫描某些分区，所以分区能提高查询速度。
水平分表：用户设定：需要用户预先手动显式创建出多张分表(如tbl_user0, tbl_user1, tbl_user2)，在物理上实实在在的创建多张表，通过客户端代理(Sharding-JDBC等)或者中间件代理(Mycat等)来实现分表逻辑。
分区：mysql默认帮你做：是MySQL的一个插件Plugin功能，将一张大表的数据在数据库底层分成多个分区文件(如tbl_user#P#p0.ibd, tbl_user#P#p1.ibd, tbl_user#P#p2.ibd)，和水平分表不同的是分区不需要显式的创建“分表”
分区：mysql默认帮你做，是MySQL的一个插件Plugin功能，将一张大表的数据在数据库底层分成多个分区文件(如tbl_user#P#p0.ibd, tbl_user#P#p1.ibd, tbl_user#P#p2.ibd)，和水平分表不同的是分区不需要显式的创建“分表”,数据库会自动创建分区文件的，用户看到的只是一张普通的表，其实是对应的是多个分区，这个是对用户是屏蔽的、透明的，在使用上和使用一张表完全一样，不需要借助任何功能来实现。分区是一种逻辑上的水平分表，在物理层面还是一张表。
7、mysql什么命令查看mysql的data存放目录？ show variables like ‘%datadir%’：通过show variables like ‘%datadir%’;命令查看mysql的data存放目录，进入所在的数据库目录(如test)，不同的引擎数据库文件格式不同
总结：show variables like "" 的功能好像啥都可以做，也很容易理解
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2f73e50528e1f3db20e6e8e41e2fede3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d327ee1398ae722a0db20d1d12d11a4c/" rel="bookmark">
			武汉部分IT企业
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		武汉IT企业 斗鱼
AcFun
车来了
有道金融
跟谁学
木仓科技
极意网络
奇米网络
斑马快跑
简寻
Deepin
航班管家
海豚浏览器
华为
今日头条（分部）
科大讯飞全国研发总部
京东（武汉分公司）
Thoughtworks
浦发银行研发中心
小红书
石墨文档
绿盟
奇虎360
小米
WPS
武汉IT部分企业
作者：筱茜
链接：https://www.nowcoder.com/discuss/86933
来源：牛客网
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2fcf48bd0a80047be9904442bee6f86d/" rel="bookmark">
			django中间件处理视图返回的数据之后，数据未返回修改之后的response
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一种方法：
Response已在中间件阶段进行渲染，因此您不仅可以更改response.data，还需要重新渲染或直接更改渲染的内容。
class RequestLogMiddleWare(object): def __init__(self, get_response): self.get_response = get_response def __call__(self, request): response = self.get_response(request) if isinstance(response, Response): response.data['detail'] = 'I have been edited' # you need to change private attribute `_is_render` # to call render second time response._is_rendered = False response.render() return response 第二种方法：
第二种方法是直接更改内容，但是在这种情况下，内置的REST Framework浏览器API将无法正常工作，因为模板无法正确呈现。
import json class RequestLogMiddleWare(object): def __init__(self, get_response): self.get_response = get_response def __call__(self, request): response = self.get_response(request) if isinstance(response, Response): response.data['detail'] = 'I have been edited' response.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2fcf48bd0a80047be9904442bee6f86d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e67a890c4c320b1efe637e83062f1021/" rel="bookmark">
			在线网站 压力测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.https://gtmetrix.com 根据测试情况给出建议
2.在线AB测试平台。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8037111ddb29c345d6fa83943961e5d4/" rel="bookmark">
			龙芯平台内核编译
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		内核的编译 主机环境：gentoo based on Loongson3A3000
GCC版本：gcc-9.2.0
源码包：loongson-linux
编译步骤：
1.将config文件放到loongson-inux目录下，并改名为.config
2.配置内核make menuconfig进入选项菜单
3.编译安装：
make -j4 安装模块 make modules_install 安装内核 make install 此时会在/boot文件夹下生成vmlinuz文件，这就是我们需要的内核镜像文件 4.生成initramfs：
genkernel --install --ramdisk-modules --kerneldir=/home/dslab/loongson-linux/ --kernel-config=/home/dslab/loongson-linux/.config initramfs -kerneldir是指定内核源码的位置，-kernel-config是指定内核配置文件.config的位置，该initramfs生成后也会被默认放在/boot文件夹下。 5.修改启动项，引导系统启动：
在编译内核和initramfs后，需要配置boot.cfg文件，使系统引导新编译的内核和initramfs启动。
boot.cfg文件的主要内容和设置如下：
timeout 5 default 0 showmenu 1 title 'Gentoo GNU/Linux for Loongson3A3000' kernel (wd0,0)/vmlinuz-4.19.80-stand-logo initrd (wd0,0)/initramfs-mips-4.19.80-chaos args root=/dev/sda2 ro quiet loglevel=0 LANG=zh_CN.UTF-8 kernel 选项后面指定内核镜像存放的位置，（wd0,0）指的是sda1 ， 如果是sdb2，则是（wd1,1）。
initrd 选项后面指定initramfs存放的位置。
args 后面是系统启动参数设置 ， root=/dev/sda2指定的是根文件系统的位置，ro表示以只读的方式挂载根文件系统，quiet表示不显示内核打印信息，loglevel设置内核信息的打印级别，只有小于console的level，信息才会被打印到console上，LANG设置编码格式和语言。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e7e19b066b14efd9be30247b7bf97e4/" rel="bookmark">
			mybatis-plus的配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 mybatis-plus: mapper-locations: classpath:/mapper/*Mapper.xml #实体扫描，多个package用逗号或者分号分隔 typeAliasesPackage: com.baomidou.springboot.db.entity typeEnumsPackage: com.baomidou.springboot.db.entity.enums global-config: #刷新mapper 调试神器 db-config: #主键类型 0:"数据库ID自增", 1:"用户输入ID",2:"全局唯一ID (数字类型唯一ID)", 3:"全局唯一ID UUID"; id-type: id_worker #字段策略 0:"忽略判断",1:"非 NULL 判断"),2:"非空判断" field-strategy: not_empty #驼峰下划线转换 column-underline: true #数据库大写下划线转换 #capital-mode: true #逻辑删除配置 logic-delete-value: Y logic-not-delete-value: N db-type: mysql refresh: true sql-injector: com.baomidou.mybatisplus.extension.injector.LogicSqlInjector #自定义填充策略接口实现 #meta-object-handler: com.baomidou.springboot.xxx #自定义SQL注入器 #sql-injector: com.baomidou.springboot.xxx configuration: map-underscore-to-camel-case: true cache-enabled: false 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5c96056a5d89d709f179127d3c70fb3/" rel="bookmark">
			【Hadoop】（七）Yarn 详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、Yarn概述二、Yarn的重要概念三、Yarn基本架构1）ResourceManager（RM）2）ApplicationMaster（AM）3）NodeManager（NM）4）Container 四、Yarn工作机制 一、Yarn概述 Yarn是一个资源调度平台，负责为运算程序提供服务器运算资源，相当于一个分布式的操作系统平台，而mapreduce等运算程序则相当于运行于操作系统之上的应用程序。
二、Yarn的重要概念 1）Yarn并不清楚用户提交的程序的运行机制
2）Yarn只提供运算资源的调度（用户程序向Yarn申请资源，Yarn就负责分配资源）
3）Yarn中的主管角色叫ResourceManager
4）Yarn中具体提供运算资源的角色叫NodeManager
5）这样一来，Yarn其实就与运行的用户程序完全解耦，就意味着Yarn上可以运行各种类型的分布式运算程序（mapreduce只是其中的一种），比如mapreduce、storm程序，spark程序……
6）所以，spark、storm等运算框架都可以整合在Yarn上运行，只要他们各自的框架中有符合Yarn规范的资源请求机制即可。
7）Yarn就成为一个通用的资源调度平台，从此，企业中以前存在的各种运算集群都可以整合在一个物理集群上，提高资源利用率，方便数据共享。
三、Yarn基本架构 从YARN的架构图来看，它主要由ResourceManager、NodeManager、ApplicationMaster和Container等以下几个组件构成。
1）ResourceManager（RM） YARN分层结构的本质是ResourceManager。这个实体控制整个集群并管理应用程序向基础计算资源的分配。ResourceManager将各个资源部分（计算、内存、带宽等）精心安排给基础NodeManager（YARN的每节点代理）。ResourceManager还与ApplicationMaster一起分配资源，与NodeManager一起启动和监视它们的基础应用程序。在此上下文中，ApplicationMaster承担了以前的TaskTracker的一些角色，ResourceManager承担了JobTracker 的角色。
总的来说，RM有以下作用
（1）处理客户端请求
（2）启动或监控ApplicationMaster
（3）监控NodeManager
（4）资源的分配与调度
2）ApplicationMaster（AM） ApplicationMaster管理在YARN内运行的每个应用程序实例。ApplicationMaster负责协调来自ResourceManager的资源，并通过NodeManager监视容器的执行和资源使用（CPU、内存等的资源分配）。请注意，尽管目前的资源更加传统（CPU 核心、内存），但未来会带来基于手头任务的新资源类型（比如图形处理单元或专用处理设备）。从YARN角度讲，ApplicationMaster是用户代码，因此存在潜在的安全问题。YARN假设ApplicationMaster存在错误或者甚至是恶意的，因此将它们当作无特权的代码对待。
总的来说,AM有以下作用
（1）负责数据的切分
（2）为应用程序申请资源并分配给内部的任务
（3）任务的监控与容错
3）NodeManager（NM） NodeManager管理YARN集群中的每个节点。NodeManager提供针对集群中每个节点的服务，从监督对一个容器的终生管理到监视资源和跟踪节点健康。MRv1通过插槽管理Map 和Reduce任务的执行，而NodeManager管理抽象容器，这些容器代表着可供一个特定应用程序使用的针对每个节点的资源。
总的来说，NM有以下作用
（1）管理单个节点上的资源
（2）处理来自ResourceManager的命令
（3）处理来自ApplicationMaster的命令
4）Container Container是YARN中的资源抽象，它封装了某个节点上的多维度资源，如内存、CPU、磁盘、网络等，当AM向RM申请资源时，RM为AM返回的资源便是用Container表示的。YARN会为每个任务分配一个Container，且该任务只能使用该Container中描述的资源。
总的来说，Container有以下作用
对任务运行环境进行抽象，封装CPU、内存等多维度的资源以及环境变量、启动命令等任务运行相关的信息
要使用一个YARN集群，首先需要一个包含应用程序的客户的请求。ResourceManager协商一个容器的必要资源，启动一个ApplicationMaster来表示已提交的应用程序。通过使用一个资源请求协议，ApplicationMaster协商每个节点上供应用程序使用的资源容器。执行应用程序时，ApplicationMaster监视容器直到完成。当应用程序完成时，ApplicationMaster从 ResourceManager注销其容器，执行周期就完成了。
通过上面的讲解，应该明确的一点是，旧的Hadoop架构受到了JobTracker的高度约束，JobTracker负责整个集群的资源管理和作业调度。新的YARN架构打破了这种模型，允许一个新ResourceManager管理跨应用程序的资源使用，ApplicationMaster负责管理作业的执行。这一更改消除了一处瓶颈，还改善了将Hadoop集群扩展到比以前大得多的配置的能力。此外，不同于传统的MapReduce，YARN允许使用MPI( Message Passing Interface) 等标准通信模式，同时执行各种不同的编程模型，包括图形处理、迭代式处理、机器学习和一般集群计算。
四、Yarn工作机制 1）Yarn运行机制
2）工作机制详解
（0）Mr程序提交到客户端所在的节点
（1）Yarnrunner向Resourcemanager申请一个Application。
（2）rm将该应用程序的资源路径返回给yarnrunner
（3）该程序将运行所需资源提交到HDFS上
（4）程序资源提交完毕后，申请运行mrAppMaster
（5）RM将用户的请求初始化成一个task
（6）其中一个NodeManager领取到task任务。
（7）该NodeManager创建容器Container，并产生MRAppmaster
（8）Container从HDFS上拷贝资源到本地
（9）MRAppmaster向RM 申请运行maptask容器
（10）RM将运行maptask任务分配给另外两个NodeManager，另两个NodeManager分别领取任务并创建容器。
（11）MR向两个接收到任务的NodeManager发送程序启动脚本，这两个NodeManager分别启动maptask，maptask对数据分区排序。
（12）MRAppmaster向RM申请2个容器，运行reduce task。
（13）reduce task向maptask获取相应分区的数据。
（14）程序运行完毕后，MR会向RM注销自己。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bafa6d49d13a32d54abfa9d12da48782/" rel="bookmark">
			web服务高级使用     Samba共享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先将防火墙改为trusted模式 前提案例:
为虚拟机 server 配置以下虚拟Web主机
实现三个网站的部署实现客户端访问server0.example.com网页内容为 卖女孩的小火柴实现客户端访问www0.example.com网页内容为 奔跑吧骆驼实现客户端访问webapp0.example.com网页内容为 20里春风不如你 服务端: [root@server0 ~]# yum -y install httpd root@server0 ~]# vim /etc/httpd/conf.d/zz.conf &lt;virtualhost *:80&gt; servername server0.example.com documentroot /var/www/abc01 &lt;/virtualhost&gt; &lt;virtualhost *:80&gt; servername www0.example.com documentroot /var/www/abc02 &lt;/virtualhost&gt; &lt;virtualhost *:80&gt; servername webapp0.example.com documentroot /var/www/abc03 &lt;/virtualhost&gt; [root@server0 ~]# cd /var/www [root@server0 www]# mkdir abc01 abc02 abc03 [root@server0 www]# echo ' &lt; h1 &gt;卖女孩的小火柴 ' &gt; abc01/index.html [root@server0 www]# echo '&lt; h1&gt;奔跑吧骆驼' &gt; abc02/index.html [root@server0 www]# echo '&lt; h1&gt;20里春风不如你' &gt; abc03/index.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bafa6d49d13a32d54abfa9d12da48782/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a7fa5db1a9b4d074891922de612c4f5/" rel="bookmark">
			Python	[ pip ] 安装requests模块
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python [ pip ] 安装requests模块 说明更改pip源并更新接下来自己看吧... 说明 网上乱七八糟的教程已经过期了...看着很心累,最近发现更好的方式来安装pip模块 默认你已经安装Python 3 + 版本了默认你会pip基础命令 pip --version	# 查看pip版本和安装位置 pip show pip	# 查看pip详细信息 pip list	#列出已经安装包 pip list -o	#查看可升级的包 pip install -U pip	# 升级pip pip install 包名	# 安装包 pip install --upgrade 包名	#升级包 pip uninstall 包名	#卸载包 pip search 包名	#搜索包 更改pip源并更新 pip有各种官方的镜像源,网上感觉最好的就是[清华大学开源软件镜像站](https://mirrors.tuna.tsinghua.edu.cn/help/pypi/),五分钟同步一次,速度挺快的
接下来自己看吧… # 临时使用清华源 pip install -i https://pypi.tuna.tsinghua.edu.cn/simple some-package # 使用之前请更新一波,写到这里方便复制 pip install -U pip	# 网络差可以临时使用清华源更新pip pip install -i https://pypi.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5a7fa5db1a9b4d074891922de612c4f5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96d0178014afce0f48d0c1dc2d993ff3/" rel="bookmark">
			轻松搞定iOS自动化环境搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		step 1 安装JDK 查找JDK安装路径，分别是mac已安装的JDK目录和mac默认使用的JDK目录
配置环境变量
vi .bash_profile
读取并执行文件中的命令
source .bash_profile
输入 java -version 显示java版本，说明安装配置完成
step 2 安装homebrew 进入homebrew官网 brew.sh ，获取最新的安装命令，直接输入命令行安装
安装完成输入brew -v 验证是否安装成功并查看版本
step 3 安装Xcode、Xcode commandline tools和iOS模拟器 Xcode在Appstore 下载，要求版本支持当前 mac的osx版本
输入xcode-select --install 安装Command Line Tools
step 4 安装ideviceinstaller 输入 brew install ideviceinstaller
安装完成后输入ideviceinstaller -h 出现如下，表示安装成功
step 5 安装 node brew install node
node -v 查看版本
step 6 安装 appium客户端 step 7 用npm安装wd npm install wd
step 8 安装依赖库 brew install libimobiledevice --HEAD
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/96d0178014afce0f48d0c1dc2d993ff3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/daf60e21054346d25be12fa733e44b9d/" rel="bookmark">
			记录踩过的坑-Android Studio
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
远程真机调试
设置SDK路径
Minimum supported Gradle version is 5.1.1. Current version is 4.8.
Call requires API level 3 (current min is 1)
NDK编译报错SIMPLE: Error configuring
Could not download tensorflow-android.aar
Android Error:Execution failed for task':app:compileDebugJavaWithJavac'
Could not find AndroidManifest.xml file using generation folder
Plugin with id 'com.android.application' not found
远程真机调试 File-Settings-Plugins，在Marketplace里搜索wifi，下载“WIFI ADB ULTIMATE”。
注意，有很多种类似插件，但其他都没试过。
安装，重启Android Studio，右边可以看到这个插件的图标。
第一次要用usb连接手机，连上之后拔掉线，后面就可以远程连接了。
注意手机需要和Android Studio电脑在同一wifi下。
设置SDK路径 File-Other Settings-Default Project Structure
Minimum supported Gradle version is 5.1.1. Current version is 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/daf60e21054346d25be12fa733e44b9d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb608979b962252add2c81397a79ae28/" rel="bookmark">
			MongoDB 未授权访问漏洞复现学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0x00 漏洞简介 开启MongoDB服务时不添加任何参数时,默认是没有权限验证的,登录的用户可以通过默认端口无需密码对数据库任意操作（增、删、改、查高危动作）而且可以远程访问数据库。
造成未授权访问的根本原因就在于启动 Mongodb 的时候未设置 --auth 也很少会有人会给数据库添加上账号密码（默认空口令），使用默认空口令这将导致恶意攻击者无需进行账号认证就可以登陆到数据服务器。
0x01 环境搭建 测试机：Kali
靶机：Ubuntu16.04
使用docker搭建环境
1、从镜像仓库中拉取或者更新指定镜像
docker pull mongo 2、列出本地主机上的mongo镜像
docker images mongo 3、创建一个新的容器并运行一个命令
docker run -d -p 27017:27017 -name mongodb mongo 显示所有的容器，包括未运行的
docker ps -a 0x02 漏洞证明 MongoDB默认端口一般都为27017，当配置成无验证时，就会存在未授权访问。
先查看DockerIP
打开msf使用如下命令：
use auxiliary/scanner/mongodb/mongodb_login set rhosts 172.17.0.1 set threads 10 exploit 555 为啥连不上
端口filtered…
找到了一篇博客解决
https://blog.csdn.net/Homewm/article/details/88672554
$docker inspect mongodb | grep IPAddress 打扰了 原来dockerip是172.17.0.2
将docker中的27017映射到靶机的27917端口
iptables -t nat -A DOCKER -p tcp --dport 27917 -j DNAT --to-destination 172.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eb608979b962252add2c81397a79ae28/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e38659a527d564c92f7869926ca23b4/" rel="bookmark">
			生成树协议（STP）及链路聚合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 STP介绍STP 算法选择根网桥（Root Bridge）选择根端口（Root Ports）选择指端口（Designated Ports） BPDU（桥协议数据单元）PVST（按VLAN生成树）链路聚合 STP介绍 STP（Spanning Tree Protocol）是生成树协议的英文缩写，可应用于计算机网络中树形拓扑结构建立。
应用场景：网络中的环路，当网络形成一个环路时自动启动。
主要作用：逻辑上断开环路防止广播风暴；备份线路（当其中一条线路出现故障，断开的接口被激活重新启用，从而恢复通信）
工作原理：利用STP算法，计算出阻塞端口，断开端口从而形成无环结构。
STP 算法 选择根网桥（Root Bridge） （1）如何选择根网桥？
根据网桥ID（BID）选择根网桥，谁的优先级小，谁就是根桥。如果优先级相同，谁的MAC地址小谁就是根桥。BID=优先级+mac地址
（2）什么是网桥ID（BID）？
每个网络只能有一个根桥，根桥具有最低的桥ID，根桥上的所有端口都是指定端口，选择根网桥的目的是为了给将生成的树形结构确定一个树根。（交换机默认优先级为：32768。设备中加上了vlan的值。如vlan10就变成32778）
（3）选择根网桥举例
选择根端口（Root Ports） （1）如何选择根端口？
在非根网桥上选择一个到根网桥最近的端口作为根端口
选择根端口的依据是：
根路径成本（cost值）【从端口出发到根桥】最低
直连网桥的网桥ID最小
直连网桥的端口ID最小
（2）什么是cost值？
根路径成本是网桥到根网桥的路径上所有链路的成本之和。
根路径成本表
（3）什么是端口ID
即端口优先级（默认128）+端口编号
（4）选择根端口举例
选择指端口（Designated Ports） 选择指定端口的依据是：
在每个网段上，选择1个指定端口，根桥上的端口全是指定端口。
非根桥上的指定端口：
根路径成本【从非根桥到根桥】最低
端口所在的网桥的ID值较小
直连网桥的端口ID值较小
BPDU（桥协议数据单元） 交换机就是使用BPDU来交换STP信息，从而计算出最优化路径成本。BPDU（Bridge Protocol Data Unit）使用组播发送BPDU，组播地址为：01-80-c2-00-00-00。
BPDU分为2种类型：
配置BPDU － 用于生成树计算
拓朴变更通告（TCN）BPDU － 用于通告网络拓朴的变化
生成树端口状态
PVST（按VLAN生成树） pvst是Cisco私有的，为每个VLAN构造一棵生成树
是用来配置网络中比较稳定的交换机为根网桥，利用PVST实现网络的负载分担
配置命令
启用生成树：Switch(config)#spanning-tree vlan vlan-list 设置根网桥：Switch(config)#spanning-tree vlan vlan-list root primary | secondary -设置为primary后，优先级变成24576 -设置为secondary后， 优先级变成28672 修改网桥的优先级：Switch(config)#spanning-tree vlan vlan-list priority Bridge-priority -优先级的值为4096的倍数 修改端口成本：Switch(config-if)#spanning-tree vlan vlan-list cost cost 修改端口优先级：Switch(config-if)#spanning-tree vlan vlan-list port-priority priority 配置上行速链路：Switch(config)#spanning-tree uplinkfast 配置端口速链路：Switch(config-if)#spanning-tree portfast 查看生成树的配置：Switch#show spanning-tree 查看某个VLAN的生成树详细信息：Switch#show spanning-tree vlan vlan-id detail 链路聚合 链路聚合又称为端口聚合，端口捆绑，英文名porttrunking。是一种聚合多个物理接口 ( that ) 创建一个逻辑接口。你可以捆扎( bundle ) 八个单独的活动链接到一个信道端口，以提供更高的带宽和冗余。端口通道也负载平衡这些物理接口上的通信量。只要端口通道中的至少一个物理接口可操作，端口通道就可以保持运行。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5e38659a527d564c92f7869926ca23b4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8aacd5f0d098ff16a240674893246805/" rel="bookmark">
			大疆MANIFOLD 2（Jetson TX2）配置总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、接线 接入鼠标、键盘、显示器、按键、电源、天线
二、安装nano sudo apt-get install -y nano
三、更换arm64国内软件源 https://blog.csdn.net/qlulibin/article/details/80271096
四、配置远程桌面 https://blog.csdn.net/talender/article/details/88543889
更改桌面共享
安装X11VNC
改分辨率：
xrandr --fb 1500x800
五、安装配置Qt Creator 安装：
sudo apt install qtcreator
配置：
打开qt creator,依次选择Tools-&gt;Options-&gt;Build &amp; Run-&gt;Compilers
点击Add按钮选择GCC。 在Compiler path:’中选择加入路径/usr/bin/gcc。并依次设置ABI的选项如下图所示:（custom – arm – linux – generic – elf – 64 bit）
然后点击Apply按钮保存，然后点击Kits
继续点击Add按钮，按下图填写Name，Qt version, CMake Tool等信息，填好如下图所示。
点击Apply,然后点击OK，设置完毕。
六、安装Opencv3.4.4 大疆官方：
https://djisdksupport.zendesk.com/hc/zh-cn/articles/360024445774-%E5%A6%82%E4%BD%95%E5%9C%A8manifold2%E4%B8%8B%E5%AE%89%E8%A3%85opencv%E4%BB%A5%E5%8F%8Aopencv-contrib
opencv官方：
https://docs.opencv.org/3.4.4/d6/d15/tutorial_building_tegra_cuda.html
cmake（等很久）:
https://blog.csdn.net/QLULIBIN/article/details/84072356
#!/bin/bash cmake \ -D CMAKE_BUILD_TYPE=Release \ -D CMAKE_INSTALL_PREFIX=/usr \ -D BUILD_PNG=OFF \ -D BUILD_TIFF=OFF \ -D BUILD_TBB=OFF \ -D BUILD_JPEG=OFF \ -D BUILD_JASPER=OFF \ -D BUILD_ZLIB=OFF \ -D BUILD_EXAMPLES=ON \ -D BUILD_opencv_java=OFF \ -D BUILD_opencv_python2=ON \ -D BUILD_opencv_python3=OFF \ -D ENABLE_PRECOMPILED_HEADERS=OFF \ -D WITH_OPENCL=OFF \ -D WITH_OPENMP=OFF \ -D WITH_FFMPEG=ON \ -D WITH_GSTREAMER=ON \ -D WITH_GSTREAMER_0_10=OFF \ -D WITH_CUDA=ON \ -D WITH_GTK=ON \ -D WITH_VTK=OFF \ -D WITH_TBB=ON \ -D WITH_1394=OFF \ -D WITH_OPENEXR=OFF \ -D CUDA_TOOLKIT_ROOT_DIR=/usr/local/cuda-9.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8aacd5f0d098ff16a240674893246805/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51bd967e51c3b3bfcbcca84d3c9c95fc/" rel="bookmark">
			Class和普通构造函数的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JS构造函数 //JS构造函数 function MathHandle(x,y){ this.x = x; this.y = y; } MathHandle.prototype.add = function(){ return this.x + this.y; } let test = new MathHandle(1,2); console.log(test.add()); console.log(typeof MathHandle); console.log(MathHandle.prototype.constructor === MathHandle); console.log(test.__proto__ === MathHandle.prototype); // 3 // function // true // true Class基本语法 //Class语法 class MathHandle { //构造器 constructor(x, y) { this.x = x; this.y = y; } add() { return this.x + this.y; } } let test2 = new MathHandle(3, 7); console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/51bd967e51c3b3bfcbcca84d3c9c95fc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d46629e5fd7bc18819c6ad837b9e852/" rel="bookmark">
			nvm简介及使用，删除node
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、简介 nvm是一个node版本管理工具
2、下载 下载nvm地址
下载nvm-setup.zip =&gt; 安装在C盘
3、配置环境变量 这一步安装最新版自动就配置了，你只需要电脑的360之类设备别阻止就行
4、使用 查看版本，出来这个证明安装成功
nvm -v 5、安装nodeJS 你需要什么版本，就指定什么版本号（PS：这样下载可能有点慢，挂机/耐心等待）
nvm install 版本 6、使用新安装的node nvm use 版本 7、常用命令 nvm install stable //安装最新版 node nvm install [node版本号] //安装指定版本的node nvm ls // 查看已安装版本方便切换 nvm use [node版本号] //切换到指定版本的node nvm alias default [node版本号] //设置默认版本 8、删除已安装node nvm uninstall 版本 提示你手动去nvm安装目录删除
9、参考文章 nvm介绍及使用
nvm卸载指定node.js版本号
Node快速切换版本、版本回退(降级)、版本更新(升级)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a96a309c6252e800a4acfd9478dfe7b7/" rel="bookmark">
			XXX想使用“登录”钥匙串，或者 Adobe Acrobat 想使用“登录”钥匙串
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 参考链接http://www.zhaoniupai.com/wap.asp?act=View&amp;id=329
前几天用adobe zii破解了 acrobat，然后就一直弹出 Adobe Acrobat 想使用“登录”钥匙串，开始以为是中病毒了，重装了电脑，在adobe zii官网重新下载了破解软件后还是一样，用趋势安全大师查了下也没有病毒，但也不代表电脑没有被恶意软件侵入。
在网上搜了很多办法，只有链接中的方法有效果。步骤如下
1 打开 钥匙串访问
2 清空 登录 钥匙串，这样会清空电脑保存的所有密码，想好了再操作 3 重启电脑 解决 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9559242f26cb0b9c3e6733d913fbb517/" rel="bookmark">
			linux_查看 Nvidia 驱动版本、Cuda、Cudnn 版本号
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 查看 Nvidia 显卡利用率：显存占用和算力情况。
# 0.5 秒更新一次显卡利用情况，并查看 NVIDIA 驱动版本 watch -n 0.5 nvidia-smi 2. 查看 Cuda 版本：
cat /usr/local/cuda/version.txt 3.查看 Cudnn 版本：
cat /usr/local/cuda/include/cudnn.h | grep CUDNN_MAJOR -A 2 cudnn 版本为 7.6.5
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1cb5b4ba476192470c4afd18651f90d2/" rel="bookmark">
			步进电机距离计算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一步：确定步进电机的步距角,这个电机上会标明的.比如说,1.8度,则一个圆周360/1.8=200,也就是说电机旋转一周需要200个脉冲.
第二步：确定电机驱动器设了细分细分没有,查清细分数,可以看驱动器上的拨码.比如说4细分,则承上所述,200*4=800,等于说800个脉冲电机才旋转一周.
第三步：确定电机轴一周的长度或者说导程：如果是丝杠,螺距*螺纹头数=导程,如果是齿轮齿条传动,分度圆直径(m*z)即为导程,导程/脉冲个数=一个脉冲的线位移. 细分和相数没关系。以1.8度为例，原来一个脉冲走1.8度，现在改为4细分，那么现在一个脉冲只能走1.8/4度了。细分越多，每个脉冲的步进长度越短。细分的多少可由驱动器设置。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96f07a0bc80f6eeecb6fc6d5544fde0d/" rel="bookmark">
			Centos7（六）之vi编辑器的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vi 编辑器的使用
vim是vi的增强版，vim可以语法的高亮，完全兼容vi
查看是否有安装vim
rpm -qf which vim`
这里我们没安装vim，手动安装下，用yum源
yum list | grep vim
yum install -y vim-minimal.x86_64 2:7.4.629-6.el7
提示已经是最新版的，不能在进行安装，但是却调用不了vim
我们需要先卸载掉安装软件，在重新下载较全的安装程序
yum remove vim vim-enhanced vim-common vim-minimal
yum -y install vim*
安装完成，可以正常使用
vim的一些使用方法
i ：当前字符之前插入
I：行首插入
a：当前字符之后插入
A：行尾插入
o：另起一行插入
x：向后删除一个字符
X：向前删除一个字符
u：撤销
r：替换
定位
gg：快速定位到首行
3gg：快速定位到第3行首
查找
:/字符串 （N、n上下移动）
:noh （取消高亮）
复制
yy：复制整行
2yy：复制2行
删除
dd：删除一行
2dd：删除2行
粘贴
p
剪贴
dd
设置行号
:set nu
:set nonu
同时打开两个文件
vim -o etc/passwd etc/hosts （-o 上下分屏、-O左右分屏）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/96f07a0bc80f6eeecb6fc6d5544fde0d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b29efab2981ef8b26c6f88358031a062/" rel="bookmark">
			剑指offer数组类题目汇总（共12道题目）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.二维数组中的查找 题目描述：
在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。
解题思路：
很明显，由于该二维数组上到下递增，左到右递增的特殊性，遍历整个矩阵进行查找不是该题目的意图所在。总结规律我们可以发现：应该从矩阵的右上角或者左下角开始查找。
以右上角为例，首先选取右上角的数字，如果该数字等于要查找的数字，则查找过程结束；如果该数字大于要查找的数字，则说明该列其他元素都大于要查找的数字，便可以删掉该列；如果该数字小于要查找的数字，则说明该行其他元素也都小于要查找的数字，便可以删掉该行。
这样，每一次比较都可以剔除一行或者一列，进而缩小查找范围，时间复杂度为O(n)。
举例：
比如在下面的二维数组中查找数字7，查找过程如下：
代码如下：
class Find{ public boolean find(int target,int [][] arr){ if(arr == null|| arr.length == 0) return false; //数组为空或不是二维数组直接返回false int row = arr.length; //定义行 int col = arr[0].length;//定义列 int i = 0; int j = col - 1; //从右上角开始 while(i&lt;row &amp;&amp; j&gt;0) { if (arr[i][j] == target) return true; //找到目标值 else if (arr[i][j] &gt; target) j--; //这一列不符合 else i++; //这一行不符合 } return false; } } **
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b29efab2981ef8b26c6f88358031a062/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e1bed9a0db9cedcf043e1fab7a41569/" rel="bookmark">
			spring 源码分析 平台事务管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AOP 事务对象 (PlatformTransactionManager) PlatformTranscationManager 平台事务管理作为事务的通用 API 处理。
提供三个方法：
1、根据事务定义创建事务状态
TransactionStatus getTransaction (TransactionDefinition definition) ;
2、根据事务状态执行事务提交
void commit(TransactionStatus status);
3、根据事务状态执行事务回滚
void rollback(TransactionStatus status);
平台抽象层 AbstractPlatformTransactionManager 对 PlatformTranscationManager 接口方法进行了实现。并延伸了4个抽象方法 doGetTransaction() 、 doBegin()、 doCommit() 、 doRollback()… 等抽象方法。
DataSourceTransactionManager 分析 数据源事务管理, 继承抽象平台事务管理器. 封装着 DataSource 对象. 实现平台抽象层方法。
一、doGetTransaction() 1、创建 DataSourceTransactionObject 对象。 其主要操作的就是 java.sql.Connection 连接，通过创建保存点（java.sql.Savepoint）、回滚保存点、释放保存点.
2、创建 ConnectionHolder 数据库连接对象持有者，并设置给 DataSourceTransactionObject 对象
二、doBegin(DataSourceTransactionObject， TransactionDefinition) 1、将资源标记为与事务同步，获取 Connection 连接对象
2、获取早先的隔离级别，设置给 DataSourceTransactionObject
3、检索此 连接 对象的当前自动提交模式
4、在事务开始后立即准备事务 Connection，设置事务已开启
5、设置超时时间
三、doCommit(DefaultTransactionStatus) 1、通过 DefaultTransactionStatus 得到 DataSourceTransactionObject 对象获取 ConnectionHolder 连接持有者中 Connection 提交事务
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e1bed9a0db9cedcf043e1fab7a41569/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3bea2f253e9e8c3234ee1c64aadfa6b7/" rel="bookmark">
			redis源码分析之二 —整体架构和流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、整体架构 Redis作为一种KV型数据库，其主要的应用方式有几种：
1、单机结构
这种情况适用于小规模的应用，安全性也相对来说比较低。处理能力有限，其数据容量也不会太大。
2、主从结构
这种方式其实就是一主多备，既可以降低Master的读压力，又可以增强安全性。但是存在主从复制的安全性问题。仍然没有解决写压力。
3、哨兵结构
通过哨兵的监控，实现了主从结构的增强即主服务器的自动灾难转移处理。这样就保证了整个系统的高可用性和安全性。增加了对系统的监控能力。但是仍然存在Master节点的写压力的问题。
4、集群结构-Proxy型
一些公司在上述的基础上增加了代理集群管理，开源了一些框架，比如Twemproxy，其实就是通过透明分片来实现多Master和多Salve。不过增加高可用的代价是，代理需要维护Failover需要自己实现。鱼和熊掌没有得兼。
5、集群结构-直连型
从Redis3.0之后支持了redis-cluster模式。其采用的是无中心结构，有点类似于P2P网络。可以自动扩展，无代理，按照哈希槽分布存储。高可用，自动实现Failover。通过Raft实现M/S的角色处理。
代码的整体架构以及代码分析，以单机及主从为主，在遇到重点流程及后期时增加其它结构类型的相关源码分析。抓住重点，理清脉络，用古人的话来说“直击肯綮”。先是整体分析，然后再根据重点的数据结构和模块进行逐一分析。
在前文提到过，Redis是一个单线程的基于多事件多路利用的C/S结构。其客户端既有官方提供的redis-cli，也有大量的第三方提供的基于其它语言的客户端。国内的各大公司几乎都封装了自己的客户端。所以，架构就说明了其流程，它一定是服务端启动监听，客户端连接并传送相关命令，然后服务端监听到数据后进行解析，丢给相关的事件处理器，然后再展开到Redis的相关处理逻辑。下面就分析其流程。
[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-00AGSEf9-1576393984889)(img/redis_frame.png)]
说明：上述的图是从https://mp.weixin.qq.com/s/XJzu8yyVYZYmcOui_xXnvw中截取，如有侵权，请告知删除。
二、流程 1、客户端
老样子，先看代码：
int main(int argc, char **argv) { int firstarg; //相关的配置文件省略 config.hostip = sdsnew("127.0.0.1"); config.hostport = 6379; ...... config.cluster_manager_command.timeout = CLUSTER_MANAGER_MIGRATE_TIMEOUT; config.cluster_manager_command.pipeline = CLUSTER_MANAGER_MIGRATE_PIPELINE; config.cluster_manager_command.threshold = CLUSTER_MANAGER_REBALANCE_THRESHOLD; config.cluster_manager_command.backup_dir = NULL; pref.hints = 1; spectrum_palette = spectrum_palette_color; spectrum_palette_size = spectrum_palette_color_size; if (!isatty(fileno(stdout)) &amp;&amp; (getenv("FAKETTY") == NULL)) config.output = OUTPUT_RAW; else config.output = OUTPUT_STANDARD; config.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3bea2f253e9e8c3234ee1c64aadfa6b7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae86948ca882ea791d35ed1b5c11e4ff/" rel="bookmark">
			博客搬家声明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		即将迁移博客，但是原来的文章会保存，由于CSDN的商业性广告太多，自己的分类被强行变成了专栏，而且原来的链接也用不了，现在准备要去博客园，链接是
博客园 但还是感谢CSDN这些年的帮助，我虽不舍，但依旧离开CSDN，希望明天会更好
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9d82ac2dec19c072a4a6c3b8e91812c/" rel="bookmark">
			原码，反码，补码的表示范围
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		图中已经很清楚的给出范围，原码与反码都有正零，负零之分，而补码没有。补码比原码反码多表示一位，那就是-2^n
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39189190fe5f36d787d557deb0573403/" rel="bookmark">
			个人认为最简单好用的KOA代理转发中间件  koa2-proxy-middleware
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		配置koa2-proxy-middleware用于代理转的中间件。在使用koa2作为前后端分离的框架，工程当中的静态页面需要请求在其他域名下的java工程接口，由于同源策略的限制，在koa2工程下的静态资源只能通过node后端进行代理请求其他域名下的接口。（ngnix或者php等等都可以）
基础使用比网上其他KOA的代理都简单，直接上代码：
// 导入koa，和koa 1.x不同，在koa2中，我们导入的是一个class，因此用大写的Koa表示: const Koa = require('koa'); const app = new Koa(); /* 代理配置 start */ const proxy = require('koa2-proxy-middleware'); //引入代理模块 const options = { targets: { // (.*) means anything '/api/(.*)': { target: 'http://test02.com/', changeOrigin: true, }, } } app.use( proxy(options) ); const bodyparser = require('koa-bodyparser') app.use(bodyparser({ enableTypes: ['json', 'form', 'text'] })) /* 代理配置 end */ // log request URL: app.use(async (ctx, next) =&gt; { console.log(`Process ${ctx.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/39189190fe5f36d787d557deb0573403/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5cc2010976240c6f5a906e3c0829bf2c/" rel="bookmark">
			2019.12.07【NOIP提高组】模拟A 组
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JZOJ 3918 蛋糕 题目 把一个矩阵横切三刀，竖切三刀，问当中的子矩阵总和最小的最大能是多少
分析 首先相当暴力的方法就是暴力切的位置然后用前缀和，时间复杂度应该是 O ( n 6 ) O(n^6) O(n6)，但是这个东西是二分的套路，考虑二分答案，首先竖切三刀，然后 O ( n ) O(n) O(n)判断，只要能分成4段或以上即为合法
代码 #include &lt;cstdio&gt; #include &lt;cctype&gt; #define rr register using namespace std; int n,m,ans,a[101][101],tot; inline signed iut(){ rr int ans=0; rr char c=getchar(); while (!isdigit(c)) c=getchar(); while (isdigit(c)) ans=(ans&lt;&lt;3)+(ans&lt;&lt;1)+(c^48),c=getchar(); return ans; } inline bool check(int j1,int j2,int j3,int k){ rr int s1=0,s2=0,s3=0,s4=0,kuai=0; for (rr int i=1;i&lt;=n;++i){ s1+=a[i][j1],s2+=a[i][j2]-a[i][j1],s3+=a[i][j3]-a[i][j2],s4+=a[i][m]-a[i][j3]; if (s1&gt;=k&amp;&amp;s2&gt;=k&amp;&amp;s3&gt;=k&amp;&amp;s4&gt;=k) s1=s2=s3=s4=0,++kuai; } return kuai&gt;=4; } signed main(){ n=iut(); m=iut(); for (rr int i=1;i&lt;=n;++i) for (rr int j=1;j&lt;=m;++j){ rr char c=getchar(); while (!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5cc2010976240c6f5a906e3c0829bf2c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e895f5eac81fae51d8c85e2eea6a7f47/" rel="bookmark">
			mac  指定范围 名称模糊匹配 批量删除文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		因为maven仓库 之前下载的jar包存在失败，产生了.lastUpload 文件，所以需要批量模糊删除
首先进入我们指定的文件夹（里面允许有子级文件夹）
cd /Users/lch/install/java/apache-maven-3.5.0/repository
删除文件
find ./ -name "*.lastUpdated" -exec rm -rf {} \;
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f6156c88f88c5fbc7998ad1aa41f881/" rel="bookmark">
			spring中类名相同，但包名不同，导致spring启动失败 解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景：本项目引入了一个三方jar包，但jar中出现了一个类名相同，但包名不同，导致spring启动失败 解决方案：
方案一：排查下在本项目调用过程中是否不会用到某一个深层jar，要是没用到，则在引入该jar的坐标时用以下方式排除掉该冲突类所在的深层jar
&lt;dependency&gt; &lt;artifactId&gt;三方jar&lt;/artifactId&gt; &lt;groupId&gt;三方jar&lt;/groupId&gt; &lt;version&gt;三方jar&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;冲突包所在的深层jar&lt;/artifactId&gt; &lt;groupId&gt;冲突包所在的深层jar&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; 方案二：排出下本项目在调用过程中是否不会用到某一个冲突的类（两个都用不到更好，不过只为了解决冲突，则只需处理一个即可），要是没用到，则在spring扫描该jar包时，将该类忽略掉不加载即可。这种方式比第一个更精确
&lt;context:component-scan base-package="com.*" &gt; &lt;context:exclude-filter type="annotation" expression="冲突类全名（包含包路径啊）"/&gt; &lt;/context:component-scan&gt; 方案三：转载其他地方的（原地址：https://www.cnblogs.com/bedlimate/p/8660839.html）
项目背景：
某日，有需求要在三天的时间内完成两个大项目的项目合并，因为之前两个项目的包结构和类名都很多相同，于是开始考虑使用加一级包进行隔离，类似于这种结构
但是在启动的过程中，抛出来这样的异常：
1
2
3
4
5
6
7
8
9
Caused by: org.springframework.context.annotation.ConflictingBeanDefinitionException: Annotation-specified bean name 'nameConflict' for bean class [xom.liuyun.beannameconflict.modelB.NameConflict] conflicts with existing, non-compatible bean definition of same name and class [xom.liuyun.beannameconflict.modelA.NameConflict]
at org.springframework.context.annotation.ClassPathBeanDefinitionScanner.checkCandidate(ClassPathBeanDefinitionScanner.java:348) ~[spring-context-5.0.4.RELEASE.jar:5.0.4.RELEASE]
at org.springframework.context.annotation.ClassPathBeanDefinitionScanner.doScan(ClassPathBeanDefinitionScanner.java:286) ~[spring-context-5.0.4.RELEASE.jar:5.0.4.RELEASE]
at org.springframework.context.annotation.ComponentScanAnnotationParser.parse(ComponentScanAnnotationParser.java:132) ~[spring-context-5.0.4.RELEASE.jar:5.0.4.RELEASE]
at org.springframework.context.annotation.ConfigurationClassParser.doProcessConfigurationClass(ConfigurationClassParser.java:284) ~[spring-context-5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4f6156c88f88c5fbc7998ad1aa41f881/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cecbfa1fa320a9262e2374306af0740e/" rel="bookmark">
			mongo 替换某个字段中的某个特定字符
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据库 member 表字段格式举例：
{ "_id" : ObjectId("xxxxxx"), ... "socials" : [ { "channel" : "wechat-channelId1", "openId" : "wechat是是openId1", }, { "channel" : "wechat-channelId2", "openId" : "wechat-openId2", }, { "channel" : "weapp-channelId3", "openId" : "weapp-openId3", }, { "channel" : "weibo-channelId4", "openId" : "weibo-openId4", }, ], ... } socials.openId 字段中可能有脏数据，要把“是”替换为“1”
脚本
var count = 0; db.member.find({ "socials.openId": /^.*是.*$/, }).snapshot().forEach(function(member) { var newSocials = [] member.socials.forEach(function(social) { var oldOpenId = social.openId; var tmp = social.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cecbfa1fa320a9262e2374306af0740e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c303ebdf357987dd9c423421a8012bf6/" rel="bookmark">
			jsdelivr&#43;github使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		jsdelivr+github使用 前提创建github仓库克隆仓库到本地上传github配置版本号通过jsdelivr访问 前提 1.有github账号
2.安装git工具
创建github仓库 进入github首页-Repository-new
输入对应的仓库信息-点击创建
复制仓库地址
克隆仓库到本地 在本地右键打开Git Bash Here-执行克隆命令
git clone https://github.com/RoyalKnights/cdn.git 此时将本地仓库克隆到了本地
将想要jsdelivr访问的文件放入仓库(我这里建立一个img文件放入一张图片)
进入仓库文件夹,把文件添加并提交到仓库更多教程
cd cdn git add --all git commit - m "描述信息“ 上传github git push -u origin master 此时会让你输入github账号和密码
配置版本号 进入仓库点击releases
创建一个版本号
通过jsdelivr访问 https://cdn.jsdelivr.net/gh/&lt;github账号&gt;/&lt;仓库名称&gt;@&lt;版本号&gt;/&lt;文件路径&gt;/&lt;文件名&gt; 不输入版本号默认访问最新版本 例如浏览器输入https://cdn.jsdelivr.net/gh/RoyalKnights/cdn@v1.0/img/test.jpg
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21aad9c9af6e26198a3a2137c7d25d2f/" rel="bookmark">
			Python - 翻转(reverse)字符串(string)的所有方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 string = 'abcdef' def string_re1(string): return string[::-1] string_re1(string) def string_re2(string): t=list(string) s=len(string) for i,v in zip(range(s-1,0,-1),range(s//2)): t[i],t[v] = t[v],t[i] return "".join(t) string_re2(string) def string_revers3(string): if len(string)&lt;=1: return string return string_revers3(string[1:])+string[0] string_revers3('sdswew') from collections import deque def string_reve4(string): d=deque() d.extendleft(string) return "".join(d) string_reve4('sdfs') def string_rev5(x): return "".join(x[i] for i in range(len(x)-1,-1,-1)) string_rev5('sdfs') 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc79563d78e038eed6f1e4f4cef6dc3d/" rel="bookmark">
			最基础的01动态规划背包问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 0-1背包 (50分)
给定n(n&lt;=100)种物品和一个背包。物品i的重量是wi，价值为vi，背包的容量为C(C&lt;=1000)。问:应如何选择装入背包中的物品，使得装入背包中物品的总价值最大? 在选择装入背包的物品时，对每种物品i只有两个选择：装入或不装入。不能将物品i装入多次，也不能只装入部分物品i。
输入格式:
共有n+1行输入： 第一行为n值和c值，表示n件物品和背包容量c； 接下来的n行，每行有两个数据，分别表示第i(1≤i≤n)件物品的重量和价值。
输出格式:
输出装入背包中物品的最大总价值。
输入样例:
在这里给出一组输入。例如：
5 10
2 6
2 3
6 5
5 4
4 6
输出样例:
在这里给出相应的输出。例如：
15
我的看法 其实这道题目非常简单，我敲了12行就能AC。
分享出来是因为我动态规划学的很差，今天就又走了一遍这道题目。
下面这张图是用PPT写的这道题的样例的动态规划的可视化算法思想。
讲真，这个算法我觉得我理解了，但是有一段时间我很难敲出来。用二维数组很难敲出来。
今天试了一下一维数组，其实反倒比二维数组容易一些，循环思路更简单一些，所以还是不要用二维数组了。我以前一直觉得二维数组占空间大，但是思路应该简单。但是，并没有，二维数组控制起来，在循环里要比一维数组复杂一些，我就之前被绕蒙了好几次，所以还是算了。既然一维数组思路更清晰，站空间还小，我为什么要写二维数组？
AC代码：
#include &lt;iostream&gt; using namespace std; int n, m, w[1000], v[1000], dp[1000]={0}; int main() { cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; n; i++) cin &gt;&gt; w[i] &gt;&gt; v[i]; for(int level=0;level&lt;n;level++) for(int C=m;C&gt;=w[level];C--) dp[C]=max(dp[C],dp[C-w[level]]+v[level]); cout &lt;&lt; dp[m] &lt;&lt; endl; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8dec824e8007006bda816105dff5ea17/" rel="bookmark">
			jupyter notebook打开指定文件内容
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果把代码、资料放到C盘是很占空间的。放到其他盘最好1、首先进入某个盘2、进入某个盘的文件 cd 文件名3、然后再输入 jupyter notebook
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de88dbfe62abb246087a6bc2cf242a65/" rel="bookmark">
			GBD调试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		GDB调试说明 全称 缩写 说明 举例 set args------设置程序运行的参数set args 10 sssbreak b 添加调试断点b 10runr运行调试rnextn执行下一句，不进入函数内部nsteps下一句，进入函数内部s continue c执行后面的语句，有断点自动停，没有将程序执行完cprintfp打印变量值p varnameset----设置变量值set i=20,str=ssss,都使用 =quitq退出调试 GDB 调试输出到文件： 1.gcc -g 源文件 2.gdb 可执行文件 3.进入gdb模式后，设置日志存储的文件 set logging file xxx.txt 4.开始将日志拷贝到文件 set logging on 5.关闭拷贝 set logging off 6.结束调试后，在当前文件夹打开日志即可查看。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c454264f07137bd29bff03847ad9e23/" rel="bookmark">
			Modbus RTU与Modbus TCP协议的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、概念不同：MODBUS是一种标准的工业控制数据交换协议，可以用RTU和ASCII两种方式进行协议数据的互传，RTU是通过二进制数据方式直接传送数据，而TCP是通过将每字节二进制数据转换为固定两位十六进制字符串，再依次串联在一起，以TCP码形式进行数据传送，一般用得最多的还是RTU方式。
2、通信方式不同： 以太网，对应的通信模式是MODBUS TCP。异步串行传输（各种介质如有线RS-232-/422/485/；光纤、无线等），对应的通信模式是MODBUS RTU或MODBUS ASCII。高速令牌传递网络，对应的通信模式是Modbus PLUS。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd89a870e876536b1c8160169b9f91f7/" rel="bookmark">
			Springboot开发指南（三）—ajax&#43;mybatis&#43;mysql从数据库读取数据并展示到前台
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一 需求
二 项目效果
三 项目建设步骤
1. 在mysql里建设数据库表m_members
2.使用IDEA 新建工程，引入依赖
3. 建后台目录及四层文件
4. 引入css和js，建前台html文件
5. 建数据库配置文件
一 需求 采用springboot+ajax+mybatis技术从mysql数据库读取数据，并展示到前台
二 项目效果 浏览器输入：http://localhost:8091/member。在页面输入ID为1，单击搜索按钮，从数据库获取数据并显示到前台
三 项目建设步骤 1. 在mysql里建设数据库表m_members 2.使用IDEA 新建工程，引入依赖 （1）选择SpringWeb、Thymeleaf、JDBC API、MySQLDriver、MyBatis Framework选型
（2）添加fastjson依赖 ，用于后台返回json格式数据
&lt;dependency&gt;
&lt;groupId&gt;com.alibaba&lt;/groupId&gt;
&lt;artifactId&gt;fastjson&lt;/artifactId&gt;
&lt;version&gt;1.2.28&lt;/version&gt;
&lt;/dependency&gt;
添加后的依赖如下：
&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.0.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.28&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bd89a870e876536b1c8160169b9f91f7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c9514ba5a841cf1852949ed4bfb65a71/" rel="bookmark">
			VTP技术及相关配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 VTP介绍VTP配置简单服务端与客户端接入另一个交换机sw3（默认为服务端）将sw2设置为透明模式，sw3配置为客户端模式设置密码防御vtp攻击（服务器设密码后，需要同步vtp的交换机的就需要设相同的密码） VTP介绍 VTP（VLAN Trunking Protocol）：是VLAN中继协议，也被称为虚拟局域网干道协议。它是思科私有协议。作用是十几台交换机在企业网中，配置VLAN工作量大，可以使用VTP协议，把一台交换机配置成VTP Server, 其余交换机配置成VTP Client,这样他们可以自动学习到server 上的VLAN 信息。
VTP模式
描述ServerClientTransparent增删改vlan信息YNY转发vtp信息YYY同步vtp信息YYN保存在NVRAM中YNY 在VTP中谁与谁同步，不是由角色决定，而是由版本号（修订版本号）决定
版本号大的vlan信息将完全覆盖版本号低的vlan信息
在向网络中添加交换机时一定要注意版本号的大小，建议把模式改为透明模式
VTP配置 首先：保证交换机为trunk模式
简单服务端与客户端 服务区模式交换机的配置
sw1(config)#vtp domain‘域名’ 设置域名 sw1(config)#vtp mode server 将交换机设置为服务器模式 2、	客户端模式交换机的配置 Sw2(config)#vtp domain‘域名’ 设置域名 Sw2(config)#vtp modeclient 将交换机设置为服务器模式 服务端划分子网，进行测试
sw1(config)#vlan 10	划分vlan sw1(config-vlan)#vlan 20 sw1(config-vlan)#vlan 30 查看vtp：
Sw1#sh vtp status 查看vtp配置（版本号…） Sw2#sh vtp status 查看vlan：
接入另一个交换机sw3（默认为服务端） （trunk模式）
sw3(config)#int f0/23 sw3(config-if)#switchport mode trunk 查看vlan及vtp，发现自动同步了的vtp和vlan
在sw3添加vlan划分，并查看vtp
sw3(config)#vlan 90 sw3(config-vlan)#vlan 80 sw3(config-vlan)#vlan 70 sw3(config-vlan)#exit sw3(config)#end sw3#sh vtp status Vtp变化
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c9514ba5a841cf1852949ed4bfb65a71/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/973d46e279b1a9602c70b304da0c4c62/" rel="bookmark">
			PyTorch 入门学习（七）————torchvision.transforms
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 管理各个transform，使用Compose一、裁剪 ------ Crop1、随机裁剪：transforms.RandomCrop2.中心裁剪：transforms.CenterCrop3.随机长宽比裁剪 transforms.RandomResizedCrop4.上下左右中心裁剪：transforms.FiveCrop5.上下左右中心裁剪后翻转: transforms.TenCrop 二、翻转和旋转——Flip and Rotation6.依概率p水平翻转transforms.RandomHorizontalFlip7.依概率p垂直翻转transforms.RandomVerticalFlip8.随机旋转：transforms.RandomRotation 三、图像变换9.resize：transforms.Resize10.标准化：transforms.Normalize11.转为tensor：transforms.ToTensor12.填充：transforms.Pad13.修改亮度、对比度和饱和度：transforms.ColorJitter14.转灰度图：transforms.Grayscale15.线性变换：transforms.LinearTransformation()16.仿射变换：transforms.RandomAffine17.依概率p转为灰度图：transforms.RandomGrayscale18.将数据转换为PILImage：transforms.ToPILImage19.transforms.Lambda 四、对transforms操作，使数据增强更灵活20.transforms.RandomChoice(transforms)21.transforms.RandomApply(transforms, p=0.5)22.transforms.RandomOrder 官方文档地址： https://pytorch.org/docs/stable/torchvision/transforms.html transform 总共有22个使用方法，可以同时使用多个，使用 transforms.Compose 来实现 管理各个transform，使用Compose Example: &gt;&gt;&gt; transforms.Compose([ &gt;&gt;&gt; transforms.CenterCrop(10), &gt;&gt;&gt; transforms.ToTensor(), &gt;&gt;&gt; ]) 一、裁剪 ------ Crop 1、随机裁剪：transforms.RandomCrop class torchvision.transforms.RandomCrop(size, padding=None, pad_if_needed=False, fill=0, padding_mode=‘constant’) 功能：依据给定的size随机裁剪size- (sequence or int)，若为sequence,则为(h,w)；若为int，则(size,size)padding-(sequence or int, optional)，此参数是设置填充多少个pixel。
当为sequence时，若有2个数，则第一个数表示左右扩充多少，第二个数表示上下的。当有4个数时，则为左，上，右，下。
当为int时，图像上下左右均填充int个，例如padding=4，则上下左右均填充4个pixel，若为3232，则会变成4040。fill- (int or tuple) 填充的值是什么（仅当填充模式为constant时有用）。int时，各通道均填充该值，当长度为3的tuple时，表示RGB通道需要填充的值。padding_mode- 填充模式，这里提供了4种填充模式，1.constant，常量。2.edge 按照图片边缘的像素值来填充。3.reflect，暂不了解。 4. symmetric，暂不了解。 2.中心裁剪：transforms.CenterCrop class torchvision.transforms.CenterCrop(size) 功能：依据给定的size从中心裁剪参数：size- (sequence or int)，若为sequence,则为(h,w)，若为int，则(size,size) 3.随机长宽比裁剪 transforms.RandomResizedCrop class torchvision.transforms.RandomResizedCrop(size, scale=(0.08, 1.0), ratio=(0.75, 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/973d46e279b1a9602c70b304da0c4c62/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3a8f4817ef15b0e082a4912b3f1979b/" rel="bookmark">
			VS调试dll
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、调试本地dll文件 1、右键项目，点击“属性”，打开“调试”，修改“命令”即可，命令中记录的是目标exe所在文件路径。
注意：
a、配置中要选择debug，修改后一定要点击“应用”；
b、目标exe必须是debug版的；
c、调试的时候，必须保证dll和.h文件一致（库工程的头文件和生成的dll文件要与调试工程中的一致），否则vs上断点无效。
之后点击vs的运行按钮即可。
二、远程调试dll文件 方法一：
1、将下图文件夹copy到被调试电脑。根据目标电脑位数来对应打开x64或x86，然后以管理员身份打开“msvsmon.exe”。
点击“工具”，点击“选项”，设置“无身份验证”，点击确定即可。
注意：要把最长空闲时间改为0。
2、打开“调试”，点击“附加到进程”，在“限定符”后写入目标电脑的ip，点击“查找”，在对话框中选择对应的电脑选项即可。
完成上述操作后，可用进程栏会显示目标电脑所有在运行的进程。
选择需要调试的进程，然后点击“附加”，就可以开始远程调试。
方法二：
1、执行上述方法一的步骤1。
2、打开项目属性页，按照下图所示，选择“远程windows调试器”。
在“远程命令”栏中写入目标电脑的调试程序路径；
在“远程服务器名称”栏中写入目标电脑的ip；
完成上述操作，即可进行远程调试。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e14760bf6ffa93a02fd31f3b21a169f9/" rel="bookmark">
			【系统安全】cookie未设置Httponly属性和未设置Secure标识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第三方公司做了系统安全测试，提出了这个问题。
详细描述会话cookie中缺少HttpOnly属性会导致攻击者可以通过程序(JS脚本、Applet等)获取到用户的cookie信息，造成用户cookie信息泄露，增加攻击者的跨站脚本攻击威胁。
HttpOnly是微软对cookie做的扩展，该值指定cookie是否可通过客户端脚本访问。Microsoft Internet Explorer 版本 6 Service Pack 1 和更高版本支持cookie属性HttpOnly。
如果在Cookie中没有设置HttpOnly属性为true，可能导致Cookie被窃取。窃取的Cookie可以包含标识站点用户的敏感信息，如ASP.NET会话ID或Forms身份验证票证，攻击者可以重播窃取的Cookie，以便伪装成用户或获取敏感信息，进行跨站脚本攻击等。
如果在Cookie中设置HttpOnly属性为true，兼容浏览器接收到HttpOnly cookie，那么客户端通过程序(JS脚本、Applet等)将无法读取到Cookie信息，这将有助于缓解跨站点脚本威胁。解决办法向所有会话cookie中添加“HttpOnly”属性。
Java示例：
HttpServletResponse response2 = (HttpServletResponse)response;
//response2.setHeader( "Set-Cookie", "name=value; HttpOnly");
response2.addHeader( "Set-Cookie", "name=value; HttpOnly"); 解决方式：使用过滤器为每一个cookie添加HttpOnly
在web.xml中加入拦截器：
&lt;!--cookie 设置httponly和secure--&gt; &lt;filter&gt; &lt;filter-name&gt;cookieFilter&lt;/filter-name&gt; &lt;filter-class&gt;cn.**.**.**.security.CookieFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;cookieFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; CookieFilter.java内容如下：
public class CookieFilter implements Filter { public static final Logger logger = Logger.getLogger(CookieFilter.class); @Override public void init(FilterConfig filterConfig) throws ServletException { logger.info("Cookie filter started."); } @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { HttpServletRequest req = (HttpServletRequest) servletRequest; HttpServletResponse resp = (HttpServletResponse) servletResponse; Cookie[] cookies = req.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e14760bf6ffa93a02fd31f3b21a169f9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29e2cd1acd4891e51114b5147ee2370e/" rel="bookmark">
			CentOS系统中安装wget
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、最近想要使用wget下载文件到我们CentOS系统中去，但是我的Linux系统显示，未找到命令，发现自己的Linux系统中并未安装wget,一下是我的安装操作，还有部分截图。
2、输入一下指令，查看，可以看到在我的linux中什么也没有显示出来，说明我并没有安装wget。
rpm -qa| grep wget 3、执行如下语句，可以看到我的Linux系统正在执行下载操作这样只需等待一会，就会显示出已安装完成了。
yum install -y wget 下面是我的安装日志：
已加载插件：fastestmirror Determining fastest mirrors * base: mirrors.aliyun.com * extras: mirrors.aliyun.com * updates: mirrors.aliyun.com base | 3.6 kB 00:00:00 docker-ce-stable | 3.5 kB 00:00:00 extras | 2.9 kB 00:00:00 updates | 2.9 kB 00:00:00 (1/5): docker-ce-stable/x86_64/primary_db | 37 kB 00:00:02 (2/5): base/7/x86_64/group_gz | 165 kB 00:00:08 (3/5): extras/7/x86_64/primary_db | 153 kB 00:00:13 (4/5): base/7/x86_64/primary_db | 6.0 MB 00:01:21 (5/5): updates/7/x86_64/primary_db | 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/29e2cd1acd4891e51114b5147ee2370e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/420f2e8f3a75ba67cc1f206cde458468/" rel="bookmark">
			lua常用操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		--- 查看某值是否为表中的key值 ---@param tableTemp 需要查找的表 ---@param key 键 function ContainsKey(tableTemp, key) if tableTemp == nil then return false end for k, v in pairs(tableTemp) do if k == key then return true end end return false end --- 查看某值是否为表中的value值 ---@param tableTemp 需要查找的表 ---@param value 值 function ContainsValue(tableTemp, value) if tableTemp == nil then return false end for k, v in pairs(tableTemp) do if v == value then return true end end return false end --- 查看某值是否为数组中的值 ---@param tableTemp 需要查找的数组 ---@param value 值 function ArrayContains(tableTemp, value) if tableTemp == nil then return false end for i=1,#tableTemp,1 do if tableTemp[i] == value then return true end end return false end ---@desc 获取table长度,索引从1开始 ---@param tableTemp 需要操作的table ---@return table长度,索引从1开始 function GetTableLength(tableTemp) if type(tableTemp) ~= "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/420f2e8f3a75ba67cc1f206cde458468/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93a59143c066f68faaf9c4e8903442e1/" rel="bookmark">
			lua知识点-maxn
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言# 今天来看一个关于table的一个简单的函数，我们知道Lua数组中的索引一般从1开始，那么数组的length就等于数组的最大索引，但是当数组下标不是连续时，我们要活的最大索引要怎么办，那就需要使用我们今天所讲的函数了。
内容# table.maxn()## 原型：table.maxn (tab_table)解释：返回一个表tab_table中的最大正数索引，如果没有正数索引的话返回0。 Uasge## 首先新建一个文件命名为maxntest.lua然后编写如下代码： -- 各种索引都存在 local tabLanguage = { up ="Lua", "c", "c++", [100] = "end", realend = "realend", [-1] = "haha"; }; for k,v in pairs(tabLanguage) do print(k,v) end print("LUA&gt;&gt;&gt;&gt;&gt;&gt;the maxn of table tabLanguage :", table.maxn(tabLanguage), "\n") -- 使用默认数字索引 local tabTest1 = { "c", "c++", "php" }; for k,v in pairs(tabTest1) do print(k,v) end print("LUA&gt;&gt;&gt;&gt;&gt;&gt;the maxn of table tabTest1 :", table.maxn(tabTest1), "\n") -- 负数索引 local tabTest2 = { [-1] = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/93a59143c066f68faaf9c4e8903442e1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34bd62fbc964269627ed5abfebac1261/" rel="bookmark">
			python实用代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		检查重复元素 下面的方法可以检查给定列表中是否有重复的元素。它使用了 set() 属性，该属性将会从列表中删除重复的元素。
def all_unique(lst):
return len(lst) == len(set(lst)) x = [1,1,2,2,3,2,3,4,5,6]
y = [1,2,3,4,5]
all_unique(x) # False
all_unique(y) # True
变位词 检测两个字符串是否互为变位词（即互相颠倒字符顺序）
from collections import Counter
def anagram(first, second):
return Counter(first) == Counter(second)
anagram(“abcd3”, “3acdb”) # True
检查内存使用情况 以下代码段可用来检查对象的内存使用情况。
import sys
variable = 30
print(sys.getsizeof(variable)) # 24
4.字节大小计算
以下方法将以字节为单位返回字符串长度。
def byte_size(string):
return(len(string.encode(‘utf-8’)))
byte_size(‘😀’) # 4
byte_size(‘Hello World’) # 11
5.重复打印字符串 N 次
以下代码不需要使用循环即可打印某个字符串 n 次
n = 2;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/34bd62fbc964269627ed5abfebac1261/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/531626af6d6dbed6e2f7c2b856a6ea9f/" rel="bookmark">
			电偶极子的MATLAB场模拟
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		电偶极子周围电场电势分布的MATLAB三维模拟 Matlab可以用于模拟四维场的效果，本文以电偶极子的电场和电势场为例展示MATLAB在该方面领域的应用。
摘要 电偶极子由一个正电荷和一个负电荷组成，其电场和空间电势分布与单电荷相比具有一些重要的特性。本文将给出电场和电势场的近似表达式。这两个量的精确表达式是复杂的，不太常用，因此 MATLAB 被采用来操作精确值和绘制三维分布的远区域， 近区域和一侧区域的电偶极子
关键词： 电偶极子 ， 电势， 能量密度， 电场， MATLAB
引言 由正电荷和负电荷等于q组成的系统，距离为d，称为电偶极子。对于电偶极子，我们定义了一个新的矢量，称为电偶极矩。电偶极子矩矢量 p 的大小是电荷 q 的大小，乘以它们之间的距离 d，P=qd。 向量方向从负电荷指向正电荷。电偶极子的电场和电势可以通过两个电荷的叠加来计算。这种方法很容易想出来，但有时很难计算结果。因此，我们可以使用合理的近似法来简化计算公式。电偶极子矩将用作新公式中的一个变量。
电偶极子的电势场 物理模型 我们可以利用两个电荷的电势叠加来获取太空中的电势。图1是一个电偶极子，其中心位于z轴上，两个电荷之间的距离为d，从点P到q和-q的距离为r+和**r-。
单个电荷的电势公式：
则我们可以以此类推，空间中的电势的分布公式为：
当电偶极子中心到目标点的距离r远大于距离d时（实际上电偶极子默认的一个的定义就是这个）
其中 r- = Δ \Delta Δr= r d c o s θ r d cos\theta rdcosθ, 1/（r+r-） 可以认为等于 1 / r 2 1/r^{2} 1/r2。因为 r &gt;&gt; Δ \Delta Δr 起。从这个公式中我们可以知道，电偶极子电位没有球形对称性，并且会以 1 / r 2 1/r^{2} 1/r2的速度下降，比单个电子的库仑定律计算出的电位快得多，后者的电位会以 1 / r 1/r 1/r的速度下降。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/531626af6d6dbed6e2f7c2b856a6ea9f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f345c7f8776c3e4f6cc4f19b93976015/" rel="bookmark">
			MyBatis驼峰命名规则
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果Java包装类使用驼峰命名规则，则不要忘记在全局配置文件中将mapUnderscoreToCamelCase属性设置为true，否则自动映射机制无法将SQL查询出的非驼峰命名方式的字段名与Java包装类中的属性进行自动映射。
【示例】在MyBatis的全局配置文件SqlMapConfig.xml（mybatis-config.xml）中，开启驼峰命名规则。
&lt;!-- 开启自动驼峰命名规则（camel case）映射 --&gt; &lt;setting name="mapUnderscoreToCamelCase" value="true"/&gt; 【示例】MyBatis中使用驼峰命名规则，映射用户信息类。
（1）数据库中创建用户信息表（tb_user），并添加数据。
-- 创建“用户信息”数据表 CREATE TABLE IF NOT EXISTS tb_user ( user_id INT AUTO_INCREMENT PRIMARY KEY COMMENT '用户编号', user_name VARCHAR(50) NOT NULL COMMENT '用户姓名', blog_url VARCHAR(50) NOT NULL COMMENT '博客地址', remark VARCHAR(50) COMMENT '备注', create_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT '注册时间' ) COMMENT = '用户信息表'; -- 添加数据 INSERT INTO tb_user(user_name,blog_url,remark) VALUES('pan_junbiao的博客','https://blog.csdn.net/pan_junbiao','您好，欢迎访问 pan_junbiao的博客'); （2）创建用户信息持久化类（User.java）。
package com.pjb.mybatis.po; import java.io.Serializable; import java.util.Date; /** * 用户信息持久化类 * @author pan_junbiao **/ public class User implements Serializable { private int userId; //用户ID private String userName; //用户姓名 private String blogUrl; //博客地址 private String remark; //备注 private Date createTime; //创建时间 public int getUserId() { return userId; } public void setUserId(int userId) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f345c7f8776c3e4f6cc4f19b93976015/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b79019cc365daea4d445e575440d586b/" rel="bookmark">
			js中进行数字,超大金额(千位符),日期时间格式化处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		虽互不曾谋面,但希望能和你成为笔尖下的朋友
以读书,技术,生活为主,偶尔撒点鸡汤
不作,不敷衍,意在真诚吐露,用心分享
点击左上方,可关注本刊
撰文 | 川川
VX-ID:suibichuanji
点击文末左下方阅读原文,可看视频内容
前言
最近遇到一个需求,对于社区里讨论的帖子展示一个访问量的计数显示问题,当超过多少页面访问量时,就让其显示xxx万,xx亿
对于后台返回该字段的数据类型是number,需要进行格式化数字的输出
这个应用场景在前端开发中其实很普遍,例如:音乐app里面音乐歌曲播放数量,微博里的点赞数,评论留言条数,页面的访问量,超大金额(千位符格式)处理,甚至时间格式转换等处理
下面就一起来看看怎么处理的
数字超大时-末尾添加相应的单位
需求:当后台接口返回一个较大的数字时,例如:1000,26742238,1234787325,低于6位数时,让数字完全显示,若高于4位,低于8位,给数字加相对应的单位,那么需要在前台做转换为2674.22万,12.34亿
示例代码如下所示:自己封装一个格式化函数
/* * @authors 川川 (itclancode@163.com) * @ID suibichuanji * @weChatNum 微信公众号:itclancoder * @version $Id$ * @desc 数字格式化处理 * */ // num接收的数字,point保留数字的第几位 function tranNumber(num, point){ // 将数字转换为字符串,然后通过split方法用.分隔,取到第0个 let numStr = num.toString().split('.')[0] if(numStr.length&lt;6) { // 判断数字有多长,如果小于6,,表示10万以内的数字,让其直接显示 console.log(numStr); return numStr; }else if(numStr.length&gt;=6 &amp;&amp; numStr.length&lt;=8){ // 如果数字大于6位,小于8位,让其数字后面加单位万 let decimal = numStr.substring(numStr.length-4, numStr.length-4+point) console.log(decimal); // 由千位,百位组成的一个数字 return parseFloat(parseInt(num / 10000)+'.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b79019cc365daea4d445e575440d586b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13aba510541302716d12f42e06c6121a/" rel="bookmark">
			Visual Studio 2019配置OpenCV开发环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文链接 https://xugaoxiang.com/2019/12/10/visual-studio-2019-opencv/
软硬件环境 Visual Studio 2019OpenCV 4.1.2Windows 10 Visual Studio 2019 到官方链接下载安装文件，安装完Visual studio 2019后，再选择安装相应组件，这里需要安装c++桌面应用组件，见下图
配置opencv环境 opencv下载地址，最新版本4.1.2，https://github.com/opencv/opencv/releases/tag/4.1.2，下载下来后是一个exe文件，双击选择安装目录，比如这里我是D:\xugaoxiang，最后目录结构是这样的
接下来设置环境变量PATH，鼠标右键点击我的电脑 --&gt; 属性 --&gt; 高级 --&gt; 环境变量
在Visual studio中使用opencv 在准备工作完成后，就可以打开visual studio 2019了，我们来新建一个项目，类型选择c++控制台应用
在工程创建成功后，在源文件OpenCVTest.cpp中加入代码
#include &lt;opencv2/core/core.hpp&gt; #include &lt;opencv2/highgui/highgui.hpp&gt; #include &lt;opencv2/imgproc.hpp&gt; #include &lt;iostream&gt; using namespace cv; using namespace std; int main() { Mat image = Mat::zeros(300, 600, CV_8UC3); circle(image, Point(300, 200), 100, Scalar(0, 255, 128), -100); circle(image, Point(400, 200), 100, Scalar(255, 255, 255), -100); imshow("Show Window"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/13aba510541302716d12f42e06c6121a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a8066d519768829d23ec2a810c1d7ac/" rel="bookmark">
			Windows设置本地DNS域名解析hosts
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：不涉及其他DNS服务器的解析，只在本地做解析。
一、先找到hosts文件，【默认路径：C:\Windows\System32\drivers\etc\hosts】：
二、修改文件：
三、刷新dns配置：
四、确定后，刷新DNS配置（ipconfig /flushdns）：
五、在自己的本地搭建了一个flask，所以启动是80端口，访问如下域名：
大功告成！
六、其他：
如果web应用不是80端口，那么hosts配置文件保持不变，可以在域名后面加端口，如图所示（这里假设端口为8989）：
注意：hosts文件里面不能带端口。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a758707db253b80d4007207fd467a1e/" rel="bookmark">
			证件照修改尺寸像素大小和存储大小
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
1、修改尺寸像素大小
2、修改图像存储大小
前言 生活中，报名一些考试，往往对提交的证件照的尺寸大小和存储大小有指定的要求，因此汇总整理一些常用方法。
1、修改尺寸像素大小 方法一：使用Windows系统自带的画图工具。
步骤一：首先选中需要修改的图像，鼠标右键该图像--编辑
步骤二：在画图中，选择【重新调整大小】
步骤三：可以在弹出的面板中选择像素，同时不勾选保持纵横比。将像素宽和高设为自己需要的值，另存为该图像即可。
方法二：使用Photoshop软件操作。
步骤一：使用Photoshop软件打开需要修改的图像。选中背景图层，按住快捷键【Ctrl+J】将背景图层复制一个图层。
步骤二：选中图层1，在菜单栏里找到【图像--图像大小】
步骤三：在弹出的对话框中，填入适当的像素大小即可，同时不要勾选【约束比例】。即可实现修改图像大小。
2、修改图像存储大小 有时候会遇到将图像按照规定的像素尺寸修改大小后，但是图像的存储空间依旧超出要求的大小，因此需要进一步修改存储空间大小。
步骤一：使用Photoshop打开需要修改的图像，选择【文件--存储为Web所用格式】
步骤二：在弹出的对话框中，选择JEPG图像格式，通过调整品质值，往小调，能够减小图像所占的存储空间。当前品质所占的存储空间大小如左下角所示。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49fe0466cef0b1c8d49761ccc1966da4/" rel="bookmark">
			php练习题：已知abc&#43;cba=1333，其中a,b,c均为一位数，编写一个程序求出abc分别代表什么数字
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		代码：
&lt;?php for ($a=1;$a&lt;10;$a++){ for ($b=1;$b&lt;10;$b++){ for ($c=1;$c&lt;10;$c++){ if(($a*100+$b*10+$c)+($c*100+$b*10+$a)==1333){ echo $a; echo $b; echo $c; echo "&lt;br&gt;"; echo "================="; } } } 执行效果：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de5b60039eae3321b123ba50c6f1dabd/" rel="bookmark">
			验证手机号跟固话正则
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 验证手机号跟固话正则
/^((0\d{2,3}-\d{7,8})|(1[3584]\d{9}))$/ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c09e57b8cd4f1e3ba4ca63da08fe377/" rel="bookmark">
			相机触发模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、图像采集模式分类 相机的图像采集模式分为内触发模式与外触发模式。其中内触发模式包含连续采集、单帧采集两种形式；外触发模式包含软件触发、硬件外触发。本文以海康相机的软件平台作介绍，该软件去海康机器人官网下载。
内触发模式与外触发模式可以通过 Acquisition Control 下的 Trigger Mode 参数进行设置 Trigger Mode 选择 On 则为外触发模式， Trigger Mode 选择 Off 则为内触发模式。如图
二、内触发模式 2.1 实时视频流（continuous）
手动点击， 展开客户端软件的设备属性列表中的 Acquisition Control，在 Acquisition Mode 选项框 中，若选择 Continuous，相机按照当前设置的帧率持续输出图像， 并给上位机送图像数据，可做实时显示 2.2 单帧采集（SingleFrame） 若选 SingleFrame， 相机只输出一张图片 三、外触发模式 相机不自动送图像数据，需要触发指令才送数据。触发相机进行采集外触发信号的类型，可以是软件给出触发信号，也可以是由外部电 平信号接入。在外触发信号模式下，相机可以按照标准单帧触发采集、多帧触发采集 和长曝光触发采集等几种工作模式输出图像。 主要分为软件触发和硬件触发。 3.1 软触发 就是上位机程序调用触发函数，触发相机拍照，然后送出图像数据，送出图像数据的反应时间按照帧速计算.
软触发有着更大的柔性，但系统整体速度和测量精度一般不如内触发，特别是有着复杂信号处理模块的时候软件触发模式，
3.2 硬触发 就是相机有硬件触发出入接口，收到外部现场的触发信号，相机拍照，然后送出图像数据，送出图像数据的反应时间按照帧速计算。至于抓拍张数可以由自己的驱动软件设定，利用软件延时可以抓拍两张，三张，甚至更多，但真正触发相机的信号只能触发一次。
工业相机外触发分类：
1、边沿触发模式。
可在界面上选择上边沿或者下边沿为触发条件。当触发端子上，收到有效触发信号后，相机开始采集一帧图像，并传输到主机。
2、电平触发模式。
可在界面上选择高电平或者低电平为触发条件，当有触发信号为有效电平时，相机开始采集一帧图像，并传输到主机。
四、各类模式的使用场景 不同的触发方式均有自己的特定使用场景。
a. 外部设备信号触发方式一般在半自动或全自动视觉系统，一键式测量设备等使用。
b. 用户手动触发方式用于前期视觉分析和实验。
c. 周期性自动触发用于类似智能视频分析或安防等系统。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03b81721fc00f72bfb1ae8db7eeefa89/" rel="bookmark">
			【报错问题】Vue element-ui 提示 ‘element-ui/lib/theme-chalk/index.css’ 找不到
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、版本说明，没有的需要安装 "element-ui": "^2.13.0", // npm install --save element-ui "vue": "^2.5.2", // npm install --save vue "vue-router": "^3.0.1", // npm install --save vue-router "css-loader": "^0.28.11", // npm install --save-dev css-loader "file-loader": "^1.1.11", // npm install --save-dev file-loader "node-sass": "^4.11.0", // npm install --save-dev node-sass "sass-loader": "^7.1.0", // npm install --save-dev sass-loader "style-loader": "^1.0.1", // npm install --save-dev style-loader "url-loader": "^3.0.0" // npm url-loader --save-dev url-loader 二、【报错原因】 2.1、安装 sass 时，报错 ‘ This dependency was not found: element-ui/lib/theme-chalk/index.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/03b81721fc00f72bfb1ae8db7eeefa89/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3bdd9c7c30f2ec922fa0b512b2c085a4/" rel="bookmark">
			vue 鼠标移入移出事件（移入出现按钮），element-ui表格移入移出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		效果图：
注：@mouseenter="enter(index)" @mouseleave="leave()" 重点
&lt;div class="img_box"&gt; &lt;div v-for="(img,index) in photoData" class="demo-image__preview" @mouseenter="enter(index)" @mouseleave="leave()"&gt; &lt;el-image class="img" :src="img.compressUrl" :preview-src-list="getSrcList(index)" &gt; &lt;/el-image&gt; &lt;div v-if="seen&amp;&amp;index==current" class="btn_download"&gt; &lt;el-button &gt;下载&lt;/el-button&gt; &lt;el-button &gt;删除&lt;/el-button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; data() { return { seen:false, current:0 } }, //鼠标移入移出 enter(index){ this.seen = true; this.current = index; }, leave(){ this.seen = false; this.current = null; } element-ui表格el-table鼠标移入移出事件 效果：
可以先去官网查看文档说明：
鼠标移入该行元素就会出现按钮或者图标（自定义）。
&lt;el-table :height="tableHeight" size="mini" :data="tableData" @cell-mouse-leave="showClickIcon=false" @cell-mouse-enter="ncrFormat" style="width: 100%;background: #fff"border &gt; //这里的cell-mouse-leave鼠标移出，cell-mouse-enter鼠标移入 &lt;el-table-column prop="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3bdd9c7c30f2ec922fa0b512b2c085a4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/602761b0aafe255eb58658d6e31d6bab/" rel="bookmark">
			c&#43;&#43; 中的回调函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		看了 https://www.bilibili.com/video/av39240401?t=4023 以后记录了一下
//1 回调函数是一种讲双向依赖改为单向依赖的好方法 //2 常见回调函数：pthread //3 函数指针 //4 回调函数：回调函数是一种在定义的模块不运行，交给另一个模块运行的函数 //回调函数的应用：尤其在调用的对象是一个黑盒子，通常是别的公司打包好的某个库，你编程时想要改变库里的某些默认行为，这是用回调函数是最好的 //5 回调函数的适用条件： //模块之间互相独立，存在相互调用关系 //两个模块处在不同的层次，为了确保单向依赖（单项调用），通常在下层设置函数指针，在上层设置回调函数。 1 常见的回调函数 //常见的回调函数 #include &lt;iostream&gt; #include &lt;pthread.h&gt; #include &lt;unistd.h&gt; //回调函数 void* cb(void *arg) { std::cout&lt;&lt;"call back running"&lt;&lt;pthread_self()&lt;&lt;std::endl; return NULL; } int main() { pthread_t tid; pthread_create(&amp;tid, NULL, cb, NULL); //将cb 做参数传进去 pthread_join(tid, NULL); pthread_t tid2; pthread_create(&amp;tid2, NULL, cb, NULL); pthread_join(tid, NULL); } 2 函数指针 //函数指针 #include &lt;stdio.h&gt; void fun1(void) { printf("fun1\n"); } void fun2(void) { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/602761b0aafe255eb58658d6e31d6bab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/227c69b0da3742c49a6e2ab5b888f5f8/" rel="bookmark">
			Apache Impala 基本介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一 impala： 是cloudera提供的一款高效率的sql查询工具，提供实时的查询效果，官方测试性能比hive快10到100倍，其sql查询比sparkSQL还要更加快速，号称是当前大数据领域最快的查询sql工具 impala 是参照谷歌的新三篇论文（Caffeine--网络搜索引擎、Pregel--分布式图计算、Dremel--交互式分析工具）当中的Dremel实现而来，其中旧三篇论文分别是（BigTable，GFS，MapReduce）分别对应我们即将学的HBase和已经学过的HDFS以及MapReduce。
impala是基于hive并使用内存进行计算，兼顾数据仓库，具有实时，批处理，多并发等优点。
二 Impala 与 Hive 关系 impala 是基于 hive 的大数据分析查询引擎，直接使用hive的元数据库 metadata，意味着impala元数据都存储在hive的metastore当中，并且impala兼容hive的绝大多数sql语法。所以需要安装impala的话，必须先安装hive，保证hive安装成功，并且还需要启动hive的metastore服务。
Hive元数据包含用Hive创建的database、table等元信息。元数据存储在关系型数据库中，如Derby、MySQL等。
客户端连接metastore服务，metastore再去连接MySQL数据库来存取元数据。有了metastore服务，就可以有多个客户端同时连接，而且这些客户端不需要知道MySQL数据库的用户名和密码，只需要连接metastore 服务即可。
Hive适合于长时间的批处理查询分析，而 Impala适合于实时交互式SQL查询。可以先使用hive进行数据转换处理，之后使用Impala在Hive处理后的结果数据集上进行快速的数据分析。
三 Impala 与 Hive 异同 Impala 与Hive都是构建在Hadoop之上的数据查询工具各有不同的侧重适应面，但从客户端使用来看Impala与Hive有很多的共同之处，如数据表元数据、ODBC/JDBC驱动、SQL语法、灵活的文件格式、存储资源池等。
但是Impala跟Hive最大的优化区别在于：没有使用 MapReduce进行并行计算，虽然MapReduce是非常好的并行计算框架，但它更多的面向批处理模式，而不是面向交互式的SQL执行。与 MapReduce相比，Impala把整个查询分成一执行计划树，而不是一连串的MapReduce任务，在分发执行计划后，Impala使用拉式获取数据的方式获取结果，把结果数据组成按执行树流式传递汇集，减少的了把中间结果写入磁盘的步骤，再从磁盘读取数据的开销。Impala使用服务的方式避免每次执行查询都需要启动的开销，即相比Hive没了MapReduce启动时间。
​​​​​​​四 Impala使用的优化技术 使用LLVM产生运行代码，针对特定查询生成特定代码，同时使用Inline的方式减少函数调用的开销，加快执行效率。(C++特性)
充分利用可用的硬件指令（SSE4.2）。
更好的IO调度，Impala知道数据块所在的磁盘位置能够更好的利用多磁盘的优势，同时Impala支持直接数据块读取和本地代码计算checksum。
通过选择合适数据存储格式可以得到最好性能（Impala支持多种存储格式）。
最大使用内存，中间结果不写磁盘，及时通过网络以stream的方式传递。
​​​​​​​​​​​​​​五 执行 计划 Hive: 依赖于MapReduce执行框架，执行计划分成 map-&gt;shuffle-&gt;reduce-&gt;map-&gt;shuffle-&gt;reduce…的模型。如果一个Query会 被编译成多轮MapReduce，则会有更多的写中间结果。由于MapReduce执行框架本身的特点，过多的中间过程会增加整个Query的执行时间。
Impala: 把执行计划表现为一棵完整的执行计划树，可以更自然地分发执行计划到各个Impalad执行查询，而不用像Hive那样把它组合成管道型的 map-&gt;reduce模式，以此保证Impala有更好的并发性和避免不必要的中间sort与shuffle。
六 数据流 Hive: 采用推的方式，每一个计算节点计算完成后将数据主动推给后续节点。
Impala: 采用拉的方式，后续节点通过getNext主动向前面节点要数据，以此方式数据可以流式的返回给客户端，且只要有1条数据被处理完，就可以立即展现出来，而不用等到全部处理完成，更符合SQL交互式查询使用。
七 内存使用 Hive: 在执行过程中如果内存放不下所有数据，则会使用外存，以保证Query能顺序执行完。每一轮MapReduce结束，中间结果也会写入HDFS中，同样由于MapReduce执行架构的特性，shuffle过程也会有写本地磁盘的操作。
Impala: 在遇到内存放不下数据时，版本1.0.1是直接返回错误，而不会利用外存，以后版本应该会进行改进。这使用得Impala目前处理Query会受到一定的限制，最好还是与Hive配合使用。
八 调度 Hive: 任务调度依赖于Hadoop的调度策略。
Impala: 调度由自己完成，目前只有一种调度器simple-schedule，它会尽量满足数据的局部性，扫描数据的进程尽量靠近数据本身所在的物理机器。调度器 目前还比较简单，在SimpleScheduler::GetBackend中可以看到，现在还没有考虑负载，网络IO状况等因素进行调度。但目前 Impala已经有对执行过程的性能统计分析，应该以后版本会利用这些统计信息进行调度吧。
九 容错 Hive: 依赖于Hadoop的容错能力。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/227c69b0da3742c49a6e2ab5b888f5f8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28a24042427d69302ce79a5a670c12f9/" rel="bookmark">
			并发编程 (18)StampedLock：有没有比读写锁更快的锁？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们介绍了读写锁，学习完之后你应该已经知道“读写锁允许多个线程同时读共享变量，适用于读多写少的场景”。那在读多写少的场景中，还有没有更快的技术方案呢？还真有，Java 在 1.8 这个版本里，提供了一种叫 StampedLock 的锁，它的性能就比读写锁还要好。
下面我们就来介绍一下 StampedLock 的使用方法、内部工作原理以及在使用过程中需要注意的事项。
StampedLock 支持的三种锁模式 我们先来看看在使用上 StampedLock 和上一篇文章讲的 ReadWriteLock 有哪些区别。
ReadWriteLock 支持两种模式：一种是读锁，一种是写锁。而 StampedLock 支持三种模式，分别是：写锁、悲观读锁和乐观读。其中，写锁、悲观读锁的语义和 ReadWriteLock 的写锁、读锁的语义非常类似，允许多个线程同时获取悲观读锁，但是只允许一个线程获取写锁，写锁和悲观读锁是互斥的。不同的是：StampedLock 里的写锁和悲观读锁加锁成功之后，都会返回一个 stamp；然后解锁的时候，需要传入这个 stamp。相关的示例代码如下。
final StampedLock sl = new StampedLock(); // 获取 / 释放悲观读锁示意代码 long stamp = sl.readLock(); try { // 省略业务相关代码 } finally { sl.unlockRead(stamp); } // 获取 / 释放写锁示意代码 long stamp = sl.writeLock(); try { // 省略业务相关代码 } finally { sl.unlockWrite(stamp); } StampedLock 的性能之所以比 ReadWriteLock 还要好，其关键是 StampedLock 支持乐观读的方式。ReadWriteLock 支持多个线程同时读，但是当多个线程同时读的时候，所有的写操作会被阻塞；而 StampedLock 提供的乐观读，是允许一个线程获取写锁的，也就是说不是所有的写操作都被阻塞。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/28a24042427d69302ce79a5a670c12f9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13be9217884c8ef17e092b9e9cba3a11/" rel="bookmark">
			Vue.js工程项目中文件/文件夹命名规范
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 访问官方Vue 特有代码的风格指南https://cn.vuejs.org/v2/style-guide/
文件或文件夹命名遵循以下原则：
①index.js 或者 index.vue，统一使用小写字母开头的(kebab-case)命名规范；
②属于组件或类的，统一使用大写字母开头的(PascalCase)命名规范；
③其他非组件或类的，统一使用小写字母开头的(kebab-case)命名规范；
命名方式一：源码文件夹src下的文件夹统一使用小写字母命名；
── src/ ├── api ├── views ├── common ├── components/ │ └── ... └── assets/ └── ... 命名方式二：全局公共组件src/components下的文件夹统一使用大写字母开头的（PascalCase）命名，其中，文件夹下除index.vue&amp;index.js外，其他的.vue文件均统一使用大写字母开头的（PascalCase）命名；
└── components/ ├── Footer/ └── index.vue └── index.js └── Footer.vue 命名方式三：其他业务页面组件src/views下的文件夹统一使用大写字母开头的（PascalCase）命名，其中，文件夹下除index.vue&amp;index.js外，其他的.vue文件均统一使用大写字母开头的（PascalCase）命名；
└── views/ ├── Home/ └── index.vue └── index.js └── Home.vue 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2bb57922a3a3b0577b2b1962bf0d1ff/" rel="bookmark">
			MySql安装错误：mysqld: Can&#39;t create directory
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		错误为无法创建目录
解决方法：
一：查看my.ini路径是否正确：
在设置数据的存放目录时，不需要单独添加Data文件夹，在写入路径的时候可以直接建立
二：查看安装路径是否存在中文：
路径正确，依旧报错，查看路径中是否含有中文，如果有中文在dos界面可以发现路径中的中文字为乱码，保证路径为英文即可。
三：地址斜杆使用错误：
这个是在查询此错误的时候其他博主写的，下方为他的连接：其他博主解决方法链接，点击即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0bc0eac95b10a3eaec2e0b253fe42f1e/" rel="bookmark">
			三极管的上拉下拉电阻的选取
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		输出端的接电源或接地的电阻叫上拉、下拉电阻，而基极电阻不叫这个名称，应该叫基极偏置电路分压电阻。
根据基极所需的偏置电压以及电源电压大小，用电阻分压公式计算Ub=Vcc*R2/（R1+R2），电阻值的大小应该在kΩ~十kΩ数量级，保证电阻上的电流比基极电流大一个数量级。
例如基极偏压需要2V，电源电压6V，取下偏置电阻10kΩ，可以算出上偏置电阻为20kΩ。
为了简便叙述，以下统一为上下拉电阻
简单概括为：电源到器件引脚上的电阻叫上拉电阻，作用是平时使该引脚为高电平，地到器件引脚上的电阻叫下拉电阻，作用是平时使该引脚为低电平。低电平在IC内部与GND相连接；高电平在IC内部与超大电阻相连接。上拉就是将不确定的信号通过一个电阻钳位在高电平，电阻同时起限流作用，下拉同理。对于非集电极（或漏极）开路输出型电路（如普通门电路，其提升电流和电压的能力是有限的，上拉和下拉电阻的主要功能是为集电极开路输出型电路提供输出电流通道。
上拉是对器件注入电流，下拉是输出电流；强弱只是上拉或下拉电阻的阻值不同，没有什么严格区分。当IC的I/O端口，节点为高电平时，节点处和GND之间的阻抗很大，可以理解为无穷大，这个时候通过上拉电阻（如4.7K欧，10K欧电阻）接到VCC上，上拉电阻的分压几乎可以忽略不计；
当I/O端口节点需要为低电平时，直接接GND就可以了，这个时候VCC与GND是通过刚才的上拉电阻（如4.7K欧，10K欧电阻）连接的，通过的电流很小，可以忽略不计。
如果单纯的想要使这个节点成为高电平，并且输出阻抗非常大，则直接接电源也无妨，但是如果单片机要使这个节点拉低，即单片机内部使节点接地，这样5V电源和地之间就短路了。
另外，当要求这个节点为高电平时，这个节点和地之间的阻抗一般非常大，如100K欧的阻抗，当上拉一个10K欧的电阻，这个点分得的电压为100K欧/（100K 10K）*5V=4.5V，这样也可以拉到高电平。
而当要求这个节点为低电平时，只要把它和地连接就可以了，电源和地之间有一个10K偶的电阻，这样就不会短路了。
当低电平时，电源和地之间有一个负载形成的回路，有时候这个节点会再串接一个电阻，因为电流流向阻抗低的地方，所以电流会通过与电源相连的电阻流向地，而不是流向这个与节点相连的电阻，因为这个节点连接的电阻阻抗高，所以低电平时这个点的电势就是低电平。
可以这么认为，对于IC的I/O端口来说，IC内部通过控制高低电平相当于控制这个O/O口与其内部的GND或非常大的电阻相连，如100K欧，当I/O口为低电平0V时，在IC内部，是控制IC芯片O/O口的引脚在芯片内与GND连接。
当I/O口为高电平时，如5V，这个时候I/O口引脚在芯片内是与非常大的电阻，如100K欧相连接的，有时在I/O节点处会再串接一个小电阻值的电阻，如68欧，因为电流流向阻抗低的地方，所以当芯片内部的I/O端口欧与GND相连为低电平时，电源与上拉电阻及芯片内部的GND形成环路进行流通。
这时I/O口节点处的电流就会流向芯片内部的GND，因为节点处串接了一个小阻值的电阻，相对于GND来说是高阻，就是大一点点也是高阻，所以电流就不会流过这个串联的电阻。
当用下拉电阻时（所谓的上拉和下拉都是针对高阻态而言的），当I/O口为高阻态时，通过上拉电阻能够让其保持在高电平状态；
具体如上文所述：当I/O端口为高阻态时，用下拉电阻把这个口与GND相连接，高阻态电阻值很大，可以理解为断开，其实就是和芯片内部的阻值很大的电阻相连接，下拉的时候拉到地上了，没有电流，电平值为0，除非是给这个引脚赋予一个高电平值它才能够起作用。
上拉和下拉电阻的作用概括如下：
1、提高电压准位当TTL电路驱动CMOS电路时，如果TTL电路输出的高电平低于CMOS电路的最低高电平，这时就需要在TTL的输出端接上拉电阻，以提高输出高电平的值；OC门电路必须加上拉电阻，以提高输出的高电平值。2、加大输出引脚的驱动能力有的单片机引脚上也常使用上拉电阻。3、N/A引脚（没有连接的引脚）防静电、防干扰；在CMOS芯片上，为了防止静电造成损坏，不用的引脚不能悬空，一般接上拉电阻降低输入阻抗，提供泄荷通路。同时引脚悬空就比较容易接收外界的电磁干扰。4、电阻匹配抑制反射波干扰，长线传输中电阻不匹配容易引起反射波干扰，加上下拉电阻使电阻匹配，能有效的抑制反射波干扰。5、预设空间状态/默认电位在一些CMOS输入端接上拉或下拉电阻是为了预设默认电位。当不用这些引脚时，这些输入端下拉接低电平或上拉接高电平。在I2C等总线上空闲时的状态是由上下拉电阻获得的。6、提高芯片输入信号的噪声容限输入端如果是高阻状态，或高阻抗输入端处于悬空状态，此时需要加上拉或下拉电阻，以免受到随机电平的影响，进而影响电路工作。同样，如果输出端处于被动状态，需要加上拉或下拉电阻，如输出端仅仅是一个三极管的集电极，从而提高芯片输入信号的噪声容限，增强抗干扰能力。在BJT晶体三极管的基极端，上拉电阻和下拉电阻也起着至关重要的作用。在三极管的电路应用中，串接在基极上的电阻起限制基级电流的作用，如下图中的R2所示，
如下图中的R5所示，上拉电阻使三极管基极的输入电平在默认情况下是高电平输入，当CPU有低电平信号输出时，外围电路响应，下拉电阻使晶体管的基极输入在默认情况下拉到低电平，如下图中的R6所示。
上拉下拉电阻选取
1、当TTL电路驱动COMS电路时，如果TTL电路输出的高电平低于COMS电路的最低高电平（一般为3.5V），这时就需要在TTL的输出端接上拉电阻，以提高输出高电平的值。
2、OC门电路必须加上拉电阻，才能使用。像比较器这类型，必须要都是要OC输出，就要加上拉电阻。
3、为加大输出引脚的驱动能力，有的单片机管脚上也常使用上拉电阻。
4、在COMS芯片上，为了防止静电造成损坏，不用的管脚不能悬空，一般接上拉电阻产生降低输入阻抗，提供泄荷通路。
5、芯片的管脚加上拉电阻来提高输出电平，从而提高芯片输入信号的噪声容限增强抗干扰能力。
6、提高总线的抗电磁干扰能力。管脚悬空就比较容易接受外界的电磁干扰。
7、长线传输中电阻不匹配容易引起反射波干扰，加上下拉电阻是电阻匹配，有效的抑制反射波干扰。
上拉电阻阻值的选择原则包括:
1、从节约功耗及芯片的灌电流能力考虑应当足够大；电阻大，电流小。
2、从确保足够的驱动电流考虑应当足够小；电阻小，电流大。
3、对于高速电路，过大的上拉电阻可能边沿变平缓。综合考虑
以上三点,通常在1k到10k之间选取。对下拉电阻也有类似道理
对上拉电阻和下拉电阻的选择应结合开关管特性和下级电路的输入特性进行设定，主要需要考虑以下几个因素：
1． MOS管和三极管驱动能力与功耗的平衡。以上拉电阻为例，一般地说，上拉电阻越小，驱动能力越强，但功耗越大，设计是应注意两者之间的均衡。
2．MOS管和三极管下级电路的驱动需求。同样以上拉电阻为例，当输出高电平时，开关管断开，上拉电阻应适当选择以能够向下级电路提供足够的电流。
3． 高低电平的设定。不同电路的高低电平的门槛电平会有不同，电阻应适当设定以确保能输出正确的电平。以上拉电阻为例，当输出低电平时，开关管导通，上拉电阻和开关管导通电阻分压值应确保在零电平门槛之下。
4． 频率特性。以上拉电阻为例，上拉电阻和开关管漏源级之间的电容和下级电路之间的输入电容会形成RC延迟，电阻越大，延迟越大。上拉电阻的设定应考虑电路在这方面的需求。
下拉电阻的设定的原则和上拉电阻是一样的。
OC门输出高电平时是一个高阻态，其上拉电流要由上拉电阻来提供，设输入端每端口不大于100uA,设输出口驱动电流约500uA，标准工作电压是5V，输入口的高低电平门限为0.8V(低于此值为低电平)；2V(高电平门限值)。
选上拉电阻时：
500uA x 8.4K= 4.2即选大于8.4K时输出端能下拉至0.8V以下，此为最小阻值，再小就拉不下来了。如果输出口驱动电流较大，则阻值可减小，保证下拉时能低于0.8V即可。
当输出高电平时，忽略管子的漏电流，两输入口需200uA
200uA x15K=3V即上拉电阻压降为3V，输出口可达到2V，此阻值为最大阻值，再大就拉不到2V了。选10K可用。
设计时管子的漏电流不可忽略，IO口实际电流在不同电平下也是不同的，上述仅仅是原理，一句话概括为：输出高电平时要喂饱后面的输入口，输出低电平不要把输出口喂撑了（否则多余的电流喂给了级联的输入口，高于低电平门限值就不可靠了）
总结：，上拉在1k到10k之间选取。 MOS管下拉一般选择10K~20K，三极管下拉用1K~2K！
另外：
1)防止三极管受噪声信号的影响而产生误动作，使晶体管截止更可靠!三极管的基极不能出现悬空，当输入信号不确定时(如输入信号为高阻态时)，加下拉电阻，就能使有效接地。
特别是GPIO连接此基极的时候，一般在GPIO所在IC刚刚上电初始化的时候，此GPIO的内部也处于一种上电状态，很不稳定，容易产生噪声，引起误动作!加此电阻，可消除此影响(如果出现一尖脉冲电平，由于时间比较短，所以这个电压很容易被电阻拉低;如果高电平的时间比较长，那就不能拉低了，也就是正常高电平时没有影响)!但是电阻不能过小，影响泄漏电流!(过小则会有较大的电流由电阻流入地)
2)当三极管开关作用时,ON和OFF时间越短越好,为了防止在OFF时,因晶体管中的残留电荷引起的时间滞后,在B,E之间加一个R起到放电作用。高频，深饱和时特别要注意。(次要)
3 )三极管基级加电阻主要是为了设置一个偏置电压，这样就不会出现信号的失真(这在输入信号有交流时极其重要：如当温度上升时，Ic将增大，导致Ie也会增大，那么在Re上的压降也增大，而Vbe=Vb-IeRe，而Vb此时基本上被下拉电阻保持住，所以使Vbe减小。当然这个减小对0.7v来说是很小的，是从微观上去分析的。Vbe的减小，使Ib减小，结果牵制了Ic的增加，从而使Ic基本恒定。这也是反馈控制的原理)。
而且同时还是为了防止输入电流过大，加个电阻可以分一部分电流，这样就不会让大电流直接流入三极管而损坏其.至于为了放电，一般是在MOS管中才用，三极管这个问题不大
4)如果三极管不接下拉电阻，就不能设定偏置电压，这样会产生输入信号的交越失真，并且输入电流过大的时候会导致大电流直接流入三极管而导致损坏。
接下拉电阻不宜过大，不然会影响流入基极的电流过小
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1340440d9a46fe0311aec02789533640/" rel="bookmark">
			计算机等级《二级JAVA》预测试卷（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		计算机等级《二级JAVA》预测试卷（一） 一、单项选择题(共40题，合计40分) 1下列运算结果为l的是（　）。
A. 8&gt;&gt;1
B. 4&gt;&gt;&gt;2
C. 8&lt;&lt;1
D. 4&lt;&lt;&lt;2
[正确答案]B
试题解析:
符号&gt;&gt;是按位右移运算符，&lt;&lt;是按位左移运算符，&gt;&gt;&gt;是添零右移运算符，没有&lt;&lt;&lt;运算符。
2软件生命周期是指（　）。
A. 软件产品从提出、实现、使用维护到停止使用退役的过程
B. 软件从需求分析、设计、实现到测试完成的过程
C. 软件的开发过程
D. 软件的运行维护过程
[正确答案]A
试题解析:
软件生命周期(SDLC，Systems Development Life Cycle)是软件的产生直到退役的生命周期，周期内有问题定义、可行性分析、总体描述、系统设计、编码、调试和测试、验收与运行、维护升级到废弃等阶段。
3在电子邮件程序向邮件服务器中发送邮件时，使用的是简单邮件传输协议，下列（　）是简单邮件传输协议。
A. POP3
B. IMAP
C. HTTP
D. SMTP
[正确答案]D
试题解析:
在电子邮件程序向邮件服务器中发送邮件时，使用的是简单邮件传输协议(SMTP)，而在电子邮件程序从邮件服务器中读取邮件时，可以使用邮局协议(POP3)。
4下列代表十六进制整数的是（　）。
A. 0XA6
B. 1234L
C. -840
D. 0144
[正确答案]A
试题解析:
本题考查Java语言中的整型常量。整型常量有3种书写格式：十进制整数、八进制整数和十六进制整数。十六进制整数以0x或0X开头，如0X123表示十进
制数291。选项A表示的是十六进制整数，选项B是long类型整型常量，选项C是十进制整数，选项D是八进制整数，因此选项A为本题正确选项。
5Java语言中。负责并发管理的机制是（　）。
A. 垃圾回收
B. 虚拟机
C. 代码安全
D. 多线程
[正确答案]D
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1340440d9a46fe0311aec02789533640/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39809bb2bd92ca4ebcdb4d0bb745a188/" rel="bookmark">
			SpringMVC教程（五）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ModelAndView 设置ModelAndView对象 , 根据view的名称 , 和视图解析器跳到指定的页面 .
页面 : {视图解析器前缀} + viewName +{视图解析器后缀}
&lt;!-- 视图解析器 --&gt; &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver" id="internalResourceViewResolver"&gt; &lt;!-- 前缀 --&gt; &lt;property name="prefix" value="/WEB-INF/jsp/" /&gt; &lt;!-- 后缀 --&gt; &lt;property name="suffix" value=".jsp" /&gt; &lt;/bean&gt; 对应的controller类
public class ControllerTest1 implements Controller { public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception { //返回一个模型视图对象 ModelAndView mv = new ModelAndView(); mv.addObject("msg","ControllerTest1"); mv.setViewName("test"); return mv; } } ServletAPI 通过设置ServletAPI , 不需要视图解析器 .
通过HttpServletResponse进行输出通过HttpServletResponse实现重定向通过HttpServletResponse实现转发 @Controller public class ResultGo { @RequestMapping("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/39809bb2bd92ca4ebcdb4d0bb745a188/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7f2c4dce2bdf8ce6de9ae6085b4e944/" rel="bookmark">
			python&amp;Keras实现多GPU或指定GPU的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载，自己好方便查看
1. keras新版本中加入多GPU并行使用的函数 下面程序段即可实现一个或多个GPU加速：
注意：使用多GPU加速时，Keras版本必须是Keras2.0.9以上版本
from keras.utils.training_utils import multi_gpu_model #导入keras多GPU函数 import VGG19 #导入已经写好的函数模型，例如VGG19 if G &lt;= 1: print("[INFO] training with 1 GPU...") model = VGG19（） # otherwise, we are compiling using multiple GPUs else: print("[INFO] training with {} GPUs...".format(G)) # we'll store a copy of the model on *every* GPU and then combine # the results from the gradient updates on the CPU with tf.device("/cpu:0"): # initialize the model model1 = VGG19（） # make the model parallel(if you have more than 2 GPU) model = multi_gpu_model(model1, gpus=G) 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e7f2c4dce2bdf8ce6de9ae6085b4e944/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28bb9eb1e5276205d11e3cb12f650712/" rel="bookmark">
			typescript编译选项esModuleInterop的作用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		esModuleInterop选项的作用是支持使用import d from 'cjs'的方式引入commonjs包。
引入commonjs模块的方式 无类型声明文件 如果一个模块没有类型声明，可以直接使用const cjs = require('cjs')的方式引入模块，此时cjs的类型是any
有类型声明文件 1.使用import cjs = require('cjs')方法引入
2.使用import * as cjs from 'cjs'方法引入，此时cjs相当于exports变量（虽然这能够正常工作，但其实不符合es模块规范，es模块规范规定cjs这个命名空间只能是一个纯对象，但是不能够直接调用，以koa举例）
import * as Koa from 'koa'; // 不符合规范 const app = new Koa(); // 编译后的结果 const Koa = require("koa"); const app = new Koa(); 那怎么才能使用import cjs from 'cjs'语法呢？
首先你需要去除类型检查(允许从没有设置默认导出的模块中默认导入)，这可以使用allowSyntheticDefaultImports配置项帮你达到。
其次你的导出需要有default属性，因为allowSyntheticDefaultImports只是帮你去掉类型检查，但是并不会影响编译后的代码输出，假设没有default属性，虽然可以正常编译，但是在运行时还是会报错的，这就需要esModuleInterop配置帮你完成了，因为对于大对数模块而言，并没有default属性。
esModuleInterop配置提供的帮助 提供两个helper函数__importStar和__importDefault分别处理import * as和import default。
例如对于下面的代码：
import * as foo from "foo"; import b from "bar"; 编译后的结果：
"use strict"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/28bb9eb1e5276205d11e3cb12f650712/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e7d108df8227b0c8f2525081e43fcd4/" rel="bookmark">
			sqlmap使用详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		sqlmap.py -u(指定url) “(写要注入的url)” 回车判断注入
sqlmap.py -u(指定url) “(写要注入的url)” --dbs（爆破数据库名）
sqlmap.py -u(指定url) “(写要注入的url)” --tables(爆破表明) -D （指定爆破的数据库） --count指定每个表里有多少行数据
sqlmap.py -u(指定url) “(写要注入的url)” --columns -T -admin -(指定爆破表的列)
sqlmap.py -u(指定url) “(写要注入的url)” --dump列数据 --T admin -C(指定列名查询列名下的数据) admin,password
sqlmap.py -u(指定url) “(写要注入的url)” 回车判断注入 --from(自动获取表单)
sqlmap.py -u(指定url) “(写要注入的url)” 回车判断注入 --data"(指定提交参数)"
基本参数：
sqlmap.py -h 查看帮助选项
is-dba 当前用户权限
dbs 所有数据库
current-db 网站当前数据库
users 所有数据库用户
current-user 当前数据库用户
tables 参数：列表明
columns 参数：列字段
dump 参数：下载数据
–dump 获取表中的数据，包含列
–dump-all 转存DBMS数据库所有表项目
–level 测试等级（1-5）默认为1
读取数据库–&gt;读取表–&gt;读取表的列–&gt;获取内容
-D 指定数据库
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1e7d108df8227b0c8f2525081e43fcd4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/168e3ae0f2754ad1e58016dc05b25dc2/" rel="bookmark">
			简单高效删除数组成员(非稳定性)的代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目的：实现一个高效代码实现简单的删除数组中的需要删除的成员的功能代码
代码如下所示：
/* tom 2019-12-06 PM 21:50 */ #include &lt;stdio.h&gt; typedef int BOOL; #define TRUE (1) #define FALSE (0) typedef struct tagNode { BOOL bToDelete; int iValue; tagNode(const BOOL bToDelete, const int iValue) { this-&gt;bToDelete = bToDelete; this-&gt;iValue	= iValue; } }NODE_ST; int main() { NODE_ST astNode[5] = { NODE_ST(FALSE, 1),	NODE_ST(TRUE, 2),	/* need to delete */ NODE_ST(FALSE, 3), NODE_ST(TRUE, 4),	/* need to delete */ NODE_ST(FALSE, 5)}; int iNodeNum = sizeof(astNode) / sizeof(NODE_ST); NODE_ST* const pstNodeBgn = astNode; NODE_ST* pstNodeEnd = astNode + sizeof(astNode) / sizeof(NODE_ST); NODE_ST* pstNode = NULL; /* 打印原始数组 */ printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/168e3ae0f2754ad1e58016dc05b25dc2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e141324f83bfffed486044d8f9a1f682/" rel="bookmark">
			drf 配置的步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 drf 配置的步骤 安装第三方库 pip install djangorestframework, markdown , django-filter 在 settings.py启用 django-rest-framework INSTALLED_APPS = [ .... 'rest_framework', ] 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aafa4cace73a3f9f8071f1baca80ba3b/" rel="bookmark">
			bootstrap前台富文本框的书写。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先砍一下效果图：
页面红色框处即为富文本框的一些格式化调整。
此处只贴富文本框处的代码：
&lt;div class="form-group"&gt; &lt;label class="col-sm-1 control-label" for="content"&gt;内容：&lt;/label&gt; &lt;div class="h-200" style="padding:0 30px;" &gt; &lt;textarea class="col-sm-5" id="content" name="content" style="height:210px;width:100%;"&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;/div&gt; $(function(){ //创建富文本编辑器 var editorBox = UE.getEditor('content', { toolbars : [ [ 'source', '|', 'undo', 'redo', '|', 'bold', 'italic', 'underline', 'fontborder', 'strikethrough', 'removeformat', 'autotypeset','blockquote', 'pasteplain', '|', 'forecolor', 'backcolor', 'insertorderedlist', 'insertunorderedlist','insertimage', 'emotion', 'map', '|', 'selectall', 'cleardoc', 'indent', '|', 'justifyleft', 'justifycenter', 'justifyright','justifyjustify', '|', 'link', 'unlink', '|', 'imagenone', 'imageleft', 'imageright', 'imagecenter', 'wordimage' ] ], wordCount : false, elementPathEnabled : false }); }） 其中toolbars中写的属性都是对应word中的文本格式化样式。譬如：'undo', 'redo'分别代表的是撤销和回滚。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aafa4cace73a3f9f8071f1baca80ba3b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37275d1e0aa97ec73c8a9b823d107204/" rel="bookmark">
			1154. Day of the Year
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下午有点感冒，挑了个简单的题刷来打发时间，然后被大神教做人
题目： Given a string date representing a Gregorian calendar date formatted as YYYY-MM-DD, return the day number of the year.
Example 1:
Input: date = "2019-01-09" Output: 9 Explanation: Given date is the 9th day of the year in 2019. Example 2:
Input: date = "2019-02-10" Output: 41 Example 3:
Input: date = "2003-03-01" Output: 60 Example 4:
Input: date = "2004-03-01" Output: 61 Constraints:
date.length == 10date[4] == date[7] == '-', and all other date[i]'s are digitsdate represents a calendar date between Jan 1st, 1900 and Dec 31, 2019.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/37275d1e0aa97ec73c8a9b823d107204/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/706d568c8f999f39f77373b6886adcb0/" rel="bookmark">
			查找算法2——折半查找
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		从小到大排列的有序序列。折半查找的算法描述如下：
将待查找元素与表中间的元素进行比较，如果两者相等，则说明查找成功；否则利用中间位置将表分成两部分，如果待查找元素小于中间位置的元素值，则继续与前一个子表的中间位置元素记性比较；否则与后一个子表的中间位置元素进行比较。不断重复上述操作，直到找到与待查找元素相等的元素，表明查找成功。如果子表为空表，表明查找失败。
【示例】
一个有序顺序表为7，15，22，29，41，55，67，78，81，99，如果要查找的元素为67。利用折半查找算法思想，过程如下。
其中low，high，表示两个指针，分别指向待查找元素的下界和上界，指针mid指向low和high的中间位置，即mid=(low+high)/2。
初始时，low=0,high=9,mig=(0+9)/2=4,因为list[mid]&lt;x，座椅需要在右半区继续寻找。此时low=5,high=9,mid=(5+9)/2=7,因为list[mid]&gt;x，所以需要在左半区继续查找x。此时有low=5,high=6,mid=5，因为list[mid]&lt;x，所以需要在右半区继续找，此时有low=6,high=6,mid=6，list[mid]=x，查找成功。
#include&lt;stdio.h&gt; #include&lt;iostream&gt; #define MaxSize 100 using namespace std; typedef struct { int list[MaxSize]; int length; }Table; int BinarySearch(Table S, int x); void main() { Table T = { { 12,24,36,48,60,72,84,96 },8 }; int i, find, x; printf("有序顺序表中的元素:\n"); for (i = 0; i&lt;T.length; i++) printf("%4d", T.list[i]); printf("\n请输入要查找的元素:"); scanf("%d", &amp;x); find = BinarySearch(T, x); if (find) printf("元素%d是顺序表中的第%d个元素.\n", x, find); else printf("没有找到该元素.\n"); system("pause"); } int BinarySearch(Table S, int x) /*在有序顺序表中折半查找元素x*/ { int low, high, mid; low = 0, high = S.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/706d568c8f999f39f77373b6886adcb0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a5ddfc674af13cd563b4cda656300f8/" rel="bookmark">
			No mapping found for HTTP request with URI [/swagger-ui.html]
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天在使用swagger-ui的是出现一个比较坑的问题，当访问swagger-ui.html的时候会出现
No mapping found for HTTP request with URI [/swagger-ui.html]
解决方法 一、在某个配置类上去掉@EnableWebMvc
二、如果要用@EnableWebMvc，则需要加上如下配置类。
@Configuration @EnableWebMvc public class WebMvcConfigurerConfig implements WebMvcConfigurer { private CorsConfiguration buildConfig() { CorsConfiguration corsConfiguration = new CorsConfiguration(); corsConfiguration.addAllowedOrigin("*"); corsConfiguration.setAllowCredentials(true); corsConfiguration.addAllowedHeader("*"); corsConfiguration.addAllowedMethod("*"); return corsConfiguration; } @Bean public CorsFilter corsFilter() { UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource(); source.registerCorsConfiguration("/**", buildConfig()); return new CorsFilter(source); } @Override public void addResourceHandlers(ResourceHandlerRegistry registry) { registry.addResourceHandler("swagger-ui.html") .addResourceLocations("classpath:/META-INF/resources/"); registry.addResourceHandler("/webjars/**") .addResourceLocations("classpath:/META-INF/resources/webjars/"); } } 深究一下原因
在Spring Boot中使用@EnableWebMvc可能遇到的问题，@EnableWebMvc是使用注解方式快捷配置Spring Webmvc的一个注解。在使用时你可能会遇到以下问题：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1a5ddfc674af13cd563b4cda656300f8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48d72e49b9a9a175496d3518d8ec4c6e/" rel="bookmark">
			C&#43;&#43;程序执行完毕窗口闪退多种解决方法推荐
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 C++程序执行完毕窗口闪退多种解决方法推荐 推荐第一种方法 方法1 个人最推荐此方法，简洁，美观，可跨平台使用。
1.添加头文件
#include&lt;conio.h&gt; 2.在程序末尾添加
cout&lt;&lt;"按任意键继续……"; _getch(); 方法2 此方法可跨平台，但麻烦，不美观，且按下的键会显示出来，需要回车。
1.添加头文件
#include&lt;stdlib.h&gt; 或
#include&lt;cstdlib&gt; 2.在程序末尾添加
cout&lt;&lt;"按任意键继续……"; cin.clear(); cin.sync(); cin.get(); 方法3 方法三方便但只适用于Windows系统，不能跨平台且占用系统资源。
在程序末尾添加
system("pause"); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed847408f7d3d43624dd01a838eef9ae/" rel="bookmark">
			Promise的用法及如何解决回调地狱
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		主要谈及： 是什么，怎么做，如何实现 一、setTimeout函数依次执行的传统方法 function fn1(){ setTimeout(()=&gt;{ console.log('fn1') },1000) } function fn2(){ setTimeout(()=&gt;{ console.log('fn2') },1000) } function fn3(){ setTimeout(()=&gt;{ console.log('fn3') },1000) } 二、实现异步函数的顺序执行 对上面的代码进行封装，形成一种回调地狱
&lt;script&gt; function fn1(callback){ setTimeout(()=&gt;{ console.log('fn1') callback() },1000) } function fn2(callback){ setTimeout(()=&gt;{ console.log('fn2') callback() },1000) } function fn3(callback){ setTimeout(()=&gt;{ console.log('fn3') },1000) } fn1(function(){ fn2(function(){ fn3() }) }) &lt;/script&gt; 分别在每一秒后执行fn1、fn2、fn3
注：可直接采用return出一个new的函数，减少代码量
function fn1(){ return new Promise((resolve,reject)=&gt;{ setTimeout(()=&gt;{ console.log('fn1...') resolve() },1000) }) } function fn2(){ return new Promise((resolve,reject)=&gt;{ setTimeout(()=&gt;{ console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ed847408f7d3d43624dd01a838eef9ae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a09aa5ef895e29b86d2e2e60c850add/" rel="bookmark">
			SpringMvc ModelAndView 视图解析器和Servlet详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一：设置ModelAndView对象，根据View的名称，和视图解析器跳转到指定的页面。
页面：视图解析器的前缀+view name +视图解析器的后缀
&lt;!-- 配置视图渲染器 --&gt; &lt;bean id="jspViewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="viewClass" value="org.springframework.web.servlet.view.JstlView"/&gt; &lt;!-- 将视图名 渲染后视图的前缀 --&gt; &lt;property name="prefix" value="/WEB-INF/jsp/"/&gt; &lt;!-- 渲染后视图的后缀 --&gt; &lt;property name="suffix" value=".jsp"/&gt; &lt;/bean&gt; @RequestMapping(value="/hello.do") public ModelAndView hello(){ ModelAndView mv = new ModelAndView(); mv.setViewName("hello"); mv.addObject("msg", "annotation ------"); return mv; } 二：通过ServletAPI对象来实现。不需要视图解析器的配置
通过HttpServletResponse输入内容。
通过HttpServletResponse实现重定向,转发。
public void hello(HttpServletRequest req,HttpServletResponse resp) throws ServletException, IOException{ //内容输出 resp.getWriter().println("hello springmvc"); //重定向 resp.sendRedirect("/jsp/hello.jsp"); //转发 req.getRequestDispatcher("index.jsp").forward(req,resp); } 三：通过springmvc实现重定向和转发（未配置视图解析器）
@RequestMapping("/hello1.do") public String hello1(ModelMap map){ //转发 return "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9a09aa5ef895e29b86d2e2e60c850add/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a0d9540ca83e05b7c4e7463b5e74ddf/" rel="bookmark">
			spark改写 心血管疾病预测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python版传送门：https://www.kesci.com/home/project/5da974e9c83fb400420f77d3
package dataclear /** * @CreateUser: eshter * @CreateDate: 2019/10/23 * @UpdateUser: */ import utils.session.IgnoreErrorAndINFO import org.apache.spark.sql.{DataFrame, SparkSession} import org.apache.spark.ml.classification.{LogisticRegression} import org.apache.spark.ml.feature.{StandardScaler, VectorAssembler, _} import utils.metrics.Metrics import org.apache.spark.ml.Pipeline object cardioTrainLr { /* 注意： 1、label =cardio 2、StandardScaler 只支持输入向量（org.spark.ml.linalg.Vector）的数据 3、数据的连续型变量为Array( "age" ,"height" ,"weight" ,"ap_hi" ,"ap_lo" ) 4、数据的离散型变量为 Array( "gender" ,"cholesterol" ,"gluc" ,"smoke" ,"alco" ) */ new IgnoreErrorAndINFO().ignoreErrorAndInfo() def splitData(df:DataFrame,splitRate:Double)={ val dfTmp = df.randomSplit(Array(splitRate,1-splitRate),seed=2) List(dfTmp(0),dfTmp(1)) } def featureHandleTest(dfTrain:DataFrame,dfValid:DataFrame,featureCols:Array[String])={ val scale_col=Array( "age" ,"height" ,"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0a0d9540ca83e05b7c4e7463b5e74ddf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07769d7fc8d237cf757a68726dac095a/" rel="bookmark">
			Cesium加载3dtiles  ，出现An error occurred while rendering. Rendering has stopped.RuntimeError: Unsupport
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		RuntimeError: Unsupported glTF Extension: KHR_technique_webgl
这是因为gltf1.0升级到gltf2.0后不支持自定义shader
var fixGltf = function(gltf) {
if (!gltf.extensionsUsed) {
return;
}
var v = gltf.extensionsUsed.indexOf('KHR_technique_webgl');
var t = gltf.extensionsRequired.indexOf('KHR_technique_webgl');
// 中招了。。
if (v !== -1) {
gltf.extensionsRequired.splice(t, 1, 'KHR_techniques_webgl');
gltf.extensionsUsed.splice(v, 1, 'KHR_techniques_webgl');
gltf.extensions = gltf.extensions || {};
gltf.extensions['KHR_techniques_webgl'] = {};
gltf.extensions['KHR_techniques_webgl'].programs = gltf.programs;
gltf.extensions['KHR_techniques_webgl'].shaders = gltf.shaders;
gltf.extensions['KHR_techniques_webgl'].techniques = gltf.techniques;
var techniques = gltf.extensions['KHR_techniques_webgl'].techniques;
gltf.materials.forEach(function (mat, index) {
gltf.materials[index].extensions['KHR_technique_webgl'].values = gltf.materials[index].values;
gltf.materials[index].extensions['KHR_techniques_webgl'] = gltf.materials[index].extensions['KHR_technique_webgl'];
var vtxfMaterialExtension = gltf.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/07769d7fc8d237cf757a68726dac095a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55f0cb7840cf6793a23f87bd60aa9100/" rel="bookmark">
			notebook打不开
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在cmd输入jupyter notebook之后，浏览器打开但不显示，用了很多方法
https://blog.csdn.net/weixin_41813895/article/details/81739502
但还是不管用，想着会不会是浏览器的问题
于是想着换个浏览器试一下，因为默认浏览器是猎豹，而当换了浏览器之后，需要输入密码
但是又不知道密码是什么
于是想着将改一下默认浏览器
再打开要修改的默认浏览器，工具--选项--默认浏览器
然后再次启动notebook，就可以打开了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04962c96955068d7e3f007bc149ef458/" rel="bookmark">
			关于快手广告追踪线索表单统计，及遇到了X-Frame-Options的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近同事叫我帮他加一个表单统计的代码，然后遇到了iframe的问题
然后通过参考一下网络上的文章，最终解决了！
非常的简单
在头部加上&lt;meta http-equiv="X-Frame-Options" content="https://ad.e.kuaishou.com"&gt;
下面看下理论知识吧！
X-Frame-Options是什么？ X-Frame-Options是一个HTTP标头（header），用来告诉浏览器这个网页是否可以放在iFrame内。例如：
X-Frame-Options: DENY
X-Frame-Options: SAMEORIGIN
X-Frame-Options: ALLOW-FROM http://caibaojian.com/
第一个例子告诉浏览器不要（DENY）把这个网页放在iFrame内，通常的目的就是要帮助用户对抗点击劫持。
第二个例子告诉浏览器只有当架设iFrame的网站与发出X-Frame-Options的网站相同，才能显示发出X-Frame-Options网页的内容。
第三个例子告诉浏览器这个网页只能放在http://caibaojian.com//网页架设的iFrame内。
蜜雪冰城：http://www.mixuejm.cn
加上基本代码：
这个代码可以script，脚部
最后一步也很关键，需要 加一个form的id
然后就大功告成了！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd84c831ddd4996b65a54cd7a05aa635/" rel="bookmark">
			相机光学（十九）——像差理论（球差）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0.基本概念 在光学系统中，描述像差的方法主要有两种：波像差法和几何像差法。
波像差基于光的电磁波理论，借助波面进行研究。如果光学系统成完善像，则任一物点发出的球面波经过光学系统后在像空间应该是以高斯像点为秋心的球面波。也可以以高斯像作为成像参考，以物体发出的光线经过光学系统后其出身光纤相对于高斯像的偏差来衡量光学系统成像缺陷。
光学系统的近轴区具有理想的光学系统的性质，光学系统近轴区的成像被认为是理想像。实际光学系统所处的像和近轴区所称的像的差异即为像差。
光学系统对单色光成像时产生单色像差，单色光像差分为五类，球差，慧差，像散，场曲和畸变。对白光成像时，还额外产生两种色差，轴向色差和垂轴色差。
1.像差部分 （0）序言 光线经单个折射球面的光路计算，是指在给定单个折射球面的结构参量n、n'、和r时，由已知入射光线L和U，计算折射后出射的参数L‘和U’。
如图所示，在三角形AEC中，应用正弦定理有：,可得球面上的入射角I为，由折射定律得，,根据外角关系，，故，对于像方截距，,化简后可得，,这就是计算子午内光线光路的基本公式。
由于折射球面关于光轴旋转对称，对于光轴上点发出的任一条光线的光路，可以表示该光线绕光轴旋转一周所形成的锥面上全部光线的光路，显然这些光线在像方交光轴于同一点。当L为定值时，L'是U的函数。若发出同心光束，由于各光线具有不同的U，因而光束经球面折射后，将有不同的L'值，即失去了同心性。
（1）子午面、弧矢面、高斯面、入瞳面、出瞳面 &lt;1&gt;入瞳面、出瞳面 如图所示的光学系统有三个光阑，透镜L1成像到物空间，就是它本身；实际上起着限制光轴上物点的光束的作用，即为孔径光阑，孔径光阑在物空间的像称为入射光瞳。由物点发出经过入瞳边缘的光线与光轴的夹角，即成为光学系统的物方孔径角，此角即即为轴上点作边缘光线光路计算所取的孔径角。同理，把所有光阑通过其后面的光组成像到系统的像空间去。孔径光阑在系统像空间的像成为出射光瞳。
入射光瞳决定了能进入系统成像的最大光束孔径，并且是物面上各点发出并进入系统成像光束的公共入口。出瞳光瞳是物面上各点的成像光束经过系统后射出系统的公共出口。入射光瞳通过整个光学系统所成的像就是出射光瞳。如果孔径光阑在整个光学系统的像空间，它本身也就是出射光瞳，反之，在物空间，就是入射光瞳。
&lt;2&gt;子午面、弧矢面、高斯面 为了了解轴外物点所发出的充满入瞳的光束的结构和传播，可通过主光线取出两个互相垂直的截面，其中一个是主光线和光轴决定的平面，称为子午面；另一个是通过主光线和子午面垂直的截面，称为弧矢面。
(2)球差 自光轴上一点发出的光线，经球面折射后所得的像方截距L'是物方孔径角U或入射高度h的函数。因此，轴上点发出的同心光束经光束经光学系统各个球面折射以后，不再是同心光束，入射光线的孔径角U不同，其出射光线与光轴交点的位置就不同，相对于理想像点有不同的偏离。由于球差的存在，使得在高斯像面上得到的不是点像，而一个圆形弥散斑，也可以以弥散斑的半径表示球差，称为横向球差，高斯像面为轴向像差，。
球差是光轴上物点存在的唯一的一种单色像差，它与物点发出光线的物方孔径角有关。物方孔径角与光线在入瞳面上经过的点的位置有关。光学系统入瞳多为圆形，轴上点发出的光束在通过光学系统前、后均对称于光轴，所以子午面内光轴以上的光束的球差就可以表示物点发出的全部光束的球差。子午面内光轴以上一条光线的球差，实际上代表了与光轴有相同夹角的圆锥面上光束的球差，称为一个带光球差。
球差的存在，使得物点在高斯像面上成一个弥散斑，这将使像模糊不清。对于单透镜来说，光线的物方孔径角越大，球差量也越大单透镜不能校正球差，正透镜产生负球差，负透镜产生正球差。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d71bf9529c3a3861efe475ad9bf22e67/" rel="bookmark">
			Git安装及使用可能需要的参考资料
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 第一次使用Git上传本地项目到github上
github修改密码后，需要重新设置sshkey
git更新本地项目至github
idea解除git项目
idea 提交git常见操作
idea中使用github
idea遇到如下错误，可能是配置最后一步没有选择tag。
17:19	Push failed Invocation failed Server returned invalid Response. java.lang.RuntimeException: Invocation failed Server returned invalid Response. at org.jetbrains.git4idea.http.GitAskPassXmlRpcClient.askUsername(GitAskPassXmlRpcClient.java:50) at org.jetbrains.git4idea.http.GitAskPassApp.main(GitAskPassApp.java:64) Caused by: java.io.IOException: Server returned invalid Response. at org.apache.xmlrpc.LiteXmlRpcTransport.sendRequest(LiteXmlRpcTransport.java:242) at org.apache.xmlrpc.LiteXmlRpcTransport.sendXmlRpc(LiteXmlRpcTransport.java:90) at org.apache.xmlrpc.XmlRpcClientWorker.execute(XmlRpcClientWorker.java:72) at org.apache.xmlrpc.XmlRpcClient.execute(XmlRpcClient.java:194) at org.apache.xmlrpc.XmlRpcClient.execute(XmlRpcClient.java:185) at org.apache.xmlrpc.XmlRpcClient.execute(XmlRpcClient.java:178) at org.jetbrains.git4idea.http.GitAskPassXmlRpcClient.askUsername(GitAskPassXmlRpcClient.java:47) ... 1 more remote: No anonymous write access. Authentication failed for 'https://github.com/FanQiH... (show balloon) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a366eedbda87ee3c5b8f32363bb4a52/" rel="bookmark">
			（六）Python列表类型练习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 # 列表 list1 = ['Google', 'Runoob', 1997, 2000] list2 = [1, 2, 3, 4, 5] list3 = ["a", "b", "c", "d"] print(list1[0]) print(list1[1:5]) print(list2) list2[2] = 20 print(list2) del list2[2] print(list2) print(len(list2)) list4 = [['a', 'b', 'c'], [1, 2, 3]] print(list4) print(max(list2)) print(min(list2)) listTest = [2, 3, 4] print(listTest) listTest.append(5) print(listTest) a = listTest.pop() print(a) listTest.extend([5, 6, 7, 5]) print(listTest) print(listTest.count(5)) print(listTest.index(5)) listTest.insert(0, 1) print(listTest) listTest.insert(1, 100) print(listTest) listTest.reverse() print(listTest) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2446fb4269481dd44d105db32842fca0/" rel="bookmark">
			AQS（AbstractQueuedSynchronizer）源码解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、前言二、介绍1. AQS 简介2. Node 数组（1） waitStatus ： 表示节点所处的等待状态（2） prev、next 前后节点（3） thread（4） nextWaiter 三、独占锁的实现1. 独占锁的获取（1）. AbstractQueuedSynchronizer#acquire（2） ReentrantLock.FairSync#tryAcquire（3）.AbstractQueuedSynchronizer#addWaiter（4）. AbstractQueuedSynchronizer#acquireQueued（5）. 总结 2. 独占锁的释放（1）. RentrantLock#unlock -&gt;AbstractQueuedSynchronizer#release（2）. ReentrantLock.Sync#tryRelease（3）. AbstractQueuedSynchronizer#unparkSuccessor（4）总结 四、共享锁的实现1. 共享锁的获取（1）. AbstractQueuedSynchronizer#tryAcquireShared（2）. AbstractQueuedSynchronizer#doAcquireSharedInterruptibly（3）. AbstractQueuedSynchronizer#setHeadAndPropagate（4）. 总结 2. 共享锁的释放（1）. AbstractQueuedSynchronizer#releaseShared（2）.AbstractQueuedSynchronizer#doReleaseShared（3）. 总结 五、总结： 一、前言 本篇是看了下面大神的专栏用来总结记录，因为自己写一遍总比看一遍记得清楚，但强烈建议想要详细了解AQS还是去阅读下面大神的专栏，而非我这篇文章。https://segmentfault.com/a/1190000015739343
二、介绍 1. AQS 简介 AQS是AbstractQueuedSynchronizer的简称。AQS提供了一种实现阻塞锁和一系列依赖FIFO等待队列的同步器的框架，如下图所示。AQS为一系列同步器依赖于一个单独的原子变量（state）的同步器提供了一个非常有用的基础。子类们必须定义改变state变量的protected方法，这些方法定义了state是如何被获取或释放的。鉴于此，本类中的其他方法执行所有的排队和阻塞机制。子类也可以维护其他的state变量，但是为了保证同步，必须原子地操作这些变量。
AQS提供独占和共享两种模式，独占顾名思义，同一时间只能有一个线程占有锁，共享则是同一时间可以有多个线程拥有锁。
2. Node 数组 AbstractQueuedSynchronizer 中，队列的实现是一个双向链表，他的每个节点是一个Node类型
Node是 AbstractQueuedSynchronizer 的一个内部类，下面省略了部分代码：
static final class Node { // 共享锁和独占锁的判断标志 static final Node SHARED = new Node(); static final Node EXCLUSIVE = null; // waitStatus 可选值 static final int CANCELLED = 1; static final int SIGNAL = -1; static final int CONDITION = -2; static final int PROPAGATE = -3; // 节点的等待状态，这个后面详细介绍 volatile int waitStatus; // 当前节点的前置节点 volatile Node prev; // 当前节点的后置节点 volatile Node next; // Node 数组中所代表的线程 volatile Thread thread; // 标志位，如果是null则说明是独占锁，不为null说明是共享锁 Node nextWaiter; // 判断是否是共享锁 final boolean isShared() { return nextWaiter == SHARED; } // 返回前置节点 final Node predecessor() throws NullPointerException { Node p = prev; if (p == null) throw new NullPointerException(); else return p; } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2446fb4269481dd44d105db32842fca0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e8738985f1122a6bf7219120c70de435/" rel="bookmark">
			Shell字符串
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		字符串是shell编程中最常用最有用的数据类型（除了数字和字符串，也没啥其它类型好用了），字符串可以用单引号，也可以用双引号，也可以不用引号。
1.单引号 str='this is a string' 单引号字符串的限制：
单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的；单引号字串中不能出现单独一个的单引号（对单引号使用转义符后也不行），但可成对出现，作为字符串拼接使用。 2.双引号 your_name='runoob' str="Hello, I know you are \"$your_name\"! \n" echo -e $str 输出结果为：
Hello, I know you are "runoob"!
双引号的优点：
双引号里可以有变量
双引号里可以出现转义字符
拼接字符串
your_name="runoob"
3.使用双引号拼接 greeting="hello, "$your_name" !" greeting_1="hello, ${your_name} !" echo $greeting $greeting_1 4.使用单引号拼接 greeting_2='hello, '$your_name' !' greeting_3='hello, ${your_name} !' echo $greeting_2 $greeting_3 输出结果为：
hello, runoob ! hello, runoob ! hello, runoob ! hello, ${your_name} ! 5.获取字符串长度 string="abcd" echo ${#string} #输出 4 6.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e8738985f1122a6bf7219120c70de435/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54b60626719851b7f4f2a66a30c4a95b/" rel="bookmark">
			排列组合中的去重问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		排列组合是笔试面试中常见的题目类型，普通排列组合难度较简单，但如果包含去重问题时候，还是有些规律可循的
Leetcode47 全排列 II
**题目描述** 给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。 candidates 中的每个数字在每个组合中只能使用一次。 说明： 所有数字（包括目标数）都是正整数。 解集不能包含重复的组合。 **示例** 输入: [1,1,2] 输出: [ [1,1,2], [1,2,1], [2,1,1] ] 首先说为何会产生重复问题，以示例来说，当索引从0开始会出现1，1，2的情况，而当首先选择第2个1时候，还有可能选择第一个1，这样还是1，1，2，导致了，重复问题的出现，当然你也可以在最终结果集中用list的contains方法去重，不过方法复杂度较高，直接在递归过程中去重，复杂度较低。
算法实现思路
首先进行排序，如果两个数相等，只有在前一个数已经加入到结果中时候，才能加第二个数， 所以还是以示例来说，就不存在先加入第二个1，再加入第一个1的情况了，解决了去重问题 实现代码
class Solution { List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); boolean[] visited; public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) { visited = new boolean[nums.length]; Arrays.sort(nums); dfs(nums,new ArrayList&lt;&gt;()); return res; } private void dfs(int[] nums,ArrayList&lt;Integer&gt; tmp){ if(tmp.size() == nums.length){ //if(!res.contains(tmp)) 可以在这去重，但复杂度较高,用时300ms res.add(new ArrayList&lt;&gt;(tmp)); return; } for(int i = 0;i &lt; nums.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/54b60626719851b7f4f2a66a30c4a95b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad2aaee8db2e74079d35223ebbf1338c/" rel="bookmark">
			java面试题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Java 基础 1.JDK 和 JRE 有什么区别？
2.== 和 equals 的区别是什么？
3.两个对象的 hashCode()相同，则 equals()也一定为 true，对吗？
4.final 在 java 中有什么作用？
5.java 中的 Math.round(-1.5) 等于多少？
6.String 属于基础的数据类型吗？
7.java 中操作字符串都有哪些类？它们之间有什么区别？
8.String str="i"与 String str=new String(“i”)一样吗？
9.如何将字符串反转？
10.String 类的常用方法都有那些？
11.抽象类必须要有抽象方法吗？
12.普通类和抽象类有哪些区别？
13.抽象类能使用 final 修饰吗？
14.接口和抽象类有什么区别？
15.java 中 IO 流分为几种？
16.BIO、NIO、AIO 有什么区别？
17.Files的常用方法都有哪些？
二、容器 18.java 容器都有哪些？
19.Collection 和 Collections 有什么区别？
20.List、Set、Map 之间的区别是什么？
21.HashMap 和 Hashtable 有什么区别？
22.如何决定使用 HashMap 还是 TreeMap？
23.说一下 HashMap 的实现原理？
24.说一下 HashSet 的实现原理？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ad2aaee8db2e74079d35223ebbf1338c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b64563f19512dd2123651989a3de1d8d/" rel="bookmark">
			vue01-组件通信
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		父组件 --&gt;子组件 属性props //child props:{msg:String} //parent &lt;HelloWorld msg="***********"/&gt; refs //parent &lt;HelloWorld ref="hw"/&gt; //赋值 this.$refs.hw.msg = "******"; children //parent this.$children[0].msg = "****"; 子组件--&gt;父组件 自定义事件 //chidren this.$emit("add",data); //parent &lt;HelloWorld @add="funcName"/&gt; .sync修饰符
*实现父子组件数据的双向绑定
官网：https://cn.vuejs.org/v2/guide/components-custom-events.html#sync-%E4%BF%AE%E9%A5%B0%E7%AC%A6
//父组件语法 v-bind:propName.sync = "data"; // v-bind.sync="obj";[这种语法只适用于对象] //子组件语法 com.$emit("update:propName",newData) //parent &lt;Hello1 v-bind:msg.sync="msg"&gt;&lt;/Hello1&gt; &lt;Hello2 v-bind.sync = "myData"&gt;&lt;/Hello2&gt; data() { return { msg: "msgmsgmgsg", myData:{ a:1,b:2,c:3 } } } //Hello1 fun1() { this.$emit("update:msg","hello1的新数据") } //Hello2 /* myData对象中的每一个属性 (如a) 都作为一个独立的 prop 传入， 各自添加用于更新的 v-on 监听器*/ fun1() { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b64563f19512dd2123651989a3de1d8d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a6ff25015dfb24eb34c01c97db514ec/" rel="bookmark">
			js-5秒之后跳转页面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;script&gt; var div = document.querySelector('div'); var time = 5; timer(); setInterval(timer, 1000) function timer() { if (time == 0) { location.href = 'http://www.baidu.com' } else { div.innerHTML = '将在' + time + '秒后跳转到百度'; time--; } } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/967afe46480299e3202ee0786f4d3a11/" rel="bookmark">
			习题3.3 线性表元素的区间删除 (20 分)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		给定一个顺序存储的线性表，请设计一个函数删除所有值大于min而且小于max的元素。删除后表中剩余元素保持顺序存储，并且相对位置不能改变。
函数接口定义： List Delete( List L, ElementType minD, ElementType maxD ); 其中List结构定义如下：
typedef int Position; typedef struct LNode *List; struct LNode { ElementType Data[MAXSIZE]; Position Last; /* 保存线性表中最后一个元素的位置 */ }; L是用户传入的一个线性表，其中ElementType元素可以通过&gt;、==、&lt;进行比较；minD和maxD分别为待删除元素的值域的下、上界。函数Delete应将Data[]中所有值大于minD而且小于maxD的元素删除，同时保证表中剩余元素保持顺序存储，并且相对位置不变，最后返回删除后的表。
裁判测试程序样例： #include &lt;stdio.h&gt; #define MAXSIZE 20 typedef int ElementType; typedef int Position; typedef struct LNode *List; struct LNode { ElementType Data[MAXSIZE]; Position Last; /* 保存线性表中最后一个元素的位置 */ }; List ReadInput(); /* 裁判实现，细节不表。元素从下标0开始存储 */ void PrintList( List L ); /* 裁判实现，细节不表 */ List Delete( List L, ElementType minD, ElementType maxD ); int main() { List L; ElementType minD, maxD; int i; L = ReadInput(); scanf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/967afe46480299e3202ee0786f4d3a11/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1193ec35f704a36da222b5d94a7fe21a/" rel="bookmark">
			合天ctf类型做题规范（下）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		七、CVE-2017-12615Tomcat远程代码执行漏洞实验 该漏洞受影响版本为7.0-7.80之间，复现实验过程过，BP抓包要实现将端口改成8090，免得与8080的猫端口冲突。
八、支付逻辑漏洞 #1支付过程中可直接修改数据包中的支付金额，bp改数据
#2没有对购买数量进行限制，将数量改成-1
#3购买商品编号篡改
例如商品积分兑换处，100个积分只能换商品编号为001的低价格商品，1000个积分能换商品编号005的高价格商品，在用100积分换商品的时候抓包把换商品的编号从001修改为005，用低积分换区高积分商品。
#4支付逻辑顺序执行缺陷
部分网站的支付逻辑可能是先A过程后B过程然后C过程最后D过程用户控制着他们给应用程序发送的每一个请求，因此能够按照任何顺序进行访问。但是，如果用户直接从B直接进入了D过程，就绕过了C过程。如果C是支付过程，那么用户就绕过了支付过程而买到了一件商品。如果C是验证过程，就会绕过验证直接进入网站程序了。
案例:万达某分站逻辑错误可绕过支付直接获得取票密码
#5请求重放
购买商品成功后，重放购买成功的http请求，可以使购买的商品一直增加。购买成功后，会有一个从银行向商户网站跳转的过程，如果这个过程反复的重放，有可能导致商品的反复购买和增加，但是用户不需要支付更多的金钱。
案例:豆丁网购买豆元后可以将豆元倍增
#6程序的异常处理
程序的异常处理比较少见，不过也是有案例的。程序的异常处理，就是指支付的数据包异常的程序的错误处理。这种异常可以是数据与KEY不符，支付的金额有错误，购买的数量不正确等等。程序的异常处理出现的原因主要是开发人员对出现异常后的处理不当造成的。
案例:115网盘存在支付绕过
九、CTF-MISC练习之编码1 Exif信息、MD5、审查元素里的NETWORK,看php
Cookie里面的check=0与check=1修改
爆破MD5，python程序编写
十、CTF-MISC练习之编码2 听说从合天网安实验室过来的小伙伴都看到KEY啦！”—referer的指向
数字解密的话用九宫格的英文输入法
X-Forwarded-For：。。。。。。。
十一、0x01 修改后缀名为txt
而且十六进制转换成十进制后，再对照ACSII表。
十二、CTF-MISC练习之编码3 Keep/admin/safe 可能的意思是admin文件夹
16进制对应的ACSII是用C32Asm
10进制对应的话用Jpk
url编码用JPK
十三、CTF-MISC练习之编码5 各种编码规则，找开头有没有提示，然后就规则搜索，百度谷歌都用，BF（百度不到，谷歌就可以）
十四、Invisible X_FORWARDED_FOR、VIA 、CLIENT_IP
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eeb8dfb779769ace8f11dde8b8d5a720/" rel="bookmark">
			typescript从0到1全过程总结&#43;vue整合typescript
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		TypeScript 是 JavaScript的一个超集 1. 下载：
npm install typescript -g 2. 生成配置文件（tsconfig.json）： 解决VsCode 红色下滑线警告
tsc --init
3. 运行：
tsc ts文件名.ts
可通过 -w 实时监听ts文件的改变 ，执行tsc ： tsc ts文件名.ts -w
注意事项：
TS 需要编译成 JS 才能被浏览器所解析即使typescript编译报错，也可以生成js文件 数据类型： 字符串类型：
数字类型：
布尔类型：
数组类型：
元祖类型：
枚举类型：
any类型：（任何类型）
void类型：（空类型：用于函数是否有返回值）
undefined 和 null 类型：
联合类型：（可以是指定中的任何一种类型）
类型推论：（定义变量时没有赋值则推论为any类型，赋值则为初始时的类型）
类型断言：（当值的类型不确定时，手动指定一个值的类型）
函数 函数的参数
可选参数： （？）
剩余参数：（...）
函数的重载：
接口：（行为的抽象，对数据的约束） 接口的定义： interface 接口名 {} 规范的接口名： I接口名首字母大写 （I：interface）
实现接口： implements 接口名
定义接口时，只需要声明即可，不包含具体的实现实现接口时，必须实现接口中的内容 应用场景：当一个东西，必须有一个或多个功能时，即可定义为一个接口。
例如：打印机（每台打印机都有一个打印功能）
/** 定义一个打印机接口 * 内部存在一个打印功能（函数） 只需要声明，不包含具体实现 */ interface Iprint { printing(mes: string): string } // 对接口的继承 interface Ipeintmes extends Iprint { getMes(mes: string): void } // 实现 Ipeintmes 接口 ，必须实现 Ipeintmes接口中的方法和继承至 Iprint接口中的方法 class Printe implements Ipeintmes { printing(mes: string): string { return mes } getMes(mes: string) { console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eeb8dfb779769ace8f11dde8b8d5a720/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92ebce95f70547b9be4e193e9b336af2/" rel="bookmark">
			【Android】蓝牙开发——经典蓝牙：配对与解除配对 &amp; 实现配对或连接时不弹出配对框
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、配对方法 二、解除配对方法
三、配对/解除配对结果
四、justwork配对模式下，不弹出配对框
五、pincode配对模式下，不弹出配对框
六、小结
在之前的文章【Android】蓝牙开发—— 经典蓝牙配对介绍（Java代码实现演示）附Demo源码 中，简单介绍和演示了经典蓝牙的配对方式，今天就在之前的基础上继续讲讲，蓝牙的配对、解除配对以及如何实现不弹出配对框。
关于“配对”、“解除配对”的说法，还有叫“绑定”、“解绑”，这里提前说一下，在之前的文章中出现，防止小伙伴们不理解。
一、配对方法 蓝牙配对方式，目前有两种，一种是通过反射的方法，还有一种是直接调用官方API的方法。
第一种：反射的方法，在低于Android API 19时，配对的方法是隐藏的方法，所以只有通过反射方法实现。
/** * 第一种 * 执行配对 反射 * @param bluetoothDevice 蓝牙设备 * @return true 执行绑定 false 未执行绑定 */ public boolean boundDevice(BluetoothDevice bluetoothDevice){ if(bluetoothDevice == null){ Log.e(TAG,"boundDevice--&gt;bluetoothDevice == null"); return false; } try { return ClsUtils.createBond(BluetoothDevice.class,bluetoothDevice); } catch (Exception e) { e.printStackTrace(); } return true; } ClsUtils.java中createBond()方法如下：
/** * 与设备配对 参考源码：platform/packages/apps/Settings.git * /Settings/src/com/android/settings/bluetooth/CachedBluetoothDevice.java */ @SuppressWarnings("unchecked") static public boolean createBond(@SuppressWarnings("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/92ebce95f70547b9be4e193e9b336af2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b499bd7bf9460182ffec0d9fb25bb328/" rel="bookmark">
			[结构光三维重建] 2、基于结构光的三维重建系统工作原理总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概念 基于结构光三维重建系统模型，如下图所示：
基于结构光的三维成像，实际上是三维参数的测量与重现，需要主动去投射结构光到被测物体上，通过结构光的变形来确定被测物的尺寸参数，是一种主动三维测量方式。
首先，结构光的类型就分为很多种，既然是结构光，当然是将光结构化，简单的结构化包括点结构光，线结构光以及简单的面结构光等，复杂一点的结构化就上升到光学图案的编码了。结构光投射到待测物表面后被待测物的高度调制，被调制的结构光经摄像系统采集，传送至计算机内分析计算后可得出被测物的三维面形数据。
空间调制方法为结构光场的相位、光强等性质被待测物的高度调制后都会产生变化，根据读取这些性质的变化就可得出待测物的面形信息。
下面以一种应用广泛的光栅投影技术（条纹投影技术）为例来阐述其具体原理。条纹投影技术实际上属于广义上的面结构光。其主要原理如下图所示，即通过计算机编程产生条纹，将该条纹通过投影设备投影至被测物，利用CCD相机拍摄条纹受物体调制的弯曲程度，解调该弯曲条纹得到相位，再将相位转化为全场的高度。当然其中至关重要的一点就是系统的标定，包括系统几何参数的标定和CCD相机以及投影设备的内部参数标定，否则很可能产生误差或者误差耦合。因为系统外部参数不标定则不可能由相位计算出正确的高度信息。
原理 下面以实验室扫描系统讲解其原理。
第一步，编程产生正弦条纹图
因为后续要利用变形条纹图获取相位，而获取相位的算法也有多种，此处采用的是四步移相法，具体原理去查文献，不再累述。因此这里产生四幅相位差pi/2的条纹。然后将该四幅条纹分时投影到被测物（面具）上，采集到四幅被调制条纹图。
第二步，相位恢复
由采集到的四幅受调制条纹图计算出被调制相位，这里得到的相位图是截断相位图，因为四步移相算法得到的结果是由反正切函数计算所得，因而被限制在[-pi,pi]之间，也就是说每当其值超过该范围，又会重新开始。得到的相位主值如下图所示： 解决上述问题需要消跳变，即将截断相位恢复为连续相位。如下所示，左边为受调制的连续相位，右边是参考连续相位。
第三步，上述二者相减得到相位差
该相位差则表征了被测物相对参考面的高度信息，再代入相位与高度转化公式（其中相应参数经过标定），得到如下三维模型。 下面是实验室研制的集成化3D结构光成像系统及其相关应用（变形测量，钥匙复制） 通过上述三个步骤，完成了三维模型的三维点云构建，重建的精度取决于相机分辨率和投影精度以及距离等参数。如果需要颜色信息或者去除边缘噪点，需要结合三维软件后处理。
https://blog.csdn.net/wangbaodong070411209/article/details/80389354
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f0d0f7cd6ce6f66d916855b23c92686/" rel="bookmark">
			【回归】问题：随机误差和残差的区别？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 回归分析中，随机误差和残差的区别？（随机扰动项与剩余项）
计量经济模型中，随机扰动项与残差项均为随机项。
区别是① 随机误差项 ξ 表示总体模型的误差（观察值 Yi 与条件期望 E(Y|Xi) 的差），残差 ei 表示样本模型的误差（观察值 Yi 与估计值或称样本条件均值 的差）；② ξ 不可观测，ei 可以在估计出参数后计算；③ ei = ξ +参数估计误差（待查）。
《计量经济学小题》：https://wenku.baidu.com/view/33770226c5da50e2524d7f5c.html
《随机误差和残差的区别》：https://www.ppkao.com/tiku/shiti/9605110.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f73e6bf7dcaf2d56c4f6ca9ffeb3d27/" rel="bookmark">
			MySql8.0忘记‘root’@&#39;localhost&#39;的密码如何修改？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		步骤：
1）管理员权限打开cmd,输入net stop mysql
（如果提示服务名无效，可以参考这里cmd中输入net start mysql 提示：服务名无效或者MySQL正在启动 MySQL无法启动）
2）修改C:\ProgramData\MySQL\MySQL Server 8.0\my.ini
在[mysqld]之后，加上skip-grant-tables
（最后要将my.ini的编码格式保存为ANSI，否则后续步骤会报错；ProgramData默认是隐藏的）
3）添加环境变量
4）mysqld --skip-grant-tables --shared-memory
（–shared-memory必须加）
5）重新用管理员权限打开一个cmd，原来那个cmd不关闭，直接输入mysql
6)启动后，输入
flush privileges
use mysql
ALTER USER ‘root’@‘localhost’ IDENTIFIED BY ‘123456’;
恭喜恭喜！复原后成功启动。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d3f37e6a689f3d6e7efb7515d45babb/" rel="bookmark">
			解决There is no getter for property named in class java.lang.String
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天在项目中遇到了如图所示的错误，这是因为mybatis对parameterType="String的SQL语句做了限制
解决方法：加入@Param注解
举例说明一下@Param注解的使用场景
第一种：方法有多个参数，需要@Param注解 @Mapper public interface UserMapper { Integer insert(@Param("username") String username, @Param("address") String address); } 对应的Mapper.XML文件
&lt;insert id="insert" parameterType="org.javaboy.helloboot.bean.User"&gt; insert into user (username,address) values (#{username},#{address}); &lt;/insert&gt; 这是最常见的需要添加 @Param 注解的场景。
第二种：方法参数要取别名，需要 @Param 注解 当需要给参数取一个别名的时候，我们也需要 @Param 注解，例如方法定义如下：
@Mapper public interface UserMapper { User getUserByUsername(@Param("name") String username); } 对应的Mapper.XML文件
&lt;select id="getUserByUsername" parameterType="org.javaboy.helloboot.bean.User"&gt; select * from user where username=#{name}; &lt;/select&gt; 基本不用，费事
第三种：XML 中的 SQL 使用了 $ ，那么参数中也需要 @Param 注解 例如要传入列名或者表名的时候，这个时候必须要添加 @Param 注解，例如：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2d3f37e6a689f3d6e7efb7515d45babb/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/254/">«</a>
	<span class="pagination__item pagination__item--current">255/321</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/256/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>