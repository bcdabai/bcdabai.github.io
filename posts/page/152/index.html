<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/897c5d0024af30989ff7dcea0d027ed3/" rel="bookmark">
			Spring Boot demo系列（十二）：ShardingSphereJDBC &#43; MyBatisPlus 分库分表 &#43; 读写分离
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 概述 之前笔者写过两篇文章：
ShardingSphereJDBC 读写分离ShardingSphereJDBC 分库分表 这里将两者结合起来，实现读写分离+分库分表的功能。关于环境的配置本文将进行简化叙述，详细可以参考前两篇文章。
2 环境 MySQL 8.0.29（Docker）MyBatis Plus 3.5.1MyBatis Plus Generator 3.5.2Druid 1.2.10ShardingSphereJDBC 5.1.1Yitter 1.0.6（一个雪花id生成器） 3 数据库环境准备 由于环境准备不是本文的重点，一主一从的主从复制环境可以参考此处搭建。
准备好环境，本地启动两个MySQL，主节点环境：
名字：master端口：3306数据库：两个库（test0、test1）数据表：六个表，每个库三个（test0.user0、test0.user1、test0.user2、test1.user0、test1.user1、test1.user2） 从节点环境：
名字：slave端口：3307数据库：两个库（test0、test1）数据表：六个表，每个库三个（test0.user0、test0.user1、test0.user2、test1.user0、test1.user1、test1.user2） 主库配置文件：
[mysqld] server-id=1 binlog-do-db=test0 binlog-do-db=test1 从库配置文件：
[mysqld] server-id=2 replicate-do-db=test0 replicate-do-db=test1 主库+从库一共12个user库都是一样的，如下所示：
完整的数据库脚本和MySQL配置文件放在文末的源码链接中。
4 新建项目 新建项目并引入如下依赖：
DruidMyBatis Plus starterMyBaits Plus GeneratorVelocity coreShardingSphereJDBCYitter Maven如下：
&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.5.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-generator&lt;/artifactId&gt; &lt;version&gt;3.5.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.freemarker&lt;/groupId&gt; &lt;artifactId&gt;freemarker&lt;/artifactId&gt; &lt;version&gt;2.3.31&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.2.10&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/897c5d0024af30989ff7dcea0d027ed3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f255cadc3df947ab9eab8b4fff191ba0/" rel="bookmark">
			Android wifi 开发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android Wifi相关操作 - 简书
Android进阶之路 - WiFi的全面使用_Modu_Liu的博客-CSDN博客
1. 获取当前networkid， 发起断开重连
WifiInfo connectionInfo = wifiManager.getConnectionInfo();
int networkId = connectionInfo.getNetworkId(); // networkId
wifiManager.disconnect();
wifiManager.enableNetwork(networkId, true);
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06ce79e1ce037d4ab1c40e0d8be8bb94/" rel="bookmark">
			nodeJs对DICOM医学影像文件解析并保存为图片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近入职一家医疗硬件和软件开发的公司，负责一套医疗软件中DICOM部分的功能开发，因为对这个行业完全陌生，对DICOM也一无所知，所以很头疼，查了很多国内外的资料，才有了一定了解。
软件需求是模仿国外知名的DICOM解析软件orthanc，实现他的功能。因为我们的软件后端使用nodejs实现，所以我需要用nodejs实现对dicom文件的解析及转换成png/jpg图片以供前后端使用。
关于对DICOM文件的解析，网上有很多资料可查，我这里不详细复述了，我碰到的问题是dicom转成图片的问题。如果是前端，可以直接用开源的医疗影像软件 cornerstonejs 下的众多开源软件包例如dicomParser解析DICOM获取TAG和位图数据，cornerstoneWADOImageLoader前端显示DICOM图像和TAG参数，cornerstoneTools使用各种预定义工具操作影像。但是nodejs就没有直接可操作转换DICOM文件为图片的相关开源包了。为此我只能查找了解DICOM的原理机制，并尝试读取位图信息并转换为图片。
经过两周不懈努力尝试了各种方案，终于开发并完成了一个可解决的方案，即利用dicomParser解析DICOM文件后，使用node-canvas将图片保存为PNG图片（此时保存的图片和DICOM文件基本差不多大，均在几兆到三十兆之间），最后使用imagemin压缩并转换成更小的PNG和JPG图片
接下来贴出部分代码以供参考学习，如有错误请指出讨论。
1、首先安装一些必要的包：
#安装dicom-parser npm install dicom-parser #安装node-canvas npm install canvas #安装imagemin npm i imagemin@7.0.1 npm i --save-dev @types/imagemin@7.0.1 npm i imagemin-jpegtran npm i --save-dev @types/imagemin-jpegtran npm i imagemin-pngquant npm i --save-dev @types/imagemin-pngquant 2、接下来是上传或导入DICOM文件并解析保存其TAGS到数据库的代码，这里就不列出了。需要导入一些必要的包，包括前面安装的
import * as fs from 'fs'; import * as crypto from 'crypto'; import * as path from 'path'; import * as dicomParser from 'dicom-parser'; //DICOM解析 import * as canvas from 'canvas'; import { getVOILUT } from '.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/06ce79e1ce037d4ab1c40e0d8be8bb94/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0fa387232cc18bf999953ac4ecbb42b4/" rel="bookmark">
			centos 8 设置中文环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.首先查看当前字符集 locale 2.看看有没有zh_CN.utf8 locale -a |grep CN 没有就安装中文配置
yum install -y langpacks-zh_CN 3.安装后配置环境 打开配置文件
vi /etc/locale.conf LANG="en_US.UTF-8" 改为 LANG="zh_CN.UTF-8"
LANG="zh_CN.UTF-8" 4.重启系统 reboot 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e926da60bf2abe04b70408f3156a4cab/" rel="bookmark">
			vue3创建文件报“组件名称应该总是由多个单词组成“Component name “index“ should always be multi-word
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在项目根目录下的 .eslintrc.js 文件中添加 “vue/multi-word-component-names”: “off”, 没有该文件就创建一个
module.exports = { root: true, env: { node: true, }, extends: [ "plugin:vue/vue3-essential", "eslint:recommended", "@vue/typescript/recommended", "plugin:prettier/recommended", ], parserOptions: { ecmaVersion: 2020, }, rules: { "no-console": process.env.NODE_ENV === "production" ? "warn" : "off", "no-debugger": process.env.NODE_ENV === "production" ? "warn" : "off", //关闭组件命名规则 "vue/multi-word-component-names": "off", }, }; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1979bc05344b7acf7433578eada1e2db/" rel="bookmark">
			计算电磁学-算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 今天开始，把学习笔记记录在网站上。
一、CEM（计算电磁学）是干嘛的？ 简单来讲，CEM就是用计算机技术 求解电场、磁场。以及由电场、磁场推算功率流（坡印廷矢量）、波导模式等。
二、各种计算方法 最基本的方法是根据网格（正交和非正交）对空间进行离散化，并在网格中的每个点求解麦克斯韦方程。典型的公式包括对每个时间瞬间在整个域上的方程进行时间步进（FDTD&amp;FIT等算法）；通矩阵求逆计算基函数的权重（FEM算法）；或使用传递矩阵方法时的矩阵乘积？；或在使用矩量法(MoM)时计算积分；或使用快速傅里叶变换，在通过分步法或 BPM 计算时使用时间迭代。
1. 积分方程求解 矩量法 矩量法( MoM) 或边界元法(BEM) 是一种求解线性偏微分方程的数值计算方法，这些方程已被表述为积分方程（即边界积分形式）。
1980 年代以来，BEM 变得越来越流行。因为它只需要计算边界值，而不是计算整个空间的值，所以对于表面/体积比小的问题，它在计算资源方面的效率要高得多。从概念上讲，它通过在建模表面上构建“网格”来工作。
快速多极方法(FMM) 是 MoM 或 Ewald 求和的替代方法。它是一种精确的模拟技术，并且比 MoM 需要更少的内存和处理器功率。
部分元件等效电路(PEEC) PEEC是一种适用于组合电磁和电路分析的3D 全波建模方法。与 MoM 不同，PEEC 是一种全谱方法，从直流到网格确定的最大频率均有效。在 PEEC 方法中，积分方程被解释为应用于基本 PEEC 电池的基尔霍夫电压定律，从而为 3D 几何形状提供完整的电路解决方案。等效电路公式允许额外的SPICE类型的电路元件很容易被包括在内。此外，模型和分析适用于时域和频域。
2.微分方程求解 时域有限差分法 有限差分时域(FDTD) 是一种流行的 CEM 技术。这很容易理解。它有一个非常简单的全波求解器实现。实现基本 FDTD 求解器的工作量至少比 FEM 或 MoM 求解器少一个数量级。
由于它是一种时域方法，只要时间步长足够小以满足所需最高频率 的Nyquist-Shannon 采样定理，解决方案可以通过单次仿真运行覆盖很宽的频率范围。
FDTD 属于基于网格的差分时域数值建模方法的一般类别。麦克斯韦方程（偏微分形式）被修改为中心差分方程，离散化并在软件中实现。方程以循环方式求解：在给定的时间点求解电场，然后在下一个时间点求解 磁场，并一遍又一遍地重复该过程。
不连续时域法 在众多的时域方法中，不连续伽辽金时域（DGTD）方法由于融合了有限体积时域（FVTD）方法和有限元时域（FETD）方法的优点而受到欢迎。与 FVTD 一样，数值通量用于在相邻元素之间交换信息，因此 DGTD 的所有操作都是本地的并且易于并行化。与 FETD 类似，DGTD 采用非结构化网格，如果采用高阶层次基函数，则能够获得高阶精度。凭借上述优点，DGTD方法被广泛应用于涉及大量未知数的多尺度问题的瞬态分析。
时域有限积分 有限积分技术
有限积分技术 (FIT) 是一种空间离散化方案，用于数值求解时域和频域中的电磁场问题。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1979bc05344b7acf7433578eada1e2db/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70013c79bd6438b0e7263939705ded42/" rel="bookmark">
			【系统集成项目管理】学习笔记（一）信息化- 第一讲
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.信息化知识 1.1 信息与信息化 信息（了解） 是客观事物状态和运动特征的一种普遍形式，客观世界中大量的存在、产生和传递着以这些方式表达出来的各种各样的信息。
本体论信息（了解） 事物的运动状态和状态变化的自我表述
认识论信息（了解） 主体对于该事物的运动状态以状态变化方式的具体描述。包括对于它的“状态和方式” 的形式、含义和价值的描述。
信息的传输模型（掌握） 系统的质量特性（掌握） 信息系统的特点 信息系统的组成（了解） 信息系统的组成部分主要包括：硬件、软件、数据库、网络、存储设备、感知识别、外设、人员以及把数据处理成信息的规程等。
硬件：由执行输入，处理和输出行为的计算机设备组成软件：由管理计算机运行的程序构成，包括驱动程序，系统软件、数据库管理系统、中间件、应用软件等数据库：是经过机构化，规范化组织后的事实和信息的集合。是信息系统中最有价值和最重要的部分之一。人员：是信息系统中最重要的因素。 信息系统人员包括 所有 管理，运行，编写和维护系统的人。 信息系统的声明周期（掌握） 软件的声明周期主要包括：可行性分析与项目开发计划、需求分析、概要设计、详细设计、编码、测试、维护 等阶段。
信息化的5个层次（掌握） 信息化的基本内涵（掌握） 国家信息化6要素（掌握） 两化融合（熟悉） 党的十八大报告指出，要坚持“四化同步发展，两化深度融合”，明确了两化深度融合成为我国工业经济转型和发展的重要举措之一。四化：工业化，信息化，城镇化，农业现代化。两化：工业化，信息化。 一.信息化与工业化发展战略的融合，即信息化发展战略与工业化发展战略要协调一致，信息化发展模式与工业化发展模式要高度匹配，信息化规划与工业化发展规划，计划要密切配合。
二.信息资源与材料，能源等工业资源的融合，能极大节约材料，能源等不可再生资源。
三.虚拟经济与工业实体经济融合，孕育新一点经济的产生，极大促进信息经济，知识经济的形成与发展。
四. 信息技术与工业技术，IT设备与工业装备的融合，产生新的科技成果，形成新的生产力。
1.2 国家信息化战略和规划 1.2.1 具体目标（了解） 促进经济增长方式的根本转变实现信息技术自主创新，信息产业发展的跨越增强政府公共服务能力，社会主义先进文化传播能力，中国特色的军事变革能力和国民信息技术应用能力。提升网络普及水平，信息资源开发利用水平和信息安全保障水平。 1.2.2 信息化基础设置（熟悉） 构建下一代国家综合信息服务设施：实施宽带中国战略，以宽带普及提速和网络融合为重点，加快构建宽带、融合、安全、泛在的下一代国家信息基础设施。 加快宽带网络优化升级和区域协调
促进下一代互联网规模商用和前沿布局（IPv6）
建设安全可靠的信息应用基础设施
加强统筹管理，逐步形成技术先进、安全可靠的内容分发网络（CDN）
加快推进三网融合（计算机网、广播电视网、电信网）
优化国家通信网络布局
信息化发展的基本原则（熟悉） 统筹发展，有序推进需求牵引，市场导向完善机制，创新驱动加强管理，保障安全 1.4 企业信息化与两化的深度融合 1.4.1 企业信息化（熟悉） 企业信息化是产业升级转型的重要举措之一，而以 “两化深度融合”、“智能制造”、“互联网” 为特点的产业信息化是未来企业信息化继续发展的方向。企业信息化就是用现代信息技术来实现企业经营策略、行为规范和业务流程。企业信息化：在企业作业、管理、决策的各个层面，科学计算、过程控制、事务处理、经营管理的各个领域，引进和使用现在信息技术，全面改革管理体制和机制，从而大幅度提高企业工作效率、市场竞争能力和经济效益。企业信息化的结构： 产品（服务）层、作业层、管理层、决策层 1.4.2 企业信息化战略要点（掌握） 以信息化带动工业化 以工业化促进信息化信息化与企业业务全过程的融合、渗透信息产业发展与企业信息化良性互动充分发挥政府引导的作用高度重视信息安全企业信息化与企业的改组改造和形成现代企业制度有机结合“因地制宜”推荐企业信息化 1.4.3 企业信息化基本原则（了解） 一 效益原则二 “一把手”原则三 中长期与短期建设相结合的原则四 规范化与标准化原则五 以人为本原则 1.4.4 ERP（了解） OLAP （在线分析处理）：强调企业的事前控制能力，它可以将设计、制造、运输和销售等通过集成来并行的进行各种相关作业，为企业提供了对质量、应变、客户满意度和绩效等关键问题的实时分析能力。ERP系统采用 客户/服务器，浏览器/服务器体系结构和分布式数据处理技术，支持Internet、电子商务和电子数据转换（EDI）ERP 是一个 以财务会计为核心的信息系统，用来识别和规划企业资源，对采购，生产、成本、库存、销售、运输、财务和人力资源等进行规划和优化，从而达到最佳资源组合，使企业利润最大化。一般的ERP软件的财务部分分为会计核算与财务管理两大块。 OLTP:在线事务处理
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/70013c79bd6438b0e7263939705ded42/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1924e4041d77bb0374441fb9c5472b9/" rel="bookmark">
			日常问题01 —— 微信开发者工具代码被覆盖了如何恢复
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.问题场景描述 我在使用微信开发者工具时，由于代码没提交，但是此时拉取代码了，导致本地修改的未提交的代码被覆盖了。
问题出现流程：
（1）本地修改的代码未提交。
（2）拉取远程分支代码。
（3）导致代码被覆盖。
2.问题解决 2.1 通过微信开发者工具的贮藏功能恢复 具体操作如下：
（1）找到版本管理
（2）找到贮藏
右下角展示的就是被覆盖的代码。
（3）恢复代码
选中被覆盖的文件后右键。只能一个一个的恢复。
注意：在恢复文件前一定不要提交代码，一旦提交，贮藏区的文件就会被清除。那样代码真的找不回来。
2.2 通过还原以前的版本功能（仅限于windows系统） （1）找到存放代码的本地文件夹
（2）还原以前版本
2.3 万能方案（100%解决问题） 那就是重新写。。。。。
所以平常要有代码备份的习惯，经常提交下代码不要间隔太久。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76cf6e555b9f50449eaefd405d71919c/" rel="bookmark">
			Spring宣布旧的Spring Security OAuth彻底停止维护，连文档仓库都没了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Spring Security团队正式宣布Spring Security OAuth终止维护，到达生命的终点。
目前官网的主页已经高亮提醒彻底停止维护。
旧的Spring Security OAuth项目终止到2.5.2.RELEASE版本，该项目将不会再进行任何的迭代，包括Bug修复，之前胖哥已经提醒该项目即将停止维护，有心的同学已经进行了迁移。
2020年就已经宣布了EOL时间表 项目文档和代码仓库被移除 目前该项目的官方文档已经正式从spring.io移除，文档已经指向404，这连文档也没有了。新增了OAuth2授权服务器Spring Authorization Server的文档。
不仅仅文档被移除，连项目的仓库也被迁移到Spring的过期项目仓库spring-attic并被标记为read-only。
Spring Security OAuth仓库已经迁移 Spring Security OAuth的Spring Boot自动配置代码仓库也一并被迁移，也就是说Spring Boot相关的自动配置也被移除。
Spring Security OAuth2 Boot仓库被迁移 从这种情况看来大约Spring Security OAuth的确是死了。难道就没有可用的了吗？当然不是。
迁移指南 这是胖哥总结的迁移指南。
依赖项检查 那么如何检查你的项目是否用了旧的OAuth2设施呢？当然是对依赖进行检查。以下清单中的依赖任何版本的都是过期的，都需要迁移：
&lt;dependency&gt; &lt;groupId&gt;org.springframework.security.oauth&lt;/groupId&gt; &lt;artifactId&gt;spring-security-oauth-parent&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.security.oauth&lt;/groupId&gt; &lt;artifactId&gt;spring-security-oauth&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.security.oauth&lt;/groupId&gt; &lt;artifactId&gt;spring-security-oauth2&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-jwt&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.security.oauth.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-security-oauth2-autoconfigure&lt;/artifactId&gt; &lt;/dependency&gt; 你可以通过mvn dependency:tree来检查依赖树是否集成了上述依赖项。
新的OAuth2替代方案 ❝ 需要开发者掌握OAuth2.0、OAuth2.1、OIDC 1.0的一些知识。
Spring Security 5中集成了OAuth2 Client和Resource Server两个模块。如果有迁移的需要，建议迁移至最新的Spring Security 5.7.x，方便向Spring 6过渡。以Spring Boot为例，首先要集成Spring Security：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/76cf6e555b9f50449eaefd405d71919c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9d72c08221a47e6079b235678f6de1a/" rel="bookmark">
			windows系统日志查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系统日志是用于记录系统中硬件、软件和系统问题、监视系统中发生事件的信息。分为系统日志、应用程序日志和安全日志。用户可以通过它来检查错误发生的原因，或者寻找受到攻击时攻击者留下的痕迹。
Windows系统日志可以通过右击计算机-管理-事件查看器，或者在【开始】→【运行】→输入 eventvwr.msc 也可以直接进入“事件查看器”进行查询。
Windows日志常用事件ID
1074，查看计算机的开机、关机、重启的时间以及原因和注释。
6005，表示日志服务已启动，用来判断正常开机进⼊系统。
6006，表示日志服务已停用
6009，表示非正常关机
41， 表示系统在未先正常关机的情况下重新启动。
4199，当发生TCP/IP地址冲突的时候，会出现此事件ID。
35,36,37，记录时间客户端状态信息，35表⽰更改时间源，36表示时间同步失败，37表示时间同步正常
7045，服务创建成功
7030，服务创建失败
4624，成功登陆的用户
4625，表示登陆失败的用户
4672，表示授予了特殊权限
4720,4722,4723,4724,4725,4726,4738,4740，事件ID表示当用户帐号发生创建，删除，改变密码时的事件记录。
4727,4737,4739,4762，表示当用户组发生添加、删除时或组内添加成员时生成该事件。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf1f40f9f6eace609b957dbaef775563/" rel="bookmark">
			MassAI 未加载UnrealEditor-MassEntity.pdb
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果你在写Processor的时候，遇到VS提示“未加载UnrealEditor-MassEntity.pdb”。之后无法加载进入编辑器。
那么你应该是写Processor却没有重载ConfigureQueries。
原因猜测为：
Processor会自动创建一个实例对象。而你没有重载的话，在调用ConfigureQueries时，会出问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/192d10c99eb47088ea445fdc55e231b4/" rel="bookmark">
			(wps)表格下拉选择多个选项
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、选择 “开发工具”，点击下拉列表框插件。
2、在表格页面画一个大小合适的列表框。
3、右击列表框，选择”查看代码“，此时会弹出表格组件编辑器。
4、在右边代码框增加如下代码。
需要注意这里我只有一个ListBox1 ，用的默认名称，如果有多个需新增多个方法，同时属性名字要改成设计时组件的名称。如ListBox1,ListBox2
Private Sub ListBox1_Click() If Reload Then Exit Sub '加载ListBox1 For i = 0 To ListBox1.ListCount - 1 If ListBox1.Selected(i) = True Then t = t &amp; "," &amp; ListBox1.List(i) Next ActiveCell = Mid(t, 2) End Sub Private Sub ListBox1_Change() If Reload Then Exit Sub '加载ListBox2 For i = 0 To ListBox1.ListCount - 1 If ListBox1.Selected(i) = True Then t = t &amp; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/192d10c99eb47088ea445fdc55e231b4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06bb8c4ffd549a8fbb089e96c669e448/" rel="bookmark">
			Arduino ESP8266 SPI-FFS存储区域
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Arduino ESP8266 SPI-FFS存储区域 首先请原谅我分开来写，文章老是不过审核。
前言 在前面博文关于ESP8266WiFiWebServer的例程中，大家可以发现，博主基本上都是手动拼装html内容返回，html的内容被固定写在我们的Arduino ESP代码中。
那么这样就有两点弊端：
ESP8266代码相当臃肿
为了开发方便，web server网页除了自身的html内容之外，还包括一些css文件，甚至引入了JQuery库以及一些图片相关资源。如果把这些内容也直接写入到ESP8266代码中，会导致8266整体代码变大，甚至可能超过flash规定的大小；业务职责分离不明确
一般来说，在一个开发团队中，有人负责开发ESP8266业务需求，有人负责开发WebServer网页内容，有人负责硬件部分。直接把html的内容直接写入到ESP8266代码中，就会导致业务职责混乱，并且如果要修改html内容的时候还得一个个改掉arduino的文件，也有可能改错标识符之类的。理想情况应该是，只需要更新web server的html文件就好，原来的esp8266 arduino逻辑不用更新；
基于以上两点弊端，正式引入本篇章需要研究的ESP8266 文件系统（SPI Flash FileSystem，简称为SPIFFS）。
先来看一个概念图：
文件系统可以帮助我们存储一些变更频率不频繁的文件例如网页、配置或者是某些固化的数据等。
其实，我们用得更多的是存储网页，将网页和相关资源（如：图片、html、css、javaScript）存入到flash的SPIFFS区域。
原理如下图：
2. FLASH存储分配 在讲解SPIFFS之前，我们来看看在Arduino环境下ESP8266的flash存储分配，请看下图：
具体可以分为几部分：
1.代码区
又叫做程序存储区，其中又区分为当前代码区（current Sketch），更新代码区（OTA update）；
文件系统
这个就是我们这节重点讲解的SPI Flash File System，简称SPIFFS闪存文件系统。
即使文件系统与程序存储在同一个闪存芯片上，烧入新的代码也不会修改文件系统内容。这允许使用文件系统来存储Web服务器的代码数据、配置文件或内容。而这个SPIFFS文件系统的大小可以通过烧写环境来配置，目前一般有1M，2M，3M等等。博主建议如果是NodeMcu板子，可以配置成3M；
为了使用文件系统，需要把下面的头文件包含在代码中：
#include &lt;FS.h&gt; 1.EEPROM
具体讲解请回顾 ESP8266开发之旅 基础篇④ ESP8266与EEPROM
WiFi Config
这个区域就是我们设置WiFi模块配置的时候存储的数据。
3. SPIFFS文件系统 3.1 文件系统限制
ESP8266的文件系统实现必须满足芯片的限制，其中最重要是有限的RAM。SPIFFS之所以被ESP8266选择作为文件系统，是因为它是为小型系统专门设计的，同时是以一些简化和限制为代价的。
首先，SPIFFS不支持目录，它只存储一个“扁平化”的文件列表。但是与传统的文件系统相反，斜杠字符“/”在文件名中是允许的，因此处理目录列表的函数（例如，openDir(“/website”)）基本上只是过滤文件名，并保留以前缀（/website/）开始的那些文件。
然后，对于文件名，总共有32个字符限制。一个“\0”字符被保留用于c字符串终止符，因此留给我们31个可用字符长度。
综合起来，这意味着建议保持短文件名，不要使用深嵌套的目录，因为每个文件的完整路径（包括目录、“/”字符、基本名称、点和扩展名）最多只能是31个字符长度。例如，/website/images/bird_thumbnail.jpg 达到了34个字符长度，如果使用它，将导致一些问题。
警告：这个限制很容易达到，如果忽略，问题可能会被忽略，因为在编译和运行时不会出现错误信息。
3.2 文件系统文件添加方式
使用文件系统目的就是为了存储文件，那么存储文件的方式其实可以分为3种：
直接代码中调用FS提供的API在SPIFFS上创建文件；
通过 ESP8266FS 工具把文件上传到SPIFFS；
通过OTA Update的方式上传到SPIFFS；
本质上，无论是通过ESP8266FS或者OTA Update的方式把文件上传到SPIFFS，其底层都是通过调用FS提供的API去完成，所以我们只需要了解FS常用API即可。
4. SPIFFS库 了解一下SPIFFS文件系统常用的操作方法，以下是博主总结的百度脑图：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/06bb8c4ffd549a8fbb089e96c669e448/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eee34727e5d3253310a9199d9a6b765f/" rel="bookmark">
			【Android学习】将Android项目打包成APK
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 将Android项目打包成APK (app应用) 在Android Studio 中打开项目Build -&gt; Generate Signed Bundle / APK ... 选APK 点击 Create new ... 输入四次相同密码, 比如:zxc@123
ok , 等待打包完成! 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2668e8b2484eacfe82156f358ff54913/" rel="bookmark">
			Java每日面试题5题（一）—— 线程进程等相关篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 一、线程和进程的区别二、说说多线程？三、说说怎么保证线程安全？四、说说死锁定义和死锁的条件五、进程间的通信方式 一、线程和进程的区别 进程 进程是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。它是操作系统动态执行的基本单元，在传统的操作系统中，进程既是基本的分配单元，也是基本的执行单元
一个进程包括进程编号 PID(标识)、进程的状态、执行优先级、上下文、内存地址
线程 线程是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务
区别 1、从属关系不同：进程是正在运行程序的实例，进程中包含了线程，而线程中不能包含进程。
2、描述侧重点不同：进程是操作系统分配资源的基本单位，而线程是操作系统调度的基本单位。
3、资源共享不同：多个进程间不能共享资源，每个进程有自己的堆、栈、虚存空间(页表)、文件描述符等信息，而线程可以共享进程资源文件(堆和方法区)。
4、上下文切换速度不同：线程上下文切换速度很快(上下文切换指的是从一个线程切换到另一个线程)，而进程的上下文切换的速度比较慢。
5、操纵者不同：一般情况下进程的操纵者是操作系统，而线程的操纵者是编程人员。
二、说说多线程？ 什么是多线程 一个进程中包含多个线程执行不同的任务，线程是程序中一个单一的顺序控制流程，而多线程就是在单个程序中同时运行多个线程来完成不同的工作。
多线程是为了同步完成多项任务，不是为了提高运行效率，而是为了提高资源使用效率来提高系统的效率。多线程是在同一时间需要完成多项任务的时候实现的。
优点 1、加快程序运行速度，响应快，将耗时长的任务在后台运行，不影响其他任务执行，提高效率。
2、同一个程序的不同部分可以并发执行，释放资源如内存占用。
3、可以设置线程的优先级。
缺点 1、线程之间共享进程资源，容易造成死锁。
2、开辟线程需要占用内存，同时多个线程之间切换占用时间也会耗费系统内存。
3、线程的终止会对程序产生影响。
4、对多个线程的管理带来额外的CPU开销，多线程的使用给系统带来上下文切换的额外负担。
三、说说怎么保证线程安全？ 产生线程安全的原因 多个线程在访问同一个共享资源时，所产生的原子性、可见性和有序性的问题，使用程序运行过程中出现超出预期的结果。
原子性：一个或多个操作在CPU执行的过程中断。
可见性：一个线程对共享变量进行修改之后，另一个线程不能马上看到，拿到旧值。
有序性：程序的执行顺序没有安装代码顺序执行。
解决方法 1、使用加锁的形式实现线程互斥同步，如常用的synchronized、lock等
2、使用自旋CAS方式保证原子操作，实现共享变量的线程安全。
3、使用ThreadLocal实现线程之间的数据隔离。
4、尽量减少共享资源的使用。
四、说说死锁定义和死锁的条件 定义 死锁是指两个及以上的进程在执行的过程中，由于竞争资源互不想让而造成一种阻塞的现象，若无外力作用，则无限陷入僵持的局面。
死锁条件 1、互斥条件：进程之间互斥使用资源，一个资源只能一个进程使用，一旦某个资源被使用，则需要使用该资源的进程就会等待。
2、请求与保持条件：一个进程因请求资源发生阻塞时，不释放已有的资源。
3、不剥夺条件：进程在未使用完资源之前，其他进程不能抢夺该进程的资源。
4、循环等待条件：一组进程之间形成一种头尾相连的等待资源关系。
解决方法 1、死锁预防：通过设置限制条件，破坏产生死锁的四个条件之一即可预防死锁的发生。
2、死锁避免：系统对进程发出的每一个系统能够满足的资源申请进行动态检查，并根据检查结果决定是否分配资源；如果分配后系统可能发生死锁，则不予分配，否则予以分配。这是一种保证系统不进入死锁状态的动态策略。比较出名的有银行家算法。
3、死锁检测和解除：检测系统是否处于死锁状态，但处于死锁状态时，采取适当措施解除死锁
五、进程间的通信方式 管道FIFO消息队列信号量共享内存 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7acee0f229529862928d25472851516f/" rel="bookmark">
			QGIS把矢量图层分割为N个图层
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需求：每一条记录都另存为一个图层文件
工具：QGIS--工具箱---矢量通用----分割矢量图层
可以按照主键或者唯一ID进行拆分。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51a34c1096d84d5ae52389e3569fab75/" rel="bookmark">
			// 利用泰勒级数e=1&#43;1/1！&#43;1/2！....&#43;1/n!计算e的近似值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、题目 // 利用泰勒级数e=1+1/1！+1/2！…+1/n!计算e的近似值
二、代码 #include &lt;stdio.h&gt; int main(int argc, const char * argv[]) { // 利用泰勒级数e=1+1/1！+1/2！....+1/n!计算e的近似值 int i; float a=1,sum=1; for (i=1; a&gt;=1e-5; i++) { a/=i; sum+=a; } printf("e=%f n=%d\n",sum,i+1); return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab7ea605e3b301131fa35f144da9191c/" rel="bookmark">
			Webstorm配置autoprefixer插件-css3自动补全兼容前缀
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Webstorm配置autoprefixer插件-css3自动补全兼容前缀 流水式下载在webstorm中配置配置完了不要慌，还有一个最大最大最大的坑，配置兼容程度，需要改源文件使用方法建议配置快捷键，可以直接在当前文件操作按快捷键操作，很方便，如图： 流水式下载 windows键搜索cmd，打开命令窗口
第一步：安装node.js，这里不过多说明，相信大家都已经有了
第二步：安装Autoprefixer
npm install autoprefixer -g 第三步：安装postcss-cli
npm install postcss-cli -g 后续补充：如果完成整个操作还不行，试试再安装postcss
npm install postcss -g 在webstorm中配置 进入设置：File–&gt;setting–&gt;External Tools 点击"+"加号
下面是我的个人配置-windows10（请大家尽量严格按照我的配置来，避免掉坑）
Name: autoprefixer （注：复制的单词后面不要有空格）
Program：C:\Users\94492\AppData\Roaming\npm\postcss.cmd（其实就是你的电脑里postcss.cmd的文件路径，肯定是在AppData文件夹下，根据自己的实际路径进行调整）
Parameters：$FileName$ -u autoprefixer -o $FileName$
Working directory：$FileDir$
相信大家还看了许多其他的配置，还有一个配置版本是这样：
Name: autoprefixer
Program：C:\Users\94492\AppData\Roaming\npm\postcss.cmd
Parameters：-u autoprefixer -o $FileDir$\$FileName$ $FileDir$\$FileName$
Working directory：$ProjectFileDir$
以上两个我都测试了，没问题，大家自由选择
配置完了不要慌，还有一个最大最大最大的坑，配置兼容程度，需要改源文件 网上搜到的内容，大家复制来复制去的，就是不说这一点，气死宝宝了！
在autoprefixer安装包目录下的node_modules\browserslist\index.js
大家可以参考我的目录： C:\Users\94492\AppData\Roaming\npm\node_modules\autoprefixer\node_modules\browserslist
修改文件内的默认Default browsers query
这个其实是配置你想实现的兼容程度，默认的配置好像是浏览器们比较新的版本，所以当你执行兼容操作后，css文件没发生什么变化，你可以根据自己的需要自行配置！
browserslist.defaults = [ '&gt; 1%', "firefox &gt;= 8", "chrome &gt;= 24", "Opera &gt;= 10"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab7ea605e3b301131fa35f144da9191c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11e14467d6f7239a037f90a662555522/" rel="bookmark">
			Java基础：文件上传案例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文件上传案例的客户端: 读取本地文件,上传到服务器,读取服务器回写的数据
明确:
数据源:c:\\1.jpg
目的地:服务器
实现步骤:
1.创建一个本地字节输入流FileInputStream对象,构造方法中绑定要读取的数据源
2.创建一个客户端Socket对象,构造方法中绑定服务器的IP地址和端口号
3.使用Socket中的方法getOutputStream,获取网络字节输出流OutputStream对象
4.使用本地字节输入流FileInputStream对象中的方法read,读取本地文件
5.使用网络字节输出流OutputStream对象中的方法write,把读取到的文件上传到服务器
6.使用Socket中的方法getInputStream,获取网络字节输入流InputStream对象
7.使用网络字节输入流InputStream对象中的方法read读取服务回写的数据
8.释放资源(FileInputStream,Socket)
public class TCPClient { public static void main(String[] args) throws IOException{ //1.创建一个本地字节输入流FileInputStream对象,构造方法中绑定要读取的数据源 FileInputStream fis = new FileInputStream("day01-code\\5.png"); //2.创建一个客户端Socket对象,构造方法中绑定服务器的IP地址和端口号 Socket socket = new Socket("xxx.xxx.xxx.xxx",9999); //3.使用Socket中的方法getOutputStream,获取网络字节输出流OutputStream对象 OutputStream os = socket.getOutputStream(); //4.使用本地字节输入流FileInputStream对象中的方法read,读取本地文件 int len = 0; byte[] bytes = new byte[1024]; while ((len = fis.read(bytes))!= -1) { //5.使用网络字节输出流OutputStream对象中的方法write,把读取到的文件上传到服务器 os.write(bytes,0 ,len); } /* 解决:上传完文件,给服务器写一个结束标记 void shutdownOutput() 禁用此套接字的输出流。 对于 TCP 套接字，任何以前写入的数据都将被发送，并且后跟 TCP 的正常连接终止序列。 */ socket.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/11e14467d6f7239a037f90a662555522/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db000091421fe7db6e7869112358c4a6/" rel="bookmark">
			org.apache.shiro.authz.AuthorizationException: Not authorized to invoke method报错解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		踩坑日记： 在springboot+shiro 权限认证时报错
方案1（不行的话就用方案2）：
用户在没有权限的情况下，访问页面，shiro根据没有权限本抛出Subject does not have permission [xxxxx]错误,可以在拦截器一个错误处理方式，统一异常处理，没有权限就进入统一页面 shiroFilterFactoryBean.setUnauthorizedUrl("url");
方案2：在unauthorizedUrl 不起作用的情况下
2.1、设置自定义的异常解析器
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import org.apache.shiro.authz.UnauthenticatedException;
import org.apache.shiro.authz.UnauthorizedException;
import org.springframework.web.servlet.HandlerExceptionResolver;
import org.springframework.web.servlet.ModelAndView;
public class DiyExceptionHandler implements HandlerExceptionResolver {
@Override
public ModelAndView resolveException(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) {
if (e instanceof UnauthorizedException) { // 未授权 : 403页面
ModelAndView mv = new ModelAndView("/403");
return mv;
} else if (e instanceof UnauthenticatedException) { // 未登录 : 401登录页面
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/db000091421fe7db6e7869112358c4a6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3cd6776b08b1d617a5b903241ceb846/" rel="bookmark">
			设备接入EasyGBS平台后请求实时流播放，出现超时是什么原因？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		EasyGBS是基于公安部推出的安防主流协议（国标GB28181协议）的视频接入、处理及分发平台，具有视频直播监控、云端录像、云存储、检索回放、智能告警、语音对讲等功能，能够涵盖所有监控领域的视频能力需求，已经在大量的项目中落地应用，如明厨亮灶、平安乡村、雪亮工程等。
有用户反馈，EasyGBS平台接入某设备后，在请求实时流播放时，出现了超时的情况，请求我们协助排查。今天和大家分享一下排查及解决流程。
将设备接入到EasyGBS平台后，发现拉取实时流总是超时。排查时发现，设备没有发流数据，于是替换为接入EasyCVR平台做对比测试，此时拉取实时流视频可以正常播放。
对比Invite消息发现，在Message Bady sdp.owner.address为域名时，设备就不发流数据，当sdp.owner.address为IP时，这个设备就能正常发流数据。于是针对这个细节进一步排查，原来是该设备不支持域名解析，所以当sdp.owner.address为域名时，设备自然就没有办法发送流数据到收流服务器了。以下是invite消息对比：
sdp.owner.address为IP：
sdp.owner.address为域名：
解决办法：将wan_ip设置为IP，或者将use_wan_recv_stream设置为0，即能解决这个问题。
修改后，设备已经能正常发流，平台可以正常播放实时流视频了。
EasyGBS强大的视频能力既可以作为业务平台，也能作为视频能力平台进行调用，功能十分灵活，平台支持多路设备接入，并对多平台、多终端分发出RTSP、RTMP、FLV、HLS、WebRTC等多种格式的视频流，是安防市场主流的视频监控平台。感兴趣的用户可以前去演示平台进行体验或部署测试，欢迎大家的关注。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e37c5d32b528ac48a1aed12d010dfdae/" rel="bookmark">
			MySQL之binlog
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		binlog是什么？它是一个日志，一个归档日志，一个二进制日志，一个逻辑日志，一个server层日志。表示看完了没什么感觉，能动手的最好别bb。看看它能干什么。
建议先打开你的数据库客户端或者“黑窗口”什么的，连接并且登录数据库。
作用：恢复数据，避免删库跑路。
还是来先看看你的数据库有没有开启binlog功能。
SHOW VARIABLES LIKE '%log_bin%'; 看到这里的ON了吗？恭喜你，你的数据库开启了binlog，为你的数据安全增加了一份保障。如果是OFF，那么参考官方文档或者自行搜索开启binlog配置（本人windows 5.7.12版本因不知名原因配置后无法启动服务就不写配置方法了）。
binlog有三种格式（哪三种方式自行搜索），方式：
SHOW VARIABLES LIKE '%binlog_format%'; 如果你已经配置成功，那么找一个不怎么重要的库里的不怎么重要的表增删改数据看看如果用binlog恢复它们。
我执行了一个update：
看上面的截图log_bin_basename，进到这个目录下面查看可以看到一堆：
通过文本方式打开它，会发现一堆乱七八糟的东西，因为它是二进制日志。使用mysqlbinlog命令查看：
mysqlbinlog -v --start-datetime="2022-06-01 15:00:00" --stop-datetime="2022-06-01 15:30:00" ../data/binlog.000243 &gt; ../data/temp.log 注意：本文所有操作皆在windows下进行的。mysqlbinlog在bin目录下，需要进入bin目录执行；日期用双引号，要找准日志文件的位置，temp.log是一个临时转存文件。
我这里看到一些这样的东西，看下@1、@2、@3分别对应了表里的字段，重点看下@1、@3（不要在意乱码，我数据库数据本身就这样）。实际上这一堆东西就是伪sql，一堆执行逻辑（逻辑日志）。将它们整理好，放到客户端执行就可以恢复修改的数据了。
mysqlbinlog语法：
mysqlbinlog [options] log-files
options：可选参数
log-files：文件名称
[options]常用值：
-d: 根据数据库的名称筛选日志
-o：跳过前N行日志
-r, --result-fil: 把日志输出到指定文件
–start-datetime: 读取指定时间之后的日志，时间格式：yyyy-MM-dd HH:mm:ss
–stop-datetime: 读取指定时间之前的日志，时间格式：yyyy-MM-dd HH:mm:ss
–start-position: 从指定位置开始读取日志
–stop-position: 读取到指定位置停止
–base64-output：在row格式下，显示伪sql语句
-v, --verbose：显示伪sql语句，-vv可以为sql语句添加备注
–set-charset：设置输出文件编码
主从架构需要用到
（没有实际操作过，暂时就不写了）。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62ad5ba7fbbe5597051f70546c1b4d3c/" rel="bookmark">
			解决opencv源代码编译找不到ffmpeg
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系统环境： 操作系统：Ubuntu18.04
硬件架构：X86_64
OpenCV版本：4.5.1或3.4.16
项目场景： 最近在研究OpenCV结合CUVIDEC解码视频流，就使用OpenCV源代码编译。结果发现无论如何都找不到ffmpeg。经过一系列研究终于找到了原因，记录如下。
问题描述 OpenCV4和OpenCV3编译当选择WITH_FFMPEG选项的时候不能找到ffmpeg模块。
原因分析： OpenCV-3.4.16和OpenCV-4.5.1两个版本略有差别，这个问题的答案我们可以在OpenCV的cmake文件里面找到答案。
先来看看opencv-3.4.16的cmake文件，在opencv-3.4.16的cmake文件夹下面找到OpenCVFindLibsVideo.cmake
# --- FFMPEG --- ocv_clear_vars(HAVE_FFMPEG) if(WITH_FFMPEG) # try FFmpeg autodetection if(OPENCV_FFMPEG_USE_FIND_PACKAGE) if(OPENCV_FFMPEG_USE_FIND_PACKAGE STREQUAL "1" OR OPENCV_FFMPEG_USE_FIND_PACKAGE STREQUAL "ON") set(OPENCV_FFMPEG_USE_FIND_PACKAGE "FFMPEG") endif() find_package(${OPENCV_FFMPEG_USE_FIND_PACKAGE}) # Required components: AVCODEC AVFORMAT AVUTIL SWSCALE if(FFMPEG_FOUND OR FFmpeg_FOUND) set(HAVE_FFMPEG TRUE) else() message(STATUS "Can't find FFmpeg via find_package(${OPENCV_FFMPEG_USE_FIND_PACKAGE})") endif() elseif(WIN32 AND NOT ARM AND NOT OPENCV_FFMPEG_SKIP_DOWNLOAD) include("${OpenCV_SOURCE_DIR}/3rdparty/ffmpeg/ffmpeg.cmake") download_win_ffmpeg(FFMPEG_CMAKE_SCRIPT) if(FFMPEG_CMAKE_SCRIPT) set(HAVE_FFMPEG TRUE) set(HAVE_FFMPEG_WRAPPER 1) include("${FFMPEG_CMAKE_SCRIPT}") endif() elseif(PKG_CONFIG_FOUND) ocv_check_modules(FFMPEG libavcodec libavformat libavutil libswscale) ocv_check_modules(FFMPEG_libavresample libavresample) if(FFMPEG_libavresample_FOUND) ocv_append_build_options(FFMPEG FFMPEG_libavresample) endif() else() message(STATUS "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/62ad5ba7fbbe5597051f70546c1b4d3c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10675c40dd7091948b477f2cc811d982/" rel="bookmark">
			Android 编程入门笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0. 环境问题
Android Studio error "Installed Build Tools revision 31.0.0 is corrupted" - Stack Overflow
Android Studio 4.1 Run窗口中文乱码解决办法_健飞的博客-CSDN博客
1. Android报错META-INF/DEPENDENCIES 参考 Android报错META-INF/DEPENDENCIES_guaguaguayyx的博客-CSDN博客​​​​​​
2. 文件读写
将数据以普通文件的形式保存在 /data/data/包名中，该方法不需要申请权限。
Android 文件读写最全解析_Teacher.Hu的博客-CSDN博客_android 文件读写
3. Android开发8——利用pull解析器读写XML文件
Android开发8——利用pull解析器读写XML文件 - CodeAntenna
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e7dd884924750a382c6ea6d56e14eda/" rel="bookmark">
			宝塔面板安装WordPress
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、添加网站 首先点击左侧网站，然后添加站点
这里域名填写自定义域名，选择数据库，这里会自动提供账号和密码，然后PHP版本选择PHP-80 二、配置网站 点击修改进入站点修改弹窗界面
进入网站目录，取消防跨站攻击
进入伪静态，选择wordpress并保存
三、下载WordPress https://cn.wordpress.org/download/
四、上传并解压WordPress程序 点击当前网站的根目录即可进入
删除自动生成的文件
选择上传，将刚刚下载的压缩包上传
右键选择压缩包进行解压
五、将文件移动到根目录 首先进入WordPress目录
选择全部文件，然后剪切
返回根目录，即上一级目录，粘贴全部 六、安装WordPress 浏览器进入，在地址栏里面输入你的网站绑定的域名或者IP加端口号，进入后点击现在就开始 输入数据库用户名和密码提交即可，用户名和密码创建站点的时候有提供！
进入下一步，运行安装程序
安装完成后，输入账号密码进入后台
登录成功后，即可访问后台
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1662e6689660ce7ae8f4ec3c0ecf5781/" rel="bookmark">
			OpenCV3.0中有哪些视频背景/前景分割(背景建模/前景提取)算法的类,它们各自的算法原理、特点是什么,并附示例代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于OpenCV3中有哪些视频背景/前景分割(背景建模/前景提取)算法的类，汇总如下：
cv::Algorithm
cv::BackgroundSubtractor
cv::BackgroundSubtractorKNN
cv::BackgroundSubtractorMOG2
cv::cuda::BackgroundSubtractorMOG2
cv::bgsegm::BackgroundSubtractorGMG
cv::bgsegm::BackgroundSubtractorMOG
cv::cuda::BackgroundSubtractorFGD
cv::cuda::BackgroundSubtractorGMG
cv::cuda::BackgroundSubtractorMOG
上面的汇总不仅显示了OpenCV3.0中有哪些视频背景/前景分割(背景建模/前景提取)算法的类，还显示了它们的继承、派生关系。
每一种具体的算法实现类都是继承于类cv::BackgroundSubtractor，而类cv::BackgroundSubtractor又继承于cv::Algorithm。
接下来分别介绍：
目录 cv::BackgroundSubtractorKNNcv::bgsegm::BackgroundSubtractorMOGcv::cuda::BackgroundSubtractorMOGcv::BackgroundSubtractorMOG2cv::cuda::BackgroundSubtractorMOG2cv::bgsegm::BackgroundSubtractorGMGcv::cuda::BackgroundSubtractorGMGcv::cuda::BackgroundSubtractorFGD cv::BackgroundSubtractorKNN cv::BackgroundSubtractorKNN利用K近邻(K-nearest neigbours)思想实现的背景建模。
其算法原理、成员函数介绍和示例代码见博文 https://blog.csdn.net/wenhao_ir/article/details/125007017
cv::bgsegm::BackgroundSubtractorMOG cv::bgsegm::BackgroundSubtractorMOG是基于混合高斯模型的背景与前景分割算法。
其算法原理、成员函数介绍和示例代码见博文 https://blog.csdn.net/wenhao_ir/article/details/125010301
cv::cuda::BackgroundSubtractorMOG cv::cuda::BackgroundSubtractorMOG是cv::bgsegm::BackgroundSubtractorMOG的CUDA实现。
cv::BackgroundSubtractorMOG2 cv::BackgroundSubtractorMOG2是混合高斯背景建模的改进版，该类实现了自适应高斯混合模型参数的更新，增强了复杂场景背景检测的性能。同时它为每个像素选择适当数量的高斯分布，它能更好的适应由于照明变化产生的不同场景。
其算法原理、成员函数介绍和示例代码见博文 https://blog.csdn.net/wenhao_ir/article/details/125017245
cv::cuda::BackgroundSubtractorMOG2 cv::cuda::BackgroundSubtractorMOG2是cv::BackgroundSubtractorMOG2的CUDA实现。
cv::bgsegm::BackgroundSubtractorGMG cv::bgsegm::BackgroundSubtractorGMG是利用下面这篇论文的算法实现的：
Andrew B Godbehere, Akihiro Matsukawa, and Ken Goldberg. Visual tracking of human visitors under variable-lighting conditions for a responsive audio art installation. In American Control Conference (ACC), 2012, pages 4305–4312. IEEE, 2012.
论文的标题翻译过来为：在不同光照条件下对访客进行视觉跟踪，以便得到灵敏的音频艺术装置。后边半句话我们不明白是啥意思，什么叫“灵敏的音频艺术装置”，看了下面的论文摘要应该就懂了。
该论文的摘要链接：https://link.springer.com/chapter/10.1007/978-3-319-03904-6_8
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1662e6689660ce7ae8f4ec3c0ecf5781/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef3236724af457a7c652ac4ac7b540d5/" rel="bookmark">
			在线音频mp3、视频mp4测试地址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列文章目录 在线音频mp3、视频mp4测试地址
一、在线音频mp3测试地址
http://music.163.com/song/media/outer/url?id=447925558.mp3
https://www.cambridgeenglish.org/images/153149-movers-sample-listening-test-vol2.mp3
https://www.cambridgeenglish.org/images/506891-a2-key-for-schools-listening-sample-test.mp3
http://downsc.chinaz.net/Files/DownLoad/sound1/201906/11582.mp3
http://downsc.chinaz.net/files/download/sound1/201206/1638.mp3
二、在线视频mp4测试地址
http://video.chinanews.com/flv/2019/04/23/400/111773_web.mp4
https://media.w3.org/2010/05/sintel/trailer.mp4
http://clips.vorwaerts-gmbh.de/big_buck_bunny.mp4
http://vjs.zencdn.net/v/oceans.mp4
http://vfx.mtime.cn/Video/2019/03/19/mp4/190319212559089721.mp4
http://vfx.mtime.cn/Video/2019/03/18/mp4/190318231014076505.mp4
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9891d88aec321b3be921bf0efc3a428c/" rel="bookmark">
			mysql查询怎么区分大小写
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mysql中查询默认是区分大小写的，但是在mysql中默认不区分大小写。
解决办法：
mysql可以在SQL语句中加入 binary来区分大小写。BINARY不是函数，是类型转换运算符，它用来强制它后面的字符串为一个二进制字符串，可以理解为在字符串比较的时候区分大小写。
一、查询语句上加binary
select * from users WHERE binary user_name = '张三' AND status != 0 二、建表时加binary
create table t { code varchar(10) binary } ALTER TABLE t_order CONVERT TO CHARACTER SET utf8 COLLATE utf8_bin; 执行完上面的sql后，对该表的查询就能区分大小写了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23b7d05b8bcf08b2916c577dae2d28f8/" rel="bookmark">
			brpc组件bvar源码解析（四）Sampler、SamplerCollector和Window类簇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.Sampler类 Sampler是所有采样类的基类。采样类中最重要的是take_sample函数，采样类的schedule函数调用之后，它的take_sample函数将会被一个专门的线程每1秒定时调用。
Sampler类的定义：
Sampler是一个纯虚类，take_sample是纯虚函数需要子类实现。
Sampler继承自LinkNode，即拥有了previous_和next_指针，可以作为双向链表的节点。
Sampler有两个成员变量，一个是_used表示当前采样类是否生效；一个是_mutex保护_used。
构造函数、析构函数和destroy函数 默认_used设为true。
如果采样类不再使用，则调用其destroy函数，设置_used为false，实现延迟删除，至于从哪里删除，后面会讲到。
schedule函数： 注册当前采样类的地址到全局单例SamplerCollector中，后面讲到SamplerCollector时再详细介绍内部实现。
2.Sample类 定义：
这个类很简单，保存了bvar的类型T的值data，和时间time_us。它用于保存一次采样的结果和采样时的时间。
3.SamplerCollector类 定义：
上面的注释可以帮助理解为什么SamplerCollector要设计成继承自Reducer。正常情况我们一般的实现是这样，用一个容器C保存所有注册的采样类和一个mutex M保护，设置定时线程来定期采样。但是这个性能不好，每次开始采样前都要用M加锁保护，以至于创建Window&lt;&gt;（创建Window&lt;&gt;是会创建sampler类、并注册到SamplerCollector中）需要等锁释放。如果想让创建Window&lt;&gt;的开销可以忽略不计，还需要更好的方案。
这里就提供了一个更好的方案，就是继承自Reducer&lt;Sampler*, CombineSampler&gt;。这样SamplerCollector就是一个bvar，保存的是Sampler*，累加器是CombineSampler，看一下CombineSampler的实现：
前面说了Sampler*是可以作为双向链表的节点的。CombineSampler的两个参数是2个双向链表，它的操作就是把两个双向链表连接起来。
综合上面的信息，SamplerCollector继承自Reducer&lt;Sampler*, CombineSampler&gt;之后，调用operator&lt;&lt;函数可以轻易的添加Sampler到stl数据中，这个过程是没有锁的，就解决了前面说的问题：想让创建Window&lt;&gt;的开销可以忽略不计；调用get_value函数可以通过累加器CombineSampler将所有的Sampler组成一个双向链表。
成员变量 _created：是否创建了采样线程
_stop：是否需要退出采样线程中的循环
_cumulated_time_us：采样线程中遍历所有的Sampler*进行采样花费的时间的总和
_tid：采样线程id
函数create_sampling_thread SamplerCollector类的构造函数中就调用了函数create_sampling_thread。
实现：
（1）创建采样线程执行函数sampling_thread
（2）如果采样线程创建成功，则通过pthread_atfork注册当fork子进程时在子进程上下文中fork函数返回之前调用child_callback_atfork函数
A）child_callback_atfork函数中创建全局SamplerCollector单例，并调用其after_forked_as_child函数
B）after_forked_as_child中重置_created为false，并调用create_sampling_thread以实现在子进程中创建采样线程。
采样线程执行run函数 采样线程首先调用的函数sampling_thread，它的实现很简单就是调用SamplerCollector::run函数：
所以看run函数：
1.获得所有的Sampler
1）调用SamplerCollector::reset函数，Reducer::reset函数中执行了_combiner.reset_all_agents，通过前文知道它把所有stl保存的Sampler*连接成一个双向链表s返回，原来的保存的地方重置为null。
2）reset函数返回的双向链表s和root连接到一起。即root是之前就已经获得的所有的Sampler构造的双向链表，s是最新加入的Sampler构造的双向链表。
2.遍历所有的Sampler
1）遍历root中的所有Sampler，判断是否被destroy（_used字段），如果是，则从root中删除、并delete，否则进行2）
2）调用Sampler::take_sample进行采样操作，take_sample是Sampler具体子类实现的
3.sleep
1）如果上述全过程花费的时间不超过1s，则sleep多余的时间
2）如果花费超过1s，则consecutive_nosleep+1，consecutive_nosleep超过WARN_NOSLEEP_THRESHOLD（默认值2）时打印log
4.ReducerSampler类 ReducerSampler是Sampler类的子类，定义如下：
继承自Sampler，有4个模板参数：
R：一般就是Reducer类或Reducer子类
T、Op、InvOp：Reducer类的三个模板参数
成员变量：
_reducer：保存传入的R类型对象指针
_window_size：窗口大小
_q：保存所有Sample的有界队列（即循环队列）；当容量全部有值、再加入新增时将替换最早加入的值。
构造函数 初始化_reducer，设置_window_size为1；调用take_sample。
函数take_sample 函数是具体的采样操作。
1._q容量不足_window_size，则扩容量
2.获得_reducer最新值
1）如果没有反向op，例如Maxer、Miner，则获得当前的最新值返回、并重置原保存的值
2）如果有反向op，例如Adder，则获得当前的最新值返回即可，之后需要窗口内的值时可以通过反向op操作来得到
3）无论有没有反向op都可以通过1）来实现，但是对于有反向op的，用2）效率会更高
3.加入到_q中
1）保存当前时间（采样时间）到time_us
2）采样结果Sample保存到_q中
函数get_value 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/23b7d05b8bcf08b2916c577dae2d28f8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa6a2df4a8f04c2097cc35bccd7418d7/" rel="bookmark">
			Java实现双向链表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
大家好！欢迎大家来到利物浦痛失欧冠冠军的第一期文章。
一、双向链表的简单理解
1、双向链表是什么？
2、双向链表长什么样子？
二、代码演示
1、结点的构建
2、链表的创建
3、打印链表
4、得到链表长度
5、查找元素
6、插入元素
（1）、头插法
（2）、尾插法
（3）、中间插入
7、删除元素
（1）、删除元素为头结点。
（2）、删除元素为中间结点或者尾巴结点
三、总结
大家好！欢迎大家来到利物浦痛失欧冠冠军的第一期文章。 一、双向链表的简单理解 1、双向链表是什么？ 在前面的文章中，我们仔细讲解了单向链表，并且用代码实现了单向链表。单向链表的好处很多，虽然单链表能 100% 解决逻辑关系为 "一对一" 数据的存储问题，但在解决某些特殊问题时，单链表并不是效率最优的存储结构。比如说，如果算法中需要大量地找某指定结点的前趋结点，使用单链表无疑是灾难性的，因为单链表更适合 "从前往后" 找，而 "从后往前" 找并不是它的强项，因此我们就有了双向链表这个东西，双向链表顾名思义就是链表的高级版，他与单向链表有所不同的一点在于在具有尾巴结点，并且双向链表的每一个结点都会有两个指向，一个指向前面的结点，一个指向后面的结点，当然头结点的前端指向为null，后结点的后端指向为null。
2、双向链表长什么样子？ 双向链表的一个结点，具有包括三个信息：1、前端指针域。2、数据域。3、后端指针域
如图所示
双向链表正是由这些一个个结点组合而成
接下来我们将会用代码的方式来实现双向链表
二、代码演示 1、结点的构建 和单向链表一样，链表的实现离不开结点，这构建也与单向链表相似，只不过不同的是我们需要加一个前端指针
class ListNode{ public ListNode prev; public ListNode next; public int val; public ListNode(int num){ this.val = num; } public ListNode(){ } } 2、链表的创建 链表的创建中有个很重要的东西，就是我们需要给链表设置一个头结点指针与尾巴结点指针，因为链表初始化只有一个结点，因此头结点指针 == 尾巴结点指针
public ListNode head; public ListNode last; public TowWayNodeList(int num){ this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fa6a2df4a8f04c2097cc35bccd7418d7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32200dd6791dd3a313dbbc6e1ae30423/" rel="bookmark">
			Spring Boot 企业级开发课后题答案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一章
1.1 填空题
Pivotal 团队在原有 spring 框架的基础上开发了全新的Spring Boot框架。
Spring Boot框架在开发过程中大量使用 约定优先配置 的思想来摆脱框架中各种复杂的手动配置。
Spring Boot 2.1.3版本要求Java 8 及以上版本的支持。
Spring Boot2.1.3版本框架官方声明支持的第三方项目构建工具包括有 maven(3.3+) 和 gradle(4.4+)
@RestController 注解是一个组合注解，主要包含 @Controller 和 @ResponseBody 两个核心注解。
1.2 判断题
Spring Boot 2.1.3版本要求Java7及以上版本的支持，同时兼容Java 11。(错)
使用Spring Initializr搭建Spring Boot项目，可以选择任意不同的Spring Boot版本，而无须修改。(错)
使用Spring Initializr 搭建的Spring Boot项目会默认生成项目启动类。( 对 )
编写单元测试需要提前加入spring- boot-starter-test测试依赖启动器。(对)
Spring Boot提供了对所有第三方技术框架的整合支持和版本管理。(错)
1.3 选择题
以下选项中，哪些属于Spring Boot的优点? (ACD)( 多选)
A.可快速构建独立的Spring应用
B.无须打包即可快速部署
C.提供依赖启动器简化构建配置
D.极大程度地自动化配置了Spring和第三方库
IDEA 界面中，[Configure 1-[Projet Deiauts 1中的Poiet Sucture主要作用是(D)
A.用于全局JDK初始化设置
B.用于全局Maven初始化设置
C.用于全局运行环境设置
D.以上都不对
下列关于Sping Boo项目各个包作用的说法， 正确的是( ABCD)(多选)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/32200dd6791dd3a313dbbc6e1ae30423/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a8dce22084c0cff22570e671ba1b63a/" rel="bookmark">
			添加删除数组元素的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.push()：在数组的末尾添加一个或多个数组元素
2.unshift（）数组开头 添加一个或多个数组元素
3.pop（） 删除最后一个元素
4.shift（） 删除第一个元素 总结
添加删除数组元素的方法
1.push()：在数组的末尾添加一个或多个数组元素 代码如下（示例）： 结果如下：
2.unshift（）数组开头 添加一个或多个数组元素 代码如下（示例）： 结果如下：
3.pop（） 删除最后一个元素 注意：没有参数，一次只能删除一个元素！
返回值为删除的那个元素
代码如下（示例）：
结果如下：
4.shift（） 删除第一个元素 注意：也是没有参数的！shift完毕之后，返回的结果是删除的那个元素
代码如下（示例）：
结果如下：
总结 以上就是今天要讲的内容，本文仅仅简单介绍了添加和删除数组的元素，我们要特别注意的一点是：添加的返回值是新数组的长度，删除的返回值是删除的元素。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe14d086fe16b3dfd8cc726bc5b269d6/" rel="bookmark">
			云计算网络管理实战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、通信的标准1
1、OSI、TCP/IP参考模型
1、早期的网络设备
2、ISO国际标准化组织OSI：开放式系统互联（一套标准）
3、OSI七层模型
4、TCP/IP模型
2、网络基础
名词介绍
3、数据通信过程
数据封装过程
二、通信的标准2
1、传输协议
1、定义：
2、tcp传输过程
3、TCP建立连的过程
4、TCP关闭连接的过程
5、TCP异常情况
6、UDP协议简介
三、通信的标准3
1、HTTP
1、协议简介
2、主要特点
3、http协议常见状态码
四、认识ip地址
五、十进制与二进制的转换
六、VLSM子网掩码
一、通信的标准1 1、OSI、TCP/IP参考模型 1、早期的网络设备 中继器、多协议网关（路由器的前身）
2、ISO国际标准化组织OSI：开放式系统互联（一套标准） TCP/IP：传输协议
协议：等同于标准
网络的设计：带宽高、安全性高、时效性、完整性、准确性
3、OSI七层模型 应用层：针对应用约定的标准
HTTP：超文本传输协议Telnet：远程协议OICP：qq的协议HTTPS：安全超文本传输协议SMTP/POP3：简单邮件传输协议（发）/邮局协议（收） 表示层：约束数据格式，负责格式转化，加密以及解密
会话层：建立、维护、解除会话，数据的传输通道
传输层：约定数据采用哪种方式进行传输
TCP：传输控制协议，实现数据的可靠传输UDP：用户数据报协议，实现数据的快速传输，不可靠 网络层：提供逻辑地址（IP地址，用于在网络中唯一的标识一台设备，作用于网络与网络之间的通信，提供路由和选路）
数据链路层：提供mac（物理地址）用于在一条链路上唯一的标识一台设备，作用于网络内的通信。
MAC地址烧写在网卡，全球唯一，MAC地址的有效范围仅限于本网络。 物理层：约定接口类型，传输速度，线缆针脚等
4、TCP/IP模型 应用层：将OSI上三层融合，用于产生需要传递的数据
传输层
网络层
网络接口层：将OSI下两层融合
2、网络基础 名词介绍 交换机：用于连接统一网络的设备，实现同网络内设备通信
路由器：用于连接不同的网络，隔离广播域，实现跨网络通信
网关：网络的出口
DNS：域名服务器（保存域名和IP地址之间的对应关系）
端口号：0-65535（在传输层中）实际可用1-65534
常见端口：http80、443https、53DNS、23Telnet 、ftp（20、21）、ssh22 、mysql3306、php9000、tomcat8080（8005、8009）、zabbix（10050、10051）用来区分不同的应用程序
3、数据通信过程 数据封装过程 可靠传输
http client————&gt;Router——&gt;http server
（http://www.baidu.com）因为数据为http所以数据要求为可靠从传输，由传输层对数据封装成TCP形成数据包
应用层产生一个数据，向外发送一个请求百度的指令（DATA——&gt;（加一个tcp））TCP+DATA——&gt;形成数据段——&gt;IP+TCP+DATA（IP地址包含源ip地址和目的ip地址）——&gt;形成数据包——&gt;帧头+IP+TCP+DATA+帧尾（帧头里有源mac地址和目的mac地址{通过ARP获取}）——&gt;形成数据帧（数据链路层对数据包进一步封装帧头和帧尾，形成数据帧）——&gt;（物理层将数据帧转化为比特流（一串二进制数），从网卡接口发出）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fe14d086fe16b3dfd8cc726bc5b269d6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/634ab5e28d63112314b0600952d5742a/" rel="bookmark">
			在 Java 中动态拼写 SQL 语句的模糊查询条件时，为啥需要使用 concat 函数拼接的简单解释
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 Java 项目中，使用 JDBC 连接数据库查询数据时，往往会使用动态 SQL 语句进行查询，这样可以有效防止 SQL 注入攻击。
比如一般的使用方式如下：
// 创建数据库连接... // 编写 SQL 语句 String sql = "SELECT * FROM provider WHERE p_name = ?"; // 创建预编译 statement PreparedStatement statement = conn.prepareStatement(sql); // 占位符赋值（按顺序给第1、2个？号赋值） statement.setObject(1, "美宜佳"); // 执行查询语句，获取结果集 ResultSet resultSet = statement.executeQuery(); // 结果集解析... 但是当查询条件为模糊查询时，为啥需要使用 concat 函数来拼接呢？如下
String sql = "SELECT * FROM provider WHERE p_name LIKE CONCAT('%',?,'%')"; 首先看一下如果不使用 concat 拼接，查询结果会是什么
直接抛异常了，可以看到，实际执行 SQL 语句时，条件似乎变成了 '%'条件值'%'（%被添加了单引号）原因暂时还没弄清楚。
使用 concat 函数拼接后再查询，成功获取到结果集
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/844c7dc94ef0cd2995c45c20e25bbdc8/" rel="bookmark">
			springboot集成swagger，出现 No mapping for GET /swagger-ui.html的错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在尝试降低springboot版本和swagger版本都无法解决这个问题后
&lt;dependency&gt;
&lt;groupId&gt;io.springfox&lt;/groupId&gt;
&lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt;
&lt;version&gt;2.9.2&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
&lt;groupId&gt;io.springfox&lt;/groupId&gt;
&lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt;
&lt;version&gt;2.9.2&lt;/version&gt;
&lt;/dependency&gt;
在SpringBoot项目引入Swagger2后，在浏览器地址里输入地址：http://ip:port/swagger-ui.html 报错：
控制台出现这样子的错误：swagger No mapping for GET /swagger-ui.html
解决办法：
1、在配置类中继承WebMvcConfigurationSupport类，重写addResourceHandlers方法
@Override
public void addResourceHandlers(ResourceHandlerRegistry registry) {
registry.addResourceHandler("doc.html")
.addResourceLocations("classpath:/META-INF/resources/");
registry.addResourceHandler("swagger-ui.html")
.addResourceLocations("classpath:/META-INF/resources/");
registry.addResourceHandler("/webjars/**")
.addResourceLocations("classpath:/META-INF/resources/webjars/");
}
访问成功
————————————————
版权声明：本文为CSDN博主「Aige_hml」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/Aige_hml/article/details/124017391
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40078c2b9252a4065c762c4e4b091e91/" rel="bookmark">
			排他思想详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		核心思路一 获取目标元素，得到一个存储元素对象数的组；我们先把所有目标元素的指定样式初始化 （干掉所有人）；再重新给指定的元素对象添加自己想要的样式（留下我自己）； 这种写法有个致命的缺点，就是每次运行此代码都会遍历一次数组，去掉每个元素的样式（包括自己），然后再给指定的元素添加样式，浏览器的重复执行了很多任务，代码运行效率不高。
示例：
&lt;button&gt;按钮1&lt;/button&gt; &lt;button&gt;按钮2&lt;/button&gt; &lt;button&gt;按钮3&lt;/button&gt; &lt;button&gt;按钮4&lt;/button&gt; &lt;button&gt;按钮5&lt;/button&gt; &lt;script&gt; // 1. 获取所有按钮元素，btns得到的是伪数组 里面的每一个元素 btns[i] let btns = document.getElementsByTagName('button'); // 给每个元素添加点击事件 for (let i = 0; i &lt; btns.length; i++) { btns[i].onclick = function() { // 2. 我们先把所有的按钮背景颜色去掉 干掉所有人 for (let j = 0; j &lt; btns.length; j++) { btns[j].style.backgroundColor = ''; } // 3. 然后才让当前的元素背景颜色为pink 留下我自己 this.style.backgroundColor = 'pink'; } } &lt;/script&gt; 核心思路二： 遍历每一个目标元素，判断这个元素与 this 是不是同一个；是则修改样式，不是则初始化样式。
// 获取所有按钮元素，btns得到的是伪数组 里面的每一个元素 btns[i] let btns = document.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/40078c2b9252a4065c762c4e4b091e91/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6196eb8512b0f908f21055f5899aac0/" rel="bookmark">
			?: (admin.E403) A ‘django.template.backends.django.DjangoTemplates‘ instance must be configured in T
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		jianja2 TEMPLATES问题解决 问题解决方案原代码学习jianja2修改的最终修复方案 问题 在学习jianja2的时候，运行项目报错如下：
?: (admin.E403) A ‘django.template.backends.django.DjangoTemplates’ instance must be configured in TEMPLATES in order to use the admin application.
翻译一下，大概就是说：django的实例必须在TEMPLATES中配置才能使用管理应用。
解决方案 原代码 TEMPLATES = [ { 'BACKEND': 'django.template.backends.django.DjangoTemplates', 'DIRS': [], 'APP_DIRS': True, 'OPTIONS': { 'context_processors': [ 'django.template.context_processors.debug', 'django.template.context_processors.request', 'django.contrib.auth.context_processors.auth', 'django.contrib.messages.context_processors.messages', ], }, }, ] 学习jianja2修改的 TEMPLATES = [ { # 'BACKEND': 'django.template.backends.django.DjangoTemplates', 'BACKEND': 'django.template.backends.jinja2.Jinja2', 'DIRS': [], 'APP_DIRS': True, 'OPTIONS': { 'context_processors': [ 'django.template.context_processors.debug', 'django.template.context_processors.request', 'django.contrib.auth.context_processors.auth', 'django.contrib.messages.context_processors.messages', ], 'environment': 'meiduo_mall.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c6196eb8512b0f908f21055f5899aac0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92faa28c766528bef7b76b3822faf68a/" rel="bookmark">
			SVN服务器搭建、备份以及还原
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、软件下载与安装 最好用VisualSVN server 服务端和 TortoiseSVN客户端搭配使用。
1.1 VisualSVN server 服务端下载地址 （官网下载地址）：https://www.visualsvn.com/server/download/
1.2TortoiseSVN客户端下载地址 （官网下载地址）：http://tortoisesvn.net/downloads.html
1.3 安装VisualSVN server 服务端 先安装VisualSVN server的安装包,双击VisualSVN server安装包,如图:
点Next,进入下一步,如图:
点同意,进图下一步,如图:
选择上面一个选项,点Next,进入下一步,如图:
Location是指VisualSVN Server的安装目录,Repositorys是指定你的版本库目录。Server
Port指定一个端口,Use secure connection勾山表示使用安全连接,Use Subversion
authentication 表示使用Subversion自己的用户认证。
点击Next,进入下一步,如图:
点Install,进入下一步,如图:
等待安装完成,如图:
安装完成后,启动VisualSVN Server Manager,如图:
1.4 安装TortoiseSVN 客户端 安装TortoiseSVN,双击安装包,进入下一步.如图:
点击Next,进入下一步,如图:
选择接受,然后点击Next,进入下一步,如图:
选择安装路径,然后点击Next,进入下一步,如图:
点击Install,开始安装,如图:
等待安装完成,安装完成后如图:
二、搭建服务器 2.1 创建版本库（创建PC版本库为例） 首先打开VisualSVN Server Manager,如图:
可以在窗口的右边看到版本库的一些信息,比如状态,日志,用户认证,版本库等.要建立版本库,需要右键单击左边窗口的Repositores,如图:
在弹出的右键菜单中选择Create New Repository或者新建-&gt;Repository,进入下一步:
输入版本库名字,进入下一步:
进入下一步
下一步
下一步
2.2 查看SVN路径 在服务端可以看到SVN路径，下图红框部分：
在cmd中查看自己的IP，把DESKTOP-6JQPA9K替换
IP如下：
路径：https://192.XXX.XXX.XXX/svn/MCU/
三、数据备份 Repositorys文件夹我们需要备份，SVN的东西就在这里。
下载BestSync，并安装（这个安装很简单一直下一步就行）。追加任务把当前的数据（F盘的文件）备份到别的盘（D盘）。
设置日程
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/92faa28c766528bef7b76b3822faf68a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f967b7674ed44508066cd7358cc73a78/" rel="bookmark">
			Kafka的leader选举
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实际上，leader选举的算法非常多，比如Zookeeper的Zab、Raft以及Viewstamped Replication。而Kafka所使用的leader选举算法更像是微软的PacificA算法。
Kafka在Zookeeper中为每一个partition动态的维护了一个ISR，这个ISR里的所有replica都跟上了leader，只有ISR里的成员才能有被选为leader的可能（unclean.leader.election.enable=false）。在这种模式下，对于f+1个副本，一个Kafka topic能在保证不丢失已经commit消息的前提下容忍f个副本的失败，在大多数使用场景下，这种模式是十分有利的。事实上，为了容忍f个副本的失败，“少数服从多数”的方式和ISR在commit前需要等待的副本的数量是一样的，但是ISR需要的总的副本的个数几乎是“少数服从多数”的方式的一半。
上文提到，在ISR中至少有一个follower时，Kafka可以确保已经commit的数据不丢失，但如果某一个partition的所有replica都挂了，就无法保证数据不丢失了。这种情况下有两种可行的方案：
等待ISR中任意一个replica“活”过来，并且选它作为leader选择第一个“活”过来的replica（并不一定是在ISR中）作为leader 如果一定要等待ISR中的replica“活”过来，那不可用的时间就可能会相对较长。而且如果ISR中所有的replica都无法“活”过来了，或者数据丢失了，这个partition将永远不可用。选择第一个“活”过来的replica作为leader,而这个replica不是ISR中的replica,那即使它并不保障已经包含了所有已commit的消息，它也会成为leader而作为consumer的数据源。默认情况下，Kafka采用第二种策略，即unclean.leader.election.enable=true，也可以将此参数设置为false来启用第一种策略。
unclean.leader.election.enable这个参数对于leader的选举、系统的可用性以及数据的可靠性都有至关重要的影响。下面我们来分析下几种典型的场景。
如果上图所示，假设某个partition中的副本数为3，replica-0, replica-1, replica-2分别存放在broker0, broker1和broker2中。AR=(0,1,2)，ISR=(0,1)。
设置request.required.acks=-1, min.insync.replicas=2，unclean.leader.election.enable=false。这里讲broker0中的副本也称之为broker0起初broker0为leader，broker1为follower。
1. 当ISR中的replica-0出现crash的情况时，broker1选举为新的leader[ISR=(1)]
因为受min.insync.replicas=2影响，write不能服务，但是read能继续正常服务。此种情况恢复方案：
尝试恢复(重启)replica-0，如果能起来，系统正常；如果replica-0不能恢复，需要将min.insync.replicas设置为1，恢复write功能。 2. 当ISR中的replica-0出现crash，紧接着replica-1也出现了crash, 此时[ISR=(1),leader=-1]
不能对外提供服务，此种情况恢复方案：
尝试恢复replica-0和replica-1，如果都能起来，则系统恢复正常；如果replica-0起来，而replica-1不能起来，这时候仍然不能选出leader，因为当设置unclean.leader.election.enable=false时，leader只能从ISR中选举，当ISR中所有副本都失效之后，需要ISR中最后失效的那个副本能恢复之后才能选举leader, 即replica-0先失效，replica-1后失效，需要replica-1恢复后才能选举leader。保守的方案建议把unclean.leader.election.enable设置为true,但是这样会有丢失数据的情况发生，这样可以恢复read服务。同样需要将min.insync.replicas设置为1，恢复write功能；replica-1恢复，replica-0不能恢复，这个情况上面遇到过，read服务可用，需要将min.insync.replicas设置为1，恢复write功能；replica-0和replica-1都不能恢复，这种情况可以参考情形2. 3. 当ISR中的replica-0, replica-1同时宕机,此时[ISR=(0,1)]
不能对外提供服务，此种情况恢复方案：尝试恢复replica-0和replica-1，当其中任意一个副本恢复正常时，对外可以提供read服务。直到2个副本恢复正常，write功能才能恢复，或者将将min.insync.replicas设置为1。
原文连接：https://www.cnblogs.com/aidodoo/p/8888628.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a68c2aff3d4067b0e1134b44b5276b8/" rel="bookmark">
			mysql5.7和mysql8.0区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mysql5.7和mysql8.0区别 mysql5.7之后的一个版本就是mysql8.0，之所以版本号跨度这么大是因为这5.7之后的版本区别确实很大，很多地方不一样了。
mysql5.7字符编码的问题 mysql5.7和之前版本，默认字符集为latin1，直接插入中文字符的时候会出现乱码的情况。所以在安装5.7及之前的版本的mysql的时候要把字符编码修改为utf8字符集，utf8字符集指的是utf8mb3。从mysql8.0开始，数据库默认字符编码改为utf8mb4。
1、查看编码命令：
show variables like 'character_%';
show variables like 'collation_%';
2、修改mysql数据目录下的my.ini配置文件
3、重启mysql服务
mysql8.0连接工具的问题 mysql8.0之后直接连接navicat会报错，这是因为mysql8.0默认采用了新的caching_sha2_password的身份验证方式，此方式并不兼容常规的老的web服务接口，所以navicat连接会报错，我们需要将默认的加密规则恢复为旧的mysql_native_password（还有一种方式就是升级数据库工具的版本，Navicat低版本有问题，Navicat15是没有这个问题的）
//使用mysql数据库 USE mysql; //更改root账户的加密规则为 mysql_native_password 并修改密码为 password 即可 ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY 'password'; //刷新权限 FLUSH PRIVILEGES; 回顾安装mysql8.0的时候，因为我们默认选择了新的授权认证方式，采用SHA256基础的密码加密方法，为了避免这个问题，我们可以在安装的时候选择下面一个传统的加密方式，保留5.x版本的兼容性。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c61baa7a62c72712b7f65ad7bf04c957/" rel="bookmark">
			Keras使用load_weights加载模型之后，没有predict方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有可能你是这么写的，按图片中修改即可：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e931f07941db4cf58f605691eec6717f/" rel="bookmark">
			手把手学习Zigbee - 使用Z-Stack 3.0.2配置CC2530的两个串口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言设备介绍串口选择解析和配置 Z-Stack总结 前言 EFR32那个平台好用是好用，但是网上能找的资料太少了，玩不明白，至今没有弄清楚那个平台的触发回调函数的流程
还是回头用CC2530吧，虽然没EFR32这么先进，但是更加符合我的开发习惯和逻辑，配合 Z-Stack 也比较方便。
设备介绍 CC2530 挺常见的zigbee 开发板，网上教程很多但 Z-Stack 的不是很全，而且开发板型号可能有细微差异，我这次就被坑了。
串口选择 因为串口0作为调试串口，和传感器通讯就必须要使用额外的串口1
网上找到的资料，都说CC2530有两个串口，每个串口有两个组引脚：
串口0：
位置一：RX - P02，TX - P03
位置二：RX - P14，TX - P15
串口1：
位置一：RX - P05，TX - P04
位置二：RX - P17，TX - P16
但是我手里的这块板子似乎的串口位置被引到了右上角红圈位置，而P04-05,P16-17,两组引脚似乎不能作为串口使用
解析和配置 Z-Stack 在左边工程文件中的HAL文件夹下可以找到 hal_uart.c 文件，里面有一一个 HalUARTInit() 函数，里面可以看到通过三个宏来控制初始化流程：
通过这三个宏可以找到在上面的 Config 目录下有一个 hal_board_cfg.h 文件， 在那儿我们可以看到 串口相关配置：
在这里可以看到默认情况下使用 DMA 后就不开启 ISR 串口了
然后知道默认的宏定义后，我们回到HalUARTInit() 函数继续往下追
既然默认走的 DMA 分支，那么我们就去 HalUARTInitDMA() 函数里看看
原来串口的两组引脚的选择是在初始化的时候 通过刚才我们看见那几组宏来控制引脚的使用
可以很清楚的发现，Z-Stack 使用串口的关节就在那几个宏上面了
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e931f07941db4cf58f605691eec6717f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82639072b2879ec42ba8da2f104e9167/" rel="bookmark">
			HIVESQL随笔---03
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目：
数据:stu
subject score
数学,30
数学,50
语文,65
数学,55
英语,80
数学,50
语文,60
数学,80
语文,90
结果:
subject score num
数学,30,1
数学,50,1
数学,50,1
数学,55,1
语文,60,2
语文,65,2
英语,80,3
数学,80,4
语文,90,5
请写出SQL输出结果表
输出一：
--1)科目的改变的定位，lag()+over()得到上次的科目 select subject,score, lag(subject) over(order by score asc) before_subject from stu;t1 --2)将本次科目和上次科目进行对比，如果相等则为0，否则1，初始值为1--case when select subject,score, case when before_subject is null then 1 when before_subject=subject then 0 else 1 end num from ()t1;t2 --3)统计 select subject,score, sum(num) over(order by score) sums from ()t2; --最终SQL select subject,score, sum(num) over(order by score asc ) sums from (select subject,score, case when before_subject is null then 1 when before_subject=subject then 0 else 1 end num from (select subject,score, lag(subject) over(order by score asc) before_subject from stu)t1)t2; 如果我按照输出一来处理，发现最终的输出结果竟然是：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/82639072b2879ec42ba8da2f104e9167/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aea1f12681fe0e91dc362bfb7750a4ec/" rel="bookmark">
			linux设置交换内存
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 查看是否有交换空间 cat /proc/swaps free -h 创建swapfile空间 sudo fallocate -l 32G /swapfile ls -lh /swapfile 设置空间权限 sudo chmod 600 /swapfile 激活交换空间 sudo mkswap /swapfile sudo swapon /swapfile 查看使用成功开启交换空间 sudo swapon --show 设置开机启动交换空间 sudo cp /etc/fstab /etc/fstab.bak echo '/swapfile none swap sw 0 0' | sudo tee -a /etc/fstab 配置优先使用交换分区 sudo vim /etc/sysctl.conf #在尾部添加： vm.swappiness=90 #最大值为100,值越大，交换分区越优先使用 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62410668d05111e8a180ecf0900891e4/" rel="bookmark">
			ZYNQ处理器系统外部接口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Zynq PS实现了众多接口，既有PS和PL之间的，也有PS和外部部件之间的。
PS和外部接口之间的通信主要是通过复用的输入/输出（Multiplexed Input/Output，MIO）实现的，它提供了可以做灵活配置的54个引脚，这表明外部设备和引脚之间的映射是可以按需定义的。这样的连续也可以通过扩展MIO（Extended MIO，EMIO）来实现，EMIO并不是PS和外部连接之间的直接通路，而是通过共用了PL的I/O资源来实现的。当需要扩展超过54个引脚的时候可以用EMIO，而当PL中实现了一个IP包的时候，这也是PS和PL中的IP保接口的一种方法。
可用的I/O包括标准接口和通用输入/输出（General Purpose Input/Output,GPIO)，GPIO可以用做各种用途，包括简单的按钮、开关和LED。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7931feb9c5d662136591484085207c15/" rel="bookmark">
			libmodbus在ARM linux开发板上使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、源码下载 1、libmodbus官网 libmodbus
2、下载 选择长期稳定版本libmodbus-3.1.6.tar.gz
3.拷贝到虚拟机
通过fillzilla或者vmtools直接拖动到linux虚拟机中
二、交叉编译 1、解压 拷贝到相应目录，解压，例如拷贝在/home/modbus下，modbus目录需要自己创建
在home/modbus下打开terminal 输入解压命令
tar -zxvf libmodbus-3.1.6.tar.gz
解压完成后在同目录下会生成 libmodbus-3.1.6文件夹，进入此文件夹
cd /home/modbus/libmodbus-3.1.6
2、创建安装目录 在/home/modbus/libmodbus-3.1.6目录下创建一个install文件夹
sudo mkdir install
3、配置编译选项 在/home/modbus/libmodbus-3.1.6目录下，打开终端，进行配置编译选项
（注：--prefix选项是安装目录，根据自己环境确定）
./configure --host=[交叉编译工具链前缀] --enable-static --prefix=[安装路径]/install/
[安装路径]例如/usr/local/modbus，[交叉编译工具链]例如arm-none-linux-gnueabihf
我最终程序是要用在ARM芯片上，所以交叉编译工具链这里我输入的是arm-none-linux-gnueabi 注意工具链一定要选对，否则一是makefile时，识别不了so文件，二是在开发板上无法运行。比如生成时用的是gnueabi，makefile时用的是gnueabihf 那就识别不了文件。
如果你使用libmodbus就是用在linux服务器上的，那么编译工具链就输入gcc即可。
我的configure示例:
./configure --host=arm-none-linux-gnueabihf --prefix=/home/modbus/libmodbus-3.1.6/install
5、编译&amp;安装 在/home/modbus/libmodbus-3.1.6目录下，打开终端，输入make 完成后再输入make install
执行此功能后，会在install文件夹生成三个文件夹，include lib share lib中包含了so库 include中包含了modbus.h的文件。 在编程时，要将include中的内容拷贝到自己项目中，lib里的 3个带so的文件要拷贝到虚拟机和开发板的 /usr/lib下。
6. 编写makefile
libmodbus是以so库的形式加载的，编写makefile时，要指明so库的路径。因为用到了modbus.h所以也需要指明modbus.h的路径。
如图中所示 -I指明了modbus.h的路径 -L指明了库所在的路径 -lmodbus指明了要链接的库。 注意:在linux中，libxxx.so文件，他的文件名在链接时只需要lib后的xxx，不需要打lib 比如要链接lib123.so 那就写 -l123即可，后缀也不用写。
编译完成后main放到开发板里运行即可
附上libmodbus函数的中文翻译libmodbus官方手册中文翻译_跃动的风的博客-CSDN博客_libmodbus使用说明
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6eada8f844b644293b1218cae9575136/" rel="bookmark">
			详解OpenCV的视频背景/前景分割(背景建模/前景提取)类cv::BackgroundSubtractorMOG2,并利用它实现对道路监控视频前景/背景的提取
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		cv::BackgroundSubtractorMOG2和cv::bgsegm::BackgroundSubtractorMOG一样，都是基于高斯混合模型的背景与前景分割算法。
cv::BackgroundSubtractorMOG2是对cv::bgsegm::BackgroundSubtractorMOG的改进，经过改进，它实现了自适应高斯混合模型参数的更新，增强了复杂场景背景检测的性能。
具体的算法原理可以参见下面两篇论文：
第一篇：
Zoran Zivkovic and Ferdinand van der Heijden. Efficient adaptive density estimation per image pixel for the task of background subtraction. Pattern recognition letters, 27(7):773–780, 2006.
第二篇：
Zoran Zivkovic. Improved adaptive gaussian mixture model for background subtraction. In Pattern Recognition, 2004. ICPR 2004. Proceedings of the 17th International Conference on, volume 2, pages 28–31. IEEE, 2004.
第一篇论文的摘要如下：
We analyze the computer vision task of pixel-level background subtraction.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6eada8f844b644293b1218cae9575136/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/975b5eb1d4349db63fe0b649e64af39c/" rel="bookmark">
			使用IDEA从git拉取分支
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、打开IDEA，进入目录：File -&gt;New -&gt;Project from Version Control 二、打开git工程，进行clone对应的链接 填充对应的链接
三、默认下载的是master分支，需要选取不同的分支时，可以在VCS-&gt;Git -&gt;Pull
选择具体的分支
过一段时间，等待拉取后的情况
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c207f6c52a2b21dcd531ed0e3809411/" rel="bookmark">
			世界名校人工智能实验室网址（研究方向）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		斯坦福大学AI实验室：人工智能、机器人
https://ai.stanford.edu/
麻省理工学院计算机科学与人工智能实验室
https://www.csail.mit.edu/
牛津大学计算机科学学院：算法、人工智能、自动验证、数据与知识
http://www.cs.ox.ac.uk/
卡内基梅隆机器人学院：机器人开发
https://www.cmu.edu/roboticsacademy/
伯克利人工智能研究（BAIR）实验室：深度强化学习
https://bair.berkeley.edu/
布里斯托机器人实验室：英国最全面的机器人研究中心
https://www.bristolroboticslab.com/
蒙特利尔大学机器学习研究所（MILA）：人工智能
https://mila.quebec/en/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2b797f35b0bb7e4b814569d1be9f448/" rel="bookmark">
			XSHELL “产品运行所需的信息检索失败。请重新安装xshell” Code=40002
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Xshell是Linux开发的桥梁，本博客仅作为学习教学使用，不提供商用。
打开链接下载完成后，以管理员方式运行绿化.bat。
链接：https://pan.baidu.com/s/1PSkN93H_XDOVEJ1E2Qkpeg 提取码：vvhz 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/315ede013d3e369e0d52057fbc88b870/" rel="bookmark">
			python &#43; Django &#43; MySQL 系列学习(二)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、xadmin是什么？二、使用步骤1.环境2. 安装 &amp; 配置 xadmin3. xadmin 添加导入功能3.1 背景3.2 setting中添加内容3.3 构建static3.4 添加导入插件 4. 参考文章 前言 前一篇文章中，我们大致介绍了如何使用django 和 mysql 进行搭建，这篇文章主要介绍如何通过django+ xadmin来实现我们的后台管理系统
提示：以下是本篇文章正文内容，下面案例可供参考
一、xadmin是什么？ Xadmin是基于bootstrap开发的一套后台管理框架,界面非常美观,只需几步就可以替换自带的Django_admin，比django自带的admin 具有更强大的功能。
二、使用步骤 1.环境 python版本：python3.9
Django版本：Django==2.2
依赖包：
django-crispy-forms == 1.7.2
django-import-export == 1.2.0
django-reversion == 3.0.3
django-formtools == 2.1
future == 0.15.2
httplib2 == 0.9.2
six == 1.10.0
xlwt == 1.3.0
xlsxwriter == 1.1.7
requests == 2.21.0
2. 安装 &amp; 配置 xadmin （1）xadmin 下载地址：https://github.com/sshwsfc/xadmin/tree/django2
（2）通过命令进行安装
pip install xadmin-django2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/315ede013d3e369e0d52057fbc88b870/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0cf9e846bdf6b0509590632c74648e9a/" rel="bookmark">
			阅读论文记忆博客
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Previous papers [arXiv:1706.03762] Attention Is All You Need
动机：RNN中顺序性质使训练无法并行化；注意力机制（Attention）对序列信息处理很好，但依赖RNN。挑战：只靠Attention机制，不使用RNN和CNN，提高并行度；充分发挥Attention抓长距离依赖关系比RNN强的优势。方法：Transformer代替RNN；
Masked Attention: 不让Decoder在训练的时候用后文的信息生成前文的信息；
Feed Forward: 非线性处理；
残差计算：更有效的反向传播；
Position Coding： “位置编码”（不同频率的正弦和余弦函数）与Embedding相加；
Scaled Dot-Product Attention：
A t t e n t i o n ( Q , K , V ) = s o f t m a x ( Q K T d k ) V Attention(Q,K,V) = softmax(\frac{QK^T}{\sqrt{d_k}})V Attention(Q,K,V)=softmax(dk​ ​QKT​)V
多头注意力（Multi-Head Attention）：
M u l t i H e a d ( Q , K , V ) = C o n c a t ( h e a d 1 , .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0cf9e846bdf6b0509590632c74648e9a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f80e11814a511ea6919c121952e2ce20/" rel="bookmark">
			《通信原理》课后题 樊昌信
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一章 绪论
1-2 何谓数字信号？何谓模拟信号？两者的根本区别是什么？
答：数字信号：电信号的参量值仅可能取有限个值。模拟信号：电信号的参量取值连续。
两者的根本区别是携带信号的参量是连续取值还是离散取值。
1-3何谓数字通信？数字通信偶哪些优缺点？
答：利用数字信号来传输信息的通信系统为数字通信系统。优点：抗干扰能力强，无噪声
积累传输差错可控；便于现代数字信号处理技术对数字信息进行处理、变换、储存；易于
集成，使通信设备微型化，重量轻；易于加密处理，且保密性好。缺点：一般需要较大的
传输带宽；系统设备较复杂。
1-4 数字通信系统的一般模型中各组成部分的主要功能是什么？
答：信源编码：提高信息传输的有效性（通过数字压缩技术降低码速率），完成 A/D 转换。
信道编码/译码：增强数字信号的抗干扰能力。
加密与解密：认为扰乱数字序列，加上密码。
数字调制与解调：把数字基带信号的频谱搬移到高频处，形成适合在信道中传输的带
通信号。
同步：使收发两端的信号在时间上保持步调一致。
1-5 按调制方式，通信系统如何分类？
答：基带传输系统和带通传输系统。
1-6 按传输信号的特征，通信系统如何分类？
答：模拟通信系统和数字通信系统。
1-7 按传输信号的复用方式，通信系统如何分类？
答：FDM,TDM,CDM。
1-8 单工、半双工及全双工通信方式是按什么标准分类的？解释他们的工作方式。
答：按照消息传递的方向与时间关系分类。单工通信：消息只能单向传输。半双工：通信
双方都能收发消息，但不能同时进行收和发的工作方式。全双工通信：通信双方可以同时
收发消息。
1-9 按数字信号码元的排列顺序可分为哪两种通信方式？他们的适用场合及特点？
答：分为并行传输和串行传输方式。并行传输一般用于设备之间的近距离通信，如计算机
和打印机之间的数据传输。串行传输使用与远距离数据的传输。
1-10 通信系统的主要性能指标是什么？
答：有效性和可靠性。
1-11 衡量数字通信系统有效性和可靠性的性能指标有哪些？
答：有效性：传输速率，频带利用率。
可靠性：误码率，误信率。
1-12 何谓码元速率和信息速率？他们之间的关系如何？
答：码元速率：单位时间（1 秒）传送码元的数目。
信息速率：单位时间内传递的平均信息量或比特数。
R b = R B * log 2 M
1-13 何谓误码率和误信率？它们之间的关系如何？
答：误码率：错误接受的码元在传输总码元数中所占的比例。
误信率：戳无接受的比特数在传输总比特数中所占的比例。
1-14 消息中包含的信息量与以下哪些因素有关？
（1）消息出现的概率；（2）消息的种类；（3）消息的重要程度；
答：消息中所含的信息量是该消息出现的概率的函数。
第 二 章 确知 信号
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f80e11814a511ea6919c121952e2ce20/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61cf16ba840b6b4038c09e095b06c9db/" rel="bookmark">
			RT_Thread_线程的一些基本概念
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		官方资料：线程管理 (rt-thread.org) 1、线程的分类 系统线程：rtt系统创建的线程：main、idle空闲线程；
用户线程：我们自己写的，由rt_thread_init和rt_thread_create创建的线程；
2、线程的五种状态和切换 注：RT-Thread 中，实际上线程并不存在运行状态，就绪状态和运行状态是等同的。
3、创建线程 补充一下下面创建线程时有关的宏定义，可以在rt_config.h里查看和修改；
3.1、静态线程 静态线程是指线程控制块、线程运行栈一般都设置为全局变量，在编译时就被确定、被分配处理，内核不负责动态分配内存空间。
需要注意的是，用户提供的栈首地址需做系统对齐（例如 ARM 上需要做 4 字节对齐）。
rt_err_t rt_thread_init	(	struct rt_thread * thread, const char * name, void(*)(void *parameter) entry, void * parameter, void * stack_start, rt_uint32_t stack_size, rt_uint8_t priority, rt_uint32_t tick ); 3.2、动态线程 系统会从动态堆内存中分配一个线程句柄以及按照参数中指定的栈大小从动态堆内存中分配相应的空间。
分配出来的栈空间是按照 rtconfig.h 中配置的 RT_ALIGN_SIZE 方式对齐。
rt_thread_t rt_thread_create(const char* name, void (*entry)(void* parameter), void* parameter, rt_uint32_t stack_size, rt_uint8_t priority, rt_uint32_t tick); 4、线程栈的大小 一开始，可设置为大一点的固定大小比如512，然后在系统运行的时候，利用msh的list_thread命令查看当前线程的信息，其中就包含栈的最大使用率max used，然后调整栈大小max used为70%比较合适。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc8c7ead6f04614efcc200ec9cbd5ae7/" rel="bookmark">
			mysql 解释字段，case…END语句
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、解释字段二、case...END 语句1、case...END 区间判断2、case...END 等值判断 一、解释字段 对查询结果的解释分析（无解释，不查询）在select执行之前，在临时表动态生成一个列；列中内容用于对临时表每一行数据进行解释分析；解释数据来源：
1、来源于聚合函数
2、来源于独立子查询
3、来源于开发人员手动设置常量
4、来源于case…END语句 二、case…END 语句 目的是为临时表的每一行数据给出一个动态的分析结果；1、case…END在select执行之前执行2、case…END执行时遍历临时表的每一行数据，在遍历时为每一行数据提供一个动态解释内容3、case…END执行完毕时，生成解释数据作为一个独立的列出现在临时表 1、case…END 区间判断 类似于if() ELSE if() ELSE ：格式
SELECT (case
when 区间判断 then ‘解释数据’
when 区间判断 then ‘解释数据’
ELSE … END) AS 列名 FROM TABLE
例子：
SELECT doc_no, use_work_hour, (SELECT AVG(use_work_hour) FROM dispatch_list) AS avg_hour, (case when use_work_hour&lt;(SELECT AVG(use_work_hour) FROM dispatch_list) then '小于平均工时' when use_work_hour&gt;(SELECT AVG(use_work_hour) FROM dispatch_list) then '大于平均工时' ELSE '等于平均工时' END ) AS 等级 FROM dispatch_list; 2、case…END 等值判断 类似于switch；格式：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cc8c7ead6f04614efcc200ec9cbd5ae7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58e225ec5c22761c279c891dd7b35c1b/" rel="bookmark">
			Source Insight 3.5 插件支持utf8
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上次SI多标签插件之后,因为公司内部编码改为utf8编码,因此特意做了这个Source Insight 3.X utf8插件.
下载地址:http://pan.baidu.com/s/1mgyZous，或者：[点我]
https://link.csdn.net/?target=http%3A%2F%2Ffiles.cnblogs.com%2FRed_angelX%2Fsiplus.zip
安装说明:
解压msimg32.dll sihook.dll siutf8.dll 到Source Insight 3.X安装目录
msimg32.dll 引导程序(*)
sihook.dll 标签插件(M)
siutf8.dll utf8插件(M)
功能说明:
1,增加SI多标签功能
2,修复SI当光标在中文字符上按CTRL+F时崩溃的问题.(感谢看雪的封心锁爱)
3,utf8编码支持.
已知问题:
当utf8编码文件在外部改变时,SI不会检测到更新.需要重新关闭SI再打开.
优美的配置文件：
配置文件
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/504f7cb883b5b846c11249811b904643/" rel="bookmark">
			数据结构笔记整理(严蔚敏版) 更新中...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 数据结构笔记整理绪论基本概念和术语算法的定义及特性定义特性 评价算法优劣的标准算法的时间复杂度算法的空间复杂度 线性表线性表的定义和特点线性表的顺序存储表示顺序表中基本操作的实现 线性表的链式存储表示单链表中基本操作的实现 栈和队列栈的定义和特点栈的表示和操作实现顺序栈链栈栈与递归 队列的定义和特点循环队列的操作队列的链式表示和实现 串、数组、和广义表串的定义串的存储结构串的模式匹配算法1.BF算法2.KMP算法 数组数组的顺序存储特殊矩阵的压缩存储1.对称矩阵2.三角矩阵3.对角矩阵4.稀疏矩阵 数据结构笔记整理 绪论 基本概念和术语 数据：能输入到计算机中并被计算机处理的符号的总称；
数据元素：数据的基本单位；
数据项：组成数据元素的、有独立含义的、不可分割的最小单位；
数据对象：性质相同的数据元素的集合；
数据结构：相互之间存在一种或多种特定关系的数据元素的集合；
数据类型：是一个值的集合和定义在这个值集上的一组操作的总称；
抽象数据类型：一般指由用户定义、表示应用问题的数据模型，以及定义在这个模型上的一组操作的总称；
（具体包括三部分：数据对象、数据对象上关系的集合以及对数据对象的基本操作的集合）
算法的定义及特性 定义 为了解决某类问题而规定的一个有限长的操作序列；
特性 1.有穷性
2.确定性
3.可行性
4.输入
5.输出；
评价算法优劣的标准 1.正确性
2.可读性
3.健壮性
4.高效性（包括时间和空间两个方面）
算法的时间复杂度 一个算法的执行时间大致上等于其所有语句执行时间总和，而语句的执行时间则为该条语句的重复执行次数和执行一次所需要时间的乘积；
问题规模是算法求解问题输入量的多少，一般用整数n表示；
语句频度一条语句重复执行的次数；
时间复杂度定义：随问题规模n的增大，算法执行时间的增长率称为时间复杂度；
最好时间复杂度：算法计算量可能达到的最小值；
最坏时间复杂度：算法计算量可能达到的最大值；
平均时间复杂度：算法在所有可能的情况下，按照输入实例以等概率出现时，算法计算量的加权平均值；
1.常量阶O(1)
int i=0,s=0; for(i=0;i&lt;100;i++){ s++;	//语句频度为常数，无论怎么大，仍然是常数 } 2.线性阶O(n)
for(i=0;i&lt;n;i++){ s++;	//语句频度为n } 3.对数阶O(log(2)n)
for(int i=1;i&lt;n;i++){ i=i*2; } //2^n=x //x=log(2)n 算法的空间复杂度 分析算法在实现是所需要的辅助空间；
int fac(int n){	if (n == 1) return 1; else return n * fac(n - 1); } 线性表 线性表的定义和特点 定义：由n个数据特性相同的元素构成的有限序列称为线性表；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/504f7cb883b5b846c11249811b904643/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9263d4803148327c8a64d4df73f2209/" rel="bookmark">
			STM32G0系列的启动配置与程序下载说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目的
STM32G是意法半导体这两年新推出的系列芯片，相比原先的F系列的芯片有很多提升点，将来必将取代F系列芯片的地位。对于新芯片的应用来说能够正确下载与运行程序是比较重要的一点，这篇文章将对 STM32G0 系列芯片的启动配置与程序下载做个简单的说明。
启动配置
STM32G0系列芯片的启动配置相关内容在官方文档《AN5096：Getting started with STM32G0 Series hardware development》第三章中有详细的描述：
启动配置相关内容其实是不多的，下面将对这部分内容做个简单的说明。
STM32系列芯片程序启动方式分为下面三种：
Main Flash memory 从主闪存启动，想要运行我们自己的程序就要选择这种方式；
System memory 从系统存储区启动，想要通过串口下载程序就要选择这种方式；
Embbeded SRAM 从内存启动；
STM32G0系列芯片通过选项字节（option byte）中的 BOOT_LOCK、nBOOT1、nBOOT_SEL、nBOOT0这几位加上外部的 BOOT0 管脚的电平来确定启动方式。当 nBOOT_SEL 为 0 时， BOOT0 的值来源于外部的 BOOT0 管脚的电平，低电平为 0 ，高电平为 1 ；当 nBOOT_SEL 为 1 时， BOOT0 的值来源于 nBOOT0 的值。
芯片启动时会检查闪存地址0x080000000（即用户程序起始地址）处的数据，如果该数据为0xFFFFFFFF则表示用户程序为空，此时不管上面的那些设置程序会从 System memory 启动。
芯片在出厂后只要没有经过程序下载等操作启动时总是会从 System memory 启动。
程序下载
STM32系列系统程序下载通常通过串口进行，而使用串口下载程序重要的是要让芯片从 System memory 启动。
从上一章节内容可以知道芯片在初次烧写时就是从 System memory 启动的，你可以正常使用串口进行连接烧写，不需要关心外部 BOOT0 管脚的电平，如果连接不上就拉低下芯片 NRST 引脚复位下芯片试试。（如果还是连接不上就检查下芯片供电、线路连接、串口模块、串口驱动等试试。）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d9263d4803148327c8a64d4df73f2209/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3bf81a7b24643e4002da1b0a487161b1/" rel="bookmark">
			linux运行shell命令文件时，出现$‘\r‘: command not found报错的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、Linux下执行shell脚本报错如下： 2、原因： 是Windows和Linux的.sh脚本文件格式不同，如果在脚本中有空行，脚本是在Windows下进行编辑之后上传到linux上去执行的话，就会出现这个问题。
windows 下的换行符是\r\n，而 linux 下的换行符是\n，没有识别/r,所以会导致上述的报错，这个属于脚本编码的问题。
3、解决方法：（运行以下命令即可修改该脚本格式） 在start.sh对应脚本目录下,执行以下命令即可。
vim start.sh :set ff=unix :wq 保存退出后，恢复到原先步骤，继续执行原来的脚本命令即可。例如 ./start.sh start
4、命令行解释： # 用vim编辑器打开文件，open、edit（E）、recover、delete
根据提示选择首字母进入文件编辑状态(键盘E)，
vim start.sh 直接输入:冒号后，命令行会自动跳至最后一行进行编辑
#转换格式，设置脚本格式为Linux形式。
vim start.sh #保存文件并退出，w写入q退出。
:wq 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d649609758c8938e35504622677375c0/" rel="bookmark">
			小猫爪：嵌入式小知识11-MPU详解及其应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		小猫爪：嵌入式小知识11-MPU详解及其应用 1 前言2 MPU简介3 MPU相关概念3.1 Memory Map3.2 MPU Region3.3 Region优先级3.4 Background Region3.5 Cache的读写策略3.5.1 Cache的读操作3.5.1 Cache的写操作 4 MPU寄存器介绍4.1 MPU_TYPE4.2 MPU_CTRL4.3 MPU_RNR4.4 MPU_RBAR4.5 MPU_RASR4.5.1 XN4.5.2 AP4.5.3 TEX, C, B, S4.5.4 SRD4.5.5 SIZE 5 MPU应用注意事项6 MPU的errata和Workaround6.1 12598646.2 10137836.3 8349226.4 8381696.5 834923 END 1 前言 前段时间被MPU（Memory Protection Unit）搞得头疼欲裂，所以就简单的学习了一下，得空做个总结，接下来就来看看这个MPU到底是个什么玩意？MPU其实是属于ARM核自带的一个外设，是跟核绑定在一起的，所以关于它的资料都在ARM核的各种参考指南中，大家请自行下载参考。
2 MPU简介 MPU说简单点其实就是一个内存访问权限控制器，如果CPU在访问内存时不符合MPU定义的访问权限的话，那么访问就会被驳回，并且会触发一次错误异常，即Hardfault异常（或者MemManage异常，可通过SCB-&gt;SHCSR来配置）。配置内存访问权限的好处主要有：
避免应用程序破坏其他任务或者OS使用的栈和堆避免非特权任务访问对系统可靠性和安全性很重要的外设防止恶意代码注入攻击控制存储器相关访问属性 3 MPU相关概念 3.1 Memory Map 众所周知，大部分M核目前是32位寻址，那就代表了核能访问0~2^32-1地址范围，总共4G大小的内存空间。芯片厂商会根据自己的设计将内部Flash，内部SRAM，TCM，外设寄存器，还有外部存储器等等的访问地址映射分布在这4G中，这就被称为Memory Map，所以MPU管理的对象就是整个4G空间。
3.2 MPU Region MPU可将整个4G分成若干个区域，然后对每个区域设置地址区间（起始地址和大小）和不同的访问权限来达到预期的保护目标。一般来说，M3核和M4最大支持8个区域，而M7最大支持16个区域，而这个区域就叫做MPU Region。
3.3 Region优先级 上面提到可对每一个MPU Region设置地址区间，那么如果两个Region有重叠的部分，那么这个时候Region Number大的优先级高。即对于同一块内存区间，Region0设置该区间可访问，而Region3设置该该区间不可访问，那么这个区间的权限遵循Region3的配置为不可访问。基本如下图所示：
3.4 Background Region 由于每个区间可设置地址区间，那么就会存在一种情况，那就是等所有的Region都配置完之后，4G空间中还有一些区域没有被所有的Region覆盖到，而这些没有被Region覆盖的区域就叫做Background Region。MPU可单独配置对Background Region的属性为默认特权访问权限还是不可访问。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d649609758c8938e35504622677375c0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/884dec2bf4fc0bb49447d36cc6222b08/" rel="bookmark">
			Antd Modal组件全屏的几种实现方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 接触React + Ant Design开发也有一段时间了，也已经慢慢习惯了React + Ant Design。最近开发的需求功能里，需要一个全屏弹窗的功能，类似于ElementUI里的Dialog组件fullscreen属性设置为true的效果。然而发现Ant Design的Modal组件并不支持全屏效果。
去Github上翻了一下其他开发者提的issue，发现2018年的时候有其他开发者已经提了：https://github.com/ant-design/ant-design/issues/12359
而Antd开发者afc163对于此需求则回复：
建议自行封装吧，暂时不会增加这样的功能。
如果内容比较多，也可以尝试 Drawer。
看来只能自己动手丰衣足食了。
方案1：通过参数实现 Modal组件提供了比较丰富的参数，其中有两个参数，分别是bodyStyle、style以及width。其中bodyStyle参数控制Modal组件的body部分样式，style参数则用于设置浮层的样式，调整浮层位置等，width参数控制宽度。
方案1思路 所谓全屏，说简单一点，就是弹窗的宽度和高度分别等于浏览器可视区域的宽度和高度。
对于宽度，我们尝试通过设置参数width="100vw"来控制弹窗的宽度：
&lt;Modal title="Basic Modal" width="100vw" visible={isModalVisible} onOk={handleOk} onCancel={handleCancel} &gt; ... &lt;/Modal&gt; 然后发现通过上述方式改变宽度之后，弹窗的左右及上下区域，分别出现了空白：
对于左右两边区域的空白，我们通过F12查看网页源代码，可以发现是Modal组件div的max-width样式导致：max-width: calc(100vw - 32px);：
针对于这个问题，我们只要通过Modal组件的style参数来修改max-width样式，将其设置为100vw即可：
&lt;Modal style={{ maxWidth: "100vw" }} title="Basic Modal" width="100vw" visible={isModalVisible} onOk={handleOk} onCancel={handleCancel} &gt; ... &lt;/Modal&gt; 而对于弹窗的高度，我们通过设置参数style={{maxWidth: "100vw", height: "100vh"}}，将高度设置为100vh，发现并没有什么用，看来我们只能另辟蹊径了。
对于弹窗上边区域的空白，我们可以通过设置top: 0的方式来消除：style={{maxWidth: "100vw", top: 0}}，其中top: 0表示Modal组件div元素，距离顶部设置为0。
另外，弹窗的高度，我们可以设置Modal组件body区域的高度，将其设置为100vh - 弹窗header部分高度 - 弹窗footer部分高度即可，其中header部分和footer部分的高度分别为55和52：
代码：
&lt;Modal style={{ maxWidth: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/884dec2bf4fc0bb49447d36cc6222b08/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e5b6a91f47437773af199006364b455/" rel="bookmark">
			Android Proguard 不混淆所有第三方jar（忽略配置设置）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天给大家分享一个只混淆自己的项目代码而不混淆所有第三方jar的方法（没错，是所有的第三方都不进行混淆，无论来什么第三方，都不需要动混淆配置）
不混淆所有第三方重大突破 今天又被同事逼迫看了一下Proguard官网，发现原来是支持指定多个目录混淆的 例如你有：com.a.a、com.b.b、com.c.c、com.第三方等 现在只想混淆com.a.a和com.b.b，那么你写成如下即可 ``` -keep class !com.a.a.**,!com.b.b.**,** {*;} ``` 使用注意：如果你项目用的第三方特别杂乱、特别多，不混淆的话会导致包体积增大很多
一、为app添加混淆 在app的buildTypes里开启对指定包进行混淆，这里我混淆了release和debug的，并且增加了一个debug模式的混淆类型（注①）
buildTypes { release { minifyEnabled true proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' signingConfig signingConfigs.release } //不混淆，便于开发debug debug { minifyEnabled false signingConfig signingConfigs.release } //debug混淆模式，以便给测试人员测试 debugProguard {//除了字符串和注释其他的不要沾半点中文 initWith debug minifyEnabled true proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' } } 二、增加混淆逻辑 第二步就是关键了，混淆的配置（放在app目录下即可，上面写的是相对路径，所以必须在app目录下，不是根目录）
# Add project specific ProGuard rules here. # By default, the flags in this file are appended to flags specified # in /Users/chenmengjia/Library/Android/sdk/tools/proguard/proguard-android.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e5b6a91f47437773af199006364b455/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/adad71025b9954f7605bfdb6fc6fca41/" rel="bookmark">
			Linux命令之显示或设置网络设备参数信息ifconfig
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述 ifconfig 命令可以用于显示或设置网络设备的参数信息。ifconfig 是 network interfaces configuring 的缩写。
注：
在 Windows 系统中可以通过类似的 ipconfig 命令进行查看网络信息。不建议通过 ifconfig 命令配置网络设备的参数信息，因为命令配置的信息只对当前系统有效，一旦重启系统，就会失效。所以建议编写到相关配置文件中。 语法 该命令的语法如下：
ifconfig [选项] [网卡设备] 该命令支持的选项有：
选项说明add &lt;地址&gt;设置网络设备IPv6的IP地址del &lt;地址&gt;删除网络设备IPv6的IP地址&lt;hw &lt;网络设备类型&gt;&lt;硬件地址&gt;设置网络设备的类型与硬件地址io_addr &lt;I/O地址&gt;设置网络设备的I/O地址irq &lt;IRQ地址&gt;设置网络设备的IRQmedia &lt;网络媒介类型&gt;设置网络设备的媒介类型mem_start &lt;内存地址&gt;设置网络设备在主内存所占用的起始地址metric &lt;数目&gt;指定在计算数据包的转送次数时，所要加上的数目mtu &lt;字节&gt;设置网络设备的MTUnetmask &lt;子网掩码&gt;设置网络设备的子网掩码tunne &lt;地址&gt;建立IPv4与IPv6之间的隧道通信地址up启动指定的网络设备down关闭指定的网络设备-broadcast &lt;地址&gt;将要送往指定地址的数据包当成广播数据包来处理-pointopoint &lt;地址&gt;与指定地址的网络设备建立直接连线，此模式具有保密功能-promisc关闭或启动指定网络设备的promiscuous模式IP地址指定网络设备的IP地址网络设备指定网络设备的名称 使用 显示网络设备信息【★★★★★】 只需要执行如下命令就可以查看当前系统的网络设备信息：
ifconfig 各字段说明如下（上图的系统是 CentOS 7，所以显示的信息可能和其他版本的有所不同）：
eth0：表示是第一块网卡。inet：表示 IP 地址。netmask：表示子网掩码。broadcast：表示广播地址。inet6：表示 IPV6 地址。lo：是 loopback 的缩写，是本地回环网卡，该网卡的 IP 地址是 127.0.0.1。 启动或关闭指定网卡设备 可以通过 up 或 down 参数对指定网卡设备进行启动或关闭：
# 语法 # 关闭指定网卡 ifconfig 指定网卡名称 down # 启动指定网卡 ifconfig 指定网卡名称 up # 示例 # 关闭名为 eth0 的网卡 ifconfig eth0 down # 启动名为 eth0 的网卡 ifconfig eth0 up 配置或删除指定网卡的 IPv6 地址 如果想要配置或删除指定网卡的 IPv6 地址，可以用如下命令格式：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/adad71025b9954f7605bfdb6fc6fca41/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da0edf160f9da5ef929000f62c76378e/" rel="bookmark">
			WebAPI-修改元素样式的方法汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		设置/修改元素样式 1 方式一 通过元素的 style 属性来设置样式；元素对象的 style 属性也是一个对象，可以通过 . 的方式来设置或修改样式。
语法：
元素对象.style.样式属性 = 属性值 注意：
通过该方式操作样式时，样式属性要使用驼峰命名法。
通过该方式产生的样式是行内样式，权重比较高。
&lt;div&gt;div标签&lt;/div&gt; // 获取元素 let el = document.querySelector('div'); // 设置样式 el.style.fontSize = '24px'; el.style.color = 'red'; // 控制台打印元素 console.log(el); 方式二 通过操作 className 属性来修改元素的类名，达到修改样式的目的。因为元素的 class 属性在 js 中是一个关键字，所以使用 className。
语法：
元素对象.className = 值 注意：
通过 className 的方式会直接覆盖原先的类名。 示例：
&lt;div class="box"&gt;div标签&lt;/div&gt; .active { color: red; font-size: 24px; background-color: skyblue; } // 获取元素 let el = document.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/da0edf160f9da5ef929000f62c76378e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e574735fe2a56451160ab49247032417/" rel="bookmark">
			数据库之快照读与当前读
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、当前读 即读取最新提交的数据
select … for update
select ... lock in share mode
insert、update、delete，都会按最新提交的数据进行操作
当前读本质上是基于锁的并发读操作
2、快照读 读取某一个快照建立时（可以理解为某一时间点）的数据，也称为一致性读。快照读主要体现在 select 时，而不同隔离级别下，select 的行为不同
在 Serializable 隔离级别下 - 普通 select 也变成当前读，即加共享读锁
在 RC 隔离级别下 - 每次 select 都会建立新的快照
在 RR 隔离级别下
事务启动后，首次 select 会建立快照
如果事务启动选择了 with consistent snapshot，事务启动时就建立快照
基于旧数据的修改操作，会重新建立快照
快照读本质上读取的是历史数据（原理是回滚段），属于无锁查询
2.1、RR 下，快照建立时机 - 第一次 select 时 tx1tx2set session transaction isolation level repeatable read;start transaction;select * from account; /* 此时建立快照，两个账户为 1000 */update account set balance = 2000 where accountNo=1;select * from account; /* 两个账户仍为 1000 */ 快照一旦建立，以后的查询都基于此快照，因此 tx1 中第二次 select 仍然得到 1 号账户余额为 1000
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e574735fe2a56451160ab49247032417/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e904db9c493074ac6b89926cd106114/" rel="bookmark">
			【C语言习题】输入某年某月某日，判断这一天是这一年的第几天（用数组&#43;switch语句编程）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目内容：输入某年某月某日，判断这一天是这一年的第几天？
输入样例：2021 12 10
输出样例：2021年12月10日是这一年的第344天！
输入样例：2020 12 10
输出样例：2020年12月10日是这一年的第345天！
个人解法如下：（数组与switch语句都有用到）
#define _CRT_SECURE_NO_WARNINGS //防报错 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int Days_M(int year, int month) //该函数用于获得当月月份的对应天数 { int days[] = { 0,31,28,31,30,31,30,31,31,30,31,30,31 }; //默认2月份为平年28天（0号位占位元素为0不影响计算） if ((year % 100 != 0 &amp;&amp; year % 4 == 0) || month % 400 == 2) days[2] += 1; //闰年2月天数加1天 return days[month]; } int Days_SUM(int year, int month, int day) //该函数用于获得总天数 { int SUM = 0; if (year &lt; 1) //年数报错 return -1; if (month &lt; 1 || month &gt; 13) //月数报错 return -2; if (day &lt; 1 || day &gt; Days_M(year, month)) //天数报错 return -3; for (int i = 0; i &lt; month; i++) //直到当月跳出循环（若int i=1会导致一月也进行一次循环） SUM += Days_M(year, i); //获得本月以前的所有月份天数之和 return SUM + day; //返回值中加上本月当前天数 } int main() { int year, month, day; int SUM = 0; printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e904db9c493074ac6b89926cd106114/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12290fe2df5826a179a2aff720e5bb37/" rel="bookmark">
			压测并发数的确定
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		压测目的 测试多用户并发访问同一个应用、模块、数据的情况下是否会产生隐藏的并发问题，例如：内存泄漏、线程锁、资源争用问题。
并发数的确认 方法一：根据泊松分布计算得到
C=NL/TQ=C+3* C \sqrt C C ​ 参数解释：
C:平均并发用户数
N:登陆会话的数量
L：登陆会话的平均长度
T:考察的时间段长度
Q：并发用户峰值数
方法二：经验获取
每天访问系统用户数的10%作为平均的并发用户数。最大的并发用户数乘上一个值，2或者3。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6e4a792bfdefc7f66ab6d6a94b5fe47/" rel="bookmark">
			python 设置Pyplot的动态rc参数、绘图的填充
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.全局参数定制
2.rc参数设置
例1.rc参数设置例1
例2.rc参数设置例2
例3.用set_xticks设置刻度
例4.用set_xticklabels改变刻度
3.绘图的填充
3.1调用函数fill_between()实现曲线下面部分的填充
3.2 部分区域填充
3.3 两条曲线之间的区域填充例7 使用fill_between()填充曲线之间的区域
3.4 直接使用fill进行绘图的填充
Matplotlib配置了配色方案和默认设置，主要用来准备用于发布的图片。有两种方式可以设置参数，即全局参数定制和rc设置方法。
查看matplotlib的rc参数：
import matplotlib as plt print(plt.ra_params) 1.全局参数定制 Matplotlib的全局参数可以通过编辑配置文件设置
import matplotlib as plt print(plt.matplotlib_fname) #显示当前用户的配置文件目录 查找到当前用户的配置文件目录，然后用编辑器打开，修改matplotlib文件，即可修改配置参数。
2.rc参数设置 使用Python编程修改rc参数，rc参数及其取值如下表1~3
表1 rc参数名称及其取值 rc参数解释取值lines.linewidth线条宽度取0~10的数值，默认1.5lines.linestyle线条样式取“-”“--”“-.”“：”4种，默认为“-”lines.marker线条上点的形状可取“o”“D”等20种，默认为Nonelines,markersize点的大小取0~10的数值，默认为1 表2 线条样式lines.linestyle的取值 linestyle取值意义linestyle取值意义-实线-.点线--长虚线:短虚线 表3 lines.marker参数的取值
marker取值 意义 marker取值 意义 'o' 圆圈 '.' 点 'D' 菱形 's' 正方形 'h' 六边形1 '*' 星号 'H' 六边形2 'd' 小菱形 '-' 水平线 'v' 一角朝下的三角形 '8' 八边形 '&lt;' 一角朝左的三角形 'p' 五边形 '&gt;' 一角朝右的三角形 '，' 像素 '^' 一角朝上的三角形 '+' 加号 '|' 竖线 'None' 无 'x' X
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e6e4a792bfdefc7f66ab6d6a94b5fe47/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad095d93b1200686215b2af22d028464/" rel="bookmark">
			AUTOSAR基础篇之OS(下)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言
首先，请问大家几个小小的问题，你清楚：
你知道多核OS在什么场景下使用吗？
多核系统OS又是如何协同启动或者关闭的呢？
AUTOSAR OS存在哪些功能安全等方面的要求呢？
多核OS之间的启动关闭与单核相比又存在哪些异同呢？
。。。。。。
今天，我们来一起探索并回答这些问题。为了便于大家理解，以下是本文的主题大纲：
正文
AUTOSAR OS 保护
在上篇文章AUTOSAR基础篇之OS(上)中我们可以了解到AUTOSAR OS的基本特点，基本对象以及各个对象之间的彼此关联，本篇文章将承前启后，在此基础上来简单谈谈我对AUTOSAR 多核OS的理解与认识。鉴于本人水平能力有限，如存在错误之处，还请大家多多批评指正。
我们已知道AUTOSAR OS来源于OSEK OS，随着汽车电子信息安全，功能安全等需求的不断提出，传统的OSEK OS已无法满足当前的需求，因此AUTOSAR组织在OSEK OS的基础上为不同的用户提供四类不同功能安全的OS可裁剪类型，分别为SC1-SC4。
AUTOSAR OS 可裁剪类型
AUTOSAR OS的四种可裁剪类型分别为SC1-SC4，具体含义如下：
SC1: OSEK OS + Schedule Table；SC2: OSEK OS + Schedule Table + Timing Protection;SC3: OSEK OS + Schedule Table + Memory Protection;SC4: OSEK OS + Schedule Table + Timing Protection + Memory Protection； 如下图1所示，较为清晰了描述了这四种不同可裁剪类型的区别与联系。
图1 AUTOSAR OS可裁剪类型 AUTOSAR OS 时间保护
从AUTOSAR OS四种可裁剪类型可以看出，时间保护(Timing Protection)是一项非常重要的功能保护机制。 如之前文章所示，AUTOSAR OS作为一实时操作系统，那么就需要在预定的时间内完成特定的任务，但有时由于某些原因导致超时错误，OS必须采用有效的方式来预防超时任务的发生，而这类措施则可以称为时间保护。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ad095d93b1200686215b2af22d028464/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0fd6c4985db10a7089bd64449a5bd3d4/" rel="bookmark">
			解决打开IEAD提示Your idea evaluation has expired. Your session will be limited to 30 minutes方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 打开IEAD提示Your idea evaluation has expired. Your session will be limited to 30 minutes方法 Your IntelliJ IDEA evaluation has expired. Your session will be limited to 30 minutes. For information on how to upgrade your evaluation software please go to 1,help— Register 2, 点击Register如图所示，选中箭头图标和划线里面的地址修改http://fls.jetbrains-agent.com（原地址替换此地址）最后点击应用即可，最后重新打开Iead 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5df91bcd69027c1f1fec3dc5b0cce06f/" rel="bookmark">
			k8s的“前端”——ingress
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
Ingress 简介
Ingress 组成
Ingress 工作原理
部署 nginx-ingress-controller
ingress 暴露服务的方式
DaemonSet+HostNetwork+nodeSelecto
Deployment+NodePort模式的Service
创建虚拟主机资源
Ingress HTTPS 代理访问
Nginx 进行重写
Nginx 进行 BasicAuth
总结
Ingress 简介 service的作用体现在两个方面，对集群内部，它不断跟踪pod的变化，更新endpoint中对应pod的对象，提供了ip不断变化的pod的服务发现机制；对集群外部，他类似负载均衡器，可以在集群内外部对pod进行访问。
在Kubernetes中，Pod的IP地址和service的ClusterIP仅可以在集群网络内部使用，对于集群外的应用是不可见的。为了使外部的应用能够访问集群内的服务，Kubernetes目前提供了以下几种方案：
●NodePort：将service暴露在节点网络上，NodePort背后就是Kube-Proxy，Kube-Proxy是沟通service网络、Pod网络和节点网络的桥梁。 测试环境使用还行，当有几十上百的服务在集群中运行时，NodePort的端口管理就是个灾难。因为每个端口只能是一种服务，端口范围只能是 30000-32767。
●LoadBalancer：通过设置LoadBalancer映射到云服务商提供的LoadBalancer地址。这种用法仅用于在公有云服务提供商的云平台上设置 Service 的场景。受限于云平台，且通常在云平台部署LoadBalancer还需要额外的费用。 在service提交后，Kubernetes就会调用CloudProvider在公有云上为你创建一个负载均衡服务，并且把被代理的Pod的IP地址配置给负载均衡服务做后端。
externalIPs：service允许为其分配外部IP，如果外部IP路由到集群中一个或多个Node上，Service会被暴露给这些externalIPs。通过外部IP进入到集群的流量，将会被路由到Service的Endpoint上。
●Ingress：只需一个或者少量的公网IP和LB，即可同时将多个HTTP服务暴露到外网，七层反向代理。 可以简单理解为service的service，它其实就是一组基于域名和URL路径，把用户的请求转发到一个或多个service的规则。
Ingress 组成 ●ingress： ingress是一个API对象，通过yaml文件来配置，ingress对象的作用是定义请求如何转发到service的规则，可以理解为配置模板。 ingress通过http或https暴露集群内部service，给service提供外部URL、负载均衡、SSL/TLS能力以及基于域名的反向代理。ingress要依靠 ingress-controller 来具体实现以上功能。
●ingress-controller： ingress-controller是具体实现反向代理及负载均衡的程序，对ingress定义的规则进行解析，根据配置的规则来实现请求转发。 ingress-controller并不是k8s自带的组件，实际上ingress-controller只是一个统称，用户可以选择不同的ingress-controller实现，目前，由k8s维护的ingress-controller只有google云的GCE与ingress-nginx两个，其他还有很多第三方维护的ingress-controller，具体可以参考官方文档。但是不管哪一种ingress-controller，实现的机制都大同小异，只是在具体配置上有差异。 一般来说，ingress-controller的形式都是一个pod，里面跑着daemon程序和反向代理程序。daemon负责不断监控集群的变化，根据 ingress对象生成配置并应用新配置到反向代理，比如ingress-nginx就是动态生成nginx配置，动态更新upstream，并在需要的时候reload程序应用新配置。为了方便，后面的例子都以k8s官方维护的ingress-nginx为例。
Ingress-Nginx github 地址：GitHub - kubernetes/ingress-nginx: NGINX Ingress Controller for Kubernetes
Ingress-Nginx 官方网站：Welcome - NGINX Ingress Controller
总结：ingress-controller才是负责具体转发的组件，通过各种方式将它暴露在集群入口，外部对集群的请求流量会先到 ingress-controller， 而ingress对象是用来告诉ingress-controller该如何转发请求，比如哪些域名、哪些URL要转发到哪些service等等。
Ingress 工作原理 （1）ingress-controller通过和 kubernetes APIServer 交互，动态的去感知集群中ingress规则变化，
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5df91bcd69027c1f1fec3dc5b0cce06f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a45c5e39d604d90da106bb6f2e1aa34/" rel="bookmark">
			带着问题看源码 —— BeanFactory和ApplicationContext的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		BeanFactory spring容器的底层接口，可以根据bean定义的信息，返回对应的实例对象。提供了最简单的容器获取和实例化对象的功能。
ApplicationContext 我们从继承图上可以看到ApplicationContext继承自BeanFactory，所以BeanFactory有的功能，都包含其中，并且对于比BeanFactory，提供了更加丰富的功能。增加那些具体的实现了我们可以总ApplicationContext的描述中看到
/* &lt;p&gt;An ApplicationContext provides: * &lt;ul&gt; * &lt;li&gt;Bean factory methods for accessing application components. * Inherited from {@link org.springframework.beans.factory.ListableBeanFactory}. * &lt;li&gt;The ability to load file resources in a generic fashion. * Inherited from the {@link org.springframework.core.io.ResourceLoader} interface. * &lt;li&gt;The ability to publish events to registered listeners. * Inherited from the {@link ApplicationEventPublisher} interface. * &lt;li&gt;The ability to resolve messages, supporting internationalization. * Inherited from the {@link MessageSource} interface.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0a45c5e39d604d90da106bb6f2e1aa34/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd6f7734de1bbd2a640b758667c5c794/" rel="bookmark">
			信息学奥赛一本通 1387：搭配购买(buy) | 洛谷 P1455 搭配购买
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【题目链接】 ybt 1387：搭配购买(buy)
洛谷 P1455 搭配购买
【题目考点】 1. 并查集 2. 动态规划：01背包 【解题思路】 有限钱买物品，要价值最大，每件物品只能买一次，能看出这是一个01背包问题。
题目中说：“互相搭配的云要一起买”，并给定了云之间的搭配关系，这就是一种集合关系。这种集合结构可以使用并查集来表示。
互相搭配的云构成一个集合，一个云的集合是一件物品，集合中所有云的价值加和为该物品的价值，集合中所有云的价钱加和为该物品的重量。
因此知道了每件物品的价值和重量，背包大小为这个人拥有的钱数w，用01背包问题的解法即可解决该问题。
【题解代码】 解法1：并查集+01背包 #include&lt;bits/stdc++.h&gt; using namespace std; #define N 10005 int n, m, wn; int fa[N], c[N], d[N];//c[i]：以i为根结点的集合的总价钱 d[i]：i为根结点的集合的总价值 int v[N], w[N], an, dp[N];//背包问题 v:价值 w:重量 dp[j]：前i个物品装入大小为j的背包的最大价值 void init() { for(int i = 1; i &lt;= n; ++i) fa[i] = i; } int find(int x) { return fa[x] == x ? x : (fa[x] = find(fa[x])); } void merge(int i, int j) { int x = find(i), y = find(j); if(x !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dd6f7734de1bbd2a640b758667c5c794/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e95b0d391365ff0ad226ce9e3c100045/" rel="bookmark">
			Hadoop-day07(MapReduce三个小案例)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MapReduce三个小案例 回顾一下 wordcount案例中map阶段 回顾一下 wordcount案例中的reduce阶段 1、IK分词器(统计三国演义指定词语个数) 步骤一：找到ik依赖,并添加到环境中
步骤二：在hadoop项目中创建子项目，并添加环境依赖
步骤三：小测试一下，结果如下：
步骤四：通过程序在 HDFS 中的 sgyy.txt 中统计 三国演义出现的次数
《三国演义》是中国文学史上第一部章回小说，是历史演义小说的开山之作，也是第一部文人长篇小说，明清时期甚至有“第一才子书”之称。 [1] 《三国演义》(全名为《三国志通俗演义》，又称《三国志演义》)是元末明初小说家罗贯中根据陈寿《三国志》和裴松之注解以及民间三国故事传说经过艺术加工创作而成的长篇章回体历史演义小说，与《西游记》《水浒传》《红楼梦》并称为中国古典四大名著。该作品成书后有嘉靖壬午本等多个版本传于世，到了明末清初，毛宗岗对《三国演义》整顿回目、修正文辞、改换诗文，该版本也成为诸多版本中水平最高、流传最广
等等 。。。。
首先：配置依赖开始第一次尝试，失败。原因是没有添加能够将 IKanalyzer 打包的依赖。下面是配置了将依赖一起打包的代码
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;parent&gt; &lt;artifactId&gt;java-hadoop&lt;/artifactId&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;hadoop-sanguodemo&lt;/artifactId&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- https://mvnrepository.com/artifact/org.apache.hadoop/hadoop-common --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt; &lt;artifactId&gt;hadoop-common&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.apache.hadoop/hadoop-client --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt; &lt;artifactId&gt;hadoop-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.apache.hadoop/hadoop-hdfs --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt; &lt;artifactId&gt;hadoop-hdfs&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/com.janeluo/ikanalyzer --&gt; &lt;dependency&gt; &lt;groupId&gt;com.janeluo&lt;/groupId&gt; &lt;artifactId&gt;ikanalyzer&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e95b0d391365ff0ad226ce9e3c100045/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4783427ba5ec8dbf1957acf7c138b28/" rel="bookmark">
			【无标题】c# 在Emit代码中如何await一个异步方法学习通http://www.bdgxy.com/
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章来源： 学习通http://www.bdgxy.com/
普学网http://www.boxinghulanban.cn/
智学网http://www.jaxp.net/
表格制作excel教程http://www.tpyjn.cn/
学习通http://www.tsgmyy.cn/
目录 0. 前言
Demo 说明
1. ContinueWith 2. GetAwaiter().GetResult() 3. async/await 完整Demo放在
0. 前言
首先立马解释一波为啥会有这样一篇伪标题的Demo随笔呢?
不是本人有知识误区，或者要误人子弟
因为大家都知道emit写出来的都是同步方法，不可能await，至少现在这么多年来没有提供对应的功能
这是之前某天在微信群看见讨论怎么emit一个异步方法并包装异步结构，简单几句文字也未能清晰的表达
所以趁着元旦节放假有点时间，
简单列举三种我知道方式去达到这样的效果
三种方法都是绕过emit直接书写emit代码，而是将对应逻辑转到其他方法中，最后emit调用方法达到效果
Demo 说明
原始方法是个延迟2秒之后返回55的方法：
public static async Task&lt;int&gt; GetV() { await Task.Delay(2000); return 55; } 现在我们需要把 55 的结果加 6 ，让最终的结果变为 61
我们的测试方法是这样，会输出一些简单的时间，帮助我们了解执行顺序和异步情况
private static async Task Test(MethodInfo method, MethodInfo awaitMehtod) { var caller = CreateCaller(method, awaitMehtod); Console.WriteLine($"Start {awaitMehtod.Name} at: {DateTime.Now}."); var task = caller(); Console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e4783427ba5ec8dbf1957acf7c138b28/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa50544d0042edeb303462752443a252/" rel="bookmark">
			对称加密和非对称的区别，非对称加密有哪些
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.加密和解密的过程不同：对称加密和解密过程使用同一个密钥；非对称加密中加密和解密采用公钥和私钥两个密钥，一般使用公钥进行加密，使用私钥进行解密。
2.加密和解密的速度不同：对称加密和解密速度较快，当数据量比较大时适合使用；非对称加密和解密时间较长，速度相对较慢，适合少量数据传输的场景。
3.传输的安全性不同：采用对称加密方式进行通信时，收发双方在数据传送前需要协定好密钥，而这个密钥还有可能被第三方窃听到的，一旦密钥泄漏，之后的通信就完全暴漏给攻击者了；非对称加密采用公钥加密和私钥解密的方式，其中私钥是基于不同的算法生成的随机数，公钥可以通过私钥通过一定的算法推导得出，并且私钥到公钥的推导过程是不可逆的，也就是说公钥无法反推导出私钥，即使攻击者窃听到传输的公钥，也无法正确解出数据，所以安全性较高。
4.常见的非对称加密算法主要有：RSA、Elgamal、背包算法、Rabin、D-H 算法等等。
talk is cheap show me the code 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc51931a702643a3520a9f8d90de201b/" rel="bookmark">
			ISP系统综述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本期主题：
ISP系统综述
文章目录 1.ISP是什么？2.ISP由什么构成3.图像数据的处理流程1.传统图像的pipeline2.图像产生过程：3.YUV域 1.ISP是什么？ ISP全称是Image Signal Processor，图像信号处理器，用于处理图像信号传感器输出的图像信号，是相机系统的重要组成部分。
2.ISP由什么构成 ISP内部包括CPU、SUB IP、IF等设备，事实上，ISP是一个SOC，可以运行各种算法来实时处理图像信号。
ISP的架构如下图所示：
CPU，中央处理器，可以运行各种图像算法，控制外设；SUB IP，各个功能模块的统称，对图像进行专业的处理；IF，图像传输的接口，手机领域常用MIPI-CSI；通用外围控制设备，I2C、SPI等等； 3.图像数据的处理流程 1.传统图像的pipeline 一个典型的ISP流水线由一系列的模块构成，数据在这些模块中一级级运转，最终以 YUV或RGB格式 流出ISP，整体结构如下图所示：
参考至链接：
Understanding ISP Pipeline
图像在ISP内部经过了两次颜色空间的转变，分别是：
从RAW domain转换到RGB domain，从sensor拿到的数据是原始的bayer数据，经过坏点修复、黑电平校正、镜头阴影修正等操作，将raw数据先优化一波，然后在Bayer-Demosaic模块，进行颜色插值，将raw数据转换成RGB数据；从RGB domain转换到YUV domain，变成RGB数据之后，还有修正工作，比如其后的gamma修正，在 CSC（color space conversion，色彩空间转换） 之后，变成了YUV域 2.图像产生过程： 景物通过 Lens 生成的光学图像投射到 sensor 表面上， 经过光电转换为模拟电信号， 消噪声后经过 A/D 转换后变为数字图像信号， 再送到 ISP 中加工处理。
从sensor端过来的数据是RAW数据，图像将实际的景象转成图像数据时，通常是用红绿蓝三原色来表示的，在黑白的CMOS传感器上，分别套上不同颜色的滤光片，这样就得到了拜耳的raw图，详细原理可参考 ISP（图像信号处理）之Bayer Raw 简介Demosaic颜色插值，这一步实现了RAW domain 转换为RGB domain，当得到bayer raw数据之后，每个像素都为单色光，从而理想的Bayer 图是一个较为昏暗的马赛克图，数字图像处理中用来从不完整的color samples插值生成完整的color samples的方法(因为bayer pattern看起来像一个个马赛克，因此称为去马赛克)；CSC颜色空间转换，这一步将RGB数据转成了YUV数据，YUV数据是将亮度信息和色彩信息区分开了，其中Y代表亮度，UV代表颜色； 3.YUV域 RGB大家应该都清楚，那YUV的定义是什么？
1.颜色空间
其实YUV与RGB一样，都是颜色空间，RGB是三原色红绿蓝的命名，而YUV实际上是亮度、色度、浓度，具体来说就是：
Y 代表的是明亮度（Luminance 或 Luma）；U 和 V 代表则是 色度、浓度（Chrominance、Chroma）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cc51931a702643a3520a9f8d90de201b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3a26598f4843cb9e00cd6ac1c1d2502/" rel="bookmark">
			IDEA “Easy Code“ 插件(v1.2.5-java版本) 自动生成代码报红
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、环境：Win10/Jdk11.0.15/idea2021.3.3(Maven 3.8.5)
二、操作运行：
三、生成的代码报红效果：
四、解决：POM.xml 增加依赖包
&lt;!-- https://mvnrepository.com/artifact/org.springframework.data/spring-data-commons --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.data&lt;/groupId&gt; &lt;artifactId&gt;spring-data-commons&lt;/artifactId&gt; &lt;version&gt;2.7.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;4.3.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; 我的完整 POM.xml 文件内容如下：
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.ltg&lt;/groupId&gt; &lt;artifactId&gt;mybatis-first&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.10&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.28&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.13.2&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework.data/spring-data-commons --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.data&lt;/groupId&gt; &lt;artifactId&gt;spring-data-commons&lt;/artifactId&gt; &lt;version&gt;2.7.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;4.3.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.glassfish/javax.annotation --&gt; &lt;dependency&gt; &lt;groupId&gt;org.glassfish&lt;/groupId&gt; &lt;artifactId&gt;javax.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b3a26598f4843cb9e00cd6ac1c1d2502/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/934f7b0ec346a7e100ddcffcab881809/" rel="bookmark">
			网络带宽单位转换 — MB/s、Mb/s、Mbps、Mbit/s、Kbps
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、bit/s 和 bps 的区别
bit/s 和 bps 都是一样的意思（bit per second）
2、KB/s 和 Kb/s 的区别（大写 B 和小写 b）
KB/s 和 Kb/s 的意思不一样
KB/s 中的 大 B 表示 Byte
Kb/s 中的 小 b 表示 bit
所以 KB/s 转换为 Kb/s 要乘以 8 ，Kb/s 转换为 KB/s 要除以 8
3、MB/s（兆字节每秒）、Mb/s（兆比特每秒）、Mbps（兆比特每秒）、Mbit/s（兆比特每秒）、Kbps（千比特每秒）
1Byte(字节) = 8 bit(比特) 【1B=8b】
1MB(百万字节也称兆字节) = 8 Mb
1Mb = 0.125MB
1Kb = 1024bit
1KB = 1024Byte
Mbps 即 Milionbit per second(百万位每秒)；
// Milionbit=1000Kilobit=1000000bit，所以1Mbps=1000 000bps；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/934f7b0ec346a7e100ddcffcab881809/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41e2d85bf6b7aba5a89da42e36e9b09b/" rel="bookmark">
			HTTP 请求格式与RestTemplate
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HTTP 格式 请求： GET /more HTTP/1.1 Host: www.baidu.com Connection: keep-alive Cache-Control: max-age=0 Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/94.0.4606.61 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9 Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7 请求行请求标头空行请求体 响应： HTTP/1.1 200 OK Cache-Control: private Connection: keep-alive Content-Encoding: gzip Content-Type: text/html;charset=utf-8 Date: Sat, 02 Oct 2021 08:14:53 GMT Expires: Sat, 02 Oct 2021 08:14:53 GMT Server: BWS/1.1 X-Frame-Options: sameorigin X-Ua-Compatible: IE=Edge,chrome=1 Transfer-Encoding: chunked {"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/41e2d85bf6b7aba5a89da42e36e9b09b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4831816f7116f74c4ccd87be2192604a/" rel="bookmark">
			升级openssh后版本不一致问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		[root@ecs-7ef8 ~]# ssh -V
OpenSSH_8.4p1, OpenSSL 1.0.2k-fips 26 Jan 2017
[root@ecs-7ef8 ~]# /usr/bin/ssh -V
OpenSSH_8.7p1, OpenSSL 1.1.1o 3 May 2022
[fortress@ecs-7ef8 ~]$ ssh -V
OpenSSH_8.7p1, OpenSSL 1.1.1o 3 May 2022
[fortress@ecs-7ef8 ~]$ which sshd
/usr/sbin/sshd
[fortress@ecs-7ef8 ~]$ which ssh /usr/bin/ssh
[root@ecs-7ef8 ~]# ps aux | grep ssh root 67696 0.0 0.0 33812 1364 ? Ss May26 0:00 sshd: /usr/sbin/sshd [listener] 0 of 10-100 startups
root 102468 0.0 0.0 102676 4656 ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4831816f7116f74c4ccd87be2192604a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9d03df4e0c184b8a2d4b3aee217e2b7/" rel="bookmark">
			Ubuntu18.04上下载安装使用sogou输入法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下载地址：搜狗输入法Linux官网-首页
安装设置网址：搜狗输入法Linux官网-安装指导 这样Ubuntu下工作就更加方便了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95fc58aa0e7d4b6bcfeedd6ca74bb677/" rel="bookmark">
			Hive--实现随机抽数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.背景 在大规模数据量的数据分析及建模任务中，往往针对全量数据进行挖掘分析时会十分耗时和占用集群资源，因此一般情况下只需要抽取一小部分数据进行分析及建模操作。
Hive提供了数据取样（SAMPLING）的功能，能够根据一定的规则进行数据抽样，目前支持数据块抽样，分桶抽样和随机抽样，具体如下所示：
2.随机方法 1.数据块抽样（tablesample()函数） a.tablesample(n percent) 根据hive表数据的大小按比例抽取数据，并保存到新的hive表中。如：抽取原hive表中10%的数据
b.tablesample(n M) 指定抽样数据的大小，单位为M。
c.tablesample(n rows) 指定抽样数据的行数，其中n代表每个map任务均取n行数据，map数量可通过hive表的简单查询语句确认（关键词：number of mappers: x)
select
*
from bi_gamecenter_dev.dim_date
tablesample(10 percent)
-- 注意：测试过程中发现，select语句不能带where条件且不支持子查询，可通过新建中间表或使用随机抽样解决
2.分桶抽样 hive中分桶其实就是根据某一个字段Hash取模，放入指定数据的桶中，比如将表table_1按照ID分成100个桶，其算法是hash(id) % 100，这样，hash(id) % 100 = 0的数据被放到第一个桶中，hash(id) % 100 = 1的记录被放到第二个桶中。创建分桶表的关键语句为：CLUSTER BY语句。
分桶抽样语法：
TABLESAMPLE (BUCKET x OUT OF y [ON colname])
其中x是要抽样的桶编号，桶编号从1开始，colname表示抽样的列，y表示桶的数量。
例如：将表随机分成10组，抽取其中的第一个桶的数据
select
*
from bi_quickgame.dim_qg_fb_cls
tablesample(bucket 1 out of 10 on rand())
3.随机抽样（rand()函数） 1.使用rand()函数进行随机抽样，limit关键字限制抽样返回的数据，其中rand函数前的distribute和sort关键字可以保证数据在mapper和reducer阶段是随机分布的
-- 每月随机抽取5天
-- 直接关联这个结果就可以了
select
cal_dt
,month_id
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/95fc58aa0e7d4b6bcfeedd6ca74bb677/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/948aff8bbd3e601031d0328e29729dfc/" rel="bookmark">
			CodeMirror自定义关键词添加class
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 /** risk:['demo'] //自定义关键词数组 eachLine //codeMirror遍历行 cmOptions: { codeMirror options lineNumbers: true, matchBrackets: true, mode: this.scriptType, tabSize: 4, line: true, styleSelectedText: true, }, content:'document.getElementById("demo").innerHTML=Date();' **/ this.editor = CodeMirror.fromTextArea(this.$refs.mycode, this.cmOptions); this.editor.setValue(this.content); this.editor.eachLine((line) =&gt; { const risk = this.risk.includes(line.text); if (risk) { const getLine = this.editor.lineInfo(line).line;// 获取行号 const getStart = line.text.indexOf() + 1; // 获取起始位置 const getEnd = getStart + line.text.length; // 获取结尾位置 this.editor.markText({ line: getLine, ch: getStart }, { line: getLine, ch: getEnd }, { className: 'styled-background' }); } }); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31d2ca75e1c20d25df8598fb68d1dfa9/" rel="bookmark">
			Ue5 导入图片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C++部分：
```cpp // Fill out your copyright notice in the Description page of Project Settings. #include "SimplePictureToolsLibrary.h" #include "IImageWrapper.h" #include "IImageWrapperModule.h" bool USimplePictureToolsLibrary::LoadImageToTextrue2D(const FString&amp; ImagePath, UTexture2D*&amp; InTexture2D, float&amp; Width, float&amp; Higth) { TArray&lt;uint8&gt; ImageResultData; FFileHelper::LoadFileToArray(ImageResultData, *ImagePath); //载入文件为二进制数组 FString Ex = FPaths::GetExtension(ImagePath, false); //取文件的后缀名 ， 不带点 //根据不同的后缀名 输出不同的 图片类型枚举 变量 EImageFormat ImageFormat = EImageFormat::Invalid; if (Ex.Equals(TEXT("jpg"), ESearchCase::IgnoreCase) || Ex.Equals(TEXT("Jpeg"), ESearchCase::IgnoreCase)) //判断当前后缀名，和 是否要忽略大小写 { ImageFormat = EImageFormat::JPEG; } else if (Ex.Equals(TEXT("PNG"), ESearchCase::IgnoreCase)) { ImageFormat = EImageFormat::PNG; } else if (Ex.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/31d2ca75e1c20d25df8598fb68d1dfa9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4266c4770fcb2c6338d82fb05408085/" rel="bookmark">
			C&#43;&#43; - 使用std::chrono获取当前秒级/毫秒级/微秒级/纳秒级时间戳
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 使用std::chrono获取当前秒级/毫秒级/微秒级/纳秒级时间戳 1.1 当前时间戳获取方法 先使用std::chrono获取当前系统时间，然后将当前系统时间转换为纪元时间std::time_t类型，之后使用std::localtime对std::time_t类型转换为本地时间结构体std::tm类型，最后使用strftime对时间进行格式化输出。
其中std::tm该结构包含了一个被分解为以下各部分的日历时间
struct tm { int tm_sec; // 秒，范围从 0 到 59 int tm_min; // 分，范围从 0 到 59 int tm_hour; // 小时，范围从 0 到 23 int tm_mday; // 一月中的第几天，范围从 1 到 31 int tm_mon; // 月份，范围从 0 到 11 int tm_year; // 自 1900 起的年数 int tm_wday; // 一周中的第几天，范围从 0 到 6 int tm_yday; // 一年中的第几天，范围从 0 到 365 int tm_isdst; // 夏令时 }; 而size_t strftime(char *str, size_t maxsize, const char *format, const struct tm *timeptr)函数根据format中定义的格式化规则，格式化结构timeptr表示的时间，并把它存储在str中。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e4266c4770fcb2c6338d82fb05408085/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce4e97edbcfd50bbf314cc978ff8eb67/" rel="bookmark">
			大规模分布式训练简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		故事一说 古有曹冲称象，为人津津乐道。而“大规模分布式训练”堪称机器学习领域的的“曹冲称象”。
三国时曹操等大臣面临的问题是大象的重量超过了称的极限。如果我们把故事中的对象替换一下：
大象替换成类似GPT3这类的参数超万亿的大模型称替换成类似GPU-A100,这类的机器学习处理器重量替换成机器训练大模型所需的内存 那什么是“大规模分布式训练”呢？
翻译翻译就是：大模型预训练所需的内存超过了单张深度学习处理器的内存。于是机器学习的工程师们纷纷化身曹冲，提出肢解大模型而又不尽量影响模型运行的的方案！
比较尴尬的是， 现代工程师们找不到一只可以容纳整个模型的船（也许2077年，nvidia发布A1000或者H1000，就是我们要找的船），于是工程师只好另辟蹊径，拿多杆秤称一头象了。如何协调多杆秤工作，就是一个技术活了。
简而言之：大规模分布式训练的目标是协调多台机器简单高效的运行大规模的模型。
问题剖析 假设运行模型所需的内存为 Requried_Momory，单卡的内存 Device_Memory。
现状是 Required_Memory &gt;&gt; Device_Memory，这是大规模分布式训练面临的核心矛盾，供需严重失衡。
解决这个矛盾的就是让这个不等式变成 Required_Memory &lt;= Device_Memory，使供需平衡。
解决方案无非就是两个思路：节流和开源。
节流，即尝试减少 Required_Memory。开源就是增大 Device_Memory。
模型内存分析 弄清问题的本质是供需不平衡，接下来我们需要厘清这这两个变量是怎么产生的。
Device_Memory : 由硬件决定的，当芯片型号确定时，可以认定这是个常量。
Required_Memory: 根据笔者了解，模型训练中内存消耗主要来自两块，分别是
神经元的中间值参数值（包括权值，梯度值和优化器的状态值） 大规模分布式训练的解决方案 节流 假设要训练一个参数量为10亿的模型，即参数量大小固定了，无法进行节流，节流的主意只能打在了神经元的中间值上。
常见的节流策略如下：
1 激活重计算（Activation-Recompute）
在网络中标记少量的算子 ，前向计算只保留这些被标记的算子的输出结果（激活值）， 其余前向算子的输出结果直接被释放，这样就可以极大减少激活值消耗的内存。当反向更新梯度需要前向算子的输出时，利用被标记的算子重新计算获取。
激活重计算是一个以时间换空间的策略。
开源 开源的目标是扩大 Device_Memory，但 Device_Memory 受硬件限制，无法改变。但脑袋一动，单卡的 Device_Memory 是固定的，可以多张卡协作，共同运行模型，这样就相当于扩大了 Device_Memory。
常见的开源策略如下：
1 数据并行（Data Parallel）
传统的数据并行（DDP），在反向计算完成后，每张卡上的梯度和权值，优化器的状态值是完全一致的。即各张卡之间进行的是完全一致的计算。因此可以将这部分的计算分散到各张卡上，每张卡仅保存部分的梯度，梯度和状态值。
针对大模型的数据并行策略，微软在DeepSpeed 框架提出了零冗余优化器（ZeRO Redunrancy Optimizer, 以下简称ZeRO）实现了节省模型训练过程中所需的内存。
2 模型并行（Model Parallel）
将模型中特定子图中的权值均匀的分配到多张卡上，每张卡进行部分计算，然后通过节点间通信获取完整的输出。从而有效降低单卡上的内存消耗。
模型并行策略的详细介绍：大规模分布式训练–模型并行策略
流水并行（Pipeline Parallel）
将网络切成若干子网络，每个子网络单独的运行在一张卡上，上一层的输出作为下一层的输入。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ce4e97edbcfd50bbf314cc978ff8eb67/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a619ceec9db53dcc5bcaab6d7367c6f6/" rel="bookmark">
			超图leaflet临时图层：在子图层中过滤特定属性的要素生成临时地图服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		超图leaflet临时图层：在子图层中过滤特定属性的要素生成临时地图服务
应用场景 通常直接在前端显示矢量，前端web压力大。为了缓解前端压力，此方法把压力转移到了服务端。
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title data-i18n="resources.title_drawFeatures"&gt;&lt;/title&gt; &lt;script type="text/javascript" src="js/include-web.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" include="leaflet.draw" src="dist/leaflet/include-leaflet.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; var map,layer, url = "https://iserver.supermap.io/iserver/services/map-jingjin/rest/maps/京津地区土地利用现状图";	setsetLayer(); function setLayer() { //子图层属性过滤条件 var layerStatus = new SuperMap.LayerStatus({ layerName: "Landuse_R@Jingjin#1",//图层名称 isVisible: true,//是否可见 displayFilter: "LANDTYPE='灌丛' "//属性过滤条件 }); var setLayerStatusParameters = new SuperMap.SetLayerStatusParameters({ layerStatusList: [layerStatus]//数组来自上面的layerStatus //holdTime:15,//获取或设置资源在服务端保存的时间。 //resourceID:"2"//获取或设置资源服务 ID。 }); var setLayerStatusService = new SuperMap.SetLayerStatusService(url, { eventListeners: { "processCompleted": setLayerCompleted, "processFailed": setLayerFailed } }); setLayerStatusService.processAsync(setLayerStatusParameters); }	function setLayerCompleted(e) { tempLayerID = e.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a619ceec9db53dcc5bcaab6d7367c6f6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bfcdeb7c39e65ba1253f1a233ca35188/" rel="bookmark">
			pywinauto基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本博客仅为个人学习使用，是看大佬视频做的笔记，侵权可联系作者删除~~
pywinauto的安装，在cmd命令行窗口直接输入pip install pywinauto即可 1、通过进程号或句柄连接 from pywinauto.application import Application # 通过pywinauto去连接已经打开的应用程序 # 通过进程号进行连接，可以使用ViewWizard查看进程号等信息 # 通过PID连接，需要先打开程序 # app = Application('uia').connect(process=6136) # print(app) # 通过窗口句柄进行连接 # 同样需要先打开程序，然后使用ViewWizard获取句柄，句柄是动态的 app = Application('uia').connect(handle=131914) ''' 这个uia，在启动navicat的时候需要，不然报错； 启动文本文件的时候不用，不然找不到弹出的窗口 初步推论：win32(可不填)在自带程序中使用，其他需下载安装等程序使用uia Win32 API（backend="win32"） - 现在的默认后端 MFC，VB6，VCL，简单的WinForms控件和大多数旧的遗留应用程序,win32 MS UI Automation（backend="uia"） WinForms，WPF，商店应用，Qt5，浏览器，navicat 注意：Chrome --force-renderer-accessibility在启动前需要cmd标志。 由于comtypes Python库限制，不支持自定义属性和控件。''' print(app) 2、通过路径打开app并选择窗口 from pywinauto.application import Application # 启动navicat,路径也可以通过ViewWizard工具获取 app = Application('uia').start(r'E:\Navicat Premium 15\navicat.exe') # 方式一 app[类名/标题] # 使用窗口类名来选择窗口 # dlg = app["TNavicatMainForm"] # 使用窗口标题来选择窗口 dlg = app['Navicat Premium'] dlg.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bfcdeb7c39e65ba1253f1a233ca35188/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12019e06c8361f2b60b7e9833de19293/" rel="bookmark">
			2022年安全员-C证试题及模拟考试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题库来源：安全生产模拟考试一点通公众号小程序
2022安全员-C证上岗证题库是安全员-C证国家题库新版教材大纲题库！2022年安全员-C证试题及模拟考试依据安全员-C证考试教材。安全员-C证考试资料随时根据安全生产模拟考试一点通上模拟考试。
1、【多选题】下列哪些属于施工现场的安全防护用具？（ ACD ）
A、绝缘鞋
B、模板
C、安全帽
D、安全带
E、消防桶
2、【多选题】在生产过程中,下列哪些属于事故？（ ABCDE ）
A、人员死亡
B、人员重伤
C、财产损失
D、人员轻伤
E、设备损失
3、【多选题】塔式起重机金属结构基础部件包括( )。（ ABCE ）
A、底架
B、塔身
C、平衡臂
D、卷扬机
E、转台
4、【多选题】对现场建筑材料的堆放的一般要求有( )。（ ABCDE ）
A、应当根据用量大小、使用时间长短、供应与运输情况堆放
B、各种材料必须按照总平面图规定的位置放置，
C、各种材料物品必须堆放整齐，并符合安全、防火的要求
D、应当按照品种、规格堆放，并设明显标牌，标明名称、规格、产地等
E、要有排水措施、符合安全防火的要求
5、【多选题】建筑工地噪声主要包括( )。（ ACD ）
A、机械性噪声
B、施工人员叫喊声
C、空气动力性噪声
D、电磁性噪声
E、临街面的嘈杂声
6、【多选题】推土机在坡道上停机时，应( )。（ ABDE ）
A、将变速杆挂低速档
B、接合主离合器
C、操纵人员不得离开
D、锁住制动踏板
E、将履带或轮胎楔住
7、【多选题】施工总平面图编制的主要依据有( )。（ ABCDE ）
A、工程所在地区的原始资料；
B、施工方案、施工进度和资源需要计划
C、原有和拟建建筑工程的位置和尺寸
D、建设单位可提供房屋和其他设施
E、全部施工设施建造方案
8、【多选题】施工现场按照功能可划分为( )等区域。（ ACDE ）
A、施工作业区
B、辅助作业区
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/12019e06c8361f2b60b7e9833de19293/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4bf1073176d10220f7103887f573b187/" rel="bookmark">
			WVPPro&#43;ZLMediaKit&#43;大华相机推流&#43;安卓模拟GB28181设备推流
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		wvp pro有三种部署方式
（1）wvp pro jar包+ZLMediaKit。本文主要基于此种方式。
（2）docker hub直接下载docker，其内置了 wvp pro jar+ZLMediaKit。第10小节讲解了此种方式。
（3）docker-compose运行。docker-compose 运行wvp-pro_fang·up·ad的博客-CSDN博客 1.项目源码 WVP Pro GitHub WVP是一个GB28181平台
ZLMediaKit GitHub
安装参考教程
国标GB28181介绍_嵌入彭于晏的博客-CSDN博客_28181
2. 部署WVP Pro项目 （1）下载WVP Pro源码
git clone https://gitee.com/pan648540858/wvp-GB28181-pro.git ♫）application.yml指定配置文件为application-dev.yml
spring: profiles: active: dev ♫）配置zlm节点
application-dev.yml中修改media.http-port为ZLMediaKit的config.ini配置文件http-port属性值一致；修改media.secret和config.ini的genaral.mediaServerId一致（一般情况下，如果删除节点，重新添加节点时才需要修改；如果日志报错zlm节点重复，那么需要删除wvp mysql数据库中media_server表中此节点的zlm配置信息即不会报错）。
这两个项目只需要配置这两个值。
#zlm 默认服务器配置 media: # [必须修改] zlm服务器的内网IP ip: 127.0.0.1 # [必须修改] zlm服务器的http.port http-port: 8091 # [可选] zlm服务器的hook.admin_params=secret secret: 035c73f7-bb6b-4889-a715-d9eb2d1925cc # 启用多端口模式, 多端口模式使用端口区分每路流，兼容性更好。 单端口使用流的ssrc区分， 点播超时建议使用多端口测试 rtp: # [可选] 是否启用多端口模式, 开启后会在portRange范围内选择端口用于媒体流传输 enable: true # [可选] 在此范围内选择端口用于媒体流传输, port-range: 30000,30500 # 端口范围 # [可选] 国标级联在此范围内选择端口发送媒体流, send-port-range: 30000,30500 # 端口范围 # 录像辅助服务， 部署此服务可以实现zlm录像的管理与下载， 0 表示不使用 record-assist-port: 18081 ♫）本项目需要安装 Redis
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4bf1073176d10220f7103887f573b187/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6486e3330a8e0567d50c441c9f236e49/" rel="bookmark">
			yolov5中成功解决:subprocess.CalledProcessError: Command ‘pip install‘pycocotools ＞ =2.0 ‘ ‘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在yolov5中我们安装对应的包的时候总是遇到这个包下载不了的问题，由于这个包不再更新，所以需要我们自己在网上下载这个安装包。
https://pan.baidu.com/s/11YZOp_yCw6DI50vN2NM_vQ?pwd=dm8r
提取码：dm8r
可以在这里下载了，然后直接复制到当前环境下的库里面。
在这个里展示下我的当前环境下的库：
E:\Anaconda3\envs\py38\Lib\site-packages
放在这里就可以了。
也可通过Pycharm中安装：
选择你刚才下载pycocotools 的文件解压后的文件夹，就能添加到库中了。
希望能够帮助到你！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae59b5bb1f5012e250f892ba4029e85d/" rel="bookmark">
			Redis常见使用场景、缓存问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 使用场景、缓存问题缓存雪崩原因解决办法（1）redis高可用（2）加锁排队，限流降级（3）缓存失效时间均匀分布（4）使用多级缓存，或为热点数据设置永不失效 缓存穿透原因解决办法（1）接口层增加校验（2）采用布隆过滤器（3）缓存空对象 缓存击穿原因解决办法（1）设置热点数据缓存没有过期时间（2）加互斥锁，采用分布式锁的方法 使用场景、缓存问题 1、热点数据的缓存
公司项目用户量达到一定数量的时候，这时合理的利用缓存不仅能够提升项目访问速度，还能大大降低数据库的压力。
2、业务上的统计，排行榜
为了保证数据实时效，比如项目的访问量，每次浏览都得给+1，并发量高时如果每次都请求数据库操作无疑是种挑战和压力
3、限时业务的运用
每日签到、限制登录功能等业务场景
4、消息队列
提供基本的发布订阅功能，但不像消息队列那种专业级别。一些访问，点击量高的网站中必备中间件，主要用于流量削峰，异步处理实时性低的业务。（和专门的中间件效果要差些）
其他的一些功能还有聊天室好友列表，各种排行榜，秒杀，抢购，数据过期处理等等。
缓存雪崩 原因 大量redis key在同一时间失效，导致大量请求访问数据库，数据库服务器宕机，线上服务大面积报错。
缓存雪崩是指缓存中大批量的 key 同时过期，而此时数据访问量又非常大，从而导致后端数据库压力突然暴增，甚至会挂掉，这种现象被称为缓存雪崩。它和缓存击穿不同，缓存击穿是在并发量特别大时，某一个热点 key 突然过期，而缓存雪崩则是大量的 key 同时过期，因此它们根本不是一个量级。
解决办法 缓存雪崩和缓存击穿有相似之处，所以也可以采用热点数据永不过期的方法，来减少大批量的 key 同时过期。再者就是为 key 设置随机过期时间，避免 key 集中过期。
（1）redis高可用 （2）加锁排队，限流降级 （3）缓存失效时间均匀分布 （4）使用多级缓存，或为热点数据设置永不失效 缓存穿透 原因 指缓存和数据库中都没有的数据，导致所有的请求都落到数据库上，造成数据库短时间内承受大量请求而崩掉。
缓存穿透是指当用户查询某个数据时，Redis 中不存在该数据，也就是缓存没有命中，此时查询请求就会转向持久层数据库 MySQL，结果发现 MySQL 中也不存在该数据，MySQL 只能返回一个空对象，代表此次查询失败。如果这种类请求非常多，或者用户利用这种请求进行恶意攻击，就会给 MySQL 数据库造成很大压力，甚至于崩溃，这种现象就叫缓存穿透。
解决办法 （1）接口层增加校验 （2）采用布隆过滤器 布隆过滤器判定不存在的数据，那么该数据一定不存在，利用它的这一特点可以防止缓存穿透。首先将用户可能会访问的热点数据存储在布隆过滤器中（也称缓存预热，缓存预热：是指系统启动时，提前将相关的数据加载到 Redis 缓存系统中。这样避免了用户请求的时再去加载数据），当有一个用户请求到来时会先经过布隆过滤器，如果请求的数据，布隆过滤器中不存在，那么该请求将直接被拒绝，否则将继续执行查询。相较于第一种方法，用布隆过滤器方法更为高效、实用。
（3）缓存空对象 当 MySQL 返回空对象时， Redis 将该对象缓存起来，同时为其设置一个过期时间。当用户再次发起相同请求时，就会从缓存中拿到一个空对象，用户的请求被阻断在了缓存层，从而保护了后端数据库，但是这种做法也存在一些问题，虽然请求进不了 MSQL，但是这种策略会占用 Redis 的缓存空间。
缓存击穿 原因 缓存击穿是指用户查询的数据缓存中不存在，但是后端数据库却存在，这种现象出现原因是一般是由缓存中 key 过期导致的。比如一个热点数据 key，它无时无刻都在接受大量的并发访问，如果某一时刻这个 key 突然失效了，就致使大量的并发请求进入后端数据库，导致其压力瞬间增大。这种现象被称为缓存击穿。这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力。比如微博热搜。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ae59b5bb1f5012e250f892ba4029e85d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2616e3ed61593dad05ca0d9f7c3769e2/" rel="bookmark">
			8080端口占用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		liuzy13@liuzy13-047 MINGW64 ~/Desktop/robot_server(1) $ netstat -ano 活动连接 协议 本地地址 外部地址 状态 PID TCP 0.0.0.0:21 0.0.0.0:0 LISTENING 6308 TCP 0.0.0.0:23 0.0.0.0:0 LISTENING 6308 TCP 0.0.0.0:80 0.0.0.0:0 LISTENING 6308 TCP 0.0.0.0:135 0.0.0.0:0 LISTENING 1088 TCP 0.0.0.0:445 0.0.0.0:0 LISTENING 4 TCP 0.0.0.0:1026 0.0.0.0:0 LISTENING 5188 TCP 0.0.0.0:1028 0.0.0.0:0 LISTENING 912 TCP 0.0.0.0:1063 0.0.0.0:0 LISTENING 928 TCP 0.0.0.0:3000 0.0.0.0:0 LISTENING 6308 TCP 0.0.0.0:3001 0.0.0.0:0 LISTENING 6308 TCP 0.0.0.0:3002 0.0.0.0:0 LISTENING 6308 TCP 0.0.0.0:3080 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2616e3ed61593dad05ca0d9f7c3769e2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c69220ccdeed8a8560a83608eaeb6c78/" rel="bookmark">
			ambari卸载删除节点步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.删除组件 yum remove -y hive* yum remove -y hdfs* yum remove -y yarn* yum remove -y mapreduce2* yum remove -y tez* yum remove -y hbase* yum remove -y pig* yum remove -y sqoop* yum remove -y oozie* yum remove -y zookeeper* yum remove -y falcon* yum remove -y storm* yum remove -y flume* yum remove -y accumulo* yum remove -y Ambari Infra* yum remove -y Ambari Metrics* yum remove -y Atlas* yum remove -y Kafka* yum remove -y Knox* yum remove -y Log Search* yum remove -y Ranger* yum remove -y Ranger KMS* yum remove -y SmartSense* yum remove -y Zeppelin Notebook* yum remove -y Druid* yum remove -y Mahout* yum remove -y Slider* yum remove -y atlas* yum remove -y atlas-metadata* yum remove -y ranger* yum remove -y bigtop* yum remove -y spark2* yum remove -y ranger* yum remove -y slider* yum remove -y ranger* yum remove -y spark* 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c69220ccdeed8a8560a83608eaeb6c78/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57986c755757b9d78f7f1e2f1a8f2d47/" rel="bookmark">
			cs怎么学？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以下一些别人的博客内容。强推最后一个指南
How to Learn CS?-2018： 学一门动态语言、一门静态语言。
Python（动态）
作者自己写的Python学习步骤，还推荐一本书《Python Crash Course》
Java（静态）
《Java fundamentals》、《advanced JAVA features》
硬件层面
《The Elements of Computing Systems》 by Noam Nisan and Shimon Schocken：硬件、编译器、链接器和操作系统
算法、数据结构
大公司面试注重考查数据结构问题，推荐一本书《Introduction to Algorithms》。不限定语言的书籍，如果一定要限制使用语言的话，这有一部分推荐use JAVA或者use Python
网络知识
《Computer Networking: A Top-Down Approach》by Kurose和Ross，书籍包含网络基础知识。
操作系统Operating System
最好的项目之一：Operating Systems Conceptsby Abraham Silberschatz，需要一点C语言基础。如果不想成为kernel开发，就忽视遇到的难题，理解全部内容很花时间，理解主要的基础内容就够了。
OSDev Wiki：学习怎样创建自己的kernel，但很难
分布式系统Distributed Sysytems
这个blog是最推荐的学习，或者是书by Martin Kleppmann，学习理论，也通过研究分布式系统项目来加深学习。
机器学习
Andrew Ng’s course是推荐的新手课程《An Introduction to Statistical Learning》：需要有点统计学和数学 Comprehensive Guide to Learn Computer Science Online-2020: 程序语言：JAVA或者Python
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/57986c755757b9d78f7f1e2f1a8f2d47/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8690ff0ef21ba12e9f3d1e5a266c6fc6/" rel="bookmark">
			安装canvas遇到的问题和运行项目遇到的报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.mac安装问题 1）第一步使用brew安装：brew install pkg-config cairo pango libpng jpeg giflib librsvg
如果上面命令安装出错，可以分开安装（推荐）
brew install pkg-config
brew install cairo
brew install pango
brew install libpng
brew install jpeg
brew install giflib
brew install librsvg
具体也可以参考官网文档：
GitHub - Automattic/node-canvas: Node canvas is a Cairo backed Canvas implementation for NodeJS.Node canvas is a Cairo backed Canvas implementation for NodeJS. - GitHub - Automattic/node-canvas: Node canvas is a Cairo backed Canvas implementation for NodeJS.https://github.com/Automattic/node-canvashttps://github.com/Automattic/node-canvas/wiki/https://github.com/Automattic/node-canvas/wiki/ 安装完之后，可以使用命令：brew list 查看是否都已安装上
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8690ff0ef21ba12e9f3d1e5a266c6fc6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df5eba1f4524482a5dbf45b3fceb504d/" rel="bookmark">
			2022金属非金属矿山安全检查（地下矿山）考试练习题及答案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题库来源：安全生产模拟考试一点通公众号小程序
2022金属非金属矿山安全检查（地下矿山）考试题模拟考试题库为金属非金属矿山安全检查（地下矿山）考试题新版教材大纲题库！2022金属非金属矿山安全检查（地下矿山）考试练习题及答案根据金属非金属矿山安全检查（地下矿山）考前押题。金属非金属矿山安全检查（地下矿山）国家题库通过安全生产模拟考试一点通上在线模拟考试。
1、【单选题】井下采掘工作面进风流中的空气成分(按体积计算),氧气应不低于( )%、二氧化碳应不高于( )%。（ B ）
A、21,1
B、20,0.5
C、20,1
2、【单选题】井田中阶段的开采顺序不正确的是( )。（ B ）
A、一般是由上而下
B、先中间后两边
C、在某些特殊情况下也可采用由下往上的回采顺序
3、【单选题】从安全生产的角度,( )是指可能造成人员伤害、疾病、财产损失、作业环境破坏或其他损失的根源或状态。（ C ）
A、危险
B、危险度
C、危险源
4、【单选题】吊桶内的岩渣,应低于桶口边缘( )m。（ A ）
A、0.1
B、0.2
C、0.3
5、【单选题】同一起爆网路( )。（ A ）
A、应使用同厂、同批、同型号电雷管
B、可使用非同厂、同批、同型号电雷管
C、应使用同厂、同批、不同型号电雷管
6、【单选题】在下列有害因素中,不属于劳动过程中的有害因素是( )。（ B ）
A、劳动组织不合理
B、照明不良
C、劳动制度不合理
7、【单选题】在电气设备和线路上进行检修工作,尤其是在高压场所工作,必须按照停电、验电、放电、装设临时接地线、( )、装设遮栏的程序,采取安全保护措施后再进行检修等作业。（ C ）
A、送电
B、设置警戒线
C、悬挂警告牌
8、【单选题】处理非抗水硝铵炸药的盲炮,可将填塞物掏出向孔内注水使其失效,但( )。（ A ）
A、应回收雷管
B、不应回收雷管
C、应回收填塞物
9、【单选题】对于地表允许崩落、孤立分散的采空区,最经济的处理方法是( )。（ A ）
A、封闭采空区
B、崩落围岩处理采空区
C、充填处理采空区
10、【单选题】对受伤出血人员进行急救的第一步应该是( )。（ B ）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/df5eba1f4524482a5dbf45b3fceb504d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/879d6958d73d90d460288e6a13079be0/" rel="bookmark">
			go-实现继承
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		持续创作，加速成长！这是我参与「掘金日新计划 · 6 月更文挑战」的第1天，点击查看活动详情
1、go-实现继承 在go语言中，是没有extends的关键字的，但并不意味着不能使用继承功能。我们可以使用结构体嵌套，以组合的方式来实现继承的功能。
## 1、什么是继承？ 继承就是在已经定义好的类的基础上创建一个新的类，新的类可以调用已经定义好的类的方法和功能。比如 我定义好了一个笔类，我们可以创建一个圆珠笔的类，它不仅可以使用笔类的功能，还能增加样式，可替换笔芯等笔类所不具备的功能 ## 2、继承的作用 提高代码的复用性，就不用写太多重复代码。 ```go package main
import "fmt" //声明一个人的结构体 type person struct { name string //姓名 age int //年龄 }
//如果一个struct嵌入另一个匿名结构体，就可以直接访问匿名结构体的字段或方法，从而实现继承 type student struct { person //匿名字段 study string //学习科目 grade string }
//如果一个struct嵌套了另一个【有名】的结构体，叫做组合 type teacher struct { p person //有名字段，当重新赋予一个相当于变量一样，就不属于继承了，叫做组合。 mobile string //电话 }
func (p *person) run(){ fmt.Println(p.name, " 会步行") }
func (s *student) reading(){ fmt.Println(s.name, " 我会学习"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/879d6958d73d90d460288e6a13079be0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/948b3951d4e453f9ce7e0e8148f2a9c3/" rel="bookmark">
			Python 按指定视频帧间隔截图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python 按指定视频帧间隔截图 import cv2 import os.path from tqdm import tqdm file_path = r"F:\\Files\\"	# 视频文件路径 path_dir = os.listdir(file_path) # 返回文件夹中的文件名 save_path = r"L:\\0\\"	# 保存图片文件夹路径 name_count = 1 video_path = file_path + "1.avi"	# 视频名称 video = cv2.VideoCapture(video_path) # 读入视频文件 if video.isOpened(): # 判断是否正常打开 rval, frame = video.read() print("开始读取视频") else: rval = False print("读取视频失败") timeF = 1 # 视频帧计数间隔频率 c = 1 if not os.path.exists(save_path): os.makedirs(save_path) print("创建保存截图目录") # 这里按每一帧截图 while rval: # 循环读取视频帧 if c % timeF == 0: # zfill(width) 方法返回指定长度的字符串，原字符串右对齐，前面填充0 # width -- 指定字符串的长度。原字符串右对齐，前面填充0 imageName = str(name_count).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/948b3951d4e453f9ce7e0e8148f2a9c3/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/151/">«</a>
	<span class="pagination__item pagination__item--current">152/321</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/153/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>