<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92f65d0f5ec3bfac500696797b80e94d/" rel="bookmark">
			JAVA实现文件ZIP压缩并解决中文文件名乱码问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、文件压缩的中文乱码问题 1、中文文件名的乱码解决
对于压缩的文件，当文件名称是中文时，若使用JDK API中自带的类（java.util.zip.ZipEntry; java.util.zip.ZipOutputStream;）进行压缩，压缩完成后，可以看到压缩包中的文件名称是乱码(文件的内容无乱码问题)。此时只要用ANT中的ant.jar中的类（org.apache.tools.zip.ZipEntry; org.apache.tools.zip.ZipOutputStream;）就可以解决此问题。
2、ant.jar依赖
&lt;!-- ant.jar 用于解决文件解压缩乱码问题 --&gt; &lt;dependency&gt; &lt;groupId&gt;ant&lt;/groupId&gt; &lt;artifactId&gt;ant&lt;/artifactId&gt; &lt;version&gt;1.6.5&lt;/version&gt; &lt;/dependency&gt; 二、JAVA实现ZIP压缩源代码 import java.io.File; import java.io.FileInputStream; import java.io.FileNotFoundException; import java.io.FileOutputStream; import java.io.IOException; import java.io.OutputStream; import org.apache.tools.zip.ZipEntry; import org.apache.tools.zip.ZipOutputStream; import org.slf4j.Logger; import org.slf4j.LoggerFactory; /** * zip压缩工具包 * @Class ZipUtils */ public class ZipUtils { private final static Logger logger = LoggerFactory.getLogger(ZipUtils.class); private static final int BUFFER_SIZE = 2 * 1024; /** * 压缩成ZIP * @param srcFilePath 压缩文件路径 * @param tarFilePath 目标ZIP输出路径 * @param KeepDirStructure 是否保留原来的目录结构,true:保留目录结构; * false:所有文件跑到压缩包根目录下(注意：不保留目录结构可能会出现同名文件,会压缩失败) * @throws Exception 压缩失败会抛出异常 */ public static boolean toZip(String srcFilePath, String tarFilePath, boolean KeepDirStructure) throws Exception { boolean isCompressSuccess = false; long start = System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/92f65d0f5ec3bfac500696797b80e94d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/759c8112c3623e649589e9cf4130a2db/" rel="bookmark">
			git 无法拉取项目，本地ping不通github的解决办法（详解）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、遇到的问题 本地在从github上拉取项目的时候，一直卡着，然后过个2分钟就报错，连接超时。问题是我前几天还能git pull项目呢，百思不得其解。后来本地浏览器访问github，得，连全世界最大的基佬交友网站都访问不了。本地ping一下IP吧，果然ping不通。
二、解决过程 说解决过程，当然是万能的百度和google。
1、修改hosts
如果大家也碰到和我一样的情况，那么百度最多的解决方案就是修改hosts。博主这边把主流的修改hosts文件的方法都试了一下，对我是没什么用。不过大家可以试试，也许就有用呢。
参考链接： https://yq.aliyun.com/articles/5031
2、ping github.com
这部分就是ping一下github的Ip地址，看看报错信息是什么。关于IP地址，随便在网上搜索“IP地址”,然后输入github.com即可获取到github的IP地址。
我这边报错信息是：无法访问目标主机
3、翻墙试一试
这种情况，博主也以为只是单纯的被墙了，所以翻墙试了试，翻墙之后能正常访问github ,但是本地还是ping不同ip地址。git pull 依旧死气沉沉。这说明不是单纯的网络问题，而很有可能是我自己电脑的问题。博主的电脑是win10系统的。
4、既然无法访问主机，那就从增加主机路由开始
根据pingIP的报错信息，我们百度一下增加主机理由相关的：
参考链接： https://www.cnblogs.com/zhumengmeng/p/3938019.html
这部分先通过 ipconfig 获取到本地默认网关，然后执行 route add 本地默认网关 ping的ip地址 -p修改之后，能正常ping通github的ip，并且浏览器可以正常访问github的网址，git bash可以正常拉取项目。
三、关于CMD命令 route 虽然我们解决了自己的问题，但是windows系统下的这个route概念我还是第一次接触，必须要学习一下下。这里网上关于route的资料已经很多了，博主这边给出几个不错的链接，方便大家学习。
参考链接：
https://blog.csdn.net/bcbobo21cn/article/details/52548923
https://blog.csdn.net/bcbobo21cn/article/details/52548923
四、我的理解 本地通过 route add ... -p 相当于在路由表中添加了一个永久路由。此时我们继续ping github的ip地址，此时不存在
找不到目标主机的问题。而route 命令的本意便是可以同时访问两个ip。我这边因为电脑用的ip是公司的内网，而要访问github的话，就需要把 github的 ip加入到静态路由中，这样就可以正常被dns解析访问。（可能理解有偏差，欢迎指正）
此次解决错误的过程中，感觉自己的方法用的不对。当我发现ping IP的报错信息之后，应该第一时间锁定报错信息的。而不是去试验其他的方法，白白浪费了几十分钟，罪过罪过。
end
============================================================
10月15号更新 我本地又出现了访问不了github，不能从git上面拉取项目的情况，十分气愤。
根据本篇博客，气冲冲的添加路由走一遍，还是不行！
后来分析本地ping github的报错情况，大家可以参考下面的文章：
https://blog.csdn.net/a136106345/article/details/7633065
我本地报错是：time out,代表已经在本地访问到路由表，但是访问github的时候报错：
正在 Ping github.com [192.30.253.113] 具有 32 字节的数据: 本机ip ：无法访问目标主机 解决方案： 1、打开本机hosts
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/759c8112c3623e649589e9cf4130a2db/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/489f8278f302a3c3fc4ae2f30b3dc8c1/" rel="bookmark">
			node&#43;微信小程序实现商城案例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		说明：
1、本人也是初次完整使用小程序，如有BUG或者不足的地方请在Issues或者本文下方留言，作者会尽快修改，谢谢！
2、本项目适合初学者或者准备自学小程序的伙伴
小程序功能：
|-- images // 公共图片 |-- lib // 公共文件 |-- pages // 页面 | |-- index // 首页 | |-- list // 商品列表 | |-- details // 商品详情 | |-- user // 个人中心 | |-- order // 我的订单 | |-- coupon // 优惠券 | |-- cart // 购物车 | |-- addressList // 我的地址 | |-- addressAdd // 添加地址 |-- README.md // 说明 页面截图：
1、首页
2、商品详情
3、购物车
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/489f8278f302a3c3fc4ae2f30b3dc8c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/462c09ded5ac3d94e90c5d7fe06d4e34/" rel="bookmark">
			隔离模块介绍-隔离电源模块
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 最近项目中涉及到强电和弱电混合设计，所以相关的“隔离”就显得尤为重要，以下是一些自己收集到的资料，本人能力尚浅，说错的地方敬请见谅。 这里将隔离模块分为隔离电源模块和隔离信号模块部分，分别以隔离电源模块和光耦为目标进行介绍，大部分数据都来自相应的数据手册，侵删！
隔离模块介绍-隔离电源模块 1.介绍 DC-DC隔离电源，定压输入、非稳压输出隔离电源模块效率高、体积小、可靠性高、耐冲击、隔离特性好，温度范围宽。国际标准引脚方式，阻燃封装（UL94-V0），自然冷却，无需外加散热片，无需外加其他元器件可直接使用，并可直接焊接于PCB板上。 适用于由开关电源或其他稳压源供电，对输出电压及纹波要求不高，小电流隔离和DC-DC电压变换的场合，如大功率IGBT驱动、纯数字电路、一般低频模拟电路、RS232、RS485、CAN-bus隔离通讯系统等，电路结构为开环系统。不适用于输入电压波动范围大于10%或对电压精度要求特别高的场合。
2.应用环境  RS232、RS485/422、CAN-bus等隔离通讯接口  大功率IGBT驱动  纯数字电路、模拟前端隔离电路  一般低频模拟电路  医学、手持、便携仪表 z 运算放大器电源  自控装置
3.工作原理 某型号隔离电源原理框图如上图所示，该系列模块采用双极型推挽振荡变换器输出方波，通过隔离变压器耦合的次级线圈，然后通过后级的二极管蒸馏和电容的滤波，输出直流电压。该系统属开环控制系统，输出电压会有一定范围内的变化，均属正常，不影响使用。 上图是广州致远电子有限公司生产的ZY0505IBS-2W，输入输出电压均为5V，输出最大功率为2W。U3的基本工作原理见上图，首先5V输入电压经过DC-AC电路，变换成交流电AC1，接着隔离变压器把AC1变压成交流电AC2，然后AC2经整流二极管变回直流电，最后经三端稳压器稳压器输出5V直流电压。由于输入输出之间完全靠隔离变压器耦合，他们之间没有任何电气接触，如果用万用表测量任意一个输入引脚和输出引脚，他们之间的阻值为无穷大，所以称之为电源隔离模块。
4.使用问题 （1）模块没有启动 在数据手册上都会有相关的说明，下图是广州致远电子有限公司生产的隔离电源模块。 下图为MORNSUN生产的隔离电源模块： （2）在使用0505时发现输入5v后输出有5.8v/5.4v等。换了好几个，电压都不一样。想问一下，如何能将电压稳定在4.9-5.2之间呢？ 0505输出我并了一个100uf电解电容和一个0.1uf滤波电容。 主要原因就是，这种隔离电源要求有个最小负载，还是看数据手册，下图是广州致远电子有限公司生产的隔离电源模块。 下图为MORNSUN生产的隔离电源模块： 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d24fe2691ca35d4d986ac18eca0252a5/" rel="bookmark">
			Java中非线程延时，Robot类。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 java中有一个Robot类该类有一个方法为delay（ms）；
使用此类时必须将该类实例化。
实现代码如下：
import java.awt.Robot; import java.util.Random; public class Fei { public static void main(String[] args) throws Exception{ Random ran=new Random(); Robot r=new Robot(); while(true) { int i=ran.nextInt(99-90)+90; r.delay(1000); System.out.println(i); } } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6994d35f1d6a1a76a307513f915e81bf/" rel="bookmark">
			如何将Excel中以文本形式存储的数字批量快速地转换为数值类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 关注公众号及时获取文章更新 以文本形式存储的数字往往在单元格（Cell）的左上角会有一个绿色的小三角。
这种格式可能会影响我们运用其中的数值进行计算（其实我也不知道具体会影响什么，哈哈！），不过还是转化为数字类型为妙啊。
方法：（缺点：只能一列一列的更改） 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/101d8cffc931df17b0881765b3720336/" rel="bookmark">
			iOS开发知识之：Animations usingSpringWithDamping动画
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Spring Animation 是一种特殊的动画曲线，自从 iOS 7 开始被广泛应用在系统动画中。
上图中演示的系统自带的动画效果，都使用了 Spring Animation
事实上，从 iOS 7 起几乎所有的系统动画都用的是 Spring Animation，包括 App 文件夹打开/关闭效果、键盘弹出效果、UISwitch 控件的开关效果、不同 View Controller 之间的 Push 动画、Modal 出现和消失的动画、Siri 的出现和消失动画，等等。下图为 Spring Animation 和普通的动画的运动曲线的对比：
下图是几种动画效果的对比，可以看到，和系统自带的 ease-out 效果相比，Spring Animation 前期速度增加得更快，在动画时间一定的前提下，给人感觉更加快速、干净。
这就是Spring Animation动画的API
+ (void)animateWithDuration:(NSTimeInterval)duration delay:(NSTimeInterval)delay usingSpringWithDamping:(CGFloat)dampingRatio initialSpringVelocity:(CGFloat)velocity options:(UIViewAnimationOptions)options animations:(void (^)(void))animations completion:(void (^)(BOOL finished))completion 下面解释一下几个主要参数的意思
usingSpringWithDamping的范围为0.0f到1.0f，数值越小「弹簧」的振动效果越明显。
话不多说，直接上图
initialSpringVelocity则表示初始的速度，数值越大一开始移动越快。
Spring Animation 是线性动画或 ease-out 动画的理想替代品。由于 iOS 本身大量使用的就是 Spring Animation，用户已经习惯了这种动画效果，因此使用它能使 App 让人感觉更加自然，用 Apple 的话说就是「instantly familiar」。此外，Spring Animation 不只能对位置使用，它适用于所有可被添加动画效果的属性。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da18b2e9a92df1fac78fc57bcaa059b0/" rel="bookmark">
			网易互联网 Unity 面经
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		面试大概过去了一个多月今天想起来才决定补上面经
我大概是提前2天到的杭州，面试前一天疯狂看C#基础，可是没想到第二天居然没问C#基础有关的
我把三面+HR都写一起吧因为忘了哪个几面问的
简单介绍下自己
balalalal
然后面试官开始看简历说下你游戏的逻辑
这个只要简单清晰说出来主要的架构就行了
你的服务器用的什么协议？
Udp
Udp和Tcp有什么区别？
1.基于连接与无连接；
2.对系统资源的要求（TCP较多，UDP少）；
3.UDP程序结构较简单；
4.流模式与数据报模式 ；
（TCP可靠，UDP不可靠）
我顺便说了下之前因为阿里云组策略忘记换协议类型导致服务器一直无法访问的事
（扯这些是有必要的，你说的只是理论的，你要告诉他，实际上你也做过）
简单说下UDP连接过程？
UDP是一个无连接的协议，仅有建立连接，发送报文，断开连接，没有发送三次握手，确认重传的机制
说说你第二个游戏的逻辑？
balalalala
简单说下Unity AssetBundle 打包解析过程？
太长了不写
安卓和PC读取ab包的差异？
回答的主要是路径和Io流的差异，安卓无法使用IO只能通过WWW读取
简单说下你这个游戏对象池的作用、思路？
当一个对象大量生成销毁的时候就需要用到对象池，我简单说了一下我的思路，就是一个objectpool类下两个Dictionaries第一个键值，名字 预制体，第二个键值名字 list 存对象，getobject()函数先查找对应对象是否在list中存在，如果存在返回引用，不存在先查找是否有预制体，有则返回无则搜索，搜索不到返回null。搜索到生成object，返回引用。
因为销毁和生产对象都需要消耗大量的CPU资源所以，使用对象池可以对内存进行优化
说一下lua的基本类型？
number string table bool userdata thread
我把number说成了int，后来补充了因为lua不用声明类型所以没有注意，其实是问C#一下没转换过来
lua你用的什么框架？
xlua
说说xlua配置和热更新方案？
太长了，我之前有一篇博客有写xlua，我重点强调了腾讯官方的FAQ有误，开启热补丁特性需要2个宏同时添加，不过后来貌似修复了
你对计算机图形学了解多少？
当时一听到这个，头皮发麻，因为那时候还没开始看这个，这部分内容可以参照我下一篇面腾讯的帖子
说说shader结构
balalal
GPU有哪些编程语言？
这特么还是知道的 CG GLSL HLSL
假如我这有一个4x4矩阵，里面有position rotation scale这三个参数，那么矩阵的哪些数字表示position？
？？？当时一脸懵逼
后来去查了才知道，transform是Matrix4x4的矩阵，03 13 23表示position
简单说说Z缓冲？
Z缓冲指在显示存储器中预先存放不同的3D造型数据，这样，当画面中的视角发生变化时，可以即时地将这些变化反映出来，从而避免了由于运算速度缓慢所造成的图形失真
图像识别了解吗？
这特么不是研究生的课程也问？还好我大二搞过一点深度学习，推荐去看下《数字图像处理(MATLAB版)》瓦萨雷斯
简单聊了聊滤波 傅立叶变换 图像压缩 图像噪声处理
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/da18b2e9a92df1fac78fc57bcaa059b0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/184f040d5c296826bccc5a6556c86658/" rel="bookmark">
			JVM之代码优化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		GitHub-理解JVM系列： https://github.com/kevinten10/Effective-Java
一、早期（编译器）优化 1. 前期编译器：javac .java =&gt; .class
2. 后端运行期编译器：JIT 字节码 =&gt; 机器码
3. 静态提前编译器：AOT *.java =&gt; 机器码
1. javac编译器 1.1 解析与填充符号表 词法语法分析： 源代码的字符流 ==&gt; 标记token集合如 int a = b + 2; ⇒ int , a , = , b , + , 2 根据token序列构造抽象语法树此后，编译器基本上不会再操作源代码，而是操作抽象语法树填充符号表： 由一组符号地址和符号信息构成 1.2 注解处理器： 插入到抽象语法树
1.3 语法分析与字节码生成 对结构上正确的源程序进行审查 类型检查逻辑审查解析语法糖： 虚拟机不支持语法糖的语法，需要解析为基础语法，故添加某种语法糖，其实对功能无影响字节码生成： com.sun.tools.javac.jvm.ClassWriter类 2. 语法糖 泛型与类型擦除 编译时，将泛型擦除，.class字节码中无泛型信息
自动拆装箱 编译后还原为对应的基本类型，使用.parseXXX()和.valueOf()进行
遍历循环foreach 转换为迭代器： list.iterator()，需要实现iterator接口 for(Iterator; iterator.hasNext();iterator.next()) 条件编译 当条件为常量时（true/false），在编译期就会删除掉不成立的分支
3. 自定义注解处理器 javac命令的-processor参数添加注解处理器
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/184f040d5c296826bccc5a6556c86658/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/793d290559909dafb6988afd50f034b4/" rel="bookmark">
			java.lang.NoClassDefFoundError: org/apache/tomcat/util/codec/binary/Base64
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 用POI在处理Excel，涉及到图片的处理，使用到了Base64
import org.apache.tomcat.util.codec.binary.Base64; Base64 base64 = new Base64(); byte[] imgByte = base64.decode(picString.substring("data:image/jpeg;base64,".length())); tomcat7.0.23就报错了。换tomcat的tomcat-util.jar也不行。。
java.lang.NoClassDefFoundError: org/apache/tomcat/util/codec/binary/Base64 com.trechina.servelet.excel.doGet(excel.java:56) com.trechina.servelet.excel.doPost(excel.java:117) javax.servlet.http.HttpServlet.service(HttpServlet.java:641) javax.servlet.http.HttpServlet.service(HttpServlet.java:722) 解决方案：
抛弃这个java包，O(∩_∩)O哈哈~
import org.apache.commons.codec.binary.Base64; byte[] imgByte = Base64.decodeBase64(picString.substring("data:image/jpeg;base64,".length()).getBytes()); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0e8704b299849095cb3e7b2144bbf66/" rel="bookmark">
			【编译原理】作业五
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		编译原理 第五次作业 151220129 计科 吴政亿 18805156360@163.com
4.7.1 规范LR项集族 I0: [S' -&gt; ·S , $] [S' -&gt; ·SS+, $], [S' -&gt; ·SS+, a] [S' -&gt; ·SS*, $], [S' -&gt; ·SS*, a] [S' -&gt; ·a , $], [S' -&gt; ·a , a] I1: [S' -&gt; a· , $], [S' -&gt; a· , a] I2: [S' -&gt; S· , $] [S' -&gt; S·S+, $], [S' -&gt; S·S+, a] [S' -&gt; S·S*, $], [S' -&gt; S·S*, a] [S' -&gt; ·SS+, a], [S' -&gt; ·SS+, *], [S' -&gt; ·SS+, +] [S' -&gt; ·SS*, a], [S' -&gt; ·SS*, *], [S' -&gt; ·SS*, +] [S' -&gt; ·a , a], [S' -&gt; ·a , *], [S' -&gt; ·a , +] I3: [S' -&gt; a· , a], [S' -&gt; a· , *], [S' -&gt; a· , +] I4: [S' -&gt; SS·+, $], [S' -&gt; SS·+, a] [S' -&gt; SS·*, $], [S' -&gt; SS·*, a] [S' -&gt; S·S+, a], [S' -&gt; S·S+, *], [S' -&gt; S·S+, +] [S' -&gt; S·S*, a], [S' -&gt; S·S*, *], [S' -&gt; S·S*, +] [S' -&gt; ·SS+, a], [S' -&gt; ·SS+, *], [S' -&gt; ·SS+, +] [S' -&gt; ·SS*, a], [S' -&gt; ·SS*, *], [S' -&gt; ·SS*, +] [S' -&gt; ·a , a], [S' -&gt; ·a , *], [S' -&gt; ·a , +] I5: [S' -&gt; SS+·, $], [S' -&gt; SS+·, a] I6: [S' -&gt; SS*·, $], [S' -&gt; SS*·, a] I7: [S' -&gt; SS·+, a], [S' -&gt; SS·+, *], [S' -&gt; SS·+, +] [S' -&gt; SS·*, a], [S' -&gt; SS·*, *], [S' -&gt; SS·*, +] [S' -&gt; S·S+, a], [S' -&gt; S·S+, *], [S' -&gt; S·S+, +] [S' -&gt; S·S*, a], [S' -&gt; S·S*, *], [S' -&gt; S·S*, +] [S' -&gt; ·SS+, a], [S' -&gt; ·SS+, *], [S' -&gt; ·SS+, +] [S' -&gt; ·SS*, a], [S' -&gt; ·SS*, *], [S' -&gt; ·SS*, +] [S' -&gt; ·a , a], [S' -&gt; ·a , *], [S' -&gt; ·a , +] I8: [S' -&gt; SS+·, a], [S' -&gt; SS+·, *], [S' -&gt; SS+·, +] I9: [S' -&gt; SS*·, a], [S' -&gt; SS*·, *], [S' -&gt; SS*·, +] LALR项集族: I0: [S' -&gt; ·S , $] [S' -&gt; ·SS+, $], [S' -&gt; ·SS+, a] [S' -&gt; ·SS*, $], [S' -&gt; ·SS*, a] [S' -&gt; ·a , $], [S' -&gt; ·a , a] I1: [S' -&gt; S· , $] [S' -&gt; S·S+, $], [S' -&gt; S·S+, a] [S' -&gt; S·S*, $], [S' -&gt; S·S*, a] [S' -&gt; ·SS+, a], [S' -&gt; ·SS+, *], [S' -&gt; ·SS+, +] [S' -&gt; ·SS*, a], [S' -&gt; ·SS*, *], [S' -&gt; ·SS*, +] [S' -&gt; ·a , a], [S' -&gt; ·a , *], [S' -&gt; ·a , +] I2: [S' -&gt; SS·+, a], [S' -&gt; SS·+, *], [S' -&gt; SS·+, +], [S' -&gt; SS·+, $] [S' -&gt; SS·*, a], [S' -&gt; SS·*, *], [S' -&gt; SS·*, *], [S' -&gt; SS·*, $] [S' -&gt; S·S+, a], [S' -&gt; S·S+, *], [S' -&gt; S·S+, +] [S' -&gt; S·S*, a], [S' -&gt; S·S*, *], [S' -&gt; S·S*, +] [S' -&gt; ·SS+, a], [S' -&gt; ·SS+, *], [S' -&gt; ·SS+, +] [S' -&gt; ·SS*, a], [S' -&gt; ·SS*, *], [S' -&gt; ·SS*, +] [S' -&gt; ·a , a], [S' -&gt; ·a , *], [S' -&gt; ·a , +] I3: [S' -&gt; a· , a], [S' -&gt; a· , *], [S' -&gt; a· , +], [S' -&gt; a· , $] I4: [S' -&gt; SS+·, a], [S' -&gt; SS+·, *], [S' -&gt; SS+·, +], [S' -&gt; SS+·, $] I5: [S' -&gt; SS*·, a], [S' -&gt; SS*·, *], [S' -&gt; SS*·, +], [S' -&gt; SS*·, $] 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a0e8704b299849095cb3e7b2144bbf66/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73f95401f20696d82599e47fd912d44b/" rel="bookmark">
			django 中间件设置设置时，出现的问题总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在设置django 中间件时，通常会出现一些问题 我将从如下三个方面进行描述 1. 分析问题 2. 问题原理 3. 解决方案 1. 设置中间件时，中间件显示无法找到 1. 原因是设置的路径不对，或者是相应的环境变量不存在
2. 将路径尽可能的描述完整，且使用倒入模块的方式也不能奏效
3. 从项目名开始写，一直到 中间件的类，
1. 在 MIDDLEWARE 中写 &gt; 项目名.app名.模块名.中间件类名
2. 在 INSTALLED_APPS 中 加入 app名
&gt; app名.模块名.中间件类名
2. 设置完中间件后，发现如下报错 django.core.exceptions.ImproperlyConfigured: WSGI application 'ubskin_web_django.wsgi.application' could not be loaded; Error importing module. 1. 由于中间件无法正常导入，引起访问出现故障 2. 将该中间件删除后，又不出现以上错误，证明是中间件的问题
3. 按照上面的方法设置中间件，即可
3. object（） take no paramaters ，问题 1. 报错如图， 显示中间件的参数有问题
2. 可能是 __init__ 函数不存在
3. 将中间件如代码所示，添加 __init__ 函数
class LoginMiddleware(object): ''' 用户登陆验证统一由中间件处理 ''' def __init__(self, get_response): self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/73f95401f20696d82599e47fd912d44b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/971e29e8fcb69fb3a53405f91ee10489/" rel="bookmark">
			基础部分
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数组怎么转成集合; 采用数组.asList()方法
List list = new ArrayList(); list = Arrays.asList(array); 注意：对于int[]数组不能直接这样做，因为asList()方法的参数必须是对象。应该先把int[]转化为Integer[]。 如果转成Set集合如下：
Set set = new HashSet(Array.asList(array)); 使用list构造set 写一个Singleton; (代码编程类问题) 第一种：
public class Singleton { private Singleton(){} private static Singleton instance = new Singleton(); public static Singleton getInstance() { return instance; } } 第二种：
public class Singleton { private static Singleton instance = null; public static synchronized Singleton getInstance() { if (instance==null) instance＝new Singleton(); return instance; } } } 异常的抛出,throws、throw、try、catch、finally分别有什么意义 一般情况下是用try来执行一段程序，如果出现异常，系统会抛出（throws）一个异常，这时候你可以通过它的类型来捕捉（catch）它，或最后（finally）由缺省处理器来处理。 try：指定一块预防所有“异常”的程序。 catch：紧跟在try程序后面，应包含一个catch子句来指定你想要捕捉的“异常”的类型。 throw：用来明确地抛出一个“异常”。 throws：标明一个成员函数可能抛出的各种“异常”。 Finally：不管发生什么“异常”都被执行一段代码。 Collection和Collections的区别 Collection 是一个集合接口。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java 类库中有很多具体的实现。Collection接口的意义是为各种具体的集合提供了最大化的统一操作方式。 Collections 是一个包装类。它包含有各种有关集合操作的静态多态方法。此类不能实例化，就像一个工具类，服务于Java的Collection框架。 四个访问修饰符的级别是什么？ Collection 是一个集合接口。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java 类库中有很多具体的实现。Collection接口的意义是为各种具体的集合提供了最大化的统一操作方式。 Collections 是一个包装类。它包含有各种有关集合操作的静态多态方法。此类不能实例化，就像一个工具类，服务于Java的Collection框架。 怎样对一个集合内的元素排序 用Java中提供的对集合进行操作的工具类Collections，其中的sort方法。 String和StringBuffer的区别 就是一个变量和常量的关系。 StringBuffer对象的内容可以修改，StringBuffer在进行字符串处理时，不生成新的对象，在内存使用上要优于String类。 而String对象一旦产生后就不可以被修改，重新赋值其实是两个对象。 StringBuffer是线程安全的，在多线程程序中也可以很方便的进行使用，但是程序的执行效率相对来说就要稍微慢一些。 ”==”和equals方法究竟有什么区别？ java中的数据类型，可分为两类： 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/971e29e8fcb69fb3a53405f91ee10489/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/451f12b8ff92eb8d1b458ae33b2c5c77/" rel="bookmark">
			C&#43;&#43;编程socket编程用recv函数接收，返回值为0解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先讲下背景，我需要写一个客户端，用winsock发送请求到服务器，服务器用tomcat写的，通过responseBody返回字符串作为发还给客户端的数据。
错误表现为：
在用Visual Studio2017调试的时候，在Debug模式下，是没有任何问题的，而在Release模式下，则报错。
错误代码如下：
char buffer[25600]; int resultLen = 0; resultLen = recv(sclient, buffer, strLen(buffer), 0); 此时，输出resultLen，得到输出结果为 0。
查阅资料得知，
当recv返回值小于0时，socket报错；
当recv返回值大于0时，成功，返回值为接收到的数据长度；
当recv返回值等于0时，表示此时connect已经关闭，没有接收到数据。
解决：
其实，socket在传输数据时，传递的是字节，我们在接受recv或发送send时，可以用字符串char*接受，但不能用strLen表示接受数据的长度，因为当接受的数据长度与实际长度不匹配时，socket套接字将关闭，recv返回结果自然就是0，因此我们在这里作了修改，直接使用这个缓冲区长度。
代码如下：
const int bufLen = 25600; char buffer[bufLen]; string result = ""; int resultLen = 0; resultLen = recv(sclient, buffer, bufLen, 0); 此时，再次调试，则recv返回值为实际传输数据的长度。异常解决。
补充：参阅网上诸多大神的说法，在Visual Studio中，用Debug调试时，会自动帮你解决或掠过部分问题，而在Release调试时会暴露出来。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0b559a70ae89372de44289bf7afe495/" rel="bookmark">
			pom.xml文件错误：
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		错误：&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-insta.......
解决：选中项目，刷新项目（F5），不行多刷新几次。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d21f6091fa24e249cf1cc7c4e4e6b3fb/" rel="bookmark">
			Vue学习笔记02day_04.生命周期函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src="./lib/vue-2.4.0.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="app"&gt; &lt;input type="button" value="修改msg" @click="msg='No'"&gt; &lt;h3 id="h3"&gt;{{ msg }}&lt;/h3&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue({ el: '#app', data: { msg: 'ok' }, methods: { show() { console.log('执行了show方法') } }, beforeCreate() { // 这是我们遇到的第一个生命周期函数，表示实例完全被创建出来之前，会执行它 // console.log(this.msg) // this.show() // 注意： 在 beforeCreate 生命周期函数执行的时候，data 和 methods 中的 数据都还没有没初始化 }, created() { // 这是遇到的第二个生命周期函数 // console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d21f6091fa24e249cf1cc7c4e4e6b3fb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a625e6dbd0d1e8cec478c9e7c248c53/" rel="bookmark">
			java第五章练习题（继承）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第五章练习题（继承）
1．下列关于继承优点的叙述正确的是哪几项？（选三项）
A．可以创建更为特殊的类型
B．消除重复代码
C．执行效率高
D．便于维护
2．在子类中调用父类中被覆盖的方法时需要使用哪项关键字？
A．this
B．super
C．new
D．以上都不是
3．现有
public class Parentt
public void change (int x){)
)
public class Child extends Parent{
／／覆盖父类change方法
}
下列哪个声明是正确的覆盖了父类的change方法？
A. protected void change (int x){}
B. public void change(int x, int y){}
C. public void change (int x){}
D. public void change (String s){}
4．如果想要一个类不能被任何类继承的话，需要使用哪个关键字来修饰该类？
A. abstract
B. new
C. static
D. final
5．为了使得System.out.println()输出对象引用的时候得到有意义的信
我们应该覆盖Object t{-的哪个方法？
A．equals
B．toString
C．hashCode
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0a625e6dbd0d1e8cec478c9e7c248c53/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a23835875f99555d93a8d5cc2b231357/" rel="bookmark">
			influxdb基础---介绍和配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#概述
InfluxDB是一个用Go语言编写的时间序列数据库，旨在处理高写入和查询负载。它是TICK堆栈的组成部分 。InfluxDB旨在用作涉及大量带时间戳数据的任何用例的后备存储，包括DevOps监控，应用程序指标，物联网传感器数据和实时分析。同时influxdb也是一个开源分布式时序、事件和指标数据库，无需外部依赖。类似的数据库有kdb、Graphite、es等
influxdb git
note：说明了新版本集群只有在云版或者企业版中才能使用（从0.12开始）就是要缴费，价格参考官网
其主要特色功能
基于时间序列，支持与时间有关的相关函数（如最大，最小，求和等）可度量性：你可以实时对大量数据进行计算基于事件：它支持任意的事件数据 InfluxDB的主要特点
专为时间序列数据编写的自定义高性能数据存储。TSM引擎允许高摄取速度和数据压缩完全写在Go。它编译成单个二进制文件，没有外部依赖项。简单，高性能的写入和查询HTTP API。插件支持其他数据提取协议，如Graphite，collectd和OpenTSDB。专为类似SQL的查询语言量身定制，可轻松查询聚合数据。支持min, max, sum, count, mean, median 等一系列函数，方便统计标签允许对系列进行索引以实现快速有效的查询。保留策略有效地自动使过时数据过期。连续查询自动计算聚合数据，以提高频繁查询的效率。无结构（无模式）：可以是任意数量的列可拓展的 集群版本要收费，单机版本免费（0.11是最后一个包含集群服务的开源版本：在influxdb 0.12发布的同时，也宣告了influxdb开源集群服务的结束，在官方文档0.12与0.11的差别中的clustering updates部分 011_vs_012）
内部集成的web控制台模块从1.3开始就被去掉了 web_admin_interface
#安装
安装最新版本 v1.6.2
以centos为例，其他的 参考官网https连接 或者 参考官网http连接
安装
RedHat &amp; CentOS SHA256: fbe635db1402b0427b32b7268d291093fc97ae888b1a68087dbc1dd39e0ddf67 wget https://dl.influxdata.com/influxdb/releases/influxdb-1.6.2.x86_64.rpm sudo yum localinstall influxdb-1.6.2.x86_64.rpm 配置文件默然在/etc/influxdb/influxdb.conf,默认占用端口是8088、8086
# Bind address to use for the RPC service for backup and restore.
# bind-address = “127.0.0.1:8088”
# The bind address used by the HTTP service.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a23835875f99555d93a8d5cc2b231357/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2620960c4e0405887007c3216aacf4b8/" rel="bookmark">
			Java web
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一 .程序架构 1.C/S架构 是一种客户端/服务器的工作模式，由两个部分组成。 特点：使用前在本地安装客户端然后调用服务器得到相应的服务。 2.B/S架构 程序采用浏览器/服务器的工作模式，又称为请求/响应模式。 特点：很大程度上降低了对用户本地设备环境的要求。同时也极大的降低了程序维护的成本，非常方便。 工作原理： 1.客户端接受用户的输入：一个用户在IE中输入用户名和密码。 2.客户端向应用服务器端发送请求：客户端把请求消息发送到应用服务器端，等待服务器端的响应。 3.服务器端程序进行数据处理：应用服务器端通常使用服务器端技术，如JSP等，对请求进行数据处理。 4.发送响应：应用服务器端向客户端发送响应消息，并由用户的浏览器解释执行响应文件，呈现到用户界面。
URL URL是Internet上标准的资源地址。 一个完整的URL由以下几部分组成， http：//www.kgc.cn/news/201609/newslist.jsp?page=6 协议：http是传输数据时使用的协议。 主机：www.kgc.cn可以定位到课工场的主机，如果知道主机的IP地址，这里可以替换成具体的IP地址来进行定位。 资源的位置：news/201609是我们访问的资源的位置或者资源的路径，而newslist.jsp则是我们要访问的资源的名称。 参数：？page=6是我们访问某个资源是所携带的参数。 ？表示该URL中含有参数需要我们进行传递。 page=6表示参数名称为“page”，值为6。 如果需要传递多个参数，使用&amp;符号进行连接，如page=6&amp;size=10. web服务器 是可以向发出请求的浏览器提供文档的程序，常用服务器主要有： 1）IIS：是源自Microsoft公司的一种信息服务器，服务对象是基于Windows系统平台开发的程序应用。 2）Tomcat：是Apache基金会旗下的一款免费，开源的web服务器软件。 技术先进，性能稳定，而且免费，占用的系统资源小，运行速度快。
什么是JSP Java sever page 简称JSP。是一种运行在服务器端的Java页面，最初是由sun公司倡导 Jsp在开发时是采用HTML语言嵌套Java代码的方式实现的。 工作原理 JSP运行在服务器端，当用户通过浏览器请求访问JSP资源时，web服务器会使用JSP引擎对请求的JSP进行编译和执行，然后将生成的页面返回给客户端浏览器进行显示，整个工作原理如图：
JSP执行阶段：翻译阶段，编译阶段，执行阶段 JSP指令与注释 page指令 language属性用于指定JSP使用的语言，JSP中默认是Java import属性用于引用脚本语言中使用到的类。 contenttype用于指定页面生成内容的mime类型，通常为text/html类型。 JSP注释 HTML注释 JSP注释 JSP脚本注释 JSP构建页面内容 1使用out对象输出显示 2表达式与变量 ①表达式通常情况下会用Java变量来代替，也可以是带有返回值的方法。 ②变量：全局变量和局部变量 定义 ①声明局部变量： &lt;%type name=value;%&gt; ②局部变量 &lt;%!type name=value;%&gt; 3转义字符的输出 在特殊字符前加 ’\’ 符号即可 jsp由这些页面元素组成： 1. 静态内容 就是html,css,javascript等内容 2. 指令 以&lt;%@开始 %&gt; 结尾，比如&lt;%@page import=”java.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2620960c4e0405887007c3216aacf4b8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c8640659bd80cc3c63604871eca2b9b/" rel="bookmark">
			php 导出excel大量数据方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由于数据较大,常用的PHPexcel包需要把所有数据拿到后才能生成excel， 在面对生成超大数据量的excel文件时这显然是会造成内存溢出的，所以考虑使用让PHP边写入输出流边让浏览器下载的形式来完成需求。
通过PHP输出流方式导出
php://output是一个可写的输出流，允许程序像操作文件一样将输出写入到输出流中，PHP会把输出流中的内容发送给web服务器并返回给发起请求的浏览器 保存为csv文件
CSV是最通用的一种文件格式，它可以非常容易地被导入各种PC表格及数据库中，而XLS则是EXCEL专用格式了。CSV文件一行即为数据表的一行，生成数据表字段用半角逗号隔开。
/** 导出csv文件,适用于大量数据导出 */ function exportToExcel($fileName = '', $headArr = [], $data = []){ ini_set('memory_limit','1024M'); //设置程序运行的内存 ini_set('max_execution_time',0); //设置程序的执行时间,0为无上限 ob_end_clean(); //清除内存 ob_start(); header("Content-Type: text/csv"); header("Content-Disposition:filename=".$fileName.'.csv'); $fp=fopen('php://output','w'); fwrite($fp, chr(0xEF).chr(0xBB).chr(0xBF)); fputcsv($fp,$headArr); $index = 0; foreach ($data as $item) { if($index==1000){ //每次写入1000条数据清除内存 $index=0; ob_flush();//清除内存 flush(); } $index++; fputcsv($fp,$item); } ob_flush(); flush(); ob_end_clean(); exit(); } 逐步写入输出流然后发送到浏览器让浏览器去逐步下载整个文件，由于是逐步写入的无法获取文件的总体size所以就没办法通过设置header("Content-Length: $size");在下载前告诉浏览器这个文件有多大了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88874eea841819578540147299a076c7/" rel="bookmark">
			rabbitmq开启webui界面管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		默认情况下，安装完成rabbitmq，启动成功，并不会开启webui的http访问服务。通过rabbitmq-plugins list查看rabbitmq插件，发现rabbitmq_management这里并没有被开启。这里介绍如何开启rabbitmq基于http的webui界面管理。
如果需要通过浏览器访问rabbitmq管理界面，需要开启rabbitmq_management插件。操作如下：
rabbitmq-plugins enable rabbitmq_management
再次查看rabbitmq-plugins
重启rabbitmq，通过rabbitmqctl status可以看到http服务开启，端口15672
现在访问http://10.119.9.149:15672，可以访问，但是为了能够像管理员一样查看rabbitmq更多信息，需要先创建一个管理员账号。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d51ac7a5fc47cdc807bfab66347e0ce5/" rel="bookmark">
			使用spring的JavaMailSender发送邮件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		步骤：
一：pom.xml
&lt;!-- java邮件 --&gt;
&lt;dependency&gt;
&lt;groupId&gt;javax.mail&lt;/groupId&gt;
&lt;artifactId&gt;mail&lt;/artifactId&gt;
&lt;version&gt;1.4.7&lt;/version&gt;
&lt;/dependency&gt;
二：mail.properties
mail.host=smtp.hsmdata.com
mail.username=**@hsmdata.com
mail.password=**
三：applicationContext.xml
&lt;!--发送邮件--&gt;
&lt;bean id="mailSender" class="org.springframework.mail.javamail.JavaMailSenderImpl"&gt;
&lt;property name="host" value="${mail.host}"&gt;&lt;/property&gt;
&lt;property name="javaMailProperties"&gt;
&lt;props&gt;
&lt;prop key="mail.smtp.auth"&gt;true&lt;/prop&gt;
&lt;prop key="mail.smtp.timeout"&gt;25000&lt;/prop&gt;
&lt;/props&gt;
&lt;/property&gt;
&lt;property name="username" value="${mail.username}"&gt;&lt;/property&gt;
&lt;property name="password" value="${mail.password}"&gt;&lt;/property&gt;
&lt;/bean&gt;
四： 使用 @Autowired private JavaMailSender mailSender; public void toEmail(SimpleMailMessage mail){ mailSender.send(mail); } String str = String.valueOf(Math.round(Math.random() * 1000000)); SimpleMailMessage mail = new SimpleMailMessage(); mail.setTo(email); mail.setFrom(PropertiesUtil.getProperty(PropertiesConstant.MAIL_USERNAME)); mail.setSubject("价值连城项目验证邮件"); mail.setText("尊敬的用户：您好，感谢您使用价值连城项目，您的验证码为" + str + "。"); 原文链接：https://www.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d51ac7a5fc47cdc807bfab66347e0ce5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1564ced616fb11afd6c46dcdd31d9da/" rel="bookmark">
			Oracle Wrap破解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 分享一次使用Wrap破解工具的使用经验 工具是我搬的，使用经验是自己摸的，主要是讲fyunwrap_full工具。
本文内容以工具均打包到附件：oracle wrapped破解工具 或者 自行百度搜索
DfUnWraper工具fyunwrap_full工具 DfUnWraper工具 可破解10G，11G，12c不需要安装oracle，操作系统无要求 该软件打开即用 fyunwrap_full工具 可破解9i，10G，11G需要安装oracle操作系统必须32位(众多评论中表明win 10以及win 8都不能使用)，亲测win 7可用 使用教程： 输入用户、密码、tnsname -&gt; 连接9i, 10g、11g数据库 -&gt; 选择schema、代码类型 -&gt; 选择代码-&gt;Unwrap 或者 直接将加密过的代码输入到wrap text编辑框中(仅10g、11g)-&gt;Unwrap 用户名密码即连接数据库的用户密码，tnsname填写服务中注册的名字 Oracle 9i 加密的不能直接将代码粘贴破解，必须连接到数据库中破解。 如何区分是否是9i加密的：前段代码中包含(9200000)则是Oracle9i加密的 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a24ebb19f16b042dacdf20edd4e7a489/" rel="bookmark">
			关于ASP.NET WebApi (增删改查)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、首先，我们先来介绍一下什么是WebApi ASP.NET Web API 是一种框架，用于轻松构建可以由多种客户端（包括浏览器和移动设备）访问的 HTTP 服务。ASP.NET Web API 是一种用于在 .NET Framework 上构建 RESTful 应用程序的理想平台。
可以把WebApi看成Asp.Net项目类型中的一种，其他项目类型诸如我们熟知的WebForm项目，Windows窗体项目，控制台应用程序等。
2、先来看一下这个demo的运行效果
如图所示，可以添加一条记录; 输入记录的Id，查询出该记录的其它信息； 修改该Id的记录； 删除该Id的记录。
3、开始建项目 1）新建一个“ASP.NET Web 应用程序”项目，命名为“Product”,点击确定，如图 2）和MVC类型的项目相似，构建程序的过程是先建立数据模型（Model）用于存取数据, 再建立控制器层（Controller）用于处理发来的Http请求，最后构造显示层（View）用于接收用户的输入和用户进行直接交互。 这里我们先在Models文件夹中建立产品Product类： Product.cs，如下：
using System; using System.Collections.Generic; using System.Linq; using System.Web; namespace demoApi.Models { public class Product { public int ID { get; set; } public string Name { get; set; } public string Department { get; set; } public decimal Salary { get; set; } } } 3）创建完一个Product类后，我们要编写一个类对其实现增删改查。 为了方便拓展和调用，我们在Product上构建一个接口“IProductRepository.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a24ebb19f16b042dacdf20edd4e7a489/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9b2b00067bc20c81022d5a4890bcdd9/" rel="bookmark">
			SSM 动态SQL文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MyBatis 的强大特性之一便是它的动态 SQL。如果你有使用 JDBC 或其他类似框架的经验，你就能体会到根据不同条件拼接 SQL 语句有多么痛苦。拼接的时候要确保不能忘了必要的空格，还要注意省掉列名列表最后的逗号。利用动态 SQL 这一特性可以彻底摆脱这种痛苦。 MyBatis的动态SQL语句是基于OGNL表达式的。可以方便的在SQL语句中实现某些逻辑，总体说来MyBatis动态SQL语句主要有以下几类： 1、if语句（简单的条件判断）。 2、choose（when，otherwize），相当于Java语言中的switch，与JSTL中的choose很类似。 3、trim（对包含的内容加上prefix，或者suffix等，前缀，后缀）。 4、where（主要是用来简化SQL语句中where条件判断的，能智能的处理and or，不必担心多余导致语法错误）。 5、set（主要用于更新时）。 6、foreach（在实现MyBatis in语句查询时特别有用）。
OGNL，全称为Object-Graph Navigation Language，它是一个功能强大的表达式语言，用来获取和设置Java对象的属性，它旨在提供一个更高的更抽象的层次来对Java对象图进行导航。 OGNL表达式的基本单位是”导航链”，一般导航链由如下几个部分组成： （1）属性名称（property） （2）方法调用（method invoke） （3）数组元素 所有的OGNL表达式都基于当前对象的上下文来完成求值运算，链的前面部分的结果将作为后面求值的上下文。例如：names[0].length()。
1、mybatis if语句处理 select * from t_blog where 1 = 1 and title = #{title} and content = #{content} and owner = #{owner} 如果你提供了title参数，那么就要满足title=#{title}，同样如果你提供了Content和Owner的时候，它们也需要满足相应的条件，之后就是返回满足这些条件的所有Blog，这是非常有用的一个功能。 以往我们使用其他类型框架或者直接使用JDBC的时候， 如果我们要达到同样的选择效果的时候，我们就需要拼SQL语句，这是极其麻烦的，比起来，上述的动态SQL就要简单多了。 2、choose (when,otherwize) ,相当于java 语言中的 switch ,与 jstl 中的choose 很类似 select * from t_blog where 1 = 1 and title = #{title} and content = #{content} and owner = “owner1” when元素表示当when中的条件满足的时候就输出其中的内容，跟JAVA中的switch效果差不多的是按照条件的顺序，当when中有条件满足的时候，就会跳出choose，即所有的when和otherwise条件中，只有一个会输出，当所有的我很条件都不满足的时候就输出otherwise中的内容。所以上述语句的意思非常简单，当title!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a9b2b00067bc20c81022d5a4890bcdd9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6e99335d192163bf9071961c000cc34/" rel="bookmark">
			k8s 集群部署问题整理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对kubernetes感兴趣的可以加群885763297，一起玩转kubernetes
1、hostname “master” could not be reached 在host中没有加解析
2、curl -sSL http://localhost:10248/healthz curl: (7) Failed connect to localhost:10248; 拒绝连接 在host中没有localhost的解析
3、Error starting daemon: SELinux is not supported with the overlay2 graph driver on this kernel. Either boot into a newer kernel or…abled=false) vim /etc/ssconfig/docker --selinux-enabled=False
4、bridge-nf-call-iptables 固化的问题： #下面的是关于bridge的配置： net.bridge.bridge-nf-call-ip6tables = 0 net.bridge.bridge-nf-call-iptables = 1 #意味着二层的网络在转发包的时候会被iptables的forward规则过滤 net.bridge.bridge-nf-call-arptables = 0
5、The connection to the server localhost:8080 was refused - did you specify the right host or port?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a6e99335d192163bf9071961c000cc34/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b941ec4644d41ddff4af739f87866194/" rel="bookmark">
			VIORB-SLAM编译
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ORB-SLAM2可以说是目前最优秀的基于特征带的视觉SLAM，由于是开源的，很多人在此基础上进行了改进与应用．废话不多说，下面说说关于IMU+ORB的编译流程与运行结果．
论文是这篇论文：Mur-Artal, R., &amp; Tardós, J. D. (2017). Visual-inertial monocular slam with map reuse. IEEE Robotics &amp; Automation Letters, 2(2), 796-803.
但是论文上没有源码地址，不过好在pangjing根据此片论文，写了相应代码：https://github.com/jingpang/LearnVIORB
由于代码是基于ROS写的，因此需要安装ROS．
(1)ROS安装(ubuntu14.04 64位 ros-indigo)
安装：
sudo sh -c 'echo "deb http://packages.ros.org/ros/ubuntu $(lsb_release -sc) main" &gt; /etc/apt/sources.list.d/ros-latest.list' sudo apt-key adv --keyserver hkp://ha.pool.sks-keyservers.net:80 --recv-key 421C365BD9FF1F717815A3895523BAEEB01FA116 sudo apt-get update sudo apt-get install ros-indigo-desktop-full apt-cache search ros-indigo sudo rosdep init ///出错则使用:sudo c_rehash /etc/ssl/certs sudo -E rosdep init rosdep update echo "source /opt/ros/indigo/setup.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b941ec4644d41ddff4af739f87866194/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/495ceb348d6ab4df4c81d51d694f2e07/" rel="bookmark">
			使用gdb查看挂掉程序堆栈信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 使用gdb查看挂掉程序堆栈信息 查看卡死的进程
ps -ef|grep CobotStudio 2. 使用gdb打开进程
sudo gdb ./CobotStudio 3. 使用attach附加
attach 22108(这里22108为进程子PID) 4. 使用bt查看堆栈信息
bt(直接使用bt查看堆栈信息) 进入gdb,使用gdb中常用命令
c:继续p_:打印list：列表attach:附加b+代码段:设置断点i b：查看设置的断点bt：查看程序crash堆栈信息-up:上一个方法（回车查看下一页）down:下一个方法（回车查看下一页） 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c6f0382461d543fe47d4bdf5b393592/" rel="bookmark">
			.git文件过大，github仓库瘦身
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前几天发现github的仓库非常庞大，down下来有近一个G。虽然把大文件删除了，但是.git文件夹还是占用很大空间，查询资料发现是因为有些文件虽然被删除了，但是github还会保留它的历史日志。所以采用下面的方式将大文件彻底删除。
PS:如果不想费事又想clone的时候快一点，只需要在命令行后面加--depth=1，就会只clone最后一次commit的内容。例如
git clone https://github.com/Wuchenwcf/MyCode.git --depth==1 1.识别出最大的三个文件 git verify-pack -v .git/objects/pack/pack-8eaeb...9e.idx | sort -k 3 -n | tail -3
红色部分对应你github仓库目录下的相应位置，笔者的是
执行结果如下:
$git verify-pack -v .git/objects/pack/pack-44647d872a2ee43463eda7c6f620b9cd88a79a9a.idx | sort -k 3 -n | tail -3
296169a146c50dbc100a5d0ee5be87a45cd7cbb3 blob 50296832 49474116 291684796
aae2c1bf6109f2729502349722b4c3402626d755 blob 77762481 77330392 78759794
35047899fd3b0dd637b0da2086e7a70fe27b1ccb blob 100534272 100014418 191670176
2、查询大文件的文件名 git rev-list --objects --all | grep 35047899fd3b0dd637b0da2086e7a70fe27b1ccb
红色部分对应上一步的绿色部分
执行结果如下:
git rev-list --objects --all | grep 35047899fd3b0dd637b0da2086e7a70fe27b1ccb
35047899fd3b0dd637b0da2086e7a70fe27b1ccb C#/道路车流量统计1/Matlab/HeadlightTracking/for_redistribution/MyAppInstaller_web.exe
3、将该文件从历史记录的所有 tree 中移除 git log --pretty=oneline --branches -- C#/道路车流量统计1/Matlab/HeadlightTracking/for_redistribution/MyAppInstaller_web.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1c6f0382461d543fe47d4bdf5b393592/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb004c80b66d79565da1b325b2720585/" rel="bookmark">
			SpringMVC  实现简单的文件上传和下载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用SpringMVC 实现文件的上传和下载 步骤一： 导包（在原有的spring mvc 包 上多加这俩个） 使用maven jar包的依赖(需要其他版本自行下载) &lt;!-- https://mvnrepository.com/artifact/commons-fileupload/commons-fileupload --&gt; &lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/commons-io/commons-io --&gt; &lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.4&lt;/version&gt; &lt;/dependency&gt; 步骤二：写控制器 @Controller public class UploadController { //这里是日志文件 private static final Logger log = Logger.getLogger(UploadController.class); @RequestMapping(value="/uploadTmp", method=RequestMethod.POST) public String Upload(@RequestParam("file")MultipartFile file,HttpServletRequest request) throws IOException { log.debug("上传的文件名："+file.getOriginalFilename()); log.debug("文件类型"+file.getContentType()); log.debug("文件大小："+file.getSize()); request.setAttribute("fileName",file.getOriginalFilename()); // 如果没选择文件 则发生异常 跳转至异常页面 if (file.getSize()&gt;0) { file.transferTo(new File("D:\\UpLoad",file.getOriginalFilename())); return "FileUploadAndDownload"; }else { return "error"; } } } 步骤三：编写配置文件 springmvc-xml &lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eb004c80b66d79565da1b325b2720585/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/857b0592d040f0a69c7113bba2235788/" rel="bookmark">
			rosdep init 显示&#34;Website may be down.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 按以下顺序输入终端
sudo apt-get install ca-cacert
sudo c_rehash /etc/ssl/certs
sudo update-ca-certificates
sudo rosdep init
OK 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69ca9e747389d05e8b3bffc4e8c82f67/" rel="bookmark">
			笔记_网络单位换算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		单位换算公式（注意字符 B、b 的 大小写）
1TB=1024GB
1GB=1024MB
1MB=1024KB
1KB=1024B
1B=8b(1Byte=8bit ,1字节=8位）
512Kb=64KB
1Mb=1024Kb=128KB=0.125MB（大于1Mb/s就可以称为宽带）
2Mb=256KB（一般称作2M带宽(下行），下载速度256K/S，真正的宽带，实际170K/S到200K/S左右)
4Mb=512KB
8Mb=1024KB=1MB 理论下行速度
10Mb=1280KB=1.25MB
转载于:https://blog.51cto.com/wangkj/2172152
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90fd3d710f592d9e14a142fdbbad6137/" rel="bookmark">
			从数据库当中读取Double类型数据,数值过大时会变成科学计数法问题解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这是问题所在..
解决方案
Double dabo = 12345678.88d; DecimalFormat df = new DecimalFormat(); df.setMaximumFractionDigits(2);//这里是小数位 String format = df.format(dabo); String removeStr = ",";//去掉千分符号 String replace = format.replace(removeStr, ""); System.out.println(replace); 输出结果:
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eac39742ed0008811af0d50d78678598/" rel="bookmark">
			mui调用摄像头
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/zhuming3834/article/details/53391872
好久没有写《HBuilder webApp App开发》这个专栏了。这周的这两天暂时比骄没事，就对着官方文档barcode写了这个二维码扫描的Demo。 以前做原生开发的时候，关于二维码扫描、识别图片中的二维码、和二维码生成都写过。具体可以看这些： 《【iOS】AVFoundation架构下的原生二维码和条形码扫描》 《【iOS】CoreImage原生二维码生成（一）》 《【iOS】CoreImage原生二维码生成（二）一个方法生成带logo的二维码》 在做Ｈ5的APP的时候，之前也写过《HBuilder webApp开发(十一)二维码生成》。 原生开发和H5的开发都写过，发现还是H5的开发代码量会少一点，但是这个就看项目是原生开发还是H5开发了。总体感觉做二维码扫描和生成不难，认真看文档，理清思路，修改官方Demo,然后测试就好了。 直接上代码，注释都在代码里面了。
&lt;body &gt; &lt;header class="mui-bar mui-bar-nav white"&gt; &lt;a class="mui-action-back mui-icon mui-icon-left-nav mui-pull-left"&gt;&lt;/a&gt; &lt;h1 class="mui-title"&gt;二维码扫描&lt;/h1&gt; &lt;/header&gt; &lt;div class="mui-content"&gt; &lt;button id="startScan" class="mui-btn mui-btn-success"&gt;开始扫描&lt;/button&gt; &lt;button id="cancelScan" class="mui-btn mui-btn-success"&gt;取消扫描&lt;/button&gt; &lt;button id="setFlash" class="mui-btn mui-btn-success"&gt;开启/关闭闪光灯&lt;/button&gt; &lt;div id= "bcid"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;script&gt; mui.init({ swipeBack:true //启用右滑关闭功能 }); var scan = null; var isOpen = false; // 闪光灯是否开始标志 true:闪光灯已经开启 false:闪光灯关闭 // 条码识别成功事件 function onmarked( type, result ) { var text = '未知: '; switch(type){ case plus.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eac39742ed0008811af0d50d78678598/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d89b920db022bc2103165c12479fe3e/" rel="bookmark">
			安卓加载webView视频页面，退出后还有声音
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		做项目的时候遇到一个问题，就是安卓用webView加载视频的页面，销毁当前页面后，还是能听到视频播放的声音，以此来记录解决问题的方案。
尝试过在onDestroy（）方法中，调用webView.destroy()方法，销毁它，但是没效果。
参考了另外方法解决的，首先说一下产生这样现象的原因是：在加载网页播放音频时，html5的audio/video 标签将获取系统播放音频的焦点（类似将系统音频管理的权限给了标签使用），返回后焦点未被改变，网页任将获取音频的使用权限，导致音视频可能继续在后台播放。
解决方案：在界面被销毁时，让网页的标签失去焦点，失去对音频的使用权限。
直接上代码。
1.获取音频管理器
private AudioManager mAudioManager; private boolean isPause=false; mAudioManager= (AudioManager) getSystemService(Context.AUDIO_SERVICE); 2.在destory（）中让标签失去焦点，让应用自身获取焦点。
@Override protected void onRestart() { super.onRestart(); //重新加载 sportStartWeb.reload(); } @Override protected void onResume() { super.onResume(); isPause=false; } @Override protected void onPause() { super.onPause(); isPause=true; } @Override protected void onDestroy() { super.onDestroy(); sportStartWeb.destroy(); mAudioManager.abandonAudioFocus(audioFocusChangeListener); } private AudioManager.OnAudioFocusChangeListener audioFocusChangeListener = new AudioManager.OnAudioFocusChangeListener() { @Override public void onAudioFocusChange(int focusChange) { if (isPause &amp;&amp; focusChange == AudioManager.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7d89b920db022bc2103165c12479fe3e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8471f00d8680c9365b2c083bfa2e99e3/" rel="bookmark">
			lumen5:在Controller.php中封装http请求
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		*使用依赖包guzzlehttp/guzzle即可 1。首先安装
2。使用这个包
use GuzzleHttp; 3。写方法使用
public function request($method, $url, array $options = []) { $client = new GuzzleHttp\Client(); $res = $client-&gt;request($method, $url, $options); $body = $res-&gt;getBody()-&gt;getContents(); $data = json_decode($body); return $data; } 4。调用的时候
public function getAllUser($token) { /*get*/ $data = $this-&gt;request('GET', 'https://oapi.dingtalk.com/user/get_org_user_count?access_token=' . $token . '&amp;onlyActive=1'); /*post*/ $data = $this-&gt;request('POST', $this-&gt;ADMIN_URL . '/api/v1/signed_user_list', ['json' =&gt; $req]); return $data; } 5.具体的使用举例子
$client = new Client(); try { $response = $client-&gt;request('PUT',$url,[ 'body' =&gt; json_encode(['foo' =&gt; 'bar']) ] ); Log::info('返回'); $statusCode = $response-&gt;getStatusCode(); $rsp = $response-&gt;getBody()-&gt;getContents(); //$arrRes = json_decode($rsp, true); Log::info($statusCode); Log::info($rsp); } catch (\Exception $e) { echo 'error: '; echo $e-&gt;getMessage(); } try catch 获取错误 put 的url 使用如下方式获取 body 数据：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8471f00d8680c9365b2c083bfa2e99e3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63a2af9804826e8d0338f30a6da1a348/" rel="bookmark">
			Mysql解决SELECT list is not in GROUP BY clause and contains nonaggregated column 问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转自：https://blog.csdn.net/u011676300/article/details/79564446
在使用GROUP BY对Mysql的数据表进行查询时如果出现以下错误
select * from user group by age; ERROR 1055 (42000): Expression #1 of SELECT list is not in GROUP BY clause and contains nonaggregated column 'test.user.user_id' which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by 解决办法： 1.查询mysql 相关mode
select @@global.sql_mode; 可以看到模式中包含了ONLY_FULL_GROUP_BY，只要没有这个配置即可。 我的Mysql版本是5.7.21，默认是带了ONLY_FULL_GROUP_BY模式。
ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE, ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION 2.重设模式值
set @@global.sql_mode=`STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE, ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION`; 3.重启Mysql即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b88d24064144fdc02942177b39cd5f7/" rel="bookmark">
			bash -c 注意事项
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		bash -c 注意事项 通常使用shell去运行脚本，两种方法 bash xxx.sh，另外一种就是bash -c “cmd string”
对于bash xxx.sh, 首先bash 会在当前目录去寻找xxx.sh，如果找到，就直接运行，找不到则按照环境变量 PATH的指定路径，按顺序去找，如果找到，则执行，找不到则报错。shell脚本的参数 P A T H 的 指 定 路 径 ， 按 顺 序 去 找 ， 如 果 找 到 ， 则 执 行 ， 找 不 到 则 报 错 。 s h e l l 脚 本 的 参 数 0就是要执行的shell脚本xxx.sh， 1就是后面紧跟xxx.sh的参数， 1 就 是 后 面 紧 跟 x x x . s h 的 参 数 ， 2 $3依次类推
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b88d24064144fdc02942177b39cd5f7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0cc77d811515b49d518464a50288afe/" rel="bookmark">
			java的远程调试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在被调试的java程序启动的时候设置虚拟机运行参数
例如 java -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=65532 -jar xxx.jar
-jar xxx.jar 是要启动的可运行的jar包
如果jar包内的java代码不像tomcat这种属于一直在后台运行的程序则会出现刚启动还没来得及打开调试器程序就结束了
这时候需要设置suspend=y 即让程序启动后等待调试器debugger连接上65532这个监听端口后再继续运行
如果是调试tomcat 则只需要在tomcat启动的时候传入jpda参数即可
例如：
catalina jpda start
因为catalina脚本里判断如果传入上述参数则运行一下语句，如下
if not "%JPDA_OPTS%" == "" goto gotJpdaOpts set JPDA_OPTS=-agentlib:jdwp=transport=%JPDA_TRANSPORT%,address=%JPDA_ADDRESS%,server=y,suspend=%JPDA_SUSPEND% :gotJpdaOpts 具体说明在catalina 脚本注释里，如下
如果tomcat 是注册为windows服务启动的，则catalina.bat脚本不会被执行，所以在脚本设置虚拟机参数也不会生效
这时候需要做如下操作
第一步，在tomcat bin目录找到
我这是是tomcat7 所以是tomcat7w.exe 后面的w表示这是一个带窗口的应用程序
双击打开它
第二步，在Java Options：加入参数 -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=65532
第三步，重启tomcat服务
如果你双击tomcat7w.exe 弹出如下窗口，说明你的tomcat在windows服务中的名字不叫tomcat7w，你需要去windows服务管理器中找到tomcat服务的名称，然后把tomcat7w.exe命名成服务的名字，比如abc.exe,然后是双击abc.exe即可。
=====================================分割线
下面是idea远程调试的配置，首先新建一个debug configuration 选择Remote类型
然后填写下面的配置 注意点为：远程的ip和端口号 本地源代码所在项目
然后点击OK 最终运行图如下，连接成功，可以打断点开始调试啦~~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2cd596cdfc21a5e2710173569c2c7038/" rel="bookmark">
			c&#43;&#43;对c的提升
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录： c和c++中布尔类型的区别 c和c++中三目运算符的区别 引用在c++里的应用 c和c++中布尔类型的区别： c中布尔类型bool其实是int型只不过规定了为0或1；
c++中bool可取的值只有true和false两个关键字。
c++中理论上bool只占用一个字节，有的编译器可以对多个bool变量分别给到同一个字节的不同bit位上。
c和c++中三目运算符的区别： 当三目运算符的可能返回都是变量时，返回的是变量引用。
当三目运算符的可能返回中有常量时，返回的是值
int a = 1； int b = 2； （a	&lt; b？a : b） = 3；//正确，返回a或b的引用，可以作为右值使用。 （a &lt; b？ 1：b） = 3；//错误，可能返回中有常量，返回的是值 ，不能作为右值使用。 引用在c++里的应用： 引用只是在c++里面应用。
引用的语法：
type&amp; name = var；
引用的类型应该与变量类型一样。
当使用常量对const引用进行初始化时，c++编译器会为常量分配空间，并将引用名作为这段空间的别名。别名称为只读变量。
引用int&amp;a == int* const a；
void f（int&amp; a） ｛ a = 5； ｝ void g（int* const a） ｛ *a = 5； ｝ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7543d24d0a0d5f68e250eef90d20e1a7/" rel="bookmark">
			hive启动小问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载来自：https://www.cnblogs.com/tijun/p/7598281.html
（1）环境变量没有配置好出现如下报错：
which: no hbase in (/opt/beh/core/zookeeper/bin:/opt/beh/core/hadoop/bin:/opt/beh/core/hadoop/sbin
:/opt/beh/core/jdk1.8.0_151/bin:/opt/beh/core/jdk1.8.0_151/jre/bin:/opt/beh/core/hbase/bin:/opt/beh/core/hive/bin:/opt/beh/core/sqoop/bin:/usr/lib64/qt-3.3/bin:/usr/local/bin:/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/sbin:/home/hadoop/bin)
解决办法：
配置好环境变量如下：
export BEH_HOME=/opt/beh
#export JAVA_HOME=/opt/beh/core/jdk1.7.0_55
export JAVA_HOME=/opt/beh/core/jdk1.8.0_151
export HBASE_HOME=/opt/beh/core/hbase
export HIVE_HOME=/opt/beh/core/hive
export HADOOP_HOME=/opt/beh/core/hadoop
export HADOOP_COMMON_HOME=/opt/beh/core/hadoop
export HADOOP_MAPRED_HOME=/opt/beh/core/hadoop
export SQOOP_HOME=/opt/beh/core/sqoop
export ZOOKEEPER_HOME=/opt/beh/core/zookeeper
export LD_LIBRARY_PATH=/opt/beh/core/hadoop/lib/native
export PUB_KEY_HOME=~/.ssh/id_rsa
export SPARK_HOME=/opt/beh/core/spark
export ZOO_DATADIR=$BEH_HOME/data/zoo
export ZOO_LOG_DIR=$BEH_HOME/logs/zookeeper
export ANACAONDA_HOME=/opt/beh/core/anaconda3
export SCALA_HOME=/opt/beh/core/scala-2.11.8
export CLASSPATH=.:$JAVA_HOME/lib:$JAVA_HOME/jre/lib:$SQOOP_HOME/lib:$SCALA_HOME/lib:$SPARK_HOME/jars:$CLASSPATH
export PATH=$ZOOKEEPER_HOME/bin:$ANACAONDA_HOME/bin:$HADOOP_HOME/bin:$HADOOP_HOME/sbin:$JAVA_HOME/bin:$JAVA_HOME/jre/bin:$HBASE_HOME
/bin:$HIVE_HOME/bin:$SQOOP_HOME/bin:$SPARK_HOME/sbin:$SPARK_HOME/bin:$SCALA_HOME/bin:$PATH
（2）找不到对应的spark jar包,原因是spark1.6之后jar包存放位置改变
ls: cannot access /opt/beh/core/spark/lib/spark-assembly-*.jar: No such file or directory
解决办法：
修改：hive/bin/hive
为如下
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17cb7606588bc8a3091934b6c2c5ac28/" rel="bookmark">
			jCanvas插件使用手册
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
jCanvas
Introduction
Syntax
Canvas Object
Extending jCanvas
Properties
Methods
Canvas
Clear Canvas(canvas清除)
Rotate Canvas(canvas缩放)
Scale Canvas(canvas缩放)
Translate Canvas(canvas反转)
Pixel Manipulation(像素操作)
Get Canvas Images(获取canvas图像)
Draw Manually(手动绘制)
Detect Pixel Ratio(检测像素比率)
Drawings
Layers
Events
Styles
jCanvas是一个jQuery插件，使HTML5画布易于使用。
jCanvas是一个JavaScript库，用jQuery编写并用于jQuery，它包含HTML5 canvas API，添加了新的特性和功能，其中许多是可定义的。功能包括图层、事件、拖放、动画等等。结果是一个灵活的API包含在一个含糖的jQuery-esque语法中，为HTML5画布带来了强大的功能。
特性：
用于绘制x形状的灵活API适用于桌面和移动设备小(经gzip后只有12kb)免费和开源 jCanvas Introduction &lt;canvas&gt;元素是HTML5的一个新元素。它允许你在被称为画布的空白元素上绘制任意形状、路径、图像和其它图形。
创建画布：
&lt;canvas width="300" height="150"&gt;&lt;/canvas&gt; 当然，画布可以设置为任意宽度和高度。还可以为画布提供id，以供将来c参考。
note：无法通过css准确设置画布的宽度和高度，只能通过canvas元素的width和heights属性设置。
导入jCanvas：
&lt;script src="jcanvas.min.js"&gt;&lt;/script&gt; 绘制：
HTML5提供了一个绘制canvas的原生javascript API。a native JavaScript API，但是我们使用jCanvas，使用jCanvas需要了解jQuery的基本知识。
Syntax 所有的jCanvas方法都是jQuery常规方法，调用jCanvas方法将应用于jQuery集合中所有canvas元素。
基础用法：
大多数jCanvas方法接受属性映射，可以按照任何顺序列出。
// 在画布上绘制一个圆 $('canvas').drawArc({ fillStyle: 'black', x: 100, y: 100, radius: 50 }); 数字值：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/17cb7606588bc8a3091934b6c2c5ac28/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3c7cc001239ca1689477a892b63d9aa/" rel="bookmark">
			洛谷1982-小朋友的数字-noip2013
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		/*
主要考察语文能力，关键把题读懂。 (分数+特征值)的最大值！
读完题就能发现这是个（几乎是裸的）最大子段和问题。对于最大子段和问题，我们有O(N)的算法。 具体的做法是这样的：当前要求第I位及之前的最大子段和，如果第（I-1）位及之前的最大子段和大于0，则显然这一位取了也未尝不可（不会减少），也就是当前这一位和前面一段连接起来。否则的话，就新开一段——把前面的最大子段和改成0以后继续往下扫描。 如果一定要说这是DP也可以。 这样朴素的做能得50分， 在计算特征值与分数的过程中记录一下最大值可以的得到80分 原因在与最后两个点的分数值超过了longlong。 进一步分析可以发现除了第一个小朋友外剩下的小朋友的分数值是不下降的。所以对于一个小朋友他的分数只有两种情况。 1.如果他的前一个小朋友的特征值大于0，那他的分数就为前一个小朋友的分数加上前一个小朋友的特征值。更新当前最大值。 2.如果他的前一个小朋友的特征值小于0，那他的分数就为第二个小朋友的分数。 （特征值小于0，也就是其前面的数字里面没有正的，都是负的，所以才是第二个小朋友的分数。）
当一个小朋友的分数值大于1000000000时我们取模 因为第一个小朋友的分数不会大于1000000000，所以我们就可以在计算过程中判断出来是否有小朋友的分数大于第一个小朋友。 这样就可以拿到满分。
*/
#include&lt;iostream&gt; #include&lt;cstdio&gt; using namespace std; long long maxx,a[1000001],n,m,p,f[1000001]={0},b[1000001],ff[1000001],ans; bool zf; int main() { cin&gt;&gt;n&gt;&gt;p; for (int i=1;i&lt;=n;i++) scanf("%lld",&amp;a[i]); f[1]=a[1];maxx=a[1]; ff[1]=a[1]; for (int i=2;i&lt;=n;i++) { f[i]=max(f[i-1]+a[i],a[i]); ff[i]=max(maxx,f[i]); maxx=ff[i]; } b[1]=ff[1]; b[2]=ff[1]+b[1]; if (b[2]&gt;=b[1]) zf=true; maxx=b[2]; for (int i=3;i&lt;=n;i++) { if (ff[i-1]&gt;0) { b[i]=b[i-1]+ff[i-1]; if (b[i]&gt;b[1]) zf=true; if (b[i]&gt;1000000000) b[i]%=p; } else b[i]=b[2]; } if (!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f3c7cc001239ca1689477a892b63d9aa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be923b3500635941d73239757d64eebf/" rel="bookmark">
			根据Select的value、text值选中option
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、根据value值选中option
$("#id").find("option[value='1']").attr("selected",true);
2、根据text值选中option $("#id").find("option:contains('text')").attr("selected",true);
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ea46ed836db9ba62ec6ac6ca1651e8c/" rel="bookmark">
			常见的HTTP状态码详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		状态码详解 每一个HTTP状态码表示不同的状态，当进行数据传输和获取时，某一环节出现了问题，就会报错，出现相应的状态码 200：正确的请求返回正确的结果，如果不想细分正确的请求结果都可以直接返回200。 201：表示资源被正确的创建。比如说，我们 POST 用户名、密码正确创建了一个用户就可以返回 201。 202：请求是正确的，但是结果正在处理中，这时候客户端可以通过轮询等机制继续请求。 203：请求的代理服务器修改了源服务器返回的 200 中的内容，我们通过代理服务器向服务器 A 请求用户信息，服务器 A 正常响应，但代理服务器命中了缓存并返回了自己的缓存内容，这时候它返回203 告诉我们这部分信息不一定是最新的，我们可以自行判断并处理。 300：请求成功，但结果有多种选择。 301：请求成功，但是资源被永久转移。比如说，我们下载的东西不在这个地址需要去到新的地址。 303：使用 GET 来访问新的地址来获取资源。 304：请求的资源并没有被修改过。 308：使用原有的地址请求方式来通过新地址获取资源。400：请求出现错误，比如请求头不对等。 401：没有提供认证信息。请求的时候没有带上 Token 等。 402：为以后需要所保留的状态码。 403：请求的资源不允许访问。就是说没有权限。 404：请求的内容不存在。 406：请求的资源并不符合要求。 408：客户端请求超时。 413：请求体过大。 415：类型不正确。 416：请求的区间无效。 500：服务器错误。 501：请求还没有被实现。 502：网关错误。 503：服务暂时不可用。服务器正好在更新代码重启。505：请求的 HTTP 版本不支持。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb4c2887c57f9738d8fac2b982735401/" rel="bookmark">
			Linux下Keepalived安装与配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、简介 负载平衡是一种在真实服务器集群中分配IP流量的方法，可提供一个或多个高度可用的虚拟服务。在设计负载均衡拓扑时，重要的是要考虑负载均衡器本身的可用性以及它背后的真实服务器。用C编写的类似于layer3, 4 &amp; 7交换机制软件，具备我们平时说的第3层、第4层和第7层交换机的功能。
Keepalived为负载平衡和高可用性提供了框架。负载平衡框架依赖于众所周知且广泛使用的Linux虚拟服务器（IPVS）内核模块，该模块提供第4层负载平衡。Keepalived实现了一组健康检查器，以根据其健康动态地自适应地维护和管理负载平衡的服务器池。虚拟冗余路由协议（VRRP）实现高可用性。VRRP是路由器故障转移的基础砖块。此外，keepalived实现了一组挂钩到VRRP有限状态机，提供低级别和高速协议交互。每个Keepalived框架可以独立使用或一起使用，以提供弹性基础设施。
在这种情况下，负载平衡器也可以被称为导向器或LVS路由器。
简而言之，Keepalived提供了两个主要功能：
健康检查LVS系统实施VRRPv2堆栈以处理负载均衡器故障转移 Keepalived使用四个Linux内核组件：
LVS框架：使用getsockopt和setsockopt调用来获取和设置套接字上的选项。Netfilter框架：支持NAT和伪装的IPVS代码。Netlink接口：设置和删除网络接口上的VRRP虚拟IP。组播：将VRRP通告发送到保留的VRRP MULTICAST组（224.0.0.18）。 上图是Keepalived的功能体系结构，大致分两层：用户空间（user space）和内核空间（kernel space）。
内核空间：主要包括IPVS（IP虚拟服务器，用于实现网络服务的负载均衡）和NETLINK（提供高级路由及其他相关的网络功能）两个部份。
用户空间：
WatchDog：负载监控checkers和VRRP进程的状况VRRP Stack：负载负载均衡器之间的失败切换FailOver，如果只用一个负载均稀器，则VRRP不是必须的。Checkers：负责真实服务器的健康检查healthchecking，是keepalived最主要的功能。换言之，可以没有VRRP Stack，但健康检查healthchecking是一定要有的。IPVS wrapper：用户发送设定的规则到内核ipvs代码Netlink Reflector：用来设定vrrp的vip地址等。 Keepalived的所有功能是配置keepalived.conf文件来实现的。
二、安装keepalived 2.1 方法一：yum方式
1、yum安装
安装依赖包 [root@localhost ~]# yum install -y curl gcc openssl-devel libnl3-devel net-snmp-devel [root@localhost ~]# yum install -y keepalived 2、初始化及启动
[root@localhost ~]# systemctl start keepalived //启动keepalived [root@localhost ~]# systemctl enable keepalived //加入开机启动keepalived [root@localhost ~]# systemctl restart keepalived //重新启动keepalived [root@localhost ~]# systemctl status keepalived //查看keepalived状态 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bb4c2887c57f9738d8fac2b982735401/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa908365576b1310b3fdabae94435217/" rel="bookmark">
			adb 无线调试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		做android开发的同学们，在调试app的时候，数据线会经常松动，导致调试失败，现在给大家分享一个用adb无线调试的方法。
1、首先电脑和手机需要连在同一个局域网中，这个是前提。
2、用数据先连接电脑，保证ide工具可以识别到。
3、在命令行窗口输入adb tcpip 9999(后面端口号可以随意指定)
4、查看手机的ip地址，在命令行中使用adb connect ip:9999
5、出现connect to ip字样说明就已经通过wifi连接成功，然后就可以愉快的玩耍了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b3af70aab07fab0a348f2cbc1234e89/" rel="bookmark">
			pip下载安装了第三方模块，Pycharm里面无法导入
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述： 使用pip下载的第三方模块，在Pycharm里面无法导入。 这个问题，一般新安装Python环境的电脑会遇到。
这里，我以安装第三方模块 chardet（检测编码）为例，来做说明。
我们先通过pip安装一下chardet。
运行-》cmd，在黑屏终端输入：pip install chardet 即可。
安装完成后，然后在Pycharm里面导入，但是，出现了点小问题：
显示导入错误。
我们，先看下当前工程下已经安装的第三方模块。
File（文件）--》Settings（设置）--》Project：你的项目名字 --》Project Interpreter
这里可以看到你项目里面已经有的第三方模块。
找了下，发现并没有我们刚才所安装的chardet模块。
在黑屏终端，尝试导入chardet模块。
导入成功，没有报错。
所以，可以推断出，造成这个问题的原因是由于Pycharm没有识别显示。 尝试，重启一下Pycharm，然而，问题并没有解决。
解决方案： 要重新导入一下，当前工程里的Python路径即可。 在这个页面，点击设置的小按钮，选择Add。
选择System Interpreter，然后选择...，最后选择你的Python安装路径，一路OK即可。
完成后，我们看下效果。
已经可以正常导入了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5caa4ff8e968273e3ba8c4d1f1cb9c88/" rel="bookmark">
			Servlet程序的入口点是？（ ）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Servlet程序的入口点是？（ ）
A.init（）
B、main（）
C、service（）
D、doGet（）
解答：C
转载于:https://www.cnblogs.com/borter/p/9592768.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a338dd21ac1086012158d6acdad88a31/" rel="bookmark">
			vue2-countdown时间定时器商城秒杀
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用文档：https://github.com/cgygd/vue2-countdown#vue2-countdown
&lt;!doctype html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;vue2-countdown&lt;/title&gt; &lt;link rel="stylesheet" href="//cdn.bootcss.com/bootstrap/3.3.0/css/bootstrap.min.css"&gt; &lt;script type="text/javascript" src="//cdn.bootcss.com/vue/2.1.4/vue.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="demo"&gt; &lt;div class="container"&gt; &lt;div class="row"&gt; &lt;div class="col-md-12"&gt; &lt;h3&gt;vue2-countdown example&lt;/h3&gt; &lt;p&gt; 使用文档：&lt;a href="https://github.com/cgygd/vue2-countdown#vue2-countdown" target="_blank"&gt;https://github.com/cgygd/vue2-countdown#options&lt;/a&gt; &lt;/p&gt; &lt;div class="panel panel-default"&gt; &lt;div class="panel-heading"&gt; &lt;b&gt;默认配置&lt;/b&gt; &lt;/div&gt; &lt;div class="panel-body text-danger"&gt; &lt;count-down :current-time="1481450106" :start-time="1481450116" :end-time="1481450126" v-on:start_callback="countDownS_cb(1)" v-on:end_callback="countDownE_cb(1)"&gt;&lt;/count-down&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="panel panel-default"&gt; &lt;div class="panel-heading"&gt; &lt;b&gt;自定义文字&lt;/b&gt; &lt;/div&gt; &lt;div class="panel-body text-danger"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a338dd21ac1086012158d6acdad88a31/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e8d4f63034cbc5266456c60328f81f05/" rel="bookmark">
			Linux上的redis启动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.首先启动server服务，找到redis.conf文件并启动，redis.conf文件不一定在当前目录
./redis-server redis.conf
2.再启动client，使用命令 (redis-server和redis-client都是当前目录下的文件)
./redis-client
3.启动服务器上的tomcat
进入tomcat下的bin目录，启动startup.sh,命令如下：
./startup.sh
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13d65ac87c5cfcee58b54f24c47ea5b7/" rel="bookmark">
			安装绿色版本XShell6
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下载地址：http://www.sdbeta.com/xiazai/2018/0108/217982.html 解压后安装，安装后会报错： xshell6 安装 产品所需的信息检索失败 code:40002
直接管理员运行！绿化.bat文件就可以使用了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/892488be86f37d4ded9cbe46cea40a61/" rel="bookmark">
			【RPC-Python】深入RPC分布式原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前面几节讲的都是单机 RPC 服务的模式，无论是多线程也好多进程也好，它们都只能算是单点的设计。现代企业的关键性 RPC 服务是绝不可以只使用单点部署的。本节我们要对 RPC 服务进行分布式化，使得服务可以容忍个别节点故障仍能继续对外提供服务。
客户端 当 RPC 服务部署在多个节点上时，客户端得到的是一个服务列表，有多个 IP 端口对。客户端的连接池可以随机地挑选任意的 RPC 服务节点进行连接。
每个服务节点应该有个权重值，当所有节点的权重值一样时，它们的流量分配就是均匀的。如果某个节点的相对权重值较小，它被客户端选中的概率也会相对比较小。
class RPCNode { String addr; // 服务地址 int weight; // 节点权重 } class RPCCluster { RPCNode[] nodes; // 节点列表 Node random(); // 按权重随机挑选节点 } 容灾Failover 当有一个服务节点挂掉时，客户端需要采取一定的策略避免请求失败。当请求失败时，客户端还要进行重试，但是也不可以无限重试，要有一定的重试策略。 比如当节点挂掉时，将失效节点摘除，放置到失效节点列表中。然后每隔一段时间检查失效节点是否恢复了，如果恢复了，那就从失效节点中移除，再将节点地址重新加入到有效节点列表中。那如何判断节点真的挂掉了呢，一般需要设置一个时间窗口，统计在一定时间窗口里出现的错误数量。如果这个数量过大，那就意味着失效了。这也是为了防止网络偶然抖动导致服务节点流量的大幅波动。
降权法 上面提到客户端会为每个节点赋予一个权值，改变权值就可以改变节点的相对流量。如果某个节点出现了一次调用错误，可以对该节点进行降权。如果错误次数过多，降权会降的很快，最终达到一个最小值。之所以不应该降到零，那是为了给节点提供一个恢复的机会。被降权的节点后来只要有一次调用成功，那么 weight 值就应该尽快被还原，这样节点就可以快速恢复为正常节点。
客户端一次调用失败会尝试重试。如果降权太慢，会导致重试次数太多，因为第二次随机挑选节点时还是很有可能再次挑选到失效节点。降权太快也不好，网络抖动会导致节点流量分配的快速抖动，瞬间从正常降到近零，又可以瞬间从近零恢复到正常。
一个简单的策略是权重减半法。错误一次权重减半，连续错误两次权重就降到 1/4，如此直到降到最小值。如果初始权重值是 1024，那么权重值就会逐渐衰减1024=&gt;512=&gt;256=&gt;128=&gt;64=&gt;32=&gt;16=&gt;8=&gt;4=&gt;2=&gt;1。如果节点恢复了，那么调用会成功，权重就可以直接恢复到正常值，也可以通过加倍法逐渐恢复到正常值1=&gt;2=&gt;4=&gt;8=&gt;16=&gt;32=&gt;64=&gt;128=&gt;256=&gt;512=&gt;1024。如果希望恢复的更快一点，可以通过乘 4 法，乘 8 法。
服务发现 健壮的服务应该是可以支持动态扩容的服务。比如 RPC 服务压力过大，希望通过增加节点的方式来减小单个 RPC 服务的压力。如果使用的是前面的静态 RPC 服务地址列表，那么当节点增加时，我们需要修改客户端的配置重启才能生效。
通过服务发现技术，当 RPC 服务节点增加或减少时，客户端可以动态快速收到服务列表的变更信息，从而可以实时调整连接配置，这样无需重启就可以完成服务的扩容和缩容。
class ServiceDiscovery(object): def register_service(self, name, addr): pass def get_services(self, name): pass def on_services_changed(self, name): pass 服务发现技术依赖于服务之间的特殊中间节点。这个节点的作用就是接受服务的注册，提供服务的查找，以及服务列表变更的实时通知功能。它一般使用支持高可用的分布式配置数据库作为解决方案，如 zookeeper/etcd 等。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/892488be86f37d4ded9cbe46cea40a61/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/251af549e04219f37e1dc1d9f7b7ecc5/" rel="bookmark">
			intellij idea创建maven项目时很慢
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题：
解决：在创建项目的时候添加archetypeCatalog=internal参数
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8cc04e4b22fb3587c119054b655a80f2/" rel="bookmark">
			软考(计算机软件水平考试)程序员介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		备考经验 软考程序员备考
复习资料（弱弱求个 star）
软考有什么用？ 加人文素质分，初级 0.5 中级 1 分好像？加综合评测分，初级 0.5 中级 1 分增加学习的信心，原来自己也能行！落户，一些大城市对拥有职业资格证书的人才有相应的落户政策 其实说有用也有用，说没用也确实没用，只是一个证书而已，还是看自己吧，但是毕竟多一个证书多一份机会
软考介绍 软考分三个等级，初级、中级和高级，每个等级又细分为多个方向，就我个人了解来说，和我们专业最契合的证分别是，初级"程序员"，中级"软件设计师"以及高级"系统架构师"，所谓契合就是额外学习成本最少，考的内容基本都是我们学过的。
大家考的最多的就是"程序员"，在此我只介绍程序员
关于考试的细枝末节自行百度，我只说些百度不到的或者不好百度的地方
考纲 （1）掌握数制及其转换、数据的机内表示、算术和逻辑运算，以及相关的应用数学基础知识；
（2）理解计算机的组成以及各主要部件的性能指标；
（3）掌握操作系统、程序设计语言的基础知识；
（4）熟练掌握计算机常用办公软件的基本操作方法；
（5）熟练掌握基本数据结构和常用算法；
（6）熟练掌握C程序设计语言，以及C++、Java中任一种程序设计语言；
（7）熟悉数据库、网络和多媒体的基础知识；
（8）掌握软件工程的基础知识，了解软件过程基本知识、软件开发项目管理的常识；
（9）了解常用信息技术标准、安全性，以及有关法律、法规的基本知识；
（10）了解信息化、计算机应用的基础知识；
（11）正确阅读和理解计算机领域的简单英文资料。
目录 看完你就笑了，这不大都学过的吗
题型 分两场，上午是计算机基础，下午是程序设计，都是笔试，满分75，45及格
计算机基础：
75道选择题，一道题一分，是的最后五道题是纯英文
程序设计：
五六题选做一个，题目都是一样，只是一个C++实现，一个Java实现
真题 计算机基础真题
程序设计真题
备考建议 建议入手官方备考资料
以真题为指导，结合教程看，总的思路是分课程做，逐个击破。
对于上午的题，同类型先做几道试试，看看它都是如何考察这部分知识，如果没问题这部分就直接跳过进入下个课程，如果有问题再看教程，一定真题结合教程看！
对于下午的题，规律性太强，可以连续做好几年的某题，比如第一题，连续做几年的第一题就有感觉了
其他 中国计算机技术职业资格网
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a39bef1b78ebf80fefcc4a2a94e74d0b/" rel="bookmark">
			pytorch学习  ：vgg做CIFAR10分类代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		# -*- coding: utf-8 -*- """ Created on Tue Sep 4 08:47:56 2018 @author: www """ import sys sys.path.append('...') import numpy as np import torch from torch import nn from torch.autograd import Variable from torchvision.datasets import CIFAR10 #我们可以定义一个 vgg 的 block，传入三个参数，第一个是模型层数，第二个是输入的通道数，第三个是 #输出的通道数，第一层卷积接受的输入通道就是图片输入的通道数，然后输出最后的输出通道数，后面的卷积 #接受的通道数就是最后的输出通道数 def vgg_block(num_convs, in_channels, out_channels): net = [nn.Conv2d(in_channels, out_channels, kernel_size=3, padding=1), nn.ReLU(True)] for i in range(num_convs-1):#定义后面的许多层 net.append(nn.Conv2d(out_channels, out_channels, kernel_size=3, padding=1)) net.append(nn.ReLU(True)) net.append(nn.MaxPool2d(2, 2))#定义池化层 return nn.Sequential(*net) #将模型打印出来看一下结构 block_demo = vgg_block(3, 64, 128) print(block_demo) #首先定义输入为（1， 64， 300， 300） input_demo = Variable(torch.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a39bef1b78ebf80fefcc4a2a94e74d0b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d91b9354c95a54fdb421872d3add34b/" rel="bookmark">
			Redis单机版安装与配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1，采用tar命令，解压redis到指定目录。
具体命令为
tar -xzvf redis-3.2.5.tar.gz -C ./ -C 指定解压到目录
2.进入redis目录，将redis安装到指定目录。使用make PREFIX=/usr/local/redis install 命令
说明，如果执行命令是，出现报错，可以按如下步骤检查
a)检查gcc版本，gcc -v,没有，则使用yum install gcc安装.
b)使用内存分配参数 malloc=libc.
具体命令如下：
make PREFIX=/usr/local/redis MALLOC=libc install 3，将redis目录下的redis.conf 复制到usr/local/redis
具体命令如下
cp redis.conf /usr/local/redis 4，进入usr/local/redis下，编辑redis.conf文件，添加一些必要的配置信息。
由于只是单机版，故目前只需要两个
a) 以守护进程的方式运行： daemonize yes
b)redis的用户名和密码：requirepass 密码
完成后，保存退出编辑。
5，启动redis服务
相关命令如下
./bin/redis-server ./redis.conf 注意，此时路径还是在/usr/local/redis下
6，说明
由于redis默认使用6379的端口，故需要保证防火墙放通6379端口。如需更改，可在redis.conf中添加 port 端口号redis默认绑定127.0.0.1的地址，如需更改，在redis.conf中添加 bind ipredis的一些常规工具，在redis目录下src下，可以使用如下命令进入命令行模式的客户端 ./redis-cli -c -h 127.0.0.1 -p 6379 -a 密码 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c9d53e642b78e160be5980506eb0319/" rel="bookmark">
			字符串的最大子串问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于字符串的最大子串问题是经常面试的问题，想要表现的好不但要会基础的方法，同时还要学会优化的算法。
常考的有两个问题：
1：两个字符串的最大公共子串（还可能是子序列）
2：同一个字符串中相同的最大子串问题
例如输入qweabcuwabcfw,输出结果为：重复字符串的长度3和位置4
一：求两个字符串的最大公共子串 #include&lt;iostream&gt;
#include&lt;string.h&gt;
#include&lt;vector&gt;
using namespace std;
char out[50];
vector&lt;string&gt; re;
int longestSubstring1(string x, string y,int &amp;start) {
int xlen = x.size();
int ylen = y.size();
if (xlen == 0 || ylen == 0) {
return 0; }
int max = -1;
//暴力破解法，两重for循环加 while
for (int i = 0; i &lt; xlen; i++) {
for (int j = 0; j &lt; ylen; j++) {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9c9d53e642b78e160be5980506eb0319/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49d4d8642324d11852a4026909375dca/" rel="bookmark">
			Oracle-常用调优方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		oracle 常用调优方法 Oracle数据库应用系统的调优主要包括十个方面：
(1)、优化数据库内存；
(2)、在Oracle共享池中固定应用程序代码；
(3)、优化数据存储；
(4)、优化数据排序的技术；
(5)、优化SQL语句；
(6)、优化回退段；
(7)、优化索引；
(8)、优化磁盘I/O；
(9)、定期生成数据库对象的状态统计信息；
(10)、优化操作系统环境。
其实质就是降低CPU负载、改善I/O性能。
1、化磁盘I/O
数据库的作用就是实现对数据的管理和查询，所以必然存在对数据的大量读写操作，其I/O问题也往往是导致Oracle数据库性能问题的重要原因。
1.1、Oracle中I/O的产生
1.2、优化OS存储
一、在UNIT环境下，采用裸设备（Raw Device）作为Oracle数据文件的存储设备比采文件系统（File System）存储Oracle数据文件具有较高的读写效率。
二、采用异步IO（Asynchronous IO）方式。在异步IO模式下，进程发出IO请求后无需等待IO完成，可以去处理其它事情；IO请求被放入一个队列中，一旦IO完成，系统会发出信号通知进程。异步IO可以使需要大量写的Oracle进程（如DBWn进程）将IO请求队列化，以充分利用硬件的IO带宽，从而使它们能最大程度实现并行处理。确认操作系统已经设置支持AIO后，还需要设置Oracle初始化参数“DISK_ASYNCH_IO”为“true”以支持异步IO。
三、磁盘负载均衡及条带化（Striping）。条带化技术就是将数据分成很多小部分并把他们分别存储到不同磁盘上的不同区域中去。这就能使多个进程同时访问数据的多个不同部分而不会造成磁盘冲突。很多操作系统、磁盘设备供应商、各种第三方软件都能做到条带化。通过条带化，DBA可以很轻松的做到IO负载均衡而无需去手工配置。
1.3、优化IO配置
一、利用LVM（Logical Volume Manager逻辑卷管理器）软件合理的配置条带的宽度和深度。
二、采用分离文件策略，避免磁盘热点。尽管我们在硬件和操作系统层面通过磁盘条带化实现了磁盘负载均衡，但我们依然不能避免某些数据文件成为“热点文件”。
分离表、索引和临时表空间的存储，即为应用系统建立单独的数据表空间、索引表空间、临时表空间。
分离重做日志(Redo Log)文件。如果Redo Log文件的IO吞吐率高，则应将Redo Log存储在单独磁盘上，在有充裕磁盘的的情况下，应将Redo Log文件条带化分布到多个磁盘上去；
分离归档日志文件(Archive Log)。当ORACLE数据库运行在归档模式下时，归档进程(ARCn )必然会产生大量的磁盘读写。所以应将归档日志文件条带化分布到多个磁盘上单独存储。
1.4、优化ORACLE I/O相关的参数设置
db_file_multiblock_read_count：用于控制一个完全连续扫描中一次 I/O 操作所读取的数据块的最大值。默认值8
db_writer_processes：数据库“写进程”的初始数量。
disk_asynch_io：用于控制数据文件、 控制文件和日志文件的 I/O 是否异步 。只有在平台支持磁盘异步 I/O的情况下才能更改该参数。
log_archive_max_processes：指定归档模式下ARCH 进程的数量。
2.优化数据存储
2.1、表空间优化
SYSTEM表空间用于存放ORACLE系统的有关信息，一般的用户建立的对象（object）不应放在SYSTEM表空间中，另外还需要注意增加SYSTEM表空间合适的大小，保证有100M左右的空闲空间。
对于ORACLE的数据库应用系统，都应该为应用系统建立独立的ORACLE用户(scheme)、数据表空间、索引表空间、临时表空间。应将表空间及数据文件一次性设置成合适的大小，避免数据文件自动增长，造成数据段块/段的不连续，影响系统性能。
定期检查数据库表空间的使用情况，防止表空间碎块过多，影响系统性能。通过查询视图dba_extents可获取表空间详细的使用情况。
整理表空间碎片，回收数据表段的可用空间。
合并表空间碎片
alter tablespace tablespacename coalesce;
回收数据表段的空闲空间
alter table tablename deallocate unused;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/49d4d8642324d11852a4026909375dca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f3d1194c3f34e7b892e0cc8e792d183/" rel="bookmark">
			Oracle-体系结构图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据库（Database）
数据库是一个数据的集合，不仅是指物理上的数据，也指物理、存储及进程对象的一个组合。Oracle是一个基于B/S模式的关系型数据库管理系统（RDBMS）。
Oracle系统体系结构由三部分组成：逻辑结构、物理结构和实例。
一、Oracle的逻辑结构 Oracle的逻辑结构是一种层次结构。主要由：表空间、段、区和数据块等概念组成。逻辑结构是面向用户的，用户使用Oracle开发应用程序使用的就是逻辑结构。数据库存储层次结构及其构成关系,结构对象也从数据块到表空间形成了不同层次的粒度关系。
1.数据块（Data Blocks）
数据块是Oracle最小的存储单位，Oracle数据存放在“块”中。一个块占用一定的磁盘空间。特别注意的是，这里的“块”是Oracle的“数据块”，不是操作系统的“块”。
Oracle每次请求数据的时候，都是以块为单位。也就是说，Oracle每次请求的数据是块的整数倍。如果Oracle请求的数据量不到一块，Oracle也会读取整个块。所以说，“块”是Oracle读写数据的最小单位或者最基本的单位。
块的标准大小由初始化参数DB_BLOCK_SIZE指定。具有标准大小的块称为标准块(Standard Block)。块的大小和标准块的大小不同的块叫非标准块(Nonstandard Block)。
操作系统每次执行I/O的时候，是以操作系统的块为单位;Oracle每次执行I/O的时候，都是以Oracle的块为单位。
Oracle数据块大小一般是操作系统块的整数倍。
数据块的格式(Data Block Format)
块中存放表的数据和索引的数据，无论存放哪种类型的数据，块的格式都是相同的，块由块头(header/Common and Variable),表目录(Table Directory),行目录(Row Directory),空余空间(Free Space)和行数据(Row Data)五部分组成，如下图
块头(header/Common and Variable)：存放块的基本信息，如：块的物理地址，块所属的段的类型(是数据段还是索引段)。
表目录(Table Directory)：存放表的信息，即：如果一些表的数据被存放在这个块中，那么，这些表的相关信息将被存放在“表目录”中。
行目录(Row Directory)：如果块中有行数据存在，则，这些行的信息将被记录在行目录中。这些信息包括行的地址等。
行数据(Row Data)：是真正存放表数据和索引数据的地方。这部分空间是已被数据行占用的空间。
空余空间(Free Space)：空余空间是一个块中未使用的区域，这片区域用于新行的插入和已经存在的行的更新。
头部信息区(Overhead)：我们把块头(header/Common and Variable),表目录(Table Directory),行目录(Row Directory)这三部分合称为头部信息区(Overhead)。头部信息区不存放数据，它存放的整个块的信息。头部信息区的大小是可变的。一般来说，头部信息区的大小介于84字节(bytes)到107字节(bytes)之间。
数据块中自由空间的使用
当往数据库中插入(INSERT)数据的时候，块中的自由空间会减少;当对块中已经存在的行进行修改(UPDATE)的时候(使记录长度增加)，块中的自由空间也会减少。
DELETE语句和UPDATE语句会使块中的自由空间增加。当使用DELETE语句删除块中的记录或者使用UPDATE语句把列的值更改成一个更小值的时候，Oracle会释放出一部分自由空间。释放出的自由空间并不一定是连续的。通常情况下，Oracle不会对块中不连续的自由空间进行合并。因为合并数据块中不连续的自由空间会影响数据库的性能。只有当用户进行数据插入(INSERT)或者更新(UPDATE)操作，却找不到连续的自由空间的时候，Oracle才会合并数据块中不连续的自由空间。
对于块中的自由空间，Oracle提供两种管理方式：自动管理，手动管理
行链接和行迁移(Row Chaining and Migrating)
行链接(Row Chaining)：如果我们往数据库中插入(INSERT)一行数据，这行数据很大，以至于一个数据块存不下一整行，Oracle就会把一行数据分作几段存在几个数据块中，这个过程叫行链接(Row Chaining)。如下图所示：
如果一行数据是普通行，这行数据能够存放在一个数据块中;如果一行数据是链接行，这行数据存放在多个数据块中。
行迁移(Row Migrating)：数据块中存在一条记录，用户执行UPDATE更新这条记录，这个UPDATE操作使这条记录变长，这时候，Oracle在这个数据块中进行查找，但是找不到能够容纳下这条记录的空间，无奈之下，Oracle只能把整行数据移到一个新的数据块。原来的数据块中保留一个“指针”，这个“指针”指向新的数据块。被移动的这条记录的ROWID保持不变。行迁移的原理如下图所示：
无论是行链接还是行迁移，都会影响数据库的性能。Oracle在读取这样的记录的时候，Oracle会扫描多个数据块，执行更多的I/O。
块中自由空间的自动管理
Oracle使用位图(bitmap)来管理和跟踪数据块，这种块的空间管理方式叫“自动管理”。自动管理有下面的好处：
◆易于使用
◆更好地利用空间
◆可以对空间进行实时调整
块中自由空间的手动管理
用户可以通过PCTFREE, PCTUSED来调整块中空间的使用，这种管理方式叫手动管理。相对于自动管理，手动管理方式比较麻烦，不容易掌握，容易造成块中空间的浪费。
PCTUSED也是用于设置一个百分比，当块中已使用的空间的比例小于这个百分比的时候，这个块才被标识为有效状态。只有有效的块才被允许插入数据。
PCTFREE参数用于指定块中必须保留的最小空闲空间百分例，默认值为10。之所以要预留这样的空间，是因为UPDATE时，需要这些空间。如果UPDATE时，没有空余空间，Oracle就会分配一个新的块，这会产生行迁移(Row Migrating)。
例如，假定在Create table语句中指定了pctfree为20，则说明在该表的数据段内每个数据块的20%被作为可利用的空闲空间，用于更新已在数据块内存在的数据行其余80%是用于插入新的数据行，直到达到80%为止。显然，pctfree值越小，则为现存行更新所预留的空间越少。因此，如果pctfree设置得太高，则在全表扫描期间增加I/O，浪费磁盘空间；如果pctfree设置得太低，则会导致行迁移。 pctused参数设置了数据块是否是空闲的界限。当数据块的使用空间低于pctused的值时，此数据块标志为空闲，该空闲空间仅用于插入新的行。如果数据块已经达到了由pctfree所确定的上边界时，Oracle就认为此数据块已经无法再插入新的行。例如，假定在Create table语句中指定pctused为40，则当小于或等于39时，该数据块才是可用的。所以，可将数据块填得更满，这样可节省空间，但却增加了处理开销，因为数据块的空闲空间总是要被更新的行占据，所以对数据块需要频繁地进行重新组织。比较低的pctused增加了数据库的空闲空间，但减少了更新操作的处理开销。所以，如果pctused设置过高，则会降低磁盘的利用率导致行迁移；若pctused设置过低，则浪费磁盘空间，增加全表扫描时的I/O输出。pctused是与pctfree相对的参数。 那么，如何选择pctfree和pctused的值呢？有个公式可供参考。显然，pctfree和pctused的之和不能超过100。若两者之和低于100，则空间的利用与系统的I/O之间的最佳平衡点是：pctfree与pctused之和等于100%减去一行的大小占块空间大小的百分比。例如，如果块大小为2048字节，则它需要100个字节的开销，而行大小是390字节（为可用块的20%）。为了充分利用空间，pctfree与pctused之和最好为80%。 那么，怎样确定数据块大小呢？有两个因素需要考虑： 一是数据库环境类型。例如，是DSS环境还是OLTP环境？在数据仓库环境（OLAP或DSS）下，用户需要进行许多运行时间很长的查询，所以应当使用大的数据块。在OLTP系统中，用户处理大量的小型事务，采用较小数据块能够获得更好的效果。 二是SGA的大小。数据库缓冲区的大小由数据块大小和初始化文件的db_block_buffers参数决定。最好设为操作系统I/O的整数倍。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2f3d1194c3f34e7b892e0cc8e792d183/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d85e1ba68da7668d4defdafbb930ea34/" rel="bookmark">
			二分查找经典题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有序数组的二分查找： 非递归形式
int BinSeach(int a[], int n, int values)
{
int index = -1;
int start = 0;
int finish = n - 1;
int middle;
while (start &lt;= finish)
{
middle = (start + finish) / 2;
if (a[middle] &lt; values)
start = middle + 1;
else if (a[middle] == values)
{
index = middle; break;
}
else
finish = middle - 1;
}
return index;
}
递归形式
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d85e1ba68da7668d4defdafbb930ea34/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ed702b20f11e336c081e31c47f2bfb5/" rel="bookmark">
			http登录模块加密登录安全登录方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		http请求很容易被截获，在写登录模块时，直接使用明文密码请求，很容易明文密码泄露；若在js页面对密码进行一次加密后在传输，虽不是明文密码，但也完全可以截获加密后的暗文，伪造http请求进行登录。为了防止密码泄露，通过参考各种方案，找到了以下比较好实现的方法：
1、登录请求分两次进行，第一次仅传用户名
2、服务器收到用户名后，生成一串随机数，将随机数响应给客户端，并将用户名和随机数存到session
3、客户端收到响应后，将密码和随机数安一定的规则组合起来，再md5加密，再http请求（此时保证了每一次登录请求的密码会随随机数的不同而不同，这个随机数为服务器生成，相当于一个公钥，与本次登录操作唯一且一一对应，客户端无法伪造）
4、服务器收到请求，取出session中的用户名和随机数串，核对用户名，再取数据库中的正确密码，再按相同的规则与随机数组合并md5加密，再比较请求的密码暗文，返回登录结果。
附一张更清晰的图，可以看到就算在传输过程的所有信息都暴露出来，也无法根据这些伪造出http请求登录成功。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83cbb549ca6171e79581e8c2b6675bea/" rel="bookmark">
			内存中堆和栈的区别【面试知识点】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		（1）什么是堆：堆是大家共有的空间，分全局堆和局部堆。全局堆就是所有没有分配的空间，局部堆就是用户分配的空间。
堆在操作系统对进程初始化的时候分配，运行过程中也可以向系统要额外的堆，但是记得用完了要还给操作系统，要不然就是内存泄漏。 （2）什么是栈：栈是线程独有的，保存其运行状态和局部自动变量的。栈在线程开始的时候初始化，每个线程的栈互相独立。每个函数都有自己的栈，栈被用来在函数之间传递参数。操作系统在切换线程的时候会自动的切换栈，就是切换SS/ESP寄存器。栈空间不需要在高级语言里面显式的分配和释放。 栈是由编译器自动分配释放，存放函数的参数值、局部变量的值等。操作方式类似于数据结构中的栈。
堆一般由程序员分配释放，若不释放，程序结束时可能由OS回收。注意这里说是可能，并非一定。所以我想再强调一次，记得要释放！ 举个例子，如果你在函数上面定义了一个指针变量，然后在这个函数里申请了一块内存让指针指向它。实际上，这个指针的地址是在栈上，但是它所指向的内容却是在堆上面的！这一点要注意！所以，再想想，在一个函数里申请了空间后，比如说下面这个函数：
void Function(void) { char *p = (char *)malloc(100 * sizeof(char)); } 就这个例子，千万不要认为函数返回，函数所在的栈被销毁指针也跟着销毁，申请的内存也就一样跟着销毁了！这绝对是错误的！因为申请的内存在堆上，而函数所在的栈被销毁跟堆完全没有啥关系。所以，还是那句话：记得释放！ 释放：
free(p); p=NULL; 注意它与数据结构中的堆是两回事，分配方式倒是类似于链表。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba901fccecf5e1b683ab077bce73bdb9/" rel="bookmark">
			sklearn——CountVectorizer详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CountVectorize CountVectorizer是属于常见的特征数值计算类，是一个文本特征提取方法。对于每一个训练文本，它只考虑每种词汇在该训练文本中出现的频率。
CountVectorizer会将文本中的词语转换为词频矩阵，它通过fit_transform函数计算各个词语出现的次数。
CountVectorizer参数详解 CountVectorizer(input='content', encoding='utf-8', decode_error='strict', strip_accents=None, lowercase=True, preprocessor=None, tokenizer=None, stop_words=None, token_pattern='(?u)\b\w\w+\b', ngram_range=(1, 1), analyzer='word', max_df=1.0, min_df=1, max_features=None, vocabulary=None, binary=False, dtype=&lt;class 'numpy.int64'&gt;) CountVectorizer类的参数很多，分为三个处理步骤：preprocessing、tokenizing、n-grams generation.
一般要设置的参数是:ngram_range,max_df，min_df，max_features等，具体情况具体分析
参数表作用input一般使用默认即可，可以设置为"filename’或’file’encodeing使用默认的utf-8即可，分析器将会以utf-8解码raw documentdecode_error默认为strict，遇到不能解码的字符将报UnicodeDecodeError错误，设为ignore将会忽略解码错误，还可以设为replace，作用尚不明确strip_accents默认为None，可设为ascii或unicode，将使用ascii或unicode编码在预处理步骤去除raw document中的重音符号analyzer一般使用默认，可设置为string类型，如’word’, ‘char’, ‘char_wb’，还可设置为callable类型，比如函数是一个callable类型preprocessor设为None或callable类型tokenizer设为None或callable类型ngram_range词组切分的长度范围，待详解stop_words设置停用词，设为english将使用内置的英语停用词，设为一个list可自定义停用词，设为None不使用停用词，设为None且max_df∈[0.7, 1.0)将自动根据当前的语料库建立停用词表lowercase将所有字符变成小写token_pattern过滤规则，表示token的正则表达式，需要设置analyzer == ‘word’，默认的正则表达式选择2个及以上的字母或数字作为token，标点符号默认当作token分隔符，而不会被当作tokenmax_df可以设置为范围在[0.0 1.0]的float，也可以设置为没有范围限制的int，默认为1.0。这个参数的作用是作为一个阈值，当构造语料库的关键词集的时候，如果某个词的document frequence大于max_df，这个词不会被当作关键词。如果这个参数是float，则表示词出现的次数与语料库文档数的百分比，如果是int，则表示词出现的次数。如果参数中已经给定了vocabulary，则这个参数无效min_df类似于max_df，不同之处在于如果某个词的document frequence小于min_df，则这个词不会被当作关键词max_features默认为None，可设为int，对所有关键词的term frequency进行降序排序，只取前max_features个作为关键词集vocabulary默认为None，自动从输入文档中构建关键词集，也可以是一个字典或可迭代对象？binary默认为False，一个关键词在一篇文档中可能出现n次，如果binary=True，非零的n将全部置为1，这对需要布尔值输入的离散概率模型的有用的dtype使用CountVectorizer类的fit_transform()或transform()将得到一个文档词频矩阵，dtype可以设置这个矩阵的数值类型 属性表作用vocabulary_词汇表；字典型get_feature_names()所有文本的词汇；列表型stop_words_返回停用词表 方法表作用fit_transform(X)拟合模型，并返回文本矩阵fit(raw_documents[, y])Learn a vocabulary dictionary of all tokens in the raw documents.fit_transform(raw_documents[, y])Learn the vocabulary dictionary and return term-document matrix. 用数据输入形式为列表，列表元素为代表文章的字符串，一个字符串代表一篇文章，字符串是已经分割好的。CountVectorizer同样适用于中文; CountVectorizer是通过fit_transform函数将文本中的词语转换为词频矩阵，矩阵元素a[i][j] 表示j词在第i个文本下的词频。即各个词语出现的次数，通过get_feature_names()可看到所有文本的关键字，通过toarray()可看到词频矩阵的结果。 入门示例 from sklearn.feature_extraction.text import CountVectorizer texts=["dog cat fish"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ba901fccecf5e1b683ab077bce73bdb9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d5a03473abbf851bca05c9de4cfb6fb/" rel="bookmark">
			python 实现股票MACD计算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先普及基本知识，就是MACD的计算公式： 3个参数（这3个参数可以根据实际情况自己设定，默认为12，26和9）：（12）日快速移动平均线，（26）日慢速移动平均，（9）日移动平均
EMA（12）= 前一日EMA（12）×11/13＋今日收盘价×2/13
EMA（26）= 前一日EMA（26）×25/27＋今日收盘价×2/27
DIFF=今日EMA（12）- 今日EMA（26）
DEA（MACD）= 前一日DEA×8/10＋今日DIF×2/10
BAR=2×(DIFF－DEA)
关键是第一日和第二日的DIFF，DEA和BAR（MACD）是多少：
第一日都为0
DIFF=0，DEA=0，BAR（MACD）=0
第二日
EMA（12）=前一日收盘价（即第一日收盘价）+（今日收盘价 - 前一日收盘价）* 2 / 13
EMA（26）=前一日收盘价（即第一日收盘价）+（今日收盘价 - 前一日收盘价）* 2 / 27
DIFF=EMA（12）-EMA（26）
DEA（9）=0（即前一日DEA（9））+今日DIFF*2/10
BAR=2*(DIFF-DEA)
第三日就可以按最上面的公式计算了，因为前一日（即第二日）的EMA（12），EMA（26），DEA（9）都已经有了，后面以此类推。
由于计算当天的DIFF，DEA和BAR（MACD）需要前一天的EMA数据，所以除非这些数据是已知的，否则需要从第一天收盘后开始计算，这也是MACD比较麻烦的地方。
根据以上的公式给出代码就不困难了：
元数据的获取使用了Tushare第三方金融数据库，可以见之前的blog：python 经济数据第三方库 tushare 简单试用
元数据格式是这样的（以沪深300指数为例）：
函数实现： def calMACD(df, fast_ma, slow_ma, ma): """ :param df: original dataframe, index = 'date', columns ='open','high','close','low','volume','amount' :param fast_ma: fast period :param slow_ma: slow period :param ma: moving average :return: DateFrame """ # sort by date sort_df = df.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2d5a03473abbf851bca05c9de4cfb6fb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd3ae9502e53ddf26f389deba02bf6ef/" rel="bookmark">
			linux tensorflow keras 安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0、非root用户安装python3
直接官方下载源码 wget https://www.python.org/ftp/python/3.6.6/Python-3.6.6.tgz
2.下载python3编译的依赖包
yum install -y gcc patch libffi-devel python-devel zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-devel tar -zxvf Python-3.6.6.tgz
cd Python-3.6.6
然后 ./configure --prefix=/home/cxq/python3/
然后 make
然后 make install 执行完上述步骤只能在python3/bin下面使用python3和pip3. 通过ln -s为python3建立新的链接. 如:
ln -s /home/cxq/python3/bin/python3 ~
给python添加PATH路径 在用户主目录下有一个 .bashrc 隐藏文件，可以在此文件中加入 PATH 的设置如下： $ gedit ~/.bashrc 加入： export PATH=/home/users/cxq/python3/bin:$PATH 保存后在终端输入 $ source ~/.bashrc 使环境变量立即生效
python3.6 -m pip install numpy
python3.6 -m 可以指定Python版本
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fd3ae9502e53ddf26f389deba02bf6ef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8341ab724e45594f9f882e8067de6058/" rel="bookmark">
			计蒜客 Magical Girl Haze ——dijkstra&#43;优先队列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		There are NN cities in the country, and MM directional roads from uu to v(1\le u, v\le n)v(1≤u,v≤n). Every road has a distance c_ic i ​ . Haze is a Magical Girl that lives in City 11, she can choose no more than KK roads and make their distances become 00. Now she wants to go to City NN, please help her calculate the minimum distance.
Input The first line has one integer T(1 \le T\le 5)T(1≤T≤5), then following TT cases.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8341ab724e45594f9f882e8067de6058/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46e79e903219ccb4699133fca67a932b/" rel="bookmark">
			Docker学习（六） Mongodb安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2019独角兽企业重金招聘Python工程师标准&gt;&gt;&gt; 一、用命令安装
1、环境已安装好docker，网络配置好了，启动docker
[root@localhost ~]# systemctl start docker.service
2、创建目录，用于容器映射本地目录
[root@localhost ~]# mkdir -p ~/mongo ~/mongo/db
[root@localhost ~]# cd mongo
3、安装mongodb
[root@localhost mongo]# docker pull mongo
[root@localhost ~]# docker images
REPOSITORY TAG IMAGE ID CREATED SIZE
redis 4.0.11 43da2e0979d8 2 days ago 83.44 MB
mongo latest a41c82c0998a 8 days ago 380.2 MB
4、运行容器，不加权限
[root@localhost mongo]# docker run --name mongodb-server0 -p 27017:27017 -v $PWD/db:/data/db -d mongo:latest
89daef5129332b2d60aa0cc2394e170dc74e1b347af71729289a534e98d55c4f
使用mongo镜像执行mongo 命令连接到刚启动的容器,主机IP为：192.168.22.151，这个一定要，不然外部连接不上
5、[root@localhost mongo]# docker run -it mongo:latest mongo --host 192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/46e79e903219ccb4699133fca67a932b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39116e3c24d89a3f96d41cae0bf75119/" rel="bookmark">
			Socket传输文件/传输图片(Windows)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		利用UDP socket 来传输文件与图片 流程图如下： 主要流程： 1.client端发送command请求，上传数据或者下载数据，选择文件路径； 2.server端应答，start代表开始传输，no代表拒绝； 3.fopen打开文件进行读取（fread）或者写入（fwrite），为了支持图片传输，以二进制方式打开文件；
Server端 //udp_server.h #define BUFLEN 4096 #define SHUTDOWN 0 #define DOWNLOAD 1 #define UPLOAD 2 #define YES 3 #define NO 4 #define START 5 #define END 6 #define CONTENT 7 #define OK 8 struct packet { int command; int buflen; int seq; char buf[BUFLEN]; }; int socketfd; int addr_len; struct sockaddr_in server; struct sockaddr_in client; struct packet send_packet; struct packet recv_packet; int length; char ip[20]; int port; int command; char file_path[256]; // udp_server.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/39116e3c24d89a3f96d41cae0bf75119/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea99739c8dbb7025e731ca866f7f14b3/" rel="bookmark">
			HBase
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		分布式文件系统(GFS)：底层分布式文件系统（GFS）存储的是完全非结构化的。
分布式数据库(Hbase)：HBase 存半结构化的，也就是松散数据。
1.数据模型简单，值只存储为字符串
2.HBase避免了连接操作。
3.基于列存储
4.原始设计只支持行健索引。
5.Hadoop不能满足实时处理需求。
HBase中执行更新操作时，并不会删除数据旧的版本，而是生成一个新的版本，旧有的版本仍然保留（这是和HDFS只允许追加不允许修改的特性相关的）。
纵向扩展： 增加cpu，单核变双核，增加内存，增加磁盘。
水平扩展：允许几千台服务器去存储海量数据。 （可以理解为有效水平切分，就是就有优良的水平可扩展性。）
Pig适合做一些数理统计
数据仓库产品 Hive 有一种HiveQL（类sql）可以去执行复杂的数据分析功能。
Hbase借助底层的HDFS来保证数据冗余备份
而HDFS使用的强一致性来保持的，也就是数据在不同步到N个节点之前，不会返回。
tips: 1.建表。HBase的表中会有一个系统默认的属性作为主键，主键无需自行创建，默认为put命令操作中表名后第一个数据，因此此处无需创建id列。虽然不需要创建即可有id列，但是put时要输入。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f234ae84a477fb792642cb82ae701c3d/" rel="bookmark">
			32位机器上unsigned int的最大值及int的最大值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include &lt;stdio.h&gt; int main() { int max_int = (1&lt;&lt;31) - 1; //第一位是符号位 printf("The max value of int on 32 machine: %d\n", max_int); unsigned int max_uint = 0 - 1; //补码 -1 和 max - 1是一样的表示方式 printf("The max value of unsigned int on 32 machine: %u\n", max_uint); } 会报 [Warning] integer overflow in expression [-Woverflow]
运行结果如图 补码计算法定义：非负数的补码是其原码本身；负数的补码是其绝对值的原码最高位符号位不变，其它位取反，再加1。
补码为什么是用取反+1 （大学老师的缩减式讲法）
我的理解：x的补码就是mod+x = mod - (-x)，所以x是正数的时候，其补码是原码，当x是负数的时候，不看符号位的话，x的反码就是mod - 1 + x ，再加1 就是其补码。详细的请看下面的链接，讲的比较清楚。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f234ae84a477fb792642cb82ae701c3d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5cd960832e33eea4018f5ec208e09e54/" rel="bookmark">
			java.io.IOException: Server returned HTTP response code: 415 for URL:xxxxxx
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		java.io.IOException: Server returned HTTP response code: 415 for URL: http://192.168.1.59:8080/mobileapi/scene/save.do?token=9DB2FD6FDD2F116CD47CE6C48B3047EE at sun.net.www.protocol.http.HttpURLConnection.getInputStream0(HttpURLConnection.java:1876) at sun.net.www.protocol.http.HttpURLConnection.getInputStream(HttpURLConnection.java:1474) 环境描述 Spring MVC 使用 @RequestBody 接收JSON参数转为实体对象
public void save(@RequestBody Scene scene, HttpServletRequest request, HttpServletResponse response) throws Exception { } 客户端添加下面的代码解决问题：
connection.setRequestProperty("Content-Type", "application/json; charset=utf-8"); 引用地址：https://blog.csdn.net/testcs_dn/article/details/71716647
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d6390bd25871535176bc610f39a22e1/" rel="bookmark">
			IO、NIO和AIO的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		IO和NIO的区别：其本质就是阻塞和非阻塞的区别。
阻塞概念：应用程序在获取网络数据的时候，如果网络传输数据很慢，那么久一直等着，知道传输完毕为止。
非阻塞概念：应用程序直接可以获取已经准备就绪好的数据，无需等待。(从操作系统缓冲区中直接读取已经缓冲完毕的数据，不用阻塞等待数据缓冲完毕，可以在这段时间中做其他事)
同步和异步的区别：
同步：应用程序会直接参与IO读写操作哦，并且应用程序会直接阻塞到某个方法上，知道数据准备就绪；或者采用轮询的策略实时检查数据的就绪状态，如果就绪则获取数据。
异步：所有的IO读写交给操作系统处理，于应用程序没有直接关系，程序不需要关心IO读写，当操作系统完成了IO读写时，会给应用程序发送通知，应用程序直接拿走数据即可。
同步说的是server服务端的执行方式（面向操作系统，异步：操作系统已经完成加载的过程）
阻塞说的是具体技术，接收数据的方式、状态（io、nio）
AIO：
在NIO基础上引入了异步通道的概念，病提供了异步文件异步套接字通道的实现。AIO不需要通过多路复用器对注册的通道进行轮询操作即可实现异步读写，从而简化了NIO变成模型。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e95942970674c7ca983ba6802e22aea3/" rel="bookmark">
			spring注入jdbcTemplate时一直为空指针null
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天做一个项目，多数据源，第二个数据源采用的是spring的jdbcTemplate。三个项目，两个都没问题，其中一个jdbcTemplate一直为null。检查了一下，在spring启动时，jdbcTemplate对象也是有数据的，就是不知道为啥启动好之后，就变成null了，很头疼。后来去网上找了一下，发现其中一种解决方案可以解决我的问题。
先上我有问题的代码吧。
1、数据库配置（app-smsJdbc.xml）：
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd"&gt; &lt;!-- IOC和DI的注解扫描 --&gt; &lt;context:component-scan base-package="cn.gtmap.estateplat.register.service.smsImpl" &gt;&lt;/context:component-scan&gt; &lt;!-- 打开AOP的注解 --&gt; &lt;!-- 这里用的是中间的横线而不是下划线 --&gt; &lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt; &lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource" &gt; &lt;property name="driverClass" value="${sms.db.driver}"&gt;&lt;/property&gt; &lt;property name="jdbcUrl" value="${sms.db.url}"&gt;&lt;/property&gt; &lt;property name="user" value="${sms.db.username}"&gt;&lt;/property&gt; &lt;property name="password" value="${sms.db.password}"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id="cmccSmsServiceImpl" class="cn.gtmap.estateplat.register.service.smsImpl.CmccSmsServiceImpl"&gt; &lt;property name="jdbcTemplate" ref="jdbcTemplate"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;/beans&gt; 2、Java代码（CmccSmsServiceImpl.java）：
package cn.gtmap.estateplat.register.service.smsImpl; import cn.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e95942970674c7ca983ba6802e22aea3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/991de5ec27306bd497c680dde0e7c399/" rel="bookmark">
			人脸识别demo使用教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在研究虹软家的arcface 人脸识别 demo，现在就给大家分享一下官方的demo
**
工程如何使用？ **
1.下载代码:
git clone https://github.com/asdfqwrasdf/ArcFaceDemo.git 或者直接下载压缩包
2.前往官网申请appid和sdkkey。
修改 ArcFaceDemo-master\src\main\java\com\arcsoft\sdk_demo\FaceDB.java 下面的对应的值:
public static String appid = "xxxx"; public static String fd_key = "xxxx"; public static String ft_key = "xxxx"; public static String fr_key = "xxxx"; 3.下载sdk包之后，解压各个包里libs中的文件到 ArcFaceDemo-master\libs 下，同名so直接覆盖。
4.Android Studio3.0 中直接打开或者导入Project,编译运行即可。
**
demo如何使用? **
1.点击第一个按钮 打开图片或者拍一张带人脸的照片，确认后自动执行人脸，弹出注册框，注册第一个人脸。
注册界面底部会展示已注册的信息列表，点击列表项，则可以执行删除操作。
2.点击第二个按钮 选择打开前置或者后置的镜头进行检测。
**
demo中人脸数据的保存方式? **
以注册时人名为关键索引，保存在face.txt中。
创建的 name.data 则为实际的数据存储文件，保存了所有特征信息。
同一个名字可以注册多个不同状态角度的人脸，在name.data 中连续保存，占用的数据文件长度为:
N * {4字节(特征数据长度) + 22020字节(特征数据信息)}
最低支持的API-LEVEL?
14-27
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/991de5ec27306bd497c680dde0e7c399/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f92d459f05b74a430ac4ace93a1c1014/" rel="bookmark">
			汽车控制器（ECU）中DTC的状态位
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文转自https://zhuanlan.zhihu.com/p/35371763，感谢原作者！
从汽车ECU中读取储存的DTC(故障码)时，除了故障码本身，还可以读出很多其他的信息，包括优先级、发生次数计数器、发生时的里程和时间，以及本文中所讲的状态位（DTC status ）。
这个状态位包含1个byte，这里面的8个bit都有各自的含义，但是这8个 bit不一定都要使用，各个主机厂可以根据自己的需求使用其中的几个，当然也可以全部使用。下图是UDS对DTC status这8个bit的定义。
DTC status中8个状态bit的定义
bit 0 : testFailed
通常来说，ECU内部以循环的方式不断地针对预先定义好的错误路径进行测试，如果在最近的一次测试中，在某个错误路径中发现了故障，则相应DTC的这一个状态位就要被置1，表征出错。此时DTC的testFailed位被置1，但是它不一定被ECU存储到non-volatile memory中，只有当pendingDTC或confirmedDTC被置1时DTC才会被存储。而pendingDTC或confirmedDTC被置1的条件应该是检测到错误出现的次数或时间满足某个预定义的门限。当错误消失或者诊断仪执行了清除DTC指令时，testFailed会再次被置为0。
bit 1 :testFailedThisOperationCycle
这个bit用于标识某个DTC在当前的operation cycle中是否出现过testFailed置1的情况，即是否出现过错误。operation cycle的起始点是ECU通过网络管理唤醒到ECU通过网络管理进入睡眠，对于没有网络管理的ECU，这个起始点就是KL15通断。通过bit 0我们无法判断某个DTC是否出现过，比如，当前testFailed = 0， 说明当前这个DTC没有出错，如果testFailedThisOperationCycle = 1的话，就说明这个DTC在当前这个operation cycle中出过错，但是当前错误又消失了。
bit 2 : pendingDTC
根据规范的解释，pendingDTC = 1表示某个DTC在当前或者上一个operation cycle中是否出现过。pendingDTC位其实是位于testFailed和confirmedDTC之间的一个状态，有的DTC被确认的判定条件比较严苛，需要在多个operation cycle中出现才可以被判定为confirmed的状态，此时就需要借助于pendingDTC位了。pendingDTC = 1的时候，DTC就要被存储下来了，如果接下来的两个operation cycle中这个DTC都还存在，那么confirmedDTC就要置1了。如果当前operation cycle中，故障发生，pendingDTC = 1，但是在下一个operation cycle中，故障没有了，pendingDTC 仍然为 1，再下一个operation cycle中，故障仍然不存在，那么pendingDTC 就可以置0了。
bit 3 : confirmedDTC
当confirmedDTC = 1时，则说明某个DTC已经被存储到ECU的non-volatile memory中，说明这个DTC曾经满足了被confirmed的条件。但是请注意，confirmedDTC = 1时，并不意味着当前这个DTC仍然出错，如果confirmedDTC = 1，但testFailed = 0，则说明这个DTC表示的故障目前已经消失了。将confirmedDTC 重新置0的方法只有删除DTC，UDS用0x14服务，OBD用0x04服务。
bit 4 : testNotCompletedSinceLastClear
这个bit用于标识，自从上次调用了清理DTC的服务（UDS用0x14服务，OBD用0x04服务）之后，是否成功地执行了对某个DTC的测试（不管测试结果是什么，只关心是否测了）。因为很多DTC的测试也是需要满足某些边界条件的，并不是ECU上电就一定会对DTC进行检测。
testNotCompletedSinceLastClear = 1 : 自从清理DTC之后还没有完成过针对该DTC的测试。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f92d459f05b74a430ac4ace93a1c1014/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ecbbbaf73a16d6765b1590fea01437fd/" rel="bookmark">
			vue fist
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装vue：
安装node.js 淘宝镜像: sudo npm install -g cnpm --registry=https://registry.npm.taobao.org
sudo cnpm install -g vue-cli 初始化项目：
vue init webpack my-vueproject 运行：
cd my-vueprojectcnpm intall 添加依赖cnpm run dev 转载于:https://my.oschina.net/u/1431982/blog/1936856
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f186784b40446135454edb3e82960a1/" rel="bookmark">
			iptables failed: iptables --wait -t nat -A DOCKER -p tcp -d 0/0 --dport 5000 -j DNAT --to-destinatio
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 启动docker容器时报错：
iptables failed: iptables --wait -t nat -A DOCKER -p tcp -d 0/0 --dport 5000 -j DNAT --to-destination 172.18.0.4:5000 ! -i br-ff45d935188b: iptables: No chain/target/match by that name. (exit status 1)
解决方案：重启docker
systemctl restart docker 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94207359c5e9ad0b0c1573f5c3b68f7d/" rel="bookmark">
			ORB-SLAM轨迹保存问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ubuntu14.04,64位系统调试ORB-SLAM时出现不能保存相机运动轨迹问题
解决方案:
1:将保存轨迹函数SLAM.SaveKeyFrameTrajectoryTUM()放在SLAM.Shutdown()之后,但是并不能解决线程不能正常关闭问题.
2:system.cc的Shutdown()中添加下面两句话:
delete mpViewer;
mpViewer = static_cast&lt;Viewer*&gt;(NULL);
添加结果如图所示:
if(mpViewer) { mpViewer-&gt;RequestFinish(); while(!mpViewer-&gt;isFinished()) { usleep(5000); mpViewer-&gt;RequestFinish(); } delete mpViewer; mpViewer = static_cast&lt;Viewer*&gt;(NULL); } 之后可能会出现Pangolin库问题,我用的是SLAM14讲中的Pangolin库,没有问题,可以正确保存轨迹
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11d3365f62f2c6e8a049c856b8a8eb54/" rel="bookmark">
			linux下nginx配置静态资源的详细配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 server { listen 80; server_name 123.57.162.75; charset utf-8; index index.html index.htm index.jsp index.do; root /opt/nginx-1.4.7/html/resources; #配置Nginx动静分离，定义的静态页面直接从Nginx发布目录读取。 location ~ .*\.(html|htm|gif|jpg|jpeg|bmp|png|ico|txt|js|css)$ { root /opt/nginx-1.4.7/html/resources; #expires定义用户浏览器缓存的时间为7天，如果静态页面不常更新，可以设置更长，这样可以节省带宽和缓解服务器的压力 expires 7d; } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ec8983b12ac92030e5aa799d86c3050/" rel="bookmark">
			关于kernel-devel、kernel-header和kernel src的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载自https://blog.csdn.net/u012450329/article/details/54137564 版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/u012450329/article/details/54137564 A kernel-header package would contain ‘header files’ needed by some applications which would be built on the target machine, for example modules used by virtualbox or the proprietary nvidia driver.
http://kernelnewbies.org/KernelHeaders
A kernel-devel package would contain the complete source code for the linux kernel, which is needed if you wish to recompile the kernel you are currently running.
Example : Fedora, Redhat, CentOS
1) ‘kernel-header’ package :
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8ec8983b12ac92030e5aa799d86c3050/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f879f3e2d115d4738c8beed8f0bd8102/" rel="bookmark">
			openwrt源码框架解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载自https://blog.csdn.net/clirus/article/details/50496958 本篇的主要目的是想通过分析Makefile，了解openwrt编译过程。着重关注以下几点：
openwrt目录结构
主Makefile的解析过程，各子目录的目标生成。
kernel编译过程
firmware的生成过程
软件包的编译过程 openwrt目录结构 官方源下载速度太度，我从github上clone了openwrt的代码仓库。
git clone https://github.com/openwrt-mirror/openwrt.git 上图是openwrt目录结构，其中第一行是原始目录，第二行是编译过程中生成的目录。各目录的作用是：
tools - 编译时需要一些工具， tools里包含了获取和编译这些工具的命令。里面是一些Makefile，有的可能还有patch。每个Makefile里都有一句 (eval ( e v a l (call HostBuild))，表示编译这个工具是为了在主机上使用的。
toolchain - 包含一些命令去获取kernel headers, C library, bin-utils, compiler, debugger
target - 各平台在这个目录里定义了firmware和kernel的编译过程。
package - 包含针对各个软件包的Makefile。openwrt定义了一套Makefile模板，各软件参照这个模板定义了自己的信息，如软件包的版本、下载地址、编译方式、安装地址等。
include - openwrt的Makefile都存放在这里。
scripts - 一些perl脚本，用于软件包管理。
dl - 软件包下载后都放到这个目录里
build_dir - 软件包都解压到build_dir/里，然后在此编译
staging_dir - 最终安装目录。tools, toolchain被安装到这里，rootfs也会放到这里。
feeds - OpenWrt环境所需要的软件包套件 bin - 编译完成之后，firmware和各ipk会放到此目录下。
feeds说明： 最重要的feeds有：
‘packages’一些额外的基础路由器特性软件
‘LuCI’OpenWrt默认的GUI
‘Xwrt’另一种可选的GUI界面
需要能够连接互联网。
在下载之前可以通过查看’feeds.conf.default’文件，来检查哪些文件需要包含在环境中。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f879f3e2d115d4738c8beed8f0bd8102/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9032442647798dcb7b49ad68a8bf3923/" rel="bookmark">
			DbForge Studio for SQL Server入门教程：在查询生成器中创建查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【dbForge Studio for SQL Server下载】
我们将使用可视化查询设计器创建一个示例查询。我们将使用AdventureWorks2012数据库。假设我们需要显示上一年度总销售额超过2 000 000的所有员工。
以可视方式创建查询：
1.创建服务器连接。有关如何创建服务器连接的详细信息，请参阅：如何连接到数据库。
2.在开始页面上单击SQL开发，然后单击查询生成器。
3.将表从数据库资源管理器拖放到编辑器。按住CTRL ，选择Person 表和SalesPerson 表，然后将它们拖放到可视编辑器中。
4.选择Person表中的FirstName和LastName复选框，以及SalesPerson表中的SalesLastYear复选框。
5.基于BusinessEntityID主键在表之间创建关系。选择BusinessEntityID的人表和它拖到BusinessEntityID的业务员表。
6.在“位置”选项卡上，插入条件。单击绿色加号图标。
7.单击“ 输入值”。在“ 表”下拉列表中，选择“ SalesPerson”表，然后选择“ SalesLastYear”列。
8.单击等号并选择大于等号。
9.单击“ 输入值”并键入2 000 000。
10.在“ 分组依据” 选项卡上，选择要按输出数据分组的列。
11.在“ 订购依据”选项卡上，选择排序顺序。
12.最后，视觉查询将如下所示：
13.按F5执行查询。
14.您还可以查看和编辑自动生成的SQL代码。
在本主题中，我们回顾了非常简单的查询，但它展示了该方法在视觉上创建查询的便利性。如果对多个表和视图进行更复杂的查询，可视化查询编辑器将节省大量时间。
购买dbForge Studio for SQL Server正版授权的朋友可以点击 "咨询在线客服 "哦~~~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb4e485aa12ecb44d1b6289bcda966f9/" rel="bookmark">
			js获取表格动态添加行的数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题：动态添加table行所定义的id值重复问题
解决思路：定义name代替定义id，循环遍历行数组拿取每行数据
&lt;table id="table"&gt;
&lt;tr&gt;&lt;input name="name1" value="a"&gt;&amp;nbsp;&amp;nbsp;&lt;input name="name2" value="aa"&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;input name="name1" value="b"&gt;&amp;nbsp;&amp;nbsp;&lt;input name="name2" value="bb"&gt;&lt;/tr&gt;
&lt;/table&gt;
//获取table下的所有tr组成行数组
var trs = $("#table tr");
//获取tr数组长度
var number = trs.length;
//定义数据，组装数据
var testList = new Array();
//循环遍历拿取table的每一行数据
for(var i=0;i&lt;number;i++){
var tr = trs[i];
//find 搜索所有与指定表达式匹配的元素。这个函数是找出正在处理的元素的后代元素。
//获取每一行下面input的name='name1'，name='name2'的数据
var testValue1 = $(tr).find("input[name='name1']").val();
var testValue2 = $(tr).find("input[name='name2']").val();
//其他html元素数据获取方法一样
//var $(tr).find("input[type='checkbox']").is(':checked')//判断每一行的checkbox是否被选中true/false
var parms = {
"testName1": testValue1 ,
"testName2": testValue2
};
testList .push(parms);
}
//数据组装结果
//每个对象代表该table的每一行数据
testList=[
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fb4e485aa12ecb44d1b6289bcda966f9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd99890d7ab5e29ab19dab856f24d053/" rel="bookmark">
			navicat远程连接oracle数据库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.下载Navica安装，32位机器安装32位，64位机器安装64位，网上有破解版的，抛出一个链接。。
http://download.csdn.net/detail/ahgaoyong/9482314
2.打开Navicat，新建链接。
3.配置连接参数
如果以sysdba或者sysoperator身份登录则点开高级，选择角色。
4.点击连接测试
can not load oci.dll 87
5.先点击确定，然后去oracle官网下载oci和sqlplus
http://www.oracle.com/technetwork/database/features/instant-client/index.html
根据你安装的时候选择的Navicat的版本，安装了32位的Navicat选择32位，64位的Navicat选择64位，否则会出现can not load oci.dll 193错误。
下载两个包，instantclient-basic和instantclient-sqlplus，版本选择最新的即可。
把两个包解压后内容放到一起。放到一个目录内。
6.Navicat打开工具-选项-OCI，如下设置后，重启Navicat。
7.再次连接，成功。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4f43b96bd793b654e8f94ba45bbebc9/" rel="bookmark">
			Hive 删除表报错： FAILED: Execution Error, return code 1 from org.apache.hadoop.hive.ql.exec.DDLTask.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		操作Hive 的时候报错， 提示如下 ：
hive&gt; drop table toss1; FAILED: Execution Error, return code 1 from org.apache.hadoop.hive.ql.exec.DDLTask. MetaException(message:Exception thrown when executing query : SELECT DISTINCT 'org.apache.hadoop.hive.metastore.model.MPartition' AS `NUCLEUS_TYPE`,`A0`.`CREATE_TIME`,`A0`.`LAST_ACCESS_TIME`,`A0`.`PART_NAME`,`A0`.`PART_ID`,` A0`.`PART_NAME` AS `NUCORDER0` FROM `PARTITIONS` `A0` LEFT OUTER JOIN `TBLS` `B0` ON `A0`.`TBL_ID` = `B0`.`TBL_ID` LEFT OUTER JOIN `DBS` `C0` ON `B0`.`DB_ID` = `C0`.`DB_ID` WHERE `B0`.`TBL_NAME` = ? AND `C0`.`NAME` = ? ORDER BY `NUCORDER0` LIMIT 0,300 ) 经发现替换mysql jar 包进行解决。 hive&gt; drop table toss1; OK Time taken: 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a4f43b96bd793b654e8f94ba45bbebc9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e4b4409939f72328cc4647f79d9ebd1/" rel="bookmark">
			[EMWIN] Dialog 中Framewin句柄 记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Dialog 中Framewin句柄 记录 在Dialog回调中个消息的句柄 WM_INIT_DIALOG : Framewin 的主窗口句柄 Dialog资源列表创建的控件 使用WM_GetParent() 获取到的Parent句柄为Framewin的客户区句柄 Dialog 中Framewin句柄 记录 在Dialog回调中个消息的句柄 WM_INIT_DIALOG : Framewin 的主窗口句柄 Dialog资源列表创建的控件 使用WM_GetParent() 获取到的Parent句柄为Framewin的客户区句柄 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0002580fd34a022e8411823e385d3b6d/" rel="bookmark">
			Redis Cluster 实现原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文基本上是 redis cluster 规范 的翻译（意译），希望能对您理解 redis cluster 的原理有所帮助。若发现哪里说的不明白，或者有错误，希望能够在评论里指出，不胜感激。
主要特性和设计原则 设计目标Redis Cluster 支持的操作Redis Cluster 协议中 Client 和 Server 的作用写安全可用性性能为什么没有 merge 操作 Redis Cluster 的主要组成部分 keys distribution model哈希标签 hash tags集群节点属性集群总线集群拓扑结构节点间的握手 重定向和重新分片 MOVED 重定向运行时集群配置变更ASK 重定向集群 client多键操作用 slave 节点扩展读请求 容错 心跳和 gossip 消息心跳包内容错误检测 PFAIL flagFAIL flag 配置处理，传播和失败转移 集群 current epochconfiguration epochSlave 选举和提升Slave Rankmaster 回应 slave 的选举请求在分隔（partition）情况下 configEpoch 的实际作用哈希槽配置的传播节点重新加入集群备份迁移备份迁移算法configEpoch 冲突解决算法节点重置从集群删除节点 发布-订阅附录 附录A： CRC16 算法的 C 语言实现 主要特性和设计原则 设计目标 Redis Cluster 是 Redis 的一个分布式实现。它具有以下设计重点：
高性能，可水平扩展到1000个节点。没有代理；异步备份；冲突时没有 merge 操作。可接受的写安全。系统尽最大可能保证连接到大部分 master 节点的 client 的写操作的完整性。不过数据仍然有一个丢失窗口，在这个窗口内写操作有可能成功返回但不保证完整性。如果 client 只连接到小部分的 master 节点，这个丢失窗口更大。可用性。只要满足这两个条件可用性就能保证：a.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0002580fd34a022e8411823e385d3b6d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3219fd1f6c25e59f8585652098372d5c/" rel="bookmark">
			MySQL8.0  大小写敏感修改的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MySQL8.0想要 大小写不敏感，必须在安装好MySQL后 修改mySQL配置文件设置为不敏感，一旦启动后，再 设置是无效的，而且 启动报错，。
如果已经晚了，那必须把MySQL数据库 data目录下所有文件 删除，修改配置文件再启动。数据库会重新 加载。
亲测可用，无问题。
### 此博客年限较早，预计官方后期会 修复这个问题，大家关注官方 最新动态，如有需要，请备份数据。 #让MYSQL大小写敏感(1-不敏感，0-敏感)/etc/my.cnf
lower_case_table_names=1
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45a26eb4fb75478862da23c2b2a34bf4/" rel="bookmark">
			Vue中的异步渲染DOM
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;template&gt; &lt;div&gt; &lt;div ref="message"&gt;{{message}}&lt;/div&gt; &lt;button @click="fn"&gt;点击&lt;/button&gt; &lt;/div&gt; &lt;/template&gt; export default { data () { return { message: 123 }; }, methods () { fn () { this.message = 456; console.log(this.$refs.message.innerHTML); //? } } } 上面的答案是 123 ，原因此时还没有将数据的更改，重新更新到DOM中。Vue这样做的好处是，最终一次性更新DOM，避免重复操作DOM，耗费性能。 使用vue中的nextTick可以获取更新DOM后的操作 &lt;template&gt; &lt;div&gt; &lt;div ref="message"&gt;{{message}}&lt;/div&gt; &lt;button @click="fn"&gt;点击&lt;/button&gt; &lt;/div&gt; &lt;/template&gt; export default { data () { return { message: 123 }; }, methods () { fn () { this.message = 456; this.$nextTick(function(){ //或者Vue.nextTick console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/45a26eb4fb75478862da23c2b2a34bf4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60b96a86eed665b69ff46bdb6c4de974/" rel="bookmark">
			【数学基础】线性方程组解情况整理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、非齐次线性方程组，无解，多解，唯一解 非齐次线性方程组，就是方程组的等式右边不为0的方程组，系数加上方程等式右边的矩阵，叫做增广矩阵。
【例1】求解下列线性方程组
化简后的有效方程组个数小于未知数个数，有多个解。
第一步，先列出增广矩阵：
第二步，用高斯消元法化简，化简成阶梯矩阵
先把第2行换到第1行 第2行减第1行的2倍，第3行减第1行的3倍，得到 第3行减第2行，得到 化简后的方程组，等于 这样，可以通过来表示，也可以通过 来表示，这样 就叫做自由变量， 可以取任意值。所以 就有无穷多个解。
可见，化简后的有效方程组个数，小于未知数个数。 有效方程组个数=2，未知数个数=3
化简后的有效方程组个数，小于未知数个数。这样的方程组有无穷多个解化。即。
【例2】求解下列线性方程组
化简后的有效方程组出现(0=d)型式不兼容方程，则无解化。
第一步，先列出增广矩阵：
第二步，用高斯消元法化简，化简成阶梯矩阵。
第2行减去第1行*2，第3行减去第2行 导出最后一个方程： 这个方程是不可能成立的，所以原线性方程组无解。 这种形式的方程叫做 {0=d} 方程，其中d是非零数，这种叫做不相容方程，也是自相矛盾的方程。 {0=d} 方程是一种自相矛盾的方程，左边全是0，右边是一个非零，这是自相矛盾的，是不相容的，所以无解。 化简后导出 {0=d} 形式的方程，方程组无解。
判断有解无解总结： 对于 方程组 通过高斯消元法，化简，化成阶梯行方程组 先看看是否出现{0=d}形式的不相容方程，如果出现，无解。有解的情况下，再看看有效方程个数是否小于未知数个数，如果是，则有无穷多个解。如果正好相等，则有唯一解。 二、齐次线性方程组，非零解，零解 齐次线性方程组，就是方程组的等式右边全部是0的方程组，只有系数矩阵，不需要增广矩阵，所以不会出现{0=d}形式的不相容方程。所以不会出现无解的情况，只需要考虑是多个解，还是唯一解。
对于齐次线性方程组，有多个解叫做有非零解。唯一解叫做零解。多个解叫做有非零解。唯一解叫做零解。
对于的齐次线性方程组，列出其系数矩阵（不需要增广矩阵），使用高斯消元法化简，化为阶梯形矩阵，化简后，判断有效方程组个数是否小于未知数个数。
如果有效方程组个数小于未知数个数，叫做有非零解（多个解） 。如果等于，叫做只有零解（唯一解）。
三、什么是矩阵的秩（），什么是detA? detA就是矩阵A的行列式的值。
什么叫做矩阵的秩？ 将矩阵用高斯消元法化简后，非零行的行数叫做行秩，非零列的列数叫做列秩。 矩阵的秩是方阵经过初等变换后的非零行行数或非零列列数。 可以将矩阵看成一个个行向量或者列向量，秩就是极大无关组中所含向量的个数。
定义：的不为零的子式的最大阶数称为矩阵A的秩。
记做，或者。
特别规定零矩阵的秩就是零。 若A中至少有一个r阶子式不等于零，且在r&lt; min(m,n)时，A中所有的r+1阶子式全为零，则A的秩为r。 由定义直接可得n阶可逆矩阵的秩为n。
满秩矩阵才可逆（以下记为第i个矩阵的初等变化）：
如果矩阵A是满秩的，我们就可以通过一系列的初等变化将矩阵A变换为单位矩阵。
则
所有通常又将可逆矩阵称为满秩矩阵，满秩矩阵。
不满秩矩阵就是奇异矩阵，奇异矩阵
由行列式性质知道，矩阵A的转置AT的秩与A的秩是一样的。
四、通过矩阵的秩（）来判断线性方程组无解，有多个解，唯一解的问题 线性方程组什么时候无解，有多个解，唯一解？
1.对于非齐次线性方程组，用矩阵的秩r(A)来判断
对线性方程组进行初等变换（高斯消元法），化为最简型（阶梯形）矩阵。
考查系数矩阵r(A)，增广矩阵r(A,b)，以及方程组未知数个数n。
如果系数矩阵的秩r(A)小于增广矩阵的秩r(A,b)，r(A)&lt;r(A,b)，那么方程组无解；
如果系统矩阵的秩小于方程组未知数个数，r(A)=r(A,b)&lt;n，那么方程组有多个解。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/60b96a86eed665b69ff46bdb6c4de974/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67d0e9e0956332ad44f04f83633feb62/" rel="bookmark">
			Hadoop与MPP是什么关系?有什么区别和联系?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 [url=https://blog.csdn.net/tbdp6411/article/details/50389059]Hadoop与MPP是什么关系?有什么区别和联系?[/url] 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/922ea3725a7a58d388c7148888262d4f/" rel="bookmark">
			【20180829】【C/C&#43;&#43;基础知识】复习match函数程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		例5：实现匹配函数match：程序在输入字符串中查找一个给定的字符，如果找到，则从该字符开始打印余下的子字符串，及该字符是字符串的第几个字符；否则输出“no match found”。 拓展：在输入字符串s2中查找s1字符串。 第一次写的程序：
/* match函数：在s2中查找s1，并输出s1之后的所有字符 */ #include &lt;stdio.h&gt; #include&lt;stdlib.h&gt; #include&lt;string.h&gt; char *match(); // 函数声明 char *match(char a[50],char b[100]) // 实现搜索的功能 { char *p1=a,*p2=b,*p; int i,len1,posit=0,locat=0; for(i=0;p1!='\0';p1++) // 求s1长度，便于后面找s2中出现s1的位置 i++; len1=i+1; // 错误2！！！ p1=a; p2=b; while(p2!='\0') // 错误1！！！ { if(*p1!=*p2) { p2++; posit++; p1=a; } else { while((*p2==*p1)&amp;&amp;(p1!='\0')) { p1++; p2++; posit++; } } if(*p1=='\0') { locat=posit-len1; p=&amp;(b[locat]); } else p=NULL; } return p; } int main() // 定义一些变量，获取字符串，调用match函数，进而做下一步操作 { char s1[50],s2[100],*p; printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/922ea3725a7a58d388c7148888262d4f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7fcdea416317c5680ccbc8164d56810d/" rel="bookmark">
			unity中OnEnable()和OnDisable()
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里做一个关于OnEnable()和OnDisable()个测试。在场景中cube上挂一个脚本TestOne.cs,然后在另一物体上挂脚本TestTwo.cs;
TestOne如下：
public class TestOne : MonoBehaviour { private void OnEnable() { print("激活"); } private void OnDisable() { print("禁止"); } }``` TestTwo.cs如下：
void Update () { //MouseRotate2(); MouseRotate(); testActive(); } private void OnEnable() //只在程序启动时执行一次，因为TestTwo脚本并没有挂在cube上 { print("启用"); } private void OnDisable() //只在程序停止时执行一次，因为TestTwo脚本并没有挂在cube上 { print("禁调"); } void testActive() { if(Input.GetKeyDown(KeyCode.A)) { // cube.gameObject.SetActive(false);//游戏对象.setActive(false)会激发游戏对象上挂的脚本中的OnDisable()方法（前提是该游戏对象的状态由true到false发生转变）； // cube.GetComponent&lt;MeshRenderer&gt;().enabled = false; //这种情况下onEnable和onDisable不会被调用的（enable()方法只是控制对象在屏幕上是否渲染出现，碰撞还是可以检测到的哦）； Destroy(cube.gameObject); //destroy游戏对象会激发游戏对象上挂的脚本中的OnDisable()方法； } if(Input.GetKeyDown(KeyCode.B)) { //cube.gameObject.SetActive(true);//游戏对象.setActive(true)会激发游戏对象上挂的脚本中的OnEnable()方法（前提是该游戏对象的状态由false到true发生转变）； // cube.GetComponent&lt;MeshRenderer&gt;().enabled = true; Object cc =Resources.Load("Cube");//重新创造该游戏对象也会激发对象上挂脚本中的OnEnable()方法； GameObject vv = (GameObject) Instantiate(cc, Vector3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7fcdea416317c5680ccbc8164d56810d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/596c99e99f7263e76b999229e88f3509/" rel="bookmark">
			vue 根据数组中某一项的值进行排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前言 我在vue项目中遇到了一个表格排序的需求，根据某一项的值的大小从大到小调整数组顺序。
二、代码 表格大概是这个样子，样式和图片在代码中简化了。
&lt;table class="recommend_table" cellspacing="0"&gt; &lt;tr&gt; &lt;th&gt;股票&lt;/th&gt; &lt;th @click="sort('in_price')"&gt;入选价&lt;/th&gt; &lt;th @click="sort('now_price')"&gt;最新价&lt;/th&gt; &lt;th @click="sort('increase')"&gt;模拟涨跌幅&lt;/th&gt; &lt;/tr&gt; &lt;tr v-for="(item,index) in recommendlist" :key="index"&gt; &lt;td&gt; &lt;div class="recommend_name"&gt;{{item.name}}&lt;/div&gt; &lt;div class="recommend_num"&gt;{{item.bn}}&lt;/div&gt; &lt;/td&gt; &lt;td&gt;{{item.in_price}}&lt;/td&gt; &lt;td&gt;{{item.now_price}}&lt;/td&gt; &lt;td&gt;{{item.increase}}%&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;script type="text/ecmascript-6"&gt; export default { data(){ return{ recommendlist: [ { name:'高科石化', bn:'002778', in_price: 20.68, now_price: 28.68, increase: 10.01 }, { name:'中孚信息', bn:'300659', in_price: 19.46, now_price: 17.46, increase: 9.06 }, { name:'永福股份', bn:'300712', in_price: 17.68, now_price: 32.68, increase: 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/596c99e99f7263e76b999229e88f3509/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a1a581474a135e973c365ee71aafd34/" rel="bookmark">
			Python之strip详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		strip Python strip() 方法用于移除字符串头尾指定的字符（默认为空格）或字符序列。 注意：该方法只能删除开头或是结尾的字符，不能删除中间部分的字符。 语法：
str.strip([chars]); 参数 chars – 移除字符串头尾指定的字符序列。 如果不带参数，默认是清除两边的空白符，例如：/n, /r, /t, ’ ’ 例一：
str = "*****this is **string** example....wow!!!*****" print (str.strip( '*' )) # 指定字符串 * 运行结果： this is **string** example....wow!!! 例二：
str = "123abcrunoob321" print (str.strip( '12' )) # 字符序列为 12 以上实例输出结果如下： 3abcrunoob3 例三：如果要删除的字符列表不包含第一个字符呢？
addr = '123@163.com'addr1 = addr.strip('23') 此时 2 不是第一个字符，所以无法继续，结果为： 123@163.com 比较简单的一个函数！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/608b7e2032023d80a9e516363eb62617/" rel="bookmark">
			Python之format的用法详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		format函数 它增强了字符串格式化的功能。基本语法是通过 {} 和 : 来代替以前的 % 。format 函数可以接受不限个参数，位置可以不按顺序。
**例一：**format 函数可以接受不限个参数，位置可以不按顺序。
"{} {}".format("hello", "world") # 不设置指定位置，按默认顺序 运行结果：'hello world' "{0} {1}".format("hello", "world") # 设置指定位置 运行结果：'hello world' "{1} {0} {1}".format("hello", "world") # 设置指定位置 运行结果：'world hello world' 例二：也可以设置参数。
print("网站名：{name}, 地址 {url}".format(name="菜鸟教程", url="www.runoob.com")) # 通过字典设置参数 site = {"name": "菜鸟教程", "url": "www.runoob.com"} print("网站名：{name}, 地址 {url}".format(**site)) # 通过列表索引设置参数 my_list = ['菜鸟教程', 'www.runoob.com'] print("网站名：{0[0]}, 地址 {0[1]}".format(my_list)) # "0" 是必须的 运行结果： 网站名：菜鸟教程, 地址 www.runoob.com 网站名：菜鸟教程, 地址 www.runoob.com 网站名：菜鸟教程, 地址 www.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/608b7e2032023d80a9e516363eb62617/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1dc15aa725649e3e05a69007825eb88e/" rel="bookmark">
			eslint问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Expected parentheses around arrow function argument having a body with curly braces 带花括号body的箭头函数参数周围，需要一个括号方法尝试很多，按照eslint官网http://eslint.cn/docs/4.0.0/rules/arrow-parens在.eslintrc.js中的rules里写入'arrow-parens': 'off',（关闭圆括号） Unexpected string concatenation 意外的字符串连接
在.eslintrc.js中的rules里写入'prefer-template': 'off' eslint真的是个麻烦的东西，但是确实好，javascript红宝书作者开发的，能不好吗。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5f37bf6d1dfa273fc8f4535652af5e8/" rel="bookmark">
			WPF中对App.Config的读写操作（例：记住账号密码功能）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近做WPF项目有一个需要记住账号密码的操作，第一反应像这种记住账号密码的应该可以保存在本地xml配置文件中，于是就去查了下别人的资料，自己加以整理学习。
WPF应用程序中有一个App.config文件，编译时会在Debug文件夹下生成一个“程序集名称+.exe.config”的xml文件，记录一些配置项。废话不多说，下面开始来完成记住账号密码这个需求：
1.首先在App.config中的&lt;configuration&gt;中添加以下代码，最常用的就是appSettings节点了，通过添加key和value键值对，从而完成参数的配置与读写操作，其中key是键，value是具体保存的值，在这声明了三个，分别是账号、密码和是否记住这三组kv键值对。
&lt;appSettings&gt; &lt;add key="userName" value="admin"/&gt; &lt;add key="password" value="1"/&gt; &lt;add key="isRemember" value="true"/&gt; &lt;/appSettings&gt; 2.前台放上账号，密码和是否记住这几个控件，后台需要引用System.Configuration.dll这个类库，这个类库提供了对客户端应用程序配置文件的访问方法。以下是对配置文件中键值对读写操作的方法：
1）读的方法根据传入键名去找对应的值返回。
2）写的方法传入键值，不为NULL则跟新配置文件。
/// &lt;summary&gt; /// 读取客户设置 /// &lt;/summary&gt; /// &lt;param name="settingName"&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static string GetSettingString(string settingName) { try { string settingString = ConfigurationManager.AppSettings[settingName].ToString(); return settingString; } catch (Exception) { return null; } } /// &lt;summary&gt; /// 更新设置 /// &lt;/summary&gt; /// &lt;param name="settingName"&gt;&lt;/param&gt; /// &lt;param name="valueName"&gt;&lt;/param&gt; public static void UpdateSettingString(string settingName, string valueName) { Configuration config = ConfigurationManager.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f5f37bf6d1dfa273fc8f4535652af5e8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45c47050e4843edf37da2e9c1e330eb6/" rel="bookmark">
			什么是数据库的参照完整性？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是数据库的参照完整性？
解答：数据库的参照完整性是指表与表之间的一种对应关系，通常情况下可以通过设置两表之间的主键、外键关系，或者编写两表的触发器来实现。 有对应参照完整性的两张表格，在对他们进行数据插入、更新、删除的过程中，系统都会将被修改表格与另一张对应表格进行对照，从而阻止一些不正确的数据的操作。
转载于:https://www.cnblogs.com/borter/p/9549151.html
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/281/">«</a>
	<span class="pagination__item pagination__item--current">282/321</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/283/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>