<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab9e26f177fcea33b329cfb63bbc1b7a/" rel="bookmark">
			腾讯云服务器新人专享优惠购买建议，附腾讯云服务器优惠购买入口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		腾讯云服务器以其多样化的云服务产品而闻名于业界。其中，轻量应用服务器是一项非常受欢迎的产品。该产品基于容器技术，通过优化配置和精简功能，提供了更高的性能和更低的成本。它适用于小型应用、个人博客和测试环境等场景。
此外，腾讯云服务器还经常推出各种优惠活动，例如首购特惠、新用户折扣等，让用户可以以更优惠的价格购买服务器。特别值得一提的是，用户可以利用首购特惠资格购买更长时间的服务器，以获得更多的优惠。同时，注册新账号也可以享受到新用户的折扣优惠。这些措施为用户提供了更多的选择和便利。
腾讯云双十一领9999代金券 https://1111.mian100.cn
腾讯云新用户领2860代金券 https://xinke.mian100.cn
腾讯云3年时长、5年时长优惠服务器尽享新用户优惠 https://5nian.mian100.cn
购买建议：更多的优惠，更长的时间 基于以上特点和价格优势，笔者为用户提供如下购买建议，帮助用户更好地利用腾讯云服务器：
利用首购特惠：腾讯云服务器经常推出首购特惠活动，用户可以在购买服务器时充分利用这些优惠，以获得更多的优惠。
购买更长时间的服务器：通过购买更长时间的服务器，用户可以获得更多的优惠。腾讯云服务器提供了不同时长的购买选项，用户可以根据自己的需求选择最合适的时长。
注册新账号：注册新账号可以享受到新用户的折扣优惠。如果您还没有腾讯云服务器的账号，不妨注册一个新账号，以便享受这些优惠。
通过以上购买建议，用户可以以更实惠的价格购买腾讯云服务器，并获得更多的优惠。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ddc4a607a0f5dfbf07cf2f0e15ae32a9/" rel="bookmark">
			C语言 哈希查找（哈希表的创建、处理冲突、查找等）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 哈希查找（Hash Search）是一种基于哈希表实现的数据查找算法，也可以被称为散列查找。
在哈希查找中，首先根据给定的键值通过哈希函数计算出对应的哈希值，然后利用该哈希值在哈希表中定位到具有相同哈希值的一个桶（Bucket），再在桶中进行线性查找和比较，以确定目标记录是否存在。若存在，则返回该记录在哈希表中存放的位置；若不存在，则说明该记录未被存储在哈希表中。
哈希表（Hash Table）：
哈希表也叫散列表，是一种根据关键码值（Key-value）而直接进行访问的数据结构。通常情况下，它通过把关键码值映射到一个表中的位置来访问记录，以加快查找的速度。换句话说，哈希表就是一种以键值对作为存储基本单位的数据结构。
哈希函数（Hash Function）：
哈希函数是一种将任意长度的输入（也叫“键”或“关键字”）映射到固定长度的输出（也叫“哈希值”或“散列值”的）的函数。通常情况下，哈希函数需要具有以下特点：
可以接受不同长度的输入，但输出长度固定。对于相同的输入，必须输出相同的结果。对于不同的输入，输出的哈希值应尽可能均匀地分布在整个哈希表中。计算速度快、容易实现且不会出现哈希冲突（即不同的输入映射到了同一个哈希值上）等要求 目录
前言
哈希函数的构造方法
处理哈希冲突的方法
哈希查找算法实现
开放定址法处理冲突的哈希表
链地址法处理冲突的哈希表 总结
哈希函数的构造方法 哈希函数的构造方法有很多种，常见的包括以下几种：
直接定址法（Direct Addressing）：将关键字直接作为地址使用，适用于关键字较小且连续的情况。例如对于关键字 k，哈希函数可以设置为 f(k) = a * k + b，其中 a、b 是常数。数字分析法（Digital Analysis）：根据关键字的分布规律来设计哈希函数，适用于数据中存在一定规律的情况。例如对于电话号码（11 位数字），可以将前三位和后两位分别乘以某个常数相加得到哈希值。平方取中法（The Mid-square Method）：将关键字平方后取中间几位作为哈希值，适用于关键字位数较多的情况，可增加哈希函数的随机性和分布性。除留余数法（Modular division method）：将关键字除以一个常数 m，取余数作为哈希值，即 f(k) = k % m。除留余数法是哈希函数设计中最常用的方法之一，容易实现且效果不错。折叠法（Folding method）：将关键字分割成若干段，取每段的和作为哈希地址。适用于关键字长度较长的情况。随机数法（Random Number）：使用随机函数生成随机数来产生哈希值，这种方法虽然能够尽可能避免哈希冲突，但也会带来效率上的问题。 哈希函数的构造方法应该根据实际情况进行选择和设计，要尽可能避免哈希冲突、保证哈希表的均匀性和稳定性，并满足计算速度快、易于实现等要求。同时需要注意的是，不同的哈希函数适用于不同类型的数据，需要根据具体数据进行选择。
处理哈希冲突的方法 哈希函数在将关键字映射到哈希表的数组下标时，可能会遇到多个不同的关键字被映射到同一个单元格的情况，即发生哈希冲突。处理哈希冲突的方法有以下几种：
链地址法（Chaining）也叫拉链法：将哈希表中每个单元格视为链表的头节点，所有哈希值相同的关键字放在该单元格对应链表的末尾。这种方法不会浪费空间，但需要消耗时间查找链表。 开放定址法（Open addressing）：当哈希值发生冲突时，依次检查哈希表中下一个位置是否空闲，直到找到一个合适的位置存储该关键字。开放定址法中有几种常见的变种策略，如线性探测、二次探测和双重散列等。再哈希法（Rehashing）：使用另一种哈希函数再次计算冲突的关键字的哈希值，并重新安排其在哈希表中的存储位置。这样可以分摊哈希冲突，并减少链表长度。但是，此方式的代价较大，因为需要对数据结构进行重新哈希操作。 根据实际应用场景选择适当的哈希冲突解决方案，可以提高哈希表的查询效率和空间利用率。
哈希查找算法实现 哈希查找流程主要包括建立哈希表、插入数据、查找数据和删除数据这几个步骤。其中，哈希函数的设计和冲突处理方法的选择是实现哈希查找算法时的关键。
具体实现流程如下：
建立哈希表：选定合适的哈希函数、定义好哈希表及其相关属性，给哈希表分配足够的空间。插入数据：将要查找的数据通过哈希函数转化为对应的哈希码，并确定在哈希表中对应的位置；进而将数据储存在该位置上。如果发生冲突，则采用相应的冲突处理方法来解决冲突，保证数据被正确储存。查找数据：需要查询数据时，先通过相同的哈希函数计算出要查找的数据的哈希码，然后根据哈希码得到在哈希表中的位置。若该位置上没有数据，则说明所查找的数据不存在；否则，在该位置上遍历查找，并返回所找到的数据。删除数据：删除数据时，需要先通过哈希表查找到所要删除数据的位置，并将其从哈希表中移除。同时，需要使用相应的冲突解决方法，重新整理该位置上的其他数据，以确保这些数据的正确性不受影响。 以下介绍常用的两种哈希表：
开放定址法处理冲突的哈希表 开放定址哈希表是一种基于数组实现的哈希表，可以采用线性探测、二次探测、双重散列等方式处理哈希冲突。其中，线性探测法是最简单的方法，其思路是依次访问下一个（i+1）个槽位，直到发现空闲槽位为止。
下面是使用线性探测法创建哈希表的示例代码：
#define _CRT_SECURE_NO_WARNINGS 1 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #define NIL 0 typedef struct { int* Table;//储存哈希节点的数组基地址 int size;//哈希表长度 }HashTable; //初始化哈希表 HashTable* InitHashTabel(int size) { HashTable* H = malloc(sizeof(HashTable)); H-&gt;size = size; H-&gt;Table = (int*)malloc(sizeof(int) * size); //将所以槽位初始化为空闲状态 while (size &gt; 0) H-&gt;Table[--size] = NIL; return H; } //哈希函数 int Hash(int data, int size) { return data % size;//除留余数法 } //线性探测法解决哈希冲突 int LinearProbe(HashTable* H, int data) { int Pos = Hash(data, H-&gt;size);//通过哈希函数计算得到其哈希地址 //若当前位置被占用 while (H-&gt;Table[Pos] !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ddc4a607a0f5dfbf07cf2f0e15ae32a9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dff75248aea5715970791e587e683376/" rel="bookmark">
			2311rust,到46版本更新
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.43.0稳定版 项(item)片段 在宏中,可用项片段把项插值到特征,实现和extern块的块体中.如:
macro_rules! mac_trait { ($i:item) =&gt; { trait T { $i } } } mac_trait! { fn foo() {} } 这生成:
trait T { fn foo() {} } 围绕原语的推导类型 改进了围绕原语,引用和二进制操作的推导类型.如下片段,
let n: f32 = 0.0 + &amp;0.0; 在Rust1.42中,你会收到错误,说"嘿,不知道如何加f64和&amp;f64,而结果是f32.该算法现在正确地决定0.0和&amp;0.0都应该是f32.
测试新的Cargo环境变量 为了帮助整合测试,Cargo设置一些新的环境变量.
假设正在处理叫"cli"的命令行项目.如果正在编写整合测试,想调用该cli二进制文件并查看它的作用.
运行测试和基准测试时,Cargo会设置可在测试中使用的叫CARGO_BIN_EXE_cli的环境变量:
let exe = env!("CARGO_BIN_EXE_cli"); 这使得调用cli更加容易,因为现在可直接调用.
更改库 现在,不必导入模块,可直接在浮点数和整数上使用关联常量.也即,现在不必用 std::u32;或用 std::f32;,就可编写u32::MAX或f32::NAN.
有个可重新导出Rust原语类型的新的原语模块.编写宏并想确保类型不会被遮蔽时,很有用.
此外,还稳定了6个新API:
Once::is_completed f32::LOG10_2 f32::LOG2_10 f64::LOG10_2 f64::LOG2_10 iter::once_with Rust1.43.1 1,修复了无法检测到的CPU功能
2,修复破损的cargo package --list
3,OpenSSL更新到1.1.1g
1.44.0稳定版 亮点是cargo中整合了cargo tree,并在no_std环境中支持async/await.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dff75248aea5715970791e587e683376/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/effdbe19472203eb61111d41bcad63c5/" rel="bookmark">
			向pycdc项目提的一个pr
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		向pycdc项目提的一个pr 前言 pycdc这个项目，我之前一直有在关注，之前使用他反编译python3.10项目，之前使用的 uncompyle6无法反编译pyhton3.10生成的pyc文件，但是pycdc可以，但是反编译效果感觉不如uncompyle6。但是版本更新很快，支持的python版本很多。
在issue看到别人提供的pyc文件 我逛github的时候，看看这个项目有没有更新啥新特性，在issue里面看到别人提的issue，带了一个pyc文件。本着乐于助人的态度，也想学习一下这个项目是如何解析pyc文件到py文件的。就下载了这个pyc。看他提的pr。是报了一个Unsupported Node type: 27错误。但是看他发的报错。感觉不止这一个报错。
E:\temp_vc\pycdc\build_v141\Release&gt;pycdc.exe model.pyc &gt;model.py Unsupported Node type: 27 Unsupported Node type: 27 Unsupported Node type: 27 Unsupported argument found for LIST_EXTEND Unsupported opcode: LIST_TO_TUPLE Unsupported opcode: CALL_FUNCTION_EX Unsupported opcode: DICT_MERGE Unsupported Node type: 27 Unsupported Node type: 27 Unsupported argument found for LIST_EXTEND Unsupported opcode: LIST_TO_TUPLE Unsupported Node type: 27 Unsupported Node type: 27 Unsupported Node type: 27 Unsupported Node type: 27 Unsupported Node type: 27 Unsupported Node type: 27 Unsupported Node type: 27 Warning: block stack is not empty!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/effdbe19472203eb61111d41bcad63c5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39feead8245e0fb122577e03b87f7c4a/" rel="bookmark">
			24年考研即将开始，我想告诉你这几件事
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.为什么要考研？
2.考研你需要做什么
3.即将考研，做好考前准备
1.为什么要考研？ 考研是指为了进入研究生阶段而进行的全国性统一考试。接下来我将论述一下考研的利与弊。
利：考研是继本科之后的另一次深造机会，可以进一步提升自己的学术水平和专业知识。通过攻读硕士或博士学位，可以更深入地研究自己感兴趣的领域，并获得更高级别的学历。就业竞争力：研究生学历在某些行业和职位上具有竞争优势。一些高端的科研机构、大型企业以及高等教育机构更倾向于招聘具有研究背景的人才。对于那些希望从事学术研究、教育、科研或高级职业的人来说，考研可以提升他们的就业竞争力。学术交流与合作机会：进入研究生阶段后，可以接触到更多优秀的学者和同行，参与学术研讨会、讲座和合作项目。这些机会可以促进学术交流，拓宽研究领域，提高自己的学术能力。
弊：高度竞争：考研是一项高度竞争的过程，每年都有大量的学生参与考试，而录取名额有限。备战考研需要付出大量的时间、精力和资源，对于一些没有足够准备或不适应考试模式的学生来说，可能会面临较大的挑战。时间压力：考研的准备需要长时间的投入，可能需要提前一年或更长时间进行系统的学习和备考。这对于已经有就业意向或其他规划的学生来说，可能需要做出权衡和时间安排上的调整。延迟就业：攻读研究生学位通常需要2-3年的时间，在这段期间，无法直接参与工作。对于那些希望尽早就业或者已经有一定工作经验的学生来说，可能需要考虑延迟就业的问题。总的来说，考研有利于学术深造、提高就业竞争力和学术交流，但也存在竞争激烈、时间压力、经济负担和延迟就业等弊端。个人在决定是否考研时应权衡利弊，结合自身情况做出合理的选择。
2.考研你需要做什么 考研指定计划表是非常有必要的，当制定考研计划表时，需要考虑以下几个方面：准备时间、复习内容、备考阶段、模拟考试和调整计划。以下是一个简单的考研计划表示例，供您参考：
准备时间：12个月
第1-2个月：了解考研信息和要求，选择专业和院校，准备报名材料。
第3-4个月：查阅教材和参考书籍，制定学习计划，进行基础知识的学习和复习。
第5-7个月：深入学习各科目的知识点，刷题巩固基础，解决重点难点问题。
第8-9个月：进行模拟考试，检验复习效果，分析错题和薄弱环节，进行有针对性的强化训练。
第10-11个月：全面回顾，进行模拟考试和真题训练，提升应试能力。
第12个月：进行模拟考试和真题训练，进行最后的复习和总结。
复习内容：
公共科目：英语、政治、数学等。
专业课程：根据个人选择的专业，制定相应的复习计划，包括核心课程和重点领域。
备考阶段：
阅读教材和参考书籍，理解知识点和概念。制定每日学习计划，合理安排时间，确保每科目都有足够的复习时间。做笔记和总结，帮助记忆和复习。刷题巩固知识点，提高解题能力。解决问题和难点，寻求帮助和讨论。
模拟考试：
定期进行全真模拟考试，模拟真实考试环境。分析模拟考试结果，找出问题和薄弱环节。针对性地进行强化训练，加强对错题和易错点的掌握。
调整计划：
根据模拟考试结果和自身情况，对计划进行调整和优化。适当调整复习进度和重点，确保复习的均衡和高效。保持良好的心态和健康的生活习惯，合理安排休息时间。请注意，这只是一个简单的示例，具体的考研计划应根据个人情况和需求进行调整和优化。同时，要根据自己的实际情况和能力合理安排时间和复习内容。
3.即将考研，做好考前准备 考前订房，一些酒店商家为了在考研过程中获得更大的利益，会特意的抬高房价，但是为了拥有一个更好的环境，建议大家不要嫌贵，还是订一个比较好点的酒店，因为考场安排的比较晚，建议还是找个靠谱点的机构帮忙预订，最好是预订有早餐的酒店，那样你会吃的比较放心，相对比较干净，为了在考场上更好的发挥，不要因为琐事分散自己注意力。
提前了解自己的考场，一般考研的考场都是在报考地的小学或初中，最好在考前熟悉一下从酒店到考场路线，切勿走错考场。考试前半个小时就可以入场，可以早去先平静一下心情。
调整作息和保持健康，合理安排作息时间，不要想着明天考试，今晚再熬到凌晨两三点，保证从充足的睡眠，避免熬夜，保持良好的饮食习惯，多摄入营养丰富的食物，适量运动保持自己的健康状态。
放松心态，考前紧张都是正常的，但也要学会放松自己的心态，可以进行一些适合自己放松的活动，比如听音乐，散步，打局游戏，以缓解压力和焦虑情绪。
打印好准考证，查看考试相关信息，仔细查看考试的具体要求和流程，了解考试地点，时间，准考证等信息，确保自己在考试当天做好准备。
科目时间表
12.24
考研科目
政治 8：30 — 11：30
英语 14：00 — 17：00
12.25
数学 8：30 — 11：30
专业课 14：00 — 17：00
博主心得
博主作为一个23年考研的人，经历了疫情封校，经历了天天排队做核酸，还经历了在考前一个星期得新冠的考研dog，最终还是坚持了下来，对于考研，有的时候没必要把自己逼得太紧，如果自己已经没有了状态，还要给自己喝鸡汤，硬要自己坚持，那样的学习效率，学习三个小时可能还没有自己的十分钟，考研过程中，不要害怕失败，也不会失败，考研的过程不仅仅是知识的灌输，更重要的是自己心路历程的博弈，众所周知，很多的考研学生在即将考研的前几个月选择了放弃，我认为这是非常不明智的行为，首先，不说已经准备了这么久，最后的临门一脚，不去勇敢的闯过去，你永远不知道自己有多强，博主在考试的前一天核酸检测还是阳性，当时怀着一种悲壮的心情，上考场犹如上战场，怀着一种慷慨赴死的心情，想着死也要死在这些磨人数学题，记不住的政治题，看不懂的英语长难句，令人头秃的专业课，现在回想起来感觉当时的自己确实有点搞笑，后来我也听说，像我这样的人也不在少数，很多在考场上坚持不住了，还有很多在考研的第一天晚上被送到了医院的急诊，非常的sad，这里也不建议大家这么做，如果身体有什么异样，一定要及时治疗，不要硬撑，毕竟身体是第一位。最后祝大家一研为定，一战成硕！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/471459665b946da9763958282d7eb977/" rel="bookmark">
			快速搭建WAMP（Windows、Apache、MySQL、PHP）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Apache、PHP 官网：https://www.xp.cn/下载Windows系统版本安装完成后打开在软件管理处下载Apache服务和MySQL服务安装完成后，返回首页一键启动，查看运行状态已启动 默认数据库、用户、密码均为root
查看设置，可以快速访问到PHP、MySQL的配置文件
查看apache配置，查看你的网站根目录
创建项目流程
第一步，到apache根目录www下创建项目名（可以创建很多项目，我新创建一个名为TEST的项目）
第二部，在这个项目里面写你的前端网页
第三步，到phpstudy配置你的网站，点击创建网站
基本配置
域名：随便取
第二域名（可填可不填写）：随便取
端口：http和https的协议区别是是否进行数字证书验证，可以自行去了解一下，这里配置8088端口（只要没有被占用的端口都行）
根目录：点击浏览选择你刚才创建的项目路径
创建环境：选择同步hosts
程序类型：勾选PHP
备注（可填可不填写）：随便取
高级配置
打开目录索引
网站首页可以自由选择你项目下的网页文件名字，（你打开这个项目出现的一个页面），也可以不配置
点击好会自动重启服务，然后点击管理，选择打开网站
因为刚才我打开了目录索引，且没有设置网站首页，打开后默认就会出现我这个目录下的所有文件
打开文件出现文件内容，PHP、Apache搭建成功（我的文档中phpinfo()函数会展示查看PHP的版本信息和扩展项等），接下来就是在这个www根目录下写你自己的网页代码咯。
MYSQL 将搭建的网页连接数据库
下载MySQL工具navicat（可以自行搜索navicat破解方法）
Navicat | 产品
下载完成之后连接在phpstudy安装的MySQL服务
这里所有的选项和phpstudy中MySQL配置保持一致
connection Name：连接的名字（随意）
Host：localhost
Port：3306
User Name：root
Password：root
测试连接（连接成功），点击OK就行了，就会在左侧列表看见你刚刚创建的项目名称了，项目里有系统自带的四个数据库
接下来就可以创建数据库、创建表和数据了，navicat的操作方法自行百度。我这里创建一个test1数据库和users表并插入一条数据。
在www文件下写一个php文件连接数据库，此函数用于连接数据库与前端网页
&lt;?php function connect() { $host = 'localhost';#和数据库的host保持一致 $username = 'root';#和phpstudy数据库的用户保持一致 $password = 'root';#和phpstudy数据库的密码保持一致 $dbname = 'test1';#和navicat创建的数据库名字保持一致 $port = '3306';#和phpstudy数据库配置文件中端口保持一致 $link = @mysqli_connect($host,$username,$password,$dbname,$port); if (!$link) { return "null"; die('连接错误 (' .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/471459665b946da9763958282d7eb977/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00ae20396301053c9b3d1191f8eac616/" rel="bookmark">
			【Linux】Ubuntu23.10&#43;VMWare17虚拟机的安装教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		欢迎来sobercq的博客喔，本期系列为【Linux】Ubuntu的安装教程
本期博客手把手带你从下载到安装我们Linux发行中的Ubuntu的教程，感谢观看，支持的可以给个赞哇。
Ubuntu
Ubuntu是Debian的一款衍生版，也是当今最受欢迎的免费操作系统。Ubuntu侧重于它在这个市场的应用，在服务器、云计算、甚至一些运行Ubuntu Linux的移动设备上很常见。Ubuntu是新手用户肯定爱不释手的一款操作系统。
一、VMware17虚拟机的下载 1.进入官网 下载 VMware Workstation Pro | CN
找到下列按钮
2.进入下载 双击打开文件，进入安装界面
3.安装步骤 选择下一步
接受协议后进入下一步 自行选择安装位置，进入下一步
取消勾选，进入下一步
继续进行下一步
选择好后安装
最后安装完后点击完成 二、下载Ubuntu的镜像 下载Ubuntu的方法有两种，一种是进入Ubuntu的官网Get Ubuntu | Download | Ubuntu，一种是进入清华大学镜像网站清华大学开源软件镜像站 | Tsinghua Open Source Mirror，那我这里只写进入清华大学镜像网站的方法（谁让官网我进不去呢）
进入网站后下拉找到
选择安装版本 在这里详细说下，Ubuntu的发行一年有两次，一次在04，一次在10月，所以其开头表示就是年份，后面是月份，我们截止目前为止选择23.10的就行了。
点击23.10进入到文件里，选择iso的镜像文件，进行下载
下载完成后我们进入安装教程 三、安装Ubuntu 点击创建虚拟机 下一步
选择iso光盘映像文件，进入下一步
下一步，更改安装信息
选择名称，更改文件安装位置
选择磁盘大小 选择硬件配置 完成安装，进入虚拟机界面，安装比较久耐心等待
选择中文简体 安装Ubuntu 选择汉语 选择我暂时不想连接到互联网 选择跳过
选择下一步
选择下一步 选择安装 ，选择时区
设置账号密码 选择主题 等待安装 最后就安装完啦 感谢观看本期教程，如果觉得对你有帮助，可以给个赞哇
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/323ea83c966adc521bb2e4e443a5c879/" rel="bookmark">
			IEEE802.11协议帧详解(转载)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、IEEE 802.11的帧格式 1.1 IEEE 802.11是什么？ 802.11是国际电工电子工程学会（IEEE）为无线局域网络制定的标准。目前在802.11的基础上开发出了802.11a、802.11b、802.11g、802.11n、802.11ac。并且为了保证802.11更加安全的工作，开发出了802.1x、802.11i等协议
1.2 IEEE 802.11连接网络的过程 使用802.11协议的设备连接到无线网络需要三步
扫描（获得网络信息）
认证（确认身份）
连接（确定连接、交换数据）
1.3 IEEE 802.11的帧格式分类 802.11的帧格式类似于以太网，但是更加复杂。并且为了解决无线网络的缺陷，需要添加额外的功能。所有802.11的帧分为三类：
管理帧
控制帧
数据帧
其中的管理帧最为复杂
1.4 IEEE 802.11通用帧格式 802.11的帧格式十分复杂，但是大体上遵循一种格式
1、frame control 位
Protocol位：协议版本有连个bit构成，用以显示该帧所使用的MAC版本：0 type与subtype位：类型与次类型位用来指定所使用的帧类型
TO DS与from DSbit：这两个bit用来指示帧的目的地是否为传输系统
Morefragments bit：这个功能类似与IP的更多片位。如果上层的封包经过MAC分段的处理，最后一个分段除外，其他片段均将此位置1。
Retrybit：重传帧位。任何重传的帧会将此bit置位1，以协助接收端剔除重复的帧。
Powermanagement bit：802.11网卡为了提高电池的使用时间，通常可以关闭网卡以节省电力。此位用来指定传送端在完成目前的基本帧交换之后是否进入省电模式，1代表工作站即将进入省电模式，而0则代表工作站一直保持清醒状态。基站发出去的帧该位必为0。
Moredata bit：为服务处于省电模式的工作站，基站会将这些由“传输系统”接收而来的帧加以暂存。基站如果设定此位，代表至少有一个帧待传送给休眠的工作站。
Protectedframe bit：之前该位为WEP bit。如果帧受到链路层安全协议的保护，该位为1.
Orderbit：帧和帧片段可以按序传送，不过发送端与接收端的MAC必须付出额外的代价。一旦进行“严格依序”传送，该位为1。
2、duration/ID位
有三种可能形式
1、 设定NAV：当第15bit被设定为0时，duration/ID位会用来设定NAV，数值代表目前所进行的传输预计使用介质多少微秒。
2、 免竞争期间所传送的帧：14bit为0,15bit为1.其他位为0。因此duration/ID位为32768，这个值被解读为NAV。它让没有收到Beacon信标帧的工作站，得以公告免竞争期间，以便将NAV更新为适当的数值，避免干扰到免竞争传输。
3、 PS-poll帧（省电-轮询）：14bit为1,15bit为1。移动工作站可以关闭天线以达到省电的目的。休眠的工作站必须定期醒来。确保不至于丢失任何帧，从休眠状态醒来的工作站和必须发送一个PS-poll帧，以便从基站取得以前暂存的帧。此外，醒来的工作站会在PS-poll帧中加入连接识别码（association ID，简称AID），以显示其所隶属的BSS，AID值介于1-2007之间。
3、address位
一个802.11帧最多可以包含四个地址位。这些地址为经过编号，因为随着帧类型的不同，这些位的作用也有所差异。
基本上，address代表接收端，address2代表传送端，address3代表被接收端拿过来的过滤地址。
在基础网络中，第三个地址位会被接收端用来判定该帧是否属于其所连接网络。
注意：802.11规定工作站应该忽略那些不属于相同BSSID的帧，但大多数产品并未正确实现BSSID过滤功能，还是会将收到的所有帧传送给上层协议。
802.11所使用的定位模式，乃是依循其他IEEE802网络所使用的格式，包括以太网。地址位为48bit。如果传送给实际介质的第一个bit为0，代表是单一工作站（单播地址）。1代表组播地址。如果全为1代表广播。
目的地址：代表最后的接收端，是负责将帧交付上层协议处理的工作站
源地址：代表传输的来源。
接收端地址：代表负责处理该帧的无线工作站。
如果是无线工作站，接收端地址即为目的地址。
如果帧的目的地址是与基站连接的以太网节点，接收端即为基站的无线界面，目的地址可能是连接到以太网的一台路由器。
传送端地址：代表将帧传送至无线介质的无线界面。传送端地址通常只用于无线桥接
4、basicservice set ID（BSSID）
在基础网络里，BSSID（基本服务集标识）是基站无线界面所使用的MAC地址。而对等（adhoc）网络则会产生一个随机的BSSID，并将universal/localbit设定为1，以防止与其他官方指定的MAC地址产生冲突。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/323ea83c966adc521bb2e4e443a5c879/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be2d091cc8549bbc421299454c59e8d8/" rel="bookmark">
			【汇编】Loop指令、段前缀
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、Loop指令1.1 Loop指令是什么？1.2 他的条件是什么？1.3 例子示例1示例2 1.4 要点总结 二、段前缀2.1 为什么要引入他2.2 对策 总结 前言 在计算机编程的世界里，了解底层的硬件操作是提升程序员能力的关键一步。汇编语言作为一种底层语言，直接操作计算机的硬件，其中的 LOOP 指令和段前缀是我们探讨的两个重要概念。LOOP 指令为我们提供了一种简洁的方式来实现循环，而段前缀则是用来指定数据存储位置的关键工具。在这篇文章中，我们将深入探讨这两个概念的作用和用法，以便读者更好地理解汇编语言的底层机制。
一、Loop指令 1.1 Loop指令是什么？ 在汇编语言中，LOOP 指令是一个循环控制指令，用来简化循环结构的编写。这个指令的作用就像你在做同样的事情一遍又一遍，而不必重复写相同的代码。
通俗解释：
假设你在写程序，需要做一件事情多次，比如打印一系列数字。使用 LOOP 就像是告诉计算机：“嘿，这里有一段代码，我要重复执行它多次。” 计算机就会明白，不用你一遍遍写相同的指令。
1.2 他的条件是什么？ 在高级语言中，我们知道，一个循环他肯定是需要一个条件的
那么我们的汇编语言也不例外，
他的条件如下：
CPU 执行loop指令时要进行的操作
①(cx)=(cx)-1；
②判断cx中的值
不为零则转至标号处执行程序
如果为零则向下执行。
要求
cx 中要提前存放循环次数，因为(cx)影响着
loop指令的执行结果
要定义一个标号
标号如下：
flag: ;you want to do other 其中flag就是标号，后面加冒号:
1.3 例子 示例1 想象你要打印数字1到10。使用 LOOP 你可以这样写：
MOV CX, 10 ; 将计数器CX设置为10
MY_LOOP: ; 这里放你要重复执行的代码，比如打印数字 LOOP MY_LOOP ; CX减1，如果不为0，跳回MY_LOOP 在这个例子中，LOOP 指令会检查 CX 寄存器的值，如果不为零，就会跳回标记为 MY_LOOP 的地方，重复执行那段代码。这样你就不需要写十次相同的代码，只需要告诉计算机循环的次数，它会帮你搞定。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/be2d091cc8549bbc421299454c59e8d8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f79ba4ad229b15123c3399c81492366b/" rel="bookmark">
			基于Unity3D引擎RPG游戏设计与开发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目 录 摘 要 I
Abstract II
引 言 1
1.相关技术 3
1.1 Unity基础界面 3
1.2 C#脚本编写 3
1.3 Unity脚本 3
1.4 Unity物理引擎 3
1.5 UGUI 3
1.6 Unity动画系统 4
1.7 本章小结 4
2. 系统分析 5
2.1游戏内容需求分析 5
2.2游戏流程需求分析 5
2.3游戏场景需求分析 5
2.4怪物系统需求分析 5
2.5UI界面需求分析 6
2.6人物动画需求分析 6
2.7本章小结 6
3. 系统设计 7
3.1游戏环境设计 7
3.1.1场景设计 7
3.1.2角色设计 7
3.1.3音乐设计 7
3.2战斗系统设计 8
3.2.1巡逻系统 8
3.2.2战斗检测 10
3.2.3怪物的攻击与搜索 10
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f79ba4ad229b15123c3399c81492366b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e3e1bab540bc1fcadbac776f4b5c911/" rel="bookmark">
			在linux下如何使用yum命令查看安装了哪些软件包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Linux系统下yum命令查看安装了哪些软件包：
yum list installed //列出所有已安装的软件包 yum针对软件包操作常用命令 1. 使用yum查找软件包 命令：
yum search 2. 列出所有可安装的软件包 命令：
yum list 3. 列出所有可更新的软件包 命令：
yum list updates 4. 列出所有已安装的软件包 命令：
yum list installed 5. 列出所有已安装但不在Yum Repository内的软件包 命令：
yum list extras 6. 使用yum获取软件包信息 命令：
yum info 7. 列出所有可更新的软件包信息 命令：
yum info updates 8. 列出所有已安装的软件包信息 命令：
yum info installed 9. 列出软件包提供哪些文件 命令：
yum provides 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15dab3013e2692ac9df11b469bd0ddca/" rel="bookmark">
			回 溯 法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、（what？）
二、（why？）
三、（how？）
四、典型例题分析：
例题1：大卖场购物车2——0-1背包问题
问题分析：
算法设计：
图解算法：
伪代码：
double Bound(int i)//计算上界（即已装入物品价值+剩余物品的总价值） { int rp=0; //剩余物品为第i~n种物品 while(i&lt;=n)//依次计算剩余物品的价值 { rp+=v[i]; i++; } return cp+rp;//返回上界 } void Backtrack(int t) //t表示当前扩展结点在第t层 { if(t&gt;n) //已经到达叶子结点 { for(j=1;j&lt;=n;j++) { bestx[j]=x[j]; } bestp=cp; //保存当前最优解 return ; } if(cw+w[t]&lt;=W) //如果满足约束条件则搜索左子树 { x[t]=1; cw+=w[t]; cp+=v[t]; Backtrack(t+1); cw-=w[t]; cp-=v[t]; } if(Bound(t+1)&gt;bestp) //如果满足限界条件则搜索右子树 { x[t]=0; Backtrack(t+1); } } 完整代码：
#include&lt;iostream&gt; #include&lt;string&gt; #include&lt;algorithm&gt; #define M 105 using namespace std; int i,j,n,W; //n表示n个物品，W表示购物车的容量 double w[M],v[M];//w[i] 表示第i个物品的重量，v[i] 表示第i个物品的价值 bool x[M]; //x[i]表示第i个物品是否放入购物车 double cw; //当前重量 double cp;//当前价值 double bestp;//当前最优价值 bool bestx[M]; //当前最优解 double Bound(int i)//计算上界（即已装入物品价值，剩余物品的总价值） { int rp=0;//剩余物品为第i~n种物品 while(i&lt;=n)//一次计算剩余物品的价值 { rp+=v[i]; i++; } return cp+rp;//返回上界 } void Backtrack(int t)//t表示当前扩展点在第t层 { if(t&gt;n)//已经到达叶子结点 { for(j=1;j&lt;=n;j++) { bestx[j]=x[j]; } bestp=cp;//保存当前最优解 return ; } if(cw+w[i]&lt;=W)//如果满足条件约束搜索左子树 { x[t]=1; cw+=w[t]; cp+=v[t]; Backtrack(t+1); cw-=w[t]; cp-=v[t]; } if(Bound(t+1)&gt;bestp)//如果满足限界条件搜索右子树 { x[t]=0; Backtrack(t+1); } } void Knapsack(double W,int n) { //初始化 cw=0; cp=0; bestp=0; double sumw=0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/15dab3013e2692ac9df11b469bd0ddca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c32fbfd93c6453cf72e1b7a0a8ea5742/" rel="bookmark">
			VUE基础入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、VUE入门 1、环境准备 2、预备知识 3、实战演练 vue官网
Vue.js - 渐进式 JavaScript 框架 | Vue.js
基础语法，vue2和vue3区别不大，但是后面路由会有很大区别。
前期基础语法，我们通过链接的方式使用vue，后面会用npm进行安装。
（1）创建项目目录 电脑任意位置
（2）使用VScode打开文件 （3）新建html文件 打一个 ！模板自动生成
通过 CDN 使用 Vue
&lt;script src="https://unpkg.com/vue@3/dist/vue.esm-browser.js"&gt;&lt;/script&gt;
或者
&lt;script src="https://unpkg.com/vue@3"&gt;&lt;/script&gt;
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src="https://unpkg.com/vue@3"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; （4）实例1-基本用法练习 &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src="https://unpkg.com/vue@3"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c32fbfd93c6453cf72e1b7a0a8ea5742/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd019987548496b85d134667fe96e9b9/" rel="bookmark">
			微信小程序开发教程：nodejs后台，将Excel数据导入Mysql数据库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开发带有后台的小程序时，数据很多的时候，就需要将数据批量导入数据库。
我在node端写了如下前端代码，以便导入EXCEL表格：
&lt;div class="col-md-6 text-right"&gt; &lt;a href="#" class="btn btn-primary" id="addBtnExcel"&gt;导入数据&lt;/a&gt; &lt;/div&gt; &lt;!-- 提交表格数据 --&gt; &lt;div class="dialog isUploadExcel"&gt;&lt;/div&gt; &lt;div class="panel dialog-wrap isUploadExcel"&gt; &lt;div class="panel-heading"&gt; &lt;h3 class="panel-title"&gt;上传数据（功能暂未实现）&lt;/h3&gt; &lt;div class="right"&gt; &lt;button class="close"&gt;&lt;i class="lnr lnr-cross"&gt;&lt;/i&gt;&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;form method="POST" action="/uploadExcel" enctype="multipart/form-data" class="demo-button1" &gt; &lt;button&gt;&lt;input type="file" name="excel_file" id="excel_file" required/&gt;&lt;/button&gt;&lt;br/&gt;&lt;br/&gt; &lt;button class="btn btn-primary" type="submit" value="上传"&gt;提交数据&lt;/button&gt; &lt;/form&gt; &lt;/div&gt; &lt;!-- 提交表格数据 结束 --&gt; 接下来，开始写上传excel的API接口文件：
var express = require('express'); var router = express.Router(); var multer = require('multer'); var upload = multer({ dest: 'uploads/' }); var xlsx = require('xlsx'); var db = require('.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bd019987548496b85d134667fe96e9b9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a2d24fad3a014b78808dc9b8ee0150b/" rel="bookmark">
			服务器便宜的多少钱？哪家的云服务器便宜？附多年优惠购买链接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		比较不同云服务商的价格，找到最适合自己的云服务商 在如今云计算飞速发展的时代，选择合适的云服务商显得尤为重要。各大云服务商纷纷推出各种优惠活动和不同套餐，使得我们选择的难度更大了。要想找到最适合自己的云服务商，我们首先需要比较不同云服务商的价格。只有了解了各个云服务商的价格体系，我们才能选择出最具性价比的服务商。建议购买腾讯云，价格低，续费也划算！
腾讯云88元/年服务器配置查看 https://tengxun.mian100.cn
购买长期服务以享受更多优惠 除了比较价格，购买长期服务也是节省费用的一个好办法。许多云服务商都提供了长期使用的优惠政策，例如像腾讯云、阿里云等云服务商都会给予购买一年或多年服务的用户一定的折扣，这样不仅能够享受到更多的优惠，还能够保证服务的连续性和稳定性。
腾讯云双十一领9999代金券 https://1111.mian100.cn
腾讯云新用户领2860代金券 https://xinke.mian100.cn
腾讯云3年时长、5年时长优惠服务器尽享新用户优惠 https://5nian.mian100.cn
选择适合自己的配置，根据业务需求购买 在选择云服务商的过程中，我们还需要根据自己的业务需求选择适合自己的配置。不同的业务对硬件配置的需求是不同的，我们要根据自己的业务情况来选择适合的配置。如果我们购买的配置过高，可能会造成资源浪费，而如果购买的配置过低，则可能会影响到我们的业务运行。因此，了解自己的业务需求并根据需求购买配置是非常重要的。
参加云服务商的优惠活动以节省费用 除了购买长期服务以享受优惠外，我们还可以参加云服务商的优惠活动以节省费用。云服务商经常会推出一些折扣活动、满减活动等，只要我们及时关注并参与其中，就能够在购买云服务的同时节省一定的费用。
腾讯云在2023年10月23日开启了双11活动，推出了一些优惠的云服务器 最近，腾讯云在2023年10月23日开启了双11活动，推出了一些优惠的云服务器。这些优惠的云服务器不仅价格相对较低，而且还能够提供稳定的性能和良好的服务质量。对于有购买需求的用户来说，这是一个非常好的机会，可以在双11活动期间购买到性价比高的云服务器。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32ccbbe654d85375c838ea194d16cad5/" rel="bookmark">
			Spring Cloud与Spring Cloud Alibaba怎么正确引入依赖版本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.Spring Cloud与Spring Cloud Alibaba与Springboot各版本的依赖关系 我们可以去springcloud alibaba的github仓库中的说明中查找到三个依赖版本的对应关系：
版本说明 · alibaba/spring-cloud-alibaba Wiki · GitHub
二.通过BOM对Spring Cloud与Spring Cloud Alibaba各组件的依赖版本进行控制 【1】什么是BOM呢？
BOM（Bill of Materials）是由Maven提供的功能,它通过定义一整套相互兼容的jar包版本集合：Maven BOM！拿来吧你 - 掘金
【2】SpirngCloud官方文档的内容：
【3】SpringCloudAlibaba官方文档的内容：
【4】简单说意思就是说我们在父项目的dependencyManagement引入了上述的依赖后在子项目中书写其各组件的依赖就不用去关心版本的问题。
父项目中：
&lt;!--统一管理依赖版本--&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;!-- springCloud --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;Hoxton.SR9&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;!--springCloudAlibaba --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt; &lt;version&gt;2.2.6.RELEASE&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencyManagement&gt; &lt;type&gt;pom&lt;/type&gt;：这里指定了依赖项的类型为"pom"，表示引入的是一个POM文件，通常用于管理其他依赖项的版本号。
&lt;scope&gt;import&lt;/scope&gt;：这里指定了依赖项的作用域为"import"，表示这个依赖项主要用于进行版本管理，不会实际参与编译和打包。
这样父子项目中与Spring Cloud与Spring Cloud Alibaba相关的组件依赖就可以省去版本的书写：
例如原先：
&lt;!-- openfeign远程连接--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt; &lt;version&gt;2.2.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; 现在：
&lt;!-- openfeign远程连接--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt; &lt;/dependency&gt; 这样就可以统一管理和控制Spring Cloud框架中各个模块的版本号。这样做有助于避免版本冲突，简化项目配置，并提高开发效率，不用再去官网查询版本了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/32ccbbe654d85375c838ea194d16cad5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b81c3a9e7018e8ff1d66b39f27f9420c/" rel="bookmark">
			基于协作mimo系统的RM编译码误码率matlab仿真,对比硬判决译码和软判决译码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.算法运行效果图预览
2.算法运行软件版本
3.部分核心程序
4.算法理论概述
5.算法完整程序工程
1.算法运行效果图预览 2.算法运行软件版本 matlab2022a
3.部分核心程序 ..................................................................... while(Err &lt;= TL) k Err Num = Num + 1; %产生数据 K = min(K1,K2); Signal0 = round(rand(1,K)); Signal = [Signal0,zeros(1,K1-K2)]; %***************************************************************** %RM编码 Signal_RM_S2D = func_Encode(Signal,V1); %调制 RM_mod_S2D = modulate(mods,Signal_RM_S2D); %过信道 RM_Noise_S2D = RM_mod_S2D + sqrt(2*N01)*randn(size(RM_mod_S2D)); %***************************************************************** %中继部分 RM_demod_S2R = demodulate(demods,RM_Noise_S2D); Bhat_S2R = func_Decode_ML_hard(RM_demod_S2R,r+1,m,V1,N1,K1,I1); %RM编码 Signal_RM_S2R = func_Encode(Bhat_S2R(1:K),V2); %调制 RM_mod_S2R = modulate(mods,Signal_RM_S2R); %过信道 RM_Noise_S2R = RM_mod_S2R + sqrt(2*N03)*randn(size(RM_mod_S2R)); %***************************************************************** %解调 RM_demod_S2D = demodulate(demods,[RM_Noise_S2D,RM_Noise_S2R]); LEN = length(RM_demod_S2D); %RM译码 Bhat_S2D1 = func_Decode_ML_hard(RM_demod_S2D(1:LEN/2),r+1,m,V1,N1,K1,I1); Bhat_S2D2 = func_Decode_ML_hard(RM_demod_S2D(LEN/2+1:LEN),r,m,V2,N2,K2,I2); %计算误码率 Err = Err + min([sum(xor(Bhat_S2D1(1:K),Signal0)),sum(xor(Bhat_S2D2(1:K),Signal0))]); end Errs(k) = Err/Num/length(Signal); end figure semilogy(SNR,Errs,'b-o'); grid on; xlabel('SNR'); ylabel('Bit error'); save r0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b81c3a9e7018e8ff1d66b39f27f9420c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/369311f3acd1f0def4e1e95c1ccc02e2/" rel="bookmark">
			python --等分列表(数组)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 def split_list(lst, num=2): ''' 等分列表 @params lst --&gt; 要分的列表; @params num --&gt; 要等分的数量; ''' length = len(lst) split_length = length // num remainder = length % num result = [] index = 0 for _ in range(num): sublist_length = split_length + (1 if remainder &gt; 0 else 0) sublist = lst[index:index+sublist_length] result.append(sublist) index += sublist_length remainder -= 1 return result a = (1, 2,3,4,5,6,7,8,9, 10) print(split_list(a, num=3)) 结果: [(1, 2, 3, 4), (5, 6, 7), (8, 9, 10)] 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a05b87d2fd19610ec5fb2ef4eabbbbd/" rel="bookmark">
			codemirror与实现c&#43;&#43;/c在线编译器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		codemirror 下载
codemirror js版
demo：
所需文件
//需要codemirror.css , anbiance.css (这里的和下载后的文件位置不一样) &lt;link href="../../../css/plugins/codemirror/codemirror.css" rel="stylesheet"&gt; &lt;link href="../../../css/plugins/codemirror/ambiance.css" rel="stylesheet"&gt; // &lt;script src="../../../js/plugins/codemirror/mode/javascript.js"&gt;&lt;/script&gt; // 实现c++所需的js文件 clike.js &lt;script src="../../../js/plugins/codemirror/mode/clike.js"&gt;&lt;/script&gt; 初始化代码框
&lt;textarea id="code1" style="display: none;"&gt;&lt;/textarea&gt; 更多设置看：
语言(c++/python…)的设置：
https://codemirror.net/5/mode/
config的设置：
https://codemirror.net/5/doc/manual.html#config
//设置config var editor_one; $(document).ready(function () { editor_one = CodeMirror.fromTextArea(document.getElementById("code1"), { lineNumbers: true, //行号 matchBrackets: true, styleActiveLine: true, theme: "ambiance", mode: "text/x-c++src" }); editor_one.setValue() }); 简单样式如下：
c编译的实现 需要gcc/g++环境变量：
mingw64下载：离线包下载解压即可添加到环境变量https://sourceforge.net/projects/mingw-w64/files/Toolchains%20targetting%20Win64/Personal%20Builds/mingw-builds/
提交函数
async function submit(e){ var code = editor_one.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1a05b87d2fd19610ec5fb2ef4eabbbbd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8a0b2136bb32b97ddcbb49f2348de7a/" rel="bookmark">
			.gitignore 文件——如何在 Git 中忽略文件和文件夹详细教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 什么是 .gitignore 文件？.gitignore 文件是用来做什么的？如何创建一个 .gitignore 文件？在 .gitignore 文件中应包括什么？如何在 Git 中忽略一个文件和文件夹如何忽略以前提交的文件 什么是 .gitignore 文件？.gitignore 文件是用来做什么的？ 在任何当前工作的 Git 仓库中，每个文件都是这样的：
追踪的（tracked）- 这些是 Git 所知道的所有文件或目录。这些是新添加（用 git add 添加）和提交（用 git commit 提交）到主仓库的文件和目录。未被追踪的（untracked） - 这些是在工作目录中创建的，但还没有被暂存（或用 git add 命令添加）的任何新文件或目录。被忽略的（ignored） - 这些是 Git 知道的要全部排除、忽略或在 Git 仓库中不需要注意的所有文件或目录。本质上，这是一种告诉 Git 哪些未被追踪的文件应该保持不被追踪并且永远不会被提交的方法。 所有被忽略的文件都会被保存在一个 .gitignore 文件中。
.gitignore 文件是一个纯文本文件，包含了项目中所有指定的文件和文件夹的列表，这些文件和文件夹是 Git 应该忽略和不追踪的。
在 .gitignore 中，你可以通过提及特定文件或文件夹的名称或模式来告诉 Git 只忽略一个文件或一个文件夹。你也可以用同样的方法告诉 Git 忽略多个文件或文件夹。
如何创建一个 .gitignore 文件？ 通常，一个 .gitignore 文件会被放在仓库的根目录下。根目录也被称为父目录和当前工作目录。根目录包含了组成项目的所有文件和其他文件夹。
也就是说，你可以把它放在版本库的任何文件夹中。你甚至可以有多个 .gitignore 文件。
要在基于 Unix 的系统（如 macOS 或 Linux）上用命令行创建一个 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c8a0b2136bb32b97ddcbb49f2348de7a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55a9fc96e22fd77363d5c09137db68ec/" rel="bookmark">
			Postman：API测试之Postman使用完全指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Postman是一个可扩展的API开发和测试协同平台工具，可以快速集成到CI/CD管道中。旨在简化测试和开发中的API工作流。
Postman工具有Chrome扩展和独立客户端，推荐安装独立客户端。
Postman有个workspace的概念，workspace分personal和team类型。Personal workspace只能自己查看的API，Team workspace可添加成员和设置成员权限，成员之间可共同管理API。
当然我个人使用一般是不登录的，因为登录之后会自动将你的测试历史数据保存到账户里，你可以登陆网页端进行查看。
因为API的很多数据是很敏感的，有的含有Token，或者就是一些私密信息，虽然Postman自己也强调说这样很安全，不会私下窥探用户的信息之类的，但是呢还是至少做一点有效的防范吧，自己不上传，因为网络并没有绝对的安全。
所以我每次测试之后会将数据（Case）保存在本地，下次使用或者换设备的情况下将数据拷贝过来又可以继续使用了。
下面正式开始介绍如何使用Postman吧。
1. 为什么选择Postman 选择使用Postman的原因如下:
简单易用 - 要使用Postman，你只需登录自己的账户，只要在电脑上安装了Postman应用程序，就可以方便地随时随地访问文件。
使用集合 - Postman允许用户为他们的API调用创建集合。每个集合可以创建子文件夹和多个请求。这有助于组织测试结构。
多人协作 - 可以导入或导出集合和环境，从而方便共享文件。直接使用链接还可以用于共享集合。
创建环境 - 创建多个环境有助于减少测试重复（DEV/QA/STG/UAT/PROD），因为可以为不同的环境使用相同的集合。这是参数化发生的地方，将在后续介绍。
创建测试 - 测试检查点（如验证HTTP响应状态是否成功）可以添加到每个API调用中，这有助于确保测试覆盖率。
自动化测试 - 通过使用集合Runner或Newman，可以在多个迭代中运行测试，节省了重复测试的时间。
调试 - Postman控制台有助于检查已检索到的数据，从而易于调试测试。
持续集成- 通过其支持持续集成的能力，可以维护开发实践。
2. 如何下载安装Postman Step1） 去官网下载进行安装
官网主页：https://www.postman.com/downloads/， 下载所需版本进行安装即可。
Step2） 登录
安装完成之后会要求你必须登录才能使用，没有账号可以进行注册，注册是免费的。（也可使用Google账号，不过基本不能登录，你懂的）
Step3）在Workspace选择你要使用的工具并点击“Save My Preferences”保存。
Step4）你将看到启动后的页面如下
3. 如何使用Postman 下图是Postman的工作区间，各个模块功能的介绍如下：
New，在这里创建新的请求、集合或环境；还可以创建更高级的文档、Mock Server和Monitor以及API。Import，这用于导入集合或环境。有一些选项，例如从文件，文件夹导入，链接或粘贴原始文本。Runner，可以通过Collection Runner执行自动化测试。后续介绍。Open New，打开一个新的标签，Postman窗口或Runner窗口。My Workspace，可以单独或以团队的形式创建新的工作区。Invite，通过邀请团队成员在工作空间上进行协同工作。History，所有的历史记录，这样可以很容易地跟踪你所做的操作。Collections，通过创建集合来组织你的测试套件。每个集合可能有子文件夹和多个请求。请求或文件夹也可以被复制。Request tab，这将显示您正在处理的请求的标题。默认对于没有标题的请求会显示“Untitled Request”。HTTP Request，单击它将显示不同请求的下拉列表，例如：GET，POST，COPY，DELETE等。在测试中，最常用的请求是GET和POST。Request URL ，也称为端点，显示API的URL。Save ，如果对请求进行了更改，必须单击save，这样新更改才不会丢失或覆盖。Params ，在这里将编写请求所需的参数，比如Key - Value。Authorization ，为了访问api，需要适当的授权。它可以是Username、Password、Token等形式。Headers ，请求头信息。Body ，请求体信息，一般在POST中才会使用到。Pre-request Script ，请求之前 先执行脚本，使用设置环境的预请求脚本来确保在正确的环境中运行测试。Tests ，这些脚本是在请求期间执行的。进行测试非常重要，因为它设置检查点来验证响应状态是否正常、检索的数据是否符合预期以及其他测试。Settings ，最新版本的有设置，一般用不到。 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/55a9fc96e22fd77363d5c09137db68ec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5199fbd84350e7522d7571419a25dca7/" rel="bookmark">
			文件包含漏洞（DVWA靶场文件包含漏洞详解）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、文件包含漏洞形成原因 开发人员为了使代码更灵活,会将被包含的文件设置为变量,用来进行动态调用,从而导致客户端可以恶意调用一个恶意文件,造成文件包含漏洞。
二、文件包含漏洞的分类 远程文件包含（RFI，Remote File Inclusion）: 当 Web 应用程序下载并执行远程文件时，会导致远程文件包含，这些远程文件通常以 HTTP 或 FTP URI 的形式获取，作为Web 应用程序的用户提供的参数。
本地文件包含（LFI，Local File Inclusion）：本地文件包含类似于远程文件包含，本地文件包含仅能包括本地文件，即当前服务器上的文件以供执行。
文件包含漏洞用到的函数：
require:找不到被包含的文件，报错，并且停止运行脚本。
include:找不到被包含的文件,只会报错，但会继续运行脚本。
require_once:与require类似,区别在于当重复调用同一文件时,程序只调用一次。
include_once:与include类似,区别在于当重复调用同一文件时,程序只调用一次。
三、PHP包含日志文件 拦截后修改：
查看日志文件已记录此条信息
浏览器中运行此日志文件，即可执行插入的PHP代码。
注意：若已经上传了一句话代码的文件，就可以通过浏览器解析了。
常见日志文件位置：
四、DVWA靶场文件包含漏洞(File Inclusion) 选择“File Inclusion”漏洞后出现错误提示：The PHP function allow_url_include is not enabled.
解决方法：到php.ini文件中将allow_url_include=off,修改为on
选择到当前使用的PHP版本就能打开其ｐｈｐ．ｉｎｉ文件。
查找：allow_url_include
修改为allow_url_include=on
１．等级low 点一下file1路径就变成了：http://192.168.182.130/vulnerabilities/fi/?page=file1.php
点击file2，file3，发现变化的就是page（页）这个参数
发现他直接传一个page这个参数没有做任何的过滤，这里就大概猜测可能出现问题。喂什么吃什么，能不出毛病嘛。
查看源代码分析：
&lt;?php // The page we wish to display $file = $_GET[ 'page' ]; ?&gt; 如１：给百度地址，直接进入百度
如２：给本地文件地址，直接显示此文件内容
如３：给远程一句话木马地址，可用中国菜刀连接木马
第一步：在ｋａｌｉ中编写一句话木马文件，ａａ．ｐｈｐ
第二步：在ａａ．ｐｈｐ路径下打开终端程序，执行：python3 -m http.server 80命令起http服务
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5199fbd84350e7522d7571419a25dca7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81bdc879e9f16219adf8bd7e16b9126d/" rel="bookmark">
			mybatis-plus分页查询（page的使用）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 01 前置的准备 配置分页的拦截器，Mybatis-plus默认是不开启分页查询的
/** *这个类用于配置MybatisPlus的分页查询器 */ @Configuration public class MyBatisPlusConfig { // MybatisPlus的配置 @Bean public MybatisPlusInterceptor mybatisPlusInterceptor() { MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor(); // 在拦截器中加入了一个分页的拦截器 interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL)); return interceptor; } } 02 基础的使用 测试类
public class Category { @TableId private Long categoryId; private String categoryName; private String categoryPicture1; private String categoryPicture2; } //分页查询的配置和使用 //前一个是设置第几页，后一个是设置一页多少数据 Page page=new Page(2,3); Page&lt;Category&gt; list=iCategoryService.page(page); System.out.println(list.getTotal());//查询数据总数 System.out.println(list.getRecords());//当前页的数据 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/305445e081b7164b388460d47cf2d9a1/" rel="bookmark">
			洛谷 P1181 数列分段 Section I
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 【题目链接】 洛谷 P1181 数列分段 Section I
【题目考点】 1. 贪心 【解题思路】 1. 贪心选择性质的证明 贪心选择：每次从第1个未被选择的数字开始，选择尽量长的满足加和小于等于m的子段
证明：
证明：
记整个数字序列为数组a，a[i]表示数字序列的第i个数字。
证明：存在最优解包含从第1个数字开始的尽量长的满足加和小于等于m的子段
假设按照上述方法选择的子段为a[1]~a[g]，“子段尽量长”指的是如果把a[g+1]加入到子段中，整个子段的加和就会大于m。因此选择的子段不能更长。
如果选择的第一个子段更短也可以得到最优解，使用反证法：
假设：最优解不包含贪心选择，存在最优解，第一个子段为a[1]~a[k]，满足k&lt;g。自然a[k+1]~a[g]不属于第一个子段。
把a[k+1]~a[g]从其它子段转到第一个子段，使第一个子段是贪心选择为a[1]~a[g]。其它子段去掉a[k+1]~a[g]的元素后，可能会使子段数量减少，可能子段中元素减少，那么该子段的加和减少或不变（因为每个元素都是非负数），不影响“每个子段加和小于等于m”的要求，子段数量不变。要求的是最少子段数量，当前已经是最优解，子段数量不变或减少，该分段仍然是最优解。该最优解包含了贪心选择，与假设相悖，原命题得证。证明：在前k次进行贪心选择后，证明最优解包含第k+1次的贪心选择。
证明方法同上，略。 2. 具体做法 顺序遍历数组，对于每个元素
如果当前子段在添加该元素后，子段和不超过m，将该元素添加进当前子段，子段和增加该元素值否则该元素自己作为下一个子段的第一个元素，子段数量增加1。
最后输出子段数 【题解代码】 解法1：贪心 #include&lt;bits/stdc++.h&gt; using namespace std; #define N 100005 int n, m, a[N]; int main() { cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; ++i) cin &gt;&gt; a[i]; int sum = 0, ct = 1; for(int i = 1; i &lt;= n; ++i) { if(sum+a[i] &lt;= m) sum += a[i]; else { ct++; sum = a[i];	} } cout &lt;&lt; ct; return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/950bb3e90f774d164a34f4cec0f93eb6/" rel="bookmark">
			小程序css弹窗动画
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;view class="popupView" style="top:{{height+35}}px" bindtap="changePopupView"&gt;
&lt;!-- 遮罩区域，点击隐藏弹出层 --&gt;
&lt;view class="close" bindtap="changePopupView"&gt;&lt;/view&gt;
&lt;!-- 内容区 --&gt;
&lt;view class="content" bindtap="onClose"&gt;
&lt;view wx:for="{{ data }}" wx:key="index"&gt;
&lt;view class="text {{ index === data.length - 1 ? 'last-text' : '' }}" data-id="{{ item.id }}" bindtap="priceQuotes"&gt;{{ item.name }}&lt;/view&gt;
&lt;/view&gt;
&lt;/view&gt;
&lt;/view&gt;
.popupView .content{
background-color: #FFF;
border-radius: 0 0 15px 15px;
max-height: 190px;
padding: 5rpx 32rpx;
overflow: auto;
color: #333333;
font-size: 28rpx;
border-top:1rpx solid #efebeb;
transform-origin: top; /* 设置动画的变换原点为顶部 */
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/950bb3e90f774d164a34f4cec0f93eb6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8cc0d5f2a860a4db0247d184c71a2bf2/" rel="bookmark">
			oneLink机卡分离如何解绑?,区域限制变更?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通过自动化脚本，可以实现一系列自动化操作，包括机卡分离复机、解绑、绑定首话单和绑定TAC等功能。此外，还可以进行区域限制变更,绑定新区域或首话单。这些功能可以无缝通过API方式集成到自己的平台中，并支持多账号管理。这样一来，我们无需频繁切换oneLink账号进行操作，可以大幅提升工作效率，预计可提高90%的工作效率。
加q交流: 1308137826
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ad22b7f9bb1ea3104455be712cf7913/" rel="bookmark">
			element的form表单校验数组处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		element的form表单校验数组处理
出现场景
form表单里有需要校验的是表格，数据是数组
解决思路
１添加隐藏的input，校验使用该隐藏的input绑定的校验，当表格数据有值后，给input赋值取消校验．
&lt;el-row :gutter="40"&gt; &lt;el-col :span="24"&gt; &lt;el-form-item label="测试表格" prop="selectSum"&gt; &lt;!-- 隐藏的input --&gt; &lt;el-input v-model="ruleForm.selectSum" type="hidden" class="LawTableInput"&gt;&lt;/el-input&gt; &lt;el-row&gt; &lt;!-- 表格 --&gt; &lt;AddPeopleReTable :orglawTable="peopleList" @getLawTabel="getLawTabel" :peopleData="peopleData"&gt;&lt;/AddPeopleReTable&gt; &lt;/el-row&gt; &lt;/el-form-item&gt; &lt;/el-col&gt; &lt;/el-row&gt; 扩展知识
type=“hidden”
定义隐藏字段，隐藏字段对于用户是不可见的。隐藏字段常常存储默认值，或者由 JavaScript 改变它们的值
２校验规则
rules: { selectSum: [ { required: true, message: '请选择测试表格', trigger: 'change' } ], } ３input赋值
if (this.peopleList &amp;&amp; this.peopleList.length &gt; 0) { this.ruleForm.selectSum = 999999; } else { this.ruleForm.selectSum = null; } ４加了隐藏的input导致增加按钮样式不对，修改隐藏的input
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2ad22b7f9bb1ea3104455be712cf7913/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b444d79a23f44eec255cf34dd699039/" rel="bookmark">
			信息学奥赛一本通 1435：【例题3】曲线 | 洛谷 洛谷 P1883 函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【题目链接】 ybt 1435：【例题3】曲线
洛谷 P1883 函数
【题目考点】 1. 三分 【解题思路】 每个 S i ( x ) S_i(x) Si​(x)是一个二次函数， F ( x ) = m a x ( S i ( x ) ) F(x) = max(S_i(x)) F(x)=max(Si​(x))，即为所有二次函数当自变量为x时的所有函数值的最大值。
已知 a ≥ 0 a \ge 0 a≥0，所以所有的二次函数都是开口向上的，为下凸函数。
首先要证明 F ( x ) F(x) F(x)在定义域为[0, 1000]的范围内是下凸函数（凸函数定义）
已知f(x),g(x)为下凸函数，证明h(x)=max(f(x),g(x))是一个下凸函数。
证明:
根据凸函数的定义，对于任意的 0 ≤ α ≤ 1 0\leq\alpha\leq1 0≤α≤1，定义域内的任意 x 1 , x 2 x1, x2 x1,x2，总有
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3b444d79a23f44eec255cf34dd699039/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34d19e9bedaedbba67d2d93df6f603a2/" rel="bookmark">
			十全十美源码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【十全十美】指标设计原理：核心逻辑是共振。
1个形态指标+3个量化模型+6个传统指标。
(MACD,KDJ,RSI,LWR,BBI,MTM),这十个模型都显示市场趋势处于上行趋势的时候,也就是十维共振向上的时候,代表着机会来临，可以把握;
反之，则代表风险来临,应该规避。
这种逻辑也暗合投资之道【顺势而为】的交易真言。
什么是《十全十美》1个趋势、3个量化、6个指标？
一个趋势指标：
1、趋势转为上行趋势，经常会出现一些典型的形态。
2、包括放量突破、阳吞阴、黄金坑形态等等，这些经典的趋势转多的形态汇总。
三个量化模型 ：
1、多空博弈量化模型：多头占优优势。
2、龙腾四海量化模型：龙腾线50以上。
3、量能突破量化模型：成交量持续放量。
六个经典技术指标 ：
1、MACD、KDJ、RSI、LWR、BBI、MTM6个指标。
2、还有流通市值、主力控盘度等指标。
指标图形信号意义：
1、黄色代表三维量化模型共振.
2、紫色代表量化模型和技术指标的九维共振
3、钱袋子代表十维共振
指标使用口诀：
加仓信号，机会来临出现钱袋子信号，十维共振信号
谨慎减仓信号，紫色方块信号消失，十维共振结束
清仓信号，黄色方块信号消失，三维量化共振结束
指标操盘秘籍：
1、指数低位启动，或者上行趋势良好，积极参与；
2、如果指数处于高位，从高位往下走，呈现下跌趋势，下跌趋势的反抽行情，尽量回避，行情难持续。
3、符合当日主线行情的优先考虑。
4、同一个概念或者行业，选股出现两个以上标的的时候，这种属于共振效应，可以优先考虑。
5、中小市值，基本面优秀、业绩稳定的优先考虑。
6、当日盘中热点优先考虑，一般就是指板块涨停个股最多的板块！
DRAWGBK(C&gt;1,RGB(0,0,0),RGB(1,1,1),1,0,0); DIFF:=EMA(CLOSE,8)-EMA(CLOSE,13); DEA:=EMA(DIFF,5); A1:STICKLINE(DIFF&gt;DEA,5,10,2,1),COLORRED; STICKLINE(DIFF&lt;DEA,5,10,2,1),COLORGREEN; 十全十美1:=(CLOSE-LLV(LOW,8))/(HHV(HIGH,8)-LLV(LOW,8))*100; K:=SMA(十全十美1,3,1); D:=SMA(K,3,1); A2:STICKLINE(K&gt;D,10,15,2,1),COLORRED; STICKLINE(K&lt;D,10,15,2,1),COLORGREEN; LC:=REF(CLOSE,1); CBA1:=(SMA(MAX(CLOSE-LC,0),5,1))/(SMA(ABS(CLOSE-LC),5,1))*100; CBA2:=(SMA(MAX(CLOSE-LC,0),13,1))/(SMA(ABS(CLOSE-LC),13,1))*100; A3:STICKLINE(CBA1&gt;CBA2,15,20,2,1),COLORRED; STICKLINE(CBA1&lt;CBA2,15,20,2,1),COLORGREEN; 十全十美:=-(HHV(HIGH,13)-CLOSE)/(HHV(HIGH,13)-LLV(LOW,13))*100; 指标营地1:=SMA(十全十美,3,1); 指标营地2:=SMA(指标营地1,3,1); A4:STICKLINE(指标营地1&gt;指标营地2,20,25,2,1),COLORRED; STICKLINE(指标营地1&lt;指标营地2,20,25,2,1),COLORGREEN; BBI:=(MA(CLOSE,3)+MA(CLOSE,6)+MA(CLOSE,12)+MA(CLOSE,24))/4; A5:STICKLINE(CLOSE&gt;BBI,25,30,2,1),COLORRED; STICKLINE(CLOSE&lt;BBI,25,30,2,1),COLORGREEN; MTM:=CLOSE-REF(CLOSE,1); MMS:=100*EMA(EMA(MTM,5),3)/EMA(EMA(ABS(MTM),5),3); MMM:=100*EMA(EMA(MTM,13),8)/EMA(EMA(ABS(MTM),13),8); A6:STICKLINE(MMS&gt;MMM,30,35,2,1),COLORRED; STICKLINE(MMS&lt;MMM,30,35,2,1),COLORGREEN; MAV:=(C*2+H+L)/4; SK:=EMA(MAV,13)-EMA(MAV,34); SD:=EMA(SK,5); 空方主力:=(-2*(SK-SD))*3.8,COLORGREEN; 多方主力:=(2*(SK-SD))*3.8,COLORRED; A7:STICKLINE(多方主力&gt;空方主力,37,42,2,0),COLORRED; STICKLINE(多方主力&lt;空方主力,37,42,2,0),COLORGREEN; MA11:=MA(CLOSE,5); MA22:=REF(MA(CLOSE,5),1); STICKLINE(MA22&gt;MA11,43,48,2,0),COLORGREEN; A8:STICKLINE(MA22&lt;= MA11,43,48,2,0),COLORRED; XYZ2:=IF(MONTH&lt;12,1,1); XYZ3:=(2*CLOSE+HIGH+LOW)/4; XYZ4:=LLV(LOW,34); XYZ5:=HHV(HIGH,34); 主力:=EMA((XYZ3-XYZ4)/(XYZ5-XYZ4)*100,13)*XYZ2; 散户:=EMA(0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/34d19e9bedaedbba67d2d93df6f603a2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64538c0e27093712a0056660cca7199c/" rel="bookmark">
			Vite 5.0 正式发布
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		11 月 16 日，Vite 5.0 正式发布，这是 Vite 道路上的又一个重要里程碑！
Vite 现在使用 Rollup 4，这已经代表了构建性能的大幅提升。此外，还有一些新的选项可以改善开发服务器性能。
Vite 4 发布于近一年前，它为生态系统奠定了坚实的基础。随着项目继续在共享基础设施上构建，每周 npm 下载量从 250 万跃升至 750 万。框架不断创新，除了 Astro、Nuxt、SvelteKit、Solid Start、Qwik City 等，还看到新的框架加入并使生态系统更加强大。RedwoodJS 和 Remix 转向 Vite 为 React 生态系统的进一步采用铺平了道路。Vitest 的增长速度甚至超过了 Vite。其团队一直在努力，很快将发布 Vitest 1.0。Vite 与 Storybook、Nx 和 Playwright 等其他工具一起使用的故事不断改进，环境也是如此，Vite 在 Deno 和 Bun 中都是可以使用的。
六个月前，Vite 4.3 版本发布。该版本显著提高了开发服务器的性能。然而，仍有很大的改进空间。在 ViteConf 上，尤雨溪公布了 Vite 的长期计划，即致力于开发 Rolldown，这是一个带有兼容 API 的 Rust 移植版的 Rollup。一旦准备就绪，打算在 Vite Core 中使用它来承担 Rollup 和 esbuild 的任务。这将意味着提高构建性能，并大大减少开发和构建之间的不一致。Rolldown 目前处于早期阶段，团队正准备在年底前开源代码库。敬请关注！
Vite 5 专注于清理 API（删除不推荐使用的功能），并简化了解决长期问题的几个功能，例如切换定义以使用正确的 AST 替换而不是 regex。团队还将继续采取措施来实现未来的 Vite（Node.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/64538c0e27093712a0056660cca7199c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0fe5194f6c5b4cdcf31abcf0d16d1416/" rel="bookmark">
			Python 的日志库（logging）和 pandas 库对日志数据进行分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python的日志库logging是一个非常有用的库，可以方便地记录程序的运行日志，以便排查错误和了解程序的运行情况。而pandas库则是一个数据处理库，可以读取各种数据格式（如CSV、Excel等），并对数据进行清洗和分析。下面是一个使用logging和pandas库对日志数据进行分析的示例代码：
import pandas as pd import logging # 配置日志记录器 logging.basicConfig(filename='example.log', level=logging.DEBUG) # 写入一些日志信息 logging.debug('Debugging information') logging.info('Informational message') logging.warning('Warning:config file %s not found', 'server.conf') logging.error('Error occurred') logging.critical('Critical error -- shutting down') # 读取日志文件，并转换成DataFrame格式 log_data = pd.read_csv('example.log', sep=' ', header=None, names=['timestamp', 'severity', 'message']) # 将日期和时间分开成两列 log_data[['date', 'time']] = log_data['timestamp'].str.split('T', expand=True) # 将日志信息按照不同的severity分类，并统计各个类别的数量 severity_counts = log_data.groupby('severity').count()['message'] # 输出结果 print(severity_counts) 输出结果：
severity CRITICAL 1 DEBUG 1 ERROR 1 INFO 1 WARNING 1 Name: message, dtype: int64 这个示例代码中首先使用logging库记录了一些日志信息，并将它们存储在一个文件中。然后使用pandas库读取这个日志文件，并将它转换成一个DataFrame格式的数据表。接着将日期和时间拆分成两列，并根据日志信息中的severity字段进行分类，并统计每个类别的数量。最后输出各个类别的数量。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d936014b666ebf6ccef551800df10218/" rel="bookmark">
			基于SSM的植物园管理系统设计与实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目 录 摘 要 I
Abstract II
引 言 1
1 开发技术简介 3
1.1 SSM框架 3
1.2 JSON 3
1.3 Ajax 4
1.4 Bootstrap前台框架 4
1.5 Eclipse 4
1.6 本章小结 4
2 系统分析 5
2.1可行性分析 5
2.1.1 技术可行性 5
2.1.2 经济可行性 5
2.1.3 操作可行性 5
2.2 功能需求 5
2.3 用例分析 6
2.3 非功能需求 8
2.4 本章小结 8
3 系统设计 9
3.1 系统总体设计 9
3.1.1 系统体系结构 9
3.1.2 系统功能结构 9
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d936014b666ebf6ccef551800df10218/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/abd9dc419cf1bf5da71b42eea8acd70e/" rel="bookmark">
			hive数据库将非分区表数据迁移到分区表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、非分区表数据迁移到分区表 一、非分区表数据迁移到分区表 业务运行一段时间后非分区表的数据量非常大，需要创建一张分区表并将数据迁移到分区表中。
原表建表语句：
create table user( id String default null comment '主键id', name String default null comment '姓名', birthday String default null comment '出生日期' ) comment '用户表' stored as orc location 'hdfs://nameservice1//tmp/wrk/user' tblproperties( 'transactional'='true' ) 分区表建表语句：
新建分区表按出生日期进行分区，新增dt字段作为分区字段
create table user_bak( id String default null comment '主键id', name String default null comment '姓名', birthday String default null comment '出生日期' ) comment '用户表' partitioned by( dt String ) stored as orc location 'hdfs://nameservice1//tmp/wrk/user' tblproperties( 'transactional'='true' ) 数据迁移
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/abd9dc419cf1bf5da71b42eea8acd70e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d7549da43b2d9ee2961084dfe197782/" rel="bookmark">
			Android App 启动状态有几种？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		startup state Android 启动状态（startup state）1.1、冷启动（Cold Start）1.2、温启动（Warm Start）1.3、热启动（Hot Start）1.4、后台启动（Background Start） 优化（套话）待续参考地址 Android 启动状态（startup state） 1.1、冷启动（Cold Start） 当应用尚未在内存中运行时，用户点击应用图标或通过其他方式启动应用时，会触发冷启动。
在这种情况下，应用需要从头开始加载并初始化，这可能需要一些时间，用户可能会感到启动时间较长。
启动流程：
https://blog.csdn.net/weixin_35691921/article/details/116143407?spm=1001.2014.3001.5501
启动时长：
可以理解为Application.onCreate() 到 Activity.onResume()
或者使用adb命令与性能测试工具
adb shell am start -W -n com.example.package/.MainActivity 1.2、温启动（Warm Start） 温启动介于冷启动和热启动之间。当应用在内存中部分被回收但仍有一些资源保留时，再次启动应用将触发温启动。这种情况下，应用需要重新初始化一些资源，但不需要完全从头开始加载。
温启动有很多场景，例如：
用户按连续按返回退出了app，然后重新启动app；
由于系统收回了app的内存，然后重新启动app。
进程仍然存在而Activity销毁
温启动的场景可以使用：onSaveInstanceState去保存需要的数据状态，在重建的时候可以在onCreate和onRestoreInstanceState中的参数去获取销毁前保存的数据。
Configuration 变换和主题切换也会触发：onSaveInstanceState和onRestoreInstanceState
App运行之后切换横竖屏，通过上面代码实验得到的结果是：
I/com.zj.activitylifecycle.LifeCycleActivity: —&gt; onCreate
I/com.zj.activitylifecycle.LifeCycleActivity: —&gt; onStart
I/com.zj.activitylifecycle.LifeCycleActivity: —&gt; onResume
I/com.zj.activitylifecycle.LifeCycleActivity: —&gt; onPause
I/com.zj.activitylifecycle.LifeCycleActivity: —&gt; onSaveInstanceState
I/com.zj.activitylifecycle.LifeCycleActivity: —&gt; onStop
I/com.zj.activitylifecycle.LifeCycleActivity: —&gt; onDestory
I/com.zj.activitylifecycle.LifeCycleActivity: —&gt; recreate
I/com.zj.activitylifecycle.LifeCycleActivity: —&gt; onStart
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4d7549da43b2d9ee2961084dfe197782/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e01359e58d4d21c77319715235d4ffe/" rel="bookmark">
			oracle实操tips
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 前言 作为一只练习时长两年半的程序猿，mysql、oracle、sqlserver、mongodb都有接触过，并且在mysql、oracle上一直是以管理员的身份来负责运维的。
这里主要记录一下在oracle实操方面的一些小知识点。
安装 客户端安装 ubuntu安装oracle客户端_ubuntu 安装oracle客户端-CSDN博客
服务端安装 网上太多了，自己搂搂吧！
centos的docker安装，windows的install安装啥的
centos docker安装oracle 12c
Oracle19C安装教程和配置（超详细！！不能在细了）_oracle19c下载及安装步骤_不爱健身的数学子弟不是好程序员的博客-CSDN博客
Tips 数据库导入导出 # 全量数据导出 exp username/password@hostname:port/instance_name file=自定义命名.dmp full=y # 全量数据导入（本地） imp \'sys/sys as sysdba\' file=自定义命名.dmp log=imp.log full=y ignore=y # 全量数据导入（导入非本地数据库） imp username/password@hostname:port/instance_name file=自定义命名.dmp full=y ignore=y 修改管理员密码 # 查看当前连接模式 show con_name 输出日志为：cdb$root # 当前会话是指定所有容器，如果不是可以通过下面命令调整会话： alter session set container=cdb$root; 命令提示：会话已经更改 # 调整用户sys和system密码： alter user sys identified by "密码"; alter user sys identified by "密码"; 命令成功会提示：用户已经更改 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d48a60d59fa82e722b59e6ff7c91f17/" rel="bookmark">
			Bootstrap对段落和文本的设置(与段落-和文本相关的类)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 01-利用lead类突出显示段落文本02-为段落添加强调样式03-给段落文字添加鼠标停留时的说明语04-添加引用信息05-文本对齐(左对齐、居中对齐、右对齐、两端对齐)06-阻止文本换行07-以省略号显示溢出的文本内容08-转换文本内容中字母的大小写09-设置文本字体的粗细和斜体10-取消超链接的下划修饰线11-颜色相关样式11-1-文本颜色11-2-设置背景颜色 01-利用lead类突出显示段落文本 Bootstrap 中的 .lead 类专门用于突出显示段落文本。这个类会增加段落文本的字体大小和行高，使其更加突出和易于阅读。
使用 .lead 类是一个很方便的方式来使文本在页面中更加引人注目。它会自动应用适当的字体大小和行高，以提高可读性。
示例代码如下：
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;lead类样式&lt;/title&gt; &lt;meta name="viewport" content="width=device-width,initial-scale=1, shrink-to-fit=no"&gt; &lt;link rel="stylesheet" href="bootstrap-4.5.3-dist/css/bootstrap.css"&gt; &lt;script src="jquery-3.5.1.slim.js"&gt;&lt;/script&gt; &lt;script src="bootstrap-4.5.3-dist/js/bootstrap.min.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body class="container"&gt; &lt;h1&gt;《山中问答》&lt;/h1&gt; &lt;h3&gt;&lt;small&gt;李白〔唐〕&lt;/small&gt;&lt;/h3&gt; &lt;p&gt;问余何意栖碧山，&lt;/p&gt; &lt;p&gt;笑而不答心自闲。&lt;/p&gt; &lt;p class="lead"&gt;桃花流水窅然去，&lt;/p&gt; &lt;p&gt;别有天地非人间。&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; 运行效果如下：
02-为段落添加强调样式 式例代码如下：
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;添加强调样式&lt;/title&gt; &lt;meta name="viewport" content="width=device-width,initial-scale=1, shrink-to-fit=no"&gt; &lt;link rel="stylesheet" href="bootstrap-4.5.3-dist/css/bootstrap.css"&gt; &lt;script src="jquery-3.5.1.slim.js"&gt;&lt;/script&gt; &lt;script src="bootstrap-4.5.3-dist/js/bootstrap.min.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body class="container"&gt; &lt;h2&gt;强调文本&lt;/h2&gt; &lt;p&gt;&lt;&amp;nbsp;mark&amp;nbsp;&gt;标签：&lt;mark&gt;标记的重点内容&lt;/mark&gt;&lt;/p&gt; &lt;p&gt;&lt;&amp;nbsp;del&amp;nbsp;&gt;标签：&lt;del&gt;删除的文本&lt;/del&gt;&lt;/p&gt; &lt;p&gt;&lt;&amp;nbsp;s&amp;nbsp;&gt;标签：&lt;s&gt;不再准确的文本&lt;/s&gt;&lt;/p&gt; &lt;p&gt;&lt;&amp;nbsp;ins&amp;nbsp;&gt;标签：&lt;ins&gt;对文档的补充文本&lt;/ins&gt;&lt;/p&gt; &lt;p&gt;&lt;&amp;nbsp;u&amp;nbsp;&gt;标签：&lt;u&gt;添加下划线的文本&lt;/u&gt;&lt;/p&gt; &lt;p&gt;&lt;&amp;nbsp;strong&amp;nbsp;&gt;标签：&lt;strong&gt;粗体文本&lt;/strong&gt;&lt;/p&gt; &lt;p&gt;&lt;&amp;nbsp;em&amp;nbsp;&gt;标签：&lt;em&gt;斜体文本&lt;/em&gt;&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; 运行结果如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8d48a60d59fa82e722b59e6ff7c91f17/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47110ba08d1dd7d9b5620c07bfac1141/" rel="bookmark">
			cookies在在前端（vue）中的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 为什么会有cookies呢？
就是一个存储，用来存放你需要的小数据。
cookies用于什么场合呢？
比如：登录请求成功后得到的token，要有roken才能进行登录保留。
cookies是什么？
在代码中，cookies是指用于存储客户端数据的HTTP cookie。它是一个由服务器发送到用户浏览器并存储在用户计算机上的小型文本文件。每当同一台计算机再次访问同一网站时，服务器将检索并使用先前存储的cookie信息。这些信息可用于多种目的，例如保持用户会话、记住用户偏好或用于安全性和认证等。
那我们要怎么使用cookies呢？
一.打开VueUse官网VueUse | VueUseCollection of essential Vue Composition Utilitieshttps://vueuse.org/ 二.加载VueUse模块 在终端运行以下代码：
cnpm i @vueuse/integrations cnpm i universal-cookie 三.使用cookies import { useCookies } from '@vueuse/integrations/useCookies' //实例化cookies const cookies = useCookies() console.log(cookies); //添加cookies cookies.set('user-token','123456') 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef2789275801030daa94d7254332f767/" rel="bookmark">
			echarts3D立体柱状图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		效果图如下:
直接上代码:
var chartDom = document.getElementById("charts2"); //html元素 var myChart = echarts.init(chartDom); var option; option = { title: [{ text: `单位/kg`, textStyle: { color: "#bfc6cc", fontSize: 14, fontFamily: "Microsoft-YaHei-Regular, Microsoft-YaHei", }, left: "5", top: "30", }, { text: `只`, textStyle: { color: "#bfc6cc", fontSize: 14, fontFamily: "Microsoft-YaHei-Regular, Microsoft-YaHei", }, right: "19", top: "30", }], tooltip: { trigger: "axis", axisPointer: { type: "cross", crossStyle: { color: "#fff", }, }, }, legend: { data: ["
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ef2789275801030daa94d7254332f767/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/284d52aa63ff0341dc6f29d350a09ea8/" rel="bookmark">
			golang优雅退出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		优雅退出 graceful shutdown，优雅退出。
指HTTP服务接受到用户的退出指令后停止接收新请求，在处理和回复当前正在处理的这批请求后主动退出服务。
区别于SIGKILL（kill -9 or CTRL + C）,安全退出可以最小化程序在滚动更新时的服务抖动
用户的退出指令一般是SIGTERM（k8s的实现）或SIGINT（常常对应bash的Ctrl + C）
一、 涉及模块 1、 监听信号 使用标准库os/exec.go中Signal即可完成信息监听
// 至少设置数量为1的缓存区 quitSignal := make(chan os.Signal, 1) signal.Notify(quitSignal, []os.Signal{syscall.SIGINT, syscall.SIGTERM}...) // 阻塞直至有信号写入 &lt;-quitSignal SIGINT：当你在终端按下ctrl+c时，则会触发这个信号SIGTERM：当我们给程序发送kill或者killall指令时，则会触发这个信号 值得注意的是，在没有使用signal.Notify()时，Go默认有一套信号处理规则，比如 SIGHUP, SIGINT或SIGTERM会让程序直接退出。
2、 停止HTTP服务 调用运行中的Server实例的Shutdown()方法可以让服务安全退出：
// ListenAndServe listens on the TCP network address srv.Addr and then // calls Serve to handle requests on incoming connections. // Accepted connections are configured to enable TCP keep-alives. // // If srv.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/284d52aa63ff0341dc6f29d350a09ea8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b641c1e3b386a43aebdfd5e473ed670/" rel="bookmark">
			网络中的损失函数其实就这样
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在机器学习和深度学习中，损失函数是用来衡量模型预测结果与真实值之间差异的函数。它在训练过程中起着关键的作用，通过最小化损失函数来优化模型的参数。以下是一些常见的损失函数，pytorch已经内置了相关损失函数，可以直接调用即可。
from torch immport nn #定义均方误差 criterion = nn.MSELoss() #定义交叉熵损失函数 criterion = nn.CrossEntropyLoss() #定义对数损失函数 criterion = nn.BCEWithLogitsLoss() #定义Hinge损失函数 criterion = nn.HingeEmbeddingLoss() #定义KL散度损失函数 criterion = nn.KLDivLoss() #定义负对数似然函数 criterion = nn.NLLLoss() 均方误差 均方误差（Mean Squared Error，MSE）：MSE是回归问题中最常见的损失函数之一。它计算预测值与真实值之间的平方差，并求取平均值。MSE对异常值敏感，因为它对误差的平方进行了求和，因此较大的误差会对损失函数产生更大的影响。
具体而言，对于一个样本的预测值 y ^ \hat{y} y^​ 和真实值 y y y，均方误差损失函数的计算公式如下：
M S E = 1 n ∑ i = 1 n ( y ^ i − y i ) 2 MSE = \frac{1}{n} \sum_{i=1}^{n} (\hat{y}_i - y_i)^2 MSE=n1​i=1∑n​(y^​i​−yi​)2
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b641c1e3b386a43aebdfd5e473ed670/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71c21d25127055f6a3bdcbb5965378eb/" rel="bookmark">
			利用ETLCloud自动化流程实现业务系统数据快速同步至数仓
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		现代企业有不少都完成了数字化的转型，而还未转型的企业或商铺也有进行数字化转型的趋势，由此可见，数据已经成为企业决策的重要依据。企业需要先获取数据，将业务系统数据同步至数仓进行整合，然后再进行数据分析。为了更好地利用数据，提高工作效率，产出及获得最大利益。
ETLCloud是一款集ETL、ELT、CDC实时数据集成、编排调度、数据服务API为一体的数据集成平台，可以帮助企业快速实现业务系统数据同步至数仓。它提供了一系列自动化流程，包括数据抽取、数据转换和数据加载等，使得数据同步变得简单、快速、准确。
首先，平台的数据抽取功能可以从各种业务系统中提取数据，并将其转化为数仓可用的格式。无论是企业内部的ERP系统、CRM系统，还是外部的供应商系统、电商平台，也能轻松实现数据同步。只需要一些简单的配置，就可以自动执行流程同步数据，大大提高了数据处理的效率。
其次，数据转换功能可以对抽取的数据进行清洗、转换、合并等操作，以满足数仓的需求。例如，对于不同系统中的数据格式、命名规范不一致的情况，可以通过灵活的转换规则，将其统一为数仓所需的规范格式。这些转换规则可以根据企业的业务需求进行定制化，以确保数据的准确性和一致性。
ETL自动化流程示例：
每天晚上23:15时，将mysql数据库a表的数据同步到b表；
新增流程，运行方式为定时自动调度，调度策略选择对应时间。
点击流程设计，选择组件进行转换。
点击组件进行设计
选择对应流程启动调度
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f168baf47412049224925eb3f831eb35/" rel="bookmark">
			使用Python进行二维图像的三维重建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2D图像的三维重建是从一组2D图像中创建对象或场景的三维模型的过程。这个技术广泛应用于计算机视觉、机器人技术和虚拟现实等领域。
在本文中，我们将解释如何使用Python执行从2D图像到三维重建的过程。我们将使用TempleRing数据集作为示例，逐步演示这个过程。该数据集包含了在对象周围的一个环上采样的阿格里真托（Agrigento）“Dioskouroi神庙”复制品的47个视图。
三维重建的关键概念
在深入了解如何使用Python从2D图像执行三维重建的详细步骤之前，让我们首先回顾一些与这个主题相关的关键概念。
深度图
深度图是一幅图像，其中每个像素代表摄像机和场景中相应点之间的距离。深度图常用于计算机视觉和机器人技术中，用于表示场景的三维结构。
有许多不同的方法可以从2D图像计算深度图，包括立体对应、结构光和飞行时间等。在本文中，我们将使用立体对应来从示例数据集计算深度图。
Point Cloud
点云是表示对象或场景形状的三维空间中的一组点。点云常用于计算机视觉和机器人技术中，用于表示场景的三维结构。
一旦我们计算出代表场景深度的深度图，我们可以使用它来计算一个三维点云。这涉及使用有关摄像机内部和外部参数的信息，将深度图中的每个像素投影回三维空间。
网格
网格是一个由顶点、边和面连接而成的表面表示。网格常用于计算机图形学和虚拟现实中，用于表示对象或场景的形状。
一旦我们计算出代表对象或场景形状的三维点云，我们可以使用它来生成一个网格。这涉及使用诸如Marching Cubes或Poisson表面重建等算法，将表面拟合到点云上。
逐步实现
现在我们已经回顾了与2D图像的三维重建相关的一些关键概念，让我们看看如何使用Python执行这个过程。我们将使用TempleRing数据集作为示例，逐步演示这个过程。下面是一个执行Temple Ring数据集中图像的三维重建的示例代码：
安装库：
pip install numpy scipy 导入库：
#importing libraries import cv2 import numpy as np import matplotlib.pyplot as plt import os 加载TempleRing数据集的图像：
# Directory containing the dataset images dataset_dir = '/content/drive/MyDrive/templeRing' # Initialize the list to store images images = []# Attempt to load the grayscale images and store them in the list for i in range(1, 48): # Assuming images are named templeR0001.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f168baf47412049224925eb3f831eb35/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87748cf3608ad8d998a24ec63d389ae4/" rel="bookmark">
			Lambda表达式的性能分析与使用限制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们需要考虑使用Lambda表达式时候的性能问题与使用限制时，我们需要首先理解什么是Lambda表达式、在Java编程中怎样使用。Lambda表达式是在Java 8引入的重要特性，它允许我们使用函数式编程风格，让我们的代码更加简洁，在许多情况下使用Lambda可以提升我们的编程效率，但是使用它也有一些限制和注意事项。
1. Lambda表达式是什么 Lambda表达式是一种轻量级的函数式编程方式，本质上是实现一个函数接口，就可以将该实现作为参数传递给方法，或者用于声明简单的匿名函数。它能够让我们的代码更加简洁、易读和易维护，特别是在处理集合数据和多线程编程方面。
2. Lambda表达式对性能的影响 虽然Lambda表达式的简洁性使得代码更易于编写和理解，但在性能方面需要注意一些事项：
对象创建/回收开销：Lambda表达式本质上是创建了一个实现函数接口的对象。频繁的Lambda表达式使用可能会导致大量的对象创建和回收，增加GC的压力。因此，在高性能的场景中，我们应该避免太多使用Lambda表达式。
额外的运行时开销：Lambda表达式需要通过invoke dynamic指令来实现，这会在运行时增加一些开销。虽然JVM会优化这些指令，但仍有额外开销。对于大量重复调用的方法，Lambda表达式的运行时开销可能会影响性能。
3. Lambda表达式的使用限制 类型推断限制：在某些情况下，编译器可能无法正确地推断Lambda表达式的参数类型。在这种情况下，我们需要显式地指定参数类型，以避免编译错误。
闭包捕获限制：Lambda表达式可以捕获外部作用域中的变量（闭包），但有一些限制。捕获的变量必须是final或等效final的。这意味着我们不能在Lambda表达式内部修改捕获的变量，否则会导致编译错误。
this指向：Lambda表达式内部的this指向的是包含它的类的实例。这在某些情况下可能与预期不符，特别是在嵌套Lambda表达式或内部类中使用时。
4. 示例代码
// Lambda表达式示例：加法 Function&lt;Integer, Integer&gt; square = x -&gt; x + 10; // 输出：15 System.out.println(square.apply(5)); // Lambda表达式尝试修改捕获的变量（错误使用方式） int a = 0; // 编译错误，不能在Lambda表达式内修改外部的变量值 Runnable increment = () -&gt; ++a; // Lambda表达式可以捕获外部变量(正确使用方式) int multi = 5; Function&lt;Integer, Integer&gt; multiply = x -&gt; x * multi; // 输出：25 System.out.println(multiply.apply(5)); 总结：Lambda表达式是一种强大的工具，能够在Java编程中显著提高代码的简洁性和可读性。然而，在高性能场景下，需要谨慎使用，避免频繁的对象创建/回收和过度的运行时开销。同时，我们要留意Lambda表达式的限制，确保正确地使用它们。
需要指出的是，性能优化在编程中是一个复杂的课题，往往需要根据具体的应用场景进行评估和调整。对于普通的业务代码，Lambda表达式通常不会成为性能瓶颈，而其简洁性和代码可读性却能带来明显的好处。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca9f85bbf61523bce60a97b6fa6b2a1b/" rel="bookmark">
			GD32F407，基于ymode协议 RS485IAP升级
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由于项目需要，了解IAP对程序进行升级操作，可以不用st—link烧写，减轻工作量。
IAP是先运行bootloader，再去运行APP程序。
bootloader程序
bootloader最重要是2个部分，从应用层读取升级文件，覆盖之前的APP程序（当然也可以不用覆盖以前的APP程序，直接运行接受到的升级程序，那么需要注意新APP的flash起始地址。），还有从BootLoader跳转到APP程序,代码如下：
#define APPLICATION_ADDRESS 0x08004000 //检查栈顶地址是否合法. if((*( __IO uint32_t*)(APPLICATION_ADDRESS)&amp;0x2FFE0000)==0x20000000) { JumpAddress = *( __IO uint32_t*) (APPLICATION_ADDRESS + 4) ; // 指向用户程序复位函数所在的地址 Jump_To_Application = ( pFunction ) JumpAddress; //初始化APP堆栈指针(用户代码区的第一个字用于存放栈顶地址) __set_MSP( *( __IO uint32_t* ) APPLICATION_ADDRESS ); /* Jump to application */ Jump_To_Application(); } else{ printf("error\r\n"); } FLASH的读写操作，要把APP的.bin文件写入FLASH中。
在写入之前要先擦除FLASH。
/*============================================================================== 函数名 : IapEraseSector 功能 : 擦除相关扇区 输入参数说明: addr_start: 起始地址 ------------------------------------------------------------------------------*/ fmc_state_enum IapEraseSector(uint32_t addr_start) { uint8_t i; printf("\r\nerase on\r\n"); fmc_unlock(); fmc_flag_clear(FMC_FLAG_END); fmc_flag_clear(FMC_FLAG_WPERR); fmc_flag_clear(FMC_FLAG_PGSERR); fmc_flag_clear(FMC_FLAG_PGMERR); printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ca9f85bbf61523bce60a97b6fa6b2a1b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c811a7c3b62135ab36a8241da5a124ec/" rel="bookmark">
			Android 关于.9图设置拉伸区域无效问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目中闪屏页面用到.9图片，但添加后并没有起作用，困扰了我一天.
解决问题：
1.如果.9在 drawable-hdpi 文件下不起作用，请移动到 drawable-xhdpi 文件下 ，以此类推，或者 移动到 drawable-xxhdpi 、drawable-xxxhdpi 文件下 都试一下。
2.建议每个分辨率文件下都放一个.9图，注意 图片名字一定要一致，这样才能各个机型都能够适配。
注意：
当.9图放在不同分辨率的文件下时，一定要让UI设计师出一套各个分辨率的图。而不是一张大小的图放在各个文件下。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e61dbbc3cd2f4b0720c116e6c42e07ac/" rel="bookmark">
			Flex布局实战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Flex布局简介 Flex布局是一种用于网页布局的现代CSS布局模型。它使用flex容器和flex项来实现灵活的、响应式的布局。Flex容器是父元素，内部包含一系列的flex项。Flex项可以根据指定的规则自动调整尺寸和位置，以适应不同的屏幕大小和设备类型。
Flex布局初概念 Flex布局，全称Flexible Box布局，是一种在CSS3中引入的新的布局方式。
采用Flex布局的元素被称为Flex项目（Flex items），这些元素在Flex容器（Flex container）内部自动成为其成员。Flex容器可以包含一个或多个Flex项目。
Flex布局的主要特点在于其具有两根轴：主轴和侧轴。主轴的起始位置与边框的交叉点被称为main start，结束位置被称为main end；侧轴的起始位置叫做cross start，结束位置叫做cross end。
Flex项目在主轴上默认是线性排列的，而在交叉轴上的排列则由flex-direction属性定义，该属性有四个可能的值：row（默认值，项目从左向右排列）、row-reverse（项目从右向左排列）、column（项目从上向下排列）和column-reverse（项目从下向上排列）。
此外，Flex容器可以设置其子元素的弹性空间（flex space），并通过flex-grow和flex-shrink属性来控制其子元素如何分配这些空间。
Flex布局的使用可以简化传统布局中一些复杂的布局问题，使得页面在不同屏幕和设备上呈现出最佳效果。
Flex布局设置 1、Flex布局属性及其作用和属性值以及描述 属性名作用属性值描述display用于将元素设置为弹性盒子或行内弹性盒子flex将元素设置为弹性盒子flex-direction定义主轴的方向，决定子元素如何在主轴上排列row 、row-reverse、column、column-reverse设置主轴的方向为水平方向或垂直方向，或它们的反向方向justify-content定义在主轴上的对齐方式，决定子元素如何沿着主轴排列flex-start, center, flex-end, space-between, space-around, space-evenly设置子元素在主轴上的对齐方式，如起点、中心、终点或均匀分布align-items定义在侧轴上的对齐方式，决定子元素如何沿着侧轴排列flex-start, center, flex-end,baseline, stretch设置子元素在侧轴上的对齐方式，如顶部对齐、底部对齐、中心对齐或按比例填充空间flex-wrap控制子元素是否换行，默认为nowrap，还有wrap和wrap-reverse可选nowrap, wrap, wrap-reverse控制子元素是否换行排列，或不换行反向排列flex-flow是flex-direction和flex-wrap的简写形式，用于设置主轴和侧轴的对齐方式[row](javascript:void(0)) [nowrap](javascript:void(0)) 、 [row](javascript:void(0)) [wrap](javascript:void(0)) 、 [row](javascript:void(0)) [wrap-reverse](javascript:void(0)) 、 [column](javascript:void(0)) [nowrap](javascript:void(0)) 、 [column](javascript:void(0)) [wrap](javascript:void(0)) 、 [column](javascript:void(0)) [wrap-reverse](javascript:void(0))设置主轴和侧轴的对齐方式，包括是否换行排列align-content当子元素在侧轴上有多行时，用于定义它们的对齐方式flex-start, center, flex-end, space-between, space-around, space-evenly当子元素有多行时，设置它们在侧轴上的对齐方式，如顶部对齐、底部对齐、中心对齐或均匀分布flex-grow用于设置元素的弹性空间，正值表示可以放大，0表示不放大number (如 1, 2, …) 或 0 (default)设置元素的弹性空间因子，可以放大元素的空间占用比例flex-shrink用于设置元素的弹性收缩，正值表示可以缩小，0表示不缩小number (如 1, 2, …) 或 0 (default)设置元素的弹性收缩因子，可以缩小元素的空间占用比例flex-basis用于设置元素的基本尺寸，类似于宽度或高度，但可被弹性空间调整length (如 20px, 5em,) 或 auto (default)设置元素的基本尺寸，可以影响弹性空间占用的尺寸比例 2、创建小程序项目 在 index.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e61dbbc3cd2f4b0720c116e6c42e07ac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8c466bc81508b18ed2cf6f8df7c7fde/" rel="bookmark">
			Android adj调整 --- computeOomAdjLSP流程详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android adj调整 --- computeOomAdjLSP流程详解 Android adj调整 --- computeOomAdjLSP流程详解1. computeOomAdjLSP的参数2. 是否存在循环计算3. 没有ApplicationThread的时候的调整4. 对ProcessStateRecord进程状态记录的一些初始化5. 设置默认是否允许冻结6. 获取调整之前的一些状态7. system_server或者常驻进程的调整8. 调整之前的一些变量的定义9. top顶端app的调整10. 正在播放远端动画的调整11. instrumentation的调整12. 正在接受广播进程的调整13. 正在运行服务进程的调整14. 系统在休眠时topApp的调整15. 其它app的默认状态初始化16. 更新foregroundActivities和mHasVisibleActivities17. 更新最近使用的activity的状态18. 调整前台服务或者hasOverlayUi的进程19. 调整最近活跃的前台服务进程20. 调整强制提升到用户可感知的进程21. 调整heavy的进程21. 调整桌面应用22. 调整previous上一个使用的应用23. 循环计算时更新procState、adj、schedGroup24. 先更新一下当前计算的值到ProcessStateRecord25. 设置当前adj调整的系列号26. 调整backup备份的应用27. service服务自身和服务依赖关系调整27.1 遍历该进程的服务numberOfRunningServices27.2 根据Services自身的状态进行调整27.3 获取前台服务的能力capabilityFromFGS27.4 遍历每个服务里面的所有链接对象27.5 取出每个服务链接对象27.6 只调整自身是服务，由于客户端的链接的情况27.7 computeClients循环计算时，会先计算客户端的adj27.8 调整前获取客户端的clientAdj和clientProcState27.9 进行没有豁免优先级情况的调整27.9.1 循环计算的时候是否需要先跳过本次计算27.9.2 能力capability初始化27.9.3 低于cached activity的进程状态clientProcState约束27.9.4 如果进程设置了在低内存时托管给系统27.9.5 如果clientAdj大于当前服务的adj，则开始adj依赖关系调整27.9.6 clientProcState依赖关系调整27.9.7 service依赖关系原因的输出 27.10 BIND_WAIVE_PRIORITY == true豁免优先级调整27.11 绑定客户端对象是activity的调整 28. provider依赖关系调整28.1 只有当前是provider内容提供者进程才调整28.2 循环计算computeClients和判断是否需要跳过本次计算shouldSkipDueToCycle28.3 调整前客户端的clientAdj、clientProcState的记录28.4 clientAdj大于provider的adj才进行adj依赖关系调整28.5 clientProcState进程状态依赖调整28.6 客户端分组依赖关系调整28.7 输出provider调整的原因28.8 hasExternalProcessHandles的调整 29. recent-provider最近使用的provider调整30.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c8c466bc81508b18ed2cf6f8df7c7fde/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1441a4ce6be211dbdcf6339771d2f5a/" rel="bookmark">
			vue-组件生命周期&#43;网络请求
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		​🌈个人主页：前端青山
🔥系列专栏：Vue篇
🔖人终将被年少不可得之物困其一生
依旧青山,本期给大家带来vue篇专栏内容:vue-组件生命周期+网络请求
目录
组件生命周期
1. Vue的生命周期
2. Vue 子组件和父组件执行顺序
3. created和mounted的区别
4. 一般在哪个生命周期请求异步数据
5. keep-alive 中的生命周期哪些
6.vue2的生命周期钩子函数
完整案例 官方解释
网络请求
1.基础语法
2.拦截器
3.取消网络请求
组件生命周期 生命周期：指的是Vue组件自其开始创建到其被销毁完毕这段时间范围。
在生命周期的这个范围内，作者将其4个重要阶段，同时作者为了方便开发者指定组件在特定时间做一些特定的操作，对外暴露了一些特定名称的函数，这些函数我们称之为生命周期钩子函数。常用的生命周期钩子函数一共有10个，外加1个不常用的错误边界周期，共11个生命周期函数。本节我们将依据其四个阶段，来学习其中最常见的8个周期函数。
四个阶段
组件创建阶段
beforeCreate
created
组件挂载阶段
beforeMount
mounted
组件更新阶段（如果强制执行该阶段周期，可以this.$forceUpdate()）
beforeUpdate
updated
组件销毁阶段（如果期望手动效果组件，可以执行this.$destroy()）
beforeDestroy
destroyed
1. 说一下Vue的生命周期 Vue 实例有⼀个完整的⽣命周期，也就是从开始创建、初始化数据、编译模版、挂载Dom -&gt; 渲染、更新 -&gt; 渲染、卸载 等⼀系列过程，称这是Vue的⽣命周期。
beforeCreate（创建前）：数据观测和初始化事件还未开始，此时 data 的响应式追踪、event/watcher 都还没有被设置，也就是说不能访问到data、computed、watch、methods上的方法和数据。
created（创建后） ：实例创建完成，实例上配置的 options 包括 data、computed、watch、methods 等都配置完成，但是此时渲染得节点还未挂载到 DOM，所以不能访问到 $el 属性。
beforeMount（挂载前）：在挂载开始之前被调用，相关的render函数首次被调用。实例已完成以下的配置：编译模板，把data里面的数据和模板生成html。此时还没有挂载html到页面上。
mounted（挂载后）：在el被新创建的 vm.$el 替换，并挂载到实例上去之后调用。实例已完成以下的配置：用上面编译好的html内容替换el属性指向的DOM对象。完成模板中的html渲染到html 页面中。此过程中进行ajax交互。
beforeUpdate（更新前）：响应式数据更新时调用，此时虽然响应式数据更新了，但是对应的真实 DOM 还没有被渲染。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c1441a4ce6be211dbdcf6339771d2f5a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e296fa87c4b6d44a768d63533d719ae0/" rel="bookmark">
			C语言isdigit()函数:判断字符是否为十进制数字
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		函数名: isdigit
头文件：&lt;ctype.h&gt;
函数原型: int isdigit(int ch);
功 能: 判断字符是否为十进制数字
参数： int ch 待检查的字符
返回值： ch不是十进制数字 返回0 , ch是十进制数字 返回非0
程序例： 判断输入的字符是否为十进制数字
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
#include&lt;ctype.h&gt;
#include&lt;stdio.h&gt;
int main(){
char ch;
printf("input a character:");
scanf("%c",&amp;ch);
if(isdigit(ch)){
printf("%c is digit.",ch);
}else{
printf("%c is not digit.",ch);
} putchar('\n'); return 0; }
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e296fa87c4b6d44a768d63533d719ae0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab4f7bb6a95cf8e37129b6c486b8135a/" rel="bookmark">
			史上最全slam从零开始-总目录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		讲解关于slam一系列文章主要分为以下几个板块,其中的序列号代表其学习难度,入门学员建议从01开始学习,相同序列号表示其难度相当
文末正下方中心提供了本人 联系方式， 点击本人照片即可显示 W X → 官方认证 {\color{blue}{文末正下方中心}提供了本人 \color{red} 联系方式，\color{blue}点击本人照片即可显示WX→官方认证} 文末正下方中心提供了本人联系方式，点击本人照片即可显示WX→官方认证
零、SLAM基础知识解读–&gt;难度系数00 学习者预备条件:高数,线性代数,矩阵运算。
（01）史上最简SLAM零基础解读(1) - 旋转平移矩阵→欧式变换推导
（02）史上最简SLAM零基础解读(2) - 对极约束→Essential矩阵、Fundamental矩阵推导
（03）史上最简SLAM零基础解读(3) - 白话来说SVD奇异值分解(1)→原理推导与奇异值求解举例
（04）史上最简SLAM零基础解读(3) - 白话来说SVD奇异值分解(2)→超定方程求解,最小奇异值特征为最优解
（05）史上最简SLAM零基础解读(4) - 单应性Homography →公式推导与细节理解
（06）史上最简SLAM零基础解读(5) - Homography,Fundamental,Essential深入浅出→了解适用场景:共面、非共面、仅旋转
（07）史上最简SLAM零基础解读(6) - 卡方分布(chi-square distribution)和()卡方检验(Chi-Squared Test) → 理论讲解与推导
（08）史上最简SLAM零基础解读(7) - Jacobian matrix(雅可比矩阵) → 理论分析与应用详解
（09）史上最简SLAM零基础解读(8.1) - 旋转矩阵、旋转向量、欧拉角推导与相互转换
（09）史上最简SLAM零基础解读(10.1) - g2o(图优化)→简介环境搭建(slam十四讲第二版为例)
（10）史上最简SLAM零基础解读(10.2) - g2o(图优化)→顶点 (Vertex)编程细节
（11）史上最简SLAM零基础解读(10.3) - g2o(图优化)→边(Edge)编程细节
（12）史上最简SLAM零基础解读(10.4) - g2o(图优化)→示例代码讲解(slam十四讲第二版为例)
一、卡尔曼家族从零解剖(Bayesian、Partical、EKF、ESKF、IEKF等)–&gt;难度系数01 学习者预备条件: 高数、线性代数、概率论与数理统计、矩阵运算。
二、ORB-SLAM2源码无死角解析–&gt;难度系数02 学习者预备条件: c++编程,linux命令行操作,高数,线性代数,矩阵运算。
（00）(01)ORB-SLAM2源码无死角解析-(00) 目录_最新无死角讲解
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab4f7bb6a95cf8e37129b6c486b8135a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9dd154e2f0e8b6425986328ebbd612c/" rel="bookmark">
			卡尔曼家族从零解剖-(01)预备知识点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		讲解关于slam一系列文章汇总链接:史上最全slam从零开始，针对于本栏目讲解的 卡尔曼家族从零解剖 链接 :卡尔曼家族从零解剖-(00)目录最新无死角讲解：https://blog.csdn.net/weixin_43013761/article/details/133846882
文末正下方中心提供了本人 联系方式， 点击本人照片即可显示 W X → 官方认证 {\color{blue}{文末正下方中心}提供了本人 \color{red} 联系方式，\color{blue}点击本人照片即可显示WX→官方认证} 文末正下方中心提供了本人联系方式，点击本人照片即可显示WX→官方认证
郑重声明：该系列博客为本人 ( W e n h a i Z h u ) 独家私有 , 禁止转载与抄袭 , 首次举报有谢 ! \color{red}郑重声明：该系列博客为本人(WenhaiZhu)独家私有,禁止转载与抄袭,首次举报有谢! 郑重声明：该系列博客为本人(WenhaiZhu)独家私有,禁止转载与抄袭,首次举报有谢!
一、前言 在后续的过程中，不可避免涉及到各种零碎的知识点，比如概率论中的一些公式记录或推导，如每次都花大量的篇幅来进行讲解，这样博客就太多了，知识点又会比较凌乱，所以该篇博客，主要用于记录一些重要公式的结论，每个公式都会有对应的编号，不过需要注意 编号未必有序 \color{red}编号未必有序 编号未必有序。有的或许会有推导过程，有的可能只有参考链接，当然或许有部分只有公式，那么说明其应该比较简单，随便百度或者谷歌一下都能找到对应的推导过程。
1.概率相关 ( 1 ) 随机变量 : \color{blue}(1)随机变量: (1)随机变量: 大写 X X X , Y Y Y， Z Z Z … 表示随机变量(事件)；小写的 x x x , y y y， z z z 表示随机变量的具体取值，通常是一个具体的数值；如 X X X 表示明天是否下雨的随机事件， X = 1 X=1 X=1 表示下雨， X = 0 X=0 X=0 则不下雨。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e9dd154e2f0e8b6425986328ebbd612c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09bffb1e7721e20e57d2ea8fe5178e60/" rel="bookmark">
			简单的用Python实现一下，采集某牙视频，多个视频翻页下载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 表弟自从学会了Python，每天一回家就搁那爬视频，不知道的以为是在学习，结果我昨天好奇看了一眼，好家伙，在那爬某牙舞蹈区，太过分了！
为了防止表弟做坏事，我连忙找了个凳子坐下，跟他一起欣赏~
啊呸，不对，监督他！
当然，作为一个大公无私的人，好东西怎么能独享呢？
这不立马就给大家分享一下~
准备工作 首先我们需要准备这些
软件模块
软件
Python 3.10 解释器Pycharm 编辑器 模块
requests # 数据请求re # 正则表达式模块 requests是第三方模块，win + R 输入cmd 输入安装命令 pip install requests 安装即可，re 是自带的模块，无需安装。
实现思路与流程 一. 数据来源分析
1. 明确需求: 明确采集的网站以及数据内容 - 网址: https://www.某牙.com/video/play/933940354.html - 数据: 视频标题 / 视频内容 &lt;主要数据&gt; 2. 抓包分析: 浏览器开发者工具去抓包 - 打开开发者工具: F12 / 右键点击检查选择network (网络) - 刷新网页: 网页相关数据内容 - 通过关键字去搜索找到对应的数据包位置 搜索: M3U8 -&gt; getMomentContent 数据包地址: https://某牙.com/moment/getMomentContent 二. 代码实现步骤
1. 发送请求 -&gt; 模拟浏览器对于url地址发送请求 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/09bffb1e7721e20e57d2ea8fe5178e60/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b48d2d47fba8c0eb3e852be4ee4abba/" rel="bookmark">
			Linux_虚拟机常用目录汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		根目录（cd /）：/ 表示根目录，cd和 / 之间有个空格！
用户目录（cd ~）：~ 表示用户目录，也称为家目录。cd 和 ~ 之间有个空格！
当前路径：执行 pwd 指令即可看到当前所在的路径信息。
绝对路径：只能由根目录写起，例如写到 alpha 目录下。
cd /home/alientek/alpha //cd 和 / 之间有一个空格
相对路径：不是由根目录写起，例如写到 alpha 目录下。
cd ~/alpha
用户主目录文件：~/alpha
cd ~/alpha/
tree -L 2
用户主目录文件：~/linux
cd ~/linux
tree -L 2
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33c5ddac685eda1face96a6092a7c1b2/" rel="bookmark">
			mysql之squid代理服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		（一）squid代理服务器 1、nginx做代理服务器 （1）反向代理（负载均衡） （2）缓存 （3）nginx无法做正向，通过proxy_pass进行反向代理 2、squid：正向代理服务器（类似vpn） 3、squid的作用：支持正向代理、缓存加速、基于ACL可以过滤控制 4、squid代理的工作机制 （1）代替客户端向网站请求数据，不需要访问代理的ip地址，直接请求目的网站，由代理服务器处理请求和响应，可以隐藏用户的真实ip地址 （2）客户端访问目标网站之后（静态web元素）保存到缓存中，发送给客户端，下一次所有的客户机都可以使用缓存访问，加快访问速度（只能缓存静态web页面，无法缓存动态web） 5、squid的数据流向 （二）squid代理的作用 1、资源获取，代替客户端获取目标服务器的资源 2、加速访问，代理服务器可能和目标服务器距离更近，可以起到一定的加速作用 3、缓存作用，代理服务器保存从目标服务器获取的资源，客户端下一次再请求目标服务器可以直接访问缓存即可，减轻目标服务器的压力 4、隐藏真实的IP地址，代理服务器代替客户端请求，客户端的信息不会显示 （三）squid代理的类型 1、传统代理（正向代理），需要在客户端上指定好代理服务器的地址和端口 2、透明代理，客户端不再需要指定代理服务器的地址和端口，而是通过默认路由来进行转发（squid服务器做网关，进行转发） 3、反向代理，在反向代理的squid服务器中，如果缓存了请求资源，将资源直接返回给客户端；否则，代理服务器会继续代理客户端向web服务器发送请求，然后再把请求的资源响应给客户端，同时把响应缓存在本地，后续请求者都可以使用（有缓存，直接响应缓存内容；没有缓存，才会代替客户端请求web资源，响应结果保存在缓存，然后响应给客户端，下一次直接访问缓存即可—缓存是否命中） 补充：SNAT、DNAT和代理服务器squid之间的区别 SNAT、DNAT和代理服务器squid之间的区别
SNAT和DNAT
代理服务器squid
网络层次
网络层
应用层
数据处理方式
改变数据包头部的源IP地址和目的地址
不改变数据包的任何信息，直接把数据包发给代理，代理通过应用层过滤的方式实现转发（类似路由器）
（四）实验架构 1、test1：客户端（10） 2、test2：squid（20），做透明代理会需要双网卡 3、web页面：nginx1，nginx2 （五）实验：正向代理 1、配置squid代理服务器
（1）编译安装 （2）创建软连接、创建用户、赋权
2、修改squid的配置文件 （1）配置文件的匹配规则：自上而下匹配，匹配之后，不再向下匹配 （2）Squid 的运行控制 （3）创建 Squid 服务脚本
（4）赋权 3、构建传统代理服务器（正向代理） （1）修改配置文件（缓存目录） （2）修改防火墙规则 （2）修改防火墙规则 （3）配置nginx （4）虚拟机测试 （六）实验：透明代理 取消代理地址和端口 将一台客户机模拟外网：12.0.0.12 双网卡分别指向网关 1、添加虚拟网卡 2、修改squid配置文件 3、开启路由转发功能，实现本机中不同网段的地址转发 4、修改防火墙策略 5、配置web服务器（nginx） 6、修改客户端的网卡配置文件 7、测试 8、基于代理的ACL控制 （1）权限控制 （2）以列表形式
（七）实验：反向代理
1、恢复配置
2、清空iptables的策略 3、修改squid配置文件 （1）http_port 20.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/33c5ddac685eda1face96a6092a7c1b2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28f2887fb73f621de34813cd4ff26e7e/" rel="bookmark">
			日本水稻(Oryza sativa Japonica rice)的基因组染色质长度 IRGSP-1.0
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		创作日志： 在看scHi-C综述的时候发现了一个在2021年发布在Nature Plants上的数据集，想拿来用，首先就要知道其对应的水稻品种以及染色质长度。最终在UCSC上找到了对应的组装好的基因组，版本名为 IRGSP-1.0。
UCSC链接：https://www.ncbi.nlm.nih.gov/datasets/genome/GCF_001433935.1/ chr1	43270923 chr2	35937250 chr3	36413819 chr4	35502694 chr5	29958434 chr6	31248787 chr7	29697621 chr8	28443022 chr9	23012720 chr10	23207287	chr11	29021106	chr12	27531856	染色质长度在这里看：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00f727dcdcf90dbe36a4fec0bd7b6c91/" rel="bookmark">
			[Vue 代码模板] Vue3 中使用 Tailwind CSS &#43; NutUI 实现侧边工具栏切换主题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章归档：https://www.yuque.com/u27599042/coding_star/vzkgy6gvcnpl3u2y
效果示例 配置 src 目录别名 @ https://www.yuque.com/u27599042/coding_star/ogu2bhefy1fvahfv
配置 Tailwind CSS https://www.yuque.com/u27599042/coding_star/yqzi9olphko9ity1
配置 Tailwind CSS 使用暗黑模式的形式 tailwind.config.js
/** @type {import('tailwindcss').Config} */ export default { // 配置 Tailwind CSS 使用暗黑模式的形式(类名 class="dark") darkMode: 'class', // ... } 配置 NutUI https://www.yuque.com/u27599042/coding_star/gumgmgfgi2gzkgpl
ToggleTheme.js src/components/toolbar/js/ToggleTheme.js
import {computed, ref} from 'vue' // *************** // * 是否为暗色主题 * // *************** const isDark = ref(false) // ********** // * 主题图标 * // ********** const lightIcon = 'icon-sunbaitian-taiyang' const darkIcon = 'icon-yueliangxingxing' export const themeIcon = computed(() =&gt; isDark.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/00f727dcdcf90dbe36a4fec0bd7b6c91/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6445da72c65196635ca7589c6e64d6e/" rel="bookmark">
			Java--奔跑的小恐龙游戏（详细注释）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		奔跑的小恐龙游戏是一款非常简单的跑酷游戏，玩家通过控制小恐龙向前狂奔，通过空格键进行跳跃躲避沿途出现的牛仔、木桶和飞行的老鹰，使用上下箭头控制奔跑的速度，跑的越远，得分越高。游戏内添加有背景音乐、跳跃音效和撞击音效。代码虽然较长，但结构简单，易于理解，适合初学者进行学习。
文章目录
详细代码：
一、启动包
1.开始类 Start
二、模型包
1.恐龙类 Dinosaur
2.障碍物类 Obstacle
三、服务包
1.刷新帧线程类 FreshThread
2.音乐播放器类 MusicPlayer
3.分数记录器类 ScoreRecorder
4.音效类 Sound
四、视图包
1.背景图像类 BackgroundImage
2.游戏面板类 GamePanel
3.主窗体类 MainFrame
4.成绩对话框类 ScoreDialog
五、其它
1、data文件夹数据：
2、music文件音效：
3、image文件图像:
总体代码架构:
详细代码： 一、启动包 游戏开始类调用游戏主窗体类。而游戏面板类对开始界面进行了窗体，窗口设计并调用了游戏主体窗口类启动游戏。
1.开始类 Start Start.java
package pers.wu.main; //启动包 import pers.wu.view.MainFrame; //启动类 public class Start { public static void main(String[] args) { MainFrame m1 = new MainFrame();//创建主窗体 m1.setVisible(true);//显示主窗体 } } 二、模型包 模型包类中对恐龙类和障碍物类进行了基本定义，恐龙类中包含对象恐龙的图片，坐标，恐龙跳跃的变量与状态与刷新时间。之后设置了如踏步，跳跃，加减速，移动和边界获取的方法。而在障碍物类中包含对对象牛仔、对象木桶和对象老鹰的图片，坐标和图片移动的速度，也设置了与之对应的方法，有移动，移除和边界获取的基本定义。
1.恐龙类 Dinosaur Dinosaur.java package pers.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f6445da72c65196635ca7589c6e64d6e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/000afd1dd635e2c44163b3689cbe1b06/" rel="bookmark">
			Echarts屏幕缩放自适应
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Echarts屏幕缩放自适应 当使用Echarts时，会设置他的大小，然后首次加载会自适应屏幕，但是渲染完成后，浏览器缩放时他不会自动再去渲染，还是原来的大小，不能动态自适应。 解决方法
//页面 &lt;div style="width: 100%; height: 160px;" id="meetings"&gt;&lt;/div&gt; //数据 data() { return { myChart1:'',} } //加载 mounted() { this.myChart1 = echarts.init(document.getElementById("meetings")); this.statusCharts(); window.addEventListener('resize',this.getResize)//开启屏幕监听缩放，刷新图表 }, beforeDestroy(){//离开页面后，删除屏幕监听，防止监听事件一直存在 window.removeEventListener('resize', this.getResize) }, methods:{ getResize(){ this.myChart1.resize(); }, statusCharts(){ this.myChart1.setOption({ })//你Echarts配置项 } } 这样就可以完美解决了！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5638b36a6c6ea3f46b3bb1c8b8f3278/" rel="bookmark">
			【Android】带下划线的TextView
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		序言 我们有时候需要一个类似这样的显示，上面是文字，下面是一条线
这样的显示效果是TextView实现不了的，需要我们自己进行修改一下。
实现 创建一个UnderlineTextView，继承系统的TextView
class UnderlineTextView(mContext: Context, attributeSet: AttributeSet) : androidx.appcompat.widget.AppCompatTextView(mContext, attributeSet) { private var underLinePains: Paint? = null init { underLinePains = Paint() underLinePains?.color = mContext.resources.getColor(R.color.agree_user_agreement_bottom_line_bg) underLinePains?.strokeWidth = 10f underLinePains?.strokeCap = Paint.Cap.SQUARE } override fun onDraw(canvas: Canvas?) { //注意这个顺序的问题，这样的顺序是先画TextView下面的带颜色的线段 underLinePains?.let { canvas?.drawLine( (0 - paddingStart).toFloat(), (height - 8).toFloat(), (width + paddingEnd).toFloat(), (height - 8).toFloat(), it ) } //现在是进行TextView里面的文本的绘制 super.onDraw(canvas) } } 这是一个很简单的View，实现了我们需要的功能，同样的当我们需要对TextView设置其他的要求时，也可以按照这种步骤实现。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad117674d0c8603423391747e9550c53/" rel="bookmark">
			命令行方式下载coco2017数据集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		命令行方式下载coco2017数据集 ​ 在你的硬盘容量足够（coco很大，18GB）的情况下，可在cmd下运行下面的命令对coco2017数据集进行下载。
# 下载训练集（2017 Train） wget http://images.cocodataset.org/zips/train2017.zip # 下载验证集（2017 Val） wget http://images.cocodataset.org/zips/val2017.zip # 下载标注文件（2017 Annotations） wget http://images.cocodataset.org/annotations/annotations_trainval2017.zip ​ 当wget命令不存在时，请安装运行下面的命令进行安装：
pip install wget ​ 接着，我们运行命令，下载coco数据训练集和标签集，效果如下图
​ 祝各位科研愉快。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6ac91c500f4efec1f0abc4b0c078c33/" rel="bookmark">
			ApplicationContext和ServletContext
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import org.springframework.beans.BeansException; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.context.event.ApplicationStartedEvent; import org.springframework.context.ApplicationContext; import org.springframework.context.ApplicationContextAware; import org.springframework.context.ApplicationListener; import org.springframework.context.ConfigurableApplicationContext; import org.springframework.stereotype.Component; import javax.servlet.ServletContext; @Component public class TestListener implements ApplicationContextAware, ApplicationListener&lt;ApplicationStartedEvent&gt; { private ApplicationContext applicationContext; @Autowired private ServletContext servletContext; @Override public void onApplicationEvent(ApplicationStartedEvent event) { //get the container who trigger the event ConfigurableApplicationContext c = event.getApplicationContext(); if (c == applicationContext) { System.out.println(servletContext); System.out.println(servletContext.getContextPath()); } // add in cusomized process. System.out.println(servletContext); System.out.println(ctx); } // interface to inject method, and access to Spring container @Override public void setApplicationContext(ApplicationContext ctx) throws BeansException { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d6ac91c500f4efec1f0abc4b0c078c33/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55f70436924aa95edfb9aea5e48de726/" rel="bookmark">
			S25FL256S介绍及FPGA实现思路
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文介绍 S25FL256S 这款 FLASH 芯片，并进行 FPGA 读写控制的实现（编程思路及注意事项）。
文章目录 S25FL-S 介绍管脚功能说明SPI 时钟模式SDRDDR 工作模式FLASH存储阵列（地址空间映射）常用寄存器及相关指令Status Register 1 (SR1)Status Register 2 (SR2)Configuration Register 1 (CR1)Autoboot Register (ABR)Bank Address Register (BAR) 关于部分常用命令的解释写使能命令（WREN 06h）写寄存器命令（WRR 01h）Autoboot读 flash 命令写 flash 命令flash 擦除命令 FPGA 实现（思路） S25FL-S 介绍 管脚功能说明 RESET#，input，硬件复位信号；CS#，input，片选信号；SCK，input，串行时钟；SI/IO0，inout，在 single mode 下的串行输入，在 Dual/Quad mode 下的 IO0；SO/IO1，inout，在 single mode 下的串行输出，在 Dual/Quad mode 下的 IO1；WP#/IO2，inout，在 single/Dual mode 下的写入保护，Quad mode 下的 IO2。在该管脚作为写入保护管脚时，当 WP# 为LOW时，在 WRR 命令期间，如果状态寄存器的状态寄存器写禁用（SRWD）位被设置为 1 时，将无法写入状态和配置寄存器，这可以防止状态寄存器的块保护（BP2、BP1、BP0）和 TBPROT 位的任何更改。同时，如果在 WRR 命令期间 WP# 为低电平，内存区域中受块保护和 TBPROT 位保护的所有数据字节也将被硬件保护，防止数据修改。WP# 芯片内部存在上拉电阻。HOLD#/IO3，inout，在 single/Dual mode 下的保持/暂停传输控制信号，Quad mode 下的 IO3。HOLD# 信号可用于暂停与设备的任何串行通信，而无需取消片选（CS#）或停止串行时钟（SCK），在 HOLD# 拉低后，若 SCK 处于 LOW，则立即进入保持状态，否则会在 SCK 的下降沿到达时进入保持状态，如下图。需注意，HOLD 不会终止已经在执行的操作。HOLD# 芯片内部存在上拉电阻。 在 SDR 情况下，FLASH 会在 SCK 上升沿寄存数据，并在 SCK 下降沿转换输出数据；在 DDR 模式下将在 SCK 的每个边沿进行数据转换。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/55f70436924aa95edfb9aea5e48de726/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cbedf73623d53221a24590c5bbd8b4e5/" rel="bookmark">
			python图像处理基础代码（分辨率、格式、删除指定文件）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import cv2 as cv import os from PIL import Image original_folder='' #原始文件夹路径 new_folder='' #保存的新文件夹路径 #遍历原始文件夹中的图像 for filename in os.listdir(original_folder) img=cv.imread(os.path.join(original_folder,filename)) img_resized=img.resize((224,224)) #要转换的尺寸 cv.imwrite(os.path.join(new_folder,filename),img) #将修改好的图片保存到新文件夹中 import cv2 as cv import os img_path = r"img_path" #图片所在目录（建议使用绝对路径） save_path = r"save_path" #转换格式后图片保存的目录 if not os.path.exists(save_path): os.makedirs(save_path) file_list = os.listdir(img_path) for i in file_list: file_path = os.path.join(img_path, i) img_mat = cv.imread(file_path, -1) filename = os.path.join(save_path, i.split(".")[0] + ".png") #修改成所需要的格式后缀，如png cv.imwrite(filename, img_mat) import cv2 as cv import os from PIL import Image dir_='' #需要修改的文件夹路径 file_list=os.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cbedf73623d53221a24590c5bbd8b4e5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc08009d4cd6c1534bb925d2f67ecf52/" rel="bookmark">
			SQL自学三部曲_Part2：十大必学语法（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、看前须知二、sqlzoo数据介绍三、基础语法和运行原理6. having&amp;简单运行原理7. 部分常见函数8. 窗口函数9. 表连接10. 子查询 四、如何继续提升1. 在题库里夯实基础2. 在笔试中不断积累3. 在实战中不断提升 系列文章 前言 本文主要介绍SQL基础语法和运行原理，但是因为内容较多，阅读起来时间较长，所以分成两篇文章
一、看前须知 本文主要适用于MySQL数据库，不过核心语句也通用于其他数据库
只学习SQL语句的查询语句部分，对于数据分析师而言完全足够（数据库就像一个图书馆，里面放了很多表；开发相当于图书管理员，会去管理图书馆；分析师只是去图书管里面选择数据进行使用，只需要知道数在哪并把它拿出来就可以了）
主要使用资源：基础语法部分基于公开网站sqlzoo的MySQL数据库引擎，必须使用英文界面练习代码（不同语言界面不同引擎可能导致数据库数据不同），并切换至Mysql引擎；小进阶部分基于自行搭建的云端数据库和外卖场景数据
SQL查询语句语法结构和运行顺序
语法结构：select–from–where–group by–having–order by–limit运行顺序：from–where–group by–having–order by–limit–select
SQL语句本身并不难，更难的是理清实际需求中的逻辑转换为SQL代码和每个表格所呈现的业务信息及多个表之间的不同连接逻辑及应用
本文是为了帮助快速入门SQL，理解SQL主要语句、语法和使用方法，可以快速解决80%以上场景的SQL问题，但仍然需要在实战中继续练习，文章的最后也提供了对应的提升路径
二、sqlzoo数据介绍 1. world
数据库引擎-MySQL一张包含每个国家信息（大洲、面积、人口、gdp、国家首都等）的表每一行数据记录了一个国家的相关信息数据部分示例
字段名-译名-解释 name-国家名continent-大洲-共有七大洲分别为：亚洲(Asia)、欧洲(Europe)、北美洲(North America)、南美洲(South America)、非洲(Africa)、大洋洲(Oceania)与南极洲(Antarctica)area-面积-国家面积population-人口gdp-gdp-Gross Domestic Product(GDP，国内生产总值)，一个国家（或地区）所有常住单位在一定时期内生产活动的最终成果，是国民经济核算的核心指标capital-首都-国家首都tld-顶级域名-国家顶级域名，中国顶级域名为.cnflag-旗帜 数据库表信息 列数：8列行数：195行字段类型
2. nobel
数据库引擎-MySQL一张诺贝尔奖获得者的名单表每一行数据记录了一名诺贝尔奖获得者及这个诺贝尔奖所属科目和年份数据部分示例
字段名-译名-解释 yr-年份-获奖年份subject-科目-获得的诺贝尔奖所属科目winner-获奖者-诺贝尔奖获得者的姓名 数据库表信息 列数：3列行数：895行字段类型
3. covid
数据库引擎-MySQL一张记录了2020年1月22号到10月9号各国每天新冠相关信息的表每一行数据记录了一个国家到截至时间的累计确诊人数、累计死亡人数、累计治愈人数数据部分示例
字段名-译名-解释 name-国家名whn-截至时间confirmed-累计确诊-截至该时间的累计确诊人数deaths-累计死亡-截至该时间的累计死亡人数recovered-累计治愈-截至该时间的累计治愈人数 数据库表信息 列数：5列行数：47946行字段类型
4. ge
数据库引擎-MySQL一张记录了2015、2017、2019年的竞选的候选人信息表每一行数据记录了当年竞选候选人的名字、姓名、所在选区编号、所属团体和得票数数据部分示例
- 字段名-译名-解释 yr-年份-举办的年份firstName-名字-候选人名字lastName-姓氏-候选人姓氏constituency-选区-所在选区编号party-团体-所属团体votes-得票数-获得选票的数量 数据库表信息 列数：6列行数：10595行字段类型
5. game、goal、eteam
数据库引擎-MySQLgame 一张记录赛事的表每一条数据记录一场赛事的编号（id），赛事的举办时间（mdate），赛事举办的场地（stadium），参加本场比赛的两个队伍（team1，team2）
goal 一张记录球员进球得分的表每一条数据记录一名进球的球员的姓名（player），进球时间（gtime），所在队伍编号（teamid），当时的赛事编号（matchid）
eteam 一张队伍表每一条数据记录一个队伍的编号（id）、名字（teamname）和教练姓名（coach）
数据部分示例 game
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dc08009d4cd6c1534bb925d2f67ecf52/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc617844408a47a87a6cfc231393e458/" rel="bookmark">
			Flutter关于获取用户相关信息权限
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		包导入 本文用到的package均来自官方提供的Dart packages
首先在pubspec.yaml文件中引用并自动下载
dependencies: flutter: sdk: flutter # The following adds the Cupertino Icons font to your application. # Use with the CupertinoIcons class for iOS style icons. cupertino_icons: ^1.0.2 contacts_service: ^0.6.3 image_picker: ^1.0.4 permission_handler: ^11.0.1 photo_manager: ^2.8.1 geolocator: ^10.1.0 安卓权限声明 获取用户授权需要在安卓的包内声明方法，
找到工程路径下android/app/src/main/AndroidManifest.xml文件
确保在标签&lt;manifest&gt;内，&lt;application&gt;外声明
&lt;!-- 获取通讯录权限 --&gt; &lt;uses-permission android:name="android.permission.READ_CONTACTS" /&gt; &lt;uses-permission android:name="android.permission.WRITE_CONTACTS" /&gt; &lt;!-- 获取存储权限 --&gt; &lt;uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE" /&gt; &lt;!-- 获取地理位置 --&gt; &lt;uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" /&gt; 开发使用 以获取通讯录权限为示例，
import 'package:flutter/material.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dc617844408a47a87a6cfc231393e458/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ec727d6cb15c713296f81b545b3a6bc/" rel="bookmark">
			深度学习基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是Pytorch？ Pytorch是torch的python版本，是由Facebook开源的神经网络框架，专门针对 GPU 加速的深度神经网络(DNN)编程。
PyTorch是Torch7团队开发的，从它的名字就可以看出，其与Torch的不同之处在于PyTorch使用了Python作为开发语言。所谓“Pythonfirst”，同样说明它是一个以Python优先的深度学习框架，不仅能够实现强大的GPU加速，同时还支持动态神经网络，这是现在很多主流框架，比如Tensorflow等都不支持的。
PyTorch既可以看做加入了GPU支持的numpy，同时也可以看成一个拥有自动求导功能的强大的深度神经网络，除了Facebook之外，它还已经被Twitter、CMU和Salesforce等机构采用。
Gpu运行效率远远大于cpu！
什么是transform？ transforms.py就像一个工具箱，里面定义的各种类就像各种工具，图片就是输入对象，经过工具处理，输出期望的图片结果。
python学习的两个小工具： 在终端中输入python或者ipython（交互式）即可打开python控制台
两个小工具：dir()和help()
什么是学习、训练？ 由用户判断这个照片是猫还是不是猫，这个结果可以拿给神经网络，神经网络拿到了同样的照片也用自己的标准去判断，判断完了以后用这个结果和你的结果进行比对，肯定是这个结果相差越小，就证明它的标准和你的标准越接近，而神经网络再根据这个差距调整自己的过程，这就是在学习就是在训练。
什么是Backbone、Head、Neck？ 在计算机视觉领域，特别是在物体检测和图像分割任务中，通常使用的神经网络结构中，"主干"、"头部"和"颈部"这些术语通常是指以下结构：
主干网络（Backbone）：
主干网络是整个神经网络的核心部分，负责提取输入数据的特征。对于图像处理任务，主干网络通常是卷积神经网络（CNN）的一部分，如ResNet、VGG、或MobileNet等。主干网络的输出通常包含丰富的高级特征，用于后续的任务，如对象检测或图像分割。 头部网络（Head）：
头部网络紧跟在主干网络之后，负责执行特定任务的输出。对于对象检测任务，头部网络可能包括用于预测边界框位置和类别的卷积和全连接层。对于图像分割任务，头部网络可能包括用于像素级别的分类或回归的层。 颈部网络（Neck）：
颈部网络位于主干网络和头部网络之间，起到连接两者的作用。颈部网络通常包括一些降维或特征融合的层，以提取并传递更具有信息量的特征给头部网络。在某些架构中，颈部网络也有助于处理多尺度信息，提高网络的鲁棒性。 这些结构的组合形成了一种分层的网络架构，其中主干网络负责提取通用特征，颈部网络用于调整特征的尺度和精度，头部网络则专注于执行特定的任务。这种模块化结构使得神经网络可以更灵活地适应不同的视觉任务。
推荐视频 安装Anaconda与PyTorch库（GPU版本）
Python深度学习：安装Anaconda、PyTorch（GPU版）库与PyCharm_哔哩哔哩_bilibili
王木头学科学
王木头学科学视频专辑-王木头学科学视频合集-哔哩哔哩视频
霹雳吧啦Wz
霹雳吧啦Wz视频专辑-霹雳吧啦Wz视频合集-哔哩哔哩视频
一：卷积神经网络基础 1.全连接层基础 全连接层的作用： 全连接层的主要功能包括：
特征组合： 通过学习连接权重，全连接层能够将前面层提取到的特征进行线性组合，形成新的特征表示。这种组合能够捕捉到不同低级特征之间的关系，从而形成更高级的特征。
非线性映射： 全连接层通常还包括激活函数，引入非线性变换。这个非线性映射使得网络能够学习复杂的非线性关系，提高模型的表达能力。
任务映射： 最终的全连接层将学到的高级特征映射到网络的输出，适应具体的任务，如分类、回归等。
全连接层结构： 最左边一层是输入层，对应的是数据的维度，数据通过这一层输入到神经网络。每一条边就是一个权重系数。
计算结果还需要经过一个激活函数才会传递到下一层，sigmoid只是符合激活函数要求的一种。
如何理解升维（下一层的神经元个数变多） 如上图所示，如果数据只是二维的，它们互相惨杂在一起，很难用直线进行划分。
而如果把它们全部升维，在更高的维度中，即便用更简单的模型也可以把它们分开
输入的数据进行了这样一个矩阵运算，矩阵对一个向量进行操作，将它变成另外一个向量。
所以我们可以把中间层看作数据的升维过程，有多少神经元就会把数据升到多少维，只要维度够高，一定可以找到一个超平面能对数据完成划分。增加模型的非线性能力，可以更好地拟合复杂的数据分布。
如何理解降维（下一层神经元个数变少） 以下图为例：利用神经网络判断一个人的心情
如果把输入图像的每一个像素当作一个输入节点，则有3500个输入节点，而我们判断一个人心情的特征只需要8个，因此一个特征不需要原始数据的所有维度，所以进行降维处理。（判断眼睛动作特征只需要原始图像的眼睛部位的像素）提高模型的泛化能力。
为什么神经元需要多层 举例：用神经网络判断输入图片是属于哪一个数字
由图示可以得出结论，隐藏层越深抽象程度越高。
增加模型的非线性能力：如果只有一层神经元，那么模型的拟合能力将受到限制，因为它只能表示线性关系。多层神经元可以增加模型的非线性能力，更好地拟合复杂的数据分布。（比如升维）
提高模型的泛化能力：使用多层神经元可以减少过度拟合的风险。如果只有一层神经元，模型可能会过度拟合训练数据，导致在测试数据上表现不佳。多层神经元可以帮助模型学习更通用的特征，从而提高模型的泛化能力。（比如降维）
增加特征的表达能力：每一层神经元都可以提取出不同的特征，通过多层神经元的组合，可以创建更复杂、更抽象的特征表示。这可以帮助模型更好地理解输入数据，并提高模型在复杂任务上的表现能力。
机器学习三要素： 反向传播： 所谓的反向传播就是把计算出来的梯度（交叉熵 偏差）反向传递到神经网络里面，让所有的W进行更新修改。
注：在深度学习网络中，反向传播的目标是计算损失函数对网络中所有可训练参数（包括全连接层、卷积层、循环层等）的梯度。这些梯度用于调整网络参数，使得网络在训练数据上的预测逐渐接近实际标签。
2.卷积层基础 在深度学习中卷积核的参数第一次是随机生成的，之后经过训练学习，通过反向传播进行参数的更新。
（1）卷积的意义 卷积的物理意义：
卷积在神经网络中意义：
（1）周围像素点对中心像素点产生的影响，g函数（卷积核的翻转）规定了如何影响
（2）过滤器：一个像素点如何试探周围的像素点，如何提取特征
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9ec727d6cb15c713296f81b545b3a6bc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e803feab3dacbfb1e1b1ac2b07b4c07b/" rel="bookmark">
			el-table操作栏添加el-dropdown获取当前行的数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 0 效果 点击子合同获取到当前行的id
1 代码 beforeHandleCommand(row, childCommand) { return { 'row': row, 'childCommand': childCommand }; }, addChildBtn(command) { const row = command.row; if (command.childCommand == 0) { // todo } else { // todo } }, 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60d8bb25ddc1e661e08f72d4a1fe3acc/" rel="bookmark">
			DateFormat类：日期格式化的便捷工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列文章目录 文章目录 系列文章目录前言一、什么是DateFormat类？二、格式化日期和时间三、解析字符串为日期和时间四、本地化支持总结 前言 前些天发现了一个巨牛的人工智能学习网站，通俗易懂，风趣幽默，忍不住分享一下给大家。点击跳转到网站，这篇文章男女通用，看懂了就去分享给你的码吧。
在软件开发中，处理日期和时间是一个常见而重要的任务。为了满足不同的需求，Java提供了DateFormat类，它是一个日期格式化的便捷工具。本文将介绍DateFormat类的基本用法以及一些常见的应用场景，帮助读者更好地理解和使用这个类。
一、什么是DateFormat类？ DateFormat类是Java中用于日期和时间格式化的类。它提供了一组方法，可以将日期和时间对象格式化为特定的字符串，或者将字符串解析为日期和时间对象。DateFormat类是抽象类，具体的实现类有SimpleDateFormat等。
二、格式化日期和时间 DateFormat类提供了format()方法，可以将日期和时间对象格式化为特定的字符串。以下是一个简单的示例：
import java.text.DateFormat; import java.text.SimpleDateFormat; import java.util.Date; public class DateFormatExample { public static void main(String[] args) { DateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); Date now = new Date(); String formattedDate = dateFormat.format(now); System.out.println("Formatted Date: " + formattedDate); } } 上述代码中，我们创建了一个SimpleDateFormat对象，并指定了日期和时间的格式。然后，使用format()方法将当前日期和时间对象格式化为字符串，并打印输出。
三、解析字符串为日期和时间 除了格式化日期和时间对象，DateFormat类还提供了parse()方法，可以将字符串解析为日期和时间对象。以下是一个简单的示例：
import java.text.DateFormat; import java.text.SimpleDateFormat; import java.util.Date; public class DateFormatExample { public static void main(String[] args) { DateFormat dateFormat = new SimpleDateFormat("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/60d8bb25ddc1e661e08f72d4a1fe3acc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f33279f6932ea3332b5fc915d6acd402/" rel="bookmark">
			深入了解SimpleDateFormat类：日期格式化的利器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列文章目录 文章目录 系列文章目录前言一、SimpleDateFormat类的概述二、日期模式三、SimpleDateFormat的常用方法四、使用示例二、常见应用场景总结 前言 前些天发现了一个巨牛的人工智能学习网站，通俗易懂，风趣幽默，忍不住分享一下给大家。点击跳转到网站，这篇文章男女通用，看懂了就去分享给你的码吧。
在Java编程中，经常需要处理日期和时间的格式化操作。SimpleDateFormat类是Java提供的一个强大的日期格式化工具，它可以将日期对象转换为特定格式的字符串，也可以将字符串解析为日期对象。本文将深入探讨SimpleDateFormat类的使用方法和常见应用场景，帮助读者更好地理解和运用这个日期格式化的利器。
一、SimpleDateFormat类的概述 SimpleDateFormat类是java.text包中的一个类，它继承自DateFormat类。它提供了一种简单而灵活的方式来格式化和解析日期。通过SimpleDateFormat，我们可以将日期对象按照指定的模式转换为字符串，也可以将字符串解析为日期对象。
二、日期模式 SimpleDateFormat类的核心在于日期模式（date pattern），它定义了日期格式化的规则。日期模式是由一系列的字母和符号组成，每个字母和符号都有特定的含义。以下是一些常用的日期模式字母：
y：年份
M：月份
d：月份中的天数
H：小时（24小时制）
h：小时（12小时制）
m：分钟
s：秒钟
除了字母之外，日期模式中的其他字符（如空格、冒号、连字符等）将会原样输出。
三、SimpleDateFormat的常用方法 SimpleDateFormat类提供了一系列的方法来进行日期格式化和解析操作。下面是其中几个常用的方法：
format(Date date)：将给定的日期对象按照指定的日期模式格式化为字符串。
parse(String source)：将给定的字符串解析为日期对象。
setLenient(boolean lenient)：设置解析日期时是否宽松模式，即容忍一些不严格的日期格式。
四、使用示例 下面是一个使用SimpleDateFormat类的示例代码，演示了如何将日期对象转换为指定格式的字符串：
import java.text.SimpleDateFormat; import java.util.Date; public class SimpleDateFormatExample { public static void main(String[] args) { Date now = new Date(); SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); String formattedDate = sdf.format(now); System.out.println("Formatted date: " + formattedDate); } } 二、常见应用场景 SimpleDateFormat类在实际应用中非常常见，以下是一些常见的使用场景：
日期显示：在界面中显示日期时，可以使用SimpleDateFormat类将日期对象格式化为特定的格式，以满足用户的需求。
日期解析：当用户在界面中输入日期时，可以使用SimpleDateFormat类将输入的字符串解析为日期对象，方便后续的日期计算和处理。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f33279f6932ea3332b5fc915d6acd402/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83cd48f3d020f8409a4b25e4647efbc4/" rel="bookmark">
			解决错误 “java.lang.IllegalArgumentException: invalid comparison: java.util.Date and java.lang.String“ 的
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列文章目录 文章目录 系列文章目录前言一、检查比较操作的数据类型：二、数据类型转换：三、使用合适的比较方法：总结 前言 前些天发现了一个巨牛的人工智能学习网站，通俗易懂，风趣幽默，忍不住分享一下给大家。点击跳转到网站，这篇文章男女通用，看懂了就去分享给你的码吧。
在 Java 开发中，有时会遇到错误信息 “java.lang.IllegalArgumentException: invalid comparison: java.util.Date and java.lang.String”，该错误表示在比较操作中使用了不兼容的数据类型（如 Date 和 String）。本文将介绍如何解决这个错误，确保正确进行数据类型的比较操作。
一、检查比较操作的数据类型： 首先，要检查在哪个比较操作中出现了错误。查看错误信息中提到的比较操作，并确认涉及的数据类型是 Date 和 String。
示例代码：
Date date = new Date(); String dateString = "2022-01-01"; if (date.compareTo(dateString) &gt; 0) { // 处理日期比较的逻辑 } 在上述示例中，我们尝试将 Date 对象和 String 对象进行比较。确保比较操作涉及的数据类型是相同的，或者根据需要进行类型转换。
二、数据类型转换： 如果在比较操作中涉及到不同的数据类型，需要进行数据类型转换以保证兼容性。
示例代码：
Date date = new Date(); String dateString = "2022-01-01"; SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd"); Date parsedDate = dateFormat.parse(dateString); if (date.compareTo(parsedDate) &gt; 0) { // 处理日期比较的逻辑 } 在上述示例中，我们使用 SimpleDateFormat 类将字符串日期转换为 Date 类型，以确保在比较操作中使用相同的数据类型。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/83cd48f3d020f8409a4b25e4647efbc4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58d4768f862e2294fab41a5386e3ee85/" rel="bookmark">
			深入了解 SQL 中的条件查询：WHERE 子句
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列文章目录 文章目录 系列文章目录前言一、WHERE 子句的语法和基本用法总结 前言 前些天发现了一个巨牛的人工智能学习网站，通俗易懂，风趣幽默，忍不住分享一下给大家。点击跳转到网站，这篇文章男女通用，看懂了就去分享给你的码吧。
在 SQL 数据库中，条件查询是一种非常常见和重要的操作，它用于从表中筛选出符合特定条件的数据。本文将深入探讨 SQL 中的 WHERE 子句，包括语法、常见的比较运算符和逻辑运算符，以及一些示例演示如何使用 WHERE 子句进行条件查询。
一、WHERE 子句的语法和基本用法 在 SQL 中，WHERE 子句用于在 SELECT、UPDATE 或 DELETE 语句中指定一个条件，以筛选出满足该条件的数据。WHERE 子句的基本语法如下：
SELECT column1, column2, ... FROM table WHERE condition; 在 WHERE 子句中，condition 是一个布尔表达式，它由一个或多个比较运算符和逻辑运算符组成，用于判断每条记录是否满足条件。
常见的比较运算符
比较运算符用于在 WHERE 子句中进行值的比较，常见的比较运算符包括：
：大于
=：等于
&lt;&gt; 或 !=：不等于
&lt;：小于
&lt;=：小于等于
=：大于等于
可以根据具体需求选择适当的比较运算符来定义条件。
常见的逻辑运算符
逻辑运算符用于在 WHERE 子句中组合多个条件，常见的逻辑运算符包括：
AND：逻辑与，同时满足所有条件
OR：逻辑或，满足任一条件
NOT：逻辑非，取反条件
可以使用括号来控制条件之间的优先级和组合关系。
示例演示
下面是一些示例演示如何使用 WHERE 子句进行条件查询：
查询学生表中年龄大于等于 18 岁的学生：
SELECT * FROM students WHERE age &gt;= 18; 查询订单表中订单金额大于 1000 并且状态为已支付的订单：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/58d4768f862e2294fab41a5386e3ee85/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa7b494c87404433c8c70412a6de3330/" rel="bookmark">
			Vue 中页面传值的多种方式详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列文章目录 文章目录 系列文章目录前言一、通过路由传参二、通过 Vuex 进行状态管理三、通过 Props 属性传值四、通过事件传递数据总结 前言 前些天发现了一个巨牛的人工智能学习网站，通俗易懂，风趣幽默，忍不住分享一下给大家。点击跳转到网站，这篇文章男女通用，看懂了就去分享给你的码吧。
在 Vue 开发中，页面间的数据传递是一个常见的需求。为了实现页面间的交互和数据传递，Vue 提供了多种方式供开发者使用。本文将详细介绍 Vue 中页面传值的多种方式，帮助您根据具体场景选择合适的方法进行数据传递。
一、通过路由传参 Vue 路由是一种常见的页面导航和参数传递方式。可以通过路由的方式在页面之间传递参数。
通过路由参数传值：可以通过路由的动态参数或查询参数传递数据。在源页面设置参数，然后在目标页面通过 $route.params 或 $route.query 访问参数。
示例代码：
// 路由配置 const router = new VueRouter({ routes: [ { path: '/source/:id', component: SourceComponent, }, // 其他路由配置... ], }); // 源页面 &lt;template&gt; &lt;router-link :to="{ path: '/source/1' }"&gt;跳转到目标页面&lt;/router-link&gt; &lt;/template&gt; // 目标页面 &lt;template&gt; &lt;div&gt; &lt;p&gt;参数传递的值：{{ $route.params.id }}&lt;/p&gt; &lt;/div&gt; &lt;/template&gt; 通过路由状态传值：可以通过路由的状态对象传递数据。在源页面设置状态对象，然后在目标页面通过 $route.meta 访问状态对象。
示例代码：
// 路由配置 const router = new VueRouter({ routes: [ { path: '/source', component: SourceComponent, meta: { data: { id: 1, name: 'John', }, }, }, // 其他路由配置.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aa7b494c87404433c8c70412a6de3330/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88a30a6c87bd8aafb6baa41498a027fe/" rel="bookmark">
			Vue 中使用 el-date-picker 限制只能选择当天、当天之前或当天之后日期的方法详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列文章目录 文章目录 系列文章目录前言一、限制只能选择当天的日期二、限制只能选择当天之前的日期三、限制只能选择当天之后的日期总结 前言 前些天发现了一个巨牛的人工智能学习网站，通俗易懂，风趣幽默，忍不住分享一下给大家。点击跳转到网站，这篇文章男女通用，看懂了就去分享给你的码吧。
在 Vue 前端开发中，使用 el-date-picker 组件进行日期选择是常见的需求。有时候我们需要限制用户只能选择当天、当天之前或当天之后的日期，以提升用户体验和数据的准确性。本文将详细介绍如何使用 el-date-picker 组件实现这些限制，让你能够轻松应对各种日期选择场景。
一、限制只能选择当天的日期 要限制只能选择当天的日期，我们可以使用 el-date-picker 组件的 picker-options 属性结合 disabledDate 方法。
&lt;template&gt; &lt;div&gt; &lt;el-date-picker v-model="selectedDate" :picker-options="pickerOptions" &gt;&lt;/el-date-picker&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return { selectedDate: null, pickerOptions: { disabledDate(time) { return time.getTime() &gt; Date.now(); }, }, }; }, }; &lt;/script&gt; 以上代码中，我们通过设置 pickerOptions 对象的 disabledDate 方法，将时间大于当前时间的日期禁用，从而实现只能选择当天的日期。
二、限制只能选择当天之前的日期 如果需要限制只能选择当天之前的日期，可以使用 disabledDate 方法进行处理。
代码如下（示例）：
&lt;template&gt; &lt;div&gt; &lt;el-date-picker v-model="selectedDate" :picker-options="pickerOptions" &gt;&lt;/el-date-picker&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return { selectedDate: null, pickerOptions: { disabledDate(time) { return time.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/88a30a6c87bd8aafb6baa41498a027fe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ff73cd0e2e83d05d20f990aa050ad64/" rel="bookmark">
			springboot访问请求404解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 前些天发现了一个巨牛的人工智能学习网站，通俗易懂，风趣幽默，忍不住分享一下给大家。点击跳转到网站，这篇文章男女通用，看懂了就去分享给你的码吧。
首先，请确保用于访问资源的URL是正确的。仔细检查URL的拼写和格式，以确保它与代码中的端点匹配。
如果URL正确，则问题可能与控制器映射有关。请检查控制器方法是否使用@RequestMapping或类似注释进行了正确注释，并且端点是否与您试图访问的URL匹配。
另一个潜在的问题可能是应用程序的配置。通过确保包含必要的依赖项并正确注释@SpringBootApplication类，检查您的应用程序是否已正确配置为处理请求。
如果这些解决方案都不起作用，那么检查服务器日志以获取有关错误的更多信息可能会有所帮助。日志可以提供关于导致404错误的原因的附加上下文。
新手在刚接触springboot的时候，可能会出现访问请求404的情况，代码怎么看都是对的，但就是404。
在十分确定代码没问题的时候，可以看下自己的包是不是出问题了，什么意思么？
答案：SpringBoot 注解 @SpringBootApplication 默认扫描当前类的同包以及子包下的类； 如：启动程序在包名 com.yang.test.ymkribbonconsumer下，则会查找所有 com.yang.test.ymkribbonconsumer下的文件以及 com.yang.test.ymkribbonconsumer 下的所有子包里面的文件。
比如：
这种路径就会报404。
如果换成这种
这样就不会报404了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/daa552f9353e7d6b0d02542680ee5510/" rel="bookmark">
			Java 将多个文件打包为压缩包进行下载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1：工具类
```csharp import java.io.BufferedInputStream; import java.io.File; import java.io.FileInputStream; import java.io.IOException; import java.io.InputStream; import java.io.OutputStream; import java.net.URLEncoder; import java.util.List; import java.util.zip.ZipEntry; import java.util.zip.ZipOutputStream; import javax.servlet.http.HttpServletResponse; public class ZipUtils { /** * 导出 * @param response * @param files 要进行压缩的文件数组 * @param fileNames 压缩的文件要修改成别的名子数组 * @param zipName 压缩包名称 * @return zip文件 * */ public static void createZipFile(HttpServletResponse response, List&lt;File&gt; files, List&lt;String&gt; fileNames, String zipName) { // 输出响应 ZipOutputStream zipStream = null; response.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/daa552f9353e7d6b0d02542680ee5510/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec391122c2e5477dea1880aa859155a9/" rel="bookmark">
			【算法】最短路径——弗洛伊德 (Floyd) 算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1.概述2.代码实现3.扩展3.应用 1.概述 （1）弗洛伊德 (Floyd) 算法又称为插点法，是一种利用动态规划的思想寻找给定的加权图中多源点之间最短路径的算法，与 Dijkstra 算法类似。该算法名称以创始人之一、1978 年图灵奖获得者、斯坦福大学计算机科学系教授罗伯特·弗洛伊德命名。
（2）弗洛伊德 (Floyd) 算法的具体思路如下：
创建一个二维数组 dist，用于存储任意两个顶点之间的最短路径长度。初始化 dist 数组，将每条边的权重赋值给对应的 dist[i][j]，其中 i 和 j 分别表示边的起点和终点。使用三重循环，分别遍历每一个顶点 k，将顶点 k 作为中间节点，更新 dist 数组。对于每一对顶点 i 和 j，如果 dist[i][j] 大于 dist[i][k] + dist[k][j]，则更新 dist[i][j] 为 dist[i][k] + dist[k][j]。最终，dist 数组中存储的就是每对顶点之间的最短路径长度。 该算法的核心思想是通过动态规划逐步构建最短路径。通过逐渐扩展考虑的中间节点集合，可以确保得到最终的最短路径。通过多次迭代，每对顶点之间的最短路径逐渐更新，直到遍历完所有的中间节点，得到最后的最短路径矩阵。
（3）弗洛伊德 (Floyd) 算法的时间复杂度和空间复杂度分别如下：
时间复杂度为 O(V3)，弗洛伊德算法使用三重循环来迭代更新所有顶点对之间的最短路径，其中 V 表示图中顶点的数量。因此，算法的时间复杂度为 O(V3)。空间复杂度为 O(V2)：算法需要使用一个二维数组来存储图中顶点对之间的最短路径距离，因此空间复杂度为 O(V2)。 有关 Dijkstra 算法的具体介绍可以参考【算法】最短路径——迪杰斯特拉 (Dijkstra) 算法这篇文章。
2.代码实现 （1）有关 Floyd 算法分别使用邻接矩阵和邻接表实现的说明如下：
Floyd 算法可以使用邻接表实现，但相比邻接矩阵，使用邻接表会增加一些复杂度，因为邻接表中存储了每个节点的出边信息，并没有存储到达该节点的边的信息。因此，在计算两个节点之间的距离时，需要遍历邻接表中连接这两个节点的所有边，这可能会使得算法的时间复杂度和空间复杂度都增加。另外，使用邻接表需要额外的开销来维护节点之间的关系。具体实现时，可以将每个节点的出边信息存储在一个链表、向量等动态数据结构中。为了能够以常数时间检查两个节点之间是否有边，可以使用哈希表来存储每个节点的出边信息。在遍历所有节点对时，对于每对节点 i 和 j，需要分别遍历它们的出边列表，以找到连接它们的路径。总之，虽然 Floyd 算法可以使用邻接表实现，但邻接矩阵更为简单和直观，并且在实现中运行时间更短和更节省空间。只有在图的规模比较大、稀疏程度比较高时，才考虑使用邻接表来表示图和实现弗洛伊德算法。 （2）下面给出 Floyd 算法的邻接矩阵实现：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ec391122c2e5477dea1880aa859155a9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1c04cd845fab828b9829d4a7a2a097c/" rel="bookmark">
			STM32的各种疑难杂症和小技巧
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里是目录 疑难杂症定时器输入捕获HAL库修改输入捕获的极性 PWM输出标准库初始化配置TIM1、TIM8高级定时器 无法烧录程序提示Could not stop Cortex-M device!Please check the JTAG cable.提示No Cortex_M SW Device Found、Error: Flash Download failed - Target DLL has been cancelled 小技巧三种启动模式 疑难杂症 定时器 输入捕获 HAL库修改输入捕获的极性 HAL库在用库函数调整输入捕获的极性时，要先重置上一次的设定，才能修改成功： TIM_RESET_CAPTUREPOLARITY(&amp;htim1,TIM_CHANNEL_1); TIM_SET_CAPTUREPOLARITY(&amp;htim1,TIM_CHANNEL_1,TIM_INPUTCHANNELPOLARITY_RISING); 如上述代码所示，在用TIM_SET_CAPTUREPOLARITY()函数修改输入捕获的极性前，要先用TIM_RESET_CAPTUREPOLARITY（）函数重置一下设置，才能修改成功，否则会无法修改。（这一条目前只在STM32F407系列单片机上使用过，不确定其他系列单片机是否有这种要求，当然也有可能HAL库更新到某一版本后就没有这个要求了） PWM输出 标准库初始化配置TIM1、TIM8高级定时器 标准库在初始化高级定时器TIM1、TIM8时，和初始化普通定时器不同，需要多调用一个函数才能正常输出PWM信号： TIM_CtrlPWMOutputs(TIM8,ENABLE); 这一条目前只在STM32F407系列单片机上使用过，不确定其他系列单片机是否有这种要求，当然也有可能HAL库更新到某一版本后就没有这个要求了 无法烧录程序 提示Could not stop Cortex-M device!Please check the JTAG cable. 弹出如下图所示的两个提示框
我出现这个问题的原因非常奇怪，是因为我板子上的复位电路（如下图所示，按键没按下时，复位信号线被上拉电阻R2拉高，按下后复位信号线上电平被开关拉低至GND从而产生复位，电容的目的是为了消抖防误触等）里的电容坏了，导致NRST信号线被拉低至了0.7V左右，从而芯片一直处于复位状态而产生的这个bug。把该电容去掉或者更换一个新的后该问题即得到解决，可以成功烧录程序。
提示No Cortex_M SW Device Found、Error: Flash Download failed - Target DLL has been cancelled 如下图所示，出现这个问题的原因是，PLL锁相环电路设置不正确导致芯片运行频率过高锁死（一般情况都是，原本跑在8MHz晶振板子上的程序，换到了一个25MHz晶振的板子上运行，你不知道它是25MHz或者忘记修改程序了而导致的）
解决办法也很简单，因为STM有三种启动模式，而只有一种是从默认的主闪存存储器启动（即从STM32的片上Flash启动，STM32的片上Flash也是存储用户编写的程序的地方），因此修改BOOT引脚的高低电平，不从flash启动，芯片就不会因频率过高而自锁，从而就可以烧录进去修改后的设置正确的程序，再把BOOT引脚改过来，即可正常使用。 小技巧 三种启动模式 STM32是现在非常流行的一款单片机，它一共有三种启动方式，如下图所示：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c1c04cd845fab828b9829d4a7a2a097c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e12b937f4c2dc9ef9ac9b4de9a27ba76/" rel="bookmark">
			Feign调用返回值统一处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		因为接口一般有固定的返回格式，有数据、返回码和异常时错误信息。
不做任何处理情况下，需要在调用Feign的业务代码处通过判断返回码来获取数据。这种重复的代码可以抽出来统一处理。
解决方法1 使用自定义Decoder来统一处理，重写Object decode(Response response, Type type)方法。
自定义解析类 import feign.FeignException; import feign.Response; import feign.codec.Decoder; import lombok.extern.slf4j.Slf4j; import org.springframework.beans.factory.ObjectFactory; import org.springframework.beans.factory.SmartInitializingSingleton; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.autoconfigure.http.HttpMessageConverters; import org.springframework.cloud.openfeign.support.ResponseEntityDecoder; import org.springframework.cloud.openfeign.support.SpringDecoder; import java.io.IOException; import java.lang.reflect.Type; @Slf4j public class FeignDecode implements Decoder, SmartInitializingSingleton { private Gson gson = new Gson(); @Autowired private ObjectFactory&lt;HttpMessageConverters&gt; messageConverters; private ResponseEntityDecoder responseEntityDecoder; @Override public Object decode(final Response response, Type type) throws IOException, FeignException { Object result = responseEntityDecoder.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e12b937f4c2dc9ef9ac9b4de9a27ba76/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cbfa4462083a39aac7044ccb6f505c02/" rel="bookmark">
			YOLOv8-seg 分割代码详解（一）Predict
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 YOLOv8-seg 分割代码详解（一）Predict
YOLOv8-seg 分割代码详解（二）Train
YOLOv8-seg 分割代码详解（三）Val
本文从 U-Net 入手熟悉分割的简单方法，再看 YOLOv8 的方法。主要梳理 YOLOv8 的网络结构，以及 Predict 过程的后处理方法。
U-Net 代码地址：https://github.com/milesial/Pytorch-UNet
YOLOv8 代码地址：https://github.com/ultralytics/ultralytics
YOLOv8 官方文档：https://docs.ultralytics.com/
1. U-Net 1.1 网络结构 CBR Conv2d(3, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False) BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) ReLU(inplace=True) 1.2 转置卷积 torch.nn.ConvTranspose2d( in_channels, out_channels, kernel_size, stride=1, padding=0, output_padding=0, groups=1, bias=True, dilation=1, padding_mode='zeros', device=None, dtype=None ) H o u t = ( H i n − 1 ) × stride [ 0 ] − 2 × padding [ 0 ] + dilation [ 0 ] × ( kernel_size [ 0 ] − 1 ) + output_padding [ 0 ] + 1 H_{out} = (H_{in} - 1) \times \text{stride}[0] - 2 \times \text{padding}[0] + \text{dilation}[0] \times (\text{kernel\_size}[0] - 1) + \text{output\_padding}[0] + 1 Hout​=(Hin​−1)×stride[0]−2×padding[0]+dilation[0]×(kernel_size[0]−1)+output_padding[0]+1
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cbfa4462083a39aac7044ccb6f505c02/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37e9254c26fe77201924fc4bd4387463/" rel="bookmark">
			笔记017
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		总有一天，我一定要把来时的路，重新走一遍！
王圣豪
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96199c9b573322abf4b1a6eca406fcde/" rel="bookmark">
			词云库wordcloud的安装和应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、安装词云库
二.应用词云库
1.输出图片
2.读取输出遮罩图片
三、jieba库介绍
一、安装词云库 1) pip install wordcloud #网络安装
2)python -m pip install 本地路径 #本地安装
二.应用词云库 生成步骤:
创建词云对象--&gt;加载词云文本--&gt;输出词云图片（文件）
（1）默认的矩形词云图片
（2）提供的图形词云图片
1.输出图片 1）导入wordcloud库模块
导入可以输出图片的模块PIL
2）创建词云对象时需注意wordcloud方法需大写W和C，wordcloud.WordCloud()
3）with open() as file: 打开文件，即开机关。
4)utf-8编码输出中英文。
2.读取输出遮罩图片 1）再多导入一个库读取遮罩图片（无坐标轴）
2）进阶版：导入一个数据可视化库里面一个基础图库pyplot（有坐标轴）
plt.imshow(wc)可以代替wc.to_file()和Image.open()这两步，它可以直接绘制词云图片并显示在当前二维列表中
三、jieba库介绍 jieba库是Python中一个重要的第三方中文分词函数库。
原理：利用一个中文词库，将待分词的内容和分词词库进行对比，通过图结构和动态规划方法找到最大概率的词组。jieba还提供自定义中文单词的功能。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1dd50ab58ca7c6e2e7f8665b49393ec2/" rel="bookmark">
			2311rust到27版本更新
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.23 从Rust1.0开始,有叫AsciiExt的特征来提供u8,char,[u8]和str上的ASCII相关功能.要使用它,需要如下编写代码:
use std::ascii::AsciiExt; let ascii = 'a'; let non_ascii = ' '; let int_ascii = 97; assert!(ascii.is_ascii()); assert!(!non_ascii.is_ascii()); assert!(int_ascii.is_ascii()); 在Rust1.23中,现在直接在这些类上定义这些方法,因此不再需要导入trait.
#[allow(unused_imports)] use std::ascii::AsciiExt; //也可继续以前导入. 来抑制相关警告.
此外,新API:
现在从非原子类型实现各种std::sync::atomic类型.如,
let x = AtomicBool::from(true); ()现在实现了FromIterator&lt;()&gt;;
RwLock&lt;T&gt;已取消发送限制
货物特点
1,Cargo Check现在可检查你的单元测试.
2,cargo uninstall现在可在一个命令中卸载多个包.
1.24 rustup component add rustfmt-preview //格式组件. 有两点:首先,在此使用的是
rustup component add //而不是 cargo install 如果以前通过cargo install使用过rustfmt,应该先卸载它.
其次,这是一个预览.
增量编译 从Rust1.24开始,默认增量编译.
要在Cargo.toml中设置codegen-units为1(或16),以提升每一滴性能.
未定义行为.Rust一般努力减少未定义行为,在安全代码中没有未定义行为,在不安全代码中尽量少.
跨越FFI边界,恐慌(panic)!时,可调用UB.即:
extern "C" fn panic_in_ffi() { panic!("Test"); } 在Rust1.24中,代码现在中止,而不是ub.
str::find,在&amp;str中查找给定的符:它现在快了10倍!这要归功于memchr.[u8]::contains也用它.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1dd50ab58ca7c6e2e7f8665b49393ec2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d951d3a7b71a5fbbca0b00cccd0e5227/" rel="bookmark">
			如何在GitHub中下载YOLOv5
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1）加速器 https://steampp.net/（该加速器可以对GitHub进行加速）
根据自己的电脑，下载对应的版本
加速模式建议改成PAC代理模式
下载完成后点击GitHub，一键加速
2）yolov5的选取 在右上角的搜索框中搜索：yolov5
在这个界面中可以看到第一个的收藏量非常高，这个就是最为核心的yolov5框架
可以看到在收藏旁边有（update 4 hours ago）四小时前刚刚更新
3）必要操作 点击进入后，第一步先查看readme文件
可以看到有两个readme文件，下面readme.zh-CN表示已翻译成中文，点击这个即可
在这里我们可以看到关于它的一些介绍与要求
根据要求进行下载安装，否则文件会报错运行不起来
如果你的版本低于要求版本怎么办？不着急，看我操作
我们先退回yolov5主界面，选择左上角master下的Tags，在这里我们可以选取yolov5的版本，根据自己电脑的配置，可以选择较低的版本
默认是打开最新版本，也就是v7.0，这里我选取v6.0版本
可以看到，v6.0版本要求python&gt;=6.0，pytorch&gt;=1.7，相较于v7.0版本要求的配置会有所降低
4）requirements.txt文件 除上述操作外，还需要查看requirements文件，里面同样包含了一些配置的要求
点击进入
这时v6.0版本的配置要求
所以下载前一定要先看好配置要求，选取对应的版本进行下载
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e87ff51327e63dc72863dbbf1283ea1/" rel="bookmark">
			【计算机开题报告】基于微信小程序的点餐系统设计与实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于微信小程序的点餐系统设计与实现
1. 课题研究目的和意义； 近年来，随着国家的改革和建设，社会的不断进步、经济的加速发展使得人们的购买力也在逐渐增加，消费的类型变得更加多元化。 在这样的大趋势之下，智能时代的到来，人们对生活效率的追求越来越高，以往的点餐系统效率低下浪费物力人力。而小程序在人们生活中就变得更加符合需求，小程序让餐饮行业迎来新春天,小程序正在餐饮行业中迅速普及，逐渐渗入到预约、到店点餐、外卖等使用场景中。2020年5月份的腾讯财报提到，微信小程序用户迅速增长，日均活跃帐户数已经超过4亿，由此可见，小程序正爆发出巨大的市场潜力。在餐饮行业，2019年，餐饮相关的小程序已经超过20万个，覆盖茶饮、快餐、正餐等6大餐饮行业和20多个场景，日均交易金额超1.5亿。小程序实现了应用的无处不在、随时可用，且不需要软件安装和卸载，基于小程序的点餐系统从某种角度上方便用户点餐。针对商户而言，可以满足简单的基础应用，非常适合生活服务类的线下商店，降低了餐厅的经营成本，减少人工的雇佣费，吸引更多的潜在客户。对于点餐系统的用户来讲，小程序的点餐系统做到了“用完即走”的概念，减轻手机内存的负担，操作方便简洁，此系统将点餐与互联网相结合，避免了店里面繁琐的点餐和付款排队环节，让用户可以直观方便地进行点餐和直接使用微信支付进行付款，相比传统的餐厅点餐更加人性化，也更加注重用户体验。针对小程序的开发者而言，其开发门槛相对其他较低、难度也不及App。本系统的设计，对开发者而言，不仅提高了开发者的开发效率和能力，对于云开发的使用，使得开发程序的审核、备份和开发系统的更新迭代变得更加轻松，代码几乎可以实现实时云备份将个人数据资料通过云存储的方式备份在网络上面，同时也给后来者提供很好的参考意见。
现实意义：
作为用户，微信点餐小程序系统解决了人们排队难、排队拥堵的现象，减少等待时间，通过餐饮小程序用户可以随时预定、随时排队、随时提醒，获得商家惊喜优惠领取优惠券，同时通过小程序进行外卖点餐。
作为商家，微信点餐小程序系统运行成本低、利润空间大、功能完善，商家做生意本就为了赚钱，美团、饿了么、口碑等平台高额的平台服务费和扣点大大压缩了商家的运营成本，而小程序没有这些费用，开发门槛也比较低。不只是肯德基、星巴克这样的大品牌，现在很多中小餐饮行业也通过自己专属的小程序来增加公司的品牌影响力，除此之外商家还可以在小程序上通过附近商家、优惠券、砍价、拼团等活动来吸引更多的用户到店消费，同时也为商家大大的节省了宣传成本。并且商家还可以小程序后台所生成的精细化数据进行深度分析，围绕不同的客户群体开展内容运营、会员营销，不断提升用户体验，刺激用户的再次消费。小程序简单方便的会员使用体验和高效的会员管理体系，拉动了餐饮类小程序的会员持续消费。显然，餐饮类小程序正在重塑用户的餐饮消费习惯，有逐渐代替传统点餐服务的趋势。此外，小程序还会让餐饮商户跳出近年来外卖平台的流量局限，重新掌握流量的自主权。
2.文献综述（课题研究现状及分析）； 1.理论的渊源及演进过程：
随着高新科技的不断发展，信息化水平的日益提高，越来越多的餐饮企业开始意识到餐饮信息化的重要性，也在积极的考虑如何将信息化技术融入到自己的餐饮管理中。通过创新，餐饮业主不仅可以降低成本，为客户提供更好的服务并获得额外的经济效益。顾客也会感到更加满意。后面我们所看到的类似于手机的一些餐饮服务系统、餐饮管理系统也逐渐开发成功并且慢慢的投入到新兴的餐饮行业中，给国内的餐饮业带来了新机。它给服务员大大节省了时间，使用掌上终端或者是平板，服务员不必离开桌子把点菜单给到厨房或者是酒水区，便可直接准确无误的下单至后厨。服务员也不需要利用纸笔手写菜单，节省了餐厅日常开支，提高了点菜速度，减少了顾客的等待时间，提高了服务质量和翻单率，增加了客户的满意度和好评率。而且服务员可以服务多个餐桌，大大提高了服务效率，节约了人力成本。
在30年的发展进程中，餐饮业作为我国第三产业中的一个传统服务性行业，始终保持着旺盛的发展势头。据中国烹饪协会提供的资料显示，在改革开放前夕的1978年，全国餐饮业的经营网点不足12万个，员工104.4万，零售额54.8亿元。自1991年以来，全国餐饮业的经营网点已突破800万个，员工已突破9000万，销售额年平均550亿元以上。2006年全国餐饮业零售额突破1万亿元大关，达到10345.5亿元、同比增长16.4%,拉动社会消费品零售总额增长2.2个百分点。2007年以来，随着人民生活水平和餐饮社会化程度的逐步提高，我国餐饮产业再创佳绩，餐饮消费持续快速增长，餐饮业经营网点数量的增长速度在我国第三产业中攀升至第一。
随着市场竞争的加剧，许多酒店、餐厅也开始着手利用高科技来改变餐饮服务模式和经营模式，无线点菜系统应运而生。传统餐饮行业与互联网商圈这一现代化工具的结合早就如火如荼地展开了，餐饮020也已成为赤手可热的名词，很多餐厅、酒店都已开始走上020之路。微博营销、微信公众平台、APP客户端、020交易平台，各种工具、手段全面利用;推广营销、外卖外送、线下打折促销活动、优惠券发放等各项服务线上线下双管齐下。如今，抢客户、争流量大战己进入白热化阶段，在互联网商圈掀起了一阵融资注资热潮。
2.国内外对本课题的研究现状和有待解决的问题：
欧美等西方发达国家信息技术起步早，各个行业的信息化变革出现较早。相比较国内，欧美国家餐厅建设电子化点餐平台的起步较早。例如德国在07年出现了世界第一个无人餐厅，餐厅中所有服务均由机器自动化完成。顾客可以通过店内的计算机设备完成菜品浏览、点餐与结算。无人餐厅秩序良好，效率高效，及时在用餐高峰期也没有出现顾客长时间排队、等待等问题，顾客对用餐环境非常满意。这种完全将餐厅服务的自动化餐厅的出现与良好运营，向大家展示了信息技术对餐饮行业的变革作用。日本一家餐厅在德国无人餐厅的基础上，适应目前移动互联网的发展趋势，将点餐系统移植到智能终端。顾客可以通过餐厅APP提前预约点菜，可以节约顾客的等待时间，进一步向人们展示出了信息时代智能点餐系统给人们生活带来的便捷。从历史发展来看，欧美餐饮行业的信息化变革分以下几个阶段：
（1）餐厅内有线点餐系统
餐饮行业传统人工点餐方式中，菜品的记录与订单管理的介质都是纸质的，容易出现下单错误的问题。从80年代开始，随着计算机技术的迅速普及与各种信息管理系统的发展，餐厅开始建立自身的订单管理系统，借助计算机技术完成下单、结算等业务的电子化。在这一阶段，点餐系统的终端往往是PC端。
（2）餐厅内无线点餐系统
从80年代末开始，随着嵌入式技术的发展与无线局域网的出现，基于移动PAD的餐厅内无线点餐系统开始出现。借助该系统，服务员可以通过手持的PAD完成下单。该方式的出现很大程度上提高了餐厅业务效率。
（3）基于互联网的无线点餐系统
从90年代开始，随着互联网与智能手机的迅速普及，餐厅的信息化建设步入一个全新的时代。目前，众多餐厅定制研发了手机应用程序，顾客可以通过餐厅的手机端应用在线进行各种浏览与操作。例如，法国巴黎的Storific是一款典型的移动端点餐应用，顾客无需服务员无需到店都可以浏览菜品、预约下单、在线支付。
餐饮020日益渗透到我们的日常生活中，消费者的消费习惯和消费观念也发生了重大变化。消费者已更多的去关注点评类网站，微博、微信公众平台等，根据餐饮消费调查，这些平台对消费者做出餐饮消费选择的影响明显加强。而且，当前消费者对020的应用不止集中在预订，还逐渐向点餐、支付等综合功能深入扩展。例如，直接在APP客户端进行点餐，支持前台付款、快速担保及信用卡预付等。
3.本人对所查文献的评述： 经过对国内各个阶段与国外餐饮行业点餐模式的综合性分析，餐饮行业基本目的都是为了让顾客感受到极高的用餐体验的舒适度；菜品与点餐模式相融合是吸引顾客的极其有效的手段，同时也对本地的特色餐饮文化进行了传承和发展；点餐模式的变革也是极为重要的一环，加强餐饮行业的信息化变革也是刻不容缓。微信小程序点餐系统正是对于线上点餐系统这以餐饮行业的长期可持续性发展提供了技术性的支持，实现了餐饮行业的品牌建设，顾客体验提升和商家运营成本压缩。显然，餐饮类小程序正在重塑用户的餐饮消费习惯，有逐渐代替传统点餐服务的趋势。此外，小程序还会让餐饮商户跳出近年来外卖平台的流量局限，重新掌握流量的自主权。
3.基本内容、拟解决的主要问题；
基于微信小程序的点餐系统后台采用Java的SSM框架进行后台管理开发，可以在浏览器上登录进行后台数据方面的管理，MySQL作为本地数据库，基于微信小程序的点餐系统用到了微信开发者工具，充分保证系统的稳定性。
基于微信小程序的点餐系统分为管理员与用户两种操作权限。
管理员功能有个人中心，用户管理，菜品管理，新上菜品管理，预定订单管理，活动信息管理，用户评价管理，系统管理，订单管理等。用户功能有个人中心，订购菜品，我的订单，我的收藏，评价菜品等。
4.技术路线或研究方法； （1）通过查阅文献、技术论坛来选择合理的技术框架和路线，保证技术能够满足毕业设计的需要；
（2）通过分析比较不同的技术方法的优点和缺点，保证所选技术路线和方案是最佳；
（3）微信小程序技术是目前比较主流的技术，可结合微信小程序技术实现对本课题的用户端开发。
5.进度安排； 2021年09月20日-2021年10月20日 收集资料，落实设计题目和书写开题报告。
2021年10月21日-2021年10月30日 提交开题报告，并针对开题报告进行答辩。
2021年10月31日-2022年01月10日 收集资料，进行需求分析，系统分析。
2022年01月11日-2022年04月30日 对系统进行总体规划，数据库设计，并实现程序代码，完成系统调试。
2022年05月1日-2022年05月20日 修改完善毕业设计和论文，提交论文成稿。
6.主要参考文献 [1]陈帅.微信点餐系统小程序的设计与实现[J].电子技术与软件工程,2021(24):30-31.
[2]高天搏,刘伟.基于微信小程序的食堂订餐系统[J].科学技术创新,2021(29):74-76.
[3]张苗苗,罗雅过,吕嘉琦.微信小程序订餐系统设计[J].无线互联科技,2020,17(24):26-27.
[4]李昊. 基于微信小程序的智能推荐点餐系统的设计与实现[D].南京邮电大学,2020.DOI:10.27251/d.cnki.gnjdc.2020.000283.
[5]李新锦,鲁志萍,刘苑如.基于微信小程序的校园点餐系统的设计[J].电脑知识与技术,2020,16(07):50-51+56.DOI:10.14004/j.cnki.ckt.2020.0756.
[6]余丽娜.微信小程序订餐系统设计与实现[J].信息通信,2020(02):131-132.
[7]蒋智慧,童莲.基于微信小程序的食堂点餐系统的设计与实现[J].现代信息科技,2019,3(24):14-16.DOI:10.19850/j.cnki.2096-4706.2019.24.004.
[8]杭莉,聂莉娟.基于微信小程序的点餐系统[J].电子制作,2019(23):54-58.DOI:10.16589/j.cnki.cn11-3571/tn.2019.23.019.
[9]韦娟,张瑞娟,孙兆丰.基于微信小程序的食堂点餐系统的设计[J].电子世界,2019(22):147-148.DOI:10.19353/j.cnki.dzsj.2019.22.074.
[10]王艳辉.基于微信小程序订餐系统的设计与研究[J].信息与电脑(理论版),2019,31(21):97-98.
[11]蒋东龙,孙铭锐,李江岱.基于微信小程序点餐系统的设计与实现[J].饮食科学,2019(04):134.
[12]申燕萍,何梦磊.基于微信小程序的点餐系统[J].电脑知识与技术,2018,14(04):62-63+83.DOI:10.14004/j.cnki.ckt.2018.0382.
[13]宋丹丹.基于微信小程序的美食点餐推荐系统的设计与实现[J].信息通信,2017(12):89-90.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b056fe0c0e51a6d7e8fb814ad6d4da6/" rel="bookmark">
			《Hello Solidity！》之 随机数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随机数 本节我们讨论一个非常重要的元素 —— 随机数。
在虚拟世界的很多场景中都需要引入随机数，来让未来变得不可琢磨，激起我们探索的欲望。
想象你在玩游戏的时候，是不是每局都不尽相同呢？
那请问在Solidity里该如何生成随机数呢？
keccak256 在Solidity中最好的随机数生成器是keccak256
我们可以通过如下代码生成0-100随机数：
// 1、使用 keccak256 计算 now 时间戳的哈希值 // 2、转换成 uint 类型 // 3、对 100 取余 uint(keccak256(now)) % 100; 安全性分析 理想情况中，调用方会将执行智能合约的事务广播到以太坊网络中，
当已收集该事务的某一节点顺利的解决难题，发布区块时，智能合约事务执行结果也将尘埃落定。
但存在这样一种攻击的方式，
攻击者在隔离节点上执行智能合约并根据结果选择是否进行广播（解除隔离）
如果执行结果对攻击者有利则尝试解决难题，当难题解决后发布区块进行广播如果执行结果对攻击者不利则重置状态到执行智能合约前 如此一来，便可以间接控制随机数为攻击者所用！🦹
所以上面的方法实际上非常的不安全
但因为解决难题的几率非常小，所以除非攻击的回报非常丰厚，
否则攻击者不会采用这种方式进行攻击。
拓展知识 话说回来，
到底是否存在在智能合约中安全生成随机数的方法呢？
答案是肯定的，
尽管困难，人们还是讨论出了一些办法 。
在线小册子引流 ==&gt; 《Hello Solidity！》
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d42e81b2af0ed82db820a064fa72d173/" rel="bookmark">
			pytorch 深度学习之余弦相似度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 用处定理代码F.normalize() 和 F.norm() 的区别 用处 此方法特别重要，经常可以用来修改论文，提出创新点.
定理 余弦相似度是通过计算两个向量之间的夹角余弦值来衡量它们的相似性。给定两个非零向量 x 和 y，它们之间的余弦相似度可以使用以下公式计算：
cosine_similarity(x, y) = (x · y) / (||x|| * ||y||)
其中，
(x · y) 表示向量 x 和 y 的点积（内积），是两个向量对应元素相乘再求和的结果。||x|| 表示向量 x 的范数，通常使用 L2 范数表示，即向量 x 的所有元素平方和的平方根。||y|| 表示向量 y 的范数，也是使用 L2 范数进行计算。 使用上述公式，我们可以将两个向量的点积除以它们的范数的乘积，得到余弦相似度的标量结果，取值范围在 -1 到 1 之间。越接近 1 表示两个向量越相似，越接近 -1 表示两个向量越不相似，0 表示两个向量正交（无关）。
代码 代码1： 如果您想在指定的维度（channels, height, width）上计算范数并保持计算过程中的维度，可以进行如下修改：
import torch.nn.functional as F def cosine_similarity(tensor_1, tensor_2): normalized_tensor_1 = F.normalize(tensor_1, p=2, dim=(1, 2, 3)) normalized_tensor_2 = F.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d42e81b2af0ed82db820a064fa72d173/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7617183b74a1eb35e7dbc49865599957/" rel="bookmark">
			《Hello Solidity！》之 payable
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		可支付 本节我们讨论一个划时代的函数修饰符 – payable
payable的出现是划时代的 🥳
在它出现前，函数只能将代表货币的数字作为参数传入;
在它出现后，函数可以将货币直接作为参数传入。
在以太坊中，因为货币（以太币）、数据（事务负载）、以及智能合约代码本身都存在于以太坊，
所以可以在调用函数的同时付钱给智能合约。
这就允许出现很多有趣的逻辑！
比如要求必须支付指定数量的以太才能运行函数,
function doSomething() external payable { // 检查调用方是否支付0.001以太 require(msg.value == 0.001 ether); // 如果已支付，则运行函数逻辑 do(); } 在上面的例子中，msg.value是一种可以查看调用方向合约发送了多少以太的方法，另外ether是一个内建单元。
从调用方那边看到的应该是下面这样子：
// 假设 `KarezaContract` 在以太坊上指向你的合约： KarezaContract.doSomething().send(from: web3.eth.defaultAccount, value: web3.utils.toWei(0.001)) JavaScript使用value字段来指定发送多少（0.001）以太。
如果把事务想象成信封，你发送到函数的参数就是信的内容。添加value很像在信封里面放钱 – 信件内容和钱同时发送给了接收者。
注意：如果一个函数没标记为payable，而你尝试利用上面的方法发送以太，函数将拒绝你的事务。
在线小册子引流 ==&gt; 《Hello Solidity！》
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9a58a7010a5d59b41f4404123d849e5/" rel="bookmark">
			《Hello Solidity！》之 提现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提现 在本节一个非常重要的概念 —— 提现
当我们部署的智能合约接受到调用方支付的以太之后，
非常关键的一件事情，我们该如何将以太提现到自己的账户呢？
废话少说，直接上代码：
function withdraw() external { // 判断调用方是否合约为所有者 require(msg.sender == owner); // 将余额转给合约所有者 owner.transfer(this.balance); } 我们可以使用transfer向任何以太坊地址付钱，
所以我们也可以在调用方超额付款的时候给他们退钱，
让我们强化下可提现中的代码：
function doSomething() external payable { // 检查调用方是否支付0.001以太 require(msg.value &gt;= 0.001 ether); // 将超额付款退回 msg.sender.transfer(msg.value - 0.001 ether); // 如果已支付，则运行函数逻辑 do(); } 在线小册子引流 ==&gt; 《Hello Solidity！》
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03ac2dbdb33752b35db9778f74638eb2/" rel="bookmark">
			折半查找法(11.15总结)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一.折半查找法原理 折半查找法的主要思想是将一个有序数列分为两部分,然后将待查找的数与中间值比较,从而确定待查找数存在的范围.通过逐步比较缩小范围,最终确定所查找的数
二.折半查找法步骤 1.定义中间值mid
2.定义左右两端的下标left right,如果待查找值大于中间值,将左端下标移至mid+1的位置(根据实际数列的排序方式)
3.如果待查找值小于中间值,将右端下标移至mid-1的位置
4.重复2.3过程,最终确定位置
三.图解 (借用一下别人的图)
如图,要查找的数为7,将7与该数列的中间数比较
很明显7大于中间数,7在中间数的右端,那么下标需要向右移动
第二次查找如下,7明显小于中间数,这时下标便需要向左移动
通过循环进行这个过程,最终确定待查找数的位置
四.代码实现 #include&lt;stdio.h&gt; int main() { int a[15]={15,14,13,12,11,10,9,8,7,6,5,4,3,2,1},middle,x,big,small; printf("输入要查找的数字:"); scanf("%d",&amp;x); left=0; right=14;	//left为左区间 right为右区间 while(left&lt;=right) { middle=(left+right)/2; if(a[middle]&lt;x) right=middle-1;	else if(a[middle]&gt;x)	//缩小区间范围 left=middle+1;	if(a[middle]==x) { printf("查找的数字为第%d个数字",middle+1); break; } } return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77ae2b347f8c724ad7e26cc3415fba5c/" rel="bookmark">
			yolov5中train.py运行配置以及报错解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.依赖库版本要求 yolov5中不同版本的依赖库要求可以在requirements.txt查看。根据你的yolov5版本，选择好满足条件的版本。最新版本链接：
yolov5/requirements.txt at master · ultralytics/yolov5 (github.com)
2.parser = argparse.ArgumentParser()参数配置 这里只需要更改--data的参数，改成训练数据的路径，如下图：
当然也可以在代码中直接修改：
3.报错信息：FailedPreconditionError: runs is not a directory 解决方案： 删除runs文件夹
4.报错信息： OSError: [WinError 1455] 页面文件太小，无法完成操作。 Error loading "C:\Users\NL\AppData\Local\Programs\Python\Python310\lib\site-packages\torch\lib\cudnn_adv_train64_8.dll" or one of its dependencies. 原因：batch_size太大
大概在410行处
解决方法，将batch_size改成8或者更小 5.报错信息：Tensor****** 因为有些数据不是tensor数据，这个要慢慢看调试改错
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71009bfb08a06f578e4977a36adb839b/" rel="bookmark">
			创建SpringBoot项目后无法运行Java文件的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.无法运行
（1）解决方法一
（2）解决方法二
2.包无法下载
（1）查看pom.xml文件中包是否存在的方法
（2）如果仓库存在包的处理方式
1.无法运行 当我们创建好一个SpringBoot项目后，打开目录中的Java文件夹下的DemoApplication.java文件，发现这个文件无法运行。
根据提示 module JDK is not defined,选择jdk版本apply后还是无法运行。
（1）解决方法一 发现pom.xml文件还是红色的，说明没有被识别为Maven文件
右键pom.xml文件，点击 add as maven project
然后发现pom.xml文件和Java文件标识变正常了，Java文件也可以运行了，但是Java文件中出现红色标识，再返回pom.xml文件中观察。
根据报错提示，可以得知设置的阿里云仓库中没有2.7.17 RELEASE，这是社区版idea的bug,我们在pom.xml文件中修改version，将版本号后的英文后缀手动去掉，修改后再去maven面板中选择刷新。
再回到Java文件和pom.xml文件中观察，发现所有标红消失，问题解决。
如果pom.xml文件中还出现 xxxxx not found的问题时，尝试在报错处同样添加上&lt;version&gt;键值对的版本号，再次Maven刷新即可。
如果还是解决不了，直接把这块代码删掉即可。
（2）解决方法二 更简单的方式：
右键当前项目，选择添加框架支持
后续修改pom.xml的方法与方法一相同。
2.包无法下载 （1）查看pom.xml文件中包是否存在的方法 因为pom.xml中常常出现包下载不下来的问题，此时我们要去中央仓库中查找此版本的包是否真正存在。
查找方法：进入中央仓库，根据包名，一级一级往下查找。
中央仓库地址：
Central Repository: https://repo1.maven.org/maven2/
（2）如果仓库存在包的处理方式 1.Maven面版多刷新几次
2.判断是否配置过国内源
3.判断配置的setting.xml文件的路径名是否存在中文，存在则修改去掉中文
4.删除本地仓库的jar包，重新下载
本地仓库中：
5.以上方法还是无法下载，尝试使用本地仓库已经下载过的相近版本
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c835d85de41fa542ea9c2571cb68497f/" rel="bookmark">
			Element Plus 实例详解（一）___安装设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Element Plus 实例详解（一） ___安装设置 本篇目录：
一、前言
二、安装方法
1、环境支持
2、Element Plus安装使用方式
（1）、使用包管理器
（2）、浏览器直接引入
3、Element Plus引入方式使用小例子
三、Element Plus用法
1、完整引入
2、按需导入
（1）、自动导入
（2）、手动导入
3、全局配置
四、Element Plus 安装使用小实例
1、搭建Vue3项目（基于Vite + Vue）
2、安装Element Plus
3、完整导入方式引入Element Plus
4、在原Vue+vite欢迎页面增加 Element Plus按钮
五、总结
一、前言 声明：不断有人冒我网名，自行转载我博客文章到其他地方，未免被其他的假鬼李鬼冒名造成不必要损失，现公布一下我个人的真实资料：我姓李，是奶奶级别的老。。。老姐姐，今年50岁了，女，广州。
我只有一个博客：csdn: 逆境清醒的博客_CSDN博客-python,前端特效实例源码,python turtle绘图集锦领域博主，https://blog.csdn.net/weixin_69553582其他以逆境清醒自居的都是冒名的。除了在csdn上公开交流外（csdn博客留言，csdn动态），其他任何地方我都不会和别人有任何私下联系，请留意分辨真伪（包括在csdn用我账号登录的）。
逆境清醒
2023年3月25日
我在阿里云也发布了一些文章，基本和csdn同步，名字依然用逆境清醒。
逆境清醒
2023年11月15日
​
Element Plus是基于Vue 3，面向设计师和开发者的组件库。　Element Plus 是为了适配 Vue 3 对 Element UI 进行的重构。　使用 TypeScript 开发　使用 Vue 3 Teleport 新特性重构挂载类组件　使用 Vue 3 Composition API 简化逻辑，降低耦合　选择了 Day.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c835d85de41fa542ea9c2571cb68497f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80407b00766a7835387e9fd2b75d7528/" rel="bookmark">
			嵌入式Linux开发，NFS文件系统挂载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在嵌入式linix的开发中，经常会需要在pc端和板端互相传输文件，优先可选择ftp传输，但是有些嵌入式板端不支持，只能使用nfs这种方式，即pc端作为服务端，板端作为客户端，将pc端的某个文件夹挂载到板端，然后可以直接将文件复制到这个挂载的目录中实现互相传输的目的
1. 安装nfs服务 sudo apt-get install nfs-kernel-server nfs-common 我已经安装过了，所以是下面的提示
2. 重新启动nfs服务 sudo service nfs-kernel-server restart 3. pc挂载目录权限设置 sudo vim /etc/exports # 添加以下语句 /home/share *(rw,sync,no_root_squash) 不添加权限的话挂载可能会出现下面的错误
mount: mounting 192.168.5.53:/home/ubuntu/work/nfsroot on /home/kirin/nfs failed: Permission denied 4. 挂载目录 mount -t nfs -o nolock 192.168.5.53:/home/share/nfsroot /home/kirin/nfs 5. 测试挂载 pc服务端
板端客户端
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad49703b17ae6ad07a9930c07a0c2707/" rel="bookmark">
			八大学习方法(金字塔模型、费曼学习法、布鲁姆学习模型)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在微博上看到博主发的，觉得总结很好，在此摘录：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1184ca2df497c9348b75b76bb0da0c84/" rel="bookmark">
			在MySQL上实现间隔5分钟汇总取数及相关字符串、时间处理方法实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 实践案例需求描述 查询mysql数据库，按每5分钟分组获取3个小时内的电量数据，参考SQL语句如下。
select sd.RecordTime RecordTime, sd.sddl sddl,sd.pvdl ,cap.capdl capdl from ((SELECT CONCAT(DATE_FORMAT(RecordTime,'%Y-%m-%d %H:'), LPAD(floor(MINUTE(RecordTime)/5)*5,2,'0')) RecordTime, sum(case when EquipmentId='db_sddb1' then ThisPower else 0 end) sddl, sum(case when EquipmentId='db_syfd1' then ThisPower else 0 end) pvdl FROM electricitymeter_history where RecordTime &gt; date_sub(str_to_date('2023-11-06 00', '%Y-%m-%d %H'), interval 3 hour) group by CONCAT(DATE_FORMAT(RecordTime,'%Y-%m-%d %H:'), LPAD(floor(MINUTE(RecordTime)/5)*5,2,'0'))) sd left join (SELECT CONCAT(DATE_FORMAT(RecordTime,'%Y-%m-%d %H:'), LPAD(floor(MINUTE(RecordTime)/5)*5,2,'0')) RecordTime,sum(ThisChargingCapacity) capdl FROM storedenergy_history WHERE RecordTime &gt; date_sub(str_to_date('2023-11-06 00', '%Y-%m-%d %H'), interval 3 hour) group by CONCAT(DATE_FORMAT(RecordTime,'%Y-%m-%d %H:'), LPAD(floor(MINUTE(RecordTime)/5)*5,2,'0'))) cap on sd.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1184ca2df497c9348b75b76bb0da0c84/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61f7124dbecdd3e5a969643a2aee6680/" rel="bookmark">
			Oneid 图计算思路
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前文
oneid 是用户画像的核心，此文提供图计算的具体方案。
二、方案
注意事项：
1. 业务存在解绑信息，当不与其他业务系统产生关联时，沿用旧oneid。
2. oneid 需要自增，下游系统会用到bitmap等数据类型，有利于人群包计算。
3. 标签与oneid 解耦，最后通过映射表关联，可大大调高计算效率。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/540a9589dbed94ee5c948606c4d0d1a7/" rel="bookmark">
			Oneid方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前文
用户画像的前提是标识出用户，存在以下场景：不同业务系统对同一个人的标识，匿名用户行为的行为归因；本文提供多种解决方案，提供大家思考。
二、方案矩阵
三、其他
相关连接：
如何通过图算法能力获取OneID高质量人_图计算服务-阿里云帮助中心
如何开发连通分量_云原生大数据计算服务 MaxCompute-阿里云帮助中心
ID图谱构建--客户数据平台-火山引擎
标识用户——简易用户关联
标识用户——全域用户关联
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85d9802c148ba45e39938921d27604dd/" rel="bookmark">
			Multisim数电仿真实验——SOS循环序列信号发生器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、前言二、设计思路2.1序列信号的实现2.2SOS信号的循环再现 三、最终电路图 一、前言 SOS电路是一种简单而重要的电子电路，用于产生和传输紧急信号。我们将介绍SOS电路的连接思路，包括所需的组件选择以及信号的连接方式。
二、设计思路 2.1序列信号的实现 因为SOS信号是一组特定的串行数字序列信号，这里我们使用 数据选择器74151 来实现。并且用 译码器74138 来控制序列信号的转换。
🌷8选1数据选择器：74151
逻辑符号
功能表（真值表）
Y和Y非负责输出，EN为0（即EN非为1）时，置零，EN为1时，正常工作。
A2A1A0组成一个二进制数，下标为这个二进制数对应的十进制数的D从Y输出。 🌷3输入8输出译码器：74138
逻辑符号
功能
74138为二进制译码器，能把二进制代码编译为0~7的十进制数值。简单来说，就是ABC组成二进制，如果对应十进制是多少，Y多少就为高电平。 我们要实现下面这个21位的一串序列信号，用3个数据选择器进行实现：
接着我们要控制这三个数据选择器依次将信号发出，于是我们用到74138译码器，连接如下：
Y0接第一片151的使能端，Y1接第二片的使能端，Y2接第三片的使能端，于是当138译码器依次从000到001到010能让三片151数据选择器将序列信号发出。
再将三片数据选择器的输出端用或门输出，将信号用小灯泡显示出来
但是我们现在还有两个问题：
三片151需要从000到111的信号输入到ABC从而输出信号输出信号后，如何循环发送SOS信号 2.2SOS信号的循环再现 我们知道，SOS序列信号由74138主要控制来发出，从000到010，依次循环三种状态。但关键是三片151的输入端ABC共需要21种状态的循环变换，所以核心是实现一个21进制的计数器。
这里我们使用两片16进制的74161进行级联来实现：
下面电路基于以上主要做了如下操作：
增加了两片74161级联，实现21进制计数器低片的QAQBQC接到3片7415的ABC：让信号一位一位发出来，因为低片的QCQBQA总是按照000到111进行变换，符合数据选择器从0到8将数据依次输出·74138的CB分别接在计数器高片的QBQA，74138的A接在计数器低片的QD（这是根据上面那张图的表格得出来的，只有这样才能实现74138从Y0到Y1到Y2的三个循环！） 三、最终电路图 按下仿真按钮可以关注小灯泡按照SOS信号进行亮灭
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8abae8997b8884d768c05370661b6c4d/" rel="bookmark">
			C&#43;&#43;11引入的原始字符串字面量与普通字符串字面量的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在C++中，R"(C:\temp\my_file.ext)"和"C:\temp\my_file.ext"之间有一个重要的区别。
"C:\temp\my_file.ext"是一个普通的字符串字面量，它包含了一个Windows文件路径。在编译时，这个字符串会被直接嵌入到代码中。R"(C:\temp\my_file.ext)"是一个原始字符串字面量（raw string literal）。在C++11及更高版本中引入，原始字符串字面量可以用来表示包含特殊字符（例如换行符和制表符）的字符串。在原始字符串字面量中，所有字符都被视为字面字符，不会被转义或解释。 因此，R"(C:\temp\my_file.ext)"和"C:\temp\my_file.ext"的主要区别在于，前者是原始字符串字面量，不会对反斜杠进行转义，而后者是一个普通的字符串字面量，反斜杠会被转义为特殊字符。在处理文件路径时，使用原始字符串字面量可以避免处理转义字符的麻烦。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4c86894bec7ebea2e786fdb5ca5045d/" rel="bookmark">
			哈夫曼编码（Java图形界面实现）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		4.1 哈夫曼编/译码器 4.1.1 项目简介
哈夫曼编/译码器问题：利用哈夫曼编码（加密）进行信息通讯可以大大提高信道利用率，缩短信息传输时间，降低传输成本，保证报文安全。这要求在发送端通过一个编码系统对待传数据预先编码；在接收端将传来的数据进行译码（解密）。设计要求如下：
一个完整的系统应具有以下功能：
(1)初始化 (Initialization)：从终端读入n个字符，建立哈夫曼树；
(2)编码 (Coding)：利用已建好的哈夫曼树，对字符进行编码，然后将正文编码结果存入文件codefile中；
(3)译码 (Decoding)：利用已建好的哈夫曼树将文件codefile中的代码进行译码，结果存入文件textfile中。
建议：
将本次实验与《计算机网络》或者《计算机组成原理》中的通讯协议相结合，对报文进行加密\解密。 代码清单
MainJFrame
package ex4_Huffman; import javax.swing.*; import java.awt.*; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; /** * @Version 1.0 * @Author:刘昕 * @Date:2021/3/30 11:06 * @Software: IntelliJ IDEA * @Content: */ public class MainJFrame extends JFrame implements ActionListener { public static Label text; JPanel functionPanel, textPanel, loadPanel, encodePanel, decodePanel, plainTextPanel, encodeTextPanel, decodeTextPanel; static JTextArea plainText; static JTextArea encodeText; static JTextArea decodeText; JScrollPane plainTextScroll, encodeTextScroll, decodeTextScroll; JButton loadButton, encodeButton, decodeButton; JTextField path; JLabel pathLabel; //存储明文 static String plain_text = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d4c86894bec7ebea2e786fdb5ca5045d/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/43/">«</a>
	<span class="pagination__item pagination__item--current">44/321</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/45/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>