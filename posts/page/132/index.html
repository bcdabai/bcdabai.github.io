<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0acef3e8ceb9d1ddaac5e60dad95ac0/" rel="bookmark">
			Kotlin Lambda详解及非局部返回是啥意思？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Lambda定义
lambda 表达式总是括在花括号中， 完整语法形式的参数声明放在花括号内，并有可选的类型标注， 函数体跟在一个 -&gt; 符号之后。如果推断出的该 lambda 的返回类型不是 Unit，那么该 lambda 主体中的最后一个（或可能是单个） 表达式会视为返回值。
意思就是说lambda表达式一定要放在花括号 { } 中 , -&gt; 前面是参数，后面是方法体就是你要拿这个参数进行的操作。如果你的lambda是有返回值的，-&gt; 后面最后一个表达式会被视为返回值，代码如下：
Lambda就像一个简化的函数，如下： lam1 对应的就是method1 ,两个参数，返回一个Int值。x+y 作为 -&gt; 后面最后一个表达式返回 var lam1: (Int, Int) -&gt; Int = { x: Int, y: Int -&gt; x + y } fun method1(x: Int, y: Int): Int { return x + y } lam2 对应的就是method2，如果表达式不需要返回值，x+y 只是做了一次运算，并没有返回 var lam2: (Int, Int) -&gt; Unit = { x: Int, y: Int -&gt; x + y } fun method2(x: Int, y: Int): Unit { x + y } lambda 主体中的最后一个（或可能是单个） 表达式会视为返回值。为啥非要这么说呢
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e0acef3e8ceb9d1ddaac5e60dad95ac0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2deb367405a390fc0d5f082c4266585e/" rel="bookmark">
			ImageFolder---合并dataset
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ImageFolder 用于读取文件夹内的图片与类别，生成Map-style datasets形式的数据集，以便DataLoader迭代。ImageFolder使用格式：
root/dog/xxx.png root/dog/xxy.png root/dog/[...]/xxz.png root/cat/123.png root/cat/nsdf3.png root/cat/[...]/asd932_.png 但是由于各种原因，如原生数据存储格式，某些操作系统(如centos)中单个目录中最大文件数量存在限制(hdf5 yyds)等等，使得数据的存储是分开的，如：
sub_root1/dog/xxx.png sub_root1/dog/xxy.png sub_root1/dog/[...]/xxz.png sub_root2/cat/123.png sub_root2/cat/nsdf3.png sub_root2/cat/[...]/asd932_.png 需要分别读取，再合并ImageFolder，功能代码如下：
import torch from torch.utils.data import DataLoader from torchvision.datasets import ImageFolder from torchvision import transforms def merge_datasets(dataset, sub_dataset): ''' 需要合并的Attributes: classes (list): List of the class names sorted alphabetically. class_to_idx (dict): Dict with items (class_name, class_index). samples (list): List of (sample path, class_index) tuples targets (list): The class_index value for each image in the dataset ''' # 合并 classes dataset.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2deb367405a390fc0d5f082c4266585e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20797b73281821ac714b42e8337ad402/" rel="bookmark">
			神经网络模型训练简记（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		神经网络模型训练简记（二） 内容简述三、机器视觉网络模型分类及简介3.2目标检测3.2.1RCNN3.2.2SPPNet3.2.3Fast RCNN3.2.4Faster RCNN3.2.5Mask RCNN3.2.6FPN3.2.7Cascade RCNN3.2.8Libra RCNN3.2.9Grid RCNN3.2.10YOLOv13.2.11SSD3.2.12YOLOv23.2.13RetinaNet3.2.14YOLOv33.2.15YOLOv43.2.16YOLOv5 参考文档 内容简述 第一、二章及第三章3.1节具体内容见神经网络模型训练简记（一），以下正文从3.2节开始。
三、机器视觉网络模型分类及简介 3.2目标检测 目标检测任务是找出图像或视频中人们感兴趣的物体，并同时检测出它们的位置和大小。不同于图像分类任务，目标检测不仅要解决分类问题，还要解决定位问题，是属于Multi-Task的问题。
作为计算机视觉的基本问题之一，目标检测构成了许多其它视觉任务的基础，例如实例分割，图像标注和目标跟踪等等；从检测应用的角度看：行人检测、面部检测、文本检测、交通标注与红绿灯检测，遥感目标检测统称为目标检测的五大应用。
基于手工提取特征的传统目标检测算法进展缓慢，性能低下。直到2012年卷积神经网络(Convolutional Neural Networks, CNNs)的兴起将目标检测领域推向了新的台阶。基于CNNs的目标检测算法主要有两条技术发展路线：anchor-based和anchor-free方法，而anchor-based方法则包括一阶段和二阶段检测算法(二阶段目标检测算法一般比一阶段精度要高，但一阶段检测算法速度会更快)，二阶段目标检测算法也称为基于区域（Region-based）的方法。
二阶段检测算法主要分为以下两个阶段
Stage1：从图像中生成region proposals；
Stage2：从region proposals生成最终的物体边框。
3.2.1RCNN RCNN（Regions with CNN features）由Ross Girshick于2014年提出，RCNN首先通过选择性搜索算法Selective Search从一组对象候选框中选择可能出现的对象框，然后将这些选择出来的对象框中的图像resize到某一固定尺寸的图像，并喂入到CNN模型(经过在ImageNet数据集上训练过的CNN模型，如AlexNet)提取特征，最后将提取出的特征送入到SVM分类器来预测该对象框中的图像是否存在待检测目标，并进一步预测该检测目标具体属于哪一类，论文链接。
RCNN算法在VOC-07数据集上取得了非常显著的效果，平均精度由33.7%(DPM-V5, 传统检测的SOTA算法)提升到58.5%。相比于传统检测算法，基于深度学习的检测算法在精度上取得了质的飞跃。
R-CNN的想法直接明了，即将检测任务转化为区域上的分类任务，是深度学习方法在检测任务上的试水。模型本身存在的问题也很多，如需要训练三个不同的模型（proposal, classification, regression）、重复计算过多导致的性能问题等。尽管如此，这篇论文的很多做法仍然广泛地影响着检测任务上的深度模型革命，后续的很多工作也都是针对改进这一工作而展开，此篇可以称得上"The First Paper"。
小结：
1.RCNN的两大贡献：1）CNN可用于基于区域的定位和分割物体；2）监督训练样本数紧缺时，在额外的数据上预训练的模型经过fine-tuning可以取得很好的效果。第一个贡献影响了之后几乎所有2-stage方法，而第二个贡献中用分类任务（Imagenet）中训练好的模型作为基网络，在检测问题上fine-tuning的做法也在之后的工作中一直沿用。
2.RCNN缺点如下：
训练时间长：主要原因是分阶段多次训练，而且对于每个region proposal都要单独计算一次feature map，导致整体的时间变长。
占用空间大：主要原因是每个region proposal的feature map都要写入硬盘中保存，以供后续的步骤使用。
multi-stage：文章中提出的模型包括多个模块，每个模块都是相互独立的，训练也是分开的。
3.2.2SPPNet SPPNet由何凯明在2015年提出，作者在论文中提出了一种空间金字塔池化层(Spatial Pyramid Pooling Layer, SPP)。它的主要思路是对于一副图像分成若干尺度的图像块(比如一副图像分成1份，4份，8份等)，然后对每一块提取的特征融合在一起，从而兼顾多个尺度的特征。SPP使得网络在全连接层之前能生成固定尺度的特征表示，而不管输入图片尺寸如何。当使用SPPNet网络用于目标检测时，整个图像只需计算一次即可生成相应特征图，不管候选框尺寸如何，经过SPP之后，都能生成固定尺寸的特征表示图，这避免了卷积特征图的重复计算，论文链接。
相比于RCNN算法，SPPNet在Pascal-07数据集上不牺牲检测精度(VOC-07, mAP=59.2%)的情况下，推理速度提高了20多倍。
SPPnet的做法是首先通过选择性搜索，对待检测的图片进行搜索出2000个候选窗口。这一步和R-CNN一样。然后把整张待检测的图片，输入CNN中，进行一次性特征提取，得到feature maps，然后在feature maps中通过映射关系找到各个候选框的区域，再对各个候选框采用金字塔空间池化，提取出固定长度的特征向量。而R-CNN输入的是每个候选框，然后再进入CNN，因为SPP-Net只需要一次对整张图片进行特征提取，速度会大大提升。
小结：
1.SPPnet解决了深度卷积神经网络（CNN）的输入必须要求固定图像尺寸（例如224*224）的限制，并且提高了目标检测领域内网络提取特征的效率，速度相比R-CNN提升24-102倍。
2.和RCNN一样，SPP也需要训练CNN提取特征，然后训练SVM分类这些特征，这需要巨大的存储空间，并且多阶段训练的流程也很繁杂。除此之外，SPPNet只对全连接层进行微调，而忽略了网络其它层的参数。
3.2.3Fast RCNN Fast RCNN网络是RCNN和SPPNet的改进版，该模型被Ross Girshick（ RCNN作者）于2015年推出。Fast RCNN该网络可以在相同的网络配置下同时训练一个检测器和边框回归器。该网络首先输入图像，图像被传递到CNN中提取特征，并返回感兴趣的区域ROI，之后再ROI上运用ROI池化层以保证每个区域的尺寸相同，最后这些区域的特征被传递到全连接层的网络中进行分类，并用Softmax和线性回归层同时返回边界框，论文链接。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/20797b73281821ac714b42e8337ad402/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/169c8e82aba204781d09af8256bb2cb5/" rel="bookmark">
			JWT 攻击 | PortSwigger（burpsuite官方靶场）| Part 1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写在前面 靶场链接及官方资料：https://portswigger.net/web-security/jwt
JWT是token的一种实现，全称为 JSON Web Token 。以形式来说，它就是一个字符串，将用户的信息保存在一个json字符串中，编码后得到的一个token，这个token有签名功能防篡改
认证流程：
post提交表单后，后端验证完成生成一个jwt，接下来返回该jwt至客户端，随后请求中带上该jwt，即可工作。
传统cookie、session对比：
1、JWT数据量小，传输速度快
2、由于是json，JWT是跨语言的，应用广
3、更适用于移动端，因为它们不支持cookie
4、避免csrf，因为不依赖cookie
5、作为请求头可以跨域工作
JWT结构
由Header、Payload、Signature组成
JWTString=Base64(Header).Base64(Payload).HMACSHA256(base64UrlEncode(header)+"."+base64UrlEncode(payload),secret) Header
{ "alg": "HS256",	#签名算法 HMAC SHA256 "typ": "JWT"	#统一为JWT } Payload
{ "sub": "1234567890", "name": "Helen", "admin": true } #自定义即可 Signature
仅单向验证是否被篡改，摘要算法。 比较关键的一点在于，签名的密钥存储在服务器中，一般情况下无法重新签名 尝试生成一个可跳转 https://jwt.io/ 。
更多JWT详情 https://blog.csdn.net/weixin_45070175/article/details/118559272 。
为了更好的对JWT进行分析和编辑，可以在bp商店中下载JWT Editor
JWT authentication bypass via unverified signature JWT 库通常提供一种验证令牌的方法和另一种仅对它们进行解码的方法。例如，Node.js 库jsonwebtoken具有verify()和decode().
有时，开发人员会混淆这两种方法，只将传入的令牌传递给该decode()方法。这实际上意味着应用程序根本不验证签名。
靶场登录账户密码：winner peter
在bp中直接双击JWT可以直接以句号分隔，在右边的inspector选项卡中会自动对它进行解码，不过并不支持一起全部解码，只能一段一段的查看。
这里可以明显看到解码后的结果有一个wiener的用户名
将其修改为administrator，重新发出请求，即可以administrator的身份登录
请求敏感链接
完成题目要求
JWT authentication bypass via flawed signature verification 在Header中，设置alg的值可以选择签名方式，就像前面的介绍，可以选择HS256，即HMAC和SHA256。在某些情况下可以设置为None，即不签名，但是一般都会过滤这种危险的设置，实战中较少，可以尝试大小写等等绕过。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/169c8e82aba204781d09af8256bb2cb5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1db9e03e901704ccc247f9e517d635ca/" rel="bookmark">
			【H3C ACL比较全】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实验要求 1、使用H3C模拟器进行三层ACL隔离网络，创建VLAN3 、VLAN4。
2、两种情况使用ACL
① 阻止30段访问 40段，可访问4.2 。
② 阻止30段访问40段，30.3除外
③ 阻止30段 访问40段，30.2可访问server 的telnet
实验拓扑 实验思路 1、vlan+虚接口地址 实现全网通
2、用acl高级 控制是否可访问
实验步骤 1、PC设置ip [pc2]sysn pc2 [pc2]ip route-s 0.0.0.0 0 192.168.40.254 [pc2]int g0/0 [pc2-GigabitEthernet0/0]ip ad 192.168.40.1 24 2、 vlan+虚接口地址 实现全网通 [sw]vlan 30 [sw-vlan30]por g1/0/1 [sw-vlan30]por g1/0/2 [sw-vlan30]por g1/0/3 [sw-vlan30]in vlan 30 [sw-Vlan-interface30]ip a 192.168.30.254 24 [sw]vlan 40 [sw-vlan40]por g1/0/5 [sw-vlan40]por g1/0/4 [sw-vlan40]int vlan 40 [sw-Vlan-interface40]ip a 192.168.40.254 24 3、用acl高级 控制是否可访问 先个体 再全体 ① 阻止30段访问 40段，可访问4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1db9e03e901704ccc247f9e517d635ca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e98a62731a31f2c9b2a3d4a81add7e7a/" rel="bookmark">
			JSP实现登录与注册界面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JSP实现登录与注册界面 1、首页index.jsp &lt;%@ page language="java" contentType="text/html; charset=utf-8" pageEncoding="utf-8"%&gt; &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;index&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;% //接收是否登录成功数据 String flag=request.getParameter("flag"); if(flag==null){ flag=""; } if(flag.equals("sucessful")){ String okname=(String)request.getAttribute("okname"); %&gt; &lt;%=okname %&gt;你好!/&lt;a href="index.jsp"&gt;注销&lt;/a&gt; &lt;% }else{ %&gt; &lt;a href="login.jsp"&gt;登录&lt;/a&gt;/ &lt;a href="reg.jsp"&gt;注册&lt;/a&gt; &lt;% } %&gt; &lt;/body&gt; &lt;/html&gt; 2、注册界面reg.jsp &lt;%@ page language="java" contentType="text/html; charset=utf-8" pageEncoding="utf-8"%&gt; &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;注册页面&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action="showReg.jsp" method="post"&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;用户名:&lt;/td&gt; &lt;td&gt;&lt;input type="text" name="username"/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;密码:&lt;/td&gt; &lt;td&gt;&lt;input type="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e98a62731a31f2c9b2a3d4a81add7e7a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96a4e460c60332478dd54a88cc192fe2/" rel="bookmark">
			贝叶斯优化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1. 最优解问题 最优解问题 最简单的，获得最优解的方法，就是网格搜索Grid Search了。
如果网格搜索开销稍微有点大，可以尝试随机搜索Random Search。
如果是凸函数Convex Function，我们可以用Gradient Descent。大量的机器学习算法，都用了这个。如线性回归，逻辑回归等。
如果，这个黑盒函数的开销非常大，又不是凸函数，我们则考虑贝叶斯优化。
2. 贝叶斯优化 贝叶斯优化（Bayesian optimization algorithm，简称BOA）利用之前已搜索点的信息确定下一个搜索点，用于求解维数不高的黑盒优化问题
黑盒优化问题 非形式化的来说，一个黑盒函数f可以理解为从Rn 到 R 的一个映射.但是映射关系 f 的解析表达式及工作方式未知，我们只能通过不断地将数据输入到黑盒函数中然后通过得到的输出值来猜测黑盒函数的结构信息.下图表示一个黑盒问题的映射关系.
与黑盒优化问题相对应的优化问题便是白盒优化问题。白盒问题要么优化问题的具体形式已知(如线性回归和SVM),要么虽然表达式的形式未知，但是我们可以利用目标对优化参数的梯度进行迭代(如深度网络，尽管深度网络也常被看做一个黑盒).这里的黑盒优化指的是优化目标的具体表达式及其梯度信息均未知的优化问题，因此我们无法利用优化目标的本身特性求得其全局最优解，也无法直接利用参数的梯度信息
除了深度网络的超参数优化问题之外，深度强化学习中智能体与环境的交互问题也可以看做一个黑盒优化问题.在model-free强化学习问题中,我们不对智能体所处的环境进行建模.在这种情形下,我们将环境当做一个黑盒,智能体通过不断尝试动作来从这个黑盒中获得奖励值,最后的优化目标是使累计获得的奖励值最大.
算法的思路 是首先生成一个初始候选解集合，然后根据这些点寻找下一个有可能是极值的点，将该点加入集合中，重复这一步骤，直至迭代终止。最后从这些点中找出极值点作为问题的解。
概念 黑盒函数叫做目标函数Objective Function近似函数，这个函数叫代理函数Surrogate Function——计算出一条平均值曲线和对应的标准差（Standard Deviation）获取函数Acquisition Function——找到下一个探索点 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d177832e98c266e12fc07780e147ac7/" rel="bookmark">
			解决Mac M1 debug报错（could not launch process: can not run under Rosetta）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在M1环境下使用vscode或goland 调试报以下错误
could not launch process: can not run under Rosetta, check that the installed build of Go is right for your CPU architecture
主要原因：
M1芯片基于ARM架构，如果安装的Golang SDK为ARM就在Debug时候会报以上错误
解决方法：
重新下载ARM 版本Go SDK，Golang Installer会自动覆盖以前的版本
安装后 go env查看
golang 调试需要用到dlv，如果没有安装则需要安装dlv
go install github.com/go-delve/delve/cmd/dlv 再次Debug，发现可以正常调试
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1019eb784b46486640b2bdf63521f71/" rel="bookmark">
			（附源码）SSM学生实验报告管理系统JAVA计算机毕业设计项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目运行
环境配置：
Jdk1.8 + Tomcat7.0 + Mysql + HBuilderX（Webstorm也行）+ Eclispe（IntelliJ IDEA,Eclispe,MyEclispe,Sts都支持）。
项目技术：
SSM + mybatis + Maven + Vue 等等组成，B/S模式 + Maven管理等等。
环境需要
1.运行环境：最好是java jdk 1.8，我们在这个平台上运行的。其他版本理论上也可以。
2.IDE环境：IDEA，Eclipse,Myeclipse都可以。推荐IDEA;
3.tomcat环境：Tomcat 7.x,8.x,9.x版本均可
4.硬件环境：windows 7/8/10 1G内存以上；或者 Mac OS；
5.是否Maven项目: 否；查看源码目录中是否包含pom.xml；若包含，则为maven项目，否则为非maven项目 6.数据库：MySql 5.7/8.0等版本均可；
毕设帮助，指导，本源码分享，调试部署(见文末)
3.1 可行性分析 一个完整的系统，可行性分析是必须要有的，因为他关系到系统生存问题，对开发的意义进行分析，能否通过本网站来补充线下学生实验报告管理模式中的缺限，去解决其中的不足等，通过对本网站，不仅能使工作量不断地减少，还能使工作和管理的效率更加高。所以开发该网站能实现更大的意义和价值， 网站完成后，能否达到预期效果就要通过可行性分析，分析之后，决定此系统是否开发。该学生实验报告管理系统的开发设计中，对技术、经济、操作方面进行了可行性分析； 3.1.1 技术可行性 随着互联网的发展，互联网与电脑已经成为现在人的必需品，所以此学生实验报告管理系统所需要的网络环境和载体都已经具备。此学生实验报告管理系统界面清晰，操作方便，一般在对人员进行培训的时候也不会太消耗时间，很容易操作。电脑的兼容性问题，本系统完全可以在电脑上进行安装和操作，所以不需要额外寻找适配的电脑。本系统借助互联网来进行可操作，所以需要借助WIFI或者数据流量进行数据的传输。最后，系统会有一个数据库来进行数据的存储、删除、查找等基本操作，所以完全具备技术可行性。
3.1.2 操作可行性 现在随着科技的飞速发展，计算机早已经进入了人们的日常生活中，人们的工作环境也不像以前有那么多的要求，不需要员工一定要到公司办公，有的工作在家也可以完成。这使得人们的工作效益有了很大的提高。操作的多样性也变高了。因此，管理的计算机化，智能化是社会发展而带来的必然趋势，各种智能的软件层出不穷，不同的软件能完成用户不同的需求，这不仅提高了工作效率还能完成一些客户特定的一些需求。本系统不仅界面简洁明了还采用可视化界面，用户只要用鼠标和键盘就可以完成对相关信息的修改，删除，添加等操作。因为这个系统的操作十分简单，方便上手，对于第一次使用系统的人，只需要很少的时间就可以上手操作。由此可见，本系统在操作上是可行的。
3.1.3经济可行性 首先就开发技术来说，开发系统所借助的开发环境都是全部免费的，所以在开发的过程中并不需要额外的成本去使用其他的一些开发技术。其次，此系统需要的电脑都是很普遍的，学生、教师和管理人员都具有电脑，所以不需要额外佩备；网络可以使用当地的无线网络或者手机的数据流量，所以成本较低，是可以接受的。学生实验报告管理系统的开发不仅可以节约学校所需要的花费，节约资源，还可以更好的管理人员。
3.1.4 法律可行性
系统平台的设计与开发与国家政策法规之间不存在冲突。此外，平台的设计和开发采用的操作和工作模式符合用户的日常习惯，操作方便、灵活、易于管理，具有较高的实用性。开发过程中所采用的数据均来自开源代码，不存在知识产权的争议，在法律上也是行的通的。
3.2 需求分析
系统模块分析是对系统的各个模块做出相应的说明以及解释。此系统的模块有后台这基本模块，而后台模块则包括了学生管理、教师管理、实验项目管理、实验报告管理这些子模块。对系统模块做出详细的分析会使系统的结构更加清晰，从而系统开发进行的也会更加顺利。
3.2.1 学生模块
学生登录之后，进入系统，可以查看到首页、个人中心、实验项目管理、实验报告管理等。学生用例图如图3-1所示：
图3-1 学生用例图
3.2.2 教师模块
教师登录之后，进入系统，可以查看到首页、个人中心、实验项目管理、实验报告管理等。教师用例图如图3-2所示：
图3-2教师用例图
3.2.3管理员模块
管理员登录之后，进入系统界面，可以对首页、个人中心、学生管理、教师管理、实验项目管理、实验报告管理等进行管理。管理员用例图如图3-3所示；
图3-3管理员用例图
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f1019eb784b46486640b2bdf63521f71/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5cdc5d2a1313ac1e30a12d7957888f1/" rel="bookmark">
			Python使用小教程01——[h264 @ 0x55abeda05080] error while decoding MB 0 14, bytestream 104435
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为什么一定要用多进程 一方面：如果采取pipeline的模式进行目标识别，先读取数据再识别，会有下面的报错： [h264 @ 0x55abeda05080] left block unavailable for requested intra mode [h264 @ 0x55abeda05080] error while decoding MB 0 14, bytestream 104435 目前比较靠谱的一种解释是“FFMPEG Lib does not support H264 videos in the rtsp protocol”。H264是当今流行的视频压缩格式；ffmpeg是一个开源库，实现了对h264视频文件的解压缩。
目前的opencv中的H264编码实际上是向下调用ffmpeg的，ffmpeg中又调用了libx264，它执行的就是视频流解码的工作。所以报错大概率也是从这个库来的。然后我们进一步定位。
发现H264除了使用帧内压缩之外，还使用了帧间压缩；H264采用了独特的I帧、P帧和B帧策略来实现，连续帧之间的压缩。那么也就是说在解码的时候如果不能有H264压缩时候需要的帧，就不能正确解码。但是我们由于读取图片和目标检测是放在一起的，导致传输堵塞。
解决方案是：读取和识别分开进行。
另一方面，如果读取速度低于视频流的输出速度，窗口显示的图片是好几秒钟前的内容。一段时间过后，缓存区将会爆满，程序报错。
解决方案是：创建一个队列，线程A从通过rtsp协议从视频流中读取出每一帧，并放入队列中，线程B从队列中将图片取出，处理后进行显示。线程A如果发现队列里有两张图片（证明线程B的读取速度跟不上线程A），那么线程A主动将队列里面的旧图片删掉，换上新图片。
由于进程间是独立的，因此一个进程的崩溃不会影响其他进程。
同一个进程可以共享内存，进程间独立，实现了资源隔离。/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66a6405d34c9b4e23d84f089d558a90b/" rel="bookmark">
			Excel中实现模糊查询-LOOKUP&#43;FIND函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Excel中实现模糊查询-LOOKUP+FIND函数 LOOKUP函数函数简介函数使用方法 FIND函数函数简介函数语法 示例 LOOKUP函数 函数简介 LOOKUP函数是Excel中的一种运算函数，实质是返回向量或数组中的数值，要求数值必须按升序排序。
------粘百度百科
函数使用方法 （1）向量形式：公式为
=LOOKUP(lookup_value,lookup_vector,result_vector)
式中 lookup_value—函数LOOKUP在第一个向量中所要查找的数值，它可以为数字、文本、逻辑值或包含数值的名称或引用；
lookup_vector—只包含一行或一列的区域，其可以是文本、数字或逻辑值；
result_vector—只包含一行或一列的区域，其大小必须与 lookup_vector 相同。
（2）数组形式：公式为
= LOOKUP(lookup_value,array)
式中 array—包含文本、数字或逻辑值的单元格区域或数组它的值用于与 lookup_value 进行比较。
例如：LOOKUP(5.2,{4.2,5,7,9,10})=5。
注意：
array和lookup_vector的数据必须按升序排列，否则函数LOOKUP不能返回正确的结果。文本不区分大小写。
如果函数LOOKUP找不到lookup_value，则查找array和 lookup_vector中小于lookup_value的最大数值。如果lookup_value小于array和 lookup_vector中的最小值，函数LOOKUP返回错误值#N/A。另外还要注意：函数LOOKUP在查找字符方面是不支持通配符的，但可以使用FIND函数的形式来代替。 ------粘百度百科
FIND函数 函数简介 Find函数用来对原始数据中某个字符串进行定位，以确定其位置。Find函数进行定位时，总是从指定位置开始，返回找到的第一个匹配字符串的位置，而不管其后是否还有相匹配的字符串。
------粘百度百科
函数语法 该函数的语法规则如下：
=FIND(find_text,within_text,start_num)
Find_text 是要查找的字符串。
Within_text 是包含要查找关键字的单元格。就是说要在这个单元格内查找关键字。
Start_num 指定开始进行查找的字符数。比如Start_num为1，则从单元格内第一个字符开始查找关键字。如果忽略 start_num，则假设其为 1。
注意：
使用find函数可从文本字符串中查找特定的文本，并返回查找文本的起始位置。查找时，要区分大小写。全角和半角字符。查找结果的字符位置不分全角和半角，作为一个字符来计算。可以单独使用find函数，例如。按照查找字符的起始位置分开文本字符串，或替换部分文本字符串等，也多用于处理其他信息。计数单位如果不是字符而是字节时，请使用findb函数。find函数和findb函数具有相同的功能，但它们的计数单位不同。 [2]
使用 start_num 可跳过指定数目的字符。例如，假定使用文本字符串“AYF0093.YoungMensApparel”，如果要查找文本字符串中说明部分的第一个“Y”的编号，则可将 start_num 设置为 8，这样就不会查找文本的序列号部分。FIND 将从第 8 个字符开始查找，而在下一个字符处即可找到 find_text，于是返回编号 9。FIND 总是从 within_text 的起始处返回字符编号，如果 start_num 大于 1，也会对跳过的字符进行计数。 [3]
如果 find_text 是空文本 ()，则 FIND 则会返回数值1。Find_text 中不能包含通配符。如果within_text 中没有 find_text，则 FIND返回错误值 #VALUE!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/66a6405d34c9b4e23d84f089d558a90b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d241cdbd8c7df08caabbca7c6a07697e/" rel="bookmark">
			Pycharm启动失败的可能原因之一
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下载好Python后下载Pycharm应用，但是点击应用配置后有时启动失败，有时弹框提示错误，看进程均不占CPU。 尝试网上各种解决方案、重新下载软件、重装系统都没能解决。 最终发现是因为电脑上装的加密软件导致，卸载后重新安装即可。 Pycharm启动失败弹框图片 Pycharm启动失败弹框展示信息 Internal error. Please refer to http://jb. ge/ ide/critical-startup-errois java. util. concurrent. Coup letionException: java. lang. RuntimeException: Can't initialisefilesystem storage at java. base/ java. util. concurrent. CompletableFuture. encodeThrowable (CompletableFuture. java: 314) at java base/ java. util. concurrent. CompletableFuture. completeThrowable (CompletableFuture. java: 319) at java base/ java. util. concurrent. CompletableFuture$AsyncRun. run (CompletableFuture. java: 1739) at com intellij. util. concurrency. BoundedTaskExecutor. doRun (BoundedTaskExecutor. java: 222) at com inte1lij util.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d241cdbd8c7df08caabbca7c6a07697e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/647b1ab09447518854c7fd8410b97122/" rel="bookmark">
			MT4插件开发 之 通过managerAPI获取实时行情数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：如有疑问可在下方留言或私信说明，博主每天抽空回复
文章目录 前言一、实现原理二、PumpingSwitch介绍具体实现结束语 前言 之前做crm需要把MT4行情实时显示到CRM中，又或者你需要把MT4的行情实时推送到自己的平台中，可以有多种方式去实现，可以连接数据源获取，可以通过serverAPI的方式获取也可以通过managerAPI获取，这里就不一一讲解了，本文讲解如果使用managerAPI获取。
提示：如有疑问可在下方留言或私信说明，博主每天抽空回复
一、实现原理 在服务器上运行我们编写的插件，CRM可以通过websocket的方式请求数据，插件实时推送行情给CRM。插件的核心是使用managerAPI的PumpingSwitch方法来订阅MT4的行情，这样当MT4有行情信息PumpingSwitch就会收到MT4返回的行情数据。
二、PumpingSwitch介绍 virtual int __stdcall PumpingSwitch(MTAPI_NOTIFY_FUNC pfnFunc,const HWND destwnd,const UINT eventmsg,const int flags)=0; Pumping Pumping is a saving and quick mode of uploading data from the server. When transferring to pumping mode, manager interface requests the server for symbol settings, groups, account databases, orders, and trading requests, after that the server sends only updated data to the connected manager. After having connected to the server, the manager interface is transferred to the pumping mode with the PumpingSwitch() function・ The pointer to the callback function to be used by the manager interface to notify about the data updating, or window handle and identifier of the user message to which the notification about the data updating will be sent, must be passed as a parameter of this function.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/647b1ab09447518854c7fd8410b97122/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bbb3ac2e2491b31b8a45020c3d2ecfd9/" rel="bookmark">
			GNSS TOOL导航定位领域实用工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		工具简介 GNSS TOOL是一款非常实用的导航定位类产品测试工具，通过串口连接导航定位设备，可实时打印串口数据，分析并展示定位信息、搜星情况、卫星信号强度等关键信息，同时支持测试数据的抓取归档。另外还集成了一些小工具，如：NMEA/KML转换、差分数据注入、指令配置管理等。
后续会逐步完善，将定位误差分析、卫星情况分析（不同系统、频点的卫星数和信号强度）等功能加进来（敬请期待） 工具源码地址：https://gitee.com/chshao/gnss/tree/master/GnssTools
功能介绍 一、离线文件回放 支持将保存下来的设备数据文件进行回放，方便排查问题。
二、设备控制 ①支持设备指令集操作（指令集可自行配置），对设备进行设置、查询等
②设备升级（暂不支持，需要自己定制开发，但是已经预留对应模块）
③支持实时RTK网络差分数据获取并注入
三、数据存储 ①支持设备串口输出数据存储
②支持RTK网络差分数据存储
③支持工具本身log存储
四、图表展示 ①串口数据图：设备串口输出数据实时打印展示
②星空图：展示设备搜星情况
③基础信息图：设备定位信息实时展示
④信噪图：设备可见卫星信号强度实时展示
五、其它功能（开发中） ①NMEA转KML
②定位轨迹误差分析（CEP50、68、95、98、SDT等指标）
③原始观测量分析
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de1aeb804709ef8ac1f46c9bd57e2105/" rel="bookmark">
			PTA 3&#43;2 转段考试 数据库mysql（3篇）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
10-152 查询图书表中李凯所著的图书，要求查询结果中包括条形码，书名，作者，出版社4列。
10-153 B1-7查找每位领导的直接下属数量
10-154 B1-8查询特定订单的详细信息
10-152 查询图书表中李凯所著的图书，要求查询结果中包括条形码，书名，作者，出版社4列。 分数 3
全屏浏览题目
切换布局
作者 刘冬霞
单位 山东理工大学
这本题目要求编写SQL语句，查询图书表中李凯所著图书，要求查询结果中包括条形码，书名，作者，出版社4列。
提示：请使用SELECT语句作答。
表结构: 图书（条形码 文本型，书名 文本型，作者 文本型，出版社 文本型，出版日期 日期型，售价 数字型）
表样例 条形码书名作者出版社出版日期售价TP303.5大学计算机基础李凯科学出版社2018-10-738.5TP304.1数据库技术及应用郭栋阳高教出版社2017-6-1642.6 输出样例: 条形码书名作者出版社TP303.5大学计算机基础李凯科学出版社 select 条形码,书名,作者,出版社 from 图书 where 作者 ='李凯' 10-153 B1-7查找每位领导的直接下属数量 分数 20
全屏浏览题目
切换布局
作者 柯海丰
单位 浙大城市学院
查询每位领导的直接下属数量，显示：领导的员工编号（EmployeeID），下属数量（重命名为（countSub））
提示：请使用SELECT语句作答。
表结构: 列名数据类型长度主码说明EmployeeIDint11√员工编号LastNamevarchar20姓FirstNamevarchar10名Titlevarchar30职务TitleOfCourtesyvarchar25礼貌称号BirthDatedatetime,出生日期HireDatedatetime,入职日期Addressvarchar60地址Cityvarchar15城市Regionvarchar15区域PostalCodevarchar10邮政编码Countryvarchar15国家HomePhonevarchar24住宅电话Extensionvarchar4范围Photolongblob,照片ReportsToint11直接上级PhotoPathvarchar255照片 表样例 employees表：
EmployeeIDLastNameFirstNameTitleTitleOfCourtesyBirthDateHireDateAddressCityRegionPostalCodeCountryHomePhoneExtensionReportsTo1DavolioNancySales RepresentativeMs.1948/12/8 00:00:001992/5/1 00:00:00507 - 20th Ave. E.Apt. 2ASeattleWA98122USA(206) 555-9857546722FullerAndrewVice President, SalesDr.1952/2/19 00:00:001992/8/14 00:00:00908 W. Capital WayTacomaWA98401USA(206) 555-948234573LeverlingJanetSales RepresentativeMs.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/de1aeb804709ef8ac1f46c9bd57e2105/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68011f01b504e92348fa0adb1e32b358/" rel="bookmark">
			CNAS 实验室认可规范文件清单 (截止2022年10月1日)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CNAS 实验室认可规范文件清单 (截止2022年10月1日)
序号类别文件编号文件名称发布日期实施日期被代替文件备注注：有效文件发布实施日期文件编号/文件名旧文件废止时间1通用认可规则CNAS-R01:2020《认可标识使用和认可状态声明规则》2020-10-202020-11-1CNAS-R01:2019《认可标识使用和认可状态声明规则》2020-11-1换版修订+实质性修订2CNAS-R02:2018《公正性和保密规则》2018-3-12018-3-1CNAS-R02:2015《公正性和保密规则》2018-3-1换版修订+实质性修订3CNAS-R03:2019《申诉、投诉和争议处理规则》2019-5-282019-5-28CNAS-R03:2018《申诉、投诉和争议处理规则》2019-5-284
实验室专用认可规则CNAS-RL01:2019《实验室认可规则》2019-12-302020-3-1CNAS-RL01:2018《实验室认可规则》2020-3-15CNAS-RL02:2018《能力验证规则》2018-3-12018-3-1CNAS-RL02:2016《能力验证规则》2018-3-1换版修订+实质性修订6CNAS-RL03:2019《实验室和检验机构认可收费管理规则》2019-4-12019-4-1CNAS-RL03:2017《实验室和检验机构认可收费管理规则》2019-4-17CNAS-RL04:2022《境外实验室和检验机构受理规则》2022-7-202022-7-20CNAS-RL04:2009《境外实验室和检验机构受理规则》(2015 年第一次修订)2022-7-20换版修订，没有实质变化8CNAS-RL05:2016《实验室生物安全认可规则》
(2019-12-15 第一次修订)2016-2-12019-12-15CNAS-RL05:2016《实验室生物安全认可规则》2020-3-12019-12-15 第一次修订9CNAS-RL06:2018《能力验证提供者认可规则》2018-3-12018-3-1CNAS-RL06:2015《能力验证提供者认可规则》2019-3-1换版修订+实质性修订10CNAS-RL07:2018《标准物质/标准样品生产者认可规则》2018-3-12018-3-1CNAS-RL07:2014《标准物质/标准样品生产者认可规则》(2015 年第一次修订)2019-3-1换版修订+实质性修订11CNAS-RL08:2017《实验动物饲养和使用机构认可规则》(2020-9-1 第一次修订)2017-6-12020-9-1CNAS-RL08:2017《实验动物饲养和使用机构认可规则》2020-9-112CNAS-RL09:2019《科研实验室认可规则》2019-3-122019-3-12制定13CNAS-RL10:2020《生物样本库认可规则》2020-12-302021-1-1制定14实验室基本认可准则CNAS-CL01:2018《检测和校准实验室能力认可准则 》( 2019-2-20 第一次修订)(ISO/IEC 17025:2017)2018-3-12018-9-1CNAS-CL01:2006《检测和校准实验室能力认可准则》(ISO/IEC17025:2005)(2019-2-20 第二次修订)2020-11-30换版修订，实质性变化
2019-2-20 第一次修订， 非实质性修订， 代替CNAS-CL01:201815CNAS-CL02:2012《医学实验室质量和能力认可准则》(2019-2-20 第二次修订)(ISO 15189:2012)2013-11-222015-6-1CNAS-CL02:2008《医学实验室质量和能力认可准则》(ISO 15189:2007)2014-11-12015-6-1 第一次修订
2019-2-20 第一次修订， 非实质性修订， 代替CNAS-CL02:2012(2015年第一次修订) 序号类别文件编号文件名称发布日期实施日期被代替文件备注注：有效文件发布实施日期文件编号/文件名旧文件废止时间16CNAS-CL03:2010《能力验证提供者认可准则》 (ISO/IEC 17043:2010)(2019 年第二次修订)2010-12-312015-6-1CNAS-CL03:2006《能力验证计划提供者认可准则》(ILAC G13:2000)2011-4-12015-6-1 第一次修订
2019-2-20 第一次修订， 非实质性修订， 代替CNAS-CL03:2010(2015年第一次修订)17
实验室基本认可准则CNAS-CL04:2017《标准物质/标准样品生产者能力认可准则》(2019 年第一次修订)
(ISO 17034:2016)2017-5-12017-7-1CNAS-CL04:2010《标准物质/标准样品生产者能力认可准则》( ISO Guide34:2009)2017-12-312019-2-20 第一次修订， 非实质性修订， 代替CNAS-CL04:201718CNAS-CL05:2009《实验室生物安全认可准则》(2019-12-15 第三次修订) ( GB 19489-2008)2009-6-302019-12-15CNAS-CL05:2009《实验室生物安全认可准则》 (2019年第二次修订)2020-3-12015-6-1 第一次修订
2019-2-20 第二次修订， 非实质性修订， 代替CNAS-CL05:2009(2015年第一次修订)
2019-12-15 第三次修订19CNAS-CL06:2018《实验动物饲养和使用机构质量和能力认可准则》(2019 年第一次修订)2018-3-12018-3-1CNAS-CL60:2017《实验动物饲养和使用机构质量和能力认可准则》( GB/T 27416-2014)2018-3-1仅文件编码变化
2019-2-20 第一次修订，非实质性修订，代替CNAS-CL06:201820CNAS-CL07:2021《医学参考测量实验室能力认可准则》 (ISO 15195:2018)2021-5-252021-11-25CNAS-CL07:2018《医学参考测量实验室认可准则》(2019 年第一次修订)(ISO 15195:2003)2021-11-2521CNAS-CL08:2018《司法鉴定/法庭科学机构能力认可准则》2018-3-12018-9-1CNAS-CL08:2013《司法鉴定/法庭科学机构能力认可准则》(2015 年第一次修订)2020-11-30换版修订，实质性变化22CNAS-CL09:2019《科研实验室认可准则》(2021-3-1 第一次修订)2019-3-122019-3-12CNAS-CL09:2019《科研实验室认可准则》2021-3-12021-3-1 第一次修订， GB/T 27425-2020《科研实验室良好规范》已发布23CNAS-CL10:2020《生物样本库质量和能力认可准则》2020-12-302021-1-1制定 序号类别文件编号文件名称发布日期实施日期被代替文件备注注：有效文件发布实施日期文件编号/文件名旧文件废止时间24
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/68011f01b504e92348fa0adb1e32b358/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca95aa872f841e4fc2a3aec4204fcdc9/" rel="bookmark">
			backtrader回测框架实例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		backtrader是基于Python的量化回测框架，功能丰富，操作方便。其优点是运行速度快，支持pandas的矢量运算；内置多种技术指标计算，还支持股票分析技术指标库talib；支持参数自动寻优运算；支持多品种（股票、期货、期权、外汇和数字货币）、多策略、多周期（Ticks、秒、分、日、周、月和年）的回测和交易；支持PyFlio、empyrica分析模块库、alphalens多因子分析模块库等；扩展灵活，可以集成TensorFlow、PyTorch和Keras等机器学习、神经网络分析模块。
一、安装
pip install backtrader
官网：Backtrader
安装需求：
Python 2.7
Python 3.2 / 3.3/ 3.4 / 3.5
pypy/pypy3
绘图需要用到Matplotlib，最新版本建议&gt;=1.4.1。
包引用：import backtrader as bt
二、backtrader功能
backtrader包主要包括：框架（Cerebro）、数据加载（Data Feed）、交易策略（Strategies）、技术指标（Indicators）、订单（Orders）、观察者（Observers）、测量评估（Analyzers）、订单（Orders）、经纪人（Broker）、实盘交易（Live Trading）、结果可视化（Plotting）等部分
整体结构如下图所示：
下面对其中的关键部分进行详细说明。
1.数据类型
backtrader回测的数据类型是由一系列的点组成的Lines，通常包括以下类别的数据：Open（开盘价）、High（最高价）、Low（最低价）、 Close（收盘价）、Volume（成交量）、OpenInterest（未平仓权益）。Data Feeds（数据加载）、Indicators（技术指标）和Strategies（策略）都会生成 Lines。价格数据中的所有的开盘价按时间组成一条 Line，因此一组含有以上6个类别的价格数据，共有6条 Lines。如果算上DateTime（时间，可以看作是一组数据的主键），一共有7条 Lines。
一条Line数据的下标为0表示访问当前时刻数据，-1表示访问最后一个数据。因此，在回测过程中，无需知道已经处理了多少条/分钟/天/月，”0”一直指向当前值，下标 -1 来访问最后一个值。
2.交易策略（Strategy）
该模块是回测系统最核心的部分，需要设计交易决策，得出买入/卖出信号。策略类代码包含重要的参数和用于执行策略的功能，要定义的参数或函数名如下：
（1）params：全局参数，可选，用于更改交易策略中变量/参数的值，可用于参数调优。
（2）log：日志，可选，用于记录策略的执行日志，可以打印出该函数提供的日期时间和txt变量。
（3）__init__：用于初始化交易策略，在其中声明的任何指标都会在next()方法调用之前进行计算。部分python操作符不支持，需要使用bt内置函数来处理，例如bt.And, bt.Or, bt.All, bt.Any等。
（4）notify_order，可选，用于跟踪交易订单（order）的状态。order具有提交，接受，买入/卖出执行和价格，已取消/拒绝等状态。
（5）notify_trade，可选，用于跟踪交易的状态，任何已平仓的交易都将报告毛利和净利润。
（6）next，必选，用于制定交易策略的函数，策略模块最核心的部分。
3.技术指标（Indicators）
实际上，策略的构建都需要指标来实现，该部分包括很多已经实现的指标，下面是一些比较常用的指标：
Average：指定周期的算术平均值。
SimpleMovingAverage(SMA)：简单移动平均
WeightedAverage：加权移动平均
MACD：滑动平均
ExponentialMovingAverage(EMA)：指数移动平均
RSI_SMA/RSI_EMA：
BollingerBands(BOLL)：布林线
DoubleExponentialMovingAverage(DEMA)：双指数移动平均
WilliamsR(WR)：威廉指标
在指标中也集成了TA-Lib库，实际使用中发现无法正常调用，不知道是不是跟我没有安装该库有关。另外，还可以通过继承Indicator或其它已存在的指标类来实现自定义指标，方便用户加入自己开发的指标。
# 继承自bt.Indicator或其他已存在的指标类 class DummyInd(bt.Indicator): # 定义持有的lines，至少需要1个line lines = ('dummyline',) # params参数可选 params = (('value', 5),) # plotinfo可选，用来控制绘图行为 plotinfo = dict(subplot=False) # __init__方法或next方法必选 def __init__(self): self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ca95aa872f841e4fc2a3aec4204fcdc9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0850adaa1267094fdd25a86243af48b7/" rel="bookmark">
			【Java入门】数组和集合— String[] 、List＜String＞ 及 ArrayList
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		相信大家一定对数组不陌生，初学的话可能是从 DataType[ ]（如最常见的 String[]）开始，随后可能更多地用到 List&lt;ObjectType&gt; 和 ArrayList，这三者的联系不可谓不少，本文希望能为大家阐述清楚这三者定义及使用。
目录
1 数组—String[]
1.1 数组的创建
1.2 数组常规操作
2 集合
2.1 Collection
2.2 List 及 ArrayList
2.2.1 集合的创建—ArrayList
2.2.2 集合的使用—List &amp; ArrayList
3 数组和集合的区别
总结
1 数组—String[] Java 语言中提供的数组是用来存储固定大小的同类型元素，官方定义解释地比较清楚了，可以简单概括为两个点：①储存容量有限②储存的元素类型需一致
DataType[] 也就是数组，数组作为一个容器，它可以基本类型+引用类型，这是它和集合的区别，DataType也就是定义数组中储存的元素类型，String[] 便是声明了一个元素类型是String 的数组。
基本数据类型如 int、byte、boolean 等8八种 ，非基本数据类型都是引用数据类型，比如类，接口，数组，涵盖很广，比如最常用的String 就是引用数据类型中的类。
1.1 数组的创建 我们new一个元素类型是String 的数组（Java 中创建一般用new 操作符），因为数组容量有限，需要声明时即确定数组中元素的个数👇
String[] list1 = new String[2];//2是元素个数 下边是数组创建的另一种形式，也是确定了两个元素，并且都是String 类型，如果将其中一个元素变更为其他类型就会报错。
String[] list2 = {"11","22"}; 1.2 数组常规操作 public static void main(String[]args) { //java数组初始化 String[] strArray={"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0850adaa1267094fdd25a86243af48b7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29841858ff282780b5b32ecc5d76b01f/" rel="bookmark">
			研一Python基础课程第一周课后习题分享（含代码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、日期格式化输出 描述‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‪‬
在三行中依次分别输入当前的年、月、日的整数值，按要求分行依次完成如下输出。‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‪‬
1 输出年月日，空格分隔，格式：2020 09 16‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‪‬
2 输出年-月-日，连字符“-”分隔，格式：2020-09-16‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‪‬
3 输出年/月/日，斜线“/”分隔，格式：2020/09/16‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‪‬
4 输出月，日，年，逗号“,”分隔，格式：09,16,2020‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‪‬
5 用str.format()格式输出，格式：2020年09月16日‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‪‬
6 用字符串拼接方法输出，格式：2020年09月16日‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‪‬
year = input() # 输入当前年，2020
month = input() # 输入当前月，09
date = input() # 输入当前日，16
二、浮点数四则运算与格式化输出 描述‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‪‬
Python 可以方便的实现计算器的功能。数学意义上的加、减、乘、除在Python中分别以符号“+、-、*、/”表示。‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‪‬
试编程实现分两行输入两个非零浮点数，并在4 行中按顺序输出两个数的加、减、乘、除的计算式和计算结果。计算结果str.format()方法严格保留小数点后3位数字。要求输出与如下示例格式相同，符号前后各有一个空格。‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‪‬
浮点数1 + 浮点数2 = 和
浮点数1 - 浮点数2 = 差
浮点数1 * 浮点数2 = 积
浮点数1 / 浮点数2 = 商
三、学费计算 描述‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‪‬
大学第一学期必选课程及其学分如下：‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‪‬
Python 高等数学 大学英语 大学体育 军事理论 哲学
3学分 4学分 4学分 2学分 2学分 2学分
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/29841858ff282780b5b32ecc5d76b01f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/edbfa6e46f31853f2e27d100698d2e05/" rel="bookmark">
			学习 瑞吉外卖项目——总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文为个人学习黑马《瑞吉外卖》项目后进行的项目总结，更偏向于对自己编写文本能力的锻炼以及对项目知识点的简短记录。因为个人能力问题，其中可行性分析和测试部分只进行了小标题的陈列，并没有进行编辑。对《瑞吉外卖》项目感兴趣的朋友也可以浏览本文后再去学习，可以对该项目架构有大体感知，同时黑马《瑞吉外卖》非常适合做各位朋友的入门项目，大力推荐本项目。
1.1 项目背景 随着我国城镇和农村居民生活水平达到富裕和小康层次，消费在国民经济活动中的比重逐步加大，居民的餐饮消费逐渐从一日三餐的刚需升级到感受餐饮文化以及社交的重要方式，近年来我国餐饮业销售收入逐年攀升，2019年中国餐饮收入达4.67万亿元，较2018年增加了0.40万亿元，同比增长9.38%，受新冠肺炎疫情影响，2020年中国餐饮收入大幅下滑，随着国内疫情的有效控制，中国餐饮市场也逐渐复苏，2021年中国餐饮收入完成4.69万亿元，较2020年增加了0.74万亿元，同比增长18.64%。“新冠疫情”改变了人们的就餐习惯，对于病毒的心理障碍，更多人选择外卖的方式来就餐，截止2021年12月末中国网上外卖用户规模达54416万人，较2020年同期增加了12533万人，同比增长29.92%。“新冠疫情”改变了人们的就餐习惯，对于病毒的心理障碍，更多人选择外卖的方式来就餐，截止2021年12月末中国网上外卖用户规模达54416万人，较2020年同期增加了12533万人，同比增长29.92%。 1.2 项目介绍 本项目（瑞吉外卖）是专门为餐厅、饭店定制的一款软件产品，包括系统管理后台和移动端应用两部分。其中系统管理后台主要提供给餐饮内部员工使用，可以对餐厅的菜品、套餐、订单进行管理和维护。移动端应用主要提供给消费者使用，可以在线浏览菜品、添加购物车、下单等。
1.3 项目亮点 1、使用Redis进行缓存 当用户数量较多时，系统访问量大，频繁的访问数据库，数据库压力大，系统的性能下降，用户体验感差。因此使用Redis对数据进行缓存，从而减小数据库的压力，在数据更新时删除缓存，从而保证数据库和缓存的一致性，同时有效提高系统的性能和访问速度。
2、使用MySQL主从复制，进行读写分离 读和写数据的所有压力全都由一台数据库承担，压力大，数据库服务器磁盘损坏则数据丢失，单点故障。使用MySQL进行主从复制，主库(master)进行写操作（intsert update delete），从库（salve）进行读操作（select），从而减轻数据库负担，增大系统承受能力，提高系统性能。本项目使用Sharding-JDBC在程序中实现读写分离。
注：MySQL主从复制是一个异步的复制过程，底层是基于Mysql数据库目带的二进制日志功能。就是一台或多台MySQL数据库(slave，即从库)从另一台MySQL数据库(master，即主库）进行日志的复制然后再解析日志并应用到自身，最终实现从库的数据和主库的数据保持一致。MySQL主从复制是MysQL数据库自带功能，无需借助第三方工具。
3、前后端分别部署，使用Nginx进行反向代理 前端页面部署到Nginx服务器中，后端代码部署到后端服务器中，使用Nginx对后端服务器进行反向代理，使用户只需要访问Nginx服务器便可获得后端服务器的服务（便于后期扩展集群，提高系统并发量）。
技术 SpringBoot+SSM 企业级项目
SSM=Spring+Spring MVC+MyBatis
nginx 是服务器，主要部署静态资源。前端请求nginx服务器，再分发到多个tomcat服务器。
Spring Session解决集群的session共享问题。
Swagger：前后端分离使用。
Redis：主要用作缓存。
展示 移动端：展示数据，消费者使用
+
后台管理：维护数据，餐饮企业使用
数据表 一个套餐是多个菜品的集合；
一个菜品有多个口味；
一个顾客可以同时把多个菜品和多个套餐放入购物车中。
slf4j
@sl4j是lombok提供的
功能开发： 员工管理 1. 后台登录 登录时，以json格式将数据发送至后端
开启驼峰命名
id是雪花算法自动生成的
mp规范：
通用结果类 R
后端返给前端的响应结果
前端使用的是json数据 数据库存储的密码是加密过的
md5加密 错误时，前端展示 2. 后台退出 3. 完善登录 {}是占位符，将会显示逗号后面的内容
传给前端json数据
4. 新增员工 账号设置了唯一的属性，添加相同账号时，数据库抛了异常 全局异常捕获：注解是xxx的类，异常是xxx时，就会被拦截处理
注解是RestController和Controller
@ResponseBody，返回json数据
5.员工信息分页查询
like的第一个条件是if的判断
page查询不需返回，会自动放入pageInfo对象并返回
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/edbfa6e46f31853f2e27d100698d2e05/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f575ef23b925b7736447e42da552ae38/" rel="bookmark">
			[Vue]计算属性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 系列文章目录：
[Vue]目录
老师的课件笔记，不含视频 https://www.aliyundrive.com/s/B8sDe5u56BU
笔记在线版： https://note.youdao.com/s/5vP46EPC
视频：尚硅谷Vue2.0+Vue3.0全套教程丨vuejs从入门到精通
文章目录 前言1 实现效果2 插值语法实现3 methods实现4 计算属性实现5 计算属性简写 通过一个姓名案例引出讲解计算属性
1 实现效果 2 插值语法实现 &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 准备容器 --&gt; &lt;div id="root"&gt; 姓：&lt;input type="text" v-model="firstName"&gt; &lt;br&gt;&lt;br&gt; 名：&lt;input type="text" v-model="lastName"&gt; &lt;br&gt;&lt;br&gt; 姓名：&lt;span&gt;{{firstName}}-{{lastName}}&lt;/span&gt; &lt;/div&gt; &lt;!-- 引入vue --&gt; &lt;script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"&gt;&lt;/script&gt; &lt;script&gt; new Vue({ el: '#root', data: { firstName: '张', lastName:'三' } }) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 如果现在有个需求：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f575ef23b925b7736447e42da552ae38/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/579ff8cf4b82b1e888ed70a281b7c792/" rel="bookmark">
			双线性插值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		博客转自于：https://blog.csdn.net/qq_37541097/article/details/112564822?spm=1001.2014.3001.5502
详见博客:https://blog.csdn.net/qq_37541097/article/details/112564822?spm=1001.2014.3001.5502
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93aa45fce77de4fcf901d3be81522ca1/" rel="bookmark">
			问题 B: 案例3-1.1：线性表元素的区间删除
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目描述
给定一个顺序存储的线性表，删除线性表中所有小于r且大于l的元素。删除后剩余元素保持顺序存储，相对位置不变。
输入格式
第一行元素个数n、区间l、r。1&lt;=n&lt;=1e6,0&lt;=l&lt;=r&lt;=1e8.
第二行n个整数，对应顺序表的各元素。对于每个元素Ai满足0&lt;=Ai&lt;=1e8
输出格式
第一行输出删除后元素的个数
第二行输出删除后顺序表中的元素，没有元素直接换行
输入样例
10 0 4
4 -8 2 12 1 5 9 3 3 10
输出样例 6
4 -8 12 5 9 10
代码展示 楼主一开始写成函数形式（但是超时了）
#include&lt;iostream&gt; using namespace std; struct Node{ int data; Node* next; }; typedef Node* List; int InitList(List &amp;list){ list=new Node; list-&gt;next=NULL; return 0; } int DestroyList(List &amp;list){ List p1,p2; p1=list;p2=list; while(p1!=NULL){ p1=p1-&gt;next; free(p2); p2=p1; } return 0; } int AddNode(List &amp;list,int data){ List head=list; List p1=head; List p2=new Node; p2-&gt;data=data; p2-&gt;next=NULL; if(head==NULL){ head-&gt;next=p2; } else{ while(p1-&gt;next!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/93aa45fce77de4fcf901d3be81522ca1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1fd7df0a4cfac7e58b909cd37e3b47e/" rel="bookmark">
			C语言期末考试测试题及答案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
期末复习：
1、什么叫分配内存，什么叫释放内存：
2、变量为什么必须初始化：
3、详细说明系统是如何执行：int i=5;这个语句的
4、请详细列出C语言所有的基本类型：
5、在printf函数中int用%d输出，请问longint、char、double、float分别用什么输出？ 6、函数的优点是什么？ 7、谈谈你对函数的理解： 8、什么是指针，什么是地址，什么是指针变量，三者之间是什么关系？
9、请写出静态变量和动态变量的异同：
10、C语言中那些知识点是我们学习的重点，请一一列举出来：
11、for语句题目1：
12、for语句题目2：
13、for语句题目3：
14、判断下列程序语法上是否错误：
15、编程实现：
16、若变量已正确定义，有以下程序段：
17、执行以下程序后，输出‘#’号的个数是：
18、有以下程序：
19、若有一些定义和语句：
20、有以下程序： 21、以下程序： 22、以下程序： 23、进制题目：
24、以下叙述正确的是： 25、以下叙述正确的是： 编程题： 1、
2、
3、
4、
5、
期末复习： 1、什么叫分配内存，什么叫释放内存： 操作系统该某一块内存空间的使用权限分配给该程序叫分配内存
操作系统把分配给该程序的内存空间的使用权利收回，该程序就不能够再使用这一块内存空间，这叫释放内存。
附注：释放内存不是把该内存的内容清零
2、变量为什么必须初始化： 不初始化，则变量通常是垃圾值
不初始化，输出语句，编译会报错。
3、详细说明系统是如何执行：int i=5;这个语句的 1、vs2019软件请求操作系统为i分配存储空间
2、操作系统会在内存中寻找一块空闲的局域，把该区域当i来使用
3、vs2019会把i和这块空闲区域关联起来，今后对字母i操作就是对这块空闲的区域操作
4、把5存储到字母i所关联的内存区域中
附注：所谓的内存区域也就是内存的一块存储单元
4、请详细列出C语言所有的基本类型： int longint shorint char float double
5、在printf函数中int用%d输出，请问longint、char、double、float分别用什么输出？ %ld %c %lf %f 6、函数的优点是什么？ 1、避免重复性操作
2、有利于程序的模块化
7、谈谈你对函数的理解： 略，看个人笔记函数部分
8、什么是指针，什么是地址，什么是指针变量，三者之间是什么关系？ 地址是内存单元的编号，指针就是地址，指针和地址是同一个概念
指针变量是存放内存单元编号的变量，指针变量和指针是两个完全不同的概念
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e1fd7df0a4cfac7e58b909cd37e3b47e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d05f6f72a1ac353d9e868e4b4c22f414/" rel="bookmark">
			数据结构——折半查找
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		算法介绍 折半搜索，也称二分搜索、对数搜索，是一种在有序数组中查找某一特定元素的搜索算法。搜索过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜索过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。这种搜索算法每一次比较都使搜索范围缩小一半 。
注意：元素序列一定是要有序的，乱序的情况下不可以使用折半查找。
查找过程 数组a头尾分别为start和end，那么它们的中点元素下标mid(start+end)/2。如果a[mid]=target(目标元素)，那么直接得出元素存在于数组的结论；如果a[mid]&lt;target，说明target位于[mid+1,end]这个区间；如果a[mid]&gt;target，说明target位于[start,mid-1]这个区间；如果start&gt;end，说明查找结束，target不存在。
这就是为什么序列一定要求有序的原因了。如果序列无序，那么通过a[mid]和target的大小来判断target所在区间这个就会出错。
实例1 数组a为｛2 4 5 6 8 9 10 12 16 20｝，使用折半查找的方式查找元素10的过程：
当前搜索的子序列：
2 4 5 6 8 9 10 12 16 20
a[mid]=8
当前搜索的子序列：
9 10 12 16 20
a[mid]=12
当前搜索的子序列：
9 10
a[mid]=9
当前搜索的子序列：
10
a[mid]=10
元素存在
实例2 数组a为｛1 3 4 6 7 8 10 11 13｝，使用折半查找的方式查找元素9的过程：
当前搜索的子序列：
1 3 4 6 7 8 10 11 13
a[mid]=7
当前搜索的子序列：
8 10 11 13
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d05f6f72a1ac353d9e868e4b4c22f414/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da3cd1ebc3893c7e802d6f1b61bf93f7/" rel="bookmark">
			简单理解类的加载过程及getClassLoader的理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们都知道java程序写好以后是以.java（文本文件）的文件存在磁盘上，然后，我们通过(bin/javac.exe)编译命令把.java文件编译成.class文件（字节码文件），并存在磁盘上。
但是程序要运行，首先一定要把.class文件加载到JVM内存中才能使用的，我们所讲的classLoader,就是负责把磁盘上的.class文件加载到JVM内存中，如下图所示：
你可以认为每一个Class对象拥有磁盘上的那个.class字节码内容,每一个class对象都有一个getClassLoader()方法，得到是谁把我从.class文件加载到内存中变成Class对象的
Class&lt;?&gt; person = Person.class.getClassLoader().loadClass("Person");//这里的Person可以换成当前加载Person的类Test,无论是Person.class.getClassLoader()还是Test.class都是拿到Class这个对象后调用.getClassLoader()获得类的加载器,获得类加载器后去调loadClass()方法将Person类加载到JVM 参考文章:http://t.csdn.cn/rRP2k
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/996f24328e9d80010aab55149f932146/" rel="bookmark">
			【Java】实现简单的通信软件C/S（聊天、文件）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述 使用swing搭建客户端界面；
界面源代码，绑定按钮监听响应操作，登录、聊天、文件传输。
import com.client.Client; import com.client.SendFile; import com.message.Message; import javax.swing.*; import java.awt.event.MouseAdapter; import java.awt.event.MouseEvent; import java.io.File; public class LoginFrame extends JFrame { //登陆控件 JTextField txtUserField; JTextField txtPwdfField; JButton btnLogin; JButton btnReg; //好友区控件 JList list; DefaultListModel model; //消息区控件 JTextArea txtHistory = new JTextArea(); JTextArea txtSend = new JTextArea(); JButton btnSend = new JButton(); //发送文件控件 JTextField txtSendFile = new JTextField(); JButton btnSendFile = new JButton(); JProgressBar progressBar = new JProgressBar(); JLabel labSendFile = new JLabel(); private static LoginFrame frame; public static LoginFrame getLoginFrame() { if (frame == null) { frame = new LoginFrame(); } return frame; } private LoginFrame() { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/996f24328e9d80010aab55149f932146/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3387e93eacd7a24b39020f56060f64c/" rel="bookmark">
			数据挖掘学习——SOM网络聚类算法&#43;python代码实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.SOM简述
2.SOM训练过程
（1）初始化
（2）采样（抽取样本点）
（3）竞争
（4）合作和适应（更新权重值）
（5）重复
3.python 代码实现
（1）初始化
（2）计算样本点和权向量之间的拓扑距离
（3）竞争
（4）更新权重
1.SOM简述 SOM（Self Organizing Map）自组织映射网络，又称竞争型神经网络。可以通过将高维数据映射到结构和相互关系简单的低维空间中进行展示，从而实现数据可视化、聚类、分类等功能。
SOM网络与其他的神经网络不同，比起其他的神经网络，他更接近于Kmeans聚类算法，即K-均值聚类算法。
其结构如下图所示。
从图中可以看到，输出层的每个节点，通过D条权边与输入节点相连（即输出层的每个节点用一个D维权重Wij来表征），其中输出层中每个节点之间按照距离远近存在一定联系。
2.SOM训练过程 （1）初始化 为初始权向量选择随机值
（2）采样（抽取样本点） 从输入数据中抽取一个样本点，作为输入训练向量样本
（3）竞争 对于权向量，神经元计算它们各自的判别函数值，为竞争提供基础。具有最小判别函数值的特定神经元被宣布为胜利者。（判别函数可定义为输入训练向量样本和权向量之间的平方欧几里德距离）
大白话：计算各个神经元和第二步选取的训练样本点之间的拓扑距离，距离最近的就是胜出的权向量点（winner）
（4）合作和适应（更新权重值） 在神经生物学研究中，我们发现在一组兴奋神经元内存在横向的相互作用。当一个神经元被激活时，最近的邻居节点往往比那些远离的邻居节点更兴奋。并且存在一个随距离衰减的拓扑邻域。
上一步胜出的神经元将获得权重值的决定权。不仅获胜的神经元能够得到权重更新，它的邻居也将更新它们的权重，尽管不如获胜神经元更新的幅度大。
可以理解为最近的权向量节点向样本点移动一定距离，同时邻近节点也移动一定的距离。
（5）重复 回到第二步重复，直到匹配完所有的输入数据点
3.python 代码实现 （1）初始化 def __init__(self, X, output, iteration, batch_size): """ :param X: 形状是N*D， 输入样本有N个,每个D维 :param output: (n,m)一个元组，为输出层的形状是一个n*m的二维矩阵 :param iteration:迭代次数 :param batch_size:每次迭代时的样本数量 初始化一个权值矩阵，形状为D*(n*m)，即有n*m权值向量。权值由numpy随机函数生成。 """ self.X = X self.output = output self.iteration = iteration self.batch_size = batch_size self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d3387e93eacd7a24b39020f56060f64c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56f38f3a807e6651c4c5b8f3c83cea2f/" rel="bookmark">
			PTA 3&#43;2 转段考试 数据库mysql (3篇)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
10-100 3-1-(c)查询在st1公司于2018年制作的电影中出演的影星
10-101 A1-2根据所在国家查找订单信息
10-102 A1-3查询顾客表中所有不重复的城市
10-100 3-1-(c)查询在st1公司于2018年制作的电影中出演的影星 分数 10
全屏浏览题目
切换布局
作者 lhm
单位 河北农业大学
本题目要求编写SQL语句，
查询在st1公司于2018年制作的电影中出演的影星。
提示：请使用SELECT语句作答。
表结构: CREATE TABLE Movie ( title CHAR(20) NOT NULL, --电影名称 year INT NOT NULL, --拍摄年份 length INT , --长度 inColor BIT DEFAULT 1, --是否彩色 studioName CHAR(20), --所属电影公司 producerCertID CHAR(10), --制片人 PRIMARY KEY (title,year), ); CREATE TABLE StarsIn ( movieTitle CHAR(20), --电影名称 movieYear INT , --拍摄年份 starName CHAR(20), --演员姓名 PRIMARY KEY(movieTitle,movieYear,starName), FOREIGN KEY(movieTitle, movieYear) REFERENCES Movie(title,year) ); 表样例 Movie表：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/56f38f3a807e6651c4c5b8f3c83cea2f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a1759f4e52ecebece7c09d50f6bbf6ed/" rel="bookmark">
			Android Studio安装配置(详细版)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android studio安装配置（相关介绍） 一. 前景介绍： 在开发Android程序之前，首先要在系统中搭建开发环境。Google公司已经发出声明，到2015年年底不再对Ecplise提供支持服务，Android Studio将全面取代Ecplise。 出于开发者角度，我会把两种开发方式（Ecplise和Android studio）都介绍给大家。
二.Android Studio下载与配置
这里去官网 http://www.android-studio.下载
也可以在此处提供的下载点击下载 （下载较慢，建议去中文官网即上面方法下载）
双击开始安装 next后显示如下界面
next
I Agree
next
Install
next
Finish
Create a new Android studio Project
10.next
next
next
next
finish
正在安装该工程
安装完成后的界面
三. 运行该程序
点击绿色的运行按钮（或者工具栏里的Run里run ‘app’）
点击Create New Virtual Device
然后选择自己要安装的型号
如果电脑cpu时AMD的会创建不成功，因为Android studio值提供了inter版本的虚拟机
如果是AMD的话就要另行安装外部虚拟机了
（1）.可以安装Genymotion虚拟机，进官网需要注册才能下载
由于电脑部分配置问题导致安装VirtualBox时一直显示“安装时发生严重错误”和打开Genymotion时出现错误，在网上找了各种办法都未能解决（可以自己尝试一下）
（2）. 可以用真机连接（自己的安卓手机）
可以参考此博客 博客链接
四. 打包问题
点击Show In Explorer 跳转到生成的.apk文件所在的位置
把自生成的apk文件发送到自己的安卓手机上就可以安装查看了
ok，到此就介绍完了，此博客为自己多从安装中总结的经验，可以避免大家少跳一些坑。如有问题评论区留言。未经允许不得私自转发。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84e09cf06ea457722fa78b54b5083fdb/" rel="bookmark">
			快速解决 GRADLE 项目下载 gradle-*-all.zip 慢的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		加载慢的原因是因为gradle是外网，如果没有专门的软件，下载起来就会特别的慢
提供所有的一部分gradle包
密码：j5mj
第一步：查看自己的.gradle文件在哪个目录下（这个是可以手动改的）
2、然后查看自己的项目要求的gradle版本
①
3、用nodepad++打开，查看版本
4.打开步骤1所在的目录查看是否有对应的版本
、
如果gradle-2.10-all这样的文件夹都没有的话，你需要先导入工程，AS会自动帮你加载包（虽然我们不需要，但它会自动帮我们创建文件夹） 导入进去后看到Build:Sync是否有download http://www.gradle.org…grale-xx(版本号)-all.zip，如果出现的话，此时把AS关掉再次进入上述文件夹（/dist）会出现一个要加载gadle包名，进入到具体的文件夹下把两个文件删除（lck和part结尾的文件），最后再把手动下载的包放在该文件夹下并解压，ok
5、再次打开AS，然后导入工程，如果出现以下界面，恭喜你，导入成功，稍等一会就回加载完毕！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a9d8d7219d255abf1607e0d6e9ed625/" rel="bookmark">
			VMware16安装windows server 2022报蓝屏和No Media错误解决办法，图片如下：
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下图错误可能是你在创建虚拟机的时候配置文件没有删干净，一定要把配置文件删干净，要不然肯定还会报错。
如果确定删干净了，还是不行，就在换一个同样版本的镜像，重新创建，就能打开虚拟机。并且能成功安装好你想要安装的操作系统。
以上方法本人已使用，解决了我的问题，当然我在csdn上用了好多博主的方法，都不管用，才自己动手找到了最后的解决办法。希望我的解决方案，对有需要的人有帮助。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/159978185fa0df443c13ec4a1ddec6c0/" rel="bookmark">
			子线程也能更新UI？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在写一个小项目的时候遇到一个很奇怪的问题，在子线程里面有两个更新UI操作，但是前面一个不报错，后面一个报错了。
我确实没有乱说，代码(完整代码,后面log对应行数都是准的)如下：
package com.demo.text_demo; import androidx.appcompat.app.AppCompatActivity; import android.os.Bundle; import android.util.Log; import android.view.View; import android.widget.TextView; import com.demo.R; import java.io.PrintWriter; import java.io.StringWriter; public class TextDemoActivity extends AppCompatActivity implements View.OnClickListener { private TextView tv_refresh_text; private TextView tv_refresh_text_too; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_text_demo); tv_refresh_text = findViewById(R.id.tv_refresh_text); tv_refresh_text_too= findViewById(R.id.tv_refresh_text_too); tv_refresh_text.setOnClickListener(this); } @Override public void onClick(View v) { logUtils("onClick: " + Thread.currentThread().getName()); Thread newThread = new Thread(new Runnable() { @Override public void run() { logUtils("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/159978185fa0df443c13ec4a1ddec6c0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b54f7d7aab1fd5d45e602257a6bc04d3/" rel="bookmark">
			【SSH】SSH 免密码登录配置|Secure Shell 免密认证登录|linux 生成密钥
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
LINUX SSH免密登录
即看即用
详细说明
免密登录原理
Secure Shell 免密认证登录
linux 生成密钥
windows 生成密钥
目录
LINUX SSH免密登录
即看即用
详细说明
免密登录原理
Secure Shell 免密认证登录
linux 生成密钥
windows 生成密钥
LINUX SSH免密登录 即看即用 Server A 要免密登录Server B (192.168.254.129)
在Server A 上
1、生成公钥，一路enter选择默认
ssh-keygen -t rsa 2、公钥拷贝到Server B(192.168.254.129)上并授权
ssh-copy-id 192.168.254.129 3、确认能免密登录
ssh 192.168.254.129
退出：logout或exit
ssh 重启命令
systemctl restart sshd.service
ssh-copy-id 卡住问题：
解决方法：
重新打开SSH窗口
或ssh-copy-id 卡住问题_t0m的专栏-CSDN博客
ssh-copy-id 报错问题：
[SDS_Admin@rdma65 ~]$ ssh-copy-id 182.200.31.109 /usr/bin/ssh-copy-id: INFO: Source of key(s) to be installed: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b54f7d7aab1fd5d45e602257a6bc04d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95d9963379492eb6763dfabb363c0d14/" rel="bookmark">
			win10 hosts文件无法修改的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		win10 hosts文件无法修改，遇到的问题: 1.对hosts文件，属性-安全 里各种赋权（当前用户，及添加everyone）等赋权，勾选完全控制 是没用的，任然无法修改。 2.复制C:\Windows\System32\drivers\etc\hosts文件到别的目录，任然无法修改。 3.解决办法： 复制C:\Windows\System32\drivers\etc\下其他文件，比如hosts.dz这个文件出来，发现可以修改，好咯那就复制这个文件到桌面，修改这个文件，然后hosts.dz重命名为hosts,替换掉原来的hosts文件即可。 总结： hosts的权限还是要给完全控制，便于后续对hosts文件进行替换或重命名
找个其他可以修改文件，重命名为hosts，替换掉原hosts文件。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/063712b7e8a23b3649356116c8da050d/" rel="bookmark">
			C语言 删除字符串中相同的字符
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 #include&lt;stdio.h&gt; void delete_string(char str[],char ch){ int i,j; for(i=j=0;str[i]!='\0';i++) if(str[i]!=ch) str[j++]=str[i]; str[j]='\0'; } int main(){ char c,str[80]; printf("请输入一个字符串："); gets(str); printf("请输入删除字符："); scanf("%c",&amp;c); delete_string(str,c); printf("删除后的字符串为：%s",str); return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca205d0eb56c53ce2d4d1442cba0b4b7/" rel="bookmark">
			Java基础-Java编译过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一章 Java基础之了解Java
文章目录 一、什么是Java？二、Java编译过程？三、Java的特点及Java开发所需要的环境？ 一、什么是Java？ Java是一门面向对象的编程语言，不仅吸收了C++语言的各种优点，还摒弃了C++里难以理解的多继承、指针等概念，因此Java语言具有功能强大和简单易用两个特征。Java语言作为静态面向对象编程语言的代表，极好地实现了面向对象理论，允许程序员以优雅的思维方式进行复杂的编程 。
Java具有简单性、面向对象、分布式、健壮性、安全性、平台独立与可移植性、多线程、动态性等特点
Java可以编写桌面应用程序、Web应用程序、分布式系统和嵌入式系统应用程序等 。
二、Java编译过程？ 在java于编程语言中，所有的源码文件都是以.java为扩展名结尾的纯文本文件，编译过程分：
编译期：.java源文件由javac编译成.class字节码文件运行期：Java启动器工具使用java虚拟机的实例运行您的应用程序；如下图
三、Java的特点及Java开发所需要的环境？ Java的特点就是跨平台使用，一次编译到处使用，如下图：
Java开发所需要的环境(可以参考下图理解)：
JVM(Java Virtual Machine)：即Java虚拟机，负责加载 .class字节码文件并运行 .class文件(.class文件包含字节码，也就是java虚拟机能识别的机器语言0和1)。JRE(Java Runtime Environment):Java运行环境，除了包含JVM之外还包含运行Java程序所必须的环境，JRE = JVM + 系统类库。JDK(Java Development Kit):Java开发环境，除了包含了JRE外还包含了Java开发程序所必须的命令工具，JDK = JRE + 编译 、 运行命令工具 总结： Java开发最小的环境是JDK； Java运行最小的环境是JRE； Java实现跨平台的基础是JVM。	Java概念图描述：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f576f7bc07c3d424131f134136206f01/" rel="bookmark">
			搞懂质数，质因子，互质，最大公约数，最小公倍数.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.质数：
质数是指在大于1的自然数中，除了1和它本身以外不再有其他因数的自然数。
借鉴y总的代码:
bool is_prime(int n){
if(n&lt;2) return false; //因为质数要大于2；
for(int i=2;i&lt;=n/i;i++){ //因为约数都是成对出现的，列如带入一个6；
if(n%i==0) return false;
}
return true;
}
2.质因子：
质因子（或质因数）在数论里是指能整除给定正整数的质数。根据算术基本定理，不考虑排列顺序的情况下，每个正整数都能够以唯一的方式表示成它的质因数的乘积。两个没有共同质因子的正整数称为互质。因为1没有质因子，1与任何正整数（包括1本身）都是互质。只有一个质因子的正整数为质数。数为质数。
1没有质因子。
5只有1个质因子，5本身。（5是质数。）
6的质因子是2和3。(6 = 2×3)
2、4、8、16等只有1个质因子：2（2是质数，4 = 22，8 = 23，如此类推。）
100有2个质因子：2和5。(100 = 22×52)
借鉴y总的代码:
void divide(int x)
{
for (int i = 2; i &lt;= x / i; i ++ )
if (x % i == 0)
{
int s = 0;
while (x % i == 0) x /= i, s ++ ;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f576f7bc07c3d424131f134136206f01/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/756a6b73dc8cfe1ade392284254fcf87/" rel="bookmark">
			git-bash进入目录操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天下载数据集要用Git-bash，不会进目录，记录一下
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f11a3b688c321a1bc075dbe53f3ca0e8/" rel="bookmark">
			太牛了：文本直接生成视频
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前沿 最近在多模态有两篇非常惊艳的工作：一篇是Facebook母公司META在9月30号放出来的Text-to-Video、一篇是Google的Text-to-3D；今天我们来看看第一篇即根据文本直接生成视频，注意不是生成图像而是生成视频！！！这个跨越可以说是非常巨大的。
论文链接：https://makeavideo.studio/Make-A-Video.pdf
demo 大家可以去如下链接先感受一波生成的demo，非常有趣，看完后说不定更有动力学习了，哈哈哈：
https://make-a-video.github.io
动机 当前已经有大量预处理好的text-image pair 数据集，而且Text-to-Image (T2I) modeling也取得了很好的成绩，但是Text-to-Video却不是那么如意，因为text-video pair(T2V)数据集比较难收集，尤其是想要收集类似text-image pair 那么大size的数据集。
但是目前已经有很多训练好的T2I模型，如果不加以利用就太可惜了，于是作者就想到能不能在T2I模型的基础上搞一搞T2V模型，而且不需要利用text-video pair的训练数据。
哈哈，如果是自己，可以想一下此时该怎么搞呢？
方法 作者给该模型取名字也是非常的自逼主题：Make-A-Video，其主要由三个部分组成，下面我们一个一个来看
TEXT-TO-IMAGE MODEL 这里就是训练一个T2I模型，也可以用当前已有的一些好的T2I模型，具体的包含三个模块：一个是prior network P，其主要是在inference的时候生成图片的embedding；其次是一个decoder network D，其主要是根据上述图片的embedding解码生产一个低分辨率的即64 × 64 RGB的图片；最后是一个super-resolution networks SRl,SRh，这是两个超分辨率网络，分别将图片分辨率增强到256 × 256和768 × 768，最后通过插值将采样率降至512获得一张更加清晰的图片。
可以看到这里本质上就是一个文本到图片的模型，只不过第三部分的提高分辨率操作可能比较陌生，但本质就是为了提高图片的质量，这部分其实也是一个研究方向，感兴趣的小伙伴可以调研调研。
SPATIOTEMPORAL LAYERS “时空层”，相信大家看到这个名字也可以猜到这小节的目的是要做什么？
video和image的最大区别就是：前者是由一连串连贯的image组成的，所以为了生成video，作者在增加T2I模型的基础上额外加了一个维度：时空层。
具体的是设计了两个模块：卷积层和注意力机制层，分别如下：
可视化结构框图如下：
可以看到不论是卷积层还是注意力机制层，都是在2D的基础上增加了1D（时空）形成了最终的3D，其中2D的部分都还是可以直接使用T2I模型训练好的权重进行初始化，而新增加的1D（时空）该怎么训练呢？
我们知道要生成视频其实就是生成一连串的多张图片，但是这些图片要在时空上保证连贯性，于是该部分一切训练的目标就是连贯性，于是就可以使用视频来训练了，注意只使用视频就可以进行无监督训练了哦，不需要text-video pair训练数据。
再强调一遍：这里解决的是多张图片的连贯性，而不解决文本和图片（视频）的相关性，作者把这两部分进行了解耦，这也是这篇paper开头自豪的说：我们不需要text-video pair训练数据的关键原因。
FRAME INTERPOLATION NETWORK 这部分又是一个插值网络，只不过对应到video的话，是一个帧插值网络，本质上和生成图片一样，目的是提高生成视频的质量。
TRAINING 其实最重要的三部分已经讲完了，总结一下就是先要有一个T2I模型、然后再在其基础上再增加一个时空维度，最后再过一个插值网络增强视频质量。
各个模块在训练的时候，都可以各自单独进行，也就是各自训练各种的。如果我们非要拆解一下来看看的话：第一个模块训练要解决的问题是文本和生成视频的相关性，这里直接用了目前很好的T2I模型；第二个模块要解决的问题是多张图片的连贯性，或者说生成视频的连贯性，这里是新增加了一个时空维度，然后只使用视频就可以单独进行无监督训练了；最后一部分就是一个插值网络，进一步来增强生成视频的质量。
总结 （1）虽然现在模型还存在很多缺点，但是也是一个非常大的突破，这个头开的很好，相信会有越来越多的惊艳工作，很期待。
（2）如果感兴趣，确实有很多知识需要静下心来好好学习，比如插值网络等等，它的原理、实现等等。
关注 欢迎关注，下期再见啦~
知乎，csdn，github，微信公众号
本文由 mdnice 多平台发布
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3979dac294cf651cd2f8316523624c5f/" rel="bookmark">
			伪代码介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 伪代码优点：语法规则变量声明指令的表示表达式赋值语句goto语句分支结构循环结构程序的结束注释风格函数的编写 实例 伪代码 定义: 伪代码介于自然语言和编程语言之间，是一种描述算法的语言
优点： 提高了代码的可读性充当了程序与算法或流程图之间的桥梁，也可当作粗略的文档可以让程序员更好的构建代码 语法规则 每条指令占一行(esle if除外)，指令后不跟任何符号缩进表示程序中的分支程序结构 变量声明 定义变量的语句不用写出来，但必须在注释中给出
a &lt;- 5 //这里的a表示整形变量 指令的表示 在算法中的某些指令或子任务可以用文字来叙述，例如，”设x是A中的最大项”，这里A是一个数组；或者”将x插入L中”，这里L是一个链表。这样做的目的是为了避免因那些与主要问题无关的细节使算法本身杂乱无章。 表达式 算术表达式可以使用通常的算术运算符（+，-，*，/，以及表示幂的^）。逻辑表达式可以使用关系运算符 = 、≠、&lt;、&gt;、≤ 和 ≥，以及逻辑运算符与(and)、或（or）、非（not） 赋值语句 赋值语句是如下形式的语句：a←b。
这里a是变量、数组项，b是算术表达式、逻辑表达式或指针表达式。语句的含义是将b的值赋给a。
变量交换：若a和b都是变量、数组项，那么记号a&lt;-&gt;b 表示a和b的内容进行交换。
goto语句 goto语句具有形式：
goto label（goto标号） 它将导致转向具有指定标号的语句。
分支结构 if i=10 then xxxx else xxxx //else 和 then 要对齐 //或者 if i=10 then xxxx //if 后面必定跟上then，else后面不用跟then elseif i=9 //elseif 要连在一起写 then xxxx yyyy else xxxx //else 跟在 elseif 的 then 对齐 循环结构 有两种循环指令：while和for。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3979dac294cf651cd2f8316523624c5f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7e5b1d51eb0021e730da4d69f08e677/" rel="bookmark">
			力扣刷题笔记 二叉树&amp;二叉搜索树
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		二叉树 二叉树的题目时的通用思考过程是：
1、是否可以通过遍历一遍二叉树得到答案？如果可以，用一个 traverse 函数配合外部变量来实现。
2、是否可以定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案？如果可以，写出这个递归函数的定义，并充分利用这个函数的返回值。
3、无论使用哪一种思维模式，你都要明白二叉树的每一个节点需要做什么，需要在什么时候（前中后序）做。
基础篇 104. 二叉树的最大深度 // 定义：输入根节点，返回这棵二叉树的最大深度 int maxDepth(TreeNode root) { if (root == null) { return 0; } // 利用定义，计算左右子树的最大深度 int leftMax = maxDepth(root.left); int rightMax = maxDepth(root.right); // 整棵树的最大深度等于左右子树的最大深度取最大值， // 然后再加上根节点自己 int res = Math.max(leftMax, rightMax) + 1; return res; } // 记录最大深度 int res = 0; // 记录遍历到的节点的深度 int depth = 0; // 主函数 int maxDepth(TreeNode root) { traverse(root); return res; } // 二叉树遍历框架 void traverse(TreeNode root) { if (root == null) { // 到达叶子节点，更新最大深度 res = Math.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d7e5b1d51eb0021e730da4d69f08e677/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6016a010699ce4aca633730f085ae4bd/" rel="bookmark">
			【Android Studio程序开发】文本显示 -- 设置文本的颜色
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		除了设置文字大小，文字颜色也经常需要修改，毕竟Android默认的灰色文字不够醒目。在Java代码中调 用setTextColor方法即可设置文本颜色，具体在Color类中定义了12种颜色，详细的取值说明见下表
比如以下代码便将文本视图的文字颜色改成了绿色：
// 从布局文件中获取名为tv_code_system的文本视图 TextView tv_code_system = findViewById(R.id.tv_code_system); // 将tv_code_system的文字颜色设置系统自带的绿色 tv_code_system.setTextColor(Color.GREEN); （ 完整代码见下文）
可是XML文件无法引用Color类的颜色常量，为此Android制定了一套规范的编码标准，将色值交由透明 度alpha和RGB三原色（红色red、绿色green、蓝色blue）联合定义。该标准又有八位十六进制数与六 位十六进制数两种表达方式，例如八位编码FFEEDDCC中，FF表示透明度，EE表示红色的浓度，DD表示 绿色的浓度，CC表示蓝色的浓度。透明度为FF表示完全不透明，为00表示完全透明。RGB三色的数值越 大，表示颜色越浓，也就越暗；数值越小，表示颜色越淡，也就越亮。RGB亮到极致就是白色，暗到极 致就是黑色。 至于六位十六进制编码，则有两种情况，它在XML文件中默认不透明（等价于透明度为FF），而在代码 中默认透明（等价于透明度为00）。以下代码给两个文本视图分别设置六位色值与八位色值，注意添加0x前缀表示十六进制数：
// 从布局文件中获取名为tv_code_six的文本视图 TextView tv_code_six = findViewById(R.id.tv_code_six); // 将tv_code_six的文字颜色设置为透明的绿色，透明就是看不到 tv_code_six.setTextColor(0x00ff00); // 从布局文件中获取名为tv_code_eight的文本视图 TextView tv_code_eight = findViewById(R.id.tv_code_eight); // 将tv_code_eight的文字颜色设置为不透明的绿色，即正常的绿色 tv_code_eight.setTextColor(0xff00ff00); 运行测试App，发现tv_code_six控件的文本不见了（其实是变透明了），而tv_code_eight控件的文本显 示正常的绿色。 在XML文件中可通过属性android:textColor设置文字颜色，但要给色值添加井号前缀“#”，设定好文本颜 色的TextView标签示例如下：（完整代码见下文）
&lt;TextView android:id="@+id/tv_xml" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="布局文件设置六位文字颜色" android:textColor="#00ff00" android:textSize="17sp" /&gt; 就像字符串资源那样，Android把颜色也当作一种资源，打开res/values目录下的colors.xml，发现里面 已经定义了3种颜色：
&lt;resources&gt; &lt;color name="colorPrimary"&gt;#008577&lt;/color&gt; &lt;color name="colorPrimaryDark"&gt;#00574B&lt;/color&gt; &lt;color name="colorAccent"&gt;#D81B60&lt;/color&gt; &lt;/resources&gt; 那么先在resources节点内部补充如下的绿色常量定义：
&lt;color name="green"&gt;#00ff00&lt;/color&gt; 然后回到XML布局文件，把android:textColor的属性值改为“@color/颜色名称”，也就是android:textColor="@color/green"，修改之后的标签TextView如下所示：
&lt;TextView android:id="@+id/tv_values" android:layout_width="wrap_content" android:layout_height="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6016a010699ce4aca633730f085ae4bd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/448d632ccecda03e649c23d8a2a7ac6f/" rel="bookmark">
			ubuntu22.04桌面版开启root用户登陆并开启root用户远程ssh连接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在使用Ubuntu22.04时需要用到root用户登录桌面，于是配置了下系统，也在网上查找了类似的文章，发现几篇文章都操作都存在一定的问题，所以在这里写了一份较为完整的，这份文档是清澈过可以正常使用运行的，具体步骤如下：
修改root用户登录桌面权限 一、设置root用户密码 使用如下命令设置root用户密码，执行命令后，依次输入当前登录用户密码，要设置的root密码，确认root密码
sudo passwd root 二、注释如下两个文件的对应行 文件为/etc/pam.d/gdm-password和/etc/pam.d/gdm-autologin，找到如下代码后在文件前面加入#注释，代码为
auth required pam_succeed_if.so user != root quiet_success 编辑文件代码如下
sudo nano /etc/pam.d/gdm-autologin sudo nano /etc/pam.d/gdm-password 三、修改profile文件 修改/root/.profile文件，编辑代码如下
sudo nano /root/.profile 注释掉或者删除行
mesg n 2＞ /dev/null || true 插入新行
tty -s &amp;&amp; mesg n || true 注意：当没有执行第一步“设置root用户密码”时，/root/.profile文件是不存在的所以对于新安装的系统来说，第一步是非常重要的。
四、测试 注销当前用户后在登录界面选择“未列出”，然后输入用户名和刚设置的密码登录，如下图所示：
配置root用户的远程ssh连接 一、安装openssh 使用如下命令安装openssh
sudo apt install openssh-server 二、修改配置文件 安装完成后修改配置文件/etc/ssh/sshd_config，命令如下
sudo nano /etc/ssh/sshd_config 将
#PermitRootLogin prohibit-password 改成
PermitRootLogin yes 三、重启服务 使用如下命令程序ssh服务
sudo systemctl restart ssh 四、测试 使用如下命令测试是否能成功登录
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/448d632ccecda03e649c23d8a2a7ac6f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3663838089be546564b039b66c810ab/" rel="bookmark">
			利用python破解zip压缩文件密码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在日常工作生活中，可能会遇到压缩文件后忘记解压密码的情况，也许你大概知道密码构成及位数，一个一个手动输入的试密码显然很麻烦，那么利用程序自动测试密码就非常方便
目录 zip密码字典破解报错处理 zip密码排列破解Excel密码排列破解 zip密码字典破解 1，新建一个zip压缩文件（破解测试.zip），设置密码为123456或987654
2，创建一个txt文件（密码字典.txt），保存可能的密码
from itertools import permutations def password_txt(): filename = r'E:\测试\密码字典.txt' with open(filename, 'w', encoding='utf-8') as file: # 写入数字10选6所有排列151200种 str_n = '0123456789' for i in permutations(str_n, 6): file.write('{}\n'.format(''.join(i))) print('所有排列写入完成') if __name__ == '__main__': password_txt() 3，编写python破解代码
import zipfile from threading import Thread from time import time i = 0 pwd_return = None # 多线程返回值，正确的密码 def extractfile(zfile, password): # 密码破解函数 try: zfile.extractall(pwd=bytes(password, 'utf8')) print('文件解压密码为: ', password) global pwd_return pwd_return = password return True except: return False # 以下为测试使用 #global i #i = i + 1 #print('密码错误第{}次\n'.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b3663838089be546564b039b66c810ab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7cc7f3e7836319d7c88ff04447a53593/" rel="bookmark">
			Spring Cloud Alibaba实战之二：OpenFeign的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
OpenFeign简介
Feign能干什么
Feign和OpenFeign的区别
Spring Cloud Alibaba中OpenFeign的使用
1、OpenFeign简单使用
1.1、新建shop-common子模块
1.2、新建shop-order子模块​编辑添加配置文件
1.3、引入依赖
1.4、在其他模块中引用common公共模块
1.5、 shop-order模块代码
1.6、shop-user模块代码
1.7、启动服务
1.8、通过feign接口访问服务
2、OpenFeign的进阶使用 2.1、openfeign接口添加请求头信息
2.2、fallback的使用 总结
OpenFeign简介 Feign是一个声明式WebService客户端，使用Feign能让编写Web Service客户端更简单
它的使用方法是定义一个服务接口然后在上面添加注解，Feign也支持可拔插式的编码器和解码器。Spring Cloud对Feign进行了封装，使其支持了Spring MVC标准注解和HttpMessageConverters。Feign可以与Eureka和Ribbon组合使用以支持负载均衡
Feign能干什么 Feign旨在使编写Java Http客户端变得更容易
前面在使用Ribbon+RestTemplate时，利用RestTemplate对http请求的封装处理，形成了一套模板化的调用方法。但是在实际开发中，由于对服务依赖的调用可能不止一处，往往一个接口会被多处调用，所以通常都会针对每个微服务自行封装一些客户端类来包装这些依赖服务的调用。所以，Feign在此基础上做了进一步封装，由它来帮助我们定义和实现依赖服务接口的定义。在Feign的实现下，我们只需要创建一个接口并使用注解的方式来配置它（以前是Dao接口上面标注Mapper注解，现在是一个微服务接口上面标注一个Feign即可），即可完成对服务提供方的接口绑定，简化了使用Spring Cloud Ribbon时，自动封装服务调用客户端的开发量
Feign集成了Ribbon，通过feign只需要定义服务绑定接口并且以声明式的方法，优雅而简单的实现了服务调用
Feign和OpenFeign的区别 Feign是Spring Cloud组件中的一个轻量级RESTful的HTTP服务客户端，Feign内置了Ribbon，用来做客户端负载均衡，去调用服务注册中心的服务。Feign的使用方式是：使用Feign的注解定义接口，调用这个接口，就可以调用服务注册中心的服务
OpenFeign是Spring Cloud在Feign的基础上支持了SpringMVC的注解，如@RequestMaping等等。OpenFeign的@FeignClient可以解析SpringMVC的@RequestMaping注解下的接口，并通过动态代理的方式产生实现类，实现类中做负载均衡并调用其他服务。
Spring Cloud Alibaba中OpenFeign的使用 1、OpenFeign简单使用 前文中已经建立了一个标识店铺用户信息的shop-user模块，本文将新建一个管理店铺订单信息的shop-order模块和公共管理shop-common模块（其中shop-common模块下主要是一些工具类，被shop-common模块和shop-order模块依赖）。这样，我们就可以用两个服务测试feign接口的功能。
1.1、新建shop-common子模块 其中shop-common的引入如下依赖：
&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt; &lt;version&gt;3.12.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.83&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-codec&lt;/groupId&gt; &lt;artifactId&gt;commons-codec&lt;/artifactId&gt; &lt;version&gt;1.15&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-log4j2&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 在common中添加工具类，一些字符串操作和非空判断操作。 1.2、新建shop-order子模块
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7cc7f3e7836319d7c88ff04447a53593/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84b3258cd5a27adbb9cc02a1820c4c95/" rel="bookmark">
			Spring Cloud Alibaba实战之一：项目搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
Spring Cloud Alibaba简介
背景
1、单体应用的痛点
2、微服务的优势
重要组件
工程搭建
1、搭建父工程
2、引入相关springcloud依赖
3、创建子模块
4、将服务注册到nacos
4.1、引入nacos依赖
4.2、创建application.yml配置文件和启动类并引入nacos​编辑
4.3、启动项目:
5、nacos配置中心
5.1、添加配置中心依赖
5.2、创建bootstrap.properties配置文件
5.3、新建名称空间
5.4、在nacos平台上创建配置文件映射相关
5.5、启动项目测试
5.6、 @RefreshScope注解 配置动态刷新
总结
Spring Cloud Alibaba简介 背景 1、单体应用的痛点 传统的单体应用，将所有功能的表示层、业务逻辑层，数据访问层，包括静态资源等等全部糅合在一个工程里面，编译，打包，部署在单台服务器上上线，比如打成war包放在Tomcat的webapp目录中部署项目。这样的项目开发部署适合小型项目，系统功能不复杂，访问量不大的情况下有绝对的优势。开发速度快，运维方便。但是当业务越来越复杂，功能越来越多，参与的开发人员越来越多，就暴露出问题了。
比如：
业务变复杂，代码量增大，代码可读性，可维护性，可扩展性下降。万一要新同事接手代码，理解起来花很多时间
测试难度增大
单体应用并发能力有限，访问量高了用户体验差
单体应用容错率低，万一哪里出错，可能导致整个项目就崩了
2、微服务的优势 将原来的单体应用按义务范围来进行划分，划分为多个小model，每个微服务运行在自己的进程中，不相互影响，通过完全自动化部署来独立部署。并使用轻量级机制通信，通常是HTTP RESTUFUL API。可对各个微服务进行集中管理。这些小model可以使用不同的编程语言，以及不同的存储技术。
重要组件 nacos：注册中心（服务注册与发现）、配置中心（动态配置管理）
Ribbon：负载均衡
Feign：声明式Http客户端（调用远程服务）
Sentinel:服务容错（限流、降级、熔断）
Gateway：API网关（webflux编程模式）
Sleuth：调用链监控
Seata：原Fescar，即分布式事务解决方案
工程搭建 1、搭建父工程 给项目起个名字就叫做’spring-cloud-alibaba-shop’ ，并删除掉src目录（父目录不需要）
2、引入相关springcloud依赖 引入springboot springcloud spingcloud alibaba 依赖，如下
版本选取：
springboot – 2.6.4
springcloud – 2021.0.1
springcloud alibaba – 2021.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/84b3258cd5a27adbb9cc02a1820c4c95/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8be227cce010d09e89d79e386f33f101/" rel="bookmark">
			c&#43;&#43;中的异常处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		异常是程序在执行期间产生的问题。C++ 异常是指在程序运行时发生的特殊情况，比如尝试除以零的操作。
异常提供了一种转移程序控制权的方式。C++ 异常处理涉及到三个关键字：try、catch、throw。
throw: 当问题出现时，程序会抛出一个异常。这是通过使用 throw 关键字来完成的。catch: 在您想要处理问题的地方，通过异常处理程序捕获异常。catch 关键字用于捕获异常。try: try 块中的代码标识将被激活的特定异常。它后面通常跟着一个或多个 catch 块。 如果有一个块抛出一个异常，捕获异常的方法会使用 try 和 catch 关键字。try 块中放置可能抛出异常的代码，try 块中的代码被称为保护代码。使用 try/catch 语句的语法如下所示：
try { // 保护代码 }catch( ExceptionName e1 ) { // catch 块 }catch( ExceptionName e2 ) { // catch 块 }catch( ExceptionName eN ) { // catch 块 } 如果 try 块在不同的情境下会抛出不同的异常，这个时候可以尝试罗列多个 catch 语句，用于捕获不同类型的异常。
一、抛出异常 您可以使用 throw 语句在代码块中的任何地方抛出异常。throw 语句的操作数可以是任意的表达式，表达式的结果的类型决定了抛出的异常的类型。
以下是尝试除以零时抛出异常的实例：
double division(int a, int b) { if( b == 0 ) { throw "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8be227cce010d09e89d79e386f33f101/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fecc1f22238a286744ec1b8c6279e16a/" rel="bookmark">
			Redis在SpringMVC（或xml配置）项目中使用(注意版本兼容问题)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在没有封装情况下使用 Java API的缺点，需要自己白那些规则把 java 对象 和 Redis 的字符串进行相互转换，而在 Spring 中这些问题都可以轻松处理。
在Spring中使用 Redis ,除了需要 jedis.jar 外，还需要下载 spring-data-redis.jar，打开网址 https://mvnrepository.com/artifact/org.springframework.data/spring-data-redis ， 就能够看到这样的页面：
值得注意的是， jar 包 和 Spring 版本兼容的问题。
注意 spring5以上需要配置 spring-data-redis 2.0 基于spring主版本为4.3.13.RELEASE的项目，测试以下对应版本可用。 spring-data-redis版本
jedis版本
备注
1.5.2.RELEASE
2.7.3
1.6.0.RELEASE
2.7.2 2.7.3
1.6.2.RELEASE
2.8.0
1.8.1.RELEASE
2.9.0
1.8.4.RELEASE
2.9.0
原有的SpringMVC配置不动，添加下面这个配置
redis.xml:
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p" xmlns:context="http://www.springframework.org/schema/context" xmlns:mvc="http://www.springframework.org/schema/mvc" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.1.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.1.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.1.xsd"&gt; &lt;!-- redis数据源 --&gt; &lt;bean id="poolConfig" class="redis.clients.jedis.JedisPoolConfig"&gt; &lt;!-- 最大连接数 --&gt; &lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fecc1f22238a286744ec1b8c6279e16a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/decc2a29b6e795e275930d56540f18eb/" rel="bookmark">
			IO进程知识点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.IO的种类
IO分为标准IO和文件IO，标准IO由库函数调用，文件IO由系统调用。
2.标准IO
2.1什么是FILE
FILE本身是一个结构体，在调用fopen的时候产生一个结构体指针，在读写文件的时候通过FILE指针完成。
#include &lt;stdio.h&gt;
typedef struct _IO_DILE FILE;
struct _IO_FILE
{
char *_IO_buf_base; //缓冲区的起始地址
char* _IO buf_end;//缓冲区的结束地址
...
}
在一个正在执行的程序中，默认已经有了三个FILE指针，stdin（标准输入） stdout（标准输出） stderr（标准出错）。
2.2 fopen函数
FILE *fopen(const char *pathname, const char *mode);
@pathname:想要打开的文件路径及名字
@mode:想打开的方式
r：以只读方式打开文件，将光标定位到文件的开头
r+：以读写方式打开文件，将光标定位到文件的开头
w：以只写方式打开文件，如果文件存在就清空，如果文件不存在就创建
w+：以读写方式打开文件，如果文件存在就清空，如果文件不存在就创建
a：以追加的方式打开文件，如果文件不存在就创建文件，如果文件存在将光标定位的结尾写
a+：以读和追加的方式打开文件，如果文件不存在就创建文件，如果读从开头读，如果写从结尾写
返回值：成功返回FILE指针，失败返回NULL，置位错误码。
2.3 fclose函数
#include &lt;stdio.h&gt;
int fclose(FILE *stream);
功能：关闭文件
参数 ：@stream文件指针
返回值：成功返回0，失败返回EOF(-1)，置位错误码
2.4 strerror函数
#include &lt;string.h&gt;
功能：将错误码转换为错误信息的字符串
参数：@errnum：错误码
返回值：错误信息的字符串
2.5 perror函数
#include &lt;stdio.h&gt;
void perror(const char *s);
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/decc2a29b6e795e275930d56540f18eb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a4e27791e7436e7cf868c9cf0c64322/" rel="bookmark">
			解决80端口被占用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天要用nginx，然后一直启用失败
看了日志（nginx-1.17.3\logs）nginx安装下的logs文件夹里面的error.log,说是80端口被占用
2022/10/01 16:06:29 [emerg] 7304#1968: bind() to 0.0.0.0:80 failed (10013: An attempt was made to access a socket in a way forbidden by its access permissions) 2022/10/01 16:28:40 [emerg] 11684#7640: bind() to 0.0.0.0:80 failed (10013: An attempt was made to access a socket in a way forbidden by its access permissions) 2022/10/01 16:29:25 [emerg] 8252#10704: bind() to 0.0.0.0:80 failed (10013: An attempt was made to access a socket in a way forbidden by its access permissions) 2022/10/01 16:35:32 [emerg] 2816#1280: bind() to 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3a4e27791e7436e7cf868c9cf0c64322/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2143702f7aa7ef551faef3a38637d24f/" rel="bookmark">
			springboot&#43;redis&#43;thymeleaf实现集合的数据在前端显示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一，前言 关于redis缓存实现在前端的一个问题：
这几天在各大博客论坛上疯狂的找thymeleaf显示从redis获取缓存显示数据，都快找遍了全网也没搜到关于这方面单独的知识，自己钻研了一两天，研究了一下redis的部分原理，由于redis存取数据有好多种，且每一种存入redis数据库里的数据格式还不一样 ，所以redis获取的数据不能直接放在modle上 ，这样会导致前端模板引擎遍历不出数据，导致前端遍历时报错 ，所以需要先将redis中获取的数据进行强转 强转为JSON格式，再将JSON强转为LIST集合的方式实现，所以我总结了一点经验，在下面分享给大家
二，项目展示 1.运行样式展示 用springboot+redis+thymeleaf+mybatisplus实现（具体代码往下看）
（当前为毕业设计，等毕业答辩完成，将进行开源）
2.项目需要的依赖 &lt;!-- redis连接池--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- redis依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--thymeleaf模板--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;version&gt;2.7.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.thymeleaf&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf-spring5&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.thymeleaf.extras&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf-extras-java8time&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--Web依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--mybatis-plus --&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.0.5&lt;/version&gt; &lt;/dependency&gt; &lt;!--lombok--&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.10&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; 3.controller代码（业务层就不展示了 直接在控制层实现） /** * @author: sqxjj * @Project: JavaLaity * @Pcakage: com.gong.school_card.pccontroller.UserController * @Date: 2022年09月14日 16:36 * @Description: */ @Controller public class UserController { //业务层注入 @Resource private StudentServicesImpl studentServices; @Resource private StringRedisTemplate stringRedisTemplate; //删除学生记录 @RequestMapping("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2143702f7aa7ef551faef3a38637d24f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f22c4b6b63dc1f0c545338aef005ccc6/" rel="bookmark">
			CIe系列专题之六：PCIe系统复位方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在PCIe Spec中，Reset总共分为两类：Conventional Reset和Function Level Reset.
1. Conventional Reset
从字面上来讲，Conventional Reset是传统的Reset方式。这一类Reset功能是在PCIe Spec 2.0之前的Spec中定义的，所以称为传统的Reset。PCIe设备必须要支持这一类Reset。
Convential Resets包含了三种Resets: Cold Reset，Warm Reset 和 Hot Reset.
另外，还有一个概念: Cold Reset和Warm Reset又被称为Fundamental Reset, Hot Reset被称为Non-Fundamental Reset.
什么是Fundamental Reset呢？
这是PCIe最基本的复位方式，主要通过硬件实现，效果是重置整个设备，对每个状态机、所有硬件逻辑、端口状态和配置寄存器重新初始化。
但是，也会有例外的情况：在某些寄存器中的字段只有在全部电源(包括VCC电源和Vaux备用电源)切断的情况下才会被重置。PCIe Spec给这些固执的字段起了个外号"Sticky Bits".
一般来说，Fundamental Reset是针对整个系统做Reset，但是有时也可以针对某个单一设备进行重置。
在这里说明一下Fundamental Reset中的Cold Reset和Warm Reset。
Cold Reset: 设备的主电源VCC上电时，就会触发Cold Reset。
Warm Reset: 在VCC不断电的情况下，系统可以触发Warm Reset。比如，电源状态的变化就会触发Warm Reset. 不过，PCIe Spec并没有定义触发Warm Reset的具体方式，这部分可以有系统设计人员自行决定。
另外，在PCIe Spec中，规定了两种触发Fundamental Reset方式。
一是通过PERST#(PCIe Reset)信号控制。
二是在没哟PERST#信号的情况下，通过Power on/off的方式实现。
举个例子，看看PERST#是如何生成的。
系统上电稳定后，有POWERGOOD信号产生(下图红色框所示)。
当系统的南桥芯片(也就是图中的IO控制器ICH)收到POWERGOOD信号后，就会产生PERST#信号(下图绿色部分)，此时会引起Cold Reset。
如果系统可以通过非上电的方式触发PERST#信号，此时会引起Warm Reset。
明白了Fundamental Reset，那Non-Fundamental Reset中的Hot Reset又是什么呢？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f22c4b6b63dc1f0c545338aef005ccc6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0eaa6a81009560929d8b8815779838d/" rel="bookmark">
			win10调节键盘灵敏度的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		细心的用户发现win10 64位系统键盘时反应很慢，每次都要等上好几秒才有响应，降低工作效率，这是怎么回事？可能是键盘设置的灵敏度问题。
那么win10怎么加快键盘反应速度？只要调节一下键盘灵敏度即可。
win10怎么加快键盘反应速度。
具体方法如下：
1、首先我们打开控制面板中，找到【键盘】选项。
2、在打开的键盘属性窗口，在字符重复栏。
把重复延迟（d）的滑块拉到最短位置，把重复速度（R）的滑块拉到最快位置（如图），然后点击：确定。
去注册表设置，查看键盘的注册表信息。
①打开注册表编辑器：win+R（输入regedit） - 回车，打开注册表编辑器，
②展开 hKeY_cURRent_UseR \ controlPanel \ Keyboard
把initialKeyboardindicators（是最初键盘指示）默认设置为“2”就好，
Keyboarddelay（是键盘延迟），设置为“0”（延迟时间当然是越少越好），
Keyboardspeed（是键盘速度），设置为“48”（根据自己的需要，也可以设置为其它值）
win10设置键盘灵敏度的方法分享到这里了，有需要的用户可以参照以上方法来调整自己的键盘。
相关教程：键盘哪个键调鼠标速度键盘背光灯怎么调节键盘突然反应慢无线键盘不灵敏怎么办
来源：https://www.weidianyuedu.com/content/2419035794252.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce4bf16cd4e65f25710f58ab64cd5520/" rel="bookmark">
			ROS 中 bag、txt、csv 格式文件的详细转换 和 图片的提取
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、包（.bag）是怎么得到的 ? rosbag record 命令是用于在ros系统中录取系统中其他ros节点发出来的 topic 的message。录取的的包可以使用 rosbag play 命令来回放，订阅这些消息的node节点就可以收到这些消息，进而执行对应的程序。 1.1 录制所有话题的包 rosbag record -a 1.2 录制指定话题，设置 bag 包名为：bag_name rosbag record -O bag_name.bag /topic1_name /topic2_name /xxx
1.3 录制包不设置 包名称，默认按照录制结束时间命名 rosbag record /topic1_name /topic2_name /xxx
例如：录制 topic 为 image_raw , 名字为 pylon_camera 的包 rosbag record -O pylon_camera.bag/image_raw
二、回放 2.1 直接回放 rosbag play pylon_camera.bag
2.2 设置以 0.5 倍速回放，也就是以录制频率的一半回放： rosbag play -r 0.5 pylon_camera.bag
此时，包内的 信息 以 topic 为 image_raw 不断地读出来； 运行rviz, 选择 topic 为 image_raw； 便可以出来图像
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ce4bf16cd4e65f25710f58ab64cd5520/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ca89a0b05044d6d47c850c91b9a7bbc/" rel="bookmark">
			浏览器自动化 - 全流程代码示例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果对xpath有疑问，可以看前面文章介绍，如果获取xpath。简单来讲，打开浏览器开发者模式，右键元素，复制xpath即可。
获取driver登录与验证&lt;iframe&gt;标签的切换 输入文本下拉选项选择点击查询按钮截屏保存清除cookies退出浏览器 #!/usr/bin/env python # -*- coding:utf-8 -*- import time from selenium.webdriver.support.wait import WebDriverWait from selenium import webdriver from selenium.webdriver.common.by import By from selenium.webdriver.common.keys import Keys from selenium.webdriver.common.action_chains import ActionChains from pathlib import Path urls = { 'login': 'https://***.***.***.***' } login_info = { 'username': '***', 'password': '***' } project_name = '***' def get_driver(): # chromedriver是当前路径，已经下载好的chrome驱动。 chromedriver = 'chromedriver' # 配置对象 options = webdriver.ChromeOptions() # 取消用户名密码保存的浏览器提示 prefs = {"profile.password_manager_enabled": False, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5ca89a0b05044d6d47c850c91b9a7bbc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d961733003e3fc7cf1f99651f3bb44ae/" rel="bookmark">
			Clickhouse 单机版 及 Clickhouse 集群的安装及搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Clickhouse 单机版及集群的搭建 本文详细描述了如何搭建 Clickhouse 单机版及 Clickhouse 集群。
Clickhouse 单机版搭建 本小节简述了如何搭建 Clickhouse 的单机版。该部分内容也会成为后续搭建 Clickhouse 集群的先决条件，请务必认真对待。
安装包拷贝至相应目录 将下载好的 clickhouse 安装包利用命令分发至待安装主机上。安装包可以到 Clickhouse 官网 下载至本地。
[hadoop@p0-tklcdh-clickhouse01 software]$ pwd /home/hadoop/software [hadoop@p0-tklcdh-clickhouse01 software]$ ls -l total 1112624 -rw-r--r-- 1 hadoop hadoop 39866 Sep 28 13:57 clickhouse-client-22.3.2.2.tgz -rw-r--r-- 1 hadoop hadoop 179545907 Sep 28 13:57 clickhouse-common-static-22.3.2.2.tgz -rw-r--r-- 1 hadoop hadoop 774024509 Sep 28 13:57 clickhouse-common-static-dbg-22.3.2.2.tgz -rw-r--r-- 1 hadoop hadoop 61901 Sep 28 13:57 clickhouse-server-22.3.2.2.tgz -rw-r--r-- 1 hadoop hadoop 185646832 Sep 28 11:40 jdk-8u181-linux-x64.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d961733003e3fc7cf1f99651f3bb44ae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36b036208d745cccd216d3a7e3a6ba5f/" rel="bookmark">
			2022 ICPC网络预选赛1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2022 ICPC网络预选赛1 A 最难的一点就是没有处理环形后效性
比如询问L=1R=9 -&gt;111000111应该是长度为6的连续一段1,贡献为6/2=3而不是2+2=4
做法就是预处理L右边最近的0的下标x，预处理R左边最近的0的下标y，然后把一段区间分成三份求解，中间就直接贡献sum[y]-sum[x-1]
然后把左边和右边连续的1加起来除于2
做法1，dp处理前缀和贡献
#include&lt;bits/stdc++.h&gt; using namespace std; const int N=1e6+10; char s[N]; int n,m,sum[N],L[N],R[N]; int f[N],l,r; signed main(){ ios::sync_with_stdio(0);cin.tie(0);cout.tie(0); cin&gt;&gt;n&gt;&gt;m&gt;&gt;s+1; int cnt=0; for(int i=1;i&lt;=n;i++){ if(s[i]=='1')cnt++; else cnt=0; f[i]=f[i-cnt-1]+(cnt+1)/2; } L[0]=0; for(int i=1;i&lt;=n;i++){ if(s[i]=='1')L[i]=L[i-1]; else L[i]=i; } R[n+1]=n+1; for(int i=n;i&gt;=1;i--){ if(s[i]=='1')R[i]=R[i+1]; else R[i]=i; } while(m--){ cin&gt;&gt;l&gt;&gt;r; int len=r-l+1; int cnt1=r-L[r]+R[l]-l; int t=f[L[r]]-f[R[l]-1]+(cnt1+1)/2; cout&lt;&lt;max(0,len/3-t)&lt;&lt;'\n'; } } 做法2，对一段连续的1采取贡献差分，也就是+1+0+1+0+1+0，然后前缀和
这样可以保证奇数的时候上取整，偶数下取整
#include&lt;bits/stdc++.h&gt; using namespace std; const int N=1e6+10; char s[N]; int n,m,sum[N],L[N],R[N]; int cal(int l,int r){ int ll=R[l]; int rr=L[r]; if(ll&gt;=rr)return (r-l+1)/2; int len1=(r-rr)+(ll-l); return sum[rr]-sum[ll-1]+(len1+1)/2; } signed main(){ ios::sync_with_stdio(0);cin.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/36b036208d745cccd216d3a7e3a6ba5f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe6ad3c07cf7687469db131541436190/" rel="bookmark">
			Ubuntu配置tftp服务端
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这两天安装ONIE和sonic系统，基于ONIE安装sonic系统时。需要使用到tftp服务，正好电脑里面有ubuntu的虚拟机，就直接在虚拟机上安装了tftp服务器。顺便记录下。
一、安装 tftp 1、安装tftp-hpa客户端、tftpd-hpa服务程序、创建tftp目录 sudo apt-get install tftp-hpa tftpd-hpa sudo mkdir -p /home/USER/work/tftp chmod 777 /home/USER/work/tftp -R #根据实际需求修改权限 2、安装xinetd sudo apt-get install xinetd Xinetd（eXtended InterNET services daemon，扩展互联网服务守护进程=超级互联网守护进程=超级服务)，xinetd是新一代的网络守护进程服务程序，又叫超级Internet服务器。
管理保护多种轻量级Internet服务。管理的服务都是一些不是很常用，但是系统中偶尔也会用到的小服务或者该服务没什么好的安全机制，比如：tftp、rsync、cvs、telnet等。它并不是一真正意义上的服务，xinetd相当于rync、cvs等服务的代理人，就像老大照着小弟!它的作用大致可以分为以下几个：访问控制、防止DOS攻击、扩展的日子选项、服务转发、用户交互式体验。
根据Xinetd的工作流程，修改配置文件。
第一步：初始化各服务信息
配置文件默认为/etc/xinetd.conf（如果没有该文件，需要自行创建），也可以通过参数指定。/etc/xinetd.conf默认内容如下：
# Simple configuration file for xinetd # # Some defaults, and include /etc/xinetd.d/ defaults { # Please note that you need a log_type line to be able to use log_on_success # and log_on_failure. The default is the following : # log_type = SYSLOG daemon info } includedir /etc/xinetd.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fe6ad3c07cf7687469db131541436190/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f7348a058147cd1760d5f793ee5c2d8/" rel="bookmark">
			SpringCloudAlibaba 整合OpenFeign
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、为服务消费者添加OpenFeign依赖
二、启动类开启Feign
三、编写服务提供者的调用接口
四、服务消费者调用该接口
五、注意事项
六、相关配置
1、全局配置
2、局部配置
3、契约配置
4、超时时间配置
七、自定义拦截器 一、为服务消费者添加OpenFeign依赖 &lt;!--OpenFeign--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt; &lt;/dependency&gt; 二、启动类开启Feign 添加@EnableFeignClients
package com.wxl; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.cloud.openfeign.EnableFeignClients; @SpringBootApplication @EnableFeignClients public class Service1Application { public static void main(String[] args) { SpringApplication.run(Service1Application.class, args); } } 三、编写服务提供者的调用接口 服务消费者使用该接口调用服务提供者：
用@FeignClient注解该接口，name为注册中心里服务提供者的服务名，path为调用接口控制器的路径。
package com.wxl.feign; import org.springframework.cloud.openfeign.FeignClient; import org.springframework.web.bind.annotation.GetMapping; @FeignClient(name = "WXL-DEV-SERVICE-2", path = "/hello") public interface Service1HelloInterface { @GetMapping("/world") String helloWorld(); } 与服务提供者是一个映射关系，如下为服务提供者的控制器：
package com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3f7348a058147cd1760d5f793ee5c2d8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d851fd40f6ff1e1065053fcaf2441749/" rel="bookmark">
			训练自己的数据_ArcFace/InsightFace使用自己数据训练人脸识别（2/2）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		人脸识别
接上一章内容ArcFace/InsightFace使用自己数据训练人脸识别(1/2)
文章中所需的脚本文件下载地址见第一个评论
六、训练
进入src目录，linux命令行输入以下：
export MXNET_CPU_WORKER_NTHREADS=24export MXNET_CUDNN_AUTOTUNE_DEFAULT=0export MXNET_ENGINE_TYPE=ThreadedEnginePerDeviceDATA_DIR=/root/cc/faces_vgg_112x112#数据存放目录NETWORK=r50#网络 默认resnet50 r100代表resnet100JOB=softmax1e3#LOSS=0#0代表使用softmax，4代表arcface等等，可以看源码MODELDIR="/root/cc/model/model-$NETWORK-$JOB"#模型保存位置mkdir -p "$MODELDIR"PREFIX="$MODELDIR/model"CUDA_VISIBLE_DEVICES='0' python -u train_softmax.py --data-dir $DATA_DIR --network "$NETWORK" --loss-type $LOSS --prefix "$PREFIX" --per-batch-size 64# 加载预训练模型，训练快，设置学习率为0.005，可减少错误，可使用以下命令CUDA_VISIBLE_DEVICES='0' python -u train_softmax.py --data-dir /mnt/sda2/faces_vgg_112x112 --network m1 --loss-type 0 --lr 0.005 --pretrained ./models/m1-softmax-emore,1-softmax-emore,1 --prefix ../models --per-batch-size 64
输入shell命令时，注意取出#后面的文字
以上参数在1080Ti上训练可以通过，注意per-batch-size和网络的设置，数目太大可能会报错。
七、测试验证
第一种验证方式
直接测试准确率等数值，进入sce/eval目录，linux命令行输入以下：
python -u verification.py --gpu 0 --data-dir /root/cc/20_faces_datasets --model '/root/insightface-master0/models/model,0' --target 20_faces --batch-size 128
命令行参数说明：
data-dir：就是之前各种文件保存的目录
model：就是训练好的模型位置，注意地址后面有个",0"代表使用哪一次的训练结果
target：就是你测试验证的数据集的标签
batch-size：每次测试的样本数量
第二种验证方式
在验证的代码中，还有一种能够直观展示测试数据结果的方式，展示结果如下图所示，程序会自动的选择表现最优的阈值，同时把在该阈值下的False_Positive和False_Negative的人脸给一一画出来，能够直观的分析识别出错的原因。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d851fd40f6ff1e1065053fcaf2441749/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1d563c6f6246114c86092285213dfaf/" rel="bookmark">
			springboot-方法处理4-消息转换器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.消息转换器简介 在《方法处理2-参数解析器》那一章，了解到获取body参数的解析器AbstractMessageConverterMethodArgumentResolver及其子类，并没有自己去解析request中的body参数，而是委托消息转换器HttpMessageConverter去解析body参数，并转换为目标方法的参数类型，本文稍微研究一下消息转换器；
1.1.类结构 1.2.功能说明(重点) 消息转换器负责读取httpRequest请求中的body参数，并转换为目标方法的参数类型。并把目标方法的返回值写入到httpResponse中；
支持的数据格式支持的参数类型名称支持的header类型字节Byte[]ByteArrayHttpMessageConverter 1.application/octet-stream类型读取和写入 2.*/*类型读取和写入 文件ResourceResourceHttpMessageConverter 1.*/*类型读取和写入 文本StringStringHttpMessageConverter 1.text/plain类型读取和写入 2.*/*类型读取和写入 任意类型 ObjectToStringHttpMessageConverter 先读取文本，然后使用ConversionService把文本转换为对象 1.text/plain类型读取和写入 MultiValueMap FormHttpMessageConverter 使用其它的消息转换器，把MultiValueMap返回值中包含的对象转换成字节/文本并写入响应 1.application/x-www-form-urlencoded类型读取和写入 2.multipart/form-data类型写入 3.multipart/mixed类型写入 4.*/*类型写入 MultiValueMap AllEncompassingFormHttpMessageConverter 使用其它的消息转换器，把MultiValueMap返回值中包含的对象转换成json/xml并写入响应 xmlSource SourceHttpMessageConverter 使用jdk的api，把xml转换为Source对象 1.application/xml类型读取和写入 2.text/xml类型读取和写入 3.application/*+xml类型读取和写入 任意类型，类包含如下注解： 1.读取:@XmlType/@XmlRootElement 2.写入:@XmlRootElement Jaxb2RootElementHttpMessageConverter 使用jakarta.xml，把xml转换为对象 任意类型 MappingJackson2XmlHttpMessageConverter 使用jackson.xml，把json转换为对象 json任意类型 FastJsonHttpMessageConverter 使用fastjson，把json转换为对象 1.*/*类型读取和写入 任意类型 JsonbHttpMessageConverter 使用javax.json，把json转换为对象 1.application/json类型读取和写入 2.application/*+json类型读取和写入 任意类型 GsonHttpMessageConverter 使用google.gson，把json转换为对象 任意类型 MappingJackson2HttpMessageConverter 使用jackson.json，把json转换为对象 2.消息转换器源码 消息转换器提供了两个接口HttpMessageConverter和GenericHttpMessageConverter，GenericHttpMessageConverter支持推断泛型类型。我们根据这两个接口把消息转换器分成两类：第一类是HttpMessageConverter及其子类，第二类为GenericHttpMessageConverter及其子类；
2.1.HttpMessageConverter及其子类 2.1.1.HttpMessageConverter HttpMessageConverter是参数转换器的顶层接口，定义了参数转换器的行为，包括6个方法。分成三种类型，每种类型2个方法；
读取httpRequest请求中的body参数，并转换为目标方法的参数把目标方法的返回值转换成指定类型，并写入到httpResponse获取支持的http contentType类型； public interface HttpMessageConverter&lt;T&gt; { //**第1类: 读取参数 //**是否支持读取目标参数类型和http contentType boolean canRead(Class&lt;?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b1d563c6f6246114c86092285213dfaf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0434be3bbdcc2ab6c3b6f5d3dc020551/" rel="bookmark">
			IDEA将内容上传至Git
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.编写好任务之后，准备上传工作：点击蓝色向下箭头，下拉项目，避免上传冲突
2.更新完成之后，点击绿色对号，会弹出可选择上传的文件，勾选后点击commit，上传至本地仓库
若有的内容没有不需要上传，会弹出一个提示窗口，判断是否重试或继续上传，若继续上传，点击commit即可
3.点击工具栏VCS，选择Git，点击绿色箭头Push上传到Git，即可上传成功
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37edc9a2b07a959edc375726c19f54d9/" rel="bookmark">
			BigDecimal 进行四舍五入 四舍六入和保留两位小数,三位四位小数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		舍入模式向“最近的邻居”舍入，除非两个邻居是等距的，在这种情况下向上舍入。 如果丢弃的分数 ≥ 0.5，则与 ROUND_UP 一样； 否则，行为与 ROUND_DOWN 相同。 请注意，这是我们大多数人在小学时所教的舍入模式。
/** * Rounding mode to round towards {@literal "nearest neighbor"} * unless both neighbors are equidistant, in which case round up. * Behaves as for {@code ROUND_UP} if the discarded fraction is * &amp;ge; 0.5; otherwise, behaves as for {@code ROUND_DOWN}. Note * that this is the rounding mode that most of us were taught in * grade school. */ public final static int ROUND_HALF_UP = 4; 舍入模式向“最近的邻居”舍入，除非两个邻居是等距的，在这种情况下向下舍入。 如果丢弃的分数 &gt; 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/37edc9a2b07a959edc375726c19f54d9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/303a0bb3d521349d8ef670cb1852850b/" rel="bookmark">
			c&#43;&#43;中的string和vector
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		知识点1【STL的概述】 STL（Standard Template Library,标准模板库）
STL的三大组件：容器（container）、算法（algorithm）、迭代器（iterator）。
算法操作数据，容器存储数据，迭代器是算法操作容器的桥梁，迭代器和容器一一对应。
STL六大组件
容器 算法 迭代器 仿函数 适配器 空间配置器
容器：存放数据
算法：操作数据
迭代器：容器和算法的桥梁
仿函数：为算法提供更多的策略
适配器：为算法提供更多的参数接口
空间配置器：管理容器和算法的空间
算法的分类：
质变算法：是指运算过程中会改变区间元素的内容。例如拷贝，替换，删除等。
非质变算法：是指运算过程中不会区间的元素内容，例如查找、计数、遍历、寻找极值。
迭代器的分类
知识点2【迭代器的案例】 案例：容器vector
#include &lt;iostream&gt; #include &lt;vector&gt; #include&lt;algorithm&gt; void myPrintInt(int num); using namespace std; void test01(){ //单端动态数组vector类模板 vector&lt;int&gt; arr(0); //push_back()尾部插入数据 arr.push_back(100); arr.push_back(200); arr.push_back(300); arr.push_back(400); //访问数据 //定义一个迭代器存储arr的起始迭代器 vector&lt;int&gt;::iterator beginIt = arr.begin(); //定义一个迭代器存储arr的结束迭代器 vector&lt;int&gt;::iterator endIt = arr.end(); //for循环遍历1 for(vector&lt;int&gt;::iterator i = beginIt; i != endIt; i++){ //对迭代器取* 代表的是 容器的元素 //*biginIt cout &lt;&lt; *i &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/303a0bb3d521349d8ef670cb1852850b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6753ecee8abfbcbe8f8729ecfb0c020/" rel="bookmark">
			如何搭建一台属于自己的服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对于新手小白来说，我推荐使用大厂们的服务器，比如阿里云，腾讯云等，这种不仅有强大的大厂背景支持，且不用担心维护，界面功能友好完善，非常适合新手小白 (๑•̀ㅂ•́)و✧
我使用的是腾讯云，所以接下来以腾讯云为例讲解。
服务器类型的选择 个人用户的话推荐大家使用 👉轻量级服务器👈 性价比会更高。
点击进入购买页面，可以看到一些配置，接下来讲解这些选项。
地域的选择 地域可以选择国内和国外，！！！这里要注意如果购买国外不需要备案，如果是国内则需要上传身份证备案且备案审核通过需要一定的时间！！！，国外的话可以购买亚洲的，比如东京、新加坡这些会快一些，太远了很能会网速比较慢。国内的话就近原则，哪个离你近选哪个，其中港澳台（有的话）也不用备案，不过比较抢手容易没。
系统的选择 如图👇
因为服务器的内存和硬盘内存比较少，所以推荐安装 Linux 系统 (CentOS / Ubuntu)。这里选择的是 CentOS，相对来说稳定一些。当然了 Ubuntu 也可以，系统文件没有 CentOS 那么大，版本 7.6 就可以。套餐推荐通用性，实例就是给你的服务器起个名字。
购买成功后进入服务器控制台界面或者点击头像搜索 “轻量级服务器” 进入控制台。进入之后建议点击 “重置密码” 更改一下你的服务器密码，这个密码用于登录你的服务器，所以不要忘了也尽量复杂点。在你的服务器名称那里显示着你的服务器 IP 地址，用于之后连接你的服务器进行操作
连接服务器 用于远程连接的工具有很多，这里推荐使用 Xshell，虽然收费但是官网有社区版，足够使用了。
安装好后点击 【文件】-&gt; 【新建】-&gt; 【连接】，名称给你的连接取个名字，【主机】 填服务器的 IP 地址，【端口号】 默认即可。
之后点击【用户身份验证】，填写你之前给服务器设置的用户名密码。
点击确定并连接，双击刚刚创建的会话，接受保存弹出来的 SSH 安全警告。这样就远程连接到你的服务器啦😎
宝塔面板的的安装 对于不熟悉 Linux 命令的用户而言，想要熟练的操作系统相比是一件令人头疼的事。因此我们可以安装宝塔面板方便我们的使用和后期网站的搭建。
官网安装命令
Centos安装脚本
yum install -y wget &amp;&amp; wget -O install.sh http://download.bt.cn/install/install_6.0.sh &amp;&amp; sh install.sh Ubuntu/Deepin安装脚本
wget -O install.sh http://download.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e6753ecee8abfbcbe8f8729ecfb0c020/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/655122538aff852e6daa59b779846ad9/" rel="bookmark">
			面试（复盘）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 医渡云1. 项目使用的redis存的什么类型的数据？2.token里面都放了哪些信息，怎么生成及判断？3. SpringCache注解有哪些参数？怎么配置的4.redis存的数据是一直存放吗5. redis清理原理6. Springboot自动装配原理7. Spring Ioc Aop理解8. 除了动态代理，Spring还怎么实现aop9. 怎么判断链表是不是循环链表10. Spring怎么解决bean循环依赖11. HashMap底层数据结构，key在哪，value在哪12. HashMap怎么根据hash获取key，value13. ConcurrentHashMap怎么实现线程安全14. 谈谈Synchronized关键字，怎么实现线程安全15. jvm锁计数器在哪个区域16. 有个concurrentHashMap，多个线程对其增删改查，是否线程安全，为什么17. 线程池的主要参数18. 知道哪些NoSQL数据库19. Mysql事务acid20. MySQL隔离级别，是怎么实现默认隔离级别的21. MySQL索引数据结构22. 什么是聚簇索引，什么是非聚簇索引23. 给一个表，id,name,age，查询name=? &amp;&amp; age = ? ，怎么建索引24. select语句中联合索引的顺序有没有影响，如果写反了是怎么查询的25. 一个10g的文件，里面都是字符串，要查找"hello"26. 怎么判断链表是不是循环链表 京东1.项目介绍，Springcloud提供服务的大概流程2.elasticsearch 怎么保持跟数据库的同步（大量数据不能定时刷新）， elasticsearch 查询为什么快3. logstash定时刷新有什么缺点4. 项目redis存的什么类型的数据，redis还有什么基本数据5. redis缓存命中率如何保证6. redis缓存怎么保证插入新数据之后能在缓存中找到新数据（一致性）7. 了解mq吗8. 介绍一两个jvm垃圾回收器9. innodb 与MyISAM区别10. 项目难点11. hashmap线程安全吗12. Integer a =1000, Integer b =1000, a== b 输出什么 贝壳场景题，多个线程怎么等都出了结果再结束扩展：多线程顺序执行 Redis数据持久化方式项目中Token直接解析可能会出安全问题，应当存到mysql中，注意token过期时间Redis数据结构前后端怎么部署volatail关键字悲观锁，乐观锁Hashmap介绍项目中Redis怎么保持缓存一致性jvm内存模型，例如volatileMysql写一个sum语句，在sum的字段上加索引与不加索引查询速度是不是不一样索引失效情况 网易杭州研究院1. 介绍项目2. 学习java中或者项目中印象比较深的地方。答springboot启动注解，简化配置（埋坑）3. 自己答Springboot 启动类注解，starter等4. springboot 项目启动时的流程，生命周期5. spring bean生命周期6. 项目哪里用到了刚才说的知识。7. 还熟悉哪些java知识 。8.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/655122538aff852e6daa59b779846ad9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9002cff11eedee9eaa99c6a3558edbe1/" rel="bookmark">
			Autodesk cad卸载不干净导致的无法安装问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先讲一下我的经历吧，先是下载2019版本的cad，但由于阅读安装步骤不仔细误以为安装错误，就稀里糊涂卸载了重装，结果就导致了无法再次安装，哪怕我换一个2018的版本仍然不行。前后共尝试了两天，以下是我所总结的方法：
一、使用卸载工具进行彻底卸载
我最先使用的是uninstall tool，包括后来也使用了Autodesk uninstall，但这两款软件都只能在你还没进行软件卸载的时候使用，才能达到完全卸载干净的作用，像我已经卸载了，只是想将其残留文件卸载掉就不太够用。不过我还是将下载链接放上来吧，适合自己的都可以拿来用。
后来我又使用了auto uninstaller，但准确来说并没有使用上，因为安装它需要激活码，而它这个激活码比较特殊，有使用次数上限与使用时间上限（20天），故我在网上找的所有资源都不行。故其卸载效果如何我无从得知，只是网上很多人推荐，想用的朋友也可以花钱去买一个激活码。
链接:https://pan.baidu.com/s/1Opv8OVEyMSfSc_L-OJAFjg?pwd=1111 提取码:1111
复制这段内容打开「百度网盘APP 即可获取」
二、自己卸载所有痕迹，侧重于注册表的卸载
首先大家把所有的c盘d盘各个盘里的Autodesk都卸载干净后，
同时按住Start（A/t旁边那个键）和R键，打开注册表编辑器
→在【运行栏】中输入“regedit”→找到【HKEY_CLASSES_ROOT】-&gt;【Installer】-&gt;【Products】
→删除【Products】目录中前缀为【7D2F......】的文件
→【HEKY_CURRENT_USER】-&gt;【Software】中，找到含有【Autodesk】的文件夹并删除
→【HEKY_LOCAL_MACHINE】-&gt;【SOFTWARE】中，找到含有【Autodesk】的文件夹并删除
这样应该就卸载干净了。
PS:但每个人的情况都不太一样，我终究还是没能卸载干净，仍然安装不上，最终去某宝上买了个远程安装才给搞定。😓😓
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a31620ccb45ae8aabc15ed67cf661da4/" rel="bookmark">
			vue拉取项目regenerator-runtime.js报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		直接安装
npm install regenerator-runtime 就好了
（如果按照它的要求红色框框安装的话会报错）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/101bb8a18464d58a46240a468fc3d0e8/" rel="bookmark">
			认识DLL动态链接库，以及如何用VS创建并调用一个DLL
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		认识DLL动态链接库 DLL是安全人不可缺少的一项技能
要认识动态链接库，首先要认识库这一概念：简单来说，库就是能够提供给使用者包含一些开箱即用的变量、函数或类的可执行代码的二进制形式，它可以被操作系统载入内存执行。
库分为两种，静态库（windows中后缀.lib）与动态库（win中后缀.dll）
这两类库的区别体现在程序的链接阶段：静态库在程序的链接阶段被直接复制到了程序中；动态库则没有，而是在程序运行时由系统动态加载到内存中供程序调用。
由此，动态链接库的优势体现了出来，那就是它相比于静态链接库来说非常节省内存，在程序运行时只需要动态加载一次即可，这也是如今动态链接库被高频使用在大型软件中的原因（用户在更新时只需要更新动态库即可，增量更新）。
实现工具：Visual Studio 2022
编程实现Dll 在此我们编写两个函数，一个函数返回斐波那契数列前n项之和，另一个函数返回输入值的阶乘
打开vs创建dll动态链接库新项目，项目名为Dll1
之后分别添加头文件mydll.h和源文件mydll.cpp
编写头文件：
在编写头文件时，通常都会加第3，4行代码，这是为了防止头文件的重复调用；由于要用C编写函数代码，所以要用exturn “C”声明在链接时使用C库函数规范来链接。在函数定义前面的__declspec(dllexport)用于导出符号，也就是定义该函数的dll；
编写源文件：
编写实现输出斐波那契数列前N项和的函数Fibonacci_Sum（）
（注意在文件头要加上刚才编写好的头文件，这样编写好的函数才能被导出为dll）
编写返回输入值阶乘的函数Factorial（）
编写完成，右键项目生成方案：
编程，调用实现的DLL 添加新项目，选择控制台应用
由于要调用DLL，所以需要设置此项目的属性：
首先，由于需要包括mydll.h这个头文件，需要在包含路径中设置：
其次，需要引入lib符号文件：
在链接器属性一栏中添加符号文件作为依赖项
然后给符号文件添加搜索路径：
最后，添加源文件编写调用代码调用DLL:
调用代码分别调用了两个函数，分别输出前5项斐波那契数列之和以及5的阶乘：
调用成功！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a5f0fc8c63bbde6171e6150ecb59ca1/" rel="bookmark">
			电信中兴光猫ZXHN F650超管密码获取工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		电信中兴光猫ZXHN F650超管密码获取工具 1. 参考来源2. 使用方法 1. 参考来源 尊重技术，大力感谢：
https://github.com/voidxxl7/ZXHN-F650-PassReader 同时参考以下博文：
https://www.52pojie.cn/thread-999381-1-1.html https://www.52pojie.cn/thread-1005978-1-1.html 2. 使用方法 设备类型：GPON天翼网关(4口单频)
设备型号：ZXHN F650
固件版本：V2.0.0P1T1
下载文件：https://github.com/voidxxl7/ZXHN-F650-PassReader/releases
若是有的朋友进不去github或者下载速度太慢了，可以用这个链接:
https://wwc.lanzoul.com/iV4pb0cm9dzc 密码:fqfa
下载完成后，直接双击运行即可。
输入光猫背面的“默认终端配置密码”
然后就OK了！
然后做你想做的事！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48d0529bb67c397276ead164a5a5b058/" rel="bookmark">
			分治法——线性时间选择
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		线性时间排序算法的目的是为了从一堆乱序数组中找到第k小的元素，最开始给出的代码是先将乱序数组按照线性顺序排序，然后从中找出第k小的元素。
上图代码使用上节内容学过的快速排序，用RandomizedPartition将a划分为[p,i] [i+1,r]
j=i-p+1即为[p,i]中包含的元素，虽然还未对这两段进行过排序，但我们知道左端是小于a[j]的，而右端是大于a[j]的，因此a[j]的排序顺序是正确的，我们比较k与j的大小，如果发现k&lt;=j，那么k的位置一定是在左端[p,j]（因为题目中的k是从1开始的，而数组却是从0开始的，也就是说k=2，数组元素对应a[1]，k如果正好为我们划分的基准元素，k=j+1),而k&gt;j时，则对右端进行随机选取。（其实这里有个问题，k=j+1时就应该找到k直接输出)。直到分无可分则输出最后的结果k。
简单描述一下优化后的选择划分基准，仔细对比图2-7，
首先它将所有元素分为5个一组，那么分成的结果最多只有一组不满5个，假设n/5正好是整数，如图所示分成了7组。首先要明白为什么55分组，因为考虑到查找的最快情况，如果我们找到了需要寻找的k在那一组，以中位数为基准，每一段仅仅需要查找两个数，这样就能快速找到k在那组的什么位置。
如果我们对所有元素进行排序，那么情况肯定是很复杂的，并且如果从一个很大的数组也不方便寻找中位数。而55分组是很方便寻找中位数的，因此我们选出每组的中位数（因为只有五个数字，因此使用任意排序算法皆可），即为图中的白点。7组找到了7个白点，然后将所有中位数看作一组，再次使用快速排序的思想，寻找到所有基准数中的中位数，将这个中位数作为划分基准。从中位数组的中位数划分出k的位置，然后寻找到k应当属于那一个中位数组，最后在这个中位数组中寻找k的位置。
算法中认为分成3（n-5）/10&gt;=n/4，因此n=75，当数组长度&lt;75时需要对数组进行简单排序
最接近点对问题好像有点复杂了，因此先不讲了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de5e78df77047f2c1d9b6828d0049183/" rel="bookmark">
			C&#43;&#43;11之内联名字空间（inline namespace）和ADL特性(Argument-Dependent name Lookup)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列文章 C++11之正则表达式（regex_match、regex_search、regex_replace）
C++11之线程库（Thread、Mutex、atomic、lock_guard、同步）
C++11之智能指针（unique_ptr、shared_ptr、weak_ptr、auto_ptr）浅谈内存管理
C++11之强制类型转换（static_cast,const_cast,dynamic_cast,reinterpret_cast）
C++11之Lanbda表达式(匿名函数)
C++11之右值引用：移动语义和完美转发(带你了解移动构造函数、纯右值、将亡值、右值引用、std::move、forward等新概念)
C++11之委派构造函数
C++11之显式转换操作符-explicit
C++11之初始化列表
C++11之防止类型收窄（列表初始化）
C++11之用户自定义字面量(ClassType operator““_C(param…))
目录 系列文章场景需求命名空间嵌套的弊端内联名字空间（inline namespace）通过内联命名空间优化嵌套问题内联命名空间配合宏使用 ADL特性(Argument-Dependent name Lookup)总结 场景需求 在早期C项目中，我们常常会因为命名冲突问题需要有一个“字典”来存储所用过的变量。这是因为在C语言中非静态全局变量、函数都是全局共享的。
C++就通过命名空间（也叫名字空间）来解决C语言中这个头疼的问题。实现分割全局共享的命名空间。程序员在编写代码时可以自己设置命名空间，使用者只需要通过空间名::函数/变量或者using namespace 空间名就可以使用（推荐使用前者方法）。但是，当我们空间名嵌套多层时在使用上不是很方便。
命名空间嵌套的弊端 在下面这段代码中，用户1将他的代码封装为LINXI，然后内部又进行了细分为BB、CC、DD。而且在DD空间下使用了BB的类型。
#include &lt;iostream&gt; using namespace std; namespace LINXI { namespace BB { class T1 { public: T1() { cout &lt;&lt; "T1 is BB" &lt;&lt; endl; } }; } namespace CC { template&lt;class T&gt; class T2 { }; } namespace DD { BB::T1 t1; class T1 { public: T1() { cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/de5e78df77047f2c1d9b6828d0049183/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2da0d81b3dd803f6dfc01dbc2959b9e3/" rel="bookmark">
			对于Kalman滤波器的简单理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 简单说下，贝叶斯两大分支之一的卡尔曼家族的小弟，线性高斯滤波器（KF）。
何为线性？自然指的是系统是线性的（系统方程满足齐次性、叠加性）。
何为高斯？自然指的是噪声服从高斯分布。
核心：通过计算卡尔曼增益，去加权融合观测结果（量测）与预测结果（估计）；一般，量测是观测模型带来的结果，预测是运动模型带来的结果。 主要分为预测、更新两大步骤。
过程：预测部分，根据t-1时刻的后验估计和后验协方差更新当前t时刻的先验估计和先验协方差矩阵；更新部分，加入观测数据，更新t时刻卡尔曼增益，加权状态的先验值和残差（红色框）得到后验状态值，更新后验协方差矩阵； 设系统状态向量为x，系统状态的不确定性是通过协方差矩阵去反应，而协方差矩阵Pt的转移是卡尔曼滤波器很关键的一步骤，它是通过系统的状态转移矩阵Ft，如下所示：
状态转移矩阵F、以及状态控制矩阵B的获取，一般是通过构建系统对于状态量的物理学运动方程获得。Q、R分别是预测部分（运动方程噪声Wk~N(0, Q)）和观测部分(观测方程噪声Vk~(0, R))的噪声方差。
附加：高斯分布N(μ，σ2)
工程上，一般取正负3*σ（3倍标准差），偏离均值3σ的数据就不要了。
正态分布的概率密度函数，对称轴为均值μ（期望），方差σ2（代表整个数据集合的误差水平）。最高点值为均值对应的概率密度。正态分布的随机变量取与均值邻近的值的概率大（粉色区区域），取离均值远的值的概率小。各个数据与平均数的差的平方和较大，分布则比较散开；曲线与横轴积分值为1；
0均值的高斯分布N(0，σ2)：对于卡尔曼滤波器而言，噪声服从0均值不相关的高斯分布Wk~N(0, Q)、Vk~(0, R)，则卡尔曼滤波器得到的解便是最优解（无偏最优估计）；
标准高斯分布N(0，1)；
从概率角度使用最大后验概率估计的形式（后验=似然*先验），以实际数值感受一下推导过程。假设现在两个高斯分布，一个为观测数据的分布，一个为预测数据的分布，那么如何得到kalman认为的最优估计值呢？
首先，我们认为我们要求解的最优估计值也是服从高斯分布的，并且该高斯分布的均值，就是我们要寻找的值。那么kalman如何做呢？即使将观测数据的分布与预测数据的分布相乘。
假设两组数据计算如下：
其中，红色框中的即为Kalman增益。
理解下图的更新加权过程：
实际使用中可能的问题：在长时间丢失量测数据或者系统状态处于可观测性弱，由于系统噪声的不断输入，系统的协方差矩阵会越变越大。为了防止卡尔曼滤波的协方差矩阵出现病态，根据实际情况要将卡尔曼的协方差矩阵进行阈值限定，防止协方差矩阵无限扩大；
使用KF进行陀螺仪角度融合代码：
class kfForImuFilter { public: double angle; //系统状态向量（angle角度，Q_bias角速度偏移） double Q_bias; double X[2][1] = {angle, Q_bias}; private: bool isfirst; //系统第一次进行，将量测数据作为最优估计 double Q_angle = 0.001; //系统状态的方差，状态不相关，所以两状态之间的协方差为0，见P矩阵 double Q_gyro = 0.003; double R_angle = 0.5; //观测误差（观测量：角度） double dt = 0.002; //采样时间（用于积分） double A[2][2] = { //系统的状态转移矩阵 1, -dt, 0, 1 }; double P[2][2] = { //系统状态协方差矩阵 Q_angle, 0, 0, Q_gyro }; double H[1][2] = { //测量矩阵 1, 0 }; double R[1][1] = { //量测的噪声矩阵 R_angle }; double K[2][1]; //卡尔曼增益 public: kfForImuFilter(){ isfirst = true; } ~kfForImuFilter(){} /* * newAngle ：量测-角度（陀螺仪输出直接计算的角度） * newGyro ：模型估计-角速度 */ void kfForImuFilterProcess(double newAngle, double newGyro){ if(isfirst){ // 初始状态 X[0][0] = newAngle; X[1][0] = 0; isfirst = false; } /**********预测************/ // 模型预测当前状态 X[0][0] = X[0][0] + (newGyro-X[1][0])*dt; X[1][0] = X[1][0];	// 协方差矩阵传播 P[0][0] += Q_angle - (P[0][1] - P[1][0])*dt; // + P[1][1]*pow(dt,2) //由于此项太小可以忽略 P[0][1] += -P[1][1]*dt; P[1][0] += -P[1][1]*dt; P[1][1] = P[1][0] + Q_gyro; /**********更新************/ // 开始使用量测数据 // 计算卡尔曼增益 K[0][0] = P[0][0] / (P[0][0]+R[0][0]); K[1][0] = P[1][0] / (P[0][0]+R[0][0]); // 计算当前状态的最优估计 X[0][0] += K[0][0]*(newAngle - X[0][0]); X[1][0] += K[1][0]*(newAngle - X[0][0]); // 协方差更新 P[0][0] += -K[0][0]*P[0][0]; P[0][1] += -K[0][0]*P[0][1]; P[1][0] += -K[1][0]*P[0][0]; P[1][1] += -K[1][0]*P[0][1]; } /* * 一阶互补滤波 * 角度、角速度 */ void cf_firstOrder(float K, float angle_m, float gyro_m) { angle = K*angle_m + (1-K)*(angle + gyro_m * dt);	// x_2 = x_1 + v*t , t:系统采样时间 } }; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/653540eecb8c54033500b5eb6be11919/" rel="bookmark">
			vmware workstation Pro 16使用ghost镜像安装windows11
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		windows11系统上市以来，一直有想法安装测试系统性能等，但考虑到硬件兼容性等问题，一直未在物理机上安装过，最近闲着就在网上下载了个ghost镜像，在虚拟机里面安装了一个win11，以下记录了安装过程。
需要准备材料 1、vmware workstation Pro 16
2、带引导启动的U盘
3、windows11的ghost镜像文件
一、配置虚拟机 1、点击创建虚拟机
2、新建虚拟机-选择典型
3、选择稍后安装操作系统
4、选择windows 10 x64版本的windows操作系统
5、修改虚拟机名称及安装位置
6、设置虚拟机磁盘大小及保存方式，按默认设置即可
7、 完成向导，新建好虚拟机
二、添加物理引导硬盘 1、在虚拟机主界面，点击“编辑虚拟机设置”
2、修改内存为4G
3、点击“添加……”，添加硬盘
4、 选择SATA的虚拟磁盘类型，继续下一步
5、 选择“使用物理磁盘”，继续下一步（注意：此步骤需要以管理员身份运行vmware才能继续，否则继续下一步时会报错）
6、 “设备”列表中选择最后一个（新插入的移动硬盘一般为最后一个）
7、使用情况选择“使用整个磁盘”，继续下一步
8、确认关联的物理硬盘的文件名，继续完成
9、完成后显示新增硬盘，磁盘信息中将显示对应物理硬盘的容量，可以核对容量与物理硬盘是否对应
三、ghost恢复系统 1、在启动按钮选项里面选择“打开电源时进入固件”
2、选择刚新增的硬盘启动系统
3、进入物理硬盘的引导系统，选择对应的带ghost软件的维护系统并进入
4、进入维护系统后先格式化硬盘
5、使用ghost工具恢复系统，完成后关闭系统
四、系统自动安装 1、删除新增的物理硬盘
2、正常启动虚拟机，如果出现如下错误，需要关闭虚拟机，按照第三步的图片配置
3、如果uefi启动失败，需要将虚拟机的“固件类型”修改为“BIOS”
4、重新启动虚拟机，当虚拟机出现以下画面即系统启动成功
5、接下来系统将自动安装并多次重启，直到安装完成
以上为虚拟机中通过ghost镜像安装windows11的全过程，如有疑问的朋友，可以私信博主咨询。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0bfdb1a4fb41ecc9dc8402f7d0ade87a/" rel="bookmark">
			Java synchronized类锁，对象锁详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考原文链接：Java synchronized类锁，对象锁详解(转载整理)_student100000的博客-CSDN博客_java synchronized 类锁
目录
一、synchronized的用法
1.同步代码块（对象锁）
2、同步方法（对象锁）
3、静态方法（类锁）
4、同步代码块（类锁）
二、对象锁和类锁
对象锁---synchronized修饰方法和代码块：
类锁---修饰静态方法和代码块
类锁---对象锁
一、synchronized的用法 1.同步代码块（对象锁） public class Demo implements Runnable{ @Override public void run() { /** * 同步代码块形式---&gt;锁为this，两个线程使用的锁是一样的， * 线程1必须要等到线程2释放了该锁后，才能执行 */ synchronized (this) { System.out.println(Thread.currentThread().getName() + "开始执行"); try { Thread.sleep(2000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName() + "执行结束"); } } public static void main(String[] args) { Demo demo = new Demo(); new Thread(demo,"线程1").start(); new Thread(demo,"线程2").start(); } } 代码块中的synchronized(this)，指获取类Demo创建的实例对象demo中的内置锁（锁定当前代码块执行者），可以看到线程2必须要等到线程1释放了该锁后，才能执行。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0bfdb1a4fb41ecc9dc8402f7d0ade87a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/daffc17adab2194f0dd0f198291d530b/" rel="bookmark">
			Docker入门学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Docker入门学习 Docker安装
Docker Hello World docker run ubuntu:15.10 /bin/echo "Hello world" 解释：Docker 以 ubuntu15.10 镜像创建一个新容器，然后在容器里执行 bin/echo “Hello world”，然后输出结果。
docker: Docker 的二进制执行文件。run: 与前面的 docker 组合来运行一个容器。ubuntu:15.10 指定要运行的镜像，Docker 首先从本地主机上查找镜像是否存在，如果不存在，Docker 就会从镜像仓库 Docker Hub 下载公共镜像。/bin/echo “Hello world”: 在启动的容器里执行的命令 运行交互式的容器 docker run -i -t ubuntu:15.10 /bin/bash -t: 在新容器内指定一个伪终端或终端。-i: 允许你对容器内的标准输入 (STDIN) 进行交互。 运行 exit 命令或者使用 CTRL+D 来退出容器。
后台启动容器 docker run -d ubuntu:15.10 /bin/sh -c "while true; do echo hello world; sleep 1; done" 返回的长串代表的是容器ID“adfe9755…”
docker ps用来查看容器
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/daffc17adab2194f0dd0f198291d530b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64e562f381233662511ce34e87414e18/" rel="bookmark">
			MySQL中 count(*)、count(主键id)、count(字段)和count(1)的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		标题 count() 函数不同执行方式的执行区别 count(*) ：对于这个命令，会每遍历一条数据进行累加，排除全字段为空的数据情况下 count++
count(1) ：相当于新加一列，列值为1，此时每一行数据都会进行累加 count++
count(主键字段) ：对于主键进行遍历，然后按行累加 count++【主键不为空】
count(普通字段) ：针对普通字段进行逐行遍历，每当该字段值不为空的时候进行累加 1
count()函数执行效率 count（普通字段）&lt; count（主键字段）&lt; count（1）≈ count（*）
count() 函数实际执行的优化 常规情况下：
对于count(*) ,count(1) 和count(主键)而言，在底层的执行都是通过查询 主键索引树来进行遍历，只要遍历一个索引树就进行加一，这样就会将速率提高，对于一定程度而言，三者的查询效率的几乎相近的
但是对于count(主键) 而言，实际在执行主键索引树时，他会将查询的id 进行返回 ，然后再进行累加，所以一定程度上速率是比前两者的速率要慢的。
对于count(普通字段) 而言，在查询的时候是不走索引树的，但是在执行的时候会进行全表扫描，然后判断是否为空再进行累加
在创建普通索引时：
对于mysql底层而言，主键索引又叫聚簇索引，普通索引为非聚簇索引
对于主键索引而言，我们每一个的叶子节点存储的是所有数据（一整行数据）
对于非主键索引而言，每一个叶子节点存储的是只有主键id
在具体执行查询的时候，主键索引的内存比较大，非主键索引的内存比较小，故在这里mysql底层做出优化
当只有主键索引时，查询主键索引树，当既有主键索引和普通索引的时候，优先查询普通索引进行count
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b529b9ba12ff4a821a58a1f446f97a26/" rel="bookmark">
			Could not find androidx.camera:camera-view
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Search google’s maven repo https://maven.google.com/ to see if the version you are looking for is even the correct one or what is the latest version of the library exists. like in your case https://maven.google.com/web/index.html?q=camera#androidx.camera:camera-view
参考：
Could not find androidx.camera:camera-view
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb925253fa4e9352613aaa41ff79ecf1/" rel="bookmark">
			初入datawork生态圈的架构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前文：
越来越多小公司上云了，这个是大势所趋。现在主流是阿里云和腾讯云，此文通过分享这两个下来的感受让大家接触云平台开发。
一、背景 相比自建机房，大部分公司上云省时省力，具体上哪个云取决于公司的业务发展，毕竟拉通带宽蛮贵的，腾讯云成本比阿里云便宜一半，但阿里的组件生态圈选择性比较多(其实也没多少预算可以选择...) 如果选择上云，那么你有两种选择，平台开发/EMR模式，取决于人员配置/业务发展，一个人才成本高/一个组件成本高。因为是新建团队，为了响应需求，目前是选择了平台开发快速交付。
二、架构 2.1 主要架构 2.2 数据集成 2.2.1 业务库投递方案 目前所有数据库都在阿里云的数据库上，所以直接使用datawork数据同步工具即可。
2.2.2 实时日志投递方案 结论：实时链路通过使用datahub一键投递，按需付费更便宜，并可解决数据偏移问题。这里有个小片段，如果没啥实时需求kafka开通了晾在那也蛮贵的，还需要懂 flink 的人员配置。
2.3 开发 2.3.1 离线开发 天/小时级别作业通过datawork开发，写入到 mysql 或 holo 外部表查询。
2.3.2 实时开发 分钟级别作业：基于 datawork 调度每 5/10分钟 调度holo脚本。
实时级别作业：通过 flink 实时计算后 入库。
主要还是看场景，增量/全量场景区分好选型即可；flink实时计算有定制语法帮助实现mysql数据实时同步到holo，满足实时场景，datawork就达不到这种效果。
详情参考：Hologres推荐的数仓分层-数据-场景-实时-实时数仓Hologres-阿里云
2.4 优缺点 2.4.1 优点 (1) 开发：数据地图，协助我们看每张表的血缘地图，并可一键查看该表所有信息。很多公司投入大量研发后基本没有产出。
(2) 调度：基于作业实例调度，当中间某个节点未完成/错误将导致下游所有节点阻塞，重跑该节点后下游节点可自动修复。像使用dolphinscheduler，下游作业要一个一个去重跑极其麻烦。
(3) 告警：一键配置全局作业告警，无需每个作业配置告警。
2.4.2 缺点 (1) 价格昂贵，预算不足，很多组件无法测试/开通。
(2) datawork 无法/微批次 更新贴源层数据，T+1拉取业务库大表对业务库影响较大。虽然有实时同步作业，但是应该是个kpi诞生下的怪胎。业界基本都有hudi、iceberg等解决方案，不知道后续是否有兼容计划，或还是得去用另一个数据湖分析组件。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/303f2fb7226ca938bb8dfed249a29ca4/" rel="bookmark">
			Jetson Nano2GB（TX2\NX\XAVIER）使用ffmpeg进行硬解码配置笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		到目前为止Jetson设备ffmpeg 硬件编码尚不可用。
l4t3261 jetpack4.6
FFmpeg在Linux平台下开发，但它同样也可以在其它操作系统环境中编译运行，包括Windows、Mac OS X等。这个项目最早由Fabrice Bellard发起，2004年至2015年间由Michael Niedermayer主要负责维护。许多FFmpeg的开发人员都来自MPlayer项目，而且当前FFmpeg也是放在MPlayer项目组的服务器上。项目的名称来自MPEG视频编码标准，前面的"FF"代表"Fast Forward"。 FFmpeg编码库可以使用GPU加速
nvidia论坛地址参考
Jetson开发人员指南 $ echo "deb https://repo.download.nvidia.com/jetson/ffmpeg main main" | sudo tee -a /etc/apt/sources.list $ echo "deb-src https://repo.download.nvidia.com/jetson/ffmpeg main main" | sudo tee -a /etc/apt/sources.list $ sudo apt update $ apt source ffmpeg $ Reading package lists... Done Need to get 8,960 kB of source archives. Get:1 https://repo.download.nvidia.cn/jetson/ffmpeg main/main ffmpeg 7:4.2.7-nvidia (dsc) [592 B] Get:2 https://repo.download.nvidia.cn/jetson/ffmpeg main/main ffmpeg 7:4.2.7-nvidia (tar) [8,960 kB] Fetched 8,960 kB in 11s (834 kB/s) dpkg-source: info: extracting ffmpeg in ffmpeg-4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/303f2fb7226ca938bb8dfed249a29ca4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b757cbf846728355514575a5a35ad712/" rel="bookmark">
			记录一次nacos版本导致的bug
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		bug记录 com.alibaba.nacos.shaded.io.grpc.StatusRuntimeException: UNAVAILABLE: io exception ... c.a.n.c.remote.client.grpc.GrpcClient : Server check fail, please check server 121.4.119.16 ,port 9848 is available , error ={} ... 基础服务nacos2.0.2
本地使用springcloudalibaba套件搭建服务发现
异常的版本：
&lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt; &lt;version&gt;2021.0.4.0&lt;/version&gt; &lt;/dependency&gt; 使用这个版本的服务发现，会一直找8848+1000，也就是9848端口，原因是更新后，加了rpc，增加服务发现性能，但是需要端口，于是就默认在8848上做了一个偏移，偏移值是1000，也就是9848端口.
如果你没有暴露9848端口，服务就一直报错，但是你这个偏移量又不能在配置文件中配置。
解决方案1 回退版本到2021.0.1.0,这个版本中的spring-cloud-starter-alibaba-nacos-discovery不会去找9848端口。但是也不会使用grpc的新特性
解决方案2 不回退版本，开放9848端口即可
解决方案3 不回退版本，9848端口被其他程序占用，我只想开放8849端口，那么可以在vm启动参数中添加-Dnacos.server.grpc.port.offset=1
或者在启动类硬编码System.setProperty("nacos.server.grpc.port.offset","1");
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1399eb40100ccb8cda81e2bbb7da0c94/" rel="bookmark">
			雪花算法导致返回前端ID不一致问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一次引入雪花算法当作生成主键，遇到问题如下：
前端请求获取的response的值，ID和后端返回的值不一致，排查了很久发现是前端在获取时将Long类型值转换超范围导致丢失精度
Java后端Long类型的范围
-2^63~2^63，即：-9223372036854775808~9223372036854775807，它是19位的。这个数字可以通过方法获得：Long.MAX_VALUE、Long_MIN_VALUE。 前端JS的数字类型的范围
-2^53~2^53，即：-9007199254740991~9007199254740991，它是16位的。这个数字可以通过方法获得：Number.MAX_SAFE_INTEGER、Number.MIN_SAFE_INTEGER。 解决办法
1. 全局处理 自定义ObjectMapper
import com.fasterxml.jackson.databind.ObjectMapper; import com.fasterxml.jackson.databind.module.SimpleModule; import com.fasterxml.jackson.databind.ser.std.ToStringSerializer; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.http.converter.json.Jackson2ObjectMapperBuilder; @Configuration public class JacksonConfig { @Bean public ObjectMapper jacksonObjectMapper(Jackson2ObjectMapperBuilder builder) { ObjectMapper objectMapper = builder.createXmlMapper(false).build(); // 全局配置序列化返回 JSON 处理 SimpleModule simpleModule = new SimpleModule(); // 将使用String来序列化Long类型 simpleModule.addSerializer(Long.class, ToStringSerializer.instance); simpleModule.addSerializer(Long.TYPE, ToStringSerializer.instance); objectMapper.registerModule(simpleModule); return objectMapper; } } 2. 局部处理 在字段上加：@JsonSerialize(using= ToStringSerializer.class)
@Id @GeneratedValue(generator = "myIDGenerator") @JsonSerialize(using= ToStringSerializer.class) private Long id; 注意：全局处理会将分页参数页码、总条数值也转成string类型
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef82c45e069cedab082ed94e88d21ace/" rel="bookmark">
			Git的安装卸载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Git的安装： Git安装地址:https://git-scm.com/downloads
下载完成后直接下一步下一步就可以了，全部采用git默认的
Git卸载： 1.在环境变量中把git的环境变量删除
2.去控制面板中卸载Git即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/572a7ffceb2a1f679db01bb20aa2214c/" rel="bookmark">
			poi升级 ExcelUtil部分更新以及新问题产生小记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、版本升级触发条件 引入hutool新工具包，pom依赖与原系统旧版本冲突，导致报错 &lt;dependency&gt; &lt;groupId&gt;cn.hutool&lt;/groupId&gt; &lt;artifactId&gt;hutool-all&lt;/artifactId&gt; &lt;version&gt;5.6.4&lt;/version&gt; &lt;/dependency&gt; 二、由于poi版本升级引起的其他错误，需更新部分设置适配新版本 1、poi版本对比 旧版本： &lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi&lt;/artifactId&gt; &lt;version&gt;3.13&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi-ooxml&lt;/artifactId&gt; &lt;version&gt;3.13&lt;/version&gt; &lt;/dependency&gt; 新版本： &lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi&lt;/artifactId&gt; &lt;version&gt;5.2.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi-ooxml&lt;/artifactId&gt; &lt;version&gt;5.2.2&lt;/version&gt; &lt;/dependency&gt; 2、Cell类型对比 旧版本： switch (cell.getCellType()) { case Cell.CELL_TYPE_STRING: value = cell.getRichStringCellValue().getString().trim(); break; case Cell.CELL_TYPE_NUMERIC: if (HSSFDateUtil.isCellDateFormatted(cell)){ //用于转化为日期格式 Date d = cell.getDateCellValue(); value = formater.format(d); }else if ("General".equals(cell.getCellStyle().getDataFormatString())) { value = df.format(cell.getNumericCellValue()); } else if ("m/d/yy".equals(cell.getCellStyle().getDataFormatString())) { value = sdf.format(cell.getDateCellValue()); } else { value = df2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/572a7ffceb2a1f679db01bb20aa2214c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ffe2c93a8eb4c6d37f3edae14204111/" rel="bookmark">
			【红日靶场系列】ATT&amp;CK红队评估5
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		靶场搭建 靶场下载地址：
http://vulnstack.qiyuanxuetang.net/vuln/detail/7/
虚拟机密码
win7
sun\heart 123.com
sun\Administrator dc123.com
2008
sun\admin 2020.com
Win7双网卡模拟内外网
环境配置：
win7：
外网网卡：192.168.135.150
内网网卡：192.168.138.136
win2008：
192.168.138.138
win7上开启phpstudy
win7关闭防火墙，不然本机访问不到web服务
本机访问192.168.135.150，访问成功，环境搭建成功
外网打点 nmap扫描
nmap -sS 192.168.135.150 有个web站点80、3306mysql数据库，先从web站点入手
ThinkPHP 5.0.22 任意命令执行getshell thinkphp综合利用工具进行攻击
tp5_invoke_func_code_exec_1漏洞攻击成功
上传webshell，哥斯拉进行连接
dirsearch目录扫描发现大佬的大马
哥斯拉下载源码查看找到MD5加密的密码
MD5解密得到明文密码admins
Mysql弱口令 翻文件找到数据库配置文件，但是没有密码
猜测密码为root，连接成功
内网渗透 上线CS 权限提升 信息搜集 发现双网卡，内网网段为192.168.138.0/24，域内主机
ipconfig /all mimikatz 获取用户密码以及NTML、SID值
开启远程桌面进行连接 横向移动 fscan扫描 上传fscan对192.168.138.0/24网段进行扫描
Psexec 横向拿下域控 SMB Beacon使用命名管道通过父级Beacon进行通讯，当两个Beacons链接后，子Beacon从父Beacon获取到任务并发送。因为链接的Beacons使用Windows命名管道进行通信，此流量封装在SMB协议中，所以SMB Beacon相对隐蔽，绕防火墙时可能发挥奇效。
wmiexec横向拿下域控 python3 wmiexec.py -debug admin:Nsfocus@123@192.168.138.138 黄金票据 在域控获得KRBTGT账户NTLM密码哈希和SID
黄金票据是伪造票据授予票据（TGT），也被称为认证票据。TGT仅用于向域控制器上的密钥分配中心（KDC）证明用户已被其他域控制器认证。
黄金票据的条件要求：
1.域名称
2.域的SID值
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5ffe2c93a8eb4c6d37f3edae14204111/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e7fadecedd6d1e1e8ba68f1cdea934c/" rel="bookmark">
			iOS 比较全的DeviceSupport文件下载地址（包含15.7）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://github.com/JinjunHan/iOSDeviceSupport
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c4832779852e014f0ea5069f248501d/" rel="bookmark">
			HTML复习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HTML中的特殊字符 在HTML中，一些特殊的符号很难或者不方便直接使用，此时我们就可以使用下面的字符来替代。
特殊字符描述字符的代码空格符&amp;nbsp;&lt;小于号&amp;lt;&gt;大于号&amp;gt; 文本格式化标签 在网页中，有时需要为字体设置粗体、斜体或下划线等效果，这是就需要用到HTML中的文本格式化标签，使文字以特殊的方式显示。
标签语义：突出重要性，比普通文字更重要。
图像标签 在HTML标签中，&lt;img&gt;标签用于定义HTML页面中的图像。
&lt;img src="图像URL" /&gt; src是&lt;img&gt;标签的必须属性，它用于指定图像文件的路径和文件名。
图像标签的其它属性：
表格标签 表格的基本语法： &lt;table&gt; &lt;tr&gt; &lt;td&gt;单元格内的文字&lt;/td&gt; ... &lt;/tr&gt; ... &lt;/table&gt; &lt;table&gt;&lt;/table&gt;是用于定义表格的标签。&lt;tr&gt;&lt;/tr&gt;标签用于定义表格中的行，必须嵌套在&lt;table&gt;&lt;table&gt;标签中。&lt;td&gt;&lt;td&gt;用于定义表格中的单元格，必须嵌套在&lt;tr&gt;&lt;tr&gt;标签中。字母td指表格数据（table data），即数据单元格的内容。 表格属性： 表格标签这部分属性我们在实际开发中不常用，后面通过CSS来设置。
表单标签 &lt;input&gt;表单元素 type属性的属性值及其描述如下：
属性值描述button定义可点击按钮（多数情况下，用于通过JavaScript启动脚本）checkbox定义复选框file定义输入字段和“浏览“按钮，供文件上传hidden定义隐藏的输入字段image定义图像形式的提交按钮password定义密码字段。该字段中的字符被掩码radio定义单选按钮reset定义重置按钮。重置按钮会清除表单中的所有数据submit定义提交按钮。提交按钮会把表单数据发送到服务器text定义单行的输入字段，用户可在其中输入文本。默认宽度为20个字符 除type属性外，&lt;input&gt;标签还有其他很多属性，其常用属性如下：
属性属性值描述name由用户自定义定义input元素的名称value由用户自定义规定input元素的值checkedchecked规定此input元素首次加载时应当被选中maxlength正整数规定输入字段中的字符的最大长度 name和value是每个表单元素都有的属性值，主要给后台人员使用。name表单元素的名字，要求单选按钮和复选框要有相同的name值。checked属性主要针对于单选按钮和复选框，主要作用一打开页面，就可以默认选中某个表单元素。maxlength是用户可以在表单元素输入的最大字符数，一般较少使用。 &lt;label&gt;标签 &lt;label&gt;标签为input元素定义标注（标签）。
&lt;label&gt;标签用于绑定一个表单元素，当点击&lt;label&gt;标签内的文本时，浏览器就会自动将焦点（光标）转到或者选择对应的表单元素上，用来增加用户体验。
&lt;label&gt;语法： &lt;label for="sex"&gt;男&lt;/label&gt; &lt;input type="radio" name="sex" /&gt; 核心：&lt;label&gt;标签的for属性应当与相关元素的id属性相同。
&lt;select&gt;表单元素 在页面中，如果有多个选项让用户选择，并且想要节约页面空间时，我们可以使用&lt;select&gt;标签控件定义下拉列表。
&lt;select&gt;语法： &lt;select&gt; &lt;option&gt;选项1&lt;/option&gt; &lt;option&gt;选项2&lt;/option&gt; &lt;option&gt;选项3&lt;/option&gt; ... &lt;/select&gt; &lt;select&gt;中至少包含一对&lt;option&gt;
在&lt;option&gt;中定义selected= “selected” 时，当前项即为默认选中项。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0aa1ac13c81b55fafb875d1ac9f03c11/" rel="bookmark">
			VMLogin 主帐号和子账号的功能介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		主账户：
SOLO/TEAM/SCALE/CUSTOM套餐的账户可以创建子账户协助操作，可以分享或转移配置文件所有权给VMLogin用户。
1、主账户可以设置子账户是否享有创建配置文件的权限：打开“配置文件创建”按钮，子账户则拥有独立创建配置文件的权限。 子账户创建的配置文件可以分享，删除或转移配置所有权给其他VMLogin浏览器的账户。关闭此按钮则无法创建配置文件，只能使用别人分享给自己的配置文件，且不可修改设置。
2、主账户可以设置子账户是否享有查看主账户分享的配置文件的权限：打开“查看配置文件”按钮，则表示子账户可以查看主账户分享给自己的配置文件设置，关闭则看不到配置文件设置，只能打开浏览器使用。
3、主账户可以设置子账户是否享有编辑代理的权限：打开“代理编辑”按钮，则表示子账户可以修改主账户分享给自己的配置文件代理IP信息，关闭则无法修改。
4、主账户可以修改子账户的账户密码，删除子账户。
注：删除子账户时会将子账户内的配置文件一并删除，且不可恢复。在删除之前，可以先批量转移配置文件所有权到其他帐号再删除子账户，在转移之前请确保已打开同步设置。
子账户：
开通【配置文件创建】权限的子账户，将拥有与主账户同等的独立创建权限。
配置文件操作说明：
1、创建：
a.有【配置文件创建】权限的子账户将可以独自创建自己的配置文件，创建后可编辑、删除、分享、转移所有权；
b.无【配置文件创建】权限将只能被动接收分享来的配置文件指纹，只可使用，不可以修改配置文件设置。
2、分享：
a.配置文件指纹创建者可以分享给任意的VMLogin用户；
b.主账户或子账户创建的配置文件都是相互独立的，不分享时互相看不到对方创建的配置文件，只有分享才可以看到。
c.子账户如有“编辑代理配置”权限，则可以修改主账户分享给自己的配置文件内代理信息。
d.如同一个配置文件需要在多台电脑打开，请将配置文件分享给子账户，子账户在其他电脑上登陆，保持一台电脑登陆一个VMLogin指纹浏览器帐号的原则使用。
e.如您在多台电脑上使用打开同一个配置文件，请确保VMLogin客户端版本号和谷歌内核版本号保持一致，注：内核只可以升级不可以降级。
注：配置文件所有者无法分享配给自己。配置文件指纹创建者可以分享给任意的VMLogin用户；如需批量分享，按住Shift或Ctrl键，同时鼠标左击，然后右键，点击分享配置文件即可批量分享配置文件。
3、转移所有权：
a.主账户：可以转移所有权给拥有【配置文件创建】权限的账户；
b.子账户：
有【配置文件创建】权限可转移给他所属的主账户及其他用户；
无【配置文件创建】权限将不可操作，也不可接收转移所有权；
c.配置文件所有权转移给其他用户后，自己将无法使用。
4、删除子帐户或配置文件：
a.主账户删除子账户，子账户名下的配置文件将一并删除，且都不可恢复；
b.删除子账户时请先将配置文件所有权转移到主账户再删除；
c.转移配置文件时请确保有打开同步功能，如未打开，请在配置文件中的其他设置中开启，开启同步后重新打开浏览器页面再关掉，以确保配置文件数据上传至服务器，同步功能打开后浏览器数据才会被同步到分享或转移的账户中。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ecbb67672170878f3db19464b6cb348/" rel="bookmark">
			nginx实现https与http共存方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		nginx实现https与http共存方案 前言nginx配置nginx安装对应模块配置文件修改server模块分别配置http和httpssteam模块中的配置完整配置文件 重启nginx并测试 总结 前言 在日常开发中，到正式上线的时候大部分需要使用https来保证链路传输的安全性，这块相信大家都了解了，但有些特殊场景下可能需要http和https共存，并且端口都是同一个端口，只是协议不同，那这块我们就借助nginx来配置了。
nginx配置 nginx安装对应模块 通过configure安装共存需要的模块stream、with-stream_ssl_preread_module、http_ssl_module。如果自身nginx配置了其他模块，记得把原来的模块的内容添加进去。 ./configure --with-stream --with-stream_ssl_preread_module --with-http_ssl_module 编译安装的模块，使用make命令,等待编译完成 make 编译完成后复制新的nginx文件替换到原来的nginx启动文件。记得先备份原来的nginx文件 mv /usr/local/nginx/sbin/nginx /usr/local/nginx/sbin/nginx.bak //备份原有文件 cp -r /usr/local/nginx-1.22.0/objs/nginx /usr/local/nginx/sbin/ //复制新的nginx // 到nginx的目录检验是否安装好 cd /usr/local/nginx/sbin/ ./nginx -V 检查版本信息以及安装的模块是否正确，版本信息和模块都没问题的话就ok了。
配置文件修改 server模块分别配置http和https 添加http的server监听 server { listen 8083; ##监听端口 server_name localhost; location { proxy_pass http://127.0.0.1:8001; ##应用服务地址，如tomcat对应地址 } } 添加https的server监听 #Https请求 server { listen 8082 ssl; #使用不同的端口监听 server_name localhost; ssl_certificate /usr/local/nginx/conf/cert/xxxx.pem; #证书放到 nginx的/conf/cert/文件夹内 ssl_certificate_key /usr/local/nginx/conf/cert/xxxx.key; #证书放到 nginx的/conf/cert/文件夹内 ssl_protocols TLSv1.2; ssl_ciphers ECDHE-RSA-AES256-SHA384:AES256-SHA256:RC4:HIGH:!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9ecbb67672170878f3db19464b6cb348/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d982757865ce857b2778ab12d14eb323/" rel="bookmark">
			MAC地址格式详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以太网编址 在数据链路层，数据帧通常依赖于MAC地址来进行数据交换，它如同公网IP地址一样要求具有全球唯一性，这样才可以识别每一台主机。那么MAC地址如何做到这点？它的格式又是什么？
MAC地址，英文全称Medium Access Control，直译为介质访问控制，它通常被固化在每个以太网网卡（NIC,Network Interface Card）。MAC（硬件）地址长48位（6字节），采用十六进制格式，下图说明了48位的MAC地址及其组成部分。
示例： 00-01-6C-06-A6-29 或 00:01:6C:06:A6:29
组织唯一标识符（OUI）由IEEE（电气和电子工程师协会）分配给厂商，它包含24位。厂商再用剩下的24位（EUI，扩展唯一标识符）为其生产的每个网卡分配一个全球唯一的全局管理地址，一般来说大厂商都会购买多个OUI。
I/G（Individual/Group）位，如果I/G=0，则是某台设备的MAC地址，即单播地址；如果I/G=1，则是多播地址（组播+广播=多播）。
G/L（Global/Local，也称为U/L位，其中U表示Universal）位，如果G/L=0，则是全局管理地址，由IEEE分配；如果G/L=1，则是本地管理地址，是网络管理员为了加强自己对网络管理而指定的地址。
对于I/G和G/L位的位置，目前有两种说法，或者说两种格式。
对于数据传输来说，数据是按每个字节中一位一位地传输的，一个字节传输完了才到下一个字节。
IEEE 802.3 ：以太网介质访问控制协议 （CSMA/CD）及物理层技术规范。
IEEE 802.4 ：令牌总线网（Token-Bus）的介质访问控制协议及物理层技术规范。
IEEE 802.5 ：令牌环网（Token-Ring)的介质访问控制协议及物理层技术规范。
IEEE 802.6 ：城域网介质访问控制协议DQDB （Distributed Queue Dual Bus 分布式队列双总线）及物理层技术规范。
第一种，每个字节的高位在前，低位在后，I/G位和G/L分别在字节中的最低位和次低位，最高位先发送，到了对端还是最高位
第二种，每个字节的低位在前，高位在后，I/G位和G/L分别在字节中的最低位和次低位，最低位先发送，到了对端还是最低位
两种看似不一样，但是结果还是一样的，如果还是弄不懂可以再草稿纸上画一画，不难理解。
因为以太网线路上按“Big Endian”字节序传送报文（也就是最高字节先传送，关于字节序请参考相关文档），而比特序是”Little Endian”（也就是最低位先传送）。
注意图上的第47bit，这一位表示MAC地址是全球唯一地址还是本地地址，0表示全球唯一地址，1表示本地唯一地址。这一位也叫G/L位。
对于网络设备上固化的MAC地址，因为它唯一标识这个设备，所以只能是单播地址，也就是MAC帧里面的Source地址第48位只能0。
我们常说有2的48次方个MAC地址可供网络设备使用，这些地址可以多到给地球上每一粒沙子分配一个地址，其实这个数量要打折扣的，因为MAC地址虽然有这么多，但真正用在网卡上并且全球唯一的只有2的46次方个：第48bit一定是0，第47bit一定是0。
这也就引出了一个有意思的现象：随便找一台PC，观察一下它的网卡地址，第1字节的十六进制数一般是4的倍数；查看一下IEEE分配的OUI(http://standards.ieee.org/develop/regauth/oui/oui.txt )，第1字节的十六进制数也一般是4的倍数（早期以太网没有本地地址的概念，所以分配的OUI里面G/L bit也可能是1），这种情况下就不是4的倍数了，但肯定是2的倍数，因为第48位只能是0。
关于组播地址，有这么个误解：MAC地址第1字节必须是0x01才表示组播地址，连TCP/IP详解上也这么说（见中文版12.4.2第一段）。IEEE 802.3里面已经明确说明了只要第48bit是1就表示组播地址，所以无论MAC地址第1字节是0x01、0xC1或者是0x33都表示这个MAC地址是组播地址（以0x33开头的表示IPV6对应的二层组播地址）。之所以有这样的误解，是因为到目前为止，大部分组播MAC地址的第1字节都是0x01。如：
01-80-C2-00-00-00(STP协议使用)
01-80-C2-00-00-01(MAC Control的PAUSE帧使用)
01-80-C2-00-00-02(Slow Protocol: 802.3ah OAM/ LACP 协议都用这个地址，这个地址很有故事，有多少软件处理这个地址会出问题啊！)
01-00-5E-xx-xx-xx(IP组播地址对应的二层组播地址)。
目标MAC是组播MAC地址的以太网帧，只有交换机才会接收，而普通终端设备不会接收。
完整的列表见http://standards.ieee.org/develop/regauth/grpmac/public.html
之所以大部分组播地址都以01-80-C2和01-00-5E开头，那是因为使用这些组播地址的协议都是带头大哥IEEE和IANA名下的，它们的OUI分别是00-80-C2和00-00-5E是，变成组播地址就是01-80-C2和01-00-5E了，当然，除了带头大哥霸占的这些组播地址，还有01-00-0C-CC-CC-CC这样的地址，这个地址是Cisco霸占的，Cisco的OUI是00-00-0C。
===========
主机网卡应该接收的数据帧：
目标MAC是自己的单播帧广播帧加入组播对应的组播帧 让网卡不检查包的接收方地址，不管是不是自己的包都统统接收下来，这种模式就叫做混杂模式。
linux系统中网卡驱动收到报文后会检查报文的目的mac地址，区分广播，组播，和单播。如果是单播报文，则比较报文的目的mac地址是否和本网卡的mac一样，如果不一样则设置该报文为PACKET_OTHERHOST。在ip_rcv函数中将PACKET_OTHERHOST类型的报文直接丢弃。所以说混杂模式下网卡收到不是自己(仅限于本网卡)mac的报文，只会在链路层处理，不会到网络层。详细分析可以参考文档：https://segmentfault.com/a/1190000021291692
ifconfig eth1 promisc ------ 开启混杂模式
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d982757865ce857b2778ab12d14eb323/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19ca2347bdf99bccb3f09879bc04a384/" rel="bookmark">
			DM 统计信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1 统计信息1.1 使用存储过程1.2 使用DBMS_STATS包1.3 统计信息使用约束 1 统计信息 统计信息描述数据是如何在数据库中存储的，是优化器的代价计算的依据，可以帮助优化器较精确地估算成本，对执行计划的选择起着至关重要的作用。
DM数据库没有自动收集统计信息功能，一般情况下使用手动执行存储过程和系统包中的方法来收集，不推荐系统稳定运行后再去更新统计信息。
DM数据库可通过执行系统存储过程收集统计信息，使用DBMS_STATS包（可兼容Oracle数据库）可收集和获取统计信息。
1.1 使用存储过程 使用存储过程可收集的统计信息包括：表统计信息、列统计信息、索引统计信息。
（1）表级基本信息收集，使用SP_TAB_STAT_INIT, 如：
SQL&gt;SP_TAB_STAT_INIT(‘SYSDBA’, ‘T1’);
（2）列级信息收集，使用SP_COL_STAT_INIT, 如：
SQL&gt;SP_COL_STAT_INIT(‘SYSDBA’, ‘T1’, ‘ID’);
//收集t1表id字段统计信息
SQL&gt;SP_TAB_COL_STAT_INIT (‘SYS’, ‘SYSOBJECTS’);
//收集SYS模式下SYSOBJECTS所有列统计信息
（3）索引信息收集，使用SP_INDEX_STAT_INIT, 如：
SQL&gt;SP_INDEX_STAT_INIT(‘SYSDBA’, ‘T1L02’);
//对表上所有索引生成统计信息
SQL&gt;SP_DB_STAT_INIT ();
SP_INDEX_STAT_INIT(‘SYSDBA’,‘INDEX_ID’);
stat 100 on index INDEX_ID;
//对库上所有模式下的所有用户表上的所有索引生成统计信息
（4）对某个SQL查询语句中涉及的所有表和过滤条件中的列(不包括大字段、ROWID)生成统计信息，如：
SQL&gt;SP_SQL_STAT_INIT(‘SELECT * FROM T1, T2’);
（5）查询表的统计信息：
begin
dbms_stats.TABLE_STATS_SHOW(‘SYSDBA’,‘T1’);
end;
/
表的统计信息，格式如下：
名称 说明
NUM_ROWS 表的总行数
LEAF_BLOCKS 总的页数
LEAF_USED_BLOCKS 已经使用的页数
（6）删除统计信息，如：
SQL&gt;SP_TAB_STAT_DEINIT(‘SYSDBA’, ‘T1’);//删除表的统计信息
（7）收集模式下对象的统计信息
使用DBMS_STATS 首先得调用一个系统存储过程来创建这个包：
收集SYSDBA模式下对象的统计信息。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/19ca2347bdf99bccb3f09879bc04a384/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70726657dadce48153669add6c2019be/" rel="bookmark">
			markdown语法学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录 文章目录 目录md文件基本语法1.标题创建2.创建段落3.粗文本4.块引用5.创建有序列表6.创建无序列表7.将单词表示为代码8.创建分割线9.创建链接10.URL 和 email 地址11.添加图像12.待补充 md文件基本语法 1.标题创建 使用（#+空格）创建一级标题 ，（##+空格） 代表二级标题（###+空格）代表三级级标题 2.创建段落 使用空白行将文本分割开即可，在一行末尾添加两个或多个空格 ，然后回车即可创建一个换行 3.粗文本 加粗文字前后加*
*像这样斜体显示文字前后加*
这样组合加粗和斜体加***
这样 4.块引用 在段落前添加 &gt; 引用内可以包含MarkDown格式的元素 块引用可以嵌套
嵌套时在段落前加 &gt;&gt;
5.创建有序列表 1.在列表项前添加数字并紧跟英文据点
2.数字不必按数学顺序
3.但列表应以数字1开始
6.创建无序列表 在列表项前添加 (*) (-) 或者 (+) 紧跟空格嵌套列表时 下一级元素需要缩进4个空格或一个tab 列表
* 再嵌套 等等。。。。 7.将单词表示为代码 使用反引号包裹单词表示为代码，例如print代码块引用时上下使用三个反引号 img = cv2.imread('path') cv2.imshow('img',img) cv2.waitKey(0) 8.创建分割线 在单独一行使用三个或多个（*）（-）不能包含其他内容 上面是分割线
9.创建链接 链接文本放在[]中括号中地址放在后面的（）中
这是一个CSDN链接 10.URL 和 email 地址 使用见括号&lt;&gt;可以把URL和email地址变成可点击的链接
https://www.csdn.net/ 11.添加图像 使用英文感叹号添加图像
12.待补充 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b84ae91fb3a6387e7072702f02b27f49/" rel="bookmark">
			《十三》CSS3 媒体查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		媒体查询：Media querys，针对不同大小的屏幕写不同的样式，让网页在不同大小的屏幕上都能正常显示。
媒体查询在 CSS2 的时候已经出现，CSS2 用 link 标签，而 CSS3 用 @meida 定义。两者用法类似，但是 CSS3 与 CSS2 相比会减小页面的请求。
// 屏幕设备，且屏幕宽度大于等于 375px //CSS2 &lt;link rel="stylesheet" media="screen and (min-width:375px)" href="style.css" /&gt; //CSS3 @media screen and (min-width:375px) { div{color:red;} } 基础语法： 媒体类型： all：默认值，可省略。用于所有设备。screen：用于电脑屏幕、平板电脑、手机屏幕等屏幕设备。print：用于打印机和打印预览等打印设备.speech：用于屏幕阅读器等发声设备，一般供残障人士使用。 媒体逻辑： and：与。使用 and 连接的查询条件全部为真时才生效。
,：或。使用 , 连接的查询条件中的任意一个为真时生效。
使用 and 连接的查询条件是一整个查询条件。
使用 , 连接的查询条件是分开的不同的查询条件。
// 屏幕设备，且屏幕宽度大于等于 750px；或者所有设备，且设备宽度小于等于 375px @media screen and (min-width: 750px), (max-width: 375px) { div{color:red;} } not：非。对当前的查询条件取反。
当 not 与 and 同时存在，not 对 and 所在的整个媒体查询生效。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b84ae91fb3a6387e7072702f02b27f49/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9301dd155fc7f523ac126575b14f88be/" rel="bookmark">
			35个MySQL常见面试题&#43;答案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天给大家总结了35 个 Mysql 常见的小问题
1.说一说三大范式
2.MyISAM 与 InnoDB 的区别是什么？
3.为什么推荐使用自增 id 作为主键？
4.一条查询语句是怎么执行的?
5.使用 Innodb 的情况下，一条更新语句是怎么执行的?
6.Innodb 事务为什么要两阶段提交?
7.什么是索引?
8.索引失效的场景有哪些?
9.为什么采用 B+ 树,而不是 B-树
10.WAl 是什么?有什么好处?
11.什么是回表?
12.什么是索引下推?
13.什么是覆盖索引?
14.什么是最左前缀原则?
15.普通索引和唯一索引该怎么选择?
16.什么是事务?其特性是什么?
17.事务的隔离级别?
18.binlog 是做什么的?
19.undolog 是做什么的?
20.relaylog 是做什么的?
21.redolog 是做什么的?
22.redolog 是怎么记录日志的?
23.redolog 和 binlog 的区别是什么?
24.说一说 mvcc 吧，有什么作用?
25.一条 Sql 语句查询一直慢会是什么原因?
26.一条 Sql 语句查询偶尔慢会是什么原因?
27.Mysql 主从之间是怎么同步数据的?
28.主从延迟要怎么解决?
29.删除表数据后表的大小却没有变动,这是为什么?
30.为什么 VarChar 建议不要超过255?
31.分布式式事务怎么实现?
32.Mysql 中有哪些锁?
33.为什么不要使用长事务?
34.buffer pool 是做什么的?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9301dd155fc7f523ac126575b14f88be/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a58a97e3b24bb931a549d5ff3d3ac7c7/" rel="bookmark">
			2. 在node中使用ts
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		默认情况下， Ts会做出以下几种假设：
1.建设当前的执行环境是dom.
2.如果代码中没有使用模块化语句（import、export), 便认为该代码是全局执行
3.编译目标代码是es3
有两种方式更改以上假设：
1.使用tsc命令行时候加选项参数
2.使用ts配置文件更改编译选项
Ts的配置文件
使用了配置文件后，使用tsc进行编译时，不能跟上文件名，如果跟上文件名， 会忽略配置文件。
@types/node
@types 是一个ts官方的类型库，其中包含了很多对js代码的类型描述。
Jquery: 用js写的， 没有类型检查
安装@types/jquery, 为jquery库添加类型定义
使用第三方库简化流程
ts-node: 将ts代码在内存中完成编译,同时完成运行
ts-node src/index.ts
编译完成后不会生成js文件
代码改动后还需要执行 ts-node命令
nodemon：用于监测文件的变化
nodemon --exec ts-node src/index.ts
可以将这个命令放到package.json中
此时nodemon会监测所有文件，我们希望只监测ts文件：
“nodemon -e ts --exec ts-node src/index.ts”
我们希望只监控src下的ts文件：
“nodemon --watch src -e ts --exec ts-node src/index.ts”
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8a8cb514938f18765c6a8c8dd1e4c70/" rel="bookmark">
			顺序表的实现及操作【C语言最详细版】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		⭐前言⭐ ※※※大家好！我是同学〖森〗，一名计算机爱好者，今天让我们进入学习模式。若有错误，请多多指教。更多有趣的代码请移步Gitee 👍 点赞 ⭐ 收藏 📝留言 都是我创作的最大的动力！
目录
⭐前言⭐
※※※大家好！我是同学〖森〗，一名计算机爱好者，今天让我们进入学习模式。若有错误，请多多指教。更多有趣的代码请移步Gitee
1.顺序表
2.实现顺序表的功能
3.准备工作
（1）创建一个XXX工程项目
（2）在XXX工程项目建XXX源程序文件（.cpp）和XXX头文件（.h）
（3）准备头文件
（4） 定义一些宏
（5）顺序表数据类型的定义。
（6）使用枚举来替换switch中的选项
4.功能实现
（1） 初始化线性表：构造一个空的顺序线性表
（2）销毁顺序表
（3）将顺序表重置为空表
（4）判断顺序表是否为空表
（5）返回顺序表中元素的个数
（6）在顺序表中第 i 个位置之前插入一个新元素 NewElem。
（7）用Elem返回顺序表中第i个数据元素的值
（8）返回顺序表中第一个与Elem满足关系，不存在返回0
（9）找CurElem的前驱元素
（10）找CurElem的后继元素
（11）删除第DelPos个元素，并用DelElement返回其值
（12）正向遍历顺序表和逆向变量顺序表
（13） 将线性表中第Pos个的元素值修改成参数Elem的值。
（14）将光标移动到（x,y）处
5.测试功能
6.运行结果演示： 1、初始化顺序表
2、销毁空间
3、清空列表
4、判断顺序表是否为空
5、返回顺序表中元素的个数
6、 在顺序表中第 i 个位置之前插入一个新元素 NewElem
12、正向遍历顺序表
11、删除第DelPos个元素，并用DelElement返回其值
7、用Elem返回顺序表中第i个数据元素的值
8、返回顺序表中第一个与Elem满足关系，不存在返回0
9、找CurElem 的前驱，结果由 PriorElem 输出
10、找 CurElem 的后继，结果由 NextElem 输出
13、逆向遍历顺序表
14、将线性表中第Pos个的元素值修改成参数Elem的值
7.注意事项
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f8a8cb514938f18765c6a8c8dd1e4c70/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ff7d34b48d27a53348f84916028b0b5/" rel="bookmark">
			网络：TCP的重传机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是重传机制 TCP实现可靠传输的方式之一，就是通过序列号和确认应答。
在TCP中，当发送端的数据到达接收端之后，接收端主机会返回一个确认应答消息，表示已经接收到消息
在网络复杂，并不一定能够上上图那样正常的数据传输，数据有可能在传输过程中丢失。所以TCP针对数据包丢失测情况，会用重传机制来解决
常见重传机制 有四种：
超时重传快速重传SACKD-SACK 超时重传 重传机制的其中一个方式，就是在发送数据时，设定一个定时器，当超过指定的时间RTO后，没有收到对方的ACK确认应答报文，就会重发该数据，也就是超时重传
什么时候会超时重传 TCP会在下面两种情况中发生超时重传：
发送的数据没能到达接收端，所以对方没有响应接收端接收到数据，但是ACK报文在返回的过程中丢失接收端拒绝或者丢弃数据 RTT和RTO RTO（Retransmission Timeout 超时重传时间）： 从上一次发送数据，因为长期没有收到ACK响应，到下一次重发之间的时间。就是重传时间通常每次重传RTO是前⼀次重传间隔的两倍，计量单位通常是RTT。例：1RTT，2RTT，4RTT，8RTT…。重传次数到达上限之后停⽌重传。 RTT（Round-Trip Time 往返时延）就是数据从网络一端传输到另一端所需的时间，也就是包的往返时间 大小不稳定。目的是接收方通过TCP头窗口字段告知发送方本方可以接收的最大数据量，用以解决发送速率过快导致接收放不能接收的问题。 假设在重传的情况下，超时时间 RTO 「较长或较短」时，会发生什么事情呢？
当超时时间 RTO 较大时，重发就慢，丢了老半天才重发，没有效率，性能差；当超时时间 RTO 较小时，会导致可能并没有丢就重发，于是重发的就快，会增加网络拥塞，导致更多的超时，更多的超时导致更多的重发。 精确的测量超时时间 RTO 的值是非常重要的，这可让我们的重传机制更高效。
根据上述的两种情况，我们可以得知，超时重传时间 RTO 的值应该略大于报文往返 RTT 的值。
至此，可能大家觉得超时重传时间 RTO 的值计算，也不是很复杂嘛。
好像就是在发送端发包时记下 t0 ，然后接收端再把这个 ack 回来时再记一个 t1，于是 RTT = t1 – t0。没那么简单，这只是一个采样，不能代表普遍情况。
实际上「报文往返 RTT 的值」是经常变化的，因为我们的网络也是时常变化的。也就因为「报文往返 RTT 的值」 是经常波动变化的，所以「超时重传时间 RTO 的值」应该是一个动态变化的值。
我们来看看 Linux 是如何计算 RTO 的呢？
估计往返时间，通常需要采样以下两个：
需要 TCP 通过采样 RTT 的时间，然后进行加权平均，算出一个平滑 RTT 的值，而且这个值还是要不断变化的，因为网络状况不断地变化。除了采样 RTT，还要采样 RTT 的波动范围，这样就避免如果 RTT 有一个大的波动的话，很难被发现的情况。 RFC6289 建议使用以下的公式计算 RTO：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8ff7d34b48d27a53348f84916028b0b5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/52740fc51fed407cb8b90972cfa3af2d/" rel="bookmark">
			【Spring Boot】DataSource数据源的自动配置解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、重点概念 1、什么是DataSource数据源
javax.sql.DataSource是由JDBC2.0 提供的接口，它负责建立与数据库的连接，当在应用程序中访问数据库时不必编写连接数据库的代码，直接引用DataSource获取数据库的连接对象即可。用于获取操作数据Connection对象
2、数据库连接池
当我们使用数据源建立多个数据库连接，这些数据库连接会保存在数据库连接池中，当需要访问数据库时，只需要从数据库连接池中获取空闲的数据库连接，当程序访问数据库结束时，数据库连接会放回数据库连接池中
二、导入依赖 首先我们需要导入JDBC相关场景
&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; 然后，我们还需要导入数据库的连接驱动
注意，我们要根据数据库的版本去导入对应版本的驱动
因为Spring Boot它有默认的版本仲裁，即使不声明version也会有默认版本
所以我们可以直接修改依赖引入的版本（maven的就近依赖原则）或者在properties属性中重新声明版本（maven的属性的就近优先原则，下面使用的就是这种方式）
&lt;properties&gt; &lt;mysql.version&gt;5.1.49&lt;/mysql.version&gt; &lt;/properties&gt; ... &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;${mysql.version}&lt;/version&gt; &lt;/dependency&gt; 三、分析自动配置 1、DataSourceAutoConfiguration类 从名字不难看出，这个类和数据源的自动配置有关
@AutoConfiguration( before = {SqlInitializationAutoConfiguration.class} ) @ConditionalOnClass({DataSource.class, EmbeddedDatabaseType.class}) @ConditionalOnMissingBean( type = {"io.r2dbc.spi.ConnectionFactory"} ) @EnableConfigurationProperties({DataSourceProperties.class}) @Import({DataSourcePoolMetadataProvidersConfiguration.class}) public class DataSourceAutoConfiguration { public DataSourceAutoConfiguration() { } ... 通过分析这个自动配置类，我们可以发现它绑定了一个DataSourceProperties.class配置类
@ConfigurationProperties( prefix = "spring.datasource" ) public class DataSourceProperties implements BeanClassLoaderAware, InitializingBean { private ClassLoader classLoader; private boolean generateUniqueName = true; private String name; private Class&lt;?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/52740fc51fed407cb8b90972cfa3af2d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b430aa2dd7fd4e879558e2784a0be3b0/" rel="bookmark">
			【MySQL 第19章_数据库备份与恢复】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第19章_数据库备份与恢复 1. 物理备份与逻辑备份2. mysqldump实现逻辑备份 2.1 备份一个数据库2.2 备份全部数据库2.3 备份部分数据库2.4 备份部分表2.5 备份单表的部分数据2.6 排除某些表的备份2.7 只备份结构或只备份数据2.8 备份中包含存储过程、函数、事件2.9 mysqldump常用选项 3. mysql命令恢复数据 3.1 单库备份中恢复单库3.2 全量备份恢复3.3 从全量备份中恢复单库3.4 从单库备份中恢复单表 4. 物理备份：直接复制整个数据库5.物理恢复：直接复制到数据库目录6. 表的导出与导入 6.1 表的导出6.2 表的导入 7. 数据库迁移 7.1 概述7.2 迁移方案 物理迁移逻辑迁移 7.3 迁移注意点 1. 相同版本的数据库之间迁移注意点2. 不同版本的数据库之间迁移注意点3. 不同数据库之间迁移注意点 7.4 迁移小结 8. 删库了不敢跑，能干点啥？ 8.1 delete：误删行8.2 truncate/drop ：误删库/表8.3 延迟复制备库8.4 预防误删库/表的方法8.5 rm：误删MySQL实例 9.附录：MySQL常用命令 9.1 mysql 1. 连接选项2. 执行选项 9.2 mysqladmin9.3 mysqlbinlog9.4 mysqldump 1. 连接选项2. 输出内容选项 9.5 mysqlimport/source9.6 mysqlshow 说明：本内容整理自尚硅谷B站MySQL视频&gt;&gt;尚硅谷B站MySQL视频
在任何数据库环境中，总会有不确定的意外情况发生，比如例外的停电、计算机系统中的各种软硬件故障、人为破坏、管理员误操作等是不可避免的，这些情况可能会导致数据的丢失、服务器瘫痪等严重的后果。存在多个服务器时，会出现主从服务器之间的数据同步问题。
为了有效防止数据丢失，并将损失降到最低，应定期对MySQL数据库服务器做备份。如果数据库中的数据丢失或者出现错误，可以使用备份的数据进行恢复。主从服务器之间的数据同步问题可以通过复制功能实现。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b430aa2dd7fd4e879558e2784a0be3b0/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/131/">«</a>
	<span class="pagination__item pagination__item--current">132/321</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/133/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>