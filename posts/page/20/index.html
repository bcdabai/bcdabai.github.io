<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7eaf10fbddaaff6557207e5bff917805/" rel="bookmark">
			springCloud使用apache的http类和RestTemplate以及Eureka
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用apache的： package com.csgholding.pvgpsp.eqp.util; import com.esotericsoftware.minlog.Log; import org.apache.commons.collections4.MapUtils; import org.apache.http.HttpEntity; import org.apache.http.client.config.RequestConfig; import org.apache.http.client.methods.CloseableHttpResponse; import org.apache.http.client.methods.HttpGet; import org.apache.http.client.utils.URIBuilder; import org.apache.http.impl.client.CloseableHttpClient; import org.apache.http.impl.client.HttpClients; import org.apache.http.util.EntityUtils; import org.springframework.http.HttpHeaders; import org.springframework.http.HttpStatus; import org.springframework.http.MediaType; import org.springframework.http.ResponseEntity; import org.springframework.http.client.SimpleClientHttpRequestFactory; import org.springframework.web.client.RestTemplate; import java.io.IOException; import java.net.URI; import java.net.URISyntaxException; import java.util.Map; /** * @Classname HttpClientUtil * @Date 2021/5/11 8:45 * @Created by jj.Zhou */ public class HttpClientUtil { //字符集 private static final String CHARSET = "UTF-8"; private static RequestConfig defaultRequestConfig = RequestConfig .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7eaf10fbddaaff6557207e5bff917805/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83d56e44b4b976da52b9c7009aef9c9e/" rel="bookmark">
			Mybatis配置动态数据源以及参数传递等
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Mybatis必知必会 一、Mybatis动态加载数据源 在配置数据源连接时,在企业的真实开发中数据源一般都会写在配置文件中，而不会直接写在mybatis的核心配置文件中
所以,Mybatis为了方便开发人员去动态的获取数据源连接制定了一些特定的标签用于加载这些数据源。
具体做法如下:
&lt;!--用于加载配置文件--&gt; &lt;properties resource="jdbc.properties"&gt;&lt;/properties&gt; 全部的配置文件如下:
&lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "https://mybatis.org/dtd/mybatis-3-config.dtd"&gt; &lt;configuration&gt; &lt;!--用于加载配置文件--&gt; &lt;properties resource="jdbc.properties"&gt;&lt;/properties&gt; &lt;environments default="development"&gt; &lt;environment id="development"&gt; &lt;transactionManager type="JDBC"/&gt; &lt;dataSource type="POOLED"&gt; &lt;!-- 这的键要和 配置文件中的键保持一致--&gt; &lt;property name="driver" value="${jdbc.driver}"/&gt; &lt;property name="url" value="${jdbc.url}"/&gt; &lt;property name="username" value="${jdbc.username}"/&gt; &lt;property name="password" value="${jdbc.password}"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;/configuration&gt; jdbc的配置文件
jdbc.driver=com.mysql.cj.jdbc.Driver jdbc.url = jdbc:mysql://localhost:3306/数据库名?serverTimezone=UTC&amp;rewriteBatchedStatements=true&amp;characterEncoding=utf-8 jdbc.username=用户名 jdbc.password=密码 二、Mybatis参数传递 在jdbc时，参数传递可以通过? 来生成动态的SQL语句，然后进行SQL的动态赋值。但在Mybatis中
我们需要学习特定的标签进行参数的传递以及属性的赋值。
第一种方式: #{参数名} 参数的取值 告诉 MyBatis 创建一个预处理语句（PreparedStatement）参数，在 JDBC 中，这样的一个参数在 SQL 中会由一个“?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/83d56e44b4b976da52b9c7009aef9c9e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4760f41422aada5e9e59e6a06435ff3/" rel="bookmark">
			从零学习Linux操作系统第十五部分 kicakstart安装系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、kicakstart对于企业的重要意义 在企业中安装多台操作系统时面临的问题
当安装Linux操作系统时，安装过程会需要回答很多关于设定的问题
这些问题必须手动选择，否则无法进行安装
当只安装1台Linux系统，手动选择设定工作量比较轻松
当安装多台Linux，这些设定需要重复多次，这些重复动作是效率底下的操作
如何解决以上问题？
用文件来记录所有安装过程中问题的答案，并让所有需要安装的主机自动读取
kickstart作用
以上解决方案中记录系统安装过程中所有问题答案的文件叫kickstart脚本
二、kicakstart文件的生成 进入/root/目录
复制anaconda-ks.cfg
cp anaconda-ks.cfg westos.cfg
然后对新文件westos.cfg进行编辑
第一步
第二步
第三步
第四步
第五步
第六步
第七步
第八步
第九步
第十步
最后 %end 结尾
三、搭建系统安装所需要的环境 安装httpd和dhcp服务
dnf install httpd dhcp-server -y
开启服务
systemctl enable --now httpd
关闭火墙
systemctl disable --now firewalld
建立一个新的目录
mkdir /var/www/html/westos
再将镜像文件挂载到里面
mount /iso/rhel-8.6-X86 64-dvd.iso /var/www/html/westos/
将kickstart的配置文件复制到/var/www/html/
cp westos.cgf /var/www/html/
更改权限
chmod 644 /var/www/html/westos.cfg
配置好dhcp服务
cat /etc/dhcp/dhcpd.conf
复制到配置文件
cp /usr/share/doc/dhcp-server/dhcpd.conf.example /etc/dhcp/dhcpd.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d4760f41422aada5e9e59e6a06435ff3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/386f7f06dbb77b0c9f0f296c1085151e/" rel="bookmark">
			Docker五部曲之四：Docker Compose
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言Compose应用程序模型Compose规范顶层属性servicenetworkvolumesconfigssecrets 环境变量.env文件environment属性主机shell中的环境变量 Profiles（剖面）启动剖面自动启动剖面和依赖项解析 多compose.yml文件共享与扩展构建规范构建属性 部署规范开发规范 Compose指令 前言 本文翻译自官方文档。
Compose应用程序模型 Compose是一个用于定义和运行多容器Docker应用程序的工具。使用Compose，您可以通过compose.yml文件来配置应用程序的服务，然后，使用一个命令，从配置中创建并启动所有服务。compose.yml文件的编写规范由Compose规范定义。Compose规范允许您定义与平台无关的基于容器的应用程序。这样的应用程序被设计为一组容器，这些容器必须与足够的共享资源和通信通道一起运行。
服务：应用程序的组件被定义为服务。服务是一个抽象概念，通过一次或多次运行相同的容器镜像和配置在平台上实现。网络：服务通过网络相互通信。在Compose规范中，网络是一个平台功能抽象，用于在连接在一起的服务中的容器之间建立IP路由卷：服务将持久数据存储和共享到卷中。规范将这种持久化数据描述为具有全局选项的高级文件系统挂载。实际的特定于平台的实现细节被分组到卷定义中，并且可能部分地在某些平台上实现。配置：有些服务需要依赖于运行时或平台的配置数据。为此，规范定义了一个专用的配置概念。从服务容器的角度来看，配置与卷类似，因为它们是挂载到容器中的文件。但实际的定义涉及不同的平台资源和服务，这些资源和服务是由这种类型抽象出来的。项目：项目是应用程序规范在平台上的单独部署。使用顶级名称属性设置的项目名称用于将资源分组在一起，并将它们与其他应用程序或具有不同参数的相同Compose指定应用程序的其他安装隔离开来。 Compose规范 顶层属性 顶级属性是由规范定义的，用于向后兼容。它只是提供信息。
service build：指定用于从源创建容器镜像的构建配置，请看下文构建规范。image：指定要从哪个镜像启动容器。 image: redis image: redis:5 image: redis@sha256:0ed5d5928d4737458944eb604cc8509e245c3e19d02ad83935398bc4b991aac7 image: library/redis image: docker.io/library/redis image: my_private.registry:5000/redis command：用于覆盖容器镜像声明的默认命令 command: bundle exec thin -p 3000 configs：见下文configscontainer_name：指定自定义容器名称的字符串，如果Compose文件指定了container_name，则Compose不会将服务扩展到一个容器之外。depends_on：表示服务之间的启动和关闭依赖关系。 services: web: build: . depends_on: - db - redis redis: image: redis db: image: postgres deploy：见下文部署规范develop：见下文开发规范entrypoint：声明了服务容器的默认入口点。这将覆盖服务的Dockerfile中的ENTRYPOINT指令。 entrypoint: /code/entrypoint.sh env_file：见下文环境变量environment：见下文环境变量extends：见下文多compose.yml文件共享与扩展ports：公开容器端口 ports: - "3000" - "3000-3005" - "8000:8000" - "9090-9091:8080-8081" - "49100:22" - "8000-9000:80" - "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/386f7f06dbb77b0c9f0f296c1085151e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f21228482eedcddc94a7771e87d345ca/" rel="bookmark">
			跨境电商账号频繁？你的IP可能“不干净”了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		疫情促进了跨境电商行业的加速发展，许多卖家也抓住了这波流量红利，跨境电商月入数万，数十万甚至数百万的造福神话也不断在上演，但由于国内外电商运营模式不同，多店运营、用户数据收集、刷单等行为都受到了国外平台的严格管控，与之而来的就是各种封号热潮，这也让跨境电商在一次次封禁当中出现“退烧”迹象。
22年以Tik Tok为首的视频平台逐渐开始推广国内的直播带货模式，各种商家利好政策以及用户推广活动让跨境电商迎来了“第二春”，但还是封号问题，各种国内推流直播间频繁受到平台的封禁和限流操作，进而致使直播间被迫中断，账号粉丝流失等一系列严重后果，这让“跨境人”的一切努力都付诸流水。
IP代理或为严重隐患
电商跨境和个人用户一样是无法直接访问相应平台的，这就需要将自己的身份伪装成“身在国外”，实际上在互联网当中，IP就作为网络公民访问网络的唯一身份凭证，目前的IP代理技术就是让用户借助第三方服务器来代替自己访问网络，进而实现身份的伪装，但由于目前国内IP代理业务混杂，国家进行了相应的管制，企业只能通过合规合法的IP代理商才能获取服务。
过了正常访问这一关，跨境电商在IP代理上仍旧困难重重：
1、由于IPV4下IP地址几乎用尽，代理商提供的都是循环使用的IP，这就导致某些IP在一些电商上做过“坏事”，进而被电商平台进行了封禁，当这个IP再次落到新用户手中并尝试注册平台时，自然就被限制了。
2、多数平台是禁止商家多账户运营的，而反制机制也是通过IP检测，部分代理IP池相对连续，关联性强，这会导致平台识别为违规行为，与之而来的就是平台封号等措施。
而这两大问题都可以归结为：你的IP不够“干净”
住宅IP已成主流
不够“干净”的主要原因，其一是企业为节约成本使用劣势IP代理，其提供的IP池由于使用者质量本身比较差，使用行为也得不到管控，IP池污染率就非常高，这样的IP代理已经存在于各大平台黑名单中，跨境电商更是不可能使用。
其二就是企业使用了机房IP，机房IP就是由机房大量服务器组成的IP池，由于机房IP分布不均匀，连续性强，很容易被电商平台识别为商用IP，进而限制企业的各种行为，但这并不是说机房IP对企业来说完全不可用，在企业基础业务上，机房IP价格就有很大优势。
与机房IP对应的，就是海外住宅IP，这些IP来自网络运营商提供给住户的真实IP，其真实性极强，使用这样的IP受到的待遇和外海用户基本一致，哪怕是直播这种对于网络和IP质量要求很高的企业行为，使用住宅IP也都能带来更好的使用体验，其次，由于真实性强，住宅IP还能满足电商运营进行网站商品和用户的数据抓取，而不被平台反制，以帮助企业更好地了解电商状况，合理布局海外业务。
平台与跨境商户之间仍需不断磨合
店铺被封－资金链断裂－供应链断裂，直接导致相关卖家与供货工厂以及物流服务商的合作受到影响，最终大卖家或许还能靠着此前的积累翻身，小卖家只能就此被淘汰。
企业除了需要快速适应海外电商规则，网络这个最基础最难搞的门槛也是踏入这场“风口”的必备技能，而平台与跨境商户之间仍需不断磨合
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e8617acaa63e4e767a26a484f0fb61e/" rel="bookmark">
			2024-01-05 C语言定义的函数名里面插入宏定义，对函数名进行封装，可以通过宏定义批量修改整个文件的函数名里面的内容
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、C语言定义的函数名里面插入宏定义，对函数名进行封装，可以通过宏定义批量修改整个文件的函数名里面的内容。使用下面的代码对函数进行封装，这样移植的时候可以根据包名和类名进行批量修改，不用一个函数一个函数的修改。。
#define PACKAGE_NAME com_xxx_xxx #define CLASS_NAME xxxx #define FUNCTION_STYLE_INNER(packagename, classname ,functionanme) Java_##packagename##_##classname##_##functionanme #define FUNCTION_STYLE(packagename, classname ,functionanme) FUNCTION_STYLE_INNER(packagename, classname ,functionanme) #define JNI_FUNCTION(functionanme) FUNCTION_STYLE(PACKAGE_NAME,CLASS_NAME,functionanme) 二、需要注意的知识点：
在C语言中，## 运算符在宏定义中用于连接两个令牌。然而，当使用宏参数与 ## 运算符一起使用时，并且这些参数本身是宏时，直接使用 ## 运算符将不会导致参数宏的展开。这是因为宏的展开顺序规则导致 ## 阻止了参数宏先于连接操作的展开。
为了解决这个问题，通常需要使用两层宏：一层用于参数宏的展开，另一层用于连接操作。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c0ffbaa94cbc7d52d438b61bfa79af1/" rel="bookmark">
			ES6的一些高级技巧
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言 ES6（ECMAScript 2015）引入了许多新的功能和语法，其中一些功能可能相对较冷门，但非常实用。本文将介绍一些这样的高级技巧，包括
Object.entries()
Object.fromEntries()
Symbol类型和Symbol属性
WeakMap和WeakSet
Promise.allSettled()
BigInt
Array.of
Array.from
.at和flat
1. Object.entries()和Object.fromEntries() Object.entries()方法返回一个给定对象自身可枚举属性的键值对数组。Object.fromEntries()方法将键值对列表转换为一个对象。 当使用Object.entries()时，可以传入一个对象作为参数。这个对象可以是任何具有可枚举属性的对象。例如：
const obj = { a: 1, b: 2, c: 3 }; const entries = Object.entries(obj); console.log(entries); // [["a", 1], ["b", 2], ["c", 3]] 在这个例子中，我们将一个包含三个属性的对象传递给Object.entries()方法，并将返回的结果存储在entries变量中。entries变量现在是一个包含键值对数组的数组。
同样地，当使用Object.fromEntries()时，可以传入一个键值对数组作为参数。这个数组中的每个元素都是一个包含键和值的数组。例如：
const entries = [["a", 1], ["b", 2], ["c", 3]]; const obj = Object.fromEntries(entries); console.log(obj); // { a: 1, b: 2, c: 3 } 在这个例子中，我们将一个包含三个键值对的数组传递给Object.fromEntries()方法，并将返回的结果存储在obj变量中。obj变量现在是一个由键值对组成的对象。
2. Symbol类型和Symbol属性 Symbol是一种新的原始数据类型，用于创建唯一的标识符。
Symbol属性是对象中使用Symbol作为键创建的属性。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2c0ffbaa94cbc7d52d438b61bfa79af1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7b3a70226c984f0431e40c78791e03f/" rel="bookmark">
			openssl3.2 - 官方demo学习 - mac - siphash.c
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 openssl3.2 - 官方demo学习 - mac - siphash.c概述笔记END openssl3.2 - 官方demo学习 - mac - siphash.c 概述 MAC算法为 SIPHASH, 设置参数(C-rounds, D-rounds, 也可以不设置, 有默认值)
用key初始化MAC算法, 算明文的MAC值
笔记 /*! \file siphash.c \note openssl3.2 - 官方demo学习 - mac - siphash.c MAC算法为 SIPHASH, 设置参数(C-rounds, D-rounds, 也可以不设置, 有默认值) 用key初始化MAC算法, 算明文的MAC值 */ /* * Copyright 2021-2023 The OpenSSL Project Authors. All Rights Reserved. * * Licensed under the Apache License 2.0 (the "License"). You may not use * this file except in compliance with the License.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c7b3a70226c984f0431e40c78791e03f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cbb7c34c44dbf4b52bc636bf3f786e59/" rel="bookmark">
			FFmpeg之AVFormat
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、概述二、解封装流程三、重要结构体3.1、AVFormatContext3.2、AVInputFormat3.3、AVOutputFormat3.4、AVStream 四、重要函数分析4.1、avformat_alloc_context4.2、avformat_open_input4.2.1、init_input4.2.2、av_probe_input_format2 4.3、avformat_find_stream_info4.4、av_read_frame4.4.1、read_frame_internal4.4.2、ff_read_packet4.4.3、parse_packet 4.5、avformat_seek_file4.6、av_seek_frame4.6.1、seek_frame_internal4.6.2、seek_frame_byte 4.7、avformat_close_input 五、实例 团队博客: 汽车电子社区
一、概述 avformat中实现了目前多媒体领域中的几乎所有封装格式，可以封装，可以解封装（也叫解复用），根据需求不同，所支持的也有所不同，ffmpeg能否支持一种封装格式的视频的封装与解封装，完全取决于这个库，例如mp4、flv、mkv等容器的封装与解封装；又或者RTMP、RTSP、TCP、UDP等协议的封装与解封装；关于封装与解封装的操作，对CPU的消耗不会特别严重，因为封装与解封装不涉及到复杂的计算，更多的是I/O，如果希望增加自己定制的封装格式的话，需要在libavformat中增加自己的对应的format模块。通过代码的文件结构可以看得出来。
二、解封装流程 1、avformat_alloc_context()：负责申请一个AVFormatContext结构的内存,并进行简单初始化。
2、avformat_open_input()：打开输入音/视频文件。
3、avformat_find_stream_info()：获取音视频文件信息。
4、av_read_frame()：读取音视频包。
5、avformat_seek_file()：定位文件。
6、av_seek_frame()：定位文件。
7、avformat_free_context()：释放该结构里的所有东西以及该结构本身。
8、avformat_close_input()：关闭解复用器。关闭后就不再需要使用avformat_free_context 进行释放。
三、重要结构体 3.1、AVFormatContext AVFormatContext是FFmpeg中一个非常重要的结构体，它包含了一个完整的媒体文件或媒体流的所有信息。在FFmpeg中，每一个AVFormatContext结构体都对应着一个媒体文件或媒体流。当我们使用FFmpe对媒体文件或者媒体流的解码、编码或者转换时，都是基于AVFormatContext结构体进行操作的。
AVFormatContext结构体包含的信息很多，其中最重要的时AVInputFormat和AVOutputFormat，它们分表代表输入和输出的格式，包含了所有支持的编解码器、封装格式、容器格式等信息。在使用FFmpeg进行媒体文件或者媒体流的解码、编码或者转换时，我们需要根据不同的输入和输出格式来选择合适的VInputFormat和AVOutputFormat。
除了AVInputFormat和AVOutputFormat以外，AVFormatContext还包含了一些其它的信息，比如AVStream，它表示一个媒体流的所有信息，包括媒体流的类型、编码方式、采样率、帧率等；AVCodecContext表示一个编解码器的所有信息，包括编解码器的类型、编解码方式、采样率、帧率等等；AVDictionary它是一个字典类型的结构体，用于存储一些额外的元数据信息，比如媒体文件的标题、作者、描述等等。
typedef struct AVFormatContext { /** * A class for logging and @ref avoptions. Set by avformat_alloc_context(). * Exports (de)muxer private options if they exist. */ const AVClass *av_class; /** * The input container format. * * Demuxing only, set by avformat_open_input(). */ const struct AVInputFormat *iformat; /** * The output container format.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cbb7c34c44dbf4b52bc636bf3f786e59/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78391a8941bca3af83cb6f111b166e27/" rel="bookmark">
			PHY驱动调试之 --- MDIO/MDC接口22号和45号条款(一)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		（转载）原文链接：https://blog.csdn.net/u014044624/article/details/123303234
最近在调试一款Phy的驱动，从没有任何头绪到略有了解经历了太多的痛苦，于是决定写这个系列篇记录一下。特别感谢无数优秀的博主无私奉献很多优秀的博文给予了我很大的帮助。在这个系列篇中，我也会转载部分优秀的博文(会附上链接)，以及增添自己的理解，如果部分内容有侵权的地方，麻烦联系我。 概述 管理MII接口的MDIO接口是一个双线的串行接口，用来对PHY芯片等物理层信息进行操作管理。
MDIO的历史 MDIO是Management Data Input/Output 的缩写，有两根线，分别为双向的MDIO和单向的MDC，用于以太网设备中上层对物理层的管理。之所以能够管理这些PHY芯片，是因为能够对PHY芯片的各类寄存器进行访问和修改。
MDIO接口最初是由IEEE RFC802.3中的22号条款定义的，在最初的定义中，一个单独的MDIO接口可以访问32个不同的PHY设备中的32个寄存器，这些寄存器提供状态和控制信息，例如：连接状态、传输速度能力、当前选择的传速、低压消耗时的下电情况、全双工还是半双工、自动协商、错误提示以及反馈信息等等。
为了满足10G以太网设备的普及发展，在IEEE 802.3ae 的45号条款中为MDIO接口提供了额外的规范：
能够通过32个端口访问32个不同设备的65536个寄存器；为访问10G以太网提供额外的OP码和ST码，从而可以直接访问寄存器地址；端到端的报错信号；环回模式控制；低压电气标准。 操作原理 MDIO总线有两个信号：管理数据时钟（MDC）和管理数据输入/输出（MDIO）。
MDIO接口中有特定的术语定义总线上的各种设备。驱动MDIO总线的设备被定义为站管理实体（STA）。而被MDC管理的目标设备称为可被MDIO管理的设备（MMD）。
STA初始化MDIO所有的通信，同时负责驱动时钟MDC。MDC的频率可以高达2.5 MHz。
22号条款 22号条款的MDIO通信的帧格式定义如下：
45号条款 为了弥补22号的条款中定义的缺陷，45号条款中增添了对低压设备的支持，最低可到1.2V，同时扩充了帧格式，能够访问更多的设备和寄存器。
45号MDIO通信帧格式如下：
第45号条款的主要变化是如何访问寄存器。在第22中，一个单独的帧指定要读或写的地址和数据，同时完成了这些工作。45号中改变这种范式，第一个地址帧发送到指定的MMD和寄存器，然后发送第二帧来执行读或写。
添加这个依次循环访问的好处是45条款是向后兼容22条款的，允许设备的互操作。其次，通过创建一个框架的登记地址，地址空间从5位增加到16位，这使得STA访问65536个不同的寄存器。
为了做到这一点，在数据帧的组成部分进行了一些变化。定义了新的ST代码（00），用于标识第45号条款的数据帧。运算码扩展到指定地址帧，写帧，读帧，或读和读后增量地址帧。由于寄存器地址不再需要，这个字段被指定目标设备类型的内容代替。扩展后还允许STA接入除了PHY以外的其他设备。
转载博文地址： 了解与MDIO/MDC接口相关的22号、45号条款
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5cdb65779814cc3a8db4fd06d692bc81/" rel="bookmark">
			MySQL 删除ibdata1时怎么恢复（接上篇）实操
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		具体实操篇
整体说通俗易懂点就好比：是一个人，被火或者其他烧伤破坏了，躯壳坏了，然后重修找一个躯壳（新建一个数据库），然后依照前面的躯壳画像（上面得到的sql），在造一个躯壳出来，然后在把内在的骨骼血肉那些（以前的数据）给安在新的躯壳上，最后整个完整的人就号了（数据就恢复了）。上述就需要.frm(躯壳)，ibd(骨骼血肉)
只是删除ibdta1文件，在确保.frm及.ibd文件在的情况下 恢复数据：
通过mysqlfrm来进行恢复（如果你能明确的知道表名甚至是表结构、数据类型的情况下，上篇文章即可解决，此篇主要是获取表结构），直接就不介绍.frm和.ibd文件了。
1.mysqlfrm
mysqlfrm是一个恢复性质的工具，可以用来读取.frm文件并从该文件中找到表定义，生成ddl语句，生成的ddl语句多用于在另一台服务器上创建表或进行诊断等。但有些信息不存在于.frm文件中，这些信息将会被忽略，如自增长序列。
安装：官方下载链接: https://cdn.mysql.com/archives/mysql-utilities/mysql-utilities-1.6.5.tar.gz
//注意是在linux环境下 //安装目录 自己创建 cd /mysqlfrm/ //解压文件 tar -xf mysql-utilities-1.6.5.tar.gz ls //进入解压好的文件夹 cd mysql-utilities-1.6.5/ //build构建 python ./setup.py build //install安装 python ./setup.py install //安装成功查看命令 mysqlfrm --version buildj截图
install截图
成功及版本截图
2.简单说下mysqlfrm模式，其他命令可去官网或者help 查看
模式介绍
–basedir：需指定服务器的基本目录，相当于再生一个数据库实例，还需指定prot，user及.frm文件位置等信息，指定的prot不能与在运行的数据库冲突，可在原数据库无法打开情况下使用，在读取.frm文件后，再生的实例将被关闭，所有的临时文件将被删除。
例：mysqlfrm --basedir=/mysql/mysqld/ --port=3333 --user=mysql /mysql/data/test/tables.frm --show-stats
–server：需指定数据库的连接字符串，需在原数据库可以打开的情况下使用，指定数据库用户名，密码，端口号及.frm文件位置等信息。
例：mysqlfrm --server=root:Root#123@localhost:3306 /mysql/data/test/tables.frm --port=3310 --user=mysql
注意：如数据库还可以正常连接，推荐使用–server模式
3.操作
首先来看下在没恢复前，所有库所有表都是没有空的，但是数据库是可以连接的。
运行mysqlfrm 命令找到以前表结构
mysqlfrm --server=root:Root#123@localhost:3306 /mysql/data/test/tables.frm --port=3310 --user=mysql //参数说明以及注意事项 root:Root#123@localhost:3306 =&gt; 账号：密码@本地(或者指定ip):端口 /mysql/data/test/tables.frm =&gt; 需要恢复的.frm文件 --port=3310 =&gt; 这个3310 端口一定不要和前面那个端口一样，前者是本生数据库端口，后者是mysqlfrm映射的端口 得到最关键的表结构以及类型，如上图
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5cdb65779814cc3a8db4fd06d692bc81/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0171aa73a0fd4e2effb50cce6379bac/" rel="bookmark">
			开源ERP系统Odoo安装部署并结合内网穿透实现公网访问本地系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言1. 下载安装Odoo：2. 实现公网访问Odoo本地系统：3. 固定域名访问Odoo本地系统 前言 Odoo是全球流行的开源企业管理套件，是一个一站式全功能ERP及电商平台。
开源性质：Odoo是一个开源的ERP软件，这意味着企业可以自由选择部署方式（如云端或本地服务器），并根据自身需求进行定制开发。这为企业提供了更大的灵活性和控制权。
​ 其功能涵盖了客户管理系统CRM、生产管理系统ERP、销售、采购、仓储管理系统WMS、MRP生产制造、内部即时通讯IM、条码追溯管理、质量管理系统QMS、HR全功能、财务管理、项目管理、制造执行系统MES、产品生命周期PLM、VOIP、电子商务E-Commerce、POS收银等一系列完善的企业信息化需求。
​ Odoo包含一站式的企业所需功能。
​ 销售管理：订单处理、报价、客户关系管理等。
​ 采购管理：供应商信息、采购订单跟踪等。
​ 库存管理：产品分类、库存控制及调拨等。
​ 生产制造：生产计划、工艺路线及成本分析等。
​ 财务会计：财务报表生成、税收处理及预算控制等。
​ Odoo有两个版本 - 企业版和社区版。两个版本都是开源的，企业版其实是在社区版上层增加了更多应用模块，两者核心是一致的,我们今天来使用免费的社区版来进行内网穿透，实现远程访问本地部署的odoo企业管理系统。
​ 当内网穿透软件cpolar映射生效后，在任意上网地方，都可以通过外网域名进行访问。让外网访问内网，主要原理方案是将内网地址变成外网地址，在目标内网操作设置添加内网IP端口映射成域名。在让外网访问前，先明确自己本地内网的具体内网地址端口协议信息，并确保在内网能够正常访问。
​ 本地搭建服务器，跨网互通互连，是网络应用场景常见需求。通过cpolar内网穿透软件，我们可以轻松实现将内网服务让外网远程访问。内网穿透的应用场景十分广泛，比如外网远程桌面连接内网计算机、nas的远程访问、个人博客的搭建、FTP文件共享、数据库跨网连接等等。
1. 下载安装Odoo： 官方首页：
odoo
安装包地址：
Index of /15.0/nightly/ (odoo.com)
本教程使用windows版本部署安装，作为演示：
点击链接，下载安装包，开始安装：
一路默认设置即可
这里是数据库的端口，用户名等信息，需要截图保存。
安装完毕后，点 finish，就会自动弹出localhost:8069 的本地页面：
点击创建数据库后，需要加载一会儿，请耐心等待
注意，我的odoo默认打开端口为8069，我们之后会内网穿透这个端口，实现公网访问本地部署的ERP系统。
进入应用选择页面：
能够正常打开进入crm系统：
具体如何使用各个功能详见Odoo官网——文档手册，本教程主要解决如何在外地公网访问这套强大的企业管理系统。
2. 实现公网访问Odoo本地系统： 首先，我们需要安装内网穿透软件cpolar
安装完毕后，打开[仪表盘 - Cpolar](http://localhost:9200/#/tunnels/list)
隧道名称：可自定义，注意不要重复
协议：http
本地地址：8069 (odoo的 默认端口)
域名类型：选择随机域名（免费）
地区：Auto
复制这个公网地址：
成功登陆：
这样我们实现了使用公网访问本地部署的开源ERP，但是免费版cpolar生成的是随机域名（24小时变化），接下来我们使用付费版将域名固定：
3. 固定域名访问Odoo本地系统 上面使用Cpolar建立的临时http数据隧道，连接上了Odoo。不过，此时还是随机临时http隧道，每隔24小时端口号就会发生变化。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d0171aa73a0fd4e2effb50cce6379bac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c702479e3fad04918f46b1734b677a3f/" rel="bookmark">
			openssl3.2 - 官方demo学习 - mac - poly1305.c
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 openssl3.2 - 官方demo学习 - mac - poly1305.c概述笔记END openssl3.2 - 官方demo学习 - mac - poly1305.c 概述 MAC算法为Poly1305,
加密算法为AES-128-ECB, 用key初始化加密算法
加密算法进行padding填充
对加密算法的key加密, 放入MAC_key后16字节, 将MAC_key的前16字节清空, 作为要用的MAC_key
拿MAC_key来初始化MAC上下文
对明文进行MAC操作.
官方建议:
Poly1305不能单独使用, 必须和其他加密算法一起对输入(MAC_key)进行处理
绝对禁止将nonce(MAC_key)直接传给Poly1305
不同会话的nonce(MAC_key)禁止重用(相同).
在实际应用绝对禁止将nonce(MAC_key)硬编码
看来nonce对于Poly1305应用的安全性影响很大(知道了MAC_key, 就可以伪造MAC值)
笔记 /*! \file poly1305.c \note openssl3.2 - 官方demo学习 - mac - poly1305.c MAC算法为Poly1305, 加密算法为AES-128-ECB, 用key初始化加密算法 加密算法进行padding填充 对加密算法的key加密, 放入MAC_key后16字节, 将MAC_key的前16字节清空, 作为要用的MAC_key 拿MAC_key来初始化MAC上下文 对明文进行MAC操作. 官方建议: Poly1305不能单独使用, 必须和其他加密算法一起对输入(MAC_key)进行处理 绝对禁止将nonce(MAC_key)直接传给Poly1305 不同会话的nonce(MAC_key)禁止重用(相同). 在实际应用绝对禁止将nonce(MAC_key)硬编码 看来nonce对于Poly1305应用的安全性影响很大(知道了MAC_key, 就可以伪造MAC值) */ /* * Copyright 2021-2023 The OpenSSL Project Authors.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c702479e3fad04918f46b1734b677a3f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb6d210b330c687dc46208be446f6dfd/" rel="bookmark">
			【FPGA &amp; Modsim】数字频率计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		module flag(clk,rst_n,cnt);
input clk;
input rst_n;
output [2:0]cnt ;
reg[31:0]count ;
reg [2:0]cnt;
always@(posedge clk or negedge rst_n)
begin
if(~rst_n)begin
count&lt;=0 ;
cnt&lt;=3'd0 ;end
else if (count&gt;= 32'd24 999) begin
cnt&lt;=cnt+1'b1 ;count&lt;=32'd0 ;
end
else if (cnt&gt;=3'd6) begin
cnt&lt;=0;end
else
count&lt;=count+1'b1 ;
end
endmodule
'timescale 1 ns/ 1ps
/
module seg (
clk, rst_ n,data,dig,led
);
input clk;
input rst_n;
input [23:0] data;
output [5:0] dig; //六位控制六个数码管
output [7:0] led;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fb6d210b330c687dc46208be446f6dfd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6bf77117240b600c7cd25c619e2d96d/" rel="bookmark">
			LLM之幻觉（二）：大语言模型LLM幻觉缓减技术综述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		LLM幻觉缓减技术分为两大主流，梯度方法和非梯度方法。梯度方法是指对基本LLM进行微调；而非梯度方法主要是在推理时使用Prompt工程技术。LLM幻觉缓减技术，如下图所示：
LLM幻觉缓减技术值得注意的是：
检索增强生成（RAG）知识检索（https://arxiv.org/abs/2307.03987）CoNLI（https://arxiv.org/abs/2310.03951）CoVe（https://cobusgreyling.medium.com/chain-of-verification-reduces-hallucination-in-llms-20af5ea67672） 与专注于有限任务的传统人工智能系统不同，LLM在训练过程中使用了大量的在线文本数据。当大模型语言生成功能应用在要求严格的应用程序时，LLM幻觉就变得非常令人担忧，例如：
总结医疗记录；
客户支持对话;
财务分析报告，并提供错误的法律建议。
一、幻觉缓解分类法 这项研究对LLM幻觉缓解技术进行了总结，分类为：梯度方法和非梯度方法。
梯度方法包括复杂和不透明的解码策略、知识图谱、微调策略等。
非梯度方法包括RAG、自我优化和Prompt微调。
值得注意的是，RAG方法分为四个部分；
生成之前；生成期间；生成后；端到端 Prompt工程缓解幻觉的原理在于定义：
特殊上下文&amp;；预期输出 二、最佳预防幻觉 预防幻觉的最佳方法不是单一的方法，需要综合多种方法。
缓减幻觉需要考虑以下因素：
在多大程度上依赖标签数据？
引入无监督或弱监督学习技术以提高可扩展性和灵活性的可能性是什么？
考虑梯度和非梯度方法，以产生连贯和上下文相关的信息。
收集到的缓解幻觉的工作揭示了一系列不同的策略，每种策略都有助于解决LLM中幻觉的细微差别。
通过反馈和推理的自我完善会产生有影响力的策略。
结构化比较推理引入了一种结构化的文本偏好预测方法，增强了连贯性，减少了幻觉。
监督微调可以通过知识注入和师生方法进行探索。
特定领域的知识被注入到较弱的LLM和使用反事实数据集来提高真实性的方法中。
参考文献： [1] https://cobusgreyling.medium.com/large-language-model-hallucination-mitigation-techniques-a75b6f873318
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ace1738c41f98b71f35216ab9c74799/" rel="bookmark">
			uniapp使用camera完成指定区域大小扫描拍照功能--自定义拍照区域，相册选择剪裁 打开闪光灯
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.代码可以直接用，剪裁功能使用uniapp的插件图片裁剪插件 - DCloud 插件市场 &lt;template&gt; &lt;view&gt; &lt;camera class="camera-box" style="position: relative;" resolution="high" @initdone="initdone" :flash='flash' :style='{width:windowWidth+"px",height:windowHeight+"px"}'&gt; &lt;cover-view class='camerabgImage'&gt; &lt;cover-view class="active"&gt; &lt;cover-image class="active-image" src="https://oss.nodekoa.com/blog/2020/12/0716073342969601272.png"&gt;&lt;/cover-image&gt; &lt;cover-view class="text"&gt;将OE码放入框内&lt;/cover-view&gt; &lt;/cover-view&gt; &lt;cover-view @click="openlamp" style="display: flex;flex-direction: column;justify-content: center;align-items: center;color: #fff;margin-top: 130%;"&gt; &lt;cover-image class="img" src="../../static/off.png" v-if="flash=='off'"&gt;&lt;/cover-image&gt; &lt;cover-image class="img" src="../../static/open.png" v-else&gt;&lt;/cover-image&gt; &lt;!-- &lt;cover-view class="font" style="font-size: 26rpx;margin-top: 20rpx;"&gt;打开闪光灯&lt;/cover-view&gt; --&gt; &lt;/cover-view&gt; &lt;cover-view style="position: absolute;bottom: 0;left: 0;width: 100%;height: 300rpx;display: flex;z-index:999;"&gt; &lt;cover-view class="icon_flex" @click="takealbum"&gt; &lt;cover-image class="img" src="../../static/photo.png"&gt;&lt;/cover-image&gt; &lt;cover-view class="font"&gt; 相册 &lt;/cover-view&gt; &lt;/cover-view&gt; &lt;cover-view class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1ace1738c41f98b71f35216ab9c74799/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a411d78712ed5769d19b9352ebfc0c5/" rel="bookmark">
			AIGC如何搞副业专栏更新了！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、AI 数字人赚钱方法二、AI 写作赚钱方法三、AI 绘画赚钱方法四、AI 工具赚钱方法总结 前言 在这个数字化时代，越来越多的人开始尝试副业来增加收入。而其中，AI技术的应用也为人们提供了新的赚钱方法。AIGC（AI赚钱专栏）便是一个专门介绍AI赚钱方法的专栏。
首先，AIGC专栏提供了一系列关于AI数字人赚钱方法的分享。这些方法包括思维书单号、儿童英语学习、工具库账号引流、携程笔记、国学小和尚、名人对谈、明星说外语、祝贺或道歉视频、视频翻译、数字人定制服务、情感咨询、法律咨询、电影解说、冷知识讲解、复活逝去的亲人以及本地生活服务等。不同的赚钱方法适合不同的人群。
一、AI 数字人赚钱方法 AI 数字人 | 思维书单号
AI 数字人 | 儿童英语学习
AI 数字人 | 工具库账号引流
AI 数字人 | 携程笔记
AI 数字人 | 国学小和尚
AI 数字人 | 名人对谈
AI 数字人 | 明星说外语
AI 数字人 | 祝贺 or 道歉视频
AI 数字人 | 视频翻译
AI 数字人 | 数字人定制服务
AI数字人 | 情感咨询
AI数字人 | 法律咨询
AI数字人 | 电影解说
AI数字人 | 冷知识讲解
AI数字人 | 复活逝去的亲人
AI数字人 | 本地生活服务
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3a411d78712ed5769d19b9352ebfc0c5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b5eb833b7c548b6b36bb001d2906546/" rel="bookmark">
			Python新手太需要了，这5个做题练习网站爱了！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言1. LearnPython2. Python练习册3. PythonPractice4. 500 line or less5. PYnative 一、Python入门二、Python爬虫三、数据分析四、数据库与ETL数仓五、机器学习六、Python高级进阶资料领取 前言 学习编程语言，练习必不可少，在练习和做题的过程中能够查漏补缺，清楚自己在理论学习过程中的不足和薄弱点，加深对于Python的理解和认识。
今天就着重的给大家推荐一些适合「新手」练习的Python做题网站。
请注意，这里强调的是「新手」，所以，上来就推leetcode、牛客、codewar的同学就省省吧，别把新手引导入坑了。
上述这些网站主要面向的是求职面试刷题使用，更加偏重算法与数据结构，使用这些网站的前提是你已经非常熟练一门编程语言，能够轻松通过编程语言实现自己的算法和过程，压根不适合新手练习Python！！！
下面，就来给大家推荐5个真正适合Python新手练习做题的网站。
1. LearnPython LearnPython是DataCamp基于经典Python入门教程推出的一款免费在校学习和练习Python的网站。
它具有2方面的特点：
理论与实践结合交互式编码挑战 首先从知识体系方面，它覆盖基础（循环、条件、函数、列表、字典、类等等）、数据科学（Numpy、Pandas）、进阶（生成器、匿名函数、异常等）3大模块构成。
在每个模块内它会将理论和练习有机的结合到一起，每讲解一一部分内容，会提供一些练习题，同时还会提供一个交互式的编码框，在这里可以直接编码、执行、获取结果，达到及时练习的效果。
2. Python练习册 Python练习册是一个Github上免费开源的项目，目前已经12.6K+颗Star，受欢迎程度可见一斑。
它每天提供一个小程序，它提供的练习题都是围绕加深Python认识和理解展开，例如，
使用 Python 如何生成 200 个激活码？任一个英文的纯文本文件，统计其中的单词出现的个数。… 这些都是Python中非常基础的操作，可能通过十几行甚至几行代码就可以实现。
但是，不要小看这些练习题，这些练习的都是日常工作中经常会用到的用法和操作。
3. PythonPractice PythonPractice是由DATAQUEST汇总整理的74个有助于提升Python水平的问题。
这74个问题可以说是覆盖了Python应用过程中高频用到的场景和用法，例如，正则表达式、日期和时间、面向对象、字典、NumPy、Matplotlib绘图等等。
在每个问题下面，它会先简单介绍一下理论知识，然后抛出一些问题，例如：
如何使用线图可视化时间序列数据？什么是相关性以及如何使用散点图将它们可视化？如何使用条形图和直方图可视化频率分布？如何使用 pandas 库加快我们的探索性数据可视化工作流程？如何使用 Seaborn 的关系图可视化多个变量？ 然后，它还会提供一个在线的编辑界面，这样你就不需要再费劲去配置开发环境，也不用把时间和精力浪费在琢磨开发环境上。可以直接在线编程实现，执行验证结果。
4. 500 line or less 顾名思义，500行以内完成一项练习，是一个非常经典的Python练习平台。
只不过，它面向的是更加偏向实践和高阶的练习。
它会涉及到一些项目端到端的全部环节，包括，模型设计、开发、测试等不同环节。
如果对Python已经有一定熟练程度，这个资源可以进一步提升对Python应用的认识高度。
5. PYnative PYnative是一款面向Python 开发人员的免费编码练习平台，练习涵盖 Python 基础知识、数据结构和数据分析。 截至目前，该页面包含 18 个模块的练习。
这些 Python 练习包括什么？
每个练习都包含需要练习和解决的特定 Python 主题问题，这些免费练习以 Python 作业的形式提供，解决不同程序和挑战的练习。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b5eb833b7c548b6b36bb001d2906546/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08f63b4ecc7cab2f33ade0b682712514/" rel="bookmark">
			双y轴折柱图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		设置双y轴
yAxis: [ { type: "value", show: true, name: "单位：件", axisTick: { show: false, //刻度线 }, axisLine: { show: false, //隐藏y轴 }, }, { type: "value", name: "单位：%", min: -100, //设置右侧y轴显示数据，最大值和最小值 max: 100, splitNumber: 10, axisTick: { show: false, //刻度线 }, axisLine: { show: false, //隐藏y轴 }, splitLine: { show: false, //隐藏y轴横线 }, }, ], 指定使用左边右边Y轴数据，这里折线使用右边y轴
series: [ { name: "本期", type: "bar", barWidth: 14, emphasis: { focus: "series", }, data: [220, 182, 191, 234, 290, 220, 182, 191, 234, 290], }, { name: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/08f63b4ecc7cab2f33ade0b682712514/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fdd276c213ebd1ab6d12619a5223304e/" rel="bookmark">
			mpc_local_planner详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		控制器配置 Controller::configure() { //创建机器模型 _dynamics = std::make_shared&lt;UnicycleModel&gt;(); //离散网络，比如多重打靶法。参考点，输入，状态，等变量也会存放在grid里面，会实时更新。而且grid也继承了顶点传入到超图问题构建中 _grid = configureGrid(nh); //求解器 _solver = configureSolver(nh); //最优化问题构建, _dynamics，_grid，_solver这三个指针也会传入到最优化问题类里 _structured_ocp = configureOcp(nh, obstacles, robot_model, via_points); } 求解器配置 configureSolver() { //SolverIpopt这个类里面会新建2个结构: //_ipopt_nlp = new IpoptWrapper(this); //_ipopt_app = IpoptApplicationFactory(); //IpoptWrapper类是Ipopt的结构壳子，在nlp_solver_ipopt_wrapper.cpp中，里面主要是求解器的接口 //这个类只是壳子，具体的问题实现在optimaization里面的问题类里，在configureOcp()里面，就创建了一个HyperGraphOptimizationProblemEdgeBased超图最优问题 //get_nlp_info() 变量和约束信息 //eval_f() 目标函数 //eval_jac_g() 雅可比矩阵 //eval_h() 海森矩阵 //IpoptApplicationFactory是ipopt的标准用法，创建一个IPOPT应用程序： //ApplicationReturnStatus status; //status = _ipopt_app-&gt;Initialize(); // 设置优化参数 //_ipopt_app-&gt;Options()-&gt;SetNumericValue("tol", 1e-9); //最小迭阈值 //_ipopt_app-&gt;Options()-&gt;SetStringValue("mu_strategy", "adaptive"); //_ipopt_app-&gt;OptimizeTNLP(_ipopt_nlp); //_ipopt_nlp-&gt;eval_f(); //获取 corbo::SolverIpopt::Ptr solver = std::make_shared&lt;corbo::SolverIpopt&gt;(); solver-&gt;initialize(); solver-&gt;setIterations(iterations); //迭代次数 solver-&gt;setMaxCpuTime(max_cpu_time);//最大计算时间 solver-&gt;setIpoptOptionNumeric(); //对应SetNumericValue() 最小迭代阈值 solver-&gt;setIpoptOptionString(); //对应SetStringValue } 最优化问题构造 Controller::configureOcp() { //构建一个超图最优化问题框架， corbo::BaseHyperGraphOptimizationProblem::Ptr hg = std::make_shared&lt;corbo::HyperGraphOptimizationProblemEdgeBased&gt;(); //构建一个最优控制问题框架,相当于在上面的框架上再套一层 corbo::StructuredOptimalControlProblem::Ptr ocp = std::make_shared&lt;corbo::StructuredOptimalControlProblem&gt;(_grid, _dynamics, hg, _solver); //控制输入边界 ocp-&gt;setControlBounds(Eigen::Vector2d(-max_vel_x_backwards, -max_vel_theta), Eigen::Vector2d(max_vel_x, max_vel_theta)); //二次型目标函数cost ocp-&gt;setStageCost(std::make_shared&lt;QuadraticFormCostSE2&gt;(Q, R, integral_form, lsq_solver)); //终端cost ocp-&gt;setFinalStageCost(std::make_shared&lt;QuadraticFinalStateCostSE2&gt;(Qf, lsq_solver)); _inequality_constraint = std::make_shared&lt;StageInequalitySE2&gt;(); //障碍物不等式约束 _inequality_constraint-&gt;setObstacleVector(obstacles); //footprint不等式约束 _inequality_constraint-&gt;setRobotFootprintModel(robot_model); //设置障碍物最小距离 _inequality_constraint-&gt;setMinimumDistance(min_obstacle_dist); //是否开启动态障碍物 _inequality_constraint-&gt;setEnableDynamicObstacles(enable_dynamic_obstacles); //障碍物过滤 _inequality_constraint-&gt;setObstacleFilterParameters(force_inclusion_dist, cutoff_dist); //加速度约束 Eigen::Vector2d ud_lb(-dec_lim_x, -acc_lim_theta); Eigen::Vector2d ud_ub(acc_lim_x, acc_lim_theta); _inequality_constraint-&gt;setControlDeviationBounds(ud_lb, ud_ub); //不等式约束传入最优控制器里 ocp-&gt;setStageInequalityConstraint(_inequality_constraint); } 迭代过程 //由computeVelocityCommands过来 bool Controller::step(const std::vector&lt;geometry_msgs::PoseStamped&gt;&amp; initial_plan, const geometry_msgs::Twist&amp; vel, double dt, ros::Time t, corbo::TimeSeries::Ptr u_seq, corbo::TimeSeries::Ptr x_seq) { _dynamics-&gt;getSteadyStateFromPoseSE2(goal, xf); //目标点转为eigen格式 //起始点根据状态反馈，来选择是用传入的start点，还是用反馈的状态点，还是用odom点。 _dynamics-&gt;getSteadyStateFromPoseSE2(start, x); if(如果目标与上一个目标之间的距离或角度变化大于阈值，将清除路径规划数据 _grid。这是为了确保机器人能够适应新的目标或路径) { _grid-&gt;clear(); } if (_grid-&gt;isEmpty()) //网格路径是否是空 { bool backward = _guess_backwards_motion &amp;&amp; (goal.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fdd276c213ebd1ab6d12619a5223304e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/436c73f47448f3e6999f7bce440f3309/" rel="bookmark">
			Linux下的coredump和kdump
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言coredump是什么？运行异常代码查看本地文件多出的core文件gdb调试带上core文件 kdump机制 前言 在我们之前介绍进程等待的时候，曾经介绍过父进程会等待子进程并且回收子进程的运行结束状态（status输出型参数）:参考博客
当进程因为一些硬件中断，异常等情况意外终止被信号所杀之后，退出码第8为的coredump标志位就会设置为1，这样其父进程会检测到，并且生成一个core快照文件用于后续寻找异常原因;
coredump是什么？ coredump翻译过来就是核心转储，这个机制会在用户级进程异常挂掉时的一个快照(kdump为内核级进程崩溃下面介绍)，保存了异常时的内存、寄存器、堆栈等运行信息。这些数据存储成一个core文件，可以进一步通过gdb等调试器查看分析异常原因;
运行异常代码 异常代码运行结果
查看本地文件多出的core文件 其实core.xxx，这个xxx部分就是当时异常进程对应的pid!
注意：如果无法生成core文件的话，是因为系统默认core文件大小为0字节了，需要用指令ulimit -c xxx 设置一下;
ulimit指令:
S：表示软限制,超出设定的值会告警。H ：表示硬限制，超出设定的值会报错。a ：列出系统所有资源限制的值c：当某些程序发生错误时，系统可能会将该程序在内存中的一些运行信息写成文件(除错用)，这种文 件就被称为核心文件(core file)。此为限制每个核心文件的最大容量d：每个进程数据段的最大值f：当前shell可创建的最大文件容量l：可以锁定的物理内存的最大值m：可以使用的常驻内存的最大值n：每个进程可以同时打开的最大文件句柄数p：管道的最大值s：堆栈的最大值t：每个进程可以使用CPU的最大时间u：每个用户运行的最大进程并发数v：当前shell可使用的最大虚拟内存 gdb调试带上core文件 可以看到，这次gdb调试2程序的时候，后面加上上对应的core文件(注意gcc编译得加-g生成debug版的程序才能用gdb调试)， 会直接跳转到异常的位置，显示了OS发来的异常信号并且描述了异常原因，这有利于我们调试过程中定位异常等等;
kdump机制 Kdump即kernel dump，内核崩溃转储，他的作用和coredump核心转储一样，场景不同，coredump是在用户级的程序挂掉，而Kdump是内核系统级进程崩溃的时候通过kexec进入第二内核捕获生成的crash dump文件并写入磁盘中;
大致流程: 通过kexec机制–&gt;第一内核崩了后load第二(捕获)内核load到内存运行，并生成与第一内核的映射；
紧接着在第二内核中将core文件写入磁盘，之后系统重启；
后续即可通过该core文件分析系统崩溃原因；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ea30c8874db7b8fd92689512bf9c2e0/" rel="bookmark">
			el-tabs那些事
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 去除el-tab-pane的内边距 :deep(.el-tabs--border-card &gt; .el-tabs__content) { padding: 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36c94f3515bc21a50091c53e933f2fc6/" rel="bookmark">
			系分备考计算机网络传输介质、通信方式和交换方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1、概述2、传输介质3、网络通信4、网络交换5、总结 1、概述 计算机网路是系统分析师考试的常考知识点，本篇主要记录了知识点：网络传输介质、网络通信和数据交换方式等。
2、传输介质 网络的传输最常见的就是网线，也就是双绞线，其次还有光纤和无线信道。
最常考的知识点为光纤。
3、网络通信 网络的通信方向分为单工、半双工、全双工，同步方式分为异步、同步、串行和并行。
4、网络交换 交换方式有三种，电路交换、报文交换和分组交换。。
5、总结 本篇计算机网络备考学习，主要记录了网络传输介质、网络通信和数据交换方式等重要的考察知识点。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cfd9d5c5d21c2af6ff1e09d0d8ff1d34/" rel="bookmark">
			Linux gdb调试底层原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言本地调试远程调试GDB调试指令 **GDB与被调试程序之间的关系**GDB调试程序时执行的两个动作ptrace系统调用 剖析GDB如何实现断点指令(调试的底层原理)进一步剖析next指令的调试 如何对正在运行的进程调试?**总结** 前言 linux下gdb调试程序操作过程参考本人文章:gdb调试操作; 这里不再叙述;
本文主要内容是介绍GDB本地调试的底层调试原理，我们来看一下GDB是通过什么机制来控制被调试程序的执行顺序;
总结部分是断点调试的底层原理，可以直接跳转过去先看看大概框架!
本地调试 本地调试：调试程序和被调试程序运行在同一台电脑中。
远程调试 远程调试：调试程序运行在一台电脑中，被调试程序运行在另一台电脑中。
关于可视化调试程序并不是重点，它只是一个用来封装GDB的外壳而已，我们通过它和gdb调试程序交互。
我们既可以用黑乎乎的终端窗口来手动输入调试命令；也可以选择集成开发环境(IDE)，这个IDE中已经嵌入了器调试，
GDB调试指令 随便贴几个指令，等会可以介绍到;
每一个调试指令都有很多的命令选项，例如断点相关的就包括：设置断点、删除断点、条件断点、临时停用启用等等。这篇文章的重点是理解gdb底层的调试机制，所以应用层的这些指令的使用方法就不再列出了，网络上的资源很多。
GDB与被调试程序之间的关系 为了方便描述，先写一个最最简单的C程序：
#include &lt;stdio.h&gt; int main(int argc, char *argv[]) { int a = 1; int b = 2; int c = a + b; printf("c = %d \n", c); return 0; } 编译命令:
$ gcc -g test.c -o test //记得-g选项，生成debug版的可执行程序 我们对可执行程序 test 进行调试，输入命令：
$ gdb ./test 输出如下:
在最后一行可以看到光标在闪烁，这是gdb程序在等着我们给它下达调试命令呢。
当上面这个黑乎乎的终端窗口在执行gdb ./test的时候，在操作系统里发生了很多复杂的事情：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cfd9d5c5d21c2af6ff1e09d0d8ff1d34/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49234870024b9ff0ce815383e3117a0e/" rel="bookmark">
			Dockerfile构建镜像（SSH、Systemctl、nginx、tomcat 、mysql、）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
构建SSH镜像
构建Systemctl镜像
构建nginx镜像
构建Tomcat镜像
构建MySQL镜像
构建SSH镜像 切换到目录 /opt/sshd：
cd /opt/sshd 这是为了进入一个特定的目录，后续的操作将在这个目录下进行。
创建一个 Dockerfile 并使用 Vim 编辑它：
vim Dockerfile 在这一步，你使用Vim编辑器创建或编辑名为Dockerfile的文件。Vim是一个文本编辑器，你可以使用其他编辑器替代。
在 Dockerfile 中添加以下内容，这些内容定义了构建Docker镜像的步骤：
# 使用的基础镜像 FROM centos:7 # 作者信息 MAINTAINER this is ssh image &lt;ssh&gt; # 安装软件包和设置SSH服务 RUN yum -y update RUN yum -y install openssh* net-tools lsof telnet passwd RUN echo '123456' | passwd --stdin root RUN sed -i 's/UsePAM yes/UsePAM no/g' /etc/ssh/sshd_config RUN sed -ri '/^session\s+required\s+pam_loginuid.so/ s/^/#/' /etc/pam.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/49234870024b9ff0ce815383e3117a0e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ead6bd53becf120208fb8777e74375a/" rel="bookmark">
			《Git学习笔记：Git入门 &amp; 常用命令》
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. Git概述 1.1 什么是Git？ Git是一个分布式版本控制工具，主要用于管理开发过程中的源代码文件（Java类、xml文件、html页面等），在软件开发过程中被广泛使用。 其它的版本控制工具
SVNCVSVSS 1.2 学完Git之后能做什么 代码回溯：Git在管理文件过程中会记录日志，方便回退到历史版本
版本切换：Git存在分支的概念，一个项目可以有多个分支（版本），可以任意切换
多人协作：Git支持多人协作，即一个团队共同开发一个项目，每个团队成员负责一部分代码，通过Git就可以管理和协调
远程备份：Git通过仓库管理文件，在Git中存在远程仓库，如果本地文件丢失还可以从远程仓库获取
2. Git概述 2.1 Git简介 Git是一个分布式版本控制工具，通常用来对软件开发过程中的源代码文件进行管理，通过Git仓库来存储和管理这些文件，Git仓库分为两种：
本地仓库：指的是存储在各个开发人员自己本机电脑上的Git仓库远程仓库：指的是远程服务器上的Git仓库 解释说明：
commit：提交，将本地文件和版本信息保存到本地仓库push：推送（上传），将本地仓库文件和版本信息上传到远程仓库pull：拉取（下载），将远程仓库文件和版本信息下载到本地仓库 2.2 Git下载与安装 下载地址： Git - Downloads
下载完成后得到安装文件：
直接双击完成安装即可，安装完成后可以在任意目录下点击鼠标右键，如果能够看到如下菜单则说明安装成功：
Git GUI Here：打开Git图形界面（一般用不上）
Git Bash Here：打开Git命令行
我们用Git，主要是用Git命令行，在命令行当中通过指令来操作Git！
Git安装目录结构如下：
3. Git代码托管服务 3.1 常用的Git代码托管服务 Git中存在两种类型的仓库，即本地仓库和远程仓库，那么我们如何搭建Git远程仓库呢？
我们可以借助互联网上提供的一些代理托管服务来实现，其中比较常用的有GitHub、码云、GitLab等。
名称网址说明GitHubGitHub: Let’s build from here · GitHub一个面向开源及私有软件项目的托管平台，因为只支持Git 作为唯一的版本库格式进行托管，故名GitHubGitee码云Gitee - 基于 Git 的代码托管和研发协作平台国内的一个代码托管平台，由于服务器在国内，所以相比于GitHub，码云速度会更快GitLabThe DevSecOps Platform | GitLab一个用于仓库管理系统的开源项目，使用Git作为代码管理工具，并在此基础上搭建起来的web服务BitBucketBitbucket | Git solution for teams using Jira一家源代码托管网站，采用Mercurial和Git作为分布式版本控制系统，同时提供商业计划和免费账户 3.2 码云代码托管服务 码云网址：Gitee - 基于 Git 的代码托管和研发协作平台
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3ead6bd53becf120208fb8777e74375a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1611ed1052e7070db78f21cd2df04c9e/" rel="bookmark">
			BIOS知识枝桠——RAID 磁盘阵列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、RAID介绍二、RAID等级分类1.RAID02.RAID13.RAID24.RAID3和RAID45.RAID5和RAID66.RAID77.RAID10 BIOS下组建RAID 前言 假设存在多块磁盘，如果不组建阵列，磁盘与磁盘之间是没有任何关系的。磁盘A和B，放在A中的文件与B磁盘没有关系，两块磁盘是完全独立的两个数据仓库，这种传统的没有联系的关系简称JBOD（Just a bunch of disk）结构。这种结构存在很大弊端，当调取磁盘A内数据时，磁盘A在全力工作，磁盘B是空闲的，磁盘B同理，除非同时调用磁盘AB的数据，不然总有一块磁盘是空闲的，无形间就浪费了一部分磁盘性能，为了发挥所有磁盘的性能，磁盘列阵产生了。
一、RAID介绍 RAID：容错式磁盘阵列（Redundant Arrays of Independent Disks，简称：磁盘阵列）是利用利用虚拟化储存技术把多个硬盘组合起来，成为一个或多个硬盘数组组，目的为提升效能或数据容错功能。
在给磁盘组建完RAID后，在电脑内就只会看到一个RAID的阵列盘，子磁盘是看不到的，只需要和使用普通磁盘一样去使用RAID即可。
二、RAID等级分类 RAID有不同等级，目前行业的公认的等级为0-7，不同等级之间并没有优劣之分，仅仅是不同功能的阵列，在使用时根据不同的需求和情况组建合适的RAID。
1.RAID0 RAID0的工作原理很像内存双通道，至少需要两块磁盘，工作原理是把一个完整的数据拆开以后分散到两块磁盘里去，写入的时候同时往两块磁盘写入，读取的时候同时从两块磁盘读取，做到和内存双通道一样带宽翻倍速度翻倍的效果。比较强大的地方是有多少磁盘就可以翻多少倍性能，由于没有和内存一样的IMC的限制，可以把南桥的带宽跑到上限，但是这里的翻倍速度只是连续读写速度，RAID0是无法提高随机读写性能的。
随机读写主要考验的就是硬盘的寻道和寻址能力，在组建完RAID以后，硬盘随机读写性能低下的问题是没有办法改变的，硬盘还是要花费大量的时间去寻道和寻址，所以组建RAID随机读写性能的提高对于单块磁盘来讲，提升是非常微弱的，也有可能会因为某块磁盘问题出现组RAID0 后随机读写能力弱于单块磁盘的现象。
RAID0是所有阵列里传输速度最快也是最不安全的，因为数据被拆分到了好几块磁盘里，假设组了6块磁盘的RAID0，数据就被拆成6份分散在6个磁盘里，万一有任意一块磁盘出现故障，只有剩下的5块磁盘的数据是无法正常读取的，会导致所有的数据全部报废。
因此RAID0 的优缺点都很极端，加的磁盘越多，速度越快，数据越危险。
内存的IMC限制指的是内存控制器（Integrated Memory Controller）的限制。IMC是现代处理器中的一个组件，它负责管理处理器与内存之间的数据传输。其主要作用是控制内存的访问速度和数据传输，以确保处理器能够高效地读取和写入数据。
IMC限制通常表示内存控制器的最大容量或频率。最大容量限制指的是处理器所支持的最大内存容量，即可以安装在系统中的最大内存大小。最大频率限制指的是内存控制器所支持的最大内存频率，即内存模块的工作频率。
2.RAID1 RAID1又被称为镜像，至少也是需要两块磁盘才可以实现，工作原理就是吧一份完整的数据复制到其他磁盘里去，假设有两块磁盘组成RAID1，向RAID1存放数据的时候，两块磁盘内都会存入完全一模一样的数据，所以RAID1就是相当于自动备份。而且组建RAID1以后，系统上只会看见一块磁盘，这是所有阵列里最安全的，但是相应的他的空间利用率和速度是最低的。
假设由两块1T的磁盘组成RAID1，你在系统内只能看到一块磁盘的容量，速度也是一块磁盘的速度，多了一个全自动备份功能。
3.RAID2 RAID2是一种利用海明码校验的一种阵列，主要目的是在RAID0的基础上增加数据纠错能力但并不是容灾，数据纠错能力指的是系统能够在数据传输或存储过程中检测并纠正数据错误的能力。容灾能力是指系统在面对灾难性事件（如自然灾害、人为破坏等）时，能够在较短时间内从灾难中恢复运行并保持正常的业务连续性。
RAID2以数据的第2的n次方为校验文件，也就是1、2、4、8、16、32位是用来纠错的校验码，其他的位置才是原始数据，假设有一个4位编码的数据需要存储，那就需要7块磁盘1 2 4存放校验码，3567是存放数据。假设有8位编码的数据，那么1 2 4 8是拿来存放校验码，35679 10 11 是存放数据，所以RAID2的编码数据位数越少磁盘利用率越低。
由于一次写入数据可以往多块磁盘里写入，所以和RAID0有比较相似的并发性能，但是由于还需要计算校验码，读取的时候也需要读取校验码用于纠错，所以性能开销比较大所以使用的人很少。
4.RAID3和RAID4 RAID3的实现至少需要3块磁盘，在RAID0的基础上增强容灾能力。假设用三块磁盘组成RAID0，这时候再增加一块磁盘作为第四块，第四块磁盘存放着前面三块磁盘的恢复码，在前三块磁盘任意一块出现故障的时候，靠着剩下两块磁盘的数据和恢复码就可以恢复丢失的磁盘的数据，而恢复码的磁盘即使损坏了也不会影响前面三个磁盘的使用。
由于前面三块磁盘和RAID0一样，仅仅只是最后多了校验磁盘，和RAID2海明码的一堆纠错码不同，恢复码的性能消耗比较少，所以RAID3的性能非常接近RAID0。
RAID4和RAID3很像，也是在RAID0的基础上增加一块恢复码磁盘，假设RAID3和4都是3数据盘和1恢复盘，要存储一个文件，被分成了3组，三组数据需要分别存储到磁盘内，RAID3是3组数据依次拆分加上那一组的数据恢复码写入磁盘，RAID4则是123组直接准备好，再为123组的数据整体准备一个恢复码，再把三组数据和整体的恢复码写进去。
这俩的区别就是，RAID3是将1个数据块拆分分开存，校验码也是针对拆分的部分去进行计算的，RAID4是直接按区块去进行存储，校验码是一块计算写入，容灾能力都是一块磁盘。问题就在，假设增加到了5块、10块数据盘，恢复盘始终都是一块，数据盘越来越多，只有一个恢复盘会制约整个阵列的性能。恢复盘的数据没有写入完成，下一次写入是没办法进行的。
5.RAID5和RAID6 RAID5将磁盘恢复码不再单独存放在恢复盘，而是直接拆分开，每一块磁盘里都储存一部分恢复码，这样恢复码的写入操作就是由4快磁盘共同完成，假设其中第三块磁盘无法读取，B1 B2 B3都在不需要恢复，A1+A2+Ap可以恢复A3，C1+Cp+C3可以恢复C2，Dp+D1+D3可以恢复D2。
所以RAID5一方面可以做到RAID0相似的性能还增加了一块磁盘的容灾能力，还解决了RAID4恢复码的瓶颈，所以民用层面RAID5是使用最多的一种磁盘。
需要注意的是做raid 5阵列所有磁盘容量必须一样大，当容量不同时，会以最小的容量为准。 最好硬盘转速一样，否则会影响性能，而且可用空间=磁盘数n-1，Raid 5 没有独立的奇偶校验盘，所有校验信息分散放在所有磁盘上， 只占用一个磁盘的容量。
RAID6的恢复码相对于RAID5从一组变成了2组，下图中黄 绿为恢复码部分，即使损坏了两块磁盘，数据依然能找回，这就让RAID6有了两块磁盘的容灾能力。
6.RAID7 RAID 7 全称叫“Optimized Asynchrony for High I/O Rates as well as high Data Transfer Rates(最优化的异步高 I/O 速率和高数据传输率)”，它与以前我们见到 RAID 级别具有明显的区别。RAID 7 完全可以理解为一个独立存储计算机，它自身带有操作系统和管理工具，完全可以独立运行。大多数用户用不到。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1611ed1052e7070db78f21cd2df04c9e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6372e9e18bbe796daf5fbf0a9ee4e029/" rel="bookmark">
			C语言——小细节和小知识9
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、大小端字节序 1、介绍 在计算机系统中，大小端（Endianness）是指多字节数据的存储和读取顺序。它是数据在内存中如何排列的问题，特别是与字节顺序相关。C语言中的数据存储大小端字节序指的是在内存中存储的多字节数据类型（如整型、浮点型）的字节序排列方式，主要有两种：
大端字节序（Big-Endian）：在大端字节序中，一个多字节数据的最高有效字节（即“大端”）存储在内存的最低地址处，其余字节按照在数值中的顺序依中次存储在连续的内存地址。例如，一个四字节的整数 0x12345678 在内存中的存储顺序（从低地址到高地址）为 12 34 56 78。
小端字节序（Little-Endian）：在小端字节序中，一个多字节数据的最低有效字节（即“小端”）存储在内存的最低地址处，其余字节按照在数值中的逆序存储在连续的内存地址中。采用同样的四字节整数 0x12345678 为例，在内存中的存储顺序（从低地址到高地址）将会是 78 56 34 12。
大小端字节序通常由硬件决定，即由CPU的设计来规定。例如，Intel的x86架构是小端字节序，而网络协议通常采用大端字节序。在C语言编程中，通常不需要关心数据的字节序，除非你在进行底层的内存操作或者网络通信、跨平台数据传输等需要考虑字节序兼容性的场合。在这些情况下，你可能需要使用函数如 htonl() 和 ntohl() 来在主机字节序和网络字节序之间转换整数类型的数据。
目前，大部分的个人电脑和服务器处理器采用小端（Little-Endian）字节序。这主要是因为Intel的x86架构处理器和后续的x86-64架构（也称为AMD64）都采用小端字节序，而这些处理器在个人电脑和服务器市场中占据主导地位。
除了Intel和AMD之外，许多基于ARM架构的处理器也通常配置为小端模式，尤其是在智能手机和平板电脑等移动设备中。ARM架构是可切换的，即可以在大端和小端之间切换，但在实际应用中，小端模式更为普遍。
大端（Big-Endian）字节序相对来说较少见，但在某些应用和处理器设计中仍然使用，例如在一些嵌入式系统、网络设备和早期的IBM、Sun等公司的系统中。网络协议，如IP协议，使用的是大端字节序，这通常称为网络字节序。
随着市场的发展和技术的演进，小端字节序成为了主流，但在进行跨平台或网络编程时，处理字节序依然非常重要。在这些领域，开发者必须确保数据在不同字节序的系统间正确传输和解释。
2、例子 以下程序的运行结果：
#include &lt;stdio.h&gt; int main() { int arr[] = { 1,2,3,4,5 }; short* p = (short*)arr; int i = 0; for (i = 0; i &lt; 5; i++) { *(p + i) = 0; } for (i = 0; i &lt; 5; i++) { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6372e9e18bbe796daf5fbf0a9ee4e029/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00af0efe96b25ecfb4a9ae4394214e01/" rel="bookmark">
			微信商家转账到零钱开通教程？场景选择
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		商家转账到零钱是什么？
【商家转账到零钱】可以说是【企业付款到零钱】的升级版，商家转账到零钱可以为商户提供同时向多个用户微信零钱转账的能力，支持分销返佣、佣金报酬、企业报销、企业补贴、服务款项、采购货款等自动向用户转账的场景。
商家转账到零钱的使用场景有哪些？
主要是用于小程序商城的分销功能，小程序里的用户帮助把产品推广出去，需要给别人用户，有这个功能以上，用户在小程序里申请提现，管理员可以把佣金在小程序管理后台直接发给用户，不用手动转账，非常方便。
商家转账到零钱的申请条件
1.申请商家转账到零钱必须为 企业主体。
2.一般申请场景为 分销返佣或者现金营销。单次提现最大额度是500元。
3.审核周期一般三到七个工作日，只需要扫码操作即可
商家转账到零钱怎么开通？
商家转账到零钱的审核时长
一般一次过的话是3个工作日左右，如果被驳回第二次提交，做到一个月的准备，亲身经历（也是第二次提交），12-02提交的，到12-28号下来的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b433d1f2a9d20f02a519ef62643e9405/" rel="bookmark">
			OS的Alarm定时器调度机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 调度表触发的任务在编译时就被静态定义，任务的触发时间和执行顺序是固定的。这种方式适用于已知的、固定的任务触发模式，例如周期性任务或事件驱动任务。而使用 Alarm 机制触发的任务具有更大的灵活性。Alarm 允许在运行时动态地设置和修改任务的触发时间和间隔。这种方式适用于需要根据实时系统的动态变化来触发任务的场景，可以根据实际情况动态调整任务的触发时间，以满足实时性要求。如果调度表的任务和 Alarm 的任务同时触发，通常会采用优先级规则来确定哪个任务先执行。具体的处理方式取决于操作系统的调度策略和任务的优先级设置。调度表中任务是通过调度器触发的，而alarm的任务是通过计时器触发的。alarm的任务如何在运行时动态设置和修改触发时间和间隔，可能涉及到时间同步的东西。由多alarm触发的多任务周期晃动很大，是由于高优先级任务抢占低优先级任务，导致低优先级任务要等高优先级任务执行完才能执行。首先，出现这种情况，肯定是对于任务的优先级和触发周期没有合理安排导致的。解决方法就是调整优先级和触发周期或改用调度表。 调度表的周期性任务与alarm周期性任务可以理解为，如果到了触发时间，如果有高优先级的任务抢占了低优先级的任务，调度表触发的任务会将任务挂起，之后等到下一个周期在重新执行，而alarm触发的任务是等高优先级任务执行完，就立即执行低优先级任务，alarm是基于全抢占调度机制实现的。如果调度表的周期任务与alarm的周期任务撞上了，调度表中的任务优先级高，那就是调度表的任务执行完后立即执行alarm的任务。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9fae3785460151e6aa9569e3d1b0e0d/" rel="bookmark">
			【错误】tcpreplay: Symbol `pcap_version‘ has different size in shared object, consider re-linking
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题 每次在回放包时均遇到这样的错误：
tcpreplay: Symbol `pcap_version’ has different size in shared object, consider re-linking
如图：
有没好的解决办法？或者合理的解释；google搜到的也全是没有答案的问题；如果你也在找答案，那么真是巧了。
影响 没啥影响后边不是 Successful packets: 647 并且 Failed 的是0，这个是正常回放的效果
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10836252cd9405a26ef1ee8e4c08d300/" rel="bookmark">
			mybatis-plus批量保存异常及效率优化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近基于自己公司内部服务维护，发现其中调度中心近期出现不少错误日志，但是该任务却是正常执行，生成的报表数据也是正常的，所以很多天没有发现问题
这就匪夷所思了，
经仔细排查发现，是触发了feign超时hystrix熔断器机制
也就是说子服务出现了执行时间过长的情况
是什么让它花费这么多时间去执行呢，只有一个for循环，组装list&lt;object&gt;
这个组装过程在java看来是非常快，根本不可能出现问题
我发现了
iXxxxService.saveBatch(xxxx); mybatisplus3.3.2自带的批量保存的sql接口
跟踪代码的实现
在接口发现IService
@Transactional( rollbackFor = {Exception.class} ) default boolean saveBatch(Collection&lt;T&gt; entityList) { return this.saveBatch(entityList, 1000); } boolean saveBatch(Collection&lt;T&gt; entityList, int batchSize); ServiceImpl的实现 @Transactional( rollbackFor = {Exception.class} ) public boolean saveBatch(Collection&lt;T&gt; entityList, int batchSize) { String sqlStatement = this.sqlStatement(SqlMethod.INSERT_ONE); return this.executeBatch(entityList, batchSize, (sqlSession, entity) -&gt; { sqlSession.insert(sqlStatement, entity); }); } protected &lt;E&gt; boolean executeBatch(Collection&lt;E&gt; list, int batchSize, BiConsumer&lt;SqlSession, E&gt; consumer) { Assert.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/10836252cd9405a26ef1ee8e4c08d300/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53209989eb4647d07fd6c10e9a662e95/" rel="bookmark">
			ElasticSearch扫盲概念篇[ES系列] - 第500篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		历史文章（文章累计500+）
《国内最全的Spring Boot系列之一》
《国内最全的Spring Boot系列之二》
《国内最全的Spring Boot系列之三》
《国内最全的Spring Boot系列之四》
《国内最全的Spring Boot系列之五》
《国内最全的Spring Boot系列之六》
ElasticSearch详细搭建以及常见错误high disk watermark [ES系列] - 第497篇
Elasticsearch可视化平台Kibana [ES系列] - 第498篇
Elasticsearch安装分词插件[ES系列] - 第499篇
悟纤：师傅，脑瓜疼来着~
​
师傅：徒儿这是怎么了？
悟纤：师傅，我感觉自己总是很忧虑，无法真正开心起来。
师傅：徒儿，我理解你的感受。有时候，我们会被一些琐事和烦恼所困扰，导致心情不畅。但是，要想获得更开心，我们需要学会调整自己的心态。
悟纤：师傅，怎么调整呢？
师傅：首先，你要学会放下那些无谓的忧虑和烦恼。不要让它们占据你的心灵，影响你的情绪。尝试转移注意力，去做一些让你感到快乐和满足的事情。
悟纤：弟子明白了，要学会放下烦恼，去做让自己开心的事情。
师傅：很好，徒儿。此外，你还可以尝试改变自己的思维方式。不要总是看到事情的负面，试着从积极的角度去看待问题。记住，生活中总会有不如意的事情，但是我们可以选择如何去面对它。
悟纤：师傅，徒儿会努力尝试的。
师傅：我相信你一定能够做到。此外，你还可以尝试寻找一些能够帮助你放松身心的方法，比如运动、听音乐、阅读等。这些活动可以帮助你缓解压力，让你的心情变得更加愉悦。
悟纤：徒儿明白了，谢谢师傅的指导。
导读
Hi，大家好，我是悟纤。我就是我，不一样的烟火。我就是我，与众不同的小苹果。
这一节来看看ES的概念。
一、ES概念
1.1 节点：Node
ElasticSearch 是以集群的方式运行的，而节点是组成ES集群的基本单位，所以每个 ElasticSearch 实例就是一个节点，每个物理机器上可以有多个节点，使用不同的端口和节点名称。
节点按主要功能可以分为三种：主节点(Master Node)，协调节点(Coordianting Node)和数据节点(Data Node)。下面简单介绍下：
主节点：处理创建，删除索引等请求，维护集群状态信息。可以设置一个节点不承担主节点角色
协调节点：负责处理请求。默认情况下，每个节点都可以是协调节点。
数据节点：用来保存数据。可以设置一个节点不承担数据节点角色
http://localhost:9200/_cat/nodes?v
1.2角色：Roles
ES的角色分类：
· 主节点（active master）：一般指活跃的主节点，一个集群中只能有一个，主要作用是对集群的管理。
· 候选节点（master-eligible）：当主节点发生故障时，参与选举，也就是主节点的替代节点。
· 数据节点（data node）：数据节点保存包含已编入索引的文档的分片。数据节点处理数据相关操作，如 CRUD、搜索和聚合。这些操作是 I/O 密集型、内存密集型和 CPU 密集型的。监控这些资源并在它们过载时添加更多数据节点非常重要。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/53209989eb4647d07fd6c10e9a662e95/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a4eb553bfbb427f8b2563827cebbad0/" rel="bookmark">
			Android 获取屏幕宽高、状态栏高度、底部导航栏高度信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Android 获取屏幕、状态栏、导航栏信息结构关系使用开启全面屏手势总结工具类ScreenUtils.javaBarUtils.javaRomUtils.java Android 获取屏幕、状态栏、导航栏信息 结构关系 手机屏幕高度 = 状态栏高度 + ActionBar高度 + ContentView高度 + 导航栏高度
使用 public class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); int screenWidth = ScreenUtils.getScreenWidth(); int screenHeight = ScreenUtils.getScreenHeight(); Log.e("TAG", "屏幕宽高：" + screenWidth + " - " + screenHeight); int appScreenWidth = ScreenUtils.getAppScreenWidth(); int appScreenHeight = ScreenUtils.getAppScreenHeight(); Log.e("TAG", "屏幕宽高（排除系统装饰元素）：" + appScreenWidth + " - " + appScreenHeight); int statusBarHeight = BarUtils.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0a4eb553bfbb427f8b2563827cebbad0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1a88e9fca2744bc836cac8be5bdc123/" rel="bookmark">
			Springboot启动后自动退出解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题复现 启动SpringBoot项目成功启动后，总是自动退出。控制台应该会有一句提示消息：
No active profile set, falling back to default profiles: default
原因分析 该问题一般都是因为Springboot项目在启动时没有正常启动Tomcat容器，只是执行了main方法而后进程关闭了。
解决办法 在pom.xml文件添加如下代码：
&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; 注意：添加依赖时注意版本号是否需要指定(&lt;version&gt;XXX&lt;/version&gt;)。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0ecfa7e8530713c301587436843a7f6/" rel="bookmark">
			元素水平垂直居中的5种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、利用弹性盒子
将父元素设置为display:flex;
通过：
justify-content: center;
align-items: center;
来设置元素的垂直水平居中
2、将元素转化为表格的形式
父元素设置：
display: table-cell;
vertical-align: middle;
text-align: center;
子元素需设置：
display: inline-block;
vertical-align: middle;//消除行内块元素三像素问题
3、利用绝对定位
将父元素设置为相对定位
position:relative;
子元素设置绝对定位
position: absolute;
top: 0;
left: 0;
right: 0;
bottom: 0;
margin: auto
4、利用translate
将父元素设置为相对定位
position:relative;
子元素设置绝对定位
position: absolute;
top:50%;
left:50%;
transform: translate(-50%,-50%);
子元素的宽高自己设置
5、利用 margin-top: ;和margin-left: ;
将父元素设置为相对定位
position:relative;
子元素设置绝对定位
position: absolute;
top:50%;
left:50%;
margin-top:-(自身高度的一半） ;
margin-left:-（自身宽度的一半） ;
例：
.child{
width: 100px;
height: 100px;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c0ecfa7e8530713c301587436843a7f6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/472a9d52b079aa1b067616579cf739f8/" rel="bookmark">
			Win10下如何清理优化C盘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Windows 10操作系统中，随着时间的推移，C盘可能会因为各种原因而变得拥挤不堪。这不仅会影响系统的运行速度，还可能导致一些未知的问题。因此，定期清理和优化C盘是保持系统良好状态的重要步骤。本文将为您提供一系列实用的方法，帮助您在Windows 10下清理和优化C盘。
联想知识库https://iknow.lenovo.com.cn/detail/193404
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/258e70438e295727fad5407e1b777c5f/" rel="bookmark">
			修改git代码提交路径
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		要修改Git的代码提交路径，可以按照以下步骤进行操作：
1、打开命令行工具（如Windows上的CMD或者Mac上的Terminal）。
2、使用cd命令切换到当前项目所在的文件夹中。
3、运行以下命令来查看当前的远程仓库地址：
git remote -v
这将显示当前配置的远程仓库名称及其对应的URL。
4、若需要更新远程仓库的URL，则可以使用以下命令：
git remote set-url origin &lt;new_remote_repository_url&gt;
其中 &lt;new_remote_repository_url&gt; 为新的远程仓库URL。
5、最后，再次运行 git remote -v 确认已成功修改了远程仓库的URL。
注意事项：
在第四步中，origin 表示默认的远程仓库名称，根据自己的情况可能会有不同的名称。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6523c67699c76a35100fa6d4bb500074/" rel="bookmark">
			单列的堆叠柱状图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目的 MSingleColumnStackBarChart类被设计用于创建只有单列的堆叠柱状图，用于血糖数据的统计。以下是封装这个类的目的的详细描述：
抽象复杂性： 通过创建MSingleColumnStackBarChart类，你将复杂的MPAndroidChart库的使用和配置封装在一个独立的类中。这有助于降低代码的复杂性，使得在其他部分的代码中更容易理解和维护。
提高可读性： 将与图表配置相关的代码集中在一个类中，使得主要的业务逻辑部分的代码更加清晰。其他开发者在查看代码时能够更轻松地理解图表的配置和使用方式。
重用性： 通过封装这个类，你可以在不同的部分或项目中重复使用相同的图表配置。这意味着，如果将来有其他地方需要显示类似的单列堆叠柱状图，你可以轻松地引入这个类，而无需重新实现相同的配置。
模块化： 类的封装使得代码更加模块化。这允许你将图表的配置和数据处理与其他功能分离，促使代码更易于组织和维护。
简化调用： 通过提供简单的接口，类的使用者只需几行代码就能创建和显示单列堆叠柱状图。这有助于降低使用图表功能时的学习曲线，并使代码更加整洁。
总体而言，MSingleColumnStackBarChart类的封装旨在提供一种简单、灵活且易于使用的方式，以满足特定场景下（如血糖数据统计）显示单列堆叠柱状图的需求。这样的封装是为了在开发中提高效率、降低出错概率，并促使代码更具可维护性。
示例 中间的就是柱状形，只要按百分比进行堆叠显示。
调用示例 List&lt;MSingleColumnStackBarChart.MBarData&gt; dataList = new ArrayList&lt;&gt;(); for (int x = 0; x &lt; 1; x++) { MSingleColumnStackBarChart.MBarData data = new MSingleColumnStackBarChart.MBarData(15, getColor(R.color.colorHHigh), "15% 很高 &gt; 13.0 mmol/L"); dataList.add(data); data = new MSingleColumnStackBarChart.MBarData(10, getColor(R.color.colorHigh), "10% 偏高 &gt; 10.0 mmol/L"); dataList.add(data); data = new MSingleColumnStackBarChart.MBarData(60, getColor(R.color.colorNormal), "60% 正常 3.9-10.0 mmol/L"); dataList.add(data); data = new MSingleColumnStackBarChart.MBarData(10, getColor(R.color.colorLow), "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6523c67699c76a35100fa6d4bb500074/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/592b9541e668cd0a4abbdba7e510f0e1/" rel="bookmark">
			redis7部署集群：包含主从模式、哨兵模式、Cluster集群模式等三种模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：
redis部署集群常见的一般有三种模式：主从模式，Sentinel（哨兵模式），Redis Cluster（高可用Cluster集群），根据不同的需求可自定义选择部署方式。
Redis 主从模式（Replication）
优点：
数据备份：主节点的数据会复制到从节点，提供了数据冗余和一定程度的故障恢复能力。
读写分离：可以将读操作分散到从节点上执行，减轻主节点的压力，提高系统的读取性能。
扩容：通过添加从节点可扩展只读操作的能力。
缺点：
无自动故障转移：当主节点发生故障时，需要人工介入进行故障切换，并更新客户端指向新的主节点。
写性能瓶颈：所有写操作必须在主节点完成，因此主节点成为系统写入的瓶颈。
数据同步延迟：主从之间存在一定的数据同步延迟，可能导致短时间内从节点数据不一致。
Sentinel（哨兵）模式
优点：
高可用性：Sentinel 系统能够自动检测主节点是否下线，并自动完成故障转移，选举新的主节点。
监控与通知：Sentinel 可以持续监控Redis服务器的状态并发送通知。
配置中心：客户端可以通过连接Sentinel来获取当前主节点的信息，无需硬编码主节点地址。
缺点：
复杂性增加：相较于主从模式，增加了Sentinel集群的部署、管理和维护成本。
网络问题敏感：由于依赖于Sentinel之间的通信，网络问题可能会影响故障转移的正确性和效率。
资源消耗：每个Sentinel实例都需要占用一定的系统资源。
Redis Cluster（集群模式）
优点：
分布式存储：数据分布在多个节点上，支持水平扩展，提供更大的存储容量和更高的吞吐量。
自动分片：通过哈希槽分区实现数据的自动分片和负载均衡。
自动故障转移：支持节点间自动故障转移和数据迁移，提高了整个系统的可用性。
缺点：
数据迁移开销：在添加或删除节点时，可能会触发大规模的数据迁移，影响集群性能。
客户端兼容性要求：部分操作如跨slot键操作、批量操作等，在Cluster模式下受到限制，客户端需支持Cluster特性才能正常使用。
更复杂的运维：相对于单机和主从模式，集群模式对运维人员的技术要求更高，且集群配置相对复杂。
主从模式适合简单场景下的数据备份和读写分离需求，但不适合需要自动故障转移和高度扩展的应用。
哨兵模式为了解决主从模式中自动故障转移的问题而设计，适用于对高可用性有较高要求的场景。
集群模式则针对大规模数据处理和高并发场景，提供了良好的水平扩展能力和自动化管理功能。
演示版本： 此教程不记录redis的安装过程
系统：anolis8.4虚拟机（阿里的龙蜥系统，可以看成相当于centos8系统）
redis：7.0.14
开始部署： 以下演示都在同一台机器，实际的生产环境还是建议配置到多台机器中
------------------------------我是昏割线------------------------------主从模式：
可以部署最简单的一主一从，也可以部署一主多从，下面以一主一从为例，主端口6379，从端口6380。
准备好一个安装好的redis，因为我是安装好redis后，只拷贝了需要的目录与文件，所以只有bin和etc两个目录，同时创建好存放数据的文件夹，以及日志文件夹，日志看自己需求需不需要配置，etc下就是redis的配置文件。
配置主节点redis_6379.conf配置文件：
支持后台运行：
daemonize yes 日志路径：看自己需求，也可以不配置
logfile "/home/l/kxm/serv/redis_PS/redis/log" 指定数据存放位置：默认配置是"./"，集群模式下必须指定路径，不然容易丢失数据
dir /home/l/kxm/serv/redis_PS/redis/data_6379 配置从节点redis_6380.conf配置文件：
复制主配置文件：
cp redis_6379.conf /home/l/kxm/serv/redis_PS/redis/etc/redis_6380.conf 配置replicaof节点：从配置要比主配置多一个replicaof节点配置，用于绑定主节点。
replicaof 主节点ip 主节点redis端口，例：
replicaof localhost 6379 这里特别说明一下，因为我是做演示，主从都配置在同一台机器上，最开始ip写的是指定ip，比如192.168.xxx.xxx这种，这样行不通，从节点一直连不上主节点，后面发现写成localhost或者127.0.0.1是没问题的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/592b9541e668cd0a4abbdba7e510f0e1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6aa1f18529339dba72dd4465d87bad5/" rel="bookmark">
			麦讯通：无需API开发，轻松实现电商平台和客服系统连接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		麦讯通：无需API开发即可实现电商与客服的连接 在数字化运营的浪潮中，能够实现电商平台和客服系统的无缝集成对企业来说至关重要。然而，传统的API开发方式需要大量的时间和技术资源，这对于许多企业来说是一个挑战。麦讯通科技有限公司提供的云通讯产品，使得企业可以轻松实现这一目标，而无需进行复杂的代码开发。
无代码开发：快速应对市场变化的秘诀 在激烈的电商市场中，能够快速响应客户需求并提供即时服务是成功的关键。麦讯通的平台使得连接电商系统和客服系统变得异常简单，企业只需通过简单的配置即可实现系统间的对接。这种无代码开发的方式不仅降低了技术门槛，还显著缩短了项目的实施周期，让企业能够快速适应市场变化。
麦讯通集成：提升客户服务效率的利器 高效的客户服务是电商成功的另一个重要因素。通过集成麦讯通的云通讯服务，电商企业可以实现自动化的客户互动，如订单确认、发货通知、售后支持等。这样的自动化流程不仅提高了客服团队的工作效率，还确保了客户体验的一致性和高质量。
简化操作流程：麦讯通的用户友好界面 麦讯通的用户友好界面进一步简化了操作流程。企业用户只需登录官网，通过简单的授权步骤，输入用户账号和密码，即可开始使用。这个过程无需复杂的技术知识，甚至连账户名称都可以自定义，大大降低了操作的复杂度。
选择麦讯通：优化电商与客服系统的理想伙伴 作为一个专注于云通讯产品研发与服务的供应商，麦讯通一直致力于为企业提供优质的整体解决方案。其云链接短信平台的强大功能和易用性，使得无数电商企业受益。通过这种无需API开发即可实现连接和集成的高效解决方案，企业可以更好地应对未来的市场挑战。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7852fd7cd39beb3ebd84444c68f35682/" rel="bookmark">
			java基础之线程安全问题以及线程安全集合类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		线程安全问题 当多个线程同时访问同一个临界资源时,原子操作可能被破坏,会导致数据丢失, 就会触发线程安全问题
临界资源: 被多个线程同时访问的对象
原子操作: 线程访问临界资源的过程中不可更改和缺失的操作
互斥锁 每个对象都默认拥有互斥锁, 该锁默认不开启.
当开启互斥锁之后,线程想要访问对象,则在需要拥有时间片的基础上也拥有锁标记,锁标记只能被一个线程拥有,拥有时间片和锁标记的线程才能执行自身内容,在此期间,其他线程只能等正在执行的线程执行结束释放锁标记和时间片之后才能进入就绪状态
synchronized: 开启互斥锁的关键字
同步方法 思路: 在被线程同时访问的方法上加锁
访问修饰符 synchronized 返回值类型 方法名(参数列表){ } package com.by.util; ​ import java.util.ArrayList; import java.util.List; ​ /** * 工具类-操作集合属性 */ public class MyList { private List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); ​ /** * 给集合属性添加元素 * @param n 添加的元素值 synchronized: 同步方法 */ public synchronized void insert(int n){ list.add(n); } /** * 查看集合内容 */ public void query(){ System.out.println("集合长度: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7852fd7cd39beb3ebd84444c68f35682/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e09073bbf8dab306cb7f0ff8b3bff1b/" rel="bookmark">
			[RK3399]tc358743芯片的HDMI IN播放视频有电流声
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前言 产品开发中发现HDMI IN输入音频的时候有电流声，分析得知hal层hdmiin的音频采样率和驱动指定采样率的不同。
二、代码路径 Android\kernel\drivers\media\i2c\tc35874x.c Android\hardware\rockchip\audio\tinyalsa_hal\audio_hw.c Android\kernel\drivers\media\v4l2-core\v4l2-dev.c 三、代码分析 audio_hw.c
static int get_hdmiin_audio_rate(struct audio_device *adev) { int rate = 44100; char value[PROPERTY_VALUE_MAX] = ""; property_get("vendor.hdmiin.audiorate", value, STR_44_1KHZ); if ( 0 == strncmp(value, STR_32KHZ, strlen(STR_32KHZ)) ){ rate = 32000; }else if( 0 == strncmp(value, STR_44_1KHZ, strlen(STR_44_1KHZ)) ){ rate = 44100; }else if( 0 == strncmp(value, STR_48KHZ, strlen(STR_48KHZ)) ){ rate = 48000; } else { rate = atoi(value); if (rate &lt;= 0) rate = 44100; } // if hdmiin connect to codec, use 44100 sample rate if (adev-&gt;dev_in[SND_IN_SOUND_CARD_HDMI].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1e09073bbf8dab306cb7f0ff8b3bff1b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37d7e68da0b856f8df0ef072b87c6991/" rel="bookmark">
			IDEA的database插件无法链接mysql的解决办法（08001错误）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		错误复现： 如上图所示，用navicat链接数据库正常，mysql控制台操作正常，但是用IDEA的数据库插件链接一直报 08001 错误【[08001] Could not create connection to database server. Attempted reconnect 3 times. Giving up. 】
错误原因： 造成这个问题的原因是因为数据库驱动包的版本问题，与当前的数据库版本不兼容（我的是mysql5.7版本，而驱动是8.0的版本）
还有一些其他的情况，如提示ServerTimezone不正确（或者是一串乱码）等大部分都是驱动和url参数的问题。
解决办法： 首先我们先来设置一下serverTimeZone：
点击 advanced 添加一个参数： serverTimezone 值为 Asia/Shanghai
也可以最后设置时区，有多种方法可以设置。
我的是 mysql 5.7 版本，所以我要下载mysql 5.x的驱动 ，具体的操作见下图：
我们再IDEA中创建与数据库的链接的时候，可以选择驱动的版本：
驱动下载完设置好以后，我们就可以再次测试连接了：
现在就成功连接啦
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c91cdfb2cffd7061fc2a1b651f743b6/" rel="bookmark">
			【opencv】python实现人脸检测和识别训练
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		人脸识别 OpenCV 中的人脸识别通常基于哈尔特征分类器（Haar Cascade Classifier）进行。以下是 OpenCV 人脸识别的基本原理：
Haar Cascade Classifier：
特征分类器：Haar 特征是一种基于矩形区域的特征，可以用于图像中的对象检测。这些特征可以表示边缘、线和区域的变化等。级联分类器：Haar 级联分类器是由大量的弱分类器组成的级联结构，每个弱分类器用于检测图像的一个特定特征。级联分类器能够快速排除非目标区域，提高效率。 训练分类器：
Haar 分类器需要经过训练，使用正样本（包含人脸的图像）和负样本（不包含人脸的图像）进行训练。OpenCV 提供了工具来训练这些分类器。 人脸检测过程：
图像灰度化：首先，图像被转换为灰度图像，简化处理。级联分类器应用：Haar 分类器通过图像的不同区域以固定的步长和缩放应用。在每个区域，级联分类器检测是否有人脸特征。人脸候选区域：检测到的候选区域被保留，其中可能包含人脸。非极大值抑制：对于重叠的候选区域，采用非极大值抑制，选择最具代表性的人脸区域。 人脸识别：
识别是通过使用预训练的人脸识别模型进行的。在检测到人脸的区域中，可以使用各种方法（如基于模板的匹配或深度学习模型）进行人脸识别。 首先安装依赖
pip install opencv-python pip install opencv-contrib-python pip install numpy pip install pillow 拍照采集人脸 cv2.ideoCapture(0)的0是默认摄像头，如果外置摄像头可以换其他数字试试，这段代码其实就是通过opencv来拍照并保存用于后面的数据训练。
# 导入模块 import cv2 # 摄像头 cap = cv2.VideoCapture(0) flag = 1 num = 1 while cap.isOpened(): ret, frame = cap.read() cv2.imshow('frame', frame) k = cv2.waitKey(1) &amp; 0xFF if k == ord('s'): # 按下s键，保存图片 cv2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0c91cdfb2cffd7061fc2a1b651f743b6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7c3630aef76c9592c1277628c618919/" rel="bookmark">
			蓝桥P2143：最少刷题数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述 小蓝老师教的编程课有 N 名学生，编号依次是 1...N 。第 i 号学生这学期刷题的数量是 Ai 。
对于每一名学生，请你计算他至少还要再刷多少道题，才能使得全班刷题比他多的学生数不超过刷题比他少的学生数。
输入格式
第一行包含一个正整数 N 。
第二行包含 N 个整数： A1，A2，A3，... ，AN。
输出格式
输出N个整数，依次表示第 1... N 号学生分别至少还要再刷多少道题。
样例输入
5
12 10 15 20 6
样例输出
0 3 0 0 7
评测用例规模与约定
对于 30% 的数据，1 ≤ N ≤ 1000，0 ≤ Ai ≤ 1000.
对于 100% 的数据，1 ≤ N ≤ 100000，0 ≤ Ai ≤ 100000.
运行限制
最大运行时间：1s
最大运行内存：512M
解题思路 基本的一个思路就是，对已有的刷题量数据进行排序，找出比它大和比它小的数据的个数，如果不满足题意条件（即不满足“大于它的数据个数比小于它的数据个数少或相等”），就计算它和中位数的差值表示需要再刷的题量，但如果中位数本身不满足题意条件，则再刷的题量需要比中位数还大也就是至少需要再加一。
参考代码 #include &lt;bits/stdc++.h&gt; using namespace std; // 定义结构体 typedef struct{ int no; // 编号 int pro,less; // 已刷题数和还需刷题数 int left,right; // 比它小的大的数据个数 } student; // 按照已刷题数的排序规则 bool comp1(const student &amp;a, const student &amp;b){ return a.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b7c3630aef76c9592c1277628c618919/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76039e90e534a420cad2c362e727725a/" rel="bookmark">
			postgresql 逻辑复制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文为 【TDSQL-PG笔记】主从复制原理的系列文章，实验基础环境参考栏目第一篇blog
如果要将不同库的某关键表备份到指定库里，可以用逻辑复制完成相关功能。
逻辑复制基本概念 PG逻辑复制基于发布和订阅模型，一个发布可以有多个订阅者。
发布publication可以创建在任意单机上，也可以在物理复制的主库上，发布端要求数据库参数WAL_LEVEL为logical。一个发布可以被多个数据库订阅。一个发布只能包含一个数据库中的表，但是这些表可以分布在不同的schema下。
订阅处于逻辑复制的下游端，一个订阅只能对应一个发布。订阅端的数据库名可以跟发布端不同，但是订阅发布的表名和schema必须相同。
当订阅创建成功后，就会自动在发布端创建多个逻辑复制槽，其中一个用于后续的增量数据同步，永久保留，另外还会创建一个或者多个的临时复制槽，用于复制表的全量快照数据。
是当发布端是物理复制架构时，如果发生主从切换，发布是不会跟随数据库failover的。但是可以通过手工拷贝文件或者利用插件实现。
逻辑复制的限制 （1）数据库的表结构不会被复制，所以需要在订阅端先创建对应的schema和表
（2）TRUNCATE和DDL不会复制，如果要进行DDL变更，需要先在订阅端执行DDL，然后在发布端执行。
（3）Sequence不会不复制，当发布端使用了sequence数据，其写入了表的值会同步到订阅端，但是目标库的sequence并不会发生变化。
（4）不支持大对象。
（5）复制只能是基表到基表，不支持视图、物化视图、外部表等。如果表是分区表，需要基于分区进行复制。
测试 发布和订阅端都新建相同的表t1,t2发布端为t1创建发布订阅端为t1创建订阅 新建一个库，做为订阅端 [pg@localhost data]$ pg_ctl init -D /data/db3 发布与订阅端都建相关同步结构的表t1,t2 postgres=# create table t1(id int,name varchar(20)); CREATE TABLE postgres=# create table t2(id int,name varchar(20)); CREATE TABLE 在发布端为t1创建发布
修改发布端wal_level = logical，修改后要restart订阅端，reload不生效。 postgres=# show wal_level; wal_level ----------- logical (1 row) postgres=# create publication pub_test for table t1; CREATE PUBLICATION 在订阅端为t1创建订阅
注：订阅端有wal_level也必须是logical postgres=# create subscription sub_test connection 'host=127.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/76039e90e534a420cad2c362e727725a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2822a892247603d383e65266af332d9/" rel="bookmark">
			开源内容管理系统Wagtail本地安装运行并结合内网穿透实现公网访问
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言1. 安装并运行Wagtail1.1 创建并激活虚拟环境 2. 安装cpolar内网穿透工具3. 实现Wagtail公网访问4. 固定的Wagtail公网地址 前言 Wagtail是一个用Python编写的开源CMS，建立在Django Web框架上。Wagtail 是一个基于 Django 的开源内容管理系统，拥有强大的社区和商业支持。它专注于用户体验，并为设计人员和开发人员提供精确控制。
选择wagtail的原因：
它能快速实现页面的表达，对于我这种对新实现的功能想要找到地方进行展示，但前端能力又不太行的同学基于django 一直会对django的稳定版本进行支持 Wagtail由开发人员为开发人员构建。那么结合cpolar内网穿透可以进行公网远程访问，实现花更少的时间进行配置，而将更多的时间用于完善您的网站。本篇文章介绍如何安装运行Wagtail，并实现公网访问网站界面。
1. 安装并运行Wagtail Wagtail 支持 Python 3.8、3.9、3.10 和 3.11。
要检查您是否有合适的 Python 3 版本，请运行以下命令：
python --version # Or: python3 --version # **On Windows** (cmd.exe, with the Python Launcher for Windows): py --version 如果上述命令均未返回版本号，或返回低于 3.8 的版本，则安装 Python 3。
1.1 创建并激活虚拟环境 按照顺序进行安装
pip install wagtail wagtail start mysite cd mysite pip install -r requirements.txt python manage.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a2822a892247603d383e65266af332d9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a13c0600fd3becc024b37a923d5c35c/" rel="bookmark">
			Vue项目 css下载字体并引入使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.下载字体
下载字体：字体下载,字体大全,免费字体下载,在线字体|字客网字客网是全球知名的字体下载与分享网站,齐全的中文,日文,韩文,英文,图标,美术设计,毛笔,钢笔,手写,书法字体大全,提供找字体,字体识别,字体下载,在线字体预览,字体转换,字体设计等服务。https://www.fontke.com/
下载之后复制里边的.ttf 文件 2.在assets添加一个文件夹text，自定义font.css 和font.ttf文件
3.下载之后复制里边的.ttf 文件更改名字直接替换font.ttf文件
@font-face {
font-family: 'CKTJGZT'; src: url('font.ttf');
font-weight: normal;
font-style: normal;
}
4.入口文件main.ts 文件全局引入 import "./assets/text/font.css";
5、页面中使用 //和css文件中的CKTJGZT保持一致
font-family: 'CKTJGZT'; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5172e5e0a19a4d7cb5a6e2670749b43b/" rel="bookmark">
			使用Github &#43; PicGo搭建个人图床，并使用CDN加速
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言创建仓库配置PicGo如何使用 前言 在写博客的时候，常常需要为博客配图，于是一个好用稳定的图床的重要性不言而喻。本文主要介绍如何使用GitHub + PicGo的方式快速搭建一个个人使用的图床。该方式方便快捷，还免费hh，唯一的不足是图片存放在GitHub公有仓库中，但是应该不会有人在图床里上传私密的图片吧，不会吧。所以这种方法已经满足大部分人的需求了，以下是配置步骤。 创建仓库 在GitHub里创建一个公有仓库，用来存放我们上传的图片。注意，这里的仓库要设置为public，不然怎么进行外部访问呢。(什么？你还没有GitHub账号，赶紧注册一个吧喂)
接下来我们要获取token给到PicGo。
点击setting，进入设置页:
往下划，找到&lt; &gt;Developer settings，点击进入页面:
点击 Personal access tokens，再点 Generate new token 新建 token。
填写下方的notes信息，设置token过期时间，不太建议设置为永久哦，因为不安全。底下复选框的内容repos要全选上，其他的看情况选，我是全选了。
配置完毕后，点击下方的generate token 即可创建完成。记得复制下面的token信息，我们下面需要用到。
配置PicGo 第一步当然是下载PicGo，快捷下载地址：PicGo:一个用于快速上传图片并获取图片 URL 链接的工具
下载后，点击安装。
打开PicGo，在图床设置里，选择GitHub设置。
设定仓库名：填入刚刚创建用来存放图片的仓库名。
设定分支名：就是刚刚仓库的分支名了。
设定token：还记得刚刚忙活后得到的那个token吧。
设定自定义域名：这里使用CDN对图片的访问速度进行加速，这里使用jsDelivr来构建我们的cdn。具体只需要写入https://cdn.jsdelivr.net/gh/ + 仓库名 即可。
如何使用 将图片文件拖到上传区即可上传，也可以复制图片url上传，上传后即可在Github仓库和PicGo相册中看到上传后的图片文件。我们可以在相册中复制外链，粘贴到我们的文章内容里了，到此我们的图床就搭建完成了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/707095496d48254ab031c33c282cbdb1/" rel="bookmark">
			Spring中请求如何映射到达controller具体的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上图中DispatcherServlet的位置是：spring-webmvc依赖包（getHandler、doDispatch等方法都在这里）
SpringMVC的执行流程:
- 用户发送请求至前端控制器DispatcherServlet。 - DispatcherServlet收到请求调用HandlerMapping处理器映射器。 - 处理器映射器找到具体的处理器（controller或者handle）(可以根据xml配置、注解进行查找)，生成 - 处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。 - DispatcherServlet调用HandlerAdapter处理器适配器。 - HandlerAdapter经过适配调用具体的处理器(Controller，也叫后端控制器)。 - Controller执行完成返回ModelAndView。 - HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet。 - DispatcherServlet将ModelAndView传给ViewReslover视图解析器。 - ViewReslover解析后返回具体View。 - DispatcherServlet根据View进行渲染视图（即将模型数据填充至视图中）。 - DispatcherServlet响应用户。 名词解释：
- 前端控制器（DispatcherServlet）：接收请求，响应结果，相当于电脑的CPU。 - 处理器映射器（HandlerMapping）：根据URL去查找处理器 - 处理器（Handler）：（需要程序员去写代码处理逻辑的），即后端控制器用controller表示。 - 处理器适配器（HandlerAdapter）：会把处理器包装成适配器，这样就可以支持多种类型的处理器，类比笔记本的适配器（适配器模式的应用） - 视图解析器（ViewResovler）：进行视图解析，多返回的字符串，进行处理，可以解析成对应的页面 Handle是什么？
Handler是一个Controller的对象和请求方式的组合的一个Object对象 HandleExcutionChains是HandleMapping返回的一个处理执行链，它是对Handle的二次封装，将拦截器关联到一起。然后，在DispatcherServlert中完成了拦截器链对handler的过滤。 DispatcherServlet要将一个请求交给哪个特定的Controller，它需要咨询一个Bean——这个Bean的名字为“HandlerMapping”。HandlerMapping是把一个URL指定到一个Controller上，（就像应用系统的web.xml文件使用&lt;servlet-mapping&gt;将URL映射到servlet）。 在SpringBoot项目中，我们通常在相应的controller中定义我们的方法。
@RestController @RequestMapping("/api/{edition}/page") public class MyPageHelperController { @Autowired private Environment env; @Autowired private PersonConfig personConfig; @GetMapping("/myPage") @ResponseBody public List&lt;String&gt; myPage(Object str) throws IOException { List&lt;String&gt; person= personConfig.getList(str); return person; } } 那么当我们通过postman调用这个方法时，springboot是如何将请求分发到我们相应的方法的呢？下面就来简单的分析下。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/707095496d48254ab031c33c282cbdb1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bcdd6ef6b624ed4ba95f6c6fa3a866b6/" rel="bookmark">
			云计算概述（发展过程、定义、发展阶段、云计算榜单）(一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		云计算概述（一） （发展过程、定义、发展阶段、云计算榜单） 本文目录：
零、00时光宝盒
一、前言
二、云计算的发展过程
三、云计算的定义
四、云计算发展阶段
五、云计算公司榜单看云计算兴衰
六、参考资料
零、00时光宝盒 养在鱼缸里的猫猫鱼 2022年，嫂子捡到3只小奶猫，幼猫，因要去旅游，曾寄养在我家10天。我没有猫笼子，就把猫放在鱼缸里养，我称之为“养在鱼缸里的3只猫猫鱼”。
去年12月初，哥哥告诉我，其中一只猫因病走了。。。
我现在心情平复了，将这只猫猫的点滴记录如下：
2022年8月17日，3只棕色斑点白猫猫来到我家，都很瘦弱，一摸都是骨头，但都很乖。走的这只猫猫体型稍大，我叫它猫大哥哥。一般猫猫都喜欢吃鱼，为增加营养，我喂食时在幼猫猫粮里会拌上2勺金枪鱼鱼块（猫罐头），其他两只猫咪都爱吃，偏偏这只猫猫不喜欢，一闻到就用爪子扒拉着要掩盖猫食，没办法，只好每次用另外一个猫碗装纯幼猫猫粮给它吃。我该说这个小家伙它是挑食呢还是不挑食呢？
它虽然体型稍大，但从不会欺负其他两只小猫猫，嬉闹玩耍时也懂得收其小爪子。它们很活泼，除了在空旷地跑酷，家里柜子缝、沙发底都非要钻进去检查一番。每天晚上睡觉前，我用温水给猫猫擦毛时，它却是最不乖的，不肯乖乖站好总跑，它是想做只小脏猫?
10天时间很短，离开那天清晨，我在厨房，听到“啪”的一声，开始还以为什么东西没放好倒了，直到脚边黏上一个毛茸茸的小暖球才知道这只小猫猫居然自己从鱼缸里跳了出来！（我担心它从那么高跳出来有没有摔伤），我把它放回鱼缸，它却一次次自己跳出来，越跳越熟练，其他两只小猫也想学它跳出来，却多次尝试失败，这只小猫猫是不是有跳高的天分呢？
既然小猫猫不肯在鱼缸里呆着，我干脆把它们放了出来。那天天气很好，阳光从窗户外照进屋子，在地上形成了几个移动的小光斑，这只小猫猫好奇得不得了，追逐着光点边嗅边伸爪子尝试摸索。。。，清晨的阳光带着淡淡的浅黄色，很暖很温和，玩耍中的小白猫很活泼，画面很美。。。可惜我当时手湿没有拿手机拍下来。
我和这只小白猫的缘分只有短短的十天，它不会记得我，但它却会活在我的记忆里。
逆境清醒
2024.1.15
一、前言 “云计算”是近年来信息技术领域被关注比较多的话题之一。但对普通人来说，会有这样一个疑问：“云计算到底是什么东西？能给我带来什么好处？”
实际上，云计算的理论的形成和发展已经有多年历史，从J2EE、.net架构，到“按需计算”（On-demand computing）、“效能计算”（Utility computing）、“软件即服务”（Software as a service）等新理念和模式的出现，其实都可看作是对云计算发展阶段的不同解读方式。
从技术层面讲，“云计算”是一个技术性很强的概念，要想给普通用户解释清楚并非易事。但，在不知不觉中，云计算已经出现在我们日常生活当中，绝大多数人已经在使用它并从中获益。我们每个人的生活都将被云计算逐渐改变，把“云计算“说清楚是很有必要的，因为可以看到，就像互联网一样，云计算已然渗透到人们生活的方方面面，云计算对人们生活的影响将更持久、更彻底。
云计算就是智能生活的技术支撑。
以智能家居为例，智能家居中每一个智能设备都有自己的识别标志，每个设备的数据控制处理都离不开强大的系统后盾支撑，这都得依靠云计算来实现。
云计算是信息技术发展和服务模式创新的集中体现，是信息化发展的重大变革和必然趋势，是信息时代国际竞争的制高点和经济发展新动能的助燃剂。云计算引发了软件开发部署模式的创新，成为承载各类应用的关键基础设施，并为大数据、物联网、人工智能等新兴领域的发展提供基础支撑。云计算能够有效整合各类设计、生产和市场资源，促进产业链上下游的高效对接与协同创新，为“大众创业、万众创新”提供基础平台，已成为推动制造业与互联网融合的关键要素，是推进制造强国、网络强国战略的重要驱动力量。
二、云计算的发展过程 （图：全球云计算发展历程）
云计算前世可以追溯到上世纪80年代和90年代初，最初源于互联网公司对成本的控制，力求尽可能合理利用每一个硬件，最大程度地发挥机器的性能。当时一些科学家和工程师开始研究利用大规模计算资源和高速网络来共享数据和计算能力。然而，由于当时硬件技术和网络基础设施的限制，云计算的发展并不十分成熟。
随着硬件和网络技术的不断进步，云计算在2000年代开始迅速发展。
2006年8月，在圣何塞举办的SES（捜索引擎战略）大会上，时任谷歌（Google）公司首席执行官（CEO）的施密特（Eric Schmidt）在回答一个有关互联网的问题时提出了“云计算”这个概念。
几周后，亚马逊（Amazon）公司推出了Elastic Compute Cloud（EC2）计算云服务，为用户提供弹性计算能力。这被认为是云计算的里程碑事件，也奠定了亚马逊AWS在云计算领域的领先地位。
云计算自此出现，从此之后各种有关“云计算”的概念层出不穷，“云计算”开始流行。
全球云计算发展历程：
2006 年
（此图片来自网络） 2006 年：
♦ 2006 年 8 月 9 日，Google首席执行官埃里克·施密特（Eric Schmidt）在搜索引擎大会（SESSanJose2006）首次提出「云计算」（Cloud Computing）的概念。
♦ 2006年，亚马逊推出了AWS首批云产品Simple Storage Service (S3)和Elastic Compute Cloud（EC2）服务，为用户提供弹性计算能力。这被认为是云计算的里程碑事件，也奠定了亚马逊AWS在云计算领域的领先地位。
（此图片来自网络） 2008年
（此图片来自网络）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bcdd6ef6b624ed4ba95f6c6fa3a866b6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33457940f0746ce943f015d30a01b23d/" rel="bookmark">
			uni-app小程序自定义分享内容
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		小程序默认分享 onLoad(option) { uni.showShareMenu({ menus: ['shareAppMessage', 'shareTimeline'], // 需要显示的转发按钮名称列表.合法值包含 "shareAppMessage"、"shareTimeline" success(res) { console.log(res); }, fail(e) { console.log(e); }, }); }, 自定义分享 用户点击分享按钮的时候会调用。这个分享按钮可能是小程序右上角原生菜单自带的分享按钮，也可能是开发者在页面中放置的分享按钮（&lt;button open-type="share"&gt;）； &lt;button open-type="share"&gt;分享&lt;/button&gt; export default { data() {}, // 分享好友 onShareAppMessage(res) { if (res.form === 'button') { // 自己想分享的内容 } // 默认右上角的 return { }; console.log(res, '====???'); }, // 分享朋友圈 onShareTimeline(res){ 注意：只有定义了此事件处理函数，右上角菜单才会显示“分享到朋友圈”按钮自定义转发内容 用于自定义分享内容，不支持自定义页面路径 } } 自定义的传参
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/197cc55cd34188317c76aff255ede8b4/" rel="bookmark">
			按摩行业的老板想开展上门按摩服务应该做哪些准备
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由于特殊三年的时期，很多实体的按摩店都支撑不下去纷纷往线上转型，那么就按摩行业来说，从线下转为线上做上门按摩的业务应该做哪些准备呢找、shanzhanxia888。
1.市场调研：了解当地市场需求、竞争对手情况以及目标客户群体，以制定适合的营销策略和业务计划。
2.技师招募与培训：找到经验丰富、技术过硬的按摩技师，并提供相关的培训，确保他们能够提供高质量的服务。
3.营销与推广：通过各种渠道宣传和推广上门按摩服务，例如社交媒体、网络广告、传单等，提高品牌知名度和吸引潜在客户。
4.技术准备：开发或购买适合的预约上门按摩系统，用于客户预约、技师排班、订单管理、财务管理等功能。
5.完善服务流程：制定详细的服务流程，包括服务内容、价格、时间等，确保提供优质的服务体验。
6.隐私与安全：确保在提供服务过程中客户隐私和安全得到保障，例如采取适当的保密措施和保护客户信息。
7.合理定价：根据当地市场情况和成本，制定合理的价格策略，确保盈利并吸引客户。
8.建立良好的口碑：通过提供优质的服务和客户满意度，建立良好的口碑和客户关系，提高客户推荐率。
9.法律合规：确保业务运营符合当地法律法规，包括执照和证书的申请等。
其中第四点软件方面，需要找一个靠谱的开发团队或者有已经开发好的上门按摩系统的公司，去上线这个整个业务里核心的东西，用户可以通过手机进行预约下单，对接上线之后就可以开展工作了。并且如果作为能针对于按摩行业开发专业系统的公司来说，对于这个行业一定也是比较了解的，也能提供出一些实际的建议。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5c4d0f2f7316c26d5a69b8bd274c3f5/" rel="bookmark">
			Github Copilot 的使用方法和快捷键
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Github Copilot的安装与激活
首先，你需要在你的计算机上安装GitHub Copilot。安装过程相对简单，只需要访问GitHub Copilot官网，下载并安装最新版本的软件即可。安装完成后，你需要使用GitHub账号进行激活。在激活过程中，你需要同意GitHub Copilot的许可协议，并确保你的GitHub账号拥有足够的权限来使用Copilot。
二、Github Copilot的使用方法
打开代码文件：在安装并激活Github Copilot后，你需要在你的代码编辑器中打开一个代码文件。Copilot将自动检测你代码中的语法错误并提供代码补全建议。代码补全：Github Copilot会根据你正在编写的代码上下文，提供自动补全建议。这些建议包括函数名、变量名和代码片段等。你可以使用键盘上的上下箭头键选择要使用的建议，然后按Enter键将其插入到代码中。语法错误提示：Copilot可以检测代码中的语法错误，并提供有关如何修复错误的提示。这些提示将显示在编辑器的侧边栏中，你可以点击它们以获取更多信息。自动完成语句：Copilot可以根据你正在编写的代码自动完成语句。例如，如果你输入了一个函数调用，Copilot会自动完成该函数的参数列表。快速修复：Copilot可以识别代码中的常见问题，并提供快速修复建议。这些建议可以快速修复代码中的问题，并提高代码质量。学习编程语言：如果你正在学习新的编程语言，Copilot可以帮助你更快地掌握它。它可以根据你编写的代码提供有关该语言的语法和结构的反馈和建议。 三、Github Copilot的快捷键
以下是一些常用的Github Copilot快捷键：
Ctrl + /：注释/取消注释选中的行或当前光标所在的行。Alt + /：显示/隐藏侧边栏中的Copilot建议。Tab：将光标移动到下一个可编辑的位置或自动补全代码。Shift + Tab：将光标移动到上一个可编辑的位置或自动补全代码。Enter：选择并插入Copilot建议。Esc：取消选择当前Copilot建议或退出自动补全模式。Shift + Down/Up：选择下一条/上一条Copilot建议。Shift + Enter：接受当前Copilot建议并向下移动光标。Shift + Tab：显示当前函数的参数列表。Ctrl + Shift + ] / Ctrl + Shift + [：跳转到下一个/上一个代码块。
​ ​四、Github Copilot的注意事项
Copilot不是万能的：虽然Copilot可以提供许多有用的功能，但它并不能替代人类的判断和经验。在编写代码时，你仍然需要仔细考虑代码的逻辑和结构，并进行必要的测试。注意代码风格：Copilot的建议是基于代码的语法和结构，而不是代码风格。在使用Copilot时，你需要确保你的代码风格符合项目的规范和标准。更新依赖关系：Copilot的功能依赖于你的代码中的依赖关系。你需要确保你的项目中包含了所有必要的依赖关系，并及时更新它们以获得最佳的代码补全和语法错误提示效果。关闭自动提交：在使用Copilot时，为了避免将自动生成的代码提交到版本控制系统中，你需要关闭自动提交功能。这样，你就可以手动审查和修改Copilot生成的代码，并确保它们符合项目的需求。注意隐私：虽然Copilot的功能需要在你的计算机上安装一个客户端，但它需要访问你的代码文件和代码编辑器的输入历史记录。你需要确保你的隐私设置正确，并只在你信任的环境中使用Copilot。
​ ​
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a97313746d75dd42a865a7ea9a03983d/" rel="bookmark">
			【rosbag】code
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 record rosbag record -O 20231620-11.bag /drone_0_ego_planner_node/goal_point /ego_planner_node/global_list /drone_0_ego_planner_node/optimal_list /drone_0_ego_planner_node/init_list /drone_0_odom_visualization/path /drone_0_ego_planner_node/grid_map/occupancy_inflate /drone_0_odom_visualization/robot /vins_fusion/path /vins_fusion/odometry /camera/infra1/image_rect_raw /position_cmd /camera/color/image_raw rosbag play rosbag play -r 0.5 xx.bag rosbag play xx.bag rosbag play xx.bag -s 10 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb4216b2c453c049a50e3c64e6ac1c89/" rel="bookmark">
			【Flask 连接数据库，使用Flask-Migrate实现数据库迁移及问题汇总】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Flask 连接数据库，使用Flask-Migrate实现数据库迁移 安装Flask-Migrate插件 pip listall Flask-Migrate # 安装失败使用以下方式安装 pip install –i https://pypi.tuna.tsinghua.edu.cn/simple flask-migrate 使用Flask-Migrate步骤 app.py主要用于数据库连接
from flask import Flask from flask_sqlalchemy import SQLAlchemy app = Flask(__name__) # 连接数据库 app.config['SQLALCHEMY_DATABASE_URI'] = 'mysql+pymysql://root:123456@127.0.0.1:3306/flask_test' app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = True db = SQLAlchemy(app) @app.route('/') def index(): return "Hello!" if __name__ == '__main__': app.run() model.py 中导入了db，作用是存储一个User类，用于生成表头。
# _*_ coding: utf-8 _*_ """ Time: 2024/1/15 9:37 Author: Bana_lv Version: V 0.1 File: model.py """ from app import db class User(db.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cb4216b2c453c049a50e3c64e6ac1c89/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5cc9f29d45da66f55cece8bce3d6a862/" rel="bookmark">
			app开发——安卓主要模块记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在app的开发中，主要涉及的就是页面交互和功能，而安卓开发中，为了实现这几个功能，主要有四大组件和其它的一些功能模块。
activity 页面除了布局的xml文件之外，主要的载体就在activity中，和页面有关的逻辑都在activity组件中实现。比如，点击事件的调用逻辑，获取输入框的输入内容，获取后端数据并显示等。都是通过activity来实现的。
service 安卓开发中的service和web开发中的后端service是不一样的，后端开发中的service主要用来是实现业务逻辑，而安卓中的service是后台服务，因为一些app的功能需要在后台执行，所以有了service的存在。
比如，在音乐播放的app中，如果用activity组件实现，那么在离开这个页面的时候，音乐就无法播放；而在service中实现，那么即使你离开了这个app，它依然会在后台继续执行。
安卓中的service有两种，第一种是单独的service，需要使用startService启动；而另一种service是和activity绑定的，当activity关闭的时候，会解绑service，并进行销毁；这就是生命周期的不同。
fragment fragment是一种在一个页面进行显示切换的一种组件，如果没有fragment，那么所有的页面切换操作都要使用activity来实现，这样会导致执行效率低下。
比如目前很多app在最下面有多个菜单按钮，比如抖音有首页，朋友，我等菜单；如果用activity实现，那么没点击一个菜单就要跳转到一个activity中，这时页面切换到流畅度就可能会有问题。
而使用fragment之后，只需要在同一个activity中，就可以通过切换不同的fragment组件来实现显示内容的切换。
receiver receiver是广播组件，用来在app中实现一些广播与通知；比如，抖音有朋友发布新视频，支付宝有账单通知等，都是通过广播组件来实现的。
广播有静态广播和动态广播，还有系统广播和用户自定义广播等。
content provider 安卓开发中的数据共享组件，其为数据的读取和存储提供了统一的接口。
数据存储 app中需要存储一些用户数据，比如记录登陆状态，用户访问的当前状态等；比如，抖音在没有退出app的情况下，记录用户当前浏览的页面视频数据等。
安卓中的数据存储形式主要有三种，sp，sqlite，room；
sp属于文件存储，使用的是xml文件格式；而sqlite和room数据数据库存储，它们是一种嵌入式的，小巧却功能强大的数据系统。
intent intent是用来在activity，service中进行数据通讯的一种方式，比如activity跳转另一个activity，但是需要携带一些数据，那么就要用到intent类。
第三方sdk
安卓开发中，虽然官方提供了大量的sdk工具，但有些功能需要使用到第三方的sdk，比如地图或者一些其它定制功能；因为自己开发一款app ，不可能自己在建立一个地图数据的采集公司，所以只能使用第三方的地图数据，那么就要使用第三方提供的sdk；
第三方sdk就是用来实现一些安卓官方没有提供的功能，可以让自己的app实现更加强大的功能。
网络模块 app的开发中，难免会出现一些与后端或其它服务进行通讯的能力，所以这时就需要一个支持网络功能的模块。
网络模块，安卓开发中使用最多的就是okhttp，其提供了强大的网络通讯能力，为安卓开发中的网络请求提供了支持。
热更新 热更新功能，是很多app需要的功能，热更新就是在不停止应用的情况下，能够更新app中的功能。比如，炒股的app，或者对数据实时行要求比较高的app，这时关闭app几个小时进行更新，这对用户来说是不可被接受的。所以才有了热更新的功能。
动画 因为app开发涉及到用户交互，而用户交互就可能有动画的需求，所以安卓中提供了多种动画的功能实现。
帧动画，属性动画，补间动画等。
当然，安卓开发中还有其它很多功能模块，不过这些是比较常用的，也是比较常见的功能模块。所以在此记录。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/669ca9e722d3361b0feee280aa13e3c1/" rel="bookmark">
			保姆级-从搭建到发布Quest3-Unity开发流程及问题解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		(持续更新) 开发准备工作 Oculus设备激活 方法1、需要配置一个的wifi，我这里使用的是华硕的路由器。（需要这个教程的话可以给我留言）
方法2、下载Oculus助手的PC应用，它可以形成一个热点供Quest使用，一开始会有免费送的600M（网上有人说500，我用的时候是600），送的流量足够激活使用了,用完的话是需要花钱续费
方法3、使用网易UU加速器，随便加速一个Oculus应用，按照操作步骤链接就好了；
---------------------------------------------------------------------------------------------------------------------------------
软件 1、Oculus PC App：从官网地址下载，点进去就直接下载了，这个软件方便使用Quest link进行串流开发，很方便，Unity引擎直接运行就可以用眼镜来看，不用频繁打包测试 在登陆时，要更改host
找到C盘的的etc文件夹：C:\Windows\System32\drivers\etc，
以文本形式打开hosts文件，并在最下面添加以下内容即可：
157.240.11.49 graph.oculus.com
157.240.11.49 www2.oculus.com
157.240.8.49 scontent.oculuscdn.com
157.240.8.49 securecdn.oculus.com 在hosts添加帖内IP后按WIN+R输入CMD打开命令提示符，运行命令ipconfig /flushdns刷新DNS解析缓存。
其他解决思路
2、Meta Quest Developer Hub for Windows： 从官网地址下载；是一个为开发者提供的平台，用于创建、测试和发布面向 Meta Quest（之前称为 Oculus Quest）头显的虚拟现实（VR）应用和游戏。这个平台提供了一系列的工具和资源，帮助开发者在 Meta Quest VR 系统上开发和优化他们的应用。 3、Unity，这个不多赘述了;Unity ;Unity中国 4、移动端下载 Meta Quest App ---------------------------------------------------------------------------------------------------------------------------------
开发者账号 登录Oculus开发者中心，点击MY APPs，随便先创建一个自己的APP,第三步自己目标是要在哪个设备使用就选哪个 此时就可以在移动端设备设置里，把设备的开发者模式打开了
---------------------------------------------------------------------------------------------------------------------------------
Unity示例工程 这里共享几个帮助你快速学习开发Quest的官方示例工程 Unity-StarterSamples Unity-SharedSpatialAnchors Unity-TheWorldBeyond ---------------------------------------------------------------------------------------------------------------------------------
Unity开发教程 这里我推荐按照官网的教程来，因为SDK和文档会更新，当然有问题可以给我留言 Unity项目设置 Oculus官方教程 创建你得第一个Oculus VR应用 Get Started with Passthrough ---------------------------------------------------------------------------------------------------------------------------------
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/669ca9e722d3361b0feee280aa13e3c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b2dfb106f6e65aaa2300ad71c25583d/" rel="bookmark">
			在Linux上使用PHP-FPM与Nginx实现高效的HTTP处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当谈到高效的HTTP处理时，PHP-FPM（FastCGI进程管理器）与Nginx的结合是许多web开发者的首选。这种组合提供了出色的性能、可扩展性和稳定性，尤其适用于高流量的网站和应用程序。
1. 为什么选择PHP-FPM与Nginx？ 性能优化：PHP-FPM通过进程管理和缓存机制，显著提高了PHP脚本的执行效率。资源隔离：每个PHP进程独立运行，降低了资源争用和潜在的冲突。与Nginx的集成：Nginx是一个高性能的HTTP和反向代理服务器，与PHP-FPM结合使用，可以提供快速、稳定的请求处理。 2. 安装与配置 安装PHP-FPM:
根据你的Linux发行版，使用适当的包管理器安装PHP-FPM。例如，在Debian/Ubuntu上：
bash复制代码
sudo apt-get update sudo apt-get install php-fpm
配置PHP-FPM:
编辑/etc/php/fpm/php.ini，根据需要进行配置调整，如内存限制、执行时间等。
安装Nginx:
同样使用包管理器进行安装：
bash复制代码
sudo apt-get install nginx
配置Nginx:
编辑Nginx的配置文件（通常位于/etc/nginx/nginx.conf或/etc/nginx/conf.d/default.conf）。你需要指定FastCGI的监听地址和端口，并配置一个或多个server块来处理PHP请求。一个基本的配置示例如下：
nginx复制代码
server { listen 80; server_name example.com; root /var/www/html; index index.php index.html index.htm; location / { try_files $uri $uri/ =404; } location ~ \.php$ { fastcgi_pass unix:/var/run/php/php7.4-fpm.sock; # 根据你的PHP-FPM版本调整路径和端口号 fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include fastcgi_params; } }
重启服务:
一旦完成配置文件的更改，重启Nginx和PHP-FPM服务以使更改生效：
bash复制代码
sudo systemctl restart nginx php-fpm
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4b2dfb106f6e65aaa2300ad71c25583d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39d8c89879a04b03a4a7b306ba7dc734/" rel="bookmark">
			Mac查看以太网信息，IP地址，查看配置桥接网络，使得虚拟机和本机ping通--linux系统part
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本机：macOS14.2.1
虚拟机：VMware Fusion pro 13.0.0+CentOS8
1-打开设置，选择网络
2-点击详细信息
3-查看IP为192.168.1.244，还可以看到一些具体信息，如TCP/IP，DNS等；
1-使用桥接网络
打开虚拟机设置-点击网络适配器-选择桥接网络
2-打开centos，进入管理员root模式（使用su命令加上输入管理员密码）
然后使用ifconfig命令查看端口地址，如下所示为192.168.1.248
3-在虚拟机内使用ping命令，测试是否和网络连通，如下图所示已经ping通
4. 在本机的终端中使用ping命令，查看是否能够ping通虚拟机系统，如下图所示已经ping通
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94a7b1ef889c9481dbb761ddf26cfb38/" rel="bookmark">
			测试学习——答疑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、什么是软件测试？ 一个产品质量好，用户的使用感受佳，用户才愿意为此付费，这样企业才会获取收益，如果一个产品bug太多的话，那用户就不会买账。所以软件测试就是对产品进行测试，提高测试质量，同时提高收益。
概念：软件测试就是验证软件产品特性是否满足用户需求。
2、调试和测试的区别？ 目的不同： 调试：发现问题并且解决问题
测试：发现问题（测试没有开发业务代码的权限）
角色不同： 调试：开发人员来执行
测试：测试人员、开发人员
（开发人员不只是编写业务代码，也要进行单元测试，因为单元测试是对一小块代码进行测试，只有开发人员最熟悉代码，所以需要开发人员来进行单元测试）
阶段不同 调试：主要在编码阶段
测试：测试贯穿软件的整个生命周期（执行测试是在编码之后）
3、走测试岗位为什么还要学习开发知识？ 学好开发知识能够提高测试质量：测试人员也需要进行代码编写，如自动化测试、性能测试、效率工具等等。测试人员能够看懂代码，了解框架，代码中数据的走向能更好的从代码层面去发现问题。（例：双十一当天的优惠活动，在11.11，00:00:00开始生效，在11.12，00:00:00开始失效，代码 11.11 00:00:00 &lt;= timeRange &lt; 11.12 00:00:00,这种情况只能了解代码之后才能进行相关测试）
或者：为什么不走开发岗位而是走测试岗位？
个人的兴趣爱好对测试的理解为什么走测试还需要学习那么多开发知识？（为了提高测试质量） 4、软件测试工程师和测试开发工程师的区别？（首先主要职责都是保障产品质量） 软件测试工程师：主要工作一般包含：需求分析、编写测试计划和测试方案、设计测试用例、执行测试用例、跟踪bug、编写测试用例报告等。
测试开发工程师：以测试为主，开发效率提升工具为辅。根据项目的特点来开发一些自动化测试的脚本，或者自动化测试工具，或者是软件测试工作中用到的提高工作效率的小工具从而更有效地进行测试，提高软件产品的质量。
5、测试人员需要具备哪些素质（你选择测试方向的优势）？ 综合能力：
表达能力（什么岗位都重要）
文字能力（编写测试用例、提交bug、编写测试报告）
开发能力（开发能力掌握的越好能够更好地协助提高测试质量~）
快速学习能力（可能找到的工作和自己学的语言不一样，得快速学习）
优秀的测试用例设计能力：
测试用例是测试人员执行测试工作的重要依据。
掌握自动化测试技术：
中大厂企业里面必不可少的。
探索性思维、兴趣、责任感和压力
6、测试和开发的区别？ 测试的广度大深度低，开发的广度小深度高。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87176c4959939fdd5433cc159f3636df/" rel="bookmark">
			P2615 [NOIP2015 提高组] 神奇的幻方————C&#43;&#43;
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 [NOIP2015 提高组] 神奇的幻方题目背景题目描述输入格式输出格式样例 #1样例输入 #1样例输出 #1 样例 #2样例输入 #2样例输出 #2 提示 解题思路Code运行结果 [NOIP2015 提高组] 神奇的幻方 题目背景 NOIp2015 提高组 Day1T1
题目描述 幻方是一种很神奇的 N × N N\times N N×N 矩阵：它由数字 1 , 2 , 3 , ⋯ ⋯ , N × N 1,2,3,\cdots \cdots ,N \times N 1,2,3,⋯⋯,N×N 构成，且每行、每列及两条对角线上的数字之和都相同。
当 N N N 为奇数时，我们可以通过下方法构建一个幻方：
首先将 1 1 1 写在第一行的中间。
之后，按如下方式从小到大依次填写每个数 K ( K = 2 , 3 , ⋯ , N × N ) K \ (K=2,3,\cdots,N \times N) K (K=2,3,⋯,N×N) ：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/87176c4959939fdd5433cc159f3636df/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5356bbd89804f8f7b575f2dc09e2b7c/" rel="bookmark">
			arcgis javascript api4.x加载天地图wgs84（wkid：4326）坐标系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需求： 使用arcgis javascript api4.x以basetilelayer方式加载天地图wgs84（wkid：4326）坐标系
效果：
代码： 提示：（下述三个文件放同一个文件夹下）
4326.js
define(['exports', 'esri/layers/support/TileInfo', 'esri/config'], function ( exports, TileInfo, esriConfig ) { 'use strict' const lods = [ { level: 1, levelValue: 1, resolution: 0.703125, scale: 295497593.05875003 }, { level: 2, levelValue: 2, resolution: 0.3515625, scale: 147748796.52937502 }, { level: 3, levelValue: 3, resolution: 0.17578125, scale: 73874398.264687508 }, { level: 4, levelValue: 4, resolution: 0.087890625, scale: 36937199.132343754 }, { level: 5, levelValue: 5, resolution: 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b5356bbd89804f8f7b575f2dc09e2b7c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70adc37a446820b7f9e936eee136382a/" rel="bookmark">
			sklearn实现支持向量机(异常检测)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		💥 项目专栏：sklearn实现经典机器学习算法(附代码+原理介绍)
文章目录 前言一、算法背景1. 算法背景：基本原理：核函数： 2. 异常检测：决策函数：超参数： 3. 算法优势与局限性：优势：局限性： 4. 应用场景：5. 实践中的考虑： 二、算法原理1. 基本概念：2. 数据映射：3. 目标函数和优化：4. 核函数：5. 参数选择：6. 异常检测：7. 应用和局限性：8. 算法原理的数学表达：9. 实际应用注意事项： 三、算法实现3.1 导包3.2 加载数据集3.3 定义模型1. 鲁棒协方差 (EllipticEnvelope)2. 单类SVM (OneClassSVM)3. 单类SVM (SGD)4. 隔离森林 (IsolationForest)5. 局部异常因子 (LocalOutlierFactor) 3.4 可视化异常检测算法 完整源码 前言 🌟 哈喽，亲爱的小伙伴们，你们知道吗？最近我们的粉丝群里有好多小可爱私信问我一些关于决策树、逻辑回归等机器学习的超级有趣的问题呢！🌈 为了让大家更轻松地理解，我决定开一个超可爱的专栏，叫做 用sklearn玩转机器学习，特别适合机器学习的小新手哦！
🍬 在这个专栏里，我们会用sklearn这个超级强大的魔法工具来实现各种闪闪发光的机器学习算法！不用担心难度哦，我会用最简单、最可爱的方式，带领大家一起探索算法的神秘世界！✨
🎈 适合哪些小伙伴加入呢？当然是对机器学习感兴趣的小新手们，还有那些刚开始接触sklearn的可爱宝宝们！我们会一起学习如何用sklearn轻松实现那些看起来好厉害的机器学习算法，让新手小白也能快快乐乐地理解它们哦！
🌸 在这个专栏里，大家可以看到用sklearn实现的机器学习算法，我们不仅仅是理论学习哦，每一篇文章都会附带 完整的代码+超级可爱的原理讲解，让大家在轻松愉快的氛围中一起学习成长呢！🌼 快来加入我们的学习大冒险吧！
🚨 我的项目环境：
平台：Windows11语言环境：Python 3.10编译器：Jupyter Lab、PyCharmscikit-learn：1.2.1Pandas：1.3.5Numpy：1.19.3Scipy：1.7.3Matplotlib：3.1.3 💥 项目专栏：sklearn实现经典机器学习算法(附代码+原理介绍)
一、算法背景 支持向量机（SVM）在异常检测领域的应用主要是通过一种特殊形式的SVM实现的，即单类支持向量机（One-Class SVM）。这种方法的核心思想是基于数据集找出一个决策边界，这个边界尽可能地包含所有正常数据点（inliers），同时排除异常数据点（outliers）。下面是One-Class SVM在异常检测中应用的一些关键点：
1. 算法背景： 基本原理： 单类分类：与传统的SVM不同，One-Class SVM专注于单一类别的数据。它的目标是找到一个最佳边界，这个边界围绕着数据空间中的正常点，而将异常点排除在外。特征空间映射：One-Class SVM利用核技巧将数据映射到高维特征空间，在这个空间中寻找最优的边界来分隔正常点和异常点。 核函数： 核函数用于处理非线性可分的数据。常见的核函数包括线性核、多项式核、径向基函数（RBF）核等。核函数的选择对算法的性能有显著影响。 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/70adc37a446820b7f9e936eee136382a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3b868ae60aa33bc4d9ed01617e31397/" rel="bookmark">
			北京程序员年薪中位数超 60 万元，2023 全球程序员收入报告出炉
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		整理 | 郑丽媛
出品 | CSDN（ID：CSDNnews）
刚刚过去的 2023 年，被许多人称作“AI 元年”，而实际上不仅是 AI，区块链、大数据、云计算等技术领域也在不断推进创新，其背后程序员的技能和洞察力成为了企业成功不可或缺的一部分。
在这样的动态发展下，程序员的收入水平也呈现出了多样化趋势：于是 2024 年伊始，知名数据收集网站 Levels.fyi 最新发布了一份《2023 年全球程序员收入报告》，深刻解读全球技术人才的市场动态。
北京程序员，年薪中位数超 60 万元
与 2022 年相比，2023 年大多数职位的薪酬中位数都有所增加——除了产品设计师和软件工程师。 过去一年中，技术项目经理的薪酬涨幅最大（3.2%），从 21.5 万美元增至 22.2 万美元，其次是软件工程经理，薪酬涨幅为 2.16%。反观产品设计师和软件工程师，其年薪中位数都有不同程度的下滑，分别下滑了 0.26% 和 0.57%。
除了根据职位观察程序员的收入水平，Levels.fyi 还根据地域不同，对美国、欧洲和全球程序员的年薪中位数进行了排名：
（1）全球热门城市
从全球范围看，程序员收入最高的城市 Top 3 是：以色列特拉维夫（13.7 万美元），加拿大温哥华（11.5 万美元）和澳大利亚悉尼（11 万美元）。其中，中国北京的程序员收入也较高，薪资中位数为 9 万美元（约人民币 64.4万元），位居榜单第六，相较于 2022 年的 7.9 万美元有了较大幅度的提升。
（2）美国热门城市
在美国范围内，程序员收入最高的地区是旧金山湾区（24.9 万美元）、西雅图地区（22.5 万美元）和纽约市地区（18.5 万美元），基本与 2022 年的榜单排名一致。
（3）欧洲热门城市
在欧洲程序员收入最高的城市中，瑞士苏黎世以 18 万美元的年薪中位数稳居第一，其次瑞士洛桑和英国伦敦分别以 12.7 万美元和 11.7 万美元的收入位于第二和第三位。
OpenAI 冲进第一，谷歌和微软已连续两年没有上榜
除了受地域因素影响，程序员的收入水平很大程度取决于其职级的不同。为此，Levels.fyi 根据工程师岗位级别，将程序员分为五个等级：初级工程师，中级工程师，高级工程师，主管工程师以及首席工程师，以此来对比各个级别之间的收入差距。 （1）初级工程师 初级工程师的工作经验通常低于 2 年，多是应届毕业生或几乎没有相关行业经验。一般这类工程师需要更有经验的团队成员的指导，在团队中负责开发和维护复杂度较低的组件。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e3b868ae60aa33bc4d9ed01617e31397/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3efe10e511f5eadaad0cec86e5ea6c95/" rel="bookmark">
			数据仓库（3）-模型建设
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文从以下9个内容，介绍数据参考模型建设相关内容。
1、OLTP VS OLAP OLTP：全称OnLine Transaction Processing，中文名联机事务处理系统，主要是执行基本日常的事务处理，比如数据库记录的增删查改,例如mysql、oracle
OLAP：全称OnLine Analytical Processing，中文名联机分析处理系统，支持复杂的分析操作，侧重决策支持，并且提供直观易懂的查询结果,例如、ClickHouse、Doris、Kylin
两者比较结果可见如下
2、数仓分层 通常我们吧数据分成4层，ODS、DWD、DWS、ADS。有时候业务在DWD和DWS中间放置一层轻度汇总层用于过渡。
3、数仓数据建模 什么是数据模型：数据特征的抽象，通常包括数据结构、数据操作、数据约束。
4、数据建模方法 数据建模方式很多，数据仓种最常见的是两种，维度建模和三范式建模（也叫实体关系建模）。以下详细介绍
5、数据建模流程 模型设计基本原则
维度建模设计大图
模型建设流程（详细）
总线矩阵
指以一致性维度为列，以业务过程为行，构建业务的数据矩阵，通过标记表示该维度与业务过程的相关性。网上找了张图：
模型建设5要素
模型设计中核心要考量的要素为5项：主题域 、事实表设计、维表设计、确认颗粒度、明确度量值。
未完待更新
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8847da6b9966e66d1c5c331ffda9f50/" rel="bookmark">
			方差分析（F检验）用于特征选择的Python实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方差分析（F检验）又称ANOVA，方差齐性检验，是一种用来捕捉每个特征变量与响应变量之间线性关系的过滤方法，实现路径是针对两个及两个以上分组的样本均值进行差异显著性检验，基本思想是将不同分组的样本均值之间的差异归结于两个方面：一是组间差异，也就是不同分组之间的均值差异，用变量在各组的均值与总均值的偏差平方和的总和表示，记为SSA，如果有r个分组，则其自由度为r-1；二是组内差异，也就是同一分组内部样本之间的差异，用变量在各组的均值与该组内变量值的偏差平方和的总和表示，记为SSE，如果有一共n个样本、r个分组，则其自由度为n-r。
基于上述思想可以构建起F统计量：
可以发现F值越大，则说明组间差异越大，也就是说据此把样本进行分类是有意义的。因此，我们在机器学习特征选择时也可以基于这一标准，即F值越大，特征的作用就越大，就越倾向于被选择用来预测或分类。F检验可以用于分类问题的特征选择，也可以用于回归问题的特征选择。
在Python实现方面，当响应变量为离散型变量时，为分类问题，应使用feature_selection.f_classif（F检验分类）；当响应变量为连续型变量时，为回归问题，应使用feature_selection.f_regression（F检验回归）。F检验在数据服从正态分布时效果稳定，使用F检验过滤特征，最好将数据转化为服从正态分布。
在使用feature_selection.f_classif（F检验分类）或feature_selection.f_regression（F检验回归）时，会返回F值和P值两个统计量。其中特征变量的F值越大，就越倾向于选择该特征变量；而P值则是与F值相对应的统计量，特征变量的P值越小，就越倾向于选择该特征变量，P值的参照标准一般为0.05。
方差分析（F检验）的Python代码示例如下：
运行结果如图所示。
其中上面的array数组为各个特征变量的F统计量值，下面的array数组为各个特征变量的P统计量值，可以发现所有特征变量的P值都小于0.05，都是比较显著的。我们可以根据这一原则来过滤特征变量，也可以与前面介绍的卡方检验类似，用SelectKBest()挑选F值最大的前N个变量：
运行结果为：
，可以发现第3个、第6个、第7个特征变量的F值是最大的。
X.columns# 查看特征变量集的各列名称
运行结果为：Index(['age', 'education', 'workyears', 'resideyears', 'income', 'debtratio', 'creditdebt', 'otherdebt'],dtype='object')。可以发现第3个、第6个、第7个特征变量分别为workyears、debtratio、creditdebt。
运行结果如图所示。
上述内容节选自《Python数据科学应用从入门到精通》（张甜 杨维忠 著 2023年11月新书 清华大学出版社）。
针对数据分析或机器学习推荐两本入门级的图书：《Python机器学习原理与算法实现》（杨维忠 张甜 著 2023年2月新书 清华大学出版社）《Python数据科学应用从入门到精通》（张甜 杨维忠 著 2023年11月新书 清华大学出版社）。这两本书的特色是在数据分析、机器学习各种算法的介绍方面通俗易懂，较少涉及数学推导，对数学基础要求相对不高，在python代码方面讲的很细致，看了以后根据自身需要选取算法、优化代码、科学调参。都有配套免费提供的源代码、数据文件和视频讲解，也有PPT、思维导图、习题等。
为什么说这两本书值得？首先说《Python机器学习原理与算法实现》（杨维忠 张甜 著 2023年2月新书 清华大学出版社），内容非常详实，包含了Python和机器学习，相当于一次获得了两本书。在讲解各类机器学习算法时，逐一详解用到的各种Python代码，针对每行代码均有恰当注释（这一点基本上是大多数书目做不到的）。这本书在出版之前曾开发成9次系列课程，在某股份制银行全行范围类开展培训，490人跟随杨维忠老师上课学习（课程限报490人），培训完成后课程在知鸟平台上回放超过3万人次。很多银行员工通过这些学习一下子就学会了Python，并且用于工作中开展数据分析、机器学习、数据可视化等，这本书也被多家商业银行选做数字化人才培训教材，成为银行员工的一本网红书。
《Python数据科学应用从入门到精通》一书，旨在教会读者实现全流程的数据分析，并且相对《Python机器学习原理与算法实现》一书增加了很多概念性、科普性的内容，进一步降低了学习难度。国务院发展研究中心创新发展研究部第二研究室主任杨超 ，山东大学经济学院金融系党支部书记、副主任、副教授、硕士生导师张博，山东管理学院信息工程学院院长 袁锋 教授、硕士生导师，山东大学经济学院刘一鸣副研究员、硕士生导师，得厚投资合伙人张伟民等一众大牛联袂推荐。书中全是干活，买这一本书相当于一下子得到了5本书（Python基础、数据清洗、特征工程、数据可视化、数据挖掘与建模），而且入门超级简单，不需要编程基础，也不需要过多数学推导，非常适用于零基础学生。全书内容共分13章。其中第1章为数据科学应用概述，第2章讲解Python的入门基础知识，第3章讲解数据清洗。第4~6章介绍特征工程，包括特征选择、特征处理、特征提取。第7章介绍数据可视化。第8~13章介绍6种数据挖掘与建模方法，分别为线性回归、Logistic回归、决策树、随机森林、神经网络、RFM分析。从数据科学应用和Python的入门，再到数据清洗与特征工程，最终完成数据挖掘与建模或数据可视化，从而可以为读者提供“从拿到数据开始，一直到构建形成最终模型或可视化报告成果”的一站式、全流程指导。
两本书随书赠送的学习资料也很多，包括全部的源代码、PPT、思维导图，还有10小时以上的讲解视频，每一章后面还有练习题及参考答案，还有学习群，相对于只看网络上的视频，一方面更加系统、高效，另一方面照着书一步步操作学起来也事半功倍。全网热销中，当当、京东等平台搜索“Python机器学习 杨维忠”“Python数据科学 杨维忠”即可。
《Python机器学习原理与算法实现》（杨维忠、张甜著，2023年2月，清华大学出版社），适用于学习Python/机器学习
《Python数据科学应用从入门到精通》（张甜 杨维忠 著 2023年11月新书 清华大学出版社）适用于学习数据分析、数据科学、数据可视化等。
创作不易，恳请多多点赞，感谢您的支持！也期待大家多多关注我，让我共同学习数据分析知识。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a75f9e3b5a1582ea423c96e0a4df3fe2/" rel="bookmark">
			2.IHRM人力资源 - 登录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、登录页结构与表单开发 我们要实现的登录界面
目前的登录界面
1.1 登录页结构 复制下面的代码到views/login/index.vue页面下
&lt;template&gt; &lt;div class="login-container"&gt; &lt;div class="logo"/&gt; &lt;div class="form"&gt; &lt;h1&gt;登录&lt;/h1&gt; &lt;el-card shadow="never" class="login-card"&gt; &lt;!--登录表单--&gt; &lt;/el-card&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name: 'Login' } &lt;/script&gt; &lt;style lang="scss"&gt; .login-container { display: flex; align-items: stretch; height: 100vh; .logo { flex: 3; background: rgba(38, 72, 176) url(../../assets/common/login_back.png) no-repeat center / cover; border-top-right-radius: 60px; display: flex; flex-direction: column; align-items: flex-end; justify-content: center; padding: 0 100px; .icon { background: url(.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a75f9e3b5a1582ea423c96e0a4df3fe2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bceda0df308bc4ccadeb08f862764f19/" rel="bookmark">
			【UnityShader入门精要学习笔记】第四章（5）坐标空间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本系列为作者学习UnityShader入门精要而作的笔记，内容将包括：
书本中句子照抄 + 个人批注项目源码一堆新手会犯的错误潜在的太监断更，有始无终 总之适用于同样开始学习Shader的同学们进行有取舍的参考。
文章目录 复习知识点复习什么是变换齐次坐标分解基础变换矩阵平移矩阵缩放矩阵旋转矩阵复合变换 练习题答案 坐标空间为什么使用这么多不同的坐标空间？坐标空间的转换顶点的坐标空间变换模型空间世界空间观察空间裁剪空间正交投影透视投影举个例子屏幕空间 MVP变换 （该系列笔记中大多数都会复习前文的知识，特别是前文知识非常重要的时候，这是为了巩固记忆，诸位可以直接通过目录跳转）
复习 知识点复习 什么是变换 变换（transform），指的是我们将一些数据，如点、方向向量甚至是颜色等，通过某种方式进行转换的过程。
什么是线性变换（Linear transform），线性变换指的是那些可以保留向量加和标量乘的变换，用公式来表示就是：
f ( x ) + f ( y ) = f ( x + y ) k f ( x ) = f ( k x ) f(x)+f(y)=f(x+y)\newline kf(x)=f(kx) f(x)+f(y)=f(x+y)kf(x)=f(kx)
所以变换本质上是对函数花里胡哨的另一种表示，我们可以简单的理解为一种函数，也就是：
x → f ( x ) → y x\to f(x) \to y x→f(x)→y，向量x经过变换 f ( x ) f(x) f(x)变为向量y。
原点不变，网格平行，单元格大小一致，这样的变换才叫做线性变换。
实质上，线性变换可以视为我们对基向量的变换，对基向量的变换会应用到整个张成空间上。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bceda0df308bc4ccadeb08f862764f19/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51c080fe9d22fb8528998f36294191ef/" rel="bookmark">
			3D模型格式转换工具HOOPS Exchange如何获取模型的特征树？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Tech Soft 3D致力于用无与伦比的技术推动创新，并很高兴为Oracle、SIEMENS、Hexagon Matrology和Stratasist，提供用最快、最准确的数据转换工具包获取CAD数据。
HOOPS Exchange允许开发团队轻松构建，通过单一接口将CAD数据转换为30多种文件格式的应用程序，支持的格式包括Catia、SolidWorks、CREO、AutoDesk inventor、STEP、SIEMENS NX等，还支持访问广泛的数据，包括以其原生形式的B-REP、视觉、语义PMI、可视化视图和构造几何。 HOOPS Exchange提供了广泛的装配结构支持，包括配置和族表。
它还提供对用ID，样式、颜色、材料和其他元数据的访问，它具有特征树支持，包括完整的定义和模式。这些都不用依赖任何CAD系统，可以让您的用户随时随地访问它们的数据，不管你是需要在桌面上运行Windows，Linux，MacOs还是Android，IOS，移动设备，甚至云端服务器访问。
本文将详细介绍，3D模型格式转换工具HOOPS Exchange是如何获取模型的特征树的。
​
申请HOOPS Exchange试用http://x7pfmmn259623uby.mikecrm.com/l9292M9
一、什么是特征树？ 特征树是在CAD系统中创建零件所采取的所有步骤。例如：
1）选择草图并定义挤出，构成一个模型实体；
2）选择该模型的一条边，然后以这条边为基础，创建圆角；
3）在该模型上打一个孔。
在这创建模型的过程，通常使用树结构来描述这些特征，树结构的层次结构可以有效的表示特征的依赖关系，例如：
挤压是在草图（另一个特征）之上构建的特征。 阵列可以是一个可以基于孔（另一个特征）的特征。 定义孔螺纹时，首先定义一个孔特征，然后在子对象中定义螺纹特征。 使用HOOPS Exchange，我们可以读取CATIA V5、Creo、NX 和 SolidWorks文件的特征树，并从特征树中获取到如下特征的所有参数：
孔(Holes) 阵列(Patterns) 挤出(Extrusion) 旋转(Revolutions) 圆角和倒角(Fillets &amp; chamfers) 这些信息对于优化下游流程（包括分析、制造和计量）特别有用，在了解特征树的基本信息之后，我们首先要知道如读取这些信息。
二、读取特征树 要读取模型中的特征信息，需要在导入模型之前将 m_bReadFeature属性设置为true，因为在默认情况下，HOOPS Exchange不会从 CAD 模型中读取特征。
​
设置m_bReadFeature后，在导入模型时，导入器将读取模型的特征信息。
接下来，我们可以从A3DAsmProductOccurrenceData中获得特征树的具体信息，其数据结构为A3DFRMFeatureTreeData：
​
​
三、特征树在PRC中的数据结构 在获取到特征树对象后，我们需要解析其具体的数据结构，特征树在PRC文件中的数据结构如下：
​
在A3DFRMFeatureTreeData数据结构中，有三个独立的表示项阵列，用于存储关于三种几何类型的信息：
1）最终几何。
2）中间几何。
3）内部几何。
其定义如下：
最终几何表示在打开CAD文件时在3D场景中显示的内容。
中间几何表示实体结构中某个阶段存在的实体。例如，下面的图片中的蓝色loop可能仅在创建倒角（右图）之前的中间阶段存在。因此，它被存储在表示项的中间几何数组中。
​
内部几何表示在给定特征的上下文中创建的东西。例如，轴可以在定义挤压时被创建。在这种情况下，它将存储在表示项内部几何数组中。
除了上述数组之外，A3DFRMFeatureTreeData数据结构中还有另一个数组，称为m_ppsParameters，它包含A3DFRMParameter元素，用于存储实际的特征树和特征信息。
为了描述特征树，我们递归特征参数的结构。A3DFRMParameter包含A3DFRMFeature元素数组， A3DFRMFeature包含A3DFRMParameter元素数组。
​
我们举一个示例特征（三点定义一个平面），该特征可以在Catia、NX或Creo中使用三个点进行定义。以下截图为该特征在Catia、NX或Creo中模型树截图：
​
该平面在HOOPS Exchange中特征树结构如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/51c080fe9d22fb8528998f36294191ef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77d240b946125a0fe2dac06113979fbf/" rel="bookmark">
			【数据结构 】哈夫曼编译码器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据结构-----哈夫曼编译码器 题目题目描述基本要求算法分析 代码实现初始化编码解码打印代码打印哈夫曼树 总结 题目 题目描述 利用哈夫曼编码进行信息通信可大大提高信道利用率，缩短信息传输时间，降低传输成本。
要求：在发送端通过一个编码系统对待传数据预先编码；在接收端将传入的数据进行译码（复原）。对于双工信道(即可以双向传输信息的信道)，每端都需要个完整的编/译码系统。试为这样的信息收发站写一个哈夫曼的编/译码系统。 基本要求 基本要求
系统应具有以下功能：
① I:初始化.从终端读入字符集大小n及n个字符和n个权值，建立哈夫曼树，井将它存于文件HuffmanTree中。
② C:编码。利用已建立好的哈夫曼树（如不在内存，则从文件HuffmanTree中读入）。对文件tobetrans中的正文进行编码，然后将结果存入文件codefile中。
③ D:解码。利用已建立好的哈夫曼树将文件codefile中的代码进行译码，结果存入testfile中。
④ P：打印代码文件。将文件codefile以紧凑格式显示在终端上，每行50个代码。同时将此字符形式的编码文件写入文件codeprint中。
⑤ T：打印哈夫曼树。将已在内存中的哈夫曼树直观的方式（树或凹入表形式）显示在终端上，同时将此字符形式的哈夫曼树写入文件treeprint中。 算法分析 本题例主要用到3个算法如下：
① 哈夫曼编码。在初始化(I)的过程中，要用输入的字符和权值建立哈夫曼树并求得哈夫曼编码。先将输入的字符和权值放到一个结构体数据中，建立哈夫曼树，将计算所得的哈夫曼编码存储到另一个结构体数组中。
② 串的匹配。在解码(D)的过程中，要对已经编码过的代码进行译码，可利用循环，将代码中与哈夫曼编码长度相同的串与这个哈夫曼编码进行比较，如果相等就回显并存入文件。
③二叉树的遍历。在打印哈夫曼树(T)的过程中，因为哈夫曼树也是二叉树，所以就要利用二叉树的前序遍历将哈夫曼树输出。 代码实现 代码部分参考了《数据结构-C语言版第2版》这本书中代码以及C++风格进行书写，测试文件tobetrans中的内容为"ABCABC"
初始化 题目要求从终端读入字符集大小n及n个字符和n个权值，建立哈夫曼树，并将它存于文件HuffmanTree中，可以先将哈夫曼树构建起来，得到哈夫曼树及其对应叶子节点的编码，再通过文件的输入输出将这些编码写入文件HuffmanTree中即可
构造哈夫曼树 /*找出森林集合中根权值最小的两个*/ void Select(HuffmanTree HT,int len,int &amp;s1,int &amp;s2) { int i,min1=0x3f3f3f3f,min2=0x3f3f3f3f;//先赋予最大值 for(i=1;i&lt;=len;i++) { if(HT[i].weight&lt;min1&amp;&amp;HT[i].parent==0) { min1=HT[i].weight; s1=i; }	} int temp=HT[s1].weight;//将原值存放起来，然后先赋予最大值，防止s1被重复选择 HT[s1].weight=0x3f3f3f3f; for(i=1;i&lt;=len;i++) { if(HT[i].weight&lt;min2&amp;&amp;HT[i].parent==0) { min2=HT[i].weight; s2=i; } } HT[s1].weight=temp;//恢复原来的值 } /*构建哈夫曼树*/ void CreatHuffmanTree(HuffmanTree &amp;HT,int n) { //构造赫夫曼树HT int m,s1,s2,i; if(n&lt;=1) return; m=2*n-1; HT=new HTNode[m+1]; //0号单元未用，所以需要动态分配m+1个单元，HT[m]表示根结点 for(i=1;i&lt;=m;++i) //将1~m号单元中的双亲、左孩子，右孩子的下标都初始化为0 { HT[i].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/77d240b946125a0fe2dac06113979fbf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/790e3117142b8a1ae1003653971815f2/" rel="bookmark">
			Centos下，使用NFS实现目录共享/网络驱动器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux系统下，也可以像windows一样通过目录共享实现网络驱动器模式访问。具体操作步骤如下：
一、服务端：
1、确认下服务端系统是否已安装 NFS
rpm -qa nfs-utils rpcbind
如果没有，安装 NFS 服务
yum install -y nfs-utils rpcbind
2、创建共享目录
mkdir -p /data/share
chmod 666 /data/share
3、修改 NFS 配置文件
vim /etc/exports
/data/share 192.168.8.*/24(rw,sync,insecure,no_subtree_check,no_root_squash)
4、启动 RPC 服务
systemctl start rpcbind.service
5、启动 NFS 服务
systemctl start nfs.service
查看 NFS 服务项
rpcinfo -p localhost
显示共享目录信息
exportfs -v
二、客户端：
1、安装NFS客户端组件
yum install -y nfs-utils
2、创建挂载目录：
mkdir -p /.../share
（假设服务器为192.168.8.172）
mount 192.168.8.172:/data/share /.../share
另外，tcp协议挂载更稳定：
mount 192.168.8.172:/data/share /.../share -o proto=tcp -o nolock
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/790e3117142b8a1ae1003653971815f2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02e9ec21538190c6d44784ea581d30bb/" rel="bookmark">
			【计算机二级考试C语言】C变量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C 变量 变量其实只不过是程序可操作的存储区的名称。C 中每个变量都有特定的类型，类型决定了变量存储的大小和布局，该范围内的值都可以存储在内存中，运算符可应用于变量上。
变量的名称可以由字母、数字和下划线字符组成。它必须以字母或下划线开头。大写字母和小写字母是不同的，因为 C 是大小写敏感的。基于前一章讲解的基本类型，有以下几种基本的变量类型：
类型描述char通常是一个字节（八位）, 这是一个整数类型。int整型，4 个字节，取值范围 -2147483648 到 2147483647。float 单精度浮点值。单精度是这样的格式，1位符号，8位指数，23位小数。
double 双精度浮点值。双精度是1位符号，11位指数，52位小数。
void表示类型的缺失。 C 语言也允许定义各种其他类型的变量，比如枚举、指针、数组、结构、共用体等等，这将会在后续的章节中进行讲解，本章节我们先讲解基本变量类型。
C 中的变量定义 变量定义就是告诉编译器在何处创建变量的存储，以及如何创建变量的存储。变量定义指定一个数据类型，并包含了该类型的一个或多个变量的列表，如下所示：
type variable_list; type 表示变量的数据类型，可以是整型、浮点型、字符型、指针等，也可以是用户自定义的对象。
variable_list 可以由一个或多个变量的名称组成，多个变量之间用逗号,分隔，变量由字母、数字和下划线组成，且以字母或下划线开头。
下面列出几个有效的声明：
定义整型变量：
int age; 以上代码中，age 被定义为一个整型变量。
定义浮点型变量：
float salary; 以上代码中，salary 被定义为一个浮点型变量。
定义字符型变量：
char grade; 以上代码中，grade 被定义为一个字符型变量。
定义指针变量：
int *ptr; 以上代码中，ptr 被定义为一个整型指针变量。
定义多个变量：
int i, j, k; int i, j, k; 声明并定义了变量 i、j 和 k，这指示编译器创建类型为 int 的名为 i、j、k 的变量。
变量初始化 在 C 语言中，变量的初始化是在定义变量的同时为其赋予一个初始值。变量的初始化可以在定义时进行，也可以在后续的代码中进行。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/02e9ec21538190c6d44784ea581d30bb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5c6fcbae540d0f2e65d567021286944/" rel="bookmark">
			【SWAT水文模型】SWAT-CUP参数率定过程问题总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SWAT-CUP参数率定过程问题总结 Q1 SWAT-CUP中calibrate按钮一直是灰色无法点击?1.1 问题描述1.2 解决办法 Q2 “SWAT”不是内部命令2.1 问题描述2.2 解决办法 Q3 未将对象引用设置到对象的实例3.1 问题描述3.2 解决办法 Q4 模拟效果太差啦！！！Q5 找不到 SUFI2.OUTbeh_*文件5.1 问题描述5.2 问题解决 Q6 Cannot open input file /SUFI2.OUT/no_beh_sims.txt6.1 问题描述6.2 问题解决 Q7 error72：floating overflow7.1 问题描述7.2 问题解决 预热/率定/检验期说明Q8 An exception happened while reading file "000120004.sol"Q9参考 SWAT-CUP如果有参数设置有误，运行应该就会卡顿。个人亲身感受。
Q1 SWAT-CUP中calibrate按钮一直是灰色无法点击? 1.1 问题描述 软件是从2W2E上下载的SWAT-CUP2019，新建的文件利用的是运行成功的SWAT的Tstinout文件，版本是2012版64bit。
问题是从新建项目到修改完所有参数保存后calibrate按钮一直是灰色无法点击。
1.2 解决办法 网上有说是因为“新版本的SWAT CUP 需要购买，可下载公开的旧版本”。
那就安装旧版本试试！
安装旧版本之后，可以打开之前用2019版本建立的文件诶，且calibrate按钮是绿色的！！！
Q2 “SWAT”不是内部命令 2.1 问题描述 运行时提示“SWAT”不是内部命令，如下图：
问题分析：该问题为CUP工程路径下缺少swat.exe的程序
2.2 解决办法 将SWAT安装目录下的swat2012.exe文件复制到当前SWATCUP所在的工程路径下，并重命名为“swat.exe”。为避免运行中出现此问题，可以在每次建立SWATCUP工程后，在运行前完成此工作。
Q3 未将对象引用设置到对象的实例 3.1 问题描述 3.2 解决办法 原因是删了保存的iteration ，但该iteration的结果文件没关闭。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d5c6fcbae540d0f2e65d567021286944/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7fb96801b261f7fbea9f6cd2e741b332/" rel="bookmark">
			基于Python的51job(前程无忧)招聘网站数据采集，通过selenium绕过网站反爬，可以采集全国各地数十万条招聘信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用Python编程语言和Selenium库来实现自动化的网页操作，从而实现登录、搜索和爬取职位信息的功能。
首先，导入了所需的库，包括time用于处理时间，selenium用于模拟浏览器操作，csv用于写入CSV文件，BeautifulSoup用于解析网页数据。然后，定义了一个名为login的函数，该函数接受一个WebDriver对象和一个关键词作为参数。
在login函数中，使用WebDriver对象打开51job网站，并通过模拟用户的行为进行登录操作。登录过程中需要输入关键词并点击搜索按钮。然后，使用BeautifulSoup库解析页面源代码，找到包含职位信息的HTML元素，并逐个提取出岗位名、公司、薪资、城市、区县、行业、标签、性质、企业人数和回复等信息。将提取的信息存储在一个列表中，并通过csv库将列表中的数据写入到CSV文件中。
在主函数main中，配置了Chrome浏览器的启动选项，并创建了一个WebDriver对象。接下来，代码循环遍历不同的城市列表，在每个城市中调用login函数进行登录和职位信息的爬取。
代码的运行过程是自动化的，通过模拟浏览器操作来实现登录和搜索功能，然后从搜索结果中提取所需的职位信息，并将其保存到CSV文件中。使用Selenium库可以实现与浏览器相同的操作，包括点击按钮、输入文本、滚动页面等。
主要代码如下：
def main(): # while True: """ chromeOptions 是一个配置 chrome 启动是属性的类,就是初始化 """ option = webdriver.ChromeOptions() """ add_experimental_option 添加实验性质的设置参数 """ option.add_experimental_option('excludeSwitches', ['enable-automation']) # webdriver防检测 ''' add_argument 添加启动参数 ''' # option.add_argument("--disable-blink-features=AutomationControlled") # option.add_argument("--no-sandbox") # option.add_argument("--disable-dev-usage") # option.add_experimental_option("prefs", {"profile.managed_default_content_settings.images": 2})#不加载图片 """ Chrome 配置驱动 """ driver = webdriver.Chrome(executable_path='chromedriver.exe',options=option) driver.set_page_load_timeout(15) list0=[['guangzhou', '广州'], ['shanghai', '上海'], ['shenzhen', '深圳'], ['changsha', '长沙'],['chongqing','重庆']] for k in list0: login(driver,k) time.sleep(15) # driver.set_page_load_timeout(15) # jugesd(driver) if __name__ == '__main__': headers = { 'User-Agent':'你的user-agent', 'Cookie':'你的cookie（一定要登录，不然久不久就会反爬验证）'} main() 完整代码可联系我，白嫖勿扰
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f5e09cfba7468e0ef27d02c64036b56/" rel="bookmark">
			MySQL 查看表结构简单命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、简单描述表结构，字段类型 desc tabl_name; # 表名 显示表结构，字段类型，主键，是否为空等属性。
二、查询表中列的注释信息 select * from information_schema.columns where table_schema = 'db' #表所在数据库 and table_name = 'tablename' ; #你要查的表 三、只查询列名和注释 select column_name, column_comment from information_schema.columns where table_schema ='db' and table_name = 'tablename' ; 四、查看表的注释 select table_name,table_comment from information_schema.tables where table_schema = 'db' and table_name ='tablename' 五、查看表生成的DDL show create table table_name; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78b6296a95ec9bc5473506b8b3354ec1/" rel="bookmark">
			Android mk文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.编译apk文件至system/app目录 #指定当前目录 LOCAL_PATH := $(call my-dir) #引入编译变量 include $(CLEAR_VARS) #编译出来的模块名 LOCAL_MODULE := ESFileExplore #编译选项便是在何种情况下编译 LOCAL_MODULE_TAGS := optional #指定编译之后放置的位置 LOCAL_MODULE_CLASS := APPS LOCAL_MODULE_SUFFIX := $(COMMON_ANDROID_PACKAGE_SUFFIX) LOCAL_SRC_FILES := $(LOCAL_MODULE).apk #签名文件 LOCAL_CERTIFICATE := platform #引入编译成可执行文件的规则 include $(BUILD_PREBUILT) apk文件和mk文件在同级目录
LOCAL_PATH := $(call my-dir) #指定当前目录 include $(CLEAR_VARS) #引入编译变量 LOCAL_MODULE := hello #编译出来的模块名 LOCAL_MODULE_TAGS := optional #编译选项便是在何种情况下编译 LOCAL_SRC_FILES := hello.c #源文件（可以指定多个） LOCAL_MODULE_CLASS := EXECUTABLES #指定编译之后放置的位置 include $(BUILD_EXECUTABLE) #引入编译成可执行文件的规则 LOCAL_PACKAGE_NAME #指定APP应用名称 LOCAL_PRIVATE_PLATFORM_APIS := true #设置后，会使用sdk的hide的api來编译 LOCAL_USE_AAPT2 := true #aapt 是编译和打包资源的工具。而aapt2是在aapt上做了优化 LOCAL_JNI_SHARED_LIBRARIES := libbluetooth_jni #声明要使用到的共享 JNI 库的名称 LOCAL_JAVA_LIBRARIES := javax.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/78b6296a95ec9bc5473506b8b3354ec1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca3925606dbc00e6a50111b73764fd12/" rel="bookmark">
			聚甲基丙烯酸甲酯PMMA的特性有哪些？UV胶水能够粘接聚甲基丙烯酸甲酯PMMA吗？又有哪些优势呢？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		聚甲基丙烯酸甲酯（Polymethyl Methacrylate，PMMA），又称丙烯酸甲酯，是一种常见的透明塑料，具有许多特性，使其在各种应用领域中广泛使用。以下是PMMA的一些主要特性：
1. 优异的透明性： PMMA具有出色的透明性，类似于玻璃，适用于制作透明的产品和器件。
2. 轻质： PMMA是一种轻质塑料，比玻璃轻，因此在需要轻量化的应用中被广泛使用。
3. 良好的机械性能： PMMA具有良好的机械强度和刚度，使其适用于制作结构性零部件。
4. 耐候性： PMMA具有一定的耐候性，能够抵抗紫外线照射和气候变化。
5. 耐化学性： PMMA对很多化学物质具有较好的耐受性，但相对较敏感于一些有机溶剂。
6. 易加工性： PMMA易于加工和成型，可通过注塑、挤出、吹塑等多种方法进行加工。
7. 良好的电绝缘性： PMMA是一种优秀的电绝缘材料，适用于电子和电气领域。
8. 抗冲击性： PMMA相对脆性，但通过改良可达到一定的抗冲击性。
9. 可塑性： PMMA可以在一定的温度范围内热塑性成型，使其适用于各种复杂形状的制品。
10. 抗黄变性： PMMA相对抗黄变，能够在一定程度上保持透明度和外观。
11. 可回收性： PMMA是可回收的塑料，有助于减少环境负担。
由于这些特性，PMMA被广泛应用于光学器件、建筑材料、汽车零部件、装饰品、广告牌、医疗器械等领域。
UV胶水通常可以用于粘接聚甲基丙烯酸甲酯（PMMA）。UV胶水是一种特殊的胶水，它需要通过紫外线照射才能固化。UV胶水通常对于PMMA等塑料材料具有较好的粘接效果，注意细节：
1. 表面处理： 虽然PMMA通常具有相对较好的表面能，但为了确保更好的粘接效果，可以考虑进行表面处理，如使用特殊的表面活化方法或处理剂。
2. 选择合适的UV胶水： 确保选择适用于PMMA材料的TADHE的UV胶水。
3. 光固化时间和强度： UV胶水需要使用紫外线照射进行固化，因此需要确保光源的固化时间和强度足够，以保证胶水能够充分固化并实现良好的粘接效果。
4. 环境条件： 注意环境条件，确保在适当的温度和湿度下进行粘接，以提高粘接效果的稳定性。
总的来说，UV胶水通常是一种有效的粘接材料，适用于与聚甲基丙烯酸甲酯（PMMA）等塑料材料的粘接。但在实际应用中，仍建议在粘接前对材料和胶水进行充分测试，以确保获得最佳的粘接效果。
使用TADHE的UV胶水粘接聚甲基丙烯酸甲酯（PMMA）具有一些优势，其中包括：
1. 快速固化： UV胶水通过紫外线照射进行固化，固化时间非常短，可以实现快速的粘接。这对于生产和制造过程中的高效率非常有利。
2. 高粘接强度： UV胶水通常能够提供高强度的粘接，确保粘接部位的牢固性。这对于需要承受一定负荷或应力的应用领域非常重要。
3. 适用于透明材料： 由于PMMA具有出色的透明性，UV胶水是一种适用于透明材料的理想选择。粘接后，不会影响PMMA的透明度，保持良好的视觉效果。
4. 不含溶剂： UV胶水通常是无溶剂的，这有助于减少对环境的影响，并使其更安全和符合环保要求。
5. 适用于复杂形状： UV胶水可以适用于各种形状的PMMA制品，包括复杂的结构和曲面，提供更广泛的应用可能性。
6. 精确控制固化区域： 通过精确控制紫外线的照射区域，可以实现局部固化，确保只在需要的区域进行粘接，避免不必要的固化。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ca3925606dbc00e6a50111b73764fd12/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6c658fe5507ce932f6d9e04b6eea630/" rel="bookmark">
			gdb python
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在对某些linux设备进行调试的时候，像pwngdb，gef这种扩展无法正常加载，但是可以使用预编译的gdb，问题就是界面很垃圾，你看不到执行的指令
这时可以通过执行x/10i $rip查看指令，然后ni执行当前指令，但是这样还是很麻烦
我们可以通过自定义python代码来完成自定义命令
python class SetCustomerCommand2(gdb.Command): def __init__(self): super(SetCustomerCommand2, self).__init__("zz", gdb.COMMAND_USER) def invoke(self, arg, from_tty): gdb.execute("set disassembly-flavor intel") gdb.execute("ni") gdb.execute("x/10i $rip") SetCustomerCommand2() end 直接在gdb中将上面的代码粘贴进去回车，即可，成功之后fk命令就相当于
ni x/10i $rip 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf140b4a62ec04bd6d2bbb463dc78fc9/" rel="bookmark">
			快速了解STM32的ADC功能，从入门到精通
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		快速了解STM32的ADC功能，从入门到精通 快速了解STM32的ADC功能，从入门到精通
1.关于ADC输入通道与GPIO口的输入关系需要查看STM32芯片手册（p31）而非数据手册。
2.外部触发源指的是触发ADC采样的触发信号，这与1的GPIO口输入是两个不同概念。而JEXTBEL[2:0]或者EXTBEL[2:0]决定具体是哪个触发源。
3.大的方向，触发模式分为了 ADON位触发启动和外部触发启动ADC转换两种。用后者就行了
4.当我们使用一个ADC要采集多个通道时，单独规则组由于只使用了一个数据寄存器，并且是整个组转换完后才会触发中断,因此数据会覆盖，这种情况下需要使用DMA方法（后面采用试试），这时数据写到SRAM中了。而单独使用注入组总共可最多有四个通道，对应四个数据寄存器，不存在覆盖。
5.关于注入通道和规则通道，原子说的很形象，前者相当于中断，能打断后者。并且举得监控例子不错
6.双ADC模式是指ADC1和ADC2两个ADC同时使用的情况。其实对于我们如果使用通道少的话，一个ADC就够用了，比如使用一个注入组就能采集四个通道，而使用规则组就可以采集16个通道，一起就能20个通道了.
二、利用STM32内部温度传感器测量温度：
32的温度值与电压值成正比关系，利用下列公式得出温度
温度(°C) = {(V25- VSENSE) / Avg_Slope} + 25
这里：
V25=VSENSE在25°C时的数值
Avg_Slope＝温度与VSENSE曲线的平均斜率(单位为mV/ °C或μV/ °C)
注意这里的V25和Vsense对应的是电压值，参考32的芯片手册可知，V25典型值为1.43，Avg_Slope为4.3mv/°C，Vsense即当前要测量温度对应的电压值，当3.3V对应3095,因此当前电压的计算可由比例关系Vsense = 3.3*当前寄存器采样值/4095。然后由上面公式得到当前温度。
//另注：自带的温度传感器是测试芯片自身温度，用其来测环境温度肯定有误差（转）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e2dbb099aa3881f00f64f09e337e1cb/" rel="bookmark">
			翻译: Streamlit从入门到精通 构建一个机器学习应用程序 三
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Streamlit从入门到精通 系列：
翻译: Streamlit从入门到精通 基础控件 一翻译: Streamlit从入门到精通 显示图表Graphs 地图Map 主题Themes 二
1. 构建一个机器学习应用程序 在这一部分，我将带你了解我做的一个关于贷款预测的项目。
贷款的主要利润直接来自于贷款的利息。贷款公司在进行了一系列严格的审核和验证过程后，才会授予贷款。然而，他们仍然不能保证申请人是否能够毫无困难地偿还贷款。在这个教程中，我们将构建一个预测模型（随机森林分类器）来预测申请人的贷款状态。我们的任务是准备一个网络应用，使其能够在生产环境中使用。
首先，我们从导入应用程序所需的必要库开始：
import streamlit as st import pandas as pd import numpy as np import pickle #to load a saved modelimport base64 #to open .gif files in streamlit app 在这个应用程序中，我们将使用多个小部件作为滑块：在侧边栏菜单中选择框和单选按钮，为此我们将准备一些Python函数。这个例子将是一个简单的演示，它有两个页面。在主页上，它将显示我们选择的数据，而“探索”页面将允许您在图表中可视化变量，“预测”页面将包含带有“预测”按钮的变量，该按钮将允许您估计贷款状态。下面的代码为您在侧边栏提供了一个选择框，使您能够选择一个页面。数据进行了缓存，因此无需不断重新加载。
@st.cache是一种缓存机制，即使在从网络加载数据、处理大型数据集或执行昂贵的计算时，也能让您的应用保持高效。
@st.cache(suppress_st_warning=True) def get_fvalue(val): feature_dict = {"No":1,"Yes":2} for key,value in feature_dict.items(): if val == key: return valuedef get_value(val,my_dict): for key,value in my_dict.items(): if val == key: return valueapp_mode = st.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e2dbb099aa3881f00f64f09e337e1cb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8af1aa0d358df1aaca2ef11f996ee2f/" rel="bookmark">
			Linux设备调试-GDB调试器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 “工欲善其事，必先利其器”，为了方便Linux驱动设备的开发和调试，建立舒适的开发环境、使用必要的软件工具，以及掌握常用的调试技巧是比较重要的。本篇介绍GDB调试器的主要功能和常见用法，同时在第三部分中，命令顺序按照使用频率由高到低编写，方便阅读和使用。
正文 一、GDB4个主要功能 可按照工程师自定义的要求运行程序。让被调试程序在工程师指定的断点处停住，断点可以是条件表达式程序被停住时，可检查此刻程序中所发生的事，并追踪上文动态地改变程序的执行环境 二、GDB使用实例 若有源文件get_timestamp.c, 使用命令gcc get_timestamp.c -o get_timestamp编译，产生含调试信息的二进制文件get_timestamp，使用命令gdb get_timestamp进入调试状态
三、调试常用命令 Ctrl+A+X 进入/退出调试界面
win cmd +5调整命令窗口大小
fs cmd 操作键停在命令窗口
r运行程序(run)
set args &lt;参数1&gt; &lt;参数2&gt; …，可指定运行参数再运行。
b 设置断点(break)
b &lt;function/linenum/*address/if &gt;，可接函数名、行数、内存地址、条件表达式。
c恢复运行(continue) c [ignore_count]，可接ignore_count，表示忽略其后多少次断点。
n单步执行(next)
p打印数据(print)
p ，接表达式（变量也是一种表达式）
p /，f为输出格式，有：x：十六进制；d：十进制；o：八进制；t：二进制；c：字符格式；f：浮点数格式
u跳出循环(until)
set修改内存
set 变量名=0
四、参考来源 书籍《Linux设备驱动开发详解：基于最新的Linux 4.0内核》第21章
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4982e75c0071beb9e2c16866c7289b42/" rel="bookmark">
			黑豹程序员-webstorm支持同时打开多个项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		只需配置下即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5e5b81f4bbad9d66389db5df5cd8d00/" rel="bookmark">
			Centost7中Redis源码编译与安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Centost7中Redis源码编译与安装 基本环境：
操作系统：Linux Centos 7
Redis版本：redis-5.0.3.tar.gz，其他版本安装方式可参考此文档
1.下载与安装 查看centos 7 版本的命令
查看系统版本的命令 1. cat /etc/redhat-release [root@localhost ~]# cat /etc/redhat-release CentOS Linux release 7.6.1810 (Core) 2. rpm -q centos-release [root@localhost ~]# rpm -q centos-release centos-release-7-6.1810.2.el7.centos.x86_64 查看内核命令： 1.uname -a [root@localhost ~]# uname -a Linux localhost.localdomain 3.10.0-957.1.3.el7.x86_64 #1 SMP Thu Nov 29 14:49:43 UTC 2018 x86_64 x86_64 x86_64 GNU/Linux 2. cat /proc/version [root@localhost ~]# cat /proc/version Linux version 3.10.0-957.1.3.el7.x86_64 (mockbuild@kbuilder.bsys.centos.org) (gcc version 4.8.5 20150623 (Red Hat 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f5e5b81f4bbad9d66389db5df5cd8d00/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cde793c5cc37a5ed591a95f207014555/" rel="bookmark">
			HTTPS环境下使用WebSocket问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、问题
使用WebSocket在本地是没有问题的，能够和前端进行正常交互，但是将项目部署到服务器上，发现和前端建立不了WebSocket的连接，打开浏览器控制台报错：This request has been blocked; this endpoint must be available over WSS.
2、理解
1、首先我们要明白 wss协议实际是websocket+SSL，就是在websocket协议上加入SSL层，类似https(http+SSL)。
2、利用nginx代理wss【通讯原理及流程】
（1）、客户端发起wss连接连到nginx
（2）、nginx将wss协议的数据转换成ws协议数据并转发到Workerman的websocket协议端口
（3）、Workerman收到数据后做业务逻辑处理
（4）、Workerman给客户端发送消息时，则是相反的过程，数据经过nginx/转换成wss协议然后发给客户端
3、关于 ws 和 wss
WebSocket可以使用 ws 或 wss 来作为统一资源标志符，类似于 HTTP 或 HTTPS。其中 ，wss 表示在 TLS 之上的 WebSocket，相当于 HTTPS。默认情况下，WebSocket的 ws 协议基于Http的 80 端口；当运行在TLS之上时，wss 协议默认是基于Http的 443 端口。说白了，wss 就是 ws 基于 SSL 的安全传输，与 HTTPS 一样样的道理。所以，如果你的网站是 HTTPS 协议的，那你就不能使用 ws:// 了，浏览器会 block 掉连接，和 HTTPS 下不允许 HTTP 请求一样。
4、解决
前提，服务器已经配置好了Nginx。如果没有配置的可以去网上搜索，很多资料的。如果找不到资料的小伙伴可以看文章的最后，我会把我的nginx配置贴出来。
在前端将：ws:// 修改为：wss://即可，同时，后面不要跟IP地址加端口，要使用网站的域名，例如：
本地websocket链接：ws://192.168.0.46:8781/tf/webSocket/huozhu20220819
那么更新到服务器的时候，链接应该修改为：wss://网站域名/tf/webSocket/huozhu20220819
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cde793c5cc37a5ed591a95f207014555/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43566baa2e890c63dd822b096766998a/" rel="bookmark">
			性能优化2.0，新增缓存后，程序的秒开率不升反降
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、前情提要经过4次优化，将页面的加载时间控制在了1秒以内，实打实的提升了程序的秒开率。 二、先了解一下，什么是缓存1、缓存有哪些分类2、本地缓存与分布式缓存 三、Guava Cache本地缓存1、Google Guava2、Loadingcache数据结构3、Loadingcache数据结构构建流程：4、判断缓存是否过期5、Loadingcache如何解决缓存穿透（1）expireAfterAcess和expireAfterWrite同步加载（2）refreshAfterWrite同步加载（3）refreshAfterWrite异步加载 四、Redis中如何解决缓存穿透五、使用loadingCache优化页面加载1、引入pom2、初始化LoadingCache3、优化5：通过LoadingCache缓存模板数据，在编辑模板后，更新缓存 大家好，我是哪吒。
一、前情提要 在上一篇文章中提到，有一个页面加载速度很慢，是通过缓冲流优化的。
查询的时候，会访问后台数据库，查询前20条数据，按道理来说，这应该很快才对。
追踪代码，看看啥问题，最后发现问题有三：
表中有一个BLOB大字段，存储着一个PDF模板，也就是上图中的运费模板；查询后会将这个PDF模板存储到本地磁盘点击线上显示，会读取本地的PDF模板，通过socket传到服务器。 大字段批量查询、批量文件落地、读取大文件并进行网络传输，不慢才怪，这一顿骚操作，5秒能加载完毕，已经烧高香了。
经过4次优化，将页面的加载时间控制在了1秒以内，实打实的提升了程序的秒开率。 批量查询时，不查询BLOB大字段；点击运费查询时，单独查询+触发索引，实现“懒加载”；异步存储文件通过 缓冲流 -&gt; 内存映射技术mmap -&gt; sendFile零拷贝 读取本地文件； 有一个小伙伴在评论中提到，还可以通过缓存继续优化，确实是可以的，缓存也是复用优化的一种。
为了提高页面的加载速度，使用了单条查询 + 触发索引，提高数据库查询速度。
归根结底，还是查询了数据库，如果不查呢，访问速度肯定会更快。
这个时候，就用到了缓存，将运费模板存到缓存中。
二、先了解一下，什么是缓存 缓存就是把访问量较高的热点数据从传统的关系型数据库中加载到内存中，当用户再次访问热点数据时，是从内存中加载，减少了对数据库的访问量，解决了高并发场景下容易造成数据库宕机的问题。
我理解的缓存的本质就是一个用空间换时间的一个思想。
提供“缓存”的目的是为了让数据访问的速度适应CPU的处理速度，其基于的原理是内存中“局部性原理”。
CPU 缓存的是内存数据，用于解决 CPU 处理速度和内存不匹配的问题，比如处理器和内存之间的高速缓存，操作系统在内存管理上，针对虚拟内存 为页表项使用了一特殊的高速缓存TLB转换检测缓冲区，因为每个虚拟内存访问会引起两次物理访问，一次取相关的页表项，一次取数据，TLB引入来加速虚拟地址到物理地址的转换。
1、缓存有哪些分类 操作系统磁盘缓存，减少磁盘机械操作数据库缓存，减少文件系统 I/O应用程序缓存，减少对数据库的查询Web 服务器缓存，减少应用程序服务器请求客户端浏览器缓存，减少对网站的访问 2、本地缓存与分布式缓存 本地缓存：在客户端本地的物理内存中划出一部分空间，来缓存客户端回写到服务器的数据。当本地回写缓存达到缓存阈值时，将数据写入到服务器中。
本地缓存是指程序级别的缓存组件，它的特点是本地缓存和应用程序会运行在同一个进程中，所以本地缓存的操作会非常快，因为在同一个进程内也意味着不会有网络上的延迟和开销。
本地缓存适用于单节点非集群的应用场景，它的优点是快，缺点是多程序无法共享缓存。
无法共享缓存可能会造成系统资源的浪费，每个系统都单独维护了一份属于自己的缓存，而同一份缓存有可能被多个系统单独进行存储，从而浪费了系统资源。
分布式缓存是指将应用系统和缓存组件进行分离的缓存机制，这样多个应用系统就可以共享一套缓存数据了，它的特点是共享缓存服务和可集群部署，为缓存系统提供了高可用的运行环境，以及缓存共享的程序运行机制。
下面介绍一个小编最常用的本地缓存 Guava Cache。
三、Guava Cache本地缓存 1、Google Guava Google Guava是一个Java编程库，其中包含了许多高质量的工具类和方法。其中，Guava的缓存工具之一是LoadingCache。LoadingCache是一个带有自动加载功能的缓存，可以自动加载缓存中不存在的数据。其实质是一个键值对(Key-Value Pair)的缓存，可以使用键来获取相应的值。
Guava Cache 的架构设计灵感来源于 ConcurrentHashMap，它使用了多个 segments 方式的细粒度锁，在保证线程安全的同时，支持了高并发的使用场景。Guava Cache 类似于 Map 集合的方式对键值对进行操作，只不过多了过期淘汰等处理逻辑。
Guava Cache对比ConcurrentHashMap优势在哪？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/43566baa2e890c63dd822b096766998a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2112016034e7fc7b614217a1d24dde65/" rel="bookmark">
			camera算法集成实现流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		和你一起终身学习，这里是程序员Android
经典好文推荐，通过阅读本文，您将收获以下知识点:
算法概览
一、算法集成前的准备
二、 为算法选择feature
三、 将算法对应的feature添加到scenario配置表
四、挂载算法
五、自定义metadata
六、APP调用算法
七、遇到的问题及解决方法
八、结语
算法概览 为了给用户提供更好的成像效果，现在的手机都会接入一些第三方的图像处理算法。MTK平台的HAL3也在P2这一层提供接入的plugin。按图像处理算法需要的帧数和摄像头数量，大体可以分为三类：
单帧算法：
常见的单帧算法有：美颜算法(瘦脸、磨皮、大眼)、广角镜头畸变校正算法、附加表情算法、单摄背景虚化算法(伪双摄算法)等等，仅需单帧图像输入的算法都属于单帧算法。一般情况下，输入一帧图像，算法处理完输出一帧处理后的图像。
多帧算法：
常见的多帧算法有：MFNR（多帧降噪）、HDR（高动态范围）等等，需要连续多帧图像输入的算法都属于多帧算法。一般情况下，输入连续多帧图像，算法处理完输出一帧处理后的图像。
双摄算法：
最常见的双摄算法是双摄景深算法或者叫双摄背景虚化算法，除此之外，也有彩色+黑白用于增强夜拍效果的双摄算法。单帧算法和多帧算法仅需要获取一个摄像头的图像。而双摄算法需要获取主、辅两个摄像头的图像，并且一般还会要求主、辅摄像头同步。分别获取主、辅摄像头的两帧同步图像，处理后输出一帧主摄图像，用户也仅能看到主摄图像。
根据这个大体上的分类，MTK HAL算法集成系列文章共三篇：
MTK HAL算法集成之单帧算法
MTK HAL算法集成之多帧算法
MTK HAL算法集成之双摄算法
本文是其中的第一篇。这个系列文章均基于Android 9.0，MT6763平台，HAL版本是HAL3。
一、算法集成前的准备 在开展集成工作之前，首先要对算法有一个基本的评估，并且对于集成也应有一定的要求。
1. 1 算法要求及评估 处理效果好，不能比竞品差，超过竞品更佳。（这条和camera调试的主观效果一样，主观性较强，往往一厢情愿，具体看项目要求吧）
各个场景及压力测试下效果稳定。
处理后照片无色差、锐度和饱和度无损失，或者损失在可接受范围。
达到可接受的分辨率，最好可达到摄像头的最大分辨率。
处理时间越快越好，不超过竞品时间、不超过项目和产品的目标时间。
无内存泄露，占用内存少。
提供必要的集成说明文档，包括算法类型、输入及输出图像要求、输入参数要求等等。
注意：如果有条件，处理时间、内存占用、分辨率等等可量化的指标可要求算法提供方给出具体的参考数据，以便集成完后测试验证。
1.2 算法集成要求 编译时可根据项目控制是否集成算法。
运行时可以用参数控制是否启用算法。
集成算法库正常运行、压力测试下效果稳定、无内存泄露。
1.3 算法集成的步骤 (1). 根据算法选择feature类型，如果与MTK提供的feature不能对号入座，则需要添加自定义feature。
(2). 将算法对应的feature类型添加到scenario配置表。
(3). 根据算法选择plugin类型，编写CPP文件实现plugin，挂载算法。
(4). 如果算法不能复用Android和MTK提供的metadata，则还需要为算法配置自定义的metadata以便APP控制是否启用算法。
首先，我准备了一个libwatermark.so，它仅仅实现了一个添加水印的功能，用它来模拟第三方的单帧算法库。如果想了解添加水印的实现代码，可以参考我另外一篇文章：Android 实现图片加水印或logo。接下来，我们就按照集成步骤，逐步详细讲解。
二、 为算法选择feature 2.1 MTK提供的feature MTK在mtk_feature_type.h和customer_feature_type.h已经提供了一些feature。
vendor/mediatek/proprietary/hardware/mtkcam3/include/mtkcam3/3rdparty/mtk/mtk_feature_type.h：
NO_FEATURE_NORMAL = 0ULL, // MTK (bit 0-31) MTK_FEATURE_MFNR = 1ULL &lt;&lt; 0, MTK_FEATURE_HDR = 1ULL &lt;&lt; 1, MTK_FEATURE_REMOSAIC = 1ULL &lt;&lt; 2, MTK_FEATURE_ABF = 1ULL &lt;&lt; 3, MTK_FEATURE_NR = 1ULL &lt;&lt; 4, MTK_FEATURE_FB = 1ULL &lt;&lt; 5, MTK_FEATURE_CZ = 1ULL &lt;&lt; 6, MTK_FEATURE_DRE = 1ULL &lt;&lt; 7, MTK_FEATURE_DEPTH = 1ULL &lt;&lt; 8, MTK_FEATURE_BOKEH = 1ULL &lt;&lt; 9, MTK_FEATURE_VSDOF = (MTK_FEATURE_DEPTH|MTK_FEATURE_BOKEH), MTK_FEATURE_FSC = 1ULL &lt;&lt; 10, MTK_FEATURE_3DNR = 1ULL &lt;&lt; 11, MTK_FEATURE_EIS = 1ULL &lt;&lt; 12, MTK_FEATURE_AINR = 1ULL &lt;&lt; 13, MTK_FEATURE_DUAL_YUV = 1ULL &lt;&lt; 14, MTK_FEATURE_DUAL_HWDEPTH = 1ULL &lt;&lt; 15, MTK_FEATURE_AIS = 1ULL &lt;&lt; 16, MTK_FEATURE_HFG = 1ULL &lt;&lt; 17, MTK_FEATURE_DCE = 1ULL &lt;&lt; 18, vendor/mediatek/proprietary/hardware/mtkcam3/include/mtkcam3/3rdparty/customer/customer_feature_type.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2112016034e7fc7b614217a1d24dde65/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f55c636e0a13ab9a0ee88deb7fbcf11/" rel="bookmark">
			详解SpringCloud微服务技术栈：强推！源码跟踪分析Ribbon负载均衡原理、Eureka服务部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		👨‍🎓作者简介：一位大四、研0学生，正在努力准备大四暑假的实习
🌌上期文章：详解SpringCloud微服务技术栈：认识微服务、服务拆分与远程调用
📚订阅专栏：微服务技术全家桶
希望文章对你们有所帮助
Eureka 提供者与消费者Eureka原理分析搭建Eureka服务搭建注册中心服务注册服务发现 Ribbon负载均衡原理源码跟踪原理（强推！）流程总结 负载均衡策略饥饿加载 提供者与消费者 服务提供者：一次业务中，被其它微服务调用的服务（提供接口给其他微服务）
服务消费者：一次业务中，调用其它微服务的服务（调用其它微服务提供的接口）
若服务A调用服务B，服务B调用服务C，那么服务B是什么角色？
提供者与消费者的概念是相对的，一个服务既可以是提供者也可以是消费者。
Eureka原理分析 上一节内容中服务调用存在问题，服务调用使用http请求，网址直接定死了，如果我们有多个服务集群，亦或是网址在后续开发过程中出现变更，就会产生不方便。如下所示：
我们需要解决以下三个问题：
服务消费者该如何获取服务提供者的地址信息？
如果有多个服务提供者，消费者该如何选择？
消费者如何得知服务提供者的健康状态？
而Eureka可以解决这个问题，Eureka的架构：
1、eureka-server：注册中心
2、eureka-client：
（1）服务消费者（集群）
（2）服务提供者（集群）
Eureka的作用及工作流程：
1、每个服务启动的时候，都会将注册服务信息记录在注册中心，例如端口号
2、服务信息都记住了，当服务消费者需要信息的时候，无须自己去记录，而是直接去Eureka-server中拉取，这样就可以得到服务提供者的信息
3、得到的服务提供者信息可能是个集群，包含多台服务的信息，这时候要做负载均衡去选取其中一个服务
4、消费者对提供者发起远程调用
这是核心的工作流程，另外，服务的提供者每隔30s就会向Eureka-server发送心跳续约，如果服务宕机了，那么Eureka-server就会将其剔除，这样能够保证服务消费者做远程调用的时候，能调用服务提供者都是健康的。
搭建Eureka服务 要首先Eureka服务，需要实现3点：
1、搭建注册中心（EurekaServer）
2、实现服务注册（将上一篇文章中的user-service、order-service注册到eureka）
3、实现服务发现（在order-service中完成服务拉取，然后通过负载均衡挑选一个服务，实现远程调用）
搭建注册中心 搭建EurekaServer的步骤如下：
1、创建项目，引入EurekaServer依赖：
&lt;dependencies&gt; &lt;!--Eureka服务端--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 2、编写启动类，添加@EnableEurekaServer注解：
@EnableEurekaServer @SpringBootApplication public class EurekaApplication { public static void main(String[] args) { SpringApplication.run(EurekaApplication.class, args); } } 3、添加application.yml文件，编写下列配置：
server: port: 10086 # 服务端口 spring: application: name: eurekaserver # 服务名称 eureka: client: service-url: # Eureka的地址信息 defaultZone: http://localhost:10086/eureka Eureka自己也是微服务，所以配置Eureka也需要将Eureka本身给注册。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1f55c636e0a13ab9a0ee88deb7fbcf11/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b82ebd382508fe84329506c6e55b2c6/" rel="bookmark">
			【AI】无人零售和边缘计算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、什么是边缘计算
1.1 边缘计算的定义
1.2 边缘计算的作用
1.3 边缘计算的关键技术
1.4 边缘计算的应用场景
二、边缘计算在无人零售中的应用
一、什么是边缘计算 1.1 边缘计算的定义 边缘计算（Edge Computing）是一种分布式计算范式，它将计算任务和数据存储从中心化的云服务器推向网络的边缘，即接近数据源和用户终端的地方。边缘计算通过在网络的边缘执行计算任务，减少了数据传输的延迟，提高了响应速度和数据处理效率。
简单理解，就是大量的运算放到距离业务发生更近的地方，而不是在客户端采集数据，云端计算，再把结果回传。
举个不恰当的例子，就是javascript很多浏览器效果，是在客户端完成的，服务器端并不知道，真正要提交数据时，服务器端才去运算。这保证的很好的用户体验和速度，同时，数据隐私、安全性，又会受到一定的影响。
1.2 边缘计算的作用 降低延迟：通过将数据处理和分析任务放在靠近数据源的地方执行，边缘计算可以显著减少数据传输的延迟，这对于实时应用（如自动驾驶、远程医疗等）至关重要。减轻网络负担：边缘计算可以减少传输到云端的大量原始数据，从而减轻网络带宽的负担，提高整体网络的效率。增强隐私和安全：由于数据在本地或附近进行处理，而不是传输到远程的云服务器，边缘计算可以在一定程度上增强数据的隐私性和安全性。支持离线功能：即使在没有网络连接的情况下，边缘计算设备也可以继续执行一些基本的计算任务。扩展性和灵活性：边缘计算允许根据需要在网络的不同部分部署和扩展计算能力。 1.3 边缘计算的关键技术 容器化技术：如Docker和Kubernetes，这些技术使得应用程序和其依赖项可以被打包成容器，轻松地在不同的边缘设备上部署和管理。微服务架构：通过将应用程序分解为一系列小型、独立的服务，微服务架构支持在边缘环境中进行灵活的部署和扩展。数据压缩和优化技术：这些技术有助于减少在边缘设备和云服务器之间传输的数据量。边缘智能：包括在边缘设备上执行机器学习和人工智能算法的能力，以实现实时的数据分析和决策。雾计算：与边缘计算相似，但更强调在网络的不同层级（从边缘到云）之间分配计算资源。安全性和隐私保护技术：包括加密、匿名化、访问控制等，以保护在边缘环境中处理和传输的数据。 1.4 边缘计算的应用场景 自动驾驶汽车：边缘计算可以在车辆上实时处理来自各种传感器的数据，以实现快速的决策和响应。智能制造：在工业自动化领域，边缘计算可以支持实时的生产监控、质量控制和故障检测。智慧城市：通过部署在城市各处的传感器和执行器，边缘计算可以支持智能交通管理、环境监测和能源管理等应用。远程医疗：边缘计算可以在医疗机构或患者家中提供实时的健康监测和诊断支持。媒体和娱乐：在内容分发网络（CDN）中，边缘计算可以提供更快的内容传输和流媒体服务。物联网（IoT）：边缘计算可以处理和分析来自大量IoT设备的数据，支持各种智能家居、智能农业和智能物流等应用。 真正在应用中，目前更多的场景是混合计算，全靠边缘不行，全上云，也经常会有实际的困难。比如我说几个场景。
比如你搞视频监控，同时使用AI技术做机器视觉分析，例如灾害预警、工人吸烟，被监控区域的网络条件很差，这种需要发现问题，就立刻制止的场景，就很适合做AI和边缘计算的结合。等你一段视频传到云端，都1分钟过去了，一根烟都抽完了。你说是不是？
二、边缘计算在无人零售中的应用 上图仅为示例。
相信大家都用过智能无人零售机器，从2020年开始，最火爆的，就是开门柜了。
微信或者支付宝扫码（扫脸）授权免密支付，开门取物，关门自动结算。这个体验真是特别的爽，而且这种柜子的价格，是传统无人零售机器的三分之一左右。
这是如何实现的？
核心就是AI动态视觉。智能柜从开门一刻起，开始拍摄视频，关门后，中控将视频传输到云端，AI识别商品，基本都是从商品云库中对比，云库中的图片，一般要按要求，拍摄4-6张，不同的角度不等。
初步识别后，如果场景非常简单，购买迅速，无遮挡，则自动就会生成订单，人工后期复核即可。如果比较复杂，置信度不高，将会推给人工，进行人工识别，生成订单。
这其中，时间最长的，就是视频传送这个过程。柜子网络基本上行在10M-20M，下行在100M，视频到云端大家就要30秒-1分钟，这个体验是不太好，消费者感觉半天没来订单，不知道扣费了没有，扣错了没有。
这时，有一些方法就出现了，第一是配合重力、RFID等方式，第二，就是边缘计算。视频直接在柜端就进行识别，生成订单，扣费，10秒内就能收到消费信息，体验非常好，促进客户的二次复购，如果优惠推送的及时，甚至当时就能再去开门购物。
这就是边缘计算最大的魅力！在其他任何场景，都是一样的！
当然，也会有一些问题，不过瑕不掩瑜，随着边缘计算模块价格的降低，这确实是一条提高GMV的新路。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5385dd9248f1d890302c8fa56fa6c202/" rel="bookmark">
			概率论与数理统计————1.随机事件与概率
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、随机事件 随机试验：满足三个特点
（1）可重复性：可在相同的条件下重复进行
（2）可预知性：每次试验的可能不止一个，事先知道试验的所有可能结果
（3）不确定性：每次试验不能确定实验结果
随机试验记作E
样本空间：随机试验E的所有可能的结果构成的集合
样本点：样本空间的每个元素是一个样本点
随机事件：样本空间的子集为一个随机事件（事件放生：该事件的某个样本点出现）
必然事件：必然发生的事件
不可能事件：不可能发生的事件
二、事件间的关系和运算 1、包含
AB：事件A发生，则事件B必发生
A=B 且
2.事件的和（并）
AB 或A+B : 事件A和事件B至少发生一个
3、事件的积（交）
AB或AB : 事件A和事件B同时发生
4、事件的差
A-B：事件A发生了，事件B不发生
重要公式：A-B=A-AB
5、互不相容事件
A和B互斥则A和B没有交集
6、对立事件
交换律：
结合律： , 分配律：
德摩根律：
三、概率的定义和性质 设一个随机试验，重复做n次，A为随机事件，发生m次则
=p为A发生的频率，当试验次数足够大时，p为事件A发生的概率
非负性：0
规范性：P（s）=1；p（）=0
有限可加性：若A,B互斥，则p（AB）=P（A）+P（B）
互补性：P（）=1-P(A)
减法公式：p（A-B）=p（A）-p（AB）
加法公式：p（）=p（A）+p（B）-p（AB）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a426269cc291d4628f8c32991648d250/" rel="bookmark">
			YOLOv5 common.py文件解读
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		def autopad(k, p=None, d=1): # kernel, padding, dilation # Pad to 'same' shape outputs if d &gt; 1: k = d * (k - 1) + 1 if isinstance(k, int) else [d * (x - 1) + 1 for x in k] # actual kernel-size if p is None: p = k // 2 if isinstance(k, int) else [x // 2 for x in k] # auto-pad return p autopad函数用于计算卷积层自动填充（padding）大小的辅助函数，目的是为了在使用卷积层时保持输出特征图的尺寸不变（即所谓的'same' padding）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a426269cc291d4628f8c32991648d250/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f261eec37ba6706733ce92b86f9007c/" rel="bookmark">
			《Git学习笔记：IDEA整合Git》
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在IDEA中集成Git去使用 通过Git命令可以完成Git相关操作，为了简化操作过程，我们可以在IDEA中配置Git，配置好后就可以在IDEA中通过图形化的方式来操作Git。 在IDEA开发工具中可以集成Git：
集成后在IDEA中可以看到Git相关图标： 1. 在IDEA中配置Git 在IDEA中使用Git，本质上还是使用的本地安装的Git软件，所以需要提前安装好Git并在IDEA中配置Git。 Git安装目录：
解释说明： gitk.exe：Git安装目录下的可执行文件，前面执行的git命令，其实就是执行的这个文件 IDEA中的配置：
首先关闭项目，找到Customize下的All settings： 1. 在IDEA当中去配置Git的安装目录 点击OK即可~！ 2. 本地仓库操作 在IDEA中使用Git获取仓库有两种方式： 本地初始化仓库从远程仓库克隆 2.1 本地初始化仓库 在IDEA中通过如下操作可以在本地初始化一个本地仓库，其实底层就是执行的 git init 命令。
操作过程如下：
1）依次选择菜单【VCS】---【Import into Version Control】---【Create Git Repository】
2）在弹出的【Create Git Repository】对话框中选择当前项目根目录，点击【OK】按钮： 操作完成后可以看到当前项目根目录下出现了.git隐藏目录： 2.2 从远程仓库克隆 在IDEA中从远程仓库克隆本质就是执行的 git clone 命令，具体操作过程如下： 1）在IDEA开始窗口中点击【Get from VCS】 2）在弹出的【Get from VCS】窗口中输入远程仓库的URL地址和对应的本地仓库存放目录，点击【Clone】按钮进行仓库克隆操作 3. Git忽略文件：.gitignore 在Git工作区中有一个特殊的文件 .gitignore，通过此文件可以指定工作区中的哪些文件不需要Git管理。
我们在码云上创建Git远程仓库时可以指定生成此文件，如下： 创建完成后效果如下：
解释说明： 我们在使用Git管理项目代码时，并不是所有文件都需要Git管理，例如Java项目中编译的.class文件、开发工具自带的配置文件等，这些文件没有必要交给Git管理，所以也就不需要提交到Git版本库中。注意：忽略文件的名称是固定的，不能修改添加到忽略列表中的文件后续Git工具就会忽略它 一个参考的.gitignore文件内容如下：
.git logs rebel.xml target/ !.mvn/wrapper/maven-wrapper.jar log.path_IS_UNDEFINED .DS_Store offline_user.md *.class ### IntelliJ IDEA ### .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9f261eec37ba6706733ce92b86f9007c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0105901cfa93525d95c18d821a81bfb4/" rel="bookmark">
			使用docker搭建Jenkins
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 enkins是一个开源的自动化服务器工具，最初是为软件开发领域设计的。它是一个基于Java的Web应用程序，用于管理和持续集成软件开发过程中的各种任务。
Jenkins的主要功能是帮助开发团队自动化构建、测试和部署软件项目。它可以集成各种版本控制系统，如Git、Subversion等，并支持多种构建工具和测试框架。
使用Jenkins，开发团队可以设置自动构建任务，从代码仓库中拉取最新代码，编译并构建应用程序，运行各种自动化测试，生成测试报告，并在构建成功后自动部署到目标服务器。这样可以大大减少手动操作，提高开发效率和软件质量。
安装 创建docker-compose.yml文件：
sudo vim docker-compose.yml version: '3' services: jenkins: image: jenkins/jenkins:lts container_name: jenkins ports: - "8080:8080" - "50000:50000" volumes: - jenkins_home:/var/jenkins_home - jenkins_logs:/var/log/jenkins environment: - JAVA_OPTS=-Djenkins.install.runSetupWizard=false - JENKINS_OPTS=--prefix=/jenkins logging: driver: "json-file" options: max-size: "10m" # 设置最大日志文件大小为10兆 max-file: "5" # 保留最多5个旧日志文件 networks: - jenkins-net volumes: jenkins_home: jenkins_logs: networks: jenkins-net: image: jenkins/jenkins:lts: 使用 Jenkins 官方的 Long-Term Support (LTS) 版本的 Docker 镜像。
container_name: jenkins: 为容器指定一个名称，以便在运行时引用容器。
ports: 映射容器内的端口到宿主机。
volumes: 定义容器的数据卷，分别用于持久化 Jenkins 数据和日志。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0105901cfa93525d95c18d821a81bfb4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/865d617c0ea06a1560b78d4d88f7907d/" rel="bookmark">
			数据治理工程师 CDGA数据建模和设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 以下选项不属于数据建模和设计治理中质量管理内容的是（D ）
A 开发数据建模和设计标准
B 评审数据模型以及数据库设计质量
C 管理数据模型版本与集成
D 评估数据模型运行效率
2. 关于实体的别名，以下对应关系不正确的是（B ）
A 在关系模型中经常用"实体”
B 在维度模型中经常使用"维度"和"链接"
C 在面向对象模型中经常使用"类”或“对象"
D 在非关系型数据库模型中经常使用“文件“或 “节点”
3. 以下关于数据建模和设计治理管理内容描述正确的是 (B )
A 举办设计评审会可由建模人员来记录讨论的要点
B 建模人员必须通过修改以解决评审小组提出的所有问题
C 如果建模人员无法自行解决评审小组提出的问题时，可挂起问题
D 数据模型的每次更改，需要以事件线记录变更内容
4. 以下不属于数据模型组件的是 ( B )
A 实体
B 类
C 属性
D 域
5. 以下选项属于逻辑数据模型建模的步骤的是（B ）
A 选择表示方法
B 分析信息需求
C 添加属性细节
D 合并企业术语
6. 以下选项不是锚建模基本概念的是 ( C )
A 锚
B 属性
C 关系
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/865d617c0ea06a1560b78d4d88f7907d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bba4507db461e0fb7873cc946ffb413c/" rel="bookmark">
			毕业设计：基于深度学习的多目标跟踪系统 机器视觉 人工智能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
设计思路
一、课题背景与意义
二、算法理论原理
2.1 目标检测算法
2.2 DeepSORT 算法
三、检测的实现
3.1 数据集
3.2 实验环境搭建
3.3 实验及结果分析
最后
前言 📅大四是整个大学期间最忙碌的时光,一边要忙着备考或实习为毕业后面临的就业升学做准备,一边要为毕业设计耗费大量精力。近几年各个学校要求的毕设项目越来越难,有不少课题是研究生级别难度的,对本科同学来说是充满挑战。为帮助大家顺利通过和节省时间与精力投入到更重要的就业和考试中去,学长分享优质的选题经验和毕设项目与技术思路。
🚀对毕设有任何疑问都可以问学长哦!
选题指导:
最新最全计算机专业毕设选题精选推荐汇总
大家好,这里是海浪学长毕设专题,本次分享的课题是
🎯基于深度学习的多目标跟踪系统
设计思路 一、课题背景与意义 在安防领域，视频监控发挥着巨大的作用，但并不是所有目标都需要进行跟踪，否则会对计算资源造成过度消耗和浪费。以施工工地中未佩戴安全帽为特定目标，研究跨域跟踪技术，以减少不必要的计算资源消耗，实现安全生产。通过对未佩戴安全帽目标的跟踪，可以及时发现并采取措施，提高工地安全管理的效果，确保工人的人身安全。
二、算法理论原理 2.1 目标检测算法 在改进过程中，通过优化Focus结构，采用DenseNet的核心组件DenseBlock模块来增强检测精度。DenseBlock模块具有紧密连接性，每个模块包含四层，每一层都会经过非线性变换函数、归一化、激活函数和卷积等操作后传输至后面的网络。模块中的任意两层直接相连，解决了梯度下降过程中梯度消失的问题。通过这一改进，可以提高YOLOv5算法对小目标的检测效果。
相关代码示例：
# 定义DenseBlock模块 class DenseBlock(nn.Module): def __init__(self, in_channels, growth_rate, num_layers): super(DenseBlock, self).__init__() self.layers = nn.ModuleList() for i in range(num_layers): self.layers.append(self._make_layer(in_channels + i * growth_rate, growth_rate)) def _make_layer(self, in_channels, growth_rate): layer = nn.Sequential( nn.BatchNorm2d(in_channels), nn.ReLU(inplace=True), nn.Conv2d(in_channels, growth_rate, kernel_size=3, padding=1) ) return layer def forward(self, x): features = [x] for layer in self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bba4507db461e0fb7873cc946ffb413c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b97ab34a7d4215b776e7708e7bb186c/" rel="bookmark">
			布隆过滤器四种实现（Java,Guava,hutool,Redisson）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.背景 为预防大量黑客故意发起非法的时间查询请求，造成缓存击穿，建议采用布隆过滤器的方法解决。布隆过滤器通过一个很长的二进制向量和一系列随机映射函数（哈希函数）来记录与识别某个数据是否在一个集合中。如果数据不在集合中，能被识别出来，不需要到数据库中进行查询，所以能将数据库查询返回值为空的查询过滤掉。
缓存穿透： 缓存穿透是查询一个根本不存在的数据，由于缓存是不命中时需要从数据库查询，这将导致这个不存在的数据每次请求都要到数据库去查询，进而给数据库带来压力。
2.布隆过滤器介绍 1970年由布隆提出的。它实际上是一个很长的二进制向量和一系列的随机映射函数（哈希函数）两部分组成的数据结构。
用途： 用于检索一个元素是否在一个集合中。
优点：
时间复杂度低，增加及查询元素的时间复杂度都是O(k)，k为Hash函数的个数；
占用存储空间小，布隆过滤器相对于其他数据结构（如Set、Map）非常节省空间。
缺点：
存在误判，只能证明一个元素一定不存在或者可能存在，返回结果是概率性的，但是可以通过调整参数来降低误判比例；
删除困难，一个元素映射到bit数组上的k个位置为1，删除的时候不能简单的直接置为0，可能会影响到其他元素的判断。
3.原理 当一个元素加入布隆过滤器中的时候，会进行如下操作：
使用布隆过滤器中的哈希函数对元素进行计算，得到哈希值（有几个哈希函数得到几个哈希值）。
根据得到的哈希值，在位数组中把对应下标的值置为1。
当我们需要判断一个元素是否位于布隆过滤器的时候，会进行如下操作：
对给定元素再次进行相同的哈希计算；
得到值之后判断位数组中的每个元素是否都为1，如果值都为1，那么说明这个值在布隆过滤器中，如果存在一个值不为1，说明该元素不在布隆过滤器中。
举个例子：
如图所示，当字符串存储要加入到布隆过滤器中时，该字符串首先由多个哈希函数生成不同的哈希值，然后将对应的位数组的下标设置为1（当位数组初始化时，所有位置均为 0）。当第二次存储相同字符串时，因为先前的对应位置已设置为 1，所以很容易知道此值已经存在（去重非常方便）。
如果我们需要判断某个字符串是否在布隆过滤器中时，只需要对给定字符串再次进行相同的哈希计算，得到值之后判断位数组中的某个元素是否都为1，如果值都为1，那么说明这个值在布隆过滤器中，如果存在一个值不为1，说明该元素不在布隆过滤器中。
不同的字符串可能哈希出来的位置相同，这种情况我们可以适当增加位数组大小或者调整我们的哈希函数。
综上：布隆过滤器说某个元素存在，小概率会误判。布隆过滤器说某个元素不存在，那么这个元素一定不在。
4.使用场景 4.1判断给定数据是否存在：
比如判断一个数字是否在于包含大量数字的数字集中（数字集很大，5亿以上）、防止缓存穿透（判断请求的数据是否有效避免直接绕过缓存请求数据库）、邮箱的垃圾邮件过滤、黑名单功能等。
4.2去重：
爬给定网址的时候对已经爬取过的URL去重。
5.代码实现 5.1Java实现 package com.fandf.test.redis; import java.util.BitSet; /** * java布隆过滤器 */ public class MyBloomFilter { /** * 位数组大小 */ private static final int DEFAULT_SIZE = 2 &lt;&lt; 24; /** * 通过这个数组创建多个Hash函数 */ private static final int[] SEEDS = new int[]{4, 8, 16, 32, 64, 128, 256}; /** * 初始化位数组，数组中的元素只能是 0 或者 1 */ private final BitSet bits = new BitSet(DEFAULT_SIZE); /** * Hash函数数组 */ private final MyHash[] myHashes = new MyHash[SEEDS.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5b97ab34a7d4215b776e7708e7bb186c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d48411297918b32d192b72ffa27f6eca/" rel="bookmark">
			Redis五大数据类型以及相关操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Redis五大数据类型 文章目录 Redis五大数据类型key字符串string操作命令列表list集合set哈希hash有序集合zset (sorted set) key keys * 查看当前库的所有键exists &lt;key&gt; 判断某个键是否存在type &lt;key&gt; 查看键的类型del &lt;key&gt; 删除某个键expire &lt;key&gt; &lt;seconds&gt; 为键值设置过期时间，单位秒ttl &lt;key&gt; 查看还有多久过期,-1表示永不过期,-2表示已过期dbsize 查看当前数据库中key的数量flushdb 清空当前库Flushall 通杀全部库 字符串string操作命令 String类型，也就是字符串类型，是Redis中最简单的存储类型
其value是字符串，不过根据字符串的格式不同，又可以分为3类：
string：普通字符串int：整数类型，可以做自增、自减的操作float：浮点类型，可以做自增、自减操作 具体操作：
set &lt;key&gt; &lt;value&gt; 设置指定的值get &lt;key&gt; 获取指定的值append &lt;key&gt; &lt;value&gt;将给定的追加到原值的末尾strlen &lt;key&gt;获取值的长度setnx &lt;key&gt; &lt;value&gt; 只有在key不存在时设置key的值incr &lt;key&gt;将key中存储的数字值增1
只能对数字值操作，如果为空，新增值为1decr &lt;key&gt;将key中存储的数字值减1
只能对数字之操作，如果为空,新增值为-1incrby /decrby &lt;key&gt; 步长将key中存储的数字值增减，自定义步长mset &lt;key1&gt; &lt;value1&gt; &lt;key2&gt; &lt;value2&gt;同时设置一个或多个key-value对(一个key-value设置失败，都失败)mget &lt;key1&gt; &lt;key2&gt; &lt;key3&gt;同时获取一个或多个valuemsetnx &lt;key1&gt; &lt;value1&gt; &lt;key2&gt; &lt;value2&gt;同时设置一个或多个key-value对，当且仅当所有给定的key都不存在getrange &lt;key&gt; &lt;起始位置&gt; &lt;结束位置&gt;获得值的范围(两边都是闭区间)setrange &lt;key&gt; &lt;起始位置&gt; &lt;value&gt;用覆盖所存储的字符串值，从&lt;起始位置&gt;开始setex &lt;key&gt; &lt;过期时间&gt; &lt;value&gt;设置键值的同时，设置过期时间，单位秒getset &lt;key&gt; &lt;value&gt;以新换旧,设置了新值的同时获取旧值 更多请查看手册Redis 字符串(String)_redis教程
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d48411297918b32d192b72ffa27f6eca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b64e9c8758e33ece793cbfa3e9c81d31/" rel="bookmark">
			Java冒泡排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		冒泡排序是一种简单的排序算法，它通过比较和交换相邻元素的方式，使得列表中的元素逐渐移动到正确的位置。具体步骤如下：
从列表的第一个元素开始，比较它与下一个元素的大小。如果顺序不对（前面的元素大于后面的元素），则交换这两个元素的位置。继续比较和交换下一对相邻元素，直到列表末尾。重复上述步骤，每次都将最大的元素移动到列表的最后，直到整个列表有序。 下面是用Java实现冒泡排序的示例代码：
public class BubbleSort { // 普通冒泡排序 public static void bubbleSort(int[] arr) { int n = arr.length; for (int i = 0; i &lt; n - 1; i++) { for (int j = 0; j &lt; n - i - 1; j++) { if (arr[j] &gt; arr[j + 1]) { // 交换 arr[j] 和 arr[j + 1] 的位置 int temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; } } } } // 优化后的冒泡排序，增加了一个标志位，减少不必要的比较 public static void optimizedBubbleSort(int[] arr) { int n = arr.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b64e9c8758e33ece793cbfa3e9c81d31/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0cca1896af665961f81b60b49d89d520/" rel="bookmark">
			Java选择排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		选择排序是一种简单直观的排序算法，其基本思想是每一轮从待排序的元素中选择最小（或最大）的元素，将其与当前位置的元素交换。选择排序的实现步骤可以简要概括为：
初始化： 遍历整个数组，将当前位置的元素标记为最小（或最大）。选择： 在未排序的部分中找到最小（或最大）的元素的索引。交换： 将最小（或最大）的元素与当前位置的元素进行交换。移动： 将标记的位置移动到下一个未排序的元素。重复： 重复以上步骤，直到整个数组有序。 以下是使用Java实现选择排序的代码：
public class SelectionSort { public static void selectionSort(int[] arr) { int n = arr.length; for (int i = 0; i &lt; n - 1; i++) { // 步骤 1：假设当前位置是最小元素的位置 int minIndex = i; // 步骤 2：在未排序的部分中找到最小元素的索引 for (int j = i + 1; j &lt; n; j++) { if (arr[j] &lt; arr[minIndex]) { minIndex = j; } } // 步骤 3：交换最小元素与当前位置的元素 if (minIndex !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0cca1896af665961f81b60b49d89d520/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/19/">«</a>
	<span class="pagination__item pagination__item--current">20/321</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/21/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>