<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13d92e9a8f60bd9948b43f83508ae592/" rel="bookmark">
			教妹学Java(三十八)：instanceof 操作符的用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		你好呀，我是沉默王二，（目前是）CSDN 周排名前十的博客专家。这是《教妹学 Java》专栏的第三十五篇，今天我们来谈谈 Java 的 instanceof 关键字——instanceof 操作符有哪些用法？
本专栏中的代码已收录到 GitHub github.com/itwanger ，里面还有我精心为你准备的一线大厂面试题。
三妹开学了，学的计算机软件编程。她学校离我家很近，坐公交车也就 10 站路的距离， 每逢周末她都会来找我，让我辅导她学习 Java。作为一名拥有十余年编程经验的程序员，再加上父母给我们的这份血缘关系，我觉得义不容辞。
“二哥，今天我们要学习的内容是‘instanceof 操作符’，对吧？”看来三妹已经提前预习了我上次留给她的作业。
“是的，三妹。instanceof 操作符主要用来判断对象属于哪种类型。 ”我面带着朴实无华的微笑回答着她，“可能是某个类，某个子类或者某个接口。”
“Java 中的 instanceof 操作符的返回结果为 true 或者 false，true 表示对象属于指定的类型，false 表示不属于。如果我们拿 instanceof 和值为 null 变量进行比较，返回结果都是 false。”
----正儿八经的分割线，正文开始------------
来看下面这个示例：
/** * @author 微信搜「沉默王二」，回复关键字 PDF */ public class Simple { public static void main(String[] args) { Simple simple = new Simple(); System.out.println(simple instanceof Simple); } } 在上面这个例子中，我们使用 instanceof 判断 simple 这个引用变量是不是 Simple 类。输出结果如下所示：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/13d92e9a8f60bd9948b43f83508ae592/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47e439d7d79ade8b54d7d04884cc9e63/" rel="bookmark">
			vue3配置src下http里index.ts文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import axios, { AxiosInstance, AxiosRequestConfig, AxiosError, AxiosResponse, } from "axios"; import nprogress from "nprogress"; import { message } from "ant-design-vue"; //创建axios实例 const service: AxiosInstance = axios.create({ baseURL: "/api", timeout: 10000, }); //请求拦截 service.interceptors.request.use( (config: AxiosRequestConfig): AxiosRequestConfig =&gt; { nprogress.start(); //前后端鉴权 //jwt:JSON WEB TOKEN //登陆成功之后后端会返回一个令牌 const token = localStorage.getItem("token"); // if (token) { // //需要在请求头中添加token // config.headers["Authorization"] = token; // } else { // message.error("请重新登录"); // } return config; }, (err: AxiosError) =&gt; { nprogress.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/47e439d7d79ade8b54d7d04884cc9e63/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f47336a2b0f7ae69ec8d66b554633af0/" rel="bookmark">
			Python开发Windows桌面应用程序（二）简单应用程序实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 上编blog说到用Python开发Windows桌面应用程序的环境搭建，下面就说说如何实现一个简单的远程日志读取的功能。
界面绘制 打开界面绘制工具，选中项目后，右键找到External Tools,然后选择QtDesigner
打开Qt Designer工作台，然后我们选择Main Window就可以在这个画布上尽情的绘制我们需要的界面呈现样式了
我绘制好的界面如下（远程查询Linux服务器上的日志）
我这里做的功能非常简单，连接服务器，然后查询设备对应的原始数据，这里有两个按钮，我们首先给按钮绑定点击事件
然后弹出按钮配置界面
因为我们绑定的是点击事件，所以这里选择第一个clicked()
点击最后一步的+号，创建一个点击事件，然后点击OK即可
将创建好的界面保存后，我们回到pycharm可以看到.ui文件
最后将.ui文件通过PyUIC转成对应的.py文件
最后我们看一下.py文件
# -*- coding: utf-8 -*- # Form implementation generated from reading ui file 'MainForm.ui' # # Created by: PyQt5 UI code generator 5.15.0 # # WARNING: Any manual changes made to this file will be lost when pyuic5 is # run again. Do not edit this file unless you know what you are doing.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f47336a2b0f7ae69ec8d66b554633af0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49c782df2db7f2b14a1f393786512a7d/" rel="bookmark">
			Ubuntu18-安装vmtk
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		官网教程：http://www.vmtk.org/download/
ubuntu 配置 vmtk :https://www.jianshu.com/p/c3bd28972ca0
按照这下面的流程一步一安装：
1. 安装 python 依赖包(等会 VMTK 要用)
sudo apt-get install python-dev libqt4-dev sudo mkdir /usr/lib/python2.7/config/ sudo cp /usr/lib/python2.7/config-x86_64-linux-gnu/libpython2.7.so /usr/lib/python2.7/config/libpython2.7.so 2. 开始着手安装 VMTK (基本是按照官网流程)
sudo apt-get install git cd ~/Downloads git clone https://github.com/vmtk/vmtk.git sudo apt-get install libxt-dev libgl1-mesa-glx libgl1-mesa-dev libglapi-mesa libosmesa-dev build-essential mkdir vmtk-build cd vmtk-build //如果有了安装包那只要在build文件夹下进行下面的，上面下载源码就不要了 cmake ../vmtk -DPYTHON_INCLUDE_DIR=/usr/include/python2.7 -DPYTHON_LIBRARY=/usr/lib/python2.7/config/libpython2.7.so make -j8 #漫长的等待 在make -j8这一步出了很多问题
1：使用Git clone代码失败的解决方法
fatal: The remote end hung up unexpectedly fatal: 过早的文件结束符(EOF) fatal: index-pack failed 查了一下，发现上因为Git限制了推送数据的大小导致的错误。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/49c782df2db7f2b14a1f393786512a7d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37c5ff0f9633b9592a9e73d06f6c5295/" rel="bookmark">
			多媒体技术选择题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		理论上 。USB1.1的最高传输速率为12Mbps。 USB2.0的最高传输速率为480Mbps。
实际上 。只要小于理论值的数字就行了
Flash MX 软件 制作网络交互动画的编辑工具
Photoshop软件 是处理图像、图形的工具
电话质量采样频率 11.025kHz
关于 dpi 的叙述
1、每英寸像索点
2、dpi 越高图像质量越低
Flash 动画是以 关键帧 为基础的帧动画
Photoshop 截图快捷键 ： (Alt+Print Screen&gt; 键
USB1． 1 接口的传输速率是 （1.5MB／s）
在 MPEG中使用了哪两种熵编码方法？ (A )
（A）哈夫编码和自适应二进制算术编码 （B）PCM编码和 DPCM编码
（C）预测编码和变换编码 （A）统计编码和算术编码
1、多媒体技术的主要特性不包括©
A.多样性 B.集成性 C. 娱乐性 D.交互性
2、IEEE 1394接口的数据传输速率可以高达 （C）
A.200Kbps B. 100Mbps C. 400Mbps D.100Gbps
3、在MPC外部设备中，U盘属于 （） D
A. 输入设备 B. 播放设备 C.人机交互设备 D.存储设备
外存储器 : 软盘、硬盘、U盘、
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/37c5ff0f9633b9592a9e73d06f6c5295/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2be133d33a8c0292fd3a55f5c9beb07/" rel="bookmark">
			Centos7离线安装GCC
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		gcc是编译c语言的一个工具，一般来说都会存在，但是有些情况镜像安装没选择，可能系统就没带gcc工具。我们在安装redis和nginx的时候又必须要gcc环境。今天就说下离线环境的gcc安装。
#查看gcc版本号 gcc -v 首先下载gcc的rpm压缩包（这个是我在iso镜像文件解压后的Packages目录下获取的，这里如果是centos7可以直接用）
百度网盘下载gcc.tar.gz: https://pan.baidu.com/s/1ixDi3BZ1O7ImUObrbf40Rw
密码: 9vic
安装包有如下文件
mpfr-3.1.1-4.el7.x86_64.rpmcpp-4.8.5-39.el7.x86_64.rpmgcc-4.8.5-39.el7.x86_64.rpmglibc-devel-2.17-307.el7.1.x86_64.rpmglibc-headers-2.17-307.el7.1.x86_64.rpmkernel-headers-3.10.0-1127.el7.x86_64.rpmlibmpc-1.0.1-3.el7.x86_64.rpm 下载完成开始安装
1、上传gcc.tar.gz到 目标服务器 /usr/local/
2、安装
#解压gcc tar -zxf gcc.tar.gz cd gcc #rpm安装gcc rpm -Uvh *.rpm --nodeps --force #检测gcc是否安装成功 gcc -v 看到如下信息那么就安装成功了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65079ffead1be36f80ca11bd083504dc/" rel="bookmark">
			ROS 的时候遇到Website may be down
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装 ROS 的时候遇到Website may be down情况. sudo rosdep init ERROR: cannot download default sources list from: https://raw.githubusercontent.com/ros/rosdistro/master/rosdep/sources.list.d/20-default.list Website may be down. Website down的原因 可以看到raw.githubusercontent.com这个网站的原因，因为是国外的网站，由于防火墙的原因，会出现一些问题。
我们直接打开rosdep的地址：
github.com/ros/rosdistro
解决方法 首先到如下网站所需包下载：
https://github.com/ros/rosdistro
也可以打开终端输入以下指令：
git clone https://github.com/ros/rosdistro.git 具体步骤 修改下载下来的包中rosdep/source.list.d下的文件20-default.list
将其中为raw.githubusercontent.com的url地址全部修改为本地文件的地址。
# os-specific listings first yaml file:///home/xxx/rosdistro/rosdep/osx-homebrew.yaml osx # generic yaml file:///home/xxx/rosdistro/rosdep/base.yaml yaml file:///home/xxx/rosdistro/rosdep/python.yaml yaml file:///home/xxx/rosdistro/rosdep/ruby.yaml gbpdistro file:///home/xxx/rosdistro/releases/fuerte.yaml fuerte # newer distributions (Groovy, Hydro, ...) must not be listed anymore, they are being fetched from the rosdistro index.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/65079ffead1be36f80ca11bd083504dc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23ed7126a31b95013700bfd6027531b9/" rel="bookmark">
			Excel多区间判断，其实很简单
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 多区间判断的问题想必大家都遇到过，比如成绩评定、业绩考核等等。今天就和大家分享一个多区间判断的函数公式套路。
先来看问题，要根据A1单元格中的业绩给出对应的等级，划分规则是：
&lt;60，等级为“F”。
60~69，等级为“E”。
70~79，等级为“D”。
80~89，等级为“C”。
90~99，等级为“B”。
&gt;=100，等级为“A”。
下面咱们就简单汇总一下常用的解决方法和思路。
1、IF函数
=IF(A1&gt;=100,"A",IF(A1&gt;=90,"B",IF(A1&gt;=80,"C",IF(A1&gt;=70,"D",IF(A1&gt;=60,"E","F")))))
通过IF函数嵌套，像剥洋葱一样逐层判断A1数值所在的区间，并返回对应的结果。
大于等于100，返回“A”，大于等于90，返回“B”，大于等于80，返回“C”……
这个公式的优点是易于理解，缺点是如果有多个判断条件，公式会变得越来越长了。
还有一个问题，使用IF函数进行多个区间的判断时，小伙伴们可以记住一个窍门，就是可以从最高的规则部分开始，逐级向下判断。也可以从最低的规则部分开始，逐级向上判断。刚刚这个公式，就可以写成：
=IF(A1&lt;60,"F",IF(A1&lt;70,"E",IF(A1&lt;80,"D",IF(A1&lt;90,"C",IF(A1&lt;100,"B","A")))))
2、LOOKUP
=LOOKUP(A1,{0,60,70,80,90,100},{"F","E","D","C","B","A"})
这种写法是多区间判断并返回对应值的模式化公式，是IF函数逐层判断的升级版。
注意，LOOKUP第二参数要升序处理{0,60,70,80,90,100}。
LOOKUP函数以A1为查找值，返回第二参数中小于等于A1的最大数值，也就是要找所有弟弟中的大弟弟，并第三参数{"F","E","D","C","B","A"}中对应位置的字符串。
3、建立对照
接下来这种方法看起来不够牛逼了，需要先在Excel中建立一个对照表：
然后使用VLOOKUP函数在对照表中执行近似匹配的查询：
=VLOOKUP(A1,D2:E7,2)
这里有两点需要注意：
1、是对照表中的首列使用升序排序；
2、是VLOOKUP函数省略第四参数，返回精确匹配值或近似匹配值。如果找不到精确匹配值，则返回小于待查询内容（A1）的最大值。
相对于其他公式，建立对照表的方法看似繁琐，但是在实际应用中更便于修改标准，而不必重新编辑公式。
4、MATCH函数
=MID("FEDCBA",MATCH(A1,{0,60,70,80,90,100}),1)
MATCH函数的作用是查询某个内容在一行或一列中的位置。
本例中MATCH函数使用A1单元格的内容作为查询值，在第二参数{0,60,70,80,90,100}中用近似匹配的方式查找A1所处的位置，返回的结果用作MID函数的第二参数。
MID 函数在文本字符串"FEDCBA"中截取字符串，截取的指定开始位置，就是由MATCH函数计算出的结果，截取的字符串长度为1。
这个公式相对比较复杂一些，看不懂的小伙伴们也不必纠结，先简单做个了解就好。
四个公式，四种不同的思路，你最喜欢哪一种呢？
今天的内容就是这些，祝各位小伙伴们一天好心情！
图文制作：祝洪忠
●Python 会交互的绘图库 Plotly！
●取数，取数，取个屁啊！
后台回复“入群”即可加入小z数据干货交流群 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2328c81e47cef6bb4e2f80d769897781/" rel="bookmark">
			基于MATLAB的新冠病毒传播元胞自动机模拟
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		鉴于2020年2月的新型冠状病毒的爆发，病毒在人群中的传播过程引起了人们的关注，这里用元胞自动机简单地模拟病毒在人群中传播的过程。
数据的初始化 以下代码设置GUI按键以及初始化人群分布，这里我把人群的分布作为二维上的正态分布。
计算二维散点的正态分布可以用matlab中的mvnrnd函数
具体用法为（以双变量为例）：先构造该两个变量的均值向量，再构造协方差矩阵，输入为mvnrnd（均值向量，协方差矩阵，想得到的点的个数），该函数的输出为n行2列的矩阵，每一行中的两个元素分别代表所得的正态分布的点的行下标，列下标（假设在一个以均值点为中心无限大的矩阵中的二维正态分布投点）。
% 设置GUI按键 plotbutton=uicontrol('style','pushbutton','string','运行', 'fontsize',12, 'position',[150,400,50,20], 'callback', 'run=1;'); erasebutton=uicontrol('style','pushbutton','string','停止','fontsize',12,'position',[250,400,50,20],'callback','freeze=1;'); quitbutton=uicontrol('style','pushbutton','string','退出','fontsize',12,'position',[350,400,50,20],'callback','stop=1;close;'); number = uicontrol('style','text','string','1','fontsize',12, 'position',[20,400,50,20]); total_num=100; n=100; mu=[50,50];% 均值向量 Sigma=[200 0;0 200];% 协方差矩阵 r=mvnrnd(mu,Sigma,total_num); r=fix(r); z = zeros(n,n); k=sub2ind(size(z),r(:,1),r(:,2));%得到人的坐标的序列索引 healthy = z;inf=z;carrier=z;cardate=z;%初始化三种类型的人群的矩阵以及携带日期的矩阵 first=randi([10,90]); healthy(k)=200;healthy(k(first))=0;%一开始没有感染者 carrier(k(first))=200;cardate(k(first))=1;%初始化携带者天数矩阵 % 建立图像句柄 主体循环部分
% 主事件循环 stop= 0; run = 1;freeze = 0; while stop==0 if run==1 %先进行感染判断 [x11,y11]=find(inf~=0); m=[];n=[]; for i=1:length(x11) m=[m;x11(i)-2:x11(i)+2]; n=[n;y11(i)-2:y11(i)+2]; m(m&lt;1)=1;m(m&gt;100)=100; n(n&lt;1)=1;n(n&gt;100)=100; end %m的每一行为距离感染者为2以内的行坐标 %n的每一行为距离感染者为2以内的列坐标 %接下来判断这个以感染者为中心5*5的矩阵中是否有健康人 x22=[];y22=[];fm=0; if ~isempty(m) fm=length(m(:,1)); end for i=1:fm mat=healthy(m(i,:),n(i,:));%某个感染者附近的坐标 [x21,y21]=find(healthy(m(i,:),n(i,:))~=0);%healthy(m(i,:),n(i,:)是5*5的矩阵，其第几行就代表m那一行的第几个元素，n同理对应列下标 x22=[x22,m(i,x21)];y22=[y22,n(i,y21)]; end for i=1:length(x22) pro=rand;a=pro&gt;0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2328c81e47cef6bb4e2f80d769897781/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6ece77cb6a3c6464d1e96c3007ec7bc/" rel="bookmark">
			redis从入门到精通（十五）——— docker redis-sentinel哨兵集群及java实战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		docker redis-sentinel哨兵集群及java实战
一、docker环境准备
1、VM安装centos-7 安装详情见https://blog.csdn.net/chaojiangroke/article/details/108660782
2、安装centos-7版docker 安装详细见https://blog.csdn.net/chaojiangroke/article/details/108666791
3、为redis集群自定义网段 docker network create --subnet=172.18.0.0/16 net-redis
二、redis主从（一主两从）
1、下载redis镜像 docker pull redis:version
2、查看镜像 docker images
3、修改准备好的redis.conf配置文件 具体配置详见：https://blog.csdn.net/chaojiangroke/article/details/108485270
讲解几个重要配置：
1）bind配置，如果bind选项为空或0.0.0.0的话，那会接受所有来自于可用网络接口的连接
bind 0.0.0.0
2）守护进程的方式进行启动：daemonize yes
3）配置密码： requirepass 123456
4）配置docker宿主机IP作为哨兵模式暴露的ip
cluster-announce-ip 192.168.233.128 #我的docker宿主机ip
Master：
端口：port 6379
关闭镜像rdb持久化，注释掉所有的save配置；
#save 900 1
#save 300 10
#save 60 10000
关闭aof持久化，appendonly no
Slave：
端口：port 6380 和 6381
开启rdb持久化和aof持久化；
save 900 1
save 300 10
save 60 10000
配置master： replicaof masterIp masterPort
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c6ece77cb6a3c6464d1e96c3007ec7bc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6619c93c6d8025e61fce32212a23d7d7/" rel="bookmark">
			如何删除 Mac 储存空间的其他选项？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Mac的储存是非常宝贵的，尤其是用着128G或者256G的小伙伴。当存储空间几乎已满时，Mac可能会开始变慢并且运行不正常，因此了解磁盘上正在使用的空间并清除随时间累积的冗余文件非常重要。
打开Mac的储存空间，大部分都很容易识别，照片，视频，音乐，文档等！但您还会发现一个名为其他的占了许多的内存。那么什么是其他呢？是不是可以直接删除它，或者应不应该删除。
##什么是Mac其他文件？
通过转到关于本机，可以基本了解Mac上占用的空间。
单击Apple徽标。
转到关于本机。
选择存储。等待它计算。
最终，您将看到一个条形图，显示出哪种类型的文件正在Mac上占用空间，类似于此图像：
在上面的图片中，黄色是照片，红色是应用程序，浅蓝色是消息，紫色是音乐，深蓝色是邮件，浅蓝色是iCloud Drive，灰色是系统。
而其他是最大的存储消费者，在我们的示例中为38.55GB，您可能想知道其他是什么。
尽管文件类型的大多数主要类别都很简单，但“其他”种类却可能是一个谜。如果不是音乐，文档，视频，照片或应用，那会是什么？
系统将标签“其他”应用于不完全适合这些类型的文件，例如安装程序包，缓存文件，旧备份，应用程序扩展，临时文件等。大多数都是不需要的，但是它们必须存储在某个地方，因此它们会被转储到“其他”类别中。
##如何查看正在占用其他存储空间的内容
您可以使用通过“关于本机”&gt;“存储”访问的工具来管理Mac上所有类型的存储所占用的资源。接下来只需单击“管理”，您将看到类似以下的屏幕。
但是，虽然您可以在系统上进行各种工作，例如选择将文件存储在iCloud中，或查看文件以减少混乱，但您根本无法在此处访问“其他”（请注意左侧栏中的其灰色状态）
那么，如何找出“其他”中的内容？
要查看所有“其他”空间都用完了什么，您需要转到“资料库”文件夹，因为通常是其他大部分内容的存储位置。
根据系统的设置，您可能无法在常规Finder窗口中看到Library文件夹，因此直接跳转到该文件夹的最简单方法是执行以下步骤：
打开查找器。
单击菜单栏中的“ 转到”选项。
选择转到文件夹。
然后输入〜/ library，然后按Enter。
现在，您将看到一长串文件夹，其中大多数将包含被视为“其他”的文件。缓存和应用程序支持是一些不错的开始，但是您需要深入研究一下可以安全删除其中的子文件夹。
在开始执行此操作之前，请仔细查看，因为删除其中一些文件可能会影响Mac的工作方式！
##我可以删除其他文件吗？
是的，但是您需要小心。诸如安装留下的.dmg文件之类的显而易见的东西很好，但是当您开始使用缓存文件和其他更钝的类型时，您可能会很快遇到问题。例如，从不再使用的旧应用程序中删除缓存不会造成任何问题。但是，如果您从使用的应用中删除一个，那么它将立即忘记您的所有选项和其他详细信息。
基本上，经验法则是，如果您不确定某个文件夹是什么或做什么，请不要理会。当然，一如既往，我们强烈建议您在开始删除任何内容之前运行系统的完整备份，以避免灾难。
##如何删除其他文件
当您位于Library文件夹中时，其他文件的删除方式与任何普通文件相同。
但是以这种方式删除某些文件可能会在Mac上留下一些残留，尽管如此，我们还是建议您使用一种专用的Mac清洁软件包来帮助您避免任何代价高昂的错误。
我们推荐最好的一款软件是CleanMyMac X，CleanMyMac X具有系统分析功能，可以突出显示冗余文件，同时保留那些仍在定期使用的文件。然后，如果要删除它们，只需单击一个按钮，而不用拖拽数百个子文件夹并希望您不要删除任何必需的东西即可。
[dl]15-31[/dl]
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c0809165fa67316630fbe4d9f27c6e4/" rel="bookmark">
			Pytorch实现Resnet训练CIFAR10数据集（完整代码，可进一步优化）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Pytorch实现Resnet训练CIFAR10数据集（完整代码，包含resnet-50,resnet-101） 首先之前有写Pytorch的入门教程博客如果没有安装pytorch具体可转链接
废话不多说，直接上代码 这个代码使用CUDA 训练，如果不想使用GPU，可以将device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')注释掉，并且把所有后面用到的将tensor转到GPU的代码一起.to(device)删掉
CIFAR10数据集下载不动的这里有下载好的网盘链接（提取码5tk8），直接解压存入代码文件上一层的文件夹中
import torch import torch.nn as nn import torchvision import torchvision.transforms as transforms # 判断是否有GPU device = torch.device('cuda' if torch.cuda.is_available() else 'cpu') num_epochs = 50 #50轮 batch_size = 50 #50步长 learning_rate = 0.01 #学习率0.01 # 图像预处理 transform = transforms.Compose([ transforms.Pad(4), transforms.RandomHorizontalFlip(), transforms.RandomCrop(32), transforms.ToTensor()]) # CIFAR-10 数据集下载 train_dataset = torchvision.datasets.CIFAR10(root='../data/', train=True, transform=transform, download=True) test_dataset = torchvision.datasets.CIFAR10(root='../data/', train=False, transform=transforms.ToTensor()) # 数据载入 train_loader = torch.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8c0809165fa67316630fbe4d9f27c6e4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/174dfd848c17be723011278623f3eb5e/" rel="bookmark">
			vim: command not found 绝妙解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		出现 command not found 的原因是没有安装 xxx mac 系统有预装 vim，直接可使用，可以通过 vim --version 来查看版本等信息。
不建议删除或更新系统预装的Vim，推荐新安装Vim的Mac实现--MacVim。
出现错误的原因 在安装软件修改环境变量时，不小心把环境变量删除或者搞乱了，导致vim不可使用。 两个解决方案 1. 安装MacVim 教程地址：https://zhuanlan.zhihu.com/p/64024294
（ 我没有亲自安装过，仅提供上述地址作参考。）
2. 不安装，仅临时使用vim （ 本人亲测好使。）
# 第一步：执行临时使用vim命令 export PATH=/usr/bin:/usr/sbin:/bin:/sbin:/usr/X11R6/bin # 第二步：正常使用即可哈哈 例如我们现在进行环境变量的添加
# ①：vim ~/.bash_profile 打开环境变量编辑文件；
# ②：按 i 键，后即可写入；
# ③：写入完成，按 esc 退出编辑；
# ④：输入 :wq 保存并关闭；（若此时遇到 readonly option is set （add！to override），执行 :wq! 强制保存退出）
# ⑤：执行 source ~/.bash_profile 让前面编辑的 vim ~/.bash_profile 文件生效；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/746a1ed87b5fbe7013af21fc78bc4de4/" rel="bookmark">
			CSS标签
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CSS 语法由三部分构成：选择器、属性和值： selector {property: value}
2.CSS的基本写法
h1,h2,h3,h4,h5,h6 {
color: green;
font-family: Verdana, sans-serif;
color: #000;
background: #fff; margin: 0; padding: 0;
}
3.派生选择器=上下文选择器
li strong {
font-style: italic; font-weight: normal; }
&lt;li&gt;&lt;strong&gt;我是斜体字。这是因为 strong 元素位于 li 元素内。 &lt;/strong&gt;&lt;/li&gt;
4.id选择器，用#号+选择器名称
#study {
font-family:sans-serif;
background:fff;
}
#blue p{
font-family:Verdana;
margin:0;
padding:0;
}
#blue tr{
font-family:Verdana;
margin:0;
padding:0;
}
即使被标注为 blue的元素只能在文档中出现一次，这个 id 选择器作为派生选择器也可以被使用很多次：
#pashen li strong{
color:#00ff11;
font-style:italic;
}
5.类选择器用.号+类选择名 .color {
color:#009988; }
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/746a1ed87b5fbe7013af21fc78bc4de4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ef0231ccdc232386a1f479439cd54b5/" rel="bookmark">
			2020低压电工模拟考试及低压电工模拟考试题库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题库来源：安全生产模拟考试一点通公众号小程序
2020低压电工模拟考试及低压电工模拟考试题库，包含低压电工模拟考试答案解析及低压电工模拟考试题库练习。由安全生产模拟考试一点通公众号结合国家低压电工考试最新大纲及低压电工考试真题出具，有助于低压电工模拟考试题库考前练习。
1、【判断题】安全可靠是对任何开关电器的基本要求。（ √ ）
2、【判断题】中间继电器的动作值与释放值可调节。（ × ）
3、【判断题】在串联电路中,电路总电压等于各电阻的分电压之和。（ √ ）
4、【判断题】对于转子有绕组的电动机,将外电阻串入转子电路中启动,并随电机转速升高而逐渐地将电阻值减小并最终切除,叫转子串电阻启动。（ √ ）
5、【判断题】使用改变磁极对数来调速的电机一般都是绕线型转子电动机。（ × ）
6、【判断题】为保证零线安全,三相四线的零线必须加装熔断器。（ × ）
7、【判断题】铜线与铝线在需要时可以直接连接。（ × ）
8、【判断题】触电事故是由电能以电流形式作用人体造成的事故。（ √ ）
9、【判断题】变配电设备应有完善的屏护装置。（ √ ）
10、【判断题】接触器的文字符号为FR。（ × ）
11、【判断题】低压断路器是一种重要的控制和保护电器，断路器都装有灭弧装置，因此可以安全地带负荷合、分闸。（ √ ）
12、【判断题】在带电灭火时，如果用喷雾水枪应将水枪喷嘴接地，并穿上绝缘靴和戴上绝缘手套，才可进行灭火操作。（ √ ）
13、【判断题】交流发电机是应用电磁感应的原理发电的。（ √ ）
14、【判断题】为了安全可靠,所有开关均应同时控制相线和零线。（ × ）
15、【判断题】雷电时,应禁止在屋外高空检修、试验和屋内验电等作业。（ √ ）
16、【判断题】热继电器的双金属片弯曲的速度与电流大小有关，电流越大，速度越快，这种特性称正比时限特性。（ × ）
17、【判断题】测量交流电路的有功电能时，因是交流电，故其电压线圈、电流线圈和各两个端可任意接在线路上。（ × ）
18、【判断题】电气安装接线图中，同一电器元件的各部分必须画在一起。（ √ ）
19、【判断题】按照通过人体电流的大小，人体反应状态的不同，可将电流划分为感知电流、摆脱电流和室颤电流。（ √ ）
20、【判断题】电容器的容量就是电容量。（ × ）
21、【判断题】当电容器测量时万用表指针摆动后停止不动，说明电容器短路。（ √ ）
22、【判断题】并联电路中各支路上的电流不一定相等。（ √ ）
23、【判断题】PN结正向导通时,其内外电场方向一致。（ × ）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1ef0231ccdc232386a1f479439cd54b5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2137d5b45d50730f273e73fb10854492/" rel="bookmark">
			Gmsh剖二维网格教程附代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、点，三角形的定义1. 点的定义2. 三角形的定义 二、区域构造三、调用Gmsh的API剖网格并得到网格信息1. 剖网格部分代码2. 获取网格的所有点的代码3. 获取网格的所有三角形的代码4. 获取最外围边界边上和内部洞的边上的点的代码5. 获取内部洞的边上的三角形的代码6. 获取最外围的边上的三角形的代码 四、程序运行结果1. 程序输出2. 带有点标号的结果图3. 没有点标号的结果图 五、总结 前言 Gmsh的安装与入门教程可以去看我的前一篇文章有限元剖网格之Gmsh安装与使用入门。本篇文章主要介绍如何借助Gmsh的C++ API剖二维网格(即三角形)。
一、点，三角形的定义 利用Gmsh剖的二维网格，一般是为了后续有限元计算的需要，后面也会给出一篇有限元的文章。此处主要是为了Gmsh前期的输入，由点连线构成多边形，以及最后利用Gmsh得到网格后对三角形信息的存储。
1. 点的定义 class Point { public: Point(const double x = 0, const double y = 0, const double z = 0):_x(x), _y(y), _z(z) { } ~Point() { } const double getX() const {return _x;} const double getY() const {return _y;} const double getZ() const {return _z;} void setX(const double x) {_x = x;} void setY(const double y) {_y = y;} void setZ(const double z) {_z = z;} bool operator &lt; (const Point&amp; p) const; protected: double _x, _y, _z; }; bool Point::operator &lt; (const Point&amp; p) const { double px = p.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2137d5b45d50730f273e73fb10854492/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31748f64dc53a4adf2fcdf87e64ace1a/" rel="bookmark">
			R语言数据分析第二节
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、向量二、矩阵1.创建矩阵2.矩阵运算2.矩阵索引2.矩阵元素筛选2.矩阵值的改变2.矩阵应用2.矩阵应用1.列表的常规操作 一、向量 寻找水仙花数
代码如下（示例）：
#寻找水仙花数 nums &lt;-100:999 first.num &lt;- nums %/%100 second.num &lt;- (nums%%100)%/%10 third.num &lt;- nums%%10 nums [(first.num^3 + second.num^3 + third.num^3) == nums] 运行结果
判断因子
代码如下（示例）：
nums&lt;-1:6 c[6%%c==0] 判断完数
代码如下（示例）：
nums &lt;- 1:(6/2) sum(nums[6%%nums == 0])== 6 二、矩阵 1.创建矩阵 代码如下（示例）：
#创建矩阵 m&lt;-matrix(1:8, nrow= 2) #Q:按行创建矩阵 m&lt;- matrix(1:8, nrow= 2, byrow=T) m matrix(c(1，5,2,6,3,7,4,8),nrow = 2)#byrow参数知识改变了数据的输入顺序，矩阵本身依然是按列存储 2.矩阵运算 代码如下（示例）：
ml &lt;-matrix(1:4, nrow =2) m2&lt;- matrix(2:7, nrow = 2) ml ; m2 ml + m2 ml &lt;- matrix(1:4, nrow = 2) m2 &lt;- matrix(2∶3, nrow= 1) ml ; m2 ml + m2 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/31748f64dc53a4adf2fcdf87e64ace1a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c92dd7228e50065670571a872b22146/" rel="bookmark">
			win10系统迁移到固态（傻瓜式--分区助手）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写在前面 系统迁移的好处 相比较重装系统，
数据保留的好点可以保留正版的系统
可选的软件：分区助手（国产软件，傻瓜式，不涉及到收费功能）DiskGenius（相比交分区助手，专业性强一点【使用需要PE启动盘】） 分区助手 下载 点击上方“下载”跳转至官网下载界面，因为系统迁移不涉及到收费功能版块儿，就直接去官网下载了。注意进入页面后下滑，找到绿色版点击下载。 下方还有PE版本，这里讲的傻瓜教程，就不说那些东西了。
下载完成后。
这里我下载完成后是一个zip文件，文件名为PAGreen，因为是免安装版，目录中东西较为繁杂，这里简单介绍使用。
文件解压后，找到文件中的PartAssist.exe 文件运行即可。打开应用 点击 “迁移系统到固态盘”(图中红色箭头)，然后跟着向导来就行，这里要注意几点，
1. 一般买回来的固态硬盘都是没什么问题的，但是你的原本的机械硬盘可能就有问题了，需要先进行** 磁盘检查 **（可以跳过， 迁移过程中会进入分区助手自带PE系统，若是中间出现错误，错误代码为 33 的话，在回来检查）
选原来的系统盘，右键-&gt;高级操作-&gt;检测错误-&gt;检测分区是否有坏扇区-&gt;确定
一般情况是没有错误的，（若有错误，因为错误在C盘，修复需要用PE系统，运行DiskGenius等修复坏道的应用进行修复，修复后，可以直接在PE系统上用分区助手进行迁移操作，也可以回到原本win10系统操作 ，因本篇为为初级，这里不介绍了，网上很多教程，有需要可以去研究。）
到这一步，我们需要做的基本就完成了，只需要等待一段时间（40分钟左右）没有出现错误的话，便是会迁移完成。 注意事项 固态装到电脑上后是未分区状态，不需要管他，若是迁移前已经将固态盘分区，可以通过分区助手，右键选择固态盘，然后删除全部分区就行。若出现错误，可根据相应提示，到网站上查询。我遇到过的就是 33 对应的是磁盘有坏道，找教程进行修复即可注意迁移系统前，看看系统盘占用空间的大小，若已占用空间大于固态的空间是迁移不了的。若太多冗余杂乱，且没有重要数据的话，建议直接重装系统到固态盘。 结语 1、官方教程参考
2、建议迁移前，下载备份软件，将系统盘备份后再进行这些操作，数据无价。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cdf32cf1f36607e19def2bbfe89d923a/" rel="bookmark">
			java中移位运算＜＜左移 ＞＞右移 ＜＜＜无符号右移 详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		java中移位运算&lt;&lt;左移 &gt;&gt;右移 &lt;&lt;&lt;无符号右移 详解 目录
java中移位运算&lt;&lt;左移 &gt;&gt;右移 &lt;&lt;&lt;无符号右移 详解
概念
代码举例
过程解释
&lt;&lt;左移
&gt;&gt;右移
&gt;&gt;&gt;无符号右移
实际应用
概念 &lt;&lt;:左移	左边最高位丢弃，右边补齐0 &gt;&gt;:右移	最高位是0，左边补齐0；最高为是1，左边补齐1 &gt;&gt;&gt;:无符号右移 无论最高位是0还是1，左边补齐0 1.左移
左移运算符“&lt;&lt;” - 使指定值的所有位都左移规定的次数。
左移m&lt;&lt;n 代表把数字m在无溢出的前提下乘以2的n次方。
例如，5&lt;&lt;3 就是5乘以2的3次方，结果是40。
2.右移
右移运算符“&gt;&gt;” - 使指定值的所有位都右移规定的次数。
右移m&gt;&gt;n 代表把数字m除以2的n次方，原来是正数的还是正数，负数还是负数。注意，如果是单数，也就是二进制末位为1，则结果是将m除以2的n次方的整数商。
例如，16&gt;&gt;3 就是16除以2的3次方，结果是2。
15&gt;&gt;3 就是14(15-1)除以2的3次方，结果是1。
3.无符号右移
无符号右移运算符“&gt;&gt;&gt;” - 同右移，但是结果全变正数。
代码举例 class OperatorDemo { public static void main(String[] args) { //&lt;&lt; 把&lt;&lt;左边的数据乘以2的移动次幂 System.out.println(3 &lt;&lt; 2); //3*2^2 = 3*4 = 12; //&gt;&gt; 把&gt;&gt;左边的数据除以2的移动次幂 System.out.println(24 &gt;&gt; 2); //24 / 2^2 = 24 / 4 = 6 System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cdf32cf1f36607e19def2bbfe89d923a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7947b6497b5356ff79010eb0c357ef85/" rel="bookmark">
			开会，就是浪费生命
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		只要你身在职场
就逃不出各种会议
而你之所以不喜欢线上开会
是因为它真的让人心累...
1
听不清
2
推理
3
误会
4
误会2
5
人齐
6
尴尬
7
无间道
8
顶配
9
懂了
·
·
·
·
·
难道开会只能这么痛苦吗！
难道时间只能这么被白白浪费吗？
不！
腾！讯！会！议！不！答！应！
长按图片扫描二维码或点击阅读原文 ↓ 了解腾讯会议如何让你更会开会 ↓
B Y / 赞助：腾讯会议
构图/绘图： 糙 、赵三、阿毛
版权归©️吓脑湿所有，已授权第三方机构代为维权，
转载须经授权，翻版必究
-往期文章精选-
(点击图片跳转）
-
吓脑湿
开脑相见，严肃活泼 带你洞悉互联网世界
↑长按图片识别二维码，一键关注，不要错过网海相遇的缘分
↓点击阅读原文，不再心累
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb228d6fcc737bf1152570af54e893d0/" rel="bookmark">
			Pytorch:cifar10官方例程代码复盘，详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		笔者暑假跑了一个简单的cifar10分类来进行深度学习入门，当时不求甚解，很多地方没有理解，于是最近就将全部代码仔细复盘了一下，期间踩了些坑，同时写下自己的理解，不正确之处还请大佬斧正。
先附上官方例程的代码。
https://pytorch.org/tutorials/
以下是我的代码，对官方例程进行了一些修改，在代码中每一句都有标注。
import torch from torch import nn from torchvision import models import torchvision import torchvision.transforms as transforms import torch.utils.data as Data import torch.optim as optim import torch.nn.functional as F device = torch.device("cuda:0" if torch.cuda.is_available() else"cpu") #调用cuda，两种方式，一种是张量.cuda()，一种是张量.to(device) transform = transforms.Compose( #数据预处理，张量化与归一化，在torchvision.datasets时调用 [transforms.ToTensor(), transforms.Normalize((0.5,0.5,0.5),(0.5,0.5,0.5))] ) #下载与载入torchvision中提供的cifar10数据集，root为数据集下载路径，可以使用相对路径也可以使用绝对路径 dataset = torchvision.datasets.CIFAR10(root='/home/ericzhao/下载',train=True,transform= transform,target_transform=None,download=True) trainloader = Data.DataLoader(dataset,batch_size=4,shuffle=False,num_workers=2) #训练集的载入，batch_size对训练效果有影响，后面再讨论 testset = torchvision.datasets.CIFAR10(root = '/home/ericzhao/下载',train=False,transform = transform,download=True) testloader = Data.DataLoader(testset,batch_size = 4,shuffle=False,num_workers=2 ) #因为cifar10是一个十分类数据集，所以定义它的十个类别 classes = ('plane','car', 'bird', 'cat', 'deer', 'dog', 'frog', 'horse', 'ship', 'truck') #自定义一个网络，继承父类nn.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eb228d6fcc737bf1152570af54e893d0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c96eb104e635fe0152ef41eec330bdd5/" rel="bookmark">
			2020氧化工艺实操考试视频及氧化工艺在线考试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题库来源：安全生产模拟考试一点通公众号小程序
2020氧化工艺实操考试视频及氧化工艺在线考试，包含氧化工艺实操考试视频答案解析及氧化工艺在线考试练习。由安全生产模拟考试一点通公众号结合国家氧化工艺考试最新大纲及氧化工艺考试真题出具，有助于氧化工艺怎么考考前练习。
1、【判断题】 环境危害极大的“酸雨”中主要成分为二氧化硫。（ √ ）
2、【判断题】 我国对水污染排放物实行总量控制。（ √ ）
3、【判断题】 甘油往复泵在启动前,应将泵内液体充满。（ × ）
4、【判断题】 在旋转机器房作业的人员必须穿齐、穿好有关的工作服,戴好工作帽。不许有敞怀、无扣、扎腰绳等现象发生。（ √ ）
5、【判断题】 职业中毒是指在生产过程中使用的有毒物质或有毒产品,以及生产中产生的有毒废气、废液、废渣引起的中毒。（ √ ）
6、【判断题】 有机化合物的反应一般为离子反应,反应速率较慢。（ × ）
7、【判断题】 任何单位和个人不得伪造、变造、买卖职业卫生技术服务机构资质证书。（ √ ）
8、【判断题】 不得安排怀孕女职工,在33℃以上的高温天气作业及室内温度在35℃以上的工作场所作业。（ × ）
9、【判断题】 现场应急处置措施。针对可能发生的火灾、爆炸、危险化学品泄漏、坍塌、水患、机动车辆伤害等,从操作措施、工艺流程、现场处置、事故控制,人员救护、消防、现场恢复等方面制定明确的应急处置措施。（ √ ）
10、【判断题】 建设项目投入使用后应马上进行安全验收评价。（ × ）
11、【判断题】 润滑脂在常温下成半固体状。（ √ ）
12、【判断题】 冷泵其实相当于油泵的排气。（ × ）
13、【判断题】 离心泵抽空时,会产生剧烈振动。（ √ ）
14、【判断题】 纯净的气体不会产生静电。（ √ ）
15、【判断题】 往复式压缩机排气阀盖特别热、排气量减少则可以判断该排气阀有故障。（ √ ）
16、【判断题】 关键词是为了文献标引工作,从论文中选取出来,用以表示全文主要内容信息款目的单词或术语,一般选用3-8个词作为关键词。（ √ ）
17、【判断题】 灭火器配置场所的火灾种类应根据该场所内的物质及其燃烧特性进行分类。（ √ ）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c96eb104e635fe0152ef41eec330bdd5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b5951d0620eb6bffe0d6ad468d8abb6/" rel="bookmark">
			深度神经网络DNN（三）——前向传播
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 神经网络与NumPy多维数组矩阵乘法神经网络内积 简单神经网络实现符号确认各层间信号传递代码实现小结 小结 神经网络与NumPy 为了实现神经网络的前向传播，我们首先来看一下NumPy多维数组的运算。掌握了NumPy多维数组的运算，就可以高效地实现神经网络。
多维数组 多维数组就是“数字的集合”，数字排成一列的集合、排成长方形的集合、排成三维状或者（更加一般化的）N维状的集合都称为多维数组。下面我们就用NumPy来生成多维数组。
一维数组 import numpy as np A = np.array([1, 2, 3, 4]) print(A) print(np.ndim(A)) print(A.shape) # 运行结果 [1 2 3 4] 1 (4,) 数组的维数可以通过np.dim()函数获得。数组的形状可以通过实例变量shape获得，上例中，A是一维数组，由4个元素构成，这里的A.shape的结果是个元组（tuple），二维数组时返回的是元组(4,3)，三维数组时返回的是元组(4,3,2)，…
二维数组 B = np.array([[1,2], [3,4], [5,6]]) print(B) print(np.ndim(B)) print(B.shape) # 运行结果 [[1 2] [3 4] [5 6]] 2 (3, 2) 这里生成了一个3×2的数组B。3×2的数组表示第一个维度有3个元素，第二个维度有2个元素。另外，第一个维度对应第0维，第二个维度对应第1维（Python的索引从0开始）。二维数组也称为矩阵（matrix）。数组的横向排列称为行（row），纵向排列称为列（column）。
矩阵乘法 下面，我们来介绍矩阵（二维数组）的乘积。比如2×2的矩阵，其乘积可以像下图这样进行计算：
矩阵的乘积是通过左边矩阵的行（横向）和右边矩阵的列（纵向）以对应元素的方式相乘后再求和而得到的。并且，运算的结果保存为新的多维数组的元素。比如，A的第1行和B的第1列的乘积结果是新数组的第1行第1列的元素，A的第2行和B的第1列的结果是新数组的第2行第1列的元素。这个运算在Python中可以用如下代码实现：
A = np.array([[1,2], [3,4]]) B = np.array([[5,6], [7,8]]) C = np.dot(A, B) print(C) # 运行结果 [[19, 22],[43, 50]] 这里，A和B都是2×2的矩阵，它们的乘积可以通过NumPy的np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b5951d0620eb6bffe0d6ad468d8abb6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6cd7cf6ae007eb482427fb25d9479efe/" rel="bookmark">
			使用formData向后台传递数组对象
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.前端
let formDatas = new FormData(); let sealValues = t.sealValues; formDatas.append('pdfFile', t.parsePdfFile); for(let i=0,len=sealValues.length;i&lt;len;i++){ let locationInfo = sealValues[i]; formDatas.append('sealLocationInfoList['+i+'].posX',locationInfo.posX); formDatas.append('sealLocationInfoList['+i+'].posY',locationInfo.posY); formDatas.append('sealLocationInfoList['+i+'].signOnPage',locationInfo.signOnPage); formDatas.append('sealLocationInfoList['+i+'].sealId',locationInfo.sealId); } 2.后端接收
@RequestMapping(path = "/stamp", method = RequestMethod.POST) public ResponseEntity&lt;Map&lt;String, Object&gt;&gt; stamp( HttpServletRequest req, @Param("pdfFile") MultipartFile pdfFile, SealLocationInfoRequest request ) { // } 3.后台映射对象
public class SealLocationInfoRequest implements Serializable { private static final long serialVersionUID = 2392716281569231777L; private Long contractId; private String filePath; private List&lt;SealLocationInfo&gt; sealLocationInfoList; }
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6cd7cf6ae007eb482427fb25d9479efe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e540d7d3687538b27bdaca423b730d84/" rel="bookmark">
			Error:svn: E155037: Previous operation has not finished； run ‘cleanup‘ if it was interrupted
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 SVN更新代码时出错：Error:svn: E155037: Previous operation has not finished; run 'cleanup' if it was interrupted
翻译过来的意思就是，上一次的操作未完成，如果被中断，运行“cleanup”。
因为我是使用idea更新代码的，直接使用idea自带的命令行就可以了
如果提示 “另一个程序正在使用此文件，进程无法访问”，关掉再运行就可以了。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2689a01eaf4f602087ba062c418940f7/" rel="bookmark">
			ARM指令整理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 ARM指令概述 1.1 概述 RISC：精简指令集（Reduced Instruction Set Computer)
在通道中只包含最有用的指令
确保数据通道快速执行每一条指令
使CPU硬件结构设计变得更为简单
RISC CPU包含较少的单元电路，因而面积小、功耗低
1.2 程序执行 1、在正常程序执行过程中，每执行一条ARM指令，程序计数器寄存器（PC）的值加4个字节；每执行一条Thumb指令，程序计数器寄存器（PC）的值加2个字节。整个过程是顺序执行。
2、通过跳转指令，程序可以跳转到特定的地址标号处执行，或者跳转到特定的子程序处执行。其中，B指令用于执行跳转操作；BL指令在执行跳转操作的同时，保存子程序的返回地址；BX指令在执行跳转操作的同时，根据目标地址的最低位可以将程序状态切换到Thumb状态；BLX指令执行3个操作：跳转到目标地址处执行，保存了子程序的返回地址，根据目标地址的最低位可以将程序状态切换到Thumb状态。
3、当异常中断发生时，系统执行完当前指令后，将跳转到相应的异常中断处理程序处执行。在当异常中断处理程序执行完成后，程序返回到发生中断的指令的下一条指令处执行。在进入异常中断处理程序时，要保存被中断的程序的执行现场，在从异常中断处理程序退出时，要恢复被中断的程序的执行现场。
1.3 特点 ARM7具有3级流水线结构（取指、译码、执行），对大多数指令来说每条流水线的处理都是单周期的，不过某些情况下，取指和执行的周期数会延长，导致流水线进入stall状态，指令执行时间超过1个周期。
PC代表程序计数器，流水线使用三个阶段，因此指令分为三个阶段执行：1.取指（从存储器装载一条指令）；2.译码（识别将要被执行的指令）；3.执行（处理指令并将结果写回寄存器）。
R15（PC）总是指向“正在取指”的指令，而不是指向“正在执行”的指令或正在“译码”的指令。一般来说，将“正在执行“的指令作为参考点，称之为当前第一条指令，因此PC总是指向第三条指令。当ARM状态时，每条指令为4字节长，所以PC始终指向该指令地址加8字节的地址，即：PC值=当前程序执行位置+8；现在PC指向的是正在取指的地址，那么CPU正在译指的指令地址是PC-4（假设在ARM状态下，一个指令占4个字节），CPU正在执行的指令地址是PC-8，也就是说PC所指向的地址和现在所执行的指令地址相差8。当突然发生中断的时候，保存的是PC的地址.这样就知道了，如果返回的时候返回PC，那么中间就有一个指令没有执行，所以用SUB pc lr-irq #4
r0-r12：通用寄存器，其中r8-r12只能被32位指令访问。
r13（SP）：堆栈指针；线程模式时可以在线程堆栈和主堆栈之间切换，但处理模式只使用主堆栈。两个堆栈同一时刻只有一个可见，进入、退出异常时自动切换堆栈。
r14（LR）：链接寄存器，保存子程序或异常的返回地址（要实现嵌套，必须入栈）。
r15（PC）：程序计数器。
xPSR：特殊用途的程序状态寄存器。
2 指令整理 ARM的指令有很多很多，通过功能分类，大致统计为：处理器内传送数据；存储器访问；算术运算；逻辑运算；移位和循环 移位运算；转换(展开和反转顺序)运算；位域处理指令；程序流控制(跳转﹑条件跳转﹑条件执行和函数调用）；乘累加(MAC)指令；除法指令；存储器屏障指令；异常相关指令；休眠模式相关指令；其他指令。 当然，Cortex-M4处理器还支持增强DSP指令：SIMD运算和打包指令；快速乘法和 MAC指令；饱和运算；浮点指令(前提是浮点单元存在）。 接下来逐个分类整理介绍16种不同的指令。
使用最高的指令有 B,BL;MOV,MVN;LDR,STR;ADD,SUB,ADC,SBC,MUL;AND,ORR,XOR,TST,BIC;CMP;LDM,STM;nop。
2.1 处理器内传送数据 其中MOV,MVN使用较多。
2.2 存储器访问 其中LDR,STR使用较多。
2.3 算术运算 2.4 逻辑运算 2.5 移位和循环 移位运算 2.6 转换(展开和反转顺序)运算 2.7 位域处理指令 2.8 程序流控制(跳转﹑条件跳转﹑条件执行和函数调用） 2.9 乘累加(MAC)指令 2.10 除法指令 2.11 存储器屏障指令 2.12 异常相关指令 2.13 休眠模式相关指令 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2689a01eaf4f602087ba062c418940f7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/452daf9d60e5e57bb88002b4c22ae3b8/" rel="bookmark">
			NLP学习（十二）-NLP实战之LSTM进行文本情感分析-tensorflow2&#43;Python3
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		情感分析简介 文本情感分析（Sentiment Analysis）是自然语言处理（NLP）方法中常见的应用，也是一个有趣的基本任务，尤其是以提炼文本情绪内容为目的的分类。它是对带有情感色彩的主观性文本进行分析、处理、归纳和推理的过程。
本文将介绍情感分析中的情感极性（倾向）分析。所谓情感极性分析，指的是对文本进行褒义、贬义、中性的判断。在大多应用场景下，只分为两类。例如对于“喜爱”和“厌恶”这两个词，就属于不同的情感倾向。
本文将详细介绍如何使用深度学习模型中的LSTM模型来实现文本的情感分析。
文本介绍及语料分析 我们以某电商网站中某个商品的评论作为语料（corpus.csv），该数据集的下载网址为：https://github.com/renjunxiang/Text-Classification/blob/master/TextClassification/data/data_single.csv ，该数据集一共有4310条评论数据，文本的情感分为两类：“正面”和“反面”
接着我们需要对语料做一个简单的分析：
数据集中的情感分布；
数据集中的评论句子长度分布。
使用以下Python脚本，我们可以统计出数据集中的情感分布以及评论句子长度分布。
# -*- coding: utf-8 -*- import pandas as pd import matplotlib.pyplot as plt from matplotlib import font_manager from itertools import accumulate # 统计句子长度及长度出现的频数 df = pd.read_csv('../testdata/data_single.csv') print(df.groupby('label')['label'].count()) df['length'] = df['evaluation'].apply(lambda x: len(x)) len_df = df.groupby('length').count() sent_length = len_df.index.tolist() sent_freq = len_df['evaluation'].tolist() # 绘制句子长度及出现频数统计图 plt.bar(sent_length, sent_freq) plt.title("句子长度及出现频数统计图") plt.xlabel("句子长度") plt.ylabel("句子长度出现的频数") plt.savefig("./句子长度及出现频数统计图.png") plt.show() plt.close() # 绘制句子长度累积分布函数(CDF) sent_pentage_list = [(count/sum(sent_freq)) for count in accumulate(sent_freq)] # 绘制CDF plt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/452daf9d60e5e57bb88002b4c22ae3b8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61a510a2f433afb496f6db0fb79761de/" rel="bookmark">
			正在创建系统还原点_如何使Windows在启动时自动创建系统还原点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		正在创建系统还原点
By default, System Restore automatically creates a restore point once per week and also before major events like an app or driver installation. If you want even more protection, you can force Windows to create a restore point automatically every time you start your PC.
默认情况下，“系统还原”会每周一次并且在重大事件(例如应用程序或驱动程序安装)之前自动创建一个还原点。 如果需要更多保护，则可以强制Windows在每次启动PC时自动创建一个还原点。
System Restore is an important tool that can help you recover from many different types of problems. The only trouble is that when restoring to a previous restore point, you reverse many of the changes made to your PC since that restore point was created.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/61a510a2f433afb496f6db0fb79761de/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/704a60bd5a498eda39d32a48742632df/" rel="bookmark">
			Java中super关键字介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由于子类不能继承父类的构造方法，因此，如果要调用父类的构造方法，可以使用 super 关键字。super 可以用来访问父类的构造方法、普通方法和属性。
super 关键字的功能：
在子类的构造方法中显式的调用父类构造方法访问父类的成员方法和变量。 1、使用super调用父类的构造方法 super必须是子类构造方法中头一条语句
当我们在父类中定义多个构造方法时，应当包括一个不带参数的构造方法，以防子类省略super时出现错误。
声明父类 Person 和子类 Student，在 Person 类中定义一个带有参数的构造方法，代码如下：
public class Person { public Person(String name) { } } public class Student extends Person { } 会发现 Student 类出现编译错误，提示必须显式定义构造方法，错误信息如下：
Implicit super constructor Person() is undefined for default constructor. Must define an explicit constructor
在本例中 JVM 默认给 Student 类加了一个无参构造方法，而在这个方法中默认调用了 super()，但是 Person 类中并不存在该构造方法，所以会编译错误。
如果一个类中没有写任何的构造方法，JVM 会生成一个默认的无参构造方法。在继承关系中，由于在子类的构造方法中，第一条语句默认为调用父类的无参构造方法（即默认为 super()，一般这行代码省略了）。所以当在父类中定义了有参构造方法，但是没有定义无参构造方法时，编译器会强制要求我们定义一个相同参数类型的构造方法。 子类 Student 继承了 Person 类，使用 super 语句来定义 Student 类的构造方法。示例代码如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/704a60bd5a498eda39d32a48742632df/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee51ae8798e6a04a489ec16c10f445d1/" rel="bookmark">
			安装Ubuntu18.04基于VirtualBox
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 安装Ubuntu18.04–基于VirtualBox 环境信息 镜像：ubuntu-18.04.5-desktop-amd64.iso
镜像下载地址：https://mirrors.aliyun.com/ubuntu-releases/18.04/ubuntu-18.04.5-desktop-amd64.iso
虚拟化软件：Oracle VM VirtualBox
安装步骤 打开VirtualBox 点击Oracle VM VirtualBox管理器界面左上角的【新建】，进入新键虚拟电脑界面，输入对应的信息，如下图所示，在该界面点击【下一步】 进入内存大小设置界面，选择默认大小即可，点击【下一步】 进入虚拟硬盘设置界面，选择【现在创建虚拟硬盘】，点击【创建】 弹出创建虚拟硬盘界面，所有选项保持默认即可，最后点击【创建】完成虚拟机创建 完成虚拟机创建后，Oracle VM VirtualBox管理器界面会出现一个Ubuntu18.04的虚拟机， 右键【Ubuntu 18.04】的虚拟机，点击【设置】 在弹出的设置界面，依次点击【存储】-【没有盘片】-【右上角的】
点击【选择一个虚拟光盘文件】
选择ubuntu-18.04.5-desktop-amd64.iso镜像，点击【打开】 返回设置界面后点击【OK】,完成设置 右键Ubuntu 18.04虚拟机，选择【启动】-【正常启动】 稍等几秒即会弹出虚拟机开机界面 左边界面选择自己喜欢的语言，点击【Install Ubuntu】开始安装 选择键盘模式，默认即可，点击【Continue】
默认即可，尽量不要选择Download updates while installing Ubuntu，这需要消耗很多时间，点击【Continue】
默认即可，点击【Install Now】 在弹出的界面，点击【Continue】 在地图上找到shanghai，如下图所示，点击【Continue】 设置用户名和密码，点击【Continue】 开始安装,这个过程需要等待好长一段时间 注：如果在这里还进入联网更新，可断开网卡并点击【skip】，跳过联网更新即可快速安装完系统
安装完成后，点击【Restart Now】 敲一下【回车】 输入密码，点击【sign In】进入系统 整个安装过程到此完成，开始进入Ubuntu系统玩耍吧 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19bbf74432c030c468a738c6b626be9b/" rel="bookmark">
			OPPO 芯片设计 面经
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		9月11日一面，17日二面
问的比较深，涉及综合DFT内容
刚成立规模就很大，oppo铁了心做芯片了
一面
29分钟，视频
自我介绍，项目介绍
芯片供电电压
fp时mem的处理
pr需要输入哪些文件
timing怎么修
换cell用什么cell
multi vt的比例
芯片规模
verilog水平怎么样
了解sdc吗，pr和综合sdc有什么不同
了解scan chain吗
脚本水平如何
python中list有哪些操作
一共写过多少行代码
用python还做过什么
解释一下笔试分数为什么比较低
(先进工艺，三轮面试，CS flow均有)
二面
40分钟，视频
自我介绍
项目介绍
PR各阶段有什么要关注的
7nmPR有什么要关注的
了解finfet吗
解释useful skew的原理
timng borrow有什么坏处
解释ccopt原理
降频对setup hold有什么影响
参数类型提取方式
项目意义，后续改进
意向城市
（已有80人团队，block级需要负责综合dft至PV全流程，两个月集体培训)
HR面
15分钟，视频
自我介绍
自我评价，并解释
家庭情况
最痛苦的事
最成功的事
获奖情况
工作遇到争执怎么处理
项目中怎么与他人分工合作
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea7e2d672486687408e956cd247735e1/" rel="bookmark">
			Android 禁止应用颜色跟随深色模式设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		总结解决方法：自己用的是&lt;style name="AppTheme" parent="Theme.AppCompat.NoActionBar"&gt;，需要修改为&lt;style name="AppTheme" parent="Theme.AppCompat.Light.NoActionBar"&gt;
在系统设置为深色模式后，发现应用中的部分文字从默认颜色变为了白色，CardView从白色变成了黑色（大多数文字和组件颜色没有变化），丑到爆了
很容易发现有变化的文字是因为没有设置textcolor，于是给他们加上之后，又给所有的cardview设置了background，但是发现文字不会改变，但cardview依然会变成深色。。
赶紧看了一下文档https://developer.android.google.cn/guide/topics/ui/look-and-feel/darktheme，希望能有禁用深色模式的方法，但根据文档里的意思，应用应该默认不会跟随系统的深色模式呀，只有手动设置后才会跟随深色模式。
在应用中支持深色主题背景
如要支持深色主题背景，您必须将应用的主题背景（通常可在 res/values/styles.xml 中找到）设置为继承 DayNight 主题背景：
&lt;style name="AppTheme" parent="Theme.AppCompat.DayNight"&gt;
您还可以使用 MaterialComponent 的深色主题背景：
&lt;style name="AppTheme" parent="Theme.MaterialComponents.DayNight"&gt;
这会将应用的主要主题背景与系统控制的夜间模式标记相关联，并将应用的默认主题背景设置为深色主题背景（如果已启用）。
去看了一下styles文件，果然被设置过了
&lt;style name="AppTheme" parent="Theme.AppCompat.DayNight"&gt;
修改了一下
&lt;style name="AppTheme" parent="Theme.AppCompat.NoActionBar"&gt;
再次运行，发现没有作用，Cardview依旧会跟随深色。。公司的项目被几个人修改过，各种配置已经比较乱了，也不敢乱改，切到自己的demo试了一下，发现默认的应用是不会跟随深色模式的，经过对比才发现，demo的styles是
&lt;style name="AppTheme" parent="Theme.AppCompat.Light.NoActionBar"&gt;
修改后，终于解决问题了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a96422a7285bb7ab0bb477819b4fa414/" rel="bookmark">
			函数的多种定义和调用方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、函数的定义方式 （1）函数发声明方式function关键字（命名函数） function fn(){ } （2）函数表达式（匿名函数） let fun=function(){} （3）new Function() let fn=new Function('参数1','参数2','函数体'); fn(); Function 里面的函数都必须是字符串格式第三种方式效率低，较少使用所有的函数都是Function的实例对象函数也是对象 2、函数的调用方式 （1）普通函数 function fn(){ console.log(1); } fn(); fn.call(); （2）对象的方法 let o={ sayHi:function(){ console.log(1); } } o.sayHi(); （3）构造函数 function Star(){ } new Star(); （4）绑定事件函数 btn.onclick=function(){} //触发 （5）定时器函数 setInterval(function(){},1000) //时间触发 一秒钟触发一次 （6）立即执行函数 (function(){ console.log(1)})(); //自动调用 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5dc6ffa0ddf8ad40439b0abd1c79c987/" rel="bookmark">
			[WINDOWS]解压tar.gz文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 安装git-gui windows版shift + 右键tar.gz文件所在目录，在当前目录运行git-bash；在弹出的cmd窗口中运行tar -zxvf xxx.tar.gz即可；git-bash 还可以在windows中运行grep进行文件内容搜索； 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7d8c535953b8a083b0975c6b56d0de1/" rel="bookmark">
			最详细！！！软考：初级程序员—思维导图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		软考复习之“葵花宝典” 给参加软考(初级程序员)小伙伴的一份指南 敲黑板ヽ(ｏ`皿′ｏ)ﾉ ！！！ 在这里有必要推荐一下 XMind 这款软件。这是总结和复习知识非常不错的一款软件，关键是免费 ！！！ 当然如果选择付费的话功能肯定会多一些。
关于XMind软件下载问题：网上有很多，下面给你们推荐几个入口
1、XMind_2020 安装
2、平台推荐：脚步之家、吾爱破解
3、官方下载链接: https://www.xmind.cn/xmind/thank-you-for-downloading/.
教材推荐： (第5版) 清华大学出版社—程序员教程，可以上淘宝或咸鱼捞一本
考试真题： 历年考试真题网站：链接: 希赛题库
软考资料：阿里网盘链接: 软考资料 【已更新】，思维导图也在里面哦！！！
历年考题资料说明：推荐大家去希赛题库网站看题，上面阿里网盘中的‘’软考真题‘’资料的题目中有一些大小写不大准确。
考试须知： 程序员考试 上午科目 和 下午科目 的考试形式与考核内容已经趋于稳定，考生应紧扣考试大纲和指南，有针对性地进行学习。本文针对近几年程序员级别的考题，分别就上午科目和下午科目的考核范围、形式和特点进行分析。
1、程序员上午试题分析和备考建议 分析近几年程序员上午试题的考试内容，其知识点和分值分布如表1所示
显然，在程序员上午科目的考题中，计算机应用、计算机系统、操作系统、程序设计语言、软件工程和面向对象技术、数据结构与算法、数据库系统基础知识是重点，一般情况下，这些问题的分值比重为75%左右。由于上午试题考试形式的局限性，必然不会出现较多的应用设计类问题，因此考生应该在基本概念和相关计算问题上多下工夫。笔者推荐考生参照官方推荐的教材进行学习和复习，因为该教材基本涵盖了所有上午试题内容(除了数学和英语)。
2. 程序员下午试题分析和备考建议 程序员下午科目主要考查程序设计能力。从2008年开始，VB程序设计题目开始减少，2009年的题目中取消了对VB程序设计题目。目前的考核内容和分值分布情况如表2所示。
程序员下午试题着重考查考生的实践和应用水平，要求考生具备一定的数学思维和逻辑推理能力。无论是完善算法流程还是编写程序代码，一般情况下，题目的说明部分都会给出一些算法思路和代码逻辑的相关线索，考生应该充分利用这些信息解答问题。有时题目的说明部分较长，给考生造成该题目较难的印象，实际上，题干叙述较长的题目为解答问题提供了更充足的信息，这种题目的难度反而不会高。
近两年，程序员下午考题的考核方式在保持传统(完善程序代码或算法步骤)的基础上，有一些变化需要考生注意。
(1) C语言程序中常见错误的分析和改正
编程时出现错误是难免的，若经常进行上机实验，这类考题应该不是难点。程序错误一般可分为语法错误和语义错误两类，语法错误在编译阶段就能发现，出现这类错误时程序不能运行。常见的语法错误有引用了未定义的变量、缺少分号或括号等，语义错误比较多，例如未将变量正确初始化、运算结果溢出、数组下标越界、混淆了“=”和“==”、函数调用的参数类型不匹配等。
程序中的有些错误比较直接，对C语言的语法和语义规则有一定基础的话，就能够轻松解答，有些错误则比较隐晦，需要熟悉C语言的难点和关键点，但是分值一般不会太大。
(2) C语言的指针
指针是C语言中的一个难点，每次的考题中或多或少都有一些题目涉及它。前几年的题目中，常以链表上的运算作为对指针的考核方式，因此，考生需要熟练掌握链表的定义、插入、删除和查找操作，其关键点是指针变量的初始化和在链表结点间的移动处理。
在近两年的考题中，对于指针的考核进一步深化，例如，关于指针常量和常量指针的概念、内存空间的申请和释放、指针参数以及函数返回指针等，使用指针时常出现的内存泄漏、野指针引用等问题。这些问题需要考生作为专题进行概念上的梳理和应用实践。
(3) C++、Java语言程序设计问题
考生需要在C++和Java中选择一种语言进行面向对象程序设计的基本训练。一般情况下，这两个问题的题目背景相同。在程序员下午考题的算法流程和C程序设计部分，更注重考查处理逻辑，而在C++和Java程序部分，则主要考查语法知识，因此考生应注重了解C++和Java语言的语法规则。
前方高能！！！ 最详细—软考初级程序员考试大纲 考试科目1—上午题 考试科目2—下午题
上午题—考试科目1：计算机与软件工程基本知识 下午题—考试科目2：程序设计 总结： 以上是小生给参加 "软考—初级程序员"和想考的小伙伴的个人分享，掌握好学习的方法，然后就是冲！！！爱拼才会赢！！！希望各位将要考试的小伙伴都能稳过~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e3c2330d3908e8001a6969bad5b373c/" rel="bookmark">
			安装eccodes运行代码出错解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为了在Windows下读取grib文件，在Anaconda环境下安装了xarray+cgrib+eccodes。参考WIndows下xarray+cgrib读取grib文件。
在Anaconda下新建虚拟环境安装相应的依赖库，参考Windows下Anaconda的下载,安装与使用。程序在Prompt中正确运行。但在Pycharm中新建project，更换Anaconda新建的虚拟环境下的python解释器运行，报错ECCODES ERROR : Unable to find boot.def. Context path=D:/bld/eccodes_1593015095851/_h_env/Library/share/eccodes/definitions.
一、在Anaconda的Prompt中运行程序 程序如下：
import xarray as xr filein = 'F:/Zhu/download/2000-2015/FNL/FNL2000/fnl_20000505_00_00' data = xr.open_dataset(filein, engine='cfgrib', backend_kwargs={'filter_by_keys':{'typeOfLevel': 'isobaricInhPa','level':500}}) print(data) 在Prompt下新建的虚拟环境中运行python …py，结果正常出现。
二、在pycharm中更换Anaconda解释器报错及解决 新建一个Project，将项目运行的python解释器更换为Anaconda虚拟环境下的解释器。
开始Project Interpreter是默认下载的python解释器，然后在右边的Add中添加新的解释器：
然后在Existing environment中选择你的Anaconda中新建的虚拟环境中的python解释器所在位置，应用即可。
运行上述程序，报错：
问题出现在eccodes环境变量的配置，在这篇博客中提到需要配置eccodes的环境变量：
但操作完也没什么用。
解决办法：最后在代码中夹一行设置变量的代码，就完美解决了。
import os os.environ['ECCODES_DEFINITION_PATH']='E:/Anaconda3/envs/tcintensity/Library/share/eccodes/definitions' 就是设置ECCODES_DEFINITION_PATH，这个路径是你在Anaconda中新建虚拟环境下安装的eccodes的路径。这样问题就解决了。
再次运行代码：
问题主要是出现在这个eccodes的路径上，有的博客说eccodes不需要配置环境变量，但在编译器中运行代码的时候找不到eccodes，这时候就可以把路径加在代码中，就解决问题了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/933a0f1742a1958a4d3d84231fe48b8c/" rel="bookmark">
			ERR_SSL_PROTOCOL_ERROR解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在项目中对接接口出现ERR_SSL_PROTOCOL_ERROR
可能是http和https使用出错造成的
进行替换即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5ac3da2c7159caeacf57c6ca679e24f/" rel="bookmark">
			什么是CNAS认证？为什么要选择具备CNAS资质的软件测试公司？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、什么是CNAS认证？
CNAS认证是中国合格评定国家认可委员会（China National Accreditation Service for Conformity Assessment）的缩写。由原中国认证机构国家认可委员会（英文简称为CNAB）和原中国实验室国家认可委员会（英文简称为CNAL）合并而成。
中国合格评定国家认可委员会是根据《中华人民共和国认证认可条例》的规定，由国家认证认可监督管理委员会批准设立并授权的国家认可机构，统一负责对认证机构、实验室和检查机构等相关机构的认可工作。
CNAS的宗旨是推进我国合格评定机构按照相关的标准和规范等要求加强建设，促进合格评定机构以公正的行为、科学的手段、准确的结果有效地为社会提供服务。
2、CNAS认证的作用
1.用于CNAS认证表示具备了按相应认可准则开展检测和校准服务的技术能力；
2.增强市场竞争能力，赢得有关部门、社会各界的信任；
3.获得签署互认协议方国家和地区认可机构的承认；
4.有机会参与国际间合格评定机构认可双边、多边合作交流；
5.可在认可的范围内使用CNAS国家实验室认可标志和ILAC国际互认联合标志；
6.列入获准认可机构名录，提高知名度；
6.用于CNAS认证资质的第三方软件评测公司，相对来说获得国家认证委的认可，更具有权威性和实力体现。
所以，在选择软件测试公司时，要认准具有CNAS、CMA等资质的第三方软件测试公司。
对于第三方软件测试企业来说，CNAS认证是一种认可，也是实力的体现。一般来说，一个城市同时拥有CNAS和CMA资质的企业非常少，这对的企业要求非常高！
3、具备CNAS认证的软件测试公司推荐
湖南卓码软件测评有限公司是一家第三方软件测试公司，并通过了中国合格评定国家认可委员会（CNAS）认可，保证了测试能力成熟度，出具的检测报告具有权威性和法律效力。专业从事软件测试服务，包括软件项目验收测试、科技成果鉴定测试、软件产品确认测试、浏览器兼容测试、测试外包服务等。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/842a0c548c75220fec96f724e87a56d6/" rel="bookmark">
			第九章 Maximum Variance Unfolding (MVU)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以上所有的算法都是kernel pca，唯一不同的是核函数不同。所有就有个问题，如果我们要做降维，哪个核函数更好？
核函数有哪些性质呢？
∣ x i − x j ∣ 2 = K i i + K j j − 2 K i j |x_i-x_j|^2=K_{ii}+K_{jj}-2K_{ij} ∣xi​−xj​∣2=Kii​+Kjj​−2Kij​ ∑ i j K i j = 0 \sum_{ij}K_{ij}=0 ∑ij​Kij​=0 K ⪰ 0 K \succeq 0 K⪰0 最好的标准是什么呢？maximum variance
max ⁡ T r ( K ) \max Tr(K) maxTr(K)
所以就变为了最优化问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e8f70818777ca65accc6b8250f5b8c13/" rel="bookmark">
			【spring cloud 第六篇】feign 中使用熔断器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1 需要修改的文件1.1 application.yml1.2 MyEurekaFeignClient1.3 新建 MyHystrix1.4 MyFeignService服务类1.5 查看结果 2 feign中使用hystrix dashboardpom文件添加依赖修改启动类查看结果， Feign的起步依赖中已经引入了Hystrix的依赖，所以在Feign中使用Hystrix不需要引入其他依赖，只需要在application.yml中配置如下： feign.hystrix.enabled = true，开启熔断机制，默认是false; 该demo在【spring cloud 第四篇】声明式调用 Feign
进行改造：
1 需要修改的文件 application.yml 配置文件MyFeignService.java 类MyEurekaFeignClient.java新增一个 MyHystrix.java 文件，并实现MyEurekaFeignClient
如下如：
1.1 application.yml feign.hystrix.enabled = true，开启熔断机制yml 文件中没有该提示，是IDEA的问题，不用理会 feign: hystrix: enabled: true # 文件中没有提示，不影响 1.2 MyEurekaFeignClient 在@FeignClient的注解的fallback配置加上快速失败的处理类（该处理类是Feign熔断器的逻辑处理类，必须实现被@FeignClient修饰的接口）本案例中的 MyHystrix就是实现了MyEurekaFeignClient /** * 添加 fallback = MyHystrix.class */ @FeignClient(value = "eureka-client-4",configuration = MyFeignConfig.class,fallback = MyHystrix.class) public interface MyEurekaFeignClient { /** * 调用 eureka-client-4 服务的getPort接口 * @PathVariable(name = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e8f70818777ca65accc6b8250f5b8c13/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd8a857da1951217a3235c6e4445f2e7/" rel="bookmark">
			HQL函数大全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HQL函数大全 一、关系运算 等值比较: =等值比较: &lt;=&gt;不等值比较: &lt;&gt;和!=小于比较: &lt;小于等于比较: &lt;=大于比较: &gt;大于等于比较: &gt;=区间比较: between and空值判断: IS NULL非空判断: IS NOT NULLlike比较: 使用通配符 like ‘%a%’| ‘_a_’|concat(’%’,’’,’%’)rlike操作: 使用正则表达式 A rlike 正则表达’[……]’regexp操作: regexp_replace(‘7311W中文’,’[[^\\\u4e00-\\\u9fa5]]’,’’)替换符合条件的字符串；
regexp_extract(string,需要匹配的正则表达式,0是显示与之匹配的整个字符串|1,2 是显示第一,二个括号里面的)取出符合条件的对应序号的字符串 二、数学运算： 加法操作: +减法操作: –乘法操作: *除法操作: /取余操作: %位与操作: &amp;位或操作: |位异或操作: ^位取反操作: ~ 三、逻辑运算： 逻辑与操作: AND 、&amp;&amp;逻辑或操作: OR 、||逻辑非操作: NOT、! 四、复合类型构造函数 map结构：{“张三”:23，“性别“:“male”}
（1）建定义字段 ：
smap map&lt;string,string&gt; comment ‘string型map’
imap map&lt;string,int&gt; comment ‘sring型map’ create table test3(field2 map&lt;string,string&gt;) row format delimited fields terminated by ',' collection items terminated by "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bd8a857da1951217a3235c6e4445f2e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7446e31619df42c39a02831f6babff5/" rel="bookmark">
			Docker学习笔记（三）—— Docker命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		帮助命令 # 查看docker版本 docker version # 显示docker系统的信息 docker info # 显示docker指令 docker --help 镜像命令 # 显示本地镜像 docker images docker images -a # 列出本地所有的镜像（含中间映像层，默认情况下，过滤掉中间映像层）-a, --all docker images --digests # 显示镜像的摘要信息 docker images --no-trunc # 显示完整镜像ID docker images -q # 只显示镜像ID -q, --quiet # 查找镜像 docker search IMAGE_NAME # 下载镜像 docker pull IMAGE_NAME:TAG # 默认TAG为latest # 上传镜像 docker tag IMAGE_NAME:TAG 10.253.84.6:8088/IMAGE_NAME:TAG docker login -u admin -p 123456 10.253.84.6:8088 docker push 10.253.84.6:8088/IMAGE_NAME:TAG #删除本地镜像 docker rmi IMAGE_NAME docker rmi -f IMAGE_NAME # 强制删除 -f, --force docker rmi -f IMAGE_NAME1 IMAGE_NAME2 # 删除多个 docker rmi -f $(docker images -qa) # 删除全部 docker rmi --no-prune IMAGE_NAME # 不移除该镜像的过程镜像，默认移除 容器命令 根本前提：有镜像才能创建容器
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f7446e31619df42c39a02831f6babff5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe9a3b335a978f006607f7e08ccfc836/" rel="bookmark">
			论文中et al.、etc.、e.g.、 i.e.的意思
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载自https://baijiahao.baidu.com/s？id=1646815827726889163&amp;wfr=spider&amp;for=pc
在英文论文写作中，经常会遇到常见的缩写，很容易搞混或写错。
e.g. etc. et al. i.e. 都是拉丁文的缩写，但在现代科技文献中仍广为使用。
下面就来介绍一下这些缩写到底是什么意思，该怎么用：
（1）et al. et al. 是用得最多的，一般在文中引用学者成果或者是参考文献时，罗列作者时的省略。
它的完整写法应该是 et alia，意为“等人，以及其他人”。
注：1、缩写时 et 后不要加“.”因为 et 不是缩写；
2、al 后面要加“.”因为是缩写；
3、如果et al. 在句子最后，不需要重复两个“.”；
4、如果后面跟“？ ！，”等标点，则还需要“.”;
5、et al. 的前面不要逗号。
如：These results agree with the ones published by Pelon et al.
（2）etc. 它的完整写法是 et cetera，意为“等等”。
一般将它放在列举的最后，表示前面的例子还没列举完。如：I need to go to the store and buy some pie, milk, cheese, etc.
注：1、etc. 前面要有逗号；
2、同样地，位于句尾时，不要加两个“.”
3、etc. 常常被误写为 ect.，这是因为很多英语的c在t前(c 在 t 后的很少)。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fe9a3b335a978f006607f7e08ccfc836/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6c79438774da2cc8e9226d716db737a/" rel="bookmark">
			keycloak api_使用Keycloak保护NestJS API
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		keycloak api
From the Keycloak website, “Keycloak is an open source identity and access management solution”. Today we’ll look at how to protect your HTTP API with Keycloak.
在Keycloak网站上，“ Keycloak是一种开源身份和访问管理解决方案”。 今天，我们将研究如何使用Keycloak保护您的HTTP API。 One of the modern ways to protect an HTTP API today is via the “Authorization: Bearer &lt;token&gt;” HTTP header and with the token being a JWT carrying the identity and the claims (roles, etc.) of the consumer of the API.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a6c79438774da2cc8e9226d716db737a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b66780239872a88b699acaa612b212c7/" rel="bookmark">
			2020电工（初级）模拟考试题及电工（初级）操作证考试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题库来源：安全生产模拟考试一点通公众号小程序
2020电工（初级）模拟考试题及电工（初级）操作证考试，包含电工（初级）模拟考试题答案解析及电工（初级）操作证考试练习。由安全生产模拟考试一点通公众号结合国家电工（初级）考试最新大纲及电工（初级）考试真题出具，有助于电工（初级）模拟考试题库考前练习。
1、【判断题】()刀开关由进线座、静触头、动触头、出线座、手柄等组成。（ √ ）
2、【判断题】()高压钠灯的发光效率高，但是透雾能力弱。（ × ）
3、【判断题】()市场经济条件下，应该树立多转行多学知识多长本领的择业观念。（ × ）
4、【判断题】()发现电气火灾后，应该尽快用水灭火。（ × ）
5、【判断题】()串联型稳压电路的调整管是工作在开关状态。（ × ）
6、【判断题】()在电阻分压电路中，电阻值越大，其两端分得的电压就越大。（ √ ）
7、【判断题】()串联使用的电容器，其容量小的电容承受的电压高。（ √ ）
8、【判断题】()电子元器件在焊接前要预先把元器件引线弯曲成一定的形状，提高电子设备的防震性和可靠性。（ √ ）
9、【判断题】()职业道德是人的事业成功的重要条件。（ √ ）
10、【判断题】()晶体管工作在放大状态时，发射结反偏，对于硅管约为0.7v，锗管约为0.3v。（ √ ）
11、【判断题】家庭使用的电路都是并联的()（ √ ）
12、【判断题】()普通螺纹的牙形角是60度，英制螺纹的牙形角是55度。（ √ ）
13、【判断题】()更换熔断器时，尽量选用相同型号规格的熔断器，并且要安装可靠。（ √ ）
14、【判断题】()单相电动机可分为两类，即：电容起动式和电容运转式。（ × ）
15、【判断题】()自动往返控制线路需要对电动机实现自动转换的点动控制才行。（ × ）
16、【判断题】()爱岗敬业作为职业道德的内在要求，指的是员工只需要热爱自己特别喜欢的工作岗位。（ × ）
17、【判断题】()三相异步电动机的常见故障有：电动机过热、电动机振动、电动机启动后转速低或转矩小。（ √ ）
18、【判断题】()P-6W型高压针式绝缘子，其型号的P代表弯脚，W代表针式绝缘子。（ × ）
19、【判断题】()接触器用来接通或断开电动机的主电路或其它负载电路的控制电器。（ √ ）
20、【判断题】()接触器是一种适用于远距离频繁接通和切断交直流小容量电路的自动控制电器。（ × ）
21、【判断题】()高压汞灯与高压钠灯启动方式相似。（ × ）
22、【判断题】()登高板使用后要整理好，挂在通风干燥处保存。（ √ ）
23、【单选题】电感元件的型号一般由主称、特征、型式等()部分组成。（ B ）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b66780239872a88b699acaa612b212c7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b6641ca06b174fd5d6bede3ec026295/" rel="bookmark">
			vue中的修饰符
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、事件修饰符 .stop 阻止事件继续传播
.prevent 阻止标签默认行为
.capture 使用事件捕获模式,即元素自身触发的事件先在此处处理，然后才交由内部元素进行处理
.self 只当在 event.target 是当前元素自身时触发处理函数
.once 事件将只会触发一次
.passive 告诉浏览器你不想阻止事件的默认行为
&lt;!-- 阻止单击事件继续传播 --&gt; &lt;a v-on:click.stop="doThis"&gt;&lt;/a&gt; &lt;!-- 提交事件不再重载页面 --&gt; &lt;form v-on:submit.prevent="onSubmit"&gt;&lt;/form&gt; &lt;!-- 修饰符可以串联 --&gt; &lt;a v-on:click.stop.prevent="doThat"&gt;&lt;/a&gt; &lt;!-- 只有修饰符 --&gt; &lt;form v-on:submit.prevent&gt;&lt;/form&gt; &lt;!-- 添加事件监听器时使用事件捕获模式 --&gt; &lt;!-- 即元素自身触发的事件先在此处处理，然后才交由内部元素进行处理 --&gt; &lt;div v-on:click.capture="doThis"&gt;...&lt;/div&gt; &lt;!-- 只当在 event.target 是当前元素自身时触发处理函数 --&gt; &lt;!-- 即事件不是从内部元素触发的 --&gt; &lt;div v-on:click.self="doThat"&gt;...&lt;/div&gt; &lt;!-- 点击事件将只会触发一次 --&gt; &lt;a v-on:click.once="doThis"&gt;&lt;/a&gt; &lt;!-- 滚动事件的默认行为 (即滚动行为) 将会立即触发 --&gt; &lt;!-- 而不会等待 `onScroll` 完成 --&gt; &lt;!-- 这其中包含 `event.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b6641ca06b174fd5d6bede3ec026295/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/79c4898711aa0cae7a1106c8b390ff98/" rel="bookmark">
			STM32CubeMX系列|外部中断
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		外部中断 1. 外部中断简介 STM32F1的每个IO口都可以作为外部中断的中断输入，STM32F103的中断控制器支持19个外部中断/事件请求。每个中断设有状态位，每个中断/事件都有独立的触发和屏蔽设置。STM32F103的19个外部中断为：
EXTI线0~15：对应外部IO口的输入中断EXTI线16：连接到PVD输出EXTI线17：连接到RTC闹钟事件EXTI线18：连接到USB唤醒事件EXTI线19：连接到以太网唤醒事件（互联网型产品） STM32F103供IO口使用的中断线只有16个，但是IO口却远不止16个。下图为GPIO跟中断线的映射关系图
2. 硬件设计 用到的硬件资源有：
指示灯D1、D2蜂鸣器BUZ4个按键：KEY_UP、K1、K2、K3 硬件连接原理图如下，注意K1、K2、K3是低电平有效的，而KEY_UP是高电平有效。因此K1、K2、K3应设置为上拉、下降沿触发中断，KEY_UP应设置为下拉、上升沿触发中断
STM32F103芯片单个IO口最大输出电流是25mA，而蜂鸣器的驱动电流是30mA左右，整个芯片的输出电流最大为150mA，如果在蜂鸣器上就消耗30mA，那么芯片的其他IO口及外设电流就比较拮据了，因此此处不会直接使用IO口驱动蜂鸣器，而是通过三极管把电流放大后再驱动蜂鸣器，这样IO口只需提供不到1mA的电流就可以控制蜂鸣器
本实验利用板载的4个按键，通过外部中断来控制板载的两个LED的亮灭和蜂鸣器。其中KEY_UP控制蜂鸣器；K1控制D1，按一次亮再按一次灭；K2控制D2，按一次亮再按一次灭；K3同时控制D1和D2，按一次它们的状态就翻转一次
3. 软件设计 3.1 STM32CubeMX设置 RCC设置外接HSE，时钟设置为72MPC0和PC2设置为GPIO推挽输出模式、上拉、高速、默认输出电平为高电平PB5设置为GPIO推挽输出、高速模式PA0设置为下拉、上升沿触发，PE2/3/4设置为上拉、下降沿触发 在NVIC(嵌套向量中断控制器)中，勾选EXIT Line0/2/3/4 interrupt，使能PA0和PE2/3/4中断。右边两个选项设置抢占优先级和响应优先级 输入工程名，选择工程路径（不要有中文），选择MDK-ARM V5；勾选Generated periphera initialization as a pair of ‘.c/.h’ files per IP ；点击GENERATE CODE，生成工程代码 3.2 MDK-ARM编程 在gpio.c文件中可以看到PC0/PC1/PB5/PA0/PE2/PE3/PE4管脚的初始化函数 void MX_GPIO_Init(void){ GPIO_InitTypeDef GPIO_InitStruct = {0}; /* GPIO Ports Clock Enable */ __HAL_RCC_GPIOE_CLK_ENABLE();	//开启GPIOE时钟 __HAL_RCC_GPIOC_CLK_ENABLE();	//开启GPIOC时钟 __HAL_RCC_GPIOA_CLK_ENABLE();	//开启GPIOA时钟 __HAL_RCC_GPIOB_CLK_ENABLE();	//开启GPIOB时钟 /*Configure GPIO pin Output Level */ HAL_GPIO_WritePin(GPIOC, LED1_Pin|LED2_Pin, GPIO_PIN_SET);	//LED1/LED2默认输出是电平为高电平 /*Configure GPIO pin Output Level */ HAL_GPIO_WritePin(BUZ_GPIO_Port, BUZ_Pin, GPIO_PIN_RESET);	//BUZ默认输出是电平为低电平	/*Configure GPIO pins : PE2 PE3 PE4 */ GPIO_InitStruct.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/79c4898711aa0cae7a1106c8b390ff98/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eea02972aa1effda9003ffb789c1ed8a/" rel="bookmark">
			‘utf-8‘ codec can‘t decode byte 0xc8 in position 0: invalid continuation byte
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决方法：
data =pd.read_csv(r’xxx.csv’,encoding = ‘gb2312’)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44dc063d1922a1235d8d674713eda6d1/" rel="bookmark">
			选中多行多光标进行操作及一些常用的命令(快捷键)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 关于颜色的css代码,把鼠标移动到这段代码上时，一个颜色选择器窗口就会显示出来,可以通过它来修改选择自己想要的颜色.
2 ctrl+shift+p 调出命令面板
3 alt+鼠标左键 选中多行同时编辑
4 ctrl+shift+L 选中编辑代码中相同的内容
5 选中多行,按tab键可统一向右移动
6 选中文本后,Ctrl + [ 和 Ctrl + ] 可实现文本的向左移动 和 向右移动
7 按住Ctrl + Alt，再按键盘上的上或下键，可以使一列上出现多个光标。
8 选中一段文字，按shift+alt+i，在每行末尾都会出现光标
9 按shift+alt，再使用鼠标拖动，也可以出现竖直的列光标，同时可以选中多列。
10 按ctrl+f，可以搜索当前页面
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f80dcbc14220976c1eac2f30404d875/" rel="bookmark">
			pyinstaller遇到的问题总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		pyinstaller遇到的问题总结 1.RecursionError: maximum recursion depth exceeded 解决步骤：
1)pyinstaller -F xxx.py
​ 这一步肯定会报上述错误导致失败，但是会产生一个xxx.spec文件
2)在xxx.spec文件中增加两行(添加在原文件第二行):
import sys sys.setrecursionlimit(5000) 3)pyinstaller xxx.spec
打包成功。
2.UnicodeDecodeError: ‘utf-8’ codec can’t decode byte 0xce in position 解决方法：在你打包的命令行中先输入chcp 65001 然后再输入打包命令。
3.WARNING: file already exists but should not: C:\…\…\…\Local\Temp_MEI58962\include\pyconfig.h 报错内容可能不同，但都是xxx已存在，问题的原因是pyinstaller打包时pyconfig.h多打了一次，所以会报已经存在了。这个解决方案就是把多余的pyconfig.h去掉。具体解决方法如下：
在自动生成的xxx.spec中，添加如下代码，去掉多余依赖项：
#add_begin for d in a.datas: if 'pyconfig' in d[0]: a.datas.remove(d) break #add_end 位置在a后面，pyz前面。
4.WARNING: file already exists but should not: C:\…\…\…\Local\Temp_MEI165842\torchvision_C.cp37-win_amd64.pyd 这个试了挺多办法，还未解决，有解决了的大哥麻烦告知一下，感激不尽！！！
5.最麻烦的，torch和torchvision打包问题，exe在自己电脑上能用，在其他电脑上就报错如下： 其实主要问题是pyinstaller不支持torchvision在0.3.0以上的版本。但是，要给torchvision降级什么的·····不多说了，懂的都懂！！！
[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-rT1z876E-1600249368225)(https://user-images.githubusercontent.com/34004152/74804720-5e0c1680-5324-11ea-8974-ce18e0692b42.png)]
所以，真解决方案：在GitHub上找到了大佬的解决方法：
这里详细说一下：在主文件，也就是你要打包的文件头部添加
def script_method(fn, _rcb=None): return fn def script(obj, optimize=True, _frames_up=0, _rcb=None): return obj import torch.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5f80dcbc14220976c1eac2f30404d875/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0efd7cfa641ada5c6e815b9ddb297060/" rel="bookmark">
			Python开发Windows桌面应用程序（一）PyCharm&#43;PyQt5开发环境搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 最近想开发一套Netty网关日志分析程序，用来分析设备的原始数据。因为网关是放在linux服务器上，之前查看日志是通过Xftp工具将日志下载到本地，然后找到对应的日志数据进行分析。
对于运维人员来说，上述的日志分析方式难度是相当大的，比如我想查看某天几点几分到几点几分的设备原始数据来分析设备的运行情况，需要将整个日志全部下载到本地，然后再海量日志文件里面找到对应的时间点。
而且，本身我也不太希望运维人员直接对服务器进行操作，人工操作风险太大，所以就考虑给运维人员开发一个小工具，既可以让他们快速的找到对应日志，又可以减少服务器的直接操作。
最初我准备用C# Winform来做这个，毕竟界面界面相对好做很多，而且我个人对Python也并不熟练。不过抱着学习的角度，最后还是准备采用Python+PyQt5来做这个开发。
言归正传，下面开始写一些我的学习心得。
下载工具包 （1）下载并安装PyCharm
下载地址：https://www.jetbrains.com/pycharm/download/
PyCharm我采用的是jetbrains-agent.jar方式进行激活的，具体方法可以参考：http://www.360doc.com/content/19/0717/13/36367108_849345042.shtml，因为之前开发网关的时候使用的是IntelliJ IDEA，这里激活方法基本是一致的。
（2）安装PyQt5
打开命令窗口，我这边使用的是Windows操作系统（Win+R,然后输入cmd）
执行命令：
pip install pyqt5 -i http://mirrors.aliyun.com/pypi/simple/ 我使用的是阿里云的镜像地址，如果直接使用：pip install pyqt5，鬼知道会失败多少次，总是在Timeout！
（3）安装PyQt5-tools
执行命令：
pip install pyqt5-tools -i http://mirrors.aliyun.com/pypi/simple/ PyCharm安装PyQt5插件 点击File—&gt;Settings
找到Tools下面的External Tools
如果之前没有设置过拓展工具的话，这里是没有任何信息的，我们需要点击上面的+号添加需要的工具
我们需要添加的工具有两个，一个是QtDesigner，一个是PyUIC，如上图红框里面的两个拓展工具。
QtDesigner：是我们做界面的一个设计工具，打开QtDesigner，展现给我们的是一个可视化的UI绘制界面，其通过拖拽的方式放置控件可以随时查看控件效果，最终QtDesigner会将我们做好的界面转成.ui文件。下面会说到如何使用QtDesigner来设计界面。
PyUIC：将我们通过QtDesigner做好的界面生成的.ui文件转成.py文件，这样我们就可以使用Python对界面元素进行操作了。
（1）添加QtDesigner 我将Python安装在了D:\Python目录下，所以通过pip添加的依赖也会在D:\Python目录下，我们找到Scripts下的designer.exe
Working directory可以手动输入$FileDir$或者点击+号选择对应的Macros
（2）添加PyUIC Program:选择python.exe
Arguments:输入c.pyuic $FileName$ -o $FileNameWithoutExtension$.p
Working directory:输入$FileDir$
到此我们PyCharm安装PyQt5插件完成。
如何使用PyQt5 首先我们创建一个项目
这里有个细节需要注意，需要勾选红框标注点，否则我们安装的PyQt5库就没办法使用了。
然后点击Create即可。
创建好项目后，项目名称那里右键找到External Tools，然后选择我们之前添加的QtDesigner即可打开UI设计界面了。
Qt Designer界面如下，选择创建一个Main Window即可开始我们的UI绘制。
经过一番拖拽和方法定义后（后续文章会说详细的设计），生产了一个.ui的文件
最后右键此文件找到External Tools
选择PyUIC生成了一个.p的文件，对这个文件进行重命名为.py文件，就是我们最后得到的Python界面文件，最后定义一个类，导入我们生产的.py文件，就可以在实现类里面控制界面上的控件了。
界面是做出来了，但是相对于C#的winform来说，设计体验不是很好，感觉相对复杂了很多，也可能是与我的习惯有关。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/229024c61d20f91ff121f6196e975fed/" rel="bookmark">
			html 9_16
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 &lt;html&gt; &lt;head&gt; &lt;title&gt;标题标记实验&lt;/title&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf8"&gt; &lt;/head&gt; &lt;h1 align="center"&gt;一级标题居中&lt;/h1&gt; &lt;h2 align="right"&gt;二级标题右对齐&lt;/h2&gt; 这是普通文字！！ &lt;h3 align="left"&gt;三级标题左对齐&lt;/h3&gt; &lt;h4&gt;四级标题&lt;/h4&gt; &lt;/body&gt; &lt;/html&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2107e0d83959f9708c5cd24ac470d8ef/" rel="bookmark">
			[AcWing面向模型编程]kmp
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目：831. KMP字符串 分析： 听y总讲了一遍kmp，感觉理解的还不错，应该可以默写了。
代码： #include &lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; //typedef __int128 lll; #define print(i) cout &lt;&lt; "debug: " &lt;&lt; i &lt;&lt; endl #define close() ios::sync_with_stdio(0), cin.tie(0), cout.tie(0) #define mem(a, b) memset(a, b, sizeof(a)) const ll mod = 1e9 + 7; const int maxn = 2e6; const int inf = 0x3f3f3f3f; int n, m; char model[maxn], now[maxn]; int nex[maxn]; void getnex() { for (int i = 2, j = 0; i &lt;= n; i++) { while (j &amp;&amp; model[j + 1] !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2107e0d83959f9708c5cd24ac470d8ef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe85d71c71939bcfeb518683455fa433/" rel="bookmark">
			Linux基础指令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ls指令，含义：list，列出所有的文件和文件夹的名称。
①ls 路径 。含义：显示文件的所有名称
这里的黑色表示文件，蓝色表示文件夹，绿色表示拥有所有权限。
②ls -l 路径。（快捷：ll 指令）以列表的形式显示文件的名称。
③ls -la 路径。显示所有文件和文件夹（包括隐藏文档）。
④ls -lh 路径。以可读性较高的方式显示详细信息。
pwd指令，含义：（print working directory）打印当前工作目录。
cd指令，含义：（change directory）改变当前的工作目录。 mkdir指令，含义：（make directory）创建目录。
①mkdir 路径。在指定目录下创建目录。
②mkdir -p a/b/c/d。在指定多层目录下创建目录。“-p”表示创建目标目录的上层目录。
③mkdir a b c d。一次性创建多个目录。
touch指令，含义：创建文件。
①touch 路径。在指定目录下创建文件，或者修改文件时间。
②touch 路径1 路径2 路径n。一次性创建多个文件。
③touch -t “时间格式（YYYYMMDDhhmm）” 文件路径。修改指定文件的时间。
cp指令，含义：（copy）将一个文档复制到另一个文档中。
①cp /a /b。将a文件复制到当前目录下并且更名为b。
②cp -r a b。将a文件夹复制到b文件夹中。“-r”表示递归的执行。
mv指令，含义：（move）移动文档到指定目录下。
①mv a/a1 b。移动a文件夹下的a1到b文件夹中。
②mv a/a1 b/a1_copy。移动a文件夹下的a1到b文件夹中并且更名为/a1_copy。
rm指令，含义：（remove）移除或删除一个文件或文件夹，删除之后不会出现在回收站中。
①rm a/a1。删除a文件夹下的a1文件。
②rm -r a。删除a文件夹。
③ rm -r a*。删除以a开头的所有文档。“ * ”表示通配符，任意字符。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fe85d71c71939bcfeb518683455fa433/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26e092896e5114a82914ed21edf9b6cb/" rel="bookmark">
			java时间戳正确，时间显示错误问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		从数据库取出时间戳为十位int类型，精确到秒的时间戳
web页面拿到显示为“yyyy-MM-dd hh:mm:ss”为变成“1970-01-01 20:20:20”，与数据库存入的当时时间，相差了几十年
仔细观察是转换为"long"型时出错:如图
SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); dateFormat.setTimeZone(TimeZone.getTimeZone("GMT+8:00")); long signtime = auser.getLastsigntime()*1000; String lastSignTime = dateFormat.format(new Date(signtime)); req.setAttribute("auser",auser); req.setAttribute("addTimes",userAddTimes); req.setAttribute("lastSignTime",lastSignTime); req.getRequestDispatcher("/userDetail.jsp").forward(req,resp); "long signtime = auser.getLastsigntime()*1000;"等号右边为int型，int乘以1000，还是int，只不过会越界，并没有转为精度更高的long型，所以signtime实际上没有转化为“时间戳-秒”对应的“时间戳-毫秒”
改成以下就好了：
SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); dateFormat.setTimeZone(TimeZone.getTimeZone("GMT+8:00")); long signtime = ((long)(auser.getLastsigntime()))*1000; String lastSignTime = dateFormat.format(new Date(signtime)); req.setAttribute("auser",auser); req.setAttribute("addTimes",userAddTimes); req.setAttribute("lastSignTime",lastSignTime); req.getRequestDispatcher("/userDetail.jsp").forward(req,resp); 在“*1000”乘以1000这个操作以前，就把lastsigntime转化为“long”类型，乘以1000后，也不会越界，就是时间戳葱“秒”换算成“毫秒”了。
小问题，记一下.
更多问题，加qq群：565191947
另外，给大家介绍一款国内很实惠便宜的服务器运营商：
https://www.didiyun.com/activity.html?invite=298tSgEjvtp#annually
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/719ee33ba421f9b5a95e65d80fdc645b/" rel="bookmark">
			Matlab 元胞自动机(模拟传染病传播)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		元胞自动机的初步认识 元胞自动机（CA）是一种用来仿真局部规则和局部联系的方法。
主要掌握三点 １.元胞状态 一般元胞状态为有限离散的。
２.规则 规则具体定义按照题意。
３.邻居 一般邻居格式有四邻居和八邻居，具体问题具体分析。
具体实例：模拟传染病传播 １.元胞状态 0 ：代表易感者1 ：代表潜伏者2 ：代表患病者3 ：代表免疫者4 ：代表死亡者5 : 代表虚拟边界 ２.规则 易感者的下一状态只能有两种：易感者　潜伏者 潜伏者的下一状态只能有三种：潜伏者　患病者　免疫者 患病者的下一状态只能有两种：患病者　死亡者　易感者（治疗） 免疫者的下一状态只能有一种：免疫者 死亡者的下一状态只能有一种：死亡者 状态转移的两种方式： １.自我影响２.影响邻居（邻居影响） ３.邻居 采用八邻居格式。
具体请看代码 可能大家…会遇到图形强制出现(笔者只是出于好玩，才临时编的模拟传染病毒扩散，水平有限…)，为此，笔者准备了Ctrl+C键来强制退出…
示例源码 close;clear;clc %参数初始化 n = 250; chushiqianfuzhe = 5; % 邻居采用 8邻居式 % 0 ：代表易感者 % 1 ：代表潜伏者 % 2 ：代表患病者 % 3 ：代表免疫者 % 4 ：代表死亡者 % 5 : 代表虚拟值 p01 = 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/719ee33ba421f9b5a95e65d80fdc645b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df7aabaa3b418a9dd44cdc47ed9dac36/" rel="bookmark">
			Linux__centerOS6忘记root密码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		忘了root超管的密码 为了解决Linux操作系统下CenterOS6版本忘记root密码的问题，可以使用以下方法。
1.重启电脑或者开机时候，按键盘E键。选择以下选项进行编辑。每进行一下选择，按E件进行确认。
2.空格输入single，按回车键。
3.按B键重启电脑，重启之后出现一下情况。
4.输入passwd root，然后根据提示输入信息
看见successfully则表示更新成功。
5.最后输入reboot，让它启动。
输入修改的密码，进入成功。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/106cbb257d8fc9355cca66251a689663/" rel="bookmark">
			【IntelliJ IDEA工具】spring boot使用JPA自动生成实体类（数据库表逆向工程自动生成带注释的实体类）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、maven依赖：
&lt;!-- JPA，用于自动生成表结构 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.persistence&lt;/groupId&gt; &lt;artifactId&gt;persistence-api&lt;/artifactId&gt; &lt;version&gt;1.0.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;${lombok.version}&lt;/version&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.47&lt;/version&gt; &lt;/dependency&gt; 2、idea添加数据库连接
3、连接上数据库，选中任意表，右击，找到schema目录下的Generate POJOs.groovy文件:
4、Generate POJOs.groovy文件配置如下：
import com.intellij.database.model.DasTable import com.intellij.database.util.Case import com.intellij.database.util.DasUtil import java.text.SimpleDateFormat /* * Available context bindings: * SELECTION Iterable&lt;DasObject&gt; * PROJECT project * FILES files helper */ packageName = "" typeMapping = [ (~/(?i)tinyint|smallint|mediumint|int/) : "Integer", (~/(?i)bigint/) : "Long", (~/(?i)bool|bit/) : "Boolean", (~/(?i)float|double|decimal|real/) : "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/106cbb257d8fc9355cca66251a689663/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba1390ce32417445b48fe81744c72cdb/" rel="bookmark">
			【Java】next() 和 nextLine() 的用法区别详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		next()
读取到有效字符后才可以结束输入对输入有效字符之前遇到的空格键、Tab键或Enter键等结束符，next()方法会自动将其去掉只有在输入有效字符之后，next()方法才将其后输入的空格键、Tab键或Enter键等视为分隔符或结束符 nextLine()
nextLine() 方法的结束符只是Enter键，即nextLine()方法返回的是Enter键之前的所有字符可以得到带空格的字符串的 用法：
测试1：nextLine() 在前，next() 在后，且输入都没有空格 public static void main(String[] args) { Scanner input = new Scanner(System.in); System.out.println("请输入字符串（nextLine）："); String str1 = input.nextLine(); System.out.println(str1); System.out.println("请输入字符串（next）："); String str = input.next(); System.out.println(str); } 输出结果一样：
测试2：nextLine() 在前，next() 在后，且输入有空格。
分析：next() 只输出了“曹老板”，后面的"很有钱"并没有输出。这是因为 next() 有效字符后遇到输入的空格键、Tab键或Enter键会自动结束，并且不会读取这些符号。 测试3：将代码中next和nextLine的顺序调整一下 public static void main(String[] args) { Scanner input = new Scanner(System.in); System.out.println("请输入字符串（next）："); String str = input.next(); System.out.println(str); System.out.println("请输入字符串（nextLine）：");//曹老板很有钱 String str1 = input.nextLine(); System.out.println(str1); } 运行结果：
分析：我们发现还没有输入nextLine的字符串，它已经停掉了。这是因为next()在输入有效字符后遇到换行符就结束读取了，并且不会读取换行符。而nextLine() 能够读取空格、换行符、Tab键等，且以换行符为分隔符，所以遇到上次输入遗留下来的换行符读取后就结束。这时输入的是 “\r”，而不是空值。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ba1390ce32417445b48fe81744c72cdb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df7615b1b2d0818d7b619cb5e0512b7c/" rel="bookmark">
			A*算法是否是最好的路径查询算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		链接: Is A* the best pathfinding algorithm?
Ask Question .
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1044b20221660b61b3c65c4887902021/" rel="bookmark">
			2020最新最详细K8s安装教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 环境准备 准备好4台centos7 一个为master,两个node,一个harbor（私有仓库）
Master内存大小为4g,其余都为2g，这里可以先安装一台最小版，再克隆其他3台
将4台的ip设置为静态ip，互相，本地和虚拟机，虚拟机和外网都可以ping通，且保证网络畅通。
设置系统主机名以及 Host 文件的相互解析
每一台都设置
vim /etc/hostname vim /etc/hosts
192.168.137.10 k8s-master
192.168.137.20 k8s-node1
192.168.137.30 k8s-node2
192.168.137.40 k8s-admin 2.安装依赖包
yum install -y conntrack ntpdate ntp ipvsadm ipset jq iptables curl sysstat libseccomp wget vimnet-tools git
3.设置防火墙为 Iptables 并设置空规则
systemctl stop firewalld &amp;&amp; systemctl disable firewalld
yum -y install iptables-services &amp;&amp; systemctl start iptables &amp;&amp; systemctl enable iptables &amp;&amp; iptables -F &amp;&amp; service iptables save
4.关闭 SELINUX
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1044b20221660b61b3c65c4887902021/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4298eb90e5555855f25659513c6220c0/" rel="bookmark">
			mysql联合索引学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mysql 联合索引生效的条件、索引失效的条件
mysql索引最左匹配原则的理解
联合索引是什么
对多个字段同时建立的索引(有顺序，ABC，ACB是完全不同的两种联合索引。)
为什么要用
以联合索引(a,b,c)为例
1 建立这样的索引相当于建立了索引a、ab、abc三个索引。一个索引顶三个索引当然是好事，毕竟每多一个索引，都会增加写操作的开销和磁盘空间的开销。
2 覆盖(动词)索引。同样的有联合索引（a,b,c），如果有如下的sql: select a,b,c from table where a=xxx and b = xxx。那么MySQL可以直接通过遍历索引取得数据，而无需读表，这减少了很多的随机io操作。减少io操作，特别的随机io其实是dba主要的优化策略。所以，在真正的实际应用中，覆盖索引是主要的提升性能的优化手段之一
3 索引列越多，通过索引筛选出的数据越少。有1000W条数据的表，有如下sql:select * from table where a = 1 and b =2 and c = 3,假设每个条件可以筛选出10%的数据，如果只有单值索引，那么通过该索引能筛选出1000W*10%=100w 条数据，然后再回表从100w条数据中找到符合b=2 and c= 3的数据，然后再排序，再分页；如果是复合索引，通过索引筛选出1000w *10% *10% *10%=1w，然后再排序、分页，哪个更高效，一眼便知
SQL优化
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/656c5be6a87be0f7ba74591315533584/" rel="bookmark">
			word自动更正关闭_如何在OS X中关闭自动更正文本替换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		word自动更正关闭
Autocorrect never ceases to humor us. Entire websites have been built upon so-called autocorrect fails. Funny as they are, for those of us who tend to be really good spellers, it’s aggravating when the computer thinks it knows better.
自动更正永远不会使我们幽默。 整个网站都建立在所谓的自动更正失败的基础上 。 尽管它们很有趣，但对于我们中那些往往是非常好的拼写者，当计算机认为它更懂时，这种情况会更加恶化。 Autocorrect and its direct descendent spellcheck are woven into the very framework of OS X. Typically any application that allows text entry will have spelling and/or substitution options on the Edit menu.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/656c5be6a87be0f7ba74591315533584/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4355f34297eebdc8ae4f775379de2869/" rel="bookmark">
			springCloud微服务 解决 Too many open files 导致的应用宕机问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Spring Boot 2.3.2 发布，解决 Too many open files 导致的应用宕机问题 Spring Boot 2.3.2Spring Boot 2.2.9Spring Boot 2.1.16 现在可从 repo.spring.io 和 Maven Central 获得。
&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.3.2.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;/parent&gt; 多个版本发布，本文仅着重分享关于 v2.3 版本的更新报告，此版本包括 88 个错误修复，增强功能，文档改进和依赖项升级。
更新日志 新特性
增强 Liveness/Readiness 的健康监测并支持配置探针构建 Docker 镜像支持可配置参数增加 反应式 Elasticsearch 健康检查 问题修复与优化
Upgrade to Reactor Dysprosium-SR10 #22376。解决 v2.2.8 、v2.3.2 版本 Too many open files，导致应用宕机问题Redis Cluster 造成反应式 Redis 健康检查失效问题修复 #22096优化 优雅关机的业务场景，支持 Spring Cloud 应用 #22014欢迎页（index.html）绕过 / 控制器问题 #21909 更多日志可参考 https://github.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4355f34297eebdc8ae4f775379de2869/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31eadbba45b22dcdd678441eb758aa77/" rel="bookmark">
			C#系列学习笔记9：泛型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		泛型 泛型常用泛型集合协变和逆变 泛型 泛型，在初始化类、方法、接口等之前，延迟指定一个或多个类型，直到实际在程序中使用它的时候，这样可以降低运行时转换或装箱操作的成本或风险。有时候在封装代码的时候，我们不关心组件之间传递的是什么类型的数据，这时就可以用泛型来定义数据。System.Collections.Generic命名空间包含几个基于泛型的集合类。
在声明泛型类、结构的时候，我们可以通过使用 where 上下文关键字指定约束
public class Employee { public Employee(string s, int i) =&gt; (Name, ID) = (s, i); public string Name { get; set; } public int ID { get; set; } } public class GenericList&lt;T&gt; where T : Employee // 类型参数必须是指定的基类或派生自指定的基类 { private class Node { public Node(T t) =&gt; (Next, Data) = (null, t); public Node Next { get; set; } public T Data { get; set; } } private Node head; public void AddHead&lt;T&gt;(T t) where T struct // T必须是不可为 null 的值类型 { Node n = new Node(t) { Next = head }; head = n; } public IEnumerator&lt;T&gt; GetEnumerator() { Node current = head; while (current !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/31eadbba45b22dcdd678441eb758aa77/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eae3ee17179db648940012b1a101f886/" rel="bookmark">
			C#系列学习笔记8：程序集和命名空间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		程序集和命名空间 程序集是代码的一个物理集合，通常扩展名是EXE或DLL的.NET可执行程序称为程序集，由一个或多个文件组成。
程序集主要由清单、类型元数据、CIL代码和资源组成。
清单。主要包含了程序集标识符、组成程序集的文件列表、本程序引用的其他程序集列表和关于哪个类型被包含在哪个程序集的地图。包含： 标识（名称、版本、文化和公钥）。属于该程序集的一个文件列表。引用程序集的列表。一组许可请求——运行这个程序集所需要的许可。导出的类型。 类型元数据。关于程序集中所有类型的元数据。CIL。包含了程序集的所有中间代码。资源。可选，含图形或语言资源之类。 由多个模块组成的程序集中，一个文件是主模块，其他的为次要模块。
命名空间完全独立于程序集。在一个程序集中可以好几个命名空间，一个命名空间也可以分布在多个程序集中。
命名空间可以看做类名的一种扩展，属于类名范畴，同时有效减少了命名冲突。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/79faf71443cb9ba847894bedf90baaca/" rel="bookmark">
			C#系列学习笔记7：委托与事件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		委托与事件 delegateevent delegate 委托相当于c/c++中的函数指针，用于实现 event 和 回调函数，所有的委托都继承自System.Delegate
public delegate void Del(string message); // 定义了一个可以调用任何形参为string、无返回的委托 public void Print(string message){ Console.WriteLine( message ); } Del handler1 = new Del(Print); // 实例化方法1 Del handler2 = Print; // 实例化方法2 handler1("This is the method 1"); handler2("This is the method 2"); 委托的另一种用法是传递回调函数：
public static void MethodWithCallback(int param1, int param2, Del callback) { ... ... callback("The number is: " + (param1 + param2).ToString()); } MethodWithCallback(1, 2, handler); // output: The number is: 3 委托可以用运算符"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/79faf71443cb9ba847894bedf90baaca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3956ac40adb0ac90542877287e3e0ae5/" rel="bookmark">
			windows系统导出策略 secedit
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		导出 secedit /export /cfg d:\setup.inf
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d07baa8102db04a83dc73d82b9fbb836/" rel="bookmark">
			Hive启动报错java.lang.NoSuchMethodError: com.google.common.base.Preconditions.checkArgument
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天，搞了下hive，想着这个安装挺简单，结果一启动hive给我来着一招
hive：小兄弟，没想到吧，咱可不是随便的人。😄
我：。。。
错误信息 报错如下：
Exception in thread "main" java.lang.NoSuchMethodError: com.google.common.base.Preconditions.checkArgument(ZLjava/lang/String;Ljava/lang/Object;)V at org.apache.hadoop.conf.Configuration.set(Configuration.java:1380) at org.apache.hadoop.conf.Configuration.set(Configuration.java:1361) at org.apache.hadoop.mapred.JobConf.setJar(JobConf.java:536) at org.apache.hadoop.mapred.JobConf.setJarByClass(JobConf.java:554) at org.apache.hadoop.mapred.JobConf.&lt;init&gt;(JobConf.java:448) at org.apache.hadoop.hive.conf.HiveConf.initialize(HiveConf.java:5141) at org.apache.hadoop.hive.conf.HiveConf.&lt;init&gt;(HiveConf.java:5099) at org.apache.hadoop.hive.common.LogUtils.initHiveLog4jCommon(LogUtils.java:97) at org.apache.hadoop.hive.common.LogUtils.initHiveLog4j(LogUtils.java:81) at org.apache.hadoop.hive.cli.CliDriver.run(CliDriver.java:699) at org.apache.hadoop.hive.cli.CliDriver.main(CliDriver.java:683) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at org.apache.hadoop.util.RunJar.run(RunJar.java:323) at org.apache.hadoop.util.RunJar.main(RunJar.java:236) 错误分析 其实这类错误一般两种思考思路：
系统找不到相关jar包同一类型的 jar 包有不同版本存在，系统无法决定使用哪一个 由百度可知，com.google.common.base.Preconditions.checkArgument类位于我们的guava.jar包中
该包在hadoop中存储的位置是hadoop\share\hadoop\common\lib
该包在hive中存储的位置是hive/lib
由此可知，真就是因为我们的jar问题导致的错误！！！
解决方案 删除hive中低版本的guava-19.0.jar包，将hadoop中的guava-27.0-jre.jar复制到hive的lib目录下即可
启动 解决了！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c78ac85881005583b7a8ebf9c834984/" rel="bookmark">
			解决 百度地图多点聚合卡顿问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由于百度地图提供的MarkerClusterer_min.js 比较卡顿 特此提供加速后的MarkerClusterer_min.js 点击链接即可到百度网盘下载 链接：https://pan.baidu.com/s/1QJT7W7lm-93X2tnXHCmdQw
提取码：guow
源码如下：
/** * @fileoverview MarkerClusterer标记聚合器用来解决加载大量点要素到地图上产生覆盖现象的问题，并提高性能。 * 主入口类是&lt;a href="symbols/BMapLib.MarkerClusterer.html"&gt;MarkerClusterer&lt;/a&gt;， * 基于Baidu Map API 1.2。 * * @author Baidu Map Api Group * @version 1.2 */ /** * @namespace BMap的所有library类均放在BMapLib命名空间下 */ var BMapLib = window.BMapLib = BMapLib || {}; (function(){ /** * 获取一个扩展的视图范围，把上下左右都扩大一样的像素值。 * @param {Map} map BMap.Map的实例化对象 * @param {BMap.Bounds} bounds BMap.Bounds的实例化对象 * @param {Number} gridSize 要扩大的像素值 * * @return {BMap.Bounds} 返回扩大后的视图范围。 */ var getExtendedBounds = function(map, bounds, gridSize){ bounds = cutBoundsInRange(bounds); var pixelNE = map.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2c78ac85881005583b7a8ebf9c834984/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87876dbd796a5b729f3441c4664c5ff5/" rel="bookmark">
			IP核
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		IP核（Intellectual Property core），是一段具有特定电路功能的硬件描述语言程序，该程序与集成电路工艺无关，可以移植到不同的半导体工艺中去生产集成电路芯片。因此使用IP核是一个发展趋势，IP核的重用大大缩短了产品上市时间。
华为-IP核
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96ede5fbe7a41f1d14c618c87d399be4/" rel="bookmark">
			redis 配置（单机）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		redis 配置（单机） 说明：以下为redis.conf配置说明，可根据关键字在文件中查找。
启动
后台启动：表示退出启动界面仍然运行 ，否则服务随启动界面的关闭而关闭
daemonize no 不是后台启动（默认）
daemonize yes 后台启动
pid
redis以后台进程运行的时候，Redis默认会把pid写入/var/run/redis.pid文件组
pidfile /var/run/redis.pid redis.pid 可以重新命名
端口
指定redis监听端口，默认为6379
port 6379
保护模式
protected-mode yes 开启保护模式，此时需要设置端口和密码，no 所有都可以连接（不安全）
指定redis只接收来自于该IP地址的请求，如果不进行设置，默认将处理所有ip的请求，
bind 127.0.0.1 ------bind 0.0.0.0 等同于不限制ip
密码
requirepass 123456
客户端超时 在客户端空闲N秒后关闭连接， 设置0表示不关闭
timeout 0
健康连接检查 单位是秒
表示将周期性的使用SO_KEEPALIVE检测客户端是否还处于健康状态，避免服务器一直阻塞，官方给出的建议值是300s，如果设置为0，则不会周期性的检测
tcp-keepalive 300
日志 debug 记录很多信息，用于开发和测试
varbose 很多精简的有用信息，不像debug会记录那么多
notice 普通的verbose，常用于生产环境 (默认)
warning 只有非常重要或者严重的信息会记录到日志
loglevel notice
syslog-enabled：是否把日志输出到系统日志中，默认是no
日志文件名称 logfile /var/redis/log/redis_6379.log
数据库数量
默认数量为16 ，默认的数据库是DB 0
databases 16
持久化机制
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/96ede5fbe7a41f1d14c618c87d399be4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/095e2b518b400035645071300501c9ca/" rel="bookmark">
			GlusterFS原理及如何配置使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、GlusterFS概述1.1简介1.2特点1.3GlusterFS相关术语1.4模块化堆栈式架构 二、GlusterFS工作原理2.1弹性hash算法2.2GlusterFS工作流程 三、GlusterFS的卷类型3.1分布式卷3.2条带卷3.3复制卷3.4分布式条带卷3.5分布式复制卷 四、部署GlusterFS卷4.1实验环境4.2以下过程为构建存储池子4.3根据规划创建如下卷4.3.1创建分布式卷4.3.2创建复制卷4.3.3创建分布式复制卷 4.4破坏测试4.5访问控制 一、GlusterFS概述 1.1简介 Glusterfs是一个开源的分布式文件系统,是Scale存储的核心,能够处理千数量级的客户端.在传统的解决 方案中Glusterfs能够灵活的结合物理的,虚拟的和云资源去体现高可用和企业级的性能存储.
Glusterfs通过TCP/IP或InfiniBand RDMA网络链接将客户端的存储资块源聚集在一起,使用单一的全局命名空间来管理数据,磁盘和内存资源.
Glusterfs基于堆叠的用户空间设计,可以为不同的工作负载提供高优的性能.
1.2特点 ●扩展性和高性能
GlusterFS利用双重特性来提供几TB至数PB的高扩展存储解决方案。Scale-Out架构允许通过简单地增加资源来提高存储容量和性能，磁盘、计算和I/O资源都可以独立增加，支持10GbE和InfiniBand等高速网络互联。Gluster弹性哈希（Elastic Hash）解除了GlusterFS对元数据服务器的需求，消除了单点故障和性能瓶颈，真正实现了并行化数据访问。
●高可用性
GlusterFS可以对文件进行自动复制，如镜像或多次复制，从而确保数据总是可以访问，甚至是在硬件故障的情况下也能正常访问。自我修复功能能够把数据恢复到正确的状态，而且修复是以增量的方式在后台执行，几乎不会产生性能负载。GlusterFS没有设计自己的私有数据文件格式，而是采用操作系统中主流标准的磁盘文件系统（如EXT3、ZFS）来存储文件，因此数据可以使用各种标准工具进行复制和访问。
●全局统一命名空间
全局统一命名空间将磁盘和内存资源聚集成一个单一的虚拟存储池，对上层用户和应用屏蔽了底层的物理硬件。存储资源可以根据需要在虚拟存储池中进行弹性扩展，比如扩容或收缩。当存储虚拟机映像时，存储的虚拟映像文件没有数量限制，成千虚拟机均通过单一挂载点进行数据共享。虚拟机I/O可在命名空间内的所有服务器上自动进行负载均衡，消除了SAN环境中经常发生的访问热点和性能瓶颈问题。
●弹性卷管理
数据储存在逻辑卷中，逻辑卷可以从虚拟化的物理存储池进行独立逻辑划分而得到。存储服务器可以在线进行增加和移除，不会导致应用中断。逻辑卷可以在所有配置服务器中增长和缩减，可以在不同服务器迁移进行容量均衡，或者增加和移除系统，这些操作都可在线进行。文件系统配置更改也可以实时在线进行并应用，从而可以适应工作负载条件变化或在线性能调优。
●基于标准协议
Gluster存储服务支持NFS, CIFS, HTTP, FTP以及Gluster原生协议，完全与POSIX标准兼容。现有应用程序不需要作任何修改或使用专用API，就可以对Gluster中的数据进行访问。这在公有云环境中部署Gluster时非常有用，Gluster对云服务提供商专用API进行抽象，然后提供标准POSIX接口。
1.3GlusterFS相关术语 ●Brick:GFS中的存储单元，通过是一个受信存储池中的服务器的一个导出目录。可以通过主机名和目录名来标识，如’SERVER:EXPORT’
●Volume:一组bricks的逻辑集合（卷）
●FUSE:Filesystem Userspace是一个可加载的内核模块，其支持非特权用户创建自己的文件系统而不需要修改内核代码。通过在用户空间运行文件系统的代码通过FUSE代码与内核进行桥接。
●VFS：虚拟文件系统
●Glusterd：Gluster management daemon，要在trusted storage pool中所有的服务器上运行。
Node:一个拥有若干brick的设备
Client: 挂载了GFS卷的设备
RDMA:远程直接内存访问，支持不通过双方的OS进行直接内存访问。
RRDNS:round robin DNS是一种通过DNS轮转返回不同的设备以进行负载均衡的方法
Self-heal:用于后台运行检测复本卷中文件和目录的不一致性并解决这些不一致。
Split-brain:脑裂
Volfile:glusterfs进程的配置文件，通常位于/var/lib/glusterd/vols/volname
1.4模块化堆栈式架构 ●模块化、堆栈式的架构
●通过对模块的组合，实现复杂的功能
GlusterFS采用模块化、堆栈式的架构，可通过灵活的配置支持高度定制化的应用环境，比如大文件存储、海量小文件存储、云存储、多传输协议应用等。每个功能以模块形式实现，然后以积木方式进行简单的组合，即可实现复杂的功能。比如，Replicate模块可实现RAID1，Stripe模块可实现RAID0，通过两者的组合可实现RAID10和RAID01，同时获得高性能和高可靠性。如下图所示
二、GlusterFS工作原理 2.1弹性hash算法 ●通过hash算法得到一个32位的整数
●划分为N个连续的子空间，每个空间对应一个Brick
●弹性hash算法的优点
保证数据平均分布在每一个Brick中
解决了对元数据服务器的依赖，进而解决了单点故障以及访问瓶颈
2.2GlusterFS工作流程 1、客户端或应用程序通过GlusterFS的挂载点访问数据，对于用户来说，集群系统的存在对用户是完全透明的，用户感觉不到是操作本地系统还是远端的集群系统。
2、用户的这个操作被递交给 本地linux系统的VFS来处理。
3、VFS将数据递交给FUSE内核文件系统, fuse文件系统则是将数据通过/dev/fuse设备文件递交给了GlusterFS client端，所以， 我们可以将 fuse文件系统理解为一个代理。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/095e2b518b400035645071300501c9ca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d42494724d127b583e9a734cd406e944/" rel="bookmark">
			axios、生命周期基本介绍、计算属性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		axios axios官网文档
axios是一套对ajax的封装的JS库，本质上用的还是XMLHttpRequest，只不过它是用promise进行的封装所以它就有.then和.catch方法
axios是基于promise封装的，所以用起来方便，避免了回调地狱
缺点：浏览器兼容性不好(技术太先进了)
与jquery对比 jQuery与axios对比jQueryaxios1.ajax技术底层原理XMLHTTPRequestXMLHTTPRequest2.体积大小大（包含大量dom操作与ajax）小(只有ajax请求)3.是否支持ES6的Promise不支持（底层使用其他方案模拟实现）支持基于原生Promise封装4.兼容性好 （兼容性是jQuery的强项）一般(使用了新技术) axios发get请求 get方法第一个参数是urlget方法第二个参数是对象类型 { params:{get参数对象} } &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8" /&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="app"&gt; &lt;button @click="sendGet"&gt;发请求&lt;/button&gt; &lt;/div&gt; &lt;/body&gt; &lt;script src="./vue.js"&gt;&lt;/script&gt; &lt;script src="https://unpkg.com/axios/dist/axios.min.js"&gt;&lt;/script&gt; &lt;script&gt; new Vue({ el: '#app', data: {}, methods: { sendGet() { axios .get('https://autumnfish.cn/api/joke/list', { params: { num: 5 }, }) .then((res) =&gt; { // 请求成功触发 console.log(res) }) .catch((error) =&gt; { // 请求失败触发 console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d42494724d127b583e9a734cd406e944/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/032a5f9170c45a2251a3fec2754b03b6/" rel="bookmark">
			REACT学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		js日期处理类 http://momentjs.cn/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ecc3d36b3efdb33503df16803e8bbde/" rel="bookmark">
			runtime for android10.2.x加载天地图服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本篇记录在arcgis runtime for android10.2.9中加载天地图地图服务。
效果图： 实现思路： 1、在androidstudio中创建应用，编写代码，代码如下：
链接：https://pan.baidu.com/s/1pWL0q_SkDSF4mamj5G5mPA 提取码：eflt
2、生成发布者SHA1
参考此链接：https://blog.csdn.net/qq_29269233/article/details/53725865
https://blog.csdn.net/qq_30304193/article/details/81781914
3、天地图官网申请密钥。访问天地图的地图服务现在需要密钥。
提交后会自动生成一个key
4、将天地图中应用的密钥填写在代码中。
5、在androidstudio运行应用程序。
如果在cpu为64位的android设备上运行应用程序闪退，在32位的android设备上运行成功，可以参考这篇博客解决64位android设备闪退的问题。链接：https://blog.csdn.net/gislaozhang/article/details/116092070
参考资料： https://blog.csdn.net/qq_30304193/article/details/81781914
https://blog.csdn.net/qq_29269233/article/details/53725865
https://blog.csdn.net/sqj199567/article/details/86526856
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/300fdc9ef7d52bc41f22a568ed2a4c10/" rel="bookmark">
			对vuepress以及vuepress-theme-vdoing的认识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对vuepress的认识 前言 还是和昨天写vuepress-theme-vdoing使用体验一样。在边尝试VuePress +Gitee 快速搭建个人博客边写博客的过程中，引出了我对vuepress的认识，而且越写越多，所以干脆也单独拎出来写一章。我复制了其中的vuepress认识，让这篇博客写得更加连贯。
记录的主体内容有三部分：我接触vuepress的过程、vuepress官网摘要、vuepress-theme-vdoing官网摘要。
文章目录 对vuepress的认识前言重新认识vuepress使用vuepress的过程vuepress理论基础摘要基础设计理念插件主题 vuepress基础内容的总结 认识vuepress-theme-vdoing的摘要基础vuepress-theme-vdoing的高级操作vdoing配置 总结 重新认识vuepress 其实我对vuepress项目感兴趣是因为我用过WordPress。看到这个vuepress的名字的时候我就下意识的认为这是一个使用vue框架的CMS。碰巧我不怎么喜欢WordPress，对vue十分有好感。所以昨天就看了看GitHub上的vuepress-theme-vdoing。还写了vuepress-theme-vdoing使用体验、我对博客网站的认识——wsdchong。
今天早上看到VuePress +Gitee 快速搭建个人博客，于是打算尝试一下vuepress，在尝试的过程中查找资料，我在CSDN的链接中还找到了vuepress-theme-antdocs和vuepress-creator的作者。我还以为他是vue-theme-vdoing的作者，但是他们的GitHub不同。最后我在vuepress-theme-vdoing的文档库中发现原来还有个vuepress。兜兜转转最后找到了组织。
vuepress：vue驱动的静态网站生成器。以markdown为中心的项目结构，以最少的配置帮助你专注写作。
使用vuepress的过程 既然可以运行又可以部署，那么就可以尝试修改内容了。
我准备尝试的部分是修改。
首先是预期效果。首先参考三个人的博客：Evan’s blog、lingze’s blog、restlessMan。
Evan’s blog：是vuepress-theme-vdoing的作者。
lingze’s blog：是vuepress-theme-vdoing的使用者。内容精简。
restlessMan：是我参考的那篇文章的vuepress博客。
然后是参考文档。一个是vuepress的官方文档，一个是vuepress-theme-vdoing的文档
vuepress：源头。官方文档更系统准确。
vuepress-theme-vdoing：一个好的使用者。个人文档更便于理解思考。
等我理解文档的意思后，归纳总结关注点。
vuepress理论基础摘要 基础 vuepress的介绍
简洁。以 Markdown 为中心的项目结构，以最少的配置帮助你专注于写作。vue驱动。享受 Vue + webpack 的开发体验，可以在 Markdown 中使用 Vue 组件，又可以使用 Vue 来开发自定义主题。高性能。VuePress 会为每个页面预渲染生成静态的 HTML，同时，每个页面被加载的时候，将作为 SPA 运行。 vuepress的基本使用
npm install -g vuepress echo '# hello!' &gt; README.md vuepress dev vuepress build //注意node.js版本&gt;=8.6 vuepress的介绍
VuePress 由两部分组成：第一部分是一个极简静态网站生成器 ，它包含由 Vue 驱动的主题系统和插件 API，另一个部分是为书写技术文档而优化的默认主题
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/300fdc9ef7d52bc41f22a568ed2a4c10/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8912882da1c1f03cb1a1299e696b224d/" rel="bookmark">
			POI导入Excel、JAVA根据POI封装Excel的导入
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		POI导入Excel、JAVA根据POI封装Excel的导入 说明代码 说明 使用前需要明白导入参数的含义。
代码 代码从接口调用开始说明
poi版本
&lt;dependency&gt; &lt;groupId&gt;cn.afterturn&lt;/groupId&gt; &lt;artifactId&gt;easypoi-base&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;cn.afterturn&lt;/groupId&gt; &lt;artifactId&gt;easypoi-web&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;cn.afterturn&lt;/groupId&gt; &lt;artifactId&gt;easypoi-annotation&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-math3&lt;/artifactId&gt; &lt;version&gt;3.6.1&lt;/version&gt; &lt;/dependency&gt; 在这里插入代码片 @PostMapping("/load") @ResponseBody public Map importTemplate(@RequestParam(value = "file") MultipartFile file) throws Exception { //参数说明看工具类说明 List&lt;ImportExcelDTO&gt; importExcelDTOS = ExcelUtils.importExcel(file, ImportExcelDTO.class, 2, 0, 1, 1); } 这个是业务相关的实体类：实体类的字段顺序一定要和Excel的字段顺序一样
@Data public class ImportExcelDTO { /** * 地区 */ private String area; /** * 货币名称 */ private String name; /** * 货币编码 */ private String code; /** * 货币编号 */ private Integer num; } 以下为封装需要的代码
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8912882da1c1f03cb1a1299e696b224d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65b662f6a56f1c7ebc122448e55c0224/" rel="bookmark">
			在C/C&#43;&#43;代码中使用SSE等指令集的指令(5)SSE进行加法运算简单的性能测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下面是一个简单的测试SSE指令性能的程序，可以看到明显的性能提升。
（说明：程序中的timing.h使用的是http://blog.csdn.net/gengshenghong/article/details/6973086中介绍的时间间隔获取方法）
#define WIN #include "timing.h" #include &lt;intrin.h&gt; #include &lt;stdlib.h&gt; #include &lt;math.h&gt; #define N 4*100000	// 注意：必须是4的倍数，否则使用SSE指令计算，要进行一些处理，从而保证正确。 _MM_ALIGN16 float op1[N]; _MM_ALIGN16 float op2[N]; _MM_ALIGN16 float result1[N]; _MM_ALIGN16 float result2[N]; void init() { for(int i = 0;i &lt; N; i++) { op1[i] = (float)rand()/(float)RAND_MAX; op2[i] = (float)rand()/(float)RAND_MAX; } } void checkResult(int debug) { bool isSame = true; for(int i = 0;i &lt; N; i++) { if (debug) { printf("%lf	%lf\n", result1[i], result2[i]); } else { if (fabs(result1[i] - result2[i]) &gt; 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/65b662f6a56f1c7ebc122448e55c0224/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/115b27971e0aee1229a4aced29c8ee98/" rel="bookmark">
			linux   FTP服务器  VSFTPD配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VSFTPD配置 Vsftpd的文件结构很简洁，主要包括：
（1）/etc/vsftpd/vsftpd.conf——主配置文件
（2）/etc/vsftpd/ftpusers——禁止使用vsftpd的用户列表文件
（3）/etc/vsftpd/user_list——禁止或允许使用vsftpd的用户列表文件。
（4）/var/ftp——匿名用户主目录
（5）/var/ftp/pub——匿名用户的下载目录
（6）/etc/logrotate.d/vsftpd.log——vsftpd的日志文件
1． 匿名服务器的连接（独立的服务器）
在/etc/vsftpd/vsftpd.conf配置文件中添加如下几项：
Anonymous_enable=no (允许匿名登陆)
Dirmessage_enable=yes （切换目录时，显示目录下.message的内容）
/var/ftp/创建一个文件,名为.message,该文件为欢迎信息的文件
cal_umask=022 (FTP上本地的文件权限，默认是077)
Connect_form_port_20=yes （启用FTP数据端口的数据连接）*
Xferlog_enable=yes （激活上传和下传的日志）
Xferlog_std_format=yes (使用标准的日志格式)
Ftpd_banner=XXXXX （欢迎信息）
Pam_service_name=vsftpd （验证方式）*
Listen=yes （独立的VSFTPD服务器）*
功能：只能连接FTP服务器，不能上传和下传
注：其中所有和日志欢迎信息相关连的都是可选项,打了星号的无论什么帐户都要添加，是属于FTP的基本选项
2． 开启匿名FTP服务器上传权限
在配置文件中添加以下的信息即可：
Anon_upload_enable=yes (开放上传权限)
Anon_mkdir_write_enable=yes （可创建目录的同时可以在此目录中上传文件）
Write_enable=yes (开放本地用户写的权限)
Anon_other_write_enable=yes (匿名帐号可以有删除的权限)
3． 开启匿名服务器下传的权限
在配置文件中添加如下信息即可：
Anon_world_readable_only=no
注：要注意文件夹的属性，匿名帐户是其它（other）用户要开启它的读写执行的权限
（R）读-----下传 （W）写----上传 （X）执行----如果不开FTP的目录都进不去
4．普通用户FTP服务器的连接（独立服务器）
在配置文件中添加如下信息即可：
Local_enble=yes （本地帐户能够登陆）
Local_root= /home/private
定义所有本地用户的根目录。当本地用户登入时，将被更换到此目录下。默认值为无。
Write_enable=yes 功能：可以用本地帐户登陆vsftpd服务器，有下载上传的权限
注：在禁止匿名登陆的信息后匿名服务器照样可以登陆但不可以上传下传
5． 用户登陆限制进其它的目录，只能进它的主目录
设置所有的本地用户都执行chroot
Chroot_local_user=yes （本地所有帐户都只能在自家目录）
设置指定用户执行chroot
Chroot_list_enable=yes （文件中的名单可以调用）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/115b27971e0aee1229a4aced29c8ee98/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b1836c284070c6814a920e1fcc795f6/" rel="bookmark">
			【JavaWeb】Filter验证是否登录案例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		案例分析 像我们平时访问浏览器时，经常会遇到这样的提示：
这个功能的实现很简单，下面就来具体演示一下；
代码实现 1.LoginFilter.jsp
package web.filter; import javax.servlet.*; import javax.servlet.annotation.WebFilter; import javax.servlet.http.HttpServletRequest; import java.io.IOException; @WebFilter("/*") public class LoginFilter implements Filter { public void destroy() { } public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws ServletException, IOException { HttpServletRequest request=(HttpServletRequest) req; String uri = request.getRequestURI();//获取请求路径 if(uri.contains("index.jsp")||uri.contains("login.jsp")||uri.contains("/css/")||uri.contains("/js/")||uri.contains("/fonts/")||uri.contains("CheckCode")){ //访问与登录相关的页面，直接放行 chain.doFilter(request, resp); } else { //与登录无关页面,查询是否登录 Object user = request.getSession().getAttribute("user"); if(user!=null){ //已经登录 chain.doFilter(request,resp); } else { //没有登陆 request.setAttribute("login_msg","您尚未登陆，请先登录"); request.getRequestDispatcher("login.jsp").forward(request,resp); } } chain.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3b1836c284070c6814a920e1fcc795f6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/146760fe4d284b9d907ba295ba9344e9/" rel="bookmark">
			Kafka集群原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Kafka 是一个分布式的、可水平扩展的、基于发布/订阅模式的、支持容错的消息系统。
一、集群成员 Kafka 使用 Zookeeper 来维护集群成员的信息。每个 broker 都有一个唯一标识符，这个标识符可以在配置文件里指定，也可以自动生成。在 broker 启动的时候，它通过创建临时节点把自己的 ID 注册到 Zookeeper。Kafka 组件订阅 Zookeeper 的 /broker/ids 路径，当有 broker 加入集群或退出集群时，这些组件就可以获得通知。
ZooKeeper 两个重要特性：
客户端会话结束时，ZooKeeper 就会删除临时节点。客户端注册监听它关心的节点，当节点状态发生变化（数据变化、子节点增减变化）时，ZooKeeper 服务会通知客户端。 二、复制 复制功能是 Kafka 架构的核心。复制之所以关键，是因为它可以在个别节点失效时仍能保证 Kafka 的可用性和持久性。
Kafka 副本 Kafka 使用 Topic 来组织数据，每个 Topic 被分为若干个 Partition。每个 Partition 有多个副本。每个 broker 可以保存成百上千个属于不同 Topic 和 Partition 的副本。Kafka 副本的本质是一个只能追加写入的提交日志。
副本有两种类型：
Leader 副本（主）：每个 Partition 都有一个 Leader 副本。Leader 处理一切对 Partition （分区）的读写请求；Follower 副本（从）：Leader 副本以外的副本都是 Follower 副本。Follower 唯一的任务就是从 Leader 那里异步复制消息，保持与 Leader 一致的状态。如果 Leader 宕机，其中一个 Follower 会被选举为新的 Leader。 为了与 Leader 保持同步，Follower 向 Leader 发起异步请求，拉取数据。请求消息里包含了 Follower 想要获取消息的偏移量，而这些偏移量总是有序的。通过查看每个 Follower 请求的最新偏移量，Leader 就会知道每个 Follower 复制的进度。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/146760fe4d284b9d907ba295ba9344e9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31302cf3bf562d82f709b65dfc62ffb1/" rel="bookmark">
			故障码（DTC）状态解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		故障码状态用于实时反映该故障的诊断状态，ECU需按协议要求存储DTC状态信息，具体有如下相关定义和要求。
规则和定义：
Test: A test is an on-board diagnostic software algorithm that determines the malfunction status of a component or system typically within a single operation cycle. Some tests run only once during an operation cycle. Other tests can run every program loop, sampling as often as every few milliseconds. The end result of a test represents acompletely matured / qualified condition (i.e., passed or failed). That means a test which needs a failing condition over a specific time or evaluation ofadditional plausibility checks before a component isconsidered to be failing will return a “Failed” condition only after all maturation criteria have been fulfilled.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/31302cf3bf562d82f709b65dfc62ffb1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27cfec2dde39d20170f6cab480ce49e4/" rel="bookmark">
			Redis windows 加服务启动运行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		redis版本：Redis-x64-3.2.100
命令：
redis-server --service-install redis.windows-service.conf --loglevel verbose
命令执行完毕，在服务里会有Redis服务
卸载服务：redis-server --service-uninstall
开启服务：redis-server --service-start
停止服务：redis-server --service-stop
服务被启动
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07a877ad80cf740833b4c61cf5c3b733/" rel="bookmark">
			如何用宝塔搭建网站
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何用宝塔搭建网站 一，宝塔 1.进宝塔查找地址（虚拟机内） 空格 ip addr 2.利用cmd来查找（方便复制粘贴） （1）ssh root@117.167.136.242（输入密码连接宝塔） （2）bt （3）14 （4）复制粘贴网站 把http://改为自己的地址 （5）会有宝塔面板的“账号密码” 进入宝塔
二，在宝塔内搭建网站 1.登录宝塔面板 宝塔面板的“账号密码” 2.添加站点 点击“网站”中的“添加站点”，输入域名（ip+端口----端口可自行设置一般8001），添加成功后会有数据库和 FTP的用户名和密码。 3.用IP地址在浏览器中打开 （如果成功则会在浏览器中出现创建成功） 4.放置文件代码 ①首先下载相关代码包，在面板左侧中选择“文件”，然后点击“上传”； ②选择下载好的相关代码压缩包上传，上传成功后记得解压缩。 ③删除创建网站生成的目录。 5.更改目录 ①点击“网站”，在刚建立的网站上面选择“设置”，更改网站目录，记得保存。 6.在浏览器中输入网站IP，创建成功时会显示相关创建网站。 三，如果一切没问问题后进网站仍然报错此时有以下可能 1.php版本的问题，下载一个低一点的版本，记得后续下好后同步切换。 2.端口的问题（要端口放行才行） 在添加站点的时候仅输入自己的IP，不用在后面加入端口号（让其用默认，但一定要看看有没有重复端口）
3.403/404报错 文件不给访问 把其他文件的都删了，只留一个主文件。 （centos搭建宝塔-宝塔安装sqllab的过程）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d72d4da5e8801ce2ba0b244e81f5ceee/" rel="bookmark">
			浅谈单目结构光原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在3D视觉技术中最常见的几类：结构光、双目和TOF。而单目结构光相比于双目，深度原理没有那么直观，双目立体视觉的原理和人眼感知距离的原理很相似，而单目结构光大部分是需要已知一个平面距离（将其称之为参考平面），而场景中的深度信息均基于参考平面计算得到。奥比的结构光深度相机由激光发射器projector、IR相机、RGB相机以及一块专门用于计算深度的处理器（深度引擎）组成。
结构光的基本原理：由激光模组发射散斑打在物体上（如图中O点），然后由IR模组接收由不同距离物体反射回来的散斑（如图中的成像点K1点），对于激光发出的同一射线PO,经过参考平面上的R点，在IR sensor上的成像点为R1 。因此对于R1和K1来说，该成像点实际上同一射线在不同距离下的投影点，这组匹配点位置的差作为视差d， 而O到相机平面的距离称之为深度z，所以z与视差d的相关可以根据相似三角形得知：
b：基线长度，设备的激光模组和ir模组之间的距离。
f: 焦距
z0: 参考平面的距离
d: 视差
b,f和z0 这三个参数与产品设计有关系，而单目结构光最关键的技术就是计算视差，如何找到当前场景中的散斑点和参考图上的散斑点事激光发射的同一点，那么最关键就属匹配算法了。奥比的结构光的匹配算法是由自主研发的深度引擎处理芯片，已经量产的芯片有MX400、MX6000和MX6300等等。
写在最后：上述结构光的数学模型是一个比较理想模型，可以自己思考，但IR的sensor平面与基线方向不平行时，那么上述的相似三角形就需要变化了。
当参考平面无穷远时，单目结构光的模型会发生什么变化？ 且听下回分解！
备注：
点击下面链接，进入奥比中光开发者社区，了解更多3D视觉技术信息：
https://developer.orbbec.com.cn/
或扫描下方二维码,进入奥比中光开发者社区：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05f54d4a92a502160b71773931ed0bd8/" rel="bookmark">
			Ubuntu16.04编译运行ORBSLAM3
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0、下载代码与数据集
代码：https://github.com/UZ-SLAMLab/ORB_SLAM3
数据集：https://projects.asl.ethz.ch/datasets/doku.php?id=kmavvisualinertialdatasets
注意：数据集下载ASL Dataset Format格式，每一行第二个link，本文下载用MH_03
1 、依赖安装
1.1 opencv
opencv需要3.0以上，本地安装3.4.1，下载地址：https://opencv.org/releases/
安装：
cd opencv-3.4.1/ mkdir build cd build cmake .. make sudo make install 配置环境变量：
sudo gedit /etc/ld.so.conf.d/opencv.conf 打开的文件输入：
/usr/local/lib 保存退出：
sudo ldconfig 编辑bashrc:
sudo gedit /etc/bash.bashrc 末尾插入：
PKG_CONFIG_PATH=$PKG_CONFIG_PATH:/usr/local/lib/pkgconfig export PKG_CONFIG_PATH 检查是否安装成功：
pkg-config opencv --modversion 1.2 Pangolin
下载地址：https://github.com/stevenlovegrove/Pangolin
安装：
mkdir build &amp;&amp; cd build cd build cmake .. make sudo make install Eigen3与Python一般版本合适，ROS自选。
2 编译
运行：
cd ORBSLAM3/ chmod +x .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/05f54d4a92a502160b71773931ed0bd8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3bbc55e1059206466d81fc35003353cd/" rel="bookmark">
			ubuntu16.04&#43;ORBSLAM3:/usr/local/lib/libopencv_imgcodecs.so.3.4.1：对‘TIFFReadDirectory@LIBTIFF_4.0’未定义
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本地环境为anaconda2、ROS等，参考这篇博客编译ORBSLAM3，碰见该问题。
解决方法：再ORBSLAM3目录下的CmakeList.txt中添加第二行：
target_link_libraries(${PROJECT_NAME} /usr/lib/x86_64-linux-gnu/libtiff.so.5 ${OpenCV_LIBS} /usr/lib/x86_64-linux-gnu/libpng.so /usr/lib/x86_64-linux-gnu/libpng12.so.0 ${EIGEN3_LIBS} ${Pangolin_LIBRARIES} ${PROJECT_SOURCE_DIR}/Thirdparty/DBoW2/lib/libDBoW2.so ${PROJECT_SOURCE_DIR}/Thirdparty/g2o/lib/libg2o.so -lboost_serialization -lcrypto ) 手动指定项目以来的链接库。
顺序很重要，一定要放到${OpenCV_LIBS}之前，一开始放于最后一行仍存在该问题。
参考其他博客，尝试过删除anaconda2、卸载过ROS的opencv等，没有解决。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9016ae8a937a2d77b56300a003417916/" rel="bookmark">
			每天一点小知识（算法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		算法的五大重要特征 有穷性（Finiteness）
算法的有穷性是指算法必须能在执行有限个步骤之后终止；
确切性(Definiteness)
算法的每一步骤必须有确切的定义；
输入项(Input)
一个算法有0个或多个输入，以刻画运算对象的初始情况，所谓0个输入是指算法本身定出了初始条件；
输出项(Output)
一个算法有一个或多个输出，以反映对输入数据加工后的结果。没有输出的算法是毫无意义的；
可行性(Effectiveness)
算法中执行的任何计算步骤都是可以被分解为基本的可执行的操作步骤，即每个计算步骤都可以在有限时间内完成（也称之为有效性）。
转载：https://baike.baidu.com/item/%E7%AE%97%E6%B3%95/209025?fr=aladdin
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/881c0cc1b502eb3d93decd3d21c4ab23/" rel="bookmark">
			顺序存储二叉树及线索化二叉树Java实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		±---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------@TOC
一、基本概念 1、顺序存储二叉树
从数据存储来看，数组存储方式和树的存储方式可以互相转换，即数组可以转化为树，树也可以转化为数组。
顺序存储二叉树的特点：
二叉树顺序存储通常只考虑完全二叉树。第n个元素的左子节点为2*n+1第n个元素的右子节点为2*n+1第n个元素的父节点为（n-1)/2n表示二叉树中的第几个元素或数组下标（从0开始编号）
如图所示：
2、线索化二叉树
对于n个结点的二叉树，在二叉链存储结构中有n+1【公式：2n-(n-1)=n+1】个空链域，利用这些空链域存放在某种遍历次序下该结点的前驱结点和后继结点的指针，这些指针称为线索，加上线索的二叉树称为线索二叉树。线索链表解决了无法直接找到该结点在某种遍历序列中的前驱和后继结点的问题，解决了二叉链表找左、右孩子困难的问题。
二、思路分析 1、顺序存储二叉树
对于给定的一个顺序存储的二叉树，实际上就是一个数组，只是对于普通的数组，我们在遍历时通常会按照由低索引向高索引依次遍历，而顺序存储的二叉树由于要考虑到它的原型是一个完全二叉树，所以在遍历时，需要先计算出对应节点左右子节点的索引，再按照树的前中后序遍历方法进行遍历。
2、线索化二叉树
如图所示二叉树进行中序线索化。
该二叉树的中序遍历序列为：[8,3,10,1,14,6]，将其进行线索化为：即叶子节点会生成一个指向中序遍历的前驱节点的索引
当线索化二叉树后，Node节点的属性left和right，会出现如下两种情况：
left指向的是左子树，也可能指向的是前驱节点。如节点1的left指向的是左子树，而10节点的left指向的则是前驱节点。right指向的是右子树，也可能指向的是后继节点。如节点1的right指向的是右子树，而节点10的right则指向的是后继节点。
所以在实现时，我们需要来设置一个标记区分这两种情况。 注意：线索化二叉树的遍历和前面说到的二叉树的遍历有所不同，因为前面的二叉树遍历停止的条件的当左子树或右子树为空，而线索化二叉树多了指向前驱或者后继节点的指针，所以会出现死循环。所以对于线索化二叉树的遍历可以通过线性方式进行遍历，无需再使用递归遍历。
三、代码实现 1、顺序存储二叉树
创建树结构以及相关遍历方法
class ArrBinaryTree { private int[] arr; public ArrBinaryTree(int[] arr) { this.arr = arr; } //封装前中后序遍历方法 public void preOrder() { this.preOrder(0); } public void midOrder() { this.midOrder(0); } public void postOrder() { this.postOrder(0); } /** * 前序遍历 * @param index 根节点索引 */ private void preOrder(int index) { if (arr == null || arr.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/881c0cc1b502eb3d93decd3d21c4ab23/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/554c694fd6796f578cbc5508c1dc2fb6/" rel="bookmark">
			什么是回表查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是回表查询？
这先要从InnoDB的索引实现说起，InnoDB有两大类索引：
聚集索引(clustered index)
普通索引(secondary index)
InnoDB聚集索引和普通索引有什么差异？
InnoDB聚集索引的叶子节点存储行记录，因此， InnoDB必须要有，且只有一个聚集索引：
（1）如果表定义了PK，则PK就是聚集索引；
（2）如果表没有定义PK，则第一个not NULL unique列是聚集索引；
（3）否则，InnoDB会创建一个隐藏的row-id作为聚集索引；
画外音：所以PK查询非常快，直接定位行记录。
InnoDB普通索引的叶子节点存储主键值。
画外音：注意，不是存储行记录头指针，MyISAM的索引叶子节点存储记录指针。
举个栗子，不妨设有表：
t(id PK, name KEY, sex, flag);
画外音：id是聚集索引，name是普通索引。
表中有四条记录：
1, shenjian, m, A
3, zhangsan, m, A
5, lisi, m, A
9, wangwu, f, B
两个B+树索引分别如上图：
（1）id为PK，聚集索引，叶子节点存储行记录；
（2）name为KEY，普通索引，叶子节点存储PK值，即id；
既然从普通索引无法直接定位行记录，那普通索引的查询过程是怎么样的呢？
通常情况下，需要扫码两遍索引树。
例如：
1
select * from t where name='lisi';　是如何执行的呢？
如粉红色路径，需要扫码两遍索引树：
（1）先通过普通索引定位到主键值id=5；
（2）在通过聚集索引定位到行记录；
这就是所谓的回表查询，先定位主键值，再定位行记录，它的性能较扫一遍索引树更低。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/050c257d46c98802fcc3d3edd275dac9/" rel="bookmark">
			springSecurity结合使用实现redis管理session
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. pom.xml 添加springsession的依赖：
&lt;span style="color:#000000"&gt;&lt;code&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.session&lt;/groupId&gt; &lt;artifactId&gt;spring-session-data-redis&lt;/artifactId&gt; &lt;version&gt;${spring.boot.version}&lt;/version&gt; &lt;/dependency&gt; &lt;/code&gt;&lt;/span&gt; 2. 进行springsession的redis配置 由于我application.yml中有使用jetcache进行远程redis连接配置，此处使用@value注解直接获取redis端口号等配置信息。进行jedis连接配置，还可以进行一些最大连接数的配置，这里我没有添加，使用默认的就好。
&lt;span style="color:#000000"&gt;&lt;code&gt;@Configuration @EnableRedisHttpSession public class SessionConfig { @Value("${jetcache.remote.default.host}") private String redisHost; @Value("${jetcache.remote.default.port}") private int redisPort; @Value("${jetcache.remote.default.password}") private String redisPwd; @Bean public JedisConnectionFactory connectionFactory() { RedisStandaloneConfiguration redisStandaloneConfiguration = new RedisStandaloneConfiguration(); redisStandaloneConfiguration.setHostName(redisHost); redisStandaloneConfiguration.setDatabase(0); redisStandaloneConfiguration.setPassword(RedisPassword.of(redisPwd)); redisStandaloneConfiguration.setPort(redisPort); return new JedisConnectionFactory(redisStandaloneConfiguration); } } &lt;/code&gt;&lt;/span&gt; 3. session配置 此处主要是将上面的redis配置添加到springsession中，使用刚才添加的redis进行sessino管理。
&lt;span style="color:#000000"&gt;&lt;code&gt;public class SecurityInitializer extends AbstractSecurityWebApplicationInitializer { public SecurityInitializer() { super(SessionConfig.class, Config.class); } } &lt;/code&gt;&lt;/span&gt; 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/050c257d46c98802fcc3d3edd275dac9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77fc5554992ad7caf53e9860e19e202b/" rel="bookmark">
			redis从入门到精通（五）———位图法统计活跃用户
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		位图法统计活跃用户 问题：
1、1亿用户，用户有频繁登录的，也有不经常登录的
2、如何来记录用户的登录信息
3、如何来查询活跃用户【如1周内登录3次的】
1）周一10个用户的初始化登录----未登录：0
127.0.0.1:6379&gt; setbit mon 100000000 0
(integer) 0
2）周一随机用户登录
5号用户登录
127.0.0.1:6379&gt; setbit mon 5 1
(integer) 0
7用户登录
127.0.0.1:6379&gt; setbit mon 7 1
(integer) 0
。。。
3）周二10亿用户的初始化登录----未登录：0
127.0.0.1:6379&gt; setbit tue 100000000 0
(integer) 0
4）周二随机用户登录
7号用户登录
127.0.0.1:6379&gt; setbit tue 7 1
(integer) 0
。。。
一直到周五
n) 统计
127.0.0.1:6379&gt; bitop and mon tuo wed thu fri sat sun
(integer) 12500001
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0189fde12533d56dfc3e009ea2ffcc46/" rel="bookmark">
			python实现简单的学生随机分班系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用说明：
该系统是Python编写 的一个简单的可以执行程序，主要用于解决简单的学生随机分班的问题，通过上传学生信息的Excel表格数据，实现学生数据的随机分班，生成一个随机分班的学生结果数据Excel的文件。
注意：上传模板要求：
1、模板第一行为学生标题信息，一般为 学生姓名、身份证号、性别、住址等信息，每一条信息代表一个学生
2、模板要求Excel格式的，并且要求数据的第三列必须为性别列，性别分类：“男” or “女”；
无法上传资源：想要的评论区留言，私信给你
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8db20dd27d2aff7bbeabca1ad507732f/" rel="bookmark">
			基于python生成的FPGA sata控制器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 源代码介绍 简介 本文中的SATA控制器是由GitHub上面python生成FPGA工程的开源库为基础，开发得到SATA控制器的。主要的优点有基本为纯逻辑代码，只是调用了少量的Xilinx的原语，移植方便。工程小，编译速度快，生成的自测工程一次编译只需两分钟左右。自带串口控制接口，可由串口对PL端的SATA控制器进行控制。
存在的问题 整个python工程生成的Verilog源代码仅存在一个源文件，代码量大，结构混杂在一起，不易阅读。传输数据中发送数据可以数据源无效时控制器可以长时间等待数据有效，但在接收数据时一旦接收数据命令发送则必须接收有效一直保持有效，否则会导致接收数据丢失，无法将接收做成带握手信号的数据接口。
源代码预留接口 input serial_cts, input serial_rts, output reg serial_tx, input serial_rx, (* dont_touch = "true" *)	input clk200_p, input clk200_n, input cpu_reset, input sata_clocks_refclk_p, input sata_clocks_refclk_n, output sata0_txp, output sata0_txn, input sata0_rxp, input sata0_rxn, output reg user_led0, output user_led1 其中串口控制的两个接口cts与rts在模块程序中并没有得到使用，可以根据具体的硬件信息加以应用。sata_clocks_refclk时钟信号为150MHz，user_led0，user_led1表示sata控制器的工作状态，0代表接收时钟是否正常，分频产生的1Hz的脉冲信号。1表示控制器接收控制信号是否准备好，准备好后常亮。由于本工程时自测工程所以在顶层接口中并没有给出相关的数据接口，数据源有本代码中的内部模块产生，数据校验也是如此，内部提供两种数据源，一种是数据计数器，另一种是伪随机数据。
整个源代码的工程结构 由底层往上分别是高速收发器、物理层、链路层、传输层、应用层、接口仲裁层、控制与数据接口、数据源与数据校验、uart转host接口控制寄存器。
其中前5个构成整个sata控制器的核心ip，接口控制层允许生成多个控制与数据接口，有多个接口同时申请发送或接收数据时进行仲裁。uart转host接口构成了一个小型的用户控制器，用户通过串口对寄存器进行赋值，读值来控制和识别当前控制器的工作状态。
源工程优化 解决接收存在的问题 上面介绍过接收时存在着无法使用握手信号暂时停止数据的接收，通过在ila中实时查看控制器每层状态机的工作状态，最终将问题定位在了链路层的状态机上。链路层的状态机中并没有将接收等待的相关逻辑添加到状态机中导致我们在接收数据中不能够控制从机端是否发送数据，且接收数据的缓存fifo的缓存深度只有一个扇区的大小，存在数据丢失的风险。最终整个解决的方案为：在链路层接收控制状态机中添加相关的接收等待的原语，将接收数据缓存的fifo深度扩大。其中需要注意的是对原语的控制，发送HOLD原语应当一直保持到接收到HOLDA原语后！
最后附上读写速率测试图（三星860PRO固态硬盘） 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c3d3f1b89e9b5fe94b12db22a8cdf4c/" rel="bookmark">
			【OS笔记 29】处理死锁的四种方法——避免死锁（资源分配图算法与银行家算法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、安全状态与不安全状态 系统处于安全状态时，就可避免死锁；处于不安全状态时，可能发生死锁。
所谓安全状态，是指系统此时能找到一个进程的序列&lt;P1,P2,P3…Pn&gt;，只要按照此顺序为其分配资源，就能使每个进程都能顺利完成。如果存在一个安全序列，那么系统则处于安全状态，否则就处于不安全状态。
在避免死锁方法中，允许进程动态地申请资源，但是系统在分配资源之间，会先计算此次资源分配的安全性，安全的话才分配，不安全的话便令进程等待。
二、计算资源分配安全性的两种方法 1. 资源分配图算法 （1）适用情况
每个资源类型只包含一个实例时可以使用。（为什么呢？因为只有当每种资源都是一个实例时，图中出现了环才表明这组进程出现了循环等待情况，才能断定是死锁的，如果有的资源不是一个实例的话，出现了环则可能发生了死锁，也可能没发生）
（2）判断方法
需求边 P2→ R2，表示进程 P2 在将来某个时刻会申请资源 R2，用虚线表示，如下面左图。
判断 P2 的这个申请是否会造成不安全状态：
假设已经将资源分配给 P2，所以要把 P2→ R2 的需求边转换为 R2→ P2 的分配边，如下面右图。
此时发现整个图中出现了环，所以现在进行 R2→ P2 的分配是不安全的。
（同样，如果没有出现环的话，就是安全的，是不是很简单呢）
2. 银行家算法 （1）数据结构
系统相关：
Available：可以利用的资源数组。Available[ j ] = K，说明 j 资源还有 K 个（也就是还剩下的资源）
进程相关：
最大需求矩阵 Max：进程所需要的总资源向量。Max [ i ，j ] = M ，说明进程 Pi 总共需要 M 个 j 资源。
需求矩阵 Need：进程还需要的资源向量。Need [ i ，j ] = N ，说明进程 Pi 还需要 N 个 j 资源。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4c3d3f1b89e9b5fe94b12db22a8cdf4c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1343f639b4e45f560b7936de1f8b9d81/" rel="bookmark">
			ARM平台搭建Hadoop 3.3.0 集群
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2020年6月的苹果WWDC大会上，苹果正式公布了基于ARM架构的自研Mac芯片计划，使用ARM芯片的Mac不久就将与大家见面；而早在2019年Q1，华为已经发布了用于数据中心的ARM架构处理器鲲鹏920，并在华为云上上线相应的资源，性价比大幅领先同级X86产品；AWS也在随后发布了自研的基于ARM架构的Graviton2芯片并同时提供了相应的虚拟机资源。可以看到，在通用处理器市场，由于性价比方面的巨大优势，已经有越来越多的厂商开始转向ARM架构。 有了硬件之后，有多少软件能够平稳的运行在这些硬件平台上，就成了用户们最关心的问题。开源软件作为影响整个行业的风向标，领域中最主流的开源软件能否在硬件平台上跑起来、跑得好对硬件平台在该领域的生态发展起到决定性的作用。因此国内(华为、麒麟等)外(ARM、Linaro等)各公司的开发者在从底层的基础库、加速库到IAAS、PAAS平台，再到大数据、数据库等业务软件的各主流开源社区进行大力投入，目前也以及取得了一些关键成果。
大数据作为目前最主要的业务领域之一，对数据中心硬件的软件生态发展有着重要意义，因此也吸引了众多开发者的重点关注。Hadoop作为开源大数据领域的最核心项目，也成为了各公司重点投入的方向。经过半年的开发和推动，2020年7月14日，Hadoop发布了3.3.0版本，除了众多新功能之外，在其release note中（https://hadoop.apache.org/docs/r3.3.0/index.html）最显著位置还声明了该版本是Hadoop发布的首个官方支持ARM架构的版本。
本文将记录实际安装步骤以及过程中发现的问题，安装完成后将运行几个常见的任务，验证功能性。
1. 下载 Hadoop 3.3.0版本发布后，在项目的下载页面（https://hadoop.apache.org/releases.html）增加了相应的连接，用户可以非常方便的进行下载：
我们的机器为ARM架构的鲲鹏920 CPU，因此下载binary-aarch64软件包：
P.S. util-linux需要升级到最新版本才lscpu功能才能够正常解析CPU具体信息，否则以编码形式呈现
下载：
解压：
tar -xzvf hadoop-3.3.0-aarch64.tar.gz cd hadoop-3.3.0/ 2. 配置Hadoop Core和HDFS Hadoop支持多种部署方式，我们这里使用伪分布式(Pseudo-Distributed)模式进行部署，以便完整的验证HDFS、YARN、Mapreduce三个部分的功能。
首先修改Hadoop-core和HDFS的配置文件：
etc/hadoop/core-site.xml:
&lt;configuration&gt; &lt;property&gt; &lt;name&gt;fs.defaultFS&lt;/name&gt; &lt;value&gt;hdfs://localhost:9000&lt;/value&gt; &lt;/property&gt; &lt;/configuration&gt; etc/hadoop/hdfs-site.xml:
&lt;configuration&gt; &lt;property&gt; &lt;name&gt;dfs.replication&lt;/name&gt; &lt;value&gt;1&lt;/value&gt; &lt;/property&gt; &lt;/configuration&gt; 虽然是伪集群式部署模式，各组件间的交互仍然是会使用SSH调用的，为了能够正常相互访问，需要配置本机自己的免密SSH访问：
ssh-keygen -t rsa -P '' -f ~/.ssh/id_rsa cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys chmod 0600 ~/.ssh/authorized_keys 通过下面命令检查是否配置成功：
ssh localhost 首先导入JAVA_HOME环境变量，具体路径需要根据自己系统的实际情况进行配置，同时通过Hadoop自带脚本启动Hadoop服务时要将环境变量导入到相应的脚本中：
export JAVA_HOME=/usr/lib/jvm/java-8-openjdk-arm64/ echo "export JAVA_HOME=/usr/lib/jvm/java-8-openjdk-arm64/" &gt;&gt; etc/hadoop/hadoop-env.sh 初始化文件系统：
bin/hdfs namenode -format 启动Namenode和Datanode服务：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1343f639b4e45f560b7936de1f8b9d81/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ab5a6212506661628fd9c056a6f55b2/" rel="bookmark">
			Spring的单例bean与原型bean的区别和创建过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Spring官方文档中给出的bean的scope有五种 singletonprototyperequestsessionglobal session 实际上，Spring最基本的scope只有两种，即singleton和prototype。
可以参看spring源码中的BeanDefinition.java的定义，只有这两种：
String SCOPE_SINGLETON = ConfigurableBeanFactory.SCOPE_SINGLETON; String SCOPE_PROTOTYPE = ConfigurableBeanFactory.SCOPE_PROTOTYPE; 其他的各种scope都是自行扩展出来的。包括官网文档中没有列出来的 servletContenxt 、thread；SpringCloud提供的refresh等。
其继承关系大致如下
singletonScope与prototypeScope singletonScope，即单例Bean，顾名思义具有单例模式的所有特性，在spring容器里面只会初始化出一个bean实例，存于缓存中。后续的请求都公用这个对象。
最简单的创建单例bean的方式，就是直接在类名上面加@Service注解。prototypeScope，即原型Bean，每次请求时都会创建新的bean实例直接使用。
创建原型Bean，需要显示指定scope属性。 可以参看spring的 AbstractBeanFactory.java 中的 doGetBean 方法，理解两种bean的使用过程 单例bean的创建
单例bean被存放在这样一个Map中：
/** Cache of singleton objects: bean name --&gt; bean instance */ private final Map&lt;String, Object&gt; singletonObjects = new ConcurrentHashMap&lt;String, Object&gt;(256); 上面代码中的 getSingleton 方法，作用就是先根据beanName从map(singletonObjects)中取bean，
取不到的话，调用后面的singletonFactory的createBean方法创建单例bean（这里的createBean是抽象方法，具体实现交给了各种scope的实现类负责），
创建成功以后，存入singletonObjects，并将引用返回。
原型bean的创建
中规中矩，上来就直接创建，然后分befoew、createBean、after三个生命周期，对于具体实现提供充分的支持。
至于最后一句 getObjectForBeanInstance，如果上面创建的是一个普通bean则直接返回；如果创建的是一个BeanFactory的实例，则利用工厂实例创建新的bean，然后返回。
对于其他扩展出来的scope
会利用 接口 Scope.java 中定义的这个方法，调用各扩展scope的实现去创建bean：
// Return the object with the given name from the underlying scope, Object get(String name, ObjectFactory&lt;?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1ab5a6212506661628fd9c056a6f55b2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e0bc3ac1e2697d793255ae36bb5e4d7/" rel="bookmark">
			JavaScript事件 内置对象
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一 事件 JavaScript创建动态页面。事件是可以被JavaScript侦测到的行为。
网页中的每个元素都可以产生某些可以触发JavaScript函数或程序的事件。
比如，当用户单击按钮或提交表单数据时，就发生一个鼠标单击（onclick）事件，需要浏览器做出处理，返回给用户一个结果。
主要事件表：
鼠标单击事件（onclick） 当在网页上单击鼠标时，就会发生该事件。同时onclick事件调用的程序块就会被执行，通常与按钮一起使用。
&lt;body&gt; &lt;form&gt; &lt;input name="点击我" type="button" value="点击我" onclick="openwin()"/&gt; &lt;!--openwin()为javascript函数--&gt; &lt;/form&gt; &lt;/body&gt; 鼠标经过事件（onmouseover） 当鼠标移到一个对象上时，该对象就触发onmouseover事件，并执行onmouseover事件调用的程序。
&lt;script type="text/javascript"&gt; function message(){ confirm("请输入密码后，再单击确定!"); } &lt;/script&gt; &lt;body&gt; &lt;form&gt; 密码:&lt;input name="password" type="password" &gt; &lt;input name="确定" type="button" value="确定" onmouseover="message()"/&gt; &lt;/form&gt; &lt;/body&gt; 鼠标移开事件（onmouseout) 当鼠标移开当前对象时，执行onmouseout调用的程序。
&lt;script type="text/javascript"&gt; function message(){ alert("不要移开，点击后进行慕课网!"); } &lt;/script&gt; &lt;form&gt; &lt;a href="http://www.imooc.com" onmouseout="message()"&gt;点击我&lt;/a&gt; &lt;/form&gt; 光标聚焦事件 （onfocus） 当网页中的对象获得聚点时，执行onfocus调用的程序j就会被执行。
失焦事件（onblur） 与onfocus是相对事件，当光标离开当前获得聚焦对象的时候，触发onblur事件，同时执行被调用的程序。
内容选中事件（onselect） 当文本框或文本域中的文字被选中时，触发onselect事件，同时调用的程序就会被执行。
文本框内容改变事件（onchange） 通过改变文本框的内容来触发onchange事件，同时执行被调用的程序。
加载事件（onload） 事件会在页面加载完成后，立即发生，同时执行被调用的程序。
加载页面时，触发onload事件，事件写在&lt;body&gt;标签内。加载页面，可理解为打开一个新页面时。 如下代码,当加载一个新页面时，弹出对话框“加载中，请稍等…”。
&lt;!DOCTYPE HTML&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2e0bc3ac1e2697d793255ae36bb5e4d7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb888351be5997bc18465171dd3fa0f7/" rel="bookmark">
			Selenium3自动化测试【1】自动化测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1. 自动化测试
1. 1. 自动化测试定义
1.2 何时开展自动化测试
1. 自动化测试 为何要开展自动化测试？手工测试与自动化测试相比孰优孰劣呢？本节针对该问题展开讨论与讲解。
测试工作中，往往需要面对很多问题。经常可以听到测试工程师的抱怨，其抱怨内容大体如下：
重复、频繁的工作太多；
同样的工作，人工重复做的次数越多，抵触情绪较大；
测试工作任务重，测试周期短，工作压力大；
创新性的工作太少，无法体现自己的能力与自己的人生价值；
测试结果有时需要精确到秒，手工测试来做太难了。
那如何将测试工程师从繁杂的测试工作中解脱出来？如何体现测试工程师的价值，发挥测试工程师的特长？又如何将测试结果精确到秒呢？
上述问题均可以通过自动化测试来解决，这样一方面提高了测试的工作效率，另一方面可以通过自动化测试提升测试工程师的价值，改变大部分人对测试工作的观点。
1. 1. 自动化测试定义 既然自动化测试可以弥补手工测试的一些不足，并能体现测试工程师的价值，那何为自动化测试？它又具备哪些特性？
自动化测试即借助于测试工具、依照测试规范，从局部或全部代替人工进行测试以及提高测试效率的过程。其具备如下主要特征：
自动测试过程是通过模拟人工操作，完成对被测试系统的输入，并且对输出进行检验的过程。
自动测试是由软件代替人工操作，对被测试系统的GUI发出指令，模拟操作，完成自动测试过程。
相对于手工测试，自动化测试可概括为如下几点：
优化成本：降低劳动量，降低测试成本；
可靠：提高测试的全面性，提高测试精确度；
快速：加快测试速度；
规范化：提供规范化的测试流程；
可重用：提高测试的重用性。
1.2 何时开展自动化测试 什么时候适合开展自动化测试呢？
测试工作中，被测软件（或系统）需要多个版本的迭代。根据公司（或项目）的不同，版本发布的时间也存在差异。
开展自动化测试之前，首先需依照测试用例，对被测功能模块展开手动测试。当手动测试执行通过后，使用自动化测试工具，将手动测试的操作过程录制下来，并将正确的结果进行保存（被称为期望结果）。由于自动化测试工具记录的为关键性功能模块，被测软件（系统）的下一版本发布后，该模块仍应进行测试。
在软件新版本的测试中，启动自动化测试工具，运行前面录制好的自动化测试脚本。对比实际运行后的结果与预期结果，如不一致，则确定为缺陷；如一致，则认为该功能模块在新的版本中测试通过。
到此，可以得出一条结论：自动化测试，适合在被测软件（或系统）版本相对稳定后开展。如软件版本相对不太稳定，则会造成使用自动化测试工具录制的脚本在新的版本中回放失败，这样既浪费人力，又浪费时间。
更多【全栈测试】视频课程，点击我哦.....
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/232/">«</a>
	<span class="pagination__item pagination__item--current">233/321</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/234/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>