<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ba010d103f70b9b2bbb9c44739f5d56/" rel="bookmark">
			删除字符串中的重复字符（C语言）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 #include&lt;stdio.h&gt; #include&lt;string.h&gt; unsigned int Delete_duplicate_characters(char *p){ unsigned int i,j,m; unsigned int len=strlen(p); for(i=0;i&lt;len-1;i++){ for(j=i+1;j&lt;len;j++){ if(p[i]==p[j]){ for(m=j;m&lt;len;m++){ p[m]=p[m+1]; } len--;//字符串长度减去1 j--;//此时因为移位新生成的字符串数组，j的位置往前跑了，所以对应的j的数应该减1 } } } return strlen(p); } int main() { char a[1024]={0}; gets(a); printf("%d\n",Delete_duplicate_characters(a)); return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a05c8066bb014772ac8b2615f836a41/" rel="bookmark">
			PowerShell 设置 wsl2 linux 端口映射
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 PowerShell 代码
netsh interface portproxy delete v4tov4 listenport=80 listenaddress=0.0.0.0 wsl ifconfig eth0 | where {$_ -match "inet "} | Foreach-Object{($_ -split "\s+")[2]} | tee-object -variable ipaddress netsh interface portproxy add v4tov4 listenport=80 listenaddress=0.0.0.0 connectport=80 connectaddress=$ipaddress netsh interface portproxy show all 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ca5d1097d91a43dac04dcffeeef7756/" rel="bookmark">
			【异步电机】矢量控制与标量控制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一. 概述 异步电机的控制方法可以划分为矢量控制与标量控制。
在标量控制中，仅对电压、电流、以及磁链等矢量的幅值和旋转频率进行控制，如恒压频比(VF)控制技术。
在矢量控制中，将矢量的瞬时位置纳入控制范畴，如矢量控制(F0C)、直接转矩控制(DTC)、模型预测控制(MPC) 等高性能控制方法。
简单介绍几个工控产品:
标量+矢量思想
1.所有国产变频器V/F控制中的自动转矩提升功能
2.台达VE系列 SVC（感应电机无感测向量控制） 应用在提升机械、低速传动机械，也会先做参数整定。
3.西门子MM系列FFC控制模式（带磁通电流控制FCC 的V/F 控制）
以上三种功能的实现方法基本相通
矢量控制
1.汇川 SVC(无速度传感器矢量控制),FVC(有速度传感器矢量控制)
2.西门子MM系列变频器，SLVC(无传感器矢量控制),VC(矢量控制)
目前，国产变频器的矢量性能有非常好的表现，大家可以多多支持国产变频器的发展。
举个例子，台达C2000老版本中:
1.V/F控制
2.SVC控制
3.无感FOC控制
4.FOC PG控制
新版本C2000
1.FOC控制
二. 详细介绍 VF控制 本质上是一种开环的标量控制，在其控制过程中，通过让电机定子电压与频率的比值保持恒定，来确保电机内部气隙磁链保持不变，从而确保调速过程中电机的有效带载能力不变。
优点: 简单有效，无需要电机参数，普适性强。
广泛应用于一般工业调速场合，如在风机、水泵等场合有着较广的应用。
缺点: 开环控制系统，导致控制的动静态性能差，转矩脉动也较大。
矢量控制 矢量控制以磁场定向为基础，将异步电机励磁回路和转矩回路进行解耦控制，便于控制精度和动态性能的提升。
转子磁场定向矢量控制:
通过坐标变换，将参考坐标选定为转子磁链定向的同步旋转坐标系，经过坐标变换，可将定子电流解耦分解为励磁分量和转矩分量。 其中励磁分量直接决定电机的转子磁链的大小，在转子磁链恒定的情况下，定子电流的转矩分量与电机的电磁转矩成正比。
这样就可以将交流异步电机控制技术转化为类似直流电机的控制方法，进而对其磁链和转矩进行独立控制。
优点: 解耦后的异步电机控制性能可与直流调速相当。
缺点: 传统矢量控制需要大量的坐标变换，且磁场定向的准确度受电机参数的影响较大，若定向不准,则会恶化控制性能。而且由于其电流闭环采用的是依赖于反馈误差的因果控制逻辑，动态响应速度较慢，且受到需要调节相关参数，容易出现超调和震荡。
直接转矩控制 直接转矩控制主要由滞环比较器、转矩和磁链估计、电压矢量选择等几部分组成，其基本原理在于直接对电压矢量和对应的控制信号进行选择，以达到对电磁转矩和定子磁链进行实施控制的目的。
优点:
直接转矩控制在控制电机时，依据转矩和磁链控制误差，按照既定的规律直接对逆变器的输出矢量进行选择，而无需像磁链定向矢量控制那样对定子电流进行转矩分量和励磁分量的分解，也无需电流调节器设计和PWM调制，简化的控制系统的实现过程和运算量，降低了参数依赖性，提升了转矩动态响应性能。
缺点:
(1) 由于电磁转矩和磁链难以或不适宜通过传感器进行检测，而是依赖转矩和磁链观测器对其进行估计，观测器的性能无疑也将影响直接转矩控制系统的实际应用性能。
(2)直接电压矢量的选择，尽管避免的PWM调制运算，并能在一定程度上减少了开关管的平均动作次数，但这也导致了开关频率不固定所引发的谐波问题和开关管发热不均问题。
(3)通过滞环比较器来对转矩进行控制会使得电流和转矩的脉动都比较大，尤其在低速运行时，控制效果较差。
目前在工业上应用最广泛的主要是矢量控制和直接转矩控制两种控制模式。两种控制方式各有侧重。
矢量控制主要应用在宽范围和高精度控制系统中，直接转矩控制主要应用在转矩响应快的场合。同时，二者也各有不足之处，对于前者近些年的主要研究工作重点是提高其控制的鲁棒性，而对于后者则主要在提高其低速性能。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5cbf73e7909e17ee81e62cf6291a6f4/" rel="bookmark">
			MYSQL存储过程进行写读操作（for循环）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在我们做统计的时候，尤其是复杂的数据统计，写sql是非常麻烦且痛苦的一件事情。尤其是表结构设计的不适合做统计的时候，更是难以下手。当做 统计的时候；需要牵扯到多张表且每个统计信息需要关联N张表才能出来结果的时候，大家可以用mysql的存储过程来进行业务处理。
前端时间做统计；业务场景是这样的：
首先判断当前时间是否为一月，若是一月，则取每个机构的去年和前年的每个月的收入统计；若不是一月，则取每个机构的今年和去年的每个月的收入统计。
存储过程进行for循环的业务逻辑呢大体是这样的：
通过定义变量（把值塞给变量，可以是数据库查到的，也可以是自定义），
定义游标（进行for循环，在for循环内进行读取数据，把读取的数据塞给变量，通过这些变量进行insert into 表，从而把得到的数据保存到临时表里。）
定义循环体判断变量，用来判断循环何时结束。
如下图：
1: DECLARE 是定义变量的语法。
2: DECLARE deptInfo CURSOR FOR select dept_id,dept_name from sys_dept where parent_id=‘100’ and del_flag=‘0’ and status=‘0’;
DECLARE deptInfo CURSOR FOR select dept_id,dept_name 意思是把查询的结果赋值给定义的游标deptInfo 。
2：对游标进行循环，在循环内进行业务处理
如上 就是存储过程进行for循环处理的流程。好了本次分享就到此结束。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bed7988335ba2c0631fe31897550ef65/" rel="bookmark">
			mAP@0.5与mAP@0.5:0.95的含义
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mAP@0.5: mean Average Precision（IoU=0.5） 即将IoU设为0.5时，计算每一类的所有图片的AP，然后所有类别求平均，即mAP。
mAP@.5:.95（mAP@[.5:.95]） 表示在不同IoU阈值（从0.5到0.95，步长0.05）（0.5、0.55、0.6、0.65、0.7、0.75、0.8、0.85、0.9、0.95）上的平均mAP。
那AP是什么呢，Average Precision，是单个类别平均精确度，而mAP是所有类别的平均精确度
AP是Precision-Recall Curve曲线下面的面积
曲线面积越大说明AP的值越大，类别的检测精度就越高。Recall官方称为召回率，可以考虑叫做查全率，Precision官网称为准确率叫做查准率，两者是相互矛盾的指标，如果能够较好的平衡两者，将在不同的条件下得到较好的检测效果，也就是图中的曲线面积。
P r e c i s i o n = T P T P + F P Precision= {TP \over TP+FP} Precision=TP+FPTP​
R e c a l l = T P T P + F N Recall = {TP \over TP + FN} Recall=TP+FNTP​
​其中（混淆矩阵）：
True Positive区域：正样本预测为正样本
False Positive区域：负样本预测为正样本
False Negative区域：正样本预测为负样本
True Negative区域：负样本预测为负样本
预测样本在检测中就是预测框的大小，我们设置的IoU就是指的真实框与预测框的交并比，如果大于阈值就是正确，小于就是错误。
这里强调一下，当我们的样本与GT交并比确定之后，这里还不能确定TP、FP、FN、FN指标，只能说确定了预测正负样本的类别，但不能说真实正确样本的类别。需要通过置信度或者类的预测概率进行确定，主要是设定不同的阈值。这么说可以比较抽象，举个例子
上图是我们生成的预测框与GT样本的IOU计算结果（最右列），根据IOU阈值和计算的IOU值可以确定预测候选框正负样本的类别，但是是否真正为正样本还是负样本，主要取决于置信度的阈值，当我们设置一个置信度阈值时，可以得到对应的一个P和R，通过设置不同的置信度阈值时，就可以得到多个P和R，进一步绘制的PR曲线。
总结一下mAP的计算过程：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bed7988335ba2c0631fe31897550ef65/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7203fa6fd74b1da33c20220b4b944567/" rel="bookmark">
			盘点一下PostgreSQL和MySQL的区别点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上期有说，数据环境切换，由MySQL换成PostgreSQL。
那么为了大家以后少踩坑，简单总结了下我曾踩过的坑和需要注意的点。
首先PostgreSQL有一个模式的概念。
一、格式区别：
和Oracle一样,PostgreSQL也是严格区分大小写。
二、符号区别：
和Oracle一样PostgreSQL中，" " 双引号是区分库名，关键字等，而MySQL则是反单引号(tab键上方的键)，pg查询时字符类型的字段必须使用单引号，而MySQL带有优化器（不是必须）。
三、自增区别：
MySQL中使用auto_increment ，在需要的列指定自增，而pg中需要设置自增序列。
（1）使用SQL语句
①创建表时
CREATE table infisa_template_config(id serial ); ②表已存在
&lt;--设置序列从1开始，自增1--&gt; CREATE SEQUENCE user_id_seq START WITH 1 INCREMENT BY 1 NO MINVALUE NO MAXVALUE CACHE 1; &lt;--设置序列--&gt; ALTER table user ALTER column id SET DEFAULT nextval('user_id_seq'); (2)使用可视化工具
连接navicat15（或者使用DBeaver）
点击序列
可以通过可视化界面新建序列
注：同步数据的话，推荐通过sql方式新建序列。
四、函数区别：
(1)时间转化
①时间转字符串：
MySQL: date_format(a.tag_create_date,‘%Y-%m-%d %H:%i:%s’)
PostgreSQL: to_char(a.tag_create_date,‘yyyy-mm-dd HH:MM:SS’)
②字符串转时间：
MySQL: date_format(a.tag_create_date,‘%Y-%m-%d %H:%i:%s’)
PostgreSQL: to_date(a.tag_create_date,‘yyyy-mm-dd HH:MM:SS’)
(2) IFNULL()函数
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7203fa6fd74b1da33c20220b4b944567/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/beaf73055073af50b774c829ba7f1485/" rel="bookmark">
			Flink中的窗口函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1. 增量聚合函数（incremental aggregation functions）
（1）归约函数（ReduceFunction）
（2）聚合函数（AggregateFunction）
2. 全窗口函数（full window functions）
（1）窗口函数（WindowFunction）
（2）处理窗口函数（ProcessWindowFunction）
3. 增量聚合和全窗口函数的结合使用
4、窗口的生命周期
1. 窗口的创建
2. 窗口计算的触发
3. 窗口的销毁
4. 窗口 API 调用总结
经窗口分配器处理之后，数据可以分配到对应的窗口中，而数据流经过转换得到的数据类 型是 WindowedStream 。这个类型并不是 DataStream ，所以并不能直接进行其他转换，而必须 进一步调用窗口函数，对收集到的数据进行处理计算之后，才能最终再次得到 DataStream ，如 图 6-21 所示。 窗口函数定义了要对窗口中收集的数据做的计算操作，根据处理的方式可以分为两类：增 量聚合函数和全窗口函数。下面我们来进行分别讲解。 1. 增量聚合函数（incremental aggregation functions） 为了提高实时性，我们可以再次将流处理的思路发扬光大：就像 DataStream 的简单聚合 一样，每来一条数据就立即进行计算，中间只要保持一个简单的聚合状态就可以了；区别只是 在于不立即输出结果，而是要等到窗口结束时间。等到窗口到了结束时间需要输出计算结果的 时候，我们只需要拿出之前聚合的状态直接输出，这无疑就大大提高了程序运行的效率和实时 性。 典型的增量聚合函数有两个： ReduceFunction 和 AggregateFunction。 （1）归约函数（ReduceFunction） 最基本的聚合方式就是归约（reduce）。 窗口函数中也提供了 ReduceFunction ：只要基于 WindowedStream 调用 .reduce() 方法，然 后传入 ReduceFunction 作为参数，就可以指定以归约两个元素的方式去对窗口中数据进行聚 合了。这里的 ReduceFunction 其实与简单聚合时用到的 ReduceFunction 是同一个函数类接口， 所以使用方式也是完全一样的。 ReduceFunction 中需要重写一个 reduce 方法，它的两个参数代表输入的两 个元素，而归约最终输出结果的数据类型，与输入的数据类型必须保持一致。也就是说，中间 聚合的状态和输出的结果，都和输入的数据类型是一样的。 下面是使用 ReduceFunction 进行增量聚合的代码示例 import org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/beaf73055073af50b774c829ba7f1485/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/22b7f1487b0e6c819381a29701f1ac05/" rel="bookmark">
			智慧监狱UWB定位系统解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、项目背景 目前我国有部分特殊场所对在需被管控人员的管理还停留在以巡逻员巡查加摄像机监视报警的阶段，人工作业仍占绝大比重，信息采集依赖人工，其管理的技术痛点主要表现在：
1、巡逻人员不足，因而增加了不稳定因素；
2、特殊场所信息化程度比较低，无法将信息系统和在被管控人员真正地关联起来，无法第一时间了解人员的动态以及实时位置；
3、现有的监控系统各成体系，没有统一的标准和接口，一旦出现紧急事件，各系统之间无法及时联动，监控图像和其他安防资源不能共享，无法快速高效地发挥防范作用。本套解决方案有效的解决以上问题，让特殊场所管理更加智能化、透明化、安全化。
二、系统构成
技术原理：UWB(Utra WideBand）是一种无载波通信技术，利用纳秒至微秒级的非正弦波窄脉冲传输数据。UWB调制采用脉冲宽度在ns级的快速上升和下降脉冲，脉冲覆盖的频谱从直流至GHz，不需常规窄带调制所需的RF频率变换，脉冲成型后可直接送至天线发射。频谱形状可通过甚窄持续单脉冲形状和天线负载特征来调整。UWB信号的辐射非常低，通常只有手机辐射的千分之一，因此在工业上应用时，其不存在对其他仪器仪表的干扰问题。
设备：
基站：要使用UWB技术给一个空间做定位，必须要事先在该空间安装好定位基站。基站通过UWB信号和定位标签进行通信，实现标策的定位功能。
标签：待定位的人员、资产上须佩戴定位标签。标签发射UWB信号，与基站相互通信，使标签自身被定位。
定位引擎：环境中的基站实时通过网络原始数据发送给定位引擎（可位于本地服务器或云端）。定位引擎运行定位算法，实时计算标签的坐标位置。
显示终端：定位引擎计算出的标签坐标，可在任意浏览器显示终端上呈现。
系统拓扑图
三、系统亮点
有线UWB系统定位解决方案可实现优于20厘米高精度定位，能够准确监测人员位置。
1.针对被管控人员：实现全程定位，视频跟踪留档；
2.针对巡逻员：监督单人不规范作业行为；
3.针对来访人员：实现区域进出权限监管；
4.基站采用POE方式供电及联网，即网线（超五类）里面包含电源，不需要再单独架设电源线，大幅度节约部署成本；
5.基站使用网线回传数据，不经过公网，信息更安全；
6.可订制人脸识别监控摄像头，监控被管制人员异常行为，第一时间追踪人员位置。
四、相关硬件
1.UWB防拆手环06 UWB防拆手环相当于定位对象的“身份证”，用于和固定在附近的定位基站进行通讯，结合管理系统，能实现定位对象的实时定位/历史轨迹/电子围栏/电子点名/电子考勤/视频联动/心率监测/运动监测等功能。
技术参数
产品型号
DDX06
跟踪精度
无遮挡情况下，最高定位精度可达0.3米
跟踪频率
运动1秒3次定位，静止3秒1次定位，可设置
跟踪方式
基于到达时间差的TDOA
覆盖范围
空旷环境下可达60米
工作频率
3.75-4.25GHz
发射功率
27dBm
识别方向
全向
消息收发
能接收平台推送的设置指令及消息，也可发送报警信息到平台
运动监测
能实现计步及运动监测，具备自动休眠功能
生命体征
支持心率实时/定时测量。
NFC
兼容
产品材质
外壳为PC材质，表带为环保亲肤型TPU材质。
操作按键
触摸按键，只可开机，不可关机，按键可做紧急报警用
防拆设计
表带佩戴时采用一次性封签密封，防止随意拆卸。表带具有传导电路，结合手环内置的多重传感器，非法拆卸立即报警。
报警类型
消失报警、拆卸报警、低电报警、越界报警等。
提醒方式
震动提醒
对外接口
触点式，可通过充电器转换为USB
电池
内置可充电500mAh聚合物锂离子电池
待机时间
60天
充电电压
5V
充电时间
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/22b7f1487b0e6c819381a29701f1ac05/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a93d34f41b8b2c7510305657d7f21608/" rel="bookmark">
			多线程和List分段解决批量添加或更新慢的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在项目中对数据进行批量操作的时候，都会有慢的问题，尤其是针对数据量极大的情况下，下面说一下简单的多线程的优化方式：
步骤如下：
获取需要进行批量更新的大集合 A，对大集合进行拆分操作，分成 N 个小集合 A-1 ~ A-N开启线程池，针对集合的大小进行调参，对小集合进行批量更新操作对流程进行控制，控制线程执行顺序 封装List的拆分工具类
/** * List按指定长度拆分 * * @param list 要拆分的list * @param size 拆分的长度 * @param &lt;T&gt; 泛型 * @return */ public static &lt;T&gt; List&lt;List&lt;T&gt;&gt; partition(final List&lt;T&gt; list, final int size) { // 非法处理 if (CollectionUtil.isEmpty(list) || size &lt;= 0) { return Lists.newArrayList(); } List&lt;List&lt;T&gt;&gt; result = Lists.newArrayList(); // 迭代器 Iterator&lt;T&gt; it = list.iterator(); // List片段存储器 List&lt;T&gt; subList = null; while (it.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a93d34f41b8b2c7510305657d7f21608/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f09251845c6a60a4f4a8b43e4ca1a1b7/" rel="bookmark">
			JS文本流转字符串 FileReader()
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JS文本流转字符串FileReader()
let reader = new FileReader() // 传入需要被转换的文本流 file,这个是转字符串的关键方法 reader.readAsText(file) // onload是异步的,封装的话可以用promise reader.onload = () =&gt; { // 输出字符串 console.log(reader.result) } 注意：如果你从接口拿到的拿到的文本流是个字符串格式，务必转成文本流格式
request({ url: '/getBlob', method: 'GET', responseType: 'blob' // 这个默认是 json 一定要设置好了blob才能用 data: {}, }) 关于 FileReader 的详解可参考MDN
js中FileReader()用法 这篇文章写的不错,可以参考下
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/642ee8534cc907d28b3c78ae7dba050b/" rel="bookmark">
			小程序 | 自定义轮播指示点、单选、多选框的样式修改
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：
小程序中有些组件的伪类样式在开发者工具中预览不了
每次要改样式都要搜一下感觉很麻烦
现在把平时自己有用到的记录下：
1. 基于vant Weapp的自定义单选框样式：（此处展示radio的样式，checkbox同理即可）
1.1 先来看下vant官网中展示的效果图：
如果跟官网需求一样的就直接官网的就好。
1.2 自定义之后的效果如图：
代码如下：
&lt;view class="blis"&gt; &lt;van-radio-group value="{{ radio }}" bind:change="chooseRadio"&gt; &lt;block wx:for="{{arr}}"&gt; &lt;van-radio name='{{item.id}}' custom-class='{{item.isact?"radioact":""}}'&gt; {{item.title}} &lt;/van-radio&gt; &lt;/block&gt; &lt;/van-radio-group&gt; &lt;/view&gt; .blis{display: flex;flex-wrap: wrap; .van-radio { display: inline-block; margin: 0 10rpx 10rpx 0; } .van-radio__icon-wrap {display: none;} .van-radio__label { min-width: 165rpx;height:80rpx;line-height: 80rpx; padding: 0 10rpx;box-sizing: border-box;text-align: center; background-color:#f4f5f8;border:1.5rpx solid #f4f5f8; border-radius:15rpx; color:#595959; font-size:26rpx; word-break: break-word; } .radioact .van-radio__label { color:#3474f6; border-color: #3474f6; background-color:#f5f7ff; } } 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/642ee8534cc907d28b3c78ae7dba050b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/079429bdc7480a6fd463e2ae88fd4b09/" rel="bookmark">
			rabbitmq管理页面发送消息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有的时候我们因为一些特殊的原因或者需要测试某个功能，需要发送mq，但是又不能直接触发消息。这种情况下，我们可以直接在mq控制台发送消息。
一、首先打开rabbitmq管理台
二、右上角选择环境，开发或者测试
三、打开Queues Tab页
四、选中某个queue，页面下拉到Publish message块
1、在properties里面加一行键值对key:content_type, value:text/plain
2、在payload里面加消息体，json格式
见图：
3、点击按钮Publish message即可发送消息到队列
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a9b22ef0c2e3570a6bd6bee5f491d71/" rel="bookmark">
			十、Echart图表 之 dataZoom区域缩放 基本使用与配置大全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🍓 作者主页：💖仙女不下凡💖
🍓 前言介绍：以下👇内容是我个人对于该技术的总结，如有不足与错误敬请指正！
🍓Echart官网地址：https://echarts.apache.org/examples/zh/index.html#chart-type-line
🍓 欢迎点赞👍 收藏⭐ 留言📝 相关账号会持续发布关于文章Echart的相关文章欢迎持续关注！
✨参照官网，dataZoom 中有两个对象如下，这样写是因为type分为 鼠标滚动 与 滑动条 两种缩放方式，当type类型不同时，里面配置的属性略有不同，请根据实际需求使用
dataZoom: [ { type: 'inside' }, // 用哪种方式就写哪个对象 { type: 'slider' } ] ✨其他属性请参考一下内容
/有值的都可视为默认值/ dataZoom: [ { type: 'inside', // 类型, inside表示鼠标滚动进行缩放 id: '', disabled: false, // 是否停止组件的功能 xAxisIndex: '', // 组件控制的 x轴, 默认全部 yAxisIndex: '', // 组件控制的 y轴 radiusAxisIndex: '', // 组件控制的 radius轴 angleAxisIndex: '', // 组件控制的 angle轴 filterMode: '', // 可选值filter/weakFilter/empty/none，详解如下 start: 100, // 数据窗口范围的起始百分比。范围是：0~100, 表示0%~100%同下 end: 100, // 数据窗口范围的结束百分比。范围是：0~100 startValue: '', // 范围的起始数值，若设置了inside.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2a9b22ef0c2e3570a6bd6bee5f491d71/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ae42a69885a2e9cc0b29b03796e93d4/" rel="bookmark">
			siwave软件的那些坑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		**
1. PCB中的cutout区域没有导出来 **
原因：采用SIwave软件可以将AD软件绘制的PCB（需要ad另存为odb格式），转化成hfss文件，进行仿真。导出PCB到HFSS 3D软件里时，由于SIwave软件的3D export options菜单里默认是忽略cutouts的 较小面积的区域。因此导出文件时需要设置一下export options菜单。
**
2. PCB中的待仿真的线，siwave导出时，HFSS软件里没有 **
原因：采用SIwave软件导出PCB到HFSS 3D软件时，导出前需要勾选待导出的线的标号。
3. HFSS仿真结果异常，通过观察电场分布，发现端口waveport处电场异常 原因：仿真时，端口施加电场时，端口的界面必须保证水平，不能有缺口。
4. siwave导出的3d HFSS文件 过孔与GND铜皮融为一体。
原因：siwave导出时，设置不对。将generate unified nets勾掉即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/067b7d3a6e5ed4f430c571a0eb9e5bd4/" rel="bookmark">
			TCP重传机制、滑动窗口、流量控制、拥塞控制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、重传机制 超时重传快速重传SACK（选择性确认）Duplicate SACK
二、滑动窗口 三、流量控制 发送方不能无脑的发送数据，应该考虑接收方的处理能力。
TCP 提供一种机制可以让「发送方」根据「接收方」的实际接收能力控制发送的数据量，这就是所谓的流量控制。
操作系统缓冲区和滑动窗口的区别
先收缩窗口，在减少缓冲区，防止数据丢失。
窗口关闭
当接收窗口大小为0时，会停止接收数据，当接收窗口重新有空间时，会给发送方发一个窗口非0 的ACK报文，但是此报文可能会丢失。为了防止此现象发送方会定时进行窗口探测。
糊涂窗口综合征
当接收窗口很小的时候，为了避免为发生大车拉小物的情况，所以设定一个窗口最小阈值。当「窗口大小」小于 min( MSS，缓存空间/2 ) ，也就是小于 MSS 与 1/2 缓存大小中的最小值时，就会向发送方通告窗口为 0，也就阻止了发送方再发数据过来。
另外也可以设定发送方当有小数量数据时先停止发送，等后面攒多了在一块发送（伺机使用）。
可以在 Socket 设置 TCP_NODELAY 选项来关闭这个算法（关闭 Nagle 算法没有全局参数，需要根据每个应用自己的特点来关闭）
setsockopt(sock_fd, IPPROTO_TCP, TCP_NODELAY, (char *)&amp;value, sizeof(int)); 四、拥塞控制 慢启动拥塞避免拥塞发生（超时重传、快速重传）快速恢复
- 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec9f46ad46ba710748377d40c8c92286/" rel="bookmark">
			win11下电脑开热点，手机连接时显示无IP分配
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.进入设置&gt;网络和Internet&gt;移动热点，打开电脑热点，热点打开时wlan会自动打开
2.进入设置&gt;网络和Internet&gt;高级网络设置&gt;更多网络适配器选项
3.右键以太网&gt;属性&gt;共享，勾选第一个框，第二个框可以不选。wlan开关打开时，网络适配器界面会出现一个新的网络适配器，我的电脑上显示为本地连接2，所以家庭网络连接选它。
4.我第一次配置共享的时候，显示网络冲突。把虚拟机的网络适配器禁用后，就可以正常配置了。配置完后再启用虚拟机的网络适配器即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d95fa738f8099d81b6f64a35ad63677a/" rel="bookmark">
			【AcWing 算法基础课】 1、基础算法 笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 第一章 基础算法一、排序快速排序归并排序 二、二分二分总结整数二分浮点数二分 三、高精度高精度加法高精度减法高精度乘法高精度除法 第三章 前缀和与差分一、一维前缀和二、二维前缀和（矩阵前缀和）三、一维差分四、二维差分 五、双指针算法六、位运算七、离散化区间合并 第一章 基础算法 背算法模板，并且理解代码的思想和流程，背的不是代码，不是单词，而是思路。
针对不同模板做相应的模板题，课下做模板题，针对做过的题，课下把代码删除后再做3~5次。
数据结构与算法可视化网站：https://visualgo.net/zh
数据输入输出大于1e6，建议用scanf，否则cin。
很多难题其实是一些基础算法堆砌而成的，人类做题的过程其实是一个 dfs 的过程，分解的过程中发现有些步骤是一些经典问题：
现在就是把这些叶节点的算法学会，最后如何有机的结合到一起就是难题了。
一、排序 快速排序 基于分治思想
确定分界点：q[l]、q[r]、q[l+r/2]、随机值调整区间：却保左边都小于等于 分界点值 x，右边大于等于分界点值 x，分界点值不一定是中间值，可能是一个奇怪的值**——重点**递归处理 左 右 两段 （暴力方法：定义两个数组，分别存储左右区间，最后合并）
优美方法：定义两个指针，i、j，分别位于数组两端，向中间移动，直到i、j顺序都不对时，交换i、j的值
void quick_sort(vector&lt;int&gt;&amp;q, int l, int r) { if (l &gt;= r) return; //注意这里是&gt;= int i = l - 1, j = r + 1, x = q[l + r &gt;&gt; 1]; while (i &lt; j) { while (q[++i] &lt; x); //注意这里无论结果如何i都会+1，故初始化时i=l-1，且才能跳出循环 while (q[--j] &gt; x); if (i &lt; j) swap(q[i], q[j]); } quick_sort(q, l, j); quick_sort(q, j + 1, r); } 快排为不稳定排序，但也可以变为稳定排序，只要将每一个数变为不同就可以，如：将 a[i]，变为 &lt; a[i]，i &gt;，变为一个二元组，进行双关键字排序即可。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d95fa738f8099d81b6f64a35ad63677a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e2e84f778826633142a63a6f0143162/" rel="bookmark">
			windows10系统下nextcloud服务的webdav网盘挂载方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
一、下载挂载服务修复批处理文件，保存到本地并运行
二、复制网盘地址，并挂载网盘
三、webdav网盘挂载成功
前言 许多朋友都有使用过网盘，像比较大的百度网盘、天翼云盘等，但是也有不少小微企业希望搭建企业内部的私有网盘，这就需要用到一些网盘系统，像nextcloud就是其中一种。有用过的网友就知道，webdav协议的网盘可以直接挂载到windows系统，当成文件目录使用，但较新的windows系统对链接有一定的限制，下面讲述了windows10系统挂载webdav网盘的详细操作步骤。
一、下载挂载服务修复批处理文件，保存到本地并运行 1、文件在网盘的“公共文件”目录下，名称为“webclient.cmd”.
2、下载完成后，鼠标右键点击文件并选择“以管理员身份运行”，如果没有错误提示，即可按第二步继续操作.
二、复制网盘地址，并挂载网盘 1、打开并登录网页版网盘，在网盘“文件”选项卡的左下角的有webdav地址，复制此地址（注意这个地址每个账号都不同）以便后续使用
2、打开文件资源管理器，点击“计算机”选项卡，在选项卡中选择“映射网络驱动器”
3、弹出“映射网络驱动器”窗口
4、在“文件夹”中粘贴刚复制的webdav地址，并且勾选“登录时重新连接”（勾选后电脑重启仍然保留映射）
5、点击完成，弹出“连接到***”对话框
6、输入登录网页版网盘时的账号和密码，并勾选“记住我的凭据”（如果不勾选，重启电脑后需要重新输入用户名和密码）
7、点击确定，弹出网盘内容，到此网盘挂载完成
8、如果执行第5步时没有弹出要求输入用户名和密码的对话框，而是弹出下面的错误提示，则说明是执行第一步时出现了问题，可以尝试重新执行第一步操作
三、webdav网盘挂载成功 以上就是webdav网盘在Windows系统上的整个挂载步骤，并且系统重启后仍然可保留挂载盘符
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a1fe71d6ba251303e7debea6e13b6d05/" rel="bookmark">
			ubuntu20.04设置rc.local开机自启动服务（配置自定义脚本）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 参考ubuntu20.04设置rc.local_青冥浩荡不见底的博客-CSDN博客_rc.local ubuntu 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/658fb32e4bdd6dc531742f8663934605/" rel="bookmark">
			C&#43;&#43; 为什么编写模板类时要把方法的实现写在头文件中，而不能像写普通类一样写在源文件中？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、回答标题的问题 这里说下我自己的理解，如有不正确请各位大佬斧正。想要解决这个问题需要先了解C++代码的编译过程。
C++将代码编译生成可执行文件的过程可以分为三步：预编译 → 编译 → 链接。预编译时，会展开头文件，将包含的头文件的代码整个复制到当前文件中来。编译过程是生成二进制机器指令的过程。C++采用分离式编译，即，在编译时，对预编译源文件生成的文件(obj文件)进行单独编译，和其他文件没有任何关系。这时就有一个问题，当编译一个文件时，遇到了函数func，当前文件中只有预编译时拉进来的func的声明，而没有定义，无法生成func的二进制机器指令。这个问题，链接阶段会专门解决。在编译阶段，这些函数会暂时被标记为 “未解析的外部符号”。当进入链接阶段时， 链接器会专门为所有的未解析符号在其他文件中寻找对应的二进制机器指令，整个工程都链接好，就能正常执行了。
以上说的都是普通C++代码的编译过程。但是模板并不普通。模板只有在真正被使用到的时候才实例化，才生成二进制机器指令。当模板类的定义和实现分别写在了头文件和源文件中，而且main.cpp中还包含了模板类的头文件。那么编译main.cpp的obj文件时，势必会遇到模板类成员方法的声明，但是这里没有定义，先标记为未解析的外部符号。到了链接时，根据未解析的外部符号去到模板类源文件的obj文件中寻找其实现，找不到，因为他还没有被实例化，链接失败。此时，如果模板类成员方法的实现也在头文件中，那么就可以解决问题。
2、如何实现定义和实现分开写也能编译 非要把定义和实现分开写在头文件和源文件的话也不是不行。需要在源文件中添加模板类的实例化。
这个方法还是有局限性，因为你不知道类的使用方会套用什么类型，你需要对每个类型在cpp文件中挨个实例化一次，这就很麻烦，尤其是使用方套用的类型是自己定义了一个类的话，还是会出现链接错误。
写这篇文章参考了很多其他文章，下面一一列出。
C++程序是如何编译的？
C++ 编译，运行过程 详解。
C++类模板是如何编译的？
C++中模板类的编译过程
C++模板编译
C++模板为什么定义和实现必须都写在头文件？
模板为什么必须定义在头文件
关于C++为什么模板类中的模板函数只能写在头文件
C++模板类如何实现头文件和源文件分离？
C++模板类/函数，将头文件与源文件分离
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9402e48a025fa3c9a126080076c40e80/" rel="bookmark">
			中缀表达式转后缀表达式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		中缀表达式转后缀表达式 1 后缀式简介2 由中缀表达式求后缀表达式示例（3种方法）2.1 方法一：栈的应用-四则运算表达式求值2.1.1 栈的应用-四则运算表达式求值规则2.1.2 栈的应用-四则运算表达式求值示例 2.2 方法二：二叉树应用2.2.1 二叉树应用规则2.2.2 二叉树应用示例 2.3 方法三：加括号法2.3.1 加括号法规则2.3.2 加括号法示例 1 后缀式简介 一种不需要括号的后缀表达法，也把它称为 逆波兰表示，是波兰逻辑学家卢卡西维奇（Lukasiewicz)发明的一种表示表达式的方法。
2 由中缀表达式求后缀表达式示例（3种方法） 中缀表达式指的是“9+(3-1)×3+8÷2”，这种就是我们通常见到的书写算式顺序，要计算中缀表达式则首先要将字符串转换为后缀表达式，即9 3 1 - 3 * + 8 2 / +，以下均是对于“9+(3-1)×3+8÷2”算式求解后缀表达式的方法。
2.1 方法一：栈的应用-四则运算表达式求值 2.1.1 栈的应用-四则运算表达式求值规则 1.设定运算符栈；
2.从左到右遍历中缀表达式的每个数字和运算符；
3.若当前字符是数字，则直接输出成为后缀表达式的一部分；
4.若当前字符为运算符，则判断其与栈顶运算符的优先级，若优先级大于栈顶运算符，则进栈；若优先级小于等于栈顶运算符，退出栈顶运算符成为后缀表达式的一部分，然后将当前运算符放入栈中；
5.若当前字符为“(”，进栈；
6.若当前字符为“)”，则从栈顶起，依次将栈中运算符出栈成为后缀表达式的一部分，直到碰到“(”。将栈中“(”出栈，不需要成为后缀表达式的一部分，然后继续扫描表达式直到最终输出后缀表达式为止。
2.1.2 栈的应用-四则运算表达式求值示例 1、初始化一个空栈。此栈用来对运算符进出栈使用。如图2-1-2-1的左图所示。
2、第一个字符是数字9，直接输出9（根据规则3），第二个字符是运算符“+”，则“+”进栈（根据规则4），如图2-1-2-1的右图所示。
图2-1-2-1 3、第三个字符是符号“(”，则“(”进栈（根据规则5），如图2-1-2-2左图所示。 4、第四个字符是数字3，直接输出3（根据规则3），总输出表达式为
9 3 第五个字符是运算符“-”，则“-”进栈（根据规则4），第六个字符是数字1，直接输出1（根据规则3），总输出表达式为
9 3 1 如图2-1-2-2右图所示。
图2-1-2-2 5、第七个字符是符号“)”，此时依次将栈中运算符出栈成为后缀表达式的一部分，直到碰到"("，此时“(”上方只有“-”运算符，因此输出“-”运算符（根据规则6），总输出表达式为 9 3 1 - 如图2-1-2-3左图所示。
6、第八个字符是运算符“ * ”，因为此时的栈顶符号是运算符“+”，优先级低于“ * ”，因此不输出，“ * ”进栈（根据规则4），如图2-1-2-3右图所示。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9402e48a025fa3c9a126080076c40e80/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41a01a4d689eba688237a3e598b95ece/" rel="bookmark">
			wangeditor editor.i18next.init is not a function错误处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
问题描述：
问题查找：
解决方案：
问题描述： 1.使用的是wangeditor v4版本
2.在使用wangeditor富文本编辑器时，开发报editor.i18next.init is not a function类型错误
2.通常第一次初始化编辑器正常，第二次初始化就会报之上错误
问题查找： 1.在百度中搜索没有得到相关问题解决方案，没有解决问题
2.看wangeditor源码发现需手动配置 i18next
解决方案： 1.不使用 i18next 直接在初始化编辑器配置的地方将editor.i18next配置为null
2.使用 i18next 手动下载并引入i18next替换掉默认配置
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2243f7f95d513068aa655b35df769c8/" rel="bookmark">
			netcore swagger 隐藏接口文档字段
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、添加操作筛选器
①、安装Swagger相关包
1、程序集包管理器控制台安装。
Install-Package Swashbuckle.AspNetCore.Swagger Install-Package Swashbuckle.AspNetCore.SwaggerGen Install-Package Swashbuckle.AspNetCore.SwaggerUI 2、Nuget程序包安装
②、添加操作筛选器
public class SwaggerOperationFilter : IOperationFilter { /// &lt;summary&gt; /// 应用筛选 /// &lt;/summary&gt; /// &lt;param name="operation"&gt;&lt;/param&gt; /// &lt;param name="context"&gt;&lt;/param&gt; public void Apply(OpenApiOperation operation, OperationFilterContext context) { //获取参数类型 var type = context.ApiDescription.ActionDescriptor.Parameters.FirstOrDefault()?.ParameterType; var proty = type?.GetProperties() ?? new PropertyInfo[] { }; foreach (var item in proty) { //查找忽略Attribute var attr = item.GetCustomAttribute&lt;JsonIgnoreAttribute&gt;(); if (attr == null) continue; //查找忽略参数 var param = operation.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a2243f7f95d513068aa655b35df769c8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7915214976e92ffafd74677b1a8779b7/" rel="bookmark">
			DCDC: 环路稳定性的测量方法-穿越频率和相位裕度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		穿越频率和相位裕度的测量方法-You can determine the crossover frequency (converter bandwidth) with transient analysis or by using a network analyzer. Both methods are shown.
有两种测量方法一种是采用示波器观察电压瞬态响应实现的；另一种是采用网络分析仪/频率分析仪测量bode图。显然，采用示波器测量是一种经济简便的方法，而采用网络分析仪测量更精准。
首先，介绍示波器测量方法。其实就是施加阶跃负载在输出端，观察输出电压瞬态响应。Figure 7 provides insight to the converter crossover frequency as described in Evaluation and Performance Optimization of Fully Integrated DC/DC Converters (Topic 7 of the 2006 Portable Power Design Seminar). 图7中，电压衰减频率是和控制环穿越频率相关的。用示波器光标第一个波谷和第二个波谷之间的时间，计算对应的振荡频率，得到的振荡频率约等于穿越频率。
从图中可看出，如果穿越频率（即振荡频率）增大，在加载后，变换器将更早调节输出电压，因此电压跌落和电压振荡都会减小。通过对比Figure7/8，可确定相位裕度大约为30°。
通过阶跃响应得到相位裕度
采用频率分析仪的方法则比较直接，直接可以得到精准的穿越频率和相位裕度。Figure9显示穿越频率为16KHz, 相位裕度为28°。
DCDC: 前馈电容Cff Feed forward capacitor增强环路稳定性 参考文章：Optimizing Transient Response of Internally Compensated dc-dc Converters With Feedforward Capacitor，http://www.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7915214976e92ffafd74677b1a8779b7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f65f366c7f6e50e71cec8d9a569eef0b/" rel="bookmark">
			【JAVA】对树形结构进行模糊查询（含分页）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需求场景： 对树形结构进行模糊查询（含分页）
示例:通过名称、日期等条件查询筛选出带有顶级节点的过滤分页树，如果查询的节点不是顶级节点时，需要将其所有的上级路径数据全部带出来。
难点： 树分页，非顶级节点，n棵m叉树
解决方案： 方案一： 1、根据条件查出数据A集合
2、根据A集合“分页”查出所有的顶级（父）节点B集合 // 去重、利用sql函数可获取顶级节点
3、根据B集合查出所有的下级节点C集合（合并B集合）//
4、根据A集合筛选过滤C集合得到最终的D集合 // 筛选过滤操作，此步骤参考树过滤
5、将D集合组树得到E集合（树形结构）// 树工具类
方案二： 1、根据条件查出数据A集合
2、根据A集合“分页”查出所有的顶级（父）节点B集合 // 去重、利用sql函数可获取顶级节点
3、根据A集合查出所有的上级节点C集合（包含A集合本身） // 去重
4、将B集合和C集合去重合并成D集合 // 过滤掉不在B集合中的顶级节点
5、将D集合组树得到E集合（树形结构） // 树工具类，由于第4步骤过滤了部分顶级节点，所以组成新树的时候，会把找不到顶级节点的数据筛选过滤掉
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/abe19049e4b09ee03047aac298ba272e/" rel="bookmark">
			第三章. Pandas入门—索引设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第三章. Pandas入门
3.8 索引设置 1. 索引的作用： 1).更方便的查询数据 2).使用索引可以提升查询性能 · 如果索引是唯一的，Pandas会使用哈希表优化，查找数据的时间复杂度为O(1) · 如果索引不是唯一的，但是有序，Pandas会使用二分查找算法，查找数据的时间复杂度为O(logN) · 如果索引是完全随机的，那么每次查找数据都需要扫描数据表，时间复杂度是O(N) 3).强大的数据结构 2. 重新设置索引： 1).函数格式： DataFrame.reindex（(labels=None, index=None, columns=None, axis=None, method=None, copy=True, level=None, fill_value=nan, limit=None, tolerance=None)） 参数说明:
labels:可以是数组
index:行索引
columns:列索引
axis:0:表示行 1：表示列
method:重新设置索引时，选择的差值方式：None，bfill(向后填充),ffill(向前填充)
fill_value：缺失值填充的数据
2)对Series对象重新设置索引： import pandas as pd # 对Series对象重新设置索引 s1 = pd.Series([100, 110, 120], index=[1, 2, 3]) print(s1) print('*' * 50) s2 = s1.reindex(index=[1, 2, 3, 's1', 's2'], fill_value=0) print(s2) print('*' * 50) s3 = s1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/abe19049e4b09ee03047aac298ba272e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/558fb200860db38f8c15383847335f04/" rel="bookmark">
			【RHCE】作业：ansible playbook中结合yaml运用各种模块
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.创建一个play, 用来创建用户和用户组 第一个任务：创建用户usertest并指定uid为2000，shell类型为/bin/sh 第二个任务：创建用户组grouptest 并指定gid为1999
2.创建一个play，用来创建文件并往文件中写入内容, 并压缩 第一个任务：创建一个data.txt文件， 第二个任务：写入：This file is for archive 第三个任务： 压缩文件 data.txt为data.tar.gz
3.创建一个play, 用来安装软件iptables, 并启动服务，然后停止服务 第一个任务，安装iptables 第二个任务: 启动服务 第三个任务：停止服务
4.创建一个play，完成新建连接并启用 首先，关闭node1， 添加一块网卡 创建任务，在新添加的网卡上新建连接
5.创建一个play，完成LVM的配置 首先，关闭node1， 在node1上添加一块硬盘，2GB
第一个任务：为磁盘设置第一个分区：500MB， flags=lvm
第二个任务：为磁盘设置第二个分区：500MB， flags=lvm
第三个任务：为磁盘设置第三个分区：500MB， flags=lvm
第四个任务：使用上边建立的三个分区，建立PV和VG(使用lvg模块)
第五个任务：使用上面建立的vg建立逻辑卷(lv), lv大小为1.2GB
第六个任务：为上面建立的lv建立文件系统，类型为xfs
第七个任务：将上面建立的逻辑卷挂载到/mount_data目录下
第八个任务：在/mount_data下创建文件data.txt
注：playbook里对缩进格式要求严格，可以去vim /etc/vimrc加一句写的更方便
autocmd FileType yaml setlocal ai ts=2 sw=2 et
【在ansible下创建yaml文件，据我观察应该是可以一个yaml文件里根据play的名字的来执行，但是我又不确定，算了还是老实每个yaml写一个play】
【老师说可以根据play名字执行，自学事倍功半，俺就不去查了】
1.创建一个play, 用来创建用户和用户组 第一个任务：创建用户usertest并指定uid为2000，shell类型为/bin/sh 第二个任务：创建用户组grouptest 并指定gid为1999 vim /root/ansible/test1.yaml
--- - name: hosts: node1 tasks: - name: userad user: name: usertest uid: 2000 shell: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/558fb200860db38f8c15383847335f04/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/675190ccb9ca2a8d9da9a463261fd10e/" rel="bookmark">
			GreenHills基本操作：调试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、编译
1.1、整体编译
1.2、编译是否优化选项
或
2、调试
2.1、进入调式
2.2、调试下载
2.3、跳转至具体行
2.4、函数调用过程查看
2.5、通过文件树查找指定文件
2.6、快速查看所需函数，设置断点
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f68d4110ea3a0402c6ab23cdf747a1d7/" rel="bookmark">
			训练记录番外篇（3）：2019-2020 ICPC Southeastern European Regional Programming Contest (SEERC 2019)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2019-2020 ICPC Southeastern European Regional Programming Contest (SEERC 2019)
6题961罚时，按照国外444的牌数看来是打铁了。
最后1h其实已经把AE两题思路都出来了，但是队友最终都没有vp的时候写完，可惜了。
A. Max or Min 代码不在我手上，如果队友之后发我再补。
思路是把所有数考虑成-1，0，1，可以把答案转换成一个求环上所有交替的-1，1序列长度/2向上取整的方案数。考虑线段树维护单点修改和区间合并，分类讨论一下环上的情况即可。
B. Level Up 队友单切，一个看不懂的dp。
#include &lt;bits/stdc++.h&gt; #pragma gcc optimize("O2") #pragma g++ optimize("O2") #define int long long #define endl '\n' using namespace std; const int N = 2e3 + 10, MOD = 1e9 + 7; int dp[N][N]; struct node { int x,t,y,r; bool operator &lt; (const node &amp;b) const { return x&lt;b.x; } }e[N]; inline void solve(){ int n, s1, s2; cin &gt;&gt; n &gt;&gt; s1 &gt;&gt; s2; for(int i=1;i&lt;=n;i++) { cin&gt;&gt;e[i].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f68d4110ea3a0402c6ab23cdf747a1d7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/976b45b7f151f00759c4dd6266651b0c/" rel="bookmark">
			【VMware环境下Linux磁盘空间（LVM）扩容方法】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VMware环境下Linux磁盘空间（LVM）扩容方法 引言环境目标步骤检查磁盘VMware扩展磁盘空间创建分区配置LVM 引言 最近在安装Oracle ASM的过程中，解压文件被迫终止，提示可用空间不足。下面简单描述磁盘扩容的步骤。
环境 环境：VMware Workstation 16 PRO下的虚拟机系统：Oracle Linux Server 7.9 （Redhat 7系列可参考）内核：Linux 5.4.17-2102.201.3.el7uek.x86_64文件系统类型：LVM [root@oracle19c-asm ~]# lsblk NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINT sdb 8:16 0 40G 0 disk sdc 8:32 0 40G 0 disk sda 8:0 0 20G 0 disk ├─sda2 8:2 0 19G 0 part │ ├─ol-swap 252:1 0 2G 0 lvm [SWAP] │ └─ol-root 252:0 0 17G 0 lvm / # 根目录挂载点为LVM └─sda1 8:1 0 1G 0 part /boot 目标 安装系统时分配磁盘空间共20G，采用默认分区配置，根目录分到19G空间。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/976b45b7f151f00759c4dd6266651b0c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4990d35e538d37ea995cfc45e0b75810/" rel="bookmark">
			【Control】Python控制第三方程序之SecureCRT
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本意：使用 Python 模拟打开 crt 并执行相关脚本的操作
进度：已实现
模拟步骤：
调用运行 win+r输入 securecrt.exe 执行程序输入快捷键 alt+s, alt+r输入脚本的绝对路径并回车 使用注意事项
纯英文输入法crt 脚本中的输入可能失败手动将 crt 的绝对路径设置为电脑环境变量 参考资料
【Python、VB.Net、Aardio】三种方法操控第三方程序实现程序自动化控制 实现代码
import pyautogui as pg import os import time import subprocess from threading import Thread pg.keyDown('super') pg.press('r') pg.keyUp('super') time.sleep(1) # 使用运行调用 crt pg.write('securecrt.exe') pg.press('enter') time.sleep(10) # 输入执行脚本的快捷键 pg.keyDown('alt') pg.press('s') time.sleep(1) pg.press('r') pg.keyUp('alt') time.sleep(1) crt_script_path = 'D:\Projects\AutoCRT' # 调用脚本打开连接 script1 = os.path.join(crt_script_path, 'openTab.py') pg.write(script1) pg.press('enter') time.sleep(5) pg.keyDown('alt') pg.press('s') time.sleep(1) pg.press('r') pg.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4990d35e538d37ea995cfc45e0b75810/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9047f437496046dcbd3715d10247f993/" rel="bookmark">
			7-1 输出全排列（递归算法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		请编写程序输出前n个正整数的全排列（n&lt;10），并通过9个测试用例（即n从1到9）观察n逐步增大时程序的运行时间。
输入格式: 输入给出正整数n（&lt;10）。
输出格式: 输出1到n的全排列。每种排列占一行，数字间无空格。排列的输出顺序为字典序，即序列a1​,a2​,⋯,an​排在序列b1​,b2​,⋯,bn​之前，如果存在k使得a1​=b1​,⋯,ak​=bk​ 并且 ak+1​&lt;bk+1​。
输入样例： 3 输出样例： 123 132 213 231 312 321 看代码： #include &lt;stdio.h&gt; int x1[10],x2[10],n;//x1表示某一位置上的值，例如x1[1] 就是第一个位置上的数字 void fanhui(int k)//x2用来判断某一数字是否被调用过 ，下标表示数字。例如x2[1]=1，表示1这个数字已经被调用 { int i; if (k&gt;n){//k表示函数开始的值 for (i=1;i&lt;n;++i) printf("%d",x1[i]); printf ("%d\n",x1[n]); return ;//结束了就返回上一级函数 } else { for (i=1;i&lt;=n;++i){ if (x2[i]==0){//数字尚未被调用 x1[k]=i; x2[i]=1; fanhui(k+1); x1[k]=0;//数据初始化，也就是引用完之后将位置空出来 x2[i]=0; } } return ;//结束了就返回上一级函数 } } int main () { scanf ("%d",&amp;n); fanhui(1); return 0;	} 这里可能有很多人看的很懵圈，大家可以带一个数字进去尝试，主要就是递归的原理：就是自己调用自己，每一次调用后递归函数都要运行到return才会结束。如果真的不理解可以将每一次调用的过程写出来。
希望对你们有帮助！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d58baa09c611f0c2fe673d9ec6598e9/" rel="bookmark">
			matlab中repmat()函数解释
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		repmat意思是复制和平铺矩阵，何为平铺？举个简单例子
如上述结果可知，其将矩阵（0 1）复制以及向右向下平铺成一个以矩阵（0 1）为单位的33阶的矩阵。
故总结一般repmat函数有如下两种形式：
A=[1,2,3,4] repmat（A，3） B=[2,4,6,8] repmat(B,3,2)，这里理解为将矩阵B复制平铺为以B为单位的32阶矩阵，结果如下所示：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4538ceb9abafb84bc996bd2373ff8736/" rel="bookmark">
			快速输出日历
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		日历插件并不少见，但多数都是大而全，直接使用插件的话往往会使项目变得臃肿，而且想做一些定制化的修改，成本反而会更高。
最近为了练手Taro框架，做了一个日历微信端小程序，大海日历，刚好用到日历输出。项目开始时也想偷个懒直接找网上插件来使用，但找来找去，大多数插件都做的大而全，觉得比较臃肿，而且定制成本都偏高，当然也不排除是我自己没找到的原因哈。于是，综合分析一下，还是自己动手吧。
需求分析 首先描述一下需求：
输出本月日期，按照星期分成行；空余位置用其他月份日期补全；某些月份日期占6行，某些月份日期占5行，为了切换月份时保证视觉效果，我们要固定所有月份都按6行铺排；西方习惯周日为每周第一天，中国更习惯周一为每周第一天，所以要支持此设置。 我们从以上需求可分析出：
首先需要计算本月第一天的星期；当前可视日期数量为6 * 7 = 42；支持传入"每周第一天是否是周一"参数；输出为7 * 6结构二位数组。 网上很多实现，是通过月份天数、本月第一天的星期，来计算本月实际占几行，进而来判断是否需要补充一行其他月份日期。我们这里取个巧，不进行此判断，不管需不需要，我们都地毯式的循环输出42天，减少很多计算量。
另外还有一个可取巧的点，Date类支持设置日期为任意整数，并且程序会自动纠正成对应日期，比如：
new Date(2022, 10, 1) // 得出日期2022-11-1 new Date(2022, 10, 0) // 得出日期2022-10-31 new Date(2022, 10, -1) // 得出日期2022-10-30 new Date(2022, 10, 31) // 得出日期2022-12-1 注意：
设置月份时，和通过getMonth()获取月份时、通过getDay()获取星期时，使用的都是编程习惯的索引值，而非自然值，也就是计数从0开始；
月份范围是[0-11]；星期范围是[0-6]，0代表周日，也就是默认星期是以周日开始的；
而通过getDate()获取日期时，则使用的是自然日。
思路 日历第一天传入的date值 通过上图，得出，当本月第一天在周一到周日变化时，日历第一行第一天的日期取值范围为[1, 0, -1, -2, -3, -4, -5]，我们利用本月月第一天的星期索引，即可算出具体日期：
取得本月第一天的星期索引，取值范围为[0, 1, 2, 3, 4, 5, 6]；当设置每周第一天为周日时，可通过1 - new Date().getDay()计算得出第一行第一天的具体日期；当设置每周第一天为周一时，本月第一天为周一到周六日期可通过2 - new Date().getDay()计算得出，为周日时则设定为-5；循环输出所有日期，我们可以设置两层循环，第一层循环用来设定当前日历的1-6周，第二层则用来设定每周的具体日期。 方法源码 具体方法实现如下：
/** * 扩展Date原型，增加日期格式化方法 * 月(M)、日(d)、小时(h)、分(m)、秒(s)、季度(q) 可以用 1-2 个占位符， * @param fmt 时间格式 * @param second 秒 */ Date.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4538ceb9abafb84bc996bd2373ff8736/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8094a91231ff786cc13f1ff1d9434a07/" rel="bookmark">
			计算机网络/学习笔记六/《计算机网络（自顶向下方法 第七版）》
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		课程资源 课程网站：http://staff.ustc.edu.cn/~qzheng/teaching.html课程视频：https://www.bilibili.com/video/BV1JV411t7ow/课程教材：计算机网络（自顶向下方法 第7版），机械工业出版社，2016 第六章 链路层与局域网 1、引论和服务 网络层解决了一个网络如何到达另外一个网络的路由问题
在一个网络内部如何由一个节点（主机或者路由器）到达另外一个相邻节点
链路层的点到点传输层功能 网络节点的连接方式
Q：一个子网中的若干节点是如何连接到一起的 点到点连接多点连接： 共享型介质通过网络交换机 广域网WAN:网络形式采用点到点链路 带宽大、距离远（延迟大） 带宽延迟积大 如果采用多点连接方式 竞争方式：一旦冲突代价大令牌等协调方式：在其中协调节点的发送代价大 点到点链路的链路层服务实现非常简单，封装和解封装 局域网 LAN一般采用多点连接方式 连接节点非常方便接到共享型介质上（或网络交换机），就可以连接所有其他节点多点连接方式网络的链路层功能实现相当复杂 多点接入：协调各节点对共享性介质的访问和使用竞争方式：冲突之后的协调；令牌方式：令牌产生，占有和释放等 链路层服务
成帧，链路接入\ 将数据报封装在帧中，加上帧头、帧尾部如果采用的是共享性介质，信道接入获得信道访问权在帧头部使用“MAC”（物理）地址来标示源和目的 不同于IP地址 在（一个网络内）相邻两个节点完成可靠数据传递 已经学过了（第三章）在低出错率的链路上（光纤和双绞线电缆）很少使用在无线链路经常使用：出错率高 Q: 为什么在链路层和传输层都实现了可靠性一般化的链路层服务，不是所有的链路层都提供这些服务一个特定的链路层只是提供其中一部分的服务 在相邻节点间（一个子网内）进行可靠的转发 已经学过了（第三章）在低差错链路上很少使用 (光纤,一些双绞线)在高差错链路上需要进行可靠的数据传送 流量控制： 使得相邻的发送和接收方节点的速度匹配 错误检测： 差错由信号衰减和噪声引起接收方检测出的错误: 通知发送端进行重传或丢弃帧 差错纠正: 接收端检查和纠正bit错误，不通过重传来纠正错误 半双工和全双工: 半双工：链路可以双向传输，但一次只有一个方向 链路层在哪里实现
在每一个主机上 也在每个路由器上交换机的每个端口上 链路层功能在“适配器”上实现 (aka network interface card NIC) 或者在一个芯片组上 以太网卡，802.11 网卡; 以太网芯片组实现链路层和相应的物理层功能 接到主机的系统总线上硬件、软件和固件的综合体
2、差错检测和纠正 错误检测 EDC=差错检测和纠正位（冗余位）D =数据由差错检测保护，可以包含头部字段错误检测不是100%可靠的 协议会漏检一些错误，但是很少更长的EDC字段可以得到更好的检测和纠正效果 奇偶校验 检测与纠正单个bit错误 校验和 目标: 检测在传输报文段时的错误（如位翻转），（注：仅仅用在传输层） 检验和：CRC（循环冗余校检） 强大的差错检测码实际中广泛使用（以太网、802.11 WiFi、ATM） 3、多点访问协议（介质访问控制协议：MAC） 两种类型的链路（一个子网内部链路连接形式）： 点对点广播 (共享线路或媒体) 多路访问协议 单个共享的广播型链路2个或更多站点同时传送: 冲突（collision） 多个节点在同一个时刻发送，则会收到2个或多个信号叠加 分布式算法-决定节点如何使用共享信道，即：决定节点什么时候可以发送关于共享控制的通信必须用借助信道本身传输3大类: 信道划分 把信道划分成小片（时间、频率、编码）分配片给每个节点专用TDMA、FDMA、CDMA 随机访问 信道不划分，允许冲突冲突后恢复 依次轮流 节点依次轮流但是有很多数据传输的节点可以获得较长的信道使用权 随机存取协议 随机存取协议
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8094a91231ff786cc13f1ff1d9434a07/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef9d39c430d0852e06e32d22c7f5f31d/" rel="bookmark">
			SSM框架-MyBatis(三)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1 MyBatis参数处理
1.1 单个简单类型参数
1.2 Map参数
1.3 实体类传值
1.4 多参数
1.5 @Param(命名注解)
2 MyBatis查询语句
2.1 返回Car
2.2 返回List
2.3 返回Map
2.4 返回List
2.5 返回Map(String,Map)
2.6 resultMap结果映射
2.7 返回总记录条数
3 动态SQL
3.1 if标签
3.2 where标签
3.3 trim标签
3.4 set标签
3.5 choose when otherwise
3.6 foreach标签
4 MyBatis的高级映射及延迟加载
4.1 多对一
4.1.1 级联属性映射
4.1.2 association
4.1.3 分步查询
4.2 多对一延迟加载
4.3 一对多 4.3.1 collection
4.3.2 分步查询
5 MyBatis的缓存
5.1 一级缓存
5.2 二级缓存
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ef9d39c430d0852e06e32d22c7f5f31d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87c8d7709b59e6aee6522f6869bbcbd3/" rel="bookmark">
			在嵌入式python解释器中手动安装pip
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录
1、官网下载嵌入式Python解释器
2、下载get-pip.py脚本
3、编辑python解释器根目录下的".pth"文件，取消掉import site的注释
4、开始安装，去cmd控制台执行以下命令
5、通过python -m 来调用pip使用命令，如下：
1、官网下载嵌入式Python解释器 官网下载"embedded"的程序包
2、下载get-pip.py脚本 get-pip.py的下载网址为：get-pip.py文件较大，等浏览器加载完毕，鼠标右键选择另存为进行保存
3、编辑python解释器根目录下的".pth"文件，取消掉import site的注释 import site 4、开始安装，去cmd控制台执行以下命令 python.exe get-pip.py 5、通过python -m 来调用pip使用命令，如下： python.exe -m pip list 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d2c8b9f6c4a291b572d24b3d18e0e3b/" rel="bookmark">
			node,koa2实现nginx服务器代理功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 vue项目打包,api设置为替换api 一、vue项目打包,api设置为替换api 那么调用接口的时候默认是本地调用,这个时候部署到node上的项目会自己调用自己的资源,那么是调用不到的
二、使用koa2的koa2-proxy-middleware功能进行代理操作 一定不要使用koa-bodyparser,那么请求转发只能转发请求get,post无效也可能会503
const Koa = require('koa') const app = new Koa() const views = require('koa-views') const json = require('koa-json') const onerror = require('koa-onerror') const logger = require('koa-logger') const fs = require("fs"); const path = require("path"); const proxy = require('koa2-proxy-middleware'); // error handler onerror(app) // middlewares app.use(json()) app.use(logger()) app.use(require('koa-static')(__dirname + '/public')) app.use(views(__dirname + '/views', { extension: 'pug' })) const options = { targets: { '/api/(.*)': { target: 'http://xx.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5d2c8b9f6c4a291b572d24b3d18e0e3b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/79efe83c3240094c7fcff275c901d211/" rel="bookmark">
			开放MySQL的远程访问权限
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开放MySQL的远程访问权限 1.使用 mysql -u root -p 连接到本地MySQL服务
2.登录后使用 use mysql;
3.使用 grant all privileges on . to ‘root’@‘%’ identified by ‘123456’ with grant option; 赋予远程登录用户权限（使用root账号和密码123456，从任何主机连接到mysql服务器），刷新权限 FLUSH PRIVILEGES;
4.使用 select user,host from user 查看系统用户
5.使用 vim /etc/mysql/mysql.conf.d/mysqld.cnf 修改bind-address的访问网址，将 bind-address=127.0.0.1 改成 bind-address=0.0.0.0
6.开放端口 3306（这是MySQL的默认端口）
参考博客：
配置mysql允许远程连接的方法
开启MySQL远程访问权限 允许远程连接
如何远程连接 MySQL 数据库，阿里云腾讯云允许远程连接教程
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/682efdea8f7b3742fb950ce95da57151/" rel="bookmark">
			解决“您的连接不是私密链接”的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这多半是因为要访问的服务器只支持http，不支持https
点击页面，在键盘输入 thisisunsafe即可访问，注意此时键盘输入时，屏幕没有响应。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/293cdebbae0234a51a027c183d541049/" rel="bookmark">
			MacOS升级13后，GIT不好用问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vim ~/.ssh/config
添加
HostkeyAlgorithms +ssh-rsa
PubkeyAcceptedAlgorithms +ssh-rsa
如下图：
注意：如果没有配置~/.ssh/config则修改/etc/ssh/ssh_config
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cfd1bd4e78d2b9d5eb4a9d220887b114/" rel="bookmark">
			SEERC 2008 Problem A Stock Exchange
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		POJ 3903
题目大意 给定一个数组P，寻找最长的递增子序列，数组最大长度100000。
解决方案 很经典的问题了，由于数据比较庞大，需要Nlog(N)的算法 ​​​​​​​
Example 需要测试数据的同学可以留言
import java.io.BufferedReader; import java.io.InputStreamReader; public class Main { public static void main(String[] args) { new Main().run(); } BufferedReader reader = new BufferedReader(new InputStreamReader(System.in)); private int readInt() { int r; try { int t; while (true) { t = reader.read(); if (t == -1) return -1; if (Character.isDigit(t)) { r = t - '0'; while (true) { t = reader.read(); if (!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cfd1bd4e78d2b9d5eb4a9d220887b114/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8229121d296b5c6a31d45c3524c7ee1/" rel="bookmark">
			Redis-Server安装包&amp;依赖包On Ubuntu-Server
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、摘要 客户的机房脱网，因业务需求，需在服务器上安装redis。所以需要提前准备好依赖和安装包，用光盘拷入。
二、准备依赖包 2.1 找到依赖
sudo apt-cache depends redis-server 2.2 保存依赖包
创建一个文件夹来存放
mkdir offline-packages 然后在文件夹下运行命令
for i in $(apt-cache depends redis-server | grep -E 'Depends|Recommends|Suggests' | cut -d ':' -f 2,3 | sed -e s/'&lt;'/''/ -e s/'&gt;'/''/); do sudo apt-get download $i 2&gt;&gt;errors.txt; done 可能会存在“依赖的依赖”情况，需要重复上一步的操作，依赖项*替换“redis-server”
三、编译安装包 在第二步中，已经得到了一个名为“offline-packages”文件夹，内含所有的依赖包。
首先需要从官网下载指定版本的源码。
下载完之后，解压至指定的文件夹，假设名为“redis”。
在该文件夹下运行命令
sudo make 编译成功后，将会在“redis/src”路径下看到名为"redis-server"的文件就OK了。
四、常见问题 1.无法安装任何软件包，即依赖损坏
​​sudo apt-get install -f​ ​-f参数的主要作用是是修复依赖关系（depends），假如用户的系统上有某个package不满足依赖条件，这个命令就会自动修复，安装程序包所依赖的包。
​
​2.“下列软件包有未满足的依赖关系: gcc : 依赖: gcc- (&gt;= 7.3.0-12~) 但是它将不会被安装”。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d8229121d296b5c6a31d45c3524c7ee1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f873505710d873882929bd010acba92/" rel="bookmark">
			Python代码循环执行exe文件，并传入命令参数实现批量处理数据。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python调用exe程序 传入命令参数，并实现循环批处理文件 1、问题背景2、面临的问题3、代码实现（案例）4、总结 1、问题背景 参加MARS数据医疗赛道进行计算机视觉的比赛，比赛内容为赛题提供一批病理数字切片，由专业医师给出切片区域内T分期指标的标注。选手需要使用计算机视觉相关技术，按照TNM分期指标中“T”指标对切片内的区域进行分类预测，辅助医生进行识别，提高病理诊断效率。
使用TNM分期进行肿瘤评估时，T0代表无证据表明存在原发肿瘤、T1~T3代表癌细胞的侵入程度逐渐加深，Tis代表原位癌（上皮内肿瘤，未侵及固有层，高度不典型增生）。在初赛中，选手需要根据给定的kfb图片及json文件，对切片内划定的区域进行侵入程度的分类预测，共分为五类，包括T0、T1、T2、T3和Tis。
2、面临的问题 由于病理切片图像为医院专业器械得出，赛题方提供的是KFB格式的病理切片图像，在自己计算机上显示不出来，所以需要使用赛题方提供的exe文件（第三方提供）对kfb格式的图片进行转换，赛题方提供的可执行文件可以把kfb格式转换为tiff格式。由于我们需要用深度学习去对数据进行预测，这里的图片数据非常多、并且一个图片就400M+，显然一张一张照片转换是非常费时的，所以需要写一个python脚本去给我们批量转换我们的数据。 3、代码实现（案例） 比如需要在命令行输入一下命令
python代码
下面展示 用Python循环执行exe可执行文件达到批量处理文件的需求。
import os path = "D:\\BaiduNetdiskDownload\\MARS\\data\\T0\\" main = "D:\\BaiduNetdiskDownload\\MARS\\tool\\KFbioConverter.exe" suffixs = [] for file_name in os.listdir(path): if file_name.endswith(".kfb"): suffix = file_name.split(".")[0] # os.startfile(main + path + file_name + toPath + suffix + ".tif 3") path1 = "D:\\BaiduNetdiskDownload\\MARS\\data\\T0\\" + file_name toPath = "D:\\BaiduNetdiskDownload\\MARS\\data\\TIF0\\" + suffix + ".tif 3" # 运行参数格式化 para = "%s %s %s" % (main, path1, toPath) # 注意是temp.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1f873505710d873882929bd010acba92/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8586c4efde46fc579b01b0c7a186b73d/" rel="bookmark">
			HTML/樱花爱心网页/
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HTML/樱花爱心网页/ 代码如下： &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;script src="js/jquery.min.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;style&gt; * { padding: 0; margin: 0; } html, body { height: 100%; padding: 0; margin: 0; background: #000; } .aa { position: fixed; left: 50%; bottom: 10px; color: #ccc; } .container { width: 100%; height: 100%; } canvas { z-index: 99; position: absolute; width: 100%; height: 100%; } &lt;/style&gt; &lt;body&gt; &lt;!-- 樱花 --&gt; &lt;div id="jsi-cherry-container" class="container"&gt; &lt;audio autoplay="autopaly"&gt; &lt;source src="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8586c4efde46fc579b01b0c7a186b73d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1371a1016aba9936df73fbf3dc39eff/" rel="bookmark">
			Spring管理Bean的三种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Spring对Bean管理的三种方式 1.基于XML实例化配置Bean 基于构造方法实例化对象基于静态工厂实例化对象基于工厂实例方法实例化对象 2.基于注解实例化配置Bean 基于注解配置IOC容器
3.基于Java代码实例化配置Bean（Java Config） 基于Java Config配置IOC容器
二、基于XML对Bean进行配置 1.默认构造方法实例化对象 &lt;!-- bean标签通过默认构造方法创建对象 --&gt; &lt;bean id="apple1" class="com.learn.spring.ioc.entity.Apple"&gt;&lt;/bean&gt; public static void main(String[] args) { // 初始化IOC容器并实例化对象 ApplicationContext context = new ClassPathXmlApplicationContext ("classpath:applicationContext-initIOC.xml"); } 2.有参构造方法实例化对象 &lt;bean id="sweetApple" class="com.learn.spring.ioc.entity.Apple"&gt; &lt;constructor-arg name="title" value="红富士"/&gt; &lt;constructor-arg name="origin" value="欧洲"/&gt; &lt;constructor-arg name="color" value="红色"/&gt; &lt;constructor-arg name="price" value="9.8"/&gt; &lt;/bean&gt; 3.构造方法参数位置实例化对象 &lt;bean id="sweetApple" class="com.learn.spring.ioc.entity.Apple"&gt; &lt;constructor-arg index="0" value="红富士"/&gt; &lt;constructor-arg index="1" value="欧洲"/&gt; &lt;constructor-arg index="2" value="红色"/&gt; &lt;constructor-arg index="3" value="9.8"/&gt; &lt;/bean&gt; 4.基于静态工厂实例化对象 &lt;!-- 利用静态工厂获取对象 --&gt; &lt;bean id="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f1371a1016aba9936df73fbf3dc39eff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7fe0d04024da7ba3a4ae479dcb13fc40/" rel="bookmark">
			uview常用组件案例操作及详解（一） 选择器 picker
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		uview常用组件案例操作及详解（一） 选择器 picker 1.图片示例 2.使用方法 *为简便代码不提供样式
&lt;view&gt; &lt;view&gt; &lt;text&gt;行业性质&lt;/text&gt; &lt;text&gt;*&lt;/text&gt; &lt;/view&gt; &lt;view&gt; &lt;text v-if="!text.industry" @click="industrysTypeShow = true;"&gt;请选择&lt;/text&gt; &lt;text v-else @click="industrysTypeShow = true;"&gt;{{text.industry}}&lt;/text&gt; &lt;u-picker :show="industrysTypeShow" :columns="industrys" @confirm="industrysTypeConfirm" :defaultIndex="findIndex(detail.industry, industrys[0])" keyName="name" @cancel="cancel('industrysTypeShow')"&gt;&lt;/u-picker&gt; &lt;u-icon slot="right" name="arrow-right" @click="industrysTypeShow = true;"&gt;&lt;/u-icon&gt; &lt;/view&gt; &lt;/view&gt; 3.效果 4.步骤详解 4.1涉及字段介绍（以下字段可替换成自己的） 4.1.1 text.industry: 在界面上显示选中值
4.1.2industrysTypeShow: 在data中注册，控制选择器的显示和隐藏，在data中赋值为false
4.1.3 industrys: 这是一个二维数组，存放的是选择器内的选择值，如果你现在拿到的是一个一维数组Array，在他的外面包一个中括号即可变成二维数组，形如[Array]
4.1.4industrysTypeConfirm: 这是一个方法，用于点击选择器右上角的确定后执行的动作，主要有两步：1.给界面text.industry赋值，渲染文字 2.给后端字段赋值
industrysTypeConfirm(e) { this.detail.industry = e.value[0].theValue this.text.industry = e.value[0].name this.cancel('industrysTypeShow') }, 4.1.5cancel(‘industrysTypeShow’): 这是一个方法，用于点击选择器右上角的“取消”后执行的动作
cancel(visible) { this[visible] = false }, 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7fe0d04024da7ba3a4ae479dcb13fc40/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e2c91bba2631fb762623dde90a6a7a7/" rel="bookmark">
			MySQL灵魂十三问之第一问: 语法:like “%关键字%“(模糊匹配) 如何优化?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、建立全文索引1.1 语法如下： 二、修改查询语句2.1 原来的语法:2.2 修改后的语法:2.3 比较两种语法的执行时间: 前言 在工作中,我们经常遇到需要前后模糊匹配查找的功能需求,数据量小的话我们直接可以用like “%关键字%” 的语法就可以。但是当数据量比较大的时候,在用这类的语法效率就非常低下了,因为前模糊匹配查找SQL内置的优化器并不能生成合适的扫描区间,必然要用到全表扫描。那么有没有一种合适的方法来优化我们的这种SQL呢?答案: 肯定是有,只需两个简单步骤看完让你的SQL执行速度提升N倍。
一、建立全文索引 1.1 语法如下： ALTER TABLE 表名 ADD FULLTEXT INDEX 索引名 ( 列名 ) WITH PARSER ngram
例如:
ALTER TABLE t_ms_log ADD FULLTEXT INDEX idx_act_name ( act_name ) WITH PARSER ngram ngram为一个语法分析器,解决的是汉语分词的问题,有点类似ES的倒排索引。 二、修改查询语句 2.1 原来的语法: SELECT * FROM t_ms_log WHERE act_name LIKE "%进账%" 2.2 修改后的语法: SELECT * FROM t_ms_log WHERE MATCH(act_name) against('进账') 2.3 比较两种语法的执行时间: SHOW PROFILES 原语句耗时:
修改后的语句耗时:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2e2c91bba2631fb762623dde90a6a7a7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc8d3f2e5c5f3287596e206380cdc1e4/" rel="bookmark">
			助你上手Vue3全家桶之Vue3教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言1，setup1.1，返回值1.2，注意点1.3，语法1.4，setup的参数 2，ref 创建响应式数据3，reactive 创建响应式数据4，computed 计算属性5，watch 监听6，watchEffect 监听回调7，生命周期7.1，改变7.2，语法 8，toRef 创建ref9，toRefs 响应式转换10，shallowReactive 响应式外层转换11，shallowRef 基本数据响应式12，readonly 响应式变只读13，shallowReadonly 响应式变只读14，toRaw 响应式变非响应式15，markRaw 标记永远不响应式16，customRef 依赖更新控制17，provide &amp; inject 通信18，响应式数据的判断18.1，isRef18.2，isReactive18.3，isReadonly18.4，isProxy 19，teleport 移动dom组件20，Suspense 异步渲染组件21，全局API调整22，移除api23，Ref 获取DOM23.1，单个ref23.2，循环中的ref 24，emits 自定义事件25，$nextTick 异步更新26，hook 生命周期事件 前言 这些内容是博主在学习过程中记录下来的，有一些不重要的点就跳过了，需要时自行查询文档。其实V2到V3的学习成本不高，熟悉V2的话，看完这篇文章就可以上手V3。
Vue3官网
在线源码编译地址
1，setup setup是所有Composition API的容器，值为一个函数。组件中所用到的数据、方法等等，均要配置在setup中，它会在beforeCreate之前执行一次，注意：V3里this不再是指向Vue实例，访问this会是undefined
1.1，返回值 若返回一个对象，则对象中的属性、方法, 在模板中均可以直接使用。若返回一个渲染函数：则可以自定义渲染内容。 1.2，注意点 尽量不要与V2配置混用
V2配置（data、methos、computed…）中可以访问到setup中的属性、方法。
但在setup中不能访问到V2配置（data、methods、computed…）。
如果有重名, setup优先。
setup不能是一个async函数
因为返回值不再return的对象, 而是promise, 模板看不到return对象中的属性。（后期也可以返回一个Promise实例，但需要Suspense和异步组件的配合）
1.3，语法 &lt;script&gt; import { ref, reactive } from 'vue' export default { name: 'Home', setup(props, context) { const title = ref('标题') const data = reactive({ value: '哈哈哈' }) return { title, data } } } &lt;/script&gt; 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dc8d3f2e5c5f3287596e206380cdc1e4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ca5ed5aed0704cd04d1ce5d0f577130/" rel="bookmark">
			js实现汉字转成拼音
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 原文地址：Vue中使用把汉字转化为拼音字母_卑微小韩的博客-CSDN博客_vue汉字转拼音
源码git地址 https://github.com/waterchestnut/pinyin.git
安装 npm install js-pinyin import pinyin from 'js-pinyin' 123 使用示例 import pinyin from 'js-pinyin' pinyin.setOptions({checkPolyphone: false, charCase: 0}); console.log(pinyin.getFullChars('管理员')); console.log(pinyin.getCamelChars('管理员')); console.log(pinyin.getCamelChars('1234')); console.log(pinyin.getCamelChars('english')); 1234567 程序中调用 &lt;el-form-item label="名称" prop="Name"&gt; &lt;el-input v-model="form.Name" placeholder="名称" size="small" id="Name" @input="createpy()"/&gt; &lt;/el-form-item&gt; &lt;script&gt; methods: { createpy(){ let pinyin = require('js-pinyin') pinyin.setOptions({checkPolyphone: false, charCase: 0}) this.form.NamePy=pinyin.getCamelChars(this.form.Name) } } &lt;/script&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ddcffc3177a307962a3026c978a4bca/" rel="bookmark">
			IDEA类和方法注释模板配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、类的注释模板配置
File--&gt;Settings--&gt;Editor--&gt;File and Code Templates--&gt;File ---&gt;Class:
模板代码下所示：
/** * @ClassName: ${NAME} * @Author : ${USER} * @Date :${DATE} ${TIME} * @Description: TODO * @Version :1.0 */ 上述${NAME}为类名，${USER}为用户名，${DATE}为日期， ${TIME}为时间，TODO为待处理项
2、方法注释模板配置
File--&gt;Settings--&gt;Editor--Live Templates
1&gt;、新建组名，上述红色标点4，命名为userDefine
2&gt;、新建模板：命名为*
3&gt;、设置模板：模板内容如下
** $param$ *@Return:$return$ *@throws *@author:$user$ *@date:$date$ $time$ */ 4&gt;、设置模板应用场景
点击模板页面最下方的警告，来设置将模板应用于那些场景，一般选择EveryWhere--&gt;Java即可
（如果曾经修改过，则显示为change而不是define）
5&gt;、设置参数的获取方式，即Edit variables
即param的Expression为：
groovyScript("def result=''; def params=\"${_1}\".replaceAll('[\\\\[|\\\\]|\\\\s]', '').split(',').toList(); for(i = 0; i &lt; params.size(); i++) {result+=' * @param ' + params[i] + ((i &lt; params.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5ddcffc3177a307962a3026c978a4bca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dca55de1b12090b9551272a4675fdd46/" rel="bookmark">
			校园网ensp模拟搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录
前言 目录
一、校园网拓扑图
二、地址规划 三、配置命令
1、二层配置
2、三层配置
3、AC配置重头戏来啦
配置设备的国家码
查看AP的MAC地址
方法一
方法二 配置AP鉴别模式 创建安全模板创建SSID模板创建VAP模板为射频引用VAP模板总结 前言 学校最近在安装校园网，然后我也就试着用ensp搭建了一下，还请大佬多多指教啊
一、校园网拓扑图 下面是AP进入就绪状态
二、地址规划 三、配置命令 1.二层配置 代码如下：
1. LSW5
&lt;Huawei&gt;sys Enter system view, return user view with Ctrl+Z. [Huawei]undo info ena Info: Information center is disabled. [Huawei]vlan batch 2 4 6 Info: This operation may take a few seconds. Please wait for a moment...done. [Huawei]int g0/0/1 [Huawei-GigabitEthernet0/0/1]port l trunk [Huawei-GigabitEthernet0/0/1]port trunk allow vlan 1 2 4 [Huawei-GigabitEthernet0/0/1]q [Huawei]int e0/0/1 [Huawei-Ethernet0/0/1]port l acc [Huawei-Ethernet0/0/1]port def vlan 6 [Huawei-Ethernet0/0/1]q [Huawei]int g0/0/2 [Huawei-GigabitEthernet0/0/2]port l trunk [Huawei-GigabitEthernet0/0/2]port trunk allow vlan 1 2 4 6 [Huawei-GigabitEthernet0/0/2]q [Huawei] LSW2 和 LSW3 的命令行和接口配置过程和LSW1相同，后面的就自己配置啦
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dca55de1b12090b9551272a4675fdd46/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/048731b4cf76aa5ab6a6511b7840f245/" rel="bookmark">
			IFEM网格剖分（一）：普通网格剖分
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先在github上下载陈龙包IFEM.
然后把包添加到当前的依赖函数库里：File -&gt; Set Path(IFEM) -&gt; Add with Subfolders
1、三角形一致网格剖分 &gt;&gt; box = [-1, 1, -1, 1]; &gt;&gt; h = 0.1; &gt;&gt; [node, elem] = squaremesh(box, h); &gt;&gt; showmesh(node, elem) 2、正方形一致网格剖分 &gt;&gt; [node,elem,T] = squarequadmesh(box,h); &gt;&gt; showmesh(node,elem); 3、含退化单元的非结构性网格 在原有的一致三角形网格上使用公式：
x = x ^ + 0.1 ∗ sin ⁡ ( 2 π x ^ ) ∗ sin ⁡ ( 2 π y ^ ) y = y ^ + 0.1 ∗ sin ⁡ ( 2 π x ^ ) ∗ sin ⁡ ( 2 π y ^ ) x=\hat{x}+0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/048731b4cf76aa5ab6a6511b7840f245/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cbcf72c1d642f6a0cc709817a2373606/" rel="bookmark">
			IDEA2021中使用Git(2.38.1)和Gitee
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.Git的一些基本命令 1.常用命令 git config --global user.name 用户名设置用户签名git config --global user.email 邮箱设置用户签名git init初始化本地库git status查看本地库状态git add 文件名添加到暂存区git commit -m “日志信息(类似于提交备注)” 文件名提交到本地库git reflog查看历史提交记录git reset --hard 版本号 （版本号）版本穿梭vim 文件名修改文件 版本号可以通过查询日志查看
这个用户签名和地址只是在你自己电脑上有用，相当于本地库的一个标识。没啥卵用hhhhh
在进行git的一系列操作前首先就是要初始化一个本地仓库。
进行git操作时文件的提交经历的阶段为:
工作区(可撤销) --&gt;暂存区(可撤销) --&gt;本地库(不可撤销) --&gt;远程库
2.分支操作 git branch 分支名创建分支git branch -v查看分支git checkout 分支名切换分支git merge 分支名把指定的分支合并到当前分支上 当master主分支和其他分支都做出修改时，这个时候再合并分支，就会产生冲突，如果产生冲突就需要手动合并冲突，后面在idea里面更容易合并，更直观。
冲突产生的原因：
合并分支时，两个分支在同一个文件的同一个位置有两套完全不同的修改。Git 无法替我们决定使用哪一个。必须人为决定新代码内容。
3.远程仓库操作命令 命令名称作用git remote -v查看当前所有远程地址别名git remote add 别名 远程地址起别名git push 别名 分支推送本地分支上的内容到远程仓库git clone 远程地址将远程仓库的内容克隆到本地git pull 远程库地址别名 远程分支名将远程仓库对于分支最新内容拉下来后与 2.idea集成Git并且和远程仓库(gitee)建立连接 这里以gitee(码云)为例进行解释，因为其服务器在国内速度较快，当然也可以用github进行自己代码的托管，但它的服务器在国外，可以下载一个steam++加快访问速度，我觉得还挺快的hhh 如果是github idea是自己包含github插件的，如果是gitee我们需要自己下载一个叫gitee的插件
1.集成Git 在idea中按这个顺序找到Git选项↓↓↓↓↓↓↓↓↓
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cbcf72c1d642f6a0cc709817a2373606/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3bbd862c87d1580ba772741b6d4b976/" rel="bookmark">
			华为eNSP：静态路由
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		华为eNSP:静态路由 一、拓扑图搭建二、IP地址的配置三、静态路由配置四、查看和测试（1）查看（2）测试 一、拓扑图搭建 PC1：IP如下图所示
PC2：IP如下图所示
二、IP地址的配置 ​ 配置R1的IP地址
&lt;Huawei&gt;u t m //在用户视图关闭提示信息 Info: Current terminal monitor is off. &lt;Huawei&gt;sys //进入系统视图 Enter system view, return user view with Ctrl+Z. [Huawei]u in e //在系统视图关闭提示信息 Info: Information center is disabled. [Huawei]sys R1 // 将名字改为R1 [R1]int g0/0/0 //进入接口g0/0/0 [R1-GigabitEthernet0/0/0]ip add 192.168.1.254 24 //配置IP地址 [R1-GigabitEthernet0/0/0]un sh //启动接口 Info: Interface GigabitEthernet0/0/0 is not shutdown. [R1-GigabitEthernet0/0/0]int g0/0/1 [R1-GigabitEthernet0/0/1]ip add 10.0.0.1 24 [R1-GigabitEthernet0/0/1]un sh Info: Interface GigabitEthernet0/0/1 is not shutdown.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d3bbd862c87d1580ba772741b6d4b976/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/596c78f412c95bea7a2a5d4fdcd6987d/" rel="bookmark">
			ACwing算法基础笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		快排（不稳定） 分治
时间复杂度在O(nlogn)~O(n^2)之间
1.确定分界点
2.调整区间
3. 递归（先处理左段，再处理右段）
785.快速排序
#include&lt;iostream&gt; using namespace std; const int N = 1e6 + 10; int n, q[N]; void quick_sort(int q[], int l, int r) { if (l &gt;= r) return; int x = q[(l + r) / 2], i = l - 1, j = r + 1; while (i &lt; j) { do i++; while (q[i] &lt; x);//小于x，则左指针继续右移 do j--; while (q[j] &gt; x);//当遇到大于等于x的数，右指针左移，遇到小于等于x的数则停下 if (i &lt; j) swap(q[i], q[j]);//左指针在右指针左边，则交换 } quick_sort(q, l, j);//递归处理左端 quick_sort(q, j + 1, r);//递归处理右端 } int main() { scanf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/596c78f412c95bea7a2a5d4fdcd6987d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af8f2566612bd18dbef942a3b23db4f0/" rel="bookmark">
			Android App开发实战项目之购物车（附源码 超详细必看）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需要源码请点赞关注收藏后评论区留言~~~
一、需求描述 电商App的购物车可谓是司空见惯了，可以知道购物车除了底部有一个结算行，其余部分主要是已加入购物车的商品列表，然后每个商品左边是商品小图，右边是商品名称以及价格，第一次进入购物车页面应该是空的，随着加入东西的增加而增加。并且在其他界面也能看到购物车，比如有新商品加入时数字会加一
二、界面设计 主要用到了以下控件
线性布局
网格布局
相对布局
数据库SQLite
全局内存
存储卡文件
共享参数SharedPreferences
效果如下
三、关键部分 1：关于页面跳转 因为购物车页面允许直接跳到商场页面，并且商场页面也允许跳到购物车页面，所以如果用户在这两个页面之间来回跳转，然后再按返回键，结果发现返回的时候也是在这两个页面之间跳转，出现问题的原因在于：每次启动活动页面都往活动栈中加入一个新活动，那么返回出栈之时，也只好一个个活动依次退出了
2：关于商品图片的缓存 通常商品图片由后端服务器提供，App打开页面时再从服务器下载所需的商品图，可是购物车模块的多个页面都会展示商品图片，如果每次都到服务器请求图片，显然非常消耗时间和流浪，因此App都会缓存常用的图片，一旦从服务器成功下载图片，便在手机储存卡上保存图片文件。然后下次界面需要加载商品图片时，就先从存储卡寻找该图片，如果找到就读取，没找到再去服务器下载
四、部分源码 ShoppingDetailActivity package com.example.chapter06; import android.annotation.SuppressLint; import android.content.Intent; import android.net.Uri; import android.os.Bundle; import android.view.View; import android.view.View.OnClickListener; import android.widget.ImageView; import android.widget.TextView; import android.widget.Toast; import androidx.appcompat.app.AppCompatActivity; import com.example.chapter06.bean.GoodsInfo; import com.example.chapter06.database.CartDBHelper; import com.example.chapter06.database.GoodsDBHelper; import com.example.chapter06.util.ToastUtil; @SuppressLint("SetTextI18n") public class ShoppingDetailActivity extends AppCompatActivity implements View.OnClickListener { private TextView tv_title; private TextView tv_count; private TextView tv_goods_price; private TextView tv_goods_desc; private ImageView iv_goods_pic; private long mGoodsId; // 当前商品的商品编号 private GoodsDBHelper mGoodsHelper; // 声明一个商品数据库的帮助器对象 private CartDBHelper mCartHelper; // 声明一个购物车数据库的帮助器对象 @Override protected void onCreate(Bundle savedInstanceState) { super.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/af8f2566612bd18dbef942a3b23db4f0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53c02fa60520acc5d8899e675e2b3aed/" rel="bookmark">
			结构光的简述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		结构光方法又称为主动三角形测量，它是一种将编码模式投射到目标表面，由目标对其进行调制，使其产生的条纹模式产生变化，从而获得目标的深度信息。然后用相机对条纹图像进行捕捉和记录，并对其进行处理，得到目标的立体轮廓。
对于结构光法的优点而言，首先，结构光简化了物体检测问题，在被测量的空间中，有一种已知的光模式，其发生改变则表明有一种对象。其次，通过光学模式的失真畸变情况，可以得到对象的立体外形特征。同时，该方法在外形尺寸、价格方面有着优势，因而在工业领域中应用最为广泛。接下来将详细介绍一下各类结构光：
点结构光是投射到物体表面的是一个点光源，通过相机对目标进行成像，并对其进行处理，获得其上的三维坐标。这种方法需要对被测量对象的表面进行逐点扫描，从而得到整个对象的三维形态。所以，在测量大面积和高分辨的物体时，会提高拍摄时间和增大图像处理的工作量，如果想要完成 物体场景的实时监测功能，还是比较困难的。
线结构光测量方法的测量方式相对于点结构光扫描点来说，换成了扫描线。通过扫描线来获取该投影线上的三维坐标，极大地提升了测量效率，但仍需进一步改进。
编码结构光法是指通过一定的方式将编码模式投影到目标表面，得到被测量对象的三维轮廓。通过采用编码的方法，可以获得各点的投影角度α ，并通过构造光线的基本方程，获得目标的三维信息，并进行重构。结构光编码法是目前最可靠的一种三维测量技术之一。该方法的采集时间短、测量精度高，是目前结构光三维轮廓测量方法的主要发展方向。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/720dec1a5dab389517b6f7fb93b37d8b/" rel="bookmark">
			素数筛(线性筛法)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、什么是线性筛法？
线性筛法是指在O(n)的复杂度情况下，筛选出所给数的所有质数
二、原理是什么？
1.最小质数
由公理可知，n都可以被分解为多个质数的乘积，那么，在这些质数中，我们总能找到一个最小的数x，那么x就是n的最小质数
2.剔除非质数
既然有了最小质数x，针对每一个数，我们只需要从2开始，逐条对2-n进行遍历（假设我们此时遍历到的数是i），如果发现i%x=0，
那么我们就知道这个数要被剔除掉因为它可以被至少两个数的乘积表示（不满足质数的定义）
3.如何保证不重复剔除非质数？
我们知道，45可以是315，或者是是59，如果我们按照第二步的想法，必将重复筛掉45两次，如果n足够大，这将会有很多重复操作，是不可接受的
那么我们该怎么做？
很简单，我们只要保证如一开始所说的，让45被他的最小质数（3）给筛掉就行，那么又该怎么做？
if(i%pri[j]==0)break;
这句话有什么意义？我们来打个比方，如果此时的i=4，即12=223=3*4，我们需要让12被2给筛掉
那么当pri[j]=2时，我们就要停止这个for循环了，为什么要这么做？
vis[pri[j]i]=1;
很简单，因为i此时能被2（i=12=22*3），那么我们可不可以断言，x = pri[j] * i = pri[j] * 2 * k
(也就是说x的最小质数是2)也可以被2给表示？
答案是肯定的，由此我们可以推断，我们此时不break，就会在这次循环筛掉12（3*4，通过3筛掉12）
但是下一轮循环我们又会通过2*6筛掉12，这显然不符合我们的目的，保证每个数被筛一次，所以我们只要
确保每个数被自己的最小质数筛掉，换言之，就是当i能被当前的质数整除时（当前整数就是i的最小质数），
就break，这样后面的数（后面所有含有i的数不会被当前循环筛掉）就不会被重复筛掉。
三，代码实现
int pri[N+9&gt;&gt;1],now; bool vis[N+9]; void init(){ for(int i=2;i&lt;=N;i++){ if(!vis[i])pri[++now]=i; for(int j=1;j&lt;=now&amp;&amp;pri[j]*i&lt;=N;j++){ vis[pri[j]*i]=1; if(i%pri[j]==0)break; } } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/79482b280e79852c6d76378d23e51867/" rel="bookmark">
			C&#43;&#43;中SORT函数使用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C++中SORT函数使用方法 一.sort函数
1.sort函数包含在头文件为#include的c++标准库中，调用标准库里的排序方法可以实现对数据的排序，但是sort函数是如何实现的，我们不用考虑！
2.sort函数的模板有三个参数：
void sort (RandomAccessIterator first, RandomAccessIterator last, Compare comp);
（1）第一个参数first：是要排序的数组的起始地址。
（2）第二个参数last：是结束的地址（最后一个数据的后一个数据的地址）
（3）第三个参数comp是排序的方法：可以是从升序也可是降序。如果第三个参数不写，则默认的排序方法是从小到大排序。
3.实例
#include&lt;iostream&gt; #include&lt;algorithm&gt; using namespace std; int main() { //sort函数第三个参数采用默认从小到大 int a[]={45,12,34,77,90,11,2,4,5,55}; sort(a,a+10); for(int i=0;i&lt;10;i++) cout&lt;&lt;a[i]&lt;&lt;" "; } 运行结果：
#include&lt;iostream&gt; #include&lt;algorithm&gt; using namespace std; bool cmp(int a,int b); int main(){ //sort函数第三个参数自己定义，实现从大到小 int a[]={45,12,34,77,90,11,2,4,5,55}; sort(a,a+10,cmp); for(int i=0;i&lt;10;i++) cout&lt;&lt;a[i]&lt;&lt;" "; } //自定义函数 bool cmp(int a,int b){ return a&gt;b; } 运行结果：
1 #include&lt;iostream&gt; 2 #include&lt;algorithm&gt; 3 #include"cstring" 4 using namespace std; 5 typedef struct student{ 6 char name[20]; 7 int math; 8 int english; 9 }Student; 10 bool cmp(Student a,Student b); 11int main(){ 12 //先按math从小到大排序，math相等，按english从大到小排序 13 Student a[4]={{"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/79482b280e79852c6d76378d23e51867/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ccd2a23361c2a0f75826c993a774103e/" rel="bookmark">
			Json以及Json在Qt中的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、简介 JSON:一种轻量级的数据交换格式
一般.json后缀
高效简单
2、使用 组织数据:用于数据的网络传输
组织数据:用于磁盘文件实现数据的持久化存储
用在登录 记录用户名密码等，下次打开软件，自动填充。
3、Json数组 Json数组使用[]表示，[]里面是元素，元素间使用 , 分隔，最后一个元素后面，没有 ,
一个Json数组，支持多种不同的数据类型，包括:整形，浮点型，字符串，json数组，json对象，空值-null(null)
Json数组中嵌套Json数组，父子关系
Json数组嵌套Json对象，Json对象可以嵌套Json数组
3.1、数组内元素类型一致 [1, 2, 3] ["哈哈","hehe","yiyi"] 3.2、数组内元素类型不一致 [1, 2, 3, true, false, "haha",null] 3.3、Json数组嵌套Json数组 [ ["cat", "狗狗", "河马", 1]//元素类型可以不一致 [1, 3, 5, true] ] 3.4、Json数组和Json对象嵌套 [//外层是Json数组 {//内层是Json对象 "小明":{//属于键值对 "age":19, "father":"大华", "sister":"小妹" } } ] 4、Json对象 Json对象使用{}来描述，每个Json对象可以存储若干个元素，每个元素对应一个键值对（key:value），元素和元素之间使用 , 间隔，最后一个元素后面没有 ,
注意:
1.键值key，必须是字符串，位于同一层级的键值，不能重复(通过键值取出数据value)
2.value值的类型是可选的，整形，浮点型，字符串，json数组，json对象，空值-null(null)
Json描述一个人的信息: { "NAME":"ACE", "Sex":"man", "Age":20, "Family":{ "Father":"yiyi", "brother":["aa","bb","cc"] }, "IsLive":"true" } 5、注意事项 , 不能乱加，解析会出错
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ccd2a23361c2a0f75826c993a774103e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ffa2d4fe1e4539512bc5bf0083578011/" rel="bookmark">
			this指针详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		this指针 this 实际上是成员函数的一个形参，在调用成员函数时将对象的地址作为实参传递给 this。不过 this 这个形参是隐式的，它并不出现在代码中，而是在编译阶段由编译器默默地将它添加到参数列表中。
this指针是类的指针，指向对象的首地址。
this指针只能在成员函数中使用，在全局函数、静态成员函数中都不能用this。
this指针只有在成员函数中才有定义，且存储位置会因编译器不同有不同存储位置。
this指针的用处 一个对象的this指针并不是对象本身的一部分，不会影响sizeof(对象)的结果。this作用域是在类内部， 当在类的非静态成员函数中访问类的非静态成员的时候（全局函数，静态函数中不能使用this指针）， 编译器会自动将对象本身的地址作为一个隐含参数传递给函数。也就是说，即使你没有写上this指针， 编译器在编译的时候也是加上this的，它作为非静态成员函数的隐含形参，对各成员的访问均通过this 进行
this指针的使用 一种情况就是，在类的非静态成员函数中返回类对象本身的时候，直接使用 return *this；
另外一种情况是当形参数与成员变量名相同时用于区分，如this-&gt;n = n （不能写成n = n）
类的this指针有以下特点 (1）this只能在成员函数中使用，全局函数、静态函数都不能使用this。实际上，成员函数默认第一个 参数为T * const this
如：
class A{ public: int func(int p){} 4	}; 其中，func的原型在编译器看来应该是： int func(A * const this,int p); （2）由此可见，this在成员函数的开始前构造，在成员函数的结束后清除。这个生命周期同任何一个 函数的参数是一样的，没有任何区别。当调用一个类的成员函数时，编译器将类的指针作为函数的this 参数传递进去。如：
A a; a.func(10); //此处，编译器将会编译成： 4	A::func(&amp;a,10); 看起来和静态函数没差别，对吗？不过，区别还是有的。编译器通常会对this指针做一些优化，因此，
this指针的传递效率比较高，例如VC通常是通过ecx（计数寄存器）传递this参数的。
几个this指针的易混问题 A. this指针是什么时候创建的？ this在成员函数的开始执行前构造，在成员的执行结束后清除。
但是如果class或者struct里面没有方法的话，它们是没有构造函数的，只能当做C的struct使用。采用TYPE xx的方式定义的话，在栈里分配内存，这时候this指针的值就是这块内存的地址。采用new的方式创建对象的话，在堆里分配内存，new操作符通过eax（累加寄存器）返回分配的地址，然后设置给指针变量。之后去调用构造函数（如果有构造函数的话），这时将这个内存块的地址传给ecx，之后构造 函数里面怎么处理请看上面的回答
B. this指针存放在何处？堆、栈、全局变量，还是其他？ this指针会因编译器不同而有不同的放置位置。可能是栈，也可能是寄存器，甚至全局变量。在汇编级 别里面，一个值只会以3种形式出现：立即数、寄存器值和内存变量值。不是存放在寄存器就是存放在 内存中，它们并不是和高级语言变量对应的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ffa2d4fe1e4539512bc5bf0083578011/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/704462e3e987dce638ef510b4f88ee34/" rel="bookmark">
			SQL Server数据库管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据库登录——使用两种方式均可登录数据库：windows和sqlserver身份验证方式两种。
数据库的使用和管理
步骤一：创建数据库
1）新建数据库，数据库名为book，初始大小都配置为3，自动增长与路径都为默认，点击确定 步骤二：查看主数据与日志文件（查看C:\Program Files\Microsoft SQL Server\MSSQL10_50.MSSQLSERVER\MSSQL\DATA目录中的book.mdf和book_log.ldf)
步骤三：创建读者信息表--在book库中-右击表--选择新建表(输入列名及数据类型) 步骤四：数据库的一些简单语句
SELECT - 从数据库中提取数据 UPDATE - 更新数据库中的数据 DELETE - 从数据库中删除数据 INSERT INTO - 向数据库中插入新数据 CREATE DATABASE - 创建新数据库 ALTER DATABASE - 修改数据库 CREATE TABLE - 创建新表 ALTER TABLE - 变更（改变）数据库表 DROP TABLE - 删除表 CREATE INDEX - 创建索引（搜索键） DROP INDEX - 删除索引 步骤五：数据库备份与恢复问题
1）完整备份 2）差异备份 3）事务日志备份 C盘的目录下新建三个文件夹，刚刚创建的数据库book ,右击book选择任务备份，在弹出的对话框中选择备份类型完整，备份到c:\完整备份\full.bak，点击确定
1）完整备份 验证备份方案是否成功?
标题: Microsoft SQL Server Management Studio
------------------------------
还原 对于 服务器“WIN-O7K6FVSA3VF”失败。 (Microsoft.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/704462e3e987dce638ef510b4f88ee34/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba6c807cfb5bc5a711d02724514561de/" rel="bookmark">
			js的区间处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.判断某个值是否在区间数组里 // 闭合区间 let open = [ [1, 3], [4, 6], [7, 10], [10, 11], ] // 判断值是否在区间的整体函数 function judgeSection() { let current = 0 // 初始开关区间为false let isOpen = false; // let isClose = false; for (let i = 0; i &lt; open.length; i++) { // 判断是否在区间 if (judgeCurrentNumberInSection(current, open[i])) { // 如果在，直接终止循环，赋值为true isOpen = true break; } } console.log(`当前值在 ${isOpen ? ' 开 ': ' 关 '}区间`); } // 判断值是否属于该区间 function judgeCurrentNumberInSection(current, section) { if (current &gt;= section[0] &amp;&amp; current &lt;= section[1]) return true else return false } 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ba6c807cfb5bc5a711d02724514561de/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8adcce7d6e6893d59f265274e8643f52/" rel="bookmark">
			用递归实现字符串逆序函数。reverse_string(char * string)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		函数功能： 函数形式为：void reverse_string(char* string)
参数：
sting为指向需要逆序的字符串的首字符地址的指针
内容：
将string所指向的字符与该字符往后第一个'\n'之间的字符串逆序。（包括首字符，不包括'\n'）
返回值：
无返回值。
举个例子：
这是输出：
函数实现： 假设这是需要逆序的字符串。将a的地址传进函数。
基本思路就是先将*p1和*p2互换，然后再将中间的bcdef逆序；*p2就是*（p1+strlen（p1）-1）；接下来尝试代码实现
优化。
最后进到最后一层，开始回归的时候吧b的字符赋给字符串的第一个\0就行了；
代码如下： #include&lt;stdio.h&gt; #include&lt;string.h&gt; void reverse_string(char* p) { char a = *p; *p = *(p + strlen(p) - 1); *(p + strlen(p) - 1) = a; char b = *(p + strlen(p) - 1); *(p + strlen(p) - 1) = '\0'; if (p &lt; p + strlen(p) - 1) reverse_string(p + 1); *(p + strlen(p) - 1) = b; } int main() { char s[] = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8adcce7d6e6893d59f265274e8643f52/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2ed281c2f3714d176cae910f141961c/" rel="bookmark">
			rtthread studio低版本的PWM 问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		static rt_err_t stm32_hw_pwm_init(struct stm32_pwm *device) { rt_err_t result = RT_EOK; TIM_HandleTypeDef *tim = RT_NULL; TIM_OC_InitTypeDef oc_config = {0}; TIM_MasterConfigTypeDef master_config = {0}; TIM_ClockConfigTypeDef clock_config = {0}; RT_ASSERT(device != RT_NULL); tim = (TIM_HandleTypeDef *)&amp;device-&gt;tim_handle; /* configure the timer to pwm mode */ tim-&gt;Init.Prescaler = 0; tim-&gt;Init.CounterMode = TIM_COUNTERMODE_UP; tim-&gt;Init.Period = 0; tim-&gt;Init.ClockDivision = TIM_CLOCKDIVISION_DIV1; #if defined(SOC_SERIES_STM32F1) || defined(SOC_SERIES_STM32L4) tim-&gt;Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE; #endif ***if (HAL_TIM_Base_Init(tim) != HAL_OK) /* 注意这里是定时器的初始化，别看混了！！！ */ { LOG_E("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c2ed281c2f3714d176cae910f141961c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44eae525c9ee414838b0eab03a48de33/" rel="bookmark">
			Android Studio开发之存储卡的文件操作讲解及实战（附源码 在存储卡上读写文本文件和图片文件）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、私有存储空间和公共存储空间 为了更规范的管理手机存储空间，Android从7.0开始将存储卡划分为私有存储和公共存储两大部分，也就是分区存储方式，系统给每个App都分配了默认的私有存储空间，App在私有空间上读写文件无须任何授权，但是若想在公共空间读写文件，则要在AndroidManifest.xml里面添加权限配置，并且即使App声明了完整的存储卡操作权限，系统仍然默认禁止该App访问公共空间，打开系统的系统设置界面，进入到具体应用的管理页面，然后打开该应用的存储访问权限。
既然存储卡分为公共空间和私有空间两部分，它们的空间路径获取也就有所不同。如下图所示
FilePathActivity类 package com.example.chapter06; import android.os.Build; import android.os.Bundle; import android.os.Environment; import android.widget.TextView; import androidx.appcompat.app.AppCompatActivity; public class FilePathActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_file_path); TextView tv_path = findViewById(R.id.tv_path); // Android7.0之后默认禁止访问公共存储目录 // 获取系统的公共存储路径 String publicPath = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS).toString(); // 获取当前App的私有存储路径 String privatePath = getExternalFilesDir(Environment.DIRECTORY_DOWNLOADS).toString(); boolean isLegacy = true; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.Q) { // Android10的存储空间默认采取分区方式，此处判断是传统方式还是分区方式 isLegacy = Environment.isExternalStorageLegacy(); } String desc = "系统的公共存储路径位于" + publicPath + "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/44eae525c9ee414838b0eab03a48de33/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b2d084a9a81c780b4428e6d2c4d36ff/" rel="bookmark">
			卡诺图化简法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		卡诺图由美国工程师卡诺提出，简称K图。
定义：根据最小项真值表按一定规则排列而成的方格图
一种按照相邻规则而排列而成的最小项方格图，利用相邻项不断合并的原则可以使逻辑函数得到化简。优点；简单，直观
AB/C000111100ABA1CBCABCAC AB/C000111100M0M2M6M41M1M3M7M5 AB/C000111100026411375 卡诺图的特点
1，N个变量的卡诺图有N*N个方格
2，卡诺图中任何相邻位置的两个最小项都是相邻项（相邻包含三种情况：1，相接，紧挨着 2，相对，任意一行或一列的两头 3 相重，对折起来位置重合）
二，卡诺图的表示方法
1，给出的逻辑函数为与或标准式
方法：将构成逻辑函数的最小项在卡诺图相应的方格中填1，其余填0.
也就是说，任何一个逻辑函数都等于其卡诺图上填1的最小项之和。
2，给出的逻辑函数为一般与或式
将一般与或式中每个与项在卡诺图上所覆盖的最小项都填1，其余填0
3给出函数为与或标准式
只要将构成逻辑函数的最大项在卡诺图相应的方格中填0，其余的方格填1
任何一个逻辑函数都等于其卡诺图上填0的那些最大项之积
三，最小项合并规律
卡诺图中凡是相邻的最小项都可以合并
两个相邻最小项合并为一项，消去一个互补变量。
卡诺图化简逻辑函数一般步骤；
1，根据逻辑函数画出卡诺图
2，画卡诺图圈合并最小项（原则;先从只有一种圈法的1格圈起，卡诺圈数量应该最少，卡诺圈应该最大）
3，写出最简函数
注意；任何一个卡诺圈可以多次被圈用，但是应该注意每个卡诺圈至少有一格只被圈一次）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/370bccc33ba744ffd1fef7bbd2634b18/" rel="bookmark">
			自己手写一个简便化订阅与发布
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		/*判断类型*/ function toType(v) { if (arguments.length === 1) { var type = Object.prototype.toString.call(v); return type.slice(8, type.length - 1); } } /*构造实例对象*/ function PubSup(options) { if (options) { this.options = options; } } function ast() { return toType(arguments[0]) === 'String' || toType(arguments[0]) === 'Array'; } function aft() { return toType(arguments[0]).indexOf('Function') !== -1 || toType(arguments[0]) === 'Array'; } PubSup.prototype = { constructor: PubSup, /*订阅 绑定*/ $on: function () { var args = arguments; if (args.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/370bccc33ba744ffd1fef7bbd2634b18/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cfb668db228b025806a7f8714995605f/" rel="bookmark">
			linux 搜狗输入法无法输入中文
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决方法
不知道第十几次/几十次搞坏系统了，每次重装搜狗都有无法输入中文的问题，这个帖子的方法非常有效
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14b58f24a11760a98d0ac3c7889eabc2/" rel="bookmark">
			pubsub.js介绍以及基本使用方法介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		List item 什么是PubSubJS？ PubSubJS 是一个用 JavaScript 编写的基于主题的 发布/订阅库。
PubSubJS 有同步解耦，所以主题是异步发布的。这有助于使您的程序保持可预测性，因为在消费者处理主题时，主题的发起者不会被阻止。
主要特点： 无依赖同步解耦ES3 兼容。PubSubJS 应该能够在任何可以执行 JavaScript 的地方运行。浏览器、服务器、电子书阅读器、旧手机、游戏机。AMD / CommonJS 模块支持不修改订阅者（jQuery 自定义事件修改订阅者）易于理解和使用（感谢同步解耦）
小，小于 1kb 压缩和压缩 安装步骤和安装方法 1.通过 npm ( npm install pubsub-js)安装
npm i pubsub-js
2.通过script引用
https://unpkg.com/pubsub-js
使用方法举例 1 通过npm 安装使用方法 import PubSub from 'pubsub-js' console.log(PubSup); /*输出下，查看都有哪些方法*/ 使用 通过PubSup.subscribe 订阅函数
import PubSub from 'pubsub-js' var aReturn = PubSup.subscribe('a',/*订阅的函数名字*/,(name,parameter)=&gt;{ /*name 该订阅的函数名=== a */ /*parameter 传递的参数*/ console.log(name,parameter); /*a 1*/ }/*事件处理函数*/); /*aReturn 是你订阅成功后返回的参数 它是一个唯一的值*/ /*如果你想解绑该订阅的事件可以通过这个返回值（aReturn）进行解绑，也可以通过你订阅函数名（'a'）进行解绑*/ 通过PubSup.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/14b58f24a11760a98d0ac3c7889eabc2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a49ba2ef6832b4841db9074fcd727764/" rel="bookmark">
			Java——数组的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java数组的使用 一、数组的基本概念1.数组的声明及初始化2.数组的访问及遍历 二、操作数组1.数组拷贝2.数组排序 三、不规则数组 一、数组的基本概念 数组是一种数据结构，用来存储一类型值的集合。可以看成是相同类型元素的一个集合，再内存中是一段连续的的空间，通过一个整形索引或下标可以访问数组中的每一个值。例如，如果a是一个整形数组，a[i]就是数组中索引为i的整数。
1.数组的声明及初始化 数组的声明有三种方式
方式一：类型[] 数组名 = new 类型[数组元素个数]
//下面我们声明一个整形数组，元素个数为3的整形数组 int[] array = new int[3]; 解释：此时我们就成功声明一个整形类型并且元素个数为3的整形数组，
并且默认初始化元素全部为0；
方式二：类型[] 数组名 = new 类型[]{元素一，元素二，…，元素n}
//下面我们创建一个数组里面元素为1——5的整形数组 int[] array1 = new int[]{1,2,3,4,5}; //简写形式 int[] array2 = {1,2,3,4,5}; 解释：这种方式创建的数组的长度为数组中元素个数，创建及初始化
方式三：var 数组名 = new 类型[元素个数]
//创建元素个数为3的整数数组 var array1 = new int[3]; //相当于下面的这种创建方式 int[] array2 = new int[3]; 解释：这种方式创建的数组在编译的时候虚拟会自动匹配右边的变量的类型，这也是var关键字的用法。
补充：一旦创建了数组，就不能再改变数组的长度（不过，当然可以改变单个数组元素）。如果程序运行中需要扩展数组的大小，就应该使用另一种数据类型——数组列表（这里不加拓展）。
2.数组的访问及遍历 数组元素从0开始编号。最后一个合法的索引为数组长度减1.创建数组是所有元素初始化为0，boolean数组初始化为false。对象数组（这里不加拓展）的元素则初始化为一个特殊值null，表示这些元素未存放任何对象。
//我们先创建一个数组 int[] array = {1,2,3,4,5}; //此时我们就访问数组元素下标为2的元素（3） int getElement = array[2]; //打印输出 System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a49ba2ef6832b4841db9074fcd727764/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d899141c6b3ea7fe7bd7a248f056afd/" rel="bookmark">
			错误：非法字符‘ufflb‘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		将中文封号改成英文封号
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f81320f172805823372918961907d9a9/" rel="bookmark">
			flask-sqlalchemy between的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		q = session.query(Table.value) for f in l: q = q.filter((Table.value.between(f[0], f[1]))) https://stackoverflow.com/questions/50304880/filtering-or-of-multiple-between-in-sqlalchemy
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2a1d7d6ac2a47b3ada808fda5a7022c/" rel="bookmark">
			C&#43;&#43;下OPENCV驱动调用海康GigE工业相机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列文章目录 第一章 Ubuntu22下OpenCV4.6.0+contrib模块编译安装
第二章 ubuntu22下C++ kdevelop环境搭建：OpenCV示例
第三章 C++下OPENCV驱动调用海康GigE工业相机
文章目录 系列文章目录前言一、海康工业相机二、MVS软件安装 摄像头连接1.安装MVS2.连接配置摄像头 三、基于SDK的摄像头C++开发1.拷贝SDK2.编辑cmakelist3.编辑相机class4.主函数调用 四、测试验证总结 前言 在前两章内笔者详细叙述了如何编译以及加载opencv库，本文将从opencv出发，在linux系统下利用海康工业摄像机的SDK完成基于海康工业相机的opencv开发算法。
包含：
1.海康工业相机的驱动；
2.工业相机的帧格式转换；
本文代码库:https://gitee.com/C-Qiyao/gig-e_camera
一、海康工业相机 一切缘起笔者在实验室翻箱倒柜喜提一个师兄购买的海康工业 相机，遂对其进行详细了解，发现功能性相比普通摄像头强不少。
产品页面
笔者使用的海康工业相机的型号为MV-CE013-50GC，采用rj45的网线接口来输出视频数据，并不会在系统设备上挂载video设备，所以需要调用海康的驱动来完成视频帧的获取。
二、MVS软件安装 摄像头连接 MVS软件是为支持海康机器视觉相机产品而开发的软件应用程序，适用于所有海康机器视觉面阵以及线阵相机产品。MVS内我们主要配置摄像头以及利用他的SDK进行开发。
1.安装MVS 前往HIKROBOT网站下载对应系统的MVS安装包
在此笔者使用的是linux系统所以选择linux系统的安装包进行下载
打开下载得到的压缩包，内容如下：
我们使用的计算机为64位的X86架构，所以在此我们将后缀为x86_64的安装包解压出来，笔者使用的是Debian系的ubuntu操作系统，所以在此解压对应deb安装包。
使用终端或者软件安装器安装该deb包
安装完成之后，读者可能会发现并没有在菜单内找到MVS软件的图标,但是我们可以在/opt路径下找到MVS的文件夹
qiyao@qiyao-Legion-Y9000X-IAH7:/opt$ ls apps durapps ffmpeg-4.3.tar.gz nvidia zTools clion deepin-wine6-stable ffmpeg MVS qqmusic 进入MVS文件夹，启动MVS软件
$ cd /opt/MVS/bin $ ./MVS 成功打开MVS界面
2.连接配置摄像头 笔者使用的海康摄像头采用rj45接口，查阅手册得知需要使用千兆以太网标准进行连接
设置网卡IP 修改有线网卡ipv4参数为以下内容：
IP：	192.168.16.68 网关：	192.168.16.1 DNS：	202.96.128.166 MTU：	9000 重启MVS软件，在设备列表里选中我们的网络摄像机，右键修改IP（在ip段内随意设置）
双击选中我们的相机，开启相机采集
至此，相机和计算机之间的连接以及完成，接下来就需要进行SDK的开发了，同时我们在画面下部的带宽部分也可以发现，该相机的数据流巨大，确实需要依赖千兆网络的支撑。
三、基于SDK的摄像头C++开发 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a2a1d7d6ac2a47b3ada808fda5a7022c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47053588eba60f0f53f850be9f73152a/" rel="bookmark">
			UDS协议的项目应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		P2*Server:当ECU发送NRC 0x78（Pending）以后，如果在P2*Server时间内没有positive回应，将回应NRC 0x7F。
比如Tester发送02 02验证软件是否valid，ECU回应NRC 0x78以后；ECU一直在做别的事情，比如发送debug信息等，导致没有及时回复验证结果；超过P2*Server时间后，ECU将回应NRC 0x7F。
P2*Server在ECU回应10 01的时候，已经将该值发送给了tester。
S3 Server:如果ECU在非默认会话时，比如programming session，tester发送3E 00 或者3E 80 维持ECU在非默认会话。如果在Tester端S3server这个时间内，比如说5000毫秒时间内，都没有给ECU发送任何诊断请求报文，那么ECU就会从非默认会话跳转到默认会话。如果ECU处于解锁状态，也会从解锁状态跳转到锁定状态（UDS建议S3时间5000 ms）
S3client: Tester的定时参数，客户端为将ECU保持在非默认会话状态，两个连续的0x3E TesterPresent请求报文的间隔时间。通常取4000ms。
对于radar，10 02的时候，BM不会触发PORST；但是在11 01/S3 time out的时候，BM 会触发PORST;
对于dasy，10 02的时候，BM 不会触发PORST；在11 01/S3 time out的时候，BM 也不会触发PORST；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/316d0e6f3034cef547a08cb9eedfaba9/" rel="bookmark">
			java基础笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基础 面向对象主要有四大特性 1、抽象
忽略一个主题中与当前目标无关的东西，专注的注意与当前目标有关的方面。(就是把现实世界中的某一类东西，提取出来，用程序代码表示，抽象出来的一般叫做类或者接口)。抽象并不打算了解全部问题，而是选择其中的一部分，暂时不用部分细节。抽象包括两个方面，一个数据抽象，而是过程抽象。抽象只关注对象有哪些属性和行为，并不关注这些行为的细节是什么。
数据抽象 --&gt;表示世界中一类事物的特征，就是对象的属性。比如鸟有翅膀，羽毛等(类的属性)
过程抽象 --&gt;表示世界中一类事物的行为，就是对象的行为。比如鸟会飞，会叫(类的方法)
2、封装
封装是面向对象的特征之一，是对象和类概念的主要特性。封装就是把过程和数据包围起来，对数据的访问只能通过已定义的界面。如私有变量，用set，get方法获取。封装就是隐藏一切可隐藏的东西，只向外界提供最简单的编程接口
封装保证了模块具有较好的独立性，使得程序维护修改较为容易。对应用程序的修改仅限于类的内部，因而可以将应用程序修改带来的影响减少到最低限度。
3、继承
继承为了重用父类代码，同时为实现多态性作准备。继承是从已有类得到继承信息创建新类的过程。提供继承信息的类被称为父类（超类、基类）；得到继承信息的类被称为子类（派生类）。继承让变化中的软件系统有了一定的延续性，同时继承也是封装程序中可变因素的重要手段。
4、多态
多态性是指允许不同子类型的对象对同一消息作出不同的响应。简单的说就是用同样的对象引用调用同样的方法但是做了不同的事情。多态性分为编译时的多态性和运行时的多态性。多态性语言具有灵活/抽象/行为共享/代码共享的优势，很好的解决了应用程序函数同名问题。总的来说，方法的重写，重载与动态链接构成多态性。java引入多态的概念原因之一就是弥补类的单继承带来的功能不足。
动态链接 --&gt;对于父类中定义的方法，如果子类中重写了该方法，那么父类类型的引用将调用子类中的这个方法，这就是动态链接。
面向对象五大基本原则是什么 单一职责
从字面意思其实就很好理解，只做一件事，不去多揽其他的事使自己烦心；单一职责原则可以看做是低耦合高内聚思想的延伸，提高高内聚来减少引起变化的原因。
开放封闭原则
在设计一个类或者一个模块，应该符合对外是可以扩展的，对修改时关闭的，这样的代码健壮性就很强，后续业务扩展增加新的需求也可以在保证现有代码不变的情况下实现扩展。
里氏替换原则
里氏替换原则对继承进行了规则上的约束，这种约束主要体现在四个方面：
1. 子类必须实现父类的抽象方法，但不得重写（覆盖）父类的非抽象（已实现）方法。
2. 子类中可以增加自己特有的方法。
3. 当子类覆盖或实现父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松。
4. 当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。
接口隔离原则
接口端不应该依赖它不需要的接口，一个类对另一个类的依赖应该建立在最小的接口上。
如果一个提供接口的类中对于它的子类来说不是最小的接口，那么它的子类在实现该类的时候就必须实现一些自己不需要的功能，整个系统就会慢慢变得臃肿难以维护。
依赖倒置原则
高层次的模块不应该依赖低层次的模块，他们都应该依赖于抽象抽象不应该依赖于具体实现，具体实现应该依赖于抽象 java三大特征 1、封装
2、继承
3、多态
JDK 6 新特性 JDK 7的新特性 JDK8 的新特性 什么是Java程序的主类？应用程序和小程序的主类有何不同？ 一个程序中可以有多个类，但只能有一个类是主类。在Java应用程序中，这个主类是指包含main()方法的类。
而在Java小程序中，这个主类是一个继承自系统类JApplet或Applet的子类。应用程序的主类不一定要求是public类，但小程序的主类要求必须是public类。主类是Java程序执行的入口点。
数据类型四类八种 数据类型包装类占用内存取值范围默认值整型byteByte1个字节-2^7 ~ 2^7-10 shortshort2个字节-2^15 ~ 2^15-10intInteger4个字节-2^31 ~ 2^31-10longLong8个字节-2^63 ~ 2^63-10L浮点型floatFloat4个字节（正数）1.4E-45 - 3.4028235E38 （整体） -3.4028235E38 ~ 3.4028235E380.0FdoubleDouble8个字节1.7976931348623157E308 ~ 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/316d0e6f3034cef547a08cb9eedfaba9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd4dd24a577cfefac51737a61754217b/" rel="bookmark">
			import _jpype ImportError: DLL load failed while importing _jpype: 动态链接库(DLL)初始化例程失败。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题报错：
import _jpype ImportError: DLL load failed while importing _jpype: 动态链接库(DLL)初始化例程失败。 解决方案：
必须将 import _jpype 放在第一行导入 放在其他行就会报错 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90080678b2bc769848cd017a328d110a/" rel="bookmark">
			杂七杂八的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 本文档记录本人遇到过问题，都是亲身经历，放心使用 Google浏览器无法翻译 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f82da10f4533f7401da87d93f1999c91/" rel="bookmark">
			宏观人脑功能网络的通用分类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		过去十年中，旨在描述人类连接组特征的研究的激增。这些项目使用非侵入性神经成像方法和先进的分析技术，绘制了大规模系统的大脑区域。虽然人脑是由多个宏观功能网络组成的这一观点在认知神经科学中得到了广泛的关注，但该领域尚未在术语方面的几个关键问题上达成共识。什么构成了一个功能性大脑网络?是否存在“核心”功能网络，如果有，它们的空间形状是什么?什么样的命名惯例?脑功能网络的分类能被描绘出来吗?在这里，我们调查了现有的研究，确定了六种常用的宏观脑网络命名方案和文献中使用的惯例，并在适当的地方突出了不一致和混淆点。我们提出了一个包含解剖学术语和认知学术语的方案。我们认为，随着网络神经科学领域的成熟，形成一种像这里提出的分类法将变得越来越必要，这种分类法可以在各个研究小组之间持续引用。本文发表在Brain Topography杂志。
1. 介绍
随着科学领域的成熟，它们通过采用标准化的术语而形式化。例如，在生物学中，界、门、纲、目、科、属和种等分类学范畴被普遍接受，并被用来交流新的研究成果。在成像神经科学中，标准化三维坐标系统的采用，如Talairach图谱和后来的蒙特利尔神经学研究所(MNI)图谱中使用的系统，为研究人员提供了一种方法，通过使用公共参考点比较不同研究的结果，彻底改变了神经成像。
网络神经科学这一新兴领域旨在通过研究大脑结构和功能网络来理解认知和行为背后的原理和机制。然而，理论的进步并不总是与这些方法的创新和成就同步。例如“大规模神经认知网络”的概念描述了服从认知和行为的神经结构，这一概念已经持续了近30年。然而，我们还没有对大规模神经认知网络的确切构成给出一个清晰的定义。由于缺乏一致的命名约定，当代网络神经科学是碎片化的。例如以下三个陈述：
“带状盖网络包括前额叶皮层、前岛叶/额叶岛盖、背侧前扣带皮层和丘脑”；
“岛叶前皮层被认为是突显网络的关键节点，该网络还包括背侧前扣带皮层和其他皮层下和边缘结构”；
“腹侧[注意]网络的核心区域包括颞顶结合部……和腹侧额叶皮层，包括额中回、额下回、额叶盖和前岛叶的部分区域”。
在所有这些情况中，作者都提到了一个包括前岛叶的功能性脑网络。在这三个例子中，作者使用了特定的术语来指代兴趣网络，并赋予它们不同的功能。当一个人试图整合跨多个实证调查的信息时，术语的传播尤其成问题。事实上，我们可以想象这样一个场景：研究人员可能会搜索调查前岛叶在腹侧注意网络中的作用的研究，但完全不知道使用其他网络术语的相关出版物。
当我们观察大规模的神经认知系统时，有复杂的动力学在起作用，很大程度上的共识被不同的网络特征所掩盖。我们首先简要调查了目前是如何定义脑功能网络的。我们探讨了在宏观尺度上有多少网络被认为是存在的问题，以及它们被认为的解剖结构和动态特性。最后，我们概述了一个建议的通用网络命名方案，或分类法的建议。
2. 功能性脑网络是如何定义的?大脑有多少功能网络?
神经科学的一个基本概念是对大脑区域的定义。脑区由其功能特异性、连通性、架构性和组织形状来定义。在定义大脑区域时，并不是所有的四个标准都符合。神经心理学家和认知神经科学家的大量努力已经描绘出了大脑许多区域的假定功能。相互连接的大脑区域形成了大规模的网络，在宏观尺度上可以观察到。构成一个功能网络的大脑区域之间连接的是典型的统计依赖性，如相关性或协方差。稳定的功能网络可能是由单或多突触的白质连接所支撑的。至关重要的是，组成网络的大脑区域的功能相互作用，包括网络内部和与大脑其他部分的相互作用，导致复杂行为的出现，这可能比每个区域单独的离散计算的相加更有可能。
在图论中，大脑网络的特征是由节点(大脑区域)和边(连接)组成。通过检查成对关联的模式和网络级别的属性，图论在描述大脑结构方面非常成功。然而，并不是所有的图，或以网络统计为特征的大脑网络都是相同的。研究大脑功能网络结构的一种常用方法是检查大小相近的皮层部分之间的功能连通性。然而，节点很少像上面定义的那样构成大脑区域。令人遗憾的是，许多与特定区域的功能相关的细粒度信息都丢失了，因为这些碎片在不考虑它们的任何相关功能或结构属性的情况下被分割并重新组合在一起。这里我们关注功能性脑网络，尽管在考虑结构属性时出现了节点和边缘定义的类似问题。
值得注意的是，不同的网络定义和节点选择过程可能会在文献中造成混淆。在网络构建过程中，大脑区域和特殊种子(感兴趣区域，ROI)选择的不同命名惯例会进一步导致网络神经科学文献中明显的不一致。
问题是大脑有多少功能网络?考虑到大脑网络结构固有的等级结构是不合适的。在神经科学中，组织是在多个层次的分析中观察到的。粗粒度和细粒度的网络都为网络分析提供了有效的解决方案。然而，独立成分分析(ICA)、任务功能磁共振成像的元分析和全脑分割研究为我们的主张提供了基础，即六个网络代表了建立分类法的合理起点。我们建议，该领域应该采用一种通用的命名法。
我们的建议集中在6个功能大脑网络上，它们在任务和静息状态fMRI研究中普遍存在。为了标准化，我们在这里称它们为枕部网络(ON)、中心周围网络(PN)、背侧额顶网络(D-FPN)、额顶外侧网络(L-FPN)、中扣带回-岛叶网络(M-CIN)和内侧额顶网络(M-FPN)(图1)。
图1 脑功能网络的分类。
蓝色的名字指的是广义认知领域。这里只描述了每个网络的1-2个核心节点。
我们提出的分类目前是以皮质为中心的。皮层下和小脑节点与我们讨论的每个网络都有明显的关联。在更高的分辨率下，这里识别的6个网络将分解为子系统。重要的是要记住，尽管时变分析可能揭示大脑区域与核心网络外区域的动态关联，但分块系统在更广泛的宏观网络内可能比在宏观网络之间显示出更大的功能关联。
3. 静息态功能连通性
使用一种被称为静息状态功能连接(RSFC)的方法，大规模的大脑网络已经被成功地描绘出来。该方法检查了静止时MRI测量的血氧水平依赖性(BOLD)信号的自发振荡的同步模式。一些最早使用RSFC来描绘宏观脑功能网络的研究使用了ICA。ICA是一种无模型的方法，它将神经成像数据集分解为一组独立的一维时间序列和相关的三维空间地图，这些地图描述了潜在信号的时间和空间特征。许多使用ICA的研究人员在发表的数据中通过字母或数字对衍生成分进行标记，同时推测文本中这些相干系统的可能功能解释。在实践中，网络的“命名”通常是研究人员的一个临时过程，他们可能会也可能不会根据与任务fMRI数据集中看到的激活模式的空间相似性来选择从静息状态fMRI数据中派生的网络。
重要的是，ICA的维度或网络数量可以由用户设置或从数据中估计。因此，不能孤立地使用ICA来确定大规模功能网络的绝对数量。然而，ICA对于生产由功能相连的大脑区域组成的数据驱动组件是有用的。当试图恢复宏观规模的功能网络时，研究人员通常选择低模型阶ICA(例如20个或更少的组件)，而不是高模型阶ICA(例如100个或更多的组件)。当目标是实现大脑打包或勾画出用于后续分析的ROI时，使用100个或更多成分。
Yeo等人提出了一种基于静息态fMRI数据的网络识别方案，该方案非常有影响力。Yeo和他的同事使用一种聚类算法将大脑皮层分成功能耦合的大脑区域网络。这里的假设和在类似静息状态fMRI分割工作中，皮质网络可以被定义为具有相似皮质-皮质功能连通性剖面的区域集合。他们继续检验衍生聚类的稳定性，以得到粗(7个网络)和细(17个网络)的解决方案。尽管如此，他们仍然谨慎地表示，对7和17网络解决方案的关注不应被视为暗示替代方案中缺乏有意义的特性。事实上，在同样的工作中，他们证明了多个网络解决方案表现出相似的稳定性水平，强调了这一点，即：通常没有一个正确的解决方案或网络的数量。
关于如何称呼这些网络的问题，作者们非常谨慎。虽然他们提供了与每个网络相关的常见名称，但在一个标题中，他们表示:“这并不意味着我们估计的网络与文献中的网络完全一致，也不意味着网络仅为与其指定名称相关的函数编码。作为启发式参考标签局限性的例子，紫色腹侧注意网络很可能是(或接近)多个网络的集合，在文献中被称为突显网络和带状盖网络网络，而红色默认网络可以被分割。”
类似的警告也可以在其他工作中看到。例如，Farrant和Uddin在他们的研究中指出，虽然一些研究人员认为腹侧注意网络和突显网络之间在功能和解剖学上高度重叠，作为它们是同一系统的一部分的证据，但其他人将这些网络概念化为不同的实体。这种类型的细微差别在广泛的网络神经科学文献中并不总是很明显。由于目前没有普遍接受的网络命名约定，研究人员继续在出版物中采用他们自己喜欢的命名法，导致了网络命名方案的更大不同。
4. 任务-激活和Meta分析
定义功能网络的另一种方法是检查任务共激活的模式，并通过元分析合并这些结果，以发现可靠的网络节点。第一个这样成功的元分析方法使得无处不在的内侧额顶神经网络的发现。在活跃的视觉任务中发现后扣带、下顶叶皮层、内侧前额叶皮层和其他区域的血流明显减少。直到后来，这一区域群才被描述为“默认”活动，随后在其关键节点之间显示出功能连接后被称为默认模式网络。该网络已被可靠地观察到在许多需要视觉空间注意力的任务中被抑制，并被称为“任务负性网络”。这种“否定任务”的命名方式掩盖了内侧额顶默认网络在许多认知形式中的积极作用。元分析证据表明，该网络参与记忆过程，如回忆，以及社会推理。然而，对认知的研究往往被孤立在离散的研究领域，一组共同的协同活动的大脑区域被命名为离散的认知功能，有限的交流和丰富的理解，这些看似不同的功能可能依赖于核心机制。例如：（1）“回忆—对过去事件的定性信息的检索—与一组一致的神经区域的增强神经活动有关……包括：海马体、角回、内侧前额叶皮层、后扣带皮层和中颞回”。（2）“由颞顶联合部、内侧前额叶皮层和楔前叶组成的心智系统，在对抽象的目标、信仰或道德问题做出推断时被激活”。（3）“专门用于语义知识存储和检索的神经系统广泛存在，在人脑皮层中占据了很大比例。参与这些过程的区域可以被分为三大类：后多式联合皮质(AG、MTG和梭状回)，具体的多式前额皮层特定亚区域(背侧、腹内侧和下前额叶皮层)，以及与海马形成有强烈联系的内侧边缘旁区域(海马旁和后扣带回)”。
在描述不同认知过程的同时，这三个例子中对应的功能神经解剖学都指向内侧额顶叶默认网络。与我们之前以前脑岛为中心的例子类似，对底层网络架构的通用命名法可以丰富这些系统的认知特征。该领域的一些不精确性可以用RSFC网络和任务共激活模式之间的不完全对应来解释。在许多情况下，静息状态网络似乎更广泛地分布在整个皮层，而任务诱发网络往往更受限制。基于这一观察结果的一种推测是，静息状态网络可能代表了大脑模式的全部功能库，从这些模式中，通过减去紧密匹配的控制条件，可以发现任务涉及区域的子集。诸如“认知图谱”和“认知范式本体论”等旨在系统地描述心理过程的项目提供了关键的经验数据，人们可以利用这些数据描绘任务诱发网络。值得注意的是，前面讨论的背侧额顶注意和内侧额顶默认网络大脑区域之间普遍存在的失活模式，可以使用这种元分析方法进行概括。
复杂的认知也可能唤起多个相互作用的网络。RSFC的区域间模式显示，侧额顶叶控制网络中的特定区域与内侧默认或背侧额顶叶注意网络在功能上更一致。这些观察结果与扩展的外侧额顶叶控制网络划分为子系统相一致，根据任务需求有不同的功能对应。
5. 脑功能网络的通用分类法概述
如上所述，网络神经科学这一新兴领域目前缺乏一致的网络分类法。这尤其有问题，因为它阻碍了与认知神经科学几十年来的发现成功对接。我们看到的唯一补救办法是正式提出一个与人类神经解剖学密切相关的共识命名法。该建议综合了RSFC MRI的观察结果，基于任务的fMRI的可靠功能共激活模式，以及可用的跨模态收敛。我们建议为六个由特定的核心脑区域组成的可靠宏观脑网络命名。对于每一种，我们都提供了一个主要的解剖学标签，以及一个必要的广泛的认知标签。我们强调解剖学网络标签的优先性。我们命名了组成每个网络的核心区域，并注意到其他大脑区域可能通过包括动态从属关系在内的过程参与任何给定的网络。
建议在未来，网络神经科学家和认知神经科学家应该尽可能地努力使用以下命名法，以便为其他对类似问题感兴趣的研究者提供一个共同的参考点。正如所讨论的，我们所描述的核心网络通常可以分成多个子系统，这些子系统可能尚未被完全描述或达成一致。出于简约的考虑，我们建议研究人员在进一步详细说明任何给定的一组发现在多大程度上保证使用额外的命名法来更完整地描述所观察到的网络结构之前，可以使用这里建议的广泛的解剖网络名称。
5.1 解剖学名称：枕部网络(ON) 认知领域：视觉网络
核心区域是枕叶，包括纹状体和纹外皮层(图2)。这个网络也可能包括丘脑的外侧膝状核。认知标签“视觉”被应用到这个网络，因为系统被稳健地观察到参与视觉处理。
图2 枕部网络。
（A）中部(120)、枕部(220)、外侧(320)视区。
（B）17个网络中的紫色和红色视觉网络。
（C）内侧(褐色)和外侧(蓝色)视觉网络
图2展示了枕部网络的几个例子。在寻找任务激活和ICA派生的静息状态网络之间的对应关系时，Smith和同事观察了三个对应于内侧、枕部和外侧视觉区域的地图。仅基于RSFC派生的片段为两种视觉网络(内侧和外侧)提供了证据。综上所述，这些分块研究为至少两个与ON（枕部网络）相关的子系统提供了证据，一个位于更中间的位置，与沿钙质沟的初级视觉皮层相关，另一个位于更侧向的涉及视觉处理的外纹区。
请注意，背侧和腹侧视流可能起源于枕部核心网络。这些流被称为视觉对象感知的“哪里”和“什么”路径。
5.2 解剖名称：中心神经网络(PN) 认知领域：躯体运动网络
中心区域是运动和躯体运动皮层，位于中央沟的前，后。中心周围神经网络的区域还包括并列小叶(补充运动区)(图3)。特征不太明显的区域包括颞上回的听觉皮层，在使用RSFC的研究中，听觉皮层通常被包裹在该网络中。由于该系统在运动过程和体感处理中有良好的记录，因此被称为“躯体运动器”。
图3 中心周围的网络。
A)感觉运动区域在20(左)和70(右)分量。
B) 7个网络中的蓝色网络。
C)手(浅蓝色)，脸(橙色)和脚(绿色)的身体运动中枢包含三个网络。另外一个被标记为听觉/运动前/顶叶记忆的网络也被包括在内。
至少有两个子系统可能与PN（中心神经网络）相关联。利用高阶ICA可以观察到左右分离，17个网络中部分网络出现了背侧(手)和腹侧(脸)子系统。在更高分辨率的MRI中，听觉和体感面部区域也可以分离。注意，PN是主要感觉和运动通路的皮层组成部分。
5.3 解剖学名称：背侧额顶叶网络(D - FPN) 认知领域：注意网络
核心区域包括延伸至顶内沟的顶上小叶、中颞复合体(MT+)和推定的前额眼动区(BA8)(图4)。背侧额顶神经网络还包括腹侧前运动皮层。特征较差的区域有：(1)右侧化的背外侧前额叶皮层、(2)上丘。
图4 背侧额顶叶网络。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f82da10f4533f7401da87d93f1999c91/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/698b6e9ffaeb300aac875f2644ad2aa7/" rel="bookmark">
			FastDFS安装笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		FastDFS安装笔记 0.环境准备 CentOS 7.5libfastcommon V1.0.43fastdfs V6.06fastdfs-nginx-module V1.22nginx 1.18.0 1.安装步骤 下载安装包 wget https://codeload.github.com/happyfish100/libfastcommon/tar.gz/V1.0.43 -O libfastcommon-1.0.43.tar.gz wget https://codeload.github.com/happyfish100/fastdfs/tar.gz/V6.06 -O fastdfs-6.06.tar.gz wget https://codeload.github.com/happyfish100/fastdfs-nginx-module/tar.gz/V1.22 -O fastdfs-nginx-module-1.22.tar.gz wget http://nginx.org/download/nginx-1.18.0.tar.gz 安装依赖 yum install -y gcc-c++ libevent pcre pcre-devel zlib zlib-devel openssl openssl-devel 安装 libfastcommon tar -zxvf libfastcommon-1.0.43.tar.gz # 进入安装目录 cd libfastcommon-1.0.43 # 编译、安装 ./make.sh ./make.sh install # 创建软链接 ln -s /usr/lib64/libfastcommon.so /usr/local/lib/libfastcommon.so ln -s /usr/lib64/libfastcommon.so /usr/lib/libfastcommon.so ln -s /usr/lib64/libfdfsclient.so /usr/local/lib/libfdfsclient.so ln -s /usr/lib64/libfdfsclient.so /usr/lib/libfdfsclient.so 安装 fastdfs tar -zxvf fastdfs-6.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/698b6e9ffaeb300aac875f2644ad2aa7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b09d605693e0229e6096c0ff6bf7901c/" rel="bookmark">
			VS客户端程序调用WCF出现由于计算机积极拒绝，无法连接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		"没有终结点在侦听可以接受消息的 http://XXX/services/BasicService.svc。这通常是由于不正确的地址或者 SOAP 操作导致的"
如不是endpoint配置的错误,检查,名称,命名空间都没有错误，dll的引用也没有错误
可能原因：web扩展服务,没有允许asp.net2.0验证
解决方案：
第一步：
win+r,运行cmd,输入"C:\WINDOWS\Microsoft.NET\Framework\v2.0.50727\aspnet_regiis.exe -i"
第二步：
注册完成,web扩展服务中允许asp.net2.0
第三步：
我的电脑 -&gt;右键 -&gt;管理 -&gt;服务和应用程序 -&gt;点击IIS
第四步：
找到aspnet_client，如果是文件的图标，右键，选择转换为应用程序，启用预加载，再点确认
变成应用程序的样子就好啦！
第五步：重启IIS，再去VS重行运行客户端程序就可以啦！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e22bc8b9a2bbcf499779f7db3dcad711/" rel="bookmark">
			Unity漫延的实现思路(流体漫延, 火烧草地的漫延等)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		↓首先这是Unity出了个Bug, 颜色混乱了
白色区域开始漫延, 当它遇到白球的时候, 会向两边分叉漫延.
这就很神奇.
颜色也会有碰撞吗?
我想实现这种效果, 于是去网上搜实现的方法, 没搜到.
那就自己模拟一个吧
用了1万个Cube
先上效果图:
上代码
主控制类:
using System.Collections; using System.Collections.Generic; using UnityEngine; public class Water : MonoBehaviour { public static Water instance; public Dictionary&lt;string, WaterCube&gt; dic = new Dictionary&lt;string, WaterCube&gt;(); void Awake() { instance = this; CreateAllCubes(); CreateDiedCubes(); //启动点 dic["0:0"].SetActive(); dic["50:90"].SetActive(); } //生成白色方块 void CreateAllCubes() { GameObject prefab = Resources.Load("Prefabs/Cube") as GameObject; for (int i = 0; i &lt; 100; i++) { for (int j = 0; j &lt; 100; j++) { WaterCube go = Instantiate&lt;WaterCube&gt;(prefab.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e22bc8b9a2bbcf499779f7db3dcad711/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fec09d4ae79d58c4db6ed423be9ef4d5/" rel="bookmark">
			C语言实现N个数中寻找最大值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、练习 要求输入N个数，找出其中的最大值，并输出。
比如N是5的时候，输入5个数：1 2 3 4 5，最大值是5。
二、思路 这个练习比较简单，基本思路就是用一个变量存储最大值，然后用户一边输入一边与这个最大值比较，大就更新它。
三、C程序参考代码如下： #include &lt;stdio.h&gt; #define LEN 5 int main() { int array[LEN] = {0}; int index = 0; int max = 0; printf("请输入5个整数: "); for(index = 0; index &lt; LEN; index++) { scanf("%d", &amp;array[index]); if(array[index] &gt; max) { max = array[index]; } } printf("最大值是: %d\n", max); system("pause"); return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07502e2c964271e54a180bdfb7ea5612/" rel="bookmark">
			生成迷宫的算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		规则 黑色为墙, 白色为路
以左下角为起点, 生成路
路能通过上下左右相邻的格子(斜着不能通过)
路不可环形相接
先上图 10X10的:
20X20的:
99X99的:
讲思路 从起点开始
看其上下左右4个邻居能不能变成路
怎么看?
先看能不能往上走:
首先, 上方得有格子,
且上方不是路,
且上上格子也不是路,
且左上格子也不是路,
且右上格子也不是路,
则, 能往上走
酱
依次看上下左右4个格子能不能走, 能走的加入neighbours
随机从neighbours选一个, 把她变成白色的路
再以她为起点, 再看其上下左右能不能走
依次执行
直到, 上下左右都不能走了, 则, 这个点是死路
从之前的活路中随机选一个点, 作为起点, 走
直到, 所有的路全部为死路
贴代码 using System.Collections; using System.Collections.Generic; using UnityEngine; public class Grid { public int x; public int y; private bool isRoad; public Transform tra; public bool IsRoad { get { return isRoad; } set { isRoad = value; if (isRoad) { tra.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/07502e2c964271e54a180bdfb7ea5612/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a6328a782ba65f7f9d2e51ac10179fd/" rel="bookmark">
			为金融而生的区块链Injective(INJ)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Injective背景 Injective 是 Binance Labs 2018 年第一期孵化的八个项目之一，已经获得了众多机构的支持，包括全球顶尖的加密货币风险投资公司之一 Pantera Capital。
Injective 的核心团队具有良好的职业背景，曾在国际知名企业如Open Zeppelin，亚马逊，对冲基金等具有工作经验。
团队核心成员毕业于纽约大学和斯坦福大学等知名院校，并且与顶尖的DeFi协议和底层公链如Elrond，Kava，Findora等建立了合作关系。
Injective 原生代币 INJ 于2020年10月通过 Launchpad 首发于Binance，是第一批交易黄金等大宗商品的DEX。
Injective简介 Injective 是一个开放、可互操作、且支持智能合约的区块链，支持 DeFi 类应用在其链上搭建。
Injective 基于 Cosmos-SDK 构建，利用 Ignite（前身为 Tendermint）权益证明共识机制来实现即时确定性的安全交易。作为以太坊 Layer-2 侧链解决方案，可将以太坊和其他更多 Layer-1 交易扩展到 Injective 链上。
Injective 提供了独特的即插即用模块，包括订单簿和衍生品交易模块，使任何开发人员都可以快速地启动有价值的金融应用。外加智能合约功能，能使开发人员轻松地使用领先的协议构建复杂的应用程程序。
Injective 是第一个为去中心化金融应用程序构建的定制互操作协议。任何人都可以使用基于以太坊的工具、快速的交易时间和即时确定性来创建新的 DApp，同时获得无与伦比的开发人员奖励。
原生代币INJ INJ 是 Injective 的原生功能型和治理代币，它在协议安全、对做市商和中继前端的激励、衍生品抵押等方面发挥着不可或缺的作用。
代币：INJ
现价：$2.69（2022-11-06）
发行总量：1亿枚
流通量：7300万枚流通
市值：2亿美元左右
市值排名：153
Injective生态 Injective Protocol的生态由三个部分组成：Injective链、Injective交易平台和Injective衍生品协议。
（1）Injective链
基于Cosmos zone，在Layer2发布，用于托管零信任、去中心化交易的时间戳证明协议；并且将使用Cosmos IBC协议，实现跨链交易。 （2）Injective交易平台
基于Injective链开发的完全去中心化交易平台，具有如下特点：杜绝提前交易，高速下单撮合，由节点维持去中心化订单薄并获取交易引入奖励，免费挂单和取消订单，无白名单交易，无需许可、公开公正的交易市场发行。 （3）Injective衍生品协议
是去中心化的点对点期货及永续掉期协议，可独立运行易于集成，各种交易市场皆可简单接入，自主市场发行，每个人都可以创建自己的「Bitmex」，支持套利、对冲、杠杆合约等金融衍生品。 Injective优势 用户友好的界面 Injective 改进了传统的 DEX 模型，以创建一个对新手和高级交易者都易于使用的协议。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9a6328a782ba65f7f9d2e51ac10179fd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/907076972c044a9d20bbafe1faec716b/" rel="bookmark">
			linux强制卸载mysql报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		error: Failed dependencies:
mysql-community-client(x86-64) &gt;= 8.0.11 is needed by (installed) mysql-community-server-8.0.31-1.el7.x86_64
[root@ mysql]# rpm -ev mysql-community-client-8.0.31-1.el7.x86_64 --nodeps --force
rpm: only installation and upgrading may be forced
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea2a2bb1cb29d39130f17e5a794f1964/" rel="bookmark">
			远程连接win10提示“登录没有成功”问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 系统前天突然崩掉了，重装系统之后简单设置了下允许被远程连接，还是一直无法被远程连接，百度的一堆方案比如修改组策略，启用防火墙远程入网规则等等都不行。
也不知道以前怎么可以直接被连接的，想着要不还是新创建一个管理员用户试试吧。打开用户设置之后发现有个功能选项叫“改用本地账户登录”。点了之后居然要重新设置账户密码，设置完之后我就可以被远程连接了！
回想一下，重装的时候只让我登录microsoft账号，登录了之后设置一个pin码。在命令行里输入query user显示我的用户名是邮箱前5位数字，填在远程桌面界面能回显我的微软账号真实名字（错误的用户名不会显示），我就一直认为我用户名没输错，密码自然只能是pin码。微软这块设计指定有点毛病。
正确的用户名会回显账户名字 错误的用户名只会是错的 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62454d130f5a9cad26f32e7f099531c3/" rel="bookmark">
			方法精讲---数量关系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 方法精讲—数量关系 1、代入排除法 2、倍数特性 （1）整除型 602=630-28（是7的陪数）
631=630+1（不是7的陪数）
（2）余数型 （3）比例型 3、方程法 （1）普通方程 （2）不定方程 a、奇偶性 b、倍数性（用多） c、尾数法 （3）不定方程组 a、未知数一定是整数 b、未知数不一定是整数 4、工程问题 （1）给完工时间型 （2）给效率比例型 （3）给具体单位型 （4）牛吃草型 出现排比句：马上想到牛吃草型
5、行程问题 （1）基础行程 使用条件：不同的速度，对应的路程一样
（2）相对行程 a、直线相遇 b、直线追及 c、环形相遇 d、环形追及 e、多次迎面相遇 f、流水行船 （3）比例行程 注意：
当题目说到什么时，一般用比例行程问题
6、经济利润问题 （1）基础经济 （2）分段计费 省了小李500块钱的从9折变成8折，从而省了50块钱
7、最值问题 （1）函数最值 （2）构造数列类 （3）最不利构造 8、排列组合与概率问题 （1）基础概念 （2）枚举法 （3）捆绑法 （4）插空法 （5）概率问题 9、容斥问题 （1）公式法 a、两集合容斥 b、三集合容斥 （2）画图法 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/22862929aac1e15ba579d86516828da1/" rel="bookmark">
			JSON使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.JSON的概述 JSON在线解析及格式化验证 - JSON.cn 这是json在线解析 网站 好使！！
1.什么是JSON JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。
JSON采用完全独立于语言的文本格式，就是说不同的编程语言JSON数据是一致的。JS原生支持JSON.
2.为什么会有JSON 在JSON出现之前，大家一直用XML来传递数据。因为XML是一种纯文本格式，所以它适合在网络上交换数据。
XML本身不算复杂，但是，加上DTD、XSD、XPath、XSLT等一大堆复杂的规范以后，
任何正常的软件开发人员碰到XML都会感觉头大了，最后大家发现，即使你努力钻研几个月，
也未必搞得清楚XML的规范。于是更简洁清晰的JSON格式应运而生。风靡全球。
3.JSON这种格式的特点 1:纯文本形式并具备简洁和清晰的层次结构。
2: JSON 具有“自我描述性”,易于人阅读和编写。
3:具有层级结构，易于机器解析和生成，可以有效地提升网络传输效率。
4:可以在js中直接解析。 2.前端中的JSON 前端js 自动可以解析 JSON 这里就不挨个写了！
JSON有几种存储格式？
两种，一种是对象形式存储数据，一种是数组形式存储数据。
1.对象格式：
对象格式: { "k1":obj,"k2":obj }
举例: { "name":"jack", "age":18, "wife":null }
语法：
1.对象可以包含多个 key/value（键/值）对。
2.key 必须是字符串，value可以是合法的 JSON 数据类型（字符串, 数字, 对象, 数组, 布尔值或 null）。
3.key 和 value 中使用冒号(:)分割。
4.每个 key/value 对使用逗号(,)分割。
2.JSON数组格式：
数组格式：[obj,obj,obj...]
举例: [ "tjtc", "it", "czzxxy" ]
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/22862929aac1e15ba579d86516828da1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/abfa8442a6e39a353a1f3d963b4b36b0/" rel="bookmark">
			编译报错：undefined reference to `TIFFReadDirectory@LIBTIFF_4.0‘解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、问题描述 自己的环境：Ubuntu18.04。
自己编译C++程序的时候，遇到如下报错：
/usr/lib/x86_64-linux-gnu/libopencv_imgcodecs.so.3.2.0: undefined reference to `TIFFReadDirectory@LIBTIFF_4.0' //usr/lib/libgdal.so.20: undefined reference to `TIFFLastDirectory@LIBTIFF_4.0' /usr/lib/x86_64-linux-gnu/libopencv_imgcodecs.so.3.2.0: undefined reference to `TIFFWriteEncodedStrip@LIBTIFF_4.0' /usr/lib/x86_64-linux-gnu/libopencv_imgcodecs.so.3.2.0: undefined reference to `TIFFIsTiled@LIBTIFF_4.0' //usr/lib/libgdal.so.20: undefined reference to `TIFFSwabArrayOfShort@LIBTIFF_4.0' //usr/lib/libgdal.so.20: undefined reference to `TIFFIsByteSwapped@LIBTIFF_4.0' //usr/lib/libgdal.so.20: undefined reference to `TIFFFlushData@LIBTIFF_4.0' //usr/lib/libgdal.so.20: undefined reference to `TIFFFreeDirectory@LIBTIFF_4.0' /usr/lib/x86_64-linux-gnu/libopencv_imgcodecs.so.3.2.0: undefined reference to `TIFFScanlineSize@LIBTIFF_4.0' //usr/lib/libgdal.so.20: undefined reference to `TIFFWriteEncodedTile@LIBTIFF_4.0' //usr/lib/libgdal.so.20: undefined reference to `TIFFWriteBufferSetup@LIBTIFF_4.0' //usr/lib/libgdal.so.20: undefined reference to `TIFFTileSize@LIBTIFF_4.0' /usr/lib/x86_64-linux-gnu/libopencv_imgcodecs.so.3.2.0: undefined reference to `TIFFRGBAImageOK@LIBTIFF_4.0' /usr/lib/x86_64-linux-gnu/libopencv_imgcodecs.so.3.2.0: undefined reference to `TIFFClose@LIBTIFF_4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/abfa8442a6e39a353a1f3d963b4b36b0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea0cb15d0f191a7eba62cf1086335ee0/" rel="bookmark">
			银行家算法（死锁避免）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
死锁
银行家算法 例：
死锁检测 死锁解除
死锁 计算机系统中有许多互斥的临界资源（如打印机）或者软件资源（如进程表，临界区），如果两个或多个进程同时争取一个资源，或者同时进入临界区必然会出现问题。所谓死锁，就是指两个以上的进程相互要求对方已经占有的资源导致无法运行的现象。
产生死锁的四个必要条件：
互斥条件
请求保持条件
不可剥夺条件
环路条件
银行家算法 银行家算法对于进程发出的每一个系统可以满足的资源请求命令并检测，如果发现分配资源后系统进入不安全状态（系统能按照某种顺序对每个进程分配资源，直到达到最大需求，可使每个进程都顺序完成），则不分配；若分配后处于安全状态，则实施分配。
例： 死锁检测 解决死锁的另一条途径是死锁检测，这种方法对资源分配不限制，允许死锁产生，但系统会定时地运行一个死锁检测程序，判断系统是否发生死锁，若检测有死锁，则设法加以解除。
死锁解除 资源剥夺法：从一些进程中强行剥夺足够数量的资源分配给死锁进程。
撤销进程法：根据某种策略逐个地撤销死锁进程，知道解除死锁。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7fd805b303088bedcbb2903041d58f8/" rel="bookmark">
			C&#43;&#43;多态之虚函数表详解及代码示例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言 C++相对其他面向对象语言来说，之所以灵活、高效。很大程度的占比在于其多态技术和模板技术。C++虚函数表是支撑C++多态的重要技术，它是C++动态绑定技术的核心。
如果对多态还不了解的小伙伴，可以点这里C++多态详解基础篇。
在不考虑继承的情况下，如果一个类中有虚函数，那么这个类就有一个虚函数表，这个虚函数表在编译期间确定，这个类对象共享。而这个类所有的实例化对象中都有一个虚函数指针，这个虚函数指针就指向同一份虚函数表。
一、多态的使用及内存分布图 假设现在有个基类的class A，A中有虚函数，class B继承了A，并且B重写了A中的虚函数。那么，我们在使用多态的时候，通常会有两种方式：
// 方式一 class A* a = new class B; // 方式二 class B b; class A *a = &amp;b; 上面两种方式，都是用父类的指针指向了子类的对象。区别在于，方式一的子类对象是new出来的，存在于堆区；方式二的子类对象则保存在栈区。
二、多重继承的虚函数表 2.1 代码示例 class A { public: void func1(){ std::cout &lt;&lt; "Class A func1" &lt;&lt; std::endl; } void func2(){ std::cout &lt;&lt; "Class A func2" &lt;&lt; std::endl; } virtual void v_func1(){ std::cout &lt;&lt; "Class A v_func1" &lt;&lt; std::endl; } virtual void v_func2(){ std::cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a7fd805b303088bedcbb2903041d58f8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e4a6fc07372a09d54d923d3f8e04cf5/" rel="bookmark">
			【测试面经】软件测试面试题大全，软件测试必问必背面试题，敢说会70%就可以轻松拿offer......
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录：导读 前言一、测试面试基础题二、测试实战面试题三、测试基础知识点四、总结 前言 大部分人学软件测试的从业者，在找工作的同时，会因为软件测试面试题挡在门前。
……跳槽最重要的一步自然是面试，正值跳槽季，网上出现了各种面试题，一时会让人眼花缭乱，分不清最该看哪个，所以为大家做了一些软件测试面试的真题，想跳槽的小伙伴们，请准备好你的小本本！
一、测试面试基础题 1、简述测试流程？
2、什么是软件测试？软件测试的目的与原则？
3、软件生存周期及其模型是什么？
4、什么是软件质量？
5、自动化测试脚本开发的主要步骤？
6、目前主要的测试用例设计方法是什么？
7、常见的测试用例设计方法都有哪些?请分别以具体的例子来说明这些方法在测试用例设计工作中的应用？
8、测试的策略有哪些?单元测试的策略有哪些？
9、正交表测试用例设计方法的特点是什么？
10、软件的安全性应从哪几个方面去测试？
11、需求测试的注意事项有哪些？
12、你在测试中发现了一个 bug ，但是开发经理认为这不是一个 bug ，你应该怎样解决？
13、给你一个网站，你如何测试？
14、一台客户端有三百个客户与三百个客户端有三百个客户对服务器施压，有什么区别?
15、软件的安全性应从哪几个方面 去测试？
16、软件质量保证体系是什么 国家标准中与质量保证管理相关的几个标准是什么? ? 他们的编号和全称是什么?
17、测试人员在软件开发过程中的任务是什么？
18、在您以往的工作中，一条软件缺陷（或者叫 Bug）记录都包含了哪些内容？如何提交高质量的软件缺陷（Bug）记录？
19、黑盒测试和白盒测试是软件测试的两种基本方法，请分别说明各自的优点和缺点？
20、什么是系统瓶颈？
手机APP测试
21、什么是并发？在lordrunner中，如何进行并发的测试？集合点失败了会怎么样？
22、详细的描述一个测试活动完整的过程？
23、在您以往的工作中，一条软件缺陷（或者叫 Bug ）记录都包含了哪些内容？如何提交高质量的软件缺陷（ Bug ）记录？
24、您认为在测试人员同开发人员的沟通过程中，如何提高沟通的效率和改善沟通的效果？维持测试人员同开发团队中其他成员 良好的人际关系的关键是什么？
25、软件测试项目从什么时候开始？为什么？
26、测试结束的标准是什么？
27、您是否了解以往所工作的企业的软件开发过程？如果了解，请试述一个完整的开发过程需要完成哪些工作？分别由哪些不同的角色来完成这些工作？您在以往的测试工作中都曾经具体从事过哪些工作？其中最擅长哪部分工作？
28、请你回答一下性能测试有哪些指标，对一个登录功能做性能测试，有哪些指标，怎么测出可同时处理的最大请求数量？
29、什么是兼容型测试？兼容性测试侧重哪些方面？
30、软件测试项目从什么时候开始？为什么？
二、测试实战面试题 1、我现在有个程序，发现在Windows上运行的很慢，怎么判别是程序存在问题还是软硬件系统存在问题？
2、一个程序有n个变量采用边界值分析可以产生几个测试用例？
3、请设计一个关于ATM自动取款机的测试用例？
4、如何测试一个 纸杯？
5、我手上这支笔，请你根据这支笔设计测试用例？
6、测试手机开机键？
7、如何回答登录功能怎么进行测试？
8、如何回答京东购物车功能怎么进行测试？
9、支付流程测试？
10、对于有系统大量并发访问，你会如何做测试，有什么建议？
11、请对这个系统做出测试用例：一个系统，多个摄像头，抓拍车牌，识别车牌，上传网上，网上展示？
12、请你说一说PC网络故障，以及如何排除障碍？
13、微信红包？
14、微信发朋友圈点赞？
15、如何对淘宝搜索框进行测试？
16、就linux下的CP命令设计测试用例？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e4a6fc07372a09d54d923d3f8e04cf5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5423eec4833d7950d1a80e5d98ba2e06/" rel="bookmark">
			C语言 完美立方
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 完美立方等式： a 3 = b 3 + c 3 + d 3 a^3=b^3+ c^3 +d^3 a3=b3+c3+d3 为完美立方等式，如 1 2 3 = 6 3 + 8 3 + 1 0 3 12^3=6^3+ 8^3 +10^3 123=63+83+103。
编写一程序，对任意给定的正整数N（N&lt;=100),寻找所有的1-N之间的四元组(a,b,c,d)。其中1&lt;a,b,c,d&lt;=N。 b,c,d由小到大排列。
#include&lt;stdio.h&gt; #include&lt;math.h&gt; int main() { int a,b,c,d; int n; printf("请输入一个正整数(&lt;100):"); scanf("%d",&amp;n); printf("1--%d完美立方等式有：\n",n); for(a=2;a&lt;=n;a++){ for(b=2;b&lt;a;b++){ for(c=b;c&lt;a;c++){ for(d=c;d&lt;a;d++){ //pow返回是浮点型有误差，直接判断会导致不等，所以要四舍五入取整 if(round(pow(a,3))==round(pow(b,3)+pow(c,3)+pow(d,3))) { printf("[%d, %d, %d, %d]\n",a,b,c,d); } } } } } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad72f098334a23916cf0afe9246971c9/" rel="bookmark">
			总结Python读取TIF影像的几种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：文章写完后，目录可以自动生成，如何生成可参考右边的帮助文档
文章目录 导入模块TIF文件路径方法1:tiffile方法2:PIL方法3:opencv方法4:gdal方法1方法5:gdal方法2 总结Python读取TIF影像的几种方法 导入模块 import numpy as np import tifffile as tf #tifffile是tiff文件的读取库 from PIL import Image import cv2 as cv import gdal TIF文件路径 path = r'C:/Users/HP/Desktop/tif/jpeg2000/Test_Images/tif/boat4_2100.tif' 方法1:tiffile img_tf = tf.imread(path) print(img_tf.shape) #(2960, 1976, 3) 方法2:PIL img = Image.open(path) #可以读取单通道影像,读取3通道16位tif影像时报错(PIL.UnidentifiedImageError: cannot identify image file),支持4通道8位影像 arr = np.array(img) print(arr.shape) 方法3:opencv #arr = cv.imread(path,cv.IMREAD_UNCHANGED) #(2960, 1976) arr = cv.imread(path,1) #(2960, 1976, 3) 备注：4波段的影像在opencv的读取方式中，显示为前三个波段，而且读取顺序为BGR print(arr.shape) 方法4:gdal方法1 dataset = gdal.Open(path) arr = dataset.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ad72f098334a23916cf0afe9246971c9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b931939f417006d95003acc63e6e62a5/" rel="bookmark">
			蓝桥杯的一些技巧
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.判断1-2022中2的个数
用编译器把它打印出来 赋值到word文档使用替换功能
2.闰年的判断
if((x%4==0&amp;&amp;x%100!=0)||x%400==0) 3.int类型能表示的最大数为2147483627 2.14*10^9
short int能表示最大数为32767 4. 输入double类型 必须用lf 防止精度丢失
输出double类型 可用f 输出精度会在函数内处理并不会丢失
5. 小数四舍五入时 double a=3.6
a=(int)(a+0.5)
输出一个数+%并且小数点保留0位 printf("%.0f%%",c); 6. 任何数和0做异或还是任何数
7. printf("%03d",n); n的位数大于等于3位 全部输出 不够三位前面补0
printf("%3d",n); n的位数大于等于3位 全部输出 不够三位前面补空格
8. 数组过大时定义为全局变量 否则容易运行不出结果
9. printf("%g",num); %g小数点右侧的尾数0不被显示
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b099079b5887093ba6b39af4e1f01b2a/" rel="bookmark">
			拯救者Y9000P 2022 ubuntu18.04问题总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 2022年5月底买的拯救者Y9000P 2022，先用ubuntu虚拟机撑了一个多月。
由于虚拟机比较卡、对硬件兼容性差等原因，决定安装双系统。
我是在外接固态硬盘上安装了ubuntu18.04。
但是装完后发现声卡、蓝牙、wifi都用不了，因为内核版本太旧电脑太新，这些驱动没有；
后来直接装了ubuntu22.04，声卡、蓝牙、wifi都能用了，但是发现只能安装ROS2（ROS官方目前只在ubuntu22.04上放了ROS2）
考虑了很久-_-还是装回了ubuntu18.04。。。
一、声音、蓝牙、WIFI. 解决没有蓝牙问题 蓝牙可以用外接蓝牙发射器，我目前暂时用不到。
解决没有声音 笔记本连一个外接显示器，有线耳机插外接显示器上就有声音了。
解决没有wifi问题 可以外接无线网卡或者连接有线网。
二、突然黑屏 今天在用ubuntu的时候突然黑屏了，屏幕上只有/dev/sda2：clean，***files,***blocks
解决方法 1.按ctr+alt+F3进入命令行模式，输入用户名密码
2.输入reboot
重启后就好了
总结 2022.10.29安装了ubuntu20.04，声音、蓝牙、无线都能正常使用了，推荐安装20.04。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38b63ef52089facb40fa2d511428bfad/" rel="bookmark">
			抽象类和抽象方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		抽象方法：将共性方法抽取到父类之后，由于子类执行内容不同，所以在父类中不能确定具体方法，该方法定义为抽象方法。
抽象类：类中存在抽象方法的类声明为抽象类。
注：1，抽象类不一定有抽象方法，但有抽象方法的类一定是抽象类；
2，抽象类不能创建对象；
3，抽象类可以有构造方法；（为什么不能创建对象还要构造方法？答：为创建子类对象时给共有属性赋值）；
4，抽象类的子类：①要么是抽象类（依旧不可创建对象），②要么重写抽象类中的所有抽象方法。
青蛙frog 属性：姓名，年龄 方法：吃虫子，喝水
狗Dog 属性：姓名，年龄 方法：吃骨头，喝水
山羊Sheep 属性：姓名，年龄 方法：吃草，喝水
测试类：
public class Main { public static void main(String[] args){ Dog d=new Dog("小灰灰",1); frog f=new frog("小小绿",1); Sheep s=new Sheep("喜羊羊",10); d.eat(); d.drink(); System.out.println("----------"); f.eat(); f.drink(); System.out.println("----------"); s.eat(); s.drink(); } } javabean类
public abstract class Animal { private String name; private int age; public Animal() { } public Animal(String name, int age) { this.name = name; this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/38b63ef52089facb40fa2d511428bfad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6f0b21673ae34e7e5f3e67c711d3446/" rel="bookmark">
			驱动 | Linux | NVMe - 1. 内核驱动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文总结 NVMe 的 Linux 驱动是如何实现的。
Update: 2022 / 11 / 2
系列文章 驱动 | Linux | NVMe - 1. 内核驱动 系列文章总览NVMe 命令PCI 总线注册和初始化驱动创建 NVMe 块设备硬件层面软件层面 NVMe 设备的 IO 流程DMA参考链接 总览 NVMe (Non-VolatileMemory express)，是一种建立在 M.2 接口上的类似 AHCI 的一种协议，是专门为闪存类存储设计的协议。
NVMe 具体优势包括：
性能有数倍的提升；可降低延迟超过50%；NVMe PCIe SSD 可提供的 IOPs 十倍于高端企业级 SATA SSD ;自动功耗状态切换和动态能耗管理功能大大降低功耗；支持未来十年技术发展的可扩展能力。 码农该怎么理解？——
问：它是一个存储协议，既然是存储协议是不是需要快速的读写？
答：对。 PCIe 才是最快的协议啊，为啥不用 PCIe 呢？
答：PCIe 很复杂的。 问：那我们给 PCIe 穿个马甲，就可以？
答：NVMe 就是给 PCIe 穿个马甲。 问：NVMe 是怎么做到的？
答：PCIe 是作文题，NVMe 是选词填空，最后的结果却一样。 问：怎么填？填什么？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f6f0b21673ae34e7e5f3e67c711d3446/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/124/">«</a>
	<span class="pagination__item pagination__item--current">125/321</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/126/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>