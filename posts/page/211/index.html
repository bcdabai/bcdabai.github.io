<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67d4300879fd4ec43fd220cc580fac8e/" rel="bookmark">
			hadoop 9000端口只能本地127.0.0.1访问解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		伪分布式模式下
https://www.aboutyun.com/thread-6839-1-1.html
将core-site.xml中的localhost改为本机名即可
原来那样配置是单机伪分布模式，只能本机访问
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9259edfd06e7fff3bafda97e599176d8/" rel="bookmark">
			js解leetcode(81)-中等
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.多边形三角剖分的最低得分 题目：
给定 N，想象一个凸 N 边多边形，其顶点按顺时针顺序依次标记为 A[0], A[i], ..., A[N-1]。
假设您将多边形剖分为 N-2 个三角形。对于每个三角形，该三角形的值是顶点标记的乘积，三角剖分的分数是进行三角剖分后所有 N-2 个三角形的值之和。
返回多边形进行三角剖分后可以得到的最低分。
思路：动态规划，可让dp[i][j]为第i个点到第j个点的三角形剖分的和，所以有
dp[i][j] = max(dp[i][j], nums[i] * nums[j] * nums[k] + dp[i][k] + dp[k][j])，其中k为i和j中的一点
时间复杂度O(n3)，空间复杂度O(n2)
/** * @param {number[]} values * @return {number} */ var minScoreTriangulation = function(nums) { const n = nums.length; const dp = new Array(n).fill("").map(() =&gt; new Array(n).fill(Infinity)); for (let i = 0; i &lt; n - 1; i++) { dp[i][i + 1] = 0; } for (let d = 2; d &lt; n; d++) { for (let l = 0; l &lt; n - d; l++) { const r = l + d; for (let i = l + 1; i &lt; r; i++) { dp[l][r] = Math.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9259edfd06e7fff3bafda97e599176d8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5fe5a582b8c6b88e10af7a570aa4b987/" rel="bookmark">
			oracle11g r2 64 补丁,新装Oracle 11gR2 11.2.0.2重要说明——Patchset p10098816（附补丁下载地址）...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		新装Oracle 11gR2 11.2.0.2重要说明——Patchset p10098816(附补丁下载地址)
Attention：new installation of Oracle 11.2.0.2
以往安装Oracle 10.2.0.4或者10.2.0.5的时候，需要先安装10.2.0.1，然后在10.2.0.1的ORACLE_HOME路径下再安装patchset p6810189升级到10.2.0.4，或patchset p8202632升级到10.2.0.5，这种称为In-place Upgrade。
从11.2.0.2开始的补丁包p10098816为完全安装包(full installation package)，因此新装11.2.0.2的话，不需要先安装11.2.0.1，而是可以直接安装11.2.0.2；而对于原先已有11.2.0.1或者11gR1，需要升级到11.2.0.2的，则有Out-of-place和In-place两种方式，Oracle推荐采用Out-of-place。
Oracle官网上的内容如下：2010 年 9 月 13 日： 上现已提供适用于 Linux 的补丁集 11.2.0.2。注意：这是一个完整安装(无需先下载 11.2.0.1)。详细信息请参见(需要登录到 My Oracle Support)。
另有说明如下：
Important Changes to Oracle Database Patch Sets Starting With 11.2.0.2 [ID 1189783.1]
摘录如下：[@more@]
新装11.2.0.2：
Simplified new installation: Because the release 11.2.0.2 patch set is a full installation package, if you are installing Oracle Database on a system without an existing Oracle Database installation, then you can simply install the release 11.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5fe5a582b8c6b88e10af7a570aa4b987/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5145b66c54e39823d1ed0bd6a6a21b8a/" rel="bookmark">
			oracle数据库sys用户登录,Oracle SYS用户远程登录管理数据库的三要素
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		OS：CentOS 6.5 x64
Oracle：Oracle 11g x64
1. remote_login_passwordfile
参数remote_login_passwordfile为EXCLUSIVE。
SQL&gt; show parameter remote_login_passwordfile
NAME TYPE VALUE
------------------------------- ----------- ------------------------------
remote_login_passwordfile string EXCLUSIVE
2. 密码文件
密码文件存在，且SYS密码正确。
SQL&gt; select * from v$pwfile_users;
USERNAME SYSDB SYSOP
------------------ -------- -----
SYS TRUE TRUE
3. 静态注册
在监听中静态注册。
SID_LIST_LISTENER =
(SID_LIST =
(SID_DESC =
(GLOBAL_DBNAME = cat)
(ORACLE_HOME = /oracle/product/12.1.0.1.0/database)
(SID_NAME = cat)
)
)
4. 测试结果
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a5ca60f2a586ba5e1a20b96ae8b085b/" rel="bookmark">
			多角度对比数据中心常见的三种走线方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		01 三种走线方式的施工图片
▽下走线（地板下走线）
▽天花吊顶上走线
▽机柜顶部走线
02 三种走线方式对比
通过上面的比较，毫无疑问，机柜顶部走线模式是最有优势的，给用户带来很多好处，包括维护方便、扩容方便等、安全可靠等。
对于机柜顶部走线模式，如果使用名牌厂商的标准机柜，可以免工具安装各种组件。如遇到非标准机柜，高度不一致，有好几种办法可以解决。
第一种，定做机柜走线槽，保持和标准机柜安装走线槽后高度平齐。
第二种，如果非标准机柜高度差的太多，不适合机柜顶部走线，可以采取从旁边的机柜借用线缆的办法。线缆可以从地板和机柜底部之间的空隙敷设并上行进入机柜。
资料免费送（点击链接下载）
史上最全，数据中心机房标准及规范汇总（下载） 数据中心运维管理 | 资料汇总（2017.7.2版本） 加入运维管理VIP群（点击链接查看）
《数据中心运维管理》VIP技术交流群会员招募说明
扫描以下二维码加入学习群
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4bf77c78d6cb24105a9636780174f68a/" rel="bookmark">
			gitflow 是什么，有哪些优缺点？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		gitflow 是什么，有哪些优缺点？ 1. 什么是git2. git的优点3. GitFlow 协同工作流3.1 GitFlow的由来3.1 GitFlow中分支角色们3.2 GitFlow的优点3.3 GitFlow的缺点 总结 1. 什么是git Git是一个分布式的版本管理工具，它分为远程仓库（云端仓库，存在后端服务器中）（仓库：repository简写repo：）和本地仓库。本地和云端的仓库的维护机制是类似的，它们都是使用一个类似一个树形结构的数据结构来维护的。每次的文件内容的改变都是一个节点(blob节点)，每个commit都是一个tree节点，节点中附带代码的操作信息和节点类型。详见：传送门。
2. git的优点 git 是分布式的，有本地分支管理功能，所以，就算没有网络也可以进行本地的维护。git的每个变动都是一个节点因此，每次的文件内容的变动都可以单独保存并且可以逐个的进行应用管理。在所有代码合并后也可以看到所有变更内容，而其他的版本管理工具则不可以。由于git每次的变更都会生成一个完整的文件快照，所以它非常快。用空间来换取时间。由于git会面临内存问题，它有自己的内存维护机制比如：删掉无用的节点，压缩打包历史记录等…git有非常多的命令，可以灵活的使用。详见：传送门 3. GitFlow 协同工作流 其实GitFlow并非什么技术，而是一种代码开发合并管理流程的思维模式或者是管理方法。大家一起开发的一种软约定。
3.1 GitFlow的由来 我们为什么需要GitFlow这种git管理流程？原因有以下几点
有一个稳定版本的代码分支，可以安心的用在线上发布。在代码提测前或者说是代码达到预发状态时，在测试交付的过程中程序员们还可以继续进行下一个版本的开发工作（挤出每一秒去开发-_-’’）。有个一个分支可以让我们及时的对线上的bug进行修复，这个过程中我们不希望将正在开发中的代码提交到线上生产中去。 由于上述开发过程中面临的需求，GitFlow协同国祚流应运而生。对应的点就是
代码共享不同环境下代码互不干扰管理好代码与环境的一致性 3.1 GitFlow中分支角色们 Master 分支： 稳定版本代码分支，用作发布环境，上面的每次提交都是可以发布的。Feture 分支： 功能分支，用于开发功能（需求），用于开发环境Developer 分支: 开发分支， 一旦Feture分支内功能开发完成就将Feture中的代码合并到Developer分支中，合并完成后，删除该功能分支。这个分支对应的是集成测试环境。Release 分支：预发分支，做发布前的准备工作，对应的是预发环境。这个分支可以确保们开发继续向前，不会因为要发布不而被停滞住。一旦Release分支达到了可发布的状态，我们需要把Release分支同时向Master，Developer分支上合并，保持代码的一致性，然后把Release分支删除。Hotfix 分支： 线上bug修缮用的分支，每次修改线上代码的bug时都要用hotfix来维护，完成后向Developer和Master同时合并。完成后删除分支。 以上就是GitFlow中所有角色分支，从中我们可以看到以下几点：
Master和Developer需要我们长期维护，也是我们开发的主干线。其中relesase和hotfix两个分支的操作会很零碎，操作起来会比较麻烦，在这个过程中很容易产生失误，导致代码不一致。所以我们需要一个号的工具或者脚本来完成此步骤。这个套流程虽然麻烦，但是他可以应用到几乎所有的开发流程中：瀑布型，敏捷性（waterfall，agile） 3.2 GitFlow的优点 适应场景多不影响开发进度分支使用相对有条理确保线上的版本稳定 3.3 GitFlow的缺点 当然GitFlow并不是完美的，这只是种管理思维，一下是他的一些缺点：
因为分支态度，所以会出现git log混乱的局面：主要是因为git-flow使用git merge --no-ff来合并分支，在git-flow这种多分支的环境下会让整个项目的log变的非常混乱。 对于整个中情况我们可以：只有feature合并到developer分支时， 使用-no-ff参数，其他的合并都不使用–no-ff
** 什么是 git merge --no-ff：
--no-ff指的是强行关闭fast-forward方式。 fast-forward方式就是当条件允许的时候，git直接把HEAD指针指向合并分支的头，完成合并。属于“快进方式”， 不这种情况如果删除分支，则会丢失分支信息。因为在这个过程中没有创建commit git merge --squash 是用来把一些不必要commit进行压缩，比如说，你的feature在开发的时候写的commit很乱， 那么我们合并的时候不希望把这些历史commit带过来，于是使用--squash进行合并，此时文件已经同合并后一样了, 但不移动HEAD，不提交。需要进行一次额外的commit来“总结”一下，然后完成最终的合并。 总结： --no-ff：不使用fast-forward方式合并，保留分支的commit历史 --squash：使用squash方式合并，把多次分支commit历史压缩为一次 同时维护Master和Developer两个分支很多时候是没必要的，因为在很多场景下Master中的内容和Developer中的内容是差不多的。尤其当你想回滚某些人的提交时，你就会发现这事似乎有点儿不好干了。而且在工作过程中，你会来来回回地切换工作的分支，有时候一不小心没有切换，就提交到了不正确的分支上，你还要回滚和重新提交，等等。 总结 这么看下来GitFlow还是不错的，毕竟他的应用场景比较全面，确实解决了开发时分支混乱的问题，而且为我们提供了代码分支管理的策略和思维。但是它也并不是完美的。我感觉像这种分支管理的规范只是万千分支管理策略中的一种，我们完全可以自己去对它进行修改和调整找到适合自己团队的管理策略。在找寻自己策略时我们可以参考一下几点：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4bf77c78d6cb24105a9636780174f68a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7e96cd0c98bc13c7a96d5f66226eadd/" rel="bookmark">
			清华裴丹：AIOps九大发展趋势
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		清华裴丹：AIOps九大发展趋势 在8月28日必示科技主办的2019智能运维技术应用大会上，清华大学计算机系裴丹教授作了题为《智能运维（AIOps）趋势解析》的精彩报告。
裴丹教授是清华大学计算机系长聘副教授、青年千人、博士生导师、美国UCLA博士、ACM和IEEE的资深会员、美国AT&amp;T研究院前主任研究员。其主要研究方向是基于机器学习的智能运维（AIOps），与国内大型金融机构及互联网公司有众多合作，并在智能运维领域发表了100余篇学术论文和20多项美国专利授权。
以下是裴丹教授报告全文整理：
各位嘉宾下午好！大家知道，运维是数字世界的的基础设施级别的技术。随着支撑数字世界的软硬件系统越来越庞大、越来越复杂，运维对智能化的要求就会越来越高。所以我们说，AIOps（智能运维）是运维技术发展必然的趋势。
AIOps在国内正式提出来到现在的实际落地有两三年了，也取得了初步的落地效果。**那么下一步到底怎么做？做什么？未来几年内能进一步达到什么样的效果？**今天我就分享下我最近总结出来的AIOps发展九大趋势。
做趋势预测是有很大挑战和风险的，好在我之前在AIOps领域还有过成功的预测。
我在2018年1月曾给出一个AIOps宏观预测：我说2018年将是AIOps在中国落地的元年，而据我所知在2018年的确有小几十个AIOps项目开始落地，也就是说我的这个预测的确成为了现实。2019年1月我说2019年是AIOps快速发展的一年，而实际上截止2019年8月份在国内有大几十个AIOps项目开始推进；与此同时，我们看到2019年初的时候人行以及各大银行也发文阐述支持AIOps方向。
我在AIOps具体技术上也有个算是成功的预测。2018年中的时候我已经在公开演讲中讲AIOps平台化这个概念了；之后在2018年底，Gartner的报告也基于与世界范围内的客户和厂商的访谈正式提出了AIOps平台化这一方向。
下面这幅图的左下部分是我的团队给出的AIOps平台架构，该图的右下部分是2009年我在AT&amp;T工作时做的智能运维平台的架构，可以看出两幅图在概念上是非常相似的。所以，从这个例子大家可以看出，我能够先于Gartner提出AIOps平台的概念，不是因为真有什么能看到未来的“水晶球”，而是因为我之前在其它场景下做过类似工作，并且在AIOps方向不断努力推进。当我看到需求到了，相关条件成熟了，自然而然就能判断应该做AIOps平台了。所以，所谓的预测能力无非是经验的积累、不断观察、思考，最重要的是不断的亲手实践，就像林肯和图灵奖得主Alan Kay（面向对象编程语言的发明者）所言，预测未来最好的方法就是亲手创造/发明这个未来。
下面我总结一下基于经验、访谈、观察、思考和实践得出的AIOps发展九大趋势，即行业多样化、产业生态化、数据多样化、场景多样化、场景精细化、算法服务化、技术平台化、落地加速化、成熟度评估的加速化。
**第一个趋势就是AIOps落地的多样化，这个结论是基于我通过多种渠道采集到的信息。**我们自己有一个公众号“智能运维前沿”，马上要突破10000个用户了；我们还有一个超过千人AIOps群，已经成功举办了两届AIOps 挑战赛，我一年中会到几十家各行各业机构去进行现场交流。从上述多种渠道采集到的信息清楚表明：现在开始落地AIOps的，除了互联网公司、银行以外，证券、保险，电力、运营商、工业制造、国家机关、自动驾驶公司也都在尝试AIOps落地。
第二个趋势是AIOps产业生态化。各个行业都在试图尝试落地AIOps，给AIOps方向提供了一个很好的产业基础。“产、学、研、用”各方也都在积极跟进，形成了一个AIOps生态系统。在这个生态系统里，专业的人负责专业的事，有越来越多的学术机构从事AIOps原理研究；由机构用户负责提出实际需求，由有预研能力的厂商把AIOps原理上的突破变成实际落地效果；有负责数据采集、接入、存储等的厂商，还有负责集成、交付、维保等的厂商。也就是说，“学、研、产、用”几方专业分工，通力协作。AIOps产业生态化在AIOps落地过程中是一个重要的里程碑，会大力推动AIOps的更快落地。
**第三个趋势是AIOps数据多样化。**数据中心的系统物理架构和软件架构都非常庞大复杂。因此我们必须采集、治理、融合多种运维数据源、从中提取对运维最有用的信息，帮助我们了解数据中心最新最全的运行状态, 从而为AIOps的众多场景服务。因此我们说AIOps数据多样化是必然趋势。
**第四个趋势是AIOps场景多样化。**下图罗列了一些我们与合作伙伴合作、交流时遇到的具体场景。我们分成几个大场景：即异常发现、事件发现、事件分析、系统画像、图谱丰富等。每一个大场景会包含很多的具体场景，比如“事件分析”大场景就包括“异常机器定位”、“交易链条定位”、“多维度异常定位”等多种类型的事件分析。也就是说，当用户认识到AIOps能实际帮助到运维的时候，会自发与生态系统中的伙伴共同找到越发多样化的AIOps场景。
**第五个趋势是AIOps场景精细化。**如下图所示，异常检测（也就是通过分析监控数据自动发现运维故障）就包含单指标异常检测、多指标异常检测、多维度异常检测、日志异常检测等等。而单指标异常检测在检测业务、机器、网络、数据库、存储系统、批处理的异常时，其场景和检测侧重点会有所不同，因此需要针对精细化的具体场景进行AIOps异常检测算法的适当调整或适配。
为了避免AIOps场景多样化和精细化导致的落地工作量增加，我们必须把各类场景用到的AIOps算法共性部分抽象提炼出来作为公用模块，为多个场景服务。如下图所示，从日志数据测量出的指标数据的异常检测，就可以复用单指标异常检测这一算法模块，并且这一算法模块已经服务化，即可以通过API直接调用。所以我们说的第六个趋势就是AIOps算法服务化，提升了效率，让整体服务得更好。
在AIOps场景多样化、场景精细化、算法服务化的前提下，**第七个趋势，即AIOps技术平台化也就水到渠成了。**AIOps技术平台化打穿多个场景、多个数据源、多个算法。如下图所示，上面输入的是各种运维监控数据，输出的就是我们所需要的各种运维智能，中间是各种服务化的AIOps算法。不管具体的某个运维场景有什么样的特点，我们都可以通过整体平台进行自由组合和编排，从而高效落地该运维场景，避免传统方法的重复低效落地。
这也就引出了**第八个趋势：AIOps新算法落地加速化。**以往一个新算法研制出来后，需要大量的工程工作配合才能让新算法产生实际效果。有了平台化之后，只需要通过编排把该新算法、新算法所需数据、已有工程工作“串”在一起，就能够快速落地。比如做了一个0day攻击检测算法ZeroWall，我们在一家具体机构进行尝试的时候，一周内捕获28种0day攻击，每天捕获上万条0day攻击，每天误报数0到6个。如果按照以往方法，我们要花大量的时间去做ZeroWall的落地工作，而有了AIOps平台化， ZeroWall的落地工作就快了很多。
在过去半年期间，各个行业的合作伙伴都提出了AIOps成熟度评估标准化的需求，而银保监会、证监会、人行、工信部相关领导也都表示会支持。这个事情我也已经着手联合各方开始做，预计一两年的时间才能做出一个切实可行的标准。
总结一下AIOps的九大趋势：行业多样化、产业生态化、数据多样化、场景多样化、场景精细化、算法服务化、技术平台化、落地加速化、成熟度评估标准化。这九大趋势将助力AIOps在今后的几年起飞、爆发。
AIOps落地还会遇到各种各样的挑战。我们需要抬头看天，低头看路，目标一致，脚踏实地，一步一个脚印落地AIOps。AIOps是我本人“择一事，终一生”的事业，希望与更多志同道合的同仁一起，为AIOps这个事业共同奋斗！
谢谢大家！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d63e979387b565a5e1a3191c816bf86e/" rel="bookmark">
			哈夫曼编码的实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		哈夫曼编码 一.关于哈弗曼编码的个人理解二.问题的提出三.哈夫曼编码的实现原理四.哈夫曼树的存储结构五.哈夫曼树如何构造1.统计文本中字符出现的频率2.对入队列的节点进行排序处理3.哈夫曼树的两种构造方法 六.哈夫曼编码的生成(压缩编码长度)1.利用哈夫曼树生成对应的密钥字典2.根据密钥字典进行字符串的压缩3.利用密钥字典中的编码对字符串进行解密 七.测试结果 一.关于哈弗曼编码的个人理解 在数据传输过程中，数据都是由很多字符构成，每个字符又都是由二进制数构成，如果给每个字符确定且定长的编码，那么在数据传输过程中，数据量就会很大，如何使数据量变小呢？
可以通过观察得到，在我们人类的所使用的语言中，总是有那么几个字符的应用频率大于其他字符的使用频率，所以我们可以通过将这些使用频率很高的字符通过缩短其二进制编码的长度，来进行数据量的压缩。
哈夫曼树就是一种很好的解决方式，哈夫曼树可以根据我们规定的权值，对字符进行排列组合，生成一颗哈夫曼树，而在这个树中，每个字符所生成的编码都是独一无二的，不会产生二义性，当对压缩后的数据进行解密时，不会因为字符编码出现二义性，不仅减小了数据量，并且保证压缩之后的数据的准确性。
二.问题的提出 如何统计给定的一篇文本中，每个字符出现的频率。使用什么样的结构可以完成哈夫曼树权值最小子树的挑选。如何对输入的数据进行压缩处理。 以上问题将会在下文进行解释。
三.哈夫曼编码的实现原理 哈夫曼编码的实现需要通过构造哈夫曼树，通过遍历哈夫曼的子树来确定每个字符的编码。在构建哈夫曼树时，需要取出权值最小的两颗子树，可以利用队列从队头取元素的特性，将树节点按照权值由小到大的存储在队列中，在构造哈夫曼树时，从队头取出两个权值最小的子树进行哈夫曼树的构造，并将构造好的子树继续根据权值大小放入队列中，用于下一次构造，直至队列为空。为节点生成哈夫曼编码，生成时，利用前序遍历的方式，将每个节点走过的路径记录下来，并且将路径生成的字符串进行存储。压缩后的编码如何解密，我们可以知道，哈夫曼编码是没有二义性的，就可以利用生成的编码顺序对比压缩的编码，一位一位进行解密。
四.哈夫曼树的存储结构 为了利用队列的特性，使用队列节点嵌套二叉树节点的方式，进行存储。
// 哈夫曼树节点 struct BiTreeNode { ElemType data; int weight; BiTreeNode* lchild; BiTreeNode* rchild; }; // 队列节点 struct SqQueueNode { BiTreeNode* btNode; SqQueueNode* next; }; struct SqQueueLink { SqQueueNode* front; SqQueueNode* rear; }; // 密钥表结构 struct EncTable { char ch; char table[256]; }; 五.哈夫曼树如何构造 1.统计文本中字符出现的频率 string str = "this is a test string";	// 示例字符串 int priority[ACSII_LEN] = { 0 };	// 确定优先级，记录ACSII表所有字符出现的次数 // 记录str中每个字符出现的次数（将字符转为acsII进行记录） for (int i = 0; i &lt; str.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d63e979387b565a5e1a3191c816bf86e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e64744c924fd5a5c92d9155b2d8f879/" rel="bookmark">
			Vulnhub之lampiao渗透测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1、靶场概述2、信息收集3、获取shell4、提权获取普通用户权限获取root权限 1、靶场概述 Description
Back to the Top
Would you like to keep hacking in your own lab?
Try this brand new vulnerable machine! “Lampião 1”.
Get root!
Level: Easy
链接:靶场下载地址
Kali IP 地址： 192.168.29.131
靶场IP地址： 192.168.29.135
VMware加载靶机ovf文件后，可能会出现获取不到ip地址的情况，若出现此情况，可参考这篇文章:Vulnhub靶机检测不到IP地址。
2、信息收集 nmap扫描192.168.29.0/24网段，扫描出靶机IP地址。
继续扫描靶机开启的端口和服务，靶机开启了22和80端口。
访问80端口，显示为一个静态页面，F12查看源码，也没有发现敏感信息泄露。
由于默认情况下，Nmap用指定的协议对端口1到1024以及nmap-services 文件中列出的更高的端口在扫描，所以我们使用nmap -sS -sV -p- 192.168.29.135对全端口进行扫描。
发现1898端口，服务为apache httpd，web访问该端口，显示一个站点。
页面上没发现可以利用的地方，于是使用“御剑”扫描后台目录。
访问robots.txt，发现一个敏感文件CHANGELOG.txt，记录更新的日志。
访问该文件，发现是Drupal为框架的网站 ，版本为7.54。
3、获取shell 利用搜集到的敏感信息，搜索存在的漏洞，这里使用kali自带的msf。
可以使用2018年3月28日，爆出的一个漏洞，利用此漏洞，可以执行远程注入（靶机drupal更新日志为2017-02-01）。
设置目标主机192.168.29.135 , 目标端口 1898 ，然后run，Kali与靶机建立连接。
执行shell获取交互式命令，由于我们获取的shell并不是一个具有完整交互的shell，对于已经安装了python的系统，我们可以使用python提供的pty模块，只需要一行脚本就可以创建一个原生的终端，命令如下：python -c 'import pty;pty.spawn("/bin/bash")'
4、提权 获取普通用户权限 ls -al查看网站根目录有些什么东西，发现有几个东西不是网站根目录应该有的，所以应该可以获得什么重要信息，把这些文件传输到攻击机上一一查看
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8e64744c924fd5a5c92d9155b2d8f879/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b2d21a596a58f17cd42abdf95c20769/" rel="bookmark">
			centos服务器常用网站部署工具安装（docker），包含minio工具类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
redis安装
minio文件服务器
rabbitmq安装
mysql安装
nginx安装
docker的基本使用
导出和导入容器
minio版本7.0.2（springboot）
官方脚本安装docker curl -fsSL https://get.docker.com | bash -s docker --mirror aliyun redis安装 docker安装radis并配置密码和自启动
docker run --name redis -p 6379:6379 -d --restart=always redis:latest redis-server --appendonly yes --requirepass "123456" minio文件服务器 -minio的相当于自己搭配的oss服务器
1.搜索镜像
docker search minio 2.拉取镜像
docker pull minio/minio 3.自定义用户名和密码 并设置自启动
docker search minio docker pull minio/minio docker run -p 9000:9000 --name minio \ -d --restart=always \ -e "MINIO_ACCESS_KEY=superchen" \ -e "MINIO_SECRET_KEY=superchen" \ -v /home/data:/data \ -v /home/config:/root/.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b2d21a596a58f17cd42abdf95c20769/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5fca63322c26cde51b9547e8fed2fa5/" rel="bookmark">
			jenkins操作笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前提：使用yum安装的Jenkins
查看jenkins信息：systemctl status jenkins
启动jenkins：systemctl start jenkins
重启Jenkins：systemctl restart jenkins
停止Jenkins：systemctl stop jenkins
查找当前安装Jenkins的安装包名：rpm -qa | grep jenkins
查看安装包中的文件及路径：rpm -ql jenkins-2.249.2-1.1.noarch
可以看到Jenkins的配置文件为:
/etc/sysconfig/jenkins
修改端口：
打开配置文件 /etc/sysconfig/jenkins ，找到配置项: JENKINS_PORT
重启：systemctl restart jenkins
修改启动内存占用过高问题：
打开配置文件 /etc/sysconfig/jenkins ，添加JAVA_OPTS="-server -Xms1024m -Xmx2048m -XX:PermSize=256m -XX:MaxPermSize=512m"
JVM内存JAVA_OPTS参数说明：
-server:一定要作为第一个参数，在多个CPU时性能佳
-Xms：初始Heap大小，使用的最小内存,cpu性能高时此值应设的大一些
-Xmx：java heap最大值，使用的最大内存
上面两个值是分配JVM的最小和最大内存，取决于硬件物理内存的大小，建议均设为物理内存的一半。
-XX:PermSize:设定内存的永久保存区域
-XX:MaxPermSize:设定最大内存的永久保存区域
-XX:MaxNewSize:
-Xss 15120 这使得JBoss每增加一个线程（thread)就会立即消耗15M内存，而最佳值应该是128K,默认值好像是512k.
+XX:AggressiveHeap 会使得 Xms没有意义。这个参数让jvm忽略Xmx参数,疯狂地吃完一个G物理内存,再吃尽一个G的swap。
-Xss：每个线程的Stack大小
-verbose:gc 现实垃圾收集信息
-Xloggc:gc.log 指定垃圾收集日志文件
-Xmn：young generation的heap大小，一般设置为Xmx的3、4分之一
-XX:+UseParNewGC ：缩短minor收集的时间
-XX:+UseConcMarkSweepGC ：缩短major收集的时间
提示：此选项在Heap Size 比较大而且Major收集时间较长的情况下使用更合适。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d409d59aa3e1cd33d69c19e438632b56/" rel="bookmark">
			Dji Manifold2-G源码编译安装pytorch
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Dji Manifold2-G源码编译安装pytorch Dji Manifold-2G 源码安装pytorch1. 查看Dji Manifold-2G环境2. 安装cudnn2.1 下载cuDNN2.2 安装cuDNN 3. 下载pytorch源码与安装3.1 下载源码3.2 安装依赖环境3.3 进行编译 4. 总结问题汇总 Dji Manifold-2G 源码安装pytorch 最近需要在无人机上做一些实验，需要配置深度学习框架。本打算采用轮子安装的方式，当时尝试几次都无法安装成功，缺少依赖的动态库。Manifold-2G 自带cuda9.0， 升级cuda是很麻烦的事，也没有找到合适的方法。因此尝试使用pytorch源码安装，在安装过程中也遇到些问题，在此做记录和总结。
1. 查看Dji Manifold-2G环境 #内核版本 uname-a #ubtuntu版本 cat /etc/lsb-release #查看cuda版本 nvcc --version #查看cuDNN版本 cat /usr/local/cuda/include/cudnn.h | grep CUDNN_MAJOR -A 2 #查看camke版本号 cmake -version 2. 安装cudnn 2.1 下载cuDNN 源码安装pytorch需要使用cuda、cudnn以及cmake，Manifold自带cuda9.0，需要安装对应版本的cudnn，Maniflod自带的cudnn需要更新到7.6.5
cudnn的下载地址：
https://developer.nvidia.com/rdp/cudnn-archive
找到与cuda9.0版本对应的cuDNN，点开之后选择与系统对应版本，由于Manifold是基于arm架构的，这里我们要选择第三项下载。
这里也给大家提供了一个直接对应cuda9.0版本的cudnn链接：cuDNN-v7.6.5
2.2 安装cuDNN ~$ cd Downloads/ #安装文件下载的目录 ~$ sudo tar xvf cudnn-9.0-linux-x64-v7.6.tgz ~$ mkdir cudnn7 ~$ sudo cp -r cuda cudnn7 ~$ cd cudnn7 ~$ sudo cp include/cudnn.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d409d59aa3e1cd33d69c19e438632b56/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f292a0f43ff12e2c7ad8e9054bd32b58/" rel="bookmark">
			删除文件注释 php,php如何删除注释
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		php删除注释的方法：首先创建一个用于测试的文件代码；然后自定义一个“removeComment”方法；接着通过“preg_replace”函数实现删除注释的功能；最后在浏览器中执行该文件即可。
PHP 去除代码中的注释
测试文件代码如下：&lt;?php /**
* Created by PhpStorm.
* User: Yang
* Date: 2019/10/16
* Time: 10:25
*/
// 计算和
// 计算和
// 计算和
$a = 1;
$b = 2;
$c = $a+$b; //总和
/*
* 求和函数
*/
function sum($a, $b) {
return $a + $b; //返回值
}
# 第二种注释
$a = 1;
$b = 2;
## 求乘积
$c = $a * $b; # 结果
//特殊
$usedFuncs = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f292a0f43ff12e2c7ad8e9054bd32b58/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8af8894e0cf1ffe3639e53b98fe64eb1/" rel="bookmark">
			php 相同key相加,php如何对二维数组内相同的key的值相加
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目描述
如何对二维数组内相同的key的值相加
题目来源及自己的思路
把一个二维数组 相同的hid的sum相加
自己做的是$array=[];
foreach ($arr as $k=&gt;$v){
$array[$v['hid']][]=$v;
}
$list=[];
foreach ($array as $k=&gt;$v){
foreach ($v as $k1=&gt;$v1){
$list[$k]+=$v1['sum'];
}
}
dump($list); 出来 array(4) {[2] =&gt; int(6) [3] =&gt; int(7)[5] =&gt; int(6) [4] =&gt; int(5)
相关代码
// 请把代码文本粘贴到下方(请勿用图片代替代码)
就是把下面的转为 $list=[6,7,6,5];$arr=[
['id'=&gt;1,'hid'=&gt;2,'sum'=&gt;1],
['id'=&gt;2,'hid'=&gt;2,'sum'=&gt;2],
['id'=&gt;3,'hid'=&gt;2,'sum'=&gt;3],
['id'=&gt;4,'hid'=&gt;3,'sum'=&gt;1],
['id'=&gt;5,'hid'=&gt;3,'sum'=&gt;2],
['id'=&gt;6,'hid'=&gt;3,'sum'=&gt;4],
['id'=&gt;7,'hid'=&gt;5,'sum'=&gt;2],
['id'=&gt;8,'hid'=&gt;5,'sum'=&gt;4],
['id'=&gt;9,'hid'=&gt;4,'sum'=&gt;5]
];
}
你期待的结果是什么？实际看到的错误信息又是什么？
如何优化我的代码。我写的循环太多了。我想要的结果就是 相同的hid的sum相加
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0143c4a59f4b56b55d0bbff6b64c806/" rel="bookmark">
			Centos安装docker&#43;vulhub搭建全过程及报错处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、CenterOS下载
https://vault.centos.org/7.8.2003/isos/x86_64/
2、VMware启用chux报错
VMware Workstation 与 Device/Credential Guard 不兼容。在禁用 Device/Credential Guard 后，可以运行
解决办法参考：http://www.bubuko.com/infodetail-3314116.html
（3）虚拟机需要上网下载各种安装包，所以需要配置上网。
(4)开始安装docker
先安装Docker，在安装docker-compose。
参考链接：https://www.freeaihub.com/post/2377.html
（5）Docker安装chmod
chomd +x /usr/local/bin/docker-compose
docker run cmd.cat/chmod chmod
（6）安装vulhub
cd /CVE#进入靶机管理文件夹
git clone https://github.com/vulhub/vulhub.git
如果出现报错，git 推送出现;fatal: The remote end hung up unexpectedly" ，重复测试。或者参考https://blog.csdn.net/weixin_38450840/article/details/80701173
（6）启用环境，安装完成，之后进入你想建立的靶场环境
docker-compose up -d //建立环境
docker-compose down//关闭环境
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97e320223b5d0edd4e823b837bff4eff/" rel="bookmark">
			Ubuntu16.04 编译错误 c&#43;&#43;: internal compiler error: Killed (program cc1plus)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		编译错误 c++: internal compiler error: Killed (program cc1plus) 错误描述 在大疆manifold-2G 上源码安装pytorch时出现编译错误
解决办法 ubuntu使用cmake编译时比较耗费内存，可以查看下内存使用情况
查看swap和memory的空间使用情况 $ free -h 可以看出没有开辟swap空间，下面尝试开辟swap空间
创建 swap file 大小为2G $ sudo fallocate -l 2G /swapfile 查看swapfile $ ls -lh /swapfile 修改文件权限，只能被root访问 $ sudo chmod 600 /swapfile $ ls -lh /swapfile 标记文件空间 sudo mkswap /swapfile 执行效果 继续执行源码编译程序，编译内存空间不足问题解决。
参考文章
https://blog.csdn.net/sinat_31220673/article/details/95351169?spm=1001.2014.3001.5502
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/970b54b9dc85d687102598dcabd410aa/" rel="bookmark">
			ACWing n-皇后问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		n−n−皇后问题是指将 nn 个皇后放在 n×nn×n 的国际象棋棋盘上，使得皇后不能相互攻击到，即任意两个皇后都不能处于同一行、同一列或同一斜线上。
现在给定整数 nn，请你输出所有的满足条件的棋子摆法。
输入格式
共一行，包含整数 nn。
输出格式
每个解决方案占 nn 行，每行输出一个长度为 nn 的字符串，用来表示完整的棋盘状态。
其中 . 表示某一个位置的方格状态为空，Q 表示某一个位置的方格上摆着皇后。
每个方案输出完成后，输出一个空行。
注意：行末不能有多余空格。
输出方案的顺序任意，只要不重复且没有遗漏即可。
数据范围
1≤n≤91≤n≤9
输入样例：
4 输出样例：
.Q.. ...Q Q... ..Q. ..Q. Q... ...Q .Q.. 思路分析：回溯法
#include&lt;bits/stdc++.h&gt; using namespace std; int n; int mp[15][15]; int dx[]= {-1,1,0,0,-1,1,-1,1}; int dy[]= {0,0,-1,1,-1,-1,1,1}; bool check(int x,int y,int op) { if(x&lt;0||x&gt;=n||y&lt;0||y&gt;=n) return true; if(mp[x][y]==1) return false; return check(x+dx[op],y+dy[op],op); } bool fun(int x,int y) { bool flag = true; for(int i =0; i&lt;8; i++) { int xx = x+dx[i]; int yy = y+dy[i]; flag = check(xx,yy,i); if(flag == false) return false; } return true; } void dfs(int x,int y,int num) { if(num==n) { for(int i = 0; i&lt;n; i++) { for(int j = 0; j&lt;n; j++) { if(mp[i][j]==1) cout&lt;&lt;"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/970b54b9dc85d687102598dcabd410aa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7ce0bfd2f78764d2ef69c9e706d84af/" rel="bookmark">
			报错FloatingPointError: Loss became infinite or NaN at iteration=1099!
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		报错FloatingPointError: Loss became infinite or NaN at iteration=1099!
[04/01 15:05:09] d2.engine.train_loop ERROR: Exception during training: Traceback (most recent call last): File "/root/detectron2/detectron2/detectron2/engine/train_loop.py", line 138, in train self.run_step() File "/root/detectron2/detectron2/detectron2/engine/defaults.py", line 441, in run_step self._trainer.run_step() File "/root/detectron2/detectron2/detectron2/engine/train_loop.py", line 242, in run_step self._write_metrics(loss_dict, data_time) File "/root/detectron2/detectron2/detectron2/engine/train_loop.py", line 285, in _write_metrics f"Loss became infinite or NaN at iteration={self.iter}!\n" FloatingPointError: Loss became infinite or NaN at iteration=1099! loss_dict = {'loss_cls': nan, 'loss_box_reg': nan, 'loss_rpn_cls': 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e7ce0bfd2f78764d2ef69c9e706d84af/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f91e28f97775f08b0ddfdb809d78c7ba/" rel="bookmark">
			递归讲解与递归实现列表的反转
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		递归： 特点：当一个复杂的问题可以分解为几个（最简单的就是一个）相对简单的且与原来问题解法相同或者类似的子问题来求解，便称为递归求解。： 递归工作栈与递归过程： 在高级语言中，调用函数与被调用函数之间的链接及信息交换需要通过栈来进行。字数太多，我们直接上图：
递归算法的效率分析： 时间复杂度： 大致为O(2^n) （斐波那契以及汉诺塔问题）空间复杂度： O(f(n)) ,f(n) 为递归工作栈中记录的个数与问题规模n的函数关系。 分治法： 一种分解-求解的策略，叫做分治法，用来求解递归问题。 分治法满足的三个条件： （1）能将一个问题转变为一个新的问题，而新的问题与原来的问题解法相同或类同，不同的仅是处理对象（重点），并且这个对象更小，且变化更有规律。 （下面列表反转递归，第二种方法操作的都是同一个列表对象，每次递归操作不同元素）
（2） 可以通过上述转化使问题简化。
（3） 必须有一个明确的递归出口，或称为递归的边界（重点）。
演示： void p(参数列表) { if(递归结束条件成立) 可直接求解； // 递归终止条件 else p(娇小的参数);	// 递归步骤 } 数据结构是递归的（很多可以递归处理） 例如链表， 树形结构等 上解答问题代码： a = [1, 2, 3, 4, 5, 6, 7, 8] def rev_list(l): if len(l) == 1: return l elif len(l) == 2: # 可以省略这一步 l[0], l[-1] = l[-1], l[0] return l else: return [l[-1]] + rev_list(l[:-1]) # -1 才算是取最后一位之前的所有 # print(rev_list(a)) # 上述方法会不断的进行 l[:-1] 和 [l[-1]] 的操作，不断地进行浅拷贝效率太低,并且并未改变a，而是返回新的列表 # 从快速排序方法中找到的灵感，我们采用双指针针解决这个问题 def reverse(l, low, height): "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f91e28f97775f08b0ddfdb809d78c7ba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6094d10f69ef8fd3c528863b9d0cd00/" rel="bookmark">
			java JVM内存结构之PC寄存器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		java JVM内存结构之PC寄存器 本篇自己学习记录,如有错误,请各位大佬指正!
JVM 内存模型图 一 ,PC寄存器介绍(PC Register) ​ JVM中的PC程序计数寄存器(Program Counter Register)中,Register 的命名源于cpu中的寄存器,寄存器存储指令相关的现场信息,cpu只有把数据 装载到寄存器才能够运行,这里,并非是广义上所指的物理寄存器,或许将其翻译为pc计数器(或指令计数器)会更为贴切,JVM中的PC寄存器是物理寄存器的抽象.
作用: ​ pc寄存器是用来存储指向下一条要执行指令的地址,即下一条要执行的代码,由执行引擎来读取下一条 指令
特点: 运行空间很小,小到可以忽略不计,且运行速度是最快的
每个线程有一个私有的程序计数器，线程之间互不影响
运行时数据区中唯一不会出现OOM(OutOfMemoryError)的区域，没有垃圾回收(gc)。
它是流程控制的指示器,分支 .流程控制,异常处理,线程 恢复等基础功能都依赖于pc寄存器来完成
如果正在执行的本地方法(native 方法)，这个计数器值则应为未定义。（undefined）
二,举例说明 下面简单代码做说明
框1 为执行指令的数字编号 ,框2 为 执行的局面指令
框3 为指令数字编号 与实际代码中行号的对应关系
三,面试题 1.使用PC寄存器存储字节码指令地址有什么用?
​ 因为线程是一个个的顺序执行流，CPU需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行,JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令,记录下一条字节码执行的指令，实现分支循环跳转、异常处理、线程恢复等功能。
2.PC寄存器为什么被设定为私有的？
​ CPU为每个线程分配时间片，多线程在一个特定的时间段内只会执行某一个线程的方法，CPU会不停地进行任务切换，线程需要中断、恢复,CPU，多线程，分配时间片，只执行一个线程，CPU任务切换，线程中断恢复,各个线程、PC寄存器记录、当前字节码指令地址，各个线程之间可进行独立计算，防止相互干扰。为了能够准确的记录各个线程当前正在执行的字节码指令,最好的办法自然就是为每一个线程都分配一个 pc寄存器，防止相互干扰。为了能够准确的记录各个线程当前正在执行的字节码指令,最好的办法自然就是为每一个线程都分配一个 pc寄存器
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc4d7e8d37611193a6dbf278caecf352/" rel="bookmark">
			【数字图像处理】双三次插值及其卷积算法（Bicubic Interpolation）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		双三次插值数学原理及其卷积算法原理（Bicubic Interpolation） 本文是维基百科上双三次插值的中文翻译，如有侵权会立即删除。本人刚学图像处理，第一次翻译英文文章，水平有限，如有错误还请指正。
附上原文链接：https://en.wikipedia.org/wiki/Bicubic_interpolation
单位正方形中的插值平面计算： 假设在单位正方形的四个顶点上函数f的函数值、x偏导、y偏导、xy混合偏导都已知。插值曲面p(x,y)可以写为：
通过这4个点f的信息，去确定一个曲面P(x,y)来拟合f，需要确定p(x,y)中的16个参数。
p(x,y)上4个点的函数值满足f：
同上，4个点共8个偏导数满足：
同上，4个点4个混合偏导数满足：
显然，p(x,y)的偏导数可以根据前面设的表达式求导得到：
这样得到的曲面p(x,y)在单位正方形内都连续可导。在任意大小的规则网格上的双三次插值可以通过将上面方法得到的曲面连接起来得到，注意在小方格边界上要满足边界条件。
如果将未知参数按如下顺序列成向量：
并设x为：
则上面p(x,y)中的参数可以由矩阵运算得到：
其中inv(A)为：
这样可以使得α被很快地求解出来。
同样的，也可以列成另外一种矩阵形式，这样更简洁：
两种方法都能确定p(x,y)，其中第二种矩阵阶数小且能用矩阵表示p(x,y)，更方便。
扩展到矩形网格： 通常应用程序要求双三次插值使用一个矩形网格上的数据，而不是单位正方形。这种情况下，偏导数的定义为：
其中Δx、Δy是网格中矩形的长或宽。
这样，计算α的实用方法是：
设x：
用前面给出的A求解α：
然后将标准化的插值变量(x,y)代入p(x,y)：
公式中的x0、x1、y0、y1是(x,y)的近邻点。
这样就得到了一个矩形内的插值曲面p(x,y)。
注意到上面的方法中需要用道偏导数信息，而对于一个离散的像素灰度数组，只有函数值信息，因此需要用下面介绍的方法计算。
从函数值中得到导数： 如果矩形顶点导数未知，那么可以通过矩形顶点的近邻点的函数值的有限次差分来近似得到。
为了计算两个一阶偏导数（x、y两个方向），可以计算该点在对应方向上的两个近邻点的连线的斜率。例如计算x方向的偏导数，可以找到它左边和右边的两个近邻点，然后将这两点相连，得到直线的斜率，作为偏导数。
同样的，也可以计算二阶混合偏导数。例如计算某个矩形顶点的二阶混合偏导数，则先计算它上下两个近邻点的一阶x方向偏导数，再用这两个偏导数值类似前面求y方向偏导数的方法求二阶偏导数。这个计算中，对一个顶点，用到了它八邻域的4个角点的函数值。
对于数据的边界，如果没有部分近邻点，那么这些点可以通过很多方法来近似。一种简单常用的方法是认为边界处的斜率不变，也就是利用已知数据在边界处的斜率以及边界点的函数值来估算不存在的近邻点。
双三次插值的卷积算法： 上面的方法需要在每一个矩形格求解线性方程。
有另一种插值方法可以完成类似的功能。通过在两个维度上与下面的核函数进行卷积，可以得到待插值：
其中a通常设置为-0.5或-0.75。注意W(0)=1，当n为正整数时，W(n)=0（如n=1）。
这个方法是由Keys提出的，他证明了a=-0.5时关于原始函数的取样间隔是三阶收敛的。
如果我们用矩阵来表示通常的a=-0.5的情况，那么我们可以把方程表示一种更友好的方式：
其中，t在0到1之间。注意对于一个维度的立方卷积插值是需要4个取样点的，其中两个在待插值点的左边，另外两个在右边，在这里用-1到2的下标表示了这些点。待插值点与下标为0的点之间的距离就是t。
对于两个维度的插值，则可以现在x方向上进行上面的计算，再在y方向上用x方向上的结果进行第二次上面的计算。
如上面的式子，共16个数据点。先对4个一组的x方向的点用tx进行上面的一维卷积得到b。之后对b用ty进行一维卷积得到p(x,y)。
通过上面的计算，可以得到二维卷积的公式。对于每个取样点，以W(x)*W(y)作为权值，然后对16个取样点加权求和，结果与两次一维卷积的结果相同。
英文原文：https://en.wikipedia.org/wiki/Bicubic_interpolation
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ee00113d00ffa3342d02f6ebece5f50/" rel="bookmark">
			安装MySQL压缩包，无法初始化MySQL
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		启动MySQL时报这个错误：
D:\download\software\mysql-8.0.23-winx64\bin&gt;mysqld --initialize --console
mysqld: Can't create directory 'D:\download oftware\mysql-8.0.23-winx64\data\' (OS errno 2 - No such file or directory)
把my.ini文件中，这两个目录加上双引号，地址再加上双斜杠就可以啦~（cmd记得在管理员权限下打开）
basedir="D:\\download\\software\\mysql-8.0.23-winx64"
datadir="D:\\download\\software\mysql-8.0.23-winx64\\data"
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f6531ec20318dd5eb7aaa1cf9f12d8e/" rel="bookmark">
			园区网络网关位置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		园区网络中，常把网关设于汇聚层而不是接入层。
优势：①合理设计二层网络规模，减少网段分配，提高网络管理效率；②接入设备可以使用二层设备，减少网络建设成本。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54ae9fd64ae22ec246a4561dfc236080/" rel="bookmark">
			记录一个mysql update   a,b      a  and b 的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mysql : update table set a = xxxxxxx and b =xxxxxxxx 。 这样 只会 执行 set a=xxxxxxxx 而且 不会赋值xxxxxxxx 而是赋值 0！....
所以正确的应该是 mysql: update table set a = xxxxxx , b=xxxxxx
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c37bfa0d9221981834c9d4d831306783/" rel="bookmark">
			Java获取指定月份的上个月第一天跟最后一天
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java获取指定月份的上个月第一天跟最后一天 import java.text.ParseException; import java.text.SimpleDateFormat; import java.util.Calendar; import java.util.Date; /** * @author : icehill * @description : 获取指定月份的上个月第一天跟最后一天 * @date : 2021-03-31 */ public class LearnTime { public static void main(String[] args) { SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd"); try { Date date = format.parse("2019-03-15"); Calendar c = Calendar.getInstance(); //设置为指定日期 c.setTime(date); //指定日期月份减去一 c.add(Calendar.MONTH, -1); //指定日期月份减去一后的 最大天数 c.set(Calendar.DATE, c.getActualMaximum(Calendar.DATE)); //获取最终的时间 Date lastDateOfPrevMonth = c.getTime(); System.out.println("上月最后一天：" + format.format(lastDateOfPrevMonth)); c.set(Calendar.DATE, 1); //获取最初的时间 Date firstDateOfPrevMonth = c.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c37bfa0d9221981834c9d4d831306783/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db055e1e8ab6e890736c7eebe4943066/" rel="bookmark">
			web服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://tool.oschina.net/ http协议默认端口是 80 https默认端口 443 // 客户端 -&gt; 浏览器 -&gt; 发送请求给服务器 -&gt; 地址栏/通过链接 -&gt; 地址栏发送请求细节: https://www.baidu.com/:9999 - htts: 协议 - baidu.com: 域名 - 域名的作用: 方便记忆, 连接服务器的时候使用的IP地址不是域名 - 域名需要和IP地址绑定 - 通过域名访问web服务器 - 当前主机会连接dns服务器 -&gt; 得到域名对应的IP地址 - 得到IP之后通过IP访问服务器 - 9999: 访问的服务器绑定的端口是9999 1. HTML 1.1 html简介 超文本标记语言(Hyper Text Markup Language)，标准通用标记语言下的一个应用。HTML 不是一种编程语言，而是一种标记语言 (markup language)，是网页制作所必备的。
超文本就是指页面内可以包含图片、链接，甚至音乐、程序等非文字元素。
超文本标记语言的结构包括**“**头”部分（英语：Head）、和“主体”部分（英语：Body），其中“头”部提供关于网页的信息，“主体”部分提供网页的具体内容。
html 特点
语法非常简洁、比较松散，以相应的英语单词关键字进行组合
使用了很多标签, 每个标签都有固定的意思使用的标签一般都是成对的, 也有特殊的单标签 html标签不区分大小写
大多数标签是成对出现的, 有开始, 有结束
不成对出现的称之为短标签
html文件命名
xxxx.htmlxxx.htm 注释
&lt;!-- 我是一个html注释 --&gt; &lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/db055e1e8ab6e890736c7eebe4943066/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf7f17f817e885f9cddf4b4fe59e1511/" rel="bookmark">
			监听ios底部bar返回事件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 监听ios底部bar返回事件
//跳转之前加上 window.history.pushState(null, null, "#"); window.history.pushState(null, null, "#"); window.location.href = 'https://www.baidu.com'; //你走后~ //监听到返回事件 window.addEventListener("popstate", function(e) { console.log(“你终于回来了~”) }, false); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d690ca3afb36b6abb16cceb6cd182f0/" rel="bookmark">
			win10开启ssh服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 记在前面：
net start sshd OpenSSH SSH Server 服务正在启动 . OpenSSH SSH Server 服务已经启动成功。 目录 1. 安装openssh2. 验证安装3. 启动SSH服务4. 设置账户密码5. 远程连接补充：使用scp传输文件 1. 安装openssh 打开 设置，选择 应用，在 应用和功能 中，找到 管理可选功能，点击 添加功能，添加OpenSSH服务器和OpenSSH客户端。
2. 验证安装 在cmd界面输入ssh，出现以下界面代表安装成功：
3. 启动SSH服务 启动SSH服务 net start sshd
停止SSH服务 net stop sshd
4. 设置账户密码 如果你的账户没有设置密码的话，需要先设置一下密码
在cmd中输入一下命令可以设置密码：
net user [user] [password] 用123456进行测试：
5. 远程连接 ssh [user]@[ip] 回车输入密码 连接成功
补充：使用scp传输文件 scp [file] [user]@[ip]:[path] 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/613dc3d69074ac5bda2083f0e5127708/" rel="bookmark">
			phpstorm配置php环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 phpstorm配置php环境 第一步，点击“File”，在下拉菜单中选择“Settings…” 第二步，进入“Settings”页面，找到“Languages&amp;Frameworks”并展开。 第三步，在“Languages&amp;Frameworks”中找到“PHP”，然后点击“CLI Interpreter”后的“三个点”。 第四步，点击左上角的加号” 第五步，选择“Local Path to Interpreter…”。 第六步，找到“General”，点击“PHP executable”后面的“三个点”。 确定后保存，在PHPSTORM中测试 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f588a0d61df93a5b4eb90a92f9c6a73/" rel="bookmark">
			js解leetcode(80)-中等
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.节点与其祖先的最大差值 题目：
给定二叉树的根节点 root，找出存在于 不同 节点 A 和 B 之间的最大值 V，其中 V = |A.val - B.val|，且 A 是 B 的祖先。
（如果 A 的任何子节点之一为 B，或者 A 的任何子节点是 B 的祖先，那么我们认为 A 是 B 的祖先）
思路：在低估时，不断更新最大值和最小值即可
时间复杂度O(n) 空间复杂度O(logn)
var maxAncestorDiff = function (root, min = root?.val, max = root.val) { if (!root) return 0; min = Math.min(min, root.val); max = Math.max(max, root.val); return Math.max( max - min, maxAncestorDiff(root.left, min, max), maxAncestorDiff(root.right, min, max) ); }; 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8f588a0d61df93a5b4eb90a92f9c6a73/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c74278f62c0ae8dcbfeeab03163fa82/" rel="bookmark">
			C# 学习笔记 9.泛型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.什么是泛型 实现一个方法可以操作多种数据类型。//类似c++的模板或者STL
2.类型参数 1.根据泛型类型参数是否提供实际类型，又可分为两类：未绑定的泛型和已构造的泛型。 如果没有为类型提供实际类型，称未绑定泛型。反之为已构造的泛型。
2.已构造泛型又分为开放类型和密封类型; 开放类型-包含类型参数的泛型，所有未绑定的泛型都属于开发类型。
密封类型-每个类型参数都传递了实际的数据类型的泛型。
//代码后面补上
3.泛型中的静态字段和静态函数问题 1.每一个封闭的泛型类型都是一个不一样的类型，所以他们都有属于自己的静态字段，静态构造函数也是如此。
public class Type_Static_Name&lt;T&gt;
{
public static string name;
static Type_Static_Name()
{
}
}
4.类型参数的推断 1.使用泛型时可以不用写"&lt;&gt;"符号可以通过编译器进行类型推断，帅！
2.泛型推断只能用于泛型方法，泛型类则不适用，因为编译器不能通过泛型类的
构造函数推断出实际的类型参数。
private static void genericMethod&lt;T&gt;(T t1, T t2)
{
T tem = t1;
t1 = t2;
t2 = tem;
Console.WriteLine( t1);
}
genericMethod&lt;string&gt;("aa", "cc");
genericMethod("aa", "bb");
5.类型参数的约束 1.使用where T : IComparable的代码，其中while语言来使用类型参数
接口继承IComparable接口，从而对类型参数进行约束。如果没有这么写
CompareTo就会出问题，编译器不知道T类型有没有提供这样的方法。
public static class compare&lt;T&gt; where T : IComparable
{
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2c74278f62c0ae8dcbfeeab03163fa82/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48b15a3f61b4f6e442af762f238b8ef3/" rel="bookmark">
			20210324牛客Java150题错题解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目 关于instanceof的应用 正解为C，错解为A。
instanceof是java中的一个二元操作符，作用是测试它左边的对象是否是它右边的类的实例。
该题中 obj 对象声明为A类型，创建为D类型对象。D对象继承了B对象，B对象继承了A对象，而C对象又继承了B对象，也就是说，D并不是C的一个实例。
JVM内存不包含如下哪个部分( ) 正解为D，错解为B。
错误原因：众所周知，JVM内存区域大概分为五块：堆，栈，本地方法区，程序计数器，方法区。
其中线程共享的是：堆，方法区。
PC寄存器也叫程序计数器。
如果要建立一个java.scut.computer的包，叙述正确的是？ ( ) 正解：A（存疑），错解：D
一般不能用java来命名，不然会报错。
而如果能够用java命名，那么package必须在非注释语句第一行。
总结：该题不严谨。
java中将ISO8859-1字符串转成GB2312编码，语句为 ？ JAVA有一个 public String(byte bytes[], Charset charset) 函数可以用指定字节数组和编码来构造字符串。一个 public byte[] getBytes(Charset charset) 函数把字符串按指定编码来得到字节数组。可以用这两个函数来实现编码转换。选A。
下面有关java object默认的基本方法，说法错误的是？ 正解：B，错解：C
解析：Object类中只有以下几种方法。
clonenotifynotifyAlltoStringwait（三个重载）finalizegetClasshashCodeequals
其中没有copy方法，只有clone方法。 下面哪个行为被打断不会导致InterruptedException：（ ）？ 正解：E 错解：B
解答这个题，我们首先得了解InterruptedException。
官方源码解释是：
翻译：当线程在活动之前或者活动期间处于正在等待，休眠或占用状态且线程中断 时，抛出该异常。
抛InterruptedException的代表方法有：
java.lang.Object 类的 wait 方法java.lang.Thread 类的 sleep 方法java.lang.Thread 类的 join 方法
而选项D这个类大概的意思就是一个可循环利用的屏障，属于并发的知识。它的await方法可以简单的理解为：等待多个线程同时到达之后才能继续进行，在此之前它就是这些线程的屏障，线程不能继续进行，而对于失败的同步尝试，CyclicBarrier 使用了一种要么全部要么全不 (all-or-none) 的破坏模式：如果因为中断、失败或者超时等原因，导致线程过早地离开了屏障点，那么在该屏障点等待的其他所有线程也将通过 BrokenBarrierException（如果它们几乎同时被中断，则用 interruptedException）以反常的方式离开。因此它被中断也是可以抛出interruptedException的。 E选项的方法以及被淘汰，不多了解。
从内存实现或者反射的角度来看，关于继承的说法正确的是（）。注：此处的继承不代表能调用 正解：A，错解：B
子类将会继承父类的所有的数据域和方法，只是对于调用有所限制，否则反射也无法去调用。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/48b15a3f61b4f6e442af762f238b8ef3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19a17da78a6d6e6597cca2f18991b323/" rel="bookmark">
			同步和异步fifo设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		同步fifo设计 信号列表 clk:fifo操作时钟
wr_en:fifo写使能，在wr_en有效的情况下，上升沿采集wdata数据。
wdata：fifo写数据。
full:fifo满有效。高电平时，代表当前wdata并未写入fifo。
rd_en：fifo读使能。在rd_en有效，empty无效时，数据同步送出fifo。
empty:fifo空有效。高电平时，代表当前rdata无效。
要点 使用两个地址寄存器，分别为raddr和waddr，假设fifo深度为8,则地址位置从000-&gt;111，只需要让raddr和waddr是4个位宽，并且让对fifo读写操作后，raddr和waddr地址加1即可。
当raddr[3:0]=waddr[3:0]，则代表fifo是空的。
当raddr[3]!=waddr[3] raddr[2:0]=waddr[2:0]，则代表fifo是满的。
verilog module fifo_syn #( parameter wa = 3, parameter wd = 4) ( input rst_n, input clk, input wr_en, input [wd-1:0] wdata, output full, input rd_en, output [wd-1:0] rdata, output empty ); //syn [wa-1:0] raddr ^ [wa-1:0] raddr reg [wa:0] raddr; reg [wa:0] waddr; wire condition_1 = &amp;(~(raddr[wa-1:0]^waddr[wa-1:0])); wire condition_2 = &amp;(~(raddr[wa]^waddr[wa])); assign full = ~condition_2&amp;condition_1; assign empty = condition_1&amp;condition_2; parameter deep = (1&lt;&lt;wa)-1; reg [wd-1:0] fifo_mem[deep:0] ; always @(posedge clk) begin if(!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/19a17da78a6d6e6597cca2f18991b323/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f4e54ce9b03c21b577367021e948522/" rel="bookmark">
			windows下Flink部署 （一）Standalone模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Flink部署-standalone模式 1、下载2、启动 1、下载 官方下载链接https://flink.apache.org/zh/downloads.html
目前下载的1.11.x版本解压后没有.bat文件，不知道什么原因，我选择下的是1.9.3版本
2、启动 解压文件
启动集群，包含bin文件夹的目录中启动cmd页面，执行命令 .\bin\start-cluster.bat 通过localhost:8081访问
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84d7e97624eb68b12b52914f818a960f/" rel="bookmark">
			Js基础知识之JSON
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;JSON&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script type="text/javascript"&gt; /* 1、什么是JSON，有什么用？ JavaScript Object Notation（JavaScript对象标记），简称JSON。(数据交换格式) JSON主要的作用是：一种标准的数据交换格式。（目前非常流行，90%以上的系统，系统A与系统B交换数据的话，都是采用JSON。） 2、JSON是一种标准的轻量级的数据交换格式。特点是： 体积小，易解析。 3、在实际的开发中有两种数据交换格式，使用最多，其一是JSON，另一个是XML。 XML体积较大，解析麻烦，但是有其优点是：语法严谨。（通常银行相关的系统之间进行数据交换的话会使用XML。） 4、JSON的语法格式： var jsonObj = { "属性名" : 属性值, "属性名" : 属性值, "属性名" : 属性值, "属性名" : 属性值, .... }; */ // 创建JSON对象(JSON也可以称为无类型对象。轻量级，轻巧。体积小。易解析。) var studentObj = { "sno" : "110", "sname" : "张三", "sex" : "男" }; // 访问JSON对象的属性 alert(studentObj.sno + "," + studentObj.sname + "," + studentObj.sex); // 之前没有使用JSON的时候,定义类,创建对象,访问对象的属性.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/84d7e97624eb68b12b52914f818a960f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a9602db4010dd1f083c9921273c39db/" rel="bookmark">
			正则表达式匹配汉字
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 PHP正则表达式匹配汉字 正确的正则表达式
$reg = '/^[\x{4e00}-\x{9fa5}]+$/u'; 错误的正则表达式
$reg = '/^[\u4e00-\u9fa5]+$/u'; PHP 正则表达式(PCRE)之Unicode PCRE支持的16进制字符编码转义符有\x00-\xFF，或\x{num}，num为任意位16进制数
但并不支持\u0000-\uFFFF这的形式
PCRE运用/u模式去处理UTF-8编码字符，这是PCRE特有的，示例代码
$str = '中123abcd个业上'; $pattern = '/[\x{4E10}-\x{4E2F}\x{4E0A}]/u'; $matchs = array(); $result = preg_match_all($pattern, $str, $matchs); var_dump($result, $matchs); 输出结果：
int(4) array(1) { [0]=&gt; array(4) { [0]=&gt; string(3) "中" [1]=&gt; string(3) "个" [2]=&gt; string(3) "业" [3]=&gt; string(3) "上" } } 示例：正则校验昵称是否只包含数字、字母、下划线、汉字
$nickname='陈先生123'; if (!preg_match("/^[0-9a-zA-Z _\x{4e00}-\x{9fa5}]+$/u", $nickname)) { echo '昵称不应包含特殊字符'; } else { echo 'success'; } 输出结果
success 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/603fd4dcfc8f442adb0a3739f41b15fe/" rel="bookmark">
			二十三种设计模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		二十三种设计模式 1 引言
谈到设计模式，绝对应该一起来说说重构。重构给我们带来了什么？除了作为对遗留代码的改进的方法，另一 大意义在于，可以让我们在写程序的时候可以不需事先考虑太多的代码组织问题，当然这其中也包括了应用模式的问题。尽管大多数开发者都已经养成了写代码前先 从设计开始的习惯，但是，这种程度的设计，涉及到到大局、到总体架构、到主要的模块划分我觉得就够了。换句话说，这时就能写代码了。这就得益于重构的思想 了。如果没有重构的思想，有希望获得非常高质量的代码，我们就不得不在开始写代码前考虑更多其实并非非常稳定的代码组织及设计模式的应用问题，那开发效率 当然就大打折扣了。在重构和设计模式的合理应用之下，我们可以相对较早的开始写代码，并在功能尽早实现的同时，不断地通过重构和模式来改善我们的代码质 量。所以，下面的章节中，在谈模式的同时，我也会谈谈关于常用的这些模式的重构成本的理解。重构成本越高意味着，在遇到类似的问题情形的时候，我们更应该 提前考虑应用对应的设计模式，而重构成本比较低则说明，类似的情形下，完全可以先怎么方便，怎么快怎么写，哪怕代码不是很优雅也没关系，回头再重构也很容 易。
1 创建型
1.1 Factory Method
思想：Factory Method的主要思想是使一个类的实例化延迟到其子类。
场景：典 型的应用场景如：在某个系统开发的较早阶段，有某些类的实例化过程，实例化方式可能还不是很确定，或者实际实例化的对象（可能是需要对象的某个子类中的一 个）不确定，或者比较容易变化。此时，如果直接将实例化过程写在某个函数中，那么一般就是if-else或select-case代 码。如果，候选项的数目较少、类型基本确定，那么这样的if-else还是可以接受的，一旦情形变 得复杂、不确定性增加，更甚至包含这个构造过程的函数所在的类包含几个甚至更多类似的函数时，这样的if-else代 码就会变得比较不那么容易维护了。此时，应用本模式，可以将这种复杂情形隔离开，即将这类不确定的对象的实例化过程延迟到子类。
实现：该模式的典型实现方法就是将调用类定义为一个虚类，在调用类定义一个专门用于构造不确定的对象实例的虚函数，再将实际的对象实例化代码 留到调用类的子类来实现。如果，被构造的对象比较复杂的话，同时可以将这个对象定义为可以继承、甚至虚类，再在不同的调用类的子类中按需返回被构造类的子 类。
重构成本：低。该模式的重构成本实际上还与调用类自己的实例化方式相关。如果调用类是通过Factory方 式（此处“Factory方式”泛指对象的实例化通过Factory Method或Abstract Factory这样的相对独立出来的 方式构造）构造的，那么，重构成本相对就会更低。否则，重构时可能除了增加调用类的子类，还要将所有实例化调用类的地方，修改为以新增的子类代替。可能这 样的子类还不止一个，那就可以考虑迭代应用模式来改善调用类的实例化代码。
1.2 Abstract Factory
思想：不直接通过对象的具体实现类，而是通过使用专门的类来负责一组相关联的对象的创建。
场景：最典型的应用场景是：您只想暴露对象的接口而不想暴露具体的实现类，但是又想提供实例化对象的接口给用户；或者，您希望所有的对象能够 集中在一个或一组类（通常称作工厂类）来创建，从而可以更方便的对对象的实例化过程进行动态配置（此时只需要修改工厂类的代码或配置）。
实现：该模式的实现是比较清晰简单的，如上图，就是定义创建和返回各种类对象实例的工厂类。在最复杂而灵活的情形，无论工厂类本身还是被创建 的对象类都可能需要有一个继承体系。简单情形其实可以只是一个工厂类和需要被创建的对象类。不一定非要像上图中结构那么完备（累赘）。
重构成本：中。如果一开始所有的对象都是直接创建，例如通过new实例化的， 而之后想重构为Abstract Factory模式，那么，很自然的我们需要替换所有直接的new实 例化代码为对工厂类对象创建方法的调用。考虑到像Resharper这样的重构工具的支持，找出对 某个方法或构造函数的调用位置这样的操作相对还是比较容易，重构成本也不是非常高。同时，重构成本还和被创建对象的构造函数的重载数量相关。您需要根据实 际情况考虑，是否工厂类要映射被创建对象的所有重载版本的构造函数。
1.3 Builder
思想：将一个类的创建过程和他的主体部分分离。
场景：该模式的典型的应用场景是：一个类的创建过程可能比较复杂，或者创建过程中的某些阶段可能会容易变化；或者多个类的创建过程比较类似， 但是主体不同。
实现：在 以上提到的两种场景中，我们就可以取出一个类的创建过程的代码，定义一个专门的Builder类， 而在原来创建类对象实例的地方，将这个Builder类的实例作为参数传入。还有第二个重点，就是Builder类 可以将将整个创建过程分为几个阶段，每个阶段不必在类中直接实现，而可以通过继承体系在子类中实现，或者通过子类的方法过载来修改创建过程中的某个阶段， 但是重用其他的阶段。可以发现，该模式将一个对象的复杂创建过程重用到非常高的层次。这正是它的意义所在。
重构成本：低。该模式的重构成本我觉得是非常低的，因为一般来讲，创建过程的代码本来也就应该在原来的类的构造函数中，把它Extract出 来就好了。如果发现多个类的创建过程有比较多的代码重复或类似，那么就可以重用这些提取出来的Builder类 或者Builder类中的某些阶段。
1.4 Prototype
思想：克 隆一个已有的类的实例（大家相比都用过甚至写过类的Clone实现，应该很容易理解了）。
场景：应 用Clone的场景应该说非常多，理想情况下我当然希望任何类都能Clone， 需要的时候就能Clone一份一模一样的出来。
实现：这 里将的实现主要之实现的表现形式，而不是如何用具体的语言来实现。因此，只要为需要Clone能力 的类定义一个Clone方法就行。当然，一般，主流的程序语言框架都已经定义了通用的Clone接 口（当然也可以自己定义），继承并实现该接口和方法就好。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/603fd4dcfc8f442adb0a3739f41b15fe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e53ce0d0c7e99530efa7dae532f1d71/" rel="bookmark">
			一些优秀的编程课程下载学习，如Java课程下载，PHP课程下载，前端开发课程下载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这次收集的课程都是属于最新的编程课程，有java，python，前端，大数据开发，以及各种项目实战，非常适合新手入门学习。
也有很多的网友说，没图没真相，那我就把图列出来，大家挑选自己喜欢的。
都是无偿大放送，无套路。
自己点击链接下载表格：
https://545c.com/f/1559942-487442618-b9fb2d（访问密码：6789）
里面是我整理好的word文档，需要保存到自己的网盘哦。
课程收集于网上，仅供大家学习参考，如果有侵权的地方，请联系删除。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6589a956f0c35c4e972a89485cd3dd9c/" rel="bookmark">
			看图猜成语微信小程序源码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 介绍： 后台可以自行设置关卡、等级、也可以一键部署，
开通流量主之后实现躺赚，你懂得。
个人号也可以开通，
审核一次性必过。
类目选择 教育，源码仅供您参考！
网盘下载地址： https://zijiewangpan.com/EXVx0vesNoA
图片： 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31182de34292a12620b375dd6370aab8/" rel="bookmark">
			MYSQL-Ceph的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ceph
Ceph是一个开源的、统一的分布式存储系统，设计初衷是提供较好的性能、可靠性和可扩展性。其中“统一”是说Ceph可以一套存储系统同时提供块设备存储、文件系统存储和对象存储三种存储功能。
Ceph项目最早起源于加州大学Santa Cruz分校的Sage Weil的博士论文所设计开发的新一代自由软件分布式文件系统，其设计目标是良好的可扩展性(PB级别以上)、高性能及高可靠性，并随后贡献给开源社区。在经过了数年的发展之后，目前已得到众多云计算厂商的支持并被广泛应用。
Ceph是一个开源的分布式文件系统。因为它还支持块存储、对象存储，所以很自然的被用做云计算框架openstack或cloudstack整个存储后端。当然也可以单独作为存储，例如部署一套集群作为对象存储、SAN存储、NAS存储等。
官网：http://docs.ceph.org.cn/start/intro/
ceph支持的3种存储方式
1、块存储
首先，什么是块设备？块设备是i/o设备中的一类，是将信息存储在固定大小的块中，每个块都有自己的地址，还可以在块设备的任意位置读取一定长度的数据。例如，硬盘就是块设备。
当给计算机连接块设备（硬盘）后，系统检测的有新的块设备，该类型块设备的驱动程序就在/dev/下创建个对应的块设备设备文件，用户就可以通过设备文件使用该块设备了。
它们怎么有的叫 sda？有的叫 sdb？有的叫 hda？
以sd开头的块设备文件对应的是scsi接口的硬盘，而以hd开头的块设备文件对应的是IDE接口的硬盘。而sda和sdb的区别呢？当系统检测到多个scsi硬盘时，会根据检测到的顺序对硬盘设备进行字母顺序的命名。注：系统按检测顺序命名硬盘会导致了盘符漂移的问题。
怎么还有的叫 rbd1 和 rbd2 呢?
rbd就是由Ceph集群提供出来的块设备。可以这样理解，sda和hda都是通过数据线连接到了真实的硬盘，而rbd是通过网络连接到了Ceph集群中的一块存储区域，往rbd设备文件写入数据，最终会被存储到Ceph集群的这块区域中。
总结一下，块设备可理解成一块硬盘，用户可以直接使用不含文件系统的块设备（裸设备），也可以将其格式化成特定的文件系统，由文件系统来组织管理存储空间，从而为用户提供丰富而友好的数据操作支持。
综上所述，块存储，即rbd。有kernel rbd和librbd两种使用方式。支持快照、克隆。相当于一块硬盘挂到本地，用法和用途和硬盘一样。比如在OpenStack项目里，Ceph的块设备存储可以对接OpenStack的后端存储。
2、文件系统存储
Ceph文件系统（CEPH FS）是一个POSIX兼容的文件系统，可以将ceph集群看做一个共享文件系统挂载到本地，使用Ceph的存储集群来存储其数据，同时支持用户空间文件系统FUSE。它可以像 NFS 或者 SAMBA 那样，提供共享文件夹，客户端通过挂载目录的方式使用 Ceph 提供的存储。
在CEPH FS中，与对象存储与块存储最大的不同就是在集群中增加了文件系统元数据服务节点MDS(Ceph Metadata Server)。MDS也支持多台机器分布式的部署，以实现系统的高可用性。文件系统客户端需要安装对应的Linux内核模块Ceph FS Kernel Object或者Ceph FS FUSE组件。
还记得上面说的块设备上的文件系统吗，用户可以在块设备上创建xfs文件系统，也可以创建ext4等其他文件系统。如下图所示，Ceph集群实现了自己的文件系统来组织管理集群的存储空间，用户可以直接将Ceph集群的文件系统挂载到用户机上使用。
ceph有了块设备接口，在块设备上完全可以构建一个文件系统，那么Ceph为什么还需要文件系统接口呢？
主要是因为应用场景的不同，Ceph的块设备具有优异的读写性能，但不能多处挂载同时读写，目前主要用在OpenStack上作为虚拟磁盘，而Ceph的文件系统接口读写性能较块设备接口差，但具有优异的共享性。
为什么Ceph的块设备接口不具有共享性，而Ceph的文件系统接口具有呢？
对于Ceph的块设备接口，如下图，文件系统的结构状态是维护在各用户机中的，假设Ceph块设备同时挂载到了用户机1和用户机2，当在用户机1上的文件系统中写入数据后，更新了用户机1的中文件系统状态，最终数据存储到了Ceph集群中，但是此时用户机2中的文件系统并不能得知底层Ceph集群数据已经变化而维持数据结构不变，因此用户无法从用户机2上读取用户机1上新写入的数据。
对于Ceph的文件系统接口，如下图，文件系统的结构状态是维护在远端Ceph集群中的，Ceph文件系统同时挂载到了用户机1和用户机2，当往用户机1的挂载点写入数据后，远端Ceph集群中的文件系统状态结构随之更新，当从用户机2的挂载点访问数据时会去远端Ceph集群取数据，由于远端Ceph集群已更新，所有用户机2能够获取最新的数据。
总结一下，Ceph的文件系统弥补了Ceph的块设备在共享性方面的不足，Ceph的文件系统符合POSIX标准，用户可以像使用本地存储目录一样使用Ceph的文件系统的挂载目录，即无需修改你的程序，就可以将程序的底层存储换成空间无限并可多处共享读写的Ceph集群文件系统。
3、对象存储
什么是对象存储
1）对象存储，也就是键值存储，通过其接口指令，也就是简单GET、PUT、DEL和其他扩展指令，向存储服务上传下载数据等
2）对象存储中所有数据都被认为是一个对象。所以，任何数据都可以存入对象存储服务器，如图片、视频、音频等
Ceph 对象存储的构成
Ceph 对象存储主要是通过RGW来实现，那么什么是 RGW 呢？
1）RGW 即 Rados Gateway 的全称。
2）RGW 是 Ceph 对象存储网关，用于向客户端应用程序提供存储界面，提供 RESTful API 访问接口。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/31182de34292a12620b375dd6370aab8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ea4ed9e06ae44a34e758852aa78a531/" rel="bookmark">
			python正则表达式去除C语言文件注释
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		去除C语言文件代码中的注释 采用python正则表达式去除c语言中的注释测试上方的两种表达式删除注释 采用python正则表达式去除c语言中的注释 在学习编译原理的过程中，要写编译器，需提前将要编译的代码中的注释删除，这儿可以用正则表达式进行匹配并删除指定的内容
标准的单行注释正则表达式：
'//.*' 该正则表达式为匹配到‘//’后不断的向后匹配任意字符，直到该行结束
多行注释的正则表达式：
'\/\*(?:[^\*]|\*+[^\/\*])*\*+\/' 该正则表达式是匹配最短的一个“/*”开始 “*/”结尾的字符串，且可实现跨行注释的匹配操作
测试上方的两种表达式 测试代码：
import re bds0 = '//.*' #标准匹配单行注释 bds1 = '\/\*(?:[^\*]|\*+[^\/\*])*\*+\/' #标准匹配多行注释 可匹配跨行注释 target0 = re.compile(bds0) #单行注释 target = re.compile(bds1) #编译正则表达式 f = open('test.c', 'r',encoding='utf-8') #注意 有中文的时候一定要定义编码encoding 不然会报错 data = f.read() result0 =target0.findall(data) print("单行注释：") for i in result0: print(i) result = target.findall(data) print("多行注释：") for i in result: print(i) test.c文件内容：
int main(){ //单行注释测试 //单行注释2 /*单独一行注释测试*/ /*行内多个多行注释*/ printf("测试啊！"); /*跨行注释测试 测试结果*/ } 程序运行结果：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0ea4ed9e06ae44a34e758852aa78a531/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8bbecb18220b4e3fb4d0b87700d98f1/" rel="bookmark">
			mongodb 按时间分组，统计5分钟平均数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		db.getCollection('historyairs').aggregate(
{
'$match': {
macAddress: "440604:001:AAB",
beginTime: {
$gt: ISODate("2019-07-26T09:00:00.000Z"),
$lte: ISODate("2019-07-27T09:00:00.000Z")
}
}
}, {
"$group": {
"_id": { "$subtract": [
{ "$subtract": [ "$beginTime", new Date("1970-01-01") ] },
{ "$mod": [
{ "$subtract": [ "$beginTime", new Date("1970-01-01") ] },
1000 * 60 * 5 /*聚合时间段，30分钟*/
]}
]
},
'SO2': { '$avg': '$SO2' },
'NO2': { '$avg': '$NO2' },
'PM10': { '$avg': '$PM10' },
'PM25': { '$avg': '$PM25' },
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f8bbecb18220b4e3fb4d0b87700d98f1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68a73478759c63f828d8ad2b9dbd9fbf/" rel="bookmark">
			Spring框架中entity层、dao层、service层、mapper层、controller层详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1. entity层
entity就是属性类，通常定义在model层里面，其相当于MVC的M层，属于数据模型层；一般的实体类对应一个数据表，其中的属性定义数据表中的字段，实体类的字段数量 &gt;= 数据库表中需要操作的字段数量。 2. dao层
dao层叫做数据访问层，全称为data access object，属于一种比较底层基础得操作，具体到对某个表得增删改查，换句话说，某个dao一定是和数据库中的某一张表一一对应的，而且其中也只是封装了增删改查得方法。 3. service层
service层即为业务逻辑层，可以理解为对一个或者多个dao进行得再次封装，主要是针对具体的问题的操作，把一些数据层的操作进行组合，间接与数据库打交道(提供操作数据库的方法)。要做这一层的话，要先设计接口，再实现类。 4. controller层
负责请求转发，接收页面过来的参数，传给service处理，接到返回值，并再次传给页面。 5. mapper层
数据存储对象，相当于DAO层，mapper层直接与数据库打交道(执行SQL语句)，接口提供给service层。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a369bea41916b8bd29d04b2d4deb132/" rel="bookmark">
			树莓派 查看CPU实时频率、占用率
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		树莓派上默认的任务管理器只能查看CPU使用率，无法查看运行频率等信息，功能太弱，没有windows的好使。
找了好半天，都说是通过
cat /proc/cpuinfo cat /proc/meminfo 来查看CPU或者内存信息，但是里面并没有啥东西。
然后看到的就是一些C的代码，或者python的代码来获取的。难道没有一个简单的方法吗？
于是乎看到了这个，太实用了。
安装一下：
sudo pip install s-tui 然后启动运行：
sudo s-tui 效果如下：
非常的漂亮~~~
另外如果要看网速还有一款不错的工具：
sudo apt-get install speedometer 启动运行，查看有线网卡如下：
speedometer -r eth0 -t eth0 如果是用的无线网卡，如下：
speedometer -r wlan0 -t wlan0 效果如下：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0978a1580db305e736a48247f7199314/" rel="bookmark">
			前端学习——JavaScript原生实现购物车案例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一. 购物车案例 1.1 案例介绍 今天我们来写另外一个购物车案例，说实话对于我来说这个是花了将近三个小时的时间然后才做出来的，里面可能还存在一些我没有发现的问题，但是能完成基本的功能，对于一些基本的需求都是可以完成的，下面照旧是案例实现的gif图片
根据上图我们可以看到，每个购物车的选项都是互不影响的，每个商店也都是互不影响的，单独运算，每个店的总计也是单独计算的，有一个计算复选框总价的功能，而且这是个通用的模板，不论有多少个店铺，店铺里面的商品有多少个，只要html的结构不变都是可以通用的，那么不多说，下面开始分析案例！
1.2 案例分析 下面给出相应的html结构的代码，便于我们进行分析
&lt;!doctype html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta name="format-detection" content="telephone=no"&gt; &lt;meta name="viewport" content="user-scalable=no, width=device-width, initial-scale=1.0, maximum-scale=1.0"&gt; &lt;title&gt;购物车&lt;/title&gt; &lt;link type="text/css" rel="stylesheet" href="css/base.css" /&gt; &lt;link type="text/css" rel="stylesheet" href="css/module.css" /&gt; &lt;/head&gt; &lt;body&gt; &lt;!--头部开始--&gt; &lt;div class="header"&gt; &lt;h1&gt;购物车&lt;/h1&gt; &lt;a href="#" class="back"&gt;&lt;span&gt;&lt;/span&gt;&lt;/a&gt; &lt;a href="#" class=""&gt;&lt;/a&gt; &lt;/div&gt; &lt;!--头部结束--&gt; &lt;div class="shopping"&gt; &lt;div class="shop-group-item"&gt; &lt;div class="shop-name"&gt; &lt;input type="checkbox" class="check goods-check shopCheck"&gt; &lt;h4&gt;&lt;a href="#"&gt;苹果专卖店&lt;/a&gt;&lt;/h4&gt; &lt;div class="coupons"&gt;&lt;span&gt;领券&lt;/span&gt;&lt;em&gt;|&lt;/em&gt;&lt;span&gt;编辑&lt;/span&gt;&lt;/div&gt; &lt;/div&gt; &lt;ul&gt; &lt;li&gt; &lt;div class="shop-info"&gt; &lt;input type="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0978a1580db305e736a48247f7199314/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7118cd59902fab47a6ebc09bf1e83a2a/" rel="bookmark">
			resize训练集图片大小并存储的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们做深度学习训练时，需要大量的图片（数据），这些图片往往尺寸不一，也不是我们input的尺寸需求。如果我们能在训练前就将这些图片resize成需要的尺寸，那么训练过程将会非常省时省资源的。
resize图片大小的方法有两种：
一、#直接基于原图片中心点为中心，以原图片较短边切割成边长为原长方形较短边为边长的正方形
代码如下：
''' [1] #直接基于原图片中心点为中心，以原图片较短边切割成边长为原长方形较短边为边长的正方形 #如test.jpg和crop_img.jpg,部分长宽比例较大的图形经过切割可能会丢失重要的信息，故一般不用！ import matplotlib.image as mpimg def load_image(path): # 读取图片，rgb img = mpimg.imread(path) # 将图片修剪成中心的正方形 short_edge = min(img.shape[:2]) yy = int((img.shape[0] - short_edge) / 2) xx = int((img.shape[1] - short_edge) / 2) crop_img = img[yy: yy + short_edge, xx: xx + short_edge] mpimg.imsave('crop_img',crop_img) return crop_img load_image('./test.jpg') ''' 输入图片
输出图片
显而易见：如果按照方法一做简单的切割，很容易丢失大量有用的信息，导致训练正确率低，甚至出现错误，故我们一般不用这种方法
二、#推荐的resize并存储的方法如下（双线性插值，或者双三次插值）
代码如下
[2]#推荐的resize并存储的方法如下 ''' 1、我们将搜集到的图片存放在与软件脚本同一根目录下的'./data/image/pre_train/'文件夹下； 2、我们使用Image模块从pre_train文件夹读取图片，resize，并存储入'./data/image/train/'文件夹； ''' from PIL import Image import os src_path = '.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7118cd59902fab47a6ebc09bf1e83a2a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3751e8bf910d23b65c9f99f29886910d/" rel="bookmark">
			realsense viewer.exe的下载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://github.com/IntelRealSense/librealsense/releases
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41b0d0f2848e3805048d9b782af5cb47/" rel="bookmark">
			markdown工具推荐，Windows下设置自己的图库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		typora 是一个文本编辑器，可以用来写markdown等
配置typora
选文件=》偏好设置=》图像 设置：
插入图片时，选择复制到指定路径选择上传服务使用windows_images.bat脚本 windows_images.bat
windows 配置完成
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92c39f9de50f293b8f6f3720ede142f0/" rel="bookmark">
			线性表元素的区间删除（c语言）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		线性表元素的区间删除 题目答案注意 题目 答案 List Delete( List L, ElementType minD, ElementType maxD ) { int i,j=0; for(i=0;i&lt;=L-&gt;Last;i++) { if(L-&gt;Data[i]&gt;minD&amp;&amp;L-&gt;Data[i]&lt;maxD) continue; else L-&gt;Data[j++]=L-&gt;Data[i]; } L-&gt;Last=j-1; return L; } 注意 这里的Last就是数组最后一个数字的下标，如果数组有10个数，Last的值就为9
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f90deefabc6cb4a16ef6327627555be/" rel="bookmark">
			WPS表格级联菜单设置方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我没想到我一个做Java开发的人，有一天居然要去学一些Excel的技巧。
事情是这样的，因为有个业务需要用户根据模板填写并导入，模板自然就需要由我来设计及提供，根据用户要求，有些数据需要根据前一个选项带出后一个可选择项，其实呢，就是一个二级联动下拉列表。
下图示例：第一行为一级下拉列表，每一列从第二行开始都为第一行的二级列表，现在我要实现的效果就是选择其中某一个手机品牌，能够带出旗下不同型号选择。
第一步：先设计好一级及其对应的二级，作为数据来源；
第二步：选中数据源，选择菜单栏-公式-指定
第三步：只勾选首行，点击确定生成名称及其对应的数值。可以通过“名称管理器”查看或修改。
第四步：新建一个sheet，我们在sheet2设计我们的二级联动下拉列表。在A2点击“有效性”设置下拉列表
第五步：在B2点击“有效性”设置下拉列表，在来源手动输入：=INDIRECT($A2)。这里要注意一下，需要在A2先选中一个值，不然直接这样设置会报错。
到这里就设置成功啦，下面的行直接继承上面的设置就可以了，把鼠标定位到方格的右下角，显示黑色的+，直接拉下来就可以了。
这里只展示二级联动下拉列表，多级联动下拉列表也是类似的操作，就不展开啦！
第一次写这种教学步骤帖，可能写得不是很好，这里给大家提供另外一个帖子参考https://jingyan.baidu.com/article/e75aca85be463f552edac6bf.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8539c52947d5ca888cbef9f32b586a9d/" rel="bookmark">
			gitlab仓库代码转移到新的分组
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 代码仓库地址codeA已经存在于一个分组中比如groupA，现在需要转移到分组groupB：
1、groupB新建一个仓库比如：codeB
2、进入原来本地代码仓库地址
cd existing_repo 3、执行命令
git remote rename origin old-origin 4、指定新的仓库
git remote add origin git@仓库地址自己替换/codeB.git 5、推送代码
git push -u origin --all git push -u origin --tags 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c75e940958262e5e6340e9183e3982a1/" rel="bookmark">
			通过AI深度学习实现骑车不戴头盔和两轮电动车摩托车号牌识别算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 去年在深圳交警的一个项目是，要在宝安区某点试点抓拍未戴头盔的电动车骑车行为，而且需要将电动车号牌识别出来，经过技术论证，采用AI深度学习+传统车牌识别算法相结合的方式，实现此功能，我带领程序员小老弟们经过8个月的奋战，终于实现了这个算法，效果还相当棒，而且还能支持在800W像素下工作,令人惊奇，真是无AI，不编程啊。
总结一下，通过AI深度学习实现骑车不戴头盔和两轮电动车摩托车号牌识别算法具有如下特征：
1.速度快到你不敢想象，通过tensorflow 训练出算法库后，再由TensorRT 推理形成更为快速度检测库，速度令人叹为观止，在GTX 1050 ti这种几百元的显卡用Cuda加速，1080p检测一帧，竟只需要 16ms
2.精度高，经过大量样本，针对各种电动车、摩托车、头盔（安全帽）深度学习后，在60*60像素以上的目标检测识别率可达到接近100%
3.融合电动车号牌识别，可以在发现未戴安全帽时再识别两轮电动车摩托车的车牌号码，效果大大提高，不需要每帧进行电动车的号牌识别
4.算法包小型号，整包不足50Mb，占用内存少
5.跨平台支持，可以在Intel X86硬件平台，Arm硬件平台上运行，支持Windows系统，Linux系统，Arm系统
项目实战运行图:
项目骑车不戴头盔行为抓拍效果 电动车车牌识别DEMO测试效果:
电动车号牌识别效果 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3358ab34e941bd582d261ac1a71b2543/" rel="bookmark">
			matlab selection函数,如何学会使用BagSelection函数？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		BagSelection用于存储rosbag选择的对象描述BagSelection对象是rosbag中消息的索引。 您可以使用它从rosbag中提取消息数据，根据特定条件选择邮件，或创建消息属性的时间序列。使用rosbag加载rosbag并创建BagSelection对象。使用select按时间和主题等条件过滤rosbag。创建句法bag = rosbag(filename)bagsel = select(bag)描述bag = rosbag(filename)创建一个可索引的BagSelection对象bag，其中包含rosbag在输入路径filename下的所有消息索引。 要访问数据，可以调用readMessages或时间序列来提取相关数据。有关其他语法，请参见rosbag。bagel = select(bag)返回一个对象bagsel，其中包含BagSelection对象bag中的所有消息。此函数不会更改原始BagSelection对象的内容。 返回对象Bagsel是一个包含指定消息选择的新对象。请参阅select以获取其他语法，并按时间和主题等条件进行过滤。属性FilePath — rosbag文件的绝对路径(字符向量)此属性是只读的。rosbag文件的绝对路径，指定为字符向量。数据类型：charStartTime —选择中的第一条消息的时间戳(标量)此属性是只读的。所选内容中第一条消息的时间戳，以秒为单位指定为标量。数据类型：双精度EndTime-选择中最后一条消息的时间戳标量此属性是只读的。所选内容中最后一条消息的时间戳，以秒为单位指定为标量。数据类型：双精度NumMessages —选择标量中的消息数此属性是只读的。所选内容中的消息数，指定为标量。 首次加载rosbag时，此属性包含rosbag中的消息数。 使用select选择消息的子集后，该属性将显示该子集中的消息数。数据类型：双精度AvailableTopics —选择表中的主题表此属性是只读的。选择中的主题表，指定为表。 表中的每一行都列出一个主题，该主题的消息数，消息类型以及类型的定义。 例如：数据类型：表AvailableFrames —字符向量的可用坐标系单元列表此属性是只读的。可用坐标系列表，以字符向量的单元格数组形式返回。 使用canTransform检查帧之间的特定转换是否可用，或使用getTransform查询转换。数据类型：单元格数组MessageList —选择中的消息列表(表)此属性是只读的。所选内容中的消息列表，指定为表格。 表中的每一行列出了一条消息。数据类型：表对象功能canTransform 验证转换是否可用getTransform 检索两个坐标系之间的变换readMessages 阅读来自rosbag的消息select 在rosbag中选择消息子集timeseries 为所选消息属性创建时间序列对象示例使用BagSelection对象创建rosbag选择加载rosbag日志文件，并根据所选条件解析特定消息。在rosbag日志文件中为所有消息创建一个BagSelection对象。根据消息的时间戳和主题选择消息的子集。以单元格数组的形式检索选择中的消息。msgs = readMessages(bagMsgs2);返回某些消息属性作为时间序列。从rosbag检索信息从rosbag检索信息。如果rosbag在MATLAB路径上尚不可用，请指定它的完整路径。选择消息的子集，并按时间和主题过滤。从文件显示rosbag信息要查看有关rosbag日志文件的信息，请使用rosbag info文件名，其中filename是rosbag(.bag)文件。从rosbag文件获取转换通过加载rosbag并检查可用的帧，从rosbag(.bag)文件中获取转换。 从这些框架中，使用getTransform查询两个坐标框架之间的转换。加载rosbag。获取可用框架的列表。frames = bag.AvailableFrames;获取两个坐标系之间的最新变换。检查在特定时间可用的转换并检索该转换。 使用canTransform检查转换是否可用。 使用rostime指定时间。tfTime = rostime(bag.StartTime + 1);end从rosbag读取消息作为结构加载rosbag。选择一个特定的主题。阅读消息是一种结构。 阅读消息时，请指定“数据格式”名称/值对。 检查返回的单元格数组中的第一个结构。msgStructs{1}从消息中提取xy点，并绘制机器人轨迹。 使用cellfun从结构中提取所有X和Y字段。 这些字段表示在rosbag记录期间机器人的xy位置。xPoints = cellfun(@(m) double(m.X),msgStructs);yPoints = cellfun(@(m) double(m.Y),msgStructs);plot(xPoints,yPoints)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7cb4c7f5f2ecdfb81457e580af92165d/" rel="bookmark">
			安装k8s
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		准备环境 设置主机名与时区 timedatectl set-timezone Asia/Shanghai hostnamectl set-hostname master 配置hosts文件 vim /etc/hosts 关闭防火墙 sed -i 's/SELINUX=enforcing/SELINUX=disabled/g' /etc/selinux/config setenforce 0 systemctl disable firewalld systemctl stop firewalld 安装k8s mkdir /usr/local/k8s-install &amp;&amp; cd /usr/local/k8s-install rz 上传 kubernetes-1.14.zip 包含以下的文件 admin-role.yaml daemon.json docker-ce-18.09.tar.gz flannel-dashboard.tar.gz init.sh k8s-114-images.tar.gz k8s.conf kube-flannel.yml kube114-rpm.tar.gz kubernetes-dashboard-admin.rbac.yaml kubernetes-dashboard.yaml worker-node.sh # 解压 unzip kubernetes-1.14.zip # 安装docker cd /usr/local/k8s-install/kubernetes-1.14 tar -zxvf docker-ce-18.09.tar.gz cd docker yum localinstall -y *.rpm systemctl start docker systemctl enable docker # 正常的结果是cgroupfs docker info | grep cgroup # 安装kubeadm # kubeadm是集群部署工具 cd /usr/local/k8s-install/kubernetes-1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7cb4c7f5f2ecdfb81457e580af92165d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa256019366f52c6243d141bbc0d1d7f/" rel="bookmark">
			php使用github上传文件,PHP调用Github API结合jsdelivr作对象存储（文件转链接）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		昨天在水群的时候发现群主为了方便管理，设置了群文件仅能由管理员上传。对于偌大的一个群来说确实能防止很多问题，不过有时也略显不方便，因此感觉自己发现了商机开发了一个这样的网页，也可以将其作为方便的对象存储使用。
思路简介
想法的产生
目前市面上有许多免费空间，它们大多数都仅支持PHP，所以作为一个贫穷的学生党，使用PHP进行开发也是可以理解的。
相信大家都知道Github这个平台，人人都可以在其中建立repo，且没有限制大小，相当于一个免费的对象存储了，不过由于服务器的位置问题，速度还是比较慢。
所以这里就用到了jsdelivr提供的免费CDN服务，仅需对github的链接作一下变换即可得到由jsdelivr加速的链接，其访问速度可以说是非常之快了。
由此便产生了使用php+Github+jsdelivr进行开发的想法
具体的思路
首先需要解决的是php调用Github API的问题。虽然笔者对php基本一窍不通，但是毕竟学过一些基础的编程，于是上来就找了一番Github官方的文档：https://developer.github.com/v3/guides/ ，此外我还对照参考了其他语言调用Github API上传文件的一些代码资料。
其次需要解决的是前端的问题，这方面比较容易，但时间消耗也比较大，为了好看，我使用了ZUI框架对界面进行了美化。
PHP上传文件
PHP可使用curl进行一些HTTP操作，上传文件主要用的是HTTP中的PUT请求，对此我随便搜了一个封装好的轮子：http://www.thisbug.com/archives/149
需要注意的是，调Github的API时需要在请求头headers中设置User-Agent为自己的用户名，还要设置Authorization为token附上自己在github的settings中生成的token。
前端构造
前端是一个HTML页面，内含一个打开文件的按钮和一个上传的按钮，并支持拖放功能。
点击打开文件按钮后，将会在页面中产生一个卡片，卡片内容为文件名，以及一个移除按钮，并将文件的base64编码、文件名存入js里的数组。
点击上传按钮后，会调用Ajax进行POST操作，将文件的base64编码及文件名传入PHP后台上传至Github的repo中，PHP后台处理成功后将返回一个经jsdelivr加速的文件链接，Ajax接收这一信息后继而将链接做成一个复制按钮放入对应的卡片中。
代码及成品
本篇文章由一文多发平台ArtiPub自动发布
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26ffffc189340baf59f44e692f728b3e/" rel="bookmark">
			基于动态规划DTW算法加速衡量两个不同的时间序列的相似性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是DTW？ DTW算法采用了动态规划DP（dynamic programming）的方法来进行时间规整的计算，可以说，动态规划方法在时间规整问题上的应用就是DTW。
为什么需要DTW算法 当两个序列按照时间步t完全对齐的时候，我们可以直接使用ED算法（或者其它距离计算）来评估两个算法的相似度。但是有些时候两个序列并未完全对其，如果我们将某一序列进行压缩处理，此时会有信息损失。那么是否可以将两个长度不一样的序列进行对齐，然后再进行距离计算，DTW算法可以完成这个任务。
如图所示，这两个序列整体上波形很相似，但是在时间轴上确实对不齐的，所以这样如果按照时间步t对应来求距离显然会出问题。
为了解决这个问题，我们需要进行对齐操作：
如图所示，就是应用DTW算法之后的对齐之后的效果图，那么此时我们对两个序列的对应点之间计算距离，此时才是这两个序列的真实距离。
DTW的核心问题？ DTW核心是将两个不同的序列按照最好的方式对齐，而如何才是最好对齐呢？对齐的方式有很多，最好的对齐方式就是两个序列的距离最小，同时这个最小的距离就是这两个序列的距离。
如图所示，两条完全不同的序列Q，C，如何才能对齐呢？
假设Q的序列长度为n，而C的序列长度为m，那么我们需要构建一个n*m的矩阵，其中矩阵元素（i，j）表示Qi和Cj之间的距离。每个矩阵元素表示Qi和Cj对齐，那么从矩阵左下角到右上角可以找到很多路径（为什么是从左下角到右上角，因为两个不同的序列无论长短，它们的起始点和终止点肯定是对应的），这个矩阵包含了所有的对齐路径，DP算法就是要找到一条最短的路径。
路径的性质 首先这条路径需要满足一定的性质，它可以帮助算法对路径进行规范。
边界条件：必须从矩阵的左上角到矩阵的右上角
连续性：路径需要是连续的，不能跨越某点去匹配，（跨越其实也行，这样会有信息损失）
单调性：路径必须随着时间单调进行，这样路径不会出现相交的情况。
连续性和单调性决定了路径中每一个格点只有三个方向，如果当前格点为（i，j），那么下一个格点只能是下面的三种情况（i+1，j）、（i，j+1）、（i+1，j+1）
当然如果连续性中考虑跨越的情况，那么可能来自五个方向，此时从(m-2,n-1)到（m，n）会有信息损失
本文中我们只考虑三种方向的情况。
动态规划关系表达式 现在我们已经知道了路径的规范条件了，那么这个问题的动态规划关系表达式为：
我们拿g(i,j)=g(i-1,j)+d(i,j)来举例，g(i-1,j)我们可以认为是起点到g(i-1,j)的最短距离，然后d(i,j)表示Qi与Cj之间的距离。
为什么有d还有2d呢？
这个可以理解为人为设定的，我们这里设定当路径横着走还有竖着走的时候，就是d，当路径斜着走的时候就是2d，也就是此时我们设定斜着走的时候损失大一些，d可以认为是损失。
现在有两个序列R和T，现在我们构建了一个矩阵，我们要找到从左下角到右上角的最短路径，每个格子中数字表示Ri和Tj的距离，右上角表示总距离。我们来看一下B2是如何计算的：
如果只能从三个方向来走的话，B2可以认为来自B1、A1、A2，通过上面的动态规划关系式可以算出来
A1+2B2=4+24=12
B1+B2=7+4=11
A2+B2=5+4=9
所以从起点到B2的最短距离就是9，我们可以通过这种方式计算出格子的所有的点，那么最终我们可以算出从起点到F4的最短距离就是26，这就是动态规划，而动态规划在时间序列的应用就是DTW算法。
但是这里就有一个问题了？以上仅仅比较两条路径就要计算这么多，如果多条路径C与Q进行匹配，那么这个计算量就太大了，也就是说时间复杂度太高了，需要进行算法的改进。所以人们在使用DTW算法的时候就会使用一些技巧，以次来提高计算速度。
一些技巧
去根号计算
当使用DTW算法的时候，需要计算Q与C之间不同i，j之间的距离，那么往往需要较大的计算量
我们可以看到我们的目的是为了寻找最小的计算量，而去掉根号不影响其大小的比较，而根号的计算需要耗费较多时间，所以一个技巧就是去掉根号。
Lower Bounding
如果正常的计算Q和C之间的DTW距离，这样计算量很大，我们可以为Q设置上下界（U和L），然后使用U和L和C进行距离计算（C和U、L之间直接通过对应时间步计算，不用对齐），这个距离属于估算，如果估算出来的这个距离大于设置阈值，我们就认为Q和C之间的差距太大了，二者不匹配。Lower Bounding存在两个算法变种：LB-kim和LB-koegh
LB-kim：
直接找到Q和C的四个对应的点，起始点，终点，最高点，最低点，计算这四个点的距离和，如果超过阈值，那么我们就认为这个Q和C不匹配。
LB-koegh：
直接找到Q和C的两个对应的点，最高点和最低点，如果超过阈值我们就认为这个Q和C不匹配。
我们可以看出来这两种方式计算的点比较少，所以计算量极少，速度会很快，但是会有问题，就是不精确，仅仅通过几个点就确定了序列的匹配程度，这样会有误差的。
Early Abandoning of ED and LB_Keogh
这个是将ED和LB进行结合，因为ED计算（DTW）比较精确，但是计算量大，而LB比较粗略，但计算量小，我们将二者结合，如图所示，我们将k=11之前使用DTW计算，K=11之后我们使用LB来计算，此时我们将二者加起来，如果这个超过阈值，我们就可以认为Q和C不匹配
一些新的技巧总结
Early Abandoning Z-Normalization
我们在使用DTW算法的时候，往往需要对数据进行归一化操作，这样可以提高效率
归一化操作
那么如果先进行归一化再进行动态规划，这样的问题就是一旦Q和C不匹配，那么就对C白白归一化了，那么我们可以这样的，每标准化一点就对这点进行ED计算，如果计算过程中总距离一旦超过阈值，就立即停止计算，以后的也不用进行归一化了，这样后面的点就不用归一化了，这样计算量就减少了。
Reordering Early Abandoning
DTW计算的时候，一般从序列匹配的起点开始计算，我们发现当计算到第9个时间步的时候，那么就发现它超过了阈值，我们就认为二者是不匹配的，就停止计算了
现在我们计算的时候不从起点开始计算，比如我们可以从中间的某个特殊的时间步（一般是Q中距离均值0比较远的序列段，用这段来和C进行距离计算，这个序列段再标准化的过程中就可以找到）计算。论文中的reorder early abounding 这部分的做法是对Q序列进行norm处理，然后对所有时间点元素值取绝对值，最后进行降序排列，以此来找到异常点？
这样，我们只计算（直接按照时间步计算距离，估算）了五个时间步就发现，Q和C距离超过阈值，二者是不匹配的，这样就直接停止计算。
以Q为基础的LB和以C为基础的LB
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/26ffffc189340baf59f44e692f728b3e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5bbebe8dc374c44ec70c7bd783aa6936/" rel="bookmark">
			view_frames中错误: cannot use a string pattern on a bytes-like object
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#在noetic版本ros中运行view_frames工具时报错
Listening to /tf for 5.0 seconds
Done Listening
b’dot - graphviz version 2.43.0 (0)\n’
Traceback (most recent call last):
File “/opt/ros/noetic/lib/tf/view_frames”, line 119, in generate(dot_graph)
File “/opt/ros/noetic/lib/tf/view_frames”, line 89, in generate
m = r.search(vstr)
TypeError: cannot use a string pattern on a bytes-like object
通过编辑器打开view_frame.py文件
sudo gedit /opt/ros/noetic/lib/tf/view_frames
我们查看view_frame.py文件报错处的代码
m = r.search(vstr)
通过分析得知search函数需要输入str类型数据，而vstr不是str类型，所以我们可以强制转换其为str类型数据，如下所示：
vstr=str(vstr)
m = r.search(vstr)
之后运行成功：
Listening to /tf for 5.0 seconds
Done Listening
b’dot - graphviz version 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5bbebe8dc374c44ec70c7bd783aa6936/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0cf4663d134b8b4102e5fd3d4173f283/" rel="bookmark">
			运维小技巧
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e583fcfa276fffe00d3e3bc6ad73aff/" rel="bookmark">
			VMware打不开文件“xxx\.xxx.vmkd”，系统找不到指定的文件-----最佳解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		突如其来的错误 花费了些时间搭建的VMware渗透测试主机，今天打开突然出现了这个情况！！
error：打不开文件“D:\testwin10\Windows 10渗透-000002.vmdk”: 系统找不到指定的文件。
如下图所示
网上找了很多的方案但是并没能正确的解决。
问题所在 根据提示是文件出现了问题。
可以看到是我这里少了一个文件导致的这个问题。毕竟这是用来做安全的一台虚机，所以我猜测应该是被Windows Defender给删除了，然而我一开始并没有发现并且彻底删除了这个文件。。。。。所以如果是发现早的朋友可以去Windows Defender里面恢复，这么恢复所有文件都不会丢失。
下面我要介绍的是和我一样情况，就是没有第一时间发现文件被Windows Defender 和谐，发现后又已经做了些无法挽回的事情，接下来该怎么办。
最佳解决方案 第一步删除选中的所有文件，我的情况是因为又快照，如果没有快照的朋友可以尝试直接复制
”Windows 10渗透-000002-s006.vmdk 改名为Windows 10渗透-000002-s007.vmdk“
用做代替
好了接下来是第二步
打开虚拟机所在文件夹
删除如下后缀的几个文件
*.lck
*.vmsd
*.vmsn
结果检查 这里我们选择浏览 选择
Windows 10渗透-000001.vmdk
可以打开了系统出现了错误，不用着急能打开就是最好的消息。
重启过后已经可以正常进入系统了。
这么做虚拟机内容会恢复到上次创建的快照，文件丢失情况还可以接受。
最终结果展示
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3faf0042542de60794fed495b80fc312/" rel="bookmark">
			lintcode 625 数组划分
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		/** * 将一个没有经过排序的整数数组划分为 3 部分: * 1.第一部分中所有的值都 &lt; low * 2.第二部分中所有的值都 &gt;= low并且 &lt;= high * 3.第三部分中所有的值都 &gt; high * 返回任意一种可能的情况。 *输入: * [4,3,4,1,2,3,1,2] * 2 * 3 * 输出: * [1,1,2,3,2,3,4,4] * 解释: * [1,1,2,2,3,3,4,4] 也对, 但 [1,2,1,2,3,3,4,4] 不对 * */ public class Test { public static void main(String[] args) { int nums[] = new int[]{4,3,4,1,2,3,1,2}; partition2(nums,2,3); for (int num : nums) { System.out.print(num + " "); } } public static void partition2(int[] nums, int low, int high) { if(nums==null || nums.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3faf0042542de60794fed495b80fc312/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6008537ebc1785a57493aa9338f96bb/" rel="bookmark">
			typedef struct 的用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 结构体类型定义 定义方式1：
Typedef struct LNode { int data; //数据域 struct LNode *next; //指针域 } *LinkList; 定义方式2：
struct LNode { int data; //数据域 struct LNode *next; //指针域 }; typedef struct LNode *LinkList; 以上两个定义方式是等价的。是将 *LinkList 定义为 struct LNode 类型，即 LinkList 被定义为一个类型名。这样就可以用 LinkList 来定义说明新的变量了，如：LinkList L; 即将 L 定义为 struct LNode 类型的指针变量。 结构体类型变量定义 定义方式1：
struct LNode { int data; //数据域 struct LNode *next; //指针域 }LnodeA; 定义方式2：
struct LNode { int data; //数据域 struct LNode *next; //指针域 }; struct LNode LnodeA; 以上两个定义方式也是等价的。这样就将 LnodeA 定义为一个 struct LNode 类型的变量，即 LnodeA 为一个 struct LNode 类型的变量名。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc9926f3967a1b60293d01dac6dcede1/" rel="bookmark">
			Gitbash使用（二）——一些命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.基础命令： cd+路径 进入目录中 cd即Change directory改变目录
ls 查看当前路径下所有文件夹
如下图：先使用ls命令查看一共有多少文件夹
然后cd Desktop/ 进入Desktop文件夹
2.新建和删除文件夹 mkdir +文件夹名字 2.1 如果不改变路径，一般在C盘，可以看到C盘下新增new文件夹
2.2 如果不知道新建文件夹路径在哪，先ls查看所有目录，找到自己的新建文件夹后cd进入，然后pwd查看路径即可，步骤如下：
这里当然也可以通过改变路径来使文件夹建立在不同目录下
此处我是建立在e盘下。通过cd e:可以从C盘进入E盘
2.3 使用 rm -r +文件夹名字 删除文件夹
先进入e盘，通过rm -r new.可以看到 e盘下的new文件被删掉了
3.新建和删除文件 touch +文件名
这里我在e盘的new文件下新建new1文件，并通过ls命令查看new文件下只有new1这一个文件，新建文件成功
删除文件
rm ＋文件名+文件类型 可以看到pictures下的第一张图片被成功删除
4.退出文件夹 使用cd 可以从任意路径下直径返回最初路径
使用cd ..返回上一层路径
5.解压缩文件 5.1 .zip文件
解压缩
unzip all.zip 解压缩all.zip的所有文件
压缩
zip all.zip *.jpg 将所有jpg文件打包成all.zip压缩文件
**
5.2 .tar文件
解压缩
tar -xf all.tar 将all.tar中的所有文件解压缩出来，-x是解开意思
查看
tar -tf all.tar 列出all.tar包中所有文件，-t是列出文件的意思
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cc9926f3967a1b60293d01dac6dcede1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/146d02701e3943d8e783406200fe3b1c/" rel="bookmark">
			3.关于运动控制芯片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在看stm32控制：步进，直流有刷，直流无刷电机。无刷电机可以分为无刷直流电机（BLDC）方波控制和永磁同步电机（PMSM）正弦波控制。
看完之后感觉自己玩玩还行，真的要去实践应用还是有很长的路要走，感觉还是要有专业的运动控制芯片来做这件事情比较好。顺便查了下目前的的运动控制芯片
记录一下。
//日本NOVA公司运动控制芯片
MCX302两轴芯片，不带插补功能
MCX304四轴芯片，不带插补功能
MCX312两轴芯片，带插补功能
MCX314As四轴芯片，带插补功能
//日本KYOPAL公司运动控制芯片
X7000运动控制芯片：两轴芯片X7023、四轴芯片X7043、八轴芯片X7083
X3000运动控制芯片：X3201、X3202、X3203A、X3301
//PMD公司运动控制芯片
Magellan系列运动控制芯片
Navigator系列运动控制芯片
Pilot系列运动控制芯片
运动控制芯片开发包
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88a65423984477a46c1a7b8b5344e27e/" rel="bookmark">
			说一下从 url 输入到返回请求的过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 年前准备换工作，总结了一波面试最频繁的面试问题跟大家交流。此文章是关于浏览器的常见问题，大概面试10家遇到6家提问类似问题（主要是大厂和中厂）。（面试的部分内容已经忘了，为了串联成一个完整的故事，增加可读性，20%的内容为虚构），目前入职滴滴出行成都团队。
问题: 从浏览器地址栏输入url到请求返回发生了什么
你一看这种烂掉牙的问题，小case，但996面试大佬由此延展的问题已经远远超越了这个问题本身了，不信你就接着看。
我回答了首先会进行 url 解析，根据 dns 系统进行 ip 查找。
话音刚落，此时一位喜欢修福报的公司的大佬打断了我，说url为啥要解析，dns查询规则是什么？我一听就心里想，不按套路出牌啊，网上一般都没问这两个问题，心里再一想，俗话说，万事开头难，扛过这一波，答出来，就是阳光明媚，万物骚动的春天！
先说为什么url要解析（也就是编码)
我回答大概内容是：因为网络标准规定了URL只能是字母和数字，还有一些其它特殊符号（-_.~ ! * ' ( ) ; : @ &amp; = + $ , / ? # [ ]，特殊符号是我下来查的资料，实在背不住这么多，比较常见的就是不包括百分号和双引号），而且如果不转义会出现歧义，比如http:www.baidu.com?key=value,假如我的key本身就包括等于=符号，比如ke=y=value，就会出现歧义，你不知道=到底是连接key和value的符号，还是说本身key里面就有=。
大佬接着毒打我说，那url编码的规则是什么呢，我说utf-8
大佬接着穷追不舍，为啥是utf-8呢，所有浏览器都是这样吗？中文的话用gb2312编码吗，还有就是万一浏览器不是你说的这样统一用utf-8，你怎么保证都是utf-8的编码?
我支支吾吾的说，我了解的大概是这样，不太清楚, 应该和html本身的编码格式有关，然后怎么保证utf-8的编码，我觉得可以用encodeURIComponent
大佬说encodeURIComponent比encodeURI有什么区别?
区别就是encodeURIComponent编码范围更广，适合给参数编码，encodeURI适合给URL本身（locaion.origin）编码,当然项目里一般都是用qs库去处理
然后说说dns解析流程，并且html如何做dns优化
首先dns这个属于很久以前在计算机网络谢希仁版看到过了，有一些细节忘了，但是大致流程是记得的。比如说查询一个网址为：www.baidu.com
1、器中输入https://www.baidu.com 域名，操作系统会先查hosts件是否有记录，有的话就会把相对应映射的IP返回。
2、hosts文件没有就去查本地dns解析器有没有缓存。（这个我没答上来）
3、然后就去找我们计算机上配置的dns服务器上有或者有缓存，就返回
4、还没有的话就去找根DNS服务器(全球13台，固定ip地址)，然后判断.com域名是哪个服务器管理，如果无法解析，就查找.baidu.com服务器是否能解析，直到查到www.baidu.com的IP地址
注:后面查资料才发现dns查询有两种模式，一种是转发模式，一种是非转发模式，我上面说的4是非转发模式。
前端的dns优化，可以在html页面头部写入dns缓存地址，比如
&lt;meta http-equiv="x-dns-prefetch-control" content="on" /&gt; &lt;link rel="dns-prefetch" href="http://bdimg.share.baidu.com" /&gt; 终于抗过了第一轮的猛问，接着我继续说从浏览器地址栏输入url到请求返回发生了什么？
查找到IP之后，就是http协议的三次握手（以及后面会涉及到四次分手）
我刚恢复节奏，准备侃侃而谈，修福报的大佬再次打断了我，说三次握手，为啥两次不行，顺便说一下3次握手发生了什么。
我去，大意了，没有闪，这是不是说我每说一句都要夹杂着各种问题，太难了啊！！！
没有办法，继续回答大佬，我说我先回答三次握手发生的事情吧，简答来说：
第一次握手：主机A发送位码为SYN＝1的TCP包给服务器，并且随机产生一个作为确认号（这是tcp包的一部分），主机B收到SYN码后直到A要求建立连接;
第二次握手：主机B收到请求后，向A发送确认号（主机A的seq+1），syn=1，seq = 随机数 的TCP包；
主机A收到后检查确认号是否正确，即第一次A发送的确认号是否+1了，以及位码ack是否为1，若正确，主机A会再发送确认号(主机B的seq+1)，ack=1，主机B收到后确认seq值与ack=1则连接建立成功。
接着补上小问题为什么两次握手不行，因为第二次握手，主机B还不能确认主机A已经收到确认请求，也是说B认为建立好连接，开始发数据了，结果发出去的包一直A都没收到，那攻击B就很容易了，我专门发包不接收，服务器很容易就挂了。
接着，大佬说出个加分题，我看你不是科班出身，能答多少是多少。问题是,从网卡把数据包传输出去到服务器发生了什么，提示我OSI参考模型
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/88a65423984477a46c1a7b8b5344e27e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5bc01652b1dcd6b8f96259469731599f/" rel="bookmark">
			论文阅读笔记(3):ST-GCN
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3934090fef09ceb19daa3bd3fa0eef3e/" rel="bookmark">
			uni-app $refs的基本用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		$refs的基本用法
一个对象(Object)，持有注册过 ref 特性 的所有 DOM 元素和组件实例。
&lt;template&gt; &lt;view class="container" style="background: #0FAEFF;"&gt; &lt;view class="child"&gt; hi {{showModal}}&lt;/view&gt; &lt;/view&gt; &lt;/template&gt; &lt;script&gt; export default { props: { showModal: { type: String, default: 'hello' } }, data() { return { childdata: 'child value' }; }, methods: { sayHello() { console.info("--child:--" + this.showModal); } } } &lt;/script&gt; child &lt;template&gt; &lt;view class="container"&gt; &lt;child :showModal="showModal" ref="vref"&gt;&lt;/child&gt; &lt;button @tap="refMethods" type="primary" &gt;点击&lt;/button&gt; &lt;/view&gt; &lt;/template&gt; &lt;script&gt; import child from "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3934090fef09ceb19daa3bd3fa0eef3e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e460851f6638c55900a9342333c547dc/" rel="bookmark">
			怎么把HTM格式转化成WORD
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		怎么把HTM格式转化成WORD 具体操作步骤如下：
1、首先鼠标右键单击HTM格式的文档并点击选择“打开方式”选项。
2、然后在该页面中点击选择“Word”方式打开。
3、之后在该页面中点击左上角“文件”选项。
4、然后在该页面中点击“另存为”选项。
5、然后在该页面中点击保存类型为“Word文档”。
6、最后在该页面中点击“保存”选项即可把HTM格式转化成WORD了。
相关文章：http://www.jieba8.com/
上一篇：http://www.xitong5s.com/
下一篇：http://www.xdy666.com/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e7db90494730ed5526ed44c80d9e45d/" rel="bookmark">
			我的世界java版forge放在哪,我的世界1.8以上版本mod/forge安装图文教程_我的世界怎么装mod_游戏堡...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		许多玩家不清楚我的世界1.8以上的版本要怎么安装mod，接下来小编就为大家带来我的世界1.8以上版本怎么安装mod的图文教程，希望大家能够喜欢。
第一步
1下载“forge”，为什么要下载“forge”?因为它是连接Mod和我的世界这款游戏的工具，相当于桥梁!
注意：下载的这个程序必须和你的世界的版本要一致!不然可能会导致mod无法使用!
2双击下载好的那个forge文件，该文件后缀为“.jar”，可以理解为java可可执行程序，安装了JAVA才能打开它!和“我的世界”一样需要JAVA.。
3双击后，在打开的界面中点击“....”，浏览到“我的世界”游戏安装目录下面的“.minecraft”文件夹!
我的游戏安装目录在“E:\\gama\\Minecraft\\.minecraft”，所以我那里打开的是“E:\\gama\\Minecraft\\.minecraft”
4打开后其他的不要管他!点击“确定”按钮，等待它自动下载一些其他的必要文件。
最后弹出一个提示窗口点击“确定”。
END
步骤2
度娘一下，下载需要的mod文件包，然后把下载的文件复制到“我的世界存放目录Minecraft\\.minecraft\\mods”的下面。
注意!如果你下载的文件后缀为.jar或.zip，那么才可以直接把该文件放入该文件夹下!
然后打开“我的世界”的启动器，选择“FM”的版本(就是forge版本)，启动我的世界。
在选择模式中会多出一个“mods”的模式，点击进入，然后就能看到你哪些mod载入成功!如果没有显示，那么表示失败，下，原因可能是mod版本的问题!
声明：游戏堡网登载此文出于传递信息之目的，不代表游戏堡网赞同其观点或证实其描述，若侵权请来信告知，我们将及时处理。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e77cc749cea1f95a0070f5c8508edc86/" rel="bookmark">
			php放量文档,MACD高级用法(论坛整理版)讲稿.docx
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MACD高级用法目录趋势停顿与转折(MACD高级战法)2 谈谈零轴3 再谈背离5 来一招通过零轴找买点的实例10 今天的 实盘与大盘解读11 底抄的爽吧12 零轴操作实例213 战斗一天16 仔细看图如何涨的18 macd回零轴选股公式19 还是macd问题21 目前大盘(三重滤网分析方法)23 讲讲指标线金叉25 玩转MACD(让你疯狂爱上MACD )32(一)0 轴上第一个金叉33(二)MACD和均线系统36(三)0 轴的威力38(四)各指标是相通的(RSI,KDJ.MACD,BOLL为例)40(五)双线和0 轴的远近关系42选股的方法：44(六) 分时图利用MACD做帮手48杀多点：54MACD抢反弹战法60 周期的关系：64 小阶段的总结：794.对金叉的选择，放量突破箱体，贴近0 轴更好，符合热点为佳品。选票时要仔细分析， 量。价。MACD。(买法1)5.为配合金叉前介入买点，特推出长期0 轴游走，DIF下 探0 轴由正值变负值的第二天或者第三天是买点的买入法。(买法2)6.对前期强势股， 推出数柱子买入法，双线离0轴较远距离高空死叉后第4-5 根，极限第6 根的买入法。 代表作论坛上跟帖的太原刚玉。(买法3)80 简单发一张周期关系图，自己领会80 一波行情MACD示意图84 对未来(2011 年)指数的研判：982011 年之大势预判101叫板所谓券商2011年金股104趋势停顿与转折(MACD高级战法)来自：/viewthread.php?tid=1612555&amp;extra=&amp;authorid=425872&amp;page=1在我的系统里，没有主力庄家的东西。类似吸筹，拉升，洗盘，震仓，出货这些玩意不 在我系统研究内。从接触市场来，就没打算研究这些。在我眼里，所有的图形，都是多空征 战在盘面上留下的足迹。从以前最初接触的k 线，均线，成交量，趋势线到走势结构。一直都是沿着多，空变化 的角度研究。但是最终我发现了一个问题。既技术分析是相通的。深入研究k线所得出的结 果，均线，量能，趋势也都能得出这个结果。任何的技术，任何的指标在我看来也只是趋势 的停顿与转折而已。既多头市场，上涨--停顿--上涨--重复--转折--下跌。不断循环。而已。所以，技术分析有很多条路都能达到巅峰，找到适合自己的一条路即可。看论坛这么多人讨论macd，我也来凑个热闹。macd的本质是速度的变化，速度是什么？是单位时间内运行的价格幅度。以一个上下 上的走势来说。如果第二段上涨没有第一段上涨速度快。则产生顶背离。反之产生底背离。 顶背离意味什么？多头衰竭。相同时间内，第二段没第一段做多强烈。产生了顶背离，可以 确定，肯定不会上涨。那只有调整。调整也有两种方式，1，时间为主，价格横盘。2，空 间为主，价格主动下跌。这是macd背离的本质。macd还有啥？指标线，快线与慢线之间的距离，零轴，红 绿柱，金叉死叉，零轴穿越。macd看似是一个简单的指标，实际他并不简单，macd在我眼里，他提示趋势，提示趋 势转折，提示趋势状态下的加速形态。很多很多。零轴，代表平衡。同时也是60均线。 指标线之间的距离：代表的是乖离率，反应的是走势与均线的距离 红绿柱：代表动能，同时也代表次级别指标线的状态。哈哈，他很强大。至少他潜意识的提示了一种循环关系。零轴穿越：代表ema12 与ema26 的金叉与死叉。 整体说完的话，会浪费大家太多时间。 那就从一个最简单实用的交易系统谈起吧。 这个交易系统只需要两个工具，1，macd。 2，趋势线。操作很简单，操作周期产生底背离，并且突破压力线做买入。如果出现缓速上涨，或者横盘代替上涨，卖出。当产生顶背离，且跌破趋势线，做卖出。实际上这并不是一个很好的系统，但是他简单。至少新手能很快的掌握，且实战型也较 强。但是不好的是，解决不了趋势停顿与转折的问题。利润做不到最大化。但是，因为是一 个趋势型交易系统，操作起来很稳健。 但，这里要正确理解背离。背离有三种。1，指标线的背离。2，柱状线的背离。3，柱状线 面积.这里只有指标线背离才是真正意义的背离。其他两种，只是它次级别走势的背离而已。接上图，个股30分钟图。因为操作30分钟级别的。L1 是下跌趋势线。买入条件是底背离+趋势线突破。L2 为上涨支撑线，卖出调整为顶背离+支撑线跌破。一个完整的操作。莫看 简单。简单的东西，大部分人不懂他的原理. 至少以我所掌握的macd知识，足够应付趋势 的停顿与转折谈谈零轴macd是一个经典的趋势类指标，都知道，指标线在零轴下为空头市场，指标线在零轴上为 多头市场。 在确定趋势方向的前提下，就有了相对应的操作策略，空头市场，逢高做空为主，多头市 场，逢低做多为主。什么是逢高？什么是逢低？必须要定量这个问题，模糊操作可不行。用波浪语言来形容波动，既推动
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3cc6ff77c6e677e1bebad7f493741998/" rel="bookmark">
			大数据相关知识点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HDFS：高度容错的适合部署在廉价机器上的分布式系统，提供高吞吐量的数据访问，非常适合大规模数据上的应用。由于放宽了一部分POSIX约束，从而实现了流式读取文件系统数据。
MapReduce：一种编程模式，用于大规模数据集的并行计算。
map函数：接受一个键值对（key-value pair），产生一组中间键值对。MapReduce框架会将map函数产生的中间键值对里键相同的值传递给一个reduce函数。
reduce函数：接受一个键，以及相关的一组值，将这组值进行合并产生一组规模更小的值（通常只有一个或零个值）。
Hbase：一个分布式的、面向列的开源数据库，它自底向上进行构建，能够简单地通过增加节点实现线性拓展。它并不是关系型数据库，不支持SQL。
Pig： 一种数据流语言和运行环境， 用以检索非常大的数据集， 运行在mapreduce和HDFS集群上。
Hive： 一个分布式、 按列存储的数据仓库。 Hive管理HDFS中存储的数据， 并提供基于SQL的查询语言（由运行时引擎翻译成Mapreduce作业） 用以查询数据。
ZooKeeper： 一个分布式、 可用性高的协调服务。 ZooKeeper提供分布式锁之类的基本服务用于构建分布是应用。
Sqoop:在数据库和HDFS之间高效传输数据的工具。
Mahout： 提供可拓展的机器学习领域经典的算法实现， 帮助开发人员更加快捷地创建智能应用程序。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9724cecd93148d19f4ce923e06dbc8dc/" rel="bookmark">
			linux vi:command not find
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		环境信息 测试环境版本操作系统centos6.9 问题现象 Linux命令行输入命令执行后报“bash:vi:command not found”
问题原因 这是由于系统PATH设置错误，PATH没有设置对，系统就无法找到精确命令了。
解决方案 命令在当前bash可用 在命令行中输入：
export PATH=/usr/bin:/usr/sbin:/bin:/sbin:/usr/X11R6/bin 永久生效 在命令行中输入 vi /etc/profile 查看是否自己另外设置了PATH属性。 vi /etc/profile 添加如下内容 export PATH=/usr/bin:/usr/sbin:/bin:/sbin:/usr/X11R6/bin source /etc/profile source /etc/profile 问题解决！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d87e9dcecb7d85bd9c5e3e63839daa5/" rel="bookmark">
			http请求超时
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		针对http接口访问超时处理
如果你参加过互联网项目，那么你一定知道，整个大的系统会被切成许多的子系统。子系统与子系统通过接口交互。其中，通过http接口交互，是非常常用的一种方式。那么如果调用某个子系统的http接口超时了，该如何处理呢？下面列举一下。
增加超时时间
假设A系统有个方法methodA，会调用B系统的methodB这个http接口，如果mehodA不追求超快的响应速度，那么你在调用methodB这个http接口时，可以增长超时时间，例如10秒超时。因为经常在某些时刻，由于网络原因或者系统原因，调用method会超时的。
默认超时时间设置与针对某Request这是超时时间
默认设置
RequestConfig config = RequestConfig.custom().setConnectTimeout(1000).setSocketTimeout(2000).build();
httpClient = HttpClientBuilder.create().setMaxConnTotal(20).setMaxConnPerRoute(20).setDefaultRequestConfig(config).build();
针对某个单个 设置
HttpGet httpGet = new HttpGet(url);
if (connectTimeout != null &amp;&amp; socketTimeout != null &amp;&amp; connectTimeout &gt; 200 &amp;&amp; socketTimeout &gt; 200) {
RequestConfig requestConfig = RequestConfig.custom().setConnectTimeout(connectTimeout).setSocketTimeout(socketTimeout).build();
httpGet.setConfig(requestConfig);
}
尝试多调用一次
如果第一次调用methodB超时了，那么你可以尝试多调用一次。当然前提是，methodA不追求超快的响应时间。
使用待处理队列
如果methodA需要很快的响应速度，那么当调用methodB接口超时时，可以使用一个队列存储本次失败的记录，然后使用一个job每隔一段时间去扫这个队列，看看是否有待处理的数据。
备注：如果对方系统挂掉了，使用待处理队列的方式，比较合适。
回滚数据
catch这个超时异常，然后记录日志后，抛出这个异常，并把之前的数据回滚。让对方的系统重新调用。
备注:宁愿没有数据，也不要存储脏数据。
使用异步机制
如果你的业务方法中，需要调用对方的http接口，如果这个http接口不影响主流程的，那么可以使用一个线程，异步调用对方的http接口，并把超时时间设置长一些。由于使用了异步，主流程会立刻继续走的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23f36308caba8eeb5865d6f16ddc8158/" rel="bookmark">
			php 去除 注释,PHP 之去除代码中的注释
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		测试文件代码如下：
/**
* Created by PhpStorm.
* User: Yang
* Date: 2019/10/16
* Time: 10:25
*/
// 计算和
// 计算和
// 计算和
$a = 1;
$b = 2;
$c = $a+$b; //总和
/*
* 求和函数
*/
function sum($a, $b) {
return $a + $b; //返回值
}
# 第二种注释
$a = 1;
$b = 2;
## 求乘积
$c = $a * $b; # 结果
//特殊
$usedFuncs = "abcd";
preg_split("//is", implode("", $usedFuncs), -1, PREG_SPLIT_NO_EMPTY);
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/23f36308caba8eeb5865d6f16ddc8158/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/339de7180855ff53dfe7dd4e9e559fe0/" rel="bookmark">
			python描述性统计案例,python数据分析学习——1.描述性统计分析-Go语言中文社区...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		描述性分析
描述性统计分析是关于数据的描述和汇总。它使用两种主要方法：
定量方法以数值方式描述和汇总数据。
可视化方法通过图表，曲线图，直方图和其他图形来说明数据。
一般在数据分析的过程中，拿到数据不会去直接去建模，而是先做描述性分析来对数据有一个大致的把握，很多后续的建模方向也是通过描述性分析来进一步决定的。那么除了在Excel/R中可以去做描述性分析。
本文将细致讲解如何使用python进行描述性分析的定量分析部分:
均值
中位数
方差
标准差
偏度
百分位数
相关性
至于可视化的部分可以参考我之前讲解pyecharts的文章，当然后面还会介绍echarts以及ggplot2的方法。
涉及到的python库
Python statistics是用于描述性统计信息的内置Python库。如果您的数据集不是太大，或者您不能依赖于导入其他库，则可以使用它。
statistics - Mathematical statistics functions - Python 3.8.2rc1 documentationdocs.python.org
NumPy是用于数字计算的第三方库，已针对使用一维和多维数组进行了优化。它的主要类型是称为的数组类型ndarray。该库包含许多用于统计分析的方法。
NumPy User Guidedocs.scipy.org
SciPy是基于NumPy的用于科学计算的第三方库。与NumPy相比，它提供了其他功能，包括scipy.stats统计分析。
Getting started - SciPy.orgwww.scipy.org
Pandas是基于NumPy的用于数值计算的第三方库。它擅长处理带有Series对象的带标签的一维(1D)数据和带有对象的二维(2D)数据DataFrame。
https://pandas.pydata.org/pandas-docs/stable/pandas.pydata.org
Matplotlib是用于数据可视化的第三方库。通常会与NumPy，SciPy和Pandas结合使用
Python plotting - Matplotlib 3.1.3 documentationmatplotlib.org
开始
首先导入所有的包
import math
import statistics
import numpy as np
import scipy.stats
import pandas as pd
创建数据
x和x_with_nan都是list。不同之处在于x_with_nan包含一个nan值。也就是空值(缺失值)，这样的数据在分析中十分常见。那么在python里，创建一个nan值可以有以下方法
float('nan')
math.nan
np.nan
当然这三种方法创建的空值都是等价的
但是真的相等吗，两个nan是不相等的，换句话说，是不可以进行比较的，这后面的故事以后再说。
接着，我们使用numpy和pandas来创建两个一维numpy arrays和pandas series
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/339de7180855ff53dfe7dd4e9e559fe0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2e38ec34e37441dd22375f4547142cc/" rel="bookmark">
			SpringBoot 接口同时接收MultipartFile参数和结构体参数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言： 近期接手一个需求，需求转成代码实现就是需要在一个接口实现很多参数传递的同时加上文件上传，考虑到参数比较多，参数封装成body上传，文件用单独的 MultipartFile 接收；前端死活对接不出来，在这里对前端同学表示歉意，是在下的错；这里解释一下原因和比较简单的处理方式。
1.问题接口展示和故障说明 @PostMapping("/create") public ApiResultBean postTest(HttpServletRequest request, @RequestBody PayOrderCreateReqDto payOrderCreateReqDto, @RequestParam(value = "applyFiles") MultipartFile applyFiles ) 从代码层面看一点问题没有，但是这里引入一下http的知识：
HTTP请求分为了消息头和消息体，头信息里面的Content-Type字段定义了消息体的请求格式，接口里面声明 @RequestBody 的参数只能设置为 "Content-Type: application/json"，而 MultipartFile 参数只能设置为"Content-Type: multipart/form-data"，上述两种格式并不是兼容的，那问题就来了，前端请求的时候 Content-Type 怎么设置，无论哪种格式都是错的。
2.解决方式 1）.前端统一格式"Content-Type: multipart/form-data"，把结构体拆分成参数，把参数传递过去，接收后再组装结构体，举例如下：
@PostMapping("/create") public ApiResultBean postTest(HttpServletRequest request, @RequestParam(value = "name") String name, @RequestParam(value = "id") String id, @RequestParam(value = "applyFiles") MultipartFile applyFiles ) 2）.前端统一格式"Content-Type: multipart/form-data"，结构体在前端传递的时候统一转成json字符串，后端接收以后用Gson转成结构体，举例如下：
@PostMapping("/create") public ApiResultBean postTest(HttpServletRequest request, @RequestParam(value = "dtoJson") String payOrderCreateReqDto, @RequestParam(value = "applyFiles") MultipartFile applyFiles ) { Gson gson = new Gson(); PayOrderCreateReqDto toDto = gson.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f2e38ec34e37441dd22375f4547142cc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/046f0b604feac288c186fb7c3556c828/" rel="bookmark">
			2021-03-26
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		html5的后缀是什么？ 对于html5一知半解的朋友，肯定会html5都会有非常多的疑问，例如html5的后缀是什么？怎么写？对于这个疑问，P2H可以帮助你解答 。html5是一门html升级后的语言，所以后缀名还是.html , 并不是大家以为的 .html5 ！ html5的区别在哪儿呢 ，html5的区别在于文档声明 ，还有 script ，link 嵌入的声明的不同 ，其实html5新增了许多html5独有的标签，原有的html标签依然可以使用。html5可以基于像xml一样的书写 ，也就是自定义标签。也就是自定义标签然后结合css3来写就是一个标准的html5页面了。跟多的html5的书写规范请看html5的书写规范。
相关文章：http://www.jieba8.com/
上一篇：http://www.xdy666.com/
下一篇：http://www.xitong5s.com/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c705da58103694c061fe6b3f6d7a357/" rel="bookmark">
			hashmap和hashset的区别和联系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		hashmap和hashset的区别和联系 1.hashset的存储结构 通过查看hashset的add方法源码可以发现hashset采用的是map存储结构
public boolean add(E e) { return map.put(e, PRESENT)==null; } private static final Object PRESENT = new Object(); hashset则将对象存储在map的key中，value值用一个new Object()作为填充
往hashset存储元素时，hashset会先调用元素的hashcode方法获取元素的hash值，再用元素的hash值和（数组长度-1）做位运算得到下标（HashMap的底层是一个数组结构，数组中的每一项对应了一个链表（jdk1.8之后是红黑树），这种结构称“链表散列”的数据结构，即数组和链表的结合体；也叫散列表、哈希表。）。如果此时计算的位置上没有其他元素则直接插入不用比较。
但是随着元素的不断添加，就可能会出现“哈希冲突”，不同的对象计算出的hashcode是相同的。这时候就需要用equals方法进行比较，如果相同则不插入，如果不同则用头插法插入链表。但是若相同元素过多同样会产生链表过长查找慢的问题，在1.8之后就采用了红黑树结构。
hashmap 一、HahMap存储对象的过程如下
1、对HahMap的Key调用hashCode()方法，返回int值，即对应的hashCode；
2、把此hashCode作为哈希表的索引，查找哈希表的相应位置，若当前位置内容为NULL，则把hashMap的Key、Value包装成Entry数组，放入当前位置；
3、若当前位置内容不为空，则继续查找当前索引处存放的链表，利用equals方法，找到Key相同的Entry数组，则用当前Value去替换旧的Value；
4、若未找到与当前Key值相同的对象，则把当前位置的链表后移（Entry数组持有一个指向下一个元素的引用），把新的Entry数组放到链表表头；
HashSet和HashMap的区别 hashset为什么比hashmap慢呢？ 有的说是因为HashMap可以直接通过hash计算得到的键来获取对象，而HashSet呢， 直接用HashMap的containKeys方法，确实能在相同效率下确定一个元素是否存在，但是因为实现的是set，并不能用get方法，因此取值很麻烦。但是总感觉牵强。
因此就想会不会是因为键值对像的差别造成的，他们俩都必须计算哈希码，但要考虑HashMap的键的性质-它通常是一个简单的String甚至是一个数字。他们俩都必须计算哈希码，而hashset可能会是一个对象。如果HashMap的键与存储在HashSet中的键是相同的对象，则性能将没有真正的区别。区别在于HashMap的键是哪种对象。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e579522b7e95772ffc439946cdf85ff/" rel="bookmark">
			【算法】PHP简单实现斗地主洗牌和发牌
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近有时间了，重新学习一下基础知识。工作中一直都只关注业务实现，丢了很多基础的东西。今天遇到一道题目问斗地主的数据结构要怎么设计，当时初步构思了一下，今晚把构思写出来，并加上洗牌的简单实现。
思路：理清斗地主的出牌逻辑，如
炸弹：王炸、4炸；
3带1对，3带1个，3个不带；
飞机：3+3，3+3+1+1，3+3+2+2；
顺子：牌3到牌A连续，5张起
一对
单个
等
按照这个思路逻辑，我计划用数字大小来做牌的主key，方便后续实现运算，王+13个牌，分别设计为王-14，二-13，A-12...三-1 ，一个牌有4个花色，分别用4到1来区分。大小王分别用142、141，二用134，133，132，131，依此类推来设计牌的数据结构。
/** * @name 简单版 斗地主洗牌、发牌 * @return array */ public function randPuker() { $puker = [ 142 =&gt; '大王', 141 =&gt; '小王', 134 =&gt; '黑桃2', 133 =&gt; '红心2', 132 =&gt; '梅花2', 131 =&gt; '方块2', 124 =&gt; '黑桃A', 123 =&gt; '红心A', 122 =&gt; '梅花A', 121 =&gt; '方块A', 114 =&gt; '黑桃K', 113 =&gt; '红心K', 112 =&gt; '梅花K', 111 =&gt; '方块K', 104 =&gt; '黑桃Q', 103 =&gt; '红心Q', 102 =&gt; '梅花Q', 101 =&gt; '方块Q', 94 =&gt; '黑桃J', 93 =&gt; '红心J', 92 =&gt; '梅花J', 91 =&gt; '方块J', 84 =&gt; '黑桃10', 83 =&gt; '红心10', 82 =&gt; '梅花10', 81 =&gt; '方块10', 74 =&gt; '黑桃9', 73 =&gt; '红心9', 72 =&gt; '梅花9', 71 =&gt; '方块9', 64 =&gt; '黑桃8', 63 =&gt; '红心8', 62 =&gt; '梅花8', 61 =&gt; '方块8', 54 =&gt; '黑桃7', 53 =&gt; '红心7', 52 =&gt; '梅花7', 51 =&gt; '方块7', 44 =&gt; '黑桃6', 43 =&gt; '红心6', 42 =&gt; '梅花6', 41 =&gt; '方块6', 34 =&gt; '黑桃5', 33 =&gt; '红心5', 32 =&gt; '梅花5', 31 =&gt; '方块5', 24 =&gt; '黑桃4', 23 =&gt; '红心4', 22 =&gt; '梅花4', 21 =&gt; '方块4', 14 =&gt; '黑桃3', 13 =&gt; '红心3', 12 =&gt; '梅花3', 11 =&gt; '方块3', ]; //随机打乱数组，由于shuffle函数会重置key值，所以使用key值来打乱，再通过key值把牌生成好 $randKeys = array_keys($puker); shuffle($randKeys); //重新按打乱顺序排好牌 foreach ($randKeys as $k){ $pukerTemp[$k] = $puker[$k]; } //重组完毕 $puker = $pukerTemp; //先抽3张作为底牌 $keys = array_rand($puker,3); $arrCover = []; foreach ($keys as $key){ $arrCover[$key] = $puker[$key]; unset($puker[$key]); } $i = 0; //将剩下的数组分3份，发牌 foreach($puker as $key =&gt; $val){ $arrPlayer[$i % 3][$key] = $val; $i++; } return array('cover'=&gt; $arrCover, 'player'=&gt; $arrPlayer); } 拿到牌以后，可以按顺序排列。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9e579522b7e95772ffc439946cdf85ff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e96b08b44e4e84304859c0144a224f1/" rel="bookmark">
			matlab绘制子图怎么,MATLAB画图之多子图画法（subplot和自己确定大小位置两种方法）...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决问题：在一个图中画多个子图，又能自己确定子图的大小和位置。
解决方法：有两种解决方法可以实现：
使用subplot命令
使用axes函数来重新规定子图的大小和位置。
这两种方法中，第一种方法相对简单，但是第二种方法更加灵活，具体使用如下：
第一种方法：使用subplot
先看一下subplot的简单使用，程序如下：
clear;
clc;
close all;
t = 0:0.001:10;
y1 = sin(t);
y2 = cos(t);
figure (1);
subplot(2,2,1)
plot(t,y1);
subplot(2,2,2)
plot(t,y1);
subplot(2,2,3)
plot(t,y2);
subplot(2,2,4)
plot(t,y2);
程序运行结果：
使用subplot的这种方法，如果想要自定义子图的大小和位置该怎么设置？
程序如下：
clear;
clc;
close all;
t = 0:0.001:10;
y1 = sin(t);
y2 = cos(t);
figure(1);
subplot('position',[0.2,0.7,0.6,0.2]);
plot(t,y1);
subplot('position',[0.2,0.2,0.6,0.2]);
plot(t,y2);
程序运行结果：
第二种方法：直接使用axes函数
程序如下：
clear;
clc;
close all;
t = 0:0.001:10;
y1 = sin(t);
y2 = cos(t);
figure (1);
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3e96b08b44e4e84304859c0144a224f1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e80aa7c2a1e618394f2849c652b64939/" rel="bookmark">
			php wordpress漏洞,wordpress会有漏洞吗
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		根据CVE官方漏洞通报得知wordpress新出一个组合式rce漏洞，漏洞编号分别为CVE-2019-8943和CVE-2019-8942，下载漏洞版本源码，分析漏洞触发过程，注：漏洞复现时一定要断网搭建，wordpress在联网状态时会自动更新代码包。找到漏洞发生文件post.php，wordpress有多个post.php文件，这里简要说明一下各自的作用，wp-includes/post.php为post的源文件，wp-admin/includes/post.php为有后台权限的post接口，wp-admin/post.php为后台post的请求处理，具体调用代码如下：wp-admin/post.php：require_once( dirname( __FILE__ ) . '/admin.php' );
wp-admin/admin.php：require_once(ABSPATH . 'wp-admin/includes/admin.php');
wp-admin/includes/admin.php：require_once(ABSPATH . 'wp-admin/includes/post.php');
wp-admin/admin.php:：require_once(dirname(dirname(__FILE__)) . '/wp-load.php');
wp-load.php：require_once( dirname( ABSPATH ) . '/wp-config.php' );
wp-config.php：require_once(ABSPATH . 'wp-settings.php');
wp-settings.php：require( ABSPATH . WPINC . '/post.php' );
define( 'WPINC', 'wp-includes' );
根据以上调用流程，漏洞利用流程为上传一个图片到媒体库，然后进行更新操作，调用wp-admin/post.php函数，并根据switch到case:editpost，如下图所示：
其中edit_post为漏洞函数，进入函数声明，如下图所示：
$post_data为post数组，并未作任何过滤防护，对此产生了之后的漏洞，对比修复后的代码，如下图所示：
在此我多说两句，因一开始并未发现wordpress在联网时会进行自动更新，所以，我定位了另一个类似漏洞点，如下图所示：
以上代码会根据传入的meta数组进行update_meta，根据代码中的$key(数据库中的meta_id)，$value[‘key’](数据库中的meta_key),$value[‘value’](数据库中的meta_value)，构造meta[1][key]=_wp_attached_file&amp;meta[1][value]=123，最终执行类似以下数据库语句UPDATE `wp_postmeta` SET `meta_key` = '_wp_attached_file', `meta_value` = '123' WHERE `meta_id` = 2，实现过程，如下图所示：
根据meta_id更新wp_postmeta表中内容，最终执行do_action函数，如下图所示 ：
但是由于第三个和第四个if的限制，导致无法执行成功，这也算是一个漏洞复现上的一个有趣的点吧，继续跟踪，如下图所示：
找到可利用的点，并根据代码所示，进入wp_updae_post函数，如下图所示：
此函数会经过一些获取参数的操作，将数组中的变量提取出来并进行赋值，跟踪到漏洞发生点，如下图所示：
发现返回wp_insert_attachment函数，跟踪此函数，如下图所示：
返回wp_insert_post函数，跟踪此函数，在此函数中定位到漏洞发生点，如下图所示：
所以根据以上漏洞点，可传入meta_input[_wp_attached_file] =../evil.jpg?shell.php，执行SQL语句为UPDATE `wp_postmeta` SET `meta_value` = '../evil.jpg?shell.php ' WHERE `post_id` = 8 AND `meta_key` = '_wp_attached_file'，测试条件为前提必须知道post_id，不过正常情况下更新图片时会自带此参数，如果是测试的话，可以观察数据库填写相关内容。具体SQL语句嵌套执行方法，如下图所示：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e80aa7c2a1e618394f2849c652b64939/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ad1f48a4da47d748703c25ada17a9c6/" rel="bookmark">
			vue 导航守卫 判断用户是否登录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 如果用户访问登录页面，则直接放行
如果用户访问具有权限的页面时，首先检测有没有token值。有，则表示用户已登录，直接放行，如果没有token值，则强制跳转到登录页
// to代表将要访问的路径 // from代表从哪个路径跳转过来 // next是函数，表示放行 router.beforeEach((to,from,next) =&gt; { if(to.path === '/login') return next(); const tokenStr = window.sessionStorage.getItem('token');//获取token值 if(!tokenStr) return next('/login'); next() }) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0a920b3e005ccefb2289e031095d537/" rel="bookmark">
			apache隐藏PHP版本号,apache隐藏版本号
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一般情况下，软件的漏洞信息和特定版本是相关的，因此，软件的版本号对攻击者来说是很有价值的。
在默认情况下，系统会把Apache版本模块都显示出来(http返回头信息)。如果列举目录的话，会显示域名信息(文件列表正文)，如：
[root@localhost conf]# curl -I 192.168.146.188
HTTP/1.1 200 OK
Date: Tue, 30 Aug 2011 09:17:42 GMT
Server: Apache/2.2.4 (Unix) PHP/5.2.6
Last-Modified: Sat, 20 Nov 2004 20:16:24 GMT
ETag: "be0533-2c-3e9564c23b600"
Accept-Ranges: bytes
Content-Length: 44
Content-Type: text/html
隐藏方法：
1、隐藏Apache版本号的方法是修改Apache的配置文件，如RedHat系的Linux默认是：
vim /etc/httpd/conf/httpd.conf
分别搜索关键字ServerTokens和ServerSignature，修改：
ServerTokens OS 修改为 ServerTokens ProductOnly
ServerSignature On 修改为 ServerSignature Off
2、重启或重新加载Apache就可以了。
apachectl restart
测试一下，如下：
[root@localhost conf]# curl -I 192.168.146.188
HTTP/1.1 200 OK
Date: Tue, 30 Aug 2011 09:17:58 GMT
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c0a920b3e005ccefb2289e031095d537/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2da0a006bdadedd1aa4caca2f7625166/" rel="bookmark">
			Intellij IDEA如何生成JavaDoc
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		javadoc基本介绍
javadoc是Sun公司提供的一个技术，它从程序源代码中抽取类、方法、成员等注释形成一个和源代码配套的API帮助文档。也就是说，只要在编写程序时以一套特定的标签作注释，在程序编写完成后，通过Javadoc就可以同时形成程序的开发文档了。
javadoc命令是用来生成自己API文档的，使用方式：使用命令行在目标文件所在目录输入javadoc +文件名.java。
javadoc常用标识
@author 作者
@version 版本号
@param 参数名 描述 方法的入参名及描述信息，如入参有特别要求，可在此注释。
@return 描述 对函数返回值的注释
@deprecated 过期文本 标识随着程序版本的提升，当前API已经过期，仅为了保证兼容性依然存在，以此告之开发者不应再用这个API。
@throws异常类名 构造函数或方法所会抛出的异常。
@exception 异常类名 同@throws。
@see 引用 查看相关内容，如类、方法、变量等。
@since 描述文本 API在什么程序的什么版本后开发支持。
{@link包.类#成员 标签} 链接到某个特定的成员对应的文档中。
{@value} 当对常量进行注释时，如果想将其值包含在文档中，则通过该标签来引用常量的值。
第一步 在工具栏中找到 Tool，然后再子菜单中找到 Generate JavaDoc。
第二步: 在生成文档上进行配置。
参数说明
1.Whole project:整个项目都生成文档
2.Custom scope 自定义范围。如下：
（1）project files 项目文件，
（2）project production files 项目产品文件，
（3）project test files 项目的测试文件， 未知范围，class hierarchy 类层
3.include test source 包含测试目录
4.include JDK and … 包含jdk和其他的第三方jar
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2da0a006bdadedd1aa4caca2f7625166/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f8639d32dad30a5fca33244c5bbc90a/" rel="bookmark">
			高可用_keepalived &#43; haproxy
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		准备： 登录腾讯云申请HAVIP 私有网络 高可用虚拟 IP 概述 - 操作指南 - 文档中心 - 腾讯云 申请通过后，刷新页面，选择 云产品 -&gt; 网络 -&gt; 私有网络 -&gt; IP与网卡 -&gt; 高可用虚拟IP
新建vip，选择自己的私有网络。此时通过自己的vpc无法访问vip(vip未绑定到自己的vpc上)，
通过keepalive配置好vip后其它vpc才能ping 通vip。注意vip申请后如果不绑定eip会默认绑定到一台服务器上，并且会扣费的，购买一个eip然后绑定到vip上就可以通过外网访问高可用环境了。 1. 主机规划 节点主机名内网ip主节点1k8s-master01172.17.0.8主节点2k8s-master02172.17.0.9HAVIPwww.k8s.com172.17.0.250（腾讯云申请-免费）EIPwww.k8s.com110.xx.xxx.2x9 (腾讯云公网ip-购买) 主节点1和主节点2都需要部署keepalived和haproxy。下面配置为主节点1的配置。
主节点2的keepalived配置基本同主节点1，需要修改的地方参考配置中的注释。主节点2的haproxy配置同主节点1的配置
2. 部署keepalived 安装keepalived yum install -y keepalived 配置keepalived vim /etc/keepalived/keepalived.conf 内容如下: ! Configuration File for keepalived global_defs { notification_email { wangfenlei@sina.cn } notification_email_from keepalived@ptmind.com smtp_server 127.0.0.1 smtp_connect_timeout 30 router_id k8s-master01 # 主节点2改为 k8s-master02 } vrrp_script check_apiserver { # script "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4f8639d32dad30a5fca33244c5bbc90a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f29fc7f9bc713d622961e7a5d1125f92/" rel="bookmark">
			LDP会话建立过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		自己考证整理的，希望能够帮到搜索该词条的学者。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60b21e8ff2e19faeb4919c40405109ef/" rel="bookmark">
			近几年美国人口数据matlab,2010-2019年美国人口数量及人口性别、年龄、城乡结构分析...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		华经产业研究院数据显示：2019年美国人口总数为32823.95万人，相比2018年增长了155.20万人；与2010年人口数据对比，美国近十年人口增长了1891.79万人。
2010-2019年美国人口总数统计图
数据来源：世界银行，华经产业研究院整理
从性别结构来看，2019年美国男性人口数量为16241.79万人，占总人口比重的49.48%；女性人口数量为16582.16万人，占总人口比重的50.52%。
2010-2019年美国男性、女性人口数量
数据来源：世界银行，华经产业研究院整理
2010-2019年美国男女人口性别比
数据来源：世界银行，华经产业研究院整理
从城乡结构来看，2019年美国城镇人口数量为27066.30万人，农村人口数量为5757.65万人；2019年美国城镇化率为82.46%。
2010-2019年美国城镇、农村人口数量
数据来源：世界银行，华经产业研究院整理
2010-2019年美国城镇化率走势图
数据来源：世界银行，华经产业研究院整理
从年龄构成来看，2019年美国0-14岁人口占比18.55%，15-64岁人口占比65.24%，65岁及以上人口占比16.21%；2019年美国65岁及以上人口数量为5320.63万人，相比2010年增长了1305.09万人。
2010-2019年美国人口年龄结构图
数据来源：世界银行，华经产业研究院整理
2010-2019年美国65岁及以上人口数量
数据来源：世界银行，华经产业研究院整理
注：因世界银行数据调整，2019年与2018年数据有出入，以最新数据为准。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5b3b68963d3e60c392a149f55b0fb94/" rel="bookmark">
			MySQL同事找我帮忙写的找出一班各科成绩最好的学生
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		（学生表）
（班级表）
（成绩表）
解题：
SET SESSION sql_mode = 'STRICT_TRANS_TABLES'; SELECT c.id, c.course, c.score, a.classID, b.className, a.stuName FROM tablec c INNER JOIN tablea a ON c.stuID = a.stuID INNER JOIN tableb b ON b.classID = a.classID INNER JOIN ( SELECT tablec.course, MAX( tablec.score ) score FROM tablec INNER JOIN ( SELECT stuId FROM tablea, tableb WHERE tablea.classID = tableb.classID AND className = '一班' ) l_a ON tablec.stuID = l_a.stuId GROUP BY tablec.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b5b3b68963d3e60c392a149f55b0fb94/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9330bce4b8dedce9540a1f7c1a1d3350/" rel="bookmark">
			python list 元素位置,怎么查找python列表中元素的位置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何在python列表中查找某个元素的索引
方法二：利用enumerate函数。
在python中如何将list中的元素根据指定字符进行切片？
原： ["啊啊啊啊啊", "呃呃呃。鹅鹅鹅鹅鹅鹅饿"] 输出：["啊啊啊啊啊", 按照你的要求将list中的元素根据指定字符进行切片的Python程序如下 #。/usr/bin/pythonb=[]a=["啊啊啊啊啊", "呃呃呃。鹅鹅鹅鹅鹅鹅饿"]for i in range(0,len(a)): b=b+a[i].split("。
怎么查找python列表中元素的位置
Python中查找list中某个固定元素是常有的事，对于两种不同的查找有两种不同的解决方案，见下。 查找元素首次出现的位置：list自带的方法index可以找出某元素在list中首次出现的位置，用法为： 其中，start为开始搜索的位置。
python 列表怎样去掉一个元素？
li = [1,2,3,4,5,6] # 1.使用del删除对应下标的元素 del li[2] # li = [1,2,4,5,6] # 2.使用.pop()删除最后一个元素 li.pop() # li = [1,2,4,5] # 3.删除指定值的元素 li.remove(4) # li = [1,2,5] # 4.使用切片来删除 li = li[:-1] # li = [1,2
python正则表达式，怎么提取列表中带有指定字符的现在有一个列表 list=['A_rig','B_obj','F_rig','H_obj','T_rig',], 怎Alist=['A_rig','B_obj','F_rig','H_obj','T_rig',] B=[] for each in Alist: if 'obj' in each: B.append(each) print(B)
python怎么把一个列表中的特定子元素(元组)提取出eg: list1 =[(小明,小明),(小红,小红),(小天，小天)]list2=[小list2 = [i[0] for i in list1]
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9330bce4b8dedce9540a1f7c1a1d3350/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa525b3907e5f165acce760b960abd97/" rel="bookmark">
			python hog特征提取,直接从原始图像的HoG特征提取编辑图像的HoG特征
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我有很多图像，我从中提取了HoG特征并保存了它们。在
我现在已经丢失了图像，很明显那是我在机器出故障之前没有备份过的数据集。在
但是我有包含这些图像的HoG特征的文件。在
如果我现在有图像，我会对图像应用剪切和旋转来创建更多的示例，然后获取这些编辑图像的HoG特征。在
但既然我没有图像。。。有没有可能只处理原稿的HoG特征，以获得编辑后的HoG特征？在
这是我用来编辑图像的代码，如果我还有图像的话，我会从中提取HoG特征用于对象分类：import numpy as np
from skimage import data, io, filter, color, exposure
from skimage.feature import hog
import skimage.transform as tf
from skimage.transform import resize, rescale, rotate, setup, warp, AffineTransform
import matplotlib.pyplot as plt
import os
from os import listdir
from os.path import isfile, join
import pickle
import Image
def generateSamples(path, readfile):
print "generating samples from " + path+"\\"+readfile
img = color.rgb2gray(io.imread(path+"\\"+readfile))
img = resize(img, (50,100))
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aa525b3907e5f165acce760b960abd97/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e0423eebd14524309937cbd1b1e82ab/" rel="bookmark">
			pyqt5 python2,pyside2与pyqt5
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这两个模块用到现在，在使用上并没有碰到什么区别，只是import不同，协议不同，一个可以商用闭源，一个必须开源。如果有不同的意见欢迎评论。
在安装时碰到的坑，先用的pyqt5,后装的pyside2
qt5并没有碰到过什么问题，但在安装后者是无法运行，会报错
this application failed to start because no qt platform plugin could....
大概就是说缺少这些东西,reinstall会管用，然后我就觉得这个小东西在放****
我又尝试了网上的n多种方法，都无法解决我的问题......淦
其中有一个还让pt5不能用了...
然后我在虚拟机上装上side2，可以用，然后在主机上把qt5调回能用，我觉得可能是side2和qt5不能共存，如果有明白人看到这，留个言，蟹蟹！！！
其他相关内容自己百度去
=_=
qt5为例
梳理：
各种控件的特性和使用
控件样式
资源加载
控件布局
事件和信号
动画
跳转
designer
网络
多线程
数据库
文件操作
绘图
多媒体
定时器
定位........
常用包介绍
QtWidgets
包含了一整套UI元素控件，用于建立符合系统风格的界面
QtGui
涵盖多种基本图形功能，字体，图形，图标颜色...
QtCore
包的核心非GUI功能，时间，文件， 目录， 数据类型，线程进程...
QtWebKit
浏览器引擎
QtTest
测试
QtSql
数据库
QtMultimedia
多媒体
QtMultimediaWidgets
多媒体
...
...
一个还好用的icon库 qtawesome https://pypi.org/project/QtAwesome/
开发中用的最多的应该是designer吧，就先来说说这个配置吧。
这个可以在文件中直接打开，也可以配置 external tools
上图~~
点+号
program是designer的路径，working directory是工作目录，填这个就可，可点insert找
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5e0423eebd14524309937cbd1b1e82ab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab568ac13ad893f56cba797b433a7196/" rel="bookmark">
			Unity基础之C#基础篇笔记4：函数基础，ref，out
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Unity基础之C#基础篇笔记4：函数基础，ref，out 函数基础1.函数概念2.函数写在哪里3.基本语法4.实际运用5.关于return6.练习 ref和out1.学习ref和out的原因2.ref和out的使用3.ref和out的区别3.习题 函数基础 1.函数概念 函数(方法) 本质是一块具有名称的代码块 可以使用函数(方法)的名称来执行该代码块 函数(方法)是封装代码进行重复使用的一种机制 函数(方法)的主要作用 1.封装代码 2.提开代码复用率(少写点代码) 3.抽象行为 右键-&gt;转到定义（F12），可以跳转到函数定义里
2.函数写在哪里 1.class语句块中 2.struct语句块中 3.基本语法 1	2	3	4 static	返回类型	函数名(参数类型参数名1，参数类型参数名2，.......) { 函数的代码逻辑; 函数的代码逻辑; 函数的代码逻辑; .........; 5 return返回值;(如果有返回类型才返回) } 1．	关于static	不是必须的	在没有学习类和结构体之前	都是必须写的 2-1．关于返回类型	引出一个新的关键字	void(表示没有返回值) 2-2．返回类型	可以写任意的变量类型	14种变量类型＋复杂数据类型（数组、枚举、结构体、类class) 3．	关于函数名	使用帕斯卡命名法	命名myName(驼峰命名法)	MlyName(帕斯卡命名法) 4-1. 参数不是必须的 可以有0~n个参数	参数的类型也是可以是任意类型的	14种变量类型＋复杂数据类型(数组、枚举、结构体、类class) 多个参数的时候	需要用逗号隔开 4-2. 参数名	用驼峰命名法 5．	当返回值类型不为void时	必须通过新的关键词	return返回对应类型的内容(注意:即使是void也可以选择性使用return) 4.实际运用 1.无参无返回值函数
//定义函数 static void SayHello() { Console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab568ac13ad893f56cba797b433a7196/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c48e37071c361ce241c3413c8a3c5cb6/" rel="bookmark">
			OSI七层参考模型图解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		OSI七层参考模型图解，希望能够帮到搜索词条的学者。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d55b3c7b71426e9e01d168827337b72c/" rel="bookmark">
			JAVA大数据-Week4-DAY3
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言第五章-数据可以Mysql必备技能第2节-数据库基础数据库介绍常用数据库介绍数据库三大范式MySQL8.0安装MYSQL8.0卸载SQL语句介绍DDL数据库表操作1数据库表操作2DDL练习讲解DML-insertDML-updateDML-deleteDML案例DCLDQL模糊查询字段控制排序聚合函数group_by_1分页limitDQL总结Navicat介绍SQL Yog介绍SQL练习1SQL练习2SQL练习3SQL练习4:聚合函数练习SQL练习5:分组练习SQL练习6:综合练习 总结 前言 第五章-数据可以Mysql必备技能 第2节-数据库基础 数据库介绍 1.1 简介
数据库（DataBase，DB）：指长期保存在计算机的存储设备上，按照一定规则组织起来，可以被各种
用户或应用共享的数据集合。
数据库管理系统（DataBase Management System，DBMS）：指一种操作和管理数据库的大型软
件，用于建立、使用和维护数据库，对数据库进行统一管理和控制，以保证数据库的安全性和完整性。
用户通过数据库管理系统访问数据库中的数据。
数据库软件应该为数据库管理系统，数据库是通过数据库管理系统创建和操作的。
数据库：存储、维护和管理数据的集合。
常用数据库介绍 1.2 常见数据库管理系统
- Oracle：Oracle数据库被认为是业界目前比较成功的关系型数据库管理系统。Oracle数据库可以运行
在UNIX、Windows等主流操作系统平台，完全支持所有的工业标准，并获得最高级别的ISO标准安全性
认证。
[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-hfzkN1f6-1616597962182)(C:\Users\jiajun.lin\AppData\Roaming\Typora\typora-user-images\image-20210324150711518.png)]
- MySQL：MySQL是一个关系型数据库管理系统，由瑞典MySQL AB 公司开发，目前属于 Oracle旗下
产品。MySQL 是最流行的关系型数据库管理系统之一，在 WEB 应用方面，MySQL是最好的 RDBMS
(Relational Database Management System，关系数据库管理系统) 应用软件。
[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-wIwf7hrM-1616597962185)(C:\Users\jiajun.lin\AppData\Roaming\Typora\typora-user-images\image-20210324150726357.png)]
- DB2：DB2是IBM公司的产品，DB2数据库系统采用多进程多线索体系结构，其功能足以满足大中公司
的需要，并可灵活地服务于中小型电子商务解决方案。
- Microsoft SQL Server：SQL Server 是Microsoft 公司推出的关系型数据库管理系统。具有使用方便
可伸缩性好与相关软件集成程度高等优点。
[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-vZKp4Bgm-1616597962187)(C:\Users\jiajun.lin\AppData\Roaming\Typora\typora-user-images\image-20210324150740956.png)]
数据库三大范式 1.3 三大范式（规范）
什么是三大范式：
第一范式：**无重复的列。**当关系模式R的所有属性都不能在分解为更基本的数据单位时，称R是满足第一
范式的，简记为1NF。满足第一范式是关系模式规范化的最低要求，否则，将有很多基本操作在这样的
关系模式中实现不了。
第二范式：属性完全依赖于主键 [ 消除部分子函数依赖 **]****。**如果关系模式R满足第一范式，并且R得所有
非主属性都完全依赖于R的每一个候选关键属性，称R满足第二范式，简记为2NF。第二范式（2NF）是
在第一范式（1NF）的基础上建立起来的，即满足第二范式（2NF）必须先满足第一范式（1NF）。第
二范式（2NF）要求数据库表中的每个实例或行必须可以被唯一地区分。为实现区分通常需要为表加上
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d55b3c7b71426e9e01d168827337b72c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f24c595c19d95b52ea37ec7353f7424/" rel="bookmark">
			索引失效的原因
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.没遵守最左前缀法则（查询从索引的最左前列开始，并且不跳过索引中间的列）
2.在索引上做了操作（计算、函数、（自动或手动）类型转换）
3.存储引擎不能使用索引中范围条件右边的列（范围之后全失效）
4.mysql在使用不等于（!=或者&lt;&gt;）的时候无法使用索引
5.is null，is not null 也无法使用索引
6.like以通配符开头（’%abc…’）mysql索引会失效
7.字符串不加单引号索引失效
8.少用or，用它来连接时会索引失效
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69a80a20dd0f80a9996a8ac8540fa5d4/" rel="bookmark">
			Join多表连接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		内连接、左连接、右连接以及全连接查询
内连接查询 inner join 关键字：inner join on
语句：select * from a_table a inner join b_table b on a.a_id = b.b_id;
说明：组合两个表中的记录，返回关联字段相符的记录，也就是返回两个表的交集（阴影）部分。
案例解释：在boy表和girl 表中查出两表 id 字段一致的姓名（gname，bname），boy表和girl 表如下：
采用内连接查询方式：
SELECT * FROM boy INNER JOIN girl ON boy.bid=girl.gid
内连接和等值连接一样
SELECT * FROM boy,girl WHERE boy.bid=girl.gid;
左连接查询 left join 关键字：left join on / left outer join on
语句：SELECT * FROM a_table a left join b_table b ON a.a_id = b.b_id;
说明： left join 是left outer join的简写，它的全称是左外连接，是外连接中的一种。 左(外)连接，左表(a_table)的记录将会全部表示出来，而右表(b_table)只会显示符合搜索条件的记录。右表记录不足的地方均为NULL。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/69a80a20dd0f80a9996a8ac8540fa5d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0a5470e76f6257781676ac3f5f23d97/" rel="bookmark">
			SpringMVC的执行流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.用户发送请求至前端控制器DispatcherServlet。
2.DispatcherServlet收到请求后调用HandlerMapping处理器映射器。
3.处理器映射器根据请求URL查找匹配该url的Handler，并返回一个执行链。
4.DispatcherServlet再请求 处理器适配器（HandlerAdapter）调用相应的Handler进行处理并返回ModelAndView给DispatcherServlet.
5.DispatcherServlet将ModelAndView请求ViewReslover(视图解析器)解析，返回具体的View。
6.DispatcherServlet对View进行渲染（即将数据填充到视图中）。
7.DispatcherServlet将页面响应给用户。
DispatcherServlet：前端控制器
用户请求到达前端控制器，它就相当于mvc模式中的c，dispatcherServlet是整个流程控制的中心，由它调用其它组件处理用户的请求，dispatcherServlet的存在降低了组件之间的耦合性。
HandlerMapping：处理器映射器
HandlerMapping负责根据用户请求url找到Handler即处理器，springmvc提供了不同的映射器实现不同的映射方式，
例如：配置文件方式，实现接口方式，注解方式等。
Handler：处理器
Handler 是继DispatcherServlet前端控制器的后端控制器，在DispatcherServlet的控制下Handler对具体的用户请求进行处理。
由于Handler涉及到具体的用户业务请求，所以一般情况需要程序员根据业务需求开发Handler。
HandlAdapter：处理器适配器
通过HandlerAdapter对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理器进行执行。
ViewResolver：视图解析器
View Resolver负责将处理结果生成View视图，View Resolver首先根据逻辑视图名解析成物理视图名即具体的页面地址，
再生成View视图对象，最后对View进行渲染将处理结果通过页面展示给用户。
View：视图
springmvc框架提供了很多的View视图类型的支持，包括：jstlView、freemarkerView、pdfView等。我们最常用的视图就是jsp。
一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由程序员根据业务需求开发具体的页面。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/797814b8de47f15a1245508e6352f9bd/" rel="bookmark">
			FPGA时序约束（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 时序约束理论篇 建立和保持时间时序路径时序模型 2.I/O管脚约束 管脚约束延迟约束 3.时钟周期约束 4.两种时序例外 多周期路径伪路径 5.xdc约束优先等级 建立和保持时间
建立时间：在clk上升沿到来之前，保持稳定（准备好开始）
保持时间：在clk上升沿到来之后，保持稳定（别动！） 时序路径
典型的额时需路径有4种，如下图所示：其中标记1和3是片间路径，2和4是片内路径。
这几类中，我们关注比较多的是2的同步时序逻辑，也就是FPGA内部的时序逻辑。
时序模型
一个完整的时序路径包括：源时钟路径，数据路径，目的时钟路径，也可以表示为触发器+组合逻辑+触发器的模型。
面试常考的两条公式（要理解）：
2.I/O管脚约束
管脚约束就是管脚分配，我们要指定管脚两个属性：PACKAGE_PIN和IOSTANDARD（管脚位置和管脚对应的电平标准）。
如：
延迟约束：
延迟约束用的是set_input_delay和set_output_delay，分别用于input端和ouput端，其时钟源可以是时钟输入管脚，也可以是虚拟时钟。但是需要注意的是，这两个约束并不是起延迟作用。
3.时钟周期约束：顾名思义，是对时钟的周期进行约束。
常用的约束指令有：
1&gt;create_clock。使用方法如下：
这里的时钟必须是主时钟primary clock，主时钟通常有两种情形:一种是时钟由外部时钟源提供，通过时钟引脚进入FPGA，该时钟引脚绑定的时钟为主时钟:另一种是高速收发器(GT)的时钟RXOUTCLK或TXOUTCLK。对于7系列FPGA，需要对GT的这两个时钟手工约束:对于UltraScale FPGA，只需对GT的输入时钟约束即可，Vivado会自动对这两个时钟约束。
2&gt;create_generated_clock,其使用方法为：
3&gt;set_clock_groups使用方法为：
这个约束常用的方法有三种。
4&gt;创建虚拟时钟
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4c081884974280c7d9a4f4bc3cd9300/" rel="bookmark">
			一起看看 HTTP/2 牛逼在哪？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		不多 BB 了，直接发车！
一起来看看 HTTP/2 牛逼在哪？
HTTP/1.1 协议的性能问题 我们得先要了解下 HTTP/1.1 协议存在的性能问题，因为 HTTP/2 协议就是把这些性能问题逐个攻破了。
现在的站点相比以前变化太多了，比如：
消息的大小变大了，从几 KB 大小的消息，到几 MB 大小的消息；页面资源变多了，从每个页面不到 10 个的资源，到每页超 100 多个资源；内容形式变多样了，从单纯到文本内容，到图片、视频、音频等内容；实时性要求变高了，对页面的实时性要求的应用越来越多； 这些变化带来的最大性能问题就是 HTTP/1.1 的高延迟，延迟高必然影响的就是用户体验。主要原因如下几个：
延迟难以下降，虽然现在网络的「带宽」相比以前变多了，但是延迟降到一定幅度后，就很难再下降了，说白了就是到达了延迟的下限；并发连接有限，谷歌浏览器最大并发连接数是 6 个，而且每一个连接都要经过 TCP 和 TLS 握手耗时，以及 TCP 慢启动过程给流量带来的影响；队头阻塞问题，同一连接只能在完成一个 HTTP 事务（请求和响应）后，才能处理下一个事务；HTTP 头部巨大且重复，由于 HTTP 协议是无状态的，每一个请求都得携带 HTTP 头部，特别是对于有携带 cookie 的头部，而 cookie 的大小通常很大；不支持服务器推送消息，因此当客户端需要获取通知时，只能通过定时器不断地拉取消息，这无疑浪费大量了带宽和服务器资源。 为了解决 HTTP/1.1 性能问题，具体的优化手段你可以看这篇文章「」，这里我举例几个常见的优化手段：
将多张小图合并成一张大图供浏览器 JavaScript 来切割使用，这样可以将多个请求合并成一个请求，但是带来了新的问题，当某张小图片更新了，那么需要重新请求大图片，浪费了大量的网络带宽；将图片的二进制数据通过 base64 编码后，把编码数据嵌入到 HTML 或 CSS 文件中，以此来减少网络请求次数；将多个体积较小的 JavaScript 文件使用 webpack 等工具打包成一个体积更大的 JavaScript 文件，以一个请求替代了很多个请求，但是带来的问题，当某个 js 文件变化了，需要重新请求同一个包里的所有 js 文件；将同一个页面的资源分散到不同域名，提升并发连接上限，因为浏览器通常对同一域名的 HTTP 连接最大只能是 6 个； 尽管对 HTTP/1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a4c081884974280c7d9a4f4bc3cd9300/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca8accdea279347dfbb4a07dd2d0daff/" rel="bookmark">
			pyinstaller如何下载以及问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		pyinstaller如何下载以及问题解决。
①windows+R,输入cmd在控制面版输入pip install pyinstaller就可以下载。
②成功会出现Successfully installed pyinstaller-x.x.x.,同时在你的python的安装目录scripts。
③在控制面板进入你编写程序的文件目录。
④成功后，进入，生成的dist文件夹，按图片步骤输入
回车，就可运行.exe文件。
问题解决。
①报错解决方法输入pip install pyinstaller-4.2.tar.gz -i https://pypi.douban.com/simple/
②看自己的python环境是否已经配置，如果没有，按照下图，根据自己的python安装的地方配置环境变量，在path中添加这两个环境变量，
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84b59e7b803f7e74b046ca3d254ca060/" rel="bookmark">
			Efuse--电编程熔丝
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Efuse–电编程熔丝 一次性可编程存储器。eFuse的诞生源于几年前IBM工程师的一个发现：与更旧的激光熔断技术相比，电子迁移(EM)特性可以用来生成小得多的熔丝结构。EM熔丝可以在芯片上编程，不论是在晶圆探测阶段还是在封装中。采用I/O电路的片上电压(通常为2.5V)，一个持续200微秒的10毫安直流脉冲就足以编程单根熔丝。
eFuse 就好像在硅片上建立了无数个交通岗哨，控制信号的传输或停止，据悉这将把芯片中的电路运行效率提高上千倍。这种功能将会为电子领域带来一种“大规模市场效应。”FPGA提供商加州Xilinx公司CTO里奥.波尔森先生表示：“比如您购买了一个新的控制器，最开始的时候控制器的功能是空的，不过在把它带回家后，它重新识别了您家中的所有系统，电视、音响、DVD，并且自动对自身进行改造，来控制这些电器。（–源自百度百科）
Efuse和PROM都属于一次性可编程存储器（One Time Programmable，OTP）。
IBM公司日前发布了一项新技术“eFuse”。公司表示，这是一项芯片技术，可以使处理器产品变得更加智能化。
IBM公司发言人表示，“eFuse”技术就是给每个芯片都增加了无数的微型电熔断器，与特定的内置软件结合使用，可以确保芯片自动改变其内部线路，用来解决各种芯片问题，或是提升芯片效率。
IBM公司表示，这种熔断器被内置在芯片中，对于消费者而言没有任何的附加成本。但是却可以控制电流速度，因此能够有效地管理芯片的性能和能耗问题。例如，当电流速度过快时，熔断器可以调整芯片电压。同时，它还可以修复部分芯片问题。
另外，如果芯片局部发生问题，例如存储器发生问题，那么这种熔断器可以关闭已损害的芯片功能，已保证其他功能不受影响。而且，“eFuse”还可以根据用户需求对芯片进行重新编程。
据悉，“eFuse”技术是IBM此前所宣布的更广泛的开发战略的一部分。通过该战略，IBM试图进一步提升其处理器产品的性能和稳定性。除此之外，IBM认为，要提高芯片性能，必须要从三方面入手：首先是要不断为芯片增加像“eFuse”这样的新特征，其次还要完善软件程序，另外还要考虑芯片的使用对象。（源自IBM报道）
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/210/">«</a>
	<span class="pagination__item pagination__item--current">211/321</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/212/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>