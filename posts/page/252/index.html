<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3eddb600ba3c27a1618824596a955e7/" rel="bookmark">
			2.设计模式七大原则
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		设计模式的目的 编写软件过程中，程序员面临着来自 耦合性，内聚性以及可维护性，可扩展性，重用性，灵活性 等多方面的挑战，设计模式是为了让程序(软件)，具有更好
1) 代码重用性 (即：相同功能的代码，不用多次编写) 2) 可读性 (即：编程规范性, 便于其他程序员的阅读和理解) 3) 可扩展性 (即：当需要增加新的功能时，非常的方便，称为可维护) 4) 可靠性 (即：当我们增加新的功能后，对原来的功能没有影响) 5) 使程序呈现高内聚，低耦合的特性 分享金句： 设计模式包含了面向对象的精髓，“懂了设计模式，你就懂了面向对象分析和设计（OOA/D）的精要”Scott Mayers 在其巨著《Effective C++》就曾经说过：C++老手和 C++新手的区别就是前者手背上有很多伤疤
设计模式常用的七大原则有:
单一职责原则接口隔离原则依赖倒转(倒置)原则里氏替换原则开闭原则迪米特法则合成复用原则 设计模式原则，其实就是程序员在编程时，应当遵守的原则，也是各种设计模式的基础(即：设计模式为什么这样设计的依据)
一.单一职责原则 基本介绍: 对类来说的，即一个类应该只负责一项职责。如类A负责两个不同职责：职责1，职责2。当职责1需求变更而改变A时，可能造成职责2执行错误，所以需要将类A的粒度分解为 A1，A2
应用实例:
方案1 public class SingleResponsibility1 { public static void main(String[] args) { Vehicle vehicle = new Vehicle(); vehicle.run("摩托车"); vehicle.run("汽车"); vehicle.run("飞机"); } } // 交通工具类 // 方式1 // 1. 在方式1 的run方法中，违反了单一职责原则 // 2. 解决的方案非常的简单，根据交通工具运行方法不同，分解成不同类即可 class Vehicle { public void run(String vehicle) { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e3eddb600ba3c27a1618824596a955e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c90532a6678c1859366db843bcfbb838/" rel="bookmark">
			注意Mysql读取值很大的Double类型数据时会采用科学计数法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 休息了好久，今天终于开工了。一个同事年前写的一段代码，今天测试的时候出了点问题，便找到我，我看了看他的代码，大概知道了原因。他要做的功能是采取POI导出数据为Excle，而且年前测试也没发现什么问题，但是由于某些原因，需要我导部分测试数据给他，所以测试出现问题便找到了我。
说来也挺有意思，导给他的数据是今儿现造的，其中涉及的金额一项，我都设置的特别大，都是几亿几亿的造，导致他导出来的表格金额这一项，采用的是科学记数法，他也没想到，其中原因是因为Mysql读取值很大的Double类型数据时会采用科学计数法，让他打了日志看，他也发现了问题所在。那么，如何解决呢？
public static void main(String[] args) { Double dabo = 88664433210.88d; System.out.println(dabo); /** * 方法一 */ DecimalFormat df = new DecimalFormat(); df.setMaximumFractionDigits(2);// 设置小数位 String replace = df.format(dabo).replace(",", ""); //去掉千分符号 System.out.println(replace); /** * 方法二 */ java.text.NumberFormat nf = java.text.NumberFormat.getInstance(); nf.setGroupingUsed(false); String scoreStr = nf.format(dabo); System.out.println(scoreStr); /** * 方法三 */ NumberFormat numberFormat = NumberFormat.getNumberInstance(); numberFormat.setMaximumFractionDigits(0); numberFormat.setMinimumFractionDigits(0); numberFormat.setMaximumFractionDigits(2);// 设置小数位 String format = numberFormat.format(dabo).replace(",", ""); //去掉千分符号; System.out.println(format); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d39328110189d2e1258cf808e917570e/" rel="bookmark">
			2.6-使用C#Winform开发Tcp/Udp网络小助手（含步骤和源码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、界面设计 在做软件之前使用“软件界面设计工具”先设计并绘制出软件界面，方便在写代码之前确认“功能需求”以及“交互流程”。
这里使用的软件是：“Axure RP”
二、新建工程与绘制界面 新建工程：
使用任意一个Visual studio即可，这里使用Visual studio2017作为开发环境（安装的时候选择.net桌面开发）。新建工程选择“c# winform类型的工程，然后填写工程名字即可完成工程创建”。
绘制图形界面：
鼠标单击打开“From1.cs”文件，会出现界面绘制界面。点击软件左侧栏的“工具栏”弹出界面控件列表，选择要绘制的控件拖动到软件绘制界面，并调整控件位置，直到达到设计图所设计的样子。如下图所示：
添加按钮按下相应函数：
选中按钮并使用右键点击“属性”，从而打开这个按钮的属性配置窗口，在窗口里可以设置很多属性，切换到事件配置页面（闪电图标）即可编辑与此控件相关的事件。在“事件配置页面”即可给按钮添加点击事件响应函数，如下图所示：
三、用到的库函数说明 .net提供了串口编程函数类，为了避免把逻辑代码和界面代码混合编写。这里给串口相关操作函数做了二次封装(采用类似工厂模型建立)。界面代码只要调用二次封装的类即可完成网络通信。
Udp broadcast UdpClient { //.net提供的类 UdpClient();//新建对象即可使用，没有Open函数 bool EnableBroadcast { get; set; }//设置允许广播 void Close();//关闭对象相关资源 int Send(byte[] dgram, int bytes, IPEndPoint endPoint);//发送udp数据包，参数（数据，目标ip，目标端口） int Available { get; }//是否有数据可读 byte[] Receive(ref IPEndPoint remoteEP);//读取数据（阻塞函数），开启一个线程循环调用此函数读取 } Udp client UdpClient {//.net提供的类 UdpClient();//新建对象即可使用，没有Open函数 void Close();//关闭对象相关资源 int Send(byte[] dgram, int bytes, IPEndPoint endPoint);//发送udp数据包，参数（数据，目标ip，目标端口） int Available { get; }//是否有数据可读 byte[] Receive(ref IPEndPoint remoteEP);//读取数据（阻塞函数），开启一个线程循环调用此函数读取 } Udp server UdpClient {//.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d39328110189d2e1258cf808e917570e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5e104ba46888b6434eff15667c4804d/" rel="bookmark">
			webstorom设置字号
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 webstorom设置字号 点击：文件》设置
1.设置软件界面字号 2.设置编辑器字号 3.开启Ctrl+鼠标滚轮功能，灵活调整字号 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/098cc53ccc08203ff73a108616275a15/" rel="bookmark">
			linux系统定时设置每隔xx秒执行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由于crontab最小只能精确到分钟，如果想每20秒执行一次，直接用crontab是不能实现的，可以变通实现：
cmd sleep 20; cmd sleep 40; cmd 当然这样看起来比较麻烦，可以用：while true; do cmd; sleep 20; done这样的来替代上面的，不过没有用到这个，在这就不测试了，有用到或需要的可以试一试。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e74ab1f3063e9f680f6d927b6920983/" rel="bookmark">
			react-native转场动画,让你的APP瞬间绚丽起来
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前言 关于react-native的转场动画这里要依赖于路由库"react-navigation":“3.6.1”，可以实现包括向上转场、向下转场、向左转场、向右转场、缩放、alpha值变化、旋转等多种动画。
二、实现方式 以向左转场为例，我们需要在项目路由下 -&gt; createStackNavigator -&gt; transitionConfig 配置参数如下
transitionConfig: (sceneProps) =&gt; ({ transitionSpec: { duration: 3000, // easing: Easing.out(Easing.poly(1)), easing: Easing.bounce, timing: Animated.timing, }, screenInterpolator: sceneProps =&gt; { const {layout, position, scene} = sceneProps; const {index} = scene; console.log('zhanglei-index:' + index); const height = layout.initHeight; //沿X轴平移 const translateX = position.interpolate({ inputRange: [index - 1, index, index + 1], outputRange: [height, 0, 0], }); //沿Y轴平移 const translateY = position.interpolate({ inputRange: [index - 1, index, index + 1], outputRange: [height, 0, 0], }); //透明度 const opacity = position.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4e74ab1f3063e9f680f6d927b6920983/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19d0efc92ecfbf567832308fa27ea8d7/" rel="bookmark">
			idea springboot 自动编译
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		idea初使用之自动编译 原文地址：https://blog.csdn.net/diaomeng11/article/details/73826564/
因为公司需要，方便使用框架以及代码整合，使用同一开发集成环境idea，因为以前一直使用eclipse和Myeclipse，使用idea还有很多方面不习惯，这里记录一下使用过程，方便之后查看备用。
以下使用的版本为IDEA 2017.1
首先使用过程中为了方便要解决的就是idea自动编译（make）问题，省却了每次修改代码以后又要重新启动的步骤。
其实IDEA自己有带make快捷键：ctrl+F9，不过每次更改代码以后需要ctrl+s,ctrl+F9两次操作确实麻烦。
去网上查询，方法如下：
1，设置File -&gt;Setting -&gt;Compile：
勾选“Make project automatically”选项
2，勾选上图"Compile independent modules in parallel”选项
3，取消运行前make，在Run -&gt;Edit Configuration中，选择 Defaults-&gt;Application，去掉下方Before里的make即可
4，File -&gt; Invalidate Caches / Restart ;
事实上我按照这个步骤做，并没有起到作用，具体原因暂时没有找到，不过这里提供第二种选择，如果上面的方法不可行的话，可以选择试试看
1，步骤1与上面方法步骤1是一样的
设置File -&gt;Setting -&gt;Compile：
勾选“Make project automatically”选项
2，使用快捷键ctrl+alt+shift+/，选择选项Registry，打开下面的界面
并找到图中红框的选项"compller.automake.allow.when.app.running"并勾选
close掉即可，此时已经生效，修改代码后ctrl+s会自动重新编译
网上还找到了另一种方法，上面说了，ctrl+F9其实就是编译，他的方法是将ctrl+s和ctrl+F9集成：
https://my.oschina.net/fdblog/blog/172229
总结：这里的快捷操作也因时因人为异，不是什么时候自动编译都好，有时候不希望实时编译的时候，这样的快捷方式反而成了困扰，所以，使用ctrl+s 和ctrl+F9复合操作也不失是一种好的选择
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/287a32c31f0e0e7d3757cc144be4c5c5/" rel="bookmark">
			查找数组中的元素
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今日在刷牛客网上面的面试题，然后碰到手写编程题，就将他们记录下来
题目一 查找数组中的元素 题目给的是这个样子
其实知道数组方法的都会觉得特别简单，直接使用indexOf方法就可以实现，因为他可以查找数组中某一项在数组中第一次出现的位置的位置
function indexOf(arr, item) { return arr.indexOf(item); } indexOf([1,2,3,4],3); 但是如果浏览器不支持indexof的情况下呢，就要先判断，然后使用自定义方式
function indexOf(arr, item) { if (Array.prototype.indexOf){//判断数组的原型是否有index方法 return arr.indexOf(item); } else { for (var i = 0; i &lt; arr.length; i++){ if (arr[i] === item){ return i; } } } return -1; } indexOf([1,2,3,4],3); 而且其实第一种方式还有一个局限性，就是如果数组中要查找的那一项还有重复的话，那么indexof只能返回该项第一次出现的位置。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f44be4881e1e78f72cb1f10d5250b09b/" rel="bookmark">
			kali中安装shodan及使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 安装命令kali中shodan的使用 ~~~~~~~~ 因为想要面对一个新的开始，一个人必须有梦想、有希望、有对未来的憧憬。如果没有这些，就不叫新的开始，而叫逃亡。 ​​​​
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ————玛丽亚·杜埃尼亚斯
shodan除了可以在web上直接操作，还可以在命令行以及编写python脚本去进行批量化操作。
安装命令 git clone https://github.com/achillean/shodan-python.git cd shodan-python python setup.py install kali中shodan的使用 shodan -h 查看帮助文档
相关参数解释
Commands: alert Manage the network alerts for your account # 管理账户的网络提示 convert Convert the given input data file into a... # 转换输入文件 count Returns the number of results for a search # 返回查询结果数量 download Download search results and save them in a... # 下载查询结果到文件 honeyscore Check whether the IP is a honeypot or not.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f44be4881e1e78f72cb1f10d5250b09b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0de129c710dba2e92bfa81daebc2a30/" rel="bookmark">
			队列——邻接矩阵的宽度优先搜索（C&#43;&#43;）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目描述 有 n 个人，他们的编号为 1~n，其中有一些人相互认识，现在 x 想要认识 y，可以通过他所认识的人来认识更多的人（如果 a 认识 b，b 认识 c，那么 a 可以通过 b 来认识 c），求出 x 最少需要通过多少人才能认识 y。
输入 第 1 行 3 个整数 n、x、y，2≤n≤100；
接下来的 n 行是一个 n×n 的邻接矩阵，
a[i][j]=1 表示 i 认识 j，a[i][j]=0 表示不认识。
保证 i=j 时，a[i][j]=0，并且 a[i][j]=a[j][i]。
输出 一行一个整数，表示 x 认识 y 最少需要通过的人数。数据保证 x 一定能认识 y
样例输入 5 1 5
0 1 0 0 0
1 0 1 1 0
0 1 0 1 0
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c0de129c710dba2e92bfa81daebc2a30/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1e9bd9a880f3e072b0ef082d69b8a20/" rel="bookmark">
			报错：Caused by: java.net.SocketTimeoutException: connect timed out
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mongodb连接超时 com.mongodb.MongoTimeoutException: Timed out after 30000 ms while waiting to connect. Client view of cluster state is {type=UNKNOWN, servers=[{address=192.168.74.129:27017, type=UNKNOWN, state=CONNECTING, exception={com.mongodb.MongoSocketOpenException: Exception opening socket}, caused by {java.net.SocketTimeoutException: connect timed out}}]
详情片段：
com.mongodb.MongoTimeoutException: Timed out after 30000 ms while waiting to connect. Client view of cluster state is {type=UNKNOWN, servers=[{address=192.168.74.129:27017, type=UNKNOWN, state=CONNECTING, exception={com.mongodb.MongoSocketOpenException: Exception opening socket}, caused by {java.net.SocketTimeoutException: connect timed out}}] at com.mongodb.connection.BaseCluster.getDescription(BaseCluster.java:167) at com.mongodb.Mongo.getConnectedClusterDescription(Mongo.java:885) at com.mongodb.Mongo.createClientSession(Mongo.java:877) at com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e1e9bd9a880f3e072b0ef082d69b8a20/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47c3aec29f9561be39ab67ac08ee03b9/" rel="bookmark">
			jenkins服务器远程执行脚本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		**
jenkins一般部署在Windows系统上面，如果要执行linux系统上面的shell脚本，该怎么操作呢？ 解决思路：jenkins通过ssh远程连接linux系统，然后构建command命令
具体实现如下：
1.安装SSH pulgins 插件 —&gt; 系统管理-插件管理-可选插件-过滤
2.权限认证即添加凭据 —&gt; Credentials- Add Credentials 填写远程服务器用户名密码（即linux系统用户名密码）
3. 配置ssh信息。系统管理-&gt;系统设置-&gt;SSH remote hosts
4.进入项目配置，构建
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bad2cba9c3c05a3ae0e7face2ce06b8f/" rel="bookmark">
			sci论文小修经验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		论文小修经验：
1.时间：论文小修给的时间一般比较短，在编辑的回信里会清楚写明截止的返修日期。一般截止日期那一天也可以，比如写，截止值Feb-16th，通常16号那天也可以，但是注意编辑部所在时区的时差。为了保险起见，至少比截止日期提前一天返修。
2.返修内容：返修需要上传两个文件，一个是修改后的手稿，通常用红色标注出修改的内容。一个是resopnse letter。在论文返修系统上传文件时，可能会要求选择resopnse letter的属性，这个其实随便选择就可以。因为最终编辑看到的稿子是两个文件合成的一个pdf文件。
3.小修内容：小修一般需要改动的内容比较少，不会存在结构性的调整。
可能的问题有：
参考文献过旧
句子有打字错误和语法错误
进一步说明文章的创新点
需要在conlusion加上关于此课题预计进一步开展的工作
需要在introduction最后概述每一章的内容
某某公式数学分析太简略，和创新点联系较少，建议进一步阐述
某某公式如果实部和虚部分开解释更好
简写的每个单词都要大写
等等
针对上述问题通常可以可以这样进行修改和写resopnse letter
1.参考文献过旧：
要把参考文献尽量全部换成近三年的。
如果有不是近三年的但是特别重要的文献要说明一下。
比如：我们已经将文献大部分换为近三年的。其中近三年参考文献占比xx%。文献xx虽然是2012年的，但是它在doa中起重要作用。它是第一篇提出将espri算法和lwa结合的论文，因此我们保留了它。
2.打字和语法错误太多:
我们已经请英语为母语国家的人润色过…
具体的resopnse letter和模板在下一篇列出。
参考文献格式的问题：
一般论文管理软件直接导出的文献参考格式和IEEE需要的不太一致。需要自己在IEEE数据库搜到参考的文献，根据IEEE该论文所在页面或者论文内给的信息将参考文献信息补充完整。比如参考文献的格式：
[16]Shah K H , Sonagara J S , Patel S K , “Design of optical leaky wave antenna with circular and diamond Si perturbations for enhancing its performance,” Microw. Opt. Technol. Lett, vol. 60, no. 6, pp. 1395– 1398, Apr.2018.
具体发表月份需要去网站上找。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bad2cba9c3c05a3ae0e7face2ce06b8f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cfdb3f542b44a5a30310f74e3b89450d/" rel="bookmark">
			STM32——TIM1的TIM1_CH1N通道PWM初始化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		TIM1 是 STM32 的高级定时器，功能很强大，它的每个通道都有对应的互补通道用来互补输出PWM。之前没使用过，今天要用来做 PWM 控制，花了好一番功夫才搞定。
记录下初始化代码： void Led_PWM_Init(u16 arr, u32 ckCnt, u16 CCR1_Val) { uint16_t pscValue = 0; TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure; TIM_OCInitTypeDef TIM_OCInitStructure; NVIC_InitTypeDef NVIC_InitStructure; RCC_APB2PeriphClockCmd(RCC_APB2Periph_TIM1, ENABLE); GPIO_Config(); //PWM控制引脚初始化 TIM_DeInit(TIM1); /* Time Base configuration */ pscValue = (uint16_t)(SystemCoreClock / ckCnt) - 1; TIM_TimeBaseStructure.TIM_Prescaler = pscValue ; TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up; TIM_TimeBaseStructure.TIM_Period = arr; TIM_TimeBaseStructure.TIM_ClockDivision = 0; TIM_TimeBaseStructure.TIM_RepetitionCounter = 0; //高级定时器特有 TIM_TimeBaseInit(TIM1, &amp;TIM_TimeBaseStructure); /* Channel 1, 2,3 and 4 Configuration in PWM mode */ TIM_OCInitStructure.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cfdb3f542b44a5a30310f74e3b89450d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d13248dbf0b74b37ed2b84f7a520e9c/" rel="bookmark">
			ROS Navigation导航包介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Navigation功能包集概述 这是2D的导航功能包集，通过接收里程计数据、tf坐标变换树以及传感器数据，为移动机器人输出目标位置以及安全速度。概念层面上讲，导航功能包集是相当简单的。 它从里程计和传感器数据流获取信息，并将速度命令发送给移动基站（比如你的机器人）。但是，想要在任意机器人上使用导航功能包集可能有点复杂。使用导航功能包集的先决条件是，机器人必须运行ROS，有一个tf变换树，使用正确的ROS Message types发布传感器数据。而且，我们需要在高层为一个具有一定形状和动力学特点的机器人配置导航功能包集。
acml：是一个针对在二维移动的机器人的基于概率定位系统。它实现了自适应蒙特卡罗滤波的定位方法，并使用粒子滤波器去跟踪在已知地图中机器人的位置。
base_local_planner：这个包提供了Trajectory Rollout以及Dynamic Window两种在2D平面局部导航的方法。通过提供一个跟随的规划路径和一个代价地图，控制器生成速度指令并发送至机器人。它支持全向和非全向机器人，以及任何可以用多边形或圆描述的机器人轮廓，并且可以在launch文件中设置这些参数。这个包已经被封装好，可以通过nav_core包的BaseLocolPlanner接口来调用。
carrot_planner：这个规划器是一个简单的全局规划器，可以通过nav_core::BaseGlobalPlanner 来进行调用，并且被move_base节点用作一个全局规划的插件。这个规划器从用户处采集到一个目标点，之后检查用户指定的目标点是否是障碍物，如果是的话沿着robot与目标点构成的向量向后退，直到找到一点没有障碍物位置。之后它会将此目标点作为目标发送给局部规划器和控制器。这个规划器允许机器人尽可能到达离用户指定的目标点最近的位置。
clear_costmap_recovery：为导航包提供了一种自救行为，试图通过将代价地图还原成已知区域外的静态地图从而清除出空间。
costmap_2d：通过激光或点云的数据，投影到2D平面上，创建代价地图，并可以设置膨胀半径。
dwa_local_planner：局部规划器，提供动态窗口方法（ Dynamic Window Approach）在平面上局部导航。与base_local_planner类似。
fake_localization：提供了一个简单节点fake_localization node，可以代替一个定位系统，并提供了acml包的ROS API的子集。由于较低的计算量，这个节点非常频繁的用于在仿真环境中提供完美的定位。这个节点将里程计数据转换为位置、粒子云，并以acml发布的数据格式发布。
global_planner：全局路径规划节点。
map_server：将代价地图作为ROS Service发布，提供了map_saver节点，可以通过命令行存储地图。
move_base：提供了action动作的实现（actionlib包），即给定一个世界系下的目标位置，机器人会试图移动到该位置。另外，move_base节点中包含了两个代价地图（全局、局部），以及一个全局规划器和一个局部规划器，以便实现导航任务。
move_base_msgs： 通过MoveBase.action文件定义产生的消息文件，用于actionlib与move_base的通信。
move_slow_and_clear：为robot提供一种自救行为，即清除代价地图的信息并限制机器人速度，但这不绝对安全，robot可能会撞到某些障碍。但这是唯一一种可以与允许最大速度动态设置的局部规划器兼容的自救行为。
nav_core：为robot实现导航任务提供了通用的接口，包括BaseGlobalPlanner，BaseLocalPlanner,， RecoveryBehavior interfaces等，这有利于方便的更新规划器或者自救行为的版本。
navfn：全局规划器，提供了一个快速插值的函数，可以在起始点到目标点之间快速插值，并找到代价最小的一条路径。
robot_pose_ekf：这个包用于估计robot的三维位置，利用扩展卡尔曼滤波的方法，建立了一个六维模型，联合了轮子里程计、IMU、视觉里程计的数据。
rotate_recovery：提供了一种自救行为，通过旋转360度来清除空间。
voxel_grid：提供一个有效的三维体素网格的实现
导航框架
这幅图描述了使用Navigation导航包的一个整体框架，其核心是move_base节点，包含了global_planner、local_planner、global_costmap、local_costmap、recovery_behaviors五个模块，move_base节点订阅tf（坐标系转换）、odom（里程计数据）、map（地图）、sensor datas（激光数据或点云）以及goal等话题，之后发布cmd_vel话题。
tf：利用ROS的tf工具发布坐标系之间的转换关系，包括：/map-&gt;/odom，/odom-&gt;/base_link，/base_link-&gt;/sensor等 odom：导航包需要用到里程计的数据，故需将其用tf工具和nav_msgs/Odometry消息发布出来 map：在导航前，最好可以提供一张全局的地图，因此需要我们提前创建（但这不是必须的） sensor data：用于避障，建图等等，可以是激光雷达的平面数据或者是点云数据（sensor_msgs/LaserScan or sensor_msgs/PointCloud ） goal：目标在全局地图中的坐标，用geometry_msgs/PoseStamped消息格式发布 此外，move_base节点还提供了action动作的接口（即SimpleActionServer的实现，详细可见actionlib包），包括订阅了move_base/goal (move_base_msgs/MoveBaseActionGoal)，move_base/cancel (actionlib_msgs/GoalID)两个话题，并发布了move_base/feedback (move_base_msgs/MoveBaseActionFeedback)、move_base/status (actionlib_msgs/GoalStatusArray)、move_base/result (move_base_msgs/MoveBaseActionResult)等三个话题。因此用户可以自己写一个利用actionlib库写一个发布目标位置的节点。
在熟悉完整个导航框架后，我们就可以开始依次做好相应的准备工作了。需要的步骤如下：
1、搭建一个移动平台，使其订阅/cmd_vel话题，并发布odom里程计数据以及/odom-&gt;/base_link的tf数据？？
2、将传感器数据（激光数据或RGB-D点云数据）发布出来
3、创建地图，利用slam_gmapping或hector_slam的方法
4、配置Navigation包，进行导航
参考链接：https://www.cnblogs.com/flyinggod/p/9081046.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a54dc8f7b6b09fd38b1840d8d3d0d354/" rel="bookmark">
			ORACLE_SID, SID, INSTANCE_NAME, SERVICE_NAME, SERVICES_NAMES, DB_NAME, GLOBAL_DBNAME, SID_NAME，以及网络服
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载：https://blog.csdn.net/lyjiau/article/details/52238997
在Oracle中，我们会遇到下面一系列的十分重要的参数。同时他们的含义也常常让我们混淆。这些参数有：
ORACLE_SID, SID, INSTANCE_NAME, SERVICE_NAME, SERVICES_NAMES, DB_NAME, GLOBAL_DBNAME, SID_NAME，以及网络服务名(net service name)，实例服务名(instance service name)等。下面我一个一个的来学习他们。
1. ORACLE_SID 与 SID 和 INSTANCE_NAME 以及 SID_NAME
ORACLE_SID：即ORACLE System IDentifier,它是一个环境变量。我们一般在oracle用户的home目录中的.bash_profile中进行定义，一般该文件包含下面一行：
[oracle@localhost ~]$ pwd
/home/oracle
[oracle@localhost ~]$ grep ORACLE_SID .bash_profile
export ORACLE_SID=jiagulun
其作用就是：
在我们使用在sqlplus工具中startup启动数据库时，OS就是利用这个环境变量来fork创建构成Oracle实例的各个进程，以及来命名一些文件的名字。如下所示：
[oracle@localhost ~]$ ps -ef | grep oracle
oracle 31707 1 0 13:41 ? 00:00:01 ora_pmon_jiagulun
oracle 31709 1 0 13:41 ? 00:00:00 ora_psp0_jiagulun
oracle 31711 1 0 13:41 ? 00:00:00 ora_mman_jiagulun
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a54dc8f7b6b09fd38b1840d8d3d0d354/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f95c7423457664c190a751a74fa8b875/" rel="bookmark">
			cut命令 -d -f
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://blog.csdn.net/u011700318/article/details/38554581?utm_source=distribute.pc_relevant.none-task
https://blog.csdn.net/RHEL_admin/article/details/37508101?ops_request_misc=%7B%22request%5Fid%22%3A%22158217786119725211963913%22%2C%22scm%22%3A%2220140713.130056874..%22%7D&amp;request_id=158217786119725211963913&amp;biz_id=0&amp;utm_source=distribute.pc_search_result.none-task
https://blog.csdn.net/Frozen_fish/article/details/2260804?utm_source=distribute.pc_relevant.none-task
https://www.runoob.com/linux/linux-comm-cut.html
参数:
-b ：以字节为单位进行分割。这些字节位置将忽略多字节字符边界，除非也指定了 -n 标志。 byte-c ：以字符为单位进行分割。 char-d ：自定义分隔符，默认为制表符。 define-f ：与-d一起使用，指定显示哪个区域。 fields 一般用以指定分隔符后的第几列-n ：取消分割多字节字符。仅和 -b 标志一起使用。如果字符的最后一个字节落在由 -b 标志的 List 参数指示的
范围之内，该字符将被写出；否则，该字符将被排除 语法： 必须指定 -b、-c 或 -f 标志之一。
cut [-bn] [file] cut [-c] [file] cut [-df] [file] 例子：
1、英文字符
[root@rhel6164 ~]# echo $PATH /usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/root/bin [root@rhel6164 ~]# echo $PATH | cut -d ':' -f 2,4-6 #使用：分割后，选择打印出第2,4,5,6段信息 /usr/local/bin:/bin:/usr/sbin:/usr/bin ———————————————— [root@rhel6164 ~]# echo $PATH | cut -c 2 #以字符为单位来分割，然后打印出第二个字符 u ———————————————— [root@rhel6164 ~]# echo $PATH | cut -b 2,4 #打印出第二个和第四个字节 ur 2、汉字
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f95c7423457664c190a751a74fa8b875/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03e191e7af16db8ca5ef04d2b31bb630/" rel="bookmark">
			【转】C&#43;&#43;动态调用dll库（例子）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.首先要生成一个功能简单的dll库，先新建项目–&gt;win 32项目（比如命名为CDLL）–&gt;dll（选中空项目）–&gt;完成。
2.新建一个头文件，命名为dllgenerator.h，完成如下代码：
#ifndef __CDLL_H__ #define __CDLL_H__ extern "C" int _declspec(dllexport) add(int x, int y); #endif 注：add（int x,int y）函数作为练习来使用，我们也可以用其他函数来代替，还有一个“int”是返回值类型。extern “C”是为了防止生成的dll代码在其他编译器使用时可能会被改变，其函数可能也会发生变化。
3.新建一个源文件，命名为dllgenerator.cpp(与之前的头文件名称须相同)，完成如下代码：
#include "dllgenerator.h" int add(int x, int y) { return x + y; } 此时，点击运行，在debug文件夹中则能找到生成的CDLL.dll文件。至此生成dll文件完成，接下来就是如何调用dll库的问题了。
4.新建一个项目–&gt;MFC应用程序(在此命名为Testadd)–&gt;选择对话框–&gt;完成。记得将CDLL.dll库文件导入到项目中（具体做法为右键项目，选择添加–&gt;现有项，找到库文件，添加），接下来在对话框中加入一个编辑框和一个按钮（注意编辑框的ID我设置为了IDC_STATIC），给按钮添加事件处理程序，函数名随便写，好记就行，也可以就按程序给我们定义好了的函数名，然后在事件处理程序中完成如下代码：
typedef int(*lpAddFun)(int,int); //宏定义函数指针类型 HINSTANCE hDll; //DLL句柄 lpAddFun addFun; //函数指针 hDll = LoadLibrary(_T("CDLL.dll")); int result=0;//将函数返回的值赋给它，这里先初始化 CString str; if (hDll != NULL) { addFun = (lpAddFun)GetProcAddress(hDll, "add");/*用addFun取代dll库中的add函数*/ if (addFun != NULL) { result = addFun(2, 3);//这里是将整型2和整型3作为参数传进去 str.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/03e191e7af16db8ca5ef04d2b31bb630/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11f7d44c8774dc80a3e9be47b4fff07a/" rel="bookmark">
			IIS简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		IIS简介 IIS全程为Internet Information Service, 是基于运行Microsoft Windows的一个web server，类似于java里面的tomcat。IIS是一套环境工具，不是操作系统，是安装在windows上的web平台。
IIS是一种Web（网页）服务组件，其中包括Web服务器、FTP服务器、NNTP服务器和SMTP服务器，分别用于网页浏览、文件传输、新闻服务和邮件发送等方面。其结构如下图所示：
IIS怎么工作的 IIS通过多种标准语言和协议工作。 HTML用于创建元素，例如文本，按钮，图像放置，直接交互/行为和超链接。HTTP是用于在Web服务器和用户之间交换信息的基本通信协议。 HTTPS(安全套接字层（SSL）上的HTTP)-使用传输层安全性或SSL加密通信以增加数据安全性。 文件传输协议（FTP）或其安全变体FTPS可以传输文件。
IIS和ASP.net core ASP.NET Core框架是最新一代的Active Server Page（ASP）框架，这是一种可生成交互式网页的服务器端脚本引擎。 一个请求从Web传入IIS服务器，然后将请求发送到ASP.NET Core应用程序，该应用程序处理该请求并将其响应发送回IIS服务器和发起该请求的客户端。 可以用ASP.NET Core编写的应用程序，例如博客平台和内容管理系统（CMS）。
开发人员可以使用许多工具（包括WebDAV）开发IIS网站，这些工具可以创建和发布Web内容。 开发人员还可以使用集成开发工具，例如Microsoft Visual Studio。
IIS的版本 IIS作为微软的产品与Microsoft Windows一起发展。 IIS的早期版本随Windows NT（New Technology）一起提供。 IIS 1.0与Windows NT 3.51一起出现，并且是通过带有Windows NT 4.0的IIS 4.0演变而来的。 Windows 2000附带了IIS5.0。Microsoft在Windows Server 2003中添加了IIS6.0。IIS7.0对Windows Server 2008进行了重大重新设计（IIS 7.5在Windows Server 2008 R2中）。 Windows Server 2012附带IIS 8.0（Windows Server 2012 R2使用IIS 8.5）。 IIS 10随Windows Server 2016和Windows 10一起提供。
在IIS的每次迭代中，Microsoft添加了新功能并更新了现有功能。 例如，IIS 3.0为动态脚本添加了ASP。 IIS 6.0增加了对IPv6的支持，并提高了安全性和可靠性。 IIS 8.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/11f7d44c8774dc80a3e9be47b4fff07a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/626d4253dfa24fd6d4c037f37be90514/" rel="bookmark">
			常见的几种web容器（Apache、Nginx、Tomcat）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言ApacheNginxTomcat ~~~~~~~~ 因为想要面对一个新的开始，一个人必须有梦想、有希望、有对未来的憧憬。如果没有这些，就不叫新的开始，而叫逃亡。 ​​​​
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ————玛丽亚·杜埃尼亚斯
前言 web容器就是一种服务程序，在服务器中一个端口就对应一个提供相应服务的程序，而这个程序就是处理服务器从客户端收到的请求，如Java中的Tomcat容器，ASP的IIS都是这样的容器。一个服务器可以有多个容器。web容器用于给处于其中的应用程序组件（ASP、JSP）提供一个环境，是中间件的一个组成部分，它实现了对动态语言的解析。
中间件是提供系统软件和应用软件之间连接的软件，以便于软件各部件之间的沟通。中间件处在操作系统和更高一级应用程序之间。他充当的功能是：将应用程序运行环境与操作系统隔离，从而实现应用程序开发者不必为更多系统问题忧虑，而直接关注该应用程序在解决问题上的能力 。容器就是中间件的一种。而Web中间件就是提供web应用软件和系统软件连接的软件的一个总称。
Apache Apache是世界使用排名第一的Web服务器软件。它可以运行在几乎所有广泛使用的计算机平台上，由于其跨平台和安全性被广泛使用，是最流行的Web服务器端软件之一。它快速、可靠并且可通过简单的API扩充，将Perl/Python等解释器编译到服务器中。Apache只支持静态网页，但像asp,php,cgi,jsp等动态网页就需要Tomcat来处理。
Apache的优点
支持模块多，功能多；运行稳定性强；支持PHP模块，无需安装其他多余的组件就可以实现.php动态页面的解析；地址重写功能（rewrite）强大
Nginx Nginx (engine x) 是一个高性能的HTTP和反向代理web服务器，同时也提供了IMAP/POP3/SMTP服务。它具有强大的抗并发能力；消耗主机资源小；非阻塞性异步功能的特点。nginx，则一般是做静态（html和js），本身不具备动态解析功能，需要配置其他插件或通过其他软件协同才具备动态功能。
反向代理
“它代理的是服务端，代服务端接收请求”，主要用于服务器集群分布式部署的情况下，反向代理隐藏了服务器的信息。
反向代理的作用：
（1）保证内网的安全，通常将反向代理作为公网访问地址，Web服务器是内网
（2）负载均衡，通过反向代理服务器来优化网站的负载
负载均衡
Nginx反向代理服务器接收到的请求数量，即负载量。
请求数量按照一定的规则进行分发到不同的服务器处理的规则，就是一种均衡规则。
每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。
Tomcat Tomcat 服务器是一个免费的开放源代码的Web 应用服务器，属于轻量级应用服务器，在中小型系统和并发访问用户不是很多的场合下被普遍使用，是开发和调试JSP 程序的首选。Tomcat是jsp/servlet容器，用于发布jsp及java的，类似的有IBM的webshere、EBA的Weblogic，sun的JRun等等。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ce533bea9c06a0ed568235ce2b11af3/" rel="bookmark">
			JavaScript思维导图——Day 14(dom基本操作、Node、实现inserAfter和标签逆序方法)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- &lt;div class="q13122"&gt; &lt;p&gt;&lt;/p&gt; &lt;span&gt;&lt;/span&gt; &lt;/div&gt; &lt;div&gt; &lt;strong&gt; &lt;span&gt; &lt;i&gt;&lt;/i&gt; &lt;/span&gt; &lt;/strong&gt; &lt;/div&gt; --&gt; &lt;div&gt; &lt;i&gt;&lt;/i&gt; &lt;span&gt;&lt;/span&gt; &lt;p&gt;&lt;/p&gt; &lt;strong&gt;&lt;/strong&gt; &lt;span&gt;&lt;/span&gt; &lt;/div&gt; &lt;script&gt; // var num = 0; // console.log(num++); 先用后加 // //num = num + 1; // //num + 1; // console.log(++num);先加后用 // console.log(num); // document --&gt; HTMLDocument.prototype --&gt; Document // HTMLBodyElement.prototype.abc = 'demo'; // var body = document.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7ce533bea9c06a0ed568235ce2b11af3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7653cbf262b2d4c6ec99e508ec5d5d2a/" rel="bookmark">
			Node-错误原因分析：Error: Multipart: Boundary not found
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前端使用umi-request上传文件，设置了 headers: { 'Content-Type': 'multipart/form-data' } 后端使用Eggjs接收的时候，报错
nodejs.Error: Multipart: Boundary not found
错误原因： Multipart没有找到Boundary
上传文件 是POST请求 multipart/form-data格式的 form表单
Content-Type: multipart/form-data 后面没有跟上boundary
综上推测 设置请求头的时候 多次设置了，覆盖了原有表单enctype=‘multipart/form-data’
最终查找 在xhr.setRequestHeader中 覆盖了 表单form中的 enctype 设置的mutlipart/form-data
综上： 不需要重复设置 Content-Type: mutipart/form-data 否则可能会覆盖原有的， 造成非预期的错误。
正确的方式：
前端
后端
浏览器
https://blog.csdn.net/dongzhiliwansui/article/details/87896418
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c504dffc49edc5f87b4ff8ce893db17/" rel="bookmark">
			微信小程序网络请求出现的错误（持续更新）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天在网络请求中成功时的回调函数中出现两个错误 1、this问题 2、参数的res.data问题 3、VM345:1 http://music.163.com 不在以下 request 合法域名列表中，请参考文档：https://developers.weixin.qq.com/miniprogram/dev/framework/ability/network.html 1、如图中在回调函数
that.setData({ danqus:danqus }), 之所以用that调用而非是this，是因为在回调函数中，我们要用的this，已经不是我们想要的this了，因此在回调函数外，把this赋值给that；
2、在回调函数中在对调用API获得的数据进行操作的时候，应该用res.data调用而不是res,
3、在本地测试的时候在详情——本地设置中勾选如图，便可解决
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51e3df7d01e75dd28c0316eb7a50079a/" rel="bookmark">
			Go的学习日记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 下载安装go 下载地址
2. 正常的打印 主函数的包名必须是main。。。
package main import "fmt" fuc main(){//go中{不可以单独一行，c++的同学注意了 fmt.print("hello world")//伟大的开始 } 3. 声明定义一个变量 go不存在声明却未使用的变量
也就是说，单独写这么一句，你会发现他报错了
var a int = 1 你必须使用这个变量，哪怕只是打印一下，来解决报错。（令我非常吃惊）
差点忘了说了，全局变量无视此规则…
定义变量的几种方法，这里还需要特殊说明一下，Go没有char类型！！！
var a int = 1 var b,c int =2,3 d,e := 4,5//自动推断数据类型贼赞 //这里还需要补充一下，:是初始化声明，也就是说在下面 e:=4//报错 e=4//没问题 4. 常量Const，iota const不想多说，主要是iota这个特殊常量，会在const关键字出现时被重置为0（内部），每新增一行计数器加一
有趣的写法
const( a = iota//0 b = iota//1 c = iota//2 ) const( a = 1&lt;&lt;iota//1 b = 3&lt;&lt;iota//6 ) 这里还要说明一下&lt;&lt;左移指令，1左移0位，依旧是1。3的二进制11左移一位变为110，即6。
注：&lt;&lt;n==*(2^N)
5. 条件 写法需要注意的是条件判断没有括号
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/51e3df7d01e75dd28c0316eb7a50079a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90ef10a9a2670cbf51b67a9d453a5ca2/" rel="bookmark">
			Modbus TCP的研究学习(一)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言：项目中经常要进行设备对接，之前一直用的是OPC协议，OPC-DA不能跨平台，所以最近开始研究学习Modbus协议和OPC-UA，这次先总结下Modbus TCP的学习掌握情况，供日后参考。
工具：Modbus Poll，Modbus Slave，C#开发的Modbus客户端。
先了解一些名词：
1.主站，从站：Modbus​是​使用​主从关系​实现​的​请求 - 响应​协议。 在​主从关系​中，​通信​总是​成​对​发生 —— 一个​设备​必须​发起​请求，​然后​等待​响应，并且​发起​设备​（主​设备）​负责​发起​每次​交互。 通常，​主​设备​是​人​机​界面​（HMI）​或​监​控​和​数据​采集​（SCADA）​系统，​从​设备​是​传感器、​可​编​程​逻辑​控制器​（PLC）​或可​编​程​自动​化​控制器​（PAC）。
网上看到一个通俗容易帮助理解的解释：主站就是个大帅哥，从站就是一堆的痴情女子。帅哥可以随便读写从站，想来就来，想走就走，痴情女子们能做的唯一的一件事就只能被动的等待帅哥的电话，接到帅哥电话了才能向帅哥倾诉一下，如果帅哥不打电话给她就只能干等着，直到地老天荒，帅哥只能电话给这些女子，不能电话给另外一个帅哥搞基，帅哥同一时间只能打出一个电话，问候下各位美女，这叫做“轮询”。
主站和从站是一对多的关系，Modbus Poll（主站），Modbus Slave（从站），C#开发的客户端（主站）。
2.功能码（部分常用）：
代码
中文名称
寄存器PLC地址
位操作/字操作
操作数量
01
读线圈状态
00001-09999
位操作
单个或多个
02
读离散输入状态
10001-19999
位操作
单个或多个
03
读保持寄存器
40001-49999
字操作
单个或多个
04
读输入寄存器
30001-39999
字操作
单个或多个
05
写单个线圈
00001-09999
位操作
单个
06
写单个保持寄存器
40001-49999
字操作
单个
15
写多个线圈
00001-09999
位操作
多个
16
写多个保持寄存器
40001-49999
字操作
多个
功能码可以分为位操作和字操作两类。位操作的最小单位为BIT，字操作的最小单位为两个字节。
【位操作指令】 读线圈状态01H，读(离散)输入状态02H，写单个线圈06H和写多个线圈0FH。
【字操作指令】 读保持寄存器03H，写单个寄存器06H，写多个保持寄存器10H。
1.打开Modbus Slave，点击Setup下的Slave Definition设置好参数，再选择Connection选择TCP/IP连接，从站设置完成。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/90ef10a9a2670cbf51b67a9d453a5ca2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31b39515c9a21725afe745368d699c07/" rel="bookmark">
			ArcGis将2000国家大地坐标系转WGS84
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 初始准备 只包含有坐标系的txt, ArcGis 10.4.1，excel2016
问题及需求 如题
解决方案 首先明确概念，CGS2000是地理坐标系(epsg:4490)，WGS_1984 也是地理坐标系（epsg:4326），查资料两者相差并不多。讲道理可以直接把txt处理成xls其中单元格格式为数字,然后直接导入ArcGis，再右键显示XY，导出数据成.shp文件，然后右键.shp文件图层，属性表，将数据导出成txt即可。兼有误差可以再自定义个坐标系投影方法也是ok。
实际上，拿的是投影坐标系，还是空间直角坐标，还不清楚是哪个坐标系，只知道是大地2000下的，具体分类可以看这 坐标系对应EPSG代号、经度范围、中央经线 ，查看了下根据经度发现要么是4528 ，要么是4549. 后面根据位数排除了4528，4528空间直角坐标系上是有带号的，与手上的数据不对（后面投影的时候ArcGis也会提示试图对空几何体执行该操作）
首先把手上的txt整理成这个样子,建议用notepad的查找替换支持正则表达式
然后把txt后缀改成svc,再在excel里打开，选择分隔符为tab和逗号，再设置格式为数字，就变成下面这样
然后另存为时选择 2003版的 xls类型，导出
打开ArcGIS ,右键图层添加数据
右键显示xy，选择xls里对应标题
之后右击new$ 个事件,导出数据成.shp文件，并选择添加到图层，然后就是将投影坐标系转成地理坐标系，也就是工具箱-》数据管理工具-》投影和变换-》投影，因为输入坐标系我之前定义投影了下所以是灰了不可选，而输出坐标系就先地理坐标系-&gt;Asia-&gt;China_Geodetic_Coordinate_System_2000
因为没有CGCS2000转WGS84的方法，我们就要自己定义一个坐标变换方法
因为两者差不多就不改参数了，咱也不知道 同样的方法再将2000投影到84, 地理变换就选我们刚定义的，有时候可能找不到定义的方法，这个bug可能重启才能解决
最后右击我们得到的图层打开属性表，对于不需要的字段可以右键标题关闭字段，对于空间直角坐标系的数据我们可以右键字段选择十进制度进行转换为经纬度
然后再单击属性表左上角 -》导出-》-》保存类型选择文本文件，就ok了.后面转CGJ02也比较方便
总结： 用ArcGis比较复杂，希望有大佬给出更简单的方法 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1dd09d2fcea37d6150aeebe956e98d9/" rel="bookmark">
			信息学奥赛一本通C&#43;&#43;语言——1057：简单计算器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【题目描述】
一个最简单的计算器，支持+, -, *, / 四种运算。仅需考虑输入输出为整数的情况，数据和运算结果不会超过int表示的范围。然而：
如果出现除数为0的情况，则输出：Divided by zero!
如果出现无效的操作符(即不为 +, -, *, / 之一），则输出：Invalid operator!
【输入】
输入只有一行，共有三个参数，其中第1、2个参数为整数，第3个参数为操作符（+,-,*,/）。
【输出】
输出只有一行，一个整数，为运算结果。然而：
1.如果出现除数为0的情况，则输出：Divided by zero!
2.如果出现无效的操作符(即不为 +, -, *, / 之一），则输出：Invalid operator!
【输入样例】
1 2 +
【输出样例】
3
代码
#include&lt;cstdio&gt; int main(){ int a,b; char c; scanf("%d %d %c",&amp;a,&amp;b,&amp;c); switch(c){ case '+' : printf("%d",a+b); break; case '-' : printf("%d",a-b); break; case '*' : printf("%d",a*b); break; case '/' : //如果除数为0，不能进行除法计算 if(b!=0){ printf("%d",a/b); }else{ printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f1dd09d2fcea37d6150aeebe956e98d9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9f001be5d12b4b94d7c5651a762f95f/" rel="bookmark">
			Power Query M函数帮助查询，快速了解调用测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Power Query M函数有700多个，如何快速地了解每个函数的用法，有两个方法：
一、微软官方在线文档
链接：https://docs.microsoft.com/zh-cn/powerquery-m/
链接的格式也是很规范，很好记住的。而且发现微软的帮助文档链接都比较好找，比如继续学习Power Pivot，查找dax语言的文档，链接就是：https://docs.microsoft.com/zh-cn/dax/
二、通过Power Query编辑器快速查询
1.进入查询编辑器，【新建源】=&gt;【其他源】=&gt;【空查询】
2. 在公式编辑框中输入“= #shared”后按回车
3.点击某个函数名，就会显示相应帮助信息。
4.点击“Function”，就可以对函数进行调用。
5.将源“转换到表中”，并进行“排序”，方便对具体的Power Query M函数进行查找。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53cf4439f01d497df1fccebbb588aa28/" rel="bookmark">
			数据结构基础（栈）——图的深度优先遍历（C语言实现）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目描述 读入一个邻接矩阵存储的无向图，输出它的深度优先遍历序列。
输入格式 第１行１个整数n,表示图中的顶点数，2&lt;=n&lt;=100
接下来的n行是一个n*n的邻接矩阵，a[i][j]=1表示顶点i和顶点j之间有直接边相连，a[i][j]=0表示没有直接边相连，保证i=k时a[i][j]=0,且a[i,j]=a[j,i].
输出格式 输出1~n的某一种排列，表示从顶点１开始，对该图进行深度优先遍历得到的顶点序列，每两个数之间，用一个“-”分隔
样例输入 8
0 1 1 0 0 0 0 0
1 0 0 1 1 0 0 0
1 0 0 0 0 0 1 1
0 1 0 0 0 1 0 0
0 1 0 0 0 1 0 0
0 0 0 1 1 0 0 0
0 0 1 0 0 0 0 1
0 0 1 0 0 0 1 0
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/53cf4439f01d497df1fccebbb588aa28/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b5b874e34b29205ad6ccd190669dc4b/" rel="bookmark">
			ESP8266和ESP32的nvs操作自定义分区
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 首先说一下ESP8266和ESP32 nvs的handle在声明的时候有些区别： ESP8266 RTOS中是：nvs_handle my_handle;ESP32的esp-idf中是：nvs_handle_t my_handle; 在components/nvs_flash/include/nvs.h中NVS_DEFAULT_PART_NAME宏定义如下 #define NVS_DEFAULT_PART_NAME "nvs" /*!&lt; Default partition name of the NVS 然后默认的 extern "C" esp_err_t nvs_flash_init(void) { return nvs_flash_init_partition(NVS_DEFAULT_PART_NAME); } extern "C" esp_err_t nvs_open(const char* name, nvs_open_mode_t open_mode, nvs_handle_t *out_handle) { return nvs_open_from_partition(NVS_DEFAULT_PART_NAME, name, open_mode, out_handle); } 所以如果需要自定义分区名称，在必要的函数中替换NVS_DEFAULT_PART_NAME即可 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3104bd112d3c1fbb0e17f009a5a2a790/" rel="bookmark">
			Shell学习记录3
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 数组 普通数组：只能使用整数作为数组索引（元素下标）
定义
#数组名[索引下标]=值 array[0]=v1 array[1]=v2 array[2]=v3 #一次赋予多个值 array=(v1 v2 v3 v4) array=(aa bb "cc") array=(1 2 3 4 "abc" [10]=lll) #将结果赋值给数组 array1=(`cat /etc/password`) array2=(`ls /etc`) 读取
#${数组名[元素下标]} echo ${array[0]} echo ${array[*]} #打印数组元素个数 echo ${#array[*]} #打印数组元素下标 echo ${!array[@]} #访问指定的元素；1代表从下标为1的元素开始获取；2代表获取后面几个元素 echo ${array[@]:1:2} #查看普通数组的信息 declare -a 关联数组：可以使用字符串作为数组索引（下标）
首先要声明是关联数组
declare -A array 赋值
#数组名[下标]=变量值 array[a]=one array[b]=two array[c]=three # array=([a]=one [b]=two [c]=three) 读取同上
2. 其他变量 取出一个目录下的目录和文件：dirname，basename
A=url(路径) #取出目录 dirname $A #取出文件 basename $A 变量“内容”的删除
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3104bd112d3c1fbb0e17f009a5a2a790/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/643f7084d9370920a891a337c943672e/" rel="bookmark">
			网易云音乐API调用（持续跟新中）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		**
最近两天在学习一下微信小程序，在学习网络请求的部分了解了一下网易云音乐api的使用，下面给大家分享一下。
**
调用方法：
https://api.imjad.cn/cloudmusic/
在以上的网址后要紧跟两个参数完成具体请求：
1、type （默认值为type=song）
2、id（歌曲的id）
具体可以参考此链接
在调取api进行歌曲搜索的时候search好像不是很好用所以就查阅资料得到下面的改进：
搜索
亲测可用如：
http://music.163.com/api/search/pc/?type=1&amp;s=理想三旬
可以得到歌曲理想三旬的歌曲信息
在如上api中获得的音乐信息中，似乎无法得到音乐的MP3地址，但是可以得到音乐的id，这样就可以根据我的上一篇博客获得MP3的地址了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d428962b9448f5397abf1193fc492e54/" rel="bookmark">
			UiPath快捷键汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ctrl + Shift + N - 创建一个新的空白项目
Ctrl + O - 允许您打开以前创建的工作流程。支持扩展名为 .xaml 或者 project.json 的文件
Ctrl + L - 打开存储日志文件的文件夹
Ctrl + S - 保存当前打开的工作流程
Ctrl + Shift + S - 保存当前打开的所有工作流程
Ctrl + D - 通过将当前活动放入“ 注释输出”容器中来忽略当前所选的活动
Ctrl + E - 从放置它的“ 注释输出”容器中删除活动
Shift + F9 - 删除当前打开的工作流程中的所有断点
F11 - 调试时，您可以进入一个活动块并执行第一个活动
Shift + F11 - 调试时，逐步执行当前所选工作流程中的活动块
Alt + Ctrl + W - 打开Web录制工具栏
Alt + Ctrl + B - 打开基本录制工具栏
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d428962b9448f5397abf1193fc492e54/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b299de7a58111aa733fc52b04bf80cb/" rel="bookmark">
			HTML 实现排行榜
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;排行榜&lt;/title&gt; &lt;style type="text/css"&gt; p { font-size: 12px; margin: 0; padding: 0; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; } .listBig { width: 268px; height: 445px; border: 1px dotted #ccc; } .listBig .options { width: 100%; height: 33px; line-height: 33px; /*border:1px solid red;*/ padding-bottom: 5px; position: relative; } .listBig .options .orders { width: 19px; height: 28px; position: absolute; left: 0; top: 0; } .schoolMain { height: 100%; width: 223px; position: absolute; left: 28px; top: 0; right: 22px; border-bottom: 1px solid #ccc; } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8b299de7a58111aa733fc52b04bf80cb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8395b7fcd29970e00258debace66ac0f/" rel="bookmark">
			变量命名常用缩写
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 参考文章：供参考的变量名缩写
WordAbbreviationabbreviate / abbreviationabrvacademicacadaccept / acceptance / acceptedacptaccessaccsaccidentacdntaccomplish / accomplishment / accomplishmentsacmpaccountingacctgaccounts payable / advanced placementapaccounts receivablearaccountacctaccreditedacrdaccrualacrlaccumulatedaccumaccumulation / accumulativeacumachieve / achievementachvacquisitionacqact / active / activity / american college testactactionactnactualactlad hocadhcadd / addedaddadditionaladdladdressaddradjudicate / adjudicated / adjudicationadjdadjusted gross incomeagiadjustmentadjadministered / administrated / administrationadmadministratoradmadmissible / admissionadmsadmittance / admittedadmtadvanced placement / accounts payableapadviceadvcaffiliationafflafteraftagencyagcyagentagntalienalnallocate / allocationallocalphaalphalter / alternatealtalumni / alumnusalmnamerican college test / act / active / activityactamountamtanalysisanlsannualannlanonymousanonansweransapartmentaptappeal / appealedapelapplicantappapplicationapp / applappointmentapptapproval / approveaprvargumentargarrayaarrearsarrsascendingascassembleasmassign / assigned / assignmentasgnassociationasscassumptionasmpasynchronizationasynathlete / athleticathlattachatchattemptatmptattend / attendanceatndattentionattnattributeattraudit / auditedadtauthority / authorizeauthauxiliaryauxavailability / availableavlaverage cumulative gradeacgaverageavgaward / awardedawrdbackgroundbgbackbkbalancebalbankbnkbargainbargbase / basicbasbatchbtchbeforebefbegin / beginningbegnbeginning of termbotbenefitsbenbill / billingbillbilling and receivables systembrsbirthbrthbitmapbmpboardbrdbool (int)bbreakbrkbudget / budgetablebudbudget balance accountbbabufferbufbuild / buildingbldbusiness unitbubusinessbusbuttonbtnbuy / buyerbuycalculate / calculated / calculationcalccalculatecalccalendarcalcampaigncmpncampuscmpscancel / canceledcancapacitycapcapitalizationcplzcardcrdcareercarcarriercrircartridgecartcasecsecashcshcatalogctlgcategorycatgcensuscenscenterctrcertificate / certificationcertchange / changedchgchangechgchapterchapcharactercharchargecrgchartfieldchartfcharccheck / checkedchkcitizen / citizenshipctzncityctyclassclasclear / clearedclrclickclkclosecloclubclbcobracbrcodecdcollect / collectionclctcollegecolgcolorcr / clrcolumncolcombination / combinecombcommandcmdcommentcmtcommitteecmmtteecompanycocomparativecompacomparecmpcompetitorcptrcomplete / completion / compliancecmplcomponentcmptcomposite / compensationcompconditionalcondconfidentialcnfdconfirm / confirmationconfconstantcnst / cstcontactctctcontinue / continuing / continuouscontcontract / contractorcntrcontrolctl / ctrlconversationconvrconversion / convert / convertedcnvcoordinatescoordcopycpycorrespondencecrspcount / countercntcount of bytescbcount of x (short)cxcountryctrycountycntycoursecrsecoveragecovrgcreatecrecredentialcrdlcreditcr / crdtcross list / cross listedxlstcross referencexrefcrosscrscumulativecumcurrencycurrcurrentcurcursorcrsrcustodiancstncustomercustcylindercyldailydlydata member of a classm_data processingdpdatabasedbdate-time stampdttmdatedtdaydd / dydead / death / deceaseddeaddebitdrdebugdbgdecimaldecdecreasedecdeduct / deductiondeddefaultdef / dfltdeficitdfctdefinitiondefndegreedegdeletedeldeliver / deliverydlvrdemodmodentaldntldepartment of motor vehiclesdmvdepartmentdeptdependency / dependent / dependsdepdepositdpstdepreciationdeprdescriptiondescr / dscdesigndsgndestinationdest / dstdetaildetldevelop / development / deviationdevdevicedevdialogdlgdictionarydictdifference / differentialdiffdifferentdiffdigitdgtdirect / direction / directionaldirdirectorydirdisability / disableddisadisbursed / disbursementdsbdiscountdiscdisplacementdspldisplaydispdispositiondspdistribute / distributiondistdistrictdstrdividedivdivision of continuing educationdcedivisiondivdocumentdocdonordonrdoubledbldowndndrive / driverdrvdriverdrvdropdrpduplicate / duplicationdupdword (unsigned long)dwdynamicdynaeacheaearlyerlyearn / earned / earningsearnearned income crediteiceditedteducate / educationedueffect / effectiveeffeffective date sequenceeffseqeffective dateeffdteffortefrtelect / elected / electiveelctelectronic data interchangeedielectronic funds transfereftelectronic mailemeligibility / eligibleeligemergencyemrgemphasisemphemployee idemplidemployeeee / emplemployereremploymentemplmtencumber / encumbranceencbend / endingendend of termeotendorse / endorsementendrendorsementendrendow / endowmentendwengineer / engineeringengnenglishenglenrichmentenrchenrollmentenrlenter / entered / entryentrentitle / entitlemententlenvironmentenvequal / equality / equivalence / equivalenteqequal employment opportunity / equal opportunityeeoequipeqperrorerrescapeescestablishmentestbethnicethnevaluation / evaluatorevaleventevntexamexmexceptionexcpexclude / exclusionexclexecute / executionexecexecuteexecexempt / exemptionexmtexpect / expectedexpcexpected family contributionefcexpeditexpdtexpense / export / expressexpexperimentalexpmexpiration / expireexprexport / expenseexpextend / extended / extensionextextendex/extexternalextrfacilityfcltfacultyfacfamily eduaction rights and privacy actferpafamilyfmlyfastfstfatherfathfederal labor and security actflsafederalfedfeet / full timeftfield / fieldsfldfinalfnlfinancial aidfafinancialfinfirstfrstfiscal year to datefytdfiscal yearfyfiscalfiscfix / fixedfixflagflgflexible spending accountfsafloorflrforeign keyfkforeignfgnformatfmtformerformrformfrmframefrmfree application for federal student aidfafsafree on boardfobfreeze / frozenfrzfrequencyfreqfresh / freshmanfrshfromfrfulfill / fulfilledfulffull time equivalentftefull timeftfunction / functionalfcnfunctionfunc / fnfund / fundingfundfuturefutgarnishmentgarngeneral education degreegedgeneral ledgerglgeneralgenlgeographic / geographygeoggiftgftglobalg / glblgovernmentgovtgrade point averagegpagradegde / grdgraduategradgrant / grantedgrntgridgrdgrossgrosgroupgrpguaranteed student loangslguaranteeguarguestgsthandicap / handicappedhandhandlehheaderhdrhealthhlthheld / holdhldhelphlphierarchyhierhigh school serviceshsshigh schoolhshigher educationhedhighwayhwayhighhhistoryhsthomehmhonor societyhschonorhonrhorizontalhorzhospitalhosphourlyhrlyhourshrshourhhhouse / housinghseidentification / identifier / indicatoridimageimgimmune / immunizationimunimpactimpcimplementationimplimplementimplimport/exportimpexpimportimpinchinincludeinclincomeincmincrease / incrementincrincreaseincincrementincindexidx / indxindicatorid / indindividual student information reportisirindividualindvinformationinfoinitial / initializeinitinitial/initialize/initializationinitinitialinitinjuryinjinoculationinocinputinptinquiryinqinsertins / isrtinstanceinstinstitutioninstinstruction / instructional / instructoristrinstructional need analysis systeminasinsuranceinsintegeriinter-unitiuinterestintinterfaceintfcinternalintrinternationalintlinterruptint / intrintervalinvlinterview / interviewerintvinventoryinvinventinvninvestmentinvestinvitation / inviteinvtinvoiceinvcissue / issuedissitemitmjournaljrnljunior sciencejsjuniorjrlabellbllablelablaboratorylablaborlbrlanguagelnglast / listlstlatitudelatlayofflayfleavelvlecturelctrledgerledlegallgllenderlndrlengthlenletterltrlevellvlliaisonlisnliberal educationlbdlibraryliblicense plate numberlic_plte_nbrlicenseliclimitlimline / loanlnlink / linkedlnklinklnkliquidliqlist / lastlstlistlstliteralltrlloan / linelnlocate / locationloclockerlkrlocklklog onlogonlogicalloglong / longestlonglong term careltclong term disabilityltdlongitudelonlonglmail / mailer / mailingmailmaintenancemaintmajormjrmakemkmanage / managermgr / manmanagermgr / mngrmaritalmrtlmaskmskmaster academic records systemmarsmatch / matchingmtchmathmthmatriculated / matriculationmtrcmaximummaxmedical / medicinalmedmeet / meetingmtmembershipmshpmembermbrmemo / memorandummmomemorialmemrmemorymemmerchandisemerchndsmerchantmerchmeritmertmessage / messagesmsgmessage agent servermasmessagemsgmetermtrmethodmethmicrofilmmfilmmiddlemidmilitarymilminimumminminorminrminutemnt / mmmiscellaneousmiscmodemdemodification / modifiermodmonetary / moneymonymonth-to-datemtdmonthmm / mnmothermothmultiplemultmultiplymulnamenm / nmenational association of college and university business officersnacubonational student loan direct systemnsldsnationalnatlnavigationnavnext of kinnoknextnxtno chargencno creditnocrno printnprtnominalnomnon-personal servicesnpsnot applicablenanote / notice / notification / notifynotenumber / numericnbrnumbernumobject / objectiveobjobjectobjoccupationocpoccursoccoffer / offeredoffrofficerofcrofficeoffcofficialofcloffsetofsonlineonlnopenopnoperatoroproption / optional / optionsoptoracleoraorderordrorganization / organizeorgorientationorntorigin / original / originationorigorigin / originalorgotherothroverheadohoverrideovrdovertimeotoverovrown / ownedownownerownrpackagedpackpackagepkgpanoramapanopaperpprparameterparam / parmparentparparity / priorityprtyparkprkpart / partialprtpart timeptparticipationprtppass / passedpasspasswordpwd / pswpatronptrnpay / payable / paymentpaypayrollpyrlpedestrianpedpell (pell grant)pelpendingpendpensionpenspercent / percentage / percentilepctperiod-to-dateptdperiodpdperkins loannsldspermanentpermpermitprmtpersonal / personnelpsnlpersonal identificationpinpersonnel action notificationpanpersonpersphonephnphysicsphyspicturepicplaceplceplanplnplatepltepledgepldgpointerp / ptrpointpnt / ptpolicyplcypositionpospost / postedpostpostalpstlpotentialpotnpredictedpredpreference / preferredprefprefixprfxpremiumpremprerequisitepreqprescribedpscrpresentationprstpresidentpresprevious / priorprevpreviouspre / prevprice levelplpriceprcprimary keypkprimaryprimprincipal / principleprinprincipal investigatorpiprint / printedprnprintprnprior / previousprevpriority / parityprtyprobation / problemprobprocedure / processprocprocess / procedureprocprofession / professionalprfsproficiencyprfcprofileprofprogramprg / progproject / projectedprojpromissoryprmspromotionprompropertiespropproposalprpsprospectprspprovinceprvnpublicpubpurchase orderpopurchasepurpurgeprgpurposepurpqualitative / qualityqalquantitative / quantityqtyquantity-to-date / quarter-to-dateqtdquarterqtrquestionqstnrangerngrankrnkratertread / readingreadreal / reallocationrealreasonrsnrecallrclreceiptrcptreceive / receivedrecvreceiverrcvrrechargerchgrecognition / recognizerecgrecommendrcmdreconciliationreconrecordrecrecreate / recreationrecrrecruit / recruitingrcrtrectrcreduce / reduced / reductionredrefer / reference / referral / referredrefreferencerefrefundrfndregionalrgnlregionrgnregisterregregistrarregrregistrationregreject / rejectionrjctrelate / relation / relationshiprlatreleaserlsereligion / religiousrelgremainingrmngreminderrmdrrenewalrnwlrepeat / repeatable / repeatedreptreplace / replacedreplreplyrplyreportrptrequest / requested / require / required / requisitionreqrequestreqrequirementsrqmtresearchresreserve / reservedrsrvreserve officers training corpsrotcresidence / residency / residentrsdtresignrsgnresourceres / rsrcresponseresprestartrstrestockrstkrestrict / restricted / restrictionsrstrresultrsltretire / retirementretretroactiveretrreturnret / rtnrevenuerevreviewrvwrevisionrevsrevokerevkroll uprluprollrlroomrmrouteroutrun controlrunctlsalarysalsalutationsltnsamesmscalescalschedule / scheduled / schedulingschedscholar / scholarshipschlrscholastic / schoolschlscholastic aptitude testsatsciencesciscorescrscreenscrsearchsrchsecondscnd / ss / secsectionsctnsecure / securitysecsegmentsegselect / selection / selectiveselselectselsemestersemsemi finalistsemfsenate / senatorsensendsndseniorsrsentsntseparateseprsequenceseqserialserlserversvr / srvserviceservsessionsessnsharingshrsheetshetsheltershltshiftshftshippingshipshort intnshortshrtsignsgnsimulatedsimsizeszskillsklskipskpsocial / societysocsocial security numberssnsoftsftsolidslidsophomoresophsortsrtsourcesrcspecial / specialtyspclspecific / specificationspecsponsor / sponsoredsponsportssprtspousespsesquaresqstackstckstaffstfstagestgstampstmpstandard deviationstdvstandardstdstart / startingstrtstatementstmtstateststaticstcstatisticsstatstatisticstatstatusstsstepstpstipendstpdstockstkstoragestgstreamstmstreetstrstringstr / sstructurestrcstudent academic recordssarstudent credit hourschstudentstustudystdysubcampaignscmpsubjectsubjsubordinatesubsubsidiarysubssubtractsubsuffixsfxsummation / summarysumsummationsumsupervisor / supportsupsupplement / supplementalsuplsurveysrvysuspensesusp / suspnswitchflg / swsybasesybsynchronizationsyncsystemsystable / tablestbltabletbltakentkntargettrgttaughttghttax / taxabletxtax id numbertintemplatetmpltemporarytmp / temptenuretenrterminaltrmlterminatetrmttermtrmtesttsttext metrictmtexttxtthermidorthermtickettkttime keepingtmkptime-stamptstimetmtitletitltodaytdytotaltottownctytrack / trackingtrktraditionaltradtrainingtrntransact / transactiontranstranscripttscptransferxfertranslate / translationxlttranslate/transation/transparenttran / transtransmit / transmittalxmittraveltrvltuitiontuittypetypundergraduateugrdunemploymentunemplunit of measureuomuniversalunvrsluniversityunivunknownunkunpaidunpdunsecure / unsecuredunsecunsigned char (byte)byunsigned intuunsigned long (ulong)ulup tomaxupdate / updatedupdtupdateupdupgradeupgupperuprus department of educationusdeuse / useduseuserusrutilityutilvacationvacnvaledictorianvldcvalid / validate / validationvldvaluevalvariablevarvehiclevehvendorvendverbalvrblverify / verifiedverfversionververticalvertveteranvetvice presidentvpviolationviovirusvirvisitvstvoidvvouchervchrwaivedwvedweek / work / worked / worker(s)wkwidthwidwindowwin / wndwithdrawalwdrlwithhold / withholdingwhldwithwwomenwmnword (unsigned short)wworksheetwkstwrite / writtenwrtx, y coordinates (short)x,yyear-to-dateytdyearyr / yyzero terminated stringsz statistics 缩写为statistargument 可缩写为 arg buffer 可缩写为 buff clock 可缩写为 clk command 可缩写为 cmd compare 可缩写为 cmp configuration 可缩写为 cfg device 可缩写为 dev error 可缩写为 err hexadecimal 可缩写为 hex increment 可缩写为 inc initialize 可缩写为 init maximum 可缩写为 max message 可缩写为 msg minimum 可缩写为 min parameter 可缩写为 para previous 可缩写为 prev register 可缩写为 reg semaphore 可缩写为 sem statistic 可缩写为 stat synchronize 可缩写为 sync temp 可缩写为 tmp 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/105abcccef1f168ae2fb770c1b529049/" rel="bookmark">
			vivo手机安装apk后无法打开，其他设备都可以正常打开
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://blog.csdn.net/yanghuiyu38/article/details/80353624
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/504430243d67299d8e6f1d74a652be9f/" rel="bookmark">
			45个小众而实用的NLP开源字典和工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言
随着BERT、ERNIE、XLNet等预训练模型的流行，解决NLP问题时不用上预训练模型似乎总显得自己有点过时。但是这显然是不对的。
众所周知，无论训练还是推理，预训练模型都会消耗大量的算力，且高度依赖GPU计算资源。然而，有很多的NLP问题实际上仅仅靠字典+规则就可以做到够用，那么这时候强行上笨重的模型无异于高射炮打蚊子，性价比是非常低的。
于是我们就从一个比较疯狂的github repo里为大家精挑细选了45个比较实用的开源小工具和字典，让大家在搭建NLP系统、辅助炼丹的过程中少一些模型和算力的依赖，多一些小而美的代码。
repo地址：
https://github.com/fighting41love/funNLP
注：这是一个非常丧心病狂的repo，里面收录了300多个项目，但是比较鱼龙混杂，要记得多多横向对比哦
来，感受一下m(_ _)m
鬼知道我是怎么把这300个repo看完一遍的
(╯°□°）╯︵ ┻━┻
1. textfilter: 中英文敏感词过滤
repo: observerss/textfilter
&gt;&gt;&gt; f = DFAFilter() &gt;&gt;&gt; f.add("sexy") &gt;&gt;&gt; f.filter("hello sexy baby") hello **** baby 敏感词包括政治、脏话等话题词汇。其原理主要是基于词典的查找（项目中的keyword文件），内容很不清真
2. langid：97种语言检测
repo: saffsd/langid.py
pip install langid
&gt;&gt;&gt; import langid&gt;&gt;&gt; langid.classify("This is a test") ('en', -54.41310358047485) 3. langdetect：另一个语言检测
地址：https://code.google.com/archive/p/language-detection
pip install langdetect
from langdetect import detectfrom langdetect import detect_langs s1 = "本篇博客主要介绍两款语言探测工具，用于区分文本到底是什么语言，"s2 = 'We are pleased to introduce today a new technology'print(detect(s1)) print(detect(s2)) print(detect_langs(s3)) # detect_langs()输出探测出的所有语言类型及其所占的比例 输出结果如下：注：语言类型主要参考的是ISO 639-1语言编码标准，详见ISO 639-1百度百科
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/504430243d67299d8e6f1d74a652be9f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4503bdcf33dde19e02421cb44a2d050a/" rel="bookmark">
			《动手学深度学习》Day4:过拟合、欠拟合及其解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、模型选择、过拟合和欠拟合1.1 训练误差和泛化误差1.2 模型选择1.3 过拟合和欠拟合 二、多项式函数拟合实验2.1初始化模型参数2.2 定义、训练和测试模型2.3 三阶多项式函数拟合（正常）2.4 线性函数拟合（欠拟合）2.5 训练样本不足（过拟合） 三、权重衰减3.1 方法3.2 L2 范数正则化（regularization）3.3 高维线性回归实验从零开始的实现3.4 初始化模型参数3.5 定义L2范数惩罚项3.6 定义训练和测试3.7 观察过拟合3.8 使用权重衰减3.9 简介实现 四、弃权法4.1 弃权法从零开始的实现4.2 简洁实现 一、模型选择、过拟合和欠拟合 1.1 训练误差和泛化误差 在解释上述现象之前，我们需要区分训练误差（training error）和泛化误差（generalization error）。通俗来讲，训练误差指模型在训练数据集上表现出的误差，泛化误差指模型在任意一个测试数据样本上表现出的误差的期望，并常常通过测试数据集上的误差来近似。计算训练误差和泛化误差可以使用之前介绍过的损失函数，例如线性回归用到的平方损失函数和softmax回归用到的交叉熵损失函数。
机器学习模型应关注降低泛化误差。
1.2 模型选择 1、验证数据集
从严格意义上讲，测试集只能在所有超参数和模型参数选定后使用一次。不可以使用测试数据选择模型，如调参。由于无法从训练误差估计泛化误差，因此也不应只依赖训练数据选择模型。鉴于此，我们可以预留一部分在训练数据集和测试数据集以外的数据来进行模型选择。这部分数据被称为验证数据集，简称验证集（validation set）。例如，我们可以从给定的训练集中随机选取一小部分作为验证集，而将剩余部分作为真正的训练集。
2、K折交叉验证
由于验证数据集不参与模型训练，当训练数据不够用时，预留大量的验证数据显得太奢侈。一种改善的方法是K折交叉验证（K-fold cross-validation）。在K折交叉验证中，我们把原始训练数据集分割成K个不重合的子数据集，然后我们做K次模型训练和验证。每一次，我们使用一个子数据集验证模型，并使用其他K-1个子数据集来训练模型。在这K次训练和验证中，每次用来验证模型的子数据集都不同。最后，我们对这K次训练误差和验证误差分别求平均。
1.3 过拟合和欠拟合 接下来，我们将探究模型训练中经常出现的两类典型问题：
一类是模型无法得到较低的训练误差，我们将这一现象称作欠拟合（underfitting）；另一类是模型的训练误差远小于它在测试数据集上的误差，我们称该现象为过拟合（overfitting）。 在实践中，我们要尽可能同时应对欠拟合和过拟合。虽然有很多因素可能导致这两种拟合问题，在这里我们重点讨论两个因素：模型复杂度和训练数据集大小。 1、模型复杂度
为了解释模型复杂度，我们以多项式函数拟合为例。给定一个由标量数据特征 x x x和对应的标量标签 y y y组成的训练数据集，多项式函数拟合的目标是找一个 K K K阶多项式函数
来近似 y y y 。在上式中， w k w_k wk​是模型的权重参数， b b b是偏差参数。与线性回归相同，多项式函数拟合也使用平方损失函数。特别地，一阶多项式函数拟合又叫线性函数拟合。
给定训练数据集，模型复杂度和误差之间的关系：
2、训练数据集大小
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4503bdcf33dde19e02421cb44a2d050a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dad4d2faeb669b06016082011552ee7f/" rel="bookmark">
			arp欺骗攻击与防范技术总结和分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言arp简介arp工作原理arp欺骗原理arp欺骗常见攻击手段遭受arp欺骗攻击现象arp欺骗攻击相关检测方法手动检测方法主机级检测方法网络级探测方法缓存超时检测方法 arp欺骗防御措施分析1. 设置静态的arp缓存2. 使用arp服务器3. 划分虚拟局域网（vlan）和端口绑定4. 删除windows系统中的npptools.dll动态连接库。5. 采用arp防火墙6. 对数据包进行加密处理7. 中间件技术 总结 ~~~~~~~~ 因为想要面对一个新的开始，一个人必须有梦想、有希望、有对未来的憧憬。如果没有这些，就不叫新的开始，而叫逃亡。 ​​​​
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ————玛丽亚·杜埃尼亚斯
前言 随着人类社会的进步和发展，人们对网络的需求将会越来越大，然而在这样一个条件下，internet与网络服务，网络应用等其他组件就面临着安全性的挑战。根据tcp/ip协议原理可以知晓，tcp/ip网络内的每台主机都必须具有一个合法的ip地址才能进行相互通信，而在互联网高速发展的现在，ip地址日益匮乏，大多数企事业单位采用nat等技术来组建自己的局域网这种方式解决这一问题，在一定程度上增强了网路内部的交互安全。然而实现简单、运行高效的tcp/ip协议，它所提供的信息和资源共享是建立在网络内部各节点之间相互信任基础之上的，这使得tcp/ip协议的完全开放性具有诸多的安全隐患。
arp简介 ARP（Address Resolution Protocol）即地址解析协议，是根据IP地址获取物理地址的一个TCP/IP协议。arp协议是tcp/ip协议集的数据链路层协议，主要用于在局域网环境下，ip地址到网络设备的物理地址（mac）的转换。作为tcp/ip协议栈中的一个重要成员，其设计同样是建立在局域网内各计算机相互信任的基础之上的。由于种种原因，arp协议在设计之初，仅处于对传输效率的考虑，而缺乏必要的身份认证和鉴别机制，导致其具有相当脆弱的安全性能。arp攻击时一种典型的欺骗类型，其实质就是利用了arp协议本身的安全缺陷和漏洞来进行攻击的。
arp工作原理 arp是非常常用的tcp/ip底层协议，用来实现ip地址和mac地址之间的映射。以太网中的arp报文格式如图所示：
在一个TCP/IP 网络中, 从一台主机 A 发送数据给另一台主机 B时, 必须把信息分割、封装成包, 并附上目的主机 B 的 IP 地址与 MAC 地址。然而, 当这两台主机第一次通信时, 源主机 A 不一定知道目的主机 B 的 MAC 地址, 根据 ARP 协议,A 就要发送一个 ARP 请求, 以寻找 IP 地址到实际 MAC 地址的映射。而 B 在收到这个包含其 IP 地址的请求后, 就会返回A一 个 ARP 响应, 告知 A 其 MAC 地址。最后, 协议栈将 IP 包封装到以太网帧中进行传送。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dad4d2faeb669b06016082011552ee7f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f8c8e1603747122d89df94ab5f3f8bd/" rel="bookmark">
			网络编程笔记（根据遇到的问题随时更新）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		函数详解 https://blog.csdn.net/seraphsky/article/details/1856191
https://www.jianshu.com/p/066d99da7cbd
可能需要的头文件 #include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;errno.h&gt;
#include &lt;strings.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;netinet/ip.h&gt;
宏定义 #define SERV_PORT 5001 必须&gt;=5000
#define SERV_IP_ADDR “192.168.7.246”
#define BACKLOG 5
#define QUIT_STR “quit”
tcp框体之client int main(int argv,const char * argv[])
{
int fd = -1; struct sockaddr_in sin; /* 优化：判断是否传入文件名、IP、端口号 if(argv != 3) { usage(argv[0]); exit(0); } usage(char *s){ printf("\n%s serv_ip serv_port\n",s); printf("\tserv_ip:server ip address"); printf("\tserv_port"server port(&gt;5000)"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4f8c8e1603747122d89df94ab5f3f8bd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d041c6b602e57277282ba697c4e8d545/" rel="bookmark">
			Unity - 动态生成迷宫(Roguelike游戏可用)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 生成迷宫的算法思路按照迷宫的尺寸参数：宽高，生成网格随机生成并添加房间生成隧道收集所有可连接墙块确定选择可连接墙块中哪些块是作为连接的块遍历将这些连接格挖掘为地板块总览步骤图 ReferencesProject backup 先来看看效果： 该迷宫只有,x,y二个维度的迷宫。 如果想要x,y,z三个维度迷宫的方式，请另外搜索。 该迷宫的生成算法参考了国外的一篇文章：Rooms and Mazes: A Procedural Dungeon Generator
不过我是算法实现上稍微和原作不太一样
然后我随便写了个测试脚本将各个参数暴露方便测试，如下图：
生成迷宫的算法思路 按照迷宫的尺寸参数：宽高，生成网格（宽和高都必须为奇数）随机生成并添加房间（房间之间没有交集，且房间的x,y坐标，和房间的w,h宽高也都必须是奇数）生成隧道（隧道的曲折程度有百分比参数可以设置，每次挖掘隧道是都是两格两格的挖掘，这个就可以保证隧道拐角在奇数格也保证了隧道之间，或隧道与房间之间会有一个格子的距离，因为后面一步的可连接块中需要用到）收集所有可连接墙块（房间之间的墙块，或是隧道与房间之间墙块）确定选择可连接墙块中哪些块是作为连接的块（但至少要有一个连接格，否则该房间没有存在的意义）遍历将这些连接格挖掘为地板块删除一些死胡同的隧道块（这个按需决定，有些玩法是需要保留死胡同的） 下面的图片都是按以上步骤处理的截图：
按照迷宫的尺寸参数：宽高，生成网格 随机生成并添加房间 生成隧道 收集所有可连接墙块 黄色块都是可作为连接格的块
确定选择可连接墙块中哪些块是作为连接的块 遍历将这些连接格挖掘为地板块 总览步骤图 生产了迷宫后，我们在根据迷宫数据生产可视化对象，每个对应类型的格子，都会使用对应一个Prefab生产。
最终效果，如下图：
在生成了迷宫网格对象基础上，再使用Unity官方GitHub上开源的NavmeshSurface来动态生成Nevmesh，如下图：
最后在加上之前制作的虚拟摇杆，参考这篇文章：Unity - UGUI快速制作虚拟摇杆 - 移动方向摇杆
把角色添加到迷宫做，用虚拟摇杆来控制移动。
如下图：
这样就生成了两个维度的(x,y)的迷宫，我们可以使用该功能制作Roguelike的地牢游戏，后面测试项目再添加一个怪物，宝箱，等，就差不多了。
References Rooms and Mazes: A Procedural Dungeon Generator Project backup MazeGenerator_2018_3_0f2 备份的项目，打开GamePlay.scene场景即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/710fc1ecad76679044e984a83dede965/" rel="bookmark">
			数据结构与算法-字符串（Python）（五）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述： 字符串（string）简称串，也是一种线性结构。在python中和array差不多，因为py的数组也可以包括各种字符（在C/Java一类的语法中，数组必须是同一种数据类型的元素）。线性结构，有限序列，是主要特点。串其中可以包含各种元素，也是计算机主要处理的一类对象。因此，串的题目涉及的范围很广，可以结合其他算法出题，往往比较有难度。通常，动态规划，双指针，回溯和栈是很重要的工具。
串的存储结构： 其存储结构同线性表一样，也分为顺序存储，即各个字符依次存放在连续的存储单元，以及链式存储，同链表一样，特点是，一个结点可以存储多个字符（一个字符占8位），称为结点的大小，结点大小越大存储密度越大，越小运算处理（插入/删除等）越方便。
串的基本的实现操作包括：赋值，复制，判断相等，串长，串连接，求子串，插入，删除，替换，输出。
串的基本算法： 循环左移 问题描述：给定一个字符串S[0…N-1],要求把S的前k个字符移到S的尾部，如把S的字符串“abcded"前面的前两个字符“a”,“b”移到字符串的尾部，得到新字符串“cdefab”，即字符串循环左移k位。算法要求：时间复杂度为O（n）,空间复杂度为O(1)。
暴力移位法，简单粗暴，我们当然不考虑了，时间复杂度为O(KN),空间复杂度为O(1);
三次拷贝法，新建一个数组，分三次拷贝，时间复杂度为O(N),空间复杂度为O(K)；
三次翻转法，类似于矩阵转置，设X=‘ab’, Y='cdef '，X ’ = ‘ba’, Y ’ = ’ fedc ’ , ( X ’ Y ’ ) ’ = ’ cdefab ’ ，时间复杂度为O(n),空间复杂度为O(1)。
def leftshift(string:str, m:int)-&gt; str: n = len(string) m %= n left = string[:m] right = string[m+1:] left = left[::-1] right = right[::-1] result = left + right result = result[::-1] return result 字符串查找（模式匹配） 暴力匹配法跳过，我们讨论著名的KMP算法（Knuth-Morris-Pratt算法）。KMP算法的关键是利用匹配失败后的信息，尽量减少模式串与主串的匹配次数以达到快速匹配的目的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/710fc1ecad76679044e984a83dede965/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/524d8c460c6fe12a8d1bbf332c131e3a/" rel="bookmark">
			10.Linux学习--网络配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		10.1 什么是IP 10.1.1 IP简介
Internet Protocol Address，网络协议地址，也就是在因特网上给主机编码的方式
协议名称：tcp/ip 协议版本：ipv4ip地址：2^32， 即ip是由32位0或1组成，例，111111111.111111111.11111111.11111111（二进制）==255.255.255.255 （十进制） 10.1.2 子网掩码 子网掩码是用来划分网络区域的，指明了一个ip地址的哪些位标识的是网段，哪些是主机 子网掩码非0的位对应的ip上的数字表示这个ip的网络位，0位对应IP的数字是的主机位网络位表示网络区域（即位置区域）主机位表示网络区域里某台主机（即区域内具体某台主机） 10.1.3 IP通信
网络位相同，主机位不同的两个ip可以直接通信，例如：
IP1：192.168.43.10/24等价于192.168.43.10/255.255.255.0
IP2：192.168.43.11/24
IP1和IP2掩码都是24位，它们的网段都为192.168.43，所以可以直接通信
实验1：IP相关命令
ip addr show | ifconfig ##查看ip地址 ping ##检测网络通畅 -c 1 ##只ping1次-w 1 ##等待1秒 ifconfig device ip netmask ##为网卡配置IP以及子网掩码ip addr show ##查看ipip addr del dev ens160 192.168.43.11/24 ##删除ip ip addr add 192.168.43.11/24 dev ens160 ##添加ip 实验2：永久方式更改IP
1. 图形方式
nm-connection-editornmtui nm-connection-editor nmtui 2. 命令方式
nmcli device status ##查看设备状态 nmcli device disconnect ens160 ##关闭设备 nmcli device connect ens160 ##开启设备 nmcli connection show ##查看连接信息 nmcli connection down "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/524d8c460c6fe12a8d1bbf332c131e3a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7255409942d69d30c5cdda76938acd8b/" rel="bookmark">
			消息队列与分布式事务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		分布式事务的最终解决方案：消息队列
消息服务中的重要概念：消息代理和目的地
当消息发送者发送消息以后，将由消息代理接管，消息代理保证消息传递到指定目的地
消息队列的两种形式的目的地：a：队列（点对点通信） b：主题（发布/订阅消息通信）
消息队列的好处：
1）异步处理
2）应用解耦
3）流量削峰
发布订阅式： 发送者发送消息到主题，多个接收者（订阅者）监听（订阅）这个主题，那么就会在消息到达时同时接收到消息
JMS: 不能跨语言，不能跨平台
AMQP：高级消息队列协议，兼容JMS 网络线级协议 跨平台跨语言 RabbitMQ的核心概念
接下来进行rabbitMQ的安装，依然是docker（不得不说docker爽爆了哇）
1、下载镜像文件 docker pull rabbitmq:management
2、创建实例并启动 docker run -d --name rabbitmq --publish 5671:5671 \
--publish 5672:5672 --publish 4369:4369 --publish 25672:25672 --publish 15671:15671 --publish 15672:15672 \
rabbitmq:management
注：
4369 -- erlang发现口
5672 --client端通信口
15672 -- 管理界面ui端口
25672 -- server间内部通信口
3、测试 在web浏览器中输入地址：http://虚拟机ip:15672/
输入默认账号: guest 密码: guest
安装好界面就是这个样子的
接下来写个rabbitMQ的demo尝试用一下
首先是引入依赖：
然后编写配置文件
最后开启该功能
测试一下消息队列是否成功
注意，只要是想通过网络通信，那么对象都要实现序列化，converAndSend的第一个参数是交换机的名字，第二个参数是路由键，第三个是你要发送的信息
去消息队列中看到了
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7255409942d69d30c5cdda76938acd8b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3aa72bd2ecc1bcefd3142176c8de93f/" rel="bookmark">
			搭建CxxTest单元测试框架
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CxxTest简介 CxxTest软件框架提供了一套代码框架和代码生成工具。
测试人员需要使用C++头文件定义测试用例。在测试用例中，通过定义测试方法，来打包需要的测试项目。测试方法中可以调用开发人员编写的函数，类，变量，声明等，来实现对这些函数，类，变量，声明进行测试和验证。
测试函数中需要使用CxxTest提供的断言宏，来测试比较结果。这些结果如果非预期，会被作为失败或者异常，被CxxTest记录下来。从而实现单元测试自动化。
cxxtestgen工具
运行测试程序
集成到makefile框架 一般大型项目，往往都用户多个可执行程序，多个库文件，以提供丰富稳定可维护的应用功能。C++代码一般使用Makefile来管理。通过定义通用的Makefile宏和变量，将
以下就是基于现有项目makefile框架增加和设计的cxxtest引入方式。
增加测试用例目录及文件列表 在每个模块目录下增加test目录，用于存放测试用例文件。
建议测试用例头文件使用扩展名.hxx。自动生成的文件扩展名为.cxx。开发人员使用的头文件.hpp，源文件.cpp。
这样规范的好处是使用git等版本管理时，可以区分出文件类型。同时设置ignore文件。
在Makefile文件中定义TESTS变量，包含测试用例文件名，定义TEST_SRCS变量，包含依赖的源文件名（不含扩展名）。
事实上我一般是定义SRCS包含源文件名。这样只需要
TEST_SRCS = $SRCS就可以避免重复定义列表了。
为什么不直接用SRCS呢，因为TEST_SRCS中不能含main函数的实现。
采用part模式 最后生产可执行 自动执行 可执行程序以test_开头，后面跟模块名，可以是库名，可以是可执行程序名。
可执行程序使用-v开关，可以显示测试用例中的跟踪调试日志信息。
测试用例编写的考量 #ifndef TEST_LIGHT_TRIGGER_HXX_ #define TEST_LIGHT_TRIGGER_HXX_ #include "light_trigger.hpp" #include &lt;dm/datetime.hpp&gt; #include &lt;cxxtest/TestSuite.h&gt; class TestLightTrigger:public CxxTest::TestSuite{ public: void testNextTime(){ dm::CDateTime dt; dt.setYear(2020); dt.setMonth(2); dt.setDay(3); dt.setHour(12); dt.setMinute(24); dt.setSec(36); dm::CTimeStamp now = dt.toTimeStamp(); dm::CTimeStamp next; znjt::CLightTrigger tg; TS_TRACE("\u9ed8\u8ba4\u503c"); TSM_ASSERT_EQUALS("\u7c7b\u578b",tg.getType(),tg.TNone); TSM_ASSERT_EQUALS("\u65f6\u95f4",tg.getSecs(),0); TSM_ASSERT("\u662f\u5426\u56fa\u5b9a\u65f6\u523b",!tg.isFixed()); TSM_ASSERT_EQUALS("\u4e0b\u6b21\u65f6\u523b",tg.nextTime(now),now); TS_TRACE("\u79d2\u6a21\u5f0f"); tg.setType(tg.TSecs); tg.setSecs(1); next = now; next.addSec(1); TSM_ASSERT("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b3aa72bd2ecc1bcefd3142176c8de93f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/267ea10c28acdc6cb3934c080f246004/" rel="bookmark">
			用友U8&#43;软件所有防火墙端口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		服务 ID
服务名称
服务说明
应用领域
默认端口
U8DispatchService
远程代理服务
远程代理服务，UAP 和登录使用。如果 无法启动则不能登录，代替 IIS 使用。 如果只使用财务和供应链则您关闭 IIS 服务也不会对 U8+有影响。
U8+ V12.5 整个产品范围
TCP:11520
U8+V15.0及以上产品TCP:11525 UFNet
加密服务
为U8+V12.5 提供站点控制服务，是 U8+非常重要的基础服务，可以单独部 署；如果没有正常启动则 U8+不能使用
U8+ V12.5 整个产品范围
TCP:4630
U8WebPool
Web远程代理服务
为 Web 程序提供远程代理，为 Silverlight 程序服务控制管理。
U8+ V12.5 整个产品范围
TCP：4522
UFReportService
报表服务
运行于应用服务器上，是报表应用的服 务端，为客户端提供报表的数据计算和 操作服务；如果没有正常启动，则产品 中的报表不能使用。
报表
TCP：9023
UFSLReportService
WEB报表服务
WEB 报表服务
B/S 报表
4527
UTUService
UU服务
UU服务
通讯端口：
TCP：11521
UDP：11522
可通过UU控制台更改
多媒体服务端口：
TCP：11523
UDP：11524
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/267ea10c28acdc6cb3934c080f246004/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1ac0d4eaeb41ed59592b528f95b68f8/" rel="bookmark">
			C# NAudio  录音、播放录音
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、录音
源代码地址GIT：https://github.com/markheath/voicerecorder
public class Recorder { private int deviceNumber = 0; // 选择的录音设备下标。多个设备时可设置为用户选择 private WaveIn waveIn; // waveIn操作类 private WaveFormat = recordingFormat; // 录音格式 private WaveFileWriter writer; // 录音文件操作类 public event EventHandler StoppedEvent = delegate { }; // 录音结束事件 public event EventHandler DataAvailableEvent = delegate { }; // 录音过程中接收到数据事件 public double RecordedTime // 获取到录音的时长 { get { if (writer == null) return 0; return (double)writer.Length / writer.WaveFormat.AverageBytesPerSecond; } } /// &lt;summary&gt; /// 开始录音 /// &lt;/summary&gt; /// &lt;param name="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d1ac0d4eaeb41ed59592b528f95b68f8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30f99ac9ce58be586a94cc9f5a3cad60/" rel="bookmark">
			利用python爬取新冠肺炎疫情实时数据&#43;可视化展示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		阅读目录 一、对全国总数据绘制饼图二、对全国各地数据进行地图的绘制三、对全国的确诊人数做词云图四、对广东的确诊人数做词云图五、对湖北的确诊人数做词云图 代码在Jupyter Notebook里运行 数据更新于2月28日 一、对全国总数据绘制饼图 1、获取数据
import time import json import requests from datetime import datetime import pandas as pd import numpy as np def catch_data(): url = 'https://view.inews.qq.com/g2/getOnsInfo?name=disease_h5' reponse = requests.get(url=url).json() #返回数据字典 data = json.loads(reponse['data']) return data data = catch_data() data.keys() lastUpdateTime = data['lastUpdateTime'] chinaTotal = data['chinaTotal'] chinaAdd = data['chinaAdd'] print(chinaTotal) print(chinaAdd) 返回结果：
2、对总数据进行饼图的绘制：
from pyecharts.charts import Pie import pyecharts.options as opts ( Pie(init_opts=opts.InitOpts(width='720px',height='320px'))#默认900，600 .add(series_name='', data_pair=[list(z) for z in zip(chinaTotal.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/30f99ac9ce58be586a94cc9f5a3cad60/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5bf1bace738ecd601e287f4c34fb3268/" rel="bookmark">
			《动手学深度学习》Day3:多层感知机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、多层感知机的基本知识1.1 隐藏层1.2 表达公式1.3 激活函数1.4 多层感知机 二、多层感知机从零开始的实现2.1 获取训练集2.2 定义模型参数2.3 定义激活函数2.4 定义网络2.5 定义损失函数2.6 训练 三、多层感知机pytorch实现3.1 初始化模型和各个参数3.2 训练 一、多层感知机的基本知识 深度学习主要关注多层模型。在这里，我们将以多层感知机（multilayer perceptron，MLP）为例，介绍多层神经网络的概念。
1.1 隐藏层 下图展示了一个多层感知机的神经网络图，它含有一个隐藏层，该层中有5个隐藏单元。
1.2 表达公式 具体来说，给定一个小批量样本 X ∈ R n × d \textbf{X}\in R^{n\times d} X∈Rn×d其批量大小为n，输入个数为d。假设多层感知机只有一个隐藏层，其中隐藏单元个数为h。记隐藏层的输出（也称为隐藏层变量或隐藏变量）为 H \textbf{H} H,有 H ∈ R n × h \textbf{H}\in R^{n\times h} H∈Rn×h。因为隐藏层和输出层均是全连接层，可以设隐藏层的权重参数和偏差参数分别为 W h ∈ R d × h \textbf{W}_{h}\in R^{d\times h} Wh​∈Rd×h和 b h ∈ R 1 × h \textbf{b}_{h}\in R^{1\times h} bh​∈R1×h,输出层的权重和偏差参数分别为 W o ∈ R h × q \textbf{W}_{o}\in R^{h\times q} Wo​∈Rh×q和 b o ∈ R 1 × q \textbf{b}_{o}\in R^{1\times q} bo​∈R1×q.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5bf1bace738ecd601e287f4c34fb3268/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f0a7deb9357d8d6e29f538f1dd06431/" rel="bookmark">
			如何获取网易云音频地址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、获取所要音乐的id值 2、获取资源地址 将xxx替换成音乐的id值
http://music.163.com/song/media/outer/url?id=xxx.mp3
http://music.163.com/song/media/outer/url?id=1383923128.mp3
可以在线播放，也可以在前端中引入
参考博客： https://blog.csdn.net/wenyichuan/article/details/90611515
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66a261f7801f9a683b88c1e4565cdae1/" rel="bookmark">
			Flutter插件开发集成aar包出现：Could not determine the dependencies of task &#39;:flutter_vpn:compileDebugAidl&#39;.问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述：
最近在做一个Flutter的插件开发，需要在android及ios原生中集成sdk，然后Flutter通过插件调用sdk的方法。这其中涉及到aar包的集成，虽然是Flutter的插件开发，但是关于android原生的aar包集成还是差不多的，按照正常的aar包集成流程操作，本以为很顺利，但是却出现了这个问题：
这个问题非常奇怪：aar资源包引用是成功的，也能识别到对应的资源文件。但是就在gradle编译的时候一直出现这个问题。
问题分析：
开始的时候，怀疑是目录不对、引用不正确等等，但是后面发现，添加依赖之后，本地的资源库是可以看到文件的，所以这个原因也就不存在。
后面，通过各种帖子了解到：
@aar 本身就是一种library Module，直接作用在 apply plugin:'com.android.application'中 在Flutter插件开发的android目录下的gradle.build文件中，插件表示的是：apply plugin: ‘com.android.library’,所以找不到
因此，就能得到解决方法
解决方案：
1、 在Project 下的 build.gradle 中的 repositories 中添加相应的引用如下：
allprojects { repositories { jcenter() maven { url "https://jitpack.io" } /**子模块含有aar:添加全局引用*/ flatDir { // 由于Flutter插件 module中引用了 aar， // 其他工程编译时会报错，所以需要在所有工程的repositories // 下把Library module中的libs目录添加到依赖关系中 dirs project(':xxx').file('libs') //注意：project后面是aar包的模块名 } } } 2、在app 的build.gradle文件中加入如下一段：
/**子模块含有aar*/ repositories { flatDir { dirs 'libs','../xxx/libs' // xxx也是代表aar所在的libs目录的模块名称 } } 总结：
我是采用了方案1解决了问题。同时也很感谢大神这篇帖子Android Studio多Module使用 aar 依赖包 丢包解决
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/66a261f7801f9a683b88c1e4565cdae1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a81ed2996e614852bea8188749081793/" rel="bookmark">
			springboot websocket无法连接的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		情况说明：websocket在打成war包放到tomcat下面运行时可以连接成功，但是打成jar包放到服务器运行时就连接不上 错误提示 ：Error during WebSocket handshake: Unexpected response code: 404
原因找了很久很久，终于找到了问题，是代码层面的问题
//使用boot内置tomcat时需要注入此bean @Bean public ServerEndpointExporter serverEndpointExporter() { return new ServerEndpointExporter(); } 原先这个是被我注解注释掉的，因为用tomcat是可以不用到这个bean的，但是用jar包的时候是用的springboot的内置的tomcat
就需要加上这个bean
然后完美连接上了。。。。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f15cdaedc3b83c251209f3d7b5289578/" rel="bookmark">
			关于前端架构的过去、现在与未来
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		早期的软件架构模式建立在有限的硬件功能上并尊重这一事实，然而，今天的情况已经变了。计算能力在不断提升，而软件架构印证了这种观点。本文从经典MVC说起，详尽解读了当代前端架构及下一阶段的展望。对于前端工程师，以及想从宏观层面理解现代Web应用程序架构的Web开发人员来说，均能从中获益。
软件架构的核心思想，就是推断软件系统各个组件之间数据流动的方式。
软件架构的质量取决于你设法推断这些数据流的难易程度！
本文要讲的内容，就是在今天的 Web 应用程序背后探索这些数据流和最终的体系结构。Web 应用已从简单的静态网站（双层结构）发展为复杂的多层次、SPA 和 SSR 驱动的 API 优先系统。CMS 系统已发展成无头（Headless）和内容优先的系统。
近年来，前端社区的面貌日新月异。早年流行的是 jQuery 引入的 DOM 注入算法，其很快被基于 MVC 的 Backbone.js 所取代。之后一夜之间，我们就身陷于双向和单向数据流架构的丛林之中。我们的成长足迹在某处中断了。曾几何时沉浸在 MVC 的世界是如何突然进入 React 开创的单向数据流时代的？它们之间有什么联系？随着本文的展开，我们将尝试解开这个难题。
虽然本文针对的是前端工程师，但想要从宏观层面理解现代 Web 应用程序架构的 Web 开发人员都能从本文中获益。软件体系背后有着大量活动——流程、需求收集、部署拓扑、技术栈等等，但那些已经超出了本文所涉及的范围。
必要的前置知识——什么是计算机？
计算机是一种从用户收集数据 / 信息，并立刻或稍后将处理过的数据 / 信息提供给用户的机器。计算机如何收集和展示这些数据呢？它使用软件应用来实现这一目的。
软件架构的关键是提供合理的手段来组成软件，同时保持一切井然有序。
这里的关键在于，软件应用正在处理的数据被称为模型或应用程序状态。一些勇士可能将其称为应用程序的域模型或业务逻辑。应用程序可以是桌面端也可以是 Web 端。
本文的宗旨是探索向（Web 前端的）用户表示这种应用程序状态的合理方式，同时让一切井然有序。我们将探索数据如何从模型流向视图层，仅此而已。
经典 MVC——起源
将数据与表示分离是（Web 端和桌面端）图形用户界面的核心思想。对于 MVC——模型 - 视图 - 控制器来说，将表示（视图）与关注域（模型）分离是其主导的设计理念。毫无疑问，MVC 是一项开创性的成果，其影响力绵远流长。
如果要为软件开发写出第一原则，那么它就会是 SoC——关注点分离。而且 MVC 模式可能是它第一个真正的落地实践。
MVC 是为 Smalltalk-80 语言推出的。在 MVC 中，视图（View）对象显示模型（Model）对象持有的数据。在我们全面研究 MVC 中的数据流之前，我们必须了解当时（约 20 世纪 70 年代）的软件应用环境：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f15cdaedc3b83c251209f3d7b5289578/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e1be999dc6ae14515ae01a598700f1f/" rel="bookmark">
			万能命令：快捷直达你想要的在线工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		wn 万能命令是一个在线工具效率平台，将各种高质量的在线工具按应用站点聚合起来，让你以方便快捷好记的方式寻找和使用各类在线工具。
使用：
一、万能命令 wn.run/
在任何网页的网址前面加上这个万能命令 wn.run/ ，就会展示针对于该网页的各种附加在线工具，比如 快速查看该网页历史存档(网页被删了找回)、直接下载该网页的视频音乐文件(默认无法下载或需要安装 app 登陆等)、快速网页翻译(默认手机端下网页翻译会比较繁琐)、快速网页长截图，查看电商历史价格、突破看某些东西等，并且点击工具时一般会直达针对该网页的功能详情页，无需再复制和粘贴网页链接。
例如下载 b 站某视频：https://www.bilibili.com/video/av42686154
在网址前面加上 wn.run/ ，变为 wn.run/https://www.bilibili.com/video/av42686154
就会展示用于 b 站的在线工具集。
二、 用书签脚本方式
1、拖动或手动新建一个书签，书签的网址项里输入下面的代码
javascript:window.open('https://wn.run/f/#'+document.location.href)
2、后面浏览任意网页时，有小需求了，只需点击一下这个书签，即可马上展示用于该网页的各类工具
特点：
方便快捷，只需输入一个命令或点击一下固定书签
无需下载、即用即走
无平台限制，pc、android、ios 等都可使用
按应用站点分类，快捷寻找到可用的工具
一般直接到达用于当前网页的工具详情页
收录了很多高质量的工具
设计思路部分借鉴于油猴 greasyfork。
缺点：
目前收录的工具还不够多
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bafaf16881ac5dfc63db99b20cf74975/" rel="bookmark">
			echarts_自定义实现x-range图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		效果展示
echarts版本：4.6.0
完整代码：
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;script src="../js/echarts.js"&gt;&lt;/script&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="main" style="width: 800px;height: 500px;border: solid 1px;"&gt;&lt;/div&gt; &lt;script type="text/javascript"&gt; var myChart = echarts.init(document.getElementById('main')); var data = []; var dataCount = 10; var startTime = +new Date();//开始时间为当前时间，+号用于将日期类型转换为number类型，这里是转换为日期对应的毫秒值 var categories = ['categoryA', 'categoryB', 'categoryC']; var types = [ {name: 'JS Heap', color: '#7b9ce1'}, {name: 'Documents', color: '#bd6d6c'}, {name: 'Nodes', color: '#75d874'}, {name: 'Listeners', color: '#e0bc78'}, {name: 'GPU Memory', color: '#dc77dc'}, {name: 'GPU', color: '#72b362'} ]; //组装数据 //遍历categories数组 echarts.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bafaf16881ac5dfc63db99b20cf74975/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a9ff0d29c2b95d2bb8d08bc3dcd4e20/" rel="bookmark">
			Android：More than one file was found with OS independent path &#39;res/values/values.xml
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述：
最近在集成一个一键登录的sdk时遇到了这个问题：
More than one file was found with OS independent path 'res/values/values.xml。
分析问题：
1.首先根据报错日记：这是由于相同命名的资源文件重复，所以系统编译的时候无法识别到底需要加载哪一个文件；
2.接着，顺着这个思路，去全局搜索，看看自己的资源文件或者导引用的jar、aar或者资源文件是否有多个日记报错的资源文件；
3.通过搜索发现，导入的aar包中确实存在多个相同命名的文件：
4.由此，问题的原因已经找到了，接下来就是如何解决的问题。
解决思路：
根据网上大多数人的建议，主要以下几种：
1.找到对应的资源文件，修改命名（这种方法视项目的大小、冲突文件的数量多少而定，要只是一两个资源文件，找出来修改以下，o了；但是，如果冲突的文件太多，不建议使用这种方法）；
2.在gradle配置项packagingOptions中使用exclude，过滤掉某些文件或者目录不添加到APK中，作用于APK，不能过滤aar和jar中的内容：
... android{ packagingOptions { exclude 'res/values/values.xml' exclude 'libs/loginsdk1.0.4-release.aar/res/values/values.xml' } } ... exclude后面的，就是需要过滤的文件路径。这种方法直接，简单，也是大多数人使用的方法。
3.与方法2相类似：packagingOptions中使用pickFirst，匹配到多个相同文件，只提取第一个。只作用于APK，不能过滤aar和jar中的文件。
比如：
... android{ packagingOptions { // pickFirst 'res/values/values.xml' // pickFirst 'AndroidManifest.xml' } } ... 4.但是，当我们是引用的三方的jar包或者aar资源文件，无法修改重复命名的资源文件，同时，虽然文件名相同、但文件内容不同的情况下，显然几种方法都无法解决问题，因此，这个时候，我们可以大胆的猜测：既然packagingOptions 的配置项可以过滤文件、提取文件等等，那我们是不是还可以通过标识完整的重复命名的资源文件，然后让系统进行提取，或者，我们还可以让重复命名的文件进行合并？而，顺着这个思路，我度娘了一下关于gradle配置项packagingOptions使用说明
gradle配置项packagingOptions使用说明
从这个帖子里面，果然找到了解决方法：
merge，将匹配的文件都添加到APK中，和pickFirst有些相反，会合并所有文件
于是，把重复文件进行了合并：
android{ packagingOptions { merge 'res/values/values.xml' merge 'AndroidManifest.xml' merge 'res/drawable/login_bg.xml' merge 'R.txt' merge 'classes.jar' } } 最后，编译，通过。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3a9ff0d29c2b95d2bb8d08bc3dcd4e20/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/605d048c4b8f5f584805f053887aef6c/" rel="bookmark">
			JAVA  蓝桥 组队
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题描述：
作为篮球队教练，你需要从以下名单中选出 1 号位至 5 号位各一名球员， 组成球队的首发阵容。 每位球员担任 1 号位至 5 号位时的评分如下表所示。请你计算首发阵容 1 号位至 5 号位的评分之和最大可能是多少？
思路：看题，很清楚，就是五个最大数之和。废话不多说，看图吧~~
注意一个点：一个人只能打一个位置！！！看清楚要求哦~
小剧场：人太多，大部分是漫无目的 的走…… 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c58c7d5e48039c18cf3e05437dc7223/" rel="bookmark">
			springboot2.x整合thymeleaf的404(找不到资源)500(html名和访问地址一样)问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 引入问题可用版本号跳转方式(Spring MVC或Spring Boot配置默认访问页面不生效？)我这里的两种写法都可以controllerWebMvcConfig application.yml配置ThymeLeaf配置 命名空间引入 参考文档: https://www.cnblogs.com/yichunguo/p/12128324.html
引入问题 父版本号
&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.2.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; 版本号 2.0.7-2.1.3 出现 java.lang.ClassNotFoundException: org.attoparser.config.ParseConfiguration
&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.4.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; 版本号 2.1.4以上出现 javax.servlet.ServletException: Circular view path [index]: would dispatch back to the current handler URL [/index] again. Check your ViewResolver setup! (Hint: This may be the result of an unspecified view, due to default view name generation.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5c58c7d5e48039c18cf3e05437dc7223/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c6b964521d5dea7b2761c61009b75a9/" rel="bookmark">
			同行列对角线的格
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【题目描述】
输入三个自然数N，i，j（1≤i≤n，1≤j≤n），输出在一个N*N格的棋盘中(行列均从1开始编号)，与格子(i，j)同行、同列、同一对角线的所有格子的位置。
如：n=4，i=2，j=3表示了棋盘中的第二行第三列的格子，
当n=4，i=2，j=3时，输出的结果是：
(2,1) (2,2) (2,3) (2,4) 同一行上格子的位置
(1,3) (2,3) (3,3) (4,3) 同一列上格子的位置
(1,2) (2,3) (3,4) 左上到右下对角线上的格子的位置
(4,1) (3,2) (2,3) (1,4) 左下到右上对角线上的格子的位置
【输入】
一行，三个自然数N，i，j，相邻两个数之间用单个空格隔开(1≤N≤10)。
【输出】
第一行：从左到右输出同一行格子位置；
第二行：从上到下输出同一列格子位置；
第三行：从左上到右下输出同一对角线格子位置；
第四行：从左下到右上输出同一对角线格子位置。
其中每个格子位置用如下格式输出：(x,y)，x为行号，y为列号，采用英文标点，中间无空格。相邻两个格子位置之间用单个空格隔开。
【输入样例】
4 2 3
【输出样例】
(2,1) (2,2) (2,3) (2,4)
(1,3) (2,3) (3,3) (4,3)
(1,2) (2,3) (3,4)
(4,1) (3,2) (2,3) (1,4)
【参考程序】
#include&lt;cstdio&gt; using namespace std; int a[11][11]; int main() { int i,n,t,s,j,x,y; scanf("%d%d%d",&amp;n,&amp;x,&amp;y); for(i=1;i&lt;=n;++i) printf("(%d,%d) ",x,i); printf("\n"); for(i=1;i&lt;=n;++i) printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7c6b964521d5dea7b2761c61009b75a9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f051733037a74ce13c33e33a1ef0e27b/" rel="bookmark">
			递归实现逆序输出整数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在这里插入代码片 本题目要求读入1个正整数n，然后编写递归函数reverse(int n)实现将该正整数逆序输出。 输入格式: 输入在一行中给出1个正整数n。 输出格式: 对每一组输入，在一行中输出n的逆序数。 输入样例: 12345 样例: 54321 //方法一调用函数 #include&lt;stdio.h&gt; void wsx(int n) { int r,sum=0; while(n) { r=n%10; n=n/10; printf("%d",r); }	} int main() { int x; scanf("%d",&amp;x); wsx(x); return 0; } 方法二
#include&lt;stdio.h&gt;
int main()
{
int n,r,sum=0;
scanf("%d",&amp;n);
while(n)
{
r=n%10;
n=n/10;
printf("%d",r);
} return 0;
}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34bed443625dd2b0c9a64ea68ae3d6dc/" rel="bookmark">
			AXI_GPIO控制器详解（1）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.AXI_GPIO应用场合 （1）AXI GPIO模块将PL端连接的GPIO信号通过AXI接口与PS模块连接，PS通过AXI接口的地址映射对PL端的GPIO信号进行读写等控制,与EMIO可以实现相同的功能，区别主要在于EMIO对于少数GPIO接口进行单独的控制，而AXI GPIO可以对多个GPIO接口合并成的总线进行整体读写控制；
（2）PS端可以借助AXI GPIO模块给PL逻辑生成一些通知信号；
（3）PL逻辑可以借助AXI GPIO模块给PS生成中断通知信号，但是必须使能AXI GPIO模块中断功能。
2.AXI_GPIO控制器框图 由下图可以知道AXI GPIO控制器有AXI Interface Module（AXI接口模块）、Interrupt Module（中断模块）、GPIO Core三大模块组成，从图中可以看出AXI GPIO控制器中断模块只针对输入信号（核心）。
（1）AXI Interface Module使用AXI_Lite接口和ZYNQ PS端的GP Master接口互联，PS用GP接口可以读写AXI GPIO控制器内部的寄存器，从而控制AXI GPIO控制器输入输出；
（2）Interrupt Module检测外部两个通道的输入信号（每个通道可以结合PL配置为32路三态门IO接口[输入、输出、高阻]），当检测到外部两个通道任何一个通道的任何一个输出发送上升沿或者下降沿时，都会由IP2INTC_Irpt端口生成一个中断给PS；
（3）GPIO Core为IPIC接口和AXI GPIO输入输出通道提供了一个转换接口，GPIO Core由读写寄存器和多路复用器组成，他还包括了必须的逻辑去生成一个中断事件，当一个输入状态改变时。下图为GPIO Core框图。
3.AXI_GPIO控制器所有寄存器描述及地址映射 （1）GPIO_DATA寄存器解释如下，当GPIO作为输入时，PS可以读其管教状态，写无效；当GPIO作为输出时，PS可以写其管教状态，读无效。
（2）GPIO_TRI（三态寄存器）寄存器解释如下，当为PS配置该位为0时，引脚作为输出，当为PS配置该位为1时，引脚作为输入。
（3）GIER寄存器（全局中断使能寄存器）解释如下，当为PS配置该位为0时，禁止AXI GPIO控制器产生中断，当为PS配置该位为1时，使能AXI GPIO控制器产生中断。也就是PS要想接收AXI GPIO中断，该位必须配置为1。
（4）IP IER寄存器（IP中断使能寄存器）解释如下，说白了就是可以单独控制哪一个通道中断打开与禁止。
（5）IP ISR寄存器（IP中断状态寄存器）解释如下，当发生中断时，PS可以查询这个寄存器来判断是通道1还是通道2发生的中断。
（7）寄存器地址映射如下
4.AXI_GPIO控制器配置及PS驱动 AXI_GPIO控制器详解（2）将结合本编文章详解AXI_GPIO控制器IP配置及PS中断配置及中断入口函数的编写及原理。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ad670c71a08a80d97346f7c2669d97e/" rel="bookmark">
			将Flask项目发布到公网，部署到云服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用的是阿里云的学生机
简要说明一下针对本文的环境情况：
系统：Ubuntu18.04 Server
Python：Python3.6.7
pip：pip 19.1.1
uwsgi：2.0.18
Flask:1.0.3
1.安装nginx和uwsgi 安装uwsgi
pip install -i https://pypi.tuna.tsinghua.edu.cn/simple uwsgi uwsgi通过uwsgi --version输出相应版本号则安装成功
uwsgi --version 安装nginx
apt install nginx 启动nginx
service nginx start 然后再浏览器地址栏输入IP:80
然后显示Welcome to nginx!,代表成功。
2.安装Flask pip install -i https://pypi.tuna.tsinghua.edu.cn/simple flask 创建测试项目及文件
from flask import Flask app = Flask(__name__) @app.route('/') def index(): return "&lt;h1 style='color:red'&gt;hello world!&lt;/h1&gt;" if __name__ == '__main__': app.run(host='0.0.0.0', debug=True) 测试运行demo
python3 main.py 文件结构：
root@ltmshing:~# cd /root/flaskdemo/ root@ltmshing:~/flaskdemo# ls main.py myapp.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4ad670c71a08a80d97346f7c2669d97e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1cfb39fd76c16a91725daa36c1e5063/" rel="bookmark">
			第3章 大数据kafka采集数据（Dstream创建）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上篇：第2章 Dstream入门
Spark Streaming原生支持一些不同的数据源。一些“核心”数据源已经被打包到Spark Streaming 的 Maven
工件中，而其他的一些则可以通过 spark-streaming-kafka 等附加工件获取。每个接收器都以 Spark
执行器程序中一个长期运行的任务的形式运行，因此会占据分配给应用的 CPU 核心。此外，我们还需要有可用的 CPU
核心来处理数据。这意味着如果要运行多个接收器，就必须至少有和接收器数目相同的核心数，还要加上用来完成计算所需要的核心数。例如，如果我们想要在流计算应用中运行
10 个接收器，那么至少需要为应用分配 11 个 CPU 核心。所以如果在本地模式运行，不要使用local[1]。
1、文件数据源 用法及说明 文件数据流：能够读取所有HDFS API兼容的文件系统文件，通过fileStream方法进行读取，Spark Streaming 将会监控 dataDirectory 目录并不断处理移动进来的文件，记住目前不支持嵌套目录。
代码实现：
package com.study.bigdatabase.streaming import org.apache.spark.SparkConf import org.apache.spark.streaming.dstream.{DStream, ReceiverInputDStream} import org.apache.spark.streaming.{Seconds, StreamingContext} object SparkStreaming02_FoleDataSource { def main(args: Array[String]): Unit = { //使用SparkStreaming完成WordCount //Sprak配置对象 val sparkConf = new SparkConf().setMaster("local[*]").setAppName("SparkStreaming01_WordCount") //实时数据分析环境对象 //采集周期：以指定的时间为周期采集实时数据 val streamingContext = new StreamingContext(sparkConf,Seconds(5)) //从指定文件夹中采集数据 val fileDStream: DStream[String] = streamingContext.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c1cfb39fd76c16a91725daa36c1e5063/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/767e2eae86b2d41f8bf9d97ad304aab8/" rel="bookmark">
			解决 The type java.lang.CharSequence cannot be resolved. It is indirectly referenced from required .cl
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		很不幸，最近在学习 Spring boot 时处处遇到困难，我升级了 JDK 到 1.8 之后，Eclipse 开始报各种错。其中一个错误就是我们今天要说的“The type java.lang.CharSequence cannot be resolved. It is indirectly referenced from required .class files”问题。 这个问题的大概意思时说：无法解析 java.lang.CharSequence 类型。它是 .class 文件中间直接引用的。说白了就是 java.lang.CharSequence 类型无法解析。
很奇怪啊，我在 StringBuffer 中 append 字符串居然报这种错误。不应该啊，后来通过百度搜索，发现 stackoverflow 中有一个网友解答的还是很高深。
造成这个问题的原因是 Eclipse 版本过低，不支持 JDK 1.8。
Eclipse JDK 版本
可以看到这里的编译版本中只能选择到 1.6。因此，最好的办法是对 Eclipse 进行升级。或者对你当前项目的 jdk 使用版本进行降价。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09c83a80b0189445f75f8202f365a481/" rel="bookmark">
			MapReduce的介绍和使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. MapReduce介绍1.1 MapReduce的基本思想1.2 MapReduce的设计1.3 MapReduce在yarn集群上的执行流程 2. MapReduce运行机制详解2.1 Map阶段2.1 Reduce阶段 3. MapReduce编程规范Map 阶段 2 个步骤Shuffle 阶段 4 个步骤Reduce 阶段 2 个步骤 5. MapReduce中的计数器 1. MapReduce介绍 1.1 MapReduce的基本思想 MapReduce思想在生活中处处可见。或多或少都曾接触过这种思想。MapReduce的思想核心是“分而治之”，适用于大量复杂的任务处理场景（大规模数据处理场景）。
MapReduce分为Map和Reduce两个阶段，Map负责“分”，即把复杂的任务分解为若干个“简单的任务”来并行处理，这些小任务可以并行计算，彼此间几乎没有依赖关系。Reduce负责“合”，即对map阶段的结果进行全局汇总。MapReduce运行在yarn集群
下图用介绍了类似MapReduce思想的一个实现过程
在实际的MapReduce执行过程中，可能有多个Reduce
1.2 MapReduce的设计 MapReduce是一个分布式运算程序的编程框架，核心功能是将用户编写的业务逻辑代码和自带默认组件整合成一个完整的分布式运算程序，并发运行在Hadoop集群上。
MapReduce设计并提供了统一的计算框架，为程序员隐藏了绝大多数系统层面的处理细节。为程序员提供一个抽象和高层的编程接口和框架。程序员仅需要关心其应用层的具体计算问题，仅需编写少量的处理应用本身计算问题的程序代码。如何具体完成这个并行计算任务所相关的诸多系统层细节被隐藏起来,交给计算框架去处理：
Map和Reduce为程序员提供了一个清晰的操作接口抽象描述。MapReduce中定义了如下的Map和Reduce两个抽象的编程接口，由用户去编程实现.Map和Reduce,MapReduce处理的数据类型是**&lt;key,value&gt;键值对**。
Map: (k1; v1) → [(k2; v2)]Reduce: (k2; [v2]) → [(k3; v3)] 1.3 MapReduce在yarn集群上的执行流程 MRAppMaster 负责整个程序的过程调度及状态协调
MapTask负责map阶段的整个数据处理流程
ReduceTask负责reduce阶段的整个数据处理流程
2. MapReduce运行机制详解 2.1 Map阶段 Map阶段又可以分为Map Task阶段和Map shuffle阶段，如下图所示
[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-zqLW66Jf-1581582983148)(7\1581407538401.png)]
[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-WL9H2P5l-1581582983149)(7\1581407566690.png)]
读取数据组件 InputFormat (默认 TextInputFormat) 会通过 getSplits 方法对输入目录中文件进行逻辑切片规划得到 block, 有多少个 block就对应启动多少个 MapTask.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/09c83a80b0189445f75f8202f365a481/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a328b20b41eec8ef0f29f9460597ccba/" rel="bookmark">
			7-15 输出全排列 (12分)（附详细讲解(不用递归的高效算法)）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		请编写程序输出前n个正整数的全排列（n&lt;10），并通过9个测试用例（即n从1到9）观察n逐步增大时程序的运行时间。
输入格式:
输入给出正整数n（&lt;10）。
输出格式:
输出1到n的全排列。每种排列占一行，数字间无空格。排列的输出顺序为字典序，即序列a1,a2,⋯,an排在序列b1,b2,⋯,bn之前，如果存在k使得a1=b1,⋯,ak=bk 并且 ak+1&lt;bk+1。
输入样例：
3
输出样例：
123
132
213
231
312
321
分析：
此题有两种分析法：第一种：将要n个要排列的整数看成一个整数，每次加9然后判断是否符合题目要求，成立就输出，例如：123到132，需要123加9；132到213，需要132加9个9……但是本人发现有很多无效数也要经过判断，因此最后一个测试点要超时（本地测试用时33秒），希望有大神能帮我解决这个问题，谢谢！
第二种：将n个数放入长度为n的数组，从左到右，数组中的第一个元素循环一次（循环条件范围是1到n），然后判断是否与前面的元素值一样，如果一样就再做一次循环，如果不一样就将下一个元素进行同样操作;如果超出循环条件范围，则先将当前位置下的元素值置为零，同时向左退一格，进行同样的操作……当最后一个元素经过处理后，就输出当前数组中的所有元素值。以输入样例为例，因为输入是3，所以先产生一个长度为3的数组，第零号元素先产生1，因为该元素是第一个元素，前面没有元素，且1在1到3之间，所以对下一个元素（即第1号元素）进行处理，第一号元素先产生1，因为1与第零号元素重复，所以在循环一次变为2，此时符合条件……当第2号元素产生3后，立即输出有元素（即123），因为第2号元素为最大，不能再循环了，所以向左退一格，此时该位置下元素变为3，符合条件……当321输出后，程序结束（此算法最后一个测试点用时500毫秒）。
#include&lt;stdio.h&gt; int main(void) { int a[9]={0}; int i=0; int j=0; int k=0; int n=0; int temp=0; int count=0; int sum=1; scanf("%d",&amp;n); for(i=1;i&lt;=n;++i) sum*=i;	//模拟n!运算 i=0; for(i=0;i&lt;n;++i) { up: for(temp=a[i]+1;temp&lt;=n;) { for(k=0;k&lt;i;++k) if(a[k]==temp) goto end; a[i]=temp; break; end: ++temp; } if(temp&gt;n) { a[i]=0; i=i-2; }	if(i==n-1) { for(j=0;j&lt;n;++j) if(j==n-1) printf("%d\n",a[j]); else printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a328b20b41eec8ef0f29f9460597ccba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76e37886b0cb2559e3aa94720ec95b8b/" rel="bookmark">
			CSS三栏布局中间自适应、flex布局、盒模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CSS中间自适应，左右两栏定宽 实现方法有很多种
1：浮动布局（左右浮动，中间不浮动）
.container .left { float: left; width: 200px; background-color: orange; } .container .main { background-color: rgb(0, 255, 106); } .container .right { float: right; width: 200px; background-color: rgb(76, 0, 255); } &lt;div class="container"&gt; &lt;div class='left'&gt;111111&lt;/div&gt; &lt;div class="right"&gt;1111111&lt;/div&gt; &lt;div class='center'&gt;111111111&lt;/div&gt; &lt;/div&gt; 2：定位布局（三个盒子都绝对定位，然后使用left：0；right：0）
.container&gt;div{ position: absolute; } .left{ left:0; width: 300px; background: red; } .center{ left: 300px; right: 300px; background: yellow; } .right{ right:0; width: 300px; background: blue; } &lt;div class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/76e37886b0cb2559e3aa94720ec95b8b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5fc7e9ebe011749ebf94ebf439d98f5a/" rel="bookmark">
			病毒扩散仿真java程序，仿真模拟新冠肺炎病毒扩散
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		GitHub 地址如下：https://github.com/KikiLetGo/VirusBroadcast
源码结构
源码结构比较简单，我们来一起看一下：
模型讲解
我对仿真模型做了一个抽象和概括，我们一起对照着源码分析模型的整个模拟过程和思路。
模型前提设置
首先，假设 C(400，400) 是城市的中心，整个城市是以 C 为中心的圆，L=100 是圆的半径。
假设 P(x，y) 就表示城市中的人，人受疫情影响有不同的状态 S：
S.NORMAL=0：正常。S.SUSPECTED=1：疑似。S.SHADOW=2：病毒携带潜伏者。S.CONFIRMED=3：确诊。S.FREEZE=4：隔离。S.CURED=5：治愈。 对应于感染者，和确诊者分别设置 infectedTime(被感染的时刻)和 confirmedTime(确诊的时刻)。
其次，假设医院是高为 H，宽为 W 的长方形区域，其中矩形左下角坐标为 H(800，110)。
为了表示医院容量的大小，我们把 H=606 设为常量，则 W 越大表示医院的可容纳量越大(也即床位越多);然后，假设 B(x，y) 就表示位于医院内的床位。
最后我们要设置一些启动参数：
int ORIGINAL_COUNT=50：初始感染数量。float BROAD_RATE=0.8f：传播率。float SHADOW_TIME=140：潜伏时间。int HOSPITAL_RECEIVE_TIME=10：医院收治响应时间。int BED_COUNT=1000：医院床位。float u=0.99f：流动意向平均值。 模型启动初始化
模型启动时，我们在以 C 为中心 L 为半径的圆内随机产生 5000 个 P：
/** * 以（400，400）为城市中心，在方圆100单位长度以内， * 伪随机（近似正态分布）出5000人； * 如果person的x轴坐标超过了700，则就按700算（为了限制到一定范围内） */ private PersonPool() { City city = new City(400,400); for (int i = 0; i &lt; 5000; i++) { /** * random.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5fc7e9ebe011749ebf94ebf439d98f5a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ff5ec553ca719a5bfe5e7317695098a/" rel="bookmark">
			图片底部留白怎么处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		行高指的是上下文本行高之间的基线距离
行高是指上下文本行的基线间的垂直距离，即图中两条红线间垂直距离。
行距是指一行底线到下一行顶线的垂直距离，即第一行粉线和第二行绿线间的垂直距离。
从上到下四条线分别是顶线、中线、基线、底线。我们知道display=inline的元素的vertical-align属性中有top、middle、baseline、bottom，就是和这四条线相关。
vertical-align该属性定义行内元素的基线相对于该元素所在行的基线的垂直对齐
这也就是为什么我们有时会看到图片下方会有一片留白的地方，就是因为它默认与基线对齐，而将基线与底线之间区域的地方空出来，没有填充。那么这个问题如何解决呢？
有三种解决方式 1：给图片img标签display:block 2：定义图片img标签vertical-align的值（可以是top，middle，bottom，视情况而定） 3：定义容器里的字体大小font-size为0。 4：改变父对象的属性 如果父对象的高宽固定，图片大小随父对象而定，则可以设置 父对象：overflow:hidden; top 和 bottom 之间的值即为 line-height。假如把 line-height 设置为0，那么 baseline 与 bottom 之间的距离也变为0，那道空白也就不见了。如果没有设置 line-height，line-height 的默认值是基于 font-size 的，视渲染引擎有所不同，但一般是乘以一个系数。因此，在没有设置 line-height 的情况下把 font-size 设为0也可以达到同样的效果。当然，这样做的后果就是不能图文混排了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/edf744b9e72f2ef11b42190a023d3ea9/" rel="bookmark">
			mybatis 动态代理原理分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一直以来都在使用MyBatis做持久化框架，也知道当我们定义XXXMapper接口类并利用它来做CRUD操作时，Mybatis是利用了动态代理的技术帮我们生成代理类。那么动态代理内部的实现细节到底是怎么的呀？XXXMapper.java类和XXXMapper.xml到底是如何关联起来的呀？本篇文章就来详细剖析下MyBatis的动态代理的具体实现机制。
MyBatis的核心组件及应用 在详细探究MyBatis中动态代理机制之前，先来补充一下基础知识，认识一下MyBatis的核心组件。
SqlSessionFactoryBuilder(构造器)： 它可以从XML、注解或者手动配置Java代码来创建SqlSessionFactory。SqlSessionFactory: 用于创建SqlSession (会话) 的工厂SqlSession: SqlSession是Mybatis最核心的类，可以用于执行语句、提交或回滚事务以及获取映射器Mapper的接口SQL Mapper： 它是由一个Java接口和XML文件（或注解）构成的，需要给出对应的SQL和映射规则，它负责发送SQL去执行，并返回结果 注意： 现在我们使用Mybatis，一般都是和Spring框架整合在一起使用，这种情况下，SqlSession将被Spring框架所创建，所以往往不需要我们使用SqlSessionFactoryBuilder或者SqlSessionFactory去创建SqlSession
下面展示一下如何使用MyBatis的这些组件，或者如何快速使用MyBatis：
数据库表 CREATE TABLE user( id int, name VARCHAR(255) not NULL , age int , PRIMARY KEY (id) )ENGINE =INNODB DEFAULT CHARSET=utf8; 复制代码 声明一个User类 @Data public class User { private int id; private int age; private String name; @Override public String toString() { return "User{" + "id=" + id + ", age=" + age + ", name='"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/edf744b9e72f2ef11b42190a023d3ea9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e4a9e368c503ad70c12c32a44b39ad2/" rel="bookmark">
			目录（哈喽，上位机）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注：本书目前在创作阶段，完成的章节会以蓝色超链接文字显示。
一、前言 1.1-什么是上位机，什么是下位机？
1.2-上位机开发应该选择哪个编程语言？
1.3-上位机开发应该选择哪个开发平台？
1.4-什么是面向过程设计，什么是面向对象设计，什么是面向对象编程思想？
1.5-在公司被称作“某工”，一起来了解上位机程序员都和哪些人打交道
1.6-程序员必须要会“英语”吗？（会英语在编程中的优势）
1.7-工控上位机软件开发平台介绍
二、通信 2.1-关于串口上位机编程你需掌握的背景知识
2.2-使用Qt开发串口小助手（含步骤和源码）
2.3-使用C#Winform开发串口小助手（含步骤和源码）
2.4-网络通信编程你需要掌握的背景知识
2.5-使用Qt开发Tcp/Udp网络小助手（含步骤和源码）
2.6-使用C#Winform开发Tcp/Udp网络小助手（含步骤和源码）
2.7-局域网查找设备的原理
2.8-局域网查找设备时有虚拟网卡干扰的编程处理方法（网络UDP广播包发不出去）
2.9-局域网查找设备的实现代码（支持有虚拟网卡）
2.10-上位机软件怎样选择合适的通信方式？
三、私有协议定制 3.1-上位机与下位机私有协议设计与封包设计（CRC校验算法）
3.2-上位机与下位机的“私有协议”通信构架设计
3.3-上位机与下位机通信构架源代码编写与使用方法说明
四、软件功能规划与UI设计 4.1-了解软件是怎样一步一步设计出来的，最完整的软件开发流程
4.2-软件开发中，“思维导图”的作用与绘制方法介绍
4.3-软件开发中，“原型图”的作用与绘制方法介绍
4.4-软件开发中，“UI设计图”的作用与绘制方法介绍
4.5-那些漂亮软件是怎么做出来的？为啥自己做的好丑
五、对UI开发框架的解读 5.1-整个ui控件的理解
5.2-消息传递理解
5.3-ui线程的理解
5.4-各个控件的继承关系的理解
5.5-对整个ui开发框架的一个解析
六、自定义控件原理与方法 6.1-什么时候需要自定义控件
6.2-自定义控件的基本原理
6.3-设计原理，绘制方法，鼠标交互，键盘交互（DoubleRangeSlider）
6.4-自定义波形现实控件，为啥不用现成的
6.5-波形控件开发
七、为何要用多线程开发 7.1-讲出面临的问题，如果不用多线程
7.2-将多线程设计程序的构架
7.3-讲多线程使用的一些经验
7.4-计算线程与ui线程的交互方法
7.5-列举计算并现实进度对话框的例子
八、软件框架 8.1-软件代码构架设计的意义与背景（成为高级程序员必经之路）：要 着重写
8.2-源码“目录结构”命名规范与“文件名、函数名、变量名”命名规范
8.3-写代码必须要写注释吗？（为什么现实中不写注释？）
8.1-这里引入并加入一些设计模式
8.2-软件开发框架mvp
8.3-模块设计与构架
8.4-数据结构设计与内存模型
8.5-大型上位机软件结构设计，与这样设计的原因优点
8.6-模块化设计与解除耦合的意义与方法
九、文件读写 9.1-保存工程文件的原理与文件格式设计
9.2-实现保存工程文件
9.3-实现打开工程文件
9.4-配置文件读写
9.5-Xml文件读写
十、数据库的使用 10.1-介绍各个数据库的使用场合与特点
10.2-数据库开发Mysql
10.3-Sqlite
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e4a9e368c503ad70c12c32a44b39ad2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8e46e2adf64bf551043b995104ecbc8/" rel="bookmark">
			Eclipse中安装Spring Tools Suite（STS）插件的正确过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Spring Tools Suite是基于Eclipse开发的官方开发IDE工具，简称STS。 第三个版本STS3：官方只更新至2019年，2020年已经不在更新维护了。最新的STS4：官方地址为：https://spring.io/tools (现在官方名字中已经少了Suite这个单词，仅为Spring Tools) 可以使用all-in-one完整版本安装，下载解压即可使用STS。 也可以在已有eclipse中以添加插件方式安装STS。
完整版本安装（all-in-one） STS4官方界面如下：
这里下载的就是all-in-one的版本（包括IDE）。all-in-one的zip文件中已经包括Eclipse，在本地不需要先安装eclipse，下载zip文件解压后就是包括eclipse的完整STS工具。使用sts.exe启动。 注：相当于spring，在eclipse基础上开发了spring相关的套件插件，一起打包而成，并且把名字从eclipse改为了STS。
Eclipse插件安装 假如本地已经有了Eclipse，这时并不希望再来一个all-in-one（浪费空间不说，搞两个启动两个费内容，还难以管理）。而是希望再现有eclipse基础上进行插件安装，把STS工具集成到本地已经有的Eclipse中。以下为安装步骤：
1、查看自己本地已有Eclipse的版本。 本文当前Eclipse版本是4.14.0。
2、不用冲官网下载。打开Eclipse菜单中Help→Eclipse Marketplace界面，在下面点选eclipse图标，然后在界面中输入搜索关键字“STS”，选择最新的Spring Tools 4， 点旁边的“Install”按钮。
2、在如下的确认选择界面中，全部勾选，点“Confirm”。
4、然后在出现的License界面中，选择Accept接受，最后点“Finish”按钮。在Eclipse主界面右下角有安装进度显示。
5、等待约分钟安装完成后（光纤网络速度快），会提示需要重启Eclipse。 对Eclipse进行重启。重启后，New新工程向导界面中，多了“Spring Starter Project” 说明安装成功了。
6、如果Eclipse选择了Dark黑色主题，为了避免YML编辑器中默认文件字体颜色太深而看不清，建议对其YAML编辑器字体颜色进行修改。菜单Window→Preferences→YEdit Preferences→ColorPreferences。修改Scalars和Constants的字体颜色如下图中的蓝色。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/116f0e8363bdeb5672c0ad87eca5421a/" rel="bookmark">
			ArcGIS教程 - 9 矢量数据空间分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		链接：https://pan.baidu.com/s/1MhG2875Zzt-6VFLus7SYzQ 提取码：w47i
第9章 矢量数据空间分析 空间分析是基于地理对象的位置和形态的空间数据分析方法，目的在于提取和传输空间信息。空间分析是地理信息系统的主要特征和核心部分。空间分析配合空间数据的属性信息，能提供强大而丰富的数据查询功能。
空间分析主要分为矢量数据空间分析和栅格数据空间分析。
矢量数据空间分析主要表现为：一般不存在模式化的分析处理方法；处理方法表现为多样性和复杂性。矢量数据空间分析方法主要包含提取分析、叠加分析、邻域分析、统计分析和网络分析等。本章主要介绍前四种空间分析方法，网络分析在后面章节会详细介绍。
矢量数据空间分析常用的工具位于ArcToolbox的【Analyst Tool】（【分析工具】）。
9.1 提取分析 GIS 数据集通常包含比实际需要更多的数据。提取分析工具允许根据查询（SQL 表达式）或空间提取所选要素类或表中的要素和属性。
9.1.2裁剪 裁剪（Clip）操作提取与裁剪要素相重叠的输入要素（图XX）。此工具用于以其他要素类中的一个或多个要素作为模具来剪切掉要素类的一部分。在您想要创建一个包含另一较大要素类的地理要素子集的新要素类（研究区域或感兴趣区域 (AOI)）时，裁剪工具尤为有用。
图XX 裁剪示意
裁剪要素可以是点、线和面，具体取决于输入要素的类型（图XX）。
当输入要素为面时，裁剪要素也必须为面；
当输入要素为线时，裁剪要素可以为线或面。用线要素裁剪线要素时，仅将重合的线或线段写入到输出要素中；
当输入要素为点时，裁剪要素可以为点、线或面。用点要素裁剪点要素时，仅将重合的点写入到输出要素中。用线要素裁剪点要素时，仅将与线要素重合的点写入到输出要素中。
输出要素类将包含输入要素的所有属性，同时输入要素类的属性值将被复制到输出要素类。
图XX 裁剪方法
具体操作步骤为：
（1）在ArcMap【目录列表】窗口中定位到【系统工具箱】--【Analysis Tools】--【提取分析】，双击【裁剪】工具，打开【裁剪】对话窗口。
或者在ArcMap中单击【地理处理】菜单项，选择【裁剪】命令打开【裁剪】对话窗口。
（2）在打开的【裁剪】对话窗口中设置如下（图XX）：
数据位置：“\ch9\Data\Extract\Clip” 目录下
输入要素：Input.shp
裁剪要素：Clip.shp
输出要素类：Input_Clip.shp
图XX 裁剪窗口 图XX 裁剪结果
（3）【XY容差】选项保持默认
（4）裁剪结果如图XX所示。
9.1.3分割 分割（Split）操作输入要素会创建由多个输出要素类构成的子集（图XX）。
图XX 分割示意 图XX 分割对话窗口
分割要素数据集必须是面。
分割字段数据类型必须是字符，其唯一值生成输出要素类的名称。分割字段的唯一值必须以有效字符开头。
具体操作步骤为：
（1）在ArcMap【目录列表】窗口中定位到【系统工具箱】--【Analysis Tools】--【提取分析】，双击【分割】工具，打开【分割】对话窗口。
或者在ArcMap中单击【地理处理】菜单项，选择【分割】命令打开【分割】对话窗口。
（2）在打开的【分割】对话窗口中设置如下（图XX）：
数据位置：“\ch9\Data\Extract\Split” 目录下
输入要素：Input.shp
裁剪要素：Split.shp
分割字段：PYNAME
目标工作空间：\Split
（3）【XY容差】选项保持默认。
（4）分割结果和分割后属性表如图XX、图XX所示。
图XX 分割结果 图XX 分割后属性表
9.1.3筛选 筛选（Select）操作从输入要素类或输入要素图层中提取要素（通常使用选择或结构化查询语言 (SQL) 表达式），并将其存储于输出要素类中。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/116f0e8363bdeb5672c0ad87eca5421a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8bb770b56ef1044c0ee3caebc2f71509/" rel="bookmark">
			latex公式快速转换为word公式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考视频链接：https://www.bilibili.com/video/av55220064?from=search&amp;seid=6763936485328690341
1.
1.利用mathpix 软件截图公式，自动生成latex公式
2.然后打开网页
3.将公式复制到上面，点击compile
4.将光标放在MATHJAX公式中 右击，选择mathml code
5.必须先复制到文本里，然后再复制到word公式中。
用到的网页：
https://www.latex4technics.com/
下面是最好的办法：
或者直接用jupyter notebook
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8239f8790351dda5e4452bbd6ce5c22/" rel="bookmark">
			用matlab对2003年香港SARS数据建模预估新冠病毒在H市的疫情走势
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		疫情隔离阶段果然是可以心无旁骛安心学习的时光。我在《用matlab对曲线拟合做最小二乘法单目标优化》https://blog.csdn.net/weixin_41855010/article/details/104225901 中查阅了2003年的SARS数据，根据当年香港的病例数据建立并且优化一波指数模型，爬了Z市卫计委的公开数据，用非典参数估计了2月H是的新增和累积，结论是按照现在趋势，2月底H市的累积确诊预计在250见顶。所以还是好好呆在家里吧，疫情应该很快就会过去的。
下面是代码：
clear all;clf;clc; T=3; %平移量 T0=0.5;%半衰期 Peak=20;%峰值 t=1:5; y1=1./(1+exp(-(t-T)./T0))*Peak; % plot(t,y1) t=1:10 ry2=[19	18	16	13	12	8	14	9	10	5]; plot(t,ry2); hold on; for t=1:30 y2(t)=max(0,ceil(19*exp(-t/10.5)+4*(rand-0.5))); end figure(1) t=1:30 plot(t,y2) title('H市新冠肺炎新增确诊断数量预测图') legend('真实值','预测值') total = [6	12	26	28	32	51	69	85	98	110	118	132	141	151	156] added = [0 6	14	2	4	19	18	16	13	12	8	14	9	10	5] for i = 11:30 added(5+i) = y2(i) total(5+i) = total(4+i) + y2(i) end Time = length(added); t=1:Time; date = datetime(2020,1,23) + caldays(1:Time); grid on % figure(1) % plot(t,added) figure(2) plot(date,total) hold on xx1 = [5,12,19,26,33]; % x = [6.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d8239f8790351dda5e4452bbd6ce5c22/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6df42137a11a3f1a6ec84face3d73ea6/" rel="bookmark">
			重载操作符（3）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		重载关系操作符：
class Object
{
public:
bool operator == (const Object&amp; other){ }
};
重载类型转换符：
class Object
{
public:
operator Type() // Type为目标类型
{
Type result;
return result;
}
};
重载输入输出操作符：
Logger&amp; operator &lt;&lt; (Type value)
{
return *this;
}
(1) 名称 : operator &lt;&lt; (2) 返回值：左值，一般返回对象自己 (3) 参数：待输出的数据 例如： class Logger
{
public:
Logger()
{
}
Logger&amp; operator &lt;&lt; (int value)
{
printf("%d", value);
return *this;
}
Logger&amp; operator &lt;&lt; (double value)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6df42137a11a3f1a6ec84face3d73ea6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db61cb2383fac125ab66bebff56f1cf6/" rel="bookmark">
			信息学奥赛C&#43;&#43;语言： 蛇形方阵1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 【题目描述】
输入一个正整数 n，生成一个 n×n 的蛇形方阵（具体见样例）。
【输入】
一行一个正整数 n，1≤n≤20。
【输出】
共 n 行，每行 n 个正整数，每个正整数占 5 列。
【输入样例】
5
【输出样例】
代码
#include&lt;bits/stdc++.h&gt; using namespace std; int main() { int n,j,i,k,t=0,a[21][21]; cin&gt;&gt;n; for(k=1;k&lt;=n;k++) if(k%2) for(j=1;j&lt;=k;j++){ i=k+1-j; t++; a[i][j]=t; a[n+1-i][n+1-j]=n*n+1-t; } else for(j=k;j&gt;=1;j--){ i=k+1-j; t++; a[i][j]=t; a[n+1-i][n+1-j]=n*n+1-t; } for(i=1;i&lt;=n;i++){ for(j=1;j&lt;=n;j++) cout&lt;&lt;setw(5)&lt;&lt;a[i][j]; cout&lt;&lt;endl; } return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e149e66107b202e0a3b31eee938d03f/" rel="bookmark">
			ArcGIS教程 - 5 地图可视化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实例数据：https://pan.baidu.com/s/17Kx42473e97RBrYTHF8n2A 密码：u6wd
第5章 地图可视化 地图可视化是有效传输与表达地理信息，挖掘空间数据之间的内在联系，揭示了地理现象内在规律的重要手段。地图作为一种信息载体，是地理信息的一种图形表达方式，以符号、文字、图形等形式表示空间数据的位置、形态、分布和动态变化的信息，表达其在空间、几何和时间上的关系。本章主要介绍空间数据符号化、地图注记、图表、报表、时态数据的实现和操作方法。
5.1地图符号化 地图符号由形状不同、大小不一、色彩有别的图形和文字组成，是地图语言的解释部分。图形语言更加形象直观、一目了然，不仅能够表示地理现象的空间位置、分布特点以及数量和质量特征，而且具有相互联系和共同表达地理环境各要素总体特征的功能；文字语言可以补充图形语言解释不全面或者不清晰的缺陷。
5.1.1地图符号 地图符号以图形方式对地图中的地理要素、标注和注记进行描述、分类或排列，以找出并显示定性关系和定量关系的过程。
根据符号绘制的几何类型不同，可将其分为四类：标记符号、线符号、填充符号和文本符号。
5.1.1.1标记符号
标记符号用于绘制点要素和点图形。它们可与其他符号配合使用以整饰线符号，或创建填充模式和文本背景。
标记符号分为以下四类：
（1）简单标记符号：由一组具有可选轮廓的快速绘制基本符号模式组成的标记符号。
（2）字符标记符号：通过任何文本中的字形或系统字体文件夹中的显示字体创建而成的标记符号。
（3）箭头标记符号：具有可调尺寸和图形属性的简单三角形符号。若要获得较复杂的箭头标记，可使用 ESRI 箭头字体中的任一符号创建字符标记符号。
（4）图片标记符号：由单个 PNG (*.png)、JPEG (*.jpg,*.jpeg)、GIF (*.gif)、Windows 位图 (.bmp) 或 Windows 增强型图元文件 (.emf) 图形组成的标记符号。Windows 增强型图元文件与栅格格式的 Windows 位图不同，属于矢量格式，因此，其清晰度更高且缩放功能更强。
5.1.1.2线符号
线符号用于绘制线状数据，例如交通网、供水系统、边界、分区及其他连接网络。线还用于绘制其他要素（例如面、点和标注）的轮廓。作为图形，线可用作边框、箭头和其他注记的牵引线以及手绘图。可将任意数量拥有任意线符号类型的符号图层合并到单个线符号中。
线符号可以分为以下五类：
（1）简单线符号：简单、快速绘制的实线或带有预定义式样且宽度为一个像素的线。
（2）制图线符号：通过属性来控制重复虚线式样、线段间连接点和线端头的线符号。可偏移几何来绘制这些符号，并且它们可以包括线整饰，例如沿线和/或在线端点处添加标记符号。
（3）混列线符号：由重复的线符号片段组成的线符号。默认情况下为垂直于几何绘制的混列线，但也可以按其他角度绘制。
（4）标记线符号：由沿着几何绘制的重复标记模式组成的线符号。
（5）图片 - PNG (*.png)、GIF (*.gif)、JPEG (*.jpg,*.jpeg)、Windows 位图 (.bmp) 或 Windows 增强型图元文件 (.emf) 图形在线长度方向的连续平铺。图片线状符号会大幅增加绘制和导出时间，生成的结果也通常不够美观。建议使用其他任意一种线符号类型来代替。
5.1.1.3填充符号
填充符号可用于绘制面要素，例如国家/地区、省、土地利用区域、栖息地、宗地和轮廓线。填充可通过单色、两种或多种颜色之间平滑的渐变过渡效果或者线、标记或图片的模式进行绘制。填充还可用于绘制图形形状和背景、数据框、地图元素、图形和文本。可将多个任意填充类型的图层合并到单个填充符号中。例如，标记填充图层可在单色填充图层上方进行绘制，从而创建不透明符号。
填充符号可以分为以下五类：
（1）简单填充符号：可选轮廓的快速绘制单色填充。
（2）渐变填充符号：对线性、矩形、圆形或者缓冲区色带进行连续填充。
（3）线填充符号：以可变角度和间隔距离排列的等间距平行影线的模式。
（4）标记填充符号：重复标记符号的随机或等间距模式。
（5）图片填充符号：PNG (*.png)、JPEG (*.jpg, *.jpeg)、GIF (*.gif)、Windows 位图 (.bmp) 或 Windows 增强型图元文件 (.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4e149e66107b202e0a3b31eee938d03f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/694f05824aa2f3ff275308e20284cfd5/" rel="bookmark">
			ArcGIS教程 - 2 ArcGIS基础知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第2章 ArcGIS基础知识 2.1 ArcGIS10.x概述 ArcGIS10.x是ESRI公司开发的GIS产品家族，它集合了数据库、软件工程、网络技术、移动技术、云计算等主流的IT技术，目的是提供给用户一套完整的、开放的企业级GIS解决方案。本章主要介绍ArcGIS产品的发展史、构架等方面的内容。
ESRI(Environmental System Research Institute，环境系统研究所)创建于1969年，总部位于加州的雷德兰兹。1982年ESRI发布第一套商业化GIS软件ARC/INFO 1.0，可以在计算机上显示点、线、面，并通过数据库管理工具将属性信息与之结合。ARC/INFO 1.0被公认为第一个商业化GIS系统。
1986年PC ARC/INFO的出现是ESRI软件发展史上的又一个里程碑，它是为PC的GIS工作站而设计的。
1992年ESRI推出了ArcView软件，人们可以用更少的投入就可以获得一套简单易用的桌面制图工具。
在20世纪90年代，ESRI推出了基于Windows NT构架的Arcinfo产品，满足用户GIS和制图多样的选择，同时奠定了ESRI在GIS市场的领头羊地位。
2004年推出了新一代的ArcGIS 9，为构建完善的GIS系统提供了一套完整的软件产品。
2010年ESRI推出ArcGIS 10，全球首款支持云构架的GIS平台，使ArcGIS 10真正具备了3D建模、编辑和分析能力，并实现了三维空间向四维时空的飞跃，真正的GIS与RS一体化。
2.2 ArcGIS10.x家族 ArcGIS家族包含众多的组成部分，最主要的几部分如下，如图所示：
• ArcGIS for Desktop - 一套集成的、桌面端的专业 GIS 应用程序。
• ArcGIS for Server - 将 GIS 信息和地图以 Web 服务形式发布，并且支持企业级数据管理。
• ArcGIS for Mobile - 为野外计算提供移动 GIS 工具和应用程序。
• ArcGIS Online - 提供可通过 Web 进行访问的在线云 GIS 功能。
2.2.1 ArcGIS桌面产品级别 ArcGIS桌面是GIS专业人士的主要工作平台，用来管理复杂的GIS流程和应用工程，来创建数据、地图、模型和应用。是在机构内部署GIS应用的起点和基础。
ArcGIS桌面是一系列整合的应用程序的总称，包括ArcMap、ArcCatalog、ArcGlobe、ArcScene、ArcToolbox 和Model Builder。通过通用的应用界面，用户可以实现任何从简单到复杂的GIS任务。根据用户的伸缩性需求，ArcGIS桌面分为三个级别产品,如图所示：
• ArcGIS for Desktop Basic：主要用于综合性数据使用、制图和分析；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/694f05824aa2f3ff275308e20284cfd5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc5c411bcf4399a39452ae6836c42fec/" rel="bookmark">
			【深度长文】中国电子商务简史：1999-2019
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		中国电子商务简史：1999-2019
中国电子商务20年历史，由于受制于电子商务的重，所以电商企业往往开始于上一个五年而成就于下一个五年，让子弹飞一会是必须的时间。在我以下的文章中你会处处感受到。
中国电子商务，商务+电子。四大基础业务是：营销-交易-仓储物流-金融。
营销的关注点：线上 VS 线下、海量用户 VS 有限用户、自我营销 VS 社交网络UGC营销。
交易的关注点：虚拟物品（服务） VS 实体物品（服务）、标品 VS 非标品、高频次交易 VS 低频次交易、中低客单价 VS 高客单价、自有产品品牌自营零售 VS 开放零售平台
仓储物流的关注点：易仓储 VS 难仓储、易物流 VS 难物流
金融的关注点：支付、微贷、信用、反欺诈、风控
电子的关注点是：云计算、大数据、智能硬件、人工智能
中国电子商务其实分为三个发展阶段，每个发展阶段是十年，我把它分为：营销时代（1998-2008）-交易时代（2008-2018）-供应链时代（2018-2028）。我们才刚刚过了20年-两个时代。我们接下来的十年，是供应链时代，所以你会看见各种分销平台、采购平台在2018年后的崛起。但这种商业业务和最终消费者没有直接关系，而且极其考验供应链，这是所有人都陌生的，下一代巨头需要具备什么样的要素，可能利丰这个从供应链起家、从欧美海外国际化发展起来的百年企业，在未来十年供应链时代、一带一路时代，值得人们学习揣摩与创新适应。
（1）1999-2003：携程：虚拟电子机票
一、营销
营销流量，经历了这20年，看到的不外乎三种：内容流量、内容搜索流量、社交网络流量。你如果想干流量的事，必出其一。
中国三大新闻内容门户正式成立是在1998年：新浪、搜狐、网易。他们一开始建立了庞大的原创内容采访团队、编辑团队，后来他们想明白了，互联网企业应该承担的是内容分发优势，而不应承担内容创作优势。所以你看成功的流量公司都是别人创作内容。而真正创作内容的互联网公司，现在都在搞什么会员订阅付费制，真的以内容收费取胜了，而不是流量营销广告了。
社交网络流量，天涯BBS、腾讯IM，都是1999年成立。
至于内容搜索流量，百度是2000年成立的。
真正把营销流量和电子商务转化挂接在一起的，是1999年由信息产业部推动、人民日报及其他媒体联合举办，在北京、上海、广州三地同时举行，那就是著名的“互联网72小时网络生存测试”。
二、零售业态
1999年，才是中国电子商务的元年。因为那一年：阿里巴巴、易趣、当当、携程、前程无忧都是在那一年成立的。当当的B2C标品图书、阿里巴巴的B2B企业黄页、易趣的C2C电子交易平台、携程的电子机票票务凭证、前程无忧的电子简历。中国电子商务业态，一开始就很齐备。
三、仓储物流
说到仓储物流，其实四通一达成立的都非常早。申通（1993年）、圆通（2000年）、中通（2002）、汇通（2003年）、韵达（1999年）。不过那个时候他们还没有全国知名。直到下个时代，才在淘宝的带领下成了气候。
1999年是另外一个公司。E国，1999年成立。不过它引爆的“E国一小时”配送活动更让人知名，但那已经是2000年的活动了。
四、金融
1999年，招商银行推出一网通，方便大家网上支付、网上转账。中国人，是1985年才用上银行卡（过去都是现金），1988年才出现第一台ATM机用于随时随地可以卡-现金交换。1997年建行虽然建设成了第一个网上银行系统，但是真正用网上银行开拓业务成气候的只有招商银行。没有资本、后起之秀的招商银行当然很头疼如何扩张网点的事，所以招商银行专门在互联网上下功夫。这就是时代的机遇。这个回顾让我们值得反复咀嚼。
五、技术
这个时代没什么技术可拼。既不拼搜索也不拼推荐。都是些传统技术：网页+JAVA中间件+Oracle数据库、小型机服务器。为了保证事务一致性、金额计算精确性、并发性能、架构体系、安全保障、运维不间断可用性，电子商务网站往往从信息技术应用最成熟的金融银行机构、电信运营商挖研发工程师。
六、洞察
当我们回顾这个阶段的时候，我们发现，冲出来的只有两家：携程（2003年12月上市）、前程无忧（2004年9月上市），他们都是服务业电商。他们都是具备两个特点：顾客海量、虚拟数字产品（服务）。这两个特点是非常关键的
而阿里巴巴因为是B2B所以顾客量少，而当当虽然是标品低价图书，但因为是实物，不可避免需要牵扯到仓储物流配送，这是水泥。但是很讽刺的是：携程在上市之前，主要营销就是在火车站和机场散卡片和做会员注册登记，主要营收渠道主要来自呼叫中心，而非网站客户自助订票。
（2）2004-2008：淘宝：虚拟营销交易平台
第一代胜出，第二代已经悄然起航。
一、零售业态
2003年5月淘宝项目发源于马云的湖畔花园，7月淘宝网正式成立。10月份，淘宝网推出支付宝服务。2004年，支付宝和淘宝网分拆。
淘宝网为啥成立？网上很难看到当时马云做决策时的真正初衷了。可能是SARS非典影响阿里巴巴B2B业务，可能是eBay对马云的启发（2002年3月eBay并购中国易趣网），可能是马云看到了阿里巴巴B2B黄页业务用户群少、客单价高、起量慢。网上现在说的是马云受SARS影响。这个理由我觉得最不靠谱。我为啥这样思考？就是因为中国2001年12月才加入WTO，正是出口大风。而且阿里巴巴地处浙江：小商品高度发达地区，既有温州一镇一品的生产，又有几天几夜逛不完的义乌小商品交易市场。阿里巴巴B2B黄页做的事其本质就是线上的义乌小商品交易市场，把中国小商品介绍到海外。而且当时阿里巴巴铁军的强悍之处就是电话销售，黑压压一屋子电话，而非面对面销售。在线不受SARS影响、海外不受中国SARS影响、电话销售不受SARS影响。阿里集团第一任CEO陆兆禧，就是在1999年12月加入阿里巴巴（阿里巴巴是1999年9月成立），立即奉命组建广东大区团队、开拓广东地区业务。在加入阿里巴巴之前，陆兆禧自己和朋友成立的公司，就是搞VOIP互联网电话，让做海外贸易的人可以打便宜的互联网电话。
但总体说来，淘宝是不是一家线上零售公司，很难说。因为淘宝自己不进货不囤货不卖货不送货，淘宝的营收主要也来自电商营销广告（钻展广告和搜索推荐广告）。就好像人们说Google不是搜索公司是世界上第一大广告公司一样。从本质来讲，整个阿里应该是一家社会资源整合调度公司：阿里妈妈是社会营销资源调度调度公司、阿里巴巴淘宝天猫是社会商品资源整合调度公司、菜鸟网络是社会仓储物流资源整合调度公司、蚂蚁金服是社会资金资源整合调度公司。
2006年还有一个公司不合时宜的产生，但我们仍然要把它介绍出来，因为它对以后的事物意义深远。这个公司就是：YES!PPG。这是一家到处在财经媒体上打营销广告的公司，营销口号也颇为给力：YES!PPG。它的定位和财经媒体的定位人群一样精准，那就是：商务男人。它自己打造品牌，既是产品品牌也是零售品牌。它自己建立电子商务网站网上直销。它利用中国溢出的服装生产能力委托加工，它的设计如同海澜之家一样属于山寨模仿买手制，它自己控制好供应链，它还委托了专门的第三方质量监理公司为它做质量保证，直到PPG倒闭，它的产品质量也没有发生大问题。这是一家极其精准凌厉的公司。但是，还是如烟花一般坠落。后来，2007年，模仿它的凡客诚品成立了。
2007年还出现了一家公司，与阿里集团背道而驰，它是真正的自己进货囤货卖货送货。它就是京东。2007年8月，一家北京中关村的普通柜台获得了一笔风险投资。这家普通柜台只是中关村2万多个商铺之一。这家线下商铺1998年就建立了，都快经营十年了。这家公司就是：京东。它获得投资的时候，还经营着线下11家连锁店。如果大家在那个年代去过中关村，你们会知道，所有的店铺都会告诉你应有尽有，即使没有的货，他们也会通过拼缝来给你找到。京东也这么干。所以京东虽然主营刻录机、光盘，但你说你要电脑，它一样可以给你调来货。而且2002年，中关村商铺就都在通过BBS论坛、QQ群来网上卖货，这一点都不稀奇。京东在网上卖货，也根本不是受SARS影响倒逼走到线上。
但是京东最凌厉一招是：拼缝是拼缝，三天内给你结算货款。这对于谁都缺钱的中关村小商铺们都有极大的诱惑。中关村作为北方最大的IT品流通集散地，资金需求量极大，但是每家商铺又都是白手起家。批发分销生意固然走量大，但周转资金慢啊，压不起啊。但，其实京东也搞不定三天内结算货款。毕竟消费者在网上要货，京东到村里拼缝找货，再邮寄出去，邮政物流人员收到款项，然后再和京东结算，京东再给商铺，这个周期在2007年根本无法完成。拿到了第一笔风险投资的京东，老刘力排众议，一咬牙，做了自营物流。但是大家知道，自古以来，码头仓库扛包、跑路运输，都是江湖人，一般人根本治不了这些人。至于京东为啥能做成，那是另外一个传奇故事了。
2008年，中国发生了四个事：汶川地震、北京奥运会、全球金融危机、中国房价高涨。北京奥运会搞新意，主打科技奥运。所以中国电信运营商那一年疯狂降价、提速，在各个小区摆摊位拉易拉宝，挨家挨户推进大家安装宽带。有宽带就得有电脑。另外大家也不要忘了另外几件事：2008年，中国政府正式发布3G牌照。2008年，支持3G的iPhone发布。2008年，第一款Android手机发布。全球金融危机，出口制造、固定资产投资、内需消费三驾马车，少了一驾，如何那两驾快速顶上，这让中国政府很是头疼。既要拉动固定资产投资又要拉动消费。想来想去，地产，是唯一的二合一的手段。干了。从此，中国各个城市都成为了一个个的大工地。中国房价立马拉升。换了新房，你就得好马配好鞍，你就得换新的家具家电。所以京东三大强势品类：电脑、家电、手机，也是有历史大背景的。
全球金融危机欧美内需减少，中国供应商都头疼如何出口制造转为内销消费。于是你会看见：2008年品牌尾货销售网站唯品会成立（2012年上市）、轻奢品销售网站寺库成立（2017年上市）、快消品销售网站1号店成立（2015年被京东收购）。中国电商行业其实是在2010年后才加速规模发展的，这里面很重要的一个原因就是受全球金融危机影响，中国出口制造能力正在逐步转向内部消费零售。
二、服务业态
2002年，携程创始人之一季琦，创办了如家快捷酒店。如家采取统一品牌、统一采购物料、统一租赁、统一装修、统一人员招聘与培训、统一作业标准流程、统一IT、统一线上营销和线上订单，4年后2006年上市，后来兼并了不少快捷酒店，形成了多层次住宿集团：华住。我现在看如家、链家自如、毛大庆的优客工场，都是一样一样的，都是同一个模式。大家要比就比服务业的最核心两个指标：平米数、满客率。
三、营销
2003年有一个重大的媒介公司刚刚成立，那就是分众传媒。在它成立之前，线下电台电视台、报纸杂志、路牌早形成割据市场。线上也是内容媒体门户广告、社交网络广告、搜索广告三大割据。分众传媒独辟蹊径开辟了楼宇广告。随之，一股风，公交地铁机场火车站交通、甚至连厕所广告都不放过。分众传媒几经兼并，形成了一家独大。分众传媒很独特，因为这个市场，要么是内容来引广告，要么是自己没有内容而是作为Agent给别人拉广告，分众是自己也没有内容，但就是有广告展示坑位，自己发展各地分销代理商自己拉广告投放企业金主。所以分众传媒利润很高。广告位位置就和商铺金铺位置一样，位置位置位置，说一万遍都不过分。广告金位x广告坑位，有了这个资源，就看广告投放填充量、客单价了。你看百度搜索广告就很牛，关键字就代表着无穷的广告坑位，竞价排名就意味着广告金位，还得预先充值而不是事后结算转账，而且还按点击量来消耗，太牛的商业模式了。
2004年，第一届网商大会开幕，第一批淘品牌产生。这就是马云搞平台，搞平台营销的高明之处。别人都搞大促销售，它搞大会营销。
随着腾讯2007年上市、百度2005年上市，2006年又是中国互联网的一个大年。这是从2004年开始的Web2.0风吹到的最高点。2006年，服务业黄页58同城创立。2006年，以影音书点评为主题的社交网络豆瓣创立。如果说阿里巴巴是商品黄页，那么58同城就是服务业黄页。如果说当当是卖书的，那么豆瓣就是卖书的营销流量前导，这是完美的社交网络营销流量和电子商务的结合。
四、仓储物流
2008年8月1日，中国第一条高铁：京津城际铁路正式运行。这虽然不算商品的仓储物流信息，但这条信息也非常关键，因为它在未来十年大大加速了中国消费人群的流动规模和效率。
五、金融
支付宝是个神奇的产物。淘宝2003年成立，中国网上购物大家还很陌生，前怕狼后怕虎，商家怕买家不给钱，买家怕商品收到后不满意不能退款，所以成交效率不高。支付宝一开始的作用是个信用担保平台（保理）。后来经过2015年一战，才真正聚焦在聚合支付工具角色。自从加了花呗，就又附加了微贷信用卡角色，自从加了余额宝，就又附加了微理财角色。现在似乎又想走向Open Uni ID。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bc5c411bcf4399a39452ae6836c42fec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/981b046a0d0c832b8795344099538391/" rel="bookmark">
			从天津百货大楼 5 病例“迷局”见新冠病毒传播路径
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		天津某百货大楼内部相继出现 5 例新冠肺炎确诊病例，从起初的 3 个病例来看，似乎找不到任何流行病学上的关联性。在这种背景之下，作为技术人员可以通过什么技术来找寻病例之间的联系呢？
摘要 最初，nCoV 新冠病毒的扩散过程是由一个人（节点）向各其他人（节点）扩散的树状结构，但随着病毒的变异和人员交叉感染、“百家宴”、“联欢会”、“春运”等人员聚集，疫情扩散为网状结构。可以使用图数据库来存储相关人员、地理位置、感染时间等数据，本文将使用图数据库 Nebula Graph 作为工具，带大家一起探讨疫情的传播路径，并找到相关的疑似病例。
天津案例简述 下面用 Usr1、Usr2、Usr3、Usr4、Usr5 来代指这 5 例病例，看一下他们的行为轨迹：
Usr1 信息:
Usr1 于 1 月 24 日开始发热，在 1 月 22 日至 1 月 30 日期间在天津百货大厦 A 区工作，于 1 月 31 日确诊；Usr2 信息：Usr2 为 Usr1 丈夫，于 1 月 25 日开始出现腹泻症状，于 2 月 1 日确诊；Usr3 信息：Usr3 于 1 月 18 日接触过一个疑似病例，而后在天津百货大厦 B 区工作，于 1 月 24 日开始发热，于 2 月 1 日确诊；Usr4 信息：Usr4 于 1 月 12 日、13 日接触过疑似病例，而后在天津百货大厦 C 区工作，于 1 月 21 日开始发热，于 2 月 1 日确诊；Usr5 信息：Usr5 于 1 月 23 日下午 16 点到 23 点到过天津百货大厦 A、B、C 区，1 月 29 日开始发热，2 月 2 日确诊； 下面我们来建立一个传播路径的模型。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/981b046a0d0c832b8795344099538391/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b813b0f76a87200d138dee9f570d755/" rel="bookmark">
			【前端】【vue.js】【参考项目】vue-konva-project
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 概述 目标 制作在线ppt编辑排版网页，支持插入文本框，图片，添加操作逻辑人性的缩放移动功能 项目地址 CSDN博客 GitHub项目 项目介绍 实现类似美图秀秀网页版的拼图工具 项目框架 vue.js Javascript框架 Konva.js Canvas绘图框架 iView UI组件库 目录结构 assetslibsviewscomponents TemplateStage index.vueLayerFont.vueLayerGroup.vue Template.vueTemplateConfig.vue store modules material.jstemplate.js index.js App.vuemain.jsrouter.js Store Directory Vuex 简介 vue.js项目中的数据集合，存储在store的数据任意时刻对组件公开，实时响应修改更新。 Concepts State 存放所有数据 Getters 获取数据的句柄 Mutations 修改数据的句柄（只支持同步操作） Actions 操作数据的句柄（可以支持异步操作） Modules 将store模块化为多个module分类管理 Components Directory Template.vue 主页面组件，组件内负责结构排版以及“模板名称panel”与“画布配置panel”调用TemplateStage以及TemplateConfig TemplateConfig.vue 侧边栏panel组件，组件内负责“模板框配置panel”以及“装饰配置panel”调用CommonSliderBar.vue绘制拖动条 TemplateStage 画板绘制组件，利用vue-konva绘制stage 未完待续… 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db86ca03412b6400dad9c2ed7aa0da4c/" rel="bookmark">
			【cpp-taskflow】源码分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、简介 cpp-taskflow 源码：https://github.com/cpp-taskflow/cpp-taskflow
（后面简称taskflow）
taskflow一个写的比较好的基于task有向无环图（DAG）的并行调度的框架，之所以说写的比较好，个人觉得有几点原因：
1.是一个兼具学术研究和工业使用的项目，并非一个玩具
2.现代C++开发，风格简洁
（源码要求编译器支持C++17，也比较容易改成C++11）
3.文档全面
4.注释丰富
因此，学习和研究了taskflow的代码，并写此文作为学习笔记。
通读代码之后，个人的感觉是开发一个通用的DAG调度框架重要在三个方面：
1.拓扑结构的存储和表达
taskflow存储和表达拓扑结构的方式还是比较简单的，用Node类表示DAG中的每个结点，Graph类存储所有的Node对象，Topology类表示一个拓扑结构，后面再详细说。
2.拓扑结构的调度执行
taskflow的调度逻辑中为提高性能做了较多优化：通过WorkStealingQueue提高线程使用率，通过Notifier类（from Eigen库）减少生产者-消费者模式中加锁的频率等。
3.辅助工具或功能
taskflow提供方法可以比较简单的监视每个线程的活动、分析用户程序的性能。
二、基本数据类型 1.类Node 类Node最重要的是保存了当前节点的执行函数，所有前继节点的指针、后续节点的指针，子图（如果有的话），每个前继节点完成后需要修改的计数器（当所有的前继节点都完成时，当前节点就可以执行了）。
class Node { //static节点的执行函数是返回值和参数都是void的函数 using StaticWork = std::function&lt;void()&gt;; //dynamic节点的执行函数是返回值为void、参数为Subflow的函数， //在代码中通过模板元编程判断参数是否是Subflow来区分静态节点还是动态节点 using DynamicWork = std::function&lt;void(Subflow&amp;)&gt;; //节点的status constexpr static int SPAWNED = 0x1; constexpr static int SUBTASK = 0x2; public: Node() = default; //可以通过构造函数传入节点的执行函数，可以不传入（default构造函数），后续再set template &lt;typename C&gt; Node(C&amp;&amp;); //传入当前节点的一个后续节点 void precede(Node&amp;); private: std::string _name; //用了C++17的std::variant函数，可以认为就是union类型，未设置、static work、dynamic work std::variant&lt;std::monostate, StaticWork, DynamicWork&gt; _work; //所有的后续节点 tf::PassiveVector&lt;Node*&gt; _successors; //所有的前继节点 tf::PassiveVector&lt;Node*&gt; _dependents; //子图，正如github上的文档所说，每个节点可以在执行期动态的创建子图 //这里用了C++17的std::optional函数，多了”未设置“状态，好处是如果未设置不会调用Graph的构造函数 std::optional&lt;Graph&gt; _subgraph; //若有值，表示此节点实际一个Taskflow，通过组合成为了一个Node Taskflow* _module {nullptr}; //以下两个是弱引用 Topology* _topology {nullptr}; Taskflow* _module {nullptr}; int _status {0}; //前继节点的个数，在调度执行过程会多线程修改，所以是std::atomic类型。 std::atomic&lt;int&gt; _num_dependents {0}; }; 重点说下precede函数的实现
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/db86ca03412b6400dad9c2ed7aa0da4c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd1da4529c4eceff5e9c60c1338e7593/" rel="bookmark">
			js实现下载excel
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		excel是常见的表格处理工具,那么前端怎么实现excel生成与下载呢?我们利用xlsx.js来实现
一. 安装js-xlsx
npm install xlsx 二. 文档简介
完成的XLSX对象:
需要理解的术语:
1 workbook是xlsx读取excel内容后的js对象,读取到内容后可以对表格进行操作;同样的也可以创建一个空的workbook,往其中写入内容
完整的workbook对象:
(其中最重要的是两个属性,SheetNames(表名)以及Sheets(数据))
2. XLSX.utils是XLSX重要的一个对象,可以实现读取其他文件格式如: 数组/json/html为workbook形式;同时也可以导出
2.1 数组转为表格并下载
// 1. 准备js数组 const arr = [ ["序号", "姓名", "公证编号", "手机号", "房号", "身份证号", "类型", "备注"], [1, "刘备", "a1234", "13548182222", "", "1111", "户口入学", "aaa"], [2, "张飞", "b1234", "13548182223", "", "222", "随迁入学", "bbb"], [3, "关羽", "c1234", "13548182224", "", "33333", "户口入学", "ccc"] ]; // 将数组转为sheet const sheet = XLSX.utils.aoa_to_sheet(arr); // 先组装wookbook数据格式 let workbook = { SheetNames: ['test'], // 总表名 Sheets: {test: sheet}, // test是表名 }; // 下载表格 XLSX.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fd1da4529c4eceff5e9c60c1338e7593/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c383601a20df1d1e745dc92f15cacf2/" rel="bookmark">
			链栈的C&#43;&#43;实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		链式结构栈的C++实现，参考书《数据结构》（秦峰，汤亚玲）
代码实现贴一下:
#include &lt;iostream&gt; //链栈 class StackNode{ public: int data; StackNode *next; StackNode(){ next = NULL; }; }; class LinkStack { //链栈的定义 private: StackNode *top; public: LinkStack(){ top = NULL; //构造一个空的栈 }; ~LinkStack() { StackNode *p; while (top) { p=top; top = top-&gt;next; delete p; } top =NULL; //栈顶指针为空代表空栈 } int Empty_Stack() { return(!top); //空返回1，不空返回0 }; int Push(int e){ StackNode *p = new StackNode(); if(p) { //这里链栈相当于一个没有头结点的链表，每次都用头插法插入新的结点 p-&gt;data = e; p-&gt;next=top; //栈为空栈的时候，p-&gt;next是NULL，不空的时候，指向栈顶元素 top = p; return 1; } else return 0; }; int Pop(int &amp;e){ StackNode *p; if(top) { p = top; e = p-&gt;data; top = top-&gt;next; delete p; return 1; } else return 0; }; int GetTop(int &amp;e){ //取栈顶的元素 if(top) { e = top-&gt;data; return 1; } else return 0; } }; int main() { std::cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9c383601a20df1d1e745dc92f15cacf2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ff250e796f732a8e9994419becea54f/" rel="bookmark">
			Tarjan算法超详细讲解(割点割边强连通)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天我主要介绍Tarjan算法在割点割边以及强连通分量中的应用以及缩点技巧 按照老规矩, 先上两道模板题 【模板】强连通分量 【模板】割点（割顶） 割点割边 一, 离散数学中的定义: 割点: 无向连通图中，去掉一个顶点及和它相邻的所有边，图中的连通分量数增加，则该顶点称为割点。
割边: 无向联通图中，去掉一条边，图中的连通分量数增加，则这条边，称为割边。
二, Tarjan算法 优点: 想象一下如果用暴力法, 你会如何求解割点或者割边的数目呢?
最容易想到的当然是对于每一个点, 去掉它后对整个图dfs一遍, 看看连通分量是否增加, 若增加, 则这个去掉的点是割点, 对于割边也是一样的思路, 所以对于暴力法, 你需要`dfs``好多遍.
而使用Tarjan算法, 你只需要`dfs’一遍即可. 需要用到的数据结构: 这个算法需要用到好几个辅助数组, 下面我来详细介绍它们的作用
int dfn[MAXN];//用来记录一个顶点第一次被访问时的时间戳 int low[MAXN];//用来记录一个顶点不经过它的父亲顶点最高能访问到它的祖先节点中的最小时间戳, 通俗易懂的来说, 就是与结点i连接的所有点中dfn[]值最小的一个。 int cut[MAXN];//用来记录该点是否是割点, 因为一个割点可能多次被记录 //这是链式前向星, 用来存储边的一个数据结构 int head[MAXN], cnt; struct Edge { int to; int nxt; } e[MAXM]; 算法的主要流程: 1. 选定一个点作为根节点来进行dfs遍历, 但由于图可能不是连通图, 故外面要套一个for, 这可以理解吧 for (int i = 1; i &lt;= n; i++) { if (!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1ff250e796f732a8e9994419becea54f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5964ba4d950cf49382669e9e536c9cd8/" rel="bookmark">
			专题分纲目录 Android Framework 窗口子系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		专题分纲目录 均为索引，本纲为：Android Framework 窗口子系统 系列文章目录
Android Framework 窗口子系统 （01）WindowMangerService基础知识
Android Framework 窗口子系统 （02） 应用进程和WMS之间的关系
Android Framework 窗口子系统 （03） 窗口显示次序
Android Framework 窗口子系统 （04） 确定窗口尺寸
Android Framework 窗口子系统 （05）窗口布局说明
Android Framework 窗口子系统 （06）窗口动画之Choreographer机制
Android Framework 窗口子系统 （07）窗口动画之Animation &amp; Animator
Android Framework 窗口子系统 （08）窗口动画之动画系统框架
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f759afe56061348552200cccc07540ad/" rel="bookmark">
			专题分纲目录 Android Framework 包管理子系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		专题分纲目录 均为索引，本纲为：Android Framework 包管理子系统 系列文章目录
Android Framework 包管理子系统（01）PackageManagerService启动分析
Android Framework 包管理子系统（02）PackageManagerService关键文件解读
Android Framework 包管理子系统（03）应用安装
Android Framework 包管理子系统（04）应用卸载
Android Framework 包管理子系统（05）intent查询组件
Android Framework 包管理子系统（06）解读installd
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf524f974729c4795450afc500380435/" rel="bookmark">
			单相桥式全控整流电路
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		单相全控桥式带电阻负载时的电路
■带电阻负载的工作情况 ◆电路分析
☞闸管VT1和VT4组成一对桥臂，VT2和VT3组成另一对桥臂。
☞在u2正半周（即a点电位高于b点电位） √若4个晶闸管均不导通，id=0,ud=0,
VT1、VT4串联承受电压u2。
√在触发角a处给VT1和VT4加触发 脉冲，VT1和VT4即导通，电流从电源a端经VT1、R、VT4流回电源b端。 ☞当u2过零时，流经晶闸管的电流也降到零，VT1和VT4关断。 ☞在u2负半周，仍在触发角a处触发VT2和VT3，VT2和VT3导通，电流从电源b端流出，经VT3、R、VT2流回电源a端。 ☞到u2过零时，电流又降为零，VT2和VT3关断。 ◆基本数量关系
☞晶闸管承受的最大正向电压和反向电压分别为和。
☞整流电压平均值为：
α=0时，Ud= Ud0=0.9U2。α=180°时，Ud=0。可见，α角的移相范围为180°。
☞向负载输出的直流电流平均值为：
☞流过晶闸管的电流平均值 ：
☞流过晶闸管的电流有效值为： ☞变压器二次侧电流有效值I2与输出直流电流有效值I相等：
可见：
☞不考虑变压器的损耗时，要求变压器的容量为S=U2I2。
单相桥式全控整流电流带阻感负载时的电路
单相桥式全控整流电流带阻感负载时的波形
■带阻感负载的工作情况 ◆电路分析
☞在u2正半周期 √触发角a处给晶闸管VT1和VT4加触发脉冲使其开通，ud=u2。
√负载电感很大，id不能突变且波形近似为一条水平线。
☞u2过零变负时，由于电感的作用晶闸管VT1和VT4中仍流过电流id，并不关断。 ☞wt=p+a时刻，触发VT2和VT3，VT2和VT3导通，u2通过VT2和VT3分别向VT1和VT4施加反压使VT1和VT4关断，流过VT1和VT4的电流迅速转移到VT2和VT3上，此过程称为换相，亦称换流。 ◆基本数量关系
☞整流电压平均值为：
当a=0时，Ud0=0.9U2。a=90°时，Ud=0。晶闸管移相范围为90°。
☞晶闸管承受的最大正反向电压均为。 ☞晶闸管导通角q与a无关，均为180°，其电流平均值和有效值分别为：和 。 ☞变压器二次侧电流i2的波形为正负各180°的矩形波，其相位由a角决定，有效值I2=Id。
单相桥式全控整流电路接反电动势—电阻负载时的电路
单相桥式全控整流电路接反电动势—电阻负载时的波形
■带反电动势负载时的工作情况 ◆当负载为蓄电池、直流电动机的电枢（忽略其中的电感）等时，负载可看成一个直流电压源，对于整流电路，它们就是反电动势负载。 ◆电路分析
☞|u2|&gt;E时，才有晶闸管承受正电压，有导通的可能。 ☞晶闸管导通之后，ud=u2，，直至|u2|=E，id即降至0使得晶闸管关断，此后ud=E。 ☞与电阻负载时相比，晶闸管提前了电角度d停止导电，d称为停止导电角。
☞当a&lt;d时，触发脉冲到来时，晶闸管承受负电压，不可能导通。
☞触发脉冲有足够的宽度，保证当wt=d时刻有晶闸管开始承受正电压时，触发脉冲仍然存在。这样，相当于触发角被推迟为d。
☞在a角相同时，整流输出电压比电阻负载时大。
◆电流断续
☞id波形在一周期内有部分时间为0的情况，称为电流断续。 ☞负载为直流电动机时，如果出现电流断续，则电动机的机械特性将很软。
☞为了克服此缺点，一般在主电路中直流输出侧串联一个平波电抗器。
☞电感量足够大使电流连续，晶闸管每次导通180°，这时整流电压ud的波形和负载电流id的波形与电感负载电流连续时的波形相同，ud的计算公式亦一样。 ☞为保证电流连续所需的电感量L可由下式求出：
单相桥式全控整流电路带反电动势负载串平波电抗器，电流连续的临界情况
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad58eeb9533c0d91760d8203b6521197/" rel="bookmark">
			神经网络AlexNet训练CIFAR数据集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AlexNet神经网络结构
第一幅图的网络结构可以简化为第二幅图的网络结构。（但是，我没有算出和上图一样的特征图大小来，欢迎大佬指教）。
import torch from torch import nn import torch.nn.functional as F import numpy as np from torch.autograd import Variable from torchvision.datasets import CIFAR10 from torchvision import transforms from utils import train # CIFAR10中的数据是32*32*3大小的 # 定义AlexNet class AlexNet(nn.Module): def __init__(self): super().__init__() # 第一层是5*5的卷积，输入的channels是3，输出的channels # 是64，步长是1，没有padding self.conv1 = nn.Sequential( nn.Conv2d(3, 64, 5), nn.ReLU(True) ) # 第二层是3*3的池化，步长是2，没有padding self.max_pool1 = nn.MaxPool2d(3, 2) # 第三层是5*5的卷积，输入的channels是64，输出的 # channels是64，步长是1，没有padding self.conv2 = nn.Sequential( nn.Conv2d(64, 64, 5, 1), nn.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ad58eeb9533c0d91760d8203b6521197/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b75c9fb81144199e74d27331d527a239/" rel="bookmark">
			Telnet实验验证（详解）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Telnet实验 一、实验环境 本实验在华为模拟器完成
二、网络拓扑图 三、地址分配 注：在此实验中，将路由器配置为Telnet服务器，用路由器实现远程的登录访问
配置Telnet服务器的IP地址
上面的截图中表示配置Telnet的GE0/0/0接口的IP地址设置为192.168.1.2，子网掩码为24位，GE0/0/1接口的IP地址为192.168.2.1，子网掩码为24位
配置R2路由器的IP地址
上面的截图表示配置路由器R2的GE0/0/0接口的IP地址为192.168.1.1，子网掩码为24位。
配置R3路由器的IP地址
上面的截图表示配置路由器R2的GE0/0/0接口的IP地址为192.168.3.，子网掩码为24位。
四、路由器实现远程登录 注：华为模拟器中的普通的PC机无法实现远程登录Telnet服务器，所以只能使用路由器或者交换机来实现远程登录，原则上来说远程登录telnet服务器一共有三种方式，方式一表示的是无需验证，直接可以登录，方式二表示的是使用password实现远程登录，方式三表示的是aaa的方式，需要提供账号和密码。
配置telnet服务器：
由上图可知，telnet服务器所依托的路由器本身已经开启了telnet服务，所以当时用telnet server enable时会显示错误
user-interface 表示进入虚拟终端，vty表示其他主机用telnet远程进入到你telnet服务器的界面，最多有五个，所以说可以vty 0 vty 1 vty… vty 4五台机器最多可以允许五个人同时在线进到telnet服务器里去配置命令的。vty0 4 就是说把这五个界面一起配置。
方式一、无需验证直接登录 由配置的截图可知远程登录的方式一共有两种，分别是aaa远程登录方式，password远程登录方式，而不存在无需验证直接登录的方式，下面验证方式一的可行性：
由上述的截图可知方式一在华为模拟器中无法使用
方式二、password方式 下面表示配置telnet服务器：
上述截图中的user-interface vty 0 4 命令已经在前面介绍，authentication-mode password表示启用的远程登录的方式为password形式，在这里设置的远程登录密码为：wang
user privilege level 3 表示启用的远程登录用户等级为3级，下面介绍一下远程登录等级的含义：
level 0：表示参观模式，在远程登录telnet服务器时可以使用的命令有：
ping、tracert、telnet、rsh、super、language-mode、display、quitlevel 1：表示监控模式，在远程登录telnet服务器时可以使用的命令有：
0级命令、msdp-tracert、mtracert、reboot、reset、send、terminal、undo、upgrade、debugginglevel 2：表示系统模式，在远程登录telnet服务器时可以使用的命令有：
所有的配置的命令（管理级的命令除外）和level 0 和level 1的命令*level 3：可以执行所有的命令 路由器R2实现远程登录：
在上述的截图中，telnet 192.168.1.2 表示路由器R2请求远程登录telent服务器，由下面的password可知需要输入密码才能实现远程登录，当输入完成之后，由可以远程登录telnet服务器成功
路由器R3实现远程登录：
由上图可知，路由器R3实现了远程登录
下面验证特殊的情况，当我们在telnet服务器上加上访问控制列表时的情况分析：
情况一、 在Telnet服务器的G0/0/0端口加上访问控制列表，阻止路由器R2来访问telnet服务器
上述的截图表示创建了一个编号为3001的扩展访问控制列表
rule 1 deny tcp source 192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b75c9fb81144199e74d27331d527a239/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31167793a3b983c2bf6f6dbefd9eae13/" rel="bookmark">
			使用python-opencv获取视频数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import cv2 if __name__ == "__main__": video_name = "video.ts" vc = cv2.VideoCapture(video_name) # 读入视频文件 video_len = int(vc.get(cv2.CAP_PROP_FRAME_COUNT)) # 视频总帧数 video_width = int(vc.get(cv2.CAP_PROP_FRAME_WIDTH)) # 视频宽度 video_height = int(vc.get(cv2.CAP_PROP_FRAME_HEIGHT)) # 视频高度 video_fps = int(vc.get(cv2.CAP_PROP_FPS)) # 视频帧率 print(video_len, video_width, video_height, video_fps) if vc.isOpened(): # 判断是否正常打开 rval, frame = vc.read() else: rval = False ind = 1 timeF = 1 # 视频帧计数间隔频率 while rval: # 循环读取视频帧 rval, frame = vc.read() if (ind % timeF == 0): # 每隔timeF帧进行存储操作 cv2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/31167793a3b983c2bf6f6dbefd9eae13/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d189b6f417771b59482f7cb1e99f3b7f/" rel="bookmark">
			【Game Engine】第一节：搭建VS2019&#43;QT5.14环境&amp;&amp;第一个openGL程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		序言 参考youtube教程：Game Engine Development
视频教程中为vs2012+qt4，本文改动将会注明
准备环境 下载QT5.14，安装MSVC2017，进入安装目录 \Qt5.14.1\5.14.1\msvc2017 （下称QT目录）安装Visual Studio 2019 （或2017）下载glew，安装目录 \glew-2.1.0 （下称GLEW目录） 环境目录 myGameEngine einginesandboxMiddleware glew binlibinclude QT binlibinclude 环境配置 将QT目录下的include内容拷贝到QT\include将QT目录下的lib目录中拷贝Qt5Cored.lib Qt5OpenGLd.lib Qt5Widgetsd.lib 到 QT\lib将QT目录下的bin目录中对应Qt5Cored.dll Qt5OpenGLd.dll Qt5Widgetsd.dll 到 QT\bin将GLEW目录下的include目录内容拷贝到glew\include将GLEW目录下的lib目录中glew32.lib拷贝到glew\lib将GLEW目录下的bin目录中glew32.dll拷贝到glew\bin 项目配置 配置sandbox中的包含库目录 附加依赖目录 为对应目录加入lib文件到附加依赖项 注：另外加入OpenGL32.lib 否则LINK报错 程序编写 测试环境 //sandbox.cpp #include &lt;QtWidgets/qapplication.h&gt; int main(int argc, char* argv[]) { QApplication Application(argc, argv); return Application.exec(); } 注意： 编译成功运行时会提示缺少dll文件，暂时将所缺少的dll拷贝到debug目录中。 创建QtWidget //sandbox.cpp #include &lt;QtWidgets/qapplication.h&gt; #include &lt;QtWidgets/qwidget.h&gt; int main(int argc, char* argv[]) { QApplication Application(argc, argv); qWidget myGlWidget; myGlWidget.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d189b6f417771b59482f7cb1e99f3b7f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54d2985bda7f602123dbb4b1d9cb24e4/" rel="bookmark">
			19.Veeam B&amp;R 19 DiskSpd模拟磁盘操作测试性能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		请注意，与所有综合基准测试一样，实际结果可能会有所不同。
DiskSpd是Microsoft的Windows，Windows Server和Cloud Server Infrastructure工程团队的一种存储性能工具，将强大，精细的IO工作负载定义与灵活的运行时和输出选项结合在一起，为合成存储子系统的测试和验证创建了理想的工具。
官方地址：https://github.com/Microsoft/diskspd
diskspd命令语法：
diskspd [options] target1 [ target2 [ target3 …] ]
Target 目标 (可以指定多个目标来模拟同时运行多个作业。)
– 指定盘符上的文件：d:\testfile.dat
– 在CIFS文件/SMB共享：\fileserver\share\testfile.dat
– NFS共享上的文件：N:\testfile.dat
– 磁盘：#X 其中X是数字磁盘管理中的磁盘。在这种模式下diskspd直接从磁盘读取或写入磁盘（“RAW”），因此会对磁盘数据造成影响。-b 指定读取或写入操作的Block size块大小。此项与存储优化选项Storage Optimization设置有关；它将在一定情况之下影响磁盘读写性能；默认值建议为512K =&gt; Local target 1MB。-c 指定需要为测试创建的File size文件大小-d 指定测试的持续时间。默认情况下，它会进行5秒的预热(不收集统计数据)，然后再进程10秒的测试。通常指定为 600秒。-Sh 禁用Windows和硬件缓存，此标记必须始终设置。Veeam Agent始终明确禁用I/O操作的缓存以提高可靠性，即使这会导致速度降低。 diskspd常见用法：
Active full or forward incremental 主动完整备份或永久增量
diskspd.exe -c1G -b512K -w100 -Sh -d600 D:\testfile.dat -w100 表示100％写入和0％读取。默认情况下使用顺序I / O。
Reverse incremental 反向增量
diskspd.exe -c1G -b512K -w67 -r4K -Sh -d600 D:\testfile.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/54d2985bda7f602123dbb4b1d9cb24e4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0daf1166f530d8266ac4708e4e36515/" rel="bookmark">
			antd&#43;moment.js限制rangePicker组件可选择的日期范围
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		经常遇到开始结束日期【不能选当前系统时间之前/之后的】、【只能选今天~今天之前/之后xx天的】的需求。
以下用 只能选【今天~往前追溯90天】内，（今天也可选）为例： import { DatePicker } from 'antd'; import moment from "moment"; const { RangePicker } = DatePicker; // 规定不可选的 日期范围 const rangePickerDisabledDate = current =&gt; { // 不能选今天以后，只能选【今天~往前追溯90天】内，今天可选。 let result = false; if (current) { if (current &lt; moment().subtract(90, "days") || current &gt; moment().endOf("day")) { result = true; } else { result = false; } } return result; }; // 规定不可选的 时分秒范围 const rangePickerDisabledTime = (_, type) =&gt; { if (type === 'start') { return { disabledHours: () =&gt; range(0, 60).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c0daf1166f530d8266ac4708e4e36515/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd3a1527dfe9f8e2cb1b679b77abda8b/" rel="bookmark">
			uniapp更好的下拉刷新动画
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原生的uniapp的下拉刷新是一个普通的加载框
样式真的很单一。后来手动改成了一个gif图片
才算满意一些。但是现在又有更好的加载样式了。
这种体验就更好了。
真的原生app接近了一些。不过这个效果在安卓机上能显示出来。在苹果手机上还是一个加载的loading
接下来把代码奉上。
第一步：在pages.json 里面加下图的一句话。然后刷新页面之后只要往下拉。这个动画出就出了。
{ "path": "pages/shop/home", //vue商城首页 "style": { "navigationBarTitleText": "商城首页", "navigationBarBackgroundColor": "#56D5FF", "enablePullDownRefresh": true, "app-plus": { } } }, 第二步。此时动画有了可是不能及时的收回。所以要在当前页面做一些其它的配置让体验更好一些。
onLoad(){ //1.刚进入页面的时候就加载这个动画 uni.startPullDownRefresh(); }, // 2.下拉刷新 onPullDownRefresh() { console.log('refresh'); setTimeout(function () { uni.stopPullDownRefresh(); // 这里放刷新数据的方法 }, 1000); }, 第三步。默认下拉的动画圈圈是绿色的。如果不喜欢可以更改。
还是要在pages.json里面的进行一个简单的配置。
{ "path": "pages/shop/home", //vue商城首页 "style": { "navigationBarTitleText": "商城首页", "navigationBarBackgroundColor": "#56D5FF", "enablePullDownRefresh": true, "app-plus": { "pullToRefresh": { "support": true, "color": "#000000", //小圈圈的颜色 "style": "circle" //小圈圈的样式 } } } }, 这样一个简单的体验很好的下拉框就做好了。 如果有帮到你。请点一个赞支持一下。后续还有更多好玩的。。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dd3a1527dfe9f8e2cb1b679b77abda8b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74e2dddbb5b0f8f63cbf3afd145845da/" rel="bookmark">
			Apache服务配置与LAMP部署以及服务管理优化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Apache服务配置与LAMP部署以及服务管理优化 一、LAMP部署 1.linux系统基本环境 修改计算机名称 配置网卡IP地址 搭建DNS 关闭selinux
注意：检查httpd的rpm包是否安装，如果已经安装需要卸载后源码安装（最好是源码安装）
2.安装配置apache（就是httpd） 上传httpd源码包，并解压到/usr/src目录
源码编译安装：./configure --prefix=/usr/local/httpd --enable-so --enable-rewrite --enable-charset-lite --enable-cgi
然后执行make &amp;&amp; make install编译安装（没有报错就是正确的）
到/usr/local/bin目录下查看是否生成脚本文件（如果没有说明编译安装失败，重新安装）
补充：优化执行路径：
ln -s /usr/local/httpd/bin/* /usr/local/bin（创建生成编译安装的httpd下的bin目录下所有软链接）
PATH=$PATH:/usr/local/httpd/bin/
注意：检查确认安装以及创建链接结果如下说明安装成功
修改配置文件httpd：vim /usr/local/httpd/conf/httpd.conf
修改服务名字
cp /usr/lcoal/httpd/bin/apachectl /etc/init.d/httpd（把脚本添加到该目录下，可以使用service命令启动服务）
修改配置文件/etc/init.d/httpd
添加——chkconfig: 35 85 15（35级别启动、开机时第85项启动、关机时第15项关闭）
1.chkconfig --add httpd（添加httpd服务） 2.chkconfig httpd on/off 3.service httpd start/stop
测试是否成功
3、安装PHP环境 安装zlib提供数据压缩用的函式库和安装libxml2是一个xml的c语言版的解析器
上传安装源码包libmcrypt、mhash、mcrypt（注意按照顺序安装）
安装源码包libmcrypt
tar zxf libmcrypt-2.5.8.tar.gz 》cd libmcrypt-2.5.8 》./configure》make &amp;&amp; make install
创建软链接可以简便使用命令：ln -s /usr/local/lib/libmcrypt* /usr/lib/
安装源码包mhash
tar zxf mhash-0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/74e2dddbb5b0f8f63cbf3afd145845da/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41cb633d9a5eaa1224ab6108702dba88/" rel="bookmark">
			服务器安装jupyter notebook
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 安装jupyter并配置
pip install jupyter jupyter notebook --generate-config # 生成配置文件 生成配置文件后会显示配置文件生成路径 在该用户的家目录下的.jupyter文件夹中
vi ~/.jupyter/jupyter_notebook_config.py # 编辑配置文件 将下面的文件修改为对应的值
c.NotebookApp.ip = '0.0.0.0'​​​​​​​ c.NotebookApp.open_browser = False # 默认启动成功会打开浏览器。服务器只有命令行关闭就可以了。 c.NotebookApp.port = 8888 # 开放的端口号 c.NotebookApp.notebook_dir = '/home/zbuter/' # 随便设置一个当前用户有权限的目录就可以 设置访问密码
jupyter notebook password 启动命令
jupyter notebook 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3554fd7e9afcb4e3e75ffdf23e17d829/" rel="bookmark">
			（四）tensorflow2.0 - 实战稀疏自动编码器SAE
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前文已经介绍完了tensorflow2.0自定义layer、model、loss function，本文将结合前述知识，搭建一个稀疏自动编码器SAE。
（一）tensorflow2.0 - 自定义layer
（二）tensorflow2.0 - 自定义Model
（三）tensorflow2.0 - 自定义loss function（损失函数）
（四）tensorflow2.0 - 实战稀疏自动编码器SAE
先简单介绍稀疏自动编码器SAE，其架构如下图所示（图源网络，侵删），三层结构，输出层应尽量和输入层接近，其重点在于中间的隐藏层，隐藏层将数据进行了重新编码，这样做的目的是获得输入数据更好的数据表示。在普通自动编码器中，往往要求隐藏层元素个数要比输入层元素个数少，但是稀疏自动编码器的要求不同，它可以允许隐藏层元素比输入层元素多，但是要保证稀疏性，即大多数隐藏层节点的输出值为0。
而SAE的损失函数，则为：
第一部分为预测值与真实值的SAE，第二部分为对权重的惩罚项，第三部分ρ和ρ帽分别代表期望的稀疏度和实际的稀疏度。
下面放上代码：
import tensorflow as tf import numpy as np import pandas as pd from tensorflow.keras import * import tensorflow.keras.backend as kb import sys import matplotlib.pyplot as plt # 输入输出为16 × 1的列表 # inputList为输入列表 def SAEFC(inputList): inputList = np.array(inputList) # 输入特征个数 inputFeatureNum = len(inputList[0]) # 隐藏层参数个数：输入特征3倍 hiddenNum = 3 * inputFeatureNum # 稀疏度(密度) density = 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3554fd7e9afcb4e3e75ffdf23e17d829/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c00b93c9ff340239b4570191f4d35f3c/" rel="bookmark">
			12小时上线“新冠肺炎同程查询工具”，开发者这样狙击疫情
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		阿里妹导读：2020开年极为复杂。面对新型肺炎的疫情，我们每一个人都与国家命运紧密相连。全社会的力量都凝聚在一起，众志成城，共克时艰。有这么一群热爱代码的人，用自己的方式提升效率，保卫家园。
“扩散!急寻这235个车次、航班同行人” “紧急寻人!急寻Z264、Z265列车同行人!” “急寻同行旅客,这趟到琼海的动车发现确诊患者”
……
新型肺炎潜伏期长则14天，春运高峰大大增加了疫情防控难度。一条条跳动在新闻上的患者同行信息，就是一个个防控疫情的关键节点。
狙击疫情，必须分秒必争！
信息不断更新，来源多样繁杂，如何让人们快速确认是否与新型肺炎确诊患者同行，从而迅速进行诊断和隔离？1月27日，一款由几位开发者从上午11点紧急开发，到晚上11点已在朋友圈传播的“新型肺炎同程查询工具”就已上线——输入日期、车次以及地区，即可查询是否与已披露的确诊患者同行。
网站：http://2019ncov.nosugartech.com/
“有人是医务人员，所以他们去了；有人是警察，所以他们去了。我们是工程师，我们可以用自己的技能做一些力所能及的小事，希望可以帮到大家”。今天，阿里妹采访到成都无糖信息技术有限公司联合创始人兼CTO，也是工具的开发者童永鳌。在他的故事里，我们看到了中国开发者的力量。
童永鳌在办公 工具上线后，累计访问量已突破3500万次，并获得人民日报的点赞转发。
做力所能及的小事，帮助大家共度难关
阿里妹：能否简单介绍新冠病毒确诊患者同程查询工具的开发初衷？
童永鳌：最开始的原因很单纯，就我自己有查询需求。我们日常接触到的疫情信息里包含寻找患者的同程者这块内容一般就是以图片为载体，一张图罗列了患者曾经搭乘过的交通工具、车次、日期等信息。通过图片逐条查找信息，一来是有可能看漏信息，二来是查找起来确实不太方便，每次都要从头查找。
作为一个程序员，我比较“懒”，一条条的去翻历史记录很麻烦，于是就想到把数据抠下来，用搜索工具去查找更加方便。
阿里妹：工具开发团队是如何在短时间内建立起来的，团队里都是志愿者吗？
童永鳌：最初的团队成员都是我自己认识十多年的老网友。我们原本就在一个群里，平时会闲聊。我看到央视的新闻之后，就在群里说了想要做个工具的想法。他们也非常支持，就直接开始做。团队中还有一个人是我公司的，因为工具需要运行维护，我就把公司的运维主管拉进来。也考虑过志愿者，但如果一开始公开招募的话，整个周期会很长。
最开始我画了一张简单的布局图丢到群里，把前端、后端、数据收集的工作安排出去就立马开始干活了。其实是一种很简单、粗暴的方式。后面陆续加入一些志愿者，他们看到工具之后，通过邮件的方式联系，并加入我们。我们再把这些志愿者拉到群里，他们协助我们收集整理数据。
最初大家在群里讨论工具时手画的简单原型图
阿里妹：能否分享一下查询工具最开始的设计思路？
童永鳌：工具本身用到的技术比较简单。先把网上现有的图片和文字内容统一做信息整合，放到数据库中。然后再做一个检索工具，就成了现在大家看到的样子。
一开始并没有想太多，总体思路很直接。有想法之后就立刻开始动手搭建网页。先是在网上查找公开的信息，交通工具就包含：火车、飞机、公交车、出租车等。所以，初步设计数据库中可能用到的这些字段。
接下来就是考虑用户可能会用什么方式来查询，查询的关键词等。我就把自己当成用户，假设自己使用这个工具的话，我需要查些什么？我想到的第一点是日期，先查询我哪天乘坐交通工具。第二点就是贴合车次做具体检索。另外是地区搜索，如果用户在某个位置，那么这个地区的火车、飞机等是否存在已确诊患者。
前面两点是后台数据库设计，最后就是界面设计。考虑完这两个设计，就直接开始动手做了。
阿里妹：从开始到工具上线过程大概用了多少时间？上线后有哪些工作要做？
童永鳌：开发大概用了半天，1月27日 上午11点左右有了这个想法，下午5点左右，功能上基本就已经做好了。后来又花了6个小时整理数据，晚上11点就发朋友圈了。
后期维护上花费的时间比较多，团队成员每天都会花17个小时甚至更久来维护，这几天大家基本上早上9点到晚上2点都在工作。刚开始确实没想到数据会突然增多，信息量大了之后我们就要做一些功能上的加强，比如：处理数据流畅机制、改动代码以及回复网友邮件等。事情多又相对比较杂，但是每一件事情都必须仔细对待。
阿里妹：开发和维护的过程中遇到过哪些挑战？
童永鳌：最大的挑战来自于数据整理。这个工具在初版的时候，用到的数据是央视整理过的，数据是现成的，整理起来相对容易些。后期信息量越来越大，整理信息的难度也越来越大。现在我们也会靠自己去筛选信息。一方面通过爬虫做信息初筛，另一方面靠网友给我们反馈信息。我们会要求网友提供链接，把链接批量爬虫回来后，从链接中做一些信息提取的工作。从目前的数据来看，爬虫来的信息和网友提供的信息大概是五五分。
另外一个挑战来自于访问量的暴涨，完全没想到访问量会这么大。第二天访问量开始暴增的时候，最开始的版本架构就扛不住了。
阿里妹：能简单说下访问量的增长过程吗？面对流量暴涨，是怎么扛过去的？
童永鳌：1月28号是上线第二天，访问总量是450万。第二天晚上八点开始就是一个几何级数的增长，从一个小时10万访问量跳到300万。29号和30号总量在2000万左右。
最开始用的是的朋友的服务器，一兆带宽1G内存。上线第一天，因为配置太低，无法容纳100人同时在线的访问量。后来就直接调用第三方的CDN，我们嵌入远程资源，就不用自己扛资源访问的这一块流量。但随着访问量越来越高，我们发现单台服务器要扛千万级的流量很难做。
于是我们取了个巧，把页面和数据文件生成静态的。相当于把库里的数据生成一个静态的文件，再把页面和数据都放到阿里云的OSS上面。让阿里云的OSS对象存储去扛住高并发、高流量，我们自己就不用担心流量压力了。
阿里妹：需要录入的信息大概多少？如何确保数据的准确性？
童永鳌：总量在500-600条左右。最早的信息是100多条，现在已录入300多条。后端还没录入的信息大概还有250-300条左右，待录入的信息中包括重复的。
数据确认是一个漏斗状的筛选过程。网上搜集来的信息经过验证、去重后会越来越少。数据量大的时候用自动化方式采集，数据量小就可以直接通过人工采集。在审核步骤上大概过程是：初始线索 -&gt; 网友整理 -&gt; 内部人员整理（核实纠正普遍性错误）-&gt; 内部人员录入（核实单条错误）-&gt; 提交（审核单条错误）-&gt; 复查（有原文链接失效或新闻报道后续修改的情况）。
后来人民日报推送工具的时候，他们帮我们重新把数据认真地再审核一遍。
对于信息我们会逐层把关，越到后面关键的步骤，数据把关人越少越好。人越多的话，犯错的可能性也随着增大。而且中间涉及到一个信任问题，特别是后面的审核的这个步骤，除了我最信任的朋友和公司的制作人，没让其他人介入。
在时间上，现在录入速度没有之前那么快了。因为我们对数据的准确性要求越来越严格，需要花大量的时间去核实。对我们来说，及时性排第二位，准确性才是第一位。
阿里妹：对工具的性能会做什么改进吗？
童永鳌：现阶段最主要的还是后端数据，首先是准确性，其次是及时性。功能上并没有打算把它复杂化。如果有些新想法，可能会单独去做尝试。
当然，还是希望疫情能够早点结束，就不用考虑这些啦。
阿里妹：接下来会迎来一个返程高峰，有没有大流量的预备方案？
童永鳌：我们现在已经不太担心高并发、大流量的问题了，主要是对数据的准确性要求更高。我们自己现在录入做数据的时候，感觉已经有点强迫症了，精神高度紧张，生怕敲了一个数字，需要反复确认。
阿里妹：这次疫情来势凶猛，你认为开发者的参与对于阻止疫情的蔓延起到了哪些帮助？
童永鳌：这个比较难判断。假设我是工具的使用者，我也只是做个查询确认而已。至于它对疫情起到多大的帮助，我感觉不出来。我觉得医生是最有帮助的，而工具能够给大家提供一定的参考意义，我觉得就足够了。
这两天也收到一些网友的邮件，有的很简单，就四个字：谢谢你们。看着其实很暖心。
阿里妹：作为一个老开发者，有没有什么建议可以分享给同行？
童永鳌：这几天也没有时间、精力想太多。我想，对于程序员来说，写代码不能当成一份工作，应该当它是一个工具。从这个角度，很容易想到做疫情同乘者查询工具，因为我只是拿一个编程语言来解决我自己想解决的生活中的问题而已，并不是说我要做一个什么项目，从产品角度去考虑这件事。
对开发者来说，建议他们尝试把编程变成了解决日常生活需求的一个东西，而不是单纯地看成工作去对待，可能就会有更多的东西好出来。
共抗疫情，我们能赢
“能做事的做事，能发声的发声。有一分热，发一分光。”疫情没有旁观者。感谢开发者们用科技的力量点亮星光。
在新型肺炎同程查询工具之外，阿里妹还看到了，GitHub上的「wuhan2020」防疫信息收集平台，以及目前还在征集开发者的外来人员登记系统、消毒检查登记系统、学生健康报备管理系统、违纪举报系统、物资管理系统等项目。
我们诚挚邀请所有开发者集思广益，如果你有能帮助到战胜疫情的小工具、好想法，欢迎在下方留言。共抗疫情，我们能赢！
相关阅读
点击下方图片即可阅读
@武汉人民，请收好这份名单
驰援武汉，就这么干了！
关注「阿里技术」
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c00b93c9ff340239b4570191f4d35f3c/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/251/">«</a>
	<span class="pagination__item pagination__item--current">252/321</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/253/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>