<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大白的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程大白的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcdabai.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大白的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大白的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大白的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e060db7fd824d31559972c235726156/" rel="bookmark">
			js函数柯里化详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、什么是函数柯里化
函数柯里化就是我们给一个函数传入一部分参数，此时就会返回一个函数来接收剩余的参数。
二、简单的柯里化的实现
没有柯里化实现的案例
将其转化为柯里化的案例
上述代码可简写为
三、函数柯里化的好处
我们希望处理函数时，希望函数功能尽可能单一。如下面代码所示，我们希望第一个参数+2,第二个参数*2,第三个参数** 2,最后再相加，此时我们可以使用函数的柯里化。
四、自动柯里化
function myCurried(fn) { return function curry(...args1) { if (args1.length &gt;= fn.length) { return fn.call(null, ...args1) } else { return function (...args2) { return curry.apply(null, [...args1, ...args2]) } } } } function sum(a, b, c, d, e) { return a + b + c + d + e } let resFunc = myCurried(sum) console.log(resFunc(1,3,4)(1)(23)) //解析: //1、这里的fn.length获取的是函数传入参数的长度 //2、这里使用递归的思想 ``` 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c77cceacae84ca49e640b5769cc579cd/" rel="bookmark">
			Hello Git（九）——GitLab CI持续集成
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、CI持续集成简介 1、CI持续集成简介 CI（Continuous Integration），即持续集成，是一种可以增加项目可见性、降低项目失败风险的开发实践，其目的在于让产品快速迭代的同时，尽可能保持高质量。每次集成都通过自动化的构建（包括编译、发布、自动化测试)来验证，从而尽快地发现集成错误，只有通过自动测试的代码才能进行后续的交付和部署。
CI是团队成员间（产研测）更好地协调工作，更好的适应敏捷迭代开发，自动完成减少人工干预，保证每个时间点上团队成员提交的代码都能成功集成的，可以很好的用于对Android/iOS项目的打包。
2、持续集成的优点 A、快速发现错误
每完成一点更新，就集成到主干，可以快速发现错误，定位错误也比较容易。
B、防止分支大幅偏离主干
如果不是经常集成，主干又在不断更新，会导致以后集成的难度变大，甚至难以集成。
3、持续集成的原则 持续集成的原则包括：
A、需要版本控制软件保障团队成员提交的代码不会导致集成失败。
B、开发人员必须及时向版本控制库中提交代码，必须经常性地从版本控制库中更新代码到本地。
C、需要有专门的集成服务器来执行集成构建。根据项目的具体实际，集成构建可以被软件的修改来直接触发，也可以定时启动，如每半个小时构建一次。
D、必须保证构建的成功。如果构建失败，修复构建过程中的错误是优先级最高的工作。一旦修复，需要手动启动一次构建。
4、持续集成系统的组成 一个完整的构建系统必须包括：
A、一个自动构建过程，包括自动编译、分发、部署和测试等。
B、一个代码存储库，即需要版本控制软件来保障代码的可维护性，同时作为构建过程的素材库。
C、一个持续集成服务器。
二、CD持续交付、持续部署 持续交付（Continuous delivery）是频繁地将软件的新版本，交付给质量团队或者用户，以供评审。如果评审通过，代码就进入生产阶段。
持续部署（continuous deployment）是持续交付的下一步，是代码通过评审后，自动部署到生产环境。
三、GitLab-CI持续集成 1、GitLab-CI简介 GitLab-CI（GitLab Continuous Integration）是一套配合GitLab使用的持续集成系统（其它的持续集成系统同样可以配合GitLab使用，比如Jenkins），GitLab8.0以后的版本默认集成GitLab-CI并且启用。
GitLab CI是GitLab提供的持续集成服务，只要在仓库根目录创建一个.gitlab-ci.yml 文件， 并为工程指派一个Runner，当有合并请求或者 push的时候就会触发那么每一次合并请求（MR）或者push都会触发CI pipeline。
Pipelines是定义于.gitlab-ci.yml中的不同阶段的不同任务。
.gitlab-ci.yml文件定义GitLab runner要做哪些操作。 默认有3个[stages(阶段)]: build、test、deploy。
当build完成后(返回非零值)，会看到push的 commit或者合并请求前面出现一个绿色的对号。 方便开发者检查出来合并请求是否会导致build失败， 免去检查代码。
GitLab CI服务跑build测试， 开发者会很快得到反馈，知道自己提交的代码是否有BUG。
A、在仓库根目录创建一个名为.gitlab-ci.yml的文件
B、为工程配置一个Runner
每次push代码到Git仓库， Runner就会自动开始pipeline。
GitLab CI负责.gitlab-ci.yml脚本的解析，根据.gitlab-ci.yml脚本的规则，分配到各个Runner来运行相应的脚本script。
2、Runner脚本文件 .gitlab-ci.yml脚本文件必须用空格来缩进，不能用tab来缩进。
.gitlab-ci.yml脚本基本示例如下：
# 定义 stages stages: - build - test # 定义 job job1: stage: test script: - echo "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c77cceacae84ca49e640b5769cc579cd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6fdd51d89a43ae0a766f8e8f03ed9c60/" rel="bookmark">
			[java练习]三、数字三角形
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述： 上图给出了一个数字三角形。从三角形的顶部到底部有很多条不同的路径。对于每条路径，把路径上面的数加起来可以得到一个和，你的任务就是找到最大的和。
路径上的每一步只能从一个数走到下一层和它最近的左边的那个数或者右 边的那个数。此外，向左下走的次数与向右下走的次数相差不能超过 1。
输入与输出： 输入描述 输入的第一行包含一个整数 N(1 ≤N ≤100)N (1≤N≤100)，表示三角形的行数。
下面的 NN 行给出数字三角形。数字三角形上的数都是 0 至 100 之间的整数。
输出描述 输出一个整数，表示答案。
代码： package com.exc.dayfour; import java.util.Scanner; public class ex1 { public static void main(String[] args) { Scanner scan = new Scanner(System.in); //在此输入您的代码... int N=scan.nextInt(); int[][] arr=new int[N][N]; for(int i=0;i&lt;N;i++) { for (int j=0;j&lt;=i;j++) { arr[i][j]=scan.nextInt(); } } //创建一个二维数组存储输入数据数组相加规则的数据 int flag[][]=new int[N][N]; flag[0][0]=arr[0][0]; for(int i=1;i&lt;N;i++) { flag[i][0]=flag[i-1][0]+arr[i][0]; } for(int i=1;i&lt;N;i++) { for(int j=1;j&lt;=i;j++) { flag[i][j]=arr[i][j]+Math.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6fdd51d89a43ae0a766f8e8f03ed9c60/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c0febf07238f23877011faecb16488f/" rel="bookmark">
			Field xxService in com.xxx.server.controller.xxController required a bean of type
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		*************************** APPLICATION FAILED TO START *************************** Description: Field xxxService in com.xxx.server.controller.xxxController required a bean of type 'com.xxx.server.service.xxxService' that could not be found. The injection point has the following annotations: - @org.springframework.beans.factory.annotation.Autowired(required=true) Action: Consider defining a bean of type 'com.xxx.server.service.xxxService' in your configuration. 上述报错是因为在 service.impl服务实现层中缺少了 @Service
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eae327cb5546710b16a705d3a9aaf4b1/" rel="bookmark">
			预防死锁的方法以及死锁的检测与解除
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		3.6 预防死锁的方法 一、预防死锁 二、系统安全状态 三、利用银行家算法避免死锁 预防死锁和避免死锁这两种方法，实质上都是通过施加某些限制条件，来预防发生死锁： 两者的区别主要在于： 预防死锁：
施加的限制条件比较严格，往往会影响进程的并发执行。避免死锁：
施加的限制条件比较宽松，这给进程的运行提供了较为宽松的环境，有利于进程的并发执行。 一、预防死锁 产生死锁的必要条件 1、互斥条件2、请求和保持条件3、不剥夺条件4、环路等待条件 预防死锁的方法是使四个必要条件中的第2,3,4条件之一不能成立，来避免发生死锁。 必要条件1，因为它是由设备的固有条件所决定的，不仅不能改变，还应加以保证。 1、摒弃“请求和保持”条件 系统规定所有进程在开始运行之前，都必须一次性的申请其在整个运行过程中所需的全部资源。此时若系统有足够的资源就分配给该进程，该进程在运行期间不会提出资源要求，从而摒弃了“请求”条件。若系统没有足够的资源分配给它，就让该进程等待。因而也摒弃了“保持”条件，从而避免发生死锁。
优点：算法简单、易于实现且很安全。缺点：资源浪费严重和进程延迟运行。 2、摒弃“不剥夺”条件 系统规定，进程是逐个地提出对资源的要求的。当一个已经保持了某些资源的进程，提出新的要求不被满足时必须释放它已经保持的所有资源，待以后需要时再重新申请。从而摒弃了“不剥夺”条件。
某一进程已经占有的资源，在运行过程中会被暂时释放掉，认为是被剥夺了。实现起来比较复杂且付出很大代价。可能会前功尽弃，反复申请和释放等情况，延长了周转时间，增加系统开销。 与前两种策略比较，资源利用率和系统吞吐量都有较明显的改善。但也存在着严重问题： 1、为资源编号限制新设备的增加；2、进程使用设备顺序与申请顺序不同，浪费资源3、限制用户编程自由。 二、系统安全状态 在预防死锁的几种方法中，都施加了较强的限制条件；在避免死锁的方法中，所施加的限制条件较弱，又能获得令人满意的系统性能。
该方法中把系统的状态分为安全状态和不安全状态，只要能使系统始终都处于安全状态，便可避免发生死锁。
思路： 允许进程动态地申请资源，但在资源分配前，应先计算资源分配的安全性，若此次分配不会导致系统进入不安全状态，则将资源分配给进程，否则，令进程等待。
安全状态 1、是否可以找到一个进程推进执行的顺序，从而满足每一个进程资源的最大需求，如果能则系统安全，否则不安全。 T0时刻：可用的有3台，可以先分配给进程B2台，然后B可以执行，执行完成以后释放4台，加上可用的1台，再分配给A，A执行完成以后，释放全部资源10台，再拿出9台可以分配给C。所以系统存在一个合理的进程执行的推进顺序：B-A-C，因此在T0时刻系统是安全的。 2、T0以后，如果C再申请一台，那么剩下可用的还有两台，则这两台可以分配进程B，B执行完以后释放4台，此时A需要5台，C需要6台，进程A和C都不能继续执行，就无法进行分配，这样系统是不安全的。 三、利用银行家算法避免死锁 3、安全性算法 银行家算法例题 （1）判断T0时刻的安全性 1、初始时work= available，finish = FALSE 2、从进程集合中找到一个能够满足下列条件的进程： finish[i] = false, need[i,j] &lt;= work,则 P1，P3满足条件。 假设让P1先执行，从【3,3,2】中拿出【1,2,2】分配给P1，那么P1可以执行，执行完以后释放资源， 则work=【2,1,0】+【3,2,2】=【5,3,2】且finish[1] = true。 从P0,P2,P3,P4中找出满足finish[i] = false, need[i,j] &lt;= work的条件。 发现P3和P4满足条件，假设让P3先执行。 则从【5,3,2】中拿出【0,1,1】分配给P3，P3可以执行，执行完以后释放资源。 则work = 【5,3,2】+【2,1,1】=【7,4,3】，且finish[3] = TRUE。 依据该思路继续执行，直到所有进程全部完成！ 因为所有进程的finish=TRUE，说明系统是处于安全状态的 存在一个安全执行推进的进程序列{P1,P3,P4,P0,P2},所以系统在T0时刻是安全的。 （2）T0时刻P1请求资源发出请求向量Request1（1,0,2），系统能否分配给它？ 此时T0时刻新的资源分配表为 再利用安全性算法检查此时系统是否安全，如下所示： 由所进行的安全性检查可知，可以找到一个安全序列{P1,P3,P4,P0,P2},因此系统是安全的，可以立即将P1所申请的资源分配给它。 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eae327cb5546710b16a705d3a9aaf4b1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/083b4661dda7d1deb68537784a9eac76/" rel="bookmark">
			【保姆教学】obs结合bilibili直播姬在b站直播
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		obs结合bilibili直播姬在b站直播 文章目录 obs结合bilibili直播姬在b站直播1.下载obs2.下载直播姬(略过)3.obs配置3.1 首先添加一个`显示器采集`,选择新建即可3.2 选择`设置`3.3 选择`推流`3.4 配置服务 4.配置哔哩哔哩直播姬4.1 打开哔哩哔哩直播姬，选择`更多`4.2 选择`第三方推流`4.3 将`推流地址`和`推流码`填入obs4.3 obs选择`开始推流`，选区完成后就可以进行直播了 1.下载obs 下载地址： https://obsproject.com/zh-cn/download
2.下载直播姬(略过) 3.obs配置 3.1 首先添加一个显示器采集,选择新建即可 3.2 选择设置 3.3 选择推流 3.4 配置服务 服务和串流密匙根据哔哩哔哩直播姬提供填写(下面有哔哩哔哩直播姬教学)
4.配置哔哩哔哩直播姬 4.1 打开哔哩哔哩直播姬，选择更多 4.2 选择第三方推流 4.3 将推流地址和推流码填入obs 4.3 obs选择开始推流，选区完成后就可以进行直播了 最后笔者祝福大家都可以成为百万粉丝的主播(✿◠‿◠)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75aea12a9c5dd9255163b9c76d99b8b3/" rel="bookmark">
			H3C交换机s5500Web登录配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		打开交换机，交换机自检结束后提示用户键入回车，之后将出现命令行提示符
1、配置过程
system-view
[H3C]interface Vlan-interface 1（进入管理VLAN）
[H3C-Vlan-interface1]undo ip address（取消管理VLAN原地址）
[H3C-Vlan-interface1]ip address 192.168.1.10 255.255.255.0（配置管理VLAN的IP地址为192.168.1.10）
[H3C]ip http enable (启用WEB服务，默认可能已经启动)
[H3C]local-user admin (添加WEB登陆账号)
[H3C-luser-admin]service-type telnet(设置telnet权限)
[H3C-luser-admin]password simple admin(配置密码)
(上面配置的账号只有普通权限，需要配置超级管理密码才能对交换进行操作)
[H3C]super password level 3 cipher passw(设置超级密码为passw)
实用发现超级密码admin登陆不了，后官方查到可以升级admin级别，就可以了
authorization-attribute level 3
引用网页
关于级别，网上找来的，不知道对不对
1.LEVEL 0(访问级)。 可以执行用于网络诊断等功能的命令。包括ping、tracert、telnet等命令,执行该级别命令的结果不能被保存到配置文件中。
2.LEVEL 1(监控级)。 可以执行用于系统维护、业务故障诊断等功能的命令。包括debugging、terminal等命令,执行该级别命令的结果不能被保存到配置文件中。
3.LEVEL 2(系统级)。 可以执行用于业务配置的命令,主要包括路由等网络层次的命令,用于向用户提供网络服务。
4.LEVEL 3(管理级)。 最高级,可以运行所有命令:关系到系统的基本运行、系统支撑模块功能的命令,这些命令对业务提供支撑作用。包括文件系统、FTP、TFTP、XModem下载、用户管理命令、级别设置命令等。
退出超级终端
3、将网线连接pc与交换机以太网口，pc机ip设为192.168.1.x，在ie浏览器以192.168.1.10登录交换机管理程序，在登录窗口输入用户名/口令admin/admin即可进入S5500Web管理界面，在进入“管理“功能时将需要超级密码。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ccd0e1c43de0e65e8b82c4a0db9f1e2b/" rel="bookmark">
			Linux安装Redis后开启外网访问
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 把redis加入到防火墙的开放端口中
2. 如果阿里云的ECS, 还需要在安全组放开对应的6379端口
3. 更改redis.conf 文件
vim /etc/redis.conf
大概第70行左右
加 # 号注释掉这一样, 这一行意思是, 只能本机访问
大概第89行左右 protected-mode 模式改为no protected-mode no 4. 重启redis就可以了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cef099ad1804cf4f8bd57a649e01e33a/" rel="bookmark">
			解决Git问题fatal: refusing to merge unrelated histories
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决Git问题fatal: refusing to merge unrelated histories 一、fatal: refusing to merge unrelated histories 今天在创建远程仓库，关联远程仓库后pull下来的时候失败
λ git pull fatal: refusing to merge unrelated histories fatal: refusing to merge unrelated histories
这里的问题的关键在于：fatal: refusing to merge unrelated histories
你可能会在git pull或者git push中都有可能会遇到，因为这两个分支可能没有取得联系。那么怎么解决呢？
二、解决方案 在你操作命令后面加–allow-unrelated-histories
例如：
git pull origin master --allow-unrelated-histories Administrator/My-demo (master) $ git pull origin master --allow-unrelated-histories From gitee.com:tuogu/typescript-demo * branch master -&gt; FETCH_HEAD Merge made by the 'recursive' strategy. 如果你是git merge 报fatal: refusing to merge unrelated histories
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cef099ad1804cf4f8bd57a649e01e33a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/097d732cb8a4bcbe9da4eaad7f516388/" rel="bookmark">
			CentOS出现 login incorrect 输入密码无法登录？（绝对解决问题）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CentOS出现localhost login 输入密码无法登录？ 一、问题描述 当大家第一次登录Centos时，出现这种情况有三种原因。
原因1： 用户名错误，如果你设置了账户，你们账号就是你设置的那个名称。如果你没有设置账户，那么第一次登录时，你的账号名称应该是root
原因2： 在输入密码时，有的人习惯用电脑右侧最右边的小键盘输入密码，但是NumLock键默认是关闭的，所以我们要先打开，再输入密码。最好是用主键盘上的数字输入密码，不要用小键盘输入密码，这样就没问题了。
原因3： 有的人输出密码后会出现下面这个界面，其实这个界面就是表示你已经登录成功了。只是没有图形化界面，我们不知道已经登录成功了。没有图像化界面的原因是因为在安装Centos时没有选择安装图像化界面，默认只安装的基本配置。
从这里进去选更改设置：
注意：要选择GNOME Desktop才会有图形化界面，系统一般默认是选Minamal Insatll（这个没有图像化界面）。
还有一种情况是你的Centos镜像是Minamal，这种包是没有图像化界面的。如图
建议下载Centos DvD版，然后安装图像化界面就完成了。
这个镜像我放在百度网盘里面了，需要的同学自取。
百度网盘链接:
https://pan.baidu.com/s/1i10YeNYT81Eyl9X6xoox5A
提取码:5wb6
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e9211343cd59d06b377adec0325d1af/" rel="bookmark">
			DB Convert Studio,转换数据库结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DB Convert Studio,转换数据库结构 DB Convert Studio 被认为是一个强大的跨数据库迁移过程以及具有转换数据库结构以及位于不同数据库格式之间的数据的能力的同步软件。它能够将成熟的、表格以及久经考验的 DB Convert 以及 DB Sync Cores 与改进的现代 UX 设计相结合。它有能力支持流行的数据库，从最好的旧文件格式到内部部署的格式以及云数据库。它能够连接两个源以及目标数据库，然后可以为本地或远程 MS windows、Linux、Mac OS 和 BSD 的捆绑数据库服务器进行配置。DB Convert Studio 如何成为强大的跨数据平台迁移。
差异同步选择能够保持信息新鲜或数据库节点的来源和目的地。DB Convert Studio 能够结合旧的、安全的内核。这个惊人的程序允许用户和开发人员以几种方式迁移数据。用户可以从某些经过实战考验的情况中进行选择，如下所述：
Master为slave的迁移
DB Convert Studio单向同步
DB Convert Studio双向同步
最后但并非最不重要的数据供应
DBConvert Studio 强大的功能：
DB Convert Studio具有以下功能和属性，如下所述：
DB Convert Studio具有自动转换视图和查询的能力： DB Convert 具有创新的解析器，它能够提供一种非常高效且简单的跨数据库使用方法以及查询的转换。该软件能够轻松灵活地完全自动地转换 SQL 视图。用户无需学习 SQL 方言之间的差异以及语法。SQL的方言没有特殊的知识和差异。
使用三种同步类型同步用户数据： DB 同步工具能够通过更新、插入和删除同步功能来保持用户数据库最新。这三种类型是插入同步、更新同步和最后但并非最不重要的删除同步。
加快用户数据库迁移：迁移速度很大程度上取决于存在的不同因素，包括数据集大小的来源、特定计算机的性能以及输出设置等等。用户无需担心查找有关如何加快转换过程的提示的过程。该引擎能够在数百万条记录的帮助下处理大型数据库，这些记录高效而轻松。
无误地传输用户数据：在用户和开发人员开始转换过程之前检测潜在的转换过程以及问题。为了防止它更好地纠正它。该软件能够向用户显示关于数据库类型以及不一致的警告消息，以及关于用户表对象的潜在问题以及处理之前的关系的报告。某些错误可能会导致数据库目标发生冲突，只需轻轻一按对话问题的小型重新配置过程，即可轻松消除这些错误。用户无需担心二进制数据的安全性。转换器能够完成所有需要的工作。DB Convert 的应用具有支持二进制数据的能力。
为有条件的数据库迁移过程添加用户数据过滤器：它允许用户和开发人员在数据集成过滤器的帮助和指导下管理数据库转换过程。由于债务人的集成过滤器，用户可以更好地控制数据迁移过程。用户可以在开始该过程之前仅选择他需要的单个表、字段、索引、查询以及外键。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5dd19b6d003c86e5a5721bf1a3ae32a1/" rel="bookmark">
			【计算机网络】第一章 概述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		全文转载，只做整理方便复习。
三种交换方式：电路交换，分组交换，报文交换 电路交换
分组交换
三种交换方式的对比
计算机网络的定义和分类
计算机网络的定义
计算机网络分类
【计算机网络】性能指标，速率、带宽、吞吐量、时延、时延带宽积、往返时间、利用率、丢包率
比特
速率
带宽
吞吐量
时延
时延带宽积
往返时间
利用率
丢包率
体系结构，分层处理方法 常见的计算机网络体系结构
分层的必要性
分层处理方法
三种交换方式：电路交换，分组交换，报文交换 电路交换 电话交换机，可以看做是一个开关器，可以将任意两个电话之间的线路按需接通。
电话交换机接通电话线的方式称为电路交换
从通信自由的分配角度来看，交换就是按照某种方式动态的分配传输线路的资源
电路交换的三个步骤：
建立连接（分配通信资源）通话（一直占用通信资源）释放连接（归还通信资源） 电话与交换机之间的线路是用户线，只能有一个通信线路，交换机与交换机之间的线路是中继线，中继线可以有多个通信线路，直到被占满
如果用这样的线路作为计算机的通信线路，是否可行？
首先，肯定能够使得双方通信，但是这样的通信效率会很低，计算机的通信为突发式的，造成大量的通信带宽被浪费，所以计算机常常采用分组交换。
分组交换 在因特网中，最重要的交换机就是路由器，它负责将各个网络连接起来，并对接收到的分组转发，也就是进行分组交换。
假设某用户要发送数据，这个数据称为报文，在发送之前，将报文分成较小的报文，并添加必要的头部信息，也就构成了分组，也可简称为包，首部称为包头，首部包含了目的地址。
交换机接收到分组后，先将分组暂时存储下来，再检查首部，按照目的地址查表转发，找到转发接口，将该分组转发给下一个交换机。
源主机将各个分组通过交换机转发出去，最终到达目的主机。目的主机接收到所有分组后，去掉首部，将各个数据段组合成原始报文。
从源主机到目的主机：
各个分组可以走不同的路径（不同路由）分组乱序（分组到达的顺序不一定按次序） 上述存储转发过程中：
发送方需要完成：构造分组，发送分组路由器需要完成：缓存分组，转发分组接收方需要完成：接收分组，还原报文 报文交换与分组交换类似，采用存储转发的方式，但是报文交换对报文大小没有限制，需要交换机有较大的缓存空间。
三种交换方式的对比 假设A、B、C、D是四个交换机，纵坐标为时间，三种不同交换方式中，报文的转发方式对比
电路交换：
通信之前建立连接数据传送释放连接，归还建立连接占用的资源 特点：比特流直达终点
报文交换：
随时发生报文，不需要事先建立连接报文传送到相邻节点交换机，全部存储下来之后，查表转发 特点：报文缓存转发，交换机需要较大的缓存空间
分组交换：
随时发生报文，不需要事先建立连接构成原始报文的分组，依次在交换机上存储转发交换机在转发分组的同时还可以缓存接收分组 特点：各个分组在交换机上存储转发，减少了转发时延
计算机网络的定义和分类 计算机网络的定义 计算机网络的精确定义并不统一
计算机网络最简单的定义就是：一些互相连接的、自治的计算机的集合
互连：计算机之间可以通过有线或者无线的方式进行数据通信自治：独立的计算机，有自己的硬件和软件，可以单独运行使用集合：至少需要两台计算机 计算机网络的较好定义：计算机网络主要是由一些通用的、可编程的硬件互连而成的，而这些硬件并非用来实现某一特定目的（如传送数据或视频信号），这些可编程的硬件能够用来传送多种不同类型的数据，并能支持广泛的和日益增长的应用
计算机网络所连接的硬件，并不限于一般的计算机，而是包括智能手机等智能硬件计算机网络并非专门用来传送数据，而是能够支持很多种应用（包括今后可能出现的应用） 计算机网络分类 按交换技术分类
电路交换网络报文交换网络分组交换网络 按使用者分类
公用网络专用网 按传输介质分类
有线网络无线网络 按覆盖范围分类
广域网WAN域域网MAN局域网LAV个域网PAN 按拓扑结构分类
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5dd19b6d003c86e5a5721bf1a3ae32a1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/147e45acb1f40cadbd07ac4212dad4e2/" rel="bookmark">
			计算机网络 | 应用层：HTTP协议和HTTPS协议详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HTTP简介
HyperText Transfer Protocol --- 》 超文本传输协议
什么是超文本？
包含由超链接和各种多媒体元素标记得文本。这些超文本文件彼此链接，形成网状，因此又被称为网页。这些链接用URL表示。最常见得超文本格式是超文本标记语言HTML。
作用：http协议是在浏览器和web服务器之间使用，用来传输网页。
所有的浏览器都懂http协议。
所有的web服务器：nginx，tomcat，iis，python，web，go web框架，Java web框架都能读懂http协议。
什么是URL？
URL即统一资源定位符（Uniform Resource Location）用来唯一的标识万维网中的某一个文档。URL由协议、主机和端口（默认为80）以及文件路径四部分构成。
什么是超文本传输协议http？
http是一种按照URL指示，将超文本文档从一台主机（web服务器）传输到另一台主机（浏览器）的应用层协议，以实现超链接的功能。
http的工作原理 在用户点击输入url为 http://www.baidu.com/index.html的链接后，浏览器和web服务器执行以下动作
1.浏览器分析超链接中的url
2.浏览器向dns请求解析网址www.baidu.com对应的IP地址
3.dns将解析出的IP地址202.2.16.21返回浏览器
4.浏览器与服务器建立tcp连接
5.浏览器请求相应文档:GET /index.html
6.服务器给出响应，将文档index.html发送给浏览器
7.浏览器显示文档index.html中的内容
8.释放tcp连接
连接：
长连接：长时间连接 --》保持一段时间，然后进行四次断开
短连接：短时间连接 --》事情完成就进行四次断开
http协议版本：
0.9 --》只支持短连接，GET方法
1.0 --》只支持短连接,POST,HEAD方法
1.1 --》支持长连接，传输的数据是文本格式，PUT ,OPTIONS,DELETE等方法
2.0 --》比较新的，速度更快，数据格式二进制，多路复用
HTTP1.0/HTTP1.1的区别：
HTTP1.0对于每个连接都只能传送一个请求和响应，请求完服务器返回响应就会关闭，HTTP1.0没有Host字段。而HTTP1.1在同一个连接中可以传送多个请求和响应，多个请求可以重叠和同时进行，HTTP1.1必须有Host字段。 HTTP的特点 HTTP协议本身是无连接的HTTP协议是无状态的HTTP是面向文本的 http的连接方式（传输层的连接）和无状态性 非持久性连接
即浏览器每请求一个web文档，就创建一个新的连接，当文档传输完毕后，连接就立刻被释放。
&gt;http1.0、http0.9采用此连接方式。
&gt;对于请求的web页中包含多个其他文档对象（如图像、声音、视频等）的链接情况，由于请求每个链接对应的文档都要创建新连接，效率低下。
持久性连接
即在一个连接中，可以进行多次文档的请求和响应。服务器在发送完响应后，并不立即释放连接，浏览器可以使用该连接继续请求其他文档。连接保持的时间可以由双方进行协商。
无状态：是web服务器端的nginx不知道你的请求是第一次请求，还是第二次，新的请求还是旧的请求。是指同一个客户端（浏览器）第二次访问同一个web服务器上的页面时，服务器无法知道这个客户曾经访问过。http的无状态性简化了服务器的设计，使其更容易支持大量并发的http请求。
有状态：服务器收集了客户端的数据，记录了他的信息，通过这些信息可以判断你是老用户还是新用户
通过session和cookie技术实现有状态性
session 和 cookie技术：可以保留客户信息
session：用户的信息保存在服务器端 --》数据保存在数据库
cookie：web服务器让浏览器保存用户的信息，信息保存到客户端，放到浏览器的cookie（存放数据的地方）里
HTTP报文 HTTP有两类报文：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/147e45acb1f40cadbd07ac4212dad4e2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd0647c16b08b9830c69999929f168c1/" rel="bookmark">
			Linux安装Redis5.0之后设置密码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方法一：通过配置文件(/etc/redis.conf)进行设置
这种方法在设置后需要重启redis生效。首先找到redis的配置文件—redis.conf文件，然后修改里面的requirepass(requirepass 是配置redis访问密码的参数)，这个本来是注释起来了的，将注释去掉，并将后面对应的字段设置成自己想要的密码，保存退出。重启redis服务，即可。
方法二：通过命令设置密码
这种方法相对简单，不需要重启redis服务。连接redis之后，通过命令设置，如下：config set requirepass 123456
如此，便将密码设置成了123456
设置之后，可通过以下指令查看密码config get requirepass
密码设置之后，当你退出再次连上redis的时候，就需要输入密码了，不然是无法操作的。这里有两种方式输入密码，一是连接的时候直接输入密码，而是连接上之后再输入密码，分别如下所示：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/390e5efdc7c85c6faeac744a5ae555de/" rel="bookmark">
			（每日一练python）整数反转
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		整数反转 给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。
如果反转后整数超过 32 位的有符号整数的范围 [−231, 231 − 1] ，就返回 0。
假设环境不允许存储 64 位整数（有符号或无符号）。
示例 1：
输入：x = 123 输出：321 示例 2：
输入：x = -123 输出：-321 示例 3：
输入：x = 120 输出：21 示例 4：
输入：x = 0 输出：0 提示：
-2^31 &lt;= x &lt;= 2^31 - 1 import math class Solution: def reverse(self, x: int) -&gt; int: r = 0 y = 0 abs_x = abs(x) negative = x &lt; 0 while abs_x !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/390e5efdc7c85c6faeac744a5ae555de/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b40258a5d3646e86e8193456638c799/" rel="bookmark">
			Linux安装Mysql5.7
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一步、下载mysql 安装包 wget https://dev.mysql.com/get/mysql57-community-release-el7-11.noarch.rpm
第二步、安装mysql 安装源 yum -y localinstall mysql57-community-release-el7-11.noarch.rpm
第三步、在线安装mysql （看网络情况，时间有点久） yum -y install mysql-community-server
*** 如果出现以下错误按此方式处理
warning: /var/cache/yum/x86_64/7/mysql57-community/packages/mysql-community-libs-compat-5.7.37-1.el7.x86_64.rpm: Header V4 RSA/SHA256 Signature, key ID 3a79bd29: NOKEY 从 file:///etc/pki/rpm-gpg/RPM-GPG-KEY-mysql 检索密钥 源 "MySQL 5.7 Community Server" 的 GPG 密钥已安装，但是不适用于此软件包。请检查源的公钥 URL 是否配置正确。 失败的软件包是：mysql-community-libs-compat-5.7.37-1.el7.x86_64 GPG 密钥配置为：file:///etc/pki/rpm-gpg/RPM-GPG-KEY-mysql
处理方法：
vim /etc/yum.repos.d/mysql-community.repo
将gpgcheck改为0
第四步、启动mysql服务 systemctl start mysqld
第五步、设置开机启动 systemctl enable mysqld
systemctl daemon-reload
第六步、查找mysql默认密码并记录下来 vim /var/log/mysqld.log
找到password
第七步、进入mysql mysql -u root -p
用找到的密码
第八步、修改密码 alter user user() identified by '你的新密码';
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b40258a5d3646e86e8193456638c799/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16211d62cb396e3c0f6d4224bbc7c8c0/" rel="bookmark">
			Linux安装Java8
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装Java JDK 1.8 yum -y install java-1.8.0-openjdk 安装成功后验证版本java -version
后面还有很多Linux学习内容
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c375b86ce5cff03138e8db075bec2ef0/" rel="bookmark">
			CS5261与CS5265功能应用|CS5261替代RTD2171|CS5265替代RTD2172
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CS5261与CS5265功能应用|CS5261替代RTD2171|CS5265替代RTD2172
CS5261与CS5265是Capstone新推的一款TYPEC转HDMI单转芯片方案，其中CS5261是Type-C转HDMI 4K30HZ 转换功能，CS5265是Type-C转HDMI 4K60HZ转换功能。CS5261其参数和性能是可以完全替代RTD2171功能，CS5265是可以完全 替代RTD2172功能。下面将详细讲述CS5261与CS5265的参数，且其在设计上面与RTD2171、RTD2172区别与优势。
CS5261参数特性：
USB Type-C显示端口（DP）Alt模式输入（接收器）
USB Type-C规范1.1和向后兼容Type-C规范1.0
VESA DisplayPortTM v1。4合规。支持双通道HBR2（5.4 Gbps）输入。内置高性能自适应均衡器。支持1-MHz辅助信道
USB Type-C通道配置（CC）功能
USB电源传输规范2.0兼容的集成USB电源传输（PD-BMC）物理层。支持消息协议。支持策略引擎。
支持基本设备策略管理器
支持热插拔检测（HPD）HDMI输出接口（变送器）
每个通道的最大数据速率高达3Gbps
支持高达3840x2160@30Hz或4096x2160@24Hz
音频流处理
-压缩音频编码格式
-192KHz x8通道的最大音频采样率
CS5265参数特性：
USB Type-C规范1.1及以下版本
与type-C 规范1.0兼容
VESA Display Port TM v1.4兼容。支持4通道高达HBR3（8.1 Gbps）的输入。内置高性能自适应均衡器。支持1兆赫辅助信道
USB Type-C通道配置（CC）功能
USB电源传输规范3.0兼容集成
USB电源传输（PD-BMC）物理层。支持消息协议。支持策略引擎。支持基本设备策略管理器
支持热插拔检测（HPD）
HDMI输出接口（发射机）
每个通道的最大数据速率高达6-Gbps
支持高达3840 x2160@60Hz或4096x2160@60Hz
音频流处理
LPCM和压缩音频编码格式
192k Hz x8通道的最大音频采样率支持高动态范围（HDR）元数据处理
嵌入式微控制器
工业标准8051核
支持I2C主从高达400 KHz。
电力与技术
5V/3.3/1.1V系统电压
HBM 6-KV用于连接器引脚，3.5-KV用于其余引脚
综上所示：
CS5261与CS5265 都是应用于
DP显示端口（适配器）、扩展底座、投影仪、游戏机等的系统。
电视显示系统、数字标牌、虚拟现实系统
CS5261与CS5265都是可以用于设计TYPEC转HDMI 短线或者长线转接线：
CS5261与CS5265设计Type-C转HDMI 投屏转换线应用和兼容的设备、手机如下所示：
CS5261与CS5265替代RTD2171与RTD2172设计上面的优势和成本差异如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c375b86ce5cff03138e8db075bec2ef0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/084afc93635aa0587d6c47d95e81989b/" rel="bookmark">
			导入matplotlib中的pyplot模块报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：
1、引起这个错误的主要原因在在于python文件的名字与matplotlib一致，所以才会导致导入pyplot模块的时候出问题
2、网上找的很多解决方案，但是都没有解决到实际问题（大家好像都提到的版本的问题），之后我发现其实只要把python的文件名字改一个就好了。
3、我这里导入的matplotlib 是3.5.1版本（目前来说是最新的）
matplotlib版本 报错提示 文件名字与matplotlib模块名相同，导致报错
解决方案 1、把文件名字改一下即可。
2、改完之后把import matplotlib.pyplot as plt 语句重新写一下即可。
【注】
描述：之前是是直接导入了pandas 和 matplotlib 模块，但是发现会出问题，他会重复读取excel的数据。经排查过后，发现还是文件名字和matplotlib 模块起冲突，因此建议一些想规范命名的小伙伴们，还是不要以，模块名字命名的比较好。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29b7a1e7fda94dec8d9372550f1c24ae/" rel="bookmark">
			请求表头headers设置Accept-Encoding为gzip,deflate,br时，python ——requets的get/post返回的结果有可能是乱码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		爬取某页面的数据时，在我本机环境进行请求，返回的结果是正常的，即不乱码，但是把代码拷贝到其他电脑运行，返回的结果就是乱码了。如下：
我本机的请求结果：
其他电脑运行返回的数据是乱码的，无论是设置utf-8、gbk还是设置gb2312，都无法解码：
百度了好久，都是说返回结果中文乱码的解决方案，都没有把问题解决（原来是自己问题点没有搜索对，毕竟当时自己也想不到）。后面在技术群中请教大佬后，才知道是headers请求头的Accept-Encoding设置值的问题，即Accept-Encoding='gzip,deflate,br’。
因为代码都一样，在自己本机运行都正常，所以压根想不到是这个导致，所以也没有一个一个的注释进行调试。
最终解决方案就是把gzip去掉，或者把 Accept-Encoding='gzip,deflate,br’ 整行都注释了，再次请求就可以得到正常的结果了。如下：
当然网上还有给出另一个方案（这方案在python我不知道怎么用，大家可以自行选择，有知道的也可以留意指导，毕竟本人菜鸟一枚）：
设置Header的Accept-Encoding值的同时设置对应的自动解压缩的模式 req.Headers["Accept-Encoding"] = "gzip,deflate,br"; req.AutomaticDecompression = DecompressionMethods.GZip; ‘Accept-Encoding’：是浏览器发给服务器,声明浏览器支持的编码类型。一般有gzip,deflate,sdch,br 等等。
网上对这的解释，那就是：
普通浏览器访问网页，之所以添加"Accept-Encoding" = “gzip,deflate,br”，那是因为，浏览器对于从服务器中返回的对应的gzip压缩的网页，会自动解压缩，所以，其request的时候，添加对应的头，表明自己接受压缩后的数据。
而在我们编写的代码中，如果也添加此头信息，结果就是，返回的压缩后的数据，没有解码，而将压缩后的数据当做普通的html文本来处理，当前显示出来的内容，是乱码了。
相关信息：
从python爬虫引发出的gzip,deflate,sdch,br压缩算法分析 http://www.cnblogs.com/RainLa/p/8057367.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a9c5475837f7342ae1dbbdb48285ca1/" rel="bookmark">
			Sql Server中 master.dbo.spt_values 的用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		master.dbo.spt_values是一个数据库常量表，表里都是一些枚举数据。
我们可以先查询一下看表里都有什么☞
select * from master.dbo.spt_values 查询得知表里有五个字段：☞
name（名称）,number（值）,type（类型）,low（下限）,high（上限）,status（状态）
抽取一个type看下☞
select number from master..spt_values where type = 'p' --Type = 'P'的number数字范围是0-2047 取1-1000之间的数字 select number from master..spt_values where type='P' and number between 1 and 1000 取当前日期往后的365个日期 select convert(varchar(10), dateadd(day,number,getdate()), 120) as [日期] from master..spt_values where type = 'P' and number between 0 and 365 取2019年4月至2020年3月的月份 select convert(varchar(6),dateadd(month,number,'20190401'),112) as month from master..spt_values where type = 'P' and dateadd(month,number,'20190401') &lt;= '20200301' 取两句话中重复的汉字 declare @text1 varchar(100),@text2 varchar(100) set @text1 = '没有理想的人不伤心' set @text2 = '他也会伤心' SELECT SUBSTRING(@text2,number,1) as value from master.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2a9c5475837f7342ae1dbbdb48285ca1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/373dac566e3b5921e0309cab832b7084/" rel="bookmark">
			TypeScript杂谈(一)——type关键字
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		type的定义 type:其作用就是给类型起一个新名字，可以作用于原始值（基本类型），联合类型，元组以及其它任何你需要手写的类型
type Second = number; // 基本类型 let timeInSecond: number = 10; let time: Second = 10; // time的类型其实就是number类型 type userOjb = {name:string} // 对象 type getName = ()=&gt;string // 函数 type data = [number,string] // 元组 type numOrFun = Second | getName // 联合类型 注意：起别名不会新建一个类型 - 它创建了一个新名字来引用那个类型。给基本类型起别名通常没什么用。类型别名常用于联合类型。
type的应用以及与interface的区别 和接口一样，用来描述对象或函数的类型 type User = { name: string age: number }; type SetUser = (name: string, age: number)=&gt;void; 在ts编译成js后，所有的接口和type 都会被擦除掉。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/373dac566e3b5921e0309cab832b7084/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5595d47ebc8800410b83edf790ddb4b/" rel="bookmark">
			两分钟解决Unity谜之问题，License error，Unity2021打不开
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题描述 最近遇到一个很离谱的问题，我的unity2020，2019都可以用，就最新下载的Unity2021无法打开
而且删除了许可证，重新激活也不可以，网上其他方法都试过还是不行。
这个问题还有个伴随症状，就是启动unity也很慢，不是因为项目的庞大的那种慢。
解决方法 关闭unity和unityHub首先win+R输入 inetcpl.cpl
找到高级，点击重置
最后就能愉快的地打开unityhub咯（之前没更新许可证的要记得更新下）
最后 其实这主要还是系统网络的问题，这之前我epic，steam都打不开(开了加速器)，甚至网盘登录的二维码都打不开，但是电脑却能正常上网，看视频，下载东西，不过用上面的重置方法后，全部都解决了。如果有用记得点个赞吧 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7381d3c843ed77bfd8242e559fa1d9da/" rel="bookmark">
			C/C&#43;&#43;学习记录：智能指针 std::unique_ptr 源码分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		抽空扣一点感兴趣的标准库源码，这里总结一下 std::unique_ptr 相关的分析本文中 gcc version: 8.4.1 20200928 (Red Hat 8.4.1-1) (GCC)libstdc++:libstdc++-8.4.1-1.el8.x86_64其中c++库安装路径为 /usr/include/c++/8 目录 一、前言二、源码分析1. 从 class unique_ptr 入手2. 储存类 class __uniq_ptr_impl3. 默认删除器 struct default_delete4. 回归 class unique_ptr 三、总结 一、前言 在对本篇文章内容的探索之前，我已经是对 std::unique_ptr 有所了解并且尝试实现过，所以本篇分析主要是为了查看标准库里的具体实现和写法，学习一下细节和思路。
众所周知啊 ，std::unique_ptr 的主要思路就是利用局部变量声明在栈上，会自动释放的特性，在构造函数里绑定指针，在析构函数里释放此指针的内容，从而达到智能指针的效果(自动释放)。这种机制被称为RAII机制，相关类被称为RAII类。
本篇笔记中会记录我在学习标准库代码时的思路和想法，此次我看的重点是自动释放的流程和相关数据结构的实现。
二、源码分析 1. 从 class unique_ptr 入手 class unique_ptr 的定义位于 /usr/include/c++/8/bits/unique_ptr.h 中。 首先可以看到，在这个文件中，存在两个 unique_ptr 类的定义，如下两图：
定义一：
定义二：
根据注释以及部分来看代码，一百多行开始的定义一部分是针对 single objects 的，而四百多行开始的定义二部分是针对 array objects 的。简单来讲就是定义一是针对单个指针对象的，而特化版本定义二是针对存有多个指针的数组对象的。
另外，可以看到模板中有两个参数，_Tp 和 _Dp。根据之前对 std::unique_ptr的使用来看，第一个参数是指针所指向的类型；然后我简单看了一下源码和注释，第二个参数是删除器，即规定指针释放时的操作。
在定义一中，删除器被默认指定为 default_delete&lt;_Tp&gt;，在下文中会对其进行分析。而定义二中需要传入两个模板参数，指定类型和删除器，我认为原因是指针对象数组与单个指针对象析构时存在差异，所以需要单独定义删除的方法。
接着就是在智能指针中，肯定是存在一个成员变量来储存指针的，所以我决定先看一下这部分内容标准库里是怎么实现的。如下图，是 std::unique_ptr 的一个构造函数，其中传入 pointer 类型的 __p 并将其赋值到成员变量 _M_t 中。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7381d3c843ed77bfd8242e559fa1d9da/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3793cd881d8a49e35e57e046a633275/" rel="bookmark">
			【ocr 文字检测】DocSegTr: An Instance-Level End-to-End Document Image Segmentation Transformer
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		论文链接：https://arxiv.org/pdf/2201.11438.pdf
代码：https://github.com/biswassanket/DocSegTr
出处：西班牙巴塞罗那自治大学
目的：理解复杂布局的文档首先就需要进行信息提取。本文目的就是通过实例级别分割获得不同的文章目标（different document objects），如：标题，章节，图片，表格等；（效果图1），文中提出一个 Document Image Segmentation Transformer（DocSegTr），第一次用于复杂布局文本的实例级分割；
关键词：文档布局分析，实例级别分割，transformer，信息抽取
贡献有三点：
提出了文档图像分割Transformer（Document image Segmentation Transformer，DocSegTr），该方法是一个端对端的实例级别的分割方法，可以有效的分析和分割布局复杂的文档。且该方法是第一个bottom-up实例级别文档分割方法，有效的结合了CNN和transformer方法，且没有使用box做目标检测；DocSegTr中将self-attention用twin attention替代，与Maskrcnn相比提升了计算效率，节省了内存空间；DocSegTr在文档数据集PubLayNet 数据上获得了89.4%AP； 2.Related Work 对于文档的信息提取需要对本页中不同布局组件之间进行空间理解和关系推理，例如：表格，文本块（段落），图，标题等等。从基于规则启发性的文档布局分割到最近的基于深度学习的文档目标检测（DOD， Document Object Detection）大量的工作是为了解决页内的目标定位。本章节，作者回顾了很多不同的方法；
2.1 基于规则启发式的文档布局分析 基于规则启发式的文档布局分割主要有三种模式：top-down，bottom-up 和hybird方法，bottom-up方法【2，31，34】使用像素作为基本组件，通过类似分组和合并的方式形成大的同种类的区域；top-down方法【20，23，29】是将整个文档划分为不同的区域，直到最终定义出标准的列或模块。bottom-up方法更加灵巧，适用于不同布局的文档，但是计算复杂；top-down 计算效率高，但是却只能处理特定版面的文档，例如基于曼哈顿布局的文档；因此，hybird方法【38，40】混合以上二者的优点，产生更好的结果；在深度学习时代以前，基于规则的分割技巧【7，10，37】对于表格检测也是影响深远；
2.2 文档目标检测 基于深度学习的发展，CNN成为了文档布局分割的主要方法。主要是通过Faster-RCNN【32】，Mask-RCNN【14】和Retinanet【26】这类自然场景检测方法对文档布局进行分割。DeepDeSRT【36】是第一个最为流行的用于处理文档中（如：扫描图和数据图片）表格检测和结构识别的目标检测方法；该方法是在将文档输入Faster-RCNN模型之前，对文档应用了一种新的图像变换策略；之后，FCNNs【13】用于在页面上检测大量的目标内容（表格和图）。Oliviera等人【30】使用了一个基于FCNN的相似框架在历史文献上进行逐个像素级别的分割。Saha等人【35】基于transfer learning的Faster-RCNN主干在数据集ICDAR POD（page object Detection）2017【11】上检测表格，图和数学公式获得了很好的结果。最近一个新的跨区域的文档目标检测（DOD）基准在【24】中建立，该基准使用了区域自适应策略，用于DOD中解决区域变换问题；
2.3 Transformers用于文档分析系统 自然语言模型获得更好的结果是因为self-attention和positional embedding机制，在Vaswani等人【41】提出了最原始的transformers。之后，BERT【9】语言模型用于多模态最新的视觉文档理解任务（VDU），比如扫描菜单和发票中的实体识别（entity recognition）和键值对（key-value pair）信息提取。LayoutLM【46】就联合学习文档图片的文档，布局和视觉特征，BERT模型作为基线（BERT-like model baseline），在VDU任务中获得了最佳效果；最近在VDU中的研究【1，22，25】使用了transformers，使用了在文档，布局和图像区域的预训练用于解决VDU任务，如表格理解【19】，菜谱理解【18】，和文档视觉QA（question， answering）【28】。
受transformers在文档理解和文档分析突破的影响，作者首先提出了端对端的文档图像分割transformer，在实例级别分割上获得了很好的效果【47】。作者也将本文的结果和之前的研究结果【4】进行了比较；
3 方法 为了完成实例级别的文档布局分割，一个混合CNN基于transformer（DocSegTr）被提出来，用于识别出不同布局的元素（段落，表，图，标题等）和它们之间的长期依赖。DocSegTr是一个端对端的分割算法，它将特征图分割成patches，然后在patches上预测文章内容，DocSegTr有三部分组成：1）一个有特征金字塔（FPN）的CNN主干用于提取输入文档图片的突出的，特定的低维和近邻元素；2）一个transformer用于广泛和语义推理，transformer兼并了functional heads用于预测语义的类别，和卷积kernel中的kernel head（这个操作是为了展开多尺度特征增加位置信息（positional embedding））；3）一个Layerwise Feature Aggregation module（分层特征聚合模块）通过在特征图和相关的卷积核之间通过动态卷积活动创作最后的一层操作（the last division cover）；产生的结构如图1
3.1 文档分割Transformer（DocSegTr） DocSegTr包含三个模块：self-attention机制：处理长期依赖；transformer层和一个Functional head用于实例级分割中的mask预测；
Attention机制：self-attention模块在Transformer中是很重要的一个部分，用于学习全局特征（catches full-document setting）和学习文档不同特征信息之间的关系。但是在【41】中提出的最原始的self-attention计算和存储都相当复杂，耗费时间。为了解决这个问题，作者使用【12】中的孪生注意力（twin-attention）分解了原始的注意力矩阵，twin-attention就是传统注意力的稀疏表示。twin-attention首先单独计算每一列的结果。这样有助于减少水平尺度的语境推理。然后通过计算每一行的相似注意力在竖着的尺度进行相似的操作；最终结果就是行和列注意力（分别为垂直尺度和水平尺度）有序连接形成全局注意力模块，沿着两个不同的维度（全局和局部）覆盖了所有重要的特征信息；
在实例级别分割任务中，假设FPN的每一层的特征图谱为，DocSegTr首先将特征图谱划分为个块（patches）,然后通过垂直方向和水平防线将这些patches堆叠为固定的组件（components）。然后将位置信息（position embedding）嵌入到components中保留位置信息，这些行列的位置信息（position embeding）用于自注意力机制当中；为了确保这两个模块（行和列的注意力矩阵）和多头注意力一起工作，作者使用了跨多层连接（防止梯度消失），在twin-attention中所有的子层中会产生相同的的输出。这个方法可以减少内存消耗，减少计算复杂度；原始的self-attention的内存和计算复杂度从降到;
Transformer Layer:本章节中，作者展示了三个特定的transformer层回顾基础结构（如图1）中的encoder。1）第一个transformer和【41】中的一样，包含两个组件：层归一化后【3】一个多头注意力单元和层归一化后的多层感知机（MLP）。此外，使用残差连接【15】两个模块。最终transformer层K个序列关联的结果就是多维特征序列，确保了下面functional heads能够做出预测；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f3793cd881d8a49e35e57e046a633275/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/814787c5d0b648dc2933d3dcea62631f/" rel="bookmark">
			java基础-双指针算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		小伙伴们，你们好呀！我是老寇！
双指针算法是基于暴力解法的优化，将时间复杂度降低到线性。
双指针算法与其说是一种算法，不如说是一种技巧，它能够缩短循环遍历的时间，提高程序的运行速度！
双指针分为两类，快慢指针和左右指针：
1.快慢指针（弗洛伊德循环查找算法），类似龟兔赛跑。
2.左右指针又称指针碰撞，就是一左一右遍历。
注：多练习，印象才更深刻
快慢指针
快乐数
class Solution { public boolean isHappy(int n) { int slow = n,fast = n; do{ slow = bitSquareSum(slow); fast = bitSquareSum(fast); fast = bitSquareSum(fast); } while(slow != fast); return (slow == 1); } private int bitSquareSum(int x) { int sum = 0,cur; while(x &gt; 0) { cur = x % 10; x = x / 10; sum += cur * cur; } return sum; } } 结论：较哈希集，指针只需要常数的额外空间 删除有序数组中的重复项
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/814787c5d0b648dc2933d3dcea62631f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0bb12fe00d010861928fdf289619a6ef/" rel="bookmark">
			ubuntu 安装网卡驱动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 ubuntu 安装网卡驱动 查看当前网卡 # 首先 查看当前所有的 网卡, ifconfig -a # 一定要加 -a (表示all) # 若有显示,说明识别成功,再查看目前已经启动的网卡有没有 ifconfig # 查看目前启动的网卡 (防止识别到了硬件,但没有启动,热插拔未启动的现象) 下载相应的驱动 # 查看当前插入的 usb 网卡设备 lsusb # 下载相应的驱动 https://www.asix.com.tw/en/product # 官方网址 https://www.lulian.cn/download/list-34-cn.html # 绿联网址 # 解压 tar -xf DRIVER_SOURCE_PACKAGE.tar.bz2 make make install # 加载驱动 insmod asix.ko # 手动加载驱动程序 modprobe asix # 运行modprobe加载内核模块,自动加载驱动程序 # 扩展几条命令 lsmod | grep -i ASIX # 查看已安装的模块 depmod -a	# 更新模块依赖新 lspci # 查看ubuntu网卡是否安装 rmmod asix # 删除 asix 模块 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e52112d10920c70b0a0c1ae37be34fc/" rel="bookmark">
			银河麒麟系统飞腾CPU安装redis和nginx
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前在国产银河麒麟系统上部署项目，这里做一下软件安装的记录。
安装redis
进入/usr/local目录cd /usr/local 创建redis文件夹mkdir redis 上传并解压redis-4.0.9.tar.gz包到redis目录tar -zxvf redis-4.0.9.tar.gz 进入deps目录cd redis-4.0.9/deps 编译redis依赖库make -j4 hiredis lua jemalloc linenoise 到主目录编译rediscd ../ make -j4 make install 修改配置daemonize no-&gt;yes bind 127.0.0.1-&gt;# bind 127.0.0.1 protected-mode yes-&gt;no 启动rediscd src ./redis-server ../redis-conf 安装nginx
进入/usr/local目录cd /usr/local 创建nginx文件夹mkdir nginx 上传nginx包：nginx-1.16.1.tar.gz和依赖包：openssl-1.1.1g.tar.gz，pcre-8.41.tar.gz，zlib-1.2.11.tar.gz(这里有版本问题，目前这个版本对应没有问题)tar -zxvf nginx-1.16.1.tar.gz tar -zxvf openssl-1.1.1g.tar.gz tar -zxvf pcre-8.41.tar.gz tar -zxvf zlib-1.2.11.tar.gz 进入解压后的nginx目录cd nginx-1.16.1 创建安装目录installsmkdir installs 编译nginx安装目录./configure --prefix=/home/nginxsrv/nginx/nginx-1.16.1/installs --with-pcre=../pcre-8.41 --with-openssl=../openssl-1.1.1g --with-zlib=../zlib-1.2.11 安装nginxmake &amp;&amp; make install 进入installs目录下修改配置文件cd installs/conf vim nginx.conf ```java server { listen 9009; server_name 服务器IP; location / { #autoindex on; #default_type text/plain; #proxy_redirect off; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Real-Port $remote_port; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; client_max_body_size 50M; #if ($request_filename ~* ^.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2e52112d10920c70b0a0c1ae37be34fc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6af18f108e555ab3d8c7d15334e1a401/" rel="bookmark">
			2023级网络安全岗面试题及面试经验分享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在当今社会网络安全行业越来越发达，也有越来越多的人去学习，为了更好地进行工作，除了学好知识外还要应对企业的面试。
所以在这里我归总了一些网络安全方面的常见面试题，希望对大家有所帮助。
一个2023届毕业生在毕业前持续更新、收集的安全岗面试题及面试经验分享~
写在前面 个人强烈感觉面试因人而异，对于简历上有具体项目经历的同学，个人感觉面试官会着重让你介绍自己的项目，包括但不限于介绍一次真实攻防/渗透/挖洞/CTF/代码审计的经历 =&gt; 因此对于自己的项目，面试前建议做一次复盘，最好能用文字描述出细节，在面试时才不会磕磕绊绊、或者忘了一些自己很得意的细节面试题会一直更新（大概，直到我毕业或者躺平为止吧…）包括一些身边同学（若他们同意的话）和牛客上扒拉下来的（若有，会贴出链接）还有自己的一些经历还有一点很想说的，就是面试题/面经，本质上只是一种“见识”，他并不能实质上提升自己的水平，还是希望大家（包括我自己）不要太局限于面经，可以查缺补漏但没必要面经问什么自己就一定要学什么，按自己的节奏学就行了，毕竟每人的技术特点不一样，面试的过程和问题也会不一样
最后欢迎大家fork项目！xdm自己有面试经验的话也欢迎发pr！有分享就有收获！ 若有不方便公开的内容请联系本人第一时间删除！
目录
致谢0x00 字节跳动-渗透测试实习生0x010x02 深信服-漏洞研究员实习0x030x04 字节跳动-安全研究实习生0x05 长亭科技-安全服务工程师0x06 天融信面试复盘0x07 腾讯-安全技术实习生0x08 小鹏汽车-安全工程师0x09 阿里巴巴-阿里云安全0x0A0x0B 字节跳动-无恒实验室0x0C 58同城-安全工程师0x0D 腾讯-玄武实验室0x0E 360-安全工程师0x0F 快手-安全实习生0x10 华顺信安-安全服务工程师0x11 奇安信面试复盘0x12 京东-安全研发0x13 安恒面试复盘0x14 浙江东岸检测0x15 360-安全工程师实习0x16 某一线实验室实习0x17 腾讯-科恩实验室实习0x18 某四字大厂面试复盘0x19 某四字大厂实习面试复盘0x1A 某两字大厂面试复盘0x1B 某安全公司-安全研究员 致谢 感谢 PolarPeak 、 lalalashenle 、 4ra1n 师傅的分享！
0x00 字节跳动-渗透测试实习生 字节直接找朋友内推的效率很高，当天上午投简历，下午就约了面试，裸面挺痛苦的建议复习一下再去
自我介绍渗透的流程信息收集如何处理子域名爆破的泛解析问题如何绕过CDN查找真实ipphpinfo你会关注哪些信息有没有了解过权限维持说一个你感觉不错的漏洞，展开讲讲输出到href的XSS如何防御samesite防御CSRF的原理CSRF防御json格式的CSRF如何防御浏览器解析顺序和解码顺序过滤逗号的SQL注入如何绕过过滤limit后的逗号如何绕过fastjson相关漏洞说一个你知道的python相关的漏洞（SSTI原理，利用过程,payload相关的东西）开放性问答 0x01 0x02 深信服-漏洞研究员实习 时长：15分钟
自我介绍在xx实习的时候做什么东西渗透测试的思路简单说一下护网在里面担当一个什么样的角色红队的一些思路拿下系统后有没有做横向前段时间那个log4j有研究吗，可以简单说一下吗（继上一个问题）有哪些混淆绕过的方法内存马有没有了解过冰蝎、哥斯拉这些工具有没有了解过做攻击队的时候有没有研究过什么攻击，比如研究一些工具还是魔改什么的那么多漏洞和攻击，比较擅长哪一个说一下shiro反序列化的形成原因、利用链对一些bypass的方法有没有了解过，有什么姿势可以简单介绍一下反问 0x03 0x04 字节跳动-安全研究实习生 一面 时长：50分钟
你投的岗位是安全研究实习生，你了解我们这边主要是做什么的吗自我介绍现在有什么比较想做的方向吗，比如你写的代码审计、攻防演练、你在学校的研究方向（密码学）其实是三个大方向，现在有什么比较想做的吗 说了代码审计、安全研究 有没有审过开源框架、cms、中间件之类的面试官介绍了工作内容我看你简历上有几段实习经历和项目经历，先聊一下实习经历吧，在A主要做什么的详细聊聊入侵检测主要在做什么，遇到的问题关于入侵检测产生大量误报的原因，有没有分析过，有没有比较好的解决方法和A比起来，B的应该就比较偏攻击方对吧，有打仗（雾，面试官好像确实是这么说的）有代码审计，聊一下在B主要做了些什么审表达式引擎的步骤和思路刚刚你说的审计听起来好像和普通开发的审计差不多，都是通过程序流、文档去做，有没有从安全方面入手审计一些项目xxe是怎么造成的，从代码层面来看我看你简历有很多攻防演练经历对吧，这几段攻防演练经历有没有哪一次印象比较深刻的，挑一个聊一聊你的这次攻击好像更多的是利用弱口令，有没有一些更有技巧的方法这个头像上传的webshell是怎么上传的还有什么其他的检验方式？要怎么绕过？这两天log4j漏洞很火，有没有去了解一下面试官最后介绍业务反问环节 一面plus-安全研发实习生 很奇葩的剧情，一面面试官面完告诉我有base北京base深圳问我是不是想要深圳的，我说是，结果过了一个多星期hr告诉我因为我一面面试官是北京的，然后我选了深圳，所以一面不作数，重新约了一面
接着一面这天中午又收到了感谢信，然后看官网状态是流程已终止，本以为没得面了没想到还是正常进行…
等到二面才发现原来已经变成安全研发了，本来我投的是安全研究的…
时长：45分钟
自我介绍A护网做了什么做哪一层的处置，waf？ids？遇到的问题是什么，有什么印象深刻的处置怎么解决误报过多的情况，有做过什么规则能解决这个情况的他的内网误报是在办公网还是生产网比如mysql也会执行powershell，怎么做防护（前面说了很多内网误报是因为有人写了ps脚本触发的）有没有挖过src在做攻防的时候，资产收集这块有没有什么经验介绍的一个单位的一级域名可能不止一个，怎么收集某个单位的所有域名，注意不是子域名还有没有其他的资产收集的经验除了信息收集，有没有什么漏洞方面的攻击案例聊一下sql注入怎么防御遇到order by时怎么防御用转义字符防御时，如果遇到数据库的列名或是表名本身就带着特殊字符，应该怎么做宽字节注入ssrf了解吗怎么修复基于黑白名单的修复，现在的生产基本都是用的docker，ip是随时变的，而且docker重启后可能什么都不一样了，怎么做一个修复fastjson反序列化redis的漏洞mysql的提权shiro反序列化最近很火的log4j，聊一下原理jndi的解析流程和原理有没有什么你做的比较好的地方我没有问到的，可以聊一聊惯例介绍部门的主要业务惯例反问 二面 紧接在一面plus后，就隔了10分钟，一面复盘写一半就开始二面了
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6af18f108e555ab3d8c7d15334e1a401/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb8677fdde8a9708977d143a0c2794fe/" rel="bookmark">
			前端在H5页面唤起微信支付（H5支付）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 公司产品之前是在公众号之内访问，使用微信JSDK调用微信支付。后需要在浏览器之中访问，调用H5支付。前端使用框架是VUE + VANT
提示：以下是本篇文章正文内容，下面案例可供参考
首先了解什么是H5支付，链接地址：微信H5支付说明文档
一、在支付页面通过后端接口获取H5支付链接 pay() { let This = this; this.$indicator.open(); //loading... let params = { proposalNo: this.$route.query.orderNo, orderType: '2', // 1投保单 2订单 payType: this.isWeixin() ? '': '3' } initiatePayment(params).then(res =&gt; { if (res.code == 200) { This.$indicator.close(); localStorage.setItem("payVisiable", true) location.href = res.data.mwebUrl // 获取支付链接直接跳转微信 } }).catch(error =&gt; { This.$indicator.close(); This.$toast(error) }) } 接下来说下，在过程中遇到的坑！！！
1、使用上边的代码跳转到微信之后，用户支付成功或失败都会跳转到发起支付的这个页面，发起支付的页面地址是https://xxx.xxxxx.cn/channel/a/#/studyH5?policyNo=1111&amp;planCode=2222，支付完成或支付失败后，跳转的页面就变成了 https://xxx.xxxxx.cn/channel/a/#/，问题来了，页面加载不出来了。
解决方法：
//在跳转支付链接后，拼接微信回跳地址 location.href = res.data.mwebUrl + '&amp;redirect_url=' + encodeURIComponent(window.location.href) 重点 跳转地址需要encodeURIComponent
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fb8677fdde8a9708977d143a0c2794fe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40ac3caf745024d4820da3f3934cf20e/" rel="bookmark">
			Oracle sid_name 和service_name的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
问题: 排查一:
排查二：
jdbc连接oracle的方式 问题: kettle连接Oracle时候报错：
错误连接数据库 [MFG Prod] : org.pentaho.di.core.exception.KettleDatabaseException: Error occurred while trying to connect to the database
Error connecting to database: (using class oracle.jdbc.driver.OracleDriver)
Listener refused the connection with the following error:
ORA-12505, TNS:listener does not currently know of SID given in connect descriptor
org.pentaho.di.core.exception.KettleDatabaseException: Error occurred while trying to connect to the database
Error connecting to database: (using class oracle.jdbc.driver.OracleDriver)
Listener refused the connection with the following error:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/40ac3caf745024d4820da3f3934cf20e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3fbc95ec8900c8de77eb381f9f8152e4/" rel="bookmark">
			STM32F103 实例应用（3.1）——GPIO(增加深度)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、GPIO简介 GPIO是通用输入输出端口的简称，简单来说就是STM32可控的引脚。将STM32芯片的GPIO引脚与外设部分连接起来，即可实现与外部通信、控制以及数据采集功能。STM32芯片的GPIO被分成很多组，每组16个引脚，如型号STM32F103VET6的芯片有GPIOA至GPIOE共5组GPIO。芯片一共100个引脚，其中GPIO就占了很大一部分，所有的GPIO引脚都有基本的输入输出功能。
最基本的输出功能是由STM32控制引脚输出高、低电平，实现开关控制，如把GPIO引脚接入LED灯，就可以控制等的亮灭；引脚接入继电器或者三极管，就可以通过继电器或者三极管控制外部大功率电路的通断。
最基本的输入功能是检测外部输入电平，如把GPIO引脚连接到按键，然后通过电平高低区分按键是否按下。
二、GPIO框图剖析 通过GPIO硬件结构框图，就可以从整体上深入了解GPIO外设及它的各种应用模式，见下图。从最右端看起，最右端就是代表STM32芯片引出的GPIO引脚，其余部件（左边）都位于芯片内部。
2.1 基本结构分析 下面我们对上图中的GPIO端口的结构部件进行说明。
2.1.1 保护二极管 引脚的两个保护二极管可以防止引脚外部过高或过低的电压输入（二极管的单向导电性），当引脚电压高于VDD时,上方的二极管导通（相当于IO引脚处是正极，VDD是负极，由于二极管单向导电，上方二极管导通），当引脚电压低于VSS时，下方二极管导通，防止不正常的电压引入芯片导致芯片烧毁。尽管由这样的保护，并不意味着STM32的引脚能直接外接大功率驱动期间==器件，如直接驱动电机，要么电机不转，要么板子冒烟，必须加大功率及隔离电路驱动。
2.1.2 P-MOS 管和 N-MOS 管 GPIO引脚线路经过2个保护二极管后，向上流向“输入模式”结构，向下流向“输出模式”结构。先看输出模式部分，线路经过一个由P-MOS和N-MOS管组成的单元电路。这个结构使GPIO具有了“推挽输出”和“开漏输出”两种模式。
所谓推挽输出模式，是根据这两个MOS管的工作方式来命名的。在该结构中输入高电平时（左边芯片内部给了高电平要向外输出），经过反向后，上方的P-MOS导通，下方的N-MOS关闭，对外输出高电平；而在该结构中输入低电平时，经过反向后，N-MOS管导通，P-MOS关闭，对外输出低电平。当引脚高低电平切换时，两个MOS管轮流导通，P管负责推电流，N管负责挽电流，使其负载能力和开关速度都比普通的方式有很大提高。推挽输出的低电平为0V，高电平为3.3V，推挽输出模式时的等效电路如下：
我是这么认为的P-MOS的S级是P；N-MOS的S级是N；S级和G级之间同性相斥，异性相吸。P-MOS的S级是P意味着S级需要接3.3V，N-MOS的S级是N意味着S级需要接GND，那么S和G之间同性相斥，就是说再P-MOS的S级是3.3的时候，G如果也是3.3就不会导通，就像一个开关它不会闭合。异性相吸就是指P-MOS的S级是3.3的时候，G如果是0，就会导通，就像一个开关闭合。
而在开漏输出模式时，上方的P-MOS管完全不工作。如果我们控制输出为0，低电平，则P-MOS管关闭，N-MOS管导通，使输出接地，若控制输出为1（它无法直接输出高电平）时，则P-MOS管和N-MOS管都关闭，所以引脚既不输出高电平，也不输出低电平，为高阻态。正常使用时必须外部接上拉电阻，等效电路如下图。
它具有“线与”特性，也就是说若有很多个开漏模式引脚连接到一起时，只有当所有引脚都输出高阻态，才由上拉电阻提供高电平，此高电平的电压为外部上拉电阻所接电源的电压。若其中一个引脚为低电平，那线路就相当于短路接地，使得整条线路都为低电平，0V。
（这里高阻态我理解为逻辑上的、理论上的断路。）
推挽输出模式一般应用在输出电平为0V和3.3V而且需要高速切换开关状态的场合。在STM32应用中，除了必须用开漏模式的场合，一般习惯使用推挽输出模式。
开漏输出一般应用在IIC、SMBUS通信等需要“线与”功能的总线电路中（这里总算明白为什么IIC需要配置开漏了，因为判断ACK需要此功能）。除此之外，还用在电平不匹配的场合，如需要5V的高电平，就可以在外部接上一个上拉电阻，上拉电源为5V，并且把GPIO设置为开漏模式，当输出高阻态时，由上拉电阻和电源向外输出5V。
2.1.3 输出数据寄存器 前面提到的 双 MOS 管结构电路的输入信号，是由 GPIO“输出数据寄存器GPIOx_ODR”提供的，因此我们通过修改输出数据寄存器的值就可以修改 GPIO 引脚的输出电平。而“置位/复位寄存器 GPIOx_BSRR”可以通过修改输出数据寄存器的值从而影响电路的输出。
2.1.4 复用功能输出 “复用功能输出”中的“复用”是指 STM32 的其它片上外设对 GPIO 引脚进行控制，此时 GPIO 引脚用作该外设功能的一部分，算是第二用途。从其它外设引出来的“复用功能输出信号”与 GPIO 本身的数据据寄存器都连接到双 MOS 管结构的输入中，通过图中的梯形结构作为开关切换选择。
例如我们使用 USART 串口通讯时，需要用到某个 GPIO 引脚作为通讯发送引脚，这个时候就可以把该 GPIO 引脚配置成 USART 串口复用功能，由串口外设控制该引脚，发送数据。
2.1.5 输入数据寄存器 看 GPIO 结构框图的上半部分，GPIO 引脚经过内部的上、下拉电阻，可以配置成上/下拉输入，然后再连接到施密特触发器，信号经过触发器后，模拟信号转化为 0、1 的数字信号，然后存储在“输入数据寄存器 GPIOx_IDR”中，通过读取该寄存器就可以了解GPIO 引脚的电平状态。
上拉默认管脚高电平，下拉默认管脚低电平。
2.1.6 复用功能输入 与“复用功能输出”模式类似，在“复用功能输入模式”时，GPIO 引脚的信号传输到STM32 其它片上外设，由该外设读取引脚状态。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3fbc95ec8900c8de77eb381f9f8152e4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0130486fb6d5610bcc629b944259095/" rel="bookmark">
			ClickHouse常见问题排查与解决（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1、Table is in readonly mode (zookeeper path: /clickhouse/tables/iov/t_fault/2)2、Replica /clickhouse/tables/s1/dwd/xxxx/replicas/dt_fault already exists3、数据写入成功，但是数据库并不存在数据4、查询时（非MergeTree表引擎），查出多条重复数据 1、Table is in readonly mode (zookeeper path: /clickhouse/tables/iov/t_fault/2) 异常说明
表示Zookeeper压力过大，表处于只读状态，导致插入失败
分析问题
Zookeeper压力过大原因分析：
写入数据以及频率过高集群中出现Zookeeper节点挂掉，导致压力过大 解决方案：
在zookeeper中将dataLogDir存放目录应该与dataDir分开，可单独采用一套存储设备来存放ZK日志。做好zookeeper集群和clickhouse集群的规划，可以多套zookeeper集群服务一套clickhouse集群。保证Zookeeper集群高可用 2、Replica /clickhouse/tables/s1/dwd/xxxx/replicas/dt_fault already exists 异常说明
删除表 ZK replicas未同步
分析问题
表的元信息会保存到Zookeeper节点上，删除副本以及本地表后，客户端未显示表，但是Zookeeper中的元信息未同步删除，即会出现异常。
解决方案
删除本地表后等待若干时间（根据经验得大概5分钟），再删除副本（分布式表）可以登录ClickHouse服务器进行删除 3、数据写入成功，但是数据库并不存在数据 问题说明
表引擎是MergeTree或者ReplicateMergeTree，所以不存在数据被合并掉。
order by字段包括四个，并且时间在中间，比如：id,name,time,type
分析问题
根据Arthas（是一个Java诊断工具，由阿里巴巴中间件团队开源。它在开发人员中被广泛采用和流行。）一些手段查询到方法的入参以及方法栈的执行情况得知，数据确实入库。
比如同一时刻入参有三条数据进行入库，查询表只有两条数据。
第一种猜测
数据重复导致ClickHouse对重复数据进行幂等性操作，进而把重复数据删除。或者会被ClickH忽略掉此次insert
大概意思是说已经有一个一模一样的数据块了。另外ck没有事务概念，但是为了保证重复插入的insert的幂等性，会检测重复，如果重复则跳过。 本地测验重复数据会部分保留在数据库，部分被删除。 - 第二种猜测 怀疑order by排序字段位置不合理 解决方案 如果想保存重复数据，两种解决办法
关闭幂等性校验。SET insert_deduplicate=0增加一个或者多个冗余字段，保证每条数据不相同 创建表时，order by字段是必须的，但是合理安排order by字段，时间放在所有字段的后边
比如：name,code,type,time等。
4、查询时（非MergeTree表引擎），查出多条重复数据 问题说明
表引擎为：ReplicatedReplacingMergeTree
select * from A join B A.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f0130486fb6d5610bcc629b944259095/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e47546fa1b5414710077106e95daccff/" rel="bookmark">
			【机器视觉】基础知识---相机篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		相机 相机种类相机参数像素/分辨率靶面尺寸像元尺寸传感器（类型及厂家）快门方式帧率色彩模式数据接口镜头接口 简单选型 相机种类 常用的工业相机类型：面阵相机、线阵相机、3D相机
相机参数 像素/分辨率 像素越高，图像越清晰，图像越大
分辨率：2448 X 2048 = 5,013,504 (500W像素)
像素点越多，图像质量越高
靶面尺寸 1.工业相机上标注的靶面尺寸通常指的是相机传感器对角线尺寸。
2. 1/2" 2/3" 1" 等单位是1英寸，但是这里的1英寸换算成毫米是16mm,而不是通常的25.4mm
3. 通常的传感器长宽比为4：3（勾股，斜边则为5）
4. 举例：
注：镜头选型时，镜头像面尺寸 &gt;= 相机靶面尺寸
像元尺寸 像元尺寸：即一个像元的大小。像元大小和像元数（分辨率）共同决定了相机机靶面的大小
像元小，分辨率高，信息量大；反之，分辨率低，信息量小。
传感器（类型及厂家） 类型（芯片）：CMOS（互补金属氧化物半导体）、CCD（电荷耦合器件）
厂家：
Sony：成像质量好
Onsemi：帧率高
Aptina：成本低
Awaiba：线阵专用
Sharp：高性价比
Kodak：高分辨率
快门方式 全局（快、贵）、卷帘（CT要求低，性价比高）
帧率 1秒钟时间里传输的图片的帧数，数值越大，采图越快
色彩模式 彩色：某些缺陷在彩色模式下更清晰，明显
黑白：像素点精度高、尺寸测量选用
像素精度：彩色相机的黑白模式 &lt; 黑白相机
数据接口 用途：传输图像数据
接口：Camera Link、IEEE 1394接口、USB接口、网络接口（GigE）、CoaXPress接口
一般工业常用：网路接口（GigE）、USB接口
网络接口：网线，可使用POE在使用网口传输数据的同时为相机供电
USB3.0：帧率更高、但传输距离受限
镜头接口 镜头接口类型：C接口（C-mount）与CS接口（CS-mount）
区别：CS接口，图像传感器到镜头之间的距离应为12.5 mm；C接口则为17.5 mm
应用场景：工业相机以C接口为主，安防相机以CS接口为主
简单选型 1.节拍要求：CT要求低可选用卷帘快门相机
2.色彩要求：彩色or黑白
3.像素要求：根据需求选择
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e47546fa1b5414710077106e95daccff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3564176e528a3d0e928c6900377a5424/" rel="bookmark">
			Java中的DO、TO、DTO、DAO等含义
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、PO即persistant Object 持久对象：
在O/R 映射（即ORM-ObjectRelationMapping）中出现的概念，通常对应数据模型（数据库），是与数据库汇总的表想影射的java对象，最简单的PO就是对应数据库中某个表中的一条记录，多个记录则用PO的集合。PO中不应该包含任何对数据库的操作。
2、DO即Domain Object 领域对象：
是从现实世界中抽象出来的有形或无形的业务实体。
3、TO即Transfer Object数据传输对象：
不同应用程序之间传输的对象
4、DTO即Data Transfer Object:数据传输对象：
泛指用于展示层与服务层之间的数据传输对象
5、VO即value Object：
通常用于业务层之间的数据传递，和PO一样仅包含数据，但是抽象出的业务对象，可以和表对应，用new 关键字创建，GC回收
6、BO即Business Object 业务对象:
主要是将业务逻辑封装为一个对象，这个对象可以包含一个或多个其他对象，如一个简历中包含教育经历、工作经历、社会关系等，可以将一个教育经历对应一个PO、工作经历对应一个PO、设计关系对应一个PO，然后简历一个对应简历的BO兑现处理简历，每个BO包含这个PO这样处理业务逻辑是，可以针对BO去处理。封装业务逻辑的java对象，通过调用DAO方法，结合PO,VO进行业务操作。
7、POJO即Plain Ordinary Java Object:
简单无规则的java对性，即在一些O/R 映射工具中，能做到维护数据库表记录的PO完全是一个符合Java Bean规范的纯java对象
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/939e40e9adf3295697a31d08daab8d11/" rel="bookmark">
			常见签名算法之SHA256withRSA
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SHA256withRSA 完美工具类 RSAUtils，包含：
1、签名
2、验签
3、公钥加密
4、钥加密私
RSAUtils工具类：
import java.io.File; import java.io.FileInputStream; import java.io.FileNotFoundException; import java.io.IOException; import java.io.InputStream; import java.io.UnsupportedEncodingException; import java.security.InvalidKeyException; import java.security.Key; import java.security.KeyFactory; import java.security.KeyPair; import java.security.KeyPairGenerator; import java.security.KeyStore; import java.security.NoSuchAlgorithmException; import java.security.PrivateKey; import java.security.PublicKey; import java.security.SecureRandom; import java.security.Signature; import java.security.cert.CertificateException; import java.security.cert.CertificateFactory; import java.security.cert.X509Certificate; import java.security.interfaces.RSAPrivateKey; import java.security.interfaces.RSAPublicKey; import java.security.spec.InvalidKeySpecException; import java.security.spec.PKCS8EncodedKeySpec; import java.security.spec.X509EncodedKeySpec; import java.util.Enumeration; import java.util.HashMap; import java.util.Map; import javax.crypto.BadPaddingException; import javax.crypto.Cipher; import javax.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/939e40e9adf3295697a31d08daab8d11/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aee399f150d814191d265846e0bf2e61/" rel="bookmark">
			Python编程从入门到实践（第2版）第三章 列表简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第三章 列表简介 3.1 列表是什么3.1.1 访问列表元素3.1.2 索引从0而不是1开始3.1.3 使用列表中的各个值 3.2 修改、添加和删除元素3.2.1 修改列表元素3.2.2 在列表中添加元素1.在列表末尾添加元素2.在列表中插入元素 3.2.3 从列表中删除元素1.使用del语句删除元素2.使用方法pop()删除元素3.弹出列表中任何位置处的元素4.根据值删除元素 动手试一试 3.3 组织列表3.3.1 使用方法sort()对列表永久排序3.3.2 使用函数sorted()对列表临时排序3.3.3 倒着打印列表3.3.4 确认列表的长度动手试一试 3.1 列表是什么 在Python中，用方括号[]表示列表，并用逗号分隔其中的元素。示例如下，其中包括几个名字：
输入:
names = ['lilei','wangquan','fanfu'] print(names) 输出：
['lilei','wangquan','fanfu'] 3.1.1 访问列表元素 只需要将列表中该元素的位置（索引）告诉Python即可。三个要素如下必不可缺：
列表名称；元素索引；方括号； 下面的代码从列表名字names中提取第一个名字：
输入：
names = ['lilei','wangquan','fanfu'] print(names[0]) 输出：
lilei 3.1.2 索引从0而不是1开始 在Python中，第一个列表元素的索引为0，而不是1。
第二个列表元素的索引为1。
输入：
#访问列表元素、索引从0开始 names = ['lilei','wangquan','fanfu'] print(names[0]) print(names[1]) print(names[2]) print(names[-1]) # 索引-1和2是同样效果，访问最后一个元素 print(names[-2]) # 索引-2和1是同样效果，访问倒数第二个元素 print(names[-3]) # 索引-3和0是同样效果，访问倒数第三个元素 输出：
lilei wangquan fanfu fanfu wangquan lilei 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aee399f150d814191d265846e0bf2e61/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e04cd048c4d5786ae7129a6376876e5c/" rel="bookmark">
			在vue中使用element的el-table和表单元素el-input或el-radio时失效的问题解决办法（已解决）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		el-table嵌套表单元素时，表单元素失效，也就是输入和点击无效时，是因为数据更新失效、试图更新失效。
原因可能是因为加入了新的对象属性，或者数据层级太深，官网有提到前面的情况，新加入的对象属性变更不会带来试图更新。
解决办法就是在表单元素上加入change方法：
&lt;el-table-column label="见面"&gt; &lt;template slot-scope="scope"&gt; &lt;el-radio-group v-model="scope.row.see" @change="chg(scope.$index,scope.row)" &gt; &lt;el-radio-button label="是"&gt;是&lt;/el-radio-button&gt; &lt;el-radio-button label="否"&gt;否&lt;/el-radio-button&gt; &lt;/el-radio-group&gt; &lt;/template&gt; &lt;/el-table-column&gt; 在vue的methods里面做处理：
chg(i,r){ this.$set(this.curcustomers,i,r) }, 这样就OK了！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb84b929a47f27b0e61c332c4c0f5bc5/" rel="bookmark">
			【最小Demo】Java RMI入门 使用Registry、Naming、Zookeeper（注册中心）实现rmi
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考 分布式架构基础:Java RMI详解
GitHub: https://github.com/jayknoxqu/rmi-example
RMI简介 ​ Java RMI，即 远程方法调用(Remote Method Invocation)，一种用于实现远程过程调用(RPC)(Remote procedure call)的Java API， 能直接传输序列化后的Java对象和分布式垃圾收集。它的实现依赖于Java虚拟机(JVM)，因此它仅支持从一个JVM到另一个JVM的调用。
(1) 直接使用Registry实现rmi Registry(注册表)是放置所有服务器对象的命名空间。
每次服务端创建一个对象时，它都会使用bind()或rebind()方法注册该对象。
这些是使用称为绑定名称的唯一名称注册的。
要调用远程对象，客户端需要该对象的引用,如(HelloRegistryFacade)。
即通过服务端绑定的名称(HelloRegistry)从注册表中获取对象(lookup()方法)。
HelloRegistryFacade package com.example.rmi.registry; import java.rmi.Remote; import java.rmi.RemoteException; public interface HelloRegistryFacade extends Remote { String helloWorld(String name) throws RemoteException; } HelloRegistryFacadeImpl package com.example.rmi.registry; import java.rmi.RemoteException; import java.rmi.server.UnicastRemoteObject; public class HelloRegistryFacadeImpl extends UnicastRemoteObject implements HelloRegistryFacade { public HelloRegistryFacadeImpl() throws RemoteException { super(); } @Override public String helloWorld(String name) { return "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cb84b929a47f27b0e61c332c4c0f5bc5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94dd0c8d0ec6683729d929277d783f34/" rel="bookmark">
			【 攻城略地 】vue3 &#43; video.js播放m3u8视频流格式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		video.js video.js是一个通用的在网页上嵌入视频播放器的JS库，video.js自动检测浏览器对HTML5的支持情况，如果不支持HTML5则自动使用Flash播放器。
文档： https://github.com/videojs/video.js
videojs中文文档详解_谢泽的网络日志-CSDN博客_video.js
安装： $ npm install --save video.js videojs-contrib-hls 使用： 1. 基础使用
// VideoComponentA.vue &lt;template&gt; // id：用于获取video对象 // class：video-js vjs-default-skin为video内置的样式名称，样式可根据具体项目进行调整 // autoplay：自动播放 // muted：设置静音。在最新版的Chrome浏览器（以及所有以Chromium为内核的浏览器）中，已不再允许自动播放音频和视频，设置静音是一种hack手段，参考：https://www.mzwu.com/article.asp?id=4411 // preload：提前加载 &lt;video id="my-video" class="video-js vjs-default-skin" autoplay muted preload="auto"&gt; // src：视频流地址 // type：视频类型 &lt;source src="http://1252093142.vod2.myqcloud.com/4704461fvodcq1252093142/f865d8a05285890787810776469/playlist.f3.m3u8" type="application/x-mpegURL" style='width: 100%;height: 100%'&gt; &lt;/video&gt; &lt;/template&gt; &lt;script lang="ts"&gt; // 引入videojs以及样式文件 import videojs from 'video.js/dist/video.min' import 'video.js/dist/video-js.min.css' import { defineComponent, onMounted } from "vue" setup() { // 在onMounted阶段进行初始化 onMounted(() =&gt; { initVideoSourc() }) function initVideoSourc() { videojs('my-video', { bigPlayButton: false, textTrackDisplay: false, posterImage: false, errorDisplay: false, controlBar: true, // .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/94dd0c8d0ec6683729d929277d783f34/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e0d8d89b45f1defc70d35127e90e608/" rel="bookmark">
			Java爬虫爬取京东商城
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、任务： 旨在通过使用java爬虫，提取网络中的各种商品信息，并收集的商品信息建立统一数据模型存储数据，通过数据模型描述商品的基本属性。如spu，sku，商品描述，价格等信息，同时需要剔除非必要信息，做到精准分析。根据所获取的信息提供商品展示页面，通过搜索，得到商品数据信息。抓取商品数据，建立统一数据模型，模型的可扩展性，商品数据展示。
目的：该项目有利于简单理解java的爬虫过程，spring boot简单的项目调试，调用，映射方式，数据库连接，帮助理解的前后端交互原理。
二、类及数据的设计 2.1项目的开发环境 2.2系统功能结构设计 该程序主要通过调用webmagic使用爬虫功能爬取数据，建立数据模型，利用MySQL存储数据。查询调用数据库内容，模型的可扩展性，通过html/css提供web页面展示。
2.2.1数据爬取，数据模型建立 WebMagic：
WebMagic的结构分为Downloader、PageProcessor、Scheduler、Pipeline四大组件，并由Spider将它们彼此组织起来。
1）Downloader：负责从互联网上下载页面，以便后续处理。WebMagic默认使用了Apache HttpClient作为下载工具。
2）PageProcessor：负责解析页面，抽取有用信息，以及发现新的链接。WebMagic使用Jsoup作为HTML解析工具，并基于其开发了解析XPath的工具Xsoup。在这四个组件中，PageProcessor对于每个站点每个页面都不一样，是需要使用者定制的部分。
3）Scheduler：负责管理待抓取的URL，以及一些去重的工作。WebMagic默认提供了JDK的内存队列来管理URL，并用集合来进行去重。也支持使用Redis进行分布式管理。除非项目有一些特殊的分布式需求，否则无需自己定制Scheduler。
4）Pipeline：负责抽取结果的处理，包括计算、持久化到文件、数据库等。WebMagic默认提供了“输出到控制台”和“保存到文件”两种结果处理方案。Pipeline定义了结果保存的方式，如果你要保存到指定数据库，则需要编写对应的Pipeline。对于一类需求一般只需编写一个Pipeline。
Selenium：
Selenium是一个Web的自动化测试工具，可以根据我们的指令，使用代码控制浏览器，让浏览器自动加载页面，获取需要的数据，甚至页面截屏，或者判断网站上某些动作是否发生，支持主流的浏览器
该程序使用Downloader、PageProcessor、Pipeline，Spider组件进行爬虫，建立数据模型。通过selenium对谷歌无头浏览器进行自动化操作。
1、定时任务
在springboot工程中使用定时器。在工程中创建一个普通的类，添加注解@Component，
在定义方法上使用@Scheduled注解标注，配置定期执行时间，在spring boot工程的引导类上添加@EnableScheduling注解。
2、设置代理
使用代理服务器发起请求，防止反爬策略封ip
代理服务器流程：
爬虫服务器 -&gt; 代理服务器 -&gt; 目标服务器
目标服务器 -&gt; 代理服务器 -&gt; 爬虫服务器 -&gt;解析数据
可用的免费代理：
免费私密代理 - 米扑代理
http://www.xiladaili.com/gaoni/
3、使用selenium+无头浏览器抓取数据
通过Maven添加Selenium依赖。Selenium是一个前端的测试框架，通过Selenium使用代码控制浏览器。
无头浏览器：没有界面的浏览器，解析js。得到一些默认不到的数据。用于各类测试场景，在任何给定页面上可采取的频繁重复的操作，反复测试。
4、使用浏览器渲染，抓取京东商城的数据并保存
1）PageProcess解析html
1. 判断是列表页面还是详细页面 2. 如果是列表页面
a、解析列表中的商品数据，去sku和spu，封装成一个对象，传递给pipeline
b、解析商品的链接地址，把地址添加到访问队列中
c、翻页处理，设置固定url：Enterprise Cybersecurity Solutions, Services &amp; Training | Proofpoint US 添加一个附件：当前请求的url
3. 如果是详细页面
a、解析商品的详细信息
b、把详细信息封装成一个商品对象
c、传递给pipeline
2）Downloader下载页面
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e0d8d89b45f1defc70d35127e90e608/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/affd9ad4a3e0ae42b7dfa047df73a8a0/" rel="bookmark">
			Java 日期类 Date
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
构造函数：
常用方法：
使用DateFormat格式化日期
使用SimpleDateFormat格式化日期
日期与日期格式字符串的相互转化：
Calendar类
Calendar与Date都是表示日期的工具类，他们之间可以相互转换。
Calendar类提供的常用方法：
构造函数： Date（int year,int month ,int day）已经过时
常用Date（long date）：从标准时间起指定时间的毫秒数
标准时间：1970-1-1-8：00
常用方法： Date类中日期和毫秒的相互转换：
1.日期获取毫秒值
Date date3 = new Date();
long time = date3.getTime();
2.把一个毫秒值转换为Date
构造方法setTime(long time)方法 使用DateFormat格式化日期 DateFormat是一个抽象类，它也提供了几个工厂方法用于获取DateFormat对象。返回的都是DateFormat对象的子类实例，是同一个类型的实例。
getDateInstance()：返回一个日期格式器，只对日期进行格式化。getTimeInstance()：返回一个时间格式器，只对时间进行格式化。getDateTimeInstance()：返回一个日期、时间格式器，既对时间又对日期进行格式化。getInstance()：返回一个默认的系统相关的日期、时间格式器。 举例：
public static void main(String[] args) throws Exception{ DateFormat format = DateFormat.getInstance(); System.out.println(format.getClass()); format = DateFormat.getDateInstance(); System.out.println(format.getClass()); format = DateFormat.getTimeInstance(); System.out.println(format.getClass()); } 输出：
虽然返回的都是同一个对象类型的实例，但是根据不同的工厂方法，返回的对象在格式化时间对象时，处理不同部分的信息。
使用SimpleDateFormat格式化日期 SimpleDateFormat是DateFormat的子类，是一种更简单的日期格式，以我们指定的格式对日期进行格式化。
举例：
public static void main(String[] args) throws Exception{ Date date = new Date(); SimpleDateFormat simple = new SimpleDateFormat("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/affd9ad4a3e0ae42b7dfa047df73a8a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9ac7181513b7ec6553297db27dee3c8/" rel="bookmark">
			配置YOLOv5-1.0版本，自己调试cpu版本环境时出现的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一：下载安装包先是安装了cpu版本pytorch1.4.0，链接地址如下：
https://download.pytorch.org/whl/torch_stable.html 下载相应版本的即可，如我的电脑anaconda下的yolov5的虚拟环境python=3.6，电脑时64位的，故下载时选了
torch-1.4.0+cpu-cp36-cp36m-win_amd64.whl
然后在激活环境后，切换到这个安装包所在的文件下，然后执行pip安装即可
pip install torch-1.4.0+cpu-cp36-cp36m-win_amd64.whl
二：当我以同样的方式安装torchvision时出现了问题，
pip install torchvision-0.5.0+cpu-cp36-cp36m-win_amd64.whl
报错
ERROR: Exception:
Traceback (most recent call last):
File "C:\ProgramData\Anaconda3\envs\yolov5\lib\site-packages\pip\_internal\cli\base_command.py", line 173, in _main
status = self.run(options, args)
File "C:\ProgramData\Anaconda3\envs\yolov5\lib\site-packages\pip\_internal\cli\req_command.py", line 203, in wrapper
return func(self, options, args)
File "C:\ProgramData\Anaconda3\envs\yolov5\lib\site-packages\pip\_internal\commands\install.py", line 316, in run
reqs, check_supported_wheels=not options.target_dir
File "C:\ProgramData\Anaconda3\envs\yolov5\lib\site-packages\pip\_internal\resolution\resolvelib\resolver.py", line 95, in resolve
collected.requirements, max_rounds=try_to_avoid_resolution_too_deep
File "C:\ProgramData\Anaconda3\envs\yolov5\lib\site-packages\pip\_vendor\resolvelib\resolvers.py", line 472, in resolve
state = resolution.resolve(requirements, max_rounds=max_rounds)
File "C:\ProgramData\Anaconda3\envs\yolov5\lib\site-packages\pip\_vendor\resolvelib\resolvers.py", line 341, in resolve
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b9ac7181513b7ec6553297db27dee3c8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c22ccb9ec0519206fd395de43183ed8/" rel="bookmark">
			初识while循环语句
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、
（1）用while循环语句输出1-10的数字
代码如下
#define _CRT_SECURE_NO_WARNINGS #include &lt;stdio.h&gt; int main() { int i = 1; while (i &lt;= 10) { printf("%d", i); i++; } } 输出结果如下
之前在分支语句中了解到了关键词break和 continue在程序中的作用，那么这两个关键词在while语句中有什么作用呢？
（2）break关键词在while循环语句中作用
在上述程序段中加入break，代码如下
#define _CRT_SECURE_NO_WARNINGS #include &lt;stdio.h&gt; int main() { int i = 1; while (i &lt;= 10) { if(i==6) break; printf("%d", i); i++; } } 输出结果如下
可以看见break在while循环语句中作用是用于永久的终止循环。
(3）在while循环语句中加入continue关键字
将上述代码中break换成continue，代码如下
#define _CRT_SECURE_NO_WARNINGS #include &lt;stdio.h&gt; int main() { int i = 1; while (i &lt;= 10) { if(i==6) continue; printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2c22ccb9ec0519206fd395de43183ed8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/899832f456e1ddb128f126d30a2ae03e/" rel="bookmark">
			Modbus RTU和Modbus TCP的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Modbus通信协议具有多个变种，支持串口（主要是RS-485总线），以太网多个版本，其中最著名的是Modbus RTU，Modbus ASCII和Modbus TCP三种。在工业现场一般都是采用Modbus RTU协议，一般大家说的基于串口通信的Modbus通信协议都是指Modbus RTU通信协议。与Modbus RTU协议相比较，Modbus TCP协议则是在RTU协议上加一个MBAP报文头，并且由于TCP是基于可靠连接的服务，RTU协议中的CRC校验码就不再需要，所以在Modbus TCP协议中是没有CRC校验码的，所以就常用一句比较通俗的话来说：Modbus TCP协议就是Modbus RTU协议在前面加上五个0以及一个6，然后去掉两个CRC校验码字节就OK。虽然这句话说得不是特别准确，但是也基本上把RTU与TCP之间的区别说得比较清楚了。
Modbus的功能码有：
功能码含义功能码含义0x01读线圈0x04读输入寄存器0x05写单个线圈0x03读保持寄存器0x0F写多个线圈0x06写单个保持寄存器0x02读离散量输入0x10写多个保持寄存器 一、Modbus RTU RTU协议中的指令由地址码(一个字节），功能码（一个字节），起始地址（两个字节），数据（N个字节），校验码（两个字节）五个部分组成。数据由数据长度（两个字节，表示的是寄存器个数，假定为M）和数据正文（M乘以2个字节）组成。
发：01 03 01 8E 00 04 25 DE //读（0x03），从寄存器地址01 8E 开始读，读4个寄存器00 04
回：01 03 08 00 01 00 01 00 01 00 01 28 D7 // 08表示数据长度 ，00 01 00 01 00 01 00 01读到的数据
发：00 10 00 20 00 01 02 00 00 AC A0 // 写（0x10），从寄存器地址 00 20开始写，写一个寄存器 00 01，写入值 00 00
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/899832f456e1ddb128f126d30a2ae03e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9b3b4db5de8c7967bfe51ec4e9e9f33/" rel="bookmark">
			【STM32】HAL库 STM32G474定时器输入捕获获取频率和占空比 IDE(STM32CubeIDE)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一.输入捕获概念二.基于NUCLEO-G474RE开发板新建工程2.1 打开 STM32CubeMX 软件，新建工程.2.2 选择开发板（芯片）2.3 配置TIM12.4 配置TIM22.5配置一下时钟树.2.6生成代码. 三.编写代码四.调试结果 一.输入捕获概念 输入捕获模式可以用来测量脉冲宽度或者测量频率。
二.基于NUCLEO-G474RE开发板新建工程 2.1 打开 STM32CubeMX 软件，新建工程. 我手里有开发板所以选择基于开发板。
2.2 选择开发板（芯片） 我这里选择的是我的开发板NUCLEO-G474RE，少去一些步骤。
2.3 配置TIM1 配置TIM1产生100kHz的PWM,对应管脚PC0。
F= Tclk/[(psc+1) * (cnt+1)] = 170MHz/[1*1700] = 100kHz。
2.4 配置TIM2 参考自数据手册 PWM input mode
输入捕获的配置
2.5配置一下时钟树. 2.6生成代码. 三.编写代码 定义变量 /* USER CODE BEGIN PV */ uint16_t PRE1=1700; uint16_t CMP1=500; uint32_t capture_Buf[4] = {0}; //存放计数 uint32_t capture_Buf1[4] = {0}; //存放计数 uint8_t capture_Cnt = 0; //状标志位 float duty_cycle; //占空 uint32_t frequency; //频率 /* USER CODE END PV */ 开启定时器TIM1和TIM2 /* USER CODE BEGIN 2 */ HAL_TIM_PWM_Start(&amp;htim1, TIM_CHANNEL_1); HAL_TIM_IC_Start_IT(&amp;htim2, TIM_CHANNEL_1); //启动频率捕获（上升沿捕获） HAL_TIM_IC_Start_IT(&amp;htim2, TIM_CHANNEL_2); //启动频率捕获（下降沿捕获） /* USER CODE END 2 */ while 循环中调节TIM1 PWM的频率和占空比 /* USER CODE BEGIN 3 */ //TIM1-&gt;PSC=0; TIM1-&gt;ARR=PRE1-1; TIM1-&gt;CCR1=CMP1-1; 核心代码（中断回调函数） /* USER CODE BEGIN 4 */ void HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim) { // 获取频率 if(TIM2==htim-&gt;Instance) { if (htim-&gt;Channel == HAL_TIM_ACTIVE_CHANNEL_1 ) { if(capture_Cnt == 0) { /* Get the 1st Input Capture value */ //capture_Buf[0] = HAL_TIM_ReadCapturedValue(htim, TIM_CHANNEL_1); assert_param(IS_TIM_CC1_INSTANCE(htim2-&gt;Instance)); capture_Buf[0] = htim-&gt;Instance-&gt;CCR1; capture_Buf1[0] = htim-&gt;Instance-&gt;CCR2; capture_Cnt = 1; } else if(capture_Cnt == 1) { /* Get the 2nd Input Capture value */ // capture_Buf[2] = HAL_TIM_ReadCapturedValue(htim, TIM_CHANNEL_1); assert_param(IS_TIM_CC1_INSTANCE(htim2-&gt;Instance)); capture_Buf[2] = htim-&gt;Instance-&gt;CCR1; capture_Buf1[2] = htim-&gt;Instance-&gt;CCR2; HAL_TIM_IC_Start_IT(&amp;htim2, TIM_CHANNEL_1); //启动频率捕获 /* Capture computation */ if (capture_Buf[2] &gt; capture_Buf[0]) { capture_Buf[3] = (capture_Buf[2] - capture_Buf[0]); capture_Buf1[3] = (capture_Buf1[2] - capture_Buf[0]); } else if (capture_Buf[2] &lt; capture_Buf[0]) { /* 0xFFFF is max TIM1_CCRx value */ capture_Buf[3] = ((0xFFFF - capture_Buf[0]) + capture_Buf[1]) + 1; capture_Buf1[3] = ((0xFFFF - capture_Buf[0]) + capture_Buf1[1]) + 1; } else { /* If capture values are equal, we have reached the limit of frequency measures */ Error_Handler(); } /* Frequency computation: for this example TIMx (TIM1) is clocked by APB2Clk */ frequency = HAL_RCC_GetPCLK2Freq() / capture_Buf[3]; duty_cycle=capture_Buf1[3]*100/capture_Buf[3]; capture_Cnt = 0; } } } } /* USER CODE END 4 */ 四.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e9b3b4db5de8c7967bfe51ec4e9e9f33/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0bed0673a0f25536ab1cbb11e1be4d4a/" rel="bookmark">
			Spring源码之@Configuration注解解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.前言 ​ Spring注解开发中，我们只需求要类上加上@Configuration注解，然后在类中的方法上面加上@Bean注解即可完成Spring Bean组件的注册。相较于之前的xml配置文件定义注册组件简化了非常多。那么Spring底层是如何处理@Configuration注解来完成Spring组件的注册，下面通过源码一步一步进行分析。
2.准备工作 Spring版本：2.2.13.RELEASE
源码中涉及的类：
ConfigurationClassPostProcessorConfigurationClassParserConfigurationClassBeanMethodConfigurationClassBeanDefinitionReaderConfigurationClassEnhancerConfigurationClassUtils 说明：文中统一将被@Configuration注解标注的类称为配置类
3.涉及相关类说明 ConfigurationClassPostProcessor 配置类的后知处理器，其中实现了BeanDefinitionRegistryPostProcessor接口，可以拿到BeanDefinitionRegistry对象手动注册组件，也是整个解析流程的入口 ConfigurationClassParser 配置类解析器，解析配置类，封装成一个个的ConfigurationClass对象 ConfigurationClass 配置类经解析后的实体对象 BeanMethod 被@Bean注解标注的方法解析后的实体对象 ConfigurationClassBeanDefinitionReader 用于读取注册配置类中定义的组件 ConfigurationClassEnhancer 对配置类进行代理增强的角色类 ConfigurationClassUtils 配置类解析相关的工具类 4.源码流程分析 ConfigurationClassPostProcessor作为入口类，类的层次结构入上图，我们只需要关心BeanDefinitionRegistryPostProcessor和BeanFactoryPostProcessor两个接口的回调方法BeanFactoryPostProcessor和postProcessBeanFactory。
两个方法的具体实现如下，可以看到两个方法的内部都调用了processConfigBeanDefinitions方法，下面针对此方法进行分析
1 public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) { 2 int registryId = System.identityHashCode(registry); 3 if (this.registriesPostProcessed.contains(registryId)) { 4 throw new IllegalStateException( 5 "postProcessBeanDefinitionRegistry already called on this post-processor against " + registry); 6 } 7 if (this.factoriesPostProcessed.contains(registryId)) { 8 throw new IllegalStateException( 9 "postProcessBeanFactory already called on this post-processor against "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0bed0673a0f25536ab1cbb11e1be4d4a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ab6a9c067cdf0b05b912c423c9dfc96/" rel="bookmark">
			Java方法调用应用操作题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问：一个景区根据游人的年龄收取不同价格的门票。请编写游人类，根据年龄段决定能够购买的门票价格并输出
思路：写类的属性很简单，定义姓名和年龄即可
方法考的难一些，可以先做一下程序分析，把思路捋清，这样才能用代码实现出来。这里需先定好不同年龄段收取的票价，然后套用循环语句去做，与此同时也不要忽略细节。
类
public class Ticket { String name; int age; public void BuyT() { do { Scanner input = new Scanner(System.in); System.out.print("请输入姓名： "); name = input.next(); if(name.equals("n")){ //当输入姓名为n时，输出退出程序 System.out.println("退出程序！"); return; //退出程序即跳出方法（语句不懂易混淆见上一篇文章） } System.out.print("请输入年龄： "); age = input.nextInt(); if (age &lt; 10) { System.out.println(name + "的年龄为" + age + "，门票免费！"); } else { //我这里定的是年龄小于10门票免费，其余一律是20元 System.out.println(name + "的年龄为" + age + "，门票价格为：20元"); } } while (!name.equals("n")); //当输入不为n时，执行操作 } } 测试类
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2ab6a9c067cdf0b05b912c423c9dfc96/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/735a7217bf2b674760783544e6b8ca8a/" rel="bookmark">
			Java基础--单重循环操作题（例题说明易错点）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问：一张纸的厚度大约是0.08mm，对折多少次之后能达到或超过珠穆朗玛峰的高度（8848.13米） 这里需要我们求的是对折的次数，那 在循环次数不确定的情况，通常选用while或do-while循环
我们选取while进行操作，已知高度和厚度，可以像下图中的high一样进行一下定义，也可以直接像厚度一样直接输入数值，影响不大。
最重要的是思路，很明显这题是以 比较对折后的厚度和山的高度 作为循环条件的，接着咱们只要 列出对折后的厚度的运算公式 以及 循环的条件改变规律 就可以了
注意：如果公式这里你也和我一样采用的 幂运算，需要注意的就是不能直接输入2^n，而是要用Math.pow(2,n)表示！(Java的魅力)
最后！循环的条件改变规律 这里我们也需要留意一下，因为我们是先 判断是否满足循环条件再进行的改变，所以最后所求得到的数值是 改变后的但没有执行操作的！
因此，要把最后的结果再减去一次条件改变的数值，咱们这里是减去1，一定不要漏了这一步！
* 幂运算的公式：Math.pow(底数,幂)
问：一个整数，它加上100后是一个完全平方数，再加上168又是一个完全平方数，请问该数是多少？ 程序分析：在10万以内判断，另外由这个数的开方数自乘得到平方数，进行比较
在循环次数确定的时候，通常选用for循环
有题目中可以知道循环的这个数的范围是在0~10万，所以我们for循环里面，就让这个数的初始值为0，范围就是小于等于10万，每次自增
紧接着我们就可以列出下面的两行等式，也就是说这个数加上100以及268之后，给它们分别开根号，得到值的表达式
后面我们需要再用到选择结构if，条件为给它们开根号后得到的值都为整数
则输出该数
注意：因为我们给一个数开根号后该数不一定为整数所以要先用double，然后我们再在if里面加上条件，如果得到的数为整数的话，则巴拉巴拉
小括号里加int就可以进行强制类型转换了！
* 这里又学到了java里的一个新表达式：
给一个数开根号：Math.sqrt(i)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a96030b8ff9c305fecfbbdf0f910ccbe/" rel="bookmark">
			Linux性能优化（一）——stress压力测试工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、stress简介 1、stress简介 stress是Linux的一个压力测试工具，可以对CPU、Memory、IO、磁盘进行压力测试。
2、stress安装 安装：
sudo yum install stress 二、stress使用 1、stress命令 stress [OPTION [ARG]] -c, --cpu N：产生N个进程，每个进程都循环调用sqrt函数产生CPU压力。
-i, --io N：产生N个进程，每个进程循环调用sync将内存缓冲区内容写到磁盘上，产生IO压力。通过系统调用sync刷新内存缓冲区数据到磁盘中，以确保同步。如果缓冲区内数据较少，写到磁盘中的数据也较少，不会产生IO压力。在SSD磁盘环境中尤为明显，很可能iowait总是0，却因为大量调用系统调用sync，导致系统CPU使用率sys 升高。
-m, --vm N：产生N个进程，每个进程循环调用malloc/free函数分配和释放内存。
--vm-bytes B：指定分配内存的大小
--vm-stride B：不断的给部分内存赋值，让COW(Copy On Write)发生
--vm-hang N ：指示每个消耗内存的进程在分配到内存后转入睡眠状态N秒，然后释放内存，一直重复执行这个过程
--vm-keep：一直占用内存，区别于不断的释放和重新分配(默认是不断释放并重新分配内存)
-d, --hdd N：产生N个不断执行write和unlink函数的进程(创建文件，写入内容，删除文件)
--hdd-bytes B：指定文件大小
--hdd-noclean：不要将写入随机ASCII数据的文件Unlink
-t, --timeout N：在N秒后结束程序 --backoff N：等待N微秒后开始运行
-q, --quiet：程序在运行的过程中不输出信息
-n, --dry-run：输出程序会做什么而并不实际执行相关的操作
--version：显示版本号
-v, --verbose：显示详细的信息
2、CPU测试 stress --cpu 2 --timeout 60 开启2个CPU进程执行sqrt计算，60秒后结束
3、IO测试 stress --io 2 --timeout 60s 开启2个IO进程，执行sync系统调用，刷新内存缓冲区到磁盘
使用stress无法模拟iowait升高，但sys升高。stress -i参数表示通过系统调用sync来模拟IO问题，但sync是刷新内存缓冲区数据到磁盘中，以确保同步。如果内存缓冲区内没多少数据，读写到磁盘中的数据也就不多，没法产生IO压力。使用SSD磁盘的环境中尤为明显，iowait一直为0，但因为大量系统调用，导致系统CPU使用率sys升高。
stress --io 2 --hdd 2 --timeout 60s 开启2个IO进程，2个磁盘IO进程
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a96030b8ff9c305fecfbbdf0f910ccbe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f6532a920add8b3d29936174a37ce91/" rel="bookmark">
			pytorch（仅供自己参考勿看）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、安装Anaconda 下载pytorch前最好先安装Anaconda，可以按照以下方法下载：
https://blog.csdn.net/weixin_50888378/article/details/109022585
二、安装pytorch 1、安装好Anaconda后，在电脑搜索栏搜索Anaconda，点击进入Anaconda Prompt。
2、换源
在Anaconda终端输入：
conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/
conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge
conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/msys2/
像这样：
3、创建python3.7的虚拟环境，名叫pytorch
在anaconda的终端里输入：
conda create -n pytorch python=3.7
出现下图这个选项时，这里选y
4、使清华源可见
输入 conda config --set show_channel_urls yes
5、执行红框中的 conda activate pytorch
如图
6、由于不翻墙下载太慢，这里选择离线下载，下载包可到官网查看对应版本：
官网查看pytorch与torchvision对应版本：https://pytorch.org/get-started/previous-versions/
下载地址：https://download.pytorch.org/whl/torch_stable.html
下载完成后，将三个包放入终端显示的当前文件夹下（如我的终端显示的是c盘-&gt;Users（用户）-&gt;86151）
7、在Anaconda终端依次输入:
pip install 你下载的torch名
pip install torchaudio-0.7.2-cp37-none-win_amd64.whl（你下载的torchaudio名）
pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple
pip install torchvision-0.8.2+cpu-cp37-cp37m-win_amd64.whl（你下载的torchvision名）
注意：最好用移动数据下载，wlan可能会很慢。
到此为止pytorch安装完毕。在这里感谢QQ里某位大佬，这是他的安装方法，我只是将这个方法记录下来。
在pycharm里可能会出现找不到torchvision的错误问题，是因为没有设置pycharm的环境 可通过https://www.cnblogs.com/jaysonteng/p/12554161.html解决。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0a2ad382926613752432bc4a9b78d04/" rel="bookmark">
			sharding-jdbc使用实战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用背景 项目中使用中表数据过大，需要分表操作。并且在项目业务中许多场景下单表数据过大时，也需要分表操作，这次尝试在某一组件内引入shsharding-jdbc，并逐步形成项目通用组件。
组件简介 在spring环境中引入sharding-jdbc，相当于dataSource组件替换成shsharding-jdbc的dataSource，完成原有的数据源替换，查询以及插入时会使用sharding-jdbc的数据源做相应的分片操作，并生成sql，完成增删改操作。
如果引用数据源换成了新的，那么就是替换掉原有的数据源，原有数据源的一些sql可能会产生影响，那么项目中需要尝试多数据源切换，以满足不需要分库分表的数据使用原有数据源。
项目引入 pom配置
&lt;!--&lt;dependency&gt;--&gt; &lt;!--&lt;groupId&gt;com.alibaba&lt;/groupId&gt;--&gt; &lt;!--&lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;--&gt; &lt;!--&lt;version&gt;${druid-spring-boot-starter}&lt;/version&gt;--&gt; &lt;!--&lt;/dependency&gt;--&gt; &lt;!--去除连接池自启动，将使用新的数据源组件，但是连接池不变--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;${druid-version}&lt;/version&gt; &lt;/dependency&gt; &lt;!--sharding-jdbc的启动包引入--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.shardingsphere&lt;/groupId&gt; &lt;artifactId&gt;shardingsphere-jdbc-core-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;${shardingsphere.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!--多数据源插件引入--&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;dynamic-datasource-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;${dynamic-datasource-spring-boot-starter}&lt;/version&gt; &lt;/dependency&gt; 启动配置
@Configuration @AutoConfigureBefore({DynamicDataSourceAutoConfiguration.class, SpringBootConfiguration.class}) public class DataSourceConfiguration { /** * 动态数据源配置项 */ @Autowired private DynamicDataSourceProperties properties; @Lazy @Resource AbstractDataSourceAdapter shardingDataSource; @Bean public DynamicDataSourceProvider dynamicDataSourceProvider() { Map&lt;String, DataSourceProperty&gt; datasourceMap = properties.getDatasource(); return new AbstractDataSourceProvider() { @Override public Map&lt;String, DataSource&gt; loadDataSources() { Map&lt;String, DataSource&gt; dataSourceMap = createDataSourceMap(datasourceMap); // 将 shardingjdbc 管理的数据源也交给动态数据源管理 dataSourceMap.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c0a2ad382926613752432bc4a9b78d04/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fac124e9d394846f35c0c0717475502c/" rel="bookmark">
			记一次低级错误：关于mybatis和mybatis-plus的路径扫描配置写法问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一个项目采用SpringBoot和Mybatis-plus进行开发，测试环境验证通过，上线，出问题了，报错：
大致意思就是找不到表，经过验证，表的确存在，这么一看，只能是扫描不到XML文件，估计配置文件有问题，一看配置文件，自己都没想到，犯了这么一个低级错误：
#mybatis 设置 mybatis.mapper-locations=classpath:mybatis/mapper/*.xml mybatis.config-location=classpath:mybatis/config/mybatis-config.xml 乍一看，是没毛病的，但是需要注意的是，Mybatis和Mybatis-plus配置xml文件的扫描路径写法是不一样的，详见：
============正确写法========= #mybatis写法 mybatis.mapper-locations=classpath:mybatis/mapper/*.xml mybatis.config-location=classpath:mybatis/config/mybatis-config.xml #mybatis-plus写法 mybatis-plus.mapper-locations=classpath:mybatis/mapper/*.xml mybatis-plus.config-location=classpath:mybatis/config/mybatis-config.xml 配置文件是properties文件 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4901d1b76a4ba481a1ab667094744c0a/" rel="bookmark">
			element ui ——form表单验证的之对于上传图片的验证
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由于 饿了吗 ui 对于上传图片是没有这种格式的验证，就要自己手动配一下。
首先配一个自定义的验证规则
var validatePass = (rule, value, callback) =&gt; { if (this.logo.length == 0) { callback(new Error('请上传图片')) } else { callback() } } 这里我的上传图片的列表是和logo字段绑定的
所以当logo长度为0时，就是没有上传图片
当但是这样的话，在上传图片后不会自动验证，所以要在上传图片成功后，触发这个验证
this.$refs.ruleData.validateField('fileList') //对图片重新验证 对这个验证重新进行效验
在对于点击删除事件的方法时，当图片列表的长度为0时，再次触发图的验证。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1bf852260e0434f84c94f639abb23e4d/" rel="bookmark">
			洛谷P1152 欢乐的跳(sort函数排序，abs绝对值c&#43;&#43;)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目描述 一个n个元素的整数数组，如果数组两个连续元素之间差的绝对值包括了[1,n−1]之间的所有整数，则称之符合“欢乐的跳”，如数组1423符合“欢乐的跳”，因为差的绝对值分别为：3,2,1。
给定一个数组，你的任务是判断该数组是否符合“欢乐的跳”。
输入格式 每组测试数据第一行以一个整数n(1≤n≤1000)开始，接下来n个空格隔开的在[-10^8,10^8]之间的整数。
输出格式 对于每组测试数据，输出一行若该数组符合“欢乐的跳”则输出"Jolly"，否则输出"Not jolly"。
#include&lt;iostream&gt; #include&lt;algorithm&gt;//sort函数属于该头文件 #include&lt;cmath&gt;//求绝对值函数abs属于该头文件 using namespace std; main() { int n,i; cin&gt;&gt;n; int a[n+1],b[n]; for(i=1;i&lt;=n;i++)//存储n个元素 { cin&gt;&gt;a[i]; } for(i=1;i&lt;n;i++)//存储n-1个元素 { b[i]=abs(a[i+1]-a[i]); } sort(b+1,b+n);//默认从小到大，个人认为也是该题核心 for(i=1;i&lt;n;i++) { if(b[i]!=i)//逐一判断 { cout&lt;&lt;"Not jolly\n"; return 0; } } cout&lt;&lt;"Jolly\n"; return 0; } ps：其实可能会考虑到用桶排法，但是两个数差值可能会很大，数组容量设置超出限制，比如10000和-10000
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d4f8f5008da221cba968ed2d936b541/" rel="bookmark">
			网络数据包（.pacp）文件格式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、前言 经常使用网络嗅探工具，抓取通过特定网卡上的数据包，用来分析网络问题。例如，使用Wireshark工具抓取电脑上的一张网卡的数据并保存，会发现生成的文件是.pacp格式。
2、pacp文件格式 文件头+ 数据包头+数据 +数据包头+数据 +数据包头+数据 +数据包头+数据+.........
数据包格式 结构名称
字节数作用 文件头
Global Header 24整个数据流文件，只会有一个 Global Header，它定义了本文件的读取规则、最大储存长度限制等内容； 数据包头
Packet Header
16 Packet Header可以有多个，每个Packet Header后面会跟着一串Packet Data，Packet Header定义了Packet Data的长度、时间戳等信息。 1、Global Header 结构 文件头结构有7个成员属性，下面结构体为nacp库中定义的结构 struct pcap_file_header { bpf_u_int32 magic; u_short version_major; u_short version_minor; bpf_int32 thiszone;	/* gmt to local correction; this is always 0 */ bpf_u_int32 sigfigs;	/* accuracy of timestamps; this is always 0 */ bpf_u_int32 snaplen;	/* max length saved portion of each pkt */ bpf_u_int32 linktype;	/* data link type (LINKTYPE_*) */ }; Magic：4Byte：标记文件开始，并用来识别文件自己和字节顺序。0xa1b2c3d4用来表示按照原来的顺序读取，0xd4c3b2a1表示下面的字节都要交换顺序读取。考虑到计算机内存的存储结构，一般会采用0xd4c3b2a1，即所有字节都需要交换顺序读取。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5d4f8f5008da221cba968ed2d936b541/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/504e2f0800b4cdba57c9367b4754865b/" rel="bookmark">
			games101（渲染管线，光栅化-总览）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		渲染管线（graphics pipeline ）是按照物体的顺序渲染（object-order graphics）的重要部分，和光线追踪不同的思路不同。
在对于渲染管线的整体表述方面，我认为虎书的表述相较于games101的表述更为清楚。
虎书中这样定义渲染管线和光栅化：
光栅化：找到图片中所有被几何的物体（图元）所影响的像素的过程称为光栅化。
//关于图元primitive，实在是找不到好的翻译，不过指的是几何物体的点线面，接着参考了网上的说法，我们就称为图元吧
渲染管线：根据需要的顺序操作，从物体开始到更改图片中像素的过程更为渲染管线。
不过相对于虎书，games101在渲染管线的展示上做的还是比较好的。
按照虎书的描述，大概是这么个流程。
其中vretex-processing中会同时处理其他需要的信息
rasterizer中，enumerate，指的是enumerates the pixels that are covered by the primitive
interpolate指的是使用插值计算
blending：combines the fragments generated by the primitives that overlapped rach piexl to compute the final color
关于反走样（抗锯齿）：这部分放在渲染管线中的哪个部分和使用的方法有关，故不再标出在渲染管线中的位置。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55fc979ef889ecf0c1e8272c64ab6df4/" rel="bookmark">
			基于STM32的DAC实现音频波形的输出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文目的是使用STM32的DAC（数模转换）实现音频信号波形的输出。这里分为两个部分：第一部分实现特定频率单音频信号波形的输出；第二部分实现歌曲音频信号波形的输出。
目录 （一）DAC简介1.STM32的DAC2.DAC主要特征3.DAC通道模块框图 （二）单音频正弦波输出1.实验目的2.DAC 配置3.输出信号3.歌曲音频信号波形输出 （三）总结 （一）DAC简介 1.STM32的DAC 数字/模拟转换模块(DAC)是12位数字输入，电压输出的数字/模拟转换器。DAC可以配置为8位 或12位模式，也可以与DMA控制器配合使用。DAC工作在12位模式时，数据可以设置成左对齐或右对齐。DAC模块有2个输出通道，每个通道都有单独的转换器。在双DAC模式下，2个通道可以独立地进行转换，也可以同时进行转换并同步地更新2个通道的输出。DAC可以通过引脚输入参考电压VREF+以获得更精确的转换结果。
2.DAC主要特征 2个DAC转换器：每个转换器对应1个输出通道8位或者12位单调输出12位模式下数据左对齐或者右对齐同步更新功能噪声波形生成三角波形生成双DAC通道同时或者分别转换每个通道都有DMA功能外部触发转换输入参考电压VREF+ 关于STM32的DAC详细内容可参考《STM32中文参考手册》
3.DAC通道模块框图 名称型号类型注释VREF+输入，正模拟参考电压DAC使用的高端/正极参考电压，2.4V ≤ VREF+ ≤ VDDA (3.3V)VDDA输入，模拟电源模拟电源VSSA输入，模拟电源地模拟电源的地线DAC_OUTx模拟输出信号DAC通道x的模拟输出 （二）单音频正弦波输出 1.实验目的 PA4管脚输出一个频率为112khz的正弦波使用该波形驱动蜂鸣器，检验是否会输出“滴…”的单音 2.DAC 配置 以下操作均在STM32F103开发板上进行，参照野火DAC正弦波输出例程。
使能 PA 口时钟，设置 PA4 为模拟输入。
STM32F103ZET6 的 DAC 通道 1 在 PA4 上，所以，我们先要使能 PORTA 的时钟，然后设
置 PA4 为模拟输入。DAC 本身是输出，但是为什么端口要设置为模拟输入模式呢？因为一但
使能 DACx 通道之后，相应的 GPIO 引脚（PA4 或者 PA5）会自动与 DAC 的模拟输出相连，设
置为输入，是为了避免额外的干扰。 RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE ); //使能 PORTA 时钟 GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN; //模拟输入 使能 DAC1 时钟。
STM32 的 DAC 模块时钟是由 APB1提供的，所以我们调用函数RCC_APB1PeriphClockCmd()设置 DAC 模块的时钟使能。 RCC_APB1PeriphClockCmd(RCC_APB1Periph_DAC, ENABLE ); //使能 DAC 通道时钟 初始化 DAC,设置 DAC 的工作模式。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/55fc979ef889ecf0c1e8272c64ab6df4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60d2d09f49649c19b66c8966c06a4494/" rel="bookmark">
			STM32 提高ADC采样频率的几种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一般情况下，我们会用定时器控制采样频率的方式去令ADC去采集一段波形数据并对其分析。
而当我们分析一些高频信号时，需要较的高采样频率。一方面由于单个ADC硬件配置的限制其最高采样频率是有限的，故可以通过以下几个方面进行提高：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3041b6a1192a75ab9cef8c8015e7d027/" rel="bookmark">
			前端的学习网站 游戏类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一个：https://flexboxfroggy.com/
第二个：http://www.flexboxdefense.com/
第三个：https://cssgridgarden.com/
第四个：https://pixact.ly/
第五个：https://type.method.ac/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/628b4309ae32252710c9ad4ca00aeedd/" rel="bookmark">
			GAMES202 笔记 -Real-Time Environment Mapping
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、环境光照-无阴影
二、Prefiltering
三、BRDF项采样
四、环境光照-阴影
五、Basis Functions
六、Spherical Harmonics(球谐函数)
七、PRT
八、Light transport
九、小波
一、环境光照-无阴影 环境贴图就是在场景中任意一点往四周看去可看到的光照,将其记录在一张图上这就是环境光照,或者也可以叫做IBL(image-based lighing)我们用spherical map和cube map来存储环境光照.
使用Spherical Map记录环境光同时存在一些问题，注意上图的上下边界，你会发现出现了扭曲的情况。这是因为球面展开成为平面的时候，平面无法均匀的描述球面上的所有信息，纬度越高的地方，在球面上占据的区域越小，展开后扭曲越严重。
使用环境光计算shading的操作叫做IBL(Image based lighting)。如果已知环境光照,此时放置一个物体在场景中间,在不考虑遮挡时我们该如何去得到任何一物体上任何一shading part的shading值:
不考虑遮挡,所以舍去visibility项，那么式中的lighting项就变成了环境光的lighting，而不是到达着色点的lighting.通用的解法是使用蒙特卡洛积分去解,但是蒙特卡洛需要大量的样本才能让得出的结果足够接近,如果我们对每个shading point都做一遍蒙特卡洛,那样的话将会花费很多时间在采样上。
避免采样：由于我们不考虑visibility项,那么rendering equation就只是brdf项和lighting项相乘再积分。brdf又分为两种情况。
对于渲染方程中的BRDF项来说，如果是glossy材质的BRDF，如上图左所示（图中i方向是相机方向，r方向是光源方向），则其lobe很小，即积分域很小；如果是diffuse材质的BRDF，如上图右所示，虽然lobe很大，但足够smooth。
由公式拆分：
把light项拆分出来,然后将brdf范围内的lighting积分起来并进行normalize归一化,其实就是将IBL这张图给模糊了。
二、Prefiltering 模糊就是在任何一点上取周围一片范围求出范围内的平均值并将平均值写回这个点上。一般来说，会选择不同尺寸的滤波核，对环境光贴图进行不同层次的滤波，当使用时，可以根据BRDF的lobe的实际大小在对应层次的滤波结果上查询，BRDF的区域越大,最后取得的图也就越模糊。-参考MIPMAP。
左图为brdf求shading point值时,我们要以一定立体角的范围内进行采样再加权平均从而求出shading pointd的值.右图为我们从镜面反射方向望去在pre-filtering的图上进行查询,由于图上任何一点都是周围范围内的加权平均值,即先采样后平均≈先平均后采样。解决了渲染方程近似拆分的前半部分，也就是lighting项的采样问题。
三、BRDF项采样 我们仍然可以用预计算来解决后半部分积分采样的问题,但是预计算的话我们需要将参数的所有可能性均考虑进去,但是比较多。因此我们需要想办法降低维度,也就是减少参数量从而实现预计算。
我们使用的是Microfacet BRDF:
F是菲涅尔项，主要参数有三通道的初始反射率R0 ，以及观察方向 W0G是几何项/阴影项，主要表示微表面之间的遮挡关系，主要参数有法线n，观察方向 W0D是法线分布函数（NDF），主要参数有观察方向 W0，粗糙度等 暂时不考虑阴影，此处需要关注的是Fresnel term和distribution of normals
Frenel term可以近似成一个基础反射率R0和入射角度的指数函数
法线发布函数（NDF）是一个一维的分布，其中有两个变量，一个变量定义是diffuse还是gloosy，另一个 是half vector和法线中间的夹角，可以近似成入射角度相关的数，这样就变成了3维的预计算。
我们对原BRDF项做下列变形：
基础反射R0被拆出积分式，需要预计算的两个量就只有roughness 和角度 ，可以将预计算结果绘制成一张纹理，在使用时进行查询即可。预计算是固定。
四、环境光照-阴影 在有了环境光照情况下如何去得到物体被环境光照射下生成的阴影：
many light问题:我们把环境光理解为很多个小的光源,这种情况下去生成阴影的话,需要在每个小光源下生成shadow map,因此会生成线性于光源数量的shadow map。对光源进行采样并不困难，甚至可以进行重要性采样类似的操作，但是每个着色点的visibility项可能是完全不同的，也就是我们很难知道在某个点的某个采样方向上，visibility项是什么。也就是我们只能对visibility项进行盲目的采样，导致结果收敛的很慢。 在工业界中,我们通常以环境光中最亮的那个作为主要光源,也就是太阳,只生成太阳为光源的shadow
与生成环境光下阴影相关的研究：
Imperfect shadow maps：是生成全局光照下阴影的一个解决方案Light cuts：是离线渲染领域中一系列有关many-light问题的相关研究RTRT(real-time ray tracing)：可能是环境光下生成阴影的一个终极解决方案Precomputed radiance transfer(prt)：可以准确的得到环境光下阴影的结果 五、Basis Functions 傅里叶级数展开：任何一个函数可以写成常数和一系列基函数(不同频率sin和cos项)的线性组合,基函数数量越多越接近于原函数的形状。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/628b4309ae32252710c9ad4ca00aeedd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/491f6b091e1d2af5e71b43269695f998/" rel="bookmark">
			疑难杂症之——启动eclipse提示找不到Java虚拟机（你没有见过的船新版本）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		疑难杂症之——启动eclipse提示找不到Java虚拟机（你没有见过的船新版本） 直接看解决办法 前两天突然来了兴致想把电脑的文件整理一下，整理时给eclipse挪了个路径，然后它就“坏了”。
当我点击桌面上的eclipse快捷方式时，它就会提示我找不到Java虚拟机，但是我点击安装路径下的eclipse.exe文件打开时，就可以正常打开的，这可把我难了好几天。
网上说可能是环境没有配置好，于是我又重新配置了Java环境，甚至重新安装了jdk，替换了eclipse版本；
还有说需要在eclipse.ini文件中添加【jdk的安装路径\bin\javaw.exe】。
我都尝试了，而且做完这一切之后在cmd中也是可以运行Java命令的，但再次尝试打开还是同样的问题。
我没办法了，只有来求助CSDN的大佬，果然就有大佬知道这个问题的解决办法，现附上解决办法
直接看解决办法 大佬原话：eclipse在初次启动的时候会在你自己的用户目录下创建一些配置文件，你找一下你自己的用户目录 ，我的电脑 c盘 ，用户，找到你自己账户目录，把 “.eclipse” 目录删掉 ，然后重新起一下eclipse试一下
比如我的是联想电脑，就在以下目录中
把这个文件夹删掉，然后再尝试点击快捷方式，就正常打开了
我看网上有很多说这个问题的博主，但基本上都没有看到我需要的解决办法，问题也不是特别有技术含量，但还是记录一下，希望某一天其他同学遇到跟我一样的问题是能对ta有帮助。
这么奇葩的问题，估计也只有我这样闲的去移动它安装路径才会遇到吧 (˘•ω•˘)
最后附上原提问链接 https://bbs.csdn.net/topics/399161770
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d46b9b575c23e81639b8de4df6a183a5/" rel="bookmark">
			TypeScript 简介 一起来认识TypeScript
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		TypeScript 由来
TypeScript是微软开发的一个开源的编程语言，通过在JavaScript的基础上添加静态类型定义构建而成。TypeScript通过TypeScript编译器或Babel转译为JavaScript代码，可运行在任何浏览器，任何操作系统
产生的意义和特点
1、TypeScript 起源于使用JavaScript开发的大型项目 。由于JavaScript语言本身的局限性，难以胜任和维护大型项目开发。因此微软开发了TypeScript ，使得其能够胜任开发大型项目。
2、TypeScript 是JavaScript添加了可选的静态类型和基于类的面向对象编程。
3、TypeScript 是一门弱类型的语言。
4、TypeScript扩展了JavaScript的语法，所以任何现有的JavaScript程序可以运行在TypeScript环境中。
5、TypeScript 可以编译为 JavaScript，然后运行在浏览器、Node.js 等任何能运行 JavaScript 的环境中。
6、TypeScript 可以和 JavaScript 共存，这意味着 JavaScript 项目能够渐进式的迁移到 TypeScript。
7、TypeScript 与标准同步发展，符合最新的 ECMAScript 标准（stage 3）
8、TypeScript 仅仅是被编译为标准的 JavaScript。支持运行于任何浏览器和平台上的任何网页。
9、TypeScript 的编译步骤可以输出运行之前的错误。
开发准备
1、通过npm（Node.js包管理器）
npm install -g typescript 运行
tsc helloworld.ts 2、安装Visual Studio的TypeScript插件
例如：
Visual Studio 2019
Visual Studio Code
Visual Studio 2017
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/79c28306c7fa1897e00b974ebdd190fb/" rel="bookmark">
			金仓数据库KingbaseES SYS_BULKLOAD工具的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		介绍
sys_bulkload是KingbaseES提供的快速加载数据的命令行工具。用户使用sys_bulkload工具能够把一定格式的文本数据简单、快速的加载到KingbaseES数据库中，或将KingbaseES数据库中的数据快速导出到CSV文件中。
使用前需要用户手动创建sys_bulkload插件，需要说明的是sys_bulkload工具是随数据库版本一同发布的，使用时请使用对应发布的数据库版本，其他数据版本则不保证能正常工作。
架构图
sys_bulkload主要包括两个模块：reader和writer。reader负责读取文件、解析tuple，writer负责把解析出的tuple写入输出源中。
sys_bulkload参数
sys_bulkload可以通过短选项、长选项、配置文件三种方式来指定配置加载选项。由于加载的选项比较多，并且一些加载选项的信息比较固定和反复使用，可以把这些加载选项配置在配置文件中，命令行直接指定配置文件的路径。配置加载选项规则如下:
启动参数的短选项和长选项是等价的。在启动参数选项中仍然可以指定配置文件中配置的加载选项，其作用主要是临时替换配置文件的选项，以避免去修改配置文件中的选项，配置文件和启动参数同时指定则以启动参数指定为准。如果使用启动参数则需要注意input，output，logfile，parse_badfile，duplicate_badfile不能多次指定，否则报错：specified only once。其他选项可以多次指定，并且以后指定的选项为准。 配置文件中参数选项说明：
必填参数:
1.TYPE = CSV | TEXT | BINARY | DB 加载的数据源的类型
CSV 从CSV格式的文本文件加载数据
TEXT 从TEXT格式的文本文件加载数据
BINARY 从二进制格式的文件加载数据
DB 从数据库的表中导出数据
2.INPUT = PATH | [schema_name.] table_name 需要导入的数据文件路径或者导出数据的源表
PATH 需要导入的数据源文件路径。如果是相对路径，在控制文件中指定时，它将与控制文件相对；当在命令行参数中指定时，相对于当前工作目录。KingbaseES服务器的用户必须具有该文件的读取权限。在“TYPE = CSV | TEXT | BINARY”时可用。
[schema_name.] table_name 需要导出数据的表名。仅在“TYPE = DB”时可用。
3.OUTPUT = [schema_name.] table_name | PATH 指定将数据导入的目标表或者目标文件。
[schema_name.] table_name 导入数据的表名。在“ TYPE = CSV | TEXT | BINARY ”时可用。
PATH 导出数据的文件路径。如果是相对路径，在控制文件中指定时，它将与控制文件相对；当在命令行参数中指定时，相对于当前工作目录。KingbaseES服务器的用户必须具有该文件的读取权限。仅在“TYPE = DB”时可用。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/79c28306c7fa1897e00b974ebdd190fb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2b698ca095cc0be3902826c0be2f08c/" rel="bookmark">
			MAVEN仓库＜repositories＞详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写在前面 本文围绕项目内部依赖的第三方JAR包相关的仓库的分类、获取，对应的标签是；针对插件的远程仓库不在该博文中讨论，当然插件也是通过仓库进行下载获取，插件对应的标签是。
MAVEN仓库的定义 MAVEN仓库是项目中依赖的第三方库，这个库所在的位置叫做仓库。MAVEN仓库能帮助我们管理构件，它就是放置所有JAR文件(WAR，ZIP，POM等等)的地方。在MAVEN中，任何一个依赖或者项目构建的输出，都称为构件。
MAVEN仓库的分类 ①. 本地仓库：不需要联网的本地磁盘目录。默认情况下，每个用户所在的用户目录下都有一个路径为 ${user.home}/.m2/repository/ 的仓库目录，它在第一次执行maven 命令时才被创建，运行MAVEN项目时，项目所需要的所有构件都是先从本地仓库获取的，如果本地仓库没有，会尝试去中央仓库获取，如果中央仓库也没有，它会尝试从远程仓库下载构件到本地仓库，然后再使用本地仓库的构件。
②. 中央仓库：需要联网的内置的远程仓库。由MAVEN社区提供和管理的仓库，包含了大量常用的类库，不需要在工程/代码中手动配置，也可以成为MAVEN缺省的远程仓库。默认中央仓库：https://repo.maven.apache.org/maven2
③. 远程仓库：需要联网的、由开发人员自己定制的仓库，包含了所需要的代码库或者工程中用到的构件。当相关依赖的构件在中央仓库找不到时，此时需要配置对应的远程仓库来获取对应的构件。
MAVEN中央仓库 中央仓库的定义在哪里可以找到？
&lt;!-- 可以从安装路径下看到默认中央仓库的地址如下： D:\Program Files (x86)\apache-maven-3.6.3\lib\ maven-model-builder-3.6.3.jar\org\apache\maven\model\pom-4.0.0.xml 中央仓库的id为central，远程url地址为http://repo.maven.apache.org/maven2， 关闭了SNAPSHOT版本构件下载的支持 --&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;central&lt;/id&gt; &lt;name&gt;Central Repository&lt;/name&gt; &lt;url&gt;https://repo.maven.apache.org/maven2&lt;/url&gt; &lt;layout&gt;default&lt;/layout&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;/repositories&gt; MAVEN仓库的其他配置项 &lt;!-- repository的releases和snapshots标签中有个enabled属性，默认为true。， 表示是否需要从这个远程仓库中下载稳定版本或者快照版本的构件，一般使用第三方仓库，建议下载稳定版本的构件。 --&gt; &lt;repository&gt; &lt;id&gt;aliyun-releases&lt;/id&gt; &lt;url&gt;https://maven.aliyun.com/repository/public&lt;/url&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; MAVEN仓库的请求顺序 项目根据以下顺序获取相关的依赖包。
1.本地仓库 -》2.中央仓库(MAVEN缺省的远程仓库) -》3.远程仓库
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f57aa1ac4ba7cf72811e8a523750a18/" rel="bookmark">
			kotlin学习第三天：kotlin集合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		kotlin集合 1.集合的映射操作1.filter操作2.map操作3.flatMap变换4.asSequence方法 2.集合的聚合操作1.fold操作 学习视频地址：https://coding.imooc.com/class/398.html
1.集合的映射操作 1.filter操作 val list= intArrayOf(1,2,3,4) list.filter { it%2==0 }.forEach { println(it) } 2.map操作 val list= intArrayOf(1,2,3,4) list.map { it*3+2 }.forEach { println(it) } 输出：
3.flatMap变换 val list= intArrayOf(1,2,3,4) list.flatMap { 0 until it }.joinToString().let(::println) 4.asSequence方法 将上面那些方法变为懒汉式，转化为序列
没有加asSequence方法
println("----------------------") val list= intArrayOf(1,2,3,4) list .filter { println("filter:$it") it % 2==0 }.map { println("map:$it") it*2+1 }.forEach { println("forEach:$it") } 输出：
加上asSequene方法
加上之后变为懒汉式，会按照代码顺序来打印，没有加的时候，是要filter全部打印完，才打印map。
println("----------------------") val list= intArrayOf(1,2,3,4) list.asSequence() .filter { println("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2f57aa1ac4ba7cf72811e8a523750a18/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fda0d8855d0204fb409fc421301389e4/" rel="bookmark">
			史上最全的springboot导出pdf文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近项目有一个导出报表文件的需求，我脑中闪过第一念头就是导出pdf（产品经理没有硬性规定导出excel还是pdf文件），于是赶紧上网查看相关的资料，直到踩了无数的坑把功能做出来了才知道其实导出excel的api更方便，网上的相关博客也更多，不过坑也踩完了，这一次就来把代码和收获整理和分享一下。
导出pdf模板的局限性 在看到需求之前，我先去网上去搜了一波，发现网上很大一部分博客都是将如何导出pdf模板的，就是先制作一张pdf模板，把固定不变的地方先写好，把需要改变的地方留白并设置参数，然后在代码里为参数赋值就行了，这种方式很简单，代码量也很少，但是！！！这种方式只适合导出格式和内容是固定的文件，而我们的需求是导出一张以产品名称为列，产品属性为行的报表，产品数量不定，这很显然就不能用模板的方式，只好老老实实把报表的数据从头到尾一一导出来。
使用iText导出pdf表格 iText是一种生成PDF报表的Java组件，先把jar包下下来，maven依赖如下：
&lt;dependency&gt; &lt;groupId&gt;com.itextpdf&lt;/groupId&gt; &lt;artifactId&gt;itextpdf&lt;/artifactId&gt; &lt;version&gt;5.0.6&lt;/version&gt; &lt;/dependency&gt; 按照惯例，先来生一个“Hello World”的文件，代码如下
public class TestPdf { public static void main(String[] args) throws Exception { TestPdf pdf = new TestPdf(); String filename = "D:/Program Files/pdfTest/testTable3.pdf"; pdf.createPDF(filename); System.out.println("打印完成"); } public void createPDF(String filename) throws IOException { Document document = new Document(PageSize.A4); try { PdfWriter.getInstance(document, new FileOutputStream(filename)); document.addTitle("example of PDF"); document.open(); document.add(new Paragraph("Hello World!")); } catch (FileNotFoundException e) { e.printStackTrace(); } catch (DocumentException e) { e.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fda0d8855d0204fb409fc421301389e4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5c90bfe9d9aa25c604ab3d251c818e7/" rel="bookmark">
			4. 利用MySQL Shell安装部署MGR集群 | 深入浅出MGR
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		* GreatSQL社区原创内容未经授权不得随意使用，转载请联系小编并注明来源。
1. 安装准备
2. 利用MySQL Shell构建MGR集群
3. MySQL Shell接管现存的MGR集群
4. 小结
参考资料、文档
免责声明
本文介绍如何利用MySQL Shell + GreatSQL 8.0.25构建一个三节点的MGR集群。
MySQL Shell是一个客户端工具，可用于方便管理和操作MySQL，支持SQL、JavaScript、Python等多种语言，也包括完善的API。MySQL Shell支持文档型和关系型数据库模式，通过X DevAPI可以管理文档型数据，通过AdminAPI可以管理InnoDB Cluster、InnoDB ClusterSet及InnoDB ReplicaSet等。
1. 安装准备 准备好下面三台服务器：
IP端口角色172.16.16.103306mgr1172.16.16.113306mgr2172.16.16.123306mgr3 确保三个节点间的网络是可以互通的，并且没有针对3306和33061端口的防火墙拦截规则。
利用yum安装MySQL Shell，版本选择和GreatSQL相同的8.0.25：
$ yum install mysql-shell-8.0.25 假定已经参考前文 3. 安装部署MGR集群 做好MySQL Server的初始化并启动三个实例。
接下来直接利用MySQL Shell部署MGR。
2. 利用MySQL Shell构建MGR集群 利用MySQL Shell构建MGR集群比较简单，主要有几个步骤：
检查实例是否满足条件。
创建并初始化一个集群。
逐个添加实例。
首先，用管理员账号 root 连接到第一个节点：
#在本地通过socket方式登入 $ mysqlsh -Spath/mysql.sock root@localhost Please provide the password for 'root@.%2Fmysql.sock': ******** Save password for 'root@.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f5c90bfe9d9aa25c604ab3d251c818e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49beca2fbcc43d4dcdbe6d02a96b774e/" rel="bookmark">
			问题3：AttributeError: ‘open3d.open3d.geometry.PointCloud‘ object has no attribute ‘voxel_down_sample‘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Issue:
============== Code =============================================== import open3d as o3d pcd = o3d.io.read_point_cloud("apple_object_50.pcd") print("Downsample the point cloud with a voxel of 0.05") downpcd = pcd.voxel_down_sample(voxel_size=0.05) o3d.visualization.draw_geometries([downpcd]) ============== Result =============================================== Downsample the point cloud with a voxel of 0.05 --------------------------------------------------------------------------- AttributeError Traceback (most recent call last) &lt;ipython-input-9-d91495e4867a&gt; in &lt;module&gt; 2 pcd = o3d.io.read_point_cloud("apple_object_50.pcd") 3 print("Downsample the point cloud with a voxel of 0.05") ----&gt; 4 downpcd = pcd.voxel_down_sample(voxel_size=0.05) 5 o3d.visualization.draw_geometries([downpcd]) AttributeError: 'open3d.open3d.geometry.PointCloud' object has no attribute 'voxel_down_sample' Reason:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/49beca2fbcc43d4dcdbe6d02a96b774e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/171332b14b40cfec4ea3b3bf80f9ccbc/" rel="bookmark">
			问题1： class DescriptorBase(metaclass=DescriptorMetaclass): ^Syntax invalid syntax
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		virtual@virtual-machine:~$ python -c 'import keras; print(keras.__version__)' Using TensorFlow backend. Traceback (most recent call last): File "&lt;string&gt;", line 1, in &lt;module&gt; File "/home/song/.local/lib/python2.7/site-packages/keras/__init__.py", line 3, in &lt;module&gt; from . import utils File "/home/song/.local/lib/python2.7/site-packages/keras/utils/__init__.py", line 6, in &lt;module&gt; from . import conv_utils File "/home/song/.local/lib/python2.7/site-packages/keras/utils/conv_utils.py", line 9, in &lt;module&gt; from .. import backend as K File "/home/song/.local/lib/python2.7/site-packages/keras/backend/__init__.py", line 1, in &lt;module&gt; from .load_backend import epsilon File "/home/song/.local/lib/python2.7/site-packages/keras/backend/load_backend.py", line 90, in &lt;module&gt; from .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/171332b14b40cfec4ea3b3bf80f9ccbc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23bc73f991c42a2f0662f4699a5f4f0d/" rel="bookmark">
			BeanFactory源码体系解析一
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		BeanFactory:用于管理Bean的顶级工厂接口，它负责生产和管理bean，职责包括实例化、定位、配置应用程序中的对象，以及建立这些对象间的依赖。 1、FACTORY_BEAN_PREFIX= "&amp;" 对FactoryBean的转义定义，使用bean名字检索FactoryBean得到的是工厂生成的对象，得到工厂实例本身需要转义。 2、getBean(String name) 根据Bean名字或者bean实例，单例对象在容器启动时进行创建。 3、getBean(String name, @Nullable Class&lt;T&gt; requiredType) 根据bean名字和Class类型获取bean实例，增加了类型安全验证机制。 4、getBean(String name, Object... args) 通过bean的名称和参数来获取bean实例 5、boolean containsBean(String name) 通过beanname查看容器是否存在bean 6、boolean isSingleton(String name) 判断bean是否是单例 7、String[] getAliases(String name) 得到bean的别名，如果根据别名查找，那么其原名也会查找出来。 HierarchicalBeanFactory：这些bean有继承关系，每个bean有可能有父bean，支持父子上下文，分层可以使容器的每层都专注于特定的层次，比如 WebApplicationContext(专注于提供对web的支持) -&gt; ApplicationContext(专注于提供容器的扩展功能) -&gt; BeanFactory(专注基础功能) 1、BeanFactory getParentBeanFactory() 获取 parent bean factory 2、boolean containsLocalBean(String name) 判断当前BeanFactory实例中是否有指定名称的bean，只在当前bean factory中检索，不会在 parent bean factory 中检索 ListableBeanFactory:这些bean是可列表化，即Listable可以列举，在BeanFactory的基础上扩展了Beaan的清单，根据清单可以判断容器中是否存在指定的Bean，统计Bean的数量，获取满足要求的Bean的名称，获取满足要求的所有Bean 1、boolean containsBeanDefinition(String beanName) 是否包含指定名称的BeanDefinition 2、int getBeanDefinitionCount() 获取BeanDefinition数量 3、String[] getBeanDefinitionNames() 获取所有Bean的名称 4、getBeanProvider 多种参数(饥饿加载、懒加载)获取Bean对应的BeanProvier 5、getBeanNamesForType 多种入参获取所有的Bean名称 6、getBeansOfType 获取指定Type的所有Bean，返回Map key=name，value=Bean实例 7、String[] getBeanNamesForAnnotation 获取指定注解的所有Bean名称 8、findAnnotationOnBean(String beanName, Class&lt;A&gt; annotationType) 获取指定Bean名称对应的注解实例 SingletonBeanRegistry :单例的顶级接口，定义了单例的通用操作 1、registerSingleton(String beanName, Object singletonObject) 注册单例 2、Object getSingleton(String beanName) 获取单例 3、boolean containsSingleton(String beanName) 判断是否包括指定Bean名称的单例 4、String[] getSingletonNames() 获取所有已创建的单例名称 5、int getSingletonCount() 获取所有已创建的单例数量 6、Object getSingletonMutex() 获取单例注册的互斥锁 ConfigurableBeanFactory : 在HierarchicalBeanFactory、SingletonBeanRegistry2个接口的基础上定义了BeanFactory的通用配置(类加载器、类型转换、属性编辑器、BeanPostProcessor、作用域、Bean定义处理依赖关系、Bean如何销毁)，继承SingletonBeanRegistry扩展单例功能 属性SCOPE_SINGLETON(单例)、SCOPE_PROTOTYPE(原型) 设置父工厂，和HierarchicalBeanFactory的getParentBeanFactory方法互补 void setParentBeanFactory(BeanFactory parentBeanFactory); 四个和类加载器有关的方法工厂类加载器、临时类加载器 void setBeanClassLoader(@Nullable ClassLoader beanClassLoader); ClassLoader getBeanClassLoader(); void setTempClassLoader(@Nullable ClassLoader tempClassLoader); ClassLoader getTempClassLoader(); 两个设置是否缓存元数据的方法 void setCacheBeanMetadata(boolean cacheBeanMetadata); boolean isCacheBeanMetadata(); 11个处理Bean注册，加载等细节的方法，Bean表达式分解器 void setBeanExpressionResolver(@Nullable BeanExpressionResolver resolver); BeanExpressionResolver getBeanExpressionResolver(); 转换服务 void setConversionService(@Nullable ConversionService conversionService); ConversionService getConversionService(); 属性编辑器属性编辑注册 void addPropertyEditorRegistrar(PropertyEditorRegistrar registrar); void registerCustomEditor(Class&lt;?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/23bc73f991c42a2f0662f4699a5f4f0d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8033df08bed3307537ac3bf2e4535002/" rel="bookmark">
			Games101笔记——Lecture 20:Color and Perception
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Lecture 20:Color and Perception 今日内容 上节课没讲完的光场内容颜色 Light Field / Lumigraph (光场) 两个组各自发明了这个东西，各自进行了命名我们看见的世界是什么？ 引入虚拟现实的原理，理解上很简单我们看见的就是进入人眼的光线 全光函数 我们所能看到的所有东西
在某个点，在一个时间上，对于某个波长，往任意方向上看能看到的值——电影
进一步扩展，摄像机的位置可以任意移动——全息电影
把函数理解成在任何时刻、任何位置、任何方向看到的东西——一个七维的函数——全光函数
光场的概念从全光函数开始，从全光函数提取其中一部分的信息先定义光线：起点与方向
重新定义光线 可以取光线上任意两点（默认方向已知）
光线与物体，物体包围盒上任意一点任意方向的发光情况——这一信息即为光场：两个数表示方向、两个数表示位置
通过光场，从任意位置都可以看向物体，都知道看到的结果，即可以得到物体任意位置的观测结果光场的位置在盒子上还是在物体表面上？不需要具体知道对于下图，知道平面上的参数化信息就行，不需要知道右边也可以定义两个平行平面，通过两平面上两点定义一条光线：即(u, v) (s, t)
一个经典的参数化表示方法对于上述方式不同的理解方式，下图
一点窥全豹 &amp; 多点看一点斯坦福做了第一种：
另外一种，与昆虫的复眼类似
光场照相机 最重要的功能，支持后期（拍照之后）重新聚焦、调整光圈大小其原理即为光场的原理 将感光元件往后移并加上一堆透镜，记录的一个像素变成了一块像素（其内部其实是各个不同方向）而每一个透镜都相当于一个光场一个像素原本记录的irradiance被拆开了
怎么做到的，想得到普通的照片怎么办？ 直接把每个透镜都选一条光线记录结果，比如都选底下光线，相当于从下面看更进一步，都选中间光线，相当于从中间看相当于虚拟的移动了照相机的位置！重新聚焦利用了一样的道理：对于不同的光线选择不同的位置，得通过计算取哪些方向 有这些功能——因为光场摄像机记录了整个光场的信息它自己本身也有问题 分辨率不足！每一个小块（更多个像素）记录了一个像素！——要求胶片分辨率高成本高（微透镜设计制造，要求胶片分辨率高）我们发现：计算机图形学中的trade-offs Physical Basis of Color 颜色是什么？光谱——不同的波长对应不同的折射率。图形学通常关注可见光部分 Spectral Power Distribution（SPD 谱功率密度） 描述任何一个光在某一波长的分布多少
SPD的线性性质，容易理解
什么是颜色？ 颜色是人的感知；并非物理上的普适概念
生物学颜色的基础 视网膜上的感光细胞 棒状细胞：用来感知光线的强度锥形细胞：数量比棒状细胞少很多 ，用来感知颜色
锥形细胞又分为三类：S，M，L，三者感知的主要波长范围不同
但是不同的人这三种细胞的分布很不一样！ 更加说明颜色是人感知的结果！ 感知的结果：
人们看到的是三个数，其实 人类视觉系统
Metamerism 同色异谱 通过不同的光谱实现看起来相同的颜色
例子
应用：
Color Reproduction / Matching 混合颜色，计算机中的加色系统
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8033df08bed3307537ac3bf2e4535002/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ca45bf9fbb90aa0a5fb04f1fb9c1e1e/" rel="bookmark">
			socket编程之select
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.socket阻塞模式
所谓阻塞方式block，顾名思义，就是进程或是线程执行到这些函数时必须等待某个事件的发生，如果事件没有发生，进程或线程就被阻塞，函数不能立即返回
2.socket非阻塞模式（select）
所谓非阻塞方式non- block，就是进程或线程执行此函数时不必非要等待事件的发生，一旦执行肯定返回，以返回值的不同来反映函数的执行情况，如果事件发生则与阻塞方式相同，若事件没有发生则返回一个代码来告知事件未发生，而进程或线程继续执行，所以效率较高
select相关API介绍与使用
#include &lt;sys/select.h&gt;
#include &lt;sys/time.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;
int select(int maxfdp, fd_set *readset, fd_set *writeset, fd_set *exceptset,struct timeval *timeout);
参数说明：
maxfdp：被监听的文件描述符的总数，它比所有文件描述符集合中的文件描述符的最大值大1，因为文件描述符是从0开始计数的；
readfds、writefds、exceptset：分别指向可读、可写和异常等事件对应的描述符集合。
timeout:用于设置select函数的超时时间，即告诉内核select等待多长时间之后就放弃等待。timeout == NULL 表示等待无限长的时间
timeval结构体定义如下：
struct timeval
{
long tv_sec; /*秒 */
long tv_usec; /*微秒 */
};
返回值：超时返回0;失败返回-1；成功返回大于0的整数，这个整数表示就绪描述符的数目。
以下介绍与select函数相关的常见的几个宏：
#include &lt;sys/select.h&gt;
int FD_ZERO(int fd, fd_set *fdset); //一个 fd_set类型变量的所有位都设为 0
int FD_CLR(int fd, fd_set *fdset); //清除某个位时可以使用
int FD_SET(int fd, fd_set *fd_set); //设置变量的某个位置位
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7ca45bf9fbb90aa0a5fb04f1fb9c1e1e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dab2b8c65adbebb5139fce6007b8c59e/" rel="bookmark">
			找不到匹配的outgoing encryption 算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 项目场景： xftp连接服务器弹窗提示
问题描述： 找不到匹配的outgoing encryption 算法
原因分析： SSH版本升级
解决方案： 1.文件 属性 设置 2. 点击设置 出现弹窗 3.点击 加密 算法 的编辑 ，将红框中的三个加密算法选中 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09a76558d230425cdc4674cb400293d8/" rel="bookmark">
			DTC之DTC Status状态位
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		部分转自//https://zhuanlan.zhihu.com/p/35371763##
一、UDS的DTC分类说明 PCBU：Powertrain（动力系统）、chassis（地盘）、body（车身）、network（通信系统）
5位标准故障码，第1位是字母，后面4位是数字，如P0101。
第一位字母表示故障所属系统，我们把汽车系统分为四大类。分别是动力，底盘，车身，网络通信，分别用PCBU表示
第二位数字是0、1、2或3表示故障类型，意义如下：“0”代表SAE(美国汽车工程师协会)定义的通用故障码；“1”代表汽车厂家定义的扩展故障码；“2”或“3”表示预留故障码
第三位数字表示故障所属的子系统。例如，对于动力系统部分：该位“0”表示燃油和空气计量辅助排放控制整个系统， “1”表示燃油和空气计量系统；“2”表示燃油和空气计量系统(喷油器)；“3”表示点火系统；“4”表示废气控制系统；“5”表示巡航、怠速控制系统；“6”表示与控制单元相关；“7”“8”表示变速箱系统等
最后两位数字指出了系统中出现故障的部件或部位
二、DTC状态位介绍 从汽车ECU中读取储存的DTC(故障码)时，除了故障码本身，还可以读出很多其他的信息，包括优先级、发生次数计数器、发生时的里程和时间，以及本文中所讲的状态位（DTC status ）。
这个状态位包含1个byte，这里面的8个bit都有各自的含义，但是这8个 bit不一定都要使用，各个主机厂可以根据自己的需求使用其中的几个，当然也可以全部使用。下图是UDS对DTC status这8个bit的定义。
先弄清以下几个概念：
Test：是一种车载诊断软件算法，根据不同的测试周期，得出最后的测试结果：Pass or Failed;
Completed：“完成”表示测试能够确定当前操作周期是否存在故障（“完成”并不表示发生故障）;
Operation Cycle：一个操作周期指监视器运行的开始和结束条件，在一个操作周期内，可能已完成若干个监视周期（无论其测试结果如何）。ECU可以支持多个操作周期，一个操作周期可以是ECU通电和断电之间或者点火打开和点火关闭之间的时间，也可以是ECU从网络唤醒到网络休眠的时间。
Pending：根据UDS规范解释，如果在当前或者上一个operation cycle中出现过具体某个DTC，pendingDTC=1。此时状态可以理解为一种中间状态（testerFailed和ConfirmedDTC之间）。
DTC status中8个状态bit的定义
bit 0 : testFailed
运行中的ECU，其内部检测DTC代码以OEM定义的周期循环执行，当达到相应的DTC触发条件，testFailed位被置1（e.g.在检测周期采样电压大于18 V）。
指示最近执行test的结果，test失败置1，但是它不一定被ECU存储到EEprom中，只有当bit2或bit3被置1时DTC才会被存储。test通过则置0，如果调用了14服务清除DTC的话，也需要重新置0。
bit 1 :testFailedThisOperationCycle
表示当前的operation cycle中出现过testFailed=1的状况，在前面说过operationcycle可以含有多个检测周期，只要有一个检测周期出现testFailed=1的情况，此bit置1。
这个bit用于标识某个DTC在当前的operation cycle中是否出现过testFailed置1的情况，即是否出现过错误。operation cycle的起始点是ECU通过网络管理唤醒到ECU通过网络管理进入睡眠，对于没有网络管理的ECU，这个起始点就是KL15通断。通过bit 0我们无法判断某个DTC是否出现过，比如，当前testFailed = 0， 说明当前这个DTC没有出错，如果testFailedThisOperationCycle = 1的话，就说明这个DTC在当前这个operation cycle中出过错，但是当前错误又消失了。
bit 2 : pendingDTC
如果在当前或者上一个operation cycle中出现过具体某个DTC，pendingDTC=1，在接下来的检测周期中如果故障不存在，pendingDTC重新置0。若接下来检测周期可以检测出此故障，那么confirmedDTC要被置1
根据规范的解释，pendingDTC = 1表示某个DTC在当前或者上一个operation cycle中是否出现过。pendingDTC位其实是位于testFailed和confirmedDTC之间的一个状态，有的DTC被确认的判定条件比较严苛，需要在多个operation cycle中出现才可以被判定为confirmed的状态，此时就需要借助于pendingDTC位了。pendingDTC = 1的时候，DTC就要被存储下来了，如果接下来的两个operation cycle中这个DTC都还存在，那么confirmedDTC就要置1了。如果当前operation cycle中，故障发生，pendingDTC = 1，但是在下一个operation cycle中，故障没有了，pendingDTC 仍然为 1，再下一个operation cycle中，故障仍然不存在，那么pendingDTC 就可以置0了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/09a76558d230425cdc4674cb400293d8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/79c3e67549056870301da57941402ca7/" rel="bookmark">
			idea maven 本地仓库配置报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言idea maven 本地仓库配置报错01 错误信息02 错误原因03 下载以前maven版本 前言 如果您觉得有用的话，记得给博主点个赞，评论，收藏一键三连啊，写作不易啊^ _ ^。
而且听说点赞的人每天的运气都不会太差，实在白嫖的话，那欢迎常来啊!!!
idea maven 本地仓库配置报错 01 错误信息 2 errors java.lang.RuntimeException: com.google.inject.CreationException: Unable to create injector, see the following errors: 1) No implementation for org.apache.maven.model.path.PathTranslator was bound. while locating org.apache.maven.model.path.PathTranslator for field at org.apache.maven.model.interpolation.AbstractStringBasedModelInterpolator.pathTranslator(Unknown Source) at org.codehaus.plexus.DefaultPlexusContainer$1.configure(DefaultPlexusContainer.java:350) 2) No implementation for org.apache.maven.model.path.UrlNormalizer was bound. while locating org.apache.maven.model.path.UrlNormalizer for field at org.apache.maven.model.interpolation.AbstractStringBasedModelInterpolator.urlNormalizer(Unknown Source) at org.codehaus.plexus.DefaultPlexusContainer$1.configure(DefaultPlexusContainer.java:350) 2 errors at com.google.inject.internal.Errors.throwCreationExceptionIfErrorsExist(Errors.java:543) at com.google.inject.internal.InternalInjectorCreator.initializeStatically(InternalInjectorCreator.java:159) at com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/79c3e67549056870301da57941402ca7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ff8c7b5d41e4204e83778bddfd12025/" rel="bookmark">
			android通过百度语音合成实现文字转换成语音(TTS)详细教程？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		android实现百度语音合成 1.使用TextToSpeech朗读文字2.百度语音合成1.创建应用1.在百度开发者平台实现注册，并进行实名认证2.点击语音技术3.点击创建应用4.创建细节5.领取语音合成次数 2.添加文件1.在lib中添加如图文件2.添加jniLibs文件夹3.添加assets文件(`重点，这里就是我前面一直出现错误的原因`)4.添加依赖 3.修改auth.properties文件4.修改OnlineAPIActivity文件5.解释ApiServer文件中重要代码1.查看百度语音合成上传参数2.通过ApiServer来达到声音，语速，音量的调整3.然后通过OnlineAPIActivity的requestSynth方法来调用 前言
因为最近在做毕业想实现这个功能，花费了我差不多一天时间，最主要太粗心了，在asset的时候出现了这个问题java.io.FileNotFoundException: auth.properties，困扰我挺久的，后面我将会提出这个问题的解决办法。
参考博客：https://llw-study.blog.csdn.net/article/details/116448633
首先看实现效果：
因为我实现的是在线合成，需要联网才能使用,所有代码地址在最下方
SVID
1.使用TextToSpeech朗读文字 这个方法是Android自带的，如果你觉得百度语音合成太麻烦了，你可以使用这种方法，但是我感觉这种方法的声音不好听，所有我选择去实现百度语音合成。
这个方法的实现可以参考这篇博客使用TextToSpeech朗读文字，经过我测试，是可以实现基本的功能的，我就不做过多解释了，你如果想实现这个功能，你可以参考那个老哥的这篇文章。‘
2.百度语音合成 1.创建应用 1.在百度开发者平台实现注册，并进行实名认证 百度开发者平台地址：https://ai.baidu.com/
实现个人认证
2.点击语音技术 3.点击创建应用 4.创建细节 5.领取语音合成次数 选择语音合成，然后点击面试领取资源
我这里是领取成功之后的效果
2.添加文件 1.在lib中添加如图文件 然后点击Add as Library，添加jar文件
2.添加jniLibs文件夹 3.添加assets文件(重点，这里就是我前面一直出现错误的原因) 因为我们一开始是直接把assets文件粘贴进去，就一直出现java.io.FileNotFoundException: auth.properties的错误
正确步骤是：
按理如下图方法添加assets文件夹
然后把文件粘贴到里面
4.添加依赖 //retrofit2 implementation 'com.squareup.retrofit2:retrofit:2.4.0' implementation 'com.squareup.retrofit2:converter-gson:2.4.0' implementation 'com.squareup.okhttp3:logging-interceptor:3.4.1' //权限请求框架 implementation 'com.tbruyelle.rxpermissions2:rxpermissions:0.9.4@aar' implementation 'io.reactivex.rxjava2:rxandroid:2.0.2' implementation "io.reactivex.rxjava2:rxjava:2.0.0" 3.修改auth.properties文件 因为下面4个数据是创建应用的数据，你要修改为你自己创建应用的appId等
我创建的应用的数据如下，建议修改为你自己，不然可能会实现不了这个功能，而且每个人的次数有限，大概5万次。
属于上述文件中sn是用于离线合成的序列号，我主要实现的在线合成，而且离线合成，就只能用30天免费时间，然后就要收费了，所有我觉得没有实现的必要。
4.修改OnlineAPIActivity文件 还需要在下列文件中修改为你自己的apiKey和apiSecret
5.解释ApiServer文件中重要代码 1.查看百度语音合成上传参数 上传参数查看地址：https://ai.baidu.com/ai-doc/SPEECH/Qk38y8lrl
2.通过ApiServer来达到声音，语速，音量的调整 在只需要在synthesis方法根据上传参数来添加相应的参数即可
3.然后通过OnlineAPIActivity的requestSynth方法来调用 如图所示，例如最后106就是修改声音为度博文。
代码我就没添出来了，我已经上传到gitee上面了，有需要的可以自行下载。
gitee代码地址：https://gitee.com/archerhe/SpeechSynthesis
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87d216f2b8288976ea548daa8b3d748a/" rel="bookmark">
			RSSI转距离资料汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		rssi测距原理及公式 http://www.elecfans.com/baike/wuxian/20171120582385.html
Rssi 计算公式 rssi = txPower + pathloss + rxGain + SystemGain
rxGain可以通过天线结构模拟
无线信号的发射功率和接收功率之间的关系可以用式（1）表示，PR是无线信号的接收功率，PT是无线信号的发射功率，r是收发单元之间的距离，n传播因子，数值大小取决于无线信号传播的环境。
PR=PT/(r^n) （1）
在公式（1）两边取对数可得到式（2），
10・nlgr=10lgPT/PR（2）
节点的发射功率是已知的，将发送功率代入式（2）中可得式（3），
10lgPR=A-10・nlgr （3）
式（3）的左半部分10lgPR是接收信号功率转换为dBm的表达式，可以直接写成式（4），在式（4）中A可以看作信号传输1m远时接收信号的功率。
PR（dBm）=A-10・nlgr （4）
注意：红色字体与原文不同
如何利用信号强度计算出与Wifi路由器的距离？ https://cloud.tencent.com/developer/ask/123184
要计算距离，你需要信号强度和信号的频率。这里是java代码：
public double calculateDistance(double signalLevelInDb, double freqInMHz) {
double exp = (27.55 - (20 * Math.log10(freqInMHz)) + Math.abs(signalLevelInDb)) / 20.0;
return Math.pow(10.0, exp);
}
使用的公式是：
距离= 10 ^（（27.55-（20 * log10（频率））+ signalLevel）/ 20）
例如：频率= 2412MHz，signalLevel = -57dbm，结果= 7.000397427391188m
谷歌实现方法： https://www.codeproject.com/Articles/63747/Exploring-GoogleGears-Wi-Fi-Geo-Locator-Secrets
关于ZIGBEE定位，RSSI转距离的问题 http://bbs.feibit.com/forum.php?mod=viewthread&amp;tid=8639
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/87d216f2b8288976ea548daa8b3d748a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b59b30e3ae8c9fa4da5d253df8bf115d/" rel="bookmark">
			Dubbo各种协议的应用场景，优缺点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		dubbo： 单一长连接和NIO异步通讯，适合大并发小数据量的服务调用，以及消费者远大于提供者。传输协议TCP，异步，Hessian序列化；
rmi： 采用JDK标准的rmi协议实现，传输参数和返回参数对象需要实现Serializable接口，使用java标准序列化机制，使用阻塞式短连接，传输数据包大小混合，消费者和提供者个数差不多，可传文件，传输协议TCP。
多个短连接，TCP协议传输，同步传输，适用常规的远程服务调用和rmi互操作。在依赖低版本的Common-Collections包，java序列化存在安全漏洞；
webservice： 基于WebService的远程调用协议，集成CXF实现，提供和原生WebService的互操作。多个短连接，基于HTTP传输，同步传输，适用系统集成和跨语言调用；
http： 基于Http表单提交的远程调用协议，使用Spring的HttpInvoke实现。多个短连接，传输协议HTTP，传入参数大小混合，提供者个数多于消费者，需要给应用程序和浏览器JS调用；
hessian： 集成Hessian服务，基于HTTP通讯，采用Servlet暴露服务，Dubbo内嵌Jetty作为服务器时默认实现，提供与Hession服务互操作。多个短连接，同步HTTP传输，Hessian序列化，传入参数较大，提供者大于消费者，提供者压力较大，可传文件；
memcache： 基于memcached实现的RPC协议
redis： 基于redis实现的RPC协议
默认使用dubbo协议
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d521a4154cef0384e2bb77ef2b33b6bf/" rel="bookmark">
			迅为iTOP-STM32MP157开发板双核cortex-A7,单核cortex-M4介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		迅为ITOP-STM32MP157是基于ST的STM32MP157芯片开发的一款开发平台。
在STM32MP157开发平台上，我们也做了比较多的创新，其中重要的一点就是，iTOP-STM32MP157核心板电源管理采用ST全新配套研制的PMIC电源管理芯片STPMU1A。为整个系统的稳定运行提供了更可靠的保证。
核心板通过了电磁兼容，电磁辐射，安规检测、高低温环境测验，采用邮票孔的连接方式，连接方式更加稳定和可靠。
底板板载4G接口(选配)、千兆以太网、WIFI蓝牙模块、HDMI、CAN、RS485、LVDS接口、温湿度传感器(选配)光环境传感器、六轴传感器、2路USB OTG、3路串口、CAMERA接口、ADC电位器、SPDIF、 SDIO接口等。
在迅为iTOP-STM32MP157开发板上，系统支持Buildroot、QT5.12.10、ubuntu_base_20.04、Debian、yocto、最小Linux系统。 系统驱动源码全开源，提供开发使用手册并长期稳定更新，资料不断升级。
适用于智能充电桩、物联网、工业控制、医疗、智能交通等，可用于任何通用工业和物联网应用。
核心板参数列表
CPU： STM32MP157A
架构： 双核 cortex-A7、单核 cortex-M4
主频： 650M
内存： 1G
存储： 8GB
工作电压： 直流 5V 供电
系统支持： 最小 Linux 系统、Buildroot、QT5.12.10、ubuntu_base_20.04、yocto 系统、Debian 系统
底板参数列表
尺寸 底板：190mm * 125mm
POWER： 电直流电源输入接口，12V/3A+电源输入
SWITCH： 电源开关
DIP SWITCH： 4 位拨码开关
ADC 电位器： 1 路
SDIO 接口： 1 个
JTAG 接口： 1 个
CAMERA 接口： 1 个
CAN 接口： 1 路 CAN
User Key： 5 个功能按键北京迅为电子有限公司 iTOP-STM32MP157 开发板使用手册
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d521a4154cef0384e2bb77ef2b33b6bf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eeaa9d8a9efcde3e2648f6c5d7855e3d/" rel="bookmark">
			Python: 将list中的每一个str型元素转换为int型元素（一维和二维）、将找出二维列表中的最大值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 例如 a=["1","2","3","4"]想要转换为 a=[1,2,3,4],有以下两种方法 方法一：列表推导式
a = [int(num) for num in a] 方法二：map()
a = list(map(int,a)) 针对二维列表
a=[["1","2","3","4"],["4","5","6","7"]] a = [[ int(num) for num in lst ] for lst in a] 找到二维列表中的最大值
a = [[1,2,3,4],[4,5,6,7]] 分两步走：
# 找出每一行的最大值 max_row = [max(row) for row in a] # 找出每一行最大值中的最大值 max_val = max(max_row) 分一步走：
max_val = max([max(row) for row in a]) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6066629daed8f91fd70400350b9fe9cc/" rel="bookmark">
			【珍藏的后端开发安装包整理】我是如何学会开始收藏一些安装包的？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何学会开始收藏安装包的 事件起因开始装程序我暂时收藏的一些安装包 不想听完絮叨的，可以直接点击目录跳转到收藏的安装包的位置，然后去下载 事件起因 前不久（就上周二 2012.12.14）出了一个意外，我的“小破电脑”笔记本在进地铁的安检口的时候（在包里立着送进去），那个口的高度刚好只有我的电脑放包里的高度，然后就被咔的一声给卡了，我立马把它拉平躺了下来，但还是晚了一步，已经明显听到了咔的一声，我从另一边把它取出来，当时立马拉开了包大致的查看了一下，能看到后盖已经裂开了
回家后更是拿上螺丝刀就是开干，然后后盖的螺丝有四颗已经滑丝在里面了，拧了半天，有颗螺帽已经掉下来和螺丝一起转，实在是没有办法，最后只好暴力拆解了，大致检查了一下主板，感觉是没有问题的，然后我就开机看看，发现屏幕就这样了，在屏幕没有光的情况下，很难看到裂痕
惨状：
当时整个心都碎了啊
没办法了啊，只好拿去修，一检查，说我屏幕肯定得换，这个我也明白，都这样子了没办法啊，然后就是当时开机后屏幕已经不亮了，说明主板出了一些问题，最后再三犹豫下
还是修吧，暂时还是不买新的了，不然又是得7-8k 暂时这台笔记本的配置也还行（自己也给这电脑改装过一些）
最后总的是花了 880 RMB
而且还得等四天，因为没有现成的屏幕，而且得慢慢检查主板到底哪儿有问题
开始装程序 这个就是噩耗的开始，因为电脑坏了的第二天还是得工作啊，有任务内容的啊，我就去找人借了一台电脑（办公本的那种 但配置也还行，一些后端也还是能跑得动，但就是这台电脑没有装环境和软件!!!）
然后我去各种环境和软件的官网去找我需要下载的环境和软件，并且去搜安装教程，就这样，一天过去了 呜呜呜，库鲁西
然后我就开始收藏各种软件和需要用到的安装包了
我暂时收藏的一些安装包 原本想传这个平台上的，但是大小被限制了
百度云盘下载链接：
链接：https://pan.baidu.com/s/1Kf-chW8D6uUXlrq1o4-GWA
提取码（可直接复制剪贴板）：
CMCQ 阿里云盘下载（下载速度快 &lt;至少比百度快&gt; 推荐）：
啊，这我上传完了阿里云盘 点击分享才发现 这个zip文件说是不支持分享，淦哦
不知道有没有什么好的解决办法
因为自己是搞java后端开发的，所以都是一些自己会用到的软件
里面的内容目录呢大致是如下的，且每一个里面都有附一个自己手写的安装教程，都比较简单：
目前的大小是1.93G
待后续更新吧，再见
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f3ee8f5bb88494185490e0ec6e38dc4/" rel="bookmark">
			c&#43;&#43; map与unordered_map区别及使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转自：map和unordered_map的差别和使用_陈云佳的专栏-CSDN博客_map和unordered
需要引入的头文件不同
map: #include &lt; map &gt;
unordered_map: #include &lt; unordered_map &gt;
内部实现机理不同
map： map内部实现了一个红黑树（红黑树是非严格平衡二叉搜索树，而AVL是严格平衡二叉搜索树），红黑树具有自动排序的功能，因此map内部的所有元素都是有序的，红黑树的每一个节点都代表着map的一个元素。因此，对于map进行的查找，删除，添加等一系列的操作都相当于是对红黑树进行的操作。map中的元素是按照二叉搜索树（又名二叉查找树、二叉排序树，特点就是左子树上所有节点的键值都小于根节点的键值，右子树所有节点的键值都大于根节点的键值）存储的，使用中序遍历可将键值按照从小到大遍历出来。
unordered_map: unordered_map内部实现了一个哈希表（也叫散列表，通过把关键码值映射到Hash表中一个位置来访问记录，查找的时间复杂度可达到O(1)，其在海量数据处理中有着广泛应用）。因此，其元素的排列顺序是无序的。哈希表详细介绍
优缺点以及适用处
map：
优点：
有序性，这是map结构最大的优点，其元素的有序性在很多应用中都会简化很多的操作
红黑树，内部实现一个红黑书使得map的很多操作在lgn的时间复杂度下就可以实现，因此效率非常的高
缺点： 空间占用率高，因为map内部实现了红黑树，虽然提高了运行效率，但是因为每一个节点都需要额外保存父节点、孩子节点和红/黑性质，使得每一个节点都占用大量的空间
适用处：对于那些有顺序要求的问题，用map会更高效一些
unordered_map：
优点： 因为内部实现了哈希表，因此其查找速度非常的快
缺点： 哈希表的建立比较耗费时间
适用处：对于查找问题，unordered_map会更加高效一些，因此遇到查找问题，常会考虑一下用unordered_map
总结：
内存占有率的问题就转化成红黑树 VS hash表 , 还是unorder_map占用的内存要高。
但是unordered_map执行效率要比map高很多
对于unordered_map或unordered_set容器，其遍历顺序与创建该容器时输入的顺序不一定相同，因为遍历是按照哈希表从前往后依次遍历的
map和unordered_map的使用
unordered_map的用法和map是一样的，提供了 insert，size，count等操作，并且里面的元素也是以pair类型来存贮的。其底层实现是完全不同的，上方已经解释了，但是就外部使用来说却是一致的。
C++ Map常见用法说明
常用操作汇总举例： #include &lt;iostream&gt; #include &lt;unordered_map&gt; #include &lt;map&gt; #include &lt;string&gt; using namespace std; int main() { //注意：C++11才开始支持括号初始化 unordered_map&lt;int, string&gt; myMap={{ 5, "张大" },{ 6, "李五" }};//使用{}赋值 myMap[2] = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5f3ee8f5bb88494185490e0ec6e38dc4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db93843bebbcb7600d65dffc31432b99/" rel="bookmark">
			vue安装脚手架步骤(vue2脚手架&#43;vue3脚手架)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一步：查看node 版本号 如果低于 版本10 的话安装最新版node
如果没有cnpm 的话 需要安装cnpm 如果已经安装过cnpm 可以跳过 安装cnpm的命令是：
npm install -g cnpm --registry=https://registry.npm.taobao.org
第二步：cmd终端中安装vue脚手架 cnpm i @vue/cli -g
安装成功后可以执行 vue -V (注意：-V 是大写) 查看vue版本号 来检测是否成功
第三步：
创建项目： 在想要创建项目的文件夹中打开终端，执行 vue create demo （demo是要创建的项目的名称）（打开终端的命令是Ctrl+ "~" 键）
如果出现如下界面 输入y 意思是问你要不要使用淘宝镜像，没有这个界面的话执行下一步就行 ①第一次创建项目需要手动选择项目配置 上下键进行切换 按回车键执行下一步 ②通过上下箭头按空格确定，然后回车进入下一步 ③选择2.x就是vue2，选择3.x就是vue3 ④选择的路由的模式 输入n不使用默认路由hish模式 按回车下一步 ⑤选择如下 ⑥把配置文件放在一起还是选择放在package.json ⑦是否保存本次配置的脚手架模板，方便下次直接选择使用。如果不需要就选择n多次使用相同配置的情况下选择y，进行回车 ⑧设置vue模板名称 ⑨出现如图所示就是创建成功啦！恭喜要你进入苦逼的代码海洋了... 下次直接使用vue create 项目名 就可以直接使用vue模板，不用重复选择了~@v@~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d989be42f03973a0a2ebca5aae38258/" rel="bookmark">
			Ubuntu（WSL）中MySQL8.0安装及卸载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 MySQL8.0安装1.1 启动MySQL服务1.2 MySQL登录1.2.1 第一种登录方法1.2.2 第二种登录方法 1.3 更改root用户密码1.4 刷新缓存1.5 重启MySQL服务1.6 设置root用户的远程访问1.7 修改MySQL配置文件实现真正的远程访问 2 MySQL8.0卸载 1 MySQL8.0安装 sudo apt install mysql-server 1.1 启动MySQL服务 WSL子系统Ubuntu中不包含systemctl命令，使用service命令
# 查看MySQL服务运行状态 sudo service mysql status * MySQL is stopped. #启动MySQL服务 sudo service mysql start * Starting MySQL database server mysqld * su: warning: cannot change directory to /nonexistent: No such file or directory [ OK ] 查看MySQL是否启动成功
ps -ef | grep mysql mysql 13613 120 0 15:49 ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5d989be42f03973a0a2ebca5aae38258/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/588bba4386eb32805af404d2a89d22b4/" rel="bookmark">
			JAVA三大集合（map、list、set）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Map接口和Collection接口是所有集合框架的父接口： Collection接口的子接口包括：Set接口和List接口
Map接口的实现类主要有：HashMap、TreeMap、Hashtable、ConcurrentHashMap以及Properties等
Set接口的实现类主要有：HashSet、TreeSet、LinkedHashSet等
List接口的实现类主要有：ArrayList、LinkedList、Stack以及Vector等
List，Set，Map三者的区别？List、Set、Map 是否继承自 Collection 接口？List、Map、Set 三个接口存取元素时，各有什么特点？ Collection集合主要有List和Set两大接口 （1）List：是一个有序，元素可以重复。常用的实现类有 ArrayList、LinkedList 和 Vector。
（2）Set：是一个无序，不可以存储重复元素，只允许存入一个null元素，Set 接口常用实现类是 HashSet、LinkedHashSet 以及 TreeSet。
Map Map是一个键值对集合，存储键、值和之间的映射。 Key无序，唯一；value 不要求有序，允许重复。Map没有继承于Collection接口，从Map集合中检索元素时，只要给出键对象，就会返回对应的值对象。
Map 的常用实现类：HashMap、TreeMap、HashTable、LinkedHashMap、ConcurrentHashMap
（1）Map 存元素和取元素和删除（put、get、remove）
import java.util.HashMap; /** * Map 存元素和取元素和删除（put、get、remove） * @author 小治的高等数学 * */ public class Map1 { public static void main(String[] args) { // 创建 HashMap 对象 Sites HashMap&lt;String, String&gt; sites = new HashMap&lt;String, String&gt;(); // 或者 // Map&lt;String, String&gt; sites = new HashMap&lt;String, String&gt;(); // 添加键值对 sites.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/588bba4386eb32805af404d2a89d22b4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70d77a3e3e9386587b9f4058e7a46736/" rel="bookmark">
			(十)性能分析工具的使用(上)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		性能分析工具的使用 1. 数据库服务器的优化步骤2. 查看系统性能参数3. 统计SQL的查询成本：last_query_cost4. 定位执行慢的 SQL：慢查询日志4.1 开启慢查询日志参数1. 开启slow_query_log2. 修改long_query_time阈值 4.2 查看慢查询数目4.3 案例演示4.4 测试及分析4.5 慢查询日志分析工具：mysqldumpslow4.6 关闭慢查询日志4.7 删除慢查询日志 5. 查看 SQL 执行成本：SHOW PROFILE 在数据库调优中，我们的目标就是 响应时间更快，吞吐量更大。利用宏观的监控工具和微观的日志分析可以帮我们快速找到调优的思路和方式。 1. 数据库服务器的优化步骤 当我们遇到数据库调优问题的时候，该如何思考呢？这里把思考的流程整理成下面这张图。
整个流程划分成了 观察（Show status） 和 行动（Action） 两个部分。字母 S 的部分代表观察（会使用相应的分析工具），字母 A 代表的部分是行动（对应分析可以采取的行动）。
我们可以通过观察了解数据库整体的运行状态，通过性能分析工具可以让我们了解执行慢的SQL都有哪些，查看具体的SQL执行计划，甚至是SQL执行中的每一步的成本代价，这样才能定位问题所在，找到了问题，再采取相应的行动。
详细解释一下这张图:
首先在S1部分，我们需要观察服务器的状态是否存在周期性的波动。如果存在周期性波动，有可能是周期性节点的原因，比如双十一、促销活动等。这样的话，我们可以通过A1这一步骤解决，也就是加缓存或者更改缓存失效策略。
如果缓存策略没有解决，或者不是周期性波动的原因，我们就需要进一步分析查询延迟和卡顿的原因。接下来进入S2这一步，我们需要开启慢查询。慢查询可以帮我们定位执行慢的sQL语句。我们可以通过设置long_query_time参数定义“慢”的阈值，如果SQL执行时间超过了long_query_time，则会认为是慢查询。当收集上来这些慢查询之后，我们就可以通过分析工具对慢查询日志进行分析。
在S3这一步骤中，我们就知道了执行慢的SQL，这样就可以针对性地用EXPLAIN查看对应SQL语句的执行计划，或者使用show profile查看sQL中每一个步骤的时间成本。这样我们就可以了解SQL查询慢是因为执行时间长，还是等待时间长。
如果是SQL等待时间长，我们进入A2步骤。在这一步骤中，我们可以调优服务器的参数，比如适当增加数据库缓冲池等。如果是SQL执行时间长，就进入A3步骤，这一步中我们需要考虑是索引设计的问题?还是查询关联的数据表过多?还是因为数据表的字段设计问题导致了这一现象。然后在这些维度上进行对应的调整。
如果A2和A3都不能解决问题，我们需要考虑数据库自身的SQL查询性能是否已经达到了瓶颈，如果确认没有达到性能瓶颈，就需要重新检查，重复以上的步骤。如果已经达到了性能瓶颈，进入A4阶段，需要考虑增加服务器，采用读写分离的架构，或者考虑对数据库进行分库分表，比如垂直分库、垂直分表和水平分表等。
以上就是数据库调优的流程思路。如果我们发现执行SQL时存在不规则延迟或卡顿的时候，就可以采用分析工具帮我们定位有问题的SQL，这三种分析工具你可以理解是SQL调优的三个步骤:慢查询、EXPLAIN和SHOWPROFILING。
小结：
2. 查看系统性能参数 在MySQL中，可以使用 SHOW STATUS 语句查询一些MySQL数据库服务器的 性能参数 、 执行频率 。 SHOW STATUS语句语法如下：
SHOW [GLOBAL|SESSION] STATUS LIKE '参数'; 一些常用的性能参数如下：
• Connections：连接MySQL服务器的次数。
• Uptime：MySQL服务器的上线时间。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/70d77a3e3e9386587b9f4058e7a46736/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a055719a370342da57ac1edaa714222/" rel="bookmark">
			git 报错： error: src refspec main does not match any；Unable to access ‘https://github.com/xxx/xxxxxx.g
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		git上传项目时，遇到的问题：error: src refspec main does not match any
（之前的问题被覆盖掉了，所以报错不全）
这个问题的主要原因是因为在初始化的时候，没有再仓库中创建对应分支造成的，因此解决方法就是，在仓库或者本地使用以下命令创建一个分支即可。
git commit之后，push的时候报错：
Unable to access 'https://github.com/xxx/xxxxxx.git/': OpenSSL SSL_read: Connection was reset, errno 10054 这个问题是因为网络连接不稳定的原因所导致的，如果想要网络稳定，可以在网上搜索相关方法解决这个问题；当然如果你认为网络不稳定不想是用github，也可以选择国内的gitee码云！
国内推荐使用码云作为代码仓库！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/341c48a11feb459a2fe87c737dabed15/" rel="bookmark">
			USB大容量存储类规范概述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1 简述2 子类代码3 协议代码参考资料 1 简述 USB Mass Storage Class Working Group (CWG)在发展4种大容量存储类的标准规范，包括：
USB Mass Storage Class Control/Bulk/Interrupt (CBI) TransportUSB Mass Storage Class Bulk-Only TransportUSB Mass Storage Class ATA Command BlockUSB Mass Storage Class UFI Command Specification 而上面这些标准规范所使用的命令集，则是复用原本已存在的协议，包括以下几种：
Advanced Technology Attachment Packet Interface (ATAPI) for Floppies. SFF-8070i, available fromGlobal Engineering, (800)-854-7179.Advanced Technology Attachment Packet Interface (ATAPI) for CD-ROMs. SFF-8020i, available fromGlobal Engineering, (800)-854-7179.Advanced Technology Attachment Packet Interface (ATAPI) for Tape.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/341c48a11feb459a2fe87c737dabed15/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cfe22399c68c4ebb59fba7c4c6052a12/" rel="bookmark">
			vs2017安装驱动环境版本的选择
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我的VS是10.0.17763的，应该下载哪个WDK呢？
下载地址：以前的 WDK 版本和其他下载 - Windows drivers | Microsoft Docs
发现下载这个1809的，安装的时候才和VS里的SDK保持一致，
如果不一致安装的时候会有红色信息提示。
安装大概要好几分钟，安装完成后即可创建驱动WDF了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f019f86ac890cbf5217d591c2e05d00a/" rel="bookmark">
			Argo workflow 案例练习和配置详细解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参数化 - parameters hello-world-parameters.yaml文件解析
apiVersion: argoproj.io/v1alpha1 kind: Workflow metadata: generateName: hello-world-parameters- spec: entrypoint: whalesay # 调用 whalesay 模板 arguments: # 传递给函数的参数 parameters: # 声明参数 - name: message # Key value: hello world # value templates: - name: whalesay # whalesay 模板 inputs: parameters: - name: message container: image: docker/whalesay command: [cowsay] args: ["{{inputs.parameters.message}}"] 提交此工作流时，可以指定实际参数值：
[root@k8s-master01 argo]# argo submit -n argo arguments-parameters.yaml -p message="goodbye world" [root@k8s-master01 argo]# argo logs -n argo hello-world-parameters-xxx 自定义 Parameter 数据生产端和消费端 output 作为生产端信息输出给 input 作为信息消费端，以parameter参数的方式。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f019f86ac890cbf5217d591c2e05d00a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2289b1c33006d45e330033ef27ff9437/" rel="bookmark">
			微信猜谜语小程序源码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		猜灯谜小程序源码 猜字谜微信小程序源码
源码介绍
没有流量主，其实可以自己加。当提示数量用完，观看激励视频的数量等等。
当然你看demo的时候也能看出界面有多喜庆，马上就要过年了，所以各种界面可能会更喜庆。
这个小程序是无服务器无域名搭建的。用微信开发者工具打开源代码上传审核就行了！
在灯笼小程序上解谜可以分为两种模式:青铜模式(普通)和国王模式(困难)。此外，还支持猜题中的回答提示。当然，次数是有限制的。
这个小程序不需要设置合法域名！上传就可以用了
学习资料地址：微信猜谜语小程序源码-蓝秦云
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a70c4fe93b6cdf86103020ea2367a2fb/" rel="bookmark">
			新唐NUC972 Linux（一）：USB烧写linux出厂镜像
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、硬件连接二、安装驱动三、烧写linux程序四、运行程序五、总结 前言 今天开始进军linux，学了那么久单片机，也摸得七七八八，至少点个灯还是会的。本人之所以买酷客的linux开发板主要是便宜，资料也算齐全，虽然没有原子那么好，不过也够了，找那么多借口，其实就是qiong。今天先从USB烧录官方提供的linux相关程序到芯片开始吧。
一、硬件连接 1、连接电源线 2、RS232转USB，用于在电脑串口超级终端中查看调试信息。 3、USB数据线，需要安装驱动，烧录就是通过这条线。 二、安装驱动 新唐USB驱动自己下载安装–&gt;&gt;
注意：新唐USB驱动安装前需要将启动开关切换至USB启动再给开发板上电，最后进行驱动安装。
三、烧写linux程序 1、全片擦除
2、烧写uboot-spl，只有NAND Flash才需要烧写这个，用于将NAND中的程序uboot搬运至DDR运行
3、烧写uboot，用于解压搬运linux系统到DDR运行
4、烧写ENV，配置uboot参数
5、烧写linux镜像
6、烧写文件系统
四、运行程序 1、开发板在不断电状态下开关切换至NAND启动，按下开发板复位按钮即可重新启动，由于文件系统中没有可运行的应用程序，所以开发板只显示linux内核开机画面。
五、总结 惊喜和噩梦的开始…
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ccd45928756bcd390eb0fcca880c3c6/" rel="bookmark">
			Latex 中转置T的几种写法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Latex写作环境，常常需要对矩阵或向量进行转置，关于转置T，实际上有不同的写法。
如下所示：
\documentclass{article}
\usepackage{amssymb}
\begin{document}
$\mathbf{A}^\mathrm{T}$ $\mathbf{A}^\top$ %&lt;------专业论文中常用
$\mathbf{A}^\mathsf{T}$
$\mathbf{A}^\intercal$ \end{document}
运行结果如下图所示。
其中第二种，细瘦的T更受欢迎！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6188203c63eddae9d7a6f185bb9f04e/" rel="bookmark">
			buuctf刷题记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2022-1-16 reverse2 扔到IDA64里解析， F5生成伪代码 通过分析得出经过一定的变换后与flag进行比较的
查看flag的值，是{hacking_for_fun} 再返回前面看如何对flag进行变换的，将105、114、49转换成值， 箭头所指的函数功能为，把flag中存在的’i’以及’r’转换成’1’，进而得出正确flag。
2022-1-17 内涵的软件 下载好以后发现是乱码的exe文件，拖到ExeinfoPE里查看信息，
没有加壳，用IDA打开，查看main函数
可以看到跳转到main0函数里 打开main0函数 F5看伪代码， 看到一串字符串，直接尝试，就是了，不得不吐槽一下，这字符串我以为还是加密的呢，然而并不是。
2022-1-18 新年快乐 先放到ExeinfoPE里查看
发现是加壳的
使用脱壳工具脱一下壳
脱壳后再扔到IDA里，F5查看，
代码逻辑如图，比对str1和str2，str2的值直接就给了。就是"HappyNewYear!"。
2022-1-19 XOR 下载下来是个无后缀文件，扔到IDA64里解析，看到main函数，直接F5， 看到是对_b跟global做对比，所以看一下global什么内容，跟进是字符串。
写一个python脚本
s = ['f',0xA,'k',0xC,'w&amp;O.@',0x11,'x',0xD,'Z;U',0x11,'p',0x19,'F',0x1F,'v"M#D',0xE,'g',6,'h',0xF,'G2O',0] for i in range(1,len(s)): if(isinstance(s[i],int)): #如果为int类型，转换为char类型 s[i]=chr(s[i]) s = ''.join(s) #将列表拼接成字符串 flag = 'f' #flag的第一位不进行异或，所以直接写为f for i in range(1,len(s)): flag += chr(ord(s[i])^ord(s[i-1])) #异或操作，两次异或会还原 print(flag) 2022-1-20 reverse3 下载下来是reverse_3.exe，扔到ExeinfoPE里，没加壳，扔到IDA里，看见了main0，直接F5，
int __cdecl main_0(int argc, const char **argv, const char **envp) { size_t v3; // eax const char *v4; // eax size_t v5; // eax char v7; // [esp+0h] [ebp-188h] char v8; // [esp+0h] [ebp-188h] signed int j; // [esp+DCh] [ebp-ACh] int i; // [esp+E8h] [ebp-A0h] signed int v11; // [esp+E8h] [ebp-A0h] char Destination[108]; // [esp+F4h] [ebp-94h] BYREF char Str[28]; // [esp+160h] [ebp-28h] BYREF char v14[8]; // [esp+17Ch] [ebp-Ch] BYREF for ( i = 0; i &lt; 100; ++i ) { if ( (unsigned int)i &gt;= 0x64 ) j____report_rangecheckfailure(); Destination[i] = 0; } sub_41132F("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d6188203c63eddae9d7a6f185bb9f04e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9acb0a614f75aca8b674b616d0540ef7/" rel="bookmark">
			kotlin学习第二天：类，扩展方法，高阶函数初步学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		kotlin学习第二天 1.类和接口1.类2.接口3.抽象类 2.扩展方法3.空类型安全1.?=赋空值2.!!.实现强制不为空类型3.安全转换 as? 4.分支表达式1.if2.when3.try..catch 5.Lambda表达式6.高阶函数7.内联函数1.inline2.noinline3.crossinline 1.类和接口 1.类 1.kotlin中使用constructor作为构造方法；java中则用类名相同来实现构造方法
2.kotlin定义变量时需要赋初始值；但是Java不需要，默认赋值。
3.用fun 名称()来定义函数，关于函数的详细知识可以看我的kotlin的上一篇文章。
4.类默认为public属性
类定义代码：
class SimpleClass1 { var y:Int=0 var x:Int=0 constructor(x:Int) { this.x=x; } fun simple(){} } 类的调用
val simpleClass1=SimpleClass1(8); println(simpleClass1.x) 类的另外一种定义
//类的定义 class SimpleClass(var x:Int,val y:String) { fun y(){} } //类的调用 val simpleClass=SimpleClass(9,"Hello") println(simpleClass.x) 2.接口 //接口的定义 interface SimpleInf{ fun simpleMethod() } //1.Java中使用implement来声明接口，但是Kotlin中使用":"来声明接口 //2.Java中override可省略，但是Kotlin中override是强制要写 class SimpleClass2(var x:Int):SimpleInf{ override fun simpleMethod() { TODO("Not yet implemented") } } 3.抽象类 强调一个不同的地方：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9acb0a614f75aca8b674b616d0540ef7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/abdc4a53c714154c8317eb4cb4bba9ce/" rel="bookmark">
			若依Bootstrap版本--冻结列无效问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.引入js文件 &lt;th:block th:include="include :: bootstrap-table-fixed-columns-js" /&gt; 如图：
2.设置冻结参数： fixedColumns:true, //默认为false禁用冻结列，设为true启用冻结列 fixedNumber:1, // 从右边开始数，冻结的列数 fixedRightNumber:2, // 从右边开始数，冻结的列数 和columns 同级别。千万不要放错位置
效果：
3.无效情况说明 这时效果并没有出现，按照官方回复是因为，列没有超出屏幕。
缩小浏览器屏幕： 没用
创建很多重复列： 有用。
4.修改 “被冻结列” 的宽度 还没有找到，希望找办法的兄弟给个回复
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c09a5546662ab58f477f71d00a45035/" rel="bookmark">
			AttributeError: module ‘tensorflow_core.compat.v1‘ has no attribute ‘contrib‘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 import tensorflow.compat.v1 as tf #原 return tf.contrib.rnn.DropoutWrapper(cell, output_keep_prob=self.keep_prob) #改为 return tf.nn.rnn_cell.DropoutWrapper(cell, output_keep_prob=self.keep_prob) tf.placeholder() is not compatible with eager execution #加上 tf.compat.v1.disable_eager_execution() 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/645e98e5140805c2095184e91616ae4a/" rel="bookmark">
			归并排序 C语言描述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 利用递归进行对算法的优化十分常见，那么我们该如何对排序进行优化呢？
首先，我们对递归应有图形形象的理解，树结构通常便是递归形成，于是我们在理解或是书写递归时，可以想象树不断向下扎根分叉。
然后我在下面展示归并排序的算法模板：
void m(int q[], int l, int r) { if (l &gt;= r) return; //递归必备的终末状态 int mid = l + r &gt;&gt; 1; m(q, l, mid), m(q, mid + 1, r); int k = 0, i = l, j = mid + 1; while (i &lt;= mid &amp;&amp; j &lt;= r) if (q[i] &lt;= q[j]) tmp[k ++ ] = q[i ++ ]; else tmp[k ++ ] = q[j ++ ]; while (i &lt;= mid) tmp[k ++ ] = q[i ++ ]; while (j &lt;= r) tmp[k ++ ] = q[j ++ ]; for (i = l, j = 0; i &lt;= r; i ++, j ++ ) q[i] = tmp[j]; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7abbc42d63ad2df31da87295277da4a7/" rel="bookmark">
			前端系列——vue2&#43;高德地图web端开发（输入提示）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vue2+高德地图web端开发（输入提示） 前言页面 基础使用1.在MapContainer.vue的plugins中引入'AMap.PlaceSearch'控件2.在MapContainer.vue中的date中定义autoOptions和auto3.在src目录下创建eventBus.js并创建vue实例4.在Search.vue和MapContainer.vue中引入eventBus.js5.在Search.vue中设置input输入框的动态id绑定以及定义sendId函数$emit传出结合mouted（）调用6.在MapContainer.vue中使用bus.on进行接收并传给autoOptions的input结合created（）进行接收7.new出map对象调用接收完整MapContainer.vue 结果展示 前言 我们可以看到这个功能是十分强大的所以在开发时被广泛使用
但是官方没有提供任何有关vue使用的文档
而且我的项目中搜索框是以组件方式独立的，我想大多数的项目中也是这样的，都是以组件引入的方式来构成页面的
页面 本文使用两个页面
search.vueMapContainer.vue 基础 本文基础为vue兄弟组件之间的数据传输，mounted生命周期,created生命周期
使用 1.在MapContainer.vue的plugins中引入’AMap.PlaceSearch’控件 plugins: ['AMap.AutoComplete'] 2.在MapContainer.vue中的date中定义autoOptions和auto autoOptions: { input: '' }, auto: null, 其中auto是用于我们进行输入提示的接收变量，由于是new出的一个对象所以定义初始值为null
而autoOptions是我们要接收的input输入框的id对象所以在其中定义input接收值为空即可
3.在src目录下创建eventBus.js并创建vue实例 import Vue from 'vue' //兄弟组件之间进行通行 export default new Vue() 你没看错就两行
4.在Search.vue和MapContainer.vue中引入eventBus.js import bus from '@/eventBus/eventBus.js' 5.在Search.vue中设置input输入框的动态id绑定以及定义sendId函数$emit传出结合mouted（）调用 &lt;el-input placeholder="请输入内容" v-model="input" :id="search_id"&gt; &lt;script&gt; import bus from '@/eventBus/eventBus.js' export default { data() { return { search_id: 'searchId', input: '' } }, methods: { sendId() { bus.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7abbc42d63ad2df31da87295277da4a7/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/168/">«</a>
	<span class="pagination__item pagination__item--current">169/321</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/170/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大白的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>